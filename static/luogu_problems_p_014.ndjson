{"pid": "P4539", "type": "P", "difficulty": 5, "samples": [["4 2 3.5\n20 30 50 20", "7.000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2006", "四川", "各省省选", "区间 DP"], "title": "[SCOI2006] zh_tree", "background": null, "description": "张老师根据自己工作的需要，设计了一种特殊的二叉搜索树。\n\n他把这种二叉树起名为 zh_tree，对于具有 $n$ 个结点的 zh_tree，其中序遍历恰好为 $(1,2,3,\\cdots,n)$，其中数字 $1,2,3,\\cdots,n$ 是每个结点的编号。$n$ 个结点恰好对应于一组学术论文中出现的n个不同的单词。\n\n第j个单词在该组论文中出现的次数记为 $d_j$，例如，$d_2=10$表示第 $2$ 个结点所对应的单词在该组论文中出现了10次。设该组论文中出现的单词总数为 S，显然，$S=d_1+d_2+…+d_n$。记 $f_j=\\frac{d_j}{S}$ 为第 j 个单词在该组论文中出现的概率（频率）。 \n\n张老师把根结点深度规定为0，如果第 $j$ 个结点的深度为 $r$，则访问该结点的代价 $h_j$ 为 $h_j=k(r+1)+c$，其中 $k$，$c$ 为已知的不超过 $100$ 的正常数。\n\n则zh_tree是满足以下条件的一棵二叉树：它使 $h_1f_1+h_2f_2+…+h_nf_n$ 达到最小。\n\n我们称上式为访问 zh_tree 的平均代价。 请你根据已知数据为张老师设计一棵 zh_tree。", "inputFormat": "第 $1$ 行：$3$ 个用空格隔开的正数： $n,k,c$ 其中 $n<30$，为整数。$k$，$c$ 为不超过 $100$ 的正实数。 第 $2$ 行：$n$ 个用空格隔开的正整数，为每个单词出现的次数（次数 $<200$）。", "outputFormat": "一行一个正实数，保留 $3$ 位小数，为访问 Zh_tree 的最小平均代价。\n\n----\n\n原题需要构造方案并输出中序遍历。出于各种原因我们决定直接删去第二问以兼容现在的题解与代码。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2006] zh_tree", "background": "", "description": "Teacher Zhang designed a special binary search tree for his work.\n\nHe named this binary tree zh_tree. For a zh_tree with $n$ nodes, its inorder traversal is exactly $(1, 2, 3, \\cdots, n)$, where the numbers $1, 2, 3, \\cdots, n$ are the identifiers of the nodes. The $n$ nodes correspond to $n$ distinct words that appear in a set of academic papers.\n\nLet the $j$-th word appear $d_j$ times; for example, $d_2 = 10$ means that the word corresponding to node $2$ appears $10$ times. Let $S$ be the total number of word occurrences in this set of papers. Obviously, $S = d_1 + d_2 + \\cdots + d_n$. Define $f_j = \\frac{d_j}{S}$ as the probability (frequency) of the $j$-th word.\n\nThe root node has depth $0$. If node $j$ has depth $r$, then its access cost $h_j$ is $h_j = k (r + 1) + c$, where $k$ and $c$ are known positive constants not exceeding $100$.\n\nA zh_tree is a binary tree that minimizes $h_1 f_1 + h_2 f_2 + \\cdots + h_n f_n$.\n\nWe call the expression above the average access cost of the zh_tree. Please design a zh_tree based on the given data.", "inputFormat": "Line 1: Three positive numbers separated by spaces: $n, k, c$, where $n < 30$ is an integer. $k$ and $c$ are positive real numbers not exceeding $100$.\n\nLine 2: $n$ positive integers separated by spaces, the occurrence counts for each word (each count $< 200$).", "outputFormat": "Output one positive real number on a single line, rounded to $3$ decimal places: the minimal average access cost of the zh_tree.", "hint": "The original problem also required constructing the tree and outputting its inorder traversal. For various reasons, we removed that second requirement to keep compatibility with existing solutions and code.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2006] zh_tree", "background": null, "description": "张老师根据自己工作的需要，设计了一种特殊的二叉搜索树。\n\n他把这种二叉树起名为 zh_tree，对于具有 $n$ 个结点的 zh_tree，其中序遍历恰好为 $(1,2,3,\\cdots,n)$，其中数字 $1,2,3,\\cdots,n$ 是每个结点的编号。$n$ 个结点恰好对应于一组学术论文中出现的n个不同的单词。\n\n第j个单词在该组论文中出现的次数记为 $d_j$，例如，$d_2=10$表示第 $2$ 个结点所对应的单词在该组论文中出现了10次。设该组论文中出现的单词总数为 S，显然，$S=d_1+d_2+…+d_n$。记 $f_j=\\frac{d_j}{S}$ 为第 j 个单词在该组论文中出现的概率（频率）。 \n\n张老师把根结点深度规定为0，如果第 $j$ 个结点的深度为 $r$，则访问该结点的代价 $h_j$ 为 $h_j=k(r+1)+c$，其中 $k$，$c$ 为已知的不超过 $100$ 的正常数。\n\n则zh_tree是满足以下条件的一棵二叉树：它使 $h_1f_1+h_2f_2+…+h_nf_n$ 达到最小。\n\n我们称上式为访问 zh_tree 的平均代价。 请你根据已知数据为张老师设计一棵 zh_tree。", "inputFormat": "第 $1$ 行：$3$ 个用空格隔开的正数： $n,k,c$ 其中 $n<30$，为整数。$k$，$c$ 为不超过 $100$ 的正实数。 第 $2$ 行：$n$ 个用空格隔开的正整数，为每个单词出现的次数（次数 $<200$）。", "outputFormat": "一行一个正实数，保留 $3$ 位小数，为访问 Zh_tree 的最小平均代价。\n\n----\n\n原题需要构造方案并输出中序遍历。出于各种原因我们决定直接删去第二问以兼容现在的题解与代码。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4540", "type": "P", "difficulty": 6, "samples": [["3 5\n2 1 4\n2 2 4\n3 3 4 5\n2 20 1 100 \n1 18 1 200 \n3 28 1 800 \n21 30 3 1500 \n19 21 1 400 ", "1800"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2006", "各省省选", "湖南", "枚举", "排序", "位运算"], "title": "[HNOI2006] 军机调度", "background": "", "description": "凯萨拥有一支由n个人组成的雇佣军，他们靠在威尼斯商行接任务过活。\n\n这支军队的成份比较复杂，不同的人往往具有不同的技能，有的人还拥有多项技能。\n\n威尼斯商行的任务也参差不齐，有的需要几个人合作完成，有的只需要一个人独立完成：有的很简单，不需要耗多少时间，因此报酬也较低，有的很有难度，需要多个人长期合作完成，因此报酬就高。完成这些任务的时间不会超过一个月。并且，一个人不能同时执行两项任务，也不能中途加入或者退出任务。但可以不执行任何任务。\n\n一项只需要n个人来完成的任务，如果执行该任务的人数p大于n,那么反而会得到更少的报酬，即原报酬的1/(p-n+1)。\n\n凯萨是一位英明的领袖，他往往在每个月的月底召开军事会议，总结上个月的成果，发给大家报酬，并指派下个月的任务。\n\n请问，凯萨应该怎样指派任务，才能使总报酬最高？总报酬为多少？", "inputFormat": "一行包含两个正整数n,m。彼此用空格隔开，\n\n其中n〈10表示雇佣军的人数，m〈15表示下个月可选的任务数。\n\n接下来的n行中第i行（对应文件的第i+1行）的第一个整数小于等于表示编号为i的雇佣军可执行的任务数\n\n后面的整数是编号为i的雇佣军可以执行的所有任务的编号，这些整数之间用空格隔开。\n\n最后的m行中，每行有四个整数b、e、p和r，彼此之间用空格隔开，\n\n其中第j行（对应整个文件的第n+j+1行）是编号为j的任务的描述：\n\n0<b<32表示该任务的开始日（这一天会被计入任务所需的时间中），\n\n0<e<32表示该任务的结束日（这一天也会被计入任务所需的时间中），\n\np<10表示该任务所需人数，0<r<100000表示该任务的报酬。", "outputFormat": "第一行只有一个整数t,表示最多可获得的总报酬", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2006] Military Dispatch", "background": "", "description": "Caesar leads a mercenary troop of $n$ people who take jobs from the Venetian Trading House.\n\nThe troop is diverse: different people have different skills, and some have multiple skills.\n\nThe jobs vary a lot. Some require several people to cooperate; some can be done by a single person. Some are simple, take little time, and thus pay less; others are difficult, require many people to work together for a long period, and thus pay more. Each job lasts no more than one month. A person cannot work on two jobs at the same time, and cannot join or leave a job midway. However, a person may stay idle and do no job.\n\nFor a job that requires $p$ people, if the number of assigned people is $x > p$, then the payment becomes the original payment divided by $(x - p + 1)$. If $x < p$, the job cannot be completed. Only people who are capable of a job may be assigned to that job.\n\nCaesar holds a military meeting at the end of each month to summarize the results, pay everyone, and assign the next month’s jobs.\n\nHow should Caesar assign the jobs to maximize the total payment? What is the maximum total payment?", "inputFormat": "- The first line contains two positive integers $n$ and $m$, separated by a space, where $n < 10$ is the number of mercenaries and $m < 15$ is the number of available jobs for the next month.\n- The next $n$ lines describe the capabilities of each mercenary. On line $i$ (corresponding to mercenary $i$), the first integer $k_i$ satisfies $0 \\le k_i \\le m$ and denotes how many jobs mercenary $i$ can perform. It is followed by $k_i$ distinct integers, the IDs of the jobs that mercenary $i$ can perform, separated by spaces.\n- The last $m$ lines describe the jobs. On line $j$ (corresponding to job $j$), there are four integers $b$, $e$, $p$, and $r$, separated by spaces:\n  - $0 < b < 32$: the start day (this day is counted in the job duration),\n  - $0 < e < 32$: the end day (this day is also counted in the job duration),\n  - $p < 10$: the required number of people,\n  - $0 < r < 100000$: the payment for the job.", "outputFormat": "The first line contains a single integer $t$, the maximum total payment that can be obtained.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2006] 军机调度", "background": "", "description": "凯萨拥有一支由n个人组成的雇佣军，他们靠在威尼斯商行接任务过活。\n\n这支军队的成份比较复杂，不同的人往往具有不同的技能，有的人还拥有多项技能。\n\n威尼斯商行的任务也参差不齐，有的需要几个人合作完成，有的只需要一个人独立完成：有的很简单，不需要耗多少时间，因此报酬也较低，有的很有难度，需要多个人长期合作完成，因此报酬就高。完成这些任务的时间不会超过一个月。并且，一个人不能同时执行两项任务，也不能中途加入或者退出任务。但可以不执行任何任务。\n\n一项只需要n个人来完成的任务，如果执行该任务的人数p大于n,那么反而会得到更少的报酬，即原报酬的1/(p-n+1)。\n\n凯萨是一位英明的领袖，他往往在每个月的月底召开军事会议，总结上个月的成果，发给大家报酬，并指派下个月的任务。\n\n请问，凯萨应该怎样指派任务，才能使总报酬最高？总报酬为多少？", "inputFormat": "一行包含两个正整数n,m。彼此用空格隔开，\n\n其中n〈10表示雇佣军的人数，m〈15表示下个月可选的任务数。\n\n接下来的n行中第i行（对应文件的第i+1行）的第一个整数小于等于表示编号为i的雇佣军可执行的任务数\n\n后面的整数是编号为i的雇佣军可以执行的所有任务的编号，这些整数之间用空格隔开。\n\n最后的m行中，每行有四个整数b、e、p和r，彼此之间用空格隔开，\n\n其中第j行（对应整个文件的第n+j+1行）是编号为j的任务的描述：\n\n0<b<32表示该任务的开始日（这一天会被计入任务所需的时间中），\n\n0<e<32表示该任务的结束日（这一天也会被计入任务所需的时间中），\n\np<10表示该任务所需人数，0<r<100000表示该任务的报酬。", "outputFormat": "第一行只有一个整数t,表示最多可获得的总报酬", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4541", "type": "P", "difficulty": 6, "samples": [["1\n1", "0"], ["1\n5", "3"], ["2\n11", "56"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2011", "各省省选", "递归", "浙江", "进制", "Fibonacci 数列", "矩阵乘法"], "title": "[ZJOI2011] 细胞", "background": "", "description": "2222年，人类在银河系外的某颗星球上发现了生命，并且携带了一个细胞回到了地球。经过反复研究，人类已经完全掌握了这类细胞的发展规律：\n\n这种细胞最初的形态是“长条形”，一端是头，一端是尾，中间是躯干。细胞内部含有一列密码（你可以认为它是这种细胞的DNA）。密码是一个长度为n的数字串，且仅含有1~9这9种数字，沿着细胞的躯干从头到尾排列着。\n\n首先，细胞会经历一次分裂。细胞将沿躯干方向分裂成若干个球体，躯干将退化成丝状物，连接着相邻的球体。在分裂过程中，质量是均匀分布的。换句话说，若分裂成k个球体，每个球体的质量为原来的1/k。然而，密码的分布是不确定的。若分割成k个球体，密码会被切割成k段（每段长度至少为1），并按从头到尾的顺序分布在各个球体中。如图，为其中一种合法的一次分裂：\n\n![](https://cdn.luogu.com.cn/upload/pic/18508.png)\n\n接下来，细胞会经历二次分裂。对于每个球体，其中会含有一小段密码（注意他是有序的），我们把它看作一个十进制的数T。这个球体会被分割成T个小球体，并排成一排，之间用躯干退化成的丝状物相连接，并且质量仍然是均匀分布的，每个小球体的质量都是原球体的1/T。至此，密码已经发挥了它的作用，便消失了。如图，为二次分裂：\n\n![](https://cdn.luogu.com.cn/upload/pic/18509.png)\n\n最后，细胞会进行变异。相邻小球体之间的丝状物可能会退化掉，这两个小球体便会以相切的方式直接连接。显然，二次分裂后，除两端外的每个小球体都有两段丝状物与其连接（头尾两端的小球体只有一段丝状物与其相连）。对于每个小球体，必须至少退化一段与其相连的丝状物，否则这个结构不稳定，会继续变异。如图，为一种稳定的变异：\n\n![](https://cdn.luogu.com.cn/upload/pic/18510.png)\n\n现在，我们想知道，对于一个给定密码的细胞，总共有多少种稳定的结构。两种结构被认为相同，当且仅当他们拥有相同个数的小球体，从头到尾每个小球体的质量相同，并且从头到尾每对相邻小球体之间的连接方式相同（都是通过丝状物相连或都是通过相切直接相连）。你只需要回答这个结果 mod 1000000007即可。", "inputFormat": "第一行为一个正整数n，表示细胞密码的长度。\n\n第二行共n个数字，为给定的细胞密码，中间没有空格。", "outputFormat": "只包含一个整数，为细胞的种数 mod 1000000007的结果。", "hint": "对于5%的数据满足，n ≤ 6；\n\n对于25%的数据满足，n ≤ 25；\n\n对于60%的数据满足，n ≤ 100；\n\n对于70%的数据满足，n ≤ 300；\n\n对于100%的数据满足，n ≤ 1 000。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2011] Cell", "background": "", "description": "In the year 2222, humans discovered life on a planet outside the Milky Way and brought back a cell to Earth. After repeated research, humans have fully understood how this type of cell develops:\n\nThe cell initially has a “long strip” shape, with a head at one end and a tail at the other, and a trunk in the middle. Inside the cell there is a sequence of codes (you may think of it as the cell’s DNA). The code is a digit string of length $n$, containing only the 9 digits $1 \\sim 9$, arranged along the trunk from head to tail.\n\nFirst, the cell undergoes a split. The cell splits along the trunk into several spheres, and the trunk degenerates into filaments that connect adjacent spheres. During the split, mass is evenly distributed. In other words, if it splits into $k$ spheres, each sphere has mass $1/k$ of the original. However, the distribution of the code is uncertain. If it is split into $k$ spheres, the code is cut into $k$ segments (each segment has length at least 1), and these segments are placed into the spheres in order from head to tail. The following figure shows one valid split:\n\n![](https://cdn.luogu.com.cn/upload/pic/18508.png)\n\nNext, the cell undergoes a second split. For each sphere, it contains a short segment of the code (note that it is ordered). Treat this segment as a decimal number $T$. This sphere is then divided into $T$ small spheres, arranged in a line, connected by filaments formed from the degenerated trunk, and the mass is still evenly distributed, so each small sphere has mass $1/T$ of the original sphere. At this point, the code has served its purpose and disappears. The following figure shows the second split:\n\n![](https://cdn.luogu.com.cn/upload/pic/18509.png)\n\nFinally, the cell mutates. The filament between two adjacent small spheres may degenerate, and then the two small spheres are directly connected in a tangent way. Clearly, after the second split, each small sphere except the two ends has two filaments connected to it (the small spheres at the head and tail ends have only one filament). For each small sphere, at least one filament connected to it must degenerate; otherwise, the structure is unstable and will continue to mutate. The following figure shows one stable mutation:\n\n![](https://cdn.luogu.com.cn/upload/pic/18510.png)\n\nNow we want to know: for a cell with a given code, how many different stable structures are there in total. Two structures are considered the same if and only if they have the same number of small spheres, from head to tail each small sphere has the same mass, and from head to tail the connection between every pair of adjacent small spheres is the same (either both connected by a filament, or both directly connected tangentially). You only need to output the answer modulo 1000000007.", "inputFormat": "The first line contains a positive integer $n$, indicating the length of the cell code.\n\nThe second line contains $n$ digits, which form the given cell code, with no spaces.", "outputFormat": "Output only one integer, the number of possible structures modulo 1000000007.", "hint": "For 5% of the testdata, $n \\le 6$.\n\nFor 25% of the testdata, $n \\le 25$.\n\nFor 60% of the testdata, $n \\le 100$.\n\nFor 70% of the testdata, $n \\le 300$.\n\nFor 100% of the testdata, $n \\le 1\\,000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2011] 细胞", "background": "", "description": "2222年，人类在银河系外的某颗星球上发现了生命，并且携带了一个细胞回到了地球。经过反复研究，人类已经完全掌握了这类细胞的发展规律：\n\n这种细胞最初的形态是“长条形”，一端是头，一端是尾，中间是躯干。细胞内部含有一列密码（你可以认为它是这种细胞的DNA）。密码是一个长度为n的数字串，且仅含有1~9这9种数字，沿着细胞的躯干从头到尾排列着。\n\n首先，细胞会经历一次分裂。细胞将沿躯干方向分裂成若干个球体，躯干将退化成丝状物，连接着相邻的球体。在分裂过程中，质量是均匀分布的。换句话说，若分裂成k个球体，每个球体的质量为原来的1/k。然而，密码的分布是不确定的。若分割成k个球体，密码会被切割成k段（每段长度至少为1），并按从头到尾的顺序分布在各个球体中。如图，为其中一种合法的一次分裂：\n\n![](https://cdn.luogu.com.cn/upload/pic/18508.png)\n\n接下来，细胞会经历二次分裂。对于每个球体，其中会含有一小段密码（注意他是有序的），我们把它看作一个十进制的数T。这个球体会被分割成T个小球体，并排成一排，之间用躯干退化成的丝状物相连接，并且质量仍然是均匀分布的，每个小球体的质量都是原球体的1/T。至此，密码已经发挥了它的作用，便消失了。如图，为二次分裂：\n\n![](https://cdn.luogu.com.cn/upload/pic/18509.png)\n\n最后，细胞会进行变异。相邻小球体之间的丝状物可能会退化掉，这两个小球体便会以相切的方式直接连接。显然，二次分裂后，除两端外的每个小球体都有两段丝状物与其连接（头尾两端的小球体只有一段丝状物与其相连）。对于每个小球体，必须至少退化一段与其相连的丝状物，否则这个结构不稳定，会继续变异。如图，为一种稳定的变异：\n\n![](https://cdn.luogu.com.cn/upload/pic/18510.png)\n\n现在，我们想知道，对于一个给定密码的细胞，总共有多少种稳定的结构。两种结构被认为相同，当且仅当他们拥有相同个数的小球体，从头到尾每个小球体的质量相同，并且从头到尾每对相邻小球体之间的连接方式相同（都是通过丝状物相连或都是通过相切直接相连）。你只需要回答这个结果 mod 1000000007即可。", "inputFormat": "第一行为一个正整数n，表示细胞密码的长度。\n\n第二行共n个数字，为给定的细胞密码，中间没有空格。", "outputFormat": "只包含一个整数，为细胞的种数 mod 1000000007的结果。", "hint": "对于5%的数据满足，n ≤ 6；\n\n对于25%的数据满足，n ≤ 25；\n\n对于60%的数据满足，n ≤ 100；\n\n对于70%的数据满足，n ≤ 300；\n\n对于100%的数据满足，n ≤ 1 000。", "locale": "zh-CN"}}}
{"pid": "P4542", "type": "P", "difficulty": 7, "samples": [["3 4 2\n0 1 1\n1 2 1\n2 3 100\n0 3 1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2011", "各省省选", "浙江", "图论建模", "最短路", "费用流"], "title": "[ZJOI2011] 营救皮卡丘", "background": null, "description": "皮卡丘被火箭队用邪恶的计谋抢走了！这三个坏家伙还给小智留下了赤果果的挑衅！为了皮卡丘，也为了正义，小智和他的朋友们义不容辞的踏上了营救皮卡丘的道路。\n\n火箭队一共有 $N$ 个据点，据点之间存在 $M$ 条双向道路。据点分别从 $1$ 到 $N$ 标号。小智一行 $K$ 人从真新镇出发，营救被困在 $N$ 号据点的皮卡丘。为了方便起见，我们将真新镇视为 $0$ 号据点，一开始 $K$ 个人都在 $0$ 号点。\n\n由于火箭队的重重布防，对于任意 $2\\le X\\le N$，要想摧毁 $X$ 号据点，必须按照顺序先摧毁 $1$ 到 $X-1$ 号据点，并且，如果 $X-1$ 号据点没有被摧毁，由于防御的连锁性，小智一行任何一个人进入据点 $X$，都会被发现，并产生严重后果。因此，在$X-1$号据点被摧毁之前，任何人是不能够经过 $X$ 号据点的。\n\n为了简化问题，我们忽略战斗环节，小智一行任何一个人经过 $K$ 号据点即认为 $K$ 号据点被摧毁。被摧毁的据点依然是可以被经过的。\n\n$K$ 个人是可以分头行动的，只要有任何一个人在 $K-1$ 号据点被摧毁之后，经过 $K$ 号据点，$K$ 号据点就被摧毁了。显然的，只要 $N$ 号据点被摧毁，皮卡丘就得救了。\n\n野外的道路是不安全的，因此小智一行希望在摧毁 $N$ 号据点救出皮卡丘的同时，使得 $K$ 个人所经过的道路的长度总和最少。\n\n请你帮助小智设计一个最佳的营救方案吧！", "inputFormat": "第一行包含三个正整数 $N,M,K$。表示一共有 $N+1$ 个点，分别从 $0$ 到 $N$ 编号，以及 $M$ 条无向边。一开始小智一行共 $K$ 个人均位于 $0$ 号点。 \n\n接下来 $M$ 行，每行三个非负整数，第 $i$ 行的整数为 $A_i$，$B_i$，$L_i$。表示存在一条从 $A_i$ 号据点到 $B_i$ 号据点的长度为 $L_i$ 的道路。", "outputFormat": "仅包含一个整数 $S$，为营救皮卡丘所需要经过的最小的道路总和。", "hint": "【样例说明】\n\n小智和小霞一起前去营救皮卡丘。在最优方案中，小智先从真新镇前往 $1$ 号点，接着前往 $2$ 号据点。当小智成功摧毁 $2$ 号据点之后，小霞从真新镇出发直接前往 $3$ 号据点，救出皮卡丘。\n\n对于 $100\\%$ 的数据满足 $N\\le 150, M \\le 20 000, 1 \\le K \\le 10, L_i \\le 10 000$, 保证小智一行一定能够救出皮卡丘。\n\n至于为什么 $K \\le 10$，你可以认为最终在小智的号召下，小智，小霞，小刚，小建，小遥，小胜，小光，艾莉丝，天桐，还有去日本旅游的黑猫警长，一同前去大战火箭队。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2011] Rescue Pikachu", "background": "", "description": "Pikachu has been taken away by Team Rocket using an evil scheme. Those three bad guys also left Ash with an open provocation. For Pikachu, and for justice, Ash and his friends set off without hesitation on the road to rescue Pikachu.\n\nTeam Rocket has a total of $N$ bases, and there are $M$ bidirectional roads between the bases. The bases are numbered from $1$ to $N$. Ash’s team has $K$ people. They start from Pallet Town and plan to rescue Pikachu trapped in base $N$. For convenience, we treat Pallet Town as base $0$. At the beginning, all $K$ people are at node $0$.\n\nDue to Team Rocket’s heavy defenses, for any $2\\le X\\le N$, to destroy base $X$, one must first destroy bases $1$ to $X-1$ in order. Moreover, if base $X-1$ has not been destroyed, then because of chained defenses, once any member of Ash’s team enters base $X$, they will be discovered and serious consequences will occur. Therefore, before base $X-1$ is destroyed, no one can pass through base $X$.\n\nTo simplify the problem, we ignore fighting. If any member of Ash’s team passes through base $K$, then base $K$ is considered destroyed. A destroyed base can still be passed through.\n\nThe $K$ people may act separately. As long as after base $K-1$ is destroyed, any one person passes through base $K$, then base $K$ is destroyed. Obviously, once base $N$ is destroyed, Pikachu is rescued.\n\nThe roads in the wild are unsafe, so while destroying base $N$ to rescue Pikachu, Ash’s team wants the total length of roads traveled by all $K$ people to be as small as possible.\n\nPlease help Ash design the best rescue plan.", "inputFormat": "The first line contains three positive integers $N,M,K$. This means there are $N+1$ nodes numbered from $0$ to $N$, and $M$ undirected edges. At the beginning, Ash’s team has $K$ people, all located at node $0$.\n\nThe next $M$ lines each contain three non-negative integers. On the $i$-th line, the integers are $A_i$, $B_i$, $L_i$, meaning there is a road of length $L_i$ between base $A_i$ and base $B_i$.", "outputFormat": "Output only one integer $S$, the minimum total road length required to rescue Pikachu.", "hint": "[Sample Explanation]\n\nAsh and Misty go to rescue Pikachu together. In the optimal plan, Ash first goes from Pallet Town to node $1$, then goes to base $2$. After Ash successfully destroys base $2$, Misty sets off from Pallet Town and goes directly to base $3$, rescuing Pikachu.\n\nFor $100\\%$ of the testdata, it holds that $N\\le 150, M \\le 20 000, 1 \\le K \\le 10, L_i \\le 10 000$. It is guaranteed that Ash’s team can rescue Pikachu.\n\nAs for why $K \\le 10$, you may assume that in the end, under Ash’s call, Ash, Misty, Brock, Tracey, May, Max, Dawn, Iris, Cilan, and also Officer Black Cat who is traveling in Japan, all go together to fight Team Rocket.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2011] 营救皮卡丘", "background": null, "description": "皮卡丘被火箭队用邪恶的计谋抢走了！这三个坏家伙还给小智留下了赤果果的挑衅！为了皮卡丘，也为了正义，小智和他的朋友们义不容辞的踏上了营救皮卡丘的道路。\n\n火箭队一共有 $N$ 个据点，据点之间存在 $M$ 条双向道路。据点分别从 $1$ 到 $N$ 标号。小智一行 $K$ 人从真新镇出发，营救被困在 $N$ 号据点的皮卡丘。为了方便起见，我们将真新镇视为 $0$ 号据点，一开始 $K$ 个人都在 $0$ 号点。\n\n由于火箭队的重重布防，对于任意 $2\\le X\\le N$，要想摧毁 $X$ 号据点，必须按照顺序先摧毁 $1$ 到 $X-1$ 号据点，并且，如果 $X-1$ 号据点没有被摧毁，由于防御的连锁性，小智一行任何一个人进入据点 $X$，都会被发现，并产生严重后果。因此，在$X-1$号据点被摧毁之前，任何人是不能够经过 $X$ 号据点的。\n\n为了简化问题，我们忽略战斗环节，小智一行任何一个人经过 $K$ 号据点即认为 $K$ 号据点被摧毁。被摧毁的据点依然是可以被经过的。\n\n$K$ 个人是可以分头行动的，只要有任何一个人在 $K-1$ 号据点被摧毁之后，经过 $K$ 号据点，$K$ 号据点就被摧毁了。显然的，只要 $N$ 号据点被摧毁，皮卡丘就得救了。\n\n野外的道路是不安全的，因此小智一行希望在摧毁 $N$ 号据点救出皮卡丘的同时，使得 $K$ 个人所经过的道路的长度总和最少。\n\n请你帮助小智设计一个最佳的营救方案吧！", "inputFormat": "第一行包含三个正整数 $N,M,K$。表示一共有 $N+1$ 个点，分别从 $0$ 到 $N$ 编号，以及 $M$ 条无向边。一开始小智一行共 $K$ 个人均位于 $0$ 号点。 \n\n接下来 $M$ 行，每行三个非负整数，第 $i$ 行的整数为 $A_i$，$B_i$，$L_i$。表示存在一条从 $A_i$ 号据点到 $B_i$ 号据点的长度为 $L_i$ 的道路。", "outputFormat": "仅包含一个整数 $S$，为营救皮卡丘所需要经过的最小的道路总和。", "hint": "【样例说明】\n\n小智和小霞一起前去营救皮卡丘。在最优方案中，小智先从真新镇前往 $1$ 号点，接着前往 $2$ 号据点。当小智成功摧毁 $2$ 号据点之后，小霞从真新镇出发直接前往 $3$ 号据点，救出皮卡丘。\n\n对于 $100\\%$ 的数据满足 $N\\le 150, M \\le 20 000, 1 \\le K \\le 10, L_i \\le 10 000$, 保证小智一行一定能够救出皮卡丘。\n\n至于为什么 $K \\le 10$，你可以认为最终在小智的号召下，小智，小霞，小刚，小建，小遥，小胜，小光，艾莉丝，天桐，还有去日本旅游的黑猫警长，一同前去大战火箭队。", "locale": "zh-CN"}}}
{"pid": "P4543", "type": "P", "difficulty": 6, "samples": [["4 4 4 1 5\n12 9 6 6 11\n0", "0.800000\n0.683938"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2011", "各省省选", "江苏"], "title": "[JSOI2011] Apple 的美食", "background": "", "description": "Apple 很喜欢吃巧克力，但它是一头挑剔的猪，有的品种的巧克力并不能满足它的胃口。如果主人给它的巧克力它不喜欢吃，它就会很不开心。主人并不知道，什么样的巧克力 Apple 喜欢吃，但她知道巧克力的可可含量是巧克力\n口感的重要因素，因此她决定根据巧克力的可可含量来判断什么样的巧克力拿给 Apple 吃，什么样的巧克力不拿给 Apple 吃。\n\n假设一块巧克力的可可含量有 $1\\sim N$ 种不同的计量，则她认为可可含量在 $[a,b]$ 的范围内的巧克力是好吃的\n。不过她不知道的这个范围到底是多少，需要你来帮忙确定这个范围，使得她可以让 Apple 吃到最多的喜欢吃的巧克力。\n\n设 $pos_i$ 是可可脂含量为 $i$，且 Apple 认为是好吃的巧克力的数量，$neg_i$ 是可可脂含量为 $i$，且 Apple 认为是不好吃的巧克力的数量。这两个序列由以下方法生成：\n$$\\begin{cases}pos_i=a_{2i-1}\\\\neg_i=a_{2i}\\end{cases}$$\n\n其中，$a_i=(p_1a_{i-1}+p_2)\\bmod M(i>1)$。\n\n设 $TP$ 是 Apple 认为好吃的、且被主人认为是好吃的巧克力数量，$TN$ 是Apple 认为不好吃的、且被主人认为是不好吃的巧克力数量，$FP$ 是 Apple 认为不好吃的、且被主人认为是好吃的巧克力数量，$FN$ 是 Apple 认为好吃的、且被主人认为是不好吃的巧克力数量。\n\n设 $r$ 为被正确判断为好吃的巧克力数占所有好吃的巧克力的比率，$p$ 为被正确判断为好吃的巧克力占所有被判定为好吃的巧克力数的比率，则\n\n$$\\begin{cases}r=\\frac{TP}{TP+FN}\\\\p=\\frac{TP}{TP+FP}\\end{cases}$$\n\n请你帮助 Apple 求出一个范围，使得 $f=\\frac{2pr}{p+r}$ 最大。", "inputFormat": "输入由若干行组成，每行是一组数据：$N,a_1,p_1,p_2,M$，中间用空格分开。\n\n输入以一个 $0$ 结束，数据组数不超过 $1000$。", "outputFormat": "每组数据输出一行，为 $f$ 的最大值（四舍五入保留 $6$ 位小数）。", "hint": "### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 10^6,a_1,p_1,p_2<M\\leq 20$，保证至少有一块 Apple 认为好吃的巧克力。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2011] Apple 的美食", "background": "", "description": "Apple 很喜欢吃巧克力，但它是一头挑剔的猪，有的品种的巧克力并不能满足它的胃口。如果主人给它的巧克力它不喜欢吃，它就会很不开心。主人并不知道，什么样的巧克力 Apple 喜欢吃，但她知道巧克力的可可含量是巧克力\n口感的重要因素，因此她决定根据巧克力的可可含量来判断什么样的巧克力拿给 Apple 吃，什么样的巧克力不拿给 Apple 吃。\n\n假设一块巧克力的可可含量有 $1\\sim N$ 种不同的计量，则她认为可可含量在 $[a,b]$ 的范围内的巧克力是好吃的\n。不过她不知道的这个范围到底是多少，需要你来帮忙确定这个范围，使得她可以让 Apple 吃到最多的喜欢吃的巧克力。\n\n设 $pos_i$ 是可可脂含量为 $i$，且 Apple 认为是好吃的巧克力的数量，$neg_i$ 是可可脂含量为 $i$，且 Apple 认为是不好吃的巧克力的数量。这两个序列由以下方法生成：\n$$\\begin{cases}pos_i=a_{2i-1}\\\\neg_i=a_{2i}\\end{cases}$$\n\n其中，$a_i=(p_1a_{i-1}+p_2)\\bmod M(i>1)$。\n\n设 $TP$ 是 Apple 认为好吃的、且被主人认为是好吃的巧克力数量，$TN$ 是Apple 认为不好吃的、且被主人认为是不好吃的巧克力数量，$FP$ 是 Apple 认为不好吃的、且被主人认为是好吃的巧克力数量，$FN$ 是 Apple 认为好吃的、且被主人认为是不好吃的巧克力数量。\n\n设 $r$ 为被正确判断为好吃的巧克力数占所有好吃的巧克力的比率，$p$ 为被正确判断为好吃的巧克力占所有被判定为好吃的巧克力数的比率，则\n\n$$\\begin{cases}r=\\frac{TP}{TP+FN}\\\\p=\\frac{TP}{TP+FP}\\end{cases}$$\n\n请你帮助 Apple 求出一个范围，使得 $f=\\frac{2pr}{p+r}$ 最大。", "inputFormat": "输入由若干行组成，每行是一组数据：$N,a_1,p_1,p_2,M$，中间用空格分开。\n\n输入以一个 $0$ 结束，数据组数不超过 $1000$。", "outputFormat": "每组数据输出一行，为 $f$ 的最大值（四舍五入保留 $6$ 位小数）。", "hint": "### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 10^6,a_1,p_1,p_2<M\\leq 20$，保证至少有一块 Apple 认为好吃的巧克力。", "locale": "zh-CN"}}}
{"pid": "P4544", "type": "P", "difficulty": 5, "samples": [["2 5 3\n3 1 2\n4 1 2\n1 1 1", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO", "单调队列", "背包 DP", "队列"], "title": "[USACO10NOV] Buying Feed G", "background": "", "description": "约翰开车来到镇上，他要带$K$吨饲料回家。运送饲料是需要花钱的，如果他的车上有$X$吨饲料，每公里就要花费$X^2$元，开车D公里就需要$D\\times  X^2$元。约翰可以从$N$家商店购买饲料，所有商店都在一个坐标轴上，第$i$家店的位置是$X_i$，饲料的售价为每吨$C_i$元，库存为$F_i$。\n\n约翰从坐标$X=0$开始沿坐标轴正方向前进，他家在坐标$X=E$上。为了带$K$吨饲料回家，约翰最少的花费是多少呢？假设所有商店的库存之和不会少于$K$。\n\n举个例子，假设有三家商店，情况如下所示：\n\n|坐标|$X=1$|$X=3$|$X=4$|$E=5$|\n|:-:|:-:|:-:|:-:|:-:|\n|库存|$1$|$1$|$1$|\n|售价|$1$|$2$|$2$|\n\n如果$K=2$，约翰的最优选择是在离家较近的两家商店购买饲料，则花在路上的钱是$1+4=5$，花在商店的钱是$2+2=4$，共需要$9$元。", "inputFormat": "第$1$行:三个整数$K,E,N$ 第$2..N+1$行:第$i+1$行的三个整数代表,$X_i,F_i,C_i$.", "outputFormat": "一个整数,代表最小花费", "hint": "$1 \\leq K \\leq 10000 , 1 \\leq E \\leq 500 , 1 \\leq N \\leq 500$\n\n$0 < Xi < E, 1 \\leq Fi \\leq 10000, 1 \\leq C_i \\leq 10^7$", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10NOV] Buying Feed G", "background": "", "description": "John drives to town and wants to bring back $K$ tons of feed. Transporting feed costs money: if his car currently carries $X$ tons, the cost per kilometer is $X^2$ yuan, so driving $D$ kilometers costs $D\\times  X^2$ yuan. John can buy feed from $N$ stores, all located on a number line. Store $i$ is at position $X_i$, sells feed at $C_i$ yuan per ton, and has $F_i$ tons in stock.\n\nJohn starts at $X=0$ and travels in the positive direction along the axis. His home is at $X=E$. What is the minimum total cost for John to bring $K$ tons of feed home? Assume the sum of all stores’ stocks is at least $K$.\n\nFor example, suppose there are three stores as shown below:\n\n|Coordinate|$X=1$|$X=3$|$X=4$|$E=5$|\n|:-:|:-:|:-:|:-:|:-:|\n|Stock|$1$|$1$|$1$|\n|Price|$1$|$2$|$2$|\n\nIf $K=2$, John’s optimal choice is to buy from the two stores closer to home. The money spent on the road is $1+4=5$, the money spent at the stores is $2+2=4$, for a total of $9$ yuan.", "inputFormat": "The first line contains three integers $K$, $E$, $N$.\n\nLines $2$ to $N+1$: line $i+1$ contains three integers $X_i$, $F_i$, $C_i$.", "outputFormat": "Output a single integer, the minimum total cost.", "hint": "Constraints\n\n$1 \\leq K \\leq 10000$, $1 \\leq E \\leq 500$, $1 \\leq N \\leq 500$.\n\n$0 < X_i < E$, $1 \\leq F_i \\leq 10000$, $1 \\leq C_i \\leq 10^7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10NOV] Buying Feed G", "background": "", "description": "约翰开车来到镇上，他要带$K$吨饲料回家。运送饲料是需要花钱的，如果他的车上有$X$吨饲料，每公里就要花费$X^2$元，开车D公里就需要$D\\times  X^2$元。约翰可以从$N$家商店购买饲料，所有商店都在一个坐标轴上，第$i$家店的位置是$X_i$，饲料的售价为每吨$C_i$元，库存为$F_i$。\n\n约翰从坐标$X=0$开始沿坐标轴正方向前进，他家在坐标$X=E$上。为了带$K$吨饲料回家，约翰最少的花费是多少呢？假设所有商店的库存之和不会少于$K$。\n\n举个例子，假设有三家商店，情况如下所示：\n\n|坐标|$X=1$|$X=3$|$X=4$|$E=5$|\n|:-:|:-:|:-:|:-:|:-:|\n|库存|$1$|$1$|$1$|\n|售价|$1$|$2$|$2$|\n\n如果$K=2$，约翰的最优选择是在离家较近的两家商店购买饲料，则花在路上的钱是$1+4=5$，花在商店的钱是$2+2=4$，共需要$9$元。", "inputFormat": "第$1$行:三个整数$K,E,N$ 第$2..N+1$行:第$i+1$行的三个整数代表,$X_i,F_i,C_i$.", "outputFormat": "一个整数,代表最小花费", "hint": "$1 \\leq K \\leq 10000 , 1 \\leq E \\leq 500 , 1 \\leq N \\leq 500$\n\n$0 < Xi < E, 1 \\leq Fi \\leq 10000, 1 \\leq C_i \\leq 10^7$", "locale": "zh-CN"}}}
{"pid": "P4545", "type": "P", "difficulty": 0, "samples": [["2 150.0000 1000.0000\n-60 165 50 165 0\n110 25 130 120 1\n-205 360 275 360", "0.7443"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2013", "各省省选", "江苏"], "title": "[JSOI2013] 投影面积", "background": "", "description": "为了简单期间，投影屏幕对应二维平面中的一条平行与 $x$ 轴，连接点 $(x_1^s,y^s)$ 和点 $(x_2^s,y^s)$ 的线段。\n\nJYY 的投影仪位于原点，朝向 $y$ 轴正方向，发出对称于 $y$ 轴并且张角度数为 $ang$ 的光束（$ang$ 是角度制），如图所示（粗线条为投影屏幕，黄色区域为投影仪射出的光束）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ate0zcyz.png)\n\n实验室内一共有 $n$ 的障碍物，每个障碍物都对应于二维平面中的一条线段（我们认为这些障碍物的厚度为 $0$）。\n\n有一些障碍物是不能反光的，因此光线只要射到这些线段上，就会被完全吸收（比如投影屏幕就是不会反光的）；其他障碍物则是双面可以反光的，光线如果射到这些线段上，就会按照基本光学原理进行反射。\n\n所有的障碍物都相互不接触，并且也不会与投影屏幕，或者坐标原点接触。\n\n光线在空气中传播会有损耗，因此在 JYY 的实验室中，光线在传播了 $len$ 的距离之后，就会消失。\n\n现在 JYY 想知道，投影屏幕上被照亮的区域占投影屏幕总长度的比率。", "inputFormat": "第一行一个正整数和两个正实数，为 $N,ang,len$。\n\n接下来 $n$ 行，每行 $5$ 个整数 $x_1,x_2,y_1,y_2,r$，表示 JYY 的实验室内存在一个连接点 $(x_1,y_1)$ 和点 $(x_2,y_2)$ 的障碍物，$r$ 为 $0$ 或者 $1$。当 $r=0$ 时表示这个障碍物不反光，$r=1$ 则表示这个障碍物双面反光。\n\n接下来一行四个整数 $x_1^s,y^s,x_2^s,y^s$，表示投影屏幕的位置，保证第二个和第四个整数相同。", "outputFormat": "一行一个 $0$ 到 $1$ 之间的实数，表示屏幕上被照亮部分的长度与屏幕总长的比值，结果精确到小数点后 $4$ 位。", "hint": "### 样例解释 1\n\n如图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k09d8sjd.png)\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$0\\leq n\\leq 10,0<ang\\leq 150,0<len\\leq 10^3$，任意输入坐标绝对值不超过 $10^3$。\n\n输入数据保证 $y^s>0,x_1^s<x_2^s$，并且对于任意障碍物满足 $\\vert y_2\\vert<y^s$。\n\n输入数据还保证对于一条光线在消失或被吸收之前至多反射 $30$ 次。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2013] 投影面积", "background": "", "description": "为了简单期间，投影屏幕对应二维平面中的一条平行与 $x$ 轴，连接点 $(x_1^s,y^s)$ 和点 $(x_2^s,y^s)$ 的线段。\n\nJYY 的投影仪位于原点，朝向 $y$ 轴正方向，发出对称于 $y$ 轴并且张角度数为 $ang$ 的光束（$ang$ 是角度制），如图所示（粗线条为投影屏幕，黄色区域为投影仪射出的光束）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ate0zcyz.png)\n\n实验室内一共有 $n$ 的障碍物，每个障碍物都对应于二维平面中的一条线段（我们认为这些障碍物的厚度为 $0$）。\n\n有一些障碍物是不能反光的，因此光线只要射到这些线段上，就会被完全吸收（比如投影屏幕就是不会反光的）；其他障碍物则是双面可以反光的，光线如果射到这些线段上，就会按照基本光学原理进行反射。\n\n所有的障碍物都相互不接触，并且也不会与投影屏幕，或者坐标原点接触。\n\n光线在空气中传播会有损耗，因此在 JYY 的实验室中，光线在传播了 $len$ 的距离之后，就会消失。\n\n现在 JYY 想知道，投影屏幕上被照亮的区域占投影屏幕总长度的比率。", "inputFormat": "第一行一个正整数和两个正实数，为 $N,ang,len$。\n\n接下来 $n$ 行，每行 $5$ 个整数 $x_1,x_2,y_1,y_2,r$，表示 JYY 的实验室内存在一个连接点 $(x_1,y_1)$ 和点 $(x_2,y_2)$ 的障碍物，$r$ 为 $0$ 或者 $1$。当 $r=0$ 时表示这个障碍物不反光，$r=1$ 则表示这个障碍物双面反光。\n\n接下来一行四个整数 $x_1^s,y^s,x_2^s,y^s$，表示投影屏幕的位置，保证第二个和第四个整数相同。", "outputFormat": "一行一个 $0$ 到 $1$ 之间的实数，表示屏幕上被照亮部分的长度与屏幕总长的比值，结果精确到小数点后 $4$ 位。", "hint": "### 样例解释 1\n\n如图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k09d8sjd.png)\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$0\\leq n\\leq 10,0<ang\\leq 150,0<len\\leq 10^3$，任意输入坐标绝对值不超过 $10^3$。\n\n输入数据保证 $y^s>0,x_1^s<x_2^s$，并且对于任意障碍物满足 $\\vert y_2\\vert<y^s$。\n\n输入数据还保证对于一条光线在消失或被吸收之前至多反射 $30$ 次。", "locale": "zh-CN"}}}
{"pid": "P4546", "type": "P", "difficulty": 7, "samples": [["3 7 C1\n1 1 0\n3 0.5 0.5\n3 -0.5 0.7\nappear 0 1\ntravel 0 1 0.3\nappear 0 2\ntravel 1 2 0.5\ndisappear 0 1\nappear 1 2\ntravel 1 2 0.5", "9.45520207e-001\n1.67942554e+000\n1.20000000e+000"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2017", "Special Judge", "THUWC"], "title": "[THUWC 2017] 在美妙的数学王国中畅游", "background": "数字和数学规律主宰着这个世界。\n\n机器的运转，\n\n生命的消长，\n\n宇宙的进程，\n\n这些神秘而又美妙的过程无不可以用数学的语言展现出来。\n\n这印证了一句古老的名言：\n\n“学好数理化，走遍天下都不怕。”", "description": "学渣小R 被大学的数学课程虐得生活不能自理，微积分的成绩曾是他在教室里上的课的最低分。然而他的某位陈姓室友却能轻松地在数学考试中得到满分。为了提升自己的数学课成绩，有一天晚上（在他睡觉的时候），他来到了数学王国。\n\n数学王国中，每个人的智商可以用一个属于 $ [0,1]$ 的实数表示。数学王国中有 $n$ 个城市，编号从 $0 \\sim n-1$，这些城市由若干座魔法桥连接。每个城市的中心都有一个魔法球，每个魔法球中藏有一道数学题。\n\n每个人在做完这道数学题之后都会得到一个在 $[0,1]$ 内的分数。一道题可以用一个函数 $f(x)$ 表示。若一个人的智商为 $x$，则他做完这道数学题之后会得到 $f(x)$ 分。有三种形式：\n\n-  正弦函数 $f(x)=\\sin(a x + b)\\ (a \\in [0,1], b \\in [0,\\pi],a+b\\in[0,\\pi])$   \n-  指数函数 $f(x)=\\text e^{ax+b}\\ (a\\in [-1,1], b\\in [-2,0], a+b\\in [-2,0])$   \n-  一次函数 $f(x) = ax + b\\ (a\\in [-1,1],b\\in[0,1],a+b\\in [0,1])$    \n\n数学王国中的魔法桥会发生变化，有时会有一座魔法桥消失，有时会有一座魔法桥出现。但在任意时刻，只存在至多一条连接任意两个城市的简单路径（即所有城市形成一个森林）。在初始情况下，数学王国中不存在任何的魔法桥。\n\n数学王国的国王拉格朗日很乐意传授小R 数学知识，但前提是小R 要先回答国王的问题。这些问题具有相同的形式，即一个智商为 $x$ 的人从城市 $u$ 旅行到城市 $v$（即经过 $u \\to v$ 这条路径上的所有城市，包括 $u$ 和 $v$）且做了所有城市内的数学题后，他所有得分的总和是多少。", "inputFormat": "第一行两个正整数 $n,m$ 和一个字符串 $type$。表示数学王国中共有 $n$ 座城市，发生了 $m$ 个事件，该数据的类型为 $type$。\n\n$type$ 字符串是为了能让大家更方便地获得部分分，你可能不需要用到这个输入。其具体含义在 **【限制与约定】** 中有解释。\n\n接下来 $n$ 行，第 $i$ 行表示初始情况下编号为 $i$ 的城市的魔法球中的函数。一个魔法用一个整数 $f$ 表示函数的类型，两个实数 $a,b$ 表示函数的参数，若\n\n- $f=1$，则函数为 $f(x)=\\sin(ax+b)$\n- $f=2$，则函数为 $f(x)=\\text e^{ax+b}$\n- $f=3$，则函数为 $f(x)=ax+b$\n\n接下来 $m$ 行，每行描述一个事件，事件分为四类。\n\n- `appear u v` 表示数学王国中出现了一条连接 $u$ 和 $v$ 这两座城市的魔法，保证连接前 $u,v$ 这两座城市不能互相到达。\n\n- `disappear u v` 表示数学王国中连接 $u,v$ 这两座城市的魔法桥消失了，保证这座魔法桥是存在的。\n\n- `magic c f a b` 表示城市 $c$ 的魔法球中的魔法变成了类型为 $f$，参数为 $a,b$ 的函数\n\n- `travel u v x` 表示询问一个智商为 $x$ 的人从城市 $u$ 旅行到城市 $v$ 后，他得分的总和是多少。若无法从 $u$ 到达 $v$，则输出一行一个字符串 `unreachable`。", "outputFormat": "对于每个询问，输出一行实数，表示得分的总和。", "hint": "【限制与约定】  \n对于 $100\\%$ 的数据，$1\\le n\\le 10^5, 1\\le m \\le 2 \\times 10^5$ 。\n\n本题共有 20 个数据点，每个数据点 5 分。\n\n测试点|$n$|$m$|数据类型\n:-:|:-:|:-:|:-:|\n$1$|$\\leq 100$|$\\leq 200$|C1\n$2 \\sim 5$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|A0\n$6$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|B0\n$7 \\sim 8$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|D0\n$9 \\sim 14$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|A1\n$15 \\sim 17$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|C1\n$18 \\sim 20$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|D1\n\n数据类型的含义：\n\nA：不存在 `disappear` 事件，且所有`appear`事件中的 $u=v-1$\n\nB：不存在 `disappear` 事件\n\nC：所有的 `travel` 事件经过的城市总数 $\\le 5 \\times 10^6$（不可到达的城市对不计入在内）\n\nD：无限制\n\n0：所有 `travel` 事件中，$x=1$（即所有人的智商均为 $1$）\n\n1：无限制\n\n\n\n【评分标准】  \n\n如果你的答案与标准答案的相对误差在 $10^{-7}$ 以内或绝对误差在 $10^{-7}$ 以内，则被判定为正确。\n\n如果你的所有答案均为正确，则得满分，否则得 0 分。\n\n请注意输出格式：每行输出一个答案，答案只能为 `unreachable` 或者一个实数（建议使用科学计数法表示）。每行的长度不得超过 50。错误输出格式会被判定为 0 分。\n\n\n\n【小R 教你学数学】\n\n若函数 $f(x)$ 的 $n$ 阶导数在 $[a,b]$ 区间内连续，则对 $f(x)$ 在 $x_0 \\ (x_0\\in[a,b])$ 处使用 $n$ 次拉格朗日中值定理可以得到带拉格朗日余项的泰勒展开式\n\n$$f(x)=\\sum_{k=0}^{n-1}\\frac{f^{(k)}(x_0)(x-x_0)^k}{k!}+\\frac{f^{(n)}(\\xi)(x-x_0)^n}{n!},x\\in[a,b]$$\n\n其中，当 $x>x_0$ 时，$\\xi\\in[x_0,x]$。当 $x<x_0$ 时，$\\xi\\in[x,x_0]$。\n\n$f^{(n)}$ 表示函数 $f$ 的 $n$ 阶导数", "locale": "zh-CN", "translations": {"en": {"title": "[THUWC 2017] Roam in the Wonderful Kingdom of Mathematics", "background": "Numbers and mathematical laws rule this world.\n\nThe operation of machines,\n\nthe waxing and waning of life,\n\nthe progress of the universe—\n\nall these mysterious and wonderful processes can be expressed in the language of mathematics.\n\nThis confirms an ancient saying:\n\n“Master math, physics, and chemistry, and you can go anywhere without fear.”", "description": "The underachiever Xiao R (pinyin) was tortured by university mathematics courses to the point of being unable to take care of himself. His calculus score was once the lowest among all the courses he took in the classroom. However, one of his roommates surnamed Chen could easily get full marks in math exams. To improve his math grades, one night (in his sleep), he arrived at the Kingdom of Mathematics.\n\nIn the Kingdom of Mathematics, everyone’s IQ is represented by a real number in $ [0,1]$. There are $n$ cities numbered from $0 \\sim n-1$, connected by several magic bridges. At the center of each city there is a magic orb, and inside each magic orb lies a math problem.\n\nAfter solving this problem, everyone will receive a score in $[0,1]$. A problem can be represented by a function $f(x)$. If a person’s IQ is $x$, then after solving this problem he will receive $f(x)$ points. There are three forms:\n\n- Sine function $f(x)=\\sin(a x + b)\\ (a \\in [0,1], b \\in [0,\\pi],a+b\\in[0,\\pi])$.\n- Exponential function $f(x)=\\text e^{ax+b}\\ (a\\in [-1,1], b\\in [-2,0], a+b\\in [-2,0])$.\n- Linear function $f(x) = ax + b\\ (a\\in [-1,1],b\\in[0,1],a+b\\in [0,1])$.\n\nThe magic bridges in the Kingdom of Mathematics change over time. Sometimes a magic bridge disappears, and sometimes a magic bridge appears. However, at any moment, there exists at most one simple path connecting any two cities (i.e., all cities form a forest). Initially, there are no magic bridges in the Kingdom of Mathematics.\n\nKing Lagrange of the Kingdom of Mathematics is happy to teach Xiao R (pinyin) math, but only if Xiao R first answers the king’s questions. These questions have the same form: for a person with IQ $x$ traveling from city $u$ to city $v$ (i.e., passing through all cities on the path $u \\to v$, including $u$ and $v$) and solving all the problems in those cities, what is the sum of all his scores.", "inputFormat": "The first line contains two positive integers $n, m$ and a string $type$. They indicate that there are $n$ cities in the Kingdom of Mathematics, $m$ events occur, and the type of this testdata is $type$.\n\nThe string $type$ is provided to help you obtain partial scores more easily; you may not need to use it. Its meaning is explained in Constraints and Assumptions.\n\nThe next $n$ lines describe, for each city $i$, the function inside its magic orb in the initial state. One integer $f$ denotes the type of function, and two real numbers $a, b$ denote the parameters. If\n\n- $f=1$, then the function is $f(x)=\\sin(ax+b)$.\n- $f=2$, then the function is $f(x)=\\text e^{ax+b}$.\n- $f=3$, then the function is $f(x)=ax+b$.\n\nThe next $m$ lines each describe an event, of one of four types.\n\n- `appear u v` means a magic bridge appears between cities $u$ and $v$. It is guaranteed that before adding the bridge, $u$ and $v$ are not reachable from each other.\n- `disappear u v` means the magic bridge between $u$ and $v$ disappears. It is guaranteed that this magic bridge exists.\n- `magic c f a b` means the magic orb in city $c$ changes to a function of type $f$ with parameters $a, b$.\n- `travel u v x` asks: for a person with IQ $x$ traveling from city $u$ to city $v$, what is the sum of his scores. If $u$ cannot reach $v$, output a single line containing the string `unreachable`.", "outputFormat": "For each query, output one line with a real number representing the total score.", "hint": "Constraints and Assumptions.  \nFor $100\\%$ of the data, $1\\le n\\le 10^5, 1\\le m \\le 2 \\times 10^5$.\n\nThere are 20 testdata points, each worth 5 points.\n\n测试点|$n$|$m$|数据类型\n:-:|:-:|:-:|:-:|\n$1$|$\\leq 100$|$\\leq 200$|C1\n$2 \\sim 5$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|A0\n$6$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|B0\n$7 \\sim 8$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|D0\n$9 \\sim 14$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|A1\n$15 \\sim 17$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|C1\n$18 \\sim 20$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|D1\n\nMeaning of data types:\n\n- A: There is no `disappear` event, and in all `appear` events, $u = v - 1$.\n- B: There is no `disappear` event.\n- C: The total number of cities traversed over all `travel` events is $\\le 5 \\times 10^6$ (pairs that are unreachable are not counted).\n- D: No further restrictions.\n\n- 0: In all `travel` events, $x=1$ (i.e., everyone’s IQ is $1$).\n- 1: No restriction.\n\nScoring criteria.  \n\nIf your answer differs from the standard answer by a relative error within $10^{-7}$ or an absolute error within $10^{-7}$, it is considered correct.\n\nYou will receive full score only if all your answers are correct; otherwise, you receive 0 points.\n\nPlease pay attention to the output format: print one answer per line, and each line must be either `unreachable` or a real number (scientific notation is recommended). Each line must not exceed 50 characters. Incorrect output format will result in 0 points.\n\nXiao R Teaches You Math.\n\nIf the $n$-th derivative of a function $f(x)$ is continuous on the interval $[a,b]$, then by applying the Lagrange mean value theorem $n$ times to $f(x)$ at $x_0 \\ (x_0\\in[a,b])$, we obtain the Taylor expansion with Lagrange remainder\n$$f(x)=\\sum_{k=0}^{n-1}\\frac{f^{(k)}(x_0)(x-x_0)^k}{k!}+\\frac{f^{(n)}(\\xi)(x-x_0)^n}{n!},x\\in[a,b]$$\nwhere, when $x>x_0$, $\\xi\\in[x_0,x]$. When $x<x_0$, $\\xi\\in[x,x_0]$.\n\n$f^{(n)}$ denotes the $n$-th derivative of the function $f$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[THUWC 2017] 在美妙的数学王国中畅游", "background": "数字和数学规律主宰着这个世界。\n\n机器的运转，\n\n生命的消长，\n\n宇宙的进程，\n\n这些神秘而又美妙的过程无不可以用数学的语言展现出来。\n\n这印证了一句古老的名言：\n\n“学好数理化，走遍天下都不怕。”", "description": "学渣小R 被大学的数学课程虐得生活不能自理，微积分的成绩曾是他在教室里上的课的最低分。然而他的某位陈姓室友却能轻松地在数学考试中得到满分。为了提升自己的数学课成绩，有一天晚上（在他睡觉的时候），他来到了数学王国。\n\n数学王国中，每个人的智商可以用一个属于 $ [0,1]$ 的实数表示。数学王国中有 $n$ 个城市，编号从 $0 \\sim n-1$，这些城市由若干座魔法桥连接。每个城市的中心都有一个魔法球，每个魔法球中藏有一道数学题。\n\n每个人在做完这道数学题之后都会得到一个在 $[0,1]$ 内的分数。一道题可以用一个函数 $f(x)$ 表示。若一个人的智商为 $x$，则他做完这道数学题之后会得到 $f(x)$ 分。有三种形式：\n\n-  正弦函数 $f(x)=\\sin(a x + b)\\ (a \\in [0,1], b \\in [0,\\pi],a+b\\in[0,\\pi])$   \n-  指数函数 $f(x)=\\text e^{ax+b}\\ (a\\in [-1,1], b\\in [-2,0], a+b\\in [-2,0])$   \n-  一次函数 $f(x) = ax + b\\ (a\\in [-1,1],b\\in[0,1],a+b\\in [0,1])$    \n\n数学王国中的魔法桥会发生变化，有时会有一座魔法桥消失，有时会有一座魔法桥出现。但在任意时刻，只存在至多一条连接任意两个城市的简单路径（即所有城市形成一个森林）。在初始情况下，数学王国中不存在任何的魔法桥。\n\n数学王国的国王拉格朗日很乐意传授小R 数学知识，但前提是小R 要先回答国王的问题。这些问题具有相同的形式，即一个智商为 $x$ 的人从城市 $u$ 旅行到城市 $v$（即经过 $u \\to v$ 这条路径上的所有城市，包括 $u$ 和 $v$）且做了所有城市内的数学题后，他所有得分的总和是多少。", "inputFormat": "第一行两个正整数 $n,m$ 和一个字符串 $type$。表示数学王国中共有 $n$ 座城市，发生了 $m$ 个事件，该数据的类型为 $type$。\n\n$type$ 字符串是为了能让大家更方便地获得部分分，你可能不需要用到这个输入。其具体含义在 **【限制与约定】** 中有解释。\n\n接下来 $n$ 行，第 $i$ 行表示初始情况下编号为 $i$ 的城市的魔法球中的函数。一个魔法用一个整数 $f$ 表示函数的类型，两个实数 $a,b$ 表示函数的参数，若\n\n- $f=1$，则函数为 $f(x)=\\sin(ax+b)$\n- $f=2$，则函数为 $f(x)=\\text e^{ax+b}$\n- $f=3$，则函数为 $f(x)=ax+b$\n\n接下来 $m$ 行，每行描述一个事件，事件分为四类。\n\n- `appear u v` 表示数学王国中出现了一条连接 $u$ 和 $v$ 这两座城市的魔法，保证连接前 $u,v$ 这两座城市不能互相到达。\n\n- `disappear u v` 表示数学王国中连接 $u,v$ 这两座城市的魔法桥消失了，保证这座魔法桥是存在的。\n\n- `magic c f a b` 表示城市 $c$ 的魔法球中的魔法变成了类型为 $f$，参数为 $a,b$ 的函数\n\n- `travel u v x` 表示询问一个智商为 $x$ 的人从城市 $u$ 旅行到城市 $v$ 后，他得分的总和是多少。若无法从 $u$ 到达 $v$，则输出一行一个字符串 `unreachable`。", "outputFormat": "对于每个询问，输出一行实数，表示得分的总和。", "hint": "【限制与约定】  \n对于 $100\\%$ 的数据，$1\\le n\\le 10^5, 1\\le m \\le 2 \\times 10^5$ 。\n\n本题共有 20 个数据点，每个数据点 5 分。\n\n测试点|$n$|$m$|数据类型\n:-:|:-:|:-:|:-:|\n$1$|$\\leq 100$|$\\leq 200$|C1\n$2 \\sim 5$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|A0\n$6$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|B0\n$7 \\sim 8$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|D0\n$9 \\sim 14$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|A1\n$15 \\sim 17$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|C1\n$18 \\sim 20$|$\\leq 10^5$|$\\leq 2 \\times 10^5$|D1\n\n数据类型的含义：\n\nA：不存在 `disappear` 事件，且所有`appear`事件中的 $u=v-1$\n\nB：不存在 `disappear` 事件\n\nC：所有的 `travel` 事件经过的城市总数 $\\le 5 \\times 10^6$（不可到达的城市对不计入在内）\n\nD：无限制\n\n0：所有 `travel` 事件中，$x=1$（即所有人的智商均为 $1$）\n\n1：无限制\n\n\n\n【评分标准】  \n\n如果你的答案与标准答案的相对误差在 $10^{-7}$ 以内或绝对误差在 $10^{-7}$ 以内，则被判定为正确。\n\n如果你的所有答案均为正确，则得满分，否则得 0 分。\n\n请注意输出格式：每行输出一个答案，答案只能为 `unreachable` 或者一个实数（建议使用科学计数法表示）。每行的长度不得超过 50。错误输出格式会被判定为 0 分。\n\n\n\n【小R 教你学数学】\n\n若函数 $f(x)$ 的 $n$ 阶导数在 $[a,b]$ 区间内连续，则对 $f(x)$ 在 $x_0 \\ (x_0\\in[a,b])$ 处使用 $n$ 次拉格朗日中值定理可以得到带拉格朗日余项的泰勒展开式\n\n$$f(x)=\\sum_{k=0}^{n-1}\\frac{f^{(k)}(x_0)(x-x_0)^k}{k!}+\\frac{f^{(n)}(\\xi)(x-x_0)^n}{n!},x\\in[a,b]$$\n\n其中，当 $x>x_0$ 时，$\\xi\\in[x_0,x]$。当 $x<x_0$ 时，$\\xi\\in[x,x_0]$。\n\n$f^{(n)}$ 表示函数 $f$ 的 $n$ 阶导数", "locale": "zh-CN"}}}
{"pid": "P4547", "type": "P", "difficulty": 7, "samples": [["2 2\n1 2 1 2 2\n2 1 2 1 1", "2"], ["3 5\n1 1 2 3 3\n1 3 2 2 2\n1 1 1 1 3\n1 2 1 3 1\n0 2 3", "7"], ["4 9\n2 4 1 4 2\n1 3 2 1 4\n2 2 1 4 4\n2 3 4 1 1\n2 4 3 2 4\n2 2 2 3 1\n0 1 3\n0 3 3\n1 2 3 1 2", "20"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["搜索", "2017", "记忆化搜索", "THUWC", "状压 DP"], "title": "[THUWC 2017] 随机二分图", "background": "", "description": "某人在玩一个非常神奇的游戏。这个游戏中有一个左右各 $n$ 个点的二分图，图中的边会按照一定的规律随机出现。\n\n为了描述这些规律，某人将这些边分到若干个组中。每条边或者不属于任何组 （这样的边一定不会出现），或者只属于一个组。\n\n有且仅有以下三类边的分组：\n\n0.  这类组每组只有一条边，该条边恰好有 $50\\%$ 的概率出现。\n\n1. 这类组每组恰好有两条边，这两条边有 $50\\%$ 的概率同时出现，有 $50\\%$ 的概率同时不出现。\n2. 这类组每组恰好有两条边，这两条边恰好出现一条，各有 $50\\%$ 的概率出现。\n\n组和组之间边的出现都是完全独立的。\n\n某人现在知道了边的分组和组的种类，想要知道完美匹配数量的期望是多少。你能帮助她解决这个问题吗？", "inputFormat": "从标准输入读入数据。\n\n第一行两个数 $n$ 和 $m$，表示图左右点数的数量和边的组的个数。我们用 $(a,b)$ （其中 $1 \\le a,b \\le n$）表示一条左端点为二分图左侧第 $a$ 个点，右端点为二分图右侧第 $b$ 个点的边。\n\n接下来 $m$ 行，每行描述一个组。开头第一个数 $t$ 表示组的种类，$t=0$ 表示是一条边的组，$t=1$ 表示是两条边的组中的第一种，$t=2$ 表示是两条边的组中的第二种。如果 $t=0$， 接下来两个数 $a_1,b_1$ 表示组内的第一条边；否则，接下来四个数 $a_1,b_1,a_2,b_2$， 表示该组内的两条边分别为 $(a_1,b_1)$  和 $(a_2,b_2)$。保证每条边至多出现一次。", "outputFormat": "输出到标准输出。\n\n假设期望的完美匹配数量是$E$。输出一行表示\n$$\n(2^{n} E) \\bmod (10^9 + 7)\n$$\n可以看出上式一定是一个整数。", "hint": "## 【定义解释】\n\n如果你对完美匹配和期望的定义很熟悉，那么你可以跳过本段。\n\n对于一个左右各 $n$ 个点的二分图，它的一个完美匹配是指 $n$ 条没有公共点的边构成的匹配。\n\n两个完美匹配不同，当且仅当它们至少含有一条不同的边。一个二分图完美匹配的数量定义为这张图能找到的两两不同的完美匹配的数量。\n\n在题目的图中，边都是随机出现的，因此这个图中完美匹配的数量是一个随机变量。一个（离散型）随机变量 $X$ 的期望定义为以概率为权，$X$ 所有可能取值的加权平均数，即\n$$\n\\sum_{x \\in V(X)}P[X=x]\\cdot x\n$$\n其中 $V(X)$ 表示 $X$ 所有可能的取值集合，$P[X=x]$ 表示 $X$ 取值为 $x$ 的概率。\n\n## 【数据规模和约定】\n\n对于 $5\\%$ 的数据 $n \\le 5$ 。  \n对于另 $5\\%$ 的数据 $n \\le 8$ 。  \n对于另 $10\\%$ 的数据 $n \\le 10$ 。  \n对于另 $15\\%$ 的数据，只有$t = 0$ 的情况。  \n对于另 $5\\%$ 的数据，只有$t = 0$ 的情况，且$m = n^2$，也就是该图为一个完全图。  \n对于另 $20\\%$ 的数据，只有 $t =0$ 或者 $t=1$ 的情况。\n对于另 $20\\%$ 的数据，只有 $t =0$ 或者 $t=2$ 的情况。\n对于 $100\\%$ 的数据，$n \\le 15$。", "locale": "zh-CN", "translations": {"en": {"title": "[THUWC 2017] Random Bipartite Graph", "background": "", "description": "Someone is playing a very magical game. In this game, there is a bipartite graph with $n$ vertices on the left and $n$ vertices on the right, and edges appear randomly according to certain rules.\n\nTo describe these rules, the edges are partitioned into several groups. Each edge either belongs to exactly one group, or to no group at all (such edges will never appear).\n\nThere are exactly the following three types of groups:\n\n0. Each such group contains exactly one edge, and that edge appears with probability $50\\%$.\n1. Each such group contains exactly two edges; the two edges either both appear with probability $50\\%$, or both do not appear with probability $50\\%$.\n2. Each such group contains exactly two edges; exactly one of the two appears, and each has probability $50\\%$ of appearing.\n\nEdge appearances from different groups are mutually independent.\n\nNow that the grouping and types of edges are given, one wants to know the expected number of perfect matchings. Can you help her solve this problem?", "inputFormat": "Read from standard input.\n\nThe first line contains two integers $n$ and $m$, denoting the number of vertices on each side of the bipartite graph and the number of edge groups. We use $(a,b)$ (where $1 \\le a, b \\le n$) to denote an edge whose left endpoint is the $a$-th vertex on the left and whose right endpoint is the $b$-th vertex on the right.\n\nThe next $m$ lines each describe one group. The first number $t$ denotes the group type, where $t=0$ means a one-edge group, $t=1$ means the first kind of two-edge group, and $t=2$ means the second kind of two-edge group. If $t=0$, then the next two integers $a_1, b_1$ specify the single edge in the group. Otherwise, the next four integers $a_1, b_1, a_2, b_2$ specify that the two edges in the group are $(a_1, b_1)$ and $(a_2, b_2)$. It is guaranteed that each edge appears at most once.", "outputFormat": "Output to standard output.\n\nSuppose the expected number of perfect matchings is $E$. Output one line:\n$$\n(2^{n} E) \\bmod (10^9 + 7)\n$$\nIt can be seen that the above expression is an integer.", "hint": "Definition Explanation.\n\nIf you are familiar with the definitions of perfect matching and expectation, you may skip this part.\n\nFor a bipartite graph with $n$ vertices on each side, a perfect matching is a matching consisting of $n$ edges with no shared endpoints.\n\nTwo perfect matchings are different if and only if they contain at least one different edge. The number of perfect matchings of a bipartite graph is defined as the number of pairwise distinct perfect matchings that can be found in this graph.\n\nIn this problem, edges appear randomly, so the number of perfect matchings is a random variable. The expectation of a (discrete) random variable $X$ is defined as the probability-weighted average of all possible values of $X$, i.e.,\n$$\n\\sum_{x \\in V(X)} P[X = x] \\cdot x\n$$\nwhere $V(X)$ denotes the set of all possible values of $X$, and $P[X = x]$ denotes the probability that $X$ takes the value $x$.\n\nConstraints.\n\n- For $5\\%$ of the testdata, $n \\le 5$.\n- For another $5\\%$ of the testdata, $n \\le 8$.\n- For another $10\\%$ of the testdata, $n \\le 10$.\n- For another $15\\%$ of the testdata, only $t = 0$ occurs.\n- For another $5\\%$ of the testdata, only $t = 0$ occurs and $m = n^2$, i.e., the graph is a complete graph.\n- For another $20\\%$ of the testdata, only $t = 0$ or $t = 1$ occurs.\n- For another $20\\%$ of the testdata, only $t = 0$ or $t = 2$ occurs.\n- For $100\\%$ of the testdata, $n \\le 15$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[THUWC 2017] 随机二分图", "background": "", "description": "某人在玩一个非常神奇的游戏。这个游戏中有一个左右各 $n$ 个点的二分图，图中的边会按照一定的规律随机出现。\n\n为了描述这些规律，某人将这些边分到若干个组中。每条边或者不属于任何组 （这样的边一定不会出现），或者只属于一个组。\n\n有且仅有以下三类边的分组：\n\n0.  这类组每组只有一条边，该条边恰好有 $50\\%$ 的概率出现。\n\n1. 这类组每组恰好有两条边，这两条边有 $50\\%$ 的概率同时出现，有 $50\\%$ 的概率同时不出现。\n2. 这类组每组恰好有两条边，这两条边恰好出现一条，各有 $50\\%$ 的概率出现。\n\n组和组之间边的出现都是完全独立的。\n\n某人现在知道了边的分组和组的种类，想要知道完美匹配数量的期望是多少。你能帮助她解决这个问题吗？", "inputFormat": "从标准输入读入数据。\n\n第一行两个数 $n$ 和 $m$，表示图左右点数的数量和边的组的个数。我们用 $(a,b)$ （其中 $1 \\le a,b \\le n$）表示一条左端点为二分图左侧第 $a$ 个点，右端点为二分图右侧第 $b$ 个点的边。\n\n接下来 $m$ 行，每行描述一个组。开头第一个数 $t$ 表示组的种类，$t=0$ 表示是一条边的组，$t=1$ 表示是两条边的组中的第一种，$t=2$ 表示是两条边的组中的第二种。如果 $t=0$， 接下来两个数 $a_1,b_1$ 表示组内的第一条边；否则，接下来四个数 $a_1,b_1,a_2,b_2$， 表示该组内的两条边分别为 $(a_1,b_1)$  和 $(a_2,b_2)$。保证每条边至多出现一次。", "outputFormat": "输出到标准输出。\n\n假设期望的完美匹配数量是$E$。输出一行表示\n$$\n(2^{n} E) \\bmod (10^9 + 7)\n$$\n可以看出上式一定是一个整数。", "hint": "## 【定义解释】\n\n如果你对完美匹配和期望的定义很熟悉，那么你可以跳过本段。\n\n对于一个左右各 $n$ 个点的二分图，它的一个完美匹配是指 $n$ 条没有公共点的边构成的匹配。\n\n两个完美匹配不同，当且仅当它们至少含有一条不同的边。一个二分图完美匹配的数量定义为这张图能找到的两两不同的完美匹配的数量。\n\n在题目的图中，边都是随机出现的，因此这个图中完美匹配的数量是一个随机变量。一个（离散型）随机变量 $X$ 的期望定义为以概率为权，$X$ 所有可能取值的加权平均数，即\n$$\n\\sum_{x \\in V(X)}P[X=x]\\cdot x\n$$\n其中 $V(X)$ 表示 $X$ 所有可能的取值集合，$P[X=x]$ 表示 $X$ 取值为 $x$ 的概率。\n\n## 【数据规模和约定】\n\n对于 $5\\%$ 的数据 $n \\le 5$ 。  \n对于另 $5\\%$ 的数据 $n \\le 8$ 。  \n对于另 $10\\%$ 的数据 $n \\le 10$ 。  \n对于另 $15\\%$ 的数据，只有$t = 0$ 的情况。  \n对于另 $5\\%$ 的数据，只有$t = 0$ 的情况，且$m = n^2$，也就是该图为一个完全图。  \n对于另 $20\\%$ 的数据，只有 $t =0$ 或者 $t=1$ 的情况。\n对于另 $20\\%$ 的数据，只有 $t =0$ 或者 $t=2$ 的情况。\n对于 $100\\%$ 的数据，$n \\le 15$。", "locale": "zh-CN"}}}
{"pid": "P4548", "type": "P", "difficulty": 7, "samples": [["2 2\n1 1\n3 1 2 1", "0002\n0010"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["字符串", "2006", "枚举", "期望", "KMP 算法", "概率生成函数", "CTSC/CTS"], "title": "[CTSC2006] 歌唱王国", "background": "", "description": "在歌唱王国，所有人的名字都是一个非空的仅包含整数 $1\\sim n$ 的字符串。\n\n王国里生活着一大群咕噜兵，他们靠不停地歌唱首领——牛人酋长们的名字来获取力量。咕噜兵每一次歌唱过程是这样的：首先，他从整数生成器那儿获得一个数字，然后花一个时间单位将此数字唱出来，如果他发现某个牛人酋长的名字已经被歌唱出来（即此名字是歌唱序列的一个连续子串），那么这次歌唱过程就立即结束。\n\n相关名词定义：\n\n- 歌唱序列：如果某人歌唱了 $x$ 个数字，第 $i$ 次歌唱的数字为 $a_i$，那么歌唱序列 $=(a_1,a_2,\\cdots,a_x)$。\n- 整数生成器：歌唱王国的神物，它有一个按钮，如果你按一下按钮，将从 $1\\sim n$ 数字中等概率的随机返回一个整数。\n- 歌唱时间：在一次歌唱过程中花费的时间。\n\n歌唱时间是随机的，无法预料；不过歌唱时间的期望值是固定的，此期望值即平均来说歌唱时间有多长，亦可称作平均歌唱时间。\n\n王国里的人非常喜欢歌唱，他们希望歌唱的时间越长越好，所以他们决定罢免一些牛人酋长，使得平均歌唱时间变长。但是他们不能罢免掉所有的牛人酋长，否则他们每次歌唱都无法停止，无法获取力量；于是他们决定只保留一个牛人酋长而罢免其余的牛人酋长。\n\n你的任务是：对于给定的 $n$、牛人酋长的个数 $t$ 以及每一个牛人酋长的名字，告诉王国里的人们，对于 $1\\leq i\\leq t$，如果保留第 $i$ 个牛人酋长，罢免掉其余的，那么平均歌唱时间将是多少。\n\n提示：此数为一个非负整数！\n\n输出要求：由于这个数字太大，所以你只需输出这个数的末 $4$ 位数字。如果不足 $4$ 位，则前面补 $0$（见样例）。\n", "inputFormat": "第一行，两个整数 $n,t$。以下 $t$ 行描述 $t$ 个牛人酋长名字。\n\n文件第 $i+1$（$1\\leq i\\leq t$）行格式如下：第一个数为 $m_i$ 表示第 $i$ 个牛人酋长的名字的长度，在一个空格之后，接下来有 $m_i$ 个数，用来描述这个牛人酋长的名字，相邻两个整数之间用一个空格分开。", "outputFormat": "共 $t$ 行，第 $i$ 行为一个整数，表示若保留第 $i$ 个牛人酋长而罢免其余的，则平均歌唱时间最长的末四位数字是多少。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 10^5$，$t\\leq 50$，$1\\leq m_i\\leq 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2006] Singing Kingdom", "background": "", "description": "In the Singing Kingdom, everyone’s name is a non-empty string consisting only of integers from $1\\sim n$.\n\nThere lives a large group of Gurubing soldiers in the kingdom. They gain power by continuously singing the names of the leaders—the “Niuren chieftains”. Each singing process works like this: first, a soldier gets a number from the integer generator, then spends one unit of time to sing this number. If he finds that the name of some Niuren chieftain has already been sung (that is, the name appears as a contiguous substring of the singing sequence), then this singing process ends immediately.\n\nDefinitions:\n\n- Singing sequence: If someone has sung $x$ numbers, and the number sung at the $i$-th step is $a_i$, then the singing sequence $=(a_1,a_2,\\cdots,a_x)$.\n- Integer generator: A divine object in the Singing Kingdom. It has a button; if you press it once, it returns a random integer from $1\\sim n$ with equal probability.\n- Singing time: The time spent in one singing process.\n\nThe singing time is random and unpredictable. However, its expected value is fixed. This expected value describes how long the singing time is on average, and can also be called the average singing time.\n\nPeople in the kingdom love singing. They want the singing time to be as long as possible, so they decide to remove (dismiss) some Niuren chieftains to make the average singing time longer. But they cannot remove all Niuren chieftains; otherwise, each singing process would never stop, and they would not be able to gain power. Therefore, they decide to keep only one Niuren chieftain and remove all the others.\n\nYour task is: given $n$, the number of Niuren chieftains $t$, and the name of each Niuren chieftain, for each $1\\leq i\\leq t$, if only the $i$-th Niuren chieftain is kept and all others are removed, output what the average singing time will be.\n\nHint: This number is a non-negative integer.\n\nOutput requirement: Because this number is too large, you only need to output its last $4$ digits. If it has fewer than $4$ digits, pad leading zeros (see the sample).", "inputFormat": "The first line contains two integers $n,t$. The following $t$ lines describe the names of the $t$ Niuren chieftains.\n\nLine $i+1$ ($1\\leq i\\leq t$) has the following format: the first number is $m_i$, the length of the $i$-th Niuren chieftain’s name. After a space, there are $m_i$ numbers describing this name, with one space between each pair of adjacent integers.", "outputFormat": "Output $t$ lines. The $i$-th line contains an integer, meaning the last four digits of the maximum average singing time when keeping only the $i$-th Niuren chieftain and removing all others.", "hint": "For $100\\%$ of the testdata, $1\\leq n\\leq 10^5$, $t\\leq 50$, $1\\leq m_i\\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2006] 歌唱王国", "background": "", "description": "在歌唱王国，所有人的名字都是一个非空的仅包含整数 $1\\sim n$ 的字符串。\n\n王国里生活着一大群咕噜兵，他们靠不停地歌唱首领——牛人酋长们的名字来获取力量。咕噜兵每一次歌唱过程是这样的：首先，他从整数生成器那儿获得一个数字，然后花一个时间单位将此数字唱出来，如果他发现某个牛人酋长的名字已经被歌唱出来（即此名字是歌唱序列的一个连续子串），那么这次歌唱过程就立即结束。\n\n相关名词定义：\n\n- 歌唱序列：如果某人歌唱了 $x$ 个数字，第 $i$ 次歌唱的数字为 $a_i$，那么歌唱序列 $=(a_1,a_2,\\cdots,a_x)$。\n- 整数生成器：歌唱王国的神物，它有一个按钮，如果你按一下按钮，将从 $1\\sim n$ 数字中等概率的随机返回一个整数。\n- 歌唱时间：在一次歌唱过程中花费的时间。\n\n歌唱时间是随机的，无法预料；不过歌唱时间的期望值是固定的，此期望值即平均来说歌唱时间有多长，亦可称作平均歌唱时间。\n\n王国里的人非常喜欢歌唱，他们希望歌唱的时间越长越好，所以他们决定罢免一些牛人酋长，使得平均歌唱时间变长。但是他们不能罢免掉所有的牛人酋长，否则他们每次歌唱都无法停止，无法获取力量；于是他们决定只保留一个牛人酋长而罢免其余的牛人酋长。\n\n你的任务是：对于给定的 $n$、牛人酋长的个数 $t$ 以及每一个牛人酋长的名字，告诉王国里的人们，对于 $1\\leq i\\leq t$，如果保留第 $i$ 个牛人酋长，罢免掉其余的，那么平均歌唱时间将是多少。\n\n提示：此数为一个非负整数！\n\n输出要求：由于这个数字太大，所以你只需输出这个数的末 $4$ 位数字。如果不足 $4$ 位，则前面补 $0$（见样例）。\n", "inputFormat": "第一行，两个整数 $n,t$。以下 $t$ 行描述 $t$ 个牛人酋长名字。\n\n文件第 $i+1$（$1\\leq i\\leq t$）行格式如下：第一个数为 $m_i$ 表示第 $i$ 个牛人酋长的名字的长度，在一个空格之后，接下来有 $m_i$ 个数，用来描述这个牛人酋长的名字，相邻两个整数之间用一个空格分开。", "outputFormat": "共 $t$ 行，第 $i$ 行为一个整数，表示若保留第 $i$ 个牛人酋长而罢免其余的，则平均歌唱时间最长的末四位数字是多少。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 10^5$，$t\\leq 50$，$1\\leq m_i\\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4549", "type": "P", "difficulty": 3, "samples": [["2\n4059 -1782\n", "99"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["数学", "最大公约数 gcd", "不定方程", "Bézout 定理", "模板题"], "title": "【模板】裴蜀定理", "background": "", "description": "给定一个包含 $n$ 个元素的**整数**序列 $A$，记作 $A_1,A_2,A_3,...,A_n$。\n\n求另一个包含 $n$ 个元素的待定**整数**序列 $X$，记 $S=\\sum\\limits_{i=1}^nA_i\\times X_i$，使得 $S>0$ 且 $S$ 尽可能的小。", "inputFormat": "第一行一个整数 $n$，表示序列元素个数。  \n\n第二行 $n$ 个整数，表示序列 $A$。", "outputFormat": "一行一个整数，表示 $S>0$ 的前提下 $S$ 的最小值。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 20$，$|A_i| \\le 10^5$，且 $A$ 序列不全为 $0$。", "locale": "zh-CN", "translations": {"en": {"title": "【Template】Bézout's Identity", "background": "", "description": "Given an **integer** sequence $A$ with $n$ elements, denoted as $A_1, A_2, A_3, \\ldots, A_n$.\n\nFind another **integer** sequence $X$ with $n$ elements. Let $S=\\sum\\limits_{i=1}^nA_i\\times X_i$, such that $S>0$ and $S$ is as small as possible.", "inputFormat": "The first line contains an integer $n$, the number of elements in the sequence.\n\nThe second line contains $n$ integers, the sequence $A$.", "outputFormat": "Output a single integer on one line, the minimal value of $S$ subject to $S>0$.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le n \\le 20$, $|A_i| \\le 10^5$, and the sequence $A$ is not all zeros.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】裴蜀定理", "background": "", "description": "给定一个包含 $n$ 个元素的**整数**序列 $A$，记作 $A_1,A_2,A_3,...,A_n$。\n\n求另一个包含 $n$ 个元素的待定**整数**序列 $X$，记 $S=\\sum\\limits_{i=1}^nA_i\\times X_i$，使得 $S>0$ 且 $S$ 尽可能的小。", "inputFormat": "第一行一个整数 $n$，表示序列元素个数。  \n\n第二行 $n$ 个整数，表示序列 $A$。", "outputFormat": "一行一个整数，表示 $S>0$ 的前提下 $S$ 的最小值。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 20$，$|A_i| \\le 10^5$，且 $A$ 序列不全为 $0$。", "locale": "zh-CN"}}}
{"pid": "P4550", "type": "P", "difficulty": 5, "samples": [["3", "21.25"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [165536, 165536, 165536, 165536, 165536, 165536, 165536, 165536, 165536, 165536, 165536]}, "tags": ["递推", "期望"], "title": "收集邮票", "background": "", "description": "有 $n$ 种不同的邮票，皮皮想收集所有种类的邮票。唯一的收集方法是到同学凡凡那里购买，每次只能买一张，并且买到的邮票究竟是 $n$ 种邮票中的哪一种是等概率的，概率均为 $1/n$。但是由于凡凡也很喜欢邮票，所以皮皮购买第 $k$ 次邮票需要支付 $k$ 元钱。\n\n现在皮皮手中没有邮票，皮皮想知道自己得到所有种类的邮票需要花费的钱数目的期望。", "inputFormat": "一行，一个数字 $N$（$N \\le 10000$）。", "outputFormat": "输出要付出多少钱，保留二位小数。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Collecting Stamps", "background": "", "description": "There are $n$ different kinds of stamps. Pipi wants to collect all kinds of stamps. The only way to collect is to buy from classmate Fanfan: each time Pipi can buy only one stamp, and which one of the $n$ kinds is obtained is equally likely, each with probability $1/n$. However, because Fanfan also likes stamps, Pipi must pay $k$ yuan for the $k$-th purchase.\n\nNow Pipi has no stamps. Pipi wants to know the expected amount of money needed to obtain all kinds of stamps.", "inputFormat": "One line, a single integer $N$ ($N \\le 10000$).", "outputFormat": "Output the amount of money to pay, with two decimal places.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "收集邮票", "background": "", "description": "有 $n$ 种不同的邮票，皮皮想收集所有种类的邮票。唯一的收集方法是到同学凡凡那里购买，每次只能买一张，并且买到的邮票究竟是 $n$ 种邮票中的哪一种是等概率的，概率均为 $1/n$。但是由于凡凡也很喜欢邮票，所以皮皮购买第 $k$ 次邮票需要支付 $k$ 元钱。\n\n现在皮皮手中没有邮票，皮皮想知道自己得到所有种类的邮票需要花费的钱数目的期望。", "inputFormat": "一行，一个数字 $N$（$N \\le 10000$）。", "outputFormat": "输出要付出多少钱，保留二位小数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4551", "type": "P", "difficulty": 4, "samples": [["4\n1 2 3\n2 3 4\n2 4 6", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "贪心", "字典树 Trie"], "title": "最长异或路径", "background": null, "description": "给定一棵 $n$ 个点的带权树，结点下标从 $1$ 开始到 $n$。求树中所有异或路径的最大值。\n\n异或路径指树上两个结点之间唯一路径上的所有边权的异或值。", "inputFormat": "第一行一个整数 $n$，表示结点数。\n\n接下来 $n-1$ 行，给出 $u,v,w$ ，分别表示树上的 $u$ 点和 $v$ 点有连边，边的权值是 $w$。", "outputFormat": "一行，一个整数表示答案。", "hint": "当两个结点分别是 $1,3$ 时，答案是 $7=3\\oplus 4$，取最大值。   \n\n### 数据范围\n\n$1\\le n \\le 10^5;0 < u,v \\le n;0 \\le w < 2^{31}$。", "locale": "zh-CN", "translations": {"en": {"title": "Longest XOR Path", "background": "", "description": "Given a weighted tree with $n$ nodes, indexed from $1$ to $n$. Find the maximum value among the XOR of all paths in the tree.\n\nAn XOR path is the XOR of all edge weights along the unique path between two nodes in the tree.\n\nConstraints\n$1 \\le n \\le 10^5; 0 < u, v \\le n; 0 \\le w < 2^{31}$.", "inputFormat": "The first line contains an integer $n$, the number of nodes.\n\nThe next $n-1$ lines each contain $u, v, w$, meaning there is an edge between node $u$ and node $v$ with weight $w$.", "outputFormat": "One line with a single integer, the answer.", "hint": "When the two nodes are $1$ and $3$, the value is $7=3\\oplus 4$, which is the maximum.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最长异或路径", "background": null, "description": "给定一棵 $n$ 个点的带权树，结点下标从 $1$ 开始到 $n$。求树中所有异或路径的最大值。\n\n异或路径指树上两个结点之间唯一路径上的所有边权的异或值。", "inputFormat": "第一行一个整数 $n$，表示结点数。\n\n接下来 $n-1$ 行，给出 $u,v,w$ ，分别表示树上的 $u$ 点和 $v$ 点有连边，边的权值是 $w$。", "outputFormat": "一行，一个整数表示答案。", "hint": "当两个结点分别是 $1,3$ 时，答案是 $7=3\\oplus 4$，取最大值。   \n\n### 数据范围\n\n$1\\le n \\le 10^5;0 < u,v \\le n;0 \\le w < 2^{31}$。", "locale": "zh-CN"}}}
{"pid": "P4552", "type": "P", "difficulty": 4, "samples": [["4\n1\n1\n2\n2", "1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["差分"], "title": "[Poetize6] IncDec Sequence", "background": null, "description": "给定一个长度为 $n$ 的数列 ${a_1,a_2,\\cdots,a_n}$，每次可以选择一个区间 $[l,r]$，使这个区间内的数都加 $1$ 或者都减 $1$。 \n  \n请问至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列有多少种。", "inputFormat": "第一行一个正整数 $n$。  \n接下来 $n$ 行，每行一个整数，第 $i+1$ 行的整数表示 $a_i$。", "outputFormat": "第一行输出最少操作次数。  \n第二行输出最终能得到多少种结果。", "hint": "对于 $100\\%$ 的数据，$n\\le 100000$，$0 \\le a_i \\le 2^{31}$。", "locale": "zh-CN", "translations": {"en": {"title": "[Poetize6] IncDec Sequence", "background": "", "description": "Given a sequence of length $n$, ${a_1,a_2,\\cdots,a_n}$, in each operation you may choose an interval $[l, r]$ and either add $1$ to every number in this interval or subtract $1$ from every number in this interval.\n  \nWhat is the minimum number of operations needed to make all numbers in the sequence equal, and under this minimum, how many different final sequences are possible?", "inputFormat": "The first line contains a positive integer $n$.\nThen $n$ lines follow; the integer on the $(i+1)$-th line is $a_i$.", "outputFormat": "Output the minimum number of operations on the first line.\nOutput the number of possible final sequences on the second line.", "hint": "Constraints: For $100\\%$ of the testdata, $n \\le 100000$, $0 \\le a_i \\le 2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Poetize6] IncDec Sequence", "background": null, "description": "给定一个长度为 $n$ 的数列 ${a_1,a_2,\\cdots,a_n}$，每次可以选择一个区间 $[l,r]$，使这个区间内的数都加 $1$ 或者都减 $1$。 \n  \n请问至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列有多少种。", "inputFormat": "第一行一个正整数 $n$。  \n接下来 $n$ 行，每行一个整数，第 $i+1$ 行的整数表示 $a_i$。", "outputFormat": "第一行输出最少操作次数。  \n第二行输出最终能得到多少种结果。", "hint": "对于 $100\\%$ 的数据，$n\\le 100000$，$0 \\le a_i \\le 2^{31}$。", "locale": "zh-CN"}}}
{"pid": "P4553", "type": "P", "difficulty": 6, "samples": [["6 3\n2 1 3 1 2 1\n2 6 8 5 0\n8 2 4 1\n6 1 0\n4 -1\n4", "27"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["网络流", "上下界网络流", "费用流"], "title": "80 人环游世界", "background": "", "description": "想必大家都看过成龙大哥的《80 天环游世界》，里面的紧张刺激的打斗场面一定给你留下了深刻的印象。现在就有这么一个 80 人的团伙，也想来一次环游世界。\n\n他们打算兵分多路，游遍每一个国家。\n\n因为他们主要分布在东方，所以他们只朝西方进军。设从东方到西方的每一个国家的编号依次为 $1, \\cdots, N$。假若第 $i$ 个人的游历路线为 $P_1,P_2,\\cdots ,P_k\\ (0\\le k\\le N)$，则 $P_1<P_2<\\cdots <P_k$。\n\n众所周知，中国相当美丽，这样在环游世界时就有很多人经过中国。我们用一个正整数 $V_i$ 来描述一个国家的吸引程度，$V_i$ 值越大表示该国家越有吸引力，同时也表示有且仅有 $V_i$ 个人会经过那一个国家。\n\n为了节省时间，他们打算通过坐飞机来完成环游世界的任务。同时为了省钱，他们希望总的机票费最小。\n  \n明天就要出发了，可是有些人临阵脱逃，最终只剩下了 $M$ 个人去环游世界。他们想知道最少的总费用，你能告诉他们吗？ ", "inputFormat": "第一行两个正整数 $N, M$。\n\n第二行有 $N$ 个不大于 $M$ 的正整数，分别表示 $V_1,V_2,\\cdots, V_N$。\n \n接下来有 $N - 1$ 行。第 $i$ 行有 $N - i$ 个整数，该行的第 $j$ 个数表示从第 $i$ 个国家到第 $i + j$ 个国家的机票费（如果该值等于 $-1$ 则表示这两个国家间没有通航）。", "outputFormat": "在第一行输出最少的总费用。", "hint": "在 $10\\%$ 的数据中，$M=1$；  \n在 $20\\%$ 的数据中，$1\\le M\\le 2$；  \n在 $40\\%$ 的数据中，$1\\le M\\le 3$；  \n在 $60\\%$ 的数据中，$1\\le M\\le 4$；  \n在 $100\\%$ 的数据中，$1 \\le N\\le 100$，$1\\le M\\le 79$。\n\n保证所以输入数据中最少费用小于 $10^6$。  \n保证至少存在一种可行方案。\n\n纪中联赛模拟题  \nBY CQF  ", "locale": "zh-CN", "translations": {"en": {"title": "Around the World with 80 People", "background": "", "description": "I’m sure many of you have seen Jackie Chan’s “Around the World in 80 Days,” and the intense, thrilling fight scenes must have left a deep impression. Now, there is a group of 80 people who also want to travel around the world.\n\nThey plan to split up and visit every country.\n\nSince they are mainly located in the East, they will only move westward. Let the countries from east to west be numbered $1, \\cdots, N$. If the $i$-th person’s itinerary is $P_1,P_2,\\cdots ,P_k\\ (0\\le k\\le N)$, then $P_1<P_2<\\cdots <P_k$.\n\nAs we all know, China is very beautiful, so many people will pass through China during their trip. We use a positive integer $V_i$ to describe a country’s attractiveness. The larger the value of $V_i$, the more attractive the country is, and it also means that exactly $V_i$ people will pass through that country.\n\nTo save time, they plan to travel by plane. To save money, they want the total airfare to be minimal.\n  \nThey are leaving tomorrow, but some people bailed at the last minute, and in the end only $M$ people will travel around the world. They want to know the minimal total cost. Please compute it.", "inputFormat": "The first line contains two positive integers $N, M$.\n\nThe second line has $N$ positive integers, each not greater than $M$, representing $V_1,V_2,\\cdots, V_N$.\n \nThen there are $N - 1$ lines. The $i$-th of these lines contains $N - i$ integers. The $j$-th number on this line is the airfare from the $i$-th country to the $(i + j)$-th country (if this value equals $-1$, then there is no direct flight between these two countries).", "outputFormat": "Output the minimal total cost on the first line.", "hint": "- In $10\\%$ of the testdata, $M=1$.\n- In $20\\%$ of the testdata, $1\\le M\\le 2$.\n- In $40\\%$ of the testdata, $1\\le M\\le 3$.\n- In $60\\%$ of the testdata, $1\\le M\\le 4$.\n- In $100\\%$ of the testdata, $1 \\le N\\le 100$, $1\\le M\\le 79$.\n\nIt is guaranteed that for all input, the minimal cost is less than $10^6$.  \nIt is guaranteed that there exists at least one feasible plan.\n\nJizhong League mock contest problem.  \nBy CQF.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "80 人环游世界", "background": "", "description": "想必大家都看过成龙大哥的《80 天环游世界》，里面的紧张刺激的打斗场面一定给你留下了深刻的印象。现在就有这么一个 80 人的团伙，也想来一次环游世界。\n\n他们打算兵分多路，游遍每一个国家。\n\n因为他们主要分布在东方，所以他们只朝西方进军。设从东方到西方的每一个国家的编号依次为 $1, \\cdots, N$。假若第 $i$ 个人的游历路线为 $P_1,P_2,\\cdots ,P_k\\ (0\\le k\\le N)$，则 $P_1<P_2<\\cdots <P_k$。\n\n众所周知，中国相当美丽，这样在环游世界时就有很多人经过中国。我们用一个正整数 $V_i$ 来描述一个国家的吸引程度，$V_i$ 值越大表示该国家越有吸引力，同时也表示有且仅有 $V_i$ 个人会经过那一个国家。\n\n为了节省时间，他们打算通过坐飞机来完成环游世界的任务。同时为了省钱，他们希望总的机票费最小。\n  \n明天就要出发了，可是有些人临阵脱逃，最终只剩下了 $M$ 个人去环游世界。他们想知道最少的总费用，你能告诉他们吗？ ", "inputFormat": "第一行两个正整数 $N, M$。\n\n第二行有 $N$ 个不大于 $M$ 的正整数，分别表示 $V_1,V_2,\\cdots, V_N$。\n \n接下来有 $N - 1$ 行。第 $i$ 行有 $N - i$ 个整数，该行的第 $j$ 个数表示从第 $i$ 个国家到第 $i + j$ 个国家的机票费（如果该值等于 $-1$ 则表示这两个国家间没有通航）。", "outputFormat": "在第一行输出最少的总费用。", "hint": "在 $10\\%$ 的数据中，$M=1$；  \n在 $20\\%$ 的数据中，$1\\le M\\le 2$；  \n在 $40\\%$ 的数据中，$1\\le M\\le 3$；  \n在 $60\\%$ 的数据中，$1\\le M\\le 4$；  \n在 $100\\%$ 的数据中，$1 \\le N\\le 100$，$1\\le M\\le 79$。\n\n保证所以输入数据中最少费用小于 $10^6$。  \n保证至少存在一种可行方案。\n\n纪中联赛模拟题  \nBY CQF  ", "locale": "zh-CN"}}}
{"pid": "P4554", "type": "P", "difficulty": 4, "samples": [["2 2\n@#\n#@\n0 0 1 1\n2 2\n@@\n@#\n0 1 1 0\n0 0", "2\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["广度优先搜索 BFS", "优先队列", "最短路", "队列"], "title": "小明的游戏", "background": "", "description": "小明最近喜欢玩一个游戏。给定一个 $n \\times m$ 的棋盘，上面有两种格子 `#` 和 `@`。游戏的规则很简单：给定一个起始位置和一个目标位置，小明每一步能向上，下，左，右四个方向移动一格。如果移动到同一类型的格子，则费用是 $0$，否则费用是 $1$。请编程计算从起始位置移动到目标位置的最小花费。", "inputFormat": "输入文件有多组数据。   \n输入第一行包含两个整数 $n$，$m$，分别表示棋盘的行数和列数。   \n输入接下来的 $n$ 行，每一行有 $m$ 个格子（使用 `#` 或者 `@` 表示）。   \n输入接下来一行有四个整数 $x_1, y_1, x_2, y_2$，分别为起始位置和目标位置。   \n当输入 $n$，$m$ 均为 $0$ 时，表示输入结束。  \n", "outputFormat": "对于每组数据，输出从起始位置到目标位置的最小花费。每一组数据独占一行。", "hint": "对于20%的数据满足：$1 \\le n, m \\le 10$。   \n对于40%的数据满足：$1 \\le n, m \\le 300$。   \n对于100%的数据满足：$1 \\le n, m \\le 500$。   ", "locale": "zh-CN", "translations": {"en": {"title": "Xiao Ming's Game", "background": "", "description": "Xiao Ming recently enjoys playing a game. Given an $n \\times m$ board with two types of cells `#` and `@`. The rules are simple: given a starting position and a target position, each step Xiao Ming can move one cell in one of the four directions: up, down, left, or right. If he moves onto a cell of the same type, the cost is $0$; otherwise, the cost is $1$. Write a program to compute the minimum cost to move from the starting position to the target position.", "inputFormat": "The input contains multiple test cases.  \nThe first line of each test case contains two integers $n$, $m$, the number of rows and columns of the board.  \nThe next $n$ lines each contain $m$ cells (denoted by `#` or `@`).  \nThe next line contains four integers $x_1, y_1, x_2, y_2$, the starting position and the target position, respectively.  \nThe input ends when both $n$ and $m$ are $0$.", "outputFormat": "For each test case, output the minimum cost from the starting position to the target position. Print one result per line.", "hint": "- For 20% of the testdata: $1 \\le n, m \\le 10$.  \n- For 40% of the testdata: $1 \\le n, m \\le 300$.  \n- For 100% of the testdata: $1 \\le n, m \\le 500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小明的游戏", "background": "", "description": "小明最近喜欢玩一个游戏。给定一个 $n \\times m$ 的棋盘，上面有两种格子 `#` 和 `@`。游戏的规则很简单：给定一个起始位置和一个目标位置，小明每一步能向上，下，左，右四个方向移动一格。如果移动到同一类型的格子，则费用是 $0$，否则费用是 $1$。请编程计算从起始位置移动到目标位置的最小花费。", "inputFormat": "输入文件有多组数据。   \n输入第一行包含两个整数 $n$，$m$，分别表示棋盘的行数和列数。   \n输入接下来的 $n$ 行，每一行有 $m$ 个格子（使用 `#` 或者 `@` 表示）。   \n输入接下来一行有四个整数 $x_1, y_1, x_2, y_2$，分别为起始位置和目标位置。   \n当输入 $n$，$m$ 均为 $0$ 时，表示输入结束。  \n", "outputFormat": "对于每组数据，输出从起始位置到目标位置的最小花费。每一组数据独占一行。", "hint": "对于20%的数据满足：$1 \\le n, m \\le 10$。   \n对于40%的数据满足：$1 \\le n, m \\le 300$。   \n对于100%的数据满足：$1 \\le n, m \\le 500$。   ", "locale": "zh-CN"}}}
{"pid": "P4555", "type": "P", "difficulty": 5, "samples": [["baacaabbacabb", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "线段树", "集训队互测", "枚举", "Manacher 算法"], "title": "[国家集训队] 最长双回文串", "background": "", "description": "顺序和逆序读起来完全一样的串叫做回文串。比如 `acbca` 是回文串，而 `abc` 不是：`abc` 的顺序为 `abc`，逆序为 `cba`，不相同。\n\n输入长度为 $n$ 的串 $S$，求 $S$ 的最长双回文子串 $T$，即可将 $T$ 分为两部分 $X, Y$（$|X|,|Y|≥1$）且 $X$ 和 $Y$ 都是回文串。", "inputFormat": "一行由小写英文字母组成的字符串 $S$。", "outputFormat": "一行一个整数，表示最长双回文子串的长度。", "hint": "**样例说明**\n\n从第二个字符开始的字符串 `aacaabbacabb` 可分为 `aacaa` 与 `bbacabb` 两部分，且两者都是回文串。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，$2\\leq |S|\\leq 10^5$。\n\n2018.12.10，2018.12.15：感谢 @Ycrpro 提供 hack 数据两组。", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] Longest Double Palindromic Substring", "background": "", "description": "A string that reads the same forward and backward is called a palindrome. For example, `acbca` is a palindrome, while `abc` is not: the forward order is `abc`, and the reverse is `cba`, which are not the same.\n\nGiven a string $S$ of length $n$, find the longest double palindromic substring $T$ of $S$, that is, $T$ can be divided into two parts $X, Y$ (with $|X|, |Y| \\ge 1$) and both $X$ and $Y$ are palindromes.", "inputFormat": "One line containing a string $S$ consisting of lowercase English letters.", "outputFormat": "One line with a single integer, the length of the longest double palindromic substring.", "hint": "**Sample Explanation**\n\nStarting from the second character, the string `aacaabbacabb` can be split into two parts `aacaa` and `bbacabb`, and both are palindromes.\n\n**Constraints**\n\nFor $100\\%$ of the testdata, $2 \\le |S| \\le 10^5$.\n\n2018.12.10, 2018.12.15: Thanks to @Ycrpro for providing two hack testdata sets.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] 最长双回文串", "background": "", "description": "顺序和逆序读起来完全一样的串叫做回文串。比如 `acbca` 是回文串，而 `abc` 不是：`abc` 的顺序为 `abc`，逆序为 `cba`，不相同。\n\n输入长度为 $n$ 的串 $S$，求 $S$ 的最长双回文子串 $T$，即可将 $T$ 分为两部分 $X, Y$（$|X|,|Y|≥1$）且 $X$ 和 $Y$ 都是回文串。", "inputFormat": "一行由小写英文字母组成的字符串 $S$。", "outputFormat": "一行一个整数，表示最长双回文子串的长度。", "hint": "**样例说明**\n\n从第二个字符开始的字符串 `aacaabbacabb` 可分为 `aacaa` 与 `bbacabb` 两部分，且两者都是回文串。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，$2\\leq |S|\\leq 10^5$。\n\n2018.12.10，2018.12.15：感谢 @Ycrpro 提供 hack 数据两组。", "locale": "zh-CN"}}}
{"pid": "P4556", "type": "P", "difficulty": 6, "samples": [["5 3\n1 2\n3 1\n3 4\n5 3\n2 3 3\n1 5 2\n3 3 3", "2\n3\n3\n0\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["线段树", "O2优化", "线段树合并", "模板题"], "title": "【模板】线段树合并 / [Vani 有约会] 雨天的尾巴", "background": "深绘里一直很讨厌雨天。\n\n灼热的天气穿透了前半个夏天，后来一场大雨和随之而来的洪水，浇灭了一切。\n\n虽然深绘里家乡的小村落对洪水有着顽固的抵抗力，但也倒了几座老房子，几棵老树被连根拔起，以及田地里的粮食被弄得一片狼藉。\n\n无奈的深绘里和村民们只好等待救济粮来维生。\n\n不过救济粮的发放方式很特别。", "description": "村落里一共有 $n$ 座房屋，并形成一个树状结构。然后救济粮分 $m$ 次发放，每次选择两个房屋 $(x, y)$，然后对于 $x$ 到 $y$ 的路径上（含 $x$ 和 $y$）每座房子里发放一袋 $z$ 类型的救济粮。\n\n然后深绘里想知道，当所有的救济粮发放完毕后，每座房子里存放的最多的是哪种救济粮。", "inputFormat": "输入的第一行是两个用空格隔开的正整数，分别代表房屋的个数 $n$ 和救济粮发放的次数 $m$。\n\n第 $2$ 到 第 $n$ 行，每行有两个用空格隔开的整数 $a, b$，代表存在一条连接房屋 $a$ 和 $b$ 的边。\n\n第 $(n + 1)$ 到第 $(n + m)$ 行，每行有三个用空格隔开的整数 $x, y, z$，代表一次救济粮的发放是从 $x$ 到 $y$ 路径上的每栋房子发放了一袋 $z$ 类型的救济粮。", "outputFormat": "输出 $n$ 行，每行一个整数，第 $i$ 行的整数代表 $i$ 号房屋存放最多的救济粮的种类，如果有多种救济粮都是存放最多的，输出种类编号最小的一种。\n\n如果某座房屋没有救济粮，则输出 $0$。", "hint": "- 对于 $20\\%$ 的数据，保证 $n, m \\leq 100$。\n- 对于 $50\\%$ 的数据，保证 $n, m \\leq 2 \\times 10^3$。\n- 对于 $100\\%$ 测试数据，保证 $1 \\leq n, m \\leq 10^5$，$1 \\leq a,b,x,y \\leq n$，$1 \\leq z \\leq 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "【Template】Segment Tree Merge / [Vani's Date] The Tail of a Rainy Day", "background": "Shenhuili has always disliked rainy days.\n\nScorching weather pierced through the first half of summer, then a heavy rain and the ensuing flood extinguished everything.\n\nAlthough the small village of Shenhuili’s hometown had a stubborn resistance to floods, several old houses still collapsed, a few old trees were uprooted, and the crops in the fields were left in a mess.\n\nHelpless, Shenhuili and the villagers could only wait for relief rations to survive.\n\nHowever, the distribution method was special.", "description": "There are $n$ houses in the village, forming a tree. Relief rations are distributed $m$ times. Each time, two houses $(x, y)$ are chosen. For every house on the path from $x$ to $y$ (including $x$ and $y$), one bag of type $z$ relief rations is given.\n\nAfter all distributions are finished, Shenhuili wants to know, for each house, which type of relief rations is stored the most.", "inputFormat": "The first line contains two positive integers $n$ and $m$.\n\nLines $2$ through $n$ each contain two integers $a, b$, indicating that there is an edge between houses $a$ and $b$.\n\nLines $(n + 1)$ through $(n + m)$ each contain three integers $x, y, z$, indicating that in one distribution, every house on the path from $x$ to $y$ receives one bag of type $z$ relief rations.", "outputFormat": "Output $n$ lines. The integer on the $i$-th line is the type of relief rations that appears most in house $i$. If multiple types are tied for the maximum, output the smallest type id.\n\nIf a house has no relief rations, output 0.", "hint": "- For $20\\%$ of the testdata, it is guaranteed that $n, m \\leq 100$.\n- For $50\\%$ of the testdata, it is guaranteed that $n, m \\leq 2 \\times 10^3$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n, m \\leq 10^5$, $1 \\leq a, b, x, y \\leq n$, and $1 \\leq z \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】线段树合并 / [Vani 有约会] 雨天的尾巴", "background": "深绘里一直很讨厌雨天。\n\n灼热的天气穿透了前半个夏天，后来一场大雨和随之而来的洪水，浇灭了一切。\n\n虽然深绘里家乡的小村落对洪水有着顽固的抵抗力，但也倒了几座老房子，几棵老树被连根拔起，以及田地里的粮食被弄得一片狼藉。\n\n无奈的深绘里和村民们只好等待救济粮来维生。\n\n不过救济粮的发放方式很特别。", "description": "村落里一共有 $n$ 座房屋，并形成一个树状结构。然后救济粮分 $m$ 次发放，每次选择两个房屋 $(x, y)$，然后对于 $x$ 到 $y$ 的路径上（含 $x$ 和 $y$）每座房子里发放一袋 $z$ 类型的救济粮。\n\n然后深绘里想知道，当所有的救济粮发放完毕后，每座房子里存放的最多的是哪种救济粮。", "inputFormat": "输入的第一行是两个用空格隔开的正整数，分别代表房屋的个数 $n$ 和救济粮发放的次数 $m$。\n\n第 $2$ 到 第 $n$ 行，每行有两个用空格隔开的整数 $a, b$，代表存在一条连接房屋 $a$ 和 $b$ 的边。\n\n第 $(n + 1)$ 到第 $(n + m)$ 行，每行有三个用空格隔开的整数 $x, y, z$，代表一次救济粮的发放是从 $x$ 到 $y$ 路径上的每栋房子发放了一袋 $z$ 类型的救济粮。", "outputFormat": "输出 $n$ 行，每行一个整数，第 $i$ 行的整数代表 $i$ 号房屋存放最多的救济粮的种类，如果有多种救济粮都是存放最多的，输出种类编号最小的一种。\n\n如果某座房屋没有救济粮，则输出 $0$。", "hint": "- 对于 $20\\%$ 的数据，保证 $n, m \\leq 100$。\n- 对于 $50\\%$ 的数据，保证 $n, m \\leq 2 \\times 10^3$。\n- 对于 $100\\%$ 测试数据，保证 $1 \\leq n, m \\leq 10^5$，$1 \\leq a,b,x,y \\leq n$，$1 \\leq z \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4557", "type": "P", "difficulty": 7, "samples": [["4 4 3\n0 0\n1 0\n0 1\n1 1\n-1 0\n0 3\n0 2\n0 -1\n0 0\n2 3\n0 -1", "1\n0\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "各省省选", "江苏", "向量", "凸包", "闵可夫斯基和 Minkowski sum"], "title": "[JSOI2018] 战争", "background": "", "description": "九条可怜是一个热爱读书的女孩子。\n\n在她最近正在读的一本小说中，描述了两个敌对部落之间的故事。第一个部落有 $n$ 个人，第二个部落有 $m$ 个人，每一个人的位置可以抽象成二维平面上坐标为 $(x_i,y_i)$ 的点。\n\n在这本书中，人们有很强的领地意识，对于平面上的任何一个点，如果它被三个来自同一部落的人形成的三角形（可能退化成一条线段）包含（包括边界），那么这一个点就属于这一个部落的领地。如果存在一个点同时在两个阵营的领地中，那么这两个部落就会为了争夺这一个点而发生战争。\n\n常年的征战让两个部落不堪重负，因此第二个部落的族长作出了一个英明的决定，他打算选择一个向量 $(dx,dy)$ ，让所有的族人都迁徙这个向量的距离，即所有第二阵营的人的坐标都变成 $(x_i+dx,y_i+dy)$ 。\n\n现在他计划了 $q$ 个迁徙的备选方案，他想要你来帮忙对每一个迁徙方案，计算一下在完成了迁徙之后，两个部落之间还会不会因为争夺领地而发生战争。\n", "inputFormat": "第一行输入三个整数 $n,m,q$，表示两个部落里的人数以及迁徙的备选方案数。\n\n接下来 $n$ 行每行两个整数 $x_i,y_i$​​ 表示第一个部落里的人的坐标。\n\n接下来 $m$ 行每行两个整数 $x_i,y_i$​​ 表示第二个部落里的人的坐标。\n\n接下来 $q$ 行每行两个整数 $dx_i,dy_i$​​ 表示一个迁徙方案。\n\n输入数据保证所有人的坐标两两不同。\n", "outputFormat": "对于每个迁徙方案，输出一行一个整数，$0$ 表示不会发生冲突，$1$ 表示会发生冲突。 ", "hint": "**样例 1 解释**\n\n下图为第一组方案中两个部落的私人领地，点 $(0,0)$ 同时属于两个部落，因此会发生战争。\n\n![0](https://i.loli.net/2018/05/05/5aed12638bab1.png)\n\n下图为第二组方案中两个部落的私人领地，没有点同时属于两个部落，因此不会发生战争。\n\n![1](https://i.loli.net/2018/05/05/5aed1293ce6ca.png)\n\n下图为第三组方案中两个部落的私人领地，点 $(0,0)$ 同时属于两个部落，因此会发生战争。\n\n![2](https://i.loli.net/2018/05/05/5aed12a4e3545.png)\n\n**数据范围**\n\n对于 $20\\%$ 的数据， $n,m\\le 5,q\\le 500$。\n\n对于 $40\\%$ 的数据， $n,m\\le 50,q\\le 500$ 。\n\n对于 $70\\%$ 的数据， $n,m\\le 10^4,q\\le 500$ 。\n\n对于 $100\\%$ 的数据， $n,m\\le 10^5,q\\le 10^5$ 。\n\n对于 $100\\%$ 的数据，保证 $-10^8\\le x_i,y_i,dx_i,dy_i\\le 10^8;n,m\\ge 3$ 。所有人的坐标两两不同且对于每一个阵营,所有人都不全共线。\n\n**2024/08/20 增加 6 组 hack 数据，并公开在本题附件。**", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2018] War", "background": "", "description": "Jiu Tiao Keliang is a girl who loves reading.\n\nIn a novel she is reading recently, there is a story about two hostile tribes. The first tribe has $n$ people, and the second tribe has $m$ people. The position of each person can be abstracted as a point with coordinates $(x_i,y_i)$ on the 2D plane.\n\nIn the novel, people have a strong sense of territory. For any point on the plane, if it is contained (including the boundary) in a triangle formed by three people from the same tribe (which may degenerate into a line segment), then this point belongs to that tribe’s territory. If there exists a point that lies in the territories of both tribes at the same time, then the two tribes will go to war to fight for that point.\n\nYears of war have exhausted both tribes, so the leader of the second tribe made a wise decision. He plans to choose a vector $(dx,dy)$ and move all his people by this vector, i.e., the coordinates of every person in the second tribe become $(x_i+dx,y_i+dy)$.\n\nNow he has prepared $q$ candidate migration plans. For each plan, he wants you to determine whether, after the migration, the two tribes will still go to war over territory.", "inputFormat": "The first line contains three integers $n,m,q$, denoting the numbers of people in the two tribes and the number of candidate migration plans.\n\nThe next $n$ lines each contain two integers $x_i,y_i$, denoting the coordinates of the people in the first tribe.\n\nThe next $m$ lines each contain two integers $x_i,y_i$, denoting the coordinates of the people in the second tribe.\n\nThe next $q$ lines each contain two integers $dx_i,dy_i$, denoting a migration plan.\n\nThe input guarantees that all people’s coordinates are pairwise distinct.", "outputFormat": "For each migration plan, output one integer per line. Output $0$ if no conflict will happen, and $1$ if a conflict will happen.", "hint": "**Sample 1 Explanation**\n\nThe figure below shows the territories of the two tribes in the first plan. The point $(0,0)$ belongs to both tribes, so a war will happen.\n\n![0](https://i.loli.net/2018/05/05/5aed12638bab1.png)\n\nThe figure below shows the territories of the two tribes in the second plan. No point belongs to both tribes, so no war will happen.\n\n![1](https://i.loli.net/2018/05/05/5aed1293ce6ca.png)\n\nThe figure below shows the territories of the two tribes in the third plan. The point $(0,0)$ belongs to both tribes, so a war will happen.\n\n![2](https://i.loli.net/2018/05/05/5aed12a4e3545.png)\n\n**Constraints**\n\nFor $20\\%$ of the testdata, $n,m\\le 5,q\\le 500$.\n\nFor $40\\%$ of the testdata, $n,m\\le 50,q\\le 500$.\n\nFor $70\\%$ of the testdata, $n,m\\le 10^4,q\\le 500$.\n\nFor $100\\%$ of the testdata, $n,m\\le 10^5,q\\le 10^5$.\n\nFor $100\\%$ of the testdata, it is guaranteed that $-10^8\\le x_i,y_i,dx_i,dy_i\\le 10^8$ and $n,m\\ge 3$. All people’s coordinates are pairwise distinct, and for each tribe, not all people are collinear.\n\n**2024/08/20 Added 6 sets of hack testdata, and made them public in the attachments of this problem.**\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2018] 战争", "background": "", "description": "九条可怜是一个热爱读书的女孩子。\n\n在她最近正在读的一本小说中，描述了两个敌对部落之间的故事。第一个部落有 $n$ 个人，第二个部落有 $m$ 个人，每一个人的位置可以抽象成二维平面上坐标为 $(x_i,y_i)$ 的点。\n\n在这本书中，人们有很强的领地意识，对于平面上的任何一个点，如果它被三个来自同一部落的人形成的三角形（可能退化成一条线段）包含（包括边界），那么这一个点就属于这一个部落的领地。如果存在一个点同时在两个阵营的领地中，那么这两个部落就会为了争夺这一个点而发生战争。\n\n常年的征战让两个部落不堪重负，因此第二个部落的族长作出了一个英明的决定，他打算选择一个向量 $(dx,dy)$ ，让所有的族人都迁徙这个向量的距离，即所有第二阵营的人的坐标都变成 $(x_i+dx,y_i+dy)$ 。\n\n现在他计划了 $q$ 个迁徙的备选方案，他想要你来帮忙对每一个迁徙方案，计算一下在完成了迁徙之后，两个部落之间还会不会因为争夺领地而发生战争。\n", "inputFormat": "第一行输入三个整数 $n,m,q$，表示两个部落里的人数以及迁徙的备选方案数。\n\n接下来 $n$ 行每行两个整数 $x_i,y_i$​​ 表示第一个部落里的人的坐标。\n\n接下来 $m$ 行每行两个整数 $x_i,y_i$​​ 表示第二个部落里的人的坐标。\n\n接下来 $q$ 行每行两个整数 $dx_i,dy_i$​​ 表示一个迁徙方案。\n\n输入数据保证所有人的坐标两两不同。\n", "outputFormat": "对于每个迁徙方案，输出一行一个整数，$0$ 表示不会发生冲突，$1$ 表示会发生冲突。 ", "hint": "**样例 1 解释**\n\n下图为第一组方案中两个部落的私人领地，点 $(0,0)$ 同时属于两个部落，因此会发生战争。\n\n![0](https://i.loli.net/2018/05/05/5aed12638bab1.png)\n\n下图为第二组方案中两个部落的私人领地，没有点同时属于两个部落，因此不会发生战争。\n\n![1](https://i.loli.net/2018/05/05/5aed1293ce6ca.png)\n\n下图为第三组方案中两个部落的私人领地，点 $(0,0)$ 同时属于两个部落，因此会发生战争。\n\n![2](https://i.loli.net/2018/05/05/5aed12a4e3545.png)\n\n**数据范围**\n\n对于 $20\\%$ 的数据， $n,m\\le 5,q\\le 500$。\n\n对于 $40\\%$ 的数据， $n,m\\le 50,q\\le 500$ 。\n\n对于 $70\\%$ 的数据， $n,m\\le 10^4,q\\le 500$ 。\n\n对于 $100\\%$ 的数据， $n,m\\le 10^5,q\\le 10^5$ 。\n\n对于 $100\\%$ 的数据，保证 $-10^8\\le x_i,y_i,dx_i,dy_i\\le 10^8;n,m\\ge 3$ 。所有人的坐标两两不同且对于每一个阵营,所有人都不全共线。\n\n**2024/08/20 增加 6 组 hack 数据，并公开在本题附件。**", "locale": "zh-CN"}}}
{"pid": "P4558", "type": "P", "difficulty": 7, "samples": [["2\n2 4\n0111\n1111\n2 4\n0010\n1000", "2\n5"]], "limits": {"time": [5000, 5000, 5000], "memory": [256000, 256000, 256000]}, "tags": ["2018", "各省省选", "江苏"], "title": "[JSOI2018] 机器人", "background": null, "description": "九条可怜是一个懒懒的女孩子。因为懒得扫地，九条可怜买了一架扫地机器人。\n\n九条可怜的家可以抽象成一个 $n \\times m$ 的网格，坐标从 $(1,1)$ 到 $(n,m)$ 。每一天晚上，可怜都会在 $(1,1)$ 处启动扫地机器人。在启动了之后，扫地机器人会按照设定好的路径开始行动，当再一次回到 $(1,1)$ 后便会停止。\n\n因为一些技术原因，扫地机器人只能向右（列编号加一）或者向下（行编号加一）走。为了让扫地机器人能够顺利的回到 $(1,1)$ ，可怜在家中安装了一些通道，使得：\n\n1.    如果机器人目前在 $(i,m)$ ，那么向右走一步会到 $(i,1)$ 。\n2.    如果机器人目前在 $(n,i)$ ，那么向下走一步回到 $(1,i)$ 。\n\n可怜希望，在启动了机器人之后，在机器人回到 $(1,1)$ 前，它可以经过每一个格子**恰好**一次。这样既可以把家里给打扫干净，也不会花太多时间。经过简单的计算，可怜很快就得到了所有不同的方案（两个方案是不同的当且仅当他们经过格子的顺序不同）。于是可怜把所有的方案都输入到了扫地机器人里。\n\n这一天可怜购置了一些新的家具，放好家具之后，家里便多了一些扫地机器人无法通过的障碍，于是在所有之前准备的方案中，扫地机器人都会撞上某一个障碍而停止工作。\n\n对于一个方案 $S$，可怜定义 $f(S)$ 为在这个方案中，扫地机器人在撞上障碍之前，经过了多少个格子。现在可怜想要对所有不同的方案，计算 $f(S)$ 的和。", "inputFormat": "**输入包含多组测试数据**。\n\n输入第一行一个整数 $T$ 表示测试数据的数量。\n\n对于每组测试数据，第一行输入两个整数 $n,m$ ，表示可怜家的大小。\n\n接下来 $n$ 行每行一个长度为 $m$ 的 01 字符串。第 $i$ 行第 $j$ 个字符是 $0$ 表示坐标 $(i,j)$ 的格子不是障碍，否则表示是障碍。\n\n输入保证 $(1,1)$ 不是障碍且至少有一个障碍。", "outputFormat": "对于每组测试数据，输出一行一个整数表示答案，答案可能很大，对 $998244353$ 取模后输出。", "hint": "**样例 2 解释**\n\n$n=2,m=4$ 时，一共有两种合法的方案：\n\n![0](https://i.loli.net/2018/05/05/5aed14bde4548.png)\n\n在第一种方案中,机器人在撞上障碍 $(1,3)$ 之前，一共经过了 $4$ 个格子。\n\n在第二种方案中,机器人在撞上障碍 $(2,1)$ 之前，一共经过了 $1$ 个格子。\n\n因此第二组测试数据的答案为 $1+4=5$ 。\n\n**数据范围**\n\n测试数据 1 $(20\\%)$: $n,m\\le 4$ 。\n\n测试数据 2 $(30\\%)$: $n,m\\le 50$ ，且除了 $(1,1)$ 外所有格子都是障碍。\n\n测试数据 3 $(50\\%)$: $n,m\\le 50$ 。\n\n对于所有测试数据，$T\\le 10;n,m\\ge 1$ 。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2018] Robot", "background": "", "description": "Jiutiao Kelian (pinyin) is a lazy girl. Because she is too lazy to sweep the floor, she bought a robot vacuum cleaner.\n\nKelian’s home can be abstracted as an $n \\times m$ grid, with coordinates from $(1,1)$ to $(n,m)$. Every night, Kelian starts the robot at $(1,1)$. After being started, the robot follows a preset route and stops when it returns to $(1,1)$ again.\n\nDue to technical reasons, the robot can only move right (column index plus one) or down (row index plus one). To ensure the robot can return to $(1,1)$ smoothly, Kelian installed some corridors such that:\n\n1. If the robot is currently at $(i,m)$, then moving one step to the right takes it to $(i,1)$.\n2. If the robot is currently at $(n,i)$, then moving one step down takes it to $(1,i)$.\n\nKelian hopes that, after starting the robot and before it returns to $(1,1)$, it passes through every cell exactly once. This way the house gets cleaned without taking too much time. After a simple calculation, she quickly obtained all different plans (two plans are different if and only if the orders in which they visit the cells are different). She then loaded all those plans into the robot.\n\nOn this day, Kelian bought some new furniture. After placing the furniture, some cells became obstacles that the robot cannot pass. Under all previously prepared plans, the robot will crash into some obstacle and stop.\n\nFor a plan $S$, define $f(S)$ as the number of cells the robot passes before it hits an obstacle under that plan. Now Kelian wants to compute the sum of $f(S)$ over all different plans.", "inputFormat": "The input contains multiple test cases.\n\nThe first line contains an integer $T$ denoting the number of test cases.\n\nFor each test case, the first line contains two integers $n, m$, denoting the size of the house.\n\nThen follow $n$ lines, each containing a binary string of length $m$. In the $i$-th line, the $j$-th character being '0' means the cell $(i,j)$ is not an obstacle; otherwise it is an obstacle.\n\nIt is guaranteed that $(1,1)$ is not an obstacle and there is at least one obstacle.", "outputFormat": "For each test case, output a single integer, the answer modulo $998244353$.", "hint": "Explanation for Sample 2\n\nWhen $n=2, m=4$, there are two valid plans:\n\n![0](https://i.loli.net/2018/05/05/5aed14bde4548.png)\n\nIn the first plan, the robot passes a total of 4 cells before it crashes into the obstacle at $(1,3)$.\n\nIn the second plan, the robot passes a total of 1 cell before it crashes into the obstacle at $(2,1)$.\n\nTherefore, the answer for the second test case is $1+4=5$.\n\nConstraints\n\n- Testdata 1 $(20\\%)$: $n, m \\le 4$.\n- Testdata 2 $(30\\%)$: $n, m \\le 50$, and all cells except $(1,1)$ are obstacles.\n- Testdata 3 $(50\\%)$: $n, m \\le 50$.\n- For all testdata, $T \\le 10; n, m \\ge 1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2018] 机器人", "background": null, "description": "九条可怜是一个懒懒的女孩子。因为懒得扫地，九条可怜买了一架扫地机器人。\n\n九条可怜的家可以抽象成一个 $n \\times m$ 的网格，坐标从 $(1,1)$ 到 $(n,m)$ 。每一天晚上，可怜都会在 $(1,1)$ 处启动扫地机器人。在启动了之后，扫地机器人会按照设定好的路径开始行动，当再一次回到 $(1,1)$ 后便会停止。\n\n因为一些技术原因，扫地机器人只能向右（列编号加一）或者向下（行编号加一）走。为了让扫地机器人能够顺利的回到 $(1,1)$ ，可怜在家中安装了一些通道，使得：\n\n1.    如果机器人目前在 $(i,m)$ ，那么向右走一步会到 $(i,1)$ 。\n2.    如果机器人目前在 $(n,i)$ ，那么向下走一步回到 $(1,i)$ 。\n\n可怜希望，在启动了机器人之后，在机器人回到 $(1,1)$ 前，它可以经过每一个格子**恰好**一次。这样既可以把家里给打扫干净，也不会花太多时间。经过简单的计算，可怜很快就得到了所有不同的方案（两个方案是不同的当且仅当他们经过格子的顺序不同）。于是可怜把所有的方案都输入到了扫地机器人里。\n\n这一天可怜购置了一些新的家具，放好家具之后，家里便多了一些扫地机器人无法通过的障碍，于是在所有之前准备的方案中，扫地机器人都会撞上某一个障碍而停止工作。\n\n对于一个方案 $S$，可怜定义 $f(S)$ 为在这个方案中，扫地机器人在撞上障碍之前，经过了多少个格子。现在可怜想要对所有不同的方案，计算 $f(S)$ 的和。", "inputFormat": "**输入包含多组测试数据**。\n\n输入第一行一个整数 $T$ 表示测试数据的数量。\n\n对于每组测试数据，第一行输入两个整数 $n,m$ ，表示可怜家的大小。\n\n接下来 $n$ 行每行一个长度为 $m$ 的 01 字符串。第 $i$ 行第 $j$ 个字符是 $0$ 表示坐标 $(i,j)$ 的格子不是障碍，否则表示是障碍。\n\n输入保证 $(1,1)$ 不是障碍且至少有一个障碍。", "outputFormat": "对于每组测试数据，输出一行一个整数表示答案，答案可能很大，对 $998244353$ 取模后输出。", "hint": "**样例 2 解释**\n\n$n=2,m=4$ 时，一共有两种合法的方案：\n\n![0](https://i.loli.net/2018/05/05/5aed14bde4548.png)\n\n在第一种方案中,机器人在撞上障碍 $(1,3)$ 之前，一共经过了 $4$ 个格子。\n\n在第二种方案中,机器人在撞上障碍 $(2,1)$ 之前，一共经过了 $1$ 个格子。\n\n因此第二组测试数据的答案为 $1+4=5$ 。\n\n**数据范围**\n\n测试数据 1 $(20\\%)$: $n,m\\le 4$ 。\n\n测试数据 2 $(30\\%)$: $n,m\\le 50$ ，且除了 $(1,1)$ 外所有格子都是障碍。\n\n测试数据 3 $(50\\%)$: $n,m\\le 50$ 。\n\n对于所有测试数据，$T\\le 10;n,m\\ge 1$ 。", "locale": "zh-CN"}}}
{"pid": "P4559", "type": "P", "difficulty": 6, "samples": [["5 5\n1 5 7 6 2\n1 5 2\n1 5 3\n1 3 9\n2 4 2\n3 5 5", "5\n4\n17\n9\n3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "线段树", "各省省选", "递归", "江苏", "可持久化线段树"], "title": "[JSOI2018] 列队", "background": "", "description": "作为一名大学生，九条可怜在去年参加了她人生中的最后一次军训。\n\n军训中的一个重要项目是练习列队，为了训练学生，教官给每一个学生分配了一个休息位置。每次训练开始前，所有学生都在各自的休息位置休息，但是当教官发出集合命令后，被点到的学生必须要到指定位置集合。\n\n为了简化问题，我们把休息位置和集合位置抽象成一根数轴。一共有 $n$ 个学生，第 $i$ 个学生的休息位置是 $a_i$。每一次命令，教官会指定一个区间 $[l,r]$ 和集合点 $K$ ，所有编号在 $[l,r]$ 内的学生都必须赶到集合点列队。在列队时，每一个学生需要选择 $[K,K+r-l]$ 中的一个整数坐标站定且不能有任何两个学生选择的坐标相同。学生从坐标 $x$ 跑到坐标 $y$ 需要耗费体力 $\\vert y-x \\vert$ 。\n\n在一天的训练中，教官一共发布了 $m$ 条命令 $(l,r,K)$ ，现在你需要计算对于每一条命令，在所有可能的列队方案中，消耗的体力值总和最小是多少。\n\n以下是对题意的一些补充：\n\n1.    任何两条命令是无关的，即在一条集合命令结束后，所有学生都会回到自己的休息位置，然后教官才会发出下一条命令。\n    \n2.    在集合的时候，可能有编号不在 $[l,r]$ 内的学生处在区间 $[K,K+r-l]$ 中，这时他会自己跑开，且跑动的距离不记在消耗的体力值总和中。\n\n", "inputFormat": "第一行输入两个整数 $n,m$。\n\n第二行 $n$ 个整数 $a_i$ 表示学生的休息位置。保证学生休息的位置两两不同。\n\n接下来 $m$ 行每行三个整数 $l,r,K$ 表示一条命令。\n", "outputFormat": "对于每一条命令输出一行一个整数表示最小的体力值总和。", "hint": "**样例 1 解释**\n\n\n在第一条命令中，五名学生依次跑到 $[2,5,4,6,3]$，则总代价为 $|2-1|+|5-5|+|4-7|+|6-6|+|3-2|=5$。\n    \n在第二条命令中，五名学生依次跑到 $[4,5,7,6,3]$，则总代价为 $|4-1|+|5-5|+|7-7|+|6-6|+|3-2|=4$。\n    \n在第三条命令中，三名学生依次跑到 $[11,10,9]$，则总代价为 $|11-1|+|10-5|+|9-7|=17$。\n    \n在第四条命令中，三名学生依次跑到 $[4,2,3]$，则总代价为 $|4-5|+|2-7|+|3-6|=9$。\n    \n在第五条命令中，三名学生依次跑到 $[7,6,5]$，则总代价为 $|7-7|+|6-6|+|5-2|=3$。\n\n**数据范围**\n\n对于 $10\\%$ 的数据，$n,m \\leq 10$；\n\n对于 $40\\%$ 的数据，$n,m \\leq 10^3$；\n\n对于 $70\\%$ 的数据，$n,m \\leq 10^5$；\n\n对于 $100\\%$ 的数据，$n,m \\leq 5 \\times 10^5,1 \\leq a_i,K \\leq 10^6$。\n\n对于 $100\\%$ 的数据，学生休息的位置两两不同。\n", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2018] Lineup", "background": "", "description": "As a university student, Jiutiao Kelian (pinyin) took part in the last military training of her life last year.\n\nAn important task in the training is practicing lineups. To train the students, the instructor assigns each student a rest position. Before each training session starts, all students rest at their own rest positions. When the instructor gives the gathering command, the selected students must gather at the specified location.\n\nTo simplify the problem, we model the rest positions and meeting positions as a number line. There are $n$ students, and the rest position of the $i$-th student is $a_i$. For each command, the instructor specifies an interval $[l, r]$ and a meeting point $K$. All students whose indices are in $[l, r]$ must rush to the meeting point to line up. During the lineup, each student must choose an integer coordinate in $[K, K + r - l]$ to stand on, and no two students may choose the same coordinate. If a student runs from coordinate $x$ to coordinate $y$, the stamina cost is $\\vert y - x \\vert$.\n\nDuring one day of training, the instructor issues $m$ commands $(l, r, K)$. For each command, you need to compute the minimum possible total stamina cost over all valid lineup assignments.\n\nAdditional clarifications:\n1. Any two commands are independent. That is, after one gathering command ends, all students return to their rest positions before the instructor issues the next command.\n2. During gathering, there may be students whose indices are not in $[l, r]$ but are located within $[K, K + r - l]$. They will move away on their own, and their movement distance is not counted in the total stamina cost.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe second line contains $n$ integers $a_i$ representing the rest positions of the students. All rest positions are pairwise distinct.\n\nEach of the next $m$ lines contains three integers $l, r, K$ describing a command.", "outputFormat": "For each command, output one line with a single integer, the minimum total stamina cost.", "hint": "$\\,\\boldsymbol{\\text{Explanation for Sample 1}}$\n\nIn the first command, the five students run to $[2,5,4,6,3]$ respectively; the total cost is $|2-1|+|5-5|+|4-7|+|6-6|+|3-2|=5$.\n\nIn the second command, the five students run to $[4,5,7,6,3]$ respectively; the total cost is $|4-1|+|5-5|+|7-7|+|6-6|+|3-2|=4$.\n\nIn the third command, the three students run to $[11,10,9]$ respectively; the total cost is $|11-1|+|10-5|+|9-7|=17$.\n\nIn the fourth command, the three students run to $[4,2,3]$ respectively; the total cost is $|4-5|+|2-7|+|3-6|=9$.\n\nIn the fifth command, the three students run to $[7,6,5]$ respectively; the total cost is $|7-7|+|6-6|+|5-2|=3$.\n\n$\\,\\boldsymbol{\\text{Constraints}}$\n\nFor $10\\%$ of the testdata, $n, m \\leq 10$.\n\nFor $40\\%$ of the testdata, $n, m \\leq 10^3$.\n\nFor $70\\%$ of the testdata, $n, m \\leq 10^5$.\n\nFor $100\\%$ of the testdata, $n, m \\leq 5 \\times 10^5$, $1 \\leq a_i, K \\leq 10^6$.\n\nFor $100\\%$ of the testdata, the students’ rest positions are pairwise distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2018] 列队", "background": "", "description": "作为一名大学生，九条可怜在去年参加了她人生中的最后一次军训。\n\n军训中的一个重要项目是练习列队，为了训练学生，教官给每一个学生分配了一个休息位置。每次训练开始前，所有学生都在各自的休息位置休息，但是当教官发出集合命令后，被点到的学生必须要到指定位置集合。\n\n为了简化问题，我们把休息位置和集合位置抽象成一根数轴。一共有 $n$ 个学生，第 $i$ 个学生的休息位置是 $a_i$。每一次命令，教官会指定一个区间 $[l,r]$ 和集合点 $K$ ，所有编号在 $[l,r]$ 内的学生都必须赶到集合点列队。在列队时，每一个学生需要选择 $[K,K+r-l]$ 中的一个整数坐标站定且不能有任何两个学生选择的坐标相同。学生从坐标 $x$ 跑到坐标 $y$ 需要耗费体力 $\\vert y-x \\vert$ 。\n\n在一天的训练中，教官一共发布了 $m$ 条命令 $(l,r,K)$ ，现在你需要计算对于每一条命令，在所有可能的列队方案中，消耗的体力值总和最小是多少。\n\n以下是对题意的一些补充：\n\n1.    任何两条命令是无关的，即在一条集合命令结束后，所有学生都会回到自己的休息位置，然后教官才会发出下一条命令。\n    \n2.    在集合的时候，可能有编号不在 $[l,r]$ 内的学生处在区间 $[K,K+r-l]$ 中，这时他会自己跑开，且跑动的距离不记在消耗的体力值总和中。\n\n", "inputFormat": "第一行输入两个整数 $n,m$。\n\n第二行 $n$ 个整数 $a_i$ 表示学生的休息位置。保证学生休息的位置两两不同。\n\n接下来 $m$ 行每行三个整数 $l,r,K$ 表示一条命令。\n", "outputFormat": "对于每一条命令输出一行一个整数表示最小的体力值总和。", "hint": "**样例 1 解释**\n\n\n在第一条命令中，五名学生依次跑到 $[2,5,4,6,3]$，则总代价为 $|2-1|+|5-5|+|4-7|+|6-6|+|3-2|=5$。\n    \n在第二条命令中，五名学生依次跑到 $[4,5,7,6,3]$，则总代价为 $|4-1|+|5-5|+|7-7|+|6-6|+|3-2|=4$。\n    \n在第三条命令中，三名学生依次跑到 $[11,10,9]$，则总代价为 $|11-1|+|10-5|+|9-7|=17$。\n    \n在第四条命令中，三名学生依次跑到 $[4,2,3]$，则总代价为 $|4-5|+|2-7|+|3-6|=9$。\n    \n在第五条命令中，三名学生依次跑到 $[7,6,5]$，则总代价为 $|7-7|+|6-6|+|5-2|=3$。\n\n**数据范围**\n\n对于 $10\\%$ 的数据，$n,m \\leq 10$；\n\n对于 $40\\%$ 的数据，$n,m \\leq 10^3$；\n\n对于 $70\\%$ 的数据，$n,m \\leq 10^5$；\n\n对于 $100\\%$ 的数据，$n,m \\leq 5 \\times 10^5,1 \\leq a_i,K \\leq 10^6$。\n\n对于 $100\\%$ 的数据，学生休息的位置两两不同。\n", "locale": "zh-CN"}}}
{"pid": "P4560", "type": "P", "difficulty": 5, "samples": [["10 3\n1 3 4 91220\n1 5 9 48623\n2 3 5 39412\n", "0\n0\n0\n39412\n39412\n39412\n48623\n48623\n48623\n48623\n"], ["10 6\n1 1 8 4\n2 4 9 1\n2 3 6 5\n1 0 5 3\n1 2 2 5\n2 6 7 0\n", "3\n4\n5\n4\n3\n3\n0\n0\n1\n0\n"]], "limits": {"time": [3001, 3001, 3001, 3001, 3001, 3001, 3001, 3001, 3001, 3001, 3001, 3001, 3001, 3001, 3001], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2014", "线段树", "IOI"], "title": "[IOI 2014] Wall 砖墙", "background": "原题为交互试题，但在此请提交**完整程序**。", "description": "给定一个长度为 $n$ 且初始值全为 $0$ 的序列。你需要支持以下两种操作：\n\n- Add $L, R, h$：将序列 $[L, R]$ 内所有值小于 $h$ 的元素都赋为 $h$，此时不改变高度大于 $h$ 的元素值\n- Remove $L, R, h$：将序列 $[L, R]$ 内所有值大于 $h$ 的元素都赋为 $h$，此时不改变高度小于 $h$ 的元素值\n\n你需要输出进行 $k$ 次上述操作之后的序列。", "inputFormat": "输入的第一行包含两个正整数 $n, k$，分别表示序列中元素的个数以及操作数量，注意：**序列下标编号为 $0$ ~ $n-1$**。\n\n接下来 $k$ 行每行包含 $4$ 个整数 $t, L, R, h$，若 $t = 1$ 则表明为 Add 操作，若 $t = 2$ 则表明为 Remove 操作。 $L, R, h$ 的含义见题目描述。", "outputFormat": "输出包含 $n$ 行，每行包含 $1$ 个整数。第 $i$ 行的整数表示 $k$ 次操作之后序列中编号为 $i - 1$ 的元素的值。", "hint": "- 子任务#1（8分）：满足 $1 \\leq n \\leq 10 000, 1 \\leq k \\leq 5 000$；\n- 子任务#2（24分）：满足 $1 \\leq n \\leq 100 000, 1 \\leq k \\leq 500 000$，全部增加操作均在全部移除操作之前；\n- 子任务#3（29分）：满足 $1 \\leq n \\leq 100 000, 1 \\leq k \\leq 500 000$；\n- 子任务#4（39分）：满足 $1 \\leq n \\leq 2 000 000, 1 \\leq k \\leq 500 000$。\n\n所有操作的高度 $h$ 满足 $0 \\leq h \\leq 100 000$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2014] Wall", "background": "The original problem was interactive, but here please submit a complete program.", "description": "You are given a sequence of length $n$ with all initial values equal to $0$. You need to support the following two operations:\n\n- Add $L, R, h$: For all elements in $[L, R]$ that are less than $h$, set them to $h$. Do not change elements whose height is greater than $h$.\n- Remove $L, R, h$: For all elements in $[L, R]$ that are greater than $h$, set them to $h$. Do not change elements whose height is less than $h$.\n\nYou need to output the sequence after performing $k$ operations.", "inputFormat": "The first line contains two positive integers $n, k$, representing the number of elements in the sequence and the number of operations. Note: indices are numbered from $0$ to $n - 1$.\n\nEach of the next $k$ lines contains $4$ integers $t, L, R, h$. If $t = 1$, it denotes an Add operation; if $t = 2$, it denotes a Remove operation. The meanings of $L, R, h$ are as described above.", "outputFormat": "Output $n$ lines. The integer on the $i$-th line is the value of the element with index $i - 1$ after all $k$ operations.", "hint": "- Subtask #1 (8 points): $1 \\leq n \\leq 10\\,000$, $1 \\leq k \\leq 5\\,000$.\n- Subtask #2 (24 points): $1 \\leq n \\leq 100\\,000$, $1 \\leq k \\leq 500\\,000$, all Add operations appear before all Remove operations.\n- Subtask #3 (29 points): $1 \\leq n \\leq 100\\,000$, $1 \\leq k \\leq 500\\,000$.\n- Subtask #4 (39 points): $1 \\leq n \\leq 2\\,000\\,000$, $1 \\leq k \\leq 500\\,000$.\n\nConstraints: For all operations, the height $h$ satisfies $0 \\leq h \\leq 100\\,000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2014] Wall 砖墙", "background": "原题为交互试题，但在此请提交**完整程序**。", "description": "给定一个长度为 $n$ 且初始值全为 $0$ 的序列。你需要支持以下两种操作：\n\n- Add $L, R, h$：将序列 $[L, R]$ 内所有值小于 $h$ 的元素都赋为 $h$，此时不改变高度大于 $h$ 的元素值\n- Remove $L, R, h$：将序列 $[L, R]$ 内所有值大于 $h$ 的元素都赋为 $h$，此时不改变高度小于 $h$ 的元素值\n\n你需要输出进行 $k$ 次上述操作之后的序列。", "inputFormat": "输入的第一行包含两个正整数 $n, k$，分别表示序列中元素的个数以及操作数量，注意：**序列下标编号为 $0$ ~ $n-1$**。\n\n接下来 $k$ 行每行包含 $4$ 个整数 $t, L, R, h$，若 $t = 1$ 则表明为 Add 操作，若 $t = 2$ 则表明为 Remove 操作。 $L, R, h$ 的含义见题目描述。", "outputFormat": "输出包含 $n$ 行，每行包含 $1$ 个整数。第 $i$ 行的整数表示 $k$ 次操作之后序列中编号为 $i - 1$ 的元素的值。", "hint": "- 子任务#1（8分）：满足 $1 \\leq n \\leq 10 000, 1 \\leq k \\leq 5 000$；\n- 子任务#2（24分）：满足 $1 \\leq n \\leq 100 000, 1 \\leq k \\leq 500 000$，全部增加操作均在全部移除操作之前；\n- 子任务#3（29分）：满足 $1 \\leq n \\leq 100 000, 1 \\leq k \\leq 500 000$；\n- 子任务#4（39分）：满足 $1 \\leq n \\leq 2 000 000, 1 \\leq k \\leq 500 000$。\n\n所有操作的高度 $h$ 满足 $0 \\leq h \\leq 100 000$。", "locale": "zh-CN"}}}
{"pid": "P4561", "type": "P", "difficulty": 6, "samples": [["2\n3 3 1 2\n1 3 4\n3 3 5 7\n1 3 4", "180\n720\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "贪心", "2018", "各省省选", "江西", "期望"], "title": "[JXOI2018] 排序问题", "background": "九条可怜是一个热爱思考的女孩子。", "description": "\n\n九条可怜最近正在研究各种排序的性质，她发现了一种很有趣的排序方法： Gobo sort ！\n\nGobo sort 的算法描述大致如下：\n\n- 假设我们要对一个大小为 $n$ 的数列 $a$ 排序。\n- 等概率随机生成一个大小为 $n$ 的排列 $p$ 。\n- 构造一个大小为 $n$ 的数列 $b$ 满足 $b_i=a_{p_i}$ ，检查 $b$ 是否有序，如果 $b$ 已经有序了就结束算法，并返回 $b$ ，不然返回步骤 2。\n\n\n显然这个算法的期望时间复杂度是 $O(n\\times n!)$ 的，但是九条可怜惊奇的发现，利用量子的神奇性质，在量子系统中，可以把这个算法的时间复杂度优化到线性。\n\n九条可怜对这个排序算法进行了进一步研究，她发现如果一个序列满足一些性质，那么 Gobo sort 会很快计算出正确的结果。为了量化这个速度，她定义 Gobo sort 的执行轮数是步骤 2 的执行次数。\n\n于是她就想到了这么一个问题：\n\n现在有一个长度为 $n$ 的序列 $x$ ，九条可怜会在这个序列后面加入 $m$ 个元素，每个元素是 $[l,r]$ 内的正整数。 她希望新的长度为 $n+m$ 的序列执行 Gobo sort 的期望执行轮数尽量的多。她希望得到这个最多的期望轮数。\n\n九条可怜很聪明，她很快就算出了答案，她希望和你核对一下，由于这个期望轮数实在是太大了，于是她只要求你输出对 $998244353$ 取模的结果。", "inputFormat": "第一行输入一个整数 $T$，表示数据组数。\n\n接下来 $2 \\times T$ 行描述了 $T$ 组数据。\n\n每组数据分成两行，第 1 行有四个正整数 $n,m,l,r$ ，表示数列的长度和加入数字的个数和加入数字的范围。\n第 2 行有 $n$ 个正整数，第 $i$ 个表示 $x_i$ 。", "outputFormat": "输出 $T$ 个整数，表示答案。\n", "hint": "###样例解释\n\n对于第一组数据，我们可以添加 $\\{1,2,2\\}$ 到序列的最末尾，使得这个序列变成 `1 3 4 1 2 2` ，那么进行一轮的成功概率是 $\\frac{1}{180}$ ，因此期望需要 $180$ 轮。\n\n对于第二组数据，我们可以添加 $\\{5,6,7\\}$ 到序列的最末尾，使得这个序列变成 `1 3 4 5 6 7` ，那么进行一轮的成功概率是 $\\frac{1}{720}$ ，因此期望需要 $720$ 轮。\n\n### 数据范围\n\n对于 30% 的数据， $T\\leq 10 , n,m,l,r\\leq 8$。  \n对于 50% 的数据， $T\\leq 300,n,m,l,r,a_i\\leq 300$ 。  \n对于 60% 的数据， $\\sum{r-l+1}\\leq 10^7$ 。  \n对于 70% 的数据， $\\sum{n} \\leq 2\\times 10^5$ 。  \n对于 90% 的数据， $m\\leq 2\\times 10^5$。  \n对于 100% 的数据， $T\\leq 10^5,n\\leq 2\\times 10^5,m\\leq 10^7,1\\leq l\\leq r\\leq 10^9$ ， $1\\leq a_i\\leq 10^9,\\sum{n}\\leq 2\\times 10^6$ 。", "locale": "zh-CN", "translations": {"en": {"title": "[JXOI2018] Sorting Problem", "background": "Kujou Karen is a girl who loves thinking.", "description": "Kujou Karen has recently been studying the properties of various sorting algorithms, and she discovered a very interesting sorting method: Gobo sort!\n\nThe algorithm of Gobo sort is roughly as follows:\n- Suppose we want to sort a sequence $a$ of size $n$.\n- Randomly and uniformly generate a permutation $p$ of size $n$.\n- Construct a sequence $b$ of size $n$ such that $b_i = a_{p_i}$, check whether $b$ is sorted. If $b$ is already sorted, end the algorithm and return $b$; otherwise, go back to step 2.\n\nObviously, the expected time complexity of this algorithm is $O(n \\times n!)$. However, to her surprise, by using the magic of quantum mechanics, in a quantum system this algorithm can be optimized to linear time.\n\nKujou Karen studied this sorting algorithm further and found that if a sequence satisfies certain properties, Gobo sort will quickly compute the correct result. To quantify this speed, she defines the number of rounds of Gobo sort as the number of times step 2 is executed.\n\nThen she came up with the following problem:\n\nNow there is a sequence $x$ of length $n$. Kujou Karen will append $m$ elements to the end of this sequence, each element being a positive integer in $[l, r]$. She wants the expected number of rounds for Gobo sort on the new sequence of length $n + m$ to be as large as possible. She wants to obtain this maximum expected number of rounds.\n\nKujou Karen is very smart and quickly computed the answer. She wants to check it with you. Since this expected number is too large, she only asks you to output the result modulo $998244353$.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nThe next $2 \\times T$ lines describe the $T$ test cases.\n\nEach test case consists of two lines. The first line contains four positive integers $n, m, l, r$, representing the length of the sequence, the number of added numbers, and the range of the added numbers. The second line contains $n$ positive integers; the $i$-th is $x_i$.", "outputFormat": "Output $T$ integers, the answers.", "hint": "### Sample Explanation\n\nFor the first test case, we can append $\\{1, 2, 2\\}$ to the end of the sequence, making it `1 3 4 1 2 2`. Then the success probability in one round is $\\frac{1}{180}$, so the expected number of rounds is $180$.\n\nFor the second test case, we can append $\\{5, 6, 7\\}$ to the end of the sequence, making it `1 3 4 5 6 7`. Then the success probability in one round is $\\frac{1}{720}$, so the expected number of rounds is $720$.\n\n### Constraints\n\n- For 30% of the testdata, $T \\leq 10$, $n, m, l, r \\leq 8$.\n- For 50% of the testdata, $T \\leq 300$, $n, m, l, r, a_i \\leq 300$.\n- For 60% of the testdata, $\\sum (r - l + 1) \\leq 10^7$.\n- For 70% of the testdata, $\\sum n \\leq 2 \\times 10^5$.\n- For 90% of the testdata, $m \\leq 2 \\times 10^5$.\n- For 100% of the testdata, $T \\leq 10^5$, $n \\leq 2 \\times 10^5$, $m \\leq 10^7$, $1 \\leq l \\leq r \\leq 10^9$, $1 \\leq a_i \\leq 10^9$, $\\sum n \\leq 2 \\times 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JXOI2018] 排序问题", "background": "九条可怜是一个热爱思考的女孩子。", "description": "\n\n九条可怜最近正在研究各种排序的性质，她发现了一种很有趣的排序方法： Gobo sort ！\n\nGobo sort 的算法描述大致如下：\n\n- 假设我们要对一个大小为 $n$ 的数列 $a$ 排序。\n- 等概率随机生成一个大小为 $n$ 的排列 $p$ 。\n- 构造一个大小为 $n$ 的数列 $b$ 满足 $b_i=a_{p_i}$ ，检查 $b$ 是否有序，如果 $b$ 已经有序了就结束算法，并返回 $b$ ，不然返回步骤 2。\n\n\n显然这个算法的期望时间复杂度是 $O(n\\times n!)$ 的，但是九条可怜惊奇的发现，利用量子的神奇性质，在量子系统中，可以把这个算法的时间复杂度优化到线性。\n\n九条可怜对这个排序算法进行了进一步研究，她发现如果一个序列满足一些性质，那么 Gobo sort 会很快计算出正确的结果。为了量化这个速度，她定义 Gobo sort 的执行轮数是步骤 2 的执行次数。\n\n于是她就想到了这么一个问题：\n\n现在有一个长度为 $n$ 的序列 $x$ ，九条可怜会在这个序列后面加入 $m$ 个元素，每个元素是 $[l,r]$ 内的正整数。 她希望新的长度为 $n+m$ 的序列执行 Gobo sort 的期望执行轮数尽量的多。她希望得到这个最多的期望轮数。\n\n九条可怜很聪明，她很快就算出了答案，她希望和你核对一下，由于这个期望轮数实在是太大了，于是她只要求你输出对 $998244353$ 取模的结果。", "inputFormat": "第一行输入一个整数 $T$，表示数据组数。\n\n接下来 $2 \\times T$ 行描述了 $T$ 组数据。\n\n每组数据分成两行，第 1 行有四个正整数 $n,m,l,r$ ，表示数列的长度和加入数字的个数和加入数字的范围。\n第 2 行有 $n$ 个正整数，第 $i$ 个表示 $x_i$ 。", "outputFormat": "输出 $T$ 个整数，表示答案。\n", "hint": "###样例解释\n\n对于第一组数据，我们可以添加 $\\{1,2,2\\}$ 到序列的最末尾，使得这个序列变成 `1 3 4 1 2 2` ，那么进行一轮的成功概率是 $\\frac{1}{180}$ ，因此期望需要 $180$ 轮。\n\n对于第二组数据，我们可以添加 $\\{5,6,7\\}$ 到序列的最末尾，使得这个序列变成 `1 3 4 5 6 7` ，那么进行一轮的成功概率是 $\\frac{1}{720}$ ，因此期望需要 $720$ 轮。\n\n### 数据范围\n\n对于 30% 的数据， $T\\leq 10 , n,m,l,r\\leq 8$。  \n对于 50% 的数据， $T\\leq 300,n,m,l,r,a_i\\leq 300$ 。  \n对于 60% 的数据， $\\sum{r-l+1}\\leq 10^7$ 。  \n对于 70% 的数据， $\\sum{n} \\leq 2\\times 10^5$ 。  \n对于 90% 的数据， $m\\leq 2\\times 10^5$。  \n对于 100% 的数据， $T\\leq 10^5,n\\leq 2\\times 10^5,m\\leq 10^7,1\\leq l\\leq r\\leq 10^9$ ， $1\\leq a_i\\leq 10^9,\\sum{n}\\leq 2\\times 10^6$ 。", "locale": "zh-CN"}}}
{"pid": "P4562", "type": "P", "difficulty": 5, "samples": [["2 4", "16\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "2018", "各省省选", "江西", "组合数学", "期望"], "title": "[JXOI2018] 游戏", "background": "九条可怜是一个富有的女孩子。", "description": "她长大以后创业了，开了一个公司。 但是管理公司是一个很累人的活，员工们经常背着可怜偷懒，可怜需要时不时对办公室进行检查。\n\n可怜公司有 $n$ 个办公室，办公室编号是 $l$ 到 $l+n-1$ ，可怜会事先制定一个顺序，按照这个顺序依次检查办公室。一开始的时候，所有办公室的员工都在偷懒，当她检查完编号是 $i$ 的办公室时候，这个办公室的员工会认真工作，并且这个办公室的员工通知所有办公室编号是 $i$ 的倍数的办公室，通知他们老板来了，让他们认真工作。因此，可怜检查完第 $i$ 个办公室的时候，所有编号是 $i$ 的倍数(包括 $i$ )的办公室的员工会认真工作。\n\n可怜发现了员工们通风报信的行为，她发现，对于每种不同的顺序 $p$ ，都存在一个最小的 $t(p)$ ，使得可怜按照这个顺序检查完前 $t(p)$ 个办公室之后，所有的办公室都会开始认真工作。她把这个 $t(p)$ 定义为 $p$ 的检查时间。\n\n可怜想知道所有 $t(p)$ 的和。\n\n但是这个结果可能很大，她想知道和对 $10^9+7$ 取模后的结果。", "inputFormat": "第一行输入两个整数 $l,r$ 表示编号范围，题目中的 $n$ 就是 $r-l+1$ 。", "outputFormat": "一个整数，表示所有 $t(p)$ 的和。", "hint": "### 样例解释\n\n考虑所有办公室被检查的相对顺序:\n\n{2 3 4} ,时间是 2 。\n{3 2 4} ,时间是 2 。\n{4 2 3} ,时间是 3 。\n{4 3 2} ,时间是 3 。\n{2 4 3} ,时间是 3 。\n{3 4 2} ,时间是 3 。\n\n和是 $16$ 。\n\n### 数据范围\n\n对于 20% 的数据，$r-l+1\\leq 8$。  \n对于另 10% 的数据，$l=1$。  \n对于另 10% 的数据，$l=2$。  \n对于另 30% 的数据，$l\\leq 200$。  \n对于 100% 的数据，$1\\leq l\\leq r\\leq 10^7$。", "locale": "zh-CN", "translations": {"en": {"title": "[JXOI2018] Game", "background": "Jiutiao Kelian (pinyin) is a wealthy girl.", "description": "After growing up, she started a business and founded a company. However, managing a company is exhausting. Employees often slack off behind Kelian’s back, so she has to inspect the offices from time to time.\n\nKelian’s company has $n$ offices, numbered from $l$ to $l + n - 1$. Kelian will decide an order in advance and inspect the offices one by one according to this order. At the beginning, all employees in all offices are slacking off. When she finishes inspecting the office with number $i$, the employees in that office start to work hard, and they also notify all offices whose numbers are multiples of $i$ to let them know the boss is here and start working. Therefore, after she finishes inspecting office $i$, all offices whose numbers are multiples of $i$ (including $i$ itself) will have their employees working hard.\n\nKelian discovered this behavior of passing along the message. She found that for every different order $p$, there exists a smallest $t(p)$ such that after she finishes inspecting the first $t(p)$ offices according to this order, all offices will have started working hard. She defines this $t(p)$ as the inspection time of $p$.\n\nKelian wants to know the sum of all $t(p)$.\n\nSince the result can be large, she wants the sum modulo $10^9 + 7$.", "inputFormat": "The first line contains two integers $l, r$ indicating the numbering range. In the problem, $n$ is $r - l + 1$.", "outputFormat": "Output a single integer, the sum of all $t(p)$.", "hint": "Sample Explanation\n\nConsider all relative orders in which the offices are inspected:\n\n{2, 3, 4}, the time is 2.  \n{3, 2, 4}, the time is 2.  \n{4, 2, 3}, the time is 3.  \n{4, 3, 2}, the time is 3.  \n{2, 4, 3}, the time is 3.  \n{3, 4, 2}, the time is 3.\n\nThe sum is $16$.\n\nConstraints\n\n- For 20% of the testdata, $r - l + 1 \\leq 8$.\n- For another 10% of the testdata, $l = 1$.\n- For another 10% of the testdata, $l = 2$.\n- For another 30% of the testdata, $l \\leq 200$.\n- For 100% of the testdata, $1 \\leq l \\leq r \\leq 10^7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JXOI2018] 游戏", "background": "九条可怜是一个富有的女孩子。", "description": "她长大以后创业了，开了一个公司。 但是管理公司是一个很累人的活，员工们经常背着可怜偷懒，可怜需要时不时对办公室进行检查。\n\n可怜公司有 $n$ 个办公室，办公室编号是 $l$ 到 $l+n-1$ ，可怜会事先制定一个顺序，按照这个顺序依次检查办公室。一开始的时候，所有办公室的员工都在偷懒，当她检查完编号是 $i$ 的办公室时候，这个办公室的员工会认真工作，并且这个办公室的员工通知所有办公室编号是 $i$ 的倍数的办公室，通知他们老板来了，让他们认真工作。因此，可怜检查完第 $i$ 个办公室的时候，所有编号是 $i$ 的倍数(包括 $i$ )的办公室的员工会认真工作。\n\n可怜发现了员工们通风报信的行为，她发现，对于每种不同的顺序 $p$ ，都存在一个最小的 $t(p)$ ，使得可怜按照这个顺序检查完前 $t(p)$ 个办公室之后，所有的办公室都会开始认真工作。她把这个 $t(p)$ 定义为 $p$ 的检查时间。\n\n可怜想知道所有 $t(p)$ 的和。\n\n但是这个结果可能很大，她想知道和对 $10^9+7$ 取模后的结果。", "inputFormat": "第一行输入两个整数 $l,r$ 表示编号范围，题目中的 $n$ 就是 $r-l+1$ 。", "outputFormat": "一个整数，表示所有 $t(p)$ 的和。", "hint": "### 样例解释\n\n考虑所有办公室被检查的相对顺序:\n\n{2 3 4} ,时间是 2 。\n{3 2 4} ,时间是 2 。\n{4 2 3} ,时间是 3 。\n{4 3 2} ,时间是 3 。\n{2 4 3} ,时间是 3 。\n{3 4 2} ,时间是 3 。\n\n和是 $16$ 。\n\n### 数据范围\n\n对于 20% 的数据，$r-l+1\\leq 8$。  \n对于另 10% 的数据，$l=1$。  \n对于另 10% 的数据，$l=2$。  \n对于另 30% 的数据，$l\\leq 200$。  \n对于 100% 的数据，$1\\leq l\\leq r\\leq 10^7$。", "locale": "zh-CN"}}}
{"pid": "P4563", "type": "P", "difficulty": 6, "samples": [["3\n2 3 1", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2018", "各省省选", "区间 DP", "江西"], "title": "[JXOI2018] 守卫", "background": "九条可怜是一个热爱运动的女孩子。", "description": "这一天她去爬山，她的父亲为了她的安全，雇了一些保镖，让他们固定地呆在在山的某些位置，来实时监视九条可怜，从而保护她。\n\n具体来说，一座山可以描述为一条折线，折线的下方是岩石。这条折线有 $n$ 个折点，每个折点上有一个亭子，第 $i$ 个折点的坐标是 $(i,h_i)$ 。九条可怜只可能会在亭子处玩耍，那些保镖也只会在亭子处监视可怜。\n\n由于技术方面的原因，一个保镖只能监视所有他能看得到的，横坐标不超过他所在位置的亭子。我们称一个保镖能看到一个亭子 $p$ ，当且仅当他所在的亭子 $q$ 和 $p$ 的连线不经过任何一块岩石。特别地，如果这条连线恰好经过了除了 $p,q$ 以外的亭子，那么我们认为保镖看不到可怜。\n\n雇佣保镖是一件很费钱的事情，可怜的父亲希望保镖越少越好。\n\n可怜的父亲还希望得到详尽的雇佣保镖的方案，他知道有些亭子可能正在维修，他想对所有的 $1\\leq l\\leq r\\leq n$ 计算：如果事先已知了只有区间 $[l,r]$ 的亭子可以用来玩耍（和监视），那么最少需要多少个保镖，才能让 $[l,r]$ 中的每一个亭子都被监视到。\n\n可怜的父亲已经得到了一个结果，他希望和你核实他的结果是否正确。", "inputFormat": "第一行输入一个整数 $n$ 表示亭子的数目。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数 $h_i$ 表示第 $i$ 个亭子的坐标是 $(i,h_i)$。", "outputFormat": "对所有的 $1\\leq l\\leq r\\leq n$ 计算：如果事先已知了可怜只会在 $[l,r]$ 这个区间的亭子里面玩耍，那么最少需要多少个保镖，才能让 $[l,r]$ 中的每一个亭子都被监视到。由于输出量太大，可怜的父亲只要你输出所有 $[l,r]$ 的答案的异或即可。\n", "hint": "### 样例解释\n\n如果 $r-l+1\\leq 2$，那么答案显然是 $1$。\n\n如果 $l=1$，$r=n$，那么答案是 $2$，需要安排两个保镖在 $(2,3),(3,1)$ 两个位置监视可怜。\n\n### 数据范围与提示\n\n对于 $30\\%$ 的数据，$n\\leq 20$。  \n对于 $70\\%$ 的数据，$n\\leq 500$。  \n对于 $100\\%$ 的数据，$n\\leq 5000$，$1\\leq h_i\\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[JXOI2018] Guards", "background": "Jiutiao Kelian is a girl who loves sports.", "description": "On this day she goes mountain climbing. For her safety, her father hires some bodyguards to stay fixed at certain positions on the mountain to monitor Jiutiao Kelian in real time and thus protect her.\n\nSpecifically, a mountain can be described as a polyline, and the area below the polyline is rock. This polyline has $n$ vertices, and there is a pavilion at each vertex. The $i$-th vertex has coordinates $(i, h_i)$. Jiutiao Kelian can only play at pavilions, and the bodyguards also only monitor at pavilions.\n\nDue to technical reasons, a guard can only monitor all pavilions he can see whose x-coordinate does not exceed his own position. We say a guard can see a pavilion $p$ if and only if the segment connecting his own pavilion $q$ and $p$ does not pass through any rock. In particular, if this segment happens to pass exactly through any pavilion other than $p$ and $q$, then we consider that the guard cannot see Kelian.\n\nHiring guards is expensive, so Kelian’s father wants as few guards as possible.\n\nKelian’s father also wants a detailed hiring plan. He knows some pavilions may be under maintenance. He wants to compute, for all $1 \\le l \\le r \\le n$: if it is known in advance that only the pavilions in the interval $[l, r]$ can be used for playing (and monitoring), what is the minimum number of guards needed so that every pavilion in $[l, r]$ is monitored.\n\nKelian’s father has already obtained a result, and he hopes you can verify whether his result is correct.", "inputFormat": "The first line contains an integer $n$ denoting the number of pavilions.\n\nThe second line contains $n$ integers, where the $i$-th integer $h_i$ means the $i$-th pavilion is at $(i, h_i)$.", "outputFormat": "For all $1 \\le l \\le r \\le n$, compute the minimum number of guards needed if it is known in advance that Kelian will only play at pavilions in $[l, r]$, so that every pavilion in $[l, r]$ is monitored. Since the output would be too large, Kelian’s father only asks you to output the XOR of the answers for all $[l, r]$.", "hint": "Sample Explanation:\n- If $r - l + 1 \\le 2$, the answer is $1$.\n- If $l = 1$, $r = n$, then the answer is $2$, and two guards are needed at $(2,3)$ and $(3,1)$ to monitor Kelian.\n\nConstraints:\n- For $30\\%$ of the testdata, $n \\le 20$.\n- For $70\\%$ of the testdata, $n \\le 500$.\n- For $100\\%$ of the testdata, $n \\le 5000$, $1 \\le h_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JXOI2018] 守卫", "background": "九条可怜是一个热爱运动的女孩子。", "description": "这一天她去爬山，她的父亲为了她的安全，雇了一些保镖，让他们固定地呆在在山的某些位置，来实时监视九条可怜，从而保护她。\n\n具体来说，一座山可以描述为一条折线，折线的下方是岩石。这条折线有 $n$ 个折点，每个折点上有一个亭子，第 $i$ 个折点的坐标是 $(i,h_i)$ 。九条可怜只可能会在亭子处玩耍，那些保镖也只会在亭子处监视可怜。\n\n由于技术方面的原因，一个保镖只能监视所有他能看得到的，横坐标不超过他所在位置的亭子。我们称一个保镖能看到一个亭子 $p$ ，当且仅当他所在的亭子 $q$ 和 $p$ 的连线不经过任何一块岩石。特别地，如果这条连线恰好经过了除了 $p,q$ 以外的亭子，那么我们认为保镖看不到可怜。\n\n雇佣保镖是一件很费钱的事情，可怜的父亲希望保镖越少越好。\n\n可怜的父亲还希望得到详尽的雇佣保镖的方案，他知道有些亭子可能正在维修，他想对所有的 $1\\leq l\\leq r\\leq n$ 计算：如果事先已知了只有区间 $[l,r]$ 的亭子可以用来玩耍（和监视），那么最少需要多少个保镖，才能让 $[l,r]$ 中的每一个亭子都被监视到。\n\n可怜的父亲已经得到了一个结果，他希望和你核实他的结果是否正确。", "inputFormat": "第一行输入一个整数 $n$ 表示亭子的数目。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数 $h_i$ 表示第 $i$ 个亭子的坐标是 $(i,h_i)$。", "outputFormat": "对所有的 $1\\leq l\\leq r\\leq n$ 计算：如果事先已知了可怜只会在 $[l,r]$ 这个区间的亭子里面玩耍，那么最少需要多少个保镖，才能让 $[l,r]$ 中的每一个亭子都被监视到。由于输出量太大，可怜的父亲只要你输出所有 $[l,r]$ 的答案的异或即可。\n", "hint": "### 样例解释\n\n如果 $r-l+1\\leq 2$，那么答案显然是 $1$。\n\n如果 $l=1$，$r=n$，那么答案是 $2$，需要安排两个保镖在 $(2,3),(3,1)$ 两个位置监视可怜。\n\n### 数据范围与提示\n\n对于 $30\\%$ 的数据，$n\\leq 20$。  \n对于 $70\\%$ 的数据，$n\\leq 500$。  \n对于 $100\\%$ 的数据，$n\\leq 5000$，$1\\leq h_i\\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4564", "type": "P", "difficulty": 6, "samples": [["3\n1 2 3\n6\n0 2 1 1\n1 1 2\n0 2 1 1\n0 3 1 1\n1 1 2\n1 3 1 2 3", "1\n0\n499122177 0 499122177\n1 0 2\n"], ["3\n1 1 1\n4\n0 2 1 2\n1 2 1 2\n0 3 2 3\n1 3 1 2 3", "249561089 748683265\n804141285 887328314 305019108\n1 499122177 332748118\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "2018", "O2优化", "枚举", "期望", "CTSC/CTS"], "title": "[CTSC2018] 假面", "background": "\n针针是绿绿的好朋友。", "description": "针针喜欢玩一款叫做 DotA (**D**efense **o**f **t**he **A**lgorithm) 的游戏，在这个游戏中，针针会操纵自己的英雄与队友一起对抗另一支队伍。\n针针在 DotA 中最喜欢使用的英雄叫做假面（Faceless），该英雄有 $2$ 个技能：\n\n- 锁定：对一名指定的敌方单位使用，以 $p$ 的概率对该单位造成 $1$ 点伤害（使其减少 $1$ 点生命值）。\n- 结界：在一片区域施放结界，让该区域内的所有其他单位无法动弹。\n在游戏中，如果一个单位的生命值降至 $0$ 或 $0$ 以下，那么该单位就会死亡。\n\n针针操纵假面的水平一般，因此他决定勤加练习。现在有 $n$ 个敌方单位（编号从 $1$ 至 $n$），编号为 $i$ 的敌方单位有 $h_i$ 点生命值。\n\n针针已经安排好了练习的计划，他会按顺序施放 $Q$ 个技能：\n\n- 对于锁定技能：针针会指定一个敌方单位 $id$ ，并对它施放。由于决定概率系数 $p$ 的因素很多，因此每次的 $p$ 都不一定相同。\n特别地，如果该敌方单位已经死亡，那么该技能不会造成任何效果。\n- 对于结界技能：针针会希望对 $k$ 个指定的敌方单位施放，但由于针针并不擅长施放该技能，因此他只能命中恰好 $1$ 个敌方单位。命中每个存活的敌方单位的概率是相等的（也就是说已经死亡的敌方单位不会有任何影响）。\n特别地，如果这 $k$ 个敌方单位均已死亡，那么该技能同样不会命中任何敌方单位。\n\n现在，围观针针进行练习的绿绿想知道：\n\n1. 对于针针施放的每个结界技能，它命中各敌人的概率分别是多少。\n2. 在针针的所有技能施放完毕后，所有敌方单位剩余生命值的期望分别是多少。\n\n由于绿绿还要围观针针训练，所以请你帮他解决这两个问题。\n\n为了防止精度误差，对于所有需要输出的数值，请输出其在模 $998244353$ 意义下的值。\n\n由于结界为假面的终极技能，因此针针施放该技能的次数不会太多。具体请见”子任务“。", "inputFormat": "第 $1$ 行为 $1$ 个正整数 $n$ ，表示敌方单位的数量。  \n第 $2$ 行为 $n$ 个正整数 $m_1,\\cdots , m_n$，依次表示各敌方单位的初始生命值。  \n第 $3$ 行为 $1$ 个非负整数 $Q$ ，表示针针施放技能的数量。  \n第 $4$ 行至第 $Q + 3$ 行，每行描述一个技能，第 $i + 3$ 行描述第 $i$ 个技能。\n\n每行的开头为一个整数 $op$ ，表示该技能的种类。  \n如果 $op = 0$ ，则表示锁定技能。并在此后跟随着 $3$ 个正整数 $id , u , v$ ，表示技能施放的目标为 $id$ ，技能命中的概率为 $p = \\frac{u}{v}$ 。（保证 $1\\le id \\le n , 0 < u \\le v < 998244353$ ）  \n如果 $op = 1$ ，则表示结界技能。并在此后跟随着 $1$ 个正整数 $k$ 表示技能施放的目标数量，随后还有额外的 $k$ 个数 $id_1,\\cdots,id_k$ 描述技能施放的所有目标。（保证所有 $1 \\le id_i \\le n$ 互不相同） 对于每一行，如果行内包含多个数，则用单个空格将它们隔开。", "outputFormat": "输出包括 $C + 1$ 行（其中 $C$ 为结界技能的数量）：\n\n前 $C$ 行依次对应每个结界技能，对于每行：\n\n输出 $k$ 个数，第 $i$ 个数表示结界命中敌方单位 $id_i$ 的概率。   \n第 $C + 1$ 行输出 $n$ 个数，第 $i$ 个数表示在所有技能施放完毕后，敌方单位 $i$ 剩余生命值的期望值。  \n\n对于每一行，如果行内包含多个数，则用单个空格将它们隔开。\n\n对于所有数值，请输出它们对 $998244353$ 取模的结果：即设答案化为最简分式后的形式为 $\\frac{a}{b}$ ，其中 $a$ 和 $b$ 的互质。输出整数 $x$ 使得 $bx \\equiv a\\bmod 998244353$ 且 $0 \\le x < 998244353$ 。（可以证明这样的整数 $x$ 是唯一的）\n", "hint": "### 样例解释 1\n针针按顺序施放如下技能：\n\n1. 对敌方单位 $2$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。此时 $2$ 号敌方单位必定剩余 $1$ 点生命值。\n2. 对敌方单位 $2$ 施放技能结界：（由于 $2$ 号敌方单位尚存活，）必定命中 $2$ 号单位。\n3. 对敌方单位 $2$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。\n4. 对敌方单位 $3$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。此时三个敌方单位的生命值一定分别为 $1, 0 ,2$ ，敌方单位 $2$ 一定死亡。\n5. 对敌方单位 $2$ 施放技能结界：（由于 $2$ 号敌方单位已死亡，）必定不命中任何单位。\n6. 对敌方单位 $1, 2, 3$ 施放技能结界：命中敌方单位 $1, 3$ 的概率是相等的，即各 $\\frac{1}{2}$ 。 最终，三个敌方单位的剩余生命值一定为 $1 , 0 , 2$ 。\n\n### 样例解释 2\n对于各结界技能的分析：\n\n1. 第 $1$ 个结界（目标为敌方单位 $1,2$ ）：\n- $2$ 号敌方单位存活的概率为 $\\frac{1}{2}$ ， $1$ 号敌方单位必定存活。\n- 如果 $2$ 号敌方单位存活，那么结界命中 $1 , 2$ 的概率相等，均为 $\\frac{1}{2}$ ；如果 $2$ 号敌方单位死亡，那么结界必定命中 $1$ 号敌方单位。\n- 因此：命中 $1$ 号敌方单位的概率为 $\\frac{1}{2} \\times 1 + \\frac{1}{2} \\times \\frac{1}{2} = \\frac{3}{4}$ ；命中 $2$ 号敌方单位的概率为 $\\frac{1}{2} \\times 0 + \\frac{1}{2} \\times \\frac{1}{2} = \\frac{1}{4}$ 。\n2. 第 $2$ 个结界（目标为敌方单位 $1, 2, 3$ ）：\n- 三个敌方单位存活的概率分别为 $1, \\frac{1}{2} , \\frac{1}{3}$ 。\n- $1 , 2 , 3$ 同时存活的概率为 $\\frac{1}{6}$ ；只有 $1, 2$ 存活的概率为 $\\frac{1}{3}$ ；只有 $1 , 3$ 存活的概率为 $\\frac{1}{6}$ ；只有 $1$ 存活的概率为 $\\frac{1}{3}$ 。\n- 因此：命中 $1$ 号敌方单位的概率为 $\\frac{1}{6} \\times \\frac{1}{3} + (\\frac{1}{3}+\\frac{1}{6}) \\times \\frac{1}{2}+ \\frac{1}{3} \\times 1 = \\frac{23}{36}$ ；命中 $2$ 号敌方单位的概率为 $\\frac{1}{6} \\times \\frac{1}{3} + \\frac{1}{3} \\times \\frac{1}{2} = \\frac{2}{9}$ ；命中 $3$ 号敌方单位的概率为 $\\frac{1}{6} \\times \\frac{1}{3} + \\frac{1}{6} \\times \\frac{1}{2} = \\frac{5}{36}$ 。 最终，三个敌方单位的剩余生命值的期望值为 $1 , \\frac{1}{2} , \\frac{1}{3}$ 。\n\n\n### 数据范围\n\n我们记 $C$ 为结界技能的数量。\n\n测试点编号|n=|Q=|C=|u,v|其他限制\n-|-|-|-|-|-\n1|5|21|6|u<v|无\n2|60|199992|500|u<v|所有 p 均相等\n3|60|23|6|u<v|所有m_i =1\n4|60|199994|500|u<v|无\n5|60|199995|500|u<v|无\n6|60|199996|0|u<v|无\n7|60|199997|500|u=v|无\n8|200|199998|1000|u<v|无\n9|200|199999|1000|u<v|无\n10|200|200000|1000|u<v|无\n\n对于所有测试点，保证 $n \\le 200 , Q \\le 200000 , C \\le 1000 , m_i \\le 100$ 。\n\n提示\n\nQ 的个位可以帮助你快速确定测试点的编号。\n测试点顺序可能与难度无关。\n\n感谢 @和泉正宗 提供题面 ", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2018] Faceless", "background": "Zhenzhen is Lvlv’s good friend.", "description": "Zhenzhen likes to play a game called DotA (Defense of the Algorithm). In this game, Zhenzhen controls his hero and fights alongside teammates against another team.\nZhenzhen’s favorite hero in DotA is called “Faceless,” and this hero has $2$ skills:\n\n- Lock: Cast on a specified enemy unit, dealing $1$ point of damage (reducing its health by $1$) with probability $p$.\n- Barrier: Cast on an area to trap all other units in that area so they cannot move.\nIn the game, if a unit’s health drops to $0$ or below, that unit dies.\n\nZhenzhen is not very skilled at controlling Faceless, so he decides to practice diligently. There are $n$ enemy units (numbered from $1$ to $n$), and the enemy unit numbered $i$ has $m_i$ health points.\n\nZhenzhen has arranged a practice plan in which he will cast $Q$ skills in order:\n\n- For the Lock skill: Zhenzhen specifies an enemy unit $id$ and casts it on that unit. Since many factors determine the probability parameter $p$, the value of $p$ may be different each time.\nIn particular, if the specified enemy unit is already dead, then this skill has no effect.\n- For the Barrier skill: Zhenzhen intends to cast it on $k$ specified enemy units, but since he is not good at casting this skill, he can hit exactly $1$ enemy unit. The probability of hitting each living enemy unit is equal (i.e., already dead enemy units have no effect).\nIn particular, if all $k$ specified enemy units are already dead, then this skill also does not hit any unit.\n\nNow, Lvlv, who is watching Zhenzhen practice, wants to know:\n\n1. For each Barrier skill that Zhenzhen casts, what is the probability that it hits each enemy, respectively.\n2. After all of Zhenzhen’s skills have been cast, what is the expected remaining health of each enemy unit.\n\nTo prevent precision errors, for all numerical outputs, please output their values modulo $998244353$.\n\nSince Barrier is Faceless’s ultimate skill, the number of times Zhenzhen casts it will not be too many. See Constraints.", "inputFormat": "The $1$-st line contains $1$ positive integer $n$, the number of enemy units.\nThe $2$-nd line contains $n$ positive integers $m_1, \\cdots, m_n$, representing the initial health of each enemy unit in order.\nThe $3$-rd line contains $1$ non-negative integer $Q$, the number of skills Zhenzhen will cast.\nThe $4$-th to the $(Q + 3)$-rd lines each describe one skill; the $(i + 3)$-rd line describes the $i$-th skill.\n\nEach line begins with an integer $op$, indicating the type of the skill.\nIf $op = 0$, it indicates the Lock skill. This is followed by $3$ positive integers $id, u, v$, meaning the target is $id$, and the hit probability is $p = \\frac{u}{v}$. (Guaranteed that $1 \\le id \\le n$, $0 < u \\le v < 998244353$.)\nIf $op = 1$, it indicates the Barrier skill. This is followed by $1$ positive integer $k$ indicating the number of targets, then an additional $k$ numbers $id_1, \\cdots, id_k$ describing all the targets of this skill. (Guaranteed that all $1 \\le id_i \\le n$ are pairwise distinct.)\nWithin each line, if there are multiple numbers, separate them with a single space.", "outputFormat": "Output $C + 1$ lines (where $C$ is the number of Barrier skills):\n\nFor the first $C$ lines, corresponding to each Barrier skill in order:\nOutput $k$ numbers. The $i$-th number is the probability that the Barrier hits enemy unit $id_i$.\n\nOn the $(C + 1)$-st line, output $n$ numbers. The $i$-th number is the expected remaining health of enemy unit $i$ after all skills have been cast.\n\nWithin each line, if there are multiple numbers, separate them with a single space.\n\nFor all numerical values, output them modulo $998244353$: that is, suppose the answer in reduced fraction form is $\\frac{a}{b}$ with $\\gcd(a, b) = 1$. Output the integer $x$ such that $b x \\equiv a \\bmod 998244353$ and $0 \\le x < 998244353$. (It can be proven that such an integer $x$ is unique.)", "hint": "Sample Explanation 1\nZhenzhen casts the following skills in order:\n\n1. Cast Lock on enemy unit $2$: deals $1$ damage with probability $1$. At this moment, enemy unit $2$ must have $1$ health remaining.\n2. Cast Barrier on enemy unit $2$: (since enemy unit $2$ is still alive,) it must hit unit $2$.\n3. Cast Lock on enemy unit $2$: deals $1$ damage with probability $1$.\n4. Cast Lock on enemy unit $3$: deals $1$ damage with probability $1$. Now the three enemy units’ health values must be $1, 0, 2$ respectively, and enemy unit $2$ must be dead.\n5. Cast Barrier on enemy unit $2$: (since enemy unit $2$ is dead,) it must hit no unit.\n6. Cast Barrier on enemy units $1, 2, 3$: the probabilities of hitting enemy units $1$ and $3$ are equal, i.e., each $\\frac{1}{2}$. Finally, the remaining health of the three enemy units must be $1, 0, 2$.\n\nSample Explanation 2\nAnalysis for each Barrier skill:\n\n1. The $1$-st Barrier (targets enemy units $1, 2$):\n- The probability that enemy unit $2$ is alive is $\\frac{1}{2}$, and enemy unit $1$ must be alive.\n- If enemy unit $2$ is alive, then the probabilities of Barrier hitting $1$ and $2$ are equal, both $\\frac{1}{2}$; if enemy unit $2$ is dead, then Barrier must hit enemy unit $1$.\n- Therefore: the probability of hitting enemy unit $1$ is $\\frac{1}{2} \\times 1 + \\frac{1}{2} \\times \\frac{1}{2} = \\frac{3}{4}$; the probability of hitting enemy unit $2$ is $\\frac{1}{2} \\times 0 + \\frac{1}{2} \\times \\frac{1}{2} = \\frac{1}{4}$.\n2. The $2$-nd Barrier (targets enemy units $1, 2, 3$):\n- The probabilities that the three enemy units are alive are $1, \\frac{1}{2}, \\frac{1}{3}$, respectively.\n- The probability that $1, 2, 3$ are all alive is $\\frac{1}{6}$; the probability that only $1, 2$ are alive is $\\frac{1}{3}$; the probability that only $1, 3$ are alive is $\\frac{1}{6}$; the probability that only $1$ is alive is $\\frac{1}{3}$.\n- Therefore: the probability of hitting enemy unit $1$ is $\\frac{1}{6} \\times \\frac{1}{3} + (\\frac{1}{3} + \\frac{1}{6}) \\times \\frac{1}{2} + \\frac{1}{3} \\times 1 = \\frac{23}{36}$; the probability of hitting enemy unit $2$ is $\\frac{1}{6} \\times \\frac{1}{3} + \\frac{1}{3} \\times \\frac{1}{2} = \\frac{2}{9}$; the probability of hitting enemy unit $3$ is $\\frac{1}{6} \\times \\frac{1}{3} + \\frac{1}{6} \\times \\frac{1}{2} = \\frac{5}{36}$. Finally, the expected remaining health of the three enemy units is $1, \\frac{1}{2}, \\frac{1}{3}$.\n\nConstraints\n\nLet $C$ be the number of Barrier skills.\n\nTest point id|n =|Q =|C =|u, v|Other constraints\n-|-|-|-|-|-\n1|5|21|6|u < v|None\n2|60|199992|500|u < v|All $p$ are equal\n3|60|23|6|u < v|All $m_i = 1$\n4|60|199994|500|u < v|None\n5|60|199995|500|u < v|None\n6|60|199996|0|u < v|None\n7|60|199997|500|u = v|None\n8|200|199998|1000|u < v|None\n9|200|199999|1000|u < v|None\n10|200|200000|1000|u < v|None\n\nFor all test points, it is guaranteed that $n \\le 200$, $Q \\le 200000$, $C \\le 1000$, $m_i \\le 100$.\n\nHint\n\nThe units digit of $Q$ can help you quickly determine the test point id.\nThe test point order may not correlate with difficulty.\n\nThanks to @和泉正宗 for providing the statement.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2018] 假面", "background": "\n针针是绿绿的好朋友。", "description": "针针喜欢玩一款叫做 DotA (**D**efense **o**f **t**he **A**lgorithm) 的游戏，在这个游戏中，针针会操纵自己的英雄与队友一起对抗另一支队伍。\n针针在 DotA 中最喜欢使用的英雄叫做假面（Faceless），该英雄有 $2$ 个技能：\n\n- 锁定：对一名指定的敌方单位使用，以 $p$ 的概率对该单位造成 $1$ 点伤害（使其减少 $1$ 点生命值）。\n- 结界：在一片区域施放结界，让该区域内的所有其他单位无法动弹。\n在游戏中，如果一个单位的生命值降至 $0$ 或 $0$ 以下，那么该单位就会死亡。\n\n针针操纵假面的水平一般，因此他决定勤加练习。现在有 $n$ 个敌方单位（编号从 $1$ 至 $n$），编号为 $i$ 的敌方单位有 $h_i$ 点生命值。\n\n针针已经安排好了练习的计划，他会按顺序施放 $Q$ 个技能：\n\n- 对于锁定技能：针针会指定一个敌方单位 $id$ ，并对它施放。由于决定概率系数 $p$ 的因素很多，因此每次的 $p$ 都不一定相同。\n特别地，如果该敌方单位已经死亡，那么该技能不会造成任何效果。\n- 对于结界技能：针针会希望对 $k$ 个指定的敌方单位施放，但由于针针并不擅长施放该技能，因此他只能命中恰好 $1$ 个敌方单位。命中每个存活的敌方单位的概率是相等的（也就是说已经死亡的敌方单位不会有任何影响）。\n特别地，如果这 $k$ 个敌方单位均已死亡，那么该技能同样不会命中任何敌方单位。\n\n现在，围观针针进行练习的绿绿想知道：\n\n1. 对于针针施放的每个结界技能，它命中各敌人的概率分别是多少。\n2. 在针针的所有技能施放完毕后，所有敌方单位剩余生命值的期望分别是多少。\n\n由于绿绿还要围观针针训练，所以请你帮他解决这两个问题。\n\n为了防止精度误差，对于所有需要输出的数值，请输出其在模 $998244353$ 意义下的值。\n\n由于结界为假面的终极技能，因此针针施放该技能的次数不会太多。具体请见”子任务“。", "inputFormat": "第 $1$ 行为 $1$ 个正整数 $n$ ，表示敌方单位的数量。  \n第 $2$ 行为 $n$ 个正整数 $m_1,\\cdots , m_n$，依次表示各敌方单位的初始生命值。  \n第 $3$ 行为 $1$ 个非负整数 $Q$ ，表示针针施放技能的数量。  \n第 $4$ 行至第 $Q + 3$ 行，每行描述一个技能，第 $i + 3$ 行描述第 $i$ 个技能。\n\n每行的开头为一个整数 $op$ ，表示该技能的种类。  \n如果 $op = 0$ ，则表示锁定技能。并在此后跟随着 $3$ 个正整数 $id , u , v$ ，表示技能施放的目标为 $id$ ，技能命中的概率为 $p = \\frac{u}{v}$ 。（保证 $1\\le id \\le n , 0 < u \\le v < 998244353$ ）  \n如果 $op = 1$ ，则表示结界技能。并在此后跟随着 $1$ 个正整数 $k$ 表示技能施放的目标数量，随后还有额外的 $k$ 个数 $id_1,\\cdots,id_k$ 描述技能施放的所有目标。（保证所有 $1 \\le id_i \\le n$ 互不相同） 对于每一行，如果行内包含多个数，则用单个空格将它们隔开。", "outputFormat": "输出包括 $C + 1$ 行（其中 $C$ 为结界技能的数量）：\n\n前 $C$ 行依次对应每个结界技能，对于每行：\n\n输出 $k$ 个数，第 $i$ 个数表示结界命中敌方单位 $id_i$ 的概率。   \n第 $C + 1$ 行输出 $n$ 个数，第 $i$ 个数表示在所有技能施放完毕后，敌方单位 $i$ 剩余生命值的期望值。  \n\n对于每一行，如果行内包含多个数，则用单个空格将它们隔开。\n\n对于所有数值，请输出它们对 $998244353$ 取模的结果：即设答案化为最简分式后的形式为 $\\frac{a}{b}$ ，其中 $a$ 和 $b$ 的互质。输出整数 $x$ 使得 $bx \\equiv a\\bmod 998244353$ 且 $0 \\le x < 998244353$ 。（可以证明这样的整数 $x$ 是唯一的）\n", "hint": "### 样例解释 1\n针针按顺序施放如下技能：\n\n1. 对敌方单位 $2$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。此时 $2$ 号敌方单位必定剩余 $1$ 点生命值。\n2. 对敌方单位 $2$ 施放技能结界：（由于 $2$ 号敌方单位尚存活，）必定命中 $2$ 号单位。\n3. 对敌方单位 $2$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。\n4. 对敌方单位 $3$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。此时三个敌方单位的生命值一定分别为 $1, 0 ,2$ ，敌方单位 $2$ 一定死亡。\n5. 对敌方单位 $2$ 施放技能结界：（由于 $2$ 号敌方单位已死亡，）必定不命中任何单位。\n6. 对敌方单位 $1, 2, 3$ 施放技能结界：命中敌方单位 $1, 3$ 的概率是相等的，即各 $\\frac{1}{2}$ 。 最终，三个敌方单位的剩余生命值一定为 $1 , 0 , 2$ 。\n\n### 样例解释 2\n对于各结界技能的分析：\n\n1. 第 $1$ 个结界（目标为敌方单位 $1,2$ ）：\n- $2$ 号敌方单位存活的概率为 $\\frac{1}{2}$ ， $1$ 号敌方单位必定存活。\n- 如果 $2$ 号敌方单位存活，那么结界命中 $1 , 2$ 的概率相等，均为 $\\frac{1}{2}$ ；如果 $2$ 号敌方单位死亡，那么结界必定命中 $1$ 号敌方单位。\n- 因此：命中 $1$ 号敌方单位的概率为 $\\frac{1}{2} \\times 1 + \\frac{1}{2} \\times \\frac{1}{2} = \\frac{3}{4}$ ；命中 $2$ 号敌方单位的概率为 $\\frac{1}{2} \\times 0 + \\frac{1}{2} \\times \\frac{1}{2} = \\frac{1}{4}$ 。\n2. 第 $2$ 个结界（目标为敌方单位 $1, 2, 3$ ）：\n- 三个敌方单位存活的概率分别为 $1, \\frac{1}{2} , \\frac{1}{3}$ 。\n- $1 , 2 , 3$ 同时存活的概率为 $\\frac{1}{6}$ ；只有 $1, 2$ 存活的概率为 $\\frac{1}{3}$ ；只有 $1 , 3$ 存活的概率为 $\\frac{1}{6}$ ；只有 $1$ 存活的概率为 $\\frac{1}{3}$ 。\n- 因此：命中 $1$ 号敌方单位的概率为 $\\frac{1}{6} \\times \\frac{1}{3} + (\\frac{1}{3}+\\frac{1}{6}) \\times \\frac{1}{2}+ \\frac{1}{3} \\times 1 = \\frac{23}{36}$ ；命中 $2$ 号敌方单位的概率为 $\\frac{1}{6} \\times \\frac{1}{3} + \\frac{1}{3} \\times \\frac{1}{2} = \\frac{2}{9}$ ；命中 $3$ 号敌方单位的概率为 $\\frac{1}{6} \\times \\frac{1}{3} + \\frac{1}{6} \\times \\frac{1}{2} = \\frac{5}{36}$ 。 最终，三个敌方单位的剩余生命值的期望值为 $1 , \\frac{1}{2} , \\frac{1}{3}$ 。\n\n\n### 数据范围\n\n我们记 $C$ 为结界技能的数量。\n\n测试点编号|n=|Q=|C=|u,v|其他限制\n-|-|-|-|-|-\n1|5|21|6|u<v|无\n2|60|199992|500|u<v|所有 p 均相等\n3|60|23|6|u<v|所有m_i =1\n4|60|199994|500|u<v|无\n5|60|199995|500|u<v|无\n6|60|199996|0|u<v|无\n7|60|199997|500|u=v|无\n8|200|199998|1000|u<v|无\n9|200|199999|1000|u<v|无\n10|200|200000|1000|u<v|无\n\n对于所有测试点，保证 $n \\le 200 , Q \\le 200000 , C \\le 1000 , m_i \\le 100$ 。\n\n提示\n\nQ 的个位可以帮助你快速确定测试点的编号。\n测试点顺序可能与难度无关。\n\n感谢 @和泉正宗 提供题面 ", "locale": "zh-CN"}}}
{"pid": "P4565", "type": "P", "difficulty": 7, "samples": [["6\n1 2 2\n1 3 0\n2 4 1\n2 5 -7\n3 6 0\n1 2 -1\n2 3 -1\n2 5 3\n2 6 -2\n3 4 8", "5\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "线段树", "O2优化", "分治", "最近公共祖先 LCA", "CTSC/CTS"], "title": "[CTSC2018] 暴力写挂", "background": "", "description": "temporaryDO 是一个很菜的 OIer。在 4 月，他在省队选拔赛的考场上见到了《林克卡特树》一题，其中 $k = 0$ 的部分分是求树 $T$ 上的最长链。可怜的 temporaryDO 并不会做这道题，他在考场上抓猫耳挠猫腮都想不出一点思路。\n\n这时，善良的板板出现在了空中，他的身上发出璀璨却柔和的光芒，荡漾在考场上。“题目并不难。” 板板说。那充满磁性的声音，让 temporaryDO 全身充满了力量。\n\n他决定：写一个枚举点对求 LCA 算距离的 $k = 0$ 的 $O(n^2 \\log n)$ 的部分分程序！于是， temporaryDO 选择以 $1$ 为根，建立了求 LCA 的树链剖分结构，然后写了二重 for 循环枚举点对。\n\n然而，菜菜的 temporaryDO 不小心开小了数组，于是数组越界到了一片神秘的内存区域。但恰好的是，那片内存区域存储的区域恰好是另一棵树 $T'$ 。这样一来，程序并没有 RE ，但他求 $x$ 和 $y$ 的距离的时候，计算的是 \n\n$$ \\mathrm{depth}(x) + \\mathrm{depth}(y) -  ({\\mathrm{depth}(\\mathrm{LCA}(x,y))}+{\\mathrm{depth'}(\\mathrm{LCA'}(x,y))})$$\n\n\n\n最后程序会输出每一对点对 $i, j$（$i \\le j$） 的如上定义的“距离” 的最大值。\ntemporaryDO 的程序在评测时光荣地爆零了。但他并不服气，他决定花好几天把自己的程序跑出来。请你根据 $T$ 和 $T'$ 帮帮可怜的 temporaryDO 求出他程序的输出。", "inputFormat": "第一行包含一个整数 $n$ ，表示树上的节点个数。\n\n第 $2$ 到第 $n$ 行，每行三个整数 $x , y , v$ ，表示 $T$ 中存在一条从 $x$ 到 $y$ 的边，其长度为 $v$。\n\n第 $n + 1$ 到第 $2n-1$ 行 ，每行三个整数 $x , y , v$ ，表示 $T'$ 中存在一条从 $x$ 到 $y$ 的边，其长度为 $v$。", "outputFormat": "输出一行一个整数，表示 temporaryDO 的程序的输出。\n", "hint": "### 样例解释 1\n点对 $(3, 4)$ 的距离计算为 $3 + 0 - (0 + (-2)) = 5$ 。\n\n### 数据范围\n对于所有数据， $1\\le n \\le 366666$，$|v| \\le 2017011328$ 。 详细数据范围见下表，表格中的“无” 表示无特殊限制。\n\n测试点编号|$n \\le$|$v$|$T$ 是一条链|$T'$ 是一条链\n-|-|-|-|-\n$1$|$36$|$=1$|否|否\n$2$|$366$|$=1$|否|否\n$3$|$1388$|$>0$|否|否\n$4$|$1999$|$>0$|否|否\n$5$|$2666$|$>0$|否|否\n$6$|$5666$|无|否|否\n$7$|$8666$|无|否|否\n$8$|$11111$|无|否|否\n$9$|$12345$|无|否|否\n$10$|$366666$|$>0$|是|是\n$11$|$366666$|无|是|是\n$12\\sim 13$|$366666$|$>0$|是|否\n$14$|$366666$|无|是|否\n$15\\sim 16$|$366666$|$>0$|否|是\n$17$|$366666$|无|否|是\n$18\\sim 20$|$366666$|无|否|否\n\n$\\mathrm{depth}(p)$ 和 $\\mathrm{depth'}(p)$ 分别表示树 $T$，$T'$ 中点 $1$ 到点 $p$ 的距离，这里规定，距离指的是经过的边的边权总和，其中 $\\mathrm{depth}(1) = 0$。\n\n$\\mathrm{LCA}(x, y)$ 和 $\\mathrm{LCA'}(x, y)$ 分别表示树 $T$，$T'$ 中点 $x$ 与点 $y$ 的最近公共祖先，即在从 $x$ 到 $y$ 的最短路径上的距离根**经过边数最少**的点。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2018] Bugged Brute Force", "background": "", "description": "temporaryDO is a very weak OIer. In April, during the provincial team qualifier, he saw the problem “Link-Cut Tree.” The partial score for $k = 0$ asks for the longest path on tree $T$. Poor temporaryDO didn’t know how to solve it; even after scratching his head, he couldn’t come up with any idea.\n\nAt that moment, the kind Banban appeared in the air, radiating a brilliant yet gentle light that rippled across the exam hall. “The problem isn’t hard,” Banban said. That magnetic voice filled temporaryDO with strength.\n\nHe decided to write an $O(n^2 \\log n)$ partial-solution program for $k = 0$ that enumerates pairs and uses LCA to compute distances. So temporaryDO chose $1$ as the root, built a heavy-light decomposition structure for LCA, and then wrote a double for loop to enumerate pairs.\n\nHowever, clumsy temporaryDO accidentally allocated an array too small, causing an out-of-bounds access into a mysterious memory region. Coincidentally, that region happened to store another tree $T'$. As a result, the program did not RE, but when computing the distance between $x$ and $y$, it calculated\n\n$$ \\mathrm{depth}(x) + \\mathrm{depth}(y) -  ({\\mathrm{depth}(\\mathrm{LCA}(x,y))}+{\\mathrm{depth'}(\\mathrm{LCA'}(x,y))})$$\n\nFinally, the program outputs the maximum of the above-defined “distance” over all pairs $i, j$ with $i \\le j$. temporaryDO’s program gloriously scored zero during evaluation. Unconvinced, he decided to spend several days reproducing his program’s output. Given $T$ and $T'$, please help the poor temporaryDO compute what his program outputs.", "inputFormat": "The first line contains an integer $n$, the number of nodes in the tree.\n\nLines $2$ to $n$ each contain three integers $x, y, v$, indicating that in $T$ there is an edge between $x$ and $y$ with length $v$.\n\nLines $n + 1$ to $2n - 1$ each contain three integers $x, y, v$, indicating that in $T'$ there is an edge between $x$ and $y$ with length $v$.", "outputFormat": "Output a single integer on one line: the output of temporaryDO’s program.", "hint": "Sample explanation 1  \nFor the pair $(3, 4)$, the distance is computed as $3 + 0 - (0 + (-2)) = 5$.\n\nConstraints  \nFor all testdata, $1 \\le n \\le 366666$, $|v| \\le 2017011328$. Detailed constraints are shown in the table below; in the table, “无” means no special restriction.\n\n测试点编号|$n \\le$|$v$|$T$ is a path|$T'$ is a path\n-|-|-|-|-\n$1$|$36$|$=1$|No|No\n$2$|$366$|$=1$|No|No\n$3$|$1388$|$>0$|No|No\n$4$|$1999$|$>0$|No|No\n$5$|$2666$|$>0$|No|No\n$6$|$5666$|none|No|No\n$7$|$8666$|none|No|No\n$8$|$11111$|none|No|No\n$9$|$12345$|none|No|No\n$10$|$366666$|$>0$|Yes|Yes\n$11$|$366666$|none|Yes|Yes\n$12\\sim 13$|$366666$|$>0$|Yes|No\n$14$|$366666$|none|Yes|No\n$15\\sim 16$|$366666$|$>0$|No|Yes\n$17$|$366666$|none|No|Yes\n$18\\sim 20$|$366666$|none|No|No\n\n$\\mathrm{depth}(p)$ and $\\mathrm{depth'}(p)$ denote the distances from node $1$ to node $p$ in trees $T$ and $T'$ respectively. Here, distance means the sum of edge weights along the path, and $\\mathrm{depth}(1) = 0$.\n\n$\\mathrm{LCA}(x, y)$ and $\\mathrm{LCA'}(x, y)$ denote, in $T$ and $T'$ respectively, the lowest common ancestor of nodes $x$ and $y$, i.e., the point on the shortest path from $x$ to $y$ that has the fewest edges from the root.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2018] 暴力写挂", "background": "", "description": "temporaryDO 是一个很菜的 OIer。在 4 月，他在省队选拔赛的考场上见到了《林克卡特树》一题，其中 $k = 0$ 的部分分是求树 $T$ 上的最长链。可怜的 temporaryDO 并不会做这道题，他在考场上抓猫耳挠猫腮都想不出一点思路。\n\n这时，善良的板板出现在了空中，他的身上发出璀璨却柔和的光芒，荡漾在考场上。“题目并不难。” 板板说。那充满磁性的声音，让 temporaryDO 全身充满了力量。\n\n他决定：写一个枚举点对求 LCA 算距离的 $k = 0$ 的 $O(n^2 \\log n)$ 的部分分程序！于是， temporaryDO 选择以 $1$ 为根，建立了求 LCA 的树链剖分结构，然后写了二重 for 循环枚举点对。\n\n然而，菜菜的 temporaryDO 不小心开小了数组，于是数组越界到了一片神秘的内存区域。但恰好的是，那片内存区域存储的区域恰好是另一棵树 $T'$ 。这样一来，程序并没有 RE ，但他求 $x$ 和 $y$ 的距离的时候，计算的是 \n\n$$ \\mathrm{depth}(x) + \\mathrm{depth}(y) -  ({\\mathrm{depth}(\\mathrm{LCA}(x,y))}+{\\mathrm{depth'}(\\mathrm{LCA'}(x,y))})$$\n\n\n\n最后程序会输出每一对点对 $i, j$（$i \\le j$） 的如上定义的“距离” 的最大值。\ntemporaryDO 的程序在评测时光荣地爆零了。但他并不服气，他决定花好几天把自己的程序跑出来。请你根据 $T$ 和 $T'$ 帮帮可怜的 temporaryDO 求出他程序的输出。", "inputFormat": "第一行包含一个整数 $n$ ，表示树上的节点个数。\n\n第 $2$ 到第 $n$ 行，每行三个整数 $x , y , v$ ，表示 $T$ 中存在一条从 $x$ 到 $y$ 的边，其长度为 $v$。\n\n第 $n + 1$ 到第 $2n-1$ 行 ，每行三个整数 $x , y , v$ ，表示 $T'$ 中存在一条从 $x$ 到 $y$ 的边，其长度为 $v$。", "outputFormat": "输出一行一个整数，表示 temporaryDO 的程序的输出。\n", "hint": "### 样例解释 1\n点对 $(3, 4)$ 的距离计算为 $3 + 0 - (0 + (-2)) = 5$ 。\n\n### 数据范围\n对于所有数据， $1\\le n \\le 366666$，$|v| \\le 2017011328$ 。 详细数据范围见下表，表格中的“无” 表示无特殊限制。\n\n测试点编号|$n \\le$|$v$|$T$ 是一条链|$T'$ 是一条链\n-|-|-|-|-\n$1$|$36$|$=1$|否|否\n$2$|$366$|$=1$|否|否\n$3$|$1388$|$>0$|否|否\n$4$|$1999$|$>0$|否|否\n$5$|$2666$|$>0$|否|否\n$6$|$5666$|无|否|否\n$7$|$8666$|无|否|否\n$8$|$11111$|无|否|否\n$9$|$12345$|无|否|否\n$10$|$366666$|$>0$|是|是\n$11$|$366666$|无|是|是\n$12\\sim 13$|$366666$|$>0$|是|否\n$14$|$366666$|无|是|否\n$15\\sim 16$|$366666$|$>0$|否|是\n$17$|$366666$|无|否|是\n$18\\sim 20$|$366666$|无|否|否\n\n$\\mathrm{depth}(p)$ 和 $\\mathrm{depth'}(p)$ 分别表示树 $T$，$T'$ 中点 $1$ 到点 $p$ 的距离，这里规定，距离指的是经过的边的边权总和，其中 $\\mathrm{depth}(1) = 0$。\n\n$\\mathrm{LCA}(x, y)$ 和 $\\mathrm{LCA'}(x, y)$ 分别表示树 $T$，$T'$ 中点 $x$ 与点 $y$ 的最近公共祖先，即在从 $x$ 到 $y$ 的最短路径上的距离根**经过边数最少**的点。", "locale": "zh-CN"}}}
{"pid": "P4566", "type": "P", "difficulty": 7, "samples": [["1 3\n1 1 3", "2\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "2018", "O2优化", "分治", "排列组合", "快速傅里叶变换 FFT", "CTSC/CTS"], "title": "[CTSC2018] 青蕈领主", "background": "“也许，我的生命也已经如同风中残烛了吧。”小绿如是说。", "description": "小绿同学因为微积分这门课，对“连续”这一概念产生了浓厚的兴趣。小绿打算把连续的概念放到由整数构成的序列上，他定义一个长度为 $m$ 的整数序列是连续的，当且仅当这个序列中的最大值与最小值的差，不超过$m-1$。例如 $\\{1,3,2\\}$ 是连续的，而 $\\{1,3\\}$ 不是连续的。\n\n某天，小绿的顶头上司板老大，给了小绿 $T$ 个长度为 $n$ 的排列。小绿拿到之后十分欢喜，他求出了每个排列的每个区间是否是他所定义的“连续”的。然而，小绿觉得被别的“连续”区间包含住的“连续”区间不够优秀，于是对于每个排列的所有右端点相同的“连续”区间，他只记录下了长度最长的那个“连续”区间的长度。也就是说，对于板老大给他的每一个排列，他都只记录下了在这个排列中，对于每一个 $1 \\le i \\le n$，右端点为 $i$ 的最长“连续”区间的长度 $L_i$。显然这个长度最少为 $1$，因为所有长度为 $1$ 的整数序列都是连续的。\n\n做完这一切后，小绿爬上绿色床，美美地做了一个绿色的梦。\n\n可是第二天醒来之后，小绿惊讶的发现板老大给他的所有排列都不见了，只剩下他记录下来的 $T$ 组信息。小绿知道自己在劫难逃，但是作为一个好奇的青年，他还是想知道：对于每一组信息，有多少个和信息符合的长度为 $n$ 的排列。\n\n由于小绿已经放弃治疗了，你只需要告诉他每一个答案对 $998244353$ 取模的结果。\n\n我们并不保证一定存在至少一个符合信息的排列，因为小绿也是人，他也有可能犯错。", "inputFormat": "输入的第一行包含两个整数 $T,n$，分别表示板老大给小绿的排列个数、以及每个排列的长度。\n\n接下来 $T$ 行，每行描述一组信息，包含 $n$ 个正整数，第 $i$ 组信息的从左往右第 $j$ 个整数 $L_{i,j}$ 表示第 $i$ 个排列中右端点为第 $j$ 个数的最长“连续”区间的长度。\n\n对于每一行，如果行内包含多个数，则用单个空格将它们隔开。", "outputFormat": "对于每组信息，输出一行一个整数表示可能的排列个数对 $998244353$ 取模的结果。由于是计算机帮你算，所以我们不给你犯错的机会。\n", "hint": "### 数据规模\n\n测试点编号|$n\\le$|$T\\le$|特殊性质\n-|-|-|-\n1~2|10|1|无\n3~4|10|100|无\n5|300|1|$L_{i,j}=j$\n6|300|1|$L_{i,j}=1$ 且 $j<n$\n7~8|300|100|无\n9|1000|1|$L_{i,j}=1$ 且 $j<n$\n10~12|1000|100|无\n13~16|5000|100|无\n17~20|50000|100|无\n\n对于所有测试数据，$1 \\le T \\le 100,1 \\le N \\le 50000,1 \\le L_{i,j} \\le j$。  \n本题部分测试点的输入规模较大，请注意读入效率。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2018] Qingxun Lord", "background": "\"Maybe my life is already like a candle flickering in the wind.\" said Xiao Lü.", "description": "Because of a calculus course, Xiao Lü has become very interested in the concept of \"continuity\". He plans to bring the concept of continuity to sequences of integers. He defines an integer sequence of length $m$ to be continuous if and only if the difference between the maximum and minimum elements in the sequence does not exceed $m-1$. For example, $\\{1,3,2\\}$ is continuous, while $\\{1,3\\}$ is not.\n\nOne day, Xiao Lü’s direct supervisor, Boss Ban, gave him $T$ permutations of length $n$. Delighted, Xiao Lü determined, for each permutation, whether each interval is \"continuous\" as he defined. However, he felt that \"continuous\" intervals contained within other \"continuous\" intervals were not good enough. Therefore, for all \"continuous\" intervals in each permutation with the same right endpoint, he recorded only the length of the longest such \"continuous\" interval. In other words, for each permutation given by Boss Ban, he recorded for each $1 \\le i \\le n$ the length $L_i$ of the longest \"continuous\" interval whose right endpoint is $i$. Clearly, this length is at least $1$, because all integer sequences of length $1$ are continuous.\n\nAfter finishing all this, Xiao Lü climbed onto his green bed and had a lovely green dream.\n\nBut when he woke up the next day, he was shocked to find that all the permutations Boss Ban had given him were gone, leaving only the $T$ recorded sets of information. Knowing he was doomed, yet being a curious young man, he still wanted to know: for each set of information, how many length-$n$ permutations are consistent with it?\n\nSince Xiao Lü has already given up on treatment, you only need to tell him each answer modulo $998244353$.\n\nWe do not guarantee that there exists at least one permutation consistent with the information, because Xiao Lü is human and can make mistakes.", "inputFormat": "The first line contains two integers $T, n$, representing the number of permutations Boss Ban gave and the length of each permutation.\n\nThe next $T$ lines each describe one set of information and contain $n$ positive integers. In the $i$-th set, the $j$-th integer from left to right $L_{i,j}$ denotes, in the $i$-th permutation, the length of the longest \"continuous\" interval whose right endpoint is the $j$-th position.\n\nWithin each line, if there are multiple numbers, they are separated by a single space.", "outputFormat": "For each set of information, output a single integer on its own line representing the number of possible permutations modulo $998244353$. Since the computer is doing the calculation, we will not give you a chance to make a mistake.", "hint": "### Constraints\n\n测试点编号|$n\\le$|$T\\le$|特殊性质\n-|-|-|-\n1~2|10|1|None\n3~4|10|100|None\n5|300|1|$L_{i,j}=j$\n6|300|1|$L_{i,j}=1$ 且 $j<n$\n7~8|300|100|None\n9|1000|1|$L_{i,j}=1$ 且 $j<n$\n10~12|1000|100|None\n13~16|5000|100|None\n17~20|50000|100|None\n\nFor all testdata, $1 \\le T \\le 100, 1 \\le n \\le 50000, 1 \\le L_{i,j} \\le j$.  \nSome test points have large input size; please be mindful of input speed.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2018] 青蕈领主", "background": "“也许，我的生命也已经如同风中残烛了吧。”小绿如是说。", "description": "小绿同学因为微积分这门课，对“连续”这一概念产生了浓厚的兴趣。小绿打算把连续的概念放到由整数构成的序列上，他定义一个长度为 $m$ 的整数序列是连续的，当且仅当这个序列中的最大值与最小值的差，不超过$m-1$。例如 $\\{1,3,2\\}$ 是连续的，而 $\\{1,3\\}$ 不是连续的。\n\n某天，小绿的顶头上司板老大，给了小绿 $T$ 个长度为 $n$ 的排列。小绿拿到之后十分欢喜，他求出了每个排列的每个区间是否是他所定义的“连续”的。然而，小绿觉得被别的“连续”区间包含住的“连续”区间不够优秀，于是对于每个排列的所有右端点相同的“连续”区间，他只记录下了长度最长的那个“连续”区间的长度。也就是说，对于板老大给他的每一个排列，他都只记录下了在这个排列中，对于每一个 $1 \\le i \\le n$，右端点为 $i$ 的最长“连续”区间的长度 $L_i$。显然这个长度最少为 $1$，因为所有长度为 $1$ 的整数序列都是连续的。\n\n做完这一切后，小绿爬上绿色床，美美地做了一个绿色的梦。\n\n可是第二天醒来之后，小绿惊讶的发现板老大给他的所有排列都不见了，只剩下他记录下来的 $T$ 组信息。小绿知道自己在劫难逃，但是作为一个好奇的青年，他还是想知道：对于每一组信息，有多少个和信息符合的长度为 $n$ 的排列。\n\n由于小绿已经放弃治疗了，你只需要告诉他每一个答案对 $998244353$ 取模的结果。\n\n我们并不保证一定存在至少一个符合信息的排列，因为小绿也是人，他也有可能犯错。", "inputFormat": "输入的第一行包含两个整数 $T,n$，分别表示板老大给小绿的排列个数、以及每个排列的长度。\n\n接下来 $T$ 行，每行描述一组信息，包含 $n$ 个正整数，第 $i$ 组信息的从左往右第 $j$ 个整数 $L_{i,j}$ 表示第 $i$ 个排列中右端点为第 $j$ 个数的最长“连续”区间的长度。\n\n对于每一行，如果行内包含多个数，则用单个空格将它们隔开。", "outputFormat": "对于每组信息，输出一行一个整数表示可能的排列个数对 $998244353$ 取模的结果。由于是计算机帮你算，所以我们不给你犯错的机会。\n", "hint": "### 数据规模\n\n测试点编号|$n\\le$|$T\\le$|特殊性质\n-|-|-|-\n1~2|10|1|无\n3~4|10|100|无\n5|300|1|$L_{i,j}=j$\n6|300|1|$L_{i,j}=1$ 且 $j<n$\n7~8|300|100|无\n9|1000|1|$L_{i,j}=1$ 且 $j<n$\n10~12|1000|100|无\n13~16|5000|100|无\n17~20|50000|100|无\n\n对于所有测试数据，$1 \\le T \\le 100,1 \\le N \\le 50000,1 \\le L_{i,j} \\le j$。  \n本题部分测试点的输入规模较大，请注意读入效率。", "locale": "zh-CN"}}}
{"pid": "P4567", "type": "P", "difficulty": 6, "samples": [["10\nInsert 13\nBalanced eert\nMove 2\nDelete 5\nNext\nInsert 7\n editor\nMove 0\nGet\nMove 11\nRotate 4\nGet", "B\nt"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "各省省选", "平衡树", "安徽"], "title": "[AHOI2006] 文本编辑器", "background": null, "description": "这些日子，可可不和卡卡一起玩了，原来可可正废寝忘食的想做一个简单而高效的文本编辑器。你能帮助他吗？为了明确任务目标，可可对“文本编辑器”做了一个抽象的定义： \n\n- `Move k`：将光标移动到第 $k$ 个字符之后，如果 $k=0$，将光标移到文本第一个字符之前。\n- `Insert n (换行) S`：在光标后插入长度为 $n$ 的字符串 $S$，光标位置不变，$n \\ge 1$。\n- `Delete n`：删除光标后的 $n$ 个字符，光标位置不变，$n \\ge 1$。\n- `Rotate n`：反转光标后的 $n$ 个字符，光标位置不变，$n \\ge 1$。\n- `Get`：输出光标后的一个字符，光标位置不变。\n- `Prev`：光标前移一个字符。\n- `Next`：光标后移一个字符。\n\n\n下面是几个定义：\n\n- 文本：由 $0$ 个或多个字符构成的序列。这些字符的 ASCII 码在闭区间 $[32, 126]$ 内或**为换行符**，也就是说，这些字符均为可见字符或空格**或换行符**。\n- 光标：在一段文本中用于指示位置的标记，可以位于文本的第一个字符之前，文本的最后一个字符之后或文本的某两个相邻字符之间。\n- 文本编辑器：为一个可以对一段文本和该文本中的一个光标进行如下七条操作的程序。如果这段文本为空，我们就说这个文本编辑器是空的。 \n\n编写一个程序：\n1. 建立一个空的文本编辑器。\n2. 从输入文件中读入一些操作指令并执行。\n3. 对所有执行过的 `Get` 操作，将指定的内容写入输出文件。", "inputFormat": "输入文件中第一行是指令条数 $N$，以下是需要执行的 $N$ 个操作。除了回车符之外，输入文件的所有字符的 ASCII 码都在闭区间 $[32, 126]$ 内。且行尾没有空格。", "outputFormat": "依次对应输入文件中每条 `Get` 指令的输出，不得有任何多余的字符。**注意：如果 `Get` 指令的输出是换行符，则无需额外换行。**", "hint": "对输入数据我们有如下假定：\n1. `MOVE` 操作不超过 $5\\times 10^4$ 个，`INSERT`, `DELETE` 和 `ROTATE` 操作作的总个数不超过 $6\\times 10^3$，`GET` 操作不超过 $2\\times 10^4$ 个，`PREV` 和 `NEXT` 操作的总个数不超过 $2\\times 10^4$。\n2.  所有 `INSERT` 插入的字符数之和不超过 $2M$（$1M=2^{20}$)。\n3. `DELETE` 操作、`ROTATE` 操作和 `GET` 操作执行时光标后必然有足够的字符。`MOVE`、`PREV`、`NEXT` 操作不会把光标移动到非法位置。\n4. 输入文件没有错误。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2006] Text Editor", "background": "", "description": "These days, Keke is not playing with Kaka, because Keke is obsessed with making a simple and efficient text editor. Can you help him? To clarify the goal, Keke gives an abstract definition of a \"text editor\":\n\n- `Move k`: Move the cursor to the position after the $k$-th character. If $k = 0$, move the cursor to the position before the first character of the text.\n- `Insert n (newline) S`: Insert a string $S$ of length $n$ after the cursor, without moving the cursor. Here $n \\ge 1$.\n- `Delete n`: Delete the $n$ characters after the cursor, without moving the cursor. Here $n \\ge 1$.\n- `Rotate n`: Reverse the $n$ characters after the cursor, without moving the cursor. Here $n \\ge 1$.\n- `Get`: Output the one character after the cursor, without moving the cursor.\n- `Prev`: Move the cursor one character to the left.\n- `Next`: Move the cursor one character to the right.\n\nDefinitions:\n\n- Text: A sequence of $0$ or more characters. Each character’s ASCII code is in the closed interval $[32, 126]$ or is a newline character. That is, characters are all visible characters or spaces, or newlines.\n- Cursor: A marker indicating a position in a text. It can be before the first character, after the last character, or between two adjacent characters.\n- Text editor: A program that performs the above seven operations on a piece of text and a cursor within it. If the text is empty, we say the text editor is empty.\n\nWrite a program to:\n1. Create an empty text editor.\n2. Read a sequence of operation commands from the input file and execute them.\n3. For every executed `Get` operation, write the specified content to the output file.", "inputFormat": "The first line of the input file contains the number of commands $N$. The following lines contain the $N$ operations to execute. Except for newline characters, all characters in the input file have ASCII codes in the closed interval $[32, 126]$. There are no trailing spaces at the end of lines.", "outputFormat": "Output the results corresponding to each `Get` command in the input file, in order, with no extra characters. Note: If the output of a `Get` command is a newline character, no additional newline is needed.", "hint": "For the input, we make the following assumptions:\n1. The number of `MOVE` operations does not exceed $5 \\times 10^4$, the total number of `INSERT`, `DELETE`, and `ROTATE` operations does not exceed $6 \\times 10^3$, the number of `GET` operations does not exceed $2 \\times 10^4$, and the total number of `PREV` and `NEXT` operations does not exceed $2 \\times 10^4$.\n2. The total number of characters inserted by all `INSERT` operations does not exceed $2M$ (where $1M = 2^{20}$).\n3. When executing `DELETE`, `ROTATE`, and `GET`, there are always enough characters after the cursor. `MOVE`, `PREV`, and `NEXT` will not move the cursor to an invalid position.\n4. The input file has no errors.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2006] 文本编辑器", "background": null, "description": "这些日子，可可不和卡卡一起玩了，原来可可正废寝忘食的想做一个简单而高效的文本编辑器。你能帮助他吗？为了明确任务目标，可可对“文本编辑器”做了一个抽象的定义： \n\n- `Move k`：将光标移动到第 $k$ 个字符之后，如果 $k=0$，将光标移到文本第一个字符之前。\n- `Insert n (换行) S`：在光标后插入长度为 $n$ 的字符串 $S$，光标位置不变，$n \\ge 1$。\n- `Delete n`：删除光标后的 $n$ 个字符，光标位置不变，$n \\ge 1$。\n- `Rotate n`：反转光标后的 $n$ 个字符，光标位置不变，$n \\ge 1$。\n- `Get`：输出光标后的一个字符，光标位置不变。\n- `Prev`：光标前移一个字符。\n- `Next`：光标后移一个字符。\n\n\n下面是几个定义：\n\n- 文本：由 $0$ 个或多个字符构成的序列。这些字符的 ASCII 码在闭区间 $[32, 126]$ 内或**为换行符**，也就是说，这些字符均为可见字符或空格**或换行符**。\n- 光标：在一段文本中用于指示位置的标记，可以位于文本的第一个字符之前，文本的最后一个字符之后或文本的某两个相邻字符之间。\n- 文本编辑器：为一个可以对一段文本和该文本中的一个光标进行如下七条操作的程序。如果这段文本为空，我们就说这个文本编辑器是空的。 \n\n编写一个程序：\n1. 建立一个空的文本编辑器。\n2. 从输入文件中读入一些操作指令并执行。\n3. 对所有执行过的 `Get` 操作，将指定的内容写入输出文件。", "inputFormat": "输入文件中第一行是指令条数 $N$，以下是需要执行的 $N$ 个操作。除了回车符之外，输入文件的所有字符的 ASCII 码都在闭区间 $[32, 126]$ 内。且行尾没有空格。", "outputFormat": "依次对应输入文件中每条 `Get` 指令的输出，不得有任何多余的字符。**注意：如果 `Get` 指令的输出是换行符，则无需额外换行。**", "hint": "对输入数据我们有如下假定：\n1. `MOVE` 操作不超过 $5\\times 10^4$ 个，`INSERT`, `DELETE` 和 `ROTATE` 操作作的总个数不超过 $6\\times 10^3$，`GET` 操作不超过 $2\\times 10^4$ 个，`PREV` 和 `NEXT` 操作的总个数不超过 $2\\times 10^4$。\n2.  所有 `INSERT` 插入的字符数之和不超过 $2M$（$1M=2^{20}$)。\n3. `DELETE` 操作、`ROTATE` 操作和 `GET` 操作执行时光标后必然有足够的字符。`MOVE`、`PREV`、`NEXT` 操作不会把光标移动到非法位置。\n4. 输入文件没有错误。", "locale": "zh-CN"}}}
{"pid": "P4568", "type": "P", "difficulty": 4, "samples": [["5 6 1\n0 4\n0 1 5\n1 2 5\n2 3 5\n3 4 5\n2 3 3\n0 2 100", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "吉林", "最短路"], "title": "[JLOI2011] 飞行路线", "background": "", "description": "Alice 和 Bob 现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在 $n$ 个城市设有业务，设这些城市分别标记为 $0$ 到 $n-1$，一共有 $m$ 种航线，每种航线连接两个城市，并且航线有一定的价格。\n\nAlice 和 Bob 现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多 $k$ 种航线上搭乘飞机。那么 Alice 和 Bob 这次出行最少花费多少？", "inputFormat": "第一行三个整数 $n,m,k$，分别表示城市数，航线数和免费乘坐次数。\n\n接下来一行两个整数 $s,t$，分别表示他们出行的起点城市编号和终点城市编号。\n\n接下来 $m$ 行，每行三个整数 $a,b,c$，表示存在一种航线，能从城市 $a$ 到达城市 $b$，或从城市 $b$ 到达城市 $a$，价格为 $c$。", "outputFormat": "输出一行一个整数，为最少花费。", "hint": "#### 数据规模与约定\n\n对于 $30\\%$ 的数据，$2 \\le n \\le 50$，$1 \\le m \\le 300$，$k=0$。\n\n对于 $50\\%$ 的数据，$2 \\le n \\le 600$，$1 \\le m \\le 6\\times10^3$，$0 \\le k \\le 1$。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 10^4$，$1 \\le m \\le 5\\times 10^4$，$0 \\le k \\le 10$，$0\\le s,t,a,b < n$，$a\\ne b$，$0\\le c\\le 10^3$。\n\n另外存在一组 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2011] Flight Routes", "background": "", "description": "Alice and Bob are going to travel by plane, and they chose a relatively cheap airline. This airline operates in $n$ cities, labeled $0$ to $n-1$, and there are $m$ routes. Each route connects two cities and has a certain price.\n\nAlice and Bob need to travel from one city to another along these routes, and they may transfer. The airline offers a discount for this trip: they can take flights on at most $k$ routes for free. What is the minimum total cost for their trip?", "inputFormat": "The first line contains three integers $n, m, k$, representing the number of cities, the number of routes, and the maximum number of free rides, respectively.\n\nThe next line contains two integers $s, t$, representing the starting city and the destination city.\n\nThe next $m$ lines each contain three integers $a, b, c$, indicating that there is a bidirectional route between cities $a$ and $b$ with price $c$.", "outputFormat": "Output a single integer on one line, which is the minimum total cost.", "hint": "#### Constraints\n\nFor $30\\%$ of the testdata, $2 \\le n \\le 50$, $1 \\le m \\le 300$, $k=0$.\n\nFor $50\\%$ of the testdata, $2 \\le n \\le 600$, $1 \\le m \\le 6\\times10^3$, $0 \\le k \\le 1$.\n\nFor $100\\%$ of the testdata, $2 \\le n \\le 10^4$, $1 \\le m \\le 5\\times 10^4$, $0 \\le k \\le 10$, $0 \\le s,t,a,b < n$, $a \\ne b$, $0 \\le c \\le 10^3$.\n\nThere is also a set of hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2011] 飞行路线", "background": "", "description": "Alice 和 Bob 现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在 $n$ 个城市设有业务，设这些城市分别标记为 $0$ 到 $n-1$，一共有 $m$ 种航线，每种航线连接两个城市，并且航线有一定的价格。\n\nAlice 和 Bob 现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多 $k$ 种航线上搭乘飞机。那么 Alice 和 Bob 这次出行最少花费多少？", "inputFormat": "第一行三个整数 $n,m,k$，分别表示城市数，航线数和免费乘坐次数。\n\n接下来一行两个整数 $s,t$，分别表示他们出行的起点城市编号和终点城市编号。\n\n接下来 $m$ 行，每行三个整数 $a,b,c$，表示存在一种航线，能从城市 $a$ 到达城市 $b$，或从城市 $b$ 到达城市 $a$，价格为 $c$。", "outputFormat": "输出一行一个整数，为最少花费。", "hint": "#### 数据规模与约定\n\n对于 $30\\%$ 的数据，$2 \\le n \\le 50$，$1 \\le m \\le 300$，$k=0$。\n\n对于 $50\\%$ 的数据，$2 \\le n \\le 600$，$1 \\le m \\le 6\\times10^3$，$0 \\le k \\le 1$。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 10^4$，$1 \\le m \\le 5\\times 10^4$，$0 \\le k \\le 10$，$0\\le s,t,a,b < n$，$a\\ne b$，$0\\le c\\le 10^3$。\n\n另外存在一组 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P4569", "type": "P", "difficulty": 6, "samples": [["2 4 2\naa\nabb", "0.75\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "2011", "北京", "Special Judge", "矩阵乘法", "AC 自动机"], "title": "[BJWC2011] 禁忌", "background": "", "description": "Magic Land上的人们总是提起那个传说：他们的祖先John在那个东方岛屿帮助Koishi与其姐姐Satori最终战平。而后，Koishi恢复了读心的能力……\n\n如今，在John已经成为传说的时代，再次造访那座岛屿的人们却发现Koishi遇到了新麻烦。\n\n这次她遇到了Flandre Scarlet——她拥有可以使用禁忌魔法而不会受到伤害的能力。\n\n为了说明什么是禁忌魔法及其伤害，引入以下概念：\n\n1. 字母集$A$上的每个非空字符串对应了一个魔法。其中$A$是包含了前alphabet个小写字母的集合。\n2. 有一个集合$T$，包含了$N$个字母集$A$上的字符串。$T$中的每一串称为一个禁忌串（Taboo string）\n3. 一个魔法，或等价地，其对应的串$s$因为包含禁忌而对使用者造成的伤害按以下方式确定：把$s$分割成若干段，考虑其中是禁忌串的段的数目，不同的分割可能会有不同的数目，其最大值就是这个伤害。\n\n由于拥有了读心的能力，Koishi总是随机地使用Flandre Scarlet的魔法，可以确定的是，她的魔法正好对应字母集$A$上所有长度为$len$的串。\n\n但是，Flandre Scarlet所使用的一些魔法是带有禁忌的，由于其自身特性，她可以使用禁忌魔法而不受到伤害，而Koishi就不同了。可怜的Koishi每一次使用对方的魔法都面临着受到禁忌伤害的威胁。\n\n你现在需要计算的是如果Koishi使用对方的每一个魔法的概率是均等的，那么每一次随机使用魔法所受到的禁忌伤害的期望值是多少。", "inputFormat": "第一行包含三个正整数 $N$、$len$、$alphabet$。  \n接下来$N$行，每行包含一个串$T_i$，表示禁忌串。", "outputFormat": "一个非负实数，表示所受到禁忌伤害的期望值。你的答案需要保证绝对误差不超过 $10^{-6}$。", "hint": "【样例1解释】\n一共有$2^4 = 16$种不同的魔法。\n\n需要注意的是“aabb”的禁忌伤害是1而不是2。\n\n### 数据范围\n\n有不少于40%的数据中：$N = 1$。  \n100%的数据中$N ≤ 5$，$len ≤10^9$，$1 ≤ alphabet ≤ 26$。  \n数据保证每个串$T_i$的长度不超过$15$，并且不是空串。  \n数据保证每个$T_i$均仅含有前$alphabet$个小写字母。  \n数据保证集合$T$中没有相同的元素，即对任意不同的$i$和$j$，有$T_i \\neq T_j$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2011] Taboo", "background": "", "description": "People in Magic Land always mention the legend: their ancestor John helped Koishi and her elder sister Satori on that eastern island, and they ultimately fought to a draw. After that, Koishi recovered her mind-reading ability...\n\nNow, in an age when John has become a legend, people who revisit that island find that Koishi has run into new trouble.\n\nThis time she encounters Flandre Scarlet — she has the ability to use taboo magic without being harmed.\n\nTo explain what taboo magic is and how it causes damage, we introduce the following concepts:\n\n1. Every non-empty string over an alphabet $A$ corresponds to a spell. Here $A$ is the set containing the first $alphabet$ lowercase letters.\n2. There is a set $T$ that contains $N$ strings over the alphabet $A$. Each string in $T$ is called a taboo string (taboo string).\n3. A spell, or equivalently its corresponding string $s$, causes damage to the user due to taboos as follows: partition $s$ into several segments, and consider the number of segments that are taboo strings. Different partitions may yield different counts; the maximum count is the damage.\n\nBecause she can read minds, Koishi always uses Flandre Scarlet’s spells at random. Concretely, her spells correspond exactly to all strings of length $len$ over the alphabet $A$.\n\nHowever, some of Flandre Scarlet’s spells are taboo. Due to her special nature, she can use taboo magic without taking damage, but Koishi cannot. Poor Koishi faces the threat of taboo damage every time she uses one of Flandre’s spells.\n\nYou need to compute the expected taboo damage when Koishi picks each of Flandre’s spells with equal probability, i.e., uniformly over all length-$len$ strings over $A$.", "inputFormat": "The first line contains three positive integers $N$, $len$, $alphabet$.  \nThe next $N$ lines each contain a string $T_i$, representing a taboo string.", "outputFormat": "Output a non-negative real number, the expected taboo damage. Your answer must have an absolute error not exceeding $10^{-6}$.", "hint": "[Explanation for Sample 1]  \nThere are $2^4 = 16$ different spells.\n\nNote that the taboo damage of \"aabb\" is 1 rather than 2.\n\nConstraints\n\n- In at least 40% of the testdata: $N = 1$.\n- For 100% of the testdata: $N \\le 5$, $len \\le 10^9$, $1 \\le alphabet \\le 26$.\n- The testdata guarantees that the length of each string $T_i$ does not exceed $15$, and is non-empty.\n- The testdata guarantees that each $T_i$ contains only the first $alphabet$ lowercase letters.\n- The testdata guarantees that the set $T$ has no duplicate elements; that is, for any distinct $i$ and $j$, $T_i \\ne T_j$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2011] 禁忌", "background": "", "description": "Magic Land上的人们总是提起那个传说：他们的祖先John在那个东方岛屿帮助Koishi与其姐姐Satori最终战平。而后，Koishi恢复了读心的能力……\n\n如今，在John已经成为传说的时代，再次造访那座岛屿的人们却发现Koishi遇到了新麻烦。\n\n这次她遇到了Flandre Scarlet——她拥有可以使用禁忌魔法而不会受到伤害的能力。\n\n为了说明什么是禁忌魔法及其伤害，引入以下概念：\n\n1. 字母集$A$上的每个非空字符串对应了一个魔法。其中$A$是包含了前alphabet个小写字母的集合。\n2. 有一个集合$T$，包含了$N$个字母集$A$上的字符串。$T$中的每一串称为一个禁忌串（Taboo string）\n3. 一个魔法，或等价地，其对应的串$s$因为包含禁忌而对使用者造成的伤害按以下方式确定：把$s$分割成若干段，考虑其中是禁忌串的段的数目，不同的分割可能会有不同的数目，其最大值就是这个伤害。\n\n由于拥有了读心的能力，Koishi总是随机地使用Flandre Scarlet的魔法，可以确定的是，她的魔法正好对应字母集$A$上所有长度为$len$的串。\n\n但是，Flandre Scarlet所使用的一些魔法是带有禁忌的，由于其自身特性，她可以使用禁忌魔法而不受到伤害，而Koishi就不同了。可怜的Koishi每一次使用对方的魔法都面临着受到禁忌伤害的威胁。\n\n你现在需要计算的是如果Koishi使用对方的每一个魔法的概率是均等的，那么每一次随机使用魔法所受到的禁忌伤害的期望值是多少。", "inputFormat": "第一行包含三个正整数 $N$、$len$、$alphabet$。  \n接下来$N$行，每行包含一个串$T_i$，表示禁忌串。", "outputFormat": "一个非负实数，表示所受到禁忌伤害的期望值。你的答案需要保证绝对误差不超过 $10^{-6}$。", "hint": "【样例1解释】\n一共有$2^4 = 16$种不同的魔法。\n\n需要注意的是“aabb”的禁忌伤害是1而不是2。\n\n### 数据范围\n\n有不少于40%的数据中：$N = 1$。  \n100%的数据中$N ≤ 5$，$len ≤10^9$，$1 ≤ alphabet ≤ 26$。  \n数据保证每个串$T_i$的长度不超过$15$，并且不是空串。  \n数据保证每个$T_i$均仅含有前$alphabet$个小写字母。  \n数据保证集合$T$中没有相同的元素，即对任意不同的$i$和$j$，有$T_i \\neq T_j$。", "locale": "zh-CN"}}}
{"pid": "P4570", "type": "P", "difficulty": 5, "samples": [["3 \n1 10 \n2 20 \n3 30", "50"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2011", "北京", "线性基"], "title": "[BJWC2011] 元素", "background": "", "description": "相传，在远古时期，位于西方大陆的 Magic Land 上，人们已经掌握了用魔法矿石炼制法杖的技术。那时人们就认识到，一个法杖的法力取决于使用的矿石。\n\n一般地，矿石越多则法力越强，但物极必反：有时，人们为了获取更强的法力而使用了很多矿石，却在炼制过程中发现魔法矿石全部消失了，从而无法炼制出法杖，这个现象被称为“魔法抵消” 。特别地，如果在炼制过程中使用超过一块同一种矿石，那么一定会发生“魔法抵消”。后来，随着人们认知水平的提高，这个现象得到了很好的解释。经过了大量的实验后，著名法师 Dmitri 发现：如果给现在发现的每一种矿石进行合理的编号（编号为正整数，称为该矿石的元素序号），那么，一个矿石组合会产生“魔法抵消”当且仅当存在一个非空子集，那些矿石的元素序号按位异或起来为零（如果你不清楚什么是异或，请参见下一页的名词解释 ）。\n\n例如，使用两个同样的矿石必将发生“魔法抵消”，因为这两种矿石的元素序号相同，异或起来为零。并且人们有了测定魔力的有效途径，已经知道了：合成出来的法杖的魔力等于每一种矿石的法力之和。人们已经测定了现今发现的所有矿石的法力值，并且通过实验推算出每一种矿石的元素序号。 \n\n现在，给定你以上的矿石信息，请你来计算一下当时可以炼制出的法杖最多有多大的魔力。", "inputFormat": "第一行包含一个正整数 $N$，表示矿石的种类数。\n\n接下来 $N$ 行，每行两个正整数$\\mathrm{Number}_i$ 和 $\\mathrm{Magic}_i$，表示这种矿石的元素序号和魔力值。", "outputFormat": "仅包含一行，一个整数代表最大的魔力值。", "hint": "### 样例解释\n\n由于有“魔法抵消”这一事实，每一种矿石最多使用一块。 \n\n如果使用全部三种矿石，由于三者的元素序号异或起来：$1\\ \\mathrm{xor}\\ 2\\ \\mathrm{xor}\\ 3 = 0$ ，则会发生魔法抵消，得不到法杖。 \n\n可以发现，最佳方案是选择后两种矿石，法力为 $20+30=50$。 \n\n### 数据范围\n\n对于全部的数据：$1\\leq N \\leq 1000$，$1\\leq \\mathrm{Number}_i \\le 10^{18}$，$1\\leq \\mathrm{Magic}_i \\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2011] Elements", "background": "", "description": "It is said that in ancient times, on the western continent, Magic Land, people had already mastered the technique of forging staffs from magic ores. People then realized that the power of a staff depended on the ores used.\n\nIn general, the more ores used, the stronger the power; but too much of anything backfires: sometimes people used many ores in pursuit of greater power, only to find during forging that all the magic ores disappeared, making it impossible to forge a staff. This phenomenon is called \"magic cancellation.\" In particular, if more than one ore of the same type is used during forging, \"magic cancellation\" will certainly occur. Later, as understanding improved, this phenomenon was well explained. After many experiments, the renowned mage Dmitri discovered: if we assign a reasonable numbering to each currently known ore type (the numbers are positive integers, called the element index of the ore), then a multiset of ores will produce \"magic cancellation\" if and only if there exists a non-empty subset whose element indices XOR to zero (if you are not familiar with XOR, please see the glossary on the next page).\n\nFor example, using two identical ores will definitely cause \"magic cancellation,\" because the element indices of these two ores are the same and XOR to zero. Moreover, people found an effective way to measure magic power, and it is known that the magic power of the synthesized staff equals the sum of the magic power of each ore used. The magic power values of all currently known ores have been measured, and the element index of each ore has been inferred through experiments.\n\nNow, given the above information about the ores, please compute the maximum possible magic power of a staff that could be forged.", "inputFormat": "The first line contains a positive integer $N$, representing the number of ore types.\n\nThe next $N$ lines each contain two positive integers $\\mathrm{Number}_i$ and $\\mathrm{Magic}_i$, representing the element index and magic power value of this ore type.", "outputFormat": "Output a single line with one integer representing the maximum magic power.", "hint": "### Sample Explanation\n\nDue to the fact of \"magic cancellation,\" at most one ore of each type can be used.\n\nIf all three types of ores are used, since their element indices XOR to $1\\ \\mathrm{xor}\\ 2\\ \\mathrm{xor}\\ 3 = 0$, magic cancellation will occur and no staff can be obtained.\n\nIt can be seen that the optimal plan is to choose the last two types of ores, with magic power $20+30=50$.\n\n### Constraints\n\nFor all testdata: $1 \\leq N \\leq 1000$, $1 \\leq \\mathrm{Number}_i \\le 10^{18}$, $1 \\leq \\mathrm{Magic}_i \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2011] 元素", "background": "", "description": "相传，在远古时期，位于西方大陆的 Magic Land 上，人们已经掌握了用魔法矿石炼制法杖的技术。那时人们就认识到，一个法杖的法力取决于使用的矿石。\n\n一般地，矿石越多则法力越强，但物极必反：有时，人们为了获取更强的法力而使用了很多矿石，却在炼制过程中发现魔法矿石全部消失了，从而无法炼制出法杖，这个现象被称为“魔法抵消” 。特别地，如果在炼制过程中使用超过一块同一种矿石，那么一定会发生“魔法抵消”。后来，随着人们认知水平的提高，这个现象得到了很好的解释。经过了大量的实验后，著名法师 Dmitri 发现：如果给现在发现的每一种矿石进行合理的编号（编号为正整数，称为该矿石的元素序号），那么，一个矿石组合会产生“魔法抵消”当且仅当存在一个非空子集，那些矿石的元素序号按位异或起来为零（如果你不清楚什么是异或，请参见下一页的名词解释 ）。\n\n例如，使用两个同样的矿石必将发生“魔法抵消”，因为这两种矿石的元素序号相同，异或起来为零。并且人们有了测定魔力的有效途径，已经知道了：合成出来的法杖的魔力等于每一种矿石的法力之和。人们已经测定了现今发现的所有矿石的法力值，并且通过实验推算出每一种矿石的元素序号。 \n\n现在，给定你以上的矿石信息，请你来计算一下当时可以炼制出的法杖最多有多大的魔力。", "inputFormat": "第一行包含一个正整数 $N$，表示矿石的种类数。\n\n接下来 $N$ 行，每行两个正整数$\\mathrm{Number}_i$ 和 $\\mathrm{Magic}_i$，表示这种矿石的元素序号和魔力值。", "outputFormat": "仅包含一行，一个整数代表最大的魔力值。", "hint": "### 样例解释\n\n由于有“魔法抵消”这一事实，每一种矿石最多使用一块。 \n\n如果使用全部三种矿石，由于三者的元素序号异或起来：$1\\ \\mathrm{xor}\\ 2\\ \\mathrm{xor}\\ 3 = 0$ ，则会发生魔法抵消，得不到法杖。 \n\n可以发现，最佳方案是选择后两种矿石，法力为 $20+30=50$。 \n\n### 数据范围\n\n对于全部的数据：$1\\leq N \\leq 1000$，$1\\leq \\mathrm{Number}_i \\le 10^{18}$，$1\\leq \\mathrm{Magic}_i \\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P4571", "type": "P", "difficulty": 5, "samples": [["3 2\n3\n4\n4", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "江苏"], "title": "[JSOI2009] 瓶子和燃料", "background": "", "description": "jyy 一直想着尽快回地球，可惜他飞船的燃料不够了。有一天他又去向火星人要燃料，这次火星人答应了，要 jyy 用飞船上的瓶子来换。jyy 的飞船上共有 $N$ 个瓶子（$1 \\leq N \\leq 1000$），经过协商，火星人只要其中的 $K$ 个。 \n\njyy 将 $K$ 个瓶子交给火星人之后，火星人用它们装一些燃料给 jyy。所有的瓶子都没有刻度，只在瓶口标注了容量，第 $i$ 个瓶子的容量为 $V _ i$（$V _ i$ 为整数，并且满足 $1 \\leq V _ i \\leq 10 ^ 9$） 。火星人比较吝啬，他们并不会把所有的瓶子都装满燃料。他们拿到瓶子后，会跑到燃料库里鼓捣一通，弄出一小点燃料来交差。jyy 当然知道他们会来这一手，于是事先了解了火星人鼓捣的具体内容。\n\n火星人在燃料库里只会做如下的 $3$ 种操作：\n\n1. 将某个瓶子装满燃料；\n2. 将某个瓶子中的燃料全部倒回燃料库；\n3. 将燃料从瓶子 $a$ 倒向瓶子 $b$，直到瓶子 $b$ 满或者瓶子 $a$ 空。燃料倾倒过程中的损耗可以忽略。\n\n火星人拿出的燃料，当然是这些操作能得到的最小正体积。jyy 知道，对于不同的瓶子组合，火星人可能会被迫给出不同体积的燃料。jyy 希望找到最优的瓶子组合，使得火星人给出尽量多的燃料。", "inputFormat": "第一行为两个整数 $N,K$。  \n第 $2 \\sim N$ 行，每行一个整数，第 $i+1$ 行的整数为 $V _ i$。", "outputFormat": "仅一行一个整数，表示火星人给出燃料的最大值。", "hint": "选择第 $2$ 个瓶子和第 $3$ 个瓶子，火星人被迫会给出 $4$ 体积的容量。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2009] Bottles and Fuel", "background": "", "description": "jyy has always wanted to return to Earth as soon as possible, but unfortunately his spaceship does not have enough fuel. One day he went to ask the Martians for fuel again. This time the Martians agreed, asking jyy to trade with the bottles on his spaceship. There are $N$ bottles on jyy's spaceship ($1 \\leq N \\leq 1000$), and after negotiation, the Martians only want $K$ of them.\n\nAfter jyy gives $K$ bottles to the Martians, they use them to fill some fuel for jyy. None of the bottles have graduation marks; only the capacity is labeled at the mouth. The capacity of the $i$-th bottle is $V _ i$ ($V _ i$ is an integer and satisfies $1 \\leq V _ i \\leq 10 ^ 9$). The Martians are stingy and will not fill all bottles to the brim. After they take the bottles, they will fiddle around in the fuel depot and produce a tiny amount of fuel just to get by. jyy certainly knows this trick, so he learned in advance exactly what the Martians do.\n\nIn the fuel depot, the Martians only perform the following $3$ types of operations:\n1. Fill some bottle completely with fuel;\n2. Pour all the fuel in some bottle back into the depot;\n3. Pour fuel from bottle $a$ into bottle $b$ until bottle $b$ is full or bottle $a$ is empty. Loss during the pouring process can be ignored.\n\nThe fuel they hand over is, of course, the smallest positive volume obtainable by these operations. jyy knows that for different choices of bottles, the Martians might be forced to give different volumes of fuel. jyy wants to find the optimal set of bottles so that the Martians are forced to give as much fuel as possible.", "inputFormat": "The first line contains two integers $N, K$.\nThe next $N$ lines each contain one integer; the integer on the $(i+1)$-th line is $V _ i$.", "outputFormat": "Output a single integer on one line, representing the maximum amount of fuel the Martians will be forced to give.", "hint": "Choose the 2nd and 3rd bottles; the Martians will be forced to give a volume of 4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2009] 瓶子和燃料", "background": "", "description": "jyy 一直想着尽快回地球，可惜他飞船的燃料不够了。有一天他又去向火星人要燃料，这次火星人答应了，要 jyy 用飞船上的瓶子来换。jyy 的飞船上共有 $N$ 个瓶子（$1 \\leq N \\leq 1000$），经过协商，火星人只要其中的 $K$ 个。 \n\njyy 将 $K$ 个瓶子交给火星人之后，火星人用它们装一些燃料给 jyy。所有的瓶子都没有刻度，只在瓶口标注了容量，第 $i$ 个瓶子的容量为 $V _ i$（$V _ i$ 为整数，并且满足 $1 \\leq V _ i \\leq 10 ^ 9$） 。火星人比较吝啬，他们并不会把所有的瓶子都装满燃料。他们拿到瓶子后，会跑到燃料库里鼓捣一通，弄出一小点燃料来交差。jyy 当然知道他们会来这一手，于是事先了解了火星人鼓捣的具体内容。\n\n火星人在燃料库里只会做如下的 $3$ 种操作：\n\n1. 将某个瓶子装满燃料；\n2. 将某个瓶子中的燃料全部倒回燃料库；\n3. 将燃料从瓶子 $a$ 倒向瓶子 $b$，直到瓶子 $b$ 满或者瓶子 $a$ 空。燃料倾倒过程中的损耗可以忽略。\n\n火星人拿出的燃料，当然是这些操作能得到的最小正体积。jyy 知道，对于不同的瓶子组合，火星人可能会被迫给出不同体积的燃料。jyy 希望找到最优的瓶子组合，使得火星人给出尽量多的燃料。", "inputFormat": "第一行为两个整数 $N,K$。  \n第 $2 \\sim N$ 行，每行一个整数，第 $i+1$ 行的整数为 $V _ i$。", "outputFormat": "仅一行一个整数，表示火星人给出燃料的最大值。", "hint": "选择第 $2$ 个瓶子和第 $3$ 个瓶子，火星人被迫会给出 $4$ 体积的容量。", "locale": "zh-CN"}}}
{"pid": "P4572", "type": "P", "difficulty": 6, "samples": [["7\n1 2\n1 3\n2 5\n2 6\n7 2\n4 1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2013", "各省省选", "江苏"], "title": "[JSOI2013] 哈利波特与死亡圣器", "background": "", "description": "伏地魔的黑暗势力控制了魔法部与霍格沃茨魔法学校之后，哈利与罗恩、赫敏不得不逃亡在外，隐形遁迹。为了完成校长邓布利多的遗命，一直在暗中寻机销毁伏地魔魂器的哈利，意外地获悉如果他们能够拥有传说中的三件死亡圣器，伏地魔将必死无疑。\n\n在凤凰社成员的帮助下，哈利一行人重新掌控了霍格沃茨。然而此举激怒了伏地魔，他很快率领大批食死徒和黑暗生物向霍格沃茨进军。麦格教授紧急疏散了霍格沃茨的学生，并开始了守卫霍格沃茨的战斗。\n\n霍格沃茨魔法学校的主要建筑共有 $n$ 处，我们编号为 $1$ 到 $n$，这些建筑间由魔法道路连接，整体呈树状分布，即任意两个建筑间有且仅有一条路径相连（路径可以是一条或多条道路组成）。霍格沃茨历经多年风雨，每个建筑自身有许多保护魔法，比如“石墩触动咒”、“降敌陷阱咒”、“统统加护咒”等，只需有人前往施用咒语即能保卫建筑。\n\n现在，伏地魔大军已经到达 $1$ 号建筑——学校大门，凤凰社成员也已经在大门迎战，并且已经启用了大门的保护魔法。然而伏地魔大军势力壮大，保护魔法只能延缓大军的进攻锋芒，他们仍能用一个小时攻克一个建筑，随后整个大军便随机前往与之相邻的另一个建筑（兵贵神速，大军移动过程不需要时间；兵法无常，他们有可能前往已经攻克的建筑）。\n\n目前除了 $1$ 号建筑，其他建筑的保护魔法都尚未被启用，凤凰社决定派出一些成员去其他建筑施用咒语来启动保护魔法。每个凤凰社成员可以瞬间达到任意一个建筑，并用一个小时完成对该建筑保护魔法的启用，之后可以再前往其他的建筑。他们的任务是，保证不论伏地魔大军如何行动，大军所到建筑的保护魔法都已经启用。为了集中更多力量直接打击伏地魔大军，凤凰社希望派出施用咒语的成员数尽可能少。\n\n请你计算，至少需要派出多少位成员。\n\n注：\n\n- 伏地魔大军到达 $1$ 号建筑开始攻击的同时，凤凰社派出成员去其他建筑施咒。\n\n- 当大军攻克某个建筑后，凤凰社成员可以在知道大军下一个小时去哪个建筑的情况下，再决定他们去哪些建筑施咒。这个过程也不需要时间。\n\n- 已经启用过保护魔法的建筑无需再施咒，即便大军攻克该建筑以后某个时候又回到这个建筑，大军也会在这个建筑持续攻击一个小时后再离开。", "inputFormat": "第一行一个整数 $n$，表示建筑的数量。\n\n接下来 $n-1$ 行，每行两个整数 $u,v$，表示建筑 $u$ 和建筑 $v$ 之间有一条魔法道路。\n", "outputFormat": "一行一个整数，表示最少需要派出施用咒语的成员数。", "hint": "### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 3\\times 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2013] 哈利波特与死亡圣器", "background": "", "description": "伏地魔的黑暗势力控制了魔法部与霍格沃茨魔法学校之后，哈利与罗恩、赫敏不得不逃亡在外，隐形遁迹。为了完成校长邓布利多的遗命，一直在暗中寻机销毁伏地魔魂器的哈利，意外地获悉如果他们能够拥有传说中的三件死亡圣器，伏地魔将必死无疑。\n\n在凤凰社成员的帮助下，哈利一行人重新掌控了霍格沃茨。然而此举激怒了伏地魔，他很快率领大批食死徒和黑暗生物向霍格沃茨进军。麦格教授紧急疏散了霍格沃茨的学生，并开始了守卫霍格沃茨的战斗。\n\n霍格沃茨魔法学校的主要建筑共有 $n$ 处，我们编号为 $1$ 到 $n$，这些建筑间由魔法道路连接，整体呈树状分布，即任意两个建筑间有且仅有一条路径相连（路径可以是一条或多条道路组成）。霍格沃茨历经多年风雨，每个建筑自身有许多保护魔法，比如“石墩触动咒”、“降敌陷阱咒”、“统统加护咒”等，只需有人前往施用咒语即能保卫建筑。\n\n现在，伏地魔大军已经到达 $1$ 号建筑——学校大门，凤凰社成员也已经在大门迎战，并且已经启用了大门的保护魔法。然而伏地魔大军势力壮大，保护魔法只能延缓大军的进攻锋芒，他们仍能用一个小时攻克一个建筑，随后整个大军便随机前往与之相邻的另一个建筑（兵贵神速，大军移动过程不需要时间；兵法无常，他们有可能前往已经攻克的建筑）。\n\n目前除了 $1$ 号建筑，其他建筑的保护魔法都尚未被启用，凤凰社决定派出一些成员去其他建筑施用咒语来启动保护魔法。每个凤凰社成员可以瞬间达到任意一个建筑，并用一个小时完成对该建筑保护魔法的启用，之后可以再前往其他的建筑。他们的任务是，保证不论伏地魔大军如何行动，大军所到建筑的保护魔法都已经启用。为了集中更多力量直接打击伏地魔大军，凤凰社希望派出施用咒语的成员数尽可能少。\n\n请你计算，至少需要派出多少位成员。\n\n注：\n\n- 伏地魔大军到达 $1$ 号建筑开始攻击的同时，凤凰社派出成员去其他建筑施咒。\n\n- 当大军攻克某个建筑后，凤凰社成员可以在知道大军下一个小时去哪个建筑的情况下，再决定他们去哪些建筑施咒。这个过程也不需要时间。\n\n- 已经启用过保护魔法的建筑无需再施咒，即便大军攻克该建筑以后某个时候又回到这个建筑，大军也会在这个建筑持续攻击一个小时后再离开。", "inputFormat": "第一行一个整数 $n$，表示建筑的数量。\n\n接下来 $n-1$ 行，每行两个整数 $u,v$，表示建筑 $u$ 和建筑 $v$ 之间有一条魔法道路。\n", "outputFormat": "一行一个整数，表示最少需要派出施用咒语的成员数。", "hint": "### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 3\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4573", "type": "P", "difficulty": 5, "samples": [["> < < < > <\nv ^ v v ^ v ^ ^ v\n< < < > < <\nv ^ v ^ v v ^ ^ v\n< < < < > >\n< > > > < >\nv v ^ ^ v ^ ^ v v\n< > > < > >\n^ v v v ^ v v ^ v\n> < < > > >\n< > > > > <\nv v v v ^ ^ ^ ^ ^\n> < < < < <\n^ ^ ^ ^ ^ v v v ^\n> > < > < <", "5 3 9 4 6 8 2 1 7\n2 4 8 1 9 7 3 5 6\n1 6 7 2 3 5 9 8 4\n6 8 1 7 4 2 5 9 3\n3 7 5 9 1 6 8 4 2\n9 2 4 5 8 3 7 6 1\n7 9 6 8 2 1 4 3 5\n4 1 2 3 5 9 6 7 8\n8 5 3 6 7 4 1 2 9"], ["< > > < > <\nv v ^ ^ v v ^ ^ ^\n< < > < > <\n^ ^ ^ v ^ ^ ^ v v\n< < < < > > \n> < > > > >\nv ^ ^ ^ ^ v v v ^\n> > > > < >\nv v ^ v ^ v ^ v ^\n> < < > > > \n< < < < > <\nv ^ v v v v ^ ^ v\n< > > < < >\n^ v v v ^ v ^ v v\n< > < > < >", "4 9 1 7 3 6 5 2 8\n2 3 7 8 1 5 6 4 9\n5 6 8 2 4 9 7 3 1\n9 1 3 6 5 4 8 7 2\n8 5 4 9 7 2 1 6 3\n7 2 6 3 8 1 9 5 4\n3 4 9 5 6 8 2 1 7\n1 8 5 4 2 7 3 9 6\n6 7 2 1 9 3 4 8 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2013", "重庆", "各省省选", "枚举", "深度优先搜索 DFS"], "title": "[CQOI2013] 新数独", "background": "", "description": "下面是一个没有数字，只有大小关系（没错，那些尖角都是“大于符号”）！的数独：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wm5lvhj6.png)\n\n除了大小关系外（注意相邻格子不能相同），还需要满足通常的数独规则：\n\n * 每个格子都是 $1\\sim 9$ 的数字；\n * 每行都是 $1 \\sim 9$ 的排列；\n * 每列都是 $1 \\sim 9$ 的排列；\n * 每个 $3\\times 3$ 的子矩阵（上图中用粗线隔开，一共有 $3\\times 3$ 个这样的子矩阵）都是 $1\\sim 9$ 的排列。\n \n 如下图所示，是上述提到的数独的唯一一种填法：\n \n ![](https://cdn.luogu.com.cn/upload/image_hosting/73a6a29i.png)\n \n 为了美观，每个 $3\\times 3$ 子矩阵的**所有 $12$ 对**相邻格子的大小关系都将给出。", "inputFormat": "一共 $15$ 行，包含一个新数独的实例。第 $1,3,5,6,8,10,11,13,15$ 行包含左右方向的符号（< 和 >），其余行包含上下方向的符号（^ 和 v）", "outputFormat": "包含 $9$ 行，每行 $9$ 个 $1\\sim 9$ 的数字，以空格隔开。输入保证唯一解。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2013] New Sudoku", "background": "", "description": "Below is a Sudoku with no digits, only inequality relations (yes, those chevrons are all \"greater-than\" signs):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wm5lvhj6.png)\n\nBesides the inequality relations (note that adjacent cells cannot be equal), it must also satisfy the usual Sudoku rules:\n- Each cell is a digit from $1 \\sim 9$.\n- Each row is a permutation of $1 \\sim 9$.\n- Each column is a permutation of $1 \\sim 9$.\n- Each $3 \\times 3$ subgrid (separated by bold lines in the figure above; there are $3 \\times 3$ such subgrids) is a permutation of $1 \\sim 9$.\n \nAs shown below, there is exactly one way to fill the Sudoku above:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/73a6a29i.png)\n\nFor neatness, for each $3 \\times 3$ subgrid, the inequality relations for **all $12$ pairs** of adjacent cells will be given.", "inputFormat": "There are $15$ lines in total, describing one instance of the new Sudoku. Lines $1, 3, 5, 6, 8, 10, 11, 13, 15$ contain left-right symbols (< and >), and the other lines contain up-down symbols (^ and v).", "outputFormat": "Output $9$ lines, each containing $9$ digits from $1 \\sim 9$, separated by spaces. The input guarantees a unique solution.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2013] 新数独", "background": "", "description": "下面是一个没有数字，只有大小关系（没错，那些尖角都是“大于符号”）！的数独：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wm5lvhj6.png)\n\n除了大小关系外（注意相邻格子不能相同），还需要满足通常的数独规则：\n\n * 每个格子都是 $1\\sim 9$ 的数字；\n * 每行都是 $1 \\sim 9$ 的排列；\n * 每列都是 $1 \\sim 9$ 的排列；\n * 每个 $3\\times 3$ 的子矩阵（上图中用粗线隔开，一共有 $3\\times 3$ 个这样的子矩阵）都是 $1\\sim 9$ 的排列。\n \n 如下图所示，是上述提到的数独的唯一一种填法：\n \n ![](https://cdn.luogu.com.cn/upload/image_hosting/73a6a29i.png)\n \n 为了美观，每个 $3\\times 3$ 子矩阵的**所有 $12$ 对**相邻格子的大小关系都将给出。", "inputFormat": "一共 $15$ 行，包含一个新数独的实例。第 $1,3,5,6,8,10,11,13,15$ 行包含左右方向的符号（< 和 >），其余行包含上下方向的符号（^ 和 v）", "outputFormat": "包含 $9$ 行，每行 $9$ 个 $1\\sim 9$ 的数字，以空格隔开。输入保证唯一解。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4574", "type": "P", "difficulty": 5, "samples": [["7 6 9", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2013", "重庆", "各省省选", "枚举", "进制"], "title": "[CQOI2013] 二进制A+B", "background": null, "description": "输入三个整数 $a, b, c$，把它们写成无前导 $0$ 的二进制整数。\n\n比如 $a=7, b=6, c=9$，写成二进制为 $a=(111)_2, b=(110)_2, c=(1001)_2$。\n\n接下来以位数最多的为基准，其他整数在前面添加前导 $0$，使得 $a, b, c$ 拥有相同的位数。比如在刚才的例子中，添加完前导 $0$ 后为 $a=(0111)_2, b=(0110)_2, c=(1001)_2$。\n\n最后，把 $a, b, c$ 的各位进行重排，得到 $a', b', c'$，使得 $a'+b'=c'$。比如在刚才的例子中，可以这样重排：$a'=(0111)_2, b'=(0011)_2, c'=(1010)_2$。\n\n你的任务是让 $c'$ 最小。如果无解，输出 $-1$。", "inputFormat": "输入仅一行，包含三个整数 $a, b, c$。", "outputFormat": "输出仅一行，为 $c'$ 的最小值。", "hint": "对于所有的测试数据，$a,b,c \\le 2^{30}$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2013] Binary A+B", "background": "", "description": "You are given three integers $a, b, c$ and write them as binary integers without leading zeros.\n\nFor example, when $a=7, b=6, c=9$, their binary forms are $a=(111)_2, b=(110)_2, c=(1001)_2$.\n\nNext, pad the shorter ones with leading zeros so that $a, b, c$ have the same number of bits as the longest one. In the example above, after padding we get $a=(0111)_2, b=(0110)_2, c=(1001)_2$.\n\nFinally, rearrange the bits of $a, b, c$ to obtain $a', b', c'$ such that $a' + b' = c'$. In the example above, one possible rearrangement is $a'=(0111)_2, b'=(0011)_2, c'=(1010)_2$.\n\nYour task is to make $c'$ as small as possible. If there is no solution, output $-1$.", "inputFormat": "The input contains a single line with three integers $a, b, c$.", "outputFormat": "Output a single line with the minimum value of $c'$.", "hint": "For all testdata, $a,b,c \\le 2^{30}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2013] 二进制A+B", "background": null, "description": "输入三个整数 $a, b, c$，把它们写成无前导 $0$ 的二进制整数。\n\n比如 $a=7, b=6, c=9$，写成二进制为 $a=(111)_2, b=(110)_2, c=(1001)_2$。\n\n接下来以位数最多的为基准，其他整数在前面添加前导 $0$，使得 $a, b, c$ 拥有相同的位数。比如在刚才的例子中，添加完前导 $0$ 后为 $a=(0111)_2, b=(0110)_2, c=(1001)_2$。\n\n最后，把 $a, b, c$ 的各位进行重排，得到 $a', b', c'$，使得 $a'+b'=c'$。比如在刚才的例子中，可以这样重排：$a'=(0111)_2, b'=(0011)_2, c'=(1010)_2$。\n\n你的任务是让 $c'$ 最小。如果无解，输出 $-1$。", "inputFormat": "输入仅一行，包含三个整数 $a, b, c$。", "outputFormat": "输出仅一行，为 $c'$ 的最小值。", "hint": "对于所有的测试数据，$a,b,c \\le 2^{30}$。", "locale": "zh-CN"}}}
{"pid": "P4575", "type": "P", "difficulty": 4, "samples": [["4\n2\n1\n0 1\n5\n0\n4\n3\n0 1\n2 1\n2 3\n3\n9\n0 1\n0 2\n1 2\n1 0\n2 0\n2 1\n0 0\n1 1\n2 2", "Yes\nYes\nNo\nYes"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2013", "重庆", "各省省选"], "title": "[CQOI2013] 图的逆变换", "background": "", "description": "给一个 $n$ 结点 $m$ 条边的有向图 $D$，可以这样构造图 $E$：给 $D$ 的每条边 $(u,v)$，在 $E$ 中建立一个点 $uv$，然后对于 $D$ 中的两条边 $(u,v)$ 和 $(v,w)$，在 $E$ 中从 $uv$ 向 $vw$ 连一条有向边。$E$ 中不含有其他点和边。\n\n输入 $E$，你的任务是判断是否存在相应的 $D$。\n\n注意，$D$ 可以有重边和自环。", "inputFormat": "第一行包含测试数据个数 $T$（$T\\leq 10$）。\n\n对于每组数据：\n\n第一行一个整数 $m$（$0\\le m\\le300$），表示 $D$ 的边数（即 $E$ 的点数）。\n\n第二行一个整数 $k$，表示 $E$ 的边数。\n\n以下 $k$ 行每行两个整数 $x, y$，表示 $E$ 中有一条有向边 $(x,y)$。$E$ 中的点编号为 $0\\sim m-1$。", "outputFormat": "对于每组数据输出一行。如果存在，输出 `Yes`，否则输出 `No`。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2013] Inverse Transformation of a Graph", "background": "", "description": "Given a directed graph $D$ with $n$ vertices and $m$ edges, construct a graph $E$ as follows: for each edge $(u,v)$ in $D$, create a vertex $uv$ in $E$; then for any two edges $(u,v)$ and $(v,w)$ in $D$, add a directed edge from $uv$ to $vw$ in $E$. No other vertices or edges exist in $E$.\n\nGiven $E$, your task is to determine whether there exists a corresponding $D$.\n\nNote that $D$ may have parallel edges and self-loops.", "inputFormat": "The first line contains the number of test cases $T$ ($T\\leq 10$).\n\nFor each test case:\n\nThe first line contains an integer $m$ ($0\\le m\\le 300$), the number of edges in $D$ (i.e., the number of vertices in $E$).\n\nThe second line contains an integer $k$, the number of edges in $E$.\n\nEach of the following $k$ lines contains two integers $x, y$, indicating that there is a directed edge $(x,y)$ in $E$. The vertices in $E$ are numbered from $0$ to $m-1$.", "outputFormat": "For each test case, output one line. If it exists, output `Yes`; otherwise, output `No`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2013] 图的逆变换", "background": "", "description": "给一个 $n$ 结点 $m$ 条边的有向图 $D$，可以这样构造图 $E$：给 $D$ 的每条边 $(u,v)$，在 $E$ 中建立一个点 $uv$，然后对于 $D$ 中的两条边 $(u,v)$ 和 $(v,w)$，在 $E$ 中从 $uv$ 向 $vw$ 连一条有向边。$E$ 中不含有其他点和边。\n\n输入 $E$，你的任务是判断是否存在相应的 $D$。\n\n注意，$D$ 可以有重边和自环。", "inputFormat": "第一行包含测试数据个数 $T$（$T\\leq 10$）。\n\n对于每组数据：\n\n第一行一个整数 $m$（$0\\le m\\le300$），表示 $D$ 的边数（即 $E$ 的点数）。\n\n第二行一个整数 $k$，表示 $E$ 的边数。\n\n以下 $k$ 行每行两个整数 $x, y$，表示 $E$ 中有一条有向边 $(x,y)$。$E$ 中的点编号为 $0\\sim m-1$。", "outputFormat": "对于每组数据输出一行。如果存在，输出 `Yes`，否则输出 `No`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4576", "type": "P", "difficulty": 4, "samples": [["2 1 1 2 2", "BLACK 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "博弈论", "2013", "重庆", "各省省选"], "title": "[CQOI2013] 棋盘游戏", "background": null, "description": "一个 $n \\times n$（$ n \\ge 2 $）棋盘上有黑白棋子各一枚。游戏者 A 和 B 轮流移动棋子，A 先走。\n\n * A 的移动规则：只能移动白棋子。可以往上下左右四个方向之一移动一格。\n \n * B 的移动规则：只能移动黑棋子。可以往上下左右四个方向之一移动一格或者两格。\n \n和通常的“吃子”规则一样，当某游戏者把自己的棋子移动到对方棋子所在的格子时，他就赢了。\n\n两个游戏者都很聪明，当可以获胜时会尽快获胜，只能输掉的时候会尽量拖延时间。你的任务是判断谁会赢，需要多少回合。\n\n\n比如 $n=2$，白棋子在 $(1,1)$，黑棋子在 $(2,2)$，那么虽然 A 有两种走法，第二个回合B总能取胜。", "inputFormat": "仅一行，包含五个整数 $n$, $r_1$, $c_1$, $r_2$, $c_2$，即棋盘大小和棋子位置。\n\n白色棋子在 $(r_1,c_1)$，黑色棋子在 $(r_2,c_2)$ $(1 \\le r_1,c_1,r_2,c_2 \\le n)$。黑白棋子的位置保证不相同。", "outputFormat": "仅一行，即游戏结果。\n\n如果 A 获胜，输出 `WHITE x`;\n\n如果 B 获胜，输出 `BLACK x`;\n\n如果二者都没有必胜策略,输出 `DRAW`。\n\n其中 $x$ 表示移动的步数。", "hint": "对于 $100\\%$ 的数据，$n \\le 20$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2013] Chessboard Game", "background": "", "description": "On an $n \\times n$ ($n \\ge 2$) board, there is one white piece and one black piece. Players A and B move alternately, with A moving first.\n\n- A’s move rule: A can only move the white piece. It can move exactly one square in one of the four orthogonal directions (up, down, left, right).\n- B’s move rule: B can only move the black piece. It can move either one or two squares in one of the four orthogonal directions (up, down, left, right).\n\nAs in the usual “capture” rule, when a player moves their piece onto the square occupied by the opponent’s piece, they win.\n\nBoth players are smart: when a win is possible, they will win as soon as possible; when they can only lose, they will delay as much as possible. Your task is to determine who will win and in how many moves.\n\nFor example, when $n=2$, the white piece is at $(1,1)$ and the black piece is at $(2,2)$. Although A has two legal moves, B can always win on the second move.", "inputFormat": "A single line containing five integers $n$, $r_1$, $c_1$, $r_2$, $c_2$, representing the board size and the positions of the pieces.\n\nThe white piece is at $(r_1,c_1)$, and the black piece is at $(r_2,c_2)$ $(1 \\le r_1,c_1,r_2,c_2 \\le n)$. The positions of the white and black pieces are guaranteed to be different.", "outputFormat": "Output a single line: the game result.\n\nIf A wins, output `WHITE x`.\n\nIf B wins, output `BLACK x`.\n\nIf neither player has a forced win, output `DRAW`.\n\nHere $x$ is the number of moves.", "hint": "For 100% of the testdata, $n \\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2013] 棋盘游戏", "background": null, "description": "一个 $n \\times n$（$ n \\ge 2 $）棋盘上有黑白棋子各一枚。游戏者 A 和 B 轮流移动棋子，A 先走。\n\n * A 的移动规则：只能移动白棋子。可以往上下左右四个方向之一移动一格。\n \n * B 的移动规则：只能移动黑棋子。可以往上下左右四个方向之一移动一格或者两格。\n \n和通常的“吃子”规则一样，当某游戏者把自己的棋子移动到对方棋子所在的格子时，他就赢了。\n\n两个游戏者都很聪明，当可以获胜时会尽快获胜，只能输掉的时候会尽量拖延时间。你的任务是判断谁会赢，需要多少回合。\n\n\n比如 $n=2$，白棋子在 $(1,1)$，黑棋子在 $(2,2)$，那么虽然 A 有两种走法，第二个回合B总能取胜。", "inputFormat": "仅一行，包含五个整数 $n$, $r_1$, $c_1$, $r_2$, $c_2$，即棋盘大小和棋子位置。\n\n白色棋子在 $(r_1,c_1)$，黑色棋子在 $(r_2,c_2)$ $(1 \\le r_1,c_1,r_2,c_2 \\le n)$。黑白棋子的位置保证不相同。", "outputFormat": "仅一行，即游戏结果。\n\n如果 A 获胜，输出 `WHITE x`;\n\n如果 B 获胜，输出 `BLACK x`;\n\n如果二者都没有必胜策略,输出 `DRAW`。\n\n其中 $x$ 表示移动的步数。", "hint": "对于 $100\\%$ 的数据，$n \\le 20$。", "locale": "zh-CN"}}}
{"pid": "P4577", "type": "P", "difficulty": 6, "samples": [["6\n2 5 1 3 5 4\n1\n1\n2\n2\n4", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2018", "线段树", "各省省选", "福建", "树形 DP", "差分", "线段树合并", "启发式合并"], "title": "[FJOI2018] 领导集团问题", "background": null, "description": "一个公司的组织领导架构可以用一棵领导树来表示。公司的每个成员对应于树中一个结点 $v_i$，且每个成员都有相应的级别 $w_i$。越高层的领导，其级别值 $w_i$ 越小。树中任何两个结点之间有边相连，则表示与结点相应的两个成员属于同一部门。领导集团问题就是根据公司的领导树确定公司的最大部门。换句话说，也就是在领导树中寻找最大的部门结点子集，使得的结点 $v_i$ 和 $v_j$，如果 $v_i$ 是 $v_j$ 的子孙结点，则 $w_i \\ge w_j$。\n\n编程任务：对于任意对于给定的领导树，计算出领导树中最大的部门结点子集。", "inputFormat": "第一行有一个正整数 $n$，表示领导树的结点数。\n\n接下来的一行中有 $n$ 个整数。第 $i$ 个数表示 $w_i$。\n\n再接下来的 $n-1$ 行中，第 $i$ 行有一个整数 $v_i$ 表示 $v_i$ 是 $i+1$ 的双亲结点。", "outputFormat": "输出找到的最大的部门的成员数。", "hint": "对于 $10\\%$ 的数据，$n\\le 20$；\n\n对于 $40\\%$ 的数据，$n\\le 2000$；\n\n对于 $100\\%$ 的数据，$1\\le n\\le 2\\times 10 ^ 5$，$0 < w_i \\le 10 ^ 9$。", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2018] Leadership Group Problem", "background": "", "description": "A company’s leadership structure can be represented by a leadership tree. Each company member corresponds to a node $v_i$ in the tree, and each member has a corresponding level $w_i$. The higher the leader is in the hierarchy, the smaller their level value $w_i$ is. If there is an edge between any two nodes in the tree, it means the two corresponding members belong to the same department.\n\nThe leadership group problem is to determine the company’s largest department based on the leadership tree. In other words, we need to find the largest subset of nodes in the leadership tree such that for any nodes $v_i$ and $v_j$, if $v_i$ is a descendant of $v_j$, then $w_i \\ge w_j$.\n\nProgramming task: For any given leadership tree, compute the size of the largest valid department node subset in the leadership tree.", "inputFormat": "The first line contains a positive integer $n$, denoting the number of nodes in the leadership tree.\n\nThe next line contains $n$ integers. The $i$-th number denotes $w_i$.\n\nIn the following $n - 1$ lines, the $i$-th line contains an integer $v_i$, meaning that $v_i$ is the parent of node $i + 1$.", "outputFormat": "Output the number of members in the largest department found.", "hint": "For $10\\%$ of the testdata, $n \\le 20$.\n\nFor $40\\%$ of the testdata, $n \\le 2000$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 2 \\times 10 ^ 5$, $0 < w_i \\le 10 ^ 9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2018] 领导集团问题", "background": null, "description": "一个公司的组织领导架构可以用一棵领导树来表示。公司的每个成员对应于树中一个结点 $v_i$，且每个成员都有相应的级别 $w_i$。越高层的领导，其级别值 $w_i$ 越小。树中任何两个结点之间有边相连，则表示与结点相应的两个成员属于同一部门。领导集团问题就是根据公司的领导树确定公司的最大部门。换句话说，也就是在领导树中寻找最大的部门结点子集，使得的结点 $v_i$ 和 $v_j$，如果 $v_i$ 是 $v_j$ 的子孙结点，则 $w_i \\ge w_j$。\n\n编程任务：对于任意对于给定的领导树，计算出领导树中最大的部门结点子集。", "inputFormat": "第一行有一个正整数 $n$，表示领导树的结点数。\n\n接下来的一行中有 $n$ 个整数。第 $i$ 个数表示 $w_i$。\n\n再接下来的 $n-1$ 行中，第 $i$ 行有一个整数 $v_i$ 表示 $v_i$ 是 $i+1$ 的双亲结点。", "outputFormat": "输出找到的最大的部门的成员数。", "hint": "对于 $10\\%$ 的数据，$n\\le 20$；\n\n对于 $40\\%$ 的数据，$n\\le 2000$；\n\n对于 $100\\%$ 的数据，$1\\le n\\le 2\\times 10 ^ 5$，$0 < w_i \\le 10 ^ 9$。", "locale": "zh-CN"}}}
{"pid": "P4578", "type": "P", "difficulty": 5, "samples": [["2\n2 2 4\n1 1 0\n1 2 0\n2 1 2\n2 2 2\n2 2 4\n1 1 0\n1 2 0\n2 1 2\n2 2 1", "Yes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["图论", "2018", "各省省选", "福建", "枚举", "差分约束"], "title": "[FJOI2018] 所罗门王的宝藏", "background": "", "description": "据古代传说记载，所罗门王既是智慧的代表，又是财富的象征。他建立了强大而富有的国家，聚集了大批的黄金象牙和钻石，并把这些价值连城的珍宝藏在一个神秘的地方，这就是世人瞩目的“所罗门王的宝藏”。多少个世纪以来，人们一直在寻找这批早已失落的古代文明宝藏，寻找盛产黄金和钻石的宝地。曾经追寻所罗门王宝藏的冒险者们都一去不回，至今没人解开这个谜题。亨利男爵在一次幸运的旅途中意外地得到了三百年前一位葡萄牙贵族留下的写在羊皮卷上的所罗门王的藏宝图和一本寻宝秘籍。在这张藏宝图的诱惑下，亨利男爵邀请约翰上校和勇敢的猎象人夸特曼开始了寻找埋葬在黑暗地底的所罗门王宝藏的艰险历程。他们横穿渺无边际的沙漠和浓荫蔽日的原始森林，越过汹涌澎湃的激流险滩，翻越高耸入云的峻岭雪山，饱尝沙漠的酷热和冰雪严寒，在藏宝图的指引下来到非洲一个原始的神秘国度库库安纳。这里有残酷的人殉制度，有一个拥有一千个妻室的独眼暴君特瓦拉，有像兀鹫一般丑恶诡诈老而不死的女巫加古尔，还有美丽聪慧的绝代佳人弗拉塔。在这片陌生而又险象环生的土地上三位寻宝英雄历尽艰辛，终于在绝代佳人弗拉塔的帮助下在海底深处找到了珍藏这批价值连城宝藏的巨大的藏宝洞。然而在女巫加古尔的精心策划下，一场灭顶之灾正在悄悄逼近。\n\n藏宝洞的洞门十分坚固且洞门紧闭，如果不知道开启洞门的秘密是无法打开藏宝洞的洞门。在藏宝洞的洞门一侧有一个奇怪的矩形密码阵列。根据寻宝秘籍的记载，在密码阵列每行的左侧和每列的顶端都有一颗红宝石按钮。每个按钮都可以向左或向右转动。每向左转动一次按钮，相应的行或列中数字都增 $1$。每向右转动一次按钮，相应的行或列中数字都减 $1$。在矩形密码阵列的若干特定位置镶嵌着绿宝石。只有当所有绿宝石位置的数字与藏宝图记载的密码完全相同，紧闭的洞门就会自动缓缓打开。女巫加古尔早已得知开门的秘密。为了阻止寻宝者打开洞门，女巫加古尔为开门的密码阵列设置了全 $0$ 的初始状态。试图打开洞门的寻宝者如果不能迅速转动按钮使所有绿宝石位置的数字与藏宝图记载的密码完全相同，就会自动启动藏宝洞玄妙的暗器机关，使寻宝者遭到灭顶攻击而死于非命。\n\n您能帮助三位寻宝英雄顺利打开藏宝洞的洞门吗？\n\n编程任务：对于给定的密码阵列，找到获得正确密码的红宝石按钮的转动序列。\n", "inputFormat": "输入的第一行中有一个正整数 $T (T \\le 5)$ 表示有 $T$ 组数据。每组数据的第一行有 $3$ 个正整数 $n,m$ 和 $k$，表示洞门密码阵列共有 $n$ 行和 $m$ 列，$0<n,m,k \\le 1000$。各行从上到下依次编号为 $1,2,\\ldots,n$；各列从左到右依次编号为 $1,2,\\ldots,m$ 。接下来的 $k$ 行中每行有三个整数 $x,y,c$，分别表示第 $k$ 个绿宝石在密码阵列中的位置和密码，$x$ 为行号 $y$ 为列号，$c$ 为该位置处的密码。", "outputFormat": "对于每组数据，用一行输出 ``Yes`` 或者 ``No``。输出 ``Yes`` 表示存在获得正确密码的红宝石按钮的转动序列。输出 ``No`` 则表示无法找到获得正确密码的红宝石按钮的转动序列。", "hint": "对于 $100\\%$ 的数据，$1 \\le n, m, k \\le 1000$，$k \\le n \\times m$，$|c| \\le 1,000,000$。", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2018] King Solomon's Treasure", "background": "", "description": "According to ancient legend, King Solomon stood for wisdom and wealth. He built a powerful and prosperous nation, amassed vast quantities of gold, ivory, and diamonds, and hid these priceless treasures in a mysterious place known as “King Solomon’s Treasure.” For centuries, people have searched for this lost treasure of ancient civilization, seeking the fabled land rich in gold and diamonds. Adventurers who pursued King Solomon’s treasure never returned, and to this day no one has solved the riddle. On a fortunate journey, Baron Henry unexpectedly obtained a treasure map of King Solomon left by a Portuguese noble three hundred years ago, written on parchment, along with a treasure-hunting manual. Tempted by the map, Baron Henry invited Colonel John and the brave elephant hunter Quatermain to begin a perilous quest for King Solomon’s treasure buried in the dark depths underground. They crossed boundless deserts and dense primeval forests, passed roaring rapids, climbed towering snowy peaks, and endured scorching heat and bitter cold. Guided by the map, they arrived at Kukuana, a mysterious and primitive land in Africa. There were cruel human sacrifices, a one-eyed tyrant Twala with a thousand wives, an old and crafty witch Gagool as ugly as a vulture, and a beautiful and intelligent lady named Foulata. In this unfamiliar and perilous land, the three treasure hunters endured countless hardships and, with Foulata’s help, finally found a vast treasure cave in the depths beneath the sea where the priceless treasure was hidden. However, under the witch Gagool’s careful plotting, disaster was quietly approaching.\n\nThe door of the treasure cave is strong and tightly shut. Without knowing the secret to opening it, the door cannot be opened. Next to the door is a strange rectangular password grid. According to the treasure-hunting manual, there is a ruby button on the left of each row and at the top of each column of the grid. Each button can be turned to the left or to the right. Each time a button is turned to the left, all numbers in the corresponding row or column increase by $1$. Each time a button is turned to the right, all numbers in the corresponding row or column decrease by $1$. Some positions in the grid are inlaid with emeralds. Only when the numbers at all emerald positions exactly match the password recorded on the map will the tightly shut door slowly open. The witch Gagool already knows the secret of opening the door. To stop the treasure hunters, she set the initial state of the grid to all $0$s. If the treasure hunters cannot quickly turn the buttons so that all emerald positions match the password exactly, a hidden mechanism will be triggered, causing a deadly attack.\n\nCan you help the three treasure hunters open the door of the treasure cave?\n\nProgramming task: For the given password grid, determine whether there exists a sequence of ruby button rotations that yields the correct password at all emerald positions.", "inputFormat": "The first line contains a positive integer $T$ ($T \\le 5$), indicating there are $T$ test cases. For each test case, the first line contains $3$ positive integers $n$, $m$, and $k$, meaning the grid has $n$ rows and $m$ columns, with $0 < n, m, k \\le 1000$. Rows are numbered $1, 2, \\ldots, n$ from top to bottom; columns are numbered $1, 2, \\ldots, m$ from left to right. The next $k$ lines each contain three integers $x$, $y$, $c$, indicating the position and required password value of an emerald in the grid: $x$ is the row index, $y$ is the column index, and $c$ is the required value at that position.", "outputFormat": "For each test case, output one line: ``Yes`` if there exists a sequence of ruby button rotations that yields the correct password, or ``No`` if it is impossible.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le n, m, k \\le 1000$, $k \\le n \\times m$, $|c| \\le 1,000,000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2018] 所罗门王的宝藏", "background": "", "description": "据古代传说记载，所罗门王既是智慧的代表，又是财富的象征。他建立了强大而富有的国家，聚集了大批的黄金象牙和钻石，并把这些价值连城的珍宝藏在一个神秘的地方，这就是世人瞩目的“所罗门王的宝藏”。多少个世纪以来，人们一直在寻找这批早已失落的古代文明宝藏，寻找盛产黄金和钻石的宝地。曾经追寻所罗门王宝藏的冒险者们都一去不回，至今没人解开这个谜题。亨利男爵在一次幸运的旅途中意外地得到了三百年前一位葡萄牙贵族留下的写在羊皮卷上的所罗门王的藏宝图和一本寻宝秘籍。在这张藏宝图的诱惑下，亨利男爵邀请约翰上校和勇敢的猎象人夸特曼开始了寻找埋葬在黑暗地底的所罗门王宝藏的艰险历程。他们横穿渺无边际的沙漠和浓荫蔽日的原始森林，越过汹涌澎湃的激流险滩，翻越高耸入云的峻岭雪山，饱尝沙漠的酷热和冰雪严寒，在藏宝图的指引下来到非洲一个原始的神秘国度库库安纳。这里有残酷的人殉制度，有一个拥有一千个妻室的独眼暴君特瓦拉，有像兀鹫一般丑恶诡诈老而不死的女巫加古尔，还有美丽聪慧的绝代佳人弗拉塔。在这片陌生而又险象环生的土地上三位寻宝英雄历尽艰辛，终于在绝代佳人弗拉塔的帮助下在海底深处找到了珍藏这批价值连城宝藏的巨大的藏宝洞。然而在女巫加古尔的精心策划下，一场灭顶之灾正在悄悄逼近。\n\n藏宝洞的洞门十分坚固且洞门紧闭，如果不知道开启洞门的秘密是无法打开藏宝洞的洞门。在藏宝洞的洞门一侧有一个奇怪的矩形密码阵列。根据寻宝秘籍的记载，在密码阵列每行的左侧和每列的顶端都有一颗红宝石按钮。每个按钮都可以向左或向右转动。每向左转动一次按钮，相应的行或列中数字都增 $1$。每向右转动一次按钮，相应的行或列中数字都减 $1$。在矩形密码阵列的若干特定位置镶嵌着绿宝石。只有当所有绿宝石位置的数字与藏宝图记载的密码完全相同，紧闭的洞门就会自动缓缓打开。女巫加古尔早已得知开门的秘密。为了阻止寻宝者打开洞门，女巫加古尔为开门的密码阵列设置了全 $0$ 的初始状态。试图打开洞门的寻宝者如果不能迅速转动按钮使所有绿宝石位置的数字与藏宝图记载的密码完全相同，就会自动启动藏宝洞玄妙的暗器机关，使寻宝者遭到灭顶攻击而死于非命。\n\n您能帮助三位寻宝英雄顺利打开藏宝洞的洞门吗？\n\n编程任务：对于给定的密码阵列，找到获得正确密码的红宝石按钮的转动序列。\n", "inputFormat": "输入的第一行中有一个正整数 $T (T \\le 5)$ 表示有 $T$ 组数据。每组数据的第一行有 $3$ 个正整数 $n,m$ 和 $k$，表示洞门密码阵列共有 $n$ 行和 $m$ 列，$0<n,m,k \\le 1000$。各行从上到下依次编号为 $1,2,\\ldots,n$；各列从左到右依次编号为 $1,2,\\ldots,m$ 。接下来的 $k$ 行中每行有三个整数 $x,y,c$，分别表示第 $k$ 个绿宝石在密码阵列中的位置和密码，$x$ 为行号 $y$ 为列号，$c$ 为该位置处的密码。", "outputFormat": "对于每组数据，用一行输出 ``Yes`` 或者 ``No``。输出 ``Yes`` 表示存在获得正确密码的红宝石按钮的转动序列。输出 ``No`` 则表示无法找到获得正确密码的红宝石按钮的转动序列。", "hint": "对于 $100\\%$ 的数据，$1 \\le n, m, k \\le 1000$，$k \\le n \\times m$，$|c| \\le 1,000,000$。", "locale": "zh-CN"}}}
{"pid": "P4579", "type": "P", "difficulty": 7, "samples": [["2 2\n0 1 1 2\n2\n1 3\n1 3", "6.83"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2018", "各省省选", "福建", "O2优化"], "title": "[FJOI2018] 邮递员问题", "background": "", "description": "$\\text{2010}$ 年以来，网购市场发展迅速，快递公司成为促成交易成功的关键环节。小郭是一名顺丰快递员，他的工资主要包括底薪、送货提成、收件提成、其他福利补贴等。小郭每完成一件客户的快递单，一般能拿到运费 $10\\%$ 的提成。因此小郭完成的快递单越多越快，他的收入就越高。小郭负责城市中 $2$ 个平行街道的所有快递业务。在这 $2$ 个平行街道上有 $2$ 处快递工作站。小郭每次投递的行程都是从一个工作站出发，完成所有快递单的投递后，回到另一个工作站。为了高效地完成投递任务，小郭希望用最短的行程来完成所有快递单的投递任务。也就是说，对于给定的 $2$ 个平行街道的街距和 $2$ 个工作站位置，以及所有投递点的位置，小郭要计算从一个工作站出发，完成所有快递单的投递后，回到另一个工作站的最短行程。街距是指 $2$ 个平行街道的之间的垂直距离。如果设平面坐标系的 $x$ 轴与街道平行，且 $2$ 个平行街道上的最左端位置的 $x$ 坐标均为 $0$，则 $2$ 个平行街道上的任何位置可以用从街道最左端到该位置的直线距离，即该位置的 $x$ 坐标值来表示。\n\n例如，设 $2$ 个平行街道 A 和 B 的街距是 $2$。$2$ 个工作站 $S_1$ ​​和 $S_2$​​ 的位置分别位于街道 A 的 $x=1$ 和街道 B 的 $x=3$ 处。另外有 $2$ 个投递点 $T_1$ 和 $T_2$​ 的位置分别位于街道 A 的 $x=3$ 和街道 B 的 $x=1$ 处，如图所示。小郭的任务就是要从工作站 $S_1$​​ 出发，完成在 $T_1$​​ 和 $T_2$​​ 处的快递单投递后，回到另一个工作站 $S_2$。\n\n编程任务：对于给定的 $2$ 个平行街道的街距和 $2$ 个工作站位置，以及所有投递点的位置，计算从一个工作站出发，完成所有快递单的投递后，回到另一个工作站的最短行程。", "inputFormat": "第 $1$ 行有 $2$ 个正整数 $n,m$，$1 \\le n,m \\le 10000$，分别表示 $2$ 个平行街道 A 和 B 上的位置数（包括投递点的位置和工作站的位置）。位置编号为 A：$1,2,\\ldots,n$；B：$1,2,\\ldots,m$。\n\n第 $2$ 行有 $4$ 个正整数 $a,b,c,d$，表示 $2$ 个工作站位置分别为 $(a,b)$ 和 $(c,d)$。$a=0$ 或 $c=0$ 表示相应的工作站在街道 $A$，$a=1$ 或 $c=1$ 表示相应的工作站在街道 $B$。$b$ 和 $d$ 分别表示工作站在相应的街道的位置号。例如，若 $(a,b)=(0,3)$ 表示第 $1$ 个工作站位于街道 $A$ 上，其位置位于给出的街道 $A$ 的 $n$ 个位置的第 $3$ 个位置。\n\n第 $3$ 行有 $1$ 个实数 $h$，表示 $2$ 个平行街道的街距 $(1 \\le h \\le 10)$。\n\n第 $4$ 行有 $n$ 个实数，表示街道 $A$ 上 $n$ 个位置的 $x$ 坐标 $(1 \\le x < 20000)$。\n\n第 $5$ 行有 $m$ 个实数，表示街道 $B$ 上 $m$ 个位置的 $x$ 坐标 $(1 \\le x < 20000)$。\n", "outputFormat": "输出计算出的最短行程，保留 $2$ 位小数。", "hint": "对于 $10\\%$ 的数据，$n,m\\le 8$；\n\n对于 $30\\%$ 的数据，$n,m\\le 100$；\n\n对于 $50\\%$ 的数据，$n,m\\le 1000$；\n\n对于 $100\\%$ 的数据，$n,m\\le 10000$。", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2018] Postman Problem", "background": "", "description": "Since $\\text{2010}$, the online shopping market has developed rapidly, and courier companies have become a key part of making transactions successful. Xiao Guo is an SF Express courier. His salary mainly includes a basic wage, delivery commission, pickup commission, other benefits and subsidies, etc. For each completed parcel order, Xiao Guo can usually get a commission of $10\\%$ of the shipping fee. Therefore, the more orders he completes and the faster he completes them, the higher his income will be.\n\nXiao Guo is responsible for all courier services on $2$ parallel streets in the city. On these $2$ parallel streets, there are $2$ courier stations. Each delivery route starts from one station, and after delivering all parcels, ends at the other station. To finish the task efficiently, Xiao Guo wants to use the shortest route to complete all deliveries.\n\nThat is, given the distance between the $2$ parallel streets, the positions of the $2$ stations, and the positions of all delivery points, Xiao Guo needs to compute the shortest route that starts from one station, delivers all parcels, and finally returns to the other station.\n\nThe street distance means the vertical distance between the $2$ parallel streets. If we set the $x$ axis parallel to the streets, and the leftmost positions on both streets have $x=0$, then any position on the $2$ streets can be represented by the straight-line distance from the leftmost end of the street to that position, i.e., the $x$ coordinate value of that position.\n\nFor example, suppose the street distance between streets A and B is $2$. The two stations $S_1$ and $S_2$ are located at street A, $x=1$, and street B, $x=3$, respectively. There are also $2$ delivery points $T_1$ and $T_2$ located at street A, $x=3$, and street B, $x=1$, respectively, as shown in the figure. Xiao Guo’s task is to start from station $S_1$, deliver the parcels at $T_1$ and $T_2$, and then return to the other station $S_2$.\n\nProgramming task: given the street distance of the $2$ parallel streets, the positions of the $2$ stations, and the positions of all delivery points, compute the shortest route that starts from one station, delivers all parcels, and ends at the other station.", "inputFormat": "The first line contains two positive integers $n,m$, $1 \\le n,m \\le 10000$, representing the number of positions on the two parallel streets A and B (including delivery points and station positions). The positions are numbered as A: $1,2,\\ldots,n$; B: $1,2,\\ldots,m$.\n\nThe second line contains four positive integers $a,b,c,d$, indicating that the two station positions are $(a,b)$ and $(c,d)$. $a=0$ or $c=0$ means the corresponding station is on street $A$, and $a=1$ or $c=1$ means the corresponding station is on street $B$. $b$ and $d$ represent the position indices of the stations on the corresponding streets. For example, $(a,b)=(0,3)$ means the first station is on street $A$, and its position is the $3$-rd among the given $n$ positions of street $A$.\n\nThe third line contains one real number $h$, representing the street distance between the $2$ parallel streets $(1 \\le h \\le 10)$.\n\nThe fourth line contains $n$ real numbers, representing the $x$ coordinates of the $n$ positions on street $A$ $(1 \\le x < 20000)$.\n\nThe fifth line contains $m$ real numbers, representing the $x$ coordinates of the $m$ positions on street $B$ $(1 \\le x < 20000)$.", "outputFormat": "Output the computed shortest route length, rounded to $2$ decimal places.", "hint": "For $10\\%$ of the testdata, $n,m\\le 8$.\n\nFor $30\\%$ of the testdata, $n,m\\le 100$.\n\nFor $50\\%$ of the testdata, $n,m\\le 1000$.\n\nFor $100\\%$ of the testdata, $n,m\\le 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2018] 邮递员问题", "background": "", "description": "$\\text{2010}$ 年以来，网购市场发展迅速，快递公司成为促成交易成功的关键环节。小郭是一名顺丰快递员，他的工资主要包括底薪、送货提成、收件提成、其他福利补贴等。小郭每完成一件客户的快递单，一般能拿到运费 $10\\%$ 的提成。因此小郭完成的快递单越多越快，他的收入就越高。小郭负责城市中 $2$ 个平行街道的所有快递业务。在这 $2$ 个平行街道上有 $2$ 处快递工作站。小郭每次投递的行程都是从一个工作站出发，完成所有快递单的投递后，回到另一个工作站。为了高效地完成投递任务，小郭希望用最短的行程来完成所有快递单的投递任务。也就是说，对于给定的 $2$ 个平行街道的街距和 $2$ 个工作站位置，以及所有投递点的位置，小郭要计算从一个工作站出发，完成所有快递单的投递后，回到另一个工作站的最短行程。街距是指 $2$ 个平行街道的之间的垂直距离。如果设平面坐标系的 $x$ 轴与街道平行，且 $2$ 个平行街道上的最左端位置的 $x$ 坐标均为 $0$，则 $2$ 个平行街道上的任何位置可以用从街道最左端到该位置的直线距离，即该位置的 $x$ 坐标值来表示。\n\n例如，设 $2$ 个平行街道 A 和 B 的街距是 $2$。$2$ 个工作站 $S_1$ ​​和 $S_2$​​ 的位置分别位于街道 A 的 $x=1$ 和街道 B 的 $x=3$ 处。另外有 $2$ 个投递点 $T_1$ 和 $T_2$​ 的位置分别位于街道 A 的 $x=3$ 和街道 B 的 $x=1$ 处，如图所示。小郭的任务就是要从工作站 $S_1$​​ 出发，完成在 $T_1$​​ 和 $T_2$​​ 处的快递单投递后，回到另一个工作站 $S_2$。\n\n编程任务：对于给定的 $2$ 个平行街道的街距和 $2$ 个工作站位置，以及所有投递点的位置，计算从一个工作站出发，完成所有快递单的投递后，回到另一个工作站的最短行程。", "inputFormat": "第 $1$ 行有 $2$ 个正整数 $n,m$，$1 \\le n,m \\le 10000$，分别表示 $2$ 个平行街道 A 和 B 上的位置数（包括投递点的位置和工作站的位置）。位置编号为 A：$1,2,\\ldots,n$；B：$1,2,\\ldots,m$。\n\n第 $2$ 行有 $4$ 个正整数 $a,b,c,d$，表示 $2$ 个工作站位置分别为 $(a,b)$ 和 $(c,d)$。$a=0$ 或 $c=0$ 表示相应的工作站在街道 $A$，$a=1$ 或 $c=1$ 表示相应的工作站在街道 $B$。$b$ 和 $d$ 分别表示工作站在相应的街道的位置号。例如，若 $(a,b)=(0,3)$ 表示第 $1$ 个工作站位于街道 $A$ 上，其位置位于给出的街道 $A$ 的 $n$ 个位置的第 $3$ 个位置。\n\n第 $3$ 行有 $1$ 个实数 $h$，表示 $2$ 个平行街道的街距 $(1 \\le h \\le 10)$。\n\n第 $4$ 行有 $n$ 个实数，表示街道 $A$ 上 $n$ 个位置的 $x$ 坐标 $(1 \\le x < 20000)$。\n\n第 $5$ 行有 $m$ 个实数，表示街道 $B$ 上 $m$ 个位置的 $x$ 坐标 $(1 \\le x < 20000)$。\n", "outputFormat": "输出计算出的最短行程，保留 $2$ 位小数。", "hint": "对于 $10\\%$ 的数据，$n,m\\le 8$；\n\n对于 $30\\%$ 的数据，$n,m\\le 100$；\n\n对于 $50\\%$ 的数据，$n,m\\le 1000$；\n\n对于 $100\\%$ 的数据，$n,m\\le 10000$。", "locale": "zh-CN"}}}
{"pid": "P4580", "type": "P", "difficulty": 5, "samples": [["6 10 3\n)(1*+0\n1 2\n1 3\n1 4\n2 3\n3 4\n2 5\n3 5\n3 6\n4 6\n5 6", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2014", "各省省选", "北京"], "title": "[BJOI2014] 路径", "background": "", "description": "在一个 $N$ 个节点的无向图（没有自环、重边）上，每个点都有一个符号，可能是数字，也可能是加号、减号、乘号、除号、小括号。你要在这个图上数一数，有多少种走恰好 $K$ 个节点的方法，使得路过的符号串起来能够得到一个算数表达式。路径的起点和终点可以任意选择。\n\n所谓算数表达式，就是由运算符连接起来的一系列数字。括号可以插入在表达式中以表明运算顺序。\n\n注意，你要处理各种情况，比如数字不能有多余的前导 $0$，减号只有前面没有运算符或数字的时候才可以当成负号，括号可以任意添加（但不能有空括号），$0$ 可以做除数（我们只考虑文法而不考虑语意），加号不能当正号。\n\n例如，下面的是合法的表达式：\n```\n-0/0\n((0)+(((2*3+4)+(-5)+7))+(-(2*3)*6))\n```\n而下面的不是合法的表达式：\n```\n001+0\n1+2(2)\n3+-3\n--1\n+1\n()\n```", "inputFormat": "第一行三个整数 $N,M,K$，表示点的数量，边的数量和走的节点数。\n\n第二行一个字符串，表示每个点的符号。\n\n接下来 $M$ 行，每行两个数，表示一条边连的两个点的编号。", "outputFormat": "输出一行一个整数，表示走的方法数。这个数可能比较大，你只需要输出它模 $10^9+7$ 的余数即可。", "hint": "$1 \\le N \\le 20，0 \\le M \\le\\frac{N×(N-1)}{2}，0\\le K\\le 30$\n\n![](https://cdn.luogu.com.cn/upload/pic/18714.png)\n\n一共有 $10$ 条路径，构成的表达式依次是 ``101, (1), 1+1, 1+0, 1*1, 1*0, 0+0, 0+1, 0*0, 0*1``。", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2014] Path", "background": "", "description": "On an undirected graph with $N$ nodes (no self-loops and no multiple edges), each node carries one symbol, which can be a digit or one of the symbols '+', '-', '*', '/', '(', ')'. Count how many walks that visit exactly $K$ nodes produce an arithmetic expression when the symbols encountered along the walk are concatenated. The start and end nodes can be chosen arbitrarily.\n\nAn arithmetic expression is a sequence of numbers connected by operators. Parentheses can be inserted into the expression to indicate the order of operations.\n\nNote that you must handle various cases:\n- Numbers must not have leading zeros unless the number is exactly $0$.\n- A minus sign can act as a unary negative sign only when there is neither an operator nor a digit immediately before it.\n- Parentheses can be added arbitrarily (but empty parentheses are not allowed).\n- $0$ can be used as a divisor (we consider only the grammar, not the semantics).\n- A plus sign cannot be used as a unary positive sign.\n\nFor example, the following are valid expressions:\n```\n-0/0\n((0)+(((2*3+4)+(-5)+7))+(-(2*3)*6))\n```\nThe following are not valid expressions:\n```\n001+0\n1+2(2)\n3+-3\n--1\n+1\n()\n```", "inputFormat": "The first line contains three integers $N, M, K$, denoting the number of nodes, the number of edges, and the number of nodes to visit.\n\nThe second line contains a string of length $N$, giving the symbol on each node.\n\nEach of the next $M$ lines contains two integers, denoting the indices of the two endpoints of an edge.", "outputFormat": "Output a single integer: the number of such walks. Since the answer can be large, output it modulo $10^9+7$.", "hint": "$1 \\le N \\le 20$, $0 \\le M \\le \\frac{N \\times (N - 1)}{2}$, $0 \\le K \\le 30$.\n\n![](https://cdn.luogu.com.cn/upload/pic/18714.png)\n\nThere are $10$ walks in total, forming the expressions ``101, (1), 1+1, 1+0, 1*1, 1*0, 0+0, 0+1, 0*0, 0*1``.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2014] 路径", "background": "", "description": "在一个 $N$ 个节点的无向图（没有自环、重边）上，每个点都有一个符号，可能是数字，也可能是加号、减号、乘号、除号、小括号。你要在这个图上数一数，有多少种走恰好 $K$ 个节点的方法，使得路过的符号串起来能够得到一个算数表达式。路径的起点和终点可以任意选择。\n\n所谓算数表达式，就是由运算符连接起来的一系列数字。括号可以插入在表达式中以表明运算顺序。\n\n注意，你要处理各种情况，比如数字不能有多余的前导 $0$，减号只有前面没有运算符或数字的时候才可以当成负号，括号可以任意添加（但不能有空括号），$0$ 可以做除数（我们只考虑文法而不考虑语意），加号不能当正号。\n\n例如，下面的是合法的表达式：\n```\n-0/0\n((0)+(((2*3+4)+(-5)+7))+(-(2*3)*6))\n```\n而下面的不是合法的表达式：\n```\n001+0\n1+2(2)\n3+-3\n--1\n+1\n()\n```", "inputFormat": "第一行三个整数 $N,M,K$，表示点的数量，边的数量和走的节点数。\n\n第二行一个字符串，表示每个点的符号。\n\n接下来 $M$ 行，每行两个数，表示一条边连的两个点的编号。", "outputFormat": "输出一行一个整数，表示走的方法数。这个数可能比较大，你只需要输出它模 $10^9+7$ 的余数即可。", "hint": "$1 \\le N \\le 20，0 \\le M \\le\\frac{N×(N-1)}{2}，0\\le K\\le 30$\n\n![](https://cdn.luogu.com.cn/upload/pic/18714.png)\n\n一共有 $10$ 条路径，构成的表达式依次是 ``101, (1), 1+1, 1+0, 1*1, 1*0, 0+0, 0+1, 0*0, 0*1``。", "locale": "zh-CN"}}}
{"pid": "P4581", "type": "P", "difficulty": 7, "samples": [["6 3\n1 2\n2 3\n4 5", "2\n2\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2014", "各省省选", "北京", "Special Judge"], "title": "[BJOI2014] 想法", "background": "", "description": "小强和阿米巴是好朋友。小强要出一套题目。\n\n他的题目以涉及面广（偏）、考察深入（怪）、思维强度大（难）著称。他为了出题，一共攒了 $M$ 个本质不同的想法，每个想法形成了一个题目。不过，他觉得拿这些题目去考察选手会把比赛搞的太过变态，所以，想请阿米巴来帮忙调整一下他的题目。\n\n阿米巴指出，为了让一场考试的题目的考察点尽量全面，有一个通用的做法叫做“组合”。如果把两个题目 $A$ 和 $B$ 组合在一起，那么组合而成的题目涉及到的想法的集合就是 $A$ 涉及到的想法的集合和 $B$ 涉及到的想法的集合的并。并且，题目是可以反复组合的。\n\n例如，小强现在有三个想法 $1,2,3$，分别对应了题目 $P_1,P_2,P_3$：\n\n- 小强把 $P_1$ 和 $P_2$ 组合得到 $P_4$。$P_4$ 涉及的想法的集合是 $\\{1,2\\}$。\n- 小强把 $P_2$ 和 $P_3$ 组合得到 $P_5$。$P_5$ 涉及的想法的集合是 $\\{2,3\\}$。\n- 小强把 $P_4$ 和 $P_5$ 组合得到 $P_6$。$P_6$ 涉及的想法的集合是 $\\{1,2,3\\}$。\n\n现在，小强告诉你每个题目都是如何组合而来的。你要回答的就是，每个题目涉及的想法的集合有多大。\n\n不过，这个问题是很难的。于是，你只需要能够以比较高的概率回答的比较准确即可。", "inputFormat": "\n第一行两个整数 $N,M$，依次表示小强的题目数量和想法的数量。   \n接下来 $N-M$ 行，每行两个整数，依次表示小强组合出来的题目都是由哪两个题组合而成的。   \n$M$ 个想法对应的题目依次编号为 $1$ 到 $M$。之后，小强组合来的第一个题编号为 $M+1$，组合出来的第二个题编号为 $M+2$，依次类推。\n", "outputFormat": "**本题使用 Special Judge。**  \n\n$N-M$ 行，每行一个整数表示小强组合出来的每个题都涉及了几个想法。\n", "hint": "对于 $100\\%$ 的数据，$1 \\le M \\le 10^5$，$1 \\le N \\le 10^6$。   \n如果其中你有 $95\\%$ 以上的行的答案和正确答案的误差不超过 $25\\%$，那么你就可以得到分数。   \n所谓误差不超过 $25\\%$，即如果正确答案是 $X$，那么你的答案在 $[0.8X,1.25X]$ 这个闭区间内就算误差不超过 $25\\%$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2014] Ideas", "background": "", "description": "Xiao Qiang and Amiba are good friends. Xiao Qiang wants to prepare a set of problems.\n\nHis problems are known for broad scope (biased), deep probing (quirky), and high difficulty (hard). To prepare problems, he has collected $M$ essentially different ideas, and each idea forms a problem. However, he feels that using these problems to test contestants would make the contest too extreme, so he asks Amiba to help adjust his problems.\n\nAmiba points out a general method called “combination” to make an exam’s coverage as comprehensive as possible. If two problems $A$ and $B$ are combined, then the set of ideas involved in the resulting problem is the union of the sets of ideas involved in $A$ and $B$. Moreover, problems can be combined repeatedly.\n\nFor example, suppose Xiao Qiang currently has three ideas $1, 2, 3$, corresponding to problems $P_1, P_2, P_3$ respectively:\n- Xiao Qiang combines $P_1$ and $P_2$ to get $P_4$. The set of ideas involved in $P_4$ is $\\{1, 2\\}$.\n- Xiao Qiang combines $P_2$ and $P_3$ to get $P_5$. The set of ideas involved in $P_5$ is $\\{2, 3\\}$.\n- Xiao Qiang combines $P_4$ and $P_5$ to get $P_6$. The set of ideas involved in $P_6$ is $\\{1, 2, 3\\}$.\n\nNow, Xiao Qiang tells you how each problem was formed by combination. Your task is to answer how large the set of ideas involved in each problem is.\n\nHowever, this problem is hard. So you only need to answer fairly accurately with a relatively high probability.", "inputFormat": "The first line contains two integers $N, M$, denoting the number of Xiao Qiang’s problems and the number of ideas, respectively.  \nThen follow $N - M$ lines, each containing two integers, indicating which two problems were combined to form each combined problem.  \nThe $M$ ideas correspond to problems numbered $1$ through $M$. After that, the first combined problem is numbered $M + 1$, the second combined problem is numbered $M + 2$, and so on.", "outputFormat": "**This problem uses Special Judge.**  \nOutput $N - M$ lines. Each line contains one integer, which is the number of ideas involved in each combined problem.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le M \\le 10^5$, $1 \\le N \\le 10^6$.  \nIf at least $95\\%$ of your lines have absolute error within $25\\%$ of the correct answers, you will receive points.  \n“Error within $25\\%$” means: if the correct answer is $X$, then your answer falling in the closed interval $[0.8X, 1.25X]$ counts as within $25\\%$ error.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2014] 想法", "background": "", "description": "小强和阿米巴是好朋友。小强要出一套题目。\n\n他的题目以涉及面广（偏）、考察深入（怪）、思维强度大（难）著称。他为了出题，一共攒了 $M$ 个本质不同的想法，每个想法形成了一个题目。不过，他觉得拿这些题目去考察选手会把比赛搞的太过变态，所以，想请阿米巴来帮忙调整一下他的题目。\n\n阿米巴指出，为了让一场考试的题目的考察点尽量全面，有一个通用的做法叫做“组合”。如果把两个题目 $A$ 和 $B$ 组合在一起，那么组合而成的题目涉及到的想法的集合就是 $A$ 涉及到的想法的集合和 $B$ 涉及到的想法的集合的并。并且，题目是可以反复组合的。\n\n例如，小强现在有三个想法 $1,2,3$，分别对应了题目 $P_1,P_2,P_3$：\n\n- 小强把 $P_1$ 和 $P_2$ 组合得到 $P_4$。$P_4$ 涉及的想法的集合是 $\\{1,2\\}$。\n- 小强把 $P_2$ 和 $P_3$ 组合得到 $P_5$。$P_5$ 涉及的想法的集合是 $\\{2,3\\}$。\n- 小强把 $P_4$ 和 $P_5$ 组合得到 $P_6$。$P_6$ 涉及的想法的集合是 $\\{1,2,3\\}$。\n\n现在，小强告诉你每个题目都是如何组合而来的。你要回答的就是，每个题目涉及的想法的集合有多大。\n\n不过，这个问题是很难的。于是，你只需要能够以比较高的概率回答的比较准确即可。", "inputFormat": "\n第一行两个整数 $N,M$，依次表示小强的题目数量和想法的数量。   \n接下来 $N-M$ 行，每行两个整数，依次表示小强组合出来的题目都是由哪两个题组合而成的。   \n$M$ 个想法对应的题目依次编号为 $1$ 到 $M$。之后，小强组合来的第一个题编号为 $M+1$，组合出来的第二个题编号为 $M+2$，依次类推。\n", "outputFormat": "**本题使用 Special Judge。**  \n\n$N-M$ 行，每行一个整数表示小强组合出来的每个题都涉及了几个想法。\n", "hint": "对于 $100\\%$ 的数据，$1 \\le M \\le 10^5$，$1 \\le N \\le 10^6$。   \n如果其中你有 $95\\%$ 以上的行的答案和正确答案的误差不超过 $25\\%$，那么你就可以得到分数。   \n所谓误差不超过 $25\\%$，即如果正确答案是 $X$，那么你的答案在 $[0.8X,1.25X]$ 这个闭区间内就算误差不超过 $25\\%$。", "locale": "zh-CN"}}}
{"pid": "P4582", "type": "P", "difficulty": 6, "samples": [["3\n2\n1 2\n3\n1 2\n2 3\n5\n1 2\n1 3\n2 4\n2 5", "Case 1: 1\nCase 2: 2\nCase 3: 6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2014", "各省省选", "福建"], "title": "[FJOI2014] 树的重心", "background": "", "description": "给定一个 $n$ 个点的树，每个点的编号从 $1 \\sim n$ ，问这个树有多少不同的连通子树，和这个树有相同的重心。\n\n其中 $n$ 个点的树指的是 $n$ 个点的最小连通图，显然 $n$ 个点的树有 $n-1$ 条边，去掉这 $n-1$ 条边中的任何一条，原图都不再联通，任意两个点之间由唯一一条路径相连。\n\n对于一个树，树的重心定义为：删掉某点 $i$ 后，若剩余 $k$ 个连通分量，那么定义 $d(i)$ 为这些连通分量中点的个数的最大值，所谓重心，就是使得 $d(i)$ 最小的点 $i$。\n\n基于以上定义，一个树的重心可能会有一个或者两个，题中所要求的联通子树，其重心编号和个数必须和原树的完全一样。\n\n找出给定的树中有多少联通的子树和这个树有相同的重心。输出答案 $\\bmod 10007$ 后的结果。", "inputFormat": "第 $1$ 行中给出正整数 $Q$，表示该组数据中有多少组测试样例。\n\n每组样例首先输入一个整数 $n$（$0 < n \\le 200$），表示该组样例中输入的树包含 $n$ 个点，之后 $n-1$ 行，每行输入两整数数 $x,y$（$1 \\le x,y \\le n$），表示编号为 $x$ 的点和编号为 $y$ 的点之间存在一条边，所有点的编号从 $1 \\sim n$。\n", "outputFormat": "首先输出样例编号，之后输出满足条件的子树的个数，由于这个数字较大，你只需要输出这个数字 $\\bmod\\ 10007$ 后的结果，详见输出示例，请严格按照输出实例中的格式输出。\n", "hint": "对于 $100 \\%$ 的数据，满足 $1 \\le Q \\le 50, 1 \\le n \\le 200$。", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2014] Tree Centroid", "background": "", "description": "Given a tree with $n$ vertices, labeled $1 \\sim n$, count how many distinct connected subtrees have the same centroid as the original tree.\n\nA tree on $n$ vertices is a minimally connected graph on $n$ vertices. It obviously has $n-1$ edges. If you remove any one of these $n-1$ edges, the original graph becomes disconnected. Between any two vertices there is a unique path.\n\nFor a tree, the centroid is defined as follows: after deleting a vertex $i$, if there are $k$ connected components left, define $d(i)$ to be the maximum number of vertices among these components. A centroid is a vertex $i$ that minimizes $d(i)$.\n\nBased on this definition, a tree may have one or two centroids. The connected subtrees required in this problem must have exactly the same centroid labels and the same number of centroids as the original tree.\n\nFind how many connected subtrees in the given tree have the same centroid as the original tree. Output the result $\\bmod 10007$.", "inputFormat": "The first line contains a positive integer $Q$, the number of test cases.\n\nFor each test case, first read an integer $n$ ($0 < n \\le 200$), the number of vertices in the tree. Then read $n-1$ lines, each containing two integers $x, y$ ($1 \\le x, y \\le n$), indicating that there is an edge between vertices $x$ and $y$. All vertices are labeled $1 \\sim n$.", "outputFormat": "First output the test case index, then output the number of connected subtrees that satisfy the condition. Since this number can be large, you only need to output this number $\\bmod\\ 10007$. See the output example and strictly follow its format.", "hint": "For $100\\%$ of the testdata, $1 \\le Q \\le 50$, $1 \\le n \\le 200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2014] 树的重心", "background": "", "description": "给定一个 $n$ 个点的树，每个点的编号从 $1 \\sim n$ ，问这个树有多少不同的连通子树，和这个树有相同的重心。\n\n其中 $n$ 个点的树指的是 $n$ 个点的最小连通图，显然 $n$ 个点的树有 $n-1$ 条边，去掉这 $n-1$ 条边中的任何一条，原图都不再联通，任意两个点之间由唯一一条路径相连。\n\n对于一个树，树的重心定义为：删掉某点 $i$ 后，若剩余 $k$ 个连通分量，那么定义 $d(i)$ 为这些连通分量中点的个数的最大值，所谓重心，就是使得 $d(i)$ 最小的点 $i$。\n\n基于以上定义，一个树的重心可能会有一个或者两个，题中所要求的联通子树，其重心编号和个数必须和原树的完全一样。\n\n找出给定的树中有多少联通的子树和这个树有相同的重心。输出答案 $\\bmod 10007$ 后的结果。", "inputFormat": "第 $1$ 行中给出正整数 $Q$，表示该组数据中有多少组测试样例。\n\n每组样例首先输入一个整数 $n$（$0 < n \\le 200$），表示该组样例中输入的树包含 $n$ 个点，之后 $n-1$ 行，每行输入两整数数 $x,y$（$1 \\le x,y \\le n$），表示编号为 $x$ 的点和编号为 $y$ 的点之间存在一条边，所有点的编号从 $1 \\sim n$。\n", "outputFormat": "首先输出样例编号，之后输出满足条件的子树的个数，由于这个数字较大，你只需要输出这个数字 $\\bmod\\ 10007$ 后的结果，详见输出示例，请严格按照输出实例中的格式输出。\n", "hint": "对于 $100 \\%$ 的数据，满足 $1 \\le Q \\le 50, 1 \\le n \\le 200$。", "locale": "zh-CN"}}}
{"pid": "P4583", "type": "P", "difficulty": 6, "samples": [["2\n5\n12345", "1\n9"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2015", "各省省选", "福建"], "title": "[FJOI2015] 世界树", "background": null, "description": "奥丁杀死巨人伊米尔后，从伊米尔的尸体上生长出来一株巨大的梣树，它是整个宇宙的核心，被称为世界之树，这个巨木的枝干构成了整个世界，它被神秘的奥术力量所守护。\n\n奥丁发现，世界树的每个节点至多有两棵子树，其蕴含的奥术力量是子树奥术力量的最大值 $+1$，如果一个节点没有子树，其奥术力量为 $1$，这些节点被称为“源”。\n\n世界树在悠长的岁月里形成了奇妙的魔法平衡，具体来说，它的左子树与右子树的奥术力量的差的绝对值不会超过 $1$。若一个节点只有一棵子树（不妨设为左子树），则右子树的奥术力量视为 $0$。\n\n现在奥丁想知道，在 $n$ 个节点的世界树中，最高和最低的两个“源”（即叶子节点）的深度差最大是多少？", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n以下 $T$ 行，每行一个整数 $n$ 表示世界树的节点数。", "outputFormat": "$T$ 行，每行一个整数表示任意两个“源”的奥术力量的差的最大值。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 10^{10000}$，$T\\leq 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2015] World Tree", "background": "", "description": "After Odin slew the giant Ymir, a gigantic ash tree grew from Ymir’s corpse. It became the core of the universe and is called the World Tree. The branches of this colossal tree form the entire world, guarded by mysterious arcane power.\n\nOdin discovered that each node of the World Tree has at most two subtrees. Its arcane power equals the maximum arcane power among its subtrees $+1$. If a node has no subtree, its arcane power is $1$; such nodes are called \"sources\".\n\nOver the long ages, the World Tree has formed a delicate magical balance: the absolute difference between the arcane powers of the left and right subtrees does not exceed $1$. If a node has only one subtree (say, the left subtree), then the arcane power of the right subtree is treated as $0$.\n\nNow Odin wants to know: in a World Tree with $n$ nodes, what is the maximum possible difference between the depths of the deepest and the shallowest two \"sources\" (i.e., leaf nodes)?", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nEach of the next $T$ lines contains an integer $n$, the number of nodes in the World Tree.", "outputFormat": "Output $T$ lines. Each line contains a single integer: the maximum possible difference between the depths of the deepest and the shallowest \"sources\".", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\leq n \\leq 10^{10000}$, $T \\leq 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2015] 世界树", "background": null, "description": "奥丁杀死巨人伊米尔后，从伊米尔的尸体上生长出来一株巨大的梣树，它是整个宇宙的核心，被称为世界之树，这个巨木的枝干构成了整个世界，它被神秘的奥术力量所守护。\n\n奥丁发现，世界树的每个节点至多有两棵子树，其蕴含的奥术力量是子树奥术力量的最大值 $+1$，如果一个节点没有子树，其奥术力量为 $1$，这些节点被称为“源”。\n\n世界树在悠长的岁月里形成了奇妙的魔法平衡，具体来说，它的左子树与右子树的奥术力量的差的绝对值不会超过 $1$。若一个节点只有一棵子树（不妨设为左子树），则右子树的奥术力量视为 $0$。\n\n现在奥丁想知道，在 $n$ 个节点的世界树中，最高和最低的两个“源”（即叶子节点）的深度差最大是多少？", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n以下 $T$ 行，每行一个整数 $n$ 表示世界树的节点数。", "outputFormat": "$T$ 行，每行一个整数表示任意两个“源”的奥术力量的差的最大值。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 10^{10000}$，$T\\leq 50$。", "locale": "zh-CN"}}}
{"pid": "P4584", "type": "P", "difficulty": 6, "samples": [["10 10 2\n3 4\nactaagacct\ngacctacctc\nata\ntact", "5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "各省省选", "福建"], "title": "[FJOI2015] 带子串包含约束LCS问题", "background": "", "description": "带有子串包含约束的最长公共子序列问题可以具体表述如下。\n \n给定2个长度分别为n和m的序列X和Y，以及一个子串包含约束集S。\n\nS中共有k个字符串$S=\\{S_1,S_2,…,S_k\\}$，其中字符串$S_i$的长度为$l_i$，1≤i≤k。带有子串包含约束的最长公共子序列问题就是要找出X和Y的包含约束集S中所有字符串为其子串的最长公共子序列。 \n\n例如，如果给定的序列X和Y分别为X=actaagacct, Y=gacctacctc，子串包含约束集S={ata, tact}，则子序列actacct是X和Y的一个无约束的最长公共子序列，而包含约束集S中所有字符串为其子串的一个最长公共子序列是atact 。 \n在本题中请特别关注子串与子序列的区别。字符串$T=t_1…t_n$的子串是一个形如$T$’$=t_1+i…t_m+i$的字符串，其中，0≤i，m+i≤n。例如，T=abcdefg，则bcd是T 的一个子串，而bce是T的一个子序列，但不是T 的子串。\n\n设计一个算法，找出给定序列X和Y带有子串包含约束S的最长公共子序列。 ", "inputFormat": "第1行中给出正整数n,m,k，m＜300, n＜300, k＜6。n和m分别表示给定序列X和Y的长度。k表示子串包含约束集S中共有k个字符串。\n\n第2行中有k个整数$l_i$，$0≤l_i≤300,1≤i≤k$，分别表示子串包含约束集S中k个字符串的长度。\n\n第3行和第4行分别给出序列X和Y 。\n\n接下来k行每行一个字符串$S_i$", "outputFormat": "将计算出的X和Y带子串包含约束S的最长公共子序列的长度输出。", "hint": "字符串仅包含大小写字母.", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2015] LCS with Substring Inclusion Constraints", "background": "", "description": "The longest common subsequence problem with substring inclusion constraints can be stated as follows.\n\nGiven two sequences $X$ and $Y$ of lengths $n$ and $m$, respectively, and a set $S$ of substring inclusion constraints.\n\nThere are $k$ strings in $S$, $S=\\{S_1,S_2,…,S_k\\}$, where the length of string $S_i$ is $l_i$, $1 \\le i \\le k$. The problem is to find a longest common subsequence of $X$ and $Y$ that contains every string in the constraint set $S$ as its substring.\n\nFor example, if the given sequences are $X = \\texttt{actaagacct}$ and $Y = \\texttt{gacctacctc}$, and the constraint set is $S=\\{\\texttt{ata}, \\texttt{tact}\\}$, then the subsequence actacct is an unconstrained LCS of $X$ and $Y$, while a longest common subsequence that contains all strings in $S$ as substrings is atact.\nIn this problem, please pay special attention to the difference between substring and subsequence. The substring of a string $T=t_1…t_n$ is a string of the form $T$’$=t_1+i…t_m+i$, where $0 \\le i$, $m+i \\le n$. For example, if $T=\\texttt{abcdefg}$, then bcd is a substring of $T$, while bce is a subsequence of $T$ but not a substring of $T$.\n\nDesign an algorithm to find a longest common subsequence of the given sequences $X$ and $Y$ that satisfies the substring inclusion constraints $S$.", "inputFormat": "- The first line contains positive integers $n$, $m$, $k$, with $m < 300$, $n < 300$, $k < 6$. Here $n$ and $m$ are the lengths of the given sequences $X$ and $Y$, respectively. The value $k$ is the number of strings in the constraint set $S$.\n- The second line contains $k$ integers $l_i$, with $0 \\le l_i \\le 300$, $1 \\le i \\le k$, which are the lengths of the $k$ strings in the constraint set $S$.\n- The third and fourth lines give the sequences $X$ and $Y$.\n- The next $k$ lines each contain one string $S_i$.", "outputFormat": "Output the length of a longest common subsequence of $X$ and $Y$ that satisfies the substring inclusion constraints $S$.", "hint": "The strings contain only uppercase and lowercase letters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2015] 带子串包含约束LCS问题", "background": "", "description": "带有子串包含约束的最长公共子序列问题可以具体表述如下。\n \n给定2个长度分别为n和m的序列X和Y，以及一个子串包含约束集S。\n\nS中共有k个字符串$S=\\{S_1,S_2,…,S_k\\}$，其中字符串$S_i$的长度为$l_i$，1≤i≤k。带有子串包含约束的最长公共子序列问题就是要找出X和Y的包含约束集S中所有字符串为其子串的最长公共子序列。 \n\n例如，如果给定的序列X和Y分别为X=actaagacct, Y=gacctacctc，子串包含约束集S={ata, tact}，则子序列actacct是X和Y的一个无约束的最长公共子序列，而包含约束集S中所有字符串为其子串的一个最长公共子序列是atact 。 \n在本题中请特别关注子串与子序列的区别。字符串$T=t_1…t_n$的子串是一个形如$T$’$=t_1+i…t_m+i$的字符串，其中，0≤i，m+i≤n。例如，T=abcdefg，则bcd是T 的一个子串，而bce是T的一个子序列，但不是T 的子串。\n\n设计一个算法，找出给定序列X和Y带有子串包含约束S的最长公共子序列。 ", "inputFormat": "第1行中给出正整数n,m,k，m＜300, n＜300, k＜6。n和m分别表示给定序列X和Y的长度。k表示子串包含约束集S中共有k个字符串。\n\n第2行中有k个整数$l_i$，$0≤l_i≤300,1≤i≤k$，分别表示子串包含约束集S中k个字符串的长度。\n\n第3行和第4行分别给出序列X和Y 。\n\n接下来k行每行一个字符串$S_i$", "outputFormat": "将计算出的X和Y带子串包含约束S的最长公共子序列的长度输出。", "hint": "字符串仅包含大小写字母.", "locale": "zh-CN"}}}
{"pid": "P4585", "type": "P", "difficulty": 6, "samples": [["4 6\n1 2 3 4\n1 1 4 1 0\n0 1 4\n0 1 3\n1 1 1 1 0\n1 1 1 1 1\n1 1 2 1 2", "5\n0\n2\n5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "线段树", "各省省选", "福建", "分治", "树套树", "可持久化", "线段树分治"], "title": "[FJOI2015] 火星商店问题", "background": null, "description": "火星上的一条商业街里按照商店的编号 $1 \\sim n$ ，依次排列着 $n$ 个商店。商店里出售的琳琅满目的商品中，每种商品都用一个非负整数 $\\text{val}$ 来标价。每个商店每天都有可能进一些新商品，其标价可能与已有商品相同。\n \n火星人在这条商业街购物时，通常会逛这条商业街某一段路上的所有商店，譬如说商店编号在区间 $[l,r]$ 中的商店，从中挑选一件自己最喜欢的商品。每个火星人对商品的喜好标准各不相同。  \n\n通常每个火星人都有一个自己的喜好密码 $x$。对每种标价为 $\\text{val}$ 的商品，喜好密码为 $x$ 的火星人对这种商品的喜好程度与 $\\text{val}$ 异或 $x$ 的值成正比。也就是说，$\\text{val xor }x$ 的值越大，他就越喜欢该商品。  \n\n每个火星人的购物卡在所有商店中只能购买最近 $d$ 天内（含当天）进货的商品。另外，每个商店都有一种特殊商品不受进货日期限制，每位火星人在任何时刻都可以选择该特殊商品。每个商店中每种商品都能保证供应，不存在商品缺货的问题。 \n\n对于给定的按时间顺序排列的事件，计算每个购物的火星人的在本次购物活动中最喜欢的商品，即输出 $\\text{val xor }x$ 的最大值。这里所说的按时间顺序排列的事件是指以下两种事件： \n\n`0 s v`，表示编号为 $s$ 的商店在当日新进一种标价为 $v$ 的商品。 \n\n`1 l r x d`，表示一位火星人当日在编号在 $[l,r]$ 的商店购买 $d$ 天内的商品，该火星人的喜好密码为 $x$。", "inputFormat": "第一行两个正整数 $n,m$，分别表示商店总数和事件总数。   \n第二行中有 $n$ 个整数，第 $i$ 个整数表示商店 $i$ 的特殊商品标价。 \n\n接下来的 $m$ 行，每行表示一个事件。每天的事件按照先事件 $0$，后事件 $1$ 的顺序排列。 \n\n**关于天的定义参考[这个帖子](https://www.luogu.com.cn/discuss/87100)**", "outputFormat": "对于每个事件 $1$，输出一行一个整数表示答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，所有输入的整数在 $[0,10^5]$ 范围内。", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2015] Mars Shop Problem", "background": "", "description": "On a commercial street on Mars, there are $n$ shops arranged in order by shop IDs $1 \\sim n$. Among the many goods sold in the shops, each item is priced with a non-negative integer $\\text{val}$. Each shop may bring in some new goods every day, and the price may be the same as existing goods.\n\nWhen Martians shop on this street, they usually visit all shops along a certain segment of the street, for example, the shops with IDs in the interval $[l,r]$, and choose their favorite item from them. Each Martian has different preferences.\n\nUsually, each Martian has a personal preference code $x$. For an item priced at $\\text{val}$, a Martian with preference code $x$ likes it in proportion to the value of $\\text{val xor }x$. That is, the larger $\\text{val xor }x$ is, the more they like the item.\n\nEach Martian’s shopping card can only be used to buy goods stocked within the most recent $d$ days (including the current day) across all shops. In addition, each shop has one special item that is not restricted by the stocking date, and each Martian can choose this special item at any time. The supply of every item in each shop is guaranteed; there is no out-of-stock issue.\n\nGiven events arranged in chronological order, for each shopping Martian, compute the item they like most in this shopping activity, i.e., output the maximum value of $\\text{val xor }x$. The events in chronological order refer to the following two types:\n\n`0 s v`, meaning that shop $s$ stocks a new item priced at $v$ on the current day.\n\n`1 l r x d`, meaning that a Martian shops on the current day in shops with IDs in $[l,r]$, buying items stocked within $d$ days, and this Martian’s preference code is $x$.", "inputFormat": "The first line contains two positive integers $n,m$, representing the total number of shops and the total number of events.\n\nThe second line contains $n$ integers; the $i$-th integer is the price of the special item in shop $i$.\n\nThe next $m$ lines each describe one event. The events of each day are arranged in the order that event type $0$ comes first, then event type $1$.", "outputFormat": "For each event of type $1$, output one line with one integer representing the answer.", "hint": "Constraints  \nFor $100\\%$ of the data, all input integers are in the range $[0,10^5]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2015] 火星商店问题", "background": null, "description": "火星上的一条商业街里按照商店的编号 $1 \\sim n$ ，依次排列着 $n$ 个商店。商店里出售的琳琅满目的商品中，每种商品都用一个非负整数 $\\text{val}$ 来标价。每个商店每天都有可能进一些新商品，其标价可能与已有商品相同。\n \n火星人在这条商业街购物时，通常会逛这条商业街某一段路上的所有商店，譬如说商店编号在区间 $[l,r]$ 中的商店，从中挑选一件自己最喜欢的商品。每个火星人对商品的喜好标准各不相同。  \n\n通常每个火星人都有一个自己的喜好密码 $x$。对每种标价为 $\\text{val}$ 的商品，喜好密码为 $x$ 的火星人对这种商品的喜好程度与 $\\text{val}$ 异或 $x$ 的值成正比。也就是说，$\\text{val xor }x$ 的值越大，他就越喜欢该商品。  \n\n每个火星人的购物卡在所有商店中只能购买最近 $d$ 天内（含当天）进货的商品。另外，每个商店都有一种特殊商品不受进货日期限制，每位火星人在任何时刻都可以选择该特殊商品。每个商店中每种商品都能保证供应，不存在商品缺货的问题。 \n\n对于给定的按时间顺序排列的事件，计算每个购物的火星人的在本次购物活动中最喜欢的商品，即输出 $\\text{val xor }x$ 的最大值。这里所说的按时间顺序排列的事件是指以下两种事件： \n\n`0 s v`，表示编号为 $s$ 的商店在当日新进一种标价为 $v$ 的商品。 \n\n`1 l r x d`，表示一位火星人当日在编号在 $[l,r]$ 的商店购买 $d$ 天内的商品，该火星人的喜好密码为 $x$。", "inputFormat": "第一行两个正整数 $n,m$，分别表示商店总数和事件总数。   \n第二行中有 $n$ 个整数，第 $i$ 个整数表示商店 $i$ 的特殊商品标价。 \n\n接下来的 $m$ 行，每行表示一个事件。每天的事件按照先事件 $0$，后事件 $1$ 的顺序排列。 \n\n**关于天的定义参考[这个帖子](https://www.luogu.com.cn/discuss/87100)**", "outputFormat": "对于每个事件 $1$，输出一行一个整数表示答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，所有输入的整数在 $[0,10^5]$ 范围内。", "locale": "zh-CN"}}}
{"pid": "P4586", "type": "P", "difficulty": 7, "samples": [["3 \n0.00 0.00 \n1.00 0.00 \n0.00 4.00 \n10 \n0.00 0.00 \n0.00 3.00 \n1.00 6.00 \n2.00 2.00 \n3.00 5.00 \n5.00 3.00 \n6.00 3.00 \n9.00 5.00 \n10.00 5.00 \n11.00 3.00 \n0", "0.50\n3.05"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "各省省选", "福建"], "title": "[FJOI2015] 最小覆盖双圆问题", "background": null, "description": "给定平面上 $n$ 个点 $(x_1,y_1),...,(x_n,y_n)$，找出2个半径相同的圆 $R_1$ 和 $R_2$，覆盖给定的 $n$ 个点，且半径最小。\n\n![](https://cdn.luogu.com.cn/upload/pic/18767.png)  \n\n设计一个算法，计算出所求最小覆盖双圆 $R_1$ 和 $R_2$ 的半径。", "inputFormat": "输入有多个测试实例。每个实例的第一行中给出正整数 $n$，表示平面上有 $n$ 个点。\n\n接下来的 $n$ 行中每行给出两个实数 $x, y$。\n\n最后一行有一个 $0$ 表示结束。", "outputFormat": "对于每组数据，输出最小的符合题意的圆的半径，保留两位小数。", "hint": "对于 $100\\%$ 的数据，$n \\leq 1000$，$|x_i|,|y_i| \\leq 10^5$，$T \\leq 10$。", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2015] Minimum Double-Circle Cover Problem", "background": "", "description": "Given $n$ points on the plane $(x_1, y_1), \\ldots, (x_n, y_n)$, find two circles $R_1$ and $R_2$ with the same radius that cover all the given $n$ points, and the radius is as small as possible.\n\n![](https://cdn.luogu.com.cn/upload/pic/18767.png)  \n\nDesign an algorithm to compute the minimal radius of the two covering circles $R_1$ and $R_2$.", "inputFormat": "The input contains multiple test cases.  \nFor each case, the first line contains a positive integer $n$ ($n < 1000$), indicating there are $n$ points on the plane.  \nEach of the next $n$ lines contains two real numbers $x$ and $y$, with $-100000 \\le x \\le 100000$ and $-100000 \\le y \\le 100000$.  \nThe input ends with a line containing a single $0$.", "outputFormat": "For each test case, output the minimal radius of a circle that satisfies the requirement, keeping two decimal places.", "hint": "For 100% of the testdata, $n \\le 1000$, $|x_i|, |y_i| \\le 100000$, and $T \\le 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2015] 最小覆盖双圆问题", "background": null, "description": "给定平面上 $n$ 个点 $(x_1,y_1),...,(x_n,y_n)$，找出2个半径相同的圆 $R_1$ 和 $R_2$，覆盖给定的 $n$ 个点，且半径最小。\n\n![](https://cdn.luogu.com.cn/upload/pic/18767.png)  \n\n设计一个算法，计算出所求最小覆盖双圆 $R_1$ 和 $R_2$ 的半径。", "inputFormat": "输入有多个测试实例。每个实例的第一行中给出正整数 $n$，表示平面上有 $n$ 个点。\n\n接下来的 $n$ 行中每行给出两个实数 $x, y$。\n\n最后一行有一个 $0$ 表示结束。", "outputFormat": "对于每组数据，输出最小的符合题意的圆的半径，保留两位小数。", "hint": "对于 $100\\%$ 的数据，$n \\leq 1000$，$|x_i|,|y_i| \\leq 10^5$，$T \\leq 10$。", "locale": "zh-CN"}}}
{"pid": "P4587", "type": "P", "difficulty": 6, "samples": [["5\n1 2 4 9 10\n5\n1 1\n1 2\n1 3\n1 4\n1 5", "2\n4\n8\n8\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "莫队", "各省省选", "福建", "树套树", "可持久化线段树", "ST 表", "离线处理"], "title": "[FJOI2016] 神秘数", "background": "", "description": "一个可重复数字集合 $S$ 的神秘数定义为最小的不能被 $S$ 的子集的和表示的正整数。例如 $S=\\{1,1,1,4,13\\}$，有：$1 = 1$，$2 = 1+1$，$3 = 1+1+1$，$4 = 4$，$5 = 4+1$，$6 = 4+1+1$，$7 = 4+1+1+1$。\n\n$8$ 无法表示为集合 $S$ 的子集的和，故集合 $S$ 的神秘数为 $8$。\n\n现给定长度为 $n$ 的**正整数**序列 $a$，$m$ 次询问，每次询问包含两个参数 $l,r$，你需要求出由 $a_l,a_{l+1},\\cdots,a_r$ 所组成的可重集合的神秘数。", "inputFormat": "第一行一个整数 $n$，表示数字个数。\n\n第二行 $n$ 个正整数，从 $1$ 编号。\n\n第三行一个整数 $m$，表示询问个数。", "outputFormat": "对于每个询问，输出一行对应的答案。", "hint": "对于 $100\\%$ 的数据点，$1\\le n,m\\le {10}^5$，$\\sum a\\le {10}^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2016] Mysterious Number", "background": "", "description": "The mysterious number of a multiset $S$ is defined as the smallest positive integer that cannot be represented as the sum of a submultiset of $S$. For example, with $S = \\{1,1,1,4,13\\}$, we have: $1 = 1$, $2 = 1+1$, $3 = 1+1+1$, $4 = 4$, $5 = 4+1$, $6 = 4+1+1$, $7 = 4+1+1+1$.\n\n$8$ cannot be represented as the sum of a submultiset of $S$, so the mysterious number of $S$ is $8$.\n\nYou are given a sequence $a$ of length $n$ consisting of positive integers, and $m$ queries. Each query contains two parameters $l, r$. You need to find the mysterious number of the multiset formed by $a_l, a_{l+1}, \\cdots, a_r$.", "inputFormat": "- The first line contains an integer $n$, the number of elements.\n- The second line contains $n$ positive integers $a_1, a_2, \\dots, a_n$, indexed from $1$.\n- The third line contains an integer $m$, the number of queries.\n- Each of the next $m$ lines contains two integers $l, r$.", "outputFormat": "For each query, output one line with the corresponding answer.", "hint": "For $100\\%$ of the testdata, $1 \\le n, m \\le 10^5$, $\\sum a_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2016] 神秘数", "background": "", "description": "一个可重复数字集合 $S$ 的神秘数定义为最小的不能被 $S$ 的子集的和表示的正整数。例如 $S=\\{1,1,1,4,13\\}$，有：$1 = 1$，$2 = 1+1$，$3 = 1+1+1$，$4 = 4$，$5 = 4+1$，$6 = 4+1+1$，$7 = 4+1+1+1$。\n\n$8$ 无法表示为集合 $S$ 的子集的和，故集合 $S$ 的神秘数为 $8$。\n\n现给定长度为 $n$ 的**正整数**序列 $a$，$m$ 次询问，每次询问包含两个参数 $l,r$，你需要求出由 $a_l,a_{l+1},\\cdots,a_r$ 所组成的可重集合的神秘数。", "inputFormat": "第一行一个整数 $n$，表示数字个数。\n\n第二行 $n$ 个正整数，从 $1$ 编号。\n\n第三行一个整数 $m$，表示询问个数。", "outputFormat": "对于每个询问，输出一行对应的答案。", "hint": "对于 $100\\%$ 的数据点，$1\\le n,m\\le {10}^5$，$\\sum a\\le {10}^9$。", "locale": "zh-CN"}}}
{"pid": "P4588", "type": "P", "difficulty": 4, "samples": [["1\n10 1000000000\n1 2\n2 1\n1 2\n1 10\n2 3\n2 4\n1 6\n1 7\n1 12\n2 7", "2\n1\n2\n20\n10\n1\n6\n42\n504\n84"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2018", "线段树", "各省省选", "天津"], "title": "[TJOI2018] 数学计算", "background": null, "description": "小豆现在有一个数 $x$，初始值为 $1$。小豆有 $Q$ 次操作，操作有两种类型：\n\n`1 m`：将 $x$ 变为 $x \\times m$，并输出 $x \\bmod M$\n\n`2 pos`：将 $x$ 变为 $x$ 除以第 $pos$ 次操作所乘的数（保证第 $pos$ 次操作一定为类型 1，对于每一个类型 1 的操作至多会被除一次），并输出 $x \\bmod M$。", "inputFormat": "一共有  $t$ 组输入。\n\n对于每一组输入，第一行是两个数字 $Q,M$。\n\n接下来 $Q$ 行，每一行为操作类型 $op$，操作编号或所乘的数字 $m$（保证所有的输入都是合法的）。", "outputFormat": "对于每一个操作，输出一行，包含操作执行后的 $x \\bmod M$ 的值。", "hint": "对于 $20\\%$ 的数据，$1 \\le Q \\le 500$。\n\n对于 $100\\%$ 的数据，$1 \\le Q \\le 10^5$，$t \\le 5,1 \\lt M \\le 10^9$，$0 < m \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2018] Mathematical Calculation", "background": "", "description": "Xiaodou now has a number $x$, initially $1$. There are $Q$ operations of two types:\n\n`1 m`: set $x$ to $x \\times m$, then output $x \\bmod M$.\n\n`2 pos`: set $x$ to $x$ divided by the number multiplied in the $pos$-th operation (it is guaranteed that the $pos$-th operation is of type 1, and each type 1 operation will be divided at most once), then output $x \\bmod M$.", "inputFormat": "There are $t$ test cases.\n\nFor each test case, the first line contains two integers $Q, M$.\n\nThe next $Q$ lines each contain an operation, formatted as either `1 m` or `2 pos` (all inputs are guaranteed to be valid).", "outputFormat": "For each operation, output one line containing the value of $x \\bmod M$ after executing the operation.", "hint": "For $20\\%$ of the testdata, $1 \\le Q \\le 500$.\n\nFor $100\\%$ of the testdata, $1 \\le Q \\le 10^5$, $t \\le 5$, $1 \\lt M \\le 10^9$, $0 < m \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2018] 数学计算", "background": null, "description": "小豆现在有一个数 $x$，初始值为 $1$。小豆有 $Q$ 次操作，操作有两种类型：\n\n`1 m`：将 $x$ 变为 $x \\times m$，并输出 $x \\bmod M$\n\n`2 pos`：将 $x$ 变为 $x$ 除以第 $pos$ 次操作所乘的数（保证第 $pos$ 次操作一定为类型 1，对于每一个类型 1 的操作至多会被除一次），并输出 $x \\bmod M$。", "inputFormat": "一共有  $t$ 组输入。\n\n对于每一组输入，第一行是两个数字 $Q,M$。\n\n接下来 $Q$ 行，每一行为操作类型 $op$，操作编号或所乘的数字 $m$（保证所有的输入都是合法的）。", "outputFormat": "对于每一个操作，输出一行，包含操作执行后的 $x \\bmod M$ 的值。", "hint": "对于 $20\\%$ 的数据，$1 \\le Q \\le 500$。\n\n对于 $100\\%$ 的数据，$1 \\le Q \\le 10^5$，$t \\le 5,1 \\lt M \\le 10^9$，$0 < m \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4589", "type": "P", "difficulty": 6, "samples": [["1 3\n1 0\n2 1 3\n3 0", "AK"], ["1 6\n1 2 2 3\n2 1 4\n3 1 4\n4 1 6\n5 0\n6 0", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2018", "二分", "各省省选", "二分图", "天津"], "title": "[TJOI2018] 智力竞赛", "background": "", "description": "小豆报名参加智力竞赛，他带上了 $n$ 个好朋友作为亲友团一块来参加比赛。比赛规则如下：\n\n一共有 $m$ 道题目，每个人都有 $1$ 次答题机会，每次答题为选择一道题目回答，在回答正确后，可以继续回答这个题目的后续题目，直到答错题目或者没有后续题目。\n\n每个问题都会有一个价值，比赛最后参赛选手获得的奖励价值等价于该选手和他的亲友团没有回答的问题中的最低价值。\n\n我们现在知道小豆和他的亲友团实力非常强，能够做出这次竞赛中的所有题目。\n\n小豆想知道在知道题目和后续题目的条件下，他最大能获得的价值是多少？", "inputFormat": "第一行有两个整数 $n,m$。（$n\\leq50,m\\leq500$）\n\n接下来 $m$ 行，第 $i+1$ 行表示编号为 $i$ 的题目的题目信息，格式形如 $v_i,k_i,a_{i,1},a_{i,2},...,a_{i,k_i}$，其中 $v_i$ 表示该题目的价值，$k_i$ 表示这个题目的后续题目个数，$a_{i,1},a_{i,2},...,a_{i,k_i}$ 表示 $k_i$ 个后续题目的编号。", "outputFormat": "如果全部题目都能答对，则输出 `AK`，否则输出小豆可以获得的最高奖励价值。", "hint": "对于 $10\\%$ 的数据，有 $1<n,m\\leq10$。\n\n对于 $20\\%$ 的数据，有 $1<n,m\\leq100$。\n\n对于 $100\\%$ 的数据，有 $1<n\\leq50,1<m\\leq500,v_i\\leq10^9,k_i,a_{i,j}\\leq m$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2018] Intelligence Contest", "background": "", "description": "Xiaodou signed up for an intelligence contest. He brought $n$ good friends as his cheering group to take part in the contest together. The rules are as follows.\n\nThere are $m$ problems in total. Each person has $1$ chance to answer questions. In each attempt, they choose one problem to answer. After answering correctly, they may continue to answer the subsequent problems of this problem, until they answer a problem incorrectly or there is no subsequent problem.\n\nEach problem has a value. At the end of the contest, the reward value that a participant gets is equal to the minimum value among the problems that were not answered by this participant and his cheering group.\n\nNow we know that Xiaodou and his cheering group are very strong and can solve all the problems in this contest.\n\nXiaodou wants to know, given the information about the problems and their subsequent problems, what is the maximum value he can obtain.", "inputFormat": "The first line contains two integers $n,m$. ($n\\leq50,m\\leq500$).\n\nThe next $m$ lines describe the problems. Line $i+1$ gives the information of problem $i$, in the form $v_i,k_i,a_{i,1},a_{i,2},...,a_{i,k_i}$, where $v_i$ is the value of this problem, $k_i$ is the number of subsequent problems of this problem, and $a_{i,1},a_{i,2},...,a_{i,k_i}$ are the indices of these $k_i$ subsequent problems.", "outputFormat": "If all problems can be answered correctly, output `AK`. Otherwise, output the maximum reward value that Xiaodou can obtain.", "hint": "For $10\\%$ of the testdata, $1<n,m\\leq10$.\n\nFor $20\\%$ of the testdata, $1<n,m\\leq100$.\n\nFor $100\\%$ of the testdata, $1<n\\leq50,1<m\\leq500,v_i\\leq10^9,k_i,a_{i,j}\\leq m$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2018] 智力竞赛", "background": "", "description": "小豆报名参加智力竞赛，他带上了 $n$ 个好朋友作为亲友团一块来参加比赛。比赛规则如下：\n\n一共有 $m$ 道题目，每个人都有 $1$ 次答题机会，每次答题为选择一道题目回答，在回答正确后，可以继续回答这个题目的后续题目，直到答错题目或者没有后续题目。\n\n每个问题都会有一个价值，比赛最后参赛选手获得的奖励价值等价于该选手和他的亲友团没有回答的问题中的最低价值。\n\n我们现在知道小豆和他的亲友团实力非常强，能够做出这次竞赛中的所有题目。\n\n小豆想知道在知道题目和后续题目的条件下，他最大能获得的价值是多少？", "inputFormat": "第一行有两个整数 $n,m$。（$n\\leq50,m\\leq500$）\n\n接下来 $m$ 行，第 $i+1$ 行表示编号为 $i$ 的题目的题目信息，格式形如 $v_i,k_i,a_{i,1},a_{i,2},...,a_{i,k_i}$，其中 $v_i$ 表示该题目的价值，$k_i$ 表示这个题目的后续题目个数，$a_{i,1},a_{i,2},...,a_{i,k_i}$ 表示 $k_i$ 个后续题目的编号。", "outputFormat": "如果全部题目都能答对，则输出 `AK`，否则输出小豆可以获得的最高奖励价值。", "hint": "对于 $10\\%$ 的数据，有 $1<n,m\\leq10$。\n\n对于 $20\\%$ 的数据，有 $1<n,m\\leq100$。\n\n对于 $100\\%$ 的数据，有 $1<n\\leq50,1<m\\leq500,v_i\\leq10^9,k_i,a_{i,j}\\leq m$。", "locale": "zh-CN"}}}
{"pid": "P4590", "type": "P", "difficulty": 6, "samples": [["3 2\nNO", "1\n19\n6"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["字符串", "递推", "2018", "各省省选", "枚举", "有限状态自动机", "天津", "DP 套 DP"], "title": "[TJOI2018] 游园会", "background": null, "description": "小豆参加了 NOI 的游园会，会场上每完成一个项目就会获得一个奖章，奖章只会是 $\\texttt{N}$、$\\texttt{O}$、$\\texttt{I}$ 的字样。在会场上他收集到了 $K$ 个奖章组成的串。兑奖规则是奖章串和兑奖串的最长公共子序列长度为小豆最后奖励的等级。现在已知兑奖串长度为 $N$，并且在兑奖串上不会出现连续三个奖章为 $\\texttt{NOI}$，即奖章中不会出现子串 $\\texttt{NOI}$。现在小豆想知道各个奖励等级会对应多少个不同的合法兑奖串。", "inputFormat": "第一行两个数，$N, K$ 分别代表兑奖串的长度，小豆收集的奖章串的长度（$N\\leq1000,K\\leq15$）。\n\n第二行一共 $K$ 个字符，表示小豆得到的奖章串。", "outputFormat": "一共 $K+1$ 行，第 $i$ 行表示小豆最后奖励等级为 $i-1$ 的不同的合法兑奖串的个数，可能这个数会很大，结果对 $10^9+7$ 取模。", "hint": "### 样例解释\n\n最长公共子序列长度为 $0$ 的串有：$\\texttt{III}$;\n\n最长公共子序列长度为 $2$ 的串有：$\\texttt{NON}$、$\\texttt{NNO}$、$\\texttt{NOO}$、$\\texttt{ONO}$、$\\texttt{INO}$、$\\texttt{NIO}$；\n\n除去 $\\texttt{NOI}$，余下的 $19 = 26-6-1$ 种为最长公共子序列长度为 $1$。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据，$N\\leq10,K\\leq10$；\n- 对于 $30\\%$ 的数据，$N\\leq100,K\\leq4$；\n- 对于 $100\\%$ 的数据，$N\\leq1000,K\\leq15$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2018] Funfair", "background": "", "description": "Xiaodou participated in the NOI funfair. At the venue, each time he completes an activity he receives a medal, and each medal is labeled only with $\\texttt{N}$, $\\texttt{O}$, or $\\texttt{I}$. At the venue he collected a string consisting of $K$ medals. The redemption rule is that the length of the longest common subsequence between the medal string and a redemption string is Xiaodou’s final reward level. It is known that the redemption string has length $N$, and the substring $\\texttt{NOI}$ never appears in the redemption string, i.e., there is no occurrence of $\\texttt{NOI}$. Now Xiaodou wants to know, for each reward level, how many different valid redemption strings correspond to it.", "inputFormat": "The first line contains two integers, $N, K$, representing the length of the redemption string and the length of the medal string Xiaodou collected ($N\\leq1000,K\\leq15$).\n\nThe second line contains $K$ characters, representing the medal string Xiaodou obtained.", "outputFormat": "Output $K+1$ lines. The $i$-th line is the number of different valid redemption strings for which Xiaodou’s final reward level is $i-1$. This number can be large; output the result modulo $10^9+7$.", "hint": "Sample explanation:\n\nStrings whose longest common subsequence length is $0$: $\\texttt{III}$.\n\nStrings whose longest common subsequence length is $2$: $\\texttt{NON}$, $\\texttt{NNO}$, $\\texttt{NOO}$, $\\texttt{ONO}$, $\\texttt{INO}$, $\\texttt{NIO}$.\n\nExcluding $\\texttt{NOI}$, the remaining $19 = 26-6-1$ kinds have a longest common subsequence length of $1$.\n\nConstraints\n\n- For $10\\%$ of the testdata, $N\\leq10,K\\leq10$.\n- For $30\\%$ of the testdata, $N\\leq100,K\\leq4$.\n- For $100\\%$ of the testdata, $N\\leq1000,K\\leq15$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2018] 游园会", "background": null, "description": "小豆参加了 NOI 的游园会，会场上每完成一个项目就会获得一个奖章，奖章只会是 $\\texttt{N}$、$\\texttt{O}$、$\\texttt{I}$ 的字样。在会场上他收集到了 $K$ 个奖章组成的串。兑奖规则是奖章串和兑奖串的最长公共子序列长度为小豆最后奖励的等级。现在已知兑奖串长度为 $N$，并且在兑奖串上不会出现连续三个奖章为 $\\texttt{NOI}$，即奖章中不会出现子串 $\\texttt{NOI}$。现在小豆想知道各个奖励等级会对应多少个不同的合法兑奖串。", "inputFormat": "第一行两个数，$N, K$ 分别代表兑奖串的长度，小豆收集的奖章串的长度（$N\\leq1000,K\\leq15$）。\n\n第二行一共 $K$ 个字符，表示小豆得到的奖章串。", "outputFormat": "一共 $K+1$ 行，第 $i$ 行表示小豆最后奖励等级为 $i-1$ 的不同的合法兑奖串的个数，可能这个数会很大，结果对 $10^9+7$ 取模。", "hint": "### 样例解释\n\n最长公共子序列长度为 $0$ 的串有：$\\texttt{III}$;\n\n最长公共子序列长度为 $2$ 的串有：$\\texttt{NON}$、$\\texttt{NNO}$、$\\texttt{NOO}$、$\\texttt{ONO}$、$\\texttt{INO}$、$\\texttt{NIO}$；\n\n除去 $\\texttt{NOI}$，余下的 $19 = 26-6-1$ 种为最长公共子序列长度为 $1$。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据，$N\\leq10,K\\leq10$；\n- 对于 $30\\%$ 的数据，$N\\leq100,K\\leq4$；\n- 对于 $100\\%$ 的数据，$N\\leq1000,K\\leq15$。", "locale": "zh-CN"}}}
{"pid": "P4591", "type": "P", "difficulty": 6, "samples": [["2\nABC\n2 A AB\n2 C BC", "2"], ["2\nAAA\n2 A AA\n2 A AA", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2018", "各省省选", "天津"], "title": "[TJOI2018] 碱基序列", "background": "", "description": "小豆参加了生物实验室。在实验室里，他主要研究蛋白质。他现在研究的蛋白质是由 $k$ 个氨基酸按一定顺序构成的。每一个氨基酸都可能有 $a$ 种碱基序列 $s_{i,j}$ 构成。\n\n现在小豆有一个碱基串 $s$，小豆想知道在这个碱基上都多少种不同的组合方式可能得到这个蛋白质。即求由 $k$ 段字符串有序合并成的字符串 $s_1$，有多少种不同方式能够匹配字符串 $s$，其中 $k$ 段字符串的选法不同，或者与 $s$ 匹配上的位置不同认为是不同的方式。", "inputFormat": "\n第一行一个数，表示这个蛋白质由 $k$ 个氨基酸组成。\n\n第二行一个字符串 $s$，表示小豆现在有的碱基串。\n\n第三行开始接下来 $k$ 行表示第 $i$ 个氨基酸可能的碱基序列，对于第 $i$ 个氨基酸，$a_i$ 表示这个氨基酸可能的碱基序列种数，接下来 $a_i$ 个字符串表示这 $a_i$ 种可能的碱基序列，用空格隔开。\n", "outputFormat": "输出一个数目标是不同的方案数（不同的方案数是指不同的子碱基串或者相同的碱基串不同的氨基酸排列方式）。\n\n答案对 $10^9+7$ 取模。", "hint": "### 样例 1 解释\n\n- 第一个选 $\\tt A$ 第二个选 $\\tt C$，得到 $\\tt AC$ 能够与 $\\tt ABC$ 产生 $0$ 种匹配方式；\n- 第一个选 $\\tt A$ 第二个选 $\\tt BC$，得到 $\\tt ABC$ 能够与 $\\tt ABC$ 产生 $1$ 种匹配方式；\n- 第一个选 $\\tt AB$ 第二个选 $\\tt C$，得到 $\\tt ABC$ 能够与 $\\tt ABC$ 产生 $1$ 种匹配方式；\n- 第一个选 $\\tt AB$ 第二个选 $\\tt BC$，得到 $\\tt ABBC$ 能够与 $\\tt ABC$ 产生 $0$ 种匹配方式。\n\n所以一共 $2$ 种。\n\n### 样例 2 解释\n\n- 第一个选 $\\tt A$ 第二个选 $\\tt A$，得到 $\\tt AA$ 能够与 $\\tt AAA$ 产生 $2$ 种匹配方式；\n- 第一个选 $\\tt A$ 第二个选 $\\tt AA$，得到 $\\tt AAA$ 能够与 $\\tt AAA$ 产生 $1$ 种匹配方式；\n- 第一个选 $\\tt AA$ 第二个选 $\\tt A$，得到 $\\tt AAA$ 能够与 $\\tt AAA$ 产生 $1$ 种匹配方式；\n- 第一个选 $\\tt AA$ 第二个选 $\\tt AA$,得到 $\\tt AAAA$ 能够与 $\\tt AAA$ 产生 $0$ 种匹配方式。\n\n所以一共 $4$ 种。\n\n### 数据范围及约定\n\n- 对于 $30\\%$ 的数据，$1\\leq k\\leq 25$，$1\\le |s|\\leq 10000$，$1\\le a_i\\leq 3$。\n- 对于 $100\\%$ 的数据，$1\\leq k\\leq100$，$1\\le |s|\\leq 10000$，$1\\le a_i \\leq10$。碱基序列的长度均不超过 $15$。字符集为大写字母。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2018] Base Sequence", "background": "", "description": "Xiaodou joined a biology laboratory. In the lab, he mainly studies proteins. The protein he is currently studying consists of $k$ amino acids in a fixed order. For each amino acid $i$, there are $a_i$ possible base sequences $s_{i,j}$.\n\nNow Xiaodou has a base string $s$, and he wants to know how many different combinations could produce this protein on this base string. That is, consider the string $s_1$ obtained by concatenating $k$ string segments in order, where for the $i$-th segment you choose one sequence from its $a_i$ options. Count how many different ways $s_1$ can match the string $s$ as a contiguous substring. Two ways are considered different if either the choices for the $k$ segments differ, or the matched positions in $s$ differ.", "inputFormat": "- The first line contains an integer indicating that the protein consists of $k$ amino acids.\n- The second line contains a string $s$, which is the current base string.\n- The next $k$ lines describe the possible base sequences for the $i$-th amino acid. For the $i$-th amino acid, the line starts with $a_i$, the number of possible base sequences, followed by $a_i$ strings representing these possible base sequences, separated by spaces.", "outputFormat": "Output a single integer: the number of different ways (either different substrings of $s$, or for the same substring, different choices of sequences for the amino acids). The answer is taken modulo $10^9+7$.", "hint": "### Sample 1 Explanation\n\n- First choose $\\tt A$, second choose $\\tt C$, obtaining $\\tt AC$, which matches $\\tt ABC$ in $0$ ways.\n- First choose $\\tt A$, second choose $\\tt BC$, obtaining $\\tt ABC$, which matches $\\tt ABC$ in $1$ way.\n- First choose $\\tt AB$, second choose $\\tt C$, obtaining $\\tt ABC$, which matches $\\tt ABC$ in $1$ way.\n- First choose $\\tt AB$, second choose $\\tt BC$, obtaining $\\tt ABBC$, which matches $\\tt ABC$ in $0$ ways.\n\nTherefore there are $2$ ways in total.\n\n### Sample 2 Explanation\n\n- First choose $\\tt A$, second choose $\\tt A$, obtaining $\\tt AA$, which matches $\\tt AAA$ in $2$ ways.\n- First choose $\\tt A$, second choose $\\tt AA$, obtaining $\\tt AAA$, which matches $\\tt AAA$ in $1$ way.\n- First choose $\\tt AA$, second choose $\\tt A$, obtaining $\\tt AAA$, which matches $\\tt AAA$ in $1$ way.\n- First choose $\\tt AA$, second choose $\\tt AA$, obtaining $\\tt AAAA$, which matches $\\tt AAA$ in $0$ ways.\n\nTherefore there are $4$ ways in total.\n\n### Constraints\n\n- For $30\\%$ of the testdata, $1 \\le k \\le 25$, $1 \\le |s| \\le 10000$, $1 \\le a_i \\le 3$.\n- For $100\\%$ of the testdata, $1 \\le k \\le 100$, $1 \\le |s| \\le 10000$, $1 \\le a_i \\le 10$. The length of each base sequence does not exceed $15$. The character set consists of uppercase letters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2018] 碱基序列", "background": "", "description": "小豆参加了生物实验室。在实验室里，他主要研究蛋白质。他现在研究的蛋白质是由 $k$ 个氨基酸按一定顺序构成的。每一个氨基酸都可能有 $a$ 种碱基序列 $s_{i,j}$ 构成。\n\n现在小豆有一个碱基串 $s$，小豆想知道在这个碱基上都多少种不同的组合方式可能得到这个蛋白质。即求由 $k$ 段字符串有序合并成的字符串 $s_1$，有多少种不同方式能够匹配字符串 $s$，其中 $k$ 段字符串的选法不同，或者与 $s$ 匹配上的位置不同认为是不同的方式。", "inputFormat": "\n第一行一个数，表示这个蛋白质由 $k$ 个氨基酸组成。\n\n第二行一个字符串 $s$，表示小豆现在有的碱基串。\n\n第三行开始接下来 $k$ 行表示第 $i$ 个氨基酸可能的碱基序列，对于第 $i$ 个氨基酸，$a_i$ 表示这个氨基酸可能的碱基序列种数，接下来 $a_i$ 个字符串表示这 $a_i$ 种可能的碱基序列，用空格隔开。\n", "outputFormat": "输出一个数目标是不同的方案数（不同的方案数是指不同的子碱基串或者相同的碱基串不同的氨基酸排列方式）。\n\n答案对 $10^9+7$ 取模。", "hint": "### 样例 1 解释\n\n- 第一个选 $\\tt A$ 第二个选 $\\tt C$，得到 $\\tt AC$ 能够与 $\\tt ABC$ 产生 $0$ 种匹配方式；\n- 第一个选 $\\tt A$ 第二个选 $\\tt BC$，得到 $\\tt ABC$ 能够与 $\\tt ABC$ 产生 $1$ 种匹配方式；\n- 第一个选 $\\tt AB$ 第二个选 $\\tt C$，得到 $\\tt ABC$ 能够与 $\\tt ABC$ 产生 $1$ 种匹配方式；\n- 第一个选 $\\tt AB$ 第二个选 $\\tt BC$，得到 $\\tt ABBC$ 能够与 $\\tt ABC$ 产生 $0$ 种匹配方式。\n\n所以一共 $2$ 种。\n\n### 样例 2 解释\n\n- 第一个选 $\\tt A$ 第二个选 $\\tt A$，得到 $\\tt AA$ 能够与 $\\tt AAA$ 产生 $2$ 种匹配方式；\n- 第一个选 $\\tt A$ 第二个选 $\\tt AA$，得到 $\\tt AAA$ 能够与 $\\tt AAA$ 产生 $1$ 种匹配方式；\n- 第一个选 $\\tt AA$ 第二个选 $\\tt A$，得到 $\\tt AAA$ 能够与 $\\tt AAA$ 产生 $1$ 种匹配方式；\n- 第一个选 $\\tt AA$ 第二个选 $\\tt AA$,得到 $\\tt AAAA$ 能够与 $\\tt AAA$ 产生 $0$ 种匹配方式。\n\n所以一共 $4$ 种。\n\n### 数据范围及约定\n\n- 对于 $30\\%$ 的数据，$1\\leq k\\leq 25$，$1\\le |s|\\leq 10000$，$1\\le a_i\\leq 3$。\n- 对于 $100\\%$ 的数据，$1\\leq k\\leq100$，$1\\le |s|\\leq 10000$，$1\\le a_i \\leq10$。碱基序列的长度均不超过 $15$。字符集为大写字母。", "locale": "zh-CN"}}}
{"pid": "P4592", "type": "P", "difficulty": 6, "samples": [["7 5\n1 3 5 7 9 2 4\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n1 3 5\n2 4 6 3\n1 5 5\n2 5 7 2\n1 1 9", "7\n6\n12\n11\n14"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["贪心", "2018", "各省省选", "可持久化", "进制", "字典树 Trie", "天津"], "title": "[TJOI2018] 异或", "background": "", "description": "现在有一颗以 $1$ 为根节点的由 $n$ 个节点组成的树，节点从 $1$ 至 $n$ 编号。树上每个节点上都有一个权值 $v_i$。现在有 $q$ 次操作，操作如下：\n\n- $1~x~z$：查询节点 $x$ 的子树中的节点权值与 $z$ 异或结果的最大值。\n- $2~x~y~z$：查询节点 $x$ 到节点 $y$ 的简单路径上的节点的权值与 $z$ 异或结果最大值。", "inputFormat": "输入的第一行是两个整数，分别代表结点个数 $n$ 和询问个数 $q$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示点 $i$ 的的权值 $v_i$。\n\n接下来 $n-1$ 行，每行有两个整数 $u, v$，表示存在一条连结 $u$ 和 $v$ 的边。\n\n接下来 $q$ 行，每行首先有一个整数 $op$，代表操作类型。\n\n- 若 $op = 1$，则一个空格后有两个整数 $x, z$，代表查询节点 $x$ 的子树中的节点权值与 $z$ 异或结果的最大值。\n- 若 $op = 2$，则一个空格后有三个整数 $x, y, z$，代表查询节点 $x$ 到节点 $y$ 的简单路径上的节点的权值与 $z$ 异或结果最大值。", "outputFormat": "对于每一个查询，输出一行一个整数代表答案。", "hint": "#### 数据规模与约定\n\n\n- 对于 $10\\%$ 的数据，保证 $n, q \\leq 10^2$；\n- 对于 $20\\%$ 的数据，保证 $n, q \\leq 10^3$；\n- 对于 $40\\%$ 的数据，保证 $n, q \\leq 10^4$；\n- 对于 $100\\%$ 的数据，保证 $2\\leq n, q \\leq10^5$，$1 \\leq u, v, x, y \\leq n$，$1 \\leq op \\leq 2$，$1 \\leq v_i, z \\lt 2^{30}$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2018] XOR", "background": "", "description": "There is a tree with $n$ nodes, rooted at $1$, with nodes numbered from $1$ to $n$. Each node $i$ has a value $v_i$. There are $q$ operations as follows:\n\n- $1~x~z$: Query the maximum value of $v \\oplus z$ among nodes in the subtree of node $x$.\n- $2~x~y~z$: Query the maximum value of $v \\oplus z$ among nodes on the simple path from node $x$ to node $y$.", "inputFormat": "The first line contains two integers $n$ and $q$, representing the number of nodes and the number of queries.\n\nThe second line contains $n$ integers, where the $i$-th integer is the value $v_i$ of node $i$.\n\nEach of the next $n-1$ lines contains two integers $u, v$, indicating that there is an edge connecting $u$ and $v$.\n\nEach of the next $q$ lines starts with an integer $op$, indicating the type of operation.\n\n- If $op = 1$, then it is followed by two integers $x, z$, representing a query for the maximum value of $v \\oplus z$ among nodes in the subtree of node $x$.\n- If $op = 2$, then it is followed by three integers $x, y, z$, representing a query for the maximum value of $v \\oplus z$ among nodes on the simple path from node $x$ to node $y$.", "outputFormat": "For each query, output a single integer on one line representing the answer.", "hint": "Constraints\n\n- For $10\\%$ of the testdata, $n, q \\leq 10^2$.\n- For $20\\%$ of the testdata, $n, q \\leq 10^3$.\n- For $40\\%$ of the testdata, $n, q \\leq 10^4$.\n- For $100\\%$ of the testdata, $2 \\leq n, q \\leq 10^5$, $1 \\leq u, v, x, y \\leq n$, $1 \\leq op \\leq 2$, $1 \\leq v_i, z \\lt 2^{30}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2018] 异或", "background": "", "description": "现在有一颗以 $1$ 为根节点的由 $n$ 个节点组成的树，节点从 $1$ 至 $n$ 编号。树上每个节点上都有一个权值 $v_i$。现在有 $q$ 次操作，操作如下：\n\n- $1~x~z$：查询节点 $x$ 的子树中的节点权值与 $z$ 异或结果的最大值。\n- $2~x~y~z$：查询节点 $x$ 到节点 $y$ 的简单路径上的节点的权值与 $z$ 异或结果最大值。", "inputFormat": "输入的第一行是两个整数，分别代表结点个数 $n$ 和询问个数 $q$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示点 $i$ 的的权值 $v_i$。\n\n接下来 $n-1$ 行，每行有两个整数 $u, v$，表示存在一条连结 $u$ 和 $v$ 的边。\n\n接下来 $q$ 行，每行首先有一个整数 $op$，代表操作类型。\n\n- 若 $op = 1$，则一个空格后有两个整数 $x, z$，代表查询节点 $x$ 的子树中的节点权值与 $z$ 异或结果的最大值。\n- 若 $op = 2$，则一个空格后有三个整数 $x, y, z$，代表查询节点 $x$ 到节点 $y$ 的简单路径上的节点的权值与 $z$ 异或结果最大值。", "outputFormat": "对于每一个查询，输出一行一个整数代表答案。", "hint": "#### 数据规模与约定\n\n\n- 对于 $10\\%$ 的数据，保证 $n, q \\leq 10^2$；\n- 对于 $20\\%$ 的数据，保证 $n, q \\leq 10^3$；\n- 对于 $40\\%$ 的数据，保证 $n, q \\leq 10^4$；\n- 对于 $100\\%$ 的数据，保证 $2\\leq n, q \\leq10^5$，$1 \\leq u, v, x, y \\leq n$，$1 \\leq op \\leq 2$，$1 \\leq v_i, z \\lt 2^{30}$。", "locale": "zh-CN"}}}
{"pid": "P4593", "type": "P", "difficulty": 6, "samples": [["2\n10 1\n5\n4 2\n1\n2", "415\n135"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "递推", "2018", "各省省选", "天津", "差分"], "title": "[TJOI2018] 教科书般的亵渎", "background": null, "description": "小豆喜欢玩游戏，现在他在玩一个游戏遇到这样的场面，每个怪的血量为 $a_i$，且每个怪物血量均不相同，小豆手里有无限张“亵渎”。亵渎的效果是对所有的怪造成 $1$ 点伤害，如果有怪死亡，则再次施放该法术。我们认为血量为 $0$ 怪物死亡。\n\n小豆使用一张“亵渎”会获得一定的分数，分数计算如下，在使用一张“亵渎”之后，每一个被“亵渎”造成伤害的怪会令小豆获得 $x^k$ 的分数，其中 $x$ 是造成伤害前怪的血量为 $x$ 和需要杀死所有怪物所需的“亵渎”的张数 $k$ 。**注意：因怪死亡而重复释放的“亵渎”不计入 $k$ ,也不会使小豆的分数增加。**", "inputFormat": "第一行输入一个 $T$（$T\\leq10$），表示有多少组测试数据。\n\n每组测试数据第一行为 $n$，$m$，表示有当前怪物最高的血量 $n$，和 $m$ 种没有出现的血量。\n\n接下来 $m$ 行，每行 $1$ 个数 $a_i$，表示场上没有血量为 $a_i$ 的怪物。", "outputFormat": "一共 $T$ 行，每行一个数，第 $i$ 行表示第 $i$ 组测试数据中小豆的最后可以获得的分数，因为这个分数会很大需要模 $10^9+7$。", "hint": "- 对于 $10\\%$ 的数据，有 $m=0$；\n- 对于 $20\\%$ 的数据，有 $m\\leq1$；\n- 对于 $30\\%$ 的数据，有 $m\\leq2$\n- 对于 $40\\%$ 的数据，有 $m\\leq3$；\n- 对于 $50\\%$ 的数据，有 $m\\leq4$；\n- 对于 $60\\%$ 的数据，有 $m\\leq5$；\n- 对于 $100\\%$ 的数据，有 $m\\leq50$，$n\\leq10^{13}$，$1 \\le a_i <n$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2018] Textbook Defile", "background": "", "description": "Xiao Dou likes playing games. He is now facing a situation in a game where each monster has health $a_i$, and all monsters have distinct health values. Xiao Dou has an unlimited number of \"Defile\" cards. The effect of Defile is to deal $1$ damage to all monsters; if any monster dies, the spell is cast again. We consider a monster to be dead when its health reaches $0$.\n\nEach time Xiao Dou uses one \"Defile,\" he gets some score. The score is calculated as follows: after using a single \"Defile,\" every monster that is damaged by \"Defile\" grants Xiao Dou $x^k$ points, where $x$ is that monster’s health value before the damage is applied, and $k$ is the number of \"Defile\" cards needed to kill all monsters. Note: automatic re-casts of \"Defile\" caused by monster deaths do not count toward $k$, and they do not increase Xiao Dou’s score.", "inputFormat": "The first line contains an integer $T$ ($T \\le 10$), the number of test cases.\n\nFor each test case, the first line contains $n$, $m$, where $n$ is the maximum health value among the monsters, and $m$ is the number of health values that are missing.\n\nThe next $m$ lines each contain one number $a_i$, indicating that there is no monster with health $a_i$ on the field.", "outputFormat": "Output $T$ lines. The $i$-th line contains the final score Xiao Dou can obtain in the $i$-th test case, modulo $10^9+7$.", "hint": "- For $10\\%$ of the testdata, $m=0$.\n- For $20\\%$ of the testdata, $m \\le 1$.\n- For $30\\%$ of the testdata, $m \\le 2$.\n- For $40\\%$ of the testdata, $m \\le 3$.\n- For $50\\%$ of the testdata, $m \\le 4$.\n- For $60\\%$ of the testdata, $m \\le 5$.\n- For $100\\%$ of the testdata, $m \\le 50$, $n \\le 10^{13}$, $1 \\le a_i < n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2018] 教科书般的亵渎", "background": null, "description": "小豆喜欢玩游戏，现在他在玩一个游戏遇到这样的场面，每个怪的血量为 $a_i$，且每个怪物血量均不相同，小豆手里有无限张“亵渎”。亵渎的效果是对所有的怪造成 $1$ 点伤害，如果有怪死亡，则再次施放该法术。我们认为血量为 $0$ 怪物死亡。\n\n小豆使用一张“亵渎”会获得一定的分数，分数计算如下，在使用一张“亵渎”之后，每一个被“亵渎”造成伤害的怪会令小豆获得 $x^k$ 的分数，其中 $x$ 是造成伤害前怪的血量为 $x$ 和需要杀死所有怪物所需的“亵渎”的张数 $k$ 。**注意：因怪死亡而重复释放的“亵渎”不计入 $k$ ,也不会使小豆的分数增加。**", "inputFormat": "第一行输入一个 $T$（$T\\leq10$），表示有多少组测试数据。\n\n每组测试数据第一行为 $n$，$m$，表示有当前怪物最高的血量 $n$，和 $m$ 种没有出现的血量。\n\n接下来 $m$ 行，每行 $1$ 个数 $a_i$，表示场上没有血量为 $a_i$ 的怪物。", "outputFormat": "一共 $T$ 行，每行一个数，第 $i$ 行表示第 $i$ 组测试数据中小豆的最后可以获得的分数，因为这个分数会很大需要模 $10^9+7$。", "hint": "- 对于 $10\\%$ 的数据，有 $m=0$；\n- 对于 $20\\%$ 的数据，有 $m\\leq1$；\n- 对于 $30\\%$ 的数据，有 $m\\leq2$\n- 对于 $40\\%$ 的数据，有 $m\\leq3$；\n- 对于 $50\\%$ 的数据，有 $m\\leq4$；\n- 对于 $60\\%$ 的数据，有 $m\\leq5$；\n- 对于 $100\\%$ 的数据，有 $m\\leq50$，$n\\leq10^{13}$，$1 \\le a_i <n$。", "locale": "zh-CN"}}}
{"pid": "P4594", "type": "P", "difficulty": 4, "samples": [["2 \n1 \n1\n", "1.00000000"], ["3\n1 \n1 \n1\n", "1.50000000"], ["3 \n1 \n1 \n9\n", "1.90000000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2011", "COCI（克罗地亚）"], "title": "[COCI 2011/2012 #5] BLOKOVI", "background": "", "description": "平面直角坐标系种有 $N$ 个质量为 $m_{i}$ ，长为 $2$，高为 $h$ 的矩形，使得：\n\n* 矩形的边缘与坐标轴平行；\n* 矩形的下层与 $y$坐标不重合，且为以下值：$0,h,2h,3h,\\dots,(N-1)h$；\n* 最低的矩形左下角的坐标为 $(-2,0)$，右下角与原点重合。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rjzp667k.png)\n\n定义一个矩阵的 X 中心是其下边的中点的 X 坐标。一个或多个矩形的 X 中心是其 X 中心的加权平均值。它的计算方法为：\n\n$$\nXbarycetre=\\frac{\\sum_{i}m_{i}\\times Xcentre(i)}{\\sum_{i}m_{i}}\n$$\n\n其中 `Xbarycetre` 表示一个或多个矩形的 X 中心，`Xcentre` 表示一个矩阵的 X 中心。\n\n换句话说，其值为每个矩形的质量乘以它的 X 中心之积除以矩形的总质量。\n\n对于每一个矩形，如果它**上面的矩形**的 X 中心与其的 X 中心的距离小于等于 $1$，则称这些矩形组成的排列是稳定的。\n\n例如，左图的排列是不稳定的，因为上面两个矩形的 X 中心到下面的矩形的X中心的距离大于 $1$。而右图的排列是稳定的。\n\n给出所有矩形的质量，求其可以组成的稳定排列中的矩形的最大 X 坐标。\n\n你不能改变矩形的顺序，它们从**基本**低到高给出。", "inputFormat": "第一行，一个整数 $N$，表示矩形的数量。\n\n接着 $N$ 行，每行一个整数 $m_{i}$，表示第 $i$ 个矩形的质量。", "outputFormat": "一行，一个小数，表示答案，答案在 $0.000001$ 的误差内均为正确。", "hint": "有 $30\\%$ 的数据，矩形的质量从大到小给出。\n\n$2\\le N\\le 3\\times 10^{5}$，$1\\le m_{i}\\le 10^{4}$。\n\n题目译自 [COCI 2011/2012 #5 T5](https://hsin.hr/coci/archive/2011_2012/contest5_tasks.pdf)。", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2011/2012 #5] BLOKOVI", "background": "", "description": "In the 2D Cartesian coordinate system, there are $N$ rectangles with masses $m_i$, width $2$, and height $h$, such that:\n\n- The sides of each rectangle are parallel to the coordinate axes.\n- The bottom side of each rectangle does not lie on the $x$-axis, and its $y$-coordinate is one of the following values: $0, h, 2h, 3h, \\dots, (N-1)h$.\n- The lowest rectangle has its lower-left corner at $(-2, 0)$, and its lower-right corner coincides with the origin.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rjzp667k.png)\n\nDefine the $x$-center of a rectangle as the $x$-coordinate of the midpoint of its bottom side. The $x$-center of one or more rectangles is the weighted average of their $x$-centers, computed as:\n\n$$\nXbarycetre=\\frac{\\sum_{i}m_{i}\\times Xcentre(i)}{\\sum_{i}m_{i}}\n$$\n\nHere, `Xbarycetre` denotes the $x$-center of one or more rectangles, and `Xcentre` denotes the $x$-center of a rectangle.\n\nIn other words, it is the sum of (each rectangle’s mass times its $x$-center) divided by the total mass of the rectangles.\n\nFor each rectangle, if the distance between the $x$-center of the rectangles **above it** and its own $x$-center is at most $1$, then the arrangement formed by these rectangles is called stable.\n\nFor example, the arrangement in the left picture is unstable because the distance between the $x$-center of the top two rectangles and the $x$-center of the rectangle below them is greater than $1$. The arrangement in the right picture is stable.\n\nGiven the masses of all rectangles, find the maximum possible $x$-coordinate of the rectangles in a stable arrangement.\n\nYou are not allowed to change the order of the rectangles; they are given from **bottom** to top.", "inputFormat": "The first line contains an integer $N$, the number of rectangles.\n\nThe next $N$ lines each contain an integer $m_i$, the mass of the $i$-th rectangle.", "outputFormat": "Print one real number, the answer. Any answer within an error of $0.000001$ will be accepted.", "hint": "For $30\\%$ of the testdata, the rectangle masses are given in decreasing order.\n\nConstraints: $2\\le N\\le 3\\times 10^{5}$, $1\\le m_{i}\\le 10^{4}$.\n\nTranslated from [COCI 2011/2012 #5 T5](https://hsin.hr/coci/archive/2011_2012/contest5_tasks.pdf).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COCI 2011/2012 #5] BLOKOVI", "background": "", "description": "平面直角坐标系种有 $N$ 个质量为 $m_{i}$ ，长为 $2$，高为 $h$ 的矩形，使得：\n\n* 矩形的边缘与坐标轴平行；\n* 矩形的下层与 $y$坐标不重合，且为以下值：$0,h,2h,3h,\\dots,(N-1)h$；\n* 最低的矩形左下角的坐标为 $(-2,0)$，右下角与原点重合。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rjzp667k.png)\n\n定义一个矩阵的 X 中心是其下边的中点的 X 坐标。一个或多个矩形的 X 中心是其 X 中心的加权平均值。它的计算方法为：\n\n$$\nXbarycetre=\\frac{\\sum_{i}m_{i}\\times Xcentre(i)}{\\sum_{i}m_{i}}\n$$\n\n其中 `Xbarycetre` 表示一个或多个矩形的 X 中心，`Xcentre` 表示一个矩阵的 X 中心。\n\n换句话说，其值为每个矩形的质量乘以它的 X 中心之积除以矩形的总质量。\n\n对于每一个矩形，如果它**上面的矩形**的 X 中心与其的 X 中心的距离小于等于 $1$，则称这些矩形组成的排列是稳定的。\n\n例如，左图的排列是不稳定的，因为上面两个矩形的 X 中心到下面的矩形的X中心的距离大于 $1$。而右图的排列是稳定的。\n\n给出所有矩形的质量，求其可以组成的稳定排列中的矩形的最大 X 坐标。\n\n你不能改变矩形的顺序，它们从**基本**低到高给出。", "inputFormat": "第一行，一个整数 $N$，表示矩形的数量。\n\n接着 $N$ 行，每行一个整数 $m_{i}$，表示第 $i$ 个矩形的质量。", "outputFormat": "一行，一个小数，表示答案，答案在 $0.000001$ 的误差内均为正确。", "hint": "有 $30\\%$ 的数据，矩形的质量从大到小给出。\n\n$2\\le N\\le 3\\times 10^{5}$，$1\\le m_{i}\\le 10^{4}$。\n\n题目译自 [COCI 2011/2012 #5 T5](https://hsin.hr/coci/archive/2011_2012/contest5_tasks.pdf)。", "locale": "zh-CN"}}}
{"pid": "P4595", "type": "P", "difficulty": 5, "samples": [["6\nabcbab\n2\ncb\ncbab", "2"], ["4\nabab\n2\nbac\nbaba", "4"], ["6\nabcabc\n2\nabca\ncab", "1"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2011", "COCI（克罗地亚）"], "title": "[COCI 2011/2012 #5] POPLOČAVANJE", "background": "注意：本题相对于原题缩小了空间限制，需要一些小技巧才能通过。", "description": "有一条由 $N$ 个英文小写字母组成的街道，市政府偶尔会更换街道上的瓷砖。但是，字母瓷砖的需求量很大，所以政府只有 $M$ 种字母瓷砖可供选择。\n\n第 $i$ 个瓦片图案由 $L_{i}$ 个字母组成。瓷砖不能旋转，也不能打碎，而且只能放置在瓷砖字母与街道上连续的字母子序列重合的地方。\n\n瓷砖可以重叠，且可以使用相同图案的多块瓷砖。如果一个街道不能被任何瓷砖覆盖，那么他就是不好的。\n\n求有多少个不好的街道。", "inputFormat": "第一行，一个整数 $N$，表示街道上的字母数。\n\n第二行有 $N$ 个小写字母，表示街道上的序列，由小写字母组成。\n\n第三行，一个整数 $M$，表示瓷砖数量。\n\n接着 $M$ 行，每行 $L_{i}$ 个小写字母，表示该瓷砖的图案。", "outputFormat": "一行，一个整数，表示方案数。", "hint": "$1\\le N\\le 3\\times 10^{5}$，$1\\le M\\le 5\\times 10^{3}$，$1\\le L_{i}\\le 5\\times 10^{3}$。\n\n题目译自 [COCI 2011/2012 #5 T6](https://hsin.hr/coci/archive/2011_2012/contest5_tasks.pdf)。", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2011/2012 #5] POPLOČAVANJE", "background": "Note: Compared with the original problem, this version has a smaller memory limit. Some small tricks are needed to pass.", "description": "There is a street consisting of $N$ lowercase English letters. The city government occasionally replaces the tiles on the street. However, letter tiles are in high demand, so the government only has $M$ kinds of letter tiles to choose from.\n\nThe pattern of the $i$-th tile consists of $L_{i}$ letters. Tiles cannot be rotated or broken, and they can only be placed where the tile’s letters exactly match a contiguous substring of letters on the street.\n\nTiles may overlap, and multiple tiles with the same pattern may be used. If a street cannot be covered by any tiles, then it is bad.\n\nFind how many bad streets there are.", "inputFormat": "The first line contains an integer $N$, the number of letters on the street.\n\nThe second line contains $N$ lowercase letters, the sequence on the street.\n\nThe third line contains an integer $M$, the number of tiles.\n\nThe next $M$ lines each contain $L_{i}$ lowercase letters, describing the pattern of that tile.", "outputFormat": "Print one line with an integer, the number of bad streets.", "hint": "Constraints: $1\\le N\\le 3\\times 10^{5}$, $1\\le M\\le 5\\times 10^{3}$, $1\\le L_{i}\\le 5\\times 10^{3}$.\n\nTranslated from [COCI 2011/2012 #5 T6](https://hsin.hr/coci/archive/2011_2012/contest5_tasks.pdf).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COCI 2011/2012 #5] POPLOČAVANJE", "background": "注意：本题相对于原题缩小了空间限制，需要一些小技巧才能通过。", "description": "有一条由 $N$ 个英文小写字母组成的街道，市政府偶尔会更换街道上的瓷砖。但是，字母瓷砖的需求量很大，所以政府只有 $M$ 种字母瓷砖可供选择。\n\n第 $i$ 个瓦片图案由 $L_{i}$ 个字母组成。瓷砖不能旋转，也不能打碎，而且只能放置在瓷砖字母与街道上连续的字母子序列重合的地方。\n\n瓷砖可以重叠，且可以使用相同图案的多块瓷砖。如果一个街道不能被任何瓷砖覆盖，那么他就是不好的。\n\n求有多少个不好的街道。", "inputFormat": "第一行，一个整数 $N$，表示街道上的字母数。\n\n第二行有 $N$ 个小写字母，表示街道上的序列，由小写字母组成。\n\n第三行，一个整数 $M$，表示瓷砖数量。\n\n接着 $M$ 行，每行 $L_{i}$ 个小写字母，表示该瓷砖的图案。", "outputFormat": "一行，一个整数，表示方案数。", "hint": "$1\\le N\\le 3\\times 10^{5}$，$1\\le M\\le 5\\times 10^{3}$，$1\\le L_{i}\\le 5\\times 10^{3}$。\n\n题目译自 [COCI 2011/2012 #5 T6](https://hsin.hr/coci/archive/2011_2012/contest5_tasks.pdf)。", "locale": "zh-CN"}}}
{"pid": "P4596", "type": "P", "difficulty": 3, "samples": [["4\nNIVA\nHLAD\nHSIN\nDEDA\n", "2"], ["6\nBAKA\nBARA\nBALC\nCALC\nARHC\nBLIC\n", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2011", "COCI（克罗地亚）"], "title": "[COCI 2011/2012 #5] RAZBIBRIGA", "background": "", "description": "四个长度相同的单词可以拼成一个正方形，如下图，`\"HLAD\",\"NIVA\",\"HSIN\",\"DEDA\"` 拼成了一个 $4\\times 4$ 的正方形。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7i3lhwgv.png)\n\n现在给你 $N$ 个等长的单词，求这些单词的子集可以拼成多少个不同的正方形，输出方案数。\n\n注意，**同一方格内不能有重复的单词**，如果两个单词至少有一个字符不同，那这两个单词就是不同的。", "inputFormat": "第一行，一个整数 $N$，表示单词数。\n\n接着 $N$ 行，每行一个单词，由大写字母组成，如题所示。", "outputFormat": "一行，一个整数，表示方案数。\n\n方案数可能很大，你需要开 `long long` 或 `int64`。", "hint": "$4\\le N\\le 10^{5}$。\n\n每个单词至多有 $10$ 个字符。\n\n单词由大写字母构成。\n\n题目译自 [COCI 2011/2012 #5 T4](https://hsin.hr/coci/archive/2011_2012/contest5_tasks.pdf)。", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2011/2012 #5] RAZBIBRIGA", "background": "", "description": "Four words of the same length can be arranged into a square, as shown in the figure below. For example, `\"HLAD\"`, `\"NIVA\"`, `\"HSIN\"`, and `\"DEDA\"` form a $4\\times 4$ square.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7i3lhwgv.png)\n\nYou are given $N$ words of the same length. Find how many different squares can be formed by choosing a subset of these words, and output the number of valid arrangements.\n\nNote that **the same square cannot contain repeated words**. If two words differ in at least one character, then they are considered different words.", "inputFormat": "The first line contains an integer $N$, which is the number of words.\n\nThe next $N$ lines each contain one word consisting of uppercase letters, as described above.", "outputFormat": "Output one line containing an integer, the number of valid arrangements.\n\nThe answer may be very large, so you need to use `long long` or `int64`.", "hint": "Constraints: $4\\le N\\le 10^{5}$.\n\nEach word has at most $10$ characters.\n\nAll words consist of uppercase letters.\n\nThis problem is translated from [COCI 2011/2012 #5 T4](https://hsin.hr/coci/archive/2011_2012/contest5_tasks.pdf)。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COCI 2011/2012 #5] RAZBIBRIGA", "background": "", "description": "四个长度相同的单词可以拼成一个正方形，如下图，`\"HLAD\",\"NIVA\",\"HSIN\",\"DEDA\"` 拼成了一个 $4\\times 4$ 的正方形。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7i3lhwgv.png)\n\n现在给你 $N$ 个等长的单词，求这些单词的子集可以拼成多少个不同的正方形，输出方案数。\n\n注意，**同一方格内不能有重复的单词**，如果两个单词至少有一个字符不同，那这两个单词就是不同的。", "inputFormat": "第一行，一个整数 $N$，表示单词数。\n\n接着 $N$ 行，每行一个单词，由大写字母组成，如题所示。", "outputFormat": "一行，一个整数，表示方案数。\n\n方案数可能很大，你需要开 `long long` 或 `int64`。", "hint": "$4\\le N\\le 10^{5}$。\n\n每个单词至多有 $10$ 个字符。\n\n单词由大写字母构成。\n\n题目译自 [COCI 2011/2012 #5 T4](https://hsin.hr/coci/archive/2011_2012/contest5_tasks.pdf)。", "locale": "zh-CN"}}}
{"pid": "P4597", "type": "P", "difficulty": 6, "samples": [["5\n3 2 -1 2 11\n", "4"], ["5\n2 1 1 1 1\n", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化", "斜率维护技巧 slope trick"], "title": "序列 sequence", "background": "原题 CF13C 数据加强版", "description": "给定一个序列，每次操作可以把某个数 $+1$ 或 $-1$。要求把序列变成非降数列。", "inputFormat": "第一行，输入一个整数 $n$（$n \\leq 5 \\times 10^5$），表示有 $n$ 个数字。  \n第二行输入 $n$ 个整数，整数的绝对值不超过 $10^9$。", "outputFormat": "输出一个数，表示最少的操作次数。", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 5 \\times {10}^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Sequence", "background": "Original problem CF13C, stronger testdata version.", "description": "Given a sequence, in each operation you may add $+1$ or $-1$ to any number. Make the sequence non-decreasing.", "inputFormat": "The first line contains an integer $n$ ($n \\le 5 \\times 10^5$), the number of elements.  \nThe second line contains $n$ integers; the absolute value of each integer does not exceed $10^9$.", "outputFormat": "Output a single number: the minimal number of operations.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 5 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "序列 sequence", "background": "原题 CF13C 数据加强版", "description": "给定一个序列，每次操作可以把某个数 $+1$ 或 $-1$。要求把序列变成非降数列。", "inputFormat": "第一行，输入一个整数 $n$（$n \\leq 5 \\times 10^5$），表示有 $n$ 个数字。  \n第二行输入 $n$ 个整数，整数的绝对值不超过 $10^9$。", "outputFormat": "输出一个数，表示最少的操作次数。", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 5 \\times {10}^5$。", "locale": "zh-CN"}}}
{"pid": "P4598", "type": "P", "difficulty": 6, "samples": [["3\n-24 14 29 6 ", "3\n-4\n-3/2\n2/3 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "各省省选", "河北"], "title": "[HEOI2012] Akai 的数学作业", "background": "这里是广袤无垠的宇宙\n\n这里是一泻千里的银河\n\n这里是独一无二的太阳系\n\n这里是蔚蓝色的地球\n\n这里，就是这里，是富饶的中国大陆！\n\n这里是神奇的河北大地\n\n这里是美丽的唐山\n\n这里是神话般的唐山一中\n\n这里是 Akai 曾经的教室", "description": "黑板上还留有当年 Akai 做过的数学作业，其实也并不是什么很困难的题目:\n\n“\n\n给出一个一元 $n$ 次方程： \n\n$$a_0 + a_1x + a_2x^2 +…+ a_nx^n= 0$$ \n\n求此方程的所有有理数解。 \n\n” \n\nAkai 至今还深刻记得当年熬夜奋战求解的时光\n\n他甚至还能记得浪费了多少草稿纸\n\n但是却怎么也想不起来最后的答案是多少了\n\n你能帮助他么？", "inputFormat": "第一行一个整数 $n$。第二行 $n+1$ 个整数，分别代表 $a_0$ 到$a_n$", "outputFormat": "第一行输出一个整数 $t$，表示有理数解的个数 \n\n接下来 $t$ 行，每行表示一个解 \n\n解以分数的形式输出，要求分子和分母互质，且分母必须是正整数 \n\n特殊的，如果这个解是一个整数，那么直接把这个数输出 \n\n等价的解只需要输出一次 \n\n所有解按照从小到大的顺序输出", "hint": "对于 30%的数据，$n\\leq10$ \n\n对于 100%的数据，$n\\leq100$，$|a_i| \\leq 1.3\\times10^8$，$a_n\\not= 0$\n\nHEOI 2012 Day1 Task1", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2012] Akai's Math Homework", "background": "Here lies the vast universe.\nHere flows the mighty Milky Way.\nHere is the one-and-only Solar System.\nHere is the blue Earth.\nHere, right here, is the fertile Chinese mainland.\nHere is the magical land of Hebei.\nHere is the beautiful city of Tangshan.\nHere is the mythical Tangshan No. 1 High School.\nHere is the classroom where Akai once studied.", "description": "On the blackboard remains a piece of math homework Akai once did. It is actually not a very difficult problem:\n\n\"Given a univariate polynomial equation of degree $n$:\n\n$$a_0 + a_1 x + a_2 x^2 + \\cdots + a_n x^n = 0$$\n\nFind all rational solutions of this equation.\"\n\nAkai still vividly remembers the nights he stayed up solving it.\nHe even remembers how much scrap paper he wasted.\nBut he just can’t recall the final answers.\nCan you help him?", "inputFormat": "The first line contains an integer $n$.\nThe second line contains $n + 1$ integers, representing $a_0$ to $a_n$.", "outputFormat": "Output an integer $t$ on the first line, the number of rational solutions.\nThen output $t$ lines, each containing one solution.\nEach solution must be printed as a fraction in lowest terms, with a positive denominator.\nIf a solution is an integer, output the integer directly.\nEquivalent solutions should be output only once.\nOutput all solutions in increasing order.", "hint": "- For 30% of the testdata, $n \\leq 10$.\n- For 100% of the testdata, $n \\leq 100$, $|a_i| \\leq 1.3 \\times 10^8$, $a_n \\ne 0$.\n\nHEOI 2012 Day 1 Task 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2012] Akai 的数学作业", "background": "这里是广袤无垠的宇宙\n\n这里是一泻千里的银河\n\n这里是独一无二的太阳系\n\n这里是蔚蓝色的地球\n\n这里，就是这里，是富饶的中国大陆！\n\n这里是神奇的河北大地\n\n这里是美丽的唐山\n\n这里是神话般的唐山一中\n\n这里是 Akai 曾经的教室", "description": "黑板上还留有当年 Akai 做过的数学作业，其实也并不是什么很困难的题目:\n\n“\n\n给出一个一元 $n$ 次方程： \n\n$$a_0 + a_1x + a_2x^2 +…+ a_nx^n= 0$$ \n\n求此方程的所有有理数解。 \n\n” \n\nAkai 至今还深刻记得当年熬夜奋战求解的时光\n\n他甚至还能记得浪费了多少草稿纸\n\n但是却怎么也想不起来最后的答案是多少了\n\n你能帮助他么？", "inputFormat": "第一行一个整数 $n$。第二行 $n+1$ 个整数，分别代表 $a_0$ 到$a_n$", "outputFormat": "第一行输出一个整数 $t$，表示有理数解的个数 \n\n接下来 $t$ 行，每行表示一个解 \n\n解以分数的形式输出，要求分子和分母互质，且分母必须是正整数 \n\n特殊的，如果这个解是一个整数，那么直接把这个数输出 \n\n等价的解只需要输出一次 \n\n所有解按照从小到大的顺序输出", "hint": "对于 30%的数据，$n\\leq10$ \n\n对于 100%的数据，$n\\leq100$，$|a_i| \\leq 1.3\\times10^8$，$a_n\\not= 0$\n\nHEOI 2012 Day1 Task1", "locale": "zh-CN"}}}
{"pid": "P4599", "type": "P", "difficulty": 7, "samples": [["2 5 50 ", "30"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "各省省选", "河北"], "title": "[HEOI2012] 赵州桥", "background": "fyg 背着他的电脑来到河北省来，就是为了见一眼古老的赵州桥。 \n\n终于，他来到了赵州桥，放下了电脑，正准备休息。一阵风吹来，从中闪现出一人影。 fyg 只觉天昏地暗，待得再次睁开眼时，发觉自己已经到了一神奇的国度，置身于一巨大的圆盘之上。放眼看去，四周都是奇形怪状的桥，不远处有一老头盘膝而坐。 ", "description": "fyg 还沉浸在惊奇之中，老头（难道就是传说中走过赵州桥的张老头！！）便开口了：凡人，你现在在我的世界中，想要出去就要回答我的问题。fyg 只得点头，老头继续道：你现在要去闯关，我给你$m$种颜色，总共有$n$关（神仙也懂数学，表示压力巨大。。==）。每一关中有一座桥，在第$i$关中，桥长度有$i$个单位，每个单位长度上有$2$个格子（也就是说这座桥有$2i$个格子），现在你要计算出：在这座桥上涂色使得桥上相邻格子的颜色不一样总方案数，然后再乘上$(2\\times i)^m$。如在第$1$关，若你手上有$2$种颜色，分别为蓝色和绿色。则总 方案数为$2\\times 2\\times 2=8$种，涂色方案数为 2（如下图，旋转、翻转相同算不同的方案），然后 还要再乘 2 个 2，最后你出来之后我会问你所有关中计算出来的数的和。如果你能答对，我就可以让你出去了，否则就无限轮回吧。 \n\n![](https://cdn.luogu.com.cn/upload/pic/19158.png )\n\nfyg 表示这个问题太水了，完全不想算。。。于是，他马上打开电脑上了QQ找到了喜欢计算的你，求你帮他直接把最终答案算出来，让他回到赵州桥上。 \n\n这两个数都有可能很大，fyg 不想为难你，所以你只要告诉他其除以 $p$ 的余数。 ", "inputFormat": "只有一行，其中包含三个正数 $n$、$m$、$p$，分别由一个空格分开。$n$、$m$、$p$ 含义和题目描述一致。 ", "outputFormat": "一行，表示方案数的和除以 $p$ 的余数。 ", "hint": "### 【样例说明】\n总共有 $2$ 关。\n\n第一关的桥长度为 $1$，总共有 $2$ 个格子，涂色方案数为 $20$，再乘上 $2 ^ 5$，第一关中计算出的数为 $640$。 \n\n第二关的桥长度为 $2$，总共有 $4$ 个格子，涂色方案数为 $260$，再乘上 $4 ^ 5$，第二关中计算出的数为 $266240$。\n\n两个数字加起来除以 $50$ 余 $30$，故输出为 $30$。 \n\n### 【数据范围】  \n\n对于其中 25%的数据，满足 $n\\leq10^6$，$m\\leq200$，$p\\leq10^9$；  \n\n对于其中 40%的数据，满足 $n\\leq10^9$，$m\\leq120$，$p\\leq10^9$；  \n\n对于其中 15%的数据，满足 $n\\leq10^9$，$m\\leq200$，$p \\leq10^9$；  \n\n对于最后 20%的数据，满足 $n\\leq10^9$，$m\\leq3000$，$p\\leq3000$； \n\nHEOI 2012 Day2 Task1", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2012] Zhaozhou Bridge", "background": "fyg carried his computer to Hebei just to catch a glimpse of the ancient Zhaozhou Bridge.\n\nAt last, he arrived at Zhaozhou Bridge, set down his computer, and was about to rest. A gust of wind blew, and a figure flashed out of it. fyg felt the world spin; when he opened his eyes again, he found himself in a magical realm, standing on a giant disk. Looking around, there were strange bridges everywhere, and not far away an old man was sitting cross-legged.", "description": "While fyg was still amazed, the old man (could it be the legendary Mr. Zhang who once crossed Zhaozhou Bridge?!) began to speak: Mortal, you are now in my world. If you want to leave, you must answer my question. fyg nodded, and the old man continued: You are going to clear a series of levels. I give you $m$ colors, and there are $n$ levels in total (even immortals know math—what pressure...). In each level, there is a bridge. In level $i$, the bridge has length $i$ units, and each unit length has $2$ cells (that is, the bridge has $2i$ cells). Now you need to compute: the number of ways to color this bridge so that adjacent cells have different colors, then multiply it by $(2 \\times i)^m$. For example, in level $1$, if you have $2$ colors, blue and green, then the final number would be $2 \\times 2 \\times 2 = 8$; the number of coloring schemes is $2$ (as shown in the figure; rotations and reflections are counted as different), and then you also multiply by two 2s. After you come out, I will ask you for the sum of the numbers computed for all levels. If you answer correctly, I will let you go; otherwise, you will be trapped in an endless cycle.\n\n![](https://cdn.luogu.com.cn/upload/pic/19158.png)\n\nfyg thought the problem was too trivial and did not want to compute it at all... So he immediately opened his computer, logged into QQ, and found you, who enjoy calculations, asking you to directly compute the final answer and help him return to Zhaozhou Bridge.\n\nThese two numbers can both be very large, and fyg does not want to make it hard for you, so you only need to tell him the remainder when divided by $p$.", "inputFormat": "A single line containing three positive integers $n$, $m$, and $p$, separated by spaces. The meanings of $n$, $m$, and $p$ are as described in the problem statement.", "outputFormat": "One line, the remainder of the sum of the values modulo $p$.", "hint": "### Sample Explanation\nThere are $2$ levels in total.\n\n- In the first level, the bridge length is $1$, there are $2$ cells in total, the number of coloring schemes is $20$, then multiply by $2^5$, and the number computed for the first level is $640$.\n- In the second level, the bridge length is $2$, there are $4$ cells in total, the number of coloring schemes is $260$, then multiply by $4^5$, and the number computed for the second level is $266240$.\n\nThe sum of the two numbers leaves a remainder $30$ when divided by $50$, so the output is $30$.\n\n### Constraints\n- For 25% of the testdata, $n \\leq 10^6$, $m \\leq 200$, $p \\leq 10^9$.\n- For 40% of the testdata, $n \\leq 10^9$, $m \\leq 120$, $p \\leq 10^9$.\n- For 15% of the testdata, $n \\leq 10^9$, $m \\leq 200$, $p \\leq 10^9$.\n- For the final 20% of the testdata, $n \\leq 10^9$, $m \\leq 3000$, $p \\leq 3000$.\n\nHEOI 2012 Day2 Task1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2012] 赵州桥", "background": "fyg 背着他的电脑来到河北省来，就是为了见一眼古老的赵州桥。 \n\n终于，他来到了赵州桥，放下了电脑，正准备休息。一阵风吹来，从中闪现出一人影。 fyg 只觉天昏地暗，待得再次睁开眼时，发觉自己已经到了一神奇的国度，置身于一巨大的圆盘之上。放眼看去，四周都是奇形怪状的桥，不远处有一老头盘膝而坐。 ", "description": "fyg 还沉浸在惊奇之中，老头（难道就是传说中走过赵州桥的张老头！！）便开口了：凡人，你现在在我的世界中，想要出去就要回答我的问题。fyg 只得点头，老头继续道：你现在要去闯关，我给你$m$种颜色，总共有$n$关（神仙也懂数学，表示压力巨大。。==）。每一关中有一座桥，在第$i$关中，桥长度有$i$个单位，每个单位长度上有$2$个格子（也就是说这座桥有$2i$个格子），现在你要计算出：在这座桥上涂色使得桥上相邻格子的颜色不一样总方案数，然后再乘上$(2\\times i)^m$。如在第$1$关，若你手上有$2$种颜色，分别为蓝色和绿色。则总 方案数为$2\\times 2\\times 2=8$种，涂色方案数为 2（如下图，旋转、翻转相同算不同的方案），然后 还要再乘 2 个 2，最后你出来之后我会问你所有关中计算出来的数的和。如果你能答对，我就可以让你出去了，否则就无限轮回吧。 \n\n![](https://cdn.luogu.com.cn/upload/pic/19158.png )\n\nfyg 表示这个问题太水了，完全不想算。。。于是，他马上打开电脑上了QQ找到了喜欢计算的你，求你帮他直接把最终答案算出来，让他回到赵州桥上。 \n\n这两个数都有可能很大，fyg 不想为难你，所以你只要告诉他其除以 $p$ 的余数。 ", "inputFormat": "只有一行，其中包含三个正数 $n$、$m$、$p$，分别由一个空格分开。$n$、$m$、$p$ 含义和题目描述一致。 ", "outputFormat": "一行，表示方案数的和除以 $p$ 的余数。 ", "hint": "### 【样例说明】\n总共有 $2$ 关。\n\n第一关的桥长度为 $1$，总共有 $2$ 个格子，涂色方案数为 $20$，再乘上 $2 ^ 5$，第一关中计算出的数为 $640$。 \n\n第二关的桥长度为 $2$，总共有 $4$ 个格子，涂色方案数为 $260$，再乘上 $4 ^ 5$，第二关中计算出的数为 $266240$。\n\n两个数字加起来除以 $50$ 余 $30$，故输出为 $30$。 \n\n### 【数据范围】  \n\n对于其中 25%的数据，满足 $n\\leq10^6$，$m\\leq200$，$p\\leq10^9$；  \n\n对于其中 40%的数据，满足 $n\\leq10^9$，$m\\leq120$，$p\\leq10^9$；  \n\n对于其中 15%的数据，满足 $n\\leq10^9$，$m\\leq200$，$p \\leq10^9$；  \n\n对于最后 20%的数据，满足 $n\\leq10^9$，$m\\leq3000$，$p\\leq3000$； \n\nHEOI 2012 Day2 Task1", "locale": "zh-CN"}}}
{"pid": "P4600", "type": "P", "difficulty": 6, "samples": [["2\naabb\nbabb\n2\n1 3 2 3\n1 4 2 4 ", "1\n1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "线段树", "各省省选", "河北", "最近公共祖先 LCA", "AC 自动机"], "title": "[HEOI2012] 旅行问题", "background": "", "description": "yz 是 Z 国的领导人，他规定每个地区的名字只能为 $26$ 个小写拉丁字母的一个。由于地区数有可能超过 $26$ 个，便产生了一个问题，如何辨别名字相同的地区？于是 yz 规定，一个地区的描述必须包含它的所有上级，且上级按次序排列。于是，一个地区的描述是一个字符串。比如说，一个地区的名字为 $\\tt c$，它的上级为 $\\tt b$，$\\tt b$ 的上级为 $\\tt a$，$\\tt a$ 没有上级，那么这个地区就描述为 $\\tt abc$。显然，这个描述同时包含了 $\\tt c$ 的上级 $\\tt b$ 和 $\\tt b$ 的上级 $\\tt a$ 的描述，分别为 $\\tt ab$ 和 $\\tt a$。\n\n值得注意的是，每个地区最多有一个上级，同一上级的地区之间名字不同，没有上级的地区之间名字不同。\n\n现在，yz 对外公布了 $n$ 个地区的描述，这些描述中包含了 Z 国所有地区的描述，并让你处理来访者的旅行问题。\n\n现有 $m$ 对人访问这个国家，对于每对人，第一个人喜欢第 $i$ 个描述中的第 $j$ 个地区，设这个地区描述为 $s_1$，第二个人喜欢第 $k$ 个描述中的第 $l$ 个地区，设这个地区描述为 $s_2$。他们为了统一行程，决定访问描述为 $s$ 的地区（显然他们只关心地区的名字，并非是地区本身），设 $s$ 的长度为 $t$，$s$ 需要满足以下条件：\n\n1. $t\\leq j$，$t\\leq l$。\n2. $s[1\\cdots t]=s_1[j-t+1\\cdots j]$，$s[1\\cdots t]=s_2[l-t+1\\cdots l]$，即 $s$ 为 $s_1$ 中 $1$ 到 $j$ 位与 $s_2$ 中 $1$ 到 $l$ 位的公共后缀。\n2. $t$ 最大化。\n\n为了不使输出过大，你只需把这个字符串按照如下生成的 $26$ 进制数转成 $10$ 进制后 $\\bmod\\ (10^9+7)$ 后输出：\n\n- $a \\to 0$；\n- $b \\to 1$；\n- ……\n- $z \\to 25$。\n\n比如地区 $\\tt cab$ 被编码成 $2\\times26^2+0\\times26^1+1\\times26^0=1353$。", "inputFormat": "第一行给定一个整数 $n$。\n\n第 $2\\cdots n+1$ 行，每 $i+1$ 行给定一个字符串 $a_i$，表示第 $i$ 个描述。\n\n接下来一行一个整数 $m$。 \n\n接下来 $m$ 行，每行给定四个整数 $i,j,k,l$，字母含义与题目描述一致。 ", "outputFormat": "共 $m$ 行，每行一个整数，表示答案字符串的编码。 ", "hint": "### 样例解释\n\n询问 $1$ 中的公共后有 $\\tt ab$ 和 $\\tt b$，但是没有 $\\tt ab$ 这个地区，只有 $\\tt b$ 地区，所以只能选择 $\\tt b$ 这个地区；\n\n询问 $2$ 中的公共后有 $\\tt abb$，$\\tt bb$ 和 $\\tt b$，但是没有 $\\tt abb$ 和 $\\tt bb$ 这两个地区，只有 $\\tt b$ 地区，所以只能选择 $\\tt b$ 这个地区。\n\n### 数据范围及约定\n\n设这个国家地区总数数为 $tot$（注意：输入的字符串总长度可能超过 $tot$！）\n\n- 对于 $30\\%$ 的数据，满足 $1\\le tot, m, n \\le 100$；\n- 对于 $50\\%$ 的数据，满足 $1\\le tot, m, n \\le 1000$；\n- 对于 $80\\%$ 的数据，满足 $1\\le tot, m, n \\le 10^5$；\n- 对于 $100\\%$ 的数据，满足$1\\le  tot, m, n \\le 10^6$。\n\n保证输入文件不超过 $20\\text{MB}$。\n\nHEOI2012 Day 2 Task 2", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2012] Travel Problem", "background": "", "description": "yz is the leader of Country Z. He requires that the name of each region can only be one of the $26$ lowercase Latin letters. Since the number of regions may exceed $26$, a problem arises: how can we tell regions with the same name apart? Therefore, yz specifies that the description of a region must include all of its superiors, and the superiors must be listed in order. Thus, a region’s description is a string. For example, if a region’s name is $\\tt c$, its superior is $\\tt b$, the superior of $\\tt b$ is $\\tt a$, and $\\tt a$ has no superior, then this region is described as $\\tt abc$. Clearly, this description also contains the descriptions of $\\tt c$’s superior $\\tt b$ and $\\tt b$’s superior $\\tt a$, which are $\\tt ab$ and $\\tt a$, respectively.\n\nNote that each region has at most one superior. Among regions with the same superior, their names are different. Among regions with no superior, their names are also different.\n\nNow, yz has published the descriptions of $n$ regions to the public. These descriptions include the descriptions of all regions in Country Z, and you are asked to handle visitors’ travel problems.\n\nThere are $m$ pairs of people visiting this country. For each pair, the first person likes the $j$-th region in the $i$-th description; let this region’s description be $s_1$. The second person likes the $l$-th region in the $k$-th description; let this region’s description be $s_2$. To unify their itinerary, they decide to visit the region whose description is $s$ (obviously, they only care about the region name, not the region itself). Let the length of $s$ be $t$. The string $s$ must satisfy:\n\n1. $t\\leq j$, $t\\leq l$.\n2. $s[1\\cdots t]=s_1[j-t+1\\cdots j]$, $s[1\\cdots t]=s_2[l-t+1\\cdots l]$, i.e., $s$ is a common suffix of the prefix $s_1[1\\cdots j]$ and the prefix $s_2[1\\cdots l]$.\n3. Maximize $t$.\n\nTo avoid overly large output, you only need to convert this string into a base-$26$ number (as generated below), then convert it to base $10$ and output it modulo $(10^9+7)$:\n\n- $a \\to 0$;\n- $b \\to 1$;\n- ……\n- $z \\to 25$.\n\nFor example, region $\\tt cab$ is encoded as $2\\times26^2+0\\times26^1+1\\times26^0=1353$.", "inputFormat": "The first line contains an integer $n$.\n\nLines $2$ to $n+1$: the $(i+1)$-th line contains a string $a_i$, representing the $i$-th description.\n\nThe next line contains an integer $m$.\n\nThe next $m$ lines each contain four integers $i,j,k,l$, with the meanings consistent with the statement.", "outputFormat": "There are $m$ lines. Each line contains one integer, which is the encoding of the answer string.", "hint": "### Sample Explanation\n\nIn query $1$, the common suffixes include $\\tt ab$ and $\\tt b$, but there is no region $\\tt ab$, only region $\\tt b$, so they can only choose region $\\tt b$.\n\nIn query $2$, the common suffixes include $\\tt abb$, $\\tt bb$, and $\\tt b$, but there are no regions $\\tt abb$ or $\\tt bb$, only region $\\tt b$, so they can only choose region $\\tt b$.\n\n### Constraints and Notes\n\nLet the total number of regions in this country be $tot$ (note that the total length of input strings may exceed $tot$!).\n\n- For $30\\%$ of the testdata, $1\\le tot, m, n \\le 100$.\n- For $50\\%$ of the testdata, $1\\le tot, m, n \\le 1000$.\n- For $80\\%$ of the testdata, $1\\le tot, m, n \\le 10^5$.\n- For $100\\%$ of the testdata, $1\\le tot, m, n \\le 10^6$.\n\nIt is guaranteed that the input file does not exceed $20\\text{MB}$.\n\nHEOI2012 Day 2 Task 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2012] 旅行问题", "background": "", "description": "yz 是 Z 国的领导人，他规定每个地区的名字只能为 $26$ 个小写拉丁字母的一个。由于地区数有可能超过 $26$ 个，便产生了一个问题，如何辨别名字相同的地区？于是 yz 规定，一个地区的描述必须包含它的所有上级，且上级按次序排列。于是，一个地区的描述是一个字符串。比如说，一个地区的名字为 $\\tt c$，它的上级为 $\\tt b$，$\\tt b$ 的上级为 $\\tt a$，$\\tt a$ 没有上级，那么这个地区就描述为 $\\tt abc$。显然，这个描述同时包含了 $\\tt c$ 的上级 $\\tt b$ 和 $\\tt b$ 的上级 $\\tt a$ 的描述，分别为 $\\tt ab$ 和 $\\tt a$。\n\n值得注意的是，每个地区最多有一个上级，同一上级的地区之间名字不同，没有上级的地区之间名字不同。\n\n现在，yz 对外公布了 $n$ 个地区的描述，这些描述中包含了 Z 国所有地区的描述，并让你处理来访者的旅行问题。\n\n现有 $m$ 对人访问这个国家，对于每对人，第一个人喜欢第 $i$ 个描述中的第 $j$ 个地区，设这个地区描述为 $s_1$，第二个人喜欢第 $k$ 个描述中的第 $l$ 个地区，设这个地区描述为 $s_2$。他们为了统一行程，决定访问描述为 $s$ 的地区（显然他们只关心地区的名字，并非是地区本身），设 $s$ 的长度为 $t$，$s$ 需要满足以下条件：\n\n1. $t\\leq j$，$t\\leq l$。\n2. $s[1\\cdots t]=s_1[j-t+1\\cdots j]$，$s[1\\cdots t]=s_2[l-t+1\\cdots l]$，即 $s$ 为 $s_1$ 中 $1$ 到 $j$ 位与 $s_2$ 中 $1$ 到 $l$ 位的公共后缀。\n2. $t$ 最大化。\n\n为了不使输出过大，你只需把这个字符串按照如下生成的 $26$ 进制数转成 $10$ 进制后 $\\bmod\\ (10^9+7)$ 后输出：\n\n- $a \\to 0$；\n- $b \\to 1$；\n- ……\n- $z \\to 25$。\n\n比如地区 $\\tt cab$ 被编码成 $2\\times26^2+0\\times26^1+1\\times26^0=1353$。", "inputFormat": "第一行给定一个整数 $n$。\n\n第 $2\\cdots n+1$ 行，每 $i+1$ 行给定一个字符串 $a_i$，表示第 $i$ 个描述。\n\n接下来一行一个整数 $m$。 \n\n接下来 $m$ 行，每行给定四个整数 $i,j,k,l$，字母含义与题目描述一致。 ", "outputFormat": "共 $m$ 行，每行一个整数，表示答案字符串的编码。 ", "hint": "### 样例解释\n\n询问 $1$ 中的公共后有 $\\tt ab$ 和 $\\tt b$，但是没有 $\\tt ab$ 这个地区，只有 $\\tt b$ 地区，所以只能选择 $\\tt b$ 这个地区；\n\n询问 $2$ 中的公共后有 $\\tt abb$，$\\tt bb$ 和 $\\tt b$，但是没有 $\\tt abb$ 和 $\\tt bb$ 这两个地区，只有 $\\tt b$ 地区，所以只能选择 $\\tt b$ 这个地区。\n\n### 数据范围及约定\n\n设这个国家地区总数数为 $tot$（注意：输入的字符串总长度可能超过 $tot$！）\n\n- 对于 $30\\%$ 的数据，满足 $1\\le tot, m, n \\le 100$；\n- 对于 $50\\%$ 的数据，满足 $1\\le tot, m, n \\le 1000$；\n- 对于 $80\\%$ 的数据，满足 $1\\le tot, m, n \\le 10^5$；\n- 对于 $100\\%$ 的数据，满足$1\\le  tot, m, n \\le 10^6$。\n\n保证输入文件不超过 $20\\text{MB}$。\n\nHEOI2012 Day 2 Task 2", "locale": "zh-CN"}}}
{"pid": "P4601", "type": "P", "difficulty": 0, "samples": [["3 3 2\nH#.\n*..\n…\n1 0\n0 1\n2\n1\n2 ", "1\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "各省省选", "河北"], "title": "[HEOI2012] 野外探险", "background": "小 H 是一位探险家。在险峻的珠穆朗玛峰，原始辽阔的非洲大草原，美丽冻人的南极大陆等地方都留下过这位探险家的足迹。这次，他来到了位于南美洲充斥着大量毒虫猛兽的以及各式各样传说的亚马逊热带雨林进行探险。为此，他花了许多时间来准备这次激动人心的探险。在准备就绪后，小 H 和他的助手在当地导游的带领下踏入了这片雨林。 ", "description": "通过 GPS 定位系统，他们获得了雨林大致的地图。这个地图是一个 $n$ 行 $m$ 列的字符网格图，’.’表示的是空地，’*’表示的是不可通行的区域，’#’表示的是需要清理的区域，’H’表示小H所在的位置，该区域是空地。他们的移动方式有 $t$ 种，用$a[i]$,$b[i]$($1\\leq i\\leq t$)表示，假设他们所在的位置为第 $x$ 行第 $y$ 列，那么他们下一步的位置将是第 $x+a[i]$行第 $y+b[i]$列，也可以是反方向，即第 $x-a[i]$行第 $y-b[i]$列。小 H 一行人每天可在选择一种移动方式，朝着正方向或者反方向连续走若干步之后停下，不可以不走。在当天的行走过程中，他们不可以到达不可通行的区域，如果他们到达了一个需要清理的区域，他们会停止移动。为了以后探险的方便，他们会用该天剩下的时间来清理该区域，之后该区域将永久变成空地。\n\n现在，为了使探险活动顺利的进行，他们将 $q$ 个询问通过网络发送给了你，询问他们在第 $d[i]$($1\\leq i\\leq q$)天能到达的区域个数，题目保证不会有无路可走的情况。你能帮助他解决这个问题吗？ ", "inputFormat": "输入的第 $1$ 行包含三个正整数，分别表示 $n$、$m$、$t$。\n\n在第 $2$ 行至第 $n+1$ 行中，每行都有 $m$ 个字符（只可能是’.’，’*’，’#’，’H’，其中’H’ 有且只有一个）。 \n\n在第 $n+2$ 行至第 $n+t+1$行中，每行有两个整数，分别表示 $a[i]$，$b[i]$（$a[i]$，$b[i]$不可能同时为 $0$）。 \n\n在第 $n+t+2$ 行包含一个正整数，表示 $q$。 \n\n在第 $n+t+3$ 行至第 $n+t+q+2$ 行共有 $q$ 个整数，表示他们所询问的时间点（即 $d[i]$）。 ", "outputFormat": "输出共 $q$ 行，对于每一个询问，输出他们所能走到的地点的个数。 ", "hint": "对于 20%的数据，满足 $n,m\\leq4$, $q\\leq100$；\n\n对于 70%的数据，满足 $n,m\\leq300$；\n\n对于 100%的数据，满足 $n,m\\leq1000$, $t\\leq5$, $q\\leq1000$, $0\\leq d[i]\\leq10^9$； \n\n\nHEOI 2012 Day2 Task3", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2012] Wilderness Expedition", "background": "Xiao H is an explorer. He has left his footprints on Mount Everest, the vast African savanna, and the beautiful yet frigid Antarctic continent. This time, he heads to the Amazon rainforest in South America, a place full of venomous insects, ferocious beasts, and all kinds of legends. He spent a lot of time preparing for this exciting expedition. Once ready, Xiao H and his assistant, led by a local guide, stepped into the rainforest.", "description": "Using a GPS system, they obtained a rough map of the rainforest. The map is an $n$-by-$m$ character grid: '.' denotes empty ground, '*' denotes impassable terrain, '#' denotes an area that needs to be cleared, and 'H' marks Xiao H's position, which is also empty ground.\n\nThere are $t$ types of movements, denoted by $a[i]$, $b[i]$ ($1 \\leq i \\leq t$). If they are currently at row $x$, column $y$, then their next position can be row $x + a[i]$, column $y + b[i]$, or the opposite direction, row $x - a[i]$, column $y - b[i]$. Each day, they may choose exactly one movement type and move a positive number of steps continuously in the forward or backward direction, then stop; they are not allowed to stay put.\n\nDuring that day’s movement, they may not enter any impassable cells ('*'). If they reach a cell marked '#', they stop moving immediately. For the rest of the day, they clear that cell; afterwards, it permanently becomes empty ground ('.').\n\nThey send you $q$ queries over the network, asking for the number of cells they can reach on day $d[i]$ ($1 \\leq i \\leq q$). It is guaranteed that there is no situation where they cannot move at all. Can you help them?", "inputFormat": "- The first line contains three positive integers $n$, $m$, and $t$.\n- Lines $2$ to $n+1$: each line contains $m$ characters (each is one of '.', '*', '#', 'H'; there is exactly one 'H').\n- Lines $n+2$ to $n+t+1$: each line contains two integers $a[i]$ and $b[i]$ (not both $0$).\n- Line $n+t+2$: a single integer $q$.\n- Lines $n+t+3$ to $n+t+q+2$: each of the next $q$ lines contains one integer $d[i]$, the queried day.", "outputFormat": "Output $q$ lines. For each query, output the number of cells that can be reached on day $d[i]$.", "hint": "Constraints:\n- For 20% of the testdata, $n, m \\leq 4$, $q \\leq 100$.\n- For 70% of the testdata, $n, m \\leq 300$.\n- For 100% of the testdata, $n, m \\leq 1000$, $t \\leq 5$, $q \\leq 1000$, $0 \\leq d[i] \\leq 10^9$.\n\nHEOI 2012 Day 2 Task 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2012] 野外探险", "background": "小 H 是一位探险家。在险峻的珠穆朗玛峰，原始辽阔的非洲大草原，美丽冻人的南极大陆等地方都留下过这位探险家的足迹。这次，他来到了位于南美洲充斥着大量毒虫猛兽的以及各式各样传说的亚马逊热带雨林进行探险。为此，他花了许多时间来准备这次激动人心的探险。在准备就绪后，小 H 和他的助手在当地导游的带领下踏入了这片雨林。 ", "description": "通过 GPS 定位系统，他们获得了雨林大致的地图。这个地图是一个 $n$ 行 $m$ 列的字符网格图，’.’表示的是空地，’*’表示的是不可通行的区域，’#’表示的是需要清理的区域，’H’表示小H所在的位置，该区域是空地。他们的移动方式有 $t$ 种，用$a[i]$,$b[i]$($1\\leq i\\leq t$)表示，假设他们所在的位置为第 $x$ 行第 $y$ 列，那么他们下一步的位置将是第 $x+a[i]$行第 $y+b[i]$列，也可以是反方向，即第 $x-a[i]$行第 $y-b[i]$列。小 H 一行人每天可在选择一种移动方式，朝着正方向或者反方向连续走若干步之后停下，不可以不走。在当天的行走过程中，他们不可以到达不可通行的区域，如果他们到达了一个需要清理的区域，他们会停止移动。为了以后探险的方便，他们会用该天剩下的时间来清理该区域，之后该区域将永久变成空地。\n\n现在，为了使探险活动顺利的进行，他们将 $q$ 个询问通过网络发送给了你，询问他们在第 $d[i]$($1\\leq i\\leq q$)天能到达的区域个数，题目保证不会有无路可走的情况。你能帮助他解决这个问题吗？ ", "inputFormat": "输入的第 $1$ 行包含三个正整数，分别表示 $n$、$m$、$t$。\n\n在第 $2$ 行至第 $n+1$ 行中，每行都有 $m$ 个字符（只可能是’.’，’*’，’#’，’H’，其中’H’ 有且只有一个）。 \n\n在第 $n+2$ 行至第 $n+t+1$行中，每行有两个整数，分别表示 $a[i]$，$b[i]$（$a[i]$，$b[i]$不可能同时为 $0$）。 \n\n在第 $n+t+2$ 行包含一个正整数，表示 $q$。 \n\n在第 $n+t+3$ 行至第 $n+t+q+2$ 行共有 $q$ 个整数，表示他们所询问的时间点（即 $d[i]$）。 ", "outputFormat": "输出共 $q$ 行，对于每一个询问，输出他们所能走到的地点的个数。 ", "hint": "对于 20%的数据，满足 $n,m\\leq4$, $q\\leq100$；\n\n对于 70%的数据，满足 $n,m\\leq300$；\n\n对于 100%的数据，满足 $n,m\\leq1000$, $t\\leq5$, $q\\leq1000$, $0\\leq d[i]\\leq10^9$； \n\n\nHEOI 2012 Day2 Task3", "locale": "zh-CN"}}}
{"pid": "P4602", "type": "P", "difficulty": 6, "samples": [["3 4\n1 3 5\n2 1 3\n3 2 5\n6 3\n5 3\n10 10\n20 10", "3\n2\n-1\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "线段树", "二分", "O2优化", "可持久化", "整体二分", "CTSC/CTS"], "title": "[CTSC2018] 混合果汁", "background": "", "description": "小 R 热衷于做黑暗料理，尤其是混合果汁。\n\n商店里有 $n$ 种果汁，编号为 $0,1,\\cdots,n-1$ 。$i$ 号果汁的美味度是 $d_i$，每升价格为 $p_i$。小 R 在制作混合果汁时，还有一些特殊的规定，即在一瓶混合果汁中，$i$ 号果汁最多只能添加 $l_i$ 升。\n\n现在有 $m$ 个小朋友过来找小 R 要混合果汁喝，他们都希望小 R 用商店里的果汁制作成一瓶混合果汁。其中，第 $j$ 个小朋友希望他得到的混合果汁总价格不大于 $g_j$，体积不小于 $L_j$。在上述这些限制条件下，小朋友们还希望混合果汁的美味度尽可能地高，一瓶混合果汁的美味度等于所有参与混合的果汁的美味度的最小值。请你计算每个小朋友能喝到的最美味的混合果汁的美味度。", "inputFormat": "输入第一行包含两个正整数 $n, m$，表示果汁的种数和小朋友的数量。\n\n接下来 $n$ 行，每行三个正整数 $d_i, p_i, l_i$，表示 $i$ 号果汁的美味度为 $d_i$，每升价格为 $p_i$，在一瓶果汁中的添加上限为 $l_i$。\n\n接下来 $m$ 行依次描述所有小朋友：每行两个数正整数 $g_j, L_j$ 描述一个小朋友，表示他最多能支付 $g_j$ 元钱，他想要至少 $L_j$ 升果汁。", "outputFormat": "对于所有小朋友依次输出：对于每个小朋友，输出一行，包含一个整数，表示他能喝到的最美味的混合果汁的美味度。如果无法满足他的需求，则输出 $-1$。\n", "hint": "对于所有的测试数据，保证 $n, m \\le 100000$，$1 \\le d_i,p_i,l_i \\le 10^5$，$1 \\le g_j, L_j \\le 10^{18}$。\n\n测试点编号|$n=$|$m=$|其他限制\n-|-|-|-\n$1,2,3$|$10$|$10$|无\n$4,5,6$|$500$|$500$|无\n$7,8,9$|$5000$|$5000$|无\n$10,11,12$|$100000$|$100000$|$p_i=1$\n$13,14,15$|$100000$|$100000$|$l_i=1$\n$16,17,18,19,20$|$100000$|$100000$|无", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2018] Mixed Juice", "background": "", "description": "Little R is obsessed with making “dark cuisine”, especially mixed juice.\n\nThere are $n$ kinds of juice in the store, numbered $0,1,\\cdots,n-1$. The deliciousness of juice $i$ is $d_i$, and its price per liter is $p_i$. When making mixed juice, Little R also has some special rules: in a bottle of mixed juice, juice $i$ can be added at most $l_i$ liters.\n\nNow $m$ children come to Little R for mixed juice. They all want Little R to use the juices in the store to make a bottle of mixed juice for them. For the $j$-th child, they want the total price of the mixed juice to be no more than $g_j$, and the volume to be at least $L_j$. Under these constraints, the children also hope the deliciousness of the mixed juice is as high as possible. The deliciousness of a bottle of mixed juice equals the minimum deliciousness among all juices that participate in the mixture. Please compute the highest deliciousness each child can get.", "inputFormat": "The first line contains two positive integers $n, m$, the number of kinds of juice and the number of children.\n\nThe next $n$ lines each contain three positive integers $d_i, p_i, l_i$, meaning the deliciousness of juice $i$ is $d_i$, its price per liter is $p_i$, and its addition limit in one bottle is $l_i$ liters.\n\nThe next $m$ lines describe all children: each line contains two positive integers $g_j, L_j$, meaning the $j$-th child can pay at most $g_j$ yuan, and wants at least $L_j$ liters of juice.", "outputFormat": "For all children in order, output one line for each child containing an integer, the highest deliciousness of the mixed juice they can drink. If their request cannot be satisfied, output $-1$.", "hint": "For all testdata, it is guaranteed that $n, m \\le 100000$, $1 \\le d_i,p_i,l_i \\le 10^5$, $1 \\le g_j, L_j \\le 10^{18}$.\n\n测试点编号|$n=$|$m=$|其他限制\n-|-|-|-\n$1,2,3$|$10$|$10$|None\n$4,5,6$|$500$|$500$|None\n$7,8,9$|$5000$|$5000$|None\n$10,11,12$|$100000$|$100000$|$p_i=1$\n$13,14,15$|$100000$|$100000$|$l_i=1$\n$16,17,18,19,20$|$100000$|$100000$|None\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2018] 混合果汁", "background": "", "description": "小 R 热衷于做黑暗料理，尤其是混合果汁。\n\n商店里有 $n$ 种果汁，编号为 $0,1,\\cdots,n-1$ 。$i$ 号果汁的美味度是 $d_i$，每升价格为 $p_i$。小 R 在制作混合果汁时，还有一些特殊的规定，即在一瓶混合果汁中，$i$ 号果汁最多只能添加 $l_i$ 升。\n\n现在有 $m$ 个小朋友过来找小 R 要混合果汁喝，他们都希望小 R 用商店里的果汁制作成一瓶混合果汁。其中，第 $j$ 个小朋友希望他得到的混合果汁总价格不大于 $g_j$，体积不小于 $L_j$。在上述这些限制条件下，小朋友们还希望混合果汁的美味度尽可能地高，一瓶混合果汁的美味度等于所有参与混合的果汁的美味度的最小值。请你计算每个小朋友能喝到的最美味的混合果汁的美味度。", "inputFormat": "输入第一行包含两个正整数 $n, m$，表示果汁的种数和小朋友的数量。\n\n接下来 $n$ 行，每行三个正整数 $d_i, p_i, l_i$，表示 $i$ 号果汁的美味度为 $d_i$，每升价格为 $p_i$，在一瓶果汁中的添加上限为 $l_i$。\n\n接下来 $m$ 行依次描述所有小朋友：每行两个数正整数 $g_j, L_j$ 描述一个小朋友，表示他最多能支付 $g_j$ 元钱，他想要至少 $L_j$ 升果汁。", "outputFormat": "对于所有小朋友依次输出：对于每个小朋友，输出一行，包含一个整数，表示他能喝到的最美味的混合果汁的美味度。如果无法满足他的需求，则输出 $-1$。\n", "hint": "对于所有的测试数据，保证 $n, m \\le 100000$，$1 \\le d_i,p_i,l_i \\le 10^5$，$1 \\le g_j, L_j \\le 10^{18}$。\n\n测试点编号|$n=$|$m=$|其他限制\n-|-|-|-\n$1,2,3$|$10$|$10$|无\n$4,5,6$|$500$|$500$|无\n$7,8,9$|$5000$|$5000$|无\n$10,11,12$|$100000$|$100000$|$p_i=1$\n$13,14,15$|$100000$|$100000$|$l_i=1$\n$16,17,18,19,20$|$100000$|$100000$|无", "locale": "zh-CN"}}}
{"pid": "P4603", "type": "P", "difficulty": 7, "samples": [["1\n2,?3,2?71?4420?2641?\n0 1 2 3 4 5 6 7 8 6 10 7 4 4 14 3 2 1 1 0", "2,13,207104420026411\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "O2优化", "CTSC/CTS"], "title": "[CTSC2018] 字典树", "background": "", "description": "Access Globe 有若干个**递增**的正整数序列。他把这些正整数序列中的每个正整数的十进制表示（无前导零）依次写了下来，相邻两个整数之间用逗号 , 隔开。Access Globe 把这个序列视为一个由 $0\\sim 9$ 的数字和逗号 , 组成的字符串，然后用一棵 Trie 树存储这些字符串。你并不需要知道 Trie 树究竟是什么，你只需要知道，Access Globe 得到的 Trie 是一棵以 $0$ 号节点为根的有根树，每条边上都有一个字符，并且从根到每个叶节点的路径上的边上的字符顺次拼接构成的字符串是一个他写下的一个递增的正整数序列。\n\n可爱的小 Tommy 决定篡改这棵 Trie 树。他先将 Trie 上的一些边上的字符删去，然后填上另一些字符。为了不被发现，Tommy 必须保证修改后的 Trie 仍然满足上述性 质，即从根到每个叶节点的路径上的边上的字符顺次拼接构成的字符串是一个递增的正整数序列，且每个正整数无前导零。\n\n现在 Tommy 已经删去了一些边上的字符，请你帮他完成“填上字符”的操作。如果有多解，请输出字典序最小的解。", "inputFormat": "输入文件包含多组数据，整个文件的第一行是一个整数 $T$，表示数据组数。对于每一组数据：\n\n第一行包含一个长度为 $n$ 的、仅包含 $0$ 到 $9$、, 和 `?` 的字符串，第 $i$ 个整数表示连接节点 $i$ 的父亲和节点 $i$ 的边上的字符，`?` 表示这条边上的字符已经被删去； 第二行包含 $n$ 个整数，第 $i$ 个整数表示节点 $i$ 的父亲节点 $f_i$，保证 $0 \\le f_i < i$。", "outputFormat": "输出 $T$ 行。对于每组数据，输出一个长度为 $n$ 的字符串，表示字典序最小的填写问号的方式中每个点的字符，第 $i$ 个整数表示节点 $i$ 的字符。\n\n如果不存在任何合法的填写方式，请输出 `failed`。\n", "hint": "### 样例解释\n\nTommy 填写的 Trie 如下图，红色的节点为所有叶子节点，注意，根节点在左下方。\n\n![](https://cdn.luogu.com.cn/upload/pic/19267.png)\n\n### 数据范围\n\n对于 $20\\%$ 的数据，$T \\le 10$，对于每组数据 $n \\le 80$ ，`?` 个数不超过 $8$；  \n对于另外 $10\\%$ 的数据，$T \\le 20$，对于每组数据 $n \\le 80$，$f_i=i-1$；  \n对于另外 $20\\%$ 的数据，$f_i=i-1$；  \n对于另外 $10\\%$ 的数据，$n \\le 80$；  \n对于所有数据，$T \\le 100$，对于每组数据 $n \\le 200$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2018] Trie", "background": "", "description": "Access Globe has several **strictly increasing** sequences of positive integers. He writes down the decimal representation (without leading zeros) of each positive integer in these sequences in order, separating every two adjacent integers with a comma `,`. Access Globe treats each such sequence as a string consisting of digits $0 \\sim 9$ and commas `,`, and then stores these strings in a Trie. You do not need to know what a Trie actually is. You only need to know that the Trie obtained by Access Globe is a rooted tree with node $0$ as the root, each edge labeled with a character, and for every path from the root to a leaf, the characters on the edges along the path, concatenated in order, form one of the strictly increasing positive integer sequences he wrote down.\n\nCute little Tommy decides to tamper with this Trie. He first deletes the characters on some edges of the Trie, and then fills in some other characters. To avoid being discovered, Tommy must ensure that the modified Trie still satisfies the property above: for every path from the root to a leaf, the characters on the edges along the path, concatenated in order, form a strictly increasing sequence of positive integers, and each positive integer has no leading zeros.\n\nNow Tommy has already deleted the characters on some edges. Please help him complete the “fill in characters” operation. If there are multiple solutions, output the lexicographically smallest one.", "inputFormat": "The input file contains multiple test cases. The first line of the file is an integer $T$, which indicates the number of test cases. For each test case:\n\nThe first line contains a string of length $n$ consisting only of `0` to `9`, `,`, and `?`. The $i$-th character represents the character on the edge connecting node $i$ and its parent. `?` means that the character on this edge has been deleted.  \nThe second line contains $n$ integers. The $i$-th integer represents the parent node $f_i$ of node $i$. It is guaranteed that $0 \\le f_i < i$.", "outputFormat": "Output $T$ lines. For each test case, output a string of length $n$, representing, among all ways to fill in the question marks, the lexicographically smallest one. The $i$-th character represents the character of node $i$.\n\nIf there is no valid way to fill in the characters, output `failed`.", "hint": "### Sample Explanation\n\nThe Trie filled in by Tommy is shown in the figure below. The red nodes are all leaf nodes. Note that the root node is at the lower left.\n\n![](https://cdn.luogu.com.cn/upload/pic/19267.png)\n\n### Constraints\n\nFor $20\\%$ of the testdata, $T \\le 10$, and for each test case $n \\le 80$, with the number of `?` not exceeding $8$;  \nFor another $10\\%$ of the testdata, $T \\le 20$, and for each test case $n \\le 80$, $f_i = i - 1$;  \nFor another $20\\%$ of the testdata, $f_i = i - 1$;  \nFor another $10\\%$ of the testdata, $n \\le 80$;  \nFor all testdata, $T \\le 100$, and for each test case $n \\le 200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2018] 字典树", "background": "", "description": "Access Globe 有若干个**递增**的正整数序列。他把这些正整数序列中的每个正整数的十进制表示（无前导零）依次写了下来，相邻两个整数之间用逗号 , 隔开。Access Globe 把这个序列视为一个由 $0\\sim 9$ 的数字和逗号 , 组成的字符串，然后用一棵 Trie 树存储这些字符串。你并不需要知道 Trie 树究竟是什么，你只需要知道，Access Globe 得到的 Trie 是一棵以 $0$ 号节点为根的有根树，每条边上都有一个字符，并且从根到每个叶节点的路径上的边上的字符顺次拼接构成的字符串是一个他写下的一个递增的正整数序列。\n\n可爱的小 Tommy 决定篡改这棵 Trie 树。他先将 Trie 上的一些边上的字符删去，然后填上另一些字符。为了不被发现，Tommy 必须保证修改后的 Trie 仍然满足上述性 质，即从根到每个叶节点的路径上的边上的字符顺次拼接构成的字符串是一个递增的正整数序列，且每个正整数无前导零。\n\n现在 Tommy 已经删去了一些边上的字符，请你帮他完成“填上字符”的操作。如果有多解，请输出字典序最小的解。", "inputFormat": "输入文件包含多组数据，整个文件的第一行是一个整数 $T$，表示数据组数。对于每一组数据：\n\n第一行包含一个长度为 $n$ 的、仅包含 $0$ 到 $9$、, 和 `?` 的字符串，第 $i$ 个整数表示连接节点 $i$ 的父亲和节点 $i$ 的边上的字符，`?` 表示这条边上的字符已经被删去； 第二行包含 $n$ 个整数，第 $i$ 个整数表示节点 $i$ 的父亲节点 $f_i$，保证 $0 \\le f_i < i$。", "outputFormat": "输出 $T$ 行。对于每组数据，输出一个长度为 $n$ 的字符串，表示字典序最小的填写问号的方式中每个点的字符，第 $i$ 个整数表示节点 $i$ 的字符。\n\n如果不存在任何合法的填写方式，请输出 `failed`。\n", "hint": "### 样例解释\n\nTommy 填写的 Trie 如下图，红色的节点为所有叶子节点，注意，根节点在左下方。\n\n![](https://cdn.luogu.com.cn/upload/pic/19267.png)\n\n### 数据范围\n\n对于 $20\\%$ 的数据，$T \\le 10$，对于每组数据 $n \\le 80$ ，`?` 个数不超过 $8$；  \n对于另外 $10\\%$ 的数据，$T \\le 20$，对于每组数据 $n \\le 80$，$f_i=i-1$；  \n对于另外 $20\\%$ 的数据，$f_i=i-1$；  \n对于另外 $10\\%$ 的数据，$n \\le 80$；  \n对于所有数据，$T \\le 100$，对于每组数据 $n \\le 200$。", "locale": "zh-CN"}}}
{"pid": "P4604", "type": "P", "difficulty": 7, "samples": [["1\n100000 2017012501", "4275990336"], ["2\n6 6\n200100\n200211\n5 3 1\n2 0 1\n2 0 3\n2 0 2\n2 3 4\n0 1 3", "3349208141"], ["3\n4\n(???", "2"], ["3\n4\n)???", "0"]], "limits": {"time": [3000, 4000, 6000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2017", "O2优化", "WC"], "title": "[WC2017] 挑战", "background": "### 洛谷不保证此类毒瘤题的评测结果准确性。\n\n你和同学们找了三道题目用来练习。\n\n这次练习的目标是写出能在时间限制里通过尽量大规模数据的代码。\n\n同学们纷纷写出了优秀的代码。现在，他们向你发起了挑战，他们对每个问题都设置了若干个测试数据，这是他们能通过的最大规模的测试数据。现在，他们想看一看你写的代码究竟能超过多少同学的代码，通过多大规模的测试数据。\n\n本题分为 $3$ 个任务，每个任务对应一道题和相应的若干个测试点，你需要对于每个任务，设计一个能通过尽量多测试点的程序。", "description": "## 任务一\n\n给定 $n$ 个 $32$ 位无符号整数，将它们从小到大排序。\n\n## 任务二\n\n有 $2n$ 个人在玩 「石头剪刀布」 游戏。他们排成两排，每排 $n$ 个人。每个人在每一局游戏都使用固定策略，即对于第 $i (i \\in 1, 2)$ 排的第 $j (0 \\leq j < n)$ 个人，用一个整数 $a_{ij}$ 表示他的策略，其中 $0$ 表示只出石头，$1$ 表示只出剪刀，$2$ 表示只出布。\n\n现在有 $q$ 个询问，每个询问给定三个整数 $x,y,l(0\\leq x,y<n,1\\leq l\\leq n-max(x,y))$， 问将第一排的第 $x∼x+l-1$ 个人和第二排的第 $y∼y+l-1$ 个人比赛之后，第一排有多少个人会赢。\n\n上文中 「比赛」 的意思是，对于所有整数 $i$ 满足 $0\\leq i<l$,让第一排的第 $x+i$ 个人和 第二排的第 $y+i$ 个人进行 「石头剪刀布」 游戏。\n\n## 任务三\n\n我们称一个合法的括号串为：只由左括号和右括号构成，两种括号的数量相等， 且任意一个前缀的左括号数量不少于右括号数量的串。现在给定一个由 ```(```，```)``` 和```?``` 构成的串，问有多少种不同的方案，使得将每个 ```?``` 都替换成一个括号之后，该串变成一 个合法的括号串。两种方案不同，当且仅当至少有一个位置的 ```?``` 被替换成了不同的括号。", "inputFormat": "此题提供了模板程序。选手可以在此基础上编写自己的程序，模板程序详见下文数据范围与提示。\n\n第一行一个整数$ task\\_id(1\\leq task\\_id\\leq3)$，表示任务编号。接下来是每个具体任务的输入内容。\n\n在输入的同一行中，相邻的两个整数会被一个空格隔开。\n\n对于任务一：一行，两个整数 $n,s$。令 $a_0=next\\_integer(s),a_i=next\\_integer(a_{i-1}),1\\leq i<n$，则 $a_0,a_1,…,a_{n-1}$ 即为需要排序的 $n$ 个整数。\n\n对于任务二：第一行两个整数 $n,q$。第二行一个仅包含 $0, 1, 2$ 的长度为 $n$ 的字符串，第 $i$ 个字符所代表的整数表示第一排第 $i$ 个人的策略（即 $a_{1i}$​​）。第三行格式同第二行，表示第二排各个人的策略。\n\n对于任务三：第一行一个整数 $n$，表示给定的串的长度。第二行一个字符串，即为给定的串。", "outputFormat": "对于任务1：令 $b$ 为已经排好序的数组，调用 ```output_arr(b, n * 4)``` 即可。\n\n对于任务2：将每个询问的答案依次存入 $32$ 位无符号整数数组 $b$ 中（即，存入 $b_0,b_1,⋯,b_{q-1}$ 中），然后调用 ```output_arr(b, q * 4)``` 即可。\n\n对于任务3：输出一个整数，表示不同的方案数除以 $2^{32}$​​ 得到的余数。", "hint": "## 数据范围与提示\n\n| 任务编号 | 分值 | 测试点编号 | 数据范围与约定 | 时间限制 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| 1 | 5 | 1 | $n=100000$ | 3s |\n| 1 | 19 | 2 | $n=10^8$ | 4s |\n| 1 | 11 | 3 | $n=2\\times10^8$ | 6s |\n| 2 | 7 | 4 | $n=q=1000$ | 3s |\n| 2 | 23 | 5 | $n=q=300000$ | 3s |\n| 3 | 9 | 6 | $n=1000$ | 3s |\n| 3 | 5 | 7 | $n=120000$ | 3s |\n| 3 | 7 | 8 | $n=225000$ | 3s |\n| 3 | 14 | 9 | $n=266666$ | 3s |\n\n\n## 模板程序\n\n### C++模板\n\n```\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n\ninline u32 next_integer(u32 x) {\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return x;\n}\n\nbool output_arr(void *a, u32 size) {\n    if (size % 4) {\n        return puts(\"-1\"), 0;\n    }\n\n    u32 blocks = size / 4;\n    u32 *A = (u32 *)a;\n    u32 ret = size;\n    u32 x = 23333333;\n    for (u32 i = 0; i < blocks; i++) {\n        ret = ret ^ (A[i] + x);\n        x ^= x << 13;\n        x ^= x >> 17;\n        x ^= x << 5;\n    }\n\n    return printf(\"%u\\n\", ret), 1;\n}\n\n// ===== header ======\n\nnamespace Sorting {\nvoid init_data(u32 *a, int n, u32 seed) {\n    for (int i = 0; i < n; i++) {\n        seed = next_integer(seed);\n        a[i] = seed;\n    }\n}\n\nvoid main() {\n    int n;\n    u32 seed;\n    scanf(\"%d%u\", &n, &seed);\n\n    u32 *a = new u32[n];\n    init_data(a, n, seed);\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\n}\n}\n\nnamespace Game {\nvoid main() {\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n\n    char *s1 = new char[n + 1];\n    char *s2 = new char[n + 1];\n    scanf(\"%s%s\", s1, s2);\n\n    u32 *anss = new u32[q];\n    int *q_x = new int[q];\n    int *q_y = new int[q];\n    int *q_len = new int[q];\n\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d%d%d\", q_x + i, q_y + i, q_len + i);\n    }\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\n}\n}\n\nnamespace Parentheses {\nvoid main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char *s = new char[n + 1];\n    scanf(\"%s\", s);\n\n    u32 ans;\n    // ans = solve(n, s);\n\n    printf(\"%u\\n\", ans);\n}\n}\n\nint main() {\n    int task_id;\n    scanf(\"%d\", &task_id);\n\n    switch (task_id) {\n        case 1:\n            Sorting::main();\n            break;\n        case 2:\n            Game::main();\n            break;\n        case 3:\n            Parentheses::main();\n            break;\n    }\n\n    return 0;\n}\n```\n\n### C模板\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define bool int\n#define true 1\n#define false 0\n\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n\ninline u32 next_integer(u32 x) {\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return x;\n}\n\nbool output_arr(void *a, u32 size) {\n    if (size % 4) {\n        return puts(\"-1\"), 0;\n    }\n\n    u32 blocks = size / 4;\n    u32 *A = (u32 *)a;\n    u32 ret = size;\n    u32 x = 23333333;\n    u32 i;\n    for (i = 0; i < blocks; i++) {\n        ret = ret ^ (A[i] + x);\n        x ^= x << 13;\n        x ^= x >> 17;\n        x ^= x << 5;\n    }\n\n    return printf(\"%u\\n\", ret), 1;\n}\n\n// ===== header ======\n\nvoid Sorting_main() {\n    int n;\n    u32 seed;\n    scanf(\"%d%u\", &n, &seed);\n\n    u32 *a = malloc(n * sizeof(u32));\n    int i;\n    for (i = 0; i < n; i++) {\n        seed = next_integer(seed);\n        a[i] = seed;\n    }\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\n}\n\nvoid Game_main() {\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n\n    char *s1 = malloc((n + 1) * sizeof(char));\n    char *s2 = malloc((n + 1) * sizeof(char));\n    scanf(\"%s%s\", s1, s2);\n\n    u32 *anss = malloc(q * sizeof(u32));\n    int *q_x = malloc(q * sizeof(int));\n    int *q_y = malloc(q * sizeof(int));\n    int *q_len = malloc(q * sizeof(int));\n\n    int i;\n\n    for (i = 0; i < q; i++) {\n        scanf(\"%d%d%d\", q_x + i, q_y + i, q_len + i);\n    }\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\n}\n\nvoid Parentheses_main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char *s = malloc((n + 1) * sizeof(char));\n    scanf(\"%s\", s);\n\n    u32 ans;\n    // ans = solve(n, s);\n\n    printf(\"%u\\n\", ans);\n}\n\nint main() {\n    int task_id;\n    scanf(\"%d\", &task_id);\n\n    switch (task_id) {\n        case 1:\n            Sorting_main();\n            break;\n        case 2:\n            Game_main();\n            break;\n        case 3:\n            Parentheses_main();\n            break;\n    }\n\n    return 0;\n}\n```\n\n### Pascal模板\n\n```\ntype\n    u32 = dword;\n    u64 = qword;\n    u32_p = ^u32;\n    u64_p = ^u64;\n    longint_p = ^longint;\n\nfunction next_integer(x : u32) : u32; inline;\nbegin\n    x := x xor (x << 13);\n    x := x xor (x >> 17);\n    x := x xor (x << 5);\n    exit(x);\nend;\n\nfunction output_arr(a_in : pointer; size : u32) : boolean;\nvar\n    blocks : u32;\n    a, a_ed : u32_p;\n    ret, x : u32;\nbegin\n    if size mod 4 <> 0 then begin\n        writeln(-1);\n        exit(false);\n    end;\n\n    blocks := size div 4;\n    ret := size;\n    a := a_in;\n    a_ed := a + blocks;\n    x := 23333333;\n\n    while a < a_ed do begin\n        ret := ret xor (a[0] + x);\n        x := x xor (x << 13);\n        x := x xor (x >> 17);\n        x := x xor (x << 5);\n        inc(a);\n    end;\n\n    writeln(ret);\n    exit(true);\nend;\n\n// ====== header ======\n\n\nprocedure init_data(a : u32_p; n : longint; seed : u32);\nvar\n    a_ed : u32_p;\nbegin\n    a_ed := a + n;\n    while a < a_ed do begin\n        seed := next_integer(seed);\n        a[0] := seed;\n        inc(a);\n    end;\nend;\n\nprocedure Sorting_main();\nvar\n    n : longint;\n    seed : u32;\n    a : u32_p;\n    i : u32;\nbegin\n    read(n, seed);\n\n    a := Getmem(n * sizeof(u32));\n    init_data(a, n, seed);\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\nend;\n\n\nprocedure Game_main();\nvar\n    n, q : longint;\n    s1, s2 : ansistring;\n    anss : u32_p;\n    q_x, q_y, q_len : longint_p;\n    i : longint;\nbegin\n    readln(n, q);\n    readln(s1);\n    readln(s2);\n\n    anss := Getmem(q * sizeof(u32));\n    q_x := Getmem(q * sizeof(longint));\n    q_y := Getmem(q * sizeof(longint));\n    q_len := Getmem(q * sizeof(longint));\n\n    for i := 0 to q - 1 do begin\n        read(q_x[i], q_y[i], q_len[i]);\n    end;\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\nend;\n\n\nprocedure Parentheses_main();\nvar\n    n : longint;\n    s : ansistring;\n    ans : u32;\nbegin\n    read(n);\n    read(s);\n\n    // ans := solve(n, s);\n\n    writeln(ans);\nend;\n\n\nvar\n    task_id : longint;\n\nbegin\n    read(task_id);\n\n    if task_id = 1 then begin\n        Sorting_main();\n    end else if task_id = 2 then begin\n        Game_main();\n    end else if task_id = 3 then begin\n        Parentheses_main();\n    end;\n    close(input); close(output);\nend.\n```", "locale": "zh-CN", "translations": {"en": {"title": "[WC2017] Challenge", "background": "### Luogu does not guarantee the accuracy of judging results for this kind of extremely tricky problem.\n\nYou and your classmates found three problems to practice.\n\nThe goal of this practice is to write code that can pass testdata of as large a size as possible within the time limit.\n\nYour classmates have written excellent code. Now, they challenge you: for each problem, they have prepared several test cases, representing the largest-scale testdata that their own code can pass. Now, they want to see how many classmates’ code your program can outperform, and how large-scale testdata it can pass.\n\nThis problem is divided into $3$ tasks. Each task corresponds to one problem and its related test points. For each task, you need to design a program that can pass as many test points as possible.", "description": "## Task 1\n\nGiven $n$ $32$-bit unsigned integers, sort them in non-decreasing order.\n\n## Task 2\n\nThere are $2n$ people playing Rock-Paper-Scissors. They stand in two rows, with $n$ people in each row. Each person uses a fixed strategy in every round. Specifically, for the $j$-th person $(0 \\leq j < n)$ in row $i$ $(i \\in 1, 2)$, use an integer $a_{ij}$ to represent their strategy, where $0$ means always play Rock, $1$ means always play Scissors, and $2$ means always play Paper.\n\nNow there are $q$ queries. Each query gives three integers $x, y, l(0\\leq x,y<n,1\\leq l\\leq n-max(x,y))$, asking: after the people from $x \\sim x+l-1$ in the first row play against the people from $y \\sim y+l-1$ in the second row, how many people in the first row will win.\n\nHere, “play against” means: for all integers $i$ such that $0 \\leq i < l$, let the person at position $x+i$ in the first row play Rock-Paper-Scissors against the person at position $y+i$ in the second row.\n\n## Task 3\n\nWe call a bracket sequence valid if it consists only of left and right parentheses, the numbers of the two types are equal, and in any prefix the number of left parentheses is not less than the number of right parentheses. Now you are given a string consisting of ```(```, ``` )``` and ```?```. How many different ways are there to replace each ```?``` with a parenthesis so that the string becomes a valid bracket sequence. Two ways are different if and only if there is at least one position where ```?``` is replaced by different parentheses.", "inputFormat": "This problem provides template code. Contestants may write their program based on it. The template code is shown below in the Constraints and Hint section.\n\nThe first line contains one integer $task\\_id(1\\leq task\\_id\\leq3)$, indicating the task number. The following input depends on the specific task.\n\nIn the same input line, any two adjacent integers are separated by a single space.\n\nFor Task 1: one line with two integers $n, s$. Let $a_0=next\\_integer(s),a_i=next\\_integer(a_{i-1}),1\\leq i<n$. Then $a_0,a_1,\\ldots,a_{n-1}$ are the $n$ integers to be sorted.\n\nFor Task 2: the first line contains two integers $n, q$. The second line contains a string of length $n$ consisting only of $0, 1, 2$. The integer represented by the $i$-th character is the strategy of the $i$-th person in the first row (i.e., $a_{1i}$). The third line has the same format as the second line, representing the strategies of the people in the second row.\n\nFor Task 3: the first line contains one integer $n$, the length of the given string. The second line contains one string, which is the given string.", "outputFormat": "For Task 1: let $b$ be the sorted array, and call ```output_arr(b, n * 4)```.\n\nFor Task 2: store the answer of each query in order into a $32$-bit unsigned integer array $b$ (i.e., into $b_0,b_1,\\cdots,b_{q-1}$), then call ```output_arr(b, q * 4)```.\n\nFor Task 3: output one integer, which is the remainder of the number of different ways modulo $2^{32}$.", "hint": "## Constraints and Hint\n\n| Task ID | Score | Test Point ID | Constraints and Notes | Time Limit |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| 1 | 5 | 1 | $n=100000$ | 3s |\n| 1 | 19 | 2 | $n=10^8$ | 4s |\n| 1 | 11 | 3 | $n=2\\times10^8$ | 6s |\n| 2 | 7 | 4 | $n=q=1000$ | 3s |\n| 2 | 23 | 5 | $n=q=300000$ | 3s |\n| 3 | 9 | 6 | $n=1000$ | 3s |\n| 3 | 5 | 7 | $n=120000$ | 3s |\n| 3 | 7 | 8 | $n=225000$ | 3s |\n| 3 | 14 | 9 | $n=266666$ | 3s |\n\n## Template Code\n\n### C++ Template\n\n```\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n\ninline u32 next_integer(u32 x) {\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return x;\n}\n\nbool output_arr(void *a, u32 size) {\n    if (size % 4) {\n        return puts(\"-1\"), 0;\n    }\n\n    u32 blocks = size / 4;\n    u32 *A = (u32 *)a;\n    u32 ret = size;\n    u32 x = 23333333;\n    for (u32 i = 0; i < blocks; i++) {\n        ret = ret ^ (A[i] + x);\n        x ^= x << 13;\n        x ^= x >> 17;\n        x ^= x << 5;\n    }\n\n    return printf(\"%u\\n\", ret), 1;\n}\n\n// ===== header ======\n\nnamespace Sorting {\nvoid init_data(u32 *a, int n, u32 seed) {\n    for (int i = 0; i < n; i++) {\n        seed = next_integer(seed);\n        a[i] = seed;\n    }\n}\n\nvoid main() {\n    int n;\n    u32 seed;\n    scanf(\"%d%u\", &n, &seed);\n\n    u32 *a = new u32[n];\n    init_data(a, n, seed);\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\n}\n}\n\nnamespace Game {\nvoid main() {\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n\n    char *s1 = new char[n + 1];\n    char *s2 = new char[n + 1];\n    scanf(\"%s%s\", s1, s2);\n\n    u32 *anss = new u32[q];\n    int *q_x = new int[q];\n    int *q_y = new int[q];\n    int *q_len = new int[q];\n\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d%d%d\", q_x + i, q_y + i, q_len + i);\n    }\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\n}\n}\n\nnamespace Parentheses {\nvoid main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char *s = new char[n + 1];\n    scanf(\"%s\", s);\n\n    u32 ans;\n    // ans = solve(n, s);\n\n    printf(\"%u\\n\", ans);\n}\n}\n\nint main() {\n    int task_id;\n    scanf(\"%d\", &task_id);\n\n    switch (task_id) {\n        case 1:\n            Sorting::main();\n            break;\n        case 2:\n            Game::main();\n            break;\n        case 3:\n            Parentheses::main();\n            break;\n    }\n\n    return 0;\n}\n```\n\n### C Template\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define bool int\n#define true 1\n#define false 0\n\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n\ninline u32 next_integer(u32 x) {\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return x;\n}\n\nbool output_arr(void *a, u32 size) {\n    if (size % 4) {\n        return puts(\"-1\"), 0;\n    }\n\n    u32 blocks = size / 4;\n    u32 *A = (u32 *)a;\n    u32 ret = size;\n    u32 x = 23333333;\n    u32 i;\n    for (i = 0; i < blocks; i++) {\n        ret = ret ^ (A[i] + x);\n        x ^= x << 13;\n        x ^= x >> 17;\n        x ^= x << 5;\n    }\n\n    return printf(\"%u\\n\", ret), 1;\n}\n\n// ===== header ======\n\nvoid Sorting_main() {\n    int n;\n    u32 seed;\n    scanf(\"%d%u\", &n, &seed);\n\n    u32 *a = malloc(n * sizeof(u32));\n    int i;\n    for (i = 0; i < n; i++) {\n        seed = next_integer(seed);\n        a[i] = seed;\n    }\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\n}\n\nvoid Game_main() {\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n\n    char *s1 = malloc((n + 1) * sizeof(char));\n    char *s2 = malloc((n + 1) * sizeof(char));\n    scanf(\"%s%s\", s1, s2);\n\n    u32 *anss = malloc(q * sizeof(u32));\n    int *q_x = malloc(q * sizeof(int));\n    int *q_y = malloc(q * sizeof(int));\n    int *q_len = malloc(q * sizeof(int));\n\n    int i;\n\n    for (i = 0; i < q; i++) {\n        scanf(\"%d%d%d\", q_x + i, q_y + i, q_len + i);\n    }\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\n}\n\nvoid Parentheses_main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char *s = malloc((n + 1) * sizeof(char));\n    scanf(\"%s\", s);\n\n    u32 ans;\n    // ans = solve(n, s);\n\n    printf(\"%u\\n\", ans);\n}\n\nint main() {\n    int task_id;\n    scanf(\"%d\", &task_id);\n\n    switch (task_id) {\n        case 1:\n            Sorting_main();\n            break;\n        case 2:\n            Game_main();\n            break;\n        case 3:\n            Parentheses_main();\n            break;\n    }\n\n    return 0;\n}\n```\n\n### Pascal Template\n\n```\ntype\n    u32 = dword;\n    u64 = qword;\n    u32_p = ^u32;\n    u64_p = ^u64;\n    longint_p = ^longint;\n\nfunction next_integer(x : u32) : u32; inline;\nbegin\n    x := x xor (x << 13);\n    x := x xor (x >> 17);\n    x := x xor (x << 5);\n    exit(x);\nend;\n\nfunction output_arr(a_in : pointer; size : u32) : boolean;\nvar\n    blocks : u32;\n    a, a_ed : u32_p;\n    ret, x : u32;\nbegin\n    if size mod 4 <> 0 then begin\n        writeln(-1);\n        exit(false);\n    end;\n\n    blocks := size div 4;\n    ret := size;\n    a := a_in;\n    a_ed := a + blocks;\n    x := 23333333;\n\n    while a < a_ed do begin\n        ret := ret xor (a[0] + x);\n        x := x xor (x << 13);\n        x := x xor (x >> 17);\n        x := x xor (x << 5);\n        inc(a);\n    end;\n\n    writeln(ret);\n    exit(true);\nend;\n\n// ====== header ======\n\n\nprocedure init_data(a : u32_p; n : longint; seed : u32);\nvar\n    a_ed : u32_p;\nbegin\n    a_ed := a + n;\n    while a < a_ed do begin\n        seed := next_integer(seed);\n        a[0] := seed;\n        inc(a);\n    end;\nend;\n\nprocedure Sorting_main();\nvar\n    n : longint;\n    seed : u32;\n    a : u32_p;\n    i : u32;\nbegin\n    read(n, seed);\n\n    a := Getmem(n * sizeof(u32));\n    init_data(a, n, seed);\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\nend;\n\n\nprocedure Game_main();\nvar\n    n, q : longint;\n    s1, s2 : ansistring;\n    anss : u32_p;\n    q_x, q_y, q_len : longint_p;\n    i : longint;\nbegin\n    readln(n, q);\n    readln(s1);\n    readln(s2);\n\n    anss := Getmem(q * sizeof(u32));\n    q_x := Getmem(q * sizeof(longint));\n    q_y := Getmem(q * sizeof(longint));\n    q_len := Getmem(q * sizeof(longint));\n\n    for i := 0 to q - 1 do begin\n        read(q_x[i], q_y[i], q_len[i]);\n    end;\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\nend;\n\n\nprocedure Parentheses_main();\nvar\n    n : longint;\n    s : ansistring;\n    ans : u32;\nbegin\n    read(n);\n    read(s);\n\n    // ans := solve(n, s);\n\n    writeln(ans);\nend;\n\n\nvar\n    task_id : longint;\n\nbegin\n    read(task_id);\n\n    if task_id = 1 then begin\n        Sorting_main();\n    end else if task_id = 2 then begin\n        Game_main();\n    end else if task_id = 3 then begin\n        Parentheses_main();\n    end;\n    close(input); close(output);\nend.\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2017] 挑战", "background": "### 洛谷不保证此类毒瘤题的评测结果准确性。\n\n你和同学们找了三道题目用来练习。\n\n这次练习的目标是写出能在时间限制里通过尽量大规模数据的代码。\n\n同学们纷纷写出了优秀的代码。现在，他们向你发起了挑战，他们对每个问题都设置了若干个测试数据，这是他们能通过的最大规模的测试数据。现在，他们想看一看你写的代码究竟能超过多少同学的代码，通过多大规模的测试数据。\n\n本题分为 $3$ 个任务，每个任务对应一道题和相应的若干个测试点，你需要对于每个任务，设计一个能通过尽量多测试点的程序。", "description": "## 任务一\n\n给定 $n$ 个 $32$ 位无符号整数，将它们从小到大排序。\n\n## 任务二\n\n有 $2n$ 个人在玩 「石头剪刀布」 游戏。他们排成两排，每排 $n$ 个人。每个人在每一局游戏都使用固定策略，即对于第 $i (i \\in 1, 2)$ 排的第 $j (0 \\leq j < n)$ 个人，用一个整数 $a_{ij}$ 表示他的策略，其中 $0$ 表示只出石头，$1$ 表示只出剪刀，$2$ 表示只出布。\n\n现在有 $q$ 个询问，每个询问给定三个整数 $x,y,l(0\\leq x,y<n,1\\leq l\\leq n-max(x,y))$， 问将第一排的第 $x∼x+l-1$ 个人和第二排的第 $y∼y+l-1$ 个人比赛之后，第一排有多少个人会赢。\n\n上文中 「比赛」 的意思是，对于所有整数 $i$ 满足 $0\\leq i<l$,让第一排的第 $x+i$ 个人和 第二排的第 $y+i$ 个人进行 「石头剪刀布」 游戏。\n\n## 任务三\n\n我们称一个合法的括号串为：只由左括号和右括号构成，两种括号的数量相等， 且任意一个前缀的左括号数量不少于右括号数量的串。现在给定一个由 ```(```，```)``` 和```?``` 构成的串，问有多少种不同的方案，使得将每个 ```?``` 都替换成一个括号之后，该串变成一 个合法的括号串。两种方案不同，当且仅当至少有一个位置的 ```?``` 被替换成了不同的括号。", "inputFormat": "此题提供了模板程序。选手可以在此基础上编写自己的程序，模板程序详见下文数据范围与提示。\n\n第一行一个整数$ task\\_id(1\\leq task\\_id\\leq3)$，表示任务编号。接下来是每个具体任务的输入内容。\n\n在输入的同一行中，相邻的两个整数会被一个空格隔开。\n\n对于任务一：一行，两个整数 $n,s$。令 $a_0=next\\_integer(s),a_i=next\\_integer(a_{i-1}),1\\leq i<n$，则 $a_0,a_1,…,a_{n-1}$ 即为需要排序的 $n$ 个整数。\n\n对于任务二：第一行两个整数 $n,q$。第二行一个仅包含 $0, 1, 2$ 的长度为 $n$ 的字符串，第 $i$ 个字符所代表的整数表示第一排第 $i$ 个人的策略（即 $a_{1i}$​​）。第三行格式同第二行，表示第二排各个人的策略。\n\n对于任务三：第一行一个整数 $n$，表示给定的串的长度。第二行一个字符串，即为给定的串。", "outputFormat": "对于任务1：令 $b$ 为已经排好序的数组，调用 ```output_arr(b, n * 4)``` 即可。\n\n对于任务2：将每个询问的答案依次存入 $32$ 位无符号整数数组 $b$ 中（即，存入 $b_0,b_1,⋯,b_{q-1}$ 中），然后调用 ```output_arr(b, q * 4)``` 即可。\n\n对于任务3：输出一个整数，表示不同的方案数除以 $2^{32}$​​ 得到的余数。", "hint": "## 数据范围与提示\n\n| 任务编号 | 分值 | 测试点编号 | 数据范围与约定 | 时间限制 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| 1 | 5 | 1 | $n=100000$ | 3s |\n| 1 | 19 | 2 | $n=10^8$ | 4s |\n| 1 | 11 | 3 | $n=2\\times10^8$ | 6s |\n| 2 | 7 | 4 | $n=q=1000$ | 3s |\n| 2 | 23 | 5 | $n=q=300000$ | 3s |\n| 3 | 9 | 6 | $n=1000$ | 3s |\n| 3 | 5 | 7 | $n=120000$ | 3s |\n| 3 | 7 | 8 | $n=225000$ | 3s |\n| 3 | 14 | 9 | $n=266666$ | 3s |\n\n\n## 模板程序\n\n### C++模板\n\n```\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n\ninline u32 next_integer(u32 x) {\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return x;\n}\n\nbool output_arr(void *a, u32 size) {\n    if (size % 4) {\n        return puts(\"-1\"), 0;\n    }\n\n    u32 blocks = size / 4;\n    u32 *A = (u32 *)a;\n    u32 ret = size;\n    u32 x = 23333333;\n    for (u32 i = 0; i < blocks; i++) {\n        ret = ret ^ (A[i] + x);\n        x ^= x << 13;\n        x ^= x >> 17;\n        x ^= x << 5;\n    }\n\n    return printf(\"%u\\n\", ret), 1;\n}\n\n// ===== header ======\n\nnamespace Sorting {\nvoid init_data(u32 *a, int n, u32 seed) {\n    for (int i = 0; i < n; i++) {\n        seed = next_integer(seed);\n        a[i] = seed;\n    }\n}\n\nvoid main() {\n    int n;\n    u32 seed;\n    scanf(\"%d%u\", &n, &seed);\n\n    u32 *a = new u32[n];\n    init_data(a, n, seed);\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\n}\n}\n\nnamespace Game {\nvoid main() {\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n\n    char *s1 = new char[n + 1];\n    char *s2 = new char[n + 1];\n    scanf(\"%s%s\", s1, s2);\n\n    u32 *anss = new u32[q];\n    int *q_x = new int[q];\n    int *q_y = new int[q];\n    int *q_len = new int[q];\n\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d%d%d\", q_x + i, q_y + i, q_len + i);\n    }\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\n}\n}\n\nnamespace Parentheses {\nvoid main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char *s = new char[n + 1];\n    scanf(\"%s\", s);\n\n    u32 ans;\n    // ans = solve(n, s);\n\n    printf(\"%u\\n\", ans);\n}\n}\n\nint main() {\n    int task_id;\n    scanf(\"%d\", &task_id);\n\n    switch (task_id) {\n        case 1:\n            Sorting::main();\n            break;\n        case 2:\n            Game::main();\n            break;\n        case 3:\n            Parentheses::main();\n            break;\n    }\n\n    return 0;\n}\n```\n\n### C模板\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define bool int\n#define true 1\n#define false 0\n\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n\ninline u32 next_integer(u32 x) {\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return x;\n}\n\nbool output_arr(void *a, u32 size) {\n    if (size % 4) {\n        return puts(\"-1\"), 0;\n    }\n\n    u32 blocks = size / 4;\n    u32 *A = (u32 *)a;\n    u32 ret = size;\n    u32 x = 23333333;\n    u32 i;\n    for (i = 0; i < blocks; i++) {\n        ret = ret ^ (A[i] + x);\n        x ^= x << 13;\n        x ^= x >> 17;\n        x ^= x << 5;\n    }\n\n    return printf(\"%u\\n\", ret), 1;\n}\n\n// ===== header ======\n\nvoid Sorting_main() {\n    int n;\n    u32 seed;\n    scanf(\"%d%u\", &n, &seed);\n\n    u32 *a = malloc(n * sizeof(u32));\n    int i;\n    for (i = 0; i < n; i++) {\n        seed = next_integer(seed);\n        a[i] = seed;\n    }\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\n}\n\nvoid Game_main() {\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n\n    char *s1 = malloc((n + 1) * sizeof(char));\n    char *s2 = malloc((n + 1) * sizeof(char));\n    scanf(\"%s%s\", s1, s2);\n\n    u32 *anss = malloc(q * sizeof(u32));\n    int *q_x = malloc(q * sizeof(int));\n    int *q_y = malloc(q * sizeof(int));\n    int *q_len = malloc(q * sizeof(int));\n\n    int i;\n\n    for (i = 0; i < q; i++) {\n        scanf(\"%d%d%d\", q_x + i, q_y + i, q_len + i);\n    }\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\n}\n\nvoid Parentheses_main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char *s = malloc((n + 1) * sizeof(char));\n    scanf(\"%s\", s);\n\n    u32 ans;\n    // ans = solve(n, s);\n\n    printf(\"%u\\n\", ans);\n}\n\nint main() {\n    int task_id;\n    scanf(\"%d\", &task_id);\n\n    switch (task_id) {\n        case 1:\n            Sorting_main();\n            break;\n        case 2:\n            Game_main();\n            break;\n        case 3:\n            Parentheses_main();\n            break;\n    }\n\n    return 0;\n}\n```\n\n### Pascal模板\n\n```\ntype\n    u32 = dword;\n    u64 = qword;\n    u32_p = ^u32;\n    u64_p = ^u64;\n    longint_p = ^longint;\n\nfunction next_integer(x : u32) : u32; inline;\nbegin\n    x := x xor (x << 13);\n    x := x xor (x >> 17);\n    x := x xor (x << 5);\n    exit(x);\nend;\n\nfunction output_arr(a_in : pointer; size : u32) : boolean;\nvar\n    blocks : u32;\n    a, a_ed : u32_p;\n    ret, x : u32;\nbegin\n    if size mod 4 <> 0 then begin\n        writeln(-1);\n        exit(false);\n    end;\n\n    blocks := size div 4;\n    ret := size;\n    a := a_in;\n    a_ed := a + blocks;\n    x := 23333333;\n\n    while a < a_ed do begin\n        ret := ret xor (a[0] + x);\n        x := x xor (x << 13);\n        x := x xor (x >> 17);\n        x := x xor (x << 5);\n        inc(a);\n    end;\n\n    writeln(ret);\n    exit(true);\nend;\n\n// ====== header ======\n\n\nprocedure init_data(a : u32_p; n : longint; seed : u32);\nvar\n    a_ed : u32_p;\nbegin\n    a_ed := a + n;\n    while a < a_ed do begin\n        seed := next_integer(seed);\n        a[0] := seed;\n        inc(a);\n    end;\nend;\n\nprocedure Sorting_main();\nvar\n    n : longint;\n    seed : u32;\n    a : u32_p;\n    i : u32;\nbegin\n    read(n, seed);\n\n    a := Getmem(n * sizeof(u32));\n    init_data(a, n, seed);\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\nend;\n\n\nprocedure Game_main();\nvar\n    n, q : longint;\n    s1, s2 : ansistring;\n    anss : u32_p;\n    q_x, q_y, q_len : longint_p;\n    i : longint;\nbegin\n    readln(n, q);\n    readln(s1);\n    readln(s2);\n\n    anss := Getmem(q * sizeof(u32));\n    q_x := Getmem(q * sizeof(longint));\n    q_y := Getmem(q * sizeof(longint));\n    q_len := Getmem(q * sizeof(longint));\n\n    for i := 0 to q - 1 do begin\n        read(q_x[i], q_y[i], q_len[i]);\n    end;\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\nend;\n\n\nprocedure Parentheses_main();\nvar\n    n : longint;\n    s : ansistring;\n    ans : u32;\nbegin\n    read(n);\n    read(s);\n\n    // ans := solve(n, s);\n\n    writeln(ans);\nend;\n\n\nvar\n    task_id : longint;\n\nbegin\n    read(task_id);\n\n    if task_id = 1 then begin\n        Sorting_main();\n    end else if task_id = 2 then begin\n        Game_main();\n    end else if task_id = 3 then begin\n        Parentheses_main();\n    end;\n    close(input); close(output);\nend.\n```", "locale": "zh-CN"}}}
{"pid": "P4605", "type": "P", "difficulty": 7, "samples": [["3\n4\n-3 2 -1 2\n-1 -1 1 -1\n0 1 2 1\n2 -2 4 -2\n0 0 1 0 2\n4\n1 1 3 3\n2 1 4 2\n3 1 5 1\n3 -1 4 -1\n0 0 -1 0 2\n4\n-2 0 1 2\n1 3 -3 2\n1 -3 5 -1\n2 -1 4 3\n0 0 1 1 2\n", "3.000000000000000\n3.118033988749895\n4.251303782246768\n"]], "limits": {"time": [10000, 10000, 10000], "memory": [512000, 512000, 512000]}, "tags": ["2018", "各省省选", "平衡树", "山东", "Special Judge", "O2优化", "前缀和", "向量"], "title": "[SDOI2018] 物理实验", "background": "", "description": "小 T 这学期有物理实验课，为了顺利完成下一节课的实验，他打算在课前对实验内容进行预习。\n\n这次实验在一个二维平面上进行，平面上放置了一条无限长的直线导轨，导轨上放置了一个长为$L$的激光发射器，激光发射器会向导轨两侧沿导轨垂直方向发射宽度为$L$的激光束。\n\n平面上还放置了 $n$ 个挡板，每个挡板可以看作是一条线段，现在每个挡板都不和直线导轨接触，且\n和直线导轨的夹角不超过 $85\t\\degree$，任意两个挡板也不会相互接触，激光束不能穿透这些挡板，并且会被挡板吸收掉，不会被挡板反射出去。\n\n小 T 想确定一个激光发射器的位置使得被激光束照射到的挡板长度之和最大，你需要帮小 T 算出这\n个最大值。", "inputFormat": "第一行包含一个正整数 T，表示测试数据的组数。\n\n对于每组测试数据，第一行是一个整数 $n$，表示挡板个数；  \n接下来 n 行，每行包含四个整数 $x1, y1, x2, y2$，表示挡板的两端点分别是 $(x1, y1)$ 和 $(x2, y2)$，保证$(x1, y1){=}\\mathllap{/\\,}(x2, y2)$。  \n第 $n + 2$ 行是五个整数 $x1, y1, x2, y2, L$，表示直线导轨经过了点 $(x1, y1)$ 和 $(x2, y2)$，且激光发射器的长度为 $L$，同样保证 $(x1, y1)\\mathrlap{\\,/}{=}(x2, y2)$。", "outputFormat": "对于每组测试数据，输出一行，包含一个实数，表示激光束能照射到的挡板长度之和的最大值，要求相对误差不超过 $10^{-6}$，也就是说，令输出结果为 $a$，标准答案为 $b$，若满足 $\\dfrac{|a-b|}{max(1,b)}$ $≤$ $10^{-6}$，则输出结果会被认为是正确答案。", "hint": "- $T ≤ 100$\n- $1 ≤ n ≤ 10^4$，\n- $1 ≤ L ≤ 2 × 10^9$，\n- 所有坐标的绝对值不超过 $10^9$。\n\n## SubTasks\n\n- 子任务 1 (40 分)：满足 $1 ≤ n ≤ 100$ 且所有坐标的绝对值不超过 $10^4$。\n- 子任务 2 (40 分)：所有坐标的绝对值不超过 $10^6$。\n- 子任务 3 (20 分)：没有任何附加的限制。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2018] Physics Experiment", "background": "", "description": "Xiao T has a physics lab class this semester. To successfully finish the experiment in the next class, he plans to preview it before class.\n\nThis experiment is conducted on a 2D plane. On the plane there is an infinitely long straight guide rail. On the rail, there is a laser emitter of length $L$. The laser emitter emits laser beams of width $L$ to both sides of the rail along the direction perpendicular to the rail.\n\nThere are also $n$ baffles on the plane. Each baffle can be regarded as a line segment. Now each baffle does not touch the straight guide rail, and the angle between it and the rail is at most $85\\degree$. Any two baffles also do not touch each other. The laser beams cannot pass through these baffles, and will be absorbed by them, not reflected.\n\nXiao T wants to determine a position of the laser emitter such that the total length of baffles illuminated by the laser beams is maximized. You need to help Xiao T compute this maximum value.", "inputFormat": "The first line contains a positive integer $T$, indicating the number of testdata groups.\n\nFor each testdata group, the first line contains an integer $n$, indicating the number of baffles.  \nThe next $n$ lines each contain four integers $x1, y1, x2, y2$, indicating that the two endpoints of the baffle are $(x1, y1)$ and $(x2, y2)$, guaranteeing $(x1, y1){=}\\mathllap{/\\,}(x2, y2)$.  \nThe $(n + 2)$-th line contains five integers $x1, y1, x2, y2, L$, indicating that the straight guide rail passes through points $(x1, y1)$ and $(x2, y2)$, and the length of the laser emitter is $L$, also guaranteeing $(x1, y1)\\mathrlap{\\,/}{=}(x2, y2)$.", "outputFormat": "For each testdata group, output one line containing a real number, representing the maximum total length of baffles that can be illuminated by the laser beams. The relative error must not exceed $10^{-6}$, that is, let your output be $a$ and the standard answer be $b$. If $\\dfrac{|a-b|}{max(1,b)}$ $≤$ $10^{-6}$, then your output will be considered correct.", "hint": "## Constraints\n\n- $T ≤ 100$.\n- $1 ≤ n ≤ 10^4$.\n- $1 ≤ L ≤ 2 × 10^9$.\n- The absolute value of all coordinates does not exceed $10^9$.\n\n## SubTasks\n\n- Subtask 1 (40 points): $1 ≤ n ≤ 100$ and the absolute value of all coordinates does not exceed $10^4$.\n- Subtask 2 (40 points): the absolute value of all coordinates does not exceed $10^6$.\n- Subtask 3 (20 points): no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2018] 物理实验", "background": "", "description": "小 T 这学期有物理实验课，为了顺利完成下一节课的实验，他打算在课前对实验内容进行预习。\n\n这次实验在一个二维平面上进行，平面上放置了一条无限长的直线导轨，导轨上放置了一个长为$L$的激光发射器，激光发射器会向导轨两侧沿导轨垂直方向发射宽度为$L$的激光束。\n\n平面上还放置了 $n$ 个挡板，每个挡板可以看作是一条线段，现在每个挡板都不和直线导轨接触，且\n和直线导轨的夹角不超过 $85\t\\degree$，任意两个挡板也不会相互接触，激光束不能穿透这些挡板，并且会被挡板吸收掉，不会被挡板反射出去。\n\n小 T 想确定一个激光发射器的位置使得被激光束照射到的挡板长度之和最大，你需要帮小 T 算出这\n个最大值。", "inputFormat": "第一行包含一个正整数 T，表示测试数据的组数。\n\n对于每组测试数据，第一行是一个整数 $n$，表示挡板个数；  \n接下来 n 行，每行包含四个整数 $x1, y1, x2, y2$，表示挡板的两端点分别是 $(x1, y1)$ 和 $(x2, y2)$，保证$(x1, y1){=}\\mathllap{/\\,}(x2, y2)$。  \n第 $n + 2$ 行是五个整数 $x1, y1, x2, y2, L$，表示直线导轨经过了点 $(x1, y1)$ 和 $(x2, y2)$，且激光发射器的长度为 $L$，同样保证 $(x1, y1)\\mathrlap{\\,/}{=}(x2, y2)$。", "outputFormat": "对于每组测试数据，输出一行，包含一个实数，表示激光束能照射到的挡板长度之和的最大值，要求相对误差不超过 $10^{-6}$，也就是说，令输出结果为 $a$，标准答案为 $b$，若满足 $\\dfrac{|a-b|}{max(1,b)}$ $≤$ $10^{-6}$，则输出结果会被认为是正确答案。", "hint": "- $T ≤ 100$\n- $1 ≤ n ≤ 10^4$，\n- $1 ≤ L ≤ 2 × 10^9$，\n- 所有坐标的绝对值不超过 $10^9$。\n\n## SubTasks\n\n- 子任务 1 (40 分)：满足 $1 ≤ n ≤ 100$ 且所有坐标的绝对值不超过 $10^4$。\n- 子任务 2 (40 分)：所有坐标的绝对值不超过 $10^6$。\n- 子任务 3 (20 分)：没有任何附加的限制。\n", "locale": "zh-CN"}}}
{"pid": "P4606", "type": "P", "difficulty": 6, "samples": [["2\n7 6\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n3\n2 1 2\n3 2 3 4\n4 4 5 6 7\n6 6\n1 2\n1 3\n2 3\n1 4\n2 5\n3 6\n4\n3 1 2 3\n3 1 2 6\n3 1 5 6\n3 4 5 6\n", "0\n1\n3\n0\n1\n2\n3"]], "limits": {"time": [10000, 10000, 10000], "memory": [500000, 500000, 500000]}, "tags": ["2018", "各省省选", "山东", "O2优化", "深度优先搜索 DFS", "双连通分量", "虚树", "圆方树"], "title": "[SDOI2018] 战略游戏", "background": "", "description": "省选临近，放飞自我的小 Q 无心刷题，于是怂恿小 C 和他一起颓废，玩起了一款战略游戏。\n\n这款战略游戏的地图由 $n$ 个城市以及 $m$ 条连接这些城市的双向道路构成，并且从任意一个城市出发总能沿着道路走到任意其他城市。\n\n现在小 C 已经占领了其中至少两个城市，小 Q 可以摧毁一个小 C 没占领的城市，同时摧毁所有连接这个城市的道路。只要在摧毁这个城市之后能够找到某两个小 C 占领的城市 $u$ 和 $v$，使得从 $u$ 出发沿着道路无论如何都不能走到 $v$，那么小 Q 就能赢下这一局游戏。\n\n小 Q 和小 C 一共进行了 $q$ 局游戏，每一局游戏会给出小 C 占领的城市集合 $S$，你需要帮小 Q 数出有多少个城市在他摧毁之后能够让他赢下这一局游戏。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n\n对于每组测试数据：\n\n第一行是两个整数 $n$ 和 $m$ ，表示地图的城市数和道路数。\n\n接下来 $m$ 行，每行包含两个整数 $u$ 和 $v (1 \\le u < v \\le n)$，表示第 $u$ 个城市和第 $v$ 个城市之间有一条道路，同一对城市之间可能有多条道路连接。\n\n\n第 $m + 1$ 是一个整数 $q$，表示游戏的局数，\n\n接下来 $q$ 行，每行先给出一个整数 $|S| (2 \\le |S| \\le n)$，表示小 C 占领的城市数量，然后给出 $|S|$ 个整数 $(1 \\le S_1 < S_2 < \\cdots < S_{|S|} ≤ n)$，表示小 C 占领的城市。", "outputFormat": "对于每一局游戏，输出一行，包含一个整数，表示这一局游戏中有多少个城市在小 Q 摧毁之后能够让他赢下这一局游戏。", "hint": "- $1 \\le T \\le 10$；\n- $2 \\le n \\le 10^5$ 且 $n - 1 \\le m \\le 2\\times 10 ^ 5$；\n- $1 \\le q \\le 10^5$；\n- 对于每组测试数据，有 $\\sum|S| \\le 2 \\times 10^5$。\n\n### Subtasks\n\n- 子任务 1 (30 分)：对于每组测试数据，满足 $\\sum|S| \\le 20$；\n- 子任务 2 (45 分)：对于每一次询问，满足 $|S| = 2$；\n- 子任务 3 (25 分)：没有任何附加的限制。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2018] Strategic Game", "background": "", "description": "With the NOI Qualifier approaching, carefree Xiao Q has no desire to practice problems. He coaxes Xiao C to slack off with him and play a strategic game.\n\nThe map of this strategic game consists of $n$ cities and $m$ undirected roads connecting these cities. From any city, it is always possible to reach any other city by following the roads.\n\nXiao C has already occupied at least two cities. Xiao Q may destroy one city not occupied by Xiao C, and simultaneously destroy all roads incident to that city. If, after destroying this city, there exist two cities $u$ and $v$ occupied by Xiao C such that starting from $u$ it is impossible to reach $v$ along the roads, then Xiao Q wins that round.\n\nXiao Q and Xiao C play $q$ rounds in total. In each round, you are given the set $S$ of cities occupied by Xiao C. You need to help Xiao Q count how many cities, if destroyed, would allow him to win that round.", "inputFormat": "The first line contains a single integer $T$, the number of test cases.\n\nFor each test case:\n\n- The first line contains two integers $n$ and $m$, the number of cities and the number of roads.\n- The next $m$ lines each contain two integers $u$ and $v$ ($1 \\le u < v \\le n$), indicating there is a road between city $u$ and city $v$. There may be multiple roads between the same pair of cities.\n- The $(m + 1)$-th line contains an integer $q$, the number of game rounds.\n- The next $q$ lines: each line first gives an integer $|S|$ ($2 \\le |S| \\le n$), the number of cities occupied by Xiao C, followed by $|S|$ integers $S_1, S_2, \\ldots, S_{|S|}$ ($1 \\le S_1 < S_2 < \\cdots < S_{|S|} \\le n$), denoting the cities occupied by Xiao C.", "outputFormat": "For each round, output a single line containing one integer: the number of cities whose destruction would allow Xiao Q to win that round.", "hint": "Constraints\n- $1 \\le T \\le 10$.\n- $2 \\le n \\le 10^5$ and $n - 1 \\le m \\le 2 \\times 10^5$.\n- $1 \\le q \\le 10^5$.\n- For each test case, $\\sum |S| \\le 2 \\times 10^5$.\n\n### Subtasks\n\n- Subtask 1 (30 points): For each test case, $\\sum |S| \\le 20$.\n- Subtask 2 (45 points): For each query, $|S| = 2$.\n- Subtask 3 (25 points): No additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2018] 战略游戏", "background": "", "description": "省选临近，放飞自我的小 Q 无心刷题，于是怂恿小 C 和他一起颓废，玩起了一款战略游戏。\n\n这款战略游戏的地图由 $n$ 个城市以及 $m$ 条连接这些城市的双向道路构成，并且从任意一个城市出发总能沿着道路走到任意其他城市。\n\n现在小 C 已经占领了其中至少两个城市，小 Q 可以摧毁一个小 C 没占领的城市，同时摧毁所有连接这个城市的道路。只要在摧毁这个城市之后能够找到某两个小 C 占领的城市 $u$ 和 $v$，使得从 $u$ 出发沿着道路无论如何都不能走到 $v$，那么小 Q 就能赢下这一局游戏。\n\n小 Q 和小 C 一共进行了 $q$ 局游戏，每一局游戏会给出小 C 占领的城市集合 $S$，你需要帮小 Q 数出有多少个城市在他摧毁之后能够让他赢下这一局游戏。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n\n对于每组测试数据：\n\n第一行是两个整数 $n$ 和 $m$ ，表示地图的城市数和道路数。\n\n接下来 $m$ 行，每行包含两个整数 $u$ 和 $v (1 \\le u < v \\le n)$，表示第 $u$ 个城市和第 $v$ 个城市之间有一条道路，同一对城市之间可能有多条道路连接。\n\n\n第 $m + 1$ 是一个整数 $q$，表示游戏的局数，\n\n接下来 $q$ 行，每行先给出一个整数 $|S| (2 \\le |S| \\le n)$，表示小 C 占领的城市数量，然后给出 $|S|$ 个整数 $(1 \\le S_1 < S_2 < \\cdots < S_{|S|} ≤ n)$，表示小 C 占领的城市。", "outputFormat": "对于每一局游戏，输出一行，包含一个整数，表示这一局游戏中有多少个城市在小 Q 摧毁之后能够让他赢下这一局游戏。", "hint": "- $1 \\le T \\le 10$；\n- $2 \\le n \\le 10^5$ 且 $n - 1 \\le m \\le 2\\times 10 ^ 5$；\n- $1 \\le q \\le 10^5$；\n- 对于每组测试数据，有 $\\sum|S| \\le 2 \\times 10^5$。\n\n### Subtasks\n\n- 子任务 1 (30 分)：对于每组测试数据，满足 $\\sum|S| \\le 20$；\n- 子任务 2 (45 分)：对于每一次询问，满足 $|S| = 2$；\n- 子任务 3 (25 分)：没有任何附加的限制。\n", "locale": "zh-CN"}}}
{"pid": "P4607", "type": "P", "difficulty": 7, "samples": [["10\n1 1 1000000001\n2 2 1000000003\n3 2 1000000005\n3 3 1000000007\n4 2 1000000009\n4 3 1000000011\n4 4 1000000013\n5 5 1000000015\n7 7 1000000017\n9 9 1000000019", "1\n2\n8\n21\n6\n15\n28\n605\n16765\n530937\n"], ["10\n8821612800 758922381 1073365919\n8380532160 166822173 1001828119\n9311702400 7367823578 1015387267\n6983776800 1646145481 1030885259\n6692786100 1953515781 1073365919\n7138971840 2649942813 1001828119\n6469693230 2585876408 1015387267\n8031343320 1646145481 1030885259\n9995200351 645412247 1030328983\n9302162851 1649517328 1053299347\n", "896784901\n911577797\n674524325\n392648220\n646549222\n879297585\n384496639\n889650008\n957785169\n413147483"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000]}, "tags": ["字符串", "2018", "各省省选", "山东", "O2优化", "枚举", "素数判断,质数,筛法"], "title": "[SDOI2018] 反回文串", "background": "", "description": "“回文串什么的最讨厌了……”\n\n小 $Q$ 讨厌任何形式的回文串：\n\n- 如果一个字符串从左往右读和从右往左读是一样的，那么小 $Q$ 讨厌它；例如 $aa$ 和 $aba$。\n\n- 对于一个字符串来说，若将某个前缀子串移除并拼接到字符串的尾部，能得到一个小 $Q$ 讨厌的字符串，那么小 $Q$ 也会讨厌原来的这个字符串；例如 $aab$ 和 $baa$。\n\n那么问题来了，如果任意字符串只可以由 $k$ 种已知的字符组成，那么长度为 $n$ 的所有字符串里，有多少字符串是小 $Q$ 讨厌的？\n\n答案可能很大，你只需要给出答案对 $p$ 取模的值。\n", "inputFormat": "第一行包含一个正整数 $T$，表示有 $T$ 组测试数据。\n接下来 $T$ 行，每行描述一组测试数据，包含三个正整数 $n, k$ 和 $p$。", "outputFormat": "对于每组测试数据，输出一行，包含一个整数，表示答案对 $p$ 取模的值。", "hint": "- 对于 $30\\%$ 的数据，有 $1 ≤ n ≤ 10^{10}$。\n\n- 对于 $60\\%$ 的数据，有 $1 ≤ n ≤ 10^{14}$。\n\n- 对于 $100\\%$ 的数据，有\n$1 ≤ T ≤ 10, 1 ≤ n ≤ 10^{18}, 1 ≤ k ≤ n, 10^9 ≤ p ≤ 2^{30}$\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2018] Anti-Palindromic String", "background": "", "description": "“I really hate palindromic strings...”\n\nXiao $Q$ hates any form of palindromic string:\n\n- If a string reads the same from left to right and from right to left, then Xiao $Q$ hates it; for example, $aa$ and $aba$.\n\n- For a string, if by removing some prefix substring and appending it to the end of the string you can obtain a string that Xiao $Q$ hates, then Xiao $Q$ also hates the original string; for example, $aab$ and $baa$.\n\nNow the question is: if any string may only be formed from $k$ known characters, among all strings of length $n$, how many strings are hated by Xiao $Q$?\n\nThe answer can be large. You only need to output the answer modulo $p$.", "inputFormat": "The first line contains a positive integer $T$, indicating that there are $T$ test cases.\nThe next $T$ lines each describe a test case, containing three positive integers $n$, $k$, and $p$.", "outputFormat": "For each test case, output one line containing an integer, which is the answer modulo $p$.", "hint": "- For $30\\%$ of the testdata, $1 \\le n \\le 10^{10}$.\n\n- For $60\\%$ of the testdata, $1 \\le n \\le 10^{14}$.\n\n- For $100\\%$ of the testdata, \n$1 \\le T \\le 10$, $1 \\le n \\le 10^{18}$, $1 \\le k \\le n$, $10^9 \\le p \\le 2^{30}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2018] 反回文串", "background": "", "description": "“回文串什么的最讨厌了……”\n\n小 $Q$ 讨厌任何形式的回文串：\n\n- 如果一个字符串从左往右读和从右往左读是一样的，那么小 $Q$ 讨厌它；例如 $aa$ 和 $aba$。\n\n- 对于一个字符串来说，若将某个前缀子串移除并拼接到字符串的尾部，能得到一个小 $Q$ 讨厌的字符串，那么小 $Q$ 也会讨厌原来的这个字符串；例如 $aab$ 和 $baa$。\n\n那么问题来了，如果任意字符串只可以由 $k$ 种已知的字符组成，那么长度为 $n$ 的所有字符串里，有多少字符串是小 $Q$ 讨厌的？\n\n答案可能很大，你只需要给出答案对 $p$ 取模的值。\n", "inputFormat": "第一行包含一个正整数 $T$，表示有 $T$ 组测试数据。\n接下来 $T$ 行，每行描述一组测试数据，包含三个正整数 $n, k$ 和 $p$。", "outputFormat": "对于每组测试数据，输出一行，包含一个整数，表示答案对 $p$ 取模的值。", "hint": "- 对于 $30\\%$ 的数据，有 $1 ≤ n ≤ 10^{10}$。\n\n- 对于 $60\\%$ 的数据，有 $1 ≤ n ≤ 10^{14}$。\n\n- 对于 $100\\%$ 的数据，有\n$1 ≤ T ≤ 10, 1 ≤ n ≤ 10^{18}, 1 ≤ k ≤ n, 10^9 ≤ p ≤ 2^{30}$\n", "locale": "zh-CN"}}}
{"pid": "P4608", "type": "P", "difficulty": 6, "samples": [["6 6\nGCTACT\nGATCCT 1", "A\nAC\nACT\nAT \nC  \nCC \nCCT\nCT \nG  \nGA \nGAC\nGACT\nGAT \nGC  \nGCC \nGCCT\nGCT \nGT  \nGTC \nGTCT\nGTT \nT   \nTC  \nTCT \nTT  \n26"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["字符串", "高精度", "2016", "各省省选", "福建", "有限状态自动机"], "title": "[FJOI2016] 所有公共子序列问题", "background": "", "description": "一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列 $X=x_1x_2\\ldots x_m$，则另一序列 $Z=z_1z_2\\ldots z_k$ 是 $X$ 的子序列是指存在一个严格递增下标序列 $i_1,i_2, \\ldots ,i_k$ 使得对于所有 $j=1,2,…,k$ 有 $z_j=x_{i_j}$。\n\n例如，序列 $Z=$``GACT`` 是序列 $X=$``GCTACT`` 的子序列，相应的递增下标序列为 $1,4,5,6$。给定两个序列 $X$ 和 $Y$，当另一序列 $Z$ 既是 $X$ 的子序列又是 $Y$ 的子序列时，称 $Z$ 是序列 $X$ 和 $Y$ 的公共子序列。例如，若 $X=$``GCTACT``， $Y=$``GATCCT``，序列 $T$ 是 $X$ 和 $Y$ 的一个公共子序列，序列 ``GACT`` 也是 $X$ 和 $Y$ 的一个公共子序列。注意对于任何给定的序列 $X$ 和 $Y$，空序列总是它们的一个公共子序列。\n\n所有公共子序列问题是要求对于给定的 $2$ 个序列 $X=x_1x_2\\ldots x_m$ 和 $Y=y_1y_2\\ldots y_m$，找出 $X$ 和 $Y$ 的所有不同的公共子序列。", "inputFormat": "文件的第一行有两个正整数 $m$ 和 $n$，分别表示 $2$ 个输入序列 $X$ 和 $Y$ 的长度。\n\n接下来的两行分别给出输入序列 $X=x_1x_2\\cdots x_m$ 和 $Y=y_1y_2\\cdots y_m$，其中序列中每个元素均为二十六个英文大小写字母。\n\n文件的最后一行给出一个非负整数 $k$。\n\n$k$ 的值为 $1$ 时，表示计算结果要输出 $X$ 和 $Y$ 的所有不同的公共子序列，以及 $X$ 和 $Y$ 有多少个不同的公共子序列。\n\n$k$ 的值为 $0$ 时，表示计算结果只要输出 $X$ 和 $Y$ 有多少个不同的公共子序列。", "outputFormat": "将计算出的 $X$ 和 $Y$ 的所有不同的公共子序列，或 $X$ 和 $Y$ 有多少个不同的公共子序列输出到文件中。当 $k=1$ 时，先输出 $X$ 和 $Y$ 的所有不同的公共子序列，每行输出一个公共子序列，按字典序从小到大输出。最后输出不同的公共子序列的个数。当 $k=0$ 时，只要输出不同的公共子序列的个数。", "hint": "$1 \\leq m,n \\leq 3010$\n\n答案....很大啦", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2016] All Common Subsequences", "background": "", "description": "A subsequence of a given sequence is obtained by deleting some elements from that sequence. Precisely, given a sequence $X = x_1 x_2 \\ldots x_m$, another sequence $Z = z_1 z_2 \\ldots z_k$ is a subsequence of $X$ if there exists a strictly increasing index sequence $i_1, i_2, \\ldots, i_k$ such that for all $j = 1, 2, \\ldots, k$ we have $z_j = x_{i_j}$.\n\nFor example, the sequence $Z = ``GACT''$ is a subsequence of the sequence $X = ``GCTACT''$, with the corresponding increasing index sequence $1, 4, 5, 6$. Given two sequences $X$ and $Y$, when another sequence $Z$ is a subsequence of both $X$ and $Y$, we call $Z$ a common subsequence of $X$ and $Y$. For example, if $X = ``GCTACT''$ and $Y = ``GATCCT''$, the sequence ``T'' is a common subsequence of $X$ and $Y$, and the sequence ``GACT'' is also a common subsequence of $X$ and $Y$. Note that for any given sequences $X$ and $Y$, the empty sequence is always their common subsequence.\n\nThe All Common Subsequences problem asks you, given two sequences $X = x_1 x_2 \\ldots x_m$ and $Y = y_1 y_2 \\ldots y_n$, to find all distinct common subsequences of $X$ and $Y$.", "inputFormat": "The first line contains two positive integers $m$ and $n$, the lengths of the two input sequences $X$ and $Y$.\n\nThe next two lines give the input sequences $X = x_1 x_2 \\cdots x_m$ and $Y = y_1 y_2 \\cdots y_n$, where each element of a sequence is an English letter, uppercase or lowercase.\n\nThe last line contains a non-negative integer $k$.\n\nIf $k = 1$, you must output all distinct common subsequences of $X$ and $Y$, and also how many distinct common subsequences $X$ and $Y$ have.\n\nIf $k = 0$, you must output only how many distinct common subsequences $X$ and $Y$ have.", "outputFormat": "Output all distinct common subsequences of $X$ and $Y$, or output how many distinct common subsequences $X$ and $Y$ have. When $k = 1$, first output all distinct common subsequences of $X$ and $Y$, one per line, in ascending lexicographic order. Finally, output the number of distinct common subsequences. When $k = 0$, output only the number of distinct common subsequences.", "hint": "$1 \\leq m, n \\leq 3010$.\n\nThe answer can be very large.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2016] 所有公共子序列问题", "background": "", "description": "一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列 $X=x_1x_2\\ldots x_m$，则另一序列 $Z=z_1z_2\\ldots z_k$ 是 $X$ 的子序列是指存在一个严格递增下标序列 $i_1,i_2, \\ldots ,i_k$ 使得对于所有 $j=1,2,…,k$ 有 $z_j=x_{i_j}$。\n\n例如，序列 $Z=$``GACT`` 是序列 $X=$``GCTACT`` 的子序列，相应的递增下标序列为 $1,4,5,6$。给定两个序列 $X$ 和 $Y$，当另一序列 $Z$ 既是 $X$ 的子序列又是 $Y$ 的子序列时，称 $Z$ 是序列 $X$ 和 $Y$ 的公共子序列。例如，若 $X=$``GCTACT``， $Y=$``GATCCT``，序列 $T$ 是 $X$ 和 $Y$ 的一个公共子序列，序列 ``GACT`` 也是 $X$ 和 $Y$ 的一个公共子序列。注意对于任何给定的序列 $X$ 和 $Y$，空序列总是它们的一个公共子序列。\n\n所有公共子序列问题是要求对于给定的 $2$ 个序列 $X=x_1x_2\\ldots x_m$ 和 $Y=y_1y_2\\ldots y_m$，找出 $X$ 和 $Y$ 的所有不同的公共子序列。", "inputFormat": "文件的第一行有两个正整数 $m$ 和 $n$，分别表示 $2$ 个输入序列 $X$ 和 $Y$ 的长度。\n\n接下来的两行分别给出输入序列 $X=x_1x_2\\cdots x_m$ 和 $Y=y_1y_2\\cdots y_m$，其中序列中每个元素均为二十六个英文大小写字母。\n\n文件的最后一行给出一个非负整数 $k$。\n\n$k$ 的值为 $1$ 时，表示计算结果要输出 $X$ 和 $Y$ 的所有不同的公共子序列，以及 $X$ 和 $Y$ 有多少个不同的公共子序列。\n\n$k$ 的值为 $0$ 时，表示计算结果只要输出 $X$ 和 $Y$ 有多少个不同的公共子序列。", "outputFormat": "将计算出的 $X$ 和 $Y$ 的所有不同的公共子序列，或 $X$ 和 $Y$ 有多少个不同的公共子序列输出到文件中。当 $k=1$ 时，先输出 $X$ 和 $Y$ 的所有不同的公共子序列，每行输出一个公共子序列，按字典序从小到大输出。最后输出不同的公共子序列的个数。当 $k=0$ 时，只要输出不同的公共子序列的个数。", "hint": "$1 \\leq m,n \\leq 3010$\n\n答案....很大啦", "locale": "zh-CN"}}}
{"pid": "P4609", "type": "P", "difficulty": 6, "samples": [["2\n3 2 2\n3 1 2", "2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["数学", "递推", "2016", "各省省选", "福建", "组合数学", "Stirling 数"], "title": "[FJOI2016] 建筑师", "background": "", "description": "小 Z 是一个很有名的建筑师，有一天他接到了一个很奇怪的任务：在数轴上建 $n$ 个建筑，每个建筑的高度是 $1$ 到 $n$ 之间的一个整数。\n\n小 Z 有很严重的强迫症，他不喜欢有两个建筑的高度相同。另外小 Z 觉得如果从最左边（所有建筑都在右边）看能看到 $A$ 个建筑，从最右边（所有建筑都在左边）看能看到 $B$ 个建筑，这样的建筑群有着独特的美感。现在，小 Z 想知道满足上述所有条件的建筑方案有多少种？\n\n如果建筑 $i$ 的左(右)边没有任何建造比它高，则建筑 $i$ 可以从左(右)边看到。两种方案不同，当且仅当存在某个建筑在两种方案下的高度不同。", "inputFormat": "第一行一个整数 $T$，代表 $T$ 组数据。\n接下来 $T$ 行，每行三个整数 $n,A,B$。", "outputFormat": "对于每组数据输出一行答案 $\\text{mod } 10^9+7$。", "hint": "对于 $10 \\%$ 的数据 ： $1 \\leq n \\leq 10$。\n\n对于 $20 \\%$ 的数据 ： $1 \\leq n \\leq 100$。\n\n对于 $40 \\%$ 的数据 ： $1 \\leq n \\leq 50000, \\ 1 \\leq T \\leq 5$。\n\n对于 $100 \\%$ 的数据 ：$1 \\leq n \\leq 50000, \\ 1 \\leq A, B \\leq 100, \\ 1 \\leq T \\leq 200000$。", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2016] Architect", "background": "", "description": "Xiao Z is a very famous architect. One day he received a strange task: build $n$ buildings on a number line, where each building’s height is an integer between $1$ and $n$.\n\nXiao Z has severe OCD; he dislikes having two buildings with the same height. Moreover, Xiao Z feels that a skyline is uniquely beautiful if, when viewed from the far left (all buildings lie to the right), exactly $A$ buildings are visible, and when viewed from the far right (all buildings lie to the left), exactly $B$ buildings are visible. Now Xiao Z wants to know how many building arrangements satisfy all of the above conditions.\n\nBuilding $i$ is visible from the left (right) if there is no building taller than it on its left (right). Two arrangements are different if and only if there exists at least one building whose height differs between the two arrangements.", "inputFormat": "The first line contains an integer $T$, the number of test cases.  \nEach of the next $T$ lines contains three integers $n, A, B$.", "outputFormat": "For each test case, output the answer $\\text{mod } 10^9+7$.", "hint": "For $10\\%$ of the testdata: $1 \\leq n \\leq 10$.\n\nFor $20\\%$ of the testdata: $1 \\leq n \\leq 100$.\n\nFor $40\\%$ of the testdata: $1 \\leq n \\leq 50000, \\ 1 \\leq T \\leq 5$.\n\nFor $100\\%$ of the testdata: $1 \\leq n \\leq 50000, \\ 1 \\leq A, B \\leq 100, \\ 1 \\leq T \\leq 200000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2016] 建筑师", "background": "", "description": "小 Z 是一个很有名的建筑师，有一天他接到了一个很奇怪的任务：在数轴上建 $n$ 个建筑，每个建筑的高度是 $1$ 到 $n$ 之间的一个整数。\n\n小 Z 有很严重的强迫症，他不喜欢有两个建筑的高度相同。另外小 Z 觉得如果从最左边（所有建筑都在右边）看能看到 $A$ 个建筑，从最右边（所有建筑都在左边）看能看到 $B$ 个建筑，这样的建筑群有着独特的美感。现在，小 Z 想知道满足上述所有条件的建筑方案有多少种？\n\n如果建筑 $i$ 的左(右)边没有任何建造比它高，则建筑 $i$ 可以从左(右)边看到。两种方案不同，当且仅当存在某个建筑在两种方案下的高度不同。", "inputFormat": "第一行一个整数 $T$，代表 $T$ 组数据。\n接下来 $T$ 行，每行三个整数 $n,A,B$。", "outputFormat": "对于每组数据输出一行答案 $\\text{mod } 10^9+7$。", "hint": "对于 $10 \\%$ 的数据 ： $1 \\leq n \\leq 10$。\n\n对于 $20 \\%$ 的数据 ： $1 \\leq n \\leq 100$。\n\n对于 $40 \\%$ 的数据 ： $1 \\leq n \\leq 50000, \\ 1 \\leq T \\leq 5$。\n\n对于 $100 \\%$ 的数据 ：$1 \\leq n \\leq 50000, \\ 1 \\leq A, B \\leq 100, \\ 1 \\leq T \\leq 200000$。", "locale": "zh-CN"}}}
{"pid": "P4610", "type": "P", "difficulty": 6, "samples": [["6 7\n1 3\n3 4\n4 5\n5 1\n4 2\n2 6\n6 3", "6"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "COI（克罗地亚）"], "title": "[COI 2012] KAMPANJA", "background": "临近选举，总统要在城市 $1$ 和城市 $2$ 举行演讲。他乘汽车完成巡回演讲，从 $1$ 出发，途中要经过城市 $2$，最后必须回到城市 $1$。特勤局对总统要经过的所有城市监控。为了使得费用最小，必须使得监控的城市最少。求最少要监控的城市。", "description": "一共有 $N$ 个城市和 $M$ 条有向边。满足 $2 \\le N \\le 100,2 \\le M \\le 200$。\n\n我们要求出从 $1$ 号城市出发途中要经过 $2$ 城市，最后要回到 $1$ 城市的路线中最少要经过的点的数目。测试数据保证一定存在解。", "inputFormat": "第一行包含 $2$ 个整数 $N,M$。$N$ 表示城市的数目，$M$ 表示有向边的数目。\n\n接下来 $M$ 行，每行两个数 $A,B$，表示从 $A$ 到 $B$ 有一条有向边。", "outputFormat": "最少要监控的城市的数量。", "hint": "对于 $100\\%$ 的数据，满足 $2 \\le N \\le 100,2 \\le M \\le 200$。\n\n本题数据加强by Imagine", "locale": "zh-CN", "translations": {"en": {"title": "[COI 2012] KAMPANJA", "background": "As the election approaches, the president will give speeches in city $1$ and city $2$. He travels by car on a campaign tour, starting from $1$, passing through city $2$ on the way, and finally must return to city $1$. The Secret Service monitors all cities the president passes through. To minimize the cost, the number of monitored cities must be as small as possible. Find the minimum number of cities that need to be monitored.", "description": "There are $N$ cities and $M$ directed edges, satisfying $2 \\le N \\le 100, 2 \\le M \\le 200$.\n\nWe need to find, among all routes that start from city $1$, pass through city $2$ on the way, and finally return to city $1$, the minimum number of cities that need to be visited. The testdata guarantees that a solution exists.", "inputFormat": "The first line contains two integers $N, M$. $N$ is the number of cities, and $M$ is the number of directed edges.\n\nThe next $M$ lines each contain two integers $A, B$, indicating a directed edge from $A$ to $B$.", "outputFormat": "Output the minimum number of cities that need to be monitored.", "hint": "For $100\\%$ of the testdata, $2 \\le N \\le 100, 2 \\le M \\le 200$ holds.\n\nThe testdata for this problem is strengthened by Imagine.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COI 2012] KAMPANJA", "background": "临近选举，总统要在城市 $1$ 和城市 $2$ 举行演讲。他乘汽车完成巡回演讲，从 $1$ 出发，途中要经过城市 $2$，最后必须回到城市 $1$。特勤局对总统要经过的所有城市监控。为了使得费用最小，必须使得监控的城市最少。求最少要监控的城市。", "description": "一共有 $N$ 个城市和 $M$ 条有向边。满足 $2 \\le N \\le 100,2 \\le M \\le 200$。\n\n我们要求出从 $1$ 号城市出发途中要经过 $2$ 城市，最后要回到 $1$ 城市的路线中最少要经过的点的数目。测试数据保证一定存在解。", "inputFormat": "第一行包含 $2$ 个整数 $N,M$。$N$ 表示城市的数目，$M$ 表示有向边的数目。\n\n接下来 $M$ 行，每行两个数 $A,B$，表示从 $A$ 到 $B$ 有一条有向边。", "outputFormat": "最少要监控的城市的数量。", "hint": "对于 $100\\%$ 的数据，满足 $2 \\le N \\le 100,2 \\le M \\le 200$。\n\n本题数据加强by Imagine", "locale": "zh-CN"}}}
{"pid": "P4611", "type": "P", "difficulty": 5, "samples": [["6 4\n12 16 16 16 14 14\n.T....", "5"], ["10 1\n10 7 3 1 1 9 8 2 4 10\n..T..T....", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2012", "COI（克罗地亚）"], "title": "[COI 2012] TRAMPOLIN", "background": "有很多超级英雄：蝙蝠侠，蜘蛛侠，超人等。其中，有一位叫牛。今天他想模仿蜘蛛侠，所以他选择了一排高大的摩天楼来跳。", "description": "具体而言，他选择了一个由 N 个摩天大楼构成的序\n列，从左到右编号从 1 到 N.他最初位于第 K 座摩天大厦。不幸的是，这样的他的能力有限，所以只能向左或向右跳到相邻的摩天楼，只有那些摩天大楼的高度不大于他目前的摩天大楼\n的高度的楼房才行。然而，他使蹦床上一些摩天大楼，从这些摩天大厦，他可以跳到任何其\n他的摩天大楼，无论多么高以及位置在何处。\n找出从第 K 座楼房开始，他能跳到的最多的不同的楼房数。如果一个楼房被多次访问，我\n们只计算一次。楼房 K 也被计算在内，不管我们是否回到过楼房 K。", "inputFormat": "第一行，包含两个数Ｎ和 K (3 ≤ N ≤ 300 000, 1 ≤ K ≤ N)，表示楼房总数和开始的楼\n房。\n第二行Ｎ个数，均小于 10^6，从左到右依次表示楼房的高度。\n第三行Ｎ个字符'.' 或'T'.如果第 i 个字符是'T'，表示这里有一个蹦床在第 i 个楼房。", "outputFormat": "一个数，有示最多能到的楼房数。", "hint": "样例 2 线路如下：\n1 –>2 –>3 –>6 –>10 –>9 –>8.", "locale": "zh-CN", "translations": {"en": {"title": "[COI 2012] TRAMPOLIN", "background": "There are many superheroes: Batman, Spider-Man, Superman, etc. Among them, there is one called Niu. Today he wants to imitate Spider-Man, so he chose a row of tall skyscrapers to jump across.", "description": "Specifically, he chose a sequence of $N$ skyscrapers, numbered from $1$ to $N$ from left to right. He initially stays on the $K$-th skyscraper. Unfortunately, his ability is limited, so he can only jump left or right to an adjacent skyscraper, and only to a skyscraper whose height is not greater than the height of his current skyscraper.\n\nHowever, some skyscrapers have trampolines. From such a skyscraper, he can jump to any other skyscraper, no matter how tall it is and no matter where it is.\n\nFind the maximum number of distinct skyscrapers he can reach starting from the $K$-th skyscraper. If a skyscraper is visited multiple times, it is counted only once. Skyscraper $K$ is also counted, whether or not he returns to it.", "inputFormat": "The first line contains two integers $N$ and $K$ ($3 \\le N \\le 300\\,000$, $1 \\le K \\le N$), representing the total number of skyscrapers and the starting skyscraper.\n\nThe second line contains $N$ integers, each less than $10^6$, describing the heights of the skyscrapers from left to right.\n\nThe third line contains $N$ characters, `.` or `T`. If the $i$-th character is `T`, it means there is a trampoline on the $i$-th skyscraper.", "outputFormat": "Output one integer, the maximum number of skyscrapers that can be reached.", "hint": "The route for Sample 2 is as follows:\n$1 \\to 2 \\to 3 \\to 6 \\to 10 \\to 9 \\to 8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COI 2012] TRAMPOLIN", "background": "有很多超级英雄：蝙蝠侠，蜘蛛侠，超人等。其中，有一位叫牛。今天他想模仿蜘蛛侠，所以他选择了一排高大的摩天楼来跳。", "description": "具体而言，他选择了一个由 N 个摩天大楼构成的序\n列，从左到右编号从 1 到 N.他最初位于第 K 座摩天大厦。不幸的是，这样的他的能力有限，所以只能向左或向右跳到相邻的摩天楼，只有那些摩天大楼的高度不大于他目前的摩天大楼\n的高度的楼房才行。然而，他使蹦床上一些摩天大楼，从这些摩天大厦，他可以跳到任何其\n他的摩天大楼，无论多么高以及位置在何处。\n找出从第 K 座楼房开始，他能跳到的最多的不同的楼房数。如果一个楼房被多次访问，我\n们只计算一次。楼房 K 也被计算在内，不管我们是否回到过楼房 K。", "inputFormat": "第一行，包含两个数Ｎ和 K (3 ≤ N ≤ 300 000, 1 ≤ K ≤ N)，表示楼房总数和开始的楼\n房。\n第二行Ｎ个数，均小于 10^6，从左到右依次表示楼房的高度。\n第三行Ｎ个字符'.' 或'T'.如果第 i 个字符是'T'，表示这里有一个蹦床在第 i 个楼房。", "outputFormat": "一个数，有示最多能到的楼房数。", "hint": "样例 2 线路如下：\n1 –>2 –>3 –>6 –>10 –>9 –>8.", "locale": "zh-CN"}}}
{"pid": "P4612", "type": "P", "difficulty": 5, "samples": [["3\n3 10 2\n8 4 2\n2 5 2", "4"], ["4\n3 3 5\n7 11 5\n20 8 10\n30 18 3", "19"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "COI（克罗地亚）"], "title": "[COI 2012] SETNJA", "background": "Mirko 要给朋友们送音乐会门票。", "description": "朋友的家可表示为二维平面的网格。Mirko 在行走时，可以朝 $8$ 个方向移动，每次都是整数坐标。他每一步朝上、下、左、右以及 $4$ 个对角方向走一格。\n\n每个朋友的家可表示为平面上的点 $(x,y)$。当 Mirko 到某朋友家送票时，朋友也可以走出来迎接他，也可以向 $8$ 个方向行走。因此，Mirko 和这个朋友最多可以在距离他家 $P$ 步远的位置相遇。$P$ 随每个朋友不同。\n\nMirko 的起始位置与终点位置都未知。\n\n请求出 Mirko 送完所有票的最少移动步数。", "inputFormat": "第一行一个整数，表示 Mirko 的朋友数 $N (2 ≤ N ≤ 200{,}000)$；\n\n接下来 $N$ 行，每行 $3$ 个数，分别表示 $x,y,P\\ (0 ≤ x, y, P ≤ 200{,}000)$。朋友按 Mirko 送票的顺序给出。", "outputFormat": "共一行一个整数，表示 Mirko 必须走的最少移动步数。", "hint": "对于全部数据，保证 $2 ≤ N ≤ 200{,}000$，$0 ≤ x, y, P ≤ 200{,}000$。", "locale": "zh-CN", "translations": {"en": {"title": "[COI 2012] SETNJA", "background": "Mirko is going to deliver concert tickets to his friends.", "description": "Each friend’s home can be represented on a 2D grid. When Mirko walks, he can move in $8$ directions, always staying on integer coordinates. In each step, he moves one grid unit up, down, left, right, or along one of the $4$ diagonal directions.\n\nEach friend’s home is a point $(x, y)$ on the plane. When Mirko arrives to deliver a ticket, the friend can also walk out to meet him, and can also move in $8$ directions. Therefore, Mirko and the friend can meet at a position up to $P$ steps away from the friend’s home. The value of $P$ may be different for each friend.\n\nMirko’s starting position and ending position are both unknown.\n\nFind the minimum number of steps Mirko needs to move in order to deliver all tickets.", "inputFormat": "The first line contains an integer $N$, the number of Mirko’s friends $(2 \\le N \\le 200{,}000)$.\n\nThe next $N$ lines each contain three numbers $x, y, P\\ (0 \\le x, y, P \\le 200{,}000)$. The friends are given in the order in which Mirko delivers the tickets.", "outputFormat": "Output one integer: the minimum number of steps Mirko must walk.", "hint": "For all testdata, it is guaranteed that $2 \\le N \\le 200{,}000$ and $0 \\le x, y, P \\le 200{,}000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COI 2012] SETNJA", "background": "Mirko 要给朋友们送音乐会门票。", "description": "朋友的家可表示为二维平面的网格。Mirko 在行走时，可以朝 $8$ 个方向移动，每次都是整数坐标。他每一步朝上、下、左、右以及 $4$ 个对角方向走一格。\n\n每个朋友的家可表示为平面上的点 $(x,y)$。当 Mirko 到某朋友家送票时，朋友也可以走出来迎接他，也可以向 $8$ 个方向行走。因此，Mirko 和这个朋友最多可以在距离他家 $P$ 步远的位置相遇。$P$ 随每个朋友不同。\n\nMirko 的起始位置与终点位置都未知。\n\n请求出 Mirko 送完所有票的最少移动步数。", "inputFormat": "第一行一个整数，表示 Mirko 的朋友数 $N (2 ≤ N ≤ 200{,}000)$；\n\n接下来 $N$ 行，每行 $3$ 个数，分别表示 $x,y,P\\ (0 ≤ x, y, P ≤ 200{,}000)$。朋友按 Mirko 送票的顺序给出。", "outputFormat": "共一行一个整数，表示 Mirko 必须走的最少移动步数。", "hint": "对于全部数据，保证 $2 ≤ N ≤ 200{,}000$，$0 ≤ x, y, P ≤ 200{,}000$。", "locale": "zh-CN"}}}
{"pid": "P4613", "type": "P", "difficulty": 1, "samples": [["3\n7 9 5\n6 13 10", "DA"], ["4\n5 3 3 5\n10 2 10 10", "NE"], ["4\n5 2 3 2\n3 8 3 3", "DA"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #5] Olivander", "background": "", "description": "Harry Potter has damaged his magic wand in a fight with Lord Voldemort. He has decided to\nget a new wand in Olivander's wand shop. On the floor of the shop, he saw ​N wands and ​N\nwand boxes. The lengths of the wands are, respectively, $X_1$\n,$X_2$\n...​$X_n$\n, and the box sizes are\n$Y_1$\n,​$Y_2$\n...$Y_n$\n. A wand of length ​X can be placed in a box of size ​Y if ​X ≤ ​Y\n. Harry wants to know\nif he can place all the wands in boxes so that each box contains exactly one wand.\nHelp him solve this difficult problem.", "inputFormat": "The first line of input contains the positive integer ​N\n(1 ≤ ​N\n≤ 100), the number from the task.\nThe second line contains ​N\npositive integers ​$X_i$\n(1 ≤ ​$X_i$\n≤ $10^9$​ ), the numbers from the task.\nThe third line contains ​N\npositive integers ​$X_i$\n(1 ≤ $X_i$\n≤ $10^9$​​ ), the numbers from the task.", "outputFormat": "If Harry can place all the wands in boxes, output “DA” (Croatian for yes), otherwise output\n“NE” (Croatian for no).", "hint": "In test cases worth 60% of total points, it will hold ​N\n≤ 9.\n\n**Clarification of the first test case:**\n\nHarry can place the wands in boxes. For example, he can place the wand of length 5 in a box of size\n6, wand of length 7 in a box of size 13, and wand of length 9 in a box of size 10.\n\n**Clarification of the second test case:**\n\nHarry can’t place the wands in boxes because the box of size 2 can’t fit any of the wands.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #5] Olivander", "background": "", "description": "Harry Potter has damaged his magic wand in a fight with Lord Voldemort. He has decided to\nget a new wand in Olivander's wand shop. On the floor of the shop, he saw ​N wands and ​N\nwand boxes. The lengths of the wands are, respectively, $X_1$\n,$X_2$\n...​$X_n$\n, and the box sizes are\n$Y_1$\n,​$Y_2$\n...$Y_n$\n. A wand of length ​X can be placed in a box of size ​Y if ​X ≤ ​Y\n. Harry wants to know\nif he can place all the wands in boxes so that each box contains exactly one wand.\nHelp him solve this difficult problem.", "inputFormat": "The first line of input contains the positive integer ​N\n(1 ≤ ​N\n≤ 100), the number from the task.\nThe second line contains ​N\npositive integers ​$X_i$\n(1 ≤ ​$X_i$\n≤ $10^9$​ ), the numbers from the task.\nThe third line contains ​N\npositive integers ​$X_i$\n(1 ≤ $X_i$\n≤ $10^9$​​ ), the numbers from the task.", "outputFormat": "If Harry can place all the wands in boxes, output “DA” (Croatian for yes), otherwise output\n“NE” (Croatian for no).", "hint": "In test cases worth 60% of total points, it will hold ​N\n≤ 9.\n\n**Clarification of the first test case:**\n\nHarry can place the wands in boxes. For example, he can place the wand of length 5 in a box of size\n6, wand of length 7 in a box of size 13, and wand of length 9 in a box of size 10.\n\n**Clarification of the second test case:**\n\nHarry can’t place the wands in boxes because the box of size 2 can’t fit any of the wands.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #5] Olivander", "background": "", "description": "哈利·波特在与伏地魔的战斗中损坏了他的魔杖。他决定去奥利凡德的魔杖店买一根新的。在商店的地板上，他看到 N 根魔杖和 N 个魔杖盒。魔杖的长度分别是 $X_1$，$X_2$，...，$X_n$，盒子的尺寸是 $Y_1$，$Y_2$，...，$Y_n$。如果魔杖的长度 X 可以放入尺寸为 Y 的盒子中，则 X ≤ Y。哈利想知道他是否可以将所有的魔杖放入盒子中，使得每个盒子恰好包含一根魔杖。帮助他解决这个难题。", "inputFormat": "输入的第一行包含正整数 N (1 ≤ N ≤ 100)，这是任务中的数字。第二行包含 N 个正整数 $X_i$ (1 ≤ $X_i$ ≤ $10^9$)，这是任务中的数字。第三行包含 N 个正整数 $Y_i$ (1 ≤ $Y_i$ ≤ $10^9$)，这是任务中的数字。", "outputFormat": "如果哈利可以将所有的魔杖放入盒子中，输出“DA”（克罗地亚语中的“是”），否则输出“NE”（克罗地亚语中的“否”）。", "hint": "在总分数的 60% 的测试用例中，将满足 N ≤ 9。\n\n**第一个测试用例的说明：**\n\n哈利可以将魔杖放入盒子中。例如，他可以将长度为 5 的魔杖放入尺寸为 6 的盒子中，长度为 7 的魔杖放入尺寸为 13 的盒子中，长度为 9 的魔杖放入尺寸为 10 的盒子中。\n\n**第二个测试用例的说明：**\n\n哈利不能将魔杖放入盒子中，因为尺寸为 2 的盒子无法容纳任何魔杖。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4614", "type": "P", "difficulty": 3, "samples": [["3 3 1\n2 2 0", "9 2 3\n8 1 4\n7 6 5"], ["3 3 1\n2 2 1", "3 2 9\n4 1 8\n5 6 7"], ["3 3 2\n1 1 0\n1 2 0", "1 1 4\n6 5 5\n19 18 17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #5] Spirale", "background": "", "description": "Little Stjepan often likes to go out with his friends and have fun in a popular nightclub in\nZagreb. However, Stjepan sometimes drinks too much soda and gets light headed from all\nthe sugar. Last night was an example of this, which is why Stjepan had the same image in\nhis mind the whole time. It was a scribble of number spirals of some sort. Since he can’t\nquite remember what the image looked like, but can describe it, he is asking you to\nreconstruct it for him.\n\nStjepan recalls that the image was of the shape of a table consisting of numbers written in ​N\nrows and ​M columns. Also, he recalls that there were ​K spirals in that table. For each spiral,\nthe starting position is known, as well as the direction it’s moving in, which can be clockwise\nand counter-clockwise. An example is shown in the images below. The spirals created\nStjepan’s image in exactly $10^{100}$ steps in the following way:\n1. Initially, the table is empty, and each spiral is in its own starting position.\n2. In each following step, each spiral moves to its next position. It is possible that, at\ntimes, the spirals leave the boundaries of the table, but also to return within it.\n3. After exactly $10^{100}$ steps, for each field in the table, the final value is the value of the\nearliest step in which one of the spirals touched that field.\n\n![](https://cdn.luogu.com.cn/upload/pic/19205.png)", "inputFormat": "The first line of input contains positive integers ​N\n, ​M\n(1 ≤ ​N\n, ​M\n≤ 50) and ​K\n(1 ≤ ​K\n≤ ​N\n*​M\n).\nEach of the following ​K lines contains three positive integers ​$X_i$\n, ​$Y_i$ and ​$T_i$ (1 ≤ ​X ≤ ​N\n, 1 ≤ ​Y ≤\nM\n, 0 ≤ ​T ≤ 1), the starting position of the $i^{th}$\nspiral and its direction (0 - clockwise, 1 -\ncounter-clockwise). No two spirals will begin in the same field.", "outputFormat": "You must output ​N lines with ​M numbers, representing the table after each spiral makes\n$10^{100}$ steps.", "hint": "In test cases worth 50% of total points, it will hold: ​N\n=​M\ni ​K\n=1 and ​$X_i$\n=​$Y_i$\n=$\\lfloor\\frac{N+1}{2}\\rfloor$, i.e. ​$X_i$\nand ​$Y_i$ \nwill be equal to the integer division of ​N\n+1 with 2.\n\n![](https://cdn.luogu.com.cn/upload/pic/19206.png)\n\nFor simplicity’s sake, the letter A was added to the numbers from the first spiral, and the letter B to the\nnumbers from the second spiral. Only the first 20 steps of the first spiral are shown, and 21 steps of\nthe second spiral. The fields in gray are the fields from the table we’re interested in, all other fields are\nout of the table’s bounds, but are shown to illustrate the way the spirals move outside of the table.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #5] Spirale", "background": "", "description": "Little Stjepan often likes to go out with his friends and have fun in a popular nightclub in\nZagreb. However, Stjepan sometimes drinks too much soda and gets light headed from all\nthe sugar. Last night was an example of this, which is why Stjepan had the same image in\nhis mind the whole time. It was a scribble of number spirals of some sort. Since he can’t\nquite remember what the image looked like, but can describe it, he is asking you to\nreconstruct it for him.\n\nStjepan recalls that the image was of the shape of a table consisting of numbers written in ​N\nrows and ​M columns. Also, he recalls that there were ​K spirals in that table. For each spiral,\nthe starting position is known, as well as the direction it’s moving in, which can be clockwise\nand counter-clockwise. An example is shown in the images below. The spirals created\nStjepan’s image in exactly $10^{100}$ steps in the following way:\n1. Initially, the table is empty, and each spiral is in its own starting position.\n2. In each following step, each spiral moves to its next position. It is possible that, at\ntimes, the spirals leave the boundaries of the table, but also to return within it.\n3. After exactly $10^{100}$ steps, for each field in the table, the final value is the value of the\nearliest step in which one of the spirals touched that field.\n\n![](https://cdn.luogu.com.cn/upload/pic/19205.png)", "inputFormat": "The first line of input contains positive integers ​N\n, ​M\n(1 ≤ ​N\n, ​M\n≤ 50) and ​K\n(1 ≤ ​K\n≤ ​N\n*​M\n).\nEach of the following ​K lines contains three positive integers ​$X_i$\n, ​$Y_i$ and ​$T_i$ (1 ≤ ​X ≤ ​N\n, 1 ≤ ​Y ≤\nM\n, 0 ≤ ​T ≤ 1), the starting position of the $i^{th}$\nspiral and its direction (0 - clockwise, 1 -\ncounter-clockwise). No two spirals will begin in the same field.", "outputFormat": "You must output ​N lines with ​M numbers, representing the table after each spiral makes\n$10^{100}$ steps.", "hint": "In test cases worth 50% of total points, it will hold: ​N\n=​M\ni ​K\n=1 and ​$X_i$\n=​$Y_i$\n=$\\lfloor\\frac{N+1}{2}\\rfloor$, i.e. ​$X_i$\nand ​$Y_i$ \nwill be equal to the integer division of ​N\n+1 with 2.\n\n![](https://cdn.luogu.com.cn/upload/pic/19206.png)\n\nFor simplicity’s sake, the letter A was added to the numbers from the first spiral, and the letter B to the\nnumbers from the second spiral. Only the first 20 steps of the first spiral are shown, and 21 steps of\nthe second spiral. The fields in gray are the fields from the table we’re interested in, all other fields are\nout of the table’s bounds, but are shown to illustrate the way the spirals move outside of the table.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #5] Spirale", "background": "", "description": "小斯捷潘经常喜欢和朋友们一起去萨格勒布一家很受欢迎的夜总会玩。不过，斯捷潘有时会喝太多苏打水，糖分过多会让他头晕目眩。昨晚就是一个例子，所以斯捷潘脑海中一直浮现着同一个画面。那是一个潦草的数字螺旋。由于他不太记得那幅图的样子，但可以描述出来，所以他请求您为他重现那幅图。\n\n斯捷潘回忆说，图像是一张表格，由 $N$ 行 $M$ 列数字组成。此外，他还记得表格中有 $K$ 个螺旋。每个螺旋的起始位置和移动方向都是已知的，有顺时针和逆时针两种。下面的图片就是一个例子。这些螺旋以如下方式创建了斯捷潘的图像，步数正好为 $10^{100}$ ：\n\n1. 一开始，表格是空的，每个螺旋都在自己的起始位置。\n2. 在接下来的每一步中，每个螺旋都会移动到下一个位置。有时，螺旋可能会离开表格，但也可能会返回到表格内。\n3. 经过整整 $10^{100}$ 步后，对于表格中的每个格子，格子中的数值就是其中一个螺旋最少经过该格子的步数。\n\n![](https://cdn.luogu.com.cn/upload/pic/19205.png)", "inputFormat": "第一行输入包含正整数 $N$ , $M$ （ $1 ≤ N , M ≤ 50$ ）和 $K$ （ $1 ≤ K ≤ N \\times M$ ）。下面 $K$ 行中的每一行都包含三个正整数 $X_i,Y_i,T_i$ （ $1 ≤ X_i ≤ N , 1 ≤ Y_i ≤ M , 0 ≤ T_i ≤ 1$ ），第 $i$ 个螺旋的起始位置和方向（ $0$ 表示顺时针，$1$ 表示逆时针）。没有螺旋的起始位置在同一格子上。", "outputFormat": "您必须输出一个 $N$ 行 $M$ 列的表格，表示在每个螺旋移动 $10^{100}$ 步之后的表格。", "hint": "对于 $50\\%$ 的数据来说，保证 $N=M,K=1$ 并且 $X_i=Y_i=\\lfloor\\frac{N+1}{2}\\rfloor$ （也就是说， $X_i$ 和 $Y_i$ 会等于 $N+1$ 除以 $2$ 再下取整的结果。）\n\n![](https://cdn.luogu.com.cn/upload/pic/19206.png)\n\n为简单起见，在第一个螺旋的数字后面加上字母 `A` ，在第二个螺旋的数字后面加上字母 `B` 。只显示了第一个螺旋的前 $20$ 步和第二个螺旋的前 $21$ 步。灰色格子是表格中的格子，其他格子都超出了表格的范围，但显示出来是为了说明螺旋在表格外移动的方式。", "locale": "zh-CN"}}}
{"pid": "P4615", "type": "P", "difficulty": 3, "samples": [["3\n1 1", "5 1 1"], ["5\n1 2 2 4", "13 8 1 3 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #5] Birokracija", "background": "", "description": "Mirko has become CEO of a huge corporation. This corporation consists of ​N people,\nlabeled from 1 to ​N\n, and Mirko is labeled 1. The corporation is structured so that each\nemployee (except Mirko) has a boss, and we say that employee is an assistant to that boss.\nEach boss can have multiple assistants, but still reports to their boss. This holds for\neveryone except Mirko, who is at the top of the pyramid and doesn’t have a boss, but has his\nassistants.\n\nWhen Mirko gets a task from the investors, he then delegates that task to his assistant with\nthe minimal number. This assistant then delegates the task to their assistant with the\nminimal number, and this process repeats until the task is given to an unlucky person\nwithout an assistant, who then must do the task.\n\nThis is when the real problems begin. The person that did the task gets paid 1 coin, the boss\nof that person gets 2 coins, the boss of that person gets 3 coins, and so on, all the way to\nMirko, who gets as many coins as there are people in this sequence. After that, the\nemployee that really did the job realizes how unfair the system is and quits their job out of\nprinciple.\n\nWhen it comes to doing the next task in the corporation, there is a person less, so maybe the\npaychecks are less, but the work must continue. Tasks are piling up, so the whole procedure\n(assigning a new task, doing it, dividing paychecks and the person doing the task quitting)\nrepeats until Mirko is left alone in the corporation and does his first (also his last) task.\n\nOf course, Mirko will have amassed quite a fortune until then, but he also wants to know how\nmuch money each of the employees earned.", "inputFormat": "The first line of input contains the positive integer ​N (2 ≤ ​N ≤ 2·$10^5$​ ), the number of\nemployees (including Mirko).\n\nThe following line contains ​N- 1 positive integers $a_2$​ , ​$a_3$​ , ​$a_4$ , …, ​$a_n$\n(1 ≤ ​$a_i$\n< ​i\n), where ​$a_i$\ndenotes the boss of employee ​i\n.", "outputFormat": "You must output a single line consisting of ​N numbers, the $i^{th}$ number corresponding to the\namount of money earned by the $i^{th}$ employee.", "hint": "In test cases worth 50% of total points, it will hold 2 ≤ ​N\n≤ 5000.\n\n**Clarification of the second test case:**\n\nMirko assigns the first task to employee 2, who then assigns it to employee 3, who then does it. For\nthis, employee 3 gets 1 coin, employee 2 gets 2 coins, and employee 1 (Mirko) gets 3 coins.\nEmployee 3 then quits.\n\nMirko assigns the second task to employee 2, who then assigns it to employee 4 (because employee\n3 quit), who then assigns it to employee 5, who then does it. For this, employee 5 gets 1 coin,\nemployee 4 gets 2 coins, employee 2 gets 3 coins, and employee 1 gets 4 coins. Employee 5 then quits.\n\nThe procedure is repeated for a total of 5 tasks.\n\nIn total, Mirko gets 13 coins, employee 2 gets 8, employee 4 gets 3, and employee 3 and 5 each get 1\ncoin.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #5] Birokracija", "background": "", "description": "Mirko has become CEO of a huge corporation. This corporation consists of ​N people,\nlabeled from 1 to ​N\n, and Mirko is labeled 1. The corporation is structured so that each\nemployee (except Mirko) has a boss, and we say that employee is an assistant to that boss.\nEach boss can have multiple assistants, but still reports to their boss. This holds for\neveryone except Mirko, who is at the top of the pyramid and doesn’t have a boss, but has his\nassistants.\n\nWhen Mirko gets a task from the investors, he then delegates that task to his assistant with\nthe minimal number. This assistant then delegates the task to their assistant with the\nminimal number, and this process repeats until the task is given to an unlucky person\nwithout an assistant, who then must do the task.\n\nThis is when the real problems begin. The person that did the task gets paid 1 coin, the boss\nof that person gets 2 coins, the boss of that person gets 3 coins, and so on, all the way to\nMirko, who gets as many coins as there are people in this sequence. After that, the\nemployee that really did the job realizes how unfair the system is and quits their job out of\nprinciple.\n\nWhen it comes to doing the next task in the corporation, there is a person less, so maybe the\npaychecks are less, but the work must continue. Tasks are piling up, so the whole procedure\n(assigning a new task, doing it, dividing paychecks and the person doing the task quitting)\nrepeats until Mirko is left alone in the corporation and does his first (also his last) task.\n\nOf course, Mirko will have amassed quite a fortune until then, but he also wants to know how\nmuch money each of the employees earned.", "inputFormat": "The first line of input contains the positive integer ​N (2 ≤ ​N ≤ 2·$10^5$​ ), the number of\nemployees (including Mirko).\n\nThe following line contains ​N- 1 positive integers $a_2$​ , ​$a_3$​ , ​$a_4$ , …, ​$a_n$\n(1 ≤ ​$a_i$\n< ​i\n), where ​$a_i$\ndenotes the boss of employee ​i\n.", "outputFormat": "You must output a single line consisting of ​N numbers, the $i^{th}$ number corresponding to the\namount of money earned by the $i^{th}$ employee.", "hint": "In test cases worth 50% of total points, it will hold 2 ≤ ​N\n≤ 5000.\n\n**Clarification of the second test case:**\n\nMirko assigns the first task to employee 2, who then assigns it to employee 3, who then does it. For\nthis, employee 3 gets 1 coin, employee 2 gets 2 coins, and employee 1 (Mirko) gets 3 coins.\nEmployee 3 then quits.\n\nMirko assigns the second task to employee 2, who then assigns it to employee 4 (because employee\n3 quit), who then assigns it to employee 5, who then does it. For this, employee 5 gets 1 coin,\nemployee 4 gets 2 coins, employee 2 gets 3 coins, and employee 1 gets 4 coins. Employee 5 then quits.\n\nThe procedure is repeated for a total of 5 tasks.\n\nIn total, Mirko gets 13 coins, employee 2 gets 8, employee 4 gets 3, and employee 3 and 5 each get 1\ncoin.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #5] Birokracija", "background": null, "description": "Mirko 是一家大公司的 CEO。该公司由 $N$ 人组成，编号为 $1$ 到 $N$，Mirko 编号为 $1$ 。公司的结构像一棵树一样，每个员工（Mirko 除外）都有老板，我们说这个员工是该老板的助手。每个老板都可以有多名助手。Mirko 没有老板，但有他的助手。\n\n之后会有一些任务，Mirko 会将该任务委托给他编号最小的助手。然后，该助手也将任务委托给他编号最小的助手，并且这个过程重复进行，直到任务被发送给没有助手的人，然后他必须亲自完成任务。\n\n执行任务的人获得 $1$ 个硬币，那个人的老板获得 $2$ 个硬币，那个人的老板获得 $3$ 个硬币，依此类推，一直到 Mirko。之后，真正完成工作的员工意识到系统的不公平并感到伤心，并且不会再执行任务（也就是辞职）。\n\n当公司收到的下一个任务时，因为少了一个人，所以薪水可能更少，但工作必须继续。任务是无限多的（直到公司倒闭），因此整个过程（分配新任务，执行任务，划分薪水和执行任务人员的退出）重复进行，最后 Mirko 独自留在公司并完成他的第一个（也是他的最后一个）任务。\n\n当然，在此之前， Mirko 将积累相当多的财富，但他也想知道每个员工赚了多少钱。", "inputFormat": "第一行有一个整数 $N(2 \\le N \\le 2 \\times 10^5)$，即包括 Mirko 在内的员工的个数。\n\n紧接着第二行有 $N-1$ 个整数，分别为 $a_2,a_3,\\cdots ,a_N(1 \\le a_i < i )$，$a_i$ 表示员工 $i$ 的老板。", "outputFormat": "输出一行 $N$ 个整数，第 $i$ 个整数表示编号为 $i$ 的人能得到的金币数。", "hint": "$50\\%$ 的数据满足 $2 \\le N \\le 5000$。", "locale": "zh-CN"}}}
{"pid": "P4616", "type": "P", "difficulty": 5, "samples": [["8 3 3\n2 5\n3 6\n4 8", "3\n1\n2"], ["25 6 1\n20 9", "4"], ["9999 2222 2\n1025 2405\n3154 8949", "1980\n2160"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "并查集", "Kruskal 重构树", "最近公共祖先 LCA", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #5] Pictionary", "background": "", "description": "There is a planet, in a yet undiscovered part of the universe, with a country inhabited solely\nby mathematicians. In this country, there are a total of ​N mathematicians, and the interesting\nfact is that each mathematician lives in their own city. Is it also interesting that no two cities\nare connected with a road, because mathematicians can communicate online or by\nreviewing academic papers. Naturally, the cities are labeled with numbers from 1 to ​N.\n\nLife was perfect until one mathematician decided to write an academic paper on their\nsmartphone. The smartphone auto-corrected the word “self-evident” to “Pictionary” and the\npaper was published as such. Soon after, the entire country discovered pictionary and\nwanted to meet up and play, so construction work on roads between cities began shortly.\n.\nThe road construction will last a total of ​M days, according to the following schedule: on the\nfirst day, construction is done on roads between all pairs of cities that have ​M as their\ngreatest common divisor. On the second day, construction is done on roads between all\npairs of cities that have ​M-1 as their greatest common divisor, and so on until the ​$M^{th}$ day\nwhen construction is done on roads between all pairs of cities that are co-prime. More\nformally, on the $i^{th}$ day, construction is done on roads between cities ​a and ​b if ​gcd(a, b) = $M-i+1$.\n\nSince the mathematicians are busy with construction work, they’ve asked you to help them\ndetermine the minimal number of days before a given pair of mathematicians can play\npictionary together.", "inputFormat": "The first line of input contains three positive integers ​N, M\nand ​Q\n(1 ≤ ​N\n, ​Q ≤ 100 000, 1 ≤ ​M\n≤ ​N\n), the number of cities, the number of days it takes to build the roads, and the number of\nqueries.\n\nEach of the following ​Q lines contains two distinct positive integers ​A and ​B\n(1 ≤ ​A\n, ​B ≤ ​N\n)\nthat denote the cities of the mathematicians who want to find out the minimal number of days\nbefore they can play pictionary together.", "outputFormat": "The $i^{th}$ line must contain the minimal number of days before the mathematicians from the $i^{th}$ query can play pictionary together.", "hint": "In test cases worth 40% of total points, it will hold ​N\n≤ 1000, ​Q\n≤ 100 000.\n\n**Clarification of the first test case:**\n\nOn the first day, road (3, 6) is built. Therefore the answer to the second query is 1.\n\nOn the second day, roads (2, 4), (2, 6), (2, 8), (4, 6) and (6, 8) are built. Cities 4 and 8 are now\nconnected (it is possible to get from the first to the second using city 6).\n\nOn the third day, roads between relatively prime cities are built, so cities 2 and 5 are connected.\n\n**Clarification of the second test case:**\n\nOn the second day, road (20, 15) is built, whereas on the fourth day, road (15, 9) is built. After the\nfourth day, cities 20 and 9 are connected via city 15.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #5] Pictionary", "background": "", "description": "There is a planet, in a yet undiscovered part of the universe, with a country inhabited solely\nby mathematicians. In this country, there are a total of ​N mathematicians, and the interesting\nfact is that each mathematician lives in their own city. Is it also interesting that no two cities\nare connected with a road, because mathematicians can communicate online or by\nreviewing academic papers. Naturally, the cities are labeled with numbers from 1 to ​N.\n\nLife was perfect until one mathematician decided to write an academic paper on their\nsmartphone. The smartphone auto-corrected the word “self-evident” to “Pictionary” and the\npaper was published as such. Soon after, the entire country discovered pictionary and\nwanted to meet up and play, so construction work on roads between cities began shortly.\n.\nThe road construction will last a total of ​M days, according to the following schedule: on the\nfirst day, construction is done on roads between all pairs of cities that have ​M as their\ngreatest common divisor. On the second day, construction is done on roads between all\npairs of cities that have ​M-1 as their greatest common divisor, and so on until the ​$M^{th}$ day\nwhen construction is done on roads between all pairs of cities that are co-prime. More\nformally, on the $i^{th}$ day, construction is done on roads between cities ​a and ​b if ​gcd(a, b) = $M-i+1$.\n\nSince the mathematicians are busy with construction work, they’ve asked you to help them\ndetermine the minimal number of days before a given pair of mathematicians can play\npictionary together.", "inputFormat": "The first line of input contains three positive integers ​N, M\nand ​Q\n(1 ≤ ​N\n, ​Q ≤ 100 000, 1 ≤ ​M\n≤ ​N\n), the number of cities, the number of days it takes to build the roads, and the number of\nqueries.\n\nEach of the following ​Q lines contains two distinct positive integers ​A and ​B\n(1 ≤ ​A\n, ​B ≤ ​N\n)\nthat denote the cities of the mathematicians who want to find out the minimal number of days\nbefore they can play pictionary together.", "outputFormat": "The $i^{th}$ line must contain the minimal number of days before the mathematicians from the $i^{th}$ query can play pictionary together.", "hint": "In test cases worth 40% of total points, it will hold ​N\n≤ 1000, ​Q\n≤ 100 000.\n\n**Clarification of the first test case:**\n\nOn the first day, road (3, 6) is built. Therefore the answer to the second query is 1.\n\nOn the second day, roads (2, 4), (2, 6), (2, 8), (4, 6) and (6, 8) are built. Cities 4 and 8 are now\nconnected (it is possible to get from the first to the second using city 6).\n\nOn the third day, roads between relatively prime cities are built, so cities 2 and 5 are connected.\n\n**Clarification of the second test case:**\n\nOn the second day, road (20, 15) is built, whereas on the fourth day, road (15, 9) is built. After the\nfourth day, cities 20 and 9 are connected via city 15.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #5] Pictionary", "background": "", "description": "在宇宙一个不为人知的地方，有一个星球，上面有一个国家，只有数学家居住。\n在这个国家有$n$个数学家，有趣的是，每个数学家都住在自己的城市，且城市间无道路相连，因为他们可以在线交流。当然，城市有从$1$到$n$的编号。\n\n一位数学家决定用手机发论文，而手机将“不言而喻”自动更正成了“猜谜游戏”。\n不久之后，这个国家就发现了猜谜游戏。他们想要见面一起玩，于是这个国家就开始了修路工程。\n道路修建会持续$m$天。对于第$i$天，若$\\gcd(a,b)=m-i+1$，则$a$和$b$城市间会修一条路。\n\n由于数学家们忙于建筑工作，请你来确定一对数学家最早什么时候能凑到一起玩。", "inputFormat": "第一行有三个正整数$n,m,q$，表示城市数量、修路持续天数、询问数量。\n接下来$q$行，每行有两个正整数$a,b$，表示询问$a$和$b$两个城市的数学家最早什么时候能在一起玩。", "outputFormat": "输出$q$行，第$i$行有一个正整数，表示第$i$次询问的结果\n\n## 说明", "hint": "对于$40\\%$的数据：\n$n≤4000,q≤10^5$  \n对于全部数据：  \n$1≤n,q≤10^5$  \n$1≤m≤n$\n\n样例1解释：\n在第一天，$(3,6)$之间修了一条路，因此第二次询问输出`1`  \n在第二天，$(2,4),(2,6),(2,8),(4,6),(6,8)$之间都修了一条路，此时$4$和$8$号城市连通，第三次询问输出`2`  \n在第三天，所有编号互质的城市之间都修了路，$2$和$5$号城市在此时连通，第一次询问输出`1`\n\n样例2解释：\n在第二天，$(20,15)$之间修了一条路  \n第四天，$(15,9)$之间修了一条路  \n所以$20$和$9$号城市在第四天连通，输出`4`", "locale": "zh-CN"}}}
{"pid": "P4617", "type": "P", "difficulty": 6, "samples": [["2 3\n1 2\n2 2\n2 1", "Slavko\nSlavko"], ["4 5\n2 2\n1 2\n1 1\n1 3\n4 2", "Slavko\nMirko\nMirko\nMirko"], ["4 5\n1 2\n1 3\n2 2\n2 3\n4 1", "Slavko\nSlavko\nMirko\nSlavko"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #5] Planinarenje", "background": "", "description": "Mirko and Slavko like to hike together. Mirko likes mountain peaks, and Slavko likes valleys.\nBecause of this, every time they climb to a peak, Slavko decides which valley they are going\nto descend to, given that a trail exists to it. Similarly, in each valley, Mirko decides which\npeak they are going to climb up to. It will never be possible to directly climb from one peak to\nanother, or to get from one valley to another valley. In order to make the hiking as fun as\npossible, they never visit the same spot twice (whether it’s a peak or a valley). Once they\nreach a spot that only leads to spots they’ve visited before, they call the mountain rangers to\npick them up. If the final spot is a peak, Mirko wins, and if it is a valley, Slavko wins.\n\nNaturally, you must already know what your task is: If we assume that both of them play\noptimally, who wins? Answer this question for all initial peaks.", "inputFormat": "The first line contains two positive integers, ​N and ​M (1 ≤ ​N ≤ 5000, 1 ≤ ​M ≤ min(5000, ​N\n·​N\n)).\nHere ​N denotes the number of peaks and valleys (therefore, there are ​N peaks and ​N\nvalleys), and ​M\ndenotes the number of hiking trails.\n\nEach of the following ​M lines contains two positive integers: ​$v_i$ and ​​$d_i$ (1 ≤ ​​$v_i$ , ​​$d_i$ ≤ ​N) that\ndenote there is a trail between peak ​​$v_i$ and valley ​$d_i$.\nBetween each peak and valley, there will exist at most one trail.", "outputFormat": "You must output ​N\nlines. The ​$i^{th}$ line denotes the winner if the starting point is peak ​i\n.", "hint": "In test cases worth 30% of total points, it will hold 1 ≤ ​N\n≤ 10 and 1 ≤ ​M\n≤ ​N\n·​N\n.\n\nIn test cases worth an additional 20% of total points, for each two connected spots, there will\nexist a unique path between them. In other words, the graph will be a forest.\n\n**Clarification of the second test case:**\n\nStarting from the first peak, Slavko can choose to go to the first valley, so Slavko wins.\n\nStarting from the second peak, Slavko can choose to go to the second valley, after which Mirko wins\nby choosing to go to the fourth peak.\n\nStarting from the third peak, there are no trails, so Mirko wins.\n\nStarting from the fourth peak, Slavko must choose to go to the second valley, after which Mirko wins\nby choosing the second peak.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #5] Planinarenje", "background": "", "description": "Mirko and Slavko like to hike together. Mirko likes mountain peaks, and Slavko likes valleys.\nBecause of this, every time they climb to a peak, Slavko decides which valley they are going\nto descend to, given that a trail exists to it. Similarly, in each valley, Mirko decides which\npeak they are going to climb up to. It will never be possible to directly climb from one peak to\nanother, or to get from one valley to another valley. In order to make the hiking as fun as\npossible, they never visit the same spot twice (whether it’s a peak or a valley). Once they\nreach a spot that only leads to spots they’ve visited before, they call the mountain rangers to\npick them up. If the final spot is a peak, Mirko wins, and if it is a valley, Slavko wins.\n\nNaturally, you must already know what your task is: If we assume that both of them play\noptimally, who wins? Answer this question for all initial peaks.", "inputFormat": "The first line contains two positive integers, ​N and ​M (1 ≤ ​N ≤ 5000, 1 ≤ ​M ≤ min(5000, ​N\n·​N\n)).\nHere ​N denotes the number of peaks and valleys (therefore, there are ​N peaks and ​N\nvalleys), and ​M\ndenotes the number of hiking trails.\n\nEach of the following ​M lines contains two positive integers: ​$v_i$ and ​​$d_i$ (1 ≤ ​​$v_i$ , ​​$d_i$ ≤ ​N) that\ndenote there is a trail between peak ​​$v_i$ and valley ​$d_i$.\nBetween each peak and valley, there will exist at most one trail.", "outputFormat": "You must output ​N\nlines. The ​$i^{th}$ line denotes the winner if the starting point is peak ​i\n.", "hint": "In test cases worth 30% of total points, it will hold 1 ≤ ​N\n≤ 10 and 1 ≤ ​M\n≤ ​N\n·​N\n.\n\nIn test cases worth an additional 20% of total points, for each two connected spots, there will\nexist a unique path between them. In other words, the graph will be a forest.\n\n**Clarification of the second test case:**\n\nStarting from the first peak, Slavko can choose to go to the first valley, so Slavko wins.\n\nStarting from the second peak, Slavko can choose to go to the second valley, after which Mirko wins\nby choosing to go to the fourth peak.\n\nStarting from the third peak, there are no trails, so Mirko wins.\n\nStarting from the fourth peak, Slavko must choose to go to the second valley, after which Mirko wins\nby choosing the second peak.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #5] Planinarenje", "background": "", "description": "米尔科和斯拉夫科喜欢一起徒步旅行。米尔科喜欢山峰，而斯拉夫科喜欢山谷。因此，每次他们爬到一个山峰时，斯拉夫科决定他们要下到哪个山谷，前提是有通往该山谷的小径。同样地，在每个山谷中，米尔科决定他们要爬上哪个山峰。永远不可能直接从一个山峰爬到另一个山峰，或从一个山谷到另一个山谷。为了使徒步旅行尽可能有趣，他们从不重复访问同一个地点（无论是山峰还是山谷）。一旦他们到达一个只能通往他们之前访问过的地点的地方，他们就会叫山地救援队来接他们。如果最后一个地点是山峰，米尔科获胜；如果是山谷，斯拉夫科获胜。\n\n显然，你已经知道你的任务是什么：如果我们假设他们两个都以最佳方式进行游戏，谁会获胜？请为所有初始山峰回答这个问题。", "inputFormat": "第一行包含两个正整数，$N$ 和 $M$（$1 \\leq N \\leq 5000$，$1 \\leq M \\leq \\min(5000, N \\cdot N)$）。这里 $N$ 表示山峰和山谷的数量（因此，有 $N$ 个山峰和 $N$ 个山谷），而 $M$ 表示徒步小径的数量。\n\n接下来的 $M$ 行中的每一行包含两个正整数：$v_i$ 和 $d_i$（$1 \\leq v_i, d_i \\leq N$），表示在山峰 $v_i$ 和山谷 $d_i$ 之间有一条小径。每对山峰和山谷之间最多存在一条小径。", "outputFormat": "你必须输出 $N$ 行。第 $i$ 行表示如果起点是山峰 $i$，谁是获胜者。", "hint": "在占总分数 30% 的测试用例中，将满足 $1 \\leq N \\leq 10$ 和 $1 \\leq M \\leq N \\cdot N$。\n\n在额外占总分数 20% 的测试用例中，对于每两个连接的地点之间，将存在唯一的路径。换句话说，图将是一个森林。\n\n**第二个测试用例的说明：**\n\n从第一个山峰开始，斯拉夫科可以选择去第一个山谷，所以斯拉夫科获胜。\n\n从第二个山峰开始，斯拉夫科可以选择去第二个山谷，之后米尔科通过选择去第四个山峰获胜。\n\n从第三个山峰开始，没有小径，所以米尔科获胜。\n\n从第四个山峰开始，斯拉夫科必须选择去第二个山谷，之后米尔科通过选择第二个山峰获胜。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4618", "type": "P", "difficulty": 7, "samples": [["2\n5 3 10000 12345 54321\n3\n1 2 3\n2 1 3\n1 3 2\n10 6 23456 77777 55555\n5\n1 1 10\n2 3 5\n2 7 5\n2 5 4\n1 8 6", "1\n5\n1\n4\n34\n61\n45\n3"]], "limits": {"time": [10000, 10000, 10000], "memory": [512000, 512000, 512000]}, "tags": ["2018", "各省省选", "山东", "O2优化", "可持久化线段树"], "title": "[SDOI2018] 原题识别", "background": "- Input file: old.in\n - Output file: old.out\n - Time limit: 10 seconds\n - Memory limit: 512 megabytes", "description": "“人肉题库” 小 $Q$ 刷题非常勤奋，题量破万。每当有人拿题目请教他时，小 $Q$ 总能在 $1$ 秒内报出这\n是哪个 $OJ$ 的哪道题。因此，小 $Q$ 是被当作 “原题搜索机” 一样的存在。\n\n有一天，小 $Q$ 来到了一棵 $n$ 个节点的有根树下，这棵树的根节点为 $1$ 号点，且每个节点都印着一道\n题目。凭借超大的题量，小 $Q$ 迅速识别出了每道题的来源，并发现有些题目被搬运了好多次。他把每个\n节点的题目都做了一个分类，第 $i$ 个节点的题目对应的题目种类为 $a_i$，当且仅当 $a_i=a_j$ 时，$i$ 点和 $j$ 点的题目来源是相同的。\n\n同一道题目做多次除了增加 $AC$ 数以外，对本身的水平没有任何提高。为了调查这棵树的题目质量，\n小 $Q$ 会不断提出以下两种询问共 $m$ 次：\n\n- $1$ $x$ $y$：如果将 $x$ 点到 $y$ 点的最短路径上的所有点 (包括 $x$ 和 $y$) 对应的题目都做一遍，那么一共可\n以做到多少道本质不同的题目？\n\n- $2$ $A$ $B$：如果在 $A$ 点到根的最短路径上 (包括 $A$ 点和根) 等概率随机选择一个点 $x$，在 $B$ 点到根的最短路径上 (包括 $B$ 点和根) 等概率随机选择一个点 $y$，那么询问 $1$ $x$ $y$ 的答案期望是多少？\n\n定义 $cnt_x$ 表示 $x$ 点到根最短路径上的节点个数，因为小 $Q$ 不喜欢分数，而且第 $2$ 类询问的答案一\n定可以表示成 $\\frac{ans}{{cnt_A}\\times{cnt_B}}$ 的形式，你只需要告诉他 $ans$ 的值就可以了。\n\n识别这些题目消耗了小 $Q$ 太大的精力，他没有办法自己去计算这些简单的询问的答案。请写一个程序回答小 $Q$ 的所有 $m$ 个问题。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n每组数据第一行包含 $5$ 个正整数 $n, p, SA, SB, SC$，其中 $n$ 表示树的节点个数。\n\n为了在某种程度上减少输入量，树边和每个点的题目种类 $a[]$ 将由以下代码生成：\n```\nunsigned int SA, SB, SC;\nunsigned int rng61(){\n\tSA ^= SA << 16;\n\tSA ^= SA >> 5;\n\tSA ^= SA << 1;\n\tunsigned int t = SA;\n\tSA = SB;\n\tSB = SC;\n\tSC ^= t ^ SA;\n\treturn SC;\n}\nvoid gen(){\n\tscanf(\"%d%d%u%u%u\", &n, &p, &SA, &SB, &SC);\n\tfor(int i = 2; i <= p; i++)\n\taddedge(i - 1, i);\n\tfor(int i = p + 1; i <= n; i++)\n\taddedge(rng61() % (i - 1) + 1, i);\n\tfor(int i = 1; i <= n; i++)\n\ta[i] = rng61() % n + 1;\n}\n```\n第二行包含一个正整数 $m$，表示询问次数。\n\n接下来 $m$ 行，每行 $3$ 个正整数，形式为 $1$ $x$ $y$ 或者 $2$ $A$ $B$，依次表示每个询问。", "outputFormat": "对于每组数据，输出 $m$ 行，每行一个整数，依次回答每个询问。", "hint": "- $1 \\le T \\le 3,2 \\le p \\le n \\le 10^5,1 \\le m \\le 2\\times 10^5$\n - $ 10^4 \\le SA, SB, SC \\le 10^6,1 \\le x, y, A, B \\le n$\n\n子任务 $1$（$30$ 分）：只含第 $1$ 类询问。\n\n子任务 $2$（$30$ 分）：满足 $p = n$。\n\n子任务 $3$（$40$ 分）：没有任何附加的限制。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2018] Original Problem Identification", "background": "- Input file: old.in\n- Output file: old.out\n- Time limit: 10 seconds.\n- Memory limit: 512 megabytes.", "description": "“Human problem database” Little $Q$ practices very hard and has solved over ten thousand problems. Whenever someone asks him about a problem, Little $Q$ can tell within $1$ second which $OJ$ and which problem it is. Therefore, Little $Q$ is like an “original problem search engine”.\n\nOne day, Little $Q$ came to a rooted tree with $n$ nodes. The root is node $1$, and each node has a problem printed on it. With his huge amount of experience, Little $Q$ quickly identified the source of every problem, and found that some problems had been reposted many times. He classified the problem on each node: the problem type of node $i$ is $a_i$. The problems at node $i$ and node $j$ come from the same source if and only if $a_i = a_j$.\n\nSolving the same problem multiple times does not improve skill, except increasing the number of $AC$ submissions. To investigate the quality of the problems on this tree, Little $Q$ will ask the following two types of queries for a total of $m$ times:\n\n- $1$ $x$ $y$: If you solve all problems on the shortest path from node $x$ to node $y$ (including $x$ and $y$), how many essentially different problems can you solve in total?\n\n- $2$ $A$ $B$: If you choose a node $x$ uniformly at random on the shortest path from node $A$ to the root (including $A$ and the root), and choose a node $y$ uniformly at random on the shortest path from node $B$ to the root (including $B$ and the root), what is the expected answer to query $1$ $x$ $y$?\n\nLet $cnt_x$ denote the number of nodes on the shortest path from node $x$ to the root. Since Little $Q$ does not like fractions, and the answer to the second type of query can always be written as $\\frac{ans}{{cnt_A}\\times{cnt_B}}$, you only need to output the value of $ans$.\n\nIdentifying these problems has consumed too much of Little $Q$’s energy, so he cannot compute the answers to these simple queries by himself. Please write a program to answer all $m$ queries for Little $Q$.", "inputFormat": "The first line contains a positive integer $T$, denoting the number of testdata.\n\nFor each testdata, the first line contains $5$ positive integers $n, p, SA, SB, SC$, where $n$ is the number of nodes in the tree.\n\nTo reduce the input size to some extent, the tree edges and the problem type array $a[]$ will be generated by the following code:\n```\nunsigned int SA, SB, SC;\nunsigned int rng61(){\n\tSA ^= SA << 16;\n\tSA ^= SA >> 5;\n\tSA ^= SA << 1;\n\tunsigned int t = SA;\n\tSA = SB;\n\tSB = SC;\n\tSC ^= t ^ SA;\n\treturn SC;\n}\nvoid gen(){\n\tscanf(\"%d%d%u%u%u\", &n, &p, &SA, &SB, &SC);\n\tfor(int i = 2; i <= p; i++)\n\taddedge(i - 1, i);\n\tfor(int i = p + 1; i <= n; i++)\n\taddedge(rng61() % (i - 1) + 1, i);\n\tfor(int i = 1; i <= n; i++)\n\ta[i] = rng61() % n + 1;\n}\n```\n\nThe second line contains a positive integer $m$, denoting the number of queries.\n\nThe next $m$ lines each contain $3$ positive integers, in the form $1$ $x$ $y$ or $2$ $A$ $B$, representing each query in order.", "outputFormat": "For each testdata, output $m$ lines, one integer per line, answering each query in order.", "hint": "- $1 \\le T \\le 3,2 \\le p \\le n \\le 10^5,1 \\le m \\le 2\\times 10^5$.\n- $10^4 \\le SA, SB, SC \\le 10^6,1 \\le x, y, A, B \\le n$.\n\nSubtask $1$ ($30$ points): only contains type $1$ queries.\n\nSubtask $2$ ($30$ points): satisfies $p = n$.\n\nSubtask $3$ ($40$ points): no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2018] 原题识别", "background": "- Input file: old.in\n - Output file: old.out\n - Time limit: 10 seconds\n - Memory limit: 512 megabytes", "description": "“人肉题库” 小 $Q$ 刷题非常勤奋，题量破万。每当有人拿题目请教他时，小 $Q$ 总能在 $1$ 秒内报出这\n是哪个 $OJ$ 的哪道题。因此，小 $Q$ 是被当作 “原题搜索机” 一样的存在。\n\n有一天，小 $Q$ 来到了一棵 $n$ 个节点的有根树下，这棵树的根节点为 $1$ 号点，且每个节点都印着一道\n题目。凭借超大的题量，小 $Q$ 迅速识别出了每道题的来源，并发现有些题目被搬运了好多次。他把每个\n节点的题目都做了一个分类，第 $i$ 个节点的题目对应的题目种类为 $a_i$，当且仅当 $a_i=a_j$ 时，$i$ 点和 $j$ 点的题目来源是相同的。\n\n同一道题目做多次除了增加 $AC$ 数以外，对本身的水平没有任何提高。为了调查这棵树的题目质量，\n小 $Q$ 会不断提出以下两种询问共 $m$ 次：\n\n- $1$ $x$ $y$：如果将 $x$ 点到 $y$ 点的最短路径上的所有点 (包括 $x$ 和 $y$) 对应的题目都做一遍，那么一共可\n以做到多少道本质不同的题目？\n\n- $2$ $A$ $B$：如果在 $A$ 点到根的最短路径上 (包括 $A$ 点和根) 等概率随机选择一个点 $x$，在 $B$ 点到根的最短路径上 (包括 $B$ 点和根) 等概率随机选择一个点 $y$，那么询问 $1$ $x$ $y$ 的答案期望是多少？\n\n定义 $cnt_x$ 表示 $x$ 点到根最短路径上的节点个数，因为小 $Q$ 不喜欢分数，而且第 $2$ 类询问的答案一\n定可以表示成 $\\frac{ans}{{cnt_A}\\times{cnt_B}}$ 的形式，你只需要告诉他 $ans$ 的值就可以了。\n\n识别这些题目消耗了小 $Q$ 太大的精力，他没有办法自己去计算这些简单的询问的答案。请写一个程序回答小 $Q$ 的所有 $m$ 个问题。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n每组数据第一行包含 $5$ 个正整数 $n, p, SA, SB, SC$，其中 $n$ 表示树的节点个数。\n\n为了在某种程度上减少输入量，树边和每个点的题目种类 $a[]$ 将由以下代码生成：\n```\nunsigned int SA, SB, SC;\nunsigned int rng61(){\n\tSA ^= SA << 16;\n\tSA ^= SA >> 5;\n\tSA ^= SA << 1;\n\tunsigned int t = SA;\n\tSA = SB;\n\tSB = SC;\n\tSC ^= t ^ SA;\n\treturn SC;\n}\nvoid gen(){\n\tscanf(\"%d%d%u%u%u\", &n, &p, &SA, &SB, &SC);\n\tfor(int i = 2; i <= p; i++)\n\taddedge(i - 1, i);\n\tfor(int i = p + 1; i <= n; i++)\n\taddedge(rng61() % (i - 1) + 1, i);\n\tfor(int i = 1; i <= n; i++)\n\ta[i] = rng61() % n + 1;\n}\n```\n第二行包含一个正整数 $m$，表示询问次数。\n\n接下来 $m$ 行，每行 $3$ 个正整数，形式为 $1$ $x$ $y$ 或者 $2$ $A$ $B$，依次表示每个询问。", "outputFormat": "对于每组数据，输出 $m$ 行，每行一个整数，依次回答每个询问。", "hint": "- $1 \\le T \\le 3,2 \\le p \\le n \\le 10^5,1 \\le m \\le 2\\times 10^5$\n - $ 10^4 \\le SA, SB, SC \\le 10^6,1 \\le x, y, A, B \\le n$\n\n子任务 $1$（$30$ 分）：只含第 $1$ 类询问。\n\n子任务 $2$（$30$ 分）：满足 $p = n$。\n\n子任务 $3$（$40$ 分）：没有任何附加的限制。", "locale": "zh-CN"}}}
{"pid": "P4619", "type": "P", "difficulty": 7, "samples": [["5\n10 10 10\n100 100 100\n1000 1000 1000\n10000 10000 10000\n100000 100000 100000", "11536\n51103588\n165949340\n19234764\n176764584"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "各省省选", "山东", "O2优化", "枚举", "剪枝", "莫比乌斯反演"], "title": "[SDOI2018] 旧试题", "background": " - Input file: divsum.in\n - Output file: divsum.out\n - Time limit: 5 seconds\n - Memory limit: 512 megabytes\n \n （注：此处文件输入输出为比赛时要求，在洛谷提交时采用标准输入输出即可。）", "description": "时光匆匆，转眼间又是一年省选季……\n\n这是小 $Q$ 同学第二次参加省队选拔赛。今年，小 $Q$ 痛定思痛，不再冒险偷取试题，而是通过练习旧试题提升个人实力。可是旧试题太多了，小 $Q$ 没日没夜地做题，却看不到前方的光明在哪里。\n\n一天，因做题过度而疲惫入睡的小 $Q$ 梦到自己在考场上遇到了一道好像做过的题目，却怎么也想不起曾经自己是怎么解决它的，直到醒来还心有余悸。\n\n小 $Q$ 眉头一皱，感觉事情不妙，于是他找到了你，希望你能教他解决这道题目。小 $Q$ 依稀记得题目要计算如下表达式的值。\n\n$$\n(\\sum_{i=1}^{A}\\sum_{j=1}^{B}\\sum_{k=1}^{C}d(ijk))\\bmod (10^9+7)\n$$\n\n其中 $d(ijk)$ 表示 $i × j × k$ 的约数个数。", "inputFormat": "第一行包含一个正整数 $T$，表示有 $T$ 组测试数据。\n\n接下来 $T$ 行，每行描述一组测试数据，包含三个整数 $A, B$ 和 $C$，含义见题目描述。", "outputFormat": "对于每组测试数据，输出一行，包含一个整数，表示所求表达式的值。", "hint": "对于 $30$ 分的数据，$1 ≤ A, B, C ≤ 5000$。\n\n对于 $100$ 分的数据，$1 ≤ T ≤ 10, 1 ≤ A, B, C ≤ 10^5, 1 ≤ \\sum{\\max(A, B, C)} ≤ 2 \\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2018] Old Problem", "background": "- Input file: divsum.in  \n- Output file: divsum.out  \n- Time limit: 5 seconds  \n- Memory limit: 512 megabytes  \n\n(Note: The file input/output above was required during the contest. On Luogu, please use standard input/output.)", "description": "Time flies, and it is the NOI Qualifier season again...\n\nThis is student $Q$'s second time taking the provincial team selection contest. This year, after learning a hard lesson, student $Q$ no longer takes the risk of stealing problems, but instead improves personal skills by practicing old problems. However, there are too many old problems. Student $Q$ works on them day and night, yet still cannot see where the light ahead is.\n\nOne day, exhausted from doing too many problems, student $Q$ fell asleep and dreamed that, in the exam room, he encountered a problem that seemed familiar, but he could not remember how he had solved it before. Even after waking up, he was still frightened.\n\nStudent $Q$ frowned, feeling that something was wrong, so he came to you and hoped you could teach him how to solve this problem. Student $Q$ vaguely remembered that the task was to compute the value of the following expression:\n\n$$\n(\\sum_{i=1}^{A}\\sum_{j=1}^{B}\\sum_{k=1}^{C}d(ijk))\\bmod (10^9+7)\n$$\n\nHere, $d(ijk)$ denotes the number of divisors of $i \\times j \\times k$.", "inputFormat": "The first line contains a positive integer $T$, meaning there are $T$ groups of testdata.\n\nThe next $T$ lines each describe one group of testdata, containing three integers $A, B,$ and $C$, with meanings as described above.", "outputFormat": "For each group of testdata, output one line containing one integer, which is the value of the required expression.", "hint": "For the testdata worth $30$ points, $1 \\le A, B, C \\le 5000$.\n\nFor the testdata worth $100$ points, $1 \\le T \\le 10$, $1 \\le A, B, C \\le 10^5$, and $1 \\le \\sum \\max(A, B, C) \\le 2 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2018] 旧试题", "background": " - Input file: divsum.in\n - Output file: divsum.out\n - Time limit: 5 seconds\n - Memory limit: 512 megabytes\n \n （注：此处文件输入输出为比赛时要求，在洛谷提交时采用标准输入输出即可。）", "description": "时光匆匆，转眼间又是一年省选季……\n\n这是小 $Q$ 同学第二次参加省队选拔赛。今年，小 $Q$ 痛定思痛，不再冒险偷取试题，而是通过练习旧试题提升个人实力。可是旧试题太多了，小 $Q$ 没日没夜地做题，却看不到前方的光明在哪里。\n\n一天，因做题过度而疲惫入睡的小 $Q$ 梦到自己在考场上遇到了一道好像做过的题目，却怎么也想不起曾经自己是怎么解决它的，直到醒来还心有余悸。\n\n小 $Q$ 眉头一皱，感觉事情不妙，于是他找到了你，希望你能教他解决这道题目。小 $Q$ 依稀记得题目要计算如下表达式的值。\n\n$$\n(\\sum_{i=1}^{A}\\sum_{j=1}^{B}\\sum_{k=1}^{C}d(ijk))\\bmod (10^9+7)\n$$\n\n其中 $d(ijk)$ 表示 $i × j × k$ 的约数个数。", "inputFormat": "第一行包含一个正整数 $T$，表示有 $T$ 组测试数据。\n\n接下来 $T$ 行，每行描述一组测试数据，包含三个整数 $A, B$ 和 $C$，含义见题目描述。", "outputFormat": "对于每组测试数据，输出一行，包含一个整数，表示所求表达式的值。", "hint": "对于 $30$ 分的数据，$1 ≤ A, B, C ≤ 5000$。\n\n对于 $100$ 分的数据，$1 ≤ T ≤ 10, 1 ≤ A, B, C ≤ 10^5, 1 ≤ \\sum{\\max(A, B, C)} ≤ 2 \\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4620", "type": "P", "difficulty": 6, "samples": [["2\n3 1 2 3 11111 22222 33333 1 1\n1 5\n2 3\n3 6\n7 2 3 7 11111 22222 33333 1 1\n6 9\n4 5\n3 7\n5 2\n2 4\n1 7\n9 6", "3\n14"]], "limits": {"time": [10000, 10000, 10000], "memory": [512000, 512000, 512000]}, "tags": ["动态规划 DP", "2018", "各省省选", "山东", "O2优化", "树形 DP"], "title": "[SDOI2018] 荣誉称号", "background": " - Input file: title.in\n - Output file: title.out\n - Time limit: 10 seconds\n - Memory limit: 512 megabytes", "description": "休闲游戏玩家小 $Q$ 不仅在算法竞赛方面取得了优异的成绩，还在一款收集钻石的游戏中排名很高。\n\n这款游戏一共有 $n$ 种不同类别的钻石，编号依次为 $1$ 到 $n$。小 $Q$ 已经玩了这款游戏很久了，对于第\n$i$ 种钻石，他已经收集到了 $a_i$ 个。这款游戏最大的亮点就是，钻石只有一种获得途径，那就是从商城中购买。具体来说，第 $i$ 种钻石的单价为 $b_i$ 点券。为了鼓励玩家充值，每种钻石都没有数量上限，只要肯充钱，就可以拥有任意多的钻石。但是这款游戏并没有开发 “丢弃道具” 功能，因此小 $Q$ 不能通过丢弃钻石去完成任务。\n\n最近这款游戏推出了一个限时成就任务，完成任务的玩家可以获得荣誉称号，而完成任务条件则是：\n给定正整数 $k$ 和 $m$，对于任意一个整数 $x (x\\ge 2^k)$，$a_{x}+a_{\\lfloor\\frac{x}{2}\\rfloor}+a_{\\lfloor\\frac{x}{4}\\rfloor}+a_{\\lfloor\\frac{x}{8}\\rfloor}+...+a_{\\lfloor\\frac{x}{2^k}\\rfloor}$ 都要是 $m$的倍数。\n\n高玩小 $Q$ 当然想完成这个限时成就任务，但是在充钱之前他想知道他究竟需要多少点券才能完成这个任务。请写一个程序帮助小 $Q$ 计算最少需要的点券数量。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n\n每组数据第一行包含 $9$ 个正整数 $n, k, m, p, SA, SB, SC, A, B$，其中 $n$ 表示钻石种类数，$k, m$ 表示任\n务条件。\n\n为了在某种程度上减少输入量，$a[]$ 和 $b[]$ 由以下代码生成：\n```\nunsigned int SA, SB, SC;int p, A, B;\nunsigned int rng61(){\n\tSA ^= SA << 16;\n\tSA ^= SA >> 5;\n\tSA ^= SA << 1;\n\tunsigned int t = SA;\n\tSA = SB;\n\tSB = SC;\n\tSC ^= t ^ SA;\n\treturn SC;\n}\nvoid gen(){\n\tscanf(\"%d%d%d%d%u%u%u%d%d\", &n, &k, &m, &p, &SA, &SB, &SC, &A, &B);\n\tfor(int i = 1; i <= p; i++)scanf(\"%d%d\", &a[i], &b[i]);\n\tfor(int i = p + 1; i <= n; i++){\n\t\ta[i] = rng61() % A + 1;\n\t\tb[i] = rng61() % B + 1;\n\t}\n}\n```", "outputFormat": "对于每组数据，输出一行一个整数，即最少需要的点券数量。", "hint": " - $1 ≤ T ≤ 10$，\n - $1 ≤ k ≤ 10$ 且 $2^k ≤ n$，\n - $ 1 ≤ p ≤ min(n, 100000)$，$10000 ≤ SA, SB, SC ≤ 1000000$，\n - $ 1 ≤ A, B, ai, bi ≤ 10^7$。\n\n子任务 $1$（$30$ 分）：满足 $1 ≤ n ≤ 1000$ 且 $m = 2$。\n\n子任务 $2$（$40$ 分）：满足 $1 ≤ n ≤ 10^5$ 且 $m ≤ 200$。\n\n子任务 $3$（$30$ 分）：满足 $1 ≤ n ≤ 10^7$ 且 $m ≤ 200$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2018] Honorary Title", "background": "- Input file: title.in  \n- Output file: title.out  \n- Time limit: 10 seconds.  \n- Memory limit: 512 megabytes.", "description": "Casual game player $Q$ has not only achieved excellent results in algorithm contests, but also ranks very high in a diamond-collecting game.\n\nThis game has $n$ different types of diamonds, numbered from $1$ to $n$. Player $Q$ has played this game for a long time. For type $i$, he has already collected $a_i$ diamonds. The biggest feature of this game is that there is only one way to obtain diamonds: buying them from the shop. Specifically, the unit price of type $i$ is $b_i$ coupons. To encourage players to spend money, there is no quantity limit for any type of diamond: as long as you are willing to pay, you can have as many diamonds as you want. However, the game does not have a “discard item” feature, so $Q$ cannot discard diamonds to complete the task.\n\nRecently, the game launched a limited-time achievement task. Players who complete it can get an honorary title. The completion condition is:\n\nGiven positive integers $k$ and $m$, for any integer $x \\ (x\\ge 2^k)$, the value  \n$a_{x}+a_{\\lfloor\\frac{x}{2}\\rfloor}+a_{\\lfloor\\frac{x}{4}\\rfloor}+a_{\\lfloor\\frac{x}{8}\\rfloor}+...+a_{\\lfloor\\frac{x}{2^k}\\rfloor}$  \nmust be a multiple of $m$.\n\nOf course, skilled player $Q$ wants to complete this limited-time achievement task, but before spending money he wants to know how many coupons he needs to complete it. Please write a program to help $Q$ compute the minimum number of coupons required.", "inputFormat": "The first line contains a positive integer $T$, the number of test cases.\n\nFor each test case, the first line contains $9$ positive integers $n, k, m, p, SA, SB, SC, A, B$, where $n$ is the number of diamond types, and $k, m$ are the task conditions.\n\nTo reduce the input size to some extent, arrays $a[]$ and $b[]$ are generated by the following code:\n```\nunsigned int SA, SB, SC;int p, A, B;\nunsigned int rng61(){\n\tSA ^= SA << 16;\n\tSA ^= SA >> 5;\n\tSA ^= SA << 1;\n\tunsigned int t = SA;\n\tSA = SB;\n\tSB = SC;\n\tSC ^= t ^ SA;\n\treturn SC;\n}\nvoid gen(){\n\tscanf(\"%d%d%d%d%u%u%u%d%d\", &n, &k, &m, &p, &SA, &SB, &SC, &A, &B);\n\tfor(int i = 1; i <= p; i++)scanf(\"%d%d\", &a[i], &b[i]);\n\tfor(int i = p + 1; i <= n; i++){\n\t\ta[i] = rng61() % A + 1;\n\t\tb[i] = rng61() % B + 1;\n\t}\n}\n```", "outputFormat": "For each test case, output one integer per line, the minimum number of coupons required.", "hint": "- $1 ≤ T ≤ 10$.  \n- $1 ≤ k ≤ 10$ and $2^k ≤ n$.  \n- $1 ≤ p ≤ min(n, 100000)$, $10000 ≤ SA, SB, SC ≤ 1000000$.  \n- $1 ≤ A, B, ai, bi ≤ 10^7$.  \n\nConstraints:\n\nSubtask 1 ($30$ points): $1 ≤ n ≤ 1000$ and $m = 2$.  \n\nSubtask 2 ($40$ points): $1 ≤ n ≤ 10^5$ and $m ≤ 200$.  \n\nSubtask 3 ($30$ points): $1 ≤ n ≤ 10^7$ and $m ≤ 200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2018] 荣誉称号", "background": " - Input file: title.in\n - Output file: title.out\n - Time limit: 10 seconds\n - Memory limit: 512 megabytes", "description": "休闲游戏玩家小 $Q$ 不仅在算法竞赛方面取得了优异的成绩，还在一款收集钻石的游戏中排名很高。\n\n这款游戏一共有 $n$ 种不同类别的钻石，编号依次为 $1$ 到 $n$。小 $Q$ 已经玩了这款游戏很久了，对于第\n$i$ 种钻石，他已经收集到了 $a_i$ 个。这款游戏最大的亮点就是，钻石只有一种获得途径，那就是从商城中购买。具体来说，第 $i$ 种钻石的单价为 $b_i$ 点券。为了鼓励玩家充值，每种钻石都没有数量上限，只要肯充钱，就可以拥有任意多的钻石。但是这款游戏并没有开发 “丢弃道具” 功能，因此小 $Q$ 不能通过丢弃钻石去完成任务。\n\n最近这款游戏推出了一个限时成就任务，完成任务的玩家可以获得荣誉称号，而完成任务条件则是：\n给定正整数 $k$ 和 $m$，对于任意一个整数 $x (x\\ge 2^k)$，$a_{x}+a_{\\lfloor\\frac{x}{2}\\rfloor}+a_{\\lfloor\\frac{x}{4}\\rfloor}+a_{\\lfloor\\frac{x}{8}\\rfloor}+...+a_{\\lfloor\\frac{x}{2^k}\\rfloor}$ 都要是 $m$的倍数。\n\n高玩小 $Q$ 当然想完成这个限时成就任务，但是在充钱之前他想知道他究竟需要多少点券才能完成这个任务。请写一个程序帮助小 $Q$ 计算最少需要的点券数量。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n\n每组数据第一行包含 $9$ 个正整数 $n, k, m, p, SA, SB, SC, A, B$，其中 $n$ 表示钻石种类数，$k, m$ 表示任\n务条件。\n\n为了在某种程度上减少输入量，$a[]$ 和 $b[]$ 由以下代码生成：\n```\nunsigned int SA, SB, SC;int p, A, B;\nunsigned int rng61(){\n\tSA ^= SA << 16;\n\tSA ^= SA >> 5;\n\tSA ^= SA << 1;\n\tunsigned int t = SA;\n\tSA = SB;\n\tSB = SC;\n\tSC ^= t ^ SA;\n\treturn SC;\n}\nvoid gen(){\n\tscanf(\"%d%d%d%d%u%u%u%d%d\", &n, &k, &m, &p, &SA, &SB, &SC, &A, &B);\n\tfor(int i = 1; i <= p; i++)scanf(\"%d%d\", &a[i], &b[i]);\n\tfor(int i = p + 1; i <= n; i++){\n\t\ta[i] = rng61() % A + 1;\n\t\tb[i] = rng61() % B + 1;\n\t}\n}\n```", "outputFormat": "对于每组数据，输出一行一个整数，即最少需要的点券数量。", "hint": " - $1 ≤ T ≤ 10$，\n - $1 ≤ k ≤ 10$ 且 $2^k ≤ n$，\n - $ 1 ≤ p ≤ min(n, 100000)$，$10000 ≤ SA, SB, SC ≤ 1000000$，\n - $ 1 ≤ A, B, ai, bi ≤ 10^7$。\n\n子任务 $1$（$30$ 分）：满足 $1 ≤ n ≤ 1000$ 且 $m = 2$。\n\n子任务 $2$（$40$ 分）：满足 $1 ≤ n ≤ 10^5$ 且 $m ≤ 200$。\n\n子任务 $3$（$30$ 分）：满足 $1 ≤ n ≤ 10^7$ 且 $m ≤ 200$。", "locale": "zh-CN"}}}
{"pid": "P4621", "type": "P", "difficulty": 6, "samples": [["3 3 1\n2 2\n1 1 R\n010\n000\n000", "3"], ["3 4 2\n2 2\n3 4 R\n2327\n6009\n2112\n3 2 R\n1310\n2101\n1301", "8"], ["4 4 3\n4 3\n1 1 U\n1001\n0240\n3322\n2327\n1 3 L\n9521\n2390\n3020\n2421\n2 2 D\n3397\n2013\n1102\n7302", "296"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2012", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #6] BAKTERIJE", "background": "", "description": "一个 $N$ 行，$M$ 列的矩形区域，行从上到下从 $1$ 到 $N$ 编号，列从左到右从 $1$ 到 $M$ 编号，有 $K$ 个细菌被放在这些单元格内，每个细菌都有自己的方向和运动规则。规则如下：读取自己在这个单元格的数字 $X$，顺时针转 $90^{\\circ}$ $X$ 次，如果它面对矩形边界，则转 $180^{\\circ}$，最后进入自己面向的单元格。我们放置一个陷阱在某一单元格，当所有细菌同时进入陷阱时，陷阱被激活，细菌会在一秒内被消灭。\n\n给定所有信息，求什么时候所有细菌被消灭。", "inputFormat": "第一行三个正整数 $N, M, K$。\n\n接下来一行，两个数 $x, y$ 表示在 $x$ 行 $y$ 列处有一个陷阱。\n\n接下来依次描述每一个细菌：\n- 首先是一行两个数 $X,Y$ 和一个字母 $C$，分别表示行列坐标和它的方向，`U` 表示上，`D` 表示下，`L` 表示左，`R` 表示右。\n- 接下来一个矩阵，表示这个细菌在这个每一个单元格上的$X$，$0\\leq X\\leq 9$。", "outputFormat": "一行一个数，表示细菌被杀死的最后时间，如果无法全部消灭则输出 $-1$。", "hint": "$3\\leq N\\leq 50$，$3\\leq M \\leq 50$，$1\\leq K\\leq 5$。", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2012/2013 #6] BAKTERIJE", "background": "", "description": "There is a rectangular area with $N$ rows and $M$ columns. Rows are numbered from $1$ to $N$ from top to bottom, and columns are numbered from $1$ to $M$ from left to right. There are $K$ bacteria placed in these cells. Each bacterium has its own direction and movement rules.\n\nThe rules are as follows: it reads the digit $X$ in its current cell, then turns clockwise by $90^{\\circ}$ exactly $X$ times. If it is facing the boundary of the rectangle, it turns $180^{\\circ}$. Finally, it moves into the cell it is facing.\n\nWe place a trap in one cell. When all bacteria enter the trap at the same time, the trap is activated, and the bacteria will be destroyed within one second.\n\nGiven all information, determine when all bacteria are destroyed.", "inputFormat": "The first line contains three positive integers $N, M, K$.\n\nThe next line contains two integers $x, y$, meaning there is a trap at row $x$, column $y$.\n\nThen each bacterium is described in order:\n- First, one line contains two integers $X, Y$ and one letter $C$, representing its row and column coordinates and its direction. `U` means up, `D` means down, `L` means left, and `R` means right.\n- Next is a matrix giving the value $X$ for this bacterium in every cell, with $0\\leq X\\leq 9$.", "outputFormat": "Output one integer on one line: the last time when the bacteria are killed. If it is impossible to destroy all of them, output $-1$.", "hint": "Constraints: $3\\leq N\\leq 50$, $3\\leq M \\leq 50$, $1\\leq K\\leq 5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COCI 2012/2013 #6] BAKTERIJE", "background": "", "description": "一个 $N$ 行，$M$ 列的矩形区域，行从上到下从 $1$ 到 $N$ 编号，列从左到右从 $1$ 到 $M$ 编号，有 $K$ 个细菌被放在这些单元格内，每个细菌都有自己的方向和运动规则。规则如下：读取自己在这个单元格的数字 $X$，顺时针转 $90^{\\circ}$ $X$ 次，如果它面对矩形边界，则转 $180^{\\circ}$，最后进入自己面向的单元格。我们放置一个陷阱在某一单元格，当所有细菌同时进入陷阱时，陷阱被激活，细菌会在一秒内被消灭。\n\n给定所有信息，求什么时候所有细菌被消灭。", "inputFormat": "第一行三个正整数 $N, M, K$。\n\n接下来一行，两个数 $x, y$ 表示在 $x$ 行 $y$ 列处有一个陷阱。\n\n接下来依次描述每一个细菌：\n- 首先是一行两个数 $X,Y$ 和一个字母 $C$，分别表示行列坐标和它的方向，`U` 表示上，`D` 表示下，`L` 表示左，`R` 表示右。\n- 接下来一个矩阵，表示这个细菌在这个每一个单元格上的$X$，$0\\leq X\\leq 9$。", "outputFormat": "一行一个数，表示细菌被杀死的最后时间，如果无法全部消灭则输出 $-1$。", "hint": "$3\\leq N\\leq 50$，$3\\leq M \\leq 50$，$1\\leq K\\leq 5$。", "locale": "zh-CN"}}}
{"pid": "P4622", "type": "P", "difficulty": 4, "samples": [["3\n-1 2 -1", "0"], ["3\n-1 -1 -1", "2"], ["6\n-1 -1 -1 2 -1 -1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["动态规划 DP", "2012", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #6] JEDAN", "background": "COCI", "description": "有$N$个数排成一行(数值代表高度)，最初所有的数都为零，你可以选择连续的一段等高的数，将它们都增加$1$(除了开头和结尾那个数)如下图表示了两次操作:\n\n![](https://cdn.luogu.com.cn/upload/pic/19412.png)\n\n现在有一些数字看不清了，我们用$-1$表示，请你根据留下的数字，推出有多少\n种可能的方案。使得留下的数字正好满足上面的操作方法。\n", "inputFormat": "第一行一个正整数$N$表示数的个数。\n接下来一行$N$个数，依次表示每一个数的大小，$-1$表示看不清楚，你可以用任\n意满足条件的数代替。第$i$个数用$h_i$表示", "outputFormat": "一个数，表示所有可能的方案对$1000000007$ 求余的值。", "hint": "- $(1≤N≤10000)$\n- $(-1 ≤ h_i ≤10 000)$", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2012/2013 #6] JEDAN", "background": "COCI", "description": "There are $N$ numbers in a row (their values represent heights). Initially, all numbers are zero. You may choose a continuous segment of numbers with the same height, and increase all of them by $1$ (except the first and last numbers of the segment). The figure below shows two operations:\n\n![](https://cdn.luogu.com.cn/upload/pic/19412.png)\n\nNow, some numbers cannot be seen clearly, and we use $-1$ to represent them. Based on the remaining numbers, determine how many possible valid arrays there are such that the visible numbers fit exactly the operation rules above.", "inputFormat": "The first line contains a positive integer $N$, the number of numbers.  \nThe next line contains $N$ integers, representing the height of each number in order. A value of $-1$ means it cannot be seen clearly; you may replace it with any number that satisfies the conditions. Let the $i$-th number be $h_i$.", "outputFormat": "Output one integer: the number of all possible valid arrays modulo $1000000007$.", "hint": "- $(1 \\le N \\le 10000)$.\n- $(-1 \\le h_i \\le 10000)$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COCI 2012/2013 #6] JEDAN", "background": "COCI", "description": "有$N$个数排成一行(数值代表高度)，最初所有的数都为零，你可以选择连续的一段等高的数，将它们都增加$1$(除了开头和结尾那个数)如下图表示了两次操作:\n\n![](https://cdn.luogu.com.cn/upload/pic/19412.png)\n\n现在有一些数字看不清了，我们用$-1$表示，请你根据留下的数字，推出有多少\n种可能的方案。使得留下的数字正好满足上面的操作方法。\n", "inputFormat": "第一行一个正整数$N$表示数的个数。\n接下来一行$N$个数，依次表示每一个数的大小，$-1$表示看不清楚，你可以用任\n意满足条件的数代替。第$i$个数用$h_i$表示", "outputFormat": "一个数，表示所有可能的方案对$1000000007$ 求余的值。", "hint": "- $(1≤N≤10000)$\n- $(-1 ≤ h_i ≤10 000)$", "locale": "zh-CN"}}}
{"pid": "P4623", "type": "P", "difficulty": 2, "samples": [["3\n1 0 0 2 2 2\n1 3 3 5 4 0\n5 4 4 5 4 4\n4\nx = 4\nx = 1\ny = 3\ny = 1", "0\n1\n1\n2"], ["4\n2 7 6 0 0 5\n7 1 7 10 11 11\n5 10 2 9 6 8\n1 9 10 10 4 1\n4\ny = 6\nx = 2\nx = 4\nx = 9", "3\n2\n3\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2012", "前缀和", "差分", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #6] BUREK", "background": "COCI", "description": "给定 $N$ 个三角形，和 $M$ 条直线，直线要么平行于 $x$ 轴，要么平行于 $y$ 轴，问这 $M$ 条直线分别穿过多少个三角形。\n\n**（一条直线穿过一个三角形，当且仅当这条直线可以将这个三角形分成两个面积均大于零的多边形）。**", "inputFormat": "输入的第一行包含一个正整数 $N$，表示三角形的个数。\n\n接下来 $N$ 行，每行三个坐标 $(x_1,y_1)$，$(x_2,y_2)$，$(x_3,y_3)$ 表示三个点，且这三点不共线，描述一个三角形。所有坐标均为非负整数，三角形可以重叠。\n\n接下来一行包含一个正整数 $M$，表示直线的条数。\n\n接下来 $M$ 行，每行一个字符串 `x = c` 或 `y = c`（注意等号两边的空格），描述一条直线。其中 `c` 为非负整数。", "outputFormat": "对于每一条直线输出一个整数，表示它穿过的三角形的个数。", "hint": "**【数据范围】**\n\n对于 $40 \\%$ 的数据，$M \\le 300$；\n\n另有 $40 \\%$ 的数据，所有三角形的坐标 $< 1000$；\n\n对于 $100 \\%$ 的数据，$2 \\le N,M \\le 10^5$，$0 \\le x_1,y_1,x_2,y_2,x_3,y_3 < 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2012/2013 #6] BUREK", "background": "COCI", "description": "Given $N$ triangles and $M$ lines. Each line is either parallel to the $x$ axis or parallel to the $y$ axis. For each of the $M$ lines, find how many triangles it passes through.\n\n**(A line passes through a triangle if and only if the line can split the triangle into two polygons whose areas are both greater than zero.)**", "inputFormat": "The first line contains a positive integer $N$, the number of triangles.\n\nThe next $N$ lines each contain three coordinates $(x_1,y_1)$, $(x_2,y_2)$, $(x_3,y_3)$, representing three points. These three points are not collinear and form a triangle. All coordinates are non-negative integers, and triangles may overlap.\n\nThe next line contains a positive integer $M$, the number of lines.\n\nThe next $M$ lines each contain a string `x = c` or `y = c` (note the spaces on both sides of the equals sign), describing a line. Here `c` is a non-negative integer.", "outputFormat": "For each line, output one integer, the number of triangles it passes through.", "hint": "**Constraints**\n\nFor $40\\%$ of the testdata, $M \\le 300$.\n\nFor another $40\\%$ of the testdata, all triangle coordinates are $< 1000$.\n\nFor $100\\%$ of the testdata, $2 \\le N,M \\le 10^5$, and $0 \\le x_1,y_1,x_2,y_2,x_3,y_3 < 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COCI 2012/2013 #6] BUREK", "background": "COCI", "description": "给定 $N$ 个三角形，和 $M$ 条直线，直线要么平行于 $x$ 轴，要么平行于 $y$ 轴，问这 $M$ 条直线分别穿过多少个三角形。\n\n**（一条直线穿过一个三角形，当且仅当这条直线可以将这个三角形分成两个面积均大于零的多边形）。**", "inputFormat": "输入的第一行包含一个正整数 $N$，表示三角形的个数。\n\n接下来 $N$ 行，每行三个坐标 $(x_1,y_1)$，$(x_2,y_2)$，$(x_3,y_3)$ 表示三个点，且这三点不共线，描述一个三角形。所有坐标均为非负整数，三角形可以重叠。\n\n接下来一行包含一个正整数 $M$，表示直线的条数。\n\n接下来 $M$ 行，每行一个字符串 `x = c` 或 `y = c`（注意等号两边的空格），描述一条直线。其中 `c` 为非负整数。", "outputFormat": "对于每一条直线输出一个整数，表示它穿过的三角形的个数。", "hint": "**【数据范围】**\n\n对于 $40 \\%$ 的数据，$M \\le 300$；\n\n另有 $40 \\%$ 的数据，所有三角形的坐标 $< 1000$；\n\n对于 $100 \\%$ 的数据，$2 \\le N,M \\le 10^5$，$0 \\le x_1,y_1,x_2,y_2,x_3,y_3 < 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4624", "type": "P", "difficulty": 6, "samples": [["10 9 18 150 0", "40"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "2000", "剪枝", "CTSC/CTS"], "title": "[CTSC2000] 采矿【测试数据有误】", "background": "一架人类的航天飞机将人类基地建在了一个荒芜的星球上。面对紧缺的能源，他们只能在最短的时间内用 $\\text{SCV}$ （一种智能机器人）采集必须的矿藏。对于这个艰巨的任务，他们希望得到编程高手们的帮助。", "description": "在这个星球上，有着两种不同的矿。一种被称为“冰矿”，是一种类似 $\\text{H}_{2}\\text{O}$ 的凝固物的蓝色高能矿藏。另一种被称为“气矿”，是四氯化碳的一种异态形式。\n\n人类通过这两种矿的提炼，获得可供生存的能源。 $\\text{SCV}$ 是一种唯一可以采集这两种矿的智能机器人。他们每采集一次冰矿需要花费 $t_{1}$ 的时间，每采集一次气矿需要花费 $t_{2}$ 的时间。采集结束后，将得到 $8$ 个冰矿或者 $8$ 个气矿单位。**每一次 $\\text{SCV}$ 只能采集冰矿或者是气矿中的一种**。\n\n $\\text{SCV}$ 可以通过主基地制造。每制造一个 $\\text{SCV}$ ，主基地将花费 $50$ 单位的冰矿。而主基地由于制造能力有限，在同一时间只能制造**一个** $\\text{SCV}$ 。制造一个 $\\text{SCV}$ 需要 $t_{3}$ 的时间。\n\n在开始时，人类拥有 $50$ 个单位的冰矿和 $4$ 个 $\\text{SCV}$ 。他们需要采集到 $p_{1}$ 单位的冰矿和 $p_{2}$ 单位的气矿。请计算出他们需要的**最短时间**。", "inputFormat": "输入文件只有一行，依次为 $t_{1}$ , $t_{2}$ , $t_{3}$ , $p_{1}$ , $p_{2}$ ，每两个数字之间有一个空格。", "outputFormat": "输出文件只包含一个数字，表示可以达到目标的最少时间。", "hint": "$1 \\leq t_{1},t_{2},t_{3} \\leq 18$，$0 \\leq p_{1},p_{2} \\leq 150$。数据从合法数据中随机均匀选取。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CTSC2000] 采矿【测试数据有误】", "background": "一架人类的航天飞机将人类基地建在了一个荒芜的星球上。面对紧缺的能源，他们只能在最短的时间内用 $\\text{SCV}$ （一种智能机器人）采集必须的矿藏。对于这个艰巨的任务，他们希望得到编程高手们的帮助。", "description": "在这个星球上，有着两种不同的矿。一种被称为“冰矿”，是一种类似 $\\text{H}_{2}\\text{O}$ 的凝固物的蓝色高能矿藏。另一种被称为“气矿”，是四氯化碳的一种异态形式。\n\n人类通过这两种矿的提炼，获得可供生存的能源。 $\\text{SCV}$ 是一种唯一可以采集这两种矿的智能机器人。他们每采集一次冰矿需要花费 $t_{1}$ 的时间，每采集一次气矿需要花费 $t_{2}$ 的时间。采集结束后，将得到 $8$ 个冰矿或者 $8$ 个气矿单位。**每一次 $\\text{SCV}$ 只能采集冰矿或者是气矿中的一种**。\n\n $\\text{SCV}$ 可以通过主基地制造。每制造一个 $\\text{SCV}$ ，主基地将花费 $50$ 单位的冰矿。而主基地由于制造能力有限，在同一时间只能制造**一个** $\\text{SCV}$ 。制造一个 $\\text{SCV}$ 需要 $t_{3}$ 的时间。\n\n在开始时，人类拥有 $50$ 个单位的冰矿和 $4$ 个 $\\text{SCV}$ 。他们需要采集到 $p_{1}$ 单位的冰矿和 $p_{2}$ 单位的气矿。请计算出他们需要的**最短时间**。", "inputFormat": "输入文件只有一行，依次为 $t_{1}$ , $t_{2}$ , $t_{3}$ , $p_{1}$ , $p_{2}$ ，每两个数字之间有一个空格。", "outputFormat": "输出文件只包含一个数字，表示可以达到目标的最少时间。", "hint": "$1 \\leq t_{1},t_{2},t_{3} \\leq 18$，$0 \\leq p_{1},p_{2} \\leq 150$。数据从合法数据中随机均匀选取。", "locale": "zh-CN"}}}
{"pid": "P4625", "type": "P", "difficulty": 0, "samples": [["6\n1 2\n2 3\n4 5\n5 6\n2 5", "3\n2\n3"], ["12\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n2 8\n3 9\n4 10\n5 11\n6 12", "6\n2\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "上海", "Special Judge"], "title": "[SHOI2009] 巴士路线", "background": "", "description": "OItown周围有n个小村庄。村庄与村庄之间有公路，每一条公路连接两个村庄。因为这些村庄并不富裕，所以，当初建公路时，这些公路只是恰好将这些村庄连通，也就是说任意从一个村庄沿着公路走到另一个村庄的方式都是唯一的。于是，有时两个很近的村庄之间要走很长的路。所以，村民们就希望能开通这些公路上的公共交通路线，方便大家的出行。\n\n巴士运营公司采纳了这个意见。同时，巴士公司认为这些巴士线路必须满足下述条件：\n\n1.每条巴士线路的起点和终点都在村庄内，巴士开行的线路都沿着公路；\n\n2.每条公路都要有巴士线路覆盖，这样村民们的出行就只需要换成巴士车就行了；\n\n3.每条公路只被一条巴士线路覆盖，且只被覆盖一次，否则巴士公司觉得在成本上不划算；\n\n4.巴士线路的总数应当最少，这样才能方便管理。\n\n例如，如果6个村庄之间的5条公路是这样的：\n\n![](https://cdn.luogu.com.cn/upload/pic/19772.png)\n\n那么这样的3条巴士线路就能满足上面的条件：1-2-3，2-4，5-4-6。\n\n不过，居民们自然认为“巴士换乘”是不方便的，因此他们希望从一个村庄乘车去另一个村庄的路上换乘次数的最大值尽可能少。例如上面这个线路安排中，从村庄1到村庄6需要换成2次，是最大的换乘次数。\n\n另一方面，巴士公司认为，一条公交线路越长意味着，一旦巴士车发生故障，受影响耽误时间的乘客就越多。所以巴士公司希望，最长的一条线路尽可能短。所谓短，就是途经的村庄少。\n\n现在，这个巴士线路设计的任务交给了参加SHTSC的你，你当然要同时考虑上面两方面的因素，所以，你必须计算出：(1)换乘次数的最大值最小可能值(2)最长的线路途经村庄数的最小可能值。", "inputFormat": "输入数据的第一行是一个整数n，表示村庄的数目。\n\n接下去每行有两个整数x、y，分别描述一条公路，表示村庄x、y之间有一条公路。\n\n输入文件保证，每条公路只会被描述一次。", "outputFormat": "输出文件有三行：\n\n第一行是一个整数，表示公交线路安排中包含的路线数。\n\n第二行是一个整数，表示换乘次数的最大值的最小可能值。\n\n第三行是一个整数，表示最长的线路途经村庄数的最小可能值。", "hint": "如果你的输出的第一行与标准答案相等，你能得2分。\n\n如果你的输出的第二行与标准答案相等，你能得4分。\n\n如果你的输出的第三行与标准答案相等，你能得4分。\n\n对于70%的数据：n<=300\n对于100%的数据：n<=$10^5$", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2009] Bus Routes", "background": "", "description": "There are $n$ small villages around OItown. There are roads between villages, and each road connects two villages. Because these villages are not wealthy, when the roads were built, they were built just enough to make all villages connected. That is, for any two villages, there is a unique way to walk from one to the other along the roads. Therefore, sometimes two villages that are very close still require a long walk along the roads. So the villagers hope to open public transport routes on these roads to make travel more convenient.\n\nThe bus operating company accepted this suggestion. At the same time, the company requires that the bus routes must satisfy the following conditions:\n\n1. The start and end points of each bus route are in villages, and the bus runs along the roads.\n2. Every road must be covered by some bus route, so that villagers only need to switch to taking buses.\n3. Each road is covered by exactly one bus route, and is covered only once. Otherwise, the company thinks it is not cost-effective.\n4. The total number of bus routes should be as small as possible, to make management easier.\n\nFor example, if the $5$ roads among $6$ villages are like this:\n\n![](https://cdn.luogu.com.cn/upload/pic/19772.png)\n\nThen the following $3$ bus routes can satisfy the conditions above: $1-2-3$, $2-4$, $5-4-6$.\n\nHowever, the residents naturally think that “bus transfers” are inconvenient, so they hope that the maximum number of transfers needed when traveling from one village to another is as small as possible. For example, in the route arrangement above, going from village $1$ to village $6$ requires $2$ transfers, which is the maximum number of transfers.\n\nOn the other hand, the bus company believes that a longer bus route means that if a bus breaks down, more passengers will be affected and delayed. Therefore, the company hopes that the longest route is as short as possible. “Short” means it passes through fewer villages.\n\nNow the task of designing the bus routes is given to you, a contestant of SHTSC. You must consider both factors above, so you need to compute:\n(1) the minimum possible value of the maximum number of transfers.\n(2) the minimum possible value of the number of villages passed through by the longest route.", "inputFormat": "The first line of the input contains an integer $n$, the number of villages.\n\nEach of the following lines contains two integers $x$ and $y$, describing a road, meaning there is a road between villages $x$ and $y$.\n\nThe input guarantees that each road is described only once.", "outputFormat": "The output has three lines:\n\nThe first line contains an integer, the number of routes in the bus route arrangement.\n\nThe second line contains an integer, the minimum possible value of the maximum number of transfers.\n\nThe third line contains an integer, the minimum possible value of the number of villages passed through by the longest route.", "hint": "If the first line of your output is the same as the standard answer, you can get $2$ points.\n\nIf the second line of your output is the same as the standard answer, you can get $4$ points.\n\nIf the third line of your output is the same as the standard answer, you can get $4$ points.\n\nConstraints:\n\nFor $70\\%$ of the testdata: $n \\le 300$.\nFor $100\\%$ of the testdata: $n \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2009] 巴士路线", "background": "", "description": "OItown周围有n个小村庄。村庄与村庄之间有公路，每一条公路连接两个村庄。因为这些村庄并不富裕，所以，当初建公路时，这些公路只是恰好将这些村庄连通，也就是说任意从一个村庄沿着公路走到另一个村庄的方式都是唯一的。于是，有时两个很近的村庄之间要走很长的路。所以，村民们就希望能开通这些公路上的公共交通路线，方便大家的出行。\n\n巴士运营公司采纳了这个意见。同时，巴士公司认为这些巴士线路必须满足下述条件：\n\n1.每条巴士线路的起点和终点都在村庄内，巴士开行的线路都沿着公路；\n\n2.每条公路都要有巴士线路覆盖，这样村民们的出行就只需要换成巴士车就行了；\n\n3.每条公路只被一条巴士线路覆盖，且只被覆盖一次，否则巴士公司觉得在成本上不划算；\n\n4.巴士线路的总数应当最少，这样才能方便管理。\n\n例如，如果6个村庄之间的5条公路是这样的：\n\n![](https://cdn.luogu.com.cn/upload/pic/19772.png)\n\n那么这样的3条巴士线路就能满足上面的条件：1-2-3，2-4，5-4-6。\n\n不过，居民们自然认为“巴士换乘”是不方便的，因此他们希望从一个村庄乘车去另一个村庄的路上换乘次数的最大值尽可能少。例如上面这个线路安排中，从村庄1到村庄6需要换成2次，是最大的换乘次数。\n\n另一方面，巴士公司认为，一条公交线路越长意味着，一旦巴士车发生故障，受影响耽误时间的乘客就越多。所以巴士公司希望，最长的一条线路尽可能短。所谓短，就是途经的村庄少。\n\n现在，这个巴士线路设计的任务交给了参加SHTSC的你，你当然要同时考虑上面两方面的因素，所以，你必须计算出：(1)换乘次数的最大值最小可能值(2)最长的线路途经村庄数的最小可能值。", "inputFormat": "输入数据的第一行是一个整数n，表示村庄的数目。\n\n接下去每行有两个整数x、y，分别描述一条公路，表示村庄x、y之间有一条公路。\n\n输入文件保证，每条公路只会被描述一次。", "outputFormat": "输出文件有三行：\n\n第一行是一个整数，表示公交线路安排中包含的路线数。\n\n第二行是一个整数，表示换乘次数的最大值的最小可能值。\n\n第三行是一个整数，表示最长的线路途经村庄数的最小可能值。", "hint": "如果你的输出的第一行与标准答案相等，你能得2分。\n\n如果你的输出的第二行与标准答案相等，你能得4分。\n\n如果你的输出的第三行与标准答案相等，你能得4分。\n\n对于70%的数据：n<=300\n对于100%的数据：n<=$10^5$", "locale": "zh-CN"}}}
{"pid": "P4626", "type": "P", "difficulty": 3, "samples": [["10", "2520"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "素数判断,质数,筛法", "bitset"], "title": "一道水题 II", "background": "", "description": "一天，szb 在上学的路上遇到了灰太狼。\n\n灰太狼：帮我们做出这道题就放了你。  \nszb：什么题？  \n灰太狼：求一个能被 $[1,n]$ 内所有数整除的最小数字，并对 $100000007$ 取模。  \nszb：这题太水了，就让我小弟来做好了。\n\n然后你就光荣的接受了这个任务。", "inputFormat": "一行一个数 $n$。", "outputFormat": "一行一个数 $ans$。", "hint": "$n \\le 10^8$", "locale": "zh-CN", "translations": {"en": {"title": "A Very Easy Problem II", "background": "", "description": "One day, on the way to school, szb met Grey Wolf.\n\nGrey Wolf: If you solve this problem for us, we will let you go.  \nszb: What problem?  \nGrey Wolf: Find the smallest number that is divisible by every number in $[1,n]$, and take it modulo $100000007$.  \nszb: This is too easy. I will have my little brother do it.\n\nThen you proudly accepted this task.", "inputFormat": "One line with one number $n$.", "outputFormat": "One line with one number $ans$.", "hint": "$n \\le 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "一道水题 II", "background": "", "description": "一天，szb 在上学的路上遇到了灰太狼。\n\n灰太狼：帮我们做出这道题就放了你。  \nszb：什么题？  \n灰太狼：求一个能被 $[1,n]$ 内所有数整除的最小数字，并对 $100000007$ 取模。  \nszb：这题太水了，就让我小弟来做好了。\n\n然后你就光荣的接受了这个任务。", "inputFormat": "一行一个数 $n$。", "outputFormat": "一行一个数 $ans$。", "hint": "$n \\le 10^8$", "locale": "zh-CN"}}}
{"pid": "P4627", "type": "P", "difficulty": 6, "samples": [["5\nLLLLB\n3\n1 3 6\n0 3 R\n1 3 6", "2\n1"], ["8\nLLLLBRRR\n7\n1 1 9\n1 4 7\n0 2 R\n1 1 9\n1 2 9\n0 7 B\n1 3 5", "4\n2\n1\n0\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "上海"], "title": "[SHOI2010] 滚动的正四面体", "background": "", "description": "正四面体总共有4个面，每个面都是一个正三角形。现在把它的一个面标记上字母A，如图 3中所示，A标记在底面上：\n\n![](https://cdn.luogu.com.cn/upload/pic/19848.png)\n\n一个正四面体的一次滚动显然有3个方向可以选择：向左（L）、向右（R）、向后（B）。如图 4所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/19850.png)\n\n于是，这个正四面体的滚动过程就可以用一个只包含“L”“R”“B”的字符串来描述。\n\n初始时，正四面体的A面朝下，现在SECSA将给这个正四面体一串滚动指令——当然就是一个这样的字符串——让这个正四面体每秒滚动一下。也就是说，第1秒内正四面体A面朝下，第1秒末执行第一条指令，第2秒末执行第2条指令，依次类推，直至将整个指令串执行完毕。\n\n你的任务就是当SECSA询问你的时候告诉他：这个正四面体在第L秒到第R秒内A面有多少秒朝着地面。\n\n当然，SECSA可能因为对这个正四面体的滚动路径不满意，他随时会修改他的某一条指令。因此你的程序应该能执行下面两个操作：\n\n(1)接受SECSA修个第i条指令的信息\n\n(2)回答SECSA的“在第L秒到第R秒内A面有多少秒朝着地面”的询问\n\n例如，假如原指令串为“LLLLB”，那么第1、4、6秒内A面是朝下的。此时，如果SECSA向你询问第3秒到第6秒的情况，你就应该回答“2”。而SECSA将第3条指令修改为“R”的话，指令串就变成了“LLRLB”，那么正四面体就只有在第1、5秒内A面朝下了。如图 5所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/19851.png)\n\n", "inputFormat": "输入文件的第一行是一个整数n，表示指令串中包含的指令条数。\n\n输入文件的第二行是一个字符串，共包含n个字符，每个字符是“L”“R”“B”之一，表示初始的指令串。\n\n输入文件的第三行是一个整数m，表示你的程序需要处理的操作总数。\n\n接下去m行，每行描述一个操作，为以下两种格式之一：\n\n(1)0 i c：表示把第i个操作改成c，c为“L”“R”“B”之一\n\n(2)1 L R：表示询问第L秒到第R秒内，A面有多少秒朝下\n\n输入文件保证：1<=i<=n，1<=L<=R<=n+1。", "outputFormat": "输出文件对于每一个询问操作依次输出你的程序给出的回答，每个回答为一个整数，占一行。", "hint": "第1个样例就是问题描述中的例子\n\n在第2个样例中，按照原指令“LLLLBRRR”，则第1、4、6、9秒内A面向下；按照第一次修改后的指令“LRLLBRRR”，则只有第1秒内A面向下；按照第二次修改后的指令“LRLLBRBR”，则第1、9秒内A面向下。\n\n1<=n<=60000\n\n1<=m<=150000", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2010] Rolling Regular Tetrahedron", "background": "", "description": "A regular tetrahedron has 4 faces, and each face is an equilateral triangle. Now mark one of its faces with the letter A. As shown in Figure 3, A is marked on the bottom face:\n\n![](https://cdn.luogu.com.cn/upload/pic/19848.png)\n\nIn one roll, a regular tetrahedron clearly has 3 possible directions: left (L), right (R), and back (B). As shown in Figure 4:\n\n![](https://cdn.luogu.com.cn/upload/pic/19850.png)\n\nTherefore, the rolling process of this tetrahedron can be described by a string containing only “L”, “R”, and “B”.\n\nInitially, face A of the tetrahedron faces downward. Now SECSA will give this tetrahedron a sequence of rolling instructions—of course, such a string—and make the tetrahedron roll once per second. That is, during the 1st second, face A faces downward; at the end of the 1st second the first instruction is executed; at the end of the 2nd second the second instruction is executed; and so on, until the whole instruction string is executed.\n\nYour task is: when SECSA asks you, tell him how many seconds, from the L-th second to the R-th second, face A is facing the ground.\n\nOf course, SECSA may be dissatisfied with the rolling path of this tetrahedron, and he may modify any one instruction at any time. Therefore, your program should be able to perform the following two operations:\n\n(1) Accept SECSA’s modification of the i-th instruction.\n\n(2) Answer SECSA’s query: “From the L-th second to the R-th second, how many seconds is face A facing the ground?”\n\nFor example, suppose the original instruction string is “LLLLB”. Then during the 1st, 4th, and 6th seconds, face A is facing downward. At this time, if SECSA asks about the 3rd second to the 6th second, you should answer “2”. If SECSA changes the 3rd instruction to “R”, the instruction string becomes “LLRLB”, and then the tetrahedron is facing downward only during the 1st and 5th seconds. As shown in Figure 5:\n\n![](https://cdn.luogu.com.cn/upload/pic/19851.png)", "inputFormat": "The first line of the input file is an integer $n$, indicating the number of instructions in the instruction string.\n\nThe second line is a string containing $n$ characters. Each character is one of “L”, “R”, and “B”, representing the initial instruction string.\n\nThe third line is an integer $m$, indicating the total number of operations your program needs to process.\n\nIn the next $m$ lines, each line describes an operation in one of the following two formats:\n\n(1) `0 i c`: Change the $i$-th instruction to $c$, where $c$ is one of “L”, “R”, and “B”.\n\n(2) `1 L R`: Query how many seconds, from the $L$-th second to the $R$-th second, face A is facing downward.\n\nThe input guarantees: $1<=i<=n$, $1<=L<=R<=n+1$.", "outputFormat": "For each query operation, output your program’s answer in order. Each answer is an integer, one per line.", "hint": "The first sample is the example in the problem description.\n\nIn the second sample, with the original instructions “LLLLBRRR”, face A faces downward during the 1st, 4th, 6th, and 9th seconds. After the first modification, the instructions become “LRLLBRRR”, and then face A faces downward only during the 1st second. After the second modification, the instructions become “LRLLBRBR”, and then face A faces downward during the 1st and 9th seconds.\n\nConstraints:\n\n$1<=n<=60000$\n\n$1<=m<=150000$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2010] 滚动的正四面体", "background": "", "description": "正四面体总共有4个面，每个面都是一个正三角形。现在把它的一个面标记上字母A，如图 3中所示，A标记在底面上：\n\n![](https://cdn.luogu.com.cn/upload/pic/19848.png)\n\n一个正四面体的一次滚动显然有3个方向可以选择：向左（L）、向右（R）、向后（B）。如图 4所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/19850.png)\n\n于是，这个正四面体的滚动过程就可以用一个只包含“L”“R”“B”的字符串来描述。\n\n初始时，正四面体的A面朝下，现在SECSA将给这个正四面体一串滚动指令——当然就是一个这样的字符串——让这个正四面体每秒滚动一下。也就是说，第1秒内正四面体A面朝下，第1秒末执行第一条指令，第2秒末执行第2条指令，依次类推，直至将整个指令串执行完毕。\n\n你的任务就是当SECSA询问你的时候告诉他：这个正四面体在第L秒到第R秒内A面有多少秒朝着地面。\n\n当然，SECSA可能因为对这个正四面体的滚动路径不满意，他随时会修改他的某一条指令。因此你的程序应该能执行下面两个操作：\n\n(1)接受SECSA修个第i条指令的信息\n\n(2)回答SECSA的“在第L秒到第R秒内A面有多少秒朝着地面”的询问\n\n例如，假如原指令串为“LLLLB”，那么第1、4、6秒内A面是朝下的。此时，如果SECSA向你询问第3秒到第6秒的情况，你就应该回答“2”。而SECSA将第3条指令修改为“R”的话，指令串就变成了“LLRLB”，那么正四面体就只有在第1、5秒内A面朝下了。如图 5所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/19851.png)\n\n", "inputFormat": "输入文件的第一行是一个整数n，表示指令串中包含的指令条数。\n\n输入文件的第二行是一个字符串，共包含n个字符，每个字符是“L”“R”“B”之一，表示初始的指令串。\n\n输入文件的第三行是一个整数m，表示你的程序需要处理的操作总数。\n\n接下去m行，每行描述一个操作，为以下两种格式之一：\n\n(1)0 i c：表示把第i个操作改成c，c为“L”“R”“B”之一\n\n(2)1 L R：表示询问第L秒到第R秒内，A面有多少秒朝下\n\n输入文件保证：1<=i<=n，1<=L<=R<=n+1。", "outputFormat": "输出文件对于每一个询问操作依次输出你的程序给出的回答，每个回答为一个整数，占一行。", "hint": "第1个样例就是问题描述中的例子\n\n在第2个样例中，按照原指令“LLLLBRRR”，则第1、4、6、9秒内A面向下；按照第一次修改后的指令“LRLLBRRR”，则只有第1秒内A面向下；按照第二次修改后的指令“LRLLBRBR”，则第1、9秒内A面向下。\n\n1<=n<=60000\n\n1<=m<=150000", "locale": "zh-CN"}}}
{"pid": "P4628", "type": "P", "difficulty": 0, "samples": [["5 4\n1 2\n1 3\n1 4\n1 5", "12"], ["5 7\n1 2\n1 3\n1 4\n2 3\n2 4\n5 3\n5 4", "2"], ["4 6\n1 2\n2 3\n2 3\n3 4\n4 1\n4 1", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "上海"], "title": "[SHOI2010] 电脑网络", "background": "", "description": "SHOI 的领队为了方便大家交流，决定在大家集训的机房里建立起一个局域网络。现在的机房里一共有 $n$ 台电脑终端，SHOI 的领队使用了 $m$ 条网线去建立这个局域网，每条网线都把某两台电脑连接起来使得它们可以双向通信。现在这个网络是连通的，也就是说，任意两台电脑之间都可以直接的或间接的通信。\n\n为了在整个备战过程中，确保所有学生之间通过这个电脑网络的交流，SHOI 的领队想要知道：“如果某台电脑 $\\texttt{A}\n$ 因故障关机的同时某一条网线 $\\texttt{L}$（并非连接在 $\\texttt{A}$ 上的）被切断，那么，除了 $\\texttt{A}$ 以外的其他电脑能否保持相互通信？”\n\n于是，SHOI 的领队需要你计算这个局域网络的“不稳定程度”。不稳定程度是指：通过从网络中移除一台电脑且切断一条网线（这条网线不连接在这台电脑上）使得整个网络中的其他电脑之间通讯不完全连通的不同方案的总数。\n", "inputFormat": "输入文件的第一行有两个正整数 $n$、$m$，分别表示网络中的电脑终端的数量以及用来连接电脑的网线数量。\n\n接下来 $m$ 行每行有两个整数 $x$、$y$ 来描述一条网线，表示这条网线连接了编号为 $x$、$y$ 的电脑，且 $x$ 不等于 $y$。\n\n输入文件保证，这个电脑网络初始时是连通的。\n", "outputFormat": "输出文件只有一行，这行只有一个整数，即为通过从网络中移除一台电脑且切断一条网线使得整个网络不连通的不同方案总数。\n", "hint": "- $1 \\leq n \\leq 2 \\times 10^3$；\n- $1 \\leq m \\leq 2 \\times 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2010] Computer Network", "background": "", "description": "The leader of SHOI, in order to make it easier for everyone to communicate, decided to build a local area network (LAN) in the computer room where they are training. There are $n$ computer terminals in the room. The leader used $m$ network cables to build this LAN. Each cable connects two computers so that they can communicate in both directions. The network is now connected, meaning that any two computers can communicate directly or indirectly.\n\nTo ensure that all students can keep communicating through this computer network during the whole preparation period, the leader wants to know: “If some computer $\\texttt{A}$ shuts down due to a failure, and at the same time some cable $\\texttt{L}$ (which is not connected to $\\texttt{A}$) is cut, can the other computers (except $\\texttt{A}$) still remain mutually connected?”\n\nTherefore, the leader needs you to compute the “instability” of this LAN. The instability is defined as: the total number of different ways to remove one computer from the network and cut one cable (and this cable is not incident to that computer), such that the remaining computers in the network are not fully connected (i.e., communication among them is not completely connected).", "inputFormat": "The first line of the input contains two positive integers $n$ and $m$, representing the number of computer terminals in the network and the number of cables used to connect them.\n\nIn the next $m$ lines, each line contains two integers $x$ and $y$ describing a cable, meaning that this cable connects computers numbered $x$ and $y$, and $x \\neq y$.\n\nThe input guarantees that the network is connected initially.", "outputFormat": "Output one line containing one integer: the total number of different ways to remove one computer and cut one cable that make the network disconnected.", "hint": "- $1 \\leq n \\leq 2 \\times 10^3$;\n- $1 \\leq m \\leq 2 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2010] 电脑网络", "background": "", "description": "SHOI 的领队为了方便大家交流，决定在大家集训的机房里建立起一个局域网络。现在的机房里一共有 $n$ 台电脑终端，SHOI 的领队使用了 $m$ 条网线去建立这个局域网，每条网线都把某两台电脑连接起来使得它们可以双向通信。现在这个网络是连通的，也就是说，任意两台电脑之间都可以直接的或间接的通信。\n\n为了在整个备战过程中，确保所有学生之间通过这个电脑网络的交流，SHOI 的领队想要知道：“如果某台电脑 $\\texttt{A}\n$ 因故障关机的同时某一条网线 $\\texttt{L}$（并非连接在 $\\texttt{A}$ 上的）被切断，那么，除了 $\\texttt{A}$ 以外的其他电脑能否保持相互通信？”\n\n于是，SHOI 的领队需要你计算这个局域网络的“不稳定程度”。不稳定程度是指：通过从网络中移除一台电脑且切断一条网线（这条网线不连接在这台电脑上）使得整个网络中的其他电脑之间通讯不完全连通的不同方案的总数。\n", "inputFormat": "输入文件的第一行有两个正整数 $n$、$m$，分别表示网络中的电脑终端的数量以及用来连接电脑的网线数量。\n\n接下来 $m$ 行每行有两个整数 $x$、$y$ 来描述一条网线，表示这条网线连接了编号为 $x$、$y$ 的电脑，且 $x$ 不等于 $y$。\n\n输入文件保证，这个电脑网络初始时是连通的。\n", "outputFormat": "输出文件只有一行，这行只有一个整数，即为通过从网络中移除一台电脑且切断一条网线使得整个网络不连通的不同方案总数。\n", "hint": "- $1 \\leq n \\leq 2 \\times 10^3$；\n- $1 \\leq m \\leq 2 \\times 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P4629", "type": "P", "difficulty": 6, "samples": [["5\n1 1 1 1 1\n1 1 1 1 1\n1 2\n2 3\n3 4\n4 5", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "各省省选", "上海"], "title": "[SHOI2015] 聚变反应炉", "background": "", "description": "曾经发明了零件组装机的发明家 SHTSC 又公开了他的新发明：聚变反应炉——一种可以产生大量清洁能量的神秘装置。\n\n众所周知，利用核聚变产生的能量有两个难点：一是控制核聚变反应的反应强度，二是使用较少的能量激发聚变反应。而 SHTSC 已经完美解决了第一个问题。一个聚变反应炉由若干个相连的聚变块组成，为了能够使得聚变反应可控，SHTSC 保证任意两个聚能块都可以通过相互之间的链接到达，并且没有一个聚能块可以不重复经过一个链接回到它自己。\n\n但是第二个问题 SHTSC 还没有完全解决。在他设计的聚变反应炉当中，每个聚变块都需要一定的初始能量 $d_i$ 来进行激发，不过 SHTSC 不需要手动激发所有聚变块，这是因为一旦一个聚变块被激发，则会向与其直接相连的所有还未被激发的聚变块传送 $c_i$ 个单位的能量。这样后被触发的聚变块可以以更低的初始能量来激发，甚至可能不需要额外的外界能量就可自行激发，从而降低了总激发能量的消耗。现在给出了一个聚变反应炉，求至少要多少能量才能激发所有聚变块。", "inputFormat": "第一行一个整数 $n$，表示共有 $n$ 个聚能块，由 $1$ 至 $n$ 编号。  \n\n第二行 $n$ 个整数，依次表示 $d_i$。  \n\n第三行 $n$ 个整数，依次表示 $c_i$。  \n\n以下 $n - 1$ 行每行两个整数 $u, v$，表示编号为 $u$ 和 $v$ 的聚能块是相连的。", "outputFormat": "一行一个整数，表示至少需要多少个单位的能量才能激发所有聚变块。", "hint": "| Case # | $\\max\\{c_i\\}$ | $n$ | 附加限制 |\n|:---:|:---:|:---:|:---:|\n| 1 | $= 1$ | $\\leq 10$ | $c_i = 1$ |\n| 2 | $= 1$ | $\\leq 100$ | $c_i = 1$ |\n| 3 | $= 1$ | $\\leq 200$ | $c_i = 1$ |\n| 4 | $= 0$ | $\\leq 10$ | - |\n| 5 | $= 1$ | $\\leq 200$ | $c_i = 1$ |\n| 6 | $= 1$ | $\\leq 200$ | - |\n| 7 | $= 1$ | $\\leq 100000$ | $c_i = 1$ |\n| 8 | $= 0$ | $\\leq 100000$ | - |\n| 9 | $= 1$ | $\\leq 100000$ | - |\n| 10 | $= 1$ | $\\leq 100000$ | - |\n| 11 | $\\leq 5$ | $\\leq 20$ | - |\n| 12 | $\\leq 5$ | $\\leq 20$ | $c_i$ 均相等 |\n| 13 | $\\leq 5$ | $\\leq 200$ | - |\n| 14 | $\\leq 5$ | $\\leq 200$ | $c_i$ 均相等 |\n| 15 | $\\leq 5$ | $\\leq 200$ | - |\n| 16 | $\\leq 5$ | $\\leq 200$ | - |\n| 17 | $\\leq 5$ | $\\leq 2000$ | $c_i$ 均相等 |\n| 18 | $\\leq 5$ | $\\leq 2000$ | - |\n| 19 | $\\leq 5$ | $\\leq 2000$ | - |\n| 20 | $\\leq 5$ | $\\leq 2000$ | - |\n\n对于所有数据，保证 $1 \\le d_i, \\sum d_i \\le {10}^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2015] Fusion Reactor", "background": "", "description": "The inventor SHTSC, who once created the parts assembler, has now revealed his new invention: a fusion reactor—a mysterious device that can produce a large amount of clean energy.\n\nAs is well known, there are two difficulties in harnessing energy from nuclear fusion: one is controlling the intensity of the fusion reaction, and the other is activating the fusion reaction using as little energy as possible. SHTSC has perfectly solved the first problem. A fusion reactor consists of several interconnected fusion blocks. To ensure controllability, SHTSC guarantees that any two fusion blocks can reach each other via links, and no fusion block can return to itself without repeating an edge. In other words, the links form a tree.\n\nHowever, the second problem is not fully solved. In his design, each fusion block requires a certain initial energy $d_i$ to be activated. Nevertheless, SHTSC does not need to activate all blocks manually, because once a fusion block is activated, it sends $c_i$ units of energy to all directly connected fusion blocks that have not yet been activated. In this way, fusion blocks activated later can be activated with lower initial energy, or even without any additional external energy, thereby reducing the total activation energy. Given a fusion reactor, find the minimum amount of energy required to activate all fusion blocks.", "inputFormat": "The first line contains an integer $n$, indicating that there are $n$ fusion blocks, numbered $1$ to $n$.  \nThe second line contains $n$ integers, representing $d_i$ in order.  \nThe third line contains $n$ integers, representing $c_i$ in order.  \nEach of the following $n - 1$ lines contains two integers $u, v$, indicating that fusion blocks $u$ and $v$ are connected.", "outputFormat": "Output a single integer on one line, indicating the minimum number of energy units required to activate all fusion blocks.", "hint": "| Case # | $\\max\\{c_i\\}$ | $n$ | Additional constraints |\n|:---:|:---:|:---:|:---:|\n| 1 | $= 1$ | $\\leq 10$ | $c_i = 1$ |\n| 2 | $= 1$ | $\\leq 100$ | $c_i = 1$ |\n| 3 | $= 1$ | $\\leq 200$ | $c_i = 1$ |\n| 4 | $= 0$ | $\\leq 10$ | - |\n| 5 | $= 1$ | $\\leq 200$ | $c_i = 1$ |\n| 6 | $= 1$ | $\\leq 200$ | - |\n| 7 | $= 1$ | $\\leq 100000$ | $c_i = 1$ |\n| 8 | $= 0$ | $\\leq 100000$ | - |\n| 9 | $= 1$ | $\\leq 100000$ | - |\n| 10 | $= 1$ | $\\leq 100000$ | - |\n| 11 | $\\leq 5$ | $\\leq 20$ | - |\n| 12 | $\\leq 5$ | $\\leq 20$ | $c_i$ are all equal |\n| 13 | $\\leq 5$ | $\\leq 200$ | - |\n| 14 | $\\leq 5$ | $\\leq 200$ | $c_i$ are all equal |\n| 15 | $\\leq 5$ | $\\leq 200$ | - |\n| 16 | $\\leq 5$ | $\\leq 200$ | - |\n| 17 | $\\leq 5$ | $\\leq 2000$ | $c_i$ are all equal |\n| 18 | $\\leq 5$ | $\\leq 2000$ | - |\n| 19 | $\\leq 5$ | $\\leq 2000$ | - |\n| 20 | $\\leq 5$ | $\\leq 2000$ | - |\n\nFor all testdata, it is guaranteed that $1 \\le d_i, \\sum d_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2015] 聚变反应炉", "background": "", "description": "曾经发明了零件组装机的发明家 SHTSC 又公开了他的新发明：聚变反应炉——一种可以产生大量清洁能量的神秘装置。\n\n众所周知，利用核聚变产生的能量有两个难点：一是控制核聚变反应的反应强度，二是使用较少的能量激发聚变反应。而 SHTSC 已经完美解决了第一个问题。一个聚变反应炉由若干个相连的聚变块组成，为了能够使得聚变反应可控，SHTSC 保证任意两个聚能块都可以通过相互之间的链接到达，并且没有一个聚能块可以不重复经过一个链接回到它自己。\n\n但是第二个问题 SHTSC 还没有完全解决。在他设计的聚变反应炉当中，每个聚变块都需要一定的初始能量 $d_i$ 来进行激发，不过 SHTSC 不需要手动激发所有聚变块，这是因为一旦一个聚变块被激发，则会向与其直接相连的所有还未被激发的聚变块传送 $c_i$ 个单位的能量。这样后被触发的聚变块可以以更低的初始能量来激发，甚至可能不需要额外的外界能量就可自行激发，从而降低了总激发能量的消耗。现在给出了一个聚变反应炉，求至少要多少能量才能激发所有聚变块。", "inputFormat": "第一行一个整数 $n$，表示共有 $n$ 个聚能块，由 $1$ 至 $n$ 编号。  \n\n第二行 $n$ 个整数，依次表示 $d_i$。  \n\n第三行 $n$ 个整数，依次表示 $c_i$。  \n\n以下 $n - 1$ 行每行两个整数 $u, v$，表示编号为 $u$ 和 $v$ 的聚能块是相连的。", "outputFormat": "一行一个整数，表示至少需要多少个单位的能量才能激发所有聚变块。", "hint": "| Case # | $\\max\\{c_i\\}$ | $n$ | 附加限制 |\n|:---:|:---:|:---:|:---:|\n| 1 | $= 1$ | $\\leq 10$ | $c_i = 1$ |\n| 2 | $= 1$ | $\\leq 100$ | $c_i = 1$ |\n| 3 | $= 1$ | $\\leq 200$ | $c_i = 1$ |\n| 4 | $= 0$ | $\\leq 10$ | - |\n| 5 | $= 1$ | $\\leq 200$ | $c_i = 1$ |\n| 6 | $= 1$ | $\\leq 200$ | - |\n| 7 | $= 1$ | $\\leq 100000$ | $c_i = 1$ |\n| 8 | $= 0$ | $\\leq 100000$ | - |\n| 9 | $= 1$ | $\\leq 100000$ | - |\n| 10 | $= 1$ | $\\leq 100000$ | - |\n| 11 | $\\leq 5$ | $\\leq 20$ | - |\n| 12 | $\\leq 5$ | $\\leq 20$ | $c_i$ 均相等 |\n| 13 | $\\leq 5$ | $\\leq 200$ | - |\n| 14 | $\\leq 5$ | $\\leq 200$ | $c_i$ 均相等 |\n| 15 | $\\leq 5$ | $\\leq 200$ | - |\n| 16 | $\\leq 5$ | $\\leq 200$ | - |\n| 17 | $\\leq 5$ | $\\leq 2000$ | $c_i$ 均相等 |\n| 18 | $\\leq 5$ | $\\leq 2000$ | - |\n| 19 | $\\leq 5$ | $\\leq 2000$ | - |\n| 20 | $\\leq 5$ | $\\leq 2000$ | - |\n\n对于所有数据，保证 $1 \\le d_i, \\sum d_i \\le {10}^9$。", "locale": "zh-CN"}}}
{"pid": "P4630", "type": "P", "difficulty": 6, "samples": [["4 3\n1 2\n2 3\n3 4\n", "8\n"], ["4 4\n1 2\n2 3\n3 4\n4 2\n", "14\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "APIO", "双连通分量", "圆方树"], "title": "[APIO2018] 铁人两项", "background": "", "description": "比特镇的路网由 $m$ 条双向道路连接的 $n$ 个交叉路口组成。\n\n最近，比特镇获得了一场铁人两项锦标赛的主办权。这场比赛共有两段赛程：选手先完成一段长跑赛程，然后骑自行车完成第二段赛程。\n\n比赛的路线要按照如下方法规划：\n\n1. 先选择三个两两互不相同的路口 $s$、$c$ 和 $f$，分别作为比赛的起点、切换点（运动员在长跑到达这个点后，骑自行车前往终点）、终点。\n2. 选择一条从 $s$ 出发，经过 $c$ 最终到达 $f$ 的路径。考虑到安全因素，选择的路径经过同一个点至多一次。\n\n在规划路径之前，镇长想请你帮忙计算，总共有多少种不同的选取 $s$、$c$ 和 $f$ 的方案，使得在第 $2$ 步中至少能设计出一条满足要求的路径。\n", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，分别表示交叉路口和双向道路的数量。\n\n接下来 $m$ 行，每行两个整数 $v_i, u_i$。表示存在一条双向道路连接交叉路口 $v_i, u_i$（$1 \\le v_i, u_i \\le n$，$v_i \\neq u_i$）。\n\n保证任意两个交叉路口之间，至多被一条双向道路直接连接。", "outputFormat": "输出一行，包括一个整数，表示能满足要求的不同的选取 $s$、$c$ 和 $f$ 的方案数。", "hint": "**提示**\n\n在第一个样例中，有以下 $8$ 种不同的选择 $(s, c, f)$ 的方案：\n\n- $(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4), (3, 2, 1)$；\n- $(4, 2, 1), (4, 3, 1), (4, 3, 2)$。\n\n在第二个样例中，有以下 $14$ 种不同的选择 $(s, c, f)$ 的方案：\n\n- $(1, 2, 3), (1, 2, 4), (1, 3, 4), (1, 4, 3), (2, 3, 4)$；\n- $(2, 4, 3), (3, 2, 1), (3, 2, 4), (3, 4, 1), (3, 4, 2)$；\n- $(4, 2, 1), (4, 2, 3), (4, 3, 1), (4, 3, 2)$。\n\n**子任务**\n\n- Subtask 1（points: $5$）：$n \\leq 10$，$m \\leq 100$。\n- Subtask 2（points: $11$）：$n \\leq 50$，$m \\leq 100$。\n- Subtask 3（points: $8$）：$n \\leq 100000$，每个交叉路口至多作为两条双向道路的端点。\n- Subtask 4（points: $10$）：$n \\leq 1000$，在路网中不存在环（存在环是指存在一个长度为 $k$（$k \\ge 3$）的交叉路口序列 $v_1, v_2, \\ldots, v_k$，序列中的路口编号两两不同，且对于 $i$ 从 $1$ 到 $k - 1$，有一条双向道路直接连接路口 $v_i$ 和 $v_{i+1}$，且有一条双向道路直接连接路口 $v_k$ 和 $v_1$）。\n- Subtask 5（points: $13$）：$n \\leq 100000$，在路网中不存在环。\n- Subtask 6（points: $15$）：$n \\leq 1000$，对于每个交叉路口，至多被一个环包含。\n- Subtask 7（points: $20$）：$n \\leq 100000$，对于每个交叉路口，至多被一个环包含。\n- Subtask 8（points: $8$）：$n \\leq 1000$，$m \\leq 2000$。\n- Subtask 9（points: $10$）：$n \\leq 100000$，$m \\leq 200000$。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2018] Triathlon", "background": "", "description": "Bit Town’s road network consists of $n$ intersections connected by $m$ bidirectional roads.\n\nRecently, Bit Town obtained the right to host a triathlon championship. The race has two stages: contestants first complete a long-distance running stage, and then ride a bicycle to complete the second stage.\n\nThe race route must be planned as follows:\n\n1. First, choose three pairwise distinct intersections $s$, $c$, and $f$, as the start point, the transition point (after reaching this point during the running stage, athletes ride a bicycle to the finish), and the finish point.\n2. Choose a path that starts from $s$, passes through $c$, and finally reaches $f$. For safety reasons, the chosen path visits each intersection at most once.\n\nBefore planning the route, the mayor wants you to help compute how many different ways there are to choose $s$, $c$, and $f$, such that in step 2 there is at least one path that satisfies the requirement.", "inputFormat": "The first line contains two integers $n$ and $m$, representing the number of intersections and the number of bidirectional roads.\n\nThe next $m$ lines each contain two integers $v_i, u_i$, indicating that there is a bidirectional road directly connecting intersections $v_i$ and $u_i$ ($1 \\le v_i, u_i \\le n$, $v_i \\neq u_i$).\n\nIt is guaranteed that any two intersections are directly connected by at most one bidirectional road.", "outputFormat": "Output one line containing one integer, the number of different ways to choose $s$, $c$, and $f$ that satisfy the requirement.", "hint": "**Hint**\n\nIn the first sample, there are the following $8$ different choices of $(s, c, f)$:\n\n- $(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4), (3, 2, 1)$;\n- $(4, 2, 1), (4, 3, 1), (4, 3, 2)$.\n\nIn the second sample, there are the following $14$ different choices of $(s, c, f)$:\n\n- $(1, 2, 3), (1, 2, 4), (1, 3, 4), (1, 4, 3), (2, 3, 4)$;\n- $(2, 4, 3), (3, 2, 1), (3, 2, 4), (3, 4, 1), (3, 4, 2)$;\n- $(4, 2, 1), (4, 2, 3), (4, 3, 1), (4, 3, 2)$.\n\n**Subtasks**\n\n- Subtask 1 (points: $5$): $n \\leq 10$, $m \\leq 100$.\n- Subtask 2 (points: $11$): $n \\leq 50$, $m \\leq 100$.\n- Subtask 3 (points: $8$): $n \\leq 100000$, each intersection is an endpoint of at most two bidirectional roads.\n- Subtask 4 (points: $10$): $n \\leq 1000$, there are no cycles in the road network (a cycle means that there exists a sequence of intersections of length $k$ ($k \\ge 3$), $v_1, v_2, \\ldots, v_k$, where all intersection labels in the sequence are pairwise distinct, and for $i$ from $1$ to $k - 1$ there is a bidirectional road directly connecting $v_i$ and $v_{i+1}$, and there is also a bidirectional road directly connecting $v_k$ and $v_1$).\n- Subtask 5 (points: $13$): $n \\leq 100000$, there are no cycles in the road network.\n- Subtask 6 (points: $15$): $n \\leq 1000$, each intersection belongs to at most one cycle.\n- Subtask 7 (points: $20$): $n \\leq 100000$, each intersection belongs to at most one cycle.\n- Subtask 8 (points: $8$): $n \\leq 1000$, $m \\leq 2000$.\n- Subtask 9 (points: $10$): $n \\leq 100000$, $m \\leq 200000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2018] 铁人两项", "background": "", "description": "比特镇的路网由 $m$ 条双向道路连接的 $n$ 个交叉路口组成。\n\n最近，比特镇获得了一场铁人两项锦标赛的主办权。这场比赛共有两段赛程：选手先完成一段长跑赛程，然后骑自行车完成第二段赛程。\n\n比赛的路线要按照如下方法规划：\n\n1. 先选择三个两两互不相同的路口 $s$、$c$ 和 $f$，分别作为比赛的起点、切换点（运动员在长跑到达这个点后，骑自行车前往终点）、终点。\n2. 选择一条从 $s$ 出发，经过 $c$ 最终到达 $f$ 的路径。考虑到安全因素，选择的路径经过同一个点至多一次。\n\n在规划路径之前，镇长想请你帮忙计算，总共有多少种不同的选取 $s$、$c$ 和 $f$ 的方案，使得在第 $2$ 步中至少能设计出一条满足要求的路径。\n", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，分别表示交叉路口和双向道路的数量。\n\n接下来 $m$ 行，每行两个整数 $v_i, u_i$。表示存在一条双向道路连接交叉路口 $v_i, u_i$（$1 \\le v_i, u_i \\le n$，$v_i \\neq u_i$）。\n\n保证任意两个交叉路口之间，至多被一条双向道路直接连接。", "outputFormat": "输出一行，包括一个整数，表示能满足要求的不同的选取 $s$、$c$ 和 $f$ 的方案数。", "hint": "**提示**\n\n在第一个样例中，有以下 $8$ 种不同的选择 $(s, c, f)$ 的方案：\n\n- $(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4), (3, 2, 1)$；\n- $(4, 2, 1), (4, 3, 1), (4, 3, 2)$。\n\n在第二个样例中，有以下 $14$ 种不同的选择 $(s, c, f)$ 的方案：\n\n- $(1, 2, 3), (1, 2, 4), (1, 3, 4), (1, 4, 3), (2, 3, 4)$；\n- $(2, 4, 3), (3, 2, 1), (3, 2, 4), (3, 4, 1), (3, 4, 2)$；\n- $(4, 2, 1), (4, 2, 3), (4, 3, 1), (4, 3, 2)$。\n\n**子任务**\n\n- Subtask 1（points: $5$）：$n \\leq 10$，$m \\leq 100$。\n- Subtask 2（points: $11$）：$n \\leq 50$，$m \\leq 100$。\n- Subtask 3（points: $8$）：$n \\leq 100000$，每个交叉路口至多作为两条双向道路的端点。\n- Subtask 4（points: $10$）：$n \\leq 1000$，在路网中不存在环（存在环是指存在一个长度为 $k$（$k \\ge 3$）的交叉路口序列 $v_1, v_2, \\ldots, v_k$，序列中的路口编号两两不同，且对于 $i$ 从 $1$ 到 $k - 1$，有一条双向道路直接连接路口 $v_i$ 和 $v_{i+1}$，且有一条双向道路直接连接路口 $v_k$ 和 $v_1$）。\n- Subtask 5（points: $13$）：$n \\leq 100000$，在路网中不存在环。\n- Subtask 6（points: $15$）：$n \\leq 1000$，对于每个交叉路口，至多被一个环包含。\n- Subtask 7（points: $20$）：$n \\leq 100000$，对于每个交叉路口，至多被一个环包含。\n- Subtask 8（points: $8$）：$n \\leq 1000$，$m \\leq 2000$。\n- Subtask 9（points: $10$）：$n \\leq 100000$，$m \\leq 200000$。", "locale": "zh-CN"}}}
{"pid": "P4631", "type": "P", "difficulty": 7, "samples": [["11\n9 9 2\n13 2 1\n11 8 2\n3 3 2\n3 12 1\n12 14 1\n9 8 5\n2 8 2\n5 2 1\n14 4 2\n14 14 1\n", "7 2 7 4 5 6 7 7 4 7 6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["搜索", "2018", "APIO", "剪枝"], "title": "[APIO2018] 选圆圈", "background": "", "description": "在平面上，有 $n$ 个圆，记为 $c_1, c_2,...,c_n$ 。我们尝试对这些圆运行这个算法：\n\n1. 找到这些圆中半径最大的。如果有多个半径最大的圆，选择编号最小的。记为 $c_i$。\n2. 删除 $c_i$ 及与其有交集的所有圆。两个圆有交集当且仅当平面上存在一个点，这个点同时在这两个圆的圆周上或圆内。（原文直译：如果平面上存在一个点被这两个圆所包含，我们称这两个圆有交集。一个点被一个圆包含，当且仅当它位于圆内或圆周上。）\n3. 重复上面两个步骤直到所有的圆都被删除。\n\n![QQ20180525194902.png](https://cdn.luogu.com.cn/upload/pic/19974.png)\n\n当 $c_i$ 被删除时，若循环中第 $1$ 步选择的圆是 $c_j$，我们说 $c_i$ 被 $c_j$ 删除。对于每个圆，求出它是被哪一个圆删除的。", "inputFormat": "第一行包含一个整数 $n$，表示开始时平面上圆的数量。\n\n接下来 $n$ 行，每行包含三个整数 $x_i, y_i, r_i$ 依次描述圆 $c_i$ 圆心的 $x$ 坐标、$y$ 坐标和它的半径。", "outputFormat": "输出一行，包含 $n$ 个整数 $a_1, a_2, ..., a_n$，其中 $a_i$ 表示圆 $c_i$ 是被圆 $c_{a_i}$ 删除的。", "hint": "**提示**\n\n题目描述中的图片对应了样例一中的情形。\n\n**子任务**\n\n- Subtask 1(points: $7$): $n \\leq 5000$\n- Subtask 2(points: $12$): $n \\leq 3 × 10^5$，对于所有的圆 $y_i = 0$\n- Subtask 3(points: $15$): $n \\leq 3 × 10^5$，每个圆最多和一个其他圆有交集\n- Subtask 4(points: $23$): $n \\leq 3 × 10^5$，所有的圆半径相同\n- Subtask 5(points: $30$): $n \\leq 10^5$\n- Subtask 6(points: $13$): $n \\leq 3 × 10^5$\n\n所有数据均满足：$-10^9 ≤ x_i, y_i ≤ 10^9, 1 ≤ r_i ≤ 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2018] Choosing Circles", "background": "", "description": "On a plane, there are $n$ circles, denoted by $c_1, c_2, ..., c_n$. We try to run the following algorithm on these circles:\n\n1. Find the circle with the largest radius. If there are multiple circles with the largest radius, choose the one with the smallest index. Denote it as $c_i$.\n2. Delete $c_i$ and all circles that intersect with it. Two circles intersect if and only if there exists a point on the plane that lies inside or on the boundary of both circles. (Literal translation of the original: If there exists a point on the plane that is contained by both circles, we say these two circles intersect. A point is contained by a circle if and only if it lies inside the circle or on its boundary.)\n3. Repeat the above two steps until all circles are deleted.\n\n![QQ20180525194902.png](https://cdn.luogu.com.cn/upload/pic/19974.png)\n\nWhen $c_i$ is deleted, if the circle chosen in Step 1 of that iteration is $c_j$, we say that $c_i$ is deleted by $c_j$. For each circle, find which circle deletes it.", "inputFormat": "The first line contains an integer $n$, indicating the number of circles on the plane initially.\n\nThe next $n$ lines each contain three integers $x_i, y_i, r_i$, describing the $x$ coordinate, the $y$ coordinate of the center of circle $c_i$, and its radius, respectively.", "outputFormat": "Output one line containing $n$ integers $a_1, a_2, ..., a_n$, where $a_i$ means that circle $c_i$ is deleted by circle $c_{a_i}$.", "hint": "**Hint**\n\nThe picture in the statement corresponds to the situation in Sample 1.\n\n**Subtasks**\n\n- Subtask 1(points: $7$): $n \\leq 5000$.\n- Subtask 2(points: $12$): $n \\leq 3 × 10^5$, and for all circles $y_i = 0$.\n- Subtask 3(points: $15$): $n \\leq 3 × 10^5$, and each circle intersects with at most one other circle.\n- Subtask 4(points: $23$): $n \\leq 3 × 10^5$, and all circles have the same radius.\n- Subtask 5(points: $30$): $n \\leq 10^5$.\n- Subtask 6(points: $13$): $n \\leq 3 × 10^5$.\n\nAll testdata satisfy: $-10^9 ≤ x_i, y_i ≤ 10^9, 1 ≤ r_i ≤ 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2018] 选圆圈", "background": "", "description": "在平面上，有 $n$ 个圆，记为 $c_1, c_2,...,c_n$ 。我们尝试对这些圆运行这个算法：\n\n1. 找到这些圆中半径最大的。如果有多个半径最大的圆，选择编号最小的。记为 $c_i$。\n2. 删除 $c_i$ 及与其有交集的所有圆。两个圆有交集当且仅当平面上存在一个点，这个点同时在这两个圆的圆周上或圆内。（原文直译：如果平面上存在一个点被这两个圆所包含，我们称这两个圆有交集。一个点被一个圆包含，当且仅当它位于圆内或圆周上。）\n3. 重复上面两个步骤直到所有的圆都被删除。\n\n![QQ20180525194902.png](https://cdn.luogu.com.cn/upload/pic/19974.png)\n\n当 $c_i$ 被删除时，若循环中第 $1$ 步选择的圆是 $c_j$，我们说 $c_i$ 被 $c_j$ 删除。对于每个圆，求出它是被哪一个圆删除的。", "inputFormat": "第一行包含一个整数 $n$，表示开始时平面上圆的数量。\n\n接下来 $n$ 行，每行包含三个整数 $x_i, y_i, r_i$ 依次描述圆 $c_i$ 圆心的 $x$ 坐标、$y$ 坐标和它的半径。", "outputFormat": "输出一行，包含 $n$ 个整数 $a_1, a_2, ..., a_n$，其中 $a_i$ 表示圆 $c_i$ 是被圆 $c_{a_i}$ 删除的。", "hint": "**提示**\n\n题目描述中的图片对应了样例一中的情形。\n\n**子任务**\n\n- Subtask 1(points: $7$): $n \\leq 5000$\n- Subtask 2(points: $12$): $n \\leq 3 × 10^5$，对于所有的圆 $y_i = 0$\n- Subtask 3(points: $15$): $n \\leq 3 × 10^5$，每个圆最多和一个其他圆有交集\n- Subtask 4(points: $23$): $n \\leq 3 × 10^5$，所有的圆半径相同\n- Subtask 5(points: $30$): $n \\leq 10^5$\n- Subtask 6(points: $13$): $n \\leq 3 × 10^5$\n\n所有数据均满足：$-10^9 ≤ x_i, y_i ≤ 10^9, 1 ≤ r_i ≤ 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4632", "type": "P", "difficulty": 7, "samples": [["4 2 4\n3 1 1 10\n9 2 2 4\n7 2 5 7\n4 1 8 10\n5 3\n5 6\n5 9\n1 10\n", "4\n2\n-1\n-1\n"], ["2 1 3\n1 1 1 4\n1 1 2 6\n1 3\n1 5\n1 7", "0\n0\n-1\n"], ["1 1 1\n100000000 1 1 1\n1 1\n", "99999999\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "线段树", "二分", "离散化", "APIO"], "title": "[APIO2018] 新家", "background": "**警告！滥用本题评测者封号！请勿多次重复提交！**", "description": "五福街是一条笔直的道路，这条道路可以看成一个数轴，街上每个建筑物的坐标都可以用一个整数来表示。小明是一位时光旅行者，他知道在这条街上，在过去现在和未来共有 $n$ 个商店出现。第 $i$ 个商店可以使用四个整数 $x_i, t_i, a_i, b_i$ 描述，它们分别表示：商店的坐标、商店的类型、商店开业的年份、商店关闭的年份。\n\n小明希望通过时光旅行，选择一个合适的时间，住在五福街上的某个地方。他给出了一份他可能选择的列表，上面包括了 $q$ 个询问，每个询问用二元组 （坐标，时间）表示。第 $i$ 对二元组用两个整数 $l_i, y_i$ 描述，分别表示选择的地点 $l_i$ 和年份 $y_i$。\n\n现在，他想计算出在这些时间和地点居住的生活质量。他定义居住的不方便指数为：在居住的年份，离居住点最远的商店类型到居住点的距离。类型 $t$ 的商店到居住点的距离定义为：在指定的年份，类型 $t$ 的所有营业的商店中，到居住点距离最近的一家到居住点的距离。我们说编号为 $i$ 的商店在第 $y$ 年在营业当且仅当 $a_i \\le y \\le b_i$。注意，在某些年份中，可能在五福街上并非所有 $k$ 种类型的商店都有至少一家在营业。在这种情况下，不方便指数定义为 $-1$。\n\n你的任务是帮助小明求出每对（坐标，时间）二元组居住的不方便指数。", "inputFormat": "第一行包含三个整数 $n, k$ 和 $q$ ，分别表示商店的数量、商店类型的数量和（坐标，时间）二元组的数量。$(1 \\leq n, q \\le 3×10^5, 1 \\le k \\le n)$。\n\n接下来 $n$ 行，每行包含四个整数 $x_i, t_i, a_i$ 和 $b_i$ 用于描述一家商店，意义如题面所述 $(1 \\le x_i, a_i, b_i \\le 10^8, 1 \\le t_i \\le k, a_i \\le b_i)$。\n\n接下来 $q$ 行，每行包含两个整数 $l_i$ 和 $y_i$ ，表示一组（坐标，时间）查询$(1 \\le l_i, y_i \\le 10^8)$。", "outputFormat": "输出一行，包含 $q$ 个整数，依次表示对于 $q$ 组（坐标，时间）询问求出的结果。", "hint": "**提示**\n\n在第一个样例中，有 4 家商店，共 2 种类型，还有 4 个询问。\n\n- 对于第一个询问：小明在第 3 年住在坐标为 5 的地方。这一年中，编号为 1 和 2 的商店在营业，到编号为 1 的商店的距离为 2 ，到编号为 2 的商店距离为 4 ，所以最大距离为 $4$。\n- 对于第二个询问：小明在第 6 年住在坐标为 5 的地方。这一年中，编号为 1 和 3 的商店在营业，到编号为 1 的商店的距离为 2 ，到编号为 3 的商店距离为 2 ，所以最大距离为 $2$。\n- 对于第三个询问：小明在第 9 年住在坐标为 5 的地方。这一年中，编号为 1 和 4 的商店在营业，它们的类型都为 1，没有类型为 2 的商店在营业，所以答案为  $-1$。\n- 同样的情况出现在第四个询问中。\n\n在第二个样例中，有 2 家商店，共 1 种类型，还有三个询问。 两家商店的类型都是 1 。在所有的询问中，小明均住在坐标为 1 的地方。 在前两个询问中，至少有一个商店在营业，所以答案为 $0$，在第三个询问中，两个商店都不在营业，所以答案为 $-1$。\n\n在第三个样例中，有 1 家商店和 1 个询问，两者之间的距离是 $99999999$。\n\n\n**子任务**\n\n- Subtask 1 (points: $5$): $n, q \\leq 400$\n- Subtask 2 (points: $7$): $n, q \\leq 6 \\times 10^4, k \\leq 400$\n- Subtask 3 (points: $10$): $n, q \\leq 3 \\times 10^5$，对于所有的商店 $a_i = 1, b_i = 10^8$\n- Subtask 4 (points: $23$): $n, q \\leq 3 \\times 10^5$，对于所有的商店 $a_i = 1$\n- Subtask 5 (points: $35$): $n, q \\leq 6 \\times 10^4$\n- Subtask 6 (points: $20$): $n, q \\leq 3 \\times 10^5$", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2018] New Home", "background": "**Warning! Abusing the judge for this problem will result in your account being banned! Do not submit repeatedly many times!**", "description": "Wufu Street is a straight road. It can be seen as a number line, and the coordinate of each building on the street can be represented by an integer. Xiaoming is a time traveler. He knows that on this street, there are $n$ shops that appear in the past, present, and future. The $i$-th shop can be described by four integers $x_i, t_i, a_i, b_i$, which represent: the shop’s coordinate, the shop’s type, the year it opens, and the year it closes.\n\nXiaoming wants to time travel to choose a suitable time and live somewhere on Wufu Street. He provides a list of possible choices containing $q$ queries, and each query is represented by a pair (coordinate, time). The $i$-th pair is described by two integers $l_i, y_i$, representing the chosen location $l_i$ and the year $y_i$.\n\nNow, he wants to compute the quality of life for living at these times and locations. He defines the inconvenience index of living as: in the year of living, the distance from the living point to the shop type that is farthest away. The distance from shops of type $t$ to the living point is defined as: in the specified year, among all open shops of type $t$, the distance from the living point to the nearest one. We say shop $i$ is open in year $y$ if and only if $a_i \\le y \\le b_i$. Note that in some years, not all of the $k$ types of shops may have at least one shop open on Wufu Street. In this case, the inconvenience index is defined as $-1$.\n\nYour task is to help Xiaoming compute the inconvenience index for each (coordinate, time) pair.", "inputFormat": "The first line contains three integers $n, k, q$, representing the number of shops, the number of shop types, and the number of (coordinate, time) pairs. $(1 \\leq n, q \\le 3\\times 10^5, 1 \\le k \\le n)$.\n\nThe next $n$ lines each contain four integers $x_i, t_i, a_i, b_i$ describing a shop, with meanings as stated above. $(1 \\le x_i, a_i, b_i \\le 10^8, 1 \\le t_i \\le k, a_i \\le b_i)$.\n\nThe next $q$ lines each contain two integers $l_i, y_i$, representing a (coordinate, time) query. $(1 \\le l_i, y_i \\le 10^8)$.", "outputFormat": "Output one line containing $q$ integers, in order, representing the answers for the $q$ (coordinate, time) queries.", "hint": "**Hint**\n\nIn the first sample, there are 4 shops, 2 types, and 4 queries.\n\n- For the first query: Xiaoming lives at coordinate 5 in year 3. In this year, shops 1 and 2 are open. The distance to shop 1 is 2, and the distance to shop 2 is 4, so the maximum distance is $4$.\n- For the second query: Xiaoming lives at coordinate 5 in year 6. In this year, shops 1 and 3 are open. The distance to shop 1 is 2, and the distance to shop 3 is 2, so the maximum distance is $2$.\n- For the third query: Xiaoming lives at coordinate 5 in year 9. In this year, shops 1 and 4 are open. Both are type 1, and there is no open shop of type 2, so the answer is $-1$.\n- The same situation occurs in the fourth query.\n\nIn the second sample, there are 2 shops, 1 type, and 3 queries. Both shops are type 1. In all queries, Xiaoming lives at coordinate 1. In the first two queries, at least one shop is open, so the answer is $0$. In the third query, neither shop is open, so the answer is $-1$.\n\nIn the third sample, there is 1 shop and 1 query, and the distance between them is $99999999$.\n\n**Subtasks**\n\n- Subtask 1 (points: $5$): $n, q \\leq 400$.\n- Subtask 2 (points: $7$): $n, q \\leq 6 \\times 10^4, k \\leq 400$.\n- Subtask 3 (points: $10$): $n, q \\leq 3 \\times 10^5$, and for all shops $a_i = 1, b_i = 10^8$.\n- Subtask 4 (points: $23$): $n, q \\leq 3 \\times 10^5$, and for all shops $a_i = 1$.\n- Subtask 5 (points: $35$): $n, q \\leq 6 \\times 10^4$.\n- Subtask 6 (points: $20$): $n, q \\leq 3 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2018] 新家", "background": "**警告！滥用本题评测者封号！请勿多次重复提交！**", "description": "五福街是一条笔直的道路，这条道路可以看成一个数轴，街上每个建筑物的坐标都可以用一个整数来表示。小明是一位时光旅行者，他知道在这条街上，在过去现在和未来共有 $n$ 个商店出现。第 $i$ 个商店可以使用四个整数 $x_i, t_i, a_i, b_i$ 描述，它们分别表示：商店的坐标、商店的类型、商店开业的年份、商店关闭的年份。\n\n小明希望通过时光旅行，选择一个合适的时间，住在五福街上的某个地方。他给出了一份他可能选择的列表，上面包括了 $q$ 个询问，每个询问用二元组 （坐标，时间）表示。第 $i$ 对二元组用两个整数 $l_i, y_i$ 描述，分别表示选择的地点 $l_i$ 和年份 $y_i$。\n\n现在，他想计算出在这些时间和地点居住的生活质量。他定义居住的不方便指数为：在居住的年份，离居住点最远的商店类型到居住点的距离。类型 $t$ 的商店到居住点的距离定义为：在指定的年份，类型 $t$ 的所有营业的商店中，到居住点距离最近的一家到居住点的距离。我们说编号为 $i$ 的商店在第 $y$ 年在营业当且仅当 $a_i \\le y \\le b_i$。注意，在某些年份中，可能在五福街上并非所有 $k$ 种类型的商店都有至少一家在营业。在这种情况下，不方便指数定义为 $-1$。\n\n你的任务是帮助小明求出每对（坐标，时间）二元组居住的不方便指数。", "inputFormat": "第一行包含三个整数 $n, k$ 和 $q$ ，分别表示商店的数量、商店类型的数量和（坐标，时间）二元组的数量。$(1 \\leq n, q \\le 3×10^5, 1 \\le k \\le n)$。\n\n接下来 $n$ 行，每行包含四个整数 $x_i, t_i, a_i$ 和 $b_i$ 用于描述一家商店，意义如题面所述 $(1 \\le x_i, a_i, b_i \\le 10^8, 1 \\le t_i \\le k, a_i \\le b_i)$。\n\n接下来 $q$ 行，每行包含两个整数 $l_i$ 和 $y_i$ ，表示一组（坐标，时间）查询$(1 \\le l_i, y_i \\le 10^8)$。", "outputFormat": "输出一行，包含 $q$ 个整数，依次表示对于 $q$ 组（坐标，时间）询问求出的结果。", "hint": "**提示**\n\n在第一个样例中，有 4 家商店，共 2 种类型，还有 4 个询问。\n\n- 对于第一个询问：小明在第 3 年住在坐标为 5 的地方。这一年中，编号为 1 和 2 的商店在营业，到编号为 1 的商店的距离为 2 ，到编号为 2 的商店距离为 4 ，所以最大距离为 $4$。\n- 对于第二个询问：小明在第 6 年住在坐标为 5 的地方。这一年中，编号为 1 和 3 的商店在营业，到编号为 1 的商店的距离为 2 ，到编号为 3 的商店距离为 2 ，所以最大距离为 $2$。\n- 对于第三个询问：小明在第 9 年住在坐标为 5 的地方。这一年中，编号为 1 和 4 的商店在营业，它们的类型都为 1，没有类型为 2 的商店在营业，所以答案为  $-1$。\n- 同样的情况出现在第四个询问中。\n\n在第二个样例中，有 2 家商店，共 1 种类型，还有三个询问。 两家商店的类型都是 1 。在所有的询问中，小明均住在坐标为 1 的地方。 在前两个询问中，至少有一个商店在营业，所以答案为 $0$，在第三个询问中，两个商店都不在营业，所以答案为 $-1$。\n\n在第三个样例中，有 1 家商店和 1 个询问，两者之间的距离是 $99999999$。\n\n\n**子任务**\n\n- Subtask 1 (points: $5$): $n, q \\leq 400$\n- Subtask 2 (points: $7$): $n, q \\leq 6 \\times 10^4, k \\leq 400$\n- Subtask 3 (points: $10$): $n, q \\leq 3 \\times 10^5$，对于所有的商店 $a_i = 1, b_i = 10^8$\n- Subtask 4 (points: $23$): $n, q \\leq 3 \\times 10^5$，对于所有的商店 $a_i = 1$\n- Subtask 5 (points: $35$): $n, q \\leq 6 \\times 10^4$\n- Subtask 6 (points: $20$): $n, q \\leq 3 \\times 10^5$", "locale": "zh-CN"}}}
{"pid": "P4633", "type": "P", "difficulty": 6, "samples": [["3\n4 0 0 10 10\n4 3 4 6 8\n4 1 1 2 2", "2"], ["6\n4 1 0 17 12\n16 10 4 16 11 2 4 8 2 3 3 2 1 16 3 15 2\n8 8 10 3 5 12 8 11 6\n6 10 9 15 10 9 7\n4 4 6 7 9\n4 6 8 5 7", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2004", "POI（波兰）", "扫描线"], "title": "[POI 2004] WYS", "background": "虽然题目名比较毒瘤，但这确实是一个简单题。", "description": "给 $n$ 个互不相交的多边形，这些多边形的边均平行或垂直于坐标轴。定义多边形 $i$ 的深度 $d_i$ 为 $\\max\\{d_j\\}+1$，其中多边形 $j$ 包含多边形 $i$。特别的，若一个多边形不被任何多边形包含，则其深度为 $1$。求深度最大的多边形的深度。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来每行描述一个多边形。首先给出一个偶数 $k$ $(4 \\leqslant k \\leqslant 10000)$，接下来包含 $k$ 个整数: $x_1,x_2,\\cdots,x_k$ $(0 \\leqslant x_i \\leqslant 10^8)$。这些点的坐标分别为 $(x_1, x_2), (x_3, x2), (x_3, x4), (x_5, x_4),\\cdots,(x_{k-1}, x_k), (x_1, x_k)$。他们按照逆时针顺序构成多边形。", "outputFormat": "输出一个整数表示最大深度。", "hint": "对于 $100\\%$ 的数据，$n \\leqslant 40000, \\sum k \\leqslant 200000$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2004] WYS", "background": "Although the title is a bit nasty, this is indeed a simple problem.", "description": "You are given $n$ pairwise disjoint polygons. All edges of these polygons are parallel or perpendicular to the coordinate axes. Define the depth $d_i$ of polygon $i$ as $\\max\\{d_j\\}+1$, where polygon $j$ contains polygon $i$. In particular, if a polygon is not contained in any other polygon, then its depth is $1$. Find the depth of the polygon with the maximum depth.", "inputFormat": "The first line contains a positive integer $n$.\n\nEach of the following lines describes one polygon. First, an even integer $k$ $(4 \\leqslant k \\leqslant 10000)$ is given, followed by $k$ integers: $x_1,x_2,\\cdots,x_k$ $(0 \\leqslant x_i \\leqslant 10^8)$. The coordinates of the points are $(x_1, x_2), (x_3, x_2), (x_3, x_4), (x_5, x_4),\\cdots,(x_{k-1}, x_k), (x_1, x_k)$. They form the polygon in counterclockwise order.", "outputFormat": "Output one integer, the maximum depth.", "hint": "For $100\\%$ of the testdata, $n \\leqslant 40000, \\sum k \\leqslant 200000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2004] WYS", "background": "虽然题目名比较毒瘤，但这确实是一个简单题。", "description": "给 $n$ 个互不相交的多边形，这些多边形的边均平行或垂直于坐标轴。定义多边形 $i$ 的深度 $d_i$ 为 $\\max\\{d_j\\}+1$，其中多边形 $j$ 包含多边形 $i$。特别的，若一个多边形不被任何多边形包含，则其深度为 $1$。求深度最大的多边形的深度。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来每行描述一个多边形。首先给出一个偶数 $k$ $(4 \\leqslant k \\leqslant 10000)$，接下来包含 $k$ 个整数: $x_1,x_2,\\cdots,x_k$ $(0 \\leqslant x_i \\leqslant 10^8)$。这些点的坐标分别为 $(x_1, x_2), (x_3, x2), (x_3, x4), (x_5, x_4),\\cdots,(x_{k-1}, x_k), (x_1, x_k)$。他们按照逆时针顺序构成多边形。", "outputFormat": "输出一个整数表示最大深度。", "hint": "对于 $100\\%$ 的数据，$n \\leqslant 40000, \\sum k \\leqslant 200000$。", "locale": "zh-CN"}}}
{"pid": "P4634", "type": "P", "difficulty": 5, "samples": [["2 1\n2000\n4\n1/1 TO 1/2 1\n2/1 TO 2/2 1\n3/1 TO 3/2 1\n3/1 TO 3/3 1\n1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2000", "CTSC/CTS"], "title": "[CTSC2000] 快乐的蜜月", "background": "位于某个旅游胜地的一家宾馆里，有一个房间是总统套房。由于总统套房价格昂贵，因此常常无人光临。宾馆的经理为了创收，决定将总统套房改建为专门为新婚夫妇服务的蜜月房。宾馆经理不仅大幅度降低了蜜月房的价位，而且还对不同身份的顾客制定了不同的价位，以吸引不同身份、不同消费水平的游客。比如对于来订蜜月房的国内来宾、海外旅客、港澳台同胞等，区别收取费用。宾馆经理的举措获得了不同凡响的效果。由于蜜月房环境幽雅，服务周到，因此生意红火。", "description": "宾馆经理在每年年底都会收到第二年的所有蜜月房预订单。每张预订单包括以下几个必要的信息：**到达日期、离去日期和顾客身份**。\n\n由于宾馆**只有一间蜜月房，只能同时接待一对新婚夫妇**。因此并不是所有的预订要求都能得到满足。\n\n当一些预订要求**在时间上发生了重叠**的时候，我们就称这些预订要求发生了冲突。\n\n对于那些不与任何其他预订要求发生冲突的预订单，它们**必然会被接受**。因为这对宾馆和顾客双方面来说都是件好事。\n\n而对于发生冲突的预订要求，宾馆经理则**必须拒绝其中的一部分**，以保证宾馆有秩序地运转。\n\n显然，对于同一时间内发生冲突的预定要求，宾馆经理**最多只能接受其中的一个**。经理也有可能**拒绝同一时间段内的所有预定要求**，因为这样可以避免顾客间发生争执。\n\n经理在做出决策后，需要将整个计划公布于众，以示公平。这是一个必须慎重的决定，因为它牵涉到诸多方面的因素。经理首先考虑的当然是利润问题。他必然希望获得尽可能多的收入。可是宾馆在获得经济效益的同时，同时也应该兼顾到社会效益，不能太惟利是图，还必须照顾到顾客们的感情。如果宾馆经理单从最大获利角度出发来决定接受或拒绝顾客的预订要求的话，就会引起人们的不满。\n\n经理有一个学过市场营销学的顾问。顾问告诉经理，可以采取一种折中的做法，放弃牟利最大的方案，而采纳获利第 $k$ 大的方案。他还通过精确的市场分析，找到了 $k$ 的最佳取值点，告诉了宾馆经理。\n\n\n现在请你帮助宾馆经理，从一大堆预订要求中，在上述原则下寻找到获利第 $k$ 大的方案。宾馆经理将根据此方案来决定接受和拒绝哪些预订要求。\n\n\n当然，可能有若干种方案的获利是一样大的。这时候，它们同属于获利第 $i$ 大的方案而不区分看待。例如，假如有 $3$ 种方案的收入同时为 $3$ ，有 $2$ 种方案的收入为 $2$ ，则收入为 $3$ 的方案都属于获利最大，收入为 $2$ 的方案都属于获利第二大。依次类推。\n\n假设所有的住、离店登记都在中午 $12$ 点进行。", "inputFormat": "输入文件的第一行是两个数，$k$ 和 $t$ 。其中 $k$ 表示需要选择获利第 $k$ 大的方案； $t$ 表示顾客的身份共划分为 $t$ 类。\n\n第二行是一个数 $y$ ，表示下一年的年份。\n\n第三行是一个数 $r$ ，表示共有 $r$ 个预订要求。\n\n以下 $r$ 行每行是一个预订要求，格式为：`m1/d1 TO m2/d2 id`；\n\n其中 $m_1,d_1$ 和 $m_2,d_2$ 分别表示到达和离去日期。 $id$ 是一个整数 （$1 \\leq id \\leq t$） ，用来标识预订顾客的身份。\n\n最后 $t$ 行每行为一个整数 $P_{i}$ ($1 \\leq i \\leq t$）表示蜜月房对于身份代号为 $i$ 的顾客的日收费标准。\n\n例：某对顾客于 $6$ 月 $1$ 日到达， $6$ 月 $3$ 日离去，对他们的日收费标准为 $m$ 元/天，则他们共住店两天，需付钱 $2m$ 元。", "outputFormat": "输出文件仅包含一个整数 $p$ ，表示在获利第 $k$ 大的方案下，宾馆的年度总收入额。如果获利第 $k$ 大的方案不存在，则输出 $-1$ 。", "hint": "数据范围：\n\n$1 \\leq k \\leq 100$ ，$1 \\leq t \\leq 100$，$0 \\leq r \\leq 20000$，$1 \\leq P_{i} \\leq 32767$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CTSC2000] 快乐的蜜月", "background": "位于某个旅游胜地的一家宾馆里，有一个房间是总统套房。由于总统套房价格昂贵，因此常常无人光临。宾馆的经理为了创收，决定将总统套房改建为专门为新婚夫妇服务的蜜月房。宾馆经理不仅大幅度降低了蜜月房的价位，而且还对不同身份的顾客制定了不同的价位，以吸引不同身份、不同消费水平的游客。比如对于来订蜜月房的国内来宾、海外旅客、港澳台同胞等，区别收取费用。宾馆经理的举措获得了不同凡响的效果。由于蜜月房环境幽雅，服务周到，因此生意红火。", "description": "宾馆经理在每年年底都会收到第二年的所有蜜月房预订单。每张预订单包括以下几个必要的信息：**到达日期、离去日期和顾客身份**。\n\n由于宾馆**只有一间蜜月房，只能同时接待一对新婚夫妇**。因此并不是所有的预订要求都能得到满足。\n\n当一些预订要求**在时间上发生了重叠**的时候，我们就称这些预订要求发生了冲突。\n\n对于那些不与任何其他预订要求发生冲突的预订单，它们**必然会被接受**。因为这对宾馆和顾客双方面来说都是件好事。\n\n而对于发生冲突的预订要求，宾馆经理则**必须拒绝其中的一部分**，以保证宾馆有秩序地运转。\n\n显然，对于同一时间内发生冲突的预定要求，宾馆经理**最多只能接受其中的一个**。经理也有可能**拒绝同一时间段内的所有预定要求**，因为这样可以避免顾客间发生争执。\n\n经理在做出决策后，需要将整个计划公布于众，以示公平。这是一个必须慎重的决定，因为它牵涉到诸多方面的因素。经理首先考虑的当然是利润问题。他必然希望获得尽可能多的收入。可是宾馆在获得经济效益的同时，同时也应该兼顾到社会效益，不能太惟利是图，还必须照顾到顾客们的感情。如果宾馆经理单从最大获利角度出发来决定接受或拒绝顾客的预订要求的话，就会引起人们的不满。\n\n经理有一个学过市场营销学的顾问。顾问告诉经理，可以采取一种折中的做法，放弃牟利最大的方案，而采纳获利第 $k$ 大的方案。他还通过精确的市场分析，找到了 $k$ 的最佳取值点，告诉了宾馆经理。\n\n\n现在请你帮助宾馆经理，从一大堆预订要求中，在上述原则下寻找到获利第 $k$ 大的方案。宾馆经理将根据此方案来决定接受和拒绝哪些预订要求。\n\n\n当然，可能有若干种方案的获利是一样大的。这时候，它们同属于获利第 $i$ 大的方案而不区分看待。例如，假如有 $3$ 种方案的收入同时为 $3$ ，有 $2$ 种方案的收入为 $2$ ，则收入为 $3$ 的方案都属于获利最大，收入为 $2$ 的方案都属于获利第二大。依次类推。\n\n假设所有的住、离店登记都在中午 $12$ 点进行。", "inputFormat": "输入文件的第一行是两个数，$k$ 和 $t$ 。其中 $k$ 表示需要选择获利第 $k$ 大的方案； $t$ 表示顾客的身份共划分为 $t$ 类。\n\n第二行是一个数 $y$ ，表示下一年的年份。\n\n第三行是一个数 $r$ ，表示共有 $r$ 个预订要求。\n\n以下 $r$ 行每行是一个预订要求，格式为：`m1/d1 TO m2/d2 id`；\n\n其中 $m_1,d_1$ 和 $m_2,d_2$ 分别表示到达和离去日期。 $id$ 是一个整数 （$1 \\leq id \\leq t$） ，用来标识预订顾客的身份。\n\n最后 $t$ 行每行为一个整数 $P_{i}$ ($1 \\leq i \\leq t$）表示蜜月房对于身份代号为 $i$ 的顾客的日收费标准。\n\n例：某对顾客于 $6$ 月 $1$ 日到达， $6$ 月 $3$ 日离去，对他们的日收费标准为 $m$ 元/天，则他们共住店两天，需付钱 $2m$ 元。", "outputFormat": "输出文件仅包含一个整数 $p$ ，表示在获利第 $k$ 大的方案下，宾馆的年度总收入额。如果获利第 $k$ 大的方案不存在，则输出 $-1$ 。", "hint": "数据范围：\n\n$1 \\leq k \\leq 100$ ，$1 \\leq t \\leq 100$，$0 \\leq r \\leq 20000$，$1 \\leq P_{i} \\leq 32767$", "locale": "zh-CN"}}}
{"pid": "P4635", "type": "P", "difficulty": 6, "samples": [["7 3 7\n2\n5\n3\n0\n3\n1\n2\n1 1 4 3\n1 4 7 4\n2 1 7", "2"], ["5 5 2\n1\n0\n0\n1\n0\n2 1 4\n2 1 5\n1 3 5 1\n2 1 4\n2 1 3", "1\n2\n2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "树状数组", "上海", "差分"], "title": "[SHOI2011] 改进代码", "background": "", "description": " PP 写了两段对数组进行操作的代码。\n\n对于 Pascal 选手，两段代码分别如下： \n\n```\nprocedure operate1(l, r, c : longint);\nvar\n    i : longint;\nbegin\n    for i := l to r do\n        a[i] := (a[i] + c) mod p;\nend;\n\nprocedure operate2(l, r : longint);\nvar\n    i, cnt : longint;\nbegin\n    cnt := 0;\n    for i := l to r - 1 do\n        if a[i] > a[i + 1]\n            then cnt := cnt + 1;\n    writeln(cnt);\nend;\n```\n\n对于 C / C++ 选手，两段代码分别如下：\n\n```cpp\nvoid operate1(int l, int r, int c)\n{\n    int i;\n    for (i = l; i <= r; ++i)\n        a[i] = (a[i] + c) % p;\n}\n\nvoid operate2(int l, int r)\n{\n    int i, cnt = 0;\n    for (i = l; i < r; ++i)\n        if (a[i] > a[i + 1])\n            ++ cnt;\n    printf(\"%d\\n\", cnt);\n}\n```\n\n于是，主程序就可以通过调用这两个子程序对数组 $a_i$​​ 进行操作，下面是示例代码。\n\n对于 Pascal 选手，代码如下：\n\n```\nbegin\n    operate1(1, 4, 3);\n    operate1(4, 7, 4);\n    operate2(1, 7);\nend.\n```\n\n对于 C / C++ 选手，代码如下：\n\n```\nint main()\n{\n    operate1(1, 4, 3);\n    operate1(4, 7, 4);\n    operate2(1, 7);\n}\n```\n\n但是 QQ 觉得 PP 的程序效率太低了，他想请你优化 PP 的代码。即，对于一段只包含 ``operate1`` 、 ``operate2`` 两种语句的主程序以及运行之前数组 $a_i$​​ 的初始值，请你计算出他的输出。", "inputFormat": "输入的第一行包含 $3$ 个整数 $n,m,p$ 。其中 $n$ 是操作中 $l,r$ 的上界， $m$ 是主程序中的语句数， $p$ 是程序中的常数 $p$ 的值。\n\n接下去 $n$ 行每行一个整数，依次是 $a_1,a_2,…,a_n$ 的初始化的值。输入保证这些值都在 $0,1,…,p-1$ 之中。\n\n接下去 $m$ 行每行依次描述主程序的一行代码。每一行的格式为下面两者之一：\n\n-    ``1 l r c`` : 表示代码 ``operate1(l, r, c);`` 。\n\n-    ``2 l r`` : 表示代码 ``operate2(l, r);`` 。\n\n", "outputFormat": "输出即为输入对应的程序的输出。", "hint": "**数据范围与提示**\n\n测试点 $1$：$n \\le 1000,m \\le 2000$。\n\n测试点 $2 \\sim 3$：$n \\le 100000$,$m \\le 200000$,$c \\le 1$,$a_i \\le 100000$,$p>500000$。\n\n测试点 $4$：$n \\le 100000,m \\le 200000,l=1,r=n$。\n\n测试点 $5 \\sim 6$：$n \\le 100000,m \\le 200000$ 且对于所有 ``operate1`` 的参数都有 $l=1,r=n$。\n\n测试点 $7 \\sim 10$：$n \\le 100000,m \\le 200000$。\n\n保证 $1 \\le l \\le r \\le n,0 \\le c \\le 10^8,p \\le 10^6$​​.", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2011] Improved Code", "background": "", "description": "PP wrote two pieces of code to operate on an array.\n\nFor Pascal users, the two procedures are as follows:\n\n```\nprocedure operate1(l, r, c : longint);\nvar\n    i : longint;\nbegin\n    for i := l to r do\n        a[i] := (a[i] + c) mod p;\nend;\n\nprocedure operate2(l, r : longint);\nvar\n    i, cnt : longint;\nbegin\n    cnt := 0;\n    for i := l to r - 1 do\n        if a[i] > a[i + 1]\n            then cnt := cnt + 1;\n    writeln(cnt);\nend;\n```\n\nFor C / C++ users, the two functions are as follows:\n\n```cpp\nvoid operate1(int l, int r, int c)\n{\n    int i;\n    for (i = l; i <= r; ++i)\n        a[i] = (a[i] + c) % p;\n}\n\nvoid operate2(int l, int r)\n{\n    int i, cnt = 0;\n    for (i = l; i < r; ++i)\n        if (a[i] > a[i + 1])\n            ++ cnt;\n    printf(\"%d\\n\", cnt);\n}\n```\n\nThen, the main program can operate on the array $a_i$ by calling these two subroutines. The following is sample code.\n\nFor Pascal users, the code is:\n\n```\nbegin\n    operate1(1, 4, 3);\n    operate1(4, 7, 4);\n    operate2(1, 7);\nend.\n```\n\nFor C / C++ users, the code is:\n\n```\nint main()\n{\n    operate1(1, 4, 3);\n    operate1(4, 7, 4);\n    operate2(1, 7);\n}\n```\n\nHowever, QQ thinks PP’s program is too slow, and he wants you to optimize PP’s code. That is, given a main program that contains only two kinds of statements, `operate1` and `operate2`, and the initial values of the array $a_i$ before running, please compute the output of the program.", "inputFormat": "The first line contains $3$ integers $n, m, p$. Here, $n$ is the upper bound of $l, r$ in the operations, $m$ is the number of statements in the main program, and $p$ is the value of the constant $p$ in the program.\n\nIn the next $n$ lines, each line contains one integer, which are the initial values of $a_1, a_2, \\ldots, a_n$ in order. The input guarantees that these values are all within $0, 1, \\ldots, p - 1$.\n\nIn the next $m$ lines, each line describes one line of code in the main program. Each line has one of the following two formats:\n\n- `1 l r c`: represents the statement `operate1(l, r, c);`.\n- `2 l r`: represents the statement `operate2(l, r);`.", "outputFormat": "Output the output produced by the program corresponding to the given input.", "hint": "**Constraints and notes**\n\nTest point $1$: $n \\le 1000, m \\le 2000$.\n\nTest points $2 \\sim 3$: $n \\le 100000$, $m \\le 200000$, $c \\le 1$, $a_i \\le 100000$, $p > 500000$.\n\nTest point $4$: $n \\le 100000, m \\le 200000, l = 1, r = n$.\n\nTest points $5 \\sim 6$: $n \\le 100000, m \\le 200000$, and for all `operate1` parameters, $l = 1, r = n$.\n\nTest points $7 \\sim 10$: $n \\le 100000, m \\le 200000$.\n\nIt is guaranteed that $1 \\le l \\le r \\le n$, $0 \\le c \\le 10^8$, $p \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2011] 改进代码", "background": "", "description": " PP 写了两段对数组进行操作的代码。\n\n对于 Pascal 选手，两段代码分别如下： \n\n```\nprocedure operate1(l, r, c : longint);\nvar\n    i : longint;\nbegin\n    for i := l to r do\n        a[i] := (a[i] + c) mod p;\nend;\n\nprocedure operate2(l, r : longint);\nvar\n    i, cnt : longint;\nbegin\n    cnt := 0;\n    for i := l to r - 1 do\n        if a[i] > a[i + 1]\n            then cnt := cnt + 1;\n    writeln(cnt);\nend;\n```\n\n对于 C / C++ 选手，两段代码分别如下：\n\n```cpp\nvoid operate1(int l, int r, int c)\n{\n    int i;\n    for (i = l; i <= r; ++i)\n        a[i] = (a[i] + c) % p;\n}\n\nvoid operate2(int l, int r)\n{\n    int i, cnt = 0;\n    for (i = l; i < r; ++i)\n        if (a[i] > a[i + 1])\n            ++ cnt;\n    printf(\"%d\\n\", cnt);\n}\n```\n\n于是，主程序就可以通过调用这两个子程序对数组 $a_i$​​ 进行操作，下面是示例代码。\n\n对于 Pascal 选手，代码如下：\n\n```\nbegin\n    operate1(1, 4, 3);\n    operate1(4, 7, 4);\n    operate2(1, 7);\nend.\n```\n\n对于 C / C++ 选手，代码如下：\n\n```\nint main()\n{\n    operate1(1, 4, 3);\n    operate1(4, 7, 4);\n    operate2(1, 7);\n}\n```\n\n但是 QQ 觉得 PP 的程序效率太低了，他想请你优化 PP 的代码。即，对于一段只包含 ``operate1`` 、 ``operate2`` 两种语句的主程序以及运行之前数组 $a_i$​​ 的初始值，请你计算出他的输出。", "inputFormat": "输入的第一行包含 $3$ 个整数 $n,m,p$ 。其中 $n$ 是操作中 $l,r$ 的上界， $m$ 是主程序中的语句数， $p$ 是程序中的常数 $p$ 的值。\n\n接下去 $n$ 行每行一个整数，依次是 $a_1,a_2,…,a_n$ 的初始化的值。输入保证这些值都在 $0,1,…,p-1$ 之中。\n\n接下去 $m$ 行每行依次描述主程序的一行代码。每一行的格式为下面两者之一：\n\n-    ``1 l r c`` : 表示代码 ``operate1(l, r, c);`` 。\n\n-    ``2 l r`` : 表示代码 ``operate2(l, r);`` 。\n\n", "outputFormat": "输出即为输入对应的程序的输出。", "hint": "**数据范围与提示**\n\n测试点 $1$：$n \\le 1000,m \\le 2000$。\n\n测试点 $2 \\sim 3$：$n \\le 100000$,$m \\le 200000$,$c \\le 1$,$a_i \\le 100000$,$p>500000$。\n\n测试点 $4$：$n \\le 100000,m \\le 200000,l=1,r=n$。\n\n测试点 $5 \\sim 6$：$n \\le 100000,m \\le 200000$ 且对于所有 ``operate1`` 的参数都有 $l=1,r=n$。\n\n测试点 $7 \\sim 10$：$n \\le 100000,m \\le 200000$。\n\n保证 $1 \\le l \\le r \\le n,0 \\le c \\le 10^8,p \\le 10^6$​​.", "locale": "zh-CN"}}}
{"pid": "P4636", "type": "P", "difficulty": 6, "samples": [["6\n1 0\n2 0\n3 0\n3 2\n4 0\n5 0", "1.00"], ["6\n-2 -1\n-1 2\n1 2\n2 3\n3 3\n4 4", "0.86"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "上海"], "title": "[SHOI2011] 直线拟合", "background": "", "description": "平面上有 $n$ 个点 $v_i(x_i,y_i)$ 。求 $D(l)=\\max_{1\\le i\\le n} dis(v_i,l)$ 的最小可能值，其中变量 $l$ 是平面上的一条直线，函数 $dis(v_i,l)$ 表示直线 $l$ 与点 $v_i$ 之间的距离。", "inputFormat": "输入的第一行为一个正整数 $n$ 。接下来 $n$ 行，每行一对整数 $x_i , y_i$​​ ，用一个空格分隔，依次表示这 $n$ 个点的坐标，其中 $|x_i|,|y_i| \\le 10^8$ ，且不同的点不会重合。", "outputFormat": "输出只有一行，包含一个实数，即 $D(l)$ 的最小值，四舍五入到小数点后两位。", "hint": "**样例解释 1**\n\n样例 $1$ 中， 取到最小值时的直线 $l$ 为 $y=1$ 。\n\n**样例解释 2**\n\n样例 $2$ 中的 $6$ 个点，以及 $D(l)$ 取到最小值时的直线 $l$ 如图所示。\n\n![1](https://cdn.luogu.com.cn/upload/pic/20067.png)\n\n**数据范围与提示**\n\n测试点 $1$：$n=3$。\n\n测试点 $2 \\sim 4$：$3 \\le n \\le 100$。\n\n测试点 $5 \\sim 7$：$100 < n \\le 100000$ ，且输入文件如下生成：选定一条线段，每次先在该线段上等概率随机选择一个点，再取离该点最近的整点。\n\n测试点 $8 \\sim 10$：$3 < n \\le 100000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2011] Line Fitting", "background": "", "description": "There are $n$ points $v_i(x_i, y_i)$ on the plane. Find the minimum possible value of $D(l)=\\max_{1\\le i\\le n} dis(v_i, l)$, where the variable $l$ is a line on the plane, and $dis(v_i, l)$ denotes the distance between the line $l$ and the point $v_i$.", "inputFormat": "The first line contains a positive integer $n$. The next $n$ lines each contain a pair of integers $x_i, y_i$, separated by a space, representing the coordinates of the $n$ points in order. Here $|x_i|, |y_i| \\le 10^8$, and no two points coincide.", "outputFormat": "Output a single line containing a real number, the minimum value of $D(l)$, rounded to two decimal places.", "hint": "**Sample Explanation 1**\n\nIn sample $1$, when the minimum is achieved, the line $l$ is $y=1$.\n\n**Sample Explanation 2**\n\nIn sample $2$, the $6$ points and the line $l$ when $D(l)$ reaches its minimum are shown in the figure.\n\n![1](https://cdn.luogu.com.cn/upload/pic/20067.png)\n\n**Constraints and Notes**\n\nTest case $1$: $n=3$.\n\nTest cases $2 \\sim 4$: $3 \\le n \\le 100$.\n\nTest cases $5 \\sim 7$: $100 < n \\le 100000$, and the input file is generated as follows: choose a line segment; each time, first pick a point uniformly at random on the segment, then take the lattice point closest to that point.\n\nTest cases $8 \\sim 10$: $3 < n \\le 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2011] 直线拟合", "background": "", "description": "平面上有 $n$ 个点 $v_i(x_i,y_i)$ 。求 $D(l)=\\max_{1\\le i\\le n} dis(v_i,l)$ 的最小可能值，其中变量 $l$ 是平面上的一条直线，函数 $dis(v_i,l)$ 表示直线 $l$ 与点 $v_i$ 之间的距离。", "inputFormat": "输入的第一行为一个正整数 $n$ 。接下来 $n$ 行，每行一对整数 $x_i , y_i$​​ ，用一个空格分隔，依次表示这 $n$ 个点的坐标，其中 $|x_i|,|y_i| \\le 10^8$ ，且不同的点不会重合。", "outputFormat": "输出只有一行，包含一个实数，即 $D(l)$ 的最小值，四舍五入到小数点后两位。", "hint": "**样例解释 1**\n\n样例 $1$ 中， 取到最小值时的直线 $l$ 为 $y=1$ 。\n\n**样例解释 2**\n\n样例 $2$ 中的 $6$ 个点，以及 $D(l)$ 取到最小值时的直线 $l$ 如图所示。\n\n![1](https://cdn.luogu.com.cn/upload/pic/20067.png)\n\n**数据范围与提示**\n\n测试点 $1$：$n=3$。\n\n测试点 $2 \\sim 4$：$3 \\le n \\le 100$。\n\n测试点 $5 \\sim 7$：$100 < n \\le 100000$ ，且输入文件如下生成：选定一条线段，每次先在该线段上等概率随机选择一个点，再取离该点最近的整点。\n\n测试点 $8 \\sim 10$：$3 < n \\le 100000$。", "locale": "zh-CN"}}}
{"pid": "P4637", "type": "P", "difficulty": 6, "samples": [["4\n0 1\n2 2\n8 7\n11 2", "2.3333"], ["3\n-10 10\n0 1\n10 10", "2.3333"], ["2\n1 10\n2 100", "1.0000\n"], ["9\n1 10\n2 10\n3 10\n4 10\n5 10\n6 10\n7 10\n8 10\n1000 2000", "1.8889"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "上海", "Special Judge", "强连通分量", "期望"], "title": "[SHOI2011] 扫雷机器人", "background": "", "description": "扫雷是陆军战场上一项重要的而危险的任务。为此， AL 军工厂专门研制了一种扫雷机器人。这种机器人是专门针对直线形雷阵设计的。所谓直线形雷阵，就是所有的地雷都埋在同一条直线上。例如图中黑点表示的雷阵就是直线形雷阵。\n\n![0](https://cdn.luogu.com.cn/upload/pic/20066.png)\n\nAL 军工厂生产的扫雷机器人的排雷方法只有一种，那就是安全引爆。每次，机器人在所有探测到的地雷中选择一颗引爆。被引爆的地雷会接连引爆不超过他的爆炸威力范围的其它地雷，这些被间接引爆的地雷还能引起进一步的连锁爆炸。例如图中，用一个圆的半径表示地雷的爆炸威力。如果引爆 $2$ 号雷， $1$ 、 $2$ 号雷都会爆炸；如果引爆 $3$ 号雷， $4$ 颗地雷全都会爆炸；而如果引爆 $4$ 号雷，那就只有它一颗爆炸。\n\n虽然是机器人，但引爆也是危险的。所以，扫雷机器人的订购人希望机器人能在实战中采取引爆次数尽可能少的炸毁所有地雷的排雷方案。于是 AL 军工厂想就此方面对机器人进行测试。为了评估机器人的表现， AL 军工厂打算事先计算出：在一个直线形雷阵（即输入的雷阵）中，如果随机进行引爆，完成排雷工作所需要引爆次数的期望；并将这个值与机器人的实际排雷方案相比较，来评估他的表现。\n\n所谓“随机进行引爆”是指，每次在所有没有被引爆的地雷中等概率的随机选择一个进行引爆。当这一次引爆引发的连环爆炸结束后，如果还有地雷没有被引爆，则重复上面的操作，直到所有地雷都被引爆为止。", "inputFormat": "输入的第一行是一个正整数 $n$，表示地雷的个数。\n\n接下去 $n$ 行，每行描述一颗地雷。其中，第 $i+1$ 行有两个整数 $x_i$ 和 $d_i$，分别是地雷的坐标和地雷的爆炸威力。也就是说，第 $i$ 号地雷的爆炸能直接进一步引爆第 $j$ 号地雷的条件是 $|x_i-x_j| \\le d$。\n\n输入保证： $|x_i| \\le 10^8$，$1 \\le d_i \\le 10^8$。", "outputFormat": "输出只有一行，包含一个实数，即为答案。四舍五入到小数点后四位。", "hint": "**提示**\n\n本题的试题目录下有 $10$ 个额外的输入样例文件 ``robot20111.in~robot201110.in`` ，以及它们对应的输出样例文件 ``robot20111.out~robot201110.out`` 。这些数据符合本题中关于数据规模的全部约定，但它们不是最终的测试数据。\n\n**[下载地址](https://pan.baidu.com/s/1Q5X52FMH38UYvmrEsVsEkA)**，密码：ypbv。\n\n**评分方式**\n\n在每个测试点，如果您的输出是 $YourAns$ ，而标准答案是 $StdAns$ ，那么：\n\n-    当 $ |YourAns-StdAns| \\le 0.0001$ 时，该测试点得 $10$ 分。\n\n-    当 $0.01 \\ge |YourAns-StdAns| > 0.0001$ 时，该测试点得 $6$ 分。\n\n-    当 $0.5 \\ge |YourAns-StdAns| > 0.01$ 时，该测试点得 $2$ 分。\n\n-    否则得 $0$ 分。\n\n**数据范围**\n\n测试点 $1$：$n \\le 20$。\n\n测试点 $2$：$n \\le 200$ ，且任意方案都保证引爆次数不超过 $20$。\n\n测试点 $3$：$n \\le 200$。\n\n测试点 $4 \\sim 5$：$n \\le 4000$ ，且任意方案都保证引爆次数不超过 $20$。\n\n测试点 $6 \\sim 10$：$n \\le 4000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2011] Minesweeper Robot", "background": "", "description": "Minesweeping is an important and dangerous task on the army battlefield. For this purpose, the AL military factory specially developed a minesweeping robot. This robot is designed specifically for linear minefields. A so-called linear minefield means that all mines are buried on the same straight line. For example, in the figure, the minefield marked by black dots is a linear minefield.\n\n![0](https://cdn.luogu.com.cn/upload/pic/20066.png)\n\nThe AL military factory’s minesweeping robot has only one method to clear mines: safe detonation. Each time, the robot chooses one mine among all detected mines to detonate. The detonated mine will in turn detonate other mines that are within its blast range. These indirectly detonated mines can further cause chain explosions. For example, in the figure, a circle radius represents a mine’s blast range. If mine $2$ is detonated, mines $1$ and $2$ will explode; if mine $3$ is detonated, all $4$ mines will explode; but if mine $4$ is detonated, then only mine $4$ will explode.\n\nEven for a robot, detonation is dangerous. Therefore, the buyer hopes that in real combat the robot can use a clearing plan that destroys all mines with as few detonations as possible. So the AL military factory wants to test the robot on this aspect. To evaluate the robot’s performance, the AL military factory plans to compute in advance: in a linear minefield (i.e., the input minefield), if detonations are performed randomly, the expected number of detonations needed to finish clearing all mines. This value will then be compared with the robot’s actual clearing plan to evaluate its performance.\n\n“Random detonation” means that each time, one mine is chosen uniformly at random among all mines that have not been detonated, and then detonated. After the chain reaction caused by this detonation ends, if there are still mines that have not been detonated, repeat the above operation until all mines have been detonated.", "inputFormat": "The first line contains a positive integer $n$, the number of mines.\n\nThe next $n$ lines describe the mines in order of their positions, one mine per line. On line $i+1$, there are two integers $x_i$ and $d_i$, representing the coordinate of the mine and its blast power. That is, mine $i$ can directly detonate mine $j$ if $|x_i-x_j| \\le d_i$. The input guarantees: $|x_i| \\le 10^8$, $1 \\le d_i \\le 10^8$.", "outputFormat": "Output one line containing one real number, which is the answer. Round to four digits after the decimal point.", "hint": "**Hint**\n\nIn the problem directory, there are $10$ additional input sample files ``robot20111.in~robot201110.in`` and their corresponding output sample files ``robot20111.out~robot201110.out``. These files satisfy all constraints in this problem, but they are not the final testdata.\n\n**[Download link](https://pan.baidu.com/s/1Q5X52FMH38UYvmrEsVsEkA)**, password: ypbv.\n\n**Scoring**\n\nFor each test point, if your output is $YourAns$ and the standard answer is $StdAns$, then:\n\n- When $|YourAns-StdAns| \\le 0.0001$, you get $10$ points for that test point.\n- When $0.01 \\ge |YourAns-StdAns| > 0.0001$, you get $6$ points.\n- When $0.5 \\ge |YourAns-StdAns| > 0.01$, you get $2$ points.\n- Otherwise, you get $0$ points.\n\n**Constraints**\n\nTest point $1$: $n \\le 20$.\n\nTest point $2$: $n \\le 200$, and any strategy guarantees that the number of detonations does not exceed $20$.\n\nTest point $3$: $n \\le 200$.\n\nTest points $4 \\sim 5$: $n \\le 4000$, and any strategy guarantees that the number of detonations does not exceed $20$.\n\nTest points $6 \\sim 10$: $n \\le 4000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2011] 扫雷机器人", "background": "", "description": "扫雷是陆军战场上一项重要的而危险的任务。为此， AL 军工厂专门研制了一种扫雷机器人。这种机器人是专门针对直线形雷阵设计的。所谓直线形雷阵，就是所有的地雷都埋在同一条直线上。例如图中黑点表示的雷阵就是直线形雷阵。\n\n![0](https://cdn.luogu.com.cn/upload/pic/20066.png)\n\nAL 军工厂生产的扫雷机器人的排雷方法只有一种，那就是安全引爆。每次，机器人在所有探测到的地雷中选择一颗引爆。被引爆的地雷会接连引爆不超过他的爆炸威力范围的其它地雷，这些被间接引爆的地雷还能引起进一步的连锁爆炸。例如图中，用一个圆的半径表示地雷的爆炸威力。如果引爆 $2$ 号雷， $1$ 、 $2$ 号雷都会爆炸；如果引爆 $3$ 号雷， $4$ 颗地雷全都会爆炸；而如果引爆 $4$ 号雷，那就只有它一颗爆炸。\n\n虽然是机器人，但引爆也是危险的。所以，扫雷机器人的订购人希望机器人能在实战中采取引爆次数尽可能少的炸毁所有地雷的排雷方案。于是 AL 军工厂想就此方面对机器人进行测试。为了评估机器人的表现， AL 军工厂打算事先计算出：在一个直线形雷阵（即输入的雷阵）中，如果随机进行引爆，完成排雷工作所需要引爆次数的期望；并将这个值与机器人的实际排雷方案相比较，来评估他的表现。\n\n所谓“随机进行引爆”是指，每次在所有没有被引爆的地雷中等概率的随机选择一个进行引爆。当这一次引爆引发的连环爆炸结束后，如果还有地雷没有被引爆，则重复上面的操作，直到所有地雷都被引爆为止。", "inputFormat": "输入的第一行是一个正整数 $n$，表示地雷的个数。\n\n接下去 $n$ 行，每行描述一颗地雷。其中，第 $i+1$ 行有两个整数 $x_i$ 和 $d_i$，分别是地雷的坐标和地雷的爆炸威力。也就是说，第 $i$ 号地雷的爆炸能直接进一步引爆第 $j$ 号地雷的条件是 $|x_i-x_j| \\le d$。\n\n输入保证： $|x_i| \\le 10^8$，$1 \\le d_i \\le 10^8$。", "outputFormat": "输出只有一行，包含一个实数，即为答案。四舍五入到小数点后四位。", "hint": "**提示**\n\n本题的试题目录下有 $10$ 个额外的输入样例文件 ``robot20111.in~robot201110.in`` ，以及它们对应的输出样例文件 ``robot20111.out~robot201110.out`` 。这些数据符合本题中关于数据规模的全部约定，但它们不是最终的测试数据。\n\n**[下载地址](https://pan.baidu.com/s/1Q5X52FMH38UYvmrEsVsEkA)**，密码：ypbv。\n\n**评分方式**\n\n在每个测试点，如果您的输出是 $YourAns$ ，而标准答案是 $StdAns$ ，那么：\n\n-    当 $ |YourAns-StdAns| \\le 0.0001$ 时，该测试点得 $10$ 分。\n\n-    当 $0.01 \\ge |YourAns-StdAns| > 0.0001$ 时，该测试点得 $6$ 分。\n\n-    当 $0.5 \\ge |YourAns-StdAns| > 0.01$ 时，该测试点得 $2$ 分。\n\n-    否则得 $0$ 分。\n\n**数据范围**\n\n测试点 $1$：$n \\le 20$。\n\n测试点 $2$：$n \\le 200$ ，且任意方案都保证引爆次数不超过 $20$。\n\n测试点 $3$：$n \\le 200$。\n\n测试点 $4 \\sim 5$：$n \\le 4000$ ，且任意方案都保证引爆次数不超过 $20$。\n\n测试点 $6 \\sim 10$：$n \\le 4000$。", "locale": "zh-CN"}}}
{"pid": "P4638", "type": "P", "difficulty": 6, "samples": [["3 3\n3 1 10\n2 1 2 2\n2 1 3 3\n1 2 6", "7"], ["2 3\n2 3\n2 1 2 1\n1 2 2\n1 2 2", "5"], ["6 6\n6 3 2 0 1 3\n2 1 2 0\n1 3 3\n1 1 1\n2 2 3 8\n2 4 5 2\n2 4 6 6", "15"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "上海"], "title": "[SHOI2011] 银行家", "background": "", "description": "你在一家银行工作，任务是帮助客户取出他们存放在保险箱里的金币。\n\n银行里有 $m$ 个保险箱，你没有办法打开这些保险箱，因为钥匙都在客户的手里。一个客户可能有很多个保险箱的钥匙，一个保险箱的钥匙也可能被多个客户拥有。今天早上，经理已经告知，你需要按照顺序接待 $n$ 个客户（任何客户都不会同时到场），你也知道，第 $i$ 个客户会要求取走 $c_i$​​ 枚金币。每个客户来到银行的时候，会打开所有他能打开的保险箱，然后从中取走 $c_i$​​ 枚金币（任何金币都没有区别），如果这些保险箱里的金币数量不足 ，他会感到不高兴，在取走尽量多的金币之后，到你的经理那里去投诉你们银行的服务质量太差了。\n\n你当然不希望“上帝”的投诉让你丢了工作，于是想到了个补救的办法：虽然每个客户走的时候都会把保险箱重新关上，但是你可以在他取金币的时候，偷偷地调整被打开的保险箱里的金币数量，譬如说把 $1$ 号保险里多余的 $5$ 枚放到 $2$ 号里，这样说不定下个客户来的时候，就能取到更多的金币了。\n\n尽管有这样的方法，还是可能没法完成所有客户的要求。然而，你希望，尽量帮助客户取走更多的金币，这样才能消除他们的怒气，保住这份来之不易的工作和薪水。 ", "inputFormat": "第一行有两个正整数： $m$ 和 $n$ ， $m$ 表示保险柜的数量， $n$ 表示客户的数量。\n\n第二行有 $m$ 个非负正数，表示银行在开始营业前，第 $1$ 号保险柜到第 $m$ 号保险柜的金币数量。 接下来有 $n$ 行，按照前来银行的顺序，依次描述了每个客户的情况。每行的开始都是一个非负整数 $k$ ，接着有 $k$ 个 $1$ 到 $m$ 之间的整数 $a_1,a_2,…,a_k$ ，表示这个客户拥有 $a_1$​​ 号、 $a_2$ 号，直到 $a_k$​​ 号保险箱的钥匙。最后还有一个非负整数 $c_i$​​ ，表示他需要的金币数量。 输入保证所有出现在输入数据中的整数都不超过 $10000$ 。", "outputFormat": "输出只需要一个整数，表示所有客户可以取走的金币总数的最大值。\n输入保证答案不会超过 $100000$ 。 ", "hint": "### 数据范围\n\n测试点编号 .|n$\\le$ .|m$\\le$ .\n-|-|-\n1|30|100\n2|40|50\n3|100|400\n4|100|400\n5|100|400\n6|200|500\n7|300|500\n8|400|1500\n9|500|2000\n10|600|2500", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2011] Banker", "background": "", "description": "You work at a bank, and your job is to help customers withdraw the gold coins stored in their safe deposit boxes.\n\nThere are $m$ safe deposit boxes in the bank. You cannot open these boxes because the keys are held by the customers. A customer may have keys to many boxes, and a box may also have keys held by multiple customers. This morning, the manager told you that you must receive $n$ customers in order (no two customers will arrive at the same time). You also know that the $i$-th customer will ask to withdraw $c_i$ gold coins. When a customer arrives, they will open all the boxes they can open and take $c_i$ coins from them (all coins are identical). If the total number of coins in these boxes is not enough, they will be unhappy. After taking as many coins as possible, they will go to your manager to complain that the bank’s service is terrible.\n\nOf course, you do not want complaints to cost you your job, so you come up with a remedy: although each customer will close the boxes again when leaving, while they are taking coins, you can secretly adjust the numbers of coins in the opened boxes. For example, you can move the extra $5$ coins in box $1$ into box $2$, so that the next customer may be able to withdraw more coins.\n\nEven with this method, it may still be impossible to satisfy all customers’ requests. However, you want to help customers withdraw as many coins as possible in total, so as to reduce their anger and keep this hard-earned job and salary.", "inputFormat": "The first line contains two positive integers $m$ and $n$, where $m$ is the number of safe deposit boxes and $n$ is the number of customers.\n\nThe second line contains $m$ non-negative integers, representing the numbers of coins in boxes $1$ to $m$ before the bank opens. Then follow $n$ lines, describing each customer in the order they arrive. Each line starts with a non-negative integer $k$, followed by $k$ integers $a_1,a_2,\\ldots,a_k$ between $1$ and $m$, indicating that the customer has the keys to boxes $a_1$, $a_2$, up to $a_k$. Finally, there is a non-negative integer $c_i$, indicating the number of coins they need. The input guarantees that all integers appearing in the input data do not exceed $10000$.", "outputFormat": "Output one integer, the maximum possible total number of coins that all customers can withdraw. The input guarantees that the answer does not exceed $100000$.", "hint": "### Constraints\n\nTest point ID | $n \\le$ | $m \\le$\n-|-|-\n1 | 30 | 100\n2 | 40 | 50\n3 | 100 | 400\n4 | 100 | 400\n5 | 100 | 400\n6 | 200 | 500\n7 | 300 | 500\n8 | 400 | 1500\n9 | 500 | 2000\n10 | 600 | 2500\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2011] 银行家", "background": "", "description": "你在一家银行工作，任务是帮助客户取出他们存放在保险箱里的金币。\n\n银行里有 $m$ 个保险箱，你没有办法打开这些保险箱，因为钥匙都在客户的手里。一个客户可能有很多个保险箱的钥匙，一个保险箱的钥匙也可能被多个客户拥有。今天早上，经理已经告知，你需要按照顺序接待 $n$ 个客户（任何客户都不会同时到场），你也知道，第 $i$ 个客户会要求取走 $c_i$​​ 枚金币。每个客户来到银行的时候，会打开所有他能打开的保险箱，然后从中取走 $c_i$​​ 枚金币（任何金币都没有区别），如果这些保险箱里的金币数量不足 ，他会感到不高兴，在取走尽量多的金币之后，到你的经理那里去投诉你们银行的服务质量太差了。\n\n你当然不希望“上帝”的投诉让你丢了工作，于是想到了个补救的办法：虽然每个客户走的时候都会把保险箱重新关上，但是你可以在他取金币的时候，偷偷地调整被打开的保险箱里的金币数量，譬如说把 $1$ 号保险里多余的 $5$ 枚放到 $2$ 号里，这样说不定下个客户来的时候，就能取到更多的金币了。\n\n尽管有这样的方法，还是可能没法完成所有客户的要求。然而，你希望，尽量帮助客户取走更多的金币，这样才能消除他们的怒气，保住这份来之不易的工作和薪水。 ", "inputFormat": "第一行有两个正整数： $m$ 和 $n$ ， $m$ 表示保险柜的数量， $n$ 表示客户的数量。\n\n第二行有 $m$ 个非负正数，表示银行在开始营业前，第 $1$ 号保险柜到第 $m$ 号保险柜的金币数量。 接下来有 $n$ 行，按照前来银行的顺序，依次描述了每个客户的情况。每行的开始都是一个非负整数 $k$ ，接着有 $k$ 个 $1$ 到 $m$ 之间的整数 $a_1,a_2,…,a_k$ ，表示这个客户拥有 $a_1$​​ 号、 $a_2$ 号，直到 $a_k$​​ 号保险箱的钥匙。最后还有一个非负整数 $c_i$​​ ，表示他需要的金币数量。 输入保证所有出现在输入数据中的整数都不超过 $10000$ 。", "outputFormat": "输出只需要一个整数，表示所有客户可以取走的金币总数的最大值。\n输入保证答案不会超过 $100000$ 。 ", "hint": "### 数据范围\n\n测试点编号 .|n$\\le$ .|m$\\le$ .\n-|-|-\n1|30|100\n2|40|50\n3|100|400\n4|100|400\n5|100|400\n6|200|500\n7|300|500\n8|400|1500\n9|500|2000\n10|600|2500", "locale": "zh-CN"}}}
{"pid": "P4639", "type": "P", "difficulty": 6, "samples": [["0 100 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nADD A B\nIF A < 220 GOTO LINE 2\nPRINT A", "300"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "上海", "提交答案"], "title": "[SHOI2011] 编译优化", "background": " ", "description": "就像 PASCAL 语言和 C/C++ 语言一样， SH 语言也是一种编程语言。 SH 语言共有 $26$ 个寄存器，用大写拉丁字母 A, B, … , Z 表示。 SH 语言的程序中，第一行依次是这 $26$ 个寄存器的初始值，用空格分隔。程序的第二行起，每一行都是一条命令。 SH 语言有三种命令，如下表所示（在格式这一列中，用下划线代替实际语言中的一个空格）。\n\n-    ``ADD``命令 格式：``ADD_R1_R2``  功能：将寄存器 R2 的值加到寄存器 R1 上。 限制：无。\n\n-    ``GOTO`` 命令 格式：``IF _R_ < _I1_ GOTO _LINE_ I2`` 功能：如果寄存器 R 的值小于立即数 I1 ，则跳转至第 I2 （ $\\ge 2$ ）行，否则继续执行下一行。限制：至多出现一次，且只可能出现在第 I2 行之后。\n\n-    ``PRINT`` 命令 格式：``PRINT_R`` 功能：打印寄存器 R 的值。限制：出现且仅出现在最后一行。\n\n现给定一个 SH 语言的程序，请输出 ``PRINT`` 命令打印的值。", "inputFormat": "每个输入文件都是一个 SH 语言的程序。输入文件保证：所有寄存器的初始值以及 ``GOTO`` 命令中出现的立即数，均为不超过 $2^{63}-1$ 的非负整数，但程序执行过程中寄存器的值不限于此。", "outputFormat": "每个输出文件只有一行，包含一个整数，即 ``PRINT`` 命令所打印的值。", "hint": "在每个测试点，如果您的输出与标准答案完全一致，您将能得到该测试点的全部分数；否则，您将在该测试点得 $0$ 分。\n\n本题为提交答案题，所有的 $10$ 个输入文件 ``compiler1.in ~ compiler10.in`` 都已存放在题目背景的下载链接中。对于每个输入文件，您需要分别给出相应的输出文件 ``compiler1.out ~ compiler10.out``。\n\n注意：您只需提交输出文件而无需提交任何程序。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2011] Compiler Optimization", "background": "", "description": "Just like the PASCAL language and the C/C++ language, the SH language is also a programming language. The SH language has $26$ registers, represented by uppercase Latin letters A, B, … , Z. In an SH program, the first line contains the initial values of these $26$ registers in order, separated by spaces. Starting from the second line, each line is one instruction. The SH language has three kinds of instructions, as shown in the table below (in the “Format” column, underscores are used to represent a single space in the actual language).\n\n- The ``ADD`` instruction. Format: ``ADD_R1_R2``. Function: add the value of register R2 to register R1. Restriction: none.\n\n- The ``GOTO`` instruction. Format: ``IF _R_ < _I1_ GOTO _LINE_ I2``. Function: if the value of register R is less than the immediate value I1, then jump to line I2 ( $\\ge 2$ ); otherwise, continue to execute the next line. Restriction: it appears at most once, and it can only appear after line I2.\n\n- The ``PRINT`` instruction. Format: ``PRINT_R``. Function: print the value of register R. Restriction: it appears and only appears on the last line.\n\nGiven an SH program, output the value printed by the ``PRINT`` instruction.", "inputFormat": "Each input file is an SH program. The input guarantees that all initial register values and the immediate values appearing in the ``GOTO`` instruction are non-negative integers not exceeding $2^{63}-1$, but during program execution, register values are not limited to this range.", "outputFormat": "Each output file contains only one line with one integer, which is the value printed by the ``PRINT`` instruction.", "hint": "For each test point, if your output is exactly the same as the standard answer, you will get full score for that test point; otherwise, you will get $0$ points for that test point.\n\nThis is an output-only problem. All $10$ input files ``compiler1.in ~ compiler10.in`` have been provided in the download link in the “Background” section. For each input file, you need to provide the corresponding output file ``compiler1.out ~ compiler10.out``.\n\nNote: You only need to submit the output files, and you do not need to submit any program.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2011] 编译优化", "background": " ", "description": "就像 PASCAL 语言和 C/C++ 语言一样， SH 语言也是一种编程语言。 SH 语言共有 $26$ 个寄存器，用大写拉丁字母 A, B, … , Z 表示。 SH 语言的程序中，第一行依次是这 $26$ 个寄存器的初始值，用空格分隔。程序的第二行起，每一行都是一条命令。 SH 语言有三种命令，如下表所示（在格式这一列中，用下划线代替实际语言中的一个空格）。\n\n-    ``ADD``命令 格式：``ADD_R1_R2``  功能：将寄存器 R2 的值加到寄存器 R1 上。 限制：无。\n\n-    ``GOTO`` 命令 格式：``IF _R_ < _I1_ GOTO _LINE_ I2`` 功能：如果寄存器 R 的值小于立即数 I1 ，则跳转至第 I2 （ $\\ge 2$ ）行，否则继续执行下一行。限制：至多出现一次，且只可能出现在第 I2 行之后。\n\n-    ``PRINT`` 命令 格式：``PRINT_R`` 功能：打印寄存器 R 的值。限制：出现且仅出现在最后一行。\n\n现给定一个 SH 语言的程序，请输出 ``PRINT`` 命令打印的值。", "inputFormat": "每个输入文件都是一个 SH 语言的程序。输入文件保证：所有寄存器的初始值以及 ``GOTO`` 命令中出现的立即数，均为不超过 $2^{63}-1$ 的非负整数，但程序执行过程中寄存器的值不限于此。", "outputFormat": "每个输出文件只有一行，包含一个整数，即 ``PRINT`` 命令所打印的值。", "hint": "在每个测试点，如果您的输出与标准答案完全一致，您将能得到该测试点的全部分数；否则，您将在该测试点得 $0$ 分。\n\n本题为提交答案题，所有的 $10$ 个输入文件 ``compiler1.in ~ compiler10.in`` 都已存放在题目背景的下载链接中。对于每个输入文件，您需要分别给出相应的输出文件 ``compiler1.out ~ compiler10.out``。\n\n注意：您只需提交输出文件而无需提交任何程序。", "locale": "zh-CN"}}}
{"pid": "P4640", "type": "P", "difficulty": 6, "samples": [["2 1 10 13\n3", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2008", "北京"], "title": "[BJWC2008] 王之财宝", "background": "", "description": "《基尔伽美修》是人类历史上第一部英雄史诗，两河流域最杰出的文学作品之一。作品讲述了基尔伽美修一生的传奇故事。在动画Fate/stay night中，基尔伽美修与亚瑟王等传说中的英雄人物一起出现在了现实世界，展开了一场惊天地、泣鬼神的战斗。在记载于12块泥板的史诗中，基尔伽美修与同伴安吉杜一起降伏了森林的守护者——神兽洪芭芭，成为地上最强的王者，同时将世间所有财宝收归手中。王之财宝(Gate of Babylon)成为Fate中金皮卡（基尔伽美修的外号…）炫耀的资本……\n\n一天金皮卡突发奇想：如果从自己无尽的财宝里面，随便抽不超过M件宝具出来砸死敌人的话。一共有多少种搭配方法呢？假设金皮卡一共有N种不同类型的宝具，大部分类型的宝具都有无限多，但其中T种超级神器的数量是有限的。设第i种超级神器的数量不超过$B_i$件。若相同类型的宝具数量相同，则认为是相同的搭配方案。\n\n金皮卡知道方案数会很大，从小数学成绩就好的他挑选了一个质数P，请你帮他计算一下方案数模P后的余数。注意，一件也不选也是一种方案。", "inputFormat": "第一行包含4个整数，分别为N，T，M，P\n\n之后T行，每行一个整数，代表$B_i$\n\n$N,M≤10^9$，$P≤10^5$，$B_i≤10^9$\n\n$0≤T≤N$，$M>0$，$B_i>0$，$T≤15$", "outputFormat": "仅包含一个整数，即方案数模P后的余数。", "hint": "只有一种超级神器，数量不超过3\n\n当不选择超级神器时，另一种宝具可以挑选0到10件，共11种方案\n\n当选择1件神器出来时，另一种宝具可以挑选0到9件，共10种方案\n\n当挑选2件神器时，共9种方案\n\n挑选3件神器时，共8种方案\n\n一共有11+10+9+8=38种方案，$38\\bmod13=12$，于是答案等于12", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2008] The King's Treasure", "background": "", "description": "The Epic of Gilgamesh is the first heroic epic in human history and one of the greatest literary works of Mesopotamia. It tells the legendary life story of Gilgamesh. In the anime Fate/stay night, Gilgamesh appears in the real world together with legendary heroes such as King Arthur, and a world-shaking battle begins. In the epic recorded on 12 clay tablets, Gilgamesh and his companion Enkidu subdue the guardian of the forest—the divine beast Humbaba—becoming the strongest king on earth, and at the same time taking all the treasures of the world for themselves. The “Gate of Babylon” becomes the capital that “Kinpika” (Gilgamesh’s nickname...) uses to show off in Fate...\n\nOne day, Kinpika suddenly has an idea: if he randomly takes out at most $M$ treasures from his endless collection to smash enemies to death, how many different ways of matching are there in total? Suppose Kinpika has $N$ different types of treasures. Most types have an unlimited quantity, but among them there are $T$ types of “super divine artifacts” whose quantities are limited. Let the quantity of the $i$-th super divine artifact be at most $B_i$. If the numbers of treasures of each type are the same, then they are considered the same matching plan.\n\nKinpika knows the number of plans will be very large. Since he has always been good at math, he chooses a prime number $P$. Please help him compute the remainder of the number of plans modulo $P$. Note that selecting none is also a valid plan.", "inputFormat": "The first line contains four integers: $N$, $T$, $M$, $P$.\n\nThe next $T$ lines each contain one integer, representing $B_i$.\n\nConstraints: $N, M \\le 10^9$, $P \\le 10^5$, $B_i \\le 10^9$, $0 \\le T \\le N$, $M > 0$, $B_i > 0$, $T \\le 15$.", "outputFormat": "Output only one integer, the remainder of the number of plans modulo $P$.", "hint": "There is only one super divine artifact, with quantity at most 3.\n\nWhen not selecting the super divine artifact, the other type of treasure can be selected from 0 to 10 items, for a total of 11 plans.\n\nWhen selecting 1 artifact, the other type of treasure can be selected from 0 to 9 items, for a total of 10 plans.\n\nWhen selecting 2 artifacts, there are 9 plans in total.\n\nWhen selecting 3 artifacts, there are 8 plans in total.\n\nIn total there are $11 + 10 + 9 + 8 = 38$ plans, and $38 \\bmod 13 = 12$, so the answer is 12.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2008] 王之财宝", "background": "", "description": "《基尔伽美修》是人类历史上第一部英雄史诗，两河流域最杰出的文学作品之一。作品讲述了基尔伽美修一生的传奇故事。在动画Fate/stay night中，基尔伽美修与亚瑟王等传说中的英雄人物一起出现在了现实世界，展开了一场惊天地、泣鬼神的战斗。在记载于12块泥板的史诗中，基尔伽美修与同伴安吉杜一起降伏了森林的守护者——神兽洪芭芭，成为地上最强的王者，同时将世间所有财宝收归手中。王之财宝(Gate of Babylon)成为Fate中金皮卡（基尔伽美修的外号…）炫耀的资本……\n\n一天金皮卡突发奇想：如果从自己无尽的财宝里面，随便抽不超过M件宝具出来砸死敌人的话。一共有多少种搭配方法呢？假设金皮卡一共有N种不同类型的宝具，大部分类型的宝具都有无限多，但其中T种超级神器的数量是有限的。设第i种超级神器的数量不超过$B_i$件。若相同类型的宝具数量相同，则认为是相同的搭配方案。\n\n金皮卡知道方案数会很大，从小数学成绩就好的他挑选了一个质数P，请你帮他计算一下方案数模P后的余数。注意，一件也不选也是一种方案。", "inputFormat": "第一行包含4个整数，分别为N，T，M，P\n\n之后T行，每行一个整数，代表$B_i$\n\n$N,M≤10^9$，$P≤10^5$，$B_i≤10^9$\n\n$0≤T≤N$，$M>0$，$B_i>0$，$T≤15$", "outputFormat": "仅包含一个整数，即方案数模P后的余数。", "hint": "只有一种超级神器，数量不超过3\n\n当不选择超级神器时，另一种宝具可以挑选0到10件，共11种方案\n\n当选择1件神器出来时，另一种宝具可以挑选0到9件，共10种方案\n\n当挑选2件神器时，共9种方案\n\n挑选3件神器时，共8种方案\n\n一共有11+10+9+8=38种方案，$38\\bmod13=12$，于是答案等于12", "locale": "zh-CN"}}}
{"pid": "P4641", "type": "P", "difficulty": 5, "samples": [["3 5\n1\n2\n4\nQ 1\nQ 2\nA 1\nQ 1\nQ 2", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2008", "北京"], "title": "[BJWC2008] 序列", "background": "", "description": "对一个长度为$N$的序列$\\{a_n\\}(a_i\\in[0,2^{16}-1])$，进行如下两种，共计$M$个操作：\n\n1. `A x`$(x\\ge0)$：$a_i=a_i+x\\mod2^{16}$\n\n2. `Q i`：询问$Card\\{k\\mid(a_k\\;\\&\\;2^i)>0,1\\le k\\le N,k\\in\\mathbb{Z}\\}$的结果\n\n其中$\\&$运算符为相当于C/C++中的`&`或Pascal中的`and`\n\n给定初始序列和操作序列，请你模拟操作过程，并计算所有$Q$操作的相应的结果的和。", "inputFormat": "输入文件的第一行包含两个以空格分隔的整数，分别代表$N,M$\n\n接下来的$N$行每行包含一个整数，代表初始序列\n\n接下来的$M$行，每行描述一个操作，格式如题目中所述", "outputFormat": "输出文件包含一个整数，表示所有$Q$操作的结果的和\n", "hint": "初始序列为$1\\;2\\;4$\n\n`Q 1`：仅$a_2=2$满足$(a_k\\;\\&\\;2^i)>0$，该$Q$操作的结果为$1$\n\n`Q 2`：仅$a_3=4$满足$(a_k\\;\\&\\;2^i)>0$，该$Q$操作的结果为$1$\n\n`A 1`：原序列变为$2\\;3\\;5$\n\n`Q 1`：仅$a_1=2,a_2=3$满足$(a_k\\;\\&\\;2^i)>0$，该$Q$操作的结果为$2$\n\n`Q 2`：仅$a_3=5$满足$(a_k\\;\\&\\;2^i)>0$，该$Q$操作的结果为$1$\n\n$1+1+2+1=5$，所以最终结果为5\n\n$30\\%$的数据满足$1\\le N\\le100,1\\le M\\le1000$\n\n$100\\%$的数据满足$1\\le N,M\\le10^5$", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2008] Sequence", "background": "", "description": "For a sequence $\\{a_n\\}$ of length $N$ $(a_i \\in [0, 2^{16} - 1])$, perform the following two types of operations, for a total of $M$ operations:\n\n1. `A x` $(x \\ge 0)$: $a_i = a_i + x \\mod 2^{16}$.\n\n2. `Q i`: Query the value of $Card\\{k \\mid (a_k\\;\\&\\;2^i) > 0, 1 \\le k \\le N, k \\in \\mathbb{Z}\\}$.\n\nHere, the $\\&$ operator is the same as `&` in C/C++ or `and` in Pascal.\n\nGiven the initial sequence and the list of operations, simulate the process and compute the sum of the results of all `Q` operations.", "inputFormat": "The first line contains two integers $N, M$ separated by spaces, representing $N$ and $M$.\n\nThe next $N$ lines each contain one integer, representing the initial sequence.\n\nThe next $M$ lines each describe one operation, in the format stated in the description.", "outputFormat": "Output one integer, representing the sum of the results of all `Q` operations.", "hint": "The initial sequence is $1\\;2\\;4$.\n\n`Q 1`: Only $a_2 = 2$ satisfies $(a_k\\;\\&\\;2^i) > 0$, so the result of this `Q` operation is $1$.\n\n`Q 2`: Only $a_3 = 4$ satisfies $(a_k\\;\\&\\;2^i) > 0$, so the result of this `Q` operation is $1$.\n\n`A 1`: The original sequence becomes $2\\;3\\;5$.\n\n`Q 1`: Only $a_1 = 2, a_2 = 3$ satisfy $(a_k\\;\\&\\;2^i) > 0$, so the result of this `Q` operation is $2$.\n\n`Q 2`: Only $a_3 = 5$ satisfies $(a_k\\;\\&\\;2^i) > 0$, so the result of this `Q` operation is $1$.\n\n$1 + 1 + 2 + 1 = 5$, so the final result is $5$.\n\nConstraints:\n\n$30\\%$ of the testdata satisfy $1 \\le N \\le 100, 1 \\le M \\le 1000$.\n\n$100\\%$ of the testdata satisfy $1 \\le N, M \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2008] 序列", "background": "", "description": "对一个长度为$N$的序列$\\{a_n\\}(a_i\\in[0,2^{16}-1])$，进行如下两种，共计$M$个操作：\n\n1. `A x`$(x\\ge0)$：$a_i=a_i+x\\mod2^{16}$\n\n2. `Q i`：询问$Card\\{k\\mid(a_k\\;\\&\\;2^i)>0,1\\le k\\le N,k\\in\\mathbb{Z}\\}$的结果\n\n其中$\\&$运算符为相当于C/C++中的`&`或Pascal中的`and`\n\n给定初始序列和操作序列，请你模拟操作过程，并计算所有$Q$操作的相应的结果的和。", "inputFormat": "输入文件的第一行包含两个以空格分隔的整数，分别代表$N,M$\n\n接下来的$N$行每行包含一个整数，代表初始序列\n\n接下来的$M$行，每行描述一个操作，格式如题目中所述", "outputFormat": "输出文件包含一个整数，表示所有$Q$操作的结果的和\n", "hint": "初始序列为$1\\;2\\;4$\n\n`Q 1`：仅$a_2=2$满足$(a_k\\;\\&\\;2^i)>0$，该$Q$操作的结果为$1$\n\n`Q 2`：仅$a_3=4$满足$(a_k\\;\\&\\;2^i)>0$，该$Q$操作的结果为$1$\n\n`A 1`：原序列变为$2\\;3\\;5$\n\n`Q 1`：仅$a_1=2,a_2=3$满足$(a_k\\;\\&\\;2^i)>0$，该$Q$操作的结果为$2$\n\n`Q 2`：仅$a_3=5$满足$(a_k\\;\\&\\;2^i)>0$，该$Q$操作的结果为$1$\n\n$1+1+2+1=5$，所以最终结果为5\n\n$30\\%$的数据满足$1\\le N\\le100,1\\le M\\le1000$\n\n$100\\%$的数据满足$1\\le N,M\\le10^5$", "locale": "zh-CN"}}}
{"pid": "P4642", "type": "P", "difficulty": 7, "samples": [["1 2\n100 100 10\n3 3\n99 100", "0.30000\nIMPOSSIBLE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2008", "北京", "线性规划", "半平面交"], "title": "[BJWC2008] 方程", "background": "", "description": "给定$3\\times N$个正整数\n\n$A_1,A_2...A_n$\n\n$B_1,B_2...B_n$\n\n$C_1,C_2...C_n$\n\n另给定$M$对正整数$S_i,T_i$对于每一对$S_i,T_i$\n\n求下列方程组的一组非负实数解\n\n$A_1X_1+A_2X_2+...+A_nX_n=S_i$\n\n$B_1X_1+B_2X_2+...+B_nX_n=T_i$\n\n使得$C_1X_1+C_2X_2+...+C_nX_n$最大", "inputFormat": "第一行两个整数代表$N,M$\n \n接下来$N$行每行三个正整数$A_i,B_i,C_i$\n\n$N\\leq 10^5$, $M \\leq 10^4$\n\n$1\\le A_i,B_i,C_i,S_i,T_i\\le1000000$", "outputFormat": "输出为$M$行，第$i$行代表$S_i,T_i$\n\n如果方程无解输出`IMPOSSIBLE`\n\n否则输出一个实数保留五位小数，代表对应的最大值。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2008] Equation", "background": "", "description": "You are given $3 \\times N$ positive integers:\n\n$A_1, A_2...A_n$\n\n$B_1, B_2...B_n$\n\n$C_1, C_2...C_n$\n\nYou are also given $M$ pairs of positive integers $S_i, T_i$. For each pair $S_i, T_i$, find a set of non-negative real solutions to the following system of equations:\n\n$A_1X_1 + A_2X_2 + ... + A_nX_n = S_i$\n\n$B_1X_1 + B_2X_2 + ... + B_nX_n = T_i$\n\nsuch that $C_1X_1 + C_2X_2 + ... + C_nX_n$ is maximized.", "inputFormat": "The first line contains two integers $N, M$.\n\nThe next $N$ lines each contain three positive integers $A_i, B_i, C_i$.\n\nConstraints: $N \\leq 10^5$, $M \\leq 10^4$.\n\n$1 \\le A_i, B_i, C_i, S_i, T_i \\le 1000000$.", "outputFormat": "Output $M$ lines. The $i$-th line corresponds to $S_i, T_i$.\n\nIf the system has no solution, output `IMPOSSIBLE`.\n\nOtherwise, output a real number rounded to five decimal places, representing the corresponding maximum value.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2008] 方程", "background": "", "description": "给定$3\\times N$个正整数\n\n$A_1,A_2...A_n$\n\n$B_1,B_2...B_n$\n\n$C_1,C_2...C_n$\n\n另给定$M$对正整数$S_i,T_i$对于每一对$S_i,T_i$\n\n求下列方程组的一组非负实数解\n\n$A_1X_1+A_2X_2+...+A_nX_n=S_i$\n\n$B_1X_1+B_2X_2+...+B_nX_n=T_i$\n\n使得$C_1X_1+C_2X_2+...+C_nX_n$最大", "inputFormat": "第一行两个整数代表$N,M$\n \n接下来$N$行每行三个正整数$A_i,B_i,C_i$\n\n$N\\leq 10^5$, $M \\leq 10^4$\n\n$1\\le A_i,B_i,C_i,S_i,T_i\\le1000000$", "outputFormat": "输出为$M$行，第$i$行代表$S_i,T_i$\n\n如果方程无解输出`IMPOSSIBLE`\n\n否则输出一个实数保留五位小数，代表对应的最大值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4643", "type": "P", "difficulty": 5, "samples": [["4 4\n6\n4\n-1\n-2\n1 2 1\n2 3 6\n3 4 3\n1 4 5", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["集训队互测"], "title": "[国家集训队] 阿狸和桃子的游戏", "background": null, "description": "阿狸和桃子正在玩一个游戏，游戏是在一个带权图 $G=(V,E)$ 上进行的，设节点权值为 $w(v)$，边权为 $c(e)$。游戏规则是这样的：\n\n1. 阿狸和桃子轮流将图中的顶点染色，阿狸会将顶点染成红色，桃子会将顶点染成粉色。已经被染过色的点不能再染了，而且每一轮都必须给一个且仅一个顶点染色。\n\n2. 为了保证公平性，节点的个数 $N$ 为偶数。\n\n3. 经过 $\\frac{N}{2}$ 轮游戏之后，两人都得到了一个顶点集合。对于顶点集合 $S$，得分计算方式为\n\n$$\\sum_{v \\in S}w(v) + \\sum_{e=(u,v)\\in E \\land u,v\\in S}c(e)$$\n\n由于阿狸石头剪子布输给了桃子，所以桃子先染色。两人都想要使自己的分数比对方多，且多得越多越好。如果两人都是采用最优策略的，求最终桃子的分数减去阿狸的分数。", "inputFormat": "输入第一行包含两个正整数 $N$ 和 $M$，分别表示图 $G$ 的节点数和边数，保证 $N$ 一定是偶数。\n\n接下来 $N+M$ 行。\n\n前 $N$ 行，每行一个整数 $w$，其中第 $k$ 行为节点 $k$ 的权值。\n\n后 $M$ 行，每行三个用空格隔开的整数 $a,b,c$，表示一条连接节点 $a$ 和节点 $b$ 的边，权值为 $c$。", "outputFormat": "输出仅包含一个整数，为桃子的得分减去阿狸的得分。", "hint": "数据规模和约定：\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 16$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10000$，$1 \\le M \\le 100000$，$-10000 \\le w , c \\le 10000$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] Ali and Peach's Game", "background": "", "description": "Ali and Peach are playing a game on a weighted graph $G=(V,E)$. Let the weight of a vertex be $w(v)$, and the weight of an edge be $c(e)$. The rules are:\n\n1. Ali and Peach take turns coloring vertices in the graph. Ali colors a vertex red, and Peach colors a vertex pink. A vertex that has already been colored cannot be colored again, and in each turn, exactly one vertex must be colored.\n\n2. To ensure fairness, the number of vertices $N$ is even.\n\n3. After $\\frac{N}{2}$ rounds, each player obtains a set of vertices. For a vertex set $S$, the score is\n\n$$\\sum_{v \\in S}w(v) + \\sum_{e=(u,v)\\in E \\land u,v\\in S}c(e)$$\n\nSince Ali lost Rock-Paper-Scissors to Peach, Peach colors first. Both players want their own score to exceed the other’s, and the larger the difference, the better. Assuming both players use optimal strategies, find the final value of Peach’s score minus Ali’s score.", "inputFormat": "The first line contains two positive integers $N$ and $M$, representing the number of vertices and edges of the graph $G$, where $N$ is guaranteed to be even.\n\nThe next $N+M$ lines follow.\n\nThe first $N$ lines each contain one integer $w$. The $k$-th of these lines gives the weight of vertex $k$.\n\nThe next $M$ lines each contain three integers $a,b,c$ separated by spaces, describing an edge between vertices $a$ and $b$ with weight $c$.", "outputFormat": "Output exactly one integer, which is Peach’s score minus Ali’s score.", "hint": "Constraints and notes:\n\nFor $40\\%$ of the testdata, $1 \\le N \\le 16$.\n\nFor $100\\%$ of the testdata, $1 \\le N \\le 10000$, $1 \\le M \\le 100000$, $-10000 \\le w , c \\le 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] 阿狸和桃子的游戏", "background": null, "description": "阿狸和桃子正在玩一个游戏，游戏是在一个带权图 $G=(V,E)$ 上进行的，设节点权值为 $w(v)$，边权为 $c(e)$。游戏规则是这样的：\n\n1. 阿狸和桃子轮流将图中的顶点染色，阿狸会将顶点染成红色，桃子会将顶点染成粉色。已经被染过色的点不能再染了，而且每一轮都必须给一个且仅一个顶点染色。\n\n2. 为了保证公平性，节点的个数 $N$ 为偶数。\n\n3. 经过 $\\frac{N}{2}$ 轮游戏之后，两人都得到了一个顶点集合。对于顶点集合 $S$，得分计算方式为\n\n$$\\sum_{v \\in S}w(v) + \\sum_{e=(u,v)\\in E \\land u,v\\in S}c(e)$$\n\n由于阿狸石头剪子布输给了桃子，所以桃子先染色。两人都想要使自己的分数比对方多，且多得越多越好。如果两人都是采用最优策略的，求最终桃子的分数减去阿狸的分数。", "inputFormat": "输入第一行包含两个正整数 $N$ 和 $M$，分别表示图 $G$ 的节点数和边数，保证 $N$ 一定是偶数。\n\n接下来 $N+M$ 行。\n\n前 $N$ 行，每行一个整数 $w$，其中第 $k$ 行为节点 $k$ 的权值。\n\n后 $M$ 行，每行三个用空格隔开的整数 $a,b,c$，表示一条连接节点 $a$ 和节点 $b$ 的边，权值为 $c$。", "outputFormat": "输出仅包含一个整数，为桃子的得分减去阿狸的得分。", "hint": "数据规模和约定：\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 16$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10000$，$1 \\le M \\le 100000$，$-10000 \\le w , c \\le 10000$。", "locale": "zh-CN"}}}
{"pid": "P4644", "type": "P", "difficulty": 5, "samples": [["3 0 4\n0 2 3\n3 4 2\n0 0 1", "5"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [64512, 64512, 64512, 64512, 64512, 64512, 64512, 64512, 64512, 64512, 64512]}, "tags": ["动态规划 DP", "递推", "2005", "线段树", "USACO", "排序", "队列"], "title": "[USACO05DEC] Cleaning Shifts S", "background": "", "description": "约翰的奶牛们从小娇生惯养，她们无法容忍牛棚里的任何脏东西。约翰发现，如果要使这群有洁癖的奶牛满意，他不得不雇佣她们中的一些来清扫牛棚，约翰的奶牛中有 $ N(1 \\leq N \\leq 10000) $ 头愿意通过清扫牛棚来挣一些零花钱。\n\n由于在某个时段中奶牛们会在牛棚里随时随地地乱扔垃圾，自然地，她们要求在这段时间里，无论什么时候至少要有一头奶牛正在打扫。需要打扫的时段从某一天的第 $ M $ 秒开始，到第 $ E $ 秒结束 $ (0 \\leq M \\leq E \\leq 86399) $。注意这里的秒是指时间段而不是时间点，也就是说，每天需要打扫的总时间是 $ E-M+1 $ 秒。\n\n约翰已经从每头牛那里得到了她们愿意接受的工作计划：对于某一头牛，她每天都愿意在笫 $ T_1 \\ldots T_2 $ 秒的时间段内工作 $ (M \\leq T_1 \\leq T_2 \\leq E) $ ，所要求的报酬是 $ S $ 美元 $ (0 \\leq S \\leq 500000) $。与需打扫时段的描述一样，如果一头奶牛愿意工作的时段是每天的第 $ 10 \\ldots 20 $ 秒，那她总共工作的时间是 $ 11 $ 秒，而不是 $ 10 $ 秒。\n\n约翰一旦决定雇佣某一头奶牛，就必须付给她全额的工资，而不能只让她工作一段时间，然后再按这段时间在她愿意工作的总时间中所占的百分比来决定她的工资。现在请你帮约翰决定该雇佣哪些奶牛以保持牛棚的清洁，当然，在能让奶牛们满意的前提下，约翰希望使总花费尽量小。", "inputFormat": "第 $ 1 $ 行： $ 3 $ 个正整数 $ N,M,E $ 。\n\n第 $ 2 $ 到 $ N+1 $ 行：第 $ i+1 $ 行给出了编号为 $ i $ 的奶牛的工作计划，即 $ 3 $ 个正整数 $ T_1,T_2,S $ 。", "outputFormat": "输出一个整数，表示约翰需要为牛棚清理工作支付的最少费用。如果清理工作不可能完成，那么输出 $ -1 $ 。", "hint": "约翰有 $ 3 $ 头牛，牛棚在第 $ 0 $ 秒到第 $ 4 $ 秒之间需要打扫。 约翰雇佣前两头牛清扫牛棚，可以只花 $ 5 $ 美元就完成一整天的清扫。\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO05DEC] Cleaning Shifts S", "background": "", "description": "John’s cows have been spoiled since childhood, and they cannot tolerate any dirt in the barn. John finds that, to satisfy these clean-freak cows, he has to hire some of them to clean the barn. Among John’s cows, there are $ N(1 \\leq N \\leq 10000) $ cows who are willing to earn some pocket money by cleaning.\n\nDuring a certain time period, the cows will litter in the barn at any time and anywhere. Naturally, they require that, throughout this period, at least one cow must be cleaning at all times. The required cleaning period starts at the $ M $-th second of a day and ends at the $ E $-th second $ (0 \\leq M \\leq E \\leq 86399) $. Note that “seconds” here refer to time intervals rather than time points. In other words, the total time that must be covered each day is $ E - M + 1 $ seconds.\n\nJohn has obtained from each cow the work schedule she is willing to accept: for a given cow, she is willing to work every day during the interval from the $ T_1 $-th second to the $ T_2 $-th second $ (M \\leq T_1 \\leq T_2 \\leq E) $, and she asks for a payment of $ S $ dollars $ (0 \\leq S \\leq 500000) $. As with the required cleaning period, if a cow is willing to work from the 10-th to the 20-th second each day, then her total working time is 11 seconds, not 10 seconds.\n\nOnce John decides to hire a cow, he must pay her the full wage. He cannot hire her for only part of her available time and then pay a fraction based on how much of her available time she actually worked. Please help John decide which cows to hire to keep the barn clean. Of course, while keeping the cows satisfied, John wants the total cost to be as small as possible.", "inputFormat": "Line 1: Three positive integers $ N, M, E $.\n\nLines 2 to $ N + 1 $: Line $ i + 1 $ gives the work schedule of cow $ i $, i.e. three positive integers $ T_1, T_2, S $.", "outputFormat": "Output one integer, the minimum total cost John needs to pay for cleaning the barn. If it is impossible to complete the cleaning, output $ -1 $.", "hint": "John has 3 cows, and the barn needs to be cleaned from the 0-th second to the 4-th second. John can hire the first two cows and complete a whole day of cleaning with only 5 dollars.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO05DEC] Cleaning Shifts S", "background": "", "description": "约翰的奶牛们从小娇生惯养，她们无法容忍牛棚里的任何脏东西。约翰发现，如果要使这群有洁癖的奶牛满意，他不得不雇佣她们中的一些来清扫牛棚，约翰的奶牛中有 $ N(1 \\leq N \\leq 10000) $ 头愿意通过清扫牛棚来挣一些零花钱。\n\n由于在某个时段中奶牛们会在牛棚里随时随地地乱扔垃圾，自然地，她们要求在这段时间里，无论什么时候至少要有一头奶牛正在打扫。需要打扫的时段从某一天的第 $ M $ 秒开始，到第 $ E $ 秒结束 $ (0 \\leq M \\leq E \\leq 86399) $。注意这里的秒是指时间段而不是时间点，也就是说，每天需要打扫的总时间是 $ E-M+1 $ 秒。\n\n约翰已经从每头牛那里得到了她们愿意接受的工作计划：对于某一头牛，她每天都愿意在笫 $ T_1 \\ldots T_2 $ 秒的时间段内工作 $ (M \\leq T_1 \\leq T_2 \\leq E) $ ，所要求的报酬是 $ S $ 美元 $ (0 \\leq S \\leq 500000) $。与需打扫时段的描述一样，如果一头奶牛愿意工作的时段是每天的第 $ 10 \\ldots 20 $ 秒，那她总共工作的时间是 $ 11 $ 秒，而不是 $ 10 $ 秒。\n\n约翰一旦决定雇佣某一头奶牛，就必须付给她全额的工资，而不能只让她工作一段时间，然后再按这段时间在她愿意工作的总时间中所占的百分比来决定她的工资。现在请你帮约翰决定该雇佣哪些奶牛以保持牛棚的清洁，当然，在能让奶牛们满意的前提下，约翰希望使总花费尽量小。", "inputFormat": "第 $ 1 $ 行： $ 3 $ 个正整数 $ N,M,E $ 。\n\n第 $ 2 $ 到 $ N+1 $ 行：第 $ i+1 $ 行给出了编号为 $ i $ 的奶牛的工作计划，即 $ 3 $ 个正整数 $ T_1,T_2,S $ 。", "outputFormat": "输出一个整数，表示约翰需要为牛棚清理工作支付的最少费用。如果清理工作不可能完成，那么输出 $ -1 $ 。", "hint": "约翰有 $ 3 $ 头牛，牛棚在第 $ 0 $ 秒到第 $ 4 $ 秒之间需要打扫。 约翰雇佣前两头牛清扫牛棚，可以只花 $ 5 $ 美元就完成一整天的清扫。\n", "locale": "zh-CN"}}}
{"pid": "P4645", "type": "P", "difficulty": 4, "samples": [["6 7\n1 3\n1 4\n3 2\n4 2\n5 6\n6 5\n3 4", "3"], ["6 8\n1 3\n1 4\n3 2\n4 2\n5 6\n6 5\n3 4\n4 3", "inf"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2006", "广度优先搜索 BFS", "强连通分量", "COCI（克罗地亚）"], "title": "[COCI 2006/2007 #3] BICIKLI", "background": "一场自行车比赛将要在一个遥远的地方上举行。", "description": "这个地方有 $n$ 个城镇，从 $1\\sim n$ 编号，其中有 $m$ 条**单向**道路连接它们。比赛将在 $1$ 号城镇开始并在 $2$ 号城镇结束。\n\n主办方想知道，一共有多少条不同的路线？", "inputFormat": "输入第一行为两个整数 $n,m$，意义如题目描述所示。\n\n接下来的 $m$ 行，每行两个整数 $a,b$，描述一条从 $a$ 到 $b$ 的道路。\n\n两个城镇间可以有多条道路。", "outputFormat": "输出不同的路线的数量。\n\n如果有无数条不同的路线，则输出 `inf`。\n\n否则输出路线数对 $10^9$ 取模的结果。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1\\le n\\leq 5\\times 10 ^ 4$，$1\\leq m\\le 10^5$。\n\n#### 说明\n\n**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #3](https://hsin.hr/coci/archive/2006_2007/contest3_tasks.pdf) *T5 BICIKLI***\n\n感谢 @[ShineEternal](https://www.luogu.com.cn/user/45475) 提供的翻译。", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2006/2007 #3] BICIKLI", "background": "A bicycle race is going to be held in a remote place.", "description": "There are $n$ towns in this place, numbered from $1$ to $n$, and there are $m$ **directed** roads connecting them. The race starts in town $1$ and ends in town $2$.\n\nThe organizers want to know how many different routes there are in total.", "inputFormat": "The first line contains two integers $n, m$, with the meanings described above.\n\nThe next $m$ lines each contain two integers $a, b$, describing a road from $a$ to $b$.\n\nThere may be multiple roads between two towns.", "outputFormat": "Output the number of different routes.\n\nIf there are infinitely many different routes, output `inf`.\n\nOtherwise, output the result modulo $10^9$.", "hint": "#### Constraints\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 5 \\times 10^4$, $1 \\le m \\le 10^5$.\n\n#### Notes\n\n**Translated from [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #3](https://hsin.hr/coci/archive/2006_2007/contest3_tasks.pdf) *T5 BICIKLI*.**\n\nThanks to @[ShineEternal](https://www.luogu.com.cn/user/45475) for providing the translation.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #3] BICIKLI", "background": "一场自行车比赛将要在一个遥远的地方上举行。", "description": "这个地方有 $n$ 个城镇，从 $1\\sim n$ 编号，其中有 $m$ 条**单向**道路连接它们。比赛将在 $1$ 号城镇开始并在 $2$ 号城镇结束。\n\n主办方想知道，一共有多少条不同的路线？", "inputFormat": "输入第一行为两个整数 $n,m$，意义如题目描述所示。\n\n接下来的 $m$ 行，每行两个整数 $a,b$，描述一条从 $a$ 到 $b$ 的道路。\n\n两个城镇间可以有多条道路。", "outputFormat": "输出不同的路线的数量。\n\n如果有无数条不同的路线，则输出 `inf`。\n\n否则输出路线数对 $10^9$ 取模的结果。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1\\le n\\leq 5\\times 10 ^ 4$，$1\\leq m\\le 10^5$。\n\n#### 说明\n\n**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #3](https://hsin.hr/coci/archive/2006_2007/contest3_tasks.pdf) *T5 BICIKLI***\n\n感谢 @[ShineEternal](https://www.luogu.com.cn/user/45475) 提供的翻译。", "locale": "zh-CN"}}}
{"pid": "P4646", "type": "P", "difficulty": 6, "samples": [["15 \n1 1 \n8 1 \n4 2 \n7 2 \n2 3 \n4 3 \n6 3 \n2 5 \n4 5 \n6 5 \n4 6 \n7 6 \n1 8 \n4 8 \n8 8 \n17 \n1 2 \n2 15 \n15 14 \n14 13 \n13 1 \n14 11 \n11 12 \n12 4 \n4 3 \n3 6 \n6 5 \n5 8 \n8 9 \n9 11 \n9 10 \n10 7 \n7 6 ", "4 \n6 \n15 \n16 \n17 "]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2007", "IOI", "Special Judge"], "title": "[IOI 2007] flood 洪水", "background": "", "description": "1964年的一场灾难性的洪水冲毁了萨格勒布城。洪水袭来时许多建筑的墙被彻底冲毁。在这个题目中，给定了城市在洪水来袭前的简化模型，你的任务是确定洪水过后哪些墙没有被冲毁。\n\n简化模型由平面上的$N$个点和$W$堵墙构成。每堵墙连接两个点，没有任何一堵墙通过其它点。模型具有如下性质：\n\n- 不存在两堵墙相交或者重合的情况，但是两堵墙可以在端点相连；\n- 每堵墙或者平行于坐标系的横轴，或者平行于坐标系的纵轴。\n\n最开始，整个坐标平面都是干的。在零时刻，洪水将城市的外围淹没（城市的外围是指没有被墙围起来的区域）。一个小时之后，所有一边是水，一边是空气的墙在水的压力下都会倒塌。于是洪水又会吞没那些没有被完好的墙围住的区域。接下来又有一些墙面临一边是水一边是空气，将要被洪水冲毁的局面。又过了一个小时，这些墙也被冲毁了。这样的过程不断重复，直到洪水淹没整个城市。\n\n下图给出了洪水侵袭过程的一个例子。\n\n![](https://cdn.luogu.com.cn/upload/pic/20664.png )\n\n给定$N$个点的坐标和连接这些点的$W$堵墙的描述，编程确定洪水过后，哪些墙会被留下来。 ", "inputFormat": "输入的第一行包含一个整数$N(2 \\leq N \\leq 100 000)$, 表示平面上的点的个数。 接下来的$N$行每行包含两个整数$X$和$Y$（都是$0$到$1 000 000$之间（包括$0$和$1 000 000$）的整数），表示点的坐标。所有点按照它们被给出的顺序编号为$1$到$N$。没有两个点在同一位置上。 接下来一行包含一个整数$W(1 \\leq W \\leq 2N)$，表示墙的数目。 接下来$W$行每行包含两个不同的整数$A$和$B(1 \\leq A \\leq N, 1 \\leq B \\leq N)$，表示在洪水到来前，有一堵墙连接$A$和$B$。这些墙按照它们被给出的顺序编号为$1$到$W$。", "outputFormat": "输出的第一行包含一个整数$K$，表示洪水过后留下的墙的数目。\n\n接下来的$K$行包含留下的墙的序号，每行一个，序号可以以任意顺序输出。", "hint": "这个样例对应前页图中的例子。\n\n有40分的测试点，所有坐标小于等于$500$。\n\n在上面的测试点和另外15分的测试点中，点的个数不超过$500$个。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2007] flood Flood", "background": "", "description": "A catastrophic flood in 1964 destroyed the city of Zagreb. When the flood arrived, the walls of many buildings were completely destroyed. In this problem, you are given a simplified model of the city before the flood, and your task is to determine which walls were not destroyed after the flood.\n\nThe simplified model consists of $N$ points on the plane and $W$ walls. Each wall connects two points, and no wall passes through any other point. The model has the following properties:\n\n- No two walls intersect or overlap, but two walls may share an endpoint.\n- Each wall is either parallel to the $x$-axis or parallel to the $y$-axis.\n\nAt the beginning, the entire coordinate plane is dry. At time $0$, the flood inundates the outside of the city (the outside means the region not enclosed by walls). After one hour, every wall that has water on one side and air on the other side will collapse due to the water pressure. Then the flood will inundate those regions that are not enclosed by intact walls. Next, some walls again have water on one side and air on the other and are about to be destroyed. After another hour, these walls also collapse. This process repeats until the flood inundates the whole city.\n\nThe figure below shows an example of the flooding process.\n\n![](https://cdn.luogu.com.cn/upload/pic/20664.png )\n\nGiven the coordinates of the $N$ points and the descriptions of the $W$ walls connecting these points, write a program to determine which walls remain after the flood.", "inputFormat": "The first line contains an integer $N(2 \\leq N \\leq 100 000)$, the number of points on the plane. The next $N$ lines each contain two integers $X$ and $Y$ (both integers between $0$ and $1 000 000$ (inclusive)), giving the coordinates of a point. All points are numbered from $1$ to $N$ in the order they are given. No two points share the same position. The next line contains an integer $W(1 \\leq W \\leq 2N)$, the number of walls. The next $W$ lines each contain two different integers $A$ and $B(1 \\leq A \\leq N, 1 \\leq B \\leq N)$, meaning that before the flood there is a wall connecting $A$ and $B$. These walls are numbered from $1$ to $W$ in the order they are given.", "outputFormat": "The first line contains an integer $K$, the number of walls that remain after the flood.\n\nThe next $K$ lines contain the indices of the remaining walls, one per line. The indices may be output in any order.", "hint": "This sample corresponds to the example in the figure on the previous page.\n\nFor $40$ points of testdata, all coordinates are at most $500$.\n\nIn the above testdata and another $15$ points of testdata, the number of points does not exceed $500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2007] flood 洪水", "background": "", "description": "1964年的一场灾难性的洪水冲毁了萨格勒布城。洪水袭来时许多建筑的墙被彻底冲毁。在这个题目中，给定了城市在洪水来袭前的简化模型，你的任务是确定洪水过后哪些墙没有被冲毁。\n\n简化模型由平面上的$N$个点和$W$堵墙构成。每堵墙连接两个点，没有任何一堵墙通过其它点。模型具有如下性质：\n\n- 不存在两堵墙相交或者重合的情况，但是两堵墙可以在端点相连；\n- 每堵墙或者平行于坐标系的横轴，或者平行于坐标系的纵轴。\n\n最开始，整个坐标平面都是干的。在零时刻，洪水将城市的外围淹没（城市的外围是指没有被墙围起来的区域）。一个小时之后，所有一边是水，一边是空气的墙在水的压力下都会倒塌。于是洪水又会吞没那些没有被完好的墙围住的区域。接下来又有一些墙面临一边是水一边是空气，将要被洪水冲毁的局面。又过了一个小时，这些墙也被冲毁了。这样的过程不断重复，直到洪水淹没整个城市。\n\n下图给出了洪水侵袭过程的一个例子。\n\n![](https://cdn.luogu.com.cn/upload/pic/20664.png )\n\n给定$N$个点的坐标和连接这些点的$W$堵墙的描述，编程确定洪水过后，哪些墙会被留下来。 ", "inputFormat": "输入的第一行包含一个整数$N(2 \\leq N \\leq 100 000)$, 表示平面上的点的个数。 接下来的$N$行每行包含两个整数$X$和$Y$（都是$0$到$1 000 000$之间（包括$0$和$1 000 000$）的整数），表示点的坐标。所有点按照它们被给出的顺序编号为$1$到$N$。没有两个点在同一位置上。 接下来一行包含一个整数$W(1 \\leq W \\leq 2N)$，表示墙的数目。 接下来$W$行每行包含两个不同的整数$A$和$B(1 \\leq A \\leq N, 1 \\leq B \\leq N)$，表示在洪水到来前，有一堵墙连接$A$和$B$。这些墙按照它们被给出的顺序编号为$1$到$W$。", "outputFormat": "输出的第一行包含一个整数$K$，表示洪水过后留下的墙的数目。\n\n接下来的$K$行包含留下的墙的序号，每行一个，序号可以以任意顺序输出。", "hint": "这个样例对应前页图中的例子。\n\n有40分的测试点，所有坐标小于等于$500$。\n\n在上面的测试点和另外15分的测试点中，点的个数不超过$500$个。", "locale": "zh-CN"}}}
{"pid": "P4647", "type": "P", "difficulty": 6, "samples": [["6 \n3 2 \n5 3 \n4 1 \n2 1 \n4 3 \n3 2 ", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2007", "IOI"], "title": "[IOI 2007] sails 船帆", "background": "", "description": "让我们来建造一艘新的海盗船。船上有 N个旗杆，每根旗杆被分成单位长度的小节。旗杆的长度等于它被分成的小节的数目。每根旗杆上会挂一些帆，每张帆正好占据旗杆上的一个小节。在一根旗杆上的帆可以任意排布在不同的小节中，但是每个小节上至多能挂一张帆。\n\n在风中，帆的不同排布方式会产生不同的推动力。靠近船头的帆比它后面的相同高度上的帆获得的推动力少，换句话说，靠近船头的帆的推动力由于受它后面相同高度的帆的影响而打了折扣。对于任意一张帆，它的推动力折扣等于在它后面并且和它在同一高度的帆的数目。\n\n所有帆的任意一种位置组合的推动力折扣总和等于在该位置下所有帆的推动力折扣的总和。\n\n![](https://cdn.luogu.com.cn/upload/pic/20670.png )\n\n这条船上有6个旗杆，从前（图上的左边）到后的高度分别是3，5，4，2，4和3。图中所示的帆的位置组合的总推动力折扣是10。上图给出了每张帆自己的推动力折扣。\n\n给定N个旗杆的高度和每个旗杆上挂的帆的数目，写一个程序求出所有位置组合中的可能达到的最小的总推动力折扣。 ", "inputFormat": "第一行包含一个整数$N(2 \\leq N \\leq 100 000)$，表示旗杆的数目。 接下来的N行每行包含两个整数$H$和$K(1 \\leq H \\leq 100 000, 1 \\leq K \\leq H)$，分别表示对应旗杆的高度及其上的帆的数目。旗杆按照从船头到船尾的顺序给出。 ", "outputFormat": "输出包含一个整数，表示可以达到的最小的总推动力折扣。\n\n注意：计算和输出结果时使用64位整数类型（在C/C++中用```long long```, 在Pascal中用```int64```）。", "hint": "这个样例数据和上页中图示的样例相同。\n\n在 25 分的测试数据中，帆的不同位置组合的总数目不超过 $1,000,000$ 。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2007] sails Sails", "background": "", "description": "Let us build a new pirate ship. There are $N$ masts on the ship. Each mast is divided into unit-length sections. The length of a mast equals the number of sections it is divided into. Some sails are hung on each mast, and each sail occupies exactly one section of the mast. On a single mast, the sails can be arranged arbitrarily among different sections, but each section can have at most one sail.\n\nIn the wind, different arrangements of sails produce different propulsive forces. A sail closer to the bow produces less propulsive force than a sail behind it at the same height. In other words, the propulsive force of a sail closer to the bow is discounted because of the sails behind it at the same height. For any sail, its propulsive force discount equals the number of sails that are behind it and at the same height.\n\nThe total propulsive force discount of an arrangement equals the sum of the propulsive force discounts of all sails under that arrangement.\n\n![](https://cdn.luogu.com.cn/upload/pic/20670.png )\n\nThis ship has 6 masts. From front (left in the figure) to back, their heights are 3, 5, 4, 2, 4, and 3. The total propulsive force discount of the sail arrangement shown in the figure is 10. The figure also gives the propulsive force discount of each individual sail.\n\nGiven the heights of the $N$ masts and the number of sails hung on each mast, write a program to find the minimum possible total propulsive force discount among all arrangements.", "inputFormat": "The first line contains an integer $N(2 \\leq N \\leq 100 000)$, the number of masts. The next $N$ lines each contain two integers $H$ and $K(1 \\leq H \\leq 100 000, 1 \\leq K \\leq H)$, representing the height of the corresponding mast and the number of sails on it. The masts are given in order from the bow to the stern.", "outputFormat": "Output one integer, the minimum total propulsive force discount that can be achieved.\n\nNote: Use a 64-bit integer type when computing and outputting the result (```long long``` in C/C++, ```int64``` in Pascal).", "hint": "This sample testdata is the same as the sample shown in the figure on the previous page.\n\nIn the testdata worth 25 points, the total number of different sail arrangements does not exceed $1,000,000$ .\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2007] sails 船帆", "background": "", "description": "让我们来建造一艘新的海盗船。船上有 N个旗杆，每根旗杆被分成单位长度的小节。旗杆的长度等于它被分成的小节的数目。每根旗杆上会挂一些帆，每张帆正好占据旗杆上的一个小节。在一根旗杆上的帆可以任意排布在不同的小节中，但是每个小节上至多能挂一张帆。\n\n在风中，帆的不同排布方式会产生不同的推动力。靠近船头的帆比它后面的相同高度上的帆获得的推动力少，换句话说，靠近船头的帆的推动力由于受它后面相同高度的帆的影响而打了折扣。对于任意一张帆，它的推动力折扣等于在它后面并且和它在同一高度的帆的数目。\n\n所有帆的任意一种位置组合的推动力折扣总和等于在该位置下所有帆的推动力折扣的总和。\n\n![](https://cdn.luogu.com.cn/upload/pic/20670.png )\n\n这条船上有6个旗杆，从前（图上的左边）到后的高度分别是3，5，4，2，4和3。图中所示的帆的位置组合的总推动力折扣是10。上图给出了每张帆自己的推动力折扣。\n\n给定N个旗杆的高度和每个旗杆上挂的帆的数目，写一个程序求出所有位置组合中的可能达到的最小的总推动力折扣。 ", "inputFormat": "第一行包含一个整数$N(2 \\leq N \\leq 100 000)$，表示旗杆的数目。 接下来的N行每行包含两个整数$H$和$K(1 \\leq H \\leq 100 000, 1 \\leq K \\leq H)$，分别表示对应旗杆的高度及其上的帆的数目。旗杆按照从船头到船尾的顺序给出。 ", "outputFormat": "输出包含一个整数，表示可以达到的最小的总推动力折扣。\n\n注意：计算和输出结果时使用64位整数类型（在C/C++中用```long long```, 在Pascal中用```int64```）。", "hint": "这个样例数据和上页中图示的样例相同。\n\n在 25 分的测试数据中，帆的不同位置组合的总数目不超过 $1,000,000$ 。", "locale": "zh-CN"}}}
{"pid": "P4648", "type": "P", "difficulty": 6, "samples": [["1 6 5 100 \n25 \n50 \n50 \n10 \n20 \n23 ", "4"], ["2 5 4 10 \n5 2 \n7 2 \n8 4 \n6 5 \n4 4 ", "8"], ["3 8 10 20 \n10 10 10 \n10 10 20 \n10 20 10 \n10 20 20 \n20 10 10 \n20 10 20 \n20 20 10 \n20 20 20 ", "12"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000]}, "tags": ["2007", "树状数组", "IOI", "枚举", "前缀和"], "title": "[IOI 2007] pairs 动物对数", "background": "", "description": "Mirko 和 Slavko 正在玩动物玩具的游戏。 首先，他们要在下图给出的三种玩具模板中选择一种。三种模板分别由一维、二维和三维的网格点（在图中用圆圈表示）组成。 \n\n![](https://cdn.luogu.com.cn/upload/pic/20672.png )\n\n接下来Mirko 把 $N$ 个小动物玩具放到选中的模板的网格点上。\n\n动物玩具可以走一步到达与它相邻的网格点上（在图中相邻的点之间有一条小短线相连）。两个网格点之间的距离定义为**从一个网格点到另一个网格点所需要移动的最小步数**。\n\n如果两个动物之间的距离小于等于$D$，则它们之间可以互相听见。Slavko 的任务是计算在模板上有多少对动物可以互相听得见。\n\n给定模板的类型、所有动物的位置以及数字$D$，写一个程序计算有多少对动物可以互相听得见。 ", "inputFormat": "输入的第一行按顺序给出四个整数： \n- 模板类型 $B (1 \\leq B \\leq 3)$; \n- 玩具动物的数目 $N (1 \\leq N \\leq 100 000)$; \n- 动物之间可以互相听得见的最大距离$D (1 \\leq D \\leq 100 000 000)$; \n- 模板的大小 $M$ ( 即在输入中允许的最大的坐标值):  当 $B=1$ 时, $M$ 最大是 $75 000 000$. 当 $B=2$时, $M$ 最大是 $75 000$. 当 $B=3$时, $M$ 最大是 $75$.\n\n接下来的$N$ 行每行包含$B$ 个整数，整数之间用空格隔开，表示一个动物玩具的坐标。坐标的取值范围是$1$ 到 $M$ ( 包括$M$ )。\n\n每个网格点可以同时包含多个动物玩具。 ", "outputFormat": "输出应该包括一个整数，表示可以互相听得见的玩具动物的对数。\n\n注意：使用64 位整数类型计算和输出结果 (在 C/C++ 中用```long long```, 在Pascal 中用```int64``` ) 。 ", "hint": "在30分的测试数据中, 动物数目 $N$ 最多是 $1 000$。\n\n如果成功通过了某一种模板（一维、二维或者三维）的全部测试数据，将会得到至少30分。\n\n对于input 1的解释： 假设动物按给出的顺序编号为$1$到$6$。$4$对互相能够听得到的动物分别是:\n- 1-5 ( 距离是5)\n- 1-6 ( 距离是2)\n- 2-3 ( 距离是0)\n- 5-6 ( 距离是3)\n\n对于input 2 的解释：$8$对动物分别是:\n- 1-2 ( 距离是2)\n- 1-4 ( 距离是4)\n- 1-5 ( 距离是3)\n- 2-3 ( 距离是3)\n- 2-4 ( 距离是4)\n- 3-4 ( 距离是3)\n- 3-5 ( 距离是4)\n- 4-5 ( 距离是3)", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2007] pairs Animal Pairs Count.", "background": "", "description": "Mirko and Slavko are playing a game with animal toys. First, they choose one of the three toy templates shown in the figure below. The three templates are made of 1D, 2D, and 3D grid points (shown as circles in the figure).\n\n![](https://cdn.luogu.com.cn/upload/pic/20672.png )\n\nNext, Mirko places $N$ small animal toys onto the grid points of the chosen template.\n\nAn animal toy can move one step to a grid point adjacent to it (in the figure, adjacent points are connected by a short line). The distance between two grid points is defined as **the minimum number of steps needed to move from one grid point to the other**.\n\nIf the distance between two animals is less than or equal to $D$, then they can hear each other. Slavko’s task is to count how many pairs of animals on the template can hear each other.\n\nGiven the template type, the positions of all animals, and the number $D$, write a program to compute how many pairs of animal toys can hear each other.", "inputFormat": "The first line of input contains four integers in order:\n- Template type $B (1 \\leq B \\leq 3)$;\n- Number of animal toys $N (1 \\leq N \\leq 100 000)$;\n- Maximum distance at which two animals can hear each other $D (1 \\leq D \\leq 100 000 000)$;\n- Template size $M$ (i.e., the maximum coordinate value allowed in the input): when $B=1$, the maximum $M$ is $75 000 000$; when $B=2$, the maximum $M$ is $75 000$; when $B=3$, the maximum $M$ is $75$.\n\nThe next $N$ lines each contain $B$ integers separated by spaces, representing the coordinates of an animal toy. Each coordinate ranges from $1$ to $M$ (including $M$).\n\nEach grid point may contain multiple animal toys at the same time.", "outputFormat": "Output one integer, the number of pairs of animal toys that can hear each other.\n\nNote: use a 64-bit integer type to compute and output the result (use ```long long``` in C/C++, and ```int64``` in Pascal).", "hint": "In the testdata worth 30 points, the number of animals $N$ is at most $1 000$.\n\nIf you pass all testdata for any one template type (1D, 2D, or 3D), you will get at least 30 points.\n\nExplanation for input 1: Suppose the animals are numbered from $1$ to $6$ in the given order. The $4$ pairs of animals that can hear each other are:\n- 1-5 (distance is 5)\n- 1-6 (distance is 2)\n- 2-3 (distance is 0)\n- 5-6 (distance is 3)\n\nExplanation for input 2: The $8$ pairs of animals are:\n- 1-2 (distance is 2)\n- 1-4 (distance is 4)\n- 1-5 (distance is 3)\n- 2-3 (distance is 3)\n- 2-4 (distance is 4)\n- 3-4 (distance is 3)\n- 3-5 (distance is 4)\n- 4-5 (distance is 3)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2007] pairs 动物对数", "background": "", "description": "Mirko 和 Slavko 正在玩动物玩具的游戏。 首先，他们要在下图给出的三种玩具模板中选择一种。三种模板分别由一维、二维和三维的网格点（在图中用圆圈表示）组成。 \n\n![](https://cdn.luogu.com.cn/upload/pic/20672.png )\n\n接下来Mirko 把 $N$ 个小动物玩具放到选中的模板的网格点上。\n\n动物玩具可以走一步到达与它相邻的网格点上（在图中相邻的点之间有一条小短线相连）。两个网格点之间的距离定义为**从一个网格点到另一个网格点所需要移动的最小步数**。\n\n如果两个动物之间的距离小于等于$D$，则它们之间可以互相听见。Slavko 的任务是计算在模板上有多少对动物可以互相听得见。\n\n给定模板的类型、所有动物的位置以及数字$D$，写一个程序计算有多少对动物可以互相听得见。 ", "inputFormat": "输入的第一行按顺序给出四个整数： \n- 模板类型 $B (1 \\leq B \\leq 3)$; \n- 玩具动物的数目 $N (1 \\leq N \\leq 100 000)$; \n- 动物之间可以互相听得见的最大距离$D (1 \\leq D \\leq 100 000 000)$; \n- 模板的大小 $M$ ( 即在输入中允许的最大的坐标值):  当 $B=1$ 时, $M$ 最大是 $75 000 000$. 当 $B=2$时, $M$ 最大是 $75 000$. 当 $B=3$时, $M$ 最大是 $75$.\n\n接下来的$N$ 行每行包含$B$ 个整数，整数之间用空格隔开，表示一个动物玩具的坐标。坐标的取值范围是$1$ 到 $M$ ( 包括$M$ )。\n\n每个网格点可以同时包含多个动物玩具。 ", "outputFormat": "输出应该包括一个整数，表示可以互相听得见的玩具动物的对数。\n\n注意：使用64 位整数类型计算和输出结果 (在 C/C++ 中用```long long```, 在Pascal 中用```int64``` ) 。 ", "hint": "在30分的测试数据中, 动物数目 $N$ 最多是 $1 000$。\n\n如果成功通过了某一种模板（一维、二维或者三维）的全部测试数据，将会得到至少30分。\n\n对于input 1的解释： 假设动物按给出的顺序编号为$1$到$6$。$4$对互相能够听得到的动物分别是:\n- 1-5 ( 距离是5)\n- 1-6 ( 距离是2)\n- 2-3 ( 距离是0)\n- 5-6 ( 距离是3)\n\n对于input 2 的解释：$8$对动物分别是:\n- 1-2 ( 距离是2)\n- 1-4 ( 距离是4)\n- 1-5 ( 距离是3)\n- 2-3 ( 距离是3)\n- 2-4 ( 距离是4)\n- 3-4 ( 距离是3)\n- 3-5 ( 距离是4)\n- 4-5 ( 距离是3)", "locale": "zh-CN"}}}
{"pid": "P4649", "type": "P", "difficulty": 6, "samples": [["5 8 \n2 1 0 \n3 2 0 \n4 3 0 \n5 4 0 \n1 3 2 \n3 5 2 \n2 4 5 \n2 5 1 ", "5"], ["9 14 \n1 2 0 \n1 3 0 \n2 3 14 \n2 6 15 \n3 4 0 \n3 5 0 \n3 6 12 \n3 7 13 \n4 6 10 \n5 6 0 \n5 7 0 \n5 8 0 \n6 9 11 \n8 9 0 ", "48"]], "limits": {"time": [300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["动态规划 DP", "2007", "IOI", "树形 DP", "仙人掌", "最近公共祖先 LCA", "状压 DP"], "title": "[IOI 2007] training 训练路径 ", "background": "", "description": "马克(Mirko)和斯拉夫克(Slavko)正在为克罗地亚举办的每年一次的双人骑车马拉松赛而紧张训练。他们需要选择一条训练路径。\n\n他们国家有$N$个城市和$M$条道路。每条道路连接两个城市。这些道路中恰好有$N-1$条是铺设好的道路，其余道路是未经铺设的土路。幸运的是，每两个城市之间都存在一条由铺设好的道路组成的通路。换句话说，这$N$个城市和$N-1$条铺设好的道路构成一个树状结构。\n\n此外，每个城市最多是$10$条道路的端点。\n\n一条训练路径由某个城市开始，途经一些道路后在原来起始的城市结束。因为马克和斯拉夫克喜欢去看新城市，所以他们制定了一条规则：绝不中途穿越已经去过的城市，并且绝不在相同的道路上骑行两次（不管方向是否相同）。训练路径可以从任何一个城市开始，并且不需要访问所有城市。\n\n显然，坐在后座的骑行者更为轻松，因为坐在前面的可以为他挡风。为此，马克和斯拉夫克在每个城市都要调换位置。为了保证他们的训练强度相同，他们要选择一条具有偶数条道路的路径。\n\n马克和斯拉夫克的竞争者决定在某些未经铺设的土路上设置路障，使得他们两人不可能找到满足上述要求的训练路径。已知在每条土路上设置路障都有一个费用值（一个正整数），并且竞争者不能在铺设好的道路上设置路障。\n\n给定城市和道路网的描述，写一个程序计算出为了使得满足上述要求的训练路径不存在，而需要的设置路障的最小总费用。", "inputFormat": "输入的第一行包含两个整数$N$和$M$，（$2\\leq N\\leq 1000$，$N-1\\leq M\\leq5000$），分别表示城市和道路的个数。 接下来的$M$行每行包含$3$个整数$A, B$和$C$（$1\\leq A\\leq N, 1\\leq B\\leq N, 0\\leq C\\leq10 000$）, 用来描述一条道路。$A$和$B$是不同的整数，表示由这条道路直接相连的两个城市。对于铺设好的道路$C$是$0$；对于土路，$C$是在该条路上设置路障所需的费用值。 每个城市最多是$10$条道路的端点。任意两个城市都不会有多于一条直接相连的道路。 ", "outputFormat": "输出包含一个整数，表示求出的最小总费用。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/20676.png )\n\n第一个样例中道路与城市的布置。已被铺设好的道路以粗边显示。\n\n![](https://cdn.luogu.com.cn/upload/pic/20677.png )\n\n共有5种可能的路线。如果边1-3、3-5和2-5被封锁，则两人将会不能使用5种路线的任何一种。封锁这三条边的代价是5。\n\n只封锁两条边，像是2-4和2-5，也是可以的，但这样会导致较高的代价，6。\n\n在前30分的测试数据中，铺设好的道路会形成一条链。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2007] training Training Route.", "background": "", "description": "Mirko and Slavko are training hard for the annual two-person cycling marathon held in Croatia. They need to choose a training route.\n\nTheir country has $N$ cities and $M$ roads. Each road connects two cities. Among these roads, exactly $N-1$ are paved roads, and the remaining roads are unpaved dirt roads. Luckily, for every pair of cities, there exists a path consisting only of paved roads. In other words, the $N$ cities and the $N-1$ paved roads form a tree.\n\nAlso, each city is an endpoint of at most $10$ roads.\n\nA training route starts from some city, goes through some roads, and ends at the same city where it started. Since Mirko and Slavko like to see new cities, they made a rule: they never pass through a city that they have already visited, and they never ride along the same road twice (no matter which direction). The training route can start from any city, and it does not need to visit all cities.\n\nObviously, the rider sitting in the back has it easier, because the rider in front blocks the wind. Therefore, Mirko and Slavko swap positions in every city. To make sure their training intensity is the same, they want to choose a route with an even number of roads.\n\nMirko and Slavko’s competitors decide to place roadblocks on some unpaved dirt roads, so that the two of them cannot find any training route that satisfies the requirements above. It is known that placing a roadblock on each dirt road has a cost (a positive integer), and the competitors cannot place roadblocks on paved roads.\n\nGiven the description of the cities and roads, write a program to compute the minimum total cost of placing roadblocks so that no training route satisfying the requirements above exists.", "inputFormat": "The first line contains two integers $N$ and $M$ ($2\\leq N\\leq 1000$, $N-1\\leq M\\leq5000$), the numbers of cities and roads. The next $M$ lines each contain three integers $A, B$ and $C$ ($1\\leq A\\leq N, 1\\leq B\\leq N, 0\\leq C\\leq10 000$), describing a road. $A$ and $B$ are different integers and represent the two cities directly connected by this road. For a paved road, $C$ is $0$; for a dirt road, $C$ is the cost to place a roadblock on this road. Each city is an endpoint of at most $10$ roads. There is at most one road directly connecting any pair of cities.", "outputFormat": "Output one integer, the minimum total cost.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/20676.png )\n\nThe layout of roads and cities in the first sample. Paved roads are shown with thick edges.\n\n![](https://cdn.luogu.com.cn/upload/pic/20677.png )\n\nThere are 5 possible routes in total. If edges 1-3, 3-5, and 2-5 are blocked, then they cannot use any of the 5 routes. The cost of blocking these three edges is 5.\n\nBlocking only two edges, such as 2-4 and 2-5, is also possible, but it leads to a higher cost, 6.\n\nIn the first 30 points of testdata, the paved roads form a chain.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2007] training 训练路径 ", "background": "", "description": "马克(Mirko)和斯拉夫克(Slavko)正在为克罗地亚举办的每年一次的双人骑车马拉松赛而紧张训练。他们需要选择一条训练路径。\n\n他们国家有$N$个城市和$M$条道路。每条道路连接两个城市。这些道路中恰好有$N-1$条是铺设好的道路，其余道路是未经铺设的土路。幸运的是，每两个城市之间都存在一条由铺设好的道路组成的通路。换句话说，这$N$个城市和$N-1$条铺设好的道路构成一个树状结构。\n\n此外，每个城市最多是$10$条道路的端点。\n\n一条训练路径由某个城市开始，途经一些道路后在原来起始的城市结束。因为马克和斯拉夫克喜欢去看新城市，所以他们制定了一条规则：绝不中途穿越已经去过的城市，并且绝不在相同的道路上骑行两次（不管方向是否相同）。训练路径可以从任何一个城市开始，并且不需要访问所有城市。\n\n显然，坐在后座的骑行者更为轻松，因为坐在前面的可以为他挡风。为此，马克和斯拉夫克在每个城市都要调换位置。为了保证他们的训练强度相同，他们要选择一条具有偶数条道路的路径。\n\n马克和斯拉夫克的竞争者决定在某些未经铺设的土路上设置路障，使得他们两人不可能找到满足上述要求的训练路径。已知在每条土路上设置路障都有一个费用值（一个正整数），并且竞争者不能在铺设好的道路上设置路障。\n\n给定城市和道路网的描述，写一个程序计算出为了使得满足上述要求的训练路径不存在，而需要的设置路障的最小总费用。", "inputFormat": "输入的第一行包含两个整数$N$和$M$，（$2\\leq N\\leq 1000$，$N-1\\leq M\\leq5000$），分别表示城市和道路的个数。 接下来的$M$行每行包含$3$个整数$A, B$和$C$（$1\\leq A\\leq N, 1\\leq B\\leq N, 0\\leq C\\leq10 000$）, 用来描述一条道路。$A$和$B$是不同的整数，表示由这条道路直接相连的两个城市。对于铺设好的道路$C$是$0$；对于土路，$C$是在该条路上设置路障所需的费用值。 每个城市最多是$10$条道路的端点。任意两个城市都不会有多于一条直接相连的道路。 ", "outputFormat": "输出包含一个整数，表示求出的最小总费用。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/20676.png )\n\n第一个样例中道路与城市的布置。已被铺设好的道路以粗边显示。\n\n![](https://cdn.luogu.com.cn/upload/pic/20677.png )\n\n共有5种可能的路线。如果边1-3、3-5和2-5被封锁，则两人将会不能使用5种路线的任何一种。封锁这三条边的代价是5。\n\n只封锁两条边，像是2-4和2-5，也是可以的，但这样会导致较高的代价，6。\n\n在前30分的测试数据中，铺设好的道路会形成一条链。", "locale": "zh-CN"}}}
{"pid": "P4650", "type": "P", "difficulty": 4, "samples": [["4 2\n1 2 2 3\n", "2 3 1 2"], ["5 3\n2 1 3 0 3\n", "3 3 0 1 2"], ["6 4\n0 2 5 2 0 1\n", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "Special Judge", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #5] Karte", "background": "", "description": "有$N$ 张牌叠在一起，第 $i$ 张牌上，有一个数字 $a_i$ 表示它下面**至少**有 $a_i$ 张牌上的信息是错误的，若它下面确实有至少 $a_i$ 张牌的信息是错误的，那这张牌的信息就是正确的，否则这张牌的信息就是错误的。（我们认为最下面的牌的后面有 $0$ 张错误的）\n\n现在需要你重新调整牌的顺序，使得正好有 $K$ 张牌上的信息是错误的。", "inputFormat": "第一行两个正整数 $N$ 和 $K$ $( 1 ≤ N≤ 5×10^5,0 ≤ K≤ N )$表示牌的张数和要求的错误信息的个数。\n接下来 $N$ 行，每行一个数，表示对应的 $a_i$ $(0 ≤ a_i≤ 5×10^5 )$", "outputFormat": "如果调整方案不存在，输出$-1$。否则输出由顶部到底部 $N$ 张牌对应的 $a_i$，若有多种方案，输出任意一种即可。", "hint": "$30\\%$的数据 $N≤ 16$。\n\n另有$40\\%$的数据 $N≤ 2000$。\n\n**样例 2 说明：**\n\n第 $5$ 张牌上写的是$2$，但是其后面只有 $0$ 张错误，所以它是错误的。\n\n第 $4$ 张牌上写的是$1$，其后面有 $1$ 张错误（第五张），所以它是正确的。\n\n第 $3$ 张牌上写的是$0$，其后面有 $1$ 张错误（第五张），所以它是正确的。\n\n第 $2$ 张牌上写的是$3$，但是其后面只有 $1$ 张错误（第五张），所以它是错误的。\n\n第 $1$ 张牌上写的是$3$，但是其后面只有 $2$ 张错误（第五张，第二张），所以它是错误的。\n\n因此总共有 $3$ 张是错误的。", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2017/2018 #5] Karte", "background": "", "description": "There are $N$ cards stacked together. On the $i$-th card, there is a number $a_i$, meaning that **at least** $a_i$ cards below it have incorrect information. If there are indeed at least $a_i$ cards below it with incorrect information, then the information on this card is correct; otherwise, the information on this card is incorrect. (We consider that below the bottom card there are $0$ incorrect cards.)\n\nNow you need to rearrange the order of the cards so that exactly $K$ cards have incorrect information.", "inputFormat": "The first line contains two positive integers $N$ and $K$ $(1 \\le N \\le 5 \\times 10^5, 0 \\le K \\le N)$, representing the number of cards and the required number of incorrect pieces of information.\n\nThe next $N$ lines each contain one number, representing the corresponding $a_i$ $(0 \\le a_i \\le 5 \\times 10^5)$.", "outputFormat": "If no rearrangement exists, output $-1$. Otherwise, output the $a_i$ of the $N$ cards from top to bottom. If there are multiple solutions, output any one.", "hint": "For $30\\%$ of the testdata, $N \\le 16$.\n\nFor another $40\\%$ of the testdata, $N \\le 2000$.\n\n**Explanation of Sample 2:**\n\nThe $5$-th card shows $2$, but there are only $0$ incorrect cards below it, so it is incorrect.\n\nThe $4$-th card shows $1$. There is $1$ incorrect card below it (the $5$-th), so it is correct.\n\nThe $3$-th card shows $0$. There is $1$ incorrect card below it (the $5$-th), so it is correct.\n\nThe $2$-th card shows $3$, but there is only $1$ incorrect card below it (the $5$-th), so it is incorrect.\n\nThe $1$-st card shows $3$, but there are only $2$ incorrect cards below it (the $5$-th and the $2$-nd), so it is incorrect.\n\nTherefore, there are $3$ incorrect cards in total.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #5] Karte", "background": "", "description": "有$N$ 张牌叠在一起，第 $i$ 张牌上，有一个数字 $a_i$ 表示它下面**至少**有 $a_i$ 张牌上的信息是错误的，若它下面确实有至少 $a_i$ 张牌的信息是错误的，那这张牌的信息就是正确的，否则这张牌的信息就是错误的。（我们认为最下面的牌的后面有 $0$ 张错误的）\n\n现在需要你重新调整牌的顺序，使得正好有 $K$ 张牌上的信息是错误的。", "inputFormat": "第一行两个正整数 $N$ 和 $K$ $( 1 ≤ N≤ 5×10^5,0 ≤ K≤ N )$表示牌的张数和要求的错误信息的个数。\n接下来 $N$ 行，每行一个数，表示对应的 $a_i$ $(0 ≤ a_i≤ 5×10^5 )$", "outputFormat": "如果调整方案不存在，输出$-1$。否则输出由顶部到底部 $N$ 张牌对应的 $a_i$，若有多种方案，输出任意一种即可。", "hint": "$30\\%$的数据 $N≤ 16$。\n\n另有$40\\%$的数据 $N≤ 2000$。\n\n**样例 2 说明：**\n\n第 $5$ 张牌上写的是$2$，但是其后面只有 $0$ 张错误，所以它是错误的。\n\n第 $4$ 张牌上写的是$1$，其后面有 $1$ 张错误（第五张），所以它是正确的。\n\n第 $3$ 张牌上写的是$0$，其后面有 $1$ 张错误（第五张），所以它是正确的。\n\n第 $2$ 张牌上写的是$3$，但是其后面只有 $1$ 张错误（第五张），所以它是错误的。\n\n第 $1$ 张牌上写的是$3$，但是其后面只有 $2$ 张错误（第五张，第二张），所以它是错误的。\n\n因此总共有 $3$ 张是错误的。", "locale": "zh-CN"}}}
{"pid": "P4651", "type": "P", "difficulty": 4, "samples": [["2 1\n0 0 2 1\nbb\nnwwnw\nbn", "6"], ["5 4\n0 2 5 2\nnnbnn\nnnnwwbwnnnn\nnbbbn\nnnwbwwbwwnn\nbwwww\nnnbwbbwwbnn\nnwwwn\nnnnnbwbbnnn\nnnwnn", "22"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2005", "最短路", "BalticOI（波罗的海）"], "title": "[BalticOI 2005] Maze (Day1)", "background": null, "description": "给出一个平行四边形的长与高。给出入口与出口，对于四边形的每条边都有三种可能：黑色、白色、无色。你要找出一条路径，走过的边黑白交替，且长度最短。", "inputFormat": "第一行给出平行四边形的长与高，且值在 $[1,500]$。\n\n第二行给出入口，出口坐标。\n\n下面的字符矩阵代表这个平行四边形每条边的颜色，`n` 表示无色，`w` 表示白色，`b` 表示黑色。", "outputFormat": "输出路径的最短长度。", "hint": "对于第一个数据:\n\n$(0, 0) \\rightarrow (1, 0) \\rightarrow (0, 1) \\rightarrow (1, 1) \\rightarrow (1, 0) \\rightarrow(2, 0) \\rightarrow (2, 1)$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a7qxcn67.png)  \n\n对于第二个数据:\n\n$(0, 2) \\rightarrow (1, 2) \\rightarrow (1, 1) \\rightarrow (2, 1) \\rightarrow (2, 0) \\rightarrow \\\\\n(3, 0) \\rightarrow (3, 1) \\rightarrow (3, 2) \\rightarrow (4, 1) \\rightarrow (3, 1) \\rightarrow \\\\\n(3, 0) \\rightarrow (2, 0) \\rightarrow (2, 1) \\rightarrow (1, 1) \\rightarrow (1, 2) \\rightarrow \\\\\n(1, 3) \\rightarrow (2, 3) \\rightarrow (2, 4) \\rightarrow (3, 4) \\rightarrow (3, 3) \\rightarrow \\\\\n(4, 3) \\rightarrow (4, 2) \\rightarrow (5, 2)$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8d0gue8n.png)", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2005] Maze (Day1)", "background": "", "description": "You are given the length and height of a parallelogram. You are also given the coordinates of the entrance and the exit. For each side (edge) of the quadrilateral, there are three possible states: black, white, or colorless. You need to find a shortest path such that the colors of the edges you traverse alternate between black and white.", "inputFormat": "The first line gives the length and height of the parallelogram, with values in $[1,500]$.\n\nThe second line gives the coordinates of the entrance and the exit.\n\nThe following character matrix represents the color of each edge of this parallelogram: `n` means colorless, `w` means white, and `b` means black.", "outputFormat": "Output the shortest length of the path.", "hint": "For the first testdata:\n\n$(0, 0) \\rightarrow (1, 0) \\rightarrow (0, 1) \\rightarrow (1, 1) \\rightarrow (1, 0) \\rightarrow(2, 0) \\rightarrow (2, 1)$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a7qxcn67.png)  \n\nFor the second testdata:\n\n$(0, 2) \\rightarrow (1, 2) \\rightarrow (1, 1) \\rightarrow (2, 1) \\rightarrow (2, 0) \\rightarrow \\\\\n(3, 0) \\rightarrow (3, 1) \\rightarrow (3, 2) \\rightarrow (4, 1) \\rightarrow (3, 1) \\rightarrow \\\\\n(3, 0) \\rightarrow (2, 0) \\rightarrow (2, 1) \\rightarrow (1, 1) \\rightarrow (1, 2) \\rightarrow \\\\\n(1, 3) \\rightarrow (2, 3) \\rightarrow (2, 4) \\rightarrow (3, 4) \\rightarrow (3, 3) \\rightarrow \\\\\n(4, 3) \\rightarrow (4, 2) \\rightarrow (5, 2)$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8d0gue8n.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2005] Maze (Day1)", "background": null, "description": "给出一个平行四边形的长与高。给出入口与出口，对于四边形的每条边都有三种可能：黑色、白色、无色。你要找出一条路径，走过的边黑白交替，且长度最短。", "inputFormat": "第一行给出平行四边形的长与高，且值在 $[1,500]$。\n\n第二行给出入口，出口坐标。\n\n下面的字符矩阵代表这个平行四边形每条边的颜色，`n` 表示无色，`w` 表示白色，`b` 表示黑色。", "outputFormat": "输出路径的最短长度。", "hint": "对于第一个数据:\n\n$(0, 0) \\rightarrow (1, 0) \\rightarrow (0, 1) \\rightarrow (1, 1) \\rightarrow (1, 0) \\rightarrow(2, 0) \\rightarrow (2, 1)$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a7qxcn67.png)  \n\n对于第二个数据:\n\n$(0, 2) \\rightarrow (1, 2) \\rightarrow (1, 1) \\rightarrow (2, 1) \\rightarrow (2, 0) \\rightarrow \\\\\n(3, 0) \\rightarrow (3, 1) \\rightarrow (3, 2) \\rightarrow (4, 1) \\rightarrow (3, 1) \\rightarrow \\\\\n(3, 0) \\rightarrow (2, 0) \\rightarrow (2, 1) \\rightarrow (1, 1) \\rightarrow (1, 2) \\rightarrow \\\\\n(1, 3) \\rightarrow (2, 3) \\rightarrow (2, 4) \\rightarrow (3, 4) \\rightarrow (3, 3) \\rightarrow \\\\\n(4, 3) \\rightarrow (4, 2) \\rightarrow (5, 2)$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8d0gue8n.png)", "locale": "zh-CN"}}}
{"pid": "P4652", "type": "P", "difficulty": 6, "samples": [["5 6\n1 2\n1 2\n4 3\n2 3\n1 3\n5 1\n2\n4 5\n1 3", "BBRBBL"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["图论", "2017", "CEOI（中欧）", "Tarjan", "双连通分量"], "title": "[CEOI 2017] One-Way Streets", "background": "", "description": "给定一张 $n$ 个点 $m$ 条边的无向图，现在想要把这张图定向。\n\n有 $p$ 个限制条件，每个条件形如 $(x_i,y_i)$，表示在新的有向图当中，$x_i$ 要能够沿着一些边走到 $y_i$​​。\n\n现在请你求出，每条边的方向是否能够唯一确定。同时请给出这些能够唯一确定的边的方向。\n\n数据保证有解。", "inputFormat": "第一行两个空格隔开的正整数 $n,m$ 。\n\n接下来 $m$ 行，每行两个空格隔开的正整数 $a_i,b_i$​​，表示 $a_i,b_i$​​ 之间有一条边。\n\n接下来一行一个整数 $p$，表示限制条件的个数。\n\n接下来 $p$ 行，每行两个空格隔开的正整数 $x_i,y_i$，描述一个 $(x_i,y_i)$ 的限制条件。", "outputFormat": "输出一行一个长度为 $m$ 的字符串，表示每条边的答案：\n\n-    若第 $i$ 条边必须得要是 $a_i$​​ 指向 $b_i$ 的，那么这个字符串的第 $i$ 个字符应当为 ``R``；\n\n-    若第 $i$ 条边必须得要是 $b_i$​​ 指向 $a_i$​​ 的，那么这个字符串的第 $i$ 个字符应当为 ``L``；\n\n-    否则，若第 $i$ 条边的方向无法唯一确定，那么这个字符串的第 $i$ 个字符应当为 ``B``。\n", "hint": "对于所有测试点，有 $1\\le n,m,p\\le 100\\ 000;1\\le a_i,b_i,x_i,y_i\\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2017] One-Way Streets", "background": "", "description": "You are given an undirected graph with $n$ vertices and $m$ edges. Now you want to orient this graph.\n\nThere are $p$ constraints. Each constraint is of the form $(x_i, y_i)$, meaning that in the new directed graph, $x_i$ must be able to reach $y_i$ by following some directed edges.\n\nPlease determine whether the direction of each edge can be uniquely determined. Also output the direction of those edges whose directions are uniquely determined.\n\nIt is guaranteed that a solution exists.", "inputFormat": "The first line contains two positive integers $n, m$ separated by spaces.\n\nThe next $m$ lines each contain two positive integers $a_i, b_i$ separated by spaces, indicating that there is an edge between $a_i$ and $b_i$.\n\nThe next line contains one integer $p$, the number of constraints.\n\nThe next $p$ lines each contain two positive integers $x_i, y_i$ separated by spaces, describing a constraint $(x_i, y_i)$.", "outputFormat": "Output one line containing a string of length $m$, representing the answer for each edge:\n\n- If the $i$-th edge must be directed from $a_i$ to $b_i$, then the $i$-th character should be `R`.\n\n- If the $i$-th edge must be directed from $b_i$ to $a_i$, then the $i$-th character should be `L`.\n\n- Otherwise, if the direction of the $i$-th edge cannot be uniquely determined, then the $i$-th character should be `B`.", "hint": "Constraints: for all testdata, $1 \\le n, m, p \\le 100\\,000$; $1 \\le a_i, b_i, x_i, y_i \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2017] One-Way Streets", "background": "", "description": "给定一张 $n$ 个点 $m$ 条边的无向图，现在想要把这张图定向。\n\n有 $p$ 个限制条件，每个条件形如 $(x_i,y_i)$，表示在新的有向图当中，$x_i$ 要能够沿着一些边走到 $y_i$​​。\n\n现在请你求出，每条边的方向是否能够唯一确定。同时请给出这些能够唯一确定的边的方向。\n\n数据保证有解。", "inputFormat": "第一行两个空格隔开的正整数 $n,m$ 。\n\n接下来 $m$ 行，每行两个空格隔开的正整数 $a_i,b_i$​​，表示 $a_i,b_i$​​ 之间有一条边。\n\n接下来一行一个整数 $p$，表示限制条件的个数。\n\n接下来 $p$ 行，每行两个空格隔开的正整数 $x_i,y_i$，描述一个 $(x_i,y_i)$ 的限制条件。", "outputFormat": "输出一行一个长度为 $m$ 的字符串，表示每条边的答案：\n\n-    若第 $i$ 条边必须得要是 $a_i$​​ 指向 $b_i$ 的，那么这个字符串的第 $i$ 个字符应当为 ``R``；\n\n-    若第 $i$ 条边必须得要是 $b_i$​​ 指向 $a_i$​​ 的，那么这个字符串的第 $i$ 个字符应当为 ``L``；\n\n-    否则，若第 $i$ 条边的方向无法唯一确定，那么这个字符串的第 $i$ 个字符应当为 ``B``。\n", "hint": "对于所有测试点，有 $1\\le n,m,p\\le 100\\ 000;1\\le a_i,b_i,x_i,y_i\\le n$。", "locale": "zh-CN"}}}
{"pid": "P4653", "type": "P", "difficulty": 3, "samples": [["4\n1.4 3.7\n1.2 2\n1.6 1.4\n1.9 1.5", "0.5000"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["贪心", "2017", "二分", "三分", "排序", "CEOI（中欧）", "前缀和", "双指针 two-pointer"], "title": "[CEOI 2017] Sure Bet", "background": null, "description": "现在有 $n$ 个 A 类灯泡和 $n$ 个 B 类灯泡，每个灯泡都有各自的权值。\n\n我们将这些灯泡分为 $n$ 组，每组包含一个来自 A 类的灯泡和一个来自 B 类的灯泡。\n\n你可以从中选取任意个灯泡，每选取一个灯泡需要花费 $1$ 的代价。\n\n在你选取完之后，系统会随机在 A 类和 B 类中选择一个类型，并点亮那一类的所有灯泡。你选取的每个点亮的灯泡会给你带来等于它权值的收益。\n\n现在请你合理选取灯泡，以最大化可能的最小收益。你只需要求出来这个收益即可。", "inputFormat": "第一行一个正整数 $n$ ，表示灯泡的组数。\n\n接下来 $n$ 行每行两个空格隔开的实数 $A_i,B_i$。分别表示属于这组的 A 灯泡和 B 灯泡的权值。输入的实数不会超过四位小数。", "outputFormat": "输出最大化的最小可能收益，请输出到小数点后恰好四位。", "hint": "**样例解释**\n\n最优策略是选择第一组的 B 灯泡和第三组的 A 灯泡和第四组的 A 灯泡：\n\n- 如果 B 类灯泡被点亮，收益是 $3.7-3=0.7$。\n- 如果 A 类灯泡被点亮，收益是 $1.6+1.9-3=0.5$ 。\n\n最小可能收益是 $0.5$。\n\n**数据范围**\n\n对于所有测试点，有 $1.0\\le A_i,B_i\\le 1000.0$，$0\\le n\\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2017] Sure Bet", "background": null, "description": "Luck is a fundamental part of betting. Some people improve their chances and earnings by having good knowledge of what they are betting on. We will take a different approach.\n\nVarious bookmakers offer different *odds* or quotas for the same outcome. (An *odds* of $x$ means that if you bet 1 euro and predict the outcome correctly, you get $x$ euros back. If you predict the outcome incorrectly, you of course get nothing back. Note that you pay 1 euro regardless of the outcome.) What if you could be certain of making a profit by cleverly placing several bets? You would want to make this guaranteed profit as large as possible.\n\nThe event we want to bet on has two possible outcomes. There are $n$ bookmakers that offer different odds. Let us denote the odds offered by the $i$-th bookmaker for the first outcome with $a_i$, and the odds offered for the second outcome with $b_i$. You can place a bet on any subset of the offered odds. You can even bet on both outcomes at the same bookmaker. However, all bets have to be exactly 1 euro and you cannot bet on the same outcome with the same bookmaker multiple times.\n\nIn case of the first outcome, you will receive $a_i$ euros from every bookmaker $i$ with whom you placed a bet on the first outcome. Similarly, in case of the second outcome, you will receive $b_i$ euros from all eligible bookmakers. Of course in both cases, you already paid 1 euro for every bet you placed.\n\nWhat is the largest *guaranteed* profit (i.e. regardless of the outcome) if you place your bets optimally?", "inputFormat": "The first line contains the number of bookmakers, $n$. The following $n$ lines describe the odds offered by each bookmaker with two space-separated real numbers $a_i$ and $b_i$ - the odds for the first and second outcome offered by the $i$-th bookmaker. The odds will be given to at most 4 decimal places.", "outputFormat": "Output the maximum guaranteed profit rounded to exactly 4 decimal places.", "hint": "#### Comment\n\nThe optimal betting strategy consists of betting on the second outcome with the first bookmaker and on the first outcome with the third and fourth bookmaker. In case of the first outcome, we will earn $1.6 + 1.9 − 3 = 0.5$ and in case of the second outcome $3.7 − 3 = 0.7$. So we’re guaranteed 0.5 euros regardless of the outcome.\n\n\n#### Constraints\n\n- $1.0 \\le a_i, b_i \\le 1000.0$\n- $1 \\le n \\le 100\\ 000$\n##### Subtask 1 (20 points)\n- $n \\le 10$\n##### Subtask 2 (40 points)\n- $n \\le 1\\ 000$\n##### Subtask 3 (40 points)\n- no additional constraints", "locale": "en"}, "zh-CN": {"title": "[CEOI 2017] Sure Bet", "background": null, "description": "现在有 $n$ 个 A 类灯泡和 $n$ 个 B 类灯泡，每个灯泡都有各自的权值。\n\n我们将这些灯泡分为 $n$ 组，每组包含一个来自 A 类的灯泡和一个来自 B 类的灯泡。\n\n你可以从中选取任意个灯泡，每选取一个灯泡需要花费 $1$ 的代价。\n\n在你选取完之后，系统会随机在 A 类和 B 类中选择一个类型，并点亮那一类的所有灯泡。你选取的每个点亮的灯泡会给你带来等于它权值的收益。\n\n现在请你合理选取灯泡，以最大化可能的最小收益。你只需要求出来这个收益即可。", "inputFormat": "第一行一个正整数 $n$ ，表示灯泡的组数。\n\n接下来 $n$ 行每行两个空格隔开的实数 $A_i,B_i$。分别表示属于这组的 A 灯泡和 B 灯泡的权值。输入的实数不会超过四位小数。", "outputFormat": "输出最大化的最小可能收益，请输出到小数点后恰好四位。", "hint": "**样例解释**\n\n最优策略是选择第一组的 B 灯泡和第三组的 A 灯泡和第四组的 A 灯泡：\n\n- 如果 B 类灯泡被点亮，收益是 $3.7-3=0.7$。\n- 如果 A 类灯泡被点亮，收益是 $1.6+1.9-3=0.5$ 。\n\n最小可能收益是 $0.5$。\n\n**数据范围**\n\n对于所有测试点，有 $1.0\\le A_i,B_i\\le 1000.0$，$0\\le n\\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4654", "type": "P", "difficulty": 6, "samples": [["10 1 4\n1 2\n2 3\n2 4\n3 9\n3 5\n4 7\n4 6\n6 8\n7 10", "4"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2017", "二分", "CEOI（中欧）", "树形 DP"], "title": "[CEOI 2017] Mousetrap", "background": "", "description": "有一个有 $n$ 个房间和 $n-1$ 条走廊的迷宫，保证任意两个房间可以通过走廊互相到达，换句话说，这个迷宫的结构是一棵树。\n\n一个老鼠被放进了迷宫，迷宫的管理者决定和老鼠做个游戏。\n\n一开始，有一个房间被放置了陷阱，老鼠出现在另一个房间。老鼠可以通过走廊到达别的房间，但是会弄脏它经过的走廊。老鼠不愿意通过脏的走廊。\n\n每个时刻，管理者可以进行一次操作：堵住一条走廊使得老鼠不能通过，或者擦干净一条走廊使得老鼠可以通过。然后老鼠会通过一条干净的并且没被堵住的走廊到达另一个房间。只有在没有这样的走廊的情况下，老鼠才不会动。一开始所有走廊都是干净的。管理者不能疏通已经被堵住的走廊。\n\n现在管理者希望通过尽量少的操作将老鼠赶到有陷阱的房间，而老鼠则希望管理者的操作数尽量多。请计算双方都采取最优策略的情况下管理者需要的操作数量。\n\n注意：管理者可以选择在一些时刻不操作。", "inputFormat": "第一行三个空格隔开的正整数数 $n,t,m$。分别代表房间的个数，陷阱房的编号和老鼠起始房间的编号。\n\n接下来 $n-1$ 行，每行两个空格隔开的整数 $a_i,b_i$​​，表示有一条走廊连接编号为 $a_i$ 和 $b_i$​​ 的房间。", "outputFormat": "输出一行包含一个整数，表示双方都采取最优策略的情况下，管理者需要的操作数量。", "hint": "**样例解释**\n\n-    管理者先堵住房间 $4$ 和 $7$ 之间的走廊。\n-    老鼠走到房间 $6$。房间 $4$ 和 $6$ 之间的走廊现在是脏的。\n-    管理者堵住房间 $6$ 和 $8$ 之间的走廊。\n-    老鼠不能动。\n-    管理者清理房间 $4$ 和 $6$ 之间的走廊，房间 $4$ 和 $6$ 之间的走廊现在是干净的。\n-    老鼠走到房间 $4$，房间 $4$ 和 $6$ 之间的走廊现在是脏的。\n-    管理者堵住房间 $2$ 和 $3$ 之间的走廊。\n-    老鼠走到房间 $2$，房间 $2$ 和 $4$ 之间的走廊现在是脏的。\n-    管理者不进行操作。\n-    老鼠走到房间 $1$。\n\n这个过程中管理者总共进行了 $4$ 次操作。\n\n**数据范围**\n\n对于所有的数据，$1 \\le n \\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2017] Mousetrap", "background": "", "description": "There is a maze with $n$ rooms and $n-1$ corridors. It is guaranteed that any two rooms are connected by corridors; in other words, the maze structure is a tree.\n\nA mouse is put into the maze, and the maze manager decides to play a game with the mouse.\n\nAt the beginning, one room contains a trap, and the mouse appears in another room. The mouse can move to other rooms through corridors, but it will dirty every corridor it passes through. The mouse does not want to go through dirty corridors.\n\nAt each moment, the manager may perform one operation: block a corridor so that the mouse cannot pass through it, or clean a corridor so that the mouse can pass through it. Then the mouse will move through one corridor that is clean and not blocked to another room. Only if there is no such corridor will the mouse stay still. Initially, all corridors are clean. The manager cannot unblock a corridor once it has been blocked.\n\nNow the manager wants to drive the mouse into the room with the trap using as few operations as possible, while the mouse wants the manager to use as many operations as possible. Compute the number of operations the manager needs when both sides play optimally.\n\nNote: The manager may choose to do nothing at some moments.", "inputFormat": "The first line contains three space-separated positive integers $n,t,m$, representing the number of rooms, the index of the trap room, and the index of the mouse’s starting room.\n\nThe next $n-1$ lines each contain two space-separated integers $a_i,b_i$, meaning there is a corridor connecting rooms $a_i$ and $b_i$.", "outputFormat": "Output one line containing one integer, indicating the number of operations the manager needs when both sides play optimally.", "hint": "**Sample Explanation**\n\n- The manager first blocks the corridor between rooms $4$ and $7$.\n- The mouse moves to room $6$. The corridor between rooms $4$ and $6$ is now dirty.\n- The manager blocks the corridor between rooms $6$ and $8$.\n- The mouse cannot move.\n- The manager cleans the corridor between rooms $4$ and $6$. The corridor between rooms $4$ and $6$ is now clean.\n- The mouse moves to room $4$. The corridor between rooms $4$ and $6$ is now dirty.\n- The manager blocks the corridor between rooms $2$ and $3$.\n- The mouse moves to room $2$. The corridor between rooms $2$ and $4$ is now dirty.\n- The manager performs no operation.\n- The mouse moves to room $1$.\n\nIn this process, the manager performed a total of $4$ operations.\n\n**Constraints**\n\nFor all testdata, $1 \\le n \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2017] Mousetrap", "background": "", "description": "有一个有 $n$ 个房间和 $n-1$ 条走廊的迷宫，保证任意两个房间可以通过走廊互相到达，换句话说，这个迷宫的结构是一棵树。\n\n一个老鼠被放进了迷宫，迷宫的管理者决定和老鼠做个游戏。\n\n一开始，有一个房间被放置了陷阱，老鼠出现在另一个房间。老鼠可以通过走廊到达别的房间，但是会弄脏它经过的走廊。老鼠不愿意通过脏的走廊。\n\n每个时刻，管理者可以进行一次操作：堵住一条走廊使得老鼠不能通过，或者擦干净一条走廊使得老鼠可以通过。然后老鼠会通过一条干净的并且没被堵住的走廊到达另一个房间。只有在没有这样的走廊的情况下，老鼠才不会动。一开始所有走廊都是干净的。管理者不能疏通已经被堵住的走廊。\n\n现在管理者希望通过尽量少的操作将老鼠赶到有陷阱的房间，而老鼠则希望管理者的操作数尽量多。请计算双方都采取最优策略的情况下管理者需要的操作数量。\n\n注意：管理者可以选择在一些时刻不操作。", "inputFormat": "第一行三个空格隔开的正整数数 $n,t,m$。分别代表房间的个数，陷阱房的编号和老鼠起始房间的编号。\n\n接下来 $n-1$ 行，每行两个空格隔开的整数 $a_i,b_i$​​，表示有一条走廊连接编号为 $a_i$ 和 $b_i$​​ 的房间。", "outputFormat": "输出一行包含一个整数，表示双方都采取最优策略的情况下，管理者需要的操作数量。", "hint": "**样例解释**\n\n-    管理者先堵住房间 $4$ 和 $7$ 之间的走廊。\n-    老鼠走到房间 $6$。房间 $4$ 和 $6$ 之间的走廊现在是脏的。\n-    管理者堵住房间 $6$ 和 $8$ 之间的走廊。\n-    老鼠不能动。\n-    管理者清理房间 $4$ 和 $6$ 之间的走廊，房间 $4$ 和 $6$ 之间的走廊现在是干净的。\n-    老鼠走到房间 $4$，房间 $4$ 和 $6$ 之间的走廊现在是脏的。\n-    管理者堵住房间 $2$ 和 $3$ 之间的走廊。\n-    老鼠走到房间 $2$，房间 $2$ 和 $4$ 之间的走廊现在是脏的。\n-    管理者不进行操作。\n-    老鼠走到房间 $1$。\n\n这个过程中管理者总共进行了 $4$ 次操作。\n\n**数据范围**\n\n对于所有的数据，$1 \\le n \\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4655", "type": "P", "difficulty": 6, "samples": [["6\n3 8 7 1 6 6\n0 -1 9 1 2 0", "17"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2017", "线段树", "cdq 分治", "CEOI（中欧）", "斜率优化", "李超线段树"], "title": "[CEOI 2017] Building Bridges", "background": "", "description": "有 $n$ 根柱子依次排列，每根柱子都有一个高度。第 $i$ 根柱子的高度为 $h_i$。\n\n现在想要建造若干座桥，如果一座桥架在第 $i$ 根柱子和第 $j$ 根柱子之间，那么需要 $(h_i-h_j)^2$​​ 的代价。\n\n在造桥前，所有用不到的柱子都会被拆除，因为他们会干扰造桥进程。第 $i$ 根柱子被拆除的代价为 $w_i$，注意 $w_i$ 不一定非负，因为可能政府希望拆除某些柱子。\n\n现在政府想要知道，通过桥梁把第 $1$ 根柱子和第 $n$ 根柱子连接的最小代价。注意桥梁不能在端点以外的任何地方相交。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个空格隔开的整数，依次表示 $h_1,h_2,\\cdots,h_n$​​。\n\n第三行 $n$ 个空格隔开的整数，依次表示 $w_1,w_2,\\cdots,w_n$​​。", "outputFormat": "输出一行一个整数表示最小代价，注意最小代价不一定是正数。", "hint": "对于 $100\\%$ 的数据，有 $2\\le n\\le 10^5;0\\le h_i,\\vert w_i\\vert\\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2017] Building Bridges", "background": "", "description": "There are $n$ pillars arranged in order, and each pillar has a height. The height of the $i$-th pillar is $h_i$.\n\nNow we want to build several bridges. If a bridge is built between the $i$-th pillar and the $j$-th pillar, it costs $(h_i-h_j)^2$.\n\nBefore building bridges, all pillars that are not used will be demolished, because they would interfere with the construction process. The cost to demolish the $i$-th pillar is $w_i$. Note that $w_i$ is not necessarily non-negative, because the government may want some pillars to be demolished.\n\nNow the government wants to know the minimum total cost to connect pillar $1$ and pillar $n$ using bridges. Note that bridges cannot intersect anywhere other than at their endpoints.", "inputFormat": "The first line contains a positive integer $n$.\n\nThe second line contains $n$ space-separated integers, which are $h_1,h_2,\\cdots,h_n$ in order.\n\nThe third line contains $n$ space-separated integers, which are $w_1,w_2,\\cdots,w_n$ in order.", "outputFormat": "Output one line with one integer, the minimum total cost. Note that the minimum total cost is not necessarily positive.", "hint": "For $100\\%$ of the testdata, $2\\le n\\le 10^5;0\\le h_i,\\vert w_i\\vert\\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2017] Building Bridges", "background": "", "description": "有 $n$ 根柱子依次排列，每根柱子都有一个高度。第 $i$ 根柱子的高度为 $h_i$。\n\n现在想要建造若干座桥，如果一座桥架在第 $i$ 根柱子和第 $j$ 根柱子之间，那么需要 $(h_i-h_j)^2$​​ 的代价。\n\n在造桥前，所有用不到的柱子都会被拆除，因为他们会干扰造桥进程。第 $i$ 根柱子被拆除的代价为 $w_i$，注意 $w_i$ 不一定非负，因为可能政府希望拆除某些柱子。\n\n现在政府想要知道，通过桥梁把第 $1$ 根柱子和第 $n$ 根柱子连接的最小代价。注意桥梁不能在端点以外的任何地方相交。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个空格隔开的整数，依次表示 $h_1,h_2,\\cdots,h_n$​​。\n\n第三行 $n$ 个空格隔开的整数，依次表示 $w_1,w_2,\\cdots,w_n$​​。", "outputFormat": "输出一行一个整数表示最小代价，注意最小代价不一定是正数。", "hint": "对于 $100\\%$ 的数据，有 $2\\le n\\le 10^5;0\\le h_i,\\vert w_i\\vert\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4656", "type": "P", "difficulty": 4, "samples": [["4\nbonobo\ndeleted\nracecar\nracecars", "3\n5\n7\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2017", "CEOI（中欧）", "哈希 hashing"], "title": "[CEOI 2017] Palindromic Partitions", "background": "", "description": "给出一个只包含小写字母字符串，要求你将它划分成尽可能多的小块，使得这些小块构成回文串。\n\n例如：对于字符串 ``abcab``，将他分成 ``ab`` ``c`` ``ab`` 或者 ``abcab`` 就是构成回文串的划分方法，``abc`` ``ab`` 则不是。", "inputFormat": "第一行输入一个整数 $T$ 表示数据组数。\n\n接下来的 $T$ 行，每行输入一个字符串，代表你需要处理的字符串，保证该字符串只包含小写字母。", "outputFormat": "输出 $T$ 行，对于每个输入的字符串，输出一行包含一个整数 $x$，表示该字符串最多能分解成 $x$ 个小块，使得这些小块构成回文串。", "hint": "对于 $100\\%$ 的数据，有 $1\\le T\\le 10$。设 $L$ 为单个字符串的长度，则 $1\\le L\\le 10^6$​​。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2017] Palindromic Partitions", "background": "", "description": "You are given a string containing only lowercase letters. You need to partition it into as many blocks as possible, such that these blocks form a palindrome string.\n\nFor example, for the string `abcab`, partitioning it into `ab` `c` `ab` or just `abcab` is a valid way to make the blocks form a palindrome, while `abc` `ab` is not.", "inputFormat": "The first line contains an integer $T$, indicating the number of test cases.\n\nThe next $T$ lines each contain a string, representing the string you need to process. It is guaranteed that the string contains only lowercase letters.", "outputFormat": "Output $T$ lines. For each input string, output one line containing an integer $x$, indicating the maximum number of blocks the string can be partitioned into, such that these blocks form a palindrome.", "hint": "For $100\\%$ of the testdata, $1 \\le T \\le 10$. Let $L$ be the length of a single string, then $1 \\le L \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2017] Palindromic Partitions", "background": "", "description": "给出一个只包含小写字母字符串，要求你将它划分成尽可能多的小块，使得这些小块构成回文串。\n\n例如：对于字符串 ``abcab``，将他分成 ``ab`` ``c`` ``ab`` 或者 ``abcab`` 就是构成回文串的划分方法，``abc`` ``ab`` 则不是。", "inputFormat": "第一行输入一个整数 $T$ 表示数据组数。\n\n接下来的 $T$ 行，每行输入一个字符串，代表你需要处理的字符串，保证该字符串只包含小写字母。", "outputFormat": "输出 $T$ 行，对于每个输入的字符串，输出一行包含一个整数 $x$，表示该字符串最多能分解成 $x$ 个小块，使得这些小块构成回文串。", "hint": "对于 $100\\%$ 的数据，有 $1\\le T\\le 10$。设 $L$ 为单个字符串的长度，则 $1\\le L\\le 10^6$​​。", "locale": "zh-CN"}}}
{"pid": "P4657", "type": "P", "difficulty": 6, "samples": [["12 2\n2 3 3 8 1 5 6 7 8 3 5 4\n2 1\n2 7\n3 4\n4 7\n7 6\n5 6\n6 8\n6 9\n7 10\n10 11\n10 12", "36"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2017", "CEOI（中欧）"], "title": "[CEOI 2017] Chase", "background": "", "description": "在逃亡者的面前有一个迷宫，这个迷宫由 $n$ 个房间和 $n-1$ 条双向走廊构成，每条走廊会链接不同的两个房间，所有的房间都可以通过走廊互相到达。换句话说，这是一棵树。\n\n逃亡者会选择一个房间进入迷宫，走过若干条走廊并走出迷宫，但他永远不会走重复的走廊。\n\n在第 $i$ 个房间里，有 $F_i$​​ 个铁球，每当一个人经过这个房间时，他就会受到铁球的阻挡。逃亡者手里有 $V$ 个磁铁，当他到达一个房间时，他可以选择丢下一个磁铁（也可以不丢），将与这个房间相邻的所有房间里的铁球吸引到这个房间。这个过程如下：\n\n1.    逃亡者进入房间。\n2.    逃亡者丢下磁铁。\n3.    逃亡者走出房间。\n4.    铁球被吸引到这个房间。\n\n注意逃亡者只会受到这个房间原有的铁球的阻拦，而不会受到被吸引的铁球的阻挡。\n\n在逃亡者走出迷宫后，追逐者将会沿着逃亡者走过的路径穿过迷宫，他会碰到这条路径上所有的铁球。\n\n请帮助逃亡者选择一条路径，使得追逐者遇到的铁球数量减去逃亡者遇到的铁球数量最大化。\n", "inputFormat": "第一行两个空格隔开的整数整数 $n$ 和 $V$。\n第二行 $n$ 个空格隔开的整数表示 $F_i$​​。\n之后的 $n-1$ 行，每行两个空格隔开的整数 $x$ 和 $y$，表示有一条走廊连接编号为 $x$ 和编号为 $y$ 的房间。", "outputFormat": "输出一个整数表示最优情况下追逐者遇到的铁球数量减去逃亡者遇到的铁球数量。", "hint": "**样例解释**\n\n有一个最优方案如下：\n\n-    从 $6$ 号房间进入迷宫并丢下第一个磁铁，他遇到了 $5$ 个铁球，这个时候 $6$ 号房间会有 $27$ 个铁球，而 $5$ 号，$7$ 号，$8$ 号，$9$ 号房间都没有铁球。\n-    走到 $7$ 号房间丢下第二个磁铁并走出迷宫，他遇到了 $0$ 个铁球，这个时候 $7$ 号房间会有 $41$ 个铁球，而 $2$ 号，$4$ 号，$6$ 号，$10$ 号房间会没有铁球。\n\n在这个过程中，逃亡者会遇到 $5$ 个铁球而追逐者会遇到 $41$ 个铁球。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，有 $1\\le n\\le 10^5;0\\le V\\le 100;0\\le F_i\\le 10^9$​​。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2017] Chase", "background": "", "description": "In front of the fugitive there is a maze. The maze consists of $n$ rooms and $n-1$ bidirectional corridors. Each corridor connects two different rooms, and all rooms are reachable from each other through the corridors. In other words, it is a tree.\n\nThe fugitive will choose a room to enter the maze, walk through some corridors, and then leave the maze, but he will never walk through the same corridor twice.\n\nIn room $i$, there are $F_i$ iron balls. Whenever someone passes through this room, they will be blocked by the iron balls. The fugitive has $V$ magnets. When he arrives at a room, he may choose to drop one magnet (or not). This will pull all iron balls from every room adjacent to this room into this room. The process is as follows:\n\n1. The fugitive enters the room.\n2. The fugitive drops a magnet.\n3. The fugitive leaves the room.\n4. The iron balls are pulled into this room.\n\nNote that the fugitive is only blocked by the iron balls originally in this room, and will not be blocked by the iron balls pulled into this room.\n\nAfter the fugitive leaves the maze, the pursuer will go through the maze along the path taken by the fugitive, and he will encounter all iron balls on this path.\n\nPlease help the fugitive choose a path to maximize: (number of iron balls encountered by the pursuer) minus (number of iron balls encountered by the fugitive).", "inputFormat": "The first line contains two space-separated integers $n$ and $V$.\n\nThe second line contains $n$ space-separated integers representing $F_i$.\n\nThen follow $n-1$ lines. Each line contains two space-separated integers $x$ and $y$, indicating that there is a corridor connecting room $x$ and room $y$.", "outputFormat": "Output one integer, representing the maximum possible value of (number of iron balls encountered by the pursuer) minus (number of iron balls encountered by the fugitive) in the optimal case.", "hint": "**Sample Explanation**\n\nOne optimal plan is as follows:\n\n- Enter the maze from room $6$ and drop the first magnet. He encounters $5$ iron balls. At this time, room $6$ will have $27$ iron balls, while rooms $5$, $7$, $8$, and $9$ will have no iron balls.\n- Walk to room $7$, drop the second magnet, and leave the maze. He encounters $0$ iron balls. At this time, room $7$ will have $41$ iron balls, while rooms $2$, $4$, $6$, and $10$ will have no iron balls.\n\nIn this process, the fugitive encounters $5$ iron balls, while the pursuer encounters $41$ iron balls.\n\n**Constraints**\n\nFor $100\\%$ of the testdata, $1\\le n\\le 10^5;0\\le V\\le 100;0\\le F_i\\le 10^9$​​。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2017] Chase", "background": "", "description": "在逃亡者的面前有一个迷宫，这个迷宫由 $n$ 个房间和 $n-1$ 条双向走廊构成，每条走廊会链接不同的两个房间，所有的房间都可以通过走廊互相到达。换句话说，这是一棵树。\n\n逃亡者会选择一个房间进入迷宫，走过若干条走廊并走出迷宫，但他永远不会走重复的走廊。\n\n在第 $i$ 个房间里，有 $F_i$​​ 个铁球，每当一个人经过这个房间时，他就会受到铁球的阻挡。逃亡者手里有 $V$ 个磁铁，当他到达一个房间时，他可以选择丢下一个磁铁（也可以不丢），将与这个房间相邻的所有房间里的铁球吸引到这个房间。这个过程如下：\n\n1.    逃亡者进入房间。\n2.    逃亡者丢下磁铁。\n3.    逃亡者走出房间。\n4.    铁球被吸引到这个房间。\n\n注意逃亡者只会受到这个房间原有的铁球的阻拦，而不会受到被吸引的铁球的阻挡。\n\n在逃亡者走出迷宫后，追逐者将会沿着逃亡者走过的路径穿过迷宫，他会碰到这条路径上所有的铁球。\n\n请帮助逃亡者选择一条路径，使得追逐者遇到的铁球数量减去逃亡者遇到的铁球数量最大化。\n", "inputFormat": "第一行两个空格隔开的整数整数 $n$ 和 $V$。\n第二行 $n$ 个空格隔开的整数表示 $F_i$​​。\n之后的 $n-1$ 行，每行两个空格隔开的整数 $x$ 和 $y$，表示有一条走廊连接编号为 $x$ 和编号为 $y$ 的房间。", "outputFormat": "输出一个整数表示最优情况下追逐者遇到的铁球数量减去逃亡者遇到的铁球数量。", "hint": "**样例解释**\n\n有一个最优方案如下：\n\n-    从 $6$ 号房间进入迷宫并丢下第一个磁铁，他遇到了 $5$ 个铁球，这个时候 $6$ 号房间会有 $27$ 个铁球，而 $5$ 号，$7$ 号，$8$ 号，$9$ 号房间都没有铁球。\n-    走到 $7$ 号房间丢下第二个磁铁并走出迷宫，他遇到了 $0$ 个铁球，这个时候 $7$ 号房间会有 $41$ 个铁球，而 $2$ 号，$4$ 号，$6$ 号，$10$ 号房间会没有铁球。\n\n在这个过程中，逃亡者会遇到 $5$ 个铁球而追逐者会遇到 $41$ 个铁球。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，有 $1\\le n\\le 10^5;0\\le V\\le 100;0\\le F_i\\le 10^9$​​。", "locale": "zh-CN"}}}
{"pid": "P4658", "type": "P", "difficulty": 5, "samples": [["2\n4\nA...\n.#..\n....\n...B\n4\nA...\n....\n..#.\n...B", "B\nA"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000]}, "tags": ["2008", "BalticOI（波罗的海）"], "title": "[BalticOI 2008] 游戏 (Day1)", "background": null, "description": "玩家 $\\text{A}$ 和玩家 $\\text{B}$，在一个 $n\\times n$ 的正方形方格板上玩游戏。方格板上的方格要么是白的，要么是黑的。游戏只在白色区域上进行，黑色区域是禁区。初始时，每位玩家的起点上，会放置一个棋子。保证两人起点不同。\n\n玩家交替移动，玩家 $\\text{A}$ 先移动。每次移动，玩家会将他的棋子移动到相邻的白色方格中。如果玩家将棋子移动到对方现在的位置，玩家可以再移动一步，以越过对手。注意在这种情况下，第二步移动的方向可以与第一步移动的不同。\n\n这个游戏的目标是玩家的棋子首先到达对方的起点，先到者为胜。即使玩家的最后一步包含两次移动，并且他只是越过了对手的起点（如果对手现在在起点），这个玩家也获得胜利。\n\n给出方格板的布局和两个玩家的起点，判定哪个玩家有必胜策略（如果对手不管怎样移动，一个玩家能获得胜利，就称一个玩家有必胜策略）。", "inputFormat": "标准输入的第一行包含一个正整数 $t$（$1\\le t\\le 10$），表示测试数据的组数。在此之后为 $t$ 组测试数据。每一组测试数据格式如下：\n\n这组数据的第一行是一个正整数 $n$（$2\\le n\\le 300$），表示方格的边长，之后的每一行包含 $n$ 个字符（字符之间无空格）。每个字符是 ``.``（一个白色方格），``#``（一个黑色方格），``A``（$\\text{A}$ 的起点）和 ``B``（$\\text{B}$ 的起点）的其中之一。\n\n保证在两人的起点间存在一条白色方格的通路。", "outputFormat": "对于每组数据，输出一行到标准输出，包含一个字符 ``A`` 或 ``B``，表示有着必胜策略的玩家。", "hint": "#### 样例解释\n\n对于第一组数据： \n\n![0](https://i.loli.net/2018/02/19/5a8ab4a17e247.gif)\n\n如果 $\\text{A}$ 在前三次移动中移动到方格最右边，$\\text{B}$ 将在前三次移动中向上移动。因此，在第三次移动中玩家 $\\text{B}$ 将会到达 $\\text{A}$ 的方块所在方格，并且给 $\\text{B}$ 一次额外的移动机会。因此，$\\text{B}$ 会首先到达 $\\text{A}$ 的起点并且赢得游戏。\n\n对于第二组数据： \n\n![1](https://i.loli.net/2018/02/19/5a8ab4a17e132.gif)\n\n$\\text{A}$ 可以先向右移动一次，再向下移动一次。然后，$\\text{A}$ 可以由 $\\text{B}$ 的前两次移动决定他向下或向右移动来回避 $\\text{B}$。这样的话 $\\text{A}$ 会首先到达 $\\text{B}$ 的起点，因此赢得比赛。事实上我们已经证明了 $\\text{A}$ 有必胜策略。\n\n#### 数据范围\n\n对于 $40\\%$ 的数据，$n\\le 40$。\n\n对于 $60\\%$ 的数据，$n\\le 150$。\n\n对于所有数据，$2\\le n\\le 300$。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2008] Game (Day 1)", "background": "", "description": "Player $\\text{A}$ and player $\\text{B}$ play a game on an $n \\times n$ square grid. Each cell on the board is either white or black. The game is played only on the white cells; black cells are forbidden. Initially, each player has one piece placed at their own starting cell. It is guaranteed that the two starting cells are different.\n\nThe players move alternately, with player $\\text{A}$ moving first. In each move, a player moves their piece to an adjacent white cell. If a player moves their piece onto the cell currently occupied by the opponent, the player may move one more step to jump over the opponent. Note that in this case, the direction of the second step may be different from the first step.\n\nThe goal of the game is to be the first player whose piece reaches the opponent’s starting cell. Even if the player’s last move consists of two steps and they only jump over the opponent’s starting cell (if the opponent is currently on that starting cell), the player still wins.\n\nGiven the board layout and the two players’ starting positions, determine which player has a winning strategy (a player has a winning strategy if they can win no matter how the opponent moves).", "inputFormat": "The first line of standard input contains a positive integer $t$ ($1 \\le t \\le 10$), the number of test cases. Then follow $t$ test cases. Each test case is given as follows:\n\nThe first line of a test case contains a positive integer $n$ ($2 \\le n \\le 300$), the side length of the grid. Each of the next $n$ lines contains $n$ characters (with no spaces). Each character is one of ``.`` (a white cell), ``#`` (a black cell), ``A`` (the starting cell of $\\text{A}$), and ``B`` (the starting cell of $\\text{B}$).\n\nIt is guaranteed that there exists a path of white cells between the two starting cells.", "outputFormat": "For each test case, output one line to standard output containing one character, ``A`` or ``B``, indicating the player who has a winning strategy.", "hint": "#### Sample Explanation\n\nFor the first test case:\n\n![0](https://i.loli.net/2018/02/19/5a8ab4a17e247.gif)\n\nIf $\\text{A}$ moves to the right edge of the grid within the first three moves, then $\\text{B}$ will move upward within the first three moves. Therefore, on the third move, player $\\text{B}$ will reach the cell where $\\text{A}$ is and gain an extra move. Thus, $\\text{B}$ will reach $\\text{A}$’s starting cell first and win the game.\n\nFor the second test case:\n\n![1](https://i.loli.net/2018/02/19/5a8ab4a17e132.gif)\n\n$\\text{A}$ can first move one step to the right and then one step down. After that, $\\text{A}$ can decide whether to move down or right based on $\\text{B}$’s first two moves, so as to avoid $\\text{B}$. In this way, $\\text{A}$ will reach $\\text{B}$’s starting cell first and win the game. In fact, we have already proven that $\\text{A}$ has a winning strategy.\n\n#### Constraints\n\nFor $40\\%$ of the testdata, $n \\le 40$.\n\nFor $60\\%$ of the testdata, $n \\le 150$.\n\nFor all testdata, $2 \\le n \\le 300$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2008] 游戏 (Day1)", "background": null, "description": "玩家 $\\text{A}$ 和玩家 $\\text{B}$，在一个 $n\\times n$ 的正方形方格板上玩游戏。方格板上的方格要么是白的，要么是黑的。游戏只在白色区域上进行，黑色区域是禁区。初始时，每位玩家的起点上，会放置一个棋子。保证两人起点不同。\n\n玩家交替移动，玩家 $\\text{A}$ 先移动。每次移动，玩家会将他的棋子移动到相邻的白色方格中。如果玩家将棋子移动到对方现在的位置，玩家可以再移动一步，以越过对手。注意在这种情况下，第二步移动的方向可以与第一步移动的不同。\n\n这个游戏的目标是玩家的棋子首先到达对方的起点，先到者为胜。即使玩家的最后一步包含两次移动，并且他只是越过了对手的起点（如果对手现在在起点），这个玩家也获得胜利。\n\n给出方格板的布局和两个玩家的起点，判定哪个玩家有必胜策略（如果对手不管怎样移动，一个玩家能获得胜利，就称一个玩家有必胜策略）。", "inputFormat": "标准输入的第一行包含一个正整数 $t$（$1\\le t\\le 10$），表示测试数据的组数。在此之后为 $t$ 组测试数据。每一组测试数据格式如下：\n\n这组数据的第一行是一个正整数 $n$（$2\\le n\\le 300$），表示方格的边长，之后的每一行包含 $n$ 个字符（字符之间无空格）。每个字符是 ``.``（一个白色方格），``#``（一个黑色方格），``A``（$\\text{A}$ 的起点）和 ``B``（$\\text{B}$ 的起点）的其中之一。\n\n保证在两人的起点间存在一条白色方格的通路。", "outputFormat": "对于每组数据，输出一行到标准输出，包含一个字符 ``A`` 或 ``B``，表示有着必胜策略的玩家。", "hint": "#### 样例解释\n\n对于第一组数据： \n\n![0](https://i.loli.net/2018/02/19/5a8ab4a17e247.gif)\n\n如果 $\\text{A}$ 在前三次移动中移动到方格最右边，$\\text{B}$ 将在前三次移动中向上移动。因此，在第三次移动中玩家 $\\text{B}$ 将会到达 $\\text{A}$ 的方块所在方格，并且给 $\\text{B}$ 一次额外的移动机会。因此，$\\text{B}$ 会首先到达 $\\text{A}$ 的起点并且赢得游戏。\n\n对于第二组数据： \n\n![1](https://i.loli.net/2018/02/19/5a8ab4a17e132.gif)\n\n$\\text{A}$ 可以先向右移动一次，再向下移动一次。然后，$\\text{A}$ 可以由 $\\text{B}$ 的前两次移动决定他向下或向右移动来回避 $\\text{B}$。这样的话 $\\text{A}$ 会首先到达 $\\text{B}$ 的起点，因此赢得比赛。事实上我们已经证明了 $\\text{A}$ 有必胜策略。\n\n#### 数据范围\n\n对于 $40\\%$ 的数据，$n\\le 40$。\n\n对于 $60\\%$ 的数据，$n\\le 150$。\n\n对于所有数据，$2\\le n\\le 300$。", "locale": "zh-CN"}}}
{"pid": "P4659", "type": "P", "difficulty": 5, "samples": [["3 2\n1 0 2 1\n1 0 2 0\n1 1 2 1", "0\n1"], ["2 1\n1 0 1 0\n1 1 1 1", "IMPOSSIBLE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000]}, "tags": ["2008", "Special Judge", "BalticOI（波罗的海）"], "title": "[BalticOI 2008] 阀门 (Day1)", "background": null, "description": "成为码农多年的你，已经厌倦了码农生活。你决定跳槽，去做一些不一样的事情。\n\n正在寻找下一份工作的你，被一份水产养殖的工作吸引住了。“太酷了！”并且，鱼是很好的生物。所以你毫不犹豫地去应聘了。幸运的是，你成功拿到了 Offer。今天是你工作的第一天。你的老板已经给你分配了任务：分隔两个蓄水池。\n\n你手上的操作指南告诉了你如下信息：\n\n这两个蓄水池之间有一些管道连通，每个管道有两个阀门。当两个阀门同时开启时，这个管道就处于开启状态，反之处于关闭状态。阀门用开关控制。同一个开关会控制一些阀门，但是每一个阀门都只被一个开关控制。有可能一个管道上的两个阀门被同一个开关控制，也可能有开关不控制任何阀门。 \n\n![0](https://i.loli.net/2018/02/19/5a8ac86221c4b.png)\n\n开关以以下两种方式控制阀门：\n- 当开关闭合时阀门打开，当开关断开时阀门关闭；\n- 当开关闭合时阀门关闭，当开关断开时阀门打开。\n\n玩了一会儿开关之后你突然意识到你的编程经历会十分有用。给出每个阀门被哪个开关所控制，判断是否可能关闭所有管道，如果可以，找出这种合法配置下每一个开关的状态。", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $m$，分别表示管道数和开关数。开关被从 $1$ 到 $m$ 标号。\n\n接下来的 $n$ 行描述管道，一行用四个整数 $a,s_a,b,s_b$ 描述一个管道，$a,b$ 代表控制该管道的开关（$1\\le a,b\\le m$）。$s_a$ 和 $s_b$ 为 $0$ 或 $1$，并与描述中的操作模式相符，$s_i=0$ 表示当且仅当开关 $i$ 断开时阀门关闭，$s_i=1$ 表示当且仅当开关 $i$ 闭合时阀门关闭。", "outputFormat": "如果有可能关闭所有管道，标准输出应包含 $m$ 行，如果开关 $i$ 断开，第 $i$ 行应输出 $0$，如果开关 $i$ 闭合，第 $i$ 行应输出 $1$。如果有很多可能的答案，你的程序可以输出任意一种。\n\n如果不可能关闭所有管道，你的程序应输出一行，包含一个单词 ``IMPOSSIBLE``。", "hint": "#### 数据范围\n\n对于 $30\\%$ 的数据，$n\\le 40$，$m\\le 20$。\n\n对于所有数据，$1\\le n\\le 2.5\\times 10^5$，$1\\le m\\le 5\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2008] Valves (Day1)", "background": "", "description": "After being a programmer for many years, you have gotten tired of the programmer’s life. You decide to change jobs and do something different.\n\nWhile looking for your next job, you are attracted by a job in aquaculture. “So cool!” And fish are great creatures. So you apply without hesitation. Luckily, you get an offer. Today is your first day at work. Your boss has assigned you a task: separate two water reservoirs.\n\nThe manual you have tells you the following information:\n\nThere are some pipes connecting the two reservoirs. Each pipe has two valves. A pipe is open when both valves are open at the same time; otherwise it is closed. Valves are controlled by switches. The same switch controls some valves, but each valve is controlled by exactly one switch. It is possible that the two valves on a pipe are controlled by the same switch, and it is also possible that some switches control no valves.\n\n![0](https://i.loli.net/2018/02/19/5a8ac86221c4b.png)\n\nA switch controls a valve in one of the following two ways:\n- When the switch is closed, the valve opens; when the switch is open, the valve closes.\n- When the switch is closed, the valve closes; when the switch is open, the valve opens.\n\nAfter playing with the switches for a while, you suddenly realize that your programming experience will be very useful. Given which switch controls each valve, determine whether it is possible to close all pipes. If it is, find the state of every switch in such a valid configuration.", "inputFormat": "The first line of standard input contains two integers $n$ and $m$, representing the number of pipes and the number of switches. The switches are numbered from $1$ to $m$.\n\nThe next $n$ lines describe the pipes. Each line contains four integers $a, s_a, b, s_b$ describing one pipe. $a, b$ are the switches controlling the pipe ($1 \\le a, b \\le m$). $s_a$ and $s_b$ are $0$ or $1$ and correspond to the control modes in the description: $s_i = 0$ means the valve is closed if and only if switch $i$ is open, and $s_i = 1$ means the valve is closed if and only if switch $i$ is closed.", "outputFormat": "If it is possible to close all pipes, standard output should contain $m$ lines. If switch $i$ is open, the $i$-th line should output $0$; if switch $i$ is closed, the $i$-th line should output $1$. If there are many possible answers, your program may output any one of them.\n\nIf it is impossible to close all pipes, your program should output one line containing the word ``IMPOSSIBLE``.", "hint": "#### Constraints\n\nFor $30\\%$ of the testdata, $n \\le 40$, $m \\le 20$.\n\nFor all testdata, $1 \\le n \\le 2.5 \\times 10^5$, $1 \\le m \\le 5 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2008] 阀门 (Day1)", "background": null, "description": "成为码农多年的你，已经厌倦了码农生活。你决定跳槽，去做一些不一样的事情。\n\n正在寻找下一份工作的你，被一份水产养殖的工作吸引住了。“太酷了！”并且，鱼是很好的生物。所以你毫不犹豫地去应聘了。幸运的是，你成功拿到了 Offer。今天是你工作的第一天。你的老板已经给你分配了任务：分隔两个蓄水池。\n\n你手上的操作指南告诉了你如下信息：\n\n这两个蓄水池之间有一些管道连通，每个管道有两个阀门。当两个阀门同时开启时，这个管道就处于开启状态，反之处于关闭状态。阀门用开关控制。同一个开关会控制一些阀门，但是每一个阀门都只被一个开关控制。有可能一个管道上的两个阀门被同一个开关控制，也可能有开关不控制任何阀门。 \n\n![0](https://i.loli.net/2018/02/19/5a8ac86221c4b.png)\n\n开关以以下两种方式控制阀门：\n- 当开关闭合时阀门打开，当开关断开时阀门关闭；\n- 当开关闭合时阀门关闭，当开关断开时阀门打开。\n\n玩了一会儿开关之后你突然意识到你的编程经历会十分有用。给出每个阀门被哪个开关所控制，判断是否可能关闭所有管道，如果可以，找出这种合法配置下每一个开关的状态。", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $m$，分别表示管道数和开关数。开关被从 $1$ 到 $m$ 标号。\n\n接下来的 $n$ 行描述管道，一行用四个整数 $a,s_a,b,s_b$ 描述一个管道，$a,b$ 代表控制该管道的开关（$1\\le a,b\\le m$）。$s_a$ 和 $s_b$ 为 $0$ 或 $1$，并与描述中的操作模式相符，$s_i=0$ 表示当且仅当开关 $i$ 断开时阀门关闭，$s_i=1$ 表示当且仅当开关 $i$ 闭合时阀门关闭。", "outputFormat": "如果有可能关闭所有管道，标准输出应包含 $m$ 行，如果开关 $i$ 断开，第 $i$ 行应输出 $0$，如果开关 $i$ 闭合，第 $i$ 行应输出 $1$。如果有很多可能的答案，你的程序可以输出任意一种。\n\n如果不可能关闭所有管道，你的程序应输出一行，包含一个单词 ``IMPOSSIBLE``。", "hint": "#### 数据范围\n\n对于 $30\\%$ 的数据，$n\\le 40$，$m\\le 20$。\n\n对于所有数据，$1\\le n\\le 2.5\\times 10^5$，$1\\le m\\le 5\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4660", "type": "P", "difficulty": 6, "samples": [["4\n0 7 1 6\n1 5 0 6", "2\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2008", "Special Judge", "BalticOI（波罗的海）"], "title": "[BalticOI 2008] 手套 (Day2)", "background": null, "description": "化学教授名曰“酸雨”。在他家黑暗的地下室，有两个装有手套的抽屉，一个抽屉装左手手套，另一个装右手手套。每个抽屉中有 $n$ 种不同颜色的手套。教授知道在每个抽屉中，每种颜色的手套数目（在不同抽屉中，相同颜色的手套数目可能不同）。保证他能够找到同色的一副手套。\n\n只有教授带相同颜色的一副手套时试验才可能会成功（与哪种颜色无关），所以在每次试验开始之前他都要去地下室从抽屉中拿手套，并且希望至少有一副一样颜色的手套。但是地下室太黑了，不出地下室就不可能分辨出任何手套的颜色。教授讨厌去地下室超过一次，同时也讨厌拿一堆手套回实验室（以防没有相同颜色的手套）。\n\n#### 任务\n\n写一个程序能够：\n- 从标准输入中读取颜色种数和每种颜色手套的数目；\n- 计算在确保拿出的手套中有一副颜色相同的手套的情况下需要取出手套的最小数目（需要明确指出从每个抽屉中取出手套的确切数目）；\n- 将结果写到标准输出。", "inputFormat": "标准输入的第一行包含一个正整数 $n$，描述不同的颜色种数。颜色从 $1$ 到 $n$ 编号。\n\n输入第二行包含 $n$ 个非负整数 $a_1,a_2,\\cdots ,a_n$，$a_i$ 表示在装左手手套的抽屉中第 $i$ 种颜色手套的数目。\n\n输入第三行包含 $n$ 个非负整数 $b_1,b_2,\\cdots ,b_n$，$b_i$ 表示在装右手手套的抽屉中第 $i$ 种颜色手套的数目。", "outputFormat": "标准输出第一行包含单独一个整数，表示从装左手手套抽屉中取出的手套数。第二行包含单独一个整数，表示从装右手手套抽屉中取出的手套数。这两个数的总和应尽量小。\n\n如果有多种正确答案，你的程序可以输出任意一组。", "hint": "对于 $40\\%$ 的数据，$n\\le 4$，$a_i,b_i\\le 10$。 \n\n对于全部数据，$1\\le n\\le 20$，$0\\le a_i,b_i\\le 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2008] Gloves (Day2)", "background": "", "description": "A chemistry professor named “Acid Rain” has a dark basement with two drawers of gloves: one drawer contains left-hand gloves, and the other contains right-hand gloves. Each drawer has gloves in $n$ different colors. The professor knows how many gloves of each color are in each drawer (the counts for the same color may differ between the two drawers). It is guaranteed that he can find at least one pair of gloves of the same color.\n\nAn experiment can succeed only if the professor wears a pair of gloves of the same color (the color does not matter). Therefore, before each experiment he goes to the basement to take gloves from the drawers, hoping to get at least one same-colored pair. However, the basement is so dark that he cannot distinguish the colors of any gloves unless he leaves the basement. The professor hates going to the basement more than once, and also hates bringing a large pile of gloves back to the lab (in case there is no same-colored pair).\n\n#### Task\n\nWrite a program that:\n- reads from standard input the number of colors and the number of gloves of each color;\n- computes the minimum total number of gloves that must be taken to guarantee that among the taken gloves there is at least one pair of the same color (and you must specify the exact number of gloves taken from each drawer);\n- writes the result to standard output.", "inputFormat": "The first line of standard input contains a positive integer $n$, the number of different colors. The colors are numbered from $1$ to $n$.\n\nThe second line contains $n$ non-negative integers $a_1,a_2,\\cdots ,a_n$, where $a_i$ is the number of gloves of color $i$ in the left-hand glove drawer.\n\nThe third line contains $n$ non-negative integers $b_1,b_2,\\cdots ,b_n$, where $b_i$ is the number of gloves of color $i$ in the right-hand glove drawer.", "outputFormat": "The first line of standard output contains a single integer: the number of gloves taken from the left-hand glove drawer. The second line contains a single integer: the number of gloves taken from the right-hand glove drawer. The sum of these two numbers should be as small as possible.\n\nIf there are multiple correct answers, your program may output any one of them.", "hint": "For $40\\%$ of the testdata, $n\\le 4$ and $a_i,b_i\\le 10$.\n\nFor all testdata, $1\\le n\\le 20$ and $0\\le a_i,b_i\\le 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2008] 手套 (Day2)", "background": null, "description": "化学教授名曰“酸雨”。在他家黑暗的地下室，有两个装有手套的抽屉，一个抽屉装左手手套，另一个装右手手套。每个抽屉中有 $n$ 种不同颜色的手套。教授知道在每个抽屉中，每种颜色的手套数目（在不同抽屉中，相同颜色的手套数目可能不同）。保证他能够找到同色的一副手套。\n\n只有教授带相同颜色的一副手套时试验才可能会成功（与哪种颜色无关），所以在每次试验开始之前他都要去地下室从抽屉中拿手套，并且希望至少有一副一样颜色的手套。但是地下室太黑了，不出地下室就不可能分辨出任何手套的颜色。教授讨厌去地下室超过一次，同时也讨厌拿一堆手套回实验室（以防没有相同颜色的手套）。\n\n#### 任务\n\n写一个程序能够：\n- 从标准输入中读取颜色种数和每种颜色手套的数目；\n- 计算在确保拿出的手套中有一副颜色相同的手套的情况下需要取出手套的最小数目（需要明确指出从每个抽屉中取出手套的确切数目）；\n- 将结果写到标准输出。", "inputFormat": "标准输入的第一行包含一个正整数 $n$，描述不同的颜色种数。颜色从 $1$ 到 $n$ 编号。\n\n输入第二行包含 $n$ 个非负整数 $a_1,a_2,\\cdots ,a_n$，$a_i$ 表示在装左手手套的抽屉中第 $i$ 种颜色手套的数目。\n\n输入第三行包含 $n$ 个非负整数 $b_1,b_2,\\cdots ,b_n$，$b_i$ 表示在装右手手套的抽屉中第 $i$ 种颜色手套的数目。", "outputFormat": "标准输出第一行包含单独一个整数，表示从装左手手套抽屉中取出的手套数。第二行包含单独一个整数，表示从装右手手套抽屉中取出的手套数。这两个数的总和应尽量小。\n\n如果有多种正确答案，你的程序可以输出任意一组。", "hint": "对于 $40\\%$ 的数据，$n\\le 4$，$a_i,b_i\\le 10$。 \n\n对于全部数据，$1\\le n\\le 20$，$0\\le a_i,b_i\\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P4661", "type": "P", "difficulty": 4, "samples": [["7 8 2 1\n0 0 2 6 1 1 0 0\n1 4 4 4 4 4 3 0\n2 4 4 4 4 4 3 0\n1 4 4 4 8 4 4 0\n0 3 4 4 4 4 4 3\n0 1 1 3 4 4 3 0\n0 0 0 1 2 1 2 0", "31"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2008", "二分", "枚举", "BalticOI（波罗的海）"], "title": "[BalticOI 2008] 网格 (Day2)", "background": null, "description": "Byteland 国的地图是一个大小为 $n\\times m$ 的网格（$n$ 是垂直方向长度，$m$ 是水平方向长度）。标记分隔的水平线被叫做平行线，并编号为 $0$ 到 $n$，标记分隔的垂直线被叫做子午线，并编号为 $0$ 到 $m$。\n\n在 Byteland 国，天气预报是一个十分严肃的话题，对于每个单元格，准备天气预报需要一定时间来计算。由于地形条件和其他因素，不同的单元格有着不同的计算时间。直到目前为止，预报系统还是会依次处理每一个单元格，所以完成预报天气需要花费的时间为计算所有单元的时间。\n\n你被要求设计一个可以在多进程处理器上运行的新系统，为了共享处理器的计算能力，Byteland 国要被 $r$ 条平行线和 $s$ 条子午线划分为 $(r+1)\\times (s+1)$ 个矩形。每个线程会依次处理一个矩形内部的单元格，这样的话对于一个矩形区域的计算时间，就为矩形区域内单元格计算时间之和。完成预报的计算时间是一个处理器上计算时间的最大值。\n\n你的任务是找到对于选择 $r$ 条平行线和 $s$ 条子午线分隔后最小的计算时间。\n\n#### 任务\n\n写一个程序能够：\n- 从标准输入读取 Byteland 的地图，要求的平行线和子午线条数以及每个单元格的处理时间；\n- 找到完成预报的最小计算时间；\n- 输出这个值到标准输出。", "inputFormat": "第一行包含四个正整数 $n,m,r,s$，由一个空格隔开。\n\n接下来 $n$ 行包含每一个单元格的计算时间 $c_{i,j}$。第 $i+1$ 行的第 $j$ 个数表示位于第 $i-1$ 和第 $i$ 条平行线，第 $j-1$ 和第 $j$ 条子午线之间的单元格需要的计算时间。", "outputFormat": "输出一行一个整数，表示最优的计算时间。", "hint": "#### 样例解释\n\n![0](https://i.loli.net/2018/02/19/5a8ae8ca02cbb.png)\n\n第二条和第四条平行线，第四条子午线把整个国家分为六个矩形，计算时间为 $21, 13, 27, 27, 17, 31$，所以完成预报的计算时间为 $31$。\n\n#### 数据范围\n\n对于 $40\\%$ 的数据，$n\\le 10,m\\le 10$。\n\n对于全部数据，$1\\le r<n\\le 18$，$1\\le s<m\\le 18$，$1\\le i\\le n$，$1\\le j\\le m$，$0\\le c_{i,j}\\le 2\\times 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2008] Grid (Day2)", "background": "", "description": "The map of the country of Byteland is a grid of size $n \\times m$ ($n$ is the vertical length and $m$ is the horizontal length). The labeled separating horizontal lines are called parallels and are numbered from $0$ to $n$. The labeled separating vertical lines are called meridians and are numbered from $0$ to $m$.\n\nIn Byteland, weather forecasting is a very serious topic. For each cell, preparing the forecast takes some time to compute. Due to terrain conditions and other factors, different cells require different computation times. Up to now, the forecasting system processes each cell one by one, so the total time to finish forecasting is the sum of the times for all cells.\n\nYou are asked to design a new system that can run on a multi-process processor. To share the processor's computing power, Byteland will be divided by $r$ parallels and $s$ meridians into $(r+1) \\times (s+1)$ rectangles. Each thread will process the cells inside one rectangle in order. Then, the computation time for a rectangle is the sum of the computation times of all cells inside that rectangle. The total time to finish the forecast is the maximum computation time among all processors.\n\nYour task is to find the minimum possible total time after choosing $r$ parallels and $s$ meridians to split the grid.\n\n#### Task\n\nWrite a program that:\n- reads from standard input the map of Byteland, the required numbers of parallels and meridians, and the processing time of each cell;\n- finds the minimum total time to finish the forecast;\n- outputs this value to standard output.", "inputFormat": "The first line contains four positive integers $n, m, r, s$, separated by a single space.\n\nThe next $n$ lines contain the computation time $c_{i,j}$ for each cell. The $j$-th number on line $i+1$ represents the time needed for the cell between the $(i-1)$-th and $i$-th parallels and between the $(j-1)$-th and $j$-th meridians.", "outputFormat": "Output one line with one integer, which is the optimal computation time.", "hint": "#### Sample Explanation\n\n![0](https://i.loli.net/2018/02/19/5a8ae8ca02cbb.png)\n\nThe 2nd and 4th parallels and the 4th meridian divide the whole country into six rectangles, with computation times $21, 13, 27, 27, 17, 31$, so the total time to finish the forecast is $31$.\n\n#### Constraints\n\nFor $40\\%$ of the testdata, $n \\le 10, m \\le 10$.\n\nFor all testdata, $1 \\le r < n \\le 18$, $1 \\le s < m \\le 18$, $1 \\le i \\le n$, $1 \\le j \\le m$, $0 \\le c_{i,j} \\le 2 \\times 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2008] 网格 (Day2)", "background": null, "description": "Byteland 国的地图是一个大小为 $n\\times m$ 的网格（$n$ 是垂直方向长度，$m$ 是水平方向长度）。标记分隔的水平线被叫做平行线，并编号为 $0$ 到 $n$，标记分隔的垂直线被叫做子午线，并编号为 $0$ 到 $m$。\n\n在 Byteland 国，天气预报是一个十分严肃的话题，对于每个单元格，准备天气预报需要一定时间来计算。由于地形条件和其他因素，不同的单元格有着不同的计算时间。直到目前为止，预报系统还是会依次处理每一个单元格，所以完成预报天气需要花费的时间为计算所有单元的时间。\n\n你被要求设计一个可以在多进程处理器上运行的新系统，为了共享处理器的计算能力，Byteland 国要被 $r$ 条平行线和 $s$ 条子午线划分为 $(r+1)\\times (s+1)$ 个矩形。每个线程会依次处理一个矩形内部的单元格，这样的话对于一个矩形区域的计算时间，就为矩形区域内单元格计算时间之和。完成预报的计算时间是一个处理器上计算时间的最大值。\n\n你的任务是找到对于选择 $r$ 条平行线和 $s$ 条子午线分隔后最小的计算时间。\n\n#### 任务\n\n写一个程序能够：\n- 从标准输入读取 Byteland 的地图，要求的平行线和子午线条数以及每个单元格的处理时间；\n- 找到完成预报的最小计算时间；\n- 输出这个值到标准输出。", "inputFormat": "第一行包含四个正整数 $n,m,r,s$，由一个空格隔开。\n\n接下来 $n$ 行包含每一个单元格的计算时间 $c_{i,j}$。第 $i+1$ 行的第 $j$ 个数表示位于第 $i-1$ 和第 $i$ 条平行线，第 $j-1$ 和第 $j$ 条子午线之间的单元格需要的计算时间。", "outputFormat": "输出一行一个整数，表示最优的计算时间。", "hint": "#### 样例解释\n\n![0](https://i.loli.net/2018/02/19/5a8ae8ca02cbb.png)\n\n第二条和第四条平行线，第四条子午线把整个国家分为六个矩形，计算时间为 $21, 13, 27, 27, 17, 31$，所以完成预报的计算时间为 $31$。\n\n#### 数据范围\n\n对于 $40\\%$ 的数据，$n\\le 10,m\\le 10$。\n\n对于全部数据，$1\\le r<n\\le 18$，$1\\le s<m\\le 18$，$1\\le i\\le n$，$1\\le j\\le m$，$0\\le c_{i,j}\\le 2\\times 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4662", "type": "P", "difficulty": 6, "samples": [["5 6\n5 3\n2\n4\n8\n3\n10\n1 5\n1 2\n2 4\n4 5\n2 3\n3 4", "1 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2008", "Special Judge", "最小割", "BalticOI（波罗的海）"], "title": "[BalticOI 2008] 黑手党 (Day0)", "background": null, "description": "Byteland 国警方收到了一条匿名举报，其中说当地黑帮老大正计划一次从港口到郊区仓库的运输。警方知道运输的时间并且知道运输需要用到国家的高速公路网。\n\n高速公路网包含双向的高速公路段，每个路段直接连着两个不同的收费站。一个收费站可能与很多其他的收费站相连。汽车只能通过收费站进入或离开高速公路网。据所知，黑帮会距港口边最近的收费站进入高速公路，从距仓库最近的收费站离开（不会在出高速后重新进入）。特警组位于选定的收费站处。当运输车辆进入被监控的收费站时，它就会被警察抓住。\n\n从这个角度看，最简单的办法就是在每个收费站处都安排特警班。然而，控制一个收费站需要特定的费用，每个收费站费用不同。警方想要让花费最小，所以他们需要制定一个收费站的最小控制集，这个集合满足两个条件：\n- 所有从港口到仓库的交通必须至少经过集合中的一个收费站；\n- 监控这些收费站的费用（即监控每一个收费站费用之和）最小。\n\n你可以假设使用高速公路可以从港口到仓库。\n\n#### 任务\n\n写一个程序能够：\n\n- 从标准输入中读取高速公路网，监控代价和运输的起点和终点；\n- 找到收费站的最小控制集；\n- 输出这个集合到标准输出。", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $m$，表示收费站的总数和公路段的总数。收费站按 $1$ 到 $n$ 标号。\n\n第二行包含两个整数 $a$ 和 $b$，分别表示距港口和仓库最近的两个收费站编号。\n\n接下来 $n$ 行表示控制费用，第 $i+2$ 行包含一个整数，表示第 $i$ 个收费站的控制费用 $c_i$。\n\n接下来 $m$ 行表示高速公路网，第 $j+n+2$ 行包含两个整数 $x_j$ 和 $y_j$，表示在 $x_j$ 和 $y_j$ 收费站之间有一条公路段相连。每一条高速公路段只出现一次。", "outputFormat": "唯一的一行输出应包含最小控制集中收费站的编号，以递增顺序输出，用一个空格分隔。\n\n如果有多于一个最小控制集，你的程序可以输出任意一个。", "hint": "#### 样例解释\n\n![0](https://i.loli.net/2018/02/19/5a8af2c2ef8d7.gif)\n\n这张图片显示了高速公路网中收费站的编号（在左上角）和控制费用。$1$ 号和 $4$ 号收费站组成了最小控制集，总控制费用为 $5$。\n\n#### 数据范围\n\n对于 $40\\%$ 的测试数据，$n\\le 20$。\n\n对于全部数据，$1\\le n\\le 200$，$1\\le m\\le 2\\times 10^4$，$1\\le a,b\\le n$，$a\\not= b$，$1\\le c_i\\le 10^7$，$1\\le x_j<y_j\\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2008] Mafia (Day0)", "background": "", "description": "The police in Byteland received an anonymous report saying that the local mafia boss is planning a transport from the port to a warehouse in the suburbs. The police know the time of the transport, and they know that the transport will use the country's highway network.\n\nThe highway network consists of bidirectional highway segments, and each segment directly connects two different toll stations. A toll station may be connected to many other toll stations. Cars can enter or leave the highway network only through toll stations. It is known that the mafia will enter the highway at the toll station closest to the port and leave at the toll station closest to the warehouse (they will not re-enter the highway after leaving). A special police unit will be stationed at selected toll stations. When the transport vehicle enters a monitored toll station, it will be caught by the police.\n\nFrom this point of view, the simplest way is to station a police unit at every toll station. However, controlling a toll station requires a certain cost, and the costs differ between stations. The police want the minimum total cost, so they need to determine a minimum control set of toll stations that satisfies two conditions:\n\n- Every route from the port to the warehouse must pass through at least one toll station in the set.\n- The total monitoring cost of these toll stations (i.e., the sum of the costs of all toll stations in the set) is minimal.\n\nYou may assume that it is possible to travel from the port to the warehouse using the highway network.\n\n#### Task\n\nWrite a program that:\n\n- reads the highway network, monitoring costs, and the start and end points of the transport from standard input;\n- finds a minimum control set of toll stations;\n- outputs this set to standard output.", "inputFormat": "The first line of standard input contains two integers $n$ and $m$, representing the total number of toll stations and the total number of highway segments. Toll stations are numbered from $1$ to $n$.\n\nThe second line contains two integers $a$ and $b$, representing the indices of the toll stations closest to the port and the warehouse, respectively.\n\nThe next $n$ lines describe the control costs. Line $i+2$ contains one integer, representing the control cost $c_i$ of toll station $i$.\n\nThe next $m$ lines describe the highway network. Line $j+n+2$ contains two integers $x_j$ and $y_j$, meaning there is a highway segment connecting toll stations $x_j$ and $y_j$. Each highway segment appears only once.", "outputFormat": "The only line of output should contain the indices of the toll stations in the minimum control set, in increasing order, separated by one space.\n\nIf there is more than one minimum control set, your program may output any one of them.", "hint": "#### Sample Explanation\n\n![0](https://i.loli.net/2018/02/19/5a8af2c2ef8d7.gif)\n\nThis image shows the toll station indices (in the top-left corner) and the control costs in the highway network. Toll stations $1$ and $4$ form a minimum control set, with a total control cost of $5$.\n\n#### Constraints\n\nFor $40\\%$ of the testdata, $n\\le 20$.\n\nFor all testdata, $1\\le n\\le 200$, $1\\le m\\le 2\\times 10^4$, $1\\le a,b\\le n$, $a\\not= b$, $1\\le c_i\\le 10^7$, $1\\le x_j<y_j\\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2008] 黑手党 (Day0)", "background": null, "description": "Byteland 国警方收到了一条匿名举报，其中说当地黑帮老大正计划一次从港口到郊区仓库的运输。警方知道运输的时间并且知道运输需要用到国家的高速公路网。\n\n高速公路网包含双向的高速公路段，每个路段直接连着两个不同的收费站。一个收费站可能与很多其他的收费站相连。汽车只能通过收费站进入或离开高速公路网。据所知，黑帮会距港口边最近的收费站进入高速公路，从距仓库最近的收费站离开（不会在出高速后重新进入）。特警组位于选定的收费站处。当运输车辆进入被监控的收费站时，它就会被警察抓住。\n\n从这个角度看，最简单的办法就是在每个收费站处都安排特警班。然而，控制一个收费站需要特定的费用，每个收费站费用不同。警方想要让花费最小，所以他们需要制定一个收费站的最小控制集，这个集合满足两个条件：\n- 所有从港口到仓库的交通必须至少经过集合中的一个收费站；\n- 监控这些收费站的费用（即监控每一个收费站费用之和）最小。\n\n你可以假设使用高速公路可以从港口到仓库。\n\n#### 任务\n\n写一个程序能够：\n\n- 从标准输入中读取高速公路网，监控代价和运输的起点和终点；\n- 找到收费站的最小控制集；\n- 输出这个集合到标准输出。", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $m$，表示收费站的总数和公路段的总数。收费站按 $1$ 到 $n$ 标号。\n\n第二行包含两个整数 $a$ 和 $b$，分别表示距港口和仓库最近的两个收费站编号。\n\n接下来 $n$ 行表示控制费用，第 $i+2$ 行包含一个整数，表示第 $i$ 个收费站的控制费用 $c_i$。\n\n接下来 $m$ 行表示高速公路网，第 $j+n+2$ 行包含两个整数 $x_j$ 和 $y_j$，表示在 $x_j$ 和 $y_j$ 收费站之间有一条公路段相连。每一条高速公路段只出现一次。", "outputFormat": "唯一的一行输出应包含最小控制集中收费站的编号，以递增顺序输出，用一个空格分隔。\n\n如果有多于一个最小控制集，你的程序可以输出任意一个。", "hint": "#### 样例解释\n\n![0](https://i.loli.net/2018/02/19/5a8af2c2ef8d7.gif)\n\n这张图片显示了高速公路网中收费站的编号（在左上角）和控制费用。$1$ 号和 $4$ 号收费站组成了最小控制集，总控制费用为 $5$。\n\n#### 数据范围\n\n对于 $40\\%$ 的测试数据，$n\\le 20$。\n\n对于全部数据，$1\\le n\\le 200$，$1\\le m\\le 2\\times 10^4$，$1\\le a,b\\le n$，$a\\not= b$，$1\\le c_i\\le 10^7$，$1\\le x_j<y_j\\le n$。", "locale": "zh-CN"}}}
{"pid": "P4663", "type": "P", "difficulty": 6, "samples": [["3 2 5", "XIX"], ["3 2 7", "NO SUCH STONE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2008", "BalticOI（波罗的海）"], "title": "[BalticOI 2008] 魔法石 (Day1)", "background": null, "description": "知名的石头 $\\text{Xi-n-k}$ 只能在 Wonderland 中找到，这样的石头只是一种碑文只有字母 ``X`` 和 ``I`` 的花岗岩板。每个石板包含 $n$ 个字母。每个石板上有不超过 $k$ 个位置 ``X`` 和 ``I`` 相邻。\n\n石板的顶部和底部不是固定的，所以石头可以旋转，变为倒立状态。例如下面这两个图片描述的是一样的石头。 \n\n![0](https://i.loli.net/2018/02/20/5a8ba0ad731f2.png)\n\n【看同样石头的两种方式。这种石头的种类是 $\\text{Xi-8-3}$，也是 $\\text{Xi-8-4}$（当然也可以是 $\\text{Xi-8-}k$，$k \\ge 3$）。】\n\n现在 Wonderland 中任意两块魔法石都不是一样的，即两块石头都没有相同的碑文（注意旋转 $180^\\circ$ 是允许的）。\n\n如果可以以两种不同方式（用旋转 $180^\\circ$ 的方式）读一块石头的碑文，那么对于这块石头，碑文的正规阅读方式被定义为两种阅读方式字典序小的那种。\n\n如果一块石头的碑文是对称的，即旋转 $180^\\circ$ 并不改变碑文，那么对于这块石头，碑文的的正规阅读方式被定义为这种独一无二的阅读方式。\n\n例如：有六种 $\\text{Xi-3-2}$ 魔法石，它们的正规阅读方式以字典序写出为：``III``，``IIX``，``IXI``，``IXX``，``XIX`` 和 ``XXX``。\n\nAlice 是一个研究 Wonderland 的魔法石的专家。她想要创建一个 $\\text{Xi-n-k}$ 魔法石的正规阅读方式字典（对于一些特定的 $n$ 和 $k$）。对于给出的 $i$，在字典中第 $i$ 个位置应该是什么碑文呢？\n\n##### 任务\n\n写一个程序能够：\n- 从标准输入中读取数字 $n$，$k$，$i$；\n- 判定对于 $\\text{Xi-n-k}$ 魔法石，第 $i$ 个正规阅读方式（按字典序）；\n- 输出结果到标准输出。", "inputFormat": "标准输入只有一行，包含三个整数 $n,k,i$，用一个空格分开。", "outputFormat": "标准输出只有一行，应该包含 $\\text{Xi-n-k}$ 魔法石，第 $i$ 个正规阅读方式（按字典序）。\n\n如果 $\\text{Xi-n-k}$ 魔法石的数量比 $i$ 小，那么只输出一行一个短语 ``NO SUCH STONE``。", "hint": "#### 数据范围与提示\n\n对于全部数据，$0\\le k<n\\le 60$，$0<i<10^{18}$。\n\n#### 说明\n\n注：我们说 $\\text{A}$ 的碑文字典序比 $\\text{B}$ 小（假设 $\\text{A}$ 和 $\\text{B}$ 的碑文长度相同），当且仅当在第一个碑文不同的位置 $\\text{A}$ 包含 ``I`` 且 $\\text{B}$ 包含 ``X``。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2008] Magic Stone (Day1)", "background": "", "description": "The famous stone $\\text{Xi-n-k}$ can only be found in Wonderland. Such a stone is a granite slab engraved with an inscription consisting only of the letters `X` and `I`. Each slab contains $n$ letters. On each slab, there are at most $k$ positions where `X` and `I` are adjacent.\n\nThe top and bottom of a slab are not fixed, so the stone can be rotated and become upside down. For example, the following two pictures describe the same stone.\n\n![0](https://i.loli.net/2018/02/20/5a8ba0ad731f2.png)\n\n【Two ways to view the same stone. This stone is of type $\\text{Xi-8-3}$, and also $\\text{Xi-8-4}$ (of course it can also be $\\text{Xi-8-}k$, $k \\ge 3$).】\n\nNow, in Wonderland, no two magic stones are the same, meaning that no two stones have the same inscription (note that a $180^\\circ$ rotation is considered the same).\n\nIf a stone’s inscription can be read in two different ways (by rotating it $180^\\circ$), then the standard way to read the inscription is defined as the lexicographically smaller of the two readings.\n\nIf a stone’s inscription is symmetric, meaning that rotating it $180^\\circ$ does not change the inscription, then the standard way to read the inscription is defined as this unique reading.\n\nFor example, there are six kinds of $\\text{Xi-3-2}$ magic stones. Their standard readings, written in lexicographical order, are: `III`, `IIX`, `IXI`, `IXX`, `XIX`, and `XXX`.\n\nAlice is an expert in studying magic stones in Wonderland. She wants to create a dictionary of standard readings of $\\text{Xi-n-k}$ magic stones (for some given $n$ and $k$). For a given $i$, what inscription should be at position $i$ in this dictionary?\n\n##### Task\n\nWrite a program that:\n- reads integers $n$, $k$, $i$ from standard input;\n- determines the $i$-th standard reading (in lexicographical order) among $\\text{Xi-n-k}$ magic stones;\n- outputs the result to standard output.", "inputFormat": "The standard input contains only one line with three integers $n,k,i$, separated by a single space.", "outputFormat": "The standard output contains only one line, which should be the $i$-th standard reading (in lexicographical order) of $\\text{Xi-n-k}$ magic stones.\n\nIf the number of $\\text{Xi-n-k}$ magic stones is smaller than $i$, output one line with the phrase `NO SUCH STONE`.", "hint": "#### Constraints and Hints\n\nFor all data, $0\\le k<n\\le 60$, $0<i<10^{18}$.\n\n#### Notes\n\nNote: We say the inscription of $\\text{A}$ is lexicographically smaller than that of $\\text{B}$ (assuming they have the same length) if and only if at the first position where they differ, $\\text{A}$ contains `I` and $\\text{B}$ contains `X`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2008] 魔法石 (Day1)", "background": null, "description": "知名的石头 $\\text{Xi-n-k}$ 只能在 Wonderland 中找到，这样的石头只是一种碑文只有字母 ``X`` 和 ``I`` 的花岗岩板。每个石板包含 $n$ 个字母。每个石板上有不超过 $k$ 个位置 ``X`` 和 ``I`` 相邻。\n\n石板的顶部和底部不是固定的，所以石头可以旋转，变为倒立状态。例如下面这两个图片描述的是一样的石头。 \n\n![0](https://i.loli.net/2018/02/20/5a8ba0ad731f2.png)\n\n【看同样石头的两种方式。这种石头的种类是 $\\text{Xi-8-3}$，也是 $\\text{Xi-8-4}$（当然也可以是 $\\text{Xi-8-}k$，$k \\ge 3$）。】\n\n现在 Wonderland 中任意两块魔法石都不是一样的，即两块石头都没有相同的碑文（注意旋转 $180^\\circ$ 是允许的）。\n\n如果可以以两种不同方式（用旋转 $180^\\circ$ 的方式）读一块石头的碑文，那么对于这块石头，碑文的正规阅读方式被定义为两种阅读方式字典序小的那种。\n\n如果一块石头的碑文是对称的，即旋转 $180^\\circ$ 并不改变碑文，那么对于这块石头，碑文的的正规阅读方式被定义为这种独一无二的阅读方式。\n\n例如：有六种 $\\text{Xi-3-2}$ 魔法石，它们的正规阅读方式以字典序写出为：``III``，``IIX``，``IXI``，``IXX``，``XIX`` 和 ``XXX``。\n\nAlice 是一个研究 Wonderland 的魔法石的专家。她想要创建一个 $\\text{Xi-n-k}$ 魔法石的正规阅读方式字典（对于一些特定的 $n$ 和 $k$）。对于给出的 $i$，在字典中第 $i$ 个位置应该是什么碑文呢？\n\n##### 任务\n\n写一个程序能够：\n- 从标准输入中读取数字 $n$，$k$，$i$；\n- 判定对于 $\\text{Xi-n-k}$ 魔法石，第 $i$ 个正规阅读方式（按字典序）；\n- 输出结果到标准输出。", "inputFormat": "标准输入只有一行，包含三个整数 $n,k,i$，用一个空格分开。", "outputFormat": "标准输出只有一行，应该包含 $\\text{Xi-n-k}$ 魔法石，第 $i$ 个正规阅读方式（按字典序）。\n\n如果 $\\text{Xi-n-k}$ 魔法石的数量比 $i$ 小，那么只输出一行一个短语 ``NO SUCH STONE``。", "hint": "#### 数据范围与提示\n\n对于全部数据，$0\\le k<n\\le 60$，$0<i<10^{18}$。\n\n#### 说明\n\n注：我们说 $\\text{A}$ 的碑文字典序比 $\\text{B}$ 小（假设 $\\text{A}$ 和 $\\text{B}$ 的碑文长度相同），当且仅当在第一个碑文不同的位置 $\\text{A}$ 包含 ``I`` 且 $\\text{B}$ 包含 ``X``。", "locale": "zh-CN"}}}
{"pid": "P4664", "type": "P", "difficulty": 5, "samples": [["4\n1 3 2 4", "2\n2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2008", "Special Judge", "背包 DP", "BalticOI（波罗的海）"], "title": "[BalticOI 2008] 选举 (Day2)", "background": null, "description": "Byteland 国的居民最近一直为议会选举投票。现在，当结果公布的时候，党派不得不决定联合组建政党。 \n\n每个党派都会获得议会中的一定席位。联合政党由这些党派中的一部分组成，他们在议会中的席位数之和**严格大于**总席位数的一半。对于联合政党来说，席位越多越好。\n\n一个**过剩**的联合政党是指联合政党中的一个党派被移出后，剩余的政党在国会中仍有过半数的席位。\n\n#### 任务\n\n请写一个程序能够：\n- 读取选举结果；\n- 找到一个在议会中有着**最大可能席位数**且**不过剩**的联合政党；\n- 输出这个联合政党的描述。", "inputFormat": "标准输入的第一行包含一个整数 $n$，表示参加选举的党派数。党派被从 $1$ 到 $n$ 编号。\n\n第二行包含 $n$ 个非负整数 $a_1,\\dots,a_n$，被一个空格隔开，第 $i$ 个整数 $a_i$ 是第 $i$ 个党派获得的席位数。你可以假设国会中的中的总席位数为小于等于 $10^5$ 的正整数。", "outputFormat": "标准输出的第一行应该包含一个整数 $k$，表示无过剩且在议会中有着最大可能席位数的联合政党中含有的党派数。\n\n第二行应该包含 $k$ 个被单个空格隔开的不同整数，表示组成联合政党的党派编号。\n\n如果有不止一个联合政党可以满足要求，你可以输出任意一个。党派的编号可以以任意顺序输出。", "hint": "对于 $40\\%$ 的数据，$n\\le 20$。\n\n对于全部数据，$1\\le n\\le 300$。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2008] Elections (Day2)", "background": null, "description": "The citizens of Byteland have recently been voting in the parliamentary elections. Now, when the results have been published, the parties have to decide on a coalition to form the government.\n\nEach party received a certain number of seats in the parliament. The coalition must be a subset of the parties such that together they have strictly more than half of all the seats in the parliament. It is desirable for the coalition to have as many seats as possible, to ensure they can still pass their proposed laws even if a few of their members are absent from a parliament session. A coalition is called redundant if one of its parties can be removed with the remaining ones still having more than half of the seats in the parliament. Of course, such a removable party would effectively have no power — the other members of the coalition would be able to force the laws regardless of its opinion.\n\n#### Task\n\nWrite a program that:\n- reads the election results from the standard input,\n- finds a non-redundant coalition that has the maximal possible number of seats in the parliament,\n- writes the description of this coalition to the standard output.", "inputFormat": "The first line of the standard input contains one integer $n\\ (1\\le n\\le 300)$ — the number of parties that participated in the elections. The parties are numbered from $1$ to $n$.\n\nThe second line contains n nonnegative integers $a_1,\\dots,a_n$, separated by single spaces, where $a_i$ is the number of seats received by the $i$-th party. You may assume that the total number of seats in the parliament will be positive and lower or equal to $100000$.\n\nAdditionally, in test cases worth $40\\%$ of points, the number of parties will not exceed $20$.", "outputFormat": "The first line of the standard output should contain one integer $k$ — the number of parties in a non-redundant coalition which has the maximal number of seats.\n\nThe second line should contain $k$ distinct integers separated by single spaces — the numbers of parties that form the coalition.\n\nIf there are several non-redundant coalitions with the maximal number of seats, you may output any of them. The member parties can be listed in any order.", "hint": "Resource: Baltic Olympiad in Informatics 2008.", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2008] 选举 (Day2)", "background": null, "description": "Byteland 国的居民最近一直为议会选举投票。现在，当结果公布的时候，党派不得不决定联合组建政党。 \n\n每个党派都会获得议会中的一定席位。联合政党由这些党派中的一部分组成，他们在议会中的席位数之和**严格大于**总席位数的一半。对于联合政党来说，席位越多越好。\n\n一个**过剩**的联合政党是指联合政党中的一个党派被移出后，剩余的政党在国会中仍有过半数的席位。\n\n#### 任务\n\n请写一个程序能够：\n- 读取选举结果；\n- 找到一个在议会中有着**最大可能席位数**且**不过剩**的联合政党；\n- 输出这个联合政党的描述。", "inputFormat": "标准输入的第一行包含一个整数 $n$，表示参加选举的党派数。党派被从 $1$ 到 $n$ 编号。\n\n第二行包含 $n$ 个非负整数 $a_1,\\dots,a_n$，被一个空格隔开，第 $i$ 个整数 $a_i$ 是第 $i$ 个党派获得的席位数。你可以假设国会中的中的总席位数为小于等于 $10^5$ 的正整数。", "outputFormat": "标准输出的第一行应该包含一个整数 $k$，表示无过剩且在议会中有着最大可能席位数的联合政党中含有的党派数。\n\n第二行应该包含 $k$ 个被单个空格隔开的不同整数，表示组成联合政党的党派编号。\n\n如果有不止一个联合政党可以满足要求，你可以输出任意一个。党派的编号可以以任意顺序输出。", "hint": "对于 $40\\%$ 的数据，$n\\le 20$。\n\n对于全部数据，$1\\le n\\le 300$。", "locale": "zh-CN"}}}
{"pid": "P4665", "type": "P", "difficulty": 5, "samples": [["6\n1 2\n2 3\n2 4\n5 4\n6 4", "2\n1 5\n3 6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["图论", "贪心", "2015", "Special Judge", "构造", "BalticOI（波罗的海）"], "title": "[BalticOI 2015] Network", "background": "", "description": "The government of Byteland has decided that it is time to connect their little country to the Internet, so that all citizens can participate in programming competitions and watch videos of cute cats. When it was time to build the network backbone of the country, they assigned the company Internet Optimists Inc. with connecting all the $N$ computers of Byteland. The connections were made as direct links between pairs of computers in such a way that any pair of computers are connected by a sequence of links.\n\nByteland is not a rich country by any means, so to minimize costs the network topology was built in the form of a tree (i.e. there are exactly $N-1$ direct links between computers). Far too late, it was realised that this solution suffers from a serious drawback. If just a single link is broken, the computers of Byteland will be partitioned so that some computers cannot communicate with each other! To improve the reliability of Byteland's network, it was decided that it should at least tolerate if a single link is broken. Your task is to help Internet Optimists Inc. to improve the network in a cheapest way. Given the network topology of Byteland (i.e. which $N-1$ pairs of computers are connected by direct links), find the minimum number of links that need to be added so that the network will still be connected if any single link is broken.", "inputFormat": "The first line of input contains a positive integer $N$ ( $N \\geq 3$ ) , the number of computers in Byteland. For simplicity, all computers are numbered from $1$ to $N$. Each of the following $N-1$ lines contains a pair of integers $a$ and $b$ ( $1\\leq a,b \\leq n,a \\ne b$ ) that describes a direct link between computers $a$ and $b$.", "outputFormat": "In the first line of output your program should write an integer $k$, the minimal number of links that should be added to the network. In each of the following $k$ lines your program should write a pair of integers $a$ and $b$ ( $1\\leq a,b \\leq n,a \\ne b$ ) that denote the numbers of computers that should be connected by a link. The links can be written in any order. If there is more than one solution, your program should output any one of them.", "hint": "$3 \\le N \\le 500000$", "locale": "en", "translations": {"en": {"title": "[BalticOI 2015] Network", "background": "", "description": "The government of Byteland has decided that it is time to connect their little country to the Internet, so that all citizens can participate in programming competitions and watch videos of cute cats. When it was time to build the network backbone of the country, they assigned the company Internet Optimists Inc. with connecting all the $N$ computers of Byteland. The connections were made as direct links between pairs of computers in such a way that any pair of computers are connected by a sequence of links.\n\nByteland is not a rich country by any means, so to minimize costs the network topology was built in the form of a tree (i.e. there are exactly $N-1$ direct links between computers). Far too late, it was realised that this solution suffers from a serious drawback. If just a single link is broken, the computers of Byteland will be partitioned so that some computers cannot communicate with each other! To improve the reliability of Byteland's network, it was decided that it should at least tolerate if a single link is broken. Your task is to help Internet Optimists Inc. to improve the network in a cheapest way. Given the network topology of Byteland (i.e. which $N-1$ pairs of computers are connected by direct links), find the minimum number of links that need to be added so that the network will still be connected if any single link is broken.", "inputFormat": "The first line of input contains a positive integer $N$ ( $N \\geq 3$ ) , the number of computers in Byteland. For simplicity, all computers are numbered from $1$ to $N$. Each of the following $N-1$ lines contains a pair of integers $a$ and $b$ ( $1\\leq a,b \\leq n,a \\ne b$ ) that describes a direct link between computers $a$ and $b$.", "outputFormat": "In the first line of output your program should write an integer $k$, the minimal number of links that should be added to the network. In each of the following $k$ lines your program should write a pair of integers $a$ and $b$ ( $1\\leq a,b \\leq n,a \\ne b$ ) that denote the numbers of computers that should be connected by a link. The links can be written in any order. If there is more than one solution, your program should output any one of them.", "hint": "$3 \\le N \\le 500000$", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2015] Network", "background": "", "description": "拜特朗政$ $府已经决定，现在是时候将他们的小国家与互联网连接起来，以便所有公民都能参加节目比赛，观看可爱猫的视频。当是时候建设这个国家的网络骨干时，他们给互联网乐观主义者公司分配了连接所有 $N$ 个拜特兰德的电脑。这些连接是作为计算机对之间的直接连接，使任何一对计算机都通过一系列的链接连接起来。\n\n拜特朗是一个发展中国家，因此，为了将成本降到最低，网络拓扑是以树的形式构建的(即有 $N-1$ 个计算机之间的直接连接)。为时已晚，人们意识到这一解决方案存在严重缺陷。如果只有一个链接断了，那么拜特兰德的计算机就会被分割，这样一些计算机就不能互相通信了！为了提高拜特朗网络的可靠性，人们决定至少要容忍单个链路中断。你的任务是帮助互联网乐观主义者公司以最便宜的方式改进网络。给出了拜特朗的网络拓扑(即 $N-1$ 个计算机对是通过直接链接连接的)，找到需要添加的最少数量的链接，以便如果任何单个链接中断，网络仍将被连接。", "inputFormat": "输入的第一行包含一个正整数 $N(N\\geq 3)$，表示拜特兰德的计算机数量。为了简单起见，所有的计算机都是从 $1$ 到 $N$。以下 $N-1$ 行包含一对整数。$a$ 和 $b(1≤a, b≤n, a\\neq b)$，它描述计算机之间的直接链接 $a$ 和 $b$。", "outputFormat": "在输出的第一行只有一个整数k，表示应该添加到网络中的最少链接数量。在下列每一项中都有对整数 $a$ 和 $b(1\\leq a ,b\\leq n,a\\neq b)$ 表示应该通过链接连接的计算机数量。链接可以按任何顺序写入。如果有一个以上的解决方案，您的程序应该输出其中的任何一个。", "hint": "$3 \\le N \\le 500000$。", "locale": "zh-CN"}}}
{"pid": "P4666", "type": "P", "difficulty": 6, "samples": [["5 7\n1 3 2 5 2\nF 2 1\nC 3 6\nF 2 3\nC 6 8\nF 2 1\nF 2 2\nC 3 5", "3\n0\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2011", "线段树", "平衡树", "BalticOI（波罗的海）"], "title": "[BalticOI 2011] Growing Trees (Day1)", "background": "", "description": "For fertilizing the trees he has several bottles of MegaBoostFertilizer, which, when treated on trees, causes them to grow one centimeter up instantly. Every bottle has a limited capacity $c_i$​​ , which determines the number of trees it can be applied to. Moreover, for each bottle there is a minimal height $h_i$ of trees, which can be treated with it. Since Egon wants to have all his trees as big as possible, he always applies the fertilizer to the $c_i$​​ smallest trees chosen from the trees that are at least $h_i$​​ centimeters high.\n\nWhen Egon computes statistics about trees he has to determine the number of trees whose height is in some given interval. Egon is quite busy working in the garden, so he asked you to write a program, that given the list of his tasks, computes the statistics for him. ", "inputFormat": "The first line of the standard input contains two integers $N$ and $M$ denoting the number of trees in Egon’s garden and the number of his tasks. The second line contains a sequence of $N$ integers fromthe range $[1,N]$ describing the initial heights of the trees in centimeters. The following $M$ lines describe the tasks in chronological order. Each of those lines begins with a character $t_i$ $(t_i=F \\ or \\ C)$, which describes the type of the task.\n\nIf $t_i=F$ then two integers $c_i$​​ and $h_i$ follow. Such a line means that Egon applies a bottle of MegaBoostFertilizer to the $c_i$ smallest trees among those trees that are at least $h_i$​​ centimeters high. When there are less than $c_i$​​ trees of sufficient height, he applies the fertilizer to all such trees and discards the bottle with some fertilizer remaining.\n\nIf $t_i=C$ then two integers $\\min_i$​​ and $\\max_i$​​ follow. They denote that Egon has to compute the number of trees whose height $H$ is between $\\min_i$ and $\\max_i$​​ centimeters $(\\min_i \\le H \\le \\max_i)$. ", "outputFormat": "For every task of type C, output one line containing the number of apple trees that have the required height. The order of the results should conform to the order of type C tasks in the input.", "hint": "$1 \\le N,M \\le 10^5,1 \\le c \\le N,0 \\le h \\le 10^9,1 \\le min \\le max \\le 10^9$。", "locale": "en", "translations": {"en": {"title": "[BalticOI 2011] Growing Trees (Day1)", "background": "", "description": "For fertilizing the trees he has several bottles of MegaBoostFertilizer, which, when treated on trees, causes them to grow one centimeter up instantly. Every bottle has a limited capacity $c_i$​​ , which determines the number of trees it can be applied to. Moreover, for each bottle there is a minimal height $h_i$ of trees, which can be treated with it. Since Egon wants to have all his trees as big as possible, he always applies the fertilizer to the $c_i$​​ smallest trees chosen from the trees that are at least $h_i$​​ centimeters high.\n\nWhen Egon computes statistics about trees he has to determine the number of trees whose height is in some given interval. Egon is quite busy working in the garden, so he asked you to write a program, that given the list of his tasks, computes the statistics for him. ", "inputFormat": "The first line of the standard input contains two integers $N$ and $M$ denoting the number of trees in Egon’s garden and the number of his tasks. The second line contains a sequence of $N$ integers fromthe range $[1,N]$ describing the initial heights of the trees in centimeters. The following $M$ lines describe the tasks in chronological order. Each of those lines begins with a character $t_i$ $(t_i=F \\ or \\ C)$, which describes the type of the task.\n\nIf $t_i=F$ then two integers $c_i$​​ and $h_i$ follow. Such a line means that Egon applies a bottle of MegaBoostFertilizer to the $c_i$ smallest trees among those trees that are at least $h_i$​​ centimeters high. When there are less than $c_i$​​ trees of sufficient height, he applies the fertilizer to all such trees and discards the bottle with some fertilizer remaining.\n\nIf $t_i=C$ then two integers $\\min_i$​​ and $\\max_i$​​ follow. They denote that Egon has to compute the number of trees whose height $H$ is between $\\min_i$ and $\\max_i$​​ centimeters $(\\min_i \\le H \\le \\max_i)$. ", "outputFormat": "For every task of type C, output one line containing the number of apple trees that have the required height. The order of the results should conform to the order of type C tasks in the input.", "hint": "$1 \\le N,M \\le 10^5,1 \\le c \\le N,0 \\le h \\le 10^9,1 \\le min \\le max \\le 10^9$。", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2011] Growing Trees (Day1)", "background": "", "description": "给出一个长度为 $N$ 的数组 $a$，数组中每个数的取值范围均为 $[1,N]$（没说互不相同）。\n接下来有 $M$ 组操作，操作分为两种：\n1. $\\texttt{F}\\:\\:c\\:\\:h$  \n将满足 $a[i] \\ge h$ 的所有 $a[i]$ 中最小的 $c$ 个数都 $+1$；\n2. $\\texttt{C}\\:\\:max\\:\\:min$  \n输出满足 $min \\le a[i] \\le max$ 的 $a[i]$ 的个数。", "inputFormat": "第一行有两个整数 $N$ 和 $M$。    \n第二行有 $N$ 个整数，表示数组 $a$。  \n在接下来的 $M$ 行中，每行有一组操作。", "outputFormat": "对于每组 $\\texttt{C}\\:\\:max\\:\\:min$ 操作输出一行，每行一个整数，表示满足 $min \\le a[i] \\le max$ 的 $a[i]$ 的个数。\n\n\n翻译提供者：Planet6174", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4667", "type": "P", "difficulty": 4, "samples": [["3 5\n\\\\/\\\\\n\\\\///\n/\\\\\\\\", "1"]], "limits": {"time": [150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "线段树", "广度优先搜索 BFS", "优先队列", "最短路", "BalticOI（波罗的海）"], "title": "[BalticOI 2011] Switch the Lamp On 电路维修 (Day1)", "background": "", "description": "Casper is designing an electronic circuit on a $N \\times M$ rectangular grid plate. There are $N \\times M$ square tiles that are aligned to the grid on the plate. Two (out of four) opposite corners of each tile are connected by a wire.\n\nA power source is connected to the top left corner of the plate. A lamp is connected to the bottom right corner of the plate. The lamp is on only if there is a path of wires connecting power source to lamp. In order to switch the lamp on, any number of tiles can be turned by 90° (in both directions).\n\n![0](http://ruanx.pw/bzojch/file/2346_0.jpg)\n\nIn the picture above the lamp is off. If any one of the tiles in the second column from the right is turned by 90° , power source and lamp get connected, and the lamp is on.\n\nWrite a program to find out the minimal number of tiles that have to be turned by 90° to switch the lamp on.", "inputFormat": "The first line of input contains two integer numbers $N$ and $M$, the dimensions of the plate. In each of the following $N$ lines there are $M$ symbols – either \\ or / – which indicate the direction of the wire connecting the opposite vertices of the corresponding tile.", "outputFormat": "There must be exactly one line of output. If it is possible to switch the lamp on, this line must contain only one integer number: the minimal number of tiles that have to be turned to switch on the lamp. If it is not possible, output the string: ``NO SOLUTION``", "hint": "对于 $40\\%$ 的数据，$1 \\le N \\le 4$，$1 \\le M \\le 5$。\n\n对于所有数据，$1 \\le N,M \\le 500$。", "locale": "en", "translations": {"en": {"title": "[BalticOI 2011] Switch the Lamp On 电路维修 (Day1)", "background": "", "description": "Casper is designing an electronic circuit on a $N \\times M$ rectangular grid plate. There are $N \\times M$ square tiles that are aligned to the grid on the plate. Two (out of four) opposite corners of each tile are connected by a wire.\n\nA power source is connected to the top left corner of the plate. A lamp is connected to the bottom right corner of the plate. The lamp is on only if there is a path of wires connecting power source to lamp. In order to switch the lamp on, any number of tiles can be turned by 90° (in both directions).\n\n![0](http://ruanx.pw/bzojch/file/2346_0.jpg)\n\nIn the picture above the lamp is off. If any one of the tiles in the second column from the right is turned by 90° , power source and lamp get connected, and the lamp is on.\n\nWrite a program to find out the minimal number of tiles that have to be turned by 90° to switch the lamp on.", "inputFormat": "The first line of input contains two integer numbers $N$ and $M$, the dimensions of the plate. In each of the following $N$ lines there are $M$ symbols – either \\ or / – which indicate the direction of the wire connecting the opposite vertices of the corresponding tile.", "outputFormat": "There must be exactly one line of output. If it is possible to switch the lamp on, this line must contain only one integer number: the minimal number of tiles that have to be turned to switch on the lamp. If it is not possible, output the string: ``NO SOLUTION``", "hint": "对于 $40\\%$ 的数据，$1 \\le N \\le 4$，$1 \\le M \\le 5$。\n\n对于所有数据，$1 \\le N,M \\le 500$。", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2011] Switch the Lamp On (Day1)", "background": null, "description": "Casper 在一个 $N\\times M$ 的电路板上设计电路。有一种正方形的电路元件，在它的两组相对顶点中，有一组会用导线连接起来，另一组则不会。有 $N\\times M$ 个这样的元件，你想将其排列成 $N$ 行，每行 $M$ 个。 电源连接到板的左上角。灯连接到板的右下角。只有在电源和灯之间有一条电线连接的情况下，灯才会亮着。为了打开灯，任何数量的电路元件都可以转动 90°（两个方向）。\n\n![](https://cdn.luogu.com.cn/upload/pic/1286.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/1285.png)\n\n在上面的图片中，灯是关着的。如果从右往左数第二列的任何一个电路元件被旋转 90°，电源和灯都会连接，灯被打开。现在请你编写一个程序，求出最小需要旋转多少电路元件。", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$，表示电路板的尺寸。 在以下 $N$ 行中，每一行有 $M$ 个符号 `\\` 或 `/`，表示连接对应电路元件对角线的导线的方向。", "outputFormat": "如果可以打开灯，那么输出只包含一个整数，表示最少转动电路元件的数量。\n\n如果不可能打开灯，输出 `NO SOLUTION`。", "hint": "对于 $40\\%$ 的数据，$1 \\le N \\le 4$，$1 \\le M \\le 5$。\n\n对于所有数据，$1 \\le N,M \\le 500$。", "locale": "zh-CN"}}}
{"pid": "P4668", "type": "P", "difficulty": 4, "samples": [["5 7\nY.....V\n..I....\n..IIIII\n.......\n...T...", "YES"], ["5 7\nY....V.\n..I....\n..IIIII\n.......\n...T...", "NO"], ["2 3\n.YT\nVII", "NO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["搜索", "2011", "BalticOI（波罗的海）"], "title": "[BalticOI 2011] Treasures and Vikings (Day1)", "background": "", "description": "You have a treasure map that is arranged into a $N \\times M$ grid. A grid square may be either sea or part of an island. In addition, the map shows the treasure and an enemy Viking ship that occupies one (sea) square. Finally, for convenience you have also drawn your own position.\n\nNow you must set up a fixed route to get the treasure. The route must start at your position, end at the treasure, and consist of a sequence of moves. In each move, you can go only to an (horizontally or vertically) adjacent square that is not part of an island. But beware: The Viking ship might follow you, using the same kind of moves! After each of your moves according to your route, the Viking ship may move or not. Your move and the Vikings’ reaction together is called a round.\n\nAfter every round, the following checks are made:\n\n-    If you are in line with the Viking ship (you are in the same vertical or horizontal line as the Viking ship with only sea between the Viking ship and you), you are dead.\n-    If you aren’t dead and at the treasure-spot, you get the treasure.\n\nWrite a program that decides whether it is possible to set up a fixed route in advance such that you can get the treasure by following this route and will not get killed by the Vikings – no matter how the Viking ship moves.", "inputFormat": "The first line of input contains two integers $N$ and $M$, the dimensions of the map. Each of the following $N$ lines contain $M$ characters. Each character describes a square in the map, and is either ``.`` (sea), ``I`` (part of an island), ``V`` (the Viking ship), ``Y`` (your position), or ``T`` (the treasure). Each of ``V``, ``Y``, and ``T`` will occur exactly once.", "outputFormat": "The only line of the output must contain the string ``YES``, if it is possible to set up a route to get the treasure, or ``NO`` otherwise.", "hint": "**Sample Explanation 1**\n\nThe route is:go down for three times,go right for three times too,go down at last.\n\n**数据范围**\n\n对于 $50\\%$ 的数据，$1 \\le N,M \\le 200$。\n\n对于所有数据，$1 \\le N,M \\le 700$。", "locale": "en", "translations": {"en": {"title": "[BalticOI 2011] Treasures and Vikings (Day1)", "background": "", "description": "You have a treasure map that is arranged into a $N \\times M$ grid. A grid square may be either sea or part of an island. In addition, the map shows the treasure and an enemy Viking ship that occupies one (sea) square. Finally, for convenience you have also drawn your own position.\n\nNow you must set up a fixed route to get the treasure. The route must start at your position, end at the treasure, and consist of a sequence of moves. In each move, you can go only to an (horizontally or vertically) adjacent square that is not part of an island. But beware: The Viking ship might follow you, using the same kind of moves! After each of your moves according to your route, the Viking ship may move or not. Your move and the Vikings’ reaction together is called a round.\n\nAfter every round, the following checks are made:\n\n-    If you are in line with the Viking ship (you are in the same vertical or horizontal line as the Viking ship with only sea between the Viking ship and you), you are dead.\n-    If you aren’t dead and at the treasure-spot, you get the treasure.\n\nWrite a program that decides whether it is possible to set up a fixed route in advance such that you can get the treasure by following this route and will not get killed by the Vikings – no matter how the Viking ship moves.", "inputFormat": "The first line of input contains two integers $N$ and $M$, the dimensions of the map. Each of the following $N$ lines contain $M$ characters. Each character describes a square in the map, and is either ``.`` (sea), ``I`` (part of an island), ``V`` (the Viking ship), ``Y`` (your position), or ``T`` (the treasure). Each of ``V``, ``Y``, and ``T`` will occur exactly once.", "outputFormat": "The only line of the output must contain the string ``YES``, if it is possible to set up a route to get the treasure, or ``NO`` otherwise.", "hint": "**Sample Explanation 1**\n\nThe route is:go down for three times,go right for three times too,go down at last.\n\n**数据范围**\n\n对于 $50\\%$ 的数据，$1 \\le N,M \\le 200$。\n\n对于所有数据，$1 \\le N,M \\le 700$。", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2011] Treasures and Vikings (Day1)", "background": "", "description": "你有一张藏宝图，这张地图被划分为一个 $N \\times M$ 的网格。一个网格可能是海洋或者是岛屿的一部分。此外，地图上标出了宝藏和占据一个（海洋）方格的敌方维京船。最后，为了方便起见，你还标出了你自己的位置。\n\n现在你必须设置一条固定的路线去获得宝藏。路线必须从你的起始位置开始，以宝藏为终点，并由一系列移动组成。在每次移动中，你只能移动到一个（水平或垂直）相邻的非岛屿方格。但要小心：维京船可能会跟随你，使用相同的移动方式！在你按照路线进行每次移动后，维京船可能会移动也可能不动。你的移动和维京船的反应合称为一轮。\n\n在每轮之后，进行以下检查：\n\n- 如果你与维京船在同一条直线上（你与维京船在同一垂直或水平线上，并且中间只有海洋），你就死了。\n- 如果你没有死并且在宝藏点上，你就获得了宝藏。\n\n编写一个程序来决定是否可以提前设置一条固定路线，使你可以通过这条路线获得宝藏，并且不会被维京人杀死——无论维京船如何移动。", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$，表示地图的尺寸。接下来的 $N$ 行中的每一行包含 $M$ 个字符。每个字符描述地图上的一个方格，可以是 ``.``（海洋）、``I``（岛屿的一部分）、``V``（维京船）、``Y``（你的位置）或 ``T``（宝藏）。``V``、``Y`` 和 ``T`` 各出现一次。", "outputFormat": "输出的唯一一行必须包含字符串 ``YES``，如果可以设置一条路线来获得宝藏；否则输出 ``NO``。", "hint": "**样例解释 1**\n\n路线是：向下走三次，向右走三次，最后再向下走一次。\n\n**数据范围**\n\n对于 $50\\%$ 的数据，$1 \\le N,M \\le 200$。\n\n对于所有数据，$1 \\le N,M \\le 700$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4669", "type": "P", "difficulty": 5, "samples": [["9 1 1", "8"], ["6 1 2", "8"], ["6 2 1", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "贪心", "2011", "枚举", "BalticOI（波罗的海）"], "title": "[BalticOI 2011] Meetings (Day2)", "background": "", "description": "The Society for Saving the World has called their $N$ members to an emergency congress to finally agree on a plan for saving the world. To reach a common decision in any meeting at the congress, the meeting participants proceed as follows:\n\n1.    Each of them has a proposal and takes $P$ minutes to present it to the others.\n\n2.    After all participants have made their presentations, they vote for the best proposal, which takes $V$ minutes.\n\nFor example, if each proposal takes one minute $(P = 1)$ and voting also takes one minute $(V = 1)$, a meeting with $100$ participants would reach a decision in $101$ minutes. To speed up the overall decision-making process, the participants of the congress have decided to split into groups and work in parallel. Each group selects the best proposal among themselves using the procedure described above. Then the representatives of the groups meet and pick the final plan among the proposals voted best in each group. For example, if the $100$ participants would split into two groups of $40$ and $60$, respectively, the process could work as follows (again, $P = V = 1$):\n\n-    the larger group takes $61$ minutes to select their best proposal;\n-    the smaller group takes $41$ minutes to do the same and then has to wait for the larger group to finish;\n-    then the two representatives of the groups meet and spend $2$ minutes presenting to each other and $1$ minute to vote.\n\nThe total time spent is thus $61 + 2 + 1 = 64$ minutes. But the groups might further divide themselves into subgroups and sometimes it could be useful to split into more than two groups. As a special case, a subgroup of $1$ member can decide in no time, as there is no need to present one’s own proposal to oneself. Write a program that, given presentation and voting times $P$ and $V$ , computes the minimal time needed for the $N$ participants of the congress to reach a common decision, assuming they organize their meetings and groups optimally.", "inputFormat": "The first and only line of input contains the three integers $N, P,$ and $V$ : $N$ is the number of participants of the congress, $P$ is the presentation time (in minutes), and $V$ is the voting time (in minutes).", "outputFormat": "The first and only line of output should contain the integer $M$, the minimal number of minutes needed for the congress to reach a decision.", "hint": "**Sample Explanation 1**\n\nIn sample 1,the nine people should be divided into 3 groups.There should be 3 people in each group.\n\n**数据范围**\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 5000$。\n\n对于 $70\\%$ 的数据，$1 \\le N \\le 5 \\times 10^4$。\n\n对于所有数据，$1 \\le N \\le 10^{15},1 \\le P,V \\le 1000$。 ", "locale": "en", "translations": {"en": {"title": "[BalticOI 2011] Meetings (Day2)", "background": "", "description": "The Society for Saving the World has called their $N$ members to an emergency congress to finally agree on a plan for saving the world. To reach a common decision in any meeting at the congress, the meeting participants proceed as follows:\n\n1.    Each of them has a proposal and takes $P$ minutes to present it to the others.\n\n2.    After all participants have made their presentations, they vote for the best proposal, which takes $V$ minutes.\n\nFor example, if each proposal takes one minute $(P = 1)$ and voting also takes one minute $(V = 1)$, a meeting with $100$ participants would reach a decision in $101$ minutes. To speed up the overall decision-making process, the participants of the congress have decided to split into groups and work in parallel. Each group selects the best proposal among themselves using the procedure described above. Then the representatives of the groups meet and pick the final plan among the proposals voted best in each group. For example, if the $100$ participants would split into two groups of $40$ and $60$, respectively, the process could work as follows (again, $P = V = 1$):\n\n-    the larger group takes $61$ minutes to select their best proposal;\n-    the smaller group takes $41$ minutes to do the same and then has to wait for the larger group to finish;\n-    then the two representatives of the groups meet and spend $2$ minutes presenting to each other and $1$ minute to vote.\n\nThe total time spent is thus $61 + 2 + 1 = 64$ minutes. But the groups might further divide themselves into subgroups and sometimes it could be useful to split into more than two groups. As a special case, a subgroup of $1$ member can decide in no time, as there is no need to present one’s own proposal to oneself. Write a program that, given presentation and voting times $P$ and $V$ , computes the minimal time needed for the $N$ participants of the congress to reach a common decision, assuming they organize their meetings and groups optimally.", "inputFormat": "The first and only line of input contains the three integers $N, P,$ and $V$ : $N$ is the number of participants of the congress, $P$ is the presentation time (in minutes), and $V$ is the voting time (in minutes).", "outputFormat": "The first and only line of output should contain the integer $M$, the minimal number of minutes needed for the congress to reach a decision.", "hint": "**Sample Explanation 1**\n\nIn sample 1,the nine people should be divided into 3 groups.There should be 3 people in each group.\n\n**数据范围**\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 5000$。\n\n对于 $70\\%$ 的数据，$1 \\le N \\le 5 \\times 10^4$。\n\n对于所有数据，$1 \\le N \\le 10^{15},1 \\le P,V \\le 1000$。 ", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2011] Meetings (Day2)", "background": "", "description": "拯救世界协会召集了他们的 $N$ 名成员参加紧急会议，以最终商定一个拯救世界的计划。为了在会议上达成共识，参与者按如下步骤进行：\n\n1. 每个人都有一个提案，并花费 $P$ 分钟向其他人展示。\n2. 在所有参与者完成展示后，他们会投票选出最佳提案，这需要 $V$ 分钟。\n\n例如，如果每个提案需要一分钟（$P = 1$），投票也需要一分钟（$V = 1$），那么有 $100$ 名参与者的会议将在 $101$ 分钟内达成决议。为了加快整体决策过程，会议的参与者决定分成小组并行工作。每个小组使用上述程序选出自己的最佳提案。然后，各小组的代表会面，从每个小组投票选出的最佳提案中选出最终计划。例如，如果 $100$ 名参与者分成两个小组，分别为 $40$ 人和 $60$ 人，过程可能如下（同样，$P = V = 1$）：\n\n- 较大组花费 $61$ 分钟选出他们的最佳提案；\n- 较小组花费 $41$ 分钟做同样的事情，然后必须等待较大组完成；\n- 然后两个小组的代表会面，花费 $2$ 分钟互相展示，$1$ 分钟投票。\n\n因此，总共花费的时间是 $61 + 2 + 1 = 64$ 分钟。但小组可能会进一步分成子小组，有时分成两个以上的小组可能更有用。作为一个特例，一个成员的小组可以立即做出决定，因为不需要向自己展示自己的提案。编写一个程序，给定展示和投票时间 $P$ 和 $V$，计算出会议的 $N$ 名参与者在最优组织会议和小组情况下达成共识所需的最少时间。", "inputFormat": "输入的第一行也是唯一一行包含三个整数 $N, P, V$：$N$ 是会议的参与者人数，$P$ 是展示时间（以分钟为单位），$V$ 是投票时间（以分钟为单位）。", "outputFormat": "输出的第一行也是唯一一行应包含整数 $M$，即会议达成决议所需的最少分钟数。", "hint": "**样例解释 1**\n\n在样例 1 中，九个人应分成 3 组。每组应有 3 个人。\n\n**数据范围**\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 5000$。\n\n对于 $70\\%$ 的数据，$1 \\le N \\le 5 \\times 10^4$。\n\n对于所有数据，$1 \\le N \\le 10^{15},1 \\le P,V \\le 1000$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4670", "type": "P", "difficulty": 3, "samples": [["2\n2 1", "0"], ["5\n1 1 1 1 1", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "BalticOI（波罗的海）"], "title": "[BalticOI 2011] Plagiarism (Day2)", "background": "", "description": "The participants of the World Programming Competition submitted $N$ solution files $f_1 ,...,f_N$ to the grading system. Before accepting the results as final, the jury would like to rule out any possibility of plagiarism. They have a program that takes two files and compares them to decide if they are too similar to each other.\n\nHowever, the number of files is rather big and it would take too much time to compare all pairs. On the other hand, many pairs could be quickly eliminated based on the fact that the file sizes are too different.\n\nMore precisely, the jury decided to fully skip comparing every pair where the size of the smaller file is less than 90% of the size of the larger one. So, the comparison program has to examine only those distinct pairs of files $(f_i, f_j)$ where $i≠j, size(f_i) \\le size(f_j)$ and $size(f_i) \\ge 0.9 \\times size(f_j)$.\n\nWrite a program that computes the number of pairs of files that will have to be examined.", "inputFormat": "The first line of input contains the integer $N$, the number of solution files submitted. The second line contains $N$ integers $size(f_1),\\cdots,size(f_N)$, each showing the size of one file.", "outputFormat": "The first and only line of output must contain one integer, the number of pairs of files that will have to be examined.", "hint": "对于 $50\\%$ 的数据，$1 \\le N \\le 2000$。\n\n对于所有数据，$1 \\le N \\le 10^5,1 \\le f_i \\le 10^8$。", "locale": "en", "translations": {"en": {"title": "[BalticOI 2011] Plagiarism (Day2)", "background": "", "description": "The participants of the World Programming Competition submitted $N$ solution files $f_1 ,...,f_N$ to the grading system. Before accepting the results as final, the jury would like to rule out any possibility of plagiarism. They have a program that takes two files and compares them to decide if they are too similar to each other.\n\nHowever, the number of files is rather big and it would take too much time to compare all pairs. On the other hand, many pairs could be quickly eliminated based on the fact that the file sizes are too different.\n\nMore precisely, the jury decided to fully skip comparing every pair where the size of the smaller file is less than 90% of the size of the larger one. So, the comparison program has to examine only those distinct pairs of files $(f_i, f_j)$ where $i≠j, size(f_i) \\le size(f_j)$ and $size(f_i) \\ge 0.9 \\times size(f_j)$.\n\nWrite a program that computes the number of pairs of files that will have to be examined.", "inputFormat": "The first line of input contains the integer $N$, the number of solution files submitted. The second line contains $N$ integers $size(f_1),\\cdots,size(f_N)$, each showing the size of one file.", "outputFormat": "The first and only line of output must contain one integer, the number of pairs of files that will have to be examined.", "hint": "对于 $50\\%$ 的数据，$1 \\le N \\le 2000$。\n\n对于所有数据，$1 \\le N \\le 10^5,1 \\le f_i \\le 10^8$。", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2011] Plagiarism (Day2)", "background": null, "description": "世界编程竞赛的参与者向评分系统提交了 $N$ 个解决方案文件 $f_1 ,...,f_N$。在接受结果为最终结果之前，评审团希望排除任何抄袭的可能性。他们有一个程序，可以将两个文件进行比较，以决定它们是否过于相似。然而，文件的数量相当大，比较所有对将花费太多时间。另一方面，许多对可以基于文件大小差异过大而快速排除。更确切地说，评审团决定完全跳过比较每一对，其中较小文件的大小小于较大文件大小的 90%。因此，比较程序只需检查那些不同的文件对 $(f_i, f_j)$，其中 $i \n\\ne j, size(f_i) \\le size(f_j)$ 且 $size(f_i) \\ge 0.9 \\times size(f_j)$。编写一个程序来计算需要检查的文件对的数量。", "inputFormat": "输入的第一行包含整数 $N$，表示提交的解决方案文件的数量。第二行包含 $N$ 个整数 $size(f_1),\\cdots,size(f_N)$，每个整数表示一个文件的大小。", "outputFormat": "输出的第一行且唯一一行必须包含一个整数，即需要检查的文件对的数量。", "hint": "对于 $50\\%$ 的数据，$1 \\le N \\le 2000$。对于所有数据，$1 \\le N \\le 10^5,1 \\le f_i \\le 10^8$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4671", "type": "P", "difficulty": 3, "samples": [["3\n5 1\n2 4\n1 1", "10.0"], ["5\n0 0\n-2 2\n-2 -1\n2 -2\n2 0", "12.5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2011", "Special Judge", "BalticOI（波罗的海）"], "title": "[BalticOI 2011] Polygon (Day2)", "background": "", "description": "A simple polygon with $N$ vertices is drawn on an infinite rectangular grid. For such a polygon, only neighboring edges touch at their common vertex; no other of its edges intersect or touch. All vertices of the polygon lie on grid points, i.e., vertices have integer coordinates.\n\nYour task is to find the total length of grid line segments which lie strictly inside the given polygon (these line segments are highlighted in the drawings below).", "inputFormat": "The first line of input contains a single integer $N$, the number of vertices of the polygon. Each of the following $N$ lines contains two integers $x$ and $y$, the coordinates of one vertex. The vertices are given either in clockwise or counterclockwise order. All vertices are distinct, but more than two consecutive vertices may lie on a line.", "outputFormat": "The only line of output must contain a decimal number: the total length of grid line segments which lie strictly inside the given polygon.", "hint": "**Sample Explanation 1**\n\nThe length of horizontal lines is $\\frac{4}{3} + \\frac{8}{3} = 4$. The length of vertical lines is $3 + 2 + 1 = 6$. The total length is $4 + 6 = 10$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3hnegtvj.png)\n\n**Sample Explanation 2**\n\nThe length of horizontal lines is $1+2+4 = 7$. The length of vertical lines is $\\frac{9}{4}+\\frac{3}{2}+\\frac{7}{4} = 5.5$. The total length is $7 + 5.5 = 12.5$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8can7qby.png)\n\n**数据范围**\n\n对于 $50\\%$ 的数据，多边形所有的边均在网格线上。\n\n对于所有数据，$3 \\le N \\le 10^5,-5 \\times 10^8 \\le x,y \\le 5 \\times 10^8$。", "locale": "en", "translations": {"en": {"title": "[BalticOI 2011] Polygon (Day2)", "background": "", "description": "A simple polygon with $N$ vertices is drawn on an infinite rectangular grid. For such a polygon, only neighboring edges touch at their common vertex; no other of its edges intersect or touch. All vertices of the polygon lie on grid points, i.e., vertices have integer coordinates.\n\nYour task is to find the total length of grid line segments which lie strictly inside the given polygon (these line segments are highlighted in the drawings below).", "inputFormat": "The first line of input contains a single integer $N$, the number of vertices of the polygon. Each of the following $N$ lines contains two integers $x$ and $y$, the coordinates of one vertex. The vertices are given either in clockwise or counterclockwise order. All vertices are distinct, but more than two consecutive vertices may lie on a line.", "outputFormat": "The only line of output must contain a decimal number: the total length of grid line segments which lie strictly inside the given polygon.", "hint": "**Sample Explanation 1**\n\nThe length of horizontal lines is $\\frac{4}{3} + \\frac{8}{3} = 4$. The length of vertical lines is $3 + 2 + 1 = 6$. The total length is $4 + 6 = 10$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3hnegtvj.png)\n\n**Sample Explanation 2**\n\nThe length of horizontal lines is $1+2+4 = 7$. The length of vertical lines is $\\frac{9}{4}+\\frac{3}{2}+\\frac{7}{4} = 5.5$. The total length is $7 + 5.5 = 12.5$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8can7qby.png)\n\n**数据范围**\n\n对于 $50\\%$ 的数据，多边形所有的边均在网格线上。\n\n对于所有数据，$3 \\le N \\le 10^5,-5 \\times 10^8 \\le x,y \\le 5 \\times 10^8$。", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2011] Polygon (Day2)", "background": null, "description": "在一个无限的矩形网格上画了一个有 $N$ 个顶点的简单多边形。对于这样的多边形，只有相邻的边在它们的公共顶点处相接；没有其他边相交或接触。多边形的所有顶点都位于网格点上，即顶点具有整数坐标。\n\n你的任务是找到严格位于给定多边形内部的网格线段的总长度（这些线段在下面的图中被高亮显示）。", "inputFormat": "输入的第一行包含一个整数 $N$，表示多边形的顶点数。接下来的 $N$ 行中的每一行包含两个整数 $x$ 和 $y$，表示一个顶点的坐标。顶点按顺时针或逆时针顺序给出。所有顶点都是不同的，但可能有多个连续的顶点位于一条线上。", "outputFormat": "输出的唯一一行必须包含一个小数：严格位于给定多边形内部的网格线段的总长度。", "hint": "**样例解释 1**\n\n水平线的长度是 $\\frac{4}{3} + \\frac{8}{3} = 4$。垂直线的长度是 $3 + 2 + 1 = 6$。总长度是 $4 + 6 = 10$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3hnegtvj.png)\n\n**样例解释 2**\n\n水平线的长度是 $1+2+4 = 7$。垂直线的长度是 $\\frac{9}{4}+\\frac{3}{2}+\\frac{7}{4} = 5.5$。总长度是 $7 + 5.5 = 12.5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8can7qby.png)\n\n**数据范围**\n\n对于 $50\\%$ 的数据，多边形的所有边均在网格线上。\n\n对于所有数据，$3 \\le N \\le 10^5,-5 \\times 10^8 \\le x,y \\le 5 \\times 10^8$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4672", "type": "P", "difficulty": 7, "samples": [["7 7\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 1", "NO"], ["6 6\n1 2\n2 3\n2 4\n3 5\n4 5\n5 6", "YES"], ["22 28\n13 8\n8 1\n1 22\n1 12\n1 14\n13 18\n13 4\n4 20\n20 7\n13 15\n15 3\n15 9\n9 16\n9 19\n22 5\n12 5\n14 5\n5 11\n11 6\n18 6\n7 10\n10 17\n17 6\n3 21\n21 6\n16 2\n19 2\n2 21", "YES"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2011", "BalticOI（波罗的海）"], "title": "[BalticOI 2011] Tree Mirroring (Day2)", "background": "", "description": "Let $T$ be a rooted tree (a connected undirected acylic graph), and let $S$ be a perfect copy of $T$. Construct a new graph by taking the union of $T$ and $S$, and merging the corresponding leaf nodes (but never the root). We call such a graph a tree-mirrored graph.", "inputFormat": "The first line of input contains two integers $N$ and $M$, the number of vertices and edges of a graph $G$. The vertices in $G$ are labeled from $1$ to $N$. The following $M$ lines describe the edges. Each such line contains two integers $x$ and $y(x≠y;1 \\le x,y \\le N)$, describing one edge. There will be at most one edge between any pair of vertices.", "outputFormat": "The first and only line of output should contain the string ``YES`` if the graph $G$ is a tree-mirrored graph, and ``NO`` otherwise.", "hint": "对于 $30\\%$ 的数据，$3 \\le N,M \\le 300$。\n\n对于 $60\\%$ 的数据，$3 \\le N,M \\le 3500$。\n\n对于所有数据，$3 \\le N,M \\le 10^5$。", "locale": "en", "translations": {"en": {"title": "[BalticOI 2011] Tree Mirroring (Day2)", "background": "", "description": "Let $T$ be a rooted tree (a connected undirected acylic graph), and let $S$ be a perfect copy of $T$. Construct a new graph by taking the union of $T$ and $S$, and merging the corresponding leaf nodes (but never the root). We call such a graph a tree-mirrored graph.", "inputFormat": "The first line of input contains two integers $N$ and $M$, the number of vertices and edges of a graph $G$. The vertices in $G$ are labeled from $1$ to $N$. The following $M$ lines describe the edges. Each such line contains two integers $x$ and $y(x≠y;1 \\le x,y \\le N)$, describing one edge. There will be at most one edge between any pair of vertices.", "outputFormat": "The first and only line of output should contain the string ``YES`` if the graph $G$ is a tree-mirrored graph, and ``NO`` otherwise.", "hint": "对于 $30\\%$ 的数据，$3 \\le N,M \\le 300$。\n\n对于 $60\\%$ 的数据，$3 \\le N,M \\le 3500$。\n\n对于所有数据，$3 \\le N,M \\le 10^5$。", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2011] Tree Mirroring (Day2)", "background": null, "description": "对于一棵树 $T$，并复制一棵与 $T$ 同构的树 $S$。构造一个新的图 $T'$，新图 $T'$ 通过合并 $T$ 和 $S$ 中相应的非根叶节点得到。我们称这样的图为树之镜像图。\n\n给定一个图 $G$，你需要判断 $G$ 是否是树之镜像图。", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$，表示图 $G$ 的顶点和边数。\n\n接下来有 $M$ 行，每一行包含两个正整数 $x$ 和 $y$（$x \\neq y$ 且 $1 \\leq x,y \\leq n$）表示顶点 $x$ 和 $y$ 之间有一条边。保证没有重边。", "outputFormat": "输出只有一行，判断图 $G$ 是否是一个树之镜像图，是输出 `YES`，否则输出 `NO`。\n\nTranslated by @找寻", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4673", "type": "P", "difficulty": 4, "samples": [["3 6 2 100\n1 3 10 20 30 40\n3 2 32 35 95 95\n1 1 1 1 7 8\n1 3 8 8 9 9\n2 2 98 98 99 99\n1 2 0 0 99 101", "32"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2005", "拓扑排序", "BalticOI（波罗的海）"], "title": "[BalticOI 2005] Bus Trip (Day2)", "background": null, "description": "有 $N$ 座城镇，和城镇之间的 $M$ 条单向直达的巴士线路（没有中间停靠站）。城镇从 $1$ 到 $N$ 标号。一个旅行者在 $0$ 时刻位于 $1$ 号城镇，想要到达 $P$ 号城镇。他将乘坐巴士在 $T$ 时刻到达 $P$ 号城镇。如果他早到了，他必须等待。\n\n对于任意一个巴士线路 $i$，我们知道其中的出发地城镇 $s_i$ 和目的地城镇 $t_i$。我们也同样知道 $i$ 的出发时间和到达时间，但仅仅是近似值：我们知道巴士离开出发地城镇 $s_i$ 在时间范围 $[a_i, b_i]$ 内，且到达目的地城镇 $t_i$ 在时间范围 $[c_i, d_i]$ 内（端点值包括在内）。\n\n旅行者不喜欢等待，因此他要寻找一个旅行计划使得最大等待时间尽量小，同时保证绝对不会错过计划中的任何一辆巴士（意思是，每次他换乘巴士，他需要下车的巴士的最晚到达时间不会迟于他需要搭乘的下一辆巴士的最早出发时间）。\n\n当计算等待时间时，我们必须假设最早可能到达的时间和最晚可能发车的时间。\n\n编写一个程序，帮助旅行者寻找一个合适的计划。", "inputFormat": "第一行包含整数 $N,M,P,T$，含义见题目描述。\n\n接下来 $M$ 行描述了巴士线路。每行包含整数 $s_i, t_i, a_i, b_i, c_i, d_i$，其中 $s_i$ 和 $t_i$ 是巴士线路 $i$ 的出发地和目的地，$a_i, b_i, c_i, d_i$ 描述了出发和到达时间。", "outputFormat": "仅一行，包含对于最合适的可能的旅行计划的最大的可能的总等待时间。如果不可能保证在 $T$ 时刻到达城镇 $P$，这一行应当包含 `-1`。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\leq P \\leq N \\leq 5\\times 10^4$，$1 \\leq M \\leq 10^5$，$0 \\leq T \\leq 10^9$，$1 \\leq s_i,t_i \\leq N$，$0 \\leq a_i \\leq b_i < c_i \\leq d_i \\leq 10^9$。\n\n#### 说明\n\n翻译自 [BalticOI 2005 Day2 B Bus Trip](https://boi.cses.fi/files/boi2005_day2.pdf)。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2005] Bus Trip (Day2)", "background": "", "description": "There are $N$ towns and $M$ one-way direct bus routes between the towns (with no intermediate stops). The towns are numbered from $1$ to $N$. A traveler is in town $1$ at time $0$ and wants to reach town $P$. He will arrive at town $P$ at time $T$ by taking buses. If he arrives earlier, he must wait.\n\nFor each bus route $i$, we know its starting town $s_i$ and destination town $t_i$. We also know its departure and arrival times, but only approximately: we know the bus leaves the starting town $s_i$ within the time interval $[a_i, b_i]$, and arrives at the destination town $t_i$ within the time interval $[c_i, d_i]$ (endpoints included).\n\nThe traveler dislikes waiting, so he wants to find a travel plan that minimizes the maximum waiting time, while also guaranteeing that he will never miss any bus in the plan (that is, each time he transfers, the latest possible arrival time of the bus he gets off is not later than the earliest possible departure time of the next bus he needs to take).\n\nWhen computing waiting time, we must assume the earliest possible arrival time and the latest possible departure time.\n\nWrite a program to help the traveler find a suitable plan.", "inputFormat": "The first line contains integers $N, M, P, T$, as described above.\n\nThe next $M$ lines describe the bus routes. Each line contains integers $s_i, t_i, a_i, b_i, c_i, d_i$, where $s_i$ and $t_i$ are the starting town and destination of route $i$, and $a_i, b_i, c_i, d_i$ describe the departure and arrival times.", "outputFormat": "Output one line containing the maximum possible total waiting time for the best possible travel plan. If it is impossible to guarantee arrival at town $P$ at time $T$, this line should contain `-1`.", "hint": "#### Constraints\n\nFor $100\\%$ of the testdata, $1 \\leq P \\leq N \\leq 5\\times 10^4$, $1 \\leq M \\leq 10^5$, $0 \\leq T \\leq 10^9$, $1 \\leq s_i, t_i \\leq N$, $0 \\leq a_i \\leq b_i < c_i \\leq d_i \\leq 10^9$.\n\n#### Notes\n\nTranslated from [BalticOI 2005 Day2 B Bus Trip](https://boi.cses.fi/files/boi2005_day2.pdf)。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2005] Bus Trip (Day2)", "background": null, "description": "有 $N$ 座城镇，和城镇之间的 $M$ 条单向直达的巴士线路（没有中间停靠站）。城镇从 $1$ 到 $N$ 标号。一个旅行者在 $0$ 时刻位于 $1$ 号城镇，想要到达 $P$ 号城镇。他将乘坐巴士在 $T$ 时刻到达 $P$ 号城镇。如果他早到了，他必须等待。\n\n对于任意一个巴士线路 $i$，我们知道其中的出发地城镇 $s_i$ 和目的地城镇 $t_i$。我们也同样知道 $i$ 的出发时间和到达时间，但仅仅是近似值：我们知道巴士离开出发地城镇 $s_i$ 在时间范围 $[a_i, b_i]$ 内，且到达目的地城镇 $t_i$ 在时间范围 $[c_i, d_i]$ 内（端点值包括在内）。\n\n旅行者不喜欢等待，因此他要寻找一个旅行计划使得最大等待时间尽量小，同时保证绝对不会错过计划中的任何一辆巴士（意思是，每次他换乘巴士，他需要下车的巴士的最晚到达时间不会迟于他需要搭乘的下一辆巴士的最早出发时间）。\n\n当计算等待时间时，我们必须假设最早可能到达的时间和最晚可能发车的时间。\n\n编写一个程序，帮助旅行者寻找一个合适的计划。", "inputFormat": "第一行包含整数 $N,M,P,T$，含义见题目描述。\n\n接下来 $M$ 行描述了巴士线路。每行包含整数 $s_i, t_i, a_i, b_i, c_i, d_i$，其中 $s_i$ 和 $t_i$ 是巴士线路 $i$ 的出发地和目的地，$a_i, b_i, c_i, d_i$ 描述了出发和到达时间。", "outputFormat": "仅一行，包含对于最合适的可能的旅行计划的最大的可能的总等待时间。如果不可能保证在 $T$ 时刻到达城镇 $P$，这一行应当包含 `-1`。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\leq P \\leq N \\leq 5\\times 10^4$，$1 \\leq M \\leq 10^5$，$0 \\leq T \\leq 10^9$，$1 \\leq s_i,t_i \\leq N$，$0 \\leq a_i \\leq b_i < c_i \\leq d_i \\leq 10^9$。\n\n#### 说明\n\n翻译自 [BalticOI 2005 Day2 B Bus Trip](https://boi.cses.fi/files/boi2005_day2.pdf)。", "locale": "zh-CN"}}}
{"pid": "P4674", "type": "P", "difficulty": 5, "samples": [["4\n1 4\n3 1 3 4\n2 1 2\n1 3\n", "8"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "O2优化", "BalticOI（波罗的海）"], "title": "[BalticOI 2016] Bosses (day1)", "background": "", "description": "A company of $n$ employees is due for a restructuring. In the resulting hierarchy,represented as a rooted tree, every node will be the boss of its children.\n\nEach employee has a list of bosses they will accept. In addition, all employees mustbe assigned a salary. The salary must be a positive integer, and the salary of eachboss must be larger than the sum of salaries of their immediate subordinates.\n\nYour task is to structure the company so that all above conditions hold, and the sumof all the salaries is as small as possible.", "inputFormat": "The first input line contains an integer $n$ : the number of employees. The employees are numbered $1,2,...,n$\n\n.After this, the input contains $n$ lines that describe the preferences of the employees.The $i$th such line contains an integer $k_i$ , followed by a list of $k_i$ integers. The list consists of all employees that the $i$th employee accepts as their boss.", "outputFormat": "You should output the lowest total salary among all valid restructurings. You can assume that at least one solution exists.", "hint": "### Subtask 1 (22 points)\n\n- $2\\leq n \\leq 10$\n\n- $\\sum^n_{i=1}k_i\\leq 20$\n\n### Subtask 2 (45 points)\n\n- $2\\leq n \\leq 100$\n\n- $\\sum^n_{i=1}k_i\\leq 200$\n\n### Subtask 3 (33 points)\n\n- $2\\leq n \\leq 5000$\n\n- $\\sum^n_{i=1}k_i\\leq 10000$", "locale": "en", "translations": {"en": {"title": "[BalticOI 2016] Bosses (day1)", "background": "", "description": "A company of $n$ employees is due for a restructuring. In the resulting hierarchy,represented as a rooted tree, every node will be the boss of its children.\n\nEach employee has a list of bosses they will accept. In addition, all employees mustbe assigned a salary. The salary must be a positive integer, and the salary of eachboss must be larger than the sum of salaries of their immediate subordinates.\n\nYour task is to structure the company so that all above conditions hold, and the sumof all the salaries is as small as possible.", "inputFormat": "The first input line contains an integer $n$ : the number of employees. The employees are numbered $1,2,...,n$\n\n.After this, the input contains $n$ lines that describe the preferences of the employees.The $i$th such line contains an integer $k_i$ , followed by a list of $k_i$ integers. The list consists of all employees that the $i$th employee accepts as their boss.", "outputFormat": "You should output the lowest total salary among all valid restructurings. You can assume that at least one solution exists.", "hint": "### Subtask 1 (22 points)\n\n- $2\\leq n \\leq 10$\n\n- $\\sum^n_{i=1}k_i\\leq 20$\n\n### Subtask 2 (45 points)\n\n- $2\\leq n \\leq 100$\n\n- $\\sum^n_{i=1}k_i\\leq 200$\n\n### Subtask 3 (33 points)\n\n- $2\\leq n \\leq 5000$\n\n- $\\sum^n_{i=1}k_i\\leq 10000$", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2016] Bosses (day1)", "background": null, "description": "[BalticOI 2016 Day1]上司们\n\n\n一家有 $n$ 名员工的公司将进行重组。在重组后的层级结构中（表示为一棵有根树），每个节点将作为其子节点的上司。\n\n每位员工都有一个可以接受的上司列表。此外，所有员工都必须被分配一个薪水。薪水必须是一个正整数，并且每位上司的薪水必须大于其直接下属薪水之和。\n\n你的任务是安排公司的结构，以确保满足上述所有条件，并且所有员工的薪水总和尽可能小。", "inputFormat": "第一行输入包含一个整数 $n$ ，表示员工数量。员工编号为 $1, 2, \\dots, n$。（$n\\leq 5000$）\n\n接下来的 $n$ 行描述每个员工的上司偏好。第 $i$ 行包含一个整数 $k_i$，后跟一个 $k_i$ 整数的列表。该列表包括第 $i$ 位员工可以接受的所有上司的编号。", "outputFormat": "你需要输出所有符合条件的重组方案中，最低的薪水总和。可以假设至少存在一种可行方案。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4675", "type": "P", "difficulty": 5, "samples": [["5 3\n16 11\n11 8 1\n6 10 1\n7 3 2\n10 4 1\n15 5 1\n1 1\n2 2\n2 1\n", "1234\n2\n14\n"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "O2优化", "BalticOI（波罗的海）"], "title": "[BalticOI 2016] Park (day1)", "background": "", "description": "In the capital of Byteland, there is a fenced park whose area is a rectangle. The trees and the visitors in the park are represented as circles.\n\nThere are four entrances in the park, one in each corner (1 = bottom-left, 2 =bottom-right, 3 = top-right, 4 = top-left). The visitors can enter and exit the park only through the entrances.\n\nVisitors can enter and exit the park when they touch both sides of a corner of the corresponding entrance. Visitors can move freely in the park, but they cannot overlap any of the trees or the fence.\n\nYour task is to calculate for each visitor, given the entrance they will enter the park,through which entrances they can exit the park.", "inputFormat": "The first input line contains two integers $w$ and $h$ : the number of trees in the park and the number of visitors.\n\nThe second input line contains two integers $w$ and $h$ : the width and the height of the park area. The bottom-left corner is $(0,0)$, and the top-right corner is $(w,h)$.\n\nAfter this, there are  lines that describe the trees. Each line contains three integers, $x,y$ and $r$ : the center of the tree is $(x,y)$ and its radius is $r$. The trees do not overlap each other or the fence.\n\nFinally, there are $m$ lines that describe the visitors. Each line contains two integers $r$ and $e$ : the radius of the visitor and the entrance they will enter the park.\n\nIn addition, no tree overlaps a square area of $2k\\times2k$ in each corner, where $k$ is the radius of the largest visitor.", "outputFormat": "You should output for each visitor a single line containing the entrances through which they can exit the park, in sorted order without spaces in between.", "hint": "Two objects touch if they have one common point. Two objects overlap if they have more than one common point.\n\n## 样例解释\n\nThe following figure shows the entrance areas and possible routes for each visitor:\n\n![](https://cdn.luogu.com.cn/upload/pic/20869.png)\n\n## Subtasks\n\nIn all subtasks $4k\\leq w,h\\leq10^9$ where $k$ is the radius of the largest visitor.\n\n### Subtask 1 (27 points)\n\n- $1\\leq n\\leq2000$\n\n- $m=1$\n\n### Subtask 2 (31 points)\n\n- $1\\leq n\\leq200$\n\n- $1\\leq m\\leq10^5$\n\n### Subtask 3 (42 points)\n\n- $1\\leq n\\leq2000$\n\n- $1\\leq m\\leq10^5$\n", "locale": "en", "translations": {"en": {"title": "[BalticOI 2016] Park (day1)", "background": "", "description": "In the capital of Byteland, there is a fenced park whose area is a rectangle. The trees and the visitors in the park are represented as circles.\n\nThere are four entrances in the park, one in each corner (1 = bottom-left, 2 =bottom-right, 3 = top-right, 4 = top-left). The visitors can enter and exit the park only through the entrances.\n\nVisitors can enter and exit the park when they touch both sides of a corner of the corresponding entrance. Visitors can move freely in the park, but they cannot overlap any of the trees or the fence.\n\nYour task is to calculate for each visitor, given the entrance they will enter the park,through which entrances they can exit the park.", "inputFormat": "The first input line contains two integers $w$ and $h$ : the number of trees in the park and the number of visitors.\n\nThe second input line contains two integers $w$ and $h$ : the width and the height of the park area. The bottom-left corner is $(0,0)$, and the top-right corner is $(w,h)$.\n\nAfter this, there are  lines that describe the trees. Each line contains three integers, $x,y$ and $r$ : the center of the tree is $(x,y)$ and its radius is $r$. The trees do not overlap each other or the fence.\n\nFinally, there are $m$ lines that describe the visitors. Each line contains two integers $r$ and $e$ : the radius of the visitor and the entrance they will enter the park.\n\nIn addition, no tree overlaps a square area of $2k\\times2k$ in each corner, where $k$ is the radius of the largest visitor.", "outputFormat": "You should output for each visitor a single line containing the entrances through which they can exit the park, in sorted order without spaces in between.", "hint": "Two objects touch if they have one common point. Two objects overlap if they have more than one common point.\n\n## 样例解释\n\nThe following figure shows the entrance areas and possible routes for each visitor:\n\n![](https://cdn.luogu.com.cn/upload/pic/20869.png)\n\n## Subtasks\n\nIn all subtasks $4k\\leq w,h\\leq10^9$ where $k$ is the radius of the largest visitor.\n\n### Subtask 1 (27 points)\n\n- $1\\leq n\\leq2000$\n\n- $m=1$\n\n### Subtask 2 (31 points)\n\n- $1\\leq n\\leq200$\n\n- $1\\leq m\\leq10^5$\n\n### Subtask 3 (42 points)\n\n- $1\\leq n\\leq2000$\n\n- $1\\leq m\\leq10^5$\n", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2016] Park (day1)", "background": "", "description": "在 Byteland 的首都，有一个以围墙包裹的矩形公园，其中以圆形表示游客和树。  \n公园里有四个入口，分别在四个角落（$1, 2, 3, 4$ 分别对应左下、右下、右上、左上）。游客只能从入口进出。  \n游客可以在他们与公园的两邻边相切的时候进出对应的入口。游客可以在公园里自由活动但不允许与树重叠。  \n你的任务是为每个游客计算，给定他们进入公园的入口，他们可以从哪个入口离开公园。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，分别为树的个数和游客的个数。  \n第二行包含两个整数 $w$ 和 $h$，公园的左下角在 $(0,0)$，右上角在 $(w,h)$。  \n接下来 $n$ 行，每行三个整数 $x,y$ 和 $r$，表示有一棵圆心在 $(x,y)$ 且半径为 $r$ 的树。保证树与树之间不会互相重叠。  \n接下来 $m$ 行，每行两个整数 $r$ 和 $e$，表示有一个半径为 $r$ 的游客从入口 $e$ 进入。  \n此外，保证没有树会与每个角落的一个大小为 $2k^2$ 的方形区域重叠，$k$ 表示最大的游客半径。", "outputFormat": "对于每个游客，输出没有空格的一行，表示该游客可以从这几个入口离开，按照升序排列。", "hint": "两个物体有重叠定义为它们不止一个公共点。\n\n下图展示了每个游客的入口和可能的路线：\n\n![](https://i.loli.net/2018/08/11/5b6e30c4b5a35.png)\n\n对于每个子任务，$4k \\leq w,h \\leq 10^9$，$k$表示最大的游客半径。\n\n|子任务|分数|数据范围|\n|:-:|:-:|-|\n|1|27|$1 \\leq n \\leq 2000,m=1$|\n|2|31|$1 \\leq n \\leq 200,1 \\leq m \\leq 10^5$|\n|3|42|$1 \\leq n \\leq 2000,1 \\leq m \\leq 10^5$|\n\n由 @I_love_him52 提供翻译", "locale": "zh-CN"}}}
{"pid": "P4676", "type": "P", "difficulty": 5, "samples": [["2 3\n0 -2 1 1\n-1 0 1 0\n1 2 1 2\n", "74\n9\n14\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500], "memory": [256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "BalticOI（波罗的海）"], "title": "[BalticOI 2016] Spiral (day1)", "background": "", "description": "A grid of size $(2n+1)\\times(2n+1)$ has been constructed as follows. Number $1$ has been placed in the center square, number $2$ has been placed to the right of it, and the following numbers have been placed along the spiral counterclockwise.\n\nYour task is to calculate answers for $q$ queries where the sum of numbers in an rectangular region in the grid is requested (modulo $10^9+7$). For example, in the following grid $n=2$ and the sum of numbers in the gray region is $74$ :\n\n![](https://cdn.luogu.com.cn/upload/pic/20871.png)", "inputFormat": "The first input line contains two integers $n$ and $q$ : the size of the grid and the number of queries.\n\nAfter this, there are $q$ lines, each containing four integers $x_1, y_1, x_2$  and $y_2$ ($-n\\leq x_1\\leq x_2\\leq n, -n\\leq y_1\\leq y_2\\leq n$). This means that you should calculate the sum of numbers in a rectangular region with corners $(x_1,y_1)$ and $(x_2,y_2)$.", "outputFormat": "You should output the answer for each query (modulo $10^9+7$).\n", "hint": "## Subtasks\n\nIn all subtasks $1\\leq q\\leq100$.\n\n### Subtask 1 (12 points)\n\n- $1\\leq n\\leq1000$\n\n### Subtask 2 (15 points)\n\n- $1\\leq n\\leq10^9$\n\n- $x_1=x_2$ and $y_1=y_2$\n\n### Subtask 3 (17 points)\n\n- $1\\leq n\\leq10^5$\n\n### Subtask 4 (31 points)\n\n- $1\\leq n\\leq10^9$\n\n- $x_1=y_1=1$\n\n### Subtask 5 (25 points)\n\n- $1\\leq n\\leq10^9$\n", "locale": "en", "translations": {"en": {"title": "[BalticOI 2016] Spiral (day1)", "background": "", "description": "A grid of size $(2n+1)\\times(2n+1)$ has been constructed as follows. Number $1$ has been placed in the center square, number $2$ has been placed to the right of it, and the following numbers have been placed along the spiral counterclockwise.\n\nYour task is to calculate answers for $q$ queries where the sum of numbers in an rectangular region in the grid is requested (modulo $10^9+7$). For example, in the following grid $n=2$ and the sum of numbers in the gray region is $74$ :\n\n![](https://cdn.luogu.com.cn/upload/pic/20871.png)", "inputFormat": "The first input line contains two integers $n$ and $q$ : the size of the grid and the number of queries.\n\nAfter this, there are $q$ lines, each containing four integers $x_1, y_1, x_2$  and $y_2$ ($-n\\leq x_1\\leq x_2\\leq n, -n\\leq y_1\\leq y_2\\leq n$). This means that you should calculate the sum of numbers in a rectangular region with corners $(x_1,y_1)$ and $(x_2,y_2)$.", "outputFormat": "You should output the answer for each query (modulo $10^9+7$).\n", "hint": "## Subtasks\n\nIn all subtasks $1\\leq q\\leq100$.\n\n### Subtask 1 (12 points)\n\n- $1\\leq n\\leq1000$\n\n### Subtask 2 (15 points)\n\n- $1\\leq n\\leq10^9$\n\n- $x_1=x_2$ and $y_1=y_2$\n\n### Subtask 3 (17 points)\n\n- $1\\leq n\\leq10^5$\n\n### Subtask 4 (31 points)\n\n- $1\\leq n\\leq10^9$\n\n- $x_1=y_1=1$\n\n### Subtask 5 (25 points)\n\n- $1\\leq n\\leq10^9$\n", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2016] Spiral (day1)", "background": null, "description": "[BalticOI 2016 Day1]螺旋\n\n\n一个矩阵的大小为 $(2n+1)\\times (2n+1)$，我们们通过下述方法填数：数字 $1$ 在中心，数字 $2$ 在其右，其他数字依次按照逆时针螺旋摆放。\n\n你的任务是对于 $q$ 个询问，计算出一个给定子矩阵所有数字的和对 $(10^9+7)$ 取余的结果。比如以下 $n=2$ 的矩阵，灰色区域的数字之和为 $74$：\n\n![](https://i.loli.net/2018/08/11/5b6e3ead24175.png)", "inputFormat": "第一行，两个整数 $n$ 和 $q$，分别表示矩阵的大小和询问的个数。\n\n接下来 $q$ 行，每行四个整数 $x_1,y_1,x_2$ 和 $y_2$ $(-n \\leq x_1 \\leq x_2 \\leq n,$ $-n \\leq y_1 \\leq y_2 \\leq n)$。这表示你需要计算一个对角为 $(x_1,y_1)$ 和 $(x_2,y_2)$ 的子矩阵的数字之和。", "outputFormat": "对于每个询问，输出一行表示答案（对 $10^9+7$ 取余）。\n\n由 @I_love_him52 提供翻译", "hint": "#### Subtask 1 (12 points)\n\n- $1 \\leq n \\leq 1000$\n\n#### Subtask 2 (15 points)\n\n- $1 \\leq n \\leq 10^9$\n\n- $x_1 = x_2$ and $y_1 = y_2$\n\n#### Subtask 3 (17 points)\n\n- $1 \\leq n \\leq 10^5$\n\n#### Subtask 4 (31 points)\n\n- $1 \\leq n \\leq 10^9$\n\n- $x_1 = y_1 = 1$\n\n#### Subtask 5 (25 points)\n\n- $1 \\leq n \\leq 10^9$\n\n对于 $100 \\%$ 数据，$1 \\leq q \\leq 100$，$1 \\leq n \\leq 10^9$，$-n \\leq x_1 \\leq x_2 \\leq n$，$-n \\leq y_1 \\leq y_2 \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P4677", "type": "P", "difficulty": 4, "samples": [["10 2\n3 1 3 1 1 1 1 1 3", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "前缀和"], "title": "山区建小学", "background": "", "description": "政府在某山区修建了一条道路，恰好穿越总共 $n$ 个村庄的每个村庄一次，没有回路或交叉，任意两个村庄只能通过这条路来往。已知任意两个相邻的村庄之间的距离为 $d_i$（$d_i$ 为正整数），其中，$0<i<n$。为了提高山区的文化素质，政府又决定从 $n$ 个村中选择 $m$ 个村建小学。请根据给定的 $n$、$m$ 以及所有相邻村庄的距离，选择在哪些村庄建小学，才使得所有村到最近小学的距离总和最小，计算最小值。", "inputFormat": "第一行为 $n$ 和 $m$，其间用空格间隔。\n\n第二行为 $n-1$ 个整数，依次表示从一端到另一端的相邻村庄的距离，整数之间以空格间隔。\n\n例如\n\n```\n10 3\n2 4 6 5 2 4 3 1 3\n```\n\n表示在 $10$ 个村庄中建 $3$ 所学校。第 $1$ 个村庄与第 $2$ 个村庄距离为 $2$，第 $2$ 个村庄与第 $3$ 个村庄距离为 $4$，第 $3$ 个村庄与第 $4$ 个村庄距离为 $6$，...，第 $9$ 个村庄到第 $10$ 个村庄的距离为 $3$。", "outputFormat": "各村庄到最近学校的距离之和的最小值。", "hint": "$1 \\le m \\le n < 500$，$1 \\le d_i \\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "Building Primary Schools in Mountainous Areas", "background": "", "description": "The government has built a single road in a mountainous area that passes through each of the $n$ villages exactly once, with no cycles or intersections. Any two villages can communicate only along this road. The distance between any two adjacent villages is $d_i$ (each $d_i$ is a positive integer), where $1 \\le i < n$. To improve education in the area, the government will choose $m$ out of the $n$ villages to build primary schools. Given $n$, $m$, and the distances between all adjacent villages, decide in which villages to build the primary schools so that the sum of distances from all villages to their nearest primary school is minimized, and compute this minimum value.", "inputFormat": "The first line contains $n$ and $m$, separated by a space.\nThe second line contains $n-1$ integers, in order from one end to the other, representing the distances between adjacent villages, separated by spaces.\n\nFor example\n\n```\n10 3\n2 4 6 5 2 4 3 1 3\n```\n\nmeans building $3$ primary schools among $10$ villages. The distance between village $1$ and village $2$ is $2$, between village $2$ and village $3$ is $4$, between village $3$ and village $4$ is $6$, ..., and between village $9$ and village $10$ is $3$.", "outputFormat": "Output the minimal sum of distances from all villages to their nearest primary school.", "hint": "$1 \\le m \\le n < 500$, $1 \\le d_i \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "山区建小学", "background": "", "description": "政府在某山区修建了一条道路，恰好穿越总共 $n$ 个村庄的每个村庄一次，没有回路或交叉，任意两个村庄只能通过这条路来往。已知任意两个相邻的村庄之间的距离为 $d_i$（$d_i$ 为正整数），其中，$0<i<n$。为了提高山区的文化素质，政府又决定从 $n$ 个村中选择 $m$ 个村建小学。请根据给定的 $n$、$m$ 以及所有相邻村庄的距离，选择在哪些村庄建小学，才使得所有村到最近小学的距离总和最小，计算最小值。", "inputFormat": "第一行为 $n$ 和 $m$，其间用空格间隔。\n\n第二行为 $n-1$ 个整数，依次表示从一端到另一端的相邻村庄的距离，整数之间以空格间隔。\n\n例如\n\n```\n10 3\n2 4 6 5 2 4 3 1 3\n```\n\n表示在 $10$ 个村庄中建 $3$ 所学校。第 $1$ 个村庄与第 $2$ 个村庄距离为 $2$，第 $2$ 个村庄与第 $3$ 个村庄距离为 $4$，第 $3$ 个村庄与第 $4$ 个村庄距离为 $6$，...，第 $9$ 个村庄到第 $10$ 个村庄的距离为 $3$。", "outputFormat": "各村庄到最近学校的距离之和的最小值。", "hint": "$1 \\le m \\le n < 500$，$1 \\le d_i \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P4678", "type": "P", "difficulty": 5, "samples": [["4\n2 2\n2 1\n2 0\n1 1", "10\n10\n9\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2018", "离散化", "福建", "排列组合", "前缀和"], "title": "[FJWC2018] 全排列", "background": "", "description": "定义两个长为 $n$ 的排列 $A$ 与 $B$ 相似：若 $\\forall i$，满足 $C(A, A_i) = C(B, B_i)$。其中 $C(P, x)$ 为满足 $P_j < x$ $(1 \\leqslant j \\leqslant n)$ 的 $j$ 的数目。\n\n对于两个长为 $n$ 的排列 $P_1, P_2$，定义函数 $F(P_1, P_2)$ 等于满足 $P_1[l \\ldots r]$ 相似于 $P_2[l \\ldots r]$ $(1 \\leqslant l \\leqslant r \\leqslant n)$ 并且 $P_1[l \\ldots r]$ 包含不超过 $E$ 个逆序对的数对 $(l, r)$ 的数目。\n\n现在请你求出：对 $P_1, P_2$ 分别取遍所有 $1 \\sim n$ 的排列后所有 $F(P_1, P_2)$ 的和。", "inputFormat": "第一行一个整数 $T$ 表示数据组数。\n\n接下来 $T$ 行，每行包含两个非负整数 $n, E$。", "outputFormat": "对于每组数据，输出一行一个整数表示答案模 $10^9 + 7$。", "hint": "对于 $50\\%$ 的数据，$T \\leqslant 10^4, n \\leqslant 10, E \\leqslant 50$。\n\n对于 $80\\%$ 的数据，$T \\leqslant 10^4, n \\leqslant 50, E \\leqslant 10^6$。\n\n对于 $100\\%$ 的数据，$T \\leqslant 10^4, n \\leqslant 500, E \\leqslant 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[FJWC2018] Full Permutation", "background": "", "description": "Define two permutations $A$ and $B$ of length $n$ to be similar if, for all $i$, $C(A, A_i) = C(B, B_i)$ holds. Here, $C(P, x)$ is the number of indices $j$ such that $P_j < x$ $(1 \\leqslant j \\leqslant n)$.\n\nFor two permutations $P_1, P_2$ of length $n$, define the function $F(P_1, P_2)$ as the number of pairs $(l, r)$ such that $P_1[l \\ldots r]$ is similar to $P_2[l \\ldots r]$ $(1 \\leqslant l \\leqslant r \\leqslant n)$, and $P_1[l \\ldots r]$ contains no more than $E$ inversion pairs.\n\nNow you need to compute: after letting $P_1$ and $P_2$ range over all permutations of $1 \\sim n$, the sum of all $F(P_1, P_2)$.", "inputFormat": "The first line contains an integer $T$, which denotes the number of test cases.\n\nThe next $T$ lines each contain two non-negative integers $n, E$.", "outputFormat": "For each test case, output one integer per line, which is the answer modulo $10^9 + 7$.", "hint": "For $50\\%$ of the testdata, $T \\leqslant 10^4, n \\leqslant 10, E \\leqslant 50$.\n\nFor $80\\%$ of the testdata, $T \\leqslant 10^4, n \\leqslant 50, E \\leqslant 10^6$.\n\nFor $100\\%$ of the testdata, $T \\leqslant 10^4, n \\leqslant 500, E \\leqslant 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJWC2018] 全排列", "background": "", "description": "定义两个长为 $n$ 的排列 $A$ 与 $B$ 相似：若 $\\forall i$，满足 $C(A, A_i) = C(B, B_i)$。其中 $C(P, x)$ 为满足 $P_j < x$ $(1 \\leqslant j \\leqslant n)$ 的 $j$ 的数目。\n\n对于两个长为 $n$ 的排列 $P_1, P_2$，定义函数 $F(P_1, P_2)$ 等于满足 $P_1[l \\ldots r]$ 相似于 $P_2[l \\ldots r]$ $(1 \\leqslant l \\leqslant r \\leqslant n)$ 并且 $P_1[l \\ldots r]$ 包含不超过 $E$ 个逆序对的数对 $(l, r)$ 的数目。\n\n现在请你求出：对 $P_1, P_2$ 分别取遍所有 $1 \\sim n$ 的排列后所有 $F(P_1, P_2)$ 的和。", "inputFormat": "第一行一个整数 $T$ 表示数据组数。\n\n接下来 $T$ 行，每行包含两个非负整数 $n, E$。", "outputFormat": "对于每组数据，输出一行一个整数表示答案模 $10^9 + 7$。", "hint": "对于 $50\\%$ 的数据，$T \\leqslant 10^4, n \\leqslant 10, E \\leqslant 50$。\n\n对于 $80\\%$ 的数据，$T \\leqslant 10^4, n \\leqslant 50, E \\leqslant 10^6$。\n\n对于 $100\\%$ 的数据，$T \\leqslant 10^4, n \\leqslant 500, E \\leqslant 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4679", "type": "P", "difficulty": 6, "samples": [["5 3\n1 2\n2 3\n2 4\n1 5\n.#\n..\n#.\n.#\n..\nQ 5 3\nC 1 ##\nQ 4 5\n", "6\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2011", "线段树", "各省省选", "浙江", "树链剖分"], "title": "[ZJOI2011] 道馆之战", "background": "", "description": "口袋妖怪（又名神奇宝贝或宠物小精灵）红/蓝/绿宝石中的水系道馆需要经过三个冰地才能到达馆主的面前，冰地中的每一个冰块都只能经过一次。当一个冰地上的所有冰块都被经过之后，到下一个冰地的楼梯才会被打开。\n\n三个冰地分别如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4tq073ig.png)\n\n当走出第三个冰地之后，就可以与馆主进行道馆战了。馆主发现这个难度太小，导致经常有挑战者能通过，为了加大难度，将道馆分成了$n$个房间，任意两个房间之间均有且仅有一条路径相连，即这$n$个房间构成一个树状结构。每个房间分成了$A$和$B$两个区域，每一区域都是一个薄冰块或者障碍物。每次只能移动到相邻房间的同一类区域（即若你现在在这个房间的$A$区域，那么你只能移动到相邻房间的$A$区域）或这个房间的另一区域。现在挑战者从房间$u$出发，馆主在房间$v$，那么挑战者只能朝接近馆主所在房间的方向过去。一开始挑战者可以在房间$u$的任意一个冰块区域内。如果挑战者踩过的冰块数达到了最大值（即没有一种方案踩过的冰块数更多了），那么当挑战者走到最后一个冰块上时，他会被瞬间传送到馆主面前与馆主进行道馆战。自从馆主修改规则后已经经过了$m$天，每天要么是有一个挑战者来进行挑战，要么就是馆主将某个房间进行了修改。对于每个来的挑战者，你需要计算出他若要和馆主进行战斗需要经过的冰块数。", "inputFormat": "第一行包含两个正整数$n$和$m$。\n\n第$2$行到第$n$行，每行包含两个正整数$x$和$y$，表示一条连接房间$x$和房间$y$的边。房间编号为$1\\cdots n$。\n\n接下来$n$行，每行包含两个字符。第$n+k$行表示房间$k$的两个区域，第一个字符为$A$区域，第二个字符为$B$区域。其中“.”（ASCII码为46）表示是薄冰块，“#”（ASCII码为35）表示是障碍物。\n\n最后的$m$行，每行一个操作：\n\n$C$ $u$ $s$：将房间$u$里的两个区域修改为$s$。\n\n$Q$ $u$ $v$：询问挑战者在房间$u$，馆主在房间$v$时，挑战者能与馆主进行挑战需要踩的冰块数。如果房间$u$的两个区域都是障碍物，那么输出$0$。", "outputFormat": "包含若干行，每行一个整数。即对于输入中的每个询问，依次输出一个答案。", "hint": "测试点$1$~$6$：$n≤1000,m≤10000$\n\n测试点$7$~$15$：$n≤30000,m≤80000$\n\n测试点$16$~$20$：$n≤50000,m≤100000$", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2011] Gym Battle", "background": "", "description": "In Pokémon (also known as Pocket Monsters), in the Water-type Gym in Red/Blue/Green/Emerald, you need to pass through three ice floors to reach the Gym Leader. Each ice block on an ice floor can be stepped on at most once. Only after all ice blocks on the current ice floor have been stepped on will the stairs to the next ice floor open.\n\nThe three ice floors are as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4tq073ig.png)\n\nAfter leaving the third ice floor, you can battle the Gym Leader. The Gym Leader thinks this is too easy and many challengers can pass, so to increase the difficulty, the Gym is divided into $n$ rooms. Between any two rooms there is exactly one path, i.e. these $n$ rooms form a tree structure. Each room is divided into two areas, $A$ and $B$. Each area is either a thin ice block or an obstacle.\n\nEach move can only go to the same type of area in an adjacent room (that is, if you are currently in area $A$ of this room, then you can only move to area $A$ of an adjacent room), or to the other area of the same room.\n\nNow a challenger starts from room $u$, and the Gym Leader is in room $v$. Then the challenger can only move in the direction that gets closer to the room where the Gym Leader is. At the beginning, the challenger may start on either ice area in room $u$. If the number of ice blocks the challenger has stepped on reaches the maximum possible (i.e. there is no strategy that steps on more ice blocks), then when the challenger steps on the last ice block, he will be instantly teleported to the Gym Leader to start the battle.\n\nSince the Gym Leader changed the rules, $m$ days have passed. Each day, either a challenger comes to challenge, or the Gym Leader modifies a certain room. For each challenger, you need to compute how many ice blocks he needs to step on in order to battle the Gym Leader.", "inputFormat": "The first line contains two positive integers $n$ and $m$.\n\nLines $2$ to $n$ each contain two positive integers $x$ and $y$, indicating an edge connecting room $x$ and room $y$. Rooms are numbered $1\\cdots n$.\n\nNext follow $n$ lines, each containing two characters. Line $n+k$ describes the two areas of room $k$: the first character is area $A$ and the second character is area $B$. Here, “.” (ASCII code 46) means a thin ice block, and “#” (ASCII code 35) means an obstacle.\n\nFinally, the next $m$ lines each describe one operation:\n\n$C$ $u$ $s$: modify the two areas in room $u$ to $s$.\n\n$Q$ $u$ $v$: query the number of ice blocks the challenger needs to step on to battle the Gym Leader, when the challenger is in room $u$ and the Gym Leader is in room $v$. If both areas in room $u$ are obstacles, output $0$.", "outputFormat": "Output multiple lines, each containing one integer. That is, for each query in the input, output the answer in order.", "hint": "Constraints:\n\nTest points $1$~$6$: $n \\le 1000, m \\le 10000$.\n\nTest points $7$~$15$: $n \\le 30000, m \\le 80000$.\n\nTest points $16$~$20$: $n \\le 50000, m \\le 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2011] 道馆之战", "background": "", "description": "口袋妖怪（又名神奇宝贝或宠物小精灵）红/蓝/绿宝石中的水系道馆需要经过三个冰地才能到达馆主的面前，冰地中的每一个冰块都只能经过一次。当一个冰地上的所有冰块都被经过之后，到下一个冰地的楼梯才会被打开。\n\n三个冰地分别如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4tq073ig.png)\n\n当走出第三个冰地之后，就可以与馆主进行道馆战了。馆主发现这个难度太小，导致经常有挑战者能通过，为了加大难度，将道馆分成了$n$个房间，任意两个房间之间均有且仅有一条路径相连，即这$n$个房间构成一个树状结构。每个房间分成了$A$和$B$两个区域，每一区域都是一个薄冰块或者障碍物。每次只能移动到相邻房间的同一类区域（即若你现在在这个房间的$A$区域，那么你只能移动到相邻房间的$A$区域）或这个房间的另一区域。现在挑战者从房间$u$出发，馆主在房间$v$，那么挑战者只能朝接近馆主所在房间的方向过去。一开始挑战者可以在房间$u$的任意一个冰块区域内。如果挑战者踩过的冰块数达到了最大值（即没有一种方案踩过的冰块数更多了），那么当挑战者走到最后一个冰块上时，他会被瞬间传送到馆主面前与馆主进行道馆战。自从馆主修改规则后已经经过了$m$天，每天要么是有一个挑战者来进行挑战，要么就是馆主将某个房间进行了修改。对于每个来的挑战者，你需要计算出他若要和馆主进行战斗需要经过的冰块数。", "inputFormat": "第一行包含两个正整数$n$和$m$。\n\n第$2$行到第$n$行，每行包含两个正整数$x$和$y$，表示一条连接房间$x$和房间$y$的边。房间编号为$1\\cdots n$。\n\n接下来$n$行，每行包含两个字符。第$n+k$行表示房间$k$的两个区域，第一个字符为$A$区域，第二个字符为$B$区域。其中“.”（ASCII码为46）表示是薄冰块，“#”（ASCII码为35）表示是障碍物。\n\n最后的$m$行，每行一个操作：\n\n$C$ $u$ $s$：将房间$u$里的两个区域修改为$s$。\n\n$Q$ $u$ $v$：询问挑战者在房间$u$，馆主在房间$v$时，挑战者能与馆主进行挑战需要踩的冰块数。如果房间$u$的两个区域都是障碍物，那么输出$0$。", "outputFormat": "包含若干行，每行一个整数。即对于输入中的每个询问，依次输出一个答案。", "hint": "测试点$1$~$6$：$n≤1000,m≤10000$\n\n测试点$7$~$15$：$n≤30000,m≤80000$\n\n测试点$16$~$20$：$n≤50000,m≤100000$", "locale": "zh-CN"}}}
{"pid": "P4681", "type": "P", "difficulty": 6, "samples": [["1 3 233\n1 \n2 1 1\n1 1 1\n2 1 1\n", "1\n1\n"], ["4 3 5\n1 2 3 4 \n2 1 4\n1 2 4\n2 2 3\n", "10\n8\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "线段树", "O2优化", "THUSC"], "title": "[THUSC 2015] 平方运算", "background": "", "description": "小 H 是一位勤奋的中学生，他的理想是进入自己心仪的大学学习计算机专业。为了实现这一目标。他从小就开始认真学习信息学竞赛的基础知识。\n\n今天，小 H 学习了平方运算。为了检验自己是否熟练掌握了平方运算，小 H 决定给自己出一道题。小 H 有一个长度为 $N$ 的序列 ${X_1,X_2,\\cdots,X_N}$。小 H 会时不时地取出 列中的一段连续区间 $[l,r]$，并将其中的每一个数改为原数值的平方对 $P$ 取模的结果，其中 $P$ 为某个给定的数。为了检验自己的运算是否正确，小 $H$ 还会时不时地想要知道序列中某一段连续区间 $[l,r]$ 内所有数的和是多少。\n\n但是，小 H 现在并没有标准答案。所以，他向你求助，希望你编写一个程序，帮他计算出每次想要知道的区间内的数的和。 ", "inputFormat": "输入第一行包含三个整数 $N,M,P$，$M$ 表示操作组数，$N,P$ 含义见题目描述；\n\n接下来一行，包含 $N$ 个正整数，为 $X_1,X_2,X_3,\\cdots,X_N$，$X_i<P$；\n\n接下来共 $M$ 行输入，每行格式形如 $1\\;l\\;r$ 或 $2\\;l\\;r$，$1$ 表示修改每个元素的值，$2$ 表示询问区间和。", "outputFormat": "对于每一个询问，输出答案。", "hint": "$1\\leq N,M\\leq 10^{5}$。\n\n$$\n\\begin{aligned}P\\in \\{233,2332,5,8192,23,45,37,4185,5850,2975,2542,\\\\2015,2003,2010,4593,4562, 1034,5831,9905,9977\\}\n\\end{aligned}\n$$", "locale": "zh-CN", "translations": {"en": {"title": "[THUSC 2015] Square Operation", "background": "", "description": "Xiao H is a hardworking middle school student. His dream is to enter his favorite university to study computer science. To achieve this goal, he has been seriously studying the basic knowledge of informatics competitions since childhood.\n\nToday, Xiao H learned the square operation. To check whether he has mastered it well, Xiao H decided to make himself a problem. Xiao H has a sequence of length $N$, ${X_1,X_2,\\cdots,X_N}$. From time to time, Xiao H takes a continuous interval $[l,r]$ from the sequence and changes each number in it to the result of squaring its original value modulo $P$, where $P$ is a given number. To verify whether his computation is correct, Xiao H also wants to know, from time to time, what the sum of all numbers in a continuous interval $[l,r]$ of the sequence is.\n\nHowever, Xiao H does not have the standard answers now. So, he asks you for help and hopes you can write a program to compute the sum of the numbers in the interval each time he asks.", "inputFormat": "The first line contains three integers $N,M,P$, where $M$ is the number of operations, and the meanings of $N$ and $P$ are as described in the statement.\n\nThe next line contains $N$ positive integers, $X_1,X_2,X_3,\\cdots,X_N$, where $X_i<P$.\n\nThen follow $M$ lines. Each line is in the format $1\\;l\\;r$ or $2\\;l\\;r$. $1$ means modifying the value of each element, and $2$ means querying the interval sum.", "outputFormat": "For each query, output the answer.", "hint": "$1\\leq N,M\\leq 10^{5}$。\n\n$$\n\\begin{aligned}P\\in \\{233,2332,5,8192,23,45,37,4185,5850,2975,2542,\\\\2015,2003,2010,4593,4562, 1034,5831,9905,9977\\}\n\\end{aligned}\n$$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[THUSC 2015] 平方运算", "background": "", "description": "小 H 是一位勤奋的中学生，他的理想是进入自己心仪的大学学习计算机专业。为了实现这一目标。他从小就开始认真学习信息学竞赛的基础知识。\n\n今天，小 H 学习了平方运算。为了检验自己是否熟练掌握了平方运算，小 H 决定给自己出一道题。小 H 有一个长度为 $N$ 的序列 ${X_1,X_2,\\cdots,X_N}$。小 H 会时不时地取出 列中的一段连续区间 $[l,r]$，并将其中的每一个数改为原数值的平方对 $P$ 取模的结果，其中 $P$ 为某个给定的数。为了检验自己的运算是否正确，小 $H$ 还会时不时地想要知道序列中某一段连续区间 $[l,r]$ 内所有数的和是多少。\n\n但是，小 H 现在并没有标准答案。所以，他向你求助，希望你编写一个程序，帮他计算出每次想要知道的区间内的数的和。 ", "inputFormat": "输入第一行包含三个整数 $N,M,P$，$M$ 表示操作组数，$N,P$ 含义见题目描述；\n\n接下来一行，包含 $N$ 个正整数，为 $X_1,X_2,X_3,\\cdots,X_N$，$X_i<P$；\n\n接下来共 $M$ 行输入，每行格式形如 $1\\;l\\;r$ 或 $2\\;l\\;r$，$1$ 表示修改每个元素的值，$2$ 表示询问区间和。", "outputFormat": "对于每一个询问，输出答案。", "hint": "$1\\leq N,M\\leq 10^{5}$。\n\n$$\n\\begin{aligned}P\\in \\{233,2332,5,8192,23,45,37,4185,5850,2975,2542,\\\\2015,2003,2010,4593,4562, 1034,5831,9905,9977\\}\n\\end{aligned}\n$$", "locale": "zh-CN"}}}
{"pid": "P4682", "type": "P", "difficulty": 6, "samples": [["0 0 10\n2 10\n0 -5 0 1\n5 0 1 0", "7.071"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "浙江"], "title": "[ZJOI2007] 粒子运动", "background": "", "description": "阿Q博士正在观察一个圆形器皿中的粒子运动。不妨建立一个平面直角坐标系，圆形器皿的圆心坐标为$(x_0, y_0)$，半径为$R$。器皿中有若干个粒子，假设第$i$个粒子在时刻$0$的位置为$(x_i, y_i)$，速度为$(v_{x_i},v_{y_i})$（注：这是一个速度向量，若没有发生碰撞，$t$时刻的位置应该是$(x_i + t * v_{x_i}, y_i + t * v_{y_i})$ ）。假设所有粒子的运动**互不干扰**；若某个粒子在某个时刻碰到了器皿壁，将发生完全弹性碰撞，即速度方向按照碰撞点的切线镜面反射，且速度大小不变（如图）。认为碰撞是瞬间完成的。\n\n![particle](https://cdn.luogu.com.cn/upload/pic/22046.png)\n\n尽管碰撞不会影响粒子的速率，但是粒子却会受到一定的伤害，所以若某一个粒子碰撞了$k$次器皿壁，那么在第$k$次碰撞时它便会消亡。\n\n出于研究的需要，阿Q博士希望知道从时刻$0$到所有粒子都消亡这段时间内，所有粒子之间的最近距离是什么。你能帮助他么？", "inputFormat": "输入文件particle.in第一行包含三个实数，分别为$x_0, y_0, R$，即圆形器皿的圆心坐标及半径。第二行包含两个正整数$N, k$，分别表示粒子的总数与消亡碰撞次数。接下来$N$行每行四个实数，分别为$x_i, y_i, v_{x_i} , v_{y_i}$，保证$(x_i, y_i)$都在圆内且$(v_{x_i}, v_{y_i})$非零。", "outputFormat": "输出文件particle.out仅包含一个实数，即所有粒子的历史最近距离，精确到小数点后三位。", "hint": "对于所有的数据，$2 \\leq N \\leq 100$。$1 \\leq k \\leq 100$。\n\n请注意实数精度问题。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2007] Particle Motion", "background": "", "description": "Dr. A-Q is observing the motion of particles in a circular container. Let us set up a 2D Cartesian coordinate system. The center of the circular container is at $(x_0, y_0)$, with radius $R$. There are several particles in the container. Suppose the position of the $i$-th particle at time $0$ is $(x_i, y_i)$, and its velocity is $(v_{x_i}, v_{y_i})$ (note: this is a velocity vector; if no collision happens, then at time $t$ its position should be $(x_i + t * v_{x_i}, y_i + t * v_{y_i})$). Assume that the motions of all particles **do not affect each other**. If a particle hits the container wall at some moment, a perfectly elastic collision occurs: the velocity direction is reflected like a mirror with respect to the tangent line at the collision point, and the speed remains unchanged (as shown in the figure). The collision is considered to be instantaneous.\n\n![particle](https://cdn.luogu.com.cn/upload/pic/22046.png)\n\nAlthough collisions do not affect a particle’s speed, the particle will take some damage. Therefore, if a particle has collided with the container wall $k$ times, then it will vanish at its $k$-th collision.\n\nFor research purposes, Dr. A-Q wants to know, from time $0$ until all particles have vanished, what the minimum distance ever achieved between any two particles is. Can you help him?", "inputFormat": "The first line of the input file particle.in contains three real numbers $x_0, y_0, R$, which are the center coordinates and radius of the circular container. The second line contains two positive integers $N, k$, representing the total number of particles and the number of collisions at which a particle vanishes. The next $N$ lines each contain four real numbers $x_i, y_i, v_{x_i}, v_{y_i}$, guaranteeing that $(x_i, y_i)$ are all inside the circle and $(v_{x_i}, v_{y_i})$ is non-zero.", "outputFormat": "The output file particle.out contains only one real number: the minimum distance ever achieved between any two particles over the whole history, accurate to three digits after the decimal point.", "hint": "For all testdata, $2 \\leq N \\leq 100$. $1 \\leq k \\leq 100$.\n\nPlease pay attention to floating-point precision issues.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2007] 粒子运动", "background": "", "description": "阿Q博士正在观察一个圆形器皿中的粒子运动。不妨建立一个平面直角坐标系，圆形器皿的圆心坐标为$(x_0, y_0)$，半径为$R$。器皿中有若干个粒子，假设第$i$个粒子在时刻$0$的位置为$(x_i, y_i)$，速度为$(v_{x_i},v_{y_i})$（注：这是一个速度向量，若没有发生碰撞，$t$时刻的位置应该是$(x_i + t * v_{x_i}, y_i + t * v_{y_i})$ ）。假设所有粒子的运动**互不干扰**；若某个粒子在某个时刻碰到了器皿壁，将发生完全弹性碰撞，即速度方向按照碰撞点的切线镜面反射，且速度大小不变（如图）。认为碰撞是瞬间完成的。\n\n![particle](https://cdn.luogu.com.cn/upload/pic/22046.png)\n\n尽管碰撞不会影响粒子的速率，但是粒子却会受到一定的伤害，所以若某一个粒子碰撞了$k$次器皿壁，那么在第$k$次碰撞时它便会消亡。\n\n出于研究的需要，阿Q博士希望知道从时刻$0$到所有粒子都消亡这段时间内，所有粒子之间的最近距离是什么。你能帮助他么？", "inputFormat": "输入文件particle.in第一行包含三个实数，分别为$x_0, y_0, R$，即圆形器皿的圆心坐标及半径。第二行包含两个正整数$N, k$，分别表示粒子的总数与消亡碰撞次数。接下来$N$行每行四个实数，分别为$x_i, y_i, v_{x_i} , v_{y_i}$，保证$(x_i, y_i)$都在圆内且$(v_{x_i}, v_{y_i})$非零。", "outputFormat": "输出文件particle.out仅包含一个实数，即所有粒子的历史最近距离，精确到小数点后三位。", "hint": "对于所有的数据，$2 \\leq N \\leq 100$。$1 \\leq k \\leq 100$。\n\n请注意实数精度问题。", "locale": "zh-CN"}}}
{"pid": "P4683", "type": "P", "difficulty": 5, "samples": [["3\nprint\nthe\npoem", "20\nt\nh\ne\nP\n-\n-\n-\np\no\ne\nm\nP\n-\n-\n-\nr\ni\nn\nt\nP"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["字符串", "2008", "IOI", "Special Judge", "深度优先搜索 DFS", "字典树 Trie"], "title": "[IOI 2008] Type Printer", "background": "", "description": "你需要利用一台可移动的打印机打印出 $n$ 个单词。这种可移动式打印机是一种老式打印机，它需要你将一些小的金属块（每个包含一个字母）放到打印机上以组成单词。然后将这些小金属块压在一张纸上以打印出这个词。这种打印机允许你进行下列操作： \n\n- 在打印机当前词的末端（尾部）添加一个字母； \n- 在打印机当前词的尾部删去一个字母（将打印机当前词的最后一个字母删去）。仅当打印机当前至少有一个字母时才允许进行该操作；\n- 将打印机上的当前词打印出来。 \n\n初始时打印机为空，或者说它不含任何带字母的金属块。打印结束时，允许有部分字母留在打印机内。同时也允许你按照任意的次序打印单词。\n\n由于每一个操作都需要一定时间，所以需要你尽可能减少所需操作的总数目（将操作的总数最小化）。\n\n你需要编写一个程序，给定所要打印的 $n$ 个单词，找出以任意次序打印所有单词所需操作的最小数目，并输出一种这样的操作序列。", "inputFormat": "- 第 $1$ 行包含一个整数 $n$, 表示你需要打印的单词数。 \t\n- 随后的 $n$ 行中，每一行都包含一个单词。每个词仅由小写字母组成，而且单词的长度为 $1$ 到 $20$ 个字母（包含 $1$ 和 $20$ 在内）。所有单词都不相同。", "outputFormat": "第一行包含一个整数 $m$，表示打印这 $n$ 个单词所需操作的最小数目。\n\n接下来的 $m$ 行，每行一个字符，表示你的操作序列，序列的描述方法如下：\n- 添加一个字母，用这个小写字母的自身来表示。\n- 删去一个字母，用 `-` 表示。\n- 打印单词，用 `P` 表示。", "hint": "对于 $40\\%$ 的数据，$n\\leq18$；\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq25000$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2008] Type Printer", "background": "", "description": "You need to use a movable printer to print $n$ words. This movable printer is an old-style printer: you have to place some small metal blocks (each containing one letter) onto the printer to form a word. Then you press these metal blocks onto a sheet of paper to print the word. The printer allows you to perform the following operations:\n\n- Add one letter to the end (tail) of the current word in the printer.\n- Delete one letter from the end of the current word (remove the last letter). This operation is allowed only when the current word has at least one letter.\n- Print the current word in the printer.\n\nInitially, the printer is empty, i.e., it contains no metal blocks with letters. After finishing all printing, it is allowed to leave some letters in the printer. You are also allowed to print the words in any order.\n\nSince each operation takes some time, you need to minimize the total number of operations.\n\nYou need to write a program that, given the $n$ words to be printed, finds the minimum number of operations needed to print all words in some order, and outputs one such sequence of operations.", "inputFormat": "- Line $1$ contains an integer $n$, the number of words you need to print.\n- The next $n$ lines each contain one word. Each word consists only of lowercase letters, and its length is from $1$ to $20$ letters (inclusive). All words are distinct.", "outputFormat": "The first line contains an integer $m$, the minimum number of operations required to print these $n$ words.\n\nThe next $m$ lines each contain one character, describing your operation sequence as follows:\n- To add a letter, output that lowercase letter itself.\n- To delete a letter, output `-`.\n- To print the current word, output `P`.", "hint": "For $40\\%$ of the testdata, $n \\leq 18$.\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 25000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2008] Type Printer", "background": "", "description": "你需要利用一台可移动的打印机打印出 $n$ 个单词。这种可移动式打印机是一种老式打印机，它需要你将一些小的金属块（每个包含一个字母）放到打印机上以组成单词。然后将这些小金属块压在一张纸上以打印出这个词。这种打印机允许你进行下列操作： \n\n- 在打印机当前词的末端（尾部）添加一个字母； \n- 在打印机当前词的尾部删去一个字母（将打印机当前词的最后一个字母删去）。仅当打印机当前至少有一个字母时才允许进行该操作；\n- 将打印机上的当前词打印出来。 \n\n初始时打印机为空，或者说它不含任何带字母的金属块。打印结束时，允许有部分字母留在打印机内。同时也允许你按照任意的次序打印单词。\n\n由于每一个操作都需要一定时间，所以需要你尽可能减少所需操作的总数目（将操作的总数最小化）。\n\n你需要编写一个程序，给定所要打印的 $n$ 个单词，找出以任意次序打印所有单词所需操作的最小数目，并输出一种这样的操作序列。", "inputFormat": "- 第 $1$ 行包含一个整数 $n$, 表示你需要打印的单词数。 \t\n- 随后的 $n$ 行中，每一行都包含一个单词。每个词仅由小写字母组成，而且单词的长度为 $1$ 到 $20$ 个字母（包含 $1$ 和 $20$ 在内）。所有单词都不相同。", "outputFormat": "第一行包含一个整数 $m$，表示打印这 $n$ 个单词所需操作的最小数目。\n\n接下来的 $m$ 行，每行一个字符，表示你的操作序列，序列的描述方法如下：\n- 添加一个字母，用这个小写字母的自身来表示。\n- 删去一个字母，用 `-` 表示。\n- 打印单词，用 `P` 表示。", "hint": "对于 $40\\%$ 的数据，$n\\leq18$；\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq25000$。", "locale": "zh-CN"}}}
{"pid": "P4684", "type": "P", "difficulty": 6, "samples": [["5\n3\n7\n2 2\n5 1\n8 3\n4 1\n2 3\n", "4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2008", "IOI"], "title": "[IOI 2008] Fish", "background": "", "description": "据Scheherazade说，在很远的沙漠中有一个湖。湖中起初有$F$条鱼。选择最值钱的$K$种宝石，对$F$条鱼的每一条只喂给它一块宝石。注意，因为$K$可能小于$F$，两条或更多的鱼可能会吞下同一种宝石。\n\n随着时间的流逝，有些鱼吃掉了别的鱼。一条鱼能够吃掉另一条鱼，当且仅当它的长度至少是被吃掉的鱼的两倍($A$ 能吃掉$B$ 当且仅当$L_A \\geq 2L_B$)。没有规则说明一条鱼何时会吃掉另一条鱼。有的鱼可能会一条接一条地吃掉几条小鱼，而有的鱼可能不吃别的鱼，即使它们有能力吃。当一条鱼吃掉一条小鱼时，它的身长并不改变，但是小鱼腹中的宝石会完好无损地进到大鱼腹中。\n\n据Scheherazade说，如果你能够找到那个湖，你会被准许捕捉一条鱼，并且得到鱼腹中的宝石。你很想试试运气，但是在出发前很想知道捉到一条鱼可能会有多少种不同的宝石组合。\n\n写一个程序，给定每条鱼的长度以及其最初吞食的宝石的种类，找出鱼腹中宝石不同组合的数量对给定整数$M$取模的值。组合由每种宝石的数量定义，与宝石的排列顺序无关。同一类宝石中任意两块是没有区别的。 ", "inputFormat": "你的程序需要从标准输入上读入下列数据：\n- 第一行是整数$F$, 即湖中最初鱼的数量。\n- 第二行是整数$K$, 即宝石的种类数。不同类型的宝石分别用从 $1$ 到 $K$的整数表示。 \n- 第三行是整数$M$。 \n- 以后 $F$ 行中的每一行用由一个空格分隔的两个整数描述一条鱼：按顺序分别是鱼的长度以及鱼腹中的宝石的类型。\n\n注意: 在所有的测试用例中，$K$ 种宝石中的每一种都会至少有一块。 ", "outputFormat": "你的程序需要在标准输出上输出一个介于$0$和$M-1$(包含)的整数，即宝石所有可能的不同组合数量模$M$，占一行。注意，在问题求解中，数值$M$除了简化计算外没有其他的作用。", "hint": "### 限制\n\n有总计70分的测试数据，其中$K$不超过$7,000$。在这些测试数据中，有总计25分的测试数据的$K$不超过$20$。\n\n对于所有的测试数据，$1 \\leq F \\leq 500,000$，$1 \\leq K \\leq F$，$2 \\leq M \\leq 30,000$，$1 \\leq L_X \\leq 1,000,000,000$。\n\n### 样例说明\n\n有 $11$ 种可能的组合，所以你需要输出$4$，也就是$11$ 模 $7$。这些可能的组合是: $[1] [1,2] [1,2,3] [1,2,3,3] [1,3] [1,3,3] [2] [2,3] [2,3,3] [3]$ 和 $[3,3]$。(对每一种组合, 我们列出其所包含的宝石。 例如，$[2,3,3]$ 包含一块$2$型宝石和两块$3$型宝石)\n\n这些组合可以由下述方式获得:\n\n$[1]$: 如果你在第二条鱼 (或第四条) 吃掉任何其它鱼之前捕捉到它。\n\n$[1,2]$: 如果第二条鱼吃掉第一条鱼, 它就会有一块 $1$ 型宝石(它在初始时刻吞下的) 和一块2型宝石 (从第一条鱼腹中得到的)。\n\n$[1,2,3]$: 一种可能的途径是: 第四条鱼吃掉第一条鱼，然后第三条鱼又吃掉它。如果你此时捉到了第三条鱼，那它腹中就有这三种宝石一样一块\n\n$[1,2,3,3]$: 第四条鱼吃掉第一条鱼，第三条鱼吃掉第四条鱼，第三条鱼吃掉第五条鱼，你捉到了第三条鱼。\n\n$[1,3]$: 第三条鱼吃掉第四条鱼，你捉到了第三条鱼。\n\n$[1,3,3]$: 第三条鱼吃掉第五条鱼，第三条鱼吃掉第四条鱼，你捉到了第三条鱼。\n\n$[2]$: 你捉到了第一条鱼。\n\n$[2,3]$: 第三条鱼吃掉第一条鱼，你捉到了第三条鱼\n\n$[2,3,3]$: 第三条鱼吃掉第一条鱼，第三条鱼吃掉第五条鱼，你捉到了第三条鱼。\n\n$[3]$: 你捉到了第三条鱼。\n\n$[3,3]$: 第三条鱼吃掉第五条鱼，你捉到了第三条鱼。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2008] Fish", "background": "", "description": "According to Scheherazade, there is a lake in a faraway desert. Initially, there are $F$ fish in the lake. Choose the most valuable $K$ types of gems, and for each of the $F$ fish, feed it exactly one gem. Note that since $K$ may be smaller than $F$, two or more fish may swallow the same type of gem.\n\nAs time goes by, some fish eat other fish. A fish can eat another fish if and only if its length is at least twice the length of the fish being eaten ($A$ can eat $B$ if and only if $L_A \\geq 2L_B$). There is no rule saying when a fish will eat another fish. Some fish may eat several smaller fish one after another, and some fish may eat none, even if they are able to. When a fish eats a smaller fish, its length does not change, but the gems inside the smaller fish remain intact and move into the bigger fish’s stomach.\n\nAccording to Scheherazade, if you can find that lake, you will be allowed to catch one fish and take the gems inside its stomach. You want to try your luck, but before setting out, you want to know how many different gem collections you might obtain by catching a fish.\n\nWrite a program that, given the length of each fish and the type of gem it initially swallowed, finds the number of different gem collections that can appear in a fish’s stomach, modulo a given integer $M$. A collection is defined by the count of each type of gem, and the order of gems does not matter. Any two gems of the same type are indistinguishable.", "inputFormat": "Your program should read the following data from standard input:\n- The first line contains an integer $F$, the initial number of fish in the lake.\n- The second line contains an integer $K$, the number of gem types. Different gem types are represented by integers from $1$ to $K$.\n- The third line contains an integer $M$.\n- Each of the next $F$ lines contains two integers separated by a space, describing a fish: its length and the type of gem in its stomach.\n\nNote: In all test cases, each of the $K$ gem types appears at least once.", "outputFormat": "Your program should output to standard output a single integer between $0$ and $M-1$ (inclusive), the number of all possible different gem collections modulo $M$, on one line. Note that in solving the problem, the value $M$ has no purpose other than simplifying computation.", "hint": "### Constraints\n\nThere are testdata worth 70 points in total where $K$ does not exceed $7,000$. Among these, there are testdata worth 25 points where $K$ does not exceed $20$.\n\nFor all testdata, $1 \\leq F \\leq 500,000$, $1 \\leq K \\leq F$, $2 \\leq M \\leq 30,000$, $1 \\leq L_X \\leq 1,000,000,000$.\n\n### Sample Explanation\n\nThere are $11$ possible collections, so you should output $4$, which is $11$ modulo $7$. These collections are: $[1] [1,2] [1,2,3] [1,2,3,3] [1,3] [1,3,3] [2] [2,3] [2,3,3] [3]$ and $[3,3]$. (For each collection, we list the gems it contains. For example, $[2,3,3]$ contains one type $2$ gem and two type $3$ gems.)\n\nThese collections can be obtained in the following ways:\n\n$[1]$: If you catch the second fish (or the fourth fish) before it eats any other fish.\n\n$[1,2]$: If the second fish eats the first fish, it will have one type $1$ gem (the one it swallowed initially) and one type $2$ gem (obtained from the first fish’s stomach).\n\n$[1,2,3]$: One possible way is: the fourth fish eats the first fish, then the third fish eats it. If you catch the third fish at this moment, it has one gem of each of these three types in its stomach.\n\n$[1,2,3,3]$: The fourth fish eats the first fish, the third fish eats the fourth fish, the third fish eats the fifth fish, and you catch the third fish.\n\n$[1,3]$: The third fish eats the fourth fish, and you catch the third fish.\n\n$[1,3,3]$: The third fish eats the fifth fish, the third fish eats the fourth fish, and you catch the third fish.\n\n$[2]$: You catch the first fish.\n\n$[2,3]$: The third fish eats the first fish, and you catch the third fish.\n\n$[2,3,3]$: The third fish eats the first fish, the third fish eats the fifth fish, and you catch the third fish.\n\n$[3]$: You catch the third fish.\n\n$[3,3]$: The third fish eats the fifth fish, and you catch the third fish.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2008] Fish", "background": "", "description": "据Scheherazade说，在很远的沙漠中有一个湖。湖中起初有$F$条鱼。选择最值钱的$K$种宝石，对$F$条鱼的每一条只喂给它一块宝石。注意，因为$K$可能小于$F$，两条或更多的鱼可能会吞下同一种宝石。\n\n随着时间的流逝，有些鱼吃掉了别的鱼。一条鱼能够吃掉另一条鱼，当且仅当它的长度至少是被吃掉的鱼的两倍($A$ 能吃掉$B$ 当且仅当$L_A \\geq 2L_B$)。没有规则说明一条鱼何时会吃掉另一条鱼。有的鱼可能会一条接一条地吃掉几条小鱼，而有的鱼可能不吃别的鱼，即使它们有能力吃。当一条鱼吃掉一条小鱼时，它的身长并不改变，但是小鱼腹中的宝石会完好无损地进到大鱼腹中。\n\n据Scheherazade说，如果你能够找到那个湖，你会被准许捕捉一条鱼，并且得到鱼腹中的宝石。你很想试试运气，但是在出发前很想知道捉到一条鱼可能会有多少种不同的宝石组合。\n\n写一个程序，给定每条鱼的长度以及其最初吞食的宝石的种类，找出鱼腹中宝石不同组合的数量对给定整数$M$取模的值。组合由每种宝石的数量定义，与宝石的排列顺序无关。同一类宝石中任意两块是没有区别的。 ", "inputFormat": "你的程序需要从标准输入上读入下列数据：\n- 第一行是整数$F$, 即湖中最初鱼的数量。\n- 第二行是整数$K$, 即宝石的种类数。不同类型的宝石分别用从 $1$ 到 $K$的整数表示。 \n- 第三行是整数$M$。 \n- 以后 $F$ 行中的每一行用由一个空格分隔的两个整数描述一条鱼：按顺序分别是鱼的长度以及鱼腹中的宝石的类型。\n\n注意: 在所有的测试用例中，$K$ 种宝石中的每一种都会至少有一块。 ", "outputFormat": "你的程序需要在标准输出上输出一个介于$0$和$M-1$(包含)的整数，即宝石所有可能的不同组合数量模$M$，占一行。注意，在问题求解中，数值$M$除了简化计算外没有其他的作用。", "hint": "### 限制\n\n有总计70分的测试数据，其中$K$不超过$7,000$。在这些测试数据中，有总计25分的测试数据的$K$不超过$20$。\n\n对于所有的测试数据，$1 \\leq F \\leq 500,000$，$1 \\leq K \\leq F$，$2 \\leq M \\leq 30,000$，$1 \\leq L_X \\leq 1,000,000,000$。\n\n### 样例说明\n\n有 $11$ 种可能的组合，所以你需要输出$4$，也就是$11$ 模 $7$。这些可能的组合是: $[1] [1,2] [1,2,3] [1,2,3,3] [1,3] [1,3,3] [2] [2,3] [2,3,3] [3]$ 和 $[3,3]$。(对每一种组合, 我们列出其所包含的宝石。 例如，$[2,3,3]$ 包含一块$2$型宝石和两块$3$型宝石)\n\n这些组合可以由下述方式获得:\n\n$[1]$: 如果你在第二条鱼 (或第四条) 吃掉任何其它鱼之前捕捉到它。\n\n$[1,2]$: 如果第二条鱼吃掉第一条鱼, 它就会有一块 $1$ 型宝石(它在初始时刻吞下的) 和一块2型宝石 (从第一条鱼腹中得到的)。\n\n$[1,2,3]$: 一种可能的途径是: 第四条鱼吃掉第一条鱼，然后第三条鱼又吃掉它。如果你此时捉到了第三条鱼，那它腹中就有这三种宝石一样一块\n\n$[1,2,3,3]$: 第四条鱼吃掉第一条鱼，第三条鱼吃掉第四条鱼，第三条鱼吃掉第五条鱼，你捉到了第三条鱼。\n\n$[1,3]$: 第三条鱼吃掉第四条鱼，你捉到了第三条鱼。\n\n$[1,3,3]$: 第三条鱼吃掉第五条鱼，第三条鱼吃掉第四条鱼，你捉到了第三条鱼。\n\n$[2]$: 你捉到了第一条鱼。\n\n$[2,3]$: 第三条鱼吃掉第一条鱼，你捉到了第三条鱼\n\n$[2,3,3]$: 第三条鱼吃掉第一条鱼，第三条鱼吃掉第五条鱼，你捉到了第三条鱼。\n\n$[3]$: 你捉到了第三条鱼。\n\n$[3,3]$: 第三条鱼吃掉第五条鱼，你捉到了第三条鱼。", "locale": "zh-CN"}}}
{"pid": "P4685", "type": "P", "difficulty": 6, "samples": [["5\n7\nPLPPL", "5"], ["12\n10000\nLPLLPLPPLPLL", "39"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2008", "IOI"], "title": "[IOI 2008] Linear Garden", "background": null, "description": "拉美西斯二世刚刚获胜归来。为了纪念这一胜利，他决定建造一座壮观的花园。这个花园里的植物排成一行，从他在卢克索的宫殿直达卡纳克神庙。所种植的植物只有莲花和纸莎草，因为它们分别代表上埃及和下埃及。\n\n这个花园中必须有$N$棵植物，并且必须保持平衡，即在花园中任取一段，其中莲花和纸莎草的棵数之差不能超过$2$。\n\n花园可以被表示为由字母 `L`（莲花）和 `P`（纸莎草）组成的字符串。例如，当 $N=5$ 时，有 $14$ 种可能的平衡花园，按照字母排序如下：`LLPLP`，`LLPPL`，`LPLLP`，`LPLPL`，`LPLPP`， `LPPLL`，`LPPLP`，`PLLPL`，`PLLPP`，`PLPLL`，`PLPLP`，`PLPPL`，`PPLLP` 和 `PPLPL`。\n\n给定长度的所有可能的平衡花园可按字母顺序排序，并从 $1$ 开始编号。例如，当 $N=5$ 时，第 $12$ 号花园是 `PLPPL`。 \n\n写一个程序，给定植物棵数 $N$ 和一个表示平衡花园的字符串，计算该花园的序号模 $M$ 的结果，其中 $M$ 是一个给定的整数。 注意，在问题求解中，数值 $M$ 除了简化计算外没有其他的作用。", "inputFormat": "第一行是整数 $N$，说明花园中植物的数量。第二行是整数 $M$。第三行是长度为 $N$ 的由字符 `L` 或 `P` 组成的字符串，表示一个平衡的花园。", "outputFormat": "你的程序需要向标准输出上输出一个介于 $0$ 和 $M-1$ 之间（含）的整数，占一行，表示该花园的序号模 $M$。", "hint": "有总分 40 分的测试点的 $N$ 不超过 $40$。\n\n对于所有测试点，$1\\le N\\le 1,000,000$，$7\\le M \\le 10,000,000$。 \n\n### 样例说明\n\n第一个样例中，实际的序号是 12。因此输出的是 12 模 7，即 5。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2008] Linear Garden", "background": "", "description": "Ramesses II has just returned victorious. To commemorate this victory, he decided to build a magnificent garden. The plants in this garden are arranged in a single line, stretching from his palace in Luxor all the way to the Karnak Temple. The only plants used are lotus and papyrus, because they represent Upper Egypt and Lower Egypt, respectively.\n\nThe garden must contain $N$ plants and must be balanced. That is, for any segment chosen within the garden, the difference between the number of lotus and the number of papyrus in that segment must not exceed $2$.\n\nThe garden can be represented as a string consisting of the letters `L` (lotus) and `P` (papyrus). For example, when $N=5$, there are $14$ possible balanced gardens. In lexicographical order, they are: `LLPLP`, `LLPPL`, `LPLLP`, `LPLPL`, `LPLPP`, `LPPLL`, `LPPLP`, `PLLPL`, `PLLPP`, `PLPLL`, `PLPLP`, `PLPPL`, `PPLLP`, and `PPLPL`.\n\nAll possible balanced gardens of a given length can be sorted in lexicographical order and numbered starting from $1$. For example, when $N=5$, garden number $12$ is `PLPPL`.\n\nWrite a program that, given the number of plants $N$ and a string representing a balanced garden, computes the garden’s index modulo $M$, where $M$ is a given integer. Note that in solving the problem, the value $M$ has no purpose other than simplifying the computation.", "inputFormat": "The first line contains an integer $N$, the number of plants in the garden. The second line contains an integer $M$. The third line contains a string of length $N$ consisting of characters `L` or `P`, representing a balanced garden.", "outputFormat": "Your program should output to standard output a single integer between $0$ and $M-1$ (inclusive), on one line, representing the garden’s index modulo $M$.", "hint": "There are test points worth 40 points where $N$ does not exceed $40$.\n\nFor all test points, $1\\le N\\le 1,000,000$ and $7\\le M \\le 10,000,000$.\n\n### Sample Explanation\n\nIn the first sample, the actual index is 12. Therefore, the output is $12$ modulo $7$, which is $5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2008] Linear Garden", "background": null, "description": "拉美西斯二世刚刚获胜归来。为了纪念这一胜利，他决定建造一座壮观的花园。这个花园里的植物排成一行，从他在卢克索的宫殿直达卡纳克神庙。所种植的植物只有莲花和纸莎草，因为它们分别代表上埃及和下埃及。\n\n这个花园中必须有$N$棵植物，并且必须保持平衡，即在花园中任取一段，其中莲花和纸莎草的棵数之差不能超过$2$。\n\n花园可以被表示为由字母 `L`（莲花）和 `P`（纸莎草）组成的字符串。例如，当 $N=5$ 时，有 $14$ 种可能的平衡花园，按照字母排序如下：`LLPLP`，`LLPPL`，`LPLLP`，`LPLPL`，`LPLPP`， `LPPLL`，`LPPLP`，`PLLPL`，`PLLPP`，`PLPLL`，`PLPLP`，`PLPPL`，`PPLLP` 和 `PPLPL`。\n\n给定长度的所有可能的平衡花园可按字母顺序排序，并从 $1$ 开始编号。例如，当 $N=5$ 时，第 $12$ 号花园是 `PLPPL`。 \n\n写一个程序，给定植物棵数 $N$ 和一个表示平衡花园的字符串，计算该花园的序号模 $M$ 的结果，其中 $M$ 是一个给定的整数。 注意，在问题求解中，数值 $M$ 除了简化计算外没有其他的作用。", "inputFormat": "第一行是整数 $N$，说明花园中植物的数量。第二行是整数 $M$。第三行是长度为 $N$ 的由字符 `L` 或 `P` 组成的字符串，表示一个平衡的花园。", "outputFormat": "你的程序需要向标准输出上输出一个介于 $0$ 和 $M-1$ 之间（含）的整数，占一行，表示该花园的序号模 $M$。", "hint": "有总分 40 分的测试点的 $N$ 不超过 $40$。\n\n对于所有测试点，$1\\le N\\le 1,000,000$，$7\\le M \\le 10,000,000$。 \n\n### 样例说明\n\n第一个样例中，实际的序号是 12。因此输出的是 12 模 7，即 5。", "locale": "zh-CN"}}}
{"pid": "P4686", "type": "P", "difficulty": 7, "samples": [["3\n1\n10 11\n1 4\n2 3", "6"], ["3\n3\n5 7\n6 10\n1999999 2000000", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2008", "IOI"], "title": "[IOI 2008] Teleporters", "background": "", "description": "你正在参加一项沿着直线路线自西向东横穿埃及的比赛。开始时你位于这条直线路线的最西端。根据比赛规则，你必须要沿着这条直线路线始终向东行进。\n\n在这条直线路线上有 $N$ 个传送器。每个传送器都有两个端点。每当你到达某个传送器的两个端点之一时，传送器都会立即将你传送到该传送器的另一个端点（注意，根据你所在的端点位置，传送器能够将你从当前位置向东或者向西传送）。当你被传送到另一个端点之后，你必须继续沿这条直线路线向东行进；你无法避开你前进路上的任何传送器端点。绝不会出现两个端点在同一位置的情形。所有端点都严格位于这条直线路线的起点和终点之间。\n\n每当你被传送一次，你就会获得 $1$ 分。比赛的目标就是获取尽可能多的分数。为使获得的分数最多，允许你在比赛开始前在这条路线上增设 $M$ 个新的传送器。使用这些新的传送器你也同样可以获得分数。\n\n你可以将这些新传送器的端点设在任何位置上（甚至是非整数坐标点也可以），只要这些坐标点并不出现在已经被另一个端点占用的位置上即可。换句话说，所有传送器的端点位置必须是唯一的。同样，新传送器的端点都必须严格位于这条直线路线的起点和终点之间。\n\n题目可以保证，不管你如何增设这些传送器，你一定可以到达比赛路线的终点。\n\n试编写一个程序，对于给定的 $N$ 个传送器的端点位置和你可以增设的新传送器的数目 $M$，计算你能获得的最高分数。", "inputFormat": "你的程序必须从标准输入中读入下列数据： \n- 第 $1$行包含一个整数 $N$，表示开始时在路线上的传送器数目；\n- 第 $2$行包含一个整数 $M$，表示你可以增设的新传送器的最大数目；\n- 随后的 $N$ 行每行描述一个传送器。第 $i$ 行描述第 $i$ 个传送器。每行有两个整数 $W_i$ 和 $E_i$，这两个整数分别描述从路线起点到该传送器的两个端点的距离。\n\n对于给定的这些传送器，没有任何两个端点在同一位置上。比赛路线的起点为位置 $0$，而终点则在位置 $2\\,000\\,001$ 上。 ", "outputFormat": "你的程序必须向标准输出写一行数据，这行数据只包含一个整数，表示你找到的能获得的最高分数。", "hint": "### 样例 1 说明\n\n![](https://cdn.luogu.com.cn/upload/pic/20908.png )\n\n上面左图表示一条初始有 $3$ 个传送器的比赛路线的情形。右图表示在增设一个端点分别为 $0.5$ 和 $1.5$ 的新传送器之后的同一比赛路线。\n\n在增设上图所示的新的传送器之后，你的比赛路途如下：\n- 你从位置 $0$ 出发，向东行进。\n- 你到达位于 $0.5$ 的传送器端点，并且被传送到另一端点 $1.5$（你获得 $1$ 分）。\n- 你继续向东行进，并且到达位于 $2$ 的传送器端点；你被传送到位于 $3$ 的另一端点（这时你共获得 $2$ 分）。\n- 你到达位于 $4$ 的传送器端点，并且被传送到位于 $1$ 的另一端点（这时你共获得 $3$ 分）。\n- 你到达位于 $1.5$ 的传送器端点，并且被传送到位于 $0.5$ 的另一端点（这时你共获得 $4$ 分）。\n- 你到达位于 $1$ 的传送器端点，并且被传送到位于 $4$ 的另一端点（这时你共获得 $5$ 分）。\n- 你到达位于 $10$ 的传送器端点，并且被传送到位于 $11$ 的另一端点（这时你共获得 $6$ 分）。\n- 你继续行进直到到达比赛的终点，以获得总分为 $6$ 分结束。\n\n### 数据范围\n\n- 对于 $30\\%$ 的数据，$N \\leq 500$ 并且 $M \\leq 500$。 \n- 对于所有数据，$1 \\leq N \\leq 1,000,000$，$1 \\leq M \\leq 1,000,000$，$1 \\leq W_X < E_X \\leq 2,000,000$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2008] Teleporters", "background": "", "description": "You are taking part in a race that goes from west to east along a straight route across Egypt. At the start, you are at the westernmost end of this straight route. According to the rules, you must always move east along this straight route.\n\nThere are $N$ teleporters on this route. Each teleporter has two endpoints. Whenever you reach one of the two endpoints of a teleporter, it immediately teleports you to the other endpoint (note that depending on which endpoint you are at, the teleporter may send you eastward or westward). After being teleported to the other endpoint, you must continue moving east along the route; you cannot avoid any teleporter endpoints that lie on your path. It is guaranteed that no teleporter has both endpoints at the same position. All endpoints lie strictly between the start and the finish of the route.\n\nEach time you are teleported, you gain $1$ point. The goal of the race is to gain as many points as possible. To maximize your score, you are allowed to add up to $M$ new teleporters on this route before the race starts. You can also gain points by using these new teleporters.\n\nYou may place the endpoints of these new teleporters at any positions (even at non-integer coordinates), as long as those positions are not already occupied by another endpoint. In other words, all teleporter endpoint positions must be unique. Likewise, the endpoints of the new teleporters must also lie strictly between the start and the finish of the route.\n\nIt is guaranteed that no matter how you add these teleporters, you will always be able to reach the finish of the race route.\n\nWrite a program that, given the endpoints of the $N$ existing teleporters and the number $M$ of new teleporters you may add, computes the maximum score you can obtain.", "inputFormat": "Your program must read the following data from standard input:\n- Line $1$ contains an integer $N$, the number of teleporters initially on the route.\n- Line $2$ contains an integer $M$, the maximum number of new teleporters you may add.\n- The next $N$ lines each describe one teleporter. Line $i$ describes the $i$-th teleporter and contains two integers $W_i$ and $E_i$, which give the distances from the start of the route to the two endpoints of that teleporter.\n\nFor these teleporters, no two endpoints are at the same position. The start of the race route is at position $0$, and the finish is at position $2\\,000\\,001$.", "outputFormat": "Your program must write one line to standard output containing a single integer, the maximum score you can achieve.", "hint": "### Explanation for Sample 1\n\n![](https://cdn.luogu.com.cn/upload/pic/20908.png )\n\nThe left figure above shows a race route with $3$ teleporters initially. The right figure shows the same route after adding one new teleporter with endpoints at $0.5$ and $1.5$.\n\nAfter adding the new teleporter shown above, your journey is as follows:\n- You start at position $0$ and move east.\n- You reach the teleporter endpoint at $0.5$ and are teleported to the other endpoint at $1.5$ (you gain $1$ point).\n- You continue moving east and reach the teleporter endpoint at $2$; you are teleported to the other endpoint at $3$ (you now have $2$ points in total).\n- You reach the teleporter endpoint at $4$ and are teleported to the other endpoint at $1$ (you now have $3$ points in total).\n- You reach the teleporter endpoint at $1.5$ and are teleported to the other endpoint at $0.5$ (you now have $4$ points in total).\n- You reach the teleporter endpoint at $1$ and are teleported to the other endpoint at $4$ (you now have $5$ points in total).\n- You reach the teleporter endpoint at $10$ and are teleported to the other endpoint at $11$ (you now have $6$ points in total).\n- You continue until you reach the finish of the race, ending with a total score of $6$ points.\n\n### Constraints\n\n- For $30\\%$ of the testdata, $N \\leq 500$ and $M \\leq 500$.\n- For all testdata, $1 \\leq N \\leq 1,000,000$, $1 \\leq M \\leq 1,000,000$, $1 \\leq W_X < E_X \\leq 2,000,000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2008] Teleporters", "background": "", "description": "你正在参加一项沿着直线路线自西向东横穿埃及的比赛。开始时你位于这条直线路线的最西端。根据比赛规则，你必须要沿着这条直线路线始终向东行进。\n\n在这条直线路线上有 $N$ 个传送器。每个传送器都有两个端点。每当你到达某个传送器的两个端点之一时，传送器都会立即将你传送到该传送器的另一个端点（注意，根据你所在的端点位置，传送器能够将你从当前位置向东或者向西传送）。当你被传送到另一个端点之后，你必须继续沿这条直线路线向东行进；你无法避开你前进路上的任何传送器端点。绝不会出现两个端点在同一位置的情形。所有端点都严格位于这条直线路线的起点和终点之间。\n\n每当你被传送一次，你就会获得 $1$ 分。比赛的目标就是获取尽可能多的分数。为使获得的分数最多，允许你在比赛开始前在这条路线上增设 $M$ 个新的传送器。使用这些新的传送器你也同样可以获得分数。\n\n你可以将这些新传送器的端点设在任何位置上（甚至是非整数坐标点也可以），只要这些坐标点并不出现在已经被另一个端点占用的位置上即可。换句话说，所有传送器的端点位置必须是唯一的。同样，新传送器的端点都必须严格位于这条直线路线的起点和终点之间。\n\n题目可以保证，不管你如何增设这些传送器，你一定可以到达比赛路线的终点。\n\n试编写一个程序，对于给定的 $N$ 个传送器的端点位置和你可以增设的新传送器的数目 $M$，计算你能获得的最高分数。", "inputFormat": "你的程序必须从标准输入中读入下列数据： \n- 第 $1$行包含一个整数 $N$，表示开始时在路线上的传送器数目；\n- 第 $2$行包含一个整数 $M$，表示你可以增设的新传送器的最大数目；\n- 随后的 $N$ 行每行描述一个传送器。第 $i$ 行描述第 $i$ 个传送器。每行有两个整数 $W_i$ 和 $E_i$，这两个整数分别描述从路线起点到该传送器的两个端点的距离。\n\n对于给定的这些传送器，没有任何两个端点在同一位置上。比赛路线的起点为位置 $0$，而终点则在位置 $2\\,000\\,001$ 上。 ", "outputFormat": "你的程序必须向标准输出写一行数据，这行数据只包含一个整数，表示你找到的能获得的最高分数。", "hint": "### 样例 1 说明\n\n![](https://cdn.luogu.com.cn/upload/pic/20908.png )\n\n上面左图表示一条初始有 $3$ 个传送器的比赛路线的情形。右图表示在增设一个端点分别为 $0.5$ 和 $1.5$ 的新传送器之后的同一比赛路线。\n\n在增设上图所示的新的传送器之后，你的比赛路途如下：\n- 你从位置 $0$ 出发，向东行进。\n- 你到达位于 $0.5$ 的传送器端点，并且被传送到另一端点 $1.5$（你获得 $1$ 分）。\n- 你继续向东行进，并且到达位于 $2$ 的传送器端点；你被传送到位于 $3$ 的另一端点（这时你共获得 $2$ 分）。\n- 你到达位于 $4$ 的传送器端点，并且被传送到位于 $1$ 的另一端点（这时你共获得 $3$ 分）。\n- 你到达位于 $1.5$ 的传送器端点，并且被传送到位于 $0.5$ 的另一端点（这时你共获得 $4$ 分）。\n- 你到达位于 $1$ 的传送器端点，并且被传送到位于 $4$ 的另一端点（这时你共获得 $5$ 分）。\n- 你到达位于 $10$ 的传送器端点，并且被传送到位于 $11$ 的另一端点（这时你共获得 $6$ 分）。\n- 你继续行进直到到达比赛的终点，以获得总分为 $6$ 分结束。\n\n### 数据范围\n\n- 对于 $30\\%$ 的数据，$N \\leq 500$ 并且 $M \\leq 500$。 \n- 对于所有数据，$1 \\leq N \\leq 1,000,000$，$1 \\leq M \\leq 1,000,000$，$1 \\leq W_X < E_X \\leq 2,000,000$。", "locale": "zh-CN"}}}
{"pid": "P4687", "type": "P", "difficulty": 7, "samples": [["6 9\n42\n5\n4 1 6 3 12\n3 6 5 6 9\n1 3 3 8 24\n3 8 6 9 21\n5 1 6 2 20", "4"], ["13 5\n0\n8\n8 4 10 4 1\n4 3 4 4 1\n10 2 12 2 2\n8 2 8 4 3\n2 4 6 4 5\n10 3 10 4 8\n12 3 12 4 13\n2 2 4 2 21", "3"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2008", "IOI"], "title": "[IOI 2008] Pyramid Base", "background": "", "description": "你要在自己财力许可的范围内寻找一个尽可能大的地方，以便兴建一个新的金字塔。为帮助你作出决定，为你提供了土地测绘图。为方便起见，该地块被划分为由$M\\times N$个小正方形构成的网格。金字塔的地基部份必须是正方形，而且各边要与这些方格平行。\n\n测绘图中标出了$P$个有可能重叠的障碍物，这些障碍物是上述网格上的长方形，其各边与方格平行。为了建造金字塔，任何塔基所占方格中的障碍物必须被移走。移除障碍物$i$需要付出成本$C_i$。当移除一个障碍物时，需要将障碍物整个地移除，即不能只移除障碍物的一部份。同时，移除一个障碍物对与其重叠的其他障碍物无任何影响。\n\n已知测绘图中$M$和$N$的大小，对$P$个障碍物的描述，移走每个障碍物的成本以及你的预算$B$。编写程序，找出在移走障碍物总成本不超过$B$的前提下金字塔地基的最大边长。 \n\n", "inputFormat": "你的程序需要从标准输入上读入以下数据： \n- 第一行包含两个以单个空格分隔的整数，分别表示$M$及$N$。 \n- 第二行包含整数$B$，是你可付出的最大成本（即你的预算）。 \n- 第三行包含整数$P$，是测绘图中标出的障碍物数量。 \n- 以下$P$行的每一行表示一个障碍物。其中第$i$ 行表示第$i$个障碍物。每一行包含$5$个以单个空格分隔的整数$X_{i1}, Y_{i1}, X_{i2}, Y_{i2}$和$C_i$，分别表示障碍物左下角小正方形的座标，右上角小正方形的座标，以及移除这个障碍物的成本。网格左下角的小正方形座标为$(1,1)$，而其右上角小正方形为$(M, N)$。 ", "outputFormat": "你的程序必须向标准输出写出一行，该行只含一个整数，即金字塔基可能的最大边长。如果无法建造任何金字塔，程序应输出0。 ", "hint": "### 样例说明\n\n样例1：\n\n![](https://cdn.luogu.com.cn/upload/pic/20909.png )\n\n样例2：\n\n![](https://cdn.luogu.com.cn/upload/pic/20910.png )\n\n### 数据范围\n\n程序用三组不相交的数据进行评测。以下限制适用于所有的测试数据： $1 \\leq M, N \\leq 1,000,000$ 网格的尺寸。 $1 \\leq Ci \\leq 7,000$ 移除障碍物i的成本。 对每个障碍物$i$均有 $1 \\leq X_{i1} \\leq X_{i2} \\leq M$ 并且 $1 \\leq Y_{i1} \\leq Y_{i2}\\leq N$。 \n\n第一组测试总分值35分： \n\n- $B = 0$ ——可以付出的最大成本。（不可移除任何障碍物）\n- $1\\leq P \\leq 1,000$ ——网格中障碍物的数目。\n\n第二组测试总分值35分：\n\n- $0 < B \\leq 2,000,000,000$ ——你的预算。\n\n- $1\\leq P \\leq 30,000$ ——网格中障碍物的数目。 \n\n第三组测试值30分：\n\n- $B = 0$ ——你的预算。（不可以移除任何障碍物）\n\n- $1\\leq P \\leq 400,000$ ——网格中障碍物的数目。 ", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2008] Pyramid Base", "background": "", "description": "You want to find the largest possible place you can afford to build a new pyramid. To help you decide, you are given a land survey map. For convenience, the area is divided into a grid of $M \\times N$ small squares. The base of the pyramid must be a square, and each side must be parallel to the grid lines.\n\nThe map marks $P$ obstacles that may overlap. These obstacles are rectangles on the grid, with sides parallel to the grid lines. To build the pyramid, any obstacle that occupies any square covered by the base must be removed. Removing obstacle $i$ costs $C_i$. When removing an obstacle, you must remove the entire obstacle; you cannot remove only part of it. Also, removing one obstacle does not affect any other obstacles that overlap with it.\n\nGiven $M$ and $N$, the description of the $P$ obstacles, the cost to remove each obstacle, and your budget $B$, write a program to find the maximum possible side length of the pyramid base such that the total cost of removed obstacles does not exceed $B$.", "inputFormat": "Your program should read the following data from standard input:\n- The first line contains two integers separated by a single space, representing $M$ and $N$.\n- The second line contains an integer $B$, the maximum cost you can pay (i.e., your budget).\n- The third line contains an integer $P$, the number of obstacles marked on the map.\n- The next $P$ lines each describe one obstacle. The $i$-th of these lines describes obstacle $i$. Each line contains $5$ integers separated by single spaces: $X_{i1}, Y_{i1}, X_{i2}, Y_{i2}$, and $C_i$, representing the coordinates of the lower-left small square of the obstacle, the coordinates of the upper-right small square of the obstacle, and the cost to remove this obstacle. The coordinate of the lower-left small square of the grid is $(1,1)$, and the upper-right small square is $(M, N)$.", "outputFormat": "Your program must write one line to standard output containing a single integer, the maximum possible side length of the pyramid base. If it is not possible to build any pyramid, output $0$.", "hint": "### Sample Explanation\n\nSample 1:\n\n![](https://cdn.luogu.com.cn/upload/pic/20909.png )\n\nSample 2:\n\n![](https://cdn.luogu.com.cn/upload/pic/20910.png )\n\n### Constraints\n\nThe program is evaluated using three non-overlapping groups of testdata. The following limits apply to all testdata: $1 \\leq M, N \\leq 1,000,000$, the size of the grid. $1 \\leq Ci \\leq 7,000$, the cost to remove obstacle $i$. For each obstacle $i$, $1 \\leq X_{i1} \\leq X_{i2} \\leq M$ and $1 \\leq Y_{i1} \\leq Y_{i2}\\leq N$.\n\nThe first group is worth 35 points:\n\n- $B = 0$, the maximum cost you can pay (no obstacles can be removed).\n- $1 \\leq P \\leq 1,000$, the number of obstacles in the grid.\n\nThe second group is worth 35 points:\n\n- $0 < B \\leq 2,000,000,000$, your budget.\n- $1 \\leq P \\leq 30,000$, the number of obstacles in the grid.\n\nThe third group is worth 30 points:\n\n- $B = 0$, your budget (no obstacles can be removed).\n- $1 \\leq P \\leq 400,000$, the number of obstacles in the grid.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2008] Pyramid Base", "background": "", "description": "你要在自己财力许可的范围内寻找一个尽可能大的地方，以便兴建一个新的金字塔。为帮助你作出决定，为你提供了土地测绘图。为方便起见，该地块被划分为由$M\\times N$个小正方形构成的网格。金字塔的地基部份必须是正方形，而且各边要与这些方格平行。\n\n测绘图中标出了$P$个有可能重叠的障碍物，这些障碍物是上述网格上的长方形，其各边与方格平行。为了建造金字塔，任何塔基所占方格中的障碍物必须被移走。移除障碍物$i$需要付出成本$C_i$。当移除一个障碍物时，需要将障碍物整个地移除，即不能只移除障碍物的一部份。同时，移除一个障碍物对与其重叠的其他障碍物无任何影响。\n\n已知测绘图中$M$和$N$的大小，对$P$个障碍物的描述，移走每个障碍物的成本以及你的预算$B$。编写程序，找出在移走障碍物总成本不超过$B$的前提下金字塔地基的最大边长。 \n\n", "inputFormat": "你的程序需要从标准输入上读入以下数据： \n- 第一行包含两个以单个空格分隔的整数，分别表示$M$及$N$。 \n- 第二行包含整数$B$，是你可付出的最大成本（即你的预算）。 \n- 第三行包含整数$P$，是测绘图中标出的障碍物数量。 \n- 以下$P$行的每一行表示一个障碍物。其中第$i$ 行表示第$i$个障碍物。每一行包含$5$个以单个空格分隔的整数$X_{i1}, Y_{i1}, X_{i2}, Y_{i2}$和$C_i$，分别表示障碍物左下角小正方形的座标，右上角小正方形的座标，以及移除这个障碍物的成本。网格左下角的小正方形座标为$(1,1)$，而其右上角小正方形为$(M, N)$。 ", "outputFormat": "你的程序必须向标准输出写出一行，该行只含一个整数，即金字塔基可能的最大边长。如果无法建造任何金字塔，程序应输出0。 ", "hint": "### 样例说明\n\n样例1：\n\n![](https://cdn.luogu.com.cn/upload/pic/20909.png )\n\n样例2：\n\n![](https://cdn.luogu.com.cn/upload/pic/20910.png )\n\n### 数据范围\n\n程序用三组不相交的数据进行评测。以下限制适用于所有的测试数据： $1 \\leq M, N \\leq 1,000,000$ 网格的尺寸。 $1 \\leq Ci \\leq 7,000$ 移除障碍物i的成本。 对每个障碍物$i$均有 $1 \\leq X_{i1} \\leq X_{i2} \\leq M$ 并且 $1 \\leq Y_{i1} \\leq Y_{i2}\\leq N$。 \n\n第一组测试总分值35分： \n\n- $B = 0$ ——可以付出的最大成本。（不可移除任何障碍物）\n- $1\\leq P \\leq 1,000$ ——网格中障碍物的数目。\n\n第二组测试总分值35分：\n\n- $0 < B \\leq 2,000,000,000$ ——你的预算。\n\n- $1\\leq P \\leq 30,000$ ——网格中障碍物的数目。 \n\n第三组测试值30分：\n\n- $B = 0$ ——你的预算。（不可以移除任何障碍物）\n\n- $1\\leq P \\leq 400,000$ ——网格中障碍物的数目。 ", "locale": "zh-CN"}}}
{"pid": "P4688", "type": "P", "difficulty": 6, "samples": [["5 2\n1 2 2 3 3\n1 2 2 3 3 4\n1 5 1 5 1 5", "3\n0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "莫队", "离散化", "O2优化", "Ynoi", "离线处理", "bitset"], "title": "[Ynoi Easy Round 2016] 掉进兔子洞", "background": "5.632\n\n我（或者是在读这篇文字的你）不属于这个世界\n\n这是世界的界限\n\n6.41\n\n世界的意义必定存在于世界之外\n\n世界中的一切事物如其所存在般而存在，如其所发生般而发生\n\n世界之中不存在价值\n\n——《逻辑哲学论》\n\n我们的情人，不过是随便借个名字，用幻想吹出来的肥皂泡\n\n把信拿去吧，你可以使假戏成真\n\n我本来是无病呻吟，漫无目的的吐露爱情---现在这些漂泊不定的鸟儿有地方栖息了，你可以从信里看出来\n\n拿去吧---由于不是出自真心，话就说得格外动听，拿去吧，就这么办吧...\n\n![](https://cdn.luogu.com.cn/upload/pic/21091.png)\n\n果然……好女人要有的是，烟、楼顶……还有轻飘飘的衣服呀……\n\n某一天，水上由岐看见天上掉下了个布制玩偶\n\n为了被天空接受而投掷出的她的布偶，不知在天空飞舞了多少次，已经遍体鳞伤\n\n“被天空接受”——那是为了寻找不知何时开始在这个城市流传的“回归天空之路”的行为\n\n![](https://cdn.luogu.com.cn/upload/pic/21102.png)\n\n为了被天空接受而被扔出去的木偶，在空中飞舞并最终坠落\n\n那是为了将其本身即为世界的少女送予天空的少女的行为\n\n![](https://cdn.luogu.com.cn/upload/pic/21093.png)\n\n横跨银河，被称作Vega与Altair，或是织女星与牛郎星的两颗星星，再加上北十字星之顶的天鹅座构成了夏之大三角\n\n它被称作譬如三位一体的神圣的图形\n\n只有神圣的图形在天空闪耀之时，世界才与天空相遇\n\n![](https://cdn.luogu.com.cn/upload/pic/21094.png)\n\n我想试一试，第一次，也是最后一次的恶作剧\n\n![](https://cdn.luogu.com.cn/upload/pic/21095.png)\n\n那是...什么？\n\n什么事也没有哦，只是，间宫君他自己主动跳下去了而已哦~\n\n怎么回事？\n\n什么事也没有哦，只是，间宫君他自己主动跳下去了而已哦~\n\n但是我看到了，是那个杀死了大家吗？\n\n什么事也没有哦，只是，间宫君他自己主动跳下去了而已哦~\n\n不，那个东西，什么都没有做，只是...\n\n什么事也没有哦，只是，间宫君他自己主动跳下去了而已哦~\n\n只是...怎么回事...\n\n什么事也没有哦，只是，间宫君他自己主动跳下去了而已哦~\n\n我确实听到了头盖骨破碎的声音\n\n但是那个，并非是外面的世界\n\n而是总自己的里面传来的\n\n![](https://cdn.luogu.com.cn/upload/pic/21096.png)\n\n水上同学...我偶尔会思考这种事情...\n\n世界的极限到底在哪里呢...\n\n世界的...世界的尽头的更尽头...\n\n要是能有那种地方...\n\n要是假如我能够站在那个地方的话...我还是能跟平时一样看着那个尽头的风景吗？我有这种想法....\n\n我理所当然的想着这种事...然后决定似乎是有些奇怪啊\n\n因为那里是世界的尽头哦\n\n是世界的极限哦\n\n如果我能够看到那个的话...世界的极限...是否就等同于我的极限呢？\n\n因为，从那里看到的世界...我所看见的...不就是我的世界吗？\n\n世界的极限...就会变成我的极限吧~\n\n世界就是我看到的摸到的，并且感受到的东西\n\n那样的话，世界到底是什么呢\n\n世界和我到底有什么不同呢...我有这种想法\n\n有吗？\n\n世界和我的差别\n\n是一样的\n\n但是，或许其他人也有相同的感觉...\n\n就连你，或许也认为世界就是你自己吧\n\n并且，我觉得那个大概是正确的...\n\n虽然我不太清楚...大概是你也站在世界的尽头，跟我一样在看着它吧\n\n所以，你也和世界一样\n\n但是啊，那样果然很奇怪啊...\n\n如果世界就是我的话...为什么我会看不到你看到的世界呢？\n\n明明我的世界里有你存在...却看不到你看到的世界\n\n我从来没有看到过你看到的世界\n\n那个，简直就像是两者不会交集的平行宇宙一样...\n\n即使有现象暗示着那个东西存在...却是绝对的无法触碰...\n\n我...看不到你所在的世界...\n\n但是...\n\n那个也是真的是真的吗？\n\n我真的没有看到过你的世界吗...\n\n既然所有的人都平等的拥有她们自己的世界的话\n\n那么为什么世界会变成一个呢？\n\n为什么那么多的世界会存在于这里呢？\n\n世界变成一个的理由\n\n...我偶尔会思考这种事情\n\n所以...我才能够喜欢上你\n\n", "description": "您正在打 galgame，然后突然发现您今天太颓了，于是想写个数据结构题练练手：\n\n一个长为 $n$ 的序列 $a$。\n\n有 $m$ 个询问，每次询问三个区间，把三个区间中同时出现的数一个一个删掉，问最后三个区间剩下的数的个数和，询问独立。\n\n注意这里删掉指的是一个一个删，不是把等于这个值的数直接删完，比如三个区间是  $[1,2,2,3,3,3,3]$，$[1,2,2,3,3,3,3]$ 与 $[1,1,2,3,3]$，就一起扔掉了 $1$ 个 $1$，$1$ 个 $2$，$2$ 个 $3$。", "inputFormat": "第一行两个整数表示 $n,m$。\n\n第二行 $n$ 个整数表示 $a_i$。\n\n之后 $m$ 行，每行 $6$ 个整数 $l_1,r_1,l_2,r_2,l_3,r_3$ 表示这三个区间。", "outputFormat": "对于每个询问，输出一个整数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477\n\n$1\\leq n , m \\leq 10^5$，$1 \\leq a_i\\leq 10^9$，$1\\leq l_1,r_1,l_2,r_2,l_3,r_3\\leq n$，$l_1\\leq r_1$，$l_2\\leq r_2$，$l_3\\leq r_3$。", "locale": "zh-CN", "translations": {"en": {"title": "[Ynoi Easy Round 2016] Falling into the Rabbit Hole", "background": "5.632\n\nI (or you who are reading this text) do not belong to this world.\n\nThis is the boundary of the world.\n\n6.41\n\nThe meaning of the world must lie outside the world.\n\nEverything in the world exists as it exists, and happens as it happens.\n\nThere is no value in the world.\n\n— *Tractatus Logico-Philosophicus*\n\nOur lover is just a soap bubble blown up by fantasy, borrowing a name at random.\n\nTake the letter. You can make the fake act come true.\n\nI was originally just complaining for no reason, spilling out love without any goal—now these drifting birds finally have a place to rest, and you can see it from the letter.\n\nTake it—since it is not from the heart, the words sound especially pleasant. Take it, let’s do it like this...\n\n![](https://cdn.luogu.com.cn/upload/pic/21091.png)\n\nAs expected... what a good woman needs is: cigarettes, the rooftop... and light, fluttering clothes...\n\nOne day, Mizukami Yuki saw a cloth doll falling from the sky onto the water.\n\nThat cloth doll, thrown in order to be “accepted by the sky”, must have flown around in the sky countless times, already covered in wounds.\n\n“Accepted by the sky”—that was an act to search for the “road to return to the sky” that had been spreading in this city since who knows when.\n\n![](https://cdn.luogu.com.cn/upload/pic/21102.png)\n\nA puppet that was thrown out to be accepted by the sky, dancing in the air and finally falling.\n\nThat was the act of a girl who tried to offer to the sky a girl who herself is the world.\n\n![](https://cdn.luogu.com.cn/upload/pic/21093.png)\n\nSpanning the Milky Way, the two stars called Vega and Altair, or Zhinü-xing and Niulang-xing, together with Deneb at the top of the Northern Cross, form the Summer Triangle.\n\nIt is called, for example, a sacred figure like the Trinity.\n\nOnly when the sacred figure shines in the sky does the world meet the sky.\n\n![](https://cdn.luogu.com.cn/upload/pic/21094.png)\n\nI want to try it—a prank for the first time, and also the last time.\n\n![](https://cdn.luogu.com.cn/upload/pic/21095.png)\n\nThat is... what?\n\nNothing happened, you know. It’s just that Mamiya-kun jumped down on his own initiative~\n\nWhat is going on?\n\nNothing happened, you know. It’s just that Mamiya-kun jumped down on his own initiative~\n\nBut I saw it. Was it that thing that killed everyone?\n\nNothing happened, you know. It’s just that Mamiya-kun jumped down on his own initiative~\n\nNo, that thing did nothing. It’s just...\n\nNothing happened, you know. It’s just that Mamiya-kun jumped down on his own initiative~\n\nJust... what is going on...\n\nNothing happened, you know. It’s just that Mamiya-kun jumped down on his own initiative~\n\nI definitely heard the sound of a skull shattering.\n\nBut that was not from the outside world.\n\nIt came from inside myself.\n\n![](https://cdn.luogu.com.cn/upload/pic/21096.png)\n\nMizukami... I sometimes think about things like this...\n\nWhere exactly is the limit of the world...\n\nBeyond the end of the world... even further beyond...\n\nIf there were such a place...\n\nIf I could stand at that place... could I still look at the scenery at the end, just like usual? I think about that....\n\nI naturally thought about it... and then decided that it seems a bit strange.\n\nBecause that is the end of the world.\n\nIt is the limit of the world.\n\nIf I can see that... then would the limit of the world... be equal to my limit?\n\nBecause the world seen from there... what I see... is my world, isn’t it?\n\nThe limit of the world... will become my limit~\n\nThe world is what I see, touch, and feel.\n\nIf so, what exactly is the world?\n\nWhat is the difference between the world and me... I think about that.\n\nIs there?\n\nThe difference between the world and me.\n\nIt is the same.\n\nBut perhaps other people also feel the same...\n\nEven you might also think that the world is yourself.\n\nAnd I think that is probably correct...\n\nAlthough I am not very sure... maybe you are also standing at the end of the world, looking at it like me.\n\nSo you are also the same as the world.\n\nBut... that is indeed strange...\n\nIf the world is me... why can’t I see the world that you see?\n\nEven though you exist in my world... I still can’t see the world that you see.\n\nI have never seen the world that you see.\n\nThat is almost like two parallel universes that never intersect...\n\nEven if there are phenomena suggesting that thing exists... it is absolutely untouchable...\n\nI... can’t see the world where you are...\n\nBut...\n\nIs that really true?\n\nHave I really never seen your world...\n\nIf everyone equally has their own world,\n\nthen why does the world become one?\n\nWhy do so many worlds exist here?\n\nThe reason why the world becomes one\n\n...I sometimes think about such things.\n\nSo... that is why I can come to like you.", "description": "You are playing a galgame, and suddenly realize you have been slacking off too much today, so you want to write a data structure problem to practice:\n\nThere is a sequence $a$ of length $n$.\n\nThere are $m$ queries. Each query gives three intervals. For numbers that appear in all three intervals, delete them one by one. Ask for the sum of the counts of remaining numbers in the three intervals at the end. Queries are independent.\n\nNote that “delete” means deleting one by one, not deleting all elements equal to that value at once. For example, if the three intervals are $[1,2,2,3,3,3,3]$, $[1,2,2,3,3,3,3]$, and $[1,1,2,3,3]$, then we throw away $1$ occurrence of $1$, $1$ occurrence of $2$, and $2$ occurrences of $3$ together.", "inputFormat": "The first line contains two integers $n,m$.\n\nThe second line contains $n$ integers denoting $a_i$.\n\nThen follow $m$ lines. Each line contains $6$ integers $l_1,r_1,l_2,r_2,l_3,r_3$ describing the three intervals.", "outputFormat": "For each query, output one integer denoting the answer.", "hint": "Idea: nzhtl1477, Solution: nzhtl1477, Code: nzhtl1477, Data: nzhtl1477\n\n$1\\leq n , m \\leq 10^5$, $1 \\leq a_i\\leq 10^9$, $1\\leq l_1,r_1,l_2,r_2,l_3,r_3\\leq n$, $l_1\\leq r_1$, $l_2\\leq r_2$, $l_3\\leq r_3$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Ynoi Easy Round 2016] 掉进兔子洞", "background": "5.632\n\n我（或者是在读这篇文字的你）不属于这个世界\n\n这是世界的界限\n\n6.41\n\n世界的意义必定存在于世界之外\n\n世界中的一切事物如其所存在般而存在，如其所发生般而发生\n\n世界之中不存在价值\n\n——《逻辑哲学论》\n\n我们的情人，不过是随便借个名字，用幻想吹出来的肥皂泡\n\n把信拿去吧，你可以使假戏成真\n\n我本来是无病呻吟，漫无目的的吐露爱情---现在这些漂泊不定的鸟儿有地方栖息了，你可以从信里看出来\n\n拿去吧---由于不是出自真心，话就说得格外动听，拿去吧，就这么办吧...\n\n![](https://cdn.luogu.com.cn/upload/pic/21091.png)\n\n果然……好女人要有的是，烟、楼顶……还有轻飘飘的衣服呀……\n\n某一天，水上由岐看见天上掉下了个布制玩偶\n\n为了被天空接受而投掷出的她的布偶，不知在天空飞舞了多少次，已经遍体鳞伤\n\n“被天空接受”——那是为了寻找不知何时开始在这个城市流传的“回归天空之路”的行为\n\n![](https://cdn.luogu.com.cn/upload/pic/21102.png)\n\n为了被天空接受而被扔出去的木偶，在空中飞舞并最终坠落\n\n那是为了将其本身即为世界的少女送予天空的少女的行为\n\n![](https://cdn.luogu.com.cn/upload/pic/21093.png)\n\n横跨银河，被称作Vega与Altair，或是织女星与牛郎星的两颗星星，再加上北十字星之顶的天鹅座构成了夏之大三角\n\n它被称作譬如三位一体的神圣的图形\n\n只有神圣的图形在天空闪耀之时，世界才与天空相遇\n\n![](https://cdn.luogu.com.cn/upload/pic/21094.png)\n\n我想试一试，第一次，也是最后一次的恶作剧\n\n![](https://cdn.luogu.com.cn/upload/pic/21095.png)\n\n那是...什么？\n\n什么事也没有哦，只是，间宫君他自己主动跳下去了而已哦~\n\n怎么回事？\n\n什么事也没有哦，只是，间宫君他自己主动跳下去了而已哦~\n\n但是我看到了，是那个杀死了大家吗？\n\n什么事也没有哦，只是，间宫君他自己主动跳下去了而已哦~\n\n不，那个东西，什么都没有做，只是...\n\n什么事也没有哦，只是，间宫君他自己主动跳下去了而已哦~\n\n只是...怎么回事...\n\n什么事也没有哦，只是，间宫君他自己主动跳下去了而已哦~\n\n我确实听到了头盖骨破碎的声音\n\n但是那个，并非是外面的世界\n\n而是总自己的里面传来的\n\n![](https://cdn.luogu.com.cn/upload/pic/21096.png)\n\n水上同学...我偶尔会思考这种事情...\n\n世界的极限到底在哪里呢...\n\n世界的...世界的尽头的更尽头...\n\n要是能有那种地方...\n\n要是假如我能够站在那个地方的话...我还是能跟平时一样看着那个尽头的风景吗？我有这种想法....\n\n我理所当然的想着这种事...然后决定似乎是有些奇怪啊\n\n因为那里是世界的尽头哦\n\n是世界的极限哦\n\n如果我能够看到那个的话...世界的极限...是否就等同于我的极限呢？\n\n因为，从那里看到的世界...我所看见的...不就是我的世界吗？\n\n世界的极限...就会变成我的极限吧~\n\n世界就是我看到的摸到的，并且感受到的东西\n\n那样的话，世界到底是什么呢\n\n世界和我到底有什么不同呢...我有这种想法\n\n有吗？\n\n世界和我的差别\n\n是一样的\n\n但是，或许其他人也有相同的感觉...\n\n就连你，或许也认为世界就是你自己吧\n\n并且，我觉得那个大概是正确的...\n\n虽然我不太清楚...大概是你也站在世界的尽头，跟我一样在看着它吧\n\n所以，你也和世界一样\n\n但是啊，那样果然很奇怪啊...\n\n如果世界就是我的话...为什么我会看不到你看到的世界呢？\n\n明明我的世界里有你存在...却看不到你看到的世界\n\n我从来没有看到过你看到的世界\n\n那个，简直就像是两者不会交集的平行宇宙一样...\n\n即使有现象暗示着那个东西存在...却是绝对的无法触碰...\n\n我...看不到你所在的世界...\n\n但是...\n\n那个也是真的是真的吗？\n\n我真的没有看到过你的世界吗...\n\n既然所有的人都平等的拥有她们自己的世界的话\n\n那么为什么世界会变成一个呢？\n\n为什么那么多的世界会存在于这里呢？\n\n世界变成一个的理由\n\n...我偶尔会思考这种事情\n\n所以...我才能够喜欢上你\n\n", "description": "您正在打 galgame，然后突然发现您今天太颓了，于是想写个数据结构题练练手：\n\n一个长为 $n$ 的序列 $a$。\n\n有 $m$ 个询问，每次询问三个区间，把三个区间中同时出现的数一个一个删掉，问最后三个区间剩下的数的个数和，询问独立。\n\n注意这里删掉指的是一个一个删，不是把等于这个值的数直接删完，比如三个区间是  $[1,2,2,3,3,3,3]$，$[1,2,2,3,3,3,3]$ 与 $[1,1,2,3,3]$，就一起扔掉了 $1$ 个 $1$，$1$ 个 $2$，$2$ 个 $3$。", "inputFormat": "第一行两个整数表示 $n,m$。\n\n第二行 $n$ 个整数表示 $a_i$。\n\n之后 $m$ 行，每行 $6$ 个整数 $l_1,r_1,l_2,r_2,l_3,r_3$ 表示这三个区间。", "outputFormat": "对于每个询问，输出一个整数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477\n\n$1\\leq n , m \\leq 10^5$，$1 \\leq a_i\\leq 10^9$，$1\\leq l_1,r_1,l_2,r_2,l_3,r_3\\leq n$，$l_1\\leq r_1$，$l_2\\leq r_2$，$l_3\\leq r_3$。", "locale": "zh-CN"}}}
{"pid": "P4689", "type": "P", "difficulty": 6, "samples": [["5 5\n1 2 3 4 5\n1 2\n1 3\n3 4\n3 5\n2 4 5\n2 1 5\n2 3 5\n1 5\n2 4 5", "0\n1\n1\n1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "莫队", "离散化", "O2优化", "构造", "Ynoi"], "title": "[Ynoi Easy Round 2016] 这是我自己的发明", "background": "一切伟大的世界历史事件与人物，可以说都会出现两次\n\n第一次是作为悲剧出现\n\n第二次，则是作为笑剧出现\n\n——《路易.波拿巴的雾月十八日》\n\n感动、\n\n痛苦、\n\n以及快乐、\n\n都只是遥不可及的宝石\n\n即便如此，人们啊，\n\n获得幸福吧！\n\n![](https://cdn.luogu.com.cn/upload/pic/21098.png)\n\n世界将在7月20日终结\n\n世界回归天空的日子\n\n万物被天空侵染的日子\n\n回归天空的日子\n\n世界必须回归\n\n世界的极限\n\n世界的尽头\n\n世界的终结\n\n![](https://cdn.luogu.com.cn/upload/pic/21099.png)\n\n你看…那就是极限…最尽头的天空\n\n如今，已无应该之事了如今，已无忘却之物了\n\n不需要的话语\n\n![](https://cdn.luogu.com.cn/upload/pic/21100.png)\n\n告别了永不相交的平行，我被吸进了…\n\n垂直下落的世界\n\n![](https://cdn.luogu.com.cn/upload/pic/21101.png)\n\n虽哭亦喜\n\n虽悲亦喜\n\n各种感情混在一起...\n\n比起其他所有，想必还是高兴占多吧\n\n她高兴地抱着我\n\n紧紧地抱着\n\n再也不会松开了...\n\n想永远这样...\n\n她的思绪，以比语言更快的速度，传达给了我\n\n有些东西，比语言更快\n\n她的思绪，以比语言更快的速度，传达给了我\n\n有些东西，比语音更准确\n\n世界上无论多么短暂的瞬间，都有意义\n\n有意义\n\n块临近终结了\n\n最后的瞬间\n\n啊啊...\n\n远方的警笛声\n\n黑色的天空\n\n月正笑\n\n地正润潮\n\n星正舞\n\n风正凉\n\n在我怀中，温暖的，\n\n橘希实香\n\n![](https://cdn.luogu.com.cn/upload/pic/21103.png)\n\n她在我的怀中...静静地合上了双眼\n\n然后我也...\n\n静静地合上了双眼", "description": "您正在打 galgame，然后突然家长进来了，于是您假装在写数据结构题：\n\n给一个树，$n$ 个点，有点权，初始根是 1。\n\n$m$ 个操作，种类如下：\n\n`1 x` 将树根换为 $x$。\n\n`2 x y` 给出两个点 $x,y$，从 $x$ 的子树中选每一个点，$y$ 的子树中选每一个点，求点权相等的情况数。\n", "inputFormat": "第一行两个数表示 $n,m$。\n\n第二行 $n$ 个数，表示每个点的点权 $a_i$。\n\n之后 $n-1$ 行 , 每行两个数 $x,y$ , 表示一条边。\n\n之后 $m$ 行，每行表示一个操作。", "outputFormat": "对于每个询问，输出一个数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477\n\n【数据范围】   \n对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$1 \\le m \\le 5\\times 10^5$ , $1 \\le a_i \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[Ynoi Easy Round 2016] This Is My Own Invention", "background": "All great world-historical facts and characters, so to speak, occur twice.\n\nThe first time as tragedy.\n\nThe second time as farce.\n\n— *The Eighteenth Brumaire of Louis Bonaparte*\n\nMoved,\n\nIn pain,\n\nAnd in joy,\n\nAre all just faraway gems.\n\nEven so, people,\n\nObtain happiness!\n\n![](https://cdn.luogu.com.cn/upload/pic/21098.png)\n\nThe world will end on July 20.\n\nThe day the world returns to the sky.\n\nThe day everything is stained by the sky.\n\nThe day it returns to the sky.\n\nThe world must return.\n\nThe world’s limit.\n\nThe end of the world.\n\nThe end of the world.\n\n![](https://cdn.luogu.com.cn/upload/pic/21099.png)\n\nLook... that is the limit... the sky at the very end.\n\nNow, there is nothing that should be done. Now, there is nothing left to forget.\n\nWords are not needed.\n\n![](https://cdn.luogu.com.cn/upload/pic/21100.png)\n\nSaying goodbye to the parallel that never intersected, I was sucked into...\n\nA world of vertical falling.\n\n![](https://cdn.luogu.com.cn/upload/pic/21101.png)\n\nCrying yet joyful.\n\nSad yet joyful.\n\nAll kinds of feelings mixed together...\n\nCompared to everything else, happiness probably takes up more.\n\nShe hugged me happily.\n\nHeld me tightly.\n\nNever letting go again...\n\nI want it to be like this forever...\n\nHer thoughts reached me faster than words.\n\nSome things are faster than words.\n\nHer thoughts reached me faster than words.\n\nSome things are more accurate than speech.\n\nNo matter how brief a moment is in this world, it has meaning.\n\nMeaning.\n\nThe block is nearing its end.\n\nThe final moment.\n\nAh...\n\nA distant siren.\n\nA black sky.\n\nThe moon is smiling.\n\nThe ground is damp.\n\nThe stars are dancing.\n\nThe wind is cool.\n\nWarm in my arms,\n\nKishima Kikkou.\n\n![](https://cdn.luogu.com.cn/upload/pic/21103.png)\n\nIn my arms... she quietly closed her eyes.\n\nAnd then I also...\n\nQuietly closed my eyes.", "description": "You are playing a galgame, and then your parents suddenly come in, so you pretend you are solving a data structure problem.\n\nGiven a tree with $n$ nodes. Each node has a weight. The initial root is $1$.\n\nThere are $m$ operations of the following types:\n\n`1 x` Change the root of the tree to $x$.\n\n`2 x y` Given two nodes $x, y$, choose every node from the subtree of $x$ and every node from the subtree of $y$, and count the number of pairs whose node weights are equal.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe second line contains $n$ integers, where the $i$-th integer is the node weight $a_i$.\n\nThe next $n-1$ lines each contain two integers $x, y$, indicating an edge.\n\nThe next $m$ lines each describe one operation.", "outputFormat": "For each query, output one integer representing the answer.", "hint": "Idea: nzhtl1477, Solution: nzhtl1477, Code: nzhtl1477, Data: nzhtl1477\n\nConstraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 10^5$, $1 \\le m \\le 5 \\times 10^5$, $1 \\le a_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Ynoi Easy Round 2016] 这是我自己的发明", "background": "一切伟大的世界历史事件与人物，可以说都会出现两次\n\n第一次是作为悲剧出现\n\n第二次，则是作为笑剧出现\n\n——《路易.波拿巴的雾月十八日》\n\n感动、\n\n痛苦、\n\n以及快乐、\n\n都只是遥不可及的宝石\n\n即便如此，人们啊，\n\n获得幸福吧！\n\n![](https://cdn.luogu.com.cn/upload/pic/21098.png)\n\n世界将在7月20日终结\n\n世界回归天空的日子\n\n万物被天空侵染的日子\n\n回归天空的日子\n\n世界必须回归\n\n世界的极限\n\n世界的尽头\n\n世界的终结\n\n![](https://cdn.luogu.com.cn/upload/pic/21099.png)\n\n你看…那就是极限…最尽头的天空\n\n如今，已无应该之事了如今，已无忘却之物了\n\n不需要的话语\n\n![](https://cdn.luogu.com.cn/upload/pic/21100.png)\n\n告别了永不相交的平行，我被吸进了…\n\n垂直下落的世界\n\n![](https://cdn.luogu.com.cn/upload/pic/21101.png)\n\n虽哭亦喜\n\n虽悲亦喜\n\n各种感情混在一起...\n\n比起其他所有，想必还是高兴占多吧\n\n她高兴地抱着我\n\n紧紧地抱着\n\n再也不会松开了...\n\n想永远这样...\n\n她的思绪，以比语言更快的速度，传达给了我\n\n有些东西，比语言更快\n\n她的思绪，以比语言更快的速度，传达给了我\n\n有些东西，比语音更准确\n\n世界上无论多么短暂的瞬间，都有意义\n\n有意义\n\n块临近终结了\n\n最后的瞬间\n\n啊啊...\n\n远方的警笛声\n\n黑色的天空\n\n月正笑\n\n地正润潮\n\n星正舞\n\n风正凉\n\n在我怀中，温暖的，\n\n橘希实香\n\n![](https://cdn.luogu.com.cn/upload/pic/21103.png)\n\n她在我的怀中...静静地合上了双眼\n\n然后我也...\n\n静静地合上了双眼", "description": "您正在打 galgame，然后突然家长进来了，于是您假装在写数据结构题：\n\n给一个树，$n$ 个点，有点权，初始根是 1。\n\n$m$ 个操作，种类如下：\n\n`1 x` 将树根换为 $x$。\n\n`2 x y` 给出两个点 $x,y$，从 $x$ 的子树中选每一个点，$y$ 的子树中选每一个点，求点权相等的情况数。\n", "inputFormat": "第一行两个数表示 $n,m$。\n\n第二行 $n$ 个数，表示每个点的点权 $a_i$。\n\n之后 $n-1$ 行 , 每行两个数 $x,y$ , 表示一条边。\n\n之后 $m$ 行，每行表示一个操作。", "outputFormat": "对于每个询问，输出一个数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477\n\n【数据范围】   \n对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$1 \\le m \\le 5\\times 10^5$ , $1 \\le a_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4690", "type": "P", "difficulty": 6, "samples": [["5 5\n1 2 3 4 5\n2 1 5\n1 2 3 4\n2 1 5\n2 3 3\n2 2 4", "5\n3\n1\n1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2016", "树状数组", "颜色段均摊（珂朵莉树 ODT）", "cdq 分治", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2016] 镜中的昆虫", "background": "镜子的世界里会有美丽的东西吗？\n\n镜子的世界里会有快乐的事情吗？\n\n镜子世界的我，像我一样摆着一副无聊的表情\n\n——出自《镜之国的爱丽丝》\n\n![](https://cdn.luogu.com.cn/upload/pic/21104.png)\n\n两个少女的战斗故事\n\n文学代表强烈的意志，化学是对抗物理世界的力量\n\n她们只有这两样对抗现实的武器\n\n![](https://cdn.luogu.com.cn/upload/pic/21105.png)\n\n啊，勒布雷！\n\n我今天要登上乳白色的月球了！\n\n不需要发明是机器，真是如此，我要一跃而出！\n\n没错朋友！那个月亮的世界！\n\n才是为我们创造的世界！\n\n不止一个我所爱的人，大概都被放逐到那里...然后在等着我...\n\n苏格拉底！伽利略！\n\n物质的基本要素的灵魂就是...\n\n这是...不，这有问题...哥白尼说过！\n\n没错朋友们，究竟为何，会中了魔障？\n\n究竟为何，会中了魔障，他到底去双桅战船上干什么呢？\n\n作为哲学家！\n\n物理学家！\n\n诗人！\n\n剑客！\n\n音乐家！\n\n空中旅行家！\n\n针尖对麦芒的辩士！\n\n他无所不能\n\n作为至高...但是...\n\n却又一事无成...\n\n...没错，你们这些家伙，想夺走我的一切！\n\n...来，夺走吧，夺走就是了...\n\n但是...无论你们再怎么叫嚷，在去往新世界的路上，我还是会带走一个！\n\n让我看看你坚强的心吧！\n\n没错，你帽子上的羽饰！\n\n象征你内心的勇气的纹章...毛子上的羽饰！\n\n对不起，我该走了，我不能让人久等！\n\n你们看...月亮来迎接我了！\n\nMon panache！\n\n![](https://cdn.luogu.com.cn/upload/pic/21106.png)\n\n我往空中踏出一步\n\n两人拼命地想要拉住我\n\n但是我往空中踏出一步\n\n没错\n\n我要为了崭新的世界，从天而降\n\n为了获得新的力量\n\n为了新的真实\n\n我踏出了这一步\n\n从手上，感到了两人的颤抖\n\n没关系...\n\n我在你们身边！\n\nSora！\n\n![](https://cdn.luogu.com.cn/upload/pic/21109.png)\n\n我完全投身于空中\n\n我的身体瞬间从空中向地面落去\n\n我紧紧地握住两人手腕，拉着两人\n\n看见两人的表情...\n\n她们边哭边笑...\n\n似乎很害怕...\n\n却又似很高兴的表情...\n\n啊...\n\n什么嘛，飞翔好舒服啊\n\n宛如变成了天使一般...\n\n好快的速度...\n\n好快的风...\n\n但是却听不见声音...\n\n世界在静静地回转\n\n已经，马上就要到地面了...\n\n空气力学的先驱者...\n\n我知道一切都在回转的天空，\n\n还有包容着我的大地\n\n还差一点，就抵达世界了...\n\n还差一点，就抵达地面了...\n\n接近着的影子\n\n地面映出我的身影\n", "description": "您正在欣赏 galgame 的 HS，然后游戏崩溃了，于是您只能做数据结构题了：\n\n维护一个长为 $n$ 的序列 $a_i$，有 $m$ 次操作。\n\n1. 将区间 $[l,r]$ 的值修改为 $x$。\n\n2. 询问区间 $[l,r]$ 出现了多少种不同的数，也就是说同一个数出现多次只算一个。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数表示 $a_i$。\n\n后面 $m$ 行每行为 $1\\ l\\ r\\ x$ 或者 $2\\ l\\ r$ ，分别表示修改和询问。", "outputFormat": "对于每个询问，输出一个数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477\n\n$1\\leq n , m \\leq 10^5$，$1\\leq a_i\\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[Ynoi Easy Round 2016] Insects in the Mirror", "background": "Are there beautiful things in the world inside a mirror?\n\nAre there happy things in the world inside a mirror?\n\nMe in the mirror world, wearing the same bored expression as I do.\n\n— From *Alice in the Mirror Country*\n\n![](https://cdn.luogu.com.cn/upload/pic/21104.png)\n\nA battle story of two girls.\n\nLiterature represents a strong will, and chemistry is the power to resist the physical world.\n\nThese are the only two weapons they have to fight reality.\n\n![](https://cdn.luogu.com.cn/upload/pic/21105.png)\n\nAh, Leblanc!\n\nToday I am going to climb onto the milky-white moon!\n\nThere is no need to invent a machine. Indeed, I will leap out in one jump!\n\nThat’s right, my friend! The world of that moon!\n\nThat is the world created for us!\n\nMore than one person I love was probably exiled there... and is waiting for me...\n\nSocrates! Galileo!\n\nThe soul of the basic elements of matter is...\n\nThis is... no, something is wrong... Copernicus said it before!\n\nThat’s right, my friends. Why on earth have I been bewitched?\n\nWhy on earth have I been bewitched? What on earth is he doing on a two-masted warship?\n\nAs a philosopher!\n\nA physicist!\n\nA poet!\n\nA swordsman!\n\nA musician!\n\nAn aerial traveler!\n\nA debater who argues needle to needle!\n\nHe can do anything.\n\nAs the supreme... but...\n\nyet he achieves nothing...\n\n...Yes, you guys want to take everything from me!\n\n...Come on, take it, just take it...\n\nBut... no matter how you shout, on the road to the new world, I will still take one thing with me!\n\nLet me see your strong heart!\n\nThat’s right, the plume on your hat!\n\nThe emblem of courage in your heart... the plume on your hat!\n\nSorry, I have to go. I can’t keep people waiting!\n\nLook... the moon has come to greet me!\n\nMon panache！\n\n![](https://cdn.luogu.com.cn/upload/pic/21106.png)\n\nI step into the air.\n\nThe two of them desperately try to pull me back.\n\nBut I step into the air.\n\nThat’s right.\n\nFor a brand-new world, I will fall from the sky.\n\nTo gain new power.\n\nFor a new truth.\n\nI take this step.\n\nFrom my hands, I feel the trembling of the two of them.\n\nIt’s okay...\n\nI am by your side!\n\nSora！\n\n![](https://cdn.luogu.com.cn/upload/pic/21109.png)\n\nI throw myself completely into the air.\n\nMy body instantly falls from the air toward the ground.\n\nI tightly grip their wrists and pull them along.\n\nSeeing their expressions...\n\nThey cry and laugh at the same time...\n\nThey seem very scared...\n\nyet also seem very happy...\n\nAh...\n\nWhat is this? Flying feels so comfortable.\n\nAs if I have become an angel...\n\nSuch fast speed...\n\nSuch fast wind...\n\nBut I can’t hear any sound...\n\nThe world is turning quietly.\n\nSoon, we are about to reach the ground...\n\nThe pioneer of aerodynamics...\n\nI know that everything is turning in the sky,\n\nand the earth that embraces me.\n\nJust a little more, and I will reach the world...\n\nJust a little more, and I will reach the ground...\n\nThe approaching shadow.\n\nThe ground reflects my silhouette.", "description": "You are enjoying HS in a galgame, but the game crashes, so you can only do a data structure problem:\n\nMaintain a sequence $a_i$ of length $n$, with $m$ operations.\n\n1. Modify the values in interval $[l,r]$ to $x$.\n\n2. Query how many different numbers appear in interval $[l,r]$. That is, if the same number appears multiple times, it is counted only once.", "inputFormat": "The first line contains two integers $n,m$.\n\nThe second line contains $n$ integers representing $a_i$.\n\nThe next $m$ lines are either $1\\ l\\ r\\ x$ or $2\\ l\\ r$, representing modification and query respectively.", "outputFormat": "For each query, output one number as the answer.", "hint": "Idea: nzhtl1477, Solution: nzhtl1477, Code: nzhtl1477, Data: nzhtl1477\n\nConstraints: $1\\leq n , m \\leq 10^5$，$1\\leq a_i\\leq 10^9$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Ynoi Easy Round 2016] 镜中的昆虫", "background": "镜子的世界里会有美丽的东西吗？\n\n镜子的世界里会有快乐的事情吗？\n\n镜子世界的我，像我一样摆着一副无聊的表情\n\n——出自《镜之国的爱丽丝》\n\n![](https://cdn.luogu.com.cn/upload/pic/21104.png)\n\n两个少女的战斗故事\n\n文学代表强烈的意志，化学是对抗物理世界的力量\n\n她们只有这两样对抗现实的武器\n\n![](https://cdn.luogu.com.cn/upload/pic/21105.png)\n\n啊，勒布雷！\n\n我今天要登上乳白色的月球了！\n\n不需要发明是机器，真是如此，我要一跃而出！\n\n没错朋友！那个月亮的世界！\n\n才是为我们创造的世界！\n\n不止一个我所爱的人，大概都被放逐到那里...然后在等着我...\n\n苏格拉底！伽利略！\n\n物质的基本要素的灵魂就是...\n\n这是...不，这有问题...哥白尼说过！\n\n没错朋友们，究竟为何，会中了魔障？\n\n究竟为何，会中了魔障，他到底去双桅战船上干什么呢？\n\n作为哲学家！\n\n物理学家！\n\n诗人！\n\n剑客！\n\n音乐家！\n\n空中旅行家！\n\n针尖对麦芒的辩士！\n\n他无所不能\n\n作为至高...但是...\n\n却又一事无成...\n\n...没错，你们这些家伙，想夺走我的一切！\n\n...来，夺走吧，夺走就是了...\n\n但是...无论你们再怎么叫嚷，在去往新世界的路上，我还是会带走一个！\n\n让我看看你坚强的心吧！\n\n没错，你帽子上的羽饰！\n\n象征你内心的勇气的纹章...毛子上的羽饰！\n\n对不起，我该走了，我不能让人久等！\n\n你们看...月亮来迎接我了！\n\nMon panache！\n\n![](https://cdn.luogu.com.cn/upload/pic/21106.png)\n\n我往空中踏出一步\n\n两人拼命地想要拉住我\n\n但是我往空中踏出一步\n\n没错\n\n我要为了崭新的世界，从天而降\n\n为了获得新的力量\n\n为了新的真实\n\n我踏出了这一步\n\n从手上，感到了两人的颤抖\n\n没关系...\n\n我在你们身边！\n\nSora！\n\n![](https://cdn.luogu.com.cn/upload/pic/21109.png)\n\n我完全投身于空中\n\n我的身体瞬间从空中向地面落去\n\n我紧紧地握住两人手腕，拉着两人\n\n看见两人的表情...\n\n她们边哭边笑...\n\n似乎很害怕...\n\n却又似很高兴的表情...\n\n啊...\n\n什么嘛，飞翔好舒服啊\n\n宛如变成了天使一般...\n\n好快的速度...\n\n好快的风...\n\n但是却听不见声音...\n\n世界在静静地回转\n\n已经，马上就要到地面了...\n\n空气力学的先驱者...\n\n我知道一切都在回转的天空，\n\n还有包容着我的大地\n\n还差一点，就抵达世界了...\n\n还差一点，就抵达地面了...\n\n接近着的影子\n\n地面映出我的身影\n", "description": "您正在欣赏 galgame 的 HS，然后游戏崩溃了，于是您只能做数据结构题了：\n\n维护一个长为 $n$ 的序列 $a_i$，有 $m$ 次操作。\n\n1. 将区间 $[l,r]$ 的值修改为 $x$。\n\n2. 询问区间 $[l,r]$ 出现了多少种不同的数，也就是说同一个数出现多次只算一个。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数表示 $a_i$。\n\n后面 $m$ 行每行为 $1\\ l\\ r\\ x$ 或者 $2\\ l\\ r$ ，分别表示修改和询问。", "outputFormat": "对于每个询问，输出一个数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477\n\n$1\\leq n , m \\leq 10^5$，$1\\leq a_i\\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4692", "type": "P", "difficulty": 6, "samples": [["2 5\n6 6\n1 3 1 1 3 2 \n2 3 3 2 1 1 \n1 1 1\n1 1 2\n1 1 2\n1 1 1\n1 1 1", "1158\n1158\n1168\n1168\n1158\n1158"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "O2优化", "容斥原理", "Ynoi"], "title": "[Ynoi Easy Round 2016] 谁的梦", "background": "6.373 \n\n世界是独立于我的意志的。 \n\n6.374 \n\n就算我们所期望的全部的事情都发生了 \n\n这果然也只能说是命运的恩惠吧。 \n\n要问为什么，那是因为意志和世界之间 \n\n能够保证这件事的逻辑性的关联并不存在 \n\nLudwig Josef Johann Wittgenstein [逻辑哲学论] \n\n自从双胞胎的哥哥过世起，已经过了多久了呢… \n\n从那时起，我一直保存着那个布偶。 \n\n在那以后的我只是个影子…而这个布偶才是我… \n\n这样也并没有什么不好。 \n\n我觉得只要现在的我消失掉就行了… \n\n那两个人却救了这样的我。 \n\n一个是由歧姐… \n\n她又来到了我的身边… \n\n带着皆守哥…回到了我们的身边… \n\n水上由岐姐姐…温柔的姐姐 \n\n曾经非常喜欢皆守哥的人……\n\n![](https://cdn.luogu.com.cn/upload/pic/21195.png)\n\n回去的路上…\n\n平时不会经过的坡道…\n\n在登上那个坡道的途中…\n\n我看到了夜晚的太阳。\n\n明明就在附近，却一直不知道的巨大的向日葵。\n\n夜露使它的绒毛泛出了白光。\n\n碧蓝的月光和黄色的向日葵…\n\n就好像太阳和月亮的立场反过来一样…\n\n原本是那么耀眼的的太阳在地上，只能在其背后下发光的月亮在天上…\n\n黄色的向日葵被染成了碧蓝色。\n\n那副样子虽然很美丽…\n\n努力绽放的向日葵，看起来反而是柔弱的存在。\n\n在夜里向天空伸展的向日葵…\n\n我在车内一直追寻着它的身影…\n\n被夜晚的月光映照着的太阳。\n\n被染成碧蓝色的太阳…\n\n它的身影…我一直追寻着……\n\n![](https://cdn.luogu.com.cn/upload/pic/21196.png)\n\n被月光照亮的天台上…\n\n一个人影…\n\n明明只是一个人影…却好像…在和什么东西对峙着一样…\n\n皆守哥…\n\n月下的立像，一个人影。\n\n胸口在风中闪烁。\n\n放在胸前的手里的是…那时的小刀。\n\n和七年前同样的姿势。\n\n唯一不同的是，那里的人影只有一个。\n\n那把小刀，好像是被他自己刺入体内。\n\n![](https://cdn.luogu.com.cn/upload/pic/21197.png)\n\n是诅咒…\n\n这是理所当然的事…\n\n那并不是什么精神病…\n\n那是诅咒…\n\n下在幸存的我们身上的…诅咒…\n\n说不定，不仅仅是卓司哥…连由岐姐也在诅咒我们…\n\n所以变成这种结果…\n\n哥哥刺向了自己的胸口…\n\n破坏了我的半身…\n\n然后…还要把很多人送回到天空…\n\n回归天空的日子。\n\n交还灵魂的日子。\n\n那一天，卓司哥对我做的事情。\n\n杀了由岐姐的…那个行为…\n\n他想要再一次实行…\n\n这次…和很多人一起…\n\n![](https://cdn.luogu.com.cn/upload/pic/21198.png)\n\n不是…\n\n那是…我啊…\n\n是那个…坡道的事情啊…\n\n两个人一起看到向日葵的…那个坡道…\n\n…我说要爬上那个坡道…要去寻找爸爸的灵魂…\n\n我想，如果到了那个坡道的前方，就能取回爸爸的灵魂…爸爸就会复生的…\n\n如果越过向日葵之路…向着向日葵所朝向的天空延伸的…那个大大的坡道的话…\n大概，就会有爸爸的灵魂…\n\n爸爸的故乡的…大大的坡道…\n\n![](https://cdn.luogu.com.cn/upload/pic/21199.png)\n\n哥哥的身体浮在空中…\n\n我无言地跳了出去。\n\n啊啊…是这样啊…\n\n由岐姐也是这种心情啊…\n\n并没有什么道理可言…\n\n只是因为喜欢的人向着天空跳下去了…\n\n我想要抓住那个身体…\n\n我——", "description": "您正在打 galgame，突然断电了，于是您跑去物管处问，结果发现是由于一个光头踢了变压器一脚导致的，可能还要修很久，于是您决定想一个之前见过的数据结构题：\n\n定义一个序列的权值为不同数字的个数，例如 $[1,2,3,3]$  权值为 $3$。\n\n现在有 $n$ 个序列，我们在每个序列里面选一个连续非空子串，拼接起来，求所有选法得到的序列的权值之和。\n\n如果一个序列能通过多种方法被选择出来，那么计算多次。\n\n本题带修改操作，格式请参考输入格式。\n\n由于结果可能过大，请输出答案 $\\bmod 19260817$ 的结果。", "inputFormat": "第一行两个整数 $n,m$，表示有 $n$ 个序列，$m$ 次修改。\n\n第二行 $n$ 个整数，第 $i$ 个数是 $len_i$，表示第 $i$ 个序列的长度。\n\n之后 $n$ 行，每行 $len_i$ 个整数，表示第 $i$ 个序列。\n\n之后 $m$ 行，每行三个整数 $x,y,z$ 表示将第 $x$ 个序列的第 $y$ 个元素改为 $z$。", "outputFormat": "输出 $m + 1$ 行，每行一个整数，依次表示初始局面以及每次修改后的答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477( partially uploaded )\n\n$1 \\leq n,m,len_i \\leq 10^5$，序列中的元素均为 $32$ 位整型数，$\\sum len_i \\leq 10^5$。\n\n共 $50$ 组数据。", "locale": "zh-CN", "translations": {"en": {"title": "[Ynoi Easy Round 2016] Whose Dream", "background": "6.373\n\nThe world is independent of my will.\n\n6.374\n\nEven if everything we hope for happens,\n\nin the end it can only be called a gift of fate.\n\nIf you ask why, it is because between will and the world,\n\nthe logical connection that can guarantee this does not exist.\n\nLudwig Josef Johann Wittgenstein [Tractatus Logico-Philosophicus]\n\nHow long has it been since my twin brother passed away…\n\nSince then, I have kept that stuffed doll.\n\nAfter that, I was only a shadow… and this stuffed doll was the real me…\n\nThat is not so bad either.\n\nI think it is enough if the current me disappears…\n\nBut those two people saved someone like me.\n\nOne of them was Yuki-nee…\n\nShe came back to my side again…\n\nBringing Minamori-nii… back to our side…\n\nMizukami Yuki-nee, a gentle older sister.\n\nSomeone who once liked Minamori-nii very much……\n\n![](https://cdn.luogu.com.cn/upload/pic/21195.png)\n\nOn the way back…\n\nA slope we usually would not pass…\n\nWhile climbing that slope…\n\nI saw the sun at night.\n\nA huge sunflower that was nearby, yet I never noticed it.\n\nThe night dew made its fuzz glow white.\n\nThe deep blue moonlight and the yellow sunflower…\n\nIt was as if the positions of the sun and the moon were reversed…\n\nThe sun, originally so dazzling, was on the ground, and the moon, which could only shine behind it, was in the sky…\n\nThe yellow sunflower was dyed deep blue.\n\nThat sight was very beautiful…\n\nBut the sunflower, blooming with all its might, instead looked like something fragile.\n\nThe sunflower stretching toward the sky at night…\n\nInside the car, I kept chasing its silhouette…\n\nThe sun illuminated by the moonlight at night.\n\nThe sun dyed deep blue…\n\nIts figure… I kept chasing it……\n\n![](https://cdn.luogu.com.cn/upload/pic/21196.png)\n\nOn the rooftop lit by moonlight…\n\nA shadow…\n\nClearly just a shadow… yet it seemed… to be confronting something…\n\nMinamori-nii…\n\nA statue under the moon, a shadow.\n\nHis chest flickered in the wind.\n\nIn the hand placed before his chest was… that small knife from back then.\n\nThe same posture as seven years ago.\n\nThe only difference was that there was only one shadow there.\n\nThat knife seemed to have been stabbed into his body by himself.\n\n![](https://cdn.luogu.com.cn/upload/pic/21197.png)\n\nIt is a curse…\n\nThis is only natural…\n\nIt is not some mental illness…\n\nIt is a curse…\n\nA curse placed on us survivors…\n\nPerhaps, not only Takushi-nii… but even Yuki-nee is cursing us…\n\nSo it ended up like this…\n\nMy brother stabbed his own chest…\n\nDestroyed my other half…\n\nAnd then… he will send many people back to the sky…\n\nThe day of returning to the sky.\n\nThe day of giving back the soul.\n\nWhat Takushi-nii did to me that day.\n\nThat act… of killing Yuki-nee…\n\nHe wants to do it once again…\n\nThis time… together with many people…\n\n![](https://cdn.luogu.com.cn/upload/pic/21198.png)\n\nNo…\n\nThat is… me…\n\nIt is that… slope…\n\nThat slope where two people saw the sunflower together…\n\n…I said I wanted to climb that slope… to look for Dad’s soul…\n\nI thought that if I reached beyond that slope, I could take back Dad’s soul… and Dad would come back to life…\n\nIf I crossed the sunflower road… and went toward that big slope that extends into the sky the sunflower faces…\nThen, probably, Dad’s soul would be there…\n\nThe big slope… of Dad’s hometown…\n\n![](https://cdn.luogu.com.cn/upload/pic/21199.png)\n\nMy brother’s body floated in the air…\n\nI jumped out without a word.\n\nAh… so that is how it is…\n\nYuki-nee felt like this too…\n\nThere is no reason to it…\n\nJust because the person I like jumped toward the sky…\n\nI wanted to grab that body…\n\nI—", "description": "You are playing a galgame when the power suddenly goes out. You run to the property management office to ask, and find out it was because a bald guy kicked the transformer, and it may take a long time to fix. So you decide to think about a data structure problem you saw before:\n\nDefine the weight of a sequence as the number of distinct numbers in it. For example, $[1,2,3,3]$ has weight $3$.\n\nNow there are $n$ sequences. For each sequence, we choose a non-empty contiguous substring, and concatenate them. Compute the sum of the weights of the resulting sequence over all choices.\n\nIf a sequence can be obtained in multiple ways, count it multiple times.\n\nThis problem includes modification operations; see the input format.\n\nSince the result may be too large, output the answer $\\bmod 19260817$.", "inputFormat": "The first line contains two integers $n,m$, meaning there are $n$ sequences and $m$ modifications.\n\nThe second line contains $n$ integers; the $i$-th number is $len_i$, meaning the length of the $i$-th sequence.\n\nThen follow $n$ lines; the $i$-th line contains $len_i$ integers, representing the $i$-th sequence.\n\nThen follow $m$ lines; each line contains three integers $x,y,z$, meaning change the $y$-th element of the $x$-th sequence to $z$.", "outputFormat": "Output $m + 1$ lines, each containing one integer, representing the answer for the initial state and after each modification, in order.", "hint": "Idea: nzhtl1477, Solution: nzhtl1477, Code: nzhtl1477, Data: nzhtl1477 ( partially uploaded )\n\n$1 \\leq n,m,len_i \\leq 10^5$. The elements in the sequences are all $32$-bit integers, and $\\sum len_i \\leq 10^5$.\n\nThere are $50$ test cases.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Ynoi Easy Round 2016] 谁的梦", "background": "6.373 \n\n世界是独立于我的意志的。 \n\n6.374 \n\n就算我们所期望的全部的事情都发生了 \n\n这果然也只能说是命运的恩惠吧。 \n\n要问为什么，那是因为意志和世界之间 \n\n能够保证这件事的逻辑性的关联并不存在 \n\nLudwig Josef Johann Wittgenstein [逻辑哲学论] \n\n自从双胞胎的哥哥过世起，已经过了多久了呢… \n\n从那时起，我一直保存着那个布偶。 \n\n在那以后的我只是个影子…而这个布偶才是我… \n\n这样也并没有什么不好。 \n\n我觉得只要现在的我消失掉就行了… \n\n那两个人却救了这样的我。 \n\n一个是由歧姐… \n\n她又来到了我的身边… \n\n带着皆守哥…回到了我们的身边… \n\n水上由岐姐姐…温柔的姐姐 \n\n曾经非常喜欢皆守哥的人……\n\n![](https://cdn.luogu.com.cn/upload/pic/21195.png)\n\n回去的路上…\n\n平时不会经过的坡道…\n\n在登上那个坡道的途中…\n\n我看到了夜晚的太阳。\n\n明明就在附近，却一直不知道的巨大的向日葵。\n\n夜露使它的绒毛泛出了白光。\n\n碧蓝的月光和黄色的向日葵…\n\n就好像太阳和月亮的立场反过来一样…\n\n原本是那么耀眼的的太阳在地上，只能在其背后下发光的月亮在天上…\n\n黄色的向日葵被染成了碧蓝色。\n\n那副样子虽然很美丽…\n\n努力绽放的向日葵，看起来反而是柔弱的存在。\n\n在夜里向天空伸展的向日葵…\n\n我在车内一直追寻着它的身影…\n\n被夜晚的月光映照着的太阳。\n\n被染成碧蓝色的太阳…\n\n它的身影…我一直追寻着……\n\n![](https://cdn.luogu.com.cn/upload/pic/21196.png)\n\n被月光照亮的天台上…\n\n一个人影…\n\n明明只是一个人影…却好像…在和什么东西对峙着一样…\n\n皆守哥…\n\n月下的立像，一个人影。\n\n胸口在风中闪烁。\n\n放在胸前的手里的是…那时的小刀。\n\n和七年前同样的姿势。\n\n唯一不同的是，那里的人影只有一个。\n\n那把小刀，好像是被他自己刺入体内。\n\n![](https://cdn.luogu.com.cn/upload/pic/21197.png)\n\n是诅咒…\n\n这是理所当然的事…\n\n那并不是什么精神病…\n\n那是诅咒…\n\n下在幸存的我们身上的…诅咒…\n\n说不定，不仅仅是卓司哥…连由岐姐也在诅咒我们…\n\n所以变成这种结果…\n\n哥哥刺向了自己的胸口…\n\n破坏了我的半身…\n\n然后…还要把很多人送回到天空…\n\n回归天空的日子。\n\n交还灵魂的日子。\n\n那一天，卓司哥对我做的事情。\n\n杀了由岐姐的…那个行为…\n\n他想要再一次实行…\n\n这次…和很多人一起…\n\n![](https://cdn.luogu.com.cn/upload/pic/21198.png)\n\n不是…\n\n那是…我啊…\n\n是那个…坡道的事情啊…\n\n两个人一起看到向日葵的…那个坡道…\n\n…我说要爬上那个坡道…要去寻找爸爸的灵魂…\n\n我想，如果到了那个坡道的前方，就能取回爸爸的灵魂…爸爸就会复生的…\n\n如果越过向日葵之路…向着向日葵所朝向的天空延伸的…那个大大的坡道的话…\n大概，就会有爸爸的灵魂…\n\n爸爸的故乡的…大大的坡道…\n\n![](https://cdn.luogu.com.cn/upload/pic/21199.png)\n\n哥哥的身体浮在空中…\n\n我无言地跳了出去。\n\n啊啊…是这样啊…\n\n由岐姐也是这种心情啊…\n\n并没有什么道理可言…\n\n只是因为喜欢的人向着天空跳下去了…\n\n我想要抓住那个身体…\n\n我——", "description": "您正在打 galgame，突然断电了，于是您跑去物管处问，结果发现是由于一个光头踢了变压器一脚导致的，可能还要修很久，于是您决定想一个之前见过的数据结构题：\n\n定义一个序列的权值为不同数字的个数，例如 $[1,2,3,3]$  权值为 $3$。\n\n现在有 $n$ 个序列，我们在每个序列里面选一个连续非空子串，拼接起来，求所有选法得到的序列的权值之和。\n\n如果一个序列能通过多种方法被选择出来，那么计算多次。\n\n本题带修改操作，格式请参考输入格式。\n\n由于结果可能过大，请输出答案 $\\bmod 19260817$ 的结果。", "inputFormat": "第一行两个整数 $n,m$，表示有 $n$ 个序列，$m$ 次修改。\n\n第二行 $n$ 个整数，第 $i$ 个数是 $len_i$，表示第 $i$ 个序列的长度。\n\n之后 $n$ 行，每行 $len_i$ 个整数，表示第 $i$ 个序列。\n\n之后 $m$ 行，每行三个整数 $x,y,z$ 表示将第 $x$ 个序列的第 $y$ 个元素改为 $z$。", "outputFormat": "输出 $m + 1$ 行，每行一个整数，依次表示初始局面以及每次修改后的答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477( partially uploaded )\n\n$1 \\leq n,m,len_i \\leq 10^5$，序列中的元素均为 $32$ 位整型数，$\\sum len_i \\leq 10^5$。\n\n共 $50$ 组数据。", "locale": "zh-CN"}}}
{"pid": "P4693", "type": "P", "difficulty": 7, "samples": [["20 30\nF(1,2)\nF(1,3)\nF(1,7)\nF(1,9)\nF(9,5)\nF(3,8)\nF(3,20)\nF(3,6)\nF(8,15)\nF(8,19)\nF(20,14)\nF(20,12)\nF(6,13)\nF(6,18)\nF(13,4)\nF(12,11)\nF(12,17)\nF(17,10)\nF(17,16)\nE(3,9)\nE(8,6)\nA(12,0)\nD(4,6)\nE(2,7)\nB(3,12)\nD(4,6)\nC(8,0)\nD(13,5)\nD(1,7)\nE(12,14)", "36\n42\n56\n89\n95\n105\n90\n61"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2016] 炸脖龙 II", "background": "瞬间…\n\n真要说的话，比瞬间还要短暂。\n\n羽咲往悬崖的方向飞去。\n\n瘦小的羽咲，比想象中更轻易地飞侠了悬崖。\n\n我急忙跑向悬崖边。\n\n然而，飞奔而出之后，方向并不是那么容易改变。\n\n我失去了平衡，就这么摔倒在地。\n\n只能一直用目光追寻着羽咲的身影。\n\n飞出悬崖的羽咲。\n\n身体浮在半空中。\n\n在下一瞬间，便听任自由落体定律…径直坠下陡峭的悬崖\n\n![](https://cdn.luogu.com.cn/upload/pic/21200.png)\n\n细长的双眼…注视着我的眼睛。\n\n这是幻觉吗…还是现实…\n\n卓司的指尖捅破了头盖骨…\n\n这根本不可能的吧…人的手劲如何能够捏破头盖骨…\n\n这毫无疑问是幻觉…不可能存在于现实中…\n\n这种事，习武的我是最清楚不过的…\n\n这种根本不可能的事…\n\n尽管如此…\n\n我的意识仍朦胧起来…\n\n已经无法与这个世界保持联系了…\n\n“我…收下皆守哥哥的身体了哦…”\n\n![](https://cdn.luogu.com.cn/upload/pic/21201.png)\n\n司空见惯的风景。\n\n比之前看到的风景更让人眼熟。\n\n我所熟悉的风景…\n\n![](https://cdn.luogu.com.cn/upload/pic/21202.png)\n\n“我会把他带走的…所以你走吧…”\n\n“卓司…那个电波小子，就让我把他带走…”\n\n“所以你就前进吧…”\n\n“在无法登上的坡道的尽头”\n\n“你不能停滞不前，必须前去迎接小羽”\n\n“好啦，打起精神来…皆守”\n\n“在这里告别吧…”\n\n![](https://cdn.luogu.com.cn/upload/pic/21203.png)\n\n轻飘飘的感觉。\n\n瞬间，感觉到了周围空气的急速变冷。\n\n扬起的灰尘伴随月光的照耀，在空中废物。\n\n告别了永不相交的平行，我和羽咲被吸进了…\n\n垂直下落的世界。\n\n月光映照出羽咲身体的轮廓。\n\n地面没有影子。\n\n宛如高空飞翔一般…\n\n远方传来警笛声。\n\n在苍穹之下反复回想。\n\n我仰望无限的天空，笔直坠下。\n\n一刻也不远看丢，在我上方的羽咲…\n\n月在笑。\n\n神在笑。\n\n笑这滑稽的姿势。\n\n笑这喜剧般的悲剧。\n\n群星旋转。\n\n如舞如蹈。\n\n夜空上的神，正嘲弄着我们。\n\n就想把空瓶子扔在地上的天真的孩子一样…\n\n世界变得一片空虚。\n\n![](https://cdn.luogu.com.cn/upload/pic/21204.png)\n\n望不到尽头的坡道…\n\n遥远而模糊的坡道…\n\n宛如…我们就漫步在这样的世界中一般…\n\n就算在意坡道的前方也毫无用处。\n\n我们就在这坡道上快乐地走着。\n\n![](https://cdn.luogu.com.cn/upload/pic/21205.png)\n", "description": "您在打galgame，突然听说苏联解体了，于是您发现您永远看不到一个活着的苏联人了，很郁闷，于是开始写一道数据结构题：\n\n这是一道模(du)拟(liu)题。  \n\n你需要维护一棵包含 $n$ 个结点有根有序树（也就是说每个点的孩子是有“从左到右”的顺序的），初始根为 $1$，支持以下几个操作：  \n\n`A(x,y)`：对 $x$ 进行路径压缩，即将 $x$ 到根路径上除了根之外的点的父亲设为根，这些点在根的孩子中的顺序保持原先路径上从浅到深的顺序。\n\n`B(x,y)`：将根的孩子 $x,y$（$x$ 在 $y$ 左边）以及之间的点按顺序展开成一条路径，$x$ 仍与根相连，涉及到的点原先的孩子都移至路径右侧。\n\n`C(x,y)`：将树的根设为 $x$，此时原先在根到 $x$ 路径左侧的点仍在左侧且先相对顺序不变，右侧同理，$x$ 的孩子在 $x$ 成为根后在 $x$ 到原先的根的路径的右侧。\n\n`D(x,y)`：给 $x$ 到根的路径上每个点的点权同时加一个数，并在这之后求 $x$ 到根的路径上的点权和。\n\n`E(x,y)`：保证 $x$ 和 $y$ 父亲相同且 $x$ 在 $y$ 左侧，对在 $x$ 的父亲的孩子中，$x$ 到 $y$ 之间（含 $x,y$）的每个点的点权加上 $x+y$，并在这之后求这些点的点权和。\n\n`F(x,y)`：给 $x$ 添加一个孩子 $y$，在最右边，这个操作在其它所有操作之前进行，用于描述树的初始形态。", "inputFormat": "第一行两个整数 $n,q$，分别表示树的结点数和操作次数。\n\n接下来 $q$ 行，每行表示一个操作。", "outputFormat": "对每个 `D` 或 `E` 操作，输出一行，表示答案对 $2^{32}$ 取模的结果。  ", "hint": "Idea：ccz181078，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n$2\\leq n\\leq 10^5$，$n\\leq q\\leq 2\\times 10^5$，$0\\leq x,y \\leq n$。\n\n保证操作合法。\n\n为了对称，所有操作都有两个参数 $x,y$，但实际上 `A`，`C` 操作中不需用到 $y$，数据保证此时 $y=0$。  \n\n前 $n-1$ 个操作一定是 `F` 操作，保证 $n-1$ 次操作后得到一棵以 $1$ 为根的树，且以后不会再出现 `F` 操作。  \n\n注意到 `A`，`B`，`C`，`F` 操作都有关于孩子顺序的规定，可以参照样例解释进行直观的理解。  \n\n共 $10$ 组数据。", "locale": "zh-CN", "translations": {"en": {"title": "[Ynoi Easy Round 2016] Zhabolong II", "background": "In an instant…\n\nIf I really had to say, it was even shorter than an instant.\n\nUsaki flew toward the cliff.\n\nSmall and thin Usaki flew over the cliff more easily than I had imagined.\n\nI hurriedly ran to the edge of the cliff.\n\nHowever, after rushing out at full speed, it was not so easy to change direction.\n\nI lost my balance and fell to the ground.\n\nI could only keep chasing Usaki’s figure with my eyes.\n\nUsaki, who had flown out over the cliff.\n\nHer body floated in midair.\n\nIn the next moment, she gave herself to the law of free fall… and dropped straight down the steep cliff.\n\n![](https://cdn.luogu.com.cn/upload/pic/21200.png)\n\nThose narrow eyes… staring into my eyes.\n\nIs this an illusion… or reality…\n\nTakuji’s fingertips pierced through the skull…\n\nThis is impossible… how could a person’s hand strength crush a skull…\n\nThis is undoubtedly an illusion… it cannot exist in reality…\n\nAs someone who practices martial arts, I know this best…\n\nSomething that is fundamentally impossible…\n\nEven so…\n\nMy consciousness still began to blur…\n\nI could no longer keep in touch with this world…\n\n“I… have taken in big brother Minamori’s body…”\n\n![](https://cdn.luogu.com.cn/upload/pic/21201.png)\n\nA familiar scenery.\n\nEven more familiar than what I saw before.\n\nA scenery I know…\n\n![](https://cdn.luogu.com.cn/upload/pic/21202.png)\n\n“I will take him away… so you should go…”\n\n“Takuji… that ‘denpa kid’, I’ll take him away…”\n\n“So you go forward…”\n\n“At the end of the slope that cannot be climbed”\n\n“You cannot stop here, you must go to meet little Yuu”\n\n“Alright, cheer up… Minamori”\n\n“Let’s say goodbye here…”\n\n![](https://cdn.luogu.com.cn/upload/pic/21203.png)\n\nA light, floating feeling.\n\nIn an instant, I felt the air around rapidly turn cold.\n\nThe dust that was kicked up was lit by moonlight, drifting in the air.\n\nSaying farewell to the parallel lines that would never intersect, Usaki and I were pulled into…\n\nA world of vertical falling.\n\nThe moonlight outlined Usaki’s body.\n\nThere were no shadows on the ground.\n\nAs if flying high in the sky…\n\nIn the distance, the sound of sirens came.\n\nEchoing again and again beneath the blue sky.\n\nI looked up at the endless sky and fell straight down.\n\nNot letting her out of my sight even for a moment, Usaki above me…\n\nThe moon was laughing.\n\nGod was laughing.\n\nLaughing at this ridiculous posture.\n\nLaughing at this tragedy like a comedy.\n\nThe stars spun.\n\nDancing and swaying.\n\nThe god in the night sky was mocking us.\n\nLike an innocent child who wants to throw an empty bottle onto the ground…\n\nThe world became completely empty.\n\n![](https://cdn.luogu.com.cn/upload/pic/21204.png)\n\nA slope with no end in sight…\n\nA distant and blurry slope…\n\nAs if… we were strolling in such a world…\n\nEven if you care about what lies ahead of the slope, it is of no use.\n\nWe just walk happily on this slope.\n\n![](https://cdn.luogu.com.cn/upload/pic/21205.png)", "description": "You are playing a galgame, and suddenly you hear that the Soviet Union has collapsed. So you realize that you will never see a living Soviet person again. Feeling depressed, you start writing a data structure problem:\n\nThis is a simulation problem.\n\nYou need to maintain a rooted ordered tree with $n$ nodes (that is, the children of each node have a left-to-right order). Initially, the root is $1$. You need to support the following operations:\n\n`A(x,y)`: Perform path compression on $x$, i.e., for every node on the path from $x$ to the root except the root, set its parent to the root. The order of these nodes among the root’s children remains the same as their order on the original path from shallow to deep.\n\n`B(x,y)`: Take the root’s children $x,y$ ($x$ is to the left of $y$) and all nodes between them, and expand them in order into a single path. $x$ remains connected to the root. All children that these involved nodes originally had are moved to the right side of the path.\n\n`C(x,y)`: Set the root of the tree to be $x$. At this time, nodes that were on the left side of the original path from the old root to $x$ remain on the left and their relative order does not change; similarly for the right side. After $x$ becomes the root, the children of $x$ are placed on the right side of the path from $x$ to the original root.\n\n`D(x,y)`: Add a number to the weight of every node on the path from $x$ to the root, and then query the sum of weights on the path from $x$ to the root.\n\n`E(x,y)`: It is guaranteed that $x$ and $y$ have the same parent and that $x$ is to the left of $y$. For every node between $x$ and $y$ (including $x,y$) among the children of $x$’s parent, add $x+y$ to its weight, and then query the sum of weights of these nodes.\n\n`F(x,y)`: Add $y$ as a child of $x$, at the far right. This operation is performed before all other operations and is used to describe the initial shape of the tree.", "inputFormat": "The first line contains two integers $n,q$, representing the number of nodes in the tree and the number of operations.\n\nThe next $q$ lines each describe an operation.", "outputFormat": "For each `D` or `E` operation, output one line: the result modulo $2^{32}$.", "hint": "Idea: ccz181078, Solution: ccz181078, Code: ccz181078, Data: ccz181078\n\nConstraints: $2\\leq n\\leq 10^5$，$n\\leq q\\leq 2\\times 10^5$，$0\\leq x,y \\leq n$.\n\nAll operations are guaranteed to be valid.\n\nFor symmetry, all operations have two parameters $x,y$, but actually $y$ is not needed in operations `A` and `C`. The testdata guarantees that $y=0$ in these cases.\n\nThe first $n-1$ operations are all `F` operations, guaranteeing that after these $n-1$ operations you get a tree rooted at $1$, and no more `F` operations will appear afterwards.\n\nNote that operations `A`, `B`, `C`, and `F` all have rules about the order of children. You may refer to the sample explanation for an intuitive understanding.\n\nThere are $10$ test groups.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Ynoi Easy Round 2016] 炸脖龙 II", "background": "瞬间…\n\n真要说的话，比瞬间还要短暂。\n\n羽咲往悬崖的方向飞去。\n\n瘦小的羽咲，比想象中更轻易地飞侠了悬崖。\n\n我急忙跑向悬崖边。\n\n然而，飞奔而出之后，方向并不是那么容易改变。\n\n我失去了平衡，就这么摔倒在地。\n\n只能一直用目光追寻着羽咲的身影。\n\n飞出悬崖的羽咲。\n\n身体浮在半空中。\n\n在下一瞬间，便听任自由落体定律…径直坠下陡峭的悬崖\n\n![](https://cdn.luogu.com.cn/upload/pic/21200.png)\n\n细长的双眼…注视着我的眼睛。\n\n这是幻觉吗…还是现实…\n\n卓司的指尖捅破了头盖骨…\n\n这根本不可能的吧…人的手劲如何能够捏破头盖骨…\n\n这毫无疑问是幻觉…不可能存在于现实中…\n\n这种事，习武的我是最清楚不过的…\n\n这种根本不可能的事…\n\n尽管如此…\n\n我的意识仍朦胧起来…\n\n已经无法与这个世界保持联系了…\n\n“我…收下皆守哥哥的身体了哦…”\n\n![](https://cdn.luogu.com.cn/upload/pic/21201.png)\n\n司空见惯的风景。\n\n比之前看到的风景更让人眼熟。\n\n我所熟悉的风景…\n\n![](https://cdn.luogu.com.cn/upload/pic/21202.png)\n\n“我会把他带走的…所以你走吧…”\n\n“卓司…那个电波小子，就让我把他带走…”\n\n“所以你就前进吧…”\n\n“在无法登上的坡道的尽头”\n\n“你不能停滞不前，必须前去迎接小羽”\n\n“好啦，打起精神来…皆守”\n\n“在这里告别吧…”\n\n![](https://cdn.luogu.com.cn/upload/pic/21203.png)\n\n轻飘飘的感觉。\n\n瞬间，感觉到了周围空气的急速变冷。\n\n扬起的灰尘伴随月光的照耀，在空中废物。\n\n告别了永不相交的平行，我和羽咲被吸进了…\n\n垂直下落的世界。\n\n月光映照出羽咲身体的轮廓。\n\n地面没有影子。\n\n宛如高空飞翔一般…\n\n远方传来警笛声。\n\n在苍穹之下反复回想。\n\n我仰望无限的天空，笔直坠下。\n\n一刻也不远看丢，在我上方的羽咲…\n\n月在笑。\n\n神在笑。\n\n笑这滑稽的姿势。\n\n笑这喜剧般的悲剧。\n\n群星旋转。\n\n如舞如蹈。\n\n夜空上的神，正嘲弄着我们。\n\n就想把空瓶子扔在地上的天真的孩子一样…\n\n世界变得一片空虚。\n\n![](https://cdn.luogu.com.cn/upload/pic/21204.png)\n\n望不到尽头的坡道…\n\n遥远而模糊的坡道…\n\n宛如…我们就漫步在这样的世界中一般…\n\n就算在意坡道的前方也毫无用处。\n\n我们就在这坡道上快乐地走着。\n\n![](https://cdn.luogu.com.cn/upload/pic/21205.png)\n", "description": "您在打galgame，突然听说苏联解体了，于是您发现您永远看不到一个活着的苏联人了，很郁闷，于是开始写一道数据结构题：\n\n这是一道模(du)拟(liu)题。  \n\n你需要维护一棵包含 $n$ 个结点有根有序树（也就是说每个点的孩子是有“从左到右”的顺序的），初始根为 $1$，支持以下几个操作：  \n\n`A(x,y)`：对 $x$ 进行路径压缩，即将 $x$ 到根路径上除了根之外的点的父亲设为根，这些点在根的孩子中的顺序保持原先路径上从浅到深的顺序。\n\n`B(x,y)`：将根的孩子 $x,y$（$x$ 在 $y$ 左边）以及之间的点按顺序展开成一条路径，$x$ 仍与根相连，涉及到的点原先的孩子都移至路径右侧。\n\n`C(x,y)`：将树的根设为 $x$，此时原先在根到 $x$ 路径左侧的点仍在左侧且先相对顺序不变，右侧同理，$x$ 的孩子在 $x$ 成为根后在 $x$ 到原先的根的路径的右侧。\n\n`D(x,y)`：给 $x$ 到根的路径上每个点的点权同时加一个数，并在这之后求 $x$ 到根的路径上的点权和。\n\n`E(x,y)`：保证 $x$ 和 $y$ 父亲相同且 $x$ 在 $y$ 左侧，对在 $x$ 的父亲的孩子中，$x$ 到 $y$ 之间（含 $x,y$）的每个点的点权加上 $x+y$，并在这之后求这些点的点权和。\n\n`F(x,y)`：给 $x$ 添加一个孩子 $y$，在最右边，这个操作在其它所有操作之前进行，用于描述树的初始形态。", "inputFormat": "第一行两个整数 $n,q$，分别表示树的结点数和操作次数。\n\n接下来 $q$ 行，每行表示一个操作。", "outputFormat": "对每个 `D` 或 `E` 操作，输出一行，表示答案对 $2^{32}$ 取模的结果。  ", "hint": "Idea：ccz181078，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n$2\\leq n\\leq 10^5$，$n\\leq q\\leq 2\\times 10^5$，$0\\leq x,y \\leq n$。\n\n保证操作合法。\n\n为了对称，所有操作都有两个参数 $x,y$，但实际上 `A`，`C` 操作中不需用到 $y$，数据保证此时 $y=0$。  \n\n前 $n-1$ 个操作一定是 `F` 操作，保证 $n-1$ 次操作后得到一棵以 $1$ 为根的树，且以后不会再出现 `F` 操作。  \n\n注意到 `A`，`B`，`C`，`F` 操作都有关于孩子顺序的规定，可以参照样例解释进行直观的理解。  \n\n共 $10$ 组数据。", "locale": "zh-CN"}}}
{"pid": "P4694", "type": "P", "difficulty": 6, "samples": [["8 4\n3 8 7 9 9 4 6 8\n2 5 9 4 3 8 9 1", "32"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "O2优化", "凸完全单调性（wqs 二分）", "模拟费用流", "PA（波兰）"], "title": "[PA 2013] Raper", "background": "", "description": "你需要生产 $k$ 张光盘。每张光盘都要经过两道工序：先在 A 工厂进行挤压，再送到 B 工厂涂上反光层。\n\n你知道每天 A、B 工厂分别加工一张光盘的花费。你现在有 $n$ 天时间，每天可以先送一张光盘到 A 工厂（或者不送），然后再送一张已经在 A 工厂加工过的光盘到 B 工厂（或者不送），每家工厂一天只能对一张光盘进行操作，同一张光盘在一天内生产出来是允许的。我们假定将未加工的或半成品的光盘保存起来不需要费用。\n\n求生产出 $k$ 张光盘的最小花费。", "inputFormat": "第一行包含两个整数 $n, k$，表示有 $n$ 天，要生产 $k$ 张光盘。\n\n第二行包含 $n$ 个整数，第 $i$ 个整数表示第 $i$ 天送到 A 工厂加工光盘的花费。\n\n第三行包含 $n$ 个整数，第 $i$ 个整数表示第 $i$ 天送到 B 工厂加工光盘的花费。", "outputFormat": "输出一行一个整数，表示最小花费。", "hint": "保证 $1 \\leqslant k \\leqslant n \\leqslant 5 \\times 10^5,$ $1 \\leqslant  a_i, b_i \\leqslant 10^9$。\n\n注：添加了 3 组 Hack 数据，如未通过将扣除 3 分。", "locale": "zh-CN", "translations": {"en": {"title": "[PA 2013] Raper", "background": "", "description": "You need to produce $k$ optical discs. Each disc must go through two steps: first it is pressed at factory A, and then it is sent to factory B to be coated with a reflective layer.\n\nYou know the daily cost for factories A and B to process one disc. You have $n$ days. Each day, you may first send one disc to factory A for processing (or send none), and then send one disc that has already been processed at factory A to factory B for processing (or send none). Each factory can process at most one disc per day. It is allowed for the same disc to be fully produced within a single day. We assume there is no cost to store unprocessed or half-finished discs.\n\nFind the minimum total cost to produce $k$ discs.", "inputFormat": "The first line contains two integers $n, k$, meaning there are $n$ days and you need to produce $k$ optical discs.\n\nThe second line contains $n$ integers. The $i$-th integer is the cost of sending a disc to factory A on day $i$.\n\nThe third line contains $n$ integers. The $i$-th integer is the cost of sending a disc to factory B on day $i$.", "outputFormat": "Output one integer on a single line, the minimum total cost.", "hint": "It is guaranteed that $1 \\leqslant k \\leqslant n \\leqslant 5 \\times 10^5,$ and $1 \\leqslant a_i, b_i \\leqslant 10^9$.\n\nNote: 3 sets of hack testdata were added. If you do not pass them, 3 points will be deducted.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[PA 2013] Raper", "background": "", "description": "你需要生产 $k$ 张光盘。每张光盘都要经过两道工序：先在 A 工厂进行挤压，再送到 B 工厂涂上反光层。\n\n你知道每天 A、B 工厂分别加工一张光盘的花费。你现在有 $n$ 天时间，每天可以先送一张光盘到 A 工厂（或者不送），然后再送一张已经在 A 工厂加工过的光盘到 B 工厂（或者不送），每家工厂一天只能对一张光盘进行操作，同一张光盘在一天内生产出来是允许的。我们假定将未加工的或半成品的光盘保存起来不需要费用。\n\n求生产出 $k$ 张光盘的最小花费。", "inputFormat": "第一行包含两个整数 $n, k$，表示有 $n$ 天，要生产 $k$ 张光盘。\n\n第二行包含 $n$ 个整数，第 $i$ 个整数表示第 $i$ 天送到 A 工厂加工光盘的花费。\n\n第三行包含 $n$ 个整数，第 $i$ 个整数表示第 $i$ 天送到 B 工厂加工光盘的花费。", "outputFormat": "输出一行一个整数，表示最小花费。", "hint": "保证 $1 \\leqslant k \\leqslant n \\leqslant 5 \\times 10^5,$ $1 \\leqslant  a_i, b_i \\leqslant 10^9$。\n\n注：添加了 3 组 Hack 数据，如未通过将扣除 3 分。", "locale": "zh-CN"}}}
{"pid": "P4695", "type": "P", "difficulty": 6, "samples": [["4 4\n10 20 30 50\n1 2 5\n2 3 7\n2 4 57\n1 3 28\n1 1 25\n2 3 2 1\n2 2 4 13", "3 1 3 4"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "线段树", "点分治", "O2优化", "树链剖分", "动态树 LCT", "PA（波兰）"], "title": "[PA 2017] Banany", "background": "", "description": "Bajtazar 是一名商人，他每天会从自己所在的城市出发，到另一个城市去贩卖香蕉。每条道路都会有一定的过路费，而作为终点的城市能获得一定收益（注意：途经点没有收益）。而每过一天，就会有一条道路的费用发生变化，或者某个城市的收益发生变化。Bajtazar 想知道当他每一天醒来后，以哪个城市作为终点获得的利润最大，而次日他会从该城市继续出发。\n\n有 $n$ 个城市，由 $n - 1$ 条道路连接，且互相都能到达。第 $i$ 个城市有一个收益 $z_i$ ，每条边有一个费用 $w$ 。\n\n如果从 $s$ 到 $t$ 做生意，获得的利润是\n\n$$ z_t - \\sum_{e \\in \\mathrm{Path}(s, t)} w(e) $$\n\n一共有 $q$ 天。\n\n最初 Bajtazar 在 $1$ 号城市。他每天经历了费用的变动后会前往下一个城市。他会选择获得利润最大的，如有多个相同则选择编号最小的，但他不能呆在原来的城市不走。\n", "inputFormat": "第一行输入两个整数 $n$ ，$q$ 。\n\n第二行输入 $n$ 个整数表示受益 $z_1,z_2,…,z_n$ 。\n\n接下来 $n - 1$ 行输入边权与费用 $u\\ v\\ w$ 。\n\n接下来 $q$ 行，有两种输入。\n\n-    输入 $1\\ i\\ z_i$ 表示将原本 $i$ 城市的费用替换。\n+    输入 $2\\ u\\ v\\ w$ 表示将原本连接 $(u,v)$ 两城市的边上的费用替换。\n\n", "outputFormat": "对于每行变化，总共输出 $q$ 组答案。表示经历变化之后， Bajtazar 的下一个目标。", "hint": "$n,q \\le 10^5,1 \\le z_i \\le 10^{18}$​​, $1 \\le w \\le 10^{12}$", "locale": "zh-CN", "translations": {"en": {"title": "[PA 2017] Banany", "background": "", "description": "Bajtazar is a merchant. Every day, he leaves the city he is currently in and travels to another city to sell bananas. Each road has a toll fee, and the destination city provides some revenue (note that intermediate cities provide no revenue). Each day, the fee of one road changes, or the revenue of one city changes. Bajtazar wants to know, after he wakes up each day, which city he should choose as the destination to obtain the maximum profit, and on the next day he will depart from that city again.\n\nThere are $n$ cities, connected by $n - 1$ roads, and every city is reachable from every other city. City $i$ has revenue $z_i$, and each edge has a fee $w$.\n\nIf he does business from $s$ to $t$, the profit is\n\n$$ z_t - \\sum_{e \\in \\mathrm{Path}(s, t)} w(e) $$\n\nThere are $q$ days in total.\n\nInitially, Bajtazar is in city $1$. Each day, after the changes take place, he will go to the next city. He will choose the one that yields the maximum profit; if there are multiple, he chooses the one with the smallest index. However, he cannot stay in the same city and must leave.", "inputFormat": "The first line contains two integers $n$ and $q$.\n\nThe second line contains $n$ integers representing the revenues $z_1, z_2, \\dots, z_n$.\n\nThe next $n - 1$ lines each contain $u\\ v\\ w$, describing an edge and its fee.\n\nThe next $q$ lines are of two types.\n\n- Input $1\\ i\\ z_i$ means replacing the revenue of city $i$ with the new value.\n- Input $2\\ u\\ v\\ w$ means replacing the fee of the edge connecting cities $(u, v)$ with the new value.", "outputFormat": "For each change, output one line. In total, output $q$ answers, each indicating Bajtazar's next destination after the change.", "hint": "Constraints: $n, q \\le 10^5$, $1 \\le z_i \\le 10^{18}$, $1 \\le w \\le 10^{12}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[PA 2017] Banany", "background": "", "description": "Bajtazar 是一名商人，他每天会从自己所在的城市出发，到另一个城市去贩卖香蕉。每条道路都会有一定的过路费，而作为终点的城市能获得一定收益（注意：途经点没有收益）。而每过一天，就会有一条道路的费用发生变化，或者某个城市的收益发生变化。Bajtazar 想知道当他每一天醒来后，以哪个城市作为终点获得的利润最大，而次日他会从该城市继续出发。\n\n有 $n$ 个城市，由 $n - 1$ 条道路连接，且互相都能到达。第 $i$ 个城市有一个收益 $z_i$ ，每条边有一个费用 $w$ 。\n\n如果从 $s$ 到 $t$ 做生意，获得的利润是\n\n$$ z_t - \\sum_{e \\in \\mathrm{Path}(s, t)} w(e) $$\n\n一共有 $q$ 天。\n\n最初 Bajtazar 在 $1$ 号城市。他每天经历了费用的变动后会前往下一个城市。他会选择获得利润最大的，如有多个相同则选择编号最小的，但他不能呆在原来的城市不走。\n", "inputFormat": "第一行输入两个整数 $n$ ，$q$ 。\n\n第二行输入 $n$ 个整数表示受益 $z_1,z_2,…,z_n$ 。\n\n接下来 $n - 1$ 行输入边权与费用 $u\\ v\\ w$ 。\n\n接下来 $q$ 行，有两种输入。\n\n-    输入 $1\\ i\\ z_i$ 表示将原本 $i$ 城市的费用替换。\n+    输入 $2\\ u\\ v\\ w$ 表示将原本连接 $(u,v)$ 两城市的边上的费用替换。\n\n", "outputFormat": "对于每行变化，总共输出 $q$ 组答案。表示经历变化之后， Bajtazar 的下一个目标。", "hint": "$n,q \\le 10^5,1 \\le z_i \\le 10^{18}$​​, $1 \\le w \\le 10^{12}$", "locale": "zh-CN"}}}
{"pid": "P4696", "type": "P", "difficulty": 6, "samples": [["5 10\n2 1 5 3 4\n5 6 3 8 12 7 1 10 11 9", "2\n2 6"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2011", "线段树", "离散化", "CEOI（中欧）", "哈希 hashing", "KMP 算法", "链表"], "title": "[CEOI 2011] Matching", "background": "", "description": "对于整数序列 $(a_1,a_2,\\cdots,a_n)$ 和 $1\\sim n$ 的排列 $(p_1,p_2,\\cdots,p_n)$，称 $(a_1,a_2,\\cdots,a_n)$ 符合 $(p_1,p_2,\\cdots,p_n)$，当且仅当：\n\n-    $\\{a\\}$ 中任意两个数字互不相同；\n\n-    将 $(a_1,a_2,\\cdots,a_n)$ 从小到大排序后，将会得到 $(a_{p_1},a_{p_2},\\cdots,a_{p_n})$。\n\n现在给出 $1\\sim n$ 的排列 $\\{p\\}$ 和序列 $h_1,h_2,\\cdots,h_m$​​，请你求出哪些 $\\{h\\}$ 的子串符合排列 $\\{p\\}$。\n", "inputFormat": "第一行两个空格隔开的正整数 $n,m$。\n\n第二行 $n$ 个空格隔开的正整数，表示排列 $p$。\n\n第三行 $m$ 个空格隔开的正整数，表示序列 $h$。", "outputFormat": "第一行一个整数 $k$，表示符合 $\\{p\\}$ 的子串个数。\n\n第二行 $k$ 个空格隔开的正整数，表示这些子串的起始位置（编号从 $1$ 开始）。请将这些位置按照从小到大的顺序输出。特别地，若 $k=0$，那么你也应当输出一个空行。", "hint": "对于 $100\\%$ 的数据，有 $2\\le n\\le m\\le 1\\ 000\\ 000;1\\le h_i\\le 10^9;1\\le p_i\\le n$，保证 $\\{h\\}$ 中的元素互不相同，且 $\\{p\\}$ 是一个排列。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2011] Matching", "background": "", "description": "For an integer sequence $(a_1,a_2,\\cdots,a_n)$ and a permutation $(p_1,p_2,\\cdots,p_n)$ of $1 \\sim n$, we say that $(a_1,a_2,\\cdots,a_n)$ matches $(p_1,p_2,\\cdots,p_n)$ if and only if:\n\n- Any two numbers in $\\{a\\}$ are different from each other.\n- After sorting $(a_1,a_2,\\cdots,a_n)$ in increasing order, we obtain $(a_{p_1},a_{p_2},\\cdots,a_{p_n})$.\n\nNow you are given a permutation $\\{p\\}$ of $1 \\sim n$ and a sequence $h_1,h_2,\\cdots,h_m$. Please determine which substrings of $\\{h\\}$ match the permutation $\\{p\\}$.", "inputFormat": "The first line contains two positive integers $n,m$ separated by spaces.\n\nThe second line contains $n$ positive integers separated by spaces, representing the permutation $p$.\n\nThe third line contains $m$ positive integers separated by spaces, representing the sequence $h$.", "outputFormat": "The first line contains an integer $k$, indicating the number of substrings that match $\\{p\\}$.\n\nThe second line contains $k$ positive integers separated by spaces, indicating the starting positions of these substrings (indexed from $1$). Output these positions in increasing order. In particular, if $k=0$, you should output an empty line as well.", "hint": "For $100\\%$ of the testdata, $2\\le n\\le m\\le 1\\ 000\\ 000;1\\le h_i\\le 10^9;1\\le p_i\\le n$. It is guaranteed that all elements in $\\{h\\}$ are pairwise distinct, and $\\{p\\}$ is a permutation.\n\n# Constraints\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2011] Matching", "background": "", "description": "对于整数序列 $(a_1,a_2,\\cdots,a_n)$ 和 $1\\sim n$ 的排列 $(p_1,p_2,\\cdots,p_n)$，称 $(a_1,a_2,\\cdots,a_n)$ 符合 $(p_1,p_2,\\cdots,p_n)$，当且仅当：\n\n-    $\\{a\\}$ 中任意两个数字互不相同；\n\n-    将 $(a_1,a_2,\\cdots,a_n)$ 从小到大排序后，将会得到 $(a_{p_1},a_{p_2},\\cdots,a_{p_n})$。\n\n现在给出 $1\\sim n$ 的排列 $\\{p\\}$ 和序列 $h_1,h_2,\\cdots,h_m$​​，请你求出哪些 $\\{h\\}$ 的子串符合排列 $\\{p\\}$。\n", "inputFormat": "第一行两个空格隔开的正整数 $n,m$。\n\n第二行 $n$ 个空格隔开的正整数，表示排列 $p$。\n\n第三行 $m$ 个空格隔开的正整数，表示序列 $h$。", "outputFormat": "第一行一个整数 $k$，表示符合 $\\{p\\}$ 的子串个数。\n\n第二行 $k$ 个空格隔开的正整数，表示这些子串的起始位置（编号从 $1$ 开始）。请将这些位置按照从小到大的顺序输出。特别地，若 $k=0$，那么你也应当输出一个空行。", "hint": "对于 $100\\%$ 的数据，有 $2\\le n\\le m\\le 1\\ 000\\ 000;1\\le h_i\\le 10^9;1\\le p_i\\le n$，保证 $\\{h\\}$ 中的元素互不相同，且 $\\{p\\}$ 是一个排列。", "locale": "zh-CN"}}}
{"pid": "P4697", "type": "P", "difficulty": 6, "samples": [["3\n0 9\n8 1\n13 7", "9.000\n1.000\n4.694"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["计算几何", "2011", "Special Judge", "CEOI（中欧）", "单调栈"], "title": "[CEOI 2011] Balloons", "background": "", "description": "有 $n$ 个气球，他们一开始都是空的。\n\n接下来，它们会按照从 $1$ 到 $n$ 的顺序依次充气，其中第 $i$ 个气球与地面在 $x_i$ 位置接触。\n\n当气球碰到碰到前面的某个气球，或者达到半径最大限制时，就会停止充气。其中第 $i$ 个气球的半径最大限制为 $r_i$。\n\n现在请你求出，每个气球最终半径是多少。", "inputFormat": "第一行一个正整数 $n$，表示气球个数。\n\n接下来 $n$ 行，每行两个空格隔开的整数 $x_i,r_i$。", "outputFormat": "输出 $n$ 行，每行一个浮点数，第 $i$ 行的浮点数表示最终第 $i$ 个气球的半径。\n\n你的答案会被判为正确，当且仅当与答案的绝对误差不超过 $10^{-3}$​​。", "hint": "对于 $100\\%$ 的数据，保证 $1\\le n\\le 200\\ 000;0\\le x_i\\le 10^9;1\\le r_i\\le 10^9;x_1< x_2< \\cdots < x_n$。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2011] Balloons", "background": "", "description": "There are $n$ balloons, and they are all empty at the beginning.\n\nNext, they will be inflated one by one in order from $1$ to $n$. The $i$-th balloon touches the ground at position $x_i$.\n\nA balloon stops inflating when it touches some previous balloon, or when it reaches its maximum radius limit. The maximum radius limit of the $i$-th balloon is $r_i$.\n\nNow, please find the final radius of each balloon.", "inputFormat": "The first line contains a positive integer $n$, which represents the number of balloons.\n\nThe next $n$ lines each contain two integers $x_i, r_i$ separated by a space.", "outputFormat": "Output $n$ lines. Each line contains a floating-point number. The floating-point number on the $i$-th line represents the final radius of the $i$-th balloon.\n\nYour answer will be judged correct if and only if the absolute error from the correct answer does not exceed $10^{-3}$.", "hint": "For $100\\%$ of the testdata, it is guaranteed that $1 \\le n \\le 200\\,000$, $0 \\le x_i \\le 10^9$, $1 \\le r_i \\le 10^9$, and $x_1 < x_2 < \\cdots < x_n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2011] Balloons", "background": "", "description": "有 $n$ 个气球，他们一开始都是空的。\n\n接下来，它们会按照从 $1$ 到 $n$ 的顺序依次充气，其中第 $i$ 个气球与地面在 $x_i$ 位置接触。\n\n当气球碰到碰到前面的某个气球，或者达到半径最大限制时，就会停止充气。其中第 $i$ 个气球的半径最大限制为 $r_i$。\n\n现在请你求出，每个气球最终半径是多少。", "inputFormat": "第一行一个正整数 $n$，表示气球个数。\n\n接下来 $n$ 行，每行两个空格隔开的整数 $x_i,r_i$。", "outputFormat": "输出 $n$ 行，每行一个浮点数，第 $i$ 行的浮点数表示最终第 $i$ 个气球的半径。\n\n你的答案会被判为正确，当且仅当与答案的绝对误差不超过 $10^{-3}$​​。", "hint": "对于 $100\\%$ 的数据，保证 $1\\le n\\le 200\\ 000;0\\le x_i\\le 10^9;1\\le r_i\\le 10^9;x_1< x_2< \\cdots < x_n$。", "locale": "zh-CN"}}}
{"pid": "P4698", "type": "P", "difficulty": 6, "samples": [["3 2 2\n150 2\n400 3\n100 2\n200 1\n700 3", "400"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2011", "CEOI（中欧）"], "title": "[CEOI 2011] Hotel", "background": "", "description": "你经营着一家旅馆，这家旅馆有 $n$ 个房间，每个房间有维护费用和容量。其中第 $i$ 个房间的维护费用为 $c_i$，容量为 $p_i$ 人。\n\n现在有 $m$ 个订单，每个订单有两个参数：$v_i,d_i$ ，其中 $v_i$ 表示这个订单支付的租金，$d_i$​​ 表示人数。\n\n你现在得要合理选择一些订单，并放弃其他订单，使得每个选择的订单被安排在同一间房间内，且人数不超过这个房间的容量限制。当然，两个不同的订单也不能被安排在同一间房间内。\n\n现在你想要知道，在最多选出 $o$ 个订单时的最大收益。一个方案的收益的定义为，选出的订单的租金和，减去选出的房间的维护费用和。", "inputFormat": "第一行三个空格隔开的整数 $n,m,o$ 。\n\n接下来 $n$ 行，每行两个空格隔开的整数 $c_i,p_i$。\n\n接下来 $m$ 行，每行两个空格隔开的整数 $v_i,d_i$。", "outputFormat": "一行一个整数表示最大收益。注意答案可能很大。", "hint": "**样例 $1$ 解释**\n\n可以将第一个订单安排至第三个房间，将第二个订单安排至第二个房间。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，有 $1\\le n,m\\le 500\\ 000;1\\le o\\le \\min(n,m);1\\le c_i,p_i,v_i,d_i\\le 10^9$，保证 $\\forall 1\\le i,j\\le n$，若 $p_i\\lt p_j$，则 $c_i\\le c_j$。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2011] Hotel", "background": "", "description": "You run a hotel with $n$ rooms. Each room has a maintenance cost and a capacity. For room $i$, the maintenance cost is $c_i$ and the capacity is $p_i$ people.\n\nThere are $m$ orders. Each order has two parameters: $v_i, d_i$, where $v_i$ is the rent paid by the order, and $d_i$ is the number of people.\n\nYou need to choose some orders and reject the others, so that each chosen order is assigned to exactly one room, and its number of people does not exceed the capacity of that room. Of course, two different orders cannot be assigned to the same room.\n\nYou want to know the maximum profit when you choose at most $o$ orders. The profit of a plan is defined as the sum of rents of the chosen orders minus the sum of maintenance costs of the chosen rooms.", "inputFormat": "The first line contains three integers $n, m, o$ separated by spaces.\n\nThe next $n$ lines each contain two integers $c_i, p_i$ separated by spaces.\n\nThe next $m$ lines each contain two integers $v_i, d_i$ separated by spaces.", "outputFormat": "Output one integer, the maximum profit. Note that the answer may be very large.", "hint": "**Explanation for Sample $1$.**\n\nYou can assign the first order to the third room, and the second order to the second room.\n\n**Constraints**\n\nFor $100\\%$ of the testdata, $1 \\le n, m \\le 500\\ 000$, $1 \\le o \\le \\min(n, m)$, $1 \\le c_i, p_i, v_i, d_i \\le 10^9$. It is guaranteed that for all $1 \\le i, j \\le n$, if $p_i \\lt p_j$, then $c_i \\le c_j$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2011] Hotel", "background": "", "description": "你经营着一家旅馆，这家旅馆有 $n$ 个房间，每个房间有维护费用和容量。其中第 $i$ 个房间的维护费用为 $c_i$，容量为 $p_i$ 人。\n\n现在有 $m$ 个订单，每个订单有两个参数：$v_i,d_i$ ，其中 $v_i$ 表示这个订单支付的租金，$d_i$​​ 表示人数。\n\n你现在得要合理选择一些订单，并放弃其他订单，使得每个选择的订单被安排在同一间房间内，且人数不超过这个房间的容量限制。当然，两个不同的订单也不能被安排在同一间房间内。\n\n现在你想要知道，在最多选出 $o$ 个订单时的最大收益。一个方案的收益的定义为，选出的订单的租金和，减去选出的房间的维护费用和。", "inputFormat": "第一行三个空格隔开的整数 $n,m,o$ 。\n\n接下来 $n$ 行，每行两个空格隔开的整数 $c_i,p_i$。\n\n接下来 $m$ 行，每行两个空格隔开的整数 $v_i,d_i$。", "outputFormat": "一行一个整数表示最大收益。注意答案可能很大。", "hint": "**样例 $1$ 解释**\n\n可以将第一个订单安排至第三个房间，将第二个订单安排至第二个房间。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，有 $1\\le n,m\\le 500\\ 000;1\\le o\\le \\min(n,m);1\\le c_i,p_i,v_i,d_i\\le 10^9$，保证 $\\forall 1\\le i,j\\le n$，若 $p_i\\lt p_j$，则 $c_i\\le c_j$。", "locale": "zh-CN"}}}
{"pid": "P4699", "type": "P", "difficulty": 6, "samples": [["5\n2\n1\n2\n2\n3", "2\n2 4 2\n3 5 1 3"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2011", "Special Judge", "CEOI（中欧）"], "title": "[CEOI 2011] Teams", "background": "", "description": "有 $n$ 个小朋友要进行比赛，他们要被分为若干队伍。每一个小朋友都有一个要求，其中第 $i$ 个小朋友要求他所在的队伍最少要有 $a_i$ 个人（包括自己）。\n\n现在请你求出一种划分方案，在满足所有小朋友的要求的情况下，最大化队伍的数量。同时在此基础上，请你最小化人数最多的队伍的人数。", "inputFormat": "第一行一个数 $n$ 表示小朋友的个数。\n\n接下来 $n$ 行，每行一个数，其中第 $i$ 行的数字为 $a_i$​​ 。", "outputFormat": "第一行一个数 $t$ ，表示在你的方案中的队伍数量。\n\n接下来 $t$ 行，每行若干个空格隔开的数字，表示一只队伍。每一行首先输出一个数 $k_i$​​ 表示第 $i$ 只队伍的人数，接下来 $k_i$ 个数依次描述该队伍内的小朋友的编号（从 $1$ 开始）。\n\n若有多解（在满足题目要求的情况下），输出任意一个即可。", "hint": "对于 $100\\%$ 的数据，有 $1\\le n\\le 1\\ 000\\ 000;1\\le a_i\\le n$，输入保证有解。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2011] Teams", "background": "", "description": "There are $n$ children who want to take part in a competition, and they need to be divided into several teams. Each child has a requirement: the $i$-th child requires that the team they are in must have at least $a_i$ people (including themselves).\n\nNow you need to find a partition plan that, while satisfying all children’s requirements, maximizes the number of teams. Based on that, you should minimize the size of the largest team.", "inputFormat": "The first line contains an integer $n$, the number of children.\n\nThe next $n$ lines each contain one integer. The number on the $i$-th line is $a_i$.", "outputFormat": "The first line contains an integer $t$, the number of teams in your plan.\n\nThe next $t$ lines describe the teams, with several integers separated by spaces on each line. Each line first outputs an integer $k_i$, the size of the $i$-th team, followed by $k_i$ integers giving the indices of the children in that team (starting from $1$).\n\nIf there are multiple solutions (while satisfying the requirements), output any one of them.", "hint": "For $100\\%$ of the testdata, $1\\le n\\le 1\\ 000\\ 000;1\\le a_i\\le n$, and the input is guaranteed to have a solution.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2011] Teams", "background": "", "description": "有 $n$ 个小朋友要进行比赛，他们要被分为若干队伍。每一个小朋友都有一个要求，其中第 $i$ 个小朋友要求他所在的队伍最少要有 $a_i$ 个人（包括自己）。\n\n现在请你求出一种划分方案，在满足所有小朋友的要求的情况下，最大化队伍的数量。同时在此基础上，请你最小化人数最多的队伍的人数。", "inputFormat": "第一行一个数 $n$ 表示小朋友的个数。\n\n接下来 $n$ 行，每行一个数，其中第 $i$ 行的数字为 $a_i$​​ 。", "outputFormat": "第一行一个数 $t$ ，表示在你的方案中的队伍数量。\n\n接下来 $t$ 行，每行若干个空格隔开的数字，表示一只队伍。每一行首先输出一个数 $k_i$​​ 表示第 $i$ 只队伍的人数，接下来 $k_i$ 个数依次描述该队伍内的小朋友的编号（从 $1$ 开始）。\n\n若有多解（在满足题目要求的情况下），输出任意一个即可。", "hint": "对于 $100\\%$ 的数据，有 $1\\le n\\le 1\\ 000\\ 000;1\\le a_i\\le n$，输入保证有解。", "locale": "zh-CN"}}}
{"pid": "P4700", "type": "P", "difficulty": 6, "samples": [["5 3 1 3\n0 0\n0 1\n0 2\n1 0\n1 1\n1 4 1\n1 5 2\n3 5 2", "2\n0\n2"], ["12 13 7 9\n0 1\n0 3\n2 2\n5 2\n7 1\n7 4\n7 6\n7 7\n3 5\n0 5\n0 9\n3 9\n1 3 2\n3 2 1\n3 4 1\n4 5 1\n5 6 1\n9 3 1\n9 4 1\n9 7 1\n9 12 2\n10 9 1\n11 12 1\n12 8 1\n12 10 1", "4\n4\n0\n2"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "CEOI（中欧）"], "title": "[CEOI 2011] Traffic", "background": null, "description": "在平面直角坐标系上有 $n$ 个点，其中第 $i$ 个点的坐标是 $(x_i,y_i)$ ，所有点在一个以 $(0,0)$ 和 $(A,B)$ 为相对顶点的矩形内。\n\n如果 $x_i=0$ ，那么我们称这个点在西侧。如果 $x_i=A$ ，那么我们称这个点在东侧。\n\n这些点之间有 $m$ 条边，每条边可能是有向边也可能是无向边，保证边在给定的 $n$ 个点以外的任何地方不相交。\n\n现在请你求出，对于每一个西侧的点，能够沿着边到达多少东侧的点。", "inputFormat": "第一行四个空格隔开的数 $n,m,A,B$ 。\n\n接下来 $n$ 行，每行两个空格隔开的数 $x_i,y_i$ 。\n\n接下来 $m$ 行，每行三个空格隔开的数 $c_i,d_i,k_i$​​ ，表示一条 $c_i$​​ 和 $d_i$ 之间的边。如果 $k_i=1$ ，那么表示这条边是有向边，方向为 $c_i$​​ 指向 $d_i$​​ ，否则这条边是无向边。", "outputFormat": "输出有若干行，每行一个数表示答案。请按照 $y$ 从大到小的顺序输出所有点对应的答案。", "hint": "**样例 $2$ 解释**\n\n![0](https://i.loli.net/2018/04/18/5ad725326df6f.png)\n\n**数据范围**\n\n对于 $100\\%$ 的数据，有 $1\\le n\\le 300\\ 000;0\\le m\\le 900\\ 000;1\\le A,B\\le 10^9;0\\le x_i\\le A;0\\le y_i\\le B;1\\le c_i,d_i\\le n;k_i\\in \\{1,2\\}$。保证西侧的点至少有一个，保证每一个无序对 $\\{c_i,d_i\\}$ 只会出现一次。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2011] Traffic", "background": "", "description": "There are $n$ points on the Cartesian plane. The coordinates of the $i$-th point are $(x_i,y_i)$. All points lie inside a rectangle with opposite vertices $(0,0)$ and $(A,B)$.\n\nIf $x_i=0$, we say this point is on the west side. If $x_i=A$, we say this point is on the east side.\n\nThere are $m$ edges among these points. Each edge may be directed or undirected. It is guaranteed that edges do not intersect anywhere except at the given $n$ points.\n\nNow, for each point on the west side, compute how many points on the east side can be reached by following the edges.", "inputFormat": "The first line contains four integers $n,m,A,B$, separated by spaces.\n\nThe next $n$ lines each contain two integers $x_i,y_i$, separated by spaces.\n\nThe next $m$ lines each contain three integers $c_i,d_i,k_i$, separated by spaces, describing an edge between $c_i$ and $d_i$. If $k_i=1$, the edge is directed from $c_i$ to $d_i$; otherwise, the edge is undirected.", "outputFormat": "Output several lines, each containing one integer, representing the answer. Output the answers for all west-side points in decreasing order of $y$.", "hint": "**Explanation for Sample $2$**\n\n![0](https://i.loli.net/2018/04/18/5ad725326df6f.png)\n\n**Constraints**\n\nFor $100\\%$ of the testdata: $1\\le n\\le 300\\ 000;0\\le m\\le 900\\ 000;1\\le A,B\\le 10^9;0\\le x_i\\le A;0\\le y_i\\le B;1\\le c_i,d_i\\le n;k_i\\in \\{1,2\\}$. It is guaranteed that there is at least one west-side point, and that each unordered pair $\\{c_i,d_i\\}$ appears at most once.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2011] Traffic", "background": null, "description": "在平面直角坐标系上有 $n$ 个点，其中第 $i$ 个点的坐标是 $(x_i,y_i)$ ，所有点在一个以 $(0,0)$ 和 $(A,B)$ 为相对顶点的矩形内。\n\n如果 $x_i=0$ ，那么我们称这个点在西侧。如果 $x_i=A$ ，那么我们称这个点在东侧。\n\n这些点之间有 $m$ 条边，每条边可能是有向边也可能是无向边，保证边在给定的 $n$ 个点以外的任何地方不相交。\n\n现在请你求出，对于每一个西侧的点，能够沿着边到达多少东侧的点。", "inputFormat": "第一行四个空格隔开的数 $n,m,A,B$ 。\n\n接下来 $n$ 行，每行两个空格隔开的数 $x_i,y_i$ 。\n\n接下来 $m$ 行，每行三个空格隔开的数 $c_i,d_i,k_i$​​ ，表示一条 $c_i$​​ 和 $d_i$ 之间的边。如果 $k_i=1$ ，那么表示这条边是有向边，方向为 $c_i$​​ 指向 $d_i$​​ ，否则这条边是无向边。", "outputFormat": "输出有若干行，每行一个数表示答案。请按照 $y$ 从大到小的顺序输出所有点对应的答案。", "hint": "**样例 $2$ 解释**\n\n![0](https://i.loli.net/2018/04/18/5ad725326df6f.png)\n\n**数据范围**\n\n对于 $100\\%$ 的数据，有 $1\\le n\\le 300\\ 000;0\\le m\\le 900\\ 000;1\\le A,B\\le 10^9;0\\le x_i\\le A;0\\le y_i\\le B;1\\le c_i,d_i\\le n;k_i\\in \\{1,2\\}$。保证西侧的点至少有一个，保证每一个无序对 $\\{c_i,d_i\\}$ 只会出现一次。", "locale": "zh-CN"}}}
{"pid": "P4701", "type": "P", "difficulty": 6, "samples": [["3 3 1\n5 5 5 5\n1 1\n0 1 1\n2 3 4\n2 3 4", "GG"], ["3 3 2\n5 5 5 1\n3 1\n3 3\n0 1 1\n2 3 4\n2 3 4", "6"], ["3 3 2\n1 5 5 5\n3 1\n3 3\n0 1 1\n2 3 4\n2 3 4", "6"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化", "树形 DP", "洛谷月赛"], "title": "粘骨牌", "background": "", "description": "一个 $n \\times m$ 的棋盘，除了某一个位置，其它所有位置都被 $1 \\times 2$ 的多米诺骨牌覆盖，所以一共有 $\\frac{nm - 1}{2}$ 个多米诺骨牌。\n\nAlice 可以进行任意多次移动，每次移动需要保证移动后多米诺骨牌不超出棋盘，且不能存在两个多米诺骨牌重叠。\n\n棋盘上有若干个特殊位置，一旦它们露出来，你就输了，所以你要避免 Alice 的移动使这些位置露出来。\n\n你可以选择固定任意多个多米诺骨牌，固定一个骨牌需要一定的代价，身为 Bob 的你希望用最少的代价，使得无论 Alice 怎么移动，那些特殊位置都不会露出来，求出这个最小代价。\n\n如果无论怎么固定，都不能满足，输出 \"GG\"。", "inputFormat": "第一行三个整数 $n, m, k(1 \\leq n, m \\leq 1001, 0 \\leq k \\leq n \\times m)$，分别表示棋盘的大小以及特殊位置的个数。保证 $n$ 和 $m$ 都是奇数。\n\n接下来一行 $\\frac{nm - 1}{2}$ 个数，第 $i$ 个数 $a_i(1 \\leq a_i \\leq 10^9)$表示固定第 $i$ 个骨牌需要的代价。\n\n接下来 $k$ 行，每行两个整数 $x, y(1 \\leq x \\leq n, 1 \\leq y \\leq m)$，表示$ (x, y)$ 是一个特殊位置。不保证这 $k$ 个特殊位置互不相同，如果有相同的，忽略后一个即可。\n\n接下来 $n$ 行，每行 $m$ 个数 $v_{i, j}(0 \\leq v_{i, j} \\leq \\frac{nm - 1}{2})$，表示棋盘的覆盖情况。如果 $v_{i,j} = 0$，表示该位置未被覆盖，否则表示这个位置被编号为 $v_{i, j}$ 的骨牌覆盖。", "outputFormat": "一行一个整数，表示答案。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Sticky Dominoes", "background": "", "description": "On an $n \\times m$ board, all cells except one are covered by $1 \\times 2$ dominoes, so there are $\\frac{nm - 1}{2}$ dominoes in total.\n\nAlice may make arbitrarily many moves. After each move, all dominoes must remain within the board, and no two dominoes may overlap.\n\nThere are several special cells on the board. Once any of them becomes exposed, you lose, so you must prevent Alice’s moves from exposing these cells.\n\nYou may choose to fix any number of dominoes in place. Fixing one domino costs a certain amount. As Bob, you want to pay the minimum total cost so that no matter how Alice moves, those special cells will never be exposed. Find this minimum cost.\n\nIf it is impossible no matter how you fix the dominoes, output \"GG\".", "inputFormat": "The first line contains three integers $n, m, k(1 \\leq n, m \\leq 1001, 0 \\leq k \\leq n \\times m)$, representing the size of the board and the number of special cells. It is guaranteed that $n$ and $m$ are both odd.\n\nThe next line contains $\\frac{nm - 1}{2}$ numbers. The $i$-th number $a_i(1 \\leq a_i \\leq 10^9)$ denotes the cost to fix the $i$-th domino.\n\nThe next $k$ lines each contain two integers $x, y(1 \\leq x \\leq n, 1 \\leq y \\leq m)$, indicating that $(x, y)$ is a special cell. The $k$ special cells are not guaranteed to be distinct; if duplicates occur, ignore any later occurrence.\n\nThe next $n$ lines each contain $m$ numbers $v_{i, j}(0 \\leq v_{i, j} \\leq \\frac{nm - 1}{2})$, describing the coverage of the board. If $v_{i, j} = 0$, that cell is uncovered; otherwise, it is covered by the domino numbered $v_{i, j}$.", "outputFormat": "Output a single line with the answer: either a single integer representing the minimum total cost, or GG if it is impossible.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "粘骨牌", "background": "", "description": "一个 $n \\times m$ 的棋盘，除了某一个位置，其它所有位置都被 $1 \\times 2$ 的多米诺骨牌覆盖，所以一共有 $\\frac{nm - 1}{2}$ 个多米诺骨牌。\n\nAlice 可以进行任意多次移动，每次移动需要保证移动后多米诺骨牌不超出棋盘，且不能存在两个多米诺骨牌重叠。\n\n棋盘上有若干个特殊位置，一旦它们露出来，你就输了，所以你要避免 Alice 的移动使这些位置露出来。\n\n你可以选择固定任意多个多米诺骨牌，固定一个骨牌需要一定的代价，身为 Bob 的你希望用最少的代价，使得无论 Alice 怎么移动，那些特殊位置都不会露出来，求出这个最小代价。\n\n如果无论怎么固定，都不能满足，输出 \"GG\"。", "inputFormat": "第一行三个整数 $n, m, k(1 \\leq n, m \\leq 1001, 0 \\leq k \\leq n \\times m)$，分别表示棋盘的大小以及特殊位置的个数。保证 $n$ 和 $m$ 都是奇数。\n\n接下来一行 $\\frac{nm - 1}{2}$ 个数，第 $i$ 个数 $a_i(1 \\leq a_i \\leq 10^9)$表示固定第 $i$ 个骨牌需要的代价。\n\n接下来 $k$ 行，每行两个整数 $x, y(1 \\leq x \\leq n, 1 \\leq y \\leq m)$，表示$ (x, y)$ 是一个特殊位置。不保证这 $k$ 个特殊位置互不相同，如果有相同的，忽略后一个即可。\n\n接下来 $n$ 行，每行 $m$ 个数 $v_{i, j}(0 \\leq v_{i, j} \\leq \\frac{nm - 1}{2})$，表示棋盘的覆盖情况。如果 $v_{i,j} = 0$，表示该位置未被覆盖，否则表示这个位置被编号为 $v_{i, j}$ 的骨牌覆盖。", "outputFormat": "一行一个整数，表示答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4702", "type": "P", "difficulty": 1, "samples": [["1\n1", "Alice"], ["1\n2", "Bob"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["博弈论", "O2优化", "进制", "前缀和", "位运算", "洛谷月赛"], "title": "取石子", "background": "", "description": "Alice 和 Bob 在玩游戏。\n\n他们有 $n$ 堆石子，第 $i$ 堆石子有 $a_i$ 个，保证初始时 $a_i \\leq a_{i + 1}(1 \\leq i < n)$。现在他们轮流对这些石子进行操作，每次操作人可以选择满足 $a_i > a_{i - 1}$（$a_0$ 视为 $0$）的一堆石子，并从中取走一个。谁最后不能取了谁输。Alice 先手，他们都使用最优策略，请判断最后谁会取得胜利。", "inputFormat": "第一行一个整数 $n(1 \\leq n \\leq 100)$，表示石子堆数。\n\n接下来一行 $n$ 个数，第 $i$ 个数为 $a_i(1 \\leq a_i \\leq 10^9)$，意义如上所述。", "outputFormat": "\"Alice\" 或 \"Bob\"，表示谁会赢。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Take Stones", "background": "", "description": "Alice and Bob are playing a game.\n\nThey have $n$ piles of stones, where the $i$-th pile has $a_i$ stones, and initially it is guaranteed that $a_i \\leq a_{i + 1}$ ($1 \\leq i < n$). They take turns operating on the piles. In each move, a player may choose a pile that satisfies $a_i > a_{i - 1}$ (with $a_0$ regarded as $0$) and remove one stone from it. The player who cannot make a move loses. Alice moves first, and they both play optimally. Determine who will win in the end.", "inputFormat": "The first line contains an integer $n (1 \\leq n \\leq 100)$, representing the number of piles.\n\nThe next line contains $n$ numbers, where the $i$-th number is $a_i (1 \\leq a_i \\leq 10^9)$, as defined above.", "outputFormat": "\"Alice\" or \"Bob\", indicating who will win.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "取石子", "background": "", "description": "Alice 和 Bob 在玩游戏。\n\n他们有 $n$ 堆石子，第 $i$ 堆石子有 $a_i$ 个，保证初始时 $a_i \\leq a_{i + 1}(1 \\leq i < n)$。现在他们轮流对这些石子进行操作，每次操作人可以选择满足 $a_i > a_{i - 1}$（$a_0$ 视为 $0$）的一堆石子，并从中取走一个。谁最后不能取了谁输。Alice 先手，他们都使用最优策略，请判断最后谁会取得胜利。", "inputFormat": "第一行一个整数 $n(1 \\leq n \\leq 100)$，表示石子堆数。\n\n接下来一行 $n$ 个数，第 $i$ 个数为 $a_i(1 \\leq a_i \\leq 10^9)$，意义如上所述。", "outputFormat": "\"Alice\" 或 \"Bob\"，表示谁会赢。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4703", "type": "P", "difficulty": 4, "samples": [["1 1\n0.000 0.000", "0.999 0.999"], ["1 2\n1.000 1.000", "GG"], ["2 2\n0.000 0.000\n2.000 2.000", "1.000 1.000"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["计算几何", "Special Judge", "O2优化", "枚举", "向量", "随机化", "洛谷月赛", "分类讨论"], "title": "偷上网", "background": "", "description": "Alice 和 Bob 生活在一个 $l \\times l$ 的正方形房子里，由于 Bob 最近沉迷隔膜，Alice 决定要限制 Bob 上网的频率。\n\nAlice 建造了 $n$ 个无线信号屏蔽器，第 $i$ 个位于 $(x_i, y_i)$，屏蔽范围为 $\\frac{l}{n}$。\n\nBob 网瘾发作按捺不住上网的冲动，找到了你，帮他找到一个位置 $(x, y)$，使得没有被 Alice 的无线信号屏蔽器覆盖。", "inputFormat": "第一行两个整数 $n, l(1 \\leq n \\leq 10, 1 \\leq l \\leq 10^5)$，分别表示无线信号屏蔽器的个数和房子的大小。\n\n接下来 $n$ 行，每行 $2$ 个数，分别是 $x_i, y_i(0 \\leq x_i, y_i \\leq l)$，意义如上所述。", "outputFormat": "如果可以找到，输出两个数 $x, y(0 \\leq x, y \\leq l)$，意义如上所述，如果有多组解，输出任意一组即可。如果你输出的解满足到任意一个屏蔽器的距离都不小于 $\\frac{l}{n} + 10^{-6}$，则视为正确。\n\n否则输出 \"GG\"。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Sneaking Online", "background": "# Description\n\nAlice and Bob live in an $l \\times l$ square house. Since Bob has recently become obsessed with \"ge mo\" (gémó), Alice decides to limit how often Bob can go online.\n\nAlice has built $n$ wireless signal jammers. The $i$-th jammer is located at $(x_i, y_i)$, with a blocking radius of $\\frac{l}{n}$.\n\nBob’s internet addiction flares up and he can’t resist going online. He comes to you to find a position $(x, y)$ that is not covered by any of Alice’s wireless signal jammers.", "description": "", "inputFormat": "", "outputFormat": "If such a position exists, output two numbers $x$, $y$ ($0 \\le x, y \\le l$), as described above. If there are multiple answers, output any one of them. If your output has distance to every jammer at least $\\frac{l}{n} + 10^{-6}$, it will be considered correct.\n\nOtherwise, output \"GG\".", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "偷上网", "background": "", "description": "Alice 和 Bob 生活在一个 $l \\times l$ 的正方形房子里，由于 Bob 最近沉迷隔膜，Alice 决定要限制 Bob 上网的频率。\n\nAlice 建造了 $n$ 个无线信号屏蔽器，第 $i$ 个位于 $(x_i, y_i)$，屏蔽范围为 $\\frac{l}{n}$。\n\nBob 网瘾发作按捺不住上网的冲动，找到了你，帮他找到一个位置 $(x, y)$，使得没有被 Alice 的无线信号屏蔽器覆盖。", "inputFormat": "第一行两个整数 $n, l(1 \\leq n \\leq 10, 1 \\leq l \\leq 10^5)$，分别表示无线信号屏蔽器的个数和房子的大小。\n\n接下来 $n$ 行，每行 $2$ 个数，分别是 $x_i, y_i(0 \\leq x_i, y_i \\leq l)$，意义如上所述。", "outputFormat": "如果可以找到，输出两个数 $x, y(0 \\leq x, y \\leq l)$，意义如上所述，如果有多组解，输出任意一组即可。如果你输出的解满足到任意一个屏蔽器的距离都不小于 $\\frac{l}{n} + 10^{-6}$，则视为正确。\n\n否则输出 \"GG\"。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4704", "type": "P", "difficulty": 7, "samples": [["2\n1 2\n3 4", "1"], ["3\n1 2\n3 4\n5 6", "2"], ["3\n1 3\n2 4\n5 6", "1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["贪心", "O2优化", "位运算", "构造", "洛谷月赛"], "title": "太极剑", "background": "", "description": "在学习太极之后，Bob 要求 Alice 教他太极剑。Alice 告诉他首先需要通过一项基本剑术测试。测试要求 Bob 尽可能快地切断 $n$ 根绳子。\n\n所有绳子的端点两两不同，所以共有 $2n$ 个端点。这些端点被捆在一个圆上，等距离分布。我们把这些端点按顺时针方向编号为 $1$ 到 $2n$。\n\nBob 每次切割的轨迹是一条直线，可以将所有与这条直线相交的绳子切断，他想知道至少多少次可以切断所有的绳子。", "inputFormat": "第一行一个整数 $n(1 \\leq n \\leq 2 \\times 10^5)$，表示绳子的个数。\n\n接下来 $n$ 行，每行两个整数 $a_i, b_i(1 \\leq a_i, b_i \\leq 2n, a_i \\not= b_i)$，表示第 $i$ 根绳子的两个端点的编号。", "outputFormat": "一行一个整数，表示答案。", "hint": "样例一解释：![](https://cdn.luogu.com.cn/upload/pic/19179.png)\n\n样例二解释：![](https://cdn.luogu.com.cn/upload/pic/19180.png)\n\n样例三解释：![](https://cdn.luogu.com.cn/upload/pic/19181.png)", "locale": "zh-CN", "translations": {"en": {"title": "Taiji Sword", "background": "", "description": "After learning Taiji, Bob asks Alice to teach him the Taiji Sword. Alice tells him he must first pass a basic swordsmanship test. The test requires Bob to cut $n$ ropes as quickly as possible.\n\nAll rope endpoints are pairwise distinct, so there are $2n$ endpoints in total. These endpoints are tied on a circle, evenly spaced. We number these endpoints clockwise from $1$ to $2n$.\n\nEach of Bob’s cuts is a straight line, and it severs every rope that intersects this line. He wants to know the minimum number of cuts needed to cut all the ropes.", "inputFormat": "The first line contains an integer $n(1 \\leq n \\leq 2 \\times 10^5)$, representing the number of ropes.\n\nThe next $n$ lines each contain two integers $a_i, b_i(1 \\leq a_i, b_i \\leq 2n, a_i \\not= b_i)$, indicating the indices of the two endpoints of the $i$-th rope.", "outputFormat": "Output a single integer, the answer.", "hint": "Explanation for Sample 1: ![](https://cdn.luogu.com.cn/upload/pic/19179.png)\n\nExplanation for Sample 2: ![](https://cdn.luogu.com.cn/upload/pic/19180.png)\n\nExplanation for Sample 3: ![](https://cdn.luogu.com.cn/upload/pic/19181.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "太极剑", "background": "", "description": "在学习太极之后，Bob 要求 Alice 教他太极剑。Alice 告诉他首先需要通过一项基本剑术测试。测试要求 Bob 尽可能快地切断 $n$ 根绳子。\n\n所有绳子的端点两两不同，所以共有 $2n$ 个端点。这些端点被捆在一个圆上，等距离分布。我们把这些端点按顺时针方向编号为 $1$ 到 $2n$。\n\nBob 每次切割的轨迹是一条直线，可以将所有与这条直线相交的绳子切断，他想知道至少多少次可以切断所有的绳子。", "inputFormat": "第一行一个整数 $n(1 \\leq n \\leq 2 \\times 10^5)$，表示绳子的个数。\n\n接下来 $n$ 行，每行两个整数 $a_i, b_i(1 \\leq a_i, b_i \\leq 2n, a_i \\not= b_i)$，表示第 $i$ 根绳子的两个端点的编号。", "outputFormat": "一行一个整数，表示答案。", "hint": "样例一解释：![](https://cdn.luogu.com.cn/upload/pic/19179.png)\n\n样例二解释：![](https://cdn.luogu.com.cn/upload/pic/19180.png)\n\n样例三解释：![](https://cdn.luogu.com.cn/upload/pic/19181.png)", "locale": "zh-CN"}}}
{"pid": "P4705", "type": "P", "difficulty": 6, "samples": [["1 1\n1\n2\n3", "3\n9\n27"], ["2 8\n764074134 743107904\n663532060 183287581 749169979 7678045 393887277 27071620 13482818 125504606\n6", "774481679\n588343913\n758339354\n233707576\n36464684\n461784746"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "O2优化", "分治", "期望", "快速傅里叶变换 FFT", "洛谷月赛"], "title": "玩游戏", "background": "### 警告：恶意提交评测将被封号。", "description": "Alice 和 Bob 又在玩游戏。\n\n对于一次游戏，首先 Alice 获得一个长度为 $n$ 的序列 $a$，Bob 获得一个长度为 $m$ 的序列 $b$。之后他们各从自己的序列里随机取出一个数，分别设为 $a_x, b_y$，定义这次游戏的 $k$ 次价值为 $(a_x + b_y)^k$。\n\n由于他们发现这个游戏实在是太无聊了，所以想让你帮忙计算对于 $i = 1, 2, \\cdots, t$，一次游戏的 $i$ 次价值的期望是多少。\n\n由于答案可能很大，只需要求出模 $998244353$ 下的结果即可。", "inputFormat": "第一行两个整数 $n, m(1 \\leq n, m \\leq 10^5)$，分别表示 Alice 和 Bob 序列的长度。\n\n接下来一行 $n$ 个数，第 $i$ 个数为 $a_i(0 \\leq a_i < 998244353)$，表示 Alice 的序列。\n\n接下来一行 $m$ 个数，第 $j$ 个数为 $b_j(0 \\leq b_j < 998244353)$，表示 Bob 的序列。\n\n接下来一行一个整数 $t(1 \\leq t \\leq 10^5)$，意义如上所述。", "outputFormat": "共 $t$ 行，第 $i$ 行表示一次游戏 $i$ 次价值的期望。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Playing a Game", "background": "Warning: Malicious submissions will result in account bans.", "description": "Alice and Bob are playing a game again.\n\nIn one game, first Alice receives a sequence $a$ of length $n$, and Bob receives a sequence $b$ of length $m$. Then they each randomly pick one number from their own sequence, denoted $a_x, b_y$. The $k$-th value of this game is defined as $(a_x + b_y)^k$.\n\nBecause they find this game too boring, they ask you to compute, for $i = 1, 2, \\cdots, t$, the expected $i$-th value of a game.\n\nSince the answer can be large, you only need to output the result modulo $998244353$.", "inputFormat": "The first line contains two integers $n, m(1 \\leq n, m \\leq 10^5)$, representing the lengths of Alice’s and Bob’s sequences.\n\nThe next line contains $n$ numbers, where the $i$-th number is $a_i(0 \\leq a_i < 998244353)$, representing Alice’s sequence.\n\nThe next line contains $m$ numbers, where the $j$-th number is $b_j(0 \\leq b_j < 998244353)$, representing Bob’s sequence.\n\nThe next line contains one integer $t(1 \\leq t \\leq 10^5)$, as described above.", "outputFormat": "Output $t$ lines, where the $i$-th line is the expected $i$-th value of a single game.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "玩游戏", "background": "### 警告：恶意提交评测将被封号。", "description": "Alice 和 Bob 又在玩游戏。\n\n对于一次游戏，首先 Alice 获得一个长度为 $n$ 的序列 $a$，Bob 获得一个长度为 $m$ 的序列 $b$。之后他们各从自己的序列里随机取出一个数，分别设为 $a_x, b_y$，定义这次游戏的 $k$ 次价值为 $(a_x + b_y)^k$。\n\n由于他们发现这个游戏实在是太无聊了，所以想让你帮忙计算对于 $i = 1, 2, \\cdots, t$，一次游戏的 $i$ 次价值的期望是多少。\n\n由于答案可能很大，只需要求出模 $998244353$ 下的结果即可。", "inputFormat": "第一行两个整数 $n, m(1 \\leq n, m \\leq 10^5)$，分别表示 Alice 和 Bob 序列的长度。\n\n接下来一行 $n$ 个数，第 $i$ 个数为 $a_i(0 \\leq a_i < 998244353)$，表示 Alice 的序列。\n\n接下来一行 $m$ 个数，第 $j$ 个数为 $b_j(0 \\leq b_j < 998244353)$，表示 Bob 的序列。\n\n接下来一行一个整数 $t(1 \\leq t \\leq 10^5)$，意义如上所述。", "outputFormat": "共 $t$ 行，第 $i$ 行表示一次游戏 $i$ 次价值的期望。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4706", "type": "P", "difficulty": 6, "samples": [["3\n3 1 2", "332748118"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["枚举", "素数判断,质数,筛法", "概率论"], "title": "取石子", "background": "", "description": "现在 Yopilla 和 yww 要开始玩游戏！\n\n他们在一条直线上标记了 $n$ 个点，从左往右依次标号为 $1, 2, ..., n$ 。然后在每个点上放置一些棋子，其中第 $i$ 个点放置了 $a_i$ 个棋子。接下来，从 Yopilla 开始操作，双方轮流操作，谁不能操作谁输。每次的操作是：当前操作方选定一个有棋子的点 $x$ ，然后选择至少一个点 $x$ 上的棋子，然后把这些棋子全都移动到点 $x / prime$ 上，其中 $prime$ 是一个质数，且 $prime \\mid x$ 。\n\nYopilla 最初一次操作的策略是随机的：随机找到一个有棋子的点 $x$ ，随机选择正整数个棋子 $y$ ，随机转移到一个能转移到的点 $z$ 。所有棋子可以看作是一样的，换句话说：两种操作不同，当且仅当三元组 $(x, y, z)$ 不同。之后双方都按照最优策略来操作。\n\nYopilla 想要预测，他能够获胜的概率是多少，答案对 $998244353$ 取模。", "inputFormat": "第一行一个数 $n$ 。\n\n第二行 $n$ 个数 $a_1, a_2, ..., a_n$ 。", "outputFormat": "输出 $m$ 行，表示 Yopilla 能够获胜的概率对 $998244353$ 取模。", "hint": "样例解释：\n\n$1$ 号点有 $3$ 个棋子，$2$ 号点有 $1$ 个棋子，$3$ 号点有 $2$ 个棋子。第一次操作的时候，能进行的有三种可能：将 $2$ 号点的 $1$ 个棋子移到 $1$ 号点，将 $3$ 号点的 $1$ 个棋子移到 $1$ 号点，将 $3$ 号点的 $2$ 个棋子移到一号点。而其中只有一种情况能使得 Yopilla 有必胜策略。所以答案为\n$$\\frac{1}{3} \\equiv 332748118 \\pmod {998244353}$$\n\n对于 $20 \\%$ 的数据，只有一个石子。\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le {10} ^ 6, 0 \\le a_i \\le {10} ^ 9$ ，保证至少有一个不在一号点的石子。", "locale": "zh-CN", "translations": {"en": {"title": "Taking Stones", "background": "", "description": "Now Yopilla and yww are going to play a game.\n\nThey mark $n$ points on a straight line, numbered from left to right as $1, 2, ..., n$. Then they place some stones on each point: point $i$ has $a_i$ stones. Next, starting from Yopilla, the two players take turns. Whoever cannot make a move loses. Each move is:\n\nThe current player chooses a point $x$ that has stones, then chooses at least one stone from point $x$, and moves all chosen stones to point $x / prime$, where $prime$ is a prime number and $prime \\mid x$.\n\nYopilla's strategy for the very first move is random: he randomly picks a point $x$ that has stones, randomly chooses a positive integer number of stones $y$, and randomly moves them to a reachable point $z$. All stones are considered identical. In other words, two moves are different if and only if the triple $(x, y, z)$ is different. After that, both players play with optimal strategies.\n\nYopilla wants to predict the probability that he can win. Output the answer modulo $998244353$.", "inputFormat": "The first line contains one integer $n$.\n\nThe second line contains $n$ integers $a_1, a_2, ..., a_n$.", "outputFormat": "Output one line, representing the probability that Yopilla can win modulo $998244353$.", "hint": "Explanation of the sample:\n\nPoint $1$ has $3$ stones, point $2$ has $1$ stone, and point $3$ has $2$ stones. On the first move, there are three possible moves: move the $1$ stone at point $2$ to point $1$; move $1$ stone at point $3$ to point $1$; move $2$ stones at point $3$ to point $1$. Among these, only one case allows Yopilla to have a winning strategy. So the answer is\n$$\\frac{1}{3} \\equiv 332748118 \\pmod {998244353}$$\n\nFor $20\\%$ of the testdata, there is only one stone.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le {10} ^ 6$, $0 \\le a_i \\le {10} ^ 9$. It is guaranteed that there is at least one stone not at point $1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "取石子", "background": "", "description": "现在 Yopilla 和 yww 要开始玩游戏！\n\n他们在一条直线上标记了 $n$ 个点，从左往右依次标号为 $1, 2, ..., n$ 。然后在每个点上放置一些棋子，其中第 $i$ 个点放置了 $a_i$ 个棋子。接下来，从 Yopilla 开始操作，双方轮流操作，谁不能操作谁输。每次的操作是：当前操作方选定一个有棋子的点 $x$ ，然后选择至少一个点 $x$ 上的棋子，然后把这些棋子全都移动到点 $x / prime$ 上，其中 $prime$ 是一个质数，且 $prime \\mid x$ 。\n\nYopilla 最初一次操作的策略是随机的：随机找到一个有棋子的点 $x$ ，随机选择正整数个棋子 $y$ ，随机转移到一个能转移到的点 $z$ 。所有棋子可以看作是一样的，换句话说：两种操作不同，当且仅当三元组 $(x, y, z)$ 不同。之后双方都按照最优策略来操作。\n\nYopilla 想要预测，他能够获胜的概率是多少，答案对 $998244353$ 取模。", "inputFormat": "第一行一个数 $n$ 。\n\n第二行 $n$ 个数 $a_1, a_2, ..., a_n$ 。", "outputFormat": "输出 $m$ 行，表示 Yopilla 能够获胜的概率对 $998244353$ 取模。", "hint": "样例解释：\n\n$1$ 号点有 $3$ 个棋子，$2$ 号点有 $1$ 个棋子，$3$ 号点有 $2$ 个棋子。第一次操作的时候，能进行的有三种可能：将 $2$ 号点的 $1$ 个棋子移到 $1$ 号点，将 $3$ 号点的 $1$ 个棋子移到 $1$ 号点，将 $3$ 号点的 $2$ 个棋子移到一号点。而其中只有一种情况能使得 Yopilla 有必胜策略。所以答案为\n$$\\frac{1}{3} \\equiv 332748118 \\pmod {998244353}$$\n\n对于 $20 \\%$ 的数据，只有一个石子。\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le {10} ^ 6, 0 \\le a_i \\le {10} ^ 9$ ，保证至少有一个不在一号点的石子。", "locale": "zh-CN"}}}
{"pid": "P4707", "type": "P", "difficulty": 7, "samples": [["3 3 3\n1 1 1\n", "499122182\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "数学", "容斥原理", "期望"], "title": "重返现世", "background": "", "description": "为了打开返回现世的大门，Yopilla 需要制作开启大门的钥匙。Yopilla 所在的迷失大陆有 $n$ 种原料，只需要集齐任意 $k$ 种，就可以开始制作。\n\nYopilla 来到了迷失大陆的核心地域。每个单位时间，这片地域就会随机生成一种原料。每种原料被生成的概率是不同的，第 $i$ 种原料被生成的概率是 $\\frac{p_i}{m}$ 。如果 Yopilla 没有这种原料，那么就可以进行收集。\n\nYopilla 急于知道，他收集到任意 $k$ 种原料的期望时间，答案对 $998244353$ 取模。", "inputFormat": "第一行三个数 $n, k, m$ 。\n\n第二行 $n$ 个数 $p_1, p_2, ..., p_n$ 。", "outputFormat": "输出一行。", "hint": "对于 $10 \\%$ 的数据，$p_1 = p_2 = ... = p_m$ 。\n\n对于另外 $10 \\%$ 的数据，$k = n$ 。\n\n对于 $70 \\%$ 的数据，$n \\le 100$ 。\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le 1000$ ，$1 \\le k \\le n,  n - k  \\le 10$ ，$1 \\le p_i \\le m, \\sum p = m, 1 \\le m \\le 10000$ 。", "locale": "zh-CN", "translations": {"en": {"title": "Return to the Real World", "background": "", "description": "To open the gate back to the real world, Yopilla needs to craft the key that unlocks it. On the Lost Continent where Yopilla is, there are $n$ kinds of materials. As long as he gathers any $k$ kinds, he can start crafting.\n\nYopilla arrives at the core area of the Lost Continent. In each unit of time, this area will randomly generate one kind of material. The probability of generating the $i$-th kind of material is $\\frac{p_i}{m}$. If Yopilla does not have this material, then he can collect it.\n\nYopilla urgently wants to know the expected time for him to collect any $k$ kinds of materials. Output the answer modulo $998244353$.", "inputFormat": "The first line contains three integers $n, k, m$.\n\nThe second line contains $n$ integers $p_1, p_2, ..., p_n$.", "outputFormat": "Output one line.", "hint": "For $10\\%$ of the testdata, $p_1 = p_2 = ... = p_m$.\n\nFor another $10\\%$ of the testdata, $k = n$.\n\nFor $70\\%$ of the testdata, $n \\le 100$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 1000$, $1 \\le k \\le n$, $n - k \\le 10$, $1 \\le p_i \\le m$, $\\sum p = m$, $1 \\le m \\le 10000$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "重返现世", "background": "", "description": "为了打开返回现世的大门，Yopilla 需要制作开启大门的钥匙。Yopilla 所在的迷失大陆有 $n$ 种原料，只需要集齐任意 $k$ 种，就可以开始制作。\n\nYopilla 来到了迷失大陆的核心地域。每个单位时间，这片地域就会随机生成一种原料。每种原料被生成的概率是不同的，第 $i$ 种原料被生成的概率是 $\\frac{p_i}{m}$ 。如果 Yopilla 没有这种原料，那么就可以进行收集。\n\nYopilla 急于知道，他收集到任意 $k$ 种原料的期望时间，答案对 $998244353$ 取模。", "inputFormat": "第一行三个数 $n, k, m$ 。\n\n第二行 $n$ 个数 $p_1, p_2, ..., p_n$ 。", "outputFormat": "输出一行。", "hint": "对于 $10 \\%$ 的数据，$p_1 = p_2 = ... = p_m$ 。\n\n对于另外 $10 \\%$ 的数据，$k = n$ 。\n\n对于 $70 \\%$ 的数据，$n \\le 100$ 。\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le 1000$ ，$1 \\le k \\le n,  n - k  \\le 10$ ，$1 \\le p_i \\le m, \\sum p = m, 1 \\le m \\le 10000$ 。", "locale": "zh-CN"}}}
{"pid": "P4708", "type": "P", "difficulty": 7, "samples": [["4", "3"], ["5", "7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["欧拉回路", "置换", "Pólya 定理"], "title": "画画", "background": null, "description": "yww 要开始画画了！\n\n地上有一张纸，纸上有 $n$ 个点。\n\nyww 要在结点之间连边。yww 的连边是非常有规律的。每次他会拿好笔，选定一个点，从这个点 $x$ 向其他点 $y$ 连边，再从 $y$ 向其他点 $z$ 连边，依次类推，直到连回点 $x$。yww 会进行若干次这样的连边。并且，自始至终，yww 都不会在两个结点之间连超过一条边。\n\nyww 想知道，他一共能画出多少种本质不同的图。两个图本质相同，当且仅当存在一个点到点的置换，使得对于原图和在置换作用下的新图，任意两点之间要么都没有连边，要么都有连边。你只需要将答案对 $998244353$ 取模。\n\n一句话题意，$n$ 个点的无标号的每个连通块有欧拉回路的图的个数。", "inputFormat": "第一行一个数 $n$。", "outputFormat": "输出一个数。", "hint": "对于 $10 \\%$ 的数据，$n \\le 5$。\n\n对于 $40 \\%$ 的数据，$n \\le 10$。\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "Drawing", "background": "", "description": "yww is going to start drawing.\n\nThere is a sheet of paper on the ground, and there are $n$ points on it.\n\nyww wants to draw edges between the points. His way of drawing edges is very regular. Each time, he will hold the pen, choose a point, and draw an edge from this point $x$ to another point $y$, then draw an edge from $y$ to another point $z$, and so on, until he finally returns to point $x$. yww will do this process several times. Also, from start to finish, yww will never draw more than one edge between the same two points.\n\nyww wants to know how many essentially different graphs he can draw in total. Two graphs are essentially the same if and only if there exists a permutation of the points such that, for the original graph and the new graph after applying the permutation, for any two points, either both graphs have no edge between them, or both graphs have an edge between them. You only need to output the answer modulo $998244353$.\n\nIn one sentence: the number of unlabeled graphs on $n$ vertices such that every connected component has an Euler circuit.", "inputFormat": "The first line contains an integer $n$.", "outputFormat": "Output one integer.", "hint": "For $10\\%$ of the testdata, $n \\le 5$.\n\nFor $40\\%$ of the testdata, $n \\le 10$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "画画", "background": null, "description": "yww 要开始画画了！\n\n地上有一张纸，纸上有 $n$ 个点。\n\nyww 要在结点之间连边。yww 的连边是非常有规律的。每次他会拿好笔，选定一个点，从这个点 $x$ 向其他点 $y$ 连边，再从 $y$ 向其他点 $z$ 连边，依次类推，直到连回点 $x$。yww 会进行若干次这样的连边。并且，自始至终，yww 都不会在两个结点之间连超过一条边。\n\nyww 想知道，他一共能画出多少种本质不同的图。两个图本质相同，当且仅当存在一个点到点的置换，使得对于原图和在置换作用下的新图，任意两点之间要么都没有连边，要么都有连边。你只需要将答案对 $998244353$ 取模。\n\n一句话题意，$n$ 个点的无标号的每个连通块有欧拉回路的图的个数。", "inputFormat": "第一行一个数 $n$。", "outputFormat": "输出一个数。", "hint": "对于 $10 \\%$ 的数据，$n \\le 5$。\n\n对于 $40 \\%$ 的数据，$n \\le 10$。\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le 50$。", "locale": "zh-CN"}}}
{"pid": "P4709", "type": "P", "difficulty": 7, "samples": [["3\n2 1 3", "1"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "信息传递", "background": "", "description": "给定置换\n$$\nf = \\begin{pmatrix} 1 & 2 & ... & n \\\\\\ a_1 & a_2 & ... & a_n \\end{pmatrix}\n$$\n求有多少个置换 $g$ ，满足\n$$\ng ^ n = f\n$$\n答案对 $998244353$ 取模。", "inputFormat": "第一行一个数 $n$ 。\n\n第二行 $n$ 个数 $a_1, a_2, ..., a_n$ 。", "outputFormat": "输出答案。", "hint": "样例解释：\n\n有且仅有 $a_1 = 2, a_2 = 1, a_3 = 3$ 满足\n$$\n{\\begin{pmatrix} 1 & 2 & 3 \\\\ 2 & 1 & 3 \\end{pmatrix}} ^ 3 = \\begin{pmatrix} 1 & 2 & 3 \\\\ 2 & 1 & 3 \\end{pmatrix}\n$$\n\n对于 $20 \\%$ 的数据，$n \\le 10$。\n\n对于 $60 \\%$ 的数据，$n \\le 1000$。\n\n对于 $100 \\%$ 的数据，$n \\le {10} ^ 5$。", "locale": "zh-CN", "translations": {"en": {"title": "Information Transmission", "background": "", "description": "Given a permutation\n$$\nf = \\begin{pmatrix} 1 & 2 & ... & n \\\\\\ a_1 & a_2 & ... & a_n \\end{pmatrix}\n$$\nfind how many permutations $g$ satisfy\n$$\ng ^ n = f\n$$\nOutput the answer modulo $998244353$.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n$ integers $a_1, a_2, ..., a_n$.", "outputFormat": "Output the answer.", "hint": "Sample explanation:\n\nThere is only one permutation with $a_1 = 2, a_2 = 1, a_3 = 3$ that satisfies\n$$\n{\\begin{pmatrix} 1 & 2 & 3 \\\\ 2 & 1 & 3 \\end{pmatrix}} ^ 3 = \\begin{pmatrix} 1 & 2 & 3 \\\\ 2 & 1 & 3 \\end{pmatrix}\n$$\n\nConstraints:\n\nFor $20\\%$ of the testdata, $n \\le 10$.\n\nFor $60\\%$ of the testdata, $n \\le 1000$.\n\nFor $100\\%$ of the testdata, $n \\le {10} ^ 5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "信息传递", "background": "", "description": "给定置换\n$$\nf = \\begin{pmatrix} 1 & 2 & ... & n \\\\\\ a_1 & a_2 & ... & a_n \\end{pmatrix}\n$$\n求有多少个置换 $g$ ，满足\n$$\ng ^ n = f\n$$\n答案对 $998244353$ 取模。", "inputFormat": "第一行一个数 $n$ 。\n\n第二行 $n$ 个数 $a_1, a_2, ..., a_n$ 。", "outputFormat": "输出答案。", "hint": "样例解释：\n\n有且仅有 $a_1 = 2, a_2 = 1, a_3 = 3$ 满足\n$$\n{\\begin{pmatrix} 1 & 2 & 3 \\\\ 2 & 1 & 3 \\end{pmatrix}} ^ 3 = \\begin{pmatrix} 1 & 2 & 3 \\\\ 2 & 1 & 3 \\end{pmatrix}\n$$\n\n对于 $20 \\%$ 的数据，$n \\le 10$。\n\n对于 $60 \\%$ 的数据，$n \\le 1000$。\n\n对于 $100 \\%$ 的数据，$n \\le {10} ^ 5$。", "locale": "zh-CN"}}}
{"pid": "P4710", "type": "P", "difficulty": 2, "samples": [["14.142136 0.785398", "10 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "Special Judge", "O2优化", "洛谷月赛"], "title": "「物理」平抛运动", "background": "", "description": "> 小 F 回到班上，面对自己 28 / 110 的物理，感觉非常凉凉。他准备从最基础的力学学起。\n\n如图，一个可以视为质点的小球在点 $A(x_0, y_0)$ 沿 $x$ 轴负方向以某速度抛出，无视除重力外的所有阻力，最后恰好以速度 $v$ 砸到 $B(0, 0)$ 点。\n\n![A1](https://cdn.luogu.com.cn/upload/pic/17884.png)\n\n给定 $v$ 的大小与方向，你的任务是求出 $(x_0,y_0)$。\n\n给定的速度单位为 $m \\cdot s ^ {-1}$，重力加速度 $g = 10 \\ (m \\cdot s ^ {-2})$，请输出以 $m$ 为单位的答案。\n\n如果你没有学过相关内容也没有关系，你可以从样例和提示里理解该题所求内容。", "inputFormat": "输入一行，为两个最多 $6$ 位的小数 $v, \\theta(1 \\leq v \\leq 100, 15 ^ \\circ \\leq \\theta \\leq 75 ^ \\circ )$，即速度与图中所标角在弧度制下的大小。", "outputFormat": "输出一行，两个最多 $15$ 位的小数 $x_0, y_0$，为你的答案。\n\n你的答案与参考答案的相对误差或者绝对误差小于 $10 ^ {-3}$ 即视为正确。", "hint": "### 样例解释\n\n如图。\n\n![A2](https://cdn.luogu.com.cn/upload/pic/17887.png )\n\n$14.142136 \\approx 10 \\sqrt 2, 0.785398 \\approx \\frac \\pi 4 = 45 ^ \\circ .$\n\n小球从 $(10, 5)$ 以速度 $(-10, 0)$ 抛出，即可在 $t = 1s$ 时以 $(-10, -10)$ 砸在 $(0, 0)$。\n\n### 提示\n\n如果你没有学习过相关内容，下面的内容可能有帮助：\n\n> zcy 教你学物理\n\n首先，由于单位均为标准单位，所以所有结果均可以直接数字运算；视为质点意味着没有体积。\n\n我们可以将小球速度分解，如图：\n\n![A3](https://cdn.luogu.com.cn/upload/pic/17886.png )\n\n其中水平方向上的速度 $v_x$ 即为抛出速度，运动过程中一直为 $v \\sin \\theta$；\n\n垂直方向上的速度 $v_y$ 受重力加速，由 $0$ 变化至 $v \\cos \\theta$。\n\n从抛出时开始计时，当时间为 $t$ 时，设此时水平、垂直方向上速度的大小分别为 $v_{xt}, v_{yt}$，水平、垂直方向上位移的大小分别为 $x_{xt}, x_{yt}$，有：\n\n$v_{xt} = v \\sin \\theta$\n\n$v_{yt} = gt$\n\n$x_{xt} = v_{xt}t$\n\n$x_{yt} = \\frac 1 2 g t ^ 2 = \\frac 1 2{v_{yt}t}$\n\n当 $t$ 恰好是落地时间时，$x_{xt}, x_{yt}$ 即为答案。\n\n---\n\n关于弧度制：\n\n$\\pi = 180 ^{\\circ}$\n\n也就是说：$\\frac \\pi 2 = 90 ^{\\circ}, \\frac \\pi 3 = 60 ^{\\circ}, \\ \\cdots $\n\n---\n\n关于三角函数：\n\n如果你是 C/C++ 选手，你可以使用 `math.h` /  `cmath` 里的 `sin()` `cos()` 进行计算；\n\n如果你是 Pascal 选手，你可以使用 `math` 库（在 `begin` 前添加 `uses math;`）里的 `sin()` `cos()` 进行计算。\n \n如果你是 Python 选手，你可以使用 `math` 库里的 `math.sin()` `math.cos()` 进行计算。\n\n如果你是其他语言的选手，请参考相应文档。\n", "locale": "zh-CN", "translations": {"en": {"title": "“Physics” Horizontal Projectile Motion", "background": "# Description\n\n> After returning to class and seeing his 28/110 in physics, little F felt utterly defeated. He decides to start learning mechanics from the very basics.\n\nAs shown in the figure, a small ball that can be treated as a point mass is thrown from point $A(x_0, y_0)$ along the negative direction of the $x$-axis with some speed, ignoring all resistance except gravity, and finally hits point $B(0, 0)$ exactly with speed $v$.\n\n![A1](https://cdn.luogu.com.cn/upload/pic/17884.png)\n\nGiven the magnitude and direction of $v$, your task is to find $(x_0, y_0)$.\n\nThe unit of the given speed is $m \\cdot s ^ {-1}$, and the gravitational acceleration is $g = 10 \\ (m \\cdot s ^ {-2})$. Please output the answer in meters.\n\nIf you have not learned the related content, it is okay; you can understand what is required from the samples and the hints.", "description": "", "inputFormat": "", "outputFormat": "Output one line with two real numbers $x_0, y_0$ (each with at most $15$ decimal places), which are your answers.\n\nYour answer is considered correct if the absolute or relative error is less than $10 ^ {-3}$.", "hint": "### Sample Explanation\n\nAs shown.\n\n![A2](https://cdn.luogu.com.cn/upload/pic/17887.png )\n\n$14.142136 \\approx 10 \\sqrt 2, 0.785398 \\approx \\frac \\pi 4 = 45 ^ \\circ.$\n\nIf the ball is thrown from $(10, 5)$ with velocity $(-10, 0)$, then at $t = 1 s$ it hits $(0, 0)$ with velocity $(-10, -10)$.\n\n### Hint\n\nIf you have not studied the related content, the following may help:\n\n> zcy teaches you physics\n\nFirst, since all units are standard, all results can be computed directly with numbers; treating the object as a point mass means it has no volume.\n\nWe can decompose the velocity of the ball as shown:\n\n![A3](https://cdn.luogu.com.cn/upload/pic/17886.png )\n\nThe horizontal component of the velocity $v_x$ is the initial throw speed and remains $v \\sin \\theta$ during the motion.\n\nThe vertical component of the velocity $v_y$ is accelerated by gravity, changing from $0$ to $v \\cos \\theta$.\n\nStarting timing from the moment of release, when the time is $t$, let the magnitudes of the horizontal and vertical velocities at this moment be $v_{xt}, v_{yt}$, and the magnitudes of the horizontal and vertical displacements be $x_{xt}, x_{yt}$, respectively. Then:\n\n$v_{xt} = v \\sin \\theta$\n\n$v_{yt} = gt$\n\n$x_{xt} = v_{xt}t$\n\n$x_{yt} = \\frac 1 2 g t ^ 2 = \\frac 1 2{v_{yt}t}$\n\nWhen $t$ is exactly the landing time, $x_{xt}, x_{yt}$ are the answers.\n\n---\n\nAbout radians:\n\n$\\pi = 180 ^{\\circ}$\n\nThat is: $\\frac \\pi 2 = 90 ^{\\circ}, \\frac \\pi 3 = 60 ^{\\circ}, \\ \\cdots $\n\n---\n\nAbout trigonometric functions:\n\nIf you use C/C++, you can use `sin()` and `cos()` from `math.h` / `cmath`.\n\nIf you use Pascal, you can use `sin()` and `cos()` from the `math` library (add `uses math;` before `begin`).\n\nIf you use Python, you can use `math.sin()` and `math.cos()` from the `math` library.\n\nIf you use other languages, please refer to the corresponding documentation.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「物理」平抛运动", "background": "", "description": "> 小 F 回到班上，面对自己 28 / 110 的物理，感觉非常凉凉。他准备从最基础的力学学起。\n\n如图，一个可以视为质点的小球在点 $A(x_0, y_0)$ 沿 $x$ 轴负方向以某速度抛出，无视除重力外的所有阻力，最后恰好以速度 $v$ 砸到 $B(0, 0)$ 点。\n\n![A1](https://cdn.luogu.com.cn/upload/pic/17884.png)\n\n给定 $v$ 的大小与方向，你的任务是求出 $(x_0,y_0)$。\n\n给定的速度单位为 $m \\cdot s ^ {-1}$，重力加速度 $g = 10 \\ (m \\cdot s ^ {-2})$，请输出以 $m$ 为单位的答案。\n\n如果你没有学过相关内容也没有关系，你可以从样例和提示里理解该题所求内容。", "inputFormat": "输入一行，为两个最多 $6$ 位的小数 $v, \\theta(1 \\leq v \\leq 100, 15 ^ \\circ \\leq \\theta \\leq 75 ^ \\circ )$，即速度与图中所标角在弧度制下的大小。", "outputFormat": "输出一行，两个最多 $15$ 位的小数 $x_0, y_0$，为你的答案。\n\n你的答案与参考答案的相对误差或者绝对误差小于 $10 ^ {-3}$ 即视为正确。", "hint": "### 样例解释\n\n如图。\n\n![A2](https://cdn.luogu.com.cn/upload/pic/17887.png )\n\n$14.142136 \\approx 10 \\sqrt 2, 0.785398 \\approx \\frac \\pi 4 = 45 ^ \\circ .$\n\n小球从 $(10, 5)$ 以速度 $(-10, 0)$ 抛出，即可在 $t = 1s$ 时以 $(-10, -10)$ 砸在 $(0, 0)$。\n\n### 提示\n\n如果你没有学习过相关内容，下面的内容可能有帮助：\n\n> zcy 教你学物理\n\n首先，由于单位均为标准单位，所以所有结果均可以直接数字运算；视为质点意味着没有体积。\n\n我们可以将小球速度分解，如图：\n\n![A3](https://cdn.luogu.com.cn/upload/pic/17886.png )\n\n其中水平方向上的速度 $v_x$ 即为抛出速度，运动过程中一直为 $v \\sin \\theta$；\n\n垂直方向上的速度 $v_y$ 受重力加速，由 $0$ 变化至 $v \\cos \\theta$。\n\n从抛出时开始计时，当时间为 $t$ 时，设此时水平、垂直方向上速度的大小分别为 $v_{xt}, v_{yt}$，水平、垂直方向上位移的大小分别为 $x_{xt}, x_{yt}$，有：\n\n$v_{xt} = v \\sin \\theta$\n\n$v_{yt} = gt$\n\n$x_{xt} = v_{xt}t$\n\n$x_{yt} = \\frac 1 2 g t ^ 2 = \\frac 1 2{v_{yt}t}$\n\n当 $t$ 恰好是落地时间时，$x_{xt}, x_{yt}$ 即为答案。\n\n---\n\n关于弧度制：\n\n$\\pi = 180 ^{\\circ}$\n\n也就是说：$\\frac \\pi 2 = 90 ^{\\circ}, \\frac \\pi 3 = 60 ^{\\circ}, \\ \\cdots $\n\n---\n\n关于三角函数：\n\n如果你是 C/C++ 选手，你可以使用 `math.h` /  `cmath` 里的 `sin()` `cos()` 进行计算；\n\n如果你是 Pascal 选手，你可以使用 `math` 库（在 `begin` 前添加 `uses math;`）里的 `sin()` `cos()` 进行计算。\n \n如果你是 Python 选手，你可以使用 `math` 库里的 `math.sin()` `math.cos()` 进行计算。\n\n如果你是其他语言的选手，请参考相应文档。\n", "locale": "zh-CN"}}}
{"pid": "P4711", "type": "P", "difficulty": 4, "samples": [["Au", "197"], ["HfO_{2}", "210.5"], ["Ca(OH)_{2}", "74"], ["CuSO_{4}~5H_{2}O", "250"], ["KAl(SO_{4})_{2}~12H_{2}O", "474"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "递归", "Special Judge", "O2优化", "洛谷月赛"], "title": "「化学」相对分子质量", "background": null, "description": "做化学题时，小 F 总是里算错相对分子质量，这让他非常苦恼。\n\n小 F 找到了你，请你来帮他算一算给定物质的相对分子质量。\n\n如果你没有学过相关内容也没有关系，你可以从样例和提示里理解该题所求内容。", "inputFormat": "输入一行，为一个长度为 $L$ $(L\\leq 100)$ 的不含空格的字符串，表示给定物质的化学式。\n\n化学式仅包括以下内容:\n\n* 元素：如 `Au`(金)，`Hf`(铪)，**出现的所有元素及其相对原子质量以附表为准**。\n* 下标 `_{}` ：表示某个原子、离子或者原子团的个数，如 `H_{2}O` 表示 $\\text{H}_2\\text{O}$ (水)，`C_{60}` 表示 $\\text{C}_{60}$ (足球烯)。\n* 括号 `()`：表示一个原子团，下标对团内物质生效。如 `Ca(OH)_{2}` 表示 $\\text{Ca(OH)}_2$ (熟石灰)。\n* 水合物 `~`：如 `CuSO_{4}~5H_{2}O` 表示 $\\text{CuSO}_4 \\cdot 5\\text{H}_2\\text{O}$（胆矾）。水之前如果存在数字，保证一定是大于 $2$ 的正整数，如果省略该部分则默认为 $1$ 。如上述胆矾中，表示水的个数的 `5`。\n\n形式化地讲，你处理的化学式满足以下规则：\n\n> 分子`~`数量`H_{2}O` \n\n其中数量或水合部分可省。\n\n对于分子，满足：\n\n> 部分`_{`数量`}`部分`_{`数量`}`...部分`_{`数量`}`\n\n其中数量可省。\n\n对于每个“部分”（原子，原子团，离子……），满足：\n\n> 元素\n\n或\n\n> `(`元素`_{` 数量 `}`元素`_{` 数量`}`... 元素`_{`数量`})`\n\n其中数量可省。\n\n请注意，满足上述条件的化学式不会出现括号嵌套；上文中出现的 “数量” 所指代的数字不超过 $10000$。", "outputFormat": "输出一行，包含一个整数或者小数部分为 `.5` 的实数，为你的计算结果。\n\n保证结果不超过 $10000$。", "hint": "### 样例解释\n金 $\\text{Au} : 197$\n\n二氧化铪 $\\text{HfO}_2: 178.5 + 2 \\times 16= 210.5$\n\n氢氧化钙（熟石灰）$\\text{Ca(OH)}_2 : 40 + (1 + 16) \\times 2 = 74$\n\n五水硫酸铜（胆矾）$\\text{CuSO}_4 \\cdot 5\\text{H}_2\\text{O}: 64 + 32 + 16 \\times 4 + 5 \\times (1 \\times 2 + 16) = 250$\n\n十二水合硫酸铝钾（明矾）$\\text{KAl(SO}_4)_2 \\cdot 12\\text{H}_2\\text{O}$ （嗯 用心感受 $474$ 是对的）\n\n### 附表：可能用到的相对原子质量\n\n|元素|相对原子质量|\n|:-:|:-:|\n|$\\text{H}$|$1$|\n|$\\text{C}$|$12$|\n|$\\text{N}$|$14$|\n|$\\text{O}$|$16$|\n|$\\text{F}$|$19$|\n|$\\text{Na}$|$23$|\n|$\\text{Mg}$|$24$|\n|$\\text{Al}$|$27$|\n|$\\text{Si}$|$28$|\n|$\\text{P}$|$31$|\n|$\\text{S}$|$32$|\n|$\\text{Cl}$|$35.5$|\n|$\\text{K}$|$39$|\n|$\\text{Ca}$|$40$|\n|$\\text{Mn}$|$55$|\n|$\\text{Fe}$|$56$|\n|$\\text{Cu}$|$64$|\n|$\\text{Zn}$|$65$|\n|$\\text{Ag}$|$108$|\n|$\\text{I}$|$127$|\n|$\\text{Ba}$|$137$|\n|$\\text{Hf}$|$178.5$|\n|$\\text{Pt}$|$195$|\n|$\\text{Au}$|$197$|\n|$\\text{Hg}$|$201$|\n\n### 提示\n\n如果你没有学习过相关内容，下面的内容可能有帮助：\n\n> zcy 教你算相对分子质量\n\n1. 每个元素以大写开头；\n2. 计算分子质量的方法就是对每个原子出现的次数乘对应的相对原子质量求和；\n3. ~( $\\cdot$ ) 相当于加；\n4. 下标相当于乘。", "locale": "zh-CN", "translations": {"en": {"title": "Chemistry: Relative Molecular Mass", "background": "", "description": "When doing chemistry problems, Xiao F always miscalculates the relative molecular mass, which makes him very distressed.\n\nXiao F came to you for help. Please compute the relative molecular mass of the given substance.\n\nIf you have not studied the related content, that is fine. You can understand what is required from the samples and the hints.", "inputFormat": "Input consists of one line: a string of length $L$ $(L \\leq 100)$ without spaces, representing the chemical formula of the given substance.\n\nThe chemical formula includes only the following:\n\n- Elements: such as `Au` (gold), `Hf` (hafnium). All occurring elements and their relative atomic masses are given in the appendix.\n- Subscript `_{}`: indicates the count of some atom, ion, or group. For example, `H_{2}O` means $\\text{H}_2\\text{O}$ (water), and `C_{60}` means $\\text{C}_{60}$ (buckminsterfullerene).\n- Parentheses `()`: indicate a group, and a subscript applies to the content inside the group. For example, `Ca(OH)_{2}` means $\\text{Ca(OH)}_2$ (slaked lime).\n- Hydrate `~`: for example, `CuSO_{4}~5H_{2}O` means $\\text{CuSO}_4 \\cdot 5\\text{H}_2\\text{O}$ (chalcanthite). If there is a number before water, it is guaranteed to be a positive integer greater than $2$. If this part is omitted, it defaults to $1$. In the example above, the `5` indicates the number of water molecules.\n\nFormally, the chemical formula you process satisfies the following rules:\n\n> Molecule `~` Count `H_{2}O`\n\nThe count or the hydrate part may be omitted.\n\nFor the molecule, it satisfies:\n\n> Part `_{` Count `}` Part `_{` Count `}` ... Part `_{` Count `}`\n\nThe count may be omitted.\n\nFor each “Part” (atom, group, ion, etc.), it satisfies:\n\n> Element\n\nor\n\n> `(` Element `_{` Count `}` Element `_{` Count `}` ... Element `_{` Count `})`\n\nThe count may be omitted.\n\nPlease note that chemical formulas satisfying the above conditions will not contain nested parentheses. The number referred to as “Count” above does not exceed $10000$.", "outputFormat": "Output one line containing either an integer or a real number whose fractional part is `.5`, which is your computed result.\n\nIt is guaranteed that the result does not exceed $10000$.", "hint": "### Sample explanations\nGold $\\text{Au} : 197$.\n\nHafnium dioxide $\\text{HfO}_2: 178.5 + 2 \\times 16 = 210.5$.\n\nCalcium hydroxide (slaked lime) $\\text{Ca(OH)}_2 : 40 + (1 + 16) \\times 2 = 74$.\n\nCopper(II) sulfate pentahydrate (chalcanthite) $\\text{CuSO}_4 \\cdot 5\\text{H}_2\\text{O}: 64 + 32 + 16 \\times 4 + 5 \\times (1 \\times 2 + 16) = 250$.\n\nPotassium aluminum sulfate dodecahydrate (alum) $\\text{KAl(SO}_4)_2 \\cdot 12\\text{H}_2\\text{O}$ (Indeed, $474$ is correct.).\n\n### Appendix: Possible relative atomic masses\n\n|元素|相对原子质量|\n|:-:|:-:|\n|$\\text{H}$|$1$|\n|$\\text{C}$|$12$|\n|$\\text{N}$|$14$|\n|$\\text{O}$|$16$|\n|$\\text{F}$|$19$|\n|$\\text{Na}$|$23$|\n|$\\text{Mg}$|$24$|\n|$\\text{Al}$|$27$|\n|$\\text{Si}$|$28$|\n|$\\text{P}$|$31$|\n|$\\text{S}$|$32$|\n|$\\text{Cl}$|$35.5$|\n|$\\text{K}$|$39$|\n|$\\text{Ca}$|$40$|\n|$\\text{Mn}$|$55$|\n|$\\text{Fe}$|$56$|\n|$\\text{Cu}$|$64$|\n|$\\text{Zn}$|$65$|\n|$\\text{Ag}$|$108$|\n|$\\text{I}$|$127$|\n|$\\text{Ba}$|$137$|\n|$\\text{Hf}$|$178.5$|\n|$\\text{Pt}$|$195$|\n|$\\text{Au}$|$197$|\n|$\\text{Hg}$|$201$|\n\n### Tips\n\nIf you have not studied the related content, the following may help:\n\n> zcy teaches you how to compute relative molecular mass\n\n1. Each element starts with an uppercase letter.\n2. To compute the molecular mass, multiply the number of occurrences of each atom by its relative atomic mass and sum them up.\n3. ~( $\\cdot$ ) is equivalent to addition.\n4. A subscript is equivalent to multiplication.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「化学」相对分子质量", "background": null, "description": "做化学题时，小 F 总是里算错相对分子质量，这让他非常苦恼。\n\n小 F 找到了你，请你来帮他算一算给定物质的相对分子质量。\n\n如果你没有学过相关内容也没有关系，你可以从样例和提示里理解该题所求内容。", "inputFormat": "输入一行，为一个长度为 $L$ $(L\\leq 100)$ 的不含空格的字符串，表示给定物质的化学式。\n\n化学式仅包括以下内容:\n\n* 元素：如 `Au`(金)，`Hf`(铪)，**出现的所有元素及其相对原子质量以附表为准**。\n* 下标 `_{}` ：表示某个原子、离子或者原子团的个数，如 `H_{2}O` 表示 $\\text{H}_2\\text{O}$ (水)，`C_{60}` 表示 $\\text{C}_{60}$ (足球烯)。\n* 括号 `()`：表示一个原子团，下标对团内物质生效。如 `Ca(OH)_{2}` 表示 $\\text{Ca(OH)}_2$ (熟石灰)。\n* 水合物 `~`：如 `CuSO_{4}~5H_{2}O` 表示 $\\text{CuSO}_4 \\cdot 5\\text{H}_2\\text{O}$（胆矾）。水之前如果存在数字，保证一定是大于 $2$ 的正整数，如果省略该部分则默认为 $1$ 。如上述胆矾中，表示水的个数的 `5`。\n\n形式化地讲，你处理的化学式满足以下规则：\n\n> 分子`~`数量`H_{2}O` \n\n其中数量或水合部分可省。\n\n对于分子，满足：\n\n> 部分`_{`数量`}`部分`_{`数量`}`...部分`_{`数量`}`\n\n其中数量可省。\n\n对于每个“部分”（原子，原子团，离子……），满足：\n\n> 元素\n\n或\n\n> `(`元素`_{` 数量 `}`元素`_{` 数量`}`... 元素`_{`数量`})`\n\n其中数量可省。\n\n请注意，满足上述条件的化学式不会出现括号嵌套；上文中出现的 “数量” 所指代的数字不超过 $10000$。", "outputFormat": "输出一行，包含一个整数或者小数部分为 `.5` 的实数，为你的计算结果。\n\n保证结果不超过 $10000$。", "hint": "### 样例解释\n金 $\\text{Au} : 197$\n\n二氧化铪 $\\text{HfO}_2: 178.5 + 2 \\times 16= 210.5$\n\n氢氧化钙（熟石灰）$\\text{Ca(OH)}_2 : 40 + (1 + 16) \\times 2 = 74$\n\n五水硫酸铜（胆矾）$\\text{CuSO}_4 \\cdot 5\\text{H}_2\\text{O}: 64 + 32 + 16 \\times 4 + 5 \\times (1 \\times 2 + 16) = 250$\n\n十二水合硫酸铝钾（明矾）$\\text{KAl(SO}_4)_2 \\cdot 12\\text{H}_2\\text{O}$ （嗯 用心感受 $474$ 是对的）\n\n### 附表：可能用到的相对原子质量\n\n|元素|相对原子质量|\n|:-:|:-:|\n|$\\text{H}$|$1$|\n|$\\text{C}$|$12$|\n|$\\text{N}$|$14$|\n|$\\text{O}$|$16$|\n|$\\text{F}$|$19$|\n|$\\text{Na}$|$23$|\n|$\\text{Mg}$|$24$|\n|$\\text{Al}$|$27$|\n|$\\text{Si}$|$28$|\n|$\\text{P}$|$31$|\n|$\\text{S}$|$32$|\n|$\\text{Cl}$|$35.5$|\n|$\\text{K}$|$39$|\n|$\\text{Ca}$|$40$|\n|$\\text{Mn}$|$55$|\n|$\\text{Fe}$|$56$|\n|$\\text{Cu}$|$64$|\n|$\\text{Zn}$|$65$|\n|$\\text{Ag}$|$108$|\n|$\\text{I}$|$127$|\n|$\\text{Ba}$|$137$|\n|$\\text{Hf}$|$178.5$|\n|$\\text{Pt}$|$195$|\n|$\\text{Au}$|$197$|\n|$\\text{Hg}$|$201$|\n\n### 提示\n\n如果你没有学习过相关内容，下面的内容可能有帮助：\n\n> zcy 教你算相对分子质量\n\n1. 每个元素以大写开头；\n2. 计算分子质量的方法就是对每个原子出现的次数乘对应的相对原子质量求和；\n3. ~( $\\cdot$ ) 相当于加；\n4. 下标相当于乘。", "locale": "zh-CN"}}}
{"pid": "P4712", "type": "P", "difficulty": 4, "samples": [["2 9\n1 0\n1 1", "0.2000000"], ["2 9\n1 0\n1 0", "-1"], ["2 10\n1 0\n1 0", "0.4000000"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "Special Judge", "O2优化", "枚举", "前缀和", "洛谷月赛"], "title": "「生物」能量流动", "background": "", "description": "生物课上，小 F 学习到了食物链、食物网的相关内容。\n\n他学到，能量是逐级递减的。比如在食物链上，两个链接起来的生物 $A \\rightarrow B$（意思是 $B$ 吃 $A$）之间的能量传递效率最多只有 $\\frac 1 5$；而研究种间关系，能够使能量流向对人类最有益的部分。\n\n现在，小 F 想研究一下能量流动的关系，于是他在脑海里创造了一个生态的系统。\n\n在这个生态的系统里，有 $n+2$ 种生物，其中 $0$ 是生产者，整个生态系统所流经的能量由它固定；你是贪婪的顶级掠食者 $n + 1$，可以捕食所有生物；其他的掠食者 $[1, n]$ 各有各的喜好，只会捕食编号在 $[0, r_i]$ 的生物。由于天然形成的强弱顺序，上述关系满足 $r_i \\leq r_{i + 1}(1 \\leq i < n),$ $r_i < i(1 \\leq i \\leq n)$。\n\n每种动物需要摄取至少 $a_i$ 单位能量才能存活；一个生物摄取到的能量可以传递给捕食者，但传递效率都不超过 $\\frac 1 5$。也就是说，假设该动物捕获了 $b_i$ 单位的能量，所有捕食它的掠食者得到的能量总和 $c_i$，那么有：\n* $b_i \\geq a_i$\n* $c_i \\leq \\frac 1 5 b_i$\n\n你希望知道，在所有生物都存活的情况下，在最优情况下你能获取到的最大能量是多少。", "inputFormat": "输入第一行两个整数 $n, a_0(1 \\leq n \\leq 10 ^ 5, 1 \\leq a_0 \\leq 10 ^ 9)$。$a_0$ 是生产者固定的能量值。 \n\n接下来 $n$ 行，每行 $2$ 个正整数，表示 $a_i, r_i(1 \\leq a_i \\leq 10 ^ 9)$。\n\n数据保证，$0\\leq r_i < i, r_i \\leq r_{i + 1}$。", "outputFormat": "输出一行一个浮点数，表示你——顶级掠食者——能得到的最大能量。如果不能使得所有生物存活（包括你自己），请输出 $-1$。\n\n你的答案与参考答案的相对误差或者绝对误差不超过 $10 ^ {-8}$ 即被认为是正确的。如果你的程序是正确的，可以不用考虑精度问题。", "hint": "### 样例 1 解释\n\n最优情况下：\n* 1 号掠食者捕食生产者 0，捕食 5 点能量，传递效率为 $\\frac 1 5$，得到 1 点能量。\n* 2 号掠食者捕食生产者 0，捕食 4 点能量，传递效率为 $\\frac 1 5$，得到 0.8 点能量。\n* 2 号掠食者捕食掠食者 1，捕食 1 点能量，传递效率为 $\\frac 1 5$，得到 0.2 点能量。\n\n可怜的你只能捕获 2 号掠食者的能量，捕食 1 点能量，得到 0.2 点能量。\n\n### 样例 2, 3 解释\n\n由于 2 号掠食者开始减肥不吃肉了（也有可能是打不过 1 了），所以所需的生产者能量从 9 点变成了 10 点。\n\n### 子任务\n\n子任务 $1(21 \\mathrm{pts}) : n \\leq 100$；\n\n子任务 $2(89 \\mathrm{pts}) : n \\leq 10 ^ 5$。", "locale": "zh-CN", "translations": {"en": {"title": "\"Biology\" Energy Flow", "background": "", "description": "In biology class, little F learned about food chains and food webs.\n\nHe learned that energy decreases step by step. For example, on a food chain, between two linked organisms $A \\rightarrow B$ (meaning $B$ eats $A$), the energy transfer efficiency is at most $\\frac 1 5$; and by studying interspecific relationships, one can guide energy to flow toward the parts most beneficial to humans.\n\nNow, little F wants to study energy flow, so he creates an ecological system in his mind.\n\nIn this ecological system, there are $n+2$ species, where $0$ is the producer and the total energy flowing through the entire ecosystem is fixed by it; you are the greedy apex predator $n + 1$, and you can prey on all species; the other predators $[1, n]$ each have their own preferences and will only prey on species with indices in $[0, r_i]$. Due to a naturally formed hierarchy of strength, these relationships satisfy $r_i \\leq r_{i + 1}(1 \\leq i < n),$ $r_i < i(1 \\leq i \\leq n)$.\n\nEach animal needs to ingest at least $a_i$ units of energy to survive; the energy ingested by one organism can be passed to its predators, but the transfer efficiency never exceeds $\\frac 1 5$. That is, suppose that organism $i$ captures $b_i$ units of energy, and the total energy $c_i$ obtained by all predators that prey on it satisfies:\n- $b_i \\geq a_i$;\n- $c_i \\leq \\frac 1 5 b_i$.\n\nYou want to know, under the constraint that all organisms survive, what is the maximum energy you can obtain in the optimal arrangement.", "inputFormat": "The first line contains two integers $n, a_0(1 \\leq n \\leq 10 ^ 5, 1 \\leq a_0 \\leq 10 ^ 9)$, where $a_0$ is the fixed energy of the producer.\n\nThen follow $n$ lines, each with $2$ positive integers, representing $a_i, r_i(1 \\leq a_i \\leq 10 ^ 9)$.\n\nIt is guaranteed that $0\\leq r_i < i, r_i \\leq r_{i + 1}$.", "outputFormat": "Output one floating-point number on a single line, representing the maximum energy you—the apex predator—can obtain. If it is impossible to make all organisms survive (including yourself), output $-1$.\n\nYour answer will be considered correct if the relative or absolute error does not exceed $10 ^ {-8}$. If your program is correct, you do not need to worry about precision issues.", "hint": "Sample 1 explanation:\n\nIn the optimal arrangement:\n- Predator 1 preys on producer 0, captures 5 units of energy, with transfer efficiency $\\frac 1 5$, and obtains 1 unit of energy.\n- Predator 2 preys on producer 0, captures 4 units of energy, with transfer efficiency $\\frac 1 5$, and obtains 0.8 units of energy.\n- Predator 2 preys on predator 1, captures 1 unit of energy, with transfer efficiency $\\frac 1 5$, and obtains 0.2 units of energy.\n\nUnfortunately, you can only prey on predator 2, capture 1 unit of energy, and obtain 0.2 units of energy.\n\nSample 2 and 3 explanation:\n\nSince predator 2 goes on a diet and stops eating meat (or perhaps cannot defeat 1), the required energy from the producer changes from 9 units to 10 units.\n\nSubtasks:\n- Subtask $1(21 \\mathrm{pts}) : n \\leq 100$;\n- Subtask $2(89 \\mathrm{pts}) : n \\leq 10 ^ 5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「生物」能量流动", "background": "", "description": "生物课上，小 F 学习到了食物链、食物网的相关内容。\n\n他学到，能量是逐级递减的。比如在食物链上，两个链接起来的生物 $A \\rightarrow B$（意思是 $B$ 吃 $A$）之间的能量传递效率最多只有 $\\frac 1 5$；而研究种间关系，能够使能量流向对人类最有益的部分。\n\n现在，小 F 想研究一下能量流动的关系，于是他在脑海里创造了一个生态的系统。\n\n在这个生态的系统里，有 $n+2$ 种生物，其中 $0$ 是生产者，整个生态系统所流经的能量由它固定；你是贪婪的顶级掠食者 $n + 1$，可以捕食所有生物；其他的掠食者 $[1, n]$ 各有各的喜好，只会捕食编号在 $[0, r_i]$ 的生物。由于天然形成的强弱顺序，上述关系满足 $r_i \\leq r_{i + 1}(1 \\leq i < n),$ $r_i < i(1 \\leq i \\leq n)$。\n\n每种动物需要摄取至少 $a_i$ 单位能量才能存活；一个生物摄取到的能量可以传递给捕食者，但传递效率都不超过 $\\frac 1 5$。也就是说，假设该动物捕获了 $b_i$ 单位的能量，所有捕食它的掠食者得到的能量总和 $c_i$，那么有：\n* $b_i \\geq a_i$\n* $c_i \\leq \\frac 1 5 b_i$\n\n你希望知道，在所有生物都存活的情况下，在最优情况下你能获取到的最大能量是多少。", "inputFormat": "输入第一行两个整数 $n, a_0(1 \\leq n \\leq 10 ^ 5, 1 \\leq a_0 \\leq 10 ^ 9)$。$a_0$ 是生产者固定的能量值。 \n\n接下来 $n$ 行，每行 $2$ 个正整数，表示 $a_i, r_i(1 \\leq a_i \\leq 10 ^ 9)$。\n\n数据保证，$0\\leq r_i < i, r_i \\leq r_{i + 1}$。", "outputFormat": "输出一行一个浮点数，表示你——顶级掠食者——能得到的最大能量。如果不能使得所有生物存活（包括你自己），请输出 $-1$。\n\n你的答案与参考答案的相对误差或者绝对误差不超过 $10 ^ {-8}$ 即被认为是正确的。如果你的程序是正确的，可以不用考虑精度问题。", "hint": "### 样例 1 解释\n\n最优情况下：\n* 1 号掠食者捕食生产者 0，捕食 5 点能量，传递效率为 $\\frac 1 5$，得到 1 点能量。\n* 2 号掠食者捕食生产者 0，捕食 4 点能量，传递效率为 $\\frac 1 5$，得到 0.8 点能量。\n* 2 号掠食者捕食掠食者 1，捕食 1 点能量，传递效率为 $\\frac 1 5$，得到 0.2 点能量。\n\n可怜的你只能捕获 2 号掠食者的能量，捕食 1 点能量，得到 0.2 点能量。\n\n### 样例 2, 3 解释\n\n由于 2 号掠食者开始减肥不吃肉了（也有可能是打不过 1 了），所以所需的生产者能量从 9 点变成了 10 点。\n\n### 子任务\n\n子任务 $1(21 \\mathrm{pts}) : n \\leq 100$；\n\n子任务 $2(89 \\mathrm{pts}) : n \\leq 10 ^ 5$。", "locale": "zh-CN"}}}
{"pid": "P4713", "type": "P", "difficulty": 6, "samples": [["4 4 12 2 10 5\n5 5 10 4\n2 -1\n0 0\n1 1", "18"], ["2 2 10 1 10 1\n1 1\n2", "9"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "O2优化", "枚举", "洛谷月赛"], "title": "「语文」凑字数", "background": " 数据的锅修好了！", "description": "时间在一秒一秒地减少着，然而小 F 仍对着作文题冥思苦想。看起来，他又写不完作文了。\n\n然而，小 F 有一种特殊的凑字数技巧——不停换行。这是因为，作文纸每行 $L$ 个字，而最低字数限制是以行数来计算的。\n\n也就是说，只要写到了 $M$ 行（不含标题）即认为时满足要求，写到意味着这一行上有字。注意，由于作文格式要求，每段首行会**有两个字符的缩进空格**。\n\n现在，他已经构思好了 $N$ 句话，每句话有着自己的长度 $a_i$ ——包括标点符号，不考虑因句号等在最后一格之外而不换行的情况。这几句话的关联或强或弱，关联强的更适合放在一段，关联弱的更适合分段，然而因为凑字数小 F 可以对任意两句话之间进行换行以分段。\n\n关联关系会用一种特殊的方式来表示。我们知道，作文改卷时会将作文的得分点划分为几个主要部分，比如全国卷分为基础，表达，发展三个部分；每个部分拥有着相同的总分，比如对于全国卷来说是 $20$ 分；每个部分的最低均为 $0$ 分，也就是说哪怕扣到 $0$ 以下也算 $0$ 分。在这里，我们的评分标准有 $K$ 个部分，每个部分有 $S$ 分的满分。根据方面的不同，小 F 将两句话的关联关系用一个 $K$ 元组 $s_i = (s_{i,1}, s_{i, 2}, \\cdots, s_{i, K})$ 表示，其中每个数都是整数，第 $j$ 个数 $s_{i, j}$ 表示：\n* 如果是正数，那么表示拆开 $i, i + 1$ 这两句话会导致第 $j$ 部分得分扣 $s_{i, j}$ 分 。\n* 如果是负数，那么表示**不**拆开这两句话第 $j$ 部分得分扣 $-s_{i, j}$ 分。\n* 如果为 0，那么表示是否拆开这两句话对得分没有影响。\n\n从满分开始，在计算完上面的扣分之后可以得到一个初步的总分。在这之后，最低字数线上每空一行，会扣 $C$ 分字数分，总分扣至 0 为止。\n\n如果能够拿到高分作文，小 F 就可以得到老师的大拇指！所以，请你帮小 F 设计出一种方案以最大化得分。", "inputFormat": "输入第一行为 $6$ 个整数，$N, M, L, K, S, C$，对应题目描述里的内容。\n\n输入第二行为 $N$ 个整数，第 $i$ 个为 $a_i$，即每句话的长度。 \n\n接下来 $N - 1$ 行，每行 $K$ 个整数，第 $i$ 行第 $j$ 个表示 $s_{i, j}$。", "outputFormat": "输出一行一个非负整数，表示你所求得的最大得分。\n\n", "hint": "### 样例 1 解释\n\n这是样例 1 不分段的情况：\n\n![](https://cdn.luogu.com.cn/upload/pic/21276.png )\n\n这样做，得分是 $10 + 9 - 5 = 14$ 分。\n\n我们发现，字数分太痛了，于是我们一定要去避免它。\n\n最优解如下：\n\n![](https://cdn.luogu.com.cn/upload/pic/21277.png)\n\n这样做，得分是 $8 + 10 - 0 = 18$ 分。\n\n### 样例 2 解释\n\n即使换行可以避免一分字数扣分，但是相应地会扣掉两分，所以不如不换。\n\n\n### 子任务\n\n子任务 $1(21 \\mathrm{pts}) : N \\leq 10$；\n\n子任务 $2(21 \\mathrm{pts}) : K = 1$；\n\n子任务 $3(31 \\mathrm{pts}) : N \\times a_i \\leq 800$；\n\n子任务 $4(77 \\mathrm{pts}) :$\n* $1 \\leq N, M, a_i \\leq 200$\n* $3 \\leq L \\leq 200$\n* $1 \\leq K \\leq 5$\n* $0 \\leq S, C, |s_{i, j}| \\leq 200$", "locale": "zh-CN", "translations": {"en": {"title": "\"Chinese\" Padding the Word Count", "background": "The issue with the testdata has been fixed.", "description": "Time is ticking away second by second, yet Xiao F is still staring at the essay prompt, racking his brain. It looks like he will not finish the essay again.\n\nHowever, Xiao F has a special trick to pad the word count: keep starting new lines. This is because the essay paper allows $L$ characters per line, and the minimum word count requirement is measured by the number of lines.\n\nThat is, as long as he reaches $M$ lines (excluding the title), the requirement is considered met; “reaches” means that the line contains at least one character. Note that due to formatting requirements, the first line of each paragraph has an indentation of two spaces.\n\nNow, he has planned $N$ sentences, and each sentence has its own length $a_i$—including punctuation. We do not consider cases where, for example, a final period would be beyond the last cell and thus avoid wrapping. The connections between these sentences vary in strength: more strongly related sentences are more suitable to be in the same paragraph, while weakly related ones are more suitable to be split into different paragraphs. However, for padding the word count, Xiao F may insert a paragraph break between any two consecutive sentences.\n\nThe association between sentences is represented in a special way. We know that when grading, the score is divided into several main parts; for example, the national paper has “Basic,” “Expression,” and “Development,” each with the same total score (e.g., $20$ points). The minimum for each part is $0$ points, meaning that even if a part would go below $0$, it is counted as $0$. Here, our rubric has $K$ parts, each with a full score of $S$. Depending on the aspect, Xiao F uses a $K$-tuple $s_i = (s_{i,1}, s_{i, 2}, \\cdots, s_{i, K})$ to describe the relation between sentence $i$ and sentence $i + 1$, where each number is an integer. The $j$-th number $s_{i, j}$ means:\n- If it is positive, then splitting sentences $i$ and $i + 1$ will deduct $s_{i, j}$ points from part $j$.\n- If it is negative, then not splitting these two sentences will deduct $-s_{i, j}$ points from part $j$.\n- If it is $0$, then whether to split has no effect on the score for that part.\n\nStarting from full marks for each part (i.e., $S$ per part), after applying the above deductions, each part is floored at $0$, and summing over parts yields a preliminary total score. After that, if the number of written lines is below the minimum line count, each missing line deducts $C$ points from the word-count score, and the overall total is floored at $0$.\n\nIf he can get a high-scoring essay, Xiao F will receive a thumbs-up from the teacher. So, please help Xiao F design a plan to maximize the score.", "inputFormat": "- The first line contains $6$ integers: $N, M, L, K, S, C$, as described above.\n- The second line contains $N$ integers, where the $i$-th is $a_i$, the length of sentence $i$.\n- The next $N - 1$ lines each contain $K$ integers; on the $i$-th of these lines, the $j$-th integer is $s_{i, j}$.", "outputFormat": "Output one non-negative integer on a single line, representing the maximum score you can obtain.", "hint": "### Explanation for Sample 1\n\nThis is the “no paragraph break” arrangement for Sample 1:\n\n![](https://cdn.luogu.com.cn/upload/pic/21276.png )\n\nWith this arrangement, the score is $10 + 9 - 5 = 14$ points.\n\nWe notice the word-count penalty is too heavy, so we must avoid it.\n\nThe optimal solution is as follows:\n\n![](https://cdn.luogu.com.cn/upload/pic/21277.png)\n\nWith this arrangement, the score is $8 + 10 - 0 = 18$ points.\n\n### Explanation for Sample 2\n\nEven though inserting a break avoids a one-point word-count penalty, it causes a two-point deduction elsewhere, so it is better not to insert a break.\n\n### Subtasks\n\nSubtask $1(21 \\mathrm{pts})$: $N \\leq 10$.\n\nSubtask $2(21 \\mathrm{pts})$: $K = 1$.\n\nSubtask $3(31 \\mathrm{pts})$: $N \\times a_i \\leq 800$.\n\nSubtask $4(77 \\mathrm{pts})$:\n- $1 \\leq N, M, a_i \\leq 200$.\n- $3 \\leq L \\leq 200$.\n- $1 \\leq K \\leq 5$.\n- $0 \\leq S, C, |s_{i, j}| \\leq 200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「语文」凑字数", "background": " 数据的锅修好了！", "description": "时间在一秒一秒地减少着，然而小 F 仍对着作文题冥思苦想。看起来，他又写不完作文了。\n\n然而，小 F 有一种特殊的凑字数技巧——不停换行。这是因为，作文纸每行 $L$ 个字，而最低字数限制是以行数来计算的。\n\n也就是说，只要写到了 $M$ 行（不含标题）即认为时满足要求，写到意味着这一行上有字。注意，由于作文格式要求，每段首行会**有两个字符的缩进空格**。\n\n现在，他已经构思好了 $N$ 句话，每句话有着自己的长度 $a_i$ ——包括标点符号，不考虑因句号等在最后一格之外而不换行的情况。这几句话的关联或强或弱，关联强的更适合放在一段，关联弱的更适合分段，然而因为凑字数小 F 可以对任意两句话之间进行换行以分段。\n\n关联关系会用一种特殊的方式来表示。我们知道，作文改卷时会将作文的得分点划分为几个主要部分，比如全国卷分为基础，表达，发展三个部分；每个部分拥有着相同的总分，比如对于全国卷来说是 $20$ 分；每个部分的最低均为 $0$ 分，也就是说哪怕扣到 $0$ 以下也算 $0$ 分。在这里，我们的评分标准有 $K$ 个部分，每个部分有 $S$ 分的满分。根据方面的不同，小 F 将两句话的关联关系用一个 $K$ 元组 $s_i = (s_{i,1}, s_{i, 2}, \\cdots, s_{i, K})$ 表示，其中每个数都是整数，第 $j$ 个数 $s_{i, j}$ 表示：\n* 如果是正数，那么表示拆开 $i, i + 1$ 这两句话会导致第 $j$ 部分得分扣 $s_{i, j}$ 分 。\n* 如果是负数，那么表示**不**拆开这两句话第 $j$ 部分得分扣 $-s_{i, j}$ 分。\n* 如果为 0，那么表示是否拆开这两句话对得分没有影响。\n\n从满分开始，在计算完上面的扣分之后可以得到一个初步的总分。在这之后，最低字数线上每空一行，会扣 $C$ 分字数分，总分扣至 0 为止。\n\n如果能够拿到高分作文，小 F 就可以得到老师的大拇指！所以，请你帮小 F 设计出一种方案以最大化得分。", "inputFormat": "输入第一行为 $6$ 个整数，$N, M, L, K, S, C$，对应题目描述里的内容。\n\n输入第二行为 $N$ 个整数，第 $i$ 个为 $a_i$，即每句话的长度。 \n\n接下来 $N - 1$ 行，每行 $K$ 个整数，第 $i$ 行第 $j$ 个表示 $s_{i, j}$。", "outputFormat": "输出一行一个非负整数，表示你所求得的最大得分。\n\n", "hint": "### 样例 1 解释\n\n这是样例 1 不分段的情况：\n\n![](https://cdn.luogu.com.cn/upload/pic/21276.png )\n\n这样做，得分是 $10 + 9 - 5 = 14$ 分。\n\n我们发现，字数分太痛了，于是我们一定要去避免它。\n\n最优解如下：\n\n![](https://cdn.luogu.com.cn/upload/pic/21277.png)\n\n这样做，得分是 $8 + 10 - 0 = 18$ 分。\n\n### 样例 2 解释\n\n即使换行可以避免一分字数扣分，但是相应地会扣掉两分，所以不如不换。\n\n\n### 子任务\n\n子任务 $1(21 \\mathrm{pts}) : N \\leq 10$；\n\n子任务 $2(21 \\mathrm{pts}) : K = 1$；\n\n子任务 $3(31 \\mathrm{pts}) : N \\times a_i \\leq 800$；\n\n子任务 $4(77 \\mathrm{pts}) :$\n* $1 \\leq N, M, a_i \\leq 200$\n* $3 \\leq L \\leq 200$\n* $1 \\leq K \\leq 5$\n* $0 \\leq S, C, |s_{i, j}| \\leq 200$", "locale": "zh-CN"}}}
{"pid": "P4714", "type": "P", "difficulty": 6, "samples": [["4 0", "3"], ["4 1", "6"], ["4 2", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["递推", "洛谷原创", "素数判断,质数,筛法", "前缀和", "洛谷月赛"], "title": "「数学」约数个数和", "background": "", "description": "小 F 在数学课上与同学闲聊。\n\n> 给你一个正整数，计算他的约数个数。\n\n「你们竞赛就学这个啊？太简单了吧。」\n\n「……」\n\n> 给你一个正整数，计算他的所有约数的约数个数和。\n\n「我想想……嗯，还是不难的。诶，你们竞赛还能报名吗？」\n\n「……」\n\n> 给你一个正整数，计算他的所有约数的所有约数的约数个数和。\n\n「哎呀反正你们电脑总是能爆算出来的嘛，快给我说在哪报名。」\n\n「……」\n\n> 给你一个正整数，计算他的所有约数的所有约数的所有约数的约数个数和。\n\n「有完没完了？」\n\n「……」\n\n\n被嘲讽的小 F 将这个问题交给了你，请展示你的爆算实力。\n\n给你一个正整数 $N$，请计算 $N$ 的 $($所有约数的$)\\times K$ 约数个数和。\n\n答案可能很大，请输出对 $998244353$ 取模的结果。\n", "inputFormat": "输入一行两个整数 $N, K(1 \\leq N \\leq 10 ^ {18}, 0 \\leq K \\leq 10^{18})$。\n", "outputFormat": "输出一行一个非负整数，表示所求的答案对 $998244353$ 取模的结果。", "hint": "### 样例 1, 2, 3 解释\n\n$4,\\ 0:$ $4$ 的约数 $\\ 1\\ 2\\ 4$\n\n$4,\\ 1:$ $4$ 的所有约数的约数 $\\ (1)\\ (1\\ 2)\\ (1\\ 2\\ 4)$\n\n$4,\\ 2:$ $4$ 的所有约数的所有约数的约数 $((1))\\ ((1)\\ (1\\ 2))\\ ((1)\\ (1\\ 2)\\ (1\\ 2\\ 4))$\n\n### 子任务\n\n子任务 $1(11 \\mathrm{pts}) : N, K \\leq 10 ^ 4$\n\n子任务 $2(31 \\mathrm{pts}) : N \\leq 10 ^ 4$\n\n子任务 $3(41 \\mathrm{pts}) : N \\leq 10 ^ 9$\n\n子任务 $4(67 \\mathrm{pts}) : 1 \\leq N \\leq 10 ^ {18}, 0 \\leq K \\leq 10^{18} $。", "locale": "zh-CN", "translations": {"en": {"title": "\"Mathematics\" Sum of Divisor Counts", "background": "", "description": "Little F is chatting with classmates in math class.\n\n> Given a positive integer, compute the number of its divisors.\n\n“You guys in competitions just study this? Too easy.”\n\n“...”\n\n> Given a positive integer, compute the sum of the number of divisors of all its divisors.\n\n“Let me think... Hmm, still not hard. Hey, can you still sign up for your competitions?”\n\n“...”\n\n> Given a positive integer, compute the sum of the number of divisors of all the divisors of all its divisors.\n\n“Anyway your computers can always brute-force it, right? Hurry up and tell me where to sign up.”\n\n“...”\n\n> Given a positive integer, compute the sum of the number of divisors of all the divisors of all the divisors of all its divisors.\n\n“Will this ever end?”\n\n“...”\n\nMocked, Little F hands this problem to you. Please show your brute-forcing power.\n\nGiven a positive integer $N$, compute the sum of divisor counts over the multiset obtained by applying the operation “take all divisors” to $N$ exactly $K$ times.\n\nThe answer may be large; output it modulo $998244353$.", "inputFormat": "One line with two integers $N, K(1 \\leq N \\leq 10 ^ {18}, 0 \\leq K \\leq 10^{18})$.", "outputFormat": "Output a single non-negative integer: the required answer modulo $998244353$.", "hint": "### Explanations for Samples 1, 2, 3\n\n$4,\\ 0:$ $4$ 的约数 $\\ 1\\ 2\\ 4$\n\n$4,\\ 1:$ $4$ 的所有约数的约数 $\\ (1)\\ (1\\ 2)\\ (1\\ 2\\ 4)$\n\n$4,\\ 2:$ $4$ 的所有约数的所有约数的约数 $((1))\\ ((1)\\ (1\\ 2))\\ ((1)\\ (1\\ 2)\\ (1\\ 2\\ 4))$\n\n### Subtasks\n\n子任务 $1(11 \\mathrm{pts}) : N, K \\leq 10 ^ 4$\n\n子任务 $2(31 \\mathrm{pts}) : N \\leq 10 ^ 4$\n\n子任务 $3(41 \\mathrm{pts}) : N \\leq 10 ^ 9$\n\n子任务 $4(67 \\mathrm{pts}) : 1 \\leq N \\leq 10 ^ {18}, 0 \\leq K \\leq 10^{18} $。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「数学」约数个数和", "background": "", "description": "小 F 在数学课上与同学闲聊。\n\n> 给你一个正整数，计算他的约数个数。\n\n「你们竞赛就学这个啊？太简单了吧。」\n\n「……」\n\n> 给你一个正整数，计算他的所有约数的约数个数和。\n\n「我想想……嗯，还是不难的。诶，你们竞赛还能报名吗？」\n\n「……」\n\n> 给你一个正整数，计算他的所有约数的所有约数的约数个数和。\n\n「哎呀反正你们电脑总是能爆算出来的嘛，快给我说在哪报名。」\n\n「……」\n\n> 给你一个正整数，计算他的所有约数的所有约数的所有约数的约数个数和。\n\n「有完没完了？」\n\n「……」\n\n\n被嘲讽的小 F 将这个问题交给了你，请展示你的爆算实力。\n\n给你一个正整数 $N$，请计算 $N$ 的 $($所有约数的$)\\times K$ 约数个数和。\n\n答案可能很大，请输出对 $998244353$ 取模的结果。\n", "inputFormat": "输入一行两个整数 $N, K(1 \\leq N \\leq 10 ^ {18}, 0 \\leq K \\leq 10^{18})$。\n", "outputFormat": "输出一行一个非负整数，表示所求的答案对 $998244353$ 取模的结果。", "hint": "### 样例 1, 2, 3 解释\n\n$4,\\ 0:$ $4$ 的约数 $\\ 1\\ 2\\ 4$\n\n$4,\\ 1:$ $4$ 的所有约数的约数 $\\ (1)\\ (1\\ 2)\\ (1\\ 2\\ 4)$\n\n$4,\\ 2:$ $4$ 的所有约数的所有约数的约数 $((1))\\ ((1)\\ (1\\ 2))\\ ((1)\\ (1\\ 2)\\ (1\\ 2\\ 4))$\n\n### 子任务\n\n子任务 $1(11 \\mathrm{pts}) : N, K \\leq 10 ^ 4$\n\n子任务 $2(31 \\mathrm{pts}) : N \\leq 10 ^ 4$\n\n子任务 $3(41 \\mathrm{pts}) : N \\leq 10 ^ 9$\n\n子任务 $4(67 \\mathrm{pts}) : 1 \\leq N \\leq 10 ^ {18}, 0 \\leq K \\leq 10^{18} $。", "locale": "zh-CN"}}}
{"pid": "P4715", "type": "P", "difficulty": 2, "samples": [["3\n4 2 3 1 10 5 9 7\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "【深基16.例1】淘汰赛", "background": "", "description": "有 $2^n$（$n\\le7$）个国家参加世界杯决赛圈且进入淘汰赛环节。已经知道各个国家的能力值，且都不相等。能力值高的国家和能力值低的国家踢比赛时高者获胜。1 号国家和 2 号国家踢一场比赛，胜者晋级。3 号国家和 4 号国家也踢一场，胜者晋级……晋级后的国家用相同的方法继续完成赛程，直到决出冠军。给出各个国家的能力值，请问亚军是哪个国家？", "inputFormat": "第一行一个整数 $n$，表示一共 $2^n$ 个国家参赛。\n\n第二行 $2^n$ 个整数，第 $i$ 个整数表示编号为 $i$ 的国家的能力值（$1\\leq i \\leq 2^n$，能力值在 int 范围内）。\n\n数据保证不存在平局。", "outputFormat": "仅一个整数，表示亚军国家的编号。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[Deep Base 16. Example 1] Knockout Tournament", "background": "", "description": "There are $2^n$ ($n \\le 7$) countries participating in the World Cup finals and entering the knockout stage. The strength value of each country is known, and all values are different. When a country with a higher strength value plays against a country with a lower strength value, the stronger one wins. Country 1 plays a match against Country 2, and the winner advances. Country 3 plays against Country 4, and the winner advances... The advanced countries continue the tournament in the same way until the champion is decided. Given the strength values of all countries, which country is the runner-up?", "inputFormat": "The first line contains an integer $n$, meaning there are $2^n$ countries in total.\n\nThe second line contains $2^n$ integers. The $i$-th integer represents the strength value of country $i$ ($1 \\leq i \\leq 2^n$, and the strength values are within the int range).\n\nThe testdata guarantees that there are no draws.", "outputFormat": "Only one integer, representing the number of the runner-up country.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【深基16.例1】淘汰赛", "background": "", "description": "有 $2^n$（$n\\le7$）个国家参加世界杯决赛圈且进入淘汰赛环节。已经知道各个国家的能力值，且都不相等。能力值高的国家和能力值低的国家踢比赛时高者获胜。1 号国家和 2 号国家踢一场比赛，胜者晋级。3 号国家和 4 号国家也踢一场，胜者晋级……晋级后的国家用相同的方法继续完成赛程，直到决出冠军。给出各个国家的能力值，请问亚军是哪个国家？", "inputFormat": "第一行一个整数 $n$，表示一共 $2^n$ 个国家参赛。\n\n第二行 $2^n$ 个整数，第 $i$ 个整数表示编号为 $i$ 的国家的能力值（$1\\leq i \\leq 2^n$，能力值在 int 范围内）。\n\n数据保证不存在平局。", "outputFormat": "仅一个整数，表示亚军国家的编号。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4716", "type": "P", "difficulty": 6, "samples": [["4 6 1\n1 2 3\n1 3 1\n4 1 2\n4 2 2\n3 2 1\n3 4 1", "3"], ["4 6 3\n1 2 3\n1 3 1\n4 1 2\n4 2 2\n3 2 1\n3 4 1", "4"], ["4 6 2\n1 2 3\n1 3 1\n4 1 2\n4 2 2\n3 2 1\n3 4 1", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["图论", "贪心", "强连通分量", "模板题"], "title": "【模板】最小树形图", "background": "这是一道模板题。", "description": "给定包含 $n$ 个结点， $m$ 条有向边的一个图。试求一棵以结点 $r$ 为根的最小树形图，并输出最小树形图每条边的权值之和，如果没有以 $r$ 为根的最小树形图，输出 $-1$。", "inputFormat": "第一行包含三个整数 $n,m,r$，意义同题目所述。\n\n接下来 $m$ 行，每行包含三个整数 $u,v,w$，表示图中存在一条从 $u$ 指向 $v$ 的权值为 $w$ 的有向边。\n", "outputFormat": "如果原图中存在以 $r$ 为根的最小树形图，就输出最小树形图每条边的权值之和，否则输出 $-1$。", "hint": "**样例 $1$ 解释**\n\n最小树形图中包含第 $2$， $5$， $6$ 三条边，总权值为 $1 + 1 + 1 = 3$\n\n**样例 $2$ 解释**\n\n最小树形图中包含第 $3$， $5$， $6$ 三条边，总权值为 $2 + 1 + 1 = 4$\n\n**样例 $3$ 解释**\n\n无法构成最小树形图，故输出 $-1$ 。\n\n**数据范围**\n\n对于所有数据，$1 \\leq u, v \\leq n \\leq 100$, $1 \\leq m \\leq 10^4$​​, $1 \\leq w \\leq 10^6$​​。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Minimum Arborescence", "background": "This is a template problem.", "description": "Given a directed graph with $n$ nodes and $m$ directed edges. Find a minimum arborescence rooted at node $r$, and output the sum of the weights of all edges in the minimum arborescence. If there is no minimum arborescence rooted at $r$, output $-1$.", "inputFormat": "The first line contains three integers $n, m, r$, with the same meanings as described in the statement.\n\nThe next $m$ lines each contain three integers $u, v, w$, indicating that there is a directed edge from $u$ to $v$ with weight $w$.", "outputFormat": "If the original graph has a minimum arborescence rooted at $r$, output the sum of the weights of all edges in the minimum arborescence; otherwise output $-1$.", "hint": "**Sample $1$ Explanation**\n\nThe minimum arborescence contains edges $2$, $5$, and $6$, with total weight $1 + 1 + 1 = 3$.\n\n**Sample $2$ Explanation**\n\nThe minimum arborescence contains edges $3$, $5$, and $6$, with total weight $2 + 1 + 1 = 4$.\n\n**Sample $3$ Explanation**\n\nA minimum arborescence cannot be formed, so output $-1$.\n\n**Constraints**\n\nFor all testdata, $1 \\leq u, v \\leq n \\leq 100$, $1 \\leq m \\leq 10^4$, $1 \\leq w \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】最小树形图", "background": "这是一道模板题。", "description": "给定包含 $n$ 个结点， $m$ 条有向边的一个图。试求一棵以结点 $r$ 为根的最小树形图，并输出最小树形图每条边的权值之和，如果没有以 $r$ 为根的最小树形图，输出 $-1$。", "inputFormat": "第一行包含三个整数 $n,m,r$，意义同题目所述。\n\n接下来 $m$ 行，每行包含三个整数 $u,v,w$，表示图中存在一条从 $u$ 指向 $v$ 的权值为 $w$ 的有向边。\n", "outputFormat": "如果原图中存在以 $r$ 为根的最小树形图，就输出最小树形图每条边的权值之和，否则输出 $-1$。", "hint": "**样例 $1$ 解释**\n\n最小树形图中包含第 $2$， $5$， $6$ 三条边，总权值为 $1 + 1 + 1 = 3$\n\n**样例 $2$ 解释**\n\n最小树形图中包含第 $3$， $5$， $6$ 三条边，总权值为 $2 + 1 + 1 = 4$\n\n**样例 $3$ 解释**\n\n无法构成最小树形图，故输出 $-1$ 。\n\n**数据范围**\n\n对于所有数据，$1 \\leq u, v \\leq n \\leq 100$, $1 \\leq m \\leq 10^4$​​, $1 \\leq w \\leq 10^6$​​。", "locale": "zh-CN"}}}
{"pid": "P4717", "type": "P", "difficulty": 6, "samples": [["2\n2 4 6 8\n1 3 5 7\n", "2 22 46 250\n88 64 112 56\n100 92 68 60\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["快速沃尔什变换 FWT", "快速莫比乌斯变换 FMT", "模板题"], "title": "【模板】快速莫比乌斯 / 沃尔什变换 (FMT / FWT)", "background": "", "description": "给定长度为 $2^n$ 两个序列 $A,B$，设 \n\n$$C_i=\\sum_{j\\oplus k = i}A_j \\times B_k$$\n\n分别当 $\\oplus$ 是 or, and, xor 时求出 $C$。", "inputFormat": "第一行，一个整数 $n$。  \n第二行，$2^n$ 个数 $A_0, A_1, \\ldots, A_{2^n-1}$。  \n第三行，$2^n$ 个数 $B_0, B_1, \\ldots, B_{2^n-1}$。\n", "outputFormat": "三行，每行 $2^n$ 个数，分别代表 $\\oplus$ 是 or, and, xor 时 $C_0, C_1, \\ldots, C_{2^n-1}$ 的值 $\\bmod\\ 998244353$。\n", "hint": "$1 \\le n \\le 17$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Fast Möbius / Walsh Transform (FMT / FWT).", "background": "", "description": "Given two sequences $A$ and $B$ of length $2^n$, define\n\n$$C_i=\\sum_{j\\oplus k = i}A_j \\times B_k$$\n\nCompute $C$ respectively when $\\oplus$ is OR, AND, and XOR.", "inputFormat": "The first line contains an integer $n$.  \nThe second line contains $2^n$ numbers $A_0, A_1, \\ldots, A_{2^n-1}$.  \nThe third line contains $2^n$ numbers $B_0, B_1, \\ldots, A_{2^n-1}$.", "outputFormat": "Output three lines. Each line contains $2^n$ numbers, representing the values of $C_0, C_1, \\ldots, C_{2^n-1}$ when $\\oplus$ is OR, AND, and XOR, respectively, taken $\\bmod\\ 998244353$.", "hint": "$1 \\le n \\le 17$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】快速莫比乌斯 / 沃尔什变换 (FMT / FWT)", "background": "", "description": "给定长度为 $2^n$ 两个序列 $A,B$，设 \n\n$$C_i=\\sum_{j\\oplus k = i}A_j \\times B_k$$\n\n分别当 $\\oplus$ 是 or, and, xor 时求出 $C$。", "inputFormat": "第一行，一个整数 $n$。  \n第二行，$2^n$ 个数 $A_0, A_1, \\ldots, A_{2^n-1}$。  \n第三行，$2^n$ 个数 $B_0, B_1, \\ldots, B_{2^n-1}$。\n", "outputFormat": "三行，每行 $2^n$ 个数，分别代表 $\\oplus$ 是 or, and, xor 时 $C_0, C_1, \\ldots, C_{2^n-1}$ 的值 $\\bmod\\ 998244353$。\n", "hint": "$1 \\le n \\le 17$。", "locale": "zh-CN"}}}
{"pid": "P4718", "type": "P", "difficulty": 6, "samples": [["6\n2\n13\n134\n8897\n1234567654321\n1000000000000", "Prime\nPrime\n67\n41\n4649\n5"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["数学", "递归", "素数判断,质数,筛法", "模板题"], "title": "【模板】Pollard-Rho", "background": "", "description": "Miller Rabin 算法是一种高效的质数判断方法。虽然是一种不确定的质数判断法，但是在选择多种底数的情况下，正确率是可以接受的。\n\nPollard rho 是一个非常玄学的方式，用于在 $O(n^{1/4})$ 的期望时间复杂度内计算合数 $n$ 的某个非平凡因子。事实上算法导论给出的是 $O(\\sqrt p)$，$p$ 是 $n$ 的某个最小因子，满足 $p$ 与 $n/p$ 互质。但是这些都是期望，未必符合实际。但事实上 Pollard rho 算法在实际环境中运行的相当不错。\n\n这里我们要写一个程序，对于每个数字检验是否是质数，是质数就输出 `Prime`；如果不是质数，输出它最大的质因子是哪个。", "inputFormat": "第一行，$T$ 代表数据组数（不大于 $350$）\n\n以下 $T$ 行，每行一个整数 $n$，保证 $2 \\le n \\le {10}^{18}$。", "outputFormat": "输出 $T$ 行。\n\n对于每组测试数据输出结果。", "hint": "2018.8.14 新加数据两组，时限加大到 2s，感谢 @whzzt\n\n2022.12.22 加入新的数据，感谢 @ftt2333 和 Library Checker\n\nby @will7101", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Pollard-Rho", "background": "", "description": "The Miller Rabin algorithm is an efficient method for primality testing. Although it is a probabilistic primality test, when multiple bases are chosen, the accuracy is acceptable.\n\nPollard rho is a rather “mystical” method used to find a non-trivial factor of a composite number $n$ in expected time complexity $O(n^{1/4})$. In fact, *Introduction to Algorithms* gives $O(\\sqrt p)$, where $p$ is the smallest factor of $n$, and $p$ is coprime with $n/p$. However, these are all expected results and may not match reality. In practice, the Pollard rho algorithm runs quite well.\n\nHere you need to write a program: for each number, check whether it is prime. If it is prime, output `Prime`; otherwise, output its largest prime factor.", "inputFormat": "The first line contains $T$, the number of test cases (not greater than $350$).\n\nThe next $T$ lines each contain an integer $n$, where $2 \\le n \\le {10}^{18}$ is guaranteed.", "outputFormat": "Output $T$ lines.\n\nFor each test case, output the result.", "hint": "On 2018.8.14, two new groups of testdata were added, and the time limit was increased to 2 s. Thanks to @whzzt.\n\nOn 2022.12.22, new testdata were added. Thanks to @ftt2333 and Library Checker.\n\nby @will7101.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】Pollard-Rho", "background": "", "description": "Miller Rabin 算法是一种高效的质数判断方法。虽然是一种不确定的质数判断法，但是在选择多种底数的情况下，正确率是可以接受的。\n\nPollard rho 是一个非常玄学的方式，用于在 $O(n^{1/4})$ 的期望时间复杂度内计算合数 $n$ 的某个非平凡因子。事实上算法导论给出的是 $O(\\sqrt p)$，$p$ 是 $n$ 的某个最小因子，满足 $p$ 与 $n/p$ 互质。但是这些都是期望，未必符合实际。但事实上 Pollard rho 算法在实际环境中运行的相当不错。\n\n这里我们要写一个程序，对于每个数字检验是否是质数，是质数就输出 `Prime`；如果不是质数，输出它最大的质因子是哪个。", "inputFormat": "第一行，$T$ 代表数据组数（不大于 $350$）\n\n以下 $T$ 行，每行一个整数 $n$，保证 $2 \\le n \\le {10}^{18}$。", "outputFormat": "输出 $T$ 行。\n\n对于每组测试数据输出结果。", "hint": "2018.8.14 新加数据两组，时限加大到 2s，感谢 @whzzt\n\n2022.12.22 加入新的数据，感谢 @ftt2333 和 Library Checker\n\nby @will7101", "locale": "zh-CN"}}}
{"pid": "P4719", "type": "P", "difficulty": 6, "samples": [["10 10\n-11 80 -99 -76 56 38 92 -51 -34 47 \n2 1\n3 1\n4 3\n5 2\n6 2\n7 1\n8 2\n9 4\n10 7\n9 -44\n2 -17\n2 98\n7 -58\n8 48\n3 99\n8 -61\n9 76\n9 14\n10 93\n", "186\n186\n190\n145\n189\n288\n244\n320\n258\n304"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["线段树", "O2优化", "树链剖分", "矩阵乘法", "动态 DP", "模板题"], "title": "【模板】动态 DP", "background": "", "description": "给定一棵 $n$ 个点的树，点带点权。\n\n有 $m$ 次操作，每次操作给定 $x,y$，表示修改点 $x$ 的权值为 $y$。\n\n你需要在每次操作之后求出这棵树的最大权独立集的权值大小。", "inputFormat": "第一行有两个整数，分别表示结点个数 $n$ 和操作个数 $m$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示节点 $i$ 的权值  $a_i$。\n\n接下来 $(n - 1)$ 行，每行两个整数 $u, v$，表示存在一条连接 $u$ 与 $v$ 的边。\n\n接下来 $m$ 行，每行两个整数 $x,y$，表示一次操作，修改点 $x$ 的权值为 $y$。", "outputFormat": "对于每次操作，输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n,m\\le 10$。\n- 对于 $60\\%$ 的数据，保证 $n,m\\le 10^3$。\n- 对于 $100\\%$ 的数据，保证 $1\\le n,m\\le 10^5$，$1 \\leq u, v , x \\leq n$，$-10^2 \\leq a_i, y \\leq 10^2$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Dynamic DP", "background": "", "description": "Given a tree with $n$ nodes, each node has a weight.\n\nThere are $m$ operations. In each operation, you are given $x, y$, which means changing the weight of node $x$ to $y$.\n\nAfter each operation, you need to output the total weight of the maximum weight independent set of this tree.", "inputFormat": "The first line contains two integers, representing the number of nodes $n$ and the number of operations $m$.\n\nThe second line contains $n$ integers. The $i$-th integer is the weight $a_i$ of node $i$.\n\nIn the next $(n - 1)$ lines, each line contains two integers $u, v$, indicating that there is an edge connecting $u$ and $v$.\n\nIn the next $m$ lines, each line contains two integers $x, y$, indicating an operation that changes the weight of node $x$ to $y$.", "outputFormat": "For each operation, output one line with one integer representing the answer.", "hint": "#### Constraints\n\n- For $30\\%$ of the testdata, $n, m \\le 10$.\n- For $60\\%$ of the testdata, $n, m \\le 10^3$.\n- For $100\\%$ of the testdata, $1 \\le n, m \\le 10^5$, $1 \\leq u, v, x \\leq n$, and $-10^2 \\leq a_i, y \\leq 10^2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】动态 DP", "background": "", "description": "给定一棵 $n$ 个点的树，点带点权。\n\n有 $m$ 次操作，每次操作给定 $x,y$，表示修改点 $x$ 的权值为 $y$。\n\n你需要在每次操作之后求出这棵树的最大权独立集的权值大小。", "inputFormat": "第一行有两个整数，分别表示结点个数 $n$ 和操作个数 $m$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示节点 $i$ 的权值  $a_i$。\n\n接下来 $(n - 1)$ 行，每行两个整数 $u, v$，表示存在一条连接 $u$ 与 $v$ 的边。\n\n接下来 $m$ 行，每行两个整数 $x,y$，表示一次操作，修改点 $x$ 的权值为 $y$。", "outputFormat": "对于每次操作，输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n,m\\le 10$。\n- 对于 $60\\%$ 的数据，保证 $n,m\\le 10^3$。\n- 对于 $100\\%$ 的数据，保证 $1\\le n,m\\le 10^5$，$1 \\leq u, v , x \\leq n$，$-10^2 \\leq a_i, y \\leq 10^2$。\n", "locale": "zh-CN"}}}
{"pid": "P4720", "type": "P", "difficulty": 6, "samples": [["5 3 3", "1"], ["666 233 123456", "61728"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["中国剩余定理 CRT", "逆元", "Lucas 定理", "模板题"], "title": "【模板】扩展卢卡斯定理 / exLucas", "background": "这是一道模板题。", "description": "求\n\n$${\\mathrm{C}}_n^m \\bmod{p}$$\n\n其中 $\\mathrm{C}$ 为组合数。", "inputFormat": "一行三个整数 $n,m,p$ ，含义由题所述。", "outputFormat": "一行一个整数，表示答案。", "hint": "对于 $100 \\%$ 的数据，$1 \\le m \\le n \\le {10}^{18}$，$2 \\le p \\le {10}^6$，**不保证** $p$ 是质数。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Extended Lucas Theorem / exLucas", "background": "This is a template problem.", "description": "Compute\n\n$${\\mathrm{C}}_n^m \\bmod{p}$$\n\nwhere $\\mathrm{C}$ is the binomial coefficient.", "inputFormat": "One line with three integers $n, m, p$, with meanings as described in the statement.", "outputFormat": "Output one integer in one line, representing the answer.", "hint": "For $100\\%$ of the testdata, $1 \\le m \\le n \\le {10}^{18}$, $2 \\le p \\le {10}^6$, and it is **not guaranteed** that $p$ is a prime number.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】扩展卢卡斯定理 / exLucas", "background": "这是一道模板题。", "description": "求\n\n$${\\mathrm{C}}_n^m \\bmod{p}$$\n\n其中 $\\mathrm{C}$ 为组合数。", "inputFormat": "一行三个整数 $n,m,p$ ，含义由题所述。", "outputFormat": "一行一个整数，表示答案。", "hint": "对于 $100 \\%$ 的数据，$1 \\le m \\le n \\le {10}^{18}$，$2 \\le p \\le {10}^6$，**不保证** $p$ 是质数。", "locale": "zh-CN"}}}
{"pid": "P4721", "type": "P", "difficulty": 6, "samples": [["4\n3 1 2", "1 3 10 35"], ["10\n2 456 32 13524543 998244352 0 1231 634544 51", "1 2 460 1864 13738095 55389979 617768468 234028967 673827961 708520894"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["分治", "生成函数", "快速傅里叶变换 FFT", "快速数论变换 NTT", "模板题"], "title": "【模板】分治 FFT", "background": "也可用多项式求逆解决。", "description": "给定序列 $g_{1\\dots n - 1}$，求序列 $f_{0\\dots n - 1}$。\n\n其中 $f_i=\\sum_{j=1}^if_{i-j}g_j$，边界为 $f_0=1$。\n\n答案对 $998244353$ 取模。", "inputFormat": "第一行一个整数 $n$ 。\n\n第二行 $n-1$ 个整数 $g_{1\\dots n - 1}$。", "outputFormat": "一行 $n$ 个整数，表示 $f_{0\\dots n - 1}$ 对 $998244353$ 取模后的值。", "hint": "$2\\leq n\\leq 10^5$，$0\\leq g_i<998244353$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Divide and Conquer FFT", "background": "It can also be solved using polynomial inversion.", "description": "Given a sequence $g_{1\\dots n - 1}$, find the sequence $f_{0\\dots n - 1}$.\n\nHere, $f_i=\\sum_{j=1}^if_{i-j}g_j$, with the boundary condition $f_0=1$.\n\nTake the answer modulo $998244353$.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n-1$ integers $g_{1\\dots n - 1}$.", "outputFormat": "Output one line with $n$ integers, representing the values of $f_{0\\dots n - 1}$ modulo $998244353$.", "hint": "Constraints: $2\\leq n\\leq 10^5$, $0\\leq g_i<998244353$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】分治 FFT", "background": "也可用多项式求逆解决。", "description": "给定序列 $g_{1\\dots n - 1}$，求序列 $f_{0\\dots n - 1}$。\n\n其中 $f_i=\\sum_{j=1}^if_{i-j}g_j$，边界为 $f_0=1$。\n\n答案对 $998244353$ 取模。", "inputFormat": "第一行一个整数 $n$ 。\n\n第二行 $n-1$ 个整数 $g_{1\\dots n - 1}$。", "outputFormat": "一行 $n$ 个整数，表示 $f_{0\\dots n - 1}$ 对 $998244353$ 取模后的值。", "hint": "$2\\leq n\\leq 10^5$，$0\\leq g_i<998244353$。", "locale": "zh-CN"}}}
{"pid": "P4722", "type": "P", "difficulty": 6, "samples": [["7 14 1 7\n1 2 5\n1 3 6\n1 4 5\n2 3 2\n2 5 3\n3 2 2\n3 4 3\n3 5 3\n3 6 7\n4 6 5\n5 6 1\n6 5 1\n5 7 8\n6 7 7\n", "14"], ["10 16 1 2\n1 3 2\n1 4 2\n5 2 2\n6 2 2\n3 5 1\n3 6 1\n4 5 1\n4 6 1\n1 7 2147483647\n9 2 2147483647\n7 8 2147483647\n10 9 2147483647\n8 5 2\n8 6 2\n3 10 2\n4 10 2\n", "8"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["网络流", "O2优化", "优先队列", "队列", "模板题"], "title": "【模板】最大流 加强版 / 预流推进", "background": "", "description": "给定 $n$ 个点，$m$ 条有向边，给定每条边的容量，求从点 $s$ 到点 $t$ 的最大流。", "inputFormat": "第一行包含四个正整数 $n$、$m$、$s$、$t$，用空格分隔，分别表示点的个数、有向边的个数、源点序号、汇点序号。\n\n接下来 $m$ 行每行包含三个正整数 $u_i$、$v_i$、$c_i$，用空格分隔，表示第 $i$ 条有向边从 $u_i$ 出发，到达 $v_i$，容量为 $c_i$。", "outputFormat": "一个整数，表示 $s$ 到 $t$ 的最大流。", "hint": "$1\\leqslant n \\leqslant 1200, 1\\leqslant m \\leqslant 120000, 1\\leqslant c \\leqslant 2^{31}-1$。\n\n保证答案不超过 $2^{31}-1$。\n\n常用网络流算法的复杂度为 $O(n^2 m)$，请尽量优化算法。\n\n数据提供者：@negiizhao\n\n（如果有人用 dinic 算法过掉了此题，请私信上传者）", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Maximum Flow Enhanced / Push-Relabel", "background": "", "description": "Given $n$ vertices and $m$ directed edges, with a capacity on each edge, find the maximum flow from vertex $s$ to vertex $t$.", "inputFormat": "The first line contains four positive integers $n$, $m$, $s$, $t$, separated by spaces, representing the number of vertices, the number of directed edges, the source vertex index, and the sink vertex index.\n\nThe next $m$ lines each contain three positive integers $u_i$, $v_i$, $c_i$, separated by spaces, meaning that the $i$-th directed edge starts from $u_i$, ends at $v_i$, and has capacity $c_i$.", "outputFormat": "Output one integer, the maximum flow from $s$ to $t$.", "hint": "Constraints: $1\\leqslant n \\leqslant 1200$, $1\\leqslant m \\leqslant 120000$, $1\\leqslant c \\leqslant 2^{31}-1$.\n\nIt is guaranteed that the answer does not exceed $2^{31}-1$.\n\nThe time complexity of common network flow algorithms is $O(n^2 m)$, so please optimize your algorithm as much as possible.\n\ntestdata provider: @negiizhao.\n\n(If anyone passes this problem using Dinic’s algorithm, please send a private message to the uploader.)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】最大流 加强版 / 预流推进", "background": "", "description": "给定 $n$ 个点，$m$ 条有向边，给定每条边的容量，求从点 $s$ 到点 $t$ 的最大流。", "inputFormat": "第一行包含四个正整数 $n$、$m$、$s$、$t$，用空格分隔，分别表示点的个数、有向边的个数、源点序号、汇点序号。\n\n接下来 $m$ 行每行包含三个正整数 $u_i$、$v_i$、$c_i$，用空格分隔，表示第 $i$ 条有向边从 $u_i$ 出发，到达 $v_i$，容量为 $c_i$。", "outputFormat": "一个整数，表示 $s$ 到 $t$ 的最大流。", "hint": "$1\\leqslant n \\leqslant 1200, 1\\leqslant m \\leqslant 120000, 1\\leqslant c \\leqslant 2^{31}-1$。\n\n保证答案不超过 $2^{31}-1$。\n\n常用网络流算法的复杂度为 $O(n^2 m)$，请尽量优化算法。\n\n数据提供者：@negiizhao\n\n（如果有人用 dinic 算法过掉了此题，请私信上传者）", "locale": "zh-CN"}}}
{"pid": "P4723", "type": "P", "difficulty": 7, "samples": [["6 4\n3 -1 0 4\n-2 3 1 5", "73"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144]}, "tags": ["递推", "线性递推", "向量", "模板题"], "title": "【模板】常系数齐次线性递推", "background": "", "description": "求一个满足 $k$ 阶齐次线性递推数列 ${a_i}$ 的第 $n$ 项，即：\n\n$$a_n=\\sum\\limits_{i=1}^{k}f_i \\times a_{n-i}$$", "inputFormat": "第一行两个数 $n$,$k$，如题面所述。\n\n第二行 $k$ 个数，表示 $f_1 \\ f_2 \\ \\cdots \\ f_k$\n\n第三行 $k$ 个数，表示 $a_0 \\ a_1 \\ \\cdots \\ a_{k-1}$", "outputFormat": "一个数，表示 $a_n \\bmod 998244353$ 的值", "hint": "$N = 10^{9} , K = 32000 $\n\n保证读入的数字均为 $[-10^9,10^9]$ 内的整数。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Constant-Coefficient Homogeneous Linear Recurrence.", "background": "", "description": "Find the $n$-th term of a $k$-th order homogeneous linear recurrence sequence $\\{a_i\\}$, that is:\n\n$$a_n=\\sum\\limits_{i=1}^{k}f_i \\times a_{n-i}$$", "inputFormat": "The first line contains two integers $n$ and $k$, as described in the statement.\n\nThe second line contains $k$ integers, representing $f_1 \\ f_2 \\ \\cdots \\ f_k$.\n\nThe third line contains $k$ integers, representing $a_0 \\ a_1 \\ \\cdots \\ a_{k-1}$.", "outputFormat": "Output one integer, the value of $a_n \\bmod 998244353$.", "hint": "Constraints: $N = 10^{9}$, $K = 32000$.\n\nIt is guaranteed that all input numbers are integers in the range $[-10^9,10^9]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】常系数齐次线性递推", "background": "", "description": "求一个满足 $k$ 阶齐次线性递推数列 ${a_i}$ 的第 $n$ 项，即：\n\n$$a_n=\\sum\\limits_{i=1}^{k}f_i \\times a_{n-i}$$", "inputFormat": "第一行两个数 $n$,$k$，如题面所述。\n\n第二行 $k$ 个数，表示 $f_1 \\ f_2 \\ \\cdots \\ f_k$\n\n第三行 $k$ 个数，表示 $a_0 \\ a_1 \\ \\cdots \\ a_{k-1}$", "outputFormat": "一个数，表示 $a_n \\bmod 998244353$ 的值", "hint": "$N = 10^{9} , K = 32000 $\n\n保证读入的数字均为 $[-10^9,10^9]$ 内的整数。", "locale": "zh-CN"}}}
{"pid": "P4724", "type": "P", "difficulty": 7, "samples": [["4 \n0 0 0\n1 0 0\n0 1 0\n0 0 1", "2.366"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "三维计算几何", "模板题"], "title": "【模板】三维凸包", "background": "", "description": "给出空间中 $n$ 个点，求凸包表面积。", "inputFormat": "第一行一个整数 $n$，表示点数。\n\n接下来 $n$ 行，每行三个实数 $x, y, z$ 描述坐标。\n", "outputFormat": "输出凸包表面积，保留 $3$ 位小数。", "hint": "$4 \\le n \\le 2000$", "locale": "zh-CN", "translations": {"en": {"title": "[Template] 3D Convex Hull", "background": "", "description": "Given $n$ points in 3D space, find the surface area of their convex hull.", "inputFormat": "The first line contains an integer $n$, which is the number of points.\n\nThe next $n$ lines each contain three real numbers $x, y, z$, describing the coordinates.", "outputFormat": "Output the surface area of the convex hull, rounded to $3$ decimal places.", "hint": "$4 \\le n \\le 2000$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】三维凸包", "background": "", "description": "给出空间中 $n$ 个点，求凸包表面积。", "inputFormat": "第一行一个整数 $n$，表示点数。\n\n接下来 $n$ 行，每行三个实数 $x, y, z$ 描述坐标。\n", "outputFormat": "输出凸包表面积，保留 $3$ 位小数。", "hint": "$4 \\le n \\le 2000$", "locale": "zh-CN"}}}
{"pid": "P4725", "type": "P", "difficulty": 6, "samples": [["6\n1 927384623 878326372 3882 273455637 998233543", "0 927384623 817976920 427326948 149643566 610586717"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "洛谷原创", "O2优化", "导数", "积分", "快速傅里叶变换 FFT", "快速数论变换 NTT", "模板题"], "title": "【模板】多项式对数函数（多项式 ln）", "background": null, "description": "给出 $n-1$ 次多项式 $A(x)$，求一个 $\\bmod{\\:x^n}$ 下的多项式 $B(x)$，满足 $B(x) \\equiv \\ln A(x)$。\n\n在 $\\text{mod } 998244353$ 意义下进行，且 $a_i \\in [0, 998244353) \\cap \\mathbb{Z}$。", "inputFormat": "第一行一个整数 $n$。\n\n下一行有 $n$ 个整数，依次表示多项式的系数 $a_0, a_1, \\cdots, a_{n-1}$。\n\n保证 $a_0 = 1$。", "outputFormat": "输出 $n$ 个整数，表示答案多项式中的系数 $a_0, a_1, \\cdots, a_{n-1}$。", "hint": "对于 $100\\%$ 的数据，$n \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Polynomial Logarithm Function (Polynomial $\\ln$).", "background": "", "description": "Given a polynomial $A(x)$ of degree $n - 1$, find a polynomial $B(x)$ modulo $x^n$ such that $B(x) \\equiv \\ln A(x)$.\n\nAll computations are done modulo $998244353$, and $a_i \\in [0, 998244353) \\cap \\mathbb{Z}$.", "inputFormat": "The first line contains an integer $n$.\n\nThe next line contains $n$ integers, which are the coefficients $a_0, a_1, \\cdots, a_{n-1}$ of the polynomial in order.\n\nIt is guaranteed that $a_0 = 1$.", "outputFormat": "Output $n$ integers, which are the coefficients $a_0, a_1, \\cdots, a_{n-1}$ of the answer polynomial in order.", "hint": "For $100\\%$ of the data, $n \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】多项式对数函数（多项式 ln）", "background": null, "description": "给出 $n-1$ 次多项式 $A(x)$，求一个 $\\bmod{\\:x^n}$ 下的多项式 $B(x)$，满足 $B(x) \\equiv \\ln A(x)$。\n\n在 $\\text{mod } 998244353$ 意义下进行，且 $a_i \\in [0, 998244353) \\cap \\mathbb{Z}$。", "inputFormat": "第一行一个整数 $n$。\n\n下一行有 $n$ 个整数，依次表示多项式的系数 $a_0, a_1, \\cdots, a_{n-1}$。\n\n保证 $a_0 = 1$。", "outputFormat": "输出 $n$ 个整数，表示答案多项式中的系数 $a_0, a_1, \\cdots, a_{n-1}$。", "hint": "对于 $100\\%$ 的数据，$n \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4726", "type": "P", "difficulty": 6, "samples": [["6\n0 927384623 817976920 427326948 149643566 610586717", "1 927384623 878326372 3882 273455637 998233543"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["倍增", "递归", "O2优化", "快速傅里叶变换 FFT", "快速数论变换 NTT", "模板题"], "title": "【模板】多项式指数函数（多项式 exp）", "background": "", "description": "给出 $n-1$ 次多项式 $A(x)$，求一个 $\\bmod{\\:x^n}$ 下的多项式 $B(x)$，满足 $B(x) \\equiv \\text e^{A(x)}$。系数对 $998244353$ 取模。", "inputFormat": "第一行一个整数 $n$.\n\n下一行有 $n$ 个整数，依次表示多项式的系数 $a_0, a_1, \\cdots, a_{n-1}$.\n\n保证 $a_0 = 0$.", "outputFormat": "输出 $n$ 个整数，表示答案多项式中的系数 $a_0, a_1, \\cdots, a_{n-1}$.", "hint": "对于 $100\\%$ 的数据，$n \\le 10^5$.", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Polynomial Exponential Function (Polynomial exp).", "background": "", "description": "Given a polynomial $A(x)$ of degree $n - 1$, find a polynomial $B(x)$ modulo $x^n$ such that $B(x) \\equiv \\text e^{A(x)}$. All coefficients are taken modulo $998244353$.", "inputFormat": "The first line contains an integer $n$.\n\nThe next line contains $n$ integers, representing the coefficients $a_0, a_1, \\cdots, a_{n-1}$ of the polynomial in order.\n\nIt is guaranteed that $a_0 = 0$.", "outputFormat": "Output $n$ integers, representing the coefficients $a_0, a_1, \\cdots, a_{n-1}$ of the answer polynomial.", "hint": "For $100\\%$ of the testdata, $n \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】多项式指数函数（多项式 exp）", "background": "", "description": "给出 $n-1$ 次多项式 $A(x)$，求一个 $\\bmod{\\:x^n}$ 下的多项式 $B(x)$，满足 $B(x) \\equiv \\text e^{A(x)}$。系数对 $998244353$ 取模。", "inputFormat": "第一行一个整数 $n$.\n\n下一行有 $n$ 个整数，依次表示多项式的系数 $a_0, a_1, \\cdots, a_{n-1}$.\n\n保证 $a_0 = 0$.", "outputFormat": "输出 $n$ 个整数，表示答案多项式中的系数 $a_0, a_1, \\cdots, a_{n-1}$.", "hint": "对于 $100\\%$ 的数据，$n \\le 10^5$.", "locale": "zh-CN"}}}
{"pid": "P4727", "type": "P", "difficulty": 7, "samples": [["1", "1"], ["2", "2"], ["3", "4"], ["5", "34"], ["9", "493"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2009", "各省省选", "湖南", "群论", "置换", "Pólya 定理", "逆元"], "title": "[HNOI2009] 图的同构计数", "background": "当学生们遇到某个难题时经常会说“这怎么做，这不是 NP 问题吗？”、“这个只有搜了，这己经被证明是 NP 问题了”。但是，你应该清楚，大多数人此时所说的 NP 问题其实都是指 NPC 问题。很多人没有真正掌握 NP 问题和 NPC 问题这两个基本概念。其实 NP 问题并不是那种“只有搜才行”的问题，NPC 问题才是。\n\n很久以前就有一个古老的传说：有―个著名的问题，即 P 是否等于 NP 的问题，传说中谁要是证明或者证伪了这个命题，他将获得幸福。这里 P 是指能在多项式时间里求解的问题的集合。而 NP 是指可在多项式时间里验证的问题的集合。显然 P 是 NP 的子集，因为能在多项式时间里求解的问题，必定可在多项式时间里验证。\n\n到目前为止还没有人因这个命题得到幸福。但是，有一个总的趋势，也就是人们普遍认为，$P=NP$ 不成立，即，多数人相信，至少存在一个不可能有多项式时间复杂度的求解算法的 NP 问题。人们如此坚信 $P \\neq NP$ 是有原因的，因为在研究 NP 问题的过程中找出了一类非常特殊的 NP 问题叫做 NP-完全问题，也就是所谓的 NPC 问题。正是因为存在 NPC 问题，才使人们相信 $P \\neq NP$。\n\n在提出 NPC 的概念之后，绝大多数“自然”的难题最后都被证明是 NPC 问题，只有三个例外，它们分别是：\n\n- 线性规划问题；\n- 图同构问题；\n- 素数判定问题与大数分解问题。", "description": "小雪在了解到以上情况后，自认为直接挑战终极难题还有不少困难，于是决定先从简单的问题做起，具体来说，他对图同构问题产生了浓厚的兴趣。$A$ 图与 $B$ 图被认为是同构的是指：$A$ 图的顶点经过一定的重新标号以后，$A$ 图的顶点集和边集要完全与 $B$ 图一一对应。\n\n小雪现在专注于如何判断两个图是否同构，同时他还想知道两两互不同构的含 $N$ 个点的图有多少种。众所周知含 $N$ 个点的简单图最多有 $N\\times(N-1)/2$ 条边，这样含 $N$ 个点的图有 $2^{N\\times(N-1)/2}$ 种可能的情况。显然这些图中有很多图是同构的，小雪想知道的便是：若同构的图算成一种，则有多少种不同的图。他把这个任务丢给了你，在他想出来之前快点解决吧！", "inputFormat": "输入包含一个非负整数 $N$，表示图的顶点数，且 $0 \\leq N \\leq 60$。", "outputFormat": "输出包含一个整数，表示含 $N$ 个点的图在同构意义下不同构的图的数目。因为答案可能很大，所以输出的最终答案是 $\\bmod ~ 997$ 的结果（$997$ 是一个素数）。", "hint": "对于 $40 \\%$ 的数据，$N \\le 20$。  \n对于 $100 \\%$ 的数据，$0 \\le N \\le 60$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2009] Counting Graph Isomorphism Classes", "background": "When students run into a hard problem, they often say, “How can this be done? Isn’t this an NP problem?”, or “You can only search; this has already been proved to be an NP problem.” However, you should know that what most people call an NP problem in such cases actually refers to an NPC problem. Many people have not truly understood the two basic concepts: NP problems and NPC problems. In fact, an NP problem is not the kind of problem that “can only be solved by searching”; NPC problems are.\n\nLong ago, there was an old legend: there is a famous question, namely whether $P$ equals $NP$. In the legend, whoever proves or disproves this statement will obtain happiness. Here, $P$ refers to the set of problems that can be solved in polynomial time. $NP$ refers to the set of problems whose solutions can be verified in polynomial time. Clearly, $P$ is a subset of $NP$, because any problem solvable in polynomial time must also be verifiable in polynomial time.\n\nSo far, no one has obtained happiness because of this statement. However, there is a general trend: people commonly believe that $P=NP$ does not hold. That is, most people believe that there exists at least one NP problem that cannot have a polynomial-time algorithm. People are so convinced that $P \\neq NP$ for a reason: during the study of NP problems, researchers found a very special class of NP problems called NP-complete problems, i.e., the so-called NPC problems. It is precisely because NPC problems exist that people believe $P \\neq NP$.\n\nAfter the concept of NPC was proposed, almost all “natural” hard problems were eventually proved to be NPC problems, with only three exceptions:\n\n- Linear programming;\n- Graph isomorphism;\n- Primality testing and integer factorization.", "description": "After learning the above, Xiaoxue felt that directly challenging the ultimate problem was still quite difficult, so he decided to start with simpler problems. Specifically, he became very interested in the graph isomorphism problem. Graph $A$ and graph $B$ are considered isomorphic if, after relabeling the vertices of graph $A$ in some way, the vertex set and edge set of $A$ correspond exactly one-to-one with those of $B$.\n\nXiaoxue is now focused on how to determine whether two graphs are isomorphic. At the same time, he also wants to know how many pairwise non-isomorphic graphs with $N$ vertices there are. It is well known that a simple graph with $N$ vertices has at most $N\\times(N-1)/2$ edges, so there are $2^{N\\times(N-1)/2}$ possible graphs with $N$ vertices. Clearly, many of these graphs are isomorphic. What Xiaoxue wants to know is: if we count isomorphic graphs as one, how many different graphs are there? He threw this task to you—solve it quickly before he figures it out!", "inputFormat": "The input contains a non-negative integer $N$, representing the number of vertices of the graph, and $0 \\leq N \\leq 60$.", "outputFormat": "Output one integer, representing the number of graphs with $N$ vertices that are non-isomorphic under isomorphism. Since the answer may be very large, output the final result $\\bmod ~ 997$ ($997$ is a prime).", "hint": "For $40\\%$ of the testdata, $N \\le 20$.  \nFor $100\\%$ of the testdata, $0 \\le N \\le 60$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2009] 图的同构计数", "background": "当学生们遇到某个难题时经常会说“这怎么做，这不是 NP 问题吗？”、“这个只有搜了，这己经被证明是 NP 问题了”。但是，你应该清楚，大多数人此时所说的 NP 问题其实都是指 NPC 问题。很多人没有真正掌握 NP 问题和 NPC 问题这两个基本概念。其实 NP 问题并不是那种“只有搜才行”的问题，NPC 问题才是。\n\n很久以前就有一个古老的传说：有―个著名的问题，即 P 是否等于 NP 的问题，传说中谁要是证明或者证伪了这个命题，他将获得幸福。这里 P 是指能在多项式时间里求解的问题的集合。而 NP 是指可在多项式时间里验证的问题的集合。显然 P 是 NP 的子集，因为能在多项式时间里求解的问题，必定可在多项式时间里验证。\n\n到目前为止还没有人因这个命题得到幸福。但是，有一个总的趋势，也就是人们普遍认为，$P=NP$ 不成立，即，多数人相信，至少存在一个不可能有多项式时间复杂度的求解算法的 NP 问题。人们如此坚信 $P \\neq NP$ 是有原因的，因为在研究 NP 问题的过程中找出了一类非常特殊的 NP 问题叫做 NP-完全问题，也就是所谓的 NPC 问题。正是因为存在 NPC 问题，才使人们相信 $P \\neq NP$。\n\n在提出 NPC 的概念之后，绝大多数“自然”的难题最后都被证明是 NPC 问题，只有三个例外，它们分别是：\n\n- 线性规划问题；\n- 图同构问题；\n- 素数判定问题与大数分解问题。", "description": "小雪在了解到以上情况后，自认为直接挑战终极难题还有不少困难，于是决定先从简单的问题做起，具体来说，他对图同构问题产生了浓厚的兴趣。$A$ 图与 $B$ 图被认为是同构的是指：$A$ 图的顶点经过一定的重新标号以后，$A$ 图的顶点集和边集要完全与 $B$ 图一一对应。\n\n小雪现在专注于如何判断两个图是否同构，同时他还想知道两两互不同构的含 $N$ 个点的图有多少种。众所周知含 $N$ 个点的简单图最多有 $N\\times(N-1)/2$ 条边，这样含 $N$ 个点的图有 $2^{N\\times(N-1)/2}$ 种可能的情况。显然这些图中有很多图是同构的，小雪想知道的便是：若同构的图算成一种，则有多少种不同的图。他把这个任务丢给了你，在他想出来之前快点解决吧！", "inputFormat": "输入包含一个非负整数 $N$，表示图的顶点数，且 $0 \\leq N \\leq 60$。", "outputFormat": "输出包含一个整数，表示含 $N$ 个点的图在同构意义下不同构的图的数目。因为答案可能很大，所以输出的最终答案是 $\\bmod ~ 997$ 的结果（$997$ 是一个素数）。", "hint": "对于 $40 \\%$ 的数据，$N \\le 20$。  \n对于 $100 \\%$ 的数据，$0 \\le N \\le 60$。", "locale": "zh-CN"}}}
{"pid": "P4728", "type": "P", "difficulty": 5, "samples": [["2\n6 3 1 4 5 8 7\n6 3 2 1 6 5 4", "Yes!\nNo!"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "各省省选", "湖南"], "title": "[HNOI2009] 双递增序列", "background": "", "description": "考虑一个长度为偶数 $n$ 的序列 $a_1, a_2, \\dots, a_n$，我们称这个序列为好的，当且仅当存在 $a_1, a_2, \\dots, a_n$ 的一个划分 $U=\\{ a_{i_1}, a_{i_2}, \\dots, a_{i_{n/2}} \\}, V=\\{ a_{j_1}, a_{j_2}, \\dots, a_{j_{n/2}} \\}=\\{ a_1, a_2, \\dots, a_n \\}-U$，且 $i_1<i_2< \\dots <i_{n/2}, a_{i_1}<a_{i_2}< \\dots <a_{i_{n/2}}, j_1<j_2< \\dots <j_{n/2}, a_{j_1}<a_{j_2}< \\dots <a_{j_{n/2}}$。\n\n比如序列 $3, 1, 4, 5, 8, 7$ 就是一个好的序列。因为它可以分成 $U=\\{3, 4, 8\\}, V=\\{1, 5, 7\\}$。而序列 $3, 2, 1, 6, 5, 4$ 则不是一个好的序列。\n\n现在的问题是，针对给出的若干序列，请你判断它们是否是好的序列。\n", "inputFormat": "第一行仅包含一个整数 $m$，表示需要判断 $m$ 个序列。  \n接下来的 $m$ 行分别给出这些序列。每个序列的输入为一行，每行的第一个数为一个偶数 $n$，表示序列的长度，随后的 $n$ 个整数表示序列本身的元素 $a_1, a_2, \\dots, a_n$。同一行的各数之间用一个空格隔开。", "outputFormat": "输出 $m$ 行，如果第 $i$ 个序列为好的序列，那么第 $i$ 行输出`Yes!`，否则输出 `No!`。", "hint": "对于 $10\\%$ 的数据，$n \\le 100$。  \n对于 $40\\%$ 的数据，$n \\le 300$。  \n对于 $100\\%$ 的数据，$1 \\le n \\leq 2000$，$1 \\le m \\leq 25$，$0 \\le a_i \\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2009] Double Increasing Sequences", "background": "", "description": "Consider a sequence $a_1, a_2, \\dots, a_n$ of even length $n$. We call this sequence good if and only if there exists a partition of $a_1, a_2, \\dots, a_n$ into two sets\n$U=\\{ a_{i_1}, a_{i_2}, \\dots, a_{i_{n/2}} \\}$ and $V=\\{ a_{j_1}, a_{j_2}, \\dots, a_{j_{n/2}} \\}=\\{ a_1, a_2, \\dots, a_n \\}-U$,\nsuch that\n$i_1<i_2< \\dots <i_{n/2}$, $a_{i_1}<a_{i_2}< \\dots <a_{i_{n/2}}$, $j_1<j_2< \\dots <j_{n/2}$, and $a_{j_1}<a_{j_2}< \\dots <a_{j_{n/2}}$.\n\nFor example, the sequence $3, 1, 4, 5, 8, 7$ is a good sequence, because it can be split into $U=\\{3, 4, 8\\}$ and $V=\\{1, 5, 7\\}$. However, the sequence $3, 2, 1, 6, 5, 4$ is not a good sequence.\n\nNow, for several given sequences, please determine whether each of them is a good sequence.", "inputFormat": "The first line contains only one integer $m$, indicating that you need to judge $m$ sequences.  \nThe next $m$ lines give these sequences. Each sequence is given on one line: the first number is an even integer $n$, indicating the length of the sequence, and the following $n$ integers are the elements of the sequence $a_1, a_2, \\dots, a_n$. Numbers on the same line are separated by a single space.", "outputFormat": "Output $m$ lines. If the $i$-th sequence is a good sequence, output `Yes!` on the $i$-th line; otherwise, output `No!`.", "hint": "For $10\\%$ of the testdata, $n \\le 100$.  \nFor $40\\%$ of the testdata, $n \\le 300$.  \nFor $100\\%$ of the testdata, $1 \\le n \\leq 2000$, $1 \\le m \\leq 25$, $0 \\le a_i \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2009] 双递增序列", "background": "", "description": "考虑一个长度为偶数 $n$ 的序列 $a_1, a_2, \\dots, a_n$，我们称这个序列为好的，当且仅当存在 $a_1, a_2, \\dots, a_n$ 的一个划分 $U=\\{ a_{i_1}, a_{i_2}, \\dots, a_{i_{n/2}} \\}, V=\\{ a_{j_1}, a_{j_2}, \\dots, a_{j_{n/2}} \\}=\\{ a_1, a_2, \\dots, a_n \\}-U$，且 $i_1<i_2< \\dots <i_{n/2}, a_{i_1}<a_{i_2}< \\dots <a_{i_{n/2}}, j_1<j_2< \\dots <j_{n/2}, a_{j_1}<a_{j_2}< \\dots <a_{j_{n/2}}$。\n\n比如序列 $3, 1, 4, 5, 8, 7$ 就是一个好的序列。因为它可以分成 $U=\\{3, 4, 8\\}, V=\\{1, 5, 7\\}$。而序列 $3, 2, 1, 6, 5, 4$ 则不是一个好的序列。\n\n现在的问题是，针对给出的若干序列，请你判断它们是否是好的序列。\n", "inputFormat": "第一行仅包含一个整数 $m$，表示需要判断 $m$ 个序列。  \n接下来的 $m$ 行分别给出这些序列。每个序列的输入为一行，每行的第一个数为一个偶数 $n$，表示序列的长度，随后的 $n$ 个整数表示序列本身的元素 $a_1, a_2, \\dots, a_n$。同一行的各数之间用一个空格隔开。", "outputFormat": "输出 $m$ 行，如果第 $i$ 个序列为好的序列，那么第 $i$ 行输出`Yes!`，否则输出 `No!`。", "hint": "对于 $10\\%$ 的数据，$n \\le 100$。  \n对于 $40\\%$ 的数据，$n \\le 300$。  \n对于 $100\\%$ 的数据，$1 \\le n \\leq 2000$，$1 \\le m \\leq 25$，$0 \\le a_i \\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4729", "type": "P", "difficulty": 6, "samples": [["6\n1 3 2\n4 7 2\n2 5 1\n3 6 1\n8 11 2\n6 8 3", "0\n0\n1\n0\n0\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2009", "线段树", "各省省选", "湖南", "平面图欧拉公式"], "title": "[HNOI2009] 积木游戏", "background": "", "description": "丹丹是一位狂热的俄罗斯方块爱好者，但在把积分刷爆之后她终于开始感到厌倦了。于是她着手思考这样一个俄罗斯方块的简化版游戏：在初始状态地面上是空的。假设所有的积木都是长方形，且积木不能旋转或翻转。丹丹在每个时刻会选择一个位置将一块积木落下，当积木在落下的过程中碰到地面或另一块积木时，它会停留在地面上或那块积木上。落到另—块积木上意味着：上面的积木的下边界与下面的积木的上边界至少有一条线段重合(―个点不算)，如图 1 所示。\n\n![图1](https://cdn.luogu.com.cn/upload/pic/22107.png)\n\n在俄罗斯方块中，如果某个时刻积木之间形成了一个洞，那么看上去就很不优美。于是丹丹想知道，每落下一块积木之后，会形成几个新的洞。一个洞是指由积木的边界或地面组成的一块面积大于 $0$ 的封闭的区域，如图 2（a）和图 2（b）所示。\n\n要注意的是：当出现图 3 所示的情况时，因为积木 1 和积木 2 紧紧地挨在一起，所以当积木 3 落下的时候，不会形成新的洞。\n\n现在丹丹告诉你她依次落下的积木的髙度 $H_i$ 以及落下的位置的左右边界 $L_i$ 与 $R_i$，$1 \\leq i \\leq n$，而她想知道毎次积木落下时会形成几个新的洞？\n\n![图23](https://cdn.luogu.com.cn/upload/pic/22108.png)", "inputFormat": "第一行包含一个正整数 $n$，表示落下的积木的总数。接下来有$n$行，每行有用一个空格隔开的三个整数，分别表示 $L_i$、$R_i$ 和 $H_i$，即积木落下的左右边界和积木的高度。", "outputFormat": "包含 $n$ 行，每行只有一个数，第 $i$ 行表示第 $i$ 个积木落下后形成的新的洞的数目。", "hint": "**【数据范围】**\n\n输入数据保证 $0 \\leq L_i < R_i \\leq 100000, H_i \\leq 1000$。\n\n$30\\%$ 的数据保证 $n \\leq 100$。\n\n$100\\%$ 的数据保证$n \\leq 100000$。\n\n**【样例说明】**\n\n样例执行后的结果如图 4 所示，其中依次落下的积木按顺序编号为从 $1$ 到 $6$ 的一个整数。\n\n![图4](https://cdn.luogu.com.cn/upload/pic/22110.png)", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2009] Block Game", "background": "", "description": "Dandan is a die-hard Tetris fan, but after maxing out the score she finally started to feel bored. So she began to think about a simplified Tetris-like game:\n\nInitially, the ground is empty. Assume all blocks are rectangles, and blocks cannot be rotated or flipped. At each moment, Dandan chooses a position and drops one block. During the falling process, when the block touches the ground or another block, it will stop on the ground or on that block. “Landing on another block” means: the bottom boundary of the upper block and the top boundary of the lower block overlap in at least one line segment (a single point does not count), as shown in Figure 1.\n\n![Figure 1](https://cdn.luogu.com.cn/upload/pic/22107.png)\n\nIn Tetris, if at some moment a hole is formed between blocks, it looks unattractive. Therefore, Dandan wants to know: after each block is dropped, how many new holes will be formed. A hole is a closed region with area greater than $0$, bounded by block boundaries or the ground, as shown in Figure 2(a) and Figure 2(b).\n\nNote: in the situation shown in Figure 3, because block 1 and block 2 are tightly adjacent, when block 3 falls, no new hole will be formed.\n\nNow Dandan tells you, in order, the height $H_i$ of each block and the left and right boundaries $L_i$ and $R_i$ of where it is dropped, $1 \\leq i \\leq n$. She wants to know how many new holes are formed each time a block is dropped.\n\n![Figure 2 and Figure 3](https://cdn.luogu.com.cn/upload/pic/22108.png)", "inputFormat": "The first line contains a positive integer $n$, the total number of blocks to be dropped. The next $n$ lines each contain three integers separated by spaces: $L_i$, $R_i$, and $H_i$, representing the left boundary, right boundary, and height of the block.", "outputFormat": "Output $n$ lines. Each line contains one number. The $i$-th line should be the number of new holes formed after the $i$-th block is dropped.", "hint": "**Constraints**\n\nThe input guarantees $0 \\leq L_i < R_i \\leq 100000$, $H_i \\leq 1000$.\n\nFor $30\\%$ of the testdata, $n \\leq 100$.\n\nFor $100\\%$ of the testdata, $n \\leq 100000$.\n\n**Sample Explanation**\n\nThe result after running the sample is shown in Figure 4. The blocks dropped are numbered in order from $1$ to $6$.\n\n![Figure 4](https://cdn.luogu.com.cn/upload/pic/22110.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2009] 积木游戏", "background": "", "description": "丹丹是一位狂热的俄罗斯方块爱好者，但在把积分刷爆之后她终于开始感到厌倦了。于是她着手思考这样一个俄罗斯方块的简化版游戏：在初始状态地面上是空的。假设所有的积木都是长方形，且积木不能旋转或翻转。丹丹在每个时刻会选择一个位置将一块积木落下，当积木在落下的过程中碰到地面或另一块积木时，它会停留在地面上或那块积木上。落到另—块积木上意味着：上面的积木的下边界与下面的积木的上边界至少有一条线段重合(―个点不算)，如图 1 所示。\n\n![图1](https://cdn.luogu.com.cn/upload/pic/22107.png)\n\n在俄罗斯方块中，如果某个时刻积木之间形成了一个洞，那么看上去就很不优美。于是丹丹想知道，每落下一块积木之后，会形成几个新的洞。一个洞是指由积木的边界或地面组成的一块面积大于 $0$ 的封闭的区域，如图 2（a）和图 2（b）所示。\n\n要注意的是：当出现图 3 所示的情况时，因为积木 1 和积木 2 紧紧地挨在一起，所以当积木 3 落下的时候，不会形成新的洞。\n\n现在丹丹告诉你她依次落下的积木的髙度 $H_i$ 以及落下的位置的左右边界 $L_i$ 与 $R_i$，$1 \\leq i \\leq n$，而她想知道毎次积木落下时会形成几个新的洞？\n\n![图23](https://cdn.luogu.com.cn/upload/pic/22108.png)", "inputFormat": "第一行包含一个正整数 $n$，表示落下的积木的总数。接下来有$n$行，每行有用一个空格隔开的三个整数，分别表示 $L_i$、$R_i$ 和 $H_i$，即积木落下的左右边界和积木的高度。", "outputFormat": "包含 $n$ 行，每行只有一个数，第 $i$ 行表示第 $i$ 个积木落下后形成的新的洞的数目。", "hint": "**【数据范围】**\n\n输入数据保证 $0 \\leq L_i < R_i \\leq 100000, H_i \\leq 1000$。\n\n$30\\%$ 的数据保证 $n \\leq 100$。\n\n$100\\%$ 的数据保证$n \\leq 100000$。\n\n**【样例说明】**\n\n样例执行后的结果如图 4 所示，其中依次落下的积木按顺序编号为从 $1$ 到 $6$ 的一个整数。\n\n![图4](https://cdn.luogu.com.cn/upload/pic/22110.png)", "locale": "zh-CN"}}}
{"pid": "P4730", "type": "P", "difficulty": 7, "samples": [["5 5\n1 6\n3 2\n9 2\n7 3\n7 8\n4 9\n3\n5 4\n1 3\n1 2\n1 2 0\n2 5 0\n1 5 1\n1 3 1\n3 4 1", "2\n2\n-1"], ["6 14\n2 7\n3 10\n8 9\n3 4\n6 5\n3 10\n6 7\n4\n6 2\n1 2\n5 2\n3 6\n5 2 0\n4 5 1\n2 3 1\n5 4 0\n1 2 1\n1 4 0\n6 4 1\n5 4 1\n4 6 0\n1 5 0\n4 1 0\n6 4 0\n5 5 0\n1 2 0", "2\n1\n1\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["搜索", "图论", "2013", "O2优化", "广度优先搜索 BFS", "湖北"], "title": "孤舟蓑笠翁", "background": "![Background](https://i.loli.net/2018/07/04/5b3cc42f57e64.png)\n\n出于保护鱼类的目的，最优秀的渔翁才能在洞庭湖继续捕鱼。经过层层选拔，洞庭湖上只剩下孤舟蓑笠翁。以前跟其他渔翁一起钓鱼、打牌、切磋武艺，而如今只剩孤单一人，蓑笠翁不禁黯然神伤。选拔被淘汰，如今他们都去哪里了呢？大概回家种田养猪了吧。", "description": "![Description](https://i.loli.net/2018/07/04/5b3cc3f0cd5f5.png)\n\n蓑笠翁现在闲暇时在练的武术名为\"左右互搏术\"，相传是周伯通首创的武功。\n\n练功时，蓑笠翁的双手在某竖直平面内运动，以该平面上某点作为坐标原点，向右为 $x$ 轴正方向，向上为 $y$ 轴正方向建立直角坐标系。那么该平面内的一个点就可以用坐标 $(x, y)$ 来表示。\n\n该武功有 $n$ 个可停顿点，分别为 $p_1 = (x_1, y_1), p_2 = (x_2, y_2), \\ldots, p_n = (x_n, y_n)$。我们可以将蓑笠翁练功的过程分成一秒一秒来看，第 $i$ 秒时，双手都处于可停顿点上。而第 $i$ 秒末双手进行移动，移动到其它可停顿点上。（当然也可以不移动）\n\n左右互搏术中，有 $k$ 种绝招。第 $i$ 种绝招为：左手处于 $v_i$ 号可停顿点，右手处于 $u_i$ 号可停顿点，则可以发动绝招。\n\n练武功也有禁忌，在两只手停顿的时候，如果两只手的曼哈顿距离小于 $d_{min}$，则容易走火入魔。如果两只手的曼哈顿距离大于 $d_{max}$，则蓑笠翁的胳膊显然快被扯断了。所以假设左手在 $l$ 号停顿点，右手在 $r$ 号停顿点，则需要满足 $d_{min} \\leq |x_l - x_r| + |y_l - y_r| \\leq d_{max}$。\n\n从一个停顿点移动到另一个停顿点也有讲究，而且对于左右手还不一样。有 $m$ 个移动条件，每个移动条件形如：左手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点，或右手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点。对于某一秒末，蓑笠翁的手没那么快，所以每只手至多只能进行移动一次。上面未提到的移动方式均为非法。\n\n蓑笠翁希望能发动连击。即先发动第 $i$ 种绝招，经过 $t$ 秒的移动后，又发动了第 $j$ 种绝招，且 $i \\neq j$。\n\n给出 $p_1, \\ldots , p_n$，$v_1, \\ldots v_k$，$u_1, \\ldots , u_k$，$d_{min}$，$d_{max}$，和 $m$ 个移动条件，现在蓑笠翁想知道，发动第 $i$ 种绝招之后，最少经过多少秒的移动后能发动某个编号不为 $i$ 的绝招，即发动连击的最短耗时。请对于每个 $1 \\leq i \\leq k$ 输出答案。", "inputFormat": "![Input](https://i.loli.net/2018/07/04/5b3ce144d752b.png)\n\n第一行两个正整数 $n,m$。\n\n第二行两个非负整数 $d_{min}, d_{max}$。保证 $d_{min} \\leq d_{max}$。\n\n接下来 $n$ 行，这 $n$ 行中的第 $i$ 行每行两个正整数 $x, y$ 表示 $i$ 号停顿点的坐标。\n\n接下来的一行一个正整数 $k$ 。\n\n接下来 $k$ 行，这 $k$ 行中的第 $i$ 行每行两个正整数 $v, u$ 表示 $i$ 号绝招。左手处于 $v$ 号可停顿点，右手处于 $u$ 号可停顿点时能发动该绝招。保证 $1 \\leq v, u \\leq n$，不会有两个绝招完全相同，保证 $v, u$ 的曼哈顿距离不小于 $d_{min}$ 不大于 $d_{max}$。\n\n接下来 $m$ 行，每行三个正整数 $a, b, type$，若 $type = 0$ 则表示左手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点，若 $type = 1$ 则表示右手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点。保证 $1 \\leq a, b \\leq n$，$type \\in \\{0, 1\\}$。", "outputFormat": "![Output](https://i.loli.net/2018/07/04/5b3cc520d9fa0.png)\n\n$k$ 行，第 $i$ 行表示第 $i$ 个绝招发动一次连击的最短耗时。\n\n如果无论如何都无法连击，请输出 $-1$。", "hint": "**【样例解释】**\n\n![Explain](https://i.loli.net/2018/07/04/5b3cc62a913ae.png)\n\n**对于样例一的解释**　对于绝招 $1$，可以先同时将左手移动到 $2$ 号可停顿点，右手移动到 $3$ 号可停顿点，这样耗时 $1 \\textrm{ s}$，再将左手移动到 $1$ 号可停顿点，右手不动，这样可以发动绝招 $2$，共用时 $2 \\textrm{ s}$。对于绝招 $2$ 可以把刚才的过程反过来，发动绝招 $1$。对于绝招 $3$，无论如何右手都无法移动，不能发动任何绝招，故输出 $-1$。\n\n**对于样例二的解释**　不解释。\n\n**【数据范围】**\n\n![Constraint](https://i.loli.net/2018/07/04/5b3cc6528795b.png)\n\n其中 $20 \\%$ 的数据，$n \\leq 50$，$m \\leq 100$，$k \\leq 100$。  \n另有 $30 \\%$ 的数据，$n \\leq 500$，$m \\leq 2000$，$k \\leq 10000$，$d_{min} = 0$，$d_{max} = 10000$。  \n对于 $100 \\%$ 的数据，$n \\leq 1000$，$m \\leq 4000$，$1 \\leq x_i, y_i \\leq 1000$，$0 \\leq d_{min} \\leq d_{max} \\leq {10}^9$。", "locale": "zh-CN", "translations": {"en": {"title": "The Lone Fisherman in a Small Boat", "background": "![Background](https://i.loli.net/2018/07/04/5b3cc42f57e64.png)\n\nTo protect fish, only the best fishermen are allowed to keep fishing on Dongting Lake. After multiple rounds of selection, only the lone fisherman in a small boat remains on Dongting Lake. In the past, he used to fish, play cards, and spar with other fishermen, but now he is left all alone, and cannot help feeling sad. Those eliminated in the selection—where did they go now? Probably went home to farm and raise pigs.", "description": "![Description](https://i.loli.net/2018/07/04/5b3cc3f0cd5f5.png)\n\nThe martial art he practices in his spare time is called \"Left-Right Mutual Combat Technique\", said to be created by Zhou Botong.\n\nDuring practice, the fisherman’s two hands move within a certain vertical plane. Take some point on this plane as the origin, set the positive $x$-axis to the right and the positive $y$-axis upward to form a Cartesian coordinate system. Then any point in this plane can be represented by coordinates $(x, y)$.\n\nThis technique has $n$ stopping points, namely $p_1 = (x_1, y_1), p_2 = (x_2, y_2), \\ldots, p_n = (x_n, y_n)$. We can view the training process second by second: at the $i$-th second, both hands are located at stopping points. At the end of the $i$-th second, the hands move to other stopping points (or they may also stay still).\n\nIn the Left-Right Mutual Combat Technique, there are $k$ special moves. The $i$-th special move is: if the left hand is at stopping point $v_i$ and the right hand is at stopping point $u_i$, then this special move can be performed.\n\nThere are also taboos in practicing. While both hands are stopped, if the Manhattan distance between the two hands is less than $d_{min}$, it is easy to lose control. If the Manhattan distance is greater than $d_{max}$, then obviously his arms are about to be torn apart. So suppose the left hand is at stopping point $l$ and the right hand is at stopping point $r$, then it must satisfy $d_{min} \\leq |x_l - x_r| + |y_l - y_r| \\leq d_{max}$.\n\nMoving from one stopping point to another also has rules, and the rules are different for the left and right hands. There are $m$ movement constraints, each of the form: when the left hand is at stopping point $a$ it can move to stopping point $b$, and when it is at $b$ it can also move to $a$; or when the right hand is at stopping point $a$ it can move to stopping point $b$, and when it is at $b$ it can also move to $a$. At the end of any second, his hands are not that fast, so each hand can make at most one move. Any movement not mentioned above is illegal.\n\nThe fisherman hopes to perform a combo. That is, he first performs the $i$-th special move, and after $t$ seconds of movement, he performs the $j$-th special move, with $i \\neq j$.\n\nGiven $p_1, \\ldots , p_n$, $v_1, \\ldots v_k$, $u_1, \\ldots , u_k$, $d_{min}$, $d_{max}$, and the $m$ movement constraints, the fisherman wants to know: after performing the $i$-th special move, what is the minimum number of seconds of movement needed to perform some special move whose index is not $i$, i.e. the shortest time needed to perform a combo. Output the answer for each $1 \\leq i \\leq k$.", "inputFormat": "![Input](https://i.loli.net/2018/07/04/5b3ce144d752b.png)\n\nThe first line contains two positive integers $n, m$.\n\nThe second line contains two non-negative integers $d_{min}, d_{max}$. It is guaranteed that $d_{min} \\leq d_{max}$.\n\nThe next $n$ lines: the $i$-th line contains two positive integers $x, y$, indicating the coordinates of stopping point $i$.\n\nThe next line contains one positive integer $k$.\n\nThe next $k$ lines: the $i$-th line contains two positive integers $v, u$, indicating the $i$-th special move. The special move can be performed when the left hand is at stopping point $v$ and the right hand is at stopping point $u$. It is guaranteed that $1 \\leq v, u \\leq n$, no two special moves are exactly the same, and the Manhattan distance between $v$ and $u$ is not less than $d_{min}$ and not greater than $d_{max}$.\n\nThe next $m$ lines: each line contains three positive integers $a, b, type$. If $type = 0$, it means the left hand can move from stopping point $a$ to stopping point $b$ and also from $b$ to $a$. If $type = 1$, it means the right hand can move from stopping point $a$ to stopping point $b$ and also from $b$ to $a$. It is guaranteed that $1 \\leq a, b \\leq n$, $type \\in \\{0, 1\\}$.", "outputFormat": "![Output](https://i.loli.net/2018/07/04/5b3cc520d9fa0.png)\n\nOutput $k$ lines. The $i$-th line should contain the shortest time needed for the $i$-th special move to perform a combo once.\n\nIf it is impossible to perform a combo no matter what, output $-1$.", "hint": "**[Sample Explanation]**\n\n![Explain](https://i.loli.net/2018/07/04/5b3cc62a913ae.png)\n\n**Explanation for Sample 1.** For special move $1$, you can first move the left hand to stopping point $2$ and the right hand to stopping point $3$ at the same time, which costs $1 \\textrm{ s}$. Then move the left hand to stopping point $1$ and keep the right hand still; then you can perform special move $2$, taking a total of $2 \\textrm{ s}$. For special move $2$, you can reverse the above process to perform special move $1$. For special move $3$, the right hand cannot move in any way, so no special move can be performed, hence output $-1$.\n\n**Explanation for Sample 2.** Omitted.\n\n**[Constraints]**\n\n![Constraint](https://i.loli.net/2018/07/04/5b3cc6528795b.png)\n\nFor $20\\%$ of the testdata, $n \\leq 50$, $m \\leq 100$, $k \\leq 100$.  \nFor another $30\\%$ of the testdata, $n \\leq 500$, $m \\leq 2000$, $k \\leq 10000$, $d_{min} = 0$, $d_{max} = 10000$.  \nFor $100\\%$ of the testdata, $n \\leq 1000$, $m \\leq 4000$, $1 \\leq x_i, y_i \\leq 1000$, $0 \\leq d_{min} \\leq d_{max} \\leq {10}^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "孤舟蓑笠翁", "background": "![Background](https://i.loli.net/2018/07/04/5b3cc42f57e64.png)\n\n出于保护鱼类的目的，最优秀的渔翁才能在洞庭湖继续捕鱼。经过层层选拔，洞庭湖上只剩下孤舟蓑笠翁。以前跟其他渔翁一起钓鱼、打牌、切磋武艺，而如今只剩孤单一人，蓑笠翁不禁黯然神伤。选拔被淘汰，如今他们都去哪里了呢？大概回家种田养猪了吧。", "description": "![Description](https://i.loli.net/2018/07/04/5b3cc3f0cd5f5.png)\n\n蓑笠翁现在闲暇时在练的武术名为\"左右互搏术\"，相传是周伯通首创的武功。\n\n练功时，蓑笠翁的双手在某竖直平面内运动，以该平面上某点作为坐标原点，向右为 $x$ 轴正方向，向上为 $y$ 轴正方向建立直角坐标系。那么该平面内的一个点就可以用坐标 $(x, y)$ 来表示。\n\n该武功有 $n$ 个可停顿点，分别为 $p_1 = (x_1, y_1), p_2 = (x_2, y_2), \\ldots, p_n = (x_n, y_n)$。我们可以将蓑笠翁练功的过程分成一秒一秒来看，第 $i$ 秒时，双手都处于可停顿点上。而第 $i$ 秒末双手进行移动，移动到其它可停顿点上。（当然也可以不移动）\n\n左右互搏术中，有 $k$ 种绝招。第 $i$ 种绝招为：左手处于 $v_i$ 号可停顿点，右手处于 $u_i$ 号可停顿点，则可以发动绝招。\n\n练武功也有禁忌，在两只手停顿的时候，如果两只手的曼哈顿距离小于 $d_{min}$，则容易走火入魔。如果两只手的曼哈顿距离大于 $d_{max}$，则蓑笠翁的胳膊显然快被扯断了。所以假设左手在 $l$ 号停顿点，右手在 $r$ 号停顿点，则需要满足 $d_{min} \\leq |x_l - x_r| + |y_l - y_r| \\leq d_{max}$。\n\n从一个停顿点移动到另一个停顿点也有讲究，而且对于左右手还不一样。有 $m$ 个移动条件，每个移动条件形如：左手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点，或右手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点。对于某一秒末，蓑笠翁的手没那么快，所以每只手至多只能进行移动一次。上面未提到的移动方式均为非法。\n\n蓑笠翁希望能发动连击。即先发动第 $i$ 种绝招，经过 $t$ 秒的移动后，又发动了第 $j$ 种绝招，且 $i \\neq j$。\n\n给出 $p_1, \\ldots , p_n$，$v_1, \\ldots v_k$，$u_1, \\ldots , u_k$，$d_{min}$，$d_{max}$，和 $m$ 个移动条件，现在蓑笠翁想知道，发动第 $i$ 种绝招之后，最少经过多少秒的移动后能发动某个编号不为 $i$ 的绝招，即发动连击的最短耗时。请对于每个 $1 \\leq i \\leq k$ 输出答案。", "inputFormat": "![Input](https://i.loli.net/2018/07/04/5b3ce144d752b.png)\n\n第一行两个正整数 $n,m$。\n\n第二行两个非负整数 $d_{min}, d_{max}$。保证 $d_{min} \\leq d_{max}$。\n\n接下来 $n$ 行，这 $n$ 行中的第 $i$ 行每行两个正整数 $x, y$ 表示 $i$ 号停顿点的坐标。\n\n接下来的一行一个正整数 $k$ 。\n\n接下来 $k$ 行，这 $k$ 行中的第 $i$ 行每行两个正整数 $v, u$ 表示 $i$ 号绝招。左手处于 $v$ 号可停顿点，右手处于 $u$ 号可停顿点时能发动该绝招。保证 $1 \\leq v, u \\leq n$，不会有两个绝招完全相同，保证 $v, u$ 的曼哈顿距离不小于 $d_{min}$ 不大于 $d_{max}$。\n\n接下来 $m$ 行，每行三个正整数 $a, b, type$，若 $type = 0$ 则表示左手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点，若 $type = 1$ 则表示右手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点。保证 $1 \\leq a, b \\leq n$，$type \\in \\{0, 1\\}$。", "outputFormat": "![Output](https://i.loli.net/2018/07/04/5b3cc520d9fa0.png)\n\n$k$ 行，第 $i$ 行表示第 $i$ 个绝招发动一次连击的最短耗时。\n\n如果无论如何都无法连击，请输出 $-1$。", "hint": "**【样例解释】**\n\n![Explain](https://i.loli.net/2018/07/04/5b3cc62a913ae.png)\n\n**对于样例一的解释**　对于绝招 $1$，可以先同时将左手移动到 $2$ 号可停顿点，右手移动到 $3$ 号可停顿点，这样耗时 $1 \\textrm{ s}$，再将左手移动到 $1$ 号可停顿点，右手不动，这样可以发动绝招 $2$，共用时 $2 \\textrm{ s}$。对于绝招 $2$ 可以把刚才的过程反过来，发动绝招 $1$。对于绝招 $3$，无论如何右手都无法移动，不能发动任何绝招，故输出 $-1$。\n\n**对于样例二的解释**　不解释。\n\n**【数据范围】**\n\n![Constraint](https://i.loli.net/2018/07/04/5b3cc6528795b.png)\n\n其中 $20 \\%$ 的数据，$n \\leq 50$，$m \\leq 100$，$k \\leq 100$。  \n另有 $30 \\%$ 的数据，$n \\leq 500$，$m \\leq 2000$，$k \\leq 10000$，$d_{min} = 0$，$d_{max} = 10000$。  \n对于 $100 \\%$ 的数据，$n \\leq 1000$，$m \\leq 4000$，$1 \\leq x_i, y_i \\leq 1000$，$0 \\leq d_{min} \\leq d_{max} \\leq {10}^9$。", "locale": "zh-CN"}}}
{"pid": "P4731", "type": "P", "difficulty": 6, "samples": [["2\n10\n08x-7/2/x?x-23??1/???\n8 -1 40 60 82 97 102 110 120 140\n5\nx-x-23?/00-\n22 37 42 52 52", "9\n10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "BalticOI（波罗的海）"], "title": "[BalticOI 2015] Bowling", "background": "", "description": "Byteasar is a fan of both bowling and statistics. He has written down the results of a few past bowling games.\n\nUnfortunately, some characters in the notes are blurry, and thus unreadable. Byteasar asks you to write a\nprogram to calculate the number of distinct games which are consistent with his notes.\n\n## Rules of Bowling\n\nA bowling game consists of $n$ frames: $n-1$ simple frames and one final frame. In a typical game $n = 10$. At the beginning of each frame $10$ pins are put standing upright at the end of a lane and a player gets no more than two (or three for the final frame) attempts (shots) to throw a bowling ball down the lane to try to knock down as many pins as possible. Each frame is denoted by two (for a simple frame) or three (for the final frame)\ncharacters.\n\nFor each shot the player receives as basic points the total number of pins knocked down in this shot. The player’s basic points in each frame are the sum of basic points of all the shots in this frame. If all $10$ pins are knocked down in a simple frame (and therefore $10$ basic points are earned), the player gets additional bonus points.\n\nFor a simple frame the rules are the following:\n\n   - If a player knocks down all $10$ pins in the first shot of a frame, she gets a strike and the frame ends. As bonus points she gets the sum of basic points of her next two shots. A strike is denoted as “``x-``”.\n \n   - If a player knocks down all $10$ pins using both shots of a frame, she gets a spare. As bonus points she gets the basic points of her next shot. A spare is denoted as “``A/``”, where $A$ is a digit describing the number of pins knocked down in the first shot of the frame.\n   \n   - If $9$ or fewer pins are knocked down after both shots, the player gets just basic points and such a frame is denoted as “``AB``”, where $A$ is the one-digit number of pins knocked down in the first shot, and $B$ is the one-digit number of pins knocked down in the second shot $(A + B < 10)$.\n\nNote that bonus points are included to the score of a frame in which the strike or the spare was obtained,regardless of the fact that the exact number of bonus points depends on future shots in next frames.\n\nFor the final frame the rules are the following:\n\n   - Initially the player receives two shots in this frame. If $9$ or fewer pins are knocked down in the two shots,the frame ends. Otherwise (if the first two shots are a spare or the first shot is a strike), the player receives a third shot in the frame. Whenever the player knocks down all the pins in any of the three shots, the pins are reset to the initial configuration for the next shot. The score of the final frame is the total number of pins knocked down (note that no bonus points are earned due to strikes and spares).\n\n   - Overall there are seven possible configurations of the final frame with the following outcomes ($A$ and $B$ stand for one-digit numbers):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vz466ecx.png)\n\nEach game is described as a sequence of $2n + 1$ characters. At the end of the game the total number of points after each frame may be calculated. For example, for a game of $n = 10$ frames described as “``08x-7/2/x-x-23441/0/x``”, the player’s points after respective frames were as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6arspls8.png)\n\n", "inputFormat": "The first line of input contains one integer $q(1 \\le q \\le 25)$, specifying the number of test cases to consider. The following $3q$ lines of input contain descriptions of test cases. Each test case is described by three lines of input.\nThe first line of a test case description contains one integer $n(2 \\le n \\le 10)$, specifying the number of frames. The second line contains a sequence of $2n + 1$ characters which denotes the game description from Byteasar’s notes. Blurry characters are replaced by “``?``” characters. The third line contains $n$ integers, the total number of points after each frame, separated by spaces. In each number either all digits are readable, or all digits are blurry. Numbers in which all digits are blurry are replaced by “``-1``”.", "outputFormat": "Your program should output $q$ lines, one line per each test case in the same order as in the input.\n\nFor each test case your program should write one integer: the number of possible distinct games corre-sponding to the test case. Two games are considered different if and only if they differ in at least one shot,that is, their $(2n+1)$-character game descriptions are different. You can assume that there is at least one game consistent with each test case in the input. You can assume that the result fits into 64-bit signed integer type.", "hint": "**Explanation to the examples:** In the first case, in frame $5$ after the character “``x``” the only possible character is “``-``”. In frame $8$ the player got $8$ points in total. Thus there are $9$ possibilities how this sum could have been obtained: $0 + 8,1 + 7,...,8 + 0$. There were no bonus points in frame $9$. Therefore, there were no points on the first shot of the final frame. To obtain $20$ points in the last two shots, the only possibility is a spare with a following strike in the last shot of the frame. Therefore there are $9$ different valid games which correspond to this input data.\n\nIn the second case, any character from $0$ to $9$ is consistent with the input data.\n\n以下子任务和评测无关，仅供参考。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v8uz3sto.png)\n\n（但是我开不了 5 个 Subtask，所以就放在一起测了）", "locale": "en", "translations": {"en": {"title": "[BalticOI 2015] Bowling", "background": "", "description": "Byteasar is a fan of both bowling and statistics. He has written down the results of a few past bowling games.\n\nUnfortunately, some characters in the notes are blurry, and thus unreadable. Byteasar asks you to write a\nprogram to calculate the number of distinct games which are consistent with his notes.\n\n## Rules of Bowling\n\nA bowling game consists of $n$ frames: $n-1$ simple frames and one final frame. In a typical game $n = 10$. At the beginning of each frame $10$ pins are put standing upright at the end of a lane and a player gets no more than two (or three for the final frame) attempts (shots) to throw a bowling ball down the lane to try to knock down as many pins as possible. Each frame is denoted by two (for a simple frame) or three (for the final frame)\ncharacters.\n\nFor each shot the player receives as basic points the total number of pins knocked down in this shot. The player’s basic points in each frame are the sum of basic points of all the shots in this frame. If all $10$ pins are knocked down in a simple frame (and therefore $10$ basic points are earned), the player gets additional bonus points.\n\nFor a simple frame the rules are the following:\n\n   - If a player knocks down all $10$ pins in the first shot of a frame, she gets a strike and the frame ends. As bonus points she gets the sum of basic points of her next two shots. A strike is denoted as “``x-``”.\n \n   - If a player knocks down all $10$ pins using both shots of a frame, she gets a spare. As bonus points she gets the basic points of her next shot. A spare is denoted as “``A/``”, where $A$ is a digit describing the number of pins knocked down in the first shot of the frame.\n   \n   - If $9$ or fewer pins are knocked down after both shots, the player gets just basic points and such a frame is denoted as “``AB``”, where $A$ is the one-digit number of pins knocked down in the first shot, and $B$ is the one-digit number of pins knocked down in the second shot $(A + B < 10)$.\n\nNote that bonus points are included to the score of a frame in which the strike or the spare was obtained,regardless of the fact that the exact number of bonus points depends on future shots in next frames.\n\nFor the final frame the rules are the following:\n\n   - Initially the player receives two shots in this frame. If $9$ or fewer pins are knocked down in the two shots,the frame ends. Otherwise (if the first two shots are a spare or the first shot is a strike), the player receives a third shot in the frame. Whenever the player knocks down all the pins in any of the three shots, the pins are reset to the initial configuration for the next shot. The score of the final frame is the total number of pins knocked down (note that no bonus points are earned due to strikes and spares).\n\n   - Overall there are seven possible configurations of the final frame with the following outcomes ($A$ and $B$ stand for one-digit numbers):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vz466ecx.png)\n\nEach game is described as a sequence of $2n + 1$ characters. At the end of the game the total number of points after each frame may be calculated. For example, for a game of $n = 10$ frames described as “``08x-7/2/x-x-23441/0/x``”, the player’s points after respective frames were as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6arspls8.png)\n\n", "inputFormat": "The first line of input contains one integer $q(1 \\le q \\le 25)$, specifying the number of test cases to consider. The following $3q$ lines of input contain descriptions of test cases. Each test case is described by three lines of input.\nThe first line of a test case description contains one integer $n(2 \\le n \\le 10)$, specifying the number of frames. The second line contains a sequence of $2n + 1$ characters which denotes the game description from Byteasar’s notes. Blurry characters are replaced by “``?``” characters. The third line contains $n$ integers, the total number of points after each frame, separated by spaces. In each number either all digits are readable, or all digits are blurry. Numbers in which all digits are blurry are replaced by “``-1``”.", "outputFormat": "Your program should output $q$ lines, one line per each test case in the same order as in the input.\n\nFor each test case your program should write one integer: the number of possible distinct games corre-sponding to the test case. Two games are considered different if and only if they differ in at least one shot,that is, their $(2n+1)$-character game descriptions are different. You can assume that there is at least one game consistent with each test case in the input. You can assume that the result fits into 64-bit signed integer type.", "hint": "**Explanation to the examples:** In the first case, in frame $5$ after the character “``x``” the only possible character is “``-``”. In frame $8$ the player got $8$ points in total. Thus there are $9$ possibilities how this sum could have been obtained: $0 + 8,1 + 7,...,8 + 0$. There were no bonus points in frame $9$. Therefore, there were no points on the first shot of the final frame. To obtain $20$ points in the last two shots, the only possibility is a spare with a following strike in the last shot of the frame. Therefore there are $9$ different valid games which correspond to this input data.\n\nIn the second case, any character from $0$ to $9$ is consistent with the input data.\n\n以下子任务和评测无关，仅供参考。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v8uz3sto.png)\n\n（但是我开不了 5 个 Subtask，所以就放在一起测了）", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2015] Bowling", "background": "", "description": "Byteasar 是一个保龄球和统计学的爱好者。他记录了一些过去保龄球比赛的结果。不幸的是，笔记中的一些字符模糊不清，因此无法辨认。Byteasar 请你编写一个程序来计算与他的笔记一致的不同游戏的数量。\n\n## 保龄球规则\n\n一场保龄球比赛由 $n$ 局组成：$n-1$ 个简单局和一个最后局。在典型的比赛中 $n = 10$。在每局开始时，10 个瓶子被竖直放置在球道的末端，玩家最多有两次（最后一局有三次）机会（投球）将保龄球投向球道，尽可能多地击倒瓶子。每局用两个（对于简单局）或三个（对于最后局）字符表示。\n\n对于每次投球，玩家获得的基本分数是该次投球击倒的瓶子总数。玩家在每局的基本分数是该局所有投球的基本分数之和。如果在一个简单局中击倒了所有 10 个瓶子（因此获得了 10 个基本分数），玩家会获得额外的奖励分数。\n\n对于简单局，规则如下：\n\n- 如果玩家在一局的第一次投球中击倒了所有 10 个瓶子，她获得一个全中，局结束。作为奖励分数，她获得下一次两次投球的基本分数之和。全中记为 “`x-`”。\n- 如果玩家在一局的两次投球中击倒了所有 10 个瓶子，她获得一个补中。作为奖励分数，她获得下一次投球的基本分数。补中记为 “`A/`”，其中 $A$ 是描述该局第一次投球击倒瓶子数的数字。\n- 如果在两次投球后击倒了 9 个或更少的瓶子，玩家只获得基本分数，这样的局记为 “`AB`”，其中 $A$ 是第一次投球击倒的瓶子数的一个数字，$B$ 是第二次投球击倒的瓶子数的一个数字 $(A + B < 10)$。\n\n注意，奖励分数被计入获得全中或补中的局的分数中，尽管确切的奖励分数取决于下一局的投球。\n\n对于最后局，规则如下：\n\n- 玩家在此局最初有两次投球。如果在两次投球中击倒了 9 个或更少的瓶子，局结束。否则（如果前两次投球是补中或第一次投球是全中），玩家在此局获得第三次投球。每当玩家在三次投球中的任何一次击倒所有瓶子时，瓶子会为下一次投球恢复到初始状态。最后局的分数是击倒的瓶子总数（注意，由于全中和补中没有奖励分数）。\n- 总共有七种可能的最后局配置，结果如下（$A$ 和 $B$ 代表一位数的数字）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vz466ecx.png)\n\n每场比赛被描述为一个 $2n + 1$ 个字符的序列。在比赛结束时，可以计算每局后的总分数。例如，对于一个由 “`08x-7/2/x-x-23441/0/x`” 描述的 $n = 10$ 局的比赛，玩家在各局后的分数如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6arspls8.png)", "inputFormat": "输入的第一行包含一个整数 $q(1 \\le q \\le 25)$，指定要考虑的测试用例数量。接下来的 $3q$ 行输入包含测试用例的描述。每个测试用例由三行输入描述。测试用例描述的第一行包含一个整数 $n(2 \\le n \\le 10)$，指定局数。第二行包含一个 $2n + 1$ 个字符的序列，表示 Byteasar 笔记中的比赛描述。模糊的字符用 “`?`” 字符替代。第三行包含 $n$ 个整数，表示每局后的总分数，以空格分隔。在每个数字中，要么所有数字可读，要么所有数字模糊。所有数字模糊的数字用 “`-1`” 替代。", "outputFormat": "你的程序应输出 $q$ 行，每个测试用例一行，顺序与输入相同。\n\n对于每个测试用例，你的程序应输出一个整数：与该测试用例对应的可能不同比赛的数量。只有在至少一个投球不同的情况下，两个比赛才被认为是不同的，即它们的 $(2n+1)$ 字符比赛描述不同。你可以假设输入中的每个测试用例至少有一个与之相符的比赛。你可以假设结果适合 64 位有符号整数类型。", "hint": "**示例解释：** 在第一个例子中，在第 5 局中，在字符 “`x`” 之后，唯一可能的字符是 “`-`”。在第 8 局中，玩家总共获得了 8 分。因此，有 9 种可能的方式获得这个总和：$0 + 8, 1 + 7, ..., 8 + 0$。在第 9 局中没有奖励分数。因此，在最后一局的第一次投球中没有分数。为了在最后两次投球中获得 20 分，唯一的可能性是补中，接着在该局的最后一次投球中全中。因此，有 9 个不同的有效比赛与此输入数据相符。\n\n在第二个例子中，任何从 $0$ 到 $9$ 的字符都与输入数据一致。\n\n以下子任务和评测无关，仅供参考。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v8uz3sto.png)\n\n（但是我开不了 5 个 Subtask，所以就放在一起测了）\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4732", "type": "P", "difficulty": 6, "samples": [["11\n1\n2\n5\n-1\n-1\n-3\n4\n-2\n-1\n-1\n1", "1\n2\n5\n2\n1\n2\n4\n2\n1\n0\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "Special Judge", "BalticOI（波罗的海）"], "title": "[BalticOI 2015] Editor", "background": "", "description": "Byteasar is a programmer who works on a revolutionary text editor. In the editor there are two types of operations: one type allows to edit text in the editor, and the other type allows to undo previously performed operations. One of the innovative features of this editor is a multilevel undo operation. It works as follows.\n\nWe say that a text editing operation is an operation of level $0$. An undo operation of level $i(for \\ i = 1,2,...)$ undoes the last operation of level at most $i-1$ which is not undone. For instance, an undo operation of level $1$ can undo only editing operations, and an undo operation of level $2$ can undo editing operations as well as undo operations of level $1$ (but no undo operations of greater levels).\n\nMore formally, each of the already performed operations can be in two states: active or undone. Let $X$ be one of the operations. Just after performing the operation $X$, it is in the state active. If $X$ is an undo operation of level $i$, we find the most recent operation in state active of level at most $i-1$ (denote it by $X_1$) and change the state of the operation X1 to undone. If X1 is also an undo operation, we must change to active the state of the operation which $X_1$ had undone (say $X_2$). We continue in the same manner: whenever\nthe state of an undo operation $X_j$ which had previously undone some operation $X_{j+1}$ changes, we must also change the state of the operation $X_{j+1}$(which, of course, may result in changing states of further operations).\n\nThe whole chain of state modifications finishes when an editing operation is reached.\n\nFor simplicity, the current contents of text in the editor will be specified by a single integer s, called the editor state (equal to $0$ at the beginning). Each editing operation specifies the editor state that it produces.\n\nThe editor state depends on the last editing operation in the state active. Help Byteasar and write a program which keeps track of the editor state.\n\nLet us see this in action: the following table shows some operations performed by Byteasar and the editor state after performing each of them. The symbol $E_s$ denotes an editing operation which changes the editor state to $s$, whereas the symbol $U_i$ denotes an undo operation of level $i$.\n\n\n\n| Operation |  | $\\mathrm{E}_1$ | $\\mathrm{E}_2$ | $\\mathrm{E}_5$ | $\\mathrm{U}_1$ | $\\mathrm{U}_1$ | $\\mathrm{U}_3$ | $\\mathrm{E}_4$ | $\\mathrm{U}_2$ | $\\mathrm{U}_1$ | $\\mathrm{U}_1$ | $\\mathrm{E}_1$ |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| Editor state | 0 | 1 | 2 | 5 | 2 | 1 | 2 | 4 | 2 | 1 | 0 | 1 |\n\nFirst, Byteasar performed three editing operations. The editor state changed from $0$ to $1$, then to $2$, and finally to $5$. Next, he performed two undo operations of level $1$, which undid the operations $E_5$ and $E_2$(changing\ntheir state to undone). Thus the editor state was restored to $1$. The following undo operation of level $3$ undid the last operation $U_1$(changing its state to undone), consequently restoring the operation $E_2$(changing its state\nback to active). As a result the editor state changed once again to $2$. Operation $U_2$ undid the operation $E_4$,operation $U_1$ once again undid the restored operation $E_2$, the last operation $U_1$ undid the operation $E_1$, and the final operation is $E_1$.", "inputFormat": "The first line of the input contains a positive integer $n$, specifying the number of operations performed by Byteasar. The next $n$ lines contain descriptions of operations, one per line, each being an integer $a_i(-n \\le a_i \\le n, a_i ≠ 0)$. If $a_i> 0$, then it specifies an editing operation which modifies the editor state to $a_i$. If $a_i< 0$,then it specifies an undo operation of level $-a_i$. You can assume that for every undo operation there will be some operation in the state active of smaller level to undo.", "outputFormat": "Your program should output $n$ lines. The $i-th$ line should contain one integer specifying the editor state after performing the first $i$ operations from the input.", "hint": "以下子任务和评测无关，仅供参考。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zejidndn.png)\n\n（但是我开不了 4 个 Subtask，所以就放在一起测了）", "locale": "en", "translations": {"en": {"title": "[BalticOI 2015] Editor", "background": "", "description": "Byteasar is a programmer who works on a revolutionary text editor. In the editor there are two types of operations: one type allows to edit text in the editor, and the other type allows to undo previously performed operations. One of the innovative features of this editor is a multilevel undo operation. It works as follows.\n\nWe say that a text editing operation is an operation of level $0$. An undo operation of level $i(for \\ i = 1,2,...)$ undoes the last operation of level at most $i-1$ which is not undone. For instance, an undo operation of level $1$ can undo only editing operations, and an undo operation of level $2$ can undo editing operations as well as undo operations of level $1$ (but no undo operations of greater levels).\n\nMore formally, each of the already performed operations can be in two states: active or undone. Let $X$ be one of the operations. Just after performing the operation $X$, it is in the state active. If $X$ is an undo operation of level $i$, we find the most recent operation in state active of level at most $i-1$ (denote it by $X_1$) and change the state of the operation X1 to undone. If X1 is also an undo operation, we must change to active the state of the operation which $X_1$ had undone (say $X_2$). We continue in the same manner: whenever\nthe state of an undo operation $X_j$ which had previously undone some operation $X_{j+1}$ changes, we must also change the state of the operation $X_{j+1}$(which, of course, may result in changing states of further operations).\n\nThe whole chain of state modifications finishes when an editing operation is reached.\n\nFor simplicity, the current contents of text in the editor will be specified by a single integer s, called the editor state (equal to $0$ at the beginning). Each editing operation specifies the editor state that it produces.\n\nThe editor state depends on the last editing operation in the state active. Help Byteasar and write a program which keeps track of the editor state.\n\nLet us see this in action: the following table shows some operations performed by Byteasar and the editor state after performing each of them. The symbol $E_s$ denotes an editing operation which changes the editor state to $s$, whereas the symbol $U_i$ denotes an undo operation of level $i$.\n\n\n\n| Operation |  | $\\mathrm{E}_1$ | $\\mathrm{E}_2$ | $\\mathrm{E}_5$ | $\\mathrm{U}_1$ | $\\mathrm{U}_1$ | $\\mathrm{U}_3$ | $\\mathrm{E}_4$ | $\\mathrm{U}_2$ | $\\mathrm{U}_1$ | $\\mathrm{U}_1$ | $\\mathrm{E}_1$ |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| Editor state | 0 | 1 | 2 | 5 | 2 | 1 | 2 | 4 | 2 | 1 | 0 | 1 |\n\nFirst, Byteasar performed three editing operations. The editor state changed from $0$ to $1$, then to $2$, and finally to $5$. Next, he performed two undo operations of level $1$, which undid the operations $E_5$ and $E_2$(changing\ntheir state to undone). Thus the editor state was restored to $1$. The following undo operation of level $3$ undid the last operation $U_1$(changing its state to undone), consequently restoring the operation $E_2$(changing its state\nback to active). As a result the editor state changed once again to $2$. Operation $U_2$ undid the operation $E_4$,operation $U_1$ once again undid the restored operation $E_2$, the last operation $U_1$ undid the operation $E_1$, and the final operation is $E_1$.", "inputFormat": "The first line of the input contains a positive integer $n$, specifying the number of operations performed by Byteasar. The next $n$ lines contain descriptions of operations, one per line, each being an integer $a_i(-n \\le a_i \\le n, a_i ≠ 0)$. If $a_i> 0$, then it specifies an editing operation which modifies the editor state to $a_i$. If $a_i< 0$,then it specifies an undo operation of level $-a_i$. You can assume that for every undo operation there will be some operation in the state active of smaller level to undo.", "outputFormat": "Your program should output $n$ lines. The $i-th$ line should contain one integer specifying the editor state after performing the first $i$ operations from the input.", "hint": "以下子任务和评测无关，仅供参考。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zejidndn.png)\n\n（但是我开不了 4 个 Subtask，所以就放在一起测了）", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2015] Editor", "background": "", "description": "Byteasar 是一名程序员，他正在开发一个革命性的文本编辑器。在这个编辑器中，有两种类型的操作：一种是允许在编辑器中编辑文本的操作，另一种是允许撤销先前执行的操作的操作。这个编辑器的一个创新功能是多级撤销操作。其工作原理如下。\n\n我们说文本编辑操作是一个 0 级操作。一个 i 级的撤销操作（对于 $i = 1, 2, \\ldots$）可以撤销最后一个未被撤销的、级别不超过 $i-1$ 的操作。例如，一个 1 级的撤销操作只能撤销编辑操作，而一个 2 级的撤销操作可以撤销编辑操作以及 1 级的撤销操作（但不能撤销更高级别的撤销操作）。\n\n更正式地说，已经执行的每个操作可以处于两种状态：活动或已撤销。设 $X$ 是其中一个操作。刚执行完操作 $X$ 后，它处于活动状态。如果 $X$ 是一个 i 级的撤销操作，我们找到最近的、处于活动状态的、级别不超过 $i-1$ 的操作（记为 $X_1$），并将操作 $X_1$ 的状态更改为已撤销。如果 $X_1$ 也是一个撤销操作，我们必须将 $X_1$ 撤销的操作（记为 $X_2$）的状态更改为活动。我们以相同的方式继续：每当一个撤销操作 $X_j$ 的状态改变时，我们必须也改变 $X_{j+1}$ 的状态（当然，这可能导致进一步操作的状态改变）。\n\n当达到一个编辑操作时，整个状态修改链结束。\n\n为简单起见，编辑器中的当前文本内容将由一个称为编辑器状态的单一整数 $s$ 指定（初始为 $0$）。每个编辑操作指定它产生的编辑器状态。\n\n编辑器状态取决于处于活动状态的最后一个编辑操作。帮助 Byteasar 编写一个程序来跟踪编辑器状态。\n\n让我们看看这个功能的实际应用：下表显示了 Byteasar 执行的一些操作以及每次执行后的编辑器状态。符号 $E_s$ 表示将编辑器状态更改为 $s$ 的编辑操作，而符号 $U_i$ 表示 i 级的撤销操作。\n\n| Operation |  | $\\mathrm{E}_1$ | $\\mathrm{E}_2$ | $\\mathrm{E}_5$ | $\\mathrm{U}_1$ | $\\mathrm{U}_1$ | $\\mathrm{U}_3$ | $\\mathrm{E}_4$ | $\\mathrm{U}_2$ | $\\mathrm{U}_1$ | $\\mathrm{U}_1$ | $\\mathrm{E}_1$ |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| Editor state | 0 | 1 | 2 | 5 | 2 | 1 | 2 | 4 | 2 | 1 | 0 | 1 |\n\n首先，Byteasar 执行了三个编辑操作。编辑器状态从 $0$ 变为 $1$，然后变为 $2$，最后变为 $5$。接下来，他执行了两个 1 级的撤销操作，撤销了操作 $E_5$ 和 $E_2$（将它们的状态更改为已撤销）。因此，编辑器状态恢复为 $1$。接下来的 3 级撤销操作撤销了最后一个 $U_1$ 操作（将其状态更改为已撤销），从而恢复了操作 $E_2$（将其状态改回活动）。结果，编辑器状态再次变为 $2$。操作 $U_2$ 撤销了操作 $E_4$，操作 $U_1$ 再次撤销了恢复的操作 $E_2$，最后一个操作 $U_1$ 撤销了操作 $E_1$，最后的操作是 $E_1$。", "inputFormat": "输入的第一行包含一个正整数 $n$，指定 Byteasar 执行的操作数。接下来的 $n$ 行包含操作的描述，每行一个整数 $a_i(-n \\le a_i \\le n, a_i \neq 0)$。如果 $a_i > 0$，则它指定一个将编辑器状态修改为 $a_i$ 的编辑操作。如果 $a_i < 0$，则它指定一个级别为 $-a_i$ 的撤销操作。你可以假设对于每个撤销操作，都会有一些较低级别的活动状态的操作可以被撤销。", "outputFormat": "你的程序应输出 $n$ 行。第 $i$ 行应包含一个整数，指定执行输入中的前 $i$ 个操作后的编辑器状态。", "hint": "以下子任务和评测无关，仅供参考。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zejidndn.png)\n\n（但是我开不了 4 个 Subtask，所以就放在一起测了。）\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4733", "type": "P", "difficulty": 7, "samples": [["4 1\n1 1 1\n2 1 2\n2 2 8\n1 2 2\n3 3 5\n3 3 2\n4 4 1\n4 4 2", "YES"], ["2 5\n1 1 1\n1 2 4\n2 2 1\n2 1 4", "NO"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "BalticOI（波罗的海）"], "title": "[BalticOI 2015] Tug of War", "background": "", "description": "拔河（*Tug of War*）在 Byteland 是十分受欢迎的运动。规则十分简单：两队以相反方向拉绳子。一年一度的 Byteland 拔河比赛将要进行，并且许多选手都报名参加了。作为公平竞赛专员，你的工作是把选手们划分为两个队伍，使得这个比赛能够进行很长时间。\n\n由于一共 $2n$ 名选手报名参赛，所以一个队有 $n$ 名队员。一根绳上左右两边各有 $n$ 个点。Byteland 的拔河精英们都很挑剔，每个参赛选手在左右两边都有一个他们想要站的位置。此外，你知道每一个参赛选手的力量值。\n\n组织者现在问你如下的问题：给定一个整数 $k$，能否分出两个队，这两个队各有 $n$ 名选手，并且他们站在他们想站的位置（当然不能有两名或以上选手站在同一位置），双方力量和之差不超过 $k$？", "inputFormat": "输入的第一行有两个正整数 $n,k$，分别表示绳子每一侧的位置数和两队的最大力量差。为了简单，我们把参赛者编号为 $1$ 到 $2n$。\n\n接下来 $2n$ 行，每行描述一个参赛者，这些行中的第 $i$ 行包含三个正整数 $l_i,r_i,s_i$，分别表示 $i$ 号选手有力量 $s_i$，并且想站在左边的 $l_i$ 位置或是右边的 $r_i$ 位置。", "outputFormat": "你的程序应在第一行输出一个单词 `YES` 或 `NO`，表示是否有可能建立两支符合上述条件的队伍。", "hint": "### 样例解释 1\n\n第一个样例中我们可以安排 $1,3,6,7$ 号选手站在左边（这个队伍力量值为 $1+8+2+1=12$），并安排 $2,4,5,8$ 号选手站在右边（这个队伍力量值为 $2+2+5+2=11$）。力量值的差为 $1$。\n\n### 样例解释 2\n\n第二个样例中两位力量值为 $4$ 的选手不得不在一个队中，因此两队最小的力量值之差为 $6$。\n\n### 子任务\n\n以下子任务与评测无关，仅供参考。\n\n本题采用子任务式测评，只有一个子任务内所有测试点均正确才可获得此子任务的分数。\n\n对于全部子任务，$k\\le 20n,1\\le l_i,r_i\\le n,1\\le s_i\\le 20$。\n\n对于每个子任务满足的条件如下：\n\n| 子任务 |           条件            | 分数 |\n| :----: | :-----------------------: | :--: |\n|  $1$   |         $n\\le 10$         | $18$ |\n|  $2$   |    $n\\le 2\\times 10^3$    | $30$ |\n|  $3$   | $n\\le 3\\times 10^4,s_i=1$ | $23$ |\n|  $4$   |    $n\\le 3\\times 10^4$    | $29$ |\n\n~~注：实际上，拔河并不取决于力量而取决于双方体重。原题的选手力量值应正比于选手体重值。~~\n\n### 附注\n\n本题翻译搬运自 [LibreOJ](https://loj.ac/problem/2707)，译者为 HeRaNO，在此对原翻译者表示感谢。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2015] Tug of War", "background": "", "description": "Tug of War is a very popular sport in Byteland. The rules are very simple: two teams pull a rope in opposite directions. The annual Byteland Tug of War tournament is about to be held, and many players have signed up. As the fair play officer, your job is to divide the players into two teams so that the match can last for a long time.\n\nSince there are $2n$ players in total, each team has $n$ members. On the rope, there are $n$ positions on the left side and $n$ positions on the right side. Byteland’s tug of war elites are very picky: each player has one position they want to stand at on the left side and one position they want to stand at on the right side. Also, you know the strength value of each player.\n\nThe organizers now ask you the following question: given an integer $k$, is it possible to form two teams, each with $n$ players, such that they stand in the positions they want (of course, no two or more players can stand in the same position), and the difference between the total strengths of the two teams does not exceed $k$?", "inputFormat": "The first line contains two positive integers $n,k$, representing the number of positions on each side of the rope and the maximum allowed difference in total strength between the two teams. For simplicity, we number the players from $1$ to $2n$.\n\nIn the next $2n$ lines, each line describes one player. The $i$-th of these lines contains three positive integers $l_i,r_i,s_i$, meaning that player $i$ has strength $s_i$ and wants to stand at position $l_i$ on the left side or position $r_i$ on the right side.", "outputFormat": "Your program should output a single word `YES` or `NO` on the first line, indicating whether it is possible to form two teams that satisfy the conditions above.", "hint": "### Sample Explanation 1\n\nIn the first sample, we can arrange players $1,3,6,7$ to stand on the left side (this team has total strength $1+8+2+1=12$), and arrange players $2,4,5,8$ to stand on the right side (this team has total strength $2+2+5+2=11$). The difference in total strength is $1$.\n\n### Sample Explanation 2\n\nIn the second sample, the two players with strength $4$ must be on the same team, so the minimum possible difference between the total strengths of the two teams is $6$.\n\n### Subtasks\n\nThe following subtasks are not related to judging and are for reference only.\n\nThis problem uses subtask-based scoring. You can get the score for a subtask only if all test points in that subtask are correct.\n\nFor all subtasks, $k\\le 20n,1\\le l_i,r_i\\le n,1\\le s_i\\le 20$.\n\nThe conditions for each subtask are as follows:\n\n| Subtask |        Condition         | Score |\n| :-----: | :----------------------: | :---: |\n|   $1$   |        $n\\le 10$         | $18$  |\n|   $2$   |    $n\\le 2\\times 10^3$   | $30$  |\n|   $3$   | $n\\le 3\\times 10^4,s_i=1$ | $23$ |\n|   $4$   |    $n\\le 3\\times 10^4$   | $29$  |\n\n~~Note: in fact, tug of war does not depend on strength, but on the weight of both sides. In the original problem, the players’ strength values should be proportional to their weights.~~\n\n### Notes\n\nThis translation is adapted and carried over from [LibreOJ](https://loj.ac/problem/2707). The translator is HeRaNO, and we would like to thank the original translator here.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2015] Tug of War", "background": "", "description": "拔河（*Tug of War*）在 Byteland 是十分受欢迎的运动。规则十分简单：两队以相反方向拉绳子。一年一度的 Byteland 拔河比赛将要进行，并且许多选手都报名参加了。作为公平竞赛专员，你的工作是把选手们划分为两个队伍，使得这个比赛能够进行很长时间。\n\n由于一共 $2n$ 名选手报名参赛，所以一个队有 $n$ 名队员。一根绳上左右两边各有 $n$ 个点。Byteland 的拔河精英们都很挑剔，每个参赛选手在左右两边都有一个他们想要站的位置。此外，你知道每一个参赛选手的力量值。\n\n组织者现在问你如下的问题：给定一个整数 $k$，能否分出两个队，这两个队各有 $n$ 名选手，并且他们站在他们想站的位置（当然不能有两名或以上选手站在同一位置），双方力量和之差不超过 $k$？", "inputFormat": "输入的第一行有两个正整数 $n,k$，分别表示绳子每一侧的位置数和两队的最大力量差。为了简单，我们把参赛者编号为 $1$ 到 $2n$。\n\n接下来 $2n$ 行，每行描述一个参赛者，这些行中的第 $i$ 行包含三个正整数 $l_i,r_i,s_i$，分别表示 $i$ 号选手有力量 $s_i$，并且想站在左边的 $l_i$ 位置或是右边的 $r_i$ 位置。", "outputFormat": "你的程序应在第一行输出一个单词 `YES` 或 `NO`，表示是否有可能建立两支符合上述条件的队伍。", "hint": "### 样例解释 1\n\n第一个样例中我们可以安排 $1,3,6,7$ 号选手站在左边（这个队伍力量值为 $1+8+2+1=12$），并安排 $2,4,5,8$ 号选手站在右边（这个队伍力量值为 $2+2+5+2=11$）。力量值的差为 $1$。\n\n### 样例解释 2\n\n第二个样例中两位力量值为 $4$ 的选手不得不在一个队中，因此两队最小的力量值之差为 $6$。\n\n### 子任务\n\n以下子任务与评测无关，仅供参考。\n\n本题采用子任务式测评，只有一个子任务内所有测试点均正确才可获得此子任务的分数。\n\n对于全部子任务，$k\\le 20n,1\\le l_i,r_i\\le n,1\\le s_i\\le 20$。\n\n对于每个子任务满足的条件如下：\n\n| 子任务 |           条件            | 分数 |\n| :----: | :-----------------------: | :--: |\n|  $1$   |         $n\\le 10$         | $18$ |\n|  $2$   |    $n\\le 2\\times 10^3$    | $30$ |\n|  $3$   | $n\\le 3\\times 10^4,s_i=1$ | $23$ |\n|  $4$   |    $n\\le 3\\times 10^4$    | $29$ |\n\n~~注：实际上，拔河并不取决于力量而取决于双方体重。原题的选手力量值应正比于选手体重值。~~\n\n### 附注\n\n本题翻译搬运自 [LibreOJ](https://loj.ac/problem/2707)，译者为 HeRaNO，在此对原翻译者表示感谢。", "locale": "zh-CN"}}}
{"pid": "P4734", "type": "P", "difficulty": 4, "samples": [["4\n7 6 8 4", "13"], ["5\n1 1 1 1 1", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["贪心", "2015", "线段树", "单调队列", "前缀和", "ST 表", "构造", "BalticOI（波罗的海）"], "title": "[BalticOI 2015] Hacker", "background": "", "description": "Byteasar the hacker has qualified for this year’s IHO, the International Hacking Olympiad. One of the tasks in the Olympiad involves competing against a system operator. There are $n$ computers numbered from $1$ to $n$,connected in a ring topology, i.e. computers $i$ and $i+1$ are connected $(for \\ i = 1,...,n-1)$, and also computers $n$ and $1$ are connected.\nThe competition is performed as a game between the hacker and the system operator:\n   - Byteasar moves first. Afterwards, the operator and Byteasar move alternately.\n   - In his first move, Byteasar chooses any computer and hacks it (for instance,by exploiting some operating system vulnerabilities).\n   - In his first move, the operator chooses any non-hacked computer and protects it (for instance, by installing latest security upgrades).\n   - In all his following moves, Byteasar either (a) does nothing or (b) chooses any computer that is neither hacked nor protected and is directly linked to any hacked computer, and hacks it.\n   - In all his following moves, the operator either (a) does nothing or (b) chooses any computer that is neither hacked nor protected and is directly linked to any protected computer, and protects it.\n   - The game ends as soon as both have done nothing in two subsequent moves.\n\nAt the beginning of the game none of the computers are hacked or protected.\nEvery computer $i$ has a certain value viwhich specifies the value of the data which is stored on it. For each hacked computer $i$, Byteasar scores its value $v_i$. Byteasar is quite a good hacker, but has no idea of algorithms.\nThat is why he asks you to write a program that computes his maximum possible score, assuming that the operator plays optimally.", "inputFormat": "The first line of input contains a positive integer $n(n \\ge 2)$, specifying the number of computers. The second line contains a sequence of $n$ integers $v_1,v_2,...,v_n(1 \\le v_i \\le 2000)$; number vispecifies the value of the data\nstored on computer $i$.", "outputFormat": "In the first and only line of output your program should write one integer: Byteasar’s maximum possible score against an optimally playing operator.", "hint": "**Explanation to the examples:** In the first example, Byteasar in his first move should hack computer $2$(scoring $6$). The operator’s response will be protecting computer $3$. In the next move Byteasar can hack computer $1$ (scoring $7$). Finally, the operator will protect computer $4$.\n\n以下子任务与评测无关，仅供参考。\n\n![PVIZHx.png](https://s1.ax1x.com/2018/07/05/PVIZHx.png)", "locale": "en", "translations": {"en": {"title": "[BalticOI 2015] Hacker", "background": "", "description": "Byteasar the hacker has qualified for this year’s IHO, the International Hacking Olympiad. One of the tasks in the Olympiad involves competing against a system operator. There are $n$ computers numbered from $1$ to $n$,connected in a ring topology, i.e. computers $i$ and $i+1$ are connected $(for \\ i = 1,...,n-1)$, and also computers $n$ and $1$ are connected.\nThe competition is performed as a game between the hacker and the system operator:\n   - Byteasar moves first. Afterwards, the operator and Byteasar move alternately.\n   - In his first move, Byteasar chooses any computer and hacks it (for instance,by exploiting some operating system vulnerabilities).\n   - In his first move, the operator chooses any non-hacked computer and protects it (for instance, by installing latest security upgrades).\n   - In all his following moves, Byteasar either (a) does nothing or (b) chooses any computer that is neither hacked nor protected and is directly linked to any hacked computer, and hacks it.\n   - In all his following moves, the operator either (a) does nothing or (b) chooses any computer that is neither hacked nor protected and is directly linked to any protected computer, and protects it.\n   - The game ends as soon as both have done nothing in two subsequent moves.\n\nAt the beginning of the game none of the computers are hacked or protected.\nEvery computer $i$ has a certain value viwhich specifies the value of the data which is stored on it. For each hacked computer $i$, Byteasar scores its value $v_i$. Byteasar is quite a good hacker, but has no idea of algorithms.\nThat is why he asks you to write a program that computes his maximum possible score, assuming that the operator plays optimally.", "inputFormat": "The first line of input contains a positive integer $n(n \\ge 2)$, specifying the number of computers. The second line contains a sequence of $n$ integers $v_1,v_2,...,v_n(1 \\le v_i \\le 2000)$; number vispecifies the value of the data\nstored on computer $i$.", "outputFormat": "In the first and only line of output your program should write one integer: Byteasar’s maximum possible score against an optimally playing operator.", "hint": "**Explanation to the examples:** In the first example, Byteasar in his first move should hack computer $2$(scoring $6$). The operator’s response will be protecting computer $3$. In the next move Byteasar can hack computer $1$ (scoring $7$). Finally, the operator will protect computer $4$.\n\n以下子任务与评测无关，仅供参考。\n\n![PVIZHx.png](https://s1.ax1x.com/2018/07/05/PVIZHx.png)", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2015] Hacker", "background": null, "description": "### 题面描述\n\nByteasar 获得了今年国际黑客奥林匹克竞赛的参赛资格。竞赛的任务之一是与系统操作员竞争。有从 $1$ 到 $n$ 编号的 $n$ 台计算机，以环形连接，即计算机 $i$ 和 $i+1$ 连接（其中 $i = 1,2,\\dots,n-1$），特别的，计算机 $n$ 和 $1$ 也连接。\n\n这个任务是黑客和系统操作员之间的游戏：\n\n- Byteasar 先走。之后，操作员和 Byteasar 交替移动。\n- Byteasar 的第一步是选择任何一台计算机并对其进行黑客攻击。\n- 在他的第一步中，操作员选择任何未被黑客攻击的计算机并对其进行保护。\n- 在接下来的所有动作中，Byteasar 要么什么都不做，要么选择任意一台既没有被黑客攻击也没有受到保护的计算机且该计算机直接链接到任意一台被黑客攻击的计算机，然后对其进行黑客攻击。\n- 在接下来的所有动作中，操作员要么什么都不做，要么选择任意一台既没有被黑客攻击也没有受到保护的计算机且该计算机直接链接到任何受保护的计算机并对其进行保护。\n- 一旦两人在接下来的两个动作中都没有做任何事情，游戏就结束了。\n\n在游戏开始时，没有任何一台电脑被黑客攻击或受到保护。\n\n每台计算机 $i$ 都有一个特定的值 $v_i$，该值指定了存储在这台电脑上的数据的价值。Byteasar 最终获得的分数就是所有被他攻击的计算机的 $v$ 值之和。\n\n虽然 Byteasar 是一个很好的黑客，但对算法一无所知——这就是为什么他要求你编写一个程序来计算他的最大的可能分数，假设操作员按最优策略进行操作。", "inputFormat": "第一行输入包含一个正整数 $n(n\\ge 2)$，指定计算机的数量。第二行包含一个含有 $n$ 个整数的序列 $v_1,v_2,\\dots,v_n(1\\le v_i\\le 2000)$。", "outputFormat": "在输出的第一行，也是唯一一行，你的程序应该输出一个整数：Byteasar 获得的总得分的最大值。", "hint": "对样例的说明：\n\n在第一个样例中，Byteasar 应在第一步黑客攻击编号为 $2$ 的计算机（得分为 $6$）。系统操作员第二步选择保护编号为 $3$ 的计算机。接下来 Byteasar 选择黑客攻击编号为 $1$ 的计算机（得分为 $7$）。最后，系统操作员选择保护编号为 $4$ 的计算机。由于双方都不能继续操作，游戏结束。最后 Byteasar 的得分为 $13$，可以证明这是他的最大得分。\n\n数据范围：\n\n对于 $100\\%$ 的数据，满足 $2 \\le n \\le 5 \\times 10^5,1\\le v_i\\le 2000$。", "locale": "zh-CN"}}}
{"pid": "P4735", "type": "P", "difficulty": 6, "samples": [["5 5\n2 6 4 3 6\nA 1 \nQ 3 5 4 \nA 4\nQ 5 7 0 \nQ 3 6 6 ", "4\n5\n6"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "可持久化", "前缀和", "字典树 Trie"], "title": "最大异或和", "background": "", "description": "给定一个非负整数序列 $\\{a\\}$，初始长度为 $N$。  \n\n有 $M$ 个操作，有以下两种操作类型：  \n\n1. `A x`：添加操作，表示在序列末尾添加一个数 $x$，序列的长度 $N$ 加 $1$。  \n2. `Q l r x`：询问操作，你需要找到一个位置 $p$，满足 $l \\le p \\le r$，使得：$a[p] \\oplus a[p+1] \\oplus ... \\oplus a[N] \\oplus x$ 最大，输出最大值。  ", "inputFormat": "第一行包含两个整数 $N, M$，含义如问题描述所示。     \n第二行包含 $N$ 个非负整数，表示初始的序列 $A$。   \n接下来 $M$ 行，每行描述一个操作，格式如题面所述。     ", "outputFormat": "假设询问操作有 $T$ 个，则输出应该有 $T$ 行，每行一个整数表示询问的答案。", "hint": "- 对于所有测试点，$1\\le N,M \\le 3\\times 10 ^ 5$，$0\\leq a_i\\leq 10 ^ 7$。", "locale": "zh-CN", "translations": {"en": {"title": "Maximum XOR Sum", "background": "", "description": "You are given a sequence of non-negative integers $\\{a\\}$ with initial length $N$.\n\nThere are $M$ operations of the following two types:\n\n1. `A x`: an append operation, meaning that a number $x$ is appended to the end of the sequence, and the length $N$ increases by $1$.\n2. `Q l r x`: a query operation. You need to find a position $p$ such that $l \\le p \\le r$, to maximize $a[p] \\oplus a[p+1] \\oplus ... \\oplus a[N] \\oplus x$, and output the maximum value.", "inputFormat": "The first line contains two integers $N, M$, as described above.  \nThe second line contains $N$ non-negative integers, representing the initial sequence $A$.  \nThe next $M$ lines each describe one operation, in the format given in the statement.", "outputFormat": "Suppose there are $T$ query operations. Output $T$ lines, each containing one integer, which is the answer to a query.", "hint": "- For all test cases, $1 \\le N, M \\le 3 \\times 10 ^ 5$, $0 \\le a_i \\le 10 ^ 7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最大异或和", "background": "", "description": "给定一个非负整数序列 $\\{a\\}$，初始长度为 $N$。  \n\n有 $M$ 个操作，有以下两种操作类型：  \n\n1. `A x`：添加操作，表示在序列末尾添加一个数 $x$，序列的长度 $N$ 加 $1$。  \n2. `Q l r x`：询问操作，你需要找到一个位置 $p$，满足 $l \\le p \\le r$，使得：$a[p] \\oplus a[p+1] \\oplus ... \\oplus a[N] \\oplus x$ 最大，输出最大值。  ", "inputFormat": "第一行包含两个整数 $N, M$，含义如问题描述所示。     \n第二行包含 $N$ 个非负整数，表示初始的序列 $A$。   \n接下来 $M$ 行，每行描述一个操作，格式如题面所述。     ", "outputFormat": "假设询问操作有 $T$ 个，则输出应该有 $T$ 行，每行一个整数表示询问的答案。", "hint": "- 对于所有测试点，$1\\le N,M \\le 3\\times 10 ^ 5$，$0\\leq a_i\\leq 10 ^ 7$。", "locale": "zh-CN"}}}
{"pid": "P4736", "type": "P", "difficulty": 3, "samples": [["2 17\n...........\n---.#--.---\n...........\n---.---.---\n...........\n", "...........\nhnd.#lb.fpj\n...........\nkqg.cma.eoi\n...........\n"], ["6 26\n...........\n---.---.###\n#-#.---.---\n---.###.---\n...........\n---.###.---\n#--.#-#.--#\n#--.--#.#-#\n...........\n", "...........\ngke.aic.###\n#-#.mzo.r-v\nx-p.###.n-t\n...........\nfjb.###.dlh\n#-s.#-#.w-#\n#-u.qy#.#-#\n...........\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "ICPC", "CERC"], "title": "[CERC2017] Assignment Algorithm", "background": "", "description": "A low-budget airline is designing a sophisticated algorithm that will assign more desirable seats to passengers who buy tickets earlier. Their airplane has $r$ rows of seats, where $r$ is an even integer. There are also $3$ exit rows in the airplane; those rows do not contain any seats but only provide access to the emergency exits. One exit row is in the very front of the airplane (before the first row of seats), one in the very back (behind the last row of seats) and one right in the middle. The rows are numbered with integers $1$ through $r + 3$ with row numbers increasing from the front to the back of the airplane. Rows\nnumbered $1$, $r/2 + 2$ and $r + 3$ are exit rows while all the other rows are seat rows.\nThe seating configuration is “3–3–3” — each seat row contains three groups of three seats with the passenger aisles between the groups. Seats in the same row are denoted with consecutive letters left to right corresponding to the pattern “``ABC.DEF.GHI``”.\nWhen a passenger purchases a ticket, she is assigned a seat according to the following rules:\n   1.    If there is an empty seat in a row directly after an exit row, all other rows are ignored in the following step (but they are not ignored when balancing the airplane in the last step).\n   2.    First, we select a seat row with the largest number of empty seats. If there are multiple such rows,we select the one closest to an exit row (distance between rows $a$ and $b$ is simply $|a − b|$). If there are still multiple such rows, we select the one with the lowest number.\n   3.    Now, we consider empty seats in the selected row and select one with the highest priority. Seat priorities, from highest to lowest are as follows:\n   - (a) Aisle seats in the middle group (``D`` or ``F``).\n   - (b) Aisle seats in the first and third group (``C`` or ``G``).\n   - (c) Window seats (``A`` or ``I``).\n   - (d) Middle seat in the middle group (``E``).\n   - (e) Other middle seats (``B`` or ``H``).\n\nIf there are two empty seats with the same highest priority, we consider the balance of the entire airplane. The airplane’s left side contains all seats with letters ``A``, ``B``, ``C`` or ``D``, while the right side contains all seats with letters ``F``, ``G``, ``H`` or ``I``. We select an empty seat in the side with more empty seats. If both sides have the same number of empty seats, we select the seat in the left side of the airplane.\n\nSome of the airplane’s seats are already reserved (possibly using a completely different procedure from the one described above). Determine the seats assigned to the next $n$ passengers purchasing a ticket.\n", "inputFormat": "The first line contains two integers $r$ and $n(2 \\le r \\le 50, 1 \\le n \\le 26)$ — the number of seat rows in the airplane (always an even integer) and the number of new passengers purchasing tickets. The following $r + 3$ lines contain the current layout of the airplane. The $j-th$ line contains exactly $11$ characters — the layout of the row $j$ of the airplane. Exit rows and aisles are denoted with the “``.``” characters. The “``#``” character denotes a reserved seat, while the “``-``” character denotes a seat that is currently empty. You may assume there will be at least $n$ empty seats in the airplane.\n", "outputFormat": "Output $r + 3$ lines containing the final layout of the airplane. The layout should be exactly the same as in input with the following exception: the seat assigned to the $j-th$ passenger purchasing a ticket should be denoted with the $j-th$ lowercase letter of the English alphabet.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2017] Assignment Algorithm", "background": "", "description": "A low-budget airline is designing a sophisticated algorithm that will assign more desirable seats to passengers who buy tickets earlier. Their airplane has $r$ rows of seats, where $r$ is an even integer. There are also $3$ exit rows in the airplane; those rows do not contain any seats but only provide access to the emergency exits. One exit row is in the very front of the airplane (before the first row of seats), one in the very back (behind the last row of seats) and one right in the middle. The rows are numbered with integers $1$ through $r + 3$ with row numbers increasing from the front to the back of the airplane. Rows\nnumbered $1$, $r/2 + 2$ and $r + 3$ are exit rows while all the other rows are seat rows.\nThe seating configuration is “3–3–3” — each seat row contains three groups of three seats with the passenger aisles between the groups. Seats in the same row are denoted with consecutive letters left to right corresponding to the pattern “``ABC.DEF.GHI``”.\nWhen a passenger purchases a ticket, she is assigned a seat according to the following rules:\n   1.    If there is an empty seat in a row directly after an exit row, all other rows are ignored in the following step (but they are not ignored when balancing the airplane in the last step).\n   2.    First, we select a seat row with the largest number of empty seats. If there are multiple such rows,we select the one closest to an exit row (distance between rows $a$ and $b$ is simply $|a − b|$). If there are still multiple such rows, we select the one with the lowest number.\n   3.    Now, we consider empty seats in the selected row and select one with the highest priority. Seat priorities, from highest to lowest are as follows:\n   - (a) Aisle seats in the middle group (``D`` or ``F``).\n   - (b) Aisle seats in the first and third group (``C`` or ``G``).\n   - (c) Window seats (``A`` or ``I``).\n   - (d) Middle seat in the middle group (``E``).\n   - (e) Other middle seats (``B`` or ``H``).\n\nIf there are two empty seats with the same highest priority, we consider the balance of the entire airplane. The airplane’s left side contains all seats with letters ``A``, ``B``, ``C`` or ``D``, while the right side contains all seats with letters ``F``, ``G``, ``H`` or ``I``. We select an empty seat in the side with more empty seats. If both sides have the same number of empty seats, we select the seat in the left side of the airplane.\n\nSome of the airplane’s seats are already reserved (possibly using a completely different procedure from the one described above). Determine the seats assigned to the next $n$ passengers purchasing a ticket.\n", "inputFormat": "The first line contains two integers $r$ and $n(2 \\le r \\le 50, 1 \\le n \\le 26)$ — the number of seat rows in the airplane (always an even integer) and the number of new passengers purchasing tickets. The following $r + 3$ lines contain the current layout of the airplane. The $j-th$ line contains exactly $11$ characters — the layout of the row $j$ of the airplane. Exit rows and aisles are denoted with the “``.``” characters. The “``#``” character denotes a reserved seat, while the “``-``” character denotes a seat that is currently empty. You may assume there will be at least $n$ empty seats in the airplane.\n", "outputFormat": "Output $r + 3$ lines containing the final layout of the airplane. The layout should be exactly the same as in input with the following exception: the seat assigned to the $j-th$ passenger purchasing a ticket should be denoted with the $j-th$ lowercase letter of the English alphabet.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Assignment Algorithm", "background": "", "description": "一家航空公司正在设计一种复杂的算法，将为提前购票的乘客分配更理想的座位。他们的飞机有 $r$ 排座位，其中 $r$ 是一个偶数。飞机上有 $3$ 行出口行，这些排没有座位，只提供通往紧急出口的通道。一个出口排在飞机的最前面（在第一排座椅之前），一个在最后面（在最后一排座椅之后），另一个在中间的位置。这些行用整数 $1$ 到 $r+3$ 进行编号，行号从飞机前部到后部递增。\n\n编号为 $1$、$r/2+2$ 和 $r+3$ 的行是出口行，而所有其他行都是座位行。\n座位配置为 “$3–3–3$” 每排座位包含三个组三个座位，每组座位之间有乘客通道。同一排座位用从左到右的连续字母表示，对应于“``ABC.DEF.GHI``”模式。\n当乘客购买机票时，会根据以下规则为其分配座位：\n\n1.如果在出口排的正后方有一排空座位，则在接下来的步骤中忽略所有其他排（但在最后一步中平衡飞机时不忽略）。\n\n2.首先，我们选择空座位数最多的一排座位。如果有多个这样的行，则选择最靠近出口行的行（行 $a$ 和 $b$ 之间的距离仅为 $|a− b|$）。如果仍有多个这样的行，则选择编号最低的行。\n\n3.现在，我们考虑所选行中的空座位，并选择一个优先级最高的座位。座位优先级从高到低排序按照如下规则：\\\n-（a）中间组的过道座位（即`D`或`F`）。\\\n-（b）第一组和第三组的过道座位（即``C``或``G``）。\\\n-（c）靠窗座位（即``A``或``I``）。\\\n-（d）中间组中的中间座位（即`E`）。\\\n-（e）第一组和第三组的中间座位（即``B``或``H``）。\\\n如果有两个空座位具有相同的最高优先级，我们会考虑整个飞机的平衡。飞机左侧包含字母``A``、``B``、`C`或`D`的所有座位，而右侧包含字母`F` 、`G`、`H`或 `I` 的所有座位。我们在空座位较多的一侧选择一个空座位。如果两边有相同数量的空座位，则优先选择飞机左侧的座位。\\\n飞机的一些座位已经预定好了（即输入中的 `#`）。现在请你确定分配给第 $i$ 个购票的乘客的座位。", "inputFormat": "第一行包含两个整数 $r$ 和 $n$ （$2\\le r \\le50，1\\le n \\le26$）表示飞机中的座位排数（保证为偶数）和购买机票的乘客数。第 $2$ 到 $r+3$ 行包含飞机的当前布局。第 $j$ 行正好包含 $11$ 个字符，即飞机第 $j$ 行的布局。出口行和通道用 “``.``” 字符表示。“``#``” 字符表示已经预定好的座位，而“``-``”表示当前空座位。保证飞机上至少有 $n$ 个空座位。", "outputFormat": "输出包含飞机最终布局的 $r+3$ 行。整体布局应与输入中的布局相同，分配给第 $j$ 个购票乘客的座位应使用英文字母，依次从小写字母 $a$ 到 $z$ 表示。\n\n### 样例输入 #1.\n\n```\n2 17\n...........\n---.#--.---\n...........\n---.---.---\n...........\n```\n\n### 样例输出 #1\n\n```\n...........\nhnd.#lb.fpj\n...........\nkqg.cma.eoi\n...........\n```\n\n### 样例输入 #2\n\n```\n6 26\n...........\n---.---.###\n#-#.---.---\n---.###.---\n...........\n---.###.---\n#--.#-#.--#\n#--.--#.#-#\n...........\n```\n\n### 样例输出 #2\n\n```\n...........\ngke.aic.###\n#-#.mzo.r-v\nx-p.###.n-t\n...........\nfjb.###.dlh\n#-s.#-#.w-#\n#-u.qy#.#-#\n...........\n```", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4737", "type": "P", "difficulty": 6, "samples": [["7\n1 1\n4 2\n6 2\n5 3\n2 5\n4 7\n7 5\n4\n4 4\n8 2\n9 6\n6 5", "2\n1\n3\n2"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "并查集", "ICPC", "CERC"], "title": "[CERC2017] Buffalo Barricades", "background": "", "description": "A pasture in the wild west can be represented as a rectangular grid embedded in the upper-right quadrant of a standard coordinate system. A herd of $n$ buffalos is scattered throughout the grid, each occupying a unit square. Buffalos are numbered $1$ through $n$; buffalo $j$ is located in the unit square whose upper-right corner is the point with integer coordinates $(x_j,y_j)$. The coordinate axes represent two rivers meeting at the origin, restricting buffalo movement downwards and leftwards.\n\nA total of $m$ settlers arrive, one by one, and each claims a piece of land using the following procedure:\n   1.    The settler picks a point with integer coordinates and installs a single fence post at that point.The point he picks is guaranteed to be free of any previously installed fence posts or fences.Moreover, no two fence posts will have the same $x$-coordinate and no two fence posts will have the same $y$-coordinates.\n   2.    Starting from the fence post, the settler builds horizontal and vertical fence segments leftwards and downwards, respectively. Each segment is built to be as long as possible — i. e. until it reaches the river or another fence.\n   3.    The settler claims all the land in the connected area bounded with fences and rivers whose upper-right corner is his fence post. Of course, he claims all the buffalos inside as well. Note that settlers arriving later may claim pieces of land already claimed by earlier settlers.\n\nFor each settler, find the total number of buffalos he claimed when he arrived.\n", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 300 000)$ — the number of buffalos. The $j-th$ of the following $n$ lines contains two integers $x_j$ and $y_j(1 \\le x_j,y_j \\le 10^9)$ — the location of the $j-th$ buffalo.No two buffalos will share the same location.\nThe following line contains an integer $m(1 \\le m \\le 300 000)$ — the number of settlers. The $j-th$ of the following $m$ lines contains two integers $x^{'}_{j}$ and $y^{'}_{j}(1 \\le x^{'}_{j},y^{'}_{j} \\le 10^9)$ — the coordinates of the fence postinstalled by the $j-th$ settler. All $x^{'}_{j}$ are different and all $y^{'}_{j}$ are different.\n", "outputFormat": "Output $m$ lines. The $j-th$ line should contain the number of buffalos claimed by the $j-th$ settler upon arrival.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2017] Buffalo Barricades", "background": "", "description": "A pasture in the wild west can be represented as a rectangular grid embedded in the upper-right quadrant of a standard coordinate system. A herd of $n$ buffalos is scattered throughout the grid, each occupying a unit square. Buffalos are numbered $1$ through $n$; buffalo $j$ is located in the unit square whose upper-right corner is the point with integer coordinates $(x_j,y_j)$. The coordinate axes represent two rivers meeting at the origin, restricting buffalo movement downwards and leftwards.\n\nA total of $m$ settlers arrive, one by one, and each claims a piece of land using the following procedure:\n   1.    The settler picks a point with integer coordinates and installs a single fence post at that point.The point he picks is guaranteed to be free of any previously installed fence posts or fences.Moreover, no two fence posts will have the same $x$-coordinate and no two fence posts will have the same $y$-coordinates.\n   2.    Starting from the fence post, the settler builds horizontal and vertical fence segments leftwards and downwards, respectively. Each segment is built to be as long as possible — i. e. until it reaches the river or another fence.\n   3.    The settler claims all the land in the connected area bounded with fences and rivers whose upper-right corner is his fence post. Of course, he claims all the buffalos inside as well. Note that settlers arriving later may claim pieces of land already claimed by earlier settlers.\n\nFor each settler, find the total number of buffalos he claimed when he arrived.\n", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 300 000)$ — the number of buffalos. The $j-th$ of the following $n$ lines contains two integers $x_j$ and $y_j(1 \\le x_j,y_j \\le 10^9)$ — the location of the $j-th$ buffalo.No two buffalos will share the same location.\nThe following line contains an integer $m(1 \\le m \\le 300 000)$ — the number of settlers. The $j-th$ of the following $m$ lines contains two integers $x^{'}_{j}$ and $y^{'}_{j}(1 \\le x^{'}_{j},y^{'}_{j} \\le 10^9)$ — the coordinates of the fence postinstalled by the $j-th$ settler. All $x^{'}_{j}$ are different and all $y^{'}_{j}$ are different.\n", "outputFormat": "Output $m$ lines. The $j-th$ line should contain the number of buffalos claimed by the $j-th$ settler upon arrival.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Buffalo Barricades", "background": "", "description": "（西进运动时期）美国西部的一块牧场可以被表示为坐标系第一象限中的一块矩形网格。有 $n$ 头水牛在其中分布着，每一头都占据着一个单位正方形。水牛们从 $1$ 到 $n$ 编号；$j$ 号水牛位于右上角坐标为 $(x_j, y_j)$ 的单位正方形中。坐标轴表示了两条交汇于原点处的河流，阻止水牛向左下方移动。\n\n一共有 $m$ 个殖民者接连到达，每个人都要宣称一块土地的所有权，其过程遵循以下规则：\n\n1. 殖民者选定一个整数坐标点，并在此处安装一个栅栏柱。他选定的点必须没有被此前安装的栅栏或栅栏柱占据。并且，不存在两个栅栏柱会拥有相同的 $x$ 坐标，也不存在两个栅栏柱会拥有相同的 $y$ 坐标。\n2. 从栅栏柱开始，殖民者分别朝着左侧或下侧修建水平或竖直的栅栏片段。每段栅栏都修建得尽可能长：即直到碰到了河流或另一段栅栏才停下。\n3. 殖民者宣称以他的栅栏柱为右上角的，被栅栏和河流包围住的连通区域的所有权。当然，他也宣称了其中的所有水牛的所有权。注意后到来的殖民者也有可能宣称了已被先到来的殖民者宣称过的土地。\n\n对于每个殖民者，请求出当他刚到来时，被他宣称了所有权的水牛的数量。", "inputFormat": "第一行一个正整数 $n$，表示水牛的个数。\n\n接下来 $n$ 行，第 $j$ 行两个正整数 $x_j, y_j$，表示第 $j$ 头水牛的位置，不存在两头水牛的位置重合。\n\n接下来一行一个正整数 $m$，表示殖民者的个数。\n\n接下来 $m$ 行，第 $j$ 行两个正整数 $x'_j, y'_j$，表示第 $j$ 个殖民者安装的栅栏柱的位置，所有 $x'_j$ 互不相同，所有 $y'_j$ 互不相同。", "outputFormat": "输出 $m$ 行，第 $j$ 行一个整数，表示第 $j$ 个殖民者刚到来时，被他宣称了所有权的水牛的数量。", "hint": "对于全部数据，$1 \\le n, m \\le 3 \\times {10}^5$，$1 \\le x_j, y_j, x'_j, y'_j \\le {10}^9$，所有有序数对 $(x_j, y_j)$ 互不相同，所有 $x'_j$ 互不相同，所有 $y'_j$ 互不相同。\n\n**翻译来源**：IOI 2021 集训队第一部分作业，PinkRabbit。", "locale": "zh-CN"}}}
{"pid": "P4738", "type": "P", "difficulty": 6, "samples": [["3 5\n1 1 1\n2 1 1\n3 1 1\n4 1 1\n5 1 1", "2\n2\n1\n3\n3"], ["4 4\n2 1 5\n4 4 3\n4 8 1\n10 3 2", "18\n15\n5\n13"], ["7 1\n1 1 125", "4031"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "ICPC", "CERC"], "title": "[CERC2017] Cumulative Code", "background": "", "description": "As you probably know, a tree is a graph consisting of $n$ nodes and $n - 1$ undirected edges in which any two nodes are connected by exactly one path. In a labeled tree each node is labeled with a different integer between $1$ and $n$.\nThe Prüfer code of a labeled tree is a unique sequence associated with the tree, generated by repeatedly removing nodes from the tree until only two nodes remain. More precisely, in each step we remove the leaf with the smallest label and append the label of its neighbour to the end of the code. Recall, a leaf is\na node with exactly one neighbour. Therefore, the Prüfer code of a labeled tree is an integer sequence of length $n - 2$. It can be shown that the original tree can be easily reconstructed from its Prüfer code.\nThe complete binary tree of depth $k$, denoted with $C_k$, is a labeled tree with $2^k - 1$ nodes where node $j$ is connected to nodes $2j$ and $2j + 1$ for all $j < 2^{k-1}$. Denote the Prüfer code of $C_k$ with $p_1,p_2,..., p_{2^k-3}$.\nSince the Prüfer code of $C_k$ can be quite long, you do not have to print it out. Instead, you need to answer $n$ questions about the sums of certain elements on the code. Each question consists of three integers: $a, d$ and $m$. The answer is the sum of the of the $C_k'$ s Prüfer code elements $p_a, p_{a+d},p_{a+2d},...,p_{a+(m-1)d}$.\n", "inputFormat": "The first line contains two integers $k$ and $q(2 \\le k \\le 30,1 \\le q \\le 300)$ — the depth of the complete binary tree and the number of questions. The $j-th$ of the following $q$ lines contains the $j-th$ question:three positive integers $a_j,d_j$ and $m_j$ such that $a_j,d_j$ and $a_j + (m_j - 1)d_j$ are all at most $2^k - 3$.\n", "outputFormat": "Output 1 lines. The $j-th$ line should contain a single integer — the answer to the $j-th$ question.\n", "hint": "In the first example above, when constructing the Prüfer code for $C_3$ the nodes are removed in the following order: $4, 5, 2, 1, 6$. Therefore, the Prüfer code of $C_3$ is $2, 2, 1, 3, 3$.\n", "locale": "en", "translations": {"en": {"title": "[CERC2017] Cumulative Code", "background": "", "description": "As you probably know, a tree is a graph consisting of $n$ nodes and $n - 1$ undirected edges in which any two nodes are connected by exactly one path. In a labeled tree each node is labeled with a different integer between $1$ and $n$.\nThe Prüfer code of a labeled tree is a unique sequence associated with the tree, generated by repeatedly removing nodes from the tree until only two nodes remain. More precisely, in each step we remove the leaf with the smallest label and append the label of its neighbour to the end of the code. Recall, a leaf is\na node with exactly one neighbour. Therefore, the Prüfer code of a labeled tree is an integer sequence of length $n - 2$. It can be shown that the original tree can be easily reconstructed from its Prüfer code.\nThe complete binary tree of depth $k$, denoted with $C_k$, is a labeled tree with $2^k - 1$ nodes where node $j$ is connected to nodes $2j$ and $2j + 1$ for all $j < 2^{k-1}$. Denote the Prüfer code of $C_k$ with $p_1,p_2,..., p_{2^k-3}$.\nSince the Prüfer code of $C_k$ can be quite long, you do not have to print it out. Instead, you need to answer $n$ questions about the sums of certain elements on the code. Each question consists of three integers: $a, d$ and $m$. The answer is the sum of the of the $C_k'$ s Prüfer code elements $p_a, p_{a+d},p_{a+2d},...,p_{a+(m-1)d}$.\n", "inputFormat": "The first line contains two integers $k$ and $q(2 \\le k \\le 30,1 \\le q \\le 300)$ — the depth of the complete binary tree and the number of questions. The $j-th$ of the following $q$ lines contains the $j-th$ question:three positive integers $a_j,d_j$ and $m_j$ such that $a_j,d_j$ and $a_j + (m_j - 1)d_j$ are all at most $2^k - 3$.\n", "outputFormat": "Output 1 lines. The $j-th$ line should contain a single integer — the answer to the $j-th$ question.\n", "hint": "In the first example above, when constructing the Prüfer code for $C_3$ the nodes are removed in the following order: $4, 5, 2, 1, 6$. Therefore, the Prüfer code of $C_3$ is $2, 2, 1, 3, 3$.\n", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Cumulative Code", "background": "", "description": "如你所知，树是一个由 $n$ 个节点和 $n - 1$ 条无向边组成的图，其中任意两个节点之间有且仅有一条路径。在标记树中，每个节点都用 $1$ 到 $n$ 之间的不同整数标记。标记树的 Prüfer 码是与该树相关联的唯一序列，通过不断从树中移除节点直到只剩下两个节点来生成。更确切地说，在每一步中，我们移除标号最小的叶子，并将其邻居的标号附加到代码的末尾。回忆一下，叶子是一个只有一个邻居的节点。因此，标记树的 Prüfer 码是一个长度为 $n - 2$ 的整数序列。可以证明，原始树可以很容易地从其 Prüfer 码重建。深度为 $k$ 的完全二叉树，记为 $C_k$，是一个有 $2^k - 1$ 个节点的标记树，其中对于所有 $j < 2^{k-1}$，节点 $j$ 连接到节点 $2j$ 和 $2j + 1$。记 $C_k$ 的 Prüfer 码为 $p_1,p_2,..., p_{2^k-3}$。由于 $C_k$ 的 Prüfer 码可能很长，你不需要输出它。相反，你需要回答关于代码中某些元素和的 $n$ 个问题。每个问题由三个整数组成：$a, d$ 和 $m$。答案是 $C_k$ 的 Prüfer 码元素 $p_a, p_{a+d}, p_{a+2d},..., p_{a+(m-1)d}$ 的和。", "inputFormat": "第一行包含两个整数 $k$ 和 $q(2 \\le k \\le 30,1 \\le q \\le 300)$ —— 完全二叉树的深度和问题的数量。接下来的 $q$ 行中的第 $j$ 行包含第 $j$ 个问题：三个正整数 $a_j, d_j$ 和 $m_j$，使得 $a_j, d_j$ 和 $a_j + (m_j - 1)d_j$ 都最多为 $2^k - 3$。", "outputFormat": "输出 $q$ 行。第 $j$ 行应包含一个整数 —— 第 $j$ 个问题的答案。", "hint": "在上面的第一个例子中，当构造 $C_3$ 的 Prüfer 码时，节点按以下顺序被移除：$4, 5, 2, 1, 6$。因此，$C_3$ 的 Prüfer 码是 $2, 2, 1, 3, 3$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4739", "type": "P", "difficulty": 5, "samples": [["4 4\n1 2 9 3\n3 5 4 8\n4 3 2 7\n5 8 1 6\n4\nmove 1\nmove 1\nchange 1 4 100\nmove 1\n", "4 2\n1 3\n1 4\n"], ["3 4\n10 20 30 40\n50 60 70 80\n90 93 95 99\n3\nmove 4\nchange 2 1 100\nmove 4\n", "3 1\n2 1\n"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "线段树", "倍增", "ICPC", "CERC"], "title": "[CERC2017] Donut Drone", "background": "", "description": "You are building a simulation in which a drone explores a volatile torus-shaped planet. Technically,the drone is moving across a toroidal grid — a rectangular grid that wraps around circularly in both dimensions. The grid consists of cells organized into $r$ rows numbered $1$ through $r$ top to bottom and $c$\ncolumns numbered $1$ through $c$ left to right. Each grid cell has a certain elevation — a positive integer.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/c7d7xb1p.png)\n\nThe drone is initially located in the cell in the first row and first column. In each step the drone considers three cells: the cell directly to the right, the cell diagonally right-down and the cell diagonally right-up (wrapping around if necessary). The drone flies to the cell with the largest elevation of the three.\n\nTwo types of events may happen during the simulation:\n   - “``move k``” — The drone makes $k$ steps.\n   - “``change a b e``” — The elevation of the cell in row $a$ column $b$ changes to $e$.\n\nFind the drone’s position immediately after each ``move`` event. You may assume that at each point in time, no sequence of three circularly consecutive cells in the same column will have the same elevation.\nHence, each drone step is well defined.\n", "inputFormat": "The first line contains two integers $r$ and $c(3 \\le r,c \\le 2 000)$ — the number of rows and the number of columns of the toroidal grid. The $i-th$ of the following $r$ lines contains a sequence of $c$ integers $e_{i,1},e_{i,2},...,e_{i,c}(1 \\le e_{i,j} \\le 10^9)$ — the initial elevations of cells in row $i$.\n\nThe following line contains an integer $m(1 \\le m \\le 5 000)$ — the number of events. The $j-th$ of the following $m$ lines contains the $j-th$ event and is either of the form “``move k``” where $k$ is an integer such that $1 \\le k \\le 10^9$ or “``change a b e``” where $a,b$ and $e$ are integers such that $1 \\le a \\le r, 1 \\le b \\le c$ and $1 \\le e \\le 10^9$.\n", "outputFormat": "Output $w$ lines where $w$ is the number of ``move`` events in the input — the $j-th$ line should contain the drone’s position (row and column numbers) after the $j-th$ ``move`` event in the input.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2017] Donut Drone", "background": "", "description": "You are building a simulation in which a drone explores a volatile torus-shaped planet. Technically,the drone is moving across a toroidal grid — a rectangular grid that wraps around circularly in both dimensions. The grid consists of cells organized into $r$ rows numbered $1$ through $r$ top to bottom and $c$\ncolumns numbered $1$ through $c$ left to right. Each grid cell has a certain elevation — a positive integer.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/c7d7xb1p.png)\n\nThe drone is initially located in the cell in the first row and first column. In each step the drone considers three cells: the cell directly to the right, the cell diagonally right-down and the cell diagonally right-up (wrapping around if necessary). The drone flies to the cell with the largest elevation of the three.\n\nTwo types of events may happen during the simulation:\n   - “``move k``” — The drone makes $k$ steps.\n   - “``change a b e``” — The elevation of the cell in row $a$ column $b$ changes to $e$.\n\nFind the drone’s position immediately after each ``move`` event. You may assume that at each point in time, no sequence of three circularly consecutive cells in the same column will have the same elevation.\nHence, each drone step is well defined.\n", "inputFormat": "The first line contains two integers $r$ and $c(3 \\le r,c \\le 2 000)$ — the number of rows and the number of columns of the toroidal grid. The $i-th$ of the following $r$ lines contains a sequence of $c$ integers $e_{i,1},e_{i,2},...,e_{i,c}(1 \\le e_{i,j} \\le 10^9)$ — the initial elevations of cells in row $i$.\n\nThe following line contains an integer $m(1 \\le m \\le 5 000)$ — the number of events. The $j-th$ of the following $m$ lines contains the $j-th$ event and is either of the form “``move k``” where $k$ is an integer such that $1 \\le k \\le 10^9$ or “``change a b e``” where $a,b$ and $e$ are integers such that $1 \\le a \\le r, 1 \\le b \\le c$ and $1 \\le e \\le 10^9$.\n", "outputFormat": "Output $w$ lines where $w$ is the number of ``move`` events in the input — the $j-th$ line should contain the drone’s position (row and column numbers) after the $j-th$ ``move`` event in the input.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Donut Drone", "background": "", "description": "你正在构建一个模拟，其中一架无人机在一个不稳定的环形星球上探索。技术上来说，无人机在一个环形网格上移动——一个在两个维度上都循环连接的矩形网格。网格由 $r$ 行组成，从上到下编号为 $1$ 到 $r$，以及 $c$ 列，从左到右编号为 $1$ 到 $c$。每个网格单元都有一定的海拔——一个正整数。\n\n无人机最初位于第一行第一列的单元格中。在每一步中，无人机会考虑三个单元格：直接向右的单元格、右下对角线的单元格和右上对角线的单元格（如有必要，进行循环连接）。无人机飞向这三个单元格中海拔最高的那个。\n\n在模拟过程中可能发生两种类型的事件：\n- “`move k`”——无人机移动 $k$ 步。\n- “`change a b e`”——第 $a$ 行第 $b$ 列的单元格的海拔变为 $e$。\n\n在每个 `move` 事件之后，找到无人机的位置。你可以假设在任何时候，同一列中连续的三个循环单元格不会有相同的海拔。因此，每一步无人机的移动都是明确的。", "inputFormat": "第一行包含两个整数 $r$ 和 $c(3 \\le r,c \\le 2 000)$——环形网格的行数和列数。接下来的 $r$ 行中的第 $i$ 行包含一个 $c$ 个整数的序列 $e_{i,1},e_{i,2},...,e_{i,c}(1 \\le e_{i,j} \\le 10^9)$——第 $i$ 行中单元格的初始海拔。\n\n接下来的一行包含一个整数 $m(1 \\le m \\le 5 000)$——事件的数量。接下来的 $m$ 行中的第 $j$ 行包含第 $j$ 个事件，形式为“`move k`”，其中 $k$ 是一个整数，满足 $1 \\le k \\le 10^9$，或者“`change a b e`”，其中 $a,b$ 和 $e$ 是整数，满足 $1 \\le a \\le r, 1 \\le b \\le c$ 和 $1 \\le e \\le 10^9$。", "outputFormat": "输出 $w$ 行，其中 $w$ 是输入中 `move` 事件的数量——第 $j$ 行应包含输入中第 $j$ 个 `move` 事件后无人机的位置（行号和列号）。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4740", "type": "P", "difficulty": 6, "samples": [["5\n1 2\n2 3\n2 4\n4 5", "4"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2017", "ICPC", "CERC"], "title": "[CERC2017] Embedding Enumeration", "background": "", "description": "As you probably know, a tree is a graph consisting of $n$ nodes and $n - 1$ undirected edges in which any two nodes are connected by exactly one path. In a labeled tree each node is labeled with a different integer between $1$ and $n$. In general, it may be hard to visualize trees nicely, but some trees can be\nneatly embedded in rectangular grids.\n\nGiven a labeled tree $G$ with $n$ nodes, a $2$ by $n$ embedding of $G$ is a mapping of nodes of $G$ to the cells of a rectangular grid consisting of $2$ rows and $n$ columns such that:\n   - Node $1$ is mapped to the cell in the upper-left corner.\n   - Nodes connected with an edge are mapped to neighboring grid cells (up, down, left or right).\n   - No two nodes are mapped to the same cell.\n\nFind the number of $2$ by $n$ embeddings of a given tree, modulo $10^9 + 7$.", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 300 000)$ — the number of nodes in $G$. The $j-th$ of the following $n - 1$ lines contains two different integers $a_j$ and $b_j(1 \\le a_j,b_j \\le n)$ — the endpoints of the $j-th$ edge.\n", "outputFormat": "Output the number of $2$ by $n$ embeddings of the given tree, modulo $10^9 + 7$.", "hint": "![PZgNB8.png](https://s1.ax1x.com/2018/07/06/PZgNB8.png)\n\nAll $4$ embeddings of the tree in the example input are given in the figure above.\n", "locale": "en", "translations": {"en": {"title": "[CERC2017] Embedding Enumeration", "background": "", "description": "As you probably know, a tree is a graph consisting of $n$ nodes and $n - 1$ undirected edges in which any two nodes are connected by exactly one path. In a labeled tree each node is labeled with a different integer between $1$ and $n$. In general, it may be hard to visualize trees nicely, but some trees can be\nneatly embedded in rectangular grids.\n\nGiven a labeled tree $G$ with $n$ nodes, a $2$ by $n$ embedding of $G$ is a mapping of nodes of $G$ to the cells of a rectangular grid consisting of $2$ rows and $n$ columns such that:\n   - Node $1$ is mapped to the cell in the upper-left corner.\n   - Nodes connected with an edge are mapped to neighboring grid cells (up, down, left or right).\n   - No two nodes are mapped to the same cell.\n\nFind the number of $2$ by $n$ embeddings of a given tree, modulo $10^9 + 7$.", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 300 000)$ — the number of nodes in $G$. The $j-th$ of the following $n - 1$ lines contains two different integers $a_j$ and $b_j(1 \\le a_j,b_j \\le n)$ — the endpoints of the $j-th$ edge.\n", "outputFormat": "Output the number of $2$ by $n$ embeddings of the given tree, modulo $10^9 + 7$.", "hint": "![PZgNB8.png](https://s1.ax1x.com/2018/07/06/PZgNB8.png)\n\nAll $4$ embeddings of the tree in the example input are given in the figure above.\n", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Embedding Enumeration", "background": "", "description": "如你所知，树是一种图结构，由 $n$ 个节点和 $n - 1$ 条无向边组成，其中任意两个节点之间恰好有一条路径。在标记树中，每个节点都被标记为 $1$ 到 $n$ 之间的不同整数。通常情况下，树的可视化可能比较困难，但有些树可以整齐地嵌入到矩形网格中。\n\n给定一个具有 $n$ 个节点的标记树 $G$，一个 $2 \\times n$ 的嵌入是将 $G$ 的节点映射到一个由 $2$ 行和 $n$ 列组成的矩形网格的单元格中，满足以下条件：\n- 节点 $1$ 被映射到左上角的单元格。\n- 通过边连接的节点被映射到相邻的网格单元格（上、下、左或右）。\n- 没有两个节点被映射到同一个单元格。\n\n求给定树的 $2 \\times n$ 嵌入的数量，结果对 $10^9 + 7$ 取模。", "inputFormat": "第一行包含一个整数 $n(1 \\le n \\le 300 000)$，表示 $G$ 中的节点数。接下来的 $n - 1$ 行中的第 $j$ 行包含两个不同的整数 $a_j$ 和 $b_j(1 \\le a_j,b_j \\le n)$，表示第 $j$ 条边的两个端点。", "outputFormat": "输出给定树的 $2 \\times n$ 嵌入的数量，结果对 $10^9 + 7$ 取模。", "hint": "![PZgNB8.png](https://s1.ax1x.com/2018/07/06/PZgNB8.png)\n\n图中给出了示例输入中树的所有 $4$ 种嵌入。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4741", "type": "P", "difficulty": 5, "samples": [["8 65\n-1\n36\n21\n97\n-65\n17\n1\n43", "2"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["素数判断,质数,筛法", "栈"], "title": "[Wind Festival] Finding RhFe", "background": "$[Morning - 8:00 A.M.]$\n\n热衷于结交老铁的 gyx 小哥哥听说了风筝节的举办，一大早就来到了现场，现在他已经迫不及待见到来玩的同学们啦~", "description": "gyx 的人格魅力是无限哒~\n\n已知风筝节上有 $N$（$1\\le N\\le 10^6$）个同学（来玩的人真的很多），每个同学都对 gyx 有一个兴趣程度 $c_i$（$ |c_i|\\le 10^9$），因为 gyx 的性格特点太明显啦，不存在对 gyx 兴趣程度为 $0$ 的同学，对于每个同学，都可以和 gyx 结交为老铁，gyx 的高兴程度就是所有结！交！过！成为老铁的同学对 gyx 兴趣程度之和。gyx 不愿意做令自己伤心的事情，所以如果所有同学对 gyx 感到反感（即兴趣程度为负）gyx 就会直接离开风筝节。\n\ngyx 可以选择其中的 $k$（$1\\le k\\le N$）个同学来结交，但一旦选择好，gyx 的结交顺序就不可以变化了。\n\n因为来风筝节的人实在是太多啦，gyx 不愿意记住所有的老铁太长的时间，但是 gyx 的脑子里记着与越早结交的老铁的点点滴滴越多，也越难忘记，gyx 忘记每个人的条件是当且仅当，在 gyx 还记着的老铁里当前的这个老铁是最后结交的。\n\n但是由于 gyx 希望与更多不同性格的同学结交，gyx 与每一个同学只愿意结交一次，即使遗忘以后也不会再次结交。\n\n当风筝节上 gyx 选择的同学都结交结束后，随着时间的流逝，gyx 也会渐渐地把所有同学都忘掉，遗忘方式与之前相同，直到最后忘记了自己结交过的所有老铁，再出发前往新的征程。\n\n由于不同的交友并遗忘的顺序可能会发生有趣的事情，gyx 想知道在保证自己高兴程度最大时选择好结交范围和结交顺序的情况下，gyx 可以有多少种不同的交友并遗忘的顺序呢？\n\n由于来风筝节的人实在是太多了，gyx 只想知道不同顺序的方案数的值对 $P$（$0<P\\le 10^9$）取模后的结果。", "inputFormat": "第一行是两个数 $N$ 和 $P$，分别表示来风筝节的同学人数和方案数要对P取模；\n\n接下来的 $N$ 行每行一个 $c_i$ 的值，表示第 $i$ 个同学对 gyx 的兴趣程度；", "outputFormat": "如果所有人对 gyx 都感到讨厌输出 `Terrible Place`；\n\n其他情况输出对 $P$ 取模后不同的顺序的方案数的值；", "hint": "对于 $30\\%$ 的数据保证：$1\\le N\\le 30$；\n\n对于 $70\\%$ 的数据保证：$1\\le N\\le 500$；\n\n对于 $100\\%$ 的数据保证：$1\\le N\\le 10^6$，$0<P\\le 10^9$，$|c_i|\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[Wind Festival] Finding RhFe", "background": "$[Morning - 8:00 A.M.]$\n\nThe sociable guy gyx heard that the kite festival was being held and arrived early in the morning. He can’t wait to meet the students who came to have fun.", "description": "The personal charm of gyx is limitless.\n\nAt the kite festival, there are $N$ students ($1 \\le N \\le 10^6$). Each student has an interest level $c_i$ in gyx ($|c_i| \\le 10^9$). Because gyx’s personality is very distinctive, no student has an interest level of $0$. For each student, gyx can befriend them as a \"laotie\". gyx’s happiness is the sum of the interest levels of all the classmates he has befriended as \"laotie\". gyx does not want to do anything that makes him sad, so if all classmates dislike him (i.e., their interest levels are negative), gyx will leave the festival immediately.\n\ngyx may choose $k$ classmates to befriend ($1 \\le k \\le N$), but once the set is chosen, the befriending order must follow their original order.\n\nBecause there are so many people at the festival, gyx does not want to remember all \"laotie\" for too long. He remembers more about those befriended earlier, and they are harder to forget. The condition for gyx to forget someone is if and only if, among the \"laotie\" he still remembers, the current one is the most recently befriended.\n\nHowever, since gyx wants to befriend more classmates with different personalities, he is willing to befriend each classmate at most once. Even after forgetting, he will not befriend them again.\n\nAfter all the students chosen by gyx have been befriended, as time passes, gyx will gradually forget all of them in the same manner as above, until he has forgotten every \"laotie\" he befriended, and then sets off on a new journey.\n\nBecause different sequences of befriending and forgetting may lead to interesting situations, gyx wants to know, while ensuring his happiness is maximized by choosing whom to befriend (thus fixing the order to their original order), how many different sequences of befriending and forgetting are possible.\n\nBecause there are so many people at the festival, gyx only wants the number of different sequences modulo $P$ ($0 < P \\le 10^9$).", "inputFormat": "The first line contains two integers $N$ and $P$, representing the number of students at the festival and the modulus $P$ for the answer.\n\nThe next $N$ lines each contain one value $c_i$, representing the interest level of the $i$-th student in gyx.", "outputFormat": "If everyone dislikes gyx, output `Terrible Place`.\n\nOtherwise, output the number of different sequences modulo $P$.", "hint": "For $30\\%$ of the testdata: $1 \\le N \\le 30$.\n\nFor $70\\%$ of the testdata: $1 \\le N \\le 500$.\n\nFor $100\\%$ of the testdata: $1 \\le N \\le 10^6$, $0 < P \\le 10^9$, $|c_i| \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Wind Festival] Finding RhFe", "background": "$[Morning - 8:00 A.M.]$\n\n热衷于结交老铁的 gyx 小哥哥听说了风筝节的举办，一大早就来到了现场，现在他已经迫不及待见到来玩的同学们啦~", "description": "gyx 的人格魅力是无限哒~\n\n已知风筝节上有 $N$（$1\\le N\\le 10^6$）个同学（来玩的人真的很多），每个同学都对 gyx 有一个兴趣程度 $c_i$（$ |c_i|\\le 10^9$），因为 gyx 的性格特点太明显啦，不存在对 gyx 兴趣程度为 $0$ 的同学，对于每个同学，都可以和 gyx 结交为老铁，gyx 的高兴程度就是所有结！交！过！成为老铁的同学对 gyx 兴趣程度之和。gyx 不愿意做令自己伤心的事情，所以如果所有同学对 gyx 感到反感（即兴趣程度为负）gyx 就会直接离开风筝节。\n\ngyx 可以选择其中的 $k$（$1\\le k\\le N$）个同学来结交，但一旦选择好，gyx 的结交顺序就不可以变化了。\n\n因为来风筝节的人实在是太多啦，gyx 不愿意记住所有的老铁太长的时间，但是 gyx 的脑子里记着与越早结交的老铁的点点滴滴越多，也越难忘记，gyx 忘记每个人的条件是当且仅当，在 gyx 还记着的老铁里当前的这个老铁是最后结交的。\n\n但是由于 gyx 希望与更多不同性格的同学结交，gyx 与每一个同学只愿意结交一次，即使遗忘以后也不会再次结交。\n\n当风筝节上 gyx 选择的同学都结交结束后，随着时间的流逝，gyx 也会渐渐地把所有同学都忘掉，遗忘方式与之前相同，直到最后忘记了自己结交过的所有老铁，再出发前往新的征程。\n\n由于不同的交友并遗忘的顺序可能会发生有趣的事情，gyx 想知道在保证自己高兴程度最大时选择好结交范围和结交顺序的情况下，gyx 可以有多少种不同的交友并遗忘的顺序呢？\n\n由于来风筝节的人实在是太多了，gyx 只想知道不同顺序的方案数的值对 $P$（$0<P\\le 10^9$）取模后的结果。", "inputFormat": "第一行是两个数 $N$ 和 $P$，分别表示来风筝节的同学人数和方案数要对P取模；\n\n接下来的 $N$ 行每行一个 $c_i$ 的值，表示第 $i$ 个同学对 gyx 的兴趣程度；", "outputFormat": "如果所有人对 gyx 都感到讨厌输出 `Terrible Place`；\n\n其他情况输出对 $P$ 取模后不同的顺序的方案数的值；", "hint": "对于 $30\\%$ 的数据保证：$1\\le N\\le 30$；\n\n对于 $70\\%$ 的数据保证：$1\\le N\\le 500$；\n\n对于 $100\\%$ 的数据保证：$1\\le N\\le 10^6$，$0<P\\le 10^9$，$|c_i|\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4742", "type": "P", "difficulty": 4, "samples": [["5 5\n8 9 11 6 7\n1 2\n2 3\n2 4\n4 5\n5 2", "41 11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论建模", "拓扑排序", "强连通分量"], "title": "[Wind Festival] Running In The Sky", "background": "$[Night - 20:02$ $P.M.]$\n\n夜空真美啊……但是……快要结束了呢……", "description": "一天的活动过后，所有学生都停下来欣赏夜空下点亮的风筝。$Curtis$ $Nishikino$想要以更近的视角感受一下，所以她跑到空中的风筝上去了(这对于一个妹子来说有点匪夷所思)! 每只风筝上的灯光都有一个亮度 $k_i$. 由于风的作用，一些风筝缠在了一起。但是这并不会破坏美妙的气氛，缠在一起的风筝会将灯光汇聚起来，形成更亮的光源！\n\n$Curtis$ $Nishikino$已经知道了一些风筝间的关系，比如给出一对风筝$(a,b)$, 这意味着她可以从 $a$ 跑到 $b$ 上去，但是不能返回。\n\n现在，请帮她找到一条路径(她可以到达一只风筝多次，但只在第一次到达时她会去感受上面的灯光), 使得她可以感受到最多的光亮。同时请告诉她这条路径上单只风筝的最大亮度，如果有多条符合条件的路径，输出能产生最大单只风筝亮度的答案。", "inputFormat": "第一行两个整数 $n$ 和 $m$. $n$ 是风筝的数量, $m$ 是风筝间关系对的数量. \n\n接下来一行 $n$ 个整数 $k_i$.\n\n接下来 $m$ 行, 每行两个整数 $a$ 和 $b$, 即$Curtis$可以从 $a$ 跑到 $b$.", "outputFormat": "一行两个整数。$Curtis$在计算出的路径上感受到的亮度和，这条路径上的单只风筝最大亮度.", "hint": "对于 $20\\%$ 的数据, $0<n \\le 5\\times10^3, \\ 0 < m \\le 10^4$.\n\n对于 $80\\%$ 的数据, $0 < n \\le 10^5, \\ 0 < m \\le 3\\times10^5$.\n\n对于 $100\\%$ 的数据, $0<n\\le2\\times10^5,\\ 0<m\\le5\\times10^5,\\ 0<k\\le200$.\n", "locale": "zh-CN", "translations": {"en": {"title": "[Wind Festival] Running In The Sky", "background": "[Night - 20:02 P.M.]\n\nThe night sky is so beautiful... but... it is about to end soon....", "description": "After a day of activities, all the students stop to admire the kites lit up under the night sky. Curtis Nishikino wants to experience it from a closer view, so she runs onto the kites in the sky (which is a bit unbelievable for a girl)! Each kite’s light has a brightness $k_i$. Because of the wind, some kites get tangled together. This does not ruin the mood—tangled kites pool their lights to form a brighter light source.\n\nCurtis Nishikino already knows some relations between the kites: for a given pair of kites $(a, b)$, she can run from $a$ to $b$, but she cannot return.\n\nNow, please help her find a path (she may reach a kite multiple times, but only the first arrival counts toward the light she experiences) so that she experiences the maximum total brightness. Also tell her the maximum brightness of a single kite on this path. If there are multiple paths that achieve the same total brightness, output the answer that yields the maximum single-kite brightness.", "inputFormat": "The first line contains two integers $n$ and $m$. Here, $n$ is the number of kites, and $m$ is the number of relation pairs.\n\nThe next line contains $n$ integers $k_i$.\n\nEach of the next $m$ lines contains two integers $a$ and $b$, meaning Curtis can run from $a$ to $b$.", "outputFormat": "Output one line with two integers: the total brightness Curtis experiences along the computed path, and the maximum brightness of a single kite on that path.", "hint": "For $20\\%$ of the testdata, $0<n \\le 5\\times10^3, \\ 0 < m \\le 10^4$.\n\nFor $80\\%$ of the testdata, $0 < n \\le 10^5, \\ 0 < m \\le 3\\times10^5$.\n\nFor $100\\%$ of the testdata, $0<n\\le2\\times10^5,\\ 0<m\\le5\\times10^5,\\ 0<k_i\\le200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Wind Festival] Running In The Sky", "background": "$[Night - 20:02$ $P.M.]$\n\n夜空真美啊……但是……快要结束了呢……", "description": "一天的活动过后，所有学生都停下来欣赏夜空下点亮的风筝。$Curtis$ $Nishikino$想要以更近的视角感受一下，所以她跑到空中的风筝上去了(这对于一个妹子来说有点匪夷所思)! 每只风筝上的灯光都有一个亮度 $k_i$. 由于风的作用，一些风筝缠在了一起。但是这并不会破坏美妙的气氛，缠在一起的风筝会将灯光汇聚起来，形成更亮的光源！\n\n$Curtis$ $Nishikino$已经知道了一些风筝间的关系，比如给出一对风筝$(a,b)$, 这意味着她可以从 $a$ 跑到 $b$ 上去，但是不能返回。\n\n现在，请帮她找到一条路径(她可以到达一只风筝多次，但只在第一次到达时她会去感受上面的灯光), 使得她可以感受到最多的光亮。同时请告诉她这条路径上单只风筝的最大亮度，如果有多条符合条件的路径，输出能产生最大单只风筝亮度的答案。", "inputFormat": "第一行两个整数 $n$ 和 $m$. $n$ 是风筝的数量, $m$ 是风筝间关系对的数量. \n\n接下来一行 $n$ 个整数 $k_i$.\n\n接下来 $m$ 行, 每行两个整数 $a$ 和 $b$, 即$Curtis$可以从 $a$ 跑到 $b$.", "outputFormat": "一行两个整数。$Curtis$在计算出的路径上感受到的亮度和，这条路径上的单只风筝最大亮度.", "hint": "对于 $20\\%$ 的数据, $0<n \\le 5\\times10^3, \\ 0 < m \\le 10^4$.\n\n对于 $80\\%$ 的数据, $0 < n \\le 10^5, \\ 0 < m \\le 3\\times10^5$.\n\n对于 $100\\%$ 的数据, $0<n\\le2\\times10^5,\\ 0<m\\le5\\times10^5,\\ 0<k\\le200$.\n", "locale": "zh-CN"}}}
{"pid": "P4743", "type": "P", "difficulty": 6, "samples": [["4 4\n4 0 1 1 2 2 2 3 1\n2 0 1 2 1\n0\n2 1 2 3 1\n5\nQA\nI 2 \n2 1 1 3 2\nQS 2 4\nQA\nQS 1 1", "4\n1 1 1 2\n5\n1 2 2 1\nend"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["平衡树", "树状数组", "O2优化", "枚举"], "title": "[Wind Festival] Energy Center", "background": "$[Noon - 12:13$ $P.M.]$\n\n$Curtis$ $Nishikino$看到大家为晚会准备地如此认真，~~可爱的~~她也做起了志愿者！", "description": "$Curtis$ $Nishikino$来到了风筝节的能源中心，大家正在为晚会做准备. 这里共有 $N$ 台设备. 当然，由于计划的调整，可能会随时发生增删设备的操作. 但设备的总数不会超过$10^4$. 随时记录设备的数量也是志愿者的工作之一.\n\n每台设备都有一些属性，比如设备$i$, 对于她拥有的每个属性, 比如属性$j$, 都会有一个给定的值, 记为$value_{ij}$.但属性是共有的, 这意味着即便一台设备没有某个属性, 也只会使她这个属性的值为$0$. 属性的数量是$M$. 注意属性的编号是从$0$到$M-1$.\n\n现在志愿者们正尝试将一部分相邻设备联系在一起，效果如下：\n\n- 对于从$j$到$k$的设备, 最终效果$i$的值为 $\\sum_{p=j}^{k}value_{pi}$.\n\n志愿者需要$Curtis$帮忙，但做计算太麻烦了，$Curtis$ $Nishikino$也希望你能帮帮她.", "inputFormat": "第一行两个整数 $n$ 和 $m$.\n\n接下来 $n$ 行, 第一个整数 $k_i$,这意味着设备 $i$ 有 $k_i$ 个属性. 后面是 $2\\times k$ 个整数, $x_j$ 和 $y_j$, 这意味着 $value_{ix_j}=y_j$.\n\n下面是一个整数 $q$, 即 $q$ 个操作. 每项操作都是如下之一:\n\n$I$ $x$ :在设备 $x$ 后插入一台设备, 下面有一行描述信息，像初始化一样.\n\n$D$ $x$:丢弃第 $x$ 台设备.\n\n$QA$ :询问设备总数.\n\n$QS$ $l$ $r$: 询问连接设备 $l$ 到 $r$ 的效果.\n\n输入数据保证合法.", "outputFormat": "对于每个 $QA$, 输出一行一个整数.\n\n对于每个 $QS$, 输出一行 $m$ 个整数, 如果属性 $i$ 的值是 $0$, 在那个位置输出 $0$ 即可.\n\n###### 注意！\n\n请在完成所有操作后输出一行额外的 \"end\" (不包含双引号).", "hint": "对于 $15\\%$ 的数据, $0 < N \\le 10^3\\ , \\ 0<M \\le 10\\ , \\ 0 < q \\le 10^3$.\n\n对于额外的 $5\\%$ 数据, $0<N \\le 10^4\\ , \\ 0<M \\le 200\\ , \\ 0 < q \\le 10^4$, 保证没有 $QS$ 操作.\n\n对于 $100\\%$ 的数据, $0<N \\le 10^4\\ ,\\ 0<M \\le 200\\ , \\ 0<q\\le10^4$.", "locale": "zh-CN", "translations": {"en": {"title": "[Wind Festival] Energy Center", "background": "$[Noon - 12:13$ $P.M.]$\n\n$Curtis$ $Nishikino$ saw everyone preparing so seriously for the party, so this ~~cute~~ girl also became a volunteer!", "description": "$Curtis$ $Nishikino$ came to the energy center of the kite festival, where everyone is preparing for the party. There are a total of $N$ devices here. Of course, due to changes in the plan, devices may be added or removed at any time. However, the total number of devices will not exceed $10^4$. Keeping track of the number of devices at any time is also one of the volunteer's jobs.\n\nEach device has some attributes. For example, for device $i$, for each attribute it has (say attribute $j$), there is a given value, denoted as $value_{ij}$. But attributes are shared, which means that even if a device does not have a certain attribute, it only makes its value for that attribute equal to $0$. The number of attributes is $M$. Note that the attribute indices range from $0$ to $M-1$.\n\nNow the volunteers are trying to connect a consecutive segment of devices together, with the following effect:\n\n- For devices from $j$ to $k$, the final value of attribute $i$ is $\\sum_{p=j}^{k}value_{pi}$.\n\nThe volunteers need $Curtis$'s help, but doing the calculations is too troublesome. $Curtis$ $Nishikino$ also hopes you can help her.", "inputFormat": "The first line contains two integers $n$ and $m$.\n\nIn the next $n$ lines, the first integer is $k_i$, meaning device $i$ has $k_i$ attributes. Then there are $2\\times k$ integers, $x_j$ and $y_j$, meaning $value_{ix_j}=y_j$.\n\nThen there is an integer $q$, meaning there are $q$ operations. Each operation is one of the following:\n\n$I$ $x$: Insert a device after device $x$. The next line contains its description, the same as initialization.\n\n$D$ $x$: Discard the $x$-th device.\n\n$QA$: Query the total number of devices.\n\n$QS$ $l$ $r$: Query the effect of connecting devices $l$ to $r$.\n\nThe input is guaranteed to be valid.", "outputFormat": "For each $QA$, output one integer on a single line.\n\nFor each $QS$, output $m$ integers on one line. If the value of attribute $i$ is $0$, output $0$ at that position.\n\n###### Note！\n\nAfter completing all operations, please output one extra line: \"end\" (without the double quotes).", "hint": "For $15\\%$ of the testdata, $0 < N \\le 10^3\\ , \\ 0<M \\le 10\\ , \\ 0 < q \\le 10^3$.\n\nFor an additional $5\\%$ of the testdata, $0<N \\le 10^4\\ , \\ 0<M \\le 200\\ , \\ 0 < q \\le 10^4$, and it is guaranteed that there are no $QS$ operations.\n\nFor $100\\%$ of the testdata, $0<N \\le 10^4\\ ,\\ 0<M \\le 200\\ , \\ 0<q\\le10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Wind Festival] Energy Center", "background": "$[Noon - 12:13$ $P.M.]$\n\n$Curtis$ $Nishikino$看到大家为晚会准备地如此认真，~~可爱的~~她也做起了志愿者！", "description": "$Curtis$ $Nishikino$来到了风筝节的能源中心，大家正在为晚会做准备. 这里共有 $N$ 台设备. 当然，由于计划的调整，可能会随时发生增删设备的操作. 但设备的总数不会超过$10^4$. 随时记录设备的数量也是志愿者的工作之一.\n\n每台设备都有一些属性，比如设备$i$, 对于她拥有的每个属性, 比如属性$j$, 都会有一个给定的值, 记为$value_{ij}$.但属性是共有的, 这意味着即便一台设备没有某个属性, 也只会使她这个属性的值为$0$. 属性的数量是$M$. 注意属性的编号是从$0$到$M-1$.\n\n现在志愿者们正尝试将一部分相邻设备联系在一起，效果如下：\n\n- 对于从$j$到$k$的设备, 最终效果$i$的值为 $\\sum_{p=j}^{k}value_{pi}$.\n\n志愿者需要$Curtis$帮忙，但做计算太麻烦了，$Curtis$ $Nishikino$也希望你能帮帮她.", "inputFormat": "第一行两个整数 $n$ 和 $m$.\n\n接下来 $n$ 行, 第一个整数 $k_i$,这意味着设备 $i$ 有 $k_i$ 个属性. 后面是 $2\\times k$ 个整数, $x_j$ 和 $y_j$, 这意味着 $value_{ix_j}=y_j$.\n\n下面是一个整数 $q$, 即 $q$ 个操作. 每项操作都是如下之一:\n\n$I$ $x$ :在设备 $x$ 后插入一台设备, 下面有一行描述信息，像初始化一样.\n\n$D$ $x$:丢弃第 $x$ 台设备.\n\n$QA$ :询问设备总数.\n\n$QS$ $l$ $r$: 询问连接设备 $l$ 到 $r$ 的效果.\n\n输入数据保证合法.", "outputFormat": "对于每个 $QA$, 输出一行一个整数.\n\n对于每个 $QS$, 输出一行 $m$ 个整数, 如果属性 $i$ 的值是 $0$, 在那个位置输出 $0$ 即可.\n\n###### 注意！\n\n请在完成所有操作后输出一行额外的 \"end\" (不包含双引号).", "hint": "对于 $15\\%$ 的数据, $0 < N \\le 10^3\\ , \\ 0<M \\le 10\\ , \\ 0 < q \\le 10^3$.\n\n对于额外的 $5\\%$ 数据, $0<N \\le 10^4\\ , \\ 0<M \\le 200\\ , \\ 0 < q \\le 10^4$, 保证没有 $QS$ 操作.\n\n对于 $100\\%$ 的数据, $0<N \\le 10^4\\ ,\\ 0<M \\le 200\\ , \\ 0<q\\le10^4$.", "locale": "zh-CN"}}}
{"pid": "P4744", "type": "P", "difficulty": 6, "samples": [["6 2\n2 -4 3 -1 2 3\n", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "单调队列"], "title": "[Wind Festival] Iron Man", "background": "[Midnight - 23:59]\n\n在风筝节上交到了老铁(并不是 Nishikino)，接触了 OI，gyx 全身的热情都被点燃啦！！为了更好地参与到下一届风筝节的工作中去，gyx 准备开始为期一年的学习。\n", "description": "gyx 想用全部的时间学(tui)OI(fei)!!!\n\ngyx 为了合理的利用所有时间学 OI，他开始规划自己的学习计划。\n\n首先，gyx 的眼里每年有 $n$ 天，因为 gyx 实在是太想学习啦，所以他并没有留下玩耍的时间（每天都全部用来学 OI 或者文化课），gyx 划分天数的原则是，在每一天中，gyx 对 OI 的感兴趣程度相同。但是，未免 gyx 也会因生活琐事而没法静心学习，所以某些天 gyx 对 OI 的兴趣程度有可能是负的。\n\n然后，gyx 开始安排学习 OI 的时间，gyx 统计出他要学习的OI 知识有 $k$ 种。因为 gyx 是一个追求完美的人，他认为对于每一种 OI 知识，知识体系的完整性是必要的，某一个部分的 OI 知识学习过程中一旦停下来会影响自己的学习效果，所以他会用连续的一些天来学习一个部分的知识，期间不能停下来学习文化课，也不会穿插着进行几种知识的学习。\n\n但是注意，gyx 在进行每部分 OI 知识的学习之间可以留出一些时间段用来学文化课。并且，gyx 并不介意各个部分 OI 知识间学习的顺序，因为他对每一部分的 OI 知识兴趣程度是相同的。\n\n现在，gyx 想知道他总共用于学 OI 的日子兴趣值之和是多少，因为 gyx 还没有学习过高级的规划算法，所以 gyx 将他学习计划的规划交给你，你可以选择任意一个小于等于 $n$ 的一个正整数 $i$，使他从第 $i$ 天开始，进行长 $n$ 天的学习（不一定一开始就必须学 OI），但在这一年中他一定要把清单中所有的知识都学完，gyx 相信你一定能给出兴趣值之和最高的方法。\n\n", "inputFormat": "两个正整数 $n,k$，分别代表 gyx 眼中一年有 $n$ 天，gyx 要学习的知识有 $k$ 种。\n\n接下来一行有 $n$ 个整数，第 $i$ 个数 $a_i$ 代表 gyx 第 $i$ 天对 OI 的兴趣程度。", "outputFormat": "输出一个整数，代表他总共学 OI 的所有日子兴趣值之和最大是多少。", "hint": "### 样例解释\n\n从第 $3$ 个时间段开始学习，那么他学 OI 的这一年兴趣程度的序列便为：\n\n- $[3,-1,2,3,2,-4]$。\n\n用于学习两个知识的时间段分别是新序列的第 $1$ 个和第 $3,4,5$ 个，于是 $ans=3+(2+3+2)=10$。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据，满足 $k=1$；\n- 对于另 $30\\%$ 的数据，满足 $k=2$；\n- 对于$100\\%$ 的数据，满足：$1\\le k\\le50$，$k\\le n\\le10^5$，$|a_i|\\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[Wind Festival] Iron Man", "background": "[Midnight - 23:59]\n\nAt the kite festival, gyx made some good buddies (not Nishikino), got in touch with OI, and all of his passion was ignited!! To better take part in the work for the next kite festival, gyx is ready to start a one-year study plan.", "description": "gyx wants to use all his time to study (slack off on) OI (waste time)!!!\n\nTo use all his time reasonably to study OI, he starts planning his study schedule.\n\nFirst, in gyx's eyes, each year has $n$ days. Because gyx really wants to study, he does not leave any time for entertainment (every day is fully used for studying OI or cultural courses). His rule for dividing days is: within each day, gyx's level of interest in OI is the same. However, since gyx may be unable to focus due to trivial life matters, on some days his interest in OI may be negative.\n\nThen, gyx starts arranging the time for studying OI. He counts that there are $k$ types of OI knowledge he needs to learn. Because gyx pursues perfection, he believes that for each type of OI knowledge, the completeness of the knowledge system is necessary. If he stops in the middle of learning a part of OI knowledge, it will affect his learning results. Therefore, he will use several consecutive days to learn one part of knowledge. During this period, he cannot stop to study cultural courses, and he will not mix learning multiple types of knowledge.\n\nNote that between learning different parts of OI knowledge, gyx can leave some time periods to study cultural courses. Also, gyx does not care about the order of learning different parts of OI knowledge, because his interest level is the same for each part of OI knowledge.\n\nNow, gyx wants to know the sum of interest values over all days he spends studying OI. Since gyx has not learned advanced planning algorithms, he hands the planning of his study schedule to you. You may choose any positive integer $i \\le n$ so that he starts from day $i$ and studies for $n$ days (he does not have to study OI at the beginning). However, within this year, he must finish learning all the knowledge on the list. gyx believes you can surely give a plan with the maximum possible sum of interest values.", "inputFormat": "Two positive integers $n, k$, representing that in gyx's eyes a year has $n$ days, and there are $k$ types of knowledge he needs to learn.\n\nThe next line contains $n$ integers. The $i$-th number $a_i$ represents gyx's interest level in OI on day $i$.", "outputFormat": "Output one integer, representing the maximum possible sum of interest values over all days he studies OI.", "hint": "### Sample Explanation\n\nStarting to study from the $3$-rd time period, the interest sequence for that year of studying OI becomes:\n\n- $[3,-1,2,3,2,-4]$.\n\nThe time periods used to learn the two types of knowledge are the $1$-st, and the $3, 4, 5$-th elements of the new sequence, so $ans = 3 + (2 + 3 + 2) = 10$.\n\n### Constraints\n\n- For $10\\%$ of the testdata, $k = 1$ holds.\n- For another $30\\%$ of the testdata, $k = 2$ holds.\n- For $100\\%$ of the testdata: $1 \\le k \\le 50$, $k \\le n \\le 10^5$, $|a_i| \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Wind Festival] Iron Man", "background": "[Midnight - 23:59]\n\n在风筝节上交到了老铁(并不是 Nishikino)，接触了 OI，gyx 全身的热情都被点燃啦！！为了更好地参与到下一届风筝节的工作中去，gyx 准备开始为期一年的学习。\n", "description": "gyx 想用全部的时间学(tui)OI(fei)!!!\n\ngyx 为了合理的利用所有时间学 OI，他开始规划自己的学习计划。\n\n首先，gyx 的眼里每年有 $n$ 天，因为 gyx 实在是太想学习啦，所以他并没有留下玩耍的时间（每天都全部用来学 OI 或者文化课），gyx 划分天数的原则是，在每一天中，gyx 对 OI 的感兴趣程度相同。但是，未免 gyx 也会因生活琐事而没法静心学习，所以某些天 gyx 对 OI 的兴趣程度有可能是负的。\n\n然后，gyx 开始安排学习 OI 的时间，gyx 统计出他要学习的OI 知识有 $k$ 种。因为 gyx 是一个追求完美的人，他认为对于每一种 OI 知识，知识体系的完整性是必要的，某一个部分的 OI 知识学习过程中一旦停下来会影响自己的学习效果，所以他会用连续的一些天来学习一个部分的知识，期间不能停下来学习文化课，也不会穿插着进行几种知识的学习。\n\n但是注意，gyx 在进行每部分 OI 知识的学习之间可以留出一些时间段用来学文化课。并且，gyx 并不介意各个部分 OI 知识间学习的顺序，因为他对每一部分的 OI 知识兴趣程度是相同的。\n\n现在，gyx 想知道他总共用于学 OI 的日子兴趣值之和是多少，因为 gyx 还没有学习过高级的规划算法，所以 gyx 将他学习计划的规划交给你，你可以选择任意一个小于等于 $n$ 的一个正整数 $i$，使他从第 $i$ 天开始，进行长 $n$ 天的学习（不一定一开始就必须学 OI），但在这一年中他一定要把清单中所有的知识都学完，gyx 相信你一定能给出兴趣值之和最高的方法。\n\n", "inputFormat": "两个正整数 $n,k$，分别代表 gyx 眼中一年有 $n$ 天，gyx 要学习的知识有 $k$ 种。\n\n接下来一行有 $n$ 个整数，第 $i$ 个数 $a_i$ 代表 gyx 第 $i$ 天对 OI 的兴趣程度。", "outputFormat": "输出一个整数，代表他总共学 OI 的所有日子兴趣值之和最大是多少。", "hint": "### 样例解释\n\n从第 $3$ 个时间段开始学习，那么他学 OI 的这一年兴趣程度的序列便为：\n\n- $[3,-1,2,3,2,-4]$。\n\n用于学习两个知识的时间段分别是新序列的第 $1$ 个和第 $3,4,5$ 个，于是 $ans=3+(2+3+2)=10$。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据，满足 $k=1$；\n- 对于另 $30\\%$ 的数据，满足 $k=2$；\n- 对于$100\\%$ 的数据，满足：$1\\le k\\le50$，$k\\le n\\le10^5$，$|a_i|\\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P4745", "type": "P", "difficulty": 6, "samples": [["4 4\n1 2\n1 3\n2 4\n3 4", "3.0000000000"], ["5 8\n1 2\n1 3\n1 4\n2 3\n2 4\n3 5\n5 4\n2 5", "4.1111111111\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "Special Judge", "ICPC", "CERC"], "title": "[CERC2017] Gambling Guide", "background": "", "description": "A railroad network in a nearby country consists of $n$ cities numbered $1$ through $n$, and $m$ two-way railroad tracks each connecting two different cities. Tickets can only be purchased at automated machines installed at every city. Unfortunately, hackers have tampered with the ticket machines and now they all work as follows: when a single coin is inserted in the machine installed at city $a$, the machine dispenses a single one-way ticket from $a$ to a random neighboring city. More precisely, the destination city is chosen uniformly at random among all cities directly connected to a with a railroad track. Destinations on different tickets originating in the same city are independent.\n\nA computer science student needs to travel from city $1$ (where she lives) to city $n$ (where a regional programming contest has already started). She knows how the machines work (but of course cannot predict the random choices) and has a map of the railway network. In each city, when she purchases a ticket, she can either immediately use it and travel to the destination city on the ticket, or discard the ticket and purchase a new one. She can keep purchasing tickets indefinitely. The trip is finished as soon as she reaches city $n$.\n\nAfter doing some calculations, she has devised a traveling strategy with the following properties:\n  - The probability that the trip will eventually finish is $1$.\n  - The expected number of coins spent on the trip is the smallest possible.\n\nFind the expected number of coins she will spend on the trip.", "inputFormat": "The first line contains two integers $n$ and $m(1 \\le n,m \\le 300 000)$ — the number of cities and the number of railroad tracks. Each of the following $m$ lines contains two different integers $a$ and $b(1 \\le a, b \\le n)$ which describe a railroad track connecting cities $a$ and $b$. \n\nThere will be at most one railroad track between each pair of cities. It will be possible to reach city $n$ starting from city $1$.", "outputFormat": "Output a single number — the expected number of coins spent. The solution will be accepted if the absolute or the relative difference from the judges solution is less than $10^{-6}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2017] Gambling Guide", "background": "", "description": "A railroad network in a nearby country consists of $n$ cities numbered $1$ through $n$, and $m$ two-way railroad tracks each connecting two different cities. Tickets can only be purchased at automated machines installed at every city. Unfortunately, hackers have tampered with the ticket machines and now they all work as follows: when a single coin is inserted in the machine installed at city $a$, the machine dispenses a single one-way ticket from $a$ to a random neighboring city. More precisely, the destination city is chosen uniformly at random among all cities directly connected to a with a railroad track. Destinations on different tickets originating in the same city are independent.\n\nA computer science student needs to travel from city $1$ (where she lives) to city $n$ (where a regional programming contest has already started). She knows how the machines work (but of course cannot predict the random choices) and has a map of the railway network. In each city, when she purchases a ticket, she can either immediately use it and travel to the destination city on the ticket, or discard the ticket and purchase a new one. She can keep purchasing tickets indefinitely. The trip is finished as soon as she reaches city $n$.\n\nAfter doing some calculations, she has devised a traveling strategy with the following properties:\n  - The probability that the trip will eventually finish is $1$.\n  - The expected number of coins spent on the trip is the smallest possible.\n\nFind the expected number of coins she will spend on the trip.", "inputFormat": "The first line contains two integers $n$ and $m(1 \\le n,m \\le 300 000)$ — the number of cities and the number of railroad tracks. Each of the following $m$ lines contains two different integers $a$ and $b(1 \\le a, b \\le n)$ which describe a railroad track connecting cities $a$ and $b$. \n\nThere will be at most one railroad track between each pair of cities. It will be possible to reach city $n$ starting from city $1$.", "outputFormat": "Output a single number — the expected number of coins spent. The solution will be accepted if the absolute or the relative difference from the judges solution is less than $10^{-6}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Gambling Guide", "background": "", "description": "一个铁路系统由 $n$ 个城市和 $m$ 条双向铁路组成。铁路票只能在安装在每个城市的自动售票机购买。不幸的是，黑客们已经篡改了这些售票机，现在它们有下面的规则：\n\n当 $a$ 市的售票机有一个硬币投入时，机器会发一张从 $a$ 市到随机一个邻市的单程票。\n\n你需要从城市 $1$ 到城市 $n$。你知道机器是怎么工作的并且有一份铁路系统的地图。在每一个城市，当你买了一张票时，你可以选择立即使用它后到达目的地，或者是丢掉它并买一张新票。你可以无限制的购买的票。当你到达城市 $n$，旅行就会结束。\n\n你需要确定一个满足以下条件的策略：\n\n- 旅行最终到达终点的概率为 $1$。\n\n- 花在旅行上的硬币的期望值越少越好。\n\n输出这个期望值。", "inputFormat": "第一行包含两个整数 $n$ 和 $m(1 \\le n,m \\le 300000)$。\n\n接下来 $m$ 行每行包含了两个不同的整数 $a$ 和 $b(1 \\le a,b \\le n)$，描述了一条连接 $a$ 市和 $b$ 市的双向铁路。\n\n两个城市之间最多只会有一条铁路，输入保证有一条从城市 $1$ 到 $n$ 的路径。", "outputFormat": "输出一个数，为期望值。此输出只要与正解的相对差或绝对差小于 $10^{−6}$ 就可以通过。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4746", "type": "P", "difficulty": 3, "samples": [["9\n/sys/kernel/notes 100\n/cerc/problems/a/testdata/in 1000000\n/cerc/problems/a/testdata/out 8\n/cerc/problems/a/luka.cc 500\n/cerc/problems/a/zuza.cc 5000\n/cerc/problems/b/testdata/in 15\n/cerc/problems/b/testdata/out 4\n/cerc/problems/b/kale.cc 100\n/cerc/documents/rules.pdf 4000\n10000", "- / 1009727\n- /cerc/ 1009627\n/cerc/documents/ 4000\n- /cerc/problems/ 1005627\n- /cerc/problems/a/ 1005508\n/cerc/problems/a/testdata/ 1000008\n+ /cerc/problems/b/ 119\n+ /sys/ 100\n"], ["8\n/b/test/in.a 100\n/b/test/in.b 1\n/c/test/in.a 100\n/c/test/in.b 1\n/c/test/pic/in.a.svg 10\n/c/test/pic/in.b.svg 10\n/a/test/in.a 99\n/a/test/in.b 1\n101\n", "- / 322\n+ /a/ 100\n- /b/ 101\n/b/test/ 101\n- /c/ 121\n+ /c/test/ 121"], ["2\n/a/a/a 100\n/b.txt 99\n200\n", "+ / 199\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "ICPC", "CERC"], "title": "[CERC2017] Hidden Hierarchy", "background": "", "description": "You are working on the user interface for a simple text-based file explorer. One of your tasks is to build a navigation pane displaying the directory hierarchy. As usual, the filesystem consists of directories which may contain files and other directories, which may, in turn, again contain files and other directories etc. Hence, the directories form a hierarchical tree structure. The top-most directoryin the hierarchy is called the root directory. If directory $d$ directly contains directory $e$ we will say that $d$ is the parent directory of $e$ while $e$ is a subdirectory od $d$. Each file has a size expressed in bytes. The directory size is simply the total size of all files directly or indirectly contained inside that directory.\n\nAll files and all directories except the root directory have a name — a string that always starts with a letter and consists of only lowercase letters and “``.``” (dot) characters. All items (files and directories) directly inside the same parent directory must have unique names. Each item (file and directory) can be uniquely described by its path — a string built according to the following rules:\n   - Path of the root directory is simply “``/``” (forward slash).\n   - For a directory $d$, its path is obtained by concatenating the directory names top to bottom along the hierarchy from the root directory to $d$, preceding each name with the “``/``” character and placing another “``/``” character at the end of the path.\n   - For a file $f$ , its path is the concatenation of the parent directory path and the name of file $f$ .\n\nWe display the directory hierarchy by printing the root directory. We print a directory $d$ by outputting a line of the form “$m_d \\ p_d \\ s_d$” where $p_d$ and $s_d$ are the path and size of directory $d$ respectively, while $m_d$ is its expansion marker explained shortly. If $d$ contains other directories we must choose either to collapse it or to expand it. If we choose to expand $d$ we print (using the same rules) all of its subdirectories in lexicographical order by name. If we choose to collapse directory $d$, we simply ignore its contents.\n\nThe expansion marker $m_d$ is a single blank character when $d$ does not have any subdirectories, “``+``” (plus) character when we choose to collapse $d$ or a “``-``” (minus) character when we choose expand $d$.\n\nGiven a list of files in the filesystem and a threshold integer $t$, display the directory hierarchy ensuring that each directory of size at least $t$ is printed. Additionally, the total number of directories printed should be minimal. Assume there are no empty directories in the filesystem — the entire hierarchy can be deduced from the provided file paths. Note that the root directory has to be printed regardless of its size. Also note that a directory of size at least $t$ only has to be printed, but not necessarily expanded.\n", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 1 000)$ — the number of files. Each of the following $n$ lines contains a string $f$ and an integer $s(1 \\le s \\le 10^6)$ — the path and the size of a single file. Each path is at most $100$ characters long and is a valid file path according to the rules above. All paths will be different.\n\nThe following line contains an integer $t(1 \\le t \\le 10^9)$ — the threshold directory size.", "outputFormat": "Output the minimal display of the filesystem hierarchy for the given threshold as described above.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2017] Hidden Hierarchy", "background": "", "description": "You are working on the user interface for a simple text-based file explorer. One of your tasks is to build a navigation pane displaying the directory hierarchy. As usual, the filesystem consists of directories which may contain files and other directories, which may, in turn, again contain files and other directories etc. Hence, the directories form a hierarchical tree structure. The top-most directoryin the hierarchy is called the root directory. If directory $d$ directly contains directory $e$ we will say that $d$ is the parent directory of $e$ while $e$ is a subdirectory od $d$. Each file has a size expressed in bytes. The directory size is simply the total size of all files directly or indirectly contained inside that directory.\n\nAll files and all directories except the root directory have a name — a string that always starts with a letter and consists of only lowercase letters and “``.``” (dot) characters. All items (files and directories) directly inside the same parent directory must have unique names. Each item (file and directory) can be uniquely described by its path — a string built according to the following rules:\n   - Path of the root directory is simply “``/``” (forward slash).\n   - For a directory $d$, its path is obtained by concatenating the directory names top to bottom along the hierarchy from the root directory to $d$, preceding each name with the “``/``” character and placing another “``/``” character at the end of the path.\n   - For a file $f$ , its path is the concatenation of the parent directory path and the name of file $f$ .\n\nWe display the directory hierarchy by printing the root directory. We print a directory $d$ by outputting a line of the form “$m_d \\ p_d \\ s_d$” where $p_d$ and $s_d$ are the path and size of directory $d$ respectively, while $m_d$ is its expansion marker explained shortly. If $d$ contains other directories we must choose either to collapse it or to expand it. If we choose to expand $d$ we print (using the same rules) all of its subdirectories in lexicographical order by name. If we choose to collapse directory $d$, we simply ignore its contents.\n\nThe expansion marker $m_d$ is a single blank character when $d$ does not have any subdirectories, “``+``” (plus) character when we choose to collapse $d$ or a “``-``” (minus) character when we choose expand $d$.\n\nGiven a list of files in the filesystem and a threshold integer $t$, display the directory hierarchy ensuring that each directory of size at least $t$ is printed. Additionally, the total number of directories printed should be minimal. Assume there are no empty directories in the filesystem — the entire hierarchy can be deduced from the provided file paths. Note that the root directory has to be printed regardless of its size. Also note that a directory of size at least $t$ only has to be printed, but not necessarily expanded.\n", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 1 000)$ — the number of files. Each of the following $n$ lines contains a string $f$ and an integer $s(1 \\le s \\le 10^6)$ — the path and the size of a single file. Each path is at most $100$ characters long and is a valid file path according to the rules above. All paths will be different.\n\nThe following line contains an integer $t(1 \\le t \\le 10^9)$ — the threshold directory size.", "outputFormat": "Output the minimal display of the filesystem hierarchy for the given threshold as described above.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Hidden Hierarchy", "background": "", "description": "假设你正在开发一个简单的以输入文字为基础的文件夹浏览器。你的工作之一就是要构建一个导航目录来显示这些文件夹的上下关系。通常而言，这些文件夹很可能是互相嵌套的——比如，某个文件夹下还有一个文件夹，当然也可能会包含某些文件。因此，这些文件夹会形成一种树状结构。在这个目录中，最顶端的那个文件夹称之为根目录。如果文件夹d中直接含有文件夹e，那么我们称之为文件夹d是文件夹e的父文件夹，而文件夹e是文件夹d的子文件夹。每个文件都有一个用字节数来表示的大小。一个文件夹的大小是被直接或不直接包含于其中的所有文件的大小之和。\n\n所有的文件和文件夹（除根目录外）都有一个名字——一个只由小写字符和点（“.\"）组成并且只由小写字母开头的字符串。包含于同一个父目录下的文件或文件夹的名字必定各不相同。而且，路径与文件是一一对应的。生成路径的规则如下：\n\n- 根目录路径是“/”\n- 文件夹d的路径是从根目录开始，沿着文件夹的父子关系，顺次往下，在每个文件夹名字前添加一个“/”，相互连接，并在路径的最末尾添加一个“/”。\n- 文件f的路径是由它的父文件夹的路径加上文件名得到的。\n\n通过打印根目录，我们能够显示文件夹的上下父子关系。打印文件夹d时，我们输出一个“md pd sd”形式的字符串。其中，pd是文件夹d的路径，sd是文件夹d的大小，md是文件夹d的扩展标记。如果文件夹d包含其他文件夹，我们可以选择是否展开它。如果我们要展开文件夹d，我们就要以字典序打印它里面包含的所有文件和文件夹。如果我们不打开文件夹d，那么我们就可以忽略其中的内容。\n\n如果d是一个空文件夹（即没有包含任何文件或文件夹），那么md就仅仅是一个空字符。当我们要展开这个文件夹的时候，md是一个“-”，而如果我们不展开这个文件夹的是md是一个“+”。\n\n现在，输入一列文件和一个限制性整数t。请你打印（按照前述展开打印方法）所有的大小不小于t的文件夹。并且，打印的文件夹总数一定是最小的。保证不存在空文件夹即整个文件夹上下关系都可从输入的文件路径中推断得出。注意，大小不小于t的文件夹必须要被打印，但不一定要展开。根目录不论多大都要被打印。", "inputFormat": "第一行输入包含一个整数n（1<=n<=1000）表示文件的总数。之后的n行中，每行包含一个字符串f和一个整数s（1<=s<=10^6）。其中，f表示文件路径和单个文件的大小。每个路径最多含有100个字符并保证是一个合法路径。所有的路径保证各不相同。\n\n之后的一行包含限制性整数t（1<=t<=10^9）。", "outputFormat": "按照前述方法输出最少的展开文件的方法。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4747", "type": "P", "difficulty": 6, "samples": [["7\n3 1 7 5 6 4 2\n3\n3 6\n7 7\n1 3\n", "3 6\n7 7 \n1 7"], ["10\n2 1 4 3 5 6 7 10 8 9\n5\n2 3\n3 7\n4 7\n4 8\n7 8\n", "1 4\n3 7\n3 7\n3 10\n7 10\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "ICPC", "CERC"], "title": "[CERC2017] Intrinsic Interval", "background": "", "description": "Given a permutation $\\pi$ of integers $1$ through $n$, an interval in $\\pi$ is a consecutive subsequence consisting of consecutive numbers. More precisely, for indices $a$ and $b$ where $1 \\le a \\le b \\le n$, the subsequence $\\pi^b_a = (\\pi_a, \\pi_{a+1}, . . . ,\\pi_b)$ is an interval if sorting it would yield a sequence of consecutive integers.\n\nFor example, in permutation $\\pi = (3, 1, 7, 5, 6, 4, 2)$, the subsequence $\\pi^6_3$ is an interval (it contains the numbers $4$ through $7$) while $\\pi^3_1$ is not.\n\nFor a subsequence $\\pi^y_x$ its intrinsic interval is any interval $\\pi^b_a$ that contains the given subsequence $(a \\le x \\le y \\le b)$ and that is, additionally, as short as possible. Of course, the length of an interval is defined as the number of elements it contains.\n\nGiven a permutation $\\pi$ and $m$ of its subsequences, find some intrinsic interval for each subsequence.", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 100 000)$ — the size of the permutation $\\pi$. The following line contains $n$ different integers $\\pi_1, \\pi_2, . . . , \\pi_n (1 \\le \\pi_j \\le n)$ — the permutation itself.\n\nThe following line contains an integer $m(1 \\le m \\le 100 000)$ — the number of subsequences. The $j-th$ of the following $m$ lines contains integers $x_j$ and $y_j(1 \\le x_j \\le y_j \\le n)$ — the endpoints of the $j-th$ subsequence.\n", "outputFormat": "Output $m$ lines. The $j-th$ line should contain two integers $a_j$ and $b_j$ where $1 \\le a_j \\le b_j \\le n$ — the endpoints of some intrinsic interval of the $j-th$ subsequence $\\pi^{y_j}_{x_j}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2017] Intrinsic Interval", "background": "", "description": "Given a permutation $\\pi$ of integers $1$ through $n$, an interval in $\\pi$ is a consecutive subsequence consisting of consecutive numbers. More precisely, for indices $a$ and $b$ where $1 \\le a \\le b \\le n$, the subsequence $\\pi^b_a = (\\pi_a, \\pi_{a+1}, . . . ,\\pi_b)$ is an interval if sorting it would yield a sequence of consecutive integers.\n\nFor example, in permutation $\\pi = (3, 1, 7, 5, 6, 4, 2)$, the subsequence $\\pi^6_3$ is an interval (it contains the numbers $4$ through $7$) while $\\pi^3_1$ is not.\n\nFor a subsequence $\\pi^y_x$ its intrinsic interval is any interval $\\pi^b_a$ that contains the given subsequence $(a \\le x \\le y \\le b)$ and that is, additionally, as short as possible. Of course, the length of an interval is defined as the number of elements it contains.\n\nGiven a permutation $\\pi$ and $m$ of its subsequences, find some intrinsic interval for each subsequence.", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 100 000)$ — the size of the permutation $\\pi$. The following line contains $n$ different integers $\\pi_1, \\pi_2, . . . , \\pi_n (1 \\le \\pi_j \\le n)$ — the permutation itself.\n\nThe following line contains an integer $m(1 \\le m \\le 100 000)$ — the number of subsequences. The $j-th$ of the following $m$ lines contains integers $x_j$ and $y_j(1 \\le x_j \\le y_j \\le n)$ — the endpoints of the $j-th$ subsequence.\n", "outputFormat": "Output $m$ lines. The $j-th$ line should contain two integers $a_j$ and $b_j$ where $1 \\le a_j \\le b_j \\le n$ — the endpoints of some intrinsic interval of the $j-th$ subsequence $\\pi^{y_j}_{x_j}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Intrinsic Interval", "background": "", "description": "对于正整数 $1,2,3 \\cdots n$ 的一个排列 $\\pi$，若它的一个子串 $\\pi[a..b]$ 排序后是连续正整数，则称 $\\pi[a..b]$ 是一个“区间”。例如对排列 $pi={3,1,7,5,6,4,2}$，子串 $\\pi[3..6]$ 是一个“区间”（因为它包含 $4,5,6,7$），$\\pi[1..3]$ 则不是。\n\n一个子串的“本征区间”是包含该子串的最短区间。“包含”是指：若 $\\pi[x..y]$ 的本征区间是 $\\pi[a..b]$，则 $a \\le x \\le y \\le b$。\n\n给定一个排列 $\\pi$ 及其 $m$ 个子串，求每个子串的“本征区间”。", "inputFormat": "第一行一个整数 $n(1 \\le n \\le 100000)$。\n\n第二行 $n$ 个整数，代表排列 $\\pi$。\n\n第三行一个整数 $m(1 \\le m \\le 100000)$。\n\n此后 $m$ 行，每行两个整数 $x,y(1 \\le x \\le y \\le n)$，代表子串 $\\pi[x..y]$。", "outputFormat": "输出 $m$ 行，每行两个整数 $a,b(1 \\le a \\le b \\le n)$，代表子串对应的本征区间 $\\pi[a..b]$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4748", "type": "P", "difficulty": 5, "samples": [["8\n1 2\n2 3\n1 4\n4 5\n6 7\n8 3\n7 3", "1 3 7"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "ICPC", "CERC"], "title": "[CERC2017] Justified Jungle", "background": "", "description": "As you probably know, a tree is a graph consisting of $n$ nodes and $n - 1$ undirected edges in which any two nodes are connected by exactly one path. A forest is a graph consisting of one or more trees.\n\nIn other words, a graph is a forest if every connected component is a tree. A forest is justified if all connected components have the same number of nodes.\n\nGiven a tree $G$ consisting of n nodes, find all positive integers $k$ such that a justified forest can be obtained by erasing exactly $k$ edges from $G$. Note that erasing an edge never erases any nodes. In particular when we erase all $n - 1$ edges from $G$, we obtain a justified forest consisting of $n$ one-node components.\n", "inputFormat": "The first line contains an integer $n(2 \\le n \\le 1 000 000)$ — the number of nodes in $G$. The $k-th$ of the following $n - 1$ lines contains two different integers $a_k$ and $b_k(1 \\le a_k, b_k \\le n)$ — the endpoints of the $k-th$ edge.\n", "outputFormat": "The first line should contain all wanted integers $k$, in increasing order.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2017] Justified Jungle", "background": "", "description": "As you probably know, a tree is a graph consisting of $n$ nodes and $n - 1$ undirected edges in which any two nodes are connected by exactly one path. A forest is a graph consisting of one or more trees.\n\nIn other words, a graph is a forest if every connected component is a tree. A forest is justified if all connected components have the same number of nodes.\n\nGiven a tree $G$ consisting of n nodes, find all positive integers $k$ such that a justified forest can be obtained by erasing exactly $k$ edges from $G$. Note that erasing an edge never erases any nodes. In particular when we erase all $n - 1$ edges from $G$, we obtain a justified forest consisting of $n$ one-node components.\n", "inputFormat": "The first line contains an integer $n(2 \\le n \\le 1 000 000)$ — the number of nodes in $G$. The $k-th$ of the following $n - 1$ lines contains two different integers $a_k$ and $b_k(1 \\le a_k, b_k \\le n)$ — the endpoints of the $k-th$ edge.\n", "outputFormat": "The first line should contain all wanted integers $k$, in increasing order.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Justified Jungle", "background": "", "description": "给你一棵包含 $ N $ 个节点的树 $ (N \\leq 10^6) $，求可以通过删除树上的多少条边，使得得到的森林满足其中所有的树都包含相同数量的节点。输出所有合法的删边数量。\r\n\r\n合法的删边数量 $ k $ 指的是存在至少一种方案，删去了恰好 $ k $ 条边，得到的森林满足其中所有的树都包含相同数量的节点。", "inputFormat": "第一行有一个正整数 $ N $ ，表示树的点数。  \r\n接下来 $ N - 1 $ 行，每行两个正整数 $ a , b $ ，表示一条连接点 $ a $ 与点 $ b $ 的无向边。", "outputFormat": "输出一行，包含若干个以空格分隔的正整数，表示所有合法的删边数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4749", "type": "P", "difficulty": 6, "samples": [["6\n9689331\n1758824\n3546327\n5682494\n9128291\n9443696\n", "3\n"], ["7\n5941186\n3871463\n8156346\n9925977\n8836125\n9999999\n5987743\n", "2\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "差分", "ICPC", "CERC"], "title": "[CERC2017] Kitchen Knobs", "background": "", "description": "You are cooking on a gigantic stove at a large fast-food restaurant. The stove contains $n$ heating elements arranged in a line and numbered with integers $1$ through $n$ left to right. Each element is operated by its control knob. The knobs are a bit unusual: each knob is marked with seven non-zero digits evenly distributed around a circle. The power of the heating element is equal to the positive integer obtained by reading the digits on its control knob clockwise starting from the top of the knob.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p2wyrucc.png)\n\nIn a single step, you can rotate one or more consecutive knobs by any number of positions in any direction. However, all knobs rotated in one step need to be rotated by the same number of positions in the same direction.\n\nFind the smallest number of steps needed to set all the heating elements to maximal possible power.", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 501)$ — the number of heating elements. The $j-th$ of the following $n$ lines contains an integer $x_j$ — the initial power of the $j-th$ heating element. Each $x_j$ consists of exactly seven non-zero digits.\n", "outputFormat": "Output a single integer — the minimal number of steps needed.", "hint": "In the first example, one of the ways to achieve maximal possible power is: rotate knobs $2$ through $3$ by $3$ positions in the counterclockwise direction, rotate knob $3$ by $3$ positions in the counterclockwise direction, and rotate knobs $4$ through $6$ by $2$ positions in the clockwise direction.\n", "locale": "en", "translations": {"en": {"title": "[CERC2017] Kitchen Knobs", "background": "", "description": "You are cooking on a gigantic stove at a large fast-food restaurant. The stove contains $n$ heating elements arranged in a line and numbered with integers $1$ through $n$ left to right. Each element is operated by its control knob. The knobs are a bit unusual: each knob is marked with seven non-zero digits evenly distributed around a circle. The power of the heating element is equal to the positive integer obtained by reading the digits on its control knob clockwise starting from the top of the knob.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p2wyrucc.png)\n\nIn a single step, you can rotate one or more consecutive knobs by any number of positions in any direction. However, all knobs rotated in one step need to be rotated by the same number of positions in the same direction.\n\nFind the smallest number of steps needed to set all the heating elements to maximal possible power.", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 501)$ — the number of heating elements. The $j-th$ of the following $n$ lines contains an integer $x_j$ — the initial power of the $j-th$ heating element. Each $x_j$ consists of exactly seven non-zero digits.\n", "outputFormat": "Output a single integer — the minimal number of steps needed.", "hint": "In the first example, one of the ways to achieve maximal possible power is: rotate knobs $2$ through $3$ by $3$ positions in the counterclockwise direction, rotate knob $3$ by $3$ positions in the counterclockwise direction, and rotate knobs $4$ through $6$ by $2$ positions in the clockwise direction.\n", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Kitchen Knobs", "background": "", "description": "你在一家大型快餐店的巨型灶台上烹饪。该灶台包含 $n$ 个加热元件，这些元件排成一行，从左到右用整数 $1$ 到 $n$ 编号。每个元件由一个控制旋钮操作。这些旋钮有些特殊：每个旋钮上标有七个非零数字，这些数字均匀分布在一个圆周上。加热元件的功率等于从其旋钮顶部开始顺时针读取数字所得到的正整数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p2wyrucc.png)\n\n在单步操作中，你可以将**一个或多个连续**的旋钮沿任意方向旋转任意数量的位置。然而，**在同一操作中旋转的所有旋钮必须沿相同方向旋转相同的位数**。\n\n请求出将所有加热元件设置为**最大可能功率**所需的最少步数。", "inputFormat": "第一行包含一个整数 $n(1 \\le n \\le 501)$ —— 表示加热元件的数量。  \n接下来的 $n$ 行中，第 $j$ 行包含一个整数 $x_j$ —— 表示第 $j$ 个加热元件的初始功率。每个 $x_j$ 恰好由七个非零数字组成。\n", "outputFormat": "输出一个整数 —— 表示所需的最少步数。\n", "hint": "在第一个样例中，一种达到最大可能功率的方法是：将旋钮 $2$ 到 $3$ 沿逆时针方向旋转 $3$ 个位置，将旋钮 $3$ 沿逆时针方向旋转 $3$ 个位置，再将旋钮 $4$ 到 $6$ 沿顺时针方向旋转 $2$ 个位置。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P4750", "type": "P", "difficulty": 6, "samples": [["2\nA 0 0 2\nB 1 0 2", "5.00"], ["8\nA -7 10 4\nB 3 10 8\nA -6 6 6\nA -2 5 8\nB 3 -1 8\nB -7 -4 8\nA 3 9 2\nB 8 6 6\n", "205.50"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "ICPC", "CERC"], "title": "[CERC2017] Lunar Landscape", "background": "", "description": "A satellite is surveying a possible rover landing area on the moon. The landing area is modeled as a square grid embedded in the standard coordinate system.\n\nThe satellite has taken $n$ photos, each capturing a square area of the surface. Careful camera calibration has ensured that all photos are aligned with the grid — all four vertices have integer coordinates. Due to the satellite’s changing orbit there are two types of photos:\n   - Photos of type ``A`` have sides that are parallel to coordinate axes. Such a photo is specified by giving the integer coordinates $(x, y)$ of the square’s middle point and the length of its side $a$ — always an even integer.\n   - Photos of type ``B`` have sides at a $45^{\\circ}$ angle to the coordinate axes. Such a photo is specified by giving the integer coordinates $(x, y)$ of the square’s middle point and the length of its diagonal $d$ — always an even integer.\n\nFind the total surface area captured in the satellite photos.\n", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 200 000)$ — the number of photos. The $j-th$ of the following $n$ lines is either of the form “$A \\ x_j \\ y_j  \\ a_j$” or “$B \\ x_j \\ y_j \\ d_j$” representing a photo of type ``A`` or ``B``,respectively.\n\nThe $x_j$ and $y_j$ are the integer coordinates of the middle point of the photo $(-1 000 \\le x_j, y_j \\le 1 000)$. The $a_j$ and $d_j$ are even integers $(2 \\le a_j, d_j \\le 1 000)$ — the side length and the diagonal length, respectively.", "outputFormat": "Output a number with exactly two digits after the decimal point — the total area of the surface. The answer has to exactly correspond to the judge’s solution (no rounding errors are tolerated).", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2017] Lunar Landscape", "background": "", "description": "A satellite is surveying a possible rover landing area on the moon. The landing area is modeled as a square grid embedded in the standard coordinate system.\n\nThe satellite has taken $n$ photos, each capturing a square area of the surface. Careful camera calibration has ensured that all photos are aligned with the grid — all four vertices have integer coordinates. Due to the satellite’s changing orbit there are two types of photos:\n   - Photos of type ``A`` have sides that are parallel to coordinate axes. Such a photo is specified by giving the integer coordinates $(x, y)$ of the square’s middle point and the length of its side $a$ — always an even integer.\n   - Photos of type ``B`` have sides at a $45^{\\circ}$ angle to the coordinate axes. Such a photo is specified by giving the integer coordinates $(x, y)$ of the square’s middle point and the length of its diagonal $d$ — always an even integer.\n\nFind the total surface area captured in the satellite photos.\n", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 200 000)$ — the number of photos. The $j-th$ of the following $n$ lines is either of the form “$A \\ x_j \\ y_j  \\ a_j$” or “$B \\ x_j \\ y_j \\ d_j$” representing a photo of type ``A`` or ``B``,respectively.\n\nThe $x_j$ and $y_j$ are the integer coordinates of the middle point of the photo $(-1 000 \\le x_j, y_j \\le 1 000)$. The $a_j$ and $d_j$ are even integers $(2 \\le a_j, d_j \\le 1 000)$ — the side length and the diagonal length, respectively.", "outputFormat": "Output a number with exactly two digits after the decimal point — the total area of the surface. The answer has to exactly correspond to the judge’s solution (no rounding errors are tolerated).", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Lunar Landscape", "background": null, "description": "一个卫星正在为探测车在月球上寻找一个合适的降落区。降落区被看做在平面直角坐标系中的一个方形区域。\n\n这颗卫星已经照了 $n$ 张照片，每张照片都涵盖了月球表面的一块正方形区域。经过对相机的精细校准，可以保证所有照片涵盖的区域都和坐标对齐——正方形四个角的坐标都为整数。由于卫星的轨道一直在变化，所以照片有两种形式：\n\n- A 类照片的边缘和坐标轴平行。对于这样的照片，题目将会给出它中心的坐标 $(x,y)$ 和它的边长 $a$（$a$ 为偶数）。\n\n- B 类照片的边缘和坐标轴呈 $45\\degree$ 角。对于这样的照片，题目将会给出它中心的坐标 $(x,y)$ 和它对角线的长度 $d$（$d$ 为偶数）。\n\n求出卫星图片拍摄到平面的总大小。", "inputFormat": "第一行有一个整数 $n$ 表示照片的数量。接下来 $n$ 行中第 $j$ 行的格式是 `A xj yj aj` 或 `B xj yj dj`，分别表示这张照片的类型是 A 或 B。\n\n$x_j$ 和 $y_j$ 是这张图片中心的坐标。$a_j$ 和 $d_j$ 为偶数，分别表示正方形的边长和对角线长度。", "outputFormat": "输出平面总的大小，保留两位小数。答案必须和标准答案严格相等（精度问题零容忍↖(^ω^)↗）。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 2 \\cdot 10^5$，$-1 000 \\le x_j, y_j \\le 1 000$，$2 \\le a_j \\le d_j \\le 10^3$，保证所有 $a_j, d_j$ 均为偶数。", "locale": "zh-CN"}}}
{"pid": "P4751", "type": "P", "difficulty": 6, "samples": [["10 10\n-11 80 -99 -76 56 38 92 -51 -34 47\n2 1\n3 1\n4 3\n5 2\n6 2\n7 1\n8 2\n9 4\n10 7\n9 -44\n184 -17\n184 98\n185 -58\n153 48\n190 99\n296 -61\n253 76\n329 14\n264 93\n", "186\n186\n190\n145\n189\n288\n244\n320\n258\n304"]], "limits": {"time": [3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "线段树", "O2优化", "树链剖分", "动态树 LCT", "动态 DP", "全局平衡二叉树", "模板题"], "title": "【模板】动态 DP（加强版）", "background": "树剖常数小！跑不满！\n\nshadowice1984 为了向你证明他能卡树剖并且会卡树剖从而出了这道毒瘤题。\n\n保证答案均在 `int` 范围内。\n\n然后就被离线算法针对了……\n\n因此这道题变成了强制在线。\n", "description": "同 [P4719](https://www.luogu.com.cn/problem/P4719)。\n\n给定一个 $n$ 个点的带点权树，进行 $m$ 次修改点权的操作。\n\n你需要在每次修改之后输出树上最大带权独立集的权值之和。", "inputFormat": "同 [P4719](https://www.luogu.com.cn/problem/P4719)。\n\n第一行两个正整数 $n$，$m$ 表示树的点数和总操作个数\n\n第二行 $n$ 个整数 $V_1,\\dots,V_n$ 表示每个点的点权。\n\n接下来 $(n - 1)$ 行，每行两个整数 $u, v$，表示存在一条连接 $u$ 与 $v$ 的边。\n\n接下来 $m$ 行每行两个整数 $x$，$y$ 表示将 $x$ 的点权修改为 $y$。\n\n对于第 $1$ 行，$x$ 即为被操作的点的编号。\n\n对于第 $2$ 到 $m$ 行，被操作的点的编号 $=x\\oplus lastans$。\n\n其中 $lastans$ 是上一次操作后输出的答案，$\\oplus$ 表示按位异或操作。", "outputFormat": "输出 $m$ 行，第 $i$ 行表示表示第 $i$ 次操作之后树上最大带权独立集的权值和。", "hint": "数据范围 $n \\leq 1 \\times 10^6$，$m \\leq 3 \\times 10^6$。保证任意时刻各点点权的绝对值 $\\leq 100$。\n\n时限为标程的二倍，如果卡常数的话请使用 `int` 类型。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Dynamic DP (Enhanced Version)", "background": "Tree decomposition has small constants! It cannot reach full performance!\n\nshadowice1984 made this nasty problem to prove to you that he can hack tree decomposition and knows how to do it.\n\nIt is guaranteed that all answers fit in the `int` range.\n\nThen it got targeted by offline algorithms...\n\nSo this problem becomes forced online.", "description": "Same as [P4719](https://www.luogu.com.cn/problem/P4719).\n\nGiven a tree with $n$ nodes and node weights, perform $m$ operations that modify node weights.\n\nAfter each modification, you need to output the maximum total weight of a maximum weight independent set on the tree.", "inputFormat": "Same as [P4719](https://www.luogu.com.cn/problem/P4719).\n\nThe first line contains two positive integers $n$, $m$, representing the number of nodes in the tree and the total number of operations.\n\nThe second line contains $n$ integers $V_1,\\dots,V_n$, representing the weight of each node.\n\nThe next $(n - 1)$ lines each contain two integers $u, v$, indicating that there is an edge connecting $u$ and $v$.\n\nThe next $m$ lines each contain two integers $x$, $y$, indicating that the weight of node $x$ is modified to $y$.\n\nFor the 1st operation, $x$ is the index of the modified node.\n\nFor the 2nd to the $m$-th operations, the index of the modified node is $x\\oplus lastans$.\n\nHere, $lastans$ is the answer output after the previous operation, and $\\oplus$ denotes the bitwise XOR operation.", "outputFormat": "Output $m$ lines. The $i$-th line is the total weight of the maximum weight independent set on the tree after the $i$-th operation.", "hint": "Constraints: $n \\leq 1 \\times 10^6$, $m \\leq 3 \\times 10^6$. It is guaranteed that at any time, the absolute value of each node weight is $\\leq 100$.\n\nThe time limit is twice that of the reference solution. If you need to optimize constants, please use the `int` type.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】动态 DP（加强版）", "background": "树剖常数小！跑不满！\n\nshadowice1984 为了向你证明他能卡树剖并且会卡树剖从而出了这道毒瘤题。\n\n保证答案均在 `int` 范围内。\n\n然后就被离线算法针对了……\n\n因此这道题变成了强制在线。\n", "description": "同 [P4719](https://www.luogu.com.cn/problem/P4719)。\n\n给定一个 $n$ 个点的带点权树，进行 $m$ 次修改点权的操作。\n\n你需要在每次修改之后输出树上最大带权独立集的权值之和。", "inputFormat": "同 [P4719](https://www.luogu.com.cn/problem/P4719)。\n\n第一行两个正整数 $n$，$m$ 表示树的点数和总操作个数\n\n第二行 $n$ 个整数 $V_1,\\dots,V_n$ 表示每个点的点权。\n\n接下来 $(n - 1)$ 行，每行两个整数 $u, v$，表示存在一条连接 $u$ 与 $v$ 的边。\n\n接下来 $m$ 行每行两个整数 $x$，$y$ 表示将 $x$ 的点权修改为 $y$。\n\n对于第 $1$ 行，$x$ 即为被操作的点的编号。\n\n对于第 $2$ 到 $m$ 行，被操作的点的编号 $=x\\oplus lastans$。\n\n其中 $lastans$ 是上一次操作后输出的答案，$\\oplus$ 表示按位异或操作。", "outputFormat": "输出 $m$ 行，第 $i$ 行表示表示第 $i$ 次操作之后树上最大带权独立集的权值和。", "hint": "数据范围 $n \\leq 1 \\times 10^6$，$m \\leq 3 \\times 10^6$。保证任意时刻各点点权的绝对值 $\\leq 100$。\n\n时限为标程的二倍，如果卡常数的话请使用 `int` 类型。", "locale": "zh-CN"}}}
{"pid": "P4752", "type": "P", "difficulty": 4, "samples": [["2\n3 2\n5 7 7\n5 7\n4 2\n5 7 7 7\n5 7", "YES\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化", "排序", "素数判断,质数,筛法", "洛谷月赛"], "title": "Divided Prime", "background": null, "description": "给定一个数字 $A$，这个 $A$ 由 $a_1,a_2,\\cdots,a_N$ 相乘得到。\n\n给定一个数字 $B$，这个 $B$ 由 $b_1,b_2,\\cdots,b_M$ 相乘得到。\n\n如果 $\\frac{A}{B}$ 是一个质数，请输出 `YES`，否则输出 `NO`。", "inputFormat": "每个测试点包含多组数据，第一行读入一个整数 $T$ 表示数据组数，对于每组数据：\n\n第一行输入两个整数 $N,M$，分别表示 $A$ 由 $N$ 个数字相乘得到，$B$ 由 $M$ 个数字相乘得到。\n\n第二行输入 $N$ 个整数，分别表示组成 $A$ 的 $N$ 个数字。\n\n第三行输入 $M$ 个整数，分别表示组成 $B$ 的 $M$ 个数字。\n\n保证对于一个数字，其在 ${b_i}$ 中出现的次数不多于在 ${a_i}$ 中出现的次数。", "outputFormat": "对于每组数据：\n如果 $\\frac{A}{B}$ 是一个质数，请输出 `YES`，否则输出 `NO`。\n在输出 `YES` 或 `NO` 后输出一个换行符。", "hint": "对于所有数据，有 $1 \\le N \\le 10^5, 0 \\le M \\le N, 1 \\le a_i,b_i \\le 10^{12}, 1 \\le T \\le 10, \\sum N \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Divided Prime", "background": "", "description": "Given a number $A$, where $A$ is obtained by multiplying $a_1, a_2, \\cdots, a_N$.\n\nGiven a number $B$, where $B$ is obtained by multiplying $b_1, b_2, \\cdots, b_M$.\n\nIf $\\frac{A}{B}$ is a prime number, output `YES`; otherwise, output `NO`.", "inputFormat": "Each test point contains multiple test cases. The first line contains an integer $T$, which denotes the number of test cases. For each test case:\n\nThe first line contains two integers $N, M$, indicating that $A$ is obtained by multiplying $N$ numbers, and $B$ is obtained by multiplying $M$ numbers.\n\nThe second line contains $N$ integers, which are the $N$ numbers that make up $A$.\n\nThe third line contains $M$ integers, which are the $M$ numbers that make up $B$.\n\nIt is guaranteed that, for any number, the number of times it appears in ${b_i}$ is no more than the number of times it appears in ${a_i}$.", "outputFormat": "For each test case:\n\nIf $\\frac{A}{B}$ is a prime number, output `YES`; otherwise, output `NO`.\n\nAfter outputting `YES` or `NO`, output a newline character.", "hint": "For all testdata, $1 \\le N \\le 10^5$, $0 \\le M \\le N$, $1 \\le a_i, b_i \\le 10^{12}$, $1 \\le T \\le 10$, and $\\sum N \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Divided Prime", "background": null, "description": "给定一个数字 $A$，这个 $A$ 由 $a_1,a_2,\\cdots,a_N$ 相乘得到。\n\n给定一个数字 $B$，这个 $B$ 由 $b_1,b_2,\\cdots,b_M$ 相乘得到。\n\n如果 $\\frac{A}{B}$ 是一个质数，请输出 `YES`，否则输出 `NO`。", "inputFormat": "每个测试点包含多组数据，第一行读入一个整数 $T$ 表示数据组数，对于每组数据：\n\n第一行输入两个整数 $N,M$，分别表示 $A$ 由 $N$ 个数字相乘得到，$B$ 由 $M$ 个数字相乘得到。\n\n第二行输入 $N$ 个整数，分别表示组成 $A$ 的 $N$ 个数字。\n\n第三行输入 $M$ 个整数，分别表示组成 $B$ 的 $M$ 个数字。\n\n保证对于一个数字，其在 ${b_i}$ 中出现的次数不多于在 ${a_i}$ 中出现的次数。", "outputFormat": "对于每组数据：\n如果 $\\frac{A}{B}$ 是一个质数，请输出 `YES`，否则输出 `NO`。\n在输出 `YES` 或 `NO` 后输出一个换行符。", "hint": "对于所有数据，有 $1 \\le N \\le 10^5, 0 \\le M \\le N, 1 \\le a_i,b_i \\le 10^{12}, 1 \\le T \\le 10, \\sum N \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4753", "type": "P", "difficulty": 5, "samples": [["6 1 3\n3", "YES\n1 2 0"], ["6 2 2\n2 4", "YES\n2 3 1 0"], ["5 2 3\n2 3", "NO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "贪心", "Special Judge", "O2优化", "洛谷月赛"], "title": "River Jumping", "background": "", "description": "有一条宽度为 $N$ 的河上，小 D 位于坐标为 $0$ 的河岸上，他想到达坐标为 $N$ 的河岸上后再回到坐标为 $0$ 的位置。在到达坐标为 $N$ 的河岸之前小 D 只能向坐标更大的位置跳跃，在到达坐标为 $N$ 的河岸之后小 D 只能向坐标更小的位置跳跃。在河的中间有 $M$ 个岩石，小 D 希望能跳到每个岩石上恰好一次。由于小 D 的跳跃能力太强，小 D 的跳跃长度有个下限 $S$，但没有上限。现在请你判断他是否能够完成他的目标。", "inputFormat": "第一行输入两个整数 $N,M,S$，分别表示河的宽度，岩石的数量和跳跃长度的下限。\n\n第二行输入 $M$ 个整数，分别表示 $M$ 个岩石的坐标 $w_1,w_2,\\cdots,w_N$。保证 $\\{w_i\\}$ 为递增序列。", "outputFormat": "如果小D可以完成他的目标，第一行输出 `YES`，第二行输出 $M+2$ 个数，依次表示小D跳到的石头编号。特殊的，坐标为 $0$ 的河岸编号为 $0$，坐标为$N$的河岸标号为 $M+1$ 。如果有多种解法，允许输出任意一种。\n\n如果小 D 不能完成他的目标，第一行输出 `NO`。", "hint": "对于全部数据，保证 $1 \\le N,S \\le 100000$，$0 \\le M < N$，$1 \\le w_i < N$。", "locale": "zh-CN", "translations": {"en": {"title": "River Jumping", "background": "", "description": "There is a river of width $N$. Little D is on the bank at coordinate $0$. He wants to reach the bank at coordinate $N$ and then return to coordinate $0$. Before reaching the bank at coordinate $N$, Little D can only jump to positions with larger coordinates. After reaching the bank at coordinate $N$, Little D can only jump to positions with smaller coordinates. There are $M$ rocks in the river. Little D hopes to land on each rock exactly once. Because Little D can jump very far, his jump length has a lower bound $S$ but no upper bound. Now determine whether he can achieve his goal.", "inputFormat": "The first line contains three integers $N, M, S$, representing the width of the river, the number of rocks, and the lower bound of the jump length.\n\nThe second line contains $M$ integers, representing the coordinates of the $M$ rocks: $w_1, w_2, \\cdots, w_N$. It is guaranteed that $\\{w_i\\}$ is a strictly increasing sequence.", "outputFormat": "If Little D can achieve his goal, output `YES` on the first line, and output $M + 2$ numbers on the second line, in order, representing the indices of the stones that Little D lands on. In particular, the bank at coordinate $0$ has index $0$, and the bank at coordinate $N$ has index $M + 1$. If there are multiple solutions, you may output any one of them.\n\nIf Little D cannot achieve his goal, output `NO` on the first line.", "hint": "For all testdata, it is guaranteed that $1 \\le N, S \\le 100000$, $0 \\le M < N$, and $1 \\le w_i < N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "River Jumping", "background": "", "description": "有一条宽度为 $N$ 的河上，小 D 位于坐标为 $0$ 的河岸上，他想到达坐标为 $N$ 的河岸上后再回到坐标为 $0$ 的位置。在到达坐标为 $N$ 的河岸之前小 D 只能向坐标更大的位置跳跃，在到达坐标为 $N$ 的河岸之后小 D 只能向坐标更小的位置跳跃。在河的中间有 $M$ 个岩石，小 D 希望能跳到每个岩石上恰好一次。由于小 D 的跳跃能力太强，小 D 的跳跃长度有个下限 $S$，但没有上限。现在请你判断他是否能够完成他的目标。", "inputFormat": "第一行输入两个整数 $N,M,S$，分别表示河的宽度，岩石的数量和跳跃长度的下限。\n\n第二行输入 $M$ 个整数，分别表示 $M$ 个岩石的坐标 $w_1,w_2,\\cdots,w_N$。保证 $\\{w_i\\}$ 为递增序列。", "outputFormat": "如果小D可以完成他的目标，第一行输出 `YES`，第二行输出 $M+2$ 个数，依次表示小D跳到的石头编号。特殊的，坐标为 $0$ 的河岸编号为 $0$，坐标为$N$的河岸标号为 $M+1$ 。如果有多种解法，允许输出任意一种。\n\n如果小 D 不能完成他的目标，第一行输出 `NO`。", "hint": "对于全部数据，保证 $1 \\le N,S \\le 100000$，$0 \\le M < N$，$1 \\le w_i < N$。", "locale": "zh-CN"}}}
{"pid": "P4754", "type": "P", "difficulty": 5, "samples": [["6 1 3 2\n0 0 0 0 0 0\n1 2\n2 1 1", "3"], ["6 1 3 2\n1 0 0 0 0 0\n1 2\n2 1 1", "2"], ["6 1 6 2\n0 0 0 0 0 0\n1 2\n2 1 1", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "O2优化", "洛谷月赛"], "title": "True Vegetable", "background": "", "description": "小A现在有$N$道题，编号为$1,2,\\cdots,N$。每道题的起始毒瘤程度为$0$或$1$。在每回合，小A可以将编号连续的$K$道题的毒瘤程度+1。但小B因为本身比较菜，不是很愿意小A出毒瘤题，所以在$w_i$回合开始时可以向第$x_i$题传播$v_i$点的菜气，使得第$x_i$的毒瘤程度减少$v_i$点（减后可以为负）。这里我们假定菜是有限的，在释放了$v_i$点的菜气后，小B需要至少$r_{v_i}$个回合不能释放菜气。现在小A知道了小B释放菜气的计划，他想知道他至少需要多少个回合可以使得每道题的毒瘤程度至少为$1$。", "inputFormat": "第一行输入四个整数，$N,M,K,L$，分别为题目的数量，小B的操作数量，每次连续增加毒瘤程度题目的数量和释放菜气的最大值。\n\n第二行输入$N$个整数$a_1,a_2,\\cdots,a_N$，分别为$N$个题目的毒瘤程度。\n\n第三行输入$L$个整数$r_1,r_2,\\cdots,r_L$，分别为释放$1$到$L$点菜气的冷却回合数。\n\n接下来有$M$行，每行输入三个整数$w_i,x_i,v_i$，表示小B在第$w_i$回合开始时向第$x_i$题释放了$v_i$点的菜气。保证$\\{w_i\\}$为递增序列。", "outputFormat": "请输出小A将每道题的毒瘤程度加到至少为$1$最少需要的回合数。", "hint": "$1 \\le N,M \\le 5 \\times 10^5$\n\n$1 \\le K \\le N$\n\n$1 \\le L \\le 100$\n\n$a[i] \\in \\{0,1\\}$\n\n$1 = r_1 < r_2 < \\cdots < r_L \\le 2 \\times L$\n\n$1 \\le w_i \\le N+L$\n\n$w_i+r_{v_i} \\le w_{i+1}$\n\n$1 \\le x_i \\le N$\n\n$1 \\le v_i \\le L$", "locale": "zh-CN", "translations": {"en": {"title": "True Vegetable", "background": "", "description": "Little A now has $N$ problems, numbered $1,2,\\cdots,N$. The initial “toxicity level” of each problem is $0$ or $1$. In each round, Little A can increase the toxicity level of $K$ problems with consecutive indices by $1$.\n\nHowever, Little B is not very strong and does not really want Little A to create toxic problems. At the start of round $w_i$, Little B can spread $v_i$ points of “noob gas” to problem $x_i$, which decreases the toxicity level of problem $x_i$ by $v_i$ points (it may become negative after decreasing). We assume the amount of “noob gas” is limited: after releasing $v_i$ points of noob gas, Little B must wait at least $r_{v_i}$ rounds before being able to release noob gas again.\n\nNow Little A knows Little B’s plan for releasing noob gas, and he wants to know the minimum number of rounds needed to make the toxicity level of every problem at least $1$.", "inputFormat": "The first line contains four integers $N,M,K,L$, representing the number of problems, the number of Little B’s operations, the number of consecutive problems increased each time, and the maximum value of noob gas that can be released.\n\nThe second line contains $N$ integers $a_1,a_2,\\cdots,a_N$, representing the toxicity levels of the $N$ problems.\n\nThe third line contains $L$ integers $r_1,r_2,\\cdots,r_L$, representing the cooldown rounds for releasing $1$ to $L$ points of noob gas.\n\nThe next $M$ lines each contain three integers $w_i,x_i,v_i$, meaning that at the start of round $w_i$, Little B releases $v_i$ points of noob gas to problem $x_i$. It is guaranteed that $\\{w_i\\}$ is a strictly increasing sequence.", "outputFormat": "Output the minimum number of rounds Little A needs to make the toxicity level of every problem at least $1$.", "hint": "Constraints\n\n$1 \\le N,M \\le 5 \\times 10^5$.\n\n$1 \\le K \\le N$.\n\n$1 \\le L \\le 100$.\n\n$a[i] \\in \\{0,1\\}$.\n\n$1 = r_1 < r_2 < \\cdots < r_L \\le 2 \\times L$.\n\n$1 \\le w_i \\le N+L$.\n\n$w_i+r_{v_i} \\le w_{i+1}$.\n\n$1 \\le x_i \\le N$.\n\n$1 \\le v_i \\le L$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "True Vegetable", "background": "", "description": "小A现在有$N$道题，编号为$1,2,\\cdots,N$。每道题的起始毒瘤程度为$0$或$1$。在每回合，小A可以将编号连续的$K$道题的毒瘤程度+1。但小B因为本身比较菜，不是很愿意小A出毒瘤题，所以在$w_i$回合开始时可以向第$x_i$题传播$v_i$点的菜气，使得第$x_i$的毒瘤程度减少$v_i$点（减后可以为负）。这里我们假定菜是有限的，在释放了$v_i$点的菜气后，小B需要至少$r_{v_i}$个回合不能释放菜气。现在小A知道了小B释放菜气的计划，他想知道他至少需要多少个回合可以使得每道题的毒瘤程度至少为$1$。", "inputFormat": "第一行输入四个整数，$N,M,K,L$，分别为题目的数量，小B的操作数量，每次连续增加毒瘤程度题目的数量和释放菜气的最大值。\n\n第二行输入$N$个整数$a_1,a_2,\\cdots,a_N$，分别为$N$个题目的毒瘤程度。\n\n第三行输入$L$个整数$r_1,r_2,\\cdots,r_L$，分别为释放$1$到$L$点菜气的冷却回合数。\n\n接下来有$M$行，每行输入三个整数$w_i,x_i,v_i$，表示小B在第$w_i$回合开始时向第$x_i$题释放了$v_i$点的菜气。保证$\\{w_i\\}$为递增序列。", "outputFormat": "请输出小A将每道题的毒瘤程度加到至少为$1$最少需要的回合数。", "hint": "$1 \\le N,M \\le 5 \\times 10^5$\n\n$1 \\le K \\le N$\n\n$1 \\le L \\le 100$\n\n$a[i] \\in \\{0,1\\}$\n\n$1 = r_1 < r_2 < \\cdots < r_L \\le 2 \\times L$\n\n$1 \\le w_i \\le N+L$\n\n$w_i+r_{v_i} \\le w_{i+1}$\n\n$1 \\le x_i \\le N$\n\n$1 \\le v_i \\le L$", "locale": "zh-CN"}}}
{"pid": "P4755", "type": "P", "difficulty": 6, "samples": [["4\n1 3 9 3\n", "5\n"], ["5\n1 1 2 1 1\n", "14\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化", "枚举", "分治", "可持久化线段树", "洛谷月赛", "笛卡尔树", "启发式合并"], "title": "Beautiful Pair", "background": "", "description": "小 D 有个数列 $\\{a\\}$，当一个数对 $(i,j)$（$i \\le j$）满足 $a_i$ 和 $a_j$ 的积不大于 $a_i, a_{i+1}, \\ldots, a_j$ 中的最大值时，小 D 认为这个数对是美丽的。请你求出美丽的数对的数量。", "inputFormat": "第一行输入一个整数 $n$，表示元素个数。\n第二行输入 $n$ 个整数 $a_1,a_2,a_3,\\ldots,a_n$，为所给的数列。\n", "outputFormat": "输出一个整数，为美丽的数字对数。", "hint": "**【样例解释 #1】**\n\n五种可行的数对为 $(1,1), (1,2), (1,3), (1,4), (2,4)$。\n\n**【样例解释 #2】**\n\n只有数对 $(3,3)$ 不可行。\n\n**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1\\le n\\le{10}^5$，$1\\le a_i\\le{10}^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Beautiful Pair", "background": "", "description": "Xiao D has a sequence $\\{a\\}$. For a pair $(i, j)$ ($i \\le j$), if the product of $a_i$ and $a_j$ is not greater than the maximum value among $a_i, a_{i+1}, \\ldots, a_j$, then Xiao D considers this pair to be beautiful. Please find the number of beautiful pairs.", "inputFormat": "The first line contains an integer $n$, representing the number of elements.  \nThe second line contains $n$ integers $a_1, a_2, a_3, \\ldots, a_n$, representing the given sequence.", "outputFormat": "Output one integer, the number of beautiful pairs.", "hint": "**[Sample Explanation #1]**\n\nThe five valid pairs are $(1,1), (1,2), (1,3), (1,4), (2,4)$.\n\n**[Sample Explanation #2]**\n\nOnly the pair $(3,3)$ is invalid.\n\n**[Constraints]**\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^5$, and $1 \\le a_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Beautiful Pair", "background": "", "description": "小 D 有个数列 $\\{a\\}$，当一个数对 $(i,j)$（$i \\le j$）满足 $a_i$ 和 $a_j$ 的积不大于 $a_i, a_{i+1}, \\ldots, a_j$ 中的最大值时，小 D 认为这个数对是美丽的。请你求出美丽的数对的数量。", "inputFormat": "第一行输入一个整数 $n$，表示元素个数。\n第二行输入 $n$ 个整数 $a_1,a_2,a_3,\\ldots,a_n$，为所给的数列。\n", "outputFormat": "输出一个整数，为美丽的数字对数。", "hint": "**【样例解释 #1】**\n\n五种可行的数对为 $(1,1), (1,2), (1,3), (1,4), (2,4)$。\n\n**【样例解释 #2】**\n\n只有数对 $(3,3)$ 不可行。\n\n**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1\\le n\\le{10}^5$，$1\\le a_i\\le{10}^9$。", "locale": "zh-CN"}}}
{"pid": "P4756", "type": "P", "difficulty": 6, "samples": [["4 4\n4 5 6 7\n1\n15\n0\n12", "6\n6\n14\n26\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化", "前缀和", "凸包", "洛谷月赛"], "title": "Added Sequence", "background": "", "description": "小$L$发明了一种新的数据结构，并将其命名为$L$数组。$L$数组的作用是可以在$O(1)$时间内将整个数组加上或减去一个数。现在给你一个长度为$N$的数组$a$，他想用$L$数组来挑战你的计算能力。\n\n定义$f(i,j)=|\\sum_{p=i}^{j} a_p|$其中$|x|$表示$x$的绝对值。\n\n定义一个数组的美丽度为$\\max_{1 \\le i \\le j \\le N} f(i,j)$，每当他将整个数组加上$x$ ，请你回答此时的美丽度。\n\n注意，你的算法必须为在线的。", "inputFormat": "第一行输入两个整数$N,M$，分别表示数组长度和询问数量。\n\n第二行输入$N$个整数，表示起始的数组$a$。\n\n接下来$M$行，每行一个整数$x_i$，设前面一次回答的答案为$pre$，那么表示第$i$次询问时在起始数组的基础上整个数组加上$[(x_i+pre)\\%(4n+1)-2n]$。其中$\\%$表示求余运算，第一次回答时$pre=0$。", "outputFormat": "输出$M$行，第$i$行为在起始数组的基础上整个数组加上$x_i$时的美丽度。", "hint": "四次加上的数字分别为-7，-4，-2，1。\n\n$1 \\le N,M \\le 200000$\n\n$|a_i| \\le 200000$\n\n$0 \\le x_i \\le 800000$", "locale": "zh-CN", "translations": {"en": {"title": "Added Sequence", "background": "　　", "description": "Xiao $L$ invented a new data structure and named it the $L$ array. An $L$ array can add or subtract a number to the entire array in $O(1)$ time. Now you are given an array $a$ of length $N$. He wants to use the $L$ array to challenge your computing ability.\n\nDefine $f(i,j)=|\\sum_{p=i}^{j} a_p|$, where $|x|$ denotes the absolute value of $x$.\n\nDefine the beauty of an array as $\\max_{1 \\le i \\le j \\le N} f(i,j)$. Each time he adds $x$ to the entire array, you need to answer the beauty at that moment.\n\nNote that your algorithm must be online.", "inputFormat": "The first line contains two integers $N,M$, representing the array length and the number of queries.\n\nThe second line contains $N$ integers, representing the initial array $a$.\n\nThe next $M$ lines each contain one integer $x_i$. Let the previous answer be $pre$. Then for the $i$-th query, it means adding $[(x_i+pre)\\%(4n+1)-2n]$ to the entire array based on the initial array. Here $\\%$ denotes the modulo operation. For the first answer, $pre=0$.", "outputFormat": "Output $M$ lines. The $i$-th line is the beauty of the array after adding $x_i$ to the entire array based on the initial array.", "hint": "The four added numbers are $-7$, $-4$, $-2$, and $1$.\n\nConstraints:\n\n$1 \\le N,M \\le 200000$.\n\n$|a_i| \\le 200000$.\n\n$0 \\le x_i \\le 800000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Added Sequence", "background": "", "description": "小$L$发明了一种新的数据结构，并将其命名为$L$数组。$L$数组的作用是可以在$O(1)$时间内将整个数组加上或减去一个数。现在给你一个长度为$N$的数组$a$，他想用$L$数组来挑战你的计算能力。\n\n定义$f(i,j)=|\\sum_{p=i}^{j} a_p|$其中$|x|$表示$x$的绝对值。\n\n定义一个数组的美丽度为$\\max_{1 \\le i \\le j \\le N} f(i,j)$，每当他将整个数组加上$x$ ，请你回答此时的美丽度。\n\n注意，你的算法必须为在线的。", "inputFormat": "第一行输入两个整数$N,M$，分别表示数组长度和询问数量。\n\n第二行输入$N$个整数，表示起始的数组$a$。\n\n接下来$M$行，每行一个整数$x_i$，设前面一次回答的答案为$pre$，那么表示第$i$次询问时在起始数组的基础上整个数组加上$[(x_i+pre)\\%(4n+1)-2n]$。其中$\\%$表示求余运算，第一次回答时$pre=0$。", "outputFormat": "输出$M$行，第$i$行为在起始数组的基础上整个数组加上$x_i$时的美丽度。", "hint": "四次加上的数字分别为-7，-4，-2，1。\n\n$1 \\le N,M \\le 200000$\n\n$|a_i| \\le 200000$\n\n$0 \\le x_i \\le 800000$", "locale": "zh-CN"}}}
{"pid": "P4757", "type": "P", "difficulty": 6, "samples": [["1\n6\n1 2\n2 3\n3 4\n3 5\n3 6\n4\n1 3\n4 5\n5 6\n6 4", "2"]], "limits": {"time": [1500, 1500], "memory": [128000, 128000]}, "tags": ["2014", "ICPC", "CERC"], "title": "[CERC2014] Parades", "background": "", "description": "In The City of Eternal Festivities, there are $n$ street junctions and $n-1$ bidirectional streets,each street connecting two of the junctions. Between every two junctions, there is exactly one (direct or indirect) path connecting them. No junction is an endpoint for more than 10 streets.\n\nEvery 13th of September (the 256th day of the year), there are many festivities going on in The City. In particular, the citizens want to organize $m$ parades. The parade number $i$ starts at junction $u_i$ and ends at $v_i$, following the unique path between the endpoints.\n\nAs the mayor of The City, you are responsible for citizens’ safety. Therefore you decreed that no two parades are ever allowed to use the same street, though they can have common junctions,or even common endpoints.\n\nTo appease your citizens, try to organize as many parades as possible, without breaking the safety regulations.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe first line of each test case contains a single integer: the number of junctions $n(2 \\le n \\le 1000)$. Each of the next $n - 1$ lines contains two integers $a, b(1 \\le a ≠ b \\le n)$, denoting that junctions $a$ and $b$ are connected by a street. Each junction has at most $10$ streets leaving it.\n\nThe next line contains a single integer: the number of planned parades $m, 0 \\le m \\le (_2^n)$.\n\nEach of the next $m$ lines contains two integers $u_i, v_i (1 \\le u_i ≠ v_i \\le n)$,meaning that a parade is planned to start at junction $u_i$, and finish at junction $v_i$. No two parades share both endpoints.", "outputFormat": "For each test case, output one line containing the largest number of parades that can be organized with no street used by more than one parade.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Parades", "background": "", "description": "In The City of Eternal Festivities, there are $n$ street junctions and $n-1$ bidirectional streets,each street connecting two of the junctions. Between every two junctions, there is exactly one (direct or indirect) path connecting them. No junction is an endpoint for more than 10 streets.\n\nEvery 13th of September (the 256th day of the year), there are many festivities going on in The City. In particular, the citizens want to organize $m$ parades. The parade number $i$ starts at junction $u_i$ and ends at $v_i$, following the unique path between the endpoints.\n\nAs the mayor of The City, you are responsible for citizens’ safety. Therefore you decreed that no two parades are ever allowed to use the same street, though they can have common junctions,or even common endpoints.\n\nTo appease your citizens, try to organize as many parades as possible, without breaking the safety regulations.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe first line of each test case contains a single integer: the number of junctions $n(2 \\le n \\le 1000)$. Each of the next $n - 1$ lines contains two integers $a, b(1 \\le a ≠ b \\le n)$, denoting that junctions $a$ and $b$ are connected by a street. Each junction has at most $10$ streets leaving it.\n\nThe next line contains a single integer: the number of planned parades $m, 0 \\le m \\le (_2^n)$.\n\nEach of the next $m$ lines contains two integers $u_i, v_i (1 \\le u_i ≠ v_i \\le n)$,meaning that a parade is planned to start at junction $u_i$, and finish at junction $v_i$. No two parades share both endpoints.", "outputFormat": "For each test case, output one line containing the largest number of parades that can be organized with no street used by more than one parade.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Parades", "background": "", "description": "在永恒节日之城，有 $n$ 个街道交叉口和 $n-1$ 条双向街道，每条街道连接两个交叉口。每两个交叉口之间，恰好有一条（直接或间接）路径连接它们。没有交叉口是超过 10 条街道的端点。\n\n每年 9 月 13 日（即一年中的第 256 天），永恒节日之城会举行许多庆祝活动。特别是，市民们想要组织 $m$ 场游行。第 $i$ 场游行从交叉口 $u_i$ 开始，到交叉口 $v_i$ 结束，沿着端点之间的唯一路径进行。\n\n作为城市的市长，你负责市民的安全。因此，你规定任何两场游行都不允许使用相同的街道，尽管它们可以有共同的交叉口，甚至是共同的端点。\n\n为了安抚市民，尽量组织尽可能多的游行，同时不违反安全规定。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来的每个测试用例描述如下：\n\n每个测试用例的第一行包含一个整数：交叉口的数量 $n(2 \\le n \\le 1000)$。接下来的 $n - 1$ 行中的每一行包含两个整数 $a, b(1 \\le a \neq b \\le n)$，表示交叉口 $a$ 和 $b$ 由一条街道连接。每个交叉口最多有 10 条街道离开。\n\n下一行包含一个整数：计划的游行数量 $m, 0 \\le m \\le \\binom{n}{2}$。\n\n接下来的 $m$ 行中的每一行包含两个整数 $u_i, v_i (1 \\le u_i \neq v_i \\le n)$，表示计划从交叉口 $u_i$ 开始，并在交叉口 $v_i$ 结束的游行。没有两场游行共享两个端点。", "outputFormat": "对于每个测试用例，输出一行，包含在不超过一条街道被多场游行使用的情况下可以组织的最大游行数量。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4758", "type": "P", "difficulty": 6, "samples": [["2\n8\n0 0\n3 7\n6 2\n9 4\n11 2\n13 3\n17 13\n20 7\n7\n0 2\n1 2\n3 1\n4 0\n5 2\n6 1\n7 3", "0 3 6 5 6 0 0\n6 4 4 0 6 0"]], "limits": {"time": [5000, 5000, 5000, 5000], "memory": [128000, 128000, 128000, 128000]}, "tags": ["2014", "ICPC", "CERC"], "title": "[CERC2014] Mountainous landscape", "background": "", "description": "You travel through a scenic landscape consisting mostly of mountains – there are $n$ landmarks (peaks and valleys) on your path. You pause for breath and wonder: which mountain are you currently seeing on the horizon?\n\n![0](https://cdn.luogu.com.cn/upload/pic/23379.png)\n\nFormally: you are given a polygonal chain $P_1,P_2,\\cdots,P_n$ in the plane. The $x$ coordinates of the points are in strictly increasing order. For each segment $P_i P_{i+1}$ of this chain, find the smallest index $j > i$, for which any point of $P_j P_{j+1}$ is visible from $P_i P_{i+1}$ (lies **strictly above** the ray $P_i \\ P^{\\rightarrow}_{i+1}$).\n\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe first line of each test case contains an integer $n(2 \\le n \\le 100 000)$ – the number of vertices on the chain.\n\nEach of the following $n$ lines contains integer coordinates $x_i, y_i$ of the vertex $P_i (0 \\le x_1 < x_2 < \\cdots < x_n \\le 10^9, 0 \\le y_i \\le 10^9)$.\n", "outputFormat": "For each test case, output a single line containing $n-1$ space-separated integers. These should be the smallest indices of chain segments visible to the right, or $0$ when no such segment exists.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Mountainous landscape", "background": "", "description": "You travel through a scenic landscape consisting mostly of mountains – there are $n$ landmarks (peaks and valleys) on your path. You pause for breath and wonder: which mountain are you currently seeing on the horizon?\n\n![0](https://cdn.luogu.com.cn/upload/pic/23379.png)\n\nFormally: you are given a polygonal chain $P_1,P_2,\\cdots,P_n$ in the plane. The $x$ coordinates of the points are in strictly increasing order. For each segment $P_i P_{i+1}$ of this chain, find the smallest index $j > i$, for which any point of $P_j P_{j+1}$ is visible from $P_i P_{i+1}$ (lies **strictly above** the ray $P_i \\ P^{\\rightarrow}_{i+1}$).\n\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe first line of each test case contains an integer $n(2 \\le n \\le 100 000)$ – the number of vertices on the chain.\n\nEach of the following $n$ lines contains integer coordinates $x_i, y_i$ of the vertex $P_i (0 \\le x_1 < x_2 < \\cdots < x_n \\le 10^9, 0 \\le y_i \\le 10^9)$.\n", "outputFormat": "For each test case, output a single line containing $n-1$ space-separated integers. These should be the smallest indices of chain segments visible to the right, or $0$ when no such segment exists.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Mountainous landscape", "background": null, "description": "你正在穿越一个以山脉为主的风景区——在你的路径上有 $n$ 个地标（山峰和山谷）。你停下来喘口气，想知道：你现在在地平线上看到的是哪座山？\n\n正式地说：给定一个平面上的多边形链 $P_1,P_2,\\cdots,P_n$。这些点的 $x$ 坐标是严格递增的。对于这条链的每一段 $P_i P_{i+1}$，找出最小的索引 $j > i$，使得 $P_j P_{j+1}$ 上的至少一个点从 $P_i P_{i+1}$ 可见（严格位于射线 $P_i \\ P^{\\rightarrow}_{i+1}$ 之上）。\n\n![0](https://cdn.luogu.com.cn/upload/pic/23379.png)", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来的部分是测试用例的描述：\n\n每个测试用例的第一行包含一个整数 $n(2 \\le n \\le 100 000)$——链上的顶点数量。\n\n接下来的 $n$ 行中的每一行包含顶点 $P_i$ 的整数坐标 $x_i, y_i (0 \\le x_1 < x_2 < \\cdots < x_n \\le 10^9, 0 \\le y_i \\le 10^9)$。", "outputFormat": "对于每个测试用例，输出一行包含 $n-1$ 个以空格分隔的整数。这些应该是向右可见的链段的最小索引，或者当不存在这样的链段时为 $0$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4759", "type": "P", "difficulty": 3, "samples": [["3\n8\n10\n24\n", "IMPOSSIBLE\n10 = 1 + 2 + 3 + 4\n24 = 7 + 8 + 9\n"]], "limits": {"time": [2000, 2000], "memory": [128000, 128000]}, "tags": ["2014", "枚举", "ICPC", "CERC"], "title": "[CERC2014] Sums", "background": "", "description": "Given an integer $N$, express it as the sum of at least two consecutive positive integers. For example:\n   \n   - $10 = 1 + 2 + 3 + 4$\n   - $24 = 7 + 8 + 9$\n\nIf there are multiple solutions, output the one with the smallest possible number of summands.\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case consists of one line containing an integer $N(1 \\le N \\le 10^9)$.", "outputFormat": "For each test case, output a single line containing the equation in the format:\n``N = a + (a+1) + ... + b`` as in the example. If there is no solution, output a single word ``IMPOSSIBLE`` instead.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Sums", "background": "", "description": "Given an integer $N$, express it as the sum of at least two consecutive positive integers. For example:\n   \n   - $10 = 1 + 2 + 3 + 4$\n   - $24 = 7 + 8 + 9$\n\nIf there are multiple solutions, output the one with the smallest possible number of summands.\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case consists of one line containing an integer $N(1 \\le N \\le 10^9)$.", "outputFormat": "For each test case, output a single line containing the equation in the format:\n``N = a + (a+1) + ... + b`` as in the example. If there is no solution, output a single word ``IMPOSSIBLE`` instead.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Sums", "background": "", "description": "## 题目大意\n\n一共有 $T$ 组数据，每组数据给定一个数 $N$，请将 $N$ 分解为几个连续正整数的和，如果有多种情况，请输出最小数最大的情况。", "inputFormat": "第一行，一个整数 $T$，表示数据组数。\n\n第 $2$ 行至第 $T+1$ 行，每行一个整数 $N$，表示要拆分的数字。", "outputFormat": "$T$ 行，每行一个式子，表示拆分结果。\n\n如果无解，请输出 `IMPOSSIBLE`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4760", "type": "P", "difficulty": 3, "samples": [["1\n5\n0 0 6\n6 8 4\n-9 0 3\n6 16 4\n0 -11 4\n", "1 clockwise\n3/2 counterclockwise\n2 counterclockwise\n3/2 clockwise\nnot moving"]], "limits": {"time": [1000, 1000], "memory": [128000, 128000]}, "tags": ["数学", "2014", "ICPC", "CERC"], "title": "[CERC2014] Wheels", "background": "", "description": "A very important and complicated machine consists of $n$ wheels, numbered $1, 2, . . . , n$. They are actually cogwheels, but the cogs are so small that we can model them as circles on the plane.\n\nEvery wheel can spin around its center.\n\nTwo wheels cannot overlap (they do not have common interior points), but they can touch.\n\nIf two wheels touch each other and one of them rotates, the other one spins as well, as their micro-cogs are locked together.\n\nA force is put to wheel $1$ (and to no other wheel), making it rotate at the rate of exactly one turn per minute, clockwise. Compute the rates of other wheels’ movement. You may assume that the machine is not jammed (the movement is physically possible).\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case consists of one line containing the number of wheels $n(1 \\le n \\le 1000)$ . \n\nEach of the following lines contain three integers $x, y$ and $r(-10 000 \\le x, y \\le 10 000, 1 \\le r \\le 10 000)$ where $(x, y)$ denote the Cartesian coordinates of the wheel’s center and $r$ is its radius.", "outputFormat": "For each test case, output $n$ lines, each describing the movement of one wheel, in the same order as in the input. For every wheel, output either ``p/q clockwise`` or ``p/q counterclockwise``,where the irreducible fraction $p/q$ is the number of wheel turns per minute. If $q$ is $1$, output just $p$ as an integer. If a wheel is standing still, output ``not moving``.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Wheels", "background": "", "description": "A very important and complicated machine consists of $n$ wheels, numbered $1, 2, . . . , n$. They are actually cogwheels, but the cogs are so small that we can model them as circles on the plane.\n\nEvery wheel can spin around its center.\n\nTwo wheels cannot overlap (they do not have common interior points), but they can touch.\n\nIf two wheels touch each other and one of them rotates, the other one spins as well, as their micro-cogs are locked together.\n\nA force is put to wheel $1$ (and to no other wheel), making it rotate at the rate of exactly one turn per minute, clockwise. Compute the rates of other wheels’ movement. You may assume that the machine is not jammed (the movement is physically possible).\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case consists of one line containing the number of wheels $n(1 \\le n \\le 1000)$ . \n\nEach of the following lines contain three integers $x, y$ and $r(-10 000 \\le x, y \\le 10 000, 1 \\le r \\le 10 000)$ where $(x, y)$ denote the Cartesian coordinates of the wheel’s center and $r$ is its radius.", "outputFormat": "For each test case, output $n$ lines, each describing the movement of one wheel, in the same order as in the input. For every wheel, output either ``p/q clockwise`` or ``p/q counterclockwise``,where the irreducible fraction $p/q$ is the number of wheel turns per minute. If $q$ is $1$, output just $p$ as an integer. If a wheel is standing still, output ``not moving``.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Wheels", "background": "", "description": "一个非常重要和复杂的机器由$n$个轮子组成，编号为$1,2,…,n$。它们其实是齿轮，但是齿太小了，我们可以把它们近似看成成平面上的圆。\r\n\r\n每一个齿轮都能围绕它的中心旋转。\r\n\r\n两个齿轮不会重叠（因为它们内部没有共同的点），但它们可以互相接触。\r\n\r\n如果两个齿轮相互接触，其中一个齿轮转动，另一个齿轮也随之转动，因为它们的齿被卡在一起。\r\n\r\n一个力作用于齿轮1（并且力没有作用于其他齿轮），使它以每分钟转一圈的速度顺时针旋转。计算其他齿轮的运动速度。你可以假设机器没有卡住（运动在物理理论上是可以的）。", "inputFormat": "输入包括多组数据，第一行为组数$T$；\r\n\r\n对于每组数据如下：\r\n\r\n第一行包括一个齿轮数$n,(1 \\le n \\le 1000)$。\r\n\r\n接下来$n$行每行包含三个整数$x,y,r,(10000≤x,y≤10000,1≤r≤10000)$，其中$(x,y)$表示齿轮中心的笛卡尔坐标（直角坐标），$r$是其半径。", "outputFormat": "对于每组数据，输出$n$行，第$i$行为第$i$个齿轮的运动状态。对于每个齿轮，输出或`p/q clockwise`或`p/q counterclockwise`，其中最简分数`p/q`是每分钟齿轮转数。如果$q$为$1$，则输出整数$p$。如果齿轮静止不动，则输出`not moving`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4761", "type": "P", "difficulty": 6, "samples": [["3\n?heoret?cal\nc?mputer\n?cience\njagiellonian\n?niversity\nkra?ow\n?\nb\nc", "42562\n52\n1"]], "limits": {"time": [2000, 1000, 1000], "memory": [128000, 128000, 128000]}, "tags": ["2014", "ICPC", "CERC"], "title": "[CERC2014] Vocabulary", "background": "", "description": "According to a popular belief, computer programmers drink a lot of coffee and know only a few words. The vocabulary of a typical programmer consists of just three words. Besides, he rarely knows how to spell them. To help programmers with their spelling mistakes, we published a book titled $The \\ Dictionary \\ of \\ the \\ Three \\ Words \\ Every \\ Typical \\ Programmer \\ Should \\ Know$.\n\nYou got a copy of the book but, soon after that, you spilled your coffee over it.\n\nNow, youcannot read some of the characters. Fortunately, the three words were, as usually in dictionaries,distinct and printed in lexicographical order.\nBefore you attempt to use that fact to recover the missing characters, you want to know in how many different ways you can do it. Since you expect this number might be large, you want to know it modulo $10^9 + 9$.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case consists of three lines, each containing a single nonempty word – in the order they appear in the dictionary. Words consist of small letters of the English alphabet and question marks, the latter denoting missing characters. Each word is at most $1 000 000$ characters long.\n", "outputFormat": "For each test case, output one line containing the number of different ways you can substitute each question mark with one of the $26$ letters from ``a`` to ``z`` in such a way that the three words are distinct and in lexicographical order. The number should be printed modulo $10^9 + 9$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Vocabulary", "background": "", "description": "According to a popular belief, computer programmers drink a lot of coffee and know only a few words. The vocabulary of a typical programmer consists of just three words. Besides, he rarely knows how to spell them. To help programmers with their spelling mistakes, we published a book titled $The \\ Dictionary \\ of \\ the \\ Three \\ Words \\ Every \\ Typical \\ Programmer \\ Should \\ Know$.\n\nYou got a copy of the book but, soon after that, you spilled your coffee over it.\n\nNow, youcannot read some of the characters. Fortunately, the three words were, as usually in dictionaries,distinct and printed in lexicographical order.\nBefore you attempt to use that fact to recover the missing characters, you want to know in how many different ways you can do it. Since you expect this number might be large, you want to know it modulo $10^9 + 9$.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case consists of three lines, each containing a single nonempty word – in the order they appear in the dictionary. Words consist of small letters of the English alphabet and question marks, the latter denoting missing characters. Each word is at most $1 000 000$ characters long.\n", "outputFormat": "For each test case, output one line containing the number of different ways you can substitute each question mark with one of the $26$ letters from ``a`` to ``z`` in such a way that the three words are distinct and in lexicographical order. The number should be printed modulo $10^9 + 9$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Vocabulary", "background": "", "description": "根据一种流行的说法，计算机程序员喝很多咖啡，并且只知道几个单词。一个典型程序员的词汇量只有三个单词。此外，他很少知道如何拼写它们。为了帮助程序员纠正拼写错误，我们出版了一本名为《每个典型程序员应该知道的三个单词词典》的书。\n\n你得到了一本书的副本，但不久之后，你把咖啡洒在了上面。\n\n现在，你无法阅读其中的一些字符。幸运的是，这三个单词在字典中是不同的，并按字典顺序排列。在你尝试利用这一事实来恢复缺失的字符之前，你想知道有多少种不同的方法可以做到这一点。由于你预计这个数字可能很大，你想知道它对 $10^9 + 9$ 取模的结果。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来的描述是测试用例：\n\n每个测试用例由三行组成，每行包含一个非空单词——按它们在字典中出现的顺序。单词由小写英文字母和问号组成，问号表示缺失的字符。每个单词最多有 $1,000,000$ 个字符。", "outputFormat": "对于每个测试用例，输出一行，包含将每个问号替换为从 “a” 到 “z” 的 $26$ 个字母之一的不同方法数，使得三个单词不同且按字典顺序排列。结果应对 $10^9 + 9$ 取模。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4762", "type": "P", "difficulty": 6, "samples": [["4\nAAAA\nAGCTTGCA\nAAGGGGAAGGGGAA\nAAACAGTCCTGACAAAAAAAAAAAAC", "3\n8\n6\n18"]], "limits": {"time": [10000, 10000, 1000, 10000], "memory": [128000, 128000, 128000, 128000]}, "tags": ["2014", "O2优化", "回文自动机 PAM", "ICPC", "CERC"], "title": "[CERC2014] Virus synthesis", "background": "", "description": "Viruses are usually bad for your health. How about fighting them with... other viruses? In this problem, you need to find out how to synthesize such good viruses.\n\nWe have prepared for you a set of strings of the letters $A, G, T$ and $C$. They correspond to the DNA nucleotide sequences of viruses that we want to synthesize, using the following operations:\n\n   - Adding a nucleotide either to the beginning or the end of the existing sequence.\n   - Replicating the sequence, reversing the copied piece, and gluing it either to the beginning or to the end of the original (so that e.g., $AGTC$ can become $AGTCCTGA$ or $CTGAAGTC$).\n\nWe’re concerned about efficiency, since we have very many such sequences, some of them very long. Find a way to synthesize them in a minimum number of operations.\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case consists of a single line containing a non-empty string. The string uses only the capital letters $A, C, G$ and $T$ and is not longer than $100 000$ characters.\n", "outputFormat": "For each test case, output a single line containing the minimum total number of operations necessary to construct the given sequence.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Virus synthesis", "background": "", "description": "Viruses are usually bad for your health. How about fighting them with... other viruses? In this problem, you need to find out how to synthesize such good viruses.\n\nWe have prepared for you a set of strings of the letters $A, G, T$ and $C$. They correspond to the DNA nucleotide sequences of viruses that we want to synthesize, using the following operations:\n\n   - Adding a nucleotide either to the beginning or the end of the existing sequence.\n   - Replicating the sequence, reversing the copied piece, and gluing it either to the beginning or to the end of the original (so that e.g., $AGTC$ can become $AGTCCTGA$ or $CTGAAGTC$).\n\nWe’re concerned about efficiency, since we have very many such sequences, some of them very long. Find a way to synthesize them in a minimum number of operations.\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case consists of a single line containing a non-empty string. The string uses only the capital letters $A, C, G$ and $T$ and is not longer than $100 000$ characters.\n", "outputFormat": "For each test case, output a single line containing the minimum total number of operations necessary to construct the given sequence.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Virus synthesis", "background": "", "description": "病毒通常对健康有害。那么用……其他病毒来对抗它们怎么样？在这个问题中，你需要找出如何合成这样的好病毒。\n\n我们为你准备了一组由字母 $A, G, T$ 和 $C$ 组成的字符串。它们对应于我们想要合成的病毒的 DNA 核苷酸序列，可以使用以下操作：\n\n- 在现有序列的开头或结尾添加一个核苷酸。\n- 复制序列，反转复制的片段，并将其粘贴到原序列的开头或结尾（例如，$AGTC$ 可以变成 $AGTCCTGA$ 或 $CTGAAGTC$）。\n\n由于我们有很多这样的序列，其中一些非常长，我们关心效率。找出一种方法，以最少的操作次数合成它们。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。测试用例的描述如下：\n\n每个测试用例由一行组成，包含一个非空字符串。该字符串仅使用大写字母 $A, C, G$ 和 $T$，且长度不超过 $100000$ 个字符。", "outputFormat": "对于每个测试用例，输出一行，包含构建给定序列所需的最小操作总数。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4763", "type": "P", "difficulty": 4, "samples": [["3\n3\n1 B\n3 W\n2 B\n4\n3 W\n3 B\n9 W\n1 B\n2\n2 W\n3 W", "2\n3\n5"]], "limits": {"time": [4000, 4000], "memory": [128000, 128000]}, "tags": ["2014", "ICPC", "CERC"], "title": "[CERC2014] Bricks", "background": "", "description": "You are given a sequence of white $(W)$ and black $(B)$ bricks. The goal is to partition it into some number of non-empty, contiguous blocks, each one having the same ratio of white and black bricks.\n\nOf course one can always “partition” the sequence into one single block (which is not very interesting). We want, however, to have as many blocks as possible. Consider for example the following sequences and its partitions:\n\n   - $BWWWBB = BW + WWBB$ (ratio 1:1),\n   - $WWWBBBWWWWWWWWWB = WWWB + BBWWWWWW + WWWB$ (ratio 3:1).\n\nNote that both of these partitions are optimal with respect to the number of blocks.\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case starts with one line containing an integer $n(1 \\le n \\le 10^5)$ which is the length of the description of a sequence. Each of the following $n$ lines consists of an integer $k(1 \\le k \\le 10^9)$ and one of the characters $W$ or $B$, meaning that $k$ bricks of the given color follow next in the sequence. It is guaranteed that the total length of the brick sequence does not exceed $10^9$.", "outputFormat": "For each test case, output a single line containing the largest possible number of blocks.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Bricks", "background": "", "description": "You are given a sequence of white $(W)$ and black $(B)$ bricks. The goal is to partition it into some number of non-empty, contiguous blocks, each one having the same ratio of white and black bricks.\n\nOf course one can always “partition” the sequence into one single block (which is not very interesting). We want, however, to have as many blocks as possible. Consider for example the following sequences and its partitions:\n\n   - $BWWWBB = BW + WWBB$ (ratio 1:1),\n   - $WWWBBBWWWWWWWWWB = WWWB + BBWWWWWW + WWWB$ (ratio 3:1).\n\nNote that both of these partitions are optimal with respect to the number of blocks.\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case starts with one line containing an integer $n(1 \\le n \\le 10^5)$ which is the length of the description of a sequence. Each of the following $n$ lines consists of an integer $k(1 \\le k \\le 10^9)$ and one of the characters $W$ or $B$, meaning that $k$ bricks of the given color follow next in the sequence. It is guaranteed that the total length of the brick sequence does not exceed $10^9$.", "outputFormat": "For each test case, output a single line containing the largest possible number of blocks.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Bricks", "background": null, "description": "给你一个由 'B' 和 'W' 组成的序列，将其按分成最多的区间且每个区间的 'B':'W' 的值相等。", "inputFormat": "多组数据，第一行一个整数 $T$ 表示数据组数。\n每组数据的第一行为一个整数 $n$，接下来 $n$ 行，每行一个整数 $k$ 和一个字符（'B' 或 'W'）表示在上一个序列后有一个长度为 $k$ 的 'B' 或 'W' 的序列，序列的总长度不超过 $10^9$。", "outputFormat": "共 $T$ 行，每行一个整数，表示能分成的最多的区间数。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4764", "type": "P", "difficulty": 7, "samples": [["1\n5 7\n1 2 2\n2 3 4\n3 4 3\n4 5 1\n5 1 3\n2 5 4\n1 4 5\n5\n1 2\n4 7\n11 12\n11 13\n18 19\n", "3\n9\n8\n14\n13"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "O2优化", "ICPC", "CERC"], "title": "[CERC2014] Pork barrel", "background": "", "description": "Winning the election was simpler than you expected: it was enough to promise to finally build a good quality, country-wide road infrastructure, of course without crippling the budget... Your happiness did not last long, however: it seems, that the citizens have found a way to actually hold you accountable for your promise!\n\nThere are $n$ major cities in your country. The Ministry of Transport has prepared a detailed map, outlining $m$ possible highway connections, together with their costs. The Quality Assurance Committee will not let you build a highway cheaper than $l$, and the National Spendings Regulatory Committee will not let you build a highway more expensive than $h$. To claim a “country-wide” network, you have to connect (possibly indirectly) as many pairs of cities, as it is possible within these two constraints. You have to find the cheapest way to do it, and you have to find it quickly! Of all networks that meet the constraints and connect the most pairs of cities,compute the cost of the cheapest one.\n\nTo make things worse, both committees are heavily influenced by your angry competitors:each time you publish your hard-prepared plan, they immediately change their rulings $l$ and $h$,and you are forced to start from scratch.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe first line of each test case contains integers $n$ and $m(1 \\le n \\le 1000, 0 \\le m \\le 100 000)$ – the number of cities in the country, and of possible direct connections, respectively.\n\nEach of the following $m$ lines contains three integers $x, y, w (1 \\le x ≠ y \\le n, 1 \\le w \\le 1 000 000)$, denoting that the cities $x$ and $y$ can be connected by a bidirectional highway at cost $w$. There might be many ways to connect a single pair of cities.\n\nThe following line contains an integer $q(1 \\le q \\le 1 000 000)$ – the number of rulings of the committees. Each of the following $q$ lines contains two integers. The first of the lines contains the initial rulings $l_1, h_1$, given directly. The rest of the rulings are encoded. The numbers in the $j-th$ of the lines for $j > 1$ are $l_j + c_{j -1}$ and $h_j + c_{j-1}$, where $l_j$ and $h_j$ are the actual rulings and $c_{j-1}$ is the correct answer for the preceding rulings $l_{j-1}$ and $h_{j-1}$.\n\nAll rulings satisfy $1 \\le l_j \\le h_j \\le 1 000 000$.\n", "outputFormat": "For each test case, output $q$ lines, one for each ruling. In the $j-th$ of them,output the minimal cost $c_j$ of building a highway network which adheres to the committees’ constraints, and creates the maximum number of connected pairs of cities.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Pork barrel", "background": "", "description": "Winning the election was simpler than you expected: it was enough to promise to finally build a good quality, country-wide road infrastructure, of course without crippling the budget... Your happiness did not last long, however: it seems, that the citizens have found a way to actually hold you accountable for your promise!\n\nThere are $n$ major cities in your country. The Ministry of Transport has prepared a detailed map, outlining $m$ possible highway connections, together with their costs. The Quality Assurance Committee will not let you build a highway cheaper than $l$, and the National Spendings Regulatory Committee will not let you build a highway more expensive than $h$. To claim a “country-wide” network, you have to connect (possibly indirectly) as many pairs of cities, as it is possible within these two constraints. You have to find the cheapest way to do it, and you have to find it quickly! Of all networks that meet the constraints and connect the most pairs of cities,compute the cost of the cheapest one.\n\nTo make things worse, both committees are heavily influenced by your angry competitors:each time you publish your hard-prepared plan, they immediately change their rulings $l$ and $h$,and you are forced to start from scratch.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe first line of each test case contains integers $n$ and $m(1 \\le n \\le 1000, 0 \\le m \\le 100 000)$ – the number of cities in the country, and of possible direct connections, respectively.\n\nEach of the following $m$ lines contains three integers $x, y, w (1 \\le x ≠ y \\le n, 1 \\le w \\le 1 000 000)$, denoting that the cities $x$ and $y$ can be connected by a bidirectional highway at cost $w$. There might be many ways to connect a single pair of cities.\n\nThe following line contains an integer $q(1 \\le q \\le 1 000 000)$ – the number of rulings of the committees. Each of the following $q$ lines contains two integers. The first of the lines contains the initial rulings $l_1, h_1$, given directly. The rest of the rulings are encoded. The numbers in the $j-th$ of the lines for $j > 1$ are $l_j + c_{j -1}$ and $h_j + c_{j-1}$, where $l_j$ and $h_j$ are the actual rulings and $c_{j-1}$ is the correct answer for the preceding rulings $l_{j-1}$ and $h_{j-1}$.\n\nAll rulings satisfy $1 \\le l_j \\le h_j \\le 1 000 000$.\n", "outputFormat": "For each test case, output $q$ lines, one for each ruling. In the $j-th$ of them,output the minimal cost $c_j$ of building a highway network which adheres to the committees’ constraints, and creates the maximum number of connected pairs of cities.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Pork barrel", "background": "", "description": "赢得选举比你预期的要简单：只需承诺最终建立一个高质量的全国性道路基础设施，当然不能让预算瘫痪……然而你的快乐并没有持续多久：似乎市民们找到了一个方法，实际上让你对你的承诺负责！\n\n在你的国家有 $n$ 个主要城市。交通部准备了一份详细的地图，列出了 $m$ 条可能的高速公路连接及其成本。质量保证委员会不会让你修建成本低于 $l$ 的高速公路，而国家支出监管委员会不会让你修建成本高于 $h$ 的高速公路。为了声称拥有一个“全国性”的网络，你必须在这两个限制内尽可能多地连接（可能是间接地）城市对。你必须找到最便宜的方法来做到这一点，而且必须快速找到！在所有满足限制并连接最多城市对的网络中，计算出最便宜的一个的成本。\n\n更糟糕的是，这两个委员会都受到你愤怒的竞争对手的强烈影响：每次你公布你精心准备的计划时，他们立即改变他们的裁决 $l$ 和 $h$，你被迫从头开始。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来的描述是测试用例的内容：\n\n每个测试用例的第一行包含整数 $n$ 和 $m(1 \\le n \\le 1000, 0 \\le m \\le 100 000)$——国家中的城市数量和可能的直接连接数量。\n\n接下来的 $m$ 行中的每一行包含三个整数 $x, y, w (1 \\le x \neq y \\le n, 1 \\le w \\le 1 000 000)$，表示城市 $x$ 和 $y$ 可以通过成本为 $w$ 的双向高速公路连接。可能有多种方式连接单对城市。\n\n接下来的行包含一个整数 $q(1 \\le q \\le 1 000 000)$——委员会的裁决数量。接下来的 $q$ 行中的第一行直接给出初始裁决 $l_1, h_1$。其余的裁决是编码的。对于 $j > 1$ 的行中的数字是 $l_j + c_{j -1}$ 和 $h_j + c_{j-1}$，其中 $l_j$ 和 $h_j$ 是实际的裁决，$c_{j-1}$ 是前一个裁决 $l_{j-1}$ 和 $h_{j-1}$ 的正确答案。\n\n所有裁决满足 $1 \\le l_j \\le h_j \\le 1 000 000$。", "outputFormat": "对于每个测试用例，输出 $q$ 行，每个裁决一行。在第 $j$ 行中，输出符合委员会限制并创建最大数量连接城市对的高速公路网络的最小成本 $c_j$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4765", "type": "P", "difficulty": 6, "samples": [["1\n3 1\n10 5\n8 1\n20 12", "7"]], "limits": {"time": [3000, 3000], "memory": [128000, 128000]}, "tags": ["2014", "O2优化", "ICPC", "CERC"], "title": "[CERC2014] The Imp", "background": "", "description": "You arrive in Ye Olde Magic Shoppe with some hard-earned gold to purchase wondrous and unique magic items. There are $n$ such items in the shop, each of them locked in a special magic box. The $i-th$ box costs $c_i$ gold pieces to buy, and contains an item worth $v_i$ gold pieces. The costs and item values are known to you, as you have previously read, mastered, and memorized Ye Olde Magic Catalogue.\n\nA mortal, such as you, can safely carry only one magic item. You therefore aim to get the most precious one. And obtain it you would, if not for a malicious, magical creature, known as The Imp.\n\nThe Imp can cast a mischievous spell, which transforms the content of any magic box into worthless dust. Of course, he will use the spell just after you buy a box, to make you pay for the item and not get it. You are thus forced to buy another box, and then the next one...\n\nThe Imp has enough magic to cast the spell at most $k$ times. He can, of course, refrain from using it, allowing you to keep an item. You can walk away at any time, empty-handed (though it would surely be a disgrace). However, if you get an item, you must keep it and leave the shop.\n\nYou aim to maximize your gain (the value of the acquired item minus all the expenses paid previously), while The Imp wants to minimize it. If both you and the creature use the optimal strategy, how much gold will you earn?", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of\nthe test cases follow:\n\nEach test case starts with a line containing the number of items $n(1 \\le n \\le 150 000)$ and the the maximum number of The Imp’s spells $k(0 \\le k \\le 9)$. \n\nThe next $n$ lines contain the items’values and costs, the $i-th$ line containing the numbers $v_i$ and $c_i$, in that order $(0 \\le v_i, c_i \\le 10^6)$.\n", "outputFormat": "For each test case, output one line containing your gain.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] The Imp", "background": "", "description": "You arrive in Ye Olde Magic Shoppe with some hard-earned gold to purchase wondrous and unique magic items. There are $n$ such items in the shop, each of them locked in a special magic box. The $i-th$ box costs $c_i$ gold pieces to buy, and contains an item worth $v_i$ gold pieces. The costs and item values are known to you, as you have previously read, mastered, and memorized Ye Olde Magic Catalogue.\n\nA mortal, such as you, can safely carry only one magic item. You therefore aim to get the most precious one. And obtain it you would, if not for a malicious, magical creature, known as The Imp.\n\nThe Imp can cast a mischievous spell, which transforms the content of any magic box into worthless dust. Of course, he will use the spell just after you buy a box, to make you pay for the item and not get it. You are thus forced to buy another box, and then the next one...\n\nThe Imp has enough magic to cast the spell at most $k$ times. He can, of course, refrain from using it, allowing you to keep an item. You can walk away at any time, empty-handed (though it would surely be a disgrace). However, if you get an item, you must keep it and leave the shop.\n\nYou aim to maximize your gain (the value of the acquired item minus all the expenses paid previously), while The Imp wants to minimize it. If both you and the creature use the optimal strategy, how much gold will you earn?", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of\nthe test cases follow:\n\nEach test case starts with a line containing the number of items $n(1 \\le n \\le 150 000)$ and the the maximum number of The Imp’s spells $k(0 \\le k \\le 9)$. \n\nThe next $n$ lines contain the items’values and costs, the $i-th$ line containing the numbers $v_i$ and $c_i$, in that order $(0 \\le v_i, c_i \\le 10^6)$.\n", "outputFormat": "For each test case, output one line containing your gain.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] The Imp", "background": null, "description": "你带着一些来之不易的金币来到了 Ye Olde 魔法商店，想要购买一些妙不可言的魔术物品。商店里有 $n$ 个魔术实体，每个实体都锁在一个特殊的魔术宝箱中。第 $i$ 个宝箱（和其中的实体）的售价为 $c_i$个金币，而其中实体的价值相当于 $v_i$ 个金币。你作为曾经完整钻研了《Ye Olde 魔法目录》的顶级做题家，当然毫无疑问地记住了每个盒子和其中实体的售价和价值。\n\n然而像你这样的凡人，只能安全地携带一件魔法实体。因此，你想要得到最宝贵的一个。你本可以直接得到它的——如果不是因为调皮而又神奇的小恶魔的话。\n\n小恶魔可以使用魔法，从而将某一个魔术宝箱内的实体转化为毫无价值的灰尘。当然，他会在你购买一个魔术宝箱后立即对其使用该魔法，这样你就为这个宝箱付了钱而没能得到里面的实体。因此，你被迫另买一个，再买一个……\n\n小恶魔拥的魔力最多可以用来使用 $k$ 次魔法。当然，他可以不用完这 $k$ 次魔法，而你也可以随时空手走开（尽管这是一个奇耻大辱）。但是，如果你成功地买到了到一个实体（而没有被变成灰尘），则你必须保留该实体并离开商店。\n\n你的目标是最大化你的收益（所购实体的价值减去支付的所有费用（包括购买当前实体和之前的灰尘）），而小恶魔则希望将其最小化。如果你和小恶魔都使用最佳策略，那么你的收益将会相当于多少金币？", "inputFormat": "**本题每个测试点包含多组数据。**\n\n第一行包含一个正整数 $T$ 表示测试数据组数。  \n每组数据的第一行包括两个数 $n$ 和 $k$ ，分别表示魔术实体个数和小恶魔使用魔法的最大次数。  \n接下来 $n$ 行，每行包括两个数 $v_i$ 和 $c_i$，分别表示第 $i$ 个盒子和其中实体的价值和售价。", "outputFormat": "对于每组数据，输出一行一个数表示答案。", "hint": "$1\\le n\\le1.5\\times10^5,0\\le k\\le9,0\\le v_i,c_i\\le10^6$。", "locale": "zh-CN"}}}
{"pid": "P4766", "type": "P", "difficulty": 5, "samples": [["1\n3\n1 4 4\n4 7 5\n3 4 7\n", "7"]], "limits": {"time": [2000, 2000, 2000], "memory": [128000, 128000, 128000]}, "tags": ["动态规划 DP", "2014", "离散化", "O2优化", "区间 DP", "ICPC", "CERC"], "title": "[CERC2014] Outer space invaders", "background": "", "description": "The aliens from outer space have (finally!) invaded Earth. Defend yourself, or be disintegrated!\n\nOr assimilated. Or eaten. We are not yet sure.\n\nThe aliens follow a known attack pattern. There are $n$ attackers, the $i-th$ one appears at time $a_i$, at distance $d_i$ from you. He must be destroyed no later than at time $b_i$, or else he will fire his weapon, which will definitely end the fight.\n\nYour weapon is an area-blaster, which can be set to any given power. If fired with power $R$,it momentarily destroys all aliens at distance $R$ or smaller. It also consumes $R$ fuel cells.\n\nDetermine the minimal cost (measured in fuel cells) of destroying all the aliens, without being killed.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case starts with a line containing the number of aliens $n(1 \\le n \\le 300)$. Of the next $n$ lines, the $i-th$ one contains three integers $a_i, b_i, d_i, (1 \\le a_i < b_i \\le 10 000, 1 \\le d_i \\le 10 000)$.\n\nThe $i-th$ alien appears at time $a_i$, is idle until $b_i$, and his distance from you is $d_i$.\n", "outputFormat": "For each test case, output one line containing the minimum number of cells needed to destroy all the aliens.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Outer space invaders", "background": "", "description": "The aliens from outer space have (finally!) invaded Earth. Defend yourself, or be disintegrated!\n\nOr assimilated. Or eaten. We are not yet sure.\n\nThe aliens follow a known attack pattern. There are $n$ attackers, the $i-th$ one appears at time $a_i$, at distance $d_i$ from you. He must be destroyed no later than at time $b_i$, or else he will fire his weapon, which will definitely end the fight.\n\nYour weapon is an area-blaster, which can be set to any given power. If fired with power $R$,it momentarily destroys all aliens at distance $R$ or smaller. It also consumes $R$ fuel cells.\n\nDetermine the minimal cost (measured in fuel cells) of destroying all the aliens, without being killed.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case starts with a line containing the number of aliens $n(1 \\le n \\le 300)$. Of the next $n$ lines, the $i-th$ one contains three integers $a_i, b_i, d_i, (1 \\le a_i < b_i \\le 10 000, 1 \\le d_i \\le 10 000)$.\n\nThe $i-th$ alien appears at time $a_i$, is idle until $b_i$, and his distance from you is $d_i$.\n", "outputFormat": "For each test case, output one line containing the minimum number of cells needed to destroy all the aliens.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Outer space invaders", "background": null, "description": "来自外太空的外星人（最终）入侵了地球。保卫自己，或者解体，被他们同化，或者成为食物。迄今为止，我们无法确定。\n\n外星人遵循已知的攻击模式。有 $N$ 个外星人进攻，第 $i$ 个进攻的外星人会在时间 $a_i$ 出现，距离你的距离为 $d_i$，它必须在时间 $b_i$ 及以前被消灭，否则被消灭的会是你。\n\n你的武器是一个区域冲击波器，可以设置任何给定的功率。如果被设置了功率 $R$，它会瞬间摧毁与你的距离在 $R$ 以内的所有外星人（可以等于），同时它也会消耗 $R$ 单位的燃料电池。\n\n求摧毁所有外星人的最低成本（消耗多少燃料电池），同时保证自己的生命安全。", "inputFormat": "第一行输入一个数 $T$,表示有 $T$ 组数据。\n\n每组数据的第一行为外星人的数量 $n$（$1\\leq n\\leq 300$）。\n\n接下来 $n$ 行，每行有三个数 $a_i,b_i,d_i$ ，表示这个外星人在时间 $a_i$ 出现，距离你 $d_i$，在 $b_i$ 前时刻死亡。其中 $1 \\le a_i \\le b_i \\le 10000,1 \\le d_i \\le 10000$。", "outputFormat": "共 $T$ 行，每行输出摧毁所有外星人的最低成本。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4767", "type": "P", "difficulty": 6, "samples": [["10 5 \n1 2 3 6 7 9 11 22 44 50", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2000", "IOI", "枚举", "区间 DP", "四边形不等式"], "title": "[IOI 2000] 邮局 加强版", "background": null, "description": "高速公路旁边有一些村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标表示。没有两个在同样地方的村庄。两个位置之间的距离是其整数坐标差的绝对值。\n\n邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。\n\n你要编写一个程序，已知村庄的位置和邮局的数量，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。", "inputFormat": "第一行包含两个整数：第一个是村庄 $V$ 的数量，第二个是邮局的数量 $P$。\n\n第二行包含 $V$ 个整数。这些整数是村庄的位置。", "outputFormat": "第一行包含一个整数 $S$，它是每个村庄与其最近的邮局之间的所有距离的总和。", "hint": "对于 $40\\%$ 的数据，$V \\leq 300$。\n\n对于 $100\\%$ 的数据，$1 \\leq P \\leq 300$，$P \\leq V  \\leq 3000$，$1 \\leq $ 村庄位置 $\\leq 10000$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2000] Post Office (Enhanced Version)", "background": "", "description": "There are some villages along a highway. The highway is represented as the integer number line, and the position of each village is given by a single integer coordinate. No two villages are at the same position. The distance between two positions is the absolute value of the difference of their integer coordinates.\n\nPost offices will be built in some, but not necessarily all, villages. To build the post offices, you should choose their locations so that the sum of distances from each village to its nearest post office is minimized.\n\nYou need to write a program that, given the positions of the villages and the number of post offices, computes the minimum possible total sum of distances from each village to its nearest post office.", "inputFormat": "The first line contains two integers: the first is the number of villages $V$, and the second is the number of post offices $P$.\n\nThe second line contains $V$ integers. These integers are the positions of the villages.", "outputFormat": "The first line contains one integer $S$, which is the total sum of distances from each village to its nearest post office.", "hint": "For $40\\%$ of the testdata, $V \\leq 300$.\n\nFor $100\\%$ of the testdata, $1 \\leq P \\leq 300$, $P \\leq V \\leq 3000$, and $1 \\leq$ village positions $\\leq 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2000] 邮局 加强版", "background": null, "description": "高速公路旁边有一些村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标表示。没有两个在同样地方的村庄。两个位置之间的距离是其整数坐标差的绝对值。\n\n邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。\n\n你要编写一个程序，已知村庄的位置和邮局的数量，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。", "inputFormat": "第一行包含两个整数：第一个是村庄 $V$ 的数量，第二个是邮局的数量 $P$。\n\n第二行包含 $V$ 个整数。这些整数是村庄的位置。", "outputFormat": "第一行包含一个整数 $S$，它是每个村庄与其最近的邮局之间的所有距离的总和。", "hint": "对于 $40\\%$ 的数据，$V \\leq 300$。\n\n对于 $100\\%$ 的数据，$1 \\leq P \\leq 300$，$P \\leq V  \\leq 3000$，$1 \\leq $ 村庄位置 $\\leq 10000$。", "locale": "zh-CN"}}}
{"pid": "P4768", "type": "P", "difficulty": 6, "samples": [["1\n4 3\n1 2 50 1\n2 3 100 2\n3 4 50 1\n5 0 2\n3 0\n2 1\n4 1\n3 1\n3 2", "0\n50\n200\n50\n150"], ["1\n5 5\n1 2 1 2\n2 3 1 2\n4 3 1 2\n5 3 1 2\n1 5 2 1\n4 1 3\n5 1\n5 2\n2 0\n4 0", "0\n2\n3\n1"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "并查集", "Kruskal 重构树", "NOI", "O2优化", "最短路", "可持久化"], "title": "[NOI2018] 归程", "background": null, "description": "本题的故事发生在魔力之都，在这里我们将为你介绍一些必要的设定。\n\n魔力之都可以抽象成一个 $n$ 个节点、$m$ 条边的无向连通图（节点的编号从 $1$ 至 $n$）。我们依次用 $l,a$ 描述一条边的**长度、海拔**。\n\n作为季风气候的代表城市，魔力之都时常有雨水相伴，因此道路积水总是不可避免的。由于整个城市的排水系统连通，因此**有积水的边一定是海拔相对最低的一些边**。我们用**水位线**来描述降雨的程度，它的意义是：所有海拔**不超过**水位线的边都是**有积水**的。\n\nYazid 是一名来自魔力之都的 OIer，刚参加完 ION2018 的他将踏上归程，回到他温暖的家。Yazid 的家恰好在魔力之都的 $1$ 号节点。对于接下来 $Q$ 天，每一天 Yazid 都会告诉你他的出发点 $v$，以及当天的水位线 $p$。\n\n每一天，Yazid 在出发点都拥有一辆车。这辆车由于一些故障不能经过有积水的边。Yazid 可以在任意节点下车，这样接下来他就可以步行经过有积水的边。但车会被留在他下车的节点并不会再被使用。\n需要特殊说明的是，第二天车会被重置，这意味着：\n\n- 车会在新的出发点被准备好。\n- Yazid 不能利用之前在某处停放的车。\n\nYazid 非常讨厌在雨天步行，因此他希望在完成回家这一目标的同时，最小化他**步行经过的边**的总长度。请你帮助 Yazid 进行计算。\n\n本题的部分测试点将强制在线，具体细节请见【输入格式】和【子任务】。", "inputFormat": "单个测试点中包含多组数据。输入的第一行为一个非负整数 $T$，表示数据的组数。\n\n接下来依次描述每组数据，对于每组数据：\n\n第一行 $2$ 个非负整数 $n,m$，分别表示节点数、边数。\n\n接下来 $m$ 行，每行 $4$ 个正整数 $u, v, l, a$，描述一条连接节点 $u, v$ 的、长度为 $l$、海拔为 $a$ 的边。\n在这里，我们保证 $1 \\leq u,v \\leq n$。\n\n接下来一行 $3$ 个非负数 $Q, K, S$，其中 $Q$ 表示总天数，$K \\in {0,1}$ 是一个会在下面被用到的系数，$S$ 表示的是可能的最高水位线。\n\n接下来 $Q$ 行依次描述每天的状况。每行 $2$ 个整数 $v_0, p_0$ 描述一天：\n\n- 这一天的出发节点为 $v = (v_0 + K \\times \\mathrm{lastans} - 1) \\bmod n + 1$。\n- 这一天的水位线为 $p = (p_0 + K \\times \\mathrm{lastans}) \\bmod (S + 1)$。\n\n其中 $\\mathrm{lastans}$ 表示上一天的答案（最小步行总路程）。特别地，我们规定第 $1$ 天时 $\\mathrm{lastans} = 0$。\n在这里，我们保证 $1 \\leq v_0 \\leq n$，$0 \\leq p_0 \\leq S$。\n\n对于输入中的每一行，如果该行包含多个数，则用单个空格将它们隔开。", "outputFormat": "依次输出各组数据的答案。对于每组数据：\n\n- 输出 $Q$ 行每行一个整数，依次表示每天的最小步行总路程。", "hint": "### 更多样例\n\n更多样例请在附加文件中下载。\n\n#### 样例 3\n\n见附加文件中的 `return3.in` 与 `return3.ans`。\n\n该样例满足海拔为一种，且不强制在线。\n\n#### 样例 4\n\n见附加文件中的 `return4.in` 与 `return4.ans`。\n\n该样例满足图形态为一条链，且强制在线。\n\n#### 样例 5\n\n见附加文件中的 `return5.in` 与 `return5.ans`。\n\n该样例满足不强制在线。\n\n### 样例 1 解释\n\n第一天没有降水，Yazid 可以坐车直接回到家中。\n\n第二天、第三天、第四天的积水情况相同，均为连接 1，2 号节点的边、连接 3，4 号点的边有积水。\n\n对于第二天，Yazid 从 2 号点出发坐车只能去往 3 号节点，对回家没有帮助。因此 Yazid 只能纯靠徒步回家。\n\n对于第三天，从 4 号节点出发的唯一一条边是有积水的，车也就变得无用了。Yazid 只能纯靠徒步回家。\n\n对于第四天，Yazid 可以坐车先到达 2 号节点，再步行回家。\n\n第五天所有的边都积水了，因此 Yazid 只能纯靠徒步回家。\n\n### 样例 2 解释\n\n本组数据强制在线。\n\n第一天的答案是 $0$，因此第二天的 $v=\\left( 5+0-1\\right)\\bmod 5+1=5$，$p=\\left(2+0\\right)\\bmod\\left(3+1\\right)=2$。\n\n第二天的答案是 $2$，因此第三天的 $v=\\left( 2+2-1\\right)\\bmod 5+1=4$，$p=\\left(0+2\\right)\\bmod\\left(3+1\\right)=2$。\n\n第三天的答案是 $3$，因此第四天的 $v=\\left( 4+3-1\\right)\\bmod 5+1=2$，$p=\\left(0+3\\right)\\bmod\\left(3+1\\right)=3$。\n\n### 数据范围与约定\n\n所有测试点均保证 $T\\leq 3$，所有测试点中的所有数据均满足如下限制：\n\n- $n\\leq 2\\times 10^5$，$m\\leq 4\\times 10^5$，$Q\\leq 4\\times 10^5$，$K\\in\\left\\{0,1\\right\\}$，$1\\leq S\\leq 10^9$。\n- 对于所有边：$l\\leq 10^4$，$a\\leq 10^9$。\n- 任意两点之间都直接或间接通过边相连。\n\n**为了方便你快速理解，我们在表格中使用了一些简单易懂的表述。在此，我们对这些内容作形式化的说明：**\n\n- 图形态：对于表格中该项为“一棵树”或“一条链”的测试点，保证 $m = n-1$。除此之外，这两类测试点分别满足如下限制：\n  - 一棵树：保证输入的图是一棵树，即保证边不会构成回路。\n  - 一条链：保证所有边满足 $u + 1 = v$。\n- 海拔：对于表格中该项为“一种”的测试点，保证对于所有边有 $a = 1$。\n- 强制在线：对于表格中该项为“是”的测试点，保证 $K = 1$；如果该项为“否”，则有 $K = 0$。\n- 对于所有测试点，如果上述对应项为“不保证”，则对该项内容不作任何保证。\n\n| $n$              | $m$              | $Q$        | 测试点 | 形态      | 海拔      | 强制在线 |\n|------------------|------------------|------------|--------|-----------|-----------|----------|\n| $\\leq 1$         | $\\leq 0$         | $0$        | 1      | 不保证    | 一种      | 否        |\n| $\\leq 6$         | $\\leq 10$        | $10$       | 2      | ^         | ^         | ^         |\n| $\\leq 50$        | $\\leq 150$       | $100$      | 3      | ^         | ^         | ^         |\n| $\\leq 100$       | $\\leq 300$       | $200$      | 4      | ^         | ^         | ^         |\n| $\\leq 1500$      | $\\leq 4000$      | $2000$     | 5      | ^         | ^         | ^         |\n| $\\leq 200000$    | $\\leq 400000$    | $100000$   | 6      | ^         | ^         | ^         |\n| $\\leq 1500$      | $=n-1$           | $2000$     | 7      | 一条链    | 不保证    | ^         |\n| ^                | ^                | ^          | 8      | ^         | ^         | ^         |\n| ^                | ^                | ^          | 9      | ^         | ^         | ^         |\n| $\\leq 200000$    | ^                | $100000$   | 10     | 一棵树    | ^         | ^         |\n| ^                | ^                | ^          | 11     | ^         | ^         | 是        |\n| ^                | $\\leq 400000$    | ^          | 12     | 不保证    | ^         | 否        |\n| ^                | ^                | ^          | 13     | ^         | ^         | ^         |\n| ^                | ^                | ^          | 14     | ^         | ^         | ^         |\n| $\\leq 1500$      | $\\leq 4000$      | $2000$     | 15     | ^         | ^         | 是        |\n| ^                | ^                | ^          | 16     | ^         | ^         | ^         |\n| $\\leq 200000$    | $\\leq 400000$    | $100000$   | 17     | ^         | ^         | ^         |\n| ^                | ^                | ^          | 18     | ^         | ^         | ^         |\n| ^                | ^                | $400000$   | 19     | ^         | ^         | ^         |\n| ^                | ^                | ^          | 20     | ^         | ^         | ^         |", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2018] Return Journey", "background": "", "description": "The story of this problem takes place in the City of Magic. Here we introduce some necessary settings.\n\nThe City of Magic can be abstracted as a connected undirected graph with $n$ nodes and $m$ edges (the nodes are numbered from $1$ to $n$). For each edge, we use $l, a$ to describe its **length** and **altitude**.\n\nAs a typical monsoon-climate city, the City of Magic often has rain, so water on roads is unavoidable. Since the drainage system of the whole city is connected, **the flooded edges must be those with relatively low altitude**. We use the **water level** to describe the amount of rain. Its meaning is: all edges whose altitude is **not greater than** the water level are **flooded**.\n\nYazid is an OIer from the City of Magic. After just finishing ION2018, he is going to start his return journey to his warm home. Yazid’s home happens to be at node $1$ of the City of Magic. For the next $Q$ days, each day Yazid will tell you his starting point $v$ and the water level $p$ of that day.\n\nEach day, Yazid has a car at the starting point. Because of some malfunctions, this car cannot pass through flooded edges. Yazid may get out of the car at any node; after that he can walk through flooded edges. However, the car will be left at the node where he gets out and will not be used again.\nNote in particular that the car will be reset on the next day, which means:\n\n- The car will be prepared at the new starting point.\n- Yazid cannot use a car parked somewhere previously.\n\nYazid really dislikes walking on rainy days, so while still getting home, he wants to minimize the total length of the **edges he walks through**. Please help Yazid compute this.\n\nSome test points of this problem are forced online. For details, see **Input Format** and **Subtasks**.", "inputFormat": "A single test file contains multiple test cases. The first line is a non-negative integer $T$, indicating the number of test cases.\n\nThen each test case is described as follows:\n\nThe first line contains two non-negative integers $n, m$, representing the number of nodes and edges.\n\nThe next $m$ lines each contain four positive integers $u, v, l, a$, describing an edge connecting nodes $u, v$ with length $l$ and altitude $a$.\nHere we guarantee $1 \\leq u,v \\leq n$.\n\nThe next line contains three non-negative integers $Q, K, S$, where $Q$ is the total number of days, $K \\in {0,1}$ is a coefficient used below, and $S$ is the maximum possible water level.\n\nThe next $Q$ lines describe the situation for each day. Each line contains two integers $v_0, p_0$:\n\n- The starting node is $v = (v_0 + K \\times \\mathrm{lastans} - 1) \\bmod n + 1$.\n- The water level is $p = (p_0 + K \\times \\mathrm{lastans}) \\bmod (S + 1)$.\n\nHere $\\mathrm{lastans}$ is the answer of the previous day (the minimum total walking distance). In particular, we define $\\mathrm{lastans} = 0$ on day $1$.\nWe guarantee $1 \\leq v_0 \\leq n$, $0 \\leq p_0 \\leq S$.\n\nFor each line of the input, if it contains multiple numbers, they are separated by a single space.", "outputFormat": "Output the answers for each test case in order. For each test case:\n\n- Output $Q$ lines, each containing one integer, representing the minimum total walking distance for each day.", "hint": "### More Samples\n\nMore samples can be downloaded from the additional files.\n\n#### Sample 3\n\nSee `return3.in` and `return3.ans` in the additional files.\n\nThis sample satisfies that there is only one altitude value, and it is not forced online.\n\n#### Sample 4\n\nSee `return4.in` and `return4.ans` in the additional files.\n\nThis sample satisfies that the graph is a chain, and it is forced online.\n\n#### Sample 5\n\nSee `return5.in` and `return5.ans` in the additional files.\n\nThis sample is not forced online.\n\n### Explanation of Sample 1\n\nOn the first day there is no rainfall, so Yazid can drive directly home.\n\nOn the second, third, and fourth days, the flooded situation is the same: the edge connecting nodes 1 and 2, and the edge connecting nodes 3 and 4 are flooded.\n\nOn the second day, Yazid starts from node 2. By car he can only go to node 3, which does not help him get home. Therefore, Yazid can only walk all the way home.\n\nOn the third day, the only edge from node 4 is flooded, so the car becomes useless. Yazid can only walk all the way home.\n\nOn the fourth day, Yazid can drive to node 2 first, then walk home.\n\nOn the fifth day, all edges are flooded, so Yazid can only walk all the way home.\n\n### Explanation of Sample 2\n\nThis test case is forced online.\n\nThe answer on day 1 is $0$, so on day 2, $v=\\left( 5+0-1\\right)\\bmod 5+1=5$, $p=\\left(2+0\\right)\\bmod\\left(3+1\\right)=2$.\n\nThe answer on day 2 is $2$, so on day 3, $v=\\left( 2+2-1\\right)\\bmod 5+1=4$, $p=\\left(0+2\\right)\\bmod\\left(3+1\\right)=2$.\n\nThe answer on day 3 is $3$, so on day 4, $v=\\left( 4+3-1\\right)\\bmod 5+1=2$, $p=\\left(0+3\\right)\\bmod\\left(3+1\\right)=3$.\n\n### Constraints and Conventions\n\nAll test points guarantee $T\\leq 3$. All data in all test points satisfy the following limits:\n\n- $n\\leq 2\\times 10^5$, $m\\leq 4\\times 10^5$, $Q\\leq 4\\times 10^5$, $K\\in\\left\\{0,1\\right\\}$, $1\\leq S\\leq 10^9$.\n- For all edges: $l\\leq 10^4$, $a\\leq 10^9$.\n- Any two nodes are connected directly or indirectly by edges.\n\n**To help you understand quickly, we use some easy expressions in the table. Here we give formal explanations:**\n\n- Graph shape: for test points where this item is “a tree” or “a chain”, it is guaranteed that $m = n-1$. In addition, these two types satisfy:\n  - A tree: the input graph is a tree, i.e. edges do not form cycles.\n  - A chain: all edges satisfy $u + 1 = v$.\n- Altitude: for test points where this item is “one value”, it is guaranteed that for all edges $a = 1$.\n- Forced online: for test points where this item is “yes”, it is guaranteed that $K = 1$; if it is “no”, then $K = 0$.\n- For all test points, if the corresponding item is “not guaranteed”, then no guarantee is made for that item.\n\n| $n$              | $m$              | $Q$        | Test point | Shape           | Altitude          | Forced online |\n|------------------|------------------|------------|------------|-----------------|-------------------|--------------|\n| $\\leq 1$         | $\\leq 0$         | $0$        | 1          | Not guaranteed  | One value         | No           |\n| $\\leq 6$         | $\\leq 10$        | $10$       | 2          | ^               | ^                 | ^            |\n| $\\leq 50$        | $\\leq 150$       | $100$      | 3          | ^               | ^                 | ^            |\n| $\\leq 100$       | $\\leq 300$       | $200$      | 4          | ^               | ^                 | ^            |\n| $\\leq 1500$      | $\\leq 4000$      | $2000$     | 5          | ^               | ^                 | ^            |\n| $\\leq 200000$    | $\\leq 400000$    | $100000$   | 6          | ^               | ^                 | ^            |\n| $\\leq 1500$      | $=n-1$           | $2000$     | 7          | A chain         | Not guaranteed    | ^            |\n| ^                | ^                | ^          | 8          | ^               | ^                 | ^            |\n| ^                | ^                | ^          | 9          | ^               | ^                 | ^            |\n| $\\leq 200000$    | ^                | $100000$   | 10         | A tree          | ^                 | ^            |\n| ^                | ^                | ^          | 11         | ^               | ^                 | Yes          |\n| ^                | $\\leq 400000$    | ^          | 12         | Not guaranteed  | ^                 | No           |\n| ^                | ^                | ^          | 13         | ^               | ^                 | ^            |\n| ^                | ^                | ^          | 14         | ^               | ^                 | ^            |\n| $\\leq 1500$      | $\\leq 4000$      | $2000$     | 15         | ^               | ^                 | Yes          |\n| ^                | ^                | ^          | 16         | ^               | ^                 | ^            |\n| $\\leq 200000$    | $\\leq 400000$    | $100000$   | 17         | ^               | ^                 | ^            |\n| ^                | ^                | ^          | 18         | ^               | ^                 | ^            |\n| ^                | ^                | $400000$   | 19         | ^               | ^                 | ^            |\n| ^                | ^                | ^          | 20         | ^               | ^                 | ^            |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2018] 归程", "background": null, "description": "本题的故事发生在魔力之都，在这里我们将为你介绍一些必要的设定。\n\n魔力之都可以抽象成一个 $n$ 个节点、$m$ 条边的无向连通图（节点的编号从 $1$ 至 $n$）。我们依次用 $l,a$ 描述一条边的**长度、海拔**。\n\n作为季风气候的代表城市，魔力之都时常有雨水相伴，因此道路积水总是不可避免的。由于整个城市的排水系统连通，因此**有积水的边一定是海拔相对最低的一些边**。我们用**水位线**来描述降雨的程度，它的意义是：所有海拔**不超过**水位线的边都是**有积水**的。\n\nYazid 是一名来自魔力之都的 OIer，刚参加完 ION2018 的他将踏上归程，回到他温暖的家。Yazid 的家恰好在魔力之都的 $1$ 号节点。对于接下来 $Q$ 天，每一天 Yazid 都会告诉你他的出发点 $v$，以及当天的水位线 $p$。\n\n每一天，Yazid 在出发点都拥有一辆车。这辆车由于一些故障不能经过有积水的边。Yazid 可以在任意节点下车，这样接下来他就可以步行经过有积水的边。但车会被留在他下车的节点并不会再被使用。\n需要特殊说明的是，第二天车会被重置，这意味着：\n\n- 车会在新的出发点被准备好。\n- Yazid 不能利用之前在某处停放的车。\n\nYazid 非常讨厌在雨天步行，因此他希望在完成回家这一目标的同时，最小化他**步行经过的边**的总长度。请你帮助 Yazid 进行计算。\n\n本题的部分测试点将强制在线，具体细节请见【输入格式】和【子任务】。", "inputFormat": "单个测试点中包含多组数据。输入的第一行为一个非负整数 $T$，表示数据的组数。\n\n接下来依次描述每组数据，对于每组数据：\n\n第一行 $2$ 个非负整数 $n,m$，分别表示节点数、边数。\n\n接下来 $m$ 行，每行 $4$ 个正整数 $u, v, l, a$，描述一条连接节点 $u, v$ 的、长度为 $l$、海拔为 $a$ 的边。\n在这里，我们保证 $1 \\leq u,v \\leq n$。\n\n接下来一行 $3$ 个非负数 $Q, K, S$，其中 $Q$ 表示总天数，$K \\in {0,1}$ 是一个会在下面被用到的系数，$S$ 表示的是可能的最高水位线。\n\n接下来 $Q$ 行依次描述每天的状况。每行 $2$ 个整数 $v_0, p_0$ 描述一天：\n\n- 这一天的出发节点为 $v = (v_0 + K \\times \\mathrm{lastans} - 1) \\bmod n + 1$。\n- 这一天的水位线为 $p = (p_0 + K \\times \\mathrm{lastans}) \\bmod (S + 1)$。\n\n其中 $\\mathrm{lastans}$ 表示上一天的答案（最小步行总路程）。特别地，我们规定第 $1$ 天时 $\\mathrm{lastans} = 0$。\n在这里，我们保证 $1 \\leq v_0 \\leq n$，$0 \\leq p_0 \\leq S$。\n\n对于输入中的每一行，如果该行包含多个数，则用单个空格将它们隔开。", "outputFormat": "依次输出各组数据的答案。对于每组数据：\n\n- 输出 $Q$ 行每行一个整数，依次表示每天的最小步行总路程。", "hint": "### 更多样例\n\n更多样例请在附加文件中下载。\n\n#### 样例 3\n\n见附加文件中的 `return3.in` 与 `return3.ans`。\n\n该样例满足海拔为一种，且不强制在线。\n\n#### 样例 4\n\n见附加文件中的 `return4.in` 与 `return4.ans`。\n\n该样例满足图形态为一条链，且强制在线。\n\n#### 样例 5\n\n见附加文件中的 `return5.in` 与 `return5.ans`。\n\n该样例满足不强制在线。\n\n### 样例 1 解释\n\n第一天没有降水，Yazid 可以坐车直接回到家中。\n\n第二天、第三天、第四天的积水情况相同，均为连接 1，2 号节点的边、连接 3，4 号点的边有积水。\n\n对于第二天，Yazid 从 2 号点出发坐车只能去往 3 号节点，对回家没有帮助。因此 Yazid 只能纯靠徒步回家。\n\n对于第三天，从 4 号节点出发的唯一一条边是有积水的，车也就变得无用了。Yazid 只能纯靠徒步回家。\n\n对于第四天，Yazid 可以坐车先到达 2 号节点，再步行回家。\n\n第五天所有的边都积水了，因此 Yazid 只能纯靠徒步回家。\n\n### 样例 2 解释\n\n本组数据强制在线。\n\n第一天的答案是 $0$，因此第二天的 $v=\\left( 5+0-1\\right)\\bmod 5+1=5$，$p=\\left(2+0\\right)\\bmod\\left(3+1\\right)=2$。\n\n第二天的答案是 $2$，因此第三天的 $v=\\left( 2+2-1\\right)\\bmod 5+1=4$，$p=\\left(0+2\\right)\\bmod\\left(3+1\\right)=2$。\n\n第三天的答案是 $3$，因此第四天的 $v=\\left( 4+3-1\\right)\\bmod 5+1=2$，$p=\\left(0+3\\right)\\bmod\\left(3+1\\right)=3$。\n\n### 数据范围与约定\n\n所有测试点均保证 $T\\leq 3$，所有测试点中的所有数据均满足如下限制：\n\n- $n\\leq 2\\times 10^5$，$m\\leq 4\\times 10^5$，$Q\\leq 4\\times 10^5$，$K\\in\\left\\{0,1\\right\\}$，$1\\leq S\\leq 10^9$。\n- 对于所有边：$l\\leq 10^4$，$a\\leq 10^9$。\n- 任意两点之间都直接或间接通过边相连。\n\n**为了方便你快速理解，我们在表格中使用了一些简单易懂的表述。在此，我们对这些内容作形式化的说明：**\n\n- 图形态：对于表格中该项为“一棵树”或“一条链”的测试点，保证 $m = n-1$。除此之外，这两类测试点分别满足如下限制：\n  - 一棵树：保证输入的图是一棵树，即保证边不会构成回路。\n  - 一条链：保证所有边满足 $u + 1 = v$。\n- 海拔：对于表格中该项为“一种”的测试点，保证对于所有边有 $a = 1$。\n- 强制在线：对于表格中该项为“是”的测试点，保证 $K = 1$；如果该项为“否”，则有 $K = 0$。\n- 对于所有测试点，如果上述对应项为“不保证”，则对该项内容不作任何保证。\n\n| $n$              | $m$              | $Q$        | 测试点 | 形态      | 海拔      | 强制在线 |\n|------------------|------------------|------------|--------|-----------|-----------|----------|\n| $\\leq 1$         | $\\leq 0$         | $0$        | 1      | 不保证    | 一种      | 否        |\n| $\\leq 6$         | $\\leq 10$        | $10$       | 2      | ^         | ^         | ^         |\n| $\\leq 50$        | $\\leq 150$       | $100$      | 3      | ^         | ^         | ^         |\n| $\\leq 100$       | $\\leq 300$       | $200$      | 4      | ^         | ^         | ^         |\n| $\\leq 1500$      | $\\leq 4000$      | $2000$     | 5      | ^         | ^         | ^         |\n| $\\leq 200000$    | $\\leq 400000$    | $100000$   | 6      | ^         | ^         | ^         |\n| $\\leq 1500$      | $=n-1$           | $2000$     | 7      | 一条链    | 不保证    | ^         |\n| ^                | ^                | ^          | 8      | ^         | ^         | ^         |\n| ^                | ^                | ^          | 9      | ^         | ^         | ^         |\n| $\\leq 200000$    | ^                | $100000$   | 10     | 一棵树    | ^         | ^         |\n| ^                | ^                | ^          | 11     | ^         | ^         | 是        |\n| ^                | $\\leq 400000$    | ^          | 12     | 不保证    | ^         | 否        |\n| ^                | ^                | ^          | 13     | ^         | ^         | ^         |\n| ^                | ^                | ^          | 14     | ^         | ^         | ^         |\n| $\\leq 1500$      | $\\leq 4000$      | $2000$     | 15     | ^         | ^         | 是        |\n| ^                | ^                | ^          | 16     | ^         | ^         | ^         |\n| $\\leq 200000$    | $\\leq 400000$    | $100000$   | 17     | ^         | ^         | ^         |\n| ^                | ^                | ^          | 18     | ^         | ^         | ^         |\n| ^                | ^                | $400000$   | 19     | ^         | ^         | ^         |\n| ^                | ^                | ^          | 20     | ^         | ^         | ^         |", "locale": "zh-CN"}}}
{"pid": "P4769", "type": "P", "difficulty": 7, "samples": [["1\n3\n1 3 2", "3"], ["1\n4\n1 4 2 3", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "树状数组", "NOI", "O2优化", "Catalan 数", "栈"], "title": "[NOI2018] 冒泡排序", "background": "请注意，题目中存在 $n=0$ 的数据。", "description": "最近，小 S 对冒泡排序产生了浓厚的兴趣。为了问题简单，小 S 只研究对 **$1$ 到 $n$ 的排列**的冒泡排序。\n\n下面是对冒泡排序的算法描述。\n\n```plain\n输入：一个长度为 n 的排列 p[1...n]\n输出：p 排序后的结果。\nfor i = 1 to n do\n\tfor j = 1 to n - 1 do\n\t\tif(p[j] > p[j + 1])\n\t\t\t交换 p[j] 与 p[j + 1] 的值\n```\n\n冒泡排序的交换次数被定义为交换过程的执行次数。可以证明交换次数的一个下界是 $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$，其中 $p_i$ 是排列 $p$ 中第 $i$ 个位置的数字。如果你对证明感兴趣，可以看提示。\n\n小 S 开始专注于研究长度为 $n$ 的排列中，满足交换次数 $= \\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ 的排列（在后文中，为了方便，我们把所有这样的排列叫「好」的排列）。他进一步想，这样的排列到底多不多？它们分布的密不密集？\n\n小 S 想要对于一个给定的长度为 $n$ 的排列 $q$，计算字典序严格大于 $q$ 的“好”的排列个数。但是他不会做，于是求助于你，希望你帮他解决这个问题，考虑到答案可能会很大，因此只需输出答案对 $998244353$ 取模的结果。", "inputFormat": "输入第一行包含一个正整数 $T$，表示数据组数。\n\n对于每组数据，第一行有一个正整数 $n$，保证 $n \\leq 6 \\times 10^5$。\n\n接下来一行会输入 $n$ 个正整数，对应于题目描述中的 $q_i$，保证输入的是一个 $1$ 到 $n$ 的排列。", "outputFormat": "输出共 $T$ 行，每行一个整数。\n\n对于每组数据，输出一个整数，表示字典序严格大于 $q$ 的「好」的排列个数对 $998244353$ 取模的结果。", "hint": "### 更多样例\n\n更多样例请在附加文件中下载。\n\n#### 样例 3\n\n见附加文件中的 `inverse3.in` 与 `inverse3.ans`。\n\n### 样例 1 解释\n\n字典序比 $1 \\ 3 \\ 2$ 大的排列中，除了 $3 \\ 2 \\ 1$ 以外都是「好」的排列，故答案为 $3$。\n\n### 数据范围\n\n下面是对本题每个测试点的输入规模的说明。\n\n对于所有数据，均满足 $T = 5$（样例可能不满足）。\n\n记 $n_\\mathrm{max}$ 表示每组数据中 $n$ 的最大值，$\\sum n$ 表示所有数据的 $n$ 的和。\n\n::cute-table{tuack}\n\n| 测试点 | $n_\\mathrm{max} =$ | $\\sum n \\leq$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|\n| $1$ | $8$ | $5 \\ n_\\mathrm{max}$ | 无 |\n| $2$ | $9$ | ^ | ^ |\n| $3$ | $10$ | ^ | ^ |\n| $4$ | $12$ | ^ | ^ |\n| $5$ | $13$ | ^ | ^ |\n| $6$ | $14$ | ^ | ^ |\n| $7$ | $16$ | ^ | ^ |\n| $8$ | $16$ | ^ | ^ |\n| $9$ | $17$ | ^ | ^ |\n| $10$ | $18$ | ^ | ^ |\n| $11$ | $18$ | ^ | ^ |\n| $12$ | $122$ | $700$ | $\\forall i \\enspace q_i = i$ |\n| $13$ | $144$ | ^ | 无 |\n| $14$ | $166$ | ^ | ^ |\n| $15$ | $200$ | ^ | ^ |\n| $16$ | $233$ | ^ | ^ |\n| $17$ | $777$ | $4000$ | $\\forall i \\enspace q_i = i$ |\n| $18$ | $888$ | ^ | 无 |\n| $19$ | $933$ | ^ | ^ |\n| $20$ | $1000$ | ^ | ^ |\n| $21$ | $266666$ | $2000000$ | $\\forall i \\enspace q_i = i$ |\n| $22$ | $333333$ | ^ | 无 |\n| $23$ | $444444$ | ^ | ^ |\n| $24$ | $555555$ | ^ | ^ |\n| $25$ | $600000$ | ^ | ^ |\n\n### 提示\n\n下面是对交换次数下界是 $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ 的证明。\n\n排序本质上就是数字的移动，因此排序的交换次数应当可以用数字移动的总距离来描述。对于第 $i$ 个位置，假设在初始排列中，这个位置上的数字是 $p_i$，那么我们需要将这个数字移动到第 $p_i$ 个位置上，移动的距离是 $\\lvert i - p_i \\rvert$。从而移动的总距离就是 $\\sum_{i=1}^n \\lvert i - p_i \\rvert$，而冒泡排序每次会交换两个相邻的数字，每次交换可以使移动的总距离至多减少 $2$。因此 $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ 是冒泡排序的交换次数的下界。\n\n并不是所有的排列都达到了下界，比如在 $n = 3$ 的时候，考虑排列 $3 \\ 2 \\ 1$，这个排列进行冒泡排序以后的交换次数是 $3$，但是 $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ 只有 $2$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2018] Bubble Sort.", "background": "Please note that the testdata includes cases with $n = 0$.", "description": "Recently, Xiao S has become very interested in bubble sort. To simplify the problem, Xiao S only studies bubble sorting permutations of $1$ to $n$.\n\nBelow is the algorithm description of bubble sort.\n\n```plain\nInput: a permutation p[1...n] of length n\nOutput: the sorted result of p.\nfor i = 1 to n do\n\tfor j = 1 to n - 1 do\n\t\tif(p[j] > p[j + 1])\n\t\t\tswap the values of p[j] and p[j + 1]\n```\n\nThe number of swaps in bubble sort is defined as the number of times the swap operation is executed. It can be proven that a lower bound of the swap count is $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$, where $p_i$ is the number at position $i$ in the permutation $p$. If you are interested in the proof, you can read the hint.\n\nXiao S starts focusing on permutations of length $n$ that satisfy swap count $= \\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ (later, for convenience, we call all such permutations “good” permutations). He further wonders: are there many such permutations? Are they dense?\n\nFor a given permutation $q$ of length $n$, Xiao S wants to compute the number of “good” permutations that are strictly greater than $q$ in lexicographical order. However, he cannot do it, so he asks you for help. Since the answer may be very large, you only need to output the result modulo $998244353$.", "inputFormat": "The first line contains a positive integer $T$, indicating the number of test cases.\n\nFor each test case, the first line contains a positive integer $n$, with $n \\leq 6 \\times 10^5$.\n\nThe next line contains $n$ positive integers, corresponding to $q_i$ in the statement, and it is guaranteed that the input is a permutation of $1$ to $n$.", "outputFormat": "Output $T$ lines, each containing one integer.\n\nFor each test case, output one integer: the number of “good” permutations that are strictly greater than $q$ in lexicographical order, modulo $998244353$.", "hint": "### More Samples\n\nPlease download more samples from the attachment.\n\n#### Sample 3\n\nSee `inverse3.in` and `inverse3.ans` in the attachment.\n\n### Explanation for Sample 1\n\nAmong the permutations that are lexicographically greater than $1 \\ 3 \\ 2$, all of them are “good” except $3 \\ 2 \\ 1$, so the answer is $3$.\n\n### Constraints\n\nBelow is a description of the input size for each test point.\n\nFor all testdata, it holds that $T = 5$ (samples may not satisfy this).\n\nLet $n_\\mathrm{max}$ be the maximum $n$ among the test cases, and let $\\sum n$ be the sum of $n$ over all test cases.\n\n::cute-table{tuack}\n\n| Test Point | $n_\\mathrm{max} =$ | $\\sum n \\leq$ | Special Properties |\n|:-:|:-:|:-:|:-:|\n| $1$ | $8$ | $5 \\ n_\\mathrm{max}$ | None |\n| $2$ | $9$ | ^ | ^ |\n| $3$ | $10$ | ^ | ^ |\n| $4$ | $12$ | ^ | ^ |\n| $5$ | $13$ | ^ | ^ |\n| $6$ | $14$ | ^ | ^ |\n| $7$ | $16$ | ^ | ^ |\n| $8$ | $16$ | ^ | ^ |\n| $9$ | $17$ | ^ | ^ |\n| $10$ | $18$ | ^ | ^ |\n| $11$ | $18$ | ^ | ^ |\n| $12$ | $122$ | $700$ | $\\forall i \\enspace q_i = i$ |\n| $13$ | $144$ | ^ | None |\n| $14$ | $166$ | ^ | ^ |\n| $15$ | $200$ | ^ | ^ |\n| $16$ | $233$ | ^ | ^ |\n| $17$ | $777$ | $4000$ | $\\forall i \\enspace q_i = i$ |\n| $18$ | $888$ | ^ | None |\n| $19$ | $933$ | ^ | ^ |\n| $20$ | $1000$ | ^ | ^ |\n| $21$ | $266666$ | $2000000$ | $\\forall i \\enspace q_i = i$ |\n| $22$ | $333333$ | ^ | None |\n| $23$ | $444444$ | ^ | ^ |\n| $24$ | $555555$ | ^ | ^ |\n| $25$ | $600000$ | ^ | ^ |\n\n### Hint\n\nBelow is the proof that a lower bound of the swap count is $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$.\n\nSorting is essentially moving numbers, so the number of swaps in sorting can be described by the total distance that numbers move. For position $i$, suppose the number at this position in the initial permutation is $p_i$. Then we need to move this number to position $p_i$, and the moving distance is $\\lvert i - p_i \\rvert$. Therefore, the total moving distance is $\\sum_{i=1}^n \\lvert i - p_i \\rvert$. Each step of bubble sort swaps two adjacent numbers, and each swap can reduce the total moving distance by at most $2$. Hence, $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ is a lower bound of the swap count in bubble sort.\n\nNot all permutations reach this lower bound. For example, when $n = 3$, consider the permutation $3 \\ 2 \\ 1$. The number of swaps after bubble sorting this permutation is $3$, but $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ is only $2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2018] 冒泡排序", "background": "请注意，题目中存在 $n=0$ 的数据。", "description": "最近，小 S 对冒泡排序产生了浓厚的兴趣。为了问题简单，小 S 只研究对 **$1$ 到 $n$ 的排列**的冒泡排序。\n\n下面是对冒泡排序的算法描述。\n\n```plain\n输入：一个长度为 n 的排列 p[1...n]\n输出：p 排序后的结果。\nfor i = 1 to n do\n\tfor j = 1 to n - 1 do\n\t\tif(p[j] > p[j + 1])\n\t\t\t交换 p[j] 与 p[j + 1] 的值\n```\n\n冒泡排序的交换次数被定义为交换过程的执行次数。可以证明交换次数的一个下界是 $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$，其中 $p_i$ 是排列 $p$ 中第 $i$ 个位置的数字。如果你对证明感兴趣，可以看提示。\n\n小 S 开始专注于研究长度为 $n$ 的排列中，满足交换次数 $= \\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ 的排列（在后文中，为了方便，我们把所有这样的排列叫「好」的排列）。他进一步想，这样的排列到底多不多？它们分布的密不密集？\n\n小 S 想要对于一个给定的长度为 $n$ 的排列 $q$，计算字典序严格大于 $q$ 的“好”的排列个数。但是他不会做，于是求助于你，希望你帮他解决这个问题，考虑到答案可能会很大，因此只需输出答案对 $998244353$ 取模的结果。", "inputFormat": "输入第一行包含一个正整数 $T$，表示数据组数。\n\n对于每组数据，第一行有一个正整数 $n$，保证 $n \\leq 6 \\times 10^5$。\n\n接下来一行会输入 $n$ 个正整数，对应于题目描述中的 $q_i$，保证输入的是一个 $1$ 到 $n$ 的排列。", "outputFormat": "输出共 $T$ 行，每行一个整数。\n\n对于每组数据，输出一个整数，表示字典序严格大于 $q$ 的「好」的排列个数对 $998244353$ 取模的结果。", "hint": "### 更多样例\n\n更多样例请在附加文件中下载。\n\n#### 样例 3\n\n见附加文件中的 `inverse3.in` 与 `inverse3.ans`。\n\n### 样例 1 解释\n\n字典序比 $1 \\ 3 \\ 2$ 大的排列中，除了 $3 \\ 2 \\ 1$ 以外都是「好」的排列，故答案为 $3$。\n\n### 数据范围\n\n下面是对本题每个测试点的输入规模的说明。\n\n对于所有数据，均满足 $T = 5$（样例可能不满足）。\n\n记 $n_\\mathrm{max}$ 表示每组数据中 $n$ 的最大值，$\\sum n$ 表示所有数据的 $n$ 的和。\n\n::cute-table{tuack}\n\n| 测试点 | $n_\\mathrm{max} =$ | $\\sum n \\leq$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|\n| $1$ | $8$ | $5 \\ n_\\mathrm{max}$ | 无 |\n| $2$ | $9$ | ^ | ^ |\n| $3$ | $10$ | ^ | ^ |\n| $4$ | $12$ | ^ | ^ |\n| $5$ | $13$ | ^ | ^ |\n| $6$ | $14$ | ^ | ^ |\n| $7$ | $16$ | ^ | ^ |\n| $8$ | $16$ | ^ | ^ |\n| $9$ | $17$ | ^ | ^ |\n| $10$ | $18$ | ^ | ^ |\n| $11$ | $18$ | ^ | ^ |\n| $12$ | $122$ | $700$ | $\\forall i \\enspace q_i = i$ |\n| $13$ | $144$ | ^ | 无 |\n| $14$ | $166$ | ^ | ^ |\n| $15$ | $200$ | ^ | ^ |\n| $16$ | $233$ | ^ | ^ |\n| $17$ | $777$ | $4000$ | $\\forall i \\enspace q_i = i$ |\n| $18$ | $888$ | ^ | 无 |\n| $19$ | $933$ | ^ | ^ |\n| $20$ | $1000$ | ^ | ^ |\n| $21$ | $266666$ | $2000000$ | $\\forall i \\enspace q_i = i$ |\n| $22$ | $333333$ | ^ | 无 |\n| $23$ | $444444$ | ^ | ^ |\n| $24$ | $555555$ | ^ | ^ |\n| $25$ | $600000$ | ^ | ^ |\n\n### 提示\n\n下面是对交换次数下界是 $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ 的证明。\n\n排序本质上就是数字的移动，因此排序的交换次数应当可以用数字移动的总距离来描述。对于第 $i$ 个位置，假设在初始排列中，这个位置上的数字是 $p_i$，那么我们需要将这个数字移动到第 $p_i$ 个位置上，移动的距离是 $\\lvert i - p_i \\rvert$。从而移动的总距离就是 $\\sum_{i=1}^n \\lvert i - p_i \\rvert$，而冒泡排序每次会交换两个相邻的数字，每次交换可以使移动的总距离至多减少 $2$。因此 $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ 是冒泡排序的交换次数的下界。\n\n并不是所有的排列都达到了下界，比如在 $n = 3$ 的时候，考虑排列 $3 \\ 2 \\ 1$，这个排列进行冒泡排序以后的交换次数是 $3$，但是 $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ 只有 $2$。", "locale": "zh-CN"}}}
{"pid": "P4770", "type": "P", "difficulty": 7, "samples": [["scbamgepe\n3\nsmape 2 7\nsbape 3 8\nsgepe 1 9", "12\n10\n4"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "线段树", "NOI", "后缀自动机 SAM", "O2优化", "可持久化线段树", "后缀数组 SA", "线段树合并"], "title": "[NOI2018] 你的名字", "background": "实力强大的小 A 被选为了 ION2018 的出题人，现在他需要解决题目的命名问题。", "description": "小 A 被选为了 ION2018 的出题人，他精心准备了一道质量十分高的题目，且已经把除了题目命名以外的工作都做好了。\n\n由于 ION 已经举办了很多届，所以在题目命名上也是有规定的，ION 命题手册规定：每年由命题委员会规定一个小写字母字符串，我们称之为那一年的命名串，要求每道题的名字必须是那一年的命名串的一个非空连续子串，且不能和前一年的任何一道题目的名字相同。\n\n由于一些特殊的原因，小 A 不知道 ION2017 每道题的名字，但是他通过一些特殊手段得到了 ION2017 的命名串，现在小 A 有 $Q$ 次询问：每次给定 ION2017 的命名串和 ION2018 的命名串，求有几种题目的命名，使得这个名字一定满足命题委员会的规定，即是 ION2018 的命名串的一个非空连续子串且一定不会和 ION2017 的任何一道题目的名字相同。\n\n由于一些特殊原因，所有询问给出的 ION2017 的命名串都是某个串的连续子串，详细可见输入格式。", "inputFormat": "第一行一个字符串 $S$ ，之后询问给出的 ION2017 的命名串都是 $S$ 的连续子串。\n第二行一个正整数 $Q$，表示询问次数。\n接下来 $Q$ 行，每行有一个字符串 $T$ 和两个正整数$l,r$，表示询问如果 ION2017 的命名串是 $S_{l\\ldots r}$，ION2018 的命名串是 $T$ 的话，有几种命名方式一定满足规定。", "outputFormat": "输出 $Q$ 行，第 $i$ 行一个非负整数表示第 $i$ 个询问的答案。", "hint": "### 更多样例\n\n更多样例请在附加文件中下载。\n\n#### 样例 2\n\n见附加文件中的 `name2.in` 与 `name2.ans`。\n\n### 数据范围\n\n::cute-table{tuack}\n\n|测试点|$\\vert S\\vert \\leq$　|$Q\\leq $　|$\\sum \\vert T\\vert \\leq $ |询问限制　|其他限制|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|$1$|$200$|$200$|$40000$|对于所有询问有 $l = 1, r=\\vert S\\vert$|$T\\leq 200$|\n|$2$|$1000$|^|^|^|^|\n|$3$|^|^|^|^|^|\n|$4$|^|^|$5 \\times 10^5$|^|无|\n|$5$|^|^|^|^|^|\n|$6$|$5 \\times 10^5$|$1$|^|^|^|\n|$7$|^|^|^|^|^|\n|$8$|$10^5$|$10^5$|$2 \\times 10^5$|^|^|\n|$9$|^|^|^|^|字符串随机|\n|$10$|$2 \\times 10^5$|^|$4 \\times 10^5$|^|无|\n|$11$|^|^|^|^|字符串随机|\n|$12$|$3 \\times 10^5$|^|$6 \\times 10^5$|^|无|\n|$13$|^|^|^|^|字符串随机|\n|$14$|$4 \\times 10^5$|^|$8 \\times 10^5$|^|无|\n|$15$|^|^|^|^|字符串随机|\n|$16$|$5 \\times 10^5$|^|$10^6$|^|无|\n|$17$|^|^|^|^|字符串随机|\n|$18$|$2 \\times 10^5$|^|^|无|无|\n|$19$|$3 \\times 10^5$|^|^|^|^|\n|$20$|$4 \\times 10^5$|^|^|^|^|\n|$21$|$5 \\times 10^5$|^|^|^|^|\n|$22$|^|^|^|^|^|\n|$23$|^|^|^|^|^|\n|$24$|^|^|^|^|^|\n|$25$|^|^|^|^|^|\n\n对于所有数据，保证 $1\\leq l \\leq r \\leq |S|$，$1\\leq |T|\\leq 5 \\times 10^5$\n\n感谢 @Wen_kr 提供的一组 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2018] Your Name", "background": "The very capable Little A was chosen as the problem setter for ION2018, and now he needs to solve the problem of naming the tasks.", "description": "Little A was chosen as the problem setter for ION2018. He carefully prepared a very high-quality problem, and has already finished all the work except naming the problem.\n\nSince ION has been held for many years, there are also rules for naming problems. The ION problem-setting manual states: every year, the problem committee specifies a lowercase-letter string, which we call that year's naming string. The name of each problem must be a non-empty contiguous substring of that year's naming string, and it must not be the same as the name of any problem in the previous year.\n\nFor some special reasons, Little A does not know the names of each problem in ION2017, but through some special means he obtained the ION2017 naming string. Now Little A has $Q$ queries: each time, given the ION2017 naming string and the ION2018 naming string, find how many possible problem names are guaranteed to satisfy the committee's rules, that is, the name is a non-empty contiguous substring of the ION2018 naming string and is guaranteed not to be the same as the name of any problem in ION2017.\n\nFor some special reasons, in all queries, the given ION2017 naming strings are contiguous substrings of some string. See the input format for details.", "inputFormat": "The first line contains a string $S$. In the queries below, the given ION2017 naming string is always a contiguous substring of $S$.\nThe second line contains a positive integer $Q$, indicating the number of queries.\nThe next $Q$ lines each contain a string $T$ and two positive integers $l, r$, meaning: if the ION2017 naming string is $S_{l\\ldots r}$ and the ION2018 naming string is $T$, then how many naming choices are guaranteed to satisfy the rules.", "outputFormat": "Output $Q$ lines. The $i$-th line contains a non-negative integer, representing the answer to the $i$-th query.", "hint": "### More Samples\n\nPlease download more samples from the additional files.\n\n#### Sample 2\n\nSee `name2.in` and `name2.ans` in the additional files.\n\n### Constraints\n\n::cute-table{tuack}\n\n|Test Point|$\\vert S\\vert \\leq$　|$Q\\leq $　|$\\sum \\vert T\\vert \\leq $ |Query Restrictions　|Other Restrictions|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|$1$|$200$|$200$|$40000$|For all queries, $l = 1, r=\\vert S\\vert$|$T\\leq 200$|\n|$2$|$1000$|^|^|^|^|\n|$3$|^|^|^|^|^|\n|$4$|^|^|$5 \\times 10^5$|^|None|\n|$5$|^|^|^|^|^|\n|$6$|$5 \\times 10^5$|$1$|^|^|^|\n|$7$|^|^|^|^|^|\n|$8$|$10^5$|$10^5$|$2 \\times 10^5$|^|^|\n|$9$|^|^|^|^|Random strings|\n|$10$|$2 \\times 10^5$|^|$4 \\times 10^5$|^|None|\n|$11$|^|^|^|^|Random strings|\n|$12$|$3 \\times 10^5$|^|$6 \\times 10^5$|^|None|\n|$13$|^|^|^|^|Random strings|\n|$14$|$4 \\times 10^5$|^|$8 \\times 10^5$|^|None|\n|$15$|^|^|^|^|Random strings|\n|$16$|$5 \\times 10^5$|^|$10^6$|^|None|\n|$17$|^|^|^|^|Random strings|\n|$18$|$2 \\times 10^5$|^|^|None|None|\n|$19$|$3 \\times 10^5$|^|^|^|^|\n|$20$|$4 \\times 10^5$|^|^|^|^|\n|$21$|$5 \\times 10^5$|^|^|^|^|\n|$22$|^|^|^|^|^|\n|$23$|^|^|^|^|^|\n|$24$|^|^|^|^|^|\n|$25$|^|^|^|^|^|\n\nFor all data, it is guaranteed that $1\\leq l \\leq r \\leq |S|$, $1\\leq |T|\\leq 5 \\times 10^5$.\n\nThanks to @Wen_kr for providing a set of hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2018] 你的名字", "background": "实力强大的小 A 被选为了 ION2018 的出题人，现在他需要解决题目的命名问题。", "description": "小 A 被选为了 ION2018 的出题人，他精心准备了一道质量十分高的题目，且已经把除了题目命名以外的工作都做好了。\n\n由于 ION 已经举办了很多届，所以在题目命名上也是有规定的，ION 命题手册规定：每年由命题委员会规定一个小写字母字符串，我们称之为那一年的命名串，要求每道题的名字必须是那一年的命名串的一个非空连续子串，且不能和前一年的任何一道题目的名字相同。\n\n由于一些特殊的原因，小 A 不知道 ION2017 每道题的名字，但是他通过一些特殊手段得到了 ION2017 的命名串，现在小 A 有 $Q$ 次询问：每次给定 ION2017 的命名串和 ION2018 的命名串，求有几种题目的命名，使得这个名字一定满足命题委员会的规定，即是 ION2018 的命名串的一个非空连续子串且一定不会和 ION2017 的任何一道题目的名字相同。\n\n由于一些特殊原因，所有询问给出的 ION2017 的命名串都是某个串的连续子串，详细可见输入格式。", "inputFormat": "第一行一个字符串 $S$ ，之后询问给出的 ION2017 的命名串都是 $S$ 的连续子串。\n第二行一个正整数 $Q$，表示询问次数。\n接下来 $Q$ 行，每行有一个字符串 $T$ 和两个正整数$l,r$，表示询问如果 ION2017 的命名串是 $S_{l\\ldots r}$，ION2018 的命名串是 $T$ 的话，有几种命名方式一定满足规定。", "outputFormat": "输出 $Q$ 行，第 $i$ 行一个非负整数表示第 $i$ 个询问的答案。", "hint": "### 更多样例\n\n更多样例请在附加文件中下载。\n\n#### 样例 2\n\n见附加文件中的 `name2.in` 与 `name2.ans`。\n\n### 数据范围\n\n::cute-table{tuack}\n\n|测试点|$\\vert S\\vert \\leq$　|$Q\\leq $　|$\\sum \\vert T\\vert \\leq $ |询问限制　|其他限制|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|$1$|$200$|$200$|$40000$|对于所有询问有 $l = 1, r=\\vert S\\vert$|$T\\leq 200$|\n|$2$|$1000$|^|^|^|^|\n|$3$|^|^|^|^|^|\n|$4$|^|^|$5 \\times 10^5$|^|无|\n|$5$|^|^|^|^|^|\n|$6$|$5 \\times 10^5$|$1$|^|^|^|\n|$7$|^|^|^|^|^|\n|$8$|$10^5$|$10^5$|$2 \\times 10^5$|^|^|\n|$9$|^|^|^|^|字符串随机|\n|$10$|$2 \\times 10^5$|^|$4 \\times 10^5$|^|无|\n|$11$|^|^|^|^|字符串随机|\n|$12$|$3 \\times 10^5$|^|$6 \\times 10^5$|^|无|\n|$13$|^|^|^|^|字符串随机|\n|$14$|$4 \\times 10^5$|^|$8 \\times 10^5$|^|无|\n|$15$|^|^|^|^|字符串随机|\n|$16$|$5 \\times 10^5$|^|$10^6$|^|无|\n|$17$|^|^|^|^|字符串随机|\n|$18$|$2 \\times 10^5$|^|^|无|无|\n|$19$|$3 \\times 10^5$|^|^|^|^|\n|$20$|$4 \\times 10^5$|^|^|^|^|\n|$21$|$5 \\times 10^5$|^|^|^|^|\n|$22$|^|^|^|^|^|\n|$23$|^|^|^|^|^|\n|$24$|^|^|^|^|^|\n|$25$|^|^|^|^|^|\n\n对于所有数据，保证 $1\\leq l \\leq r \\leq |S|$，$1\\leq |T|\\leq 5 \\times 10^5$\n\n感谢 @Wen_kr 提供的一组 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P4771", "type": "P", "difficulty": 2, "samples": [["5 5 5\n1 2 3 4 5\n2 3 4 5 1\n3 4 5 1 2\n4 5 1 2 3\n5 1 2 3 4\n1 2\n2 3\n3 4\n4 5\n5 1\n", "Pool Babingbaboom!\nPool Babingbaboom!\n1\n2\n0"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["二分", "枚举", "前缀和"], "title": "八百标兵奔北坡", "background": "baingbaboom 正在往北边跑！！！", "description": "现在在一张 $N*M$ 的地图上有 $K$ 只 babingbaboom ！！！对于一张地图上的点都有一个 $ h_{i,j} $ 来表示这个地方的高度。现在这些 babingbaboom 都想要跑到北边的一个山坡上。求出离每一个 babingbaboom 最近的靠北的山。\n\n补充定义：\n\n山：山的周围没有比它更高的地方（四连通）。\n\n在北边：令 Babingbaboom 的坐标为 $A(a,b)$，山的坐标为 $B(x,y)$，山在 Babingbaboom 的北边当且仅当 $dis_{A,B}=a-x$。\n\n切比雪夫距离：\n\n$A(x_1,y_1) B(x_2,y_2):dis_{A,B}=\\max(|x_1 - x_2|, |y_1 - y_2|)$", "inputFormat": "第 $1$ 行三个正整数 $N,M,K$。\n\n第 $3-N$ 行每行有 $M$ 个正整数 $h_{i,j}$。\n\n第 $K+3$ 行每行有两个正整数 $X_i,Y_i$，表示每一个 babingbaboom 的坐标。", "outputFormat": "共 $K$ 行。如果对于每一个 babingbaboom 存在这样的最近的山（切比雪夫距离），就输出这个 babingbaboom 到山的切比雪夫距离；否则输出“Pool Babingbaboom!”。", "hint": "保证 $ 1 \\leqslant  N,M \\leqslant 10^3$，$1 \\leqslant  K \\leqslant 10^5 $，$ 1 \\leqslant  h_{i,j} \\leqslant 10^9 $。\n\n数据有梯度！\n\n样例图片（星代表一个 Babingbaboom，红色代表一个山）：\n![](https://cdn.luogu.com.cn/upload/pic/22827.png)\n\n（竖的是 $x$，横的是 $y$。画的时候没注意，很抱歉。）", "locale": "zh-CN", "translations": {"en": {"title": "Eight Hundred Soldiers Rush to the Northern Slope", "background": "baingbaboom is running north!!!", "description": "Now on an $N*M$ map, there are $K$ babingbabooms!!! For each point on the map, there is a $h_{i,j}$ representing the height of that location. Now these babingbabooms all want to run to a mountain slope in the north. Find the nearest mountain to the north for each babingbaboom.\n\nAdditional definitions:\n\nMountain: a point whose surrounding area has no place higher than it (4-connected).\n\nIn the north: Let the babingbaboom's coordinate be $A(a,b)$ and the mountain's coordinate be $B(x,y)$. The mountain is to the north of the babingbaboom if and only if $dis_{A,B}=a-x$.\n\nChebyshev distance:\n\n$A(x_1,y_1) B(x_2,y_2):dis_{A,B}=\\max(|x_1 - x_2|, |y_1 - y_2|)$", "inputFormat": "Line $1$ contains three positive integers $N,M,K$.\n\nLines $2$ to $N+1$ each contain $M$ positive integers $h_{i,j}$.\n\nLines $N+2$ to $N+K+1$ each contain two positive integers $X_i,Y_i$, indicating the coordinate of each babingbaboom.", "outputFormat": "Output $K$ lines in total. If for a babingbaboom there exists such a nearest mountain (by Chebyshev distance), output the Chebyshev distance from this babingbaboom to that mountain. Otherwise, output \"Pool Babingbaboom!\".", "hint": "Constraints: $1 \\leqslant N,M \\leqslant 10^3$, $1 \\leqslant K \\leqslant 10^5$, $1 \\leqslant h_{i,j} \\leqslant 10^9$.\n\nThe testdata has gradients.\n\nSample image (stars represent babingbabooms, red represents mountains):\n![](https://cdn.luogu.com.cn/upload/pic/22827.png)\n\n(The vertical axis is $x$, and the horizontal axis is $y$. I did not pay attention when drawing it, sorry.)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "八百标兵奔北坡", "background": "baingbaboom 正在往北边跑！！！", "description": "现在在一张 $N*M$ 的地图上有 $K$ 只 babingbaboom ！！！对于一张地图上的点都有一个 $ h_{i,j} $ 来表示这个地方的高度。现在这些 babingbaboom 都想要跑到北边的一个山坡上。求出离每一个 babingbaboom 最近的靠北的山。\n\n补充定义：\n\n山：山的周围没有比它更高的地方（四连通）。\n\n在北边：令 Babingbaboom 的坐标为 $A(a,b)$，山的坐标为 $B(x,y)$，山在 Babingbaboom 的北边当且仅当 $dis_{A,B}=a-x$。\n\n切比雪夫距离：\n\n$A(x_1,y_1) B(x_2,y_2):dis_{A,B}=\\max(|x_1 - x_2|, |y_1 - y_2|)$", "inputFormat": "第 $1$ 行三个正整数 $N,M,K$。\n\n第 $3-N$ 行每行有 $M$ 个正整数 $h_{i,j}$。\n\n第 $K+3$ 行每行有两个正整数 $X_i,Y_i$，表示每一个 babingbaboom 的坐标。", "outputFormat": "共 $K$ 行。如果对于每一个 babingbaboom 存在这样的最近的山（切比雪夫距离），就输出这个 babingbaboom 到山的切比雪夫距离；否则输出“Pool Babingbaboom!”。", "hint": "保证 $ 1 \\leqslant  N,M \\leqslant 10^3$，$1 \\leqslant  K \\leqslant 10^5 $，$ 1 \\leqslant  h_{i,j} \\leqslant 10^9 $。\n\n数据有梯度！\n\n样例图片（星代表一个 Babingbaboom，红色代表一个山）：\n![](https://cdn.luogu.com.cn/upload/pic/22827.png)\n\n（竖的是 $x$，横的是 $y$。画的时候没注意，很抱歉。）", "locale": "zh-CN"}}}
{"pid": "P4772", "type": "P", "difficulty": 5, "samples": [["5 5 3\nA.**C\n*....\nB*...\n.**..\n.....", "16\nACB"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["广度优先搜索 BFS", "最短路", "状压 DP"], "title": "灰化肥，会挥发", "background": "Farmer Justin 有一大堆会发黑和挥发的灰化肥呢！！！", "description": "在 Farmer Justin 的农场中有许多灰化肥，它们都堆积在A仓库里。为了方便施肥，Farmer Justin 需要修一些公路使得他能用拖拉机把这些灰化肥拉到其他仓库里。由于 Farmer Justin 及其懒惰，所以他只想一次拉完所有的灰化肥送到其他仓库里。但是灰化肥见光易挥发，所以 Farmer Justin 需要尽快把这些灰化肥拉完。现在告诉你Farmer Justin农场的构成地图，请你帮帮他计划一条**从 A 仓库出发**走完所有仓库的方案吧！由于Farmer Justin 非常的讨厌浪费时间，所以你只需要告诉他最短的距离和走过所有农场的顺序。（注意：拖拉机走的时候是四联通的。）", "inputFormat": "第一行三个正整数 $R,C,N$ 分别表示地图大小和仓库数量。\n下面给出一个 $R$ 行 $C$ 列的地图，其中 `.` 表示空地，可以修建公路；`*` 表示是 Farmer Justin 的农业区，不可以修建公路；用大写字母表示仓库编号。", "outputFormat": "\n第一行一个正整数表示最短的距离。\n\n第二行表示拖拉机走过仓库的方案（由仓库编号组成的字符串）。若有多种方案，输出字典序最小的方案。\n\n数据保证有解。", "hint": "对于全部数据，$ 1 \\leqslant R,C \\leqslant 500 $，$ 1 \\leqslant N \\leqslant 16 $。", "locale": "zh-CN", "translations": {"en": {"title": "Ash Fertilizer Turns Black, and It Evaporates.", "background": "Farmer Justin has a huge pile of ash fertilizer that can turn black and evaporate!!!", "description": "On Farmer Justin's farm, there is a lot of ash fertilizer, and all of it is stored in warehouse A. To make fertilizing easier, Farmer Justin needs to build some roads so that he can use a tractor to transport the ash fertilizer to the other warehouses. Since Farmer Justin is very lazy, he only wants to move all the ash fertilizer at once and deliver it to the other warehouses. However, ash fertilizer evaporates easily when exposed to light, so Farmer Justin needs to finish transporting it as quickly as possible.\n\nNow you are given the map of Farmer Justin's farm. Please help him plan a route that **starts from warehouse A** and visits all warehouses. Since Farmer Justin really hates wasting time, you only need to tell him the shortest total distance and the order in which he visits all warehouses. (Note: the tractor moves in 4 directions, i.e., 4-connected.)", "inputFormat": "The first line contains three positive integers $R, C, N$, representing the map size and the number of warehouses.  \nThen an $R$ by $C$ map is given, where `.` means empty land where roads can be built, `*` means Farmer Justin's farmland area where roads cannot be built, and capital letters represent warehouse labels.", "outputFormat": "The first line contains one positive integer, the shortest distance.\n\nThe second line describes the tractor's visiting plan for the warehouses (a string consisting of warehouse labels). If there are multiple plans, output the lexicographically smallest one.\n\nIt is guaranteed that a solution exists.", "hint": "For all testdata, $1 \\leqslant R, C \\leqslant 500$, $1 \\leqslant N \\leqslant 16$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "灰化肥，会挥发", "background": "Farmer Justin 有一大堆会发黑和挥发的灰化肥呢！！！", "description": "在 Farmer Justin 的农场中有许多灰化肥，它们都堆积在A仓库里。为了方便施肥，Farmer Justin 需要修一些公路使得他能用拖拉机把这些灰化肥拉到其他仓库里。由于 Farmer Justin 及其懒惰，所以他只想一次拉完所有的灰化肥送到其他仓库里。但是灰化肥见光易挥发，所以 Farmer Justin 需要尽快把这些灰化肥拉完。现在告诉你Farmer Justin农场的构成地图，请你帮帮他计划一条**从 A 仓库出发**走完所有仓库的方案吧！由于Farmer Justin 非常的讨厌浪费时间，所以你只需要告诉他最短的距离和走过所有农场的顺序。（注意：拖拉机走的时候是四联通的。）", "inputFormat": "第一行三个正整数 $R,C,N$ 分别表示地图大小和仓库数量。\n下面给出一个 $R$ 行 $C$ 列的地图，其中 `.` 表示空地，可以修建公路；`*` 表示是 Farmer Justin 的农业区，不可以修建公路；用大写字母表示仓库编号。", "outputFormat": "\n第一行一个正整数表示最短的距离。\n\n第二行表示拖拉机走过仓库的方案（由仓库编号组成的字符串）。若有多种方案，输出字典序最小的方案。\n\n数据保证有解。", "hint": "对于全部数据，$ 1 \\leqslant R,C \\leqslant 500 $，$ 1 \\leqslant N \\leqslant 16 $。", "locale": "zh-CN"}}}
{"pid": "P4773", "type": "P", "difficulty": 5, "samples": [["1 1", "499122454"], ["1 2", "45"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["数学", "高精度", "最大公约数 gcd"], "title": "红鲤鱼与绿鲤鱼", "background": "JerryC 家里除了有驴之外，还有一个有着红鲤鱼和绿鲤鱼的鱼缸。", "description": "在 JerryC 家里的鱼缸里，有一些红鲤鱼和绿鲤鱼（鱼缸里没有驴！）。这天晚上 23:05 的时候，JerryC 闲的无聊，于是打开了某神秘 OJ 开始爆肝。\n\n作为一名膜$%$法师，JerryC 可以通过预言术得知下一次自己的提交是对是错。当然，预言术使用的工具就是眼前的鱼缸了。每当 JerryC 的预言术指示一只红鲤鱼的时候，就说明这次提交会 WA，同时会增加 5min 的罚时；如果是绿鲤鱼就会 AC。(当然，由于 JerryC 的膜$%$法，JerryC 是不会番薯田扛把子的。JerryC 第一次提交会在第 5min，而且不幸的是 JerryC 的膜$%$法有 5min 的冷却时间）并且 JerryC 在每一次预言后就会把预言到的那一只鲤鱼取出来，以便比赛完毕后给鱼缸换水（~~给自己换换口味~~）。\n\n现在 JerryC 告诉你他家里有多少条红鲤鱼和绿鲤鱼，请你告诉他他这场比赛的罚时期望是多少。当然，JerryC 会按顺序做题，并且罚时只会记录 AC 的题目，算罚时的时候需要加上 AC 的时间，并且所有的鲤鱼用完后还会提交一次，而且这一次 JerryC 并不会预测并且必定 AC。\n\n由于 JerryC 脾气比较犟，所以他不会因为 WA 掉一道题而换一道题去做，除非 AC。", "inputFormat": "一行，两个正整数 $A, B$，分别表示有多少条红鲤鱼和绿鲤鱼。", "outputFormat": "一行，一个正整数，表示罚时的期望模 $998244853$ 的结果。如果结果除不尽时，若结果可以表示为 $\\frac{P}{Q}$，则需要输出 $P \\times Q^{mod-2} \\bmod mod$  。", "hint": "### 样例解释 \\#1\n\n有两种可能： \n1. AC WA AC；\n2. WA AC AC。\n \n第一个情况的罚时是 $5$（第 5 分钟 AC）$\\!+ \\ 5$（WA 一次罚时 5 分钟）$\\!+ \\ 15$（第 15 分钟 AC）$= 25$。 \n\n第二个情况的罚时是 $5$（WA 一次罚时 5 分钟）$\\!+ \\ 10$（第 10 分钟 AC）$\\!+ \\ 15$（第 15 分钟 AC ）$=30$。 \n\n所以期望罚时为 $ \\frac{25+30}{2} = \\frac{55}{2} $ 需要对分数取模，所以最后答案为 $499122454$。\n\n### 数据规模与约定\n\n- 10 pts：$1 \\le A + B \\le 5$；\n- 30 pts：$1 \\le A + B \\le 20$；\n- 70 pts：$1 \\le A + B \\le 3000$；\n- 100 pts：$1 \\le A \\le 10 ^ {18}$，$1 \\le B \\le 10 ^ 7$。\n\n最后六个点时限 2400ms，其他点时限 400ms。\n\n$$\\color{white}{\\text{温馨提示:注意模数}}$$", "locale": "zh-CN", "translations": {"en": {"title": "Red Carp and Green Carp", "background": "In JerryC’s home, besides a donkey, there is also a fish tank with red carp and green carp.", "description": "In JerryC’s fish tank, there are some red carp and green carp (there is no donkey in the fish tank!). At 23:05 tonight, JerryC was bored, so he opened some mysterious OJ and started grinding hard.\n\nAs a “mo$%$” mage, JerryC can know in advance whether his next submission will be correct or wrong through divination. Of course, the tool for divination is the fish tank in front of him. Whenever JerryC’s divination points to a red carp, it means this submission will be WA, and 5 min of penalty time will be added; if it points to a green carp, it will be AC. (Of course, due to JerryC’s “mo$%$” magic, JerryC will not be “番薯田扛把子” (fan shu tian kang ba zi). JerryC’s first submission will be at the 5th min, and unfortunately, JerryC’s “mo$%$” magic has a 5 min cooldown.) Also, after each divination, JerryC will take the carp he divined out of the tank, so that after the contest he can change the water (~~change his taste~~).\n\nNow JerryC tells you how many red carp and green carp he has at home. Please tell him the expected total penalty time for this contest. JerryC will solve problems in order, and penalty time is recorded only for problems that are AC. When calculating penalty time, you need to add the time of AC, and after all carp are used up, he will submit once more. For this last submission, JerryC will not do any prediction and it will definitely be AC.\n\nBecause JerryC is quite stubborn, he will not switch to another problem after getting WA on a problem, unless he gets AC.", "inputFormat": "One line with two positive integers $A, B$, representing the number of red carp and green carp, respectively.", "outputFormat": "One line with one positive integer, representing the expected penalty time modulo $998244853$. If the result is not an integer, and it can be written as $\\frac{P}{Q}$, then output $P \\times Q^{mod-2} \\bmod mod$.", "hint": "### Sample Explanation \\#1\n\nThere are two possibilities:  \n1. AC WA AC;  \n2. WA AC AC.\n\nIn the first case, the penalty time is $5$ (AC at the 5th minute) $\\!+ \\ 5$ (one WA adds 5 minutes of penalty) $\\!+ \\ 15$ (AC at the 15th minute) $= 25$.\n\nIn the second case, the penalty time is $5$ (one WA adds 5 minutes of penalty) $\\!+ \\ 10$ (AC at the 10th minute) $\\!+ \\ 15$ (AC at the 15th minute) $= 30$.\n\nSo the expected penalty time is $ \\frac{25+30}{2} = \\frac{55}{2} $. We need to take the fraction modulo, so the final answer is $499122454$.\n\n### Constraints\n\n- 10 pts: $1 \\le A + B \\le 5$;\n- 30 pts: $1 \\le A + B \\le 20$;\n- 70 pts: $1 \\le A + B \\le 3000$;\n- 100 pts: $1 \\le A \\le 10 ^ {18}$, $1 \\le B \\le 10 ^ 7$.\n\nThe time limit for the last six subtasks is 2400 ms, and for the other subtasks it is 400 ms.\n\n$$\\color{white}{\\text{Warm reminder: pay attention to the modulus}}$$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "红鲤鱼与绿鲤鱼", "background": "JerryC 家里除了有驴之外，还有一个有着红鲤鱼和绿鲤鱼的鱼缸。", "description": "在 JerryC 家里的鱼缸里，有一些红鲤鱼和绿鲤鱼（鱼缸里没有驴！）。这天晚上 23:05 的时候，JerryC 闲的无聊，于是打开了某神秘 OJ 开始爆肝。\n\n作为一名膜$%$法师，JerryC 可以通过预言术得知下一次自己的提交是对是错。当然，预言术使用的工具就是眼前的鱼缸了。每当 JerryC 的预言术指示一只红鲤鱼的时候，就说明这次提交会 WA，同时会增加 5min 的罚时；如果是绿鲤鱼就会 AC。(当然，由于 JerryC 的膜$%$法，JerryC 是不会番薯田扛把子的。JerryC 第一次提交会在第 5min，而且不幸的是 JerryC 的膜$%$法有 5min 的冷却时间）并且 JerryC 在每一次预言后就会把预言到的那一只鲤鱼取出来，以便比赛完毕后给鱼缸换水（~~给自己换换口味~~）。\n\n现在 JerryC 告诉你他家里有多少条红鲤鱼和绿鲤鱼，请你告诉他他这场比赛的罚时期望是多少。当然，JerryC 会按顺序做题，并且罚时只会记录 AC 的题目，算罚时的时候需要加上 AC 的时间，并且所有的鲤鱼用完后还会提交一次，而且这一次 JerryC 并不会预测并且必定 AC。\n\n由于 JerryC 脾气比较犟，所以他不会因为 WA 掉一道题而换一道题去做，除非 AC。", "inputFormat": "一行，两个正整数 $A, B$，分别表示有多少条红鲤鱼和绿鲤鱼。", "outputFormat": "一行，一个正整数，表示罚时的期望模 $998244853$ 的结果。如果结果除不尽时，若结果可以表示为 $\\frac{P}{Q}$，则需要输出 $P \\times Q^{mod-2} \\bmod mod$  。", "hint": "### 样例解释 \\#1\n\n有两种可能： \n1. AC WA AC；\n2. WA AC AC。\n \n第一个情况的罚时是 $5$（第 5 分钟 AC）$\\!+ \\ 5$（WA 一次罚时 5 分钟）$\\!+ \\ 15$（第 15 分钟 AC）$= 25$。 \n\n第二个情况的罚时是 $5$（WA 一次罚时 5 分钟）$\\!+ \\ 10$（第 10 分钟 AC）$\\!+ \\ 15$（第 15 分钟 AC ）$=30$。 \n\n所以期望罚时为 $ \\frac{25+30}{2} = \\frac{55}{2} $ 需要对分数取模，所以最后答案为 $499122454$。\n\n### 数据规模与约定\n\n- 10 pts：$1 \\le A + B \\le 5$；\n- 30 pts：$1 \\le A + B \\le 20$；\n- 70 pts：$1 \\le A + B \\le 3000$；\n- 100 pts：$1 \\le A \\le 10 ^ {18}$，$1 \\le B \\le 10 ^ 7$。\n\n最后六个点时限 2400ms，其他点时限 400ms。\n\n$$\\color{white}{\\text{温馨提示:注意模数}}$$", "locale": "zh-CN"}}}
{"pid": "P4774", "type": "P", "difficulty": 6, "samples": [["2\n3 3\n3 5 7\n4 6 10\n7 3 9\n1 9 1000\n3 2\n3 5 6\n4 8 7\n1 1 1\n1 1", "59\n-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "NOI", "O2优化", "不定方程", "中国剩余定理 CRT", "逆元"], "title": "[NOI2018] 屠龙勇士", "background": "", "description": "小 D 最近在网上发现了一款小游戏。游戏的规则如下：\n\n- 游戏的目标是按照编号 $1 \\rightarrow n$ 顺序杀掉 $n$ 条巨龙，每条巨龙拥有一个初始的生命值 $a_i$ 。同时每条巨龙拥有恢复能力，当其使用恢复能力时，它的生命值就会每次增加 $p_i$ ，直至生命值非负。只有在攻击结束后且当生命值 **恰好** 为 $0$ 时它才会死去。\n- 游戏开始时玩家拥有 $m$ 把攻击力已知的剑，每次面对巨龙时，玩家只能选择一把剑，当杀死巨龙后这把剑就会消失，但作为奖励，玩家会获得全新的一把剑。\n\n小 D 觉得这款游戏十分无聊，但最快通关的玩家可以获得 ION2018 的参赛资格，于是小 D 决定写一个笨笨的机器人帮她通关这款游戏，她写的机器人遵循以下规则：\n\n- 每次面对巨龙时，机器人会选择当前拥有的，攻击力不高于巨龙初始生命值中攻击力最大的一把剑作为武器。如果没有这样的剑，则选择 **攻击力最低** 的一把剑作为武器。\n- 机器人面对每条巨龙，它都会使用上一步中选择的剑攻击巨龙固定的 $x$ 次，使巨龙的生命值减少 $x \\times ATK$ 。\n- 之后，巨龙会不断使用恢复能力，每次恢复 $p_i$ 生命值。若在使用恢复能力前或某一次恢复后其生命值为 $0$ ，则巨龙死亡，玩家通过本关。\n\n那么显然机器人的攻击次数是决定能否最快通关这款游戏的关键。小 D 现在得知了每条巨龙的所有属性，她想考考你，你知道应该将机器人的攻击次数 $x$ 设置为多少，才能用最少的攻击次数通关游戏吗？\n\n当然如果无论设置成多少都无法通关游戏，输出 $-1$ 即可。", "inputFormat": "第一行一个整数 $T$，代表数据组数。\n\n接下来 $T$ 组数据，每组数据包含 $5$ 行。\n\n- 每组数据的第一行包含两个整数，$n$ 和 $m$ ，代表巨龙的数量和初始剑的数量；\n- 接下来一行包含 $n$ 个正整数，第 $i$ 个数表示第 $i$ 条巨龙的初始生命值 $a_i$；\n- 接下来一行包含 $n$ 个正整数，第 $i$ 个数表示第 $i$ 条巨龙的恢复能力 $p_i$；\n- 接下来一行包含 $n$ 个正整数，第 $i$ 个数表示杀死第 $i$ 条巨龙后奖励的剑的攻击力；\n- 接下来一行包含 $m$ 个正整数，表示初始拥有的 $m$ 把剑的攻击力。", "outputFormat": "一共 $T$ 行。\n\n第 $i$ 行一个整数，表示对于第 $i$ 组数据，能够使得机器人通关游戏的最小攻击次数 $x$ ，如果答案不存在，输出 $-1$。", "hint": "### 更多样例\n\n更多样例请在附加文件中下载。\n\n### 样例 2\n\n见附加文件中的 `dragon2.in` 与 `dragon2.ans`。\n\n### 样例 1 解释\n\n第一组数据：\n- 开始时拥有的剑的攻击力为 $\\{1,9,1000\\}$，第 $1$ 条龙生命值为 $3$，故选择攻击力为 $1$ 的剑，攻击 $59$ 次，造成 $59$ 点伤害，此时龙的生命值为 $-56$，恢复 14 次后生命值恰好为 $0$，死亡。\n\n- 攻击力为 $1$ 的剑消失，拾取一把攻击力为 $7$ 的剑，此时拥有的剑的攻击力为\n$\\{7,9,1000\\}$，第 2 条龙生命值为 $5$，故选择攻击力为 $7$ 的剑，攻击 $59$ 次，造成 $413$ 点伤害，此时龙的生命值为 $-408$，恢复 $68$ 次后生命值恰好为 $0$，死亡。\n\n- 此时拥有的剑的攻击力为 $\\{3,9,1000\\}$，第 $3$ 条龙生命值为 $7$，故选择攻击力为 $3$ 的剑，攻击 $59$ 次，造成 $177$ 点伤害，此时龙的生命值为 $-170$，恢复 $17$ 次后生命值恰好为 0，死亡。\n\n- 没有比 $59$ 次更少的通关方法，故答案为 $59$。\n\n第二组数据：\n不存在既能杀死第一条龙又能杀死第二条龙的方法，故无法通关，输出 $-1$。\n\n### 子任务\n\n::cute-table{tuack}\n\n测试点编号 | $n$ | $m$ | $p_i$ | $a_i$ | 攻击力 | 其他限制\n:-:|:-:|:-:|:-:|:-:|:-:|:-:\n1|$\\le 10^5$|$=1$|$=1$|$\\le 10^5$|$=1$| 无\n2|^|^|^|^|^| ^\n3|^|^|^|^|$\\le 10^5$| ^\n4|^|^|^|^|^| ^\n5|$\\le 10^3$|$\\le 10^3$|$\\le 10^5$|^|^| 特性 1、特性 2\n6|^|^|^|^|^| ^\n7|^|^|^|^|^| ^\n8|$=1$|$=1$|$\\le 10^8$|$\\le 10^8$|$\\le 10^6$| 特性 1\n9|^|^|^|^|^| ^\n10|^|^|^|^|^| ^\n11|^|^|^|^|^| ^\n12|^|^|^|^|^| ^\n13|^|^|^|^|^| ^\n14|$=10^5$|$=10^5$|$=1$|^|^| 无特殊限制\n15|^|^|^|^|^| ^\n16|$\\le 10^5$|^| 所有 $p_i$ 是质数 |$\\le 10^{12}$|^| 特性 1\n17|^|^| ^ |^|^| ^\n18|^|^| 无特殊限制 | ^| ^ | ^\n19|^|^| ^ | ^| ^ | ^\n20|^|^| ^ | ^| ^ | ^\n\n特性 1 是指：对于任意的 $i$，$a_i \\le p_i$。\n\n特性 2 是指：$\\operatorname{lcm}(p_i) \\le 10^6$，即所有 $p_i$ 的 **最小公倍数** 不大于 $10^6$。\n\n对于所有的测试点，$T \\le 5$，所有武器的攻击力 $\\le 10^6$，所有 $p_i$ 的最小公倍数 $\\le 10^{12}$。\n\n保证 $ T, n, m $ 均为正整数。\n\n### 提示\n\n你所用到的中间结果可能很大，注意保存中间结果的变量类型。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2018] Dragon Slayer", "background": "", "description": "Xiao D recently found a mini game online. The rules are as follows:\n\n- The goal of the game is to kill $n$ dragons in order $1 \\rightarrow n$. Each dragon has an initial health value $a_i$. At the same time, each dragon has a recovery ability: when it uses recovery, its health increases by $p_i$ each time until its health becomes non-negative. The dragon will only die when the attack ends and its health is **exactly** $0$.\n- At the start of the game, the player has $m$ swords with known attack power. Each time facing a dragon, the player can only choose one sword. After killing the dragon, that sword disappears, but as a reward, the player obtains a brand-new sword.\n\nXiao D thinks this game is very boring, but the fastest player to clear it can get a qualification for ION2018, so Xiao D decides to write a simple robot to help her clear the game. Her robot follows these rules:\n\n- Each time it faces a dragon, the robot chooses, among the swords it currently has, the one with the maximum attack power that does not exceed the dragon’s initial health as its weapon. If there is no such sword, it chooses the sword with the **minimum attack power** as its weapon.\n- For each dragon, the robot uses the sword chosen in the previous step to attack the dragon a fixed $x$ times, reducing the dragon’s health by $x \\times ATK$.\n- Then, the dragon will keep using its recovery ability, recovering $p_i$ health each time. If before using recovery, or after some recovery, its health becomes $0$, then the dragon dies and the player clears this stage.\n\nSo obviously, the number of attacks is the key to whether the game can be cleared as fast as possible. Xiao D now knows all attributes of each dragon and wants to test you: what value should the robot’s attack count $x$ be set to, so that the game can be cleared with the minimum number of attacks?\n\nOf course, if the game cannot be cleared no matter what it is set to, output $-1$.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nThen there are $T$ test cases, each containing $5$ lines.\n\n- The first line of each test case contains two integers $n$ and $m$, representing the number of dragons and the number of initial swords;\n- The next line contains $n$ positive integers; the $i$-th number is the initial health $a_i$ of the $i$-th dragon;\n- The next line contains $n$ positive integers; the $i$-th number is the recovery value $p_i$ of the $i$-th dragon;\n- The next line contains $n$ positive integers; the $i$-th number is the attack power of the sword rewarded after killing the $i$-th dragon;\n- The next line contains $m$ positive integers, the attack powers of the $m$ initial swords.", "outputFormat": "Output $T$ lines in total.\n\nThe $i$-th line contains one integer, indicating for the $i$-th test case the minimum attack count $x$ that allows the robot to clear the game. If no such answer exists, output $-1$.", "hint": "### More Samples\n\nPlease download more samples in the attached file.\n\n### Sample 2\n\nSee `dragon2.in` and `dragon2.ans` in the attached file.\n\n### Explanation for Sample 1\n\nTest case 1:\n- The initial sword attack powers are $\\{1,9,1000\\}$. The health of dragon $1$ is $3$, so the sword with attack power $1$ is chosen. Attack $59$ times, dealing $59$ damage. The dragon’s health becomes $-56$. After recovering $14$ times, its health becomes exactly $0$, so it dies.\n\n- The sword with attack power $1$ disappears, and a sword with attack power $7$ is picked up. Now the sword attack powers are $\\{7,9,1000\\}$. The health of dragon $2$ is $5$, so the sword with attack power $7$ is chosen. Attack $59$ times, dealing $413$ damage. The dragon’s health becomes $-408$. After recovering $68$ times, its health becomes exactly $0$, so it dies.\n\n- Now the sword attack powers are $\\{3,9,1000\\}$. The health of dragon $3$ is $7$, so the sword with attack power $3$ is chosen. Attack $59$ times, dealing $177$ damage. The dragon’s health becomes $-170$. After recovering $17$ times, its health becomes exactly $0$, so it dies.\n\n- There is no way to clear the game with fewer than $59$ attacks, so the answer is $59$.\n\nTest case 2:\nThere is no method that can kill both the first dragon and the second dragon, so the game cannot be cleared. Output $-1$.\n\n### Subtasks\n\n::cute-table{tuack}\n\nTest Point ID | $n$ | $m$ | $p_i$ | $a_i$ | Attack Power | Other Restrictions\n:-:|:-:|:-:|:-:|:-:|:-:|:-:\n1|$\\le 10^5$|$=1$|$=1$|$\\le 10^5$|$=1$| None\n2|^|^|^|^|^| ^\n3|^|^|^|^|$\\le 10^5$| ^\n4|^|^|^|^|^| ^\n5|$\\le 10^3$|$\\le 10^3$|$\\le 10^5$|^|^| Property 1, Property 2\n6|^|^|^|^|^| ^\n7|^|^|^|^|^| ^\n8|$=1$|$=1$|$\\le 10^8$|$\\le 10^8$|$\\le 10^6$| Property 1\n9|^|^|^|^|^| ^\n10|^|^|^|^|^| ^\n11|^|^|^|^|^| ^\n12|^|^|^|^|^| ^\n13|^|^|^|^|^| ^\n14|$=10^5$|$=10^5$|$=1$|^|^| No special restrictions\n15|^|^|^|^|^| ^\n16|$\\le 10^5$|^| All $p_i$ are primes |$\\le 10^{12}$|^| Property 1\n17|^|^| ^ |^|^| ^\n18|^|^| No special restrictions | ^| ^ | ^\n19|^|^| ^ | ^| ^ | ^\n20|^|^| ^ | ^| ^ | ^\n\nProperty 1 means: for any $i$, $a_i \\le p_i$.\n\nProperty 2 means: $\\operatorname{lcm}(p_i) \\le 10^6$, i.e. the **least common multiple** of all $p_i$ is at most $10^6$.\n\nFor all test points, $T \\le 5$, all weapon attack powers $\\le 10^6$, and the least common multiple of all $p_i$ is $\\le 10^{12}$.\n\nIt is guaranteed that $T$, $n$, and $m$ are all positive integers.\n\n### Notes\n\nThe intermediate results you use may be very large, so pay attention to the variable types used to store them.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2018] 屠龙勇士", "background": "", "description": "小 D 最近在网上发现了一款小游戏。游戏的规则如下：\n\n- 游戏的目标是按照编号 $1 \\rightarrow n$ 顺序杀掉 $n$ 条巨龙，每条巨龙拥有一个初始的生命值 $a_i$ 。同时每条巨龙拥有恢复能力，当其使用恢复能力时，它的生命值就会每次增加 $p_i$ ，直至生命值非负。只有在攻击结束后且当生命值 **恰好** 为 $0$ 时它才会死去。\n- 游戏开始时玩家拥有 $m$ 把攻击力已知的剑，每次面对巨龙时，玩家只能选择一把剑，当杀死巨龙后这把剑就会消失，但作为奖励，玩家会获得全新的一把剑。\n\n小 D 觉得这款游戏十分无聊，但最快通关的玩家可以获得 ION2018 的参赛资格，于是小 D 决定写一个笨笨的机器人帮她通关这款游戏，她写的机器人遵循以下规则：\n\n- 每次面对巨龙时，机器人会选择当前拥有的，攻击力不高于巨龙初始生命值中攻击力最大的一把剑作为武器。如果没有这样的剑，则选择 **攻击力最低** 的一把剑作为武器。\n- 机器人面对每条巨龙，它都会使用上一步中选择的剑攻击巨龙固定的 $x$ 次，使巨龙的生命值减少 $x \\times ATK$ 。\n- 之后，巨龙会不断使用恢复能力，每次恢复 $p_i$ 生命值。若在使用恢复能力前或某一次恢复后其生命值为 $0$ ，则巨龙死亡，玩家通过本关。\n\n那么显然机器人的攻击次数是决定能否最快通关这款游戏的关键。小 D 现在得知了每条巨龙的所有属性，她想考考你，你知道应该将机器人的攻击次数 $x$ 设置为多少，才能用最少的攻击次数通关游戏吗？\n\n当然如果无论设置成多少都无法通关游戏，输出 $-1$ 即可。", "inputFormat": "第一行一个整数 $T$，代表数据组数。\n\n接下来 $T$ 组数据，每组数据包含 $5$ 行。\n\n- 每组数据的第一行包含两个整数，$n$ 和 $m$ ，代表巨龙的数量和初始剑的数量；\n- 接下来一行包含 $n$ 个正整数，第 $i$ 个数表示第 $i$ 条巨龙的初始生命值 $a_i$；\n- 接下来一行包含 $n$ 个正整数，第 $i$ 个数表示第 $i$ 条巨龙的恢复能力 $p_i$；\n- 接下来一行包含 $n$ 个正整数，第 $i$ 个数表示杀死第 $i$ 条巨龙后奖励的剑的攻击力；\n- 接下来一行包含 $m$ 个正整数，表示初始拥有的 $m$ 把剑的攻击力。", "outputFormat": "一共 $T$ 行。\n\n第 $i$ 行一个整数，表示对于第 $i$ 组数据，能够使得机器人通关游戏的最小攻击次数 $x$ ，如果答案不存在，输出 $-1$。", "hint": "### 更多样例\n\n更多样例请在附加文件中下载。\n\n### 样例 2\n\n见附加文件中的 `dragon2.in` 与 `dragon2.ans`。\n\n### 样例 1 解释\n\n第一组数据：\n- 开始时拥有的剑的攻击力为 $\\{1,9,1000\\}$，第 $1$ 条龙生命值为 $3$，故选择攻击力为 $1$ 的剑，攻击 $59$ 次，造成 $59$ 点伤害，此时龙的生命值为 $-56$，恢复 14 次后生命值恰好为 $0$，死亡。\n\n- 攻击力为 $1$ 的剑消失，拾取一把攻击力为 $7$ 的剑，此时拥有的剑的攻击力为\n$\\{7,9,1000\\}$，第 2 条龙生命值为 $5$，故选择攻击力为 $7$ 的剑，攻击 $59$ 次，造成 $413$ 点伤害，此时龙的生命值为 $-408$，恢复 $68$ 次后生命值恰好为 $0$，死亡。\n\n- 此时拥有的剑的攻击力为 $\\{3,9,1000\\}$，第 $3$ 条龙生命值为 $7$，故选择攻击力为 $3$ 的剑，攻击 $59$ 次，造成 $177$ 点伤害，此时龙的生命值为 $-170$，恢复 $17$ 次后生命值恰好为 0，死亡。\n\n- 没有比 $59$ 次更少的通关方法，故答案为 $59$。\n\n第二组数据：\n不存在既能杀死第一条龙又能杀死第二条龙的方法，故无法通关，输出 $-1$。\n\n### 子任务\n\n::cute-table{tuack}\n\n测试点编号 | $n$ | $m$ | $p_i$ | $a_i$ | 攻击力 | 其他限制\n:-:|:-:|:-:|:-:|:-:|:-:|:-:\n1|$\\le 10^5$|$=1$|$=1$|$\\le 10^5$|$=1$| 无\n2|^|^|^|^|^| ^\n3|^|^|^|^|$\\le 10^5$| ^\n4|^|^|^|^|^| ^\n5|$\\le 10^3$|$\\le 10^3$|$\\le 10^5$|^|^| 特性 1、特性 2\n6|^|^|^|^|^| ^\n7|^|^|^|^|^| ^\n8|$=1$|$=1$|$\\le 10^8$|$\\le 10^8$|$\\le 10^6$| 特性 1\n9|^|^|^|^|^| ^\n10|^|^|^|^|^| ^\n11|^|^|^|^|^| ^\n12|^|^|^|^|^| ^\n13|^|^|^|^|^| ^\n14|$=10^5$|$=10^5$|$=1$|^|^| 无特殊限制\n15|^|^|^|^|^| ^\n16|$\\le 10^5$|^| 所有 $p_i$ 是质数 |$\\le 10^{12}$|^| 特性 1\n17|^|^| ^ |^|^| ^\n18|^|^| 无特殊限制 | ^| ^ | ^\n19|^|^| ^ | ^| ^ | ^\n20|^|^| ^ | ^| ^ | ^\n\n特性 1 是指：对于任意的 $i$，$a_i \\le p_i$。\n\n特性 2 是指：$\\operatorname{lcm}(p_i) \\le 10^6$，即所有 $p_i$ 的 **最小公倍数** 不大于 $10^6$。\n\n对于所有的测试点，$T \\le 5$，所有武器的攻击力 $\\le 10^6$，所有 $p_i$ 的最小公倍数 $\\le 10^{12}$。\n\n保证 $ T, n, m $ 均为正整数。\n\n### 提示\n\n你所用到的中间结果可能很大，注意保存中间结果的变量类型。", "locale": "zh-CN"}}}
{"pid": "P4775", "type": "P", "difficulty": 7, "samples": [["2\n5\n1 2 1\n2 3 3\n3 4 2\n1 5 8\n2\n1 4 5\n3 5 8\n5\n1 2 1\n2 3 3\n3 4 3\n1 5 9\n2\n1 5 5\n2 3 8", "1\nF"], ["1\n11\n1 2 2\n1 3 0\n2 4 1\n3 5 7\n1 6 0\n1 7 1\n1 8 1\n6 9 3\n4 10 2\n4 11 8\n10\n7 10 2\n10 7 0\n2 11 1\n8 6 7\n7 7 0\n10 1 1\n8 2 1\n7 8 3\n7 7 3\n3 9 9\n", "13\n"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "线段树", "NOI", "O2优化", "最近公共祖先 LCA"], "title": "[NOI2018] 情报中心", "background": "", "description": "C 国和 D 国近年来战火纷飞。\n\n最近，C 国成功地渗透进入了 D 国的一个城市。这个城市可以抽象成一张有 $n$ 个节点，节点之间由 $n − 1$ 条双向的边连接的无向图，使得任意两个点之间可以互相到达。也就是说，这张无向图实际上是一棵树。\n\n经过侦查，C 国情报部部长 GGB 惊讶地发现，这座看起来不起眼的城市竟然是 D 国的军事中心。因此 GGB 决定在这个城市内设立情报机构。情报专家 TAC 在侦查后，安排了 $m$ 种设立情报机构的方案。这些方案中，第 $i$ 种方案是在节点 $x_i$ 到节点 $y_i$ 的最短路径的所有边上安排情报人员收集情报，这种方案需要花费 $v_i$ 元的代价。\n\n但是，由于人手不足，GGB 只能安排上述 $m$ 种方案中的两种进行实施。同时 TAC 指出，为了让这两个情报机构可以更好的合作，它们收集情报的范围应**至少有一条公共的边**。为了评估一种方案的性能，GGB 和 TAC 对所有的边进行了勘察，给每一条边制定了一个情报价值 $c_i$，表示收集这条边上的情报能够带来 $c_i$ 元的收益。注意，情报是唯一的，因此当一条边的情报被两个情报机构收集时，也同样只会有 $c_i$ 的收益。\n\n现在，请你帮 GGB 选出两种合法的设立情报机构的方案进行实施，使得这两种方案收集情报的范围至少有一条公共的边，并且在此基础上**总收益减去总代价的差**最大。\n\n注意，这个值可能是负的，但仍然是合法的。如果无法找到这样的两种方案，请输出 `F`。\n", "inputFormat": "从文件 `center.in` 中读入数据。\n\n本题包含多组测试数据。\n\n输入文件的第一行包含一个整数 $T$，表示数据组数；\n\n每组数据包含 $(n + m + 1)$ 行：\n\n第 $1$ 行包含一个整数 $n$，表示城市的点数；\n\n第 $2$ 到第 $n$ 行中，第 $(i + 1)$ 行包含三个整数 $a_i$，$b_i$，$c_i$，表示城市中一条连接节点 $a_i$ 和 $b_i$、情报价值为 $c_i$ 的双向边，保证 $a_i < b_i$ 且 $b_i$ 互不相同；\n\n第 $(n + 1)$ 行包含一个整数 $m$，表示 TAC 设立的 $m$ 种设立情报机构的方案；\n\n第 $(n + 2)$ 到 $(n + m + 1)$ 行中，第 $(n + i + 1)$ 行包含三个整数 $x_i$，$y_i$，$v_i$，表示第 $i$ 种设立情报机构的方案是在节点 $x_i$ 到节点 $y_i$ 的最短路径上的所有边上安排情报人员收集情报，并且需要花费 $v_i$ 元的代价。", "outputFormat": "输出到文件 `center.out` 中。\n\n输出文件包含 $T$ 行；\n\n对于每组数据，输出一行：如果存在合法的方案，则输出一个整数表示最大的总收益减去总代价的差；否则输出 `F`。\n", "hint": "### 样例 1 解释\n\n这个样例中包含两组数据。这两组数据的城市相同，只是在情报的价值和情报机构的方案上有所不同。城市地图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mfs5k9ob.png)\n\n* 对于第一组数据，方案一中的节点 $1$ 到节点 $4$ 的最短路径为 $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4$，方案二中的节点 $3$ 到节点 $5$ 的最短路径为 $3 \\rightarrow 2 \\rightarrow 1 \\rightarrow 5$。选择这两种方案需要花费 $5 + 8 = 13$ 的代价，并且每一条边的情报都被收集从而得到 $1 + 3 + 2 + 8 = 14$ 的收益，因此总收益减去总代价为 $14 − 13 = 1$。\n* 对于第二组数据，方案一中的节点 $1$ 到节点 $5$ 的最短路径为 $1 \\rightarrow 5$，方案二中的节点 $2$ 到节点 $3$ 的最短路径为 $2 \\rightarrow 3$。这两种方案收集情报的范围没有公共的边，因此非法，所以这组数据不存在合法方案，应输出 `F`。\n\n### 样例 2 解释\n\n见附加文件中的 `center2.in` 与 `center2.ans`。\n\n这个样例只包含一组数据。这一数据中，最优方案为选择第 $2$ 种和第 $3$ 种方案。\n\n这组数据的城市地图如下，其中**加粗**的边表示被情报中心收集情报的边，红色的边表示只被第 $2$ 种方案的情报中心收集情报的边，蓝色的边表示只被第 $3$ 种方案的情报中心收集情报的边，紫色的边表示同时被两个情报中心收集情报的边。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s9blcjri.png)\n\n### 样例 3\n\n见附加文件中的 `center3.in` 与 `center3.ans`。\n\n这个样例和第 $4$ 个测试点的性质相同。每个测试点的性质见下文的表格。\n\n### 样例 4\n\n见附加文件中的 `center4.in` 与 `center4.ans`。\n\n这个样例，无疑是善良的出题人无私的馈赠。大量精心构造的 $n\\le 100,m\\le 200$ 的测试数据，涵盖了测试点中所有出现性质的组合。你可以利用这个测试点，对自己的程序进行全面的检查。足量的数据组数、不大的数据范围和多种多样的数据类型，能让程序中的错误无处遁形。出题人相信，这个美妙的样例，可以给拼搏于 AC 这道题的逐梦之路上的你，提供一个有力的援助。\n\n### 数据范围\n\n各测试点的数据规模和性质如下表：\n\n::cute-table{tuack}\n\n| 测试点 | $n \\le$ | $m \\le$ | $T \\le 50$ | 特殊性质 |\n| :-: | :-: | :-: | :-: | :-: |\n| 1 | $2$ | $3$ | 保证 | 无 |\n| 2 | $10$ | $30$ | ^ | ^ |\n| 3 | $200$ | $300$ | ^ | ^ |\n| 4 | $10^3$ | $2,000$ | ^ | $a_i = b_i - 1$ |\n| 5 | $10^4$ | $3 \\times 10^4$ | ^ | ^ |\n| 6 | $5 \\times 10^4$ | $10^5$ | ^ | ^ |\n| 7 | $10^4$ | $3 \\times 10^4$ | ^ | $c_i=0$ |\n| 8 | $5 \\times 10^4$ | $10^5$ | ^ | ^ |\n| 9 | ^ | ^ | ^ | ^ |\n| 10 | $10^4$ | $n$ | ^ | $S_1$ |\n| 11 | $5 \\times 10^4$ | ^ | 不保证 | ^ |\n| 12 | ^ | ^ | ^ | ^ |\n| 13 | $10^4$ | $3 \\times 10^4$ | 保证 | $S_2$ |\n| 14 | ^ | ^ | ^ | ^ |\n| 15 | $5 \\times 10^4$ | $10^5$ | 不保证 | ^ |\n| 16 | ^ | ^ | ^ | ^ |\n| 17 | $10^4$ | $3 \\times 10^4$ | 保证 | 无 |\n| 18 | $5 \\times 10^4$ | $ 10^5$ | ^ | ^ |\n| 19 | ^ | ^ | 不保证 | ^ |\n| 20 | ^ | ^ | ^ | ^ |\n\n表格中的特殊性质如下：\n* 特殊性质 $S_1$：对于任意 $i, j$，保证 $x_i$ 到 $y_i$ 的最短路径所经过的编号最小的节点不同于 $x_j$ 到 $y_j$ 的最短路径所经过的编号最小的节点；\n\n* 特殊性质 $S_2$：对于任意 $i$，保证 $x_i$ 到 $y_i$ 的最短路径所经过的编号最小的节点为节点 $1$。\n\n对于所有的数据，$1 \\le n \\le 5 \\times 10^4$，$0 \\le m \\le 10^5$，$0 \\le c_i \\le 10^9$，$0 \\le v_i \\le 10^{10} \\times n$。每个测试点中，所有 $n$ 的和不会超过 $1\\,000\\,233$，所有 $m$ 的和不会超过 $2\\,000\\,233$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2018] Intelligence Center", "background": "", "description": "In recent years, Country C and Country D have been at war.\n\nRecently, Country C successfully infiltrated a city in Country D. This city can be modeled as an undirected graph with $n$ nodes, connected by $n - 1$ bidirectional edges, such that any two nodes are reachable from each other. In other words, this undirected graph is actually a tree.\n\nAfter investigation, the minister of intelligence of Country C, GGB, was surprised to find that this seemingly ordinary city is actually the military center of Country D. Therefore, GGB decided to set up intelligence agencies in this city. After reconnaissance, the intelligence expert TAC prepared $m$ possible plans to set up intelligence agencies. In the $i$-th plan, intelligence personnel are deployed on all edges along the shortest path from node $x_i$ to node $y_i$ to collect intelligence, and this plan costs $v_i$ yuan.\n\nHowever, due to lack of manpower, GGB can only implement two of the above $m$ plans. Meanwhile, TAC pointed out that, for these two intelligence agencies to cooperate better, the ranges of intelligence they collect must share **at least one common edge**. To evaluate a plan, GGB and TAC surveyed all edges and assigned each edge an intelligence value $c_i$, meaning that collecting intelligence on this edge brings a profit of $c_i$ yuan. Note that intelligence is unique, so even if an edge’s intelligence is collected by both agencies, the profit is still only $c_i$.\n\nNow, please help GGB choose two legal plans to implement, such that the ranges of intelligence collected by these two plans share at least one common edge, and on this basis, the **difference between total profit and total cost** is maximized.\n\nNote that this value may be negative, but it is still valid. If no such two plans can be found, output `F`.", "inputFormat": "Read input from file `center.in`.\n\nThis problem contains multiple test cases.\n\nThe first line of the input file contains an integer $T$, indicating the number of test cases.\n\nEach test case contains $(n + m + 1)$ lines:\n\nLine $1$ contains an integer $n$, the number of nodes in the city.\n\nLines $2$ to $n$ (i.e., line $(i + 1)$) each contain three integers $a_i$, $b_i$, $c_i$, describing a bidirectional edge connecting nodes $a_i$ and $b_i$ with intelligence value $c_i$. It is guaranteed that $a_i < b_i$ and all $b_i$ are distinct.\n\nLine $(n + 1)$ contains an integer $m$, the number of plans proposed by TAC.\n\nLines $(n + 2)$ to $(n + m + 1)$ (i.e., line $(n + i + 1)$) each contain three integers $x_i$, $y_i$, $v_i$, meaning that the $i$-th plan deploys intelligence personnel on all edges along the shortest path from node $x_i$ to node $y_i$, and costs $v_i$ yuan.", "outputFormat": "Write output to file `center.out`.\n\nThe output file contains $T$ lines.\n\nFor each test case, output one line: if there exists a legal choice, output an integer representing the maximum value of (total profit minus total cost); otherwise output `F`.", "hint": "### Sample 1 Explanation\n\nThis sample contains two test cases. The cities (trees) are the same in both cases; only the intelligence values and the plans differ. The city map is as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mfs5k9ob.png)\n\n* For the first test case, the shortest path from node $1$ to node $4$ in plan 1 is $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4$, and the shortest path from node $3$ to node $5$ in plan 2 is $3 \\rightarrow 2 \\rightarrow 1 \\rightarrow 5$. Choosing these two plans costs $5 + 8 = 13$, and intelligence on every edge is collected, yielding a profit of $1 + 3 + 2 + 8 = 14$, so (total profit minus total cost) is $14 − 13 = 1$.\n* For the second test case, the shortest path from node $1$ to node $5$ in plan 1 is $1 \\rightarrow 5$, and the shortest path from node $2$ to node $3$ in plan 2 is $2 \\rightarrow 3$. The ranges of intelligence collected by these two plans have no common edge, so this is illegal. Therefore, there is no legal choice for this test case, and you should output `F`.\n\n### Sample 2 Explanation\n\nSee the attached files `center2.in` and `center2.ans`.\n\nThis sample contains only one test case. In this test case, the optimal choice is to select plan $2$ and plan $3$.\n\nThe city map for this test case is as follows. The **bold** edges are those whose intelligence is collected by the intelligence centers; red edges are collected only by the intelligence center in plan $2$; blue edges are collected only by the intelligence center in plan $3$; and purple edges are collected by both intelligence centers.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s9blcjri.png)\n\n### Sample 3\n\nSee the attached files `center3.in` and `center3.ans`.\n\nThis sample has the same properties as test point $4$. The properties of each test point are shown in the table below.\n\n### Sample 4\n\nSee the attached files `center4.in` and `center4.ans`.\n\nThis sample is undoubtedly a generous gift from the kind problem setter. It contains a large number of carefully constructed test cases with $n\\le 100,m\\le 200$, covering all combinations of properties that appear among the test points. You can use this test point to thoroughly check your program. With enough test cases, small constraints, and diverse data types, bugs in your program will have nowhere to hide. The problem setter believes that this wonderful sample can provide strong support on your journey toward AC on this problem.\n\n### Constraints\n\nThe sizes and properties of the test points are shown in the table below:\n\n::cute-table{tuack}\n\n| Test Point | $n \\le$ | $m \\le$ | $T \\le 50$ | Special Property |\n| :-: | :-: | :-: | :-: | :-: |\n| 1 | $2$ | $3$ | Guaranteed | None |\n| 2 | $10$ | $30$ | ^ | ^ |\n| 3 | $200$ | $300$ | ^ | ^ |\n| 4 | $10^3$ | $2,000$ | ^ | $a_i = b_i - 1$ |\n| 5 | $10^4$ | $3 \\times 10^4$ | ^ | ^ |\n| 6 | $5 \\times 10^4$ | $10^5$ | ^ | ^ |\n| 7 | $10^4$ | $3 \\times 10^4$ | ^ | $c_i=0$ |\n| 8 | $5 \\times 10^4$ | $10^5$ | ^ | ^ |\n| 9 | ^ | ^ | ^ | ^ |\n| 10 | $10^4$ | $n$ | ^ | $S_1$ |\n| 11 | $5 \\times 10^4$ | ^ | Not guaranteed | ^ |\n| 12 | ^ | ^ | ^ | ^ |\n| 13 | $10^4$ | $3 \\times 10^4$ | Guaranteed | $S_2$ |\n| 14 | ^ | ^ | ^ | ^ |\n| 15 | $5 \\times 10^4$ | $10^5$ | Not guaranteed | ^ |\n| 16 | ^ | ^ | ^ | ^ |\n| 17 | $10^4$ | $3 \\times 10^4$ | Guaranteed | None |\n| 18 | $5 \\times 10^4$ | $ 10^5$ | ^ | ^ |\n| 19 | ^ | ^ | Not guaranteed | ^ |\n| 20 | ^ | ^ | ^ | ^ |\n\nThe special properties in the table are:\n\n* Special property $S_1$: For any $i, j$, it is guaranteed that the smallest-indexed node on the shortest path from $x_i$ to $y_i$ is different from the smallest-indexed node on the shortest path from $x_j$ to $y_j$.\n\n* Special property $S_2$: For any $i$, it is guaranteed that the smallest-indexed node on the shortest path from $x_i$ to $y_i$ is node $1$.\n\nFor all testdata, $1 \\le n \\le 5 \\times 10^4$, $0 \\le m \\le 10^5$, $0 \\le c_i \\le 10^9$, $0 \\le v_i \\le 10^{10} \\times n$. In each test point, the sum of all $n$ does not exceed $1\\,000\\,233$, and the sum of all $m$ does not exceed $2\\,000\\,233$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2018] 情报中心", "background": "", "description": "C 国和 D 国近年来战火纷飞。\n\n最近，C 国成功地渗透进入了 D 国的一个城市。这个城市可以抽象成一张有 $n$ 个节点，节点之间由 $n − 1$ 条双向的边连接的无向图，使得任意两个点之间可以互相到达。也就是说，这张无向图实际上是一棵树。\n\n经过侦查，C 国情报部部长 GGB 惊讶地发现，这座看起来不起眼的城市竟然是 D 国的军事中心。因此 GGB 决定在这个城市内设立情报机构。情报专家 TAC 在侦查后，安排了 $m$ 种设立情报机构的方案。这些方案中，第 $i$ 种方案是在节点 $x_i$ 到节点 $y_i$ 的最短路径的所有边上安排情报人员收集情报，这种方案需要花费 $v_i$ 元的代价。\n\n但是，由于人手不足，GGB 只能安排上述 $m$ 种方案中的两种进行实施。同时 TAC 指出，为了让这两个情报机构可以更好的合作，它们收集情报的范围应**至少有一条公共的边**。为了评估一种方案的性能，GGB 和 TAC 对所有的边进行了勘察，给每一条边制定了一个情报价值 $c_i$，表示收集这条边上的情报能够带来 $c_i$ 元的收益。注意，情报是唯一的，因此当一条边的情报被两个情报机构收集时，也同样只会有 $c_i$ 的收益。\n\n现在，请你帮 GGB 选出两种合法的设立情报机构的方案进行实施，使得这两种方案收集情报的范围至少有一条公共的边，并且在此基础上**总收益减去总代价的差**最大。\n\n注意，这个值可能是负的，但仍然是合法的。如果无法找到这样的两种方案，请输出 `F`。\n", "inputFormat": "从文件 `center.in` 中读入数据。\n\n本题包含多组测试数据。\n\n输入文件的第一行包含一个整数 $T$，表示数据组数；\n\n每组数据包含 $(n + m + 1)$ 行：\n\n第 $1$ 行包含一个整数 $n$，表示城市的点数；\n\n第 $2$ 到第 $n$ 行中，第 $(i + 1)$ 行包含三个整数 $a_i$，$b_i$，$c_i$，表示城市中一条连接节点 $a_i$ 和 $b_i$、情报价值为 $c_i$ 的双向边，保证 $a_i < b_i$ 且 $b_i$ 互不相同；\n\n第 $(n + 1)$ 行包含一个整数 $m$，表示 TAC 设立的 $m$ 种设立情报机构的方案；\n\n第 $(n + 2)$ 到 $(n + m + 1)$ 行中，第 $(n + i + 1)$ 行包含三个整数 $x_i$，$y_i$，$v_i$，表示第 $i$ 种设立情报机构的方案是在节点 $x_i$ 到节点 $y_i$ 的最短路径上的所有边上安排情报人员收集情报，并且需要花费 $v_i$ 元的代价。", "outputFormat": "输出到文件 `center.out` 中。\n\n输出文件包含 $T$ 行；\n\n对于每组数据，输出一行：如果存在合法的方案，则输出一个整数表示最大的总收益减去总代价的差；否则输出 `F`。\n", "hint": "### 样例 1 解释\n\n这个样例中包含两组数据。这两组数据的城市相同，只是在情报的价值和情报机构的方案上有所不同。城市地图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mfs5k9ob.png)\n\n* 对于第一组数据，方案一中的节点 $1$ 到节点 $4$ 的最短路径为 $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4$，方案二中的节点 $3$ 到节点 $5$ 的最短路径为 $3 \\rightarrow 2 \\rightarrow 1 \\rightarrow 5$。选择这两种方案需要花费 $5 + 8 = 13$ 的代价，并且每一条边的情报都被收集从而得到 $1 + 3 + 2 + 8 = 14$ 的收益，因此总收益减去总代价为 $14 − 13 = 1$。\n* 对于第二组数据，方案一中的节点 $1$ 到节点 $5$ 的最短路径为 $1 \\rightarrow 5$，方案二中的节点 $2$ 到节点 $3$ 的最短路径为 $2 \\rightarrow 3$。这两种方案收集情报的范围没有公共的边，因此非法，所以这组数据不存在合法方案，应输出 `F`。\n\n### 样例 2 解释\n\n见附加文件中的 `center2.in` 与 `center2.ans`。\n\n这个样例只包含一组数据。这一数据中，最优方案为选择第 $2$ 种和第 $3$ 种方案。\n\n这组数据的城市地图如下，其中**加粗**的边表示被情报中心收集情报的边，红色的边表示只被第 $2$ 种方案的情报中心收集情报的边，蓝色的边表示只被第 $3$ 种方案的情报中心收集情报的边，紫色的边表示同时被两个情报中心收集情报的边。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s9blcjri.png)\n\n### 样例 3\n\n见附加文件中的 `center3.in` 与 `center3.ans`。\n\n这个样例和第 $4$ 个测试点的性质相同。每个测试点的性质见下文的表格。\n\n### 样例 4\n\n见附加文件中的 `center4.in` 与 `center4.ans`。\n\n这个样例，无疑是善良的出题人无私的馈赠。大量精心构造的 $n\\le 100,m\\le 200$ 的测试数据，涵盖了测试点中所有出现性质的组合。你可以利用这个测试点，对自己的程序进行全面的检查。足量的数据组数、不大的数据范围和多种多样的数据类型，能让程序中的错误无处遁形。出题人相信，这个美妙的样例，可以给拼搏于 AC 这道题的逐梦之路上的你，提供一个有力的援助。\n\n### 数据范围\n\n各测试点的数据规模和性质如下表：\n\n::cute-table{tuack}\n\n| 测试点 | $n \\le$ | $m \\le$ | $T \\le 50$ | 特殊性质 |\n| :-: | :-: | :-: | :-: | :-: |\n| 1 | $2$ | $3$ | 保证 | 无 |\n| 2 | $10$ | $30$ | ^ | ^ |\n| 3 | $200$ | $300$ | ^ | ^ |\n| 4 | $10^3$ | $2,000$ | ^ | $a_i = b_i - 1$ |\n| 5 | $10^4$ | $3 \\times 10^4$ | ^ | ^ |\n| 6 | $5 \\times 10^4$ | $10^5$ | ^ | ^ |\n| 7 | $10^4$ | $3 \\times 10^4$ | ^ | $c_i=0$ |\n| 8 | $5 \\times 10^4$ | $10^5$ | ^ | ^ |\n| 9 | ^ | ^ | ^ | ^ |\n| 10 | $10^4$ | $n$ | ^ | $S_1$ |\n| 11 | $5 \\times 10^4$ | ^ | 不保证 | ^ |\n| 12 | ^ | ^ | ^ | ^ |\n| 13 | $10^4$ | $3 \\times 10^4$ | 保证 | $S_2$ |\n| 14 | ^ | ^ | ^ | ^ |\n| 15 | $5 \\times 10^4$ | $10^5$ | 不保证 | ^ |\n| 16 | ^ | ^ | ^ | ^ |\n| 17 | $10^4$ | $3 \\times 10^4$ | 保证 | 无 |\n| 18 | $5 \\times 10^4$ | $ 10^5$ | ^ | ^ |\n| 19 | ^ | ^ | 不保证 | ^ |\n| 20 | ^ | ^ | ^ | ^ |\n\n表格中的特殊性质如下：\n* 特殊性质 $S_1$：对于任意 $i, j$，保证 $x_i$ 到 $y_i$ 的最短路径所经过的编号最小的节点不同于 $x_j$ 到 $y_j$ 的最短路径所经过的编号最小的节点；\n\n* 特殊性质 $S_2$：对于任意 $i$，保证 $x_i$ 到 $y_i$ 的最短路径所经过的编号最小的节点为节点 $1$。\n\n对于所有的数据，$1 \\le n \\le 5 \\times 10^4$，$0 \\le m \\le 10^5$，$0 \\le c_i \\le 10^9$，$0 \\le v_i \\le 10^{10} \\times n$。每个测试点中，所有 $n$ 的和不会超过 $1\\,000\\,233$，所有 $m$ 的和不会超过 $2\\,000\\,233$。\n", "locale": "zh-CN"}}}
{"pid": "P4776", "type": "P", "difficulty": 7, "samples": [["5 1\n1 1 2 2", "2"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "NOI", "O2优化"], "title": "[NOI2018] 多边形", "background": "", "description": "久莲是一个喜欢出题的女孩子。\n\n在今年的 World Final 结束以后，久莲特别喜欢计算几何，于是她打算在 NOI 的考场上也出一个计算几何：这是一道只有题目名字和计算几何相关的题目。\n\n首先，久莲给出了一棵 $n\\ (n \\ge 2)$ 个节点的有根树 $T$，根节点编号为 $1$。定义叶子节点为除了根以外所有度数恰好为 $1$ 的节点。下图是一个树 $T$ 的例子，其中叶子节点集合为 $\\{3, 4, 5\\}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9k8ckocd.png)\n\n接着通过这棵树，久莲构造了一个序列 $A$：\n- 从根节点开始深度优先遍历整棵树，遍历时按照编号从小到大的顺序来访问孩子，这样可以得到一个树 $T$ 的 DFS 序。\n- 接着按照在 DFS 序中的出现顺序从前往后，久莲把所有叶子节点排成一排得到了一个序列 $A$。\n\n更进一步地，通过序列 $A$，久莲定义了两个叶子节点 $u, v$ 的距离 $d(u, v)$：假设 $u$ 在 $A$ 中是第 $i$ 个元素，$v$ 是第 $j$ 个元素，则 $d(u, v) = \\min(|i − j|, |A| − |i − j|)$。其中 $|A|$ 为序列的长度，即 $T$ 的叶子个数，$i, j$ 指的是出现的位置，从 $1$ 开始计数。\n\n上面的例子中，序列 $A$ 为 $\\{4, 5, 3\\}$，其中 $d(3, 5) = d(3, 4) = d(4, 5) = 1$，$3, 4, 5$ 的出现位置分别为 $3, 1, 2$。\n\n最后，久莲给出了一个参数 $K$，利用这棵有根树 $T$ 和序列 $A$，我们可以构造一张 $n$ 个点的**无重边无自环**的无向图 $G$：两个不同的点 $u, v$ 之间有边当且仅当它们满足下列条件中的至少一个：\n- 在树 $T$ 中存在连接 $u, v$ 的边。\n- 在树 $T$ 中 $u, v$ 都是叶子节点且 $d(u, v) \\le K$。\n\n当 $K = 1$ 或 $2$ 时，上面的例子得到的图 $G$ 都如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zsq6qywg.png)\n\n现在久莲想让你来计算一下 $G$ 中不同的哈密尔顿回路数量有多少条，答案可能很大，请对 $998244353$ 取模后输出。\n\n下面是一些补充定义：\n- 无重边无自环的无向图 $G$ 的一条哈密尔顿回路 $H$ 是 $G$ 中边的一个子集，其中每一个点恰好有两条不同的相邻边在 $H$ 中，且任意两个点都可以通过 $H$ 中的边直接或间接到达。\n- 无重边无自环的无向图 $G$ 的两条哈密尔顿回路 $H_1, H_2$ 是不同的当且仅当存在一条边 $e$ 使得 $e$ 在 $H_1$ 中且不在 $H_2$ 中。", "inputFormat": "从文件 `polygon.in` 中读入数据。\n\n第一行输入两个整数 $n, K$，表示树 $T$ 的点数以及久莲选定的参数 $K$。\n\n第二行输入 $n - 1$ 个整数 $f_i\\ (1 \\le f_i \\le i)$，其中 $f_i$ 表示树 $T$ 上存在边 $( f_i, i + 1)$。", "outputFormat": "输出到文件 `polygon.out` 中。\n\n输出一行一个整数，表示哈密尔顿回路数量对 $998244353$ 取模后的结果。", "hint": "### 样例解释\n\n该样例和题面中的例子完全相同。两条哈密尔顿回路经过节点的顺序分别为 $(1, 2, 4, 5, 3)$ 和 $(1, 2, 5, 4, 3)$。\n\n### 子任务\n\n::cute-table{tuack=4}\n\n编号|$n$|$K$|特殊性质|编号|$n$|$K$|特殊性质\n:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:\n$1$|$\\le 5$|$\\le 3$|无|$11$|$\\le 1000$|$\\le 2$|A\n$2$|$\\le 10$|^|^|$12$|^|^|^\n$3$|$\\le 15$|^|^|$13$|^|^|^\n$4$|$\\le 20$|^|^|$14$|^|^|无\n$5$|$\\le 1000$|$=1$|A|$15$|^|^|^\n$6$|^|$=1$|^|$16$|^|^|^\n$7$|^|^|^|$17$|^|$\\le 3$|A\n$8$|^|^|无|$18$|^|^|^\n$9$|^|^|^|$19$|^|^|无\n$10$|^|^|^|$20$|^|^|^\n\n其中性质 A 为保证树上所有节点至多有两个孩子。\n\n对于所有的数据，保证 $1 \\leq f_i \\leq i$，$2 \\leq n \\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2018] Polygon", "background": "", "description": "Jiulian is a girl who likes to create problems.\n\nAfter this year’s World Final ended, Jiulian became very interested in computational geometry, so she decided to set a computational geometry problem in the NOI contest. This is a problem whose only relation to computational geometry is its title.\n\nFirst, Jiulian gives a rooted tree $T$ with $n\\ (n \\ge 2)$ nodes, where the root is node $1$. A leaf node is defined as any node whose degree is exactly $1$, excluding the root. The figure below shows an example of a tree $T$, where the set of leaf nodes is $\\{3, 4, 5\\}$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9k8ckocd.png)\n\nNext, using this tree, Jiulian constructs a sequence $A$:\n- Starting from the root, perform a depth-first traversal of the whole tree. During the traversal, visit children in increasing order of their labels. This yields a DFS order of the tree $T$.\n- Then, according to their order of appearance in the DFS order from front to back, Jiulian lines up all leaf nodes to obtain a sequence $A$.\n\nFurthermore, based on the sequence $A$, Jiulian defines the distance $d(u, v)$ between two leaf nodes $u, v$: suppose $u$ is the $i$-th element in $A$ and $v$ is the $j$-th element, then $d(u, v) = \\min(|i − j|, |A| − |i − j|)$. Here $|A|$ is the length of the sequence, i.e. the number of leaves of $T$, and $i, j$ are their positions, counted starting from $1$.\n\nIn the example above, the sequence $A$ is $\\{4, 5, 3\\}$, where $d(3, 5) = d(3, 4) = d(4, 5) = 1$, and the positions of $3, 4, 5$ are $3, 1, 2$ respectively.\n\nFinally, Jiulian gives a parameter $K$. Using the rooted tree $T$ and the sequence $A$, we can construct an undirected graph $G$ with $n$ vertices, **without multiple edges and without self-loops**. There is an edge between two distinct vertices $u, v$ if and only if they satisfy at least one of the following conditions:\n- There is an edge connecting $u$ and $v$ in the tree $T$.\n- In the tree $T$, both $u$ and $v$ are leaf nodes, and $d(u, v) \\le K$.\n\nWhen $K = 1$ or $2$, the graph $G$ obtained from the example above is as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zsq6qywg.png)\n\nNow Jiulian wants you to compute the number of distinct Hamiltonian cycles in $G$. The answer may be large, so output it modulo $998244353$.\n\nHere are some additional definitions:\n- A Hamiltonian cycle $H$ of an undirected graph $G$ without multiple edges and self-loops is a subset of edges of $G$ such that for every vertex, there are exactly two distinct incident edges in $H$, and any two vertices can be connected directly or indirectly using edges in $H$.\n- Two Hamiltonian cycles $H_1, H_2$ of an undirected graph $G$ without multiple edges and self-loops are different if and only if there exists an edge $e$ such that $e$ is in $H_1$ but not in $H_2$.", "inputFormat": "Read input from file `polygon.in`.\n\nThe first line contains two integers $n, K$, representing the number of nodes in the tree $T$ and the parameter $K$ chosen by Jiulian.\n\nThe second line contains $n - 1$ integers $f_i\\ (1 \\le f_i \\le i)$, where $f_i$ means that there is an edge $( f_i, i + 1)$ in the tree $T$.", "outputFormat": "Write output to file `polygon.out`.\n\nOutput one line with one integer, representing the number of Hamiltonian cycles modulo $998244353$.", "hint": "### Sample Explanation\n\nThis sample is exactly the same as the example in the statement. The orders of nodes visited by the two Hamiltonian cycles are $(1, 2, 4, 5, 3)$ and $(1, 2, 5, 4, 3)$, respectively.\n\n### Subtasks\n\n::cute-table{tuack=4}\n\nID|$n$|$K$|Special Property|ID|$n$|$K$|Special Property\n:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:\n$1$|$\\le 5$|$\\le 3$|None|$11$|$\\le 1000$|$\\le 2$|A\n$2$|$\\le 10$|^|^|$12$|^|^|^\n$3$|$\\le 15$|^|^|$13$|^|^|^\n$4$|$\\le 20$|^|^|$14$|^|^|None\n$5$|$\\le 1000$|$=1$|A|$15$|^|^|^\n$6$|^|$=1$|^|$16$|^|^|^\n$7$|^|^|^|$17$|^|$\\le 3$|A\n$8$|^|^|None|$18$|^|^|^\n$9$|^|^|^|$19$|^|^|None\n$10$|^|^|^|$20$|^|^|^\n\nProperty A means that every node in the tree has at most two children.\n\nFor all testdata, it is guaranteed that $1 \\leq f_i \\leq i$, $2 \\leq n \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2018] 多边形", "background": "", "description": "久莲是一个喜欢出题的女孩子。\n\n在今年的 World Final 结束以后，久莲特别喜欢计算几何，于是她打算在 NOI 的考场上也出一个计算几何：这是一道只有题目名字和计算几何相关的题目。\n\n首先，久莲给出了一棵 $n\\ (n \\ge 2)$ 个节点的有根树 $T$，根节点编号为 $1$。定义叶子节点为除了根以外所有度数恰好为 $1$ 的节点。下图是一个树 $T$ 的例子，其中叶子节点集合为 $\\{3, 4, 5\\}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9k8ckocd.png)\n\n接着通过这棵树，久莲构造了一个序列 $A$：\n- 从根节点开始深度优先遍历整棵树，遍历时按照编号从小到大的顺序来访问孩子，这样可以得到一个树 $T$ 的 DFS 序。\n- 接着按照在 DFS 序中的出现顺序从前往后，久莲把所有叶子节点排成一排得到了一个序列 $A$。\n\n更进一步地，通过序列 $A$，久莲定义了两个叶子节点 $u, v$ 的距离 $d(u, v)$：假设 $u$ 在 $A$ 中是第 $i$ 个元素，$v$ 是第 $j$ 个元素，则 $d(u, v) = \\min(|i − j|, |A| − |i − j|)$。其中 $|A|$ 为序列的长度，即 $T$ 的叶子个数，$i, j$ 指的是出现的位置，从 $1$ 开始计数。\n\n上面的例子中，序列 $A$ 为 $\\{4, 5, 3\\}$，其中 $d(3, 5) = d(3, 4) = d(4, 5) = 1$，$3, 4, 5$ 的出现位置分别为 $3, 1, 2$。\n\n最后，久莲给出了一个参数 $K$，利用这棵有根树 $T$ 和序列 $A$，我们可以构造一张 $n$ 个点的**无重边无自环**的无向图 $G$：两个不同的点 $u, v$ 之间有边当且仅当它们满足下列条件中的至少一个：\n- 在树 $T$ 中存在连接 $u, v$ 的边。\n- 在树 $T$ 中 $u, v$ 都是叶子节点且 $d(u, v) \\le K$。\n\n当 $K = 1$ 或 $2$ 时，上面的例子得到的图 $G$ 都如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zsq6qywg.png)\n\n现在久莲想让你来计算一下 $G$ 中不同的哈密尔顿回路数量有多少条，答案可能很大，请对 $998244353$ 取模后输出。\n\n下面是一些补充定义：\n- 无重边无自环的无向图 $G$ 的一条哈密尔顿回路 $H$ 是 $G$ 中边的一个子集，其中每一个点恰好有两条不同的相邻边在 $H$ 中，且任意两个点都可以通过 $H$ 中的边直接或间接到达。\n- 无重边无自环的无向图 $G$ 的两条哈密尔顿回路 $H_1, H_2$ 是不同的当且仅当存在一条边 $e$ 使得 $e$ 在 $H_1$ 中且不在 $H_2$ 中。", "inputFormat": "从文件 `polygon.in` 中读入数据。\n\n第一行输入两个整数 $n, K$，表示树 $T$ 的点数以及久莲选定的参数 $K$。\n\n第二行输入 $n - 1$ 个整数 $f_i\\ (1 \\le f_i \\le i)$，其中 $f_i$ 表示树 $T$ 上存在边 $( f_i, i + 1)$。", "outputFormat": "输出到文件 `polygon.out` 中。\n\n输出一行一个整数，表示哈密尔顿回路数量对 $998244353$ 取模后的结果。", "hint": "### 样例解释\n\n该样例和题面中的例子完全相同。两条哈密尔顿回路经过节点的顺序分别为 $(1, 2, 4, 5, 3)$ 和 $(1, 2, 5, 4, 3)$。\n\n### 子任务\n\n::cute-table{tuack=4}\n\n编号|$n$|$K$|特殊性质|编号|$n$|$K$|特殊性质\n:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:\n$1$|$\\le 5$|$\\le 3$|无|$11$|$\\le 1000$|$\\le 2$|A\n$2$|$\\le 10$|^|^|$12$|^|^|^\n$3$|$\\le 15$|^|^|$13$|^|^|^\n$4$|$\\le 20$|^|^|$14$|^|^|无\n$5$|$\\le 1000$|$=1$|A|$15$|^|^|^\n$6$|^|$=1$|^|$16$|^|^|^\n$7$|^|^|^|$17$|^|$\\le 3$|A\n$8$|^|^|无|$18$|^|^|^\n$9$|^|^|^|$19$|^|^|无\n$10$|^|^|^|$20$|^|^|^\n\n其中性质 A 为保证树上所有节点至多有两个孩子。\n\n对于所有的数据，保证 $1 \\leq f_i \\leq i$，$2 \\leq n \\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P4777", "type": "P", "difficulty": 6, "samples": [["3\n11 6\n25 9\n33 17\n", "809"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "最大公约数 gcd", "中国剩余定理 CRT", "模板题"], "title": "【模板】扩展中国剩余定理（EXCRT）", "background": "", "description": "给定 $n$ 组非负整数 $a_i, b_i$ ，求解关于 $x$ 的方程组的最小非负整数解。\n$$\\begin{cases}x\\equiv b_1\\pmod{a_1}\\\\x\\equiv b_2\\pmod{a_2}\\\\\\dots\\\\x\\equiv b_n\\pmod{a_n}\\end{cases}$$", "inputFormat": "输入第一行包含整数 $n$。\n\n接下来 $n$ 行，每行两个非负整数 $a_i, b_i$。", "outputFormat": "输出一行，为满足条件的最小非负整数 $x$。", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le {10}^5$，$1 \\le a_i \\le {10}^{12}$，$0\\leq b_i \\leq 10^{12}$，保证所有 $a_i$ 的最小公倍数不超过 ${10}^{18}$。\n\n**请注意程序运行过程中进行乘法运算时结果可能有溢出的风险。**\n\n数据保证有解。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Extended Chinese Remainder Theorem (EXCRT).", "background": "", "description": "Given $n$ pairs of non-negative integers $a_i, b_i$, find the smallest non-negative integer solution to the system of equations in $x$.\n$$\\begin{cases}x\\equiv b_1\\pmod{a_1}\\\\x\\equiv b_2\\pmod{a_2}\\\\\\dots\\\\x\\equiv b_n\\pmod{a_n}\\end{cases}$$", "inputFormat": "The first line contains an integer $n$.\n\nThe next $n$ lines each contain two non-negative integers $a_i, b_i$.", "outputFormat": "Output one line: the smallest non-negative integer $x$ that satisfies the conditions.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le {10}^5$, $1 \\le a_i \\le {10}^{12}$, $0\\leq b_i \\leq 10^{12}$. It is guaranteed that the least common multiple of all $a_i$ does not exceed ${10}^{18}$.\n\n**Please note that during the execution of the program, multiplication operations may overflow.**\n\nIt is guaranteed that a solution exists.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】扩展中国剩余定理（EXCRT）", "background": "", "description": "给定 $n$ 组非负整数 $a_i, b_i$ ，求解关于 $x$ 的方程组的最小非负整数解。\n$$\\begin{cases}x\\equiv b_1\\pmod{a_1}\\\\x\\equiv b_2\\pmod{a_2}\\\\\\dots\\\\x\\equiv b_n\\pmod{a_n}\\end{cases}$$", "inputFormat": "输入第一行包含整数 $n$。\n\n接下来 $n$ 行，每行两个非负整数 $a_i, b_i$。", "outputFormat": "输出一行，为满足条件的最小非负整数 $x$。", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le {10}^5$，$1 \\le a_i \\le {10}^{12}$，$0\\leq b_i \\leq 10^{12}$，保证所有 $a_i$ 的最小公倍数不超过 ${10}^{18}$。\n\n**请注意程序运行过程中进行乘法运算时结果可能有溢出的风险。**\n\n数据保证有解。", "locale": "zh-CN"}}}
{"pid": "P4778", "type": "P", "difficulty": 6, "samples": [["3\n\n3\n2 3 1\n\n4\n2 1 4 3\n\n2\n1 2", "3\n2\n1"]], "limits": {"time": [1000, 1000], "memory": [32000, 32000]}, "tags": [], "title": "Counting swaps", "background": "Just like yesterday (in problem U of the practice session), Bob is busy, so Alice keeps on playing some single-player games and puzzles. In her newest puzzle she has a permutation of numbers from 1 to n. The goal of the puzzle is to sort the permutation using the smallest possible number of swaps.    \n\nInstead of simply solving the puzzle, Alice is wondering about the probability of winning it just by playing at random. In order to answer this question, she needs to know the number of optimal solutions to her puzzle.", "description": "You are given a permutation $p_1,\\cdots, p_n$ of the numbers $1$ through $n$. In each step you can choose two numbers $x < y$ and swap $p_x$ with $p_y$.\n\nLet $m$ be the minimum number of such swaps needed to sort the given permutation. Compute the number of different sequences of exactly $m$ swaps that sort the given permutation. Since this number may be large, compute it modulo $10^9 + 9$.", "inputFormat": "The first line of the input file contains an integer t specifying the number of test cases. Each test case is preceded by a blank line.\n\nEach test case consists of two lines. The first line contains the integer n. The second line contains the sequence $p_1,\\cdots, p_n$: a permutation of $1,\\cdots, n$.\n\nIn the easy subproblem C1, $1 \\leq n \\leq 10$.\n\nIn the hard subproblem C2, $1 \\leq n \\leq 10^5$.", "outputFormat": "For each test case, output a single line with a single integer: $x \\bmod 10^9+9$, where x is the number of ways to sort the given sequence using as few swaps as possible.", "hint": "In the first test case, we can sort the permutation in two swaps. We can make the first swap arbitrarily; for each of them, there's exactly one optimal second swap. For example, one of the three shortest solutions is “swap $p_1$ with $p_2$ and then swap $p_1$ with $p_3$”.  \n\nIn the second test case, the optimal solution involves swapping $p_1$ with $p_2$ and swapping $p_3$ with $p_4$. We can do these two swaps in either order.  \n\nThe third sequence is already sorted. The optimal number of swaps is $0$, and thus the only optimal solution is an empty sequence of swaps.  \n题目来源：[IPSC2016](https://ipsc.ksp.sk/2016/real/problems/c.html)", "locale": "en", "translations": {"en": {"title": "Counting swaps", "background": "Just like yesterday (in problem U of the practice session), Bob is busy, so Alice keeps on playing some single-player games and puzzles. In her newest puzzle she has a permutation of numbers from 1 to n. The goal of the puzzle is to sort the permutation using the smallest possible number of swaps.    \n\nInstead of simply solving the puzzle, Alice is wondering about the probability of winning it just by playing at random. In order to answer this question, she needs to know the number of optimal solutions to her puzzle.", "description": "You are given a permutation $p_1,\\cdots, p_n$ of the numbers $1$ through $n$. In each step you can choose two numbers $x < y$ and swap $p_x$ with $p_y$.\n\nLet $m$ be the minimum number of such swaps needed to sort the given permutation. Compute the number of different sequences of exactly $m$ swaps that sort the given permutation. Since this number may be large, compute it modulo $10^9 + 9$.", "inputFormat": "The first line of the input file contains an integer t specifying the number of test cases. Each test case is preceded by a blank line.\n\nEach test case consists of two lines. The first line contains the integer n. The second line contains the sequence $p_1,\\cdots, p_n$: a permutation of $1,\\cdots, n$.\n\nIn the easy subproblem C1, $1 \\leq n \\leq 10$.\n\nIn the hard subproblem C2, $1 \\leq n \\leq 10^5$.", "outputFormat": "For each test case, output a single line with a single integer: $x \\bmod 10^9+9$, where x is the number of ways to sort the given sequence using as few swaps as possible.", "hint": "In the first test case, we can sort the permutation in two swaps. We can make the first swap arbitrarily; for each of them, there's exactly one optimal second swap. For example, one of the three shortest solutions is “swap $p_1$ with $p_2$ and then swap $p_1$ with $p_3$”.  \n\nIn the second test case, the optimal solution involves swapping $p_1$ with $p_2$ and swapping $p_3$ with $p_4$. We can do these two swaps in either order.  \n\nThe third sequence is already sorted. The optimal number of swaps is $0$, and thus the only optimal solution is an empty sequence of swaps.  \n题目来源：[IPSC2016](https://ipsc.ksp.sk/2016/real/problems/c.html)", "locale": "en"}, "zh-CN": {"title": "Counting swaps", "background": null, "description": "给定一个排列 $p_1, \\ldots, p_n$，它是数字 $1$ 到 $n$ 的一个排列。在每一步中，你可以选择两个数字 $x < y$ 并交换 $p_x$ 和 $p_y$。\n\n设 $m$ 为将给定排列排序所需的最小交换次数。计算恰好用 $m$ 次交换来排序给定排列的不同序列的数量。由于这个数量可能很大，计算它对 $10^9 + 9$ 取模的结果。", "inputFormat": "输入文件的第一行包含一个整数 $t$，表示测试用例的数量。每个测试用例前有一个空行。\n\n每个测试用例由两行组成。第一行包含整数 $n$。第二行包含序列 $p_1, \\ldots, p_n$：这是 $1, \\ldots, n$ 的一个排列。\n\n在简单子问题 C1 中，$1 \\leq n \\leq 10$。\n\n在困难子问题 C2 中，$1 \\leq n \\leq 10^5$。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数：$x \\bmod 10^9 + 9$，其中 $x$ 是用尽可能少的交换次数来排序给定序列的方法数。", "hint": "在第一个测试用例中，我们可以通过两次交换来排序排列。我们可以任意进行第一次交换；对于每种情况，恰好有一种最佳的第二次交换。例如，三个最短解之一是“交换 $p_1$ 和 $p_2$，然后交换 $p_1$ 和 $p_3$”。\n\n在第二个测试用例中，最佳解涉及交换 $p_1$ 和 $p_2$，以及交换 $p_3$ 和 $p_4$。我们可以以任意顺序进行这两次交换。\n\n第三个序列已经排序。最佳交换次数为 $0$，因此唯一的最佳解是空的交换序列。\n\n题目来源：[IPSC2016](https://ipsc.ksp.sk/2016/real/problems/c.html)\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4779", "type": "P", "difficulty": 3, "samples": [["4 6 1\n1 2 2\n2 3 2\n2 4 1\n1 3 5\n3 4 3\n1 4 4", "0 2 4 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "优先队列", "最短路", "模板题"], "title": "【模板】单源最短路径（标准版）", "background": "2018 年 7 月 19 日，某位同学在 [NOI Day 1 T1 归程](https://www.luogu.com.cn/problem/P4768) 一题里非常熟练地使用了一个广为人知的算法求最短路。\n\n然后呢？\n\n$100 \\rightarrow 60$；\n\n$\\text{Ag} \\rightarrow \\text{Cu}$；\n\n最终，他因此没能与理想的大学达成契约。\n\n小 F 衷心祝愿大家不再重蹈覆辙。", "description": "给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。\n\n数据保证你能从 $s$ 出发到任意点。", "inputFormat": "第一行为三个正整数 $n, m, s$。\n第二行起 $m$ 行，每行三个非负整数 $u_i, v_i, w_i$，表示从 $u_i$ 到 $v_i$ 有一条权值为 $w_i$ 的有向边。", "outputFormat": "输出一行 $n$ 个空格分隔的非负整数，表示 $s$ 到每个点的距离。", "hint": "样例解释请参考 [数据随机的模板题](https://www.luogu.com.cn/problem/P3371)。\n\n$1 \\leq n \\leq 10^5$；\n\n$1 \\leq m \\leq 2\\times 10^5$；\n\n$s = 1$；\n\n$1 \\leq u_i, v_i\\leq n$；\n\n$0 \\leq w_i \\leq 10 ^ 9$,\n\n$0 \\leq \\sum w_i \\leq 10 ^ 9$。\n\n本题数据可能会持续更新，但不会重测，望周知。\n\n2018.09.04 数据更新 from @zzq", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Single-Source Shortest Path (Standard Version).", "background": "On July 19, 2018, a student used a well-known algorithm very skillfully to find shortest paths in the problem [NOI Day 1 T1 Return Trip](https://www.luogu.org/problemnew/show/P4768).\n\nThen what?\n\n$100 \\rightarrow 60$;\n\n$\\text{Ag} \\rightarrow \\text{Cu}$;\n\nIn the end, because of this, he failed to make a contract with his ideal university.\n\nLittle F sincerely hopes that everyone will not make the same mistake again.", "description": "Given a directed graph with $n$ nodes and $m$ directed edges with non-negative weights, please compute the distance from $s$ to every node.\n\nThe testdata guarantees that you can reach every node starting from $s$.", "inputFormat": "The first line contains three positive integers $n, m, s$.\nStarting from the second line, there are $m$ lines. Each line contains three non-negative integers $u_i, v_i, w_i$, meaning there is a directed edge from $u_i$ to $v_i$ with weight $w_i$.", "outputFormat": "Output one line with $n$ space-separated non-negative integers, representing the distance from $s$ to each node.", "hint": "For the sample explanation, please refer to [Template Problem with Random Data](https://www.luogu.com.cn/problem/P3371).\n\nConstraints:\n\n$1 \\leq n \\leq 10^5$;\n\n$1 \\leq m \\leq 2\\times 10^5$;\n\n$s = 1$;\n\n$1 \\leq u_i, v_i\\leq n$;\n\n$0 \\leq w_i \\leq 10 ^ 9$,\n\n$0 \\leq \\sum w_i \\leq 10 ^ 9$。\n\nThe testdata of this problem may continue to be updated, but it will not be rejudged. Please be informed.\n\n2018.09.04 Data update from @zzq.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】单源最短路径（标准版）", "background": "2018 年 7 月 19 日，某位同学在 [NOI Day 1 T1 归程](https://www.luogu.com.cn/problem/P4768) 一题里非常熟练地使用了一个广为人知的算法求最短路。\n\n然后呢？\n\n$100 \\rightarrow 60$；\n\n$\\text{Ag} \\rightarrow \\text{Cu}$；\n\n最终，他因此没能与理想的大学达成契约。\n\n小 F 衷心祝愿大家不再重蹈覆辙。", "description": "给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。\n\n数据保证你能从 $s$ 出发到任意点。", "inputFormat": "第一行为三个正整数 $n, m, s$。\n第二行起 $m$ 行，每行三个非负整数 $u_i, v_i, w_i$，表示从 $u_i$ 到 $v_i$ 有一条权值为 $w_i$ 的有向边。", "outputFormat": "输出一行 $n$ 个空格分隔的非负整数，表示 $s$ 到每个点的距离。", "hint": "样例解释请参考 [数据随机的模板题](https://www.luogu.com.cn/problem/P3371)。\n\n$1 \\leq n \\leq 10^5$；\n\n$1 \\leq m \\leq 2\\times 10^5$；\n\n$s = 1$；\n\n$1 \\leq u_i, v_i\\leq n$；\n\n$0 \\leq w_i \\leq 10 ^ 9$,\n\n$0 \\leq \\sum w_i \\leq 10 ^ 9$。\n\n本题数据可能会持续更新，但不会重测，望周知。\n\n2018.09.04 数据更新 from @zzq", "locale": "zh-CN"}}}
{"pid": "P4780", "type": "P", "difficulty": 5, "samples": [["4", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "枚举", "素数判断,质数,筛法"], "title": "Phi 的反函数", "background": null, "description": "求最小的正整数 $x$，使得 $\\varphi(x)=n$。", "inputFormat": "输入正整数 $n$（$n<2^{31}$）。", "outputFormat": "输出 $x$，如果 $x>2^{31}$ 或者不存在，则输出 $-1$。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Inverse Function of Phi.", "background": "", "description": "Find the smallest positive integer $x$ such that $\\varphi(x)=n$.", "inputFormat": "Input a positive integer $n$ ($n<2^{31}$).", "outputFormat": "Output $x$. If $x>2^{31}$ or it does not exist, output $-1$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Phi 的反函数", "background": null, "description": "求最小的正整数 $x$，使得 $\\varphi(x)=n$。", "inputFormat": "输入正整数 $n$（$n<2^{31}$）。", "outputFormat": "输出 $x$，如果 $x>2^{31}$ 或者不存在，则输出 $-1$。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4781", "type": "P", "difficulty": 5, "samples": [["3 100\n1 4\n2 9\n3 16", "10201"], ["3 100\n1 1\n2 2\n3 3", "100"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化", "拉格朗日插值法", "模板题"], "title": "【模板】拉格朗日插值", "background": "这是一道模板题。", "description": "对于 $n$ 个点 $(x_i,y_i)$，如果满足 $\\forall i\\neq j, x_i\\neq x_j$，那么经过这 $n$ 个点可以唯一地确定一个 $n-1$ 次多项式 $y = f(x)$。\n\n现在，给定这样 $n$ 个点，请你确定这个 $n-1$ 次多项式，并求出 $f(k) \\bmod 998244353$ 的值。", "inputFormat": "第一行两个整数 $n,k$。\n\n接下来 $n$ 行，第 $i$ 行两个整数 $x_i,y_i$。", "outputFormat": "一行一个整数，表示 $f(k) \\bmod 998244353$ 的值。", "hint": "样例一中的多项式为 $f(x)=x^2+2x+1$，$f(100) = 10201$。\n\n样例二中的多项式为 $f(x)=x$，$f(100) = 100$。\n\n---\n\n$1 \\le n \\leq 2\\times 10^3$，$1 \\le x_i,y_i,k < 998244353$，$x_i$ 两两不同。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Lagrange Interpolation", "background": "This is a template problem.", "description": "For $n$ points $(x_i, y_i)$, if $\\forall i \\neq j, x_i \\neq x_j$, then these $n$ points uniquely determine a polynomial $y = f(x)$ of degree $n - 1$.\n\nNow, given such $n$ points, please determine this degree $n - 1$ polynomial and compute the value of $f(k) \\bmod 998244353$.", "inputFormat": "The first line contains two integers $n, k$.\n\nThe next $n$ lines each contain two integers $x_i, y_i$ on the $i$-th line.", "outputFormat": "Output one integer in one line, representing the value of $f(k) \\bmod 998244353$.", "hint": "In Sample 1, the polynomial is $f(x) = x^2 + 2x + 1$, and $f(100) = 10201$.\n\nIn Sample 2, the polynomial is $f(x) = x$, and $f(100) = 100$.\n\n---\n\nConstraints: $1 \\le n \\le 2 \\times 10^3$, $1 \\le x_i, y_i, k < 998244353$, and all $x_i$ are pairwise distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】拉格朗日插值", "background": "这是一道模板题。", "description": "对于 $n$ 个点 $(x_i,y_i)$，如果满足 $\\forall i\\neq j, x_i\\neq x_j$，那么经过这 $n$ 个点可以唯一地确定一个 $n-1$ 次多项式 $y = f(x)$。\n\n现在，给定这样 $n$ 个点，请你确定这个 $n-1$ 次多项式，并求出 $f(k) \\bmod 998244353$ 的值。", "inputFormat": "第一行两个整数 $n,k$。\n\n接下来 $n$ 行，第 $i$ 行两个整数 $x_i,y_i$。", "outputFormat": "一行一个整数，表示 $f(k) \\bmod 998244353$ 的值。", "hint": "样例一中的多项式为 $f(x)=x^2+2x+1$，$f(100) = 10201$。\n\n样例二中的多项式为 $f(x)=x$，$f(100) = 100$。\n\n---\n\n$1 \\le n \\leq 2\\times 10^3$，$1 \\le x_i,y_i,k < 998244353$，$x_i$ 两两不同。", "locale": "zh-CN"}}}
{"pid": "P4782", "type": "P", "difficulty": 5, "samples": [["3 1\n1 1 3 0", "POSSIBLE\n0 0 0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "Special Judge", "O2优化", "2-SAT", "强连通分量", "模板题"], "title": "【模板】2-SAT", "background": null, "description": "有 $n$ 个布尔变量 $x_1\\sim x_n$，另有 $m$ 个需要满足的条件，每个条件的形式都是 「$x_i$ 为 `true` / `false` 或 $x_j$ 为 `true` / `false`」。比如 「$x_1$ 为真或 $x_3$ 为假」、「$x_7$ 为假或 $x_2$ 为假」。\n\n2-SAT 问题的目标是给每个变量赋值使得所有条件得到满足。", "inputFormat": "第一行两个整数 $n$ 和 $m$，意义如题面所述。\n\n接下来 $m$ 行每行 $4$ 个整数 $i$, $a$, $j$, $b$，表示 「$x_i$ 为 $a$ 或 $x_j$ 为 $b$」($a, b\\in \\{0,1\\}$)", "outputFormat": "如无解，输出 `IMPOSSIBLE`；\n\n否则输出 `POSSIBLE`，下一行 $n$ 个整数 $x_1\\sim x_n$（$x_i\\in\\{0,1\\}$），表示构造出的解。", "hint": "$1\\leq n, m\\leq 10^6$ , 前 $3$ 个点卡小错误，后面 $5$ 个点卡效率。\n\n由于数据随机生成，可能会含有 10 0 10 0 之类的坑，但按照最常规写法的写的标程没有出错，各个数据点卡什么的提示在标程里。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] 2-SAT", "background": "", "description": "There are $n$ Boolean variables $x_1\\sim x_n$, and $m$ constraints that must be satisfied. Each constraint has the form: “$x_i$ is `true` / `false` or $x_j$ is `true` / `false`”. For example, “$x_1$ is true or $x_3$ is false”, “$x_7$ is false or $x_2$ is false”.\n\nThe goal of the 2-SAT problem is to assign a value to each variable so that all constraints are satisfied.", "inputFormat": "The first line contains two integers $n$ and $m$, with the meanings as described above.\n\nThe next $m$ lines each contain four integers $i$, $a$, $j$, $b$, meaning “$x_i$ is $a$ or $x_j$ is $b” ($a, b\\in \\{0,1\\}$).", "outputFormat": "If there is no solution, output `IMPOSSIBLE`.\n\nOtherwise output `POSSIBLE`, and on the next line output $n$ integers $x_1\\sim x_n$ ($x_i\\in\\{0,1\\}$), representing a constructed solution.", "hint": "$1\\leq n, m\\leq 10^6$. The first $3$ test points check for small mistakes, and the remaining $5$ test points check efficiency.\n\nSince the testdata is generated randomly, it may contain tricky cases such as `10 0 10 0`, but the official solution written in the most standard way did not make mistakes. The hints about what each test point is checking are in the official solution.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】2-SAT", "background": null, "description": "有 $n$ 个布尔变量 $x_1\\sim x_n$，另有 $m$ 个需要满足的条件，每个条件的形式都是 「$x_i$ 为 `true` / `false` 或 $x_j$ 为 `true` / `false`」。比如 「$x_1$ 为真或 $x_3$ 为假」、「$x_7$ 为假或 $x_2$ 为假」。\n\n2-SAT 问题的目标是给每个变量赋值使得所有条件得到满足。", "inputFormat": "第一行两个整数 $n$ 和 $m$，意义如题面所述。\n\n接下来 $m$ 行每行 $4$ 个整数 $i$, $a$, $j$, $b$，表示 「$x_i$ 为 $a$ 或 $x_j$ 为 $b$」($a, b\\in \\{0,1\\}$)", "outputFormat": "如无解，输出 `IMPOSSIBLE`；\n\n否则输出 `POSSIBLE`，下一行 $n$ 个整数 $x_1\\sim x_n$（$x_i\\in\\{0,1\\}$），表示构造出的解。", "hint": "$1\\leq n, m\\leq 10^6$ , 前 $3$ 个点卡小错误，后面 $5$ 个点卡效率。\n\n由于数据随机生成，可能会含有 10 0 10 0 之类的坑，但按照最常规写法的写的标程没有出错，各个数据点卡什么的提示在标程里。", "locale": "zh-CN"}}}
{"pid": "P4783", "type": "P", "difficulty": 5, "samples": [["3\n1 2 8\n2 5 6\n5 1 2", "718750005 718750005 968750007\n171875001 671875005 296875002\n117187501 867187506 429687503"], ["3\n3 2 4\n7 2 9\n2 4 3", "No Solution"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "O2优化", "高斯消元", "模板题"], "title": "【模板】矩阵求逆", "background": "", "description": "求一个 $N\\times N$ 的矩阵的逆矩阵。答案对 ${10}^9+7$ 取模。", "inputFormat": "第一行有一个整数 $N$，代表矩阵的大小；\n\n接下来 $N$ 行，每行 $N$ 个整数，其中第 $i$ 行第 $j$ 列的数代表矩阵中的元素 $a_{i j}$。", "outputFormat": "若矩阵可逆，则输出 $N$ 行，每行 $N$ 个整数，其中第 $i$ 行第 $j$ 列的数代表逆矩阵中的元素 $b_{i j}$，答案对 ${10}^9+7$ 取模；\n\n否则只输出一行 `No Solution`。", "hint": "对 $30 \\%$ 的数据有 $N\\le 100$；  \n对 $100 \\%$ 的数据有 $N\\le 400$，所有 $0 \\le a_{i j} < {10}^9 + 7$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Matrix Inversion", "background": "", "description": "Find the inverse matrix of an $N\\times N$ matrix. Output the answer modulo ${10}^9+7$.", "inputFormat": "The first line contains an integer $N$, which represents the size of the matrix.\n\nThe next $N$ lines each contain $N$ integers. The number in row $i$ and column $j$ represents the element $a_{i j}$ of the matrix.", "outputFormat": "If the matrix is invertible, output $N$ lines, each containing $N$ integers. The number in row $i$ and column $j$ represents the element $b_{i j}$ of the inverse matrix, taken modulo ${10}^9+7$.\n\nOtherwise, output only one line: `No Solution`.", "hint": "For $30\\%$ of the testdata, $N\\le 100$.\n\nFor $100\\%$ of the testdata, $N\\le 400$, and all $0 \\le a_{i j} < {10}^9 + 7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】矩阵求逆", "background": "", "description": "求一个 $N\\times N$ 的矩阵的逆矩阵。答案对 ${10}^9+7$ 取模。", "inputFormat": "第一行有一个整数 $N$，代表矩阵的大小；\n\n接下来 $N$ 行，每行 $N$ 个整数，其中第 $i$ 行第 $j$ 列的数代表矩阵中的元素 $a_{i j}$。", "outputFormat": "若矩阵可逆，则输出 $N$ 行，每行 $N$ 个整数，其中第 $i$ 行第 $j$ 列的数代表逆矩阵中的元素 $b_{i j}$，答案对 ${10}^9+7$ 取模；\n\n否则只输出一行 `No Solution`。", "hint": "对 $30 \\%$ 的数据有 $N\\le 100$；  \n对 $100 \\%$ 的数据有 $N\\le 400$，所有 $0 \\le a_{i j} < {10}^9 + 7$。", "locale": "zh-CN"}}}
{"pid": "P4784", "type": "P", "difficulty": 6, "samples": [["4 3 6\n1 3 4\n1 2 4\n1 3 9\n1 4 6\n2 3 2\n2 4 5\n3 4 8", "11"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "枚举", "最短路", "生成树", "BalticOI（波罗的海）", "状压 DP"], "title": "[BalticOI 2016] 城市 (Day2)", "background": "", "description": "在 Byteland 有 $n$ 个城市，并且其中有 $k$ 个国王经常来访的主要城市。\n\n其中有 $m$ 条道路，每条道路连接两个城市。然而不幸的是，这些道路的环境极差使得国王无法全速驶过。\n\n对于每条道路，翻修的成本是已知的。你的任务是选择性的翻修道路使得 $k$ 个主要城市都可以经过翻修后的道路互相连通，且总成本尽量小。", "inputFormat": "第一行，三个整数 $n,k$ 和 $m$，分别表示城市的个数，主要城市的个数和道路的个数。城市的编号分别为 $1,2,\\dots,n$。\n\n第二行，$k$ 个整数，表示主要城市。\n\n接下来 $m$ 行，每行三个整数 $a,b$ 和 $c$，表示有一条双向道路从城市 $a$ 连接到城市 $b$，且翻修成本为 $c$。", "outputFormat": "输出一行，表示满足以上条件的最小的总成本。\n\n", "hint": "对于所有子任务，$1 \\leq c \\leq 10^9$ 且 $n \\geq k$。\n\n|子任务|分数|数据范围|\n|:-:|:-:|-|\n|1|22|$2 \\leq k \\leq 5,n \\leq 20,1 \\leq m \\leq 40$|\n|2|14|$2 \\leq k \\leq 3,n \\leq 10^5,1 \\leq m \\leq 2 \\cdot 10^5$|\n|3|15|$2 \\leq k \\leq 4,n \\leq 1000,1 \\leq m \\leq 2000$|\n|4|23|$k = 4,n \\leq 10^5,1 \\leq m \\leq 2 \\cdot 10^5$|\n|5|26|$k = 5,n \\leq 10^5,1 \\leq m \\leq 2 \\cdot 10^5$|\n", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2016] Cities (Day2)", "background": "", "description": "In Byteland, there are $n$ cities, and among them there are $k$ major cities that the king often visits.\n\nThere are $m$ roads, and each road connects two cities. Unfortunately, the poor condition of these roads prevents the king from driving at full speed.\n\nFor each road, the repair cost is given. Your task is to selectively repair roads so that all $k$ major cities can be connected to each other using the repaired roads, while keeping the total cost as small as possible.", "inputFormat": "The first line contains three integers $n$, $k$, and $m$, representing the number of cities, the number of major cities, and the number of roads. The cities are numbered $1,2,\\dots,n$.\n\nThe second line contains $k$ integers, representing the major cities.\n\nThe next $m$ lines each contain three integers $a$, $b$, and $c$, meaning there is a bidirectional road connecting city $a$ and city $b$, and the repair cost is $c$.", "outputFormat": "Output one line containing the minimum total cost that satisfies the above conditions.", "hint": "For all subtasks, $1 \\leq c \\leq 10^9$ and $n \\geq k$.\n\n|Subtask|Score|Constraints|\n|:-:|:-:|-|\n|1|22|$2 \\leq k \\leq 5,n \\leq 20,1 \\leq m \\leq 40$|\n|2|14|$2 \\leq k \\leq 3,n \\leq 10^5,1 \\leq m \\leq 2 \\cdot 10^5$|\n|3|15|$2 \\leq k \\leq 4,n \\leq 1000,1 \\leq m \\leq 2000$|\n|4|23|$k = 4,n \\leq 10^5,1 \\leq m \\leq 2 \\cdot 10^5$|\n|5|26|$k = 5,n \\leq 10^5,1 \\leq m \\leq 2 \\cdot 10^5$|\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2016] 城市 (Day2)", "background": "", "description": "在 Byteland 有 $n$ 个城市，并且其中有 $k$ 个国王经常来访的主要城市。\n\n其中有 $m$ 条道路，每条道路连接两个城市。然而不幸的是，这些道路的环境极差使得国王无法全速驶过。\n\n对于每条道路，翻修的成本是已知的。你的任务是选择性的翻修道路使得 $k$ 个主要城市都可以经过翻修后的道路互相连通，且总成本尽量小。", "inputFormat": "第一行，三个整数 $n,k$ 和 $m$，分别表示城市的个数，主要城市的个数和道路的个数。城市的编号分别为 $1,2,\\dots,n$。\n\n第二行，$k$ 个整数，表示主要城市。\n\n接下来 $m$ 行，每行三个整数 $a,b$ 和 $c$，表示有一条双向道路从城市 $a$ 连接到城市 $b$，且翻修成本为 $c$。", "outputFormat": "输出一行，表示满足以上条件的最小的总成本。\n\n", "hint": "对于所有子任务，$1 \\leq c \\leq 10^9$ 且 $n \\geq k$。\n\n|子任务|分数|数据范围|\n|:-:|:-:|-|\n|1|22|$2 \\leq k \\leq 5,n \\leq 20,1 \\leq m \\leq 40$|\n|2|14|$2 \\leq k \\leq 3,n \\leq 10^5,1 \\leq m \\leq 2 \\cdot 10^5$|\n|3|15|$2 \\leq k \\leq 4,n \\leq 1000,1 \\leq m \\leq 2000$|\n|4|23|$k = 4,n \\leq 10^5,1 \\leq m \\leq 2 \\cdot 10^5$|\n|5|26|$k = 5,n \\leq 10^5,1 \\leq m \\leq 2 \\cdot 10^5$|\n", "locale": "zh-CN"}}}
{"pid": "P4785", "type": "P", "difficulty": 6, "samples": [["5\n3 4 2 5 1", "2 1 3 4 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["贪心", "2016", "BalticOI（波罗的海）"], "title": "[BalticOI 2016] 交换 (Day2)", "background": "", "description": "给定一个包含 $n$ 个数的序列 $x_1,x_2,\\dots,x_n$。$1,2,\\dots,n$ 每个数在序列中刚好出现一次。  \n你可以通过交换修改这个序列。你需要进行连续的 $n-1$ 轮操作，编号 $k=2,3,\\dots,n$，第 $k$ 轮你可以选择交换 $x_k$ 和 $x_{\\lfloor k/2\\rfloor}$ 或是什么都不做。  \n如果存在一个数 $j(1 \\leq j \\leq n)$，使得对于所有 $k < j$ 且 $a_j < b_j,$ $a_k = b_k$ 成立，那么序列 $a_1\\dots a_n$ 「**字典序小于**」序列 $b_1\\dots b_n$。  \n你能得到的字典序最小的序列是什么？", "inputFormat": "第一行，一个整数 $n$。  \n第二行，$n$ 个整数，表示序列 $x_1,x_2,\\dots,x_n$。", "outputFormat": "输出 $n$ 个整数，表示你能得到的字典序最小的序列。", "hint": "|子任务|分数|数据范围|\n|:-:|:-:|-|\n|1|10|$1 \\leq n \\leq 20$|\n|2|11|$1 \\leq n \\leq 40$|\n|3|27|$1 \\leq n \\leq 1000$|\n|4|20|$1 \\leq n \\leq 5 \\cdot 10^4$|\n|5|32|$1 \\leq n \\leq 2 \\cdot 10^5$|\n", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2016] Swap (Day2)", "background": "", "description": "You are given a sequence $x_1, x_2, \\dots, x_n$ containing $n$ numbers. Each number $1, 2, \\dots, n$ appears in the sequence exactly once.  \n\nYou may modify this sequence by swapping. You must perform $n - 1$ consecutive rounds of operations, numbered $k = 2, 3, \\dots, n$. In round $k$, you may choose to swap $x_k$ and $x_{\\lfloor k/2 \\rfloor}$, or do nothing.  \n\nIf there exists a number $j$ $(1 \\leq j \\leq n)$ such that for all $k < j$, $a_k = b_k$ holds, and $a_j < b_j$, then the sequence $a_1 \\dots a_n$ is \"**lexicographically smaller**\" than the sequence $b_1 \\dots b_n$.  \n\nWhat is the lexicographically smallest sequence you can obtain?", "inputFormat": "The first line contains an integer $n$.  \nThe second line contains $n$ integers, representing the sequence $x_1, x_2, \\dots, x_n$.", "outputFormat": "Output $n$ integers, representing the lexicographically smallest sequence you can obtain.", "hint": "|Subtask|Score|Constraints|\n|:-:|:-:|-|\n|1|10|$1 \\leq n \\leq 20$|\n|2|11|$1 \\leq n \\leq 40$|\n|3|27|$1 \\leq n \\leq 1000$|\n|4|20|$1 \\leq n \\leq 5 \\cdot 10^4$|\n|5|32|$1 \\leq n \\leq 2 \\cdot 10^5$|\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2016] 交换 (Day2)", "background": "", "description": "给定一个包含 $n$ 个数的序列 $x_1,x_2,\\dots,x_n$。$1,2,\\dots,n$ 每个数在序列中刚好出现一次。  \n你可以通过交换修改这个序列。你需要进行连续的 $n-1$ 轮操作，编号 $k=2,3,\\dots,n$，第 $k$ 轮你可以选择交换 $x_k$ 和 $x_{\\lfloor k/2\\rfloor}$ 或是什么都不做。  \n如果存在一个数 $j(1 \\leq j \\leq n)$，使得对于所有 $k < j$ 且 $a_j < b_j,$ $a_k = b_k$ 成立，那么序列 $a_1\\dots a_n$ 「**字典序小于**」序列 $b_1\\dots b_n$。  \n你能得到的字典序最小的序列是什么？", "inputFormat": "第一行，一个整数 $n$。  \n第二行，$n$ 个整数，表示序列 $x_1,x_2,\\dots,x_n$。", "outputFormat": "输出 $n$ 个整数，表示你能得到的字典序最小的序列。", "hint": "|子任务|分数|数据范围|\n|:-:|:-:|-|\n|1|10|$1 \\leq n \\leq 20$|\n|2|11|$1 \\leq n \\leq 40$|\n|3|27|$1 \\leq n \\leq 1000$|\n|4|20|$1 \\leq n \\leq 5 \\cdot 10^4$|\n|5|32|$1 \\leq n \\leq 2 \\cdot 10^5$|\n", "locale": "zh-CN"}}}
{"pid": "P4786", "type": "P", "difficulty": 6, "samples": [["11\nCCCTTTTTTCC\n3\n1 11\n4 9\n1 6", "4\n6\n3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2018", "线段树", "前缀和", "BalkanOI（巴尔干半岛）"], "title": "[BalkanOI 2018] Election", "background": "", "description": "**翻译自 [BalkanOI 2018](http://boi2018.ro) Day1 T1「[Election](http://boi2018.ro/assets/Tasks/BOI/Day_1/election/elections_en.pdf)」**\n\n有一个长度为 $N$ 的字符串 $S[1\\dots N]$，它仅由 `C` 和 `T` 两种字母组成。  \n现在有 $Q$ 个查询，每个查询包含两个整数 $L$ 和 $R$，表示：设新字符串 $S'=S[L\\dots R]$，至少在 $S'$ 中要删除多少个字符，才能保证：对于 $S'$ 的每一个前缀和后缀，其 `C` 的数量都不小于 `T` 的数量。", "inputFormat": "第一行有一个整数 $N$。  \n第二行有一个长度为 $N$ 的字符串 $S$。  \n第三行有一个整数 $Q$。  \n在接下来的 $Q$ 行中，每行有两个整数 $L$ 和 $R$，表示一组查询。", "outputFormat": "对于每组查询输出一行，表示至少在 $S'$ 中要删除多少个字符，才能保证题面要求。", "hint": "#### 样例解释\n查询 1：`CCCTTTTTTCC`；  \n查询 2：`TTTTTT`；  \n查询 3：`CCCTTT`。\n\n子任务 #1（28 分）：$1 ≤ N, Q ≤ 2000$；  \n子任务 #2（54 分）：$1 ≤ N, Q ≤ 7\\times 10^4$；  \n子任务 #3（18 分）： $1 ≤ N, Q ≤ 5\\times 10^5$。\n\n感谢 Planet6174 提供的翻译", "locale": "zh-CN", "translations": {"en": {"title": "[BalkanOI 2018] Election", "background": "", "description": "**Translated from [BalkanOI 2018](http://boi2018.ro) Day 1 T1 “[Election](http://boi2018.ro/assets/Tasks/BOI/Day_1/election/elections_en.pdf)”.**\n\nThere is a string $S[1\\dots N]$ of length $N$, consisting only of the two letters `C` and `T`.  \nNow there are $Q$ queries. Each query contains two integers $L$ and $R$, meaning: let the new string be $S' = S[L\\dots R]$. What is the minimum number of characters that must be deleted from $S'$ to ensure that, for every prefix and every suffix of $S'$, the number of `C` is not less than the number of `T`?", "inputFormat": "The first line contains an integer $N$.  \nThe second line contains a string $S$ of length $N$.  \nThe third line contains an integer $Q$.  \nIn the next $Q$ lines, each line contains two integers $L$ and $R$, representing one query.", "outputFormat": "For each query, output one line: the minimum number of characters that must be deleted from $S'$ to satisfy the requirement in the statement.", "hint": "#### Sample Explanation\n\nQuery 1: `CCCTTTTTTCC`.  \nQuery 2: `TTTTTT`.  \nQuery 3: `CCCTTT`.\n\nSubtask #1 (28 points): $1 \\le N, Q \\le 2000$.  \nSubtask #2 (54 points): $1 \\le N, Q \\le 7 \\times 10^4$.  \nSubtask #3 (18 points): $1 \\le N, Q \\le 5 \\times 10^5$.\n\nThanks to Planet6174 for providing the translation.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalkanOI 2018] Election", "background": "", "description": "**翻译自 [BalkanOI 2018](http://boi2018.ro) Day1 T1「[Election](http://boi2018.ro/assets/Tasks/BOI/Day_1/election/elections_en.pdf)」**\n\n有一个长度为 $N$ 的字符串 $S[1\\dots N]$，它仅由 `C` 和 `T` 两种字母组成。  \n现在有 $Q$ 个查询，每个查询包含两个整数 $L$ 和 $R$，表示：设新字符串 $S'=S[L\\dots R]$，至少在 $S'$ 中要删除多少个字符，才能保证：对于 $S'$ 的每一个前缀和后缀，其 `C` 的数量都不小于 `T` 的数量。", "inputFormat": "第一行有一个整数 $N$。  \n第二行有一个长度为 $N$ 的字符串 $S$。  \n第三行有一个整数 $Q$。  \n在接下来的 $Q$ 行中，每行有两个整数 $L$ 和 $R$，表示一组查询。", "outputFormat": "对于每组查询输出一行，表示至少在 $S'$ 中要删除多少个字符，才能保证题面要求。", "hint": "#### 样例解释\n查询 1：`CCCTTTTTTCC`；  \n查询 2：`TTTTTT`；  \n查询 3：`CCCTTT`。\n\n子任务 #1（28 分）：$1 ≤ N, Q ≤ 2000$；  \n子任务 #2（54 分）：$1 ≤ N, Q ≤ 7\\times 10^4$；  \n子任务 #3（18 分）： $1 ≤ N, Q ≤ 5\\times 10^5$。\n\n感谢 Planet6174 提供的翻译", "locale": "zh-CN"}}}
{"pid": "P4787", "type": "P", "difficulty": 6, "samples": [["4\n1 2\n2 3\n3 4\n3\nM 1 2 1\nm 1 4 0\nM 2 3 100", "3 2 100\n1 2 1\n4 3 0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2018", "Special Judge", "BalkanOI（巴尔干半岛）"], "title": "[BalkanOI 2018] Minmaxtree", "background": "", "description": "**翻译自 [BalkanOI 2018](http://boi2018.ro) Day1 T3「[Minmaxtree](http://boi2018.ro/assets/Tasks/BOI/Day_1/minmaxtree/minmaxtree_en.pdf)」**\n\n有一棵有 $N$ 个结点的无权树，结点分别编号为 $1\\dots N$。现在要给每条边赋一个权值，使之变为一棵带权树。这棵带权树满足 $K$ 个条件，条件分为两类： \n1. $\\ \\texttt{M }x\\ y\\ z\\ \\ $ 从结点 $x$ 到结点 $y$ 的链上最大的边权为 $z$；\n2. $\\ \\texttt{m }x\\ y\\ z\\ \\ $ 从结点 $x$ 到结点 $y$ 的链上最小的边权为 $z$。\n\n**保证这 $K$ 组条件的 $z$ 互不相同。**\n\n请构造出这棵树，并输出每条边的边权。", "inputFormat": "第一行有一个整数 $N$。  \n在接下来的 $N-1$ 行中，每行两个整数，表示一条边连接的两个结点。  \n第 $N+1$ 行有一个整数 $K$。  \n在接下来的 $K$ 行中，每行开头有一个字母，字母为 $\\texttt{M}$ 或 $\\texttt{m}$，接下来有三个整数 $x, y, z$。", "outputFormat": "输出 $n-1$ 行，每行三个整数 $x, y, v$，用空格分隔，表示带权树的一条带权边。", "hint": "子任务 #1（7 分）：$1 ≤ N, z ≤ 1000$；  \n子任务 #2（22 分）：只有条件 1，没有条件 2。  \n子任务 #3（29 分）：所有条件 1 中给出的 $x$ 到 $y$ 的链互不相交；所有条件 2 中给出的 $x$ 到 $y$ 的链也互不相交。  \n子任务 #4（42 分）：没有其他限制。  \n对于所有数据，$1 ≤ N, K ≤ 70000$，$0 ≤ z ≤ 10^9$。\n\n\n\n感谢 Planet6174 提供的翻译", "locale": "zh-CN", "translations": {"en": {"title": "[BalkanOI 2018] Minmaxtree", "background": "", "description": "**Translated from [BalkanOI 2018](http://boi2018.ro) Day 1 T3 “[Minmaxtree](http://boi2018.ro/assets/Tasks/BOI/Day_1/minmaxtree/minmaxtree_en.pdf)”.**\n\nThere is an unweighted tree with $N$ nodes, numbered $1 \\dots N$. You need to assign a weight to each edge to make it a weighted tree. The weighted tree must satisfy $K$ conditions. There are two types of conditions:\n\n1. $\\ \\texttt{M }x\\ y\\ z\\ \\ $ The maximum edge weight on the path from node $x$ to node $y$ is $z$.\n2. $\\ \\texttt{m }x\\ y\\ z\\ \\ $ The minimum edge weight on the path from node $x$ to node $y$ is $z$.\n\n**It is guaranteed that the $z$ values in these $K$ conditions are all distinct.**\n\nPlease construct such a tree and output the weight of each edge.", "inputFormat": "The first line contains an integer $N$.  \nIn the next $N - 1$ lines, each line contains two integers, indicating an edge connecting two nodes.  \nLine $N + 1$ contains an integer $K$.  \nIn the next $K$ lines, each line starts with a letter $\\texttt{M}$ or $\\texttt{m}$, followed by three integers $x, y, z$.", "outputFormat": "Output $N - 1$ lines. Each line contains three integers $x, y, v$ separated by spaces, meaning an edge $(x, y)$ in the weighted tree has weight $v$.", "hint": "Subtask #1 (7 points): $1 \\le N, z \\le 1000$.  \nSubtask #2 (22 points): Only condition type 1, and no condition type 2.  \nSubtask #3 (29 points): All paths from $x$ to $y$ given in condition type 1 are pairwise edge-disjoint. All paths from $x$ to $y$ given in condition type 2 are also pairwise edge-disjoint.  \nSubtask #4 (42 points): No other restrictions.  \nFor all testdata, $1 \\le N, K \\le 70000$, $0 \\le z \\le 10^9$.\n\nThanks to Planet6174 for providing the translation.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalkanOI 2018] Minmaxtree", "background": "", "description": "**翻译自 [BalkanOI 2018](http://boi2018.ro) Day1 T3「[Minmaxtree](http://boi2018.ro/assets/Tasks/BOI/Day_1/minmaxtree/minmaxtree_en.pdf)」**\n\n有一棵有 $N$ 个结点的无权树，结点分别编号为 $1\\dots N$。现在要给每条边赋一个权值，使之变为一棵带权树。这棵带权树满足 $K$ 个条件，条件分为两类： \n1. $\\ \\texttt{M }x\\ y\\ z\\ \\ $ 从结点 $x$ 到结点 $y$ 的链上最大的边权为 $z$；\n2. $\\ \\texttt{m }x\\ y\\ z\\ \\ $ 从结点 $x$ 到结点 $y$ 的链上最小的边权为 $z$。\n\n**保证这 $K$ 组条件的 $z$ 互不相同。**\n\n请构造出这棵树，并输出每条边的边权。", "inputFormat": "第一行有一个整数 $N$。  \n在接下来的 $N-1$ 行中，每行两个整数，表示一条边连接的两个结点。  \n第 $N+1$ 行有一个整数 $K$。  \n在接下来的 $K$ 行中，每行开头有一个字母，字母为 $\\texttt{M}$ 或 $\\texttt{m}$，接下来有三个整数 $x, y, z$。", "outputFormat": "输出 $n-1$ 行，每行三个整数 $x, y, v$，用空格分隔，表示带权树的一条带权边。", "hint": "子任务 #1（7 分）：$1 ≤ N, z ≤ 1000$；  \n子任务 #2（22 分）：只有条件 1，没有条件 2。  \n子任务 #3（29 分）：所有条件 1 中给出的 $x$ 到 $y$ 的链互不相交；所有条件 2 中给出的 $x$ 到 $y$ 的链也互不相交。  \n子任务 #4（42 分）：没有其他限制。  \n对于所有数据，$1 ≤ N, K ≤ 70000$，$0 ≤ z ≤ 10^9$。\n\n\n\n感谢 Planet6174 提供的翻译", "locale": "zh-CN"}}}
{"pid": "P4788", "type": "P", "difficulty": 6, "samples": [["1\n3\n())(()\n()(()\n()))", "GRBRBG\nBBRBG\nimpossible"], ["2\n2\n6\n100", "12\n959772055"]], "limits": {"time": [300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "贪心", "2018", "Special Judge", "BalkanOI（巴尔干半岛）"], "title": "[BalkanOI 2018] Parentrises", "background": "", "description": "**翻译自 [BalkanOI 2018](http://boi2018.ro) Day2 T1「[Parentrises](http://boi2018.ro/assets/Tasks/BOI/Day_2/parentrises/parentrises_en.pdf)」**\n\n**「括号串」**是一个仅由 `(` 和 `)` 构成的字符串。如果在括号串中插入一些 `1` 和 `+` 可以将其转化为正确的表达式，该字符串就是一个**「良括号串」**。例如，`(())` 和 `(())` 是良括号串，而 `)(` 和 `(` 不是。空字符串可视为良括号串。（就是你们学 Catalan 数时学的那个啊）  \n将一个**括号串**（不是良括号串）的每个括号都涂成红绿蓝三种颜色之一，如果有一种方案同时满足：\n+ 忽略该串的所有蓝色括号后它是**良括号串**；\n+ 忽略该串的所有红色括号后它是良括号串；\n\n该串就是 **RGB 可读**的。  \n\n你会接到两类任务之一。任务类型用一个整数 $P$ 表示，$P=1$ 或 $2$。\n\n* $P=1$：你会接到 $T$ 组询问，每组询问包含一个括号串，试问该串是否 RGB 可读，如果是，请输出一种染色方案，如果否请输出 `impossible`；\n* $P=2$：你会接到 $T$ 组询问，每组询问包含一个数 $N$，试求：有多少个长度为 $N$ 的 RGB 可读的良括号串。输出答案模 $(10^9+7)$ 的结果。", "inputFormat": "第一行有一个整数 $P$。  \n第二行有一个整数 $T$。  \n+ 如果 $P=1$，在接下来的 $T$ 行中，每行有一个括号串，表示询问。\n+ 如果 $P=2$，在接下来的 $T$ 行中，每行有一个数 $N$，表示询问。", "outputFormat": "如果 $P=1$，对于每组询问，\n+ 如果该串是 RGB 可读的，请输出一种染色方案；\n+ 如果该串不是 RGB 可读的，请输出 `impossible`；\n\n如果 $P=2$，对于每组询问，请输出长度为 $N$ 的 RGB 可读的良括号串的个数模 $(10^9+7)$ 的结果。", "hint": "样例 $1$ 解释：\n\n对于查询 1，忽略原串的所有蓝色括号后它变为 `()()`；忽略原串的所有红色括号后它也变为 `()()`。\n对于查询 2，忽略原串的所有蓝色括号后它变为 `()`；忽略原串的所有红色括号后它变为 `()()`。\n\n$P = 1$：  \n设 $L$ 为字符串总长。  \n* 子任务 #1（5 分）：$1 ≤ T ≤ 5,$ $1 ≤ len(S) ≤ 13$。  \n* 子任务 #2（11 分）：$1 ≤ L ≤ 100$。  \n* 子任务 #3（6 分）：$1 ≤ L ≤ 1000$。  \n* 子任务 #4（28 分）：$1 ≤ L ≤ 10^6$。\n\n$P = 2$：\n* 子任务 #5（6 分）：$1 ≤ N, T ≤ 15$。  \n* 子任务 #6（16 分）：$1 ≤ N, T ≤ 30$。  \n* 子任务 #7（28 分）：$1 ≤ N, T ≤ 300$。\n\n感谢 Planet6174 提供的翻译", "locale": "zh-CN", "translations": {"en": {"title": "[BalkanOI 2018] Parentrises", "background": "", "description": "**Translated from [BalkanOI 2018](http://boi2018.ro) Day 2 T1 “[Parentrises](http://boi2018.ro/assets/Tasks/BOI/Day_2/parentrises/parentrises_en.pdf)”.**\n\nA **parentheses string** is a string consisting only of `(` and `)`. If inserting some `1` and `+` into a parentheses string can turn it into a correct expression, then the string is a **balanced parentheses string**. For example, `(())` and `()()` are balanced parentheses strings, while `)(` and `(` are not. The empty string is considered a balanced parentheses string. (This is the one you saw when learning Catalan numbers.)\n\nColor each parenthesis of a **parentheses string** (not necessarily balanced) with one of three colors: red, green, and blue. If there exists a coloring such that all of the following are true:\n+ After ignoring all blue parentheses in the string, it becomes a **balanced parentheses string**.\n+ After ignoring all red parentheses in the string, it becomes a balanced parentheses string.\n\nThen the string is called **RGB-readable**.\n\nYou will receive one of two types of tasks. The task type is given by an integer $P$, where $P = 1$ or $2$.\n\n* $P = 1$: You will receive $T$ queries, each containing a parentheses string. Determine whether the string is RGB-readable. If it is, output one valid coloring; otherwise output `impossible`.\n* $P = 2$: You will receive $T$ queries, each containing an integer $N$. Compute how many RGB-readable balanced parentheses strings of length $N$ there are. Output the answer modulo $(10^9+7)$.", "inputFormat": "The first line contains an integer $P$.  \nThe second line contains an integer $T$.  \n+ If $P = 1$, then in the next $T$ lines, each line contains a parentheses string representing a query.\n+ If $P = 2$, then in the next $T$ lines, each line contains an integer $N$ representing a query.", "outputFormat": "If $P = 1$, for each query:\n+ If the string is RGB-readable, output one valid coloring.\n+ If the string is not RGB-readable, output `impossible`.\n\nIf $P = 2$, for each query, output the number of RGB-readable balanced parentheses strings of length $N$ modulo $(10^9+7)$.", "hint": "Explanation for Sample $1$:\n\nFor query 1, after ignoring all blue parentheses, the original string becomes `()()`; after ignoring all red parentheses, it also becomes `()()`.  \nFor query 2, after ignoring all blue parentheses, it becomes `()`; after ignoring all red parentheses, it becomes `()()`.\n\nConstraints for $P = 1$:  \nLet $L$ be the total length of all strings.  \n* Subtask #1 (5 points): $1 \\le T \\le 5$, $1 \\le len(S) \\le 13$.\n* Subtask #2 (11 points): $1 \\le L \\le 100$.\n* Subtask #3 (6 points): $1 \\le L \\le 1000$.\n* Subtask #4 (28 points): $1 \\le L \\le 10^6$.\n\nConstraints for $P = 2$:\n* Subtask #5 (6 points): $1 \\le N, T \\le 15$.\n* Subtask #6 (16 points): $1 \\le N, T \\le 30$.\n* Subtask #7 (28 points): $1 \\le N, T \\le 300$.\n\nThanks to Planet6174 for providing the translation.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalkanOI 2018] Parentrises", "background": "", "description": "**翻译自 [BalkanOI 2018](http://boi2018.ro) Day2 T1「[Parentrises](http://boi2018.ro/assets/Tasks/BOI/Day_2/parentrises/parentrises_en.pdf)」**\n\n**「括号串」**是一个仅由 `(` 和 `)` 构成的字符串。如果在括号串中插入一些 `1` 和 `+` 可以将其转化为正确的表达式，该字符串就是一个**「良括号串」**。例如，`(())` 和 `(())` 是良括号串，而 `)(` 和 `(` 不是。空字符串可视为良括号串。（就是你们学 Catalan 数时学的那个啊）  \n将一个**括号串**（不是良括号串）的每个括号都涂成红绿蓝三种颜色之一，如果有一种方案同时满足：\n+ 忽略该串的所有蓝色括号后它是**良括号串**；\n+ 忽略该串的所有红色括号后它是良括号串；\n\n该串就是 **RGB 可读**的。  \n\n你会接到两类任务之一。任务类型用一个整数 $P$ 表示，$P=1$ 或 $2$。\n\n* $P=1$：你会接到 $T$ 组询问，每组询问包含一个括号串，试问该串是否 RGB 可读，如果是，请输出一种染色方案，如果否请输出 `impossible`；\n* $P=2$：你会接到 $T$ 组询问，每组询问包含一个数 $N$，试求：有多少个长度为 $N$ 的 RGB 可读的良括号串。输出答案模 $(10^9+7)$ 的结果。", "inputFormat": "第一行有一个整数 $P$。  \n第二行有一个整数 $T$。  \n+ 如果 $P=1$，在接下来的 $T$ 行中，每行有一个括号串，表示询问。\n+ 如果 $P=2$，在接下来的 $T$ 行中，每行有一个数 $N$，表示询问。", "outputFormat": "如果 $P=1$，对于每组询问，\n+ 如果该串是 RGB 可读的，请输出一种染色方案；\n+ 如果该串不是 RGB 可读的，请输出 `impossible`；\n\n如果 $P=2$，对于每组询问，请输出长度为 $N$ 的 RGB 可读的良括号串的个数模 $(10^9+7)$ 的结果。", "hint": "样例 $1$ 解释：\n\n对于查询 1，忽略原串的所有蓝色括号后它变为 `()()`；忽略原串的所有红色括号后它也变为 `()()`。\n对于查询 2，忽略原串的所有蓝色括号后它变为 `()`；忽略原串的所有红色括号后它变为 `()()`。\n\n$P = 1$：  \n设 $L$ 为字符串总长。  \n* 子任务 #1（5 分）：$1 ≤ T ≤ 5,$ $1 ≤ len(S) ≤ 13$。  \n* 子任务 #2（11 分）：$1 ≤ L ≤ 100$。  \n* 子任务 #3（6 分）：$1 ≤ L ≤ 1000$。  \n* 子任务 #4（28 分）：$1 ≤ L ≤ 10^6$。\n\n$P = 2$：\n* 子任务 #5（6 分）：$1 ≤ N, T ≤ 15$。  \n* 子任务 #6（16 分）：$1 ≤ N, T ≤ 30$。  \n* 子任务 #7（28 分）：$1 ≤ N, T ≤ 300$。\n\n感谢 Planet6174 提供的翻译", "locale": "zh-CN"}}}
{"pid": "P4789", "type": "P", "difficulty": 4, "samples": [["5 1\n29 27 25 25 28", "29 27 25 25 26 28\n"], ["1 5\n29", "29 28 27 26 25 25\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2018", "Special Judge", "BalkanOI（巴尔干半岛）"], "title": "[BalkanOI 2018] Zalmoxis", "background": "", "description": "**翻译自 [BalkanOI 2018](http://boi2018.ro) Day2 T3「[Zalmoxis](http://boi2018.ro/assets/Tasks/BOI/Day_2/zalmoxis/zalmoxis_en.pdf)」**\n\n**「ZalPunch」** 是一种修改数列的方式，每次 ZalPunch 可以将数列中的任意一个正整数 $x$ 原地替换成两个 $(x-1)$。  \n* 正确示范：$[1, 1]\\xrightarrow{ZalPunch}[0, 0, 1]$；  \n* 正确示范：$[1,23,3]\\xrightarrow{ZalPunch}[1,22,22,3]$；  \n* 错误示范：$[1,3]\\xrightarrow{ZalPunch}[2,1,2]$（第一个 2 不在原位）。\n\n从数列 $[30]$ 开始，用 ZalPunch 修改该数列任意多次，所得到的所有数列都称为 **「ZalSequence」**（含数列 $[30]$）。  \n给你一个有 $N$ 项的数列 $S$，请在其中插入 $K$ 个数（不是使用 $K$ 次 ZalPunch），使之变成 ZalSequence。保证有解。", "inputFormat": "第一行有两个整数 $N, K$。  \n第二行有 $N$ 个整数，表示数列 $S$。", "outputFormat": "输出 $N+K$ 个整数，表示新数列。", "hint": "#### 样例解释 1\n$[30] → [29, 29] →[29, 28, 28] →[29, 27, 27, 28] $ $→[29, 27, 26, 26, 28] $ $→ [29, 27, 25, 25, 26, 28]$\n\n#### 样例解释 2\n$[30] → [29, 29] →[29, 28, 28] →[29, 28, 27, 27] $ $→[29, 28, 27, 26, 26] $ $→[29, 28, 27, 26, 25, 25]$\n\n对于 $30\\%$ 的数据，$K=1$。  \n对于所有数据，$1 ≤ N,K ≤ 10^6, $ $1 ≤ N + K ≤ 10^6$。\n\n\n感谢 Planet6174 提供的翻译\n\n感谢 @tiger2005 提供的 SPJ", "locale": "zh-CN", "translations": {"en": {"title": "[BalkanOI 2018] Zalmoxis", "background": "", "description": "**Translated from [BalkanOI 2018](http://boi2018.ro) Day 2 T3 “[Zalmoxis](http://boi2018.ro/assets/Tasks/BOI/Day_2/zalmoxis/zalmoxis_en.pdf)”.**\n\n**“ZalPunch”** is a way to modify a sequence. Each time you perform a ZalPunch, you can take any non-negative integer $x$ in the sequence and replace it in place with two $(x-1)$.  \n* Correct example: $[1, 1]\\xrightarrow{ZalPunch}[0, 0, 1]$;  \n* Correct example: $[1,23,3]\\xrightarrow{ZalPunch}[1,22,22,3]$;  \n* Wrong example: $[1,3]\\xrightarrow{ZalPunch}[2,1,2]$ (the first $2$ is not in the original position).\n\nStarting from the sequence $[30]$, all sequences that can be obtained by applying ZalPunch any number of times are called **“ZalSequence”** (including $[30]$).  \nYou are given a sequence $S$ with $N$ elements. Insert $K$ numbers into it (not performing ZalPunch $K$ times) so that it becomes a ZalSequence. It is guaranteed that a solution exists.", "inputFormat": "The first line contains two integers $N, K$.  \nThe second line contains $N$ integers, representing the sequence $S$.", "outputFormat": "Output $N+K$ integers, representing the new sequence.", "hint": "#### Sample Explanation 1\n\n$[30] → [29, 29] →[29, 28, 28] →[29, 27, 27, 28]$ $→[29, 27, 26, 26, 28]$ $→ [29, 27, 25, 25, 26, 28]$.\n\n#### Sample Explanation 2\n\n$[30] → [29, 29] →[29, 28, 28] →[29, 28, 27, 27]$ $→[29, 28, 27, 26, 26]$ $→[29, 28, 27, 26, 25, 25]$.\n\nFor $30\\%$ of the testdata, $K=1$.  \nFor all testdata, $1 ≤ N,K ≤ 10^6,$ $1 ≤ N + K ≤ 10^6$.\n\nThanks to Planet6174 for providing the translation.  \n\nThanks to @tiger2005 for providing the SPJ.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalkanOI 2018] Zalmoxis", "background": "", "description": "**翻译自 [BalkanOI 2018](http://boi2018.ro) Day2 T3「[Zalmoxis](http://boi2018.ro/assets/Tasks/BOI/Day_2/zalmoxis/zalmoxis_en.pdf)」**\n\n**「ZalPunch」** 是一种修改数列的方式，每次 ZalPunch 可以将数列中的任意一个正整数 $x$ 原地替换成两个 $(x-1)$。  \n* 正确示范：$[1, 1]\\xrightarrow{ZalPunch}[0, 0, 1]$；  \n* 正确示范：$[1,23,3]\\xrightarrow{ZalPunch}[1,22,22,3]$；  \n* 错误示范：$[1,3]\\xrightarrow{ZalPunch}[2,1,2]$（第一个 2 不在原位）。\n\n从数列 $[30]$ 开始，用 ZalPunch 修改该数列任意多次，所得到的所有数列都称为 **「ZalSequence」**（含数列 $[30]$）。  \n给你一个有 $N$ 项的数列 $S$，请在其中插入 $K$ 个数（不是使用 $K$ 次 ZalPunch），使之变成 ZalSequence。保证有解。", "inputFormat": "第一行有两个整数 $N, K$。  \n第二行有 $N$ 个整数，表示数列 $S$。", "outputFormat": "输出 $N+K$ 个整数，表示新数列。", "hint": "#### 样例解释 1\n$[30] → [29, 29] →[29, 28, 28] →[29, 27, 27, 28] $ $→[29, 27, 26, 26, 28] $ $→ [29, 27, 25, 25, 26, 28]$\n\n#### 样例解释 2\n$[30] → [29, 29] →[29, 28, 28] →[29, 28, 27, 27] $ $→[29, 28, 27, 26, 26] $ $→[29, 28, 27, 26, 25, 25]$\n\n对于 $30\\%$ 的数据，$K=1$。  \n对于所有数据，$1 ≤ N,K ≤ 10^6, $ $1 ≤ N + K ≤ 10^6$。\n\n\n感谢 Planet6174 提供的翻译\n\n感谢 @tiger2005 提供的 SPJ", "locale": "zh-CN"}}}
{"pid": "P4790", "type": "P", "difficulty": 6, "samples": [["8\nleonard emmy\nada emmy\nisaac leonard\nemmy pierre\npierre bernhard\nbernhard emmy\nsofia karl\nkarl sofia", "3\n"], ["4\na c\nb c\nc d\nd d", "3\n"], ["3\nrocky scarlet\nscarlet patrick\npatrick rocky", "-1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000, 768000]}, "tags": ["动态规划 DP", "贪心", "2018", "深度优先搜索 DFS", "BalticOI（波罗的海）"], "title": "[BalticOI 2018] 多角恋", "background": "", "description": "**题目译自 [BalticOI 2018](https://boi2018.progolymp.se/tasks/) Day1「[Love Polygon](https://boi18-day1-open.kattis.com/problems/boi18.polygon)」**\n\n给一张 $N$ 个点的有向图，每个点的出度为 $1$。每次可以花费 $1$ 的代价修改图上的一条边的终点，也就是改变从一个点出发所到达的点。求最少需要花费多少代价，才能使这张图形成若干个两两不相交的二元环，并且图上的所有点都在某一个环里。", "inputFormat": "第一行包含一个整数 $N$。\n\n接下来的 $N$ 行每行包含两个字符串 $s$ 和 $t$，表示图中存在一条 $s\\rightarrow t$ 的边。\n\n字符串只包含小写英文字母，且长度不超过 $10$。", "outputFormat": "输出一个整数，表示最少需要花费多少代价，才能使这张图形成若干个两两不相交的二元环，并且图上的所有点都在某一个环里。无解请输出 $-1$。", "hint": "#### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1ojydan1.png)\n\n唯一的最优解如上图所示，图的上半部分为原图，底色为粉色的三个点为需要修改的边的起点；图的下半部分表示修改后的情况。\n\n#### 样例 2 解释\n\n存在多组最优解。其中一种是分别改变一条以 ``a``、``b`` 和 ``d`` 为起点的边，使他们分别连接到 ``b``、``a`` 和 `c`。\n\n#### 样例 3 解释\n\n图中有 $3$ 个点，无论如何修改边的终点，总会有一个人不在环里。\n\n\n| 子任务 | 分值 | 数据范围 | 附加限制 |\n|:----------:|:-------:|:-------------:|:-------------:|\n|$1$|$21$|$2\\leqslant N\\leqslant 20$|.|\n|$2$|$25$|$2\\leqslant N\\leqslant 100\\, 000$|每个点都有一条入边（可能有自环）|\n|$3$|$29$|$2\\leqslant N\\leqslant 100\\, 000$|不存在两个点或更多个点构成的环|\n|$4$|$25$|$2\\leqslant N\\leqslant 100\\, 000$|.|\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2018] Love Polygon", "background": "", "description": "**This problem is translated from [BalticOI 2018](https://boi2018.progolymp.se/tasks/) Day 1 “[Love Polygon](https://boi18-day1-open.kattis.com/problems/boi18.polygon)”.**\n\nYou are given a directed graph with $N$ vertices, where each vertex has out-degree $1$. Each time, you may pay a cost of $1$ to change the destination of one edge in the graph, i.e., change which vertex is reached from a given starting vertex. Find the minimum total cost needed to make the graph become several pairwise disjoint 2-cycles, and every vertex in the graph must belong to some cycle.", "inputFormat": "The first line contains an integer $N$.\n\nThe next $N$ lines each contain two strings $s$ and $t$, meaning there is an edge $s\\rightarrow t$ in the graph.\n\nEach string contains only lowercase English letters and has length at most $10$.", "outputFormat": "Output one integer, the minimum total cost needed to make the graph become several pairwise disjoint 2-cycles, and every vertex in the graph must belong to some cycle. If there is no solution, output $-1$.", "hint": "#### Explanation for Sample 1\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1ojydan1.png)\n\nThe only optimal solution is shown in the figure above. The upper part is the original graph, and the three vertices with a pink background are the starting vertices of the edges that need to be modified. The lower part shows the graph after the modifications.\n\n#### Explanation for Sample 2\n\nThere are multiple optimal solutions. One of them is to change the edges starting from ``a``, ``b``, and ``d``, so that they connect to ``b``, ``a``, and `c`, respectively.\n\n#### Explanation for Sample 3\n\nThere are $3$ vertices in the graph. No matter how you change the destinations of edges, there will always be one person not in any cycle.\n\n| Subtask | Score | Constraints | Additional Limit |\n|:----------:|:-------:|:-------------:|:-------------:|\n|$1$|$21$|$2\\leqslant N\\leqslant 20$|.|\n|$2$|$25$|$2\\leqslant N\\leqslant 100\\, 000$|Each vertex has one incoming edge (self-loops may exist).|\n|$3$|$29$|$2\\leqslant N\\leqslant 100\\, 000$|There is no cycle consisting of two or more vertices.|\n|$4$|$25$|$2\\leqslant N\\leqslant 100\\, 000$|.|\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2018] 多角恋", "background": "", "description": "**题目译自 [BalticOI 2018](https://boi2018.progolymp.se/tasks/) Day1「[Love Polygon](https://boi18-day1-open.kattis.com/problems/boi18.polygon)」**\n\n给一张 $N$ 个点的有向图，每个点的出度为 $1$。每次可以花费 $1$ 的代价修改图上的一条边的终点，也就是改变从一个点出发所到达的点。求最少需要花费多少代价，才能使这张图形成若干个两两不相交的二元环，并且图上的所有点都在某一个环里。", "inputFormat": "第一行包含一个整数 $N$。\n\n接下来的 $N$ 行每行包含两个字符串 $s$ 和 $t$，表示图中存在一条 $s\\rightarrow t$ 的边。\n\n字符串只包含小写英文字母，且长度不超过 $10$。", "outputFormat": "输出一个整数，表示最少需要花费多少代价，才能使这张图形成若干个两两不相交的二元环，并且图上的所有点都在某一个环里。无解请输出 $-1$。", "hint": "#### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1ojydan1.png)\n\n唯一的最优解如上图所示，图的上半部分为原图，底色为粉色的三个点为需要修改的边的起点；图的下半部分表示修改后的情况。\n\n#### 样例 2 解释\n\n存在多组最优解。其中一种是分别改变一条以 ``a``、``b`` 和 ``d`` 为起点的边，使他们分别连接到 ``b``、``a`` 和 `c`。\n\n#### 样例 3 解释\n\n图中有 $3$ 个点，无论如何修改边的终点，总会有一个人不在环里。\n\n\n| 子任务 | 分值 | 数据范围 | 附加限制 |\n|:----------:|:-------:|:-------------:|:-------------:|\n|$1$|$21$|$2\\leqslant N\\leqslant 20$|.|\n|$2$|$25$|$2\\leqslant N\\leqslant 100\\, 000$|每个点都有一条入边（可能有自环）|\n|$3$|$29$|$2\\leqslant N\\leqslant 100\\, 000$|不存在两个点或更多个点构成的环|\n|$4$|$25$|$2\\leqslant N\\leqslant 100\\, 000$|.|\n\n", "locale": "zh-CN"}}}
