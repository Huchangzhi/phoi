{"pid": "P1281", "type": "P", "difficulty": 3, "samples": [["9 3\n1 2 3 4 5 6 7 8 9\n", "1 5\n6 7\n8 9\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "1998", "二分", "ICPC", "CERC"], "title": "[CERC1998] 书的复制", "background": "大多数人的错误原因：尽可能让前面的人少抄写，如果前几个人可以不写则不写，对应的人输出 `0 0` 。\n\n不过，已经修改数据，保证每个人都有活可干。", "description": "现在要把 $m$ 本有顺序的书分给 $k$ 个人复制（抄写），每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的，比如不能把第一、第三、第四本书给同一个人抄写。\n\n现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。", "inputFormat": "第一行两个整数 $m,k$。\n\n第二行 $m$ 个整数，第 $i$ 个整数表示第 $i$ 本书的页数。", "outputFormat": "共 $k$ 行，每行两个整数，第 $i$ 行表示第 $i$ 个人抄写的书的起始编号和终止编号。 $k$ 行的起始编号应该从小到大排列，如果有多解，则尽可能让前面的人少抄写。", "hint": "$1\\le k \\le m \\le 500$，所有书的页数都是正整数且不超过 $10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[CERC1998] Copying Books", "background": "Most people's mistake: try to make earlier people copy as little as possible; if the first few people can skip, then let them skip, and output `0 0` for the corresponding person. However, the testdata has been modified to ensure that everyone has work to do.", "description": "We need to distribute $m$ ordered books to $k$ people for copying. Each person has the same copying speed. A book cannot be assigned to two (or more) people. The books assigned to each person must form a contiguous block; for example, you cannot assign the 1st, 3rd, and 4th books to the same person.\n\nPlease design a plan that minimizes the total copying time. The copying time is the time taken by the person who copies the most pages.", "inputFormat": "The first line contains two integers $m,k$.\n\nThe second line contains $m$ integers. The $i$-th integer indicates the number of pages in the $i$-th book.", "outputFormat": "Output $k$ lines, each with two integers. On the $i$-th line, output the starting and ending book indices assigned to the $i$-th person. The $k$ lines’ starting indices should be in increasing order. If there are multiple solutions, make the earlier people copy as little as possible.", "hint": "Constraints: $1\\le k \\le m \\le 500$, and the number of pages of each book is a positive integer not exceeding $10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC1998] 书的复制", "background": "大多数人的错误原因：尽可能让前面的人少抄写，如果前几个人可以不写则不写，对应的人输出 `0 0` 。\n\n不过，已经修改数据，保证每个人都有活可干。", "description": "现在要把 $m$ 本有顺序的书分给 $k$ 个人复制（抄写），每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的，比如不能把第一、第三、第四本书给同一个人抄写。\n\n现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。", "inputFormat": "第一行两个整数 $m,k$。\n\n第二行 $m$ 个整数，第 $i$ 个整数表示第 $i$ 本书的页数。", "outputFormat": "共 $k$ 行，每行两个整数，第 $i$ 行表示第 $i$ 个人抄写的书的起始编号和终止编号。 $k$ 行的起始编号应该从小到大排列，如果有多解，则尽可能让前面的人少抄写。", "hint": "$1\\le k \\le m \\le 500$，所有书的页数都是正整数且不超过 $10^4$。", "locale": "zh-CN"}}}
{"pid": "P1282", "type": "P", "difficulty": 4, "samples": [["4\n6 1\n1 5\n1 3\n1 2\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "枚举", "背包 DP"], "title": "多米诺骨牌", "background": "", "description": "多米诺骨牌由上下 $2$ 个方块组成，每个方块中有 $1\\sim6$ 个点。现有排成行的上方块中点数之和记为 $S_1$，下方块中点数之和记为 $S_2$，它们的差为 $\\left|S_1-S_2\\right|$。如图，$S1=6+1+1+1=9$，$S2=1+5+3+2=11$，$\\left|S_1-S_2\\right|=2$。每个多米诺骨牌可以旋转 $180°$，使得上下两个方块互换位置。请你计算最少旋转多少次才能使多米诺骨牌上下 $2$ 行点数之差达到最小。\n\n![](https://cdn.luogu.com.cn/upload/pic/91.png)\n\n对于图中的例子，只要将最后一个多米诺骨牌旋转 $180°$，即可使上下 $2$ 行点数之差为 $0$。", "inputFormat": "输入文件的第一行是一个正整数 $n(1\\leq n\\leq 1000)$，表示多米诺骨牌数。接下来的 $n$ 行表示 $n$ 个多米诺骨牌的点数。每行有两个用空格隔开的正整数，表示多米诺骨牌上下方块中的点数 $a$ 和 $b$，且 $1\\leq a,b\\leq 6$。\n", "outputFormat": "输出文件仅一行，包含一个整数。表示求得的最小旋转次数。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Dominoes", "background": "", "description": "A domino consists of two squares, upper and lower. Each square has $1$ to $6$ pips. For a row of dominoes, let $S_1$ be the sum of pips in the upper squares and $S_2$ be the sum of pips in the lower squares. Their difference is $\\left|S_1 - S_2\\right|$. As shown in the figure, $S_1 = 6+1+1+1 = 9$, $S_2 = 1+5+3+2 = 11$, and $\\left|S_1 - S_2\\right| = 2$. Each domino can be rotated by $180°$ so that the upper and lower squares swap positions. Please compute the minimum number of rotations needed to make the difference between the two rows as small as possible.\n\n![](https://cdn.luogu.com.cn/upload/pic/91.png)\n\nFor the example in the figure, rotating only the last domino by $180°$ makes the difference between the two rows equal to $0$.", "inputFormat": "The first line contains a positive integer $n$ ($1 \\le n \\le 1000$), the number of dominoes. Each of the next $n$ lines contains two positive integers $a$ and $b$ ($1 \\le a, b \\le 6$), representing the pips on the upper and lower squares of a domino.", "outputFormat": "Output a single line containing one integer: the minimum number of rotations.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "多米诺骨牌", "background": "", "description": "多米诺骨牌由上下 $2$ 个方块组成，每个方块中有 $1\\sim6$ 个点。现有排成行的上方块中点数之和记为 $S_1$，下方块中点数之和记为 $S_2$，它们的差为 $\\left|S_1-S_2\\right|$。如图，$S1=6+1+1+1=9$，$S2=1+5+3+2=11$，$\\left|S_1-S_2\\right|=2$。每个多米诺骨牌可以旋转 $180°$，使得上下两个方块互换位置。请你计算最少旋转多少次才能使多米诺骨牌上下 $2$ 行点数之差达到最小。\n\n![](https://cdn.luogu.com.cn/upload/pic/91.png)\n\n对于图中的例子，只要将最后一个多米诺骨牌旋转 $180°$，即可使上下 $2$ 行点数之差为 $0$。", "inputFormat": "输入文件的第一行是一个正整数 $n(1\\leq n\\leq 1000)$，表示多米诺骨牌数。接下来的 $n$ 行表示 $n$ 个多米诺骨牌的点数。每行有两个用空格隔开的正整数，表示多米诺骨牌上下方块中的点数 $a$ 和 $b$，且 $1\\leq a,b\\leq 6$。\n", "outputFormat": "输出文件仅一行，包含一个整数。表示求得的最小旋转次数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1283", "type": "P", "difficulty": 5, "samples": [["7\n0 0 2 2 1\n0 2 1 6 2\n2 0 4 2 1\n1 2 4 4 2\n1 4 3 6 1\n4 0 6 4 1\n3 4 6 6 2\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [125000, 125000, 125000, 125000, 125000, 125000, 125000, 125000, 125000]}, "tags": ["搜索", "深度优先搜索 DFS", "剪枝", "拓扑排序", "状压 DP"], "title": "平板涂色", "background": "", "description": "CE 数码公司开发了一种名为自动涂色机（APM）的产品。它能用预定的颜色给一块由不同尺寸且互不覆盖的矩形构成的平板涂色。\n\n为了涂色，APM 需要使用一组刷子。每个刷子涂一种不同的颜色 $C_i$ 。APM 拿起一把有颜色 $C_i$ 的刷子，并给所有颜色为 $C_i$ 且符合下面限制的矩形涂色：\n\n![](https://cdn.luogu.com.cn/upload/pic/90.png) \n\n为了避免颜料渗漏使颜色混合，一个矩形只能在所有紧靠它上方的矩形涂色后，才能涂色。例如图中矩形 $F$ 必须在 $C$ 和 $D$ 涂色后才能涂色。注意，每一个矩形必须立刻涂满，不能只涂一部分。\n\n写一个程序求一个使 APM 拿起刷子次数最少的涂色方案。注意，如果一把刷子被拿起超过一次，则每一次都必须记入总数中。", "inputFormat": "第一行为矩形的个数 $N$。下面有 $N$ 行描述了 $N$ 个矩形。每个矩形有 $5$ 个整数描述，左上角的 $y$ 坐标和 $x$ 坐标，右下角的 $y$ 坐标和 $x$ 坐标，以及预定颜色。\n\n平板的左上角坐标总是 $(0,0)$。", "outputFormat": "一个整数，表示拿起刷子的最少次数。", "hint": "$1\\le C_i \\le 20$，$0 \\le x_i,y_i \\le 99$，$1\\le N \\le 16$。", "locale": "zh-CN", "translations": {"en": {"title": "Board Painting", "background": "", "description": "CE Digital has developed a product called the Automatic Painting Machine (APM). It can paint a board composed of non-overlapping rectangles of various sizes using predetermined colors.\n\nTo paint, the APM uses a set of brushes. Each brush paints a distinct color $C_i$. The APM picks up a brush of color $C_i$ and paints all rectangles whose color is $C_i$ and which satisfy the restriction below:\n\n![](https://cdn.luogu.com.cn/upload/pic/90.png)\n\nTo prevent paint from seeping and mixing colors, a rectangle can be painted only after all rectangles that are immediately above it have been painted. For example, in the figure, rectangle $F$ can be painted only after $C$ and $D$ have been painted. Note that each rectangle must be painted to completion immediately; you cannot paint only part of it.\n\nWrite a program to find a painting plan that minimizes the number of times the APM picks up a brush. Note that if a brush is picked up more than once, each pickup counts toward the total.", "inputFormat": "The first line contains the number of rectangles $N$. The next $N$ lines each describe one rectangle. Each rectangle is given by $5$ integers: the top-left $y$-coordinate and $x$-coordinate, the bottom-right $y$-coordinate and $x$-coordinate, and the predetermined color.\n\nThe top-left coordinate of the board is always $(0, 0)$.", "outputFormat": "Output a single integer, the minimum number of brush pickups.", "hint": "Constraints: $1 \\le C_i \\le 20$, $0 \\le x_i, y_i \\le 99$, $1 \\le N \\le 16$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "平板涂色", "background": "", "description": "CE 数码公司开发了一种名为自动涂色机（APM）的产品。它能用预定的颜色给一块由不同尺寸且互不覆盖的矩形构成的平板涂色。\n\n为了涂色，APM 需要使用一组刷子。每个刷子涂一种不同的颜色 $C_i$ 。APM 拿起一把有颜色 $C_i$ 的刷子，并给所有颜色为 $C_i$ 且符合下面限制的矩形涂色：\n\n![](https://cdn.luogu.com.cn/upload/pic/90.png) \n\n为了避免颜料渗漏使颜色混合，一个矩形只能在所有紧靠它上方的矩形涂色后，才能涂色。例如图中矩形 $F$ 必须在 $C$ 和 $D$ 涂色后才能涂色。注意，每一个矩形必须立刻涂满，不能只涂一部分。\n\n写一个程序求一个使 APM 拿起刷子次数最少的涂色方案。注意，如果一把刷子被拿起超过一次，则每一次都必须记入总数中。", "inputFormat": "第一行为矩形的个数 $N$。下面有 $N$ 行描述了 $N$ 个矩形。每个矩形有 $5$ 个整数描述，左上角的 $y$ 坐标和 $x$ 坐标，右下角的 $y$ 坐标和 $x$ 坐标，以及预定颜色。\n\n平板的左上角坐标总是 $(0,0)$。", "outputFormat": "一个整数，表示拿起刷子的最少次数。", "hint": "$1\\le C_i \\le 20$，$0 \\le x_i,y_i \\le 99$，$1\\le N \\le 16$。", "locale": "zh-CN"}}}
{"pid": "P1284", "type": "P", "difficulty": 4, "samples": [["5\n1\n1\n3\n3\n4\n", "692\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "贪心", "背包 DP"], "title": "三角形牧场", "background": "", "description": "和所有人一样，奶牛喜欢变化。它们正在设想新造型的牧场。奶牛建筑师 Hei 想建造围有漂亮白色栅栏的三角形牧场。她拥有 $n$ 块木板，每块的长度 $l_i$ 都是整数，她想用所有的木板围成一个三角形使得牧场面积最大。\n\n请帮助 Hei 小姐构造这样的牧场，并计算出这个最大牧场的面积。", "inputFormat": "第 $1$ 行：一个整数 $n$；\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i + 1)$ 行的整数 $l_i$ 表示第 $i$ 块木板的长度。", "outputFormat": "仅一个整数：最大牧场面积乘以 $100$ 然后舍尾的结果。如果无法构建，输出 $-1$。", "hint": "#### 样例输入输出 1 解释\n\n$692=\\text{舍尾后的}(100\\times\\text{三角形面积})$，此三角形为等边三角形，边长为 $4$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $3\\le n\\le40$，$1\\le l_i\\le40$。", "locale": "zh-CN", "translations": {"en": {"title": "Triangular Pasture", "background": "", "description": "Like everyone, cows enjoy variety. They are imagining a new look for their pastures. The cow architect Hei wants to build a triangular pasture enclosed by a beautiful white fence. She has $n$ boards, each with an integer length $l_i$, and she wants to use all the boards to enclose a triangle so that the pasture area is maximized.\n\nPlease help Miss Hei construct such a pasture and compute this maximum area.", "inputFormat": "Line $1$: an integer $n$.\n\nLines $2$ to $(n + 1)$: each line contains one integer. On line $(i + 1)$, the integer $l_i$ denotes the length of the $i$-th board.", "outputFormat": "A single integer: the result of multiplying the maximum pasture area by $100$ and then truncating the fractional part. If it is impossible to construct, output $-1$.", "hint": "Explanation for Sample Input/Output 1: $692=\\text{truncated}(100\\times\\text{triangle area})$, and the triangle is equilateral with side length $4$.\n\nConstraints: For $100\\%$ of the testdata, it is guaranteed that $3 \\le n \\le 40$, $1 \\le l_i \\le 40$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "三角形牧场", "background": "", "description": "和所有人一样，奶牛喜欢变化。它们正在设想新造型的牧场。奶牛建筑师 Hei 想建造围有漂亮白色栅栏的三角形牧场。她拥有 $n$ 块木板，每块的长度 $l_i$ 都是整数，她想用所有的木板围成一个三角形使得牧场面积最大。\n\n请帮助 Hei 小姐构造这样的牧场，并计算出这个最大牧场的面积。", "inputFormat": "第 $1$ 行：一个整数 $n$；\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i + 1)$ 行的整数 $l_i$ 表示第 $i$ 块木板的长度。", "outputFormat": "仅一个整数：最大牧场面积乘以 $100$ 然后舍尾的结果。如果无法构建，输出 $-1$。", "hint": "#### 样例输入输出 1 解释\n\n$692=\\text{舍尾后的}(100\\times\\text{三角形面积})$，此三角形为等边三角形，边长为 $4$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $3\\le n\\le40$，$1\\le l_i\\le40$。", "locale": "zh-CN"}}}
{"pid": "P1285", "type": "P", "difficulty": 6, "samples": [["5\n2 3 5 0\n1 4 5 3 0\n1 2 5 0\n1 2 3 0\n4 3 2 1 0\n", "3 1 3 5\n2 2 4\n"], ["5\n3 4 5 0\n1 3 5 0\n2 1 4 5 0\n2 3 5 0\n1 2 3 4 0\n", "No solution\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2001", "Special Judge", "背包 DP", "二分图", "ICPC", "NERC/NEERC"], "title": "[NEERC 2001] 队员分组", "background": null, "description": "有 $n$ 个人从 $1$ 至 $n$ 编号，相互之间有一些认识关系，你的任务是把这些人分成两组，使得：\n\n- 每个人都被分到其中一组。\n- 每个组都至少有一个人。\n- 一组中的每个人都认识其他同组成员。\n\n在满足上述条件的基础上，要求两组成员的人数之差（绝对值）尽可能小。请构造一种可行的方案。\n\n请注意，$x$ 认识 $y$ 不一定说明 $y$ 认识 $x$；$x$ 认识 $y$ 且 $y$ 认识 $z$ 不一定说明 $x$ 认识 $z$。即认识关系是单向且不可传递的。", "inputFormat": "输入的第一行是一个整数，代表总人数 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行有若干个互不相同的整数，以 $0$ 结尾，第 $(i + 1)$ 行的第 $j$ 个整数 $a_{i, j}$（$0$ 除外）代表第 $i$ 个人认识 $a_{i, j}$。", "outputFormat": "**本题存在 Special Judge**。\n\n如果无解，请输出一行一个字符串 `No solution`。\n\n如果有解，请输出两行整数，分别代表两组的成员。每行的第一个整数是该组的人数，后面**以升序**若干个整数代表该组的成员编号，数字间用空格隔开。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $2 \\leq n \\leq 100$，$1 \\leq a_{i, j} \\leq n$。\n\n#### 说明\n\n由 @zhouyonglong 提供 SPJ。", "locale": "zh-CN", "translations": {"en": {"title": "[NEERC 2001] Team them up!", "background": null, "description": "There are $n$ people numbered from $1$ to $n$, with some acquaintance relations among them. Your task is to divide these people into two groups such that:\n\n- Everyone is assigned to one of the groups.\n- Each group contains at least one person.\n- In each group, every person knows every other member in the same group.\n\nSubject to the above conditions, the absolute difference between the sizes of the two groups should be as small as possible. Please construct one feasible grouping.\n\nPlease note that $x$ knowing $y$ does not necessarily mean that $y$ knows $x$; $x$ knowing $y$ and $y$ knowing $z$ does not necessarily mean that $x$ knows $z$. That is, the acquaintance relation is directed and non-transitive.", "inputFormat": "The first line contains an integer representing the total number of people $n$.\n\nFrom line $2$ to line $(n + 1)$, each line contains several pairwise distinct integers ending with $0$. On line $(i + 1)$, the $j$-th integer $a_{i, j}$ (excluding $0$) indicates that person $i$ knows $a_{i, j}$.", "outputFormat": "This problem uses a Special Judge.\n\nIf there is no solution, output a single line containing the string `No solution`.\n\nIf there is a solution, output two lines of integers describing the two groups. On each line, the first integer is the size of that group, followed by the member indices in ascending order, separated by spaces.", "hint": "Constraints\n\nFor all test points, it is guaranteed that $2 \\leq n \\leq 100$, $1 \\leq a_{i, j} \\leq n$.\n\nExplanation\n\nSPJ provided by @zhouyonglong.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NEERC 2001] 队员分组", "background": null, "description": "有 $n$ 个人从 $1$ 至 $n$ 编号，相互之间有一些认识关系，你的任务是把这些人分成两组，使得：\n\n- 每个人都被分到其中一组。\n- 每个组都至少有一个人。\n- 一组中的每个人都认识其他同组成员。\n\n在满足上述条件的基础上，要求两组成员的人数之差（绝对值）尽可能小。请构造一种可行的方案。\n\n请注意，$x$ 认识 $y$ 不一定说明 $y$ 认识 $x$；$x$ 认识 $y$ 且 $y$ 认识 $z$ 不一定说明 $x$ 认识 $z$。即认识关系是单向且不可传递的。", "inputFormat": "输入的第一行是一个整数，代表总人数 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行有若干个互不相同的整数，以 $0$ 结尾，第 $(i + 1)$ 行的第 $j$ 个整数 $a_{i, j}$（$0$ 除外）代表第 $i$ 个人认识 $a_{i, j}$。", "outputFormat": "**本题存在 Special Judge**。\n\n如果无解，请输出一行一个字符串 `No solution`。\n\n如果有解，请输出两行整数，分别代表两组的成员。每行的第一个整数是该组的人数，后面**以升序**若干个整数代表该组的成员编号，数字间用空格隔开。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $2 \\leq n \\leq 100$，$1 \\leq a_{i, j} \\leq n$。\n\n#### 说明\n\n由 @zhouyonglong 提供 SPJ。", "locale": "zh-CN"}}}
{"pid": "P1286", "type": "P", "difficulty": 5, "samples": [["3 1269 1160 1663\n", "383 777 886\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "Special Judge"], "title": "两数之和", "background": "", "description": "我们知道从 $n$ 个非负整数中任取两个相加共有 $\\frac{n(n-1)}{2}$ 个和，现在已知这 $\\frac{n(n-1)}{2}$ 个和值，要求 $n$ 个非负整数。", "inputFormat": "输入文件有若干行，每行一组数据，包含 $\\frac{n(n-1)}{2}+1$ 个空格隔开的非负整数，其中第一个数表示 $n$（$2<n<10$），其余 $\\frac{n(n-1)}{2}$ 个数表示和值，每个数不超过 $100000$。文件末以 `EOF` 结尾。\n", "outputFormat": "输出文件若干行，对应每一个输入，该行按从小到大的次序依次输出一组满足要求的 $n$ 个非负整数，相邻两个整数之间用一个空格隔开；若问题无解则输出 `Impossible`。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Sum of Two Numbers", "background": "", "description": "We know that taking any two from $n$ non-negative integers and adding them yields $\\frac{n(n-1)}{2}$ sums. Now, given these $\\frac{n(n-1)}{2}$ sums, determine the $n$ non-negative integers.", "inputFormat": "The input contains multiple lines. Each line is one dataset, consisting of $\\frac{n(n-1)}{2} + 1$ non-negative integers separated by spaces. The first number denotes $n$ ($2 < n < 10$). The remaining $\\frac{n(n-1)}{2}$ numbers are the pairwise sums. Each number does not exceed $100000$. The file ends with `EOF`.", "outputFormat": "Output multiple lines. For each input line, output one line that contains a set of $n$ non-negative integers in ascending order, separated by single spaces. If there is no solution, output `Impossible`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "两数之和", "background": "", "description": "我们知道从 $n$ 个非负整数中任取两个相加共有 $\\frac{n(n-1)}{2}$ 个和，现在已知这 $\\frac{n(n-1)}{2}$ 个和值，要求 $n$ 个非负整数。", "inputFormat": "输入文件有若干行，每行一组数据，包含 $\\frac{n(n-1)}{2}+1$ 个空格隔开的非负整数，其中第一个数表示 $n$（$2<n<10$），其余 $\\frac{n(n-1)}{2}$ 个数表示和值，每个数不超过 $100000$。文件末以 `EOF` 结尾。\n", "outputFormat": "输出文件若干行，对应每一个输入，该行按从小到大的次序依次输出一组满足要求的 $n$ 个非负整数，相邻两个整数之间用一个空格隔开；若问题无解则输出 `Impossible`。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1287", "type": "P", "difficulty": 2, "samples": [["3 2\n", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "枚举", "容斥原理", "Stirling 数"], "title": "盒子与球", "background": "", "description": "现有 $r$ 个互不相同的盒子和 $n$ 个互不相同的球，要将这 $n$ 个球放入 $r$ 个盒子中，且不允许有空盒子。请求出有多少种不同的放法。\n\n两种放法不同当且仅当存在一个球使得该球在两种放法中放入了不同的盒子。", "inputFormat": "输入只有一行两个整数，分别代表 $n$ 和 $r$。", "outputFormat": "输出一行一个整数代表答案。", "hint": "#### 样例输入输出 1 解释\n\n有两个盒子（编号为 $1, 2$）和三个球（编号为 $1, 2, 3$），共有六种方案，分别如下：\n\n| 盒子编号 |   方案 1    |   方案 2    |   方案 3    |   方案 4    |   方案 5    |   方案 6    |\n| :------: | :---------: | :---------: | :---------: | :---------: | :---------: | :---------: |\n| 盒子 $1$ |  小球 $1$   |  小球 $2$   |  小球 $3$   | 小球 $2, 3$ | 小球 $1, 3$ | 小球 $1, 2$ |\n| 盒子 $2$ | 小球 $2, 3$ | 小球 $1, 3$ | 小球 $1, 2$ |  小球 $1$   |  小球 $2$   |  小球 $3$   |\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $0 \\leq r \\leq n \\leq 10$，且答案小于 $2^{31}$。", "locale": "zh-CN", "translations": {"en": {"title": "Boxes and Balls", "background": "", "description": "There are $r$ distinct boxes and $n$ distinct balls. Put these $n$ balls into the $r$ boxes, with no box left empty. Find how many different placements there are.\n\nTwo placements are different if and only if there exists a ball that is placed into different boxes in the two placements.", "inputFormat": "The input contains one line with two integers, representing $n$ and $r$.", "outputFormat": "Output one line with a single integer representing the answer.", "hint": "#### Sample Explanation 1\n\nThere are two boxes (IDs $1, 2$) and three balls (IDs $1, 2, 3$), for a total of six arrangements, as follows:\n\n| Box ID | Arrangement 1 | Arrangement 2 | Arrangement 3 | Arrangement 4 | Arrangement 5 | Arrangement 6 |\n| :----: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: |\n| Box $1$ |   Ball $1$    |   Ball $2$    |   Ball $3$    |  Balls $2, 3$ |  Balls $1, 3$ |  Balls $1, 2$ |\n| Box $2$ |  Balls $2, 3$ |  Balls $1, 3$ |  Balls $1, 2$ |   Ball $1$    |   Ball $2$    |   Ball $3$    |\n\n#### Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that $0 \\leq r \\leq n \\leq 10$, and the answer is less than $2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "盒子与球", "background": "", "description": "现有 $r$ 个互不相同的盒子和 $n$ 个互不相同的球，要将这 $n$ 个球放入 $r$ 个盒子中，且不允许有空盒子。请求出有多少种不同的放法。\n\n两种放法不同当且仅当存在一个球使得该球在两种放法中放入了不同的盒子。", "inputFormat": "输入只有一行两个整数，分别代表 $n$ 和 $r$。", "outputFormat": "输出一行一个整数代表答案。", "hint": "#### 样例输入输出 1 解释\n\n有两个盒子（编号为 $1, 2$）和三个球（编号为 $1, 2, 3$），共有六种方案，分别如下：\n\n| 盒子编号 |   方案 1    |   方案 2    |   方案 3    |   方案 4    |   方案 5    |   方案 6    |\n| :------: | :---------: | :---------: | :---------: | :---------: | :---------: | :---------: |\n| 盒子 $1$ |  小球 $1$   |  小球 $2$   |  小球 $3$   | 小球 $2, 3$ | 小球 $1, 3$ | 小球 $1, 2$ |\n| 盒子 $2$ | 小球 $2, 3$ | 小球 $1, 3$ | 小球 $1, 2$ |  小球 $1$   |  小球 $2$   |  小球 $3$   |\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $0 \\leq r \\leq n \\leq 10$，且答案小于 $2^{31}$。", "locale": "zh-CN"}}}
{"pid": "P1288", "type": "P", "difficulty": 2, "samples": [["4\n2 5 3 0\n", "YES\n"], ["3\n0 0 0\n", "NO\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "博弈论"], "title": "取数游戏 II", "background": "", "description": "有一个取数的游戏。初始时，给出一个环，环上的每条边上都有一个非负整数。这些整数中至少有一个 $0$。然后，将一枚硬币放在环上的一个节点上。两个玩家就是以这个放硬币的节点为起点开始这个游戏，两人轮流取数，取数的规则如下：\n\n1.  选择硬币左边或者右边的一条边，并且边上的数非 $0$；\n1.  将这条边上的数减至任意一个非负整数（至少要有所减小）；\n1.  将硬币移至边的另一端。\n\n如果轮到一个玩家走，这时硬币左右两边的边上的数值都是 $0$，那么这个玩家就输了。\n\n如下图，描述的是 Alice 和 Bob 两人的对弈过程（其中黑色节点表示硬币所在节点）。\n\n ![](https://cdn.luogu.com.cn/upload/pic/93.png) \n\n各图的结果为：\n\n- $\\text{A}$：轮到 Alice 操作；\n- $\\text{B}$：轮到 Bob 操作；\n- $\\text{C}$：轮到 Alice 操作；\n- $\\text{D}$：轮到 Bob 操作。\n\n$\\text{D}$ 中，轮到 Bob 走时，硬币两边的边上都是 $0$，所以 Alice 获胜。\n\n现在，你的任务就是根据给出的环、边上的数值以及起点（硬币所在位置），判断先走方是否有必胜的策略。", "inputFormat": "第一行一个整数 $N$ $(N \\leq 20)$，表示环上的节点数。\n\n第二行 $N$ 个数，数值不超过 $30$，依次表示 $N$ 条边上的数值。硬币的起始位置在第一条边与最后一条边之间的节点上。", "outputFormat": "仅一行。若存在必胜策略，则输出 ```YES```，否则输出 ```NO```。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Number Picking Game II", "background": "", "description": "There is a number-picking game. Initially, you are given a ring; each edge on the ring has a non-negative integer on it. Among these integers, at least one is $0$. Then, a coin is placed on a node of the ring. Starting from this node, two players take turns according to the following rules:\n\n1. Choose one of the two edges adjacent to the coin (left or right), and its number must be non-zero.\n2. Decrease the number on that edge to any non-negative integer (it must strictly decrease).\n3. Move the coin to the other endpoint of that edge.\n\nIf it is a player's turn and the numbers on both edges adjacent to the coin are $0$, then that player loses.\n\nAs shown below is a sequence of moves between Alice and Bob (the black node marks the coin's position).\n\n![](https://cdn.luogu.com.cn/upload/pic/93.png)\n\nThe results of the panels are:\n\n- $\\text{A}$: Alice to move.\n- $\\text{B}$: Bob to move.\n- $\\text{C}$: Alice to move.\n- $\\text{D}$: Bob to move.\n\nIn $\\text{D}$, when it is Bob's turn, both adjacent edges have number $0$, so Alice wins.\n\nYour task is to determine, given the ring, the edge values, and the starting node (the coin's position), whether the first player has a forced winning strategy.", "inputFormat": "The first line contains an integer $N$ $(N \\leq 20)$, the number of nodes on the ring.\n\nThe second line contains $N$ integers, each not exceeding $30$, giving the values on the $N$ edges in order. The coin initially sits on the node between the first edge and the last edge.", "outputFormat": "Output a single line. If there exists a winning strategy, output ```YES```, otherwise output ```NO```.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "取数游戏 II", "background": "", "description": "有一个取数的游戏。初始时，给出一个环，环上的每条边上都有一个非负整数。这些整数中至少有一个 $0$。然后，将一枚硬币放在环上的一个节点上。两个玩家就是以这个放硬币的节点为起点开始这个游戏，两人轮流取数，取数的规则如下：\n\n1.  选择硬币左边或者右边的一条边，并且边上的数非 $0$；\n1.  将这条边上的数减至任意一个非负整数（至少要有所减小）；\n1.  将硬币移至边的另一端。\n\n如果轮到一个玩家走，这时硬币左右两边的边上的数值都是 $0$，那么这个玩家就输了。\n\n如下图，描述的是 Alice 和 Bob 两人的对弈过程（其中黑色节点表示硬币所在节点）。\n\n ![](https://cdn.luogu.com.cn/upload/pic/93.png) \n\n各图的结果为：\n\n- $\\text{A}$：轮到 Alice 操作；\n- $\\text{B}$：轮到 Bob 操作；\n- $\\text{C}$：轮到 Alice 操作；\n- $\\text{D}$：轮到 Bob 操作。\n\n$\\text{D}$ 中，轮到 Bob 走时，硬币两边的边上都是 $0$，所以 Alice 获胜。\n\n现在，你的任务就是根据给出的环、边上的数值以及起点（硬币所在位置），判断先走方是否有必胜的策略。", "inputFormat": "第一行一个整数 $N$ $(N \\leq 20)$，表示环上的节点数。\n\n第二行 $N$ 个数，数值不超过 $30$，依次表示 $N$ 条边上的数值。硬币的起始位置在第一条边与最后一条边之间的节点上。", "outputFormat": "仅一行。若存在必胜策略，则输出 ```YES```，否则输出 ```NO```。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1289", "type": "P", "difficulty": 3, "samples": [["20 3\n4 2 3 11 12\n1 7\n3 18 5 10\n", "We need 9 move operations.\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学"], "title": "磁盘碎片整理", "background": "", "description": "出于最高安全性考虑，司令部采用了特殊的安全操作系统，该系统采用一个特殊的文件系统。在这个文件系统中所有磁盘空间都被分成了相同尺寸的 $N$ 块，用整数 $1$ 到 $N$ 标识。每个文件占用磁盘上任意区域的一块或多块存储区，未被文件占用的存储块被认为是可是用的。如果文件存储在磁盘上自然连续的存储块中，则能被以最快的速度读出。\n\n因为磁盘是匀速转动的，所以存取上面不同的存储块需要的时间也不同。读取磁盘开头处的存储块比读取磁盘尾处的存储块快。根据以上现象，我们事先将文件按其存取频率的大小用整数 $1$ 到 $K$ 标识。按文件在磁盘上的最佳存储方法，$1$ 号文件将占用 $1,2,\\cdots,S_1$ 的存储块，$2$ 号文件将占用 $S_1+1,S_1+2,\\cdots, S_1+S_2$ 的存储块，以此类推（$S_i$ 是被第 $i$ 个文件占用的存储块的个数）。为了将文件以最佳形式存储在磁盘上，需要执行存储块移动操作。一个存储块移动操作包括从磁盘上读取一个被占用的存储块至内存并将它写入其他空的存储块，然后宣称前一个存储块被释放，后一个存储块被占用。\n\n本程序的目的是通过执行最少次数的存储块移动操作，将文件按最佳方式存储到磁盘上，注意同一个文件的存储块在移动之后其相对次序不可改变。", "inputFormat": "每个磁盘说明的第一行包含两个用空格隔开的整数 $N$ 和 $K(1 \\le K \\le N \\le 10^5)$，接下来的 $K$ 行每行说明一个文件，对第 $i$ 个文件的说明是这样的：首先以整数 $S_i$ 开头，表示第 $i$ 个文件的存储块数量，$1 \\le S_i \\le N-K$，然后跟 $S_i$ 个整数，每个整数之间用空格隔开，表示该文件按自然顺序在磁盘上占用的存储块的标识。所有这些数都介于 $1$ 和 $N$ 之间，包括 $1$ 和 $N$。一个磁盘说明中所有存储块的标识都是不同的，并且该盘至少有一个空的存储块。", "outputFormat": "对于每一个磁盘说明，只需输出一行句子 $\\text{``\\texttt{We need \\textrm{\\textit{M}} move operations.}''}$，$M$ 表示将文件按最佳方式存储到磁盘上所需进行的最少存储块移动操作次数。如果文件已按最佳方式存储，仅需输出 $\\text{``\\texttt{No optimization needed.}''}$。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Disk Defragmentation", "background": "", "description": "For maximum security, the headquarters uses a special secure operating system with a special file system. In this file system, all disk space is divided into $N$ blocks of equal size, labeled with integers $1$ to $N$. Each file occupies one or more blocks located in arbitrary regions of the disk, and blocks not occupied by any file are considered available. If a file is stored in physically contiguous blocks on the disk, it can be read at the highest speed.\n\nBecause the disk rotates at a constant speed, the time needed to access different blocks varies. Reading blocks near the beginning of the disk is faster than reading blocks near the end. Based on this, files are pre-labeled by their access frequency with integers $1$ to $K$. In the optimal placement on the disk, file $1$ occupies blocks $1, 2, \\cdots, S_1$, file $2$ occupies blocks $S_1 + 1, S_1 + 2, \\cdots, S_1 + S_2$, and so on (where $S_i$ is the number of blocks occupied by file $i$). To store files in their optimal form, block move operations may be performed. One block move operation consists of reading an occupied block from the disk into memory and writing it to some other empty block, then marking the former block free and the latter block occupied.\n\nThe goal is to store the files in the optimal way using the minimum number of block move operations. Note that the relative order of the blocks within the same file must not change after moving.", "inputFormat": "Each disk description starts with a line containing two integers $N$ and $K$ ($1 \\le K \\le N \\le 10^5$). The next $K$ lines each describe one file. For file $i$, the description begins with an integer $S_i$, the number of blocks of this file ($1 \\le S_i \\le N - K$), followed by $S_i$ integers separated by spaces, giving the block IDs that the file currently occupies on the disk in natural order. All these numbers are between $1$ and $N$, inclusive. Within one disk description, all occupied block IDs are distinct, and there is at least one empty block.\n\nThere may be multiple disk descriptions; process all of them until EOF.", "outputFormat": "For each disk description, output a single line\n$\\text{``\\texttt{We need \\textrm{\\textit{M}} move operations.}''}$,\nwhere $M$ is the minimum number of block move operations required to store the files in the optimal way. If the files are already in the optimal placement, output\n$\\text{``\\texttt{No optimization needed.}''}$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "磁盘碎片整理", "background": "", "description": "出于最高安全性考虑，司令部采用了特殊的安全操作系统，该系统采用一个特殊的文件系统。在这个文件系统中所有磁盘空间都被分成了相同尺寸的 $N$ 块，用整数 $1$ 到 $N$ 标识。每个文件占用磁盘上任意区域的一块或多块存储区，未被文件占用的存储块被认为是可是用的。如果文件存储在磁盘上自然连续的存储块中，则能被以最快的速度读出。\n\n因为磁盘是匀速转动的，所以存取上面不同的存储块需要的时间也不同。读取磁盘开头处的存储块比读取磁盘尾处的存储块快。根据以上现象，我们事先将文件按其存取频率的大小用整数 $1$ 到 $K$ 标识。按文件在磁盘上的最佳存储方法，$1$ 号文件将占用 $1,2,\\cdots,S_1$ 的存储块，$2$ 号文件将占用 $S_1+1,S_1+2,\\cdots, S_1+S_2$ 的存储块，以此类推（$S_i$ 是被第 $i$ 个文件占用的存储块的个数）。为了将文件以最佳形式存储在磁盘上，需要执行存储块移动操作。一个存储块移动操作包括从磁盘上读取一个被占用的存储块至内存并将它写入其他空的存储块，然后宣称前一个存储块被释放，后一个存储块被占用。\n\n本程序的目的是通过执行最少次数的存储块移动操作，将文件按最佳方式存储到磁盘上，注意同一个文件的存储块在移动之后其相对次序不可改变。", "inputFormat": "每个磁盘说明的第一行包含两个用空格隔开的整数 $N$ 和 $K(1 \\le K \\le N \\le 10^5)$，接下来的 $K$ 行每行说明一个文件，对第 $i$ 个文件的说明是这样的：首先以整数 $S_i$ 开头，表示第 $i$ 个文件的存储块数量，$1 \\le S_i \\le N-K$，然后跟 $S_i$ 个整数，每个整数之间用空格隔开，表示该文件按自然顺序在磁盘上占用的存储块的标识。所有这些数都介于 $1$ 和 $N$ 之间，包括 $1$ 和 $N$。一个磁盘说明中所有存储块的标识都是不同的，并且该盘至少有一个空的存储块。", "outputFormat": "对于每一个磁盘说明，只需输出一行句子 $\\text{``\\texttt{We need \\textrm{\\textit{M}} move operations.}''}$，$M$ 表示将文件按最佳方式存储到磁盘上所需进行的最少存储块移动操作次数。如果文件已按最佳方式存储，仅需输出 $\\text{``\\texttt{No optimization needed.}''}$。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1290", "type": "P", "difficulty": 4, "samples": [["2\n25 7\n24 15\n", "Stan wins\nOllie wins\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "博弈论", "递归"], "title": "欧几里德的游戏", "background": "", "description": "欧几里德的两个后代 Stan 和 Ollie 正在玩一种数字游戏，这个游戏是他们的祖先欧几里德发明的。给定两个正整数 $M$ 和 $N$，从 Stan 开始，从其中较大的一个数，减去较小的数的正整数倍，当然，得到的数不能小于 $0$。然后是 Ollie，对刚才得到的数，和 $M,N$ 中较小的那个数，再进行同样的操作……直到一个人得到了 $0$，他就取得了胜利。下面是他们用 $(25,7)$ 两个数游戏的过程：\n\n- 初始：$(25,7)$；\n- Stan：$(11,7)$；\n- Ollie：$(4,7)$；\n- Stan：$(4,3)$；\n- Ollie：$(1,3)$；\n- Stan：$(1,0)$。\n\nStan 赢得了游戏的胜利。\n\n现在，假设他们完美地操作，谁会取得胜利呢？", "inputFormat": "**本题有多组测试数据。**\n\n第一行为测试数据的组数 $C$。\n下面 $C$ 行，每行为一组数据，包含两个正整数 $M,N(M,N<2^{31})$。", "outputFormat": "对每组输入数据输出一行，如果 Stan 胜利，则输出 `Stan wins`；否则输出 `Ollie wins`。\n", "hint": "$1 \\leq C \\leq 6$。", "locale": "zh-CN", "translations": {"en": {"title": "Euclid's Game", "background": "", "description": "Two descendants of Euclid, Stan and Ollie, are playing a number game invented by their ancestor. Given two positive integers $M$ and $N$, starting with Stan, on each turn the player subtracts a positive multiple of the smaller number from the larger number, and the result must not be less than $0$. Then it is Ollie’s turn, using the new pair formed by the result and the other number, and the same operation is repeated. The process continues until someone makes the larger number become $0$; that player wins. The play sequence for the numbers $(25, 7)$ is as follows:\n\n- Start: $(25, 7)$.\n- Stan: $(11, 7)$.\n- Ollie: $(4, 7)$.\n- Stan: $(4, 3)$.\n- Ollie: $(1, 3)$.\n- Stan: $(1, 0)$.\n\nStan wins the game.\n\nNow, assuming both players play optimally, who will win?", "inputFormat": "**This problem contains multiple test cases.**\n\nThe first line contains the number of test cases $C$.  \nEach of the next $C$ lines contains one test case with two positive integers $M,N(M,N<2^{31})$.", "outputFormat": "For each test case, output one line. If Stan wins, output `Stan wins`; otherwise output `Ollie wins`.", "hint": "$1 \\leq C \\leq 6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "欧几里德的游戏", "background": "", "description": "欧几里德的两个后代 Stan 和 Ollie 正在玩一种数字游戏，这个游戏是他们的祖先欧几里德发明的。给定两个正整数 $M$ 和 $N$，从 Stan 开始，从其中较大的一个数，减去较小的数的正整数倍，当然，得到的数不能小于 $0$。然后是 Ollie，对刚才得到的数，和 $M,N$ 中较小的那个数，再进行同样的操作……直到一个人得到了 $0$，他就取得了胜利。下面是他们用 $(25,7)$ 两个数游戏的过程：\n\n- 初始：$(25,7)$；\n- Stan：$(11,7)$；\n- Ollie：$(4,7)$；\n- Stan：$(4,3)$；\n- Ollie：$(1,3)$；\n- Stan：$(1,0)$。\n\nStan 赢得了游戏的胜利。\n\n现在，假设他们完美地操作，谁会取得胜利呢？", "inputFormat": "**本题有多组测试数据。**\n\n第一行为测试数据的组数 $C$。\n下面 $C$ 行，每行为一组数据，包含两个正整数 $M,N(M,N<2^{31})$。", "outputFormat": "对每组输入数据输出一行，如果 Stan 胜利，则输出 `Stan wins`；否则输出 `Ollie wins`。\n", "hint": "$1 \\leq C \\leq 6$。", "locale": "zh-CN"}}}
{"pid": "P1291", "type": "P", "difficulty": 4, "samples": [["2\n", "3\n"], ["17", "  340463\n58------\n  720720"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2002", "各省省选", "上海"], "title": "[SHOI2002] 百事世界杯之旅", "background": "“……在 2002 年 6 月之前购买的百事任何饮料的瓶盖上都会有一个百事球星的名字。只要凑齐所有百事球星的名字，就可参加百事世界杯之旅的抽奖活动，获得球星背包，随声听，更可赴日韩观看世界杯。还不赶快行动！”", "description": "你关上电视，心想：假设有 $n$ 个不同的球星名字，每个名字出现的概率相同，平均需要买几瓶饮料才能凑齐所有的名字呢？", "inputFormat": "输入只有一行一个整数，表示不同球星名字的个数 $n$。", "outputFormat": "输出凑齐所有的名字平均需要买的饮料瓶数。如果是一个整数，则直接输出，否则应该直接按照分数格式输出，例如五又二十分之三应该输出为：\n\n```plain\n 3\n5--\n 20\n```\n\n第一行是分数部分的分子，第二行首先是整数部分，然后是由减号组成的分数线，第三行是分母。减号的个数应等于分母的位数。分子和分母的首位都与第一个减号对齐。\n\n分数必须是不可约的。", "hint": "### 数据规模与约定\n\n对于全部的测试点，保证 $2 \\leq n \\leq 33$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2002] Pepsi World Cup Tour", "background": "\"... Before June 2002, the cap of any Pepsi beverage will have the name of a Pepsi soccer star. As long as you collect all Pepsi soccer star names, you can enter the drawing for the Pepsi World Cup Tour, win a star backpack and a portable music player, and even go to Japan and South Korea to watch the World Cup. Hurry up!\"", "description": "You turn off the TV and think: assuming there are $n$ different star names and each name appears with equal probability, on average how many bottles do you need to buy to collect all the names?", "inputFormat": "The input contains a single integer on one line, representing the number of different star names $n$.", "outputFormat": "Output the average number of bottles needed to collect all the names. If it is an integer, print it directly. Otherwise, print it directly in fractional format. For example, five and three twentieths should be printed as:\n\n```plain\n 3\n5--\n 20\n```\n\nThe first line is the numerator of the fractional part. The second line contains the integer part first, followed by a bar made of minus signs. The third line is the denominator. The number of minus signs should equal the number of digits in the denominator. The first digit of the numerator and the first digit of the denominator must align with the first minus sign. The fraction must be in lowest terms.", "hint": "### Constraints\n\nFor all testdata, it is guaranteed that $2 \\leq n \\leq 33$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2002] 百事世界杯之旅", "background": "“……在 2002 年 6 月之前购买的百事任何饮料的瓶盖上都会有一个百事球星的名字。只要凑齐所有百事球星的名字，就可参加百事世界杯之旅的抽奖活动，获得球星背包，随声听，更可赴日韩观看世界杯。还不赶快行动！”", "description": "你关上电视，心想：假设有 $n$ 个不同的球星名字，每个名字出现的概率相同，平均需要买几瓶饮料才能凑齐所有的名字呢？", "inputFormat": "输入只有一行一个整数，表示不同球星名字的个数 $n$。", "outputFormat": "输出凑齐所有的名字平均需要买的饮料瓶数。如果是一个整数，则直接输出，否则应该直接按照分数格式输出，例如五又二十分之三应该输出为：\n\n```plain\n 3\n5--\n 20\n```\n\n第一行是分数部分的分子，第二行首先是整数部分，然后是由减号组成的分数线，第三行是分母。减号的个数应等于分母的位数。分子和分母的首位都与第一个减号对齐。\n\n分数必须是不可约的。", "hint": "### 数据规模与约定\n\n对于全部的测试点，保证 $2 \\leq n \\leq 33$。", "locale": "zh-CN"}}}
{"pid": "P1292", "type": "P", "difficulty": 4, "samples": [["5 3\r\n", "1\r\n1 2\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "扩展欧几里德算法"], "title": "倒酒", "background": null, "description": "Winy 是一家酒吧的老板，他的酒吧提供两种体积的啤酒，$a$ ml 和 $b$ ml，分别使用容积为 $a$ ml 和 $b$ ml 的酒杯来装载。\n\n酒吧的生意并不好。Winy 发现酒鬼们都非常穷。有时，他们会因为负担不起 $a$ ml 或者 $b$ ml 啤酒的消费，而不得不离去。因此，Winy 决定出售第三种体积的啤酒（较小体积的啤酒）。\n\nWiny 只有两种杯子，容积分别为 $a$ ml 和 $b$ ml，而且啤酒杯是没有刻度的。他只能通过两种杯子和酒桶间的互相倾倒来得到新的体积的酒。\n\n为了简化倒酒的步骤，Winy 规定：\n\n1.  $a \\ge b$；\n2.  酒桶容积无限大，酒桶中酒的体积也是无限大（但远小于桶的容积）；\n3. 只包含三种可能的倒酒操作：  \n   1. 将酒桶中的酒倒入容积为 $b$ ml 的酒杯中；  \n   2. 将容积为 $a$ ml 的酒杯中的酒倒入酒桶；  \n   3. 将容积为 $b$ ml 的酒杯中的酒倒入容积为 $a$ ml 的酒杯中。\n4. 每次倒酒必须把杯子倒满或把被倾倒的杯子倒空。\n\nWiny 希望通过若干次倾倒得到容积为 $a$ ml 酒杯中剩下的酒的体积尽可能小，他请求你帮助他设计倾倒的方案。", "inputFormat": "输入共一行两个整数 $a$ 和 $b$，满足 $0 < b \\le a \\le 10^9$。", "outputFormat": "第一行一个整数 $c~(c > 0)$，表示可以得到的酒的最小体积。\n\n第二行两个整数 $P_a$ 和 $P_b$（中间用一个空格分隔），分别表示从体积为 $a$ ml 的酒杯中倒出酒的次数和将酒倒入体积为 $b$ ml 的酒杯中的次数。\n\n若有多种可能的 $P_a,P_b$ 满足要求，那么请输出 $P_a$ 最小的一个。若在 $P_a$ 最小的情况下，有多个 $P_b$ 满足要求，请输出 $P_b$ 最小的一个。", "hint": "### 样例解释\n\n倾倒的方案为：\n\n1. 桶 $\\to$ B 杯；\n2. B 杯 $\\to$ A 杯；\n3. 桶 $\\to$ B 杯；\n4. B 杯 $\\to$ A 杯；\n5. A 杯 $\\to$ 桶; \n6. B 杯 $\\to$ A 杯。", "locale": "zh-CN", "translations": {"en": {"title": "Pouring Beer", "background": "", "description": "Winy is the owner of a bar. His bar offers two volumes of beer, $a$ ml and $b$ ml, served in cups with capacities $a$ ml and $b$ ml respectively.\n\nBusiness is not good. Winy finds that the drunks are very poor. Sometimes they have to leave because they cannot afford $a$ ml or $b$ ml of beer. Therefore, Winy decides to sell a third volume of beer (a smaller volume).\n\nWiny has only two cups with capacities $a$ ml and $b$ ml, and the cups have no markings. He can only obtain new volumes by pouring between the two cups and the barrel.\n\nTo simplify the pouring steps, Winy stipulates:\n1. $a≥b$.\n2. The barrel has infinite capacity, and the amount of beer in the barrel is also infinite (but much smaller than the barrel’s capacity).\n3. Only three pouring operations are allowed:\n   1. Pour beer from the barrel into the cup of capacity $b$ ml.\n   2. Pour the beer from the cup of capacity $a$ ml into the barrel.\n   3. Pour the beer from the cup of capacity $b$ ml into the cup of capacity $a$ ml.\n4. Each pour must either fill the receiving cup to full or empty the source cup completely.\n\nWiny hopes that after several pours, the remaining volume of beer in the $a$ ml cup is as small as possible. He asks you to help design a pouring plan.", "inputFormat": "A single line with two integers $a$ and $b$, satisfying $0<b≤a≤10^9$.", "outputFormat": "The first line contains an integer $c$, representing the minimal volume that can be obtained.\n\nThe second line contains two integers $P_a$ and $P_b$ (separated by a space), representing respectively the number of times pouring from the $a$ ml cup into the barrel and the number of times pouring into the $b$ ml cup from the barrel.\n\nIf multiple pairs $P_a,P_b$ satisfy the requirement, output the one with the smallest $P_a$. If there are still multiple choices under the smallest $P_a$, output the one with the smallest $P_b$.", "hint": "Sample explanation:\n\nThe pouring plan is:\n1. Barrel -> cup B.\n2. Cup B -> cup A.\n3. Barrel -> cup B.\n4. Cup B -> cup A.\n5. Cup A -> barrel.\n6. Cup B -> cup A.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "倒酒", "background": null, "description": "Winy 是一家酒吧的老板，他的酒吧提供两种体积的啤酒，$a$ ml 和 $b$ ml，分别使用容积为 $a$ ml 和 $b$ ml 的酒杯来装载。\n\n酒吧的生意并不好。Winy 发现酒鬼们都非常穷。有时，他们会因为负担不起 $a$ ml 或者 $b$ ml 啤酒的消费，而不得不离去。因此，Winy 决定出售第三种体积的啤酒（较小体积的啤酒）。\n\nWiny 只有两种杯子，容积分别为 $a$ ml 和 $b$ ml，而且啤酒杯是没有刻度的。他只能通过两种杯子和酒桶间的互相倾倒来得到新的体积的酒。\n\n为了简化倒酒的步骤，Winy 规定：\n\n1.  $a \\ge b$；\n2.  酒桶容积无限大，酒桶中酒的体积也是无限大（但远小于桶的容积）；\n3. 只包含三种可能的倒酒操作：  \n   1. 将酒桶中的酒倒入容积为 $b$ ml 的酒杯中；  \n   2. 将容积为 $a$ ml 的酒杯中的酒倒入酒桶；  \n   3. 将容积为 $b$ ml 的酒杯中的酒倒入容积为 $a$ ml 的酒杯中。\n4. 每次倒酒必须把杯子倒满或把被倾倒的杯子倒空。\n\nWiny 希望通过若干次倾倒得到容积为 $a$ ml 酒杯中剩下的酒的体积尽可能小，他请求你帮助他设计倾倒的方案。", "inputFormat": "输入共一行两个整数 $a$ 和 $b$，满足 $0 < b \\le a \\le 10^9$。", "outputFormat": "第一行一个整数 $c~(c > 0)$，表示可以得到的酒的最小体积。\n\n第二行两个整数 $P_a$ 和 $P_b$（中间用一个空格分隔），分别表示从体积为 $a$ ml 的酒杯中倒出酒的次数和将酒倒入体积为 $b$ ml 的酒杯中的次数。\n\n若有多种可能的 $P_a,P_b$ 满足要求，那么请输出 $P_a$ 最小的一个。若在 $P_a$ 最小的情况下，有多个 $P_b$ 满足要求，请输出 $P_b$ 最小的一个。", "hint": "### 样例解释\n\n倾倒的方案为：\n\n1. 桶 $\\to$ B 杯；\n2. B 杯 $\\to$ A 杯；\n3. 桶 $\\to$ B 杯；\n4. B 杯 $\\to$ A 杯；\n5. A 杯 $\\to$ 桶; \n6. B 杯 $\\to$ A 杯。", "locale": "zh-CN"}}}
{"pid": "P1293", "type": "P", "difficulty": 2, "samples": [["7 9289 Vladivostok\n5 8523 Chabarovsk\n3 5184 Irkutsk\n8 2213 Yalutorovsk\n10 0 Moscow\n", "Yalutorovsk 112125\n"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000]}, "tags": ["数学"], "title": "班级聚会", "background": null, "description": "毕业 25 年以后，我们的主人公开始准备同学聚会。打了无数电话后他终于搞到了所有同学的地址。他们有些人仍在本城市，但大多数人分散在其他的城市。不过，他发现一个巧合，所有地址都恰好分散在一条铁路线上。他准备出发邀请但无法决定应该在哪个地方举行宴会。最后他决定选择一个地点，使大家旅行的花费和最小。\n\n不幸的是，我们的主人公既不擅长数学，也不擅长计算机。他请你帮忙写一个程序，根据他同学的地址，选择聚会的最佳地点。花费相同时优先取靠近莫斯科的城市。", "inputFormat": "输入数据的每一行描述一个城市的信息。对于每个城市，\n\n首先是城市里同学的个数，紧跟着是这个城市到 Moscow（起点站）的距离（单位 $\\rm km$），最后是城市的名称。最后一行描述的总是 Moscow，它在铁路线的一端，距离为 $0$。", "outputFormat": "聚会地点城市名称和旅行费用（单程），两者之间用一空格隔开。每 $\\rm km$ 花费一个卢布。", "hint": "### 数据范围及约定\n\n对于全部数据，保证城市数量 $ \\le 150$，距离 $ \\le 10000$，同学个数 $ \\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "Class Reunion", "background": "", "description": "Twenty-five years after graduation, our protagonist starts preparing a class reunion. After countless phone calls, he finally obtains the addresses of all classmates. Some still live in the same city, but most are scattered in other cities. However, he notices a coincidence: all addresses happen to lie along a single railway line. He plans to set out to invite them but cannot decide where to hold the banquet. In the end, he decides to choose a location that minimizes the sum of everyone’s travel costs.\n\nUnfortunately, our protagonist is neither good at math nor computers. He asks you to write a program that, given his classmates’ addresses, selects the best reunion location. If the total cost is tied, choose the city closer to Moscow.", "inputFormat": "Each line of the input data describes one city. For each city, first comes the number of classmates living in that city, followed by the distance from this city to Moscow (the starting station) in $\\rm km$, and finally the city name. The last line always describes Moscow, which lies at one end of the railway line and has distance $0$.", "outputFormat": "Output the city name of the meeting location and the travel cost (one-way), separated by a single space. Each $\\rm km$ costs one ruble.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that the number of cities $ \\le 150$, the distance $ \\le 10000$, and the number of classmates $ \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "班级聚会", "background": null, "description": "毕业 25 年以后，我们的主人公开始准备同学聚会。打了无数电话后他终于搞到了所有同学的地址。他们有些人仍在本城市，但大多数人分散在其他的城市。不过，他发现一个巧合，所有地址都恰好分散在一条铁路线上。他准备出发邀请但无法决定应该在哪个地方举行宴会。最后他决定选择一个地点，使大家旅行的花费和最小。\n\n不幸的是，我们的主人公既不擅长数学，也不擅长计算机。他请你帮忙写一个程序，根据他同学的地址，选择聚会的最佳地点。花费相同时优先取靠近莫斯科的城市。", "inputFormat": "输入数据的每一行描述一个城市的信息。对于每个城市，\n\n首先是城市里同学的个数，紧跟着是这个城市到 Moscow（起点站）的距离（单位 $\\rm km$），最后是城市的名称。最后一行描述的总是 Moscow，它在铁路线的一端，距离为 $0$。", "outputFormat": "聚会地点城市名称和旅行费用（单程），两者之间用一空格隔开。每 $\\rm km$ 花费一个卢布。", "hint": "### 数据范围及约定\n\n对于全部数据，保证城市数量 $ \\le 150$，距离 $ \\le 10000$，同学个数 $ \\le 50$。", "locale": "zh-CN"}}}
{"pid": "P1294", "type": "P", "difficulty": 2, "samples": [["4 6\n1 2 10\n2 3 20\n3 4 30\n4 1 40\n1 3 50\n2 4 60", "150"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "洛谷原创", "深度优先搜索 DFS"], "title": "高手去散步", "background": "高手最近谈恋爱了。不过是单相思。“即使是单相思，也是完整的爱情”，高手从未放弃对它的追求。今天，这个阳光明媚的早晨，太阳从西边缓缓升起。于是它找到高手，希望在晨读开始之前和高手一起在鳌头山上一起散步。高手当然不会放弃这次梦寐以求的机会，他已经准备好了一切。\n", "description": "鳌头山上有 $n$ 个观景点，观景点两两之间有游步道共 $m$ 条。高手的那个它，不喜欢太刺激的过程，因此那些没有路的观景点高手是不会选择去的。另外，她也不喜欢去同一个观景点一次以上。而高手想让他们在一起的路程最长（观景时它不会理高手），已知高手的穿梭机可以让他们在任意一个观景点出发，也在任意一个观景点结束。", "inputFormat": "第一行，两个用空格隔开的整数 $n$ 、 $m.$ 之后 $m$ 行，为每条游步道的信息：两端观景点编号、长度。", "outputFormat": "一个整数，表示他们最长相伴的路程。\n", "hint": "对于 $100\\%$ 的数据：$n \\le 20$，$m \\le 50$，保证观景点两两之间不会有多条游步道连接。", "locale": "zh-CN", "translations": {"en": {"title": "Gaoshou Goes for a Walk", "background": "Gaoshou (高手) has recently fallen in love, but it is unrequited. “Even unrequited love is still a complete love.” Gaoshou has never given up pursuing it. Today, on this sunny morning, the sun slowly rose from the west. So she found Gaoshou and hoped to take a walk with him on Aotou Mountain before morning reading begins. Of course, Gaoshou would not miss this long‑awaited opportunity; he has prepared everything.", "description": "There are $n$ viewpoints on Aotou Mountain, and there are $m$ footpaths between pairs of viewpoints. Gaoshou’s crush does not like anything too thrilling, so Gaoshou will not choose viewpoints that have no roads at all. In addition, she does not like to visit the same viewpoint more than once. Gaoshou wants their walking distance together to be as long as possible (while viewing the scenery, she will ignore Gaoshou). It is known that Gaoshou’s shuttle can start at any viewpoint and end at any viewpoint.", "inputFormat": "The first line contains two space‑separated integers $n$ 、 $m.$ After that, there are $m$ lines, each describing one footpath: the indices of its two endpoints and its length.", "outputFormat": "Output a single integer, representing the maximum distance they can stay together.", "hint": "Constraints: For $100\\%$ of the testdata: $n \\le 20$, $m \\le 50$. It is guaranteed that there is no more than one footpath between any pair of viewpoints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "高手去散步", "background": "高手最近谈恋爱了。不过是单相思。“即使是单相思，也是完整的爱情”，高手从未放弃对它的追求。今天，这个阳光明媚的早晨，太阳从西边缓缓升起。于是它找到高手，希望在晨读开始之前和高手一起在鳌头山上一起散步。高手当然不会放弃这次梦寐以求的机会，他已经准备好了一切。\n", "description": "鳌头山上有 $n$ 个观景点，观景点两两之间有游步道共 $m$ 条。高手的那个它，不喜欢太刺激的过程，因此那些没有路的观景点高手是不会选择去的。另外，她也不喜欢去同一个观景点一次以上。而高手想让他们在一起的路程最长（观景时它不会理高手），已知高手的穿梭机可以让他们在任意一个观景点出发，也在任意一个观景点结束。", "inputFormat": "第一行，两个用空格隔开的整数 $n$ 、 $m.$ 之后 $m$ 行，为每条游步道的信息：两端观景点编号、长度。", "outputFormat": "一个整数，表示他们最长相伴的路程。\n", "hint": "对于 $100\\%$ 的数据：$n \\le 20$，$m \\le 50$，保证观景点两两之间不会有多条游步道连接。", "locale": "zh-CN"}}}
{"pid": "P1295", "type": "P", "difficulty": 5, "samples": [["4 6\n1\n3\n3\n1", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2011", "线段树", "二分", "各省省选", "单调队列", "cdq 分治", "动态规划优化", "天津", "单调栈"], "title": "[TJOI2011] 书架", "background": "由于最近又购买了很多书，所以你打算在自己的书房做一个新书架，为了照顾整体效果，你希望你的书架的宽度越小越好。\n\n书架背靠墙摆放，宽度就是指书架在垂直于墙面的方向上占据的距离。", "description": "现按一定顺序给出所有要放置于书架上的书，共有 $n$ 本，第 $i$ 本书有一个长度 $h_i$。\n\n书架有若干层，层与层之间的宽度不一定相等，但是一层的宽度不能小于其上所摆放的任何一本书的长度。同时，每层上的书的长度之和不能超过一个给定的参数 $m$，且任何层上的书必须是给出的书的序列中连续的几本。\n\n书架的宽度是所有层的宽度之和，求书架的最小宽度。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $m$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i + 1)$ 行的整数代表第 $i$ 本书的长度 $h_i$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $ n \\leq 10^3$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^5$，$1 \\leq h_i \\leq 10^9$，$\\max\\limits_{i = 1}^{n} h_i \\leq m \\leq 10^9$。\n\n#### 提示\n\n由于原题题意严重模糊不清，现给出简化版题意：\n\n给出一个长度为 $n$ 的序列 $h$，请将 $h$ 分成若干段，满足每段数字之和都不超过 $m$，最小化每段的最大值之和。 ", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2011] Bookshelf", "background": "Since you have recently bought many books, you plan to make a new bookshelf in your study. To keep the overall style, you want the bookshelf’s width to be as small as possible.\n\nThe bookshelf is placed against a wall; the width refers to the distance it occupies in the direction perpendicular to the wall.", "description": "You are given, in a fixed order, all the books to be placed on the bookshelf. There are $n$ books, and the $i$-th book has a length $h_i$.\n\nThe bookshelf has several layers (shelves). The widths of different layers may vary, but the width of a layer cannot be smaller than the length of any book placed on that layer. At the same time, the sum of the lengths of the books on each layer cannot exceed a given parameter $m$, and the books on any layer must be a contiguous subsequence in the given order.\n\nThe width of the bookshelf is the sum of the widths of all layers. Find the minimum possible width of the bookshelf.", "inputFormat": "The first line contains two integers $n$ and $m$.\n\nFrom line $2$ to line $(n + 1)$, each line contains one integer. The integer on line $(i + 1)$ is the length $h_i$ of the $i$-th book.", "outputFormat": "Output a single integer on one line representing the answer.", "hint": "Constraints\n\n- For $30\\%$ of the testdata, it is guaranteed that $n \\leq 10^3$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 10^5$, $1 \\leq h_i \\leq 10^9$, $\\max\\limits_{i = 1}^{n} h_i \\leq m \\leq 10^9$.\n\nHint\n\nBecause the original statement was quite ambiguous, here is a simplified version:\n\nGiven a sequence $h$ of length $n$, partition $h$ into several segments such that the sum of numbers in each segment does not exceed $m$, and minimize the sum of the maximum values of all segments.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2011] 书架", "background": "由于最近又购买了很多书，所以你打算在自己的书房做一个新书架，为了照顾整体效果，你希望你的书架的宽度越小越好。\n\n书架背靠墙摆放，宽度就是指书架在垂直于墙面的方向上占据的距离。", "description": "现按一定顺序给出所有要放置于书架上的书，共有 $n$ 本，第 $i$ 本书有一个长度 $h_i$。\n\n书架有若干层，层与层之间的宽度不一定相等，但是一层的宽度不能小于其上所摆放的任何一本书的长度。同时，每层上的书的长度之和不能超过一个给定的参数 $m$，且任何层上的书必须是给出的书的序列中连续的几本。\n\n书架的宽度是所有层的宽度之和，求书架的最小宽度。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $m$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i + 1)$ 行的整数代表第 $i$ 本书的长度 $h_i$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $ n \\leq 10^3$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^5$，$1 \\leq h_i \\leq 10^9$，$\\max\\limits_{i = 1}^{n} h_i \\leq m \\leq 10^9$。\n\n#### 提示\n\n由于原题题意严重模糊不清，现给出简化版题意：\n\n给出一个长度为 $n$ 的序列 $h$，请将 $h$ 分成若干段，满足每段数字之和都不超过 $m$，最小化每段的最大值之和。 ", "locale": "zh-CN"}}}
{"pid": "P1296", "type": "P", "difficulty": 2, "samples": [["5 10\n10 12 16 37 40\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "二分", "排序", "队列", "双指针 two-pointer"], "title": "奶牛的耳语", "background": "", "description": "在你的养牛场，所有的奶牛都养在一排呈直线的牛栏中。一共有 $n$ 头奶牛，其中第 $i$ 头牛在直线上所处的位置可以用一个整数坐标 $p_i(0\\le p_i \\le 10^8)$ 来表示。在无聊的日子里，奶牛们常常在自己的牛栏里与其它奶牛交流一些八卦新闻。每头奶牛发出的声音响度是一样的，而由于声波的能量衰减，某头奶牛发出的声音只能被与它距离不超过 $d(0 \\le d \\le 10^4)$ 的奶牛所听到，这样这对奶牛就称为可以相互交流的。现在给出所有奶牛的位置和声音所能传播的最远距离 $d$ ，请你编个程序来计算你的养牛场里究竟有多少对可以相互交流的奶牛。", "inputFormat": "第一行包含两个整数 $n,d$。\n\n第二行包含 $n$ 个整数，每个整数都是一个坐标 $p_i$，描述一头奶牛在直线上的位置。", "outputFormat": "一个数，表示养牛场中可以相互交流奶牛的对数。\n", "hint": "数据规模\n\n对于 $40\\%$ 的数据，$1 \\leq n \\leq 10^3$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "Cows' Whispers", "background": "", "description": "In your cattle farm, all cows are kept in a row of stalls arranged along a straight line. There are $n$ cows, and the position of the $i$-th cow on the line is represented by an integer coordinate $p_i(0\\le p_i \\le 10^8)$. On boring days, cows often share gossip from their own stalls. Each cow speaks with the same loudness, but due to sound attenuation, a cow’s voice can only be heard by cows within a distance no greater than $d(0 \\le d \\le 10^4)$. In this case, the pair of cows is said to be able to communicate with each other. Given all cows’ positions and the maximum propagation distance $d$, please write a program to compute how many pairs of cows in your farm can communicate.", "inputFormat": "The first line contains two integers $n,d$.\n\nThe second line contains $n$ integers, each being a coordinate $p_i$, describing a cow’s position on the line.", "outputFormat": "A single integer, the number of pairs of cows in the farm that can communicate.", "hint": "Constraints\n\n- For $40\\%$ of the data, $1 \\leq n \\leq 10^3$.\n- For $100\\%$ of the data, $1 \\leq n \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "奶牛的耳语", "background": "", "description": "在你的养牛场，所有的奶牛都养在一排呈直线的牛栏中。一共有 $n$ 头奶牛，其中第 $i$ 头牛在直线上所处的位置可以用一个整数坐标 $p_i(0\\le p_i \\le 10^8)$ 来表示。在无聊的日子里，奶牛们常常在自己的牛栏里与其它奶牛交流一些八卦新闻。每头奶牛发出的声音响度是一样的，而由于声波的能量衰减，某头奶牛发出的声音只能被与它距离不超过 $d(0 \\le d \\le 10^4)$ 的奶牛所听到，这样这对奶牛就称为可以相互交流的。现在给出所有奶牛的位置和声音所能传播的最远距离 $d$ ，请你编个程序来计算你的养牛场里究竟有多少对可以相互交流的奶牛。", "inputFormat": "第一行包含两个整数 $n,d$。\n\n第二行包含 $n$ 个整数，每个整数都是一个坐标 $p_i$，描述一头奶牛在直线上的位置。", "outputFormat": "一个数，表示养牛场中可以相互交流奶牛的对数。\n", "hint": "数据规模\n\n对于 $40\\%$ 的数据，$1 \\leq n \\leq 10^3$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P1297", "type": "P", "difficulty": 4, "samples": [["3 2 0 4 1", "1.167\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "集训队互测", "概率论", "期望"], "title": "[国家集训队] 单选错位", "background": "", "description": "gx 和 lc 去参加 noip 初赛，其中有一种题型叫单项选择题，顾名思义，只有一个选项是正确答案。\n\n试卷上共有 $n$ 道单选题，第 $i$ 道单选题有 $a_i$ 个选项，这 $a_i$ 个选项编号是 $1,2,3,\\ldots,a_i$，每个选项成为正确答案的概率都是相等的。\n\nlc 采取的策略是每道题目随机写上 $1 \\sim a_i$ 的某个数作为答案选项，他用不了多少时间就能期望做对 $\\sum_{i=1}^n \\frac{1}{a_i}$ 道题目。gx 则是认认真真地做完了这 $n$ 道题目，可是等他做完的时候时间也所剩无几了，于是他匆忙地把答案抄到答题纸上，没想到抄错位了：第 $i$ 道题目的答案抄到了答题纸上的第 $i+1$ 道题目的位置上，特别地，第 $n$ 道题目的答案抄到了第 $1$ 道题目的位置上。\n\n现在 gx 已经走出考场没法改了，不过他还是想知道自己期望能做对几道题目，这样他就知道会不会被 lc 鄙视了。\n\n我们假设 gx 没有做错任何题目，只是答案抄错位置了。\n", "inputFormat": "$n$ 很大，为了避免读入耗时太多，输入文件只有 $5$ 个整数参数 $n, A, B, C, a_1$，由上交的程序产生数列 $a$。下面给出 pascal/C/C++ 的读入语句和产生序列的语句（默认从标准输入读入）：\n\n```cpp\n// for pascal\nreadln(n,A,B,C,q[1]);\nfor i:=2 to n do\nq[i] := (int64(q[i-1]) * A + B) mod 100000001;\nfor i:=1 to n do\nq[i] := q[i] mod C + 1;\n\n\n// for C/C++\nscanf(\"%d%d%d%d%d\", &n, &A, &B, &C, a + 1);\nfor (int i = 2; i <= n; i++)\n\ta[i] = ((long long) a[i - 1] * A + B) % 100000001;\nfor (int i = 1; i <= n; i++)\n\ta[i] = a[i] % C + 1;\n```\n\n选手可以通过以上的程序语句得到 $n$ 和数列 $a$（$a$ 的元素类型是 $32$ 位整数），$n$ 和 $a$ 的含义见题目描述。\n", "outputFormat": "输出一个实数，表示 gx 期望做对的题目个数，保留三位小数。\n", "hint": "【样例说明】\n\n| 正确答案   |   gx的答案    | 做对题目 | 出现概率 |\n| :----------: | :----------: |:----------: | :----------: |\n| $\\{1,1,1\\}$  |    $\\{1,1,1\\}$    |    $3$    |    $\\frac16$ |\n| $\\{1,2,1\\}$    |   $ \\{1,1,2\\}$   |    $1$    |    $\\frac16$ |\n|$\\{1,3,1\\}$    |   $ \\{1,1,3\\} $   |    $1$    |    $\\frac16$ |\n|$\\{2,1,1\\}$    |   $ \\{1,2,1\\} $   |    $1$    |    $\\frac16$|\n|$\\{2,2,1\\}$    |   $ \\{1,2,2\\}$    |    $1$    |    $\\frac16$ |\n|$\\{2,3,1\\}$    |    $\\{1,2,3\\} $   |    $0$    |    $\\frac16$ |\n\n\n\n\n$a = \\{2,3,1\\}$。\n\n共有 $6$ 种情况，每种情况出现的概率是 $\\frac{1}{6}$，gx 期望做对 $\\frac{3+1+1+1+1+0}6 = \\frac76$ 题。（相比之下，lc 随机就能期望做对 $\\frac{11}6$ 题）\n\n\n\n对于 $30\\%$ 的数据，$n\\leq 10, C\\leq 10$。\n\n对于 $80\\%$ 的数据，$n\\leq 10^4, C\\leq 10$。\n\n对于 $90\\%$ 的数据，$n\\leq 5\\times 10^5, C\\leq 10^8$。\n\n对于 $100\\%$ 的数据，$2\\leq n\\leq 10^7, 0\\leq A,B,C \\leq 10^8$，$1 \\leq a_i \\leq 10^8$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[National Training Team] Single-Choice Misalignment", "background": "", "description": "gx and lc went to take the NOIP preliminary round. There is a type of problem called single-choice questions, meaning only one option is the correct answer.\n\nThere are $n$ single-choice questions on the paper. The $i$-th question has $a_i$ options, numbered $1, 2, 3, \\ldots, a_i$. Each option is equally likely to be the correct answer.\n\nlc’s strategy is to randomly write down some number from $1 \\sim a_i$ as the answer for each question. In little time, he can expect to get $\\sum_{i=1}^n \\frac{1}{a_i}$ questions correct. gx carefully solved all $n$ questions, but when he finished, time was running out. He hurriedly copied his answers onto the answer sheet, but accidentally shifted them: the answer to the $i$-th question was written in the position of the $(i+1)$-th question on the answer sheet. Specifically, the answer to the $n$-th question was written in the position of the $1$-st question.\n\nNow that gx has left the exam room, he cannot change his answers, but he still wants to know the expected number of questions he got correct, so he can tell whether he will be looked down upon by lc.\n\nWe assume gx did not solve any question incorrectly; only the positions of his answers were misaligned.", "inputFormat": "$n$ is large. To avoid slow input, the input file contains only $5$ integers $n, A, B, C, a_1$, and the submitted program generates the sequence $a$. Below are the Pascal/C/C++ input statements and the sequence-generation statements (input is read from standard input by default):\n\n```cpp\n// for pascal\nreadln(n,A,B,C,q[1]);\nfor i:=2 to n do\nq[i] := (int64(q[i-1]) * A + B) mod 100000001;\nfor i:=1 to n do\nq[i] := q[i] mod C + 1;\n\n\n// for C/C++\nscanf(\"%d%d%d%d%d\", &n, &A, &B, &C, a + 1);\nfor (int i = 2; i <= n; i++)\n\ta[i] = ((long long) a[i - 1] * A + B) % 100000001;\nfor (int i = 1; i <= n; i++)\n\ta[i] = a[i] % C + 1;\n```\n\nContestants can obtain $n$ and the sequence $a$ using the code above (the elements of $a$ are $32$-bit integers). The meanings of $n$ and $a$ are as described in the problem statement.", "outputFormat": "Output a real number representing the expected number of questions gx gets correct, rounded to three decimal places.", "hint": "[Sample Explanation]\n\n| Correct answers | gx's answers | Number correct | Probability |\n| :----------: | :----------: |:----------: | :----------: |\n| $\\{1,1,1\\}$  | $\\{1,1,1\\}$  | $3$ | $\\frac16$ |\n| $\\{1,2,1\\}$  | $\\{1,1,2\\}$  | $1$ | $\\frac16$ |\n| $\\{1,3,1\\}$  | $\\{1,1,3\\}$  | $1$ | $\\frac16$ |\n| $\\{2,1,1\\}$  | $\\{1,2,1\\}$  | $1$ | $\\frac16$ |\n| $\\{2,2,1\\}$  | $\\{1,2,2\\}$  | $1$ | $\\frac16$ |\n| $\\{2,3,1\\}$  | $\\{1,2,3\\}$  | $0$ | $\\frac16$ |\n\n$a = \\{2,3,1\\}$.\n\nThere are $6$ cases, each occurring with probability $\\frac{1}{6}$. The expected number of correct answers for gx is $\\frac{3+1+1+1+1+0}6 = \\frac76$. (In comparison, lc’s random strategy yields an expectation of $\\frac{11}6$.)\n\nFor $30\\%$ of the testdata, $n \\le 10$, $C \\le 10$.\n\nFor $80\\%$ of the testdata, $n \\le 10^4$, $C \\le 10$.\n\nFor $90\\%$ of the testdata, $n \\le 5 \\times 10^5$, $C \\le 10^8$.\n\nFor $100\\%$ of the testdata, $2 \\le n \\le 10^7$, $0 \\le A, B, C \\le 10^8$, $1 \\le a_i \\le 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] 单选错位", "background": "", "description": "gx 和 lc 去参加 noip 初赛，其中有一种题型叫单项选择题，顾名思义，只有一个选项是正确答案。\n\n试卷上共有 $n$ 道单选题，第 $i$ 道单选题有 $a_i$ 个选项，这 $a_i$ 个选项编号是 $1,2,3,\\ldots,a_i$，每个选项成为正确答案的概率都是相等的。\n\nlc 采取的策略是每道题目随机写上 $1 \\sim a_i$ 的某个数作为答案选项，他用不了多少时间就能期望做对 $\\sum_{i=1}^n \\frac{1}{a_i}$ 道题目。gx 则是认认真真地做完了这 $n$ 道题目，可是等他做完的时候时间也所剩无几了，于是他匆忙地把答案抄到答题纸上，没想到抄错位了：第 $i$ 道题目的答案抄到了答题纸上的第 $i+1$ 道题目的位置上，特别地，第 $n$ 道题目的答案抄到了第 $1$ 道题目的位置上。\n\n现在 gx 已经走出考场没法改了，不过他还是想知道自己期望能做对几道题目，这样他就知道会不会被 lc 鄙视了。\n\n我们假设 gx 没有做错任何题目，只是答案抄错位置了。\n", "inputFormat": "$n$ 很大，为了避免读入耗时太多，输入文件只有 $5$ 个整数参数 $n, A, B, C, a_1$，由上交的程序产生数列 $a$。下面给出 pascal/C/C++ 的读入语句和产生序列的语句（默认从标准输入读入）：\n\n```cpp\n// for pascal\nreadln(n,A,B,C,q[1]);\nfor i:=2 to n do\nq[i] := (int64(q[i-1]) * A + B) mod 100000001;\nfor i:=1 to n do\nq[i] := q[i] mod C + 1;\n\n\n// for C/C++\nscanf(\"%d%d%d%d%d\", &n, &A, &B, &C, a + 1);\nfor (int i = 2; i <= n; i++)\n\ta[i] = ((long long) a[i - 1] * A + B) % 100000001;\nfor (int i = 1; i <= n; i++)\n\ta[i] = a[i] % C + 1;\n```\n\n选手可以通过以上的程序语句得到 $n$ 和数列 $a$（$a$ 的元素类型是 $32$ 位整数），$n$ 和 $a$ 的含义见题目描述。\n", "outputFormat": "输出一个实数，表示 gx 期望做对的题目个数，保留三位小数。\n", "hint": "【样例说明】\n\n| 正确答案   |   gx的答案    | 做对题目 | 出现概率 |\n| :----------: | :----------: |:----------: | :----------: |\n| $\\{1,1,1\\}$  |    $\\{1,1,1\\}$    |    $3$    |    $\\frac16$ |\n| $\\{1,2,1\\}$    |   $ \\{1,1,2\\}$   |    $1$    |    $\\frac16$ |\n|$\\{1,3,1\\}$    |   $ \\{1,1,3\\} $   |    $1$    |    $\\frac16$ |\n|$\\{2,1,1\\}$    |   $ \\{1,2,1\\} $   |    $1$    |    $\\frac16$|\n|$\\{2,2,1\\}$    |   $ \\{1,2,2\\}$    |    $1$    |    $\\frac16$ |\n|$\\{2,3,1\\}$    |    $\\{1,2,3\\} $   |    $0$    |    $\\frac16$ |\n\n\n\n\n$a = \\{2,3,1\\}$。\n\n共有 $6$ 种情况，每种情况出现的概率是 $\\frac{1}{6}$，gx 期望做对 $\\frac{3+1+1+1+1+0}6 = \\frac76$ 题。（相比之下，lc 随机就能期望做对 $\\frac{11}6$ 题）\n\n\n\n对于 $30\\%$ 的数据，$n\\leq 10, C\\leq 10$。\n\n对于 $80\\%$ 的数据，$n\\leq 10^4, C\\leq 10$。\n\n对于 $90\\%$ 的数据，$n\\leq 5\\times 10^5, C\\leq 10^8$。\n\n对于 $100\\%$ 的数据，$2\\leq n\\leq 10^7, 0\\leq A,B,C \\leq 10^8$，$1 \\leq a_i \\leq 10^8$。\n", "locale": "zh-CN"}}}
{"pid": "P1298", "type": "P", "difficulty": 5, "samples": [["360 120\n3.1415926536\n", "355/113\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "数论"], "title": "最接近的分数", "background": "", "description": "给出一个正小数，找出分子（分子 $ \\ge 0$）不超过 $M$，分母不超过 $N$ 的最简分数或整数，使其最接近给出的小数。“最接近”是指在数轴上该分数距离给出的小数最近，如果这个分数不唯一，输出 ``TOO MANY``。", "inputFormat": "输入共有 $2$ 行，第一行包含两个用空格隔开的正整数 $M$ 和 $N$，表示要求的分数其分子不超过 $M$，分母不超过 $N$；第二行为小数 $R(R>0)$，$R$ 的整数部分为一个阿拉伯数字，小数部分最多有十位。", "outputFormat": "输出仅 $1$ 行，若解唯一则输出 `分子/分母`（整数 $K$ 写成 $\\dfrac{K}{1}$），否则输出 ``TOO MANY``。", "hint": "### 数据范围及约定\n\n对于全部数据，保证 $1\\le M,N\\le 10^7$。", "locale": "zh-CN", "translations": {"en": {"title": "Closest Fraction", "background": "", "description": "Given a positive decimal number, find a reduced fraction or an integer whose numerator (numerator $ \\ge 0$) does not exceed $M$ and denominator does not exceed $N$, such that it is closest to the given decimal on the number line. If this closest fraction is not unique, output ``TOO MANY``.", "inputFormat": "There are $2$ lines of input. The first line contains two space-separated positive integers $M$ and $N$, indicating that the fraction’s numerator does not exceed $M$ and the denominator does not exceed $N$. The second line contains a decimal $R(R>0)$; the integer part of $R$ is a single Arabic digit, and the fractional part has at most ten digits.", "outputFormat": "Output exactly $1$ line. If the solution is unique, output `numerator/denominator` (an integer $K$ should be written as $\\dfrac{K}{1}$); otherwise output ``TOO MANY``.", "hint": "### Constraints\n\nFor all testdata, it is guaranteed that $1\\le M,N\\le 10^7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最接近的分数", "background": "", "description": "给出一个正小数，找出分子（分子 $ \\ge 0$）不超过 $M$，分母不超过 $N$ 的最简分数或整数，使其最接近给出的小数。“最接近”是指在数轴上该分数距离给出的小数最近，如果这个分数不唯一，输出 ``TOO MANY``。", "inputFormat": "输入共有 $2$ 行，第一行包含两个用空格隔开的正整数 $M$ 和 $N$，表示要求的分数其分子不超过 $M$，分母不超过 $N$；第二行为小数 $R(R>0)$，$R$ 的整数部分为一个阿拉伯数字，小数部分最多有十位。", "outputFormat": "输出仅 $1$ 行，若解唯一则输出 `分子/分母`（整数 $K$ 写成 $\\dfrac{K}{1}$），否则输出 ``TOO MANY``。", "hint": "### 数据范围及约定\n\n对于全部数据，保证 $1\\le M,N\\le 10^7$。", "locale": "zh-CN"}}}
{"pid": "P1299", "type": "P", "difficulty": 4, "samples": [["4\n0 1 1 1\n1 1 1 0\n1 0 0 0\n0 0 0 1\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索"], "title": "切孔机", "background": null, "description": "司令部的助理经常需要在大纸上切割各种形状的孔。他们刚刚购买了一台新的切孔机，该机比他们以前使用的要方便自由的多。他们想编写一个程序来求出经过一系列复杂的切孔后会发生什么情况，他们特别想知道纸上形成的孔的数量。\n\n下图列出了经过切割后形成的一些图样。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tbek5h3m.png)", "inputFormat": "第一行是一个整数 $N$，表示切纸操作的次数，$1≤N≤100$。接下来的 $N$ 行中每行给出一个精确的切割操作，每次切割都给出了用空格隔开的四个整数，$x_1,y_1,x_2,y_2,\\ -1000≤x_1,y_1,x_2,y_2≤1000$。$x_1$ 和 $y_1$ 是切割线开始处的坐标值，$x_2$ 和 $y_2$ 是切割线结束时的坐标值。你可以假设所有的切割点都在纸上，不会出界。每次切割都平行于纸上的 $x$ 和 $y$ 坐标轴。", "outputFormat": "一行一个整数，表示切割完成后纸上留下的单独的孔数。注意任何孔的最小面积不低于 $1$ 平方单位。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Hole Cutting Machine", "background": "", "description": "Assistants at the headquarters often need to cut holes of various shapes in a large sheet of paper. They have just purchased a new hole cutting machine, which is much more convenient and flexible than the one they used before. They want to write a program to determine what happens after a sequence of complex cuts; in particular, they want to know how many holes are formed in the paper.\n\nThe figure below shows several patterns formed after cutting.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tbek5h3m.png)", "inputFormat": "The first line contains an integer $N$, the number of cutting operations, with $1 \\le N \\le 100$. Each of the next $N$ lines gives one precise cut, described by four space-separated integers $x_1, y_1, x_2, y_2$, with $-1000 \\le x_1, y_1, x_2, y_2 \\le 1000$. Here, $x_1$ and $y_1$ are the coordinates where the cut starts, and $x_2$ and $y_2$ are the coordinates where the cut ends. You may assume all cutting points lie on the paper and never go out of bounds. Each cut is an axis-aligned segment (parallel to the $x$ or $y$ axis).", "outputFormat": "Output a single integer on one line, the number of separate holes on the paper after all cuts are completed. Note that the area of any hole is at least $1$ square unit.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "切孔机", "background": null, "description": "司令部的助理经常需要在大纸上切割各种形状的孔。他们刚刚购买了一台新的切孔机，该机比他们以前使用的要方便自由的多。他们想编写一个程序来求出经过一系列复杂的切孔后会发生什么情况，他们特别想知道纸上形成的孔的数量。\n\n下图列出了经过切割后形成的一些图样。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tbek5h3m.png)", "inputFormat": "第一行是一个整数 $N$，表示切纸操作的次数，$1≤N≤100$。接下来的 $N$ 行中每行给出一个精确的切割操作，每次切割都给出了用空格隔开的四个整数，$x_1,y_1,x_2,y_2,\\ -1000≤x_1,y_1,x_2,y_2≤1000$。$x_1$ 和 $y_1$ 是切割线开始处的坐标值，$x_2$ 和 $y_2$ 是切割线结束时的坐标值。你可以假设所有的切割点都在纸上，不会出界。每次切割都平行于纸上的 $x$ 和 $y$ 坐标轴。", "outputFormat": "一行一个整数，表示切割完成后纸上留下的单独的孔数。注意任何孔的最小面积不低于 $1$ 平方单位。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1300", "type": "P", "difficulty": 4, "samples": [["8 11\n...........\n....#####..\n....#...#..\n....#...#..\n.#E######..\n....#......\n.##F#......\n...........\n", "8\n"], ["17 21\n.....................\n.#######.............\n.#.....#.......#.....\n.###...#.......#.....\n...#...#.......#.....\n.###...#.......#.....\n.#.....#.......#.....\n.############F#####..\n.......#..........#..\n.......#..........#..\n...#...#...#####..#..\n...#...#...#.#.#..#..\n..#S########.#.#..#..\n...#.......#.###..#..\n...#.......#......#..\n...........########..\n.....................", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "图论"], "title": "城市街道交通费系统", "background": "", "description": "城市街道交费系统最近创立了。一辆汽车左转一次需付费 $1$ ，右转一次需付费 $5$ 。只有当前进、左转、右转都无路可走的时候，调头才是允许的，调头每次付费 $10$ 。\n\n给出一张城市地图，要求你求出从起始点到达终止点的花费最少的路径。幸运的是，所有的道路都是正北、正南、正西或正东方向的。", "inputFormat": "输入格式如下：\n\n1. 第一行有两个整数，地图高度 $h$ 和宽度 $w$。\n2. 其后 $h$ 行，每行 $w$ 个字符，将是以下字符中的一个：\n\n- `.` 表示障碍区。\n- `#` 表示道路。\n- `E` 表示起始点且汽车面朝东。\n- `W` 表示起始点且汽车面朝西。\n- `N` 表示起始点且汽车面朝北。\n- `S` 表示起始点且汽车面朝南。\n- `F` 表示终点。", "outputFormat": "仅包含一个整数，即为最便宜路径的费用。\n", "hint": "样例一解释：\n\n直走，然后左转 $3$ 次，最后右转到终止点 `F`。如果先直走然后右转 $2$ 次，花费将是 $10$ 。\n\n---\n\n样例二解释：\n\n最便宜的路径花费 $7$ ：立刻左转，直走，在第一个岔路口左转，随后右转。\n\n---\n\n对于 $100\\%$ 的数据：$4 \\leq h,w \\leq 30$。\n\n数据保证地图中只有一个起点，一个终点，他们之间存在着可通达的路径。同时保证地图最外层一圈都是障碍。", "locale": "zh-CN", "translations": {"en": {"title": "City Street Traffic Fee System", "background": "", "description": "A city street toll system was recently established. A car must pay $1$ for each left turn and $5$ for each right turn. A U-turn is allowed only when going straight, turning left, and turning right are all impossible; each U-turn costs $10$.\n\nGiven a city map, find the path from the start to the finish with the minimum cost. Fortunately, all roads run due north, due south, due west, or due east.", "inputFormat": "The input format is as follows:\n\n1. The first line contains two integers, the map height $h$ and width $w$.\n2. Then follow $h$ lines, each with $w$ characters, each being one of the following:\n\n- `.` denotes an obstacle.\n- `#` denotes a road.\n- `E` denotes the start, with the car facing east.\n- `W` denotes the start, with the car facing west.\n- `N` denotes the start, with the car facing north.\n- `S` denotes the start, with the car facing south.\n- `F` denotes the finish.", "outputFormat": "Output a single integer: the cost of the cheapest path.", "hint": "Explanation for Sample 1:\n\nGo straight, then turn left $3$ times, and finally turn right to reach `F`. If you go straight first and then turn right $2$ times, the cost will be $10$.\n\n---\n\nExplanation for Sample 2:\n\nThe cheapest path costs $7$: turn left immediately, go straight, turn left at the first intersection, then turn right.\n\n---\n\nFor $100\\%$ of the testdata: $4 \\leq h,w \\leq 30$.\n\nIt is guaranteed that there is exactly one start and one finish on the map, and that there exists a reachable path between them. It is also guaranteed that the outermost border of the map consists entirely of obstacles.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "城市街道交通费系统", "background": "", "description": "城市街道交费系统最近创立了。一辆汽车左转一次需付费 $1$ ，右转一次需付费 $5$ 。只有当前进、左转、右转都无路可走的时候，调头才是允许的，调头每次付费 $10$ 。\n\n给出一张城市地图，要求你求出从起始点到达终止点的花费最少的路径。幸运的是，所有的道路都是正北、正南、正西或正东方向的。", "inputFormat": "输入格式如下：\n\n1. 第一行有两个整数，地图高度 $h$ 和宽度 $w$。\n2. 其后 $h$ 行，每行 $w$ 个字符，将是以下字符中的一个：\n\n- `.` 表示障碍区。\n- `#` 表示道路。\n- `E` 表示起始点且汽车面朝东。\n- `W` 表示起始点且汽车面朝西。\n- `N` 表示起始点且汽车面朝北。\n- `S` 表示起始点且汽车面朝南。\n- `F` 表示终点。", "outputFormat": "仅包含一个整数，即为最便宜路径的费用。\n", "hint": "样例一解释：\n\n直走，然后左转 $3$ 次，最后右转到终止点 `F`。如果先直走然后右转 $2$ 次，花费将是 $10$ 。\n\n---\n\n样例二解释：\n\n最便宜的路径花费 $7$ ：立刻左转，直走，在第一个岔路口左转，随后右转。\n\n---\n\n对于 $100\\%$ 的数据：$4 \\leq h,w \\leq 30$。\n\n数据保证地图中只有一个起点，一个终点，他们之间存在着可通达的路径。同时保证地图最外层一圈都是障碍。", "locale": "zh-CN"}}}
