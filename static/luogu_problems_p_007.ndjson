{"pid": "P2774", "type": "P", "difficulty": 6, "samples": [["3 3\n1 2 3\n3 2 3\n2 3 1 ", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["网络流", "O2优化", "深度优先搜索 DFS", "最小割", "网络流与线性规划 24 题"], "title": "方格取数问题", "background": "", "description": "有一个 $m$ 行 $n$ 列的方格图，每个方格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，请求出最大的和。\n", "inputFormat": "第一行是两个用空格隔开的整数，分别代表方格图的行数 $m$ 和列数 $n$。\n\n第 $2$ 到第 $(m + 1)$ 行，每行 $n$ 个整数，第 $(i + 1)$ 行的第 $j$ 个整数代表方格图第 $i$ 行第 $j$ 列的的方格中的数字 $a_{i, j}$。", "outputFormat": "输出一行一个整数，代表和最大是多少。", "hint": "**数据规模与约定**\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n, m \\leq 100$，$1 \\leq a_{i, j} \\leq 10^5$。\n\n**提示**\n\n请注意输入的第一行先读入 $m$ 再读入 $n$。", "locale": "zh-CN", "translations": {"en": {"title": "Grid Number Picking Problem", "background": "", "description": "There is an $m$-row $n$-column grid, with a positive integer in each cell. You need to pick numbers from the grid so that no two chosen cells share a common edge, and the total sum of the chosen numbers is maximized. Please compute the maximum possible sum.", "inputFormat": "The first line contains two integers separated by a space, representing the number of rows $m$ and the number of columns $n$.\n\nFrom line $2$ to line $(m + 1)$, each line contains $n$ integers. The $j$-th integer on line $(i + 1)$ represents the number in the cell at row $i$, column $j$, namely $a_{i, j}$.", "outputFormat": "Output a single integer on one line, representing the maximum sum.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\leq n, m \\leq 100$, $1 \\leq a_{i, j} \\leq 10^5$.\n\nTip\n\nPlease note that in the first line, $m$ is read before $n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "方格取数问题", "background": "", "description": "有一个 $m$ 行 $n$ 列的方格图，每个方格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，请求出最大的和。\n", "inputFormat": "第一行是两个用空格隔开的整数，分别代表方格图的行数 $m$ 和列数 $n$。\n\n第 $2$ 到第 $(m + 1)$ 行，每行 $n$ 个整数，第 $(i + 1)$ 行的第 $j$ 个整数代表方格图第 $i$ 行第 $j$ 列的的方格中的数字 $a_{i, j}$。", "outputFormat": "输出一行一个整数，代表和最大是多少。", "hint": "**数据规模与约定**\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n, m \\leq 100$，$1 \\leq a_{i, j} \\leq 10^5$。\n\n**提示**\n\n请注意输入的第一行先读入 $m$ 再读入 $n$。", "locale": "zh-CN"}}}
{"pid": "P2775", "type": "P", "difficulty": 0, "samples": [["5 0 3\n1 1 2\n1 1 2\n1 3 0 1 3\n0 2 2 4\n1 1 3 ", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化", "启发式迭代加深搜索 IDA*", "网络流与线性规划 24 题"], "title": "机器人路径规划问题（疑似错题）", "background": "**通过套取数据而直接“打表”过题者，是作弊行为，发现即棕名。**\n\n本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。由于测试数据过水，可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）。本题题目和数据仅供参考。本题不接受添加 hack 数据。\n\n本题为错题。**不建议尝试或提交本题。**[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)", "description": "机器人 Rob 可在一个树状路径上自由移动。给定树状路径 $T$ 上的起点 $s$ 和终点 $t$，机器人 Rob 要从 $s$ 运动到 $t$。树状路径 $T$ 上有若干可移动的障碍物。由于路径狭窄，任何时刻在路径的任何位置不能同时容纳 $2$ 个物体。每一步可以将障碍物或机器人移到相邻的空顶点上。设计一个有效算法用最少移动次数使机器人从 $s$ 运动到 $t$。对于给定的树 $T$，以及障碍物在树 $T$ 中的分布情况。计算机器人从起点 $s$ 到终点 $t$ 的最少移动次数。", "inputFormat": "第 $1$ 行有 $3$ 个正整数 $n$，$s$ 和 $t$，分别表示树 $T$ 的顶点数，起点 $s$ 的编号和终点 $t$ 的编号。\n\n接下来的 $n$ 行分别对应于树 $T$ 中编号为 $0,1,\\cdots,n-1$ 的顶点。每行的第 $1$ 个整数 $h$ 表示顶点的初始状态，当 $h=1$ 时表示该顶点为空顶点，当 $h=0$ 时表示该顶点为满顶点，其中已有 $1$ 个障碍物。第 $2$ 个数 $k$ 表示有 $k$ 个顶点与该顶点相连。接下来的 $k$ 个数是与该顶点相连的顶点编号。", "outputFormat": "程序运行结束时，将计算出的机器人最少移动次数输出。如果无法将机器人从起点移动到终点，输出 `No solution!`。", "hint": "题目中出现的数字均小于 $1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Robot Path Planning Problem (Suspected Faulty Problem)", "background": "Directly passing a problem by siphoning testdata and “table-based” solutions (hardcoding lookup tables) is cheating; once discovered, you will be brown-named.\n\nThis problem does not guarantee that there exists a solution that works for arbitrary data within this problem’s constraints. Because the testdata are weak, a program that passes this problem may be incorrect (e.g., with wrong time complexity or without correctness guarantees). The problem statement and testdata are for reference only. This problem does not accept additional hack testdata.\n\nThis is a faulty problem. You are not recommended to attempt or submit to this problem. [More details about this type of problem](https://www.luogu.com.cn/paste/pf94n89x).", "description": "Robot Rob can move freely on a tree-shaped path. Given the start $s$ and the end $t$ on the tree $T$, Rob needs to move from $s$ to $t$. There are several movable obstacles on $T$. Because the path is narrow, no two objects can occupy the same position at the same time. In each step, you may move either an obstacle or the robot to an adjacent empty vertex. Design an efficient algorithm to minimize the number of moves needed to move the robot from $s$ to $t$. For the given tree $T$ and the distribution of obstacles in $T$, compute the minimal number of moves for the robot to go from $s$ to $t$.", "inputFormat": "The first line contains three positive integers $n$, $s$ and $t$, denoting the number of vertices of the tree $T$, the index of the start $s$, and the index of the end $t$, respectively.\n\nThe next $n$ lines correspond to the vertices of $T$ numbered $0,1,\\cdots,n-1$. In each line, the first integer $h$ indicates the initial state of the vertex: when $h = 1$, the vertex is empty; when $h = 0$, the vertex is occupied, containing exactly one obstacle. The second number $k$ indicates that there are $k$ vertices adjacent to this vertex. The following $k$ numbers are the indices of the adjacent vertices.", "outputFormat": "Output the minimal number of moves computed. If the robot cannot be moved from the start to the end, output `No solution!`.", "hint": "All numbers that appear in the problem are less than $1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "机器人路径规划问题（疑似错题）", "background": "**通过套取数据而直接“打表”过题者，是作弊行为，发现即棕名。**\n\n本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。由于测试数据过水，可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）。本题题目和数据仅供参考。本题不接受添加 hack 数据。\n\n本题为错题。**不建议尝试或提交本题。**[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)", "description": "机器人 Rob 可在一个树状路径上自由移动。给定树状路径 $T$ 上的起点 $s$ 和终点 $t$，机器人 Rob 要从 $s$ 运动到 $t$。树状路径 $T$ 上有若干可移动的障碍物。由于路径狭窄，任何时刻在路径的任何位置不能同时容纳 $2$ 个物体。每一步可以将障碍物或机器人移到相邻的空顶点上。设计一个有效算法用最少移动次数使机器人从 $s$ 运动到 $t$。对于给定的树 $T$，以及障碍物在树 $T$ 中的分布情况。计算机器人从起点 $s$ 到终点 $t$ 的最少移动次数。", "inputFormat": "第 $1$ 行有 $3$ 个正整数 $n$，$s$ 和 $t$，分别表示树 $T$ 的顶点数，起点 $s$ 的编号和终点 $t$ 的编号。\n\n接下来的 $n$ 行分别对应于树 $T$ 中编号为 $0,1,\\cdots,n-1$ 的顶点。每行的第 $1$ 个整数 $h$ 表示顶点的初始状态，当 $h=1$ 时表示该顶点为空顶点，当 $h=0$ 时表示该顶点为满顶点，其中已有 $1$ 个障碍物。第 $2$ 个数 $k$ 表示有 $k$ 个顶点与该顶点相连。接下来的 $k$ 个数是与该顶点相连的顶点编号。", "outputFormat": "程序运行结束时，将计算出的机器人最少移动次数输出。如果无法将机器人从起点移动到终点，输出 `No solution!`。", "hint": "题目中出现的数字均小于 $1000$。", "locale": "zh-CN"}}}
{"pid": "P2776", "type": "P", "difficulty": 3, "samples": [["4 2\n0 0 1 1\n6\npush 2\npush 0\npush 3\npop\npop\npop", "2\n3\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "山东"], "title": "[SDOI2007] 小组队列", "background": "嘛，这道非常简单的给大家提供信心的省选题洛谷居然没有！\n\n这么简单的题怎么可以没有！\n\n给大家提升士气是义不容辞的责任！\n\n所以我就来补一下啦..\n\n值得一提的是，标程是我自己做的..\n\n很渣，因为数据很水所以能 AC..\n\n大神勿喷..\n", "description": "有 $m$ 个小组， $n$ 个元素，每个元素属于且仅属于一个小组。\n\n\n支持以下操作：\n\n\n`push x`：使元素 `x` 进队，如果前边有 `x` 所属小组的元素，`x` 会排到自己小组最后一个元素的下一个位置，否则 `x` 排到整个队列最后的位置。\n\n`pop`：出队，弹出队头并输出出队元素，出队的方式和普通队列相同，即排在前边的元素先出队。\n", "inputFormat": "第一行有两个正整数 $n$, $m$，分别表示元素个数和小组个数，元素和小组均从 $0$ 开始编号。\n\n接下来一行 $n$ 个非负整数 $A_i$，表示元素 $i$ 所在的小组。\n\n接下来一行一个正整数 $T$ ，表示操作数。\n\n接下来 $T$ 行，每行为一个操作。\n", "outputFormat": "对于每个出队操作输出一行，为出队的元素。\n", "hint": "对于 $30\\%$ 的数据，$1≤n≤100$，$1≤m≤10$，$T≤50$。\n\n对于 $100\\%$ 的数据，$1≤n≤100000$，$1≤m≤300$，$T≤100000$，输入保证操作合法。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2007] Team Queue", "background": "Well, somehow this very simple NOI Qualifier problem to boost confidence isn’t on Luogu.\n\nHow could such a simple problem be missing.\n\nIt’s my responsibility to raise everyone’s morale.\n\nSo I’m adding it here.\n\nWorth mentioning, the reference solution is my own.\n\nIt’s quite weak, but since the testdata is easy, it can AC.\n\nExperts, please don’t roast me.", "description": "There are $m$ groups and $n$ elements. Each element belongs to exactly one group.\n\nSupport the following operations:\n\n`push x`: Enqueue element `x`. If there is already an element from `x`’s group ahead in the queue, `x` will be placed immediately after the last element of its own group currently in the queue; otherwise, `x` will be placed at the end of the whole queue.\n\n`pop`: Dequeue. Remove the front element of the queue and output it. This behaves like a normal queue, i.e., elements in front leave first.", "inputFormat": "The first line contains two positive integers $n$, $m$, representing the number of elements and the number of groups. Elements and groups are numbered starting from $0$.\n\nThe next line contains $n$ non-negative integers $A_i$, where $A_i$ is the group that element $i$ belongs to.\n\nThe next line contains a positive integer $T$, the number of operations.\n\nThe next $T$ lines each contain one operation.", "outputFormat": "For each dequeue operation, output the dequeued element on a separate line.", "hint": "For $30\\%$ of the testdata, $1 \\le n \\le 100$, $1 \\le m \\le 10$, $T \\le 50$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 100000$, $1 \\le m \\le 300$, $T \\le 100000$. The input guarantees that all operations are valid.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2007] 小组队列", "background": "嘛，这道非常简单的给大家提供信心的省选题洛谷居然没有！\n\n这么简单的题怎么可以没有！\n\n给大家提升士气是义不容辞的责任！\n\n所以我就来补一下啦..\n\n值得一提的是，标程是我自己做的..\n\n很渣，因为数据很水所以能 AC..\n\n大神勿喷..\n", "description": "有 $m$ 个小组， $n$ 个元素，每个元素属于且仅属于一个小组。\n\n\n支持以下操作：\n\n\n`push x`：使元素 `x` 进队，如果前边有 `x` 所属小组的元素，`x` 会排到自己小组最后一个元素的下一个位置，否则 `x` 排到整个队列最后的位置。\n\n`pop`：出队，弹出队头并输出出队元素，出队的方式和普通队列相同，即排在前边的元素先出队。\n", "inputFormat": "第一行有两个正整数 $n$, $m$，分别表示元素个数和小组个数，元素和小组均从 $0$ 开始编号。\n\n接下来一行 $n$ 个非负整数 $A_i$，表示元素 $i$ 所在的小组。\n\n接下来一行一个正整数 $T$ ，表示操作数。\n\n接下来 $T$ 行，每行为一个操作。\n", "outputFormat": "对于每个出队操作输出一行，为出队的元素。\n", "hint": "对于 $30\\%$ 的数据，$1≤n≤100$，$1≤m≤10$，$T≤50$。\n\n对于 $100\\%$ 的数据，$1≤n≤100000$，$1≤m≤300$，$T≤100000$，输入保证操作合法。\n", "locale": "zh-CN"}}}
{"pid": "P2777", "type": "P", "difficulty": 2, "samples": [["3\n8\n10\n9", "3"], ["5\n15\n14\n15\n12\n14", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["模拟", "贪心", "2016", "安徽", "排序"], "title": "[AHOI2016初中组] 自行车比赛", "background": "", "description": "小雪非常关注自行车比赛，尤其是环滨湖自行车赛。一年一度的环滨湖自行车赛，需要选手们连续比赛数日，最终按照累计得分决出冠军。今年一共有 $N$ 位参赛选手。每一天的比赛总会决出当日的排名，第一名的选手会获得 $N$ 点得分，第二名会获得 $N-1$ 点得分，第三名会获得 $N-2$ 点得分，依次类推，最后一名会获得 $1$ 点得分。保证没有选手会排名相同。\n\n\n在之前的数日较量中，$N$ 位选手已经分别累计了一些分数。现在即将开始的是最后一天的比赛。小雪希望知道有多少位选手还有可能获得最终的冠军，也就是说还有多少选手有可能通过最后一天的比赛获得累计总分第一名。\n", "inputFormat": "第一行输入一个整数 $N$，表示参赛选手总数，保证 $3\\le N\\le 3\\times 10^5$。\n\n\n之后 $N$ 行，其中第 $i$ 行输入一个整数 $B_i$ 表示第 $i$ 位选手已经获得的累计分数，满足 $0\\le B_i\\le 2\\times 10^6%$。\n", "outputFormat": "输出只有一行，只输出一个整数，表示有多少位选手有可能获得最终的冠军。\n", "hint": "### 数据范围及约定\n\n- 对于 $20\\% $ 的数据，$3\\le N\\le 600$。\n- 对于 $50\\%$  的数据，$3\\le N\\le 1\\times 10^4$。\n- 对于 $100\\%$ 的数据，$3\\le N\\le 3\\times 10^5$ 且 $0\\le B_i\\le 2\\times 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2016 Junior] Bicycle Race", "background": "", "description": "Xiaoxue is very interested in bicycle races, especially the Tour of Binhu Lake. The annual Tour of Binhu Lake requires riders to compete for several consecutive days, and the champion is decided by total accumulated points. This year there are $N$ contestants. Each day’s race produces a ranking: the first-place finisher earns $N$ points, the second-place finisher earns $N-1$ points, the third-place finisher earns $N-2$ points, and so on, with the last-place finisher earning $1$ point. It is guaranteed that no two contestants share the same rank on a given day.\n\nOver the previous days, the $N$ contestants have already accumulated some points. The final day is about to begin. Xiaoxue wants to know how many contestants still have a chance to become the overall champion — that is, how many contestants can possibly finish with the highest total after the last day’s race.", "inputFormat": "The first line contains an integer $N$, the total number of contestants, with $3\\le N\\le 3\\times 10^5$.\n\nThen follow $N$ lines. The $i$-th line contains an integer $B_i$, the accumulated points already earned by contestant $i$, with $0\\le B_i\\le 2\\times 10^6$.", "outputFormat": "Output a single line containing one integer: the number of contestants who can still become the final champion.", "hint": "### Constraints and Conventions\n\n- For $20\\%$ of the testdata, $3\\le N\\le 600$.\n- For $50\\%$ of the testdata, $3\\le N\\le 1\\times 10^4$.\n- For $100\\%$ of the testdata, $3\\le N\\le 3\\times 10^5$ and $0\\le B_i\\le 2\\times 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2016初中组] 自行车比赛", "background": "", "description": "小雪非常关注自行车比赛，尤其是环滨湖自行车赛。一年一度的环滨湖自行车赛，需要选手们连续比赛数日，最终按照累计得分决出冠军。今年一共有 $N$ 位参赛选手。每一天的比赛总会决出当日的排名，第一名的选手会获得 $N$ 点得分，第二名会获得 $N-1$ 点得分，第三名会获得 $N-2$ 点得分，依次类推，最后一名会获得 $1$ 点得分。保证没有选手会排名相同。\n\n\n在之前的数日较量中，$N$ 位选手已经分别累计了一些分数。现在即将开始的是最后一天的比赛。小雪希望知道有多少位选手还有可能获得最终的冠军，也就是说还有多少选手有可能通过最后一天的比赛获得累计总分第一名。\n", "inputFormat": "第一行输入一个整数 $N$，表示参赛选手总数，保证 $3\\le N\\le 3\\times 10^5$。\n\n\n之后 $N$ 行，其中第 $i$ 行输入一个整数 $B_i$ 表示第 $i$ 位选手已经获得的累计分数，满足 $0\\le B_i\\le 2\\times 10^6%$。\n", "outputFormat": "输出只有一行，只输出一个整数，表示有多少位选手有可能获得最终的冠军。\n", "hint": "### 数据范围及约定\n\n- 对于 $20\\% $ 的数据，$3\\le N\\le 600$。\n- 对于 $50\\%$  的数据，$3\\le N\\le 1\\times 10^4$。\n- 对于 $100\\%$ 的数据，$3\\le N\\le 3\\times 10^5$ 且 $0\\le B_i\\le 2\\times 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P2778", "type": "P", "difficulty": 3, "samples": [["3\n0 0 1\n3 0 1\n2 0 4\n1\n0 0 3 0", "2"], ["3\n0 0 1\n0 0 2\n4 0 1\n2\n0 0 4 0\n0 0 0 4", "3\n2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "安徽"], "title": "[AHOI2016初中组] 迷宫", "background": "", "description": "小雪和小可可被困在了一个无限大的迷宫中。\n\n已经知道这个迷宫有 $N$ 堵环状的墙，如果把整个迷宫看作是一个二维平面，那么每一堵墙都是平面上一个圆。**任意两个圆不相交，不重合，也不会相切，但有可能相互包含**。小雪和小可可分别被困在了 $2$ 个不同的位置，且保证他们的位置与这些圆不重合。\n\n他们只有破坏墙面才能穿过去。\n\n小雪希望知道，如果他们要相见，至少要破坏掉多少堵墙？他们可以在任何位置相见。", "inputFormat": "第一行有一个整数 $N$，表示有多少堵墙。\n\n之后 $N$ 行，每一行有 $3$ 个整数 $x, y, r$，表示有一堵环状的墙是以 $(x,y)$ 为圆心，$r$ 为半径的。\n\n再下一行有一个整数 $Q$，表示有多少组询问。\n\n之后 $Q$ 行，每一行有 $4$ 个整数 $a, b, c, d$，给出了一组询问，表示小雪所在的位置为 $(a,b)$，小可可所在的位置为 $(c,d)$。", "outputFormat": "输出 $Q$ 行，对应 $Q$ 次询问，每一行输出一个整数，表示最少需要破坏掉多少堵墙才能相见。", "hint": "对于 $20\\%$ 的数据，$0\\le N\\le 200$。\n\n对于 $40\\%$ 的数据，$0\\le N\\le 1000$。\n\n对于 $100\\%$ 的数据，$0\\le N, Q\\le 8000,-10^8\\le x,y,r, a, b, c, d\\le 10^8$。\n\n此外，还有额外的 $20\\%$ 的数据，满足 $0\\le N\\le 1000,0\\le Q\\le 1000$。\n\n大数据点时限 $\\rm 3\\ s$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2016 Middle School Division] Maze", "background": "", "description": "Xiaoxue and Xiaokeke are trapped in an infinite maze.\n\nIt is known that this maze has $N$ ring-shaped walls. If we regard the entire maze as a 2D plane, then each wall is a circle on the plane. Any two circles do not intersect, do not coincide, and are not tangent, but they may contain each other. Xiaoxue and Xiaokeke are trapped at two different positions, and it is guaranteed that their positions do not lie on any of these circles.\n\nThey can pass through only by breaking the walls.\n\nXiaoxue wants to know the minimum number of walls they need to break in order to meet. They may meet at any location.", "inputFormat": "The first line contains an integer $N$, the number of walls.\n\nThe next $N$ lines each contain three integers $x, y, r$, indicating a ring-shaped wall that is a circle centered at $(x, y)$ with radius $r$.\n\nThe next line contains an integer $Q$, the number of queries.\n\nThe following $Q$ lines each contain four integers $a, b, c, d$, representing one query: Xiaoxue is at position $(a, b)$, and Xiaokeke is at position $(c, d)$.", "outputFormat": "Output $Q$ lines, one per query. For each query, output one integer: the minimum number of walls that must be broken for them to meet.", "hint": "For $20\\%$ of the testdata, $0\\le N\\le 200$.\n\nFor $40\\%$ of the testdata, $0\\le N\\le 1000$.\n\nFor $100\\%$ of the testdata, $0\\le N, Q\\le 8000,-10^8\\le x,y,r, a, b, c, d\\le 10^8$.\n\nIn addition, there is an extra $20\\%$ of the testdata with $0\\le N\\le 1000, 0\\le Q\\le 1000$.\n\nLarge testdata time limit: $\\rm 3\\ s$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2016初中组] 迷宫", "background": "", "description": "小雪和小可可被困在了一个无限大的迷宫中。\n\n已经知道这个迷宫有 $N$ 堵环状的墙，如果把整个迷宫看作是一个二维平面，那么每一堵墙都是平面上一个圆。**任意两个圆不相交，不重合，也不会相切，但有可能相互包含**。小雪和小可可分别被困在了 $2$ 个不同的位置，且保证他们的位置与这些圆不重合。\n\n他们只有破坏墙面才能穿过去。\n\n小雪希望知道，如果他们要相见，至少要破坏掉多少堵墙？他们可以在任何位置相见。", "inputFormat": "第一行有一个整数 $N$，表示有多少堵墙。\n\n之后 $N$ 行，每一行有 $3$ 个整数 $x, y, r$，表示有一堵环状的墙是以 $(x,y)$ 为圆心，$r$ 为半径的。\n\n再下一行有一个整数 $Q$，表示有多少组询问。\n\n之后 $Q$ 行，每一行有 $4$ 个整数 $a, b, c, d$，给出了一组询问，表示小雪所在的位置为 $(a,b)$，小可可所在的位置为 $(c,d)$。", "outputFormat": "输出 $Q$ 行，对应 $Q$ 次询问，每一行输出一个整数，表示最少需要破坏掉多少堵墙才能相见。", "hint": "对于 $20\\%$ 的数据，$0\\le N\\le 200$。\n\n对于 $40\\%$ 的数据，$0\\le N\\le 1000$。\n\n对于 $100\\%$ 的数据，$0\\le N, Q\\le 8000,-10^8\\le x,y,r, a, b, c, d\\le 10^8$。\n\n此外，还有额外的 $20\\%$ 的数据，满足 $0\\le N\\le 1000,0\\le Q\\le 1000$。\n\n大数据点时限 $\\rm 3\\ s$。", "locale": "zh-CN"}}}
{"pid": "P2779", "type": "P", "difficulty": 5, "samples": [["B?B?????", "6"], ["??BB????W???BB??????", "26"], ["????????B???????????W??B?????W????????????????????W????????W", "10058904"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "动态规划 DP", "2016", "线段树", "安徽"], "title": "[AHOI2016初中组] 黑白序列", "background": "小可可知道小雪喜欢什么样子的黑白序列。", "description": "首先，对于任何正整数 $n$，如果一个黑白序列是由连续 $n$ 个黑接上连续 $n$ 个白，那一定是小雪喜欢的黑白序列。\n\n其次，如果有两个黑白序列小雪都喜欢，那么把这两个序列接起来得到的新序列，小雪也一定喜欢。小雪不会喜欢更多别的黑白序列。\n\n例如，如果用字符 `B` 和 `W` 分别表示黑色，`W` 表示白色，那么 `BW`，`BBWW`，`BBBWWW` 以及 `BWBW`，`BWBBWW`，`BWBBWWBW` 都是小雪喜欢的黑白序列。而 `W`，`WW`，`WB`，`WBBW` 以及 `BBBWW` 都不是小雪喜欢的黑白序列。\n\n现在小可可准备了一个未完成的黑白序列，用 `B` 和 `W` 表示黑色和白色，用 `?` 表示尚未确定，他希望知道一共有多少种不同的方法，在决定了每一个 `?` 位置的颜色后可以得到一个小雪喜欢的黑白序列。\n\n两个方案若有至少一位不同才能算是不同的，不是 `?` 的位置是不允许修改的。\n\n答案对 $10^9 + 9$（一个素数）取模。\n\n\n\n\n\n", "inputFormat": "第一行输入一个长度大于零的字符串，由 `B`，`W` 和 `?` 组成。\n", "outputFormat": "输出一个整数，表示答案。", "hint": "#### 样例输入输出 1 解释\n有六种合法方案，依次得到的最终黑白序列为： \n\n- `BBBBWWWW`，\n- `BBBWWWBW`，\n- `BWBBBWWW`，\n- `BWBBWWBW`，\n- `BWBWBBWW`，\n- `BWBWBWBW`。\n\n#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，输入长度不超过 $22$。\n- 对于 $60\\%$ 的数据，输入长度不超过 $5000$。\n- 对于 $100\\%$ 的数据，输入长度不超过 $500000$，保证序列中只含 `W`，`B`，`?` 三种字符，其中 `?` 是英文字符。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2016 Middle School] Black-and-White Sequence", "background": "Xiao Keke knows what kind of black-and-white sequences Xiaoxue likes.", "description": "First, for any positive integer $n$, if a black-and-white sequence consists of $n$ consecutive blacks followed by $n$ consecutive whites, then Xiaoxue definitely likes it.\n\nSecond, if Xiaoxue likes two black-and-white sequences, then she also likes the new sequence obtained by concatenating these two sequences. Xiaoxue does not like any other black-and-white sequences.\n\nFor example, use characters `B` and `W` to denote black and white, respectively. Then `BW`, `BBWW`, `BBBWWW`, as well as `BWBW`, `BWBBWW`, `BWBBWWBW` are sequences that Xiaoxue likes. In contrast, `W`, `WW`, `WB`, `WBBW`, and `BBBWW` are not liked by Xiaoxue.\n\nNow Xiao Keke has prepared an incomplete black-and-white sequence, where `B` and `W` denote black and white, and `?` denotes undecided. He wants to know how many different ways there are to decide the color at every `?` so that the resulting sequence is liked by Xiaoxue.\n\nTwo assignments are considered different if they differ at least at one position. Positions that are not `?` are not allowed to be modified.\n\nOutput the answer modulo $10^9 + 9$ (a prime).", "inputFormat": "The first line contains a non-empty string consisting of `B`, `W`, and `?`.", "outputFormat": "Output a single integer, the answer.", "hint": "Explanation for Sample Input/Output 1:\nThere are six valid assignments, and the resulting sequences are:\n- `BBBBWWWW`,\n- `BBBWWWBW`,\n- `BWBBBWWW`,\n- `BWBBWWBW`,\n- `BWBWBBWW`,\n- `BWBWBWBW`.\n\nConstraints:\n- For 20% of the testdata, the input length does not exceed 22.\n- For 60% of the testdata, the input length does not exceed 5000.\n- For 100% of the testdata, the input length does not exceed 500000. The sequence contains only the three characters `W`, `B`, and `?`, where `?` is the ASCII question mark.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2016初中组] 黑白序列", "background": "小可可知道小雪喜欢什么样子的黑白序列。", "description": "首先，对于任何正整数 $n$，如果一个黑白序列是由连续 $n$ 个黑接上连续 $n$ 个白，那一定是小雪喜欢的黑白序列。\n\n其次，如果有两个黑白序列小雪都喜欢，那么把这两个序列接起来得到的新序列，小雪也一定喜欢。小雪不会喜欢更多别的黑白序列。\n\n例如，如果用字符 `B` 和 `W` 分别表示黑色，`W` 表示白色，那么 `BW`，`BBWW`，`BBBWWW` 以及 `BWBW`，`BWBBWW`，`BWBBWWBW` 都是小雪喜欢的黑白序列。而 `W`，`WW`，`WB`，`WBBW` 以及 `BBBWW` 都不是小雪喜欢的黑白序列。\n\n现在小可可准备了一个未完成的黑白序列，用 `B` 和 `W` 表示黑色和白色，用 `?` 表示尚未确定，他希望知道一共有多少种不同的方法，在决定了每一个 `?` 位置的颜色后可以得到一个小雪喜欢的黑白序列。\n\n两个方案若有至少一位不同才能算是不同的，不是 `?` 的位置是不允许修改的。\n\n答案对 $10^9 + 9$（一个素数）取模。\n\n\n\n\n\n", "inputFormat": "第一行输入一个长度大于零的字符串，由 `B`，`W` 和 `?` 组成。\n", "outputFormat": "输出一个整数，表示答案。", "hint": "#### 样例输入输出 1 解释\n有六种合法方案，依次得到的最终黑白序列为： \n\n- `BBBBWWWW`，\n- `BBBWWWBW`，\n- `BWBBBWWW`，\n- `BWBBWWBW`，\n- `BWBWBBWW`，\n- `BWBWBWBW`。\n\n#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，输入长度不超过 $22$。\n- 对于 $60\\%$ 的数据，输入长度不超过 $5000$。\n- 对于 $100\\%$ 的数据，输入长度不超过 $500000$，保证序列中只含 `W`，`B`，`?` 三种字符，其中 `?` 是英文字符。", "locale": "zh-CN"}}}
{"pid": "P2780", "type": "P", "difficulty": 4, "samples": [["4 2 58 100\n10 10 50 80", "15"], ["8 3 1300 1800\n2 0 1 9 1 4 0 5", "1782"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "安徽"], "title": "[AHOI2016初中组] 游戏", "background": "", "description": "小雪与小可可正在玩一种数字游戏。他们准备了 $n$ 张卡片，每一张卡片上都有一个整数。游戏开始后，小雪会先选择一个不小于 $a$ 且不大于 $b$ 的整数 $t$，并告诉小可可这个数字 $t$ 是多少。之后小可可会挑出恰好 $k$ 张卡片，并将这 $k$ 张卡片上的数字相加，得到的和数记为 $m$。\n\n小雪希望 $t$ 和 $m$ 差的绝对值尽可能大，而小可可却希望 $t$ 和 $m$ 差的绝对值尽可能小。在游戏开始前，他们二人都知道 $n$， $a$， $b$ 和 $k$ 是多少，也知道每一张卡片上的数字是多少。在小雪决定了 $t$ 的大小后，不能再修改，之后才由小可可挑选纸牌。\n\n小雪希望知道，在二人都尝试最优策略的情况下， $t$ 和 $m$ 差的绝对值最大可以有多大？", "inputFormat": "输入有两行。\n\n第一行有 4 个整数 $n$， $k$， $a$ 和 $b$，分别满足 $1 \\le k \\le n \\le 250$ 且 $0 \\le a \\le b \\le 75000$。\n\n第二行有 $n$ 个整数，依次为 $x_1$ 到 $x_n$，给出了每一张卡片上的数字。\n\n每一张卡片上的数字 $x_i$ 都满足 $0\\le x_i \\le 300$。", "outputFormat": "输出一行，只有一个整数，表示 $t$ 和 $m$ 差的绝对值最大可以有多大。", "hint": "对于 30% 的数据， $1\\le k\\le n\\le 20$ 且 $0\\le a\\le b\\le   6000$。\n\n对于 80% 的数据， $1\\le k\\le n\\le 65$ 且 $0\\le a\\le b\\le   19650$。\n\n对于 100% 的数据， $1\\le k\\le n\\le 250$ 且 $0\\le a\\le b\\le 75000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2016 Junior] Game", "background": "", "description": "Xiao Xue and Xiao Keke are playing a number game. They have prepared $n$ cards, each with an integer on it. At the beginning, Xiao Xue chooses an integer $t$ with $a \\le t \\le b$ and tells Xiao Keke the value of $t$. Then Xiao Keke selects exactly $k$ cards and sums their numbers; denote this sum by $m$.\n\nXiao Xue wants the absolute difference between $t$ and $m$ to be as large as possible, while Xiao Keke wants it to be as small as possible. Before the game starts, both of them know $n$, $a$, $b$, and $k$, and also the number on every card. After Xiao Xue decides $t$, it cannot be changed, and only then does Xiao Keke select the cards.\n\nXiao Xue wants to know, under optimal play by both of them, how large the absolute difference between $t$ and $m$ can be.", "inputFormat": "The input has two lines.\n\nThe first line contains 4 integers $n$, $k$, $a$, and $b$, satisfying $1 \\le k \\le n \\le 250$ and $0 \\le a \\le b \\le 75000$.\n\nThe second line contains $n$ integers, namely $x_1$ to $x_n$, which are the numbers on the cards.\n\nEach number $x_i$ satisfies $0 \\le x_i \\le 300$.", "outputFormat": "Output one line with a single integer, which is the maximum possible value of the absolute difference between $t$ and $m$.", "hint": "For 30% of the testdata, $1 \\le k \\le n \\le 20$ and $0 \\le a \\le b \\le 6000$.\n\nFor 80% of the testdata, $1 \\le k \\le n \\le 65$ and $0 \\le a \\le b \\le 19650$.\n\nFor 100% of the testdata, $1 \\le k \\le n \\le 250$ and $0 \\le a \\le b \\le 75000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2016初中组] 游戏", "background": "", "description": "小雪与小可可正在玩一种数字游戏。他们准备了 $n$ 张卡片，每一张卡片上都有一个整数。游戏开始后，小雪会先选择一个不小于 $a$ 且不大于 $b$ 的整数 $t$，并告诉小可可这个数字 $t$ 是多少。之后小可可会挑出恰好 $k$ 张卡片，并将这 $k$ 张卡片上的数字相加，得到的和数记为 $m$。\n\n小雪希望 $t$ 和 $m$ 差的绝对值尽可能大，而小可可却希望 $t$ 和 $m$ 差的绝对值尽可能小。在游戏开始前，他们二人都知道 $n$， $a$， $b$ 和 $k$ 是多少，也知道每一张卡片上的数字是多少。在小雪决定了 $t$ 的大小后，不能再修改，之后才由小可可挑选纸牌。\n\n小雪希望知道，在二人都尝试最优策略的情况下， $t$ 和 $m$ 差的绝对值最大可以有多大？", "inputFormat": "输入有两行。\n\n第一行有 4 个整数 $n$， $k$， $a$ 和 $b$，分别满足 $1 \\le k \\le n \\le 250$ 且 $0 \\le a \\le b \\le 75000$。\n\n第二行有 $n$ 个整数，依次为 $x_1$ 到 $x_n$，给出了每一张卡片上的数字。\n\n每一张卡片上的数字 $x_i$ 都满足 $0\\le x_i \\le 300$。", "outputFormat": "输出一行，只有一个整数，表示 $t$ 和 $m$ 差的绝对值最大可以有多大。", "hint": "对于 30% 的数据， $1\\le k\\le n\\le 20$ 且 $0\\le a\\le b\\le   6000$。\n\n对于 80% 的数据， $1\\le k\\le n\\le 65$ 且 $0\\le a\\le b\\le   19650$。\n\n对于 100% 的数据， $1\\le k\\le n\\le 250$ 且 $0\\le a\\le b\\le 75000$。\n", "locale": "zh-CN"}}}
{"pid": "P2781", "type": "P", "difficulty": 3, "samples": [["5 5\n2 1 2\n1 4 4 2\n1 2 4 7\n1 4 5 6\n2 3 4", "0\n22"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "枚举"], "title": "传教", "background": "写完暑假作业后，bx2k 去找 pear 玩。pear 表示他要去汉中传教，于是 bx2k 准备跟着去围观。", "description": "pear 把即将接受传教的人排成一行，每个人从左到右的编号为 $1\\sim n$。每个人有一个信仰值，一开始所有人的信仰值为 $0$。接着pear会做以下两件事之一：\n\n1. pear 向连续的一段人群传教。具体来说，pear 会使第 $l$个人到第 $r$ 个人之间的所有人的信仰值增加 $k$。\n\n2. pear 想知道某一段人的信仰值之和来得知泉岭精神是否深入人心。具体来说，pear 会问 bx2k 第 $l$ 个人到第 $r$ 个人之间所有人的信仰值之和。\n\n身为一个泉岭精神的信徒，bx2k 自然会帮 pear 来算。但是 bx2k 太笨了，根本不会算。于是他想找你来帮忙。", "inputFormat": "第一行包含两个整数 $n,m$。分别表示接受传教的人数以及 pear 的操作数。\n\n接下来 $m$ 行，每行包含若干个整数。若第一个整数为 $1$，则代表 pear 在进行传教，这一行接下来会包含 $l,r,k$ 三个整数。否则第一个整数为 $2$，代表 pear 的一个询问，这一行接下来会包含 $l,r$ 两个整数。", "outputFormat": "输出若干行，每行包含 $1$ 个整数，表示 pear 询问的答案。行数为 pear 的询问数量。", "hint": "【样例说明】\n\n一开始所有人的信仰值都为 $0$，所以答案为 $0$。到第五个操作时，五个人的信仰值分别为 $0,7,7,15,6$。则答案为 $7+15=22$\n\n【数据范围与约定】\n\n|测试点|$n,m$|特殊性质|\n|:-:|:-:|:-:|\n|$1 \\sim 3$|$\\le 10$|无|\n|$4 \\sim 5$|$\\le 10^3$|无|\n|$6 \\sim 8$|$\\le 10^9$|特殊性质 A|\n\n特殊性质 A：没有传教操作。\n\n对于所有测试点，$n \\le 10^9,m \\le 10^3,1 \\le l \\le r \\le n,k \\le10$", "locale": "zh-CN", "translations": {"en": {"title": "Preaching", "background": "After finishing his summer homework, bx2k went to play with pear. pear said he was going to Hanzhong to preach, so bx2k decided to tag along and watch.", "description": "pear lines up the people who are about to receive preaching in a row, numbered from left to right as $1 \\sim n$. Each person has a faith value, and initially all faith values are $0$. Then pear will perform one of the following two operations:\n\n1. pear preaches to a continuous segment of people. Specifically, pear will increase the faith value of every person from the $l$-th to the $r$-th person by $k$.\n\n2. pear wants to know the sum of faith values over a segment to see whether the \"Quanling spirit\" has taken root. Specifically, pear will ask bx2k for the sum of the faith values of all people from the $l$-th to the $r$-th person.\n\nAs a believer in the \"Quanling spirit,\" bx2k naturally wants to help pear calculate. However, bx2k is too clumsy to do the math, so he is asking you for help.", "inputFormat": "The first line contains two integers $n, m$, representing the number of people receiving preaching and the number of operations by pear, respectively.\n\nThe next $m$ lines each contain several integers. If the first integer is $1$, it means pear is preaching, and this line will then contain three integers $l, r, k$. Otherwise, if the first integer is $2$, it means pear is making a query, and this line will then contain two integers $l, r$.", "outputFormat": "Output several lines, each containing $1$ integer, representing the answer to pear’s query. The number of lines equals the number of queries.", "hint": "Sample explanation:\nInitially, everyone’s faith value is $0$, so the answer is $0$. By the time of the fifth operation, the five people’s faith values are $0, 7, 7, 15, 6$. Thus, the answer is $7 + 15 = 22$.\n\nConstraints:\n| Test point | $n, m$ | Special property |\n|:-:|:-:|:-:|\n| $1 \\sim 3$ | $\\le 10$ | None |\n| $4 \\sim 5$ | $\\le 10^3$ | None |\n| $6 \\sim 8$ | $\\le 10^9$ | Special property A |\n\nSpecial property A: No preaching operations.\n\nFor all test points, $n \\le 10^9$, $m \\le 10^3$, $1 \\le l \\le n$, $1 \\le r \\le n$, $k \\le 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "传教", "background": "写完暑假作业后，bx2k 去找 pear 玩。pear 表示他要去汉中传教，于是 bx2k 准备跟着去围观。", "description": "pear 把即将接受传教的人排成一行，每个人从左到右的编号为 $1\\sim n$。每个人有一个信仰值，一开始所有人的信仰值为 $0$。接着pear会做以下两件事之一：\n\n1. pear 向连续的一段人群传教。具体来说，pear 会使第 $l$个人到第 $r$ 个人之间的所有人的信仰值增加 $k$。\n\n2. pear 想知道某一段人的信仰值之和来得知泉岭精神是否深入人心。具体来说，pear 会问 bx2k 第 $l$ 个人到第 $r$ 个人之间所有人的信仰值之和。\n\n身为一个泉岭精神的信徒，bx2k 自然会帮 pear 来算。但是 bx2k 太笨了，根本不会算。于是他想找你来帮忙。", "inputFormat": "第一行包含两个整数 $n,m$。分别表示接受传教的人数以及 pear 的操作数。\n\n接下来 $m$ 行，每行包含若干个整数。若第一个整数为 $1$，则代表 pear 在进行传教，这一行接下来会包含 $l,r,k$ 三个整数。否则第一个整数为 $2$，代表 pear 的一个询问，这一行接下来会包含 $l,r$ 两个整数。", "outputFormat": "输出若干行，每行包含 $1$ 个整数，表示 pear 询问的答案。行数为 pear 的询问数量。", "hint": "【样例说明】\n\n一开始所有人的信仰值都为 $0$，所以答案为 $0$。到第五个操作时，五个人的信仰值分别为 $0,7,7,15,6$。则答案为 $7+15=22$\n\n【数据范围与约定】\n\n|测试点|$n,m$|特殊性质|\n|:-:|:-:|:-:|\n|$1 \\sim 3$|$\\le 10$|无|\n|$4 \\sim 5$|$\\le 10^3$|无|\n|$6 \\sim 8$|$\\le 10^9$|特殊性质 A|\n\n特殊性质 A：没有传教操作。\n\n对于所有测试点，$n \\le 10^9,m \\le 10^3,1 \\le l \\le r \\le n,k \\le10$", "locale": "zh-CN"}}}
{"pid": "P2782", "type": "P", "difficulty": 3, "samples": [["7\n22 4\n2 6\n10 3\n15 12\n9 8\n17 17\n4 2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "二分", "排序"], "title": "友好城市", "background": "", "description": "有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的 $N$ 个城市。北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航道不相交的情况下，被批准的申请尽量多。\n", "inputFormat": "第一行，一个整数 $N$，表示城市数。\n\n第二行到第 $N+1$ 行，每行两个整数，中间用一个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。\n", "outputFormat": "仅一行，输出一个整数，表示政府所能批准的最多申请数。\n", "hint": "### 数据规模与约定\n\n- 对于 $50\\%$ 的数据，$1 \\leq N \\leq 5000$，$0 \\leq x _ i \\leq 10000$。\n- 对于 $100\\%$ 的数据，$1 \\leq N \\leq 2 \\times 10 ^ 5$，$0 \\leq x _ i \\leq 10 ^ 6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Friendly Cities", "background": "", "description": "There is an east-west river with straight north and south banks. On each bank, there are $N$ cities at distinct positions. Each city on the north bank has exactly one friendly city on the south bank, and different cities have different friendly cities. Each pair of friendly cities applies to build a straight shipping lane across the river connecting the two cities. However, due to heavy fog on the river, the government decides to avoid any two lanes crossing to prevent accidents. Write a program to approve and reject some applications so that, while ensuring no two lanes cross, the number of approved applications is maximized.", "inputFormat": "The first line contains an integer $N$, the number of cities.\nFrom the second line to the $(N+1)$-th line, each line contains two integers separated by a space, representing the coordinates of a pair of friendly cities on the south and north banks, respectively.", "outputFormat": "Output a single line with one integer, the maximum number of applications the government can approve.", "hint": "Constraints\n\n- For $50\\%$ of the testdata, $1 \\leq N \\leq 5000$, $0 \\leq x_i \\leq 10000$.\n- For $100\\%$ of the testdata, $1 \\leq N \\leq 2 \\times 10^5$, $0 \\leq x_i \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "友好城市", "background": "", "description": "有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的 $N$ 个城市。北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航道不相交的情况下，被批准的申请尽量多。\n", "inputFormat": "第一行，一个整数 $N$，表示城市数。\n\n第二行到第 $N+1$ 行，每行两个整数，中间用一个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。\n", "outputFormat": "仅一行，输出一个整数，表示政府所能批准的最多申请数。\n", "hint": "### 数据规模与约定\n\n- 对于 $50\\%$ 的数据，$1 \\leq N \\leq 5000$，$0 \\leq x _ i \\leq 10000$。\n- 对于 $100\\%$ 的数据，$1 \\leq N \\leq 2 \\times 10 ^ 5$，$0 \\leq x _ i \\leq 10 ^ 6$。\n", "locale": "zh-CN"}}}
{"pid": "P2783", "type": "P", "difficulty": 5, "samples": [["3 2\n1 2\n2 3\n2\n1 2\n2 3\n", "10\n10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "Tarjan", "双连通分量", "最近公共祖先 LCA"], "title": "有机化学之神偶尔会做作弊", "background": "XS 中学化学竞赛组教练是一个酷爱炉石的人。\n\n有一天他一边搓炉石一边监考，而你作为一个信息竞赛的大神也来凑热闹。\n\n然而你的化竞基友却向你求助了。\n\n“第 1354 题怎么做？”<--手语  他问道。", "description": "你翻到那一题：给定一个烃，只含有单键（给初中生的一个理解性解释：就是一堆碳用横线连起来，横线都是单条的）。\n\n然后炎魔之王拉格纳罗斯用他的火焰净化了一切环（？？？）。所有的环状碳都变成了一个碳，如图所示。\n\n![环状碳变为一个碳](https://cdn.luogu.com.cn/upload/pic/2758.png)\n\n然后指定多组碳，求出它们之间总共有多少碳，如图所示（和上图没有关系）。\n\n![求出有多少碳](https://cdn.luogu.com.cn/upload/pic/2759.png)\n\n但是因为在考试，所以你只能把这个答案用手语告诉你的基友。你决定用二进制来表示最后的答案，如图所示（不要在意，和题目没有什么没关系）。\n\n![二进制手语](https://cdn.luogu.com.cn/upload/pic/2760.png)\n\n### 题意简述\n\n给你一个 $n$ 个点，$m$ 条边的无向图。把图中所有的环变为一个点，求变化后某两个点之间有多少个点。", "inputFormat": "第一行两个整数 $n$，$m$。表示有 $n$ 个点，$m$ 根键。\n\n接下来 $m$ 行每行两个整数 $u$，$v$ 表示 $u$ 号碳和 $v$ 号碳有一根键。\n\n接下来一个整数 $tot$ 表示询问次数。\n\n接下来 $tot$ 行每行两个整数，$a$，$b$ 表示询问的两个碳的编号。", "outputFormat": "共 $tot$ 行，每行一个二进制数，表示答案。", "hint": "两个碳不成环。\n\n## 数据范围及约定\n\n对于 $100\\%$ 的数据，$1<n\\le10 ^ 4$，$1<m\\le5\\times 10 ^ 4$。", "locale": "zh-CN", "translations": {"en": {"title": "The God of Organic Chemistry Occasionally Cheats", "background": "The coach of the XS Middle School chemistry contest team is a big fan of Hearthstone.\n\nOne day, he was invigilating while playing Hearthstone, and you, being a programming contest pro, also came to watch.\n\nHowever, your chemistry-contest buddy turned to you for help.\n\n\"How do I solve Problem 1354?\" — he asked in sign language.", "description": "You flip to that problem: given a hydrocarbon that contains only single bonds (an intuitive explanation for middle schoolers: a bunch of carbons connected by single lines, and every line is a single bond).\n\nThen Ragnaros the Firelord purified all cycles with his flames (???). Every cyclic carbon structure is contracted into a single carbon, as shown in the figure.\n\n![环状碳变为一个碳](https://cdn.luogu.com.cn/upload/pic/2758.png)\n\nNext, for multiple specified pairs of carbons, compute how many carbons are between them in total, as illustrated (this illustration is unrelated to the one above).\n\n![求出有多少碳](https://cdn.luogu.com.cn/upload/pic/2759.png)\n\nBut since this is during an exam, you can only tell your buddy the answer using sign language. You decide to represent the final answer in binary, as shown (don’t mind it; it’s not really related to the problem).\n\n![二进制手语](https://cdn.luogu.com.cn/upload/pic/2760.png)\n\nIn short: you are given an undirected graph with $n$ vertices and $m$ edges. Contract every cycle in the graph into a single vertex. After this transformation, for each query asking about two vertices, find how many vertices lie between them.", "inputFormat": "- The first line contains two integers $n$, $m$, meaning there are $n$ vertices and $m$ bonds.\n- The next $m$ lines each contain two integers $u$, $v$, indicating there is a bond between carbon $u$ and carbon $v$.\n- The next line contains an integer $tot$, the number of queries.\n- The next $tot$ lines each contain two integers $a$, $b$, denoting the indices of the two queried carbons.", "outputFormat": "Output $tot$ lines, each containing a binary number representing the answer.", "hint": "The two queried carbons do not lie on a cycle.\n\n# Constraints\n\nFor $100\\%$ of the testdata, $1 < n \\le 10^4$, $1 < m \\le 5 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "有机化学之神偶尔会做作弊", "background": "XS 中学化学竞赛组教练是一个酷爱炉石的人。\n\n有一天他一边搓炉石一边监考，而你作为一个信息竞赛的大神也来凑热闹。\n\n然而你的化竞基友却向你求助了。\n\n“第 1354 题怎么做？”<--手语  他问道。", "description": "你翻到那一题：给定一个烃，只含有单键（给初中生的一个理解性解释：就是一堆碳用横线连起来，横线都是单条的）。\n\n然后炎魔之王拉格纳罗斯用他的火焰净化了一切环（？？？）。所有的环状碳都变成了一个碳，如图所示。\n\n![环状碳变为一个碳](https://cdn.luogu.com.cn/upload/pic/2758.png)\n\n然后指定多组碳，求出它们之间总共有多少碳，如图所示（和上图没有关系）。\n\n![求出有多少碳](https://cdn.luogu.com.cn/upload/pic/2759.png)\n\n但是因为在考试，所以你只能把这个答案用手语告诉你的基友。你决定用二进制来表示最后的答案，如图所示（不要在意，和题目没有什么没关系）。\n\n![二进制手语](https://cdn.luogu.com.cn/upload/pic/2760.png)\n\n### 题意简述\n\n给你一个 $n$ 个点，$m$ 条边的无向图。把图中所有的环变为一个点，求变化后某两个点之间有多少个点。", "inputFormat": "第一行两个整数 $n$，$m$。表示有 $n$ 个点，$m$ 根键。\n\n接下来 $m$ 行每行两个整数 $u$，$v$ 表示 $u$ 号碳和 $v$ 号碳有一根键。\n\n接下来一个整数 $tot$ 表示询问次数。\n\n接下来 $tot$ 行每行两个整数，$a$，$b$ 表示询问的两个碳的编号。", "outputFormat": "共 $tot$ 行，每行一个二进制数，表示答案。", "hint": "两个碳不成环。\n\n## 数据范围及约定\n\n对于 $100\\%$ 的数据，$1<n\\le10 ^ 4$，$1<m\\le5\\times 10 ^ 4$。", "locale": "zh-CN"}}}
{"pid": "P2784", "type": "P", "difficulty": 3, "samples": [["3 3 1 3\n1 3 0.8\n1 2 0.9\n2 3 0.9\n", "0.8100"], ["3 3 2 1\n1 3 0.8\n1 2 0.9\n2 3 0.9\n", "orz"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "洛谷原创", "队列"], "title": "化学1（chem1）- 化学合成", "background": "蒟蒻 HansBug 在化学考场上，挠了无数次的头，可脑子里还是一片空白。", "description": "眼下出现在蒟蒻 HansBug 面前的是一个化学合成题，据他所知，一般答案如下面这样的格式：\n\n![](https://cdn.luogu.com.cn/upload/pic/2223.png) （接下一行）\n\n![](https://cdn.luogu.com.cn/upload/pic/2221.png) \n\n简单解释下：每种化合物可以通过一步反应生成另一个化合物（将这称作一步反应，设为 $A\\rightarrow B$），现在假设每个 $A\\rightarrow B$ 中，理论上 $1$ 个单位的 $A$ 都仅可以生成 $1$ 个单位的 $B$。然而实际实验表明，并不存在绝对完全的化学转化，设转化率为 $C$（即 $1$ 个单位 $A$ 实际可以生成 $C$ 个单位的 $B$，$0<C<1$）。\n\n现在蒟蒻 HansBug 的知识体系中有 $N$ 个这样 $A\\rightarrow B$ 的转化。然而题目中蒟蒻 HansBug 要由 $1$ 个单位的化合物 $S$ 生成化合物 $T$，可是他脑细胞和 RP 已经消耗殆尽，所以找到最终产量最高的合成路线的艰巨任务就交给你啦！", "inputFormat": "第一行为四个整数：$N,M,S,T$，分别表示总共出现的化合物个数、HansBug 所知道的反应个数、起始的化合物序号、终末的化合物序号（$1\\le S,T\\le N$）。\n\n第 $2 \\sim M+1$ 行每行为两个整数和一个实数：$A_i,B_i,C_i$，分别表示第 $i$ 个反应为由 $1$ 个单位的 $A_i$ 化合物生成 $C_i$ 单位的 $B_i$ 化合物。", "outputFormat": "一行，包含一个实数，为最佳路线下最终的产量（四舍五入保留 $4$ 位小数），如果没有可行路线的话，输出 `orz`。", "hint": "样例 1 和样例 2 中，两条合成路线分别为 $1\\rightarrow3$、$1\\rightarrow2$、$2\\rightarrow3$，产率分别为 $0.8$、$0.9$、$0.9$。\n\n在样例 1 中，有两种可行的路线 $1\\rightarrow3$ 和 $1\\rightarrow2\\rightarrow3$ ，最终产量分别为 $0.8$、$0.9\\times0.9=0.81$，故第二条路线更优，产量为 $0.8100$。\n\n样例 2 中，$2$ 只能生成 $3$，$3$ 无法生成别的化合物，故无法生成，蒟蒻 HansBug 只好选择 `orz`。\n\n**【数据范围】**\n\n![](https://cdn.luogu.com.cn/upload/pic/2220.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "Chemistry 1 (chem1) - Chemical Synthesis", "background": "The juruo HansBug scratched his head countless times in the chemistry exam, yet his mind was still blank.", "description": "In front of the juruo HansBug is a chemical synthesis problem. As far as he knows, answers are usually written in the following format:\n\n![](https://cdn.luogu.com.cn/upload/pic/2223.png) (continued on the next line)\n\n![](https://cdn.luogu.com.cn/upload/pic/2221.png)\n\nA brief explanation: each compound can produce another compound through a one-step reaction (call this a one-step reaction, denoted as $A \\rightarrow B$). Now assume that in each $A \\rightarrow B$, theoretically $1$ unit of $A$ can only produce $1$ unit of $B$. However, actual experiments show that perfectly complete chemical conversion does not exist. Let the conversion rate be $C$ (i.e., $1$ unit of $A$ actually produces $C$ units of $B$, where $0 < C < 1$).\n\nIn the juruo HansBug’s knowledge base there are $N$ such $A \\rightarrow B$ conversions. In this problem, HansBug needs to produce compound $T$ starting from $1$ unit of compound $S$. But his brain cells and RP are exhausted, so the arduous task of finding the synthesis route with the highest final yield is handed over to you!", "inputFormat": "The first line contains four integers: $N, M, S, T$, representing the total number of distinct compounds, the number of reactions known to HansBug, the index of the starting compound, and the index of the target compound, respectively ($1 \\le S, T \\le N$).\n\nLines $2$ to $M+1$ each contain two integers and one real number: $A_i, B_i, C_i$, indicating that the $i$-th reaction converts $1$ unit of compound $A_i$ into $C_i$ units of compound $B_i$.", "outputFormat": "Output one line containing a real number: the final yield along the optimal route (rounded to $4$ decimal places). If there is no feasible route, output `orz`.", "hint": "In Sample $1$ and Sample $2$, the two synthesis routes are $1 \\rightarrow 3$, $1 \\rightarrow 2$, $2 \\rightarrow 3$, with yields $0.8$, $0.9$, $0.9$, respectively.\n\nIn Sample $1$, there are two feasible routes, $1 \\rightarrow 3$ and $1 \\rightarrow 2 \\rightarrow 3$. Their final yields are $0.8$ and $0.9 \\times 0.9 = 0.81$, respectively, so the second route is better, with a yield of $0.8100$.\n\nIn Sample $2$, $2$ can only produce $3$, and $3$ cannot produce any other compound, so synthesis is impossible, and the juruo HansBug has to output `orz`.\n\nConstraints\n\n![](https://cdn.luogu.com.cn/upload/pic/2220.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "化学1（chem1）- 化学合成", "background": "蒟蒻 HansBug 在化学考场上，挠了无数次的头，可脑子里还是一片空白。", "description": "眼下出现在蒟蒻 HansBug 面前的是一个化学合成题，据他所知，一般答案如下面这样的格式：\n\n![](https://cdn.luogu.com.cn/upload/pic/2223.png) （接下一行）\n\n![](https://cdn.luogu.com.cn/upload/pic/2221.png) \n\n简单解释下：每种化合物可以通过一步反应生成另一个化合物（将这称作一步反应，设为 $A\\rightarrow B$），现在假设每个 $A\\rightarrow B$ 中，理论上 $1$ 个单位的 $A$ 都仅可以生成 $1$ 个单位的 $B$。然而实际实验表明，并不存在绝对完全的化学转化，设转化率为 $C$（即 $1$ 个单位 $A$ 实际可以生成 $C$ 个单位的 $B$，$0<C<1$）。\n\n现在蒟蒻 HansBug 的知识体系中有 $N$ 个这样 $A\\rightarrow B$ 的转化。然而题目中蒟蒻 HansBug 要由 $1$ 个单位的化合物 $S$ 生成化合物 $T$，可是他脑细胞和 RP 已经消耗殆尽，所以找到最终产量最高的合成路线的艰巨任务就交给你啦！", "inputFormat": "第一行为四个整数：$N,M,S,T$，分别表示总共出现的化合物个数、HansBug 所知道的反应个数、起始的化合物序号、终末的化合物序号（$1\\le S,T\\le N$）。\n\n第 $2 \\sim M+1$ 行每行为两个整数和一个实数：$A_i,B_i,C_i$，分别表示第 $i$ 个反应为由 $1$ 个单位的 $A_i$ 化合物生成 $C_i$ 单位的 $B_i$ 化合物。", "outputFormat": "一行，包含一个实数，为最佳路线下最终的产量（四舍五入保留 $4$ 位小数），如果没有可行路线的话，输出 `orz`。", "hint": "样例 1 和样例 2 中，两条合成路线分别为 $1\\rightarrow3$、$1\\rightarrow2$、$2\\rightarrow3$，产率分别为 $0.8$、$0.9$、$0.9$。\n\n在样例 1 中，有两种可行的路线 $1\\rightarrow3$ 和 $1\\rightarrow2\\rightarrow3$ ，最终产量分别为 $0.8$、$0.9\\times0.9=0.81$，故第二条路线更优，产量为 $0.8100$。\n\n样例 2 中，$2$ 只能生成 $3$，$3$ 无法生成别的化合物，故无法生成，蒟蒻 HansBug 只好选择 `orz`。\n\n**【数据范围】**\n\n![](https://cdn.luogu.com.cn/upload/pic/2220.png)\n", "locale": "zh-CN"}}}
{"pid": "P2785", "type": "P", "difficulty": 4, "samples": [["3 1\n0 0\n1 0\n0 2\n", "1.0000"], ["4 1\n1 1\n1 -1\n-1 -1\n-1 1\n", "4.0000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "计算几何", "洛谷原创"], "title": "物理1（phsic1）- 磁通量", "background": "蒟蒻 HansBug 在物理考场上，挠了无数次的头，可脑子里还是一片空白。", "description": "眼下出现在 HansBug 蒟蒻面前的是一个奇怪的磁场，形状为多边形，可以描述为 $N$ 个点构成的序列，这些点即依次为该磁场的各个顶点。于是现在蒟蒻 HansBug 想要知道该磁场的磁通量为多少。可是他脑细胞和 RP 已经消耗殆尽，所以这个高端的任务就交给你们啦。", "inputFormat": "第一行为一个整数 $N$ 和一个实数 $B$，$B$ 为磁感应强度。\n\n第 $2\\sim N+1$ 行，每行包含两个实数，表示该点的横纵坐标。", "outputFormat": "一行，包含一个实数，即为磁通量（输出四舍五入保留四位小数）。", "hint": "磁通量 $=$ 磁感应强度 $\\times$ 磁场区域面积。\n\n![](https://cdn.luogu.com.cn/upload/pic/2219.png)\n\n$0\\lt B\\le 10$。", "locale": "zh-CN", "translations": {"en": {"title": "Physics 1 (phsic1) - Magnetic Flux", "background": "The newbie HansBug scratched his head countless times in the physics exam, yet his mind was still blank.", "description": "In front of the newbie HansBug is a peculiar magnetic field region in the shape of a polygon, described by a sequence of $N$ points, which are the vertices of the region in order. Now HansBug wants to know the magnetic flux of this region. However, his brain cells and luck have been depleted, so this high-end task is left to you.", "inputFormat": "The first line contains an integer $N$ and a real number $B$, where $B$ is the magnetic flux density.\n\nLines $2\\sim N+1$ each contain two real numbers, representing the $x$ and $y$ coordinates of a point.", "outputFormat": "Output one line containing a real number: the magnetic flux (rounded to 4 decimal places).", "hint": "Magnetic flux $=$ magnetic flux density $\\times$ area of the magnetic field region.\n\n![](https://cdn.luogu.com.cn/upload/pic/2219.png)\n\n$0\\lt B\\le 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "物理1（phsic1）- 磁通量", "background": "蒟蒻 HansBug 在物理考场上，挠了无数次的头，可脑子里还是一片空白。", "description": "眼下出现在 HansBug 蒟蒻面前的是一个奇怪的磁场，形状为多边形，可以描述为 $N$ 个点构成的序列，这些点即依次为该磁场的各个顶点。于是现在蒟蒻 HansBug 想要知道该磁场的磁通量为多少。可是他脑细胞和 RP 已经消耗殆尽，所以这个高端的任务就交给你们啦。", "inputFormat": "第一行为一个整数 $N$ 和一个实数 $B$，$B$ 为磁感应强度。\n\n第 $2\\sim N+1$ 行，每行包含两个实数，表示该点的横纵坐标。", "outputFormat": "一行，包含一个实数，即为磁通量（输出四舍五入保留四位小数）。", "hint": "磁通量 $=$ 磁感应强度 $\\times$ 磁场区域面积。\n\n![](https://cdn.luogu.com.cn/upload/pic/2219.png)\n\n$0\\lt B\\le 10$。", "locale": "zh-CN"}}}
{"pid": "P2786", "type": "P", "difficulty": 3, "samples": [["5 99\nhansbug 1\nkkksc03 2\nyyy 3\nabsi2011 4\nlzn 100\nhansbug is a juruo!but absi2011 not.!?!\none day absi2011 laughed at yyy and hansbug.\nthen kkksc03 and lzn blamed him for that.\n", "16"], ["5 99\nyyyy 1\nkkksc03 2\nyyy 3\nabsi2011 4\nlzn 100\nyyyy is a juruo!but absi2011 not.!?!\none day absi2011 laughed at yyy and yyyy.\nthen kkksc03 and lzn blamed him for that.\n", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "树形数据结构", "平衡树", "洛谷原创", "哈希 hashing", "STL"], "title": "英语1（eng1）- 英语作文", "background": "蒟蒻 HansBug 在英语考场上，挠了无数次的头，可脑子里还是一片空白。", "description": "眼下出现在 HansBug 蒟蒻面前的是一篇英语作文，然而智商捉急的 HansBug 已经草草写完了，此时他发现离考试结束还有 $40$ 分钟，于是他打算估计一下这篇共有 $M$ 个单词的英语作文的含金量如何。众所周知的是，在中高考英语作文中使用高级词汇可以有效提高文章的含金量，从而获得更好的分数。已知蒟蒻 HansBug 知道 $N$ 个高级词汇，该词汇为 $A_i$（词汇长度为 $L_i$，包含数字、大小写字母），该高级词汇的含金量为 $B_i$，则该高级词汇每出现一次便可增加 $B_i$ 的含金量。可是他脑细胞和 RP 已经消耗殆尽，所以这个伟大的任务就交给你啦！", "inputFormat": "第一行包含两个正整数 $N$ 和 $P$，$N$ 表示 HansBug 共知道的高级词汇个数，$P$ 为模数。\n\n接下来 $N$ 行，每行包含一个单词 $A_i$（长度为 $L_i$）和一个整数 $B_i$，其中 $B_i(0<B_i\\le 10^5)$ 表示该单词的含金量。\n\n接下来直到输入结束的若干行为一篇英语作文，其中包含共计 $M$ 个单词，以及若干的分隔符（分隔符包含且仅包含 `,`、`.`、`!`、`?`）。", "outputFormat": "一行，包含一个整数，为该文章的总含金量对 $P$ 的模。", "hint": "样例 $1$ 中，共计出现了 $2$ 次 `hansbug`、$2$ 次 `absi2011`、$1$ 次 `yyy`、$1$ 次 `kkksc03`、$1$ 次 `lzn`，所以总含金量为 $1\\times2+2\\times4+3\\times1+4\\times1+100\\times1=115$，对 $99$ 取模就是 $16$。\n\n样例 $2$ 中，和样例 $1$ 基本一样，值得注意的是整体的 `yyyy` 不可以被认为是 `yyy` 出现 $2$ 次，请注意这是一篇英语作文，一切以单词为最小单位。\n\n此题目中大小写敏感。\n\n数据范围（设所有单词的最大长度为 $\\rm{Lmax}$）：\n\n| 测试点编号 | $N$ | $M$ | $\\rm{Lmax}$ |\n|:-:|:-:|:-:|:-:|\n| $1\\sim 3$ | $\\le 10$ | $\\le 100$ | $\\le 4$ |\n| $4\\sim 5$ | $\\le 10^5$ | $\\le 3\\times 10^4$ | ^ |\n| $6\\sim 7$ | $\\le 5\\times 10^4$ | $\\le 10^4$ | $\\le 50$ |\n| $8\\sim 10$ | $\\le 10^5$ | $\\le 3\\times 10^4$ | ^ |\n\n对于所有数据，$1\\le N\\le 10^5$，$1\\le M\\le 3\\times 10^4$，$1\\le P\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "English 1 (eng1) - English Essay", "background": "\"Juruo\" HansBug scratched his head countless times in the English exam room, but his mind was still blank.", "description": "In front of \"juruo\" HansBug is an English essay. However, with his anxious IQ, HansBug has already scribbled a draft. He then notices there are still $40$ minutes left before the exam ends, so he decides to estimate the \"value\" (also called \"gold content\") of this English essay, which contains $M$ words in total. As we all know, using advanced vocabulary in English essays for entrance exams can effectively raise the essay’s \"gold content\", thus earning a better score. It is known that \"juruo\" HansBug knows $N$ advanced words, denoted as $A_i$ (each word has length $L_i$ and consists of digits and letters in both uppercase and lowercase). The \"gold content\" value of this advanced word is $B_i$, meaning every occurrence of this word increases the total value by $B_i$. But his brain cells and RP (\"luck\") are already exhausted, so this great task is left to you!", "inputFormat": "- The first line contains two positive integers $N$ and $P$, where $N$ is the number of advanced words HansBug knows, and $P$ is the modulus.\n- The next $N$ lines each contain a word $A_i$ (of length $L_i$) and an integer $B_i$, where $B_i$ satisfies $0 < B_i \\le 10^5$, representing the value of that word.\n- The following lines until the end of input form an English essay, which contains $M$ words in total, along with some separators (the separators include and only include `,`, `.`, `!`, `?`).", "outputFormat": "Output one line containing a single integer: the total value of the essay modulo $P$.", "hint": "In sample $1$, there are $2$ occurrences of `hansbug`, $2$ of `absi2011`, $1$ of `yyy`, $1$ of `kkksc03`, and $1$ of `lzn`, so the total value is $1 \\times 2 + 2 \\times 4 + 3 \\times 1 + 4 \\times 1 + 100 \\times 1 = 115$, and $115 \\bmod 99 = 16$.\n\nIn sample $2$, it is basically the same as sample $1$. Note that the whole `yyyy` cannot be considered as `yyy` appearing $2$ times. Please note this is an English essay; treat the word as the smallest unit.\n\nThis problem is case-sensitive.\n\nConstraints (let the maximum length of all words be $\\rm{Lmax}$):\n\n| Test point ID | $N$ | $M$ | $\\rm{Lmax}$ |\n|:-:|:-:|:-:|:-:|\n| $1\\sim 3$ | $\\le 10$ | $\\le 100$ | $\\le 4$ |\n| $4\\sim 5$ | $\\le 10^5$ | $\\le 3 \\times 10^4$ | ^ |\n| $6\\sim 7$ | $\\le 5 \\times 10^4$ | $\\le 10^4$ | $\\le 50$ |\n| $8\\sim 10$ | $\\le 10^5$ | $\\le 3 \\times 10^4$ | ^ |\n\nFor all testdata, $1 \\le N \\le 10^5$, $1 \\le M \\le 3 \\times 10^4$, $1 \\le P \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "英语1（eng1）- 英语作文", "background": "蒟蒻 HansBug 在英语考场上，挠了无数次的头，可脑子里还是一片空白。", "description": "眼下出现在 HansBug 蒟蒻面前的是一篇英语作文，然而智商捉急的 HansBug 已经草草写完了，此时他发现离考试结束还有 $40$ 分钟，于是他打算估计一下这篇共有 $M$ 个单词的英语作文的含金量如何。众所周知的是，在中高考英语作文中使用高级词汇可以有效提高文章的含金量，从而获得更好的分数。已知蒟蒻 HansBug 知道 $N$ 个高级词汇，该词汇为 $A_i$（词汇长度为 $L_i$，包含数字、大小写字母），该高级词汇的含金量为 $B_i$，则该高级词汇每出现一次便可增加 $B_i$ 的含金量。可是他脑细胞和 RP 已经消耗殆尽，所以这个伟大的任务就交给你啦！", "inputFormat": "第一行包含两个正整数 $N$ 和 $P$，$N$ 表示 HansBug 共知道的高级词汇个数，$P$ 为模数。\n\n接下来 $N$ 行，每行包含一个单词 $A_i$（长度为 $L_i$）和一个整数 $B_i$，其中 $B_i(0<B_i\\le 10^5)$ 表示该单词的含金量。\n\n接下来直到输入结束的若干行为一篇英语作文，其中包含共计 $M$ 个单词，以及若干的分隔符（分隔符包含且仅包含 `,`、`.`、`!`、`?`）。", "outputFormat": "一行，包含一个整数，为该文章的总含金量对 $P$ 的模。", "hint": "样例 $1$ 中，共计出现了 $2$ 次 `hansbug`、$2$ 次 `absi2011`、$1$ 次 `yyy`、$1$ 次 `kkksc03`、$1$ 次 `lzn`，所以总含金量为 $1\\times2+2\\times4+3\\times1+4\\times1+100\\times1=115$，对 $99$ 取模就是 $16$。\n\n样例 $2$ 中，和样例 $1$ 基本一样，值得注意的是整体的 `yyyy` 不可以被认为是 `yyy` 出现 $2$ 次，请注意这是一篇英语作文，一切以单词为最小单位。\n\n此题目中大小写敏感。\n\n数据范围（设所有单词的最大长度为 $\\rm{Lmax}$）：\n\n| 测试点编号 | $N$ | $M$ | $\\rm{Lmax}$ |\n|:-:|:-:|:-:|:-:|\n| $1\\sim 3$ | $\\le 10$ | $\\le 100$ | $\\le 4$ |\n| $4\\sim 5$ | $\\le 10^5$ | $\\le 3\\times 10^4$ | ^ |\n| $6\\sim 7$ | $\\le 5\\times 10^4$ | $\\le 10^4$ | $\\le 50$ |\n| $8\\sim 10$ | $\\le 10^5$ | $\\le 3\\times 10^4$ | ^ |\n\n对于所有数据，$1\\le N\\le 10^5$，$1\\le M\\le 3\\times 10^4$，$1\\le P\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P2787", "type": "P", "difficulty": 5, "samples": [["10 5\nABCDABCDCD\n1 1 3 A\n3 1 5\n1 1 3 A\n2 1 2 B\n1 2 3 B\n", "1\n2\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "线段树", "洛谷原创", "枚举"], "title": "语文1（chin1）- 理理思维", "background": "蒟蒻 HansBug 在语文考场上，挠了无数次的头，可脑子里还是一片空白。\n", "description": "考试开始了，可是蒟蒻 HansBug 脑中还是一片空白。哦不！准确的说是乱七八糟的。现在首要任务就是帮蒟蒻 HansBug 理理思维。假设 HansBug 的思维是一长串字符串（字符串中包含且仅包含 $26$ 个字母），现在的你，有一张神奇的药方，上面依次包含了三种操作：\n\n1、 获取第 $x$ 到第 $y$ 个字符中字母 $k$ 出现了多少次\n\n2、将第 $x$ 到第 $y$ 个字符全部赋值为字母 $k$\n\n3、将第 $x$ 到第 $y$ 个字符按照 $\\text{a} \\sim \\text{z}$ 的顺序排序\n\n\n你欣喜若狂之时，可是他脑细胞和 RP 已经因为之前过度紧张消耗殆尽，眼看试卷最后还有一篇八百字的作文呢，所以这个关键的任务就交给你啦！\n", "inputFormat": "第一行包含两个整数 $n,m$，分别表示 HansBug 的思维所包含的字母个数和药方上操作个数。\n第二行包含一个长度为 $n$ 的字符串，表示 HansBug 的思维。\n\n接下来 $m$ 行，每行表示一个操作，格式如下：\n\n- `1 x y k` 表示将第 $x$ 到第 $y$ 个字符中 $k$ 出现的次数输出\n\n- `2 x y k` 表示将第 $x$ 到第 $y$ 个字符全部替换为 $k$\n\n- `3 x y` 表示将第 $x$ 到第 $y$ 个字符按照 $\\text{a} \\sim \\text{z}$ 的顺序排序\n", "outputFormat": "输出为若干行，每行包含一个整数，依次为所有操作 $1$ 所得的结果。\n", "hint": "样例说明：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2231.png) \n\n数据规模：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2232.png) \n\n### 此题目中大小写不敏感。\n\n### 新加了三组 hack 数据，不在上面的表格中，但保证 $1\\le n,m \\le 50000$。", "locale": "zh-CN", "translations": {"en": {"title": "Chinese 1 (chin1) - Organize the Thoughts", "background": "Rookie HansBug scratched his head countless times in the Chinese exam, but his mind was still completely blank.", "description": "The exam has started, but HansBug's mind is still blank. Oh no! To be precise, it is a total mess. Your primary task now is to help HansBug organize his thoughts. Assume HansBug's thoughts form a long string (containing only the $26$ letters). Now you have a magic prescription that contains three operations in order:\n\n1. Get how many times letter $k$ appears from the $x$-th to the $y$-th character.\n2. Set all characters from the $x$-th to the $y$-th to letter $k$.\n3. Sort the characters from the $x$-th to the $y$-th in $\\text{a} \\sim \\text{z}$ order.\n\nJust when you are overjoyed, his brain cells and RP have already been exhausted by previous nervousness, and there is still an $800$-word essay at the end of the paper. So this crucial task is up to you!", "inputFormat": "The first line contains two integers $n, m$, denoting the number of letters in HansBug's thoughts and the number of operations on the prescription, respectively.\nThe second line contains a string of length $n$, representing HansBug's thoughts.\n\nThen follow $m$ lines, each describing an operation in the following format (positions are $1$-based and inclusive):\n\n- `1 x y k` means to output how many times $k$ appears from the $x$-th to the $y$-th character.\n- `2 x y k` means to replace all characters from the $x$-th to the $y$-th with $k$.\n- `3 x y` means to sort the characters from the $x$-th to the $y$-th in $\\text{a} \\sim \\text{z}$ order.", "outputFormat": "Output several lines, each containing an integer, which are the results of all type `1` operations in order.", "hint": "Sample explanation:\n\n ![](https://cdn.luogu.com.cn/upload/pic/2231.png) \n\nConstraints:\n\n ![](https://cdn.luogu.com.cn/upload/pic/2232.png) \n\nThis problem is case-insensitive.\n\nThree additional hack testdata groups have been added, which are not in the table above, but it is guaranteed that $1 \\le n, m \\le 50000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "语文1（chin1）- 理理思维", "background": "蒟蒻 HansBug 在语文考场上，挠了无数次的头，可脑子里还是一片空白。\n", "description": "考试开始了，可是蒟蒻 HansBug 脑中还是一片空白。哦不！准确的说是乱七八糟的。现在首要任务就是帮蒟蒻 HansBug 理理思维。假设 HansBug 的思维是一长串字符串（字符串中包含且仅包含 $26$ 个字母），现在的你，有一张神奇的药方，上面依次包含了三种操作：\n\n1、 获取第 $x$ 到第 $y$ 个字符中字母 $k$ 出现了多少次\n\n2、将第 $x$ 到第 $y$ 个字符全部赋值为字母 $k$\n\n3、将第 $x$ 到第 $y$ 个字符按照 $\\text{a} \\sim \\text{z}$ 的顺序排序\n\n\n你欣喜若狂之时，可是他脑细胞和 RP 已经因为之前过度紧张消耗殆尽，眼看试卷最后还有一篇八百字的作文呢，所以这个关键的任务就交给你啦！\n", "inputFormat": "第一行包含两个整数 $n,m$，分别表示 HansBug 的思维所包含的字母个数和药方上操作个数。\n第二行包含一个长度为 $n$ 的字符串，表示 HansBug 的思维。\n\n接下来 $m$ 行，每行表示一个操作，格式如下：\n\n- `1 x y k` 表示将第 $x$ 到第 $y$ 个字符中 $k$ 出现的次数输出\n\n- `2 x y k` 表示将第 $x$ 到第 $y$ 个字符全部替换为 $k$\n\n- `3 x y` 表示将第 $x$ 到第 $y$ 个字符按照 $\\text{a} \\sim \\text{z}$ 的顺序排序\n", "outputFormat": "输出为若干行，每行包含一个整数，依次为所有操作 $1$ 所得的结果。\n", "hint": "样例说明：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2231.png) \n\n数据规模：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2232.png) \n\n### 此题目中大小写不敏感。\n\n### 新加了三组 hack 数据，不在上面的表格中，但保证 $1\\le n,m \\le 50000$。", "locale": "zh-CN"}}}
{"pid": "P2788", "type": "P", "difficulty": 1, "samples": [["1+2-3", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "洛谷原创"], "title": "数学1（math1）- 加减算式", "background": "蒟蒻HansBug 在数学考场上，挠了无数次的头，可脑子里还是一片空白。\n", "description": "好不容易啊，HansBug 终于熬到了做到数学最后一题的时刻了，眼前是一堆杂乱的加减算式。显然成功就在眼前了。可是他脑细胞和RP已经消耗殆尽，所以这个重要的任务就交给你们啦。\n", "inputFormat": "一行，包含一个字符串形式的加减法多项式（每一项数字范围为$0\\sim 32767$）。\n", "outputFormat": "一个整数，为计算所得的结果（保证计算结果不会超过长整型范围）。\n", "hint": "数据保证字符串长度不超过 $60000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Math 1 (math1) - Addition and Subtraction Expressions", "background": "Noob HansBug scratched his head countless times in the math exam, but his mind was still blank.", "description": "At long last, HansBug has made it to the final math problem: a jumble of addition and subtraction expressions. Success seems within reach. However, his brain cells and RP (luck) are completely drained, so this important task is now up to you.", "inputFormat": "One line containing an addition/subtraction expression given as a string (the number in each term is in the range $0 \\sim 32767$).", "outputFormat": "A single integer, which is the computed result (guaranteed that the result will not exceed the range of a long integer).", "hint": "The testdata guarantees that the string length does not exceed $60000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数学1（math1）- 加减算式", "background": "蒟蒻HansBug 在数学考场上，挠了无数次的头，可脑子里还是一片空白。\n", "description": "好不容易啊，HansBug 终于熬到了做到数学最后一题的时刻了，眼前是一堆杂乱的加减算式。显然成功就在眼前了。可是他脑细胞和RP已经消耗殆尽，所以这个重要的任务就交给你们啦。\n", "inputFormat": "一行，包含一个字符串形式的加减法多项式（每一项数字范围为$0\\sim 32767$）。\n", "outputFormat": "一个整数，为计算所得的结果（保证计算结果不会超过长整型范围）。\n", "hint": "数据保证字符串长度不超过 $60000$。\n", "locale": "zh-CN"}}}
{"pid": "P2789", "type": "P", "difficulty": 4, "samples": [["4", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "递归"], "title": "直线交点数", "background": "", "description": "假设平面上有 $N$ 条直线，且无三线共点，那么这些直线有多少种可能的交点数？", "inputFormat": "一行，一个整数 $N$，代表有 $N$ 条直线。", "outputFormat": "一行，一个整数，表示方案总数。", "hint": "对于所有数据，满足 $1 \\le N \\le 25$。", "locale": "zh-CN", "translations": {"en": {"title": "Number of Intersection Points of Lines", "background": "", "description": "Assume there are $N$ lines in the plane, and no three lines are concurrent. How many distinct possible numbers of intersection points can these lines have?", "inputFormat": "One line with an integer $N$, the number of lines.", "outputFormat": "One line with an integer, the total number of possible values.", "hint": "For all testdata, $1 \\le N \\le 25$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "直线交点数", "background": "", "description": "假设平面上有 $N$ 条直线，且无三线共点，那么这些直线有多少种可能的交点数？", "inputFormat": "一行，一个整数 $N$，代表有 $N$ 条直线。", "outputFormat": "一行，一个整数，表示方案总数。", "hint": "对于所有数据，满足 $1 \\le N \\le 25$。", "locale": "zh-CN"}}}
{"pid": "P2790", "type": "P", "difficulty": 2, "samples": [["10\nmove 9 onto 1\nmove 8 over 1\nmove 7 over 1\nmove 6 over 1\npile 8 over 6\npile 8 over 5\nmove 2 over 1\nmove 4 over 9\nquit", "0: 0\n1: 1 9 2 4\n2:\n3: 3\n4:\n5: 5 8 7 6\n6:\n7:\n8:\n9:"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "ccj与zrz之积木问题", "background": "ccj和zrz无聊到了玩起了搭积木...(本题选自uva101，翻译来自《算法竞赛入门经典2》)\n", "description": "从左到右有 $n$ 个木块，编号从 $0$ 到 $n-1$，要求模拟以下 $4$ 种操作（下面的 $a$ 和 $b$ 都是木块编号，归位表示比如 $1$ 号木块归到 $1$ 号位去）。\n\n- $\\texttt{move }a\\texttt{ onto }b$：把 $a$ 和 $b$ 上方的木块全部归位，然后把 $a$ 摞在 $b$ 上面；\n- $\\texttt{move }a\\texttt{ over }b$：把 $a$ 上方的全部归位，然后把 $a$ 放在 $b$ 所在木块堆的顶部；\n- $\\texttt{pile }a\\texttt{ onto }b$：把 $b$ 上方的木块全部归位，然后把 $a$ 及上面的木块整体摞在 $b$ 上面；\n- $\\texttt{pile }a\\texttt{ over }b$：把 $a$ 及上面的木块整体摞在 $b$ 所在木块堆的顶部；\n- 遇到 $\\texttt{quit}$ 停止。$a$ 和 $b$ 在同一堆的指令时非法指令，应当忽略。\n\n最后输出每个位置的木块列表，按照从底部到顶部的顺序排列。", "inputFormat": "第一行一个整数 $n$。\n\n接下来若干行：每行一个指令（语法不会错），遇到 $\\texttt{quit}$ 停止。", "outputFormat": "输出共 $n$ 行，第 $i$ 行输出一个 $i$ 和冒号，然后一个空格，输出，它位置上的所有积木。", "hint": "### 数据范围及约定\n\n对于全部数据，$0<n<25$。", "locale": "zh-CN", "translations": {"en": {"title": "ccj and zrz's Blocks Problem", "background": "ccj and zrz were so bored that they started playing with building blocks... (This problem is from UVA 101, translation from \"算法竞赛入门经典 2\".)", "description": "From left to right there are $n$ blocks, numbered from $0$ to $n-1$. Simulate the following 4 operations (here $a$ and $b$ are block numbers; “return to initial position” means, for example, block $1$ goes back to position $1$):\n\n- $\\texttt{move }a\\texttt{ onto }b$: Return all blocks above $a$ and above $b$ to their initial positions, then place $a$ on top of $b$.\n- $\\texttt{move }a\\texttt{ over }b$: Return all blocks above $a$ to their initial positions, then place $a$ on the top of the stack containing $b$.\n- $\\texttt{pile }a\\texttt{ onto }b$: Return all blocks above $b$ to their initial positions, then move $a$ together with all blocks above it as a whole onto $b$.\n- $\\texttt{pile }a\\texttt{ over }b$: Move $a$ together with all blocks above it as a whole onto the top of the stack containing $b$.\n- Stop when encountering $\\texttt{quit}$. If $a$ and $b$ are in the same stack, the instruction is illegal and should be ignored.\n\nFinally, output the list of blocks at each position, in order from bottom to top.", "inputFormat": "The first line contains an integer $n$.\n\nThen follow several lines, each containing one instruction (the syntax will be correct). Stop when encountering $\\texttt{quit}$.", "outputFormat": "Output exactly $n$ lines. On the $i$-th line, output $i$ followed by a colon, then a space, then all the blocks at position $i$, listed from bottom to top.", "hint": "### Constraints and Notes\n\nFor all testdata, $0<n<25$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "ccj与zrz之积木问题", "background": "ccj和zrz无聊到了玩起了搭积木...(本题选自uva101，翻译来自《算法竞赛入门经典2》)\n", "description": "从左到右有 $n$ 个木块，编号从 $0$ 到 $n-1$，要求模拟以下 $4$ 种操作（下面的 $a$ 和 $b$ 都是木块编号，归位表示比如 $1$ 号木块归到 $1$ 号位去）。\n\n- $\\texttt{move }a\\texttt{ onto }b$：把 $a$ 和 $b$ 上方的木块全部归位，然后把 $a$ 摞在 $b$ 上面；\n- $\\texttt{move }a\\texttt{ over }b$：把 $a$ 上方的全部归位，然后把 $a$ 放在 $b$ 所在木块堆的顶部；\n- $\\texttt{pile }a\\texttt{ onto }b$：把 $b$ 上方的木块全部归位，然后把 $a$ 及上面的木块整体摞在 $b$ 上面；\n- $\\texttt{pile }a\\texttt{ over }b$：把 $a$ 及上面的木块整体摞在 $b$ 所在木块堆的顶部；\n- 遇到 $\\texttt{quit}$ 停止。$a$ 和 $b$ 在同一堆的指令时非法指令，应当忽略。\n\n最后输出每个位置的木块列表，按照从底部到顶部的顺序排列。", "inputFormat": "第一行一个整数 $n$。\n\n接下来若干行：每行一个指令（语法不会错），遇到 $\\texttt{quit}$ 停止。", "outputFormat": "输出共 $n$ 行，第 $i$ 行输出一个 $i$ 和冒号，然后一个空格，输出，它位置上的所有积木。", "hint": "### 数据范围及约定\n\n对于全部数据，$0<n<25$。", "locale": "zh-CN"}}}
{"pid": "P2791", "type": "P", "difficulty": 7, "samples": [["3 2 1 3\n3 2 2", "332748121"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2019", "O2优化", "组合数学", "快速数论变换 NTT"], "title": "幼儿园篮球题", "background": "众所周知，全民制作幼儿园园龄两年半的蔡徐坤同学喜欢唱、跳、rap 和篮球。而作为欧文的老师，他的篮球技术自然比 ikun 们要强得多。", "description": "全民制作幼儿园的蔡徐坤专属篮球场上总共有 $N$ 个蔡徐坤专属篮球，而其中有 $M$ 个是没气的。鉴于蔡徐坤的高超技术，他投**没气的球一定能进**，而投**有气的球一定不能**。\n\n蔡徐坤举办了 $S$ 场巡回篮球表演，第 $i$ 场表演 ikun 们会指定投球个数 $k_i$ ，ikun 们会从 $N$ 个蔡徐坤专属篮球中准备 $n_i$ 个球放在场地上，其中恰好有 $m_i$ 个是没气的。蔡徐坤会在这 $n_i$ 个蔡徐坤专属篮球中**随机**选出 $k_i$ 个投篮。如果投进了 $x$ 个，则这次表演的**失败度**为 $x^L$。ikun 们想知道这 $S$ 场表演的**期望失败度**对 $998244353$ 取模的结果。篮球表演之间**相互独立**。", "inputFormat": "第一行，四个正整数，$N,M,S,L$，表示蔡徐坤专属篮球总个数，没气的篮球总个数，蔡徐坤巡回篮球表演场数，以及失败度参数。\n\n接下来的第 $i+1$ 行，每行三个正整数 $n_i,m_i,k_i$，表示第 $i$ 场表演蔡徐坤专属篮球个数、没气的篮球个数和 ikun 们指定的投球个数。", "outputFormat": "输出共 $S$ 行，第 $i$ 行为一个正整数，表示第 $i$ 场表演的期望失败度对 $998244353$ 取模的结果。", "hint": "对于样例，我们作出如下解释：设失败度为 $X$，蔡徐坤有 $\\frac{1}{3}$ 的概率投进 $2$ 个，有 $\\frac{2}{3}$ 的概率投进 $1$ 个，期望失败度为 $E(x)=\\frac{2^3}{3}+\\frac{1^3*2}{3}=\\frac{10}{3}$，$\\frac{10}{3}\\equiv 332748121\\pmod{998244353}$。\n\n子任务 1 ($15\\%$)：$1\\leq L\\leq2$。\n\n子任务 2 ($10\\%$)：$1\\leq N\\leq10^5$。\n\n子任务 3 ($75\\%$)：无特殊限制。\n\n对于全部数据，$1\\leq S\\leq200$，$1\\leq L\\leq2\\times 10^5$，$1\\leq M\\leq N\\leq2\\times 10^7$。并且对于 $1\\leq i\\leq S$，有 $1\\leq m_i,k_i\\leq n_i\\leq N$，$1\\leq m_i\\leq M$。", "locale": "zh-CN", "translations": {"en": {"title": "Kindergarten Basketball Problem.", "background": "As everyone knows, Cai Xukun, who “debuted” from the national talent show and has been in kindergarten for two and a half years, likes singing, dancing, rap, and basketball. As Irving’s teacher, his basketball skills are naturally much better than those of the “ikun” fans.", "description": "On Cai Xukun’s exclusive basketball court in the “national talent show kindergarten”, there are a total of $N$ exclusive basketballs, among which $M$ are deflated. Due to Cai Xukun’s superb skills, when he shoots a **deflated ball, it must go in**, and when he shoots an **inflated ball, it must not go in**.\n\nCai Xukun holds $S$ touring basketball performances. In the $i$-th performance, the ikun fans specify the number of shots $k_i$. They will prepare $n_i$ balls from the $N$ exclusive basketballs and place them on the court, among which exactly $m_i$ are deflated. Cai Xukun will **randomly** choose $k_i$ balls from these $n_i$ exclusive basketballs to shoot. If he makes $x$ shots, then the **failure score** of this performance is $x^L$. The ikun fans want to know, for these $S$ performances, the result of the **expected failure score** modulo $998244353$. The basketball performances are **independent** of each other.", "inputFormat": "The first line contains four positive integers $N, M, S, L$, representing the total number of Cai Xukun’s exclusive basketballs, the total number of deflated basketballs, the number of touring basketball performances, and the failure score parameter.\n\nEach of the next $S$ lines contains three positive integers $n_i, m_i, k_i$, representing, for the $i$-th performance, the number of exclusive basketballs used, the number of deflated basketballs among them, and the number of shots specified by the ikun fans.", "outputFormat": "Output $S$ lines in total. The $i$-th line contains a positive integer, representing the expected failure score of the $i$-th performance modulo $998244353$.", "hint": "For the sample, we explain as follows. Let the failure score be $X$. Cai Xukun has probability $\\frac{1}{3}$ to make $2$ shots, and probability $\\frac{2}{3}$ to make $1$ shot. The expected failure score is $E(x)=\\frac{2^3}{3}+\\frac{1^3*2}{3}=\\frac{10}{3}$, and $\\frac{10}{3}\\equiv 332748121\\pmod{998244353}$.\n\nSubtask 1 ($15\\%$): $1\\leq L\\leq2$.\n\nSubtask 2 ($10\\%$): $1\\leq N\\leq10^5$.\n\nSubtask 3 ($75\\%$): No special constraints.\n\nFor all testdata, $1\\leq S\\leq200$, $1\\leq L\\leq2\\times 10^5$, $1\\leq M\\leq N\\leq2\\times 10^7$. Also, for $1\\leq i\\leq S$, we have $1\\leq m_i,k_i\\leq n_i\\leq N$, $1\\leq m_i\\leq M$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "幼儿园篮球题", "background": "众所周知，全民制作幼儿园园龄两年半的蔡徐坤同学喜欢唱、跳、rap 和篮球。而作为欧文的老师，他的篮球技术自然比 ikun 们要强得多。", "description": "全民制作幼儿园的蔡徐坤专属篮球场上总共有 $N$ 个蔡徐坤专属篮球，而其中有 $M$ 个是没气的。鉴于蔡徐坤的高超技术，他投**没气的球一定能进**，而投**有气的球一定不能**。\n\n蔡徐坤举办了 $S$ 场巡回篮球表演，第 $i$ 场表演 ikun 们会指定投球个数 $k_i$ ，ikun 们会从 $N$ 个蔡徐坤专属篮球中准备 $n_i$ 个球放在场地上，其中恰好有 $m_i$ 个是没气的。蔡徐坤会在这 $n_i$ 个蔡徐坤专属篮球中**随机**选出 $k_i$ 个投篮。如果投进了 $x$ 个，则这次表演的**失败度**为 $x^L$。ikun 们想知道这 $S$ 场表演的**期望失败度**对 $998244353$ 取模的结果。篮球表演之间**相互独立**。", "inputFormat": "第一行，四个正整数，$N,M,S,L$，表示蔡徐坤专属篮球总个数，没气的篮球总个数，蔡徐坤巡回篮球表演场数，以及失败度参数。\n\n接下来的第 $i+1$ 行，每行三个正整数 $n_i,m_i,k_i$，表示第 $i$ 场表演蔡徐坤专属篮球个数、没气的篮球个数和 ikun 们指定的投球个数。", "outputFormat": "输出共 $S$ 行，第 $i$ 行为一个正整数，表示第 $i$ 场表演的期望失败度对 $998244353$ 取模的结果。", "hint": "对于样例，我们作出如下解释：设失败度为 $X$，蔡徐坤有 $\\frac{1}{3}$ 的概率投进 $2$ 个，有 $\\frac{2}{3}$ 的概率投进 $1$ 个，期望失败度为 $E(x)=\\frac{2^3}{3}+\\frac{1^3*2}{3}=\\frac{10}{3}$，$\\frac{10}{3}\\equiv 332748121\\pmod{998244353}$。\n\n子任务 1 ($15\\%$)：$1\\leq L\\leq2$。\n\n子任务 2 ($10\\%$)：$1\\leq N\\leq10^5$。\n\n子任务 3 ($75\\%$)：无特殊限制。\n\n对于全部数据，$1\\leq S\\leq200$，$1\\leq L\\leq2\\times 10^5$，$1\\leq M\\leq N\\leq2\\times 10^7$。并且对于 $1\\leq i\\leq S$，有 $1\\leq m_i,k_i\\leq n_i\\leq N$，$1\\leq m_i\\leq M$。", "locale": "zh-CN"}}}
{"pid": "P2792", "type": "P", "difficulty": 6, "samples": [["4\n10.00 1\n1.80 1\n3.00 0\n2.50 2\n2\n1 4 2.00\n4 2 1.50", "15.50"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2008", "各省省选", "江苏", "生成树"], "title": "[JSOI2008] 小店购物", "background": "JSOI集训队的队员发现，在他们经常活动的集训地，有一个小店因为其丰富的经营优惠方案深受附近居民的青睐，生意红火。\n", "description": "小店的优惠方案十分简单有趣：\n\n一次消费过程中，如您在本店购买了精制油的话，您购买香皂时就可以享受 $2.00$ 元 / 块的优惠价；如果您在本店购买了香皂的话，您购买可乐时就可以享受 $1.50$ 元 / 听的优惠价……诸如此类的优惠方案可概括为：如果您在本店购买了商品 $A$ 的话，您就可以以 $P$ 元 / 件的优惠价格购买商品 $B$（购买的数量不限）。\n\n有趣的是，你需要购买同样一些商品，由于不同的买卖顺序，老板可能会叫你付不同数量的钱。比如你需要一块香皂（原价 $2.50$ 元）、一瓶精制油（原价 $10.00$ 元）、一听可乐（原价 $1.80$ 元），如果你按照可乐、精制油、香皂这样的顺序购买的话，老板会问你要 $13.80$ 元；而如果你按照精制油、香皂、可乐这样的顺序购买的话，您只需付 $13.50$ 元。\n\n该处居民发现 JSOI 集训队的队员均擅长电脑程序设计，于是他们请集训队的队员编写一个程序：在告诉你该小店商品的原价，所有优惠方案及所需的商品后，计算至少需要花多少钱（不允许购买任何不必要的商品，即使这样做可能使花的钱更少）。", "inputFormat": "输入文件第一行为一个整数 $n\\ (1 \\le n \\le 50)$，表示小店的商品总数。\n\n接下来是 $n$ 行，其中第 $i+1$ 行由一个实数 $c_i\\ (0<c_i \\le 1000)$ 和一个整数 $m_i\\ (0 \\le m_i \\le 100)$ 组成，其间由一个空格分隔，分别表示第 $i$ 种商品的原价和所需数量。第 $n+2$ 行又是一个整数 $k\\ (1 \\le k \\le 500)$，表示小店的优惠方案总数。\n\n接着 $k$ 行，每行有二个整数 $A,B(1 \\le A,B \\le n)$ 和一个实数 $P(0 \\le P<1000)$，表示一种优惠方案，即如果您购买了商品 $A$，您就可以以 $P$ 元 / 件的优惠价格购买商品 $B$，$P$ 小于商品 $B$ 的原价。所有优惠方案的 $(A,B)$ 都是不同的。为了方便老板不收分币，所以所有价格都不出现单位分。", "outputFormat": "输出只有一个实数，表示最少需要花多少钱。输出实数须保留两位小数。\n", "hint": "数据范围见输入格式\n", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2008] Small Shop Shopping", "background": "The members of the JSOI training team discovered that at their regular training site, there is a small shop that is very popular among nearby residents due to its rich variety of promotional deals, and business is booming.", "description": "The shop’s promotions are simple and fun:\n\nDuring a single shopping session, if you buy refined oil at this shop, then when you buy soap you can enjoy a discounted price of $2.00$ yuan per bar; if you buy soap, then when you buy cola you can enjoy a discounted price of $1.50$ yuan per can; and so on. In summary: if you buy item $A$, then you may buy item $B$ at a discounted price of $P$ yuan per unit (with no limit on the quantity).\n\nInterestingly, you need to buy some fixed items, and because different purchase orders may lead the shopkeeper to charge you different totals. For example, you need one bar of soap (original price $2.50$ yuan), one bottle of refined oil (original price $10.00$ yuan), and one can of cola (original price $1.80$ yuan). If you purchase in the order cola → refined oil → soap, the shopkeeper will charge you $13.80$ yuan; but if you purchase in the order refined oil → soap → cola, you only need to pay $13.50$ yuan.\n\nThe local residents know that JSOI team members are good at programming, so they ask you to write a program: given the original prices of all items in the shop, all promotion rules, and the items you need, compute the minimum amount of money you must spend (you are not allowed to buy any unnecessary items, even if doing so could reduce the total cost).", "inputFormat": "The first line contains an integer $n\\ (1 \\le n \\le 50)$, the total number of item types in the shop.\n\nThe next $n$ lines follow. The $(i+1)$-th line contains a real number $c_i\\ (0 < c_i \\le 1000)$ and an integer $m_i\\ (0 \\le m_i \\le 100)$ separated by a space, denoting the original price of item $i$ and the required quantity. The $(n+2)$-th line contains an integer $k\\ (1 \\le k \\le 500)$, the total number of promotion rules.\n\nThen $k$ lines follow. Each line contains two integers $A, B\\ (1 \\le A, B \\le n)$ and a real number $P\\ (0 \\le P < 1000)$, describing one promotion: if you buy item $A$, then you may buy item $B$ at a discounted price of $P$ yuan per unit. Here $P$ is less than the original price of item $B$. All pairs $(A, B)$ in the promotions are distinct. For convenience, the shopkeeper does not use one-cent units, so all prices are multiples of $0.10$ yuan.", "outputFormat": "Output a single real number: the minimum total cost. Print the number with exactly two decimal places.", "hint": "Constraints can be found in the Input Format.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2008] 小店购物", "background": "JSOI集训队的队员发现，在他们经常活动的集训地，有一个小店因为其丰富的经营优惠方案深受附近居民的青睐，生意红火。\n", "description": "小店的优惠方案十分简单有趣：\n\n一次消费过程中，如您在本店购买了精制油的话，您购买香皂时就可以享受 $2.00$ 元 / 块的优惠价；如果您在本店购买了香皂的话，您购买可乐时就可以享受 $1.50$ 元 / 听的优惠价……诸如此类的优惠方案可概括为：如果您在本店购买了商品 $A$ 的话，您就可以以 $P$ 元 / 件的优惠价格购买商品 $B$（购买的数量不限）。\n\n有趣的是，你需要购买同样一些商品，由于不同的买卖顺序，老板可能会叫你付不同数量的钱。比如你需要一块香皂（原价 $2.50$ 元）、一瓶精制油（原价 $10.00$ 元）、一听可乐（原价 $1.80$ 元），如果你按照可乐、精制油、香皂这样的顺序购买的话，老板会问你要 $13.80$ 元；而如果你按照精制油、香皂、可乐这样的顺序购买的话，您只需付 $13.50$ 元。\n\n该处居民发现 JSOI 集训队的队员均擅长电脑程序设计，于是他们请集训队的队员编写一个程序：在告诉你该小店商品的原价，所有优惠方案及所需的商品后，计算至少需要花多少钱（不允许购买任何不必要的商品，即使这样做可能使花的钱更少）。", "inputFormat": "输入文件第一行为一个整数 $n\\ (1 \\le n \\le 50)$，表示小店的商品总数。\n\n接下来是 $n$ 行，其中第 $i+1$ 行由一个实数 $c_i\\ (0<c_i \\le 1000)$ 和一个整数 $m_i\\ (0 \\le m_i \\le 100)$ 组成，其间由一个空格分隔，分别表示第 $i$ 种商品的原价和所需数量。第 $n+2$ 行又是一个整数 $k\\ (1 \\le k \\le 500)$，表示小店的优惠方案总数。\n\n接着 $k$ 行，每行有二个整数 $A,B(1 \\le A,B \\le n)$ 和一个实数 $P(0 \\le P<1000)$，表示一种优惠方案，即如果您购买了商品 $A$，您就可以以 $P$ 元 / 件的优惠价格购买商品 $B$，$P$ 小于商品 $B$ 的原价。所有优惠方案的 $(A,B)$ 都是不同的。为了方便老板不收分币，所以所有价格都不出现单位分。", "outputFormat": "输出只有一个实数，表示最少需要花多少钱。输出实数须保留两位小数。\n", "hint": "数据范围见输入格式\n", "locale": "zh-CN"}}}
{"pid": "P2793", "type": "P", "difficulty": 3, "samples": [["1 5 3\n5", "2"], ["5 6 3\n5 4 3 2 1", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟"], "title": "Facer的工厂", "background": "", "description": "Facer 是一个工厂里的兼职工人，这回他碰到了一个问题。\n\n有 $N$ 根钢管，每根长度是 $a_i$。\n\n有一个钢管加工器，每秒钟可以加工 $k$ 长度的钢管。\n\nFacer 需要按顺序加工这些钢管。\n\n不过呢，机器的最大等待长度是 $h$，即等待加工（已经塞入机器却还没有加工的钢管）的钢管长度不能超过 $h$（保证 $a_i \\le h$）。\n\nFacer 只能在整数秒的时候塞入钢管。\n\n求 Facer 处理完这些钢管最少要多久呢？", "inputFormat": "第一行 $N,H,K$，代表钢管条数，最大等待长度和每秒处理速度。\n\n接下来 $N$ 行，每行一个数，代表钢管的长度。\n\n钢管需要按顺序处理。", "outputFormat": "最短时间\n", "hint": "样例 1 解释：只有 $1$ 根钢管，加工时间为 $\\lceil 5/3\\rceil= 2$。\n\n样例 2 解释：\n\n第一秒塞入 $5$，等待长度 $5$，机器处理了 $3$，等待长度 $2$。\n\n第二秒塞入 $4$，等待长度 $6$，机器处理了 $3$，等待长度 $3$。\n\n第三秒塞入 $3$，等待长度 $6$，机器处理了 $3$，等待长度 $3$。\n\n第四秒塞入了 $1,2$，等待长度 $6$，机器处理了 $3$，等待长度 $3$。\n\n第五秒无塞入，等待长度 $3$，机器处理了 $3$，处理完毕。\n\n$N \\le 100000$，$h,a_i \\le 10^9$。\n\n本题 by zhouyonglong\n", "locale": "zh-CN", "translations": {"en": {"title": "Facer's Factory", "background": "", "description": "Facer is a part-time worker in a factory, and this time he encounters a problem.\n\nThere are $N$ steel pipes, with the $i$-th pipe having length $a_i$.\n\nThere is a pipe processor that can process $K$ units of pipe length per second.\n\nFacer needs to process these pipes in order.\n\nThe machine has a maximum waiting length $H$, meaning the total length of pipes waiting to be processed (already fed into the machine but not yet processed) cannot exceed $H$ (guaranteed that $a_i \\le H$).\n\nFacer can only feed pipes into the machine at integer seconds.\n\nWhat is the minimum time for Facer to finish processing all the pipes?", "inputFormat": "The first line contains $N, H, K$, representing the number of pipes, the maximum waiting length, and the processing speed per second.\n\nThe next $N$ lines each contain one number, the length of a pipe.\n\nThe pipes must be processed in order.", "outputFormat": "The minimum time.", "hint": "Sample 1 explanation: There is only $1$ pipe, and the processing time is $\\lceil 5/3 \\rceil = 2$.\n\nSample 2 explanation:\n- At the first second, feed $5$, waiting length is $5$. The machine processes $3$, waiting length becomes $2$.\n- At the second second, feed $4$, waiting length is $6$. The machine processes $3$, waiting length becomes $3$.\n- At the third second, feed $3$, waiting length is $6$. The machine processes $3$, waiting length becomes $3$.\n- At the fourth second, feed $1, 2$, waiting length is $6$. The machine processes $3$, waiting length becomes $3$.\n- At the fifth second, feed nothing, waiting length is $3$. The machine processes $3$, and all pipes are finished.\n\nConstraints: $N \\le 100000$, $H, a_i \\le 10^9$.\n\nProblem by zhouyonglong.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Facer的工厂", "background": "", "description": "Facer 是一个工厂里的兼职工人，这回他碰到了一个问题。\n\n有 $N$ 根钢管，每根长度是 $a_i$。\n\n有一个钢管加工器，每秒钟可以加工 $k$ 长度的钢管。\n\nFacer 需要按顺序加工这些钢管。\n\n不过呢，机器的最大等待长度是 $h$，即等待加工（已经塞入机器却还没有加工的钢管）的钢管长度不能超过 $h$（保证 $a_i \\le h$）。\n\nFacer 只能在整数秒的时候塞入钢管。\n\n求 Facer 处理完这些钢管最少要多久呢？", "inputFormat": "第一行 $N,H,K$，代表钢管条数，最大等待长度和每秒处理速度。\n\n接下来 $N$ 行，每行一个数，代表钢管的长度。\n\n钢管需要按顺序处理。", "outputFormat": "最短时间\n", "hint": "样例 1 解释：只有 $1$ 根钢管，加工时间为 $\\lceil 5/3\\rceil= 2$。\n\n样例 2 解释：\n\n第一秒塞入 $5$，等待长度 $5$，机器处理了 $3$，等待长度 $2$。\n\n第二秒塞入 $4$，等待长度 $6$，机器处理了 $3$，等待长度 $3$。\n\n第三秒塞入 $3$，等待长度 $6$，机器处理了 $3$，等待长度 $3$。\n\n第四秒塞入了 $1,2$，等待长度 $6$，机器处理了 $3$，等待长度 $3$。\n\n第五秒无塞入，等待长度 $3$，机器处理了 $3$，处理完毕。\n\n$N \\le 100000$，$h,a_i \\le 10^9$。\n\n本题 by zhouyonglong\n", "locale": "zh-CN"}}}
{"pid": "P2794", "type": "P", "difficulty": 6, "samples": [["3 3\n1 7\n2 -1\n6 6\n1 1 5\n2 4 5\n2 3 0", "3\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创"], "title": "Facer和教官", "background": "Facer和教官关系很好，被教官任命为副教官。", "description": "Facer 要训练一个 $N$ 个人的队伍。\n\n每个人有一个智力值 $a_i$ 和一个体力值 $b_i$。\n\nFacer 希望两个人组队，组队的两个人要尽量相似。\n\n具体来说，编号为 $i$ 和 $j$ 的人的相似度为 $| a_i - a_j + b_j - b_i | + | a_i - a_j |$。相似度越小，表示越相似。\n\n现在队伍里有 $N$ 个人，但是 Facer 想要进行 $M$ 次操作。有以下两种操作：\n\n- 在队伍里加入一个人。\n- 给出一个**不在队伍里**的人的数据，输出他和队伍里所有人的相似度中最低的相似度。注意，操作结束后，**不要将这个人加入队伍，也不要将找到的人移出队伍**。", "inputFormat": "第一行，两个整数 $N,M$。\n\n接下来 $N$ 行，第 $i$ 行两个数 $a_i,b_i$，表示队伍中第 $i$ 个人的智力值 $a_i$，体力值 $b_i$。\n\n接下来 $M$ 行，每行一个操作。\n\n- `1 a b`：表示队伍中新加入了一个人，智力为 $a$，体力为 $b$。\n- `2 a b`：表示有一个不在队伍里的人的智力为 $a$，体力为 $b$，输出队伍里和这个人最相似的人与这个人的相似度。", "outputFormat": "对于每个操作 `2`，输出一行，表示队伍里和这个人最相似的人与这个人的相似度。", "hint": "对于 $40\\%$ 的数据，$1 \\le N,M \\le 1000$。\n\n对于 $100\\%$ 的数据，$1 \\le N,M \\le {10}^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Facer and the Instructor", "background": "Facer has a good relationship with the instructor and is appointed as the deputy instructor.", "description": "Facer needs to train a team of $N$ people.\n\nEach person has an intelligence value $a_i$ and a stamina value $b_i$.\n\nFacer wants to form teams of two, and the two people in a team should be as similar as possible.\n\nSpecifically, the similarity between person $i$ and person $j$ is $| a_i - a_j + b_j - b_i | + | a_i - a_j |$. The smaller the similarity, the more similar they are.\n\nThere are currently $N$ people in the team, but Facer wants to perform $M$ operations. There are two types of operations:\n\n- Add a person to the team.\n- Given the data of a person who is not in the team, output the minimum similarity between this person and all people in the team. Note that after the operation, do not add this person to the team, and do not remove any person found from the team.", "inputFormat": "The first line contains two integers $N, M$.\n\nThe next $N$ lines each contain two numbers $a_i, b_i$, representing the intelligence and stamina of the $i$-th person in the team.\n\nThe next $M$ lines each describe one operation:\n\n- `1 a b`: A new person with intelligence $a$ and stamina $b$ is added to the team.\n- `2 a b`: There is a person not in the team with intelligence $a$ and stamina $b$. Output the minimum similarity between this person and all people in the team.", "outputFormat": "For each operation `2`, output one line containing the minimum similarity between this person and the most similar person in the team.", "hint": "For $40\\%$ of the testdata, $1 \\le N, M \\le 1000$.\n\nFor $100\\%$ of the testdata, $1 \\le N, M \\le {10}^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Facer和教官", "background": "Facer和教官关系很好，被教官任命为副教官。", "description": "Facer 要训练一个 $N$ 个人的队伍。\n\n每个人有一个智力值 $a_i$ 和一个体力值 $b_i$。\n\nFacer 希望两个人组队，组队的两个人要尽量相似。\n\n具体来说，编号为 $i$ 和 $j$ 的人的相似度为 $| a_i - a_j + b_j - b_i | + | a_i - a_j |$。相似度越小，表示越相似。\n\n现在队伍里有 $N$ 个人，但是 Facer 想要进行 $M$ 次操作。有以下两种操作：\n\n- 在队伍里加入一个人。\n- 给出一个**不在队伍里**的人的数据，输出他和队伍里所有人的相似度中最低的相似度。注意，操作结束后，**不要将这个人加入队伍，也不要将找到的人移出队伍**。", "inputFormat": "第一行，两个整数 $N,M$。\n\n接下来 $N$ 行，第 $i$ 行两个数 $a_i,b_i$，表示队伍中第 $i$ 个人的智力值 $a_i$，体力值 $b_i$。\n\n接下来 $M$ 行，每行一个操作。\n\n- `1 a b`：表示队伍中新加入了一个人，智力为 $a$，体力为 $b$。\n- `2 a b`：表示有一个不在队伍里的人的智力为 $a$，体力为 $b$，输出队伍里和这个人最相似的人与这个人的相似度。", "outputFormat": "对于每个操作 `2`，输出一行，表示队伍里和这个人最相似的人与这个人的相似度。", "hint": "对于 $40\\%$ 的数据，$1 \\le N,M \\le 1000$。\n\n对于 $100\\%$ 的数据，$1 \\le N,M \\le {10}^5$。", "locale": "zh-CN"}}}
{"pid": "P2795", "type": "P", "difficulty": 5, "samples": [["3 3 3\ns1 v1 s1\ns3 s19 v2\nv3 s-1 v-1\n", "2"], ["5 10 3\ns81 s47 s3 s0 s82 s31 s89 v0 s97 v-1\ns14 s94 v1 v-1 v1 s106 v1 v0 v-1 v0\ns93 s105 v-1 s219 v0 v0 v-1 v1 s225 v1\nv0 s160 v1 v1 s348 s120 s240 s392 s280 s172\ns305 s455 s140 v-1 s455 v0 v-1 v0 v1 s410\n", "430"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "搜索"], "title": "Facer爱游泳", "background": "Facer 是一个爱游泳的孩子。", "description": "一天他来到了一个 $n \\times m$ 的游泳池中，其中第一行是水面，第 $n$ 行是游泳池底。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ggncnjpk.png)\n\nFacer 想要从 $(1,1)$ 游到 $(1,m)$。他初始速度为 $0$ m/s。\n\nFacer 可以按照以下方式游泳：假设当前 Facer 位于 $(x,y)$，速度为 $v$，那么它可以游到 $(x+v,y+1)$，如果 $x+v>n$，那么就会游到 $(n,y+1)$。\n\n到了每一个格子，Facer 可以选择将自己的速度 $+1$，$-1$ 或者不变，也就是说每次 Facer 有三种选择：\n\n- 游到 $(x+v-1,y+1)$，速度变为 $v-1$。\n- 游到 $(x+v,y+1)$，速度变为 $v$。\n- 游到 $(x+v+1,y+1)$，速度变为 $v+1$。\n\n游泳池的每个格子上会放有以下两种物品中的一种：\n\n- 变速器，每个变速器有一个属性 $w$，到了这个格子速度会变为 $v+w$（当然原来的 $+1$，$-1$，不变照样存在）。\n- 金币盒，每个金币盒中有一定数量的钱 $a$，到了这个位置你可以得到 $a$ 个金币。\n\n除此之外，有以下两点需要注意的：\n\n1. 当 Facer 到达水面，即位于 $(1,x)$ 时，Facer的速度会变成 $0$（当然他仍然可以选择将速度 $+1$，$-1$ 或不变）。\n2. Facer 不能在水下待太长时间，相邻两次到水面换气的时间不能超过 $k$ 秒。\n\n求 Facer 能够得到最大金币的数量。", "inputFormat": "第一行三个整数 $n,m,k$。\n\n第二行到第 $n+1$ 行，每行 $m$ 个字符串，表示每个格子物品的情况：\n\n- 首字母为 ```v```，后面接一个整数 $w$，表示该格子中有一个变速器，属性为 $w$。\n- 首字母为 ```s```，后面接一个整数 $a$，表示该格子中有一个金币盒，钱数为 $a$。", "outputFormat": "一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，$1 \\leq n,m \\leq 5$。\n- 对于 $40\\%$ 的数据，$1 \\leq n,m \\leq 100$。\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 100$，$1 \\leq m \\leq 1000$，$1 \\leq k \\leq 10$，$-20 \\leq w \\leq 20$，$-1000 \\leq a \\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Facer Loves Swimming", "background": "Facer is a child who loves swimming.", "description": "One day he came to an $n \\times m$ swimming pool, where the first row is the water surface and the $n$-th row is the bottom of the pool.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ggncnjpk.png)\n\nFacer wants to swim from $(1, 1)$ to $(1, m)$. His initial speed is $0$ m/s.\n\nFacer can swim as follows: suppose Facer is currently at $(x, y)$ with speed $v$, then he can swim to $(x+v, y+1)$. If $x+v > n$, he will instead swim to $(n, y+1)$.\n\nUpon reaching each cell, Facer can choose to change his speed by $+1$, $-1$, or keep it unchanged. That is, each time Facer has three choices:\n- Swim to $(x+v-1, y+1)$ and the speed becomes $v-1$.\n- Swim to $(x+v, y+1)$ and the speed becomes $v$.\n- Swim to $(x+v+1, y+1)$ and the speed becomes $v+1$.\n\nEach cell in the swimming pool contains exactly one of the following two items:\n- Accelerator: each accelerator has an attribute $w$. Upon reaching this cell, the speed becomes $v+w$ (of course, the original options of $+1$, $-1$, or unchanged still apply).\n- Coin box: each coin box contains an amount $a$. Upon reaching this cell, you obtain $a$ coins.\n\nIn addition, note the following:\n1. When Facer reaches the surface, i.e., is at $(1, x)$, Facer’s speed becomes $0$ (he can still choose to change his speed by $+1$, $-1$, or keep it unchanged).\n2. Facer cannot stay underwater for too long. The time between two consecutive surfacings cannot exceed $k$ seconds.\n\nFind the maximum number of coins Facer can obtain.", "inputFormat": "The first line contains three integers $n, m, k$.\n\nFrom the second line to line $n+1$, each line contains $m$ strings describing the item in each cell:\n- If the first character is ```v``` followed by an integer $w$, then the cell contains an accelerator with attribute $w$.\n- If the first character is ```s``` followed by an integer $a$, then the cell contains a coin box with amount $a$.", "outputFormat": "Output a single integer, the answer.", "hint": "Constraints\n\n- For $10\\%$ of the testdata, $1 \\leq n, m \\leq 5$.\n- For $40\\%$ of the testdata, $1 \\leq n, m \\leq 100$.\n- For $100\\%$ of the testdata, $1 \\leq n \\leq 100$, $1 \\leq m \\leq 1000$, $1 \\leq k \\leq 10$, $-20 \\leq w \\leq 20$, $-1000 \\leq a \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Facer爱游泳", "background": "Facer 是一个爱游泳的孩子。", "description": "一天他来到了一个 $n \\times m$ 的游泳池中，其中第一行是水面，第 $n$ 行是游泳池底。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ggncnjpk.png)\n\nFacer 想要从 $(1,1)$ 游到 $(1,m)$。他初始速度为 $0$ m/s。\n\nFacer 可以按照以下方式游泳：假设当前 Facer 位于 $(x,y)$，速度为 $v$，那么它可以游到 $(x+v,y+1)$，如果 $x+v>n$，那么就会游到 $(n,y+1)$。\n\n到了每一个格子，Facer 可以选择将自己的速度 $+1$，$-1$ 或者不变，也就是说每次 Facer 有三种选择：\n\n- 游到 $(x+v-1,y+1)$，速度变为 $v-1$。\n- 游到 $(x+v,y+1)$，速度变为 $v$。\n- 游到 $(x+v+1,y+1)$，速度变为 $v+1$。\n\n游泳池的每个格子上会放有以下两种物品中的一种：\n\n- 变速器，每个变速器有一个属性 $w$，到了这个格子速度会变为 $v+w$（当然原来的 $+1$，$-1$，不变照样存在）。\n- 金币盒，每个金币盒中有一定数量的钱 $a$，到了这个位置你可以得到 $a$ 个金币。\n\n除此之外，有以下两点需要注意的：\n\n1. 当 Facer 到达水面，即位于 $(1,x)$ 时，Facer的速度会变成 $0$（当然他仍然可以选择将速度 $+1$，$-1$ 或不变）。\n2. Facer 不能在水下待太长时间，相邻两次到水面换气的时间不能超过 $k$ 秒。\n\n求 Facer 能够得到最大金币的数量。", "inputFormat": "第一行三个整数 $n,m,k$。\n\n第二行到第 $n+1$ 行，每行 $m$ 个字符串，表示每个格子物品的情况：\n\n- 首字母为 ```v```，后面接一个整数 $w$，表示该格子中有一个变速器，属性为 $w$。\n- 首字母为 ```s```，后面接一个整数 $a$，表示该格子中有一个金币盒，钱数为 $a$。", "outputFormat": "一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，$1 \\leq n,m \\leq 5$。\n- 对于 $40\\%$ 的数据，$1 \\leq n,m \\leq 100$。\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 100$，$1 \\leq m \\leq 1000$，$1 \\leq k \\leq 10$，$-20 \\leq w \\leq 20$，$-1000 \\leq a \\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P2796", "type": "P", "difficulty": 3, "samples": [["3\n1 2\n2 3", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "洛谷原创"], "title": "Facer的程序", "background": "", "description": "Facer 是一个萌萌哒的码农。他写了 $N$ 个程序。程序和程序之间有巧妙的联系，即任意两个程序恰好由一条联系链连在一起。\n\n具体来说，对于程序 $a,b$，存在且仅存在一个序列 $a,x_1,x_2,\\dots ,x_n,b$，使得 $a,x_1$ 有联系, $x_1,x_2$ 有联系，依此类推，$x_n,b$ 有联系。符合这样的一组程序称为程序块。\n\n现在已知一个程序块的程序之间的联系，询问它有多少个子程序块。即取出一个程序子集 $S$，使得 $S$ 也满足上述条件。\n", "inputFormat": "\n第一行输入一个正整数 $N$。\n\n接下来 $N-1$ 行，每行两个数，代表有联系的两个程序。", "outputFormat": "\n输出有多少个子程序块，对 $10^9+7$ 取模。", "hint": "### 样例解释：\n\n子集 $\\{1\\},\\{2\\},\\{3\\},\\{1,2\\},\\{2,3\\},\\{1,2,3\\}$ 满足上述条件。\n\n### 数据范围\n\n对于 $10\\%$ 的数据 $1\\le N\\le20$。\n\n对于 $40\\%$ 的数据 $1\\le N\\le 500$。\n\n对于 $100\\%$ 的数据 $1\\le N\\le10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Facer's Programs", "background": "", "description": "Facer is a cute coder. He wrote $N$ programs. The programs are cleverly related: any two programs are connected by exactly one chain.\n\nSpecifically, for programs $a, b$, there exists and only exists one sequence $a,x_1,x_2,\\dots ,x_n,b$ such that $a,x_1$ are directly connected, $x_1,x_2$ are directly connected, and so on, $x_n,b$ are directly connected. A set of programs that satisfies this is called a program block.\n\nNow, given the connections within one program block, determine how many sub-blocks it has. That is, choose a subset $S$ of programs such that $S$ also satisfies the condition above.", "inputFormat": "The first line contains a positive integer $N$.\n\nThe next $N-1$ lines each contain two integers, representing two programs that are directly connected.", "outputFormat": "Output the number of sub-blocks, modulo $10^9+7$.", "hint": "### Sample Explanation:\n\nThe subsets $\\{1\\},\\{2\\},\\{3\\},\\{1,2\\},\\{2,3\\},\\{1,2,3\\}$ satisfy the condition above.\n\n### Constraints\n\nFor $10\\%$ of the testdata, $1\\le N\\le20$.\n\nFor $40\\%$ of the testdata, $1\\le N\\le 500$.\n\nFor $100\\%$ of the testdata, $1\\le N\\le10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Facer的程序", "background": "", "description": "Facer 是一个萌萌哒的码农。他写了 $N$ 个程序。程序和程序之间有巧妙的联系，即任意两个程序恰好由一条联系链连在一起。\n\n具体来说，对于程序 $a,b$，存在且仅存在一个序列 $a,x_1,x_2,\\dots ,x_n,b$，使得 $a,x_1$ 有联系, $x_1,x_2$ 有联系，依此类推，$x_n,b$ 有联系。符合这样的一组程序称为程序块。\n\n现在已知一个程序块的程序之间的联系，询问它有多少个子程序块。即取出一个程序子集 $S$，使得 $S$ 也满足上述条件。\n", "inputFormat": "\n第一行输入一个正整数 $N$。\n\n接下来 $N-1$ 行，每行两个数，代表有联系的两个程序。", "outputFormat": "\n输出有多少个子程序块，对 $10^9+7$ 取模。", "hint": "### 样例解释：\n\n子集 $\\{1\\},\\{2\\},\\{3\\},\\{1,2\\},\\{2,3\\},\\{1,2,3\\}$ 满足上述条件。\n\n### 数据范围\n\n对于 $10\\%$ 的数据 $1\\le N\\le20$。\n\n对于 $40\\%$ 的数据 $1\\le N\\le 500$。\n\n对于 $100\\%$ 的数据 $1\\le N\\le10^5$。", "locale": "zh-CN"}}}
{"pid": "P2797", "type": "P", "difficulty": 5, "samples": [["4\n1 2 3 4", "0.33"], ["4\n1 2 3 9", "2.00"], ["2\n1 2", "0.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学"], "title": "Facer的魔法", "background": "Facer 误闯入禁地，学会了魔法。", "description": "Facer 闯入禁地之后，遇到了对手。\n\n具体来说，Facer 魔法是一串数字。\n\n但是 Facer 能力有限，这串数字只能从给定的 $n$ 个数中选择，能产生的魔法值为选择出的这些数字的平均数。\n\n他的对手不会像 Facer 这样的强大的魔法，但是他会克制招数，即从 Facer 选出的数字中找出中位数，便是他的魔法值。\n\n求 Facer 最多能克制对方多少点魔法。\n\n一句话题意：给你 $n$ 个数，你可以选若干个数，使得平均数减中位数最大。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个数如题。", "outputFormat": "Facer 能克制对方多少魔法值，精确到两位小数。", "hint": "- 对于 $20\\%$ 的数据，$n \\leq 100$；\n- 对于 $50\\%$ 的数据，$n \\leq 2000$；\n- 对于 $100\\%$ 的数据，$n \\leq 10^5$，$0 \\leq x_i \\leq 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "Facer's Magic", "background": "Facer accidentally trespassed into a forbidden land and learned magic.", "description": "After entering the forbidden land, Facer meets an opponent.\n\nMore specifically, Facer's magic is a sequence of numbers.\n\nHowever, Facer's ability is limited: this sequence can only be chosen from the given $n$ numbers, and the magic value produced equals the average of the chosen numbers.\n\nHis opponent does not wield magic as powerful as Facer's, but he can counter: he takes the median of the numbers Facer chose; that is his magic value.\n\nFind the maximum amount by which Facer can counter the opponent's magic.\n\nIn one sentence: given $n$ numbers, you may choose any non-empty subset so that (average − median) is maximized.\n\nDefinition of median: for a multiset of size $k$, sort the chosen numbers in non-decreasing order. If $k$ is odd, the median is the middle element; if $k$ is even, the median is the average of the two middle elements.", "inputFormat": "The first line contains a positive integer $n$.\n\nThe second line contains $n$ numbers as described.", "outputFormat": "Output the maximum value of (average − median) that Facer can achieve, to two decimal places.", "hint": "Constraints:\n- For $20\\%$ of the testdata, $n \\leq 100$.\n- For $50\\%$ of the testdata, $n \\leq 2000$.\n- For $100\\%$ of the testdata, $n \\leq 10^5$, $0 \\leq x_i \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Facer的魔法", "background": "Facer 误闯入禁地，学会了魔法。", "description": "Facer 闯入禁地之后，遇到了对手。\n\n具体来说，Facer 魔法是一串数字。\n\n但是 Facer 能力有限，这串数字只能从给定的 $n$ 个数中选择，能产生的魔法值为选择出的这些数字的平均数。\n\n他的对手不会像 Facer 这样的强大的魔法，但是他会克制招数，即从 Facer 选出的数字中找出中位数，便是他的魔法值。\n\n求 Facer 最多能克制对方多少点魔法。\n\n一句话题意：给你 $n$ 个数，你可以选若干个数，使得平均数减中位数最大。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个数如题。", "outputFormat": "Facer 能克制对方多少魔法值，精确到两位小数。", "hint": "- 对于 $20\\%$ 的数据，$n \\leq 100$；\n- 对于 $50\\%$ 的数据，$n \\leq 2000$；\n- 对于 $100\\%$ 的数据，$n \\leq 10^5$，$0 \\leq x_i \\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P2798", "type": "P", "difficulty": 5, "samples": [["4 2 5 \n1 2 6 5 \n1 3 3 1 \n2 3 9 4 \n2 4 6 1 \n3 4 4 2 \n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["树形数据结构", "二分"], "title": "爆弹虐场", "background": null, "description": "某年某月某日，Kiana 结识了一名爆弹虐场的少年。\n\nKiana 仗着自己多学了几年 OI，所以还可以勉勉强强给这位少年讲一些自己擅长的题。具体来说，Kiana 先给这位少年灌输了 $n$ 个毫不相干的知识点，然后再通过自己的[数据删除]技术把这些知识点强行联系在一起。\n\n由于这位少年有着爆弹虐场的实力，所以对于每个 Kiana 准备强行构造的联系，他都能够自己想出来，不过会花费更多的时间。具体来说，Kiana 一共有 $m$ 个联系，每个联系可以把两个不相干的知识点连在一起，如果由 Kiana 直接来讲第 $i$ 个联系，需要花费 $t_i$ 的时间，而如果由少年自己想出来，则需要花费 $T_i$ 的时间。\n\n为了偷懒，Kiana 只需要自己讲的或少年想出来的联系能刚好把知识点全部直接或间接串在一起就可以了。但为了保证教学质量，Kiana 觉得至少有 $k$ 个联系需要少年自己想出来。由于 Kiana 耐心有限，她希望无论是自己讲或是少年自己想，构造的联系中花费时间最长的一个用时最短。\n\n现在 Kiana 想知道，满足这些条件的情况下，构造的联系中耗时最长的一个的最短用时是多少。由于她不会算，所以希望由你告诉她。", "inputFormat": "输入文件包括 $m+1$ 行。\n\n第一行包含三个正整数 $n$，$k$ 和 $m$，分别表示知识点的数量，Kiana 希望少年自己想出来的联系的数量和联系的总数量。\n\n接下来 $m$ 行，每行包含四个正整数 $a$，$b$，$T_i$ 和 $t_i$，表示在知识点 $a$ 和 $b$ 之间可以构造出一个联系，这个联系由少年自己想出来需要花费 $T_i$ 的时间，而 Kiana 直接讲出来需要花费 $t_i$ 的时间。", "outputFormat": "输出文件包括一行。\n\n第一行包含一个正整数，表示构造的联系中耗时最长的一个的最短用时。", "hint": "对于 $30\\%$ 的数据，$1\\le n\\le 10,n-1\\le m\\le 15$，\n\n对于 $60\\%$ 的数据，$1\\le n\\le 500,n-1\\le m\\le 1000$，\n\n对于 $100\\%$ 的数据，$1\\le k<n\\le10000,n-1\\le m\\le20000$，\n\n$1\\le t_i<T_i\\le10^6$。\n\n数据保证一定存在可行解。", "locale": "zh-CN", "translations": {"en": {"title": "Explosive Mayhem Arena", "background": "", "description": "On a certain day, Kiana met a boy who dominates the Explosive Mayhem Arena.\n\nBecause Kiana has studied OI for a few more years, she can barely explain to this boy some problems she is good at. Specifically, Kiana first poured $n$ unrelated knowledge points into him, and then used her [Data Deletion] technique to forcibly connect these knowledge points.\n\nSince the boy is very strong, for each link Kiana plans to construct, he can figure it out by himself, but it will take more time. Specifically, Kiana has $m$ links. Each link can connect two unrelated knowledge points. If Kiana directly explains the $i$-th link, it takes $t_i$ time; if the boy figures it out himself, it takes $T_i$ time.\n\nTo be lazy, Kiana only needs the links she explains or the boy figures out to make all knowledge points directly or indirectly connected. But to ensure teaching quality, Kiana thinks at least $k$ links should be figured out by the boy himself. Since Kiana’s patience is limited, she wants the longest time among all constructed links, regardless of who does them, to be as small as possible.\n\nNow Kiana wants to know, under these conditions, what is the minimal possible value of the maximum time among the constructed links. Since she cannot compute it, she asks you to tell her.", "inputFormat": "The input contains $m+1$ lines.\n\nThe first line contains three positive integers $n$, $k$, and $m$, representing the number of knowledge points, the number of links Kiana wants the boy to figure out himself, and the total number of links, respectively.\n\nThen $m$ lines follow. Each line contains four positive integers $a$, $b$, $T_i$, and $t_i$, meaning a link can be constructed between knowledge points $a$ and $b$. If the boy figures out this link himself, it takes $T_i$ time; if Kiana explains it directly, it takes $t_i$ time.", "outputFormat": "The output contains one line.\n\nPrint a single positive integer, the minimal possible value of the maximum time among all constructed links.", "hint": "For $30\\%$ of the testdata, $1 \\le n \\le 10$, $n-1 \\le m \\le 15$.\n\nFor $60\\%$ of the testdata, $1 \\le n \\le 500$, $n-1 \\le m \\le 1000$.\n\nFor $100\\%$ of the testdata, $1 \\le k < n \\le 10000$, $n-1 \\le m \\le 20000$.\n\n$1 \\le t_i < T_i \\le 10^6$.\n\nThe testdata guarantees that a feasible solution exists.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "爆弹虐场", "background": null, "description": "某年某月某日，Kiana 结识了一名爆弹虐场的少年。\n\nKiana 仗着自己多学了几年 OI，所以还可以勉勉强强给这位少年讲一些自己擅长的题。具体来说，Kiana 先给这位少年灌输了 $n$ 个毫不相干的知识点，然后再通过自己的[数据删除]技术把这些知识点强行联系在一起。\n\n由于这位少年有着爆弹虐场的实力，所以对于每个 Kiana 准备强行构造的联系，他都能够自己想出来，不过会花费更多的时间。具体来说，Kiana 一共有 $m$ 个联系，每个联系可以把两个不相干的知识点连在一起，如果由 Kiana 直接来讲第 $i$ 个联系，需要花费 $t_i$ 的时间，而如果由少年自己想出来，则需要花费 $T_i$ 的时间。\n\n为了偷懒，Kiana 只需要自己讲的或少年想出来的联系能刚好把知识点全部直接或间接串在一起就可以了。但为了保证教学质量，Kiana 觉得至少有 $k$ 个联系需要少年自己想出来。由于 Kiana 耐心有限，她希望无论是自己讲或是少年自己想，构造的联系中花费时间最长的一个用时最短。\n\n现在 Kiana 想知道，满足这些条件的情况下，构造的联系中耗时最长的一个的最短用时是多少。由于她不会算，所以希望由你告诉她。", "inputFormat": "输入文件包括 $m+1$ 行。\n\n第一行包含三个正整数 $n$，$k$ 和 $m$，分别表示知识点的数量，Kiana 希望少年自己想出来的联系的数量和联系的总数量。\n\n接下来 $m$ 行，每行包含四个正整数 $a$，$b$，$T_i$ 和 $t_i$，表示在知识点 $a$ 和 $b$ 之间可以构造出一个联系，这个联系由少年自己想出来需要花费 $T_i$ 的时间，而 Kiana 直接讲出来需要花费 $t_i$ 的时间。", "outputFormat": "输出文件包括一行。\n\n第一行包含一个正整数，表示构造的联系中耗时最长的一个的最短用时。", "hint": "对于 $30\\%$ 的数据，$1\\le n\\le 10,n-1\\le m\\le 15$，\n\n对于 $60\\%$ 的数据，$1\\le n\\le 500,n-1\\le m\\le 1000$，\n\n对于 $100\\%$ 的数据，$1\\le k<n\\le10000,n-1\\le m\\le20000$，\n\n$1\\le t_i<T_i\\le10^6$。\n\n数据保证一定存在可行解。", "locale": "zh-CN"}}}
{"pid": "P2799", "type": "P", "difficulty": 2, "samples": [["ABBAABBA", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "搜索", "递归"], "title": "国王的魔镜", "background": "", "description": "国王有一个魔镜，可以把任何接触镜面的东西变成原来的两倍——只是，因为是镜子嘛，增加的那部分是反的。比如一条项链，我们用AB来表示，不同的字母表示不同颜色的珍珠。如果把B端接触镜面的话，魔镜会把这条项链变为ABBA。如果再用一端接触的话，则会变成ABBAABBA（假定国王只用项链的某一端接触魔镜）。给定最终的项链，请编写程序输出国王没使用魔镜之前，最初的项链可能的最小长度。\n", "inputFormat": "只有一个字符串，由大写英文字母组成（字母数<=100000），表示最终的项链。\n", "outputFormat": "只有一个整数，表示国王没使用魔镜前，最初的项链可能的最小长度。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "The King's Magic Mirror", "background": "", "description": "The king has a magic mirror that doubles anything touching its surface—only, because it is a mirror, the added part is reversed. For example, consider a necklace represented by AB, where different letters denote different colors of pearls. If the end B touches the mirror, the mirror turns the necklace into ABBA. If an end touches it again, it becomes ABBAABBA (assume the king always touches the mirror with one end of the necklace). Given the final necklace, write a program to output the minimal possible length of the original necklace before the mirror was used.", "inputFormat": "A single string consisting of uppercase English letters (length $ \\le 100000 $), representing the final necklace.", "outputFormat": "A single integer, representing the minimal possible length of the original necklace before the king used the mirror.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "国王的魔镜", "background": "", "description": "国王有一个魔镜，可以把任何接触镜面的东西变成原来的两倍——只是，因为是镜子嘛，增加的那部分是反的。比如一条项链，我们用AB来表示，不同的字母表示不同颜色的珍珠。如果把B端接触镜面的话，魔镜会把这条项链变为ABBA。如果再用一端接触的话，则会变成ABBAABBA（假定国王只用项链的某一端接触魔镜）。给定最终的项链，请编写程序输出国王没使用魔镜之前，最初的项链可能的最小长度。\n", "inputFormat": "只有一个字符串，由大写英文字母组成（字母数<=100000），表示最终的项链。\n", "outputFormat": "只有一个整数，表示国王没使用魔镜前，最初的项链可能的最小长度。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2800", "type": "P", "difficulty": 2, "samples": [["5\n3 5 1 8 4", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "又上锁妖塔", "background": null, "description": "小 A 在玩《剑仙》，他遇到了一个锁妖塔，想从外面爬上去。\n\n锁妖塔共有 $n$ 层，第 $i$ 层的高度为 $h_i$。小 A 初始时在地面上，他爬上第 $i$ 层需要花费的时间等于该层高度 $h_i$。小 A 会用仙术，每用一次可以让他向上跳一层或两层，该过程不花费时间。但是每次跳跃后小 A 都将用完力气，必须再爬过至少一层休息才可以继续使用仙术跳跃。\n\n现在小 A 想让你帮他算出爬上塔顶（第 $n$ 层）的最短时间。", "inputFormat": "第一行一个整数 $n$ 表示锁妖塔的层数。\n\n第二行 $n$ 个整数 $h_i$ 表示从下往上第 $i$ 层的高度。", "outputFormat": "一行一个整数 $t$，表示最短时间。", "hint": "对于所有的数据，保证 $1\\le n\\le 10 ^ 6,1\\le h_i \\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "Climbing the Demon-Sealing Tower Again", "background": "", "description": "Little A is playing \"Sword Immortal\" (Jianxian). He encounters a Demon-Sealing Tower and wants to climb it from the outside.\n\nThe tower has $n$ floors; the height of floor $i$ is $h_i$. Little A starts on the ground. Climbing floor $i$ (that is, moving from floor $i-1$ to floor $i$) takes time equal to that floor’s height $h_i$. Little A can use \"immortal arts\" (xiān shù). Each time he uses it, he can jump up by one or two floors, and this process takes no time. However, after each jump, Little A will be exhausted and must climb at least one floor to rest before he can use the immortal arts to jump again.\n\nNow Little A wants you to compute the minimal time to reach the top (floor $n$).", "inputFormat": "The first line contains an integer $n$ representing the number of floors in the Demon-Sealing Tower.\n\nThe second line contains $n$ integers $h_i$ representing the height of the $i$-th floor from bottom to top.", "outputFormat": "Output a single integer $t$, representing the minimal time.", "hint": "For all testdata, it is guaranteed that $1 \\le n \\le 10^6$, $1 \\le h_i \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "又上锁妖塔", "background": null, "description": "小 A 在玩《剑仙》，他遇到了一个锁妖塔，想从外面爬上去。\n\n锁妖塔共有 $n$ 层，第 $i$ 层的高度为 $h_i$。小 A 初始时在地面上，他爬上第 $i$ 层需要花费的时间等于该层高度 $h_i$。小 A 会用仙术，每用一次可以让他向上跳一层或两层，该过程不花费时间。但是每次跳跃后小 A 都将用完力气，必须再爬过至少一层休息才可以继续使用仙术跳跃。\n\n现在小 A 想让你帮他算出爬上塔顶（第 $n$ 层）的最短时间。", "inputFormat": "第一行一个整数 $n$ 表示锁妖塔的层数。\n\n第二行 $n$ 个整数 $h_i$ 表示从下往上第 $i$ 层的高度。", "outputFormat": "一行一个整数 $t$，表示最短时间。", "hint": "对于所有的数据，保证 $1\\le n\\le 10 ^ 6,1\\le h_i \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P2801", "type": "P", "difficulty": 5, "samples": [["5 3\n1 2 3 4 5\nA 1 5 4\nM 3 5 1\nA 1 5 4", "2\n3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["二分", "排序", "分块"], "title": "教主的魔法", "background": "", "description": "教主最近学会了一种神奇的魔法，能够使人长高。于是他准备演示给 XMYZ 信息组每个英雄看。于是 $N$ 个英雄们又一次聚集在了一起，这次他们排成了一列，被编号为 $1, 2, \\ldots, N$。\n\n\n每个人的身高一开始都是不超过 $1000$ 的正整数。教主的魔法每次可以把闭区间 $[L, R]$（$1≤L≤R≤N$）内的英雄的身高全部加上一个整数 $W$。（虽然 $L=R$ 时并不符合区间的书写规范，但我们可以认为是单独增加第 $L(R)$ 个英雄的身高）\n\n\nCYZ、光哥和 ZJQ 等人不信教主的邪，于是他们有时候会问 WD 闭区间 $[L, R]$ 内有多少英雄身高大于等于 $C$，以验证教主的魔法是否真的有效。\n\n\nWD 巨懒，于是他把这个回答的任务交给了你。\n", "inputFormat": "第 $1$ 行为两个整数 $N, Q$。$Q$ 为问题数与教主的施法数总和。\n\n第 $2$ 行有 $N$ 个正整数，第 $i$ 个数代表第 $i$ 个英雄的身高。\n\n\n第 $3$ 到第 $Q+2$ 行每行有一个操作：\n\n\n1. 若第一个字母为 `M`，则紧接着有三个数字 $L, R, W$。表示对闭区间 $[L, R]$ 内所有英雄的身高加上 $W$。\n\n2. 若第一个字母为 `A`，则紧接着有三个数字 $L, R, C$。询问闭区间 $[L, R]$ 内有多少英雄的身高大于等于 $C$。\n", "outputFormat": "对每个 `A` 询问输出一行，仅含一个整数，表示闭区间 $[L, R]$ 内身高大于等于 $C$ 的英雄数。\n", "hint": "【输入输出样例说明】\n\n原先 $5$ 个英雄身高为 $1, 2, 3, 4, 5$，此时 $[1, 5]$ 间有 $2$ 个英雄的身高大于等于 $4$。教主施法后变为 $1, 2, 4, 5, 6$，此时 $[1, 5]$ 间有 $3$ 个英雄的身高大于等于 $4$。\n\n【数据范围】\n\n对于 $30\\%$ 的数据，$N≤1000$，$Q≤1000$。\n\n对于 $100\\%$ 的数据，$N≤10^6$，$Q≤3000$，$1≤W≤1000$，$1≤C≤10^9$。\n\n---\n\n$\\text{upd 2022.8.18}$：新增加一组 Hack 数据。  \n$\\text{upd 2023.8.16}$：新增加一组 [Hack 数据](https://www.luogu.com.cn/discuss/661585)。", "locale": "zh-CN", "translations": {"en": {"title": "{{The Leader's Magic}}", "background": "{{}}", "description": "{{The leader has recently learned a magical spell that can make people taller. He plans to demonstrate it to every hero in the XMYZ Information Group. Thus, $N$ heroes gather once again, lining up in a row and being numbered $1, 2, \\ldots, N$.\n\nEach person’s height is initially a positive integer not exceeding $1000$. Each time the leader casts the spell, he can add an integer $W$ to the heights of all heroes in the closed interval $[L, R]$ ($1≤L≤R≤N$). (Although $L=R$ is not standard interval notation, we can regard it as increasing only the height of the $L$-th hero.)\n\nCYZ, Guang Ge, and ZJQ do not believe in the leader’s magic, so they sometimes ask WD how many heroes in the closed interval $[L, R]$ have height greater than or equal to $C$, to verify whether the magic really works.\n\nWD is extremely lazy, so he hands this task over to you.}}", "inputFormat": "{{The first line contains two integers $N, Q$. $Q$ is the total number of queries and spells.\n\nThe second line contains $N$ positive integers; the $i$-th number is the height of the $i$-th hero.\n\nLines $3$ through $Q+2$ each contain one operation:\n\n1. If the first letter is `M`, then three numbers $L, R, W$ follow. Add $W$ to the heights of all heroes in the closed interval $[L, R]$.\n\n2. If the first letter is `A`, then three numbers $L, R, C$ follow. Query how many heroes in the closed interval $[L, R]$ have height greater than or equal to $C$.}}", "outputFormat": "{{For each `A` query, output one line containing a single integer: the number of heroes with height greater than or equal to $C$ in $[L, R]$.}}", "hint": "{{Sample explanation:\n\nOriginally, the $5$ heroes’ heights are $1, 2, 3, 4, 5$, so there are $2$ heroes in $[1, 5]$ whose heights are at least $4$. After the leader casts the spell, the heights become $1, 2, 4, 5, 6$, so there are $3$ heroes in $[1, 5]$ whose heights are at least $4$.\n\nConstraints:\n\n- For $30\\%$ of the testdata, $N≤1000$, $Q≤1000$.\n- For $100\\%$ of the testdata, $N≤10^6$, $Q≤3000$, $1≤W≤1000$, $1≤C≤10^9$.\n\n---\n\n$\\text{upd 2022.8.18}$: A new set of Hack testdata has been added.\n$\\text{upd 2023.8.16}$: A new set of [Hack testdata](https://www.luogu.com.cn/discuss/661585) has been added.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "教主的魔法", "background": "", "description": "教主最近学会了一种神奇的魔法，能够使人长高。于是他准备演示给 XMYZ 信息组每个英雄看。于是 $N$ 个英雄们又一次聚集在了一起，这次他们排成了一列，被编号为 $1, 2, \\ldots, N$。\n\n\n每个人的身高一开始都是不超过 $1000$ 的正整数。教主的魔法每次可以把闭区间 $[L, R]$（$1≤L≤R≤N$）内的英雄的身高全部加上一个整数 $W$。（虽然 $L=R$ 时并不符合区间的书写规范，但我们可以认为是单独增加第 $L(R)$ 个英雄的身高）\n\n\nCYZ、光哥和 ZJQ 等人不信教主的邪，于是他们有时候会问 WD 闭区间 $[L, R]$ 内有多少英雄身高大于等于 $C$，以验证教主的魔法是否真的有效。\n\n\nWD 巨懒，于是他把这个回答的任务交给了你。\n", "inputFormat": "第 $1$ 行为两个整数 $N, Q$。$Q$ 为问题数与教主的施法数总和。\n\n第 $2$ 行有 $N$ 个正整数，第 $i$ 个数代表第 $i$ 个英雄的身高。\n\n\n第 $3$ 到第 $Q+2$ 行每行有一个操作：\n\n\n1. 若第一个字母为 `M`，则紧接着有三个数字 $L, R, W$。表示对闭区间 $[L, R]$ 内所有英雄的身高加上 $W$。\n\n2. 若第一个字母为 `A`，则紧接着有三个数字 $L, R, C$。询问闭区间 $[L, R]$ 内有多少英雄的身高大于等于 $C$。\n", "outputFormat": "对每个 `A` 询问输出一行，仅含一个整数，表示闭区间 $[L, R]$ 内身高大于等于 $C$ 的英雄数。\n", "hint": "【输入输出样例说明】\n\n原先 $5$ 个英雄身高为 $1, 2, 3, 4, 5$，此时 $[1, 5]$ 间有 $2$ 个英雄的身高大于等于 $4$。教主施法后变为 $1, 2, 4, 5, 6$，此时 $[1, 5]$ 间有 $3$ 个英雄的身高大于等于 $4$。\n\n【数据范围】\n\n对于 $30\\%$ 的数据，$N≤1000$，$Q≤1000$。\n\n对于 $100\\%$ 的数据，$N≤10^6$，$Q≤3000$，$1≤W≤1000$，$1≤C≤10^9$。\n\n---\n\n$\\text{upd 2022.8.18}$：新增加一组 Hack 数据。  \n$\\text{upd 2023.8.16}$：新增加一组 [Hack 数据](https://www.luogu.com.cn/discuss/661585)。", "locale": "zh-CN"}}}
{"pid": "P2802", "type": "P", "difficulty": 2, "samples": [["3 3\n2 1 1\n1 1 0\n1 1 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "广度优先搜索 BFS"], "title": "回家", "background": "", "description": "[](https://paste.ubuntu.com/p/DSg5bzrrjs/)\n\n小 H 在一个划分成了 $n \\times m$ 个方格的长方形封锁线上。 每次他能向上下左右四个方向移动一格（当然小 H 不可以静止不动）， 但不能离开封锁线，否则就被打死了。 刚开始时他有满血 $6$ 点，每移动一格他要消耗 $1$ 点血量。一旦小 H 的血量降到 $0$， 他将死去。 他可以沿路通过拾取鼠标（什么鬼。。。）来补满血量。只要他走到有鼠标的格子，他不需要任何时间即可拾取。格子上的鼠标可以瞬间补满，所以每次经过这个格子都有鼠标。就算到了某个有鼠标的格子才死去， 他也不能通过拾取鼠标补满 HP。 即使在家门口死去， 他也不能算完成任务回到家中。\n\n地图上有五种格子：\n\n`0`：障碍物。\n\n`1`：空地， 小 H 可以自由行走。\n\n`2`：小 H 出发点， 也是一片空地。\n\n`3`：小 H 的家。\n\n`4`：有鼠标在上面的空地。\n\n小 H 能否安全回家？如果能， 最短需要多长时间呢？\n", "inputFormat": "第一行两个整数 $n,m$， 表示地图的大小为 $n \\times m$。\n\n下面 $n$ 行， 每行 $m$ 个数字来描述地图。", "outputFormat": "一行， 若小 H 不能回家， 输出 `-1`，否则输出他回家所需最短时间。", "hint": "对于所有数据，$1 \\le n,m \\le 9$。\n\n2021.9.2 增添一组 hack 数据 by @囧仙", "locale": "zh-CN", "translations": {"en": {"title": "Go Home", "background": "", "description": "[](https://paste.ubuntu.com/p/DSg5bzrrjs/)\n\nXiao H is on a rectangular cordon divided into $n \\times m$ cells. Each move, he can move one cell in one of the four directions: up, down, left, or right (he cannot stay still). He cannot leave the cordon; otherwise, he will be killed. He starts with full HP of 6 points, and each step costs 1 point of HP. Once his HP drops to 0, he dies. He can pick up a mouse (what the heck...) along the way to refill his HP to full. As long as he steps onto a cell with a mouse, he can pick it up instantly without spending any time. The mouse on a cell refills instantly, so each time he passes that cell, there is a mouse. Even if he dies upon arriving at a cell with a mouse, he cannot refill his HP by picking it up. Even if he dies at his doorstep, it does not count as having returned home.\n\nThere are five types of cells on the map:\n\n`0`: Obstacle.\n\n`1`: Empty cell; Xiao H can walk freely.\n\n`2`: Xiao H’s starting point; also an empty cell.\n\n`3`: Xiao H’s home.\n\n`4`: An empty cell with a mouse on it.\n\nCan Xiao H return home safely? If yes, what is the shortest time needed?", "inputFormat": "The first line contains two integers $n, m$, indicating that the map size is $n \\times m$.\n\nThe next $n$ lines each contain $m$ numbers describing the map.", "outputFormat": "Output one line: if Xiao H cannot return home, output `-1`; otherwise, output the shortest time he needs to return home.", "hint": "For all testdata, $1 \\le n, m \\le 9$.\n\n2021.9.2 Added a set of hack testdata by @囧仙.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "回家", "background": "", "description": "[](https://paste.ubuntu.com/p/DSg5bzrrjs/)\n\n小 H 在一个划分成了 $n \\times m$ 个方格的长方形封锁线上。 每次他能向上下左右四个方向移动一格（当然小 H 不可以静止不动）， 但不能离开封锁线，否则就被打死了。 刚开始时他有满血 $6$ 点，每移动一格他要消耗 $1$ 点血量。一旦小 H 的血量降到 $0$， 他将死去。 他可以沿路通过拾取鼠标（什么鬼。。。）来补满血量。只要他走到有鼠标的格子，他不需要任何时间即可拾取。格子上的鼠标可以瞬间补满，所以每次经过这个格子都有鼠标。就算到了某个有鼠标的格子才死去， 他也不能通过拾取鼠标补满 HP。 即使在家门口死去， 他也不能算完成任务回到家中。\n\n地图上有五种格子：\n\n`0`：障碍物。\n\n`1`：空地， 小 H 可以自由行走。\n\n`2`：小 H 出发点， 也是一片空地。\n\n`3`：小 H 的家。\n\n`4`：有鼠标在上面的空地。\n\n小 H 能否安全回家？如果能， 最短需要多长时间呢？\n", "inputFormat": "第一行两个整数 $n,m$， 表示地图的大小为 $n \\times m$。\n\n下面 $n$ 行， 每行 $m$ 个数字来描述地图。", "outputFormat": "一行， 若小 H 不能回家， 输出 `-1`，否则输出他回家所需最短时间。", "hint": "对于所有数据，$1 \\le n,m \\le 9$。\n\n2021.9.2 增添一组 hack 数据 by @囧仙", "locale": "zh-CN"}}}
{"pid": "P2803", "type": "P", "difficulty": 3, "samples": [["3 2\n24 18 31\n10 8", "144"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "学校选址 II", "background": "", "description": "在一条大路一旁有许多栋楼，每栋楼里有许多小学生（哈哈哈一波小学生来袭！）。但是这条路上没有小学！！！！所以唯恐世界不乱的牛A打算在路上（汽车什么的都不敢来这个小学生云集的地方咯，所以不用担心安全问题）任选几点（可以和楼重合，当然也可以不重合）建立小学，且使所有小学生上学走的路程之和最短。牛A发现修建一所小学根本无法满足他唯恐世界不乱的（变态）心理，所以他准备建立K所小学。\n", "inputFormat": "第一行2个整数，表示楼数n，学校数k（1<=n,k<=100）\n\n第二行n个整数，表示每栋楼的学生数（0＜每栋楼学生数≤100 )\n\n第三行n-1个数，分别表示楼i到楼i+1之间距离（1≤距离≤100，1≤i≤n-1）\n", "outputFormat": "即学生走的距离和的最小值\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "School Location II", "background": "", "description": "Along one side of a straight road there are many buildings, each with some primary school students. However, there is no primary school on this road. Therefore, the ever-mischievous \"Niu A\" plans to choose points on the road to build primary schools (they may coincide with building locations or not), so that the total walking distance of all students is minimized. Since building just one school cannot satisfy his desire for chaos, he decides to build K schools.", "inputFormat": "- The first line contains two integers $n$ and $k$, the number of buildings and the number of schools ($1 \\le n, k \\le 100$).\n- The second line contains $n$ integers, the number of students in each building (each count is between $1$ and $100$ inclusive).\n- The third line contains $n - 1$ integers, where the $i$-th number is the distance between building $i$ and building $i + 1$ ($1 \\le i \\le n - 1$, each distance is between $1$ and $100$ inclusive).", "outputFormat": "Output the minimal total walking distance of all students.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "学校选址 II", "background": "", "description": "在一条大路一旁有许多栋楼，每栋楼里有许多小学生（哈哈哈一波小学生来袭！）。但是这条路上没有小学！！！！所以唯恐世界不乱的牛A打算在路上（汽车什么的都不敢来这个小学生云集的地方咯，所以不用担心安全问题）任选几点（可以和楼重合，当然也可以不重合）建立小学，且使所有小学生上学走的路程之和最短。牛A发现修建一所小学根本无法满足他唯恐世界不乱的（变态）心理，所以他准备建立K所小学。\n", "inputFormat": "第一行2个整数，表示楼数n，学校数k（1<=n,k<=100）\n\n第二行n个整数，表示每栋楼的学生数（0＜每栋楼学生数≤100 )\n\n第三行n-1个数，分别表示楼i到楼i+1之间距离（1≤距离≤100，1≤i≤n-1）\n", "outputFormat": "即学生走的距离和的最小值\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2804", "type": "P", "difficulty": 4, "samples": [["4 3\n1 5 4 2", "5"], ["4 4\n5 2 7 3", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "数学", "线性数据结构", "二分", "树状数组", "递归", "离散化"], "title": "神秘数字", "background": "在公元 XXXX 年，侦探小明收到了组织的神秘信息，在 Y 市的某个地方有一道神秘的门。小明到达了那个门后，发现门上有一行字：“这个门需要密码才能解锁。”小明左找右找，终于找到了一张字条：“现在给你 $n$ 个数，请你求出这 $n$ 个数里面，有多少个连续的数的平均数大于某个给定的数 $M$？注意：这个数可能会很大，请输出这个数对 $92084931$ 取模的结果。最终的结果即是这个门的密码。”小明苦思冥想了半天，但始终找不到答案。于是他来求助于你。请你帮他解决这个问题。由于小明十分着急，他最多只能等 $1$ 秒。", "description": "给定 $n$ 个数，请你帮助小明求出里面有多少个连续的数的平均数大于给定的某个数 $M$。并将这个方案数输出。注意：这个数可能会很大，所以请输出这个数对 $92084931$ 取模的结果。", "inputFormat": "两行。第一行为两个数 $n$ 和 $M$。第二行为 $n$ 个数。", "outputFormat": "一行一个数，即问题的解对 $92084931$ 取模的结果。", "hint": "#### 样例解释\n\n1. 对于这 $4$ 个数，问题的解有 $\\{5\\},\\{4\\},\\{5,4\\},\\{1,5,4\\},\\{5,4,2\\}$ 共 $5$ 组。\n\n1. 对于这4个数，问题的解有 $\\{5\\},\\{7\\},\\{2,7\\},\\{7,3\\},\\{5,2,7\\},\\{5,2,7,3\\}$ 共 $6$ 组。\n\n#### 数据规模\n\n对于 $10\\%$ 的数据，$1<n \\le 10$。\n\n对于 $30\\%$ 的数据，$1<n \\le 1000$。\n\n对于 $50\\%$ 的数据，$1<n \\le 30000$。\n\n对于 $100\\%$ 的数据，$1<n \\le 200000$，$1<M \\le 3000$，每个数均为正整数且不大于 $5000$。", "locale": "zh-CN", "translations": {"en": {"title": "Mysterious Number", "background": "In the year XXXX, detective Xiao Ming received a secret message from the organization: there is a mysterious door somewhere in Y City. After arriving at the door, he found a line of text: “This door requires a password to unlock.” Xiao Ming searched around and finally found a note: “Now you are given $n$ numbers. Please find how many contiguous numbers among these $n$ numbers have an average greater than a given number $M$. Note: this number can be very large, so please output the result modulo $92084931$. The final result is the password to this door.” Xiao Ming pondered for a long time but still couldn’t find the answer, so he turned to you for help. Please solve this problem for him. Since Xiao Ming is in a hurry, he can wait at most $1$ second.", "description": "Given $n$ numbers, help Xiao Ming count how many contiguous subarrays have an average greater than a given number $M$, and output this count. Note: the number can be very large, so please output the result modulo $92084931$.", "inputFormat": "Two lines.  \nThe first line contains two numbers $n$ and $M$.  \nThe second line contains $n$ numbers.", "outputFormat": "One line with a single number, which is the answer modulo $92084931$.", "hint": "Sample explanation:\n1. For these $4$ numbers, the valid solutions are $\\{5\\},\\{4\\},\\{5,4\\},\\{1,5,4\\},\\{5,4,2\\}$, for a total of $5$ groups.\n2. For these $4$ numbers, the valid solutions are $\\{5\\},\\{7\\},\\{2,7\\},\\{7,3\\},\\{5,2,7\\},\\{5,2,7,3\\}$, for a total of $6$ groups.\n\nConstraints:\n- For $10\\%$ of the testdata, $1 < n \\le 10$.\n- For $30\\%$ of the testdata, $1 < n \\le 1000$.\n- For $50\\%$ of the testdata, $1 < n \\le 30000$.\n- For $100\\%$ of the testdata, $1 < n \\le 200000$, $1 < M \\le 3000$, and each number is a positive integer not greater than $5000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "神秘数字", "background": "在公元 XXXX 年，侦探小明收到了组织的神秘信息，在 Y 市的某个地方有一道神秘的门。小明到达了那个门后，发现门上有一行字：“这个门需要密码才能解锁。”小明左找右找，终于找到了一张字条：“现在给你 $n$ 个数，请你求出这 $n$ 个数里面，有多少个连续的数的平均数大于某个给定的数 $M$？注意：这个数可能会很大，请输出这个数对 $92084931$ 取模的结果。最终的结果即是这个门的密码。”小明苦思冥想了半天，但始终找不到答案。于是他来求助于你。请你帮他解决这个问题。由于小明十分着急，他最多只能等 $1$ 秒。", "description": "给定 $n$ 个数，请你帮助小明求出里面有多少个连续的数的平均数大于给定的某个数 $M$。并将这个方案数输出。注意：这个数可能会很大，所以请输出这个数对 $92084931$ 取模的结果。", "inputFormat": "两行。第一行为两个数 $n$ 和 $M$。第二行为 $n$ 个数。", "outputFormat": "一行一个数，即问题的解对 $92084931$ 取模的结果。", "hint": "#### 样例解释\n\n1. 对于这 $4$ 个数，问题的解有 $\\{5\\},\\{4\\},\\{5,4\\},\\{1,5,4\\},\\{5,4,2\\}$ 共 $5$ 组。\n\n1. 对于这4个数，问题的解有 $\\{5\\},\\{7\\},\\{2,7\\},\\{7,3\\},\\{5,2,7\\},\\{5,2,7,3\\}$ 共 $6$ 组。\n\n#### 数据规模\n\n对于 $10\\%$ 的数据，$1<n \\le 10$。\n\n对于 $30\\%$ 的数据，$1<n \\le 1000$。\n\n对于 $50\\%$ 的数据，$1<n \\le 30000$。\n\n对于 $100\\%$ 的数据，$1<n \\le 200000$，$1<M \\le 3000$，每个数均为正整数且不大于 $5000$。", "locale": "zh-CN"}}}
{"pid": "P2805", "type": "P", "difficulty": 6, "samples": [["3 2\n10 0\n20 0\n-10 0\n-5 1 0 0\n100 1 2 1\n100 0", "25"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "NOI", "网络流", "图论建模", "拓扑排序", "最小割"], "title": "[NOI2009] 植物大战僵尸", "background": "Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和 Zombies（僵尸）是游戏的主角，其中 Plants 防守，而 Zombies 进攻。该款游戏包含多种不同的挑战系列，比如 Protect Your Brain、Bowling 等等。其中最为经典的，莫过于玩家通过控制 Plants 来防守 Zombies 的进攻，或者相反地由玩家通过控制 Zombies 对 Plants 发起进攻。\n\n", "description": "现在，我们将要考虑的问题是游戏中 Zombies 对 Plants 的进攻，请注意，本题中规则与实际游戏**有所不同**。游戏中有两种角色，Plants 和 Zombies，每个 Plant 有一个攻击位置集合，它可以对这些位置进行保护；而 Zombie 进攻植物的方式是走到植物所在的位置上并将其吃掉。\n\n游戏的地图可以抽象为一个 $N$ 行 $M$ 列的矩阵，行从上到下用 $0$ 到 $N–1$ 编号，列从左到右用 $0$ 到 $M–1$ 编号；在地图的每个位置上都放有一个 $Plant$，为简单起见，我们把位于第 $r$ 行第 $c$ 列的植物记为 $P_{r, c}$。\n\nPlants 分很多种，有「攻击类」「防守类」和「经济类」等等。为了简单的描述每个 Plant，定义 $\\operatorname{Score}$ 和 $\\operatorname{Attack}$ 如下：\n\n* $\\operatorname{Score}(P_{r, c})$ — Zombie 击溃植物 $P_{r, c}$ 可获得的能源。   \n若 $\\operatorname{Score}(P_{r, c})$ 为非负整数，则表示击溃植物 $P_{r, c}$ 可获得能源 $\\operatorname{Score}(P_{r, c})$，若为负数表示击溃 $P_{r, c}$ 需要付出能源 $-\\operatorname{Score}(P_{r, c})$。\n\n* $\\operatorname{Attack}(P_{r, c})$ — 植物 $P_{r, c}$ 能够对 Zombie 进行攻击的位置集合。\n\nZombies 必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies 攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此 Zombies 的进攻总是从地图的右侧开始。也就是说，对于第 $r$ 行的进攻，Zombies 必须首先攻击 $P_{r, M-1}$；若需要对 $P_{r, c}$（$0 \\le c < m - 1$）攻击，必须将 $P_{r,M-1}, P_{r, M-2} \\cdots P_{r, c+1}$ 先击溃，并移动到位置 $(r, c)$ 才可进行攻击。\n\n在本题的设定中，Plants 的攻击力是无穷大的，一旦 Zombie 进入某个 Plant 的攻击位置，该 Zombie 会被瞬间消灭，而该 Zombie 没有时间进行任何攻击操作。因此，即便 Zombie 进入了一个 Plant 所在的位置，但该位置属于其他植物的攻击位置集合，则 Zombie 会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant 的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。\n\nZombies 的目标是对 Plants 的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套 Zombies 的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。", "inputFormat": "第一行包含两个正整数 $N$ 和 $M$，分别表示地图的行数和列数。\n\n接下来 $N \\times M$ 行描述每个位置上植物的信息。第 $r \\times M + c + 1$ 行按照如下格式给出植物 $P_{r, c}$ 的信息：\n\n第一个整数为 $\\operatorname{Score}(P_{r,c})$，第二个整数为集合 $\\operatorname{Attack}(P_{r,c})$ 中的位置个数 $w$，接下来 $w$ 个位置信息 $(r', c')$，表示 $P_{r, c}$ 可以攻击位置第 $r'$ 行第 $c'$ 列。\n\n", "outputFormat": "仅包含一个整数，表示可以获得的最大能源收入。注意，你也可以选择不进行任何攻击，这样能源收入为 $0$。", "hint": "#### 数据规模与约定\n- 对于 $20\\%$ 的数据，保证 $ N, M \\le 5$。\n- 对于 $40\\%$ 的数据，保证 $ N, M \\le 10$。\n- 对于 $100\\%$ 的数据，保证 $1 \\le N \\le 20$，$1 \\le M \\le 30$，$-10^4 ≤ \\operatorname{Score} \\le 10^4$。\n\n#### 说明\n题面由 @syksykCCC 修改。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2009] Plants vs. Zombies", "background": "Plants vs. Zombies (PVZ) is a very popular casual game. Plants and Zombies are the main characters: Plants defend while Zombies attack. The game features many different challenge series, such as Protect Your Brain and Bowling. The most classic mode is where the player controls Plants to defend against Zombies, or conversely the player controls Zombies to attack the Plants.", "description": "We will consider the scenario where Zombies attack Plants in the game. Note that the rules in this problem differ from the actual game. There are two roles, Plants and Zombies. Each Plant has a set of attack positions, and it can protect those positions. A Zombie attacks a plant by stepping onto the plant’s position and eating it.\n\nThe map is modeled as an $N$-by-$M$ grid. Rows are numbered from top to bottom as $0$ to $N-1$, and columns are numbered from left to right as $0$ to $M-1$. There is a $Plant$ placed at every position on the map. For simplicity, we denote the plant at row $r$ and column $c$ as $P_{r, c}$.\n\nThere are many types of Plants, such as “attack-type,” “defense-type,” and “economy-type.” To describe each Plant, define $\\operatorname{Score}$ and $\\operatorname{Attack}$ as follows:\n\n- $\\operatorname{Score}(P_{r, c})$ — the energy a Zombie gains by destroying plant $P_{r, c}$.  \nIf $\\operatorname{Score}(P_{r, c})$ is a non-negative integer, then destroying $P_{r, c}$ grants energy $\\operatorname{Score}(P_{r, c})$. If it is negative, then destroying $P_{r, c}$ costs energy $-\\operatorname{Score}(P_{r, c})$.\n\n- $\\operatorname{Attack}(P_{r, c})$ — the set of positions that plant $P_{r, c}$ can attack.\n\nZombies must enter from the right side of the map and can only move horizontally. The only way a Zombie attacks a plant is by moving to that plant’s position and eating it. Therefore, a Zombie attack on row $r$ always starts from the right side of the map. That is, for an attack on row $r$, the Zombies must first attack $P_{r, M-1}$. If they want to attack $P_{r, c}$ with $0 \\le c < M - 1$, they must first destroy $P_{r, M-1}, P_{r, M-2}, \\dots, P_{r, c+1}$ and move to position $(r, c)$ to attack.\n\nIn this problem, Plants have infinite attack power. Once a Zombie enters any plant’s attack position, that Zombie is instantly eliminated and has no time to perform any attack action. Therefore, even if a Zombie steps onto a plant’s position, if that position is in another plant’s attack set, the Zombie is instantly eliminated and the plant at that position remains unharmed. (In our setting, a plant’s attack set does not include its own position; otherwise you could never destroy it.)\n\nThe Zombies’ goal is to attack the Plants’ formation to obtain the maximum energy income. Each time, you may choose one attackable plant to attack. The objective is to design an attack plan for the Zombies, choosing which plants to attack and in what order, to maximize the total energy income.", "inputFormat": "The first line contains two positive integers $N$ and $M$, the number of rows and columns of the map.\n\nThe next $N \\times M$ lines describe the plant at each position. For $0 \\le r < N$ and $0 \\le c < M$, the $(r \\times M + c + 1)$-th of these lines gives the information for plant $P_{r, c}$ in the following format:\n\nThe first integer is $\\operatorname{Score}(P_{r, c})$, the second integer is $w$, the number of positions in $\\operatorname{Attack}(P_{r, c})$, followed by $w$ positions $(r', c')$, indicating that $P_{r, c}$ can attack the position at row $r'$ and column $c'$.", "outputFormat": "Output a single integer: the maximum energy income that can be obtained. Note that you may also choose to make no attacks, in which case the income is $0$.", "hint": "#### Constraints\n- For $20\\%$ of the testdata, $N, M \\le 5$.\n- For $40\\%$ of the testdata, $N, M \\le 10$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 20$, $1 \\le M \\le 30$, $-10^4 \\le \\operatorname{Score} \\le 10^4$.\n\n#### Notes\nStatement modified by @syksykCCC.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2009] 植物大战僵尸", "background": "Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和 Zombies（僵尸）是游戏的主角，其中 Plants 防守，而 Zombies 进攻。该款游戏包含多种不同的挑战系列，比如 Protect Your Brain、Bowling 等等。其中最为经典的，莫过于玩家通过控制 Plants 来防守 Zombies 的进攻，或者相反地由玩家通过控制 Zombies 对 Plants 发起进攻。\n\n", "description": "现在，我们将要考虑的问题是游戏中 Zombies 对 Plants 的进攻，请注意，本题中规则与实际游戏**有所不同**。游戏中有两种角色，Plants 和 Zombies，每个 Plant 有一个攻击位置集合，它可以对这些位置进行保护；而 Zombie 进攻植物的方式是走到植物所在的位置上并将其吃掉。\n\n游戏的地图可以抽象为一个 $N$ 行 $M$ 列的矩阵，行从上到下用 $0$ 到 $N–1$ 编号，列从左到右用 $0$ 到 $M–1$ 编号；在地图的每个位置上都放有一个 $Plant$，为简单起见，我们把位于第 $r$ 行第 $c$ 列的植物记为 $P_{r, c}$。\n\nPlants 分很多种，有「攻击类」「防守类」和「经济类」等等。为了简单的描述每个 Plant，定义 $\\operatorname{Score}$ 和 $\\operatorname{Attack}$ 如下：\n\n* $\\operatorname{Score}(P_{r, c})$ — Zombie 击溃植物 $P_{r, c}$ 可获得的能源。   \n若 $\\operatorname{Score}(P_{r, c})$ 为非负整数，则表示击溃植物 $P_{r, c}$ 可获得能源 $\\operatorname{Score}(P_{r, c})$，若为负数表示击溃 $P_{r, c}$ 需要付出能源 $-\\operatorname{Score}(P_{r, c})$。\n\n* $\\operatorname{Attack}(P_{r, c})$ — 植物 $P_{r, c}$ 能够对 Zombie 进行攻击的位置集合。\n\nZombies 必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies 攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此 Zombies 的进攻总是从地图的右侧开始。也就是说，对于第 $r$ 行的进攻，Zombies 必须首先攻击 $P_{r, M-1}$；若需要对 $P_{r, c}$（$0 \\le c < m - 1$）攻击，必须将 $P_{r,M-1}, P_{r, M-2} \\cdots P_{r, c+1}$ 先击溃，并移动到位置 $(r, c)$ 才可进行攻击。\n\n在本题的设定中，Plants 的攻击力是无穷大的，一旦 Zombie 进入某个 Plant 的攻击位置，该 Zombie 会被瞬间消灭，而该 Zombie 没有时间进行任何攻击操作。因此，即便 Zombie 进入了一个 Plant 所在的位置，但该位置属于其他植物的攻击位置集合，则 Zombie 会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant 的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。\n\nZombies 的目标是对 Plants 的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套 Zombies 的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。", "inputFormat": "第一行包含两个正整数 $N$ 和 $M$，分别表示地图的行数和列数。\n\n接下来 $N \\times M$ 行描述每个位置上植物的信息。第 $r \\times M + c + 1$ 行按照如下格式给出植物 $P_{r, c}$ 的信息：\n\n第一个整数为 $\\operatorname{Score}(P_{r,c})$，第二个整数为集合 $\\operatorname{Attack}(P_{r,c})$ 中的位置个数 $w$，接下来 $w$ 个位置信息 $(r', c')$，表示 $P_{r, c}$ 可以攻击位置第 $r'$ 行第 $c'$ 列。\n\n", "outputFormat": "仅包含一个整数，表示可以获得的最大能源收入。注意，你也可以选择不进行任何攻击，这样能源收入为 $0$。", "hint": "#### 数据规模与约定\n- 对于 $20\\%$ 的数据，保证 $ N, M \\le 5$。\n- 对于 $40\\%$ 的数据，保证 $ N, M \\le 10$。\n- 对于 $100\\%$ 的数据，保证 $1 \\le N \\le 20$，$1 \\le M \\le 30$，$-10^4 ≤ \\operatorname{Score} \\le 10^4$。\n\n#### 说明\n题面由 @syksykCCC 修改。", "locale": "zh-CN"}}}
{"pid": "P2807", "type": "P", "difficulty": 2, "samples": [["3\n1\n2\n3", "1\n5\n13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推"], "title": "三角形计数", "background": "三角形计数(triangle) 递推\n", "description": "把大三角形的每条边 $n$ 等分，将对应的等分点连接起来（连接线分别平行于三条边），这样一共会有多少三角形呢？编程来解决这个问题。\n", "inputFormat": "第一行为整数 $t(t≤100)$，表示测试数据组数；接下来 $t$ 行，每行一个正整数 $n(n≤500)$。\n", "outputFormat": "对于每个 $n$，输出一个正整数，表示三角形个数。\n", "hint": "\n", "locale": "zh-CN", "translations": {"en": {"title": "Triangle Counting", "background": "Triangle counting (triangle), recurrence.", "description": "Divide each side of the large triangle into $n$ equal parts. Connect the corresponding division points, with the connecting lines respectively parallel to the three sides. How many triangles are there in total? Write a program to solve this problem.", "inputFormat": "The first line contains an integer $t$ ($t \\le 100$), indicating the number of test cases. The next $t$ lines each contain a positive integer $n$ ($n \\le 500$).", "outputFormat": "For each $n$, output a single positive integer, representing the number of triangles.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "三角形计数", "background": "三角形计数(triangle) 递推\n", "description": "把大三角形的每条边 $n$ 等分，将对应的等分点连接起来（连接线分别平行于三条边），这样一共会有多少三角形呢？编程来解决这个问题。\n", "inputFormat": "第一行为整数 $t(t≤100)$，表示测试数据组数；接下来 $t$ 行，每行一个正整数 $n(n≤500)$。\n", "outputFormat": "对于每个 $n$，输出一个正整数，表示三角形个数。\n", "hint": "\n", "locale": "zh-CN"}}}
{"pid": "P2808", "type": "P", "difficulty": 5, "samples": [["5\n1 0 1 1 2\n0 2 6 3 4", "20"], ["10\n5 2 7 2 6 5 3 5 3 6\n8 7 8 4 0 6 0 10 10 0", "237"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2013", "JOI（日本）"], "title": "[JOI2014 预选赛] 小笼包", "background": "JOI 同学的午饭，是在中华料理店买的小笼包。这是一种用小麦粉制成的皮包着馅和热汤的料理，吃的时候，热汤会飞溅出来。", "description": "JOI 同学点的小笼包套餐，由馅料不同的 $N$ 个小笼包组成。$N$ 个小笼包等间隔排成一列，编号为 $1$ 到 $N$。第 $i$ 个小笼包与第 $j$ 个小笼包之间的距离是绝对值 $\\vert i-j\\vert$。\n\nJOI 同学按照顺序吃小笼包。最初，所有的小笼包的美味度都是 $0$。吃第 $i$ 个小笼包时，汤汁向周围飞散，与第 $i$ 个小笼包距离 $D_i$ 以下的小笼包都淋上了汤汁，而被淋上汤汁的小笼包的美味度会增加 $A_i$。也就是说，吃第 $i$ 个小笼包的时候，第 $j\\ (1\\le j\\le N$ 并且 $i-D_i\\le j\\le i+D_i)$ 个小笼包还没有吃到的话，第 $j$ 个小笼包的美味度就增加 $A_i$。\n\n ![](https://cdn.luogu.com.cn/upload/pic/2340.png) \n\nJOI 同学要在吃小笼包的顺序上下功夫，让吃的小笼包的美味度的合计最大化。", "inputFormat": "输入共三行。\n\n第一行是一个整数 $N\\ (1\\le N\\le 100)$。\n\n第二行是 $N$ 个整数 $D_1,D_2,\\dots,D_N\\ (0\\le D_i\\le 7)$，以空格分隔。\n\n第三行是 $N$ 个整数 $A_1,A_2,\\dots,A_N\\ (0\\le A_i\\le 1000)$，以空格分隔。", "outputFormat": "共一行，输出 JOI 同学吃的小笼包的美味度的合计最大值。", "hint": "样例 $1$ 的说明：以 $5\\rightarrow 3\\rightarrow 1\\rightarrow 2\\rightarrow 4$ 的顺序吃的话，美味度合计为 $20$。可以证明，美味度超过 $20$ 的吃法不存在。\n\n本题是 2014 年日本信息学奥林匹克（JOI）预选第 6 题。", "locale": "zh-CN", "translations": {"en": {"title": "[JOI2014 Preliminary Round] Xiaolongbao", "background": "JOI’s lunch is xiaolongbao bought at a Chinese restaurant. This dish has a wrapper made from wheat flour enclosing filling and hot soup; when eating, the hot soup may splash.", "description": "The xiaolongbao set that JOI ordered consists of $N$ xiaolongbao with different fillings. The $N$ xiaolongbao are arranged in a row at equal intervals, numbered $1$ to $N$. The distance between the $i$-th and $j$-th xiaolongbao is the absolute value $\\vert i-j\\vert$.\n\nJOI eats the xiaolongbao in some order. Initially, the deliciousness of every xiaolongbao is $0$. When eating the $i$-th xiaolongbao, soup splashes outward; all xiaolongbao whose distance from the $i$-th xiaolongbao is at most $D_i$ are splashed, and each splashed xiaolongbao has its deliciousness increased by $A_i$. That is, when eating the $i$-th xiaolongbao, if the $j\\ (1\\le j\\le N$ and $i-D_i\\le j\\le i+D_i)$-th xiaolongbao has not yet been eaten, then the deliciousness of the $j$-th xiaolongbao increases by $A_i$.\n\n ![](https://cdn.luogu.com.cn/upload/pic/2340.png) \n\nJOI will choose the eating order to maximize the total deliciousness of the xiaolongbao eaten.", "inputFormat": "The input consists of three lines.\n\nThe first line contains an integer $N\\ (1\\le N\\le 100)$.\n\nThe second line contains $N$ integers $D_1,D_2,\\dots,D_N\\ (0\\le D_i\\le 7)$, separated by spaces.\n\nThe third line contains $N$ integers $A_1,A_2,\\dots,A_N\\ (0\\le A_i\\le 1000)$, separated by spaces.", "outputFormat": "Output one line: the maximum possible total deliciousness of the xiaolongbao eaten by JOI.", "hint": "Explanation for Sample $1$: If JOI eats in the order $5\\rightarrow 3\\rightarrow 1\\rightarrow 2\\rightarrow 4$, the total deliciousness is $20$. It can be proven that no eating order yields a total exceeding $20$.\n\nThis problem is Problem $6$ of the 2014 Japanese Olympiad in Informatics (JOI) Preliminary Round.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JOI2014 预选赛] 小笼包", "background": "JOI 同学的午饭，是在中华料理店买的小笼包。这是一种用小麦粉制成的皮包着馅和热汤的料理，吃的时候，热汤会飞溅出来。", "description": "JOI 同学点的小笼包套餐，由馅料不同的 $N$ 个小笼包组成。$N$ 个小笼包等间隔排成一列，编号为 $1$ 到 $N$。第 $i$ 个小笼包与第 $j$ 个小笼包之间的距离是绝对值 $\\vert i-j\\vert$。\n\nJOI 同学按照顺序吃小笼包。最初，所有的小笼包的美味度都是 $0$。吃第 $i$ 个小笼包时，汤汁向周围飞散，与第 $i$ 个小笼包距离 $D_i$ 以下的小笼包都淋上了汤汁，而被淋上汤汁的小笼包的美味度会增加 $A_i$。也就是说，吃第 $i$ 个小笼包的时候，第 $j\\ (1\\le j\\le N$ 并且 $i-D_i\\le j\\le i+D_i)$ 个小笼包还没有吃到的话，第 $j$ 个小笼包的美味度就增加 $A_i$。\n\n ![](https://cdn.luogu.com.cn/upload/pic/2340.png) \n\nJOI 同学要在吃小笼包的顺序上下功夫，让吃的小笼包的美味度的合计最大化。", "inputFormat": "输入共三行。\n\n第一行是一个整数 $N\\ (1\\le N\\le 100)$。\n\n第二行是 $N$ 个整数 $D_1,D_2,\\dots,D_N\\ (0\\le D_i\\le 7)$，以空格分隔。\n\n第三行是 $N$ 个整数 $A_1,A_2,\\dots,A_N\\ (0\\le A_i\\le 1000)$，以空格分隔。", "outputFormat": "共一行，输出 JOI 同学吃的小笼包的美味度的合计最大值。", "hint": "样例 $1$ 的说明：以 $5\\rightarrow 3\\rightarrow 1\\rightarrow 2\\rightarrow 4$ 的顺序吃的话，美味度合计为 $20$。可以证明，美味度超过 $20$ 的吃法不存在。\n\n本题是 2014 年日本信息学奥林匹克（JOI）预选第 6 题。", "locale": "zh-CN"}}}
{"pid": "P2809", "type": "P", "difficulty": 5, "samples": [["7\n5 6 23 8 19 7 10\n4\n5 16 30 27\n7\n1 2 3 4 5 6 7\n5\n7 6 5 5 5\n4\n1 2 3 4\n1\n10\n6\n19 23 3 51 2 0\n2\n34 64", "S\nS\nS\nN"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2016", "福建省历届夏令营", "福建"], "title": "hzwer 爱折纸", "background": null, "description": "hzwer 买到了一张神奇的小纸条，初始时它由 $N$ 个格子组成，每个格子上面有一个整数 $N_i$，显然每两个相邻的格子之间有一条分界线，hzwer 可以选择任意一条分界线，将整张纸条进行向左翻折，如果翻折后有两个格子重叠，那么翻折后的格子上数字为原两个格子数字之和，否则数字保持不变。hzwer 也可以将整张纸条进行向左翻转，翻转之后第 $i$ 个格子的数字变成第 $N - i + 1$ 个格子的数字。\n\n![](https://cdn.luogu.com.cn/upload/pic/2350.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/2351.png)", "inputFormat": "多组数据，最多 $5$ 组，每组数据由四行组成：\n\n第一行包含一个整数 $N$，代表了初始纸条的格子数。\n\n第二行包含 $N$ 个整数，代表了初始时每个格子的值 $N_i$。\n\n第三行包含一个整数 $M$（$M \\le N$），代表了理想纸条的格子数。\n\n第四行包含 $M$ 个整数，代表了理想纸条上每个格子的值 $m_i$。", "outputFormat": "每组数据包含一个字母，`S` 代表可行，`N` 代表不可行。", "hint": "对于 $70 \\%$ 的数据，$N \\le 10$。  \n对于 $100 \\%$ 的数据，$1 \\le N \\le 15$。", "locale": "zh-CN", "translations": {"en": {"title": "hzwer Loves Origami", "background": "", "description": "hzwer bought a magical little paper strip. Initially, it consists of $N$ cells, and each cell has an integer $N_i$ on it. Obviously, there is a dividing line between every two adjacent cells. hzwer can choose any dividing line and fold the entire strip to the left. If two cells overlap after folding, the number on the resulting cell equals the sum of the two original cells; otherwise, the numbers remain unchanged. hzwer can also reverse the entire strip; after reversing, the number of the $i$-th cell becomes the number of the $(N - i + 1)$-th cell.\n\nhzwer wants to obtain an ideal strip with $M$ cells and values $m_i$. Determine whether it is possible to transform the initial strip into the ideal strip by performing the above operations any number of times.\n\n![](https://cdn.luogu.com.cn/upload/pic/2350.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/2351.png)", "inputFormat": "Multiple test cases, at most $5$ groups. Each test case consists of four lines:\n\n- The first line contains an integer $N$, the number of cells in the initial strip.\n- The second line contains $N$ integers, the initial values $N_i$ of each cell.\n- The third line contains an integer $M$ ($M \\le N$), the number of cells in the ideal strip.\n- The fourth line contains $M$ integers, the values $m_i$ on the ideal strip.", "outputFormat": "For each test case, output one letter: `S` means feasible, and `N` means infeasible.", "hint": "For $70\\%$ of the testdata, $N \\le 10$.\nFor $100\\%$ of the testdata, $1 \\le N \\le 15$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "hzwer 爱折纸", "background": null, "description": "hzwer 买到了一张神奇的小纸条，初始时它由 $N$ 个格子组成，每个格子上面有一个整数 $N_i$，显然每两个相邻的格子之间有一条分界线，hzwer 可以选择任意一条分界线，将整张纸条进行向左翻折，如果翻折后有两个格子重叠，那么翻折后的格子上数字为原两个格子数字之和，否则数字保持不变。hzwer 也可以将整张纸条进行向左翻转，翻转之后第 $i$ 个格子的数字变成第 $N - i + 1$ 个格子的数字。\n\n![](https://cdn.luogu.com.cn/upload/pic/2350.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/2351.png)", "inputFormat": "多组数据，最多 $5$ 组，每组数据由四行组成：\n\n第一行包含一个整数 $N$，代表了初始纸条的格子数。\n\n第二行包含 $N$ 个整数，代表了初始时每个格子的值 $N_i$。\n\n第三行包含一个整数 $M$（$M \\le N$），代表了理想纸条的格子数。\n\n第四行包含 $M$ 个整数，代表了理想纸条上每个格子的值 $m_i$。", "outputFormat": "每组数据包含一个字母，`S` 代表可行，`N` 代表不可行。", "hint": "对于 $70 \\%$ 的数据，$N \\le 10$。  \n对于 $100 \\%$ 的数据，$1 \\le N \\le 15$。", "locale": "zh-CN"}}}
{"pid": "P2810", "type": "P", "difficulty": 4, "samples": [["1", "8"], ["8", "54"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["二分"], "title": "Catch the theives", "background": "你们懂的，浙江某高中的保安是非常敬（sui）职（bian）的，但是有一天，一群奶牛（不要问我怎么想的），溜进了校园走进了二食堂，偷吃了可口的饭菜（没尝过）。现在 headmaster 非常生气，让保安严查此事。这时 \\*\\*\\* 走过，勤劳而又严谨的保安求助 \\*\\*\\*，\\*\\*\\* 很忙所以把任务交给了你。要不要来杯咖啡先。", "description": "karlven 听说保安在打游戏值班时看到有 $4$ 只奶牛滚出校门（吃太饱了？），而且这个品种的奶牛非常贪心，而且有秩序。怎么体现？偷吃的时候他们会排队，且后一只偷吃的量是前一只的**整数倍（设为 $k,k>1$）**，按照他的经验估计这些奶牛**最多能吃 $m$ 吨**的食物，一旦**超过就会暴毙**化为灰烬，所以一只奶牛**不会**吃超过 $m$ 吨的食物并且只能**一吨一吨**吃。一旦有一只奶牛无法吃东西，他就会攻击同伴然后自尽。现在 karlven 不告诉你 $m$ 的值，只告诉你奶牛**能够一起偷吃并且一起安全滚出校门**的方案数量 $n$（$n\\le10^{15}$，不要方），请你算出 $m$ 的值，若有多种解，输出**最小的可能值**。如果你怎么算都算不出，就输出 $-1$，然后投诉保安。", "inputFormat": "一个数 $n$。", "outputFormat": "你算出的答案，一个整数。", "hint": "对于 $100\\%$ 的数据，$n\\le10^{15}.$\n\n样例解释：\n\n样例 #1：$(1,2,4,8)$；\n\n样例 #2：$(1,2,4,8),(1,3,9,27),(2,4,8,16),(2,6,18,54),(3,6,12,24),(4,8,16,32),(5,10,20,40),(6,12,24,48).$", "locale": "zh-CN", "translations": {"en": {"title": "Catch the Thieves", "background": "You know this: the security guards at a certain high school in Zhejiang are very diligent (sui) and meticulous (bian). But one day, a herd of cows (don’t ask me why) slipped into the campus and walked into the second cafeteria, stealing tasty dishes (never tried them). Now the headmaster is very angry and ordered the guards to investigate strictly. At this moment, *** walked by, and the hardworking and rigorous guards asked *** for help. *** was busy and handed the task to you. How about a cup of coffee first.", "description": "karlven heard that while the guards were on duty playing games, they saw $4$ cows rolling out of the school gate (ate too much?). This breed of cow is very greedy and also orderly. How is that reflected? When stealing food they line up, and the amount eaten by each later cow is an **integer multiple (denote as $k$, $k>1$)** of the previous cow’s amount. Based on his experience, these cows can **eat at most $m$ tons** of food; once they **exceed it, they die** and turn to ashes. Therefore, a cow **will not** eat more than $m$ tons, and can only eat **one ton at a time**. If any cow cannot eat its required amount, it will attack its companion and then commit suicide.\n\nNow karlven does not tell you the value of $m$, and only tells you the number $n$ ($n \\le 10^{15}$) of schemes in which the cows **can steal together and roll out safely together**. Please compute the value of $m$. If there are multiple answers, output the **smallest possible value**. If you cannot find any such $m$, output $-1$ and then file a complaint against the guards.", "inputFormat": "A single integer $n$.", "outputFormat": "Your computed answer, a single integer.", "hint": "Constraints: For $100\\%$ of the testdata, $n \\le 10^{15}$.\n\nSample explanation:\n\nSample #1: (1, 2, 4, 8).\n\nSample #2: (1, 2, 4, 8), (1, 3, 9, 27), (2, 4, 8, 16), (2, 6, 18, 54), (3, 6, 12, 24), (4, 8, 16, 32), (5, 10, 20, 40), (6, 12, 24, 48).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Catch the theives", "background": "你们懂的，浙江某高中的保安是非常敬（sui）职（bian）的，但是有一天，一群奶牛（不要问我怎么想的），溜进了校园走进了二食堂，偷吃了可口的饭菜（没尝过）。现在 headmaster 非常生气，让保安严查此事。这时 \\*\\*\\* 走过，勤劳而又严谨的保安求助 \\*\\*\\*，\\*\\*\\* 很忙所以把任务交给了你。要不要来杯咖啡先。", "description": "karlven 听说保安在打游戏值班时看到有 $4$ 只奶牛滚出校门（吃太饱了？），而且这个品种的奶牛非常贪心，而且有秩序。怎么体现？偷吃的时候他们会排队，且后一只偷吃的量是前一只的**整数倍（设为 $k,k>1$）**，按照他的经验估计这些奶牛**最多能吃 $m$ 吨**的食物，一旦**超过就会暴毙**化为灰烬，所以一只奶牛**不会**吃超过 $m$ 吨的食物并且只能**一吨一吨**吃。一旦有一只奶牛无法吃东西，他就会攻击同伴然后自尽。现在 karlven 不告诉你 $m$ 的值，只告诉你奶牛**能够一起偷吃并且一起安全滚出校门**的方案数量 $n$（$n\\le10^{15}$，不要方），请你算出 $m$ 的值，若有多种解，输出**最小的可能值**。如果你怎么算都算不出，就输出 $-1$，然后投诉保安。", "inputFormat": "一个数 $n$。", "outputFormat": "你算出的答案，一个整数。", "hint": "对于 $100\\%$ 的数据，$n\\le10^{15}.$\n\n样例解释：\n\n样例 #1：$(1,2,4,8)$；\n\n样例 #2：$(1,2,4,8),(1,3,9,27),(2,4,8,16),(2,6,18,54),(3,6,12,24),(4,8,16,32),(5,10,20,40),(6,12,24,48).$", "locale": "zh-CN"}}}
{"pid": "P2811", "type": "P", "difficulty": 5, "samples": [["5\n31619 26195 18669 1198 178\n4\n2 4\n3 5\n1 2\n4 1", "20045 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论"], "title": "Protect the school", "background": "话说上回保安因为奶牛事件而搞得地位岌岌可危，所以他们决定好好看守这个学校，他们有一个计划。但是由于学校太大了，他们计划不好，所以找到上次帮他的你，请你解决他的苦难。然后他又可以开始了手机游戏之旅。\n", "description": "学校有 $n$ 个检查点，由于保安懒得动脑筋，他们决定在这 $n$ 个检查点之间建立 $m$ 条通道，由于学校的懒政以及军事化管理，这些路是单向的，逆向通过会被处分。保安们人手不够（游戏任务太多），他们决定只挑选一些点来站岗，由于保安身怀绝技，可以瞬间通过任何他站岗点可以走到的路（瞬移到到任何连通的点）。每一个检查点有一个值表示这个点的困难程度。为了保护学校，请你帮他们出个主意，保证一旦有一个检查点发生事件，都能有保安瞬间抵达。但是为了舒服和管理便利，请你告诉他们在使用最少的保安数量的情况下最小的困难总和。\n", "inputFormat": "第一行一个整数 $n$，代表检查点数量。\n\n接下来一行 $n$ 个整数，代表困难程度。\n\n接下来一行一个数 $m$，表示道路的数量。\n\n接下来 $m$ 行每行两个整数 $u,v$ 代表 $u$ 到 $v$ 有一条单向通道。", "outputFormat": "两个整数。\n\n第一个整数表示最小困难和。第二个整数表示在保证最小困难和以及最少保安数量的条件下，可选的方案总数。\n", "hint": "$1 \\le n \\le 10 ^ 4,1 \\le m \\le 5 \\times 10 ^ 4$，保证答案在 `int` 范围内。", "locale": "zh-CN", "translations": {"en": {"title": "Protect the school", "background": "Last time, the security staff’s status was on the line because of the cow incident. They decided to guard the school properly this time, and they have a plan. But since the campus is too large, they cannot plan it well, so they come to you again for help. Please solve their problem so they can resume their mobile gaming journey.", "description": "The school has $n$ checkpoints. Because the guards do not want to think too hard, they decide to build $m$ passages between these $n$ checkpoints. Due to lax administration and militarized management, these roads are one-way; going in the reverse direction will result in punishment.\n\nThe guards are short-handed (too many game quests), so they will select some checkpoints to stand guard. Since the guards have special skills, a guard can instantly traverse along any path reachable from the checkpoint where he is stationed (i.e., teleport to any vertex reachable via directed edges). Each checkpoint has a value representing its difficulty.\n\nTo protect the school, please help them ensure that if an incident occurs at any checkpoint, at least one guard can instantly reach it. For convenience and easier management, tell them the minimum possible total difficulty under the constraint of using the fewest number of guards.", "inputFormat": "The first line contains an integer $n$, the number of checkpoints.\n\nThe second line contains $n$ integers, the difficulties of the checkpoints.\n\nThe third line contains an integer $m$, the number of roads.\n\nEach of the next $m$ lines contains two integers $u, v$, indicating a one-way passage from $u$ to $v$.", "outputFormat": "Output two integers.\n\nThe first integer is the minimum total difficulty. The second integer is the number of valid selections that achieve both the minimum number of guards and that minimum total difficulty.", "hint": "$1 \\le n \\le 10^4$, $1 \\le m \\le 5 \\times 10^4$, and the answer fits in the int range.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Protect the school", "background": "话说上回保安因为奶牛事件而搞得地位岌岌可危，所以他们决定好好看守这个学校，他们有一个计划。但是由于学校太大了，他们计划不好，所以找到上次帮他的你，请你解决他的苦难。然后他又可以开始了手机游戏之旅。\n", "description": "学校有 $n$ 个检查点，由于保安懒得动脑筋，他们决定在这 $n$ 个检查点之间建立 $m$ 条通道，由于学校的懒政以及军事化管理，这些路是单向的，逆向通过会被处分。保安们人手不够（游戏任务太多），他们决定只挑选一些点来站岗，由于保安身怀绝技，可以瞬间通过任何他站岗点可以走到的路（瞬移到到任何连通的点）。每一个检查点有一个值表示这个点的困难程度。为了保护学校，请你帮他们出个主意，保证一旦有一个检查点发生事件，都能有保安瞬间抵达。但是为了舒服和管理便利，请你告诉他们在使用最少的保安数量的情况下最小的困难总和。\n", "inputFormat": "第一行一个整数 $n$，代表检查点数量。\n\n接下来一行 $n$ 个整数，代表困难程度。\n\n接下来一行一个数 $m$，表示道路的数量。\n\n接下来 $m$ 行每行两个整数 $u,v$ 代表 $u$ 到 $v$ 有一条单向通道。", "outputFormat": "两个整数。\n\n第一个整数表示最小困难和。第二个整数表示在保证最小困难和以及最少保安数量的条件下，可选的方案总数。\n", "hint": "$1 \\le n \\le 10 ^ 4,1 \\le m \\le 5 \\times 10 ^ 4$，保证答案在 `int` 范围内。", "locale": "zh-CN"}}}
{"pid": "P2812", "type": "P", "difficulty": 5, "samples": [["5\n2 0\n4 0\n5 0\n1 0\n0\n", "2\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "强连通分量"], "title": "校园网络【[USACO]Network of Schools加强版】", "background": "浙江省的几所 OI 强校的神犇发明了一种人工智能，可以 AC 任何题目，所以他们决定建立一个网络来共享这个软件。但是由于他们脑力劳动过多导致全身无力身体被♂掏♂空，他们来找你帮助他们。\n", "description": "共有 $n$ 所学校 $(1 \\leq n \\leq 10000)$ 已知他们实现设计好的网络共 $m$ 条线路，为了保证高速，网络是单向的。现在请你告诉他们至少选几所学校作为共享软件的母机，能使每所学校都可以用上。再告诉他们至少要添加几条线路能使任意一所学校作为母机都可以使别的学校使用上软件。\n", "inputFormat": "第一行一个正整数 $n$。\n\n接下来 $n$ 行每行有若干个整数，用空格隔开。\n\n第 $i+1$ 行，每行输入若干个非零整数 $x$，表示从 $i$ 到 $x$ 有一条线路。以 $0$ 作为结束标志。\n", "outputFormat": "第一行一个整数，表示至少选几所学校作为共享软件的母机，能使每所学校都可以用上。\n\n第二行一个整数，表示至少要添加几条线路能使任意一所学校作为母机都可以使别的学校使用上软件。", "hint": "~~POJ 原题。数据扩大了 $100$ 倍。~~\n\n~~$1 \\leq $ 边数 $\\leq 5000000$，$1 \\leq n \\leq 10000$ 。~~\n\n实际上，$1 \\leq n \\leq 10000$，$1\\le $ 边数 $\\le 50000$。", "locale": "zh-CN", "translations": {"en": {"title": "Campus Network [USACO] Network of Schools Enhanced Version", "background": "Several OI powerhouse schools in Zhejiang have shen niu (pinyin: shén niú) who invented an artificial intelligence that can AC any problem, so they decided to build a network to share this software. However, due to excessive brainwork, they are completely drained and have come to you for help.", "description": "There are $n$ schools ($1 \\leq n \\leq 10000$). It is known that in their designed network there are $m$ edges. To ensure high speed, the network is directed. Please tell them the minimum number of schools to select as servers (“mother machines”) so that every school can use the software. Then tell them the minimum number of edges to add so that choosing any single school as the server will allow every other school to use the software.", "inputFormat": "The first line contains a positive integer $n$.\n\nThe next $n$ lines each contain several integers separated by spaces.\n\nOn the $(i+1)$-th line, several non-zero integers $x$ are given, indicating that there is a directed edge from $i$ to $x$. The line ends with a terminating $0$.", "outputFormat": "The first line contains an integer, the minimum number of schools to select as servers so that every school can use the software.\n\nThe second line contains an integer, the minimum number of edges to add so that choosing any school as the server will allow every other school to use the software.", "hint": "~~POJ original. The testdata has been enlarged by $100$ times.~~\n\n~~$1 \\leq n \\leq 10000$, $1 \\leq m \\leq 5000000$.~~\n\nIn fact, $1 \\leq n \\leq 10000$, $1 \\leq m \\leq 50000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "校园网络【[USACO]Network of Schools加强版】", "background": "浙江省的几所 OI 强校的神犇发明了一种人工智能，可以 AC 任何题目，所以他们决定建立一个网络来共享这个软件。但是由于他们脑力劳动过多导致全身无力身体被♂掏♂空，他们来找你帮助他们。\n", "description": "共有 $n$ 所学校 $(1 \\leq n \\leq 10000)$ 已知他们实现设计好的网络共 $m$ 条线路，为了保证高速，网络是单向的。现在请你告诉他们至少选几所学校作为共享软件的母机，能使每所学校都可以用上。再告诉他们至少要添加几条线路能使任意一所学校作为母机都可以使别的学校使用上软件。\n", "inputFormat": "第一行一个正整数 $n$。\n\n接下来 $n$ 行每行有若干个整数，用空格隔开。\n\n第 $i+1$ 行，每行输入若干个非零整数 $x$，表示从 $i$ 到 $x$ 有一条线路。以 $0$ 作为结束标志。\n", "outputFormat": "第一行一个整数，表示至少选几所学校作为共享软件的母机，能使每所学校都可以用上。\n\n第二行一个整数，表示至少要添加几条线路能使任意一所学校作为母机都可以使别的学校使用上软件。", "hint": "~~POJ 原题。数据扩大了 $100$ 倍。~~\n\n~~$1 \\leq $ 边数 $\\leq 5000000$，$1 \\leq n \\leq 10000$ 。~~\n\n实际上，$1 \\leq n \\leq 10000$，$1\\le $ 边数 $\\le 50000$。", "locale": "zh-CN"}}}
{"pid": "P2813", "type": "P", "difficulty": 2, "samples": [["3 5 \n1000 \n2000 \n1200 \n2100 \n2000 \n1200 \n1000 \n1000", "2000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "广东", "排序"], "title": "母舰", "background": "广东汕头聿怀初中 Train#3 Problem 1\n\n（有没有红警既视感~）\n", "description": "在小 A 的星际大战游戏中，一艘强力的母舰往往决定了一场战争的胜负。一艘母舰的攻击力是普通的 MA（Mobile Armor）无法比较的。\n\n对于一艘母舰而言，它是由若干个攻击系统和若干个防御系统组成的。两艘母舰对决时，一艘母舰会选择用不同的攻击系统去攻击对面母舰的防御系统。当这个攻击系统的攻击力大于防御系统的防御力时，那个防御系统会被破坏掉。当一艘母舰的防御系统全部被破坏掉之后，所有的攻击都会攻击到敌方母舰本身上去造成伤害。\n\n这样说，一艘母舰对对面的伤害在一定程度上是取决于选择的攻击对象的。\n\n在瞬息万变的战场中，选择一个最优的攻击对象是非常重要的。所以需要写出一个战斗系统出来，判断出你的母舰最多能对对手造成多少伤害并加以实现。\n", "inputFormat": "输入第一行两个整数 $M$ 和 $N$，表示对方母舰的防御系统数量和你的母舰的攻击系统数量。\n\n接着 $M$ 行每行一个整数每一个表示对方防御系统的防御力是多少。\n\n接着 $N$ 行每行一个整数每一个表示己方攻击系统的攻击力是多少。", "outputFormat": "输出仅有一行，表示可以造成的最大伤害。\n", "hint": "#### 样例解释 #1\n\n对方防御系统有 $3$ 个，防御值为 $1000(a),2000(b),1200(c)$，己方攻击系统有 $5$ 个，攻击值为 $2100(d)，2000(e),1200(f),1000(g),1000(h)$。第 $1$ 轮攻击的最优方案是 $d$ 攻击 $b$，$e$ 攻击 $c$，$f$ 攻击 $a$，$g$ 和 $h$ 攻击对方母舰本身，造成 $2000$ 点伤害。\n\n#### 数据范围与约定\n\n对于 $80 \\%$ 的数据，$1 \\le N,M \\le 1000$。\n\n对于 $100 \\%$ 的数据，$1 \\le N,M \\le 10 ^ 5$。\n\n\n本题为转载题目。", "locale": "zh-CN", "translations": {"en": {"title": "Mothership", "background": "Guangdong Shantou Yuhuai Junior High School Train#3 Problem 1.\n\n(Does this give a Red Alert vibe?)", "description": "In player A’s space war game, a powerful mothership often decides the outcome of a war. The attack power of a mothership cannot be matched by ordinary MAs (Mobile Armor).\n\nA mothership consists of several attack systems and several defense systems. When two motherships duel, one mothership will choose different attack systems to attack the opponent’s defense systems. If the attack power of an attack system is greater than the defense power of a defense system, that defense system will be destroyed. After all defense systems of a mothership have been destroyed, all remaining attacks will hit the enemy mothership itself and deal damage.\n\nIn other words, the damage a mothership deals to the opponent depends, to some extent, on how you choose targets.\n\nOn a rapidly changing battlefield, choosing optimal targets is crucial. Therefore, you need to implement a battle system to determine the maximum damage your mothership can deal to the opponent.", "inputFormat": "The first line contains two integers $M$ and $N$, the number of the opponent’s defense systems and the number of your mothership’s attack systems.\n\nThen follow $M$ lines, each with one integer, representing the defense power of each opponent defense system.\n\nThen follow $N$ lines, each with one integer, representing the attack power of each of your attack systems.", "outputFormat": "Output a single line with the maximum damage that can be dealt.", "hint": "#### Sample Explanation #1\n\nThe opponent has $3$ defense systems with defense values $1000(a),2000(b),1200(c)$, and you have $5$ attack systems with attack values $2100(d),2000(e),1200(f),1000(g),1000(h)$. An optimal plan for the first round is: $d$ attacks $b$, $e$ attacks $c$, $f$ attacks $a$, and $g$ and $h$ attack the enemy mothership itself, dealing $2000$ damage.\n\n#### Constraints\n\nFor $80 \\%$ of the testdata, $1 \\le N,M \\le 1000$.\n\nFor $100 \\%$ of the testdata, $1 \\le N,M \\le 10 ^ 5$.\n\nThis problem is a reposted problem.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "母舰", "background": "广东汕头聿怀初中 Train#3 Problem 1\n\n（有没有红警既视感~）\n", "description": "在小 A 的星际大战游戏中，一艘强力的母舰往往决定了一场战争的胜负。一艘母舰的攻击力是普通的 MA（Mobile Armor）无法比较的。\n\n对于一艘母舰而言，它是由若干个攻击系统和若干个防御系统组成的。两艘母舰对决时，一艘母舰会选择用不同的攻击系统去攻击对面母舰的防御系统。当这个攻击系统的攻击力大于防御系统的防御力时，那个防御系统会被破坏掉。当一艘母舰的防御系统全部被破坏掉之后，所有的攻击都会攻击到敌方母舰本身上去造成伤害。\n\n这样说，一艘母舰对对面的伤害在一定程度上是取决于选择的攻击对象的。\n\n在瞬息万变的战场中，选择一个最优的攻击对象是非常重要的。所以需要写出一个战斗系统出来，判断出你的母舰最多能对对手造成多少伤害并加以实现。\n", "inputFormat": "输入第一行两个整数 $M$ 和 $N$，表示对方母舰的防御系统数量和你的母舰的攻击系统数量。\n\n接着 $M$ 行每行一个整数每一个表示对方防御系统的防御力是多少。\n\n接着 $N$ 行每行一个整数每一个表示己方攻击系统的攻击力是多少。", "outputFormat": "输出仅有一行，表示可以造成的最大伤害。\n", "hint": "#### 样例解释 #1\n\n对方防御系统有 $3$ 个，防御值为 $1000(a),2000(b),1200(c)$，己方攻击系统有 $5$ 个，攻击值为 $2100(d)，2000(e),1200(f),1000(g),1000(h)$。第 $1$ 轮攻击的最优方案是 $d$ 攻击 $b$，$e$ 攻击 $c$，$f$ 攻击 $a$，$g$ 和 $h$ 攻击对方母舰本身，造成 $2000$ 点伤害。\n\n#### 数据范围与约定\n\n对于 $80 \\%$ 的数据，$1 \\le N,M \\le 1000$。\n\n对于 $100 \\%$ 的数据，$1 \\le N,M \\le 10 ^ 5$。\n\n\n本题为转载题目。", "locale": "zh-CN"}}}
{"pid": "P2814", "type": "P", "difficulty": 3, "samples": [["#George\n+Rodney\n#Arthur\n+Gareth\n+Walter\n#Gareth\n+Edward\n?Edward\n?Walter\n?Rodney\n?Arthur\n$", "Edward Arthur\nWalter Arthur\nRodney George\nArthur Arthur"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "搜索", "图论", "线性数据结构", "并查集", "树的遍历"], "title": "家谱", "background": "现代的人对于本家族血统越来越感兴趣。\n", "description": "给出充足的父子关系，请你编写程序找到某个人的最早的祖先。\n", "inputFormat": "输入由多行组成，首先是一系列有关父子关系的描述，其中每一组父子关系中父亲只有一行，儿子可能有若干行，用 `#name` 的形式描写一组父子关系中的父亲的名字，用 `+name` 的形式描写一组父子关系中的儿子的名字；接下来用 `?name` 的形式表示要求该人的最早的祖先；最后用单独的一个 `$` 表示文件结束。", "outputFormat": "按照输入文件的要求顺序，求出每一个要找祖先的人的祖先，格式为：本人的名字 $+$ 一个空格 $+$ 祖先的名字 $+$ 回车。", "hint": "规定每个人的名字都有且只有 $6$ 个字符，而且首字母大写，且没有任意两个人的名字相同。最多可能有 $10^3$ 组父子关系，总人数最多可能达到 $5 \\times 10^4$ 人，家谱中的记载不超过 $30$ 代。", "locale": "zh-CN", "translations": {"en": {"title": "Genealogy", "background": "People today are increasingly interested in their own family lineage.", "description": "Given sufficient father–son relationships, write a program to find a person’s earliest ancestor.", "inputFormat": "The input consists of multiple lines. First comes a series of descriptions of father–son relationships. In each group, the father appears on exactly one line written as `#name`, and the sons appear on zero or more lines written as `+name`. After that, lines written as `?name` indicate queries asking for that person’s earliest ancestor. Finally, a single `$` on its own line marks the end of file.", "outputFormat": "For each query, in the order they appear in the input, output the person’s earliest ancestor in the format: the person’s name $+$ a space $+$ the ancestor’s name $+$ a newline.", "hint": "Each person’s name has exactly $6$ characters, the first letter is uppercase, and no two people share the same name. There can be at most $10^3$ groups of father–son relationships, the total number of people can be up to $5 \\times 10^4$, and the genealogy records do not exceed $30$ generations.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "家谱", "background": "现代的人对于本家族血统越来越感兴趣。\n", "description": "给出充足的父子关系，请你编写程序找到某个人的最早的祖先。\n", "inputFormat": "输入由多行组成，首先是一系列有关父子关系的描述，其中每一组父子关系中父亲只有一行，儿子可能有若干行，用 `#name` 的形式描写一组父子关系中的父亲的名字，用 `+name` 的形式描写一组父子关系中的儿子的名字；接下来用 `?name` 的形式表示要求该人的最早的祖先；最后用单独的一个 `$` 表示文件结束。", "outputFormat": "按照输入文件的要求顺序，求出每一个要找祖先的人的祖先，格式为：本人的名字 $+$ 一个空格 $+$ 祖先的名字 $+$ 回车。", "hint": "规定每个人的名字都有且只有 $6$ 个字符，而且首字母大写，且没有任意两个人的名字相同。最多可能有 $10^3$ 组父子关系，总人数最多可能达到 $5 \\times 10^4$ 人，家谱中的记载不超过 $30$ 代。", "locale": "zh-CN"}}}
{"pid": "P2815", "type": "P", "difficulty": 3, "samples": [["2406:0840:f990:0000:0000:0000:0000:0001", "2406:840:f990::1"], ["2a13:1801:018a:00cf:0100:0000:0000:0000", "2a13:1801:18a:cf:100::"], ["2001:4860:4860:0000:0000:0000:0000:8888", "2001:4860:4860::8888"], ["2001:0db8:0000:0000:0000:0000:0000:0001", "2001:db8::1"], ["0000:0000:0000:0000:0000:0000:0000:0000", "::"], ["0000:0000:0000:0000:0000:0000:0000:0001", "::1"], ["2001:0db8:ffff:0000:0123:4567:89ab:cdef", "2001:db8:ffff::123:4567:89ab:cdef"], ["1234:5678:9abc:def0:1234:5678:9abc:def0", "1234:5678:9abc:def0:1234:5678:9abc:def0"], ["0001:0000:0000:0000:0000:0000:0000:0001", "1::1"], ["0000:0000:0000:0000:0000:0000:0001:0002", "::1:2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串"], "title": "IPv6地址压缩", "background": "（友情提示：IPv6 基础知识曾多次出现在 NOIP 初赛中）Internet Protocol，互联网协议，即为我们常说的 IP。我们目前常说的 IP 主要指它的第四版，即 IPv4，它由 IETF 于 1981 年发布。它的地址长度是 $32$ 个二进制位，因此也就有 $2^{32}$ 个 IP 地址可供使用，约为 $43$ 亿，在当时，谁也没有料想到 IPv4 如此庞大的地址长度会有用完的一天。\n\n在 21 世纪的今天，互联网的蓬勃发展早就了我们如今便利的生活。当下，世界人口已超过 70 亿，计算机和各种联网设备已经走入千家万户，而不再仅是上个世纪 80 年代科学家们的工具。此时便出现了人们日益增长的联网设备需要同落后 IPv4 地址长度之间的矛盾。尽管可以通过网络地址翻译能技术来共享 IP 地址，临时解决枯竭的问题，但显然不是长久之计。\n\nIETF 也有先见之明，早早地于 1998 年发布了 IPv6 协议，从微软 2006 年发布的 Windows Vista 开始成为默认安装的网络协议。作为 IPv4 的继任者，它的地址长度为 $128$ 个二进制位，也就是 $2^{128}$ 个IP地址可供使用。然而面对这冗长的地址，一位记忆力不好的网络工程师小明在配置路由表时遇到了许许多多多的困难，现在他找到了你，希望你帮忙编写一个程序来按照 IPv6 地址标准的格式压缩规则来压缩 IPv6 地址。", "description": "**【IPv6 格式】**\n\nIPv6 二进位制下为 $128$ 位长度，以 $16$ 位为一组，每组以冒号“`:`”隔开，可以分为 $8$ 组，每组以 $4$ 位十六进制方式表示。\n\n比如 `2001:0db8:0000:0000:0123:4567:89ab:cdef` 是一个合法的 IPv6 地址。\n\n同时 IPv6 地址在某些条件下可以压缩：\n\n1. 每组数字代表的独立十六进制数可以省略前位的 `0`。\n\n比如上面的 IPv6 地址可被压缩为 `2001:db8:0:0:123:4567:89ab:cdef`。\n\n2. 可以用双冒号 `::` 表示一组 `0` 或多组连续的 `0`，但只能出现一次。\n\n比如上面的 IPv6 地址可被压缩为 `2001:db8::123:4567:89ab:cdef`。\n\n请你帮助记忆力不好的网络工程师小明解决他遇到的问题。\n\n**【规则补充】**\n\n1. 输入数据为完全展开的 IPv6 地址，确保输入的 IPv6 地址不含双冒号，每组地址省略的 `0` 都会被补充上去。\n\n2. 双冒号只能使用一次，因此我们压缩最长的全 `0` 组。\n\n比如 `2001:0db8:0000:0000:1:0000:0000:0000`，压缩为 `2001:db8:0:0:1::`，而非 `2001:db8::1:0:0:0`。\n\n3. 双冒号只能使用一次，因此我们在我们遇到地址中多个连续全 `0` 组长度相同时，我们压缩最前面的一个。\n\n比如 `2001:0db8:0000:0000:ffff:0000:0000:1`，压缩为 `2001:db8::ffff:0:0:1`，而非 `2001:db8:0:0:ffff::1`。\n\n4. 输入的 IPv6 地址可能无法被压缩，此时请照原样输出。\n\n提示：本题所示的压缩规则与 macOS (Darwin) 默认的 IPv6 地址显示方式相同，而 Windows 和 Linux 只遇到一组全 `0` 时不会使用 `::` 进行压缩。但用此方法压缩过的 IPv6 地址一样可以被 Windows 和 Linux 正确识别。\n\n比如 `2001:0db8:ffff:0000:0123:4567:89ab:cdef`，Darwin 压缩为 `2001:db8:ffff::123:4567:89ab:cdef`，而 Linux 和 Windows 压缩为 `2001:db8:ffff:0:123:4567:89ab:cdef`。", "inputFormat": "一串 $39$ 个字符的字符串，代表一个完全展开的 IPv6 地址。", "outputFormat": "一串压缩后的 IPv6 地址。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "IPv6 Address Compression", "background": "(Friendly note: IPv6 basics have appeared many times in the NOIP preliminary contest.) Internet Protocol, the protocol of the Internet, is what we usually call IP. What we most often refer to is its fourth version, IPv4, which was released by IETF in 1981. Its address length is $32$ binary bits, so there are $2^{32}$ IP addresses available, about $4.3$ billion. At that time, no one expected that even such a large IPv4 address space would one day run out.\n\nIn the 21st century, the rapid development of the Internet has brought us a convenient life. Today, the world’s population has exceeded $7$ billion. Computers and various networked devices have entered thousands of households, no longer just the tools of scientists in the 1980s. This has created a conflict between the growing number of networked devices and the limited IPv4 address space. Although Network Address Translation (NAT) can be used to share IP addresses and temporarily alleviate the exhaustion problem, it is obviously not a long-term solution.\n\nIETF was forward-looking and released the IPv6 protocol as early as 1998. Starting with Microsoft’s Windows Vista in 2006, it became a default-installed network protocol. As the successor to IPv4, its address length is $128$ binary bits, that is, $2^{128}$ IP addresses are available. However, faced with such lengthy addresses, a network engineer named Xiaoming, who has a poor memory, encountered many difficulties when configuring routing tables. He has come to you, hoping you can write a program to compress IPv6 addresses according to the standard IPv6 formatting rules.", "description": "[IPv6 Format]\n\nIn binary, an IPv6 address is $128$ bits long. It is divided into groups of $16$ bits, separated by colons “:”, making $8$ groups in total. Each group is written as a 4-digit hexadecimal number.\n\nFor example, `2001:0db8:0000:0000:0123:4567:89ab:cdef` is a valid IPv6 address.\n\nIPv6 addresses can be compressed under certain conditions:\n\n1. Leading zeros in each group can be omitted.\n\nFor example, the address above can be compressed to `2001:db8:0:0:123:4567:89ab:cdef`.\n\n2. A double colon `::` can represent one or more consecutive groups of `0`, but it can only appear once.\n\nFor example, the address above can be compressed to `2001:db8::123:4567:89ab:cdef`.\n\nPlease help the forgetful network engineer Xiaoming solve his problem.\n\n[Supplementary Rules]\n\n1. The input is a fully expanded IPv6 address. It is guaranteed that the input IPv6 address contains no double colon, and that any omitted zeros in each group have been filled.\n\n2. Since `::` can be used only once, compress the longest run of all-zero groups.\n\nFor example, `2001:0db8:0000:0000:1:0000:0000:0000` is compressed to `2001:db8:0:0:1::`, not `2001:db8::1:0:0:0`.\n\n3. Since `::` can be used only once, if there are multiple runs of all-zero groups with the same maximum length, compress the earliest one.\n\nFor example, `2001:0db8:0000:0000:ffff:0000:0000:1` is compressed to `2001:db8::ffff:0:0:1`, not `2001:db8:0:0:ffff::1`.\n\n4. The input IPv6 address may not be compressible. In that case, output it as-is.\n\nTip: The compression rules shown in this problem match the default IPv6 display style on macOS (Darwin), whereas Windows and Linux do not use `::` when there is only a single all-zero group. However, IPv6 addresses compressed in this way can still be correctly recognized by Windows and Linux.\n\nFor example, `2001:0db8:ffff:0000:0123:4567:89ab:cdef` is compressed by Darwin as `2001:db8:ffff::123:4567:89ab:cdef`, while Linux and Windows compress it as `2001:db8:ffff:0:123:4567:89ab:cdef`.", "inputFormat": "A string of $39$ characters representing a fully expanded IPv6 address.", "outputFormat": "A string representing the compressed IPv6 address.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "IPv6地址压缩", "background": "（友情提示：IPv6 基础知识曾多次出现在 NOIP 初赛中）Internet Protocol，互联网协议，即为我们常说的 IP。我们目前常说的 IP 主要指它的第四版，即 IPv4，它由 IETF 于 1981 年发布。它的地址长度是 $32$ 个二进制位，因此也就有 $2^{32}$ 个 IP 地址可供使用，约为 $43$ 亿，在当时，谁也没有料想到 IPv4 如此庞大的地址长度会有用完的一天。\n\n在 21 世纪的今天，互联网的蓬勃发展早就了我们如今便利的生活。当下，世界人口已超过 70 亿，计算机和各种联网设备已经走入千家万户，而不再仅是上个世纪 80 年代科学家们的工具。此时便出现了人们日益增长的联网设备需要同落后 IPv4 地址长度之间的矛盾。尽管可以通过网络地址翻译能技术来共享 IP 地址，临时解决枯竭的问题，但显然不是长久之计。\n\nIETF 也有先见之明，早早地于 1998 年发布了 IPv6 协议，从微软 2006 年发布的 Windows Vista 开始成为默认安装的网络协议。作为 IPv4 的继任者，它的地址长度为 $128$ 个二进制位，也就是 $2^{128}$ 个IP地址可供使用。然而面对这冗长的地址，一位记忆力不好的网络工程师小明在配置路由表时遇到了许许多多多的困难，现在他找到了你，希望你帮忙编写一个程序来按照 IPv6 地址标准的格式压缩规则来压缩 IPv6 地址。", "description": "**【IPv6 格式】**\n\nIPv6 二进位制下为 $128$ 位长度，以 $16$ 位为一组，每组以冒号“`:`”隔开，可以分为 $8$ 组，每组以 $4$ 位十六进制方式表示。\n\n比如 `2001:0db8:0000:0000:0123:4567:89ab:cdef` 是一个合法的 IPv6 地址。\n\n同时 IPv6 地址在某些条件下可以压缩：\n\n1. 每组数字代表的独立十六进制数可以省略前位的 `0`。\n\n比如上面的 IPv6 地址可被压缩为 `2001:db8:0:0:123:4567:89ab:cdef`。\n\n2. 可以用双冒号 `::` 表示一组 `0` 或多组连续的 `0`，但只能出现一次。\n\n比如上面的 IPv6 地址可被压缩为 `2001:db8::123:4567:89ab:cdef`。\n\n请你帮助记忆力不好的网络工程师小明解决他遇到的问题。\n\n**【规则补充】**\n\n1. 输入数据为完全展开的 IPv6 地址，确保输入的 IPv6 地址不含双冒号，每组地址省略的 `0` 都会被补充上去。\n\n2. 双冒号只能使用一次，因此我们压缩最长的全 `0` 组。\n\n比如 `2001:0db8:0000:0000:1:0000:0000:0000`，压缩为 `2001:db8:0:0:1::`，而非 `2001:db8::1:0:0:0`。\n\n3. 双冒号只能使用一次，因此我们在我们遇到地址中多个连续全 `0` 组长度相同时，我们压缩最前面的一个。\n\n比如 `2001:0db8:0000:0000:ffff:0000:0000:1`，压缩为 `2001:db8::ffff:0:0:1`，而非 `2001:db8:0:0:ffff::1`。\n\n4. 输入的 IPv6 地址可能无法被压缩，此时请照原样输出。\n\n提示：本题所示的压缩规则与 macOS (Darwin) 默认的 IPv6 地址显示方式相同，而 Windows 和 Linux 只遇到一组全 `0` 时不会使用 `::` 进行压缩。但用此方法压缩过的 IPv6 地址一样可以被 Windows 和 Linux 正确识别。\n\n比如 `2001:0db8:ffff:0000:0123:4567:89ab:cdef`，Darwin 压缩为 `2001:db8:ffff::123:4567:89ab:cdef`，而 Linux 和 Windows 压缩为 `2001:db8:ffff:0:123:4567:89ab:cdef`。", "inputFormat": "一串 $39$ 个字符的字符串，代表一个完全展开的 IPv6 地址。", "outputFormat": "一串压缩后的 IPv6 地址。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2816", "type": "P", "difficulty": 2, "samples": [["3\n0 0 3\n", "2"], ["4\n0 0 0 0\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "山东"], "title": "宋荣子搭积木", "background": "", "description": "saruka 非常喜欢搭积木，他一共有 $n$ 块积木。而且 saruka 的积木很特殊，只能一块块的竖着摞，可以摞很多列。说过 saruka 的是特殊的积木了，这些积木都非常智能，第 $i$ 块积木有一个情绪值 $x_i$ ，当摞在这块积木上的积木总数超过 $x_i$ 时，这块积木就会很不高兴，发誓以后不会再和 saruka 一起玩耍了。saruka 这么爱玩积木，肯定不会让积木不高兴的，但是 saruka 又希望每块积木都被用上，并且摞的积木列数最少。你能来帮帮 saruka 吗?", "inputFormat": "第一行一个整数 $n$，含义如题目描述所示，\n\n第二行有 $n$ 个数 $x_i$，含义如题目描述所示。", "outputFormat": "输出一个数字，代表最小的积木列数。", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 5000$，$0 \\le x_i \\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "Song Rongzi Builds Blocks", "background": "", "description": "saruka loves building with blocks and has $n$ blocks. saruka’s blocks are special: they can only be stacked vertically one by one, and you may build many columns. Since saruka’s blocks are special, they are intelligent. The $i$-th block has a mood value $x_i$. If the total number of blocks stacked on top of this block exceeds $x_i$, this block will be unhappy and vows never to play with saruka again. saruka loves blocks and will not make any block unhappy, but saruka also wants to use every block and minimize the number of columns. Can you help saruka?", "inputFormat": "The first line contains an integer $n$, as described above.  \nThe second line contains $n$ numbers $x_i$, as described above.", "outputFormat": "Output a single integer, the minimum number of columns.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 5000$, $0 \\le x_i \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "宋荣子搭积木", "background": "", "description": "saruka 非常喜欢搭积木，他一共有 $n$ 块积木。而且 saruka 的积木很特殊，只能一块块的竖着摞，可以摞很多列。说过 saruka 的是特殊的积木了，这些积木都非常智能，第 $i$ 块积木有一个情绪值 $x_i$ ，当摞在这块积木上的积木总数超过 $x_i$ 时，这块积木就会很不高兴，发誓以后不会再和 saruka 一起玩耍了。saruka 这么爱玩积木，肯定不会让积木不高兴的，但是 saruka 又希望每块积木都被用上，并且摞的积木列数最少。你能来帮帮 saruka 吗?", "inputFormat": "第一行一个整数 $n$，含义如题目描述所示，\n\n第二行有 $n$ 个数 $x_i$，含义如题目描述所示。", "outputFormat": "输出一个数字，代表最小的积木列数。", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 5000$，$0 \\le x_i \\le n$。", "locale": "zh-CN"}}}
{"pid": "P2817", "type": "P", "difficulty": 3, "samples": [["5 2", "54"], ["7 4", "1728"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "山东"], "title": "宋荣子的城堡", "background": "", "description": "saruka 有一座大大的城堡！城堡里面有 $n$ 个房间，每个房间上面都写着一个数字 $p_i$。有一天，saruka 邀请他的小伙伴 LYL 和 MagHSK 来城堡里玩耍，他们约定，如果某一个人当前站在 $i$ 号房间里，那么下一步他就要去 $p_i$ 号房间，在下一步就要去 $p_{p_i}$ 号房间。\n\n为了增加趣味性，saruka 决定重新书写一下每个房间的 $p_i$，以满足：\n\n- 如果从编号为 $1 \\sim k$ 的某个房间走，按照规则走，必须能走回 $1$ 号房间。特别的，如果从 $1$ 号房间开始走，也要走回 $1$ 号房间。（至少走一步，如果 $p_1 = 1$，从 $1$ 走到 $1$ 也算合法）。\n\n- 如果从编号大于 $k$ 的房间开始，按照规则走，一定不能走到 $1$ 号房间。\n\nsaruka 想知道，一共有多少书写 $p_i$ 的方案可以满足要求，答案对 $10 ^ 9 + 7$ 取模。", "inputFormat": "共一行两个数字 $n,k$，含义如题。", "outputFormat": "一个数字，表示合法的方案数。答案对 $10 ^ 9 + 7$ 取模。", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 10 ^ {18},1 \\le k \\le \\min(n,8)$。", "locale": "zh-CN", "translations": {"en": {"title": "Song Rongzi’s Castle", "background": "", "description": "saruka owns a big castle. There are $n$ rooms in the castle, and each room has a number $p_i$ written on it. One day, saruka invited his friends LYL and MagHSK to play in the castle. They agreed that if someone is currently standing in room $i$, then on the next step they must go to room $p_i$, and on the following step to room $p_{p_i}$.\n\nTo make it more interesting, saruka decides to rewrite each $p_i$ to satisfy the following:\n\n- If you start from any room numbered from $1 \\sim k$ and follow the rule, you must be able to return to room $1$. In particular, if you start from room $1$, you must return to room $1$ as well (you must take at least one step; if $p_1 = 1$, moving from $1$ to $1$ is also considered valid).\n\n- If you start from any room with a number greater than $k$ and follow the rule, you must never reach room $1$.\n\nsaruka wants to know how many assignments of $p_i$ satisfy the requirements. Output the answer modulo $10 ^ 9 + 7$.", "inputFormat": "A single line containing two integers $n, k$, as described.", "outputFormat": "Output a single integer, the number of valid assignments. The answer is taken modulo $10 ^ 9 + 7$.", "hint": "Constraints: For $100 \\%$ of the testdata, $1 \\le n \\le 10 ^ {18}, 1 \\le k \\le \\min(n, 8)$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "宋荣子的城堡", "background": "", "description": "saruka 有一座大大的城堡！城堡里面有 $n$ 个房间，每个房间上面都写着一个数字 $p_i$。有一天，saruka 邀请他的小伙伴 LYL 和 MagHSK 来城堡里玩耍，他们约定，如果某一个人当前站在 $i$ 号房间里，那么下一步他就要去 $p_i$ 号房间，在下一步就要去 $p_{p_i}$ 号房间。\n\n为了增加趣味性，saruka 决定重新书写一下每个房间的 $p_i$，以满足：\n\n- 如果从编号为 $1 \\sim k$ 的某个房间走，按照规则走，必须能走回 $1$ 号房间。特别的，如果从 $1$ 号房间开始走，也要走回 $1$ 号房间。（至少走一步，如果 $p_1 = 1$，从 $1$ 走到 $1$ 也算合法）。\n\n- 如果从编号大于 $k$ 的房间开始，按照规则走，一定不能走到 $1$ 号房间。\n\nsaruka 想知道，一共有多少书写 $p_i$ 的方案可以满足要求，答案对 $10 ^ 9 + 7$ 取模。", "inputFormat": "共一行两个数字 $n,k$，含义如题。", "outputFormat": "一个数字，表示合法的方案数。答案对 $10 ^ 9 + 7$ 取模。", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 10 ^ {18},1 \\le k \\le \\min(n,8)$。", "locale": "zh-CN"}}}
{"pid": "P2818", "type": "P", "difficulty": 2, "samples": [["7\n9\n", "2\n"], ["11\n108\n", "9\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["高精度"], "title": "天使的起誓", "background": "", "description": "Tenshi 非常幸运地被选为掌管智慧之匙的天使。在正式任职之前，她必须和其他新当选的天使一样要宣誓。\n\n宣誓仪式是每位天使各自表述自己的使命，他们的发言稿放在 $n$ 个呈圆形排列的宝盒中。这些宝盒按顺时针方向被编上号码 $1, 2, \\cdots, n - 1, n$。\n\n一开始天使们站在编号为 $n$ 的宝盒旁。她们各自手上都有一个数字，代表她们自己的发言稿所在的盒子是从 $1$ 号盒子开始按顺时针方向的第几个。例如：有  $7$ 个盒子，如果 Tenshi 手上的数字为 $9$，那么她的发言稿所在的盒子就是 $2$ 个。现在天使们开始按照自己手上的数字来找发言稿，先找到的就可以先发言。 \n\nTenshi 一下子就找到了，于是她最先上台宣誓：“我将带领大家开启 NOI 之门……” Tenshi 宣誓结束后，陆续有天使上台宣誓。可是有一位天使找了好久都找不到她的发言稿，原来她手上的数字 $m$ 非常大，她转了好久都找不到她想找的宝盒。\n\n请帮助这位天使找到她想找的宝盒编号。\n", "inputFormat": "第一行为正整数 $n$，第二行为正整数 $m$。", "outputFormat": "只有一行（包括换行符），即天使想找的宝盒的编号。\n", "hint": "对于 $100 \\%$ 的数据，$2\\le n\\le 10^8$，$2\\le m\\le 10^{1000}$。", "locale": "zh-CN", "translations": {"en": {"title": "The Angel's Oath", "background": "", "description": "Tenshi is very lucky to be chosen as the angel who holds the Key of Wisdom. Before officially taking office, she must take an oath like the other newly elected angels.\n\nDuring the oath ceremony, each angel states her mission, and their speech scripts are placed in $n$ treasure boxes arranged in a circle. These boxes are numbered clockwise as $1, 2, \\cdots, n - 1, n$.\n\nAt the beginning, the angels stand next to the box numbered $n$. Each of them holds a number that indicates the box containing her script is the $k$-th one clockwise starting from box $1$. For example: there are $7$ boxes, and if the number in Tenshi’s hand is $9$, then the box containing her script is $2$. Now the angels start to search for their scripts according to the numbers they hold; whoever finds it first will speak first.\n\nTenshi finds hers immediately and goes on stage first: “I will lead everyone to open the gate to NOI ...” After Tenshi finishes her oath, other angels go on stage one after another. However, one angel cannot find her script for a long time. It turns out that the number $m$ in her hand is very large, and after circling for a long time she still cannot find the box she wants.\n\nPlease help this angel find the index of the box she is looking for.", "inputFormat": "The first line contains a positive integer $n$, and the second line contains a positive integer $m$.", "outputFormat": "Output a single line: the index of the box the angel is looking for.", "hint": "For 100% of the testdata, $2 \\le n \\le 10^8$, $2 \\le m \\le 10^{1000}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "天使的起誓", "background": "", "description": "Tenshi 非常幸运地被选为掌管智慧之匙的天使。在正式任职之前，她必须和其他新当选的天使一样要宣誓。\n\n宣誓仪式是每位天使各自表述自己的使命，他们的发言稿放在 $n$ 个呈圆形排列的宝盒中。这些宝盒按顺时针方向被编上号码 $1, 2, \\cdots, n - 1, n$。\n\n一开始天使们站在编号为 $n$ 的宝盒旁。她们各自手上都有一个数字，代表她们自己的发言稿所在的盒子是从 $1$ 号盒子开始按顺时针方向的第几个。例如：有  $7$ 个盒子，如果 Tenshi 手上的数字为 $9$，那么她的发言稿所在的盒子就是 $2$ 个。现在天使们开始按照自己手上的数字来找发言稿，先找到的就可以先发言。 \n\nTenshi 一下子就找到了，于是她最先上台宣誓：“我将带领大家开启 NOI 之门……” Tenshi 宣誓结束后，陆续有天使上台宣誓。可是有一位天使找了好久都找不到她的发言稿，原来她手上的数字 $m$ 非常大，她转了好久都找不到她想找的宝盒。\n\n请帮助这位天使找到她想找的宝盒编号。\n", "inputFormat": "第一行为正整数 $n$，第二行为正整数 $m$。", "outputFormat": "只有一行（包括换行符），即天使想找的宝盒的编号。\n", "hint": "对于 $100 \\%$ 的数据，$2\\le n\\le 10^8$，$2\\le m\\le 10^{1000}$。", "locale": "zh-CN"}}}
{"pid": "P2819", "type": "P", "difficulty": 2, "samples": [["5 8 4\n1 2\n1 3\n1 4\n2 3\n2 4\n2 5\n3 4\n4 5", "48"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "递归"], "title": "图的 m 着色问题", "background": "给定无向连通图 $G$ 和 $m$ 种不同的颜色。用这些颜色为图 $G$ 的各顶点着色，每个顶点着一种颜色。如果有一种着色法使 $G$ 中每条边的 $2$ 个顶点着不同颜色，则称这个图是 $m$ 可着色的。图的 $m$ 着色问题是对于给定图 $G$ 和 $m$ 种颜色，找出所有不同的着色法。", "description": "对于给定的无向连通图 $G$ 和 $m$ 种不同的颜色，编程计算图的所有不同的着色法。", "inputFormat": "第 $1$ 行有 $3$ 个正整数 $n,k,m$，表示给定的图 $G$ 有 $n$ 个顶点和 $k$ 条边，$m$ 种颜色。顶点编号为 $1,2,\\dots,n$。接下来的 $k$ 行中，每行有 $2$ 个正整数 $u,v$，表示图 $G$ 的一条边 $(u,v)$。", "outputFormat": "程序运行结束时，将计算出的不同的着色方案数输出。", "hint": "数据保证，$1\\leq n\\leq 100$，$1 \\leq k\\leq 2500$。\n\n在 $n$ 很大时保证 $k$ 足够大。\n\n保证答案不超过 $20000$。\n\n数据为在满足上述条件的合法数据中随机采样得到。", "locale": "zh-CN", "translations": {"en": {"title": "Graph m-Coloring Problem", "background": "Given an undirected connected graph $G$ and $m$ different colors, color each vertex of $G$ using these colors, with each vertex assigned exactly one color. If there exists a coloring such that the two vertices of every edge in $G$ have different colors, then the graph is called $m$-colorable. The graph $m$-coloring problem is: for a given graph $G$ and $m$ colors, find all distinct colorings.", "description": "For a given undirected connected graph $G$ and $m$ different colors, write a program to compute all distinct colorings of the graph.", "inputFormat": "The first line contains $3$ positive integers $n, k, m$, indicating that the given graph $G$ has $n$ vertices and $k$ edges, and there are $m$ colors. The vertices are labeled $1, 2, \\dots, n$. The next $k$ lines each contain $2$ positive integers $u, v$, representing an edge of the graph $(u, v)$.", "outputFormat": "At the end of the program, output the number of computed distinct coloring schemes.", "hint": "The data guarantees $1 \\leq n \\leq 100$, $1 \\leq k \\leq 2500$.\n\nWhen $n$ is large, it is guaranteed that $k$ is sufficiently large.\n\nIt is guaranteed that the answer does not exceed $20000$.\n\nThe testdata is randomly sampled from valid data that meet the above conditions.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "图的 m 着色问题", "background": "给定无向连通图 $G$ 和 $m$ 种不同的颜色。用这些颜色为图 $G$ 的各顶点着色，每个顶点着一种颜色。如果有一种着色法使 $G$ 中每条边的 $2$ 个顶点着不同颜色，则称这个图是 $m$ 可着色的。图的 $m$ 着色问题是对于给定图 $G$ 和 $m$ 种颜色，找出所有不同的着色法。", "description": "对于给定的无向连通图 $G$ 和 $m$ 种不同的颜色，编程计算图的所有不同的着色法。", "inputFormat": "第 $1$ 行有 $3$ 个正整数 $n,k,m$，表示给定的图 $G$ 有 $n$ 个顶点和 $k$ 条边，$m$ 种颜色。顶点编号为 $1,2,\\dots,n$。接下来的 $k$ 行中，每行有 $2$ 个正整数 $u,v$，表示图 $G$ 的一条边 $(u,v)$。", "outputFormat": "程序运行结束时，将计算出的不同的着色方案数输出。", "hint": "数据保证，$1\\leq n\\leq 100$，$1 \\leq k\\leq 2500$。\n\n在 $n$ 很大时保证 $k$ 足够大。\n\n保证答案不超过 $20000$。\n\n数据为在满足上述条件的合法数据中随机采样得到。", "locale": "zh-CN"}}}
{"pid": "P2820", "type": "P", "difficulty": 3, "samples": [["5 5\n1 2 8\n1 3 1\n1 5 3\n2 4 5\n3 4 2\n", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "并查集", "生成树"], "title": "局域网", "background": "某个局域网内有 $n$ 台计算机，由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用 $f(i,j)$ 表示 $i,j$ 之间连接的畅通程度，$f(i,j)$ 值越小表示 $i,j$ 之间连接越通畅，$f(i,j)$ 为 $0$ 表示 $i,j$ 之间无网线连接。", "description": "现在需要解决回路问题，我们将除去一些连线，使得网络中没有回路，**不改变原图节点的连通性**，并且被除去网线的 $\\sum f(i,j)$ 最大，请求出这个最大值。", "inputFormat": "第一行两个正整数 $n,k$。\n\n接下来的 $k$ 行每行三个正整数 $i,j,m$ 表示 $i,j$ 两台计算机之间有网线联通，通畅程度为 $m$。", "outputFormat": "一个正整数， $\\sum f(i,j)$ 的最大值。", "hint": "对于全部数据，保证 $1\\le n \\le 100$，$1\\le f(i,j)\\le 1000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Local Area Network", "background": "In a certain local area network, there are $n$ computers. Due to negligence when setting up the LAN, the connections now form cycles. We know that if a LAN contains cycles, data will keep circulating within the cycle, causing network lag. Because the network cables connecting computers are different, some connections are not very smooth. We use $f(i,j)$ to denote the smoothness between $i$ and $j$; a smaller value of $f(i,j)$ means a smoother connection between $i$ and $j$, and $f(i,j) = 0$ means there is no cable between $i$ and $j$.", "description": "Now we need to resolve the cycle problem. We will remove some cables so that the network contains no cycles, **without changing the connectivity of the original graph's nodes**, and the sum of $f(i,j)$ over the removed cables is maximized. Please compute this maximum value.", "inputFormat": "The first line contains two positive integers $n, k$.\nThe next $k$ lines each contain three positive integers $i, j, m$, indicating that there is a cable between computers $i$ and $j$ with smoothness $m$.", "outputFormat": "A single positive integer: the maximum value of $\\sum f(i,j)$.", "hint": "Constraints: For all testdata, it is guaranteed that $1 \\le n \\le 100$, $1 \\le f(i,j) \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "局域网", "background": "某个局域网内有 $n$ 台计算机，由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用 $f(i,j)$ 表示 $i,j$ 之间连接的畅通程度，$f(i,j)$ 值越小表示 $i,j$ 之间连接越通畅，$f(i,j)$ 为 $0$ 表示 $i,j$ 之间无网线连接。", "description": "现在需要解决回路问题，我们将除去一些连线，使得网络中没有回路，**不改变原图节点的连通性**，并且被除去网线的 $\\sum f(i,j)$ 最大，请求出这个最大值。", "inputFormat": "第一行两个正整数 $n,k$。\n\n接下来的 $k$ 行每行三个正整数 $i,j,m$ 表示 $i,j$ 两台计算机之间有网线联通，通畅程度为 $m$。", "outputFormat": "一个正整数， $\\sum f(i,j)$ 的最大值。", "hint": "对于全部数据，保证 $1\\le n \\le 100$，$1\\le f(i,j)\\le 1000$。\n", "locale": "zh-CN"}}}
{"pid": "P2821", "type": "P", "difficulty": 4, "samples": [["48", "68"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心"], "title": "变幻数", "background": null, "description": "给定一个十进制正整数 $n$，它的递归变幻数定义如下：\n\n- 如果 $n$ 的位数多于 $1$ 位（忽略前置的 $0$），将 $n$ 的各个位上的数相乘，乘积为 $m$。称 $m$ 为 $n$ 的子变幻数，$n$ 称为 $m$ 的父变幻数。求一个数的变幻数等于求其子变幻数。即求 $n$ 的变幻数等于求 $m$ 的变幻数。\n\n- 如果 $n$ 的位数只有一位，$n$ 的变幻数即为它本身。 如求 $679$ 的变幻数过程为：$679 \\to 378(6 \\times 7 \\times 9) \\to 168(3 \\times 7 \\times 8) \\to 48(1 \\times 6 \\times 8) \\to 32(4 \\times 8) \\to 6(2 \\times 3)$，所以 $679$ 的变幻数为 $6$。\n\n现在的问题是给定一个子变幻数 $k$，问 $k$ 的父变幻数最小是多少？ 如：$k=18$，则 $k$ 的父变幻数可以是 $29$，也可以是 $92$。但最小为 $29$。", "inputFormat": "一个子变幻数 $k$（位数 $\\le 1000$）。", "outputFormat": "$k$ 的最小父变幻数。 当不存在父变幻数时请输出 `There is no such number!`。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Transform Number", "background": "", "description": "Given a positive decimal integer $n$, its recursive \"transform number\" is defined as follows:\n\n- If $n$ has more than 1 digit (ignoring leading zeros), multiply all its digits, and let the product be $m$. Call $m$ a \"sub-transform number\" of $n$, and call $n$ a \"parent transform number\" of $m$. To compute the \"transform number\" of a number means to keep taking its sub-transform number recursively. That is, computing the transform number of $n$ is the same as computing the transform number of $m$.\n\n- If $n$ has exactly one digit, then its transform number is itself. For example, the process for the transform number of $679$ is: $679 \\to 378(6 \\times 7 \\times 9) \\to 168(3 \\times 7 \\times 8) \\to 48(1 \\times 6 \\times 8) \\to 32(4 \\times 8) \\to 6(2 \\times 3)$, so the transform number of $679$ is $6$.\n\nNow, given a sub-transform number $k$, what is the smallest parent transform number of $k$? For example, when $k=18$, the parent transform number can be $29$ or $92$, but the smallest is $29$.", "inputFormat": "A sub-transform number $k$ (number of digits $\\le 1000$).", "outputFormat": "The smallest parent transform number of $k$. If no parent transform number exists, output `There is no such number!`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "变幻数", "background": null, "description": "给定一个十进制正整数 $n$，它的递归变幻数定义如下：\n\n- 如果 $n$ 的位数多于 $1$ 位（忽略前置的 $0$），将 $n$ 的各个位上的数相乘，乘积为 $m$。称 $m$ 为 $n$ 的子变幻数，$n$ 称为 $m$ 的父变幻数。求一个数的变幻数等于求其子变幻数。即求 $n$ 的变幻数等于求 $m$ 的变幻数。\n\n- 如果 $n$ 的位数只有一位，$n$ 的变幻数即为它本身。 如求 $679$ 的变幻数过程为：$679 \\to 378(6 \\times 7 \\times 9) \\to 168(3 \\times 7 \\times 8) \\to 48(1 \\times 6 \\times 8) \\to 32(4 \\times 8) \\to 6(2 \\times 3)$，所以 $679$ 的变幻数为 $6$。\n\n现在的问题是给定一个子变幻数 $k$，问 $k$ 的父变幻数最小是多少？ 如：$k=18$，则 $k$ 的父变幻数可以是 $29$，也可以是 $92$。但最小为 $29$。", "inputFormat": "一个子变幻数 $k$（位数 $\\le 1000$）。", "outputFormat": "$k$ 的最小父变幻数。 当不存在父变幻数时请输出 `There is no such number!`。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2822", "type": "P", "difficulty": 3, "samples": [["1 2\n3 3", "1"], ["2 5\n4 5\n6 7", "0\n7\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "2016", "NOIP 提高组", "组合数学", "前缀和"], "title": "[NOIP 2016 提高组] 组合数问题", "background": "NOIP2016 提高组 D2T1", "description": "组合数 $\\binom{n}{m}$ 表示的是从 $n$ 个物品中选出 $m$ 个物品的方案数。举个例子，从 $(1,2,3)$ 三个物品中选择两个物品可以有 $(1,2),(1,3),(2,3)$ 这三种选择方法。根据组合数的定义，我们可以给出计算组合数 $\\binom{n}{m}$ 的一般公式：\n\n$$\\binom{n}{m}=\\frac{n!}{m!(n-m)!}$$\n\n其中 $n!=1\\times2\\times\\cdots\\times n$；特别地，定义 $0!=1$。\n\n小葱想知道如果给定 $n,m$ 和 $k$，对于所有的 $0\\leq i\\leq n,0\\leq j\\leq \\min \\left ( i, m \\right )$ 有多少对 $(i,j)$ 满足 $k\\mid\\binom{i}{j}$。", "inputFormat": "第一行有两个整数 $t,k$，其中 $t$ 代表该测试点总共有多少组测试数据，$k$ 的意义见问题描述。\n\n接下来 $t$ 行每行两个整数 $n,m$，其中 $n,m$ 的意义见问题描述。", "outputFormat": "共 $t$ 行，每行一个整数代表所有的 $0\\leq i\\leq n,0\\leq j\\leq \\min \\left ( i, m \\right )$ 中有多少对 $(i,j)$ 满足 $k\\mid\\binom{i}{j}$。", "hint": "【样例1说明】\n\n在所有可能的情况中，只有 $\\binom{2}{1} = 2$ 一种情况是 $2$ 的倍数。\n\n【子任务】\n\n::cute-table{tuack}\n\n|测试点|$n$|$m$|$k$|$t$|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$\\le3$|$\\le3$|$=2$|$=1$|\n|$2$|^|^|$=3$|$\\le10^4$|\n|$3$|$\\le7$|$\\le7$|$=4$|$=1$|\n|$4$|^|^|$=5$|$\\le10^4$|\n|$5$|$\\le10$|$\\le10$|$=6$|$=1$|\n|$6$|^|^|$=7$|$\\le10^4$|\n|$7$|$\\le20$|$\\le100$|$=8$|$=1$|\n|$8$|^|^|$=9$|$\\le10^4$|\n|$9$|$\\le25$|$\\le2000$|$=10$|$=1$|\n|$10$|^|^|$=11$|$\\le10^4$|\n|$11$|$\\le60$|$\\le20$|$=12$|$=1$|\n|$12$|^|^|$=13$|$\\le10^4$|\n|$13$|$\\le100$|$\\le25$|$=14$|$=1$|\n|$14$|^|^|$=15$|$\\le10^4$|\n|$15$|^|$\\le60$|$=16$|$=1$|\n|$16$|^|^|$=17$|$\\le10^4$|\n|$17$|$\\le2000$|$\\le100$|$=18$|$=1$|\n|$18$|^|^|$=19$|$\\le10^4$|\n|$19$|^|$\\le2000$|$=20$|$=1$|\n|$20$|^|^|$=21$|$\\le10^4$|\n\n- 对于全部的测试点，保证 $0 \\leq n, m \\leq 2 \\times 10^3$，$1 \\leq t \\leq 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2016 Senior] Binomial Coefficient Problem", "background": "NOIP 2016 Senior D2T1.", "description": "The binomial coefficient $\\binom{n}{m}$ represents the number of ways to choose $m$ items from $n$ items. For example, when choosing two items from three items $(1, 2, 3)$, there are three choices: $(1, 2)$, $(1, 3)$, and $(2, 3)$. By definition, the general formula for computing the binomial coefficient $\\binom{n}{m}$ is:\n\n$$\\binom{n}{m}=\\frac{n!}{m!(n-m)!}$$\n\nwhere $n!=1\\times2\\times\\cdots\\times n$. In particular, $0!=1$.\n\nXiaocong wants to know, given $n$, $m$, and $k$, among all $0 \\leq i \\leq n$, $0 \\leq j \\leq \\min \\left ( i, m \\right )$, how many pairs $(i, j)$ satisfy $k \\mid \\binom{i}{j}$.", "inputFormat": "The first line contains two integers $t, k$, where $t$ is the number of test cases in this testdata, and $k$ is as described in the problem.\n\nEach of the next $t$ lines contains two integers $n, m$, where $n$ and $m$ are as described in the problem.", "outputFormat": "Output $t$ lines. Each line contains a single integer representing how many pairs $(i, j)$ among all $0 \\leq i \\leq n$, $0 \\leq j \\leq \\min \\left ( i, m \\right )$ satisfy $k \\mid \\binom{i}{j}$.", "hint": "Sample 1 Explanation.\n\nAmong all possible cases, only $\\binom{2}{1} = 2$ is a multiple of $2$.\n\nSubtasks.\n\n| Testpoint | $n$ | $m$ | $k$ | $t$ |\n|:-:|:-:|:-:|:-:|:-:|\n| $1$ | $\\le 3$ | $\\le 3$ | $=2$ | $=1$ |\n| $2$ | ^ | ^ | $=3$ | $\\le 10^4$ |\n| $3$ | $\\le 7$ | $\\le 7$ | $=4$ | $=1$ |\n| $4$ | ^ | ^ | $=5$ | $\\le 10^4$ |\n| $5$ | $\\le 10$ | $\\le 10$ | $=6$ | $=1$ |\n| $6$ | ^ | ^ | $=7$ | $\\le 10^4$ |\n| $7$ | $\\le 20$ | $\\le 100$ | $=8$ | $=1$ |\n| $8$ | ^ | ^ | $=9$ | $\\le 10^4$ |\n| $9$ | $\\le 25$ | $\\le 2000$ | $=10$ | $=1$ |\n| $10$ | ^ | ^ | $=11$ | $\\le 10^4$ |\n| $11$ | $\\le 60$ | $\\le 20$ | $=12$ | $=1$ |\n| $12$ | ^ | ^ | $=13$ | $\\le 10^4$ |\n| $13$ | $\\le 100$ | $\\le 25$ | $=14$ | $=1$ |\n| $14$ | ^ | ^ | $=15$ | $\\le 10^4$ |\n| $15$ | ^ | $\\le 60$ | $=16$ | $=1$ |\n| $16$ | ^ | ^ | $=17$ | $\\le 10^4$ |\n| $17$ | $\\le 2000$ | $\\le 100$ | $=18$ | $=1$ |\n| $18$ | ^ | ^ | $=19$ | $\\le 10^4$ |\n| $19$ | ^ | $\\le 2000$ | $=20$ | $=1$ |\n| $20$ | ^ | ^ | $=21$ | $\\le 10^4$ |\n\nConstraints.\n\nFor all testdata, it is guaranteed that $0 \\leq n, m \\leq 2 \\times 10^3$, $1 \\leq t \\leq 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2016 提高组] 组合数问题", "background": "NOIP2016 提高组 D2T1", "description": "组合数 $\\binom{n}{m}$ 表示的是从 $n$ 个物品中选出 $m$ 个物品的方案数。举个例子，从 $(1,2,3)$ 三个物品中选择两个物品可以有 $(1,2),(1,3),(2,3)$ 这三种选择方法。根据组合数的定义，我们可以给出计算组合数 $\\binom{n}{m}$ 的一般公式：\n\n$$\\binom{n}{m}=\\frac{n!}{m!(n-m)!}$$\n\n其中 $n!=1\\times2\\times\\cdots\\times n$；特别地，定义 $0!=1$。\n\n小葱想知道如果给定 $n,m$ 和 $k$，对于所有的 $0\\leq i\\leq n,0\\leq j\\leq \\min \\left ( i, m \\right )$ 有多少对 $(i,j)$ 满足 $k\\mid\\binom{i}{j}$。", "inputFormat": "第一行有两个整数 $t,k$，其中 $t$ 代表该测试点总共有多少组测试数据，$k$ 的意义见问题描述。\n\n接下来 $t$ 行每行两个整数 $n,m$，其中 $n,m$ 的意义见问题描述。", "outputFormat": "共 $t$ 行，每行一个整数代表所有的 $0\\leq i\\leq n,0\\leq j\\leq \\min \\left ( i, m \\right )$ 中有多少对 $(i,j)$ 满足 $k\\mid\\binom{i}{j}$。", "hint": "【样例1说明】\n\n在所有可能的情况中，只有 $\\binom{2}{1} = 2$ 一种情况是 $2$ 的倍数。\n\n【子任务】\n\n::cute-table{tuack}\n\n|测试点|$n$|$m$|$k$|$t$|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$\\le3$|$\\le3$|$=2$|$=1$|\n|$2$|^|^|$=3$|$\\le10^4$|\n|$3$|$\\le7$|$\\le7$|$=4$|$=1$|\n|$4$|^|^|$=5$|$\\le10^4$|\n|$5$|$\\le10$|$\\le10$|$=6$|$=1$|\n|$6$|^|^|$=7$|$\\le10^4$|\n|$7$|$\\le20$|$\\le100$|$=8$|$=1$|\n|$8$|^|^|$=9$|$\\le10^4$|\n|$9$|$\\le25$|$\\le2000$|$=10$|$=1$|\n|$10$|^|^|$=11$|$\\le10^4$|\n|$11$|$\\le60$|$\\le20$|$=12$|$=1$|\n|$12$|^|^|$=13$|$\\le10^4$|\n|$13$|$\\le100$|$\\le25$|$=14$|$=1$|\n|$14$|^|^|$=15$|$\\le10^4$|\n|$15$|^|$\\le60$|$=16$|$=1$|\n|$16$|^|^|$=17$|$\\le10^4$|\n|$17$|$\\le2000$|$\\le100$|$=18$|$=1$|\n|$18$|^|^|$=19$|$\\le10^4$|\n|$19$|^|$\\le2000$|$=20$|$=1$|\n|$20$|^|^|$=21$|$\\le10^4$|\n\n- 对于全部的测试点，保证 $0 \\leq n, m \\leq 2 \\times 10^3$，$1 \\leq t \\leq 10^4$。", "locale": "zh-CN"}}}
{"pid": "P2823", "type": "P", "difficulty": 6, "samples": [["2\n2 2 3 2\n4 1\n2 3\n0 1 1\n0 1 0\n1 1 1\n1 1 1\n1 1 1\n1 0 1\n2 2 3 2\n4 1\n2 3\n0 1 2\n0 1 0\n1 1 1\n1 1 1\n1 1 1\n1 0 1", "Yes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "福建省历届夏令营", "网络流", "福建"], "title": "时间表", "background": "小 A 是一个电话服务中心的主管，他的团队有一大批人。他们团队中的每个人都会花费他们的时间参加会议和通过电话与客户通话，当然还有研究团队的项目也是要花费他们的时间的。\n", "description": "他们中的每个人在每个小时只能在参加会议、和客户通话、研究项目三者中选择一个来进行。为了提高效率，每个小时必须完整地奉献到这一项工作中，不能中途改变。\n\n小 A 所在的地方很奇怪，他们一个星期有 $D$ 天，从 $1$ 到 $D$ 标号。为了照顾员工的嗓子，第 $i$ 个人在每个星期最多能够与客户通话 $L_i$ 小时。\n\n开会是已经计划好的事情，对于每个人他们需要在什么时间参加会议是确定的。这个电话服务中心每天要有 $H$ 个小时的时间是可以回复客户的电话的，为了简便，这 $H$ 个小时被从 $1$ 到 $H$ 标号。\n\n对于每周的每个小时，有多少客户会连接到电话服务中心是已知的。因此，小 A 知道他在第 $i$ 天的第 $j$ 个小时必须安排 $R_{i,j}$ 个员工来和客户通话。如果第 $k$ 个人在第 $i$ 天的第 $j$ 个小时没有会议可以和客户通话，那么 $F_{k,i,j}$ 的值为 $1$，如果有会议则为 $0$。\n\n再次说明，小  A的世界十分奇怪，他们除了每周可能不是 $7$ 天以外，每天也可能不是 $24$ 个小时。\n\n小 A 需要为每个员工创建一个时间表。由于员工也需要吃饭和休息，每天都会有一个午休时间，这段时间是从 $L_{\\text{T}_\\text{begin}}$ 开始到 $L_{\\text{T}_\\text{end}}$ 结束（$L_{\\text{T}_\\text{begin}}$ 和 $L_{\\text{T}_\\text{end}}$ 也包含在内）。小 A 需要确保每个员工在这段时间内至少有一个小时是没有参加会议或与客户通话的，以便他们可以吃饭和休息，或者做自己想做的事情。\n\n如果某个人在某个小时内没有会议也没有和客户通话，那他在这个小时就可以去研究公司项目，研究公司项目也算在工作时间之内。另外，他们有可能会去研究自己的项目，然而这是不算在工作时间内的。\n\n小 A 想要知道，他是否有可能安排出这样一个时间表，并且满足：\n\n- 每个人每天最多花费 $N$ 个小时在参加会议和客户通话上；\n- 每个人每周最多花费 $L_i$ 个小时和客户通话；\n- 每个人在午休时间至少有一个小时没有参加会议或和客户通话；\n- 对于第 $i$ 天第 $j$ 个小时，恰好有 $R_{i,j}$ 个人可以与客户通话。\n", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n\n每组数据第一行包含四个整数 $P, D, H, N$，分别表示团队的人数，每周需要工作的天数，每天电话服务中心可以响应客户电话的小时数，以及每天每个人的工作时长；\n\n接下来一行包含 $P$ 个整数，第 $i$ 个表示 $L_i$；\n\n再接下来一行包含两个整数$L_{\\text{T}_\\text{begin}}$ 和 $L_{\\text{T}_\\text{end}}$，表示午休时间段；\n\n接下来 $D$ 行每行包含 $H$ 个整数，第 $i$ 行第 $j$ 个整数表示 $R_{i,j}$；\n\n再接下来 $P$ 个块，每个块有 $D$ 行，每行包含 $H$ 个整数。第 $k$ 个块的第$i$ 行的第 $j$ 个数表示 $F_{k,i,j}$。\n", "outputFormat": "共 $T$ 行，如果第 $i$ 组数据存在可行方案则输出 `Yes`，否则输出 `No`。\n", "hint": "对于 $100\\%$ 的数据满足有\n\n$1 \\leq T \\leq 5,1 \\leq N \\leq H \\leq 70$\n\n$1 \\leq D, P\\leq 70,1 \\leq L_i \\leq N\\times D, 0 \\leq R_{i, j} \\leq 15$\n\n$0 \\leq F_{k, i, j} \\leq 1,1 \\leq L_{\\text{T}_\\text{begin}} \\leq L_{\\text{T}_\\text{end}} \\leq N$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Timetable", "background": "Xiao A is a supervisor at a call service center, and his team has a large number of people. Everyone on the team spends their time attending meetings and talking to customers over the phone, and of course working on the team's research projects also takes up their time.", "description": "Each person can only choose one of attending meetings, talking to customers, or working on research projects in any given hour. To improve efficiency, each hour must be devoted entirely to one of these tasks, and they cannot switch in the middle.\n\nXiao A lives in a strange place where a week has $D$ days, labeled from $1$ to $D$. To protect the employees' voices, person $i$ can talk to customers for at most $L_i$ hours per week.\n\nMeetings are pre-planned, and the times at which each person needs to attend meetings are fixed. The call service center can respond to customer calls for $H$ hours each day; for convenience, these $H$ hours are labeled from $1$ to $H$.\n\nFor each day and hour of the week, the number of customers connecting to the call service center is known. Therefore, Xiao A knows that on day $i$ at hour $j$, exactly $R_{i,j}$ employees must be scheduled to talk to customers. If person $k$ has no meeting at day $i$, hour $j$ and can take customer calls, then $F_{k,i,j}=1$; otherwise $F_{k,i,j}=0$.\n\nAgain, Xiao A's world is quite strange: not only might a week not have $7$ days, but a day might also not have $24$ hours.\n\nXiao A needs to create a timetable for each employee. Since employees also need to eat and rest, there is a lunch break every day from $L_{\\text{T}_\\text{begin}}$ to $L_{\\text{T}_\\text{end}}$ inclusive. Xiao A must ensure that each employee has at least one hour within this interval during which they are neither in a meeting nor talking to customers, so that they can eat, rest, or do what they want.\n\nIf someone has neither a meeting nor customer calls in an hour, they can work on the company’s research projects during that hour, and this counts as working time. They might also work on their own projects, but that does not count as working time.\n\nXiao A wants to know whether it is possible to arrange such a timetable that satisfies all of the following:\n\n- Each person spends at most $N$ hours per day on meetings and customer calls.\n- Each person spends at most $L_i$ hours per week talking to customers.\n- Each person has at least one hour during the lunch break when they are neither in a meeting nor talking to customers.\n- For day $i$, hour $j$, exactly $R_{i,j}$ people are talking to customers.", "inputFormat": "The first line contains a positive integer $T$, the number of testdata sets.\n\nFor each testdata set, the first line contains four integers $P, D, H, N$, representing the number of people in the team, the number of working days per week, the number of hours per day during which the call service center can respond to customer calls, and the daily per-person limit on time spent on meetings and customer calls, respectively.\n\nThe next line contains $P$ integers, where the $i$-th integer is $L_i$.\n\nThe next line contains two integers $L_{\\text{T}_\\text{begin}}$ and $L_{\\text{T}_\\text{end}}$, representing the lunch break interval.\n\nThen follow $D$ lines, each containing $H$ integers; on the $i$-th line, the $j$-th integer is $R_{i,j}$.\n\nThen follow $P$ blocks; each block has $D$ lines, and each line contains $H$ integers. In the $k$-th block, the number on the $i$-th line and $j$-th position is $F_{k,i,j}$.", "outputFormat": "Output $T$ lines. For the $i$-th testdata set, print `Yes` if a feasible schedule exists; otherwise, print `No`.", "hint": "Constraints:\n\nFor $100\\%$ of the testdata, the following hold:\n\n$1 \\leq T \\leq 5, 1 \\leq N \\leq H \\leq 70$.\n\n$1 \\leq D, P \\leq 70, 1 \\leq L_i \\leq N \\times D, 0 \\leq R_{i,j} \\leq 15$.\n\n$0 \\leq F_{k,i,j} \\leq 1, 1 \\leq L_{\\text{T}_\\text{begin}} \\leq L_{\\text{T}_\\text{end}} \\leq H$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "时间表", "background": "小 A 是一个电话服务中心的主管，他的团队有一大批人。他们团队中的每个人都会花费他们的时间参加会议和通过电话与客户通话，当然还有研究团队的项目也是要花费他们的时间的。\n", "description": "他们中的每个人在每个小时只能在参加会议、和客户通话、研究项目三者中选择一个来进行。为了提高效率，每个小时必须完整地奉献到这一项工作中，不能中途改变。\n\n小 A 所在的地方很奇怪，他们一个星期有 $D$ 天，从 $1$ 到 $D$ 标号。为了照顾员工的嗓子，第 $i$ 个人在每个星期最多能够与客户通话 $L_i$ 小时。\n\n开会是已经计划好的事情，对于每个人他们需要在什么时间参加会议是确定的。这个电话服务中心每天要有 $H$ 个小时的时间是可以回复客户的电话的，为了简便，这 $H$ 个小时被从 $1$ 到 $H$ 标号。\n\n对于每周的每个小时，有多少客户会连接到电话服务中心是已知的。因此，小 A 知道他在第 $i$ 天的第 $j$ 个小时必须安排 $R_{i,j}$ 个员工来和客户通话。如果第 $k$ 个人在第 $i$ 天的第 $j$ 个小时没有会议可以和客户通话，那么 $F_{k,i,j}$ 的值为 $1$，如果有会议则为 $0$。\n\n再次说明，小  A的世界十分奇怪，他们除了每周可能不是 $7$ 天以外，每天也可能不是 $24$ 个小时。\n\n小 A 需要为每个员工创建一个时间表。由于员工也需要吃饭和休息，每天都会有一个午休时间，这段时间是从 $L_{\\text{T}_\\text{begin}}$ 开始到 $L_{\\text{T}_\\text{end}}$ 结束（$L_{\\text{T}_\\text{begin}}$ 和 $L_{\\text{T}_\\text{end}}$ 也包含在内）。小 A 需要确保每个员工在这段时间内至少有一个小时是没有参加会议或与客户通话的，以便他们可以吃饭和休息，或者做自己想做的事情。\n\n如果某个人在某个小时内没有会议也没有和客户通话，那他在这个小时就可以去研究公司项目，研究公司项目也算在工作时间之内。另外，他们有可能会去研究自己的项目，然而这是不算在工作时间内的。\n\n小 A 想要知道，他是否有可能安排出这样一个时间表，并且满足：\n\n- 每个人每天最多花费 $N$ 个小时在参加会议和客户通话上；\n- 每个人每周最多花费 $L_i$ 个小时和客户通话；\n- 每个人在午休时间至少有一个小时没有参加会议或和客户通话；\n- 对于第 $i$ 天第 $j$ 个小时，恰好有 $R_{i,j}$ 个人可以与客户通话。\n", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n\n每组数据第一行包含四个整数 $P, D, H, N$，分别表示团队的人数，每周需要工作的天数，每天电话服务中心可以响应客户电话的小时数，以及每天每个人的工作时长；\n\n接下来一行包含 $P$ 个整数，第 $i$ 个表示 $L_i$；\n\n再接下来一行包含两个整数$L_{\\text{T}_\\text{begin}}$ 和 $L_{\\text{T}_\\text{end}}$，表示午休时间段；\n\n接下来 $D$ 行每行包含 $H$ 个整数，第 $i$ 行第 $j$ 个整数表示 $R_{i,j}$；\n\n再接下来 $P$ 个块，每个块有 $D$ 行，每行包含 $H$ 个整数。第 $k$ 个块的第$i$ 行的第 $j$ 个数表示 $F_{k,i,j}$。\n", "outputFormat": "共 $T$ 行，如果第 $i$ 组数据存在可行方案则输出 `Yes`，否则输出 `No`。\n", "hint": "对于 $100\\%$ 的数据满足有\n\n$1 \\leq T \\leq 5,1 \\leq N \\leq H \\leq 70$\n\n$1 \\leq D, P\\leq 70,1 \\leq L_i \\leq N\\times D, 0 \\leq R_{i, j} \\leq 15$\n\n$0 \\leq F_{k, i, j} \\leq 1,1 \\leq L_{\\text{T}_\\text{begin}} \\leq L_{\\text{T}_\\text{end}} \\leq N$。\n", "locale": "zh-CN"}}}
{"pid": "P2824", "type": "P", "difficulty": 5, "samples": [["6 3\n1 6 2 5 3 4\n0 1 4\n1 3 6\n0 2 4\n3", "5"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "线段树", "二分", "各省省选", "颜色段均摊（珂朵莉树 ODT）", "河北", "排序", "天津"], "title": "[HEOI2016/TJOI2016] 排序", "background": null, "description": "在 2016 年，佳媛姐姐喜欢上了数字序列。因而她经常研究关于序列的一些奇奇怪怪的问题，现在她在研究一个难题，需要你来帮助她。  \n\n这个难题是这样子的：给出一个 $1$ 到 $n$ 的排列，现在对这个排列序列进行 $m$ 次局部排序，排序分为两种：  \n\n- `0 l r` 表示将区间 $[l,r]$ 的数字升序排序；  \n- `1 l r` 表示将区间 $[l,r]$ 的数字降序排序。  \n\n注意，这里是对**下标**在区间 $[l,r]$ 内的数排序。  \n最后询问第 $q$ 位置上的数字。", "inputFormat": "输入数据的第一行为两个整数 $n$ 和 $m$，$n$ 表示序列的长度，$m$ 表示局部排序的次数。  \n\n第二行为 $n$ 个整数，表示 $1$ 到 $n$ 的一个排列。  \n\n接下来输入 $m$ 行，每一行有三个整数 $\\text{op},l,r$，$\\text{op}$ 为 $0$ 代表升序排序，$\\text{op}$ 为 $1$ 代表降序排序, $l,r$ 表示排序的区间。  \n\n最后输入一个整数 $q$，表示排序完之后询问的位置。", "outputFormat": "输出数据仅有一行，一个整数，表示按照顺序将全部的部分排序结束后第 $q$ 位置上的数字。", "hint": "河北省选 2016 第一天第二题。\n\n对于 $30\\%$ 的数据，$n,m\\leq 1000$；\n\n对于 $100\\%$ 的数据，$n,m\\leq 10^5$，$1\\leq q\\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2016/TJOI2016] Sorting", "background": "", "description": "In 2016, sister Jiayuan became fond of number sequences. She often studies various quirky problems about sequences, and now she is working on a hard one that needs your help.\n\nThe problem is as follows: given a permutation of $1$ to $n$, perform $m$ local sorts on this sequence. There are two types of sorts:\n\n- `0 l r` means sorting the numbers in the interval $[l,r]$ in ascending order.\n- `1 l r` means sorting the numbers in the interval $[l,r]$ in descending order.\n\nNote that this sorts the numbers whose **indices** lie in the interval $[l,r]$.  \nFinally, query the number at position $q$.", "inputFormat": "The first line contains two integers $n$ and $m$, where $n$ is the length of the sequence and $m$ is the number of local sorts.\n\nThe second line contains $n$ integers, representing a permutation of $1$ to $n$.\n\nThe next $m$ lines each contain three integers $\\text{op}, l, r$, where $\\text{op}$ being $0$ means ascending sort, $\\text{op}$ being $1$ means descending sort, and $l, r$ specify the interval to sort.\n\nFinally, an integer $q$ is given, indicating the position to query after all sorts are finished.", "outputFormat": "Output a single line containing one integer, the number at position $q$ after performing all local sorts in order.", "hint": "Hebei NOI Qualifier 2016 Day 1 Problem 2.\n\nFor $30\\%$ of the testdata, $n, m \\leq 1000$.\n\nFor $100\\%$ of the testdata, $n, m \\leq 10^5$, $1 \\leq q \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2016/TJOI2016] 排序", "background": null, "description": "在 2016 年，佳媛姐姐喜欢上了数字序列。因而她经常研究关于序列的一些奇奇怪怪的问题，现在她在研究一个难题，需要你来帮助她。  \n\n这个难题是这样子的：给出一个 $1$ 到 $n$ 的排列，现在对这个排列序列进行 $m$ 次局部排序，排序分为两种：  \n\n- `0 l r` 表示将区间 $[l,r]$ 的数字升序排序；  \n- `1 l r` 表示将区间 $[l,r]$ 的数字降序排序。  \n\n注意，这里是对**下标**在区间 $[l,r]$ 内的数排序。  \n最后询问第 $q$ 位置上的数字。", "inputFormat": "输入数据的第一行为两个整数 $n$ 和 $m$，$n$ 表示序列的长度，$m$ 表示局部排序的次数。  \n\n第二行为 $n$ 个整数，表示 $1$ 到 $n$ 的一个排列。  \n\n接下来输入 $m$ 行，每一行有三个整数 $\\text{op},l,r$，$\\text{op}$ 为 $0$ 代表升序排序，$\\text{op}$ 为 $1$ 代表降序排序, $l,r$ 表示排序的区间。  \n\n最后输入一个整数 $q$，表示排序完之后询问的位置。", "outputFormat": "输出数据仅有一行，一个整数，表示按照顺序将全部的部分排序结束后第 $q$ 位置上的数字。", "hint": "河北省选 2016 第一天第二题。\n\n对于 $30\\%$ 的数据，$n,m\\leq 1000$；\n\n对于 $100\\%$ 的数据，$n,m\\leq 10^5$，$1\\leq q\\leq n$。", "locale": "zh-CN"}}}
{"pid": "P2825", "type": "P", "difficulty": 6, "samples": [["4 4\n#***\n*#**\n**#*\nxxx#", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2016", "各省省选", "网络流", "河北", "连通块", "二分图", "天津"], "title": "[HEOI2016/TJOI2016] 游戏", "background": "", "description": "在 2016 年，佳媛姐姐喜欢上了一款游戏，叫做泡泡堂。\n\n简单的说，这个游戏就是在一张地图上放上若干个炸弹，看是否能炸到对手，或者躲开对手的炸弹。在玩游戏的过程中，小 H 想到了这样一个问题：当给定一张地图，在这张地图上最多能放上多少个炸弹能使得任意两个炸弹之间不会互相炸到。炸弹能炸到的范围是该炸弹所在的一行和一列，炸弹的威力可以穿透软石头，但是不能穿透硬石头。\n\n给定一张 $ n \\times m $ 的网格地图:其中 ``*`` 代表空地，炸弹的威力可以穿透，可以在空地上放置一枚炸弹。 ``x`` 代表软石头，炸弹的威力可以穿透，不能在此放置炸弹。``#`` 代表硬石头，炸弹的威力是不能穿透的，不能在此放置炸弹。例如：给出 $ 1 \\times 4 $ 的网格地图 `` *xx*``，这个地图上最多只能放置一个炸弹。给出另一个$ 1 \\times 4 $ 的网格地图 ``*x#*``，这个地图最多能放置两个炸弹。\n\n现在小 H 任意给出一张 $ n \\times m $ 的网格地图，问你最多能放置多少炸弹。", "inputFormat": "第一行输入两个正整数 $ n, m $，$ n $ 表示地图的行数，$ m $ 表示地图的列数。\n\n接下来输入 $ n $ 行 $ m $ 列个字符，代表网格地图。``*``的个数不超过 $ n \\times m $ 个。", "outputFormat": "输出一个整数 $ a $，表示最多能放置炸弹的个数。", "hint": "$1 \\leq n,m \\leq 50$", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2016/TJOI2016] Game", "background": "", "description": "In 2016, Sister Jiayuan fell in love with a game called BnB.\n\nSimply put, in this game you place several bombs on a map to see whether you can hit the opponent or avoid the opponent’s bombs. While playing, Little H thought of this question: given a map, what is the maximum number of bombs you can place so that no two bombs can hit each other? A bomb’s explosion reaches the entire row and column where it is placed. The explosion can pass through soft stones, but cannot pass through hard stones.\n\nYou are given an $ n \\times m $ grid map: the symbol ``*`` denotes an empty cell; the explosion can pass through it, and you can place a bomb on it. The symbol ``x`` denotes a soft stone; the explosion can pass through it, but you cannot place a bomb on it. The symbol ``#`` denotes a hard stone; the explosion cannot pass through it, and you cannot place a bomb on it. For example, given a $ 1 \\times 4 $ grid map ``*xx*``, you can place at most one bomb on this map. Given another $ 1 \\times 4 $ grid map ``*x#*``, you can place at most two bombs on this map.\n\nNow, given any $ n \\times m $ grid map from Little H, determine the maximum number of bombs that can be placed.", "inputFormat": "The first line contains two positive integers $ n, m $, where $ n $ is the number of rows and $ m $ is the number of columns.\n\nThen $ n $ lines follow, each containing $ m $ characters representing the grid map. The number of ``*`` does not exceed $ n \\times m $.", "outputFormat": "Output a single integer $ a $, the maximum number of bombs that can be placed.", "hint": "$1 \\leq n, m \\leq 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2016/TJOI2016] 游戏", "background": "", "description": "在 2016 年，佳媛姐姐喜欢上了一款游戏，叫做泡泡堂。\n\n简单的说，这个游戏就是在一张地图上放上若干个炸弹，看是否能炸到对手，或者躲开对手的炸弹。在玩游戏的过程中，小 H 想到了这样一个问题：当给定一张地图，在这张地图上最多能放上多少个炸弹能使得任意两个炸弹之间不会互相炸到。炸弹能炸到的范围是该炸弹所在的一行和一列，炸弹的威力可以穿透软石头，但是不能穿透硬石头。\n\n给定一张 $ n \\times m $ 的网格地图:其中 ``*`` 代表空地，炸弹的威力可以穿透，可以在空地上放置一枚炸弹。 ``x`` 代表软石头，炸弹的威力可以穿透，不能在此放置炸弹。``#`` 代表硬石头，炸弹的威力是不能穿透的，不能在此放置炸弹。例如：给出 $ 1 \\times 4 $ 的网格地图 `` *xx*``，这个地图上最多只能放置一个炸弹。给出另一个$ 1 \\times 4 $ 的网格地图 ``*x#*``，这个地图最多能放置两个炸弹。\n\n现在小 H 任意给出一张 $ n \\times m $ 的网格地图，问你最多能放置多少炸弹。", "inputFormat": "第一行输入两个正整数 $ n, m $，$ n $ 表示地图的行数，$ m $ 表示地图的列数。\n\n接下来输入 $ n $ 行 $ m $ 列个字符，代表网格地图。``*``的个数不超过 $ n \\times m $ 个。", "outputFormat": "输出一个整数 $ a $，表示最多能放置炸弹的个数。", "hint": "$1 \\leq n,m \\leq 50$", "locale": "zh-CN"}}}
{"pid": "P2827", "type": "P", "difficulty": 5, "samples": [["3 7 1 1 3 1\n3 3 2", "3 4 4 4 5 5 6\n6 6 6 5 5 4 4 3 2 2"], ["3 7 1 1 3 2\n3 3 2", "4 4 5\n6 5 4 3 2"], ["3 7 1 1 3 9\n3 3 2", "//空行\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "堆", "NOIP 提高组", "O2优化", "队列"], "title": "[NOIP 2016 提高组] 蚯蚓", "background": "NOIP2016 提高组 D2T2", "description": "本题中，我们将用符号 $\\lfloor c \\rfloor$ 表示对 $c$ 向下取整，例如：$\\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3$。\n\n蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。\n\n蛐蛐国里现在共有 $n$ 只蚯蚓（$n$ 为正整数）。每只蚯蚓拥有长度，我们设第 $i$ 只蚯蚓的长度为 $a_i\\,(i=1,2,\\dots,n)$，并保证所有的长度都是非负整数（即：可能存在长度为 $0$ 的蚯蚓）。\n\n每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 $p$（是满足 $0 < p < 1$ 的有理数）决定，设这只蚯蚓长度为 $x$，神刀手会将其切成两只长度分别为 $\\lfloor px \\rfloor$ 和 $x - \\lfloor px \\rfloor$ 的蚯蚓。特殊地，如果这两个数的其中一个等于 $0$，则这个长度为 $0$ 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 $q$（是一个非负整常数）。\n\n蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 $m$ 秒才能到来……（$m$ 为非负整数）\n\n蛐蛐国王希望知道这 $m$ 秒内的战况。具体来说，他希望知道：\n\n- $m$ 秒内，每一秒被切断的蚯蚓被切断前的长度（有 $m$ 个数）；\n- $m$ 秒后，所有蚯蚓的长度（有 $n + m$ 个数）。\n\n蛐蛐国王当然知道怎么做啦！但是他想考考你……", "inputFormat": "第一行包含六个整数 $n,m,q,u,v,t$，其中：$n,m,q$ 的意义见【问题描述】；$u,v,t$ 均为正整数；你需要自己计算 $p=u / v$（保证 $0 < u < v$）；$t$ 是输出参数，其含义将会在【输出格式】中解释。\n\n第二行包含 $n$ 个非负整数，为 $a_1, a_2, \\dots, a_n$，即初始时 $n$ 只蚯蚓的长度。\n\n同一行中相邻的两个数之间，恰好用一个空格隔开。\n\n保证 $1 \\leq n \\leq 10^5$，$0 \\leq m \\leq 7 \\times 10^6$，$0 < u < v \\leq 10^9$，$0 \\leq q \\leq 200$，$1 \\leq t \\leq 71$，$0 \\leq a_i \\leq 10^8$。", "outputFormat": "第一行输出 $\\left \\lfloor \\frac{m}{t} \\right \\rfloor$ 个整数，按时间顺序，依次输出第 $t$ 秒，第 $2t$ 秒，第 $3t$ 秒，……被切断蚯蚓（在被切断前）的长度。\n\n第二行输出 $\\left \\lfloor \\frac{n+m}{t} \\right \\rfloor$ 个整数，输出 $m$ 秒后蚯蚓的长度；需要按从大到小的顺序，依次输出排名第 $t$，第 $2t$，第 $3t$，……的长度。\n\n同一行中相邻的两个数之间，恰好用一个空格隔开。即使某一行没有任何数需要输出，你也应输出一个空行。\n\n请阅读样例来更好地理解这个格式。", "hint": "**样例解释 1**\n\n在神刀手到来前：$3$ 只蚯蚓的长度为 $3,3,2$。\n\n$1$ 秒后：一只长度为 $3$ 的蚯蚓被切成了两只长度分别为$1$ 和 $2$ 的蚯蚓，其余蚯蚓的长度增加了 $1$。最终 $4$ 只蚯蚓的长度分别为 $(1,2),4,3$。括号表示这个位置刚刚有一只蚯蚓被切断。\n\n$2$ 秒后：一只长度为 $4$ 的蚯蚓被切成了 $1$ 和 $3$。$5$ 只蚯蚓的长度分别为：$2,3,(1,3),4$。\n\n$3$ 秒后：一只长度为 $4$ 的蚯蚓被切断。$6$ 只蚯蚓的长度分别为：$3,4,2,4,(1,3)$。\n\n$4$ 秒后：一只长度为 $4$ 的蚯蚓被切断。$7$ 只蚯蚓的长度分别为：$4,(1,3),3,5,2,4$。\n\n$5$ 秒后：一只长度为 $5$ 的蚯蚓被切断。$8$ 只蚯蚓的长度分别为：$5,2,4,4,(1,4),3,5$。\n\n$6$ 秒后：一只长度为 $5$ 的蚯蚓被切断。$9$ 只蚯蚓的长度分别为：$(1,4),3,5,5,2,5,4,6$。\n\n$7$ 秒后：一只长度为 $6$ 的蚯蚓被切断。$10$ 只蚯蚓的长度分别为：$2,5,4,6,6,3,6,5,(2,4)$。所以，$7$ 秒内被切断的蚯蚓的长度依次为 $3,4,4,4,5,5,6$。$7$ 秒后，所有蚯蚓长度从大到小排序为 $6,6,6,5,5,4,4,3,2,2$。\n\n**样例解释 2**\n\n这个数据中只有 $t=2$ 与上个数据不同。只需在每行都改为每两个数输出一个数即可。\n\n虽然第一行最后有一个 $6$ 没有被输出，但是第二行仍然要重新从第二个数再开始输出。\n\n**样例解释 3**\n\n这个数据中只有 $t=9$ 与上个数据不同。\n\n注意第一行没有数要输出，但也要输出一个空行。\n\n\n**数据范围**\n\n::cute-table{tuack}\n| 测试点  | $n$            | $m$              | $t$   | $a_i$     | $v$       | $q$      |\n|:----:|:--------------:|:----------------:|:-----:|:---------:|:---------:|:--------:|\n| $1$  | $=1$           | $=0$             | $=1$  | $\\le10^6$ | $\\le2$    | $=0$     |\n| $2$  | $=10^3$        | ^                | ^     | ^         | ^         | ^        |\n| $3$  | $=10^5$        | ^                | ^     | ^         | ^         | ^        |\n| $4$  | $=1$           | $=10^3$          | ^     | ^         | ^         | ^        |\n| $5$  | $=10^3$        | ^                | ^     | ^         | ^         | ^        |\n| $6$  | $=1$           | ^                | ^     | ^         | ^         | $\\le200$ |\n| $7$  | $=10^3$        | ^                | ^     | ^         | ^         | ^        |\n| $8$  | $=5\\times10^4$ | $=5\\times10^4$   | ^     | ^         | ^         | $=0$     |\n| $9$  | $=10^5$        | $=10^5$          | $=2$  | ^         | ^         | ^        |\n| $10$ | ^              | $=2\\times10^6$   | $=21$ | ^         | ^         | ^        |\n| $11$ | ^              | $=2.5\\times10^6$ | $=26$ | ^         | ^         | ^        |\n| $12$ | ^              | $=3.5\\times10^6$ | $=36$ | $\\le10^7$ | ^         | ^        |\n| $13$ | ^              | $=5\\times10^6$   | $=51$ | ^         | $\\le10^9$ | ^        |\n| $14$ | ^              | $=7\\times10^6$   | $=71$ | $\\le10^8$ | ^         | ^        |\n| $15$ | $=5\\times10^4$ | $=5\\times10^4$   | $=1$  | ^         | $\\le2$    | $\\le200$ |\n| $16$ | ^              | $=1.5\\times10^5$ | $=2$  | ^         | ^         | ^        |\n| $17$ | $=10^5$        | $=10^5$          | $=3$  | ^         | $\\le10^9$ | ^        |\n| $18$ | ^              | $=3\\times10^5$   | $=4$  | ^         | ^         | ^        |\n| $19$ | ^              | $=3.5\\times10^6$ | $=36$ | ^         | ^         | ^        |\n| $20$ | ^              | $=7\\times10^6$   | $=71$ | ^         | ^         | ^        |", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2016 Senior] Earthworms", "background": "NOIP 2016 Senior D2T2.", "description": "In this problem, we use the symbol $\\lfloor c \\rfloor$ to denote the floor of $c$. For example, $\\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3$.\n\nThe Cricket Kingdom is suffering from an earthworm outbreak! Even the fleas from the neighboring Flea Kingdom can’t handle the earthworms. The Cricket King has no choice but to invite the Divine Blade Master to help eliminate them.\n\nThere are currently $n$ earthworms in the Cricket Kingdom (where $n$ is a positive integer). Each earthworm has a length. Let the length of the $i$-th earthworm be $a_i \\,(i=1,2,\\dots,n)$, and all lengths are guaranteed to be non-negative integers (i.e., earthworms with length $0$ may exist).\n\nEvery second, the Divine Blade Master will accurately find the longest earthworm among all earthworms (if there are multiple, choose any one) and cut it in half. The cutting position is determined by a constant $p$ (a rational number satisfying $0 < p < 1$). Suppose the length of this earthworm is $x$. The master will cut it into two earthworms with lengths $\\lfloor p x \\rfloor$ and $x - \\lfloor p x \\rfloor$. In particular, if either of these numbers equals $0$, that earthworm of length $0$ is also kept. In addition, except for the two newly created earthworms, the lengths of all other earthworms will increase by $q$ (a non-negative integer constant).\n\nThe Cricket King knows this is not a long-term solution, because not only will the number of earthworms increase, but they will also become longer. The king decides to seek help from a mysterious figure with great power, but the reinforcements will take $m$ seconds to arrive... (where $m$ is a non-negative integer).\n\nThe king wants to know the situation within these $m$ seconds. Specifically, he wants to know:\n- Within $m$ seconds, for each second, the length of the earthworm that is cut, measured just before it is cut (there are $m$ numbers).\n- After $m$ seconds, the lengths of all earthworms (there are $n + m$ numbers).\n\nOf course, the Cricket King knows how to do this! But he wants to test you.", "inputFormat": "The first line contains six integers $n,m,q,u,v,t$, where: the meanings of $n,m,q$ are as in [Description]; $u,v,t$ are positive integers; you need to compute $p = u / v$ yourself (guaranteed $0 < u < v$); $t$ is an output parameter, whose meaning will be explained in [Output Format].\n\nThe second line contains $n$ non-negative integers, namely $a_1, a_2, \\dots, a_n$, the initial lengths of the $n$ earthworms.\n\nBetween any two adjacent numbers on the same line, there is exactly one space.\n\nIt is guaranteed that $1 \\leq n \\leq 10^5$, $0 \\leq m \\leq 7 \\times 10^6$, $0 < u < v \\leq 10^9$, $0 \\leq q \\leq 200$, $1 \\leq t \\leq 71$, $0 \\leq a_i \\leq 10^8$.", "outputFormat": "On the first line, output $\\left\\lfloor \\frac{m}{t} \\right\\rfloor$ integers. In chronological order, output the length (just before being cut) of the earthworm cut at time $t$, $2t$, $3t$, … .\n\nOn the second line, output $\\left\\lfloor \\frac{n+m}{t} \\right\\rfloor$ integers: after $m$ seconds, output the earthworm lengths in non-increasing order, specifically the $t$-th, $2t$-th, $3t$-th, … largest lengths.\n\nBetween any two adjacent numbers on the same line, there is exactly one space. Even if a line has no numbers to output, you must still output a blank line.\n\nPlease read the samples to better understand this format.", "hint": "Sample Explanation 1\n\nBefore the Divine Blade Master arrives: the lengths of $3$ earthworms are $3, 3, 2$.\n\nAfter $1$ second: one earthworm of length $3$ is cut into two earthworms of lengths $1$ and $2$; the other earthworms increase by $1$. In the end, the $4$ earthworms have lengths $(1,2), 4, 3$. Parentheses mean an earthworm at that position has just been cut.\n\nAfter $2$ seconds: one earthworm of length $4$ is cut into $1$ and $3$. The $5$ earthworms’ lengths are: $2, 3, (1,3), 4$.\n\nAfter $3$ seconds: one earthworm of length $4$ is cut. The $6$ earthworms’ lengths are: $3, 4, 2, 4, (1,3)$.\n\nAfter $4$ seconds: one earthworm of length $4$ is cut. The $7$ earthworms’ lengths are: $4, (1,3), 3, 5, 2, 4$.\n\nAfter $5$ seconds: one earthworm of length $5$ is cut. The $8$ earthworms’ lengths are: $5, 2, 4, 4, (1,4), 3, 5$.\n\nAfter $6$ seconds: one earthworm of length $5$ is cut. The $9$ earthworms’ lengths are: $(1,4), 3, 5, 5, 2, 5, 4, 6$.\n\nAfter $7$ seconds: one earthworm of length $6$ is cut. The $10$ earthworms’ lengths are: $2, 5, 4, 6, 6, 3, 6, 5, (2,4)$. Therefore, within $7$ seconds, the lengths of the cut earthworms are $3, 4, 4, 4, 5, 5, 6$ in order. After $7$ seconds, all earthworm lengths in non-increasing order are $6, 6, 6, 5, 5, 4, 4, 3, 2, 2$.\n\nSample Explanation 2\n\nIn this testdata, only $t = 2$ differs from the previous one. You only need to output one number every two numbers on each line.\n\nAlthough the last $6$ on the first line is not output, the second line must restart counting from the second number.\n\nSample Explanation 3\n\nIn this testdata, only $t = 9$ differs from the previous one.\n\nNote that there are no numbers to output on the first line, but you must still print a blank line.\n\nConstraints\n\n![](https://cdn.luogu.com.cn/upload/pic/3458.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2016 提高组] 蚯蚓", "background": "NOIP2016 提高组 D2T2", "description": "本题中，我们将用符号 $\\lfloor c \\rfloor$ 表示对 $c$ 向下取整，例如：$\\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3$。\n\n蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。\n\n蛐蛐国里现在共有 $n$ 只蚯蚓（$n$ 为正整数）。每只蚯蚓拥有长度，我们设第 $i$ 只蚯蚓的长度为 $a_i\\,(i=1,2,\\dots,n)$，并保证所有的长度都是非负整数（即：可能存在长度为 $0$ 的蚯蚓）。\n\n每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 $p$（是满足 $0 < p < 1$ 的有理数）决定，设这只蚯蚓长度为 $x$，神刀手会将其切成两只长度分别为 $\\lfloor px \\rfloor$ 和 $x - \\lfloor px \\rfloor$ 的蚯蚓。特殊地，如果这两个数的其中一个等于 $0$，则这个长度为 $0$ 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 $q$（是一个非负整常数）。\n\n蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 $m$ 秒才能到来……（$m$ 为非负整数）\n\n蛐蛐国王希望知道这 $m$ 秒内的战况。具体来说，他希望知道：\n\n- $m$ 秒内，每一秒被切断的蚯蚓被切断前的长度（有 $m$ 个数）；\n- $m$ 秒后，所有蚯蚓的长度（有 $n + m$ 个数）。\n\n蛐蛐国王当然知道怎么做啦！但是他想考考你……", "inputFormat": "第一行包含六个整数 $n,m,q,u,v,t$，其中：$n,m,q$ 的意义见【问题描述】；$u,v,t$ 均为正整数；你需要自己计算 $p=u / v$（保证 $0 < u < v$）；$t$ 是输出参数，其含义将会在【输出格式】中解释。\n\n第二行包含 $n$ 个非负整数，为 $a_1, a_2, \\dots, a_n$，即初始时 $n$ 只蚯蚓的长度。\n\n同一行中相邻的两个数之间，恰好用一个空格隔开。\n\n保证 $1 \\leq n \\leq 10^5$，$0 \\leq m \\leq 7 \\times 10^6$，$0 < u < v \\leq 10^9$，$0 \\leq q \\leq 200$，$1 \\leq t \\leq 71$，$0 \\leq a_i \\leq 10^8$。", "outputFormat": "第一行输出 $\\left \\lfloor \\frac{m}{t} \\right \\rfloor$ 个整数，按时间顺序，依次输出第 $t$ 秒，第 $2t$ 秒，第 $3t$ 秒，……被切断蚯蚓（在被切断前）的长度。\n\n第二行输出 $\\left \\lfloor \\frac{n+m}{t} \\right \\rfloor$ 个整数，输出 $m$ 秒后蚯蚓的长度；需要按从大到小的顺序，依次输出排名第 $t$，第 $2t$，第 $3t$，……的长度。\n\n同一行中相邻的两个数之间，恰好用一个空格隔开。即使某一行没有任何数需要输出，你也应输出一个空行。\n\n请阅读样例来更好地理解这个格式。", "hint": "**样例解释 1**\n\n在神刀手到来前：$3$ 只蚯蚓的长度为 $3,3,2$。\n\n$1$ 秒后：一只长度为 $3$ 的蚯蚓被切成了两只长度分别为$1$ 和 $2$ 的蚯蚓，其余蚯蚓的长度增加了 $1$。最终 $4$ 只蚯蚓的长度分别为 $(1,2),4,3$。括号表示这个位置刚刚有一只蚯蚓被切断。\n\n$2$ 秒后：一只长度为 $4$ 的蚯蚓被切成了 $1$ 和 $3$。$5$ 只蚯蚓的长度分别为：$2,3,(1,3),4$。\n\n$3$ 秒后：一只长度为 $4$ 的蚯蚓被切断。$6$ 只蚯蚓的长度分别为：$3,4,2,4,(1,3)$。\n\n$4$ 秒后：一只长度为 $4$ 的蚯蚓被切断。$7$ 只蚯蚓的长度分别为：$4,(1,3),3,5,2,4$。\n\n$5$ 秒后：一只长度为 $5$ 的蚯蚓被切断。$8$ 只蚯蚓的长度分别为：$5,2,4,4,(1,4),3,5$。\n\n$6$ 秒后：一只长度为 $5$ 的蚯蚓被切断。$9$ 只蚯蚓的长度分别为：$(1,4),3,5,5,2,5,4,6$。\n\n$7$ 秒后：一只长度为 $6$ 的蚯蚓被切断。$10$ 只蚯蚓的长度分别为：$2,5,4,6,6,3,6,5,(2,4)$。所以，$7$ 秒内被切断的蚯蚓的长度依次为 $3,4,4,4,5,5,6$。$7$ 秒后，所有蚯蚓长度从大到小排序为 $6,6,6,5,5,4,4,3,2,2$。\n\n**样例解释 2**\n\n这个数据中只有 $t=2$ 与上个数据不同。只需在每行都改为每两个数输出一个数即可。\n\n虽然第一行最后有一个 $6$ 没有被输出，但是第二行仍然要重新从第二个数再开始输出。\n\n**样例解释 3**\n\n这个数据中只有 $t=9$ 与上个数据不同。\n\n注意第一行没有数要输出，但也要输出一个空行。\n\n\n**数据范围**\n\n::cute-table{tuack}\n| 测试点  | $n$            | $m$              | $t$   | $a_i$     | $v$       | $q$      |\n|:----:|:--------------:|:----------------:|:-----:|:---------:|:---------:|:--------:|\n| $1$  | $=1$           | $=0$             | $=1$  | $\\le10^6$ | $\\le2$    | $=0$     |\n| $2$  | $=10^3$        | ^                | ^     | ^         | ^         | ^        |\n| $3$  | $=10^5$        | ^                | ^     | ^         | ^         | ^        |\n| $4$  | $=1$           | $=10^3$          | ^     | ^         | ^         | ^        |\n| $5$  | $=10^3$        | ^                | ^     | ^         | ^         | ^        |\n| $6$  | $=1$           | ^                | ^     | ^         | ^         | $\\le200$ |\n| $7$  | $=10^3$        | ^                | ^     | ^         | ^         | ^        |\n| $8$  | $=5\\times10^4$ | $=5\\times10^4$   | ^     | ^         | ^         | $=0$     |\n| $9$  | $=10^5$        | $=10^5$          | $=2$  | ^         | ^         | ^        |\n| $10$ | ^              | $=2\\times10^6$   | $=21$ | ^         | ^         | ^        |\n| $11$ | ^              | $=2.5\\times10^6$ | $=26$ | ^         | ^         | ^        |\n| $12$ | ^              | $=3.5\\times10^6$ | $=36$ | $\\le10^7$ | ^         | ^        |\n| $13$ | ^              | $=5\\times10^6$   | $=51$ | ^         | $\\le10^9$ | ^        |\n| $14$ | ^              | $=7\\times10^6$   | $=71$ | $\\le10^8$ | ^         | ^        |\n| $15$ | $=5\\times10^4$ | $=5\\times10^4$   | $=1$  | ^         | $\\le2$    | $\\le200$ |\n| $16$ | ^              | $=1.5\\times10^5$ | $=2$  | ^         | ^         | ^        |\n| $17$ | $=10^5$        | $=10^5$          | $=3$  | ^         | $\\le10^9$ | ^        |\n| $18$ | ^              | $=3\\times10^5$   | $=4$  | ^         | ^         | ^        |\n| $19$ | ^              | $=3.5\\times10^6$ | $=36$ | ^         | ^         | ^        |\n| $20$ | ^              | $=7\\times10^6$   | $=71$ | ^         | ^         | ^        |", "locale": "zh-CN"}}}
{"pid": "P2829", "type": "P", "difficulty": 5, "samples": [["4 4 1\n1 2 100\n2 4 200\n2 3 250\n3 4 100", "450"], ["4 4 3\n1 2 100\n2 4 200\n2 3 250\n3 4 100", "500"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "最短路"], "title": "大逃离", "background": "zrz 走进了一个奇葩的迷宫，他发现自己迷路了，想逃出来，他好不容易数完了所有的路，累的快晕了，只好叫你帮忙咯。", "description": "这是一张有 $n$ 个节点，$m$ 条双向边的图，每一条边有 $w$ 个单位距离，zrz 在 $1$ 的位置，出口在 $n$ 的位置。\n\n不过 zrz 脑子出了点 bug，不想走最短的路，想走第二短的路。第二短路径允许与最短路径有重边，也可以重复通过一些节点和边。注意，如果有多条路径都是最短路径，那么他们都不能叫第二短路径。\n\n另外，如果接下来进入的一个节点，它所直接连接的地方小于 $k$ 个（起点和终点除外），那么 zrz 就会不敢进去。", "inputFormat": "第一行三个数：$n,m,k$。\n\n接下来 $m$ 行，每行三个数 $u,v,w$，表示 $u$ 和 $v$ 之间有一条权值为 $w$ 的双向边。", "outputFormat": "一个数，表示从 $1$ 走到 $n$ 的第二短路的值，如果不存在，输出 $-1$。", "hint": "对于 $50\\%$ 的数据：$n \\leq 10$，$m \\leq 10$；\n\n对于 $90\\%$ 的数据：$n \\leq 1000$，$m \\leq 20000$；\n\n对于 $100\\%$ 的数据：$1\\leq n \\leq 5000$，$1\\leq m \\leq 100000$，$1\\leq u,v \\leq n$，$1\\leq w\\leq 10000$。\n\n另外，$k$ 比较小。\n\n样例 $2$ 最短路径是 $300$（`1-2-4`）。因为无法从 $2$ 走到 $3$（$3$ 连接到节点只有 $2$ 个），所以可以 `1-2-1-2-4`，第二短路为 $500$。", "locale": "zh-CN", "translations": {"en": {"title": "The Great Escape", "background": "zrz walked into a peculiar maze. He found himself lost and wanted to get out. After barely finishing counting all the roads, he was so tired that he almost fainted, so he asked you for help.", "description": "This is a graph with $n$ nodes and $m$ undirected edges. Each edge has a length of $w$ units. zrz is at position $1$, and the exit is at position $n$.\n\nHowever, zrz’s brain has a little bug: he does not want the shortest path; he wants the second-shortest path. The second-shortest path may share edges with the shortest path and may pass through some nodes and edges multiple times. Note that if there are multiple paths that are all shortest, none of them can be called the second-shortest path.\n\nIn addition, if the next node to enter has fewer than $k$ directly connected neighbors (excluding the start and the exit), then zrz will not dare to enter it.", "inputFormat": "The first line contains three numbers: $n, m, k$.\n\nThe next $m$ lines each contain three numbers $u, v, w$, indicating there is an undirected edge of weight $w$ between $u$ and $v$.", "outputFormat": "Output a single number: the length of the second-shortest path from $1$ to $n$. If it does not exist, output $-1$.", "hint": "Constraints:\n- For $50\\%$ of the testdata: $n \\leq 10$, $m \\leq 10$.\n- For $90\\%$ of the testdata: $n \\leq 1000$, $m \\leq 20000$.\n- For $100\\%$ of the testdata: $1 \\leq n \\leq 5000$, $1 \\leq m \\leq 100000$, $1 \\leq u, v \\leq n$, $1 \\leq w \\leq 10000$.\n\nAlso, $k$ is relatively small.\n\nIn Sample $2$, the shortest path is $300$ (`1-2-4`). Because it is impossible to go from $2$ to $3$ ($3$ is connected to only $2$ nodes), it is allowed to go `1-2-1-2-4`, and the second-shortest path is $500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "大逃离", "background": "zrz 走进了一个奇葩的迷宫，他发现自己迷路了，想逃出来，他好不容易数完了所有的路，累的快晕了，只好叫你帮忙咯。", "description": "这是一张有 $n$ 个节点，$m$ 条双向边的图，每一条边有 $w$ 个单位距离，zrz 在 $1$ 的位置，出口在 $n$ 的位置。\n\n不过 zrz 脑子出了点 bug，不想走最短的路，想走第二短的路。第二短路径允许与最短路径有重边，也可以重复通过一些节点和边。注意，如果有多条路径都是最短路径，那么他们都不能叫第二短路径。\n\n另外，如果接下来进入的一个节点，它所直接连接的地方小于 $k$ 个（起点和终点除外），那么 zrz 就会不敢进去。", "inputFormat": "第一行三个数：$n,m,k$。\n\n接下来 $m$ 行，每行三个数 $u,v,w$，表示 $u$ 和 $v$ 之间有一条权值为 $w$ 的双向边。", "outputFormat": "一个数，表示从 $1$ 走到 $n$ 的第二短路的值，如果不存在，输出 $-1$。", "hint": "对于 $50\\%$ 的数据：$n \\leq 10$，$m \\leq 10$；\n\n对于 $90\\%$ 的数据：$n \\leq 1000$，$m \\leq 20000$；\n\n对于 $100\\%$ 的数据：$1\\leq n \\leq 5000$，$1\\leq m \\leq 100000$，$1\\leq u,v \\leq n$，$1\\leq w\\leq 10000$。\n\n另外，$k$ 比较小。\n\n样例 $2$ 最短路径是 $300$（`1-2-4`）。因为无法从 $2$ 走到 $3$（$3$ 连接到节点只有 $2$ 个），所以可以 `1-2-1-2-4`，第二短路为 $500$。", "locale": "zh-CN"}}}
{"pid": "P2830", "type": "P", "difficulty": 4, "samples": [["int a[10]\na[a[0]] 2\ncout a[0]", "2"], ["int a[10]\na[0] 10\ncout a[0]\na[a[0]] 1\ncout a[0]", "10\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "写程序", "background": "zrz 在写程序，他叫你帮他看看他的程序有没有问题。", "description": "有一个若干行的程序，每一行只有一个命令，可能出现的命令有一下几种：\n\n- `int a[N]` 声明一个数组，开头一定是 `int`，不会是别的什么 `long long` 之类的，`a` 是指一个数组的名称（不一定是 `a`，也有可能是别的字母或者多个字母，总之长度不超过 $10$），后面是一个中括号和**一个数字或一个变量**，表示数组大小（从 $0$ 到 $N-1$，$N\\le100$），数组声明之后里面的数均为 $0$。\n- `a[i] h` 把 `h` 赋给 `a[i]`（也就是 `a[i]=h`），同样 $h$ 可能是**一个数字或者是一个变量**，$i$ 代表一个数字或者是一个变量。\n- `cout h` 输出 $h$，$h$ 一定是个变量。\n\n对于以下两种情况，不管是哪个命令，都要立即停止，无论下面有多少行命令都忽略，并输出 `-1`：\n\n* 在某一行发现有数组下标越界。\n\n* 定义了一个大小为 $0$ 的数组。", "inputFormat": "若干行：每行一个命令。", "outputFormat": "对于每一个输出的命令（即 `cout`），按题目要求，输出一行。", "hint": "行数不超过 $10$，变量可能嵌套，如 `a[a[b[0]]]` 等等，也有可能出现大写字母，所有的出现的数字不会超过 $10^9$，也不会是负数，更不会是小数。", "locale": "zh-CN", "translations": {"en": {"title": "Write a Program", "background": "zrz is writing a program. He asks you to check whether there are any problems with his program.", "description": "There is a program with several lines, and each line contains exactly one command. The possible commands are as follows:\n\n- `int a[N]` Declare an array. The keyword is always `int`, never something else like `long long`. `a` denotes the name of an array (not necessarily `a`; it could be another letter or multiple letters, with length no more than $10$). After that is a pair of brackets containing either a number or a variable, indicating the array size (indices range from $0$ to $N-1$, $N\\le100$). After the array is declared, all its elements are $0$.\n- `a[i] h` Assign `h` to `a[i]` (i.e., `a[i]=h`). Here $h$ can be either a number or a variable, and $i$ can be either a number or a variable.\n- `cout h` Output $h$, where $h$ must be a variable.", "inputFormat": "Several lines: one command per line.", "outputFormat": "For each output command (i.e., `cout`), print one line.\n\nIf an out-of-bounds array index is found on any line (note that only this type of error can occur; there will not be other issues such as redefinition), stop immediately regardless of how many commands remain below, ignore all remaining commands, and output `-1`.", "hint": "The number of lines does not exceed $10$. Variables may be nested, such as `a[a[b[0]]]`, etc. Uppercase letters may also appear. All numbers that appear do not exceed $10^9$, are not negative, and are not decimals.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "写程序", "background": "zrz 在写程序，他叫你帮他看看他的程序有没有问题。", "description": "有一个若干行的程序，每一行只有一个命令，可能出现的命令有一下几种：\n\n- `int a[N]` 声明一个数组，开头一定是 `int`，不会是别的什么 `long long` 之类的，`a` 是指一个数组的名称（不一定是 `a`，也有可能是别的字母或者多个字母，总之长度不超过 $10$），后面是一个中括号和**一个数字或一个变量**，表示数组大小（从 $0$ 到 $N-1$，$N\\le100$），数组声明之后里面的数均为 $0$。\n- `a[i] h` 把 `h` 赋给 `a[i]`（也就是 `a[i]=h`），同样 $h$ 可能是**一个数字或者是一个变量**，$i$ 代表一个数字或者是一个变量。\n- `cout h` 输出 $h$，$h$ 一定是个变量。\n\n对于以下两种情况，不管是哪个命令，都要立即停止，无论下面有多少行命令都忽略，并输出 `-1`：\n\n* 在某一行发现有数组下标越界。\n\n* 定义了一个大小为 $0$ 的数组。", "inputFormat": "若干行：每行一个命令。", "outputFormat": "对于每一个输出的命令（即 `cout`），按题目要求，输出一行。", "hint": "行数不超过 $10$，变量可能嵌套，如 `a[a[b[0]]]` 等等，也有可能出现大写字母，所有的出现的数字不会超过 $10^9$，也不会是负数，更不会是小数。", "locale": "zh-CN"}}}
{"pid": "P2831", "type": "P", "difficulty": 5, "samples": [["2\n2 0\n1.00 3.00\n3.00 3.00\n5 2\n1.00 5.00\n2.00 8.00\n3.00 9.00\n4.00 8.00\n5.00 5.00", "1\n1"], ["3\n2 0\n1.41 2.00\n1.73 3.00\n3 0\n1.11 1.41\n2.34 1.79\n2.98 1.49\n5 0\n2.72 2.72\n2.72 3.14\n3.14 2.72\n3.14 3.14\n5.00 5.00", "2\n2\n3\n"], ["1\n10 0\n7.16 6.28\n2.02 0.38\n8.33 7.78\n7.68 2.09\n7.46 7.86\n5.77 7.44\n8.24 6.72\n4.42 5.11\n5.42 7.79\n8.15 4.99", "6\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["搜索", "2016", "NOIP 提高组", "状压 DP"], "title": "[NOIP 2016 提高组] 愤怒的小鸟", "background": "NOIP2016 提高组 D2T3", "description": "Kiana 最近沉迷于一款神奇的游戏无法自拔。\n\n简单来说，这款游戏是在一个平面上进行的。\n\n有一架弹弓位于 $(0,0)$ 处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 $y=ax^2+bx$ 的曲线，其中 $a,b$ 是 Kiana 指定的参数，且必须满足 $a < 0$，$a,b$ 都是实数。\n\n当小鸟落回地面（即 $x$ 轴）时，它就会瞬间消失。\n\n在游戏的某个关卡里，平面的第一象限中有 $n$ 只绿色的小猪，其中第 $i$ 只小猪所在的坐标为 $\\left(x_i,y_i \\right)$。\n\n如果某只小鸟的飞行轨迹经过了 $\\left( x_i, y_i \\right)$，那么第 $i$ 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；\n\n如果一只小鸟的飞行轨迹没有经过 $\\left( x_i, y_i \\right)$，那么这只小鸟飞行的全过程就不会对第 $i$ 只小猪产生任何影响。\n\n例如，若两只小猪分别位于 $(1,3)$ 和 $(3,3)$，Kiana 可以选择发射一只飞行轨迹为 $y=-x^2+4x$ 的小鸟，这样两只小猪就会被这只小鸟一起消灭。\n\n而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。\n\n这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在【输入格式】中详述。\n\n假设这款游戏一共有 $T$ 个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。", "inputFormat": "第一行包含一个正整数 $T$，表示游戏的关卡总数。\n\n下面依次输入这 $T$ 个关卡的信息。每个关卡第一行包含两个非负整数 $n,m$，分别表示该关卡中的小猪数量和 Kiana 输入的神秘指令类型。接下来的 $n$ 行中，第 $i$ 行包含两个正实数 $x_i,y_i$，表示第 $i$ 只小猪坐标为 $(x_i,y_i)$。数据保证同一个关卡中不存在两只坐标完全相同的小猪。\n\n如果 $m=0$，表示 Kiana 输入了一个没有任何作用的指令。\n\n如果 $m=1$，则这个关卡将会满足：至多用 $\\lceil n/3 + 1 \\rceil$ 只小鸟即可消灭所有小猪。\n\n如果 $m=2$，则这个关卡将会满足：一定存在一种最优解，其中有一只小鸟消灭了至少 $\\lfloor n/3 \\rfloor$ 只小猪。\n\n保证 $1\\leq n \\leq 18$，$0\\leq m \\leq 2$，$0 < x_i,y_i < 10$，输入中的实数均保留到小数点后两位。\n\n上文中，符号 $\\lceil c \\rceil$ 和 $\\lfloor c \\rfloor$ 分别表示对 $c$ 向上取整和向下取整，例如：$\\lceil 2.1 \\rceil = \\lceil 2.9 \\rceil = \\lceil 3.0 \\rceil = \\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3$。", "outputFormat": "对每个关卡依次输出一行答案。\n\n输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小猪最少需要的小鸟数量。", "hint": "【样例解释1】\n\n这组数据中一共有两个关卡。\n\n第一个关卡与【问题描述】中的情形相同，$2$ 只小猪分别位于 $(1.00,3.00)$ 和 $(3.00,3.00)$，只需发射一只飞行轨迹为 $y = -x^2 + 4x$ 的小鸟即可消灭它们。\n\n第二个关卡中有 $5$ 只小猪，但经过观察我们可以发现它们的坐标都在抛物线 $y = -x^2 + 6x$上，故 Kiana 只需要发射一只小鸟即可消灭所有小猪。\n\n【数据范围】\n\n| 测试点编号 |   $n\\leqslant$ |   $m=$ |  $T\\leqslant$ |\n| :----------: | :----------: | :----------: | :----------: |\n|   $1$ |   $2$ |   $0$ |  $10$ |\n|   $2$ |   $2$ |   $0$ |  $30$ |\n|   $3$ |   $3$ |   $0$ |  $10$ |\n|   $4$ |   $3$ |   $0$ |  $30$ |\n|   $5$ |   $4$ |   $0$ |  $10$ |\n|   $6$ |   $4$ |   $0$ |  $30$ |\n|   $7$ |   $5$ |   $0$ |  $10$ |\n|   $8$ |   $6$ |   $0$ |  $10$ |\n|   $9$ |   $7$ |   $0$ |  $10$ |\n|   $10$ |   $8$ |   $0$ |  $10$ |\n|   $11$ |   $9$ |   $0$ |  $30$ |\n|   $12$ |   $10$ |   $0$ |  $30$ |\n|   $13$ |   $12$ |   $1$ |  $30$ |\n|   $14$ |   $12$ |   $2$ |  $30$ |\n|   $15$ |   $15$ |   $0$ |  $15$ |\n|   $16$ |   $15$ |   $1$ |  $15$ |\n|   $17$ |   $15$ |   $2$ |  $15$ |\n|   $18$ |   $18$ |   $0$ |  $5$ |\n|   $19$ |   $18$ |   $1$ |  $5$ |\n|   $20$ |   $18$ |   $2$ |  $5$ |", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2016 Senior] Angry Birds", "background": "NOIP 2016 Senior Day 2 Task 3.", "description": "Kiana has recently become addicted to a magical game.\n\nSimply put, this game takes place on a plane.\n\nThere is a slingshot at $ (0, 0) $. Each time, Kiana can use it to launch a red bird toward the first quadrant. The flight trajectory of a bird is a curve of the form $ y = a x^2 + b x $, where $ a, b $ are parameters chosen by Kiana and must satisfy $ a < 0 $, with $ a, b $ being real numbers.\n\nWhen a bird falls back to the ground (i.e., the $ x $-axis), it disappears instantly.\n\nIn a certain level of the game, there are $ n $ green pigs in the first quadrant of the plane. The $ i $-th pig is at coordinates $ \\left( x_i, y_i \\right) $.\n\nIf a bird’s trajectory passes through $ \\left( x_i, y_i \\right) $, then the $ i $-th pig will be eliminated, and the bird will continue along its original trajectory. If a bird’s trajectory does not pass through $ \\left( x_i, y_i \\right) $, then that bird’s entire flight has no effect on the $ i $-th pig.\n\nFor example, if two pigs are at $ (1, 3) $ and $ (3, 3) $, Kiana can choose to launch a bird with trajectory $ y = -x^2 + 4x $, and both pigs will be eliminated by this bird.\n\nThe goal of the game is to eliminate all the pigs by launching birds.\n\nEach level of this magical game is difficult for Kiana, so she also entered some mysterious commands to make it easier to complete the game. These commands are detailed in Input Format.\n\nAssume the game has $ T $ levels. Now Kiana wants to know, for each level, the minimum number of birds needed to eliminate all the pigs. Since she cannot compute it herself, she hopes you will tell her.", "inputFormat": "The first line contains a positive integer $ T $, the total number of levels in the game.\n\nThen, for each of the $ T $ levels, the first line contains two non-negative integers $ n, m $, representing the number of pigs in that level and the type of mysterious command Kiana entered, respectively. The next $ n $ lines each contain two positive real numbers $ x_i, y_i $, indicating that the $ i $-th pig is at $ (x_i, y_i) $. It is guaranteed that no two pigs in the same level share identical coordinates.\n\nIf $ m = 0 $, it means Kiana entered a command that has no effect.\n\nIf $ m = 1 $, then this level satisfies: at most $ \\lceil n / 3 + 1 \\rceil $ birds are sufficient to eliminate all pigs.\n\nIf $ m = 2 $, then this level satisfies: there is an optimal solution in which one bird eliminates at least $ \\lfloor n / 3 \\rfloor $ pigs.\n\nIt is guaranteed that $ 1 \\leq n \\leq 18 $, $ 0 \\leq m \\leq 2 $, and $ 0 < x_i, y_i < 10 $. All real numbers in the input are given to two decimal places.\n\nIn the above, the symbols $ \\lceil c \\rceil $ and $ \\lfloor c \\rfloor $ denote the ceiling and floor of $ c $, respectively. For example: $ \\lceil 2.1 \\rceil = \\lceil 2.9 \\rceil = \\lceil 3.0 \\rceil = \\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3 $.", "outputFormat": "For each level, output one line with a positive integer: the minimum number of birds needed to eliminate all pigs in that level.", "hint": "Sample Explanation 1.\n\nThere are two levels in this set of testdata.\n\nIn the first level, as in the Description, $ 2 $ pigs are at $ (1.00, 3.00) $ and $ (3.00, 3.00) $. Launching one bird with trajectory $ y = -x^2 + 4x $ is enough to eliminate them.\n\nIn the second level, there are $ 5 $ pigs, and by observation they all lie on the parabola $ y = -x^2 + 6x $, so Kiana needs to launch only one bird to eliminate all pigs.\n\nConstraints\n\n| Test point ID | $n\\leqslant$ | $m=$ | $T\\leqslant$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2$ | $0$ | $10$ |\n| $2$ | $2$ | $0$ | $30$ |\n| $3$ | $3$ | $0$ | $10$ |\n| $4$ | $3$ | $0$ | $30$ |\n| $5$ | $4$ | $0$ | $10$ |\n| $6$ | $4$ | $0$ | $30$ |\n| $7$ | $5$ | $0$ | $10$ |\n| $8$ | $6$ | $0$ | $10$ |\n| $9$ | $7$ | $0$ | $10$ |\n| $10$ | $8$ | $0$ | $10$ |\n| $11$ | $9$ | $0$ | $30$ |\n| $12$ | $10$ | $0$ | $30$ |\n| $13$ | $12$ | $1$ | $30$ |\n| $14$ | $12$ | $2$ | $30$ |\n| $15$ | $15$ | $0$ | $15$ |\n| $16$ | $15$ | $1$ | $15$ |\n| $17$ | $15$ | $2$ | $15$ |\n| $18$ | $18$ | $0$ | $5$ |\n| $19$ | $18$ | $1$ | $5$ |\n| $20$ | $18$ | $2$ | $5$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2016 提高组] 愤怒的小鸟", "background": "NOIP2016 提高组 D2T3", "description": "Kiana 最近沉迷于一款神奇的游戏无法自拔。\n\n简单来说，这款游戏是在一个平面上进行的。\n\n有一架弹弓位于 $(0,0)$ 处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 $y=ax^2+bx$ 的曲线，其中 $a,b$ 是 Kiana 指定的参数，且必须满足 $a < 0$，$a,b$ 都是实数。\n\n当小鸟落回地面（即 $x$ 轴）时，它就会瞬间消失。\n\n在游戏的某个关卡里，平面的第一象限中有 $n$ 只绿色的小猪，其中第 $i$ 只小猪所在的坐标为 $\\left(x_i,y_i \\right)$。\n\n如果某只小鸟的飞行轨迹经过了 $\\left( x_i, y_i \\right)$，那么第 $i$ 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；\n\n如果一只小鸟的飞行轨迹没有经过 $\\left( x_i, y_i \\right)$，那么这只小鸟飞行的全过程就不会对第 $i$ 只小猪产生任何影响。\n\n例如，若两只小猪分别位于 $(1,3)$ 和 $(3,3)$，Kiana 可以选择发射一只飞行轨迹为 $y=-x^2+4x$ 的小鸟，这样两只小猪就会被这只小鸟一起消灭。\n\n而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。\n\n这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在【输入格式】中详述。\n\n假设这款游戏一共有 $T$ 个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。", "inputFormat": "第一行包含一个正整数 $T$，表示游戏的关卡总数。\n\n下面依次输入这 $T$ 个关卡的信息。每个关卡第一行包含两个非负整数 $n,m$，分别表示该关卡中的小猪数量和 Kiana 输入的神秘指令类型。接下来的 $n$ 行中，第 $i$ 行包含两个正实数 $x_i,y_i$，表示第 $i$ 只小猪坐标为 $(x_i,y_i)$。数据保证同一个关卡中不存在两只坐标完全相同的小猪。\n\n如果 $m=0$，表示 Kiana 输入了一个没有任何作用的指令。\n\n如果 $m=1$，则这个关卡将会满足：至多用 $\\lceil n/3 + 1 \\rceil$ 只小鸟即可消灭所有小猪。\n\n如果 $m=2$，则这个关卡将会满足：一定存在一种最优解，其中有一只小鸟消灭了至少 $\\lfloor n/3 \\rfloor$ 只小猪。\n\n保证 $1\\leq n \\leq 18$，$0\\leq m \\leq 2$，$0 < x_i,y_i < 10$，输入中的实数均保留到小数点后两位。\n\n上文中，符号 $\\lceil c \\rceil$ 和 $\\lfloor c \\rfloor$ 分别表示对 $c$ 向上取整和向下取整，例如：$\\lceil 2.1 \\rceil = \\lceil 2.9 \\rceil = \\lceil 3.0 \\rceil = \\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3$。", "outputFormat": "对每个关卡依次输出一行答案。\n\n输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小猪最少需要的小鸟数量。", "hint": "【样例解释1】\n\n这组数据中一共有两个关卡。\n\n第一个关卡与【问题描述】中的情形相同，$2$ 只小猪分别位于 $(1.00,3.00)$ 和 $(3.00,3.00)$，只需发射一只飞行轨迹为 $y = -x^2 + 4x$ 的小鸟即可消灭它们。\n\n第二个关卡中有 $5$ 只小猪，但经过观察我们可以发现它们的坐标都在抛物线 $y = -x^2 + 6x$上，故 Kiana 只需要发射一只小鸟即可消灭所有小猪。\n\n【数据范围】\n\n| 测试点编号 |   $n\\leqslant$ |   $m=$ |  $T\\leqslant$ |\n| :----------: | :----------: | :----------: | :----------: |\n|   $1$ |   $2$ |   $0$ |  $10$ |\n|   $2$ |   $2$ |   $0$ |  $30$ |\n|   $3$ |   $3$ |   $0$ |  $10$ |\n|   $4$ |   $3$ |   $0$ |  $30$ |\n|   $5$ |   $4$ |   $0$ |  $10$ |\n|   $6$ |   $4$ |   $0$ |  $30$ |\n|   $7$ |   $5$ |   $0$ |  $10$ |\n|   $8$ |   $6$ |   $0$ |  $10$ |\n|   $9$ |   $7$ |   $0$ |  $10$ |\n|   $10$ |   $8$ |   $0$ |  $10$ |\n|   $11$ |   $9$ |   $0$ |  $30$ |\n|   $12$ |   $10$ |   $0$ |  $30$ |\n|   $13$ |   $12$ |   $1$ |  $30$ |\n|   $14$ |   $12$ |   $2$ |  $30$ |\n|   $15$ |   $15$ |   $0$ |  $15$ |\n|   $16$ |   $15$ |   $1$ |  $15$ |\n|   $17$ |   $15$ |   $2$ |  $15$ |\n|   $18$ |   $18$ |   $0$ |  $5$ |\n|   $19$ |   $18$ |   $1$ |  $5$ |\n|   $20$ |   $18$ |   $2$ |  $5$ |", "locale": "zh-CN"}}}
{"pid": "P2832", "type": "P", "difficulty": 5, "samples": [["5 8\n2 4 2\n5 2 1\n1 2 1\n4 3 2\n1 3 3\n4 5 2\n1 5 8\n3 5 3\n", "7\n1 3 5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论"], "title": "行路难【疑似 std 复杂度有误】", "background": "小X来到了山区，领略山林之乐。在他乐以忘忧之时，他突然发现，开学迫在眉睫\n", "description": "山区有 $n$ 座山。山之间有 $m$ 条羊肠小道，每条连接两座山，只能单向通过，并会耗费小 X 一定时间。\n\n小 X 现在在 $1$ 号山，他的目的是 $n$ 号山，因为那里有火车站。\n\n然而小 X 的体力是有限的。他每通过一条羊肠小道，就会变得更疲劳，导致他通过任意一条羊肠小道的时间都增加 $1$。", "inputFormat": "第一行两个数，$n,m$。\n\n第 $2$ 行到第 $m+1$ 行，每行 $3$ 个数 $A, B, C$，表示 $A$ 、 $B$ 之间有一条羊肠小道，可以让小 X 花费 $C$ 的时间从 $A$ 移动到 $B$。", "outputFormat": "\n第一行一个数 $T$，表示小 X 需要的最短时间。\n\n第二行若干个数，用空格隔开，表示小 X 的移动路线。例如，$[1, 4, 2, 5]$ 表示小 $X$ 从 $1$ 号山开始，移动到 $4$ 号山，再到 $2$ 号山，最后到 $5$ 号山。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$n \\le 10^4$，$m \\le 2\\times 10^5$。\n\n数据保证没有多条最短路径。", "locale": "zh-CN", "translations": {"en": {"title": "Hard Road [Suspected standard solution (std) complexity is incorrect]", "background": "Xiao X came to the mountains and enjoyed the pleasures of the forest. While he was happily forgetting his worries, he suddenly realized that the new semester was imminent.", "description": "There are $n$ mountains in the mountainous area. There are $m$ narrow mountain paths between the mountains. Each path connects two mountains, is one-way, and costs Xiao X a certain amount of time.\n\nXiao X is currently at mountain $1$. His goal is mountain $n$, because there is a train station there.\n\nHowever, Xiao X’s stamina is limited. Each time he traverses a narrow mountain path, he becomes more tired, causing the time to traverse any narrow mountain path to increase by $1$.", "inputFormat": "The first line contains two integers, $n, m$.\n\nFrom line $2$ to line $m+1$, each line contains $3$ integers $A, B, C$, indicating that there is a narrow mountain path from $A$ to $B$ that allows Xiao X to move from $A$ to $B$ with a time cost of $C$.", "outputFormat": "The first line contains an integer $T$, the shortest time Xiao X needs.\n\nThe second line contains a sequence of integers separated by spaces, representing Xiao X’s route. For example, [1, 4, 2, 5] means Xiao X starts from mountain 1, moves to mountain 4, then to mountain 2, and finally to mountain 5.", "hint": "Constraints\n\nFor all testdata, $n \\le 10^4$, $m \\le 2 \\times 10^5$.\n\nThe testdata guarantees that the shortest path is unique.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "行路难【疑似 std 复杂度有误】", "background": "小X来到了山区，领略山林之乐。在他乐以忘忧之时，他突然发现，开学迫在眉睫\n", "description": "山区有 $n$ 座山。山之间有 $m$ 条羊肠小道，每条连接两座山，只能单向通过，并会耗费小 X 一定时间。\n\n小 X 现在在 $1$ 号山，他的目的是 $n$ 号山，因为那里有火车站。\n\n然而小 X 的体力是有限的。他每通过一条羊肠小道，就会变得更疲劳，导致他通过任意一条羊肠小道的时间都增加 $1$。", "inputFormat": "第一行两个数，$n,m$。\n\n第 $2$ 行到第 $m+1$ 行，每行 $3$ 个数 $A, B, C$，表示 $A$ 、 $B$ 之间有一条羊肠小道，可以让小 X 花费 $C$ 的时间从 $A$ 移动到 $B$。", "outputFormat": "\n第一行一个数 $T$，表示小 X 需要的最短时间。\n\n第二行若干个数，用空格隔开，表示小 X 的移动路线。例如，$[1, 4, 2, 5]$ 表示小 $X$ 从 $1$ 号山开始，移动到 $4$ 号山，再到 $2$ 号山，最后到 $5$ 号山。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$n \\le 10^4$，$m \\le 2\\times 10^5$。\n\n数据保证没有多条最短路径。", "locale": "zh-CN"}}}
{"pid": "P2833", "type": "P", "difficulty": 4, "samples": [["1 1 -3 0 4 0 4", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "洛谷原创"], "title": "等式", "background": "ZKC 有一天突发奇想，望着天空想出一道很好的问题，但是绞尽脑汁又不会做，所以请你来帮他解决。\n", "description": "给出 $a,b,c,x_1,x_2,y_1,y_2$，求满足 $ax+by+c=0$，且 $x\\in [x_1,x_2]$，$y\\in [y_1,y_2]$ 的整数解有多少对。\n", "inputFormat": "一行七个整数 $a,b,c,x_1,x_2,y_1,y_2$，整数间用空格隔开。\n", "outputFormat": "输出整数解有多少对。\n", "hint": "对于 $30\\%$ 的数据，$a,b,c,x_1,x_2,y_1,y_2$ 的绝对值不超过 $1000$。\n\n对于 $100\\%$ 的数据，$a,b,c,x_1,x_2,y_1,y_2$ 的绝对值不超过 $10^8$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Equation", "background": "One day, ZKC had a sudden idea. Staring at the sky, he came up with a nice problem, but after racking his brains he could not solve it, so he asks you to help him.", "description": "Given $a, b, c, x_1, x_2, y_1, y_2$, find how many pairs of integer solutions satisfy $ax + by + c = 0$, with $x \\in [x_1, x_2]$ and $y \\in [y_1, y_2]$.", "inputFormat": "A single line contains seven integers $a, b, c, x_1, x_2, y_1, y_2$, separated by spaces.", "outputFormat": "Output the number of pairs of integer solutions.", "hint": "For $30\\%$ of the testdata, the absolute values of $a, b, c, x_1, x_2, y_1, y_2$ do not exceed $1000$.\n\nFor $100\\%$ of the testdata, the absolute values of $a, b, c, x_1, x_2, y_1, y_2$ do not exceed $10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "等式", "background": "ZKC 有一天突发奇想，望着天空想出一道很好的问题，但是绞尽脑汁又不会做，所以请你来帮他解决。\n", "description": "给出 $a,b,c,x_1,x_2,y_1,y_2$，求满足 $ax+by+c=0$，且 $x\\in [x_1,x_2]$，$y\\in [y_1,y_2]$ 的整数解有多少对。\n", "inputFormat": "一行七个整数 $a,b,c,x_1,x_2,y_1,y_2$，整数间用空格隔开。\n", "outputFormat": "输出整数解有多少对。\n", "hint": "对于 $30\\%$ 的数据，$a,b,c,x_1,x_2,y_1,y_2$ 的绝对值不超过 $1000$。\n\n对于 $100\\%$ 的数据，$a,b,c,x_1,x_2,y_1,y_2$ 的绝对值不超过 $10^8$。\n", "locale": "zh-CN"}}}
{"pid": "P2834", "type": "P", "difficulty": 2, "samples": [["6 15\n1 5 10 20 50 100", "6"], ["3 15\n1 5 11", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP"], "title": "纸币问题 3", "background": "你是一个非常有钱的小朋友。\n\n**注意：** 本题和《进阶篇》的对应题目，输入格式略有差异。", "description": "你有 $n$ 种面额互不相同的纸币，第 $i$ 种纸币的面额为 $a_i$ 并且有无限张，现在你需要支付 $w$ 的金额，请问有多少种纸币组合能恰好支付金额 $w$，答案对 $10^9+7$ 取模。", "inputFormat": "第一行两个正整数 $n,w$，分别表示纸币的种数和要凑出的金额。  \n第二行一行 $n$ 个以空格隔开的正整数 $a_1, a_2, \\dots a_n$ 依次表示这 $n$ 种纸币的面额。", "outputFormat": "一行一个整数，表示能恰好凑齐面额 $w$ 的纸币组合数量。", "hint": "对于 $40\\%$ 的数据，满足 $n\\le 10$，$w\\le 100$；  \n对于 $100\\%$ 的数据，满足 $1\\le n\\le 10^3$，$1\\le a_i , w\\le 10^4$。\n\n其实小朋友并不有钱。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "纸币问题 3", "background": "你是一个非常有钱的小朋友。\n\n**注意：** 本题和《进阶篇》的对应题目，输入格式略有差异。", "description": "你有 $n$ 种面额互不相同的纸币，第 $i$ 种纸币的面额为 $a_i$ 并且有无限张，现在你需要支付 $w$ 的金额，请问有多少种纸币组合能恰好支付金额 $w$，答案对 $10^9+7$ 取模。", "inputFormat": "第一行两个正整数 $n,w$，分别表示纸币的种数和要凑出的金额。  \n第二行一行 $n$ 个以空格隔开的正整数 $a_1, a_2, \\dots a_n$ 依次表示这 $n$ 种纸币的面额。", "outputFormat": "一行一个整数，表示能恰好凑齐面额 $w$ 的纸币组合数量。", "hint": "对于 $40\\%$ 的数据，满足 $n\\le 10$，$w\\le 100$；  \n对于 $100\\%$ 的数据，满足 $1\\le n\\le 10^3$，$1\\le a_i , w\\le 10^4$。\n\n其实小朋友并不有钱。", "locale": "zh-CN"}}}
{"pid": "P2835", "type": "P", "difficulty": 4, "samples": [["5\n2 3 4 0\n4 5 0\n0\n0\n1 0", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "并查集", "强连通分量", "Floyd 算法"], "title": "刻录光盘", "background": "在 JSOI2005 夏令营快要结束的时候，很多营员提出来要把整个夏令营期间的资料刻录成一张光盘给大家，以便大家回去后继续学习。组委会觉得这个主意不错！可是组委会一时没有足够的空光盘，没法保证每个人都能拿到刻录上资料的光盘，又来不及去买了，怎么办呢？", "description": "组委会把这个难题交给了 LHC，LHC 分析了一下所有营员的地域关系，发现有些营员是一个城市的，其实他们只需要一张就可以了，因为一个人拿到光盘后，其他人可以带着 U 盘之类的东西去拷贝啊！\n\n可是，LHC 调查后发现，由于种种原因，有些营员并不是那么的合作，他们愿意某一些人到他那儿拷贝资料，也不愿意让另外一些人到他那儿拷贝资料，这与我们 JSOI 宣扬的团队合作精神格格不入！！！\n\n现在假设总共有 $N$ 个营员 $(2 \\le N \\le 200)$，每个营员的编号为 $1 \\sim N$。LHC 给每个人发了一张调查表，让每个营员填上自己愿意让哪些人到他那儿拷贝资料。当然，如果 A 愿意把资料拷贝给 B，而 B 又愿意把资料拷贝给 C，则一旦 A 获得了资料，则 B 和 C 都会获得资料。\n\n现在，请你编写一个程序，根据回收上来的调查表，帮助 LHC 计算出组委会至少要刻录多少张光盘，才能保证所有营员回去后都能得到夏令营资料？", "inputFormat": "先是一个数 $N$ 代表有 $N$ 个营员。接下来的 $N$ 行，分别表示各个营员愿意把自己获得的资料拷贝给其他哪些营员。即输入数据的第 $i+1$ 行表示第 $i$ 个营员愿意把资料拷贝给那些营员的编号，以 $0$ 结束。如果一个营员不愿意拷贝资料给任何人，则相应的行只有 $0$。一行中的数之间用一个空格隔开。", "outputFormat": "一个正整数，表示最少要刻录的光盘数。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Burning CDs", "background": "As the JSOI 2005 summer camp was about to end, many campers suggested burning all the materials from the entire camp onto a single CD for everyone, so they could continue studying after going home. The organizing committee thought this was a good idea! However, they did not have enough blank CDs at the moment to ensure that everyone could get one, and there was no time to buy more. What should they do?", "description": "The organizing committee handed this problem to LHC. After analyzing the campers’ locations, LHC found that some campers are from the same city. In fact, they only need one disc, because once one person gets the disc, others can bring a USB drive and copy the materials.\n\nHowever, after investigation, LHC discovered that, for various reasons, some campers are not very cooperative: they are willing to let certain people copy materials from them, but unwilling to let others do so. This goes against the team spirit promoted by JSOI.\n\nNow suppose there are $N$ campers $(2 \\le N \\le 200)$, numbered $1 \\sim N$. LHC gave everyone a survey form to fill in the people they are willing to let copy materials from them. Of course, if A is willing to copy to B, and B is willing to copy to C, then once A obtains the materials, both B and C will obtain them.\n\nPlease write a program that, based on the returned survey forms, helps LHC compute the minimum number of CDs the organizing committee must burn to ensure that all campers can get the summer camp materials after going home.", "inputFormat": "First is a number $N$ indicating there are $N$ campers. The next $N$ lines respectively indicate which other campers each camper is willing to copy the materials to. Specifically, the $(i+1)$-th line of the input indicates the IDs of the campers to whom the $i$-th camper is willing to copy, ending with $0$. If a camper is unwilling to copy to anyone, the corresponding line contains only $0$. Numbers on a line are separated by a single space.", "outputFormat": "A single positive integer, indicating the minimum number of CDs that must be burned.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "刻录光盘", "background": "在 JSOI2005 夏令营快要结束的时候，很多营员提出来要把整个夏令营期间的资料刻录成一张光盘给大家，以便大家回去后继续学习。组委会觉得这个主意不错！可是组委会一时没有足够的空光盘，没法保证每个人都能拿到刻录上资料的光盘，又来不及去买了，怎么办呢？", "description": "组委会把这个难题交给了 LHC，LHC 分析了一下所有营员的地域关系，发现有些营员是一个城市的，其实他们只需要一张就可以了，因为一个人拿到光盘后，其他人可以带着 U 盘之类的东西去拷贝啊！\n\n可是，LHC 调查后发现，由于种种原因，有些营员并不是那么的合作，他们愿意某一些人到他那儿拷贝资料，也不愿意让另外一些人到他那儿拷贝资料，这与我们 JSOI 宣扬的团队合作精神格格不入！！！\n\n现在假设总共有 $N$ 个营员 $(2 \\le N \\le 200)$，每个营员的编号为 $1 \\sim N$。LHC 给每个人发了一张调查表，让每个营员填上自己愿意让哪些人到他那儿拷贝资料。当然，如果 A 愿意把资料拷贝给 B，而 B 又愿意把资料拷贝给 C，则一旦 A 获得了资料，则 B 和 C 都会获得资料。\n\n现在，请你编写一个程序，根据回收上来的调查表，帮助 LHC 计算出组委会至少要刻录多少张光盘，才能保证所有营员回去后都能得到夏令营资料？", "inputFormat": "先是一个数 $N$ 代表有 $N$ 个营员。接下来的 $N$ 行，分别表示各个营员愿意把自己获得的资料拷贝给其他哪些营员。即输入数据的第 $i+1$ 行表示第 $i$ 个营员愿意把资料拷贝给那些营员的编号，以 $0$ 结束。如果一个营员不愿意拷贝资料给任何人，则相应的行只有 $0$。一行中的数之间用一个空格隔开。", "outputFormat": "一个正整数，表示最少要刻录的光盘数。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2836", "type": "P", "difficulty": 5, "samples": [["475.6\n11.9 27.4 14.98 6\n102.0 99.9\n220.0 132.9\n256.3 147.9\n275.0 102.9\n277.6 112.9\n381.8 100.9", "27.31"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "加油问题", "background": "", "description": "一个美国旅行代理商经常被要求去估计开车从一个城市旅行至另一个城市的最小费用。他有一个在通常路线上的大多数加油站的列表。列表包括了所有加油站的位置及当前每加仑汽油的价格。\n\n为了简化估计费用的过程，代理商使用了以下的简化汽车驾驶员行为的规则：\n\n- 除非汽车无法用油箱里的汽油达到下一个加油站（如果有的话）或目的地，在油箱里还有不少于最大容量一半的汽油时，驾驶员从不在加油站停下来。\n- 在每一个停下的加油站，驾驶员总是将油加满。\n- 在一个加油站停下之后，驾驶员将为旅程在快餐和糖果上花去 $2.00$ 元。\n- 在驶向加油站或目的地时，驾驶员不需要超过必须量的汽油。不需要“安全余量”。\n- 驾驶员开始旅行时油箱总是满的\n- 每个加油站付款时四舍五入到分（ $1$ 元等于 $100$ 分）。\n\n你必须写一个程序以估计驾驶员在旅程上至少要为汽油和食品付多少钱。\n", "inputFormat": "开始的 $2$ 行给出了出发地和目的地的信息。数据项的后继行代表了路线上的加油站，每个加油站用一行表示。下面是输入数据中数据项的精确格式及其含义。\n\n第一行：一个实数——从出发地到目的地的距离（英里）\n\n第二行：三个实数及一个整数\n\n- 第一个实数是汽车油箱的最大的容量（加仑）\n- 第二个实数是汽车每加仑汽油可以行驶的英里数\n- 第三个实数是汽车在出发地城市加满油箱的费用（单位：元）\n- 最后一个整数，是路线上加油站的数目 $n$。\n\n接下来的每一行有两个实数。\n\n- 第一个实数是从出发地到加油站的距离（单位：英里）\n- 第二个实数是该加油站出售的汽油每加仑的价格（单位：分）\n\n数据项中的所有数据都是正数。一条路线上的加油站根据其到出发地的距离递增排列。路线上不存在这样的加油站，它到出发点的距离大于从出发点到目的地的距离。每条路线上的加油站都被适当的安排以使得任何汽车都能从出发地开到目的地。\n", "outputFormat": "仅一行，一个实数（保留两位小数），表示最小的花费（单位：元）。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$n \\le 51$。", "locale": "zh-CN", "translations": {"en": {"title": "Refueling Problem", "background": "", "description": "A travel agent in the United States is often asked to estimate the minimum cost of driving from one city to another. He has a list of most gas stations on the usual route. The list includes the location of each station and the current price per gallon of gasoline.\n\nTo simplify the estimation, the agent uses the following simplified rules for driver behavior:\n\n- Unless the car cannot reach the next gas station (if any) or the destination with the gasoline currently in the tank, the driver will never stop at a station if the tank has at least half of its maximum capacity remaining.\n- At every stop, the driver always fills the tank to full.\n- After stopping at a gas station, the driver spends $2.00$ yuan on fast food and candy for the trip.\n- When heading to a gas station or the destination, the driver does not need to carry more gasoline than necessary. No \"safety margin\" is required.\n- The driver always starts the trip with a full tank.\n- Each payment at a gas station is rounded to the nearest cent ($1$ yuan equals $100$ cents).\n\nYou must write a program to estimate the minimum amount of money the driver will have to pay for gasoline and food on the trip.", "inputFormat": "The first $2$ lines give the information about the origin and the destination. The subsequent lines represent gas stations on the route, one per line. Below is the exact format of the input items and their meaning.\n\nFirst line: one real number — the distance from the origin to the destination (miles).\n\nSecond line: three real numbers and one integer:\n- The first real number is the maximum capacity of the car’s gas tank (gallons).\n- The second real number is the car’s fuel efficiency, in miles per gallon (mpg).\n- The third real number is the cost to fill the tank in the origin city (yuan).\n- The last integer is the number of gas stations on the route $n$.\n\nEach of the next $n$ lines contains two real numbers:\n- The first real number is the distance from the origin to the gas station (miles).\n- The second real number is the station’s price per gallon (cents).\n\nAll numbers in the input are positive. The gas stations on a route are ordered by increasing distance from the origin. There is no station whose distance from the origin exceeds the total distance to the destination. The stations on each route are arranged appropriately so that any car can drive from the origin to the destination.", "outputFormat": "A single line with one real number (rounded to two decimal places), representing the minimum total cost (yuan).", "hint": "### Constraints\n\nFor all testdata, $n \\le 51$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "加油问题", "background": "", "description": "一个美国旅行代理商经常被要求去估计开车从一个城市旅行至另一个城市的最小费用。他有一个在通常路线上的大多数加油站的列表。列表包括了所有加油站的位置及当前每加仑汽油的价格。\n\n为了简化估计费用的过程，代理商使用了以下的简化汽车驾驶员行为的规则：\n\n- 除非汽车无法用油箱里的汽油达到下一个加油站（如果有的话）或目的地，在油箱里还有不少于最大容量一半的汽油时，驾驶员从不在加油站停下来。\n- 在每一个停下的加油站，驾驶员总是将油加满。\n- 在一个加油站停下之后，驾驶员将为旅程在快餐和糖果上花去 $2.00$ 元。\n- 在驶向加油站或目的地时，驾驶员不需要超过必须量的汽油。不需要“安全余量”。\n- 驾驶员开始旅行时油箱总是满的\n- 每个加油站付款时四舍五入到分（ $1$ 元等于 $100$ 分）。\n\n你必须写一个程序以估计驾驶员在旅程上至少要为汽油和食品付多少钱。\n", "inputFormat": "开始的 $2$ 行给出了出发地和目的地的信息。数据项的后继行代表了路线上的加油站，每个加油站用一行表示。下面是输入数据中数据项的精确格式及其含义。\n\n第一行：一个实数——从出发地到目的地的距离（英里）\n\n第二行：三个实数及一个整数\n\n- 第一个实数是汽车油箱的最大的容量（加仑）\n- 第二个实数是汽车每加仑汽油可以行驶的英里数\n- 第三个实数是汽车在出发地城市加满油箱的费用（单位：元）\n- 最后一个整数，是路线上加油站的数目 $n$。\n\n接下来的每一行有两个实数。\n\n- 第一个实数是从出发地到加油站的距离（单位：英里）\n- 第二个实数是该加油站出售的汽油每加仑的价格（单位：分）\n\n数据项中的所有数据都是正数。一条路线上的加油站根据其到出发地的距离递增排列。路线上不存在这样的加油站，它到出发点的距离大于从出发点到目的地的距离。每条路线上的加油站都被适当的安排以使得任何汽车都能从出发地开到目的地。\n", "outputFormat": "仅一行，一个实数（保留两位小数），表示最小的花费（单位：元）。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$n \\le 51$。", "locale": "zh-CN"}}}
{"pid": "P2837", "type": "P", "difficulty": 2, "samples": [["7\n2\n1\n1\n1\n2\n2\n1", "2"], ["5\n2\n2\n1\n2\n2", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2008", "USACO"], "title": "[USACO08FEB] Dining Cows B", "background": "", "description": "为了避免餐厅过分拥挤，FJ 要求奶牛们分 $2$ 批就餐。每天晚饭前，奶牛们都会在餐厅前排队入内，按 FJ 的设想，所有第 $2$ 批就餐的奶牛排在队尾，队伍的前半部分则由设定为第 $1$ 批就餐的奶牛占据。\n\n由于奶牛们不理解 FJ 的安排，晚饭前的排队成了一个大麻烦。 第 $i$ 头奶牛有一张标明她用餐批次 $D_i$ 的卡片。虽然所有 $N$ 头奶牛排成了很整齐的队伍，但谁都看得出来，卡片上的号码是完全杂乱无章的。 在若干次混乱的重新排队后，FJ 找到了一种简单些的方法：奶牛们不动，他沿着队伍从头到尾走一遍，把那些他认为排错队的奶牛卡片上的编号改掉，最终得到一个他想要的每个组中的奶牛都站在一起的队列，例如 $112222$ 或 $111122$。有的时候，FJ 会把整个队列弄得只有 $1$ 组奶牛（比方说，$1111$ 或 $222$）。 \n\n你也晓得，FJ 是个很懒的人。他想知道，如果他想达到目的，那么他最少得改多少头奶牛卡片上的编号。所有奶牛在 FJ 改卡片编号的时候，都不会挪位置。", "inputFormat": "第一行输入一个整数 $N$（$1 \\le N \\le 3 \\times 10 ^ 4$）。\n\n第 $2 \\sim N + 1$ 行，每行 $1$ 个整数，表示第 $i$ 头牛的用餐批次 $D_i$（$1 \\le D_i \\le 2$）。", "outputFormat": "输出 $1$ 个整数，为 FJ 最少要改几头奶牛卡片上的编号，才能让编号变成他设想中的样子。", "hint": "$1 \\le N \\le 3 \\times 10 ^ 4$", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08FEB] Dining Cows B", "background": "", "description": "To avoid overcrowding in the dining hall, FJ requires the cows to eat in $2$ batches. Every day before dinner, the cows line up in front of the dining hall to enter. According to FJ’s plan, all cows in batch $2$ stand at the end of the line, while the front part of the line is occupied by cows designated as batch $1$.\n\nSince the cows do not understand FJ’s arrangement, lining up before dinner has become a big hassle. Cow $i$ holds a card that indicates her dining batch $D_i$. Although all $N$ cows stand in a neat line, it is obvious that the numbers on the cards are completely jumbled. After several chaotic re-lineups, FJ finds a simpler method: without moving the cows, he walks from the head to the tail of the line and changes the number on the card of any cow he believes is in the wrong batch, eventually obtaining a line in which all cows of each group stand together, for example, $112222$ or $111122$. Sometimes, FJ will even make the entire line consist of only $1$ group (for example, $1111$ or $222$).\n\nYou also know that FJ is lazy. He wants to know the minimum number of cows’ card numbers he must change to achieve his goal. None of the cows moves while FJ is changing the card numbers.", "inputFormat": "The first line contains an integer $N$ ($1 \\le N \\le 3 \\times 10 ^ 4$).\n\nLines $2$ to $N + 1$ each contain $1$ integer, the dining batch $D_i$ of the $i$-th cow ($1 \\le D_i \\le 2$).", "outputFormat": "Output $1$ integer, the minimum number of cows’ card numbers FJ must change to make the sequence match his plan.", "hint": "Constraints: $1 \\le N \\le 3 \\times 10 ^ 4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO08FEB] Dining Cows B", "background": "", "description": "为了避免餐厅过分拥挤，FJ 要求奶牛们分 $2$ 批就餐。每天晚饭前，奶牛们都会在餐厅前排队入内，按 FJ 的设想，所有第 $2$ 批就餐的奶牛排在队尾，队伍的前半部分则由设定为第 $1$ 批就餐的奶牛占据。\n\n由于奶牛们不理解 FJ 的安排，晚饭前的排队成了一个大麻烦。 第 $i$ 头奶牛有一张标明她用餐批次 $D_i$ 的卡片。虽然所有 $N$ 头奶牛排成了很整齐的队伍，但谁都看得出来，卡片上的号码是完全杂乱无章的。 在若干次混乱的重新排队后，FJ 找到了一种简单些的方法：奶牛们不动，他沿着队伍从头到尾走一遍，把那些他认为排错队的奶牛卡片上的编号改掉，最终得到一个他想要的每个组中的奶牛都站在一起的队列，例如 $112222$ 或 $111122$。有的时候，FJ 会把整个队列弄得只有 $1$ 组奶牛（比方说，$1111$ 或 $222$）。 \n\n你也晓得，FJ 是个很懒的人。他想知道，如果他想达到目的，那么他最少得改多少头奶牛卡片上的编号。所有奶牛在 FJ 改卡片编号的时候，都不会挪位置。", "inputFormat": "第一行输入一个整数 $N$（$1 \\le N \\le 3 \\times 10 ^ 4$）。\n\n第 $2 \\sim N + 1$ 行，每行 $1$ 个整数，表示第 $i$ 头牛的用餐批次 $D_i$（$1 \\le D_i \\le 2$）。", "outputFormat": "输出 $1$ 个整数，为 FJ 最少要改几头奶牛卡片上的编号，才能让编号变成他设想中的样子。", "hint": "$1 \\le N \\le 3 \\times 10 ^ 4$", "locale": "zh-CN"}}}
{"pid": "P2838", "type": "P", "difficulty": 7, "samples": [["233\n// 仅作为参考，这里应该填数据编号", "I\nC 1\nF 2\nC 233333\nT 1 3\nT 2 3\nO 3\n（这个程序可以进行x+1！是不是很厉害啊！不过程序中并不能附加任何注释）"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "提交答案", "Special Judge"], "title": "瓶子国的故事", "background": "这是一道非传统题。\n\n传说有一个国家叫瓶子国，里面有大大小小的瓶子。\n\n现在瓶子国想要学习邻居跳蚤国发展计算机，可是瓶子国没有计算机只有瓶子。\n\n于是瓶子国国王就给了你一些瓶子，让你实现一些计算任务。\n", "description": "我们用水的量来描述一个数。\n\n- 一个瓶子的容量为它最多可以装的水的数量。\n\n瓶子国国王认为瓶子可以干这些事：\n\n- $\\verb!I!$：制造一个新瓶子，它的容量和里面装的水量都为输入的数，这个瓶子的编号为 $\\textbf{当前最大编号} +1$。\n- $\\verb!F !s$；把编号为 $s$ 的瓶子里的水倒满。\n- $\\verb!E !s$：把编号为 $s$ 的瓶子里的水倒空。\n- $\\verb!C !s$：制作一个新瓶子，它的容量为 $s$，里面没装水，这个瓶子的编号为 $\\textbf{当前最大编号} +1$。注意由于瓶子容积有限，$0\\le s\\le 10^9$。\n- $\\verb!M !s$：制作一个新瓶子，它的容量为 $\\textbf{s 号瓶子里装的水的数量}$，里面没装水，这个瓶子的编号为 $\\textbf{当前最大编号}+1$。\n- $\\verb!T !a\\ b$：把 $a$ 瓶往 $b$ 瓶倒水，直到 $a$ 瓶空或者 $b$ 瓶满为止。（注意 $a\\neq b$）。\n- $\\verb!O !s$：把 $s$ 号瓶子里的水输出。\n\n还有一种昂贵的操作：\n\n- $\\verb!K !a\\ b$：制作一个新瓶子，它的容量为 $\\textbf{a 号瓶子的容量} \\times \\textbf{b 号瓶子的容量}$，这个瓶子的编号为 $\\textbf{当前最大编号}+1$。注意由于瓶子容积有限，$\\textbf{a 号瓶子的容量}\\times\\textbf{b 号瓶子的容量}$，不能超过 $10^9$。（使用这种操作要扣分，评分规则详见下方提示）\n\n现在瓶子国国王把这些操作给了你，你只要输出这些操作，瓶子国的瓶子们就会为你执行！\n\n瓶子国国王给了你一些计算任务，你只需要实现这些任务就行啦！\n\n左边是数据点编号，右边是计算任务。\n\n1. 输入 $a$ 和 $b$，计算 $a+b$。（$0\\le a,b\\le 10^5$）\n2. 输入 $a$ 和 $b$，计算 $|a-b|$。（$0\\le a,b\\le 10^5$）\n3. 输入 $a$ 和 $b$，计算 $\\max(a,b)$。（$0\\le a,b\\le 10^5$）\n4. 输入 $a$ 和 $b$，输出 $\\gcd(a,b)$。（$1\\le a,b\\le 1000$）\n5. 输入 $a$，输出 $a$ 的 $32$ 位二进制表示。（$0\\le a\\le 10^5$，例如 $5$ 输出 $\\verb!0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1!$）\n6. 输入 $a$ 和 $b$，输出 $a\\times b$。（$0\\le a,b\\le 1000$）\n7. 输入 $a$ 和 $b$，输出 $a\\oplus b$。（$0\\le a,b\\le 10^5$，$\\oplus$ 表示异或）\n8. 输入 $a$，输出 $a\\div 10$ 下取整。（$1\\le a\\le 10000$）\n9. 输入 $a$ 和 $b$，输出 $a\\times b \\bmod 262144$。（$0\\le a,b\\le 10^5$）\n10. 输入 $a$ 和 $b$，输出 $a$ 的 $b$ 次方。（$1\\le a,b\\le 1000$，$a$ 的 $b$ 次方不超过 $10^6$）\n\n瓶子国国王会生成 $30$ 组**左右**的数据对你的程序进行测试，并根据你使用的操作个数进行评分，评分规则详见下方提示。\n\n（**UPD**：如果你没有看懂题目这里有一段补充说明）\n\n你**提交到洛谷的程序**（C/C++/Pascal）需要输出一段操作，格式类似样例输出。\n\n例如第一个点，提交后洛谷上的 checker 会随机生成 $a$ 和 $b$ 作为 $\\verb!I!$ **操作的输入**来测试你的操作。\n\n对于本地 checker（下载见提示区），你可以把输出的操作保存成 `a.txt`，然后第一行输入 `a.txt`，第二行如果手玩就输 $0$，如果测试指定点就输编号。\n", "inputFormat": "输入共一行一个整数，表示数据点编号。\n", "outputFormat": "输出可以满足计算任务的操作。\n", "hint": "请注意提交的是一段**输出操作的程序**！（如果你生成答案之后把生成它的程序删了直接打表输出，可能会输出超限）\n\n灵感来自 NOI2016 旷野大计算（其实我不说你们肯定也知道啊）\n\n为了方便选手本地测试，下面是一个 C++ 的本地checker（需要注意的是，它的测试结果与洛谷上的测试结果不一定一样，洛谷上可能更严格）：\n\n- http://paste.ubuntu.com/23070332/\n\n如果需要下载 exe 的话可戳度盘：\n\n- http://pan.baidu.com/s/1o7HZ1GY 密码为 `kqhl`。\n\n### 评分规则\n\n如果你的算法输出了错误结果（多输出也算）或者发生运行错误（操作不符合要求等）或者行数超过 $5\\times 10^6$ 行或者行数太长了 checker 没能在 $1s$ 内测试完 $30$ 组数据，你将获得 $0$ 分。\n\n否则，假设 std 的步数为 $s$，你的步数为 $x$。\n\n- 如果 $x\\le s$，你的基准分为 $10$ 分。\n- 如果 $s<x\\le s+5$，你的基准分为 $9$ 分。\n- 如果 $s+5<x\\le 3s$，你的基准分为 $8$ 分。\n- 如果 $3s<x\\le 10s$，你的基准分为 $7$ 分。\n- 如果 $10s<x\\le 50s$，你的基准分为 $6$ 分。\n- 如果 $x>50s$，你的基准分为 $5$ 分。\n\n如果你使用了昂贵的 $\\verb!K!$ 操作，你会得到（基准分 $-4$）分。\n\n否则你会得到基准分。\n\n（说人话：步数越少分越高，用K操作扣4分）\n\n（**UPD2：洛谷上的checker常见错误信息**）\n\n```cpp\ntoo many lines：超过500w行（这个似乎还没有触发过）\nWTF：就是操作的第一个字符串（I/T/K/F/E/C/M/O）长度大于1\n（可能是由于上一个操作多跟了一个操作数？）\nwrong operation：操作的第一个字符串长度为1但不是I/T/K/F/E/C/M/O。\nexpected *****：希望输入一个数/字符串却没有（可能是操作数多打/少打）\nnothing to input：I操作数量大于输入的数数量\nF/E/C/M/T/O/K wrong bottle：操作的瓶子编号不在[1,当前最大编号]范围内\nC exceed [0,10^9]：字面意思\nK exceed 10^9：字面意思\nwa on test xxx：你在第xxx组随机数据狗带了\nwa on extratest xxx：你在第xxx组人工数据（手打的）狗带了\n```", "locale": "zh-CN", "translations": {"en": {"title": "The Story of Bottle Country", "background": "This is a non-traditional problem.\n\nLegend has it there is a country called Bottle Country, filled with bottles of various sizes.\n\nNow Bottle Country wants to learn from its neighbor, Flea Country, to develop computers, but Bottle Country has no computers—only bottles.\n\nSo the king of Bottle Country gives you some bottles to carry out certain computational tasks.", "description": "We use the amount of water to represent a number.\n\n- The capacity of a bottle is the maximum amount of water it can hold.\n\nThe king of Bottle Country believes bottles can do the following:\n\n- $\\verb!I!$: Create a new bottle whose capacity and current amount of water are both equal to the input number. Its index is $\\textbf{当前最大编号} +1$.\n- $\\verb!F !s$: Fill the bottle with index $s$ to its full capacity.\n- $\\verb!E !s$: Empty the bottle with index $s$.\n- $\\verb!C !s$: Create a new bottle with capacity $s$ and no water in it. Its index is $\\textbf{当前最大编号} +1$. Note that due to limited capacity, $0\\le s\\le 10^9$.\n- $\\verb!M !s$: Create a new bottle whose capacity equals $\\textbf{s 号瓶子里装的水的数量}$ and which initially contains no water. Its index is $\\textbf{当前最大编号}+1$.\n- $\\verb!T !a\\ b$: Pour water from bottle $a$ into bottle $b$ until bottle $a$ becomes empty or bottle $b$ becomes full (note $a\\neq b$).\n- $\\verb!O !s$: Output the amount of water in bottle $s$.\n\nThere is also an expensive operation:\n\n- $\\verb!K !a\\ b$: Create a new bottle whose capacity equals $\\textbf{a 号瓶子的容量} \\times \\textbf{b 号瓶子的容量}$. Its index is $\\textbf{当前最大编号}+1$. Note that due to capacity limits, $\\textbf{a 号瓶子的容量}\\times\\textbf{b 号瓶子的容量}$ must not exceed $10^9$. (Using this operation deducts points; see the scoring rules below.)\n\nThe king gives you these operations; you only need to output them, and the bottles will execute them for you!\n\nThe king of Bottle Country gives you several computational tasks. Just implement these tasks.\n\nOn the left are the data point IDs; on the right are the tasks:\n\n1. Given $a$ and $b$, compute $a+b$. ($0\\le a,b\\le 10^5$)\n2. Given $a$ and $b$, compute $|a-b|$. ($0\\le a,b\\le 10^5$)\n3. Given $a$ and $b$, compute $\\max(a,b)$. ($0\\le a,b\\le 10^5$)\n4. Given $a$ and $b$, output $\\gcd(a,b)$. ($1\\le a,b\\le 1000$)\n5. Given $a$, output the 32-bit binary representation of $a$. ($0\\le a\\le 10^5$, for example, $5$ outputs $\\verb!0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1!$)\n6. Given $a$ and $b$, output $a\\times b$. ($0\\le a,b\\le 1000$)\n7. Given $a$ and $b$, output $a\\oplus b$. ($0\\le a,b\\le 10^5$, where $\\oplus$ denotes bitwise XOR)\n8. Given $a$, output $\\lfloor a\\div 10 \\rfloor$. ($1\\le a\\le 10000$)\n9. Given $a$ and $b$, output $a\\times b \\bmod 262144$. ($0\\le a,b\\le 10^5$)\n10. Given $a$ and $b$, output $a^b$. ($1\\le a,b\\le 1000$, and $a^b$ does not exceed $10^6$)\n\nThe king will generate about $30$ groups of testdata to test your program and will score it based on the number of operations you use. See the scoring rules below.\n\n(UPD: If you did not understand the problem, here is an additional explanation.)\n\nYour program submitted to Luogu (C/C++/Pascal) must output a sequence of operations in the format similar to the sample output.\n\nFor example, for the first data point, after submission the checker on Luogu will randomly generate $a$ and $b$ as the inputs to the $\\verb!I!$ operation to test your operations.\n\nFor the local checker (see the Hint section for download), you can save your output operations to a file named `a.txt`. Then input `a.txt` on the first line. On the second line, input $0$ if playing manually, or input the specific data point ID if testing that point.", "inputFormat": "A single line containing one integer representing the data point ID.", "outputFormat": "Output a sequence of operations that satisfies the computational task.", "hint": "Please note you are submitting a program that outputs operations! (If you generate the answers and then delete the program and directly hardcode the outputs, your output might exceed limits.)\n\nInspired by NOI2016 “Wilderness Big Computation” (you probably knew that anyway).\n\nFor convenient local testing, here is a C++ local checker (note that its results may differ from Luogu’s; Luogu may be stricter):\n\n- http://paste.ubuntu.com/23070332/\n\nIf you need an executable, you can use Baidu Netdisk:\n\n- http://pan.baidu.com/s/1o7HZ1GY Password: `kqhl`.\n\nScoring Rules:\n\nIf your algorithm produces a wrong result (extra outputs also count), or a runtime error occurs (operations violate the rules, etc.), or the number of lines exceeds $5\\times 10^6$, or the lines are so many that the checker cannot finish testing $30$ groups within $1$ s, you receive $0$ points.\n\nOtherwise, suppose the standard solution uses $s$ steps and your solution uses $x$ steps.\n\n- If $x\\le s$, your base score is $10$ points.\n- If $s<x\\le s+5$, your base score is $9$ points.\n- If $s+5<x\\le 3s$, your base score is $8$ points.\n- If $3s<x\\le 10s$, your base score is $7$ points.\n- If $10s<x\\le 50s$, your base score is $6$ points.\n- If $x>50s$, your base score is $5$ points.\n\nIf you use the expensive $\\verb!K!$ operation, you will get (base score $-4$) points.\n\nOtherwise, you will receive the base score.\n\n(In plain words: fewer steps → higher score; using the K operation deducts 4 points.)\n\n(UPD2: Common checker error messages on Luogu)\n\n```cpp\ntoo many lines：超过500w行（这个似乎还没有触发过）\nWTF：就是操作的第一个字符串（I/T/K/F/E/C/M/O）长度大于1\n（可能是由于上一个操作多跟了一个操作数？）\nwrong operation：操作的第一个字符串长度为1但不是I/T/K/F/E/C/M/O。\nexpected *****：希望输入一个数/字符串却没有（可能是操作数多打/少打）\nnothing to input：I操作数量大于输入的数数量\nF/E/C/M/T/O/K wrong bottle：操作的瓶子编号不在[1,当前最大编号]范围内\nC exceed [0,10^9]：字面意思\nK exceed 10^9：字面意思\nwa on test xxx：你在第xxx组随机数据狗带了\nwa on extratest xxx：你在第xxx组人工数据（手打的）狗带了\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "瓶子国的故事", "background": "这是一道非传统题。\n\n传说有一个国家叫瓶子国，里面有大大小小的瓶子。\n\n现在瓶子国想要学习邻居跳蚤国发展计算机，可是瓶子国没有计算机只有瓶子。\n\n于是瓶子国国王就给了你一些瓶子，让你实现一些计算任务。\n", "description": "我们用水的量来描述一个数。\n\n- 一个瓶子的容量为它最多可以装的水的数量。\n\n瓶子国国王认为瓶子可以干这些事：\n\n- $\\verb!I!$：制造一个新瓶子，它的容量和里面装的水量都为输入的数，这个瓶子的编号为 $\\textbf{当前最大编号} +1$。\n- $\\verb!F !s$；把编号为 $s$ 的瓶子里的水倒满。\n- $\\verb!E !s$：把编号为 $s$ 的瓶子里的水倒空。\n- $\\verb!C !s$：制作一个新瓶子，它的容量为 $s$，里面没装水，这个瓶子的编号为 $\\textbf{当前最大编号} +1$。注意由于瓶子容积有限，$0\\le s\\le 10^9$。\n- $\\verb!M !s$：制作一个新瓶子，它的容量为 $\\textbf{s 号瓶子里装的水的数量}$，里面没装水，这个瓶子的编号为 $\\textbf{当前最大编号}+1$。\n- $\\verb!T !a\\ b$：把 $a$ 瓶往 $b$ 瓶倒水，直到 $a$ 瓶空或者 $b$ 瓶满为止。（注意 $a\\neq b$）。\n- $\\verb!O !s$：把 $s$ 号瓶子里的水输出。\n\n还有一种昂贵的操作：\n\n- $\\verb!K !a\\ b$：制作一个新瓶子，它的容量为 $\\textbf{a 号瓶子的容量} \\times \\textbf{b 号瓶子的容量}$，这个瓶子的编号为 $\\textbf{当前最大编号}+1$。注意由于瓶子容积有限，$\\textbf{a 号瓶子的容量}\\times\\textbf{b 号瓶子的容量}$，不能超过 $10^9$。（使用这种操作要扣分，评分规则详见下方提示）\n\n现在瓶子国国王把这些操作给了你，你只要输出这些操作，瓶子国的瓶子们就会为你执行！\n\n瓶子国国王给了你一些计算任务，你只需要实现这些任务就行啦！\n\n左边是数据点编号，右边是计算任务。\n\n1. 输入 $a$ 和 $b$，计算 $a+b$。（$0\\le a,b\\le 10^5$）\n2. 输入 $a$ 和 $b$，计算 $|a-b|$。（$0\\le a,b\\le 10^5$）\n3. 输入 $a$ 和 $b$，计算 $\\max(a,b)$。（$0\\le a,b\\le 10^5$）\n4. 输入 $a$ 和 $b$，输出 $\\gcd(a,b)$。（$1\\le a,b\\le 1000$）\n5. 输入 $a$，输出 $a$ 的 $32$ 位二进制表示。（$0\\le a\\le 10^5$，例如 $5$ 输出 $\\verb!0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1!$）\n6. 输入 $a$ 和 $b$，输出 $a\\times b$。（$0\\le a,b\\le 1000$）\n7. 输入 $a$ 和 $b$，输出 $a\\oplus b$。（$0\\le a,b\\le 10^5$，$\\oplus$ 表示异或）\n8. 输入 $a$，输出 $a\\div 10$ 下取整。（$1\\le a\\le 10000$）\n9. 输入 $a$ 和 $b$，输出 $a\\times b \\bmod 262144$。（$0\\le a,b\\le 10^5$）\n10. 输入 $a$ 和 $b$，输出 $a$ 的 $b$ 次方。（$1\\le a,b\\le 1000$，$a$ 的 $b$ 次方不超过 $10^6$）\n\n瓶子国国王会生成 $30$ 组**左右**的数据对你的程序进行测试，并根据你使用的操作个数进行评分，评分规则详见下方提示。\n\n（**UPD**：如果你没有看懂题目这里有一段补充说明）\n\n你**提交到洛谷的程序**（C/C++/Pascal）需要输出一段操作，格式类似样例输出。\n\n例如第一个点，提交后洛谷上的 checker 会随机生成 $a$ 和 $b$ 作为 $\\verb!I!$ **操作的输入**来测试你的操作。\n\n对于本地 checker（下载见提示区），你可以把输出的操作保存成 `a.txt`，然后第一行输入 `a.txt`，第二行如果手玩就输 $0$，如果测试指定点就输编号。\n", "inputFormat": "输入共一行一个整数，表示数据点编号。\n", "outputFormat": "输出可以满足计算任务的操作。\n", "hint": "请注意提交的是一段**输出操作的程序**！（如果你生成答案之后把生成它的程序删了直接打表输出，可能会输出超限）\n\n灵感来自 NOI2016 旷野大计算（其实我不说你们肯定也知道啊）\n\n为了方便选手本地测试，下面是一个 C++ 的本地checker（需要注意的是，它的测试结果与洛谷上的测试结果不一定一样，洛谷上可能更严格）：\n\n- http://paste.ubuntu.com/23070332/\n\n如果需要下载 exe 的话可戳度盘：\n\n- http://pan.baidu.com/s/1o7HZ1GY 密码为 `kqhl`。\n\n### 评分规则\n\n如果你的算法输出了错误结果（多输出也算）或者发生运行错误（操作不符合要求等）或者行数超过 $5\\times 10^6$ 行或者行数太长了 checker 没能在 $1s$ 内测试完 $30$ 组数据，你将获得 $0$ 分。\n\n否则，假设 std 的步数为 $s$，你的步数为 $x$。\n\n- 如果 $x\\le s$，你的基准分为 $10$ 分。\n- 如果 $s<x\\le s+5$，你的基准分为 $9$ 分。\n- 如果 $s+5<x\\le 3s$，你的基准分为 $8$ 分。\n- 如果 $3s<x\\le 10s$，你的基准分为 $7$ 分。\n- 如果 $10s<x\\le 50s$，你的基准分为 $6$ 分。\n- 如果 $x>50s$，你的基准分为 $5$ 分。\n\n如果你使用了昂贵的 $\\verb!K!$ 操作，你会得到（基准分 $-4$）分。\n\n否则你会得到基准分。\n\n（说人话：步数越少分越高，用K操作扣4分）\n\n（**UPD2：洛谷上的checker常见错误信息**）\n\n```cpp\ntoo many lines：超过500w行（这个似乎还没有触发过）\nWTF：就是操作的第一个字符串（I/T/K/F/E/C/M/O）长度大于1\n（可能是由于上一个操作多跟了一个操作数？）\nwrong operation：操作的第一个字符串长度为1但不是I/T/K/F/E/C/M/O。\nexpected *****：希望输入一个数/字符串却没有（可能是操作数多打/少打）\nnothing to input：I操作数量大于输入的数数量\nF/E/C/M/T/O/K wrong bottle：操作的瓶子编号不在[1,当前最大编号]范围内\nC exceed [0,10^9]：字面意思\nK exceed 10^9：字面意思\nwa on test xxx：你在第xxx组随机数据狗带了\nwa on extratest xxx：你在第xxx组人工数据（手打的）狗带了\n```", "locale": "zh-CN"}}}
{"pid": "P2839", "type": "P", "difficulty": 6, "samples": [["5\n170337785\n271451044\n22430280\n969056313\n206452321\n3\n3 1 0 2\n2 3 1 4\n3 1 4 0", "271451044\n271451044\n969056313"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["二分", "集训队互测", "可持久化线段树"], "title": "[国家集训队] middle", "background": "", "description": "一个长度为 $n$ 的序列 $a$，设其排过序之后为 $b$，其中位数定义为 $b_{n/2}$，其中 $a,b$ 从 $0$ 开始标号，除法下取整。\n\n给你一个长度为 $n$ 的序列 $s$。\n\n回答 $Q$ 个这样的询问：$s$ 的左端点在 $[a,b]$ 之间，右端点在 $[c,d]$ 之间的子区间中，最大的中位数。\n\n其中 $a<b<c<d$。\n\n位置也从 $0$ 开始标号。\n\n我会使用一些方式强制你在线。\n", "inputFormat": "第一行序列长度 $n$。\n\n接下来 $n$ 行按顺序给出 $a$ 中的数。\n\n接下来一行 $Q$。\n\n然后 $Q$ 行每行 $a,b,c,d$，我们令上个询问的答案是 $x$（如果这是第一个询问则 $x=0$）。\n\n令数组 $q=\\{(a+x)\\bmod n,(b+x)\\bmod n,(c+x)\\bmod n,(d+x)\\bmod n\\}$。\n\n将 $q$ 从小到大排序之后，令真正的要询问的 $a=q_0$，$b=q_1$，$c=q_2$，$d=q_3$。\n\n输入保证满足条件。\n", "outputFormat": "$Q$ 行依次给出询问的答案。\n", "hint": "对于 $5\\%$ 的数据，$n,Q \\leq 100$；\n\n对于另 $25\\%$ 的数据，$n \\leq 2000$；\n\n对于 $100\\%$ 的数据，$1\\leq n \\leq 20000$，$1\\leq Q \\leq 25000$，$1\\leq a_i\\leq 10 ^ 9$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] middle", "background": "", "description": "Given a sequence $a$ of length $n$, let $b$ be the sorted version of $a$. The median is defined as $b_{n/2}$, where $a$ and $b$ are 0-indexed and the division takes the floor.\n\nYou are given a sequence $s$ of length $n$.\n\nAnswer $Q$ queries of the following type: among all subarrays of $s$ whose left endpoint is in $[a, b]$ and right endpoint is in $[c, d]$, find the maximum possible median.\n\nHere $a < b < c < d$.\n\nPositions are also 0-indexed.\n\nI will use some method to force you to process the queries online.", "inputFormat": "The first line contains the sequence length $n$.\n\nThe next $n$ lines give the numbers of $s$ in order.\n\nThe next line contains $Q$.\n\nThen $Q$ lines follow, each containing $a, b, c, d$. Let the answer to the previous query be $x$ (if this is the first query, then $x=0$).\n\nLet the array $q=\\{(a+x)\\bmod n,(b+x)\\bmod n,(c+x)\\bmod n,(d+x)\\bmod n\\}$.\n\nAfter sorting $q$ in ascending order, let the actual query be $a=q_0$, $b=q_1$, $c=q_2$, $d=q_3$.\n\nThe input is guaranteed to satisfy the conditions.", "outputFormat": "Output $Q$ lines in order, each giving the answer to a query.", "hint": "For $5\\%$ of the testdata, $n, Q \\leq 100$.\n\nFor an additional $25\\%$ of the testdata, $n \\leq 2000$.\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 20000$, $1 \\leq Q \\leq 25000$, $1 \\leq s_i \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] middle", "background": "", "description": "一个长度为 $n$ 的序列 $a$，设其排过序之后为 $b$，其中位数定义为 $b_{n/2}$，其中 $a,b$ 从 $0$ 开始标号，除法下取整。\n\n给你一个长度为 $n$ 的序列 $s$。\n\n回答 $Q$ 个这样的询问：$s$ 的左端点在 $[a,b]$ 之间，右端点在 $[c,d]$ 之间的子区间中，最大的中位数。\n\n其中 $a<b<c<d$。\n\n位置也从 $0$ 开始标号。\n\n我会使用一些方式强制你在线。\n", "inputFormat": "第一行序列长度 $n$。\n\n接下来 $n$ 行按顺序给出 $a$ 中的数。\n\n接下来一行 $Q$。\n\n然后 $Q$ 行每行 $a,b,c,d$，我们令上个询问的答案是 $x$（如果这是第一个询问则 $x=0$）。\n\n令数组 $q=\\{(a+x)\\bmod n,(b+x)\\bmod n,(c+x)\\bmod n,(d+x)\\bmod n\\}$。\n\n将 $q$ 从小到大排序之后，令真正的要询问的 $a=q_0$，$b=q_1$，$c=q_2$，$d=q_3$。\n\n输入保证满足条件。\n", "outputFormat": "$Q$ 行依次给出询问的答案。\n", "hint": "对于 $5\\%$ 的数据，$n,Q \\leq 100$；\n\n对于另 $25\\%$ 的数据，$n \\leq 2000$；\n\n对于 $100\\%$ 的数据，$1\\leq n \\leq 20000$，$1\\leq Q \\leq 25000$，$1\\leq a_i\\leq 10 ^ 9$。", "locale": "zh-CN"}}}
{"pid": "P2840", "type": "P", "difficulty": 2, "samples": [["6 15\n1 5 10 20 50 100", "42"], ["3 15\n1 5 11", "39"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP"], "title": "纸币问题 2", "background": "你是一个非常有钱的小朋友。", "description": "你有 $n$ 种面额互不相同的纸币，第 $i$ 种纸币的面额为 $a_i$ 并且有无限张，现在你需要支付 $w$ 的金额，求问有多少种方式可以支付面额 $w$，答案对 $10^9+7$ 取模。  \n注意在这里，同样的纸币组合如果支付顺序不同，会被视作不同的方式。例如支付 $3$ 元，使用一张面值 $1$ 的纸币和一张面值 $2$ 的纸币会产生两种方式（$1+2$ 和 $2+1$）。", "inputFormat": "第一行两个正整数 $n,w$，分别表示纸币的种数和要凑出的金额。  \n第二行一行 $n$ 个以空格隔开的正整数 $a_1, a_2, \\dots a_n $ 依次表示这 $n$ 种纸币的面额。", "outputFormat": "一行一个整数，表示支付方式的数量。", "hint": "对于 $40\\%$ 的数据，满足 $n\\le 10$，$w\\le 100$；  \n对于 $100\\%$ 的数据，满足 $1\\le n\\le 10^3$，$1\\le a_i , w\\le 10^4$。\n\n其实小朋友并没有那么多钱。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "纸币问题 2", "background": "你是一个非常有钱的小朋友。", "description": "你有 $n$ 种面额互不相同的纸币，第 $i$ 种纸币的面额为 $a_i$ 并且有无限张，现在你需要支付 $w$ 的金额，求问有多少种方式可以支付面额 $w$，答案对 $10^9+7$ 取模。  \n注意在这里，同样的纸币组合如果支付顺序不同，会被视作不同的方式。例如支付 $3$ 元，使用一张面值 $1$ 的纸币和一张面值 $2$ 的纸币会产生两种方式（$1+2$ 和 $2+1$）。", "inputFormat": "第一行两个正整数 $n,w$，分别表示纸币的种数和要凑出的金额。  \n第二行一行 $n$ 个以空格隔开的正整数 $a_1, a_2, \\dots a_n $ 依次表示这 $n$ 种纸币的面额。", "outputFormat": "一行一个整数，表示支付方式的数量。", "hint": "对于 $40\\%$ 的数据，满足 $n\\le 10$，$w\\le 100$；  \n对于 $100\\%$ 的数据，满足 $1\\le n\\le 10^3$，$1\\le a_i , w\\le 10^4$。\n\n其实小朋友并没有那么多钱。", "locale": "zh-CN"}}}
{"pid": "P2841", "type": "P", "difficulty": 5, "samples": [["6", "185 1110\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "高精度", "递推", "进制"], "title": "A*B Problem", "background": "", "description": "给出一个数 $A$ ，你需要给出一个最小的数 $B$ ，使得 $A\\times B$ 的结果只含有 $0$ 和 $1$ 。", "inputFormat": "一个正整数 $A$。", "outputFormat": "正整数 $B$ 和 $A\\times B$ 的结果，两数之间用一个空格隔开。", "hint": "样例说明：$6\\times 185=1110$。\n\n对于 $30\\%$ 的数据，$0<A<20$。\n\n对于 $50\\%$ 的数据，$0<A<100$。\n\n对于 $70\\%$ 的数据，$0<A<1000$。\n\n对于 $100\\%$ 的数据，$0<A<10^4$。\n", "locale": "zh-CN", "translations": {"en": {"title": "A*B Problem", "background": "", "description": "Given a number $A$, you need to output the smallest number $B$ such that the result of $A \\times B$ contains only digits 0 and 1.", "inputFormat": "A positive integer $A$.", "outputFormat": "The positive integer $B$ and the result of $A \\times B$, separated by a single space.", "hint": "Sample explanation: $6 \\times 185 = 1110$.\n\nFor 30% of the testdata, $0 < A < 20$.\nFor 50% of the testdata, $0 < A < 100$.\nFor 70% of the testdata, $0 < A < 1000$.\nFor 100% of the testdata, $0 < A < 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "A*B Problem", "background": "", "description": "给出一个数 $A$ ，你需要给出一个最小的数 $B$ ，使得 $A\\times B$ 的结果只含有 $0$ 和 $1$ 。", "inputFormat": "一个正整数 $A$。", "outputFormat": "正整数 $B$ 和 $A\\times B$ 的结果，两数之间用一个空格隔开。", "hint": "样例说明：$6\\times 185=1110$。\n\n对于 $30\\%$ 的数据，$0<A<20$。\n\n对于 $50\\%$ 的数据，$0<A<100$。\n\n对于 $70\\%$ 的数据，$0<A<1000$。\n\n对于 $100\\%$ 的数据，$0<A<10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P2842", "type": "P", "difficulty": 2, "samples": [["6 15\n1 5 10 20 50 100", "2"], ["3 15\n1 5 11", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP"], "title": "纸币问题 1", "background": null, "description": "某国有 $n$ 种纸币，每种纸币面额为 $a_i$ 并且有无限张，现在要凑出 $w$ 的金额，试问最少用多少张纸币可以凑出来？（保证可以凑出对应金额）", "inputFormat": "第一行两个整数 $n,w$，分别表示纸币的种数和要凑出的金额。  \n第二行一行 $n$ 个以空格隔开的整数 $a_1, a_2, a_3, \\dots a_n$ 依次表示这 $n$ 种纸币的面额。", "outputFormat": "一行一个整数，表示最少使用的纸币张数。", "hint": "对于 $40\\%$ 的数据，满足 $n\\le 10$，$w\\le 100$；  \n对于 $100\\%$ 的数据，满足 $1\\le n\\le 10^3$，$1\\le a_i , w\\le 10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "纸币问题 1", "background": null, "description": "某国有 $n$ 种纸币，每种纸币面额为 $a_i$ 并且有无限张，现在要凑出 $w$ 的金额，试问最少用多少张纸币可以凑出来？（保证可以凑出对应金额）", "inputFormat": "第一行两个整数 $n,w$，分别表示纸币的种数和要凑出的金额。  \n第二行一行 $n$ 个以空格隔开的整数 $a_1, a_2, a_3, \\dots a_n$ 依次表示这 $n$ 种纸币的面额。", "outputFormat": "一行一个整数，表示最少使用的纸币张数。", "hint": "对于 $40\\%$ 的数据，满足 $n\\le 10$，$w\\le 100$；  \n对于 $100\\%$ 的数据，满足 $1\\le n\\le 10^3$，$1\\le a_i , w\\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P2843", "type": "P", "difficulty": 5, "samples": [["7 3\n7 6 7 2 1 4 2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["前缀和"], "title": "暗杀", "background": "", "description": "敌方的高级将领都是有很多相同之处的。为了方便找到每名敌将的弱点，我军情报部已经找到了他们的不同点，并将其归纳为 $k$ 种特性。比如 $1$ 号特性就代表一个敌将喜欢打人，$2$ 号特性就代表一个敌将喜欢吃饭，等等。\n\n为了方便存储，我军使用特性值来描述一个敌将的特点。特性值是一个位数为 $k$ 的二进制整数，每一位都可以表示一名敌将的一个特性。$1$ 代表具有此特性，$0$ 代表没有。\n\n我军间谍打听到，不久有 $n$ 个敌方将领会举行一场宴会，而且入场时他们会排成一路纵队入场。如果有连续的 $m$ 个人的每种特性出现的次数之和是一样的，那么我军间谍就很容易暗杀这 $m$ 个人。你需要帮助我军算出，间谍最多可以暗杀多少人？\n\n因为间谍开始攻击后就可能被敌人击毙，所以间谍只能进行一次攻击。", "inputFormat": "第一行两个整数 $n$，$k$。\n\n第二行 $n$ 个整数，第 $i$ 个数 $a_i$ 表示第 $i$ 个敌将的特性值（以十进制的形式输入）。", "outputFormat": "最多可以暗杀多少个敌将。", "hint": "- 对于 $30\\%$ 的数据，$1 \\leq N \\leq 100$；\n- 对于 $50\\%$ 的数据，$1 \\leq N \\leq 1000$；\n- 对于 $100\\%$ 的数据，$1 \\leq N \\leq 10^5$，$1 \\leq K \\leq 30$。", "locale": "zh-CN", "translations": {"en": {"title": "Assassination", "background": "", "description": "The enemy’s senior generals share many similarities. To more easily find each general’s weakness, our intelligence department has identified their differences and summarized them into $k$ types of traits. For example, trait $1$ means a general likes to fight, trait $2$ means a general likes to eat, and so on.\n\nFor storage, we use a trait value to describe a general’s characteristics. The trait value is a binary integer with $k$ bits, where each bit can represent one trait of a general. $1$ means the general has this trait, and $0$ means not.\n\nOur spy has learned that soon $n$ enemy generals will hold a banquet, and they will enter in a single file. If among some consecutive $m$ people, the number of occurrences of each trait are all the same, then our spy can easily assassinate these $m$ people. You need to help determine the maximum number $m$ that the spy can assassinate.\n\nBecause the spy may be killed right after starting the attack, the spy can attack only once.", "inputFormat": "The first line contains two integers $n$, $k$.\n\nThe second line contains $n$ integers, where the $i$-th number $a_i$ represents the $i$-th general’s trait value (given in decimal form).", "outputFormat": "Output the maximum number of enemy generals that can be assassinated.", "hint": "- For 30% of the testdata, $1 \\leq n \\leq 100$.\n- For 50% of the testdata, $1 \\leq n \\leq 1000$.\n- For 100% of the testdata, $1 \\leq n \\leq 10^5$, $1 \\leq k \\leq 30$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "暗杀", "background": "", "description": "敌方的高级将领都是有很多相同之处的。为了方便找到每名敌将的弱点，我军情报部已经找到了他们的不同点，并将其归纳为 $k$ 种特性。比如 $1$ 号特性就代表一个敌将喜欢打人，$2$ 号特性就代表一个敌将喜欢吃饭，等等。\n\n为了方便存储，我军使用特性值来描述一个敌将的特点。特性值是一个位数为 $k$ 的二进制整数，每一位都可以表示一名敌将的一个特性。$1$ 代表具有此特性，$0$ 代表没有。\n\n我军间谍打听到，不久有 $n$ 个敌方将领会举行一场宴会，而且入场时他们会排成一路纵队入场。如果有连续的 $m$ 个人的每种特性出现的次数之和是一样的，那么我军间谍就很容易暗杀这 $m$ 个人。你需要帮助我军算出，间谍最多可以暗杀多少人？\n\n因为间谍开始攻击后就可能被敌人击毙，所以间谍只能进行一次攻击。", "inputFormat": "第一行两个整数 $n$，$k$。\n\n第二行 $n$ 个整数，第 $i$ 个数 $a_i$ 表示第 $i$ 个敌将的特性值（以十进制的形式输入）。", "outputFormat": "最多可以暗杀多少个敌将。", "hint": "- 对于 $30\\%$ 的数据，$1 \\leq N \\leq 100$；\n- 对于 $50\\%$ 的数据，$1 \\leq N \\leq 1000$；\n- 对于 $100\\%$ 的数据，$1 \\leq N \\leq 10^5$，$1 \\leq K \\leq 30$。", "locale": "zh-CN"}}}
{"pid": "P2845", "type": "P", "difficulty": 4, "samples": [["3 6\n1 1 1 2\n2 1 2 2\n1 1 1 3\n2 3 3 1\n1 3 1 2\n1 3 2 1\n", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "2015", "USACO", "广度优先搜索 BFS", "深度优先搜索 DFS"], "title": "[USACO15DEC] Switching on the Lights S", "background": "来源：usaco-2015-dec\n\nFarm John 最近新建了一批巨大的牛棚。这些牛棚构成了一个 $N \\times N$ 的矩形网络 $(1 < N \\leq 100)$。\n\n然而 Bessie 十分怕黑，他想计算可以把多少个牛棚的灯打开。", "description": "有 $N \\times N$ 个房间，组成了一张 $N \\times N$ 的网格图，Bessie 一开始位于左上角 $(1,1)$，并且只能上下左右行走。\n\n\n一开始，只有 $(1,1)$ 这个房间的灯是亮着的，Bessie 只能在亮着灯的房间里活动。\n\n\n有另外 $M$ 条信息，每条信息包含四个数 $a,b,c,d$，表示房间 $(a,b)$ 里有房间 $(c,d)$ 的灯的开关。\n\n\n请计算出最多有多少个房间的灯可以被打开。", "inputFormat": "第一行输入两个整数 $N,M(1 < N \\leq 100,1 < M < 2 \\times 10 ^ 5)$。\n\n第 $2 \\sim M + 1$ 行，每行输入四个整数 $(x_1,y_1),(x_2,y_2)$，代表房间的坐标 $(x_1,y_1)$ 可以点亮房间的坐标 $(x_2,y_2)$。", "outputFormat": "一个数，最多可以点亮的房间数。\n", "hint": "Bessie 可以使用 $(1,1)$ 的开关打开 $(1,2),(1,3)$ 的灯，然后走到 $(1,3)$ 并打开 $(2,1)$ 的灯，走到 $(2,1)$ 并打开 $(2,2)$ 的灯。$(2,3)$ 的开关无法到达。因此可以点亮 $5$ 个房间。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO15DEC] Switching on the Lights S", "background": "Source: usaco-2015-dec.\n\nFarmer John recently built a large set of barns arranged in an $N \\times N$ rectangular grid ($1 < N \\leq 100$).\n\nHowever, Bessie is afraid of the dark and wants to know how many barns’ lights she can turn on.", "description": "There are $N \\times N$ rooms forming an $N \\times N$ grid. Bessie starts at the top-left corner $(1, 1)$ and can move only up, down, left, and right.\n\nInitially, only the room $(1, 1)$ is lit, and Bessie may only move through rooms whose lights are on.\n\nThere are $M$ additional pieces of information. Each describes that a switch in room $(a, b)$ controls the light in room $(c, d)$.\n\nCompute the maximum number of rooms whose lights can be turned on.", "inputFormat": "The first line contains two integers $N, M$ ($1 < N \\leq 100$, $1 < M < 2 \\times 10^5$).\n\nLines $2$ to $M+1$ each contain four integers $(x_1, y_1), (x_2, y_2)$, meaning the switch in room $(x_1, y_1)$ can turn on the light in room $(x_2, y_2)$.", "outputFormat": "Output a single integer, the maximum number of rooms that can be lit.", "hint": "Bessie can use the switch at $(1, 1)$ to turn on the lights in $(1, 2)$ and $(1, 3)$, then move to $(1, 3)$ and turn on $(2, 1)$, move to $(2, 1)$ and turn on $(2, 2)$. The switch at $(2, 3)$ is unreachable. Therefore, $5$ rooms can be lit.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO15DEC] Switching on the Lights S", "background": "来源：usaco-2015-dec\n\nFarm John 最近新建了一批巨大的牛棚。这些牛棚构成了一个 $N \\times N$ 的矩形网络 $(1 < N \\leq 100)$。\n\n然而 Bessie 十分怕黑，他想计算可以把多少个牛棚的灯打开。", "description": "有 $N \\times N$ 个房间，组成了一张 $N \\times N$ 的网格图，Bessie 一开始位于左上角 $(1,1)$，并且只能上下左右行走。\n\n\n一开始，只有 $(1,1)$ 这个房间的灯是亮着的，Bessie 只能在亮着灯的房间里活动。\n\n\n有另外 $M$ 条信息，每条信息包含四个数 $a,b,c,d$，表示房间 $(a,b)$ 里有房间 $(c,d)$ 的灯的开关。\n\n\n请计算出最多有多少个房间的灯可以被打开。", "inputFormat": "第一行输入两个整数 $N,M(1 < N \\leq 100,1 < M < 2 \\times 10 ^ 5)$。\n\n第 $2 \\sim M + 1$ 行，每行输入四个整数 $(x_1,y_1),(x_2,y_2)$，代表房间的坐标 $(x_1,y_1)$ 可以点亮房间的坐标 $(x_2,y_2)$。", "outputFormat": "一个数，最多可以点亮的房间数。\n", "hint": "Bessie 可以使用 $(1,1)$ 的开关打开 $(1,2),(1,3)$ 的灯，然后走到 $(1,3)$ 并打开 $(2,1)$ 的灯，走到 $(2,1)$ 并打开 $(2,2)$ 的灯。$(2,3)$ 的开关无法到达。因此可以点亮 $5$ 个房间。", "locale": "zh-CN"}}}
{"pid": "P2846", "type": "P", "difficulty": 4, "samples": [["4 5\n0 1 2\n0 2 4\n1 2 3\n0 2 4\n1 1 4", "1\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000]}, "tags": ["2008", "线段树", "USACO", "bitset"], "title": "[USACO08NOV] Light Switching G", "background": null, "description": "农夫约翰试图让奶牛玩智力玩具来保持它们的敏锐。谷仓里的灯是较大的玩具之一。$N (2 \\le N \\le 10^5)$ 个牛栏编号为 $1 \\ldots N$，每个牛栏上面都有一盏灯。起初所有的灯都关着。\n\n共有 $M$ 次操作，分为两种。\n1. 指定一个区间 $[S_i,E_i]$，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开）；\n2. 指定一个区间 $[S_i,E_i]$，要求你输出这个区间内有多少盏灯是打开的。", "inputFormat": "第 $1$ 行: 用空格隔开的两个整数 $N$ 和 $M$，$N$ 是灯数。\n\n第 $2\\ldots M+1$ 行: 每行表示一个操作, 有三个用空格分开的整数: 指令号, $S_i$ 和 $E_i$。\n\n若指令号为 $0$，则表示改变 $[S_i,E_i]$ 区间内的灯的状态（把开着的灯关上，关着的灯打开）。\n\n若指令号为 $1$，则表示输出 $[S_i,E_i]$ 这个区间内有多少盏灯是打开的。", "outputFormat": null, "hint": "| 数据点编号 | $N$ | $M$ |\n| :----------: | :----------: | :----------: |\n| $1\\sim 2$ | $\\le 100$ | $\\le 100$ |\n| $3\\sim 4$ | $\\le 1000$ | $\\le 1000$ |\n| $5\\sim 6$ | $\\le 10000$ | $\\le 10000$ |\n| $7\\sim 8$ | $\\le 10^5$ | $\\le 100$ |\n| $9\\sim 10$ | $\\le 100$ | $\\le 10^5$ |\n| $11\\sim 12$ | $\\le 1000$ | $\\le 10^5$ |\n| $13\\sim 14$ | $\\le 10^5$ | $\\le 1000$ |\n| $15\\sim 16$ | $\\le 10000$ | $\\le 10000$ |\n| $17\\sim 18$ | $\\le 10$ | $\\le 10^5$ |\n| $19\\sim 20$ | $\\le 2000$ | $\\le 10^6$ |", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08NOV] Light Switching G", "background": null, "description": "Farmer John tries to keep the cows sharp by letting them play with intellectual toys. One of the larger toys is the lights in the barn. Each of the $N (2 \\le N \\le 10^5)$ cow stalls conveniently numbered $1\\ldots N$ has a colorful light above it.\n\nAt the beginning of the evening, all the lights are off. The cows control the lights with a set of N pushbutton switches that toggle the lights; pushing switch i changes the state of light i from off to on or from on to off.\n\nThe cows read and execute a list of $M(1\\le M \\le 10^5)$ operations expressed as one of two integers ( $0 \\le$ operation $\\le 1$ ).\n\nThe first kind of operation (denoted by a $0$ command) includes two subsequent integers $S_i$ and $E_i (1 \\le S_i \\le E_i \\le N)$ that indicate a starting switch and ending switch. They execute the operation by pushing each pushbutton from $S_i$ through $E_i$ inclusive exactly once.\n\nThe second kind of operation (denoted by a $1$ command) asks the cows to count how many lights are on in the range given by two integers $S_i$ and $E_i (1 \\le S_i \\le E_i \\le N)$ which specify the inclusive range in which the cows should count the number of lights that are on.\n\nHelp FJ ensure the cows are getting the correct answer by processing the list and producing the proper counts.", "inputFormat": null, "outputFormat": null, "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO08NOV] Light Switching G", "background": null, "description": "农夫约翰试图让奶牛玩智力玩具来保持它们的敏锐。谷仓里的灯是较大的玩具之一。$N (2 \\le N \\le 10^5)$ 个牛栏编号为 $1 \\ldots N$，每个牛栏上面都有一盏灯。起初所有的灯都关着。\n\n共有 $M$ 次操作，分为两种。\n1. 指定一个区间 $[S_i,E_i]$，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开）；\n2. 指定一个区间 $[S_i,E_i]$，要求你输出这个区间内有多少盏灯是打开的。", "inputFormat": "第 $1$ 行: 用空格隔开的两个整数 $N$ 和 $M$，$N$ 是灯数。\n\n第 $2\\ldots M+1$ 行: 每行表示一个操作, 有三个用空格分开的整数: 指令号, $S_i$ 和 $E_i$。\n\n若指令号为 $0$，则表示改变 $[S_i,E_i]$ 区间内的灯的状态（把开着的灯关上，关着的灯打开）。\n\n若指令号为 $1$，则表示输出 $[S_i,E_i]$ 这个区间内有多少盏灯是打开的。", "outputFormat": null, "hint": "| 数据点编号 | $N$ | $M$ |\n| :----------: | :----------: | :----------: |\n| $1\\sim 2$ | $\\le 100$ | $\\le 100$ |\n| $3\\sim 4$ | $\\le 1000$ | $\\le 1000$ |\n| $5\\sim 6$ | $\\le 10000$ | $\\le 10000$ |\n| $7\\sim 8$ | $\\le 10^5$ | $\\le 100$ |\n| $9\\sim 10$ | $\\le 100$ | $\\le 10^5$ |\n| $11\\sim 12$ | $\\le 1000$ | $\\le 10^5$ |\n| $13\\sim 14$ | $\\le 10^5$ | $\\le 1000$ |\n| $15\\sim 16$ | $\\le 10000$ | $\\le 10000$ |\n| $17\\sim 18$ | $\\le 10$ | $\\le 10^5$ |\n| $19\\sim 20$ | $\\le 2000$ | $\\le 10^6$ |", "locale": "zh-CN"}}}
{"pid": "P2847", "type": "P", "difficulty": 3, "samples": [["4\n1 3\n5 4\n7 2\n6 1", "17\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "二分", "USACO", "生成树"], "title": "[USACO16DEC] Moocast G", "background": "", "description": "Farmer John's $N$ cows ($1 \\leq N \\leq 1000$) want to organize an emergency \"moo-cast\" system for broadcasting important messages among themselves.\n\nInstead of mooing at each-other over long distances, the cows decide to equip themselves with walkie-talkies, one for each cow. These walkie-talkies each have a limited transmission radius, but cows can relay messages to one-another along a path consisting of several hops, so it is not necessary for every cow to be able to transmit directly to every other cow.\n\nThe cows need to decide how much money to spend on their walkie-talkies. If they spend $X$, they will each get a walkie-talkie capable of transmitting up to a distance of $\\sqrt{X}$. That is, the squared distance between two cows must be at most $X$ for them to be able to communicate.\n\nPlease help the cows determine the minimum integer value of $X$ such that a broadcast from any cow will ultimately be able to reach every other cow.\n", "inputFormat": "The first line of input contains $N$.\n\nThe next $N$ lines each contain the $x$ and $y$ coordinates of a single cow. These are both integers in the range $0 \\ldots 25,000$.\n", "outputFormat": "Write a single line of output containing the integer $X$ giving the minimum amount the cows must spend on walkie-talkies.\n", "hint": "感谢@MrMorning 提供翻译\n", "locale": "en", "translations": {"en": {"title": "[USACO16DEC] Moocast G", "background": "", "description": "Farmer John's $N$ cows ($1 \\leq N \\leq 1000$) want to organize an emergency \"moo-cast\" system for broadcasting important messages among themselves.\n\nInstead of mooing at each-other over long distances, the cows decide to equip themselves with walkie-talkies, one for each cow. These walkie-talkies each have a limited transmission radius, but cows can relay messages to one-another along a path consisting of several hops, so it is not necessary for every cow to be able to transmit directly to every other cow.\n\nThe cows need to decide how much money to spend on their walkie-talkies. If they spend $X$, they will each get a walkie-talkie capable of transmitting up to a distance of $\\sqrt{X}$. That is, the squared distance between two cows must be at most $X$ for them to be able to communicate.\n\nPlease help the cows determine the minimum integer value of $X$ such that a broadcast from any cow will ultimately be able to reach every other cow.\n", "inputFormat": "The first line of input contains $N$.\n\nThe next $N$ lines each contain the $x$ and $y$ coordinates of a single cow. These are both integers in the range $0 \\ldots 25,000$.\n", "outputFormat": "Write a single line of output containing the integer $X$ giving the minimum amount the cows must spend on walkie-talkies.\n", "hint": "感谢@MrMorning 提供翻译\n", "locale": "en"}, "zh-CN": {"title": "[USACO16DEC] Moocast G", "background": "", "description": "Farmer John 的 $N$ 头奶牛（$1 \\leq N \\leq 1000$）希望组织一个紧急的“哞播”系统，用于在它们之间广播重要消息。\n\n为了避免在长距离上互相哞叫，奶牛们决定为自己配备对讲机，每头奶牛一个。这些对讲机每个都有一个有限的传输半径，但奶牛们可以通过多次跳跃的路径中继消息，因此并非每头奶牛都需要能够直接与其他每头奶牛通信。\n\n奶牛们需要决定在对讲机上花费多少钱。如果它们花费 $X$，每头奶牛将获得一个能够传输到 $\\sqrt{X}$ 距离的对讲机。也就是说，两头奶牛之间的平方距离必须不超过 $X$，它们才能通信。\n\n请帮助奶牛们确定 $X$ 的最小整数值，使得从任何一头奶牛发出的广播最终能够到达其他所有奶牛。", "inputFormat": "输入的第一行包含 $N$。\n\n接下来的 $N$ 行每行包含一头奶牛的 $x$ 和 $y$ 坐标。这些坐标都是 $0 \\ldots 25,000$ 范围内的整数。", "outputFormat": "输出一行，包含整数 $X$，表示奶牛们在对讲机上必须花费的最小金额。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2848", "type": "P", "difficulty": 4, "samples": [["3 2\n0 0\n1 0\n2 0\n0 3\n1 3", "20"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2016", "USACO"], "title": "[USACO16DEC] Cow Checklist G", "background": "", "description": "Every day, Farmer John walks through his pasture to check on the well-being ofeach of his cows. On his farm he has two breeds of cows, Holsteins and Guernseys. His $H$ Holsteins are conveniently numbered $1 \\ldots H$, and his $G$ Guernseys are conveniently numbered $1 \\ldots G$($1 \\leq H \\leq 1000, 1 \\leq G \\leq 1000$). Each cow is located at a point inthe 2D plane (not necessarily distinct).\n\nFarmer John starts his tour at Holstein 1, and ends at Holstein $H$.  He wantsto visit each cow along the way, and for convenience in maintaining hischecklist of cows visited so far, he wants to visit the Holsteins and Guernseysin the order in which they are numbered. In the sequence of all $H+G$ cows hevisits, the Holsteins numbered $1 \\ldots H$ should appear as a (not necessarilycontiguous) subsequence, and likewise for the Guernseys. Otherwise stated, thesequence of all $H+G$ cows should be formed by  interleaving the list ofHolsteins numbered $1 \\ldots H$ with the list of Guernseys numbered $1 \\ldots G$.\n\nWhen FJ moves from one cow to another cow traveling a distance of $D$, heexpends $D^2$ energy.  Please help him determine the minimum amount of energyrequired to visit all his cows according to a tour as described above.", "inputFormat": "The first line of input contains $H$ and $G$, separated by a space.\n\nThe next $H$ lines contain the $x$ and $y$ coordinates of the $H$ Holsteins, and the next $G$ lines after that contain coordinates of the Guernseys. Each coordinate is an integer in the range $0 \\ldots 1000$.\n", "outputFormat": "Write a single line of output, giving the minimum energy required for FJ's tour of all the cows.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO16DEC] Cow Checklist G", "background": "", "description": "Every day, Farmer John walks through his pasture to check on the well-being ofeach of his cows. On his farm he has two breeds of cows, Holsteins and Guernseys. His $H$ Holsteins are conveniently numbered $1 \\ldots H$, and his $G$ Guernseys are conveniently numbered $1 \\ldots G$($1 \\leq H \\leq 1000, 1 \\leq G \\leq 1000$). Each cow is located at a point inthe 2D plane (not necessarily distinct).\n\nFarmer John starts his tour at Holstein 1, and ends at Holstein $H$.  He wantsto visit each cow along the way, and for convenience in maintaining hischecklist of cows visited so far, he wants to visit the Holsteins and Guernseysin the order in which they are numbered. In the sequence of all $H+G$ cows hevisits, the Holsteins numbered $1 \\ldots H$ should appear as a (not necessarilycontiguous) subsequence, and likewise for the Guernseys. Otherwise stated, thesequence of all $H+G$ cows should be formed by  interleaving the list ofHolsteins numbered $1 \\ldots H$ with the list of Guernseys numbered $1 \\ldots G$.\n\nWhen FJ moves from one cow to another cow traveling a distance of $D$, heexpends $D^2$ energy.  Please help him determine the minimum amount of energyrequired to visit all his cows according to a tour as described above.", "inputFormat": "The first line of input contains $H$ and $G$, separated by a space.\n\nThe next $H$ lines contain the $x$ and $y$ coordinates of the $H$ Holsteins, and the next $G$ lines after that contain coordinates of the Guernseys. Each coordinate is an integer in the range $0 \\ldots 1000$.\n", "outputFormat": "Write a single line of output, giving the minimum energy required for FJ's tour of all the cows.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO16DEC] Cow Checklist G", "background": null, "description": "每天，Farmer John 都会穿过他的牧场，检查每头奶牛的健康状况。他的农场里有两类奶牛：荷斯坦牛和根西牛。他的 $H$ 头荷斯坦牛被方便地编号为 $1 \\ldots H$，而他的 $G$ 头根西牛被方便地编号为 $1 \\ldots G$（$1 \\leq H \\leq 1000, 1 \\leq G \\leq 1000$）。每头奶牛都位于二维平面中的一个点（不一定不同）。\n\nFarmer John 从荷斯坦牛 $1$ 开始他的巡视，并在荷斯坦牛 $H$ 结束。他希望沿途访问每头奶牛，并且为了方便维护他已经访问过的奶牛清单，他希望按照编号顺序访问荷斯坦牛和根西牛。在他访问的所有 $H+G$ 头奶牛的序列中，编号为 $1 \\ldots H$ 的荷斯坦牛应作为一个（不一定连续的）子序列出现，同样地，编号为 $1 \\ldots G$ 的根西牛也应如此。换句话说，所有 $H+G$ 头奶牛的序列应通过将编号为 $1 \\ldots H$ 的荷斯坦牛列表与编号为 $1 \\ldots G$ 的根西牛列表交错排列而成。\n\n当 Farmer John 从一头奶牛移动到另一头奶牛，移动距离为 $D$ 时，他会消耗 $D^2$ 的能量。请帮助他确定按照上述巡视方式访问所有奶牛所需的最小能量。", "inputFormat": "输入的第一行包含用空格分隔的 $H$ 和 $G$。\n\n接下来的 $H$ 行包含 $H$ 头荷斯坦牛的 $x$ 和 $y$ 坐标，随后的 $G$ 行包含根西牛的坐标。每个坐标都是 $0 \\ldots 1000$ 范围内的整数。", "outputFormat": "输出一行，表示 Farmer John 巡视所有奶牛所需的最小能量。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2849", "type": "P", "difficulty": 3, "samples": [["5 2\n0 0\n8 3\n1 1\n10 -5\n2 2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "USACO"], "title": "[USACO14DEC] Marathon S", "background": "", "description": "Unhappy with the poor health of his cows, Farmer John enrolls them in an assortment of different physical fitness activities. His prize cow Bessie is enrolled in a running class, where she is eventually expected to run a marathon through the downtown area of the city near Farmer John's farm!\n\n\nThe marathon course consists of N checkpoints (3 <= N <= 500) to be visited in sequence, where checkpoint 1 is the starting location and checkpoint N is the finish. Bessie is supposed to visit all of these checkpoints one by one, but being the lazy cow she is, she decides that she will skip up to K checkpoints (K < N) in order to shorten her total journey. She cannot skip checkpoints 1 or N, however, since that would be too noticeable.\n\n\nPlease help Bessie find the minimum distance that she has to run if she can skip up to K checkpoints.\n\n\nSince the course is set in a downtown area with a grid of streets, the distance between two checkpoints at locations (x1, y1) and (x2, y2) is given by |x1-x2| + |y1-y2|.\n\nBessie 参加城市马拉松比赛，要顺序经过 $N (3 \\leq N \\leq 500)$ 个检查点，其中检查点 $1$ 是起点，检查点 $N$ 是终点。 Bessie尝试略过 $K(K < N)$ 个检查点，以减少总路程，检查点 $1$ 和检查点 $N$ 不能被略过。两个检查点的距离是 $|x_1-x_2| + |y_1-y_2|$。\n\n输入输出格式\n", "inputFormat": "The first line gives the values of N and K.\n\n\nThe next N lines each contain two space-separated integers, x and y,representing a checkpoint (-1000 <= x <= 1000, -1000 <= y <= 1000).\n\n\nThe checkpoints are given in the order that they must be visited.\n\n\nNote that the course might cross over itself several times, with several checkpoints occurring at the same physical location. When Bessie skips such a checkpoint, she only skips one instance of the checkpoint -- she does not skip every checkpoint occurring at the same location.\n", "outputFormat": "Output the minimum distance that Bessie can run by skipping up to K checkpoints. In the sample case shown here, skipping the checkpoints at (8, 3) and (10, -5) leads to the minimum total distance of 4.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO14DEC] Marathon S", "background": "", "description": "Unhappy with the poor health of his cows, Farmer John enrolls them in an assortment of different physical fitness activities. His prize cow Bessie is enrolled in a running class, where she is eventually expected to run a marathon through the downtown area of the city near Farmer John's farm!\n\n\nThe marathon course consists of N checkpoints (3 <= N <= 500) to be visited in sequence, where checkpoint 1 is the starting location and checkpoint N is the finish. Bessie is supposed to visit all of these checkpoints one by one, but being the lazy cow she is, she decides that she will skip up to K checkpoints (K < N) in order to shorten her total journey. She cannot skip checkpoints 1 or N, however, since that would be too noticeable.\n\n\nPlease help Bessie find the minimum distance that she has to run if she can skip up to K checkpoints.\n\n\nSince the course is set in a downtown area with a grid of streets, the distance between two checkpoints at locations (x1, y1) and (x2, y2) is given by |x1-x2| + |y1-y2|.\n\nBessie 参加城市马拉松比赛，要顺序经过 $N (3 \\leq N \\leq 500)$ 个检查点，其中检查点 $1$ 是起点，检查点 $N$ 是终点。 Bessie尝试略过 $K(K < N)$ 个检查点，以减少总路程，检查点 $1$ 和检查点 $N$ 不能被略过。两个检查点的距离是 $|x_1-x_2| + |y_1-y_2|$。\n\n输入输出格式\n", "inputFormat": "The first line gives the values of N and K.\n\n\nThe next N lines each contain two space-separated integers, x and y,representing a checkpoint (-1000 <= x <= 1000, -1000 <= y <= 1000).\n\n\nThe checkpoints are given in the order that they must be visited.\n\n\nNote that the course might cross over itself several times, with several checkpoints occurring at the same physical location. When Bessie skips such a checkpoint, she only skips one instance of the checkpoint -- she does not skip every checkpoint occurring at the same location.\n", "outputFormat": "Output the minimum distance that Bessie can run by skipping up to K checkpoints. In the sample case shown here, skipping the checkpoints at (8, 3) and (10, -5) leads to the minimum total distance of 4.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO14DEC] Marathon S", "background": "", "description": "由于对他的奶牛的健康状况不佳而感到不满，牧场主约翰让它们参加各种各样的体育健身活动。最让他感到自豪的奶牛是 Bessie，她将参加约翰牧场附近城市里的马拉松比赛！\n\n马拉松比赛有 $N$ 个检查点 $(3\\leq N\\leq 500)$ ，需要按顺序访问。检查点 $1$ 是起点，检查点 $N$ 是终点。Bessie 应该按顺序一一访问所有的这些检查点，但由于她是一头懒惰的牛（懒惰竟然还选择跑马拉松！），于是她决定跳过 $K(K<N)$ 个检查点以缩小她的赛程。但她不能跳过第 $1$ 个和第 $N$ 个检查点，因为这样太明显了。\n\n请你帮助 Bessie 计算出跳过中间的 $K$ 个检查点后她最少要跑多少距离。\n\n注意：由于街道是网格状的，我们用坐标来表示点的位置。但是 $(x_1,y_1),(x_2,y_2)$ 两点间的距离应为 $|x_1-x_2|+|y_1-y_2|$，这种测量距离的方法被称为“曼哈顿”距离，这是因为在市中心的网格路中，你可以沿平行于 $x$ 轴或 $y$ 轴的方向走，但不能沿直线到达。", "inputFormat": "第一行：两个正整数 $N$ 和 $K$。\n\n第 $2$ 行到第 $N+1$ 行，每行两个整数$x,y (-1000\\leq x\\leq 1000,-1000\\leq y\\leq 1000)$。\n\n这里给出了检查点的顺序，她必须按顺序访问。注意：可能会有几个检查点出现在同一位置，Bessie 跳过这样的检查点时，相当于只跳过其中的一个检查点。", "outputFormat": "输出跳过某一个检查点后 Bessie 可以跑的最短距离。\n\n感谢@彭骐飞 提供的翻译", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2850", "type": "P", "difficulty": 4, "samples": [["2\n3 3 1\n1 2 2\n1 3 4\n2 3 1\n3 1 3\n3 2 1\n1 2 3\n2 3 4\n3 1 8", "NO\nYES"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2006", "USACO", "深度优先搜索 DFS", "负权环"], "title": "[USACO06DEC] Wormholes G", "background": "[英文题面见此链接](https://www.luogu.com.cn/paste/mxuf6zpl)", "description": "Farmer John 在探索他的农场时发现了许多神奇的虫洞。虫洞的特性非常特殊——它是一个单向通道，能将你传送到它的目的地，而且时间还会回溯到过去！FJ 的每个农场包含 $N (1 \\le N \\le 500)$ 块编号为 $1 \\sim N$ 的田地、$M (1 \\le M \\le 2500)$ 条双向路径和 $W (1 \\le W \\le 200)$ 个虫洞。\n\n作为狂热的时间旅行爱好者，FJ 希望实现：从某块田地出发，经过若干路径和虫洞后，在初始离开时间之前回到起点。这样或许他能遇见自己 :)\n\n为了判断可行性，FJ 将提供 $F (1 \\le F \\le 5)$ 个农场的完整地图。所有路径通行耗时不超过 $10,000$ 秒，虫洞最多能将 FJ 带回 $10,000$ 秒前。", "inputFormat": "第 $1$ 行：一个整数 $F$，表示农场数。后续为 $F$ 个农场的数据。\n\n每个农场：\n\n- 第 $1$ 行：三个空格分隔的整数 $N$（田地数）, $M$（双向路径数）, $W$（虫洞数）。\n\n- 第 $2 \\sim M+1$ 行：每行三个空格分隔的整数 $(S, E, T)$，表示 $S$ 和 $E$ 间有一条耗时 $T$ 秒的双向路径。两块田地间可能存在多条路径。\n\n- 第 $M+2 \\sim M+W+1$ 行：每行三个空格分隔的整数 $(S, E, T)$，表示一条从 $S$ 到 $E$ 的单向虫洞，可将 FJ 带回 $T$ 秒前。", "outputFormat": "输出 $F$ 行：对每个农场，若 FJ 能达成目标输出`YES`，否则输出`NO`。", "hint": "- 农场 $1$：FJ 无法实现时间回溯。\n\n- 农场 $2$：FJ 可通过环 $1 \\to 2 \\to 3 \\to 1$ 回到起点 $1$ 秒前（可从环上任意点出发实现）。\n\n翻译：DeepSeek-R1", "locale": "zh-CN", "translations": {"en": {"title": "[USACO06DEC] Wormholes G", "background": null, "description": "While exploring his many farms, Farmer John has discovered a number of amazing wormholes. A wormhole is very peculiar because it is a one-way path that delivers you to its destination at a time that is **BEFORE** you entered the wormhole! Each of FJ's farms comprises $N (1 \\le N \\le 500)$ fields conveniently numbered $1 \\sim N, M (1 \\le M \\le 2500)$ paths, and $W (1 \\le W \\le 200)$ wormholes.\n\nAs FJ is an avid time-traveling fan, he wants to do the following: start at some field, travel through some paths and wormholes, and return to the starting field a time before his initial departure. Perhaps he will be able to meet himself :) .\n\nTo help FJ find out whether this is possible or not, he will supply you with complete maps to $F (1 \\le F \\le 5)$ of his farms. No paths will take longer than $10,000$ seconds to travel and no wormhole can bring FJ back in time by more than $10,000$ seconds.", "inputFormat": "Line $1$: A single integer, $F$. $F$ farm descriptions follow.\n\nLine $1$ of each farm: Three space-separated integers respectively: $N$, $M$, and $W$.\n\nLines $2 \\sim M+1$ of each farm: Three space-separated numbers $(S, E, T)$ that describe, respectively: a bidirectional path between $S$ and $E$ that requires $T$ seconds to traverse. Two fields might be connected by more than one path.\n\nLines $M+2 \\sim M+W+1$ of each farm: Three space-separated numbers $(S, E, T)$ that describe, respectively: A one way path from $S$ to $E$ that also moves the traveler back $T$ seconds.", "outputFormat": "Lines $1 \\sim F$: For each farm, output `YES` if FJ can achieve his goal, otherwise output `NO`.", "hint": "For farm $1$, FJ cannot travel back in time.\n\nFor farm $2$, FJ could travel back in time by the cycle $1 \\to 2 \\to 3 \\to 1$, arriving back at his starting location $1$ second before he leaves. He could start from anywhere on the cycle to accomplish this.", "locale": "en"}, "zh-CN": {"title": "[USACO06DEC] Wormholes G", "background": "[英文题面见此链接](https://www.luogu.com.cn/paste/mxuf6zpl)", "description": "Farmer John 在探索他的农场时发现了许多神奇的虫洞。虫洞的特性非常特殊——它是一个单向通道，能将你传送到它的目的地，而且时间还会回溯到过去！FJ 的每个农场包含 $N (1 \\le N \\le 500)$ 块编号为 $1 \\sim N$ 的田地、$M (1 \\le M \\le 2500)$ 条双向路径和 $W (1 \\le W \\le 200)$ 个虫洞。\n\n作为狂热的时间旅行爱好者，FJ 希望实现：从某块田地出发，经过若干路径和虫洞后，在初始离开时间之前回到起点。这样或许他能遇见自己 :)\n\n为了判断可行性，FJ 将提供 $F (1 \\le F \\le 5)$ 个农场的完整地图。所有路径通行耗时不超过 $10,000$ 秒，虫洞最多能将 FJ 带回 $10,000$ 秒前。", "inputFormat": "第 $1$ 行：一个整数 $F$，表示农场数。后续为 $F$ 个农场的数据。\n\n每个农场：\n\n- 第 $1$ 行：三个空格分隔的整数 $N$（田地数）, $M$（双向路径数）, $W$（虫洞数）。\n\n- 第 $2 \\sim M+1$ 行：每行三个空格分隔的整数 $(S, E, T)$，表示 $S$ 和 $E$ 间有一条耗时 $T$ 秒的双向路径。两块田地间可能存在多条路径。\n\n- 第 $M+2 \\sim M+W+1$ 行：每行三个空格分隔的整数 $(S, E, T)$，表示一条从 $S$ 到 $E$ 的单向虫洞，可将 FJ 带回 $T$ 秒前。", "outputFormat": "输出 $F$ 行：对每个农场，若 FJ 能达成目标输出`YES`，否则输出`NO`。", "hint": "- 农场 $1$：FJ 无法实现时间回溯。\n\n- 农场 $2$：FJ 可通过环 $1 \\to 2 \\to 3 \\to 1$ 回到起点 $1$ 秒前（可从环上任意点出发实现）。\n\n翻译：DeepSeek-R1", "locale": "zh-CN"}}}
{"pid": "P2851", "type": "P", "difficulty": 5, "samples": [["3 70\n5 25 50\n5 2 1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2006", "USACO", "背包 DP", "进制"], "title": "[USACO06DEC] The Fewest Coins G", "background": null, "description": "农夫 John 想到镇上买些补给。为了高效地完成任务，他想使硬币的转手次数最少。即使他交付的硬 币数与找零得到的的硬币数最少。 \n\n\nJohn 想要买价值为 $T(1 \\le T \\le 10,000)$ 的东西。有 $N(1 \\le N \\le 100)$ 种货币参与流通，面值分别为 $V_1,V_2,\\dots,V_N(1 \\le V_i \\le 120)$。John 有 $C_i$ 个面值为 $V_i$ 的硬币（$0 \\le C_i \\le 10 ^ 4$）。\n\n我们假设店主有无限多的硬币， 并总按最优方案找零。**注意**无解输出 `-1`。", "inputFormat": "第一行两个整数 $N,T$。\n\n第二行 $N$ 个整数 $V_1 \\sim V_N$。\n\n第三行 $N$ 个整数 $C_1 \\sim C_N$。", "outputFormat": "一个整数表示答案（无解输出 $-1$）。", "hint": "样例的最优方案：农夫 John 支付面值 $50$ 和 $25$ 的硬币各一枚，店主找回面值为 $5$ 的硬币一枚。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO06DEC] The Fewest Coins G", "background": null, "description": "Farmer John has gone to town to buy some farm supplies. Being a very efficient man, he always pays for his goods in such a way that the smallest number of coins changes hands, i.e., the number of coins he uses to pay plus the number of coins he receives in change is minimized. Help him to determine what this minimum number is.\n\nFJ wants to buy $T (1 \\le T \\le 10,000)$ cents of supplies. The currency system has $N (1 \\le N \\le 100)$ different coins, with values $V1, V2, \\dots, V_N (1 \\le V_i \\le 120)$. Farmer John is carrying $C_1$ coins of value $V_1$, $C_2$ coins of value $V_2$, ...., and $C_N$ coins of value $V_N\\ (0 \\le C_i \\le 10,000)$. The shopkeeper has an unlimited supply of all the coins, and always makes change in the most efficient manner (although Farmer John must be sure to pay in a way that makes it possible to make the correct change).", "inputFormat": "Line $1$: Two space-separated integers: $N$ and $T$.\n\nLine $2$: $N$ space-separated integers, respectively $V_1, V_2, \\dots, V_N$.\n\nLine $3$: $N$ space-separated integers, respectively $C_1, C_2, \\dots C_N$.", "outputFormat": "Line $1$: A line containing a single integer, the minimum number of coins involved in a payment and change-making. If it is impossible for Farmer John to pay and receive exact change, output $-1$.", "hint": "Farmer John pays $75$ cents using a $50$ cents and a $25$ cents coin, and receives a $5$ cents coin in change, for a total of $3$ coins used in the transaction.", "locale": "en"}, "zh-CN": {"title": "[USACO06DEC] The Fewest Coins G", "background": null, "description": "农夫 John 想到镇上买些补给。为了高效地完成任务，他想使硬币的转手次数最少。即使他交付的硬 币数与找零得到的的硬币数最少。 \n\n\nJohn 想要买价值为 $T(1 \\le T \\le 10,000)$ 的东西。有 $N(1 \\le N \\le 100)$ 种货币参与流通，面值分别为 $V_1,V_2,\\dots,V_N(1 \\le V_i \\le 120)$。John 有 $C_i$ 个面值为 $V_i$ 的硬币（$0 \\le C_i \\le 10 ^ 4$）。\n\n我们假设店主有无限多的硬币， 并总按最优方案找零。**注意**无解输出 `-1`。", "inputFormat": "第一行两个整数 $N,T$。\n\n第二行 $N$ 个整数 $V_1 \\sim V_N$。\n\n第三行 $N$ 个整数 $C_1 \\sim C_N$。", "outputFormat": "一个整数表示答案（无解输出 $-1$）。", "hint": "样例的最优方案：农夫 John 支付面值 $50$ 和 $25$ 的硬币各一枚，店主找回面值为 $5$ 的硬币一枚。", "locale": "zh-CN"}}}
{"pid": "P2852", "type": "P", "difficulty": 4, "samples": [["8 2\n1\n2\n3\n2\n3\n2\n3\n1", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "二分", "USACO", "哈希 hashing", "后缀数组 SA"], "title": "[USACO06DEC] Milk Patterns G", "background": "", "description": "Farmer John has noticed that the quality of milk given by his cows varies from day to day. On further investigation, he discovered that although he can't predict the quality of milk from one day to the next, there are some regular patterns in the daily milk quality.\n\nTo perform a rigorous study, he has invented a complex classification scheme by which each milk sample is recorded as an integer between 0 and 1,000,000 inclusive, and has recorded data from a single cow over N (1 ≤ N ≤ 20,000) days. He wishes to find the longest pattern of samples which repeats identically at least K (2 ≤ K ≤ N) times. This may include overlapping patterns -- 1 2 3 2 3 2 3 1 repeats 2 3 2 3 twice, for example.\n\nHelp Farmer John by finding the longest repeating subsequence in the sequence of samples. It is guaranteed that at least one subsequence is repeated at least K times.\n", "inputFormat": "Line 1: Two space-separated integers: N and K\n\n\nLines 2..N+1: N integers, one per line, the quality of the milk on day i appears on the ith line.\n", "outputFormat": "Line 1: One integer, the length of the longest pattern which occurs at least K times\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO06DEC] Milk Patterns G", "background": "", "description": "Farmer John has noticed that the quality of milk given by his cows varies from day to day. On further investigation, he discovered that although he can't predict the quality of milk from one day to the next, there are some regular patterns in the daily milk quality.\n\nTo perform a rigorous study, he has invented a complex classification scheme by which each milk sample is recorded as an integer between 0 and 1,000,000 inclusive, and has recorded data from a single cow over N (1 ≤ N ≤ 20,000) days. He wishes to find the longest pattern of samples which repeats identically at least K (2 ≤ K ≤ N) times. This may include overlapping patterns -- 1 2 3 2 3 2 3 1 repeats 2 3 2 3 twice, for example.\n\nHelp Farmer John by finding the longest repeating subsequence in the sequence of samples. It is guaranteed that at least one subsequence is repeated at least K times.\n", "inputFormat": "Line 1: Two space-separated integers: N and K\n\n\nLines 2..N+1: N integers, one per line, the quality of the milk on day i appears on the ith line.\n", "outputFormat": "Line 1: One integer, the length of the longest pattern which occurs at least K times\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO06DEC] Milk Patterns G", "background": null, "description": "农夫约翰注意到他的奶牛所产的牛奶质量每天都在变化。经过进一步调查，他发现虽然无法预测牛奶质量从一天到下一天的变化，但每天的牛奶质量中存在一些规律模式。\n\n为了进行严格的研究，他发明了一种复杂的分类方案，其中每个牛奶样本被记录为一个介于 $0$ 和 $1,000,000$ 之间的整数，并记录了一头奶牛在 $N\\ (1 \\le N \\le 20,000)$ 天内的数据。他希望找到一个最长的样本模式，该模式至少重复 $K\\ (2 \\le K \\le N)$ 次。这可能包括重叠的模式——例如，`1 2 3 2 3 2 3 1` 中的 `2 3 2 3` 重复了两次。\n\n帮助农夫约翰找到样本序列中最长的重复子序列。保证至少有一个子序列重复至少 $K$ 次。", "inputFormat": "第 $1$ 行：两个用空格分隔的整数：$N$ 和 $K$。\n\n第 $2$ 行到第 $N+1$ 行：$N$ 个整数，每行一个，第 $i$ 行表示第 $i$ 天的牛奶质量。", "outputFormat": "第 $1$ 行：一个整数，表示至少出现 $K$ 次的最长模式的长度。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P2853", "type": "P", "difficulty": 3, "samples": [["2 4 4\n2\n3\n1 2\n1 4\n2 3\n3 4", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "图论", "贪心", "2006", "USACO", "深度优先搜索 DFS"], "title": "[USACO06DEC] Cow Picnic S", "background": "", "description": "The cows are having a picnic! Each of Farmer John's K (1 ≤ K ≤ 100) cows is grazing in one of N (1 ≤ N ≤ 1,000) pastures, conveniently numbered 1...N. The pastures are connected by M (1 ≤ M ≤ 10,000) one-way paths (no path connects a pasture to itself).\n\nThe cows want to gather in the same pasture for their picnic, but (because of the one-way paths) some cows may only be able to get to some pastures. Help the cows out by figuring out how many pastures are reachable by all cows, and hence are possible picnic locations.", "inputFormat": "Line 1: Three space-separated integers, respectively: K, N, and M\n\nLines 2..K+1: Line i+1 contains a single integer (1..N) which is the number of the pasture in which cow i is grazing.\n\nLines K+2..M+K+1: Each line contains two space-separated integers, respectively A and B (both 1..N and A != B), representing a one-way path from pasture A to pasture B.", "outputFormat": "Line 1: Three space-separated integers, respectively: K, N, and M\n\nLines 2..K+1: Line i+1 contains a single integer (1..N) which is the number of the pasture in which cow i is grazing.\n\nLines K+2..M+K+1: Each line contains two space-separated integers, respectively A and B (both 1..N and A != B), representing a one-way path from pasture A to pasture B.", "hint": "The cows can meet in pastures 3 or 4.", "locale": "en", "translations": {"en": {"title": "[USACO06DEC] Cow Picnic S", "background": "", "description": "The cows are having a picnic! Each of Farmer John's K (1 ≤ K ≤ 100) cows is grazing in one of N (1 ≤ N ≤ 1,000) pastures, conveniently numbered 1...N. The pastures are connected by M (1 ≤ M ≤ 10,000) one-way paths (no path connects a pasture to itself).\n\nThe cows want to gather in the same pasture for their picnic, but (because of the one-way paths) some cows may only be able to get to some pastures. Help the cows out by figuring out how many pastures are reachable by all cows, and hence are possible picnic locations.", "inputFormat": "Line 1: Three space-separated integers, respectively: K, N, and M\n\nLines 2..K+1: Line i+1 contains a single integer (1..N) which is the number of the pasture in which cow i is grazing.\n\nLines K+2..M+K+1: Each line contains two space-separated integers, respectively A and B (both 1..N and A != B), representing a one-way path from pasture A to pasture B.", "outputFormat": "Line 1: Three space-separated integers, respectively: K, N, and M\n\nLines 2..K+1: Line i+1 contains a single integer (1..N) which is the number of the pasture in which cow i is grazing.\n\nLines K+2..M+K+1: Each line contains two space-separated integers, respectively A and B (both 1..N and A != B), representing a one-way path from pasture A to pasture B.", "hint": "The cows can meet in pastures 3 or 4.", "locale": "en"}, "zh-CN": {"title": "[USACO06DEC] Cow Picnic S", "background": null, "description": "$K(1 \\le K \\le 100)$ 只奶牛分散在 $N(1 \\le N \\le 1000)$ 个牧场．现在她们要集中起来进餐。牧场之间有 $M(1 \\le M \\le 10000)$ 条有向路径连接（没有路径将牧场连接到自身）。她们进餐的地点必须是所有奶牛都可到达的地方。那么，有多少这样的牧场可供进食呢？", "inputFormat": "第 $1$ 行：三个以空格分隔的整数，分别为：$K$, $N$, $M$。\n\n第 $2$ 行到第 $K+1$ 行：每行包含一个整数 $C_i$（$1\\le C_i\\le N$），表示第 $i$ 头奶牛所在的牧场编号。  \n\n第 $K+2$ 行到第 $M+K+1$ 行：每行包含两个以空格分隔的整数 $A$ 和 $B$，表示一条从牧场 $A$ 到牧场 $B$ 的单向路径。（$1\\le A,B\\le N, A\\neq B$）", "outputFormat": "第一行：一个整数，即所有奶牛都可以到达的牧场数量。", "hint": "奶牛可以在 $3$ 或 $4$ 号牧场相遇。", "locale": "zh-CN"}}}
{"pid": "P2854", "type": "P", "difficulty": 4, "samples": [["5 6 10\n0 2 20 6\n2 3 5 6\n0 1 2 1\n1 1 1 3\n1 2 5 4\n3 2 10 2", "17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2006", "USACO", "背包 DP"], "title": "[USACO06DEC] Cow Roller Coaster S", "background": "", "description": "The cows are building a roller coaster! They want your help to design as fun a roller coaster as possible, while keeping to the budget.\n\nThe roller coaster will be built on a long linear stretch of land of length L (1 ≤ L ≤ 1,000). The roller coaster comprises a collection of some of the N (1 ≤ N ≤ 10,000) different interchangable components. Each component i has a fixed length Wi (1 ≤ Wi ≤ L). Due to varying terrain, each component i can be only built starting at location Xi (0 ≤ Xi ≤ L - Wi). The cows want to string together various roller coaster components starting at 0 and ending at L so that the end of each component (except the last) is the start of the next component.\n\nEach component i has a \"fun rating\" Fi (1 ≤ Fi ≤ 1,000,000) and a cost Ci (1 ≤ Ci ≤ 1000). The total fun of the roller coster is the sum of the fun from each component used; the total cost is likewise the sum of the costs of each component used. The cows' total budget is B (1 ≤ B ≤ 1000). Help the cows determine the most fun roller coaster that they can build with their budget.", "inputFormat": "Line 1: Three space-separated integers: L, N and B.\n\n\nLines 2..N+1: Line i+1 contains four space-separated integers, respectively: Xi, Wi, Fi, and Ci.\n", "outputFormat": "Line 1: A single integer that is the maximum fun value that a roller-coaster can have while staying within the budget and meeting all the other constraints. If it is not possible to build a roller-coaster within budget, output -1.\n", "hint": "Taking the 3rd, 5th and 6th components gives a connected roller-coaster with fun value 17 and cost 7. Taking the first two components would give a more fun roller-coaster (25) but would be over budget.\n", "locale": "en", "translations": {"en": {"title": "[USACO06DEC] Cow Roller Coaster S", "background": "", "description": "The cows are building a roller coaster! They want your help to design as fun a roller coaster as possible, while keeping to the budget.\n\nThe roller coaster will be built on a long linear stretch of land of length L (1 ≤ L ≤ 1,000). The roller coaster comprises a collection of some of the N (1 ≤ N ≤ 10,000) different interchangable components. Each component i has a fixed length Wi (1 ≤ Wi ≤ L). Due to varying terrain, each component i can be only built starting at location Xi (0 ≤ Xi ≤ L - Wi). The cows want to string together various roller coaster components starting at 0 and ending at L so that the end of each component (except the last) is the start of the next component.\n\nEach component i has a \"fun rating\" Fi (1 ≤ Fi ≤ 1,000,000) and a cost Ci (1 ≤ Ci ≤ 1000). The total fun of the roller coster is the sum of the fun from each component used; the total cost is likewise the sum of the costs of each component used. The cows' total budget is B (1 ≤ B ≤ 1000). Help the cows determine the most fun roller coaster that they can build with their budget.", "inputFormat": "Line 1: Three space-separated integers: L, N and B.\n\n\nLines 2..N+1: Line i+1 contains four space-separated integers, respectively: Xi, Wi, Fi, and Ci.\n", "outputFormat": "Line 1: A single integer that is the maximum fun value that a roller-coaster can have while staying within the budget and meeting all the other constraints. If it is not possible to build a roller-coaster within budget, output -1.\n", "hint": "Taking the 3rd, 5th and 6th components gives a connected roller-coaster with fun value 17 and cost 7. Taking the first two components would give a more fun roller-coaster (25) but would be over budget.\n", "locale": "en"}, "zh-CN": {"title": "[USACO06DEC] Cow Roller Coaster S", "background": null, "description": "有 $n$ 条线段，每条线段只能放在数轴上的一个特定位置，并且第 $i$ 根线段有如下几个属性：$X_i$（该线段放在数轴上的起点），$W_i$（该线段长度），$F_i$（你若使用该线段你能获得的价值），$C_i$（你若使用该线段你所需要的费用）。现在让你从中选出一些线段，使得这些线段能够铺满数轴上的区间 $[0,L]$ 且线段必须首尾相接（也就是不能重叠，也不能空缺），并且所花费用和不超过 $B$，同时要使你收获的价值尽量大，请你找到这个方案。", "inputFormat": "第一行三个整数 $L, n, B$。\n\n接下来 $n$ 行，每行四个整数 $X_i, W_i, F_i, C_i$ 表示第 $i$ 根线段的四个属性。", "outputFormat": "一个整数，表示你能获得的最大价值和。若无法满足上述要求，则输出 $-1$。", "hint": "对于 $100\\%$ 的数据，保证 $1\\le W_i\\le L\\le 1000,1\\le N\\le 10000,1\\le F_i\\le 10^6,1\\le B,C_i\\le 1000,0\\le X_i\\le L-W_i$", "locale": "zh-CN"}}}
{"pid": "P2855", "type": "P", "difficulty": 3, "samples": [["25 5 2\n2\n14\n11\n21\n17", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "二分", "USACO"], "title": "[USACO06DEC] River Hopscotch S", "background": null, "description": "奶牛们每年都会举办一次活动，内容是一种奇特的跳房子游戏，即在河中小心翼翼地从一块石头跳到另一块石头。 比赛在一条笔直的长河上进行，起点有一块石头，终点有另一块石头，距离起点 $L$ 个单位（$1 \\le L\\le 1,000,000,000$）。 在起点和终点岩石之间的河道上，会出现 $N$ 个（$0\\le N\\le 50,000 $ 个）更多的岩石，每个岩石与起点的距离为一个整数 $D_i$（$0<D_i<L$）。\n\n玩游戏时，每头牛依次从起点岩石开始，努力到达终点岩石，只能从一个岩石跳到另一个岩石。 当然，不那么灵活的奶牛永远也到不了终点岩石，最后只能掉进河里。\n\n农场主约翰为自己的奶牛感到骄傲，每年都会观看这项比赛。 但随着时间的推移，他已经厌倦了看着其他农户的胆小的奶牛一瘸一拐地走过石头之间的短距离。 他计划移走几块石头，以增加奶牛跳到终点的最短距离。 他知道自己无法移走起点和终点的石头，但他计算出自己有足够的资源移走最多 $M$ 块石头（$0 \\le M \\le N$）。\n\nFJ 想知道，在开始移走石头之前，他能将最短距离增加多少。 请帮助农场主约翰确定在移走最优的 $M$ 组石块后，奶牛要跳过的最短距离。\n\n形式化中文题意：\n\n对于给定在一维位置的 $N$ 个点，选择 $M$ 个点进行移除，使得每两个点之间的距离最小值最大。", "inputFormat": "第 $1$ 行，三个空格分隔的整数：$L$、$N$ 和 $M$。\n\n\n第 $2\\dots N+1$ 行，每行包含一个整数，表示某块岩石距离起始岩石的距离。 没有两块石头的位置相同。", "outputFormat": "一个整数，即奶牛在移走 $M$ 块石头后所需跳跃的最短距离的最大值。", "hint": "在移除任何石块之前，最短的跳跃是从 $0$（起点）到 $2$ 的 $2$ 级跳；在移除 $2$ 和 $14$ 处的石块之后，所需的最短跳跃是 $4$ 级跳（从 $17$ 到 $21$ 或从 $21$ 到 $25$）。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO06DEC] River Hopscotch S", "background": "", "description": "Every year the cows hold a peculiar hopscotch event, carefully jumping from one rock to another in a river. The competition is on a long straight river with a rock at the start and another rock at the end, which is $L$ units away from the start ($1 \\le L\\le 1,000,000,000$). Between the start and end rocks, there are $N$ additional rocks ($0\\le N\\le 50,000 $), each at an integer distance $D_i$ from the start ($0<D_i<L$).\n\nDuring the game, each cow starts from the start rock and tries to reach the end rock, only allowed to jump from one rock to another. Of course, the less agile cows will never reach the end rock and will eventually fall into the river.\n\nFarmer John is proud of his cows and watches this contest every year. Over time, however, he has grown tired of watching timid cows from other farms hobble across short gaps between rocks. He plans to remove some rocks to increase the minimal distance the cows must jump to reach the end. He knows he cannot remove the start and end rocks, but he has enough resources to remove at most $M$ rocks ($0 \\le M \\le N$).\n\nBefore he starts removing rocks, FJ wants to know how much he can increase the minimal jump distance. Please determine, after optimally removing at most $M$ rocks, the maximum possible minimal distance that any cow must jump.\n\nFormal statement: Given $N$ points on a line, remove at most $M$ points so that the minimum distance between consecutive remaining points (including the start at $0$ and the end at $L$) is maximized.", "inputFormat": "The first line contains three space-separated integers: $L$, $N$, and $M$.\n\nLines $2 \\dots N+1$ each contain one integer, the distance of a rock from the start. No two rocks share the same position.", "outputFormat": "Output a single integer, the maximum possible value of the minimal jump distance after removing at most $M$ rocks.", "hint": "Before removing any rock, the shortest jump is a length-$2$ jump from $0$ (start) to $2$; after removing the rocks at $2$ and $14$, the required shortest jump is $4$ (from $17$ to $21$ or from $21$ to $25$).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO06DEC] River Hopscotch S", "background": null, "description": "奶牛们每年都会举办一次活动，内容是一种奇特的跳房子游戏，即在河中小心翼翼地从一块石头跳到另一块石头。 比赛在一条笔直的长河上进行，起点有一块石头，终点有另一块石头，距离起点 $L$ 个单位（$1 \\le L\\le 1,000,000,000$）。 在起点和终点岩石之间的河道上，会出现 $N$ 个（$0\\le N\\le 50,000 $ 个）更多的岩石，每个岩石与起点的距离为一个整数 $D_i$（$0<D_i<L$）。\n\n玩游戏时，每头牛依次从起点岩石开始，努力到达终点岩石，只能从一个岩石跳到另一个岩石。 当然，不那么灵活的奶牛永远也到不了终点岩石，最后只能掉进河里。\n\n农场主约翰为自己的奶牛感到骄傲，每年都会观看这项比赛。 但随着时间的推移，他已经厌倦了看着其他农户的胆小的奶牛一瘸一拐地走过石头之间的短距离。 他计划移走几块石头，以增加奶牛跳到终点的最短距离。 他知道自己无法移走起点和终点的石头，但他计算出自己有足够的资源移走最多 $M$ 块石头（$0 \\le M \\le N$）。\n\nFJ 想知道，在开始移走石头之前，他能将最短距离增加多少。 请帮助农场主约翰确定在移走最优的 $M$ 组石块后，奶牛要跳过的最短距离。\n\n形式化中文题意：\n\n对于给定在一维位置的 $N$ 个点，选择 $M$ 个点进行移除，使得每两个点之间的距离最小值最大。", "inputFormat": "第 $1$ 行，三个空格分隔的整数：$L$、$N$ 和 $M$。\n\n\n第 $2\\dots N+1$ 行，每行包含一个整数，表示某块岩石距离起始岩石的距离。 没有两块石头的位置相同。", "outputFormat": "一个整数，即奶牛在移走 $M$ 块石头后所需跳跃的最短距离的最大值。", "hint": "在移除任何石块之前，最短的跳跃是从 $0$（起点）到 $2$ 的 $2$ 级跳；在移除 $2$ 和 $14$ 处的石块之后，所需的最短跳跃是 $4$ 级跳（从 $17$ 到 $21$ 或从 $21$ 到 $25$）。", "locale": "zh-CN"}}}
{"pid": "P2856", "type": "P", "difficulty": 4, "samples": [["3 13\n11\nALL\nBALL\nBELL\nCALK\nCALL\nCELL\nDILL\nFILL\nFILM\nILL\nMILK", "7\nAB\nCDEFGHIJK\nLM"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2006", "USACO"], "title": "[USACO06FEB] Cellphones G", "background": null, "description": "$D\\ (1 \\le D \\le 1000)$ 只奶牛的名字都是由英文字母表的前 $L\\ (1 \\le L \\le 26)$ 个大写字母构成的，且长度 $S$ 满足 $1 \\le S \\le 10$。现在想设计一种手机，有 $B\\ (1 \\le B \\le L)$ 个按键。请你把这 $L$ 个字母按顺序分配给 $B$ 个按键，使能够通过按这些键而唯一确定的奶牛数尽量多。", "inputFormat": "第一行两个正整数 $B,L$。\n\n第二行一个正整数 $D$。\n\n下面 $D$ 行，每行一个字符串，表示已知奶牛的名字。", "outputFormat": "第一行一个整数表示通过按这些键而唯一确定的最大奶牛数。\n\n下面 $B$ 行，构造一组方案：对于其中的第 $i$ 行，按字母表顺序依次输出所有属于第 $i$ 个按键的字母。", "hint": "样例解释：除了 `CELL/DILL/FILL/FILM` 的按键顺序都是 $2 - 2 - 3 - 3$ 外，剩下 $7$ 个名字都可以通过按这些键而唯一确定。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO06FEB] Cellphones G", "background": null, "description": "The cows have started using cellphones to cowmunicate with each other, but have found that the button layout doesn't suit their hooves very well. They are designing a special cellphone with fewer but larger buttons.\n\nOne feature they liked on the standard cellphones was predictive text. Each button has a few letters associated with it, and one types a word by pushing the associated buttons. Because there is more than one letter for each button, this can be ambiguous for some words. However, most of the time the ambiguity can be resolved by using a dictionary to determine what word the user wanted.\n\nSince the cows are designing a custom cellphone, they are also going to replace the English alphabet with the Cow alphabet. By an amazing coincidence, the cow alphabet is simply the first $L (1 \\le L \\le 26)$ letters of the English alphabet, in the same order. They want to find out how to assign the letters of the Cow alphabet to the $B$ buttons $(1 \\le B \\le L)$ in such a way that the maximum number of words in their dictionary are unambiguous when entered with predictive text. Like normal cellphones, they want the letters on each button to be a contiguous section (one or more consecutive letters) of the alphabet.", "inputFormat": "Line $1$: Two space-separated integers: $B$ and $L$.\n\nLine $2$: $D$, the number of words in the dictionary $(1 \\le D \\le 1000)$.\n\nLines $3 \\sim D+2$: Each line contains one word from the dictionary in upper case and of length $1 \\sim 10$ characters. The words are presented in alphabetical order and with no duplicates.", "outputFormat": "Line $1$: The number of words in the Cow dictionary that have unique button sequences.\n\nLines $2 \\sim B+1$: The nth line contains the letters that appear on button $n$, in upper case and alphabetical order. The lines must be listed in alphabetical order, and every Cow letter must appear exactly once. If there is more than one optimal solution, use the one that places the most letters on button $1$. Ties are broken by placing the most letters on button $2$, etc.", "hint": "Explanation of the sample:\n\nButton $1$ contains $\\text{AB}$, button two contains $\\text{C} \\sim \\text{K}$, and button $3$ contains $\\text{LM}$. The words $\\text{CELL},\\text{DILL},\\text{FILL}$ and $\\text{FILM}$ are all entered as $2-2-3-3$, while the remaining $7$ words are all entered uniquely.", "locale": "en"}, "zh-CN": {"title": "[USACO06FEB] Cellphones G", "background": null, "description": "$D\\ (1 \\le D \\le 1000)$ 只奶牛的名字都是由英文字母表的前 $L\\ (1 \\le L \\le 26)$ 个大写字母构成的，且长度 $S$ 满足 $1 \\le S \\le 10$。现在想设计一种手机，有 $B\\ (1 \\le B \\le L)$ 个按键。请你把这 $L$ 个字母按顺序分配给 $B$ 个按键，使能够通过按这些键而唯一确定的奶牛数尽量多。", "inputFormat": "第一行两个正整数 $B,L$。\n\n第二行一个正整数 $D$。\n\n下面 $D$ 行，每行一个字符串，表示已知奶牛的名字。", "outputFormat": "第一行一个整数表示通过按这些键而唯一确定的最大奶牛数。\n\n下面 $B$ 行，构造一组方案：对于其中的第 $i$ 行，按字母表顺序依次输出所有属于第 $i$ 个按键的字母。", "hint": "样例解释：除了 `CELL/DILL/FILL/FILM` 的按键顺序都是 $2 - 2 - 3 - 3$ 外，剩下 $7$ 个名字都可以通过按这些键而唯一确定。", "locale": "zh-CN"}}}
{"pid": "P2857", "type": "P", "difficulty": 6, "samples": [["6 4\n1 2 3 4\n2 3 1 4\n4 2 3 1\n3 1 2 4\n1 3 4 2\n1 4 2 3\n2 1 3 2", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2006", "二分", "USACO", "网络流", "枚举", "双指针 two-pointer"], "title": "[USACO06FEB] Steady Cow Assignment G", "background": "", "description": "Farmer John's N (1 <= N <= 1000) cows each reside in one of B (1 <= B <= 20) barns which, of course, have limited capacity. Some cows really like their current barn, and some are not so happy.\n\nFJ would like to rearrange the cows such that the cows are as equally happy as possible, even if that means all the cows hate their assigned barn.\n\n\nEach cow gives FJ the order in which she prefers the barns.  A cow's happiness with a particular assignment is her ranking of her barn. Your job is to find an assignment of cows to barns such that no barn's capacity is exceeded and the size of the range (i.e., one more than the positive difference between the the highest-ranked barn chosen and that lowest-ranked barn chosen) of barn rankings the cows give their assigned barns is as small as possible.\n", "inputFormat": "Line 1: Two space-separated integers, N and B\n\n\nLines 2..N+1: Each line contains B space-separated integers which are exactly 1..B sorted into some order. The first integer on line i+1 is the number of the cow i's top-choice barn, the second integer on that line is the number of the i'th cow's second-choice barn, and so on.\n\n\nLine N+2: B space-separated integers, respectively the capacity of the first barn, then the capacity of the second, and so on. The sum of these numbers is guaranteed to be at least N.\n", "outputFormat": "Line 1: One integer, the size of the minumum range of barn rankings the cows give their assigned barns, including the endpoints.\n", "hint": "Explanation of the sample:\n\n\n\n\nEach cow can be assigned to her first or second choice: barn 1 gets cows 1 and 5, barn 2 gets cow 2, barn 3 gets cow 4, and barn 4 gets cows 3 and 6.\n", "locale": "en", "translations": {"en": {"title": "[USACO06FEB] Steady Cow Assignment G", "background": "", "description": "Farmer John's N (1 <= N <= 1000) cows each reside in one of B (1 <= B <= 20) barns which, of course, have limited capacity. Some cows really like their current barn, and some are not so happy.\n\nFJ would like to rearrange the cows such that the cows are as equally happy as possible, even if that means all the cows hate their assigned barn.\n\n\nEach cow gives FJ the order in which she prefers the barns.  A cow's happiness with a particular assignment is her ranking of her barn. Your job is to find an assignment of cows to barns such that no barn's capacity is exceeded and the size of the range (i.e., one more than the positive difference between the the highest-ranked barn chosen and that lowest-ranked barn chosen) of barn rankings the cows give their assigned barns is as small as possible.\n", "inputFormat": "Line 1: Two space-separated integers, N and B\n\n\nLines 2..N+1: Each line contains B space-separated integers which are exactly 1..B sorted into some order. The first integer on line i+1 is the number of the cow i's top-choice barn, the second integer on that line is the number of the i'th cow's second-choice barn, and so on.\n\n\nLine N+2: B space-separated integers, respectively the capacity of the first barn, then the capacity of the second, and so on. The sum of these numbers is guaranteed to be at least N.\n", "outputFormat": "Line 1: One integer, the size of the minumum range of barn rankings the cows give their assigned barns, including the endpoints.\n", "hint": "Explanation of the sample:\n\n\n\n\nEach cow can be assigned to her first or second choice: barn 1 gets cows 1 and 5, barn 2 gets cow 2, barn 3 gets cow 4, and barn 4 gets cows 3 and 6.\n", "locale": "en"}, "zh-CN": {"title": "[USACO06FEB] Steady Cow Assignment G", "background": "", "description": "农夫约翰的 $N$ 头牛（$1 \\leq N \\leq 1000$）各自居住在 $B$ 个谷仓中的一个（$1 \\leq B \\leq 20$），当然，谷仓的容量是有限的。有些牛非常喜欢她们当前的谷仓，而有些则不太开心。\n\nFJ 想要重新安排这些牛，使得牛群的快乐程度尽可能均衡，即使这意味着所有的牛都讨厌她们被分配的谷仓。\n\n\n每头牛都会告诉 FJ 她对谷仓的偏好顺序。牛对特定分配的快乐程度是她对该谷仓的排名。你的任务是找到一种将牛分配到谷仓的方法，使得没有谷仓的容量被超出，并且牛给她们被分配的谷仓的排名范围（即最高排名谷仓和最低排名谷仓之间的正差加一）的大小尽可能小。\n", "inputFormat": "第 1 行：两个用空格分隔的整数，$N$ 和 $B$\n\n\n第 2 行到第 $N+1$ 行：每行包含 $B$ 个用空格分隔的整数，正好是 $1..B$ 的某种顺序排列。第 $i+1$ 行的第一个整数是第 $i$ 头牛最喜欢的谷仓的编号，第二个整数是第 $i$ 头牛次喜欢的谷仓的编号，依此类推。\n\n\n第 $N+2$ 行：$B$ 个用空格分隔的整数，分别是第一个谷仓的容量，第二个谷仓的容量，依此类推。这些数字的总和保证至少为 $N$。\n", "outputFormat": "第 1 行：一个整数，牛给她们被分配的谷仓的排名范围的最小值，包括端点。\n", "hint": "样例解释：\n\n\n\n\n每头牛可以被分配到她们的第一或第二选择：谷仓 1 得到牛 1 和 5，谷仓 2 得到牛 2，谷仓 3 得到牛 4，谷仓 4 得到牛 3 和 6。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2858", "type": "P", "difficulty": 3, "samples": [["5\n1\n3\n1\n5\n2", "43"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2006", "USACO", "区间 DP"], "title": "[USACO06FEB] Treats for the Cows G/S", "background": null, "description": "约翰经常给产奶量高的奶牛发特殊津贴，于是很快奶牛们拥有了大笔不知该怎么花的钱。为此，约翰购置了 $N$（$1 \\leq N \\leq 2000$） 份美味的零食来卖给奶牛们。每天约翰售出一份零食。当然约翰希望这些零食全部售出后能得到最大的收益，这些零食有以下这些有趣的特性：\n+ 零食按照 $1, \\ldots, N$ 编号，它们被排成一列放在一个很长的盒子里。盒子的两端都有开口，约翰每天可以从盒子的任一端取出最外面的一个。\n+ 与美酒与好吃的奶酪相似，这些零食储存得越久就越好吃。当然，这样约翰就可以把它们卖出更高的价钱。\n+ 每份零食的初始价值不一定相同。约翰进货时，第 $i$ 份零食的初始价值为 $V_i$（$1 \\leq V \\leq 1000$）。\n+ 第 $i$ 份零食如果在被买进后的第 $a$ 天出售，则它的售价是 $V_i \\times a$。\n\n$V_i$ 的是从盒子顶端往下的第 $i$ 份零食的初始价值。约翰告诉了你所有零食的初始价值，并希望你能帮他计算一下，在这些零食全被卖出后，他最多能得到多少钱。", "inputFormat": "第一行一个正整数 $N$。\n\n接下来 $2 \\sim N+1$ 行，第 $i+1$ 行为一个正整数 $V_i$。", "outputFormat": "一行一个整数表示答案。", "hint": "样例的最优解是：按 $1 \\to 5 \\to 2 \\to 3 \\to 4$ 的顺序卖零食，得到的钱数是 $1 \\times 1 + 2 \\times 2 + 3 \\times 3 + 4 \\times 1 + 5 \\times 5 = 43$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO06FEB] Treats for the Cows G/S", "background": null, "description": "FJ has purchased $N (1 \\le N \\le 2000)$ yummy treats for the cows who get money for giving vast amounts of milk. FJ sells one treat per day and wants to maximize the money he receives over a given period time.\n\nThe treats are interesting for many reasons:The treats are numbered $1 \\sim N$ and stored sequentially in single file in a long box that is open at both ends. On any day, FJ can retrieve one treat from either end of his stash of treats.Like fine wines and delicious cheeses, the treats improve with age and command greater prices.The treats are not uniform: some are better and have higher intrinsic value. Treat $i$ has value $v_i (1 \\le v_i \\le 1000)$. Cows pay more for treats that have aged longer: a cow will pay $v_i \\times a$ for a treat of age $a$. Given the values $v_i$ of each of the treats lined up in order of the index $i$ in their box, what is the greatest value FJ can receive for them if he orders their sale optimally?\n\nThe first treat is sold on day $1$ and has age $a=1$. Each subsequent day increases the age by $1$.", "inputFormat": "Line $1$: A single integer, $N$.\n\nLines $2 \\sim N+1$: Line $i+1$ contains the value of treat $v_i$.", "outputFormat": "Line $1$: The maximum revenue FJ can achieve by selling the treats.", "hint": "Explanation of the sample:\n\nFive treats. On the first day FJ can sell either treat $\\#1$ (value $1$) or treat $\\#5$ (value $2$).\n\nFJ sells the treats (values $1, 3, 1, 5, 2$) in the following order of indices: $1, 5, 2, 3, 4$, making $1 \\times 1 + 2 \\times 2 + 3 \\times 3 + 4 \\times 1 + 5 \\times 5 = 43$.", "locale": "en"}, "zh-CN": {"title": "[USACO06FEB] Treats for the Cows G/S", "background": null, "description": "约翰经常给产奶量高的奶牛发特殊津贴，于是很快奶牛们拥有了大笔不知该怎么花的钱。为此，约翰购置了 $N$（$1 \\leq N \\leq 2000$） 份美味的零食来卖给奶牛们。每天约翰售出一份零食。当然约翰希望这些零食全部售出后能得到最大的收益，这些零食有以下这些有趣的特性：\n+ 零食按照 $1, \\ldots, N$ 编号，它们被排成一列放在一个很长的盒子里。盒子的两端都有开口，约翰每天可以从盒子的任一端取出最外面的一个。\n+ 与美酒与好吃的奶酪相似，这些零食储存得越久就越好吃。当然，这样约翰就可以把它们卖出更高的价钱。\n+ 每份零食的初始价值不一定相同。约翰进货时，第 $i$ 份零食的初始价值为 $V_i$（$1 \\leq V \\leq 1000$）。\n+ 第 $i$ 份零食如果在被买进后的第 $a$ 天出售，则它的售价是 $V_i \\times a$。\n\n$V_i$ 的是从盒子顶端往下的第 $i$ 份零食的初始价值。约翰告诉了你所有零食的初始价值，并希望你能帮他计算一下，在这些零食全被卖出后，他最多能得到多少钱。", "inputFormat": "第一行一个正整数 $N$。\n\n接下来 $2 \\sim N+1$ 行，第 $i+1$ 行为一个正整数 $V_i$。", "outputFormat": "一行一个整数表示答案。", "hint": "样例的最优解是：按 $1 \\to 5 \\to 2 \\to 3 \\to 4$ 的顺序卖零食，得到的钱数是 $1 \\times 1 + 2 \\times 2 + 3 \\times 3 + 4 \\times 1 + 5 \\times 5 = 43$。", "locale": "zh-CN"}}}
{"pid": "P2859", "type": "P", "difficulty": 4, "samples": [["5\n1 10\n2 4\n3 6\n5 8\n4 7", "4\n1\n2\n3\n2\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2006", "线段树", "USACO", "Special Judge", "前缀和"], "title": "[USACO06FEB] Stall Reservations S", "background": "", "description": "Oh those picky $N$ ($1 \\leq N \\leq 50,000$) cows! They are so picky that each one will only be milked over some precise time interval $[A,B]$ ($1 \\leq A \\leq B \\leq 1,000,000$), which includes both times $A$ and $B$. Obviously, FJ must create a reservation system to determine which stall each cow can be assigned for her milking time. Of course, no cow will share such a private moment with other cows.\n\nHelp FJ by determining: The minimum number of stalls required in the barn so that each cow can have her private milking period. An assignment of cows to these stalls over time. Many answers are correct for each test dataset; a program will grade your answer.", "inputFormat": "Line $1$: A single integer, $N$.\n\nLines $2 \\sim N+1$: Line $i+1$ describes cow $i$'s milking interval with two space-separated integers.", "outputFormat": "Line $1$: The minimum number of stalls the barn must have.\n\nLines $2 \\sim N+1$: Line $i+1$ describes the stall to which cow i will be assigned for her milking period.", "hint": "**Explanation of the sample:**\n\nHere's a graphical schedule for this output:\n\n```plain\nTime     1  2  3  4  5  6  7  8  9 10\n\n\nStall 1 c1>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n\nStall 2 .. c2>>>>>> c4>>>>>>>>> .. ..\n\n\nStall 3 .. .. c3>>>>>>>>> .. .. .. ..\n\n\nStall 4 .. .. .. c5>>>>>>>>> .. .. ..\n```\n\nOther outputs using the same number of stalls are possible.", "locale": "en", "translations": {"en": {"title": "[USACO06FEB] Stall Reservations S", "background": "", "description": "Oh those picky $N$ ($1 \\leq N \\leq 50,000$) cows! They are so picky that each one will only be milked over some precise time interval $[A,B]$ ($1 \\leq A \\leq B \\leq 1,000,000$), which includes both times $A$ and $B$. Obviously, FJ must create a reservation system to determine which stall each cow can be assigned for her milking time. Of course, no cow will share such a private moment with other cows.\n\nHelp FJ by determining: The minimum number of stalls required in the barn so that each cow can have her private milking period. An assignment of cows to these stalls over time. Many answers are correct for each test dataset; a program will grade your answer.", "inputFormat": "Line $1$: A single integer, $N$.\n\nLines $2 \\sim N+1$: Line $i+1$ describes cow $i$'s milking interval with two space-separated integers.", "outputFormat": "Line $1$: The minimum number of stalls the barn must have.\n\nLines $2 \\sim N+1$: Line $i+1$ describes the stall to which cow i will be assigned for her milking period.", "hint": "**Explanation of the sample:**\n\nHere's a graphical schedule for this output:\n\n```plain\nTime     1  2  3  4  5  6  7  8  9 10\n\n\nStall 1 c1>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n\nStall 2 .. c2>>>>>> c4>>>>>>>>> .. ..\n\n\nStall 3 .. .. c3>>>>>>>>> .. .. .. ..\n\n\nStall 4 .. .. .. c5>>>>>>>>> .. .. ..\n```\n\nOther outputs using the same number of stalls are possible.", "locale": "en"}, "zh-CN": {"title": "[USACO06FEB] Stall Reservations S", "background": "", "description": "约翰的 $N$（$1\\leq N\\leq 50000$）头奶牛实在是太难伺候了，她们甚至有自己独特的产奶时段。对于某一头奶牛，她每天的产奶时段是固定的时间段 $[A,B]$（即 $A$ 到 $B$，包括 $A$ 和 $B$）($1 \\leq A \\leq B \\leq 10^6$)。这使得约翰必须开发一个调控系统来决定每头奶牛应该被安排到哪个牛棚去挤奶，因为奶牛们并不希望在挤奶时被其它奶牛看见。\n\n请帮约翰计算：如果要满足奶牛们的要求，并且每天每头奶牛都要被挤过奶，至少需要多少牛棚和每头牛应该在哪个牛棚被挤奶。如果有多种答案，输出任意一种均可。", "inputFormat": "第 $1$ 行，一个整数 $N$。\n\n第 $2\\sim (N+1)$ 行，每行两个数字，第 $(i+1)$ 行的数字代表第 $i$ 头奶牛的产奶时段。", "outputFormat": "第 $1$ 行输出一个整数，代表需要牛棚的最少数量。\n\n第 $2\\sim (N+1)$ 行，每行一个数字，第 $(i+1)$ 行的数字代表第 $i$ 头奶牛将会被安排到哪个牛棚挤奶。", "hint": "由 @FlierKing 提供 SPJ。", "locale": "zh-CN"}}}
{"pid": "P2860", "type": "P", "difficulty": 5, "samples": [["7 7\n1 2\n2 3\n3 4\n2 5\n4 5\n5 6\n5 7", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2006", "USACO", "Tarjan", "双连通分量"], "title": "[USACO06JAN] Redundant Paths G", "background": null, "description": "In order to get from one of the $F$ ($1 \\le F \\le 5\\times 10^3$) grazing fields (which are numbered $1$ to $F$) to another field, Bessie and the rest of the herd are forced to cross near the Tree of Rotten Apples.  The cows are now tired of often being forced to take a particular path and want to build some new paths so that they will always have a choice of at least two separate routes between any pair of fields. They currently have at least one route between each pair of fields and want to have at least two. Of course, they can only travel on Official Paths when they move from one field to another.\n\n\nGiven a description of the current set of $R$ ($F-1 \\le R \\le 1\\times 10^4$) paths that each connect exactly two different fields, determine the minimum number of new paths (each of which connects exactly two fields) that must be built so that there are at least two separate routes between any pair of fields. Routes are considered separate if they use none of the same paths, even if they visit the same intermediate field along the way.\n\n\nThere might already be more than one paths between the same pair of fields, and you may also build a new path that connects the same fields as some other path.", "inputFormat": "Line $1$: Two space-separated integers: $F$ and $R$.\n\n\n\n\nLines $2$ to $R+1$: Each line contains two space-separated integers which are the fields at the endpoints of some path.", "outputFormat": "Line $1$: A single integer that is the number of new paths that must be built.", "hint": "Explanation of the sample:\n\n\n\n\nOne visualization of the paths is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cubnel5k.png)\n\nBuilding new paths from $1$ to $6$ and from $4$ to $7$ satisfies the conditions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rgguiytp.png)\n\nCheck some of the routes:\n\n- $1$ – $2$:  $1 \\to 2$ and $1 \\to 6 \\to 5 \\to 2$.\n- $1$ – $4$:  $1 \\to 2 \\to 3 \\to 4$ and $1 \\to 6 \\to 5 \\to 4$.\n- $3$ – $7$:  $3 \\to 4 \\to 7$ and $3 \\to 2 \\to 5 \\to 7$.\n\nEvery pair of fields is, in fact, connected by two routes.\n\nIt's possible that adding some other path will also solve the problem (like one from $6$ to $7$). Adding two paths, however, is the minimum.", "locale": "en", "translations": {"en": {"title": "[USACO06JAN] Redundant Paths G", "background": null, "description": "In order to get from one of the $F$ ($1 \\le F \\le 5\\times 10^3$) grazing fields (which are numbered $1$ to $F$) to another field, Bessie and the rest of the herd are forced to cross near the Tree of Rotten Apples.  The cows are now tired of often being forced to take a particular path and want to build some new paths so that they will always have a choice of at least two separate routes between any pair of fields. They currently have at least one route between each pair of fields and want to have at least two. Of course, they can only travel on Official Paths when they move from one field to another.\n\n\nGiven a description of the current set of $R$ ($F-1 \\le R \\le 1\\times 10^4$) paths that each connect exactly two different fields, determine the minimum number of new paths (each of which connects exactly two fields) that must be built so that there are at least two separate routes between any pair of fields. Routes are considered separate if they use none of the same paths, even if they visit the same intermediate field along the way.\n\n\nThere might already be more than one paths between the same pair of fields, and you may also build a new path that connects the same fields as some other path.", "inputFormat": "Line $1$: Two space-separated integers: $F$ and $R$.\n\n\n\n\nLines $2$ to $R+1$: Each line contains two space-separated integers which are the fields at the endpoints of some path.", "outputFormat": "Line $1$: A single integer that is the number of new paths that must be built.", "hint": "Explanation of the sample:\n\n\n\n\nOne visualization of the paths is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cubnel5k.png)\n\nBuilding new paths from $1$ to $6$ and from $4$ to $7$ satisfies the conditions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rgguiytp.png)\n\nCheck some of the routes:\n\n- $1$ – $2$:  $1 \\to 2$ and $1 \\to 6 \\to 5 \\to 2$.\n- $1$ – $4$:  $1 \\to 2 \\to 3 \\to 4$ and $1 \\to 6 \\to 5 \\to 4$.\n- $3$ – $7$:  $3 \\to 4 \\to 7$ and $3 \\to 2 \\to 5 \\to 7$.\n\nEvery pair of fields is, in fact, connected by two routes.\n\nIt's possible that adding some other path will also solve the problem (like one from $6$ to $7$). Adding two paths, however, is the minimum.", "locale": "en"}, "zh-CN": {"title": "[USACO06JAN] Redundant Paths G", "background": null, "description": "为了从 $F(1\\le F\\le 5,000)$ 个牧场（编号为 $1$ 到 $F$）中的一个到达另一个牧场，贝西和其他牛群被迫经过腐烂苹果树附近。奶牛们厌倦了经常被迫走特定的路径，想要修建一些新路径，以便在任意一对牧场之间总是有至少两条独立的路线可供选择。目前在每对牧场之间至少有一条路径，他们希望至少有两条。当然，他们只能在官方路径上从一个牧场移动到另一个牧场。\n\n给定当前 $R(F-1\\le R\\le 10,000)$ 条路径的描述，每条路径恰好连接两个不同的牧场，确定必须修建的最少新路径数量（每条新路径也恰好连接两个牧场），以便在任意一对牧场之间至少有两条独立的路线。若两条路线不使用相同的路径，即使它们沿途访问相同的中间牧场，也被视为独立的。\n\n在同一对牧场之间可能已经有多条路径，你也可以修建一条新路径连接与某条现有路径相同的牧场。", "inputFormat": "第 $1$ 行：两个用空格分隔的整数：$F$ 和 $R$。\n\n第 $2$ 行到第 $R+1$ 行：每行包含两个用空格分隔的整数，表示某条路径的两个端点牧场。", "outputFormat": "第 $1$ 行：一个整数，表示必须修建的新路径数量。", "hint": "样例解释：\n\n路径的一个可视化图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cubnel5k.png)\n\n从 $1$ 到 $6$ 和从 $4$ 到 $7$ 修建新路径满足条件。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rgguiytp.png)\n\n检查一些路线：\n\n- $1 \\to 2$：$1 \\to2$ 和 $1 \\to6 \\to5 \\to2$\n- $1 \\to 4$：$1 \\to2 \\to3 \\to4$ 和 $1 \\to6 \\to5 \\to4$\n- $3 \\to 7$：$3 \\to4 \\to7$ 和 $3 \\to2 \\to5 \\to7$\n\n事实上，每对牧场之间都由两条路线连接。\n\n添加其他路径也可能解决问题（例如从 $6$ 到 $7$ 的路径）。然而，添加两条路径是最少的。\n\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2861", "type": "P", "difficulty": 5, "samples": [["5 3 1\n6 10\n10 7\n9 1\n2 0\n0 3\n2 2\n5 6\n8 3", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "USACO"], "title": "[USACO06JAN] Roping the Field G", "background": null, "description": "约翰真是一个自然派艺术大师，他常常在他的田地上创作一些巨大的艺术杰作。今天，他想在麦田上创作一幅由绳索构成的巨画。他的麦田是一个多边形，由 $N\\ (1 \\le N \\le 150)$ 个篱笆粧和之间的篱笆围成。为了创作他的巨画，他打算用尽量多的数量的绳索，笔直地连接两个不相邻的篱笆粧。但是为了画作的优美，任意两根绳索不得交叉。\n\n约翰有一个难处：一些邪恶的外星人在他的麦田上整出了 $G\\ (0 \\le G \\le 100)$ 个怪圈。这些怪圈都有一定的半径 $R\\ (1\\le R\\le 100000)$。他不敢惹外星人，所以不想有任何绳索通过这些怪圈，即使碰到怪圈的边际也不行。这些怪圈的圆心都在麦田之内，但一些怪圈可能有部分在麦田之外。一些篱笆或者篱笆粧都有可能在某一个怪圈里。\n\n给出篱笆粧和怪圈的坐标，计算最多的绳索数。所有的坐标都是 $[0,10^6]$ 内的整数。", "inputFormat": "第 $1$ 行输入三个整数 $N,G,R$。\n\n接下来 $N$ 行，每行输入两个整数表示篱笆粧的坐标。\n\n接下来 $G$ 行，每行输入两个整数表示一个怪圈的圆心坐标。", "outputFormat": "一行一个正整数表示答案。", "hint": "样例解释：唯一一条绳索连接了 $(10,7)$ 和 $(2,0)$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO06JAN] Roping the Field G", "background": null, "description": "Farmer John is quite the nature artist: he often constructs large works of art on his farm. Today, FJ wants to construct a giant \"field web\". FJ's field is large convex polygon with fences along the boundary and fence posts at each of the $N$ corners $(1 \\le N \\le 150)$. To construct his field web, FJ wants to run as many ropes as possible in straight lines between pairs of non-adjacent fence posts such that no two ropes cross.\n\nThere is one complication: FJ's field is not completely usable. Some evil aliens have created a total of $G (0 \\le G \\le 100)$ grain circles in the field, all of radius $R (1 \\le R \\le 100,000)$. FJ is afraid to upset the aliens, and therefore doesn't want the ropes to pass through, or even touch the very edge of a grain circle. Note that although the centers of all the circles are contained within the field, a wide radius may make it extend outside of the field, and both fences and fence posts may be within a grain circle.\n\nGiven the locations of the fence posts and the centers of the circles, determine the maximum number of ropes that FJ can use to create his field web.\n\nFJ's fence pots and the circle centers all have integer coordinates $X$ and $Y$ each of which is in the range $[0,1,000,000]$.", "inputFormat": "Line $1$: Three space-separated integers: $N$, $G$, and $R$.\n\nLines $2 \\sim N+1$: Each line contains two space-separated integers that are the $X,Y$ position of a fence post on the boundary of FJ's field.\n\nLines $N+2 \\sim N+G+1$: Each line contains two space-separated integers that are the $X,Y$ position of a circle's center inside FJ's field.", "outputFormat": "Line $1$: A single integer that is the largest number of ropes FJ can use for his artistic creation.", "hint": "Explanation of the sample:\n\nA pentagonal field, in which all possible ropes are blocked by three grain circles, except for the rope between fenceposts $2$ and $4$.", "locale": "en"}, "zh-CN": {"title": "[USACO06JAN] Roping the Field G", "background": null, "description": "约翰真是一个自然派艺术大师，他常常在他的田地上创作一些巨大的艺术杰作。今天，他想在麦田上创作一幅由绳索构成的巨画。他的麦田是一个多边形，由 $N\\ (1 \\le N \\le 150)$ 个篱笆粧和之间的篱笆围成。为了创作他的巨画，他打算用尽量多的数量的绳索，笔直地连接两个不相邻的篱笆粧。但是为了画作的优美，任意两根绳索不得交叉。\n\n约翰有一个难处：一些邪恶的外星人在他的麦田上整出了 $G\\ (0 \\le G \\le 100)$ 个怪圈。这些怪圈都有一定的半径 $R\\ (1\\le R\\le 100000)$。他不敢惹外星人，所以不想有任何绳索通过这些怪圈，即使碰到怪圈的边际也不行。这些怪圈的圆心都在麦田之内，但一些怪圈可能有部分在麦田之外。一些篱笆或者篱笆粧都有可能在某一个怪圈里。\n\n给出篱笆粧和怪圈的坐标，计算最多的绳索数。所有的坐标都是 $[0,10^6]$ 内的整数。", "inputFormat": "第 $1$ 行输入三个整数 $N,G,R$。\n\n接下来 $N$ 行，每行输入两个整数表示篱笆粧的坐标。\n\n接下来 $G$ 行，每行输入两个整数表示一个怪圈的圆心坐标。", "outputFormat": "一行一个正整数表示答案。", "hint": "样例解释：唯一一条绳索连接了 $(10,7)$ 和 $(2,0)$。", "locale": "zh-CN"}}}
{"pid": "P2862", "type": "P", "difficulty": 4, "samples": [["3 4\n1 2\n2 1\n4 1\n5 2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "线段树", "二分", "USACO"], "title": "[USACO06JAN] Corral the Cows G", "background": null, "description": "Farmer John 希望为他的奶牛们建立一个畜栏。\n\n这些挑剔的奶牛要求畜栏必须是正方形的，而且至少要包含 $C$ 片三叶草，来当做它们的下午茶。\n\n约翰的土地里一共包含 $N$ 片三叶草，每单位三叶草位于一个 $1\\times 1$ 的土地区域内。坐标都为整数，范围在 $1$ 到 $10000$ 以内。\n\n**多片的三叶草可能会位于同一个 $1\\times 1$ 的区域内，所以在输入内，同一个区域坐标可能出现多次。**\n\n请你帮 Farmer John 计算一下，在能包含至少 $C$ 片三叶草的情况下，畜栏的最小边长是多少。\n\n$1\\le C\\le N\\le 500$。", "inputFormat": "第一行两个正整数 $C,N$。\n\n下面 $N$ 行，每行两个整数 $X,Y$，表示某一单位三叶草的位置 $(X,Y)$。", "outputFormat": "一行一个整数表示答案。", "hint": "样例的一个最优解是，将正方形的左下角设为 $(1,1)$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO06JAN] Corral the Cows G", "background": null, "description": "Farmer John wishes to build a corral for his cows. Being finicky beasts, they demand that the corral be square and that the corral contain at least $C (1 \\le C \\le 500)$ clover fields for afternoon treats. The corral's edges must be parallel to the $X,Y$ axes.\n\nFJ's land contains a total of $N (C \\le N \\le 500)$ clover fields, each a block of size $1 \\times 1$ and located at with its lower left corner at integer $X$ and $Y$ coordinates each in the range $1 \\sim 10,000$. Sometimes more than one clover field grows at the same location; such a field would have its location appear twice (or more) in the input. A corral surrounds a clover field if the field is entirely located inside the corral's borders.\n\nHelp FJ by telling him the side length of the smallest square containing $C$ clover fields.", "inputFormat": "Line $1$: Two space-separated integers: $C$ and $N$.\n\nLines $2 \\sim N+1$: Each line contains two space-separated integers that are the $X,Y$ coordinates of a clover field.", "outputFormat": "Line $1$: A single line with a single integer that is length of one edge of the minimum size square that contains at least $C$ clover fields.", "hint": "Explanation of the sample:\n\n```plain\n|*   *\n| * *\n+------\n```\n\nBelow is one $4 \\times 4$ solution (`C`'s show most of the corral's area); many others exist.\n\n```plain\n|CCCC\n|CCCC\n|*CCC*\n|C*C*\n+------\n```", "locale": "en"}, "zh-CN": {"title": "[USACO06JAN] Corral the Cows G", "background": null, "description": "Farmer John 希望为他的奶牛们建立一个畜栏。\n\n这些挑剔的奶牛要求畜栏必须是正方形的，而且至少要包含 $C$ 片三叶草，来当做它们的下午茶。\n\n约翰的土地里一共包含 $N$ 片三叶草，每单位三叶草位于一个 $1\\times 1$ 的土地区域内。坐标都为整数，范围在 $1$ 到 $10000$ 以内。\n\n**多片的三叶草可能会位于同一个 $1\\times 1$ 的区域内，所以在输入内，同一个区域坐标可能出现多次。**\n\n请你帮 Farmer John 计算一下，在能包含至少 $C$ 片三叶草的情况下，畜栏的最小边长是多少。\n\n$1\\le C\\le N\\le 500$。", "inputFormat": "第一行两个正整数 $C,N$。\n\n下面 $N$ 行，每行两个整数 $X,Y$，表示某一单位三叶草的位置 $(X,Y)$。", "outputFormat": "一行一个整数表示答案。", "hint": "样例的一个最优解是，将正方形的左下角设为 $(1,1)$。", "locale": "zh-CN"}}}
{"pid": "P2863", "type": "P", "difficulty": 4, "samples": [["5 4\n2 4\n3 5\n1 2\n4 1", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2006", "USACO", "强连通分量", "Tarjan"], "title": "[USACO06JAN] The Cow Prom S", "background": "", "description": "有一个 $n$ 个点，$m$ 条边的有向图，请求出这个图点数大于 $1$ 的强连通分量个数。", "inputFormat": "第一行为两个整数 $n$ 和 $m$。\n\n第二行至 $m+1$ 行，每一行有两个整数 $a$ 和 $b$，表示有一条从 $a$ 到 $b$ 的有向边。", "outputFormat": "仅一行，表示点数大于 $1$ 的强连通分量个数。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $2\\le n \\le 10^4$，$2\\le m\\le 5\\times 10^4$，$1 \\leq a, b \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO06JAN] The Cow Prom S", "background": "", "description": "Given a directed graph with $n$ vertices and $m$ edges, find the number of strongly connected components that contain more than 1 vertex.", "inputFormat": "The first line contains two integers $n$ and $m$.\n\nLines 2 through $m+1$, each line contains two integers $a$ and $b$, indicating a directed edge from $a$ to $b$.", "outputFormat": "Output a single line containing the number of strongly connected components with more than 1 vertex.", "hint": "Constraints\n\nFor all test points, it is guaranteed that $2 \\le n \\le 10^4$, $2 \\le m \\le 5 \\times 10^4$, $1 \\le a, b \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO06JAN] The Cow Prom S", "background": "", "description": "有一个 $n$ 个点，$m$ 条边的有向图，请求出这个图点数大于 $1$ 的强连通分量个数。", "inputFormat": "第一行为两个整数 $n$ 和 $m$。\n\n第二行至 $m+1$ 行，每一行有两个整数 $a$ 和 $b$，表示有一条从 $a$ 到 $b$ 的有向边。", "outputFormat": "仅一行，表示点数大于 $1$ 的强连通分量个数。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $2\\le n \\le 10^4$，$2\\le m\\le 5\\times 10^4$，$1 \\leq a, b \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P2864", "type": "P", "difficulty": 5, "samples": [["6 7\n.......\n...X...\n..XXX..\n...XXX.\n...X...\n...*...", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "USACO", "广度优先搜索 BFS"], "title": "[USACO06JAN] The Grove S", "background": null, "description": "牧场里有树林，林子里没有坑，贝茜很想知道，最少几步能绕树林走一圈，最后回到起点.她能上下左右走，也能走对角线格子.\n\n牧场被分成 $R$ 行 $C$ 列 $(1\\leq R\\leq 50,1\\leq C\\leq 50)$。下面是一张样例的地图，其中 `.` 表示贝茜可以走的空地，`X` 表示树林，`*` 表示起点。而贝茜走的最近的路已经特别地用 `+` 表示出来：\n\n```plain\n...+...\n..+X+..\n.+XXX+.\n..+XXX+\n..+X..+\n...+++*\n```\n\n题目**保证存在最短路径**，且森林形成一个联通块。", "inputFormat": "第一行两个正整数 $R,C$。\n\n下面 $R$ 行，一个 $R \\times C$ 的字符矩阵。", "outputFormat": "一行一个整数表示答案。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[USACO06JAN] The Grove S", "background": null, "description": "The pasture contains a small, contiguous grove of trees that has no 'holes' in the middle of the it.  Bessie wonders: how far is it to walk around that grove and get back to my starting position? She's just sure there is a way to do it by going from her start location to successive locations by walking horizontally, vertically, or diagonally and counting each move as a single step. Just looking at it, she doesn't think you could pass 'through' the grove on a tricky diagonal. Your job is to calculate the minimum number of steps she must take.\n\n\nHappily, Bessie lives on a simple world where the pasture is represented by a grid with $R$ rows and $C$ columns $(1 \\le R \\le 50, 1 \\le C \\le 50)$. Here's a typical example where `.` is pasture (which Bessie may traverse), `X` is the grove of trees, `*` represents Bessie's start and end position, and `+` marks one shortest path she can walk to circumnavigate the grove (i.e., the answer):\n\n```plain\n...+...\n..+X+..\n.+XXX+.\n..+XXX+\n..+X..+\n...+++*\n```\nThe path shown is not the only possible shortest path; Bessie might have taken a diagonal step from her start position and achieved a similar length solution. Bessie is happy that she's starting 'outside' the grove instead of in a sort of 'harbor' that could complicate finding the best path.", "inputFormat": "Line $1$: Two space-separated integers: $R$ and $C$.\n\nLines $2 \\sim R+1$: Line $i+1$ describes row $i$ with $C$ characters (with no spaces between them).", "outputFormat": "Line $1$: The single line contains a single integer which is the smallest number of steps required to circumnavigate the grove.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO06JAN] The Grove S", "background": null, "description": "牧场里有树林，林子里没有坑，贝茜很想知道，最少几步能绕树林走一圈，最后回到起点.她能上下左右走，也能走对角线格子.\n\n牧场被分成 $R$ 行 $C$ 列 $(1\\leq R\\leq 50,1\\leq C\\leq 50)$。下面是一张样例的地图，其中 `.` 表示贝茜可以走的空地，`X` 表示树林，`*` 表示起点。而贝茜走的最近的路已经特别地用 `+` 表示出来：\n\n```plain\n...+...\n..+X+..\n.+XXX+.\n..+XXX+\n..+X..+\n...+++*\n```\n\n题目**保证存在最短路径**，且森林形成一个联通块。", "inputFormat": "第一行两个正整数 $R,C$。\n\n下面 $R$ 行，一个 $R \\times C$ 的字符矩阵。", "outputFormat": "一行一个整数表示答案。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2865", "type": "P", "difficulty": 5, "samples": [["4 4\n1 2 100\n2 4 200\n2 3 250\n3 4 100", "450"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2006", "USACO", "最短路"], "title": "[USACO06NOV] Roadblocks G", "background": "", "description": "Bessie has moved to a small farm and sometimes enjoys returning to visit one of her best friends. She does not want to get to her old home too quickly, because she likes the scenery along the way. She has decided to take the second-shortest rather than the shortest path. She knows there must be some second-shortest path.\n\nThe countryside consists of R (1 ≤ R ≤ 100,000) bidirectional roads, each linking two of the N (1 ≤ N ≤ 5000) intersections, conveniently numbered 1..N. Bessie starts at intersection 1, and her friend (the destination) is at intersection N.\n\nThe second-shortest path may share roads with any of the shortest paths, and it may backtrack i.e., use the same road or intersection more than once. The second-shortest path is the shortest path whose length is longer than the shortest path(s) (i.e., if two or more shortest paths exist, the second-shortest path is the one whose length is longer than those but no longer than any other path).\n", "inputFormat": "Line 1: Two space-separated integers: N and R\n\n\nLines 2..R+1: Each line contains three space-separated integers: A, B, and D that describe a road that connects intersections A and B and has length D (1 ≤ D ≤ 5000)\n", "outputFormat": "Line 1: The length of the second shortest path between node 1 and node N\n", "hint": "Two routes: 1 -> 2 -> 4 (length 100+200=300) and 1 -> 2 -> 3 -> 4 (length 100+250+100=450)\n", "locale": "en", "translations": {"en": {"title": "[USACO06NOV] Roadblocks G", "background": "", "description": "Bessie has moved to a small farm and sometimes enjoys returning to visit one of her best friends. She does not want to get to her old home too quickly, because she likes the scenery along the way. She has decided to take the second-shortest rather than the shortest path. She knows there must be some second-shortest path.\n\nThe countryside consists of R (1 ≤ R ≤ 100,000) bidirectional roads, each linking two of the N (1 ≤ N ≤ 5000) intersections, conveniently numbered 1..N. Bessie starts at intersection 1, and her friend (the destination) is at intersection N.\n\nThe second-shortest path may share roads with any of the shortest paths, and it may backtrack i.e., use the same road or intersection more than once. The second-shortest path is the shortest path whose length is longer than the shortest path(s) (i.e., if two or more shortest paths exist, the second-shortest path is the one whose length is longer than those but no longer than any other path).\n", "inputFormat": "Line 1: Two space-separated integers: N and R\n\n\nLines 2..R+1: Each line contains three space-separated integers: A, B, and D that describe a road that connects intersections A and B and has length D (1 ≤ D ≤ 5000)\n", "outputFormat": "Line 1: The length of the second shortest path between node 1 and node N\n", "hint": "Two routes: 1 -> 2 -> 4 (length 100+200=300) and 1 -> 2 -> 3 -> 4 (length 100+250+100=450)\n", "locale": "en"}, "zh-CN": {"title": "[USACO06NOV] Roadblocks G", "background": null, "description": "Bessie 搬到了一个小农场，有时喜欢回去拜访她的一个好朋友。她不想太快到达她的旧家，因为她喜欢沿途的风景。她决定选择第二短的路径而不是最短的路径。她知道一定存在某条第二短路径。\n\n乡村由 $R(1\\le R\\le100,000)$ 条双向道路组成，每条道路连接 $N(1\\le N\\le5000)$ 个交叉路口中的两个，这些交叉路口被方便地编号为 $1$ 到 $N$。Bessie 从交叉路口 $1$ 出发，她的朋友（目的地）在交叉路口 $N$。\n\n第二短路径可以与任何最短路径共享道路，并且可以回溯，即多次使用相同的道路或交叉路口。第二短路径是长度比最短路径长的最短路径（即，如果存在两条或多条最短路径，第二短路径是长度比这些路径长但不比任何其他路径长的路径）。", "inputFormat": "第 $1$ 行：两个用空格分隔的整数：$N$ 和 $R$。\n\n\n第 $2$ 行到第 $R+1$ 行：每行包含三个用空格分隔的整数：$A$、$B$ 和 $D$，描述连接交叉路口 $A$ 和 $B$ 的一条长度为 $D(1\\le D\\le5000)$ 的道路。", "outputFormat": "第 $1$ 行：节点 $1$ 和节点 $N$ 之间第二短路径的长度。", "hint": "两条路径：$1\\to2\\to4$（长度 $100+200=300$）和 $1\\to2\\to3\\to4$（长度 $100+250+100=450$）。\n\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2866", "type": "P", "difficulty": 3, "samples": [["6\n10\n3\n7\n4\n12\n2", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "USACO", "栈", "ST 表", "单调栈"], "title": "[USACO06NOV] Bad Hair Day S", "background": "", "description": "\n农夫约翰有 $N$ 头奶牛正在过乱头发节。\n\n每一头牛都站在同一排面朝右，它们被从左到右依次编号为 $1, 2, \\cdots, N$。编号为 $i$ 的牛身高为 $h_i$。第 $N$ 头牛在最前面，而第 $1$ 头牛在最后面。\n\n对于第 $i$ 头牛**前面**的第 $j$ 头牛，如果 $h_i>h_{i+1}, h_i>h_{i+2}, \\cdots, h_i>h_j$，那么认为第 $i$ 头牛可以看到第 $i+1$ 到第 $j$ 头牛。\n\n定义 $C_i$ 为第 $i$ 头牛所能看到的牛的数量。请帮助农夫约翰求出 $C _ 1 + C _ 2 + \\cdots + C _ N$。\n", "inputFormat": "输入共 $N + 1$ 行。\n\n第一行为一个整数 $N$，代表牛的个数。  \n接下来 $N$ 行，每行一个整数 $a _ i$，分别代表第 $1, 2, \\cdots, N$ 头牛的身高。", "outputFormat": "输出共一行一个整数，代表 $C _ 1 + C _ 2 + \\cdots + C _ N$。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq N \\leq 8 \\times 10 ^ 4$，$1 \\leq h _ i \\leq 10 ^ 9$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO06NOV] Bad Hair Day S", "background": "", "description": "Farmer John has $N$ cows on a Bad Hair Day.\n\nAll cows stand in a single line facing right, and they are numbered from left to right as $1, 2, \\cdots, N$. Cow $N$ is at the front, and cow $1$ is at the back. The height of cow $i$ is $h_i$.\n\nFor the cows in front of cow $i$, if $h_i > h_{i+1}, h_i > h_{i+2}, \\cdots, h_i > h_j$, then cow $i$ is considered able to see cows $i+1$ through $j$.\n\nDefine $C_i$ as the number of cows visible to cow $i$. Please help Farmer John compute $C_1 + C_2 + \\cdots + C_N$.", "inputFormat": "The input contains $N + 1$ lines.\n\nThe first line contains an integer $N$, the number of cows.  \nThe next $N$ lines each contain an integer $h_i$, representing the heights of cows $1, 2, \\cdots, N$.", "outputFormat": "Output a single line with one integer, the value of $C_1 + C_2 + \\cdots + C_N$.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\leq N \\leq 8 \\times 10^4$, $1 \\leq h_i \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO06NOV] Bad Hair Day S", "background": "", "description": "\n农夫约翰有 $N$ 头奶牛正在过乱头发节。\n\n每一头牛都站在同一排面朝右，它们被从左到右依次编号为 $1, 2, \\cdots, N$。编号为 $i$ 的牛身高为 $h_i$。第 $N$ 头牛在最前面，而第 $1$ 头牛在最后面。\n\n对于第 $i$ 头牛**前面**的第 $j$ 头牛，如果 $h_i>h_{i+1}, h_i>h_{i+2}, \\cdots, h_i>h_j$，那么认为第 $i$ 头牛可以看到第 $i+1$ 到第 $j$ 头牛。\n\n定义 $C_i$ 为第 $i$ 头牛所能看到的牛的数量。请帮助农夫约翰求出 $C _ 1 + C _ 2 + \\cdots + C _ N$。\n", "inputFormat": "输入共 $N + 1$ 行。\n\n第一行为一个整数 $N$，代表牛的个数。  \n接下来 $N$ 行，每行一个整数 $a _ i$，分别代表第 $1, 2, \\cdots, N$ 头牛的身高。", "outputFormat": "输出共一行一个整数，代表 $C _ 1 + C _ 2 + \\cdots + C _ N$。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq N \\leq 8 \\times 10 ^ 4$，$1 \\leq h _ i \\leq 10 ^ 9$。", "locale": "zh-CN"}}}
{"pid": "P2867", "type": "P", "difficulty": 4, "samples": [["6\nJ*J***\n******\nJ***J*\n******\n**B***\n******", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2006", "USACO", "枚举", "深度优先搜索 DFS"], "title": "[USACO06NOV] Big Square S", "background": "[English version](https://www.luogu.com.cn/paste/x781adew)", "description": "农民 John 的牛参加了一次和农民 Bob 的牛的竞赛。\n\n他们在区域中画了一个 $N\\times N$ 的正方形点阵，两个农场的牛各自占据了一些点。当然不能有两头牛处于同一个点。\n\n农场的目标是用自己的牛作为 $4$ 个顶点，形成一个面积最大的正方形（不必须和边界平行）。\n\n除了 Bessie 以外，John 其他的牛都已经放到点阵中去了，要确定 Bessie 放在哪个位置，能使得 John 的农场得到一个最大的正方形（Bessie 不是必须参与作为正方形的四个顶点之一）。", "inputFormat": "第 $1$ 行：一个单独的整数，$N$（$2 \\leq N \\leq 100$）。\n\n第 $2 \\sim (N+1)$ 行：第 $i-1$ 行使用 $N$ 个字符描述区域的第 $i$ 行。其中，`J`代表此点被 John 的牛占据，`B` 代表此点被 Bob 的牛占据，而 `*` 代表一个未被占据的点。输入保证至少有一个未被占据的点。", "outputFormat": "输出一个整数，表示 John 的农场所能达到的最大面积。如果无法形成正方形，则输出 $0$。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[USACO06NOV] Big Square S", "background": "[English version](https://www.luogu.com.cn/paste/x781adew)", "description": "Farmer John’s cows are competing against Farmer Bob’s cows.\n\nThey draw an $N\\times N$ square lattice of points in the field. Each farm’s cows occupy some points, and of course no two cows can be at the same point.\n\nEach farm aims to use its own cows as the $4$ vertices to form a square with the maximum possible area (the square does not need to be axis-aligned).\n\nAll of John’s cows except Bessie have already been placed on the lattice. Determine where to place Bessie so that John’s farm can obtain a square with the maximum possible area (Bessie is not required to be one of the four vertices).", "inputFormat": "Line $1$: A single integer $N$ ($2 \\leq N \\leq 100$).\n\nLines $2$ to $(N+1)$: The $(i-1)$-th of these lines uses $N$ characters to describe row $i$ of the field. `J` denotes a point occupied by John’s cow, `B` denotes a point occupied by Bob’s cow, and `*` denotes an unoccupied point. The input guarantees at least one unoccupied point.", "outputFormat": "Output a single integer, the maximum area that John’s farm can achieve. If no square can be formed, output $0$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO06NOV] Big Square S", "background": "[English version](https://www.luogu.com.cn/paste/x781adew)", "description": "农民 John 的牛参加了一次和农民 Bob 的牛的竞赛。\n\n他们在区域中画了一个 $N\\times N$ 的正方形点阵，两个农场的牛各自占据了一些点。当然不能有两头牛处于同一个点。\n\n农场的目标是用自己的牛作为 $4$ 个顶点，形成一个面积最大的正方形（不必须和边界平行）。\n\n除了 Bessie 以外，John 其他的牛都已经放到点阵中去了，要确定 Bessie 放在哪个位置，能使得 John 的农场得到一个最大的正方形（Bessie 不是必须参与作为正方形的四个顶点之一）。", "inputFormat": "第 $1$ 行：一个单独的整数，$N$（$2 \\leq N \\leq 100$）。\n\n第 $2 \\sim (N+1)$ 行：第 $i-1$ 行使用 $N$ 个字符描述区域的第 $i$ 行。其中，`J`代表此点被 John 的牛占据，`B` 代表此点被 Bob 的牛占据，而 `*` 代表一个未被占据的点。输入保证至少有一个未被占据的点。", "outputFormat": "输出一个整数，表示 John 的农场所能达到的最大面积。如果无法形成正方形，则输出 $0$。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2868", "type": "P", "difficulty": 5, "samples": [["5 7\n30\n10\n10\n5\n10\n1 2 3\n2 3 2\n3 4 5\n3 5 2\n4 5 5\n5 1 3\n5 2 2", "6.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "2007", "二分", "USACO", "最短路", "分数规划"], "title": "[USACO07DEC] Sightseeing Cows G", "background": "", "description": "Farmer John has decided to reward his cows for their hard work by taking them on a tour of the big city! The cows must decide how best to spend their free time.\n\nFortunately, they have a detailed city map showing the L (2 ≤ L ≤ 1000) major landmarks (conveniently numbered 1.. L) and the P (2 ≤ P ≤ 5000) unidirectional cow paths that join them. Farmer John will drive the cows to a starting landmark of their choice, from which they will walk along the cow paths to a series of other landmarks, ending back at their starting landmark where Farmer John will pick them up and take them back to the farm. Because space in the city is at a premium, the cow paths are very narrow and so travel along each cow path is only allowed in one fixed direction.\n\nWhile the cows may spend as much time as they like in the city, they do tend to get bored easily. Visiting each new landmark is fun, but walking between them takes time. The cows know the exact fun values Fi (1 ≤ Fi ≤ 1000) for each landmark i.\n\nThe cows also know about the cowpaths. Cowpath i connects landmark L1i to L2i (in the direction L1i -> L2i ) and requires time Ti (1 ≤ Ti ≤ 1000) to traverse.\n\nIn order to have the best possible day off, the cows want to maximize the average fun value per unit time of their trip. Of course, the landmarks are only fun the first time they are visited; the cows may pass through the landmark more than once, but they do not perceive its fun value again. Furthermore, Farmer John is making the cows visit at least two landmarks, so that they get some exercise during their day off.\n\nHelp the cows find the maximum fun value per unit time that they can achieve.\n", "inputFormat": "\\* Line 1: Two space-separated integers: L and P\n\n\\* Lines 2..L+1: Line i+1 contains a single one integer: Fi\n\n\\* Lines L+2..L+P+1: Line L+i+1 describes cow path i with three space-separated integers: L1i , L2i , and Ti\n", "outputFormat": "\\* Line 1: A single number given to two decimal places (do not perform explicit rounding), the maximum possible average fun per unit time, or 0 if the cows cannot plan any trip at all in accordance with the above rules.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO07DEC] Sightseeing Cows G", "background": "", "description": "Farmer John has decided to reward his cows for their hard work by taking them on a tour of the big city! The cows must decide how best to spend their free time.\n\nFortunately, they have a detailed city map showing the L (2 ≤ L ≤ 1000) major landmarks (conveniently numbered 1.. L) and the P (2 ≤ P ≤ 5000) unidirectional cow paths that join them. Farmer John will drive the cows to a starting landmark of their choice, from which they will walk along the cow paths to a series of other landmarks, ending back at their starting landmark where Farmer John will pick them up and take them back to the farm. Because space in the city is at a premium, the cow paths are very narrow and so travel along each cow path is only allowed in one fixed direction.\n\nWhile the cows may spend as much time as they like in the city, they do tend to get bored easily. Visiting each new landmark is fun, but walking between them takes time. The cows know the exact fun values Fi (1 ≤ Fi ≤ 1000) for each landmark i.\n\nThe cows also know about the cowpaths. Cowpath i connects landmark L1i to L2i (in the direction L1i -> L2i ) and requires time Ti (1 ≤ Ti ≤ 1000) to traverse.\n\nIn order to have the best possible day off, the cows want to maximize the average fun value per unit time of their trip. Of course, the landmarks are only fun the first time they are visited; the cows may pass through the landmark more than once, but they do not perceive its fun value again. Furthermore, Farmer John is making the cows visit at least two landmarks, so that they get some exercise during their day off.\n\nHelp the cows find the maximum fun value per unit time that they can achieve.\n", "inputFormat": "\\* Line 1: Two space-separated integers: L and P\n\n\\* Lines 2..L+1: Line i+1 contains a single one integer: Fi\n\n\\* Lines L+2..L+P+1: Line L+i+1 describes cow path i with three space-separated integers: L1i , L2i , and Ti\n", "outputFormat": "\\* Line 1: A single number given to two decimal places (do not perform explicit rounding), the maximum possible average fun per unit time, or 0 if the cows cannot plan any trip at all in accordance with the above rules.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO07DEC] Sightseeing Cows G", "background": null, "description": "农夫约翰决定奖励他的奶牛们的辛勤工作，带它们去大城市游览！奶牛们必须决定如何最好地度过它们的空闲时间。\n\n幸运的是，它们有一张详细的城市地图，显示了 $L$ $(2 \\leq L \\leq 1000)$ 个主要地标（方便地编号为 $1$ 到 $L$）和 $P$ $(2 \\leq P \\leq 5000)$ 条连接这些地标的单向牛道。农夫约翰会把奶牛们送到它们选择的一个起始地标，从那里它们将沿着牛道走到一系列其他地标，最后回到它们的起始地标，农夫约翰会在那里接它们回农场。由于城市空间有限，牛道非常狭窄，因此每条牛道的旅行只能沿着一个固定方向进行。\n\n虽然奶牛们可以在城市里待多久都行，但它们很容易感到无聊。参观每个新的地标很有趣，但在它们之间行走需要时间。奶牛们知道每个地标 $i$ 的确切乐趣值 $F_i$ $(1 \\leq F_i \\leq 1000)$。\n\n奶牛们还了解牛道。牛道 $i$ 连接地标 $L1_i$ 到 $L2_i$（方向为 $L1_i \\to L2_i$），需要时间 $T_i$ $(1 \\leq T_i \\leq 1000)$ 来穿越。\n\n为了度过一个最好的假期，奶牛们希望最大化它们旅行的单位时间平均乐趣值。当然，地标只有在第一次访问时才有趣；奶牛们可以多次经过地标，但它们不会再次感受到它的乐趣值。此外，农夫约翰要求奶牛们至少访问两个地标，以便在假期中得到一些锻炼。\n\n帮助奶牛们找到它们能够实现的最大单位时间乐趣值。", "inputFormat": "第 $1$ 行：两个用空格分隔的整数：$L$ 和 $P$\n\n第 $2$ 行到第 $L+1$ 行：第 $i+1$ 行包含一个整数：$F_i$\n\n第 $L+2$ 行到第 $L+P+1$ 行：第 $L+i+1$ 行描述牛道 $i$，包含三个用空格分隔的整数：$L1_i$，$L2_i$ 和 $T_i$", "outputFormat": "第 $1$ 行：一个保留两位小数的数字（不要进行显式四舍五入），表示最大可能的单位时间平均乐趣值，如果奶牛们无法按照上述规则计划任何旅行，则输出 $0$。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2869", "type": "P", "difficulty": 5, "samples": [["4 7\n1 1\n2 3\n1 4\n4 2\n3 2\n2 1\n4 3\n5 2\n5 4\n2 6\n4 4", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "USACO"], "title": "[USACO07DEC] Gourmet Grazers G", "background": "", "description": "Like so many others, the cows have developed very haughty tastes and will no longer graze on just any grass. Instead, Farmer John must purchase gourmet organic grass at the Green Grass Grocers store for each of his N (1 ≤ N ≤ 100,000) cows.\n\nEach cow i demands grass of price at least Ai (1 ≤ Ai ≤ 1,000,000,000) and with a greenness score at least Bi (1 ≤ Bi ≤ 1,000,000,000). The GGG store has M (1 ≤ M ≤ 100,000) different types of grass available, each with a price Ci (1 ≤ Ci ≤ 1,000,000,000) and a greenness score of Di (1 ≤ Di ≤ 1,000,000,000). Of course, no cow would sacrifice her individuality, so no two cows can have the same kind of grass.\n\nHelp Farmer John satisfy the cows' expensive gourmet tastes while spending as little money as is necessary.", "inputFormat": "\\* Line 1: Two space-separated integers: N and M.\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: Ai and Bi\n\n\\* Lines N+2..N+M+1: Line i+N+1 contains two space-separated integers: Ci and Di\n", "outputFormat": "\\* Line 1: A single integer which is the minimum cost to satisfy all the cows. If that is not possible, output -1.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO07DEC] Gourmet Grazers G", "background": "", "description": "Like so many others, the cows have developed very haughty tastes and will no longer graze on just any grass. Instead, Farmer John must purchase gourmet organic grass at the Green Grass Grocers store for each of his N (1 ≤ N ≤ 100,000) cows.\n\nEach cow i demands grass of price at least Ai (1 ≤ Ai ≤ 1,000,000,000) and with a greenness score at least Bi (1 ≤ Bi ≤ 1,000,000,000). The GGG store has M (1 ≤ M ≤ 100,000) different types of grass available, each with a price Ci (1 ≤ Ci ≤ 1,000,000,000) and a greenness score of Di (1 ≤ Di ≤ 1,000,000,000). Of course, no cow would sacrifice her individuality, so no two cows can have the same kind of grass.\n\nHelp Farmer John satisfy the cows' expensive gourmet tastes while spending as little money as is necessary.", "inputFormat": "\\* Line 1: Two space-separated integers: N and M.\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: Ai and Bi\n\n\\* Lines N+2..N+M+1: Line i+N+1 contains two space-separated integers: Ci and Di\n", "outputFormat": "\\* Line 1: A single integer which is the minimum cost to satisfy all the cows. If that is not possible, output -1.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO07DEC] Gourmet Grazers G", "background": null, "description": "约翰的奶牛对食物越来越挑剔了。现在，商店有 $m$ 份牧草可供出售，奶牛食量很大，每份牧草仅能供一头奶牛食用。第 $i$ 份牧草的价格为 $c_i$，口感为 $d_i$。\n\n约翰一共有 $n$ 头奶牛，他要为每头奶牛订购一份牧草，第 $i$ 头奶牛要求 它的牧草价格不低于 $a_i$，口感不低于 $b_i$。请问，约翰应该如何为每头奶牛选择牧草，才能让他花的钱最少？", "inputFormat": "第一行，两个整数 $n$ 和 $m$。  \n\n第 $2\\sim n+1$ 行，第 $i+1$ 行两个整数 $a_i$ 和 $b_i$。  \n\n第 $n+2\\sim n+m+1$ 行，第 $i+n+1$ 行两个整数 $c_i$ 和 $d_i$。\n\n含义见题面所述。", "outputFormat": "输出仅一行，代表能够满足所有奶牛要求所要花的钱的最小值。如果不能够满足所有奶牛的要求，输出 `-1`。", "hint": "对于 $100\\%$ 的数据，满足 $1\\leqslant n,m\\leqslant 10^5$，$1\\leqslant a_i,b_i,c_i,d_i\\leqslant 10^9$。", "locale": "zh-CN"}}}
{"pid": "P2870", "type": "P", "difficulty": 4, "samples": [["6\nA\nC\nD\nB\nC\nB", "ABCBCD"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["字符串", "贪心", "2007", "USACO", "哈希 hashing", "队列", "后缀数组 SA"], "title": "[USACO07DEC] Best Cow Line G", "background": "*本题和 [2007 年 11 月月赛银组同名题目](/problem/P6140) 在题意上一致，唯一的差别是数据范围。*", "description": "Farmer John 打算带领 $N$（$1 \\leq N \\leq 5 \\times 10^5$）头奶牛参加一年一度的“全美农场主大奖赛”。在这场比赛中，每个参赛者必须让他的奶牛排成一列，然后带领这些奶牛从裁判面前依此走过。\n\n今年，竞赛委员会在接受报名时，采用了一种新的登记规则：取每头奶牛名字的首字母，按照它们在队伍中的次序排成一列。将所有队伍的名字按字典序升序排序，从而得到出场顺序。\n\nFJ 由于事务繁忙，他希望能够尽早出场。因此他决定重排队列。\n\n他的调整方式是这样的：每次，他从原队列的首端或尾端牵出一头奶牛，将她安排到新队列尾部。重复这一操作直到所有奶牛都插入新队列为止。\n\n现在请你帮 FJ 算出按照上面这种方法能排出的字典序最小的队列。", "inputFormat": "第一行一个整数 $N$。\n\n接下来 $N$ 行每行一个大写字母，表示初始队列。", "outputFormat": "输出一个长度为 $N$ 的字符串，表示可能的最小字典序队列。\n\n每输出 $80$ 个字母需要一个换行。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[USACO07DEC] Best Cow Line G", "background": "This problem has the same statement as the problem with the same name from the November 2007 Monthly Contest, Silver Group (/problem/P6140), with the only difference being the Constraints.", "description": "Farmer John plans to bring $N$ ( $1 \\leq N \\leq 5 \\times 10^5$ ) cows to the annual \"All-American Farmers Grand Prix\". In this contest, each participant must line up his cows in a single row, then lead them past the judges one by one.\n\nThis year, during registration, the committee adopted a new rule: take the first letter of each cow’s name, in the order they appear in the line, to form a string. Sort all teams’ strings in ascending lexicographic order to determine the order of appearance.\n\nSince FJ is busy, he wants to appear as early as possible. Therefore, he decides to rearrange the line.\n\nHis operation is as follows: at each step, he takes one cow from either the front or the back of the original line and appends her to the end of a new line. He repeats this until all cows have been placed into the new line.\n\nPlease help FJ compute the lexicographically smallest line that can be formed using the method above.", "inputFormat": "The first line contains an integer $N$.\n\nThe next $N$ lines each contain a single uppercase letter, representing the initial line.", "outputFormat": "Output a string of length $N$ representing the lexicographically smallest possible line.\n\nPrint a newline after every $80$ letters.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO07DEC] Best Cow Line G", "background": "*本题和 [2007 年 11 月月赛银组同名题目](/problem/P6140) 在题意上一致，唯一的差别是数据范围。*", "description": "Farmer John 打算带领 $N$（$1 \\leq N \\leq 5 \\times 10^5$）头奶牛参加一年一度的“全美农场主大奖赛”。在这场比赛中，每个参赛者必须让他的奶牛排成一列，然后带领这些奶牛从裁判面前依此走过。\n\n今年，竞赛委员会在接受报名时，采用了一种新的登记规则：取每头奶牛名字的首字母，按照它们在队伍中的次序排成一列。将所有队伍的名字按字典序升序排序，从而得到出场顺序。\n\nFJ 由于事务繁忙，他希望能够尽早出场。因此他决定重排队列。\n\n他的调整方式是这样的：每次，他从原队列的首端或尾端牵出一头奶牛，将她安排到新队列尾部。重复这一操作直到所有奶牛都插入新队列为止。\n\n现在请你帮 FJ 算出按照上面这种方法能排出的字典序最小的队列。", "inputFormat": "第一行一个整数 $N$。\n\n接下来 $N$ 行每行一个大写字母，表示初始队列。", "outputFormat": "输出一个长度为 $N$ 的字符串，表示可能的最小字典序队列。\n\n每输出 $80$ 个字母需要一个换行。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2871", "type": "P", "difficulty": 2, "samples": [["4 6\n1 4\n2 6\n3 12\n2 7", "23"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2007", "USACO", "枚举", "背包 DP"], "title": "[USACO07DEC] Charm Bracelet S", "background": null, "description": "有 $N$ 件物品和一个容量为 $M$ 的背包。第 $i$ 件物品的重量是 $W_i$，价值是 $D_i$。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。", "inputFormat": "第一行：物品个数 $N$ 和背包大小 $M$。\n\n第二行至第 $N+1$ 行：第 $i$ 个物品的重量 $W_i$ 和价值 $D_i$。", "outputFormat": "输出一行最大价值。", "hint": "$1 \\le N \\le 3402$，$1 \\le M \\le 12880$，$1 \\le W_i \\le 400$，$1 \\le D_i \\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO07DEC] Charm Bracelet S", "background": null, "description": "Bessie has gone to the mall's jewelry store and spies a charm bracelet. Of course, she'd like to fill it with the best charms possible from the $N (1 \\le N \\le 3,402)$ available charms. Each charm i in the supplied list has a weight $W_i (1 \\le W_i \\le 400)$, a 'desirability' factor $D_i (1 \\le D_i \\le 100)$, and can be used at most once. Bessie can only support a charm bracelet whose weight is no more than $M (1 \\le M \\le 12,880)$.\n\nGiven that weight limit as a constraint and a list of the charms with their weights and desirability rating, deduce the maximum possible sum of ratings.", "inputFormat": "* Line $1$: Two space-separated integers: $N$ and $M$.\n\n* Lines $2 \\sim N+1$: Line $i+1$ describes charm $i$ with two space-separated integers: $W_i$ and $D_i$.", "outputFormat": "* Line $1$: A single integer that is the greatest sum of charm desirabilities that can be achieved given the weight constraints.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO07DEC] Charm Bracelet S", "background": null, "description": "有 $N$ 件物品和一个容量为 $M$ 的背包。第 $i$ 件物品的重量是 $W_i$，价值是 $D_i$。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。", "inputFormat": "第一行：物品个数 $N$ 和背包大小 $M$。\n\n第二行至第 $N+1$ 行：第 $i$ 个物品的重量 $W_i$ 和价值 $D_i$。", "outputFormat": "输出一行最大价值。", "hint": "$1 \\le N \\le 3402$，$1 \\le M \\le 12880$，$1 \\le W_i \\le 400$，$1 \\le D_i \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P2872", "type": "P", "difficulty": 3, "samples": [["4 1\n1 1\n3 1\n2 3\n4 3\n1 4", "4.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2007", "USACO", "生成树"], "title": "[USACO07DEC] Building Roads S", "background": null, "description": "给定 $n$ 个点的坐标，第 $i$ 个点的坐标为 $(x_i,y_i)$，这 $n$ 个点编号为 $1$ 到 $n$。给定 $m$ 条边，第 $i$ 条边连接第 $u_i$ 个点和第 $v_i$ 个点。现在要求你添加一些边，并且能使得任意一点都可以连通其他所有点。求添加的边的总长度的最小值。", "inputFormat": "第一行两个整数 $n,m$ 代表点数与边数。   \n接下来 $n$ 行每行两个整数 $x_i,y_i$ 代表第 $i$ 个点的坐标。   \n接下来 $m$ 行每行两个整数 $u_i,v_i$ 代表第 $i$ 条边连接第 $u_i$ 个点和第 $v_i$ 个点。", "outputFormat": "一行一个实数代表添加的边的最小长度，要求保留两位小数，为了避免误差，请用 $64$ 位实型变量进行计算。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的整数，$1 \\le n,m \\le 1000$，$1 \\le x_i,y_i \\le 10^6$，$1 \\le u_i,v_i \\le n$。\n\n### 说明\n\nTranslated by 一只书虫仔。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO07DEC] Building Roads S", "background": null, "description": "Farmer John had just acquired several new farms! He wants to connect the farms with roads so that he can travel from any farm to any other farm via a sequence of roads; roads already connect some of the farms.\n\nEach of the $N (1 \\le N \\le 1,000)$ farms (conveniently numbered $1 \\sim N$) is represented by a position $(X_i, Y_i)$ on the plane $(0 \\le X_i \\le 1,000,000; 0 \\le Y_i \\le 1,000,000)$. Given the preexisting $M$ roads $(1 \\le M \\le 1,000)$ as pairs of connected farms, help Farmer John determine the smallest length of additional roads he must build to connect all his farms.", "inputFormat": "* Line $1$: Two space-separated integers: $N$ and $M$.\n\n* Lines $2 \\sim N+1$: Two space-separated integers: $X_i$ and $Y_i$.\n\n* Lines $N+2 \\sim N+M+2$: Two space-separated integers: $i$ and $j$, indicating that there is already a road connecting the farm $i$ and farm $j$.", "outputFormat": "* Line $1$: Smallest length of additional roads required to connect all farms, printed without rounding to two decimal places. Be sure to calculate distances as 64-bit floating point numbers.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO07DEC] Building Roads S", "background": null, "description": "给定 $n$ 个点的坐标，第 $i$ 个点的坐标为 $(x_i,y_i)$，这 $n$ 个点编号为 $1$ 到 $n$。给定 $m$ 条边，第 $i$ 条边连接第 $u_i$ 个点和第 $v_i$ 个点。现在要求你添加一些边，并且能使得任意一点都可以连通其他所有点。求添加的边的总长度的最小值。", "inputFormat": "第一行两个整数 $n,m$ 代表点数与边数。   \n接下来 $n$ 行每行两个整数 $x_i,y_i$ 代表第 $i$ 个点的坐标。   \n接下来 $m$ 行每行两个整数 $u_i,v_i$ 代表第 $i$ 条边连接第 $u_i$ 个点和第 $v_i$ 个点。", "outputFormat": "一行一个实数代表添加的边的最小长度，要求保留两位小数，为了避免误差，请用 $64$ 位实型变量进行计算。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的整数，$1 \\le n,m \\le 1000$，$1 \\le x_i,y_i \\le 10^6$，$1 \\le u_i,v_i \\le n$。\n\n### 说明\n\nTranslated by 一只书虫仔。", "locale": "zh-CN"}}}
{"pid": "P2873", "type": "P", "difficulty": 2, "samples": [["1 2 7\n0 2\n-1 3\n3 1\n1 1\n4 2\n-1 1\n2 2", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "USACO"], "title": "[USACO07DEC] Mud Puddles S", "background": "", "description": "Farmer John is leaving his house promptly at 6 AM for his daily milking of Bessie. However, the previous evening saw a heavy rain, and the fields are quite muddy. FJ starts at the point (0, 0) in the coordinate plane and heads toward Bessie who is located at (X, Y) (-500 ≤ X ≤ 500; -500 ≤ Y ≤ 500). He can see all N (1 ≤ N ≤ 10,000) puddles of mud, located at points (Ai, Bi) (-500 ≤ Ai ≤ 500; -500 ≤ Bi ≤ 500) on the field. Each puddle occupies only the point it is on.\n\nHaving just bought new boots, Farmer John absolutely does not want to dirty them by stepping in a puddle, but he also wants to get to Bessie as quickly as possible. He's already late because he had to count all the puddles. If Farmer John can only travel parallel to the axes and turn at points with integer coordinates, what is the shortest distance he must travel to reach Bessie and keep his boots clean? There will always be a path without mud that Farmer John can take to reach Bessie.", "inputFormat": "\\* Line 1: Three space-separate integers: X, Y, and N.\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: Ai and Bi\n", "outputFormat": "\\* Line 1: The minimum distance that Farmer John has to travel to reach Bessie without stepping in mud.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO07DEC] Mud Puddles S", "background": "", "description": "Farmer John is leaving his house promptly at 6 AM for his daily milking of Bessie. However, the previous evening saw a heavy rain, and the fields are quite muddy. FJ starts at the point (0, 0) in the coordinate plane and heads toward Bessie who is located at (X, Y) (-500 ≤ X ≤ 500; -500 ≤ Y ≤ 500). He can see all N (1 ≤ N ≤ 10,000) puddles of mud, located at points (Ai, Bi) (-500 ≤ Ai ≤ 500; -500 ≤ Bi ≤ 500) on the field. Each puddle occupies only the point it is on.\n\nHaving just bought new boots, Farmer John absolutely does not want to dirty them by stepping in a puddle, but he also wants to get to Bessie as quickly as possible. He's already late because he had to count all the puddles. If Farmer John can only travel parallel to the axes and turn at points with integer coordinates, what is the shortest distance he must travel to reach Bessie and keep his boots clean? There will always be a path without mud that Farmer John can take to reach Bessie.", "inputFormat": "\\* Line 1: Three space-separate integers: X, Y, and N.\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: Ai and Bi\n", "outputFormat": "\\* Line 1: The minimum distance that Farmer John has to travel to reach Bessie without stepping in mud.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO07DEC] Mud Puddles S", "background": null, "description": "农夫约翰在早上 $6$ 点准时离开家去挤奶贝茜。然而，前一天晚上下了大雨，田地里非常泥泞。约翰从坐标平面上的点 $(0,0)$ 出发，前往位于 $(X,Y)$ 的贝茜（$-500\\le X\\le 500$；$-500\\le Y\\le 500$）。他可以看到田地上所有 $N(1\\le N\\le 10,000)$ 个泥坑，位于点 $(A_i,B_i)$（$-500\\le A_i\\le 500$；$-500\\le B_i\\le 500$）。每个泥坑只占据它所在的点。\n\n刚买了新靴子的农夫约翰绝对不想弄脏他的靴子，但他也想尽快到达贝茜。他已经迟到了，因为他不得不数清所有的泥坑。如果农夫约翰只能平行于坐标轴行走，并且只能在整数坐标点处转弯，那么他到达贝茜并保持靴子干净的最短距离是多少？总会有一条没有泥的路径可以让农夫约翰到达贝茜。", "inputFormat": "* 第 $1$ 行：三个用空格分隔的整数：$X,Y,N$。\n* 第 $2$ 行到第 $N+1$ 行：第 $i+1$ 行包含两个用空格分隔的整数：$A_i$ 和 $B_i$。", "outputFormat": "* 第 $1$ 行：农夫约翰到达贝茜而不踩到泥的最短距离。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P2874", "type": "P", "difficulty": 5, "samples": [["4\n1 -3\n0 1\n-2 1\n1 -1", "10 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "贪心", "2007", "USACO"], "title": "[USACO07FEB] Building A New Barn G", "background": null, "description": "给出平面上 $n$ 个两两之间曼哈顿距离不小于 $2$ 的整点，要求到这 $n$ 个点的曼哈顿距离之和最小，且不与 $n$ 个点中任意一个点重合的整点个数 $C$，和这个最小距离 $D$。", "inputFormat": "第一行一个正整数 $n$。\n\n下面 $n$ 行，每行两个整数 $x_i,y_i$，表示一个点的坐标 $(x_i,y_i)$。", "outputFormat": "一行两个整数 $D,C$。", "hint": "样例解释：$D=10$，$4$ 个最优整点分别是 $(0, -1), (0, 0), (1, 0), (1, 1)$。$(0,1)$ 和 $(1,-1)$ 也是符合题意的，但是因为与给定的点重合了，所以不算在答案内。\n\n\n---\n\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 10^4$，$-10^4 \\le x_i,y_i \\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO07FEB] Building A New Barn G", "background": null, "description": "After scrimping and saving for years, Farmer John has decided to build a new barn. He wants the barn to be highly accessible, and he knows the coordinates of the grazing spots of all N (2 ≤ N ≤ 10,000 cows. Each grazing spot is at a point with integer coordinates (Xi, Yi) (-10,000 ≤ Xi ≤ 10,000; -10,000 ≤ Yi ≤ 10,000). The hungry cows never graze in spots that are horizontally or vertically adjacent.\n\nThe barn must be placed at integer coordinates and cannot be on any cow's grazing spot. The inconvenience of the barn for any cow is given the Manhattan distance formula | X - Xi | + | Y - Yi|, where (X, Y) and (Xi, Yi) are the coordinates of the barn and the cow's grazing spot, respectively. Where should the barn be constructed in order to minimize the sum of its inconvenience for all the cows?", "inputFormat": "Line 1: A single integer: N\n\nLines 2..N+1: Line i+1 contains two space-separated integers which are the grazing location (Xi, Yi) of cow i", "outputFormat": "Line 1: Two space-separated integers: the minimum inconvenience for the barn and the number of spots on which Farmer John can build the barn to achieve this minimum.", "hint": "The minimum inconvenience is 10, and there are 4 spots that Farmer John can build the farm to achieve this: (0, -1), (0, 0), (1, 0), and (1, 1).", "locale": "en"}, "zh-CN": {"title": "[USACO07FEB] Building A New Barn G", "background": null, "description": "给出平面上 $n$ 个两两之间曼哈顿距离不小于 $2$ 的整点，要求到这 $n$ 个点的曼哈顿距离之和最小，且不与 $n$ 个点中任意一个点重合的整点个数 $C$，和这个最小距离 $D$。", "inputFormat": "第一行一个正整数 $n$。\n\n下面 $n$ 行，每行两个整数 $x_i,y_i$，表示一个点的坐标 $(x_i,y_i)$。", "outputFormat": "一行两个整数 $D,C$。", "hint": "样例解释：$D=10$，$4$ 个最优整点分别是 $(0, -1), (0, 0), (1, 0), (1, 1)$。$(0,1)$ 和 $(1,-1)$ 也是符合题意的，但是因为与给定的点重合了，所以不算在答案内。\n\n\n---\n\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 10^4$，$-10^4 \\le x_i,y_i \\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P2875", "type": "P", "difficulty": 5, "samples": [["6 10\nbrowndcodw\ncow\nmilk\nwhite\nblack\nbrown\nfarmer", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "2007", "USACO"], "title": "[USACO07FEB] The Cow Lexicon S", "background": "", "description": "Few know that the cows have their own dictionary with W (1 ≤ W ≤ 600) words, each containing no more 25 of the characters 'a'..'z'. Their cowmunication system, based on mooing, is not very accurate; sometimes they hear words that do not make any sense. For instance, Bessie once received a message that said \"browndcodw\". As it turns out, the intended message was \"browncow\" and the two letter \"d\"s were noise from other parts of the barnyard.\n\nThe cows want you to help them decipher a received message (also containing only characters in the range 'a'..'z') of length L (2 ≤ L ≤ 300) characters that is a bit garbled. In particular, they know that the message has some extra letters, and they want you to determine the smallest number of letters that must be removed to make the message a sequence of words from the dictionary.", "inputFormat": "Line 1: Two space-separated integers, respectively: W and L\n\n\nLine 2: L characters (followed by a newline, of course): the received message\n\n\nLines 3..W+2: The cows' dictionary, one word per line\n\n• 第1行:两个用空格隔开的整数,W和L.\n\n\n• 第2行:一个长度为L的字符串,表示收到的信息.\n\n\n• 第3行至第W+2行:奶牛的字典,每行一个词.\n", "outputFormat": "Line 1: a single integer that is the smallest number of characters that need to be removed to make the message a sequence of dictionary words.\n\n一个整数,表示最少去掉几个字母就可以使之变成准确的\"牛语\".\n", "hint": "感谢@ws\\_fuweidong 提供完整题面\n", "locale": "en", "translations": {"en": {"title": "[USACO07FEB] The Cow Lexicon S", "background": "", "description": "Few know that the cows have their own dictionary with W (1 ≤ W ≤ 600) words, each containing no more 25 of the characters 'a'..'z'. Their cowmunication system, based on mooing, is not very accurate; sometimes they hear words that do not make any sense. For instance, Bessie once received a message that said \"browndcodw\". As it turns out, the intended message was \"browncow\" and the two letter \"d\"s were noise from other parts of the barnyard.\n\nThe cows want you to help them decipher a received message (also containing only characters in the range 'a'..'z') of length L (2 ≤ L ≤ 300) characters that is a bit garbled. In particular, they know that the message has some extra letters, and they want you to determine the smallest number of letters that must be removed to make the message a sequence of words from the dictionary.", "inputFormat": "Line 1: Two space-separated integers, respectively: W and L\n\n\nLine 2: L characters (followed by a newline, of course): the received message\n\n\nLines 3..W+2: The cows' dictionary, one word per line\n\n• 第1行:两个用空格隔开的整数,W和L.\n\n\n• 第2行:一个长度为L的字符串,表示收到的信息.\n\n\n• 第3行至第W+2行:奶牛的字典,每行一个词.\n", "outputFormat": "Line 1: a single integer that is the smallest number of characters that need to be removed to make the message a sequence of dictionary words.\n\n一个整数,表示最少去掉几个字母就可以使之变成准确的\"牛语\".\n", "hint": "感谢@ws\\_fuweidong 提供完整题面\n", "locale": "en"}, "zh-CN": {"title": "[USACO07FEB] The Cow Lexicon S", "background": null, "description": "很少有人知道，奶牛们有自己的字典，它包含 $W$（$1\\le W\\le 600$）个单词。每个单词均由小写字母组成，且最多包含 $25$ 个字符。\n\n它们的“牛语”系统基于哞声，不是很准确；有时它们会听到一些没有意义的词。例如，Bessie 曾收到一条信息 `browndcodw`。结果发现，原本的信息是 `browncow`，其中两个字母 `d` 是来自其他地方的噪音。\n\n奶牛们希望你帮助它们解码收到的信息（只包含小写字母），长度为 $L$（$2\\le L\\le 300$），信息有些混乱。\n\n特别是，它们知道信息中有一些多余的字母，它们希望你确定必须删除的最少字母数量，以使信息成为字典中的单词序列。", "inputFormat": "第 $1$ 行：两个用空格隔开的整数，分别是：$W$ 和 $L$。\n\n第 $2$ 行：一个长度为 $L$ 的字符串，表示收到的信息。\n\n第 $3$ 行至第 $W+2$ 行：奶牛的字典，每行一个单词。", "outputFormat": "一行一个整数，表示最少去掉几个字母就可以使之变成准确的“牛语”。", "hint": "感谢 @ws_fuweidong 提供完整题面。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P2876", "type": "P", "difficulty": 5, "samples": [["100 5\n40 20\n60 20\n30 50\n30 50\n40 40", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2007", "USACO", "最短路"], "title": "[USACO07JAN] Problem Solving G", "background": "", "description": "In easier times, Farmer John's cows had no problems. These days, though, they have problems, lots of problems; they have P (1 ≤ P ≤ 300) problems, to be exact. They have quit providing milk and have taken regular jobs like all other good citizens. In fact, on a normal month they make M (1 ≤ M ≤ 1000) money.\n\nTheir problems, however, are so complex they must hire consultants to solve them. Consultants are not free, but they are competent: consultants can solve any problem in a single month. Each consultant demands two payments: one in advance (1 ≤ payment ≤ M) to be paid at the start of the month problem-solving is commenced and one more payment at the start of the month after the problem is solved (1 ≤ payment ≤ M). Thus, each month the cows can spend the money earned during the previous month to pay for consultants. Cows are spendthrifts: they can never save any money from month-to-month; money not used is wasted on cow candy.\n\nSince the problems to be solved depend on each other, they must be solved mostly in order. For example, problem 3 must be solved before problem 4 or during the same month as problem 4.\n\nDetermine the number of months it takes to solve all of the cows' problems and pay for the solutions.\n\n", "inputFormat": "Line 1: Two space-separated integers: M and P.\n\n\nLines 2..P+1: Line i+1 describes problem i with two space-separated integers: Bi and Ai. Bi is the payment to the consult BEFORE the problem is solved; Ai is the payment to the consult AFTER the problem is solved.\n\n", "outputFormat": "Line 1: The number of months it takes to solve and pay for all the cows' problems.\n", "hint": "|      | Avail | Probs  | Before  | After   | Candy  |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n|Month | Money | Solved | Payment | Payment | Money  |\n| 1    | 0     | -none- | 0       | 0       | 0      |\n| 2    | 100   | 1, 2   | 40+60   | 0       | 0      |\n| 3    | 100   | 3, 4   | 30+30   | 20+20   | 0      |\n| 4    | 100   | -none- | 0       | 50+50   | 0      |\n| 5    | 100   | 5      | 40      | 0       | 60     |\n| 6    | 100   | -none- | 0       | 40      | 60     |", "locale": "en", "translations": {"en": {"title": "[USACO07JAN] Problem Solving G", "background": "", "description": "In easier times, Farmer John's cows had no problems. These days, though, they have problems, lots of problems; they have P (1 ≤ P ≤ 300) problems, to be exact. They have quit providing milk and have taken regular jobs like all other good citizens. In fact, on a normal month they make M (1 ≤ M ≤ 1000) money.\n\nTheir problems, however, are so complex they must hire consultants to solve them. Consultants are not free, but they are competent: consultants can solve any problem in a single month. Each consultant demands two payments: one in advance (1 ≤ payment ≤ M) to be paid at the start of the month problem-solving is commenced and one more payment at the start of the month after the problem is solved (1 ≤ payment ≤ M). Thus, each month the cows can spend the money earned during the previous month to pay for consultants. Cows are spendthrifts: they can never save any money from month-to-month; money not used is wasted on cow candy.\n\nSince the problems to be solved depend on each other, they must be solved mostly in order. For example, problem 3 must be solved before problem 4 or during the same month as problem 4.\n\nDetermine the number of months it takes to solve all of the cows' problems and pay for the solutions.\n\n", "inputFormat": "Line 1: Two space-separated integers: M and P.\n\n\nLines 2..P+1: Line i+1 describes problem i with two space-separated integers: Bi and Ai. Bi is the payment to the consult BEFORE the problem is solved; Ai is the payment to the consult AFTER the problem is solved.\n\n", "outputFormat": "Line 1: The number of months it takes to solve and pay for all the cows' problems.\n", "hint": "|      | Avail | Probs  | Before  | After   | Candy  |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n|Month | Money | Solved | Payment | Payment | Money  |\n| 1    | 0     | -none- | 0       | 0       | 0      |\n| 2    | 100   | 1, 2   | 40+60   | 0       | 0      |\n| 3    | 100   | 3, 4   | 30+30   | 20+20   | 0      |\n| 4    | 100   | -none- | 0       | 50+50   | 0      |\n| 5    | 100   | 5      | 40      | 0       | 60     |\n| 6    | 100   | -none- | 0       | 40      | 60     |", "locale": "en"}, "zh-CN": {"title": "[USACO07JAN] Problem Solving G", "background": null, "description": "在较为轻松的日子里，Farmer John 的奶牛们没有任何问题。然而，如今它们却有许多问题，确切地说，它们有 $P$ 个问题，其中 $1 \\leq P \\leq 300$。它们已经停止提供牛奶，并像其他好公民一样找了常规工作。实际上，在一个正常的月份里，它们可以赚取 $M$ 的钱，其中 $1 \\leq M \\leq 1000$。\n\n然而，它们的问题非常复杂，以至于必须雇佣顾问来解决。顾问不是免费的，但他们很有能力：顾问可以在一个月内解决任何一个问题。每个顾问要求两次付款：一次是在开始解决问题的月份开始时支付的预付款（$1 \\leq \\text{payment} \\leq M$），另一次是在问题解决后的下个月开始时支付的尾款（$1 \\leq \\text{payment} \\leq M$）。因此，每个月奶牛们可以用上个月赚的钱来支付顾问的费用。奶牛们是挥霍无度的，它们无法从一个月到下个月存钱；未使用的钱会浪费在牛糖果上。\n\n由于要解决的问题之间存在依赖关系，它们必须大部分按顺序解决。例如，问题 3 必须在问题 4 之前解决，或者与问题 4 在同一个月解决。\n\n确定解决所有奶牛问题并支付解决费用所需的月份数。", "inputFormat": "第 1 行：两个用空格分隔的整数：$M$ 和 $P$。\n\n\n第 2 行到第 $P+1$ 行：第 $i+1$ 行描述问题 $i$，包含两个用空格分隔的整数：$B_i$ 和 $A_i$。$B_i$ 是在问题解决之前支付给顾问的费用；$A_i$ 是在问题解决之后支付给顾问的费用。", "outputFormat": "第 1 行：解决并支付所有奶牛问题所需的月份数。", "hint": "| 月份 | 当月收入   | 当月解决的问题  | 当月支付的预付款 |  当月支付的尾款   | 浪费金额    |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$    | $0$    | -无-  | $0$       | $0$      | $0$     |\n| $2$    | $100$  | $1, 2$  | $40+60$   | $0$      | $0$     |\n| $3$    | $100$  | $3, 4$  | $30+30$   | $20+20$  | $0$     |\n| $4$    | $100$ | -无-  | $0$       | $50+50$  | $0$     |\n| $5$    | $100$  | $5$     | $40$      | $0$      | $60$    |\n| $6$    | $100$  | -无-  | $0$       | $40$     | $60$    |\n\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2877", "type": "P", "difficulty": 6, "samples": [["5\n1 2\n5 9\n3 8\n4 10\n1 3", "2\n1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "USACO", "cdq 分治", "斜率优化", "分数规划", "决策单调性"], "title": "[USACO07JAN] Cow School G", "background": null, "description": "一个人参加了 $N$ 场考试，第 $i$ 场满分为 $P_i$，其得分为 $T_i$。现在要删去其中 $D$ 次考试的成绩，用剩下的总得分除以剩下的满分之和，作为其最终成绩。问对于哪些 $D$ 而言，删除得分比（即 $\\dfrac{T_i}{P_i}$）最小的 $D$ 场得到的最终成绩不是最优的（用其他方法可以得到更高的最终成绩）。", "inputFormat": "第一行一个正整数 $N$。\n\n下面 $N$ 行，每行两个正整数 $T_i,P_i$。", "outputFormat": "先输出满足题意的 $D$ 的个数，然后升序输出所有满足题意的 $D$，每个一行。", "hint": "样例解释：当 $D \\le 2$ 时，删去 $\\dfrac{4}{10}$ 比删去 $\\dfrac{1}{3}$ 更优。\n\n\n\n---\n\n对于 $91\\%$ 的数据（#1 - #11），$N \\le 5 \\times 10^3$。\n\n对于 $100\\%$ 的数据（#1 - #12），$1 \\le N \\le 5 \\times 10^4$，$0 \\le T_i \\le P_i \\le 4 \\times 10^4$，$P_i \\ne 0$，且所有 $\\dfrac{T_i}{P_i}$ 互不相同。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO07JAN] Cow School G", "background": null, "description": "Bessy is going to school and doing well. She has taken N (1 ≤ N ≤ 5000 -- except one case where 1 ≤ N ≤ 50,000) tests and recorded the scores (Ti points out of Pi points for test i; 0 ≤ Ti ≤ Pi < 40,000; 0 < Pi) as this task's input.\n\nHer teacher will drop the D tests with the lowest percentage (Ti⁄Pi) before calculating Bessie's final grade (which is the sum of the remaining test score points over the sum of the remaining total test points). Bessy is good at math and quickly realizes that this does not benefit her as much as it might.\n\nTo prove her point, Bessy wants to find all values of D for which she could have ended up with a higher grade by choosing to drop different tests than the teacher would have. Help her by finding and printing all values of D for which this is possible.\n\nBessy has noted that, amazingly, she has never scored the same percentage on two different tests.", "inputFormat": "Line 1: A single integer, N\n\nLines 2..N+1: Line i+1 contains two space-separated integers: Ti and Pi", "outputFormat": "Line 1: A single integer K (0 ≤ K ≤ N) that is the number of values of D for which Bessy could have ended up with a higher grade by dropping a different set of D tests than the teacher.\n\nLines 2..K+1: The values of D for which this is true, in ascending numerical order.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO07JAN] Cow School G", "background": null, "description": "一个人参加了 $N$ 场考试，第 $i$ 场满分为 $P_i$，其得分为 $T_i$。现在要删去其中 $D$ 次考试的成绩，用剩下的总得分除以剩下的满分之和，作为其最终成绩。问对于哪些 $D$ 而言，删除得分比（即 $\\dfrac{T_i}{P_i}$）最小的 $D$ 场得到的最终成绩不是最优的（用其他方法可以得到更高的最终成绩）。", "inputFormat": "第一行一个正整数 $N$。\n\n下面 $N$ 行，每行两个正整数 $T_i,P_i$。", "outputFormat": "先输出满足题意的 $D$ 的个数，然后升序输出所有满足题意的 $D$，每个一行。", "hint": "样例解释：当 $D \\le 2$ 时，删去 $\\dfrac{4}{10}$ 比删去 $\\dfrac{1}{3}$ 更优。\n\n\n\n---\n\n对于 $91\\%$ 的数据（#1 - #11），$N \\le 5 \\times 10^3$。\n\n对于 $100\\%$ 的数据（#1 - #12），$1 \\le N \\le 5 \\times 10^4$，$0 \\le T_i \\le P_i \\le 4 \\times 10^4$，$P_i \\ne 0$，且所有 $\\dfrac{T_i}{P_i}$ 互不相同。", "locale": "zh-CN"}}}
{"pid": "P2878", "type": "P", "difficulty": 3, "samples": [["6\n3 1\n2 5\n2 3\n3 2\n4 1\n1 6", "86"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "2007", "USACO", "排序"], "title": "[USACO07JAN] Protecting the Flowers S", "background": "", "description": "有 $n$ 头奶牛跑到 FJ 的花园里去吃花儿了，它们分别在距离牛圈 $T_i$（这里指 FJ 到那里需要 $T_i$ 分钟）处吃花，每分钟会吃掉 $D_i$ 朵花，FJ 现在要将它们给弄回牛圈，但是他每次只能弄一头回去，来回用时总共为 $2 \\times T_i$ 分钟，在这段时间内，其它的奶牛会继续吃 FJ 的花，速度保持不变，当然正在被赶回牛圈的奶牛不能继续吃了。现在求在最好的方案下奶牛吃掉花的最小朵数。", "inputFormat": "第一行一个正整数 $n$。\n\n下面 $n$ 行，每行两个正整数 $T_i,D_i$。", "outputFormat": "一行一个整数表示答案。", "hint": "样例解释：最优策略是按 $6 \\to 2 \\to 3 \\to 4 \\to 1 \\to 5$ 的顺序把牛赶回牛圈。\n\n---\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^5$，$1 \\le T_i \\le 2 \\times 10^6$，$1 \\le D_i \\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO07JAN] Protecting the Flowers S", "background": null, "description": "Farmer John went to cut some wood and left N (2 ≤ N ≤ 100,000) cows eating the grass, as usual. When he returned, he found to his horror that the cluster of cows was in his garden eating his beautiful flowers. Wanting to minimize the subsequent damage, FJ decided to take immediate action and transport each cow back to its own barn.\n\nEach cow i is at a location that is Ti minutes (1 ≤ Ti ≤ 2,000,000) away from its own barn. Furthermore, while waiting for transport, she destroys Di (1 ≤ Di ≤ 100) flowers per minute. No matter how hard he tries, FJ can only transport one cow at a time back to her barn. Moving cow i to its barn requires 2 × Ti minutes (Ti to get there and Ti to return). FJ starts at the flower patch, transports the cow to its barn, and then walks back to the flowers, taking no extra time to get to the next cow that needs transport.\n\nWrite a program to determine the order in which FJ should pick up the cows so that the total number of flowers destroyed is minimized.", "inputFormat": "Line 1: A single integer N\n\nLines 2..N+1: Each line contains two space-separated integers, Ti and Di, that describe a single cow's characteristics", "outputFormat": "Line 1: A single integer that is the minimum number of destroyed flowers", "hint": "FJ returns the cows in the following order: 6, 2, 3, 4, 1, 5. While he is transporting cow 6 to the barn, the others destroy 24 flowers; next he will take cow 2, losing 28 more of his beautiful flora. For the cows 3, 4, 1 he loses 16, 12, and 6 flowers respectively. When he picks cow 5 there are no more cows damaging the flowers, so the loss for that cow is zero. The total flowers lost this way is 24 + 28 + 16 + 12 + 6 = 86.", "locale": "en"}, "zh-CN": {"title": "[USACO07JAN] Protecting the Flowers S", "background": "", "description": "有 $n$ 头奶牛跑到 FJ 的花园里去吃花儿了，它们分别在距离牛圈 $T_i$（这里指 FJ 到那里需要 $T_i$ 分钟）处吃花，每分钟会吃掉 $D_i$ 朵花，FJ 现在要将它们给弄回牛圈，但是他每次只能弄一头回去，来回用时总共为 $2 \\times T_i$ 分钟，在这段时间内，其它的奶牛会继续吃 FJ 的花，速度保持不变，当然正在被赶回牛圈的奶牛不能继续吃了。现在求在最好的方案下奶牛吃掉花的最小朵数。", "inputFormat": "第一行一个正整数 $n$。\n\n下面 $n$ 行，每行两个正整数 $T_i,D_i$。", "outputFormat": "一行一个整数表示答案。", "hint": "样例解释：最优策略是按 $6 \\to 2 \\to 3 \\to 4 \\to 1 \\to 5$ 的顺序把牛赶回牛圈。\n\n---\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^5$，$1 \\le T_i \\le 2 \\times 10^6$，$1 \\le D_i \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P2879", "type": "P", "difficulty": 3, "samples": [["9 3 5 5\n1 3\n5 3\n4 3\n3 7\n9 8", "5\n4\n5\n3\n4\n4\n5\n5\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2007", "USACO", "哈希 hashing", "前缀和", "差分"], "title": "[USACO07JAN] Tallest Cow S", "background": null, "description": "FJ's $N(1 \\le N \\le 10,000)$ cows conveniently indexed $1 \\ldots N$ are standing in a line. Each cow has a positive integer height (which is a bit of secret). You are told only the height $H(1 \\le H \\le 1,000,000)$ of the tallest cow along with the index I of that cow.\n\nFJ has made a list of $R(0 \\le R \\le 10,000)$ lines of the form \"cow 17 sees cow 34\". This means that cow 34 is at least as tall as cow 17, and that every cow between 17 and 34 has a height that is strictly smaller than that of cow 17.\n\nFor each cow from $1 \\ldots N$, determine its maximum possible height, such that all of the information given is still correct. It is guaranteed that it is possible to satisfy all the constraints.", "inputFormat": "Line $1$: Four space-separated integers: $N, I, H$ and $R$\n\n\nLines $2 \\ldots R+1$: Two distinct space-separated integers $A$ and $B(1 \\le A, B \\le N)$, indicating that cow $A$ can see cow $B$.", "outputFormat": "Lines $1 \\ldots N$: Line $i$ contains the maximum possible height of cow $i$.", "hint": null, "locale": "en", "translations": {"en": {"title": "[USACO07JAN] Tallest Cow S", "background": null, "description": "FJ's $N(1 \\le N \\le 10,000)$ cows conveniently indexed $1 \\ldots N$ are standing in a line. Each cow has a positive integer height (which is a bit of secret). You are told only the height $H(1 \\le H \\le 1,000,000)$ of the tallest cow along with the index I of that cow.\n\nFJ has made a list of $R(0 \\le R \\le 10,000)$ lines of the form \"cow 17 sees cow 34\". This means that cow 34 is at least as tall as cow 17, and that every cow between 17 and 34 has a height that is strictly smaller than that of cow 17.\n\nFor each cow from $1 \\ldots N$, determine its maximum possible height, such that all of the information given is still correct. It is guaranteed that it is possible to satisfy all the constraints.", "inputFormat": "Line $1$: Four space-separated integers: $N, I, H$ and $R$\n\n\nLines $2 \\ldots R+1$: Two distinct space-separated integers $A$ and $B(1 \\le A, B \\le N)$, indicating that cow $A$ can see cow $B$.", "outputFormat": "Lines $1 \\ldots N$: Line $i$ contains the maximum possible height of cow $i$.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO07JAN] Tallest Cow S", "background": null, "description": "FJ 的 $N$ 头奶牛（$1 \\le N \\le 10,000$）按编号 $1$ 到 $N$ 排成一行。每头奶牛有一个正整数表示的身高（这是个秘密）。现在你只知道最高奶牛的身高 $H$（$1 \\le H \\le 1,000,000$），以及它的编号 $I$。\n\nFJ 提供了 $R$ 条信息（$0 \\le R \\le 10,000$），每条信息形如“奶牛 17 能看到奶牛 34”。这意味着奶牛 34 的身高不小于奶牛 17 的身高，并且编号在 17 和 34 之间的所有奶牛，其身高都严格小于奶牛 17 的身高。\n\n现在请你计算出对于每一头奶牛（编号从 $1$ 到 $N$），在所有给定信息都成立的前提下，它可能具有的最大身高。\n\n题目保证一定存在满足条件的解。", "inputFormat": "第 $1$ 行：四个用空格分隔的整数：$N$，$I$，$H$ 和 $R$。\n\n第 $2$ 到第 $R+1$ 行：每行两个不同的整数 $A$ 和 $B$（$1 \\le A$, $B \\le N$），表示奶牛 $A$ 能看到奶牛 $B$。", "outputFormat": "共 $N$ 行，第 $i$ 行输出奶牛 $i$ 的最大可能身高。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2880", "type": "P", "difficulty": 3, "samples": [["6 3\n1\n7\n3\n4\n2\n5\n1 5\n4 6\n2 2", "6\n3\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2007", "线段树", "USACO", "树状数组", "ST 表"], "title": "[USACO07JAN] Balanced Lineup G", "background": null, "description": "每天，农夫 John 的 $n\\ (1\\le n\\le 5\\times 10^4)$ 头牛总是按同一序列排队。\n\n有一天，John 决定让一些牛们玩一场飞盘比赛。他准备找一群在队列中位置连续的牛来进行比赛。但是为了避免水平悬殊，牛的身高不应该相差太大。John 准备了 $q\\ (1\\le q\\le 1.8\\times10^5)$ 个可能的牛的选择和所有牛的身高 $h_i\\ (1\\le h_i\\le 10^6,1\\le i\\le n)$。他想知道每一组里面最高和最低的牛的身高差。", "inputFormat": "第一行两个数 $n,q$。\n\n接下来 $n$ 行，每行一个数 $h_i$。\n\n再接下来 $q$ 行，每行两个整数 $a$ 和 $b$，表示询问第 $a$ 头牛到第 $b$ 头牛里的最高和最低的牛的身高差。", "outputFormat": "输出共 $q$ 行，对于每一组询问，输出每一组中最高和最低的牛的身高差。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[USACO07JAN] Balanced Lineup G", "background": null, "description": "For the daily milking, Farmer John's $N$ cows ($1 \\le N \\le 5 \\times 10^4$) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height.\n\nFarmer John has made a list of $Q$ ($1 \\le Q \\le 1.8 \\times 10^5$) potential groups of cows and their heights ($1 \\le \\text{height} \\le 10^6$). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group.", "inputFormat": "Line $1$: Two space-separated integers, $N$ and $Q$.\n\nLines $2 \\dots N+1$: Line $i+1$ contains a single integer that is the height of cow $i$.\n\nLines $N+2 \\dots N+Q+1$: Two integers $A$ and $B$ ($1 \\le A \\le B \\le N$), representing the range of cows from $A$ to $B$ inclusive.", "outputFormat": "Lines $1 \\dots Q$: Each line contains a single integer that is a response to a reply and indicates the difference in height between the tallest and shortest cow in the range.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO07JAN] Balanced Lineup G", "background": null, "description": "每天，农夫 John 的 $n\\ (1\\le n\\le 5\\times 10^4)$ 头牛总是按同一序列排队。\n\n有一天，John 决定让一些牛们玩一场飞盘比赛。他准备找一群在队列中位置连续的牛来进行比赛。但是为了避免水平悬殊，牛的身高不应该相差太大。John 准备了 $q\\ (1\\le q\\le 1.8\\times10^5)$ 个可能的牛的选择和所有牛的身高 $h_i\\ (1\\le h_i\\le 10^6,1\\le i\\le n)$。他想知道每一组里面最高和最低的牛的身高差。", "inputFormat": "第一行两个数 $n,q$。\n\n接下来 $n$ 行，每行一个数 $h_i$。\n\n再接下来 $q$ 行，每行两个整数 $a$ 和 $b$，表示询问第 $a$ 头牛到第 $b$ 头牛里的最高和最低的牛的身高差。", "outputFormat": "输出共 $q$ 行，对于每一组询问，输出每一组中最高和最低的牛的身高差。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2881", "type": "P", "difficulty": 4, "samples": [["5 5\n2 1\n1 5\n2 3\n1 4\n3 4", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "USACO"], "title": "[USACO07MAR] Ranking the Cows G", "background": null, "description": "FJ 想按照奶牛产奶的能力给她们排序。现在已知有 $N$ 头奶牛（$1\\le N\\le {10}^3$）。FJ 通过比较，已经知道了 $M$（$1 \\le M \\le {10}^4$）对相对关系。每一对关系表示为 `X Y`，意指奶牛 $X$ 的产奶能力强于 $Y$。现在 FJ 想要知道，他至少还要知道多少对关系才能完成整个排序。", "inputFormat": "第一行，两个正整数 $N$ 和 $M$。\n\n以下 $M$ 行，每行两个正整数 $X$ 和 $Y$，表示第 $X$ 只奶牛的产奶能力强于第 $Y$ 只。", "outputFormat": "只输出一行，一个非负整数，表示至少还需要知道的关系对数。特别地，如果 FJ 已经可以知道所有奶牛的产奶能力排序，输出 `0`。", "hint": "### 样例解释\n\n我们用 $C_i$ 表示第 $i$ 头奶牛的产奶能力。\n\n根据给出的 $5$ 组关系，FJ 已经能知道 $C_2 > C_1 > C_5$ 且 $C_2 > C_3 > C_4$，因此第 $2$ 只奶牛的产奶能力最高。接着 FJ 需要知道 $C_1$ 和 $C_3$ 的大小关系才能知道哪只奶牛的产奶能力第二高。FJ 还需要知道 $C_4$ 和 $C_5$ 的大小关系和 $C_5$ 和 $C_3$ 的关系才能完全确定顺序。可以证明没有询问次数比 $3$ 次更少的方案了。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO07MAR] Ranking the Cows G", "background": "", "description": "Each of Farmer John's N cows (1 ≤ N ≤ 1,000) produces milk at a different positive rate, and FJ would like to order his cows according to these rates from the fastest milk producer to the slowest.\n\nFJ has already compared the milk output rate for M (1 ≤ M ≤ 10,000) pairs of cows. He wants to make a list of C additional pairs of cows such that, if he now compares those C pairs, he will definitely be able to deduce the correct ordering of all N cows. Please help him determine the minimum value of C for which such a list is possible.", "inputFormat": "Line 1: Two space-separated integers: N and M\n\n\nLines 2..M+1: Two space-separated integers, respectively: X and Y. Both X and Y are in the range 1...N and describe a comparison where cow X was ranked higher than cow Y.", "outputFormat": "Line 1: A single integer that is the minimum value of C.", "hint": "From the information in the 5 test results, Farmer John knows that since cow 2 > cow 1 > cow 5 and cow 2 > cow 3 > cow 4, cow 2 has the highest rank. However, he needs to know whether cow 1 > cow 3 to determine the cow with the second highest rank. Also, he will need one more question to determine the ordering between cow 4 and cow 5. After that, he will need to know if cow 5 > cow 3 if cow 1 has higher rank than cow 3. He will have to ask three questions in order to be sure he has the rankings: \"Is cow 1 > cow 3?  Is cow 4 > cow 5? Is cow 5 > cow 3?\"", "locale": "en"}, "zh-CN": {"title": "[USACO07MAR] Ranking the Cows G", "background": null, "description": "FJ 想按照奶牛产奶的能力给她们排序。现在已知有 $N$ 头奶牛（$1\\le N\\le {10}^3$）。FJ 通过比较，已经知道了 $M$（$1 \\le M \\le {10}^4$）对相对关系。每一对关系表示为 `X Y`，意指奶牛 $X$ 的产奶能力强于 $Y$。现在 FJ 想要知道，他至少还要知道多少对关系才能完成整个排序。", "inputFormat": "第一行，两个正整数 $N$ 和 $M$。\n\n以下 $M$ 行，每行两个正整数 $X$ 和 $Y$，表示第 $X$ 只奶牛的产奶能力强于第 $Y$ 只。", "outputFormat": "只输出一行，一个非负整数，表示至少还需要知道的关系对数。特别地，如果 FJ 已经可以知道所有奶牛的产奶能力排序，输出 `0`。", "hint": "### 样例解释\n\n我们用 $C_i$ 表示第 $i$ 头奶牛的产奶能力。\n\n根据给出的 $5$ 组关系，FJ 已经能知道 $C_2 > C_1 > C_5$ 且 $C_2 > C_3 > C_4$，因此第 $2$ 只奶牛的产奶能力最高。接着 FJ 需要知道 $C_1$ 和 $C_3$ 的大小关系才能知道哪只奶牛的产奶能力第二高。FJ 还需要知道 $C_4$ 和 $C_5$ 的大小关系和 $C_5$ 和 $C_3$ 的关系才能完全确定顺序。可以证明没有询问次数比 $3$ 次更少的方案了。", "locale": "zh-CN"}}}
{"pid": "P2882", "type": "P", "difficulty": 4, "samples": [["7\nB\nB\nF\nB\nF\nB\nB", "3 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2007", "USACO", "枚举", "差分"], "title": "[USACO07MAR] Face The Right Way G", "background": null, "description": "$N$ 头牛排成一列。每头牛要么向前要么向后。为了让所有牛都面向前方，农夫每次可以将 $K$ 头连续的牛转向（$1 \\le K \\le N$），求最小的操作次数 $M$ 和相应的最小 $K$。", "inputFormat": "第一行一个正整数 $N$。\n\n下面 $N$ 行，每行一个字符 `F` 或 `B`，表示一头奶牛的初始朝向。（`F` 为朝前，`B` 为朝后）", "outputFormat": "请在一行输出两个数字 $K$ 和 $M$，用空格分开。", "hint": "样例解释：$K=3$，$M=3$，$3$ 次操作分别让奶牛 $1/2/3,\\ \\ 3/4/5,\\ \\ 5/6/7$ 转向。\n\n\n---\n\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 5000$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO07MAR] Face The Right Way G", "background": null, "description": "Farmer John has arranged his N (1 ≤ N ≤ 5,000) cows in a row and many of them are facing forward, like good cows. Some of them are facing backward, though, and he needs them all to face forward to make his life perfect.\n\nFortunately, FJ recently bought an automatic cow turning machine. Since he purchased the discount model, it must be irrevocably preset to turn K (1 ≤ K ≤ N) cows at once, and it can only turn cows that are all standing next to each other in line. Each time the machine is used, it reverses the facing direction of a contiguous group of K cows in the line (one cannot use it on fewer than K cows, e.g., at the either end of the line of cows). Each cow remains in the same *location* as before, but ends up facing the *opposite direction*. A cow that starts out facing forward will be turned backward by the machine and vice-versa.\n\nBecause FJ must pick a single, never-changing value of K, please help him determine the minimum value of K that minimizes the number of operations required by the machine to make all the cows face forward. Also determine M, the minimum number of machine operations required to get all the cows facing forward using that value of K.", "inputFormat": "Line 1: A single integer: N\n\nLines 2..N+1: Line i+1 contains a single character, F or B, indicating whether cow i is facing forward or backward.", "outputFormat": "Line 1: Two space-separated integers: K and M", "hint": "For K = 3, the machine must be operated three times: turn cows (1,2,3), (3,4,5), and finally (5,6,7)", "locale": "en"}, "zh-CN": {"title": "[USACO07MAR] Face The Right Way G", "background": null, "description": "$N$ 头牛排成一列。每头牛要么向前要么向后。为了让所有牛都面向前方，农夫每次可以将 $K$ 头连续的牛转向（$1 \\le K \\le N$），求最小的操作次数 $M$ 和相应的最小 $K$。", "inputFormat": "第一行一个正整数 $N$。\n\n下面 $N$ 行，每行一个字符 `F` 或 `B`，表示一头奶牛的初始朝向。（`F` 为朝前，`B` 为朝后）", "outputFormat": "请在一行输出两个数字 $K$ 和 $M$，用空格分开。", "hint": "样例解释：$K=3$，$M=3$，$3$ 次操作分别让奶牛 $1/2/3,\\ \\ 3/4/5,\\ \\ 5/6/7$ 转向。\n\n\n---\n\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 5000$。", "locale": "zh-CN"}}}
{"pid": "P2883", "type": "P", "difficulty": 3, "samples": [["7 7\n1 3\n3 4\n3 5\n4 6\n2 3\n5 6\n6 7", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2007", "USACO", "深度优先搜索 DFS", "拓扑排序"], "title": "[USACO07MAR] Cow Traffic S", "background": null, "description": "随着牛的数量增加，农场的道路的拥挤现象十分严重，特别是在每天晚上的挤奶时间。为了解决这个问题，FJ 决定研究这个问题，以能找到导致拥堵现象的瓶颈所在。\n\n\n牧场共有 $M$ 条单向道路，每条道路连接着两个不同的交叉路口，为了方便研究，FJ 将这些交叉路口编号为 $1\\sim N$，而牛圈位于交叉路口 $N$。任意一条单向道路的方向一定是是从编号低的路口到编号高的路口，因此农场中不会有环型路径。同时，可能存在某两个交叉路口不止一条单向道路径连接的情况。\n\n\n在挤奶时间到来的时候，奶牛们开始从各自的放牧地点回到牛圈。放牧地点是指那些没有道路连接进来的路口（入度为 $0$ 的顶点）。\n\n\n现在请你帮助 FJ 通过计算从放牧点到达牛圈的路径数目来找到最繁忙的道路，即求出所有可行路径中通过某条道路的路径数的最大值。保证答案不会超过 32 位有符号整数的范围。", "inputFormat": "第一行两个正整数 $N,M$。\n\n下面 $M$ 行，每行两个正整数 $U_i,V_i$，表示一条有向道路 $U_i \\to V_i$。", "outputFormat": "一行一个整数表示答案。", "hint": "样例解释：\n\n最繁忙的道路是 $6\\to 7$，四条经过这条边的路径如下。\n\n```plain\n1 -> 3 -> 4 -> 6 -> 7\n1 -> 3 -> 5 -> 6 -> 7\n2 -> 3 -> 4 -> 6 -> 7\n2 -> 3 -> 5 -> 6 -> 7\n```\n\n\n---\n\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 5 \\times 10^3$，$1 \\le M \\le 5 \\times 10^4$，$1 \\le U_i,V_i \\le N$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO07MAR] Cow Traffic S", "background": null, "description": "The bovine population boom down on the farm has caused serious congestion on the cow trails leading to the barn. Farmer John has decided to conduct a study to find the bottlenecks in order to relieve the 'traffic jams' at milking time.\n\nThe pasture contains a network of M (1 ≤ M ≤ 50,000) one-way trails, each of which connects exactly two different intersections from the set of N (1 ≤ N ≤ 5,000) intersections conveniently numbered 1..N; the barn is at intersection number N. Each trail connects one intersection point to another intersection point with a higher number. As a result, there are no cycles and, as they say on the farm, all trails lead to the barn. A pair of intersection points might be connected by more than one trail.\n\nDuring milking time rush hour, the cows start from their respective grazing locations and head to the barn. The grazing locations are exactly those intersection points with no trails connecting into them. Each cow traverses a 'path', which is defined as a sequence of trails from a grazing location to the barn.\n\nHelp FJ finding the busiest trail(s) by computing the largest number of possible paths that contain any one trail. The answer is guaranteed to fit in a signed 32-bit integer.", "inputFormat": "Line 1: Two space-separated integers: N and M.\n\nLines 2..M+1: Two space-separated intersection points.", "outputFormat": "Line 1: The maximum number of paths passing through any one trail.", "hint": "Here are the four possible paths that lead to the barn:\n\n1 3 4 6 7\n\n1 3 5 6 7\n\n2 3 4 6 7\n\n2 3 5 6 7", "locale": "en"}, "zh-CN": {"title": "[USACO07MAR] Cow Traffic S", "background": null, "description": "随着牛的数量增加，农场的道路的拥挤现象十分严重，特别是在每天晚上的挤奶时间。为了解决这个问题，FJ 决定研究这个问题，以能找到导致拥堵现象的瓶颈所在。\n\n\n牧场共有 $M$ 条单向道路，每条道路连接着两个不同的交叉路口，为了方便研究，FJ 将这些交叉路口编号为 $1\\sim N$，而牛圈位于交叉路口 $N$。任意一条单向道路的方向一定是是从编号低的路口到编号高的路口，因此农场中不会有环型路径。同时，可能存在某两个交叉路口不止一条单向道路径连接的情况。\n\n\n在挤奶时间到来的时候，奶牛们开始从各自的放牧地点回到牛圈。放牧地点是指那些没有道路连接进来的路口（入度为 $0$ 的顶点）。\n\n\n现在请你帮助 FJ 通过计算从放牧点到达牛圈的路径数目来找到最繁忙的道路，即求出所有可行路径中通过某条道路的路径数的最大值。保证答案不会超过 32 位有符号整数的范围。", "inputFormat": "第一行两个正整数 $N,M$。\n\n下面 $M$ 行，每行两个正整数 $U_i,V_i$，表示一条有向道路 $U_i \\to V_i$。", "outputFormat": "一行一个整数表示答案。", "hint": "样例解释：\n\n最繁忙的道路是 $6\\to 7$，四条经过这条边的路径如下。\n\n```plain\n1 -> 3 -> 4 -> 6 -> 7\n1 -> 3 -> 5 -> 6 -> 7\n2 -> 3 -> 4 -> 6 -> 7\n2 -> 3 -> 5 -> 6 -> 7\n```\n\n\n---\n\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 5 \\times 10^3$，$1 \\le M \\le 5 \\times 10^4$，$1 \\le U_i,V_i \\le N$。", "locale": "zh-CN"}}}
{"pid": "P2884", "type": "P", "difficulty": 3, "samples": [["7 5\n100\n400\n300\n100\n500\n101\n400", "500"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "USACO"], "title": "[USACO07MAR] Monthly Expense S", "background": null, "description": "给定一个 $n$ 项的正整数序列 $\\{a_n\\}$，请找出满足以下条件的最小的正整数 $S$：存在一种将 $\\{a_n\\}$ 划分成 $m$ 段的方案，使得每一段中所有数字的和都不大于 $S$。", "inputFormat": "第一行两个正整数 $n,m$。\n\n下面 $n$ 行，每行一个正整数 $a_i$。", "outputFormat": "一行一个正整数表示答案。", "hint": "样例解释：$\\{100,400\\},\\{300,100\\},\\{500\\},\\{101\\},\\{400\\}$ 是一种合法的划分方案。\n\n---\n\n对于 $100\\%$ 的数据，$1 \\le m \\le n \\le 10^5$，$1 \\le a_i \\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO07MAR] Monthly Expense S", "background": null, "description": "Farmer John is an astounding accounting wizard and has realized he might run out of money to run the farm. He has already calculated and recorded the exact amount of money (1 ≤ moneyi ≤ 10,000) that he will need to spend each day over the next N (1 ≤ N ≤ 100,000) days.\n\nFJ wants to create a budget for a sequential set of exactly M (1 ≤ M ≤ N) fiscal periods called \"fajomonths\". Each of these fajomonths contains a set of 1 or more consecutive days. Every day is contained in exactly one fajomonth.\n\nFJ's goal is to arrange the fajomonths so as to minimize the expenses of the fajomonth with the highest spending and thus determine his monthly spending limit.", "inputFormat": "Line 1: Two space-separated integers: N and M\n\nLines 2..N+1: Line i+1 contains the number of dollars Farmer John spends on the ith day", "outputFormat": "Line 1: The smallest possible monthly limit Farmer John can afford to live with.", "hint": "If Farmer John schedules the months so that the first two days are a month, the third and fourth are a month, and the last three are their own months, he spends at most $500 in any month. Any other method of scheduling gives a larger minimum monthly limit.", "locale": "en"}, "zh-CN": {"title": "[USACO07MAR] Monthly Expense S", "background": null, "description": "给定一个 $n$ 项的正整数序列 $\\{a_n\\}$，请找出满足以下条件的最小的正整数 $S$：存在一种将 $\\{a_n\\}$ 划分成 $m$ 段的方案，使得每一段中所有数字的和都不大于 $S$。", "inputFormat": "第一行两个正整数 $n,m$。\n\n下面 $n$ 行，每行一个正整数 $a_i$。", "outputFormat": "一行一个正整数表示答案。", "hint": "样例解释：$\\{100,400\\},\\{300,100\\},\\{500\\},\\{101\\},\\{400\\}$ 是一种合法的划分方案。\n\n---\n\n对于 $100\\%$ 的数据，$1 \\le m \\le n \\le 10^5$，$1 \\le a_i \\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P2885", "type": "P", "difficulty": 5, "samples": [["5 2\n2\n3\n5\n1\n4", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2007", "USACO", "单调队列"], "title": "[USACO07NOV] Telephone Wire G", "background": "", "description": "Farmer John's cows are getting restless about their poor telephone service; they want FJ to replace the old telephone wire with new, more efficient wire. The new wiring will utilize N (2 ≤ N ≤ 100,000) already-installed telephone poles, each with some heighti meters (1 ≤ heighti ≤ 100). The new wire will connect the tops of each pair of adjacent poles and will incur a penalty cost C × the two poles' height difference for each section of wire where the poles are of different heights (1 ≤ C ≤ 100). The poles, of course, are in a certain sequence and can not be moved.\n\nFarmer John figures that if he makes some poles taller he can reduce his penalties, though with some other additional cost. He can add an integer X number of meters to a pole at a cost of X2.\n\nHelp Farmer John determine the cheapest combination of growing pole heights and connecting wire so that the cows can get their new and improved service.", "inputFormat": "* Line 1: Two space-separated integers: N and C\n\n* Lines 2..N+1: Line i+1 contains a single integer: heighti", "outputFormat": "* Line 1: The minimum total amount of money that it will cost Farmer John to attach the new telephone wire.", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO07NOV] Telephone Wire G", "background": "", "description": "Farmer John's cows are getting restless about their poor telephone service; they want FJ to replace the old telephone wire with new, more efficient wire. The new wiring will utilize N (2 ≤ N ≤ 100,000) already-installed telephone poles, each with some heighti meters (1 ≤ heighti ≤ 100). The new wire will connect the tops of each pair of adjacent poles and will incur a penalty cost C × the two poles' height difference for each section of wire where the poles are of different heights (1 ≤ C ≤ 100). The poles, of course, are in a certain sequence and can not be moved.\n\nFarmer John figures that if he makes some poles taller he can reduce his penalties, though with some other additional cost. He can add an integer X number of meters to a pole at a cost of X2.\n\nHelp Farmer John determine the cheapest combination of growing pole heights and connecting wire so that the cows can get their new and improved service.", "inputFormat": "* Line 1: Two space-separated integers: N and C\n\n* Lines 2..N+1: Line i+1 contains a single integer: heighti", "outputFormat": "* Line 1: The minimum total amount of money that it will cost Farmer John to attach the new telephone wire.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO07NOV] Telephone Wire G", "background": null, "description": "农夫约翰的奶牛们对她们那糟糕的电话服务感到不安。她们想让 FJ 用更高效的新电话线代替旧的。新电话线将利用 $n$ 个已经安装好的电话杆，每一个电话杆高 $h_i$ 米。新电话线将连接每对相邻电线杆的顶部，当相邻两根电线杆 $i$ 与 $i + 1$ 的高度不同时，新电话线会产生 $c \\times \\lvert h_i - h_{i + 1} \\rvert$ 的成本。电线杆的顺序是固定的，不能移动。\n\n农夫约翰发现，他可以通过提高某些电线杆的高度来减少成本。他可以花费 $x^2$ 的成本将第 $i$ 根电线杆提高 $x$ 米。\n\n请你帮助农夫约翰确定只提高高度和连接电线最便宜的方案使得奶牛们用上更好的电话服务。", "inputFormat": "第一行包含两个整数 $n, c$，相邻的整数之间使用一个空格分隔。\n\n接下来 $n$ 行，第 $i$ 行包含一个整数 $h_i$。", "outputFormat": "一个整数，表示农夫约翰安装新电话线所花费的最少金额。", "hint": "对于 $100\\%$ 的数据，$2 \\le n \\le 100000$，$1 \\le c, h_i \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P2886", "type": "P", "difficulty": 4, "samples": [["2 6 6 4\n11 4 6\n4 4 8\n8 4 9\n6 6 8\n2 6 9\n3 8 9", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2007", "USACO", "最短路", "矩阵乘法"], "title": "[USACO07NOV] Cow Relays G", "background": "", "description": "For their physical fitness program, N (2 ≤ N ≤ 1,000,000) cows have decided to run a relay race using the T (2 ≤ T ≤ 100) cow trails throughout the pasture.\n\nEach trail connects two different intersections (1 ≤ I1i ≤ 1,000; 1 ≤ I2i ≤ 1,000), each of which is the termination for at least two trails. The cows know the lengthi of each trail (1 ≤ lengthi  ≤ 1,000), the two intersections the trail connects, and they know that no two intersections are directly connected by two different trails. The trails form a structure known mathematically as a graph.\n\nTo run the relay, the N cows position themselves at various intersections (some intersections might have more than one cow). They must position themselves properly so that they can hand off the baton cow-by-cow and end up at the proper finishing place.\n\nWrite a program to help position the cows. Find the shortest path that connects the starting intersection (S) and the ending intersection (E) and traverses exactly N cow trails.\n\n给出一张无向连通图，求S到E经过k条边的最短路。\n", "inputFormat": "\\* Line 1: Four space-separated integers: N, T, S, and E\n\n\\* Lines 2..T+1: Line i+1 describes trail i with three space-separated integers: lengthi , I1i , and I2i\n", "outputFormat": "\\* Line 1: A single integer that is the shortest distance from intersection S to intersection E that traverses exactly N cow trails.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO07NOV] Cow Relays G", "background": "", "description": "For their physical fitness program, N (2 ≤ N ≤ 1,000,000) cows have decided to run a relay race using the T (2 ≤ T ≤ 100) cow trails throughout the pasture.\n\nEach trail connects two different intersections (1 ≤ I1i ≤ 1,000; 1 ≤ I2i ≤ 1,000), each of which is the termination for at least two trails. The cows know the lengthi of each trail (1 ≤ lengthi  ≤ 1,000), the two intersections the trail connects, and they know that no two intersections are directly connected by two different trails. The trails form a structure known mathematically as a graph.\n\nTo run the relay, the N cows position themselves at various intersections (some intersections might have more than one cow). They must position themselves properly so that they can hand off the baton cow-by-cow and end up at the proper finishing place.\n\nWrite a program to help position the cows. Find the shortest path that connects the starting intersection (S) and the ending intersection (E) and traverses exactly N cow trails.\n\n给出一张无向连通图，求S到E经过k条边的最短路。\n", "inputFormat": "\\* Line 1: Four space-separated integers: N, T, S, and E\n\n\\* Lines 2..T+1: Line i+1 describes trail i with three space-separated integers: lengthi , I1i , and I2i\n", "outputFormat": "\\* Line 1: A single integer that is the shortest distance from intersection S to intersection E that traverses exactly N cow trails.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO07NOV] Cow Relays G", "background": null, "description": "给定一张 $T$ 条边的无向连通图，求从 $S$ 到 $E$ 经过 $N$ 条边的最短路长度。", "inputFormat": "第一行四个正整数 $N,T,S,E$ ，意义如题面所示。\n\n接下来 $T$ 行每行三个正整数 $w,u,v$ ，分别表示路径的长度，起点和终点。", "outputFormat": "一行一个整数表示图中从 $S$ 到 $E$ 经过 $N$ 条边的最短路长度。", "hint": "对于所有的数据，保证 $1\\le N\\le 10^6$，$2\\le T\\le 100$。\n\n所有的边保证 $1\\le u,v\\le 1000$，$1\\le w\\le 1000$ 且不存在重边，自环。\n\n所有的顶点保证至少连接两条边。", "locale": "zh-CN"}}}
{"pid": "P2887", "type": "P", "difficulty": 3, "samples": [["3 2\n3 10\n2 5\n1 5\n6 2\n4 1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "贪心", "2007", "USACO"], "title": "[USACO07NOV] Sunscreen G", "background": null, "description": "有 $C$ 头奶牛进行日光浴，第 $i$ 头奶牛需要 $minSPF[i]$ 到 $maxSPF[i]$ 单位强度之间的阳光。\n\n每头奶牛在日光浴前必须涂防晒霜，防晒霜有 $L$ 种，涂上第 $i$ 种之后，身体接收到的阳光强度就会稳定为 $SPF[i]$，第 $i$ 种防晒霜有 $cover[i]$ 瓶。\n\n求最多可以满足多少头奶牛进行日光浴。", "inputFormat": "第一行输入整数 $C$ 和 $L$。\n\n接下来的 $C$ 行，按次序每行输入一头牛的 $minSPF$ 和 $maxSPF$ 值，即第 $i$ 行输入 $minSPF[i]$ 和 $maxSPF[i]$。\n\n再接下来的 $L$ 行，按次序每行输入一种防晒霜的 $SPF$ 和 $cover$ 值，即第 $i$ 行输入 $SPF[i]$ 和 $cover[i]$。\n\n每行的数据之间用空格隔开。", "outputFormat": "输出一个整数，代表最多可以满足奶牛日光浴的奶牛数目。", "hint": "样例解释：给第一头奶牛涂第一种防晒霜，第二头奶牛涂第二种防晒霜。\n\n\n---\n\n\n对于 $100\\%$ 的数据，$1\\le C,L\\le 2500$，$1\\le minSPF[i]\\le maxSPF[i]\\le 1000$，$1\\le SPF[i]\\le 1000$，$1\\le cover[i]\\le 2500$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO07NOV] Sunscreen G", "background": null, "description": "To avoid unsightly burns while tanning, each of the C (1 ≤ C ≤ 2500) cows must cover her hide with sunscreen when they're at the beach. Cow i has a minimum and maximum SPF rating (1 ≤ minSPFi ≤ 1,000; minSPFi ≤ maxSPFi ≤ 1,000) that will work. If the SPF rating is too low, the cow suffers sunburn; if the SPF rating is too high, the cow doesn't tan at all........\n\nThe cows have a picnic basket with L (1 ≤ L ≤ 2500) bottles of sunscreen lotion, each bottle i with an SPF rating SPFi (1 ≤ SPFi ≤ 1,000). Lotion bottle i can cover coveri cows with lotion. A cow may lotion from only one bottle.\n\nWhat is the maximum number of cows that can protect themselves while tanning given the available lotions?", "inputFormat": "* Line 1: Two space-separated integers: C and L\n\n* Lines 2..C+1: Line i describes cow i's lotion requires with two integers: minSPFi and maxSPFi\n\n* Lines C+2..C+L+1: Line i+C+1 describes a sunscreen lotion bottle i with space-separated integers: SPFi and coveri", "outputFormat": "A single line with an integer that is the maximum number of cows that can be protected while tanning", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO07NOV] Sunscreen G", "background": null, "description": "有 $C$ 头奶牛进行日光浴，第 $i$ 头奶牛需要 $minSPF[i]$ 到 $maxSPF[i]$ 单位强度之间的阳光。\n\n每头奶牛在日光浴前必须涂防晒霜，防晒霜有 $L$ 种，涂上第 $i$ 种之后，身体接收到的阳光强度就会稳定为 $SPF[i]$，第 $i$ 种防晒霜有 $cover[i]$ 瓶。\n\n求最多可以满足多少头奶牛进行日光浴。", "inputFormat": "第一行输入整数 $C$ 和 $L$。\n\n接下来的 $C$ 行，按次序每行输入一头牛的 $minSPF$ 和 $maxSPF$ 值，即第 $i$ 行输入 $minSPF[i]$ 和 $maxSPF[i]$。\n\n再接下来的 $L$ 行，按次序每行输入一种防晒霜的 $SPF$ 和 $cover$ 值，即第 $i$ 行输入 $SPF[i]$ 和 $cover[i]$。\n\n每行的数据之间用空格隔开。", "outputFormat": "输出一个整数，代表最多可以满足奶牛日光浴的奶牛数目。", "hint": "样例解释：给第一头奶牛涂第一种防晒霜，第二头奶牛涂第二种防晒霜。\n\n\n---\n\n\n对于 $100\\%$ 的数据，$1\\le C,L\\le 2500$，$1\\le minSPF[i]\\le maxSPF[i]\\le 1000$，$1\\le SPF[i]\\le 1000$，$1\\le cover[i]\\le 2500$。", "locale": "zh-CN"}}}
{"pid": "P2888", "type": "P", "difficulty": 3, "samples": [["5 6 3\n1 2 12\n3 2 8\n1 3 5\n2 5 3\n3 4 4\n2 4 8\n3 4\n1 2\n5 1\n", "4\n8\n-1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "USACO", "最短路"], "title": "[USACO07NOV] Cow Hurdles S", "background": null, "description": "Farmer John 想让她的奶牛准备郡级跳跃比赛，Bessie 和她的伙伴们正在练习跨栏。她们很累，所以她们想消耗最少的能量来跨栏。 显然，对于一头奶牛跳过几个矮栏是很容易的，但是高栏却很难。于是，奶牛们总是关心路径上最高的栏的高度。 \n\n奶牛的训练场中有 $N$ 个站台，分别标记为 $1,\\dots,N$。所有站台之间有 $M$ 条单向路径，第 $i$ 条路经是从站台 $S_i$ 开始，到站台 $E_i$，其中最高的栏的高度为 $H_i$。无论如何跑，奶牛们都要跨栏。 \n\n奶牛们有 $T$ 个训练任务要完成。第 $i$ 个任务包含两个数字 $A_i$ 和 $B_i$，表示奶牛必须从站台 $A_i$ 跑到站台 $B_i$，可以路过别的站台。奶牛们想找一条路径从站台 $A_i$ 到站台 $B_i$，使路径上最高的栏的高度最小。 你的任务就是写一个程序，计算出路径上最高的栏的高度的最小值。", "inputFormat": "第一行：三个空格隔开的整数 $N, M, T$。\n\n接下来 $M$ 行：第 $i$ 行包含三个空格隔开的整数 $S_i, E_i, H_i$。\n\n接下来 $T$ 行：第 $i$ 行包含两个空格隔开的整数，表示任务 $i$ 的起始站台和目标站台 $A_i, B_i$。", "outputFormat": "$T$ 行：第 $i$ 行为一个整数，表示任务 $i$ 路径上最高的栏的高度的最小值。如果无法到达，输出 `-1`。", "hint": "对于 $100\\%$ 的数据，$1 \\le N \\le 300$，$1 \\le M \\le 2.5 \\times 10^4$，$1 \\le H_i \\le 1 \\times 10^6$，$1 \\le T \\le 4 \\times 10^4$，$1 \\le A_i,B_i \\le N$。\n\n感谢 @gaozhiyong @_Cppsteve_ 提供翻译", "locale": "zh-CN", "translations": {"en": {"title": "[USACO07NOV] Cow Hurdles S", "background": null, "description": "Farmer John wants the cows to prepare for the county jumping competition, so Bessie and the gang are practicing jumping over hurdles. They are getting tired, though, so they want to be able to use as little energy as possible to jump over the hurdles.\n\nObviously, it is not very difficult for a cow to jump over several very short hurdles, but one tall hurdle can be very stressful. Thus, the cows are only concerned about the height of the tallest hurdle they have to jump over.\n\nThe cows' practice room has $N$ stations, conveniently labeled $1,\\dots,N$. A set of $M$ one-way paths connects pairs of stations; the paths are also conveniently labeled $1,\\dots,M$. Path $i$ travels from station $S_i$ to station $E_i$ and contains exactly one hurdle of height $H_i$. Cows must jump hurdles in any path they traverse.\n\nThe cows have $T$ tasks to complete. Task $i$ comprises two distinct numbers, $A_i$ and $B_i$, which connote that a cow has to travel from station $A_i$ to station $B_i$ (by traversing over one or more paths over some route). The cows want to take a path the minimizes the height of the tallest hurdle they jump over when traveling from $A_i$ to $B_i$ . Your job is to write a program that determines the path whose tallest hurdle is smallest and report that height.", "inputFormat": "\\* Line $1$: Three space-separated integers: $N$, $M$, and $T$\n\n\\* Lines $2,\\dots,M+1$: Line $i+1$ contains three space-separated integers: $S_i$ , $E_i$ , and $H_i$\n\n\\* Lines $M+2,\\dots,M+T+1$: Line $i+M+1$ contains two space-separated integers that describe task $i$: $A_i$ and $B_i$", "outputFormat": "\\* Lines $1,\\dots,T$: Line $i$ contains the result for task $i$ and tells the smallest possible maximum height necessary to travel between the stations. Output `-1` if it is impossible to travel between the two stations.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO07NOV] Cow Hurdles S", "background": null, "description": "Farmer John 想让她的奶牛准备郡级跳跃比赛，Bessie 和她的伙伴们正在练习跨栏。她们很累，所以她们想消耗最少的能量来跨栏。 显然，对于一头奶牛跳过几个矮栏是很容易的，但是高栏却很难。于是，奶牛们总是关心路径上最高的栏的高度。 \n\n奶牛的训练场中有 $N$ 个站台，分别标记为 $1,\\dots,N$。所有站台之间有 $M$ 条单向路径，第 $i$ 条路经是从站台 $S_i$ 开始，到站台 $E_i$，其中最高的栏的高度为 $H_i$。无论如何跑，奶牛们都要跨栏。 \n\n奶牛们有 $T$ 个训练任务要完成。第 $i$ 个任务包含两个数字 $A_i$ 和 $B_i$，表示奶牛必须从站台 $A_i$ 跑到站台 $B_i$，可以路过别的站台。奶牛们想找一条路径从站台 $A_i$ 到站台 $B_i$，使路径上最高的栏的高度最小。 你的任务就是写一个程序，计算出路径上最高的栏的高度的最小值。", "inputFormat": "第一行：三个空格隔开的整数 $N, M, T$。\n\n接下来 $M$ 行：第 $i$ 行包含三个空格隔开的整数 $S_i, E_i, H_i$。\n\n接下来 $T$ 行：第 $i$ 行包含两个空格隔开的整数，表示任务 $i$ 的起始站台和目标站台 $A_i, B_i$。", "outputFormat": "$T$ 行：第 $i$ 行为一个整数，表示任务 $i$ 路径上最高的栏的高度的最小值。如果无法到达，输出 `-1`。", "hint": "对于 $100\\%$ 的数据，$1 \\le N \\le 300$，$1 \\le M \\le 2.5 \\times 10^4$，$1 \\le H_i \\le 1 \\times 10^6$，$1 \\le T \\le 4 \\times 10^4$，$1 \\le A_i,B_i \\le N$。\n\n感谢 @gaozhiyong @_Cppsteve_ 提供翻译", "locale": "zh-CN"}}}
{"pid": "P2889", "type": "P", "difficulty": 3, "samples": [["12 4 2\n1 2 8\n10 12 19\n3 6 24\n7 10 31", "43"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2007", "USACO", "排序", "背包 DP"], "title": "[USACO07NOV] Milking Time S", "background": "", "description": "Bessie 可以在接下来 $N$ 个小时内产奶，为了方便，我们把这 $N$ 个小时 $1\\dots N$ 编号。\n\nFJ 在这 $N$ 个小时内有 $M$ 段时间可以来给 Bessie 挤奶，第 $i$ 段时间从 $Start_i$ 开始到 $End_i$ 结束，可以得到 $Eff_i$ 加仑牛奶。\n\n每次 FJ 给 Bessie 挤奶之后，Bessie 都要休息 $R$ 个小时，FJ 才能开始下一次挤奶。\n\n现在，FJ 需要您计算出 Bessie 在这 $N$ 个小时内最多产多少奶。", "inputFormat": "第一行有三个整数，分别表示 $N,M,R$。\n\n第 $2\\dots M+1$ 行，第 $i+1$ 行有三个整数 $Start_i,End_i,Eff_i$，描述一段挤奶的时间。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n对于全部的测试点，保证 $1\\le N\\le 10^6$，$1\\le M\\le 10^3$，$1\\le Start_i<end_i\\le N$，$1\\le Eff_i\\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO07NOV] Milking Time S", "background": "", "description": "Bessie can produce milk in the next $N$ hours. For convenience, we number these $N$ hours $1 \\dots N$.\n\nWithin these $N$ hours, FJ has $M$ intervals during which he can milk Bessie. The $i$-th interval runs from $Start_i$ to $End_i$ and yields $Eff_i$ gallons of milk.\n\nAfter each milking, Bessie must rest for $R$ hours before FJ can start the next milking.\n\nNow, FJ needs you to compute the maximum total milk Bessie can produce within these $N$ hours.", "inputFormat": "The first line contains three integers, representing $N$, $M$, and $R$.\n\nLines $2 \\dots M+1$: the $(i+1)$-th line contains three integers $Start_i$, $End_i$, and $Eff_i$, describing one milking interval.", "outputFormat": "Output a single integer on one line: the answer.", "hint": "#### Constraints\nFor all testdata, it is guaranteed that $1 \\le N \\le 10^6$, $1 \\le M \\le 10^3$, $1 \\le Start_i < End_i \\le N$, and $1 \\le Eff_i \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO07NOV] Milking Time S", "background": "", "description": "Bessie 可以在接下来 $N$ 个小时内产奶，为了方便，我们把这 $N$ 个小时 $1\\dots N$ 编号。\n\nFJ 在这 $N$ 个小时内有 $M$ 段时间可以来给 Bessie 挤奶，第 $i$ 段时间从 $Start_i$ 开始到 $End_i$ 结束，可以得到 $Eff_i$ 加仑牛奶。\n\n每次 FJ 给 Bessie 挤奶之后，Bessie 都要休息 $R$ 个小时，FJ 才能开始下一次挤奶。\n\n现在，FJ 需要您计算出 Bessie 在这 $N$ 个小时内最多产多少奶。", "inputFormat": "第一行有三个整数，分别表示 $N,M,R$。\n\n第 $2\\dots M+1$ 行，第 $i+1$ 行有三个整数 $Start_i,End_i,Eff_i$，描述一段挤奶的时间。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n对于全部的测试点，保证 $1\\le N\\le 10^6$，$1\\le M\\le 10^3$，$1\\le Start_i<end_i\\le N$，$1\\le Eff_i\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P2890", "type": "P", "difficulty": 4, "samples": [["3 4\nabcb\na 1000 1100\nb 350 700\nc 200 800\n", "900\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "递推", "2007", "USACO", "区间 DP"], "title": "[USACO07OPEN] Cheapest Palindrome G", "background": "", "description": "Keeping track of all the cows can be a tricky task so Farmer John has installed a system to automate it. He has installed on each cow an electronic ID tag that the system will read as the cows pass by a scanner. Each ID tag's contents are currently a single string with length M (1 ≤ M ≤ 2,000) characters drawn from an alphabet of N (1 ≤ N ≤ 26) different symbols (namely, the lower-case roman alphabet).\n\nCows, being the mischievous creatures they are, sometimes try to spoof the system by walking backwards. While a cow whose ID is \"abcba\" would read the same no matter which direction the she walks, a cow with the ID \"abcb\" can potentially register as two different IDs (\"abcb\" and \"bcba\").\n\nFJ would like to change the cows's ID tags so they read the same no matter which direction the cow walks by. For example, \"abcb\" can be changed by adding \"a\" at the end to form \"abcba\" so that the ID is palindromic (reads the same forwards and backwards). Some other ways to change the ID to be palindromic are include adding the three letters \"bcb\" to the begining to yield the ID \"bcbabcb\" or removing the letter \"a\" to yield the ID \"bcb\". One can add or remove characters at any location in the string yielding a string longer or shorter than the original string.\n\nUnfortunately as the ID tags are electronic, each character insertion or deletion has a cost (0 ≤ cost ≤ 10,000) which varies depending on exactly which character value to be added or deleted. Given the content of a cow's ID tag and the cost of inserting or deleting each of the alphabet's characters, find the minimum cost to change the ID tag so it satisfies FJ's requirements. An empty ID tag is considered to satisfy the requirements of reading the same forward and backward. Only letters with associated costs can be added to a string.\n", "inputFormat": "Line 1: Two space-separated integers: N and M\n\n\nLine 2: This line contains exactly M characters which constitute the initial ID string\n\n\nLines 3..N+2: Each line contains three space-separated entities: a character of the input alphabet and two integers which are respectively the cost of adding and deleting that character.\n", "outputFormat": "Line 1: A single line with a single integer that is the minimum cost to change the given name tag.\n", "hint": "If we insert an \"a\" on the end to get \"abcba\", the cost would be 1000. If we delete the \"a\" on the beginning to get \"bcb\", the cost would be 1100. If we insert \"bcb\" at the begining of the string, the cost would be 350 + 200 + 350 = 900, which is the minimum.\n", "locale": "en", "translations": {"en": {"title": "[USACO07OPEN] Cheapest Palindrome G", "background": "", "description": "Keeping track of all the cows can be a tricky task so Farmer John has installed a system to automate it. He has installed on each cow an electronic ID tag that the system will read as the cows pass by a scanner. Each ID tag's contents are currently a single string with length M (1 ≤ M ≤ 2,000) characters drawn from an alphabet of N (1 ≤ N ≤ 26) different symbols (namely, the lower-case roman alphabet).\n\nCows, being the mischievous creatures they are, sometimes try to spoof the system by walking backwards. While a cow whose ID is \"abcba\" would read the same no matter which direction the she walks, a cow with the ID \"abcb\" can potentially register as two different IDs (\"abcb\" and \"bcba\").\n\nFJ would like to change the cows's ID tags so they read the same no matter which direction the cow walks by. For example, \"abcb\" can be changed by adding \"a\" at the end to form \"abcba\" so that the ID is palindromic (reads the same forwards and backwards). Some other ways to change the ID to be palindromic are include adding the three letters \"bcb\" to the begining to yield the ID \"bcbabcb\" or removing the letter \"a\" to yield the ID \"bcb\". One can add or remove characters at any location in the string yielding a string longer or shorter than the original string.\n\nUnfortunately as the ID tags are electronic, each character insertion or deletion has a cost (0 ≤ cost ≤ 10,000) which varies depending on exactly which character value to be added or deleted. Given the content of a cow's ID tag and the cost of inserting or deleting each of the alphabet's characters, find the minimum cost to change the ID tag so it satisfies FJ's requirements. An empty ID tag is considered to satisfy the requirements of reading the same forward and backward. Only letters with associated costs can be added to a string.\n", "inputFormat": "Line 1: Two space-separated integers: N and M\n\n\nLine 2: This line contains exactly M characters which constitute the initial ID string\n\n\nLines 3..N+2: Each line contains three space-separated entities: a character of the input alphabet and two integers which are respectively the cost of adding and deleting that character.\n", "outputFormat": "Line 1: A single line with a single integer that is the minimum cost to change the given name tag.\n", "hint": "If we insert an \"a\" on the end to get \"abcba\", the cost would be 1000. If we delete the \"a\" on the beginning to get \"bcb\", the cost would be 1100. If we insert \"bcb\" at the begining of the string, the cost would be 350 + 200 + 350 = 900, which is the minimum.\n", "locale": "en"}, "zh-CN": {"title": "[USACO07OPEN] Cheapest Palindrome G", "background": "", "description": "给定一个由 $n$ 个不同的小写字母构成的长 $m$ 的字符串 $s$。可以通过**在 $\\bm{s}$ 的任意位置**增减字母将 $s$ 改为回文串。增减字母的花费不同，求最小花费。", "inputFormat": "第 $1$ 行是两个整数 $n,m$。\n\n第 $2$ 行是字符串 $s$。\n\n接下 $n$ 行，每行一个字符 $c$ 和两个整数 $x,y$，表示添加一个 $c$ 的花费为 $x$，删除一个 $c$ 的花费为 $y$。", "outputFormat": "只有 $1$ 行，表示最小花费。", "hint": "对于 $100\\%$ 的数据，$1\\le m\\le2\\times10^3,1\\le n\\le 26,0\\le x,y\\le 10^4$。\n\n$\\mathrm{by\\ @}$[$\\mathrm{Fish\\_Know\\_Forever}$](/user/663215)", "locale": "zh-CN"}}}
{"pid": "P2891", "type": "P", "difficulty": 5, "samples": [["4 3 3\n2 2 1 2 3 1\n2 2 2 3 1 2\n2 2 1 3 1 2\n2 1 1 3 3", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2007", "USACO", "网络流"], "title": "[USACO07OPEN] Dining G", "background": "", "description": "Cows are such finicky eaters. Each cow has a preference for certain foods and drinks, and she will consume no others.\n\nFarmer John has cooked fabulous meals for his cows, but he forgot to check his menu against their preferences. Although he might not be able to stuff everybody, he wants to give a complete meal of both food and drink to as many cows as possible.\n\nFarmer John has cooked F (1 ≤ F ≤ 100) types of foods and prepared D (1 ≤ D ≤ 100) types of drinks. Each of his N (1 ≤ N ≤ 100) cows has decided whether she is willing to eat a particular food or drink a particular drink. Farmer John must assign a food type and a drink type to each cow to maximize the number of cows who get both.\n\nEach dish or drink can only be consumed by one cow (i.e., once food type 2 is assigned to a cow, no other cow can be assigned food type 2).\n", "inputFormat": "Line 1: Three space-separated integers: N, F, and D\n\n\nLines 2..N+1: Each line i starts with a two integers Fi and Di, the number of dishes that cow i likes and the number of drinks that cow i likes. The next Fi integers  denote the dishes that cow i will eat, and the Di integers following that denote the drinks that cow i will drink.\n", "outputFormat": "Line 1: A single integer that is the maximum number of cows that can be fed both food and drink that conform to their wishes\n", "hint": "One way to satisfy three cows is:\n\n\nCow 1: no meal\n\n\nCow 2: Food #2, Drink #2\n\n\nCow 3: Food #1, Drink #1\n\n\nCow 4: Food #3, Drink #3\n\n\nThe pigeon-hole principle tells us we can do no better since there are only three kinds of food or drink. Other test data sets are more challenging, of course.\n", "locale": "en", "translations": {"en": {"title": "[USACO07OPEN] Dining G", "background": "", "description": "Cows are such finicky eaters. Each cow has a preference for certain foods and drinks, and she will consume no others.\n\nFarmer John has cooked fabulous meals for his cows, but he forgot to check his menu against their preferences. Although he might not be able to stuff everybody, he wants to give a complete meal of both food and drink to as many cows as possible.\n\nFarmer John has cooked F (1 ≤ F ≤ 100) types of foods and prepared D (1 ≤ D ≤ 100) types of drinks. Each of his N (1 ≤ N ≤ 100) cows has decided whether she is willing to eat a particular food or drink a particular drink. Farmer John must assign a food type and a drink type to each cow to maximize the number of cows who get both.\n\nEach dish or drink can only be consumed by one cow (i.e., once food type 2 is assigned to a cow, no other cow can be assigned food type 2).\n", "inputFormat": "Line 1: Three space-separated integers: N, F, and D\n\n\nLines 2..N+1: Each line i starts with a two integers Fi and Di, the number of dishes that cow i likes and the number of drinks that cow i likes. The next Fi integers  denote the dishes that cow i will eat, and the Di integers following that denote the drinks that cow i will drink.\n", "outputFormat": "Line 1: A single integer that is the maximum number of cows that can be fed both food and drink that conform to their wishes\n", "hint": "One way to satisfy three cows is:\n\n\nCow 1: no meal\n\n\nCow 2: Food #2, Drink #2\n\n\nCow 3: Food #1, Drink #1\n\n\nCow 4: Food #3, Drink #3\n\n\nThe pigeon-hole principle tells us we can do no better since there are only three kinds of food or drink. Other test data sets are more challenging, of course.\n", "locale": "en"}, "zh-CN": {"title": "[USACO07OPEN] Dining G", "background": "", "description": "奶牛是如此挑剔的食客。每头奶牛都有自己偏好的食物和饮料，她们不会吃其他的东西。\n\n农夫约翰为他的奶牛们准备了丰盛的饭菜，但他忘记检查菜单是否符合她们的偏好。虽然他可能无法满足所有奶牛，但他希望尽可能多地为奶牛提供一份完整的食物和饮料。\n\n农夫约翰准备了 $F$ 种食物（$1 \\le F \\le 100$）和 $D$ 种饮料（$1 \\le D \\le 100$）。他的 $N$ 头奶牛（$1 \\le N \\le 100$）已经决定她们愿意吃某种食物或喝某种饮料。农夫约翰必须为每头奶牛分配一种食物类型和一种饮料类型，以最大化同时获得食物和饮料的奶牛数量。\n\n每种食物或饮料只能被一头奶牛消费（即，一旦食物类型 2 被分配给一头奶牛，其他奶牛就不能再被分配食物类型 2）。\n", "inputFormat": "第 1 行：三个用空格分隔的整数：$N$，$F$ 和 $D$。\n\n\n第 2 行到第 $N+1$ 行：每行 $i$ 以两个整数 $F_i$ 和 $D_i$ 开始，分别表示奶牛 $i$ 喜欢的食物数量和饮料数量。接下来的 $F_i$ 个整数表示奶牛 $i$ 会吃的食物，接下来的 $D_i$ 个整数表示奶牛 $i$ 会喝的饮料。\n", "outputFormat": "第 1 行：一个整数，表示可以同时满足食物和饮料愿望的最大奶牛数量。\n", "hint": "一种满足三头奶牛的方法是：\n\n\n奶牛 1：没有餐食\n\n\n奶牛 2：食物 #2，饮料 #2\n\n\n奶牛 3：食物 #1，饮料 #1\n\n\n奶牛 4：食物 #3，饮料 #3\n\n\n鸽巢原理告诉我们，由于只有三种食物或饮料，我们不能做得更好。当然，其他测试数据集更具挑战性。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2892", "type": "P", "difficulty": 7, "samples": [["4\n1 2\n3 2\n2 4", "2\n7\nL 2\nL 2\nM 2 1\nB 1\nL 3\nM 3 2\nM 2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2007", "NOI", "提交答案", "Special Judge", "O2优化"], "title": "[NOI2007] 追捕盗贼", "background": "SPJ 来源：loj-Robin。已获得授权。\n\nhttps://www.luogu.com.cn/paste/dxytr6gc \n\n附 SPJ，一些修改部分未按照代码规范，请各位谅解。", "description": "魔法国度 Magic Land 里最近出现了一个大盗 Frank，他在 Magic Land 四处作案，专门窃取政府机关的机密文件（因而有人怀疑 Frank 是敌国派来的间谍）。\n\n为了捉住 Frank，Magic Land 的安全局重拳出击！\n\nMagic Land 由 $N$ 个城市组成，并且这 $N$ 个城市又由恰好 $N-1$ 条公路彼此连接起来，使得任意两个城市间都可以通过若干条公路互达。从数据结构的角度我们也可以说，这 $N$ 个城市和 $N-1$ 条公路形成了一棵树。\n\n例如，下图就是 Magic Land 的一个可能格局（$4$ 个城市用数字编号，$3$ 条公路用字母编号）：\n\n ![](https://cdn.luogu.com.cn/upload/pic/12794.png) \n\n大盗 Frank 能够在公路上以任意速度移动。\n\n比方说，对于上图给出的格局，在 $0.00001$ 秒钟内（或者任意短的一段时间内），Frank 就可以从城市 $1$ 经过城市 $2$ 到达城市 $4$，中间经过了两条公路。\n\n想要生擒 Frank 困难重重，所以安全局派出了经验丰富的警探，这些警探具有非凡的追捕才能：\n\n1.  只要有警探和 Frank 同处一个城市，那么就能够立刻察觉到 Frank，并且将其逮捕。\n2.  虽然 Frank 可以在公路上以任意快的速度移动，但是如果有警探和 Frank 在同一条公路上相遇，那么警探也可以立刻察觉到 Frank 并将其逮捕。\n\n安全局完全不知道 Frank 躲在哪个城市，或者正在哪条公路上移动，所以需要制定一个周密的抓捕计划，计划由若干步骤组成。在每一步中，可以做如下几件事中的一个：\n\n1.  在某个城市空降一位警探。警探可以直接从指挥部空降到 Magic Land 的任意一个城市里。此操作记为 `L x`，表示在编号为 $x$ 的城市里空降一位警探。耗时 $1$ 秒。\n2.  把留在某个城市里的一位警探直接召回指挥部。以备在以后的步骤中再度空降到某个城市里。此操作记为 `B x`。表示把编号为 $x$ 的城市里的一位警探召回指挥部。耗时 $1$ 秒。\n3.  让待在城市 $x$ 的一位警探沿着公路移动到城市 $y$，此操作记为 `M x y`。耗时 $1$ 秒。当然，前提是城市 $x$ 和城市 $y$ 之间有公路。如果在警探移动的过程中，大盗 Frank 也在同一条公路上，那么警探就抓捕到了Frank。\n\n现在，由你来制定一套追捕计划，也就是给出若干个步骤，需要保证：无论大盗 Frank 一开始躲在哪儿，也无论 Frank 在整个过程中如何狡猾地移动（Frank 大盗可能会窃取到追捕行动的计划书，所以他一定会想尽办法逃避），他一定会被缉拿归案。\n\n希望参与的警探越少越好，因为经验丰富的警探毕竟不多。\n\n例如对于前面所给的那个图示格局，一个可行的计划如下：\n\n1.  `L 2`：在城市 $2$ 空降一位警探。注意这一步完成之后，城市 $2$ 里不会有 Frank，否则他将被捉住。\n2.  `L 2`：再在城市 $2$ 空降一位警探。\n3.  `M 2 1`：让城市 $2$ 的一位警探移动到城市 $1$。注意城市 $2$ 里还留有另一位警探。这一步完成之后，城市 $1$ 里不会有 Frank，公路 $A$ 上也不会有 Frank。也就是说，假如 Frank 还没有被逮捕，那么他只能是在城市 $3$ 或城市 $4$ 里，或者公路 $B$ 或公路 $C$ 上。\n4.  `B 1`：召回城市 $1$ 的一位警探。注意虽然召回了这位警探，但是由于我们始终留了一位警探在城市 $2$ 把守，所以 Frank 仍然不可能跑到城市 $1$ 或者是公路 $A$ 上。\n5.  `L 3`：在城市 $3$ 空降一位警探。注意这一步可以空降在此之前被召回的那位警探。这一步完成之后，城市 $3$ 里不会有 Frank，否则他会被捉住。\n6.  `M 3 2`：让城市 $3$ 里的一位警探移动到城市 $2$。这一步完成之后，如果 Frank 还没有被捉住，那他只能是在公路 $C$ 上或者城市 $4$ 里。注意这一步之后，城市 $2$ 里有两位警探。\n7.  `M 2 4` 让城市 $2$ 里的一位警探移动到城市 $4$。这一步完成之后，Frank 一定会被捉住，除非他根本就没来 Magic Land。\n\n这个计划总共需要 $2$ 位警探的参与。可以证明：如果自始至终只有 $1$ 名或者更少的警探参与，则 Frank 就会逍遥法外。\n\n你的任务很简单：对于一个输入的 Magic Land 的格局，计算 $S$，也就是为了追捕 Frank 至少需要投入多少位警探，并且给出相应的追捕计划步骤。", "inputFormat": "输入文件给出了 Magic Land 的格局。\n\n第一行一个整数 $N$，代表有 $N$ 个城市，城市的编号是 $1\\sim N$。\n\n接下来 $N-1$ 行，每行有两个用空格分开的整数 $x_i,y_i$，代表城市 $x_i,y_i$ 之间有公路相连。保证 $1\\le x_i,y_i \\le N$。", "outputFormat": "向输出文件输出你所给出的追捕计划。\n\n第一行请输出一个整数 $S$，代表追捕计划需要多少位警探。\n\n第二行请输出一个整数 $T$，代表追捕计划总共有多少步。\n\n接下来请输出 $T$ 行，依次描述了追捕计划的每一步。每行必须是以下三种形式之一：\n\n\n`L x`，其中 `L` 是大写字母，接着是一个空格，再接着是整数 $x$，代表在城市 $x$ 空降一位警探。你必须保证 $1\\le x\\le N$。\n\n`B x`，其中 `B` 是大写字母，接着是一个空格，再接着是整数 $x$，代表召回城市 $x$ 的一位警探。你必须保证 $1\\le x\\le N$，且你的计划执行到这一步之前，城市 $x$ 里面确实至少有一位警探。\n\n\n`M x y`，其中 `M` 是大写字母，接着是一个空格，再接着是整数 $x$，再跟一个空格，最后一个是整数 $y$。代表让城市 $x$ 的一位警探沿着公路移动到城市 $y$。你必须保证 $1\\le x,y\\le N$，且你的计划执行到这一步之前，城市 $x$ 里面确实至少有一位警探，且城市 $x,y$ 之前确实有公路。\n\n\n必须保证输出的 $S$ 确实等于追捕计划中所需要的警探数目。", "hint": "对于任何一个测试点：\n\n如果输出的追捕计划不合法，或者整个追捕计划的步骤数 $T$ 超过了 $20000$，或者追捕计划结束之后，不能保证捉住 Frank，则不能得分。\n\n否则，用你输出的 $S$ 和我们已知的标准答案 $S ^* $ 相比较：\n1. 若 $S<S ^* $，则得到 $120\\%$ 的分。\n2. 若 $S=S ^* $，则得到 $100\\%$ 的分。\n3. 若 $S ^* <S \\le S ^* +2$，则得到 $60\\%$ 的分。\n4. 若 $S ^* +2<S \\le S ^* +4$，则得到 $40\\%$ 的分。\n5. 若 $S ^* +4<S \\le S ^* +8$，则得到 $20\\%$ 的分。\n6. 若 $S>S ^* +8$，则得到 $10\\%$ 的分。\n\n输入保证描述了一棵连通的 $N$ 结点树，$1 \\le N \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2007] Hunting the Thief", "background": "SPJ source: loj-Robin. Authorization obtained.\n\nhttps://www.luogu.com.cn/paste/dxytr6gc\n\nSPJ attached; some modified parts do not follow coding conventions, please excuse.", "description": "A notorious thief named Frank has recently appeared in the magical kingdom Magic Land. He commits crimes all over Magic Land, specializing in stealing confidential government documents (so some suspect Frank is a spy sent by an enemy nation).\n\nTo capture Frank, the Security Bureau of Magic Land is taking strong action!\n\nMagic Land consists of $N$ cities, and these $N$ cities are connected by exactly $N-1$ roads so that any two cities can be reached via some sequence of roads. From a data structure perspective, these $N$ cities and $N-1$ roads form a tree.\n\nFor example, the following diagram shows one possible layout of Magic Land ($4$ cities labeled with numbers, $3$ roads labeled with letters):\n\n![](https://cdn.luogu.com.cn/upload/pic/12794.png)\n\nFrank can move along roads at any speed.\n\nFor instance, in the layout above, within $0.00001$ seconds (or any arbitrarily short period of time), Frank can go from city $1$ through city $2$ to city $4$, passing along two roads.\n\nCapturing Frank alive is extremely difficult, so the Bureau has dispatched experienced detectives with exceptional pursuit skills:\n\n1. If a detective and Frank are in the same city, the detective immediately detects Frank and arrests him.\n2. Although Frank can move arbitrarily fast along roads, if a detective and Frank meet on the same road, the detective can also immediately detect Frank and arrest him.\n\nThe Bureau has no idea which city Frank is hiding in, nor on which road he might be moving, so they must devise a meticulous capture plan consisting of several steps. In each step, exactly one of the following actions can be performed:\n\n1. Airdrop a detective into some city. A detective can be airdropped directly from headquarters into any city in Magic Land. This operation is denoted as `L x`, meaning a detective is airdropped into city $x$. It takes $1$ second.\n2. Recall a detective who is staying in some city back to headquarters, to be available for later airdrop into some city. This operation is denoted as `B x`, meaning a detective in city $x$ is recalled to headquarters. It takes $1$ second.\n3. Move a detective in city $x$ along a road to city $y$. This operation is denoted as `M x y`. It takes $1$ second. Of course, this requires that there is a road between cities $x$ and $y$. If, during the detective’s move, Frank is also on the same road, then the detective will capture Frank.\n\nNow it is your turn to devise a capture plan, i.e., to output a sequence of steps, ensuring that no matter where Frank initially hides and no matter how cunningly he moves throughout the process (Frank might steal the plan, so he will try every means to evade capture), he is guaranteed to be apprehended.\n\nWe want to use as few detectives as possible, since experienced detectives are scarce.\n\nFor the layout shown earlier, one feasible plan is as follows:\n\n1. `L 2`: Airdrop a detective into city $2$. Note that after this step is completed, Frank cannot be in city $2$, otherwise he would have been captured.\n2. `L 2`: Airdrop another detective into city $2$.\n3. `M 2 1`: Move one detective from city $2$ to city $1$. Note that another detective remains in city $2$. After this step, Frank cannot be in city $1$, nor on road $A$. In other words, if Frank has not been arrested yet, he can only be in city $3$ or city $4$, or on road $B$ or road $C$.\n4. `B 1`: Recall the detective in city $1$. Note that although this detective is recalled, since we have kept a detective guarding city $2$ the whole time, Frank still cannot get to city $1$ or road $A$.\n5. `L 3`: Airdrop a detective into city $3$. Note that this step can airdrop the detective who was recalled earlier. After this step is completed, Frank cannot be in city $3$, otherwise he would be captured.\n6. `M 3 2`: Move a detective from city $3$ to city $2$. After this step, if Frank has still not been captured, then he can only be on road $C$ or in city $4$. Note that after this step there are two detectives in city $2$.\n7. `M 2 4`: Move a detective from city $2$ to city $4$. After this step, Frank is guaranteed to be captured, unless he never came to Magic Land at all.\n\nThis plan requires a total of $2$ detectives. It can be proved that if at all times only $1$ detective (or fewer) participates, Frank will escape.\n\nYour task is simple: for a given layout of Magic Land, compute $S$, the minimum number of detectives required to capture Frank, and output a corresponding capture plan.", "inputFormat": "The input file gives the layout of Magic Land.\n\nThe first line contains an integer $N$, the number of cities, numbered $1$ to $N$.\n\nThe next $N-1$ lines each contain two integers $x_i,y_i$ separated by a space, indicating that cities $x_i$ and $y_i$ are connected by a road. It is guaranteed that $1\\le x_i,y_i \\le N$.", "outputFormat": "Output your capture plan.\n\nOn the first line, output an integer $S$, the number of detectives required by your plan.\n\nOn the second line, output an integer $T$, the total number of steps in your plan.\n\nThen output $T$ lines, each describing one step of the plan. Each line must be in one of the following three forms:\n\n`L x`, where `L` is an uppercase letter, followed by a space, then an integer $x$, meaning a detective is airdropped into city $x$. You must ensure $1\\le x\\le N$.\n\n`B x`, where `B` is an uppercase letter, followed by a space, then an integer $x$, meaning a detective in city $x$ is recalled. You must ensure $1\\le x\\le N$, and that prior to this step, there is indeed at least one detective in city $x$.\n\n`M x y`, where `M` is an uppercase letter, followed by a space, then an integer $x$, followed by a space, and finally an integer $y$, meaning a detective in city $x$ moves along a road to city $y$. You must ensure $1\\le x,y\\le N$, that prior to this step there is indeed at least one detective in city $x$, and that there is a road between cities $x$ and $y$.\n\nYou must ensure that the output $S$ is exactly the number of detectives used by your plan.", "hint": "For any test point:\n\nIf the output plan is invalid, or the total number of steps $T$ exceeds $20000$, or after the plan ends Frank is not guaranteed to be captured, you will receive no points.\n\nOtherwise, compare your output $S$ with our known optimal answer $S ^* $:\n1. If $S<S ^* $, you get $120\\%$ of the points.\n2. If $S=S ^* $, you get $100\\%$ of the points.\n3. If $S ^* <S \\le S ^* +2$, you get $60\\%$ of the points.\n4. If $S ^* +2<S \\le S ^* +4$, you get $40\\%$ of the points.\n5. If $S ^* +4<S \\le S ^* +8$, you get $20\\%$ of the points.\n6. If $S>S ^* +8$, you get $10\\%$ of the points.\n\nThe input is guaranteed to describe a connected tree with $N$ nodes, $1 \\le N \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2007] 追捕盗贼", "background": "SPJ 来源：loj-Robin。已获得授权。\n\nhttps://www.luogu.com.cn/paste/dxytr6gc \n\n附 SPJ，一些修改部分未按照代码规范，请各位谅解。", "description": "魔法国度 Magic Land 里最近出现了一个大盗 Frank，他在 Magic Land 四处作案，专门窃取政府机关的机密文件（因而有人怀疑 Frank 是敌国派来的间谍）。\n\n为了捉住 Frank，Magic Land 的安全局重拳出击！\n\nMagic Land 由 $N$ 个城市组成，并且这 $N$ 个城市又由恰好 $N-1$ 条公路彼此连接起来，使得任意两个城市间都可以通过若干条公路互达。从数据结构的角度我们也可以说，这 $N$ 个城市和 $N-1$ 条公路形成了一棵树。\n\n例如，下图就是 Magic Land 的一个可能格局（$4$ 个城市用数字编号，$3$ 条公路用字母编号）：\n\n ![](https://cdn.luogu.com.cn/upload/pic/12794.png) \n\n大盗 Frank 能够在公路上以任意速度移动。\n\n比方说，对于上图给出的格局，在 $0.00001$ 秒钟内（或者任意短的一段时间内），Frank 就可以从城市 $1$ 经过城市 $2$ 到达城市 $4$，中间经过了两条公路。\n\n想要生擒 Frank 困难重重，所以安全局派出了经验丰富的警探，这些警探具有非凡的追捕才能：\n\n1.  只要有警探和 Frank 同处一个城市，那么就能够立刻察觉到 Frank，并且将其逮捕。\n2.  虽然 Frank 可以在公路上以任意快的速度移动，但是如果有警探和 Frank 在同一条公路上相遇，那么警探也可以立刻察觉到 Frank 并将其逮捕。\n\n安全局完全不知道 Frank 躲在哪个城市，或者正在哪条公路上移动，所以需要制定一个周密的抓捕计划，计划由若干步骤组成。在每一步中，可以做如下几件事中的一个：\n\n1.  在某个城市空降一位警探。警探可以直接从指挥部空降到 Magic Land 的任意一个城市里。此操作记为 `L x`，表示在编号为 $x$ 的城市里空降一位警探。耗时 $1$ 秒。\n2.  把留在某个城市里的一位警探直接召回指挥部。以备在以后的步骤中再度空降到某个城市里。此操作记为 `B x`。表示把编号为 $x$ 的城市里的一位警探召回指挥部。耗时 $1$ 秒。\n3.  让待在城市 $x$ 的一位警探沿着公路移动到城市 $y$，此操作记为 `M x y`。耗时 $1$ 秒。当然，前提是城市 $x$ 和城市 $y$ 之间有公路。如果在警探移动的过程中，大盗 Frank 也在同一条公路上，那么警探就抓捕到了Frank。\n\n现在，由你来制定一套追捕计划，也就是给出若干个步骤，需要保证：无论大盗 Frank 一开始躲在哪儿，也无论 Frank 在整个过程中如何狡猾地移动（Frank 大盗可能会窃取到追捕行动的计划书，所以他一定会想尽办法逃避），他一定会被缉拿归案。\n\n希望参与的警探越少越好，因为经验丰富的警探毕竟不多。\n\n例如对于前面所给的那个图示格局，一个可行的计划如下：\n\n1.  `L 2`：在城市 $2$ 空降一位警探。注意这一步完成之后，城市 $2$ 里不会有 Frank，否则他将被捉住。\n2.  `L 2`：再在城市 $2$ 空降一位警探。\n3.  `M 2 1`：让城市 $2$ 的一位警探移动到城市 $1$。注意城市 $2$ 里还留有另一位警探。这一步完成之后，城市 $1$ 里不会有 Frank，公路 $A$ 上也不会有 Frank。也就是说，假如 Frank 还没有被逮捕，那么他只能是在城市 $3$ 或城市 $4$ 里，或者公路 $B$ 或公路 $C$ 上。\n4.  `B 1`：召回城市 $1$ 的一位警探。注意虽然召回了这位警探，但是由于我们始终留了一位警探在城市 $2$ 把守，所以 Frank 仍然不可能跑到城市 $1$ 或者是公路 $A$ 上。\n5.  `L 3`：在城市 $3$ 空降一位警探。注意这一步可以空降在此之前被召回的那位警探。这一步完成之后，城市 $3$ 里不会有 Frank，否则他会被捉住。\n6.  `M 3 2`：让城市 $3$ 里的一位警探移动到城市 $2$。这一步完成之后，如果 Frank 还没有被捉住，那他只能是在公路 $C$ 上或者城市 $4$ 里。注意这一步之后，城市 $2$ 里有两位警探。\n7.  `M 2 4` 让城市 $2$ 里的一位警探移动到城市 $4$。这一步完成之后，Frank 一定会被捉住，除非他根本就没来 Magic Land。\n\n这个计划总共需要 $2$ 位警探的参与。可以证明：如果自始至终只有 $1$ 名或者更少的警探参与，则 Frank 就会逍遥法外。\n\n你的任务很简单：对于一个输入的 Magic Land 的格局，计算 $S$，也就是为了追捕 Frank 至少需要投入多少位警探，并且给出相应的追捕计划步骤。", "inputFormat": "输入文件给出了 Magic Land 的格局。\n\n第一行一个整数 $N$，代表有 $N$ 个城市，城市的编号是 $1\\sim N$。\n\n接下来 $N-1$ 行，每行有两个用空格分开的整数 $x_i,y_i$，代表城市 $x_i,y_i$ 之间有公路相连。保证 $1\\le x_i,y_i \\le N$。", "outputFormat": "向输出文件输出你所给出的追捕计划。\n\n第一行请输出一个整数 $S$，代表追捕计划需要多少位警探。\n\n第二行请输出一个整数 $T$，代表追捕计划总共有多少步。\n\n接下来请输出 $T$ 行，依次描述了追捕计划的每一步。每行必须是以下三种形式之一：\n\n\n`L x`，其中 `L` 是大写字母，接着是一个空格，再接着是整数 $x$，代表在城市 $x$ 空降一位警探。你必须保证 $1\\le x\\le N$。\n\n`B x`，其中 `B` 是大写字母，接着是一个空格，再接着是整数 $x$，代表召回城市 $x$ 的一位警探。你必须保证 $1\\le x\\le N$，且你的计划执行到这一步之前，城市 $x$ 里面确实至少有一位警探。\n\n\n`M x y`，其中 `M` 是大写字母，接着是一个空格，再接着是整数 $x$，再跟一个空格，最后一个是整数 $y$。代表让城市 $x$ 的一位警探沿着公路移动到城市 $y$。你必须保证 $1\\le x,y\\le N$，且你的计划执行到这一步之前，城市 $x$ 里面确实至少有一位警探，且城市 $x,y$ 之前确实有公路。\n\n\n必须保证输出的 $S$ 确实等于追捕计划中所需要的警探数目。", "hint": "对于任何一个测试点：\n\n如果输出的追捕计划不合法，或者整个追捕计划的步骤数 $T$ 超过了 $20000$，或者追捕计划结束之后，不能保证捉住 Frank，则不能得分。\n\n否则，用你输出的 $S$ 和我们已知的标准答案 $S ^* $ 相比较：\n1. 若 $S<S ^* $，则得到 $120\\%$ 的分。\n2. 若 $S=S ^* $，则得到 $100\\%$ 的分。\n3. 若 $S ^* <S \\le S ^* +2$，则得到 $60\\%$ 的分。\n4. 若 $S ^* +2<S \\le S ^* +4$，则得到 $40\\%$ 的分。\n5. 若 $S ^* +4<S \\le S ^* +8$，则得到 $20\\%$ 的分。\n6. 若 $S>S ^* +8$，则得到 $10\\%$ 的分。\n\n输入保证描述了一棵连通的 $N$ 结点树，$1 \\le N \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P2893", "type": "P", "difficulty": 5, "samples": [["7\n1\n3\n2\n4\n5\n3\n9\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "递推", "2008", "USACO", "O2优化", "斜率维护技巧 slope trick"], "title": "[USACO08FEB] Making the Grade G", "background": null, "description": "农夫约翰想改造一条长度为 $N$ 的路，原来的路的每一段海拔是 $A_i$，修理后是 $B_i$，花费 $|A_i - B_i|$。我们要求修好的路，即你构造的 $B_i$，是单调不升或者单调不降的。求最小花费 $\\sum_{i=1}^{N} |A_i - B_i|$。", "inputFormat": "第一行包含一个整数 $N$。\n\n接下来 $N$ 行，每行包含一个整数 $A_i$。", "outputFormat": "一行一个整数，表示最小花费。", "hint": "数据范围为 $1\\le N\\le 2000, 0\\le A_i\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08FEB] Making the Grade G", "background": "", "description": "Farmer John wants to renovate a road of length $N$. The original elevation of each segment is $A_i$, and after repair it becomes $B_i$, with a cost of $|A_i - B_i|$. We require the repaired road, that is, the sequence $B_i$ you construct, to be monotone nonincreasing or monotone nondecreasing. Find the minimum total cost $\\sum_{i=1}^{N} |A_i - B_i|$.", "inputFormat": "The first line contains an integer $N$.\n\nThe next $N$ lines each contain an integer $A_i$.", "outputFormat": "Output a single integer, the minimum cost.", "hint": "Constraints: $1 \\le N \\le 2000$, $0 \\le A_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO08FEB] Making the Grade G", "background": null, "description": "农夫约翰想改造一条长度为 $N$ 的路，原来的路的每一段海拔是 $A_i$，修理后是 $B_i$，花费 $|A_i - B_i|$。我们要求修好的路，即你构造的 $B_i$，是单调不升或者单调不降的。求最小花费 $\\sum_{i=1}^{N} |A_i - B_i|$。", "inputFormat": "第一行包含一个整数 $N$。\n\n接下来 $N$ 行，每行包含一个整数 $A_i$。", "outputFormat": "一行一个整数，表示最小花费。", "hint": "数据范围为 $1\\le N\\le 2000, 0\\le A_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P2894", "type": "P", "difficulty": 5, "samples": [["10 6\n1 3\n1 3\n1 3\n1 3\n2 5 5\n1 6\n", "1\n4\n7\n0\n5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2008", "线段树", "USACO", "栈"], "title": "[USACO08FEB] Hotel G", "background": "", "description": "对一家有 $n$ 个房间（编号为 $1 \\sim n$，开始都为空房）的宾馆维护以下操作：\n\n- 查询房间：你需要在 $1,2,\\ldots,n$ 房间中找到长度为 $x$ 的连续空房。若找得到，在这 $x$ 个空房间中住上人。\n- 退房：房间号 $x \\sim x+y-1$ 退房，即让房间为空。", "inputFormat": "第一行输入 $n,m$，$n$ 代表有 $n$ 个房间 $(1\\leq n \\leq 50,000)$，编号为 $1 \\sim n$，开始都为空房，$m$ 表示以下有 $m$ 行操作 $(1\\leq m \\leq 50,000)$，以下每行先输入一个数 $i$，表示一种操作：\n\n若 $i$ 为 $1$，表示查询房间，再输入一个数 $x$。\n\n若 $i$ 为 $2$，表示退房，再输入两个数 $x,y$。", "outputFormat": "对每个输入 $1$，输出连续 $x$ 个房间中左端的房间号，尽量让这个房间号最小，若找不到长度为 $x$ 的连续空房，输出 $0$。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08FEB] Hotel G", "background": null, "description": "The cows are journeying north to Thunder Bay in Canada to gain cultural enrichment and enjoy a vacation on the sunny shores of Lake Superior. Bessie, ever the competent travel agent, has named the Bullmoose Hotel on famed Cumberland Street as their vacation residence. This immense hotel has N (1 ≤ N ≤ 50,000) rooms all located on the same side of an extremely long hallway (all the better to see the lake, of course).\n\nThe cows and other visitors arrive in groups of size Di (1 ≤ Di ≤ N) and approach the front desk to check in. Each group i requests a set of Di contiguous rooms from Canmuu, the moose staffing the counter. He assigns them some set of consecutive room numbers r..r+Di-1 if they are available or, if no contiguous set of rooms is available, politely suggests alternate lodging. Canmuu always chooses the value of r to be the smallest possible.\n\nVisitors also depart the hotel from groups of contiguous rooms. Checkout i has the parameters Xi and Di which specify the vacating of rooms Xi ..Xi +Di-1 (1 ≤ Xi ≤ N-Di+1). Some (or all) of those rooms might be empty before the checkout.\n\nYour job is to assist Canmuu by processing M (1 ≤ M < 50,000) checkin/checkout requests. The hotel is initially unoccupied.", "inputFormat": "* Line 1: Two space-separated integers: N and M\n\n* Lines 2..M+1: Line i+1 contains request expressed as one of two possible formats: (a) Two space separated integers representing a check-in request: 1 and Di (b) Three space-separated integers representing a check-out: 2, Xi, and Di", "outputFormat": "* Lines 1.....: For each check-in request, output a single line with a single integer r, the first room in the contiguous sequence of rooms to be occupied. If the request cannot be satisfied, output 0.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO08FEB] Hotel G", "background": "", "description": "对一家有 $n$ 个房间（编号为 $1 \\sim n$，开始都为空房）的宾馆维护以下操作：\n\n- 查询房间：你需要在 $1,2,\\ldots,n$ 房间中找到长度为 $x$ 的连续空房。若找得到，在这 $x$ 个空房间中住上人。\n- 退房：房间号 $x \\sim x+y-1$ 退房，即让房间为空。", "inputFormat": "第一行输入 $n,m$，$n$ 代表有 $n$ 个房间 $(1\\leq n \\leq 50,000)$，编号为 $1 \\sim n$，开始都为空房，$m$ 表示以下有 $m$ 行操作 $(1\\leq m \\leq 50,000)$，以下每行先输入一个数 $i$，表示一种操作：\n\n若 $i$ 为 $1$，表示查询房间，再输入一个数 $x$。\n\n若 $i$ 为 $2$，表示退房，再输入两个数 $x,y$。", "outputFormat": "对每个输入 $1$，输出连续 $x$ 个房间中左端的房间号，尽量让这个房间号最小，若找不到长度为 $x$ 的连续空房，输出 $0$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2895", "type": "P", "difficulty": 3, "samples": [["4\n0 0 2\n2 1 2\n1 1 2\n0 3 5\n", "5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2008", "USACO", "广度优先搜索 BFS"], "title": "[USACO08FEB] Meteor Shower S", "background": "", "description": "Bessie hears that an extraordinary meteor shower is coming; reports say that these meteors will crash into earth and destroy anything they hit. Anxious for her safety, she vows to find her way to a safe location (one that is never destroyed by a meteor) . She is currently grazing at the origin in the coordinate plane and wants to move to a new, safer location while avoiding being destroyed by meteors along her way.\n\nThe reports say that M meteors (1 ≤ M ≤ 50,000) will strike, with meteor i will striking point (Xi, Yi) (0 ≤ Xi ≤ 300; 0 ≤ Yi ≤ 300) at time Ti (0 ≤ Ti  ≤ 1,000). Each meteor destroys the point that it strikes and also the four rectilinearly adjacent lattice points.\n\nBessie leaves the origin at time 0 and can travel in the first quadrant and parallel to the axes at the rate of one distance unit per second to any of the (often 4) adjacent rectilinear points that are not yet destroyed by a meteor. She cannot be located on a point at any time greater than or equal to the time it is destroyed).\n\nDetermine the minimum time it takes Bessie to get to a safe place.\n", "inputFormat": "\\* Line 1: A single integer: M\n\n\\* Lines 2..M+1: Line i+1 contains three space-separated integers: Xi, Yi, and Ti\n", "outputFormat": "\\* Line 1: The minimum time it takes Bessie to get to a safe place or -1 if it is impossible.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO08FEB] Meteor Shower S", "background": "", "description": "Bessie hears that an extraordinary meteor shower is coming; reports say that these meteors will crash into earth and destroy anything they hit. Anxious for her safety, she vows to find her way to a safe location (one that is never destroyed by a meteor) . She is currently grazing at the origin in the coordinate plane and wants to move to a new, safer location while avoiding being destroyed by meteors along her way.\n\nThe reports say that M meteors (1 ≤ M ≤ 50,000) will strike, with meteor i will striking point (Xi, Yi) (0 ≤ Xi ≤ 300; 0 ≤ Yi ≤ 300) at time Ti (0 ≤ Ti  ≤ 1,000). Each meteor destroys the point that it strikes and also the four rectilinearly adjacent lattice points.\n\nBessie leaves the origin at time 0 and can travel in the first quadrant and parallel to the axes at the rate of one distance unit per second to any of the (often 4) adjacent rectilinear points that are not yet destroyed by a meteor. She cannot be located on a point at any time greater than or equal to the time it is destroyed).\n\nDetermine the minimum time it takes Bessie to get to a safe place.\n", "inputFormat": "\\* Line 1: A single integer: M\n\n\\* Lines 2..M+1: Line i+1 contains three space-separated integers: Xi, Yi, and Ti\n", "outputFormat": "\\* Line 1: The minimum time it takes Bessie to get to a safe place or -1 if it is impossible.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO08FEB] Meteor Shower S", "background": "", "description": "贝茜听说一场特别的流星雨即将到来：这些流星会撞向地球，并摧毁它们所撞击的任何东西。她为自己的安全感到焦虑，发誓要找到一个安全的地方（一个永远不会被流星摧毁的地方）。\n\n如果将牧场放入一个直角坐标系中，贝茜现在的位置是原点，并且，贝茜不能踏上一块被流星砸过的土地。\n\n根据预报，一共有 $M$ 颗流星 $(1\\leq M\\leq 50,000)$ 会坠落在农场上，其中第 $i$ 颗流星会在时刻 $T_i$（$0 \\leq T _ i \\leq 1000$）砸在坐标为 $(X_i,Y_i)(0\\leq X_i\\leq 300$，$0\\leq Y_i\\leq 300)$ 的格子里。流星的力量会将它所在的格子，以及周围 $4$ 个相邻的格子都化为焦土，当然贝茜也无法再在这些格子上行走。\n\n贝茜在时刻 $0$ 开始行动，她只能在会在横纵坐标 $X,Y\\ge 0$ 的区域中，平行于坐标轴行动，每 $1$ 个时刻中，她能移动到相邻的（一般是 $4$ 个）格子中的任意一个，当然目标格子要没有被烧焦才行。如果一个格子在时刻 $t$ 被流星撞击或烧焦，那么贝茜只能在 $t$ 之前的时刻在这个格子里出现。 贝茜一开始在 $(0,0)$。\n\n请你计算一下，贝茜最少需要多少时间才能到达一个安全的格子。如果不可能到达输出 $−1$。", "inputFormat": "共 $M+1$ 行，第 $1$ 行输入一个整数 $M$，接下来的 $M$ 行每行输入三个整数分别为 $X_i, Y_i, T_i$。", "outputFormat": "贝茜到达安全地点所需的最短时间，如果不可能，则为 $-1$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2896", "type": "P", "difficulty": 3, "samples": [["5\n1\n3\n2\n1\n1\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2008", "USACO", "队列"], "title": "[USACO08FEB] Eating Together S", "background": null, "description": "FJ 的奶牛们在吃晚饭时很傻。他们把自己组织成三组（为了方便，将它们编号为 $1,2,3$），坚持一起用餐。当他们在谷仓排队进入喂食区时，麻烦就开始了。\n\n每头奶牛都随身带着一张小卡片，小卡片上刻的是 $D_i$（$1\\le D_i\\le 3$）表示她属于哪一组。所有的 $N$（$1\\le N\\le 30000$）头奶牛排队吃饭，但他们并不能按卡片上的分组站好。\n\n\nFJ 的工作并不是那么难。他只是沿着牛的路线走下去，把旧的号码标出来，换上一个新的。通过这样做，他使奶牛的就餐组按他们的晚餐卡片按升序或降序排列，比如 `111222333` 或 `333222111`。\n\n\nFJ 和其他人一样懒惰。他很好奇：怎样他才能进行适当的分组，使得他只要修改最少次数的数字？由于奶牛们已经很长时间没有吃到饭了，所以“哞哞”的声音到处都是，FJ 只能更换卡号，而不能重新排列已经排好队的奶牛。", "inputFormat": "- 第 $1$ 行：一个整数：$n$\n- 第 $2\\sim n+1$ 行：第 $i+1$ 行描述第 $i$ 个奶牛目前的分组", "outputFormat": "一个整数，表示必须做出的最小变化数，使得奶牛的就餐组按他们的晚餐卡片按升序或降序排列。", "hint": "感谢@一思千年 提供翻译", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08FEB] Eating Together S", "background": null, "description": "The cows are so very silly about their dinner partners. They have organized themselves into three groups (conveniently numbered 1, 2, and 3) that insist upon dining together. The trouble starts when they line up at the barn to enter the feeding area.\n\nEach cow i carries with her a small card upon which is engraved Di (1 ≤ Di ≤ 3) indicating her dining group membership. The entire set of N (1 ≤ N ≤ 30,000) cows has lined up for dinner but it's easy for anyone to see that they are not grouped by their dinner-partner cards.\n\nFJ's job is not so difficult. He just walks down the line of cows changing their dinner partner assignment by marking out the old number and writing in a new one. By doing so, he creates groups of cows like 111222333 or 333222111 where the cows' dining groups are sorted in either ascending or descending order by their dinner cards.\n\nFJ is just as lazy as the next fellow. He's curious: what is the absolute mminimum number of cards he must change to create a proper grouping of dining partners? He must only change card numbers and must not rearrange the cows standing in line.", "inputFormat": "* Line 1: A single integer: N\n\n* Lines 2..N+1: Line i describes the i-th cow's current dining group with a single integer: Di", "outputFormat": "* Line 1: A single integer representing the minimum number of changes that must be made so that the final sequence of cows is sorted in either ascending or descending order", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO08FEB] Eating Together S", "background": null, "description": "FJ 的奶牛们在吃晚饭时很傻。他们把自己组织成三组（为了方便，将它们编号为 $1,2,3$），坚持一起用餐。当他们在谷仓排队进入喂食区时，麻烦就开始了。\n\n每头奶牛都随身带着一张小卡片，小卡片上刻的是 $D_i$（$1\\le D_i\\le 3$）表示她属于哪一组。所有的 $N$（$1\\le N\\le 30000$）头奶牛排队吃饭，但他们并不能按卡片上的分组站好。\n\n\nFJ 的工作并不是那么难。他只是沿着牛的路线走下去，把旧的号码标出来，换上一个新的。通过这样做，他使奶牛的就餐组按他们的晚餐卡片按升序或降序排列，比如 `111222333` 或 `333222111`。\n\n\nFJ 和其他人一样懒惰。他很好奇：怎样他才能进行适当的分组，使得他只要修改最少次数的数字？由于奶牛们已经很长时间没有吃到饭了，所以“哞哞”的声音到处都是，FJ 只能更换卡号，而不能重新排列已经排好队的奶牛。", "inputFormat": "- 第 $1$ 行：一个整数：$n$\n- 第 $2\\sim n+1$ 行：第 $i+1$ 行描述第 $i$ 个奶牛目前的分组", "outputFormat": "一个整数，表示必须做出的最小变化数，使得奶牛的就餐组按他们的晚餐卡片按升序或降序排列。", "hint": "感谢@一思千年 提供翻译", "locale": "zh-CN"}}}
{"pid": "P2897", "type": "P", "difficulty": 5, "samples": [["3\n4 2\n2 7\n6 4", "4\n50\n26"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO", "栈"], "title": "[USACO08JAN] Artificial Lake G", "background": "USACO 2008 January Gold", "description": "夏日那让人喘不过气的酷热将奶牛们的烦躁情绪推到了最高点。最终，FJ 决定建一个人工湖供奶牛消暑之用。为了使湖看起来更加真实，FJ 决定将湖的横截面建成 $N(1\\le N\\le 100,000)$ 个连续的平台高低错落的组合状，所有的平台从左到右按 $1\\sim N$ 依次编号。当然咯，在湖中注入水后，这些平台都将被淹没。平台 $i$ 在设计图上用它的宽度 $W_i(1\\le W_i\\le1,000)$ 和高度（你可以理解为该平台顶离 FJ 挖的地基的高度）$H_i(1\\le H_i\\le 1,000,000)$ 来描述的。所有平台的高度都是独一无二的。湖的边缘可以视为无限高的平台。下面给出了一张 FJ 的设计图：\n          \n```plain\n         *             *  :\n         *             *  :\n         *             *  8\n         *    ***      *  7\n         *    ***      *  6\n         *    ***      *  5\n         *    **********  4 <- height\n         *    **********  3\n         ***************  2\n         ***************  1\nLevel    |  1 |2|  3   |\n```\n\n按 FJ 的设想，在坑挖好后，他会以 $1$ 单位每分钟的速度往最低的那个平台上注水。水在离开水管后立即下落，直到撞到平台顶或是更早些时候注入的水。然后，与所有常温下的水一样，它会迅速地流动、扩散。简单起见，你可以认为这些都是在瞬间完成的。FJ 想知道，对于每一个平台，它的顶部是从哪个时刻开始，与水面的距离至少为 $1$ 单位长度。\n\n\n```plain\nWATER              WATER OVERFLOWS                     \n       |                       |                           \n     * |          *      *     |      *      *            *\n     * V          *      *     V      *      *            *\n     *            *      *    ....    *      *~~~~~~~~~~~~*\n     *    **      *      *~~~~** :    *      *~~~~**~~~~~~*\n     *    **      *      *~~~~** :    *      *~~~~**~~~~~~*\n     *    **      *      *~~~~**~~~~~~*      *~~~~**~~~~~~*\n     *    *********      *~~~~*********      *~~~~*********\n     *~~~~*********      *~~~~*********      *~~~~*********\n     **************      **************      **************\n     **************      **************      **************\n     After 4 mins        After 26 mins       After 50 mins\n\n     Lvl 1 submerged     Lvl 3 submerged     Lvl 2 submerged\n```", "inputFormat": "第一行一个正整数 $N$。\n\n下面 $N$ 行，每行两个正整数 $W_i,H_i$。", "outputFormat": "$N$ 行，每行一个正整数，表示：对于每一个平台，它的顶部是从哪个时刻开始，与水面的距离至少为 $1$ 单位长度。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[USACO08JAN] Artificial Lake G", "background": null, "description": "The oppressively hot summer days have raised the cows' clamoring to its highest level. Farmer John has finally decided to build an artificial lake. For his engineering studies, he is modeling the lake as a two-dimensional landscape consisting of a contiguous sequence of N soon-to-be-submerged levels (1 ≤ N ≤ 100,000) conveniently numbered 1..N from left to right.\n\nEach level i is described by two integers, its width Wi (1 ≤ Wi ≤ 1,000) and height (like a relative elevation) Hi (1 ≤ Hi ≤ 1,000,000). The heights of FJ's levels are unique. An infinitely tall barrier encloses the lake's model on the left and right. One example lake profile is shown below.\n\n```plain\n         *             *  :\n         *             *  :\n         *             *  8\n         *    ***      *  7\n         *    ***      *  6\n         *    ***      *  5\n         *    **********  4 <- height\n         *    **********  3\n         ***************  2\n         ***************  1\nLevel    |  1 |2|  3   |\n```\n\nIn FJ's model, he starts filling his lake at sunrise by flowing water into the bottom of the lowest elevation at a rate of 1 square unit of water per minute. The water falls directly downward until it hits something, and then it flows and spreads as room-temperature water always does. As in all good models, assume that falling and flowing happen instantly. Determine the time at which each elevation's becomes submerged by a single unit of water.\n\n```plain\nWATER              WATER OVERFLOWS                     \n       |                       |                           \n     * |          *      *     |      *      *            *\n     * V          *      *     V      *      *            *\n     *            *      *    ....    *      *~~~~~~~~~~~~*\n     *    **      *      *~~~~** :    *      *~~~~**~~~~~~*\n     *    **      *      *~~~~** :    *      *~~~~**~~~~~~*\n     *    **      *      *~~~~**~~~~~~*      *~~~~**~~~~~~*\n     *    *********      *~~~~*********      *~~~~*********\n     *~~~~*********      *~~~~*********      *~~~~*********\n     **************      **************      **************\n     **************      **************      **************\n     After 4 mins        After 26 mins       After 50 mins\n\n     Lvl 1 submerged     Lvl 3 submerged     Lvl 2 submerged\n```\n\nWarning: The answer will not always fit in 32 bits.", "inputFormat": "* Line 1: A single integer: N\n\n* Lines 2..N+1: Line i+1 describes level i with two space-separated integers: Wi and Hi", "outputFormat": "Lines 1..N: Line i contains a single integer that is the number of minutes that since sunrise when level #i is covered by water of height 1.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO08JAN] Artificial Lake G", "background": "USACO 2008 January Gold", "description": "夏日那让人喘不过气的酷热将奶牛们的烦躁情绪推到了最高点。最终，FJ 决定建一个人工湖供奶牛消暑之用。为了使湖看起来更加真实，FJ 决定将湖的横截面建成 $N(1\\le N\\le 100,000)$ 个连续的平台高低错落的组合状，所有的平台从左到右按 $1\\sim N$ 依次编号。当然咯，在湖中注入水后，这些平台都将被淹没。平台 $i$ 在设计图上用它的宽度 $W_i(1\\le W_i\\le1,000)$ 和高度（你可以理解为该平台顶离 FJ 挖的地基的高度）$H_i(1\\le H_i\\le 1,000,000)$ 来描述的。所有平台的高度都是独一无二的。湖的边缘可以视为无限高的平台。下面给出了一张 FJ 的设计图：\n          \n```plain\n         *             *  :\n         *             *  :\n         *             *  8\n         *    ***      *  7\n         *    ***      *  6\n         *    ***      *  5\n         *    **********  4 <- height\n         *    **********  3\n         ***************  2\n         ***************  1\nLevel    |  1 |2|  3   |\n```\n\n按 FJ 的设想，在坑挖好后，他会以 $1$ 单位每分钟的速度往最低的那个平台上注水。水在离开水管后立即下落，直到撞到平台顶或是更早些时候注入的水。然后，与所有常温下的水一样，它会迅速地流动、扩散。简单起见，你可以认为这些都是在瞬间完成的。FJ 想知道，对于每一个平台，它的顶部是从哪个时刻开始，与水面的距离至少为 $1$ 单位长度。\n\n\n```plain\nWATER              WATER OVERFLOWS                     \n       |                       |                           \n     * |          *      *     |      *      *            *\n     * V          *      *     V      *      *            *\n     *            *      *    ....    *      *~~~~~~~~~~~~*\n     *    **      *      *~~~~** :    *      *~~~~**~~~~~~*\n     *    **      *      *~~~~** :    *      *~~~~**~~~~~~*\n     *    **      *      *~~~~**~~~~~~*      *~~~~**~~~~~~*\n     *    *********      *~~~~*********      *~~~~*********\n     *~~~~*********      *~~~~*********      *~~~~*********\n     **************      **************      **************\n     **************      **************      **************\n     After 4 mins        After 26 mins       After 50 mins\n\n     Lvl 1 submerged     Lvl 3 submerged     Lvl 2 submerged\n```", "inputFormat": "第一行一个正整数 $N$。\n\n下面 $N$ 行，每行两个正整数 $W_i,H_i$。", "outputFormat": "$N$ 行，每行一个正整数，表示：对于每一个平台，它的顶部是从哪个时刻开始，与水面的距离至少为 $1$ 单位长度。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2898", "type": "P", "difficulty": 5, "samples": [["20 4\n1 10 7\n5 19 7\n3 12 8\n11 15 12\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "线段树", "二分", "USACO", "并查集"], "title": "[USACO08JAN] Haybale Guessing G", "background": "", "description": "The cows, who always have an inferiority complex about their intelligence, have a new guessing game to sharpen their brains.\n\nA designated 'Hay Cow' hides behind the barn and creates N (1 ≤ N ≤ 1,000,000) uniquely-sized stacks (conveniently numbered 1..N) of hay bales, each with 1..1,000,000,000 bales of hay.\n\nThe other cows then ask the Hay Cow a series of Q (1 ≤ Q ≤ 25,000) questions about the the stacks, all having the same form:\n\nWhat is the smallest number of bales of any stack in the range of stack numbers Ql..Qh (1 ≤ Ql ≤ N; Ql ≤ Qh ≤ N)?The Hay Cow answers each of these queries with a single integer A whose truthfulness is not guaranteed.\n\nHelp the other cows determine if the answers given by the Hay Cow are self-consistent or if certain answers contradict others.\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and Q\n\n\\* Lines 2..Q+1: Each line contains three space-separated integers that represent a single query and its reply: Ql, Qh, and A\n", "outputFormat": "\\* Line 1: Print the single integer 0 if there are no inconsistencies among the replies (i.e., if there exists a valid realization of the hay stacks that agrees with all Q queries). Otherwise, print the index from 1..Q of the earliest query whose answer is inconsistent with the answers to the queries before it.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO08JAN] Haybale Guessing G", "background": "", "description": "The cows, who always have an inferiority complex about their intelligence, have a new guessing game to sharpen their brains.\n\nA designated 'Hay Cow' hides behind the barn and creates N (1 ≤ N ≤ 1,000,000) uniquely-sized stacks (conveniently numbered 1..N) of hay bales, each with 1..1,000,000,000 bales of hay.\n\nThe other cows then ask the Hay Cow a series of Q (1 ≤ Q ≤ 25,000) questions about the the stacks, all having the same form:\n\nWhat is the smallest number of bales of any stack in the range of stack numbers Ql..Qh (1 ≤ Ql ≤ N; Ql ≤ Qh ≤ N)?The Hay Cow answers each of these queries with a single integer A whose truthfulness is not guaranteed.\n\nHelp the other cows determine if the answers given by the Hay Cow are self-consistent or if certain answers contradict others.\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and Q\n\n\\* Lines 2..Q+1: Each line contains three space-separated integers that represent a single query and its reply: Ql, Qh, and A\n", "outputFormat": "\\* Line 1: Print the single integer 0 if there are no inconsistencies among the replies (i.e., if there exists a valid realization of the hay stacks that agrees with all Q queries). Otherwise, print the index from 1..Q of the earliest query whose answer is inconsistent with the answers to the queries before it.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO08JAN] Haybale Guessing G", "background": null, "description": "给一个长度为 $n$ 的数组 $q$ 个条件，数组中的数字互不相同，每个条件格式形如  $l_i,r_i,x_i$ 表示这个数组的区间 $[l_i,r_i]$ 内的最小值为 $x_i$，输出最早与前面的条件有矛盾的条件的编号，如果所有条件都不发生矛盾，输出 $0$。", "inputFormat": "第一行两个整数，分别是  $n$ 和  $q$。\n\n第二行至第 $q+1$ 行，每行三个整 $l_i,r_i,x_i$ 描述一个条件。", "outputFormat": "仅一个整数，表示最早发生矛盾的条件的编号。如果所有条件都没有发生矛盾，输出 $0$。", "hint": "对于 $100\\%$ 的数据，保证：\n  - $1 \\le q \\le 25000$\n  - $1 \\le n \\le 10^6$\n  - $1 \\le l_i \\le r_i \\le n$\n  - $1 \\le x_i \\le 10^9$", "locale": "zh-CN"}}}
{"pid": "P2899", "type": "P", "difficulty": 3, "samples": [["5\n1 3\n5 2\n4 3\n3 5\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO", "排序", "树形 DP", "拓扑排序"], "title": "[USACO08JAN] Cell Phone Network G", "background": null, "description": "Farmer John 想让他的所有牛用上手机以便相互交流。他需要建立几座信号塔在 $N$ 块草地中。已知与信号塔相邻的草地和信号塔所在的草地均能收到信号。给你 $N-1$ 个草地 $(A,B)$ 的相邻关系，问：最少需要建多少个信号塔能实现所有草地都有信号。", "inputFormat": "第 $1$ 行：一个整数 $N$。\n\n第 $2$ 行到第 $N$ 行：每一行两个整数，用空格分隔，给出一对相邻的草地 $A$ 和 $B$。", "outputFormat": "一个整数，表示要安装的最少信号塔数。", "hint": "对于所有的数据，$1 \\leq N \\leq 10^4$，$1 \\leq A,B \\leq N$，$A \\neq B$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08JAN] Cell Phone Network G", "background": "", "description": "Farmer John wants all his cows to use cell phones so that they can communicate. He needs to build several cell towers among $N$ pastures. A tower provides coverage to the pasture it is placed on and to any pasture adjacent to it. You are given $N-1$ adjacency pairs $(A, B)$ between pastures. What is the minimum number of towers required so that every pasture has coverage?", "inputFormat": "Line 1: an integer $N$.\n\nLines 2 through $N$: each line contains two integers separated by a space, giving one adjacent pair of pastures $A$ and $B$.", "outputFormat": "A single integer, the minimum number of towers to install.", "hint": "For all testdata, $1 \\leq N \\leq 10^4$, $1 \\leq A, B \\leq N$, $A \\neq B$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO08JAN] Cell Phone Network G", "background": null, "description": "Farmer John 想让他的所有牛用上手机以便相互交流。他需要建立几座信号塔在 $N$ 块草地中。已知与信号塔相邻的草地和信号塔所在的草地均能收到信号。给你 $N-1$ 个草地 $(A,B)$ 的相邻关系，问：最少需要建多少个信号塔能实现所有草地都有信号。", "inputFormat": "第 $1$ 行：一个整数 $N$。\n\n第 $2$ 行到第 $N$ 行：每一行两个整数，用空格分隔，给出一对相邻的草地 $A$ 和 $B$。", "outputFormat": "一个整数，表示要安装的最少信号塔数。", "hint": "对于所有的数据，$1 \\leq N \\leq 10^4$，$1 \\leq A,B \\leq N$，$A \\neq B$。", "locale": "zh-CN"}}}
{"pid": "P2900", "type": "P", "difficulty": 6, "samples": [["4 \n100 1 \n15 15 \n20 5 \n1 100 \n", "500 \n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2008", "USACO", "斜率优化"], "title": "[USACO08MAR] Land Acquisition G", "background": "", "description": "Farmer John 准备扩大他的农场，眼前他正在考虑购买 $N$ 块长方形的土地。\n\n如果 FJ 单买一块土地，价格就是土地的面积。但他可以选择并购一组土地，并购的价格为这些土地中最大的长乘以最大的宽。比如 FJ 并购一块 $3 \\times 5$ 和一块 $5 \\times 3$ 的土地，他只需要支付 $5 \\times 5=25$ 元， 比单买合算。\n\nFJ 希望买下所有的土地。他发现，将这些土地分成不同的小组来并购可以节省经费。 给定每份土地的尺寸，请你帮助他计算购买所有土地所需的最小费用。", "inputFormat": "第一行一个整数 $N$（$1 \\leq N \\leq 5 \\times 10^4$）。\n\n接下来 $N$ 行，每行两个整数 $w_i$ 和 $l_i$，代表第 $i$ 块土地的长和宽。保证土地的长和宽不超过 $10^6$。", "outputFormat": "输出买下所有土地的最小费用。", "hint": "将所有土地分为三组：\n\n- 第一块土地为第一组，花费 $100 \\times 1=100$；\n- 第二，三块土地为第二组，花费 $20 \\times 15=300$；\n- 第四块土地为第三组，花费 $1 \\times 100=100$；\n\n总花费为 $500$，可以证明不存在更优的方案。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08MAR] Land Acquisition G", "background": "", "description": "Farmer John is planning to expand his farm and is considering buying $N$ rectangular plots.\n\nIf FJ buys a single plot, the price equals the area of the plot. But he can choose to acquire a group of plots together, where the price of the group is the maximum length times the maximum width among those plots. For example, if FJ acquires a $3 \\times 5$ plot and a $5 \\times 3$ plot together, he only pays $5 \\times 5=25$, which is cheaper than buying them separately.\n\nFJ wants to buy all the plots. He found that partitioning the plots into different groups can save money. Given the dimensions of each plot, please help him compute the minimum total cost to purchase all plots.", "inputFormat": "The first line contains an integer $N$ ($1 \\leq N \\leq 5 \\times 10^4$).\n\nEach of the next $N$ lines contains two integers $w_i$ and $l_i$, denoting the length and the width of the $i$-th plot. It is guaranteed that both the length and the width do not exceed $10^6$.", "outputFormat": "Output the minimum cost to buy all the plots.", "hint": "Divide all plots into three groups:\n\n- The first plot is in the first group, costing $100 \\times 1=100$.\n- The second and third plots are in the second group, costing $20 \\times 15=300$.\n- The fourth plot is in the third group, costing $1 \\times 100=100$.\n\nThe total cost is $500$, and it can be proven that no better plan exists.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO08MAR] Land Acquisition G", "background": "", "description": "Farmer John 准备扩大他的农场，眼前他正在考虑购买 $N$ 块长方形的土地。\n\n如果 FJ 单买一块土地，价格就是土地的面积。但他可以选择并购一组土地，并购的价格为这些土地中最大的长乘以最大的宽。比如 FJ 并购一块 $3 \\times 5$ 和一块 $5 \\times 3$ 的土地，他只需要支付 $5 \\times 5=25$ 元， 比单买合算。\n\nFJ 希望买下所有的土地。他发现，将这些土地分成不同的小组来并购可以节省经费。 给定每份土地的尺寸，请你帮助他计算购买所有土地所需的最小费用。", "inputFormat": "第一行一个整数 $N$（$1 \\leq N \\leq 5 \\times 10^4$）。\n\n接下来 $N$ 行，每行两个整数 $w_i$ 和 $l_i$，代表第 $i$ 块土地的长和宽。保证土地的长和宽不超过 $10^6$。", "outputFormat": "输出买下所有土地的最小费用。", "hint": "将所有土地分为三组：\n\n- 第一块土地为第一组，花费 $100 \\times 1=100$；\n- 第二，三块土地为第二组，花费 $20 \\times 15=300$；\n- 第四块土地为第三组，花费 $1 \\times 100=100$；\n\n总花费为 $500$，可以证明不存在更优的方案。", "locale": "zh-CN"}}}
{"pid": "P2901", "type": "P", "difficulty": 5, "samples": [["5 8 7 \n5 4 1 \n5 3 1 \n5 2 1 \n5 1 1 \n4 3 4 \n3 1 1 \n3 2 1 \n2 1 1 \n", "1 \n2 \n2 \n3 \n6 \n7 \n-1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "USACO", "广度优先搜索 BFS", "A*  算法"], "title": "[USACO08MAR] Cow Jogging G", "background": "", "description": "\n贝西终于尝到了懒惰的后果，决定每周从谷仓到池塘慢跑几次来健身。当然，她不想跑得太累，所以她只打算从谷仓慢跑下山到池塘，然后悠闲地散步回谷仓。\n\n同时，贝西不想跑得太远，所以她只想沿着通向池塘的最短路径跑步。一共有 $M$ 条道路，其中每一条都连接了两个牧场。这些牧场从 $1$ 到 $N$ 编号，如果 $X>Y$，则说明牧场 $X$ 的地势高于牧场 $Y$，即下坡的道路是从 $X$ 通向 $Y$ 的，$N$ 为贝西所在的牛棚（最高点），$1$ 为池塘（最低点）。\n\n然而，一周之后，贝西开始对单调的路线感到厌烦，她希望可以跑不同的路线。比如说，她希望能有 $K$ 种不同的路线。同时，为了避免跑得太累，她希望这 $K$ 条路线是从牛棚到池塘的路线中最短的 $K$ 条。如果两条路线包含的道路组成的序列不同，则这两条路线被认为是不同的。\n\n请帮助贝西算算她的训练强度，即将牧场网络里最短的 $K$ 条路径的长度分别算出来。你将会被提供一份牧场间路线的列表，每条道路用 $(X_i, Y_i, D_i)$ 表示，意为从 $X_i$ 到 $Y_i$ 有一条长度为 $D_i$ 的下坡道路。", "inputFormat": "第一行三个用空格分开的整数 $N,M,K$，其中 。\n\n第二行到第 $M+1$ 行每行有三个用空格分开的整数 $X_i,Y_i,D_i$，描述一条下坡的道路。", "outputFormat": "共 $K$ 行，在第 $i$ 行输出第 $i$ 短的路线长度，如果不存在则输出 $-1$。如果出现多种有相同长度的路线，务必将其全部输出。", "hint": "#### 样例 1 解释\n\n这些路线分别为 $(5\\to 1)$、$(5\\to 3\\to 1)$、$(5\\to 2\\to 1)$、$(5\\to 3\\to 2\\to 1)$、$(5\\to 4\\to 3\\to 1)$ 和 $(5\\to 4\\to 3\\to 2\\to 1)$。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\le N \\le 1,000$，$1 \\le M \\le 1\\times10^4$，$1 \\le K \\le 100$，$1 \\le Y_i < X_i\\le N$，$1 \\le D_i \\le 1\\times 10^6$， ", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08MAR] Cow Jogging G", "background": "", "description": "Bessie has finally tasted the consequences of laziness and decides to jog from the barn to the pond several times a week to get in shape. Of course, she does not want to overexert herself, so she only plans to jog downhill from the barn to the pond, then leisurely walk back to the barn.\n\nAt the same time, Bessie does not want to run too far, so she wants to run along the shortest route to the pond. There are $M$ roads in total, each connecting two pastures. The pastures are numbered from $1$ to $N$. If $X > Y$, it means pasture $X$ is higher than pasture $Y$, i.e., downhill roads go from $X$ to $Y$. Pasture $N$ is the barn (the highest point), and pasture $1$ is the pond (the lowest point).\n\nHowever, after a week, Bessie gets bored of the monotony and wants to try different routes. For example, she hopes there can be $K$ different routes. To avoid getting too tired, she wants these $K$ routes to be the $K$ shortest routes from the barn to the pond. Two routes are considered different if the sequences of roads they contain are different.\n\nPlease help Bessie compute her training intensity by finding the lengths of the $K$ shortest paths in the pasture network. You are given a list of roads between pastures, where each road is represented by $(X_i, Y_i, D_i)$, meaning there is a downhill road from $X_i$ to $Y_i$ of length $D_i$.", "inputFormat": "The first line contains three space-separated integers $N, M, K$.\n\nEach of the next $M$ lines contains three space-separated integers $X_i, Y_i, D_i$, describing a downhill road.", "outputFormat": "Output $K$ lines. On the $i$-th line, output the length of the $i$-th shortest route. If fewer than $K$ routes exist, output $-1$ for the remaining lines. If multiple distinct routes have the same length, they should all be counted; equal lengths may appear multiple times.", "hint": "Sample 1 Explanation:\nThese routes are $(5 \\to 1)$, $(5 \\to 3 \\to 1)$, $(5 \\to 2 \\to 1)$, $(5 \\to 3 \\to 2 \\to 1)$, $(5 \\to 4 \\to 3 \\to 1)$, and $(5 \\to 4 \\to 3 \\to 2 \\to 1)$.\n\nConstraints:\nFor all test points, it is guaranteed that $1 \\le N \\le 1,000$, $1 \\le M \\le 1 \\times 10^4$, $1 \\le K \\le 100$, $1 \\le Y_i < X_i \\le N$, $1 \\le D_i \\le 1 \\times 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO08MAR] Cow Jogging G", "background": "", "description": "\n贝西终于尝到了懒惰的后果，决定每周从谷仓到池塘慢跑几次来健身。当然，她不想跑得太累，所以她只打算从谷仓慢跑下山到池塘，然后悠闲地散步回谷仓。\n\n同时，贝西不想跑得太远，所以她只想沿着通向池塘的最短路径跑步。一共有 $M$ 条道路，其中每一条都连接了两个牧场。这些牧场从 $1$ 到 $N$ 编号，如果 $X>Y$，则说明牧场 $X$ 的地势高于牧场 $Y$，即下坡的道路是从 $X$ 通向 $Y$ 的，$N$ 为贝西所在的牛棚（最高点），$1$ 为池塘（最低点）。\n\n然而，一周之后，贝西开始对单调的路线感到厌烦，她希望可以跑不同的路线。比如说，她希望能有 $K$ 种不同的路线。同时，为了避免跑得太累，她希望这 $K$ 条路线是从牛棚到池塘的路线中最短的 $K$ 条。如果两条路线包含的道路组成的序列不同，则这两条路线被认为是不同的。\n\n请帮助贝西算算她的训练强度，即将牧场网络里最短的 $K$ 条路径的长度分别算出来。你将会被提供一份牧场间路线的列表，每条道路用 $(X_i, Y_i, D_i)$ 表示，意为从 $X_i$ 到 $Y_i$ 有一条长度为 $D_i$ 的下坡道路。", "inputFormat": "第一行三个用空格分开的整数 $N,M,K$，其中 。\n\n第二行到第 $M+1$ 行每行有三个用空格分开的整数 $X_i,Y_i,D_i$，描述一条下坡的道路。", "outputFormat": "共 $K$ 行，在第 $i$ 行输出第 $i$ 短的路线长度，如果不存在则输出 $-1$。如果出现多种有相同长度的路线，务必将其全部输出。", "hint": "#### 样例 1 解释\n\n这些路线分别为 $(5\\to 1)$、$(5\\to 3\\to 1)$、$(5\\to 2\\to 1)$、$(5\\to 3\\to 2\\to 1)$、$(5\\to 4\\to 3\\to 1)$ 和 $(5\\to 4\\to 3\\to 2\\to 1)$。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\le N \\le 1,000$，$1 \\le M \\le 1\\times10^4$，$1 \\le K \\le 100$，$1 \\le Y_i < X_i\\le N$，$1 \\le D_i \\le 1\\times 10^6$， ", "locale": "zh-CN"}}}
{"pid": "P2902", "type": "P", "difficulty": 3, "samples": [["8 3 \n2 \n2 \n4 \n", "1 3 \n1 3 \n2 3 \n3 2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2008", "USACO", "Special Judge"], "title": "[USACO08MAR] Pearl Pairing G", "background": null, "description": "在 Bessie 最近的生日聚会上，她收到 $N(2\\le N \\le 10^5,N\\equiv0\\pmod{2})$ 颗珍珠。一共有 $C$ 种颜色的珍珠（$1\\le C \\le N$），第 $i$ 种颜色的珍珠有 $C_i$ 颗。\n\n\n观察到珍珠的数量 $N$ 总是偶数，她的创意来了，决定配对珍珠，使每对珍珠有两种不同的颜色。数据保证存在答案。请帮助 Bessie 执行这样的配对，如果有多种配对的方法，输出任意一种即可。", "inputFormat": "第 $1$ 行：两个空格分隔的整数：$N$ 和 $C$。\n\n第 $2\\ldots C+1$行：第 $i+1$ 为颜色 $i$ 的珍珠数 $C_i$。", "outputFormat": "第 $1\\ldots \\dfrac{N}{2}$ 行：第 $i$ 行包含两个整数 $a_i$ 和 $b_i$，表示 Bessie 可以将各自颜色为 $a_i$ 和 $b_i$ 的两个珍珠配对。", "hint": "说明：有 $8$ 颗珍珠和 $3$ 种不同的颜色。两颗珍珠颜色为 $1$，两颗珍珠颜色为 $2$，四颗珍珠颜色为 $3$。\n\nBessie 将每颗颜色为 $3$ 的珍珠与颜色为 $1$ 和 $2$ 的珍珠配对。\n\n感谢@[线段木](https://www.luogu.com.cn/user/33930) 提供翻译，@[PineappleSummer](https://www.luogu.com.cn/user/880187) 修正翻译以及提供 $\\LaTeX$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08MAR] Pearl Pairing G", "background": null, "description": "At Bessie's recent birthday party, she received $N(2 \\le N \\le 10^5,N\\equiv0\\pmod{2})$ pearls, each painted one of C different colors ($1\\le C \\le N$).\n\nUpon observing that the number of pearls $N$ is always even, her creative juices flowed and she decided to pair the pearls so that each pair of pearls has two different colors.\n\nKnowing that such a set of pairings is always possible for the supplied testcases, help Bessie perform such a pairing. If there are multiple ways of creating a pairing, any solution suffices.", "inputFormat": "Line $1$: Two space-separated integers: $N$ and $C$.\n\nLines $2 \\ldots C+1$: Line $i+1$ tells the count of pearls with color $i$: $C_i$.", "outputFormat": "Lines $1\\ldots \\dfrac{N}{2}$: Line $i$ contains two integers $a_i$ and $b_i$ indicating that Bessie can pair two pearls with respective colors $a_i$ and $b_i$.", "hint": "There are $8$ pearls and $3$ different colors. Two pearls have color $\\mathrm{I}$; two have color $\\mathrm{II}$; four have color $\\mathrm{III}$.\n\n\nBessie pairs each pearl of color $\\mathrm{III}$ with one of color $\\mathrm{I}$ and $\\mathrm{Ii}$.", "locale": "en"}, "zh-CN": {"title": "[USACO08MAR] Pearl Pairing G", "background": null, "description": "在 Bessie 最近的生日聚会上，她收到 $N(2\\le N \\le 10^5,N\\equiv0\\pmod{2})$ 颗珍珠。一共有 $C$ 种颜色的珍珠（$1\\le C \\le N$），第 $i$ 种颜色的珍珠有 $C_i$ 颗。\n\n\n观察到珍珠的数量 $N$ 总是偶数，她的创意来了，决定配对珍珠，使每对珍珠有两种不同的颜色。数据保证存在答案。请帮助 Bessie 执行这样的配对，如果有多种配对的方法，输出任意一种即可。", "inputFormat": "第 $1$ 行：两个空格分隔的整数：$N$ 和 $C$。\n\n第 $2\\ldots C+1$行：第 $i+1$ 为颜色 $i$ 的珍珠数 $C_i$。", "outputFormat": "第 $1\\ldots \\dfrac{N}{2}$ 行：第 $i$ 行包含两个整数 $a_i$ 和 $b_i$，表示 Bessie 可以将各自颜色为 $a_i$ 和 $b_i$ 的两个珍珠配对。", "hint": "说明：有 $8$ 颗珍珠和 $3$ 种不同的颜色。两颗珍珠颜色为 $1$，两颗珍珠颜色为 $2$，四颗珍珠颜色为 $3$。\n\nBessie 将每颗颜色为 $3$ 的珍珠与颜色为 $1$ 和 $2$ 的珍珠配对。\n\n感谢@[线段木](https://www.luogu.com.cn/user/33930) 提供翻译，@[PineappleSummer](https://www.luogu.com.cn/user/880187) 修正翻译以及提供 $\\LaTeX$。", "locale": "zh-CN"}}}
{"pid": "P2903", "type": "P", "difficulty": 3, "samples": [["4 32 54 \n0 0 10 \n0 30 20 \n32 54 20 \n-40 30 20 \n", "20000 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "2008", "USACO", "广度优先搜索 BFS"], "title": "[USACO08MAR] The Loathesome Hay Baler S", "background": "", "description": "Farmer John has purchased the world's most loathesome hay baler. Instead of having a drive-roller that drives maybe an idler roller that drives the power take-off for the baler, it has N rollers (2 <= N <= 1050) which drive and are driven by various rollers.\n\nFJ has meticulously cataloged data for each roller i: X\\_i,Y\\_i are the center of the roller (-5000 <= X\\_i <= 5000; -5000 <= Y\\_i <= 5000); R\\_i is the roller's radius (3 <= R\\_i <= 800). The drive-roller is located at 0,0; the baler power take-off is located at X\\_t,Y\\_t (numbers supplied in the input).\n\nThe drive-roller turns clockwise at 10,000 revolutions per hour. Your job is to determine the speeds of all the rollers that are in the power-train: from the drive-roller through the power take-off roller. Rollers that do not transfer power to the take-off roller are to be ignored. A roller of radius Rd that is turning at S rph and driving another roller of radius Rx will cause the second roller to turn at the speed -S\\*Rd/Rx (where the sign denotes whether the roller is turning clockwise or counterclockwise (anticlockwise for our British friends)).\n\nDetermine the power-train path and report the sum of the absolute values of all those rollers' speeds. All the rollers in the input set except the driver-roller are driven by some other roller; power is never transferred to a roller from more than one other roller.\n\nReport your answer as an integer that is the truncated value after summing all the speeds.", "inputFormat": "\\* Line 1: Three space-separated integers: N, X\\_t, and Y\\_t\n\n\\* Lines 2..N+1: Line i+1 describes roller i's properties: X\\_i, Y\\_i, and R\\_i", "outputFormat": "\\* Line 1: A single integer that is the truncated version of the sum of the absolute value of the speeds of the rollers in the power-train including the drive-roller, all the driven rollers, and the power take-off roller.", "hint": "$2 \\leq N \\leq 1050$，$-5000 \\leq x,y \\leq 5000$，$3 \\leq r \\leq 800$。\n\n\n\n\nFour rollers: the drive-roller at 0,0 with radius 10. It drives the roller above it at 0,30 with radius 20. That roller drives both the power take-off roller at 32,54 (r=20) and a random roller (not in the power train) at -40,30 (r=20).\n\n\nRoller   Radius   Speed\n\n1 (0,0)     10     10,000 \n\n2 (0,30)    20     -5,000 \n\n3 (32,54)   20      5,000 \n\n------\nSum of abs values: 20,000\n", "locale": "en", "translations": {"en": {"title": "[USACO08MAR] The Loathesome Hay Baler S", "background": "", "description": "Farmer John has purchased the world's most loathesome hay baler. Instead of having a drive-roller that drives maybe an idler roller that drives the power take-off for the baler, it has N rollers (2 <= N <= 1050) which drive and are driven by various rollers.\n\nFJ has meticulously cataloged data for each roller i: X\\_i,Y\\_i are the center of the roller (-5000 <= X\\_i <= 5000; -5000 <= Y\\_i <= 5000); R\\_i is the roller's radius (3 <= R\\_i <= 800). The drive-roller is located at 0,0; the baler power take-off is located at X\\_t,Y\\_t (numbers supplied in the input).\n\nThe drive-roller turns clockwise at 10,000 revolutions per hour. Your job is to determine the speeds of all the rollers that are in the power-train: from the drive-roller through the power take-off roller. Rollers that do not transfer power to the take-off roller are to be ignored. A roller of radius Rd that is turning at S rph and driving another roller of radius Rx will cause the second roller to turn at the speed -S\\*Rd/Rx (where the sign denotes whether the roller is turning clockwise or counterclockwise (anticlockwise for our British friends)).\n\nDetermine the power-train path and report the sum of the absolute values of all those rollers' speeds. All the rollers in the input set except the driver-roller are driven by some other roller; power is never transferred to a roller from more than one other roller.\n\nReport your answer as an integer that is the truncated value after summing all the speeds.", "inputFormat": "\\* Line 1: Three space-separated integers: N, X\\_t, and Y\\_t\n\n\\* Lines 2..N+1: Line i+1 describes roller i's properties: X\\_i, Y\\_i, and R\\_i", "outputFormat": "\\* Line 1: A single integer that is the truncated version of the sum of the absolute value of the speeds of the rollers in the power-train including the drive-roller, all the driven rollers, and the power take-off roller.", "hint": "$2 \\leq N \\leq 1050$，$-5000 \\leq x,y \\leq 5000$，$3 \\leq r \\leq 800$。\n\n\n\n\nFour rollers: the drive-roller at 0,0 with radius 10. It drives the roller above it at 0,30 with radius 20. That roller drives both the power take-off roller at 32,54 (r=20) and a random roller (not in the power train) at -40,30 (r=20).\n\n\nRoller   Radius   Speed\n\n1 (0,0)     10     10,000 \n\n2 (0,30)    20     -5,000 \n\n3 (32,54)   20      5,000 \n\n------\nSum of abs values: 20,000\n", "locale": "en"}, "zh-CN": {"title": "[USACO08MAR] The Loathesome Hay Baler S", "background": null, "description": "Farmer John 新买的干草打包机的内部结构大概算世界上最混乱的了，它不像普通的机器一样有明确的内部传动装置，而是 $N$ 个齿轮互相作用，每个齿轮都可能驱动着多个齿轮。 FJ 记录了对于每个齿轮 $i$，记录了它的 $3$ 个参数，以一个三元组 $(x,y,r)$ 表示，$x$ 和 $y$ 表示齿轮中心的位置坐标，$r$ 表示该齿轮的半径。\n\n驱动齿轮的位置为 $(0,0)$，并且 FJ 也知道最终的工作齿轮位于 $(X_t,Y_t)$。 驱动齿轮顺时针转动，转速为 $10,000$ 转/小时。你的任务是，确定传动序列中所有齿轮的转速。传动序列的定义为，能量由驱动齿轮传送到工作齿轮的过程中用到的所有齿轮的集合。对能量传送无意义的齿轮都应当被忽略。\n\n在一个半径为 $R_d$，转速为 $S$ 转/每小时的齿轮的带动下，与它相接的半径为 $R_x$ 的齿轮的转速将为 $-S\\times \\frac{R_d}{R_x}$ 转/小时。$S$ 前的负号的意思是，一个齿轮带动的另一个齿轮的转向会与它的转向相反。\n\nFJ 只对整个传动序列中所有齿轮速度的绝对值之和感兴趣，你的任务也就相应转化成求这个值。机器中除了驱动齿轮以外的所有齿轮都被另外某个齿轮带动，并且不会出现 $2$ 个不同的齿轮带动同一个齿轮的情况。", "inputFormat": "第一行，三个整数，分别代表 $N,X_t,Y_t$；\n\n第 $2$ 行到第 $N+1$ 行，每行三个整数，代表一个三元组 $(x,y,r)$。", "outputFormat": "输出共一行，一个整数，代表整个传动序列中所有齿轮速度的绝对值之和。", "hint": "$2 \\leq N \\leq 1050$，$-5000 \\leq x,y \\leq 5000$，$3 \\leq r \\leq 800$。\n\n有四个齿轮：驱动齿轮位于 $0,0$，半径为 $10$。它驱动位于 $0,30$、半径为 $20$ 的齿轮。该齿轮又驱动动力输出齿轮，位于 $32,54$（$r=20$）和一个随机齿轮（不在动力传动系统中），位于 $-40,30$（$r=20$）。\n\n|齿轮 |半径 |速度 |\n|:-:|:-:|:-:|\n|  $1$ $(0,0)$ | $10$  | $10000$  |\n|  $2$ $(0,30)$ | $20$  | $5000$  |\n|  $3$ $(32,54)$ | $20$  |  $-5000$ |\n\n\n绝对值之和：$20000$。", "locale": "zh-CN"}}}
{"pid": "P2904", "type": "P", "difficulty": 3, "samples": [["5 10 \n3 \n4 \n6 \n100 \n1 \n", "50 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "USACO", "背包 DP"], "title": "[USACO08MAR] River Crossing S", "background": "", "description": "Farmer John is herding his N cows (1 <= N <= 2,500) across the expanses of his farm when he finds himself blocked by a river. A single raft is available for transportation.\n\nFJ knows that he must ride on the raft for all crossings and that that adding cows to the raft makes it traverse the river more slowly.\n\nWhen FJ is on the raft alone, it can cross the river in M minutes (1 <= M <= 1000).  When the i cows are added, it takes M\\_i minutes (1 <= M\\_i <= 1000) longer to cross the river than with i-1 cows (i.e., total M+M\\_1 minutes with one cow, M+M\\_1+M\\_2 with two, etc.). Determine the minimum time it takes for Farmer John to get all of the cows across the river (including time returning to get more cows).", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: M\\_i\n", "outputFormat": "\\* Line 1: The minimum time it takes for Farmer John to get all of the cows across the river.\n", "hint": "There are five cows. Farmer John takes 10 minutes to cross the river alone, 13 with one cow, 17 with two cows, 23 with three, 123 with four, and 124 with all five.\n\n\nFarmer John can first cross with three cows (23 minutes), then return (10 minutes), and then cross with the last two (17 minutes). 23+10+17 = 50 minutes total.\n", "locale": "en", "translations": {"en": {"title": "[USACO08MAR] River Crossing S", "background": "", "description": "Farmer John is herding his N cows (1 <= N <= 2,500) across the expanses of his farm when he finds himself blocked by a river. A single raft is available for transportation.\n\nFJ knows that he must ride on the raft for all crossings and that that adding cows to the raft makes it traverse the river more slowly.\n\nWhen FJ is on the raft alone, it can cross the river in M minutes (1 <= M <= 1000).  When the i cows are added, it takes M\\_i minutes (1 <= M\\_i <= 1000) longer to cross the river than with i-1 cows (i.e., total M+M\\_1 minutes with one cow, M+M\\_1+M\\_2 with two, etc.). Determine the minimum time it takes for Farmer John to get all of the cows across the river (including time returning to get more cows).", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: M\\_i\n", "outputFormat": "\\* Line 1: The minimum time it takes for Farmer John to get all of the cows across the river.\n", "hint": "There are five cows. Farmer John takes 10 minutes to cross the river alone, 13 with one cow, 17 with two cows, 23 with three, 123 with four, and 124 with all five.\n\n\nFarmer John can first cross with three cows (23 minutes), then return (10 minutes), and then cross with the last two (17 minutes). 23+10+17 = 50 minutes total.\n", "locale": "en"}, "zh-CN": {"title": "[USACO08MAR] River Crossing S", "background": null, "description": "农夫约翰以及他的 $N(1 \\le N \\le 2500)$ 头奶牛打算过一条河，但他们所有的渡河工具，仅仅是一个木筏。 \n\n由于奶牛不会划船，在整个渡河过程中，约翰必须始终在木筏上。在这个基础上，木筏上的奶牛数目每增加 $1$，FJ把木筏划到对岸就得花更多的时间。 \n\n当约翰一个人坐在木筏上，他把木筏划到对岸需要 $M(1 \\le M \\le 1000)$ 分钟。当木筏搭载的奶牛数目从 $i-1$ 增加到 $i$ 时，约翰得多花 $M_i(1 \\le M_i \\le 1000)$ 分钟才能把木筏划过河（也就是说，船上有 $1$ 头奶牛时，约翰得花 $M+M_1$ 分钟渡河；船上有 $2$ 头奶牛时，时间就变成 $M+M_1+M_2$ 分钟。后面的以此类推）。那么，约翰最少要花多少时间，才能把所有奶牛带到对岸呢？当然，这个时间得包括约翰一个人把木筏从对岸划回来接下一批的奶牛的时间。", "inputFormat": "* 第一行包含 $2$ 个整数 $N$ 和 $M$。\n* 第 $2$ 行至第 $N + 1$ 行，其中第 $i + 1$ 行包含 $1$ 个整数 $M_i$。", "outputFormat": "* 输出共 $1$ 行，为农夫约翰让所有奶牛过河所需的最短时间。", "hint": "有五头牛，农夫约翰独自过河需要 $10$ 分钟，带一头牛需要 $13$ 分钟，带两头牛需要 $17$ 分钟，带三头牛需要 $23$ 分钟，带四头牛需要 $123$ 分钟，带五头牛需要 $124$ 分钟。\n\n农夫约翰可以先带三头牛过河（$23$ 分钟），然后独自返回（$10$ 分钟），再带最后两头牛过河（$17$ 分钟）。总共耗时 $23+10+17=50$ 分钟。", "locale": "zh-CN"}}}
{"pid": "P2905", "type": "P", "difficulty": 5, "samples": [["3 6 3 \n3 4 \n6 2 \n5 7 \n8 2 \n9 2 \n6 4 \n5 4 \n6 7 \n8 7 \n", "6 \nEEE \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "2008", "USACO"], "title": "[USACO08OPEN] Crisis on the Farm G", "background": null, "description": "约翰和他的奶牛组建了一只乐队“后街奶牛”，现在他们正在牧场里排练。奶牛们分成一堆一堆，共 $N$ 堆。每一堆里，$30$ 只奶牛一只踩在另一只的背上，叠成一座牛塔。牧场里还有 $M$ 个高高的草垛。\n\n作为出色的指挥家，约翰可以通过口哨指挥奶牛们移动。他的口哨有四个音，分别能使所有的牛塔向东南西北四个方向移动一格。\n\n每一次，当一个牛塔到达了一个草垛所在的格子，牛塔最上方的奶牛就会跳到草垛上，而且不再下来，而其他奶牛仍然呈塔状站在草垛所在的格子里。当牛塔只剩一只奶牛时，这只奶牛也会跳到草垛上。\n\n突然，约翰大惊失色：原来邻家的奶缸爆炸了！滚滚而下的牛奶正朝着约翰的牧场冲来，不久就要将牧场淹没。约翰必须马上行动，用口哨声挽救奶牛们的生命。他要指挥奶牛尽量多地跳上草垛，草垛上的奶牛将不会被淹死。\n\n约翰还有 $K$ 次吹口哨的机会。那他最多还能救多少奶牛呢？请计算最多能挽救的奶牛数，以及达到这个数目约翰需要吹的口哨调子序列。序列用 $\\mathtt{E,W,S,N}$ 表示东西南北。如果有多种序列能达到要求，输出字典序最小的。", "inputFormat": "第一行三个正整数 $N,M,K$。\n\n下面 $N$ 行，每行两个正整数 $X_i,Y_i$，表示一个奶牛堆的坐标 $(X_i,Y_i)$。\n\n下面 $M$ 行，每行两个正整数 $X_i,Y_i$，表示一个草垛的坐标 $(X_i,Y_i)$。", "outputFormat": "第一行输出一个整数表示最多能挽救的奶牛数。\n\n第一行输出一个长度为 $K$ 的字符串表示达到这个数目约翰需要吹的字典序最小的口哨调子序列。", "hint": "样例解释：\n\n$3$ 声哨子吹完后，$3$ 个草堆各挽救了一只奶牛。\n\n---\n\n对于 $100\\%$ 的数据，$1\\le K\\le 30$，$1\\le N,M,X_i,Y_i\\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08OPEN] Crisis on the Farm G", "background": "", "description": "John and his cows have formed a band called \"Backstreet Cows,\" and they are rehearsing on the pasture. The cows are grouped into $N$ piles. In each pile, $30$ cows stand one on another, forming a tower. There are also $M$ tall haystacks on the pasture.\n\nAs a skilled conductor, John can use four whistle tones. Each tone makes all towers move one cell in one of the four directions: east, west, south, or north.\n\nEach time a tower reaches a cell that contains a haystack, the cow at the top of the tower jumps onto the haystack and stays there, while the remaining cows continue to stand as a tower on that cell. When only one cow remains in a tower, that cow also jumps onto the haystack.\n\nSuddenly, the neighbor’s milk tank explodes. A torrent of milk is rushing toward John’s pasture and will flood it soon. John must act immediately and use whistle tones to save as many cows as possible. Cows on haystacks will not drown.\n\nJohn has $K$ whistle blows left. How many cows can he save at most? Compute the maximum number of cows that can be saved, and a sequence of whistle tones to achieve it. The sequence is represented by $\\mathtt{E, W, S, N}$ for east, west, south, and north. If multiple sequences achieve the maximum, output the lexicographically smallest one.", "inputFormat": "- The first line contains three positive integers $N, M, K$.\n- The next $N$ lines each contain two positive integers $X_i, Y_i$, the coordinates $(X_i, Y_i)$ of a cow pile.\n- The next $M$ lines each contain two positive integers $X_i, Y_i$, the coordinates $(X_i, Y_i)$ of a haystack.", "outputFormat": "- The first line contains an integer, the maximum number of cows that can be saved.\n- The second line contains a string of length $K$ that is the lexicographically smallest whistle tone sequence achieving that maximum.", "hint": "Sample explanation:\n\nAfter $3$ whistles, $3$ haystacks each save one cow.\n\nConstraints:\n\nFor $100\\%$ of the testdata, $1 \\le K \\le 30$, $1 \\le N, M, X_i, Y_i \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO08OPEN] Crisis on the Farm G", "background": null, "description": "约翰和他的奶牛组建了一只乐队“后街奶牛”，现在他们正在牧场里排练。奶牛们分成一堆一堆，共 $N$ 堆。每一堆里，$30$ 只奶牛一只踩在另一只的背上，叠成一座牛塔。牧场里还有 $M$ 个高高的草垛。\n\n作为出色的指挥家，约翰可以通过口哨指挥奶牛们移动。他的口哨有四个音，分别能使所有的牛塔向东南西北四个方向移动一格。\n\n每一次，当一个牛塔到达了一个草垛所在的格子，牛塔最上方的奶牛就会跳到草垛上，而且不再下来，而其他奶牛仍然呈塔状站在草垛所在的格子里。当牛塔只剩一只奶牛时，这只奶牛也会跳到草垛上。\n\n突然，约翰大惊失色：原来邻家的奶缸爆炸了！滚滚而下的牛奶正朝着约翰的牧场冲来，不久就要将牧场淹没。约翰必须马上行动，用口哨声挽救奶牛们的生命。他要指挥奶牛尽量多地跳上草垛，草垛上的奶牛将不会被淹死。\n\n约翰还有 $K$ 次吹口哨的机会。那他最多还能救多少奶牛呢？请计算最多能挽救的奶牛数，以及达到这个数目约翰需要吹的口哨调子序列。序列用 $\\mathtt{E,W,S,N}$ 表示东西南北。如果有多种序列能达到要求，输出字典序最小的。", "inputFormat": "第一行三个正整数 $N,M,K$。\n\n下面 $N$ 行，每行两个正整数 $X_i,Y_i$，表示一个奶牛堆的坐标 $(X_i,Y_i)$。\n\n下面 $M$ 行，每行两个正整数 $X_i,Y_i$，表示一个草垛的坐标 $(X_i,Y_i)$。", "outputFormat": "第一行输出一个整数表示最多能挽救的奶牛数。\n\n第一行输出一个长度为 $K$ 的字符串表示达到这个数目约翰需要吹的字典序最小的口哨调子序列。", "hint": "样例解释：\n\n$3$ 声哨子吹完后，$3$ 个草堆各挽救了一只奶牛。\n\n---\n\n对于 $100\\%$ 的数据，$1\\le K\\le 30$，$1\\le N,M,X_i,Y_i\\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P2906", "type": "P", "difficulty": 6, "samples": [["4 2 \n1 1 \n3 3 \n2 2 \n10 10 \n", "2 3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO", "并查集", "平衡树", "生成树"], "title": "[USACO08OPEN] Cow Neighborhoods G", "background": "", "description": "了解奶牛的人都知道奶牛是如何组成「奶牛社区」的。他们观察了 Farmer John 的 $N$ 头奶牛（编号为 $1 \\sim N$），它们在 $X$ 和 $Y$ 坐标范围为 $1$ 的牧场上放牧，每头奶牛都在自己唯一的整数直线坐标上。\n\n如果满足以下两个标准中的至少一个，则两头奶牛是邻居：\n\n1. 两只奶牛的曼哈顿距离不超过 $C$，即 $|X_i - x_i| + |Y_i - y_i| \\leq C$；\n2. 两只奶牛有共同的邻居。即存在一只奶牛 $k$，使 $i$ 与 $k$，$j$ 与 $k$ 均同属一个群。\n\n给定奶牛的位置和距离 $C$，确定「奶牛社区」的数量和最大的「奶牛社区」中的奶牛数量。\n\n例如，考虑下面的牧场。 当 $C = 4$ 时，这个牧场有四个社区：左边的一个大社区，两个大小为 1 的社区，右边有一个巨大的社区，里面有 $60$ 头不同的奶牛。\n\n```text\n.....................................*.................\n....*...*..*.......................***.................\n......*...........................****.................\n..*....*..*.......................*...*.******.*.*.....\n........................*.............***...***...*....\n*..*..*...*..........................*..*...*..*...*...\n.....................................*..*...*..*.......\n.....................................*..*...*..*.......\n...*................*..................................\n.*..*............................*.*.*.*.*.*.*.*.*.*.*.\n.*.....*..........................*.*.*.*.*.*.*.*.*.*.*\n....*..................................................\n```", "inputFormat": "第 $1$ 行包含两个用空格分隔的整数 $N, C$。\n\n第 $2$ 到第 $N + 1$ 行每行包含两个用空格分隔的整数 $X_i, Y_i$，表示一头牛的坐标。\n", "outputFormat": "\n共一行，为两个用空格分隔的整数，为「奶牛社区」的数量和最大的「奶牛社区」内牛的数量。", "hint": "### 样例说明 #1\n\n样例中有 $2$ 个社区，一个由前三头奶牛组成，另一个是最后一头奶牛。因此，最大的社区大小为 $3$。\n\n### 数据范围与约定\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 10^5$，$1 \\leq C \\leq 10^9$，$1 \\leq X_i, Y_i \\leq 10^9$，$X_i, Y_i$ 均为整数。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08OPEN] Cow Neighborhoods G", "background": "", "description": "People who know cows understand how they form \"cow neighborhoods.\" They observed Farmer John’s $N$ cows (numbered $1$ through $N$) grazing on a pasture modeled as a plane with $X$ and $Y$ coordinates starting from $1$, where each cow is located at a unique integer lattice point.\n\nTwo cows are neighbors if at least one of the following criteria holds:\n1. Their Manhattan distance is at most $C$, i.e., $|X_i - X_j| + |Y_i - Y_j| \\leq C$.\n2. They share a common neighbor; that is, there exists a cow $k$ such that $i$ and $k$, and $j$ and $k$, both belong to the same group.\n\nGiven the cows’ positions and the distance $C$, determine the number of \"cow neighborhoods\" and the number of cows in the largest \"cow neighborhood.\"\n\nFor example, consider the pasture below. When $C = 4$, this pasture has four neighborhoods: one large neighborhood on the left, two neighborhoods of size $1$, and a huge neighborhood on the right containing $60$ distinct cows.\n\n```text\n.....................................*.................\n....*...*..*.......................***.................\n......*...........................****.................\n..*....*..*.......................*...*.******.*.*.....\n........................*.............***...***...*....\n*..*..*...*..........................*..*...*..*...*...\n.....................................*..*...*..*.......\n.....................................*..*...*..*.......\n...*................*..................................\n.*..*............................*.*.*.*.*.*.*.*.*.*.*.\n.*.....*..........................*.*.*.*.*.*.*.*.*.*.*\n....*..................................................\n```", "inputFormat": "The first line contains two space-separated integers $N, C$.\n\nEach of the next $N$ lines contains two space-separated integers $X_i, Y_i$, giving the coordinates of a cow.", "outputFormat": "Output a single line with two space-separated integers: the number of \"cow neighborhoods\" and the size of the largest \"cow neighborhood.\"", "hint": "Sample Explanation #1\n\nThere are $2$ neighborhoods in the sample: one formed by the first three cows, and the other by the last cow. Therefore, the largest neighborhood size is $3$.\n\nConstraints\n\nFor $100\\%$ of the testdata, $1 \\leq N \\leq 10^5$, $1 \\leq C \\leq 10^9$, $1 \\leq X_i, Y_i \\leq 10^9$, and $X_i, Y_i$ are integers.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO08OPEN] Cow Neighborhoods G", "background": "", "description": "了解奶牛的人都知道奶牛是如何组成「奶牛社区」的。他们观察了 Farmer John 的 $N$ 头奶牛（编号为 $1 \\sim N$），它们在 $X$ 和 $Y$ 坐标范围为 $1$ 的牧场上放牧，每头奶牛都在自己唯一的整数直线坐标上。\n\n如果满足以下两个标准中的至少一个，则两头奶牛是邻居：\n\n1. 两只奶牛的曼哈顿距离不超过 $C$，即 $|X_i - x_i| + |Y_i - y_i| \\leq C$；\n2. 两只奶牛有共同的邻居。即存在一只奶牛 $k$，使 $i$ 与 $k$，$j$ 与 $k$ 均同属一个群。\n\n给定奶牛的位置和距离 $C$，确定「奶牛社区」的数量和最大的「奶牛社区」中的奶牛数量。\n\n例如，考虑下面的牧场。 当 $C = 4$ 时，这个牧场有四个社区：左边的一个大社区，两个大小为 1 的社区，右边有一个巨大的社区，里面有 $60$ 头不同的奶牛。\n\n```text\n.....................................*.................\n....*...*..*.......................***.................\n......*...........................****.................\n..*....*..*.......................*...*.******.*.*.....\n........................*.............***...***...*....\n*..*..*...*..........................*..*...*..*...*...\n.....................................*..*...*..*.......\n.....................................*..*...*..*.......\n...*................*..................................\n.*..*............................*.*.*.*.*.*.*.*.*.*.*.\n.*.....*..........................*.*.*.*.*.*.*.*.*.*.*\n....*..................................................\n```", "inputFormat": "第 $1$ 行包含两个用空格分隔的整数 $N, C$。\n\n第 $2$ 到第 $N + 1$ 行每行包含两个用空格分隔的整数 $X_i, Y_i$，表示一头牛的坐标。\n", "outputFormat": "\n共一行，为两个用空格分隔的整数，为「奶牛社区」的数量和最大的「奶牛社区」内牛的数量。", "hint": "### 样例说明 #1\n\n样例中有 $2$ 个社区，一个由前三头奶牛组成，另一个是最后一头奶牛。因此，最大的社区大小为 $3$。\n\n### 数据范围与约定\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 10^5$，$1 \\leq C \\leq 10^9$，$1 \\leq X_i, Y_i \\leq 10^9$，$X_i, Y_i$ 均为整数。", "locale": "zh-CN"}}}
{"pid": "P2907", "type": "P", "difficulty": 1, "samples": [["6 2 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO", "递归"], "title": "[USACO08OPEN] Roads Around The Farm S", "background": "", "description": "Farmer John's cows have taken an interest in exploring the territory around the farm. Initially, all N (1 <= N <= 1,000,000,000) cows commence traveling down a road in one big group. Upon encountering a fork in the road, the group sometimes chooses to break into two smaller (nonempty) groups with each group continuing down one of the roads.  When one of those groups arrives at another fork, it might split again, and so on.\n\nThe cows have crafted a peculiar way of splitting: if they can split into two groups such that the sizes of the groups differ by exactly K (1 <= K <= 1000), then they will split in that way; otherwise, they stop exploring and just start grazing peacefully.\n\nAssuming that there will always be new forks in the road, compute the final number of groups of peacefully grazing cows.", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n", "outputFormat": "\\* Line 1: A single integer representing the number of groups of grazing cows\n", "hint": "There are 6 cows and the difference in group sizes is 2.\n\n\nThere are 3 final groups (with 2, 1, and 3 cows in them). \n\n```plain\n  6\n / \\\n2   4\n   / \\\n  1   3\n```", "locale": "en", "translations": {"en": {"title": "[USACO08OPEN] Roads Around The Farm S", "background": "", "description": "Farmer John's cows have taken an interest in exploring the territory around the farm. Initially, all N (1 <= N <= 1,000,000,000) cows commence traveling down a road in one big group. Upon encountering a fork in the road, the group sometimes chooses to break into two smaller (nonempty) groups with each group continuing down one of the roads.  When one of those groups arrives at another fork, it might split again, and so on.\n\nThe cows have crafted a peculiar way of splitting: if they can split into two groups such that the sizes of the groups differ by exactly K (1 <= K <= 1000), then they will split in that way; otherwise, they stop exploring and just start grazing peacefully.\n\nAssuming that there will always be new forks in the road, compute the final number of groups of peacefully grazing cows.", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n", "outputFormat": "\\* Line 1: A single integer representing the number of groups of grazing cows\n", "hint": "There are 6 cows and the difference in group sizes is 2.\n\n\nThere are 3 final groups (with 2, 1, and 3 cows in them). \n\n```plain\n  6\n / \\\n2   4\n   / \\\n  1   3\n```", "locale": "en"}, "zh-CN": {"title": "[USACO08OPEN] Roads Around The Farm S", "background": null, "description": "Farmer John 的奶牛对探索农场周围的领地产生了兴趣。最初，所有 $N$ 头奶牛（$1 \\leq N \\leq 10^9$）以一个大群体的形式开始沿着一条道路旅行。当遇到岔路时，群体有时会选择分成两个较小的（非空）群体，每个群体沿着一条道路继续前进。当其中一个群体到达另一个岔路时，它可能会再次分裂，依此类推。\n\n奶牛们设计了一种特殊的分裂方式：如果它们可以分裂成两个群体，使得群体的大小正好相差 $K$（$1 \\leq K \\leq 1000$），那么它们就会以这种方式分裂；否则，它们就停止探索，开始安静地吃草。\n\n假设总是会有新的岔路，计算最终安静吃草的奶牛群的数量。", "inputFormat": "两个空格分隔的整数，$N$ 和 $K$。", "outputFormat": "一个整数，表示安静吃草的奶牛群的数量。", "hint": "有 $6$ 头奶牛，群体大小的差异是 $2$。\n\n最终有 $3$ 个群体（分别有 $2$、$1$ 和 $3$ 头奶牛）。\n\n```plain\n  6\n / \\\n2   4\n   / \\\n  1   3\n```\n\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2908", "type": "P", "difficulty": 2, "samples": [["5 3 \nBessie \nJonathan \nMontgomery \nAlicia \nAngola \nse \nnGo \nOnt \n", "1 \n1 \n2 \n0 \n1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "2008", "USACO"], "title": "[USACO08OPEN] Word Power S", "background": null, "description": "约翰想要计算他那 $N(l \\le N \\le 1000)$ 只奶牛的名字的能量。每只奶牛的名字由不超过 $1000$ 个字符构成，没有一个名字是空字符串。\n\n约翰有一张“能量字符串表”，上面有 $M(1 \\le M \\le 100)$ 个代表能量的字符串。每个字符串由不超过 $30$ 个字符构成，同样不存在空字符串。一个奶牛的名字蕴含多少个能量字符串，这个名字就有多少能量。所谓“蕴含”，是指某个能量字符串的所有字符都在名字串中按顺序出现（不一定一个紧接着一个）。\n\n所有的大写字母和小写字母都是等价的。比如，在贝茜的名字 `Bessie` 里，蕴含有 `Be`、`si`、`EE`、`Es` 等等字符串，但不蕴含 `Ls` 或 `eB`。请帮约翰计算他的奶牛的名字的能量。", "inputFormat": "第一行两个正整数 $N,M$。\n\n下面 $N$ 行，每行一个字符串，代表一只奶牛的名字。\n\n下面 $M$ 行，每行一个字符串，代表一个能量字符串。", "outputFormat": "对每个名字输出一行一个整数表示其能量值。", "hint": "样例解释：\n\n|奶牛名字|`se`|`nGo`|`Ont`|\n|:-:|:-:|:-:|:-:|\n|`Bessie`|蕴含|不蕴含|不蕴含|\n|`Jonathan`|不蕴含|不蕴含|蕴含|\n|`Montgomery`|不蕴含|蕴含|蕴含|\n|`Alicia`|不蕴含|不蕴含|不蕴含|\n|`Angola`|不蕴含|蕴含|不蕴含|", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08OPEN] Word Power S", "background": null, "description": "Farmer John wants to evaluate the quality of the names of his $N (1 \\le N \\le 1000)$ cows. Each name is a string with no more than 1000 characters, all of which are non-blank.\n\nHe has created a set of $M (1 \\le M \\le 100)$ 'good' strings (no longer than 30 characters and fully non-blank). If the sequence letters of a cow's name contains the letters of a 'good' string in the correct order as a subsequence (i.e., not necessarily all next to each other), the cow's name gets 1 quality point.\n\nAll strings is case-insensitive, i.e., capital letters and lower case letters are considered equivalent. For example, the name $\\texttt{Bessie}$ contains the letters of $\\texttt{Be}$, $\\texttt{sI}$, $\\texttt{EE}$, and $\\text{Es}$ in the correct order, but not $\\texttt{is}$ or $\\texttt{eB}$. Help Farmer John determine the number of quality points in each of his cow's names.", "inputFormat": "* Line $1$: Two space-separated integers: $N$ and $M$.\n\n* Lines $2 \\sim N+1$: Line $i+1$ contains a string that is the name of the ith cow.\n\n* Lines $N+2 \\sim N+M+1$: Line $N+i+1$ contains the ith good string.", "outputFormat": "* Lines $1 \\sim N+1$: Line $i+1$ contains the number of quality points of the ith name.", "hint": "There are 5 cows, and their names are $\\texttt{Bessie}$, $\\texttt{Jonathan}$, $\\texttt{Montgomery}$, $\\texttt{Alicia}$, and $\\texttt{Angola}$. The 3 good strings are $\\texttt{se}$, $\\texttt{nGo}$, and $\\texttt{Ont}$.\n\n$\\texttt{Bessie}$ contains $\\texttt{se}$, $\\texttt{Jonathan}$ contains $\\texttt{Ont}$, $\\texttt{Montgomery}$ contains both $\\texttt{nGo}$ and $\\texttt{Ont}$, $\\texttt{Alicia}$ contains none of the good strings, and $\\texttt{Angola}$ contains $\\texttt{nGo}$.", "locale": "en"}, "zh-CN": {"title": "[USACO08OPEN] Word Power S", "background": null, "description": "约翰想要计算他那 $N(l \\le N \\le 1000)$ 只奶牛的名字的能量。每只奶牛的名字由不超过 $1000$ 个字符构成，没有一个名字是空字符串。\n\n约翰有一张“能量字符串表”，上面有 $M(1 \\le M \\le 100)$ 个代表能量的字符串。每个字符串由不超过 $30$ 个字符构成，同样不存在空字符串。一个奶牛的名字蕴含多少个能量字符串，这个名字就有多少能量。所谓“蕴含”，是指某个能量字符串的所有字符都在名字串中按顺序出现（不一定一个紧接着一个）。\n\n所有的大写字母和小写字母都是等价的。比如，在贝茜的名字 `Bessie` 里，蕴含有 `Be`、`si`、`EE`、`Es` 等等字符串，但不蕴含 `Ls` 或 `eB`。请帮约翰计算他的奶牛的名字的能量。", "inputFormat": "第一行两个正整数 $N,M$。\n\n下面 $N$ 行，每行一个字符串，代表一只奶牛的名字。\n\n下面 $M$ 行，每行一个字符串，代表一个能量字符串。", "outputFormat": "对每个名字输出一行一个整数表示其能量值。", "hint": "样例解释：\n\n|奶牛名字|`se`|`nGo`|`Ont`|\n|:-:|:-:|:-:|:-:|\n|`Bessie`|蕴含|不蕴含|不蕴含|\n|`Jonathan`|不蕴含|不蕴含|蕴含|\n|`Montgomery`|不蕴含|蕴含|蕴含|\n|`Alicia`|不蕴含|不蕴含|不蕴含|\n|`Angola`|不蕴含|蕴含|不蕴含|", "locale": "zh-CN"}}}
{"pid": "P2909", "type": "P", "difficulty": 2, "samples": [["3 1 1 5 \n5 \n7 \n5 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2008", "USACO", "排序"], "title": "[USACO08OPEN] Cow Cars S", "background": "", "description": "N (1 <= N <= 50,000) cows conveniently numbered 1..N are driving in separate cars along a highway in Cowtopia. Cow i can drive in any of M different high lanes (1 <= M <= N) and can travel at a maximum speed of S\\_i (1 <= S\\_i <= 1,000,000) km/hour.\n\nAfter their other bad driving experience, the cows hate collisions and take extraordinary measures to avoid them. On this highway, cow i reduces its speed by D (0 <= D <= 5,000) km/hour for each cow in front of it on the highway (though never below 0 km/hour). Thus, if there are K cows in front of cow i, the cow will travel at a speed of max[S\\_i - D \\* K, 0]. While a cow might actually travel faster than a cow directly in front of it, the cows are spaced far enough apart so crashes will not occur once cows slow down as\n\ndescribed,\n\nCowtopia has a minimum speed law which requires everyone on the highway to travel at a a minimum speed of L (1 <= L <= 1,000,000) km/hour so sometimes some of the cows will be unable to take the highway if they follow the rules above. Write a program that will find the maximum number of cows that can drive on the highway while obeying the minimum speed limit law.\n", "inputFormat": "\\* Line 1: Four space-separated integers: N, M, D, and L\n\n\\* Lines 2..N+1: Line i+1 describes cow i's initial speed with a single integer: S\\_i\n", "outputFormat": "\\* Line 1: A single integer representing the maximum number of cows that can use the highway\n", "hint": "There are three cows with one lane to drive on, a speed decrease of 1, and a minimum speed limit of 5.\n\n\nTwo cows are possible, by putting either cow with speed 5 first and the cow with speed 7 second.\n", "locale": "en", "translations": {"en": {"title": "[USACO08OPEN] Cow Cars S", "background": "", "description": "N (1 <= N <= 50,000) cows conveniently numbered 1..N are driving in separate cars along a highway in Cowtopia. Cow i can drive in any of M different high lanes (1 <= M <= N) and can travel at a maximum speed of S\\_i (1 <= S\\_i <= 1,000,000) km/hour.\n\nAfter their other bad driving experience, the cows hate collisions and take extraordinary measures to avoid them. On this highway, cow i reduces its speed by D (0 <= D <= 5,000) km/hour for each cow in front of it on the highway (though never below 0 km/hour). Thus, if there are K cows in front of cow i, the cow will travel at a speed of max[S\\_i - D \\* K, 0]. While a cow might actually travel faster than a cow directly in front of it, the cows are spaced far enough apart so crashes will not occur once cows slow down as\n\ndescribed,\n\nCowtopia has a minimum speed law which requires everyone on the highway to travel at a a minimum speed of L (1 <= L <= 1,000,000) km/hour so sometimes some of the cows will be unable to take the highway if they follow the rules above. Write a program that will find the maximum number of cows that can drive on the highway while obeying the minimum speed limit law.\n", "inputFormat": "\\* Line 1: Four space-separated integers: N, M, D, and L\n\n\\* Lines 2..N+1: Line i+1 describes cow i's initial speed with a single integer: S\\_i\n", "outputFormat": "\\* Line 1: A single integer representing the maximum number of cows that can use the highway\n", "hint": "There are three cows with one lane to drive on, a speed decrease of 1, and a minimum speed limit of 5.\n\n\nTwo cows are possible, by putting either cow with speed 5 first and the cow with speed 7 second.\n", "locale": "en"}, "zh-CN": {"title": "[USACO08OPEN] Cow Cars S", "background": "", "description": "在 Cowtopia 的高速公路上，有 $N$ 头奶牛（$1 \\leq N \\leq 50,000$），它们被方便地编号为 $1..N$，分别驾驶着不同的汽车。奶牛 $i$ 可以在 $M$ 条不同的高速车道上行驶（$1 \\leq M \\leq N$），并且可以以最大速度 $S_i$（$1 \\leq S_i \\leq 1,000,000$）公里/小时行驶。\n\n在经历了其他糟糕的驾驶体验后，奶牛们讨厌碰撞，并采取了极端措施来避免它们。在这条高速公路上，奶牛 $i$ 会因为在它前面的每一头奶牛而将速度减少 $D$（$0 \\leq D \\leq 5,000$）公里/小时（但速度不会低于 0 公里/小时）。因此，如果在奶牛 $i$ 前面有 $K$ 头奶牛，那么它将以 $\\max[S_i - D \\times K, 0]$ 的速度行驶。虽然奶牛实际上可能比直接在它前面的奶牛行驶得更快，但奶牛之间的间距足够大，因此一旦奶牛减速，就不会发生碰撞。\n\nCowtopia 有一条最低速度法则，要求高速公路上的所有车辆都必须以最低速度 $L$（$1 \\leq L \\leq 1,000,000$）公里/小时行驶，因此有时一些奶牛在遵循上述规则时将无法上高速公路。编写一个程序，找出在遵守最低速度限制法的情况下，能够在高速公路上行驶的最大奶牛数量。\n", "inputFormat": "\\* 第 1 行：四个以空格分隔的整数：$N$，$M$，$D$ 和 $L$\n\n\\* 第 2 行到第 $N+1$ 行：第 $i+1$ 行用一个整数描述奶牛 $i$ 的初始速度：$S_i$\n", "outputFormat": "\\* 第 1 行：一个整数，表示可以使用高速公路的最大奶牛数量\n", "hint": "有三头奶牛，只有一条车道可供行驶，速度减少为 1，最低速度限制为 5。\n\n\n可以让两头奶牛上高速公路，方法是先让速度为 5 的奶牛上路，然后让速度为 7 的奶牛上路。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2910", "type": "P", "difficulty": 3, "samples": [["3 4 \n1 \n2 \n1 \n3 \n0 5 1 \n5 0 2 \n1 2 0 \n", "7 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO", "最短路"], "title": "[USACO08OPEN] Clear And Present Danger S", "background": null, "description": "Farmer John is on a boat seeking fabled treasure on one of the $N (1 \\le N \\le 100)$ islands conveniently labeled $1 \\sim N$ in the Cowribbean Sea.\n\nThe treasure map tells him that he must travel through a certain sequence $A_1, A_2, \\dots, A_M$ of $M (2 \\le M \\le 10^4)$ islands, starting on island $1$ and ending on island $N$ before the treasure will appear to him. He can visit these and other islands out of order and even more than once, but his trip must include the $A_i$ sequence in the order specified by the map.\n\nFJ wants to avoid pirates and knows the pirate-danger rating $(0 \\le danger \\le 10^5)$ between each pair of islands. The total danger rating of his mission is the sum of the danger ratings of all the paths he traverses.\n\nHelp Farmer John find the least dangerous route to the treasure that satisfies the treasure map's requirement.", "inputFormat": "Line $1$: Two space-separated integers: $N$ and $M$.\n\nLines $2 \\sim M+1$: Line $i+1$ describes the $i$-th island FJ must visit with a single integer: $A_i$.\n\nLines $M+2\\sim N+M+1$: Line $i+M+1$ contains $N$ space-separated integers that are the respective danger rating of the path between island i and islands $1, 2, \\dots$, and $N$, respectively. The ith integer is always zero.", "outputFormat": "Line $1$: The minimum danger that Farmer John can encounter while obtaining the treasure.", "hint": "There are $3$ islands and the treasure map requires Farmer John to visit a sequence of $4$ islands in order: island $1$, island $2$, island $1$ again, and finally island $3$. The danger ratings of the paths are given: the paths $(1, 2); (2, 3); (3, 1)$ and the reverse paths have danger ratings of $5, 2$, and $1$, respectively.\n\n\nHe can get the treasure with a total danger of $7$ by traveling in the sequence of islands $1, 3, 2, 3, 1$, and $3$. The cow map's requirement ($1, 2, 1$, and $3$) is satisfied by this route. We avoid the path between islands $1$ and $2$ because it has a large danger rating.", "locale": "en", "translations": {"en": {"title": "[USACO08OPEN] Clear And Present Danger S", "background": null, "description": "Farmer John is on a boat seeking fabled treasure on one of the $N (1 \\le N \\le 100)$ islands conveniently labeled $1 \\sim N$ in the Cowribbean Sea.\n\nThe treasure map tells him that he must travel through a certain sequence $A_1, A_2, \\dots, A_M$ of $M (2 \\le M \\le 10^4)$ islands, starting on island $1$ and ending on island $N$ before the treasure will appear to him. He can visit these and other islands out of order and even more than once, but his trip must include the $A_i$ sequence in the order specified by the map.\n\nFJ wants to avoid pirates and knows the pirate-danger rating $(0 \\le danger \\le 10^5)$ between each pair of islands. The total danger rating of his mission is the sum of the danger ratings of all the paths he traverses.\n\nHelp Farmer John find the least dangerous route to the treasure that satisfies the treasure map's requirement.", "inputFormat": "Line $1$: Two space-separated integers: $N$ and $M$.\n\nLines $2 \\sim M+1$: Line $i+1$ describes the $i$-th island FJ must visit with a single integer: $A_i$.\n\nLines $M+2\\sim N+M+1$: Line $i+M+1$ contains $N$ space-separated integers that are the respective danger rating of the path between island i and islands $1, 2, \\dots$, and $N$, respectively. The ith integer is always zero.", "outputFormat": "Line $1$: The minimum danger that Farmer John can encounter while obtaining the treasure.", "hint": "There are $3$ islands and the treasure map requires Farmer John to visit a sequence of $4$ islands in order: island $1$, island $2$, island $1$ again, and finally island $3$. The danger ratings of the paths are given: the paths $(1, 2); (2, 3); (3, 1)$ and the reverse paths have danger ratings of $5, 2$, and $1$, respectively.\n\n\nHe can get the treasure with a total danger of $7$ by traveling in the sequence of islands $1, 3, 2, 3, 1$, and $3$. The cow map's requirement ($1, 2, 1$, and $3$) is satisfied by this route. We avoid the path between islands $1$ and $2$ because it has a large danger rating.", "locale": "en"}, "zh-CN": {"title": "[USACO08OPEN] Clear And Present Danger S", "background": null, "description": "农夫约翰正驾驶一条小艇在牛勒比海上航行。\n\n海上有 $N(1\\leq N\\leq 100)$ 个岛屿，用 $1$ 到 $N$ 编号。约翰从 $1$ 号小岛出发，最后到达 $N$ 号小岛。\n\n一张藏宝图上说，如果他的路程上经过的小岛依次出现了  $A_1,A_2,\\dots ,A_M(2\\leq M\\leq 10000)$ 这样的序列（不一定相邻），那他最终就能找到古老的宝藏。但是，由于牛勒比海有海盗出没，约翰知道任意两个岛屿之间的航线上海盗出没的概率，他用一个危险指数 $D_{i,j}(0\\leq D_{i,j}\\leq 100000)$ 来描述。他希望他的寻宝活动经过的航线危险指数之和最小。那么，在找到宝藏的前提下，这个最小的危险指数是多少呢？", "inputFormat": "第一行：两个用空格隔开的正整数 $N$ 和 $M$。\n\n第二到第 $M+1$ 行：第 $i+1$ 行用一个整数 $A_i$ 表示 FJ 必须经过的第 $i$ 个岛屿。保证 $A_1=1,A_M=N$。\n\n第 $M+2$ 到第 $N+M+1$ 行：第 $i+M+1$ 行包含 $N$ 个用空格隔开的非负整数分别表示 $i$ 号小岛到第 $1\\dots N$ 号小岛的航线各自的危险指数。保证第 $i$ 个数是 $0$。", "outputFormat": "第一行：FJ 在找到宝藏的前提下经过的航线的危险指数之和的最小值。", "hint": "### 样例说明 #1\n这组数据中有三个岛屿，藏宝图要求 FJ 按顺序经过四个岛屿：$1$ 号岛屿、$2$ 号岛屿、回到 $1$ 号岛屿、最后到 $3$ 号岛屿。每条航线的危险指数也给出了：航路$(1,2),(2,3),(3,1)$ 和它们的反向路径的危险指数分别是 $5,2,1$。\n\nFJ 可以通过依次经过 $1,3,2,3,1,3$ 号岛屿以 $7$ 的最小总危险指数获得宝藏。这条道路满足了奶牛地图的要求 $(1,2,1,3)$。我们避开了 $1$ 号和 $2$ 号岛屿之间的航线，因为它的危险指数太大了。\n\n注意：测试数据中 $a$ 到 $b$ 的危险指数不一定等于 $b$ 到 $a$ 的危险指数！\n\nTranslated by @LJC00125", "locale": "zh-CN"}}}
{"pid": "P2911", "type": "P", "difficulty": 1, "samples": [["3 2 3 \n", "5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO", "枚举", "期望"], "title": "[USACO08OCT] Bovine Bones G", "background": null, "description": "Bessie loves board games and role-playing games so she persuaded Farmer John to drive her to the hobby shop where she purchased three dice for rolling. These fair dice have $S_1$, $S_2$, and $S_3$ sides respectively ($2 \\le S_1 \\le 20; 2 \\le S_2 \\le 20; 2 \\le S_3 \\le 40$). \n\nBessie rolls and rolls and rolls trying to figure out which three-dice sum appears most often.\n\nGiven the number of sides on each of the three dice, determine which three-dice sum appears most frequently. If more than one sum can appear most frequently, report the smallest such sum.\n\nPOINTS: $70$", "inputFormat": "\\* Line 1: Three space-separated integers: $S_1$, $S_2$, and $S_3$.", "outputFormat": "\\* Line 1: The smallest integer sum that appears most frequently when the dice are rolled in every possible combination.", "hint": "Here are all the possible outcomes.\n\n```\n1 1 1 -> 3  \n1 2 1 -> 4  \n2 1 1 -> 4  \n2 2 1 -> 5  \n3 1 1 -> 5  \n3 2 1 -> 6 \n1 1 2 -> 4  \n1 2 2 -> 5  \n2 1 2 -> 5  \n2 2 2 -> 6  \n3 1 2 -> 6  \n3 2 2 -> 7 \n1 1 3 -> 5  \n1 2 3 -> 6  \n2 1 3 -> 6  \n2 2 3 -> 7  \n3 1 3 -> 7  \n3 2 3 -> 8\n```\nBoth 5 and 6 appear most frequently (five times each), so 5 is the answer.", "locale": "en", "translations": {"en": {"title": "[USACO08OCT] Bovine Bones G", "background": null, "description": "Bessie loves board games and role-playing games so she persuaded Farmer John to drive her to the hobby shop where she purchased three dice for rolling. These fair dice have $S_1$, $S_2$, and $S_3$ sides respectively ($2 \\le S_1 \\le 20; 2 \\le S_2 \\le 20; 2 \\le S_3 \\le 40$). \n\nBessie rolls and rolls and rolls trying to figure out which three-dice sum appears most often.\n\nGiven the number of sides on each of the three dice, determine which three-dice sum appears most frequently. If more than one sum can appear most frequently, report the smallest such sum.\n\nPOINTS: $70$", "inputFormat": "\\* Line 1: Three space-separated integers: $S_1$, $S_2$, and $S_3$.", "outputFormat": "\\* Line 1: The smallest integer sum that appears most frequently when the dice are rolled in every possible combination.", "hint": "Here are all the possible outcomes.\n\n```\n1 1 1 -> 3  \n1 2 1 -> 4  \n2 1 1 -> 4  \n2 2 1 -> 5  \n3 1 1 -> 5  \n3 2 1 -> 6 \n1 1 2 -> 4  \n1 2 2 -> 5  \n2 1 2 -> 5  \n2 2 2 -> 6  \n3 1 2 -> 6  \n3 2 2 -> 7 \n1 1 3 -> 5  \n1 2 3 -> 6  \n2 1 3 -> 6  \n2 2 3 -> 7  \n3 1 3 -> 7  \n3 2 3 -> 8\n```\nBoth 5 and 6 appear most frequently (five times each), so 5 is the answer.", "locale": "en"}, "zh-CN": {"title": "[USACO08OCT] Bovine Bones G", "background": null, "description": "Bessie 喜欢桌游和角色扮演游戏，所以她说服了 Farmer John 驾车送她去爱好商店，在那里她购买了三个用于掷骰子的骰子。这些公平的骰子分别有 $S_1$、$S_2$ 和 $S_3$ 个面（$2 \\leq S_1 \\leq 20$；$2 \\leq S_2 \\leq 20$；$2 \\leq S_3 \\leq 40$），上面分别包含 $1$ 到 $S_1$，$S_2$ 和 $S_3$ 之间的所有整数。Bessie 不断地掷骰子，试图找出哪个三个骰子的点数和出现得最频繁。如果有多个和出现得最频繁，输出其中最小的和。", "inputFormat": "第 1 行：三个用空格分隔的整数：$S_1$、$S_2$ 和 $S_3$。", "outputFormat": "第 1 行：当骰子以每种可能的组合掷出时，出现次数最多的最小整数和。", "hint": "这里是所有可能的结果。\n\n```\n1 1 1 -> 3  \n1 2 1 -> 4  \n2 1 1 -> 4  \n2 2 1 -> 5  \n3 1 1 -> 5  \n3 2 1 -> 6 \n1 1 2 -> 4  \n1 2 2 -> 5  \n2 1 2 -> 5  \n2 2 2 -> 6  \n3 1 2 -> 6  \n3 2 2 -> 7 \n1 1 3 -> 5  \n1 2 3 -> 6  \n2 1 3 -> 6  \n2 2 3 -> 7  \n3 1 3 -> 7  \n3 2 3 -> 8\n```\n\n5 和 6 都出现得最频繁（各五次），所以答案是 5。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P2912", "type": "P", "difficulty": 3, "samples": [["4 2 \n2 1 2 \n4 3 2 \n1 4 3 \n1 2 \n3 2 \n", "2 \n7 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO"], "title": "[USACO08OCT] Pasture Walking G", "background": null, "description": "The $N$ cows ($2 \\le N \\le 1,000$) conveniently numbered $1$…$N$ are grazing among the $N$ pastures also conveniently numbered $1$…$N$. Most conveniently of all, cow $i$ is grazing in pasture $i$.\n\nSome pairs of pastures are connected by one of $N-1$ bidirectional walkways that the cows can traverse. Walkway $i$ connects pastures $A_i$ and $B_i$ ($1 \\le A_i \\le N; 1 \\le B_i \\le N$) and has a length of $L_i$ ($1 \\le L_i \\le 10,000$).\n\nThe walkways are set up in such a way that between any two distinct pastures, there is exactly one path of walkways that travels between them. Thus, the walkways form a tree.\n\nThe cows are very social and wish to visit each other often. Ever in a hurry, they want you to help them schedule their visits by computing the lengths of the paths between $1 \\le L_i \\le 10,000$ pairs of pastures (each pair given as a query $p1$,$p2$ ($1 \\le p1 \\le N; 1 \\le p2 \\le N$).\n\nPOINTS: 200\n\n有$N$（$2 \\le N \\le 1,000$）头奶牛，编号为 $1$ 到 $N$，它们正在同样编号为 $1$ 到 $N$ 的牧场上行走.为了方便，我们假设编号为 $i$ 的牛恰好在第 $i$ 号牧场上。\n\n有一些牧场间每两个牧场用一条双向道路相连，道路总共有 $N - 1$ 条，奶牛可以在这些道路上行走。第i条道路把第 $A_i$ 个牧场和第 $B_i$ 个牧场连了起来（$1 \\le A_i \\le N; 1 \\le B_i \\le N$），而它的长度是 $1 \\le L_i \\le 10,000$ 在任意两个牧场间，有且仅有一条由若干道路组成的路径相连。也就是说，所有的道路构成了一棵树。\n\n奶牛们十分希望经常互相见面。它们十分着急，所以希望你帮助它们计划它们的行程，你只 需要计算出 $Q$（$1 < Q < 1000$）对点之间的路径长度。每对点以一个询问 $p1$，$p2$ ($1 \\le p1 \\le N; 1 \\le p2 \\le N$) 的形式给出。", "inputFormat": "\\* Line 1: Two space-separated integers: $N$ and $Q$\n\n\\* Lines $2$…$N$: Line $i+1$ contains three space-separated integers: $A_i$, $B_i$, and $L_i$\n\n\\* Lines $N+1$…$N+Q$: Each line contains two space-separated integers representing two distinct pastures between which the cows wish to travel: $p1$ and $p2$", "outputFormat": "\\* Lines $1$…$Q$: Line $i$ contains the length of the path between the two pastures in query $i$.", "hint": "Query 1: The walkway between pastures $1$ and $2$ has length $2$.\n\nQuery 2: Travel through the walkway between pastures $3$ and $4$, then the one between $4$ and $1$, and finally the one between $1$ and $2$, for a total length of $7$.", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08OCT] Pasture Walking G", "background": "", "description": "The $N$ cows ($2 \\le N \\le 1,000$), conveniently numbered $1$…$N$, are grazing among the $N$ pastures also conveniently numbered $1$…$N$. Most conveniently of all, cow $i$ is grazing in pasture $i$.\n\nSome pairs of pastures are connected by one of $N - 1$ bidirectional walkways that the cows can traverse. Walkway $i$ connects pastures $A_i$ and $B_i$ ($1 \\le A_i \\le N; 1 \\le B_i \\le N$) and has a length of $L_i$ ($1 \\le L_i \\le 10,000$).\n\nThe walkways are set up so that between any two distinct pastures, there is exactly one path of walkways that travels between them. Thus, the walkways form a tree.\n\nThe cows are very social and wish to visit each other often. Being in a hurry, they want you to help schedule their visits by computing the lengths of the paths for $Q$ pairs of pastures ($1 < Q < 1,000$). Each pair is given as a query $p1$, $p2$ ($1 \\le p1 \\le N; 1 \\le p2 \\le N$).", "inputFormat": "* Line 1: Two space-separated integers $N$ and $Q$.\n* Lines $2$…$N$: Line $i+1$ contains three space-separated integers $A_i$, $B_i$, and $L_i$.\n* Lines $N+1$…$N+Q$: Each line contains two space-separated integers representing two distinct pastures between which the cows wish to travel: $p1$ and $p2$.", "outputFormat": "* Lines $1$…$Q$: Line $i$ contains the length of the path between the two pastures in query $i$.", "hint": "Query 1: The walkway between pastures $1$ and $2$ has length $2$.\n\nQuery 2: Travel through the walkway between pastures $3$ and $4$, then the one between $4$ and $1$, and finally the one between $1$ and $2$, for a total length of $7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO08OCT] Pasture Walking G", "background": null, "description": "The $N$ cows ($2 \\le N \\le 1,000$) conveniently numbered $1$…$N$ are grazing among the $N$ pastures also conveniently numbered $1$…$N$. Most conveniently of all, cow $i$ is grazing in pasture $i$.\n\nSome pairs of pastures are connected by one of $N-1$ bidirectional walkways that the cows can traverse. Walkway $i$ connects pastures $A_i$ and $B_i$ ($1 \\le A_i \\le N; 1 \\le B_i \\le N$) and has a length of $L_i$ ($1 \\le L_i \\le 10,000$).\n\nThe walkways are set up in such a way that between any two distinct pastures, there is exactly one path of walkways that travels between them. Thus, the walkways form a tree.\n\nThe cows are very social and wish to visit each other often. Ever in a hurry, they want you to help them schedule their visits by computing the lengths of the paths between $1 \\le L_i \\le 10,000$ pairs of pastures (each pair given as a query $p1$,$p2$ ($1 \\le p1 \\le N; 1 \\le p2 \\le N$).\n\nPOINTS: 200\n\n有$N$（$2 \\le N \\le 1,000$）头奶牛，编号为 $1$ 到 $N$，它们正在同样编号为 $1$ 到 $N$ 的牧场上行走.为了方便，我们假设编号为 $i$ 的牛恰好在第 $i$ 号牧场上。\n\n有一些牧场间每两个牧场用一条双向道路相连，道路总共有 $N - 1$ 条，奶牛可以在这些道路上行走。第i条道路把第 $A_i$ 个牧场和第 $B_i$ 个牧场连了起来（$1 \\le A_i \\le N; 1 \\le B_i \\le N$），而它的长度是 $1 \\le L_i \\le 10,000$ 在任意两个牧场间，有且仅有一条由若干道路组成的路径相连。也就是说，所有的道路构成了一棵树。\n\n奶牛们十分希望经常互相见面。它们十分着急，所以希望你帮助它们计划它们的行程，你只 需要计算出 $Q$（$1 < Q < 1000$）对点之间的路径长度。每对点以一个询问 $p1$，$p2$ ($1 \\le p1 \\le N; 1 \\le p2 \\le N$) 的形式给出。", "inputFormat": "\\* Line 1: Two space-separated integers: $N$ and $Q$\n\n\\* Lines $2$…$N$: Line $i+1$ contains three space-separated integers: $A_i$, $B_i$, and $L_i$\n\n\\* Lines $N+1$…$N+Q$: Each line contains two space-separated integers representing two distinct pastures between which the cows wish to travel: $p1$ and $p2$", "outputFormat": "\\* Lines $1$…$Q$: Line $i$ contains the length of the path between the two pastures in query $i$.", "hint": "Query 1: The walkway between pastures $1$ and $2$ has length $2$.\n\nQuery 2: Travel through the walkway between pastures $3$ and $4$, then the one between $4$ and $1$, and finally the one between $1$ and $2$, for a total length of $7$.", "locale": "zh-CN"}}}
{"pid": "P2913", "type": "P", "difficulty": 2, "samples": [["4 \n2 3 0 \n3 4 1 \n1 2 0 \n", "1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO"], "title": "[USACO08OCT] Wheel Rotation G", "background": "", "description": "Farmer John has an old-time thresher (wheat harvester) that requires belts to be installed on various gears to turn the parts. The engine drives pulley 1 in a clockwise direction which attaches via a belt to pulley 2. Pulley 2 attaches via a belt to pulley 3 and so on through a total of N (2 <= N <= 1,000) pulleys (and N-1 belts).\n\nThe diagram above depicts the two ways a belt can be installed between two gears. In this illustration, pulley 1's belt directly drives pulley 2 (a 'straight' connection) and thus they will rotate in the same direction. Pulley 3 drives pulley 4 via a 'crossed belt' that reverses the direction of the rotation.\n\nGiven a list of the belt types that connect the pulleys along with the fact that pulley 1 is driven in a clockwise direction by the engine, determine the drive direction of pulley N. Each belt is described by three integers:\n\n```cpp\n* S_i -- the driving (source) pulley \n* D_i -- the driven (destination) pulley \n* C_i -- the connection type (0=straight, 1=crossed) \nUnfortunately, FJ lists the belts in random order. \nBy way of example, consider the illustration below. N = 4, and pulley 1 is driven clockwise by the thresher engine. Straight \nbelts drive pulley 2 and then pulley 3, so they rotate clockwise. The crosswise belt reverses the rotation direction so pulley 4 (pulley N) rotates counterclockwise. \n```\nPOINTS: 70\n约翰有一个过时的收割机，需要在它的各种滑轮上装配皮带才能让收割机的各个部分运作起 来.引擎能够驱动滑轮1向顺时针方向转动，滑轮1通过一条皮带又连接到滑轮2.滑轮2又通过一 条皮带连接到滑轮3，等等，总共有N(2 <= N <= 1000)个滑轮和N - 1条皮带.\n\n皮带连接两个滑轮有两种方式：直接连接和交叉连接.直接连接的两个滑轮旋转方向相同， 即同为顺时针或同为逆时针.交叉连接的两个滑轮旋转方向相反.\n\n现在给出一个列表，里面列出所有皮带的连接方式.已经知道滑轮1被引擎驱动着向顺时针方 向转动.每一条皮带由下面三个数定义：\n\n•驱动滑轮S，输入驱动力的滑轮.\n\n•被驱动滑轮D;，被驱使转动的滑轮.\n\n•连接类型C，0表示直接连接，1表示交叉连接.\n\n不幸的是，约翰的这个列表中，皮带的顺序是混乱的.所以请你写一个程序来求出滑轮N的 转动方向.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N: Each line describes a belt with three integers: S\\_i, D\\_i, and C\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the rotation direction for pulley N (0=clockwise, 1=counterclockwise)\n", "hint": "As in the example illustration.\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08OCT] Wheel Rotation G", "background": "", "description": "Farmer John has an old-time thresher that uses belts on pulleys to transmit motion. The engine drives pulley 1 in a clockwise direction. Pulley 1 is connected to pulley 2 by a belt, pulley 2 to pulley 3, and so on, for a total of $N$ pulleys ($2 \\le N \\le 1000$) and $N - 1$ belts.\n\nThere are two ways to install a belt between two pulleys:\n- Straight connection: the two pulleys rotate in the same direction.\n- Crossed connection: the two pulleys rotate in opposite directions.\n\nYou are given a list of all belts. Each belt is specified by three integers:\n- $S_i$: the driving (source) pulley.\n- $D_i$: the driven (destination) pulley.\n- $C_i$: the connection type ($0$ = straight, $1$ = crossed).\n\nThe belts are listed in random order. Knowing that pulley 1 rotates clockwise, determine the rotation direction of pulley $N$.\n\n```cpp\n* S_i -- the driving (source) pulley \n* D_i -- the driven (destination) pulley \n* C_i -- the connection type (0=straight, 1=crossed) \nUnfortunately, FJ lists the belts in random order. \nBy way of example, consider the illustration below. N = 4, and pulley 1 is driven clockwise by the thresher engine. Straight \nbelts drive pulley 2 and then pulley 3, so they rotate clockwise. The crosswise belt reverses the rotation direction so pulley 4 (pulley N) rotates counterclockwise. \n```", "inputFormat": "- Line 1: A single integer $N$.\n- Lines 2 to $N$: Each line describes a belt with three integers $S_i$, $D_i$, and $C_i$.", "outputFormat": "- Line 1: A single integer indicating the rotation direction of pulley $N$ ($0$ = clockwise, $1$ = counterclockwise).", "hint": "As in the example illustration.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO08OCT] Wheel Rotation G", "background": "", "description": "Farmer John has an old-time thresher (wheat harvester) that requires belts to be installed on various gears to turn the parts. The engine drives pulley 1 in a clockwise direction which attaches via a belt to pulley 2. Pulley 2 attaches via a belt to pulley 3 and so on through a total of N (2 <= N <= 1,000) pulleys (and N-1 belts).\n\nThe diagram above depicts the two ways a belt can be installed between two gears. In this illustration, pulley 1's belt directly drives pulley 2 (a 'straight' connection) and thus they will rotate in the same direction. Pulley 3 drives pulley 4 via a 'crossed belt' that reverses the direction of the rotation.\n\nGiven a list of the belt types that connect the pulleys along with the fact that pulley 1 is driven in a clockwise direction by the engine, determine the drive direction of pulley N. Each belt is described by three integers:\n\n```cpp\n* S_i -- the driving (source) pulley \n* D_i -- the driven (destination) pulley \n* C_i -- the connection type (0=straight, 1=crossed) \nUnfortunately, FJ lists the belts in random order. \nBy way of example, consider the illustration below. N = 4, and pulley 1 is driven clockwise by the thresher engine. Straight \nbelts drive pulley 2 and then pulley 3, so they rotate clockwise. The crosswise belt reverses the rotation direction so pulley 4 (pulley N) rotates counterclockwise. \n```\nPOINTS: 70\n约翰有一个过时的收割机，需要在它的各种滑轮上装配皮带才能让收割机的各个部分运作起 来.引擎能够驱动滑轮1向顺时针方向转动，滑轮1通过一条皮带又连接到滑轮2.滑轮2又通过一 条皮带连接到滑轮3，等等，总共有N(2 <= N <= 1000)个滑轮和N - 1条皮带.\n\n皮带连接两个滑轮有两种方式：直接连接和交叉连接.直接连接的两个滑轮旋转方向相同， 即同为顺时针或同为逆时针.交叉连接的两个滑轮旋转方向相反.\n\n现在给出一个列表，里面列出所有皮带的连接方式.已经知道滑轮1被引擎驱动着向顺时针方 向转动.每一条皮带由下面三个数定义：\n\n•驱动滑轮S，输入驱动力的滑轮.\n\n•被驱动滑轮D;，被驱使转动的滑轮.\n\n•连接类型C，0表示直接连接，1表示交叉连接.\n\n不幸的是，约翰的这个列表中，皮带的顺序是混乱的.所以请你写一个程序来求出滑轮N的 转动方向.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N: Each line describes a belt with three integers: S\\_i, D\\_i, and C\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the rotation direction for pulley N (0=clockwise, 1=counterclockwise)\n", "hint": "As in the example illustration.\n", "locale": "zh-CN"}}}
{"pid": "P2914", "type": "P", "difficulty": 4, "samples": [["9 3 \n2.0 \n0 0 \n0 1 \n1 1 \n2 1 \n2 2 \n3 2 \n3 3 \n4 1 \n4 3 \n1 2 \n2 3 \n3 4 \n", "2828 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO"], "title": "[USACO08OCT] Power Failure G", "background": "", "description": "A vicious thunderstorm has destroyed some of the wires of the farm's electrical power grid! Farmer John has a map of all $N$ ($2\\le N \\le 1000$) of the powerpoles, which are conveniently numbered $1\\ldots N$ and located on integer plane coordinates $(x_i,y_i)$ ($-100000 \\le x_i \\le 100000, -100000 \\le y_i \\le 100000$).\n\nSome $W$ ($1 \\le W \\le 10000$) power wires connect pairs of power poles $P_i$ and $P_j$ ($1 \\le Pi \\le N, 1 \\le Pj \\le N$).\n\nHe needs to get power from pole $1$ to pole $N$ (which means that some series of wires can traverse from pole $1$ to pole $N$, probably through some intermediate set of poles).\n\nGiven the locations of the $N$ poles and the list of remaining power wires, determine the minimum length of power wire required to restore the electrical connection so that electricity can flow from pole $1$ to pole $N$.  No wire can be longer than some real number $M$ ($0.0 < M \\le 200000.0$).\n\nAs an example, below on the left is a map of the $9$ poles and $3$ wires after the storm. For this task, $M = 2.0$. The best set of wires to add would connect poles $4$ and $6$ and also poles $6$ and $9$.\n\n```cpp\n   After the storm              Optimally reconnected\n3  . . . 7 9 . . . . .          3  . . . 7 9 . . . . .\n                                          /\n2  . . 5 6 . . . . . .          2  . . 5 6 . . . . . .\n                                        /\n1  2-3-4 . 8 . . . . .          1  2-3-4 . 8 . . . . .\n   |                               |\n0  1 . . . . . . . . .          0  1 . . . . . . . . .\n\n   0 1 2 3 4 5 6 7 8 9             0 1 2 3 4 5 6 7 8 9\n```\n\nThe total length is then $1.414213562 + 1.414213562 = 2.828427124$.\n\nPOINTS: 350\n", "inputFormat": "Line $1$: Two space-separated integers: $N$ and $W$.\n\nLine $2$: A single real number: $M$.\n\nLines $3\\ldots N+2$: Each line contains two space-separated integers: $x_i$ and $y_i$.\n\nLines $N+3\\ldots N+2+W$: Two space-separated integers: $P_i$ and $P_j$.\n", "outputFormat": "Line 1: A single integer on a single line. If restoring connection is impossible, output `-1`. Otherwise, output a single integer that is $1000$ times the total minimum cost to restoreelectricity. Do not perform any rounding; truncate the resulting product.\n", "hint": "Just as in the diagram above.\n\n\nAs above.\n", "locale": "en", "translations": {"en": {"title": "[USACO08OCT] Power Failure G", "background": "", "description": "A vicious thunderstorm has destroyed some of the wires of the farm's electrical power grid! Farmer John has a map of all $N$ ($2\\le N \\le 1000$) of the powerpoles, which are conveniently numbered $1\\ldots N$ and located on integer plane coordinates $(x_i,y_i)$ ($-100000 \\le x_i \\le 100000, -100000 \\le y_i \\le 100000$).\n\nSome $W$ ($1 \\le W \\le 10000$) power wires connect pairs of power poles $P_i$ and $P_j$ ($1 \\le Pi \\le N, 1 \\le Pj \\le N$).\n\nHe needs to get power from pole $1$ to pole $N$ (which means that some series of wires can traverse from pole $1$ to pole $N$, probably through some intermediate set of poles).\n\nGiven the locations of the $N$ poles and the list of remaining power wires, determine the minimum length of power wire required to restore the electrical connection so that electricity can flow from pole $1$ to pole $N$.  No wire can be longer than some real number $M$ ($0.0 < M \\le 200000.0$).\n\nAs an example, below on the left is a map of the $9$ poles and $3$ wires after the storm. For this task, $M = 2.0$. The best set of wires to add would connect poles $4$ and $6$ and also poles $6$ and $9$.\n\n```cpp\n   After the storm              Optimally reconnected\n3  . . . 7 9 . . . . .          3  . . . 7 9 . . . . .\n                                          /\n2  . . 5 6 . . . . . .          2  . . 5 6 . . . . . .\n                                        /\n1  2-3-4 . 8 . . . . .          1  2-3-4 . 8 . . . . .\n   |                               |\n0  1 . . . . . . . . .          0  1 . . . . . . . . .\n\n   0 1 2 3 4 5 6 7 8 9             0 1 2 3 4 5 6 7 8 9\n```\n\nThe total length is then $1.414213562 + 1.414213562 = 2.828427124$.\n\nPOINTS: 350\n", "inputFormat": "Line $1$: Two space-separated integers: $N$ and $W$.\n\nLine $2$: A single real number: $M$.\n\nLines $3\\ldots N+2$: Each line contains two space-separated integers: $x_i$ and $y_i$.\n\nLines $N+3\\ldots N+2+W$: Two space-separated integers: $P_i$ and $P_j$.\n", "outputFormat": "Line 1: A single integer on a single line. If restoring connection is impossible, output `-1`. Otherwise, output a single integer that is $1000$ times the total minimum cost to restoreelectricity. Do not perform any rounding; truncate the resulting product.\n", "hint": "Just as in the diagram above.\n\n\nAs above.\n", "locale": "en"}, "zh-CN": {"title": "[USACO08OCT] Power Failure G", "background": "", "description": "一场猛烈的雷暴摧毁了农场电力网的一些电线！农夫约翰有一张所有 $N$ 根电线杆的地图（$2 \\le N \\le 1000$），这些电线杆被方便地编号为 $1\\ldots N$，并位于整数平面坐标 $(x_i, y_i)$ 上（$-100000 \\le x_i \\le 100000, -100000 \\le y_i \\le 100000$）。\n\n有 $W$ 根电线（$1 \\le W \\le 10000$）连接成对的电线杆 $P_i$ 和 $P_j$（$1 \\le P_i \\le N, 1 \\le P_j \\le N$）。\n\n他需要从电线杆 $1$ 获取电力到电线杆 $N$（这意味着一些电线可以从电线杆 $1$ 通过某些中间电线杆传输到电线杆 $N$）。\n\n给定 $N$ 根电线杆的位置和剩余电线的列表，确定恢复电力连接所需的最小电线长度，以便电力可以从电线杆 $1$ 流向电线杆 $N$。没有电线可以长于某个实数 $M$（$0.0 < M \\le 200000.0$）。\n\n例如，下面左侧是暴风雨后 $9$ 根电线杆和 $3$ 根电线的地图。对于这个任务，$M = 2.0$。最佳的电线连接方案是连接电线杆 $4$ 和 $6$，以及电线杆 $6$ 和 $9$。\n\n```cpp\n   暴风雨后                  最优重新连接\n3  . . . 7 9 . . . . .          3  . . . 7 9 . . . . .\n                                          /\n2  . . 5 6 . . . . . .          2  . . 5 6 . . . . . .\n                                        /\n1  2-3-4 . 8 . . . . .          1  2-3-4 . 8 . . . . .\n   |                               |\n0  1 . . . . . . . . .          0  1 . . . . . . . . .\n\n   0 1 2 3 4 5 6 7 8 9             0 1 2 3 4 5 6 7 8 9\n```\n\n总长度为 $1.414213562 + 1.414213562 = 2.828427124$。\n\n分值：350\n", "inputFormat": "第 $1$ 行：两个用空格分隔的整数：$N$ 和 $W$。\n\n第 $2$ 行：一个实数：$M$。\n\n第 $3\\ldots N+2$ 行：每行包含两个用空格分隔的整数：$x_i$ 和 $y_i$。\n\n第 $N+3\\ldots N+2+W$ 行：两个用空格分隔的整数：$P_i$ 和 $P_j$。\n", "outputFormat": "第 1 行：单独一行上的一个整数。如果无法恢复连接，输出 `-1`。否则，输出一个整数，该整数是恢复电力所需的总最小成本的 $1000$ 倍。不要进行任何四舍五入；截断结果乘积。\n", "hint": "就像上面的图示一样。\n\n\n如上所述。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2915", "type": "P", "difficulty": 5, "samples": [["4 1 \n3 \n4 \n2 \n1 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO", "状压 DP"], "title": "[USACO08NOV] Mixed Up Cows G", "background": "", "description": "Each of Farmer John's N (4 <= N <= 16) cows has a unique serial number S\\_i (1 <= S\\_i <= 25,000). The cows are so proud of it that each one now wears her number in a gangsta manner engraved in large letters on a gold plate hung around her ample bovine neck.\n\nGangsta cows are rebellious and line up to be milked in an order called 'Mixed Up'. A cow order is 'Mixed Up' if the sequence of serial numbers formed by their milking line is such that the serial numbers of every pair of consecutive cows in line differs by more than K (1 <= K <= 3400). For example, if N = 6 and K = 1 then 1, 3, 5, 2, 6, 4 is a 'Mixed Up' lineup but 1, 3, 6, 5, 2, 4 is not (since the consecutive numbers 5 and 6 differ by 1).\n\nHow many different ways can N cows be Mixed Up?\n\nFor your first 10 submissions, you will be provided with the results of running your program on a part of the actual test data.\n\nPOINTS: 200\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..N+1: Line i+1 contains a single integer that is the serial number of cow i: S\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the number of ways that N cows can be 'Mixed Up'. The answer is guaranteed to fit in a 64 bit integer.\n", "hint": "The 2 possible Mixed Up arrangements are:\n\n3 1 4 2\n\n2 4 1 3\n", "locale": "en", "translations": {"en": {"title": "[USACO08NOV] Mixed Up Cows G", "background": "", "description": "Each of Farmer John's N (4 <= N <= 16) cows has a unique serial number S\\_i (1 <= S\\_i <= 25,000). The cows are so proud of it that each one now wears her number in a gangsta manner engraved in large letters on a gold plate hung around her ample bovine neck.\n\nGangsta cows are rebellious and line up to be milked in an order called 'Mixed Up'. A cow order is 'Mixed Up' if the sequence of serial numbers formed by their milking line is such that the serial numbers of every pair of consecutive cows in line differs by more than K (1 <= K <= 3400). For example, if N = 6 and K = 1 then 1, 3, 5, 2, 6, 4 is a 'Mixed Up' lineup but 1, 3, 6, 5, 2, 4 is not (since the consecutive numbers 5 and 6 differ by 1).\n\nHow many different ways can N cows be Mixed Up?\n\nFor your first 10 submissions, you will be provided with the results of running your program on a part of the actual test data.\n\nPOINTS: 200\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..N+1: Line i+1 contains a single integer that is the serial number of cow i: S\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the number of ways that N cows can be 'Mixed Up'. The answer is guaranteed to fit in a 64 bit integer.\n", "hint": "The 2 possible Mixed Up arrangements are:\n\n3 1 4 2\n\n2 4 1 3\n", "locale": "en"}, "zh-CN": {"title": "[USACO08NOV] Mixed Up Cows G", "background": null, "description": "约翰家有 $N$（$4\\le N\\le16$）头奶牛，第 $i$ 头奶牛的编号是 $S_i$（$1\\le S_i \\le 25,000$），每头奶牛的编号都是唯一的。\n\n这些奶牛最近在闹脾气，为表达不满的情绪，她们在挤奶的时候一定要排成混乱的队伍。在一只混乱的队伍中，相邻奶牛的编号之差均超过 $K$（$1\\le K \\le 3,400$）。比如当 $K=1$ 时，$[1,3,5,2,6,4]$ 就是一支混乱的队伍，而 $[1,3,6,5,2,4]$ 不是，因为 $6$ 和 $5$ 只差 $1$。\n\n请数一数，有多少种队形是混乱的呢？", "inputFormat": "第 $1$ 行：两个用空格分隔的整数 $N$ 和 $K$。\n\n第 $2\\sim N+1$ 行：第 $i+1$ 行包含奶牛 $i$ 的序列号 $S_i$。", "outputFormat": "输出一行答案，表示混乱的队形数量。保证可以使用 64 位整型存下。", "hint": "两种可能的混乱队形如下：\n\n- $3,1,4,2$\n\n- $2,4,1,3$", "locale": "zh-CN"}}}
{"pid": "P2916", "type": "P", "difficulty": 4, "samples": [["5 7 \n10 \n10 \n20 \n6 \n30 \n1 2 5 \n2 3 5 \n2 4 12 \n3 4 17 \n2 5 15 \n3 5 6 \n4 5 12 \n", "176 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO", "生成树"], "title": "[USACO08NOV] Cheering up the Cow G", "background": "", "description": "农夫约翰有 $$ N $$ 个牧场（编号为 $$ 1 $$ 到 $$ N $$，$$ 5 \\leq N \\leq 10,000 $$），每个牧场住着一头牛。这些牧场通过 $$ P $$ 条双向路径（$$ N-1 \\leq P \\leq 100,000 $$）连接。每条路径 $$ j $$ 连接牧场 $$ S_j $$ 和 $$ E_j $$（$$ 1 \\leq S_j \\leq N $$；$$ 1 \\leq E_j \\leq N $$；$$ S_j \\neq E_j $$），穿越该路径需要耗费 $$ L_j $$（$$ 0 \\leq L_j \\leq 1,000 $$）单位时间。任意两座牧场之间最多只有一条直接相连的路径。\n\n约翰打算在保持各牧场连通的情况下去掉尽量多的道路。约翰知道，在道路被强拆后，奶牛会非常伤心，所以他计划拆除道路之后就去安抚她们。约翰可以选择从任意一个牧场出发开始他的安抚工作。当他走访完所有的奶牛之后，还要回到他的出发地。每次路过牧场 $i$ 的时候，他必须花 $C_i( 1 \\leq C_i \\leq 1000 )$ 的时间和奶牛交谈，即使之前已经谈过了，也要留下来再谈一次。注意约翰在出发和回去的时候，都要和出发地的奶牛谈一次话。\n\n假设农夫约翰采纳了你关于保留路径的建议，并且你选择了最优的住宿牧场，请计算满足每天至少拜访每头牛一次的前提下，所需的最小总时间。", "inputFormat": "* 第 $1$ 行：两个用空格分隔的整数：$$ N $$ 和 $$ P $$  \n\n* 第 $2$ 行到第 $$ N+1 $$ 行：第 $$ i+1 $$ 行包含一个整数：$$ C_i $$  。\n\n* 第 $$ N+2 $$ 行到第 $$ N+P+1 $$ 行：第 $$ N+j+1 $$ 行包含三个用空格分隔的整数：$$ S_j $$、$$ E_j $$ 和 $$ L_j $$。", "outputFormat": "* 第 1 行：一个整数，表示拜访所有奶牛（包括在睡觉牧场进行的两次交谈）所需的最小总时间。", "hint": "```cpp\n   +-(15)-+\n  /        \\\n /          \\\n1-(5)-2-(5)-3-(6)--5\n   \\   /(17)  /\n(12)\\ /      /(12)\n     4------+\n\n保留这些路径：\n1-(5)-2-(5)-3      5\n       \\          /\n    (12)\\        /(12)\n        *4------+\n```\n\n选择牧场 $4$ 作为住处，按照 $4→5→4→2→3→2→1→2→4$ 的顺序拜访所有牧场，最终返回睡觉，总耗时为 $176$ 单位时间。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08NOV] Cheering up the Cow G", "background": "", "description": "Farmer John has $N$ pastures (numbered $1$ to $N$, $5 \\leq N \\leq 10,000$), each inhabited by one cow. These pastures are connected by $P$ bidirectional paths ($N-1 \\leq P \\leq 100,000$). Each path $j$ connects pastures $S_j$ and $E_j$ ($1 \\leq S_j \\leq N$; $1 \\leq E_j \\leq N$; $S_j \\neq E_j$), and traversing it takes $L_j$ units of time ($0 \\leq L_j \\leq 1,000$). There is at most one direct path between any pair of pastures.\n\nJohn plans to remove as many roads as possible while keeping all pastures connected. He knows the cows will be very sad after the demolition, so he plans to comfort them afterward. John may choose any pasture to start his comforting tour. After he has visited all cows, he must return to his starting pasture. Each time he passes pasture $i$, he must spend $C_i$ ($1 \\leq C_i \\leq 1000$) units of time to talk with the cow there; even if he has already talked before, he must stop and talk again. Note that both when setting out and when returning, he must talk to the cow at the starting pasture.\n\nAssume Farmer John follows your recommendation on which paths to keep, and you also choose the optimal lodging pasture. Compute the minimal total time required while ensuring that each cow is visited at least once.", "inputFormat": "- Line $1$: Two space-separated integers: $N$ and $P$.\n- Lines $2$ to $N+1$: Line $i+1$ contains one integer: $C_i$.\n- Lines $N+2$ to $N+P+1$: Line $N+j+1$ contains three space-separated integers: $S_j$, $E_j$, and $L_j$.", "outputFormat": "- Line $1$: A single integer, the minimal total time needed to visit all cows (including the two chats at the lodging pasture).", "hint": "```cpp\n   +-(15)-+\n  /        \\\n /          \\\n1-(5)-2-(5)-3-(6)--5\n   \\   /(17)  /\n(12)\\ /      /(12)\n     4------+\n\nKeep these paths:\n1-(5)-2-(5)-3      5\n       \\          /\n    (12)\\        /(12)\n        *4------+\n```\n\nChoose pasture $4$ as the lodging pasture, visit in the order $4 \\to 5 \\to 4 \\to 2 \\to 3 \\to 2 \\to 1 \\to 2 \\to 4$, and finally return to sleep. The total time is $176$ units.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO08NOV] Cheering up the Cow G", "background": "", "description": "农夫约翰有 $$ N $$ 个牧场（编号为 $$ 1 $$ 到 $$ N $$，$$ 5 \\leq N \\leq 10,000 $$），每个牧场住着一头牛。这些牧场通过 $$ P $$ 条双向路径（$$ N-1 \\leq P \\leq 100,000 $$）连接。每条路径 $$ j $$ 连接牧场 $$ S_j $$ 和 $$ E_j $$（$$ 1 \\leq S_j \\leq N $$；$$ 1 \\leq E_j \\leq N $$；$$ S_j \\neq E_j $$），穿越该路径需要耗费 $$ L_j $$（$$ 0 \\leq L_j \\leq 1,000 $$）单位时间。任意两座牧场之间最多只有一条直接相连的路径。\n\n约翰打算在保持各牧场连通的情况下去掉尽量多的道路。约翰知道，在道路被强拆后，奶牛会非常伤心，所以他计划拆除道路之后就去安抚她们。约翰可以选择从任意一个牧场出发开始他的安抚工作。当他走访完所有的奶牛之后，还要回到他的出发地。每次路过牧场 $i$ 的时候，他必须花 $C_i( 1 \\leq C_i \\leq 1000 )$ 的时间和奶牛交谈，即使之前已经谈过了，也要留下来再谈一次。注意约翰在出发和回去的时候，都要和出发地的奶牛谈一次话。\n\n假设农夫约翰采纳了你关于保留路径的建议，并且你选择了最优的住宿牧场，请计算满足每天至少拜访每头牛一次的前提下，所需的最小总时间。", "inputFormat": "* 第 $1$ 行：两个用空格分隔的整数：$$ N $$ 和 $$ P $$  \n\n* 第 $2$ 行到第 $$ N+1 $$ 行：第 $$ i+1 $$ 行包含一个整数：$$ C_i $$  。\n\n* 第 $$ N+2 $$ 行到第 $$ N+P+1 $$ 行：第 $$ N+j+1 $$ 行包含三个用空格分隔的整数：$$ S_j $$、$$ E_j $$ 和 $$ L_j $$。", "outputFormat": "* 第 1 行：一个整数，表示拜访所有奶牛（包括在睡觉牧场进行的两次交谈）所需的最小总时间。", "hint": "```cpp\n   +-(15)-+\n  /        \\\n /          \\\n1-(5)-2-(5)-3-(6)--5\n   \\   /(17)  /\n(12)\\ /      /(12)\n     4------+\n\n保留这些路径：\n1-(5)-2-(5)-3      5\n       \\          /\n    (12)\\        /(12)\n        *4------+\n```\n\n选择牧场 $4$ 作为住处，按照 $4→5→4→2→3→2→1→2→4$ 的顺序拜访所有牧场，最终返回睡觉，总耗时为 $176$ 单位时间。", "locale": "zh-CN"}}}
{"pid": "P2917", "type": "P", "difficulty": 6, "samples": [["4 1 2 2 1 3 \n8 \n2 \n1 \n6 \n", "35 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2008", "USACO", "生成树", "状压 DP"], "title": "[USACO08NOV] Toys G", "background": "", "description": "Bessie's birthday is coming up, and she wishes to celebrate for the next D (1 <= D <= 100,000; 70% of testdata has 1 <= D <= 500) days. Cows have short attention spans so Bessie wants to provide toys to entertain them. She has calculated that she will require T\\_i (1 <= T\\_i <= 50) toys on day i.\n\nBessie's kindergarten provides many services to its aspiring bovine programmers, including a toy shop which sells toys for Tc (1 <= Tc <= 60) dollars. Bessie wishes to save money by reusing toys, but Farmer John is worried about transmitting diseases and requires toys to be disinfected before use. (The toy shop disinfects the toys when it sells them.)\n\nThe two disinfectant services near the farm provide handy complete services. The first one charges C1 dollars and requires N1 nights to complete; the second charges C2 dollars and requires N2 nights to complete (1 <= N1 <= D; 1 <= N2 <= D; 1 <= C1 <= 60; 1 <= C2 <= 60). Bessie takes the toys to the disinfecters after the party and can pay and pick them back up the next morning if one night service is rendered, or on later mornings if more nights are required for disinfecting.\n\nBeing an educated cow, Bessie has already learned the value of saving her money. Help her find the cheapest way she can provide toys for her party.\n\nPOINTS: 400\n", "inputFormat": "\\* Line 1: Six space-separated integers: D, N1, N2, C1, C2, Tc\n\n\\* Lines 2..D+1: Line i+1 contains a single integer: T\\_i\n", "outputFormat": "\\* Line 1: The minimum cost to provide safe and sanitary toys for Bessie's birthday parties.\n", "hint": "Bessie wishes to party for 4 days, and requires 8 toys the first day, 2 toys the second, 1 toy the third, and 6 toys on the fourth day. The first disinfectant service takes 1 day and charges \\$2, and the second takes 2 days and charges \\$1. Buying a new toy costs \\$3.\n\n\nDay 1   Purchase 8 toys in the morning for $24; party in the\n\nafternoon. Take 2 toys to the fast cleaner (overnight) and \n\nthe other 6 toys to the slow cleaner (two nights). \n\nDay 2   Pick up the two toys at the fast cleaner; pay $4. Party in the afternoon. Take 1 toy to the slow cleaner. \n\nDay 3   Pick up 6 toys from the slow cleaner and pay $6. Party in the afternoon.\n\nDay 4   Pick up the final remaining toy from the slow cleaner\n\n(bringing the number of toys onsite back to 6); pay $1. Party hearty with the realization that a minimum amount of money was spent.\n", "locale": "en", "translations": {"en": {"title": "[USACO08NOV] Toys G", "background": "", "description": "Bessie's birthday is coming up, and she wishes to celebrate for the next D (1 <= D <= 100,000; 70% of testdata has 1 <= D <= 500) days. Cows have short attention spans so Bessie wants to provide toys to entertain them. She has calculated that she will require T\\_i (1 <= T\\_i <= 50) toys on day i.\n\nBessie's kindergarten provides many services to its aspiring bovine programmers, including a toy shop which sells toys for Tc (1 <= Tc <= 60) dollars. Bessie wishes to save money by reusing toys, but Farmer John is worried about transmitting diseases and requires toys to be disinfected before use. (The toy shop disinfects the toys when it sells them.)\n\nThe two disinfectant services near the farm provide handy complete services. The first one charges C1 dollars and requires N1 nights to complete; the second charges C2 dollars and requires N2 nights to complete (1 <= N1 <= D; 1 <= N2 <= D; 1 <= C1 <= 60; 1 <= C2 <= 60). Bessie takes the toys to the disinfecters after the party and can pay and pick them back up the next morning if one night service is rendered, or on later mornings if more nights are required for disinfecting.\n\nBeing an educated cow, Bessie has already learned the value of saving her money. Help her find the cheapest way she can provide toys for her party.\n\nPOINTS: 400\n", "inputFormat": "\\* Line 1: Six space-separated integers: D, N1, N2, C1, C2, Tc\n\n\\* Lines 2..D+1: Line i+1 contains a single integer: T\\_i\n", "outputFormat": "\\* Line 1: The minimum cost to provide safe and sanitary toys for Bessie's birthday parties.\n", "hint": "Bessie wishes to party for 4 days, and requires 8 toys the first day, 2 toys the second, 1 toy the third, and 6 toys on the fourth day. The first disinfectant service takes 1 day and charges \\$2, and the second takes 2 days and charges \\$1. Buying a new toy costs \\$3.\n\n\nDay 1   Purchase 8 toys in the morning for $24; party in the\n\nafternoon. Take 2 toys to the fast cleaner (overnight) and \n\nthe other 6 toys to the slow cleaner (two nights). \n\nDay 2   Pick up the two toys at the fast cleaner; pay $4. Party in the afternoon. Take 1 toy to the slow cleaner. \n\nDay 3   Pick up 6 toys from the slow cleaner and pay $6. Party in the afternoon.\n\nDay 4   Pick up the final remaining toy from the slow cleaner\n\n(bringing the number of toys onsite back to 6); pay $1. Party hearty with the realization that a minimum amount of money was spent.\n", "locale": "en"}, "zh-CN": {"title": "[USACO08NOV] Toys G", "background": "", "description": "贝茜的生日快到了，她希望在接下来的 D 天（1 <= D <= 100,000；70% 的测试数据满足 1 <= D <= 500）里庆祝。奶牛们注意力短暂，所以贝茜想要提供玩具来娱乐它们。她计算出她在第 i 天需要 T_i（1 <= T_i <= 50）个玩具。\n\n贝茜的幼儿园为其有抱负的牛程序员提供许多服务，包括一个玩具店，玩具售价为 Tc（1 <= Tc <= 60）美元。贝茜希望通过重复使用玩具来省钱，但农夫约翰担心传染病，要求玩具在使用前进行消毒。（玩具店在销售玩具时会对其进行消毒。）\n\n农场附近的两个消毒服务提供便捷的全套服务。第一个服务收费 C1 美元，需要 N1 个晚上完成；第二个服务收费 C2 美元，需要 N2 个晚上完成（1 <= N1 <= D；1 <= N2 <= D；1 <= C1 <= 60；1 <= C2 <= 60）。贝茜在派对后将玩具送去消毒，如果是一个晚上的服务，她可以在第二天早上支付并取回玩具，或者如果需要更多晚上的消毒，则在之后的早晨取回。\n\n作为一头有学问的奶牛，贝茜已经学会了节省金钱的价值。帮助她找到为她的派对提供玩具的最便宜的方法。\n\nPOINTS: 400", "inputFormat": "* 第 1 行：六个用空格分隔的整数：D, N1, N2, C1, C2, Tc\n\n* 第 2 行到第 D+1 行：第 i+1 行包含一个整数：T_i", "outputFormat": "* 第 1 行：为贝茜的生日派对提供安全卫生玩具的最低成本。", "hint": "贝茜希望庆祝 4 天，第一天需要 8 个玩具，第二天需要 2 个玩具，第三天需要 1 个玩具，第四天需要 6 个玩具。第一个消毒服务需要 1 天，收费 2 美元，第二个需要 2 天，收费 1 美元。购买一个新玩具需要 3 美元。\n\n第 1 天 早上购买 8 个玩具，花费 24 美元；下午开派对。将 2 个玩具送去快速清洗（过夜），其余 6 个玩具送去慢速清洗（两晚）。\n\n第 2 天 从快速清洗处取回 2 个玩具；支付 4 美元。下午开派对。将 1 个玩具送去慢速清洗。\n\n第 3 天 从慢速清洗处取回 6 个玩具并支付 6 美元。下午开派对。\n\n第 4 天 从慢速清洗处取回最后一个玩具（将现场玩具数量恢复到 6 个）；支付 1 美元。开心地开派对，意识到花费了最少的钱。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P2918", "type": "P", "difficulty": 3, "samples": [["2 15 \n3 2 \n5 3 \n", "9 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "USACO", "背包 DP"], "title": "[USACO08NOV] Buying Hay S", "background": "", "description": "Farmer John is running out of supplies and needs to purchase H (1 <= H <= 50,000) pounds of hay for his cows.\n\nHe knows N (1 <= N <= 100) hay suppliers conveniently numbered 1..N. Supplier i sells packages that contain P\\_i (1 <= P\\_i <= 5,000) pounds of hay at a cost of C\\_i (1 <= C\\_i <= 5,000) dollars. Each supplier has an unlimited number of packages available, and the packages must be bought whole.\n\nHelp FJ by finding the minimum cost necessary to purchase at least H pounds of hay.", "inputFormat": "\\* Line 1: Two space-separated integers: N and H\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: P\\_i and C\\_i", "outputFormat": "\\* Line 1: A single integer representing the minimum cost FJ needs to pay to obtain at least H pounds of hay.", "hint": "FJ can buy three packages from the second supplier for a total cost of 9.", "locale": "en", "translations": {"en": {"title": "[USACO08NOV] Buying Hay S", "background": "", "description": "Farmer John is running out of supplies and needs to purchase H (1 <= H <= 50,000) pounds of hay for his cows.\n\nHe knows N (1 <= N <= 100) hay suppliers conveniently numbered 1..N. Supplier i sells packages that contain P\\_i (1 <= P\\_i <= 5,000) pounds of hay at a cost of C\\_i (1 <= C\\_i <= 5,000) dollars. Each supplier has an unlimited number of packages available, and the packages must be bought whole.\n\nHelp FJ by finding the minimum cost necessary to purchase at least H pounds of hay.", "inputFormat": "\\* Line 1: Two space-separated integers: N and H\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: P\\_i and C\\_i", "outputFormat": "\\* Line 1: A single integer representing the minimum cost FJ needs to pay to obtain at least H pounds of hay.", "hint": "FJ can buy three packages from the second supplier for a total cost of 9.", "locale": "en"}, "zh-CN": {"title": "[USACO08NOV] Buying Hay S", "background": null, "description": "约翰的干草库存已经告罄，他打算为奶牛们采购 $H(1 \\leq H \\leq 50000)$ 磅干草。\n\n他知道 $N(1 \\leq N\\leq 100)$ 个干草公司，现在用 $1$ 到 $N$ 给它们编号。第 $i$ 公司卖的干草包重量为 $P_i (1 \\leq P_i \\leq 5,000)$ 磅，需要的开销为 $C_i (1 \\leq C_i \\leq 5,000)$ 美元。每个干草公司的货源都十分充足， 可以卖出无限多的干草包。\n\n帮助约翰找到最小的开销来满足需要，即采购到至少 $H$ 磅干草。", "inputFormat": "第 $1$ 行：两个整数： $N$ 与 $H$ ，以空格分隔。\n\n第 $2$ 行至第 $N+1$ 行：其中第 $i+1$ 行包含两个整数： $P_i$ 与 $C_i$ ，以空格分隔。", "outputFormat": "一个整数，表示 FJ 至少采购到 $H$ 磅干草所需的最少花费。", "hint": "FJ 可以在第二家公司买 $3$ 包干草，共花费 $9$ 美元。", "locale": "zh-CN"}}}
{"pid": "P2919", "type": "P", "difficulty": 4, "samples": [["8 7 \n4 3 2 2 1 0 1 \n3 3 3 2 1 0 1 \n2 2 2 2 1 0 0 \n2 1 1 1 1 0 0 \n1 1 0 0 0 1 0 \n0 0 0 1 1 1 0 \n0 1 2 2 1 1 0 \n0 1 1 1 2 1 0 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2008", "USACO", "广度优先搜索 BFS", "深度优先搜索 DFS"], "title": "[USACO08NOV] Guarding the Farm S", "background": "", "description": "The farm has many hills upon which Farmer John would like to place guards to ensure the safety of his valuable milk-cows.\n\nHe wonders how many guards he will need if he wishes to put one on top of each hill. He has a map supplied as a matrix of integers; the matrix has N (1 < N <= 700) rows and M (1 < M <= 700) columns. Each member of the matrix is an altitude H\\_ij (0 <= H\\_ij <= 10,000). Help him determine the number of hilltops on the map.\n\nA hilltop is one or more adjacent matrix elements of the same value surrounded exclusively by either the edge of the map or elements with a lower (smaller) altitude. Two different elements are adjacent if the magnitude of difference in their X coordinates is no greater than 1 and the magnitude of differences in their Y coordinates is also no greater than 1.\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 describes row i of the matrix with M\n\nspace-separated integers: H\\_ij\n", "outputFormat": "\\* Line 1: A single integer that specifies the number of hilltops\n", "hint": "There are three peaks: The one with height 4 on the left top, one of the points with height 2 at the bottom part, and one of the points with height 1 on the right top corner.\n", "locale": "en", "translations": {"en": {"title": "[USACO08NOV] Guarding the Farm S", "background": "", "description": "The farm has many hills upon which Farmer John would like to place guards to ensure the safety of his valuable milk-cows.\n\nHe wonders how many guards he will need if he wishes to put one on top of each hill. He has a map supplied as a matrix of integers; the matrix has N (1 < N <= 700) rows and M (1 < M <= 700) columns. Each member of the matrix is an altitude H\\_ij (0 <= H\\_ij <= 10,000). Help him determine the number of hilltops on the map.\n\nA hilltop is one or more adjacent matrix elements of the same value surrounded exclusively by either the edge of the map or elements with a lower (smaller) altitude. Two different elements are adjacent if the magnitude of difference in their X coordinates is no greater than 1 and the magnitude of differences in their Y coordinates is also no greater than 1.\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 describes row i of the matrix with M\n\nspace-separated integers: H\\_ij\n", "outputFormat": "\\* Line 1: A single integer that specifies the number of hilltops\n", "hint": "There are three peaks: The one with height 4 on the left top, one of the points with height 2 at the bottom part, and one of the points with height 1 on the right top corner.\n", "locale": "en"}, "zh-CN": {"title": "[USACO08NOV] Guarding the Farm S", "background": "", "description": "农场有许多小山丘，约翰农夫希望在这些小山丘上放置守卫，以确保他珍贵的奶牛的安全。\n\n他想知道如果他希望在每个小山丘的顶部放置一个守卫，他需要多少守卫。他有一张地图，这张地图是一个整数矩阵；矩阵有 $N$ 行（$1 < N \\leq 700$）和 $M$ 列（$1 < M \\leq 700$）。矩阵中的每个元素表示一个高度 $H_{ij}$（$0 \\leq H_{ij} \\leq 10,000$）。请帮助他确定地图上有多少个山顶。\n\n一个山顶是由一个或多个相邻且具有相同值的矩阵元素组成，这些元素被地图的边缘或具有较低（较小）高度的元素完全包围。如果两个不同的元素的 $X$ 坐标差的绝对值不大于 1，且 $Y$ 坐标差的绝对值也不大于 1，则它们是相邻的。\n", "inputFormat": "\\* 第 1 行：两个用空格分隔的整数：$N$ 和 $M$\n\n\\* 第 2 行到第 $N+1$ 行：第 $i+1$ 行描述矩阵的第 $i$ 行，包含 $M$ 个用空格分隔的整数：$H_{ij}$\n", "outputFormat": "\\* 第 1 行：一个整数，表示山顶的数量\n", "hint": "有三个山峰：左上角高度为 4 的一个，底部高度为 2 的一个点，以及右上角高度为 1 的一个点。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2920", "type": "P", "difficulty": 3, "samples": [["4 \n3 5 \n8 14 \n5 20 \n1 16 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2008", "二分", "USACO", "排序"], "title": "[USACO08NOV] Time Management S", "background": "", "description": "作为一名忙碌的商人，约翰知道必须高效地安排他的时间。他有 $N(1\\le N\\le 1000)$ 个工作要做，比如给奶牛挤奶，清洗牛棚，修理栅栏之类的。\n\n为了高效，约翰列出了所有工作的清单。第 $i(1\\le i\\le N)$ 个工作需要 $T_i(1\\le T_i\\le 1000)$ 单位的时间来完成，而且必须在 $1\\le S_i\\le 10^6$ 或之前完成。现在是 $0$ 时刻。约翰做一份工作必须直到做完才能停止。\n\n所有的商人都喜欢睡懒觉。请帮约翰计算他最迟什么时候开始工作，可以让所有工作按时完成。（如果始终无法完成全部任务，输出 `-1`）", "inputFormat": "第一行，一个整数 $N$\n\n接下来 $N$ 行，每行 $2$ 个有空格分隔的整数 $T_i,S_i$", "outputFormat": "一行，一个整数，表示约翰可以开始工作的最晚时间，如果约翰无法完成所有工作，则为 `-1`", "hint": "**【样例解释】**\n\n约翰有 $4$ 个工作要做，分别需要 $3、8、5$ 和 $1$ 个时间单位，并且必须分别在时间 $5、14、20$ 和 $16$ 之前完成。\n\n约翰必须在时间 $2$ 开始第一个作业。然后他可以按此顺序完成第二、第四和第三项工作，以按时完成。", "locale": "zh-CN", "translations": {"en": {"title": "", "background": "", "description": "Ever the maturing businessman, Farmer John realizes that he must manage his time effectively. He has N jobs conveniently numbered 1..N (1 <= N <= 1,000) to accomplish (like milking the cows, cleaning the barn, mending the fences, and so on).\n\nTo manage his time effectively, he has created a list of the jobs that must be finished. Job i requires a certain amount of time T\\_i (1 <= T\\_i <= 1,000) to complete and furthermore must be finished by time S\\_i (1 <= S\\_i <= 1,000,000). Farmer John starts his day at time t=0 and can only work on one job at a time until it is finished.\n\nEven a maturing businessman likes to sleep late; help Farmer John determine the latest he can start working and still finish all the jobs on time.", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: T\\_i and S\\_i\n", "outputFormat": "Farmer John has 4 jobs to do, which take 3, 8, 5, and 1 units of time, respectively, and must be completed by time 5, 14, 20, and 16, respectively.\n\n\nFarmer John must start the first job at time 2. Then he can do the second, fourth, and third jobs in that order to finish on time.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO08NOV] Time Management S", "background": "", "description": "作为一名忙碌的商人，约翰知道必须高效地安排他的时间。他有 $N(1\\le N\\le 1000)$ 个工作要做，比如给奶牛挤奶，清洗牛棚，修理栅栏之类的。\n\n为了高效，约翰列出了所有工作的清单。第 $i(1\\le i\\le N)$ 个工作需要 $T_i(1\\le T_i\\le 1000)$ 单位的时间来完成，而且必须在 $1\\le S_i\\le 10^6$ 或之前完成。现在是 $0$ 时刻。约翰做一份工作必须直到做完才能停止。\n\n所有的商人都喜欢睡懒觉。请帮约翰计算他最迟什么时候开始工作，可以让所有工作按时完成。（如果始终无法完成全部任务，输出 `-1`）", "inputFormat": "第一行，一个整数 $N$\n\n接下来 $N$ 行，每行 $2$ 个有空格分隔的整数 $T_i,S_i$", "outputFormat": "一行，一个整数，表示约翰可以开始工作的最晚时间，如果约翰无法完成所有工作，则为 `-1`", "hint": "**【样例解释】**\n\n约翰有 $4$ 个工作要做，分别需要 $3、8、5$ 和 $1$ 个时间单位，并且必须分别在时间 $5、14、20$ 和 $16$ 之前完成。\n\n约翰必须在时间 $2$ 开始第一个作业。然后他可以按此顺序完成第二、第四和第三项工作，以按时完成。", "locale": "zh-CN"}}}
{"pid": "P2921", "type": "P", "difficulty": 4, "samples": [["4 \n1 \n3 \n2 \n3 \n", "1 \n2 \n2 \n3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "2008", "USACO", "记忆化搜索", "Tarjan", "基环树"], "title": "[USACO08DEC] Trick or Treat on the Farm G", "background": "", "description": "Every year in Wisconsin the cows celebrate the USA autumn holiday of Halloween by dressing up in costumes and collecting candy that Farmer John leaves in the N (1 <= N <= 100,000) stalls conveniently numbered 1..N.\n\nBecause the barn is not so large, FJ makes sure the cows extend their fun by specifying a traversal route the cows must follow.  To implement this scheme for traveling back and forth through the barn, FJ has posted a 'next stall number' next\\_i (1 <= next\\_i <= N) on stall i that tells the cows which stall to visit next; the cows thus might travel the length of the barn many times in order to collect their candy.\n\nFJ mandates that cow i should start collecting candy at stall i. A cow stops her candy collection if she arrives back at any stall she has already visited.\n\nCalculate the number of unique stalls each cow visits before being forced to stop her candy collection.\n\nPOINTS: 100", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: next\\_i\n", "outputFormat": "\\* Lines 1..N: Line i contains a single integer that is the total number of unique stalls visited by cow i before she returns to a stall  she has previously visited.\n", "hint": "Four stalls.\n\n\\* Stall 1 directs the cow back to stall 1.\n\n\\* Stall 2 directs the cow to stall 3\n\n\\* Stall 3 directs the cow to stall 2\n\n\\* Stall 4 directs the cow to stall 3\n\n\nCow 1:  Start at 1, next is 1.  Total stalls visited: 1.\n\nCow 2:  Start at 2, next is 3, next is 2.  Total stalls visited: 2. Cow 3:  Start at 3, next is 2, next is 3.  Total stalls visited: 2. Cow 4:  Start at 4, next is 3, next is 2, next is 3. Total stalls visited: 3.\n", "locale": "en", "translations": {"en": {"title": "[USACO08DEC] Trick or Treat on the Farm G", "background": "", "description": "Every year in Wisconsin the cows celebrate the USA autumn holiday of Halloween by dressing up in costumes and collecting candy that Farmer John leaves in the N (1 <= N <= 100,000) stalls conveniently numbered 1..N.\n\nBecause the barn is not so large, FJ makes sure the cows extend their fun by specifying a traversal route the cows must follow.  To implement this scheme for traveling back and forth through the barn, FJ has posted a 'next stall number' next\\_i (1 <= next\\_i <= N) on stall i that tells the cows which stall to visit next; the cows thus might travel the length of the barn many times in order to collect their candy.\n\nFJ mandates that cow i should start collecting candy at stall i. A cow stops her candy collection if she arrives back at any stall she has already visited.\n\nCalculate the number of unique stalls each cow visits before being forced to stop her candy collection.\n\nPOINTS: 100", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: next\\_i\n", "outputFormat": "\\* Lines 1..N: Line i contains a single integer that is the total number of unique stalls visited by cow i before she returns to a stall  she has previously visited.\n", "hint": "Four stalls.\n\n\\* Stall 1 directs the cow back to stall 1.\n\n\\* Stall 2 directs the cow to stall 3\n\n\\* Stall 3 directs the cow to stall 2\n\n\\* Stall 4 directs the cow to stall 3\n\n\nCow 1:  Start at 1, next is 1.  Total stalls visited: 1.\n\nCow 2:  Start at 2, next is 3, next is 2.  Total stalls visited: 2. Cow 3:  Start at 3, next is 2, next is 3.  Total stalls visited: 2. Cow 4:  Start at 4, next is 3, next is 2, next is 3. Total stalls visited: 3.\n", "locale": "en"}, "zh-CN": {"title": "[USACO08DEC] Trick or Treat on the Farm G", "background": null, "description": "每年，在威斯康星州，奶牛们都会穿上衣服，收集农夫约翰在 $N(1\\le N\\le 100,000)$ 个牛棚隔间中留下的糖果，以此来庆祝美国秋天的万圣节。\n\n由于牛棚不太大，FJ 通过指定奶牛必须遵循的穿越路线来确保奶牛的乐趣。为了实现这个让奶牛在牛棚里来回穿梭的方案，FJ 在第 $i$ 号隔间上张贴了一个 “下一个隔间：$next_i(1\\le next_i\\le N)$” 的标语，告诉奶牛要去的下一个隔间。这样，为了收集它们的糖果，奶牛就会在牛棚里来回穿梭了。\n\nFJ 命令奶牛 $i$ 应该从 $i$ 号隔间开始收集糖果。如果一只奶牛回到某一个她已经去过的隔间，她就会停止收集糖果。\n\n在被迫停止收集糖果之前，计算一下每头奶牛要前往的隔间数（包含起点）。", "inputFormat": "第一行一个整数 $n$，表示牛棚隔间的数量。\n\n第 $2$ 至 $n+1$ 行，每行包含一个整数 $next_i$，表示 $i$ 号隔间的下一个隔间。", "outputFormat": "输出共 $n$ 行，第 $i$ 行包含一个整数，表示第 $i$ 只奶牛要前往的隔间数。", "hint": "有 $4$ 个隔间。\n\n- 隔间 $1$ 要求牛到隔间 $1$，\n\n- 隔间 $2$ 要求牛到隔间 $3$，\n\n- 隔间 $3$ 要求牛到隔间 $2$，\n\n- 隔间 $4$ 要求牛到隔间 $3$。\n\n牛 $1$：从 $1\\rightarrow 1$，总共访问 $1$ 个隔间；\n\n牛 $2$：$2\\rightarrow 3\\rightarrow 2$，总共访问 $2$ 个隔间；\n\n牛 $3$：$3\\rightarrow 2\\rightarrow 3$，总共访问 $2$ 个隔间；\n\n牛 $4$：$4\\rightarrow 3\\rightarrow 2\\rightarrow 3$，总共访问 $3$ 个隔间。\n\n翻译提供者：[busy_programmer](https://www.luogu.com.cn/user/649315)。", "locale": "zh-CN"}}}
{"pid": "P2922", "type": "P", "difficulty": 4, "samples": [["4 5 \n3 0 1 0 \n1 1 \n3 1 0 0 \n3 1 1 0 \n1 0 \n1 1 \n2 0 1 \n5 0 1 0 0 1 \n2 1 1 \n", "1 \n3 \n1 \n1 \n2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO", "进制", "字典树 Trie"], "title": "[USACO08DEC] Secret Message G", "background": null, "description": "贝茜正在领导奶牛们逃跑。为了联络，奶牛们互相发送秘密信息。\n\n信息是二进制的，共有 $M$（$1 \\le M \\le 50000$）条，反间谍能力很强的约翰已经部分拦截了这些信息，知道了第  $i$ 条二进制信息的前 $b_i$（$1 \\le b_i \\le 10000$）位，他同时知道，奶牛使用 $N$（$1 \\le N \\le 50000$）条暗号．但是，他仅仅知道第 $j$ 条暗号的前 $c_j$（$1 \\le c_j \\le 10000$）位。\n\n对于每条暗号 $j$，他想知道有多少截得的信息能够和它匹配。也就是说，有多少信息和这条暗号有着相同的前缀。当然，这个前缀长度必须等于暗号和那条信息长度的较小者。\n\n在输入文件中，位的总数（即 $\\sum b_i + \\sum c_i$）不会超过 $5 \\times 10^5$。", "inputFormat": "第 $1$ 行：两个整数 $M$ 和 $N$。\n\n接下来 $M$ 行，其中的第 $i$ 行：一个整数 $b_i$，后跟 $b_i$ 个空格分隔的“0”和“1”，描述截取的消息 $i$。\n\n接下来 $N$ 行，其中的第 $j$ 行：一个整数 $c_j$，后跟 $c_j$ 个空格分隔的“0”和“1”，描述暗号 $j$。", "outputFormat": "$N$ 行，第 $i$ 行表示第 $i$ 个暗号可以匹配的消息数。", "hint": "四条消息；五条暗号。截获的消息以 `010`、`1`、`100` 和 `110` 开头。可能的暗号以 `0`、`1`、`01`、`01001` 和 `11` 开头。\n\n`0`：匹配 `010`: $1$ 个匹配。\n\n`1`：匹配 `1`、`100` 和 `110`，$3$ 个匹配。\n\n`01`：匹配 `010`，$1$ 个匹配。\n\n`01001`：匹配 `010`，$1$ 个匹配。\n\n`11`： 匹配 `1` 和 `110`，$2$ 个匹配。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08DEC] Secret Message G", "background": null, "description": "Bessie is leading the cows in an attempt to escape! To do this, the cows are sending secret binary messages to each other.\n\nEver the clever counterspy, Farmer John has intercepted the first $b_i$ ($1 \\le b_i \\le 10,000$) bits of each of $M$ ($1 \\le M \\le 50,000$) of these secret binary messages.\n\nHe has compiled a list of $N$ ($1 \\le N \\le 50,000$) partial codewords that he thinks the cows are using. Sadly, he only knows the first $c_j$ ($1 \\le c_j \\le 10,000$) bits of codeword $j$.\n\nFor each codeword $j$, he wants to know how many of the intercepted messages match that codeword (i.e., for codeword $j$, how many times does a message and the codeword have the same initial bits). Your job is to compute this number.\n\nThe total number of bits in the input (i.e., the sum of the $b_i$ and the $c_j$) will not exceed  $500,000$.", "inputFormat": "Line $1$: Two integers: $M$ and $N$.\n\nLines $2 \\ldots M+1$: Line $i+1$ describes intercepted code $i$ with an integer $b_i$ followed by $b_i$ space-separated `0`'s and `1`'s.\n\nLines $M+2 \\ldots M+N+1$: Line $M+j+1$ describes codeword $j$ with an integer $c_j$ followed by $c_j$ space-separated `0`'s and `1`'s.", "outputFormat": "Lines $1 \\ldots N$: Line $j$: The number of messages that the $j$-th codeword could match.", "hint": "Four messages; five codewords. \n\nThe intercepted messages start with 010, 1, 100, and 110.\n\nThe possible codewords start with 0, 1, 01, 01001, and 11.\n\n\n0 matches only 010: 1 match\n\n1 matches 1, 100, and 110: 3 matches\n\n01 matches only 010: 1 match\n\n01001 matches 010: 1 match\n\n11 matches 1 and 110: 2 matches", "locale": "en"}, "zh-CN": {"title": "[USACO08DEC] Secret Message G", "background": null, "description": "贝茜正在领导奶牛们逃跑。为了联络，奶牛们互相发送秘密信息。\n\n信息是二进制的，共有 $M$（$1 \\le M \\le 50000$）条，反间谍能力很强的约翰已经部分拦截了这些信息，知道了第  $i$ 条二进制信息的前 $b_i$（$1 \\le b_i \\le 10000$）位，他同时知道，奶牛使用 $N$（$1 \\le N \\le 50000$）条暗号．但是，他仅仅知道第 $j$ 条暗号的前 $c_j$（$1 \\le c_j \\le 10000$）位。\n\n对于每条暗号 $j$，他想知道有多少截得的信息能够和它匹配。也就是说，有多少信息和这条暗号有着相同的前缀。当然，这个前缀长度必须等于暗号和那条信息长度的较小者。\n\n在输入文件中，位的总数（即 $\\sum b_i + \\sum c_i$）不会超过 $5 \\times 10^5$。", "inputFormat": "第 $1$ 行：两个整数 $M$ 和 $N$。\n\n接下来 $M$ 行，其中的第 $i$ 行：一个整数 $b_i$，后跟 $b_i$ 个空格分隔的“0”和“1”，描述截取的消息 $i$。\n\n接下来 $N$ 行，其中的第 $j$ 行：一个整数 $c_j$，后跟 $c_j$ 个空格分隔的“0”和“1”，描述暗号 $j$。", "outputFormat": "$N$ 行，第 $i$ 行表示第 $i$ 个暗号可以匹配的消息数。", "hint": "四条消息；五条暗号。截获的消息以 `010`、`1`、`100` 和 `110` 开头。可能的暗号以 `0`、`1`、`01`、`01001` 和 `11` 开头。\n\n`0`：匹配 `010`: $1$ 个匹配。\n\n`1`：匹配 `1`、`100` 和 `110`，$3$ 个匹配。\n\n`01`：匹配 `010`，$1$ 个匹配。\n\n`01001`：匹配 `010`，$1$ 个匹配。\n\n`11`： 匹配 `1` 和 `110`，$2$ 个匹配。", "locale": "zh-CN"}}}
{"pid": "P2923", "type": "P", "difficulty": 5, "samples": [["8 \n-+-+-+-+ \n+-+-+-+- \n-+-K-+-+ \n+-+-+-+- \n-o-o-+-+ \n+-K-+-+- \n-o-+-+-+ \n+-K-+-K- \n", "8 3 \n6 1 \n4 3 \n6 5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2008", "USACO", "队列"], "title": "[USACO08DEC] Winning Checkers G", "background": "", "description": "The cows have taken up the game of checkers with a vengeance.\n\nUnfortunately, despite their unlimited enjoyment of playing, they are terrible at the endgame and want your help.\n\nGiven an NxN (4 <= N <= 500) checkboard, determine the optimal set of moves (i.e., smallest number of moves) to end the game on the next move. Checkers move only on the '+' squares and capture by jumping 'over' an opponent's piece in the traditional way. The piece is removed as soon as it is jumped.  See the example below where N=8:\n\n```cpp\n- + - + - + - +  The K's mark Bessie's kings; the o's represent the \n+ - + - + - + -  opponent's checkers. Bessie always moves next. The \n- + - K - + - +  Kings jump opponent's checkers successively in any \n+ - + - + - + -  diagonal direction (and removes pieces when jumped). \n- o - o - + - + \n+ - K - + - + -  For this board, the best solution requires the lower \n- o - + - + - +  left King to jump successively across all three of the \n+ - K - + - K -  opponents' checkers, thus ending the game (moving K marked as >K<): \nOriginal          After move 1       After move 2        After move 3 \n- + - + - + - +     - + - + - + - +    - + - + - + - +     - + - + - + - + \n+ - + - + - + -     + - + - + - + -    + - + - + - + -     + - + - + - + - \n- + - K - + - +     - + - K - + - +    - + - K - + - +     - + - K - + - + \n+ - + - + - + -     + - + - + - + -    + ->K<- + - + -     + - + - + - + - \n- o - o - + - +     - o - o - + - +    - + - o - + - +     - + - + - + - + \n+ - K - + - + -    >K<- K - + - + -    + - K - + - + -     + - K ->K<- + - \n- o - + - + - +     - + - + - + - +    - + - + - + - +     - + - + - + - + \n+ ->K<- + - K -     + - + - + - K -    + - K - + - K -     + - K - + - K - \n\nThe moves traversed these squares: \n1 2 3 4 5 6 7 8           R C \n1 - + - + - + - +    start: 8 3 \n2 + - + - + - + -    move:  6 1 \n3 - + - K - + - +    move:  4 3 \n4 + - * - + - + -    move:  6 5 \n5 - o - o - + - + \n6 * - K - * - + - \n7 - o - + - + - + \n8 + - K - + - K - \n```\nWrite a program to determine the game-ending sequence for an NxN input board if it exists. There is at least a king and at least one opponent piece on the board. The king can jump a piece on every move of the optimal solution.\n\nPOINTS: 330\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains N characters (each one of: '-', '+', 'K', or 'o') that represent row i of a proper checkboard. Line 2 always begins with '-'.\n", "outputFormat": "\\* Lines 1..?: If there is no winning sequence of jump, output\n\n'impossible' on a line by itself. If such a sequence exists, each line contains two space-separated integers that represent successive locations of a king whose moves will win the game. Any such sequence is acceptable.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO08DEC] Winning Checkers G", "background": "", "description": "The cows have taken up the game of checkers with a vengeance.\n\nUnfortunately, despite their unlimited enjoyment of playing, they are terrible at the endgame and want your help.\n\nGiven an NxN (4 <= N <= 500) checkboard, determine the optimal set of moves (i.e., smallest number of moves) to end the game on the next move. Checkers move only on the '+' squares and capture by jumping 'over' an opponent's piece in the traditional way. The piece is removed as soon as it is jumped.  See the example below where N=8:\n\n```cpp\n- + - + - + - +  The K's mark Bessie's kings; the o's represent the \n+ - + - + - + -  opponent's checkers. Bessie always moves next. The \n- + - K - + - +  Kings jump opponent's checkers successively in any \n+ - + - + - + -  diagonal direction (and removes pieces when jumped). \n- o - o - + - + \n+ - K - + - + -  For this board, the best solution requires the lower \n- o - + - + - +  left King to jump successively across all three of the \n+ - K - + - K -  opponents' checkers, thus ending the game (moving K marked as >K<): \nOriginal          After move 1       After move 2        After move 3 \n- + - + - + - +     - + - + - + - +    - + - + - + - +     - + - + - + - + \n+ - + - + - + -     + - + - + - + -    + - + - + - + -     + - + - + - + - \n- + - K - + - +     - + - K - + - +    - + - K - + - +     - + - K - + - + \n+ - + - + - + -     + - + - + - + -    + ->K<- + - + -     + - + - + - + - \n- o - o - + - +     - o - o - + - +    - + - o - + - +     - + - + - + - + \n+ - K - + - + -    >K<- K - + - + -    + - K - + - + -     + - K ->K<- + - \n- o - + - + - +     - + - + - + - +    - + - + - + - +     - + - + - + - + \n+ ->K<- + - K -     + - + - + - K -    + - K - + - K -     + - K - + - K - \n\nThe moves traversed these squares: \n1 2 3 4 5 6 7 8           R C \n1 - + - + - + - +    start: 8 3 \n2 + - + - + - + -    move:  6 1 \n3 - + - K - + - +    move:  4 3 \n4 + - * - + - + -    move:  6 5 \n5 - o - o - + - + \n6 * - K - * - + - \n7 - o - + - + - + \n8 + - K - + - K - \n```\nWrite a program to determine the game-ending sequence for an NxN input board if it exists. There is at least a king and at least one opponent piece on the board. The king can jump a piece on every move of the optimal solution.\n\nPOINTS: 330\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains N characters (each one of: '-', '+', 'K', or 'o') that represent row i of a proper checkboard. Line 2 always begins with '-'.\n", "outputFormat": "\\* Lines 1..?: If there is no winning sequence of jump, output\n\n'impossible' on a line by itself. If such a sequence exists, each line contains two space-separated integers that represent successive locations of a king whose moves will win the game. Any such sequence is acceptable.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO08DEC] Winning Checkers G", "background": "", "description": "奶牛在激烈地下跳棋。\n\n不幸的是，尽管他们玩得很开心，但他们在最后阶段很艰难，需要你的帮助。\n\n给定一个 $N \\times N(4 \\le N \\le 500)$ 的棋盘，确定帮助贝西“吃”掉**所有对方棋子**的移动次数最少的路径。\n\n移动规则：\n\n1. 沿对角线方向移动。\n\n1. 必须越过对方棋子到达下一个位子。\n\n1. 被越过的对方棋子视为“吃”掉。\n\n1. 贝西只能操控她的其中**1**个国王**连续**移动。\n\n请看下面的例子，其中 $N=8$ ：\n\n1. 对手棋子标记为 o\n\n1. 贝西的国王标记为 K\n\n1. 正在移动的国王标记为 >K<\n\n```\n初始状态             移动一次后          移动两次后           移动三次后\n- + - + - + - +     - + - + - + - +    - + - + - + - +     - + - + - + - + \n+ - + - + - + -     + - + - + - + -    + - + - + - + -     + - + - + - + - \n- + - K - + - +     - + - K - + - +    - + - K - + - +     - + - K - + - + \n+ - + - + - + -     + - + - + - + -    + ->K<- + - + -     + - + - + - + - \n- o - o - + - +     - o - o - + - +    - + - o - + - +     - + - + - + - + \n+ - K - + - + -    >K<- K - + - + -    + - K - + - + -     + - K ->K<- + - \n- o - + - + - +     - + - + - + - +    - + - + - + - +     - + - + - + - + \n+ ->K<- + - K -     + - + - + - K -    + - K - + - K -     + - K - + - K - \n\n这次移动的路径（标记为 * ）：\n\n  1 2 3 4 5 6 7 8          行 列 \n1 - + - + - + - +    起点:  8  3 \n2 + - + - + - + -    路径:  6  1 \n3 - + - K - + - +    路径:  4  3 \n4 + - * - + - + -    路径:  6  5 \n5 - o - o - + - + \n6 * - K - * - + - \n7 - o - + - + - + \n8 + - K - + - K - \n```\n\n编写一个程序来确定贝西的国王的移动路径。棋盘上至少有一个国王和一个对手棋子。", "inputFormat": "第一行有一个整数 $N$。\n\n接下来 $N$ 行是一个 $N \\times N$ 的矩阵，每个字符之间没有空格。", "outputFormat": "若有一条路径，输出每行包含两个空格分隔的整数，表示一位国王的连续位置。\n\n若没有这样的路径,则一行输出\"impossible\"。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2924", "type": "P", "difficulty": 6, "samples": [["6 \n5 5 \n2 3 \n3 2 \n1 5 \n5 1 \n1 1 \n", "5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2008", "USACO", "凸包", "极角排序"], "title": "[USACO08DEC] Largest Fence G", "background": null, "description": "Farmer John 的农场里有 $N$（$5\\le N\\le250$）个篱笆桩，每个都有独一无二的坐标 $(x_i,y_i)$（$1\\le x_i,y_i \\le1000$）。他想选择尽量多的篱笆桩来构建他的围栏。这个围栏要美观，所以必须是凸多边形的。那他最多能选多少个呢？\n\n所有的篱笆桩中不存在三点共线。", "inputFormat": "第一行一个整数 $N$。\n\n接下来的 $N$ 行，每行包含两个整数 $x_i,y_i$，表示第 $i$ 个篱笆桩的坐标。", "outputFormat": "输出一个整数，为构成凸多边形的最大顶点数。", "hint": "样例构成的图形可以理解为一个正方形，其内部有两个点。\n能够围成的最大凸多边形是五边形，其顶点依次为 $(2,3),(3,2),(5,1),(5,5),(1,5)$。\n\n对于 $45\\%$ 的数据，保证 $N\\le 65$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08DEC] Largest Fence G", "background": null, "description": "Farmer John has purchased $N$ ($5 \\le N \\le 250$) fence posts in order to build a very nice-looking fence. Everyone knows the best fences are convex polygons where fence posts form vertices of a polygon. The pasture is represented as a rectilinear grid; fencepost $i$ is at integer coordinates $(x_i, y_i)$ ($1 \\le x_i \\le 1000,1 \\le y_i \\le 1000$).\n\nGiven the locations of $N$ fence posts (which, intriguingly, feature no set of three points which are collinear), what is the largest number of fence posts FJ can use to create a fence that is convex?\n\nFor test cases worth $45\\%$ of the points for this problem, $N \\le 65$.", "inputFormat": "- Line $1$: A single integer: $N$.\n\n- Lines $2\\dots N+1$: Line $i+1$ describes fence post $i$'s location with two space-separated integers: $x_i$ and $y_i$.", "outputFormat": "- Line $1$: A single integer, the maximum possible number of fence posts that form a convex polygon.", "hint": "A square with two points inside.\n\nThe largest convex polygon is the pentagon $(2,3), (3,2), (5,1), (5,5), (1,5)$.", "locale": "en"}, "zh-CN": {"title": "[USACO08DEC] Largest Fence G", "background": null, "description": "Farmer John 的农场里有 $N$（$5\\le N\\le250$）个篱笆桩，每个都有独一无二的坐标 $(x_i,y_i)$（$1\\le x_i,y_i \\le1000$）。他想选择尽量多的篱笆桩来构建他的围栏。这个围栏要美观，所以必须是凸多边形的。那他最多能选多少个呢？\n\n所有的篱笆桩中不存在三点共线。", "inputFormat": "第一行一个整数 $N$。\n\n接下来的 $N$ 行，每行包含两个整数 $x_i,y_i$，表示第 $i$ 个篱笆桩的坐标。", "outputFormat": "输出一个整数，为构成凸多边形的最大顶点数。", "hint": "样例构成的图形可以理解为一个正方形，其内部有两个点。\n能够围成的最大凸多边形是五边形，其顶点依次为 $(2,3),(3,2),(5,1),(5,5),(1,5)$。\n\n对于 $45\\%$ 的数据，保证 $N\\le 65$。", "locale": "zh-CN"}}}
{"pid": "P2925", "type": "P", "difficulty": 2, "samples": [["7 3 \n2 \n6 \n5 \n", "7 \n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "USACO", "背包 DP"], "title": "[USACO08DEC] Hay For Sale S", "background": "", "description": "Farmer John suffered a terrible loss when giant Australian cockroaches ate the entirety of his hay inventory, leaving him with nothing to feed the cows. He hitched up his wagon with capacity $C$ ($1\\le C\\le 50000$) cubic units and sauntered over to Farmer Don's to get some hay before the cows miss a meal.\n\nFarmer Don had a wide variety of $H$ ($1\\le H\\le 5000$) hay bales for sale, each with its own volume ($1\\le V_i\\le C$). Bales of hay, you know, are somewhat flexible and can be jammed into the oddest of spaces in a wagon.\n\nFJ carefully evaluates the volumes so that he can figure out the largest amount of hay he can purchase for his cows.\n\nGiven the volume constraint and a list of bales to buy, what is the greatest volume of hay FJ can purchase?  He can't purchase partial bales, of course. Each input line (after the first) lists a single bale FJ can buy.", "inputFormat": "\\* Line $1$: Two space-separated integers: $C$ and $H$;\n\n\\* Lines $2\\dots H+1$: Each line describes the volume of a single bale: $V_i$.", "outputFormat": "\\* Line $1$: A single integer which is the greatest volume of hay FJ can purchase given the list of bales for sale and constraints.", "hint": "The wagon holds $7$ volumetric units; three bales are offered for sale with volumes of $2$, $6$, and $5$ units, respectively.\n\n\nBuying the two smaller bales fills the wagon.", "locale": "en", "translations": {"en": {"title": "[USACO08DEC] Hay For Sale S", "background": "", "description": "Farmer John suffered a terrible loss when giant Australian cockroaches ate the entirety of his hay inventory, leaving him with nothing to feed the cows. He hitched up his wagon with capacity $C$ ($1\\le C\\le 50000$) cubic units and sauntered over to Farmer Don's to get some hay before the cows miss a meal.\n\nFarmer Don had a wide variety of $H$ ($1\\le H\\le 5000$) hay bales for sale, each with its own volume ($1\\le V_i\\le C$). Bales of hay, you know, are somewhat flexible and can be jammed into the oddest of spaces in a wagon.\n\nFJ carefully evaluates the volumes so that he can figure out the largest amount of hay he can purchase for his cows.\n\nGiven the volume constraint and a list of bales to buy, what is the greatest volume of hay FJ can purchase?  He can't purchase partial bales, of course. Each input line (after the first) lists a single bale FJ can buy.", "inputFormat": "\\* Line $1$: Two space-separated integers: $C$ and $H$;\n\n\\* Lines $2\\dots H+1$: Each line describes the volume of a single bale: $V_i$.", "outputFormat": "\\* Line $1$: A single integer which is the greatest volume of hay FJ can purchase given the list of bales for sale and constraints.", "hint": "The wagon holds $7$ volumetric units; three bales are offered for sale with volumes of $2$, $6$, and $5$ units, respectively.\n\n\nBuying the two smaller bales fills the wagon.", "locale": "en"}, "zh-CN": {"title": "[USACO08DEC] Hay For Sale S", "background": "", "description": "农民 John 面临一个很可怕的事，因为防范力度不大所以他存储的所有稻草都被蟑螂吃光了，他将面临没有稻草喂养奶牛的局面。在奶牛断粮之前，John 拉着他的马车到农民 Don 的农场中买一些稻草给奶牛过冬。已知 John 的马车可以装的下 $C(1\\le C\\le5\\times10^4)$ 立方的稻草。\n\n农民 Don 有 $H(1\\le H\\le5\\times10^3)$ 捆体积不同的稻草可供购买，每一捆稻草有它自己的体积 $V_i(1\\le V_i\\le C)$。面对这些稻草 John 认真的计算如何充分利用马车的空间购买尽量多的稻草给他的奶牛过冬。\n\n现在给定马车的最大容积 $C$ 和每一捆稻草的体积 $V_i$，John 如何在不超过马车最大容积的情况下买到最大体积的稻草？他不可以把一捆稻草分开来买。", "inputFormat": "第一行两个整数，分别为 $C$ 和 $H$。\n第 $2$ 到 $H+1$ 行:每一行一个整数代表第 $i$ 捆稻草的体积 $V_i$。", "outputFormat": "一个整数，为 John 能买到的稻草的体积。\n\n###### 修改 by zhangsenhao6728", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2926", "type": "P", "difficulty": 3, "samples": [["5 \n2 \n1 \n2 \n3 \n4 \n", "2 \n0 \n2 \n1 \n3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO", "素数判断,质数,筛法"], "title": "[USACO08DEC] Patting Heads S", "background": "", "description": "It's Bessie's birthday and time for party games! Bessie has instructed the N (1 <= N <= 100,000) cows conveniently numbered 1..N to sit in a circle (so that cow i [except at the ends] sits next to cows i-1 and i+1; cow N sits next to cow 1). Meanwhile, Farmer John fills a barrel with one billion slips of paper, each containing some integer in the range 1..1,000,000.\n\nEach cow i then draws a number A\\_i (1 <= A\\_i <= 1,000,000) (which is not necessarily unique, of course) from the giant barrel.  Taking turns, each cow i then takes a walk around the circle and pats the heads of all other cows j such that her number A\\_i is exactly\n\ndivisible by cow j's number A\\_j; she then sits again back in her original position.\n\nThe cows would like you to help them determine, for each cow, the number of other cows she should pat.\n\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: A\\_i\n", "outputFormat": "\\* Lines 1..N: On line i, print a single integer that is the number of other cows patted by cow i.\n", "hint": "The 5 cows are given the numbers 2, 1, 2, 3, and 4, respectively.\n\n\nThe first cow pats the second and third cows; the second cows pats no cows; etc.\n", "locale": "en", "translations": {"en": {"title": "[USACO08DEC] Patting Heads S", "background": "", "description": "It's Bessie's birthday and time for party games! Bessie has instructed the N (1 <= N <= 100,000) cows conveniently numbered 1..N to sit in a circle (so that cow i [except at the ends] sits next to cows i-1 and i+1; cow N sits next to cow 1). Meanwhile, Farmer John fills a barrel with one billion slips of paper, each containing some integer in the range 1..1,000,000.\n\nEach cow i then draws a number A\\_i (1 <= A\\_i <= 1,000,000) (which is not necessarily unique, of course) from the giant barrel.  Taking turns, each cow i then takes a walk around the circle and pats the heads of all other cows j such that her number A\\_i is exactly\n\ndivisible by cow j's number A\\_j; she then sits again back in her original position.\n\nThe cows would like you to help them determine, for each cow, the number of other cows she should pat.\n\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: A\\_i\n", "outputFormat": "\\* Lines 1..N: On line i, print a single integer that is the number of other cows patted by cow i.\n", "hint": "The 5 cows are given the numbers 2, 1, 2, 3, and 4, respectively.\n\n\nThe first cow pats the second and third cows; the second cows pats no cows; etc.\n", "locale": "en"}, "zh-CN": {"title": "[USACO08DEC] Patting Heads S", "background": null, "description": "今天是 Bessie 的生日，正是玩派对游戏的好时机！Bessie 指示编号为 $1$ 到 $N$ 的 $N$ 头奶牛（$1 \\le N \\le 100,000$）围成一个圆圈坐下（因此奶牛 $i$ [除了两端] 坐在奶牛 $i-1$ 和 $i+1$ 的旁边；奶牛 $N$ 坐在奶牛 $1$ 的旁边）。与此同时，Farmer John 往一个桶里装了十亿张纸条，每张纸条上都写着一个范围在 $1$ 到 $1,000,000$ 之间的整数。\n\n每头奶牛 $i$ 然后从这个巨大的桶中抽取一个数字 $A_i$（$1 \\le A_i \\le 1,000,000$）（当然，这个数字不一定是唯一的）。轮到每头奶牛 $i$ 时，她会绕着圈走一圈，拍所有其他奶牛 $j$ 的头，只要她的数字 $A_i$ 能被奶牛 $j$ 的数字 $A_j$ 整除；然后她回到原来的位置坐下。\n\n奶牛们希望你帮助她们确定，对于每头奶牛，她应该拍多少下其他奶牛的头。", "inputFormat": "\\* 第 1 行：一个整数： $N$\n\n\\* 第 2 到 $N+1$ 行：第 $i+1$ 行包含一个整数：$A_i$", "outputFormat": "\\* 第 $1$ 到 $N$ 行：在第 $i$ 行，输出一个整数，表示被第 $i$ 头奶牛拍头的其他奶牛的数量。", "hint": "5 头奶牛分别被赋予数字 2、1、2、3 和 4。\n\n\n第一头奶牛拍了第二和第三头奶牛；第二头奶牛没有拍任何奶牛；等等。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2927", "type": "P", "difficulty": 4, "samples": [["2 3 \n1 c d 0 0 \n2 0 d b 0 \n3 c 0 d a \n4 b a b 0 \n5 d 0 0 e \n6 0 0 b e \n", "1 0 c d 0 \n3 0 d a c \n5 0 0 e d \n2 d b 0 0 \n4 a b 0 b \n6 e 0 0 b \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO"], "title": "[USACO08DEC] Jigsaw Puzzles S", "background": null, "description": "奶牛们在玩按字母表顺序排列的拼图谜题。每道谜题是有 $R$（$1 \\le R \\le 10$）列 $C$（$1 \\le C \\le 10$）行的拼图块，它们边缘是由字母或封闭边界组成，完成后的整副拼图外围是边界线，中间的边界是字母。\n\n每块拼图块都有一个序列号和 $4$ 个字母或者数字表示边界线（顺序为上右下左），在输入中，数字充当边界线。\n\n拼图可以换位和旋转，完成后的拼图在边缘的块上靠近外围的是边界线，拼图完成后，一块拼图若与另一块相邻，它们的边界字母必须相同。\n\n现在，奶牛们拿到了一系列拼图块，但由于 FJ 喊他们去吃饭，他们没有时间去拼，于是这个重大的问题就交给了你解决：这个拼图如何拼出来。", "inputFormat": "第一行两个整数 $R$，$C$。\n\n接下来 $R*C$ 行，每行描述一块拼图。", "outputFormat": "共 $R*C$ 行，每行 $5$ 个数字或字母，描述一个拼图，表示它的编号和上、右、下、左的边界线。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "", "background": "", "description": "The cows have taken up alphabetical jigsaw puzzles. In these puzzles with R (1 <= R <= 10) rows and C (1 <= C <= 10) columns, the edges are not funny-shaped cardboard shapes but rather are letters.\n\nEach piece has a serial number and 4 letters (or borders) that must be aligned as in a regular jigsaw puzzle. The pseudo-letter '0' (the digit 0) will represent a border (and a piece can have several borders if it is a corner piece or even the top of column in a, e.g., 4x1 puzzle).  Below is a set of six pieces (the borders are marked with lines instead of '0's) assembled in one way (of many) that completes the puzzle:\n\n+---+  +---+  +---+\n\n| 1 c  c 3 d  d 5 | \n+-d-+  + a +  +-e-+\n\n+-d-+  +-a-+  +-e-+\n\n| 2 b  b 4 b  b 6 | \n+---+  +---+  +---+\n\nNote that each edge letter of each piece matches the border letter of the piece adjacent to it; the borders appear properly on the top, bottom, and sides.\n\nPieces are represented by a serial number and a clockwise list of their four edges (where edges are the letters a..z and 0). Pieces might require rotation when placed in the puzzle.\n\nGiven a set of pieces, find at least one way to assemble them into a puzzle. Test data for puzzles with larger R and C are easier to solve because they have a more varied set of edge letters.\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: R and C\n\n\\* Lines 2..R\\*C+1: Each line contains five space-separated entities: an integer serial number and four edge identifiers\n", "outputFormat": "\\* Lines 1..R\\*C: Line R\\*(i-1)+j describes the puzzle piece placed a row i, column j with an integer and five space-separated entities: the serial number of the puzzle piece and the four piece edge identifiers in the order top, right, bottom, left.\n", "hint": "Describes the input puzzle although with some of the pieces rotated compared to the sample solution.\n\n\nAs shown in the diagram in the task text. Other solutions (like reflections) are possible; a grading program will check your answer.\n", "locale": "en"}, "zh-CN": {"title": "[USACO08DEC] Jigsaw Puzzles S", "background": null, "description": "奶牛们在玩按字母表顺序排列的拼图谜题。每道谜题是有 $R$（$1 \\le R \\le 10$）列 $C$（$1 \\le C \\le 10$）行的拼图块，它们边缘是由字母或封闭边界组成，完成后的整副拼图外围是边界线，中间的边界是字母。\n\n每块拼图块都有一个序列号和 $4$ 个字母或者数字表示边界线（顺序为上右下左），在输入中，数字充当边界线。\n\n拼图可以换位和旋转，完成后的拼图在边缘的块上靠近外围的是边界线，拼图完成后，一块拼图若与另一块相邻，它们的边界字母必须相同。\n\n现在，奶牛们拿到了一系列拼图块，但由于 FJ 喊他们去吃饭，他们没有时间去拼，于是这个重大的问题就交给了你解决：这个拼图如何拼出来。", "inputFormat": "第一行两个整数 $R$，$C$。\n\n接下来 $R*C$ 行，每行描述一块拼图。", "outputFormat": "共 $R*C$ 行，每行 $5$ 个数字或字母，描述一个拼图，表示它的编号和上、右、下、左的边界线。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2928", "type": "P", "difficulty": 6, "samples": [["3 1 0 0 0 2 \n0 -3 0 4 \n1 2 -1 1 \n1 -2 2 -1 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09HOL] Cattle Bruisers G", "background": "", "description": "\nCanmuu is out for revenge after being utterly defeated by Bessie in paintball and has challenged Bessie to a video game.\n\nIn this game, Bessie starts out at point $(BX, BY)$ in the coordinate grid $(-1,000 \\le BX \\le 1,000; -1000 \\le BY \\le 1,000)$, and tries to escape, starting at time 0. She moves continuously at a velocity of $(BVX, BVY)$ units/second $(-100 \\le BVX \\le 100; -100 \\le BVY \\le 100)$. Thus, at time 1 she will be at point $(BX + BVX, BY + BVY)$; at time $1.5$ she will be at $(BX + 1.5 \\times BVX, BY + 1.5\\times BVY)$.\n\nUnfortunately, Canmuu has sent $N (1 \\le N \\le 50,000)$ cattle bruisers to pursue Bessie.  At time $t=0$, cattle bruiser i is at position $(X_i, Y_i) (-1,000 \\le X_i \\le 1,000; -1,000 \\le Y_i \\le 1,000)$ with velocity $(VX_i, VY_i)$ units/second $(-1,000 \\le VX_i \\le 1,000; -1,000 \\le VY_i \\le 1,000)$.\n\nEach cattle bruiser carries a 'proximity' weapon to fire at Bessie; the weapon can hurt Bessie when the cattle bruiser is no further than $R (1 \\le R \\le 2,500)$ units from her.\n\nBessie has a shield to protect herself from these attacks. However, she does not want to waste any of her shield's power, so she would like to know the maximum number of cattle bruisers within firing range for any (potentially non-integer) time.\n\nIn order to avoid precision errors with real numbers, it is guaranteed that the answer produced will be the same whether the attack range is decreased to $R-0.0001$ or increased to $R+0.0001$.\n\nFEEDBACK: Your first $50$  submissions for this problem will be run on some of the official test data, and you will receive a summary of the results.\n\n自从卡门在弹珠游戏中被贝茜彻底击败，他一直在想找机会复仇。这会儿，他邀贝茜去玩一个电脑游戏。\n\n游戏中，贝茜在（$B_X,B_Y$）处开始行动，这时时刻为 $0$。她要试图逃离。她的速度为 ($BV_X，BV_Y$) 每秒。\n\n不幸的是，卡门为了复仇，放出 $N (1\\le N\\le 50000)$ 个杀手追击贝茜。\n\n在 $t = 0$ 时，杀手 $i$ 的位置是 $X_i$, $Y_i$ 他的速度是 $Vx_i,Vy_i$ 每秒。\n\n由于每个杀手配备了手枪，手枪的射程是 $R$，也就是说贝茜要与这个杀手的距离需要保持超过 $R$，否则有性命之虞。\n\n然而，贝茜还有一件秘密武器，盾。但是，她不想过多地消耗盾的能量。所以，她想知道在逃脱过程中，某一个时刻她在最多为多少个杀手的射程内。当然这个时刻不一定是整数。\n\n为了防止出现精度误差，数据保证在 $r+10^{-4}\\le R\\le r+10^{-4}$ 时也能得出正确结果。", "inputFormat": "\\* Line $1$: Six space-separated integers: $N$, $R$, $BX$, $BY$, $BVX$, and $BVY$.\n\n\\* Lines $2$ ~ $N+1$: Line i+1 contains four space-separated integers: $X_i$, $Y_i$, $VX_i$, and $VY_i$.\n\n第一行：六个整数：$N,R,B_X,B_Y,BV_X,BV_Y$.\n\n后 $n$ 行每行包含四个整数：$X_i,Y_i,Vx_i,Vy_i$.", "outputFormat": "\\* Line $1$: Print a single integer denoting the maximum number of cattle bruisers within attack range at any point in time.\n\n\n输出一个整数，表示在任意时刻攻击范围内最多可存在的杀手数量。", "hint": "\nBessie starts at point $(0, 0)$ and is moving at $2$ units per second in the (positive) y-direction. There are $3$ cattle bruisers, the first of which starts at point $(0, -3)$ and travels $4$ units per second in the y-direction. The maximum distance for a cattle bruiser to be in range of Bessie is $1$ unit.\n\nAt time $1.5$, Bessie is at point $(0, 3)$, and the three bruisers are at points $(0, 3)$, $(-0.5, 3.5)$, and $(4, -3.5)$. The first two cattle bruisers are within $1$ unit of Bessie, while the third will never be within $1$ unit of Bessie, so $2$ is the most achievable.\n\n样例解释：\n\n贝茜从点 $(0, 0)$ 出发，以每秒 $2$ 个单位的速度沿 y 轴正方向移动。有 $3$ 个杀手，其中第一个从点 $(0, -3)$ 出发，以每秒 $4$ 个单位的速度沿 y 轴移动。杀手与贝茜的最远有效距离为 $1$ 个单位。\n\n在时刻 $1.5$，贝茜位于点 $(0, 3)$，而三个杀手分别位于点 $(0, 3),(-0.5, 3.5)$ 和 $(4, -3.5)$。前两个杀手与贝茜的距离均不超过 $1$ 单位，但第三个杀手永远无法进入贝茜 $1$ 单位范围内，因此最多可存在的杀手数量为 $2$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09HOL] Cattle Bruisers G", "background": "", "description": "Canmuu is out for revenge after being utterly defeated by Bessie in paintball and has challenged Bessie to a video game.\n\nIn this game, Bessie starts at point $(BX, BY)$ in the coordinate grid ($-1{,}000 \\le BX \\le 1{,}000$; $-1{,}000 \\le BY \\le 1{,}000$) at time $0$. She moves continuously with velocity $(BVX, BVY)$ units per second ($-100 \\le BVX \\le 100$; $-100 \\le BVY \\le 100$). Thus, at time $1$ she will be at point $(BX + BVX, BY + BVY)$; at time $1.5$ she will be at $(BX + 1.5 \\times BVX, BY + 1.5 \\times BVY)$.\n\nUnfortunately, Canmuu has sent $N$ ($1 \\le N \\le 50{,}000$) cattle bruisers to pursue Bessie. At time $t = 0$, cattle bruiser $i$ is at position $(X_i, Y_i)$ ($-1{,}000 \\le X_i \\le 1{,}000$; $-1{,}000 \\le Y_i \\le 1{,}000$) with velocity $(VX_i, VY_i)$ units per second ($-1{,}000 \\le VX_i \\le 1{,}000$; $-1{,}000 \\le VY_i \\le 1{,}000$).\n\nEach cattle bruiser carries a \"proximity\" weapon that can hurt Bessie when the cattle bruiser is no farther than $R$ ($1 \\le R \\le 2{,}500$) units from her.\n\nBessie has a shield to protect herself from these attacks. However, she does not want to waste any of her shield’s power, so she would like to know the maximum number of cattle bruisers within firing range at any (possibly non-integer) time.\n\nTo avoid precision errors with real numbers, it is guaranteed that the answer remains the same whether the attack range is decreased to $R - 10^{-4}$ or increased to $R + 10^{-4}$.", "inputFormat": "- Line $1$: Six space-separated integers: $N$, $R$, $BX$, $BY$, $BVX$, $BVY$.\n- Lines $2$ to $N + 1$: Line $i + 1$ contains four space-separated integers: $X_i$, $Y_i$, $VX_i$, $VY_i$.", "outputFormat": "- Line $1$: Print a single integer denoting the maximum number of cattle bruisers within attack range at any point in time.", "hint": "Bessie starts at point $(0, 0)$ and is moving at $2$ units per second in the positive y-direction. There are $3$ cattle bruisers; the first starts at point $(0, -3)$ and travels $4$ units per second in the y-direction. The maximum distance for a cattle bruiser to be in range of Bessie is $1$ unit.\n\nAt time $1.5$, Bessie is at point $(0, 3)$, and the three bruisers are at points $(0, 3)$, $(-0.5, 3.5)$, and $(4, -3.5)$. The first two cattle bruisers are within $1$ unit of Bessie, while the third will never be within $1$ unit of Bessie, so the maximum achievable number is $2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09HOL] Cattle Bruisers G", "background": "", "description": "\nCanmuu is out for revenge after being utterly defeated by Bessie in paintball and has challenged Bessie to a video game.\n\nIn this game, Bessie starts out at point $(BX, BY)$ in the coordinate grid $(-1,000 \\le BX \\le 1,000; -1000 \\le BY \\le 1,000)$, and tries to escape, starting at time 0. She moves continuously at a velocity of $(BVX, BVY)$ units/second $(-100 \\le BVX \\le 100; -100 \\le BVY \\le 100)$. Thus, at time 1 she will be at point $(BX + BVX, BY + BVY)$; at time $1.5$ she will be at $(BX + 1.5 \\times BVX, BY + 1.5\\times BVY)$.\n\nUnfortunately, Canmuu has sent $N (1 \\le N \\le 50,000)$ cattle bruisers to pursue Bessie.  At time $t=0$, cattle bruiser i is at position $(X_i, Y_i) (-1,000 \\le X_i \\le 1,000; -1,000 \\le Y_i \\le 1,000)$ with velocity $(VX_i, VY_i)$ units/second $(-1,000 \\le VX_i \\le 1,000; -1,000 \\le VY_i \\le 1,000)$.\n\nEach cattle bruiser carries a 'proximity' weapon to fire at Bessie; the weapon can hurt Bessie when the cattle bruiser is no further than $R (1 \\le R \\le 2,500)$ units from her.\n\nBessie has a shield to protect herself from these attacks. However, she does not want to waste any of her shield's power, so she would like to know the maximum number of cattle bruisers within firing range for any (potentially non-integer) time.\n\nIn order to avoid precision errors with real numbers, it is guaranteed that the answer produced will be the same whether the attack range is decreased to $R-0.0001$ or increased to $R+0.0001$.\n\nFEEDBACK: Your first $50$  submissions for this problem will be run on some of the official test data, and you will receive a summary of the results.\n\n自从卡门在弹珠游戏中被贝茜彻底击败，他一直在想找机会复仇。这会儿，他邀贝茜去玩一个电脑游戏。\n\n游戏中，贝茜在（$B_X,B_Y$）处开始行动，这时时刻为 $0$。她要试图逃离。她的速度为 ($BV_X，BV_Y$) 每秒。\n\n不幸的是，卡门为了复仇，放出 $N (1\\le N\\le 50000)$ 个杀手追击贝茜。\n\n在 $t = 0$ 时，杀手 $i$ 的位置是 $X_i$, $Y_i$ 他的速度是 $Vx_i,Vy_i$ 每秒。\n\n由于每个杀手配备了手枪，手枪的射程是 $R$，也就是说贝茜要与这个杀手的距离需要保持超过 $R$，否则有性命之虞。\n\n然而，贝茜还有一件秘密武器，盾。但是，她不想过多地消耗盾的能量。所以，她想知道在逃脱过程中，某一个时刻她在最多为多少个杀手的射程内。当然这个时刻不一定是整数。\n\n为了防止出现精度误差，数据保证在 $r+10^{-4}\\le R\\le r+10^{-4}$ 时也能得出正确结果。", "inputFormat": "\\* Line $1$: Six space-separated integers: $N$, $R$, $BX$, $BY$, $BVX$, and $BVY$.\n\n\\* Lines $2$ ~ $N+1$: Line i+1 contains four space-separated integers: $X_i$, $Y_i$, $VX_i$, and $VY_i$.\n\n第一行：六个整数：$N,R,B_X,B_Y,BV_X,BV_Y$.\n\n后 $n$ 行每行包含四个整数：$X_i,Y_i,Vx_i,Vy_i$.", "outputFormat": "\\* Line $1$: Print a single integer denoting the maximum number of cattle bruisers within attack range at any point in time.\n\n\n输出一个整数，表示在任意时刻攻击范围内最多可存在的杀手数量。", "hint": "\nBessie starts at point $(0, 0)$ and is moving at $2$ units per second in the (positive) y-direction. There are $3$ cattle bruisers, the first of which starts at point $(0, -3)$ and travels $4$ units per second in the y-direction. The maximum distance for a cattle bruiser to be in range of Bessie is $1$ unit.\n\nAt time $1.5$, Bessie is at point $(0, 3)$, and the three bruisers are at points $(0, 3)$, $(-0.5, 3.5)$, and $(4, -3.5)$. The first two cattle bruisers are within $1$ unit of Bessie, while the third will never be within $1$ unit of Bessie, so $2$ is the most achievable.\n\n样例解释：\n\n贝茜从点 $(0, 0)$ 出发，以每秒 $2$ 个单位的速度沿 y 轴正方向移动。有 $3$ 个杀手，其中第一个从点 $(0, -3)$ 出发，以每秒 $4$ 个单位的速度沿 y 轴移动。杀手与贝茜的最远有效距离为 $1$ 个单位。\n\n在时刻 $1.5$，贝茜位于点 $(0, 3)$，而三个杀手分别位于点 $(0, 3),(-0.5, 3.5)$ 和 $(4, -3.5)$。前两个杀手与贝茜的距离均不超过 $1$ 单位，但第三个杀手永远无法进入贝茜 $1$ 单位范围内，因此最多可存在的杀手数量为 $2$。", "locale": "zh-CN"}}}
{"pid": "P2929", "type": "P", "difficulty": 5, "samples": [["4 1 3 \n0110 \n", "4 \n1001 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09HOL] Transmission Delay G", "background": "", "description": "Farmer John has taken to yodeling from the top of the barn in order to communicate with the cows out in the pastures. Being bovine and all, cows can hear binary messages (0's and 1's) but have trouble with perfect communications because FJ's yodeling echoes off the silo. In fact, in a sequence of N (1 <= N <= 2,000) bits, Bessie will always receive a sequence of N bits, with the same number of 0s and 1s, but each 0 or 1 might be delayed.\n\nPrecisely speaking, for a given number D (0 <= D < N), the i-th bit might be heard as the j-th one as long as |i - j| <= D (in other words, no bit appears in a position farther than distance D from its original position). \nConsider the following message as an example: 0110. Four possible messages might be heard if D = 1: 0101, 0110, 1001, and 1010.\n\nGiven the message to be yodeled by FJ, along with two numbers D and K (1 <= K <= 100,000,000), determine the number of different messages that might be heard by Bessie, modulo 100,000,000. Also determine the K-th smallest such message in lexicographical order (in binary representation, with 0 coming before 1). It is guaranteed that K will be no larger than the number of different possible messages.\n\nMEMORY LIMIT: 32 MB\n\nTIME LIMIT: 2 seconds\n\nFEEDBACK: Your first 50 submissions for this problem will be run on some of the official test data, and you will receive a summary of the results.\n\n约翰在屋顶上唱歌，以此来与奶牛们交流。但是奶牛们的听力很奇怪，她们只能听到约翰的歌声变成 $0$ 和 $1$ 构成的信息串时的样子。约翰的声音里有 $N  (1 \\leq N \\leq 2000)$ 个 $0$ 或 $1$，奶牛听到的也是 $N$ 个，而且 $0$ 和 $1$ 的数量不会变化，但是一部分 $0$ 或 $1$ 可能偏离原来的位置，这就是约翰的歌声在传输时发生的“传输延迟”现象。$0$ 或 $1$ 的偏离距离不会超过 $D(O \\leq D < N)$，也就是说某一个码的原本位置和现在的位置之差的绝对值不大于 $D$。\n\n比如，对于 `0110`，$D = 1$，传输延迟发生后可能出现 `0101`，`0110`，`1001`，`1010` 这四种串．\n\n给出约翰歌声的 $01$ 串形式和一个整数 $K(1 \\leq K \\leq10^8)$，请计算传输延迟发生后一共有多少种可能的 $01$ 串，以及其中第 $K$ 大的串是什么。", "inputFormat": "\\* Line 1: Three space-separated integers: N, D, and K\n\n\\* Line 2: FJ's binary message, containing exactly N bits\n", "outputFormat": "\\* Line 1: The number of different possible messages that can heard by Bessie, mod 100,000,000\n\n\\* Line 2: The K-th smallest such message (in binary representation)\n\nNote that if your program's first line of output is correct but the second line of output is either missing or wrong, you will receive 40% of the points for that test case.\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09HOL] Transmission Delay G", "background": "", "description": "Farmer John has taken to yodeling from the top of the barn in order to communicate with the cows out in the pastures. Being bovine and all, cows can hear binary messages (0's and 1's) but have trouble with perfect communications because FJ's yodeling echoes off the silo. In fact, in a sequence of N (1 <= N <= 2,000) bits, Bessie will always receive a sequence of N bits, with the same number of 0s and 1s, but each 0 or 1 might be delayed.\n\nPrecisely speaking, for a given number D (0 <= D < N), the i-th bit might be heard as the j-th one as long as |i - j| <= D (in other words, no bit appears in a position farther than distance D from its original position). Consider the following message as an example: 0110. Four possible messages might be heard if D = 1: 0101, 0110, 1001, and 1010.\n\nGiven the message to be yodeled by FJ, along with two numbers D and K (1 <= K <= 100,000,000), determine the number of different messages that might be heard by Bessie, modulo 100,000,000. Also determine the K-th smallest such message in lexicographical order (in binary representation, with 0 coming before 1). It is guaranteed that K will be no larger than the number of different possible messages.\n\nMEMORY LIMIT: 32 MB.\n\nTIME LIMIT: 2 seconds.\n\nFEEDBACK: Your first 50 submissions for this problem will be run on some of the official testdata, and you will receive a summary of the results.\n\nFarmer John sings from the rooftop to communicate with the cows. The cows can only hear the message when it is represented as a string of $0$ and $1$. There are $N  (1 \\leq N \\leq 2000)$ bits in Farmer John's voice, and the cows will also hear $N$ bits, with the counts of $0$ and $1$ unchanged, but some bits may shift from their original positions due to “transmission delay.” The shift distance will not exceed $D(O \\leq D < N)$, meaning the absolute difference between a bit’s original position and its received position is at most $D$.\n\nFor example, for `0110` with $D = 1$, the possible received strings are `0101`, `0110`, `1001`, and `1010`.\n\nGiven the $01$-string of Farmer John’s message and an integer $K(1 \\leq K \\leq10^8)$, compute the total number of possible $01$ strings after transmission delay, and find the K-th smallest string in lexicographical order.", "inputFormat": "- Line 1: Three space-separated integers: N, D, and K.\n- Line 2: FJ's binary message, containing exactly N bits.", "outputFormat": "- Line 1: The number of different possible messages that can be heard by Bessie, modulo 100,000,000.\n- Line 2: The K-th smallest such message (in binary representation).\n\nNote that if your program's first line of output is correct but the second line of output is either missing or wrong, you will receive 40% of the points for that test case.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09HOL] Transmission Delay G", "background": "", "description": "Farmer John has taken to yodeling from the top of the barn in order to communicate with the cows out in the pastures. Being bovine and all, cows can hear binary messages (0's and 1's) but have trouble with perfect communications because FJ's yodeling echoes off the silo. In fact, in a sequence of N (1 <= N <= 2,000) bits, Bessie will always receive a sequence of N bits, with the same number of 0s and 1s, but each 0 or 1 might be delayed.\n\nPrecisely speaking, for a given number D (0 <= D < N), the i-th bit might be heard as the j-th one as long as |i - j| <= D (in other words, no bit appears in a position farther than distance D from its original position). \nConsider the following message as an example: 0110. Four possible messages might be heard if D = 1: 0101, 0110, 1001, and 1010.\n\nGiven the message to be yodeled by FJ, along with two numbers D and K (1 <= K <= 100,000,000), determine the number of different messages that might be heard by Bessie, modulo 100,000,000. Also determine the K-th smallest such message in lexicographical order (in binary representation, with 0 coming before 1). It is guaranteed that K will be no larger than the number of different possible messages.\n\nMEMORY LIMIT: 32 MB\n\nTIME LIMIT: 2 seconds\n\nFEEDBACK: Your first 50 submissions for this problem will be run on some of the official test data, and you will receive a summary of the results.\n\n约翰在屋顶上唱歌，以此来与奶牛们交流。但是奶牛们的听力很奇怪，她们只能听到约翰的歌声变成 $0$ 和 $1$ 构成的信息串时的样子。约翰的声音里有 $N  (1 \\leq N \\leq 2000)$ 个 $0$ 或 $1$，奶牛听到的也是 $N$ 个，而且 $0$ 和 $1$ 的数量不会变化，但是一部分 $0$ 或 $1$ 可能偏离原来的位置，这就是约翰的歌声在传输时发生的“传输延迟”现象。$0$ 或 $1$ 的偏离距离不会超过 $D(O \\leq D < N)$，也就是说某一个码的原本位置和现在的位置之差的绝对值不大于 $D$。\n\n比如，对于 `0110`，$D = 1$，传输延迟发生后可能出现 `0101`，`0110`，`1001`，`1010` 这四种串．\n\n给出约翰歌声的 $01$ 串形式和一个整数 $K(1 \\leq K \\leq10^8)$，请计算传输延迟发生后一共有多少种可能的 $01$ 串，以及其中第 $K$ 大的串是什么。", "inputFormat": "\\* Line 1: Three space-separated integers: N, D, and K\n\n\\* Line 2: FJ's binary message, containing exactly N bits\n", "outputFormat": "\\* Line 1: The number of different possible messages that can heard by Bessie, mod 100,000,000\n\n\\* Line 2: The K-th smallest such message (in binary representation)\n\nNote that if your program's first line of output is correct but the second line of output is either missing or wrong, you will receive 40% of the points for that test case.\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2930", "type": "P", "difficulty": 6, "samples": [["17 15 10 \n111111101111111 \n111111000111111 \n111110000011111 \n111100000001111 \n111000000000111 \n111100000001111 \n111000000000111 \n110000000000011 \n111000000000111 \n110000000000011 \n100000000000001 \n110000000000011 \n100000000000001 \n000000000000000 \n111111000111111 \n111111000111111 \n111111000111111 \n5 8 2 14 1 \n8 17 3 7 1 \n4 5 10 15 0 \n7 16 12 14 1 \n2 17 13 14 0 \n2 6 2 3 1 \n13 14 4 8 1 \n3 6 6 7 1 \n1 16 10 11 0 \n7 16 10 10 0 \n", "113 \n94 \n95 \n91 \n87 \n93 \n91 \n87 \n93 \n93 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "线段树", "USACO", "颜色段均摊（珂朵莉树 ODT）"], "title": "[USACO09HOL] Holiday Painting G", "background": null, "description": "为了表达假日的激情，奶牛们要画一幅巨大的画。\n\n画布可以分成 $R\\times C$ 个方格，从上到下编为 $1$ 到 $R$ 行，从左到右编为 $1$ 到 $C$ 列。作画的颜色有两种，白色（用 $0$ 表示）或者黑色（用 $1$ 表示）。\n\n由于时间紧迫，奶牛们不得不请教北面的邻居，卡门。卡门送给它们一台机器，一次操作只输入 $5$ 个参数 $R1_i,R2_i,C1_i,C2_i,X_i$（$1 \\le R1_i \\le R2_i \\le R$，$1 \\le C1_i \\le C2_i \\le C$，$0 \\le X_i \\le 1$），表示把 $R1_i$ 行到 $R2_i$ 行，$C1_i$ 列到 $C2_i$ 列的一个大长方形涂成 $X_i$ 色。在所有操作还未进行的时候，画布是白色的。\n\n奶牛们一共要进行 $Q$ 次操作。\n\n因为这样的画法总要出些差错，所以奶牛们想请你算算，每一次操作过后，一共有多少个方格与它们的目标画里对应的方格是同色的。", "inputFormat": "第一行包括三个整数 $R,C,Q$。\n\n第二行至第 $R+1$ 行：第 $i+1$ 行包含 $C$ 个字符，每个字符均为 $0$ 或 $1$，表示网格的第 $i$ 行。\n\n第 $R+2$ 行至第 $R+Q+1$ 行：第 $R+i+1$ 行包含五个整数，表示一次涂色操作：$R1_i,R2_i,C1_i,C2_i,X_i$。", "outputFormat": "对于每次操作，输出一行一个整数，表示此次操作后匹配的方格数量。", "hint": "### 样例解释\n\n奶牛们想要画一幅节日树的图画。\n\n第一次操作后，图像网格如下所示：\n\n```markdown\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n011111111111110\n011111111111110\n011111111111110\n011111111111110\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n```\n\n有 $113$ 个方格与树形图像中的对应方格相匹配，它们以下方的```x```标记表示（其他部分则按首次涂色后的实际形态展示）：\n```markdown\n0000000x0000000\n000000xxx000000\n00000xxxxx00000\n0000xxxxxxx0000\n0xx111111111xx0\n0xxx1111111xxx0\n0xx111111111xx0\n0x11111111111x0\n000xxxxxxxxx000\n00xxxxxxxxxxx00\n0xxxxxxxxxxxxx0\n00xxxxxxxxxxx00\n0xxxxxxxxxxxxx0\nxxxxxxxxxxxxxxx\n000000xxx000000\n000000xxx000000\n000000xxx000000\n```\n\n### 数据范围\n\n对于所有数据：\n\n$1\\le Q\\le 10^4$，$1\\le R\\le 5\\times10^4$，$1\\le C\\le 15$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09HOL] Holiday Painting G", "background": "", "description": "The cows want to paint a large picture on an $R \\times C$ grid ($1 \\le R \\le 50{,}000$, $1 \\le C \\le 15$). Each cell holds a bit, either 0 or 1. Rows are numbered $1..R$, and columns are numbered $1..C$. The initial picture is all 0s.\n\nThey will perform $Q$ operations ($1 \\le Q \\le 10{,}000$). Each operation takes five parameters $R1_i,R2_i,C1_i,C2_i,X_i$ $(1 \\le R1_i \\le R2_i \\le R; 1 \\le C1_i \\le C2_i \\le C; 0 \\le X_i \\le 1)$, and paints every cell in rows $R1_i$ to $R2_i$ and columns $C1_i$ to $C2_i$ to color $X_i$.\n\nA target image is given as an $R \\times C$ grid of '0'/'1' characters. After each operation, output how many cells in the current painted grid match the corresponding cells in the target image.\n\nMemory limit: 64 MB. Time limit: 1.5 seconds.", "inputFormat": "- Line 1: Three space-separated integers: $R$, $C$, and $Q$.\n- Lines 2..$R+1$: Line $i+1$ contains $C$ characters, each '0' or '1', denoting the $i$-th row of the target grid.\n- Lines $R+2..R+Q+1$: Line $R+i+1$ contains five space-separated integers representing a paint operation: $R1_i$, $R2_i$, $C1_i$, $C2_i$, and $X_i$.", "outputFormat": "- Lines 1..$Q$: On line $i$, print a single integer representing the number of matching unit squares after the $i$-th operation.", "hint": "The cows want to paint a picture of a holiday tree.\n\nAfter the first operation, the picture grid looks as follows:\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\n011111111111110\n\n011111111111110\n\n011111111111110\n\n011111111111110\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\nThere are 113 unit squares which match the corresponding square in the tree image; they are denoted below by an 'x' (the other bits are shown as they appear after the first paint splash):\n\n0000000x0000000\n\n000000xxx000000\n\n00000xxxxx00000\n\n0000xxxxxxx0000\n\n0xx111111111xx0\n\n0xxx1111111xxx0\n\n0xx111111111xx0\n\n0x11111111111x0\n\n000xxxxxxxxx000\n\n00xxxxxxxxxxx00\n\n0xxxxxxxxxxxxx0\n\n00xxxxxxxxxxx00\n\n0xxxxxxxxxxxxx0\n\nxxxxxxxxxxxxxxx\n\n000000xxx000000\n\n000000xxx000000\n\n000000xxx000000.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09HOL] Holiday Painting G", "background": null, "description": "为了表达假日的激情，奶牛们要画一幅巨大的画。\n\n画布可以分成 $R\\times C$ 个方格，从上到下编为 $1$ 到 $R$ 行，从左到右编为 $1$ 到 $C$ 列。作画的颜色有两种，白色（用 $0$ 表示）或者黑色（用 $1$ 表示）。\n\n由于时间紧迫，奶牛们不得不请教北面的邻居，卡门。卡门送给它们一台机器，一次操作只输入 $5$ 个参数 $R1_i,R2_i,C1_i,C2_i,X_i$（$1 \\le R1_i \\le R2_i \\le R$，$1 \\le C1_i \\le C2_i \\le C$，$0 \\le X_i \\le 1$），表示把 $R1_i$ 行到 $R2_i$ 行，$C1_i$ 列到 $C2_i$ 列的一个大长方形涂成 $X_i$ 色。在所有操作还未进行的时候，画布是白色的。\n\n奶牛们一共要进行 $Q$ 次操作。\n\n因为这样的画法总要出些差错，所以奶牛们想请你算算，每一次操作过后，一共有多少个方格与它们的目标画里对应的方格是同色的。", "inputFormat": "第一行包括三个整数 $R,C,Q$。\n\n第二行至第 $R+1$ 行：第 $i+1$ 行包含 $C$ 个字符，每个字符均为 $0$ 或 $1$，表示网格的第 $i$ 行。\n\n第 $R+2$ 行至第 $R+Q+1$ 行：第 $R+i+1$ 行包含五个整数，表示一次涂色操作：$R1_i,R2_i,C1_i,C2_i,X_i$。", "outputFormat": "对于每次操作，输出一行一个整数，表示此次操作后匹配的方格数量。", "hint": "### 样例解释\n\n奶牛们想要画一幅节日树的图画。\n\n第一次操作后，图像网格如下所示：\n\n```markdown\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n011111111111110\n011111111111110\n011111111111110\n011111111111110\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n```\n\n有 $113$ 个方格与树形图像中的对应方格相匹配，它们以下方的```x```标记表示（其他部分则按首次涂色后的实际形态展示）：\n```markdown\n0000000x0000000\n000000xxx000000\n00000xxxxx00000\n0000xxxxxxx0000\n0xx111111111xx0\n0xxx1111111xxx0\n0xx111111111xx0\n0x11111111111x0\n000xxxxxxxxx000\n00xxxxxxxxxxx00\n0xxxxxxxxxxxxx0\n00xxxxxxxxxxx00\n0xxxxxxxxxxxxx0\nxxxxxxxxxxxxxxx\n000000xxx000000\n000000xxx000000\n000000xxx000000\n```\n\n### 数据范围\n\n对于所有数据：\n\n$1\\le Q\\le 10^4$，$1\\le R\\le 5\\times10^4$，$1\\le C\\le 15$。", "locale": "zh-CN"}}}
{"pid": "P2931", "type": "P", "difficulty": 0, "samples": [["0 6 \n", "#FILE perlbrac 0 \n6 \n0 \n1 \n0 \n2 \n1 \n0 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2009", "线段树", "USACO", "树状数组", "Special Judge"], "title": "[USACO09HOL] Pearl Bracelet G【征集 SPJ】", "background": "", "description": "Bessie received a magic bracelet of a set of the rarest black pearls for her favorite holiday. Bessie loved the bracelet and marveled that each pearl contained a small number engraved on it. She noticed that if you align the the bracelet's pearls in all the possible ways by bending it around some point (see below), the 'progressive' sums of the pearls' numbers that have corresponding numbers on the top and bottom sides of the bracelet never, everatch when compared using mod M (2 <= M <= 100). 'Progressive' sums are exemplified below.\n\nSuppose the mod M is 3. Consider a bracelet with N=6 pearls, etched sequentially with the numbers 0, 1, 0, 2, 1, 0. We'll illustrate this bracelet with its clasps like this:\n\n>0-1-0-2-1-0< \nThe six-pearl bracelet can be laid out on the ground in five different ways so that some pearls 'correspond' to each other (see below). We can 'progressively' sum-mod-M those pearls that correspond on the top and also sum-mod-M the corresponding pearls on the bottom, as shown with ONE-sums, TWO-sums, THREE-sums (and so on when N > 6).\n\n```cpp\n               |     THREE-sums         |     TWO-sums      | ONE-sums\n --------------+------------------------+-------------------+--------- \n    >0-1-0-2-1 |                        |                   | => 1 |\n               |                        |                   | \n            >0 |                        |                   | => 0 \n --------------+------------------------+-------------------+--------- \n      >0-1-0-2 |                        | => 0+2 = 2        | => 2 | \n               |                        |                   | \n          >0-1 |                        | => 0+1 = 1        | => 1 \n --------------+------------------------+-------------------+--------- \n        >0-1-0 | => 0+1+0 = 1           | => 1+0 = 1        | => 0 | \n               |                        |                   | \n        >0-1-2 | => 0+1+2 = 3 mod 3 = 0 | => 1+2 mod 3 = 0  | => 2 \n --------------+------------------------+-------------------+--------- \n          >0-1 |                        | => 0+1 = 1        | => 1 | \n               |                        |                   | \n      >0-1-2-0 |                        | => 2+0 = 2        | => 0 \n --------------+------------------------+-------------------+--------- \n            >0 |                        |                   | => 0 | \n               |                        |                   | \n    >0-1-2-0-1 |                        |                   | => 1 \n```\n\n\n\nBessie notes that all the pairs of sums contain different numbers and has heard this is true for all the magic bracelets. Bessie wondered what is longest possible bracelet that has this unique-sum property.\n\nGiven M, find a really long (but no longer than 20,000) set of numbers can be etched on the black pearls to maintain this unique sum property for a bracelet.\n\nThis is an output-only problem, the 15 input files can be downloaded at: http://ace.delos.com/perlbrac.zip\n\nSCORING: Scoring for this problem will be relative; your integer score (out of 10) for each test case will be int (10 \\* sqrt (YOURS / BEST)), where YOURS is the length of your solution, and BEST is the length of the best solution among all contestants.\n\nFEEDBACK: When you submit a file for grading, it will be checked for both correct format and validity (i.e., whether it satisfies the required numerical properties), and you will be informed of the results.\n", "inputFormat": "\\* Line 1: Two space-separated integers: the case number and M\n", "outputFormat": "\\* Line 1: A single line containing the task name and case number: #FILE perlbrac CASENUM\n\n\\* Line 2: A single line with a single integer, N (which must be no larger than 20,000)\n\n\\* Lines 3..N+1: Line i+2 contains a single integer that is the integer etched onto the i-th pearl on the bracelet; this number should be between 0 and M - 1, inclusive\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO09HOL] Pearl Bracelet G【征集 SPJ】", "background": "", "description": "Bessie received a magic bracelet of a set of the rarest black pearls for her favorite holiday. Bessie loved the bracelet and marveled that each pearl contained a small number engraved on it. She noticed that if you align the the bracelet's pearls in all the possible ways by bending it around some point (see below), the 'progressive' sums of the pearls' numbers that have corresponding numbers on the top and bottom sides of the bracelet never, everatch when compared using mod M (2 <= M <= 100). 'Progressive' sums are exemplified below.\n\nSuppose the mod M is 3. Consider a bracelet with N=6 pearls, etched sequentially with the numbers 0, 1, 0, 2, 1, 0. We'll illustrate this bracelet with its clasps like this:\n\n>0-1-0-2-1-0< \nThe six-pearl bracelet can be laid out on the ground in five different ways so that some pearls 'correspond' to each other (see below). We can 'progressively' sum-mod-M those pearls that correspond on the top and also sum-mod-M the corresponding pearls on the bottom, as shown with ONE-sums, TWO-sums, THREE-sums (and so on when N > 6).\n\n```cpp\n               |     THREE-sums         |     TWO-sums      | ONE-sums\n --------------+------------------------+-------------------+--------- \n    >0-1-0-2-1 |                        |                   | => 1 |\n               |                        |                   | \n            >0 |                        |                   | => 0 \n --------------+------------------------+-------------------+--------- \n      >0-1-0-2 |                        | => 0+2 = 2        | => 2 | \n               |                        |                   | \n          >0-1 |                        | => 0+1 = 1        | => 1 \n --------------+------------------------+-------------------+--------- \n        >0-1-0 | => 0+1+0 = 1           | => 1+0 = 1        | => 0 | \n               |                        |                   | \n        >0-1-2 | => 0+1+2 = 3 mod 3 = 0 | => 1+2 mod 3 = 0  | => 2 \n --------------+------------------------+-------------------+--------- \n          >0-1 |                        | => 0+1 = 1        | => 1 | \n               |                        |                   | \n      >0-1-2-0 |                        | => 2+0 = 2        | => 0 \n --------------+------------------------+-------------------+--------- \n            >0 |                        |                   | => 0 | \n               |                        |                   | \n    >0-1-2-0-1 |                        |                   | => 1 \n```\n\n\n\nBessie notes that all the pairs of sums contain different numbers and has heard this is true for all the magic bracelets. Bessie wondered what is longest possible bracelet that has this unique-sum property.\n\nGiven M, find a really long (but no longer than 20,000) set of numbers can be etched on the black pearls to maintain this unique sum property for a bracelet.\n\nThis is an output-only problem, the 15 input files can be downloaded at: http://ace.delos.com/perlbrac.zip\n\nSCORING: Scoring for this problem will be relative; your integer score (out of 10) for each test case will be int (10 \\* sqrt (YOURS / BEST)), where YOURS is the length of your solution, and BEST is the length of the best solution among all contestants.\n\nFEEDBACK: When you submit a file for grading, it will be checked for both correct format and validity (i.e., whether it satisfies the required numerical properties), and you will be informed of the results.\n", "inputFormat": "\\* Line 1: Two space-separated integers: the case number and M\n", "outputFormat": "\\* Line 1: A single line containing the task name and case number: #FILE perlbrac CASENUM\n\n\\* Line 2: A single line with a single integer, N (which must be no larger than 20,000)\n\n\\* Lines 3..N+1: Line i+2 contains a single integer that is the integer etched onto the i-th pearl on the bracelet; this number should be between 0 and M - 1, inclusive\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO09HOL] Pearl Bracelet G【征集 SPJ】", "background": "", "description": "Bessie 收到了一个魔法手镯，这是一套稀有的黑珍珠，是她最喜欢的节日礼物。Bessie 非常喜欢这个手镯，并惊奇地发现每颗珍珠上都刻有一个小数字。她注意到，如果通过围绕某个点弯曲手镯来排列珍珠的所有可能方式（见下文），手镯上下两侧对应数字的珍珠的「渐进」和在模 M（2 <= M <= 100）比较时从未匹配过。「渐进」和的例子如下。\n\n假设模 M 为 3。考虑一个有 N=6 颗珍珠的手镯，珍珠上依次刻有数字 0, 1, 0, 2, 1, 0。我们将这个手镯用它的扣子这样表示：\n\n>0-1-0-2-1-0< \n这个六颗珍珠的手镯可以在地上以五种不同的方式排列，使得某些珍珠「对应」彼此（见下文）。我们可以对上面对应的珍珠进行「渐进」和模 M 运算，也可以对下面对应的珍珠进行和模 M 运算，如同用 ONE-sums, TWO-sums, THREE-sums（当 N > 6 时以此类推）所示。\n\n```cpp\n               |     THREE-sums         |     TWO-sums      | ONE-sums\n --------------+------------------------+-------------------+--------- \n    >0-1-0-2-1 |                        |                   | => 1 |\n               |                        |                   | \n            >0 |                        |                   | => 0 \n --------------+------------------------+-------------------+--------- \n      >0-1-0-2 |                        | => 0+2 = 2        | => 2 | \n               |                        |                   | \n          >0-1 |                        | => 0+1 = 1        | => 1 \n --------------+------------------------+-------------------+--------- \n        >0-1-0 | => 0+1+0 = 1           | => 1+0 = 1        | => 0 | \n               |                        |                   | \n        >0-1-2 | => 0+1+2 = 3 mod 3 = 0 | => 1+2 mod 3 = 0  | => 2 \n --------------+------------------------+-------------------+--------- \n          >0-1 |                        | => 0+1 = 1        | => 1 | \n               |                        |                   | \n      >0-1-2-0 |                        | => 2+0 = 2        | => 0 \n --------------+------------------------+-------------------+--------- \n            >0 |                        |                   | => 0 | \n               |                        |                   | \n    >0-1-2-0-1 |                        |                   | => 1 \n```\n\n\n\nBessie 注意到所有的和对都包含不同的数字，并且听说对于所有的魔法手镯都是如此。Bessie 想知道具有这种唯一和性质的最长可能手镯是多少。\n\n给定 M，找到一组非常长（但不超过 20,000）的数字，可以刻在黑珍珠上以保持手镯的这种唯一和性质。\n\n这是一个仅输出题目，15 个输入文件可以从以下地址下载：http://ace.delos.com/perlbrac.zip\n\n评分：此问题的评分将是相对的；每个测试用例的整数得分（满分 10 分）将是 int(10 \\* sqrt(YOURS / BEST))，其中 YOURS 是你的解的长度，BEST 是所有参赛者中最佳解的长度。\n\n反馈：当你提交一个文件进行评分时，它将被检查格式和有效性（即是否满足所需的数值属性），并且你将被告知结果。", "inputFormat": "\\* 第 1 行：两个用空格分隔的整数：案例编号和 M\n", "outputFormat": "\\* 第 1 行：包含任务名称和案例编号的单行：#FILE perlbrac CASENUM\n\n\\* 第 2 行：单行包含一个整数 N（必须不大于 20,000）\n\n\\* 第 3 到 N+1 行：第 i+2 行包含一个整数，即刻在手镯上第 i 颗珍珠上的整数；这个数字应在 0 到 M - 1 之间（含）\n", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2932", "type": "P", "difficulty": 3, "samples": [["4 3 1 \n1 2 \n2 3 \n3 4 \n3 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09JAN] Earthquake Damage G", "background": "", "description": "Wisconsin has had an earthquake that has struck Farmer John's farm! The earthquake has damaged some of the pastures so that they are unpassable. Remarkably, none of the cowpaths was damaged.\n\nAs usual, the farm is modeled as a set of $P(1 \\le P \\le 30,000)$ pastures conveniently numbered $1\\ldots P$ which are connected by a set of $C (1 \\le C \\le 100,000)$ non-directional cowpaths conveniently numbered $1\\ldots C$. Cowpath $i$ connects pastures $a_i$ and $b_i (1 \\le a_i \\le P; 1 \\le b_i \\le P)$. Cowpaths might connect $a_i$ to itself or perhaps might connect two pastures more than once.  The barn is located in pasture $1$.\n\nA total of $N (1 \\le N \\le P)$ cows (in different pastures) sequentially contact Farmer John via moobile phone with an integer message $report_j (2 \\le report_j \\le P)$ that indicates that pasture $report_j$ is undamaged but that the calling cow is unable to return to the barn from pasture $report_j$ because she could not find a path that does not go through damaged pastures.\n\nAfter all the cows report in, determine the minimum number of pastures (including ones that are uncrossable) from which it is not possible to return to the barn.\n\nNote: Feedback on some of the test data will be provided on the first $50$ submissions.", "inputFormat": "Line $1$: Three space-separated integers: $P$,$C$,and $N$.\n\nLines $2\\ldots C+1$: Line $i+1$ describes cowpath $i$ with two integers: $a_i$ and $b_i$.\n\nLines $C+2\\ldots C+N+1$: Line $C+1+j$ contains a single integer: $report_j$.\n", "outputFormat": "Line $1$: A single integer that is the minimum count of pastures from which a cow can not return to the barn (including the damaged pastures themselves)\n", "hint": "Pasture $2$ is damaged, resulting in cows in pastures $2, 3, 4$ not being able to return to the barn.", "locale": "en", "translations": {"en": {"title": "[USACO09JAN] Earthquake Damage G", "background": "", "description": "Wisconsin has had an earthquake that has struck Farmer John's farm! The earthquake has damaged some of the pastures so that they are unpassable. Remarkably, none of the cowpaths was damaged.\n\nAs usual, the farm is modeled as a set of $P(1 \\le P \\le 30,000)$ pastures conveniently numbered $1\\ldots P$ which are connected by a set of $C (1 \\le C \\le 100,000)$ non-directional cowpaths conveniently numbered $1\\ldots C$. Cowpath $i$ connects pastures $a_i$ and $b_i (1 \\le a_i \\le P; 1 \\le b_i \\le P)$. Cowpaths might connect $a_i$ to itself or perhaps might connect two pastures more than once.  The barn is located in pasture $1$.\n\nA total of $N (1 \\le N \\le P)$ cows (in different pastures) sequentially contact Farmer John via moobile phone with an integer message $report_j (2 \\le report_j \\le P)$ that indicates that pasture $report_j$ is undamaged but that the calling cow is unable to return to the barn from pasture $report_j$ because she could not find a path that does not go through damaged pastures.\n\nAfter all the cows report in, determine the minimum number of pastures (including ones that are uncrossable) from which it is not possible to return to the barn.\n\nNote: Feedback on some of the test data will be provided on the first $50$ submissions.", "inputFormat": "Line $1$: Three space-separated integers: $P$,$C$,and $N$.\n\nLines $2\\ldots C+1$: Line $i+1$ describes cowpath $i$ with two integers: $a_i$ and $b_i$.\n\nLines $C+2\\ldots C+N+1$: Line $C+1+j$ contains a single integer: $report_j$.\n", "outputFormat": "Line $1$: A single integer that is the minimum count of pastures from which a cow can not return to the barn (including the damaged pastures themselves)\n", "hint": "Pasture $2$ is damaged, resulting in cows in pastures $2, 3, 4$ not being able to return to the barn.", "locale": "en"}, "zh-CN": {"title": "[USACO09JAN] Earthquake Damage G", "background": "", "description": "威斯康星州发生了一场地震，影响了 Farmer John 的农场！地震损坏了一些牧场，使它们无法通行。值得注意的是，没有一条牛道受到损坏。\n\n像往常一样，农场被建模为一组编号为 $1\\ldots P$ 的 $P(1 \\le P \\le 30,000)$ 个牧场，这些牧场通过一组编号为 $1\\ldots C$ 的 $C (1 \\le C \\le 100,000)$ 条无向牛道连接。牛道 $i$ 连接牧场 $a_i$ 和 $b_i (1 \\le a_i \\le P; 1 \\le b_i \\le P)$。牛道可能连接 $a_i$ 自己，或者可能多次连接两个牧场。谷仓位于牧场 $1$。\n\n总共有 $N (1 \\le N \\le P)$ 头牛（在不同的牧场）通过手机依次联系 Farmer John，发送一个整数消息 $report_j (2 \\le report_j \\le P)$，表示牧场 $report_j$ 未受损，但打电话的牛无法从牧场 $report_j$ 返回谷仓，因为它找不到不经过受损牧场的路径。\n\n在所有牛报告后，确定无法返回谷仓的最小牧场数量（包括那些不可通行的牧场）。\n\n注意：在前 $50$ 次提交中，将提供部分测试数据的反馈。", "inputFormat": "第 $1$ 行：三个用空格分隔的整数：$P$，$C$ 和 $N$。\n\n第 $2\\ldots C+1$ 行：第 $i+1$ 行描述牛道 $i$，包含两个整数：$a_i$ 和 $b_i$。\n\n第 $C+2\\ldots C+N+1$ 行：第 $C+1+j$ 行包含一个整数：$report_j$。\n", "outputFormat": "第 $1$ 行：一个整数，表示无法从牧场返回谷仓的最小牧场数量（包括受损的牧场本身）。\n", "hint": "牧场 $2$ 受损，导致牧场 $2, 3, 4$ 的牛无法返回谷仓。（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2933", "type": "P", "difficulty": 5, "samples": [["4 20 \n10 \n3 \n20 \n40 \n", "2 17 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09JAN] The Baric Bovine G", "background": "", "description": "Following up on a journal article about increasing milk production, Bessie has become the Baric Bovine by studying atmospheric pressure in order to curry favor with Farmer John.\n\nShe takes N (1 <= N <= 100) measurements conveniently named M\\_1 through M\\_N during the day (1 <= M\\_i <= 1,000,000); these measurements are numbered in the order in which Bessie observed them.\n\nIn order to characterize the day's atmospheric pressure readings, she is interested in finding a subset of the measurements (given by the K (1 <= K <= N) indices s\\_j where 1 <= s\\_1 < s\\_2 < ... < s\\_K <= N) that accurately reflects the entire set, i.e., limits the error as described below.\n\nIn any subset of measurements, an error is incurred for each\n\nmeasurement (1) before the first member of the subset, (2) between two consecutive measurements in the subset, and (3) after the last member of the subset. The total error value for a given set of s\\_j values is the sum of each of the individual errors.\n\nSpecifically, for all measurements whose index i is not one of the s\\_j values:\n\n```cpp\n* if i is less than s_1, then the sample error is: \n2 * | M_i - M_(s_1) | \n* if i is between s_j and s_(j+1), then the sample error is \n| 2 * M_i - Sum(s_j, s_(j+1)) | \nwhere Sum(x, y) = M_x + M_y; \n* if i is greater than s_K, then the sample error is \n2 * | M_i - M_(s_K) | \nGiven a maximum error value E (1 <= E <= 1,000,000), determine the size of the smallest subset of measurements that produces an error of at most E. \n```\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and E\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: M\\_i\n", "outputFormat": "\\* Line 1: Two space-separated integers: the size of the smallest subset of measurements that produces an error of at most E and the least possible error for the subset of that size.\n", "hint": "Bessie takes four measurements; the maximum error is 20. The\n\nmeasurements are, in sequence: 10, 3, 20, and 40.\n\n\nChoosing the second and fourth measurements is the best option, giving an error of 17. The first term's error is 2\\*|10-3| = 14; the third term's error is |2\\*20 - (3+40)| = 3. ", "locale": "en", "translations": {"en": {"title": "[USACO09JAN] The Baric Bovine G", "background": "", "description": "Following up on a journal article about increasing milk production, Bessie has become the Baric Bovine by studying atmospheric pressure in order to curry favor with Farmer John.\n\nShe takes N (1 <= N <= 100) measurements conveniently named M\\_1 through M\\_N during the day (1 <= M\\_i <= 1,000,000); these measurements are numbered in the order in which Bessie observed them.\n\nIn order to characterize the day's atmospheric pressure readings, she is interested in finding a subset of the measurements (given by the K (1 <= K <= N) indices s\\_j where 1 <= s\\_1 < s\\_2 < ... < s\\_K <= N) that accurately reflects the entire set, i.e., limits the error as described below.\n\nIn any subset of measurements, an error is incurred for each\n\nmeasurement (1) before the first member of the subset, (2) between two consecutive measurements in the subset, and (3) after the last member of the subset. The total error value for a given set of s\\_j values is the sum of each of the individual errors.\n\nSpecifically, for all measurements whose index i is not one of the s\\_j values:\n\n```cpp\n* if i is less than s_1, then the sample error is: \n2 * | M_i - M_(s_1) | \n* if i is between s_j and s_(j+1), then the sample error is \n| 2 * M_i - Sum(s_j, s_(j+1)) | \nwhere Sum(x, y) = M_x + M_y; \n* if i is greater than s_K, then the sample error is \n2 * | M_i - M_(s_K) | \nGiven a maximum error value E (1 <= E <= 1,000,000), determine the size of the smallest subset of measurements that produces an error of at most E. \n```\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and E\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: M\\_i\n", "outputFormat": "\\* Line 1: Two space-separated integers: the size of the smallest subset of measurements that produces an error of at most E and the least possible error for the subset of that size.\n", "hint": "Bessie takes four measurements; the maximum error is 20. The\n\nmeasurements are, in sequence: 10, 3, 20, and 40.\n\n\nChoosing the second and fourth measurements is the best option, giving an error of 17. The first term's error is 2\\*|10-3| = 14; the third term's error is |2\\*20 - (3+40)| = 3. ", "locale": "en"}, "zh-CN": {"title": "[USACO09JAN] The Baric Bovine G", "background": "", "description": "为了研究农场的气候，Bessie 帮助农夫 John 做了  $N$ 次气压测量并按顺序记录了结果  $M_1 \\cdots M_n$。Bessie 想找出一部分测量结果来总结一整天的气压分布。她想用  $K(1 \\leq K \\leq N)$ 个数  $s_j (1 \\leq s_1 < s_2 < \\cdots < s_K \\leq N)$ 来概括所有测量结果。她想限制如下的误差: 对于任何测量结果子集，每一个非此子集中的结果都会产生误差。总误差是所有测量结果的误差之和。更明确地说，对于每一个和所有  $s_j$ 都不同的  $i$：\n\n- 如果  $i$ 小于  $s_1$, 误差是： $2 \\times | M_i - M_{(s_1)} |$；\n- 如果  $i$ 在  $s_j$ 和  $s_{(j+1)}$ 之间，误差是： $| 2 \\times M_i - \\operatorname{Sum}(s_j, s_{(j+1)}) |$。注： $\\operatorname{Sum}(x, y) = M_x + M_y$  ( $M_x$ 和  $M_y$ 之和)；\n- 如果  $i$ 大于  $s_K$ ,误差为： $2 \\times | M_i - M_{(s_K)} |$ 给出最大允许的误差  $E$，找出最小的一部分结果使得误差最多为  $E$。", "inputFormat": "- 第  $1$ 行：两个用空格分开的正整数  $N$ 和  $E$。\n\n- 第  $2\\cdots N+1$ 行：第  $i+1$ 行包含单独的一个正整数  $M_i$。", "outputFormat": "- 第  $1$ 行：两个用空格分开的整数，分别代表着最小的使得误差小于等于  $E$ 的测量结果子集元素的数量和其能达到的最小误差值。", "hint": "对于所有数据， $1 \\leq N \\leq 100$， $1 \\leq M_i \\leq 1,000,000$， $1 \\leq E \\leq 1,000,000$。\n\n### 样例说明\n\nBessie 做了 4 次测量，最大允许的误差是 20。测量的结果分别为 10，3，20 和 40。\n\n选择第二次和第四次测量结果是最佳的，误差为 17。第一个结果的误差为  $2\\times|10-3|=14$，第三个的为  $|2\\times20-(3+40)|=3$。", "locale": "zh-CN"}}}
{"pid": "P2934", "type": "P", "difficulty": 5, "samples": [["4 5 \n1 2 2 \n1 3 2 \n3 4 4 \n3 2 1 \n2 4 3 \n", "3 \n3 \n6 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO", "并查集", "最短路", "最近公共祖先 LCA", "树链剖分"], "title": "[USACO09JAN] Safe Travel G", "background": "", "description": "Gremlins have infested the farm. These nasty, ugly fairy-like creatures thwart the cows as each one walks from the barn (conveniently located at pasture\\_1) to the other fields, with cow\\_i traveling to from pasture\\_1 to pasture\\_i. Each gremlin is personalized and knows the quickest path that cow\\_i normally takes to pasture\\_i. Gremlin\\_i waits for cow\\_i in the middle of the final cowpath of the quickest route to pasture\\_i, hoping to harass cow\\_i.\n\nEach of the cows, of course, wishes not to be harassed and thus chooses an at least slightly  different route from pasture\\_1 (the barn) to pasture\\_i.\n\nCompute the best time to traverse each of these new not-quite-quickest routes that enable each cow\\_i that avoid gremlin\\_i who is located on the final cowpath of the quickest route from pasture\\_1 to pasture\\_i.\n\nAs usual, the M (2 <= M <= 200,000) cowpaths conveniently numbered 1..M are bidirectional and enable travel to all N (3 <= N <= 100,000) pastures conveniently numbered 1..N. Cowpath i connects pastures a\\_i (1 <= a\\_i <= N) and b\\_i (1 <= b\\_i <= N) and requires t\\_i (1 <= t\\_i <= 1,000) time to traverse. No two cowpaths connect the same two pastures, and no path connects a pasture to itself (a\\_i != b\\_i). Best of all, the shortest path regularly taken by cow\\_i from pasture\\_1 to pasture\\_i is unique in all the test data supplied to your program.\n\nBy way of example, consider these pastures, cowpaths, and [times]:\n\n```cpp\n1--[2]--2-------+ \n|       |       | \n[2]     [1]     [3] \n|       |       | \n+-------3--[4]--4\n```\n``` \nTRAVEL     BEST ROUTE   BEST TIME   LAST PATH \np_1 to p_2       1->2          2         1->2 \np_1 to p_3       1->3          2         1->3 \np_1 to p_4      1->2->4        5         2->4 \n```\nWhen gremlins are present:\n\n```cpp\nTRAVEL     BEST ROUTE   BEST TIME    AVOID \np_1 to p_2     1->3->2         3         1->2 \np_1 to p_3     1->2->3         3         1->3 \np_1 to p_4     1->3->4         6         2->4 \n```\nFor 20% of the test data, N <= 200. \n\nFor 50% of the test data, N <= 3000. \n\nTIME LIMIT: 3 Seconds\n\nMEMORY LIMIT: 64 MB", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Three space-separated integers: a\\_i, b\\_i, and t\\_i\n", "outputFormat": "\\* Lines 1..N-1: Line i contains the smallest time required to travel from pasture\\_1 to pasture\\_i+1 while avoiding the final cowpath of the shortest path from pasture\\_1 to pasture\\_i+1. If no such path exists from pasture\\_1 to pasture\\_i+1, output -1 alone on the line.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO09JAN] Safe Travel G", "background": "", "description": "Gremlins have infested the farm. These nasty, ugly fairy-like creatures thwart the cows as each one walks from the barn (conveniently located at pasture\\_1) to the other fields, with cow\\_i traveling to from pasture\\_1 to pasture\\_i. Each gremlin is personalized and knows the quickest path that cow\\_i normally takes to pasture\\_i. Gremlin\\_i waits for cow\\_i in the middle of the final cowpath of the quickest route to pasture\\_i, hoping to harass cow\\_i.\n\nEach of the cows, of course, wishes not to be harassed and thus chooses an at least slightly  different route from pasture\\_1 (the barn) to pasture\\_i.\n\nCompute the best time to traverse each of these new not-quite-quickest routes that enable each cow\\_i that avoid gremlin\\_i who is located on the final cowpath of the quickest route from pasture\\_1 to pasture\\_i.\n\nAs usual, the M (2 <= M <= 200,000) cowpaths conveniently numbered 1..M are bidirectional and enable travel to all N (3 <= N <= 100,000) pastures conveniently numbered 1..N. Cowpath i connects pastures a\\_i (1 <= a\\_i <= N) and b\\_i (1 <= b\\_i <= N) and requires t\\_i (1 <= t\\_i <= 1,000) time to traverse. No two cowpaths connect the same two pastures, and no path connects a pasture to itself (a\\_i != b\\_i). Best of all, the shortest path regularly taken by cow\\_i from pasture\\_1 to pasture\\_i is unique in all the test data supplied to your program.\n\nBy way of example, consider these pastures, cowpaths, and [times]:\n\n```cpp\n1--[2]--2-------+ \n|       |       | \n[2]     [1]     [3] \n|       |       | \n+-------3--[4]--4\n```\n``` \nTRAVEL     BEST ROUTE   BEST TIME   LAST PATH \np_1 to p_2       1->2          2         1->2 \np_1 to p_3       1->3          2         1->3 \np_1 to p_4      1->2->4        5         2->4 \n```\nWhen gremlins are present:\n\n```cpp\nTRAVEL     BEST ROUTE   BEST TIME    AVOID \np_1 to p_2     1->3->2         3         1->2 \np_1 to p_3     1->2->3         3         1->3 \np_1 to p_4     1->3->4         6         2->4 \n```\nFor 20% of the test data, N <= 200. \n\nFor 50% of the test data, N <= 3000. \n\nTIME LIMIT: 3 Seconds\n\nMEMORY LIMIT: 64 MB", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Three space-separated integers: a\\_i, b\\_i, and t\\_i\n", "outputFormat": "\\* Lines 1..N-1: Line i contains the smallest time required to travel from pasture\\_1 to pasture\\_i+1 while avoiding the final cowpath of the shortest path from pasture\\_1 to pasture\\_i+1. If no such path exists from pasture\\_1 to pasture\\_i+1, output -1 alone on the line.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO09JAN] Safe Travel G", "background": "", "description": "小妖精侵占了农场。这些讨厌的类精灵生物会阻挠每头牛从谷仓（位于 $\\mathrm{pasture}_1$（牧场 $1$））前往其他牧场的行程，其中第 $i$ 头牛要从 $\\mathrm{pasture}_1$ 前往 $\\mathrm{pasture}_i$。每个小妖精都经过个性化训练，知道第 $i$ 头牛前往 $\\mathrm{pasture}_i$ 的最短路径。第 $i$ 个小妖精会埋伏在第 $i$ 头牛最短路径的最后一条道路上，企图骚扰这头牛。\n\n每头牛当然都不希望被骚扰，因此会选择一条与原始最短路径至少存在细微差别的从 $\\mathrm{pasture}_1$ 到 $\\mathrm{pasture}_i$ 的新路径。\n\n请计算每头牛避开位于其原始最短路径最后一条道路上的小妖精后，新路线的最短通行时间。\n\n给定 $M (2 \\leq M \\leq 200\\,000)$ 条双向道路（编号 $1\\dots M$）连接 $N (3 \\leq N \\leq 100\\,000)$ 个牧场（编号 $1\\dots N$）。第 $i$ 条道路连接牧场 $a_i (1 \\leq a_i \\leq N)$ 和 $b_i (1 \\leq b_i \\leq N)$，通行时间为 $t_i (1 \\leq t_i \\leq 1\\,000)$。保证没有两条道路连接同一对牧场，且所有测试数据中从 $\\mathrm{pasture}_1$ 到任意 $\\mathrm{pasture}_i$ 的最短路径唯一。\n\n例如以下牧场、道路和通行时间：\n\n```\n1--[2]--2-------+ \n|       |       | \n[2]     [1]     [3] \n|       |       | \n+-------3--[4]--4\n```\n\n```\nTRAVEL     最佳路线      最短时间    最后一条道路 \np_1 到 p_2   1->2          2         1->2 \np_1 到 p_3   1->3          2         1->3 \np_1 到 p_4  1->2->4        5         2->4 \n```\n\n当存在小妖精时：\n\n```\nTRAVEL     最佳路线      最短时间    规避道路 \np_1 到 p_2   1->3->2        3         1->2 \np_1 到 p_3   1->2->3        3         1->3 \np_1 到 p_4   1->3->4        6         2->4 \n```\n\n- 对于 $20\\%$ 的测试数据，$N\\leq 200$。\n- 对于 $50\\%$ 的测试数据，$N\\leq 3000$。", "inputFormat": "- 第 $1$ 行：两个空格分隔的整数 $N$ 和 $M$\n- 第 $2\\dots (M+1)$ 行：每行三个空格分隔的整数 $a_i$、$b_i$ 和 $t_i$", "outputFormat": "- 第 1..N-1 行：第 $i$ 行输出从 $\\mathrm{pasture}_1$ 到 $\\mathrm{pasture}_{i+1}$ 时，避开其原始最短路径最后一条道路后的新最短路径时间。若不存在这样的路径，输出 -1。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2935", "type": "P", "difficulty": 3, "samples": [["13 6 15 \n11 \n13 \n10 \n12 \n8 \n1 \n2 4 3 \n7 11 3 \n10 11 1 \n4 13 3 \n9 10 3 \n2 3 2 \n3 5 4 \n5 9 2 \n6 7 6 \n5 6 1 \n1 2 4 \n4 5 3 \n11 12 3 \n6 10 1 \n7 8 7 \n", "10 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO", "枚举", "最短路"], "title": "[USACO09JAN] Best Spot S", "background": null, "description": "约翰拥有 $P(1 \\leq P \\leq 500)$ 个牧场，\n\n贝茜特别喜欢其中的 $F(1\\leq F \\leq P)$ 个。\n\n所有的牧场由 $C(1 < C \\leq 8000)$ 条双向路连接，第 $i$ 条路连接着 $a_i$,$b_i$ 两个牧场 $(1 \\leq a_i \\leq P,1 \\leq b_i \\leq P)$，需要 $T_i(1 \\leq T_i < 892)$ 个单位时间来通过。\n\n作为一只总想提升自己生活方式的奶牛，贝茜希望自己有朝一日醒来，到达所有那 $F$ 个她喜欢的牧场的平均用时最小。那她前一天应该睡在哪个牧场呢？请帮助贝茜找到这个最佳牧场。\n\n例如，考虑如下图所示的牧场布局，其中含有 * 的牧场的编号是最受欢迎的。而中括号内的数字是这条牛道的通过时间。\n\n```cpp\n\n            1*--[4]--2--[2]--3\n                     |       |\n                    [3]     [4]\n                     |       |\n                     4--[3]--5--[1]---6---[6]---7--[7]--8*\n                     |       |        |         |\n                    [3]     [2]      [1]       [3]\n                     |       |        |         |\n                    13*      9--[3]--10*--[1]--11*--[3]--12*\n```\n下表显示了牧场 $4,5,6,7,9,10,11$ 和 $12$ 与贝茜最喜欢的牧场的各个距离、平均距离和最终求出的最佳牧场：\n```cpp\n                    * * * * * * 最喜欢的牧场 * * * * * *\n  可能的         牧场    牧场    牧场    牧场    牧场    牧场         平均\n 最佳牧场          1       8      10      11      12      13          距离\n------------      --      --      --      --      --      --      -----------\n    4              7      16       5       6       9       3      46/6 = 7.67\n    5             10      13       2       3       6       6      40/6 = 6.67\n    6             11      12       1       2       5       7      38/6 = 6.33\n    7             16       7       4       3       6      12      48/6 = 8.00\n    9             12      14       3       4       7       8      48/6 = 8.00\n   10             12      11       0       1       4       8      36/6 = 6.00 ** 最佳的\n   11             13      10       1       0       3       9      36/6 = 6.00\n   12             16      13       4       3       0      12      48/6 = 8.00\n\n```\n由表格可见，在样例环境下，牧场 $10$ 到所有贝茜喜欢的牧场的平均距离最小，为最佳牧场。", "inputFormat": "第一行包含三个整数 $P$,$F$,$C$。\n\n接下来 $F$ 行，每行一个整数，表示贝茜喜欢的牧场的编号。\n\n接下来 $C$ 行，每行三个整数 $a_i$,$b_i$,$T_i$，表示存在一条连接 $a_i$ 和 $b_i$ 的双向通路，通过时间为 $T_i$。", "outputFormat": "一个整数，表示最佳的牧场编号。如果有多个最佳牧场，则输出编号最小的那一个。", "hint": "翻译来自 AASDFGHJKL(1035916)。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09JAN] Best Spot S", "background": "", "description": "John owns $P(1 \\leq P \\leq 500)$ pastures.\n\nBessie especially likes $F(1\\leq F \\leq P)$ of them.\n\nAll pastures are connected by $C(1 < C \\leq 8000)$ bidirectional roads. The $i$-th road connects pastures $a_i$,$b_i$ $(1 \\leq a_i \\leq P,1 \\leq b_i \\leq P)$ and takes $T_i(1 \\leq T_i < 892)$ units of time to traverse.\n\nAs a cow who always wants to improve her lifestyle, Bessie hopes that one day she will wake up at a pasture where the average time to reach all $F$ pastures she likes is minimized. At which pasture should she sleep the day before? Please help Bessie find this best pasture.\n\nFor example, consider the pasture layout shown below, where starred pastures are the most favored ones, and the numbers in brackets are the traversal times of the cow paths.\n\n```cpp\n\n            1*--[4]--2--[2]--3\n                     |       |\n                    [3]     [4]\n                     |       |\n                     4--[3]--5--[1]---6---[6]---7--[7]--8*\n                     |       |        |         |\n                    [3]     [2]      [1]       [3]\n                     |       |        |         |\n                    13*      9--[3]--10*--[1]--11*--[3]--12*\n```\n下表显示了牧场 $4,5,6,7,9,10,11$ 和 $12$ 与贝茜最喜欢的牧场的各个距离、平均距离和最终求出的最佳牧场：\n```cpp\n                    * * * * * * 最喜欢的牧场 * * * * * *\n  可能的         牧场    牧场    牧场    牧场    牧场    牧场         平均\n 最佳牧场          1       8      10      11      12      13          距离\n------------      --      --      --      --      --      --      -----------\n    4              7      16       5       6       9       3      46/6 = 7.67\n    5             10      13       2       3       6       6      40/6 = 6.67\n    6             11      12       1       2       5       7      38/6 = 6.33\n    7             16       7       4       3       6      12      48/6 = 8.00\n    9             12      14       3       4       7       8      48/6 = 8.00\n   10             12      11       0       1       4       8      36/6 = 6.00 ** 最佳的\n   11             13      10       1       0       3       9      36/6 = 6.00\n   12             16      13       4       3       0      12      48/6 = 8.00\n\n```\nFrom the table, in the sample setting, pasture $10$ has the smallest average distance to all pastures Bessie likes, making it the best pasture.", "inputFormat": "The first line contains three integers $P$,$F$,$C$.\n\nThe next $F$ lines each contain a single integer, the index of a pasture that Bessie likes.\n\nThe next $C$ lines each contain three integers $a_i$,$b_i$,$T_i$, indicating there is a bidirectional path between $a_i$ and $b_i$ with traversal time $T_i$.", "outputFormat": "Output a single integer, the index of the best pasture. If there are multiple best pastures, output the smallest index.", "hint": "Translated by AASDFGHJKL (1035916).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09JAN] Best Spot S", "background": null, "description": "约翰拥有 $P(1 \\leq P \\leq 500)$ 个牧场，\n\n贝茜特别喜欢其中的 $F(1\\leq F \\leq P)$ 个。\n\n所有的牧场由 $C(1 < C \\leq 8000)$ 条双向路连接，第 $i$ 条路连接着 $a_i$,$b_i$ 两个牧场 $(1 \\leq a_i \\leq P,1 \\leq b_i \\leq P)$，需要 $T_i(1 \\leq T_i < 892)$ 个单位时间来通过。\n\n作为一只总想提升自己生活方式的奶牛，贝茜希望自己有朝一日醒来，到达所有那 $F$ 个她喜欢的牧场的平均用时最小。那她前一天应该睡在哪个牧场呢？请帮助贝茜找到这个最佳牧场。\n\n例如，考虑如下图所示的牧场布局，其中含有 * 的牧场的编号是最受欢迎的。而中括号内的数字是这条牛道的通过时间。\n\n```cpp\n\n            1*--[4]--2--[2]--3\n                     |       |\n                    [3]     [4]\n                     |       |\n                     4--[3]--5--[1]---6---[6]---7--[7]--8*\n                     |       |        |         |\n                    [3]     [2]      [1]       [3]\n                     |       |        |         |\n                    13*      9--[3]--10*--[1]--11*--[3]--12*\n```\n下表显示了牧场 $4,5,6,7,9,10,11$ 和 $12$ 与贝茜最喜欢的牧场的各个距离、平均距离和最终求出的最佳牧场：\n```cpp\n                    * * * * * * 最喜欢的牧场 * * * * * *\n  可能的         牧场    牧场    牧场    牧场    牧场    牧场         平均\n 最佳牧场          1       8      10      11      12      13          距离\n------------      --      --      --      --      --      --      -----------\n    4              7      16       5       6       9       3      46/6 = 7.67\n    5             10      13       2       3       6       6      40/6 = 6.67\n    6             11      12       1       2       5       7      38/6 = 6.33\n    7             16       7       4       3       6      12      48/6 = 8.00\n    9             12      14       3       4       7       8      48/6 = 8.00\n   10             12      11       0       1       4       8      36/6 = 6.00 ** 最佳的\n   11             13      10       1       0       3       9      36/6 = 6.00\n   12             16      13       4       3       0      12      48/6 = 8.00\n\n```\n由表格可见，在样例环境下，牧场 $10$ 到所有贝茜喜欢的牧场的平均距离最小，为最佳牧场。", "inputFormat": "第一行包含三个整数 $P$,$F$,$C$。\n\n接下来 $F$ 行，每行一个整数，表示贝茜喜欢的牧场的编号。\n\n接下来 $C$ 行，每行三个整数 $a_i$,$b_i$,$T_i$，表示存在一条连接 $a_i$ 和 $b_i$ 的双向通路，通过时间为 $T_i$。", "outputFormat": "一个整数，表示最佳的牧场编号。如果有多个最佳牧场，则输出编号最小的那一个。", "hint": "翻译来自 AASDFGHJKL(1035916)。", "locale": "zh-CN"}}}
{"pid": "P2936", "type": "P", "difficulty": 5, "samples": [["5 \nA B 3 \nB C 3 \nC D 5 \nD Z 4 \nB Z 6 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO", "网络流"], "title": "[USACO09JAN] Total Flow S", "background": "", "description": "Farmer John always wants his cows to have enough water and thus has made a map of the N (1 <= N <= 700) water pipes on the farm that connect the well to the barn. He was surprised to find a wild mess of different size pipes connected in an apparently haphazard way. He wants to calculate the flow through the pipes.\n\nTwo pipes connected in a row allow water flow that is the minimum of the values of the two pipe's flow values. The example of a pipe with flow capacity 5 connecting to a pipe of flow capacity 3 can be reduced logically to a single pipe of flow capacity 3:\n\n```plain\n+---5---+---3---+    ->    +---3---+\n```\n\nSimilarly, pipes in parallel let through water that is the sum of their flow capacities:\n\n```plain\n   +---5---+\n---+       +---    ->    +---8---+\n   +---3---+\n```\n\nFinally, a pipe that connects to nothing else can be removed; it contributes no flow to the final overall capacity:\n\n```plain\n   +---5---+\n---+               ->    +---3---+\n   +---3---+--\n```\n\nAll the pipes in the many mazes of plumbing can be reduced using these ideas into a single total flow capacity.\n\nGiven a map of the pipes, determine the flow capacity between the well (A) and the barn (Z).\n\nConsider this example where node names are labeled with letters:\n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +---3---+---5---+---4---+\n                 C       D\n```\n\nPipe BC and CD can be combined:\n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +-----3-----+-----4-----+\n                     D\n```\n\nThen BD and DZ can be combined: \n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +-----------3-----------+\n```\n\nThen two legs of BZ can be combined: \n\n```plain\n         B\nA+---3---+---9---+Z\n```\n\nThen AB and BZ can be combined to yield a net capacity of 3:\n\n```plain\nA+---3---+Z\n```\n\nWrite a program to read in a set of pipes described as two endpoints and then calculate the net flow capacity from 'A' to 'Z'. All\n\nnetworks in the test data can be reduced using the rules here.\n\nPipe i connects two different nodes a\\_i and b\\_i (a\\_i in range\n\n'A-Za-z'; b\\_i in range 'A-Za-z') and has flow F\\_i (1 <= F\\_i <= 1,000). Note that lower- and upper-case node names are intended to be treated as different.\n\nThe system will provide extra test case feedback for your first 50 submissions.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N + 1: Line i+1 describes pipe i with two letters and an integer, all space-separated: a\\_i, b\\_i, and F\\_i\n", "outputFormat": "\\* Line 1: A single integer that the maximum flow from the well ('A') to the barn ('Z')\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO09JAN] Total Flow S", "background": "", "description": "Farmer John always wants his cows to have enough water and thus has made a map of the N (1 <= N <= 700) water pipes on the farm that connect the well to the barn. He was surprised to find a wild mess of different size pipes connected in an apparently haphazard way. He wants to calculate the flow through the pipes.\n\nTwo pipes connected in a row allow water flow that is the minimum of the values of the two pipe's flow values. The example of a pipe with flow capacity 5 connecting to a pipe of flow capacity 3 can be reduced logically to a single pipe of flow capacity 3:\n\n```plain\n+---5---+---3---+    ->    +---3---+\n```\n\nSimilarly, pipes in parallel let through water that is the sum of their flow capacities:\n\n```plain\n   +---5---+\n---+       +---    ->    +---8---+\n   +---3---+\n```\n\nFinally, a pipe that connects to nothing else can be removed; it contributes no flow to the final overall capacity:\n\n```plain\n   +---5---+\n---+               ->    +---3---+\n   +---3---+--\n```\n\nAll the pipes in the many mazes of plumbing can be reduced using these ideas into a single total flow capacity.\n\nGiven a map of the pipes, determine the flow capacity between the well (A) and the barn (Z).\n\nConsider this example where node names are labeled with letters:\n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +---3---+---5---+---4---+\n                 C       D\n```\n\nPipe BC and CD can be combined:\n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +-----3-----+-----4-----+\n                     D\n```\n\nThen BD and DZ can be combined: \n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +-----------3-----------+\n```\n\nThen two legs of BZ can be combined: \n\n```plain\n         B\nA+---3---+---9---+Z\n```\n\nThen AB and BZ can be combined to yield a net capacity of 3:\n\n```plain\nA+---3---+Z\n```\n\nWrite a program to read in a set of pipes described as two endpoints and then calculate the net flow capacity from 'A' to 'Z'. All\n\nnetworks in the test data can be reduced using the rules here.\n\nPipe i connects two different nodes a\\_i and b\\_i (a\\_i in range\n\n'A-Za-z'; b\\_i in range 'A-Za-z') and has flow F\\_i (1 <= F\\_i <= 1,000). Note that lower- and upper-case node names are intended to be treated as different.\n\nThe system will provide extra test case feedback for your first 50 submissions.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N + 1: Line i+1 describes pipe i with two letters and an integer, all space-separated: a\\_i, b\\_i, and F\\_i\n", "outputFormat": "\\* Line 1: A single integer that the maximum flow from the well ('A') to the barn ('Z')\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO09JAN] Total Flow S", "background": null, "description": "**请注意，题面中并没有说明水管是单向的还是双向的（虽然应该是双向的）。数据保证无论将水管视作单向还是双向得到的结果相同。**\n\n农夫约翰总是希望他的奶牛有足够的水，因此他绘制了一张农场上连接水井和谷仓的 $N（1 \\leq N \\leq 700$）根水管的地图。他惊讶地发现这些不同尺寸的水管连接得杂乱无章。他想计算水管的流量。\n\n两个串联的水管允许的水流量是两个水管流量值中的最小值。例如，一个流量为 $5$ 的水管连接到一个流量为 $3$ 的水管，可以逻辑上简化为一个流量为 $3$ 的水管：\n\n```plain\n+---5---+---3---+    ->    +---3---+\n```\n\n类似地，并联的水管允许的水流量是它们流量的总和：\n\n```plain\n   +---5---+\n---+       +---    ->    +---8---+\n   +---3---+\n```\n\n最后，一个没有连接到其他任何东西的水管可以被移除，它对最终的总流量没有贡献：\n\n```plain\n   +---5---+\n---+               ->    +---3---+\n   +---3---+--\n```\n\n管道网络中的所有水管都可以使用这些方法简化为一个总流量。\n\n给定一张水管的地图，确定从水井 $A$ 到谷仓 $Z$ 的流量。\n\n考虑这个节点名称用字母标记的例子：\n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +---3---+---5---+---4---+\n                 C       D\n```\n\n管道 $BC$ 和 $CD$ 可以合并：\n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +-----3-----+-----4-----+\n                     D\n```\n\n然后 $BD$ 和 $DZ$ 可以合并：\n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +-----------3-----------+\n```\n\n然后 $BZ$ 的两条路径可以合并：\n\n```plain\n         B\nA+---3---+---9---+Z\n```\n\n最后，$AB$ 和 $BZ$ 可以合并，得到净流量为 $3$：\n\n```plain\nA+---3---+Z\n```\n\n编写一个程序读取描述为两个端点的水管集合，然后计算从 $A$ 到 $Z$ 的净流量。测试数据中的所有网络都可以使用这里的规则简化。\n\n管道 i 连接两个不同的节点 $a_i$ 和 $b_i$（节点范围均为 $a-z、A-Z$），流量为 $F_i$（$1 \\leq F_i \\leq 1,000$）。注意，小写和大写的节点名称应视为不同。\n\n形式化题意：求出 $A$ 到 $Z$ 的最大流。", "inputFormat": "第 $1$ 行：一个整数：$N$\n\n第 $2$ 行到第 $N+1$ 行：第 $i+1$ 行描述第 $i$ 根水管，包含两个字母和一个整数，均以空格分隔：$a_i$，$b_i$ 和 $F_i$。", "outputFormat": "第 $1$ 行：一个整数，表示从水井 $A$ 到谷仓 $Z$ 的最大流量。", "hint": "@[langmouren](luogu://user/1470994) 提供翻译", "locale": "zh-CN"}}}
{"pid": "P2937", "type": "P", "difficulty": 4, "samples": [["7 8 \n....... \n......C \n......* \n*****.* \n....*.. \n....*.. \n.C..*.. \n....... \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2009", "USACO", "并查集", "广度优先搜索 BFS", "深度优先搜索 DFS", "最短路", "最近公共祖先 LCA"], "title": "[USACO09JAN] Laserphones S", "background": null, "description": "The cows have a new laser-based system so they can have casual conversations while out in the pasture which is modeled as a W x H grid of points (1 <= W <= 100; 1 <= H <= 100).\n\nThe system requires a sort of line-of-sight connectivity in order to sustain communication. The pasture, of course, has rocks and trees that disrupt the communication but the cows have purchased diagonal mirrors ('/' and '\\' below) that deflect the laser beam through a 90 degree turn. Below is a map that illustrates the\n\nproblem.\n\nH is 8 and W is 7 for this map.  The two communicating cows are notated as 'C's; rocks and other blocking elements are notated as '\\*'s:\n\n```plain\n7 . . . . . . .         7 . . . . . . . \n6 . . . . . . C         6 . . . . . /-C \n5 . . . . . . *         5 . . . . . | * \n4 * * * * * . *         4 * * * * * | * \n3 . . . . * . .         3 . . . . * | . \n2 . . . . * . .         2 . . . . * | . \n1 . C . . * . .         1 . C . . * | . \n0 . . . . . . .         0 . \\-------/ . \n  0 1 2 3 4 5 6           0 1 2 3 4 5 6 \n```\nDetermine the minimum number of mirrors M that must be installed to maintain laser communication between the two cows, a feat which is always possible in the given test data.", "inputFormat": "\\* Line 1: Two space separated integers: W and H\n\n\\* Lines 2..H+1: The entire pasture.", "outputFormat": "\\* Line 1: A single integer: M", "hint": null, "locale": "en", "translations": {"en": {"title": "[USACO09JAN] Laserphones S", "background": null, "description": "The cows have a new laser-based system so they can have casual conversations while out in the pasture which is modeled as a W x H grid of points (1 <= W <= 100; 1 <= H <= 100).\n\nThe system requires a sort of line-of-sight connectivity in order to sustain communication. The pasture, of course, has rocks and trees that disrupt the communication but the cows have purchased diagonal mirrors ('/' and '\\' below) that deflect the laser beam through a 90 degree turn. Below is a map that illustrates the\n\nproblem.\n\nH is 8 and W is 7 for this map.  The two communicating cows are notated as 'C's; rocks and other blocking elements are notated as '\\*'s:\n\n```plain\n7 . . . . . . .         7 . . . . . . . \n6 . . . . . . C         6 . . . . . /-C \n5 . . . . . . *         5 . . . . . | * \n4 * * * * * . *         4 * * * * * | * \n3 . . . . * . .         3 . . . . * | . \n2 . . . . * . .         2 . . . . * | . \n1 . C . . * . .         1 . C . . * | . \n0 . . . . . . .         0 . \\-------/ . \n  0 1 2 3 4 5 6           0 1 2 3 4 5 6 \n```\nDetermine the minimum number of mirrors M that must be installed to maintain laser communication between the two cows, a feat which is always possible in the given test data.", "inputFormat": "\\* Line 1: Two space separated integers: W and H\n\n\\* Lines 2..H+1: The entire pasture.", "outputFormat": "\\* Line 1: A single integer: M", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO09JAN] Laserphones S", "background": null, "description": "奶牛们有一个新的激光系统，这样它们在牧场上时可以进行随意的交谈。牧场被建模为一个 $W \\times H$ 的点阵（$1 \\leq W \\leq 100$，$1 \\leq H \\leq 100$）。\n\n该系统需要某种视线连通性以维持通信。当然，牧场上有岩石和树木会干扰通信，但奶牛们购买了对角镜（如下的 '/' 和 '\\\\'）来使激光束偏转 90 度。下面是一个说明问题的地图。\n\n对于这张地图，$H$ 是 8，$W$ 是 7。两个正在通信的奶牛用 'C' 表示；岩石和其他阻挡元素用 '*' 表示：\n\n```plain\n7 . . . . . . .         7 . . . . . . . \n6 . . . . . . C         6 . . . . . /-C \n5 . . . . . . *         5 . . . . . | * \n4 * * * * * . *         4 * * * * * | * \n3 . . . . * . .         3 . . . . * | . \n2 . . . . * . .         2 . . . . * | . \n1 . C . . * . .         1 . C . . * | . \n0 . . . . . . .         0 . \\-------/ . \n  0 1 2 3 4 5 6           0 1 2 3 4 5 6 \n```\n确定必须安装的最少镜子数量 $M$，以维持两头奶牛之间的激光通信。在给定的测试数据中，这一壮举总是可能的。", "inputFormat": "\\* 第 1 行：两个用空格分隔的整数：$W$ 和 $H$\n\n\\* 第 2 行到第 $H+1$ 行：整个牧场。", "outputFormat": "\\* 第 1 行：一个整数：$M$", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2938", "type": "P", "difficulty": 4, "samples": [["2 3 10 \n10 15 15 \n13 11 20 \n", "24 \n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO", "背包 DP", "最短路", "排列组合"], "title": "[USACO09FEB] Stock Market G", "background": "", "description": "Despite their innate prudence, the cows took a beating in the home mortgage market and now are trying their hand at stocks. Happily, Bessie is prescient and knows not only today's S (2 <= S <= 50) stock prices but also the future stock prices for a total of D days (2 <= D <= 10).\n\nGiven the matrix of current and future stock prices on various days (1 <= PR\\_sd <= 1,000) and an initial M (1 <= M <= 200,000) units of money, determine an optimal buying and selling strategy in order to maximize the gain realized by selling stock on the final day. Shares must be purchased in integer multiples, and you need not spend all the money (or any money). It is guaranteed that you will not be able to earn a profit of more than 500,000 units of money.\n\nConsider the example below of a bull (i.e., improving) market, the kind Bessie likes most. In this case, S=2 stocks and D=3 days. The cows have 10 units of money to invest.\n\n| Stock | Today's price | Tomorrow's price |    Two days hence Stock   |\n| :---: | :-----------: | :--------------: | :--: |\n|  $A$  |      10       |        15        |  15  |\n|  $B$  |      13       |        11        |  20  |\n\nIf money is to be made, the cows must purchase stock 1 on day 1. Selling stock 1 on day 2 and quickly buying stock 2 yields 4 money in the bank and one share of 2. Selling stock 2 on the final day brings in 20 money for a total of 24 money when the 20 is added to the bank.\n", "inputFormat": "\\* Line 1: Three space-separated integers: S, D, and M\n\n\\* Lines 2..S+1: Line s+1 contains the D prices for stock s on days 1..D: PR\\_sd\n", "outputFormat": "\\* Line 1: The maximum amount of money possible to have after selling on day D.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO09FEB] Stock Market G", "background": "", "description": "Despite their innate prudence, the cows took a beating in the home mortgage market and now are trying their hand at stocks. Happily, Bessie is prescient and knows not only today's S (2 <= S <= 50) stock prices but also the future stock prices for a total of D days (2 <= D <= 10).\n\nGiven the matrix of current and future stock prices on various days (1 <= PR\\_sd <= 1,000) and an initial M (1 <= M <= 200,000) units of money, determine an optimal buying and selling strategy in order to maximize the gain realized by selling stock on the final day. Shares must be purchased in integer multiples, and you need not spend all the money (or any money). It is guaranteed that you will not be able to earn a profit of more than 500,000 units of money.\n\nConsider the example below of a bull (i.e., improving) market, the kind Bessie likes most. In this case, S=2 stocks and D=3 days. The cows have 10 units of money to invest.\n\n| Stock | Today's price | Tomorrow's price |    Two days hence Stock   |\n| :---: | :-----------: | :--------------: | :--: |\n|  $A$  |      10       |        15        |  15  |\n|  $B$  |      13       |        11        |  20  |\n\nIf money is to be made, the cows must purchase stock 1 on day 1. Selling stock 1 on day 2 and quickly buying stock 2 yields 4 money in the bank and one share of 2. Selling stock 2 on the final day brings in 20 money for a total of 24 money when the 20 is added to the bank.\n", "inputFormat": "\\* Line 1: Three space-separated integers: S, D, and M\n\n\\* Lines 2..S+1: Line s+1 contains the D prices for stock s on days 1..D: PR\\_sd\n", "outputFormat": "\\* Line 1: The maximum amount of money possible to have after selling on day D.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO09FEB] Stock Market G", "background": "", "description": "尽管奶牛天生谨慎，它们仍然在住房抵押信贷市场中大受打击，现在它们准备在股市上碰碰运气。贝西有内部消息，她知道 $S$ 只股票在今后 $D$ 天内的价格。\n\n假设在一开始，她筹集了 $M$ 元钱，那么她该怎样操作才能赚到最多的钱呢？贝西在每天可以买卖多只股票，也可以多次买卖同一只股票，交易单位必须是整数，数量不限。举一个牛市的例子：\n\n假设贝西有 $10$ 元本金，股票价格如下：\n\n|  股票 | 今天的价格 | 明天的价格 | 后天的价格 |\n| :-: | :---: | :---: | :---: |\n| $A$ |   $10$  |   $15$  |   $15$  |\n| $B$ |   $13$  |   $11$  |   $20$  |\n\n最赚钱的做法是：今天买入 $A$ 股 $1$ 张，到明天把它卖掉并且买入 $B$ 股 $1$ 张，在后天卖掉 $B$ 股，这样贝西就有 $24$ 元了。", "inputFormat": "第一行：三个整数 $S,D$ 和 $M$，$2\\le S\\le 50,2\\le D\\le 10,1\\le M\\le 200000$。\n\n第二行到第 $S + 1$ 行：第 $i + 1$ 行有 $D$ 个整数：$P_{i,1}$ 到 $P_{i,D}$，表示第 $i$ 种股票在第一天到最后一天的售价，对所有 $1\\le j\\le D$，$1\\le P_{i,j}\\le 1000$。", "outputFormat": "单个整数：表示奶牛可以获得的最大钱数，保证这个数不会超过 $500000$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2939", "type": "P", "difficulty": 4, "samples": [["4 4 1 \n1 2 10 \n2 4 10 \n1 3 1 \n3 4 100 \n", "1 \n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "USACO", "最短路"], "title": "[USACO09FEB] Revamping Trails G", "background": "", "description": "Farmer John dutifully checks on the cows every day. He traverses some of the M (1 <= M <= 50,000) trails conveniently numbered 1..M from pasture 1 all the way out to pasture N (a journey which is always possible for trail maps given in the test data). The N (1 <= N <= 10,000) pastures conveniently numbered 1..N on Farmer John's farm are currently connected by bidirectional dirt trails.  Each trail i connects pastures P1\\_i and P2\\_i (1 <= P1\\_i <= N; 1 <= P2\\_i <= N) and requires T\\_i (1 <= T\\_i <= 1,000,000) units of time to traverse.\n\nHe wants to revamp some of the trails on his farm to save time on his long journey. Specifically, he will choose K (1 <= K <= 20) trails to turn into highways, which will effectively reduce the trail's traversal time to 0. Help FJ decide which trails to revamp to minimize the resulting time of getting from pasture 1 to N.\n\nTIME LIMIT: 2 seconds\n\n", "inputFormat": "\\* Line 1: Three space-separated integers: N, M, and K\n\n\\* Lines 2..M+1: Line i+1 describes trail i with three space-separated integers: P1\\_i, P2\\_i, and T\\_i\n", "outputFormat": "\\* Line 1: The length of the shortest path after revamping no more than K edges\n", "hint": "K is 1; revamp trail 3->4 to take time 0 instead of 100. The new shortest path is 1->3->4, total traversal time now 1.\n", "locale": "en", "translations": {"en": {"title": "[USACO09FEB] Revamping Trails G", "background": "", "description": "Farmer John dutifully checks on the cows every day. He traverses some of the M (1 <= M <= 50,000) trails conveniently numbered 1..M from pasture 1 all the way out to pasture N (a journey which is always possible for trail maps given in the test data). The N (1 <= N <= 10,000) pastures conveniently numbered 1..N on Farmer John's farm are currently connected by bidirectional dirt trails.  Each trail i connects pastures P1\\_i and P2\\_i (1 <= P1\\_i <= N; 1 <= P2\\_i <= N) and requires T\\_i (1 <= T\\_i <= 1,000,000) units of time to traverse.\n\nHe wants to revamp some of the trails on his farm to save time on his long journey. Specifically, he will choose K (1 <= K <= 20) trails to turn into highways, which will effectively reduce the trail's traversal time to 0. Help FJ decide which trails to revamp to minimize the resulting time of getting from pasture 1 to N.\n\nTIME LIMIT: 2 seconds\n\n", "inputFormat": "\\* Line 1: Three space-separated integers: N, M, and K\n\n\\* Lines 2..M+1: Line i+1 describes trail i with three space-separated integers: P1\\_i, P2\\_i, and T\\_i\n", "outputFormat": "\\* Line 1: The length of the shortest path after revamping no more than K edges\n", "hint": "K is 1; revamp trail 3->4 to take time 0 instead of 100. The new shortest path is 1->3->4, total traversal time now 1.\n", "locale": "en"}, "zh-CN": {"title": "[USACO09FEB] Revamping Trails G", "background": null, "description": "农夫约翰每天都会认真检查他的奶牛。他会穿越一些编号为 $1$ 到 $M$ 的小径（$1 \\leq M \\leq 50,000$），从牧场 $1$ 一直走到牧场 $N$（对于测试数据给出的路径图，这段旅程总是可能的）。农夫约翰的农场上有 $N$ 个牧场（$1 \\leq N \\leq 10,000$），它们通过双向泥土小径连接在一起。每条小径 $i$ 连接牧场 $P1_i$ 和 $P2_i$（$1 \\leq P1_i \\leq N,1 \\leq P2_i \\leq N$），需要 $T_i$（$1 \\leq T_i \\leq 1,000,000$）单位时间来穿越。\n\n他想要改造农场上的一些小径，以节省长途旅行的时间。具体来说，他将选择 $K$（$1 \\leq K \\leq 20$）条小径将其改造成高速公路，这将有效地将小径的穿越时间减少到 $0$。帮助 FJ 决定改造哪些小径以最小化从牧场 $1$ 到 $N$ 的最终时间。", "inputFormat": "* 第 $1$ 行：三个用空格分隔的整数：$N,M$ 和 $K$。\n\n* 第 $2$ 行到第 $M+1$ 行：第 $i+1$ 行描述小径 $i$，包含三个用空格分隔的整数：$P1_i$、$P2_i$ 和 $T_i$。", "outputFormat": "共 $1$ 行：改造不超过 $K$ 条边后的最短路径长度。", "hint": "$K$ 为 $1$；将小径 $3$->$4$ 改造成高速公路，时间从 $100$ 变为 $0$。新的最短路径为 $1$->$3$->$4$，总穿越时间现在为 $1$。", "locale": "zh-CN"}}}
{"pid": "P2940", "type": "P", "difficulty": 3, "samples": [["4 \n8 6 6 1 \n-3 4 0 5 \n4 2 1 9 \n1 -9 9 -2 \n", "24 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09FEB] The Leprechaun S", "background": "", "description": "Imagine Bessie's surprise as she spotted a leprechaun prancing through the north pasture. Being no one's fool, she charged and captured him with her prehensile hooves.\n\n\"One wish, bovine one. That's all I have for cows,\" he said.\n\n\"Riches,\" Bessie replied dreamily. \"The opportunity for riches.\"\n\nLeprechauns never grant the easiest possible form of a wish. When the smoke from a loud explosion cleared, a shimmering donut spun slowly over the verdant green fields.\n\n\"I have made you a torus,\" the leprechaun cooed. \"On that torus is an $N \\times N$ matrix ($1 \\le N \\le 200$) of integers in the range $-1{,}000{,}000..1{,}000{,}000$ that will determine the magnitude of your riches. You must find the contiguous sequence of integers, all in one row, one column, or along one diagonal, that yields the largest sum among all possible sequences on the torus.\"\n\nBessie realized that the torus \"wraps\" the rows, columns, and diagonals of the matrix so that one may choose contiguous elements that wrap around the edges. In other words, the two ends of a row are adjacent, the two ends of a column are adjacent, and even the ends across adjacent rows are adjacent in the diagonal directions. You must choose at least one matrix element.\n\nBy way of example, consider the $4 \\times 4$ matrix on the left below in which all the elements of one exemplary wrapped diagonal are marked:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/03z54guy.png)\n\nThe marked diagonal of the right-hand matrix includes two nines (the highest available number) and a six, for a total of $24$. This is the best possible sum for this matrix and uses only three of the four possible elements on that diagonal.", "inputFormat": "* Line 1: A single integer $N$.\n* Lines $2..N+1$: Line $i+1$ contains $N$ space-separated integers that compose row $i$ of the matrix.", "outputFormat": "* Line 1: A single integer that is the largest possible sum computable using the rules above.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en", "translations": {"en": {"title": "[USACO09FEB] The Leprechaun S", "background": "", "description": "Imagine Bessie's surprise as she spotted a leprechaun prancing through the north pasture. Being no one's fool, she charged and captured him with her prehensile hooves.\n\n\"One wish, bovine one. That's all I have for cows,\" he said.\n\n\"Riches,\" Bessie replied dreamily. \"The opportunity for riches.\"\n\nLeprechauns never grant the easiest possible form of a wish. When the smoke from a loud explosion cleared, a shimmering donut spun slowly over the verdant green fields.\n\n\"I have made you a torus,\" the leprechaun cooed. \"On that torus is an $N \\times N$ matrix ($1 \\le N \\le 200$) of integers in the range $-1{,}000{,}000..1{,}000{,}000$ that will determine the magnitude of your riches. You must find the contiguous sequence of integers, all in one row, one column, or along one diagonal, that yields the largest sum among all possible sequences on the torus.\"\n\nBessie realized that the torus \"wraps\" the rows, columns, and diagonals of the matrix so that one may choose contiguous elements that wrap around the edges. In other words, the two ends of a row are adjacent, the two ends of a column are adjacent, and even the ends across adjacent rows are adjacent in the diagonal directions. You must choose at least one matrix element.\n\nBy way of example, consider the $4 \\times 4$ matrix on the left below in which all the elements of one exemplary wrapped diagonal are marked:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/03z54guy.png)\n\nThe marked diagonal of the right-hand matrix includes two nines (the highest available number) and a six, for a total of $24$. This is the best possible sum for this matrix and uses only three of the four possible elements on that diagonal.", "inputFormat": "* Line 1: A single integer $N$.\n* Lines $2..N+1$: Line $i+1$ contains $N$ space-separated integers that compose row $i$ of the matrix.", "outputFormat": "* Line 1: A single integer that is the largest possible sum computable using the rules above.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09FEB] The Leprechaun S", "background": null, "description": "你难以想象贝茜看到一只妖精在牧场出现时是多么的惊讶．她不是傻瓜，立即猛扑过去，用她那灵活的牛蹄抓住了那只妖精．\n\n“你可以许一个愿望，傻大个儿！”妖精说．\n\n“财富，”贝茜用梦游般的声音回答道，  “我要获得财富的机会．”", "inputFormat": "妖精从来没有碰到过这么简单的愿望．他在地方划出一大块 $N\\times N(1≤N≤200)$ 的方格，每个格子上写上 $-1,000,000$ 到 $1,000,000$ 之间的数字．他说：“在方格上朝一个方向行走，可以是行的方向，列的方向，斜对角的方向，一步只能走一格，所有你踩过的数字的和就是你的财富．”\n\n贝茜请你来帮忙，找到一行、一列或一条对角线上找一段连续的数字，它们的和最大．由于妖精方格的神奇特性，沿着一个方向走，走到了边际，再一步跨过去可以“绕”到方格的对边出现．一行两端的格子是相邻的，一列两端的格子也是相邻的，甚至相邻两行的分别两端的格子也是相邻的（斜对角方向）．\n\n对于下图左边的方格，所有标记过的数字都在一条对角线上．\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tc1tim3s.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8cgrjpuz.png)\n \n对于这个方格，能踩出来的最大的和是 24，踩过的数字在右图中标记出来了", "outputFormat": "一行一个正整数表示答案", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2941", "type": "P", "difficulty": 3, "samples": [["12 \n1 7 \n7 3 \n3 6 \n6 10 \n10 1 \n2 12 \n2 9 \n8 9 \n8 12 \n11 5 \n5 4 \n11 4 \n0 15 9 20 25 8 10 13 17 8 8 7 \n15 0 12 12 10 10 8 15 15 8 8 9 \n9 12 0 25 20 18 16 14 13 7 12 12 \n20 12 25 0 8 13 14 15 15 10 10 10 \n25 10 20 8 0 16 20 18 17 18 9 11 \n8 10 18 13 16 0 10 9 11 10 8 12 \n10 8 16 14 20 10 0 18 20 6 16 15 \n13 15 14 15 18 9 18 0 5 12 12 13 \n17 15 13 15 17 11 20 5 0 22 8 10 \n8 8 7 10 18 10 6 12 22 0 11 12 \n8 8 12 10 9 8 16 12 8 11 0 9 \n7 9 12 10 11 12 15 13 10 12 9 0 \n", "30 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO", "并查集", "枚举"], "title": "[USACO09FEB] Surround the Islands S", "background": "", "description": "Farmer John has bought property in the Caribbean and is going to try to raise dairy cows on a big farm composed of islands. Set in his ways, he wants to surround all the islands with fence.\n\nEach island in the farm has the shape of a polygon. He fences the islands one side at a time (between a consecutive pair of vertices) and proceeds clockwise around a given island with his fencing\n\noperations. Since he wants to fence all the islands, he must at some point travel to any other islands using a boat.\n\nHe can start fencing at any vertex and, at any vertex he encounters, travel to some vertex on another island, fence all the way around it, and then IMMEDIATELY return back to the same vertex on the original island using the same path he traveled before. Each boat trip has a cost defined by a supplied matrix.\n\nThe islands are described by a set of N (3 <= N <= 500) pairs of vertices V1,V2 (1 <= V1 <= N; 1 <= V2 <= N) although you must figure out how to assemble them into islands. The vertices are conveniently numbered 1..N.\n\nThe cost of traveling by boat between each pair of vertices is given by a symmetric cost matrix whose elements fall in the range 0..1000.\n\nWhat is the minimum cost of surrounding the islands with the fence?", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Each line describes an island's border with two space-separated integers: V1 and V2\n\n\\* Lines N+2..2\\*N+1: Line i-N-1 contains N integers that describe row i of the cost matrix: Row\\_i\n", "outputFormat": "\\* Line 1: A single integer that specifies the minimum cost of building the fence\n", "hint": "1        10            4\n\nxxxxxxx              x\n\nxxxxxxxxx            xxxx\n\n7 xxxxxxxxxxx 6        xxxxxxx\n\nxxxxxxxxxxx       11 xxxxxxxxxx 5\n\nxxxxxxx\n\nxxx\n3         12 xxxxxxx 2\n\nxxxxxxxx\n\nxxxxxxxx\n\nxxxxxxxxx\n\nxxxxxxxxx\n\nxxxxxxxxxx\n\nxxxxxxxxxx\n\n8 xxxxxxxxxx 9\n\nThe example describes three islands: {1,7,3,6,10}, {4,5,11} and {2,9,8,12}. The travel costs are provided as a matrix. For example, the travel cost from vertex 1 to 2 is 15.\n\n\nThere is more than one solution. One is: FJ starts from vertex 3 then 7 and stops at 1, travels to 11 followed by 4,5,11. He then returns back to 1, and travels to 12 followed by 2,9,8,12. Finally, he returns back to 1 and continues with 10,6,3,7. The costs are 8 \\* 2 = 16 for traveling from 1 to 11 and returning back, and 7 \\* 2 = 14 for traveling from 1 to 12 and back -- a total cost of 30.\n", "locale": "en", "translations": {"en": {"title": "[USACO09FEB] Surround the Islands S", "background": "", "description": "Farmer John has bought property in the Caribbean and is going to try to raise dairy cows on a big farm composed of islands. Set in his ways, he wants to surround all the islands with fence.\n\nEach island in the farm has the shape of a polygon. He fences the islands one side at a time (between a consecutive pair of vertices) and proceeds clockwise around a given island with his fencing\n\noperations. Since he wants to fence all the islands, he must at some point travel to any other islands using a boat.\n\nHe can start fencing at any vertex and, at any vertex he encounters, travel to some vertex on another island, fence all the way around it, and then IMMEDIATELY return back to the same vertex on the original island using the same path he traveled before. Each boat trip has a cost defined by a supplied matrix.\n\nThe islands are described by a set of N (3 <= N <= 500) pairs of vertices V1,V2 (1 <= V1 <= N; 1 <= V2 <= N) although you must figure out how to assemble them into islands. The vertices are conveniently numbered 1..N.\n\nThe cost of traveling by boat between each pair of vertices is given by a symmetric cost matrix whose elements fall in the range 0..1000.\n\nWhat is the minimum cost of surrounding the islands with the fence?", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Each line describes an island's border with two space-separated integers: V1 and V2\n\n\\* Lines N+2..2\\*N+1: Line i-N-1 contains N integers that describe row i of the cost matrix: Row\\_i\n", "outputFormat": "\\* Line 1: A single integer that specifies the minimum cost of building the fence\n", "hint": "1        10            4\n\nxxxxxxx              x\n\nxxxxxxxxx            xxxx\n\n7 xxxxxxxxxxx 6        xxxxxxx\n\nxxxxxxxxxxx       11 xxxxxxxxxx 5\n\nxxxxxxx\n\nxxx\n3         12 xxxxxxx 2\n\nxxxxxxxx\n\nxxxxxxxx\n\nxxxxxxxxx\n\nxxxxxxxxx\n\nxxxxxxxxxx\n\nxxxxxxxxxx\n\n8 xxxxxxxxxx 9\n\nThe example describes three islands: {1,7,3,6,10}, {4,5,11} and {2,9,8,12}. The travel costs are provided as a matrix. For example, the travel cost from vertex 1 to 2 is 15.\n\n\nThere is more than one solution. One is: FJ starts from vertex 3 then 7 and stops at 1, travels to 11 followed by 4,5,11. He then returns back to 1, and travels to 12 followed by 2,9,8,12. Finally, he returns back to 1 and continues with 10,6,3,7. The costs are 8 \\* 2 = 16 for traveling from 1 to 11 and returning back, and 7 \\* 2 = 14 for traveling from 1 to 12 and back -- a total cost of 30.\n", "locale": "en"}, "zh-CN": {"title": "[USACO09FEB] Surround the Islands S", "background": null, "description": "Farmer John 在加勒比海购置了一片地产，准备在由一系列岛屿组成的农场上养奶牛。 出于他的意愿，他要把所有的岛屿都用篱笆围上。\n每个岛都是多边形的。每一次，FJ 会给多边形的一个边（即相邻的两个顶点之间）装上篱笆。对于整个岛屿，他会按照顺时针顺序装上篱笆。由于他想要给所有的岛屿都装上篱笆，某些时候，他必须从一个岛屿坐船到另一个岛屿去。  \nFJ 可以从任何一个顶点开始装篱笆，也可以从任何一个顶点坐船到另一个岛的某个顶点上，从这个顶点开始把该岛屿的篱笆全都装好，然后**马上**坐船原路返回。保证任意两个顶点间都有航线。在任意两个顶点之间坐船的费用会在一个矩阵中给出。  \n\n所有的岛屿由给定的 $N$ 对顶点 $V_1$，$V_2$ 描述（即：给定顶点 $V_1$ 与 $V_2$ 相邻）。每个顶点具体属于哪个岛屿**不会**在输入中给出。所有顶点由 $1$ 到 $N$ 标号。  \n在顶点间坐船旅行的费用由一个 $N \\times N$ 的矩阵给出。保证两个岛屿间两个方向的旅行费用相等且不会超过 $1000$。   \n\n请求出 FJ 把篱笆装完所需要的最小花费。", "inputFormat": "第 $1$ 行一个整数 $N$。\n\n第 $2$ 至第 $N+1$ 行：每行包含两个整数 $V_1$ 和 $V_2$，表示这两个顶点在同一个岛屿上且相邻。\n\n第 $N+2$ 行至第 $2\\times N+1$ 行：每行包含 $N$ 个整数，第 $i+N+1$ 行的第 $j$ 个整数表示从 $i$ 号顶点坐船到第 $j$ 号顶点的花费。", "outputFormat": "一行一个整数，表示 FJ 把篱笆装完所需要的最小花费。", "hint": "对于所有数据，保证：\n+ $3 \\leq N \\leq 500$\n+ $1 \\leq V_1,V_2 \\leq N$\n+ 任意两个顶点之间的旅行花费 $\\leq 1000$", "locale": "zh-CN"}}}
{"pid": "P2942", "type": "P", "difficulty": 3, "samples": [["3 10 \n4 3 3 \n17 8 2 \n", "65 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09MAR] Moon Mooing G", "background": "", "description": "A full moon casts some sort of spell on the cows and, like their cousins the wolves and coyotes, they bay at the moon -- mooing instead of howling, of course.\n\nEach 'moo' lasts a certain amount of time. A short 'moo' might last time 1; a longer one might last time 24 or even 1,000,000,000 or longer (cows can really moo when they want to). No 'moo' will last more than or equal to 2^63.\n\nIt should come as no surprise that the cows have a pattern to their moos.  Bessie will choose an integer c (1 <= c <= 100) that is the initial length of a moo.\n\nAfter Bessie moos for length c, the cows calculate times for\n\nsubsequent moos. They apply two formulae to each moo time to yield even more moo times. The two formulae are:\n\n```cpp\nf1(c)=a1*c/d1+b1 (integer divide, of course) and \nf2(c)=a2*c/d2+b2. \nThey then successively use the two new times created by evaluating f1(c) and f2(c) to create even more mooing times. They keep a sorted list of all the possible mooing times (discarding duplicates). \nThey are allowed to moo a total of N times (1 <= N <= 4,000,000). Please determine the length of the longest moo before they must quit. \nThe constants in the formulae have these constraints: 1 <= d1 < a1; d1 < a1 <= 20; 0 <= b1 <= 20; 1 <= d2 < a2; d2 < a2 <= 20; 0 <= b2 <= 20. \nConsider an example where c=3 and N=10. The constants are: \na1=4    b1=3     d1=3 \na2=17   b2=8     d2=2 \n```\nThe first mooing time is 3, given by the value of c. The total list of mooing times is:\n```cpp\n1. c=3             ->  3       6. f2(3)=17*3/2+8  -> 33 \n2. f1(3)=4*3/3+3   ->  7       7. f1(28)=4*28/3+3 -> 40 \n3. f1(7)=4*7/3+3   -> 12       8. f1(33)=4*33/3+3 -> 47 \n4. f1(12)=4*12/3+3 -> 19       9. f1(40)=4*40/3+3 -> 56 \n5. f1(19)=4*19/3+3 -> 28      10. f1(47)=4*47/3+3 -> 65 \nThe tenth time is 65, which would be the proper answer for this set of inputs. \n```\nPartial feedback will be provided on the first 50 submissions.\nMEMORY LIMIT: 64MB\n\n满月的时候，和狼一样，牛们也在月光下叫，他们从不嚎叫，而是哞叫。\n\n每次哞叫都有一个时长，可能是 $1$ 秒，可能是 $10^9$ 秒或更久，牛们真的非常能叫.当然，没有哞叫时长会超过或等于 $2^{63}$。\n\n牛们的哞叫可以找到规律，这并不奇怪。贝茜会选择一个整数 $c(c\\le100)$ 来作为初始时长之后，牛们根据两条公式确定更多的时长：\n\n$f_1(c)=\\lfloor a_1c/d_1\\rfloor+b_1$\n\n$f_2(c)=\\lfloor a_2c/d_2\\rfloor+b_2$ \n\n牛们用这两条公式不断地迭代、计算，算得大量的时长.然后她们将这些时长排序，剔除重复的时长，最后取前 $N(1<N< 4000000)$ 个整数为她们 $N$ 次哞叫的时长.请你计算，第 $N$ 次哞叫的时长是多少。公式中的常量均为整数，满足下列关系： \n\n$1 \\le d_1 < a_1 \\le 20$; $0\\le b_1 \\le 20$;\n\n$1 \\le d_2 < a_2 \\le 20$; $0\\le b_2\\le 20$。\n", "inputFormat": "\\* Line 1: Two space-separated integers: c and N\n\n\\* Line 2: Three space-separated integers: a1, b1, and d1\n\n\\* Line 3: Three space-separated integers: a2, b2, and d2\n", "outputFormat": "\\* Line 1: A single line which contains a single integer which is the length of the Nth moo\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09MAR] Moon Mooing G", "background": "", "description": "A full moon casts some sort of spell on the cows and, like their cousins the wolves and coyotes, they bay at the moon — mooing instead of howling, of course.\n\nEach \"moo\" lasts a certain amount of time. A short \"moo\" might last time 1; a longer one might last time 24 or even 1,000,000,000 or longer (cows can really moo when they want to). No \"moo\" will last more than or equal to $2^{63}$.\n\nIt should come as no surprise that the cows have a pattern to their moos. Bessie will choose an integer $c$ ($1 \\le c \\le 100$) that is the initial length of a moo.\n\nAfter Bessie moos for length $c$, the cows calculate times for subsequent moos. They apply two formulae to each moo time to yield even more moo times. The two formulae are:\n\n```cpp\nf1(c)=a1*c/d1+b1 (integer divide, of course) and \nf2(c)=a2*c/d2+b2. \nThey then successively use the two new times created by evaluating f1(c) and f2(c) to create even more mooing times. They keep a sorted list of all the possible mooing times (discarding duplicates). \nThey are allowed to moo a total of N times (1 <= N <= 4,000,000). Please determine the length of the longest moo before they must quit. \nThe constants in the formulae have these constraints: 1 <= d1 < a1; d1 < a1 <= 20; 0 <= b1 <= 20; 1 <= d2 < a2; d2 < a2 <= 20; 0 <= b2 <= 20. \nConsider an example where c=3 and N=10. The constants are: \na1=4    b1=3     d1=3 \na2=17   b2=8     d2=2 \n```\n\nThe first mooing time is 3, given by the value of $c$. The total list of mooing times is:\n```cpp\n1. c=3             ->  3       6. f2(3)=17*3/2+8  -> 33 \n2. f1(3)=4*3/3+3   ->  7       7. f1(28)=4*28/3+3 -> 40 \n3. f1(7)=4*7/3+3   -> 12       8. f1(33)=4*33/3+3 -> 47 \n4. f1(12)=4*12/3+3 -> 19       9. f1(40)=4*40/3+3 -> 56 \n5. f1(19)=4*19/3+3 -> 28      10. f1(47)=4*47/3+3 -> 65 \nThe tenth time is 65, which would be the proper answer for this set of inputs. \n```\n\nThey keep a sorted list of all possible moo times (discarding duplicates). They are allowed to moo a total of $N$ times ($1 \\le N \\le 4{,}000{,}000$). Please determine the length of the $N$-th moo.\n\nThe constants in the formulae are integers and satisfy:\n$1 \\le d_1 < a_1 \\le 20$; $0 \\le b_1 \\le 20$;\n$1 \\le d_2 < a_2 \\le 20$; $0 \\le b_2 \\le 20$.\n\nThe two formulae are:\n$f_1(c)=\\lfloor a_1 c / d_1 \\rfloor + b_1$\n$f_2(c)=\\lfloor a_2 c / d_2 \\rfloor + b_2$.", "inputFormat": "- Line 1: Two space-separated integers: $c$ and $N$.\n- Line 2: Three space-separated integers: $a_1$, $b_1$, and $d_1$.\n- Line 3: Three space-separated integers: $a_2$, $b_2$, and $d_2$.", "outputFormat": "- Line 1: A single integer — the length of the $N$-th moo.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09MAR] Moon Mooing G", "background": "", "description": "A full moon casts some sort of spell on the cows and, like their cousins the wolves and coyotes, they bay at the moon -- mooing instead of howling, of course.\n\nEach 'moo' lasts a certain amount of time. A short 'moo' might last time 1; a longer one might last time 24 or even 1,000,000,000 or longer (cows can really moo when they want to). No 'moo' will last more than or equal to 2^63.\n\nIt should come as no surprise that the cows have a pattern to their moos.  Bessie will choose an integer c (1 <= c <= 100) that is the initial length of a moo.\n\nAfter Bessie moos for length c, the cows calculate times for\n\nsubsequent moos. They apply two formulae to each moo time to yield even more moo times. The two formulae are:\n\n```cpp\nf1(c)=a1*c/d1+b1 (integer divide, of course) and \nf2(c)=a2*c/d2+b2. \nThey then successively use the two new times created by evaluating f1(c) and f2(c) to create even more mooing times. They keep a sorted list of all the possible mooing times (discarding duplicates). \nThey are allowed to moo a total of N times (1 <= N <= 4,000,000). Please determine the length of the longest moo before they must quit. \nThe constants in the formulae have these constraints: 1 <= d1 < a1; d1 < a1 <= 20; 0 <= b1 <= 20; 1 <= d2 < a2; d2 < a2 <= 20; 0 <= b2 <= 20. \nConsider an example where c=3 and N=10. The constants are: \na1=4    b1=3     d1=3 \na2=17   b2=8     d2=2 \n```\nThe first mooing time is 3, given by the value of c. The total list of mooing times is:\n```cpp\n1. c=3             ->  3       6. f2(3)=17*3/2+8  -> 33 \n2. f1(3)=4*3/3+3   ->  7       7. f1(28)=4*28/3+3 -> 40 \n3. f1(7)=4*7/3+3   -> 12       8. f1(33)=4*33/3+3 -> 47 \n4. f1(12)=4*12/3+3 -> 19       9. f1(40)=4*40/3+3 -> 56 \n5. f1(19)=4*19/3+3 -> 28      10. f1(47)=4*47/3+3 -> 65 \nThe tenth time is 65, which would be the proper answer for this set of inputs. \n```\nPartial feedback will be provided on the first 50 submissions.\nMEMORY LIMIT: 64MB\n\n满月的时候，和狼一样，牛们也在月光下叫，他们从不嚎叫，而是哞叫。\n\n每次哞叫都有一个时长，可能是 $1$ 秒，可能是 $10^9$ 秒或更久，牛们真的非常能叫.当然，没有哞叫时长会超过或等于 $2^{63}$。\n\n牛们的哞叫可以找到规律，这并不奇怪。贝茜会选择一个整数 $c(c\\le100)$ 来作为初始时长之后，牛们根据两条公式确定更多的时长：\n\n$f_1(c)=\\lfloor a_1c/d_1\\rfloor+b_1$\n\n$f_2(c)=\\lfloor a_2c/d_2\\rfloor+b_2$ \n\n牛们用这两条公式不断地迭代、计算，算得大量的时长.然后她们将这些时长排序，剔除重复的时长，最后取前 $N(1<N< 4000000)$ 个整数为她们 $N$ 次哞叫的时长.请你计算，第 $N$ 次哞叫的时长是多少。公式中的常量均为整数，满足下列关系： \n\n$1 \\le d_1 < a_1 \\le 20$; $0\\le b_1 \\le 20$;\n\n$1 \\le d_2 < a_2 \\le 20$; $0\\le b_2\\le 20$。\n", "inputFormat": "\\* Line 1: Two space-separated integers: c and N\n\n\\* Line 2: Three space-separated integers: a1, b1, and d1\n\n\\* Line 3: Three space-separated integers: a2, b2, and d2\n", "outputFormat": "\\* Line 1: A single line which contains a single integer which is the length of the Nth moo\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2943", "type": "P", "difficulty": 5, "samples": [["13 4 \n1 \n2 \n1 \n3 \n2 \n2 \n3 \n4 \n3 \n4 \n3 \n1 \n4 \n", "11 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2009", "USACO", "枚举"], "title": "[USACO09MAR] Cleaning Up G", "background": "", "description": "In the good old days, Farmer John served a boring cuisine comprising but a single type of cow food to his N (1 <= N <= 40000) prize dairy cows. Times change. Today he serves the herd a total of M (1 <= M <= N) different types of food (conveniently numbered 1..M).\n\nThe cows are picky. Cow i has a single food preference P\\_i (1 <= P\\_i <= M) and will eat only that favorite food.\n\nEach day at feeding time FJ converts the barn into a tastefully lit cafeteria. The cows line up outside to enter the cafeteria in order of their previously-mentioned convenient index number.\n\nUnfortunately, with so many types of food, cleaning up afterwards is very time-consuming. If Farmer John is serving K different types of food, it takes him K\\*K units of time to clean the barn.\n\nTo save time, FJ serves the cows in contiguous groups from the line. After each group, he cleans up the barn and sets out the food for the next group (of course, he only sets out food that cows in the any given group will eat). Determine the minimum amount of total time FJ must spend cleaning the barn. Each group consists of the next contiguous group of cows from the line; each cow belongs to exactly one group; and the barn must be cleaned up after every group, including the last one.\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: P\\_i\n", "outputFormat": "\\* Line 1: A single integer: the minimum amount of time FJ must spend cleaning the  barn.\n", "hint": "There are four types of food and thirteen cows in line. The first cow prefers type 1, the second type 2, the third type 1, etc.\n\n\nThe first four groups contain one cow each. The fifth group contains two cows who prefer food #2 (requiring one unit of time). The sixth group contains cows preferring foods 3, 4, 3, 4, 3 (and requires four units of time to clean). The last two groups contain one cow each. The total time is 11.\n", "locale": "en", "translations": {"en": {"title": "[USACO09MAR] Cleaning Up G", "background": "", "description": "In the good old days, Farmer John served a boring cuisine comprising but a single type of cow food to his N (1 <= N <= 40000) prize dairy cows. Times change. Today he serves the herd a total of M (1 <= M <= N) different types of food (conveniently numbered 1..M).\n\nThe cows are picky. Cow i has a single food preference P\\_i (1 <= P\\_i <= M) and will eat only that favorite food.\n\nEach day at feeding time FJ converts the barn into a tastefully lit cafeteria. The cows line up outside to enter the cafeteria in order of their previously-mentioned convenient index number.\n\nUnfortunately, with so many types of food, cleaning up afterwards is very time-consuming. If Farmer John is serving K different types of food, it takes him K\\*K units of time to clean the barn.\n\nTo save time, FJ serves the cows in contiguous groups from the line. After each group, he cleans up the barn and sets out the food for the next group (of course, he only sets out food that cows in the any given group will eat). Determine the minimum amount of total time FJ must spend cleaning the barn. Each group consists of the next contiguous group of cows from the line; each cow belongs to exactly one group; and the barn must be cleaned up after every group, including the last one.\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: P\\_i\n", "outputFormat": "\\* Line 1: A single integer: the minimum amount of time FJ must spend cleaning the  barn.\n", "hint": "There are four types of food and thirteen cows in line. The first cow prefers type 1, the second type 2, the third type 1, etc.\n\n\nThe first four groups contain one cow each. The fifth group contains two cows who prefer food #2 (requiring one unit of time). The sixth group contains cows preferring foods 3, 4, 3, 4, 3 (and requires four units of time to clean). The last two groups contain one cow each. The total time is 11.\n", "locale": "en"}, "zh-CN": {"title": "[USACO09MAR] Cleaning Up G", "background": null, "description": "在过去的好日子里，农夫约翰只为他的 $N$（$1 \\leq N \\leq 40000$）头优质奶牛提供一种单一类型的牛饲料。时光流逝，如今他为牛群提供总共 $M$（$1 \\leq M \\leq N$）种不同类型的食物（方便地编号为 $1$ 到 $M$）。\n\n奶牛们很挑剔。奶牛 $i$ 只有一个食物偏好 $P_i$（$1 \\leq P_i \\leq M$），并且只吃那种最喜欢的食物。\n\n每天喂食时间，FJ 将谷仓改造成一个灯光优雅的自助餐厅。奶牛们按照之前提到的方便索引编号排队进入餐厅。\n\n不幸的是，由于食物种类繁多，事后清理工作非常耗时。如果农夫约翰提供 $K$ 种不同类型的食物，他需要花费 $K \\times K$ 单位的时间来清理谷仓。\n\n为了节省时间，FJ 将奶牛按连续的组来喂食。每组之后，他清理谷仓并为下一组准备食物（当然，他只准备给定组中的奶牛会吃的食物）。请确定 FJ 清理谷仓所需的最少总时间。每组由队列中下一个连续的奶牛组组成；每头奶牛只属于一个组；每组之后，包括最后一组，谷仓都必须清理。", "inputFormat": "第 $1$ 行两个用空格分隔的整数 $N$ 和 $M$。\n\n第 $2$ 行到第 $N+1$ 行：第 $i+1$ 行包含一个整数 $P_i$。", "outputFormat": "第 1 行一个整数：FJ 清理谷仓所需的最少时间。", "hint": "有四种类型的食物和十三头奶牛排队。第一头奶牛喜欢类型 $1$，第二头喜欢类型 $2$，第三头喜欢类型 $1$，等等。\n\n前四组每组包含一头奶牛。第五组包含两头喜欢食物 $2$ 的奶牛（需要一单位时间）。第六组包含喜欢食物 $3$、$4$、$3$、$4$、$3$ 的奶牛（需要四单位时间清理）。最后两组每组包含一头奶牛。总时间是 $11$。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2944", "type": "P", "difficulty": 6, "samples": [["5 5 2 \n1 2 \n2 3 \n3 5 \n2 4 \n4 5 \n4 \n5 \n", "1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO", "网络流", "图论建模", "最小割"], "title": "[USACO09MAR] Earthquake Damage 2 G", "background": null, "description": "威斯康辛州发生地震，袭击了农夫约翰的农场！地震摧毁了部分牧场。令人惊讶的是，所有的路径均未受损。\n\n农夫约翰的农场有 $P\\ (1 \\le P \\le 3,000)$ 个牧场，牧场依次编号为 $1$ 至 $P$。牧场通过 $C\\ (1 \\le C \\le 20,000)$ 条双向路径相连，路径依次编号为 $1$ 至 $C$。第 $i$ 条路径连接牧场 $a_i$ 和 $b_i\\ (1 \\le a_i,b_i \\le P)$。路径可能连接同一牧场，也可能重复连接两个牧场。牛棚位于牧场 $1$。\n\n共有位于不同牧场的 $N\\ (1 \\le N \\le P)$ 头奶牛依次通过手机向农夫约翰报告它们所位于的牧场的编号，第 $j$ 头奶牛报告的编号为 $report_j\\ (2 \\le report_j \\le P)$，表明虽然牧场 $report_j$ 没有被摧毁，但报告的奶牛找不到一条可以在不经过被摧毁牧场的前提下从 $report_j$ 返回牛棚的路径。\n\n所有奶牛报告完毕后，请确定被摧毁牧场的最小数量。", "inputFormat": "第 $1$ 行：三个以空格分隔的整数，分别表示 $P$，$C$ 和 $N$。\n\n第 $2$ 到 $C+1$ 行：第 $i+1$ 行包含两个整数，表示一条连接牧场 $a_i$ 和 $b_i$ 的双向路径。\n\n第 $C+2$ 到 $C+N+1$ 行：第 $C+1+j$ 行包含一个整数，表示 $report_j$。", "outputFormat": "第 $1$ 行：一个整数，表示被摧毁牧场的最小数量。", "hint": "只有牧场 $2$ 被摧毁才会出现这种情况。", "locale": "zh-CN", "translations": {"en": {"title": null, "background": null, "description": "Wisconsin has had an earthquake that has struck Farmer John's farm! The earthquake has damaged some of the pastures so that they are unpassable. Remarkably, none of the cowpaths was damaged.\n\nAs usual, the farm is modeled as a set of $P\\ (1 \\le P \\le 3,000)$ pastures conveniently numbered $1\\cdots P$ which are connected by a set of $C\\ (1 \\le C \\le 20,000)$ non-directional cowpaths conveniently numbered $1\\dots C$. Cowpath $i$ connects pastures $a_i$ and $b_i\\ (1 \\le a_i,b_i \\le P)$. Cowpaths might connect $a_i$ to itself or perhaps might connect two pastures more than once. The barn is located in pasture $1$.\n\nA total of $N\\ (1 \\le N \\le P)$ cows (in different pastures) sequentially contacts Farmer John via moobile phone with an integer message $report_j\\ (2 \\le report_j \\le P)$ that indicates that pasture $report_j$ is undamaged but that the calling cow is unable to return to the barn from pasture $report_j$ because she could not find a path that does not go through damaged pastures.\n\nAfter all the cows report in, determine the minimum number of pastures that are damaged.", "inputFormat": "Line $1$: Three space-separated integers: $P$, $C$, and $N$.\n\nLines $2\\dots C+1$: Line $i+1$ describes cowpath $i$ with two integers: $a_i$ and $b_i$.\n\nLines $C+2\\dots C+N+1$: Line $C+1+j$ contains a single integer: $report_j$", "outputFormat": "Line $1$: One number, the minimum number of damaged pastures.", "hint": "Only pasture $2$ being damaged gives such a scenario.", "locale": "en"}, "zh-CN": {"title": "[USACO09MAR] Earthquake Damage 2 G", "background": null, "description": "威斯康辛州发生地震，袭击了农夫约翰的农场！地震摧毁了部分牧场。令人惊讶的是，所有的路径均未受损。\n\n农夫约翰的农场有 $P\\ (1 \\le P \\le 3,000)$ 个牧场，牧场依次编号为 $1$ 至 $P$。牧场通过 $C\\ (1 \\le C \\le 20,000)$ 条双向路径相连，路径依次编号为 $1$ 至 $C$。第 $i$ 条路径连接牧场 $a_i$ 和 $b_i\\ (1 \\le a_i,b_i \\le P)$。路径可能连接同一牧场，也可能重复连接两个牧场。牛棚位于牧场 $1$。\n\n共有位于不同牧场的 $N\\ (1 \\le N \\le P)$ 头奶牛依次通过手机向农夫约翰报告它们所位于的牧场的编号，第 $j$ 头奶牛报告的编号为 $report_j\\ (2 \\le report_j \\le P)$，表明虽然牧场 $report_j$ 没有被摧毁，但报告的奶牛找不到一条可以在不经过被摧毁牧场的前提下从 $report_j$ 返回牛棚的路径。\n\n所有奶牛报告完毕后，请确定被摧毁牧场的最小数量。", "inputFormat": "第 $1$ 行：三个以空格分隔的整数，分别表示 $P$，$C$ 和 $N$。\n\n第 $2$ 到 $C+1$ 行：第 $i+1$ 行包含两个整数，表示一条连接牧场 $a_i$ 和 $b_i$ 的双向路径。\n\n第 $C+2$ 到 $C+N+1$ 行：第 $C+1+j$ 行包含一个整数，表示 $report_j$。", "outputFormat": "第 $1$ 行：一个整数，表示被摧毁牧场的最小数量。", "hint": "只有牧场 $2$ 被摧毁才会出现这种情况。", "locale": "zh-CN"}}}
{"pid": "P2945", "type": "P", "difficulty": 2, "samples": [["3 6 5 \n3 1 \n1 2 \n1 2 \n", "11 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2009", "USACO"], "title": "[USACO09MAR] Sand Castle S", "background": "", "description": "Farmer John has built a sand castle! Like all good castles, the walls have crennelations, that nifty pattern of embrasures (gaps) and merlons (filled spaces); see the diagram below. The N (1 <= N <= 25,000) merlons of his castle wall are conveniently numbered 1..N; merlon i has height M\\_i (1 <= M\\_i <= 100,000); his merlons often have varying heights, unlike so many.\n\nHe wishes to modify the castle design in the following fashion: he has a list of numbers B\\_1 through B\\_N (1 <= B\\_i <= 100,000), and wants to change the merlon heights to those heights B\\_1, ..., B\\_N in some order (not necessarily the order given or any other order derived from the data).\n\nTo do this, he has hired some bovine craftsmen to raise and lower the merlons' heights. Craftsmen, of course, cost a lot of money. In particular, they charge FJ a total X (1 <= X <= 100) money per unit height added and Y (1 <= Y <= 100) money per unit height\n\nreduced.\n\nFJ would like to know the cheapest possible cost of modifying his sand castle if he picks the best permutation of heights. The answer is guaranteed to fit within a 32-bit signed integer.\n\nNote: about 40% of the test data will have N <= 9, and about 60% will have N <= 18.", "inputFormat": "\\* Line 1: Three space-separated integers: N, X, and Y\n\n\\* Lines 2..N+1: Line i+1 contains the two space-separated integers: M\\_i and B\\_i\n", "outputFormat": "\\* Line 1: A single integer, the minimum cost needed to rebuild the castle\n", "hint": "FJ's castle starts with heights of 3, 1, and 1. He would like to change them so that their heights are 1, 2, and 2, in some order. It costs 6 to add a unit of height and 5 to remove a unit of height.\n\n\nFJ reduces the first merlon's height by 1, for a cost of 5 (yielding merlons of heights 2, 1, and 1). He then adds one unit of height to the second merlon for a cost of 6 (yielding merlons of heights 2, 2, and 1).\n", "locale": "en", "translations": {"en": {"title": "[USACO09MAR] Sand Castle S", "background": "", "description": "Farmer John has built a sand castle! Like all good castles, the walls have crennelations, that nifty pattern of embrasures (gaps) and merlons (filled spaces); see the diagram below. The N (1 <= N <= 25,000) merlons of his castle wall are conveniently numbered 1..N; merlon i has height M\\_i (1 <= M\\_i <= 100,000); his merlons often have varying heights, unlike so many.\n\nHe wishes to modify the castle design in the following fashion: he has a list of numbers B\\_1 through B\\_N (1 <= B\\_i <= 100,000), and wants to change the merlon heights to those heights B\\_1, ..., B\\_N in some order (not necessarily the order given or any other order derived from the data).\n\nTo do this, he has hired some bovine craftsmen to raise and lower the merlons' heights. Craftsmen, of course, cost a lot of money. In particular, they charge FJ a total X (1 <= X <= 100) money per unit height added and Y (1 <= Y <= 100) money per unit height\n\nreduced.\n\nFJ would like to know the cheapest possible cost of modifying his sand castle if he picks the best permutation of heights. The answer is guaranteed to fit within a 32-bit signed integer.\n\nNote: about 40% of the test data will have N <= 9, and about 60% will have N <= 18.", "inputFormat": "\\* Line 1: Three space-separated integers: N, X, and Y\n\n\\* Lines 2..N+1: Line i+1 contains the two space-separated integers: M\\_i and B\\_i\n", "outputFormat": "\\* Line 1: A single integer, the minimum cost needed to rebuild the castle\n", "hint": "FJ's castle starts with heights of 3, 1, and 1. He would like to change them so that their heights are 1, 2, and 2, in some order. It costs 6 to add a unit of height and 5 to remove a unit of height.\n\n\nFJ reduces the first merlon's height by 1, for a cost of 5 (yielding merlons of heights 2, 1, and 1). He then adds one unit of height to the second merlon for a cost of 6 (yielding merlons of heights 2, 2, and 1).\n", "locale": "en"}, "zh-CN": {"title": "[USACO09MAR] Sand Castle S", "background": "", "description": "农夫 John 建造了一座沙堡！像所有好的城堡一样，城墙上有垛口，那种由垛口（空隙）和垛堞（填充空间）组成的精巧图案；见下图。他的城堡墙上的 N（1 <= N <= 25,000）个垛堞被方便地编号为 1 到 N；垛堞 i 的高度为 $M_i$（1 <= $M_i$ <= 100,000）；他的垛堞高度常常不同，这与许多其他的不同。\n\n他希望以以下方式修改城堡设计：他有一个从 $B_1$ 到 $B_N$（1 <= $B_i$ <= 100,000）的数字列表，并希望将垛堞的高度更改为这些高度 $B_1, ..., B_N$ 的某种顺序（不一定是给定的顺序或从数据派生的任何其他顺序）。\n\n为此，他雇佣了一些牛工匠来增加和降低垛堞的高度。当然，工匠们要价很高。特别是，他们向 FJ 收取总共 $X$（1 <= $X$ <= 100）每单位高度增加的钱和 $Y$（1 <= $Y$ <= 100）每单位高度减少的钱。\n\nFJ 想知道如果他选择最佳的高度排列，修改他的沙堡的最低可能成本是多少。答案保证适合 32 位有符号整数。\n\n注意：大约 40% 的测试数据将有 N <= 9，大约 60% 将有 N <= 18。", "inputFormat": "\\* 第 1 行：三个用空格分隔的整数：N, X 和 Y\n\n\\* 第 2 行到第 N+1 行：第 i+1 行包含两个用空格分隔的整数：$M_i$ 和 $B_i$\n", "outputFormat": "\\* 第 1 行：一个整数，重建城堡所需的最低成本\n", "hint": "FJ 的城堡起始高度为 3, 1 和 1。他希望将它们的高度更改为 1, 2 和 2，以某种顺序。增加一个单位高度的成本为 6，减少一个单位高度的成本为 5。\n\n\nFJ 将第一个垛堞的高度减少 1，成本为 5（得到高度为 2, 1 和 1 的垛堞）。然后他为第二个垛堞增加一个单位的高度，成本为 6（得到高度为 2, 2 和 1 的垛堞）。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2946", "type": "P", "difficulty": 3, "samples": [["4 5 \n1 \n2 \n8 \n2 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "USACO", "背包 DP"], "title": "[USACO09MAR] Cow Frisbee Team S", "background": "", "description": "老唐最近迷上了飞盘，约翰想和他一起玩，于是打算从他家的 $N$ 头奶牛中选出一支队伍。\n\n每只奶牛的能力为整数，第 $i$ 头奶牛的能力为 $R_i$。飞盘队的队员数量不能少于 $1$、大于 $N$。一支队伍的总能力就是所有队员能力的总和。\n\n约翰比较迷信，他的幸运数字是 $F$，所以他要求队伍的总能力必须是 $F$ 的倍数。请帮他算一下，符合这个要求的队伍组合有多少？由于这个数字很大，只要输出答案对 $10^8$ 取模的值。", "inputFormat": "第一行：两个用空格分开的整数：$N$ 和 $F$。\n\n第二行到 $N+1$ 行：第 $i+1$ 行有一个整数 $R_i$，表示第 $i$ 头奶牛的能力。", "outputFormat": "第一行：单个整数，表示方案数对 $10^8$ 取模的值。", "hint": "对于 $100\\%$ 的数据，$1 \\le N \\le 2000$，$1 \\le F \\le 1000$，$1 \\le R_i \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09MAR] Cow Frisbee Team S", "background": "", "description": "Lao Tang has recently gotten into frisbee, and John wants to play with him, so he plans to select a team from his $N$ cows.\n\nEach cow has an integer ability. The $i$-th cow’s ability is $R_i$. The number of players on the frisbee team must be between $1$ and $N$ inclusive. A team’s total ability is the sum of the abilities of all its members.\n\nJohn is superstitious, and his lucky number is $F$, so he requires the team’s total ability to be a multiple of $F$. Please compute how many team selections satisfy this requirement. Since this number can be very large, output the answer modulo $10^8$.", "inputFormat": "The first line contains two space-separated integers: $N$ and $F$.\n\nLines $2$ through $N+1$: line $i+1$ contains an integer $R_i$, the ability of the $i$-th cow.", "outputFormat": "A single integer: the number of valid selections modulo $10^8$.", "hint": "For $100\\%$ of the testdata, $1 \\le N \\le 2000$, $1 \\le F \\le 1000$, $1 \\le R_i \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09MAR] Cow Frisbee Team S", "background": "", "description": "老唐最近迷上了飞盘，约翰想和他一起玩，于是打算从他家的 $N$ 头奶牛中选出一支队伍。\n\n每只奶牛的能力为整数，第 $i$ 头奶牛的能力为 $R_i$。飞盘队的队员数量不能少于 $1$、大于 $N$。一支队伍的总能力就是所有队员能力的总和。\n\n约翰比较迷信，他的幸运数字是 $F$，所以他要求队伍的总能力必须是 $F$ 的倍数。请帮他算一下，符合这个要求的队伍组合有多少？由于这个数字很大，只要输出答案对 $10^8$ 取模的值。", "inputFormat": "第一行：两个用空格分开的整数：$N$ 和 $F$。\n\n第二行到 $N+1$ 行：第 $i+1$ 行有一个整数 $R_i$，表示第 $i$ 头奶牛的能力。", "outputFormat": "第一行：单个整数，表示方案数对 $10^8$ 取模的值。", "hint": "对于 $100\\%$ 的数据，$1 \\le N \\le 2000$，$1 \\le F \\le 1000$，$1 \\le R_i \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P2947", "type": "P", "difficulty": 3, "samples": [["6 \n3 \n2 \n6 \n1 \n1 \n2 \n", "3 \n3 \n0 \n6 \n6 \n0 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2009", "USACO", "单调栈"], "title": "[USACO09MAR] Look Up S", "background": null, "description": "约翰的 $N(1\\le N\\le10^5)$ 头奶牛站成一排，奶牛 $i$ 的身高是 $H_i(1\\le H_i\\le10^6)$。现在，每只奶牛都在向右看。对于奶牛 $i$，如果奶牛 $j$ 满足 $i<j$ 且 $H_i<H_j$，我们可以说奶牛 $i$ 可以仰望奶牛 $j$。 求出每只奶牛离她最近的仰望对象。", "inputFormat": "第 $1$ 行输入 $N$，之后 $N$ 行第 $i+1$ 行输入一个身高 $H_i$。", "outputFormat": "共 $N$ 行，按顺序每行输出一只奶牛的最近仰望对象，如果没有仰望对象，输出 $0$。", "hint": "**【输入说明】**\n\n$6$ 头奶牛的身高分别为 $3$, $2$, $6$, $1$, $1$, $2$。\n\n**【输出说明】**\n\n奶牛 $1,2$ 仰望奶牛 $3$，奶牛 $4,5$ 仰望奶牛 $6$，奶牛 $3$ 和 $6$ 没有仰望对象。\n\n**【数据规模】**\n\n对于 $20\\%$ 的数据：$1\\le N\\le10$；\n\n对于 $50\\%$ 的数据：$1\\le N\\le10^3$；\n\n对于 $100\\%$ 的数据：$1\\le N\\le10^5,1\\le H_i\\le10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09MAR] Look Up S", "background": null, "description": "Farmer John's $N(1 \\le N \\le 10^5)$ cows, conveniently numbered $1$ to $N$, are once again standing in a row. Cow $i$ has height $H_i(1 \\le H_i \\le 10^6)$.\n\nEach cow is looking to her right toward those with higher index numbers. We say that cow $i$ \"looks up to\" cow $j$ if $i < j$ and $H_i < H_j$. For each cow $i$, FJ would like to know the index of the first cow in line \"looked up to\" by cow $i$.\n\nNote: about $50\\%$ of the test data will have $N \\le 10^3$.", "inputFormat": "Line $1$ : A single integer: $N$.\n\nLines $2$ to $N+1$ : Line $i+1$ contains the single integer: $H_i$.", "outputFormat": "Lines $1$ to $N$: Line $i$ contains a single integer representing the smallest index of a cow up to which cow $i$ looks. If no such cow exists, print $0$.", "hint": "FJ has six cows of heights $3$, $2$, $6$, $1$, $1$, and $2$.\n\n\nCows $1$ and $2$ both look up to cow $3$; cows $4$ and $5$ both look up to cow $6$. Cows $3$ and $6$ do not look up to any cow.", "locale": "en"}, "zh-CN": {"title": "[USACO09MAR] Look Up S", "background": null, "description": "约翰的 $N(1\\le N\\le10^5)$ 头奶牛站成一排，奶牛 $i$ 的身高是 $H_i(1\\le H_i\\le10^6)$。现在，每只奶牛都在向右看。对于奶牛 $i$，如果奶牛 $j$ 满足 $i<j$ 且 $H_i<H_j$，我们可以说奶牛 $i$ 可以仰望奶牛 $j$。 求出每只奶牛离她最近的仰望对象。", "inputFormat": "第 $1$ 行输入 $N$，之后 $N$ 行第 $i+1$ 行输入一个身高 $H_i$。", "outputFormat": "共 $N$ 行，按顺序每行输出一只奶牛的最近仰望对象，如果没有仰望对象，输出 $0$。", "hint": "**【输入说明】**\n\n$6$ 头奶牛的身高分别为 $3$, $2$, $6$, $1$, $1$, $2$。\n\n**【输出说明】**\n\n奶牛 $1,2$ 仰望奶牛 $3$，奶牛 $4,5$ 仰望奶牛 $6$，奶牛 $3$ 和 $6$ 没有仰望对象。\n\n**【数据规模】**\n\n对于 $20\\%$ 的数据：$1\\le N\\le10$；\n\n对于 $50\\%$ 的数据：$1\\le N\\le10^3$；\n\n对于 $100\\%$ 的数据：$1\\le N\\le10^5,1\\le H_i\\le10^6$。", "locale": "zh-CN"}}}
{"pid": "P2948", "type": "P", "difficulty": 5, "samples": [["10 1 2 \n3 2 5 \n4 1 \n1 3 \n", "6 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2009", "USACO", "枚举"], "title": "[USACO09OPEN] Ski Lessons G", "background": "", "description": "Farmer John wants to take Bessie skiing in Colorado. Sadly, Bessie is not really a very good skier.\n\nBessie has learned that the ski resort is offering S (0 <= S <= 100) ski classes throughout the day. Lesson i starts at time M\\_i (1 <= M\\_i <= 10,000) and lasts for time L\\_i (1 <= L\\_i <= 10,000). After lesson i, Bessie's ski ability becomes A\\_i (1 <= A\\_i <= 100). Note: this ability is an absolute, not an incremental change.\n\nBessie has purchased a map which shows all N (1 <= N <= 10,000) ski slopes along with the time D\\_i (1 <= D\\_i <= 10,000) required to ski down slope i and the skill level C\\_i (1 <= C\\_i <= 100) required to get down the slope safely. Bessie's skill level must be greater than or equal to the skill level of the slope in order for her to ski down it.\n\nBessie can devote her time to skiing, taking lessons, or sipping hot cocoa but must leave the ski resort by time T (1 <= T <= 10,000), and that means she must complete the descent of her last slope without exceeding that time limit.\n\nFind the maximum number of runs Bessie can complete within the time limit. She starts the day at skill level 1.\n\nExtra feedback will be provided on the first 50 submissions.\n\n", "inputFormat": "\\* Line 1: Three space-separated integers: T, S, and N\n\n\\* Lines 2..S+1: Line i+1 describes ski lesson i with three\n\nspace-separated integers: M\\_i, L\\_i, and A\\_i\n\n\\* Lines S+2..S+N+1: Line S+i+1 describes ski slope i with two\n\nspace-separated integers: C\\_i and D\\_i.\n", "outputFormat": "A single integer on a line by itself, the maximum number of runs that Bessie may ski within the time limit.\n", "hint": "Ski the second slope once, take the lesson, and ski the first slope 5 times before time is up: a total of 6 slopes.\n", "locale": "en", "translations": {"en": {"title": "[USACO09OPEN] Ski Lessons G", "background": "", "description": "Farmer John wants to take Bessie skiing in Colorado. Sadly, Bessie is not really a very good skier.\n\nBessie has learned that the ski resort is offering S (0 <= S <= 100) ski classes throughout the day. Lesson i starts at time M\\_i (1 <= M\\_i <= 10,000) and lasts for time L\\_i (1 <= L\\_i <= 10,000). After lesson i, Bessie's ski ability becomes A\\_i (1 <= A\\_i <= 100). Note: this ability is an absolute, not an incremental change.\n\nBessie has purchased a map which shows all N (1 <= N <= 10,000) ski slopes along with the time D\\_i (1 <= D\\_i <= 10,000) required to ski down slope i and the skill level C\\_i (1 <= C\\_i <= 100) required to get down the slope safely. Bessie's skill level must be greater than or equal to the skill level of the slope in order for her to ski down it.\n\nBessie can devote her time to skiing, taking lessons, or sipping hot cocoa but must leave the ski resort by time T (1 <= T <= 10,000), and that means she must complete the descent of her last slope without exceeding that time limit.\n\nFind the maximum number of runs Bessie can complete within the time limit. She starts the day at skill level 1.\n\nExtra feedback will be provided on the first 50 submissions.\n\n", "inputFormat": "\\* Line 1: Three space-separated integers: T, S, and N\n\n\\* Lines 2..S+1: Line i+1 describes ski lesson i with three\n\nspace-separated integers: M\\_i, L\\_i, and A\\_i\n\n\\* Lines S+2..S+N+1: Line S+i+1 describes ski slope i with two\n\nspace-separated integers: C\\_i and D\\_i.\n", "outputFormat": "A single integer on a line by itself, the maximum number of runs that Bessie may ski within the time limit.\n", "hint": "Ski the second slope once, take the lesson, and ski the first slope 5 times before time is up: a total of 6 slopes.\n", "locale": "en"}, "zh-CN": {"title": "[USACO09OPEN] Ski Lessons G", "background": null, "description": "农夫约翰想带贝西去科罗拉多滑雪。不幸的是，贝西滑雪技术并不是很好。\n\n贝西了解到滑雪场全天提供 $S (0 \\le S \\le 100)$ 节滑雪课。第 $i$ 节课从时间 $M\\_i (1 \\le M\\_i \\le 10,000)$ 开始，持续时间为 $L_i (1 \\le L_i \\le 10,000)$。在第 i 节课后，贝西的滑雪能力变为 $A_i (1 \\le A_i \\le 100)$。注意：这种能力是绝对值变化，而不是增量变化。\n\n贝西购买了一张地图，上面显示了所有 $N (1 \\le N \\le 10,000)$ 条滑雪道，以及滑下第 i 条滑雪道所需的时间 $D_i (1 \\le D_i \\le 10,000)$ 和安全滑下该滑雪道所需的技能水平 $C_i (1 \\le C_i \\le 100)$。贝西的技能水平必须大于或等于滑雪道的技能水平，才能安全滑下。\n\n贝西可以把时间花在滑雪、上课或喝热可可上，但必须在时间 $T (1 \\le T \\le 10,000)$ 前离开滑雪场，这意味着她必须在不超过该时间限制的情况下完成她最后一条滑雪道的滑行。\n\n找出贝西在时间限制内可以完成的最大滑雪次数。她一天开始时的技能水平为 $1$。", "inputFormat": "- 第 $1$ 行：三个用空格分隔的整数：$T$、$S$ 和 $N$。\n\n- 第 $2$ 行到第 $S+1$ 行：第 $i+1$ 行描述第 $i$ 节滑雪课，包含三个用空格分隔的整数：$M_i、L_i 和 A_i$。\n\n- 第 $S+2$ 行到第 $S+N+1$ 行：第 $S+i+1$ 行描述第 $i$ 条滑雪道，包含两个用空格分隔的整数：$C_i$ 和 $D_i$。", "outputFormat": "单独一行上的一个整数，表示贝西在时间限制内可以滑的最大次数。", "hint": "滑第二条滑雪道一次，上课，然后在时间用完前滑第一条滑雪道 $5$ 次：总共 $6$ 条滑雪道。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2949", "type": "P", "difficulty": 5, "samples": [["3 \n2 10 \n1 5 \n1 7 \n", "17 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "递推", "2009", "USACO", "优先队列", "反悔贪心"], "title": "[USACO09OPEN] Work Scheduling G", "background": "", "description": "Farmer John has so very many jobs to do! In order to run the farm efficiently, he must make money on the jobs he does, each one of which takes just one time unit.\n\nHis work day starts at time 0 and has 1,000,000,000 time units (!).  He currently can choose from any of N (1 <= N <= 100,000) jobs\n\nconveniently numbered 1..N for work to do. It is possible but\n\nextremely unlikely that he has time for all N jobs since he can only work on one job during any time unit and the deadlines tend to fall so that he can not perform all the tasks.\n\nJob i has deadline D\\_i (1 <= D\\_i <= 1,000,000,000). If he finishes job i by then, he makes a profit of P\\_i (1 <= P\\_i <= 1,000,000,000).\n\nWhat is the maximum total profit that FJ can earn from a given list of jobs and deadlines?  The answer might not fit into a 32-bit integer.\n\n\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: D\\_i and P\\_i\n", "outputFormat": "\\* Line 1: A single number on a line by itself that is the maximum possible profit FJ can earn.\n", "hint": "Complete job 3 (1,7) at time 1 and complete job 1 (2,10) at time 2 to maximize the earnings (7 + 10 -> 17).\n", "locale": "en", "translations": {"en": {"title": "[USACO09OPEN] Work Scheduling G", "background": "", "description": "Farmer John has so very many jobs to do! In order to run the farm efficiently, he must make money on the jobs he does, each one of which takes just one time unit.\n\nHis work day starts at time 0 and has 1,000,000,000 time units (!).  He currently can choose from any of N (1 <= N <= 100,000) jobs\n\nconveniently numbered 1..N for work to do. It is possible but\n\nextremely unlikely that he has time for all N jobs since he can only work on one job during any time unit and the deadlines tend to fall so that he can not perform all the tasks.\n\nJob i has deadline D\\_i (1 <= D\\_i <= 1,000,000,000). If he finishes job i by then, he makes a profit of P\\_i (1 <= P\\_i <= 1,000,000,000).\n\nWhat is the maximum total profit that FJ can earn from a given list of jobs and deadlines?  The answer might not fit into a 32-bit integer.\n\n\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: D\\_i and P\\_i\n", "outputFormat": "\\* Line 1: A single number on a line by itself that is the maximum possible profit FJ can earn.\n", "hint": "Complete job 3 (1,7) at time 1 and complete job 1 (2,10) at time 2 to maximize the earnings (7 + 10 -> 17).\n", "locale": "en"}, "zh-CN": {"title": "[USACO09OPEN] Work Scheduling G", "background": null, "description": "农夫约翰有很多工作要做！为了高效地经营农场，他必须从他所做的每一项工作中赚取利润，每项工作只需要一个时间单位。\n\n他的工作日从时间 $0$ 开始，总共有 $10^9$ 个时间单位。他目前可以从 $N$ ($1 \\leq N \\leq 10^5$) 项工作中选择要做的工作，这些工作被方便地编号为 $1$ 到 $N$。\n\n虽然理论上他有可能完成所有 $N$ 项工作，但实际上这是极不可能的，因为他在任何一个时间单位内只能完成一项工作，而截止日期通常会导致他无法完成所有任务。\n\n第 $i$ 项工作的截止时间为 $D_i$ ($1 \\leq D_i \\leq 10^9$)。如果他在截止时间前完成第 $i$ 项工作（如果当前时间为 $t$，那么仅当 $D_i > t$ 的时候他能做这个任务，完成后 $t \\rightarrow t+1$），他将获得 $P_i$ ($1 \\leq P_i \\leq 10^9$) 的利润。\n\n给定一系列工作和截止日期，FJ 能够获得的最大总利润是多少？答案可能无法容纳在 $32$ 位整数中。", "inputFormat": "第一行输入一个整数 $N$，意义见题目描述。\n\n第二行到第 $N+1$ 行：第 $i+1$ 行包含两个用空格分隔的整数：$D_i$ 和 $P_i$", "outputFormat": "只有一个数字，表示 FJ 能够获得的最大利润。", "hint": "在时间 $1$ 完成工作 $3$ $\\left(1,7\\right)$，在时间 $2$ 完成工作 $1$ $\\left(2,10\\right)$ 以最大化收益，最后收益为 $7+10=17$。\n\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2950", "type": "P", "difficulty": 5, "samples": [["2 1 \n1 0 0 \n0 1 0 \n", "1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2009", "USACO", "单调队列"], "title": "[USACO09OPEN] Bovine Embroidery G", "background": "", "description": "Bessie has taken up the detailed art of bovine embroidery. Cows embroider a cloth mounted in a circular hoop of integer radius d (1 <= d <= 50,000). They sew N (2 <= N <= 50,000) threads, each in a straight line from one point on the edge of the hoop to another point on the edge of the hoop (no two embroidered points share a location on the hoop's edge).\n\nBeing mathematically inclined, Bessie knows a formula of the form ax + by + c = 0 for each straight line piece of thread. Conveniently, a, b, and c are integers (-1,000,000 <= a <= 1,000,000; -1,000,000 <= b <= 1,000,000; -1,000,000 <= c <= 1,000,000). Even more\n\nconveniently, no two threads coincide exactly.\n\nPerhaps less conveniently, Bessie knows that her set of formula coefficients also includes a number of formulae for threads that do not appear to pass inside the hoop's circle. She regrets this greatly.\n\nThe origin (0,0) is in the precise middle of the hoop, so all points on the hoop's edge are distance d from the origin. At least one of the coefficients a and b is non-zero for each thread's formula.\n\nBovine embroidery is more highly regarded when the number of thread intersections is maximized. Help Bessie: count the number of pairs of threads that intersect on the cloth (i.e., within distance d of the origin). Note that if three threads happen to coincide at the same point, that would be three pairs of intersections. Four threads at the same point -> six pairs of intersections, etc.\n\nBessie学会了刺绣这种精细的工作。牛们在一片半径为d(1 <= d <= 50000)的圆形布上绣花. 它们一共绣了N (2 <= N <= 50000)条直线，每条直线连接布的边缘上的两个点(没有两条线通过边上同一个点)。\n\n作为一只热爱数学的牛，Bessie 知道每条线的公式, ax + by + c = 0. a, b, 和 c 为整数(-1000000 <= a <= 1000000; -1000000 <= b <= 1000000; -1000000 <= c <= 1000000).没有两条线完全重合。\n\n不幸的是, 一部分线不通过圆布的内部. 原点(0,0)在布的正中央, 所有边上的点离原点距离为d. 每条线的公式满足至少a,b中的一个非零. 对于牛来说，刺绣作品中线的交点越多，便越有价值。帮助Bessie计算在圆中相交的线的对数，也就是说交点与原点的距离小于d。注意如果三条线在圆内同一点相交,这算3对线。4线共点->6对线.\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and d\n\n\\* Lines 2..N+1: Line i+1 describes thread i with three integers: a, b, and c\n", "outputFormat": "\\* Line 1: One integer, on a line by itself, that is the count of pairs of threads that intersect.\n", "hint": "The two lines are x=0 and y=0. \n\nThe two lines intersect at (0,0), which is clearly with 1 of the origin. \n\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09OPEN] Bovine Embroidery G", "background": "", "description": "Bessie has taken up the detailed art of bovine embroidery. Cows embroider a cloth mounted in a circular hoop of integer radius $d$ ($1 \\le d \\le 50000$). They sew $N$ ($2 \\le N \\le 50000$) straight threads, each from one point on the edge of the hoop to another point on the edge (no two embroidered points share a location on the hoop's edge).\n\nBeing mathematically inclined, Bessie knows a formula of the form $ax + by + c = 0$ for each straight thread. Conveniently, $a$, $b$, and $c$ are integers ($-1000000 \\le a \\le 1000000$, $-1000000 \\le b \\le 1000000$, $-1000000 \\le c \\le 1000000$). Even more conveniently, no two threads coincide exactly. At least one of $a$ and $b$ is non-zero for each thread’s formula.\n\nPerhaps less conveniently, Bessie knows that her set of formula coefficients also includes some lines that do not pass through the interior of the hoop’s circle. The origin $(0, 0)$ is at the exact center of the hoop, so all points on the hoop’s edge are at distance $d$ from the origin.\n\nBovine embroidery is more highly regarded when the number of thread intersections is maximized. Help Bessie count the number of pairs of threads that intersect on the cloth, i.e., whose intersection point lies within distance $d$ of the origin. If $k$ threads meet at the same point inside the circle, they contribute $\\binom{k}{2}$ pairs (e.g., three threads give three pairs; four threads give six pairs).", "inputFormat": "- Line 1: Two space-separated integers $N$ and $d$.\n- Lines 2 to $N+1$: Line $i+1$ describes thread $i$ with three integers: $a$, $b$, and $c$.", "outputFormat": "- Line 1: One integer, the count of pairs of threads that intersect inside the circle of radius $d$.", "hint": "The two lines are $x = 0$ and $y = 0$. The two lines intersect at $(0, 0)$, which is clearly within distance $1$ of the origin.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09OPEN] Bovine Embroidery G", "background": "", "description": "Bessie has taken up the detailed art of bovine embroidery. Cows embroider a cloth mounted in a circular hoop of integer radius d (1 <= d <= 50,000). They sew N (2 <= N <= 50,000) threads, each in a straight line from one point on the edge of the hoop to another point on the edge of the hoop (no two embroidered points share a location on the hoop's edge).\n\nBeing mathematically inclined, Bessie knows a formula of the form ax + by + c = 0 for each straight line piece of thread. Conveniently, a, b, and c are integers (-1,000,000 <= a <= 1,000,000; -1,000,000 <= b <= 1,000,000; -1,000,000 <= c <= 1,000,000). Even more\n\nconveniently, no two threads coincide exactly.\n\nPerhaps less conveniently, Bessie knows that her set of formula coefficients also includes a number of formulae for threads that do not appear to pass inside the hoop's circle. She regrets this greatly.\n\nThe origin (0,0) is in the precise middle of the hoop, so all points on the hoop's edge are distance d from the origin. At least one of the coefficients a and b is non-zero for each thread's formula.\n\nBovine embroidery is more highly regarded when the number of thread intersections is maximized. Help Bessie: count the number of pairs of threads that intersect on the cloth (i.e., within distance d of the origin). Note that if three threads happen to coincide at the same point, that would be three pairs of intersections. Four threads at the same point -> six pairs of intersections, etc.\n\nBessie学会了刺绣这种精细的工作。牛们在一片半径为d(1 <= d <= 50000)的圆形布上绣花. 它们一共绣了N (2 <= N <= 50000)条直线，每条直线连接布的边缘上的两个点(没有两条线通过边上同一个点)。\n\n作为一只热爱数学的牛，Bessie 知道每条线的公式, ax + by + c = 0. a, b, 和 c 为整数(-1000000 <= a <= 1000000; -1000000 <= b <= 1000000; -1000000 <= c <= 1000000).没有两条线完全重合。\n\n不幸的是, 一部分线不通过圆布的内部. 原点(0,0)在布的正中央, 所有边上的点离原点距离为d. 每条线的公式满足至少a,b中的一个非零. 对于牛来说，刺绣作品中线的交点越多，便越有价值。帮助Bessie计算在圆中相交的线的对数，也就是说交点与原点的距离小于d。注意如果三条线在圆内同一点相交,这算3对线。4线共点->6对线.\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and d\n\n\\* Lines 2..N+1: Line i+1 describes thread i with three integers: a, b, and c\n", "outputFormat": "\\* Line 1: One integer, on a line by itself, that is the count of pairs of threads that intersect.\n", "hint": "The two lines are x=0 and y=0. \n\nThe two lines intersect at (0,0), which is clearly with 1 of the origin. \n\n", "locale": "zh-CN"}}}
{"pid": "P2951", "type": "P", "difficulty": 3, "samples": [["6 7 \n3 6 \n4 3 \n3 2 \n1 3 \n1 2 \n2 4 \n5 2 \n", "4 2 3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO", "最短路"], "title": "[USACO09OPEN] Hide and Seek S", "background": null, "description": "奶牛贝西和农夫约翰（FJ）玩捉迷藏，现在有 $N$ 个谷仓，FJ开始在第一个谷仓，贝西为了不让FJ找到她，当然要藏在距离第一个谷仓最远的那个谷仓了。现在告诉你 $N$ 个谷仓，和 $M$ 个两两谷仓间的“无向边”。每两个仓谷间当然会有最短路径，现在要求距离第一个谷仓（FJ那里）最远的谷仓是哪个（所谓最远就是距离第一个谷仓最大的最短路径）？如有多个则输出编号最小的。以及求这最远距离是多少，和有几个这样的谷仓距离第一个谷仓那么远。", "inputFormat": "第一行：两个整数 $N$，$M$；\n\n\n第 $2-M+1$ 行：每行两个整数，表示端点 $A_i$ 和 $B_i$ 间有一条无向边。", "outputFormat": "仅一行，三个整数，两两中间空格隔开。表示：距离第一个谷仓最远的谷仓编号（如有多个则输出编号最小的），以及最远的距离，和有几个谷仓距离第一个谷仓那么远。", "hint": "农场的布局如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2815.png) \n\n这里谷仓4，5，6距离1号谷仓都是2，但是4编号最小所以输出4.因此最远距离是2且有3个谷仓，依次输出：2和3。 \n\n$2\\le n\\le 50000,1\\le m\\le 50000$\n\n感谢 wjcwinmt 的贡献翻译", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09OPEN] Hide and Seek S", "background": null, "description": "Bessie is playing hide and seek (a game in which a number of players\nhide and a single player (the seeker) attempts to find them after\nwhich various penalties and rewards are assessed; much fun usually\nensues).\n\nShe is trying to figure out in which of N (2 <= N <= 20,000) barns\nconveniently numbered 1..N she should hide. She knows that FJ (the\nseeker) starts out in barn 1. All the barns are connected by M (1\n<= M <= 50,000) bidirectional paths with endpoints A_i and B_i (1\n<= A_i <= N; 1 <= B_i <= N; A_i != B_i); it is possible to reach\nany barn from any other through the paths.\n\nBessie decides that it will be safest to hide in the barn that has\nthe greatest distance from barn 1 (the distance between two barns\nis the smallest number of paths that one must traverse to get from\none to the other). Help Bessie figure out the best barn in which\nto hide.", "inputFormat": "* Line 1: Two space-separated integers: N and M\n\n* Lines 2..M+1: Line i+1 contains the endpoints for path i: A_i and\n        B_i", "outputFormat": "* Line 1: On a single line, print three space-separated integers: the\n        index of the barn farthest from barn 1 (if there are multiple\n        such barns, print the smallest such index), the smallest\n        number of paths needed to reach this barn from barn 1, and the\n        number of barns with this number of paths.", "hint": "The farm layout is as follows:\n\n                   1--2--5\n                   | /|\n                   |/ |\n                   3--4\n                   |\n                   6\n\nBarns 4, 5, and 6 are all a distance of 2 from barn 1. We choose barn 4\nbecause it has the smallest index.", "locale": "en"}, "zh-CN": {"title": "[USACO09OPEN] Hide and Seek S", "background": null, "description": "奶牛贝西和农夫约翰（FJ）玩捉迷藏，现在有 $N$ 个谷仓，FJ开始在第一个谷仓，贝西为了不让FJ找到她，当然要藏在距离第一个谷仓最远的那个谷仓了。现在告诉你 $N$ 个谷仓，和 $M$ 个两两谷仓间的“无向边”。每两个仓谷间当然会有最短路径，现在要求距离第一个谷仓（FJ那里）最远的谷仓是哪个（所谓最远就是距离第一个谷仓最大的最短路径）？如有多个则输出编号最小的。以及求这最远距离是多少，和有几个这样的谷仓距离第一个谷仓那么远。", "inputFormat": "第一行：两个整数 $N$，$M$；\n\n\n第 $2-M+1$ 行：每行两个整数，表示端点 $A_i$ 和 $B_i$ 间有一条无向边。", "outputFormat": "仅一行，三个整数，两两中间空格隔开。表示：距离第一个谷仓最远的谷仓编号（如有多个则输出编号最小的），以及最远的距离，和有几个谷仓距离第一个谷仓那么远。", "hint": "农场的布局如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2815.png) \n\n这里谷仓4，5，6距离1号谷仓都是2，但是4编号最小所以输出4.因此最远距离是2且有3个谷仓，依次输出：2和3。 \n\n$2\\le n\\le 50000,1\\le m\\le 50000$\n\n感谢 wjcwinmt 的贡献翻译", "locale": "zh-CN"}}}
{"pid": "P2952", "type": "P", "difficulty": 2, "samples": [["10 \nA L \nA L \nA R \nA L \nD R 2 \nA R \nA R \nD L 1 \nA L \nA R \n", "7 \n2 \n5 \n6 \n8 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "递推", "2009", "USACO", "队列"], "title": "[USACO09OPEN] Cow Line S", "background": "", "description": "Farmer John's N cows (conveniently numbered 1..N) are forming a line. The line begins with no cows and then, as time progresses, one by one, the cows join the line on the left or right side. Every once in a while, some number of cows on the left or right side of the line all leave the line to go graze in their favorite pasture.\n\nFJ has trouble keeping track of all the cows in the line. Please help him.\n\nThe cows enter the line in numerical order 1..N, and once a cow leaves the line she never re-enters it. Your program will be given S (1 <= S <= 100,000) input specifications; each appears on a single line and is one of two types:\n\n\\* A cow enters the line (a parameter indicates whether on the left or right).\n\n\\* K cows leave the line from the left or right side (supplied parameters define both the number of cows and which side).\n\nInput lines never request an operation that can not be performed.\n\nAfter all the input lines have been processed, your program should print the cows in the line in order from left to right. The final line is guaranteed to be non-empty at the end of the input specifications.", "inputFormat": "\\* Line 1: A single integer: S\n\n\\* Lines 2..S+1: Line i+1 contains specification i in one of four formats:\n\n\\* A L -- a cow arrives on the Left of the line\n\n\\* A R -- a cow arrives on the Right of the line\n\n\\* D L K -- K cows depart the Left side of the line\n\n\\* D R K -- K cows depart the Right side of the line", "outputFormat": "\\* Lines 1..??: Print the numbers of the cows in the line in order from left to right, one number per line.", "hint": "Input    Resulting Cow Line\n\nA L      1\n\nA L      2 1\n\nA R      2 1 3\n\nA L      4 2 1 3\n\nD R 2    4 2\n\nA R      4 2 5\n\nA R      4 2 5 6\n\nD L 1    2 5 6\n\nA L      7 2 5 6\n\nA R      7 2 5 6 8\n\n感谢@ ws\\_fuweidong  提供翻译。\n", "locale": "en", "translations": {"en": {"title": "[USACO09OPEN] Cow Line S", "background": "", "description": "Farmer John's N cows (conveniently numbered 1..N) are forming a line. The line begins with no cows and then, as time progresses, one by one, the cows join the line on the left or right side. Every once in a while, some number of cows on the left or right side of the line all leave the line to go graze in their favorite pasture.\n\nFJ has trouble keeping track of all the cows in the line. Please help him.\n\nThe cows enter the line in numerical order 1..N, and once a cow leaves the line she never re-enters it. Your program will be given S (1 <= S <= 100,000) input specifications; each appears on a single line and is one of two types:\n\n\\* A cow enters the line (a parameter indicates whether on the left or right).\n\n\\* K cows leave the line from the left or right side (supplied parameters define both the number of cows and which side).\n\nInput lines never request an operation that can not be performed.\n\nAfter all the input lines have been processed, your program should print the cows in the line in order from left to right. The final line is guaranteed to be non-empty at the end of the input specifications.", "inputFormat": "\\* Line 1: A single integer: S\n\n\\* Lines 2..S+1: Line i+1 contains specification i in one of four formats:\n\n\\* A L -- a cow arrives on the Left of the line\n\n\\* A R -- a cow arrives on the Right of the line\n\n\\* D L K -- K cows depart the Left side of the line\n\n\\* D R K -- K cows depart the Right side of the line", "outputFormat": "\\* Lines 1..??: Print the numbers of the cows in the line in order from left to right, one number per line.", "hint": "Input    Resulting Cow Line\n\nA L      1\n\nA L      2 1\n\nA R      2 1 3\n\nA L      4 2 1 3\n\nD R 2    4 2\n\nA R      4 2 5\n\nA R      4 2 5 6\n\nD L 1    2 5 6\n\nA L      7 2 5 6\n\nA R      7 2 5 6 8\n\n感谢@ ws\\_fuweidong  提供翻译。\n", "locale": "en"}, "zh-CN": {"title": "[USACO09OPEN] Cow Line S", "background": null, "description": "Farmer John（以下简称 FJ）的 $N$ 头奶牛（用 $1 \\dots N$ 编号）在直线上排队。一开始，这条线上没有任何奶牛，随着时间的推移，奶牛们会一个接一个地站到队伍的左边或右边。又过了一会儿，某些奶牛会从队伍里离开，去吃自己最喜欢的草料。\n\nFJ 无法跟踪每一头奶牛，于是，他想让你来帮助他。\n\n奶牛以 $1 \\dots N$ 的顺序排队，并且离开的奶牛不会再次回来。数据将会给出 $S$（$1 \\le S \\le 100000$） 条指令，各占一行，分两种：\n\n- $1$ 头奶牛加入了队列（还有一个参数，表示从左加入还是从右加入）；\n- $K$ 头奶牛从左边或者右边离开了队列（还有两个参数，分别表示从左离开还是从右离开和离开多少头奶牛）。\n\n输入的命令一定是可以执行的。\n\n所有的操作结束后，你的程序应该以从左到右的顺序输出这个奶牛队列。数据保证最后的队列不空。", "inputFormat": "- 第 $1$ 行：单独一个整数 $S$。\n- 第 $2 \\dots S+1$ 行：第 $i+1$ 行会有一条命令，有以下几种：\n  - `A L`：一头奶牛从队列左边加入；\n  - `A R`：一头奶牛从队列右边加入；\n  - `D L K`：$K$ 头奶牛从队伍左边离开；\n  - `D R K`：$K$ 头奶牛从队伍右边离开。", "outputFormat": "- 第 $1 \\dots ??$ 行：从左到右输出最后的奶牛队列，一个奶牛编号占一行。\n\n**【样例解释】**\n\n以下为输入的命令及对应的队列：\n\n- `A L`：$1$；\n- `A L`：$2,1$；\n- `A R`：$2,1,3$；\n- `A L`：$4,2,1,3$；\n- `D R 2`：$4,2$；\n- `A R`：$4,2,5$；\n- `A R`：$4,2,5,6$；\n- `D L 1`：$2,5,6$；\n- `A L`：$7,2,5,6$；\n- `A R`（最终序列）：$7,2,5,6,8$。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2953", "type": "P", "difficulty": 4, "samples": [["2 \n9 \n10 \n", "YES \nNO \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "动态规划 DP", "博弈论", "2009", "USACO", "SG 函数"], "title": "[USACO09OPEN] Cow Digit Game S", "background": null, "description": "贝茜和约翰在玩一个数字游戏。贝茜需要你帮助她。\n\n游戏一共进行了 $G(1\\le G\\le100)$ 场。第 $i$ 场游戏开始于一个正整数 $N_i(1\\le N_i\\le 1\\,000\\,000)$。\n\n游戏规则是这样的：双方轮流操作，将当前的数字减去一个数，这个数可以是当前数字的最大数码，也可以是最小的非 $0$ 数码。比如当前的数是 $3014$，操作者可以减去 $1$ 变成 $3013$，也可以减去 $4$ 变成 $3010$。若干次操作之后，这个数字会变成 $0$。这时候不能再操作的一方为输家。贝茜总是先开始操作。如果贝茜和约翰都足够聪明，执行最好的策略。请你计算最后的赢家。\n\n比如，一场游戏开始于 $13$。贝茜将 $13$ 减去 $3$ 变成 $10$。约翰只能将 $10$ 减去 $1$ 变成 $9$。贝茜再将 $9$ 减去 $9$ 变成 $0$。最后贝茜赢。", "inputFormat": "第一行一个整数 $G$。\n\n第 $2$ 到第 $G+1$ 行，每行一个整数 $N_i$。", "outputFormat": "输出 $G$ 行，每行表示对于每个 $N_i$，若贝茜能赢则输出 `YES` 否则输出 `NO`。", "hint": "在第一个游戏中，贝茜只需减去 $9$ 便能胜利。在第二个游戏中，贝茜只能减去 $1$（因为她不能减去 $0$），然后农夫约翰只需减去减去 $9$ 便能胜利。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09OPEN] Cow Digit Game S", "background": "", "description": "Bessie is playing a number game against Farmer John, and she wants you to help her win.\n\nGame $i$ starts with an integer $N_i$ ($1 \\le N_i \\le 1{,}000{,}000$). Bessie goes first, and then the two players alternate turns. On each turn, a player can subtract from the current number either its largest digit or its smallest nonzero digit to obtain a new number. For example, from $3014$ we may subtract either $1$ or $4$ to obtain either $3013$ or $3010$, respectively. The game continues until the number becomes $0$, at which point the last player to have taken a turn is the winner.\n\nBessie and FJ play $G$ ($1 \\le G \\le 100$) games. Determine, for each game, whether Bessie or FJ will win, assuming both play optimally (that is, on each turn, if the current player has a move that guarantees a win, they will take it).\n\nConsider a sample game where $N_i = 13$. Bessie goes first and takes $3$, leaving $10$. FJ is forced to take $1$, leaving $9$. Bessie takes the remainder and wins the game.", "inputFormat": "* Line 1: A single integer $G$.\n* Lines 2..$G+1$: Line $i+1$ contains the single integer $N_i$.", "outputFormat": "* Lines 1..$G$: Line $i$ contains 'YES' if Bessie can win game $i$, and 'NO' otherwise.", "hint": "For the first game, Bessie simply takes the number $9$ and wins. For the second game, Bessie must take $1$ (since she cannot take $0$), and then FJ can win by taking $9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09OPEN] Cow Digit Game S", "background": null, "description": "贝茜和约翰在玩一个数字游戏。贝茜需要你帮助她。\n\n游戏一共进行了 $G(1\\le G\\le100)$ 场。第 $i$ 场游戏开始于一个正整数 $N_i(1\\le N_i\\le 1\\,000\\,000)$。\n\n游戏规则是这样的：双方轮流操作，将当前的数字减去一个数，这个数可以是当前数字的最大数码，也可以是最小的非 $0$ 数码。比如当前的数是 $3014$，操作者可以减去 $1$ 变成 $3013$，也可以减去 $4$ 变成 $3010$。若干次操作之后，这个数字会变成 $0$。这时候不能再操作的一方为输家。贝茜总是先开始操作。如果贝茜和约翰都足够聪明，执行最好的策略。请你计算最后的赢家。\n\n比如，一场游戏开始于 $13$。贝茜将 $13$ 减去 $3$ 变成 $10$。约翰只能将 $10$ 减去 $1$ 变成 $9$。贝茜再将 $9$ 减去 $9$ 变成 $0$。最后贝茜赢。", "inputFormat": "第一行一个整数 $G$。\n\n第 $2$ 到第 $G+1$ 行，每行一个整数 $N_i$。", "outputFormat": "输出 $G$ 行，每行表示对于每个 $N_i$，若贝茜能赢则输出 `YES` 否则输出 `NO`。", "hint": "在第一个游戏中，贝茜只需减去 $9$ 便能胜利。在第二个游戏中，贝茜只能减去 $1$（因为她不能减去 $0$），然后农夫约翰只需减去减去 $9$ 便能胜利。", "locale": "zh-CN"}}}
{"pid": "P2954", "type": "P", "difficulty": 4, "samples": [["5 10 \n2 \n8 \n1 \n3 \n9 \n", "4 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2009", "USACO", "单调队列"], "title": "[USACO09OPEN] Grazing2 S", "background": "", "description": "Farmer John has N (2 <= N <= 1,500) prize milk cows conveniently numbered 1..N. His newly-painted barn has S (N <= S <= 1,000,000) stalls (conveniently numbered 1..S) in a single long line; each stall is a unit distance from its neighboring stall(s).\n\nThe cows have made their way to the stalls for a rest; cow i is in stall P\\_i. Antisocial as they are, the cows get grumpy if they are situated in stalls very close to each other, so Farmer John wants to move the cows to be as spread out as possible.\n\nFJ wants to make sure that the N - 1 distances between adjacent cows are as large as possible, and he would also like them to be similar to each other (i.e., close to equi-distant spacing).\n\nIn particular, FJ would like all distances between adjacent cows to be at most 1 different from (S - 1) / (N - 1), where integer division is used. Moreover, he would like as many of these distances as possible to be exactly equal to (S - 1) / (N - 1) [integer\n\ndivision]. Thus, with four cows and eight stalls, one can place the cows at positions 1, 3, 5, 8 or 1, 3, 6, 8 but not at 1, 2, 4, 7 or 1, 2, 4, 8.\n\nHelp FJ spread the cows as efficiently as possible by calculating and reporting the minimum total distance that the cows have to move in order to achieve proper spacing. Ignore the distance it takes for a cow to enter or exit a stall.\n\n约翰有N(2≤N≤1500)头奶牛，S(N≤S≤1,000,000)个一字排开的牛棚．相邻牛棚间的距离恰好为1．\n\n奶牛们已经回棚休息，第i只奶牛现在待在牛棚Pi．如果两只奶牛离得太近，会让奶牛们变得很暴躁．所以约翰想给一些奶牛换一个棚，让她们之间的距离变得尽量大，并且尽管接近．令d=Trunc((s-1)/(n-1))\n\n所以约翰希望最终的奶牛的状态是：两只相邻奶牛间的距离与d之差不超过1，而且让尽量多的间距等于d．因此，对于4只奶牛8个棚的情况，1，3，5，8或1，3，6，8这样的安置情况是允许的，而1，2，4，7或1，2，4，8这样的情况是不允许的．    帮助约翰移动奶牛，让所有奶牛的移动距离之和最小，同时让最终的安置情况符合约翰心意．\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and S\n\n\\* Lines 2..N+1: Line i+1 contains the single integer: P\\_i\n", "outputFormat": "\\* Line 1: A single integer: the minimum total distance the cows have to travel. This number is guaranteed to be under 1,000,000,000 (thus fitting easily into a signed 32-bit integer).\n", "hint": "1   2   3   4   5   6   7   8   9  10\n\nCow Locs     | A | B | C | . | . | . | . | D | E | . | \n\nCows move from stall 2 to 3, 3 to 5, and 9 to 10. The total distance moved is 1 + 2 + 1 = 4. The final positions of the cows are in stalls 1, 3, 5, 8, and 10.\n\n1   2   3   4   5   6   7   8   9  10\n\nInit Stall     | A | B | C | . | . | . | . | D | E | . | \nFinal Stall    | A | . | B | . | C | . | . | D | . | E | \nDistance moved | 0 | . | 1 | . | 2 | . | . | 0 | . | 1 | ", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09OPEN] Grazing2 S", "background": "", "description": "Farmer John has $N$ cows, numbered $1..N$, where $2 \\le N \\le 1500$. His newly painted barn has $S$ stalls in a single line, numbered $1..S$, where $N \\le S \\le 1{,}000{,}000$. Each pair of adjacent stalls is at distance $1$.\n\nThe cows have already gone to rest; cow $i$ is currently in stall $P_i$. Since cows get grumpy when they are too close together, Farmer John wants to move them so they are as spread out as possible and with similar gaps.\n\nLet $d = \\left\\lfloor \\frac{S - 1}{N - 1} \\right\\rfloor$ (integer division). Farmer John wants the $N - 1$ distances between adjacent cows to each differ from $d$ by at most $1$, and he also wants to maximize the number of these distances that are exactly equal to $d$.\n\nFor example, with $4$ cows and $8$ stalls, placements $1, 3, 5, 8$ and $1, 3, 6, 8$ are allowed, but $1, 2, 4, 7$ and $1, 2, 4, 8$ are not allowed.\n\nHelp Farmer John spread the cows as efficiently as possible by computing the minimum total distance the cows must move to achieve such spacing. Ignore the distance for entering or leaving a stall.", "inputFormat": "- Line 1: Two space-separated integers $N$ and $S$.\n- Lines $2..N+1$: Line $i+1$ contains a single integer $P_i$.", "outputFormat": "- Line 1: A single integer — the minimum total distance the cows must travel. This value is guaranteed to be less than $1{,}000{,}000{,}000$.", "hint": "1   2   3   4   5   6   7   8   9  10\nCow Locs     | A | B | C | . | . | . | . | D | E | . |\n\nCows move from stall 2 to 3, 3 to 5, and 9 to 10. The total distance moved is 1 + 2 + 1 = 4. The final positions of the cows are in stalls 1, 3, 5, 8, and 10.\n\n1   2   3   4   5   6   7   8   9  10\nInit Stall     | A | B | C | . | . | . | . | D | E | . |\nFinal Stall    | A | . | B | . | C | . | . | D | . | E |\nDistance moved | 0 | . | 1 | . | 2 | . | . | 0 | . | 1 |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09OPEN] Grazing2 S", "background": "", "description": "Farmer John has N (2 <= N <= 1,500) prize milk cows conveniently numbered 1..N. His newly-painted barn has S (N <= S <= 1,000,000) stalls (conveniently numbered 1..S) in a single long line; each stall is a unit distance from its neighboring stall(s).\n\nThe cows have made their way to the stalls for a rest; cow i is in stall P\\_i. Antisocial as they are, the cows get grumpy if they are situated in stalls very close to each other, so Farmer John wants to move the cows to be as spread out as possible.\n\nFJ wants to make sure that the N - 1 distances between adjacent cows are as large as possible, and he would also like them to be similar to each other (i.e., close to equi-distant spacing).\n\nIn particular, FJ would like all distances between adjacent cows to be at most 1 different from (S - 1) / (N - 1), where integer division is used. Moreover, he would like as many of these distances as possible to be exactly equal to (S - 1) / (N - 1) [integer\n\ndivision]. Thus, with four cows and eight stalls, one can place the cows at positions 1, 3, 5, 8 or 1, 3, 6, 8 but not at 1, 2, 4, 7 or 1, 2, 4, 8.\n\nHelp FJ spread the cows as efficiently as possible by calculating and reporting the minimum total distance that the cows have to move in order to achieve proper spacing. Ignore the distance it takes for a cow to enter or exit a stall.\n\n约翰有N(2≤N≤1500)头奶牛，S(N≤S≤1,000,000)个一字排开的牛棚．相邻牛棚间的距离恰好为1．\n\n奶牛们已经回棚休息，第i只奶牛现在待在牛棚Pi．如果两只奶牛离得太近，会让奶牛们变得很暴躁．所以约翰想给一些奶牛换一个棚，让她们之间的距离变得尽量大，并且尽管接近．令d=Trunc((s-1)/(n-1))\n\n所以约翰希望最终的奶牛的状态是：两只相邻奶牛间的距离与d之差不超过1，而且让尽量多的间距等于d．因此，对于4只奶牛8个棚的情况，1，3，5，8或1，3，6，8这样的安置情况是允许的，而1，2，4，7或1，2，4，8这样的情况是不允许的．    帮助约翰移动奶牛，让所有奶牛的移动距离之和最小，同时让最终的安置情况符合约翰心意．\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and S\n\n\\* Lines 2..N+1: Line i+1 contains the single integer: P\\_i\n", "outputFormat": "\\* Line 1: A single integer: the minimum total distance the cows have to travel. This number is guaranteed to be under 1,000,000,000 (thus fitting easily into a signed 32-bit integer).\n", "hint": "1   2   3   4   5   6   7   8   9  10\n\nCow Locs     | A | B | C | . | . | . | . | D | E | . | \n\nCows move from stall 2 to 3, 3 to 5, and 9 to 10. The total distance moved is 1 + 2 + 1 = 4. The final positions of the cows are in stalls 1, 3, 5, 8, and 10.\n\n1   2   3   4   5   6   7   8   9  10\n\nInit Stall     | A | B | C | . | . | . | . | D | E | . | \nFinal Stall    | A | . | B | . | C | . | . | D | . | E | \nDistance moved | 0 | . | 1 | . | 2 | . | . | 0 | . | 1 | ", "locale": "zh-CN"}}}
{"pid": "P2955", "type": "P", "difficulty": 1, "samples": [["2 \n1024 \n5931 \n", "even \nodd \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09OCT] Even? Odd? G", "background": null, "description": "Bessie那惨无人道的二年级老师搞了一个有 $N$ 个正整数 $I$ 的表叫Bessie去判断“奇偶性”（这个词语意思向二年级的学生解释，就是“这个数是单数，还是双数啊？”）。Bessie被那个表的长度深深地震惊到了，竟然跟栋栋的泛做表格一样多道题！！！毕竟她才刚刚学会数数啊。\n\n写一个程序读入 $N$ 个整数，如果是双数，那么在单立的一行内输出 `even`，如果是单数则类似地输出 `odd`。", "inputFormat": "第一行：一个整数 $N$\n\n接下来 $N$ 行：第 $j$ 行一个整数 $l_j$，表示用于确定奇数或偶数的第 $j$ 个整数", "outputFormat": "一共 $N$ 行：第 $j$ 行包含单词 `even` 或 `odd` ，具体取决于 $l_j$ 的奇偶性", "hint": "**【样例解释】**\n\n两个整数：$1024\\text{ 和 }5931$\n\n$1024$ 可被 $2$ 整除，$5931$ 不能\n\n**【数据范围】**\n\n$1\\le N \\le 100，1\\le l_j \\le 10^{60}$", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09OCT] Even? Odd? G", "background": "", "description": "Bessie's ruthless second-grade teacher gave her a list with $N$ positive integers $I$ and asked her to determine their \"parity\" (explained to a second grader as \"is the number odd or even?\"). Bessie was shocked by how long the list was—there were as many items as on Dongdong's repetitive worksheets! After all, she has only just learned to count.\n\nWrite a program that reads $N$ integers. If a number is even, output `even` on a separate line; if it is odd, similarly output `odd`.", "inputFormat": "The first line contains an integer $N$.\n\nThe next $N$ lines: the $j$-th line contains an integer $l_j$, which is the $j$-th integer to determine as odd or even.", "outputFormat": "A total of $N$ lines: the $j$-th line contains the word `even` or `odd`, depending on the parity of $l_j$.", "hint": "Sample Explanation:\n\nTwo integers: $1024\\text{ 和 }5931$.\n\n$1024$ is divisible by $2$, $5931$ is not.\n\nConstraints:\n\n$1\\le N \\le 100，1\\le l_j \\le 10^{60}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09OCT] Even? Odd? G", "background": null, "description": "Bessie那惨无人道的二年级老师搞了一个有 $N$ 个正整数 $I$ 的表叫Bessie去判断“奇偶性”（这个词语意思向二年级的学生解释，就是“这个数是单数，还是双数啊？”）。Bessie被那个表的长度深深地震惊到了，竟然跟栋栋的泛做表格一样多道题！！！毕竟她才刚刚学会数数啊。\n\n写一个程序读入 $N$ 个整数，如果是双数，那么在单立的一行内输出 `even`，如果是单数则类似地输出 `odd`。", "inputFormat": "第一行：一个整数 $N$\n\n接下来 $N$ 行：第 $j$ 行一个整数 $l_j$，表示用于确定奇数或偶数的第 $j$ 个整数", "outputFormat": "一共 $N$ 行：第 $j$ 行包含单词 `even` 或 `odd` ，具体取决于 $l_j$ 的奇偶性", "hint": "**【样例解释】**\n\n两个整数：$1024\\text{ 和 }5931$\n\n$1024$ 可被 $2$ 整除，$5931$ 不能\n\n**【数据范围】**\n\n$1\\le N \\le 100，1\\le l_j \\le 10^{60}$", "locale": "zh-CN"}}}
{"pid": "P2956", "type": "P", "difficulty": 1, "samples": [["6 4 2 \n1 1 2 4 \n1 3 5 4 \n", "14 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09OCT] The Robot Plow G", "background": null, "description": "农夫约翰购买了一台新的自动耕地机器人，以将自己从日复一日犁地的繁重劳动中解脱出来。这台机器人确实能完成耕地任务，但有一个小缺点：它只能犁出各边长度均为整数的完美矩形地块。\n\n由于约翰的田地中分布着树木和其他障碍物，他需要设定机器人犁耕多个不同的矩形区域，这些区域可能会有重叠。他很好奇，在按照各种耕地指令（每个指令通过给出矩形的左下角和右上角 x、y 坐标来描述）编程后，田地里实际被犁过的方格数量究竟有多少。\n\n和往常一样，田地被划分为若干方格，这些方格的边与 x 轴和 y 轴平行。整块田地的宽度为 $X$ 个方格，高度为 $Y$ 个方格 $1\\le X,Y \\le 240)$。共有 $I$ 条耕地指令 $(1\\le I \\le 200)$，每条指令包含四个整数：$Xll、Yll、Xur \\text{ 和 } Yur\\text{ (}1 \\le Xll \\le Xur \\le X;1 \\le Yll \\le Yur \\le Y）$，分别表示待犁矩形的左下角和右上角坐标。机器人会犁耕区间 $(Xll \\dots Xur, Yll \\dots Yur)$ 内的所有田地方格——根据不同的理解方式，这个区间可能比初始设想的多一行或一列（当然，具体取决于你如何理解）。\n\n以一块宽 6 格、高 4 格的田地为例。当约翰发出两条耕地指令（如下所示）时，田地的犁耕情况如 `*` 和 `#` 所示（通常犁过的田地看起来相同，这里用 `#` 表示最近犁过的区域）：\n\n```\n......             **....             #####. \n......  (1,1)(2,4) **....  (1,3)(5,4) #####. \n......             **....             **.... \n......             **....             **....\n```\n最终共有 14 个方格被犁过。\n\n得分：25 分", "inputFormat": "共 $I+1$ 行\n\n第一行，三个空格分隔的整数：$X、Y\\text{ 和 }I$\n\n第二行到第 $I+1$ 行：第 $i+1$ 行包含第 $i$ 条耕地指令，由四个整数描述：$Xll、Yll、Xur \\text{ 和 } Yur$", "outputFormat": "一行，一个整数，表示被犁过的方格总数", "hint": "正如任务示例中所示", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09OCT] The Robot Plow G", "background": "", "description": "Farmer John bought a new automatic plowing robot to free himself from the daily hard work of plowing. The robot can indeed do the job, but with a small limitation: it can only plow perfect rectangular areas whose side lengths are integers.\n\nBecause there are trees and other obstacles scattered around the field, John needs to instruct the robot to plow several different rectangular regions, which may overlap. He is curious how many grid cells will actually be plowed after programming the robot with various instructions (each instruction is described by the lower-left and upper-right $x, y$ coordinates of a rectangle).\n\nAs usual, the field is divided into unit grid cells whose edges are parallel to the $x$- and $y$-axes. The whole field is $X$ cells wide and $Y$ cells high ($1 \\le X, Y \\le 240$). There are $I$ plowing instructions ($1 \\le I \\le 200$). Each instruction consists of four integers: $Xll, Yll, Xur$ and $Yur$ ($1 \\le Xll \\le Xur \\le X; 1 \\le Yll \\le Yur \\le Y$), representing the coordinates of the lower-left and upper-right corners of the rectangle to be plowed. The robot will plow all grid cells in the rectangle $(Xll \\dots Xur, Yll \\dots Yur)$—depending on how you interpret it, this might include one more row or column than you initially expect (of course, that depends on your interpretation).\n\nFor example, consider a field that is 6 cells wide and 4 cells high. When John issues two plowing instructions (as shown below), the plowed area is indicated by `*` and `#` (usually the plowed area looks the same; here `#` marks the most recently plowed area):\n\n```\n......             **....             #####. \n......  (1,1)(2,4) **....  (1,3)(5,4) #####. \n......             **....             **.... \n......             **....             **....\n```\nIn the end, 14 cells are plowed.\n\nScore: 25 points.", "inputFormat": "A total of $I+1$ lines.\n\n- The first line contains three space-separated integers: $X, Y$ and $I$.\n- Lines 2 through $I+1$: line $i+1$ contains the $i$-th plowing instruction, described by four integers: $Xll, Yll, Xur$ and $Yur$.", "outputFormat": "One line with a single integer, the total number of cells that are plowed.", "hint": "As shown in the example in the statement.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09OCT] The Robot Plow G", "background": null, "description": "农夫约翰购买了一台新的自动耕地机器人，以将自己从日复一日犁地的繁重劳动中解脱出来。这台机器人确实能完成耕地任务，但有一个小缺点：它只能犁出各边长度均为整数的完美矩形地块。\n\n由于约翰的田地中分布着树木和其他障碍物，他需要设定机器人犁耕多个不同的矩形区域，这些区域可能会有重叠。他很好奇，在按照各种耕地指令（每个指令通过给出矩形的左下角和右上角 x、y 坐标来描述）编程后，田地里实际被犁过的方格数量究竟有多少。\n\n和往常一样，田地被划分为若干方格，这些方格的边与 x 轴和 y 轴平行。整块田地的宽度为 $X$ 个方格，高度为 $Y$ 个方格 $1\\le X,Y \\le 240)$。共有 $I$ 条耕地指令 $(1\\le I \\le 200)$，每条指令包含四个整数：$Xll、Yll、Xur \\text{ 和 } Yur\\text{ (}1 \\le Xll \\le Xur \\le X;1 \\le Yll \\le Yur \\le Y）$，分别表示待犁矩形的左下角和右上角坐标。机器人会犁耕区间 $(Xll \\dots Xur, Yll \\dots Yur)$ 内的所有田地方格——根据不同的理解方式，这个区间可能比初始设想的多一行或一列（当然，具体取决于你如何理解）。\n\n以一块宽 6 格、高 4 格的田地为例。当约翰发出两条耕地指令（如下所示）时，田地的犁耕情况如 `*` 和 `#` 所示（通常犁过的田地看起来相同，这里用 `#` 表示最近犁过的区域）：\n\n```\n......             **....             #####. \n......  (1,1)(2,4) **....  (1,3)(5,4) #####. \n......             **....             **.... \n......             **....             **....\n```\n最终共有 14 个方格被犁过。\n\n得分：25 分", "inputFormat": "共 $I+1$ 行\n\n第一行，三个空格分隔的整数：$X、Y\\text{ 和 }I$\n\n第二行到第 $I+1$ 行：第 $i+1$ 行包含第 $i$ 条耕地指令，由四个整数描述：$Xll、Yll、Xur \\text{ 和 } Yur$", "outputFormat": "一行，一个整数，表示被犁过的方格总数", "hint": "正如任务示例中所示", "locale": "zh-CN"}}}
{"pid": "P2957", "type": "P", "difficulty": 2, "samples": [["abcxxxxabcxabcd \nabcdxabcxxxxabcx \n", "11 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2009", "USACO", "哈希 hashing", "前缀和"], "title": "[USACO09OCT] Barn Echoes G", "background": null, "description": "奶牛们非常享受在牛栏中哞叫，因为她们可以听到她们哞声的回音。虽然有时候并不能完全听到完整的回音。Bessie 曾经是一个出色的秘书，所以她精确地纪录了所有的哞叫声及其回声。她很好奇到底两个声音的重复部分有多长。\n\n输入两个字符串（长度为 $1$ 到 $80$ 个字母），表示两个哞叫声。你要确定最长的重复部分的长度。两个字符串的重复部分指的是同时是一个字符串的前缀和另一个字符串的后缀的字符串。\n\n我们通过一个例子来理解题目。考虑下面的两个哞声：\n\n```\nmoyooyoxyzooo\nyzoooqyasdfljkamo\n```\n\n第一个串的最后的部分 `yzooo` 跟第二个串的第一部分重复。第二个串的最后的部分 `mo` 跟第一个串的第一部分重复。所以 `yzooo` 跟 `mo` 都是这 $2$ 个串的重复部分。其中，`yzooo` 比较长，所以最长的重复部分的长度就是 $5$。", "inputFormat": "两行字符串，表示一只奶牛的哞叫声及其回声。", "outputFormat": "一行一个整数，表示两个声音的重复部分有多长。", "hint": "“abcxxxxabcx”是两个字符串的重复部分（第一个字符串的前缀和第二个字符串的后缀），所以答案为 $11$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09OCT] Barn Echoes G", "background": "", "description": "The cows enjoy mooing at the barn because their moos echo back, although sometimes not completely. Bessie, ever the excellent\n\nsecretary, has been recording the exact wording of the moo as it goes out and returns. She is curious as to just how much overlap there is.\n\nGiven two lines of input (letters from the set a..z, total length in the range 1..80), each of which has the wording of a moo on it, determine the greatest number of characters of overlap between one string and the other. A string is an overlap between two other strings if it is a prefix of one string and a suffix of the other string.\n\nBy way of example, consider two moos:\n\n```\nmoyooyoxyzooo\nyzoooqyasdfljkamo\n```\nThe last part of the first string overlaps 'yzooo' with the first part of the second string. The last part of the second string\n\noverlaps 'mo' with the first part of the first string. The largest overlap is 'yzooo' whose length is 5.\n\nPOINTS: 50", "inputFormat": "\\* Lines 1..2: Each line has the text of a moo or its echo", "outputFormat": "\\* Line 1: A single line with a single integer that is the length of the longest overlap between the front of one string and end of the other.\n", "hint": "'abcxxxxabcx' is a prefix of the first string and a suffix of the second string.\n", "locale": "en"}, "zh-CN": {"title": "[USACO09OCT] Barn Echoes G", "background": null, "description": "奶牛们非常享受在牛栏中哞叫，因为她们可以听到她们哞声的回音。虽然有时候并不能完全听到完整的回音。Bessie 曾经是一个出色的秘书，所以她精确地纪录了所有的哞叫声及其回声。她很好奇到底两个声音的重复部分有多长。\n\n输入两个字符串（长度为 $1$ 到 $80$ 个字母），表示两个哞叫声。你要确定最长的重复部分的长度。两个字符串的重复部分指的是同时是一个字符串的前缀和另一个字符串的后缀的字符串。\n\n我们通过一个例子来理解题目。考虑下面的两个哞声：\n\n```\nmoyooyoxyzooo\nyzoooqyasdfljkamo\n```\n\n第一个串的最后的部分 `yzooo` 跟第二个串的第一部分重复。第二个串的最后的部分 `mo` 跟第一个串的第一部分重复。所以 `yzooo` 跟 `mo` 都是这 $2$ 个串的重复部分。其中，`yzooo` 比较长，所以最长的重复部分的长度就是 $5$。", "inputFormat": "两行字符串，表示一只奶牛的哞叫声及其回声。", "outputFormat": "一行一个整数，表示两个声音的重复部分有多长。", "hint": "“abcxxxxabcx”是两个字符串的重复部分（第一个字符串的前缀和第二个字符串的后缀），所以答案为 $11$。", "locale": "zh-CN"}}}
{"pid": "P2958", "type": "P", "difficulty": 2, "samples": [["3 4 \n3 3 4 5 \n4 5 3 2 \n1 7 4 2 \n", "39 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09OCT] Papaya Jungle G", "background": "", "description": "Bessie 不小心游荡出 Farmer John 的田地，而走进了相邻的农民的地里。她举起一个木瓜，木瓜对奶牛来说可是不可多得的美味。这个木瓜林像一般的威斯康星州的田地一样被分割成一个 $R$ 行 $C$ 列的网格 $(1 \\le R,C \\le 40)$。Bessie 可以从一个格沿着一条跟 X 轴或 Y 轴平行的直线走到邻接的另一个格。Bessie 发现一开始她自己在木瓜林的 $(1,1)$，也就是第一行第一列慢悠悠地咀嚼着木瓜。\n\nBessie 总是用她最信赖地双筒望远镜去数每一个邻接的格里挂着的木瓜的数目。然后她就游荡到那个有最多没有被吃掉的木瓜的邻接的格子（保证这样的格子只有一个）。\n\n按照这种移动方法，最终 Bessie 总是会在 $(R,C)$ 停止然后吃掉那里的木瓜。\n\n给定这个木瓜林的大小及每个格的木瓜数 $F_{ij}(1 \\le F_{ij} \\le 100)$，求 Bessie 一共吃了多少个木瓜。", "inputFormat": "第一行：两个用空格分割的整数 $R$ 和 $C$。\n\n接下来 $R$ 行：第 $i+1$ 行用 $C$ 个用空格分隔的整数描述丛林的第 $i$ 行 $F_{i1},F_{i2},\\dots,F_{iC}$。", "outputFormat": "第一行：一个整数，表示 Bessie 在坐标 $(R,C)$ 的右下角谷仓吃完木瓜时吃的木瓜总数。", "hint": "Bessie 按照下面的顺序吃木瓜：\n\n![顺序](https://cdn.luogu.com.cn/upload/image_hosting/uagjs0wr.png)", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09OCT] Papaya Jungle G", "background": "", "description": "Bessie has accidentally wandered out of Farmer John’s field and into a neighboring farmer’s land. She picks up a papaya—papayas are a rare delicacy for cows. Like typical fields in Wisconsin, this papaya grove is partitioned into a grid of $R$ rows and $C$ columns ($1 \\le R, C \\le 40$). Bessie can move from one cell to an adjacent cell along a straight line parallel to the X-axis or Y-axis. She finds herself starting in the papaya grove at $(1, 1)$, the first row and first column, leisurely chewing on a papaya.\n\nBessie always uses her trusty binoculars to count the number of papayas hanging in each adjacent cell. Then she wanders to the adjacent cell that has the most papayas that have not yet been eaten (this cell is guaranteed to be unique).\n\nFollowing this movement rule, Bessie will eventually stop at $(R, C)$ and eat the papayas there.\n\nGiven the size of the papaya grove and the number of papayas in each cell $F_{ij}$ ($1 \\le F_{ij} \\le 100$), determine the total number of papayas Bessie eats.", "inputFormat": "Line 1: two integers $R$ and $C$ separated by a space.\n\nThe next $R$ lines: the $(i + 1)$-th line describes row $i$ of the grove with $C$ space-separated integers $F_{i1}, F_{i2}, \\dots, F_{iC}$.", "outputFormat": "Line 1: a single integer, the total number of papayas Bessie eats by the time she finishes at the barn in the bottom-right corner at coordinates $(R, C)$.", "hint": "Bessie eats the papayas in the following order:\n\n![顺序](https://cdn.luogu.com.cn/upload/image_hosting/uagjs0wr.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09OCT] Papaya Jungle G", "background": "", "description": "Bessie 不小心游荡出 Farmer John 的田地，而走进了相邻的农民的地里。她举起一个木瓜，木瓜对奶牛来说可是不可多得的美味。这个木瓜林像一般的威斯康星州的田地一样被分割成一个 $R$ 行 $C$ 列的网格 $(1 \\le R,C \\le 40)$。Bessie 可以从一个格沿着一条跟 X 轴或 Y 轴平行的直线走到邻接的另一个格。Bessie 发现一开始她自己在木瓜林的 $(1,1)$，也就是第一行第一列慢悠悠地咀嚼着木瓜。\n\nBessie 总是用她最信赖地双筒望远镜去数每一个邻接的格里挂着的木瓜的数目。然后她就游荡到那个有最多没有被吃掉的木瓜的邻接的格子（保证这样的格子只有一个）。\n\n按照这种移动方法，最终 Bessie 总是会在 $(R,C)$ 停止然后吃掉那里的木瓜。\n\n给定这个木瓜林的大小及每个格的木瓜数 $F_{ij}(1 \\le F_{ij} \\le 100)$，求 Bessie 一共吃了多少个木瓜。", "inputFormat": "第一行：两个用空格分割的整数 $R$ 和 $C$。\n\n接下来 $R$ 行：第 $i+1$ 行用 $C$ 个用空格分隔的整数描述丛林的第 $i$ 行 $F_{i1},F_{i2},\\dots,F_{iC}$。", "outputFormat": "第一行：一个整数，表示 Bessie 在坐标 $(R,C)$ 的右下角谷仓吃完木瓜时吃的木瓜总数。", "hint": "Bessie 按照下面的顺序吃木瓜：\n\n![顺序](https://cdn.luogu.com.cn/upload/image_hosting/uagjs0wr.png)", "locale": "zh-CN"}}}
{"pid": "P2959", "type": "P", "difficulty": 2, "samples": [["10 \n7 8 0 \n5 0 6 \n9 0 0 \n6 0 7 \n3 4 0 \n2 5 0 \n8 0 9 \n4 0 0 \n1 2 3 \n", "7 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09OCT] The Leisurely Stroll G", "background": null, "description": "Bessie 通过牛棚的大门向外望去，发现今天是一个美丽的春季早晨。她想，“我真的好想好想沐浴着春风，走在草地之中，感受嫩草温柔地抚摸四蹄的感觉。”她知道一旦她离开了牛棚，她将沿着一条小径走一段路，然后就会出现一个三岔路口，她必须在两条小径中选择一条继续走下去。然后她又会遇到更多的三岔路口，进行更多的选择，直到她到达一个青翠的牧场为止。\n\n她决定作一个选择使得她在去吃早草的路途中可以走过最多的小径。给你这些小径的描述，求出 Bessie 最多可以走过多少条小径。假定 Bessie 一出牛棚就有 $2$ 条路径，Bessie 需要从中选择一条。\n\n农场中有 $P-1$（$1 \\le P \\le 1000$）个分岔节点（范围是 $1 \\ldots P-1$），引向 $P$ 片草地，它们之间由小径连接。对任意一个节点来说，只有一条从牛棚（被标记为节点 $1$）开始的路径可以到达。\n\n考虑下面的图。线段表示小径，`%` 表示草地。右边的图中的 `#` 表示一条到达草地的高亮的路径。\n\n```plain\n\n                 %                             %\n                /                             /\n      2----%   7----8----%          2----%   7####8----%\n     / \\      /      \\             # #      #      #\n    1   5----6        9----%      1   5####6        9----%\n     \\   \\    \\        \\           \\   \\    \\        #\n      \\   %    %        %           \\   %    %        %\n       \\                             \\\n        3-----%                       3-----%\n         \\                             \\\n          4----%                        4----%\n           \\                             \\\n            %                             %\n```\n\n从分岔节点 $9$ 到达的草地是两个可以让 Bessie 走过最多小径的草地之一。在去吃早草的路上 Bessie 将走过 $7$ 条不同的小径。这些草地是离牛棚也就是节点 $1$ 最“远”的。\n\n由 $3$ 个整数来表示每一个节点：$C,D_1,D_2$，$C$ 是节点的编号（$1 \\le C < P$），$D_1$ 和 $D_2$ 是由该节点引出的两条小径的终点（$0 \\le D_1,D_2 < P$）。如果 $D_1$ 为 $0$，表示这条小径引向的是一片牧草地，$D_2$ 也一样。", "inputFormat": "第一行，一个正整数 $P$。\n\n以下 $P-1$ 行，每行 $3$ 个整数 $C,D_1,D_2$ 表示一个节点。", "outputFormat": "输出一行一个整数，代表 Bessie 可以经过最多节点数。", "hint": "输入即题目描述中的地图。\n\n`1-2-5-6-7-8-9-草地` 是最长路径之一。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09OCT] The Leisurely Stroll G", "background": "", "description": "Bessie looks out of the barn door and sees a beautiful spring morning. She thinks, \"I really, really want to stroll through the meadow in the spring breeze and feel the tender grass gently brushing my hooves.\" She knows that once she leaves the barn, she will follow a trail for a while and then reach a fork with two choices. She will keep encountering more forks and making more choices until she reaches a lush pasture.\n\nShe decides to choose a route that lets her walk through as many trails as possible on her way to breakfast. Given the description of these trails, compute the maximum number of trails Bessie can traverse. Assume that right outside the barn there are $2$ outgoing trails, and Bessie must choose one of them.\n\nThere are $P-1$ ($1 \\le P \\le 1000$) branching nodes (numbered $1 \\ldots P-1$) leading to $P$ pastures, connected by trails. For any node, there is exactly one path starting from the barn (which is labeled node $1$) that reaches it.\n\nConsider the figure below. Line segments represent trails, and `%` represents a pasture. In the figure on the right, `#` highlights a path to a pasture.\n\n```plain\n\n                 %                             %\n                /                             /\n      2----%   7----8----%          2----%   7####8----%\n     / \\      /      \\             # #      #      #\n    1   5----6        9----%      1   5####6        9----%\n     \\   \\    \\        \\           \\   \\    \\        #\n      \\   %    %        %           \\   %    %        %\n       \\                             \\\n        3-----%                       3-----%\n         \\                             \\\n          4----%                        4----%\n           \\                             \\\n            %                             %\n```\n\nThe pasture reached from branching node $9$ is one of the two pastures that allow Bessie to traverse the most trails. On the way to breakfast, Bessie will traverse $7$ distinct trails. These pastures are the \"farthest\" from the barn, i.e., node $1$.\n\nEach node is described by three integers $C, D_1, D_2$. Here, $C$ is the node label ($1 \\le C < P$), and $D_1$ and $D_2$ are the endpoints of the two outgoing trails from node $C$ ($0 \\le D_1, D_2 < P$). If $D_1$ is $0$, that trail leads to a pasture; the same applies to $D_2$.", "inputFormat": "The first line contains a single integer $P$.\n\nEach of the following $P-1$ lines contains three integers $C, D_1, D_2$ describing one node.", "outputFormat": "Output a single integer: the maximum number of trails (edges) Bessie can traverse.", "hint": "The input is exactly the map shown in the Description.\n\n1-2-5-6-7-8-9-pasture is one of the longest paths.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09OCT] The Leisurely Stroll G", "background": null, "description": "Bessie 通过牛棚的大门向外望去，发现今天是一个美丽的春季早晨。她想，“我真的好想好想沐浴着春风，走在草地之中，感受嫩草温柔地抚摸四蹄的感觉。”她知道一旦她离开了牛棚，她将沿着一条小径走一段路，然后就会出现一个三岔路口，她必须在两条小径中选择一条继续走下去。然后她又会遇到更多的三岔路口，进行更多的选择，直到她到达一个青翠的牧场为止。\n\n她决定作一个选择使得她在去吃早草的路途中可以走过最多的小径。给你这些小径的描述，求出 Bessie 最多可以走过多少条小径。假定 Bessie 一出牛棚就有 $2$ 条路径，Bessie 需要从中选择一条。\n\n农场中有 $P-1$（$1 \\le P \\le 1000$）个分岔节点（范围是 $1 \\ldots P-1$），引向 $P$ 片草地，它们之间由小径连接。对任意一个节点来说，只有一条从牛棚（被标记为节点 $1$）开始的路径可以到达。\n\n考虑下面的图。线段表示小径，`%` 表示草地。右边的图中的 `#` 表示一条到达草地的高亮的路径。\n\n```plain\n\n                 %                             %\n                /                             /\n      2----%   7----8----%          2----%   7####8----%\n     / \\      /      \\             # #      #      #\n    1   5----6        9----%      1   5####6        9----%\n     \\   \\    \\        \\           \\   \\    \\        #\n      \\   %    %        %           \\   %    %        %\n       \\                             \\\n        3-----%                       3-----%\n         \\                             \\\n          4----%                        4----%\n           \\                             \\\n            %                             %\n```\n\n从分岔节点 $9$ 到达的草地是两个可以让 Bessie 走过最多小径的草地之一。在去吃早草的路上 Bessie 将走过 $7$ 条不同的小径。这些草地是离牛棚也就是节点 $1$ 最“远”的。\n\n由 $3$ 个整数来表示每一个节点：$C,D_1,D_2$，$C$ 是节点的编号（$1 \\le C < P$），$D_1$ 和 $D_2$ 是由该节点引出的两条小径的终点（$0 \\le D_1,D_2 < P$）。如果 $D_1$ 为 $0$，表示这条小径引向的是一片牧草地，$D_2$ 也一样。", "inputFormat": "第一行，一个正整数 $P$。\n\n以下 $P-1$ 行，每行 $3$ 个整数 $C,D_1,D_2$ 表示一个节点。", "outputFormat": "输出一行一个整数，代表 Bessie 可以经过最多节点数。", "hint": "输入即题目描述中的地图。\n\n`1-2-5-6-7-8-9-草地` 是最长路径之一。", "locale": "zh-CN"}}}
{"pid": "P2960", "type": "P", "difficulty": 3, "samples": [["4 3 1 1 \n.... \n..*. \n.**. \n", "4 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2009", "USACO"], "title": "[USACO09OCT] Invasion of the Milkweed G", "background": "", "description": "Farmer John has always done his best to keep the pastures full of luscious, delicious healthy grass for the cows. He has lost the battle, though, as the evil milkweed has attained a foothold in the northwest part of his farm.\n\nThe pasture, as usual, is partitioned into a rectilinear grid of height Y (1 <= Y <= 100) and width X (1 <= X <= 100) with (1,1) being in the lower left corner (i.e., arranged as a normal X,Y coordinate grid). The milkweed has initially begun growing at square (Mx,My). Each week the milkweed propagates to all non-rocky squares that surround any square it already occupies, as many as eight more squares (both the rectilinear squares and the diagonals). After only one week in those squares, it is ready to move on to more squares.\n\nBessie wants to enjoy all the grass she can before the pastures are taken over by milkweed. She wonders how long it can last. If the milkweed is in square (Mx,My) at time zero, at what time does it complete its invasion of the pasture (which, for the given input data, will always happen)?\n\nThe pasture is described by a picture with '.'s for grass and '\\*'s for boulders, like this example with X=4 and Y=3:\n\n```\n....\n..*.\n.**.\n```\n\nIf the milkweed started in the lower left corner (row=1, column=1), then the map would progress like this:\n\n```\n    ....  ....  MMM.  MMMM  MMMM\n    ..*.  MM*.  MM*.  MM*M  MM*M\n    M**.  M**.  M**.  M**.  M**M\nweek  0    1    2    3    4\n```\n\nThe milkweed has taken over the entire field after 4 weeks.", "inputFormat": "\\* Line 1: Four space-separated integers: X, Y, Mx, and My\n\n\\* Lines 2..Y+1: Line y+1 describes row (Y+2-y) of the field with X characters ('.' for grass and '\\*' for a boulder)\n", "outputFormat": "\\* Line 1: A single integer that is the week number when the milkweed takes over the last remaining non-boulder square of the pasture.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO09OCT] Invasion of the Milkweed G", "background": "", "description": "Farmer John has always done his best to keep the pastures full of luscious, delicious healthy grass for the cows. He has lost the battle, though, as the evil milkweed has attained a foothold in the northwest part of his farm.\n\nThe pasture, as usual, is partitioned into a rectilinear grid of height Y (1 <= Y <= 100) and width X (1 <= X <= 100) with (1,1) being in the lower left corner (i.e., arranged as a normal X,Y coordinate grid). The milkweed has initially begun growing at square (Mx,My). Each week the milkweed propagates to all non-rocky squares that surround any square it already occupies, as many as eight more squares (both the rectilinear squares and the diagonals). After only one week in those squares, it is ready to move on to more squares.\n\nBessie wants to enjoy all the grass she can before the pastures are taken over by milkweed. She wonders how long it can last. If the milkweed is in square (Mx,My) at time zero, at what time does it complete its invasion of the pasture (which, for the given input data, will always happen)?\n\nThe pasture is described by a picture with '.'s for grass and '\\*'s for boulders, like this example with X=4 and Y=3:\n\n```\n....\n..*.\n.**.\n```\n\nIf the milkweed started in the lower left corner (row=1, column=1), then the map would progress like this:\n\n```\n    ....  ....  MMM.  MMMM  MMMM\n    ..*.  MM*.  MM*.  MM*M  MM*M\n    M**.  M**.  M**.  M**.  M**M\nweek  0    1    2    3    4\n```\n\nThe milkweed has taken over the entire field after 4 weeks.", "inputFormat": "\\* Line 1: Four space-separated integers: X, Y, Mx, and My\n\n\\* Lines 2..Y+1: Line y+1 describes row (Y+2-y) of the field with X characters ('.' for grass and '\\*' for a boulder)\n", "outputFormat": "\\* Line 1: A single integer that is the week number when the milkweed takes over the last remaining non-boulder square of the pasture.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO09OCT] Invasion of the Milkweed G", "background": null, "description": "农夫约翰一直尽力保持牧场里长满丰盛、美味且健康的草供奶牛食用。然而，他输掉了这场战斗，因为邪恶的乳草在他的农场西北部站稳了脚跟。\n\n牧场通常被划分为一个直角网格，高度为 $Y$（$1 \\le Y \\le 100$），宽度为 $X$（$1 \\le X \\le 100$），其中 $(1,1)$ 位于左下角（即，排列为正常的 $X,Y$ 坐标网格）。乳草最初开始在方格 $(M_x,M_y)$ 生长。每周，乳草会传播到它已经占据的任何方格周围的所有非岩石方格，最多可以传播到八个方格（包括直角方格和对角线方格）。在这些方格中仅仅一周后，它就准备好继续传播到更多方格。\n\n贝茜想在牧场被乳草占领之前尽可能多地享受青草。她想知道牧场能持续多久。如果乳草在时间零时位于方格 $(M_x,M_y)$，那么它在何时完成对牧场的入侵（对于给定的输入数据，这种情况总会发生）？\n\n牧场由一个图示描述，'.' 代表草，'\\*' 代表巨石，如下例所示，$X=4$，$Y=3$：\n\n```\n....\n..*.\n.**.\n```\n\n如果乳草从左下角开始（行=1，列=1），那么地图将按如下方式演变：\n\n```\n    ....  ....  MMM.  MMMM  MMMM\n    ..*.  MM*.  MM*.  MM*M  MM*M\n    M**.  M**.  M**.  M**.  M**M\nweek  0    1    2    3    4\n```\n\n乳草在 4 周后占领了整个牧场。", "inputFormat": "\\* 第 1 行：四个以空格分隔的整数：$X$，$Y$，$M_x$ 和 $M_y$\n\n\\* 第 2 行到第 $Y+1$ 行：第 $y + 1$ 行描述了牧场的第 $(Y + 1 - y)$ 行，其中包含 $X$ 个字符（'.' 代表草，'\\*' 代表巨石）", "outputFormat": "\\* 第 1 行：一个整数，表示乳草占领牧场最后一个非巨石方格的周数。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2961", "type": "P", "difficulty": 6, "samples": [["5 6 \n3 2 4 5 \n2 1 3 \n3 1 2 3 \n1 1 \n2 2 5 \n3 2 3 4 \n", "5 \n1 \n3 \n1 \n2 \n4 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2009", "USACO", "Special Judge"], "title": "[USACO09NOV] Who Brings the Cookies? G", "background": "", "description": "Farmer John's N (1 <= N <= 1,000) cows conveniently numbered 1..N decided to form M (1 <= M <= 100) study groups. A total of S\\_i (1 <= S\\_i <= 19) cows study in group G\\_i (namely cows G\\_i1, G\\_i2, ...). A cow might study in more than one study group.\n\nFor each study group, one cow in the group must be chosen to bring cookies to the meeting. Cookies are costly and require time to acquire, so the cows want to divide the work of bringing cookies as fairly as possible.\n\nThey decided that if a cow attends meetings with size c\\_1, c\\_2, ..., c\\_K, she is only willing to bring cookies to at most ceil(1/c\\_1 + 1/c\\_2 + ... + 1/c\\_K) meetings.\n\nFigure out which cow brings cookies to each meeting. If this isn't possible, just output '-1'. Choose any solution if more than one is possible.\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Line i+1 contains many space-separated integers: S\\_i, G\\_i1, G\\_i2, ...\n", "outputFormat": "\\* Lines 1..M: If a mapping is possible, line i contains the number of the cow who brings cookies to study group i. Otherwise, line 1 contains just the integer -1.\n", "hint": "Cow1 can bring cookies to at most 2 meetings, cow2 can bring 2, cow3 can bring 2, cow4 can bring 1, and cow5 can bring 1.\n", "locale": "en", "translations": {"en": {"title": "[USACO09NOV] Who Brings the Cookies? G", "background": "", "description": "Farmer John's N (1 <= N <= 1,000) cows conveniently numbered 1..N decided to form M (1 <= M <= 100) study groups. A total of S\\_i (1 <= S\\_i <= 19) cows study in group G\\_i (namely cows G\\_i1, G\\_i2, ...). A cow might study in more than one study group.\n\nFor each study group, one cow in the group must be chosen to bring cookies to the meeting. Cookies are costly and require time to acquire, so the cows want to divide the work of bringing cookies as fairly as possible.\n\nThey decided that if a cow attends meetings with size c\\_1, c\\_2, ..., c\\_K, she is only willing to bring cookies to at most ceil(1/c\\_1 + 1/c\\_2 + ... + 1/c\\_K) meetings.\n\nFigure out which cow brings cookies to each meeting. If this isn't possible, just output '-1'. Choose any solution if more than one is possible.\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Line i+1 contains many space-separated integers: S\\_i, G\\_i1, G\\_i2, ...\n", "outputFormat": "\\* Lines 1..M: If a mapping is possible, line i contains the number of the cow who brings cookies to study group i. Otherwise, line 1 contains just the integer -1.\n", "hint": "Cow1 can bring cookies to at most 2 meetings, cow2 can bring 2, cow3 can bring 2, cow4 can bring 1, and cow5 can bring 1.\n", "locale": "en"}, "zh-CN": {"title": "[USACO09NOV] Who Brings the Cookies? G", "background": null, "description": "农夫约翰的 $N (1 \\leq N \\leq 1,000)$ 头奶牛，方便地编号为 $1$ 到 $N$，决定组成 $M (1 \\leq M \\leq 100)$ 个学习小组。每个学习小组 $G_i$ 中有 $S_i (1 \\leq S_i \\leq 19)$ 头奶牛参与学习（即奶牛 $G_i1, G_i2, \\dots$）。一头奶牛可能参加多个学习小组。\n\n对于每个学习小组，必须选择其中一头奶牛带饼干来参加会议。饼干很贵且需要时间来获取，因此奶牛们希望尽可能公平地分配带饼干的工作。\n\n她们决定，如果一头奶牛参加了大小为 $c_1, c_2, \\dots, c_K$ 的会议，她最多只愿意为 $ceil(1/c_1 + 1/c_2 + \\dots + 1/c_K$) 个会议带饼干。\n\n找出哪头奶牛为每次会议带饼干。如果无法做到，只需输出 '$-1$'。如果有多个解决方案，任选其一。", "inputFormat": "* 第 $1$ 行：两个用空格分隔的整数：$N$ 和 $M$。\n\n* 第 $2$ 行到第 $M+1$ 行：第 $i+1$ 行包含多个用空格分隔的整数：$S_i, G_i1, G_i2, \\dots$", "outputFormat": "* 第 $1$ 行到第 $M$ 行：如果映射是可能的，第 $i$ 行包含为学习小组 $i$ 带饼干的奶牛编号。否则，第 $1$ 行仅包含整数 $-1$。", "hint": "奶牛 $1$ 最多可以为 $2$ 次会议带饼干，奶牛 $2$ 可以带 $2$ 次，奶牛 $3$ 可以带 $2$ 次，奶牛 $4$ 可以带 $1$ 次，奶牛 $5$ 可以带 $1$ 次。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2962", "type": "P", "difficulty": 5, "samples": [["5 6 \n1 2 \n1 3 \n4 2 \n3 4 \n2 5 \n5 3 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2009", "USACO", "O2优化", "深度优先搜索 DFS", "折半搜索 meet in the middle"], "title": "[USACO09NOV] Lights G", "background": "", "description": "奶牛 Bessie 和其他奶牛在谷仓里玩游戏，但电源重置后所有灯都熄灭了。请帮助它们将所有的灯重新打开，以便继续游戏。\n\n有 $N$（$1 \\le N \\le 35$）盏灯，编号为 $1$ 到 $N$，它们的开关通过 $M$（$1 \\le M \\le 595$）条连接构成一个复杂的网络。\n\n每盏灯都有一个开关，当你切换它时，该灯及所有与之直接相连的灯都会改变状态（开变关，关变开）。\n\n请找出最少需要切换多少次开关，才能把所有灯都打开。\n\n题目保证至少存在一种切换方案可以将所有灯点亮。", "inputFormat": "第 $1$ 行是两个用空格分隔的整数 $N$ 和 $M$。\n\n第 $2$ 行到第 $M + 1$ 行，每行两个空格分隔的整数，表示一条连接的两个灯的编号（无重复）。", "outputFormat": "仅一行一个整数，表示将所有灯点亮所需的最少开关切换次数。", "hint": "### 样例解释\n\n$5$ 盏灯中，灯 $1, 4, 5$ 各自都与灯 $2$ 和灯 $3$ 相连。\n\n只需切换灯 $1, 4, 5$ 的开关，即可使所有灯都打开。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09NOV] Lights G", "background": null, "description": "Bessie and the cows were playing games in the barn, but the power was reset and the lights were all turned off. Help the cows get all the lights back on so they can resume their games.\n\nThe $N(1 \\le N \\le 35)$ lights conveniently numbered $1 \\cdots N$ and their switches are arranged in a complex network with $M(1 \\le M \\le 595)$ clever connection between pairs of lights (see below).\n\nEach light has a switch that, when toggled, causes that light -- and all of the lights that are connected to it -- to change their states (from on to off, or off to on).\n\nFind the minimum number of switches that need to be toggled in order to turn all the lights back on.\n\nIt's guaranteed that there is at least one way to toggle the switches so all lights are back on.", "inputFormat": "- Line $1$: Two space-separated integers: $N$ and $M$.\n- Lines $2 \\cdots M+1$: Each line contains two space-separated integers representing two lights that are connected. No pair will be repeated.", "outputFormat": "- Line $1$: A single integer representing the minimum number of switches that need to be flipped in order to turn on all the lights.", "hint": "### Explanation\n\nThere are $5$ lights. Lights $1,4$ and $5$ are each connected to both lights $2$ and $3$.\n\nToggle the switches on lights $1, 4$ and $5$.", "locale": "en"}, "zh-CN": {"title": "[USACO09NOV] Lights G", "background": "", "description": "奶牛 Bessie 和其他奶牛在谷仓里玩游戏，但电源重置后所有灯都熄灭了。请帮助它们将所有的灯重新打开，以便继续游戏。\n\n有 $N$（$1 \\le N \\le 35$）盏灯，编号为 $1$ 到 $N$，它们的开关通过 $M$（$1 \\le M \\le 595$）条连接构成一个复杂的网络。\n\n每盏灯都有一个开关，当你切换它时，该灯及所有与之直接相连的灯都会改变状态（开变关，关变开）。\n\n请找出最少需要切换多少次开关，才能把所有灯都打开。\n\n题目保证至少存在一种切换方案可以将所有灯点亮。", "inputFormat": "第 $1$ 行是两个用空格分隔的整数 $N$ 和 $M$。\n\n第 $2$ 行到第 $M + 1$ 行，每行两个空格分隔的整数，表示一条连接的两个灯的编号（无重复）。", "outputFormat": "仅一行一个整数，表示将所有灯点亮所需的最少开关切换次数。", "hint": "### 样例解释\n\n$5$ 盏灯中，灯 $1, 4, 5$ 各自都与灯 $2$ 和灯 $3$ 相连。\n\n只需切换灯 $1, 4, 5$ 的开关，即可使所有灯都打开。", "locale": "zh-CN"}}}
{"pid": "P2963", "type": "P", "difficulty": 4, "samples": [["4 2 \n2 1 \n3 5 \n4 4 \n", "4 4 \n4 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2009", "USACO"], "title": "[USACO09NOV] Cow Rescue G", "background": "", "description": "Bessie is trapped in a triangular maze with N rows (1 <= N <= 1,000,000). A three row maze is shown below:\n\nThe i'th row of the maze contains 2\\*i-1 triangles. Numbering from the left, the triangles are named (i,1), (i,2), and so on.\n\nBessie can travel to the (often three) triangles which share an edge with her current triangle. For example, if she is at (3, 3), she can travel to (3, 2), (3, 4) and (4, 4). Bessie takes one minute to travel from one triangle to the next.\n\nFJ has learned the Bessie is trapped and knows by tracking her iPhone that she starts her exit trek at triangle (Si,Sj). FJ's love for Bessie knows no bounds so he wants her back in the minimum possible time.\n\nThe maze has M (1 <= M <= 10,000) exits found in locations throughout the set of triangles. Any one of these will enable Bessie to escape. Once she enters an exit triangle, she leaves the maze in just one more minute.\n\nFind the minimum time in minutes, T, required for Bessie to exit the maze and report the optimal exit location she uses, (OUTi, OUTj). If more than one location requires only T minutes, output the location with the smallest row. If two optimal rows are the same, output the one with smaller column.\n\n贝希被困在一个三角形的迷宫之中。这个迷宫有 $N$ 行（$1 \\le N \\le 1000000$）。比如下图是一个 $3$ 行的迷宫。  迷宫的第 $i$ 行有 $2i-1$ 个三角形，从左到右分别编号为 $(i, 1)$、$(i, 2)$ 等等。\n\n贝希每次可以从一个三角形走到任意一个一个跟当前的三角形有邻边的三角形。\n\n比如说，如果她目前处于三角形 $(3, 3)$，那么，她可以走到三角形 $(3, 2)$、$(3, 4)$ 和 $(4, 4)$。贝希每次需要一分钟的时间来移动到下一个三角形。\n\n农夫约翰发现贝希被困了！于是她跟踪贝希的iPhone手机（可怜的触摸屏～），得知贝希目前处于三角形 $(S_i, S_j)$。\n\n因为约翰对贝希有著无穷无尽的浓浓爱意，所以他希望贝希能尽可能快地回到他的身边。 在迷宫的三角形之中，有 $M$（$1 \\le M \\le 10000$）个是出口。在任何一个出口都可以让贝希逃离迷宫。一旦贝希进入一个作为出口的三角形，她用多一分钟就可以逃离这个迷宫。 找到一个可以让贝希逃离迷宫最小时间 $T$，并输出她应该从哪一个出口逃离迷宫，这个出口记为 $(\\text{OUT}_i, \\text{OUT}_j)$。\n\n如果有多个出口同时需要时间 $T$，输出那个行的编号小的出口，如果仍然有多个出口，输出那个列的编号小的。\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Line 2: Two space-separated integers: Si and Sj\n\n\\* Lines 3..M+2: Line i+2 contains two space-separated integers that are the triangle location of exit i: Ei and Ej\n", "outputFormat": "\\* Line 1: Two space-separated integers: OUTi and OUTj\n\n\\* Line 2: A single integer: T\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09NOV] Cow Rescue G", "background": "", "description": "Bessie is trapped in a triangular maze with $N$ rows ($1 \\le N \\le 1{,}000{,}000$). For example, a maze with $3$ rows is shown below.\n\nThe $i$-th row of the maze contains $2i - 1$ triangles. Numbering from the left, the triangles are named $(i, 1)$, $(i, 2)$, and so on.\n\nBessie can move to any triangles that share an edge with her current triangle (often three neighbors). For example, if she is at $(3, 3)$, she can move to $(3, 2)$, $(3, 4)$, and $(4, 4)$. Each move to a neighboring triangle takes one minute.\n\nFarmer John has learned that Bessie is trapped and, by tracking her iPhone, knows she starts at triangle $(S_i, S_j)$. His love for Bessie knows no bounds, so he wants her back in the minimum possible time.\n\nThere are $M$ exits ($1 \\le M \\le 10{,}000$) located at various triangles in the maze. Entering any exit triangle allows Bessie to escape, and it takes one additional minute after entering an exit triangle to leave the maze.\n\nFind the minimum time in minutes, $T$, required for Bessie to exit the maze, and report the exit she uses, $(\\text{OUT}_i, \\text{OUT}_j)$. If more than one exit requires only $T$ minutes, output the one with the smallest row. If there is still a tie, output the one with the smaller column.", "inputFormat": "- Line 1: Two space-separated integers: $N$ and $M$.\n- Line 2: Two space-separated integers: $S_i$ and $S_j$.\n- Lines $3 \\ldots M+2$: Line $i+2$ contains two space-separated integers giving the location of exit $i$: $E_i$ and $E_j$.", "outputFormat": "- Line 1: Two space-separated integers: $\\text{OUT}_i$ and $\\text{OUT}_j$.\n- Line 2: A single integer: $T$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09NOV] Cow Rescue G", "background": "", "description": "Bessie is trapped in a triangular maze with N rows (1 <= N <= 1,000,000). A three row maze is shown below:\n\nThe i'th row of the maze contains 2\\*i-1 triangles. Numbering from the left, the triangles are named (i,1), (i,2), and so on.\n\nBessie can travel to the (often three) triangles which share an edge with her current triangle. For example, if she is at (3, 3), she can travel to (3, 2), (3, 4) and (4, 4). Bessie takes one minute to travel from one triangle to the next.\n\nFJ has learned the Bessie is trapped and knows by tracking her iPhone that she starts her exit trek at triangle (Si,Sj). FJ's love for Bessie knows no bounds so he wants her back in the minimum possible time.\n\nThe maze has M (1 <= M <= 10,000) exits found in locations throughout the set of triangles. Any one of these will enable Bessie to escape. Once she enters an exit triangle, she leaves the maze in just one more minute.\n\nFind the minimum time in minutes, T, required for Bessie to exit the maze and report the optimal exit location she uses, (OUTi, OUTj). If more than one location requires only T minutes, output the location with the smallest row. If two optimal rows are the same, output the one with smaller column.\n\n贝希被困在一个三角形的迷宫之中。这个迷宫有 $N$ 行（$1 \\le N \\le 1000000$）。比如下图是一个 $3$ 行的迷宫。  迷宫的第 $i$ 行有 $2i-1$ 个三角形，从左到右分别编号为 $(i, 1)$、$(i, 2)$ 等等。\n\n贝希每次可以从一个三角形走到任意一个一个跟当前的三角形有邻边的三角形。\n\n比如说，如果她目前处于三角形 $(3, 3)$，那么，她可以走到三角形 $(3, 2)$、$(3, 4)$ 和 $(4, 4)$。贝希每次需要一分钟的时间来移动到下一个三角形。\n\n农夫约翰发现贝希被困了！于是她跟踪贝希的iPhone手机（可怜的触摸屏～），得知贝希目前处于三角形 $(S_i, S_j)$。\n\n因为约翰对贝希有著无穷无尽的浓浓爱意，所以他希望贝希能尽可能快地回到他的身边。 在迷宫的三角形之中，有 $M$（$1 \\le M \\le 10000$）个是出口。在任何一个出口都可以让贝希逃离迷宫。一旦贝希进入一个作为出口的三角形，她用多一分钟就可以逃离这个迷宫。 找到一个可以让贝希逃离迷宫最小时间 $T$，并输出她应该从哪一个出口逃离迷宫，这个出口记为 $(\\text{OUT}_i, \\text{OUT}_j)$。\n\n如果有多个出口同时需要时间 $T$，输出那个行的编号小的出口，如果仍然有多个出口，输出那个列的编号小的。\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Line 2: Two space-separated integers: Si and Sj\n\n\\* Lines 3..M+2: Line i+2 contains two space-separated integers that are the triangle location of exit i: Ei and Ej\n", "outputFormat": "\\* Line 1: Two space-separated integers: OUTi and OUTj\n\n\\* Line 2: A single integer: T\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2964", "type": "P", "difficulty": 5, "samples": [["5 \n1 \n3 \n1 \n7 \n2 \n", "9 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000]}, "tags": ["动态规划 DP", "博弈论", "2009", "USACO"], "title": "[USACO09NOV] A Coin Game S", "background": null, "description": "小 A 和小 B 在玩游戏。\n\n初始时，有 $n$ 个硬币被摆成了一行，从左至右第 $i$ 个硬币的价值为 $c_i$。\n\n游戏的规则是，两人交替从这堆硬币的**左侧**连续取出若干硬币，然后将取出的硬币的价值累加至自己获得的累计价值中。若对方上次操作取出了 $k$ 个硬币，那么本次自己最多取出 $k \\times 2$ 个硬币。当没有硬币可取时，游戏结束。\n\n游戏开始时，由小 A 先动手取硬币，最多取出 $2$ 个硬币。\n\n请求出当双方都尽可能使自己的累计价值最大的情况下，小 A 能获得的累计价值最大是多少。", "inputFormat": "输入的第一行是一个整数 $n$，代表硬币的个数。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i + 1)$ 行的整数代表第 $i$ 个硬币的价值 $c_i$。", "outputFormat": "输出一行一个整数，代表小 A 能获得的最大累计价值。", "hint": "#### 输出输出样例 $1$ 解释\n\n初始时，硬币序列为 $\\{1,~3,~1,~7,~2\\}$。\n\n由小 A 先操作，他取出了一个硬币，硬币序列变为 $\\{3,~1,~7,~2\\}$，小 A 的累计价值为 $1$。\n\n再由小 B 操作，由于小 A 上回合取出了 $1$ 个硬币，所以他本回合可以取出至多 $1 \\times 2 = 2$ 个硬币。他取出了一个硬币，硬币序列变为 $\\{1,~7,~2\\}$，小 B 的累计价值为 $3$。\n\n再由小 A 操作，由于上回合小 B 取出了 $1$ 个硬币，所以他本回合可以取出至多 $1 \\times 2 = 2$ 个硬币。他取出了两个硬币，硬币序列变为 $\\{2\\}$，小 A 的累计价值为 $1 + 1 + 7 = 9$。\n\n再由小 B 操作，由于上回合小 A 取出了 $2$ 个硬币，所以他本回合可以取出至多 $2 \\times 2 = 4$ 个硬币。但是只剩下了 $1$ 个硬币，因此他只能取出一个硬币，硬币序列变为空，小 B 的累计价值为 $3 + 2 = 5$，游戏结束。\n\n#### 数据范围与约定\n\n对于全部的测试点，保证 $5 \\leq n \\leq 2 \\times 10^3$，$1 \\leq c_i \\leq 10^5$。\n\n**提示：请注意本题的空间限制为 $20$ MiB**。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09NOV] A Coin Game S", "background": null, "description": "Farmer John's cows like to play coin games so FJ has invented with a new two-player coin game called Xoinc for them.\n\nInitially a stack of $N\\ (5 <= N <= 2,000)$ coins sits on the ground; coin i from the top has integer value $C_i\\ (1\\le C_i\\le 100,000)$.\n\nThe first player starts the game by taking the top one or two coins ($C_1$ and maybe $C_2$) from the stack. If the first player takes just the top coin, the second player may take the following one or two coins in the next turn. If the first player takes two coins then the second player may take the top one, two, three or four coins from the stack. In each turn, the current player must take at least one coin and at most two times the amount of coins last taken by the opposing player. The game is over when there are no more coins to take.\n\nAfterwards, they can use the value of the coins they have taken from the stack to buy treats from FJ, so naturally, their purpose in the game is to maximize the total value of the coins they take. Assuming the second player plays optimally to maximize his own winnings, what is the highest total value that the first player can have when the game is over?", "inputFormat": "First Line: A single integer: $N$\n\nNext $N$ Lines: Line $i+1$ contains a single integer: $C_i$", "outputFormat": "A single integer representing the maximum value that can be made by the first player.", "hint": "Explanation:\n\nThe first player starts by taking a single coin (value $1$). The opponent takes one coin as well (value $3$). The first player takes two more coins (values $1$ and $7$ -- total $9$).\n\nThe second player gets the leftover coin (value $2$-- total $5$).", "locale": "en"}, "zh-CN": {"title": "[USACO09NOV] A Coin Game S", "background": null, "description": "小 A 和小 B 在玩游戏。\n\n初始时，有 $n$ 个硬币被摆成了一行，从左至右第 $i$ 个硬币的价值为 $c_i$。\n\n游戏的规则是，两人交替从这堆硬币的**左侧**连续取出若干硬币，然后将取出的硬币的价值累加至自己获得的累计价值中。若对方上次操作取出了 $k$ 个硬币，那么本次自己最多取出 $k \\times 2$ 个硬币。当没有硬币可取时，游戏结束。\n\n游戏开始时，由小 A 先动手取硬币，最多取出 $2$ 个硬币。\n\n请求出当双方都尽可能使自己的累计价值最大的情况下，小 A 能获得的累计价值最大是多少。", "inputFormat": "输入的第一行是一个整数 $n$，代表硬币的个数。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i + 1)$ 行的整数代表第 $i$ 个硬币的价值 $c_i$。", "outputFormat": "输出一行一个整数，代表小 A 能获得的最大累计价值。", "hint": "#### 输出输出样例 $1$ 解释\n\n初始时，硬币序列为 $\\{1,~3,~1,~7,~2\\}$。\n\n由小 A 先操作，他取出了一个硬币，硬币序列变为 $\\{3,~1,~7,~2\\}$，小 A 的累计价值为 $1$。\n\n再由小 B 操作，由于小 A 上回合取出了 $1$ 个硬币，所以他本回合可以取出至多 $1 \\times 2 = 2$ 个硬币。他取出了一个硬币，硬币序列变为 $\\{1,~7,~2\\}$，小 B 的累计价值为 $3$。\n\n再由小 A 操作，由于上回合小 B 取出了 $1$ 个硬币，所以他本回合可以取出至多 $1 \\times 2 = 2$ 个硬币。他取出了两个硬币，硬币序列变为 $\\{2\\}$，小 A 的累计价值为 $1 + 1 + 7 = 9$。\n\n再由小 B 操作，由于上回合小 A 取出了 $2$ 个硬币，所以他本回合可以取出至多 $2 \\times 2 = 4$ 个硬币。但是只剩下了 $1$ 个硬币，因此他只能取出一个硬币，硬币序列变为空，小 B 的累计价值为 $3 + 2 = 5$，游戏结束。\n\n#### 数据范围与约定\n\n对于全部的测试点，保证 $5 \\leq n \\leq 2 \\times 10^3$，$1 \\leq c_i \\leq 10^5$。\n\n**提示：请注意本题的空间限制为 $20$ MiB**。", "locale": "zh-CN"}}}
{"pid": "P2965", "type": "P", "difficulty": 2, "samples": [["2 0 1 5 55555555 0 1 0 55555555 55555555 \n", "51 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09NOV] The Grand Farm-off S", "background": "", "description": "Farmer John owns 3\\*N (1 <= N <= 500,000) cows surprisingly numbered 0..3\\*N-1, each of which has some associated integer weight W\\_i (1 <= W\\_i <= d). He is entering the Grand Farm-off, a farming competition where he shows off his cows to the greater agricultural community.\n\nThis competition allows him to enter a group of N cows. He has given each of his cows a utility rating U\\_i (1 <= U\\_i <= h), which\n\nrepresents the usefulness he thinks that a particular cow will have in the competition, and he wants his selection of cows to have the maximal sum of utility.\n\nThere might be multiple sets of N cows that attain the maximum utility sum. FJ is afraid the competition may impose a total weight limit on the cows in the competition, so a secondary priority is to bring lighter weight competition cows.\n\nHelp FJ find a set of N cows with minimum possible total weight among the sets of N cows that maximize the utility, and print the remainder when this total weight is divided by M (10,000,000 <= M <= 1,000,000,000).\n\nNote: to make the input phase faster, FJ has derived polynomials which will generate the weights and utility values for each cow. For each cow 0 <= i < 3\\*N,\n\n $$W_i=(a\\times i^5+b\\times i^2+c)\\mod d$$\n \n $$U_i=(e\\times i^5+f\\times i^3+g)\\mod h$$\n \n $$(0\\le a,b,c,d,e,f,g,h\\le 10^9)$$\n\nThe formulae do sometimes generate duplicate numbers; your algorithm should handle this properly. \n\n农夫约翰有3N(1 < N < 500000)头牛，编号依次为1..#N，每头牛都有一个整数值的体 重。约翰准备参加农场技艺大赛，向广大的农业社区展示他的奶牛.\n大赛规则允许约翰带N头牛参赛.约翰给每头牛赋予了一个“有用度”Ui，它表 示了某头牛在比赛中的有用程度.约翰希望他选出的奶牛的有用度之和最大.\n\n有可能选出很多组的N头牛都能达到有用度最大和.约翰害怕选出的N头牛的总重量会给大赛 带来震撼，所以，要考虑优先选择体重轻的奶牛.\n\n帮助约翰选出N头总重量最轻，并且有用度之和最大的奶牛.输出体重模M后的余数.\n\n注意：为了使输入更快，约翰使用了一个多项式来生成每头牛的体重和有用度.对每头牛/， 体重和有用度的计算公式为：\n\n\n\n $$W_i=(a\\times i^5+b\\times i^2+c)\\mod d$$\n \n $$U_i=(e\\times i^5+f\\times i^3+g)\\mod h$$\n \n $$(0\\le a,b,c,d,e,f,g,h\\le 10^9)$$", "inputFormat": "\\* Line 1: Ten space-separated integers: N, a, b, c, d, e, f, g, h, and M\n", "outputFormat": "\\* Line 1: A single integer representing the lowest sum of the weights of the N cows with the highest net utility.\n", "hint": "The functions generate weights of 5, 6, 9, 14, 21, and 30 along with utilities of 0, 1, 8, 27, 64, and 125.\n\n\nThe two cows with the highest utility are cow 5 and 6, and their combined weight is 21+30=51.\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09NOV] The Grand Farm-off S", "background": "", "description": "Farmer John owns $3N$ cows (with $1 \\le N \\le 500{,}000$), numbered $0 \\ldots 3N - 1$. Each cow $i$ has an integer weight $W_i$ and a utility rating $U_i$.\n\nHe may enter a group of $N$ cows into the Grand Farm-off. He wants to choose $N$ cows whose total utility is maximized. If multiple sets of $N$ cows achieve the same maximum total utility, he prefers the set with the minimum possible total weight.\n\nAmong all selections of $N$ cows that maximize the total utility, find the minimum possible total weight, and output the remainder when this total weight is divided by $M$ (with $10{,}000{,}000 \\le M \\le 1{,}000{,}000{,}000$).\n\nTo speed up input, the weights and utilities are generated by polynomials. For each cow $0 \\le i < 3N$,\n\n $$W_i=(a\\times i^5+b\\times i^2+c)\\mod d$$\n \n $$U_i=(e\\times i^5+f\\times i^3+g)\\mod h$$\n \n $$(0\\le a,b,c,d,e,f,g,h\\le 10^9)$$\n\nNote that these formulae can generate duplicate values; your algorithm should handle this properly. Also, $0 \\le W_i < d$ and $0 \\le U_i < h$.", "inputFormat": "Line 1: Ten space-separated integers $N$, $a$, $b$, $c$, $d$, $e$, $f$, $g$, $h$, $M$.", "outputFormat": "Line 1: A single integer — the remainder when the minimum possible total weight (among all selections of $N$ cows that maximize total utility) is divided by $M$.", "hint": "The functions generate weights of 5, 6, 9, 14, 21, and 30 along with utilities of 0, 1, 8, 27, 64, and 125.\n\nThe two cows with the highest utility are cows 5 and 6, and their combined weight is $21 + 30 = 51$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09NOV] The Grand Farm-off S", "background": "", "description": "Farmer John owns 3\\*N (1 <= N <= 500,000) cows surprisingly numbered 0..3\\*N-1, each of which has some associated integer weight W\\_i (1 <= W\\_i <= d). He is entering the Grand Farm-off, a farming competition where he shows off his cows to the greater agricultural community.\n\nThis competition allows him to enter a group of N cows. He has given each of his cows a utility rating U\\_i (1 <= U\\_i <= h), which\n\nrepresents the usefulness he thinks that a particular cow will have in the competition, and he wants his selection of cows to have the maximal sum of utility.\n\nThere might be multiple sets of N cows that attain the maximum utility sum. FJ is afraid the competition may impose a total weight limit on the cows in the competition, so a secondary priority is to bring lighter weight competition cows.\n\nHelp FJ find a set of N cows with minimum possible total weight among the sets of N cows that maximize the utility, and print the remainder when this total weight is divided by M (10,000,000 <= M <= 1,000,000,000).\n\nNote: to make the input phase faster, FJ has derived polynomials which will generate the weights and utility values for each cow. For each cow 0 <= i < 3\\*N,\n\n $$W_i=(a\\times i^5+b\\times i^2+c)\\mod d$$\n \n $$U_i=(e\\times i^5+f\\times i^3+g)\\mod h$$\n \n $$(0\\le a,b,c,d,e,f,g,h\\le 10^9)$$\n\nThe formulae do sometimes generate duplicate numbers; your algorithm should handle this properly. \n\n农夫约翰有3N(1 < N < 500000)头牛，编号依次为1..#N，每头牛都有一个整数值的体 重。约翰准备参加农场技艺大赛，向广大的农业社区展示他的奶牛.\n大赛规则允许约翰带N头牛参赛.约翰给每头牛赋予了一个“有用度”Ui，它表 示了某头牛在比赛中的有用程度.约翰希望他选出的奶牛的有用度之和最大.\n\n有可能选出很多组的N头牛都能达到有用度最大和.约翰害怕选出的N头牛的总重量会给大赛 带来震撼，所以，要考虑优先选择体重轻的奶牛.\n\n帮助约翰选出N头总重量最轻，并且有用度之和最大的奶牛.输出体重模M后的余数.\n\n注意：为了使输入更快，约翰使用了一个多项式来生成每头牛的体重和有用度.对每头牛/， 体重和有用度的计算公式为：\n\n\n\n $$W_i=(a\\times i^5+b\\times i^2+c)\\mod d$$\n \n $$U_i=(e\\times i^5+f\\times i^3+g)\\mod h$$\n \n $$(0\\le a,b,c,d,e,f,g,h\\le 10^9)$$", "inputFormat": "\\* Line 1: Ten space-separated integers: N, a, b, c, d, e, f, g, h, and M\n", "outputFormat": "\\* Line 1: A single integer representing the lowest sum of the weights of the N cows with the highest net utility.\n", "hint": "The functions generate weights of 5, 6, 9, 14, 21, and 30 along with utilities of 0, 1, 8, 27, 64, and 125.\n\n\nThe two cows with the highest utility are cow 5 and 6, and their combined weight is 21+30=51.\n", "locale": "zh-CN"}}}
{"pid": "P2966", "type": "P", "difficulty": 5, "samples": [["5 7 2 \n2 \n5 \n3 \n3 \n4 \n1 2 3 \n1 3 2 \n2 5 3 \n5 3 1 \n5 4 1 \n2 4 3 \n3 4 4 \n1 4 \n2 3 \n", "8 \n9 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO", "排序", "最短路"], "title": "[USACO09DEC] Cow Toll Paths G", "background": "", "description": "Like everyone else, FJ is always thinking up ways to increase his revenue. To this end, he has set up a series of tolls that the cows will pay when they traverse the cowpaths throughout the farm.\n\nThe cows move from any of the $N (1 \\leq N \\leq 250)$ pastures conveniently numbered $1...N$ to any other pasture over a set of $M (1 \\leq M \\leq 10,000) $bidirectional cowpaths that connect pairs of different pastures $A_j$ and $B_j (1 \\leq A_j \\leq N; 1 \\leq B_j \\leq N)$. FJ has assigned a toll $L_j (1 \\leq L_j \\leq 100,000)$ to the path connecting pastures $A_j$ and $B_j$.\n\nWhile there may be multiple cowpaths connecting the same pair of pastures, a cowpath will never connect a pasture to itself. Best of all, a cow can always move from any one pasture to any other pasture by following some sequence of cowpaths.\n\nIn an act that can only be described as greedy, FJ has also assigned a toll $C_i (1 \\leq C_i \\leq 100,000)$ to every pasture. The cost of moving from one pasture to some different pasture is the sum of the tolls for each of the cowpaths that were traversed plus a **single additional toll** that is the maximum of all the pasture tolls encountered along the way, including the initial and destination pastures.\n\nThe patient cows wish to investigate their options. They want you to write a program that accepts $K (1 \\leq K \\leq 10,000)$ queries and outputs the minimum cost of trip specified by each query. Query $i$ is a pair of numbers $s_i$ and $t_i (1 \\leq s_i \\leq N; 1 \\leq t_i \\leq N; s_i \\neq t_i)$ specifying a starting and ending pasture.\n\nConsider this example diagram with five pastures:\n\nThe 'edge toll' for the path from pasture $1$ to pasture $2$ is $3$. Pasture $2$'s 'node toll' is $5$.\n\nTo travel from pasture $1$ to pasture $4$, traverse pastures $1$ to $3$ to $5$ to $4$. This incurs an edge toll of $2+1+1=4$ and a node toll of $4$ (since pasture $5$'s toll is greatest), for a total cost of $4+4=8$.\n\nThe best way to travel from pasture $2$ to pasture $3$ is to traverse pastures $2$ to $5$ to $3$. This incurs an edge toll of $3+1=4$ and a node toll of $5$, for a total cost of $4+5=9$.\n\n给定一个 $n$ 点 $m$ 边的双向图，第 $i$ 条道路连接了 $u_i$ 与 $v_i$，边权为 $w_i$，第 $i$ 个点的点权为 $c_i$。\n\n给定 $q$ 组询问，第 $i$ 组询问求从 $s_i$ 到 $t_i$ 的路径的边权之和与点权的最大值的和的最小值。\n\n**可能有重边，但保证无自环。**", "inputFormat": "-  Line $1$: Three space separated integers: $N$, $M$, and $K$\n\n- Lines $2..N+1$: Line $i+1$ contains a single integer: $C_i$\n\n- Lines $N+2..N+M+1$: Line $j+N+1$ contains three space separated integers: $A_j$, $B_j$, and $L_j$\n\n- Lines $N+M+2..N+M+K+1$: Line $i+N+M+1$ specifies query $i$ using two space-separated integers: $s_i$ and $t_i$\n\n第一行三个整数 $n,m,q$ 代表点数，边数与询问数。   \n接下来 $n$ 行每行一个整数 $c_i$ 代表第 $i$ 个点的点权。    \n接下来 $m$ 行每行三个整数 $u_i,v_i,w_i$ 代表第 $i$ 条边从 $u_i$ 连到 $v_i$ 边权为 $w_i$。   \n接下来 $q$ 行每行两个整数 $s_i,t_i$ 代表第 $i$ 组询问求从 $s_i$ 到 $t_i$ 的边权之和与点权的最大值的和的最小值。\n", "outputFormat": "- Lines $1..K$: Line $i$ contains a single integer which is the lowest cost of any route from $s_i$ to $t_i$\n\n$q$ 行每行一个整数，代表第 $i$ 组询问的结果。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 250$，$1 \\le m \\le 10^4$，$1 \\le q \\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09DEC] Cow Toll Paths G", "background": "", "description": "Like everyone else, FJ is always thinking up ways to increase his revenue. To this end, he has set up a series of tolls that the cows will pay when they traverse the cowpaths throughout the farm.\n\nThe farm is modeled as an undirected graph with $N$ pastures, conveniently numbered $1..N$, connected by $M$ bidirectional cowpaths. Path $j$ connects two different pastures $A_j$ and $B_j$ and has an edge toll $L_j$. There may be multiple cowpaths connecting the same pair of pastures, but no cowpath connects a pasture to itself. The graph is connected, so a cow can always move from any pasture to any other pasture by following some sequence of cowpaths.\n\nFJ has also assigned a toll $C_i$ to every pasture $i$. The cost of traveling from pasture $s$ to a different pasture $t$ along any path is the sum of the edge tolls on that path plus a single additional toll equal to the maximum of all the node tolls encountered along the way, including $s$ and $t$.\n\nYou are given $K$ queries. Query $i$ specifies $(s_i, t_i)$ and asks for the minimum possible cost of a trip from $s_i$ to $t_i$ under the rule above.", "inputFormat": "- Line $1$: Three space-separated integers $N$, $M$, and $K$.\n- Lines $2..N+1$: Line $i+1$ contains a single integer $C_i$.\n- Lines $N+2..N+M+1$: Line $j+N+1$ contains three space-separated integers $A_j$, $B_j$, and $L_j$.\n- Lines $N+M+2..N+M+K+1$: Line $i+N+M+1$ contains two space-separated integers $s_i$ and $t_i$.", "outputFormat": "- Lines $1..K$: Line $i$ contains a single integer, the minimum cost of any route from $s_i$ to $t_i$.", "hint": "Constraints: $1 \\leq N \\leq 250$, $1 \\leq M \\leq 10^4$, $1 \\leq K \\leq 10^4$, $1 \\leq C_i \\leq 100{,}000$, $1 \\leq L_j \\leq 100{,}000$.\n\nNotes: Multiple edges between a pair of pastures are allowed, but self-loops are not. The graph is connected.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09DEC] Cow Toll Paths G", "background": "", "description": "Like everyone else, FJ is always thinking up ways to increase his revenue. To this end, he has set up a series of tolls that the cows will pay when they traverse the cowpaths throughout the farm.\n\nThe cows move from any of the $N (1 \\leq N \\leq 250)$ pastures conveniently numbered $1...N$ to any other pasture over a set of $M (1 \\leq M \\leq 10,000) $bidirectional cowpaths that connect pairs of different pastures $A_j$ and $B_j (1 \\leq A_j \\leq N; 1 \\leq B_j \\leq N)$. FJ has assigned a toll $L_j (1 \\leq L_j \\leq 100,000)$ to the path connecting pastures $A_j$ and $B_j$.\n\nWhile there may be multiple cowpaths connecting the same pair of pastures, a cowpath will never connect a pasture to itself. Best of all, a cow can always move from any one pasture to any other pasture by following some sequence of cowpaths.\n\nIn an act that can only be described as greedy, FJ has also assigned a toll $C_i (1 \\leq C_i \\leq 100,000)$ to every pasture. The cost of moving from one pasture to some different pasture is the sum of the tolls for each of the cowpaths that were traversed plus a **single additional toll** that is the maximum of all the pasture tolls encountered along the way, including the initial and destination pastures.\n\nThe patient cows wish to investigate their options. They want you to write a program that accepts $K (1 \\leq K \\leq 10,000)$ queries and outputs the minimum cost of trip specified by each query. Query $i$ is a pair of numbers $s_i$ and $t_i (1 \\leq s_i \\leq N; 1 \\leq t_i \\leq N; s_i \\neq t_i)$ specifying a starting and ending pasture.\n\nConsider this example diagram with five pastures:\n\nThe 'edge toll' for the path from pasture $1$ to pasture $2$ is $3$. Pasture $2$'s 'node toll' is $5$.\n\nTo travel from pasture $1$ to pasture $4$, traverse pastures $1$ to $3$ to $5$ to $4$. This incurs an edge toll of $2+1+1=4$ and a node toll of $4$ (since pasture $5$'s toll is greatest), for a total cost of $4+4=8$.\n\nThe best way to travel from pasture $2$ to pasture $3$ is to traverse pastures $2$ to $5$ to $3$. This incurs an edge toll of $3+1=4$ and a node toll of $5$, for a total cost of $4+5=9$.\n\n给定一个 $n$ 点 $m$ 边的双向图，第 $i$ 条道路连接了 $u_i$ 与 $v_i$，边权为 $w_i$，第 $i$ 个点的点权为 $c_i$。\n\n给定 $q$ 组询问，第 $i$ 组询问求从 $s_i$ 到 $t_i$ 的路径的边权之和与点权的最大值的和的最小值。\n\n**可能有重边，但保证无自环。**", "inputFormat": "-  Line $1$: Three space separated integers: $N$, $M$, and $K$\n\n- Lines $2..N+1$: Line $i+1$ contains a single integer: $C_i$\n\n- Lines $N+2..N+M+1$: Line $j+N+1$ contains three space separated integers: $A_j$, $B_j$, and $L_j$\n\n- Lines $N+M+2..N+M+K+1$: Line $i+N+M+1$ specifies query $i$ using two space-separated integers: $s_i$ and $t_i$\n\n第一行三个整数 $n,m,q$ 代表点数，边数与询问数。   \n接下来 $n$ 行每行一个整数 $c_i$ 代表第 $i$ 个点的点权。    \n接下来 $m$ 行每行三个整数 $u_i,v_i,w_i$ 代表第 $i$ 条边从 $u_i$ 连到 $v_i$ 边权为 $w_i$。   \n接下来 $q$ 行每行两个整数 $s_i,t_i$ 代表第 $i$ 组询问求从 $s_i$ 到 $t_i$ 的边权之和与点权的最大值的和的最小值。\n", "outputFormat": "- Lines $1..K$: Line $i$ contains a single integer which is the lowest cost of any route from $s_i$ to $t_i$\n\n$q$ 行每行一个整数，代表第 $i$ 组询问的结果。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 250$，$1 \\le m \\le 10^4$，$1 \\le q \\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P2967", "type": "P", "difficulty": 5, "samples": [["3 800 \n300 2 30 50 25 80 \n600 1 50 130 \n400 3 40 70 30 40 35 60 \n", "210 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "USACO", "背包 DP"], "title": "[USACO09DEC] Video Game Troubles G", "background": "", "description": "Farmer John's cows love their video games! FJ noticed that after playing these games that his cows produced much more milk than usual, surely because contented cows make more milk.\n\nThe cows disagree, though, on which is the best game console. One cow wanted to buy the Xbox 360 to play Halo 3; another wanted to buy the Nintendo Wii to play Super Smash Brothers Brawl; a third wanted to play Metal Gear Solid 4 on the PlayStation 3. FJ wants to purchase the set of game consoles (no more than one each) and games (no more than one each -- and within the constraints of a given budget) that helps his cows produce the most milk and thus nourish the most children.\n\nFJ researched N (1 <= N <= 50) consoles, each with a console price P\\_i (1 <= P\\_i <= 1000) and a number of console-specific games G\\_i (1 <= G\\_i <= 10). A cow must, of course, own a console before she can buy any game that is specific to that console. Each individual game has a game price GP\\_j (1 <= GP\\_j price <= 100) and a production value (1 <= PV\\_j <= 1,000,000), which indicates how much milk a cow will produce after playing the game. Lastly, Farmer John has a budget V (1 <= V <= 100,000) which is the maximum amount of money he can spend. Help him maximize the sum of the production values of the games he buys.\n\nConsider one dataset with N=3 consoles and a V=$800 budget. The first console costs $300 and has 2 games with cost $30 and $25 and production values as shown:\n\nGame #    Cost    Production Value\n\n1       $30          50\n\n2       $25          80\n\nThe second console costs $600 and has only 1 game:\n\nGame #    Cost    Production Value\n\n1       $50          130\n\nThe third console costs $400 and has 3 games:\n\nGame #    Cost    Production Value\n\n1       $40         70\n\n2       $30         40\n\n3       $35         60\n\nFarmer John should buy consoles 1 and 3, game 2 for console 1, and games 1 and 3 for console 3 to maximize his expected production at 210:\n\n```cpp\n                                Production Value\n        Budget:     $800      \n        Console 1  -$300\n           Game 2   -$25              80\n        Console 3  -$400\n           Game 1   -$40              70\n           Game 3   -$35              60\n      -------------------------------------------\n        Total:         0 (>= 0)      210\n```\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and V\n\n\\* Lines 2..N+1: Line i+1 describes the price of and the games\n\navailable for console i; it contains: P\\_i, G\\_i, and G\\_i pairs of space-separated integers GP\\_j, PV\\_j\n", "outputFormat": "\\* Line 1: The maximum production value that Farmer John can get with his budget.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO09DEC] Video Game Troubles G", "background": "", "description": "Farmer John's cows love their video games! FJ noticed that after playing these games that his cows produced much more milk than usual, surely because contented cows make more milk.\n\nThe cows disagree, though, on which is the best game console. One cow wanted to buy the Xbox 360 to play Halo 3; another wanted to buy the Nintendo Wii to play Super Smash Brothers Brawl; a third wanted to play Metal Gear Solid 4 on the PlayStation 3. FJ wants to purchase the set of game consoles (no more than one each) and games (no more than one each -- and within the constraints of a given budget) that helps his cows produce the most milk and thus nourish the most children.\n\nFJ researched N (1 <= N <= 50) consoles, each with a console price P\\_i (1 <= P\\_i <= 1000) and a number of console-specific games G\\_i (1 <= G\\_i <= 10). A cow must, of course, own a console before she can buy any game that is specific to that console. Each individual game has a game price GP\\_j (1 <= GP\\_j price <= 100) and a production value (1 <= PV\\_j <= 1,000,000), which indicates how much milk a cow will produce after playing the game. Lastly, Farmer John has a budget V (1 <= V <= 100,000) which is the maximum amount of money he can spend. Help him maximize the sum of the production values of the games he buys.\n\nConsider one dataset with N=3 consoles and a V=$800 budget. The first console costs $300 and has 2 games with cost $30 and $25 and production values as shown:\n\nGame #    Cost    Production Value\n\n1       $30          50\n\n2       $25          80\n\nThe second console costs $600 and has only 1 game:\n\nGame #    Cost    Production Value\n\n1       $50          130\n\nThe third console costs $400 and has 3 games:\n\nGame #    Cost    Production Value\n\n1       $40         70\n\n2       $30         40\n\n3       $35         60\n\nFarmer John should buy consoles 1 and 3, game 2 for console 1, and games 1 and 3 for console 3 to maximize his expected production at 210:\n\n```cpp\n                                Production Value\n        Budget:     $800      \n        Console 1  -$300\n           Game 2   -$25              80\n        Console 3  -$400\n           Game 1   -$40              70\n           Game 3   -$35              60\n      -------------------------------------------\n        Total:         0 (>= 0)      210\n```\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and V\n\n\\* Lines 2..N+1: Line i+1 describes the price of and the games\n\navailable for console i; it contains: P\\_i, G\\_i, and G\\_i pairs of space-separated integers GP\\_j, PV\\_j\n", "outputFormat": "\\* Line 1: The maximum production value that Farmer John can get with his budget.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO09DEC] Video Game Troubles G", "background": null, "description": "农夫约翰的奶牛们非常喜欢玩电子游戏！FJ 发现，在玩了这些游戏后，他的奶牛产的奶比平时多得多，这肯定是因为快乐的奶牛产奶更多。\n\n然而，奶牛们对于哪个是最好的游戏机存在分歧。一头奶牛想买 Xbox 360 来玩《光环 3》；另一头想买任天堂 Wii 来玩《任天堂明星大乱斗》；第三头想在 PlayStation 3 上玩《合金装备 4》。FJ 想购买一些游戏机（每种不超过一台）和游戏（每种不超过一款并在给定预算的限制内），以帮助他的奶牛产出最多的牛奶，从而养育更多的孩子。\n\nFJ 调查了 $N$ 台游戏机（$1 \\leq N \\leq 50$），每台游戏机的价格为 $P_i$（$1 \\leq P_i \\leq 1000$），以及独占发布于该游戏机的游戏数量 $G_i$（$1 \\leq G_i \\leq 10$）。当然，奶牛必须先拥有这台游戏机，才能购买该游戏机独占的任何游戏。每款游戏都有一个游戏价格 $GP_j$（$1 \\leq GP_j \\leq 100$）和一个生产值（$1 \\leq PV_j \\leq 1,000,000$），表示奶牛在玩游戏后会产出多少牛奶。最后，农夫约翰有一个预算 $V$（$1 \\leq V \\leq 100,000$），这是他最多能花的钱。帮助他最大化他购买的游戏的生产值之和。\n\n考虑一个例子，$N=3$ 台游戏机，预算 $V=800$ 美元。\n\n第一台游戏机价格为 $300$ 美元，并有两个游戏，价格分别为 $30$ 美元和 $25$ 美元，生产值如下所示：\n| 游戏编号 | 价格 | 生产值 |\n|:-:|:-:|:-:|\n|$1$|\\$$30$|$50$|\n|$2$|\\$$25$|$80$|\n\n第二台游戏机价格为 $600$ 美元，只有一个游戏：\n| 游戏编号 | 价格 | 生产值 |\n|:-:|:-:|:-:|\n|$1$|\\$$50$|$130$|\n\n第三台游戏机价格为 $400$ 美元，有三个游戏：\n| 游戏编号 | 价格 | 生产值 |\n|:-:|:-:|:-:|\n|$1$|\\$$40$|$70$|\n|$2$|\\$$30$|$40$|\n|$3$|\\$$35$|$60$|\n\n农夫约翰应该购买游戏机 $1$ 和 $3$，游戏机 $1$ 的游戏 $2$，以及游戏机 $3$ 的游戏 $1$ 和 $3$，以最大化他所购买游戏的生产值。该值为 210：\n\n```cpp\n                                  生产值\n        预算:      $800      \n        游戏机 1  -$300\n          游戏 2  -$25              80\n        游戏机 3  -$400\n          游戏 1  -$40              70\n          游戏 3  -$35              60\n      -------------------------------------------\n        总计:        0 (>= 0)      210\n```", "inputFormat": "输入第 $1$ 行为两个用空格分隔的整数：$N$ 和 $V$\n\n第 $2$ 到 $N+1$ 行：第 $i+1$ 行描述了游戏机 $i$ 的价格 $P_i$ 和其独占的游戏数量 $G_i$，接下来后面有 $G_i$ 对用空格分隔的整数 $GP_j$ 和 $PV_j$，描述其独占的各款游戏的信息。", "outputFormat": "输出 $1$ 个整数，表示农夫约翰在他的预算内可以获得的最大生产值。", "hint": "（由 ChatGPT 4o 进行翻译）", "locale": "zh-CN"}}}
{"pid": "P2968", "type": "P", "difficulty": 4, "samples": [["14 3 \n7 3 \n11 1 \n13 8 \n", "5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09DEC] Bobsledding S", "background": "", "description": "Bessie 从山顶滑雪到山脚，山顶到山脚的距离是 $L$（$2 \\le L \\le 10^9$）。\n\nBessie 在起点的速度是 $1$，她可以在滑行的过程中改变速度：如果上一米的速度是 $v_0$，这一米的速度可以是 $v_0 + 1$、$v_0 - 1$ 或 $v_0$。\n\nBessie 会遇到 $N$（$1 \\le N \\le 10^5$）个转弯处，第 $i$ 个转弯处和出发点的距离是 $T_i$（$1 \\le T_i < L$）。为了安全，她到达第 $i$ 个转弯处时的速度不能超过 $S_i$（$1 \\le S_i \\le 10^9$）。贝茜到达终点时的速度没有最大限制。\n\n求 Bessie 在滑雪过程中的最高速度。", "inputFormat": "第一行两个正整数 $L$ 和 $N$。\n\n第 $i + 1$（$1 \\le i \\le N$）行两个正整数 $T_i$ 和 $S_i$。", "outputFormat": "一个整数，表示 Bessie 在滑雪过程中的最高速度。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09DEC] Bobsledding S", "background": null, "description": "Bessie has entered a bobsled competition because she hopes her hefty weight will give her an advantage over the $L$ meter course ($2 \\le L \\le 10^9$).\n\nBessie pushes off the starting line at $1$ meter per second, and her speed can change while she travels along the course. Near the middle of every meter Bessie covers, she can change her speed by using gravity to accelerate by $1$ meter per second, or by braking to keep the same speed or decrease her speed by $1$ meter per second.\n\nOn the way down the hill, Bessie must negotiate $N$ turns ($1 \\le N \\le 10^5$). Turn $i$ is located $T_i$ meters from the start ($1 \\le T_i < L$), and she must enter the meter that contains turn $i$ at a speed of at most $S_i$ meters per second ($1 \\le S_i \\le 10^9$). Bessie may cross the finish line at any speed.\n\nHelp Bessie determine the maximum speed she can attain anywhere on the course without exceeding the speed limits at the turns.\n\nConsider this course with the meter markers as integers and the turn speed limits in brackets (for example, \"[3]\"):\n\n```\n\n|   1   2   3   4   5   6   7[3]\n|---+---+---+---+---+---+---+\n|                            \\\nStart                         + 8    \n                               \\\n                                + 9    \n                                 \\\n                                  + 10       +++ 14 (finish)\n                                   \\         /\n                              11[1] +---+---+\n                                        12  13[8]\n```\n\nBelow is a chart of Bessie's speeds at the beginning of each meter along the course:\n\n```\nMax:                              3               1       8 \nMtrs: 0   1   2   3   4   5   6   7   8   9  10  11  12  13  14\nSpd:  1   2   3   4   5   5   4   3   4   3   2   1   2   3   4 \n```\n\nHer maximum speed was $5$ near the beginning of meter $4$.", "inputFormat": "* Line $1$: Two space-separated integers: $L$ and $N$.\n* Lines $2$ to $N+1$: Line $i+1$ describes turn $i$ with two space-separated integers: $T_i$ and $S_i$.", "outputFormat": "* Line 1: A single integer, representing the maximum speed that Bessie can attain between the start and the finish line, inclusive.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO09DEC] Bobsledding S", "background": "", "description": "Bessie 从山顶滑雪到山脚，山顶到山脚的距离是 $L$（$2 \\le L \\le 10^9$）。\n\nBessie 在起点的速度是 $1$，她可以在滑行的过程中改变速度：如果上一米的速度是 $v_0$，这一米的速度可以是 $v_0 + 1$、$v_0 - 1$ 或 $v_0$。\n\nBessie 会遇到 $N$（$1 \\le N \\le 10^5$）个转弯处，第 $i$ 个转弯处和出发点的距离是 $T_i$（$1 \\le T_i < L$）。为了安全，她到达第 $i$ 个转弯处时的速度不能超过 $S_i$（$1 \\le S_i \\le 10^9$）。贝茜到达终点时的速度没有最大限制。\n\n求 Bessie 在滑雪过程中的最高速度。", "inputFormat": "第一行两个正整数 $L$ 和 $N$。\n\n第 $i + 1$（$1 \\le i \\le N$）行两个正整数 $T_i$ 和 $S_i$。", "outputFormat": "一个整数，表示 Bessie 在滑雪过程中的最高速度。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2969", "type": "P", "difficulty": 2, "samples": [["3 5 \n2 \n1 \n3 \n2 \n3 \n4 \n0 \n1 \n", "2 \n3 \n3 \n1 \n1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO", "排序", "前缀和"], "title": "[USACO09DEC] Music Notes S", "background": "", "description": "FJ is going to teach his cows how to play a song. The song consists of N (1 <= N <= 50,000) notes, and the i-th note lasts for B\\_i (1 <= B\\_i <= 10,000) beats (thus no song is longer than 500,000,000 beats). The cows will begin playing the song at time 0; thus, they will play note 1 from time 0 through just before time B\\_1, note 2 from time B\\_1 through just before time B\\_1 + B\\_2, etc.\n\nHowever, recently the cows have lost interest in the song, as they feel that it is too long and boring. Thus, to make sure his cows are paying attention, he asks them Q (1 <= Q <= 50,000) questions of the form, 'In the interval from time T through just before time T+1, which note should you be playing?' The cows need your help to answer these questions which are supplied as T\\_i (0 <= T\\_i <=\n\nend\\_of\\_song). \n\nConsider this song with three notes of durations 2, 1, and 3 beats:\n\n```cpp\nBeat:   0    1    2    3    4    5    6    ...\n        |----|----|----|----|----|----|--- ...\n        1111111111     :              :\n                  22222:              :\n                       333333333333333:\n``` \nHere is a set of five queries along with the resulting answer:\n\nQuery    Note\n\n2        2\n\n3        3\n\n4        3\n\n0        1\n\n1        1\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and Q\n\n\\* Lines 2..N+1: Line i+1 contains the single integer: B\\_i\n\n\\* Lines N+2..N+Q+1: Line N+i+1 contains a single integer: T\\_i\n", "outputFormat": "\\* Lines 1..Q: For each query, print a single integer that is the index of the note that the cows should be playing.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO09DEC] Music Notes S", "background": "", "description": "FJ is going to teach his cows how to play a song. The song consists of N (1 <= N <= 50,000) notes, and the i-th note lasts for B\\_i (1 <= B\\_i <= 10,000) beats (thus no song is longer than 500,000,000 beats). The cows will begin playing the song at time 0; thus, they will play note 1 from time 0 through just before time B\\_1, note 2 from time B\\_1 through just before time B\\_1 + B\\_2, etc.\n\nHowever, recently the cows have lost interest in the song, as they feel that it is too long and boring. Thus, to make sure his cows are paying attention, he asks them Q (1 <= Q <= 50,000) questions of the form, 'In the interval from time T through just before time T+1, which note should you be playing?' The cows need your help to answer these questions which are supplied as T\\_i (0 <= T\\_i <=\n\nend\\_of\\_song). \n\nConsider this song with three notes of durations 2, 1, and 3 beats:\n\n```cpp\nBeat:   0    1    2    3    4    5    6    ...\n        |----|----|----|----|----|----|--- ...\n        1111111111     :              :\n                  22222:              :\n                       333333333333333:\n``` \nHere is a set of five queries along with the resulting answer:\n\nQuery    Note\n\n2        2\n\n3        3\n\n4        3\n\n0        1\n\n1        1\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and Q\n\n\\* Lines 2..N+1: Line i+1 contains the single integer: B\\_i\n\n\\* Lines N+2..N+Q+1: Line N+i+1 contains a single integer: T\\_i\n", "outputFormat": "\\* Lines 1..Q: For each query, print a single integer that is the index of the note that the cows should be playing.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO09DEC] Music Notes S", "background": "", "description": "FJ 准备教他的奶牛们演奏一首歌曲。这首歌由 $N$ 个音符组成，其中第 $i$ 个音符持续 $B_i$ 个节拍（$1 \\leq N \\leq 50,000$，$1 \\leq B_i \\leq 10,000$），因此整首歌的长度不会超过 500,000,000 个节拍。奶牛们将在时间 0 开始演奏这首歌，因此它们将在时间 0 到时间 $B_1$ 之前演奏第 1 个音符，在时间 $B_1$ 到时间 $B_1 + B_2$ 之前演奏第 2 个音符，依此类推。\n\n然而，最近奶牛们对这首歌失去了兴趣，因为它们觉得这首歌太长且无聊。因此，为了确保奶牛们集中注意力，他向它们提出了 $Q$ 个问题（$1 \\leq Q \\leq 50,000$），问题的形式为「在时间 $T$ 到时间 $T+1$ 之前的区间内，你应该演奏哪个音符？」奶牛们需要你的帮助来回答这些问题，这些问题以 $T_i$ 的形式给出（$0 \\leq T_i \\leq \\text{end\\_of\\_song}$）。\n\n考虑这首由三个音符组成的歌曲，音符的持续时间分别为 2、1 和 3 个节拍：\n\n```cpp\nBeat:   0    1    2    3    4    5    6    ...\n        |----|----|----|----|----|----|--- ...\n        1111111111     :              :\n                  22222:              :\n                       333333333333333:\n``` \n这里有一组五个查询及其对应的答案：\n\nQuery    Note\n\n2        2\n\n3        3\n\n4        3\n\n0        1\n\n1        1\n", "inputFormat": "\\* 第 1 行：两个用空格分隔的整数：$N$ 和 $Q$\n\n\\* 第 2 行到第 $N+1$ 行：第 $i+1$ 行包含一个整数：$B_i$\n\n\\* 第 $N+2$ 行到第 $N+Q+1$ 行：第 $N+i+1$ 行包含一个整数：$T_i$\n", "outputFormat": "\\* 第 1 行到第 $Q$ 行：对于每个查询，输出一个整数，表示奶牛们应该演奏的音符的索引。\n", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2970", "type": "P", "difficulty": 2, "samples": [["5 \n2 4 \n1 12 \n4 5 \n7 10 \n7 8 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2009", "USACO", "排序"], "title": "[USACO09DEC] Selfish Grazing S", "background": "", "description": "Each of Farmer John's N (1 <= N <= 50,000) cows likes to graze in a certain part of the pasture, which can be thought of as a large one-dimeensional number line. Cow i's favorite grazing range starts at location S\\_i and ends at location E\\_i (1 <= S\\_i < E\\_i; S\\_i < E\\_i <= 100,000,000).\n\nMost folks know the cows are quite selfish; no cow wants to share any of its grazing area with another. Thus, two cows i and j can only graze at the same time if either S\\_i >= E\\_j or E\\_i <= S\\_j. FJ would like to know the maximum number of cows that can graze at the same time for a given set of cows and their preferences.\n\nConsider a set of 5 cows with ranges shown below:\n\n```cpp\n  ... 1    2    3    4    5    6    7    8    9   10   11   12   13 ...\n  ... |----|----|----|----|----|----|----|----|----|----|----|----|----\nCow 1:      <===:===>          :              :              :\nCow 2: <========:==============:==============:=============>:\nCow 3:          :     <====>   :              :              :\nCow 4:          :              :     <========:===>          :\nCow 5:          :              :     <==>     :              :\n```\nThese ranges represent (2, 4), (1, 12), (4, 5), (7, 10), and (7, 8), respectively.\n\nFor a solution, the first, third, and fourth (or fifth) cows can all graze at the same time. If the second cow grazed, no other cows could graze. Also, the fourth and fifth cows cannot graze together, so it is impossible for four or more cows to graze.\n\n约翰有N(1≤N≤50000)头牛，约翰的草地可以认为是一条直线．每只牛只喜欢在某个特定的范围内吃草．第i头牛喜欢在区间(Si，Ei)吃草，1≤Si<Ei≤1,000,000,00.\n\n奶牛们都很自私，他们不喜欢和其他奶牛共享自己喜欢吃草的领域，因此约翰要保证任意\n\n两头牛都不会共享他们喜欢吃草昀领域．如果奶牛i和奶牛J想要同时吃草，那么要满足：Si>=Ej或者Ei≤Sj．约翰想知道在同一时刻，最多可以有多少头奶牛同时吃草？\n", "inputFormat": "\\* Line 1: A  single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains the two space-separated integers: S\\_i and E\\_i\n", "outputFormat": "\\* Line 1: A single integer representing the maximum number of cows that can graze at once.\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09DEC] Selfish Grazing S", "background": "", "description": "Each of Farmer John’s $N$ cows ($1 \\le N \\le 50{,}000$) likes to graze in a specific part of the pasture, which can be modeled as a large one-dimensional number line. Cow $i$’s favorite grazing range starts at location $S_i$ and ends at location $E_i$ ($1 \\le S_i < E_i \\le 100{,}000{,}000$).\n\nCows are quite selfish; no cow wants to share any of its grazing area with another. Thus, two cows $i$ and $j$ can graze at the same time only if $S_i \\ge E_j$ or $E_i \\le S_j$. Farmer John would like to know the maximum number of cows that can graze at the same time for a given set of cows and their preferences.\n\nConsider a set of 5 cows with ranges shown below:\n\n```cpp\n  ... 1    2    3    4    5    6    7    8    9   10   11   12   13 ...\n  ... |----|----|----|----|----|----|----|----|----|----|----|----|----\nCow 1:      <===:===>          :              :              :\nCow 2: <========:==============:==============:=============>:\nCow 3:          :     <====>   :              :              :\nCow 4:          :              :     <========:===>          :\nCow 5:          :              :     <==>     :              :\n```\n\nThese ranges represent (2, 4), (1, 12), (4, 5), (7, 10), and (7, 8), respectively.\n\nAs a solution, the first, third, and fourth (or fifth) cows can all graze at the same time. If the second cow grazed, no other cows could graze. Also, the fourth and fifth cows cannot graze together, so it is impossible for four or more cows to graze.", "inputFormat": "- Line 1: A single integer $N$.\n- Lines 2..$N+1$: Line $i+1$ contains two space-separated integers $S_i$ and $E_i$.", "outputFormat": "- Line 1: A single integer representing the maximum number of cows that can graze at once.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09DEC] Selfish Grazing S", "background": "", "description": "Each of Farmer John's N (1 <= N <= 50,000) cows likes to graze in a certain part of the pasture, which can be thought of as a large one-dimeensional number line. Cow i's favorite grazing range starts at location S\\_i and ends at location E\\_i (1 <= S\\_i < E\\_i; S\\_i < E\\_i <= 100,000,000).\n\nMost folks know the cows are quite selfish; no cow wants to share any of its grazing area with another. Thus, two cows i and j can only graze at the same time if either S\\_i >= E\\_j or E\\_i <= S\\_j. FJ would like to know the maximum number of cows that can graze at the same time for a given set of cows and their preferences.\n\nConsider a set of 5 cows with ranges shown below:\n\n```cpp\n  ... 1    2    3    4    5    6    7    8    9   10   11   12   13 ...\n  ... |----|----|----|----|----|----|----|----|----|----|----|----|----\nCow 1:      <===:===>          :              :              :\nCow 2: <========:==============:==============:=============>:\nCow 3:          :     <====>   :              :              :\nCow 4:          :              :     <========:===>          :\nCow 5:          :              :     <==>     :              :\n```\nThese ranges represent (2, 4), (1, 12), (4, 5), (7, 10), and (7, 8), respectively.\n\nFor a solution, the first, third, and fourth (or fifth) cows can all graze at the same time. If the second cow grazed, no other cows could graze. Also, the fourth and fifth cows cannot graze together, so it is impossible for four or more cows to graze.\n\n约翰有N(1≤N≤50000)头牛，约翰的草地可以认为是一条直线．每只牛只喜欢在某个特定的范围内吃草．第i头牛喜欢在区间(Si，Ei)吃草，1≤Si<Ei≤1,000,000,00.\n\n奶牛们都很自私，他们不喜欢和其他奶牛共享自己喜欢吃草的领域，因此约翰要保证任意\n\n两头牛都不会共享他们喜欢吃草昀领域．如果奶牛i和奶牛J想要同时吃草，那么要满足：Si>=Ej或者Ei≤Sj．约翰想知道在同一时刻，最多可以有多少头奶牛同时吃草？\n", "inputFormat": "\\* Line 1: A  single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains the two space-separated integers: S\\_i and E\\_i\n", "outputFormat": "\\* Line 1: A single integer representing the maximum number of cows that can graze at once.\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2971", "type": "P", "difficulty": 4, "samples": [["6 2 \n1 3 \n2 1 \n1 0 \n2 1 \n2 1 \n1 5 \n", "3 \n2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO", "树上启发式合并", "最近公共祖先 LCA", "树的直径", "树论"], "title": "[USACO10HOL] Cow Politics G", "background": null, "description": "农夫约翰的奶牛住在 $n$ 片不同的草地上，标号为 $1\\sim n$。\n\n恰好有 $n-1$ 条单位长度的双向道路，用各种各样的方法连接这些草地。而且从每片草地出发都可以抵达其他所有草地。也就是说，这些草地和道路构成了一种叫做树的图。输入包含一个详细的草地的集合，详细说明了每个草地的父节点 $p_i$。根节点的 $p_i=0$, 表示它没有父节点。\n\n因为奶牛建立了 $1\\sim k$ 一共 $k$ 个政党。每只奶牛都要加入某一个政党，其中， 第 $i$ 只奶牛属于第 $a_i$ 个政党。而且每个政党至少有两只奶牛。 每个政党都想知道自己的“范围”有多大。其中，定义一个政党的范围是这个政党离得最远的两只奶牛（沿着双向道路行走）的距离。", "inputFormat": "第一行两个整数 $n,k$。\n\n第 $2\\sim n+1$ 行：第 $i+1$ 行两个整数 $a_i,p_i$。", "outputFormat": "一共 $K$ 行，第 $i$ 行一个整数表示第 $i$ 个政党的范围。", "hint": "数据范围：$2 \\le n \\le 2\\times10^5,1 \\le k \\le \\frac n2,0\\le p_i\\le n,1\\le a_i\\le k$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10HOL] Cow Politics G", "background": "", "description": "Farmer John's cows live on $n$ different pastures, numbered $1 \\sim n$.\n\nThere are exactly $n-1$ undirected roads of unit length connecting these pastures, and from any pasture you can reach all others. In other words, the pastures and roads form a tree. The input specifies, for each pasture $i$, its parent $p_i$. The root has $p_i = 0$, meaning it has no parent.\n\nThere are $k$ political parties numbered $1 \\sim k$. Each cow joins exactly one party; specifically, cow $i$ (at pasture $i$) belongs to party $a_i$. Each party has at least two cows. Every party wants to know its \"range\", defined as the distance (along the undirected roads) between the farthest pair of cows within that party.", "inputFormat": "The first line contains two integers $n, k$.\n\nLines $2 \\sim n+1$: line $i+1$ contains two integers $a_i, p_i$.", "outputFormat": "Output $k$ lines. The $i$-th line contains a single integer, the range of party $i$.", "hint": "Constraints: $2 \\le n \\le 2 \\times 10^5, 1 \\le k \\le \\frac n2, 0 \\le p_i \\le n, 1 \\le a_i \\le k$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10HOL] Cow Politics G", "background": null, "description": "农夫约翰的奶牛住在 $n$ 片不同的草地上，标号为 $1\\sim n$。\n\n恰好有 $n-1$ 条单位长度的双向道路，用各种各样的方法连接这些草地。而且从每片草地出发都可以抵达其他所有草地。也就是说，这些草地和道路构成了一种叫做树的图。输入包含一个详细的草地的集合，详细说明了每个草地的父节点 $p_i$。根节点的 $p_i=0$, 表示它没有父节点。\n\n因为奶牛建立了 $1\\sim k$ 一共 $k$ 个政党。每只奶牛都要加入某一个政党，其中， 第 $i$ 只奶牛属于第 $a_i$ 个政党。而且每个政党至少有两只奶牛。 每个政党都想知道自己的“范围”有多大。其中，定义一个政党的范围是这个政党离得最远的两只奶牛（沿着双向道路行走）的距离。", "inputFormat": "第一行两个整数 $n,k$。\n\n第 $2\\sim n+1$ 行：第 $i+1$ 行两个整数 $a_i,p_i$。", "outputFormat": "一共 $K$ 行，第 $i$ 行一个整数表示第 $i$ 个政党的范围。", "hint": "数据范围：$2 \\le n \\le 2\\times10^5,1 \\le k \\le \\frac n2,0\\le p_i\\le n,1\\le a_i\\le k$。", "locale": "zh-CN"}}}
{"pid": "P2972", "type": "P", "difficulty": 5, "samples": [["3 2 10 \n1 5 \n1 3 \n2 3 \n3 1 \n", "No \nYes \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2010", "USACO"], "title": "[USACO10HOL] Rocks and Trees G", "background": "```\nMy country's bigger than most\nAnd if asked I boast\n'Cause I'm really proud\nSo I shout it loud\nThough our numbers are few\nWe will welcome you\nAlthough we don't have history\nGold medal winning teams\nHeroes or prisoners\nWorld famous volcanoes\nStill what we've got's glorious\n'Cause we've got\nRocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd water\n-The Arrogant Worms, on Canada\n（本段为诗歌，具体内容与题目无关）", "description": "After moving across the 49th parallel to Canada, the land of rocks and trees, Farmer John's cows invented a game to spend their leisure time on the pasture; naturally, it involved the rocks and trees! Cowboy Ted likes this game very much, but so poor is his luck that he always loses to other cows. This time, he is going to seek your help. \n\nThe game's rules are simple. It is played with a tree that has both $N$$(2 \\leqslant N \\leqslant10000)$nodes conveniently numbered $1 \\cdots N$ and also $N-1$ branches. Node 1 is the root of this tree; except for node 1, node $i$ has parent $P_i$ $(1 \\leqslant P_i < i)$. Initially, Each node contains some rocks (except the root node, which has no rocks). In particular, non-root node $i$ has exactly $R_i (1 \\leqslant R_i \\leqslant 1000)$ rocks at the beginning of the game. \n\nTwo players alternate turns to play this game in turn, with Ted going first. In each turn, the current player can choose a non-root node $i$ and move at most $L (1 \\leqslant L \\leqslant 1000)$ rocks from this node one branch closer to the root (i.e., move these rocks to the parent node). He must move at least one rock, and, of course, he cannot exceed the current number of rocks on this node. The game ends when a player can't make a legal move (i.e., when all the rocks are on node 1); that player loses. \n\nTed needs your help. He has given you the initial configuration of the game, and he will then make $T (1 \\leqslant T \\leqslant 10000)$changes to the configuration one by one. Please help him determine, after each step, if he can win the game beginning from this configuration, assuming both he and his opponent use the best possible strategy. \n\nTed's changes are specified as two integers $A_j (1 < A_j \\leqslant N)$ and $B_j (1 \\leqslant B_j \\leqslant 1000)$, meaning that Ted will change the number of rocks on node $A_j$ to $B_j$ (this is a `set` not a `subtract` or `add`), and will then ask you whether he can win. Changes accumulate; node $A_j$'s rocks stay at $B_j$ until another change for $A_j$ appears.\n\nConsider this example with three nodes numbered as shown and the shape shown in Board 0. Initially, there are 5 rocks on node 2 and 3 rocks on node 3; see Board 1.\n\nFor the first change, Ted removes 2 rocks from node 2 (thus leaving 3); see Board 2. For the second change, Ted removes 2 rocks from node 3 (thus leaving 1). Note that node 2 still has 3 rocks; see Board 3.\n\nBoard 0 Board 1 Board 2 Board 3\n\n（原题面并未给出链接）\n\nYour program should determine in each case who wins.\n\nFor about 30% of the test cases, $N \\leqslant 10$, and $T \\leqslant 100$, and no tree node will have more than 5 rocks on it after any of Ted's changes.\n\nPartial feedback will be provided for your first $50$ submissions.", "inputFormat": "Line $1$: Three space-separated integers: $N$, $T$, and $L$.  \nLines $2 \\cdots N$: Line i contains two space-separted integers: $P_i$ and $R_i$.  \nLines $N+1 \\cdots N+T$: Line $j+N$ describes Ted's next change using two space-separated integers: $A_j$ and $B_j$.", "outputFormat": "Lines $1 \\cdots T$: Line $i$ contains `Yes` if Ted can win the game after change $i$; and `No` otherwise.", "hint": "数据来源：bzoj。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10HOL] Rocks and Trees G", "background": "```\nMy country's bigger than most\nAnd if asked I boast\n'Cause I'm really proud\nSo I shout it loud\nThough our numbers are few\nWe will welcome you\nAlthough we don't have history\nGold medal winning teams\nHeroes or prisoners\nWorld famous volcanoes\nStill what we've got's glorious\n'Cause we've got\nRocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd water\n-The Arrogant Worms, on Canada\n（本段为诗歌，具体内容与题目无关）\n```\n\n(This passage is a poem; the content is unrelated to the problem.)", "description": "After moving across the 49th parallel to Canada, the land of rocks and trees, Farmer John's cows invented a game to spend their leisure time on the pasture; naturally, it involved the rocks and trees! Cowboy Ted likes this game very much, but so poor is his luck that he always loses to other cows. This time, he is going to seek your help.\n\nThe game's rules are simple. It is played with a tree that has both $N$ $(2 \\leqslant N \\leqslant10000)$ nodes conveniently numbered $1 \\cdots N$ and also $N-1$ branches. Node 1 is the root of this tree; except for node 1, node $i$ has parent $P_i$ $(1 \\leqslant P_i < i)$. Initially, each node contains some rocks (except the root node, which has no rocks). In particular, non-root node $i$ has exactly $R_i$ $(1 \\leqslant R_i \\leqslant 1000)$ rocks at the beginning of the game.\n\nTwo players alternate turns to play this game, with Ted going first. In each turn, the current player can choose a non-root node $i$ and move at most $L$ $(1 \\leqslant L \\leqslant 1000)$ rocks from this node one branch closer to the root (i.e., move these rocks to the parent node). He must move at least one rock, and, of course, he cannot exceed the current number of rocks on this node. The game ends when a player can't make a legal move (i.e., when all the rocks are on node 1); that player loses.\n\nTed needs your help. He has given you the initial configuration of the game, and he will then make $T$ $(1 \\leqslant T \\leqslant 10000)$ changes to the configuration one by one. Please help him determine, after each step, if he can win the game beginning from this configuration, assuming both he and his opponent use the best possible strategy.\n\nTed's changes are specified as two integers $A_j$ $(1 < A_j \\leqslant N)$ and $B_j$ $(1 \\leqslant B_j \\leqslant 1000)$, meaning that Ted will change the number of rocks on node $A_j$ to $B_j$ (this is a \"set\", not a \"subtract\" or \"add\"), and will then ask you whether he can win. Changes accumulate; node $A_j$'s rocks stay at $B_j$ until another change for $A_j$ appears.\n\nConsider this example with three nodes numbered as shown and the shape shown in Board 0. Initially, there are 5 rocks on node 2 and 3 rocks on node 3; see Board 1.\n\nFor the first change, Ted removes 2 rocks from node 2 (thus leaving 3); see Board 2. For the second change, Ted removes 2 rocks from node 3 (thus leaving 1). Note that node 2 still has 3 rocks; see Board 3.\n\nBoard 0 Board 1 Board 2 Board 3\n\n(No link is provided in the original statement.)\n\nYour program should determine in each case who wins.\n\nFor about 30% of the test cases, $N \\leqslant 10$, and $T \\leqslant 100$, and no tree node will have more than 5 rocks on it after any of Ted's changes.\n\nPartial feedback will be provided for your first $50$ submissions.", "inputFormat": "Line $1$: Three space-separated integers: $N$, $T$, and $L$.  \nLines $2 \\cdots N$: Line $i$ contains two space-separated integers: $P_i$ and $R_i$.  \nLines $N+1 \\cdots N+T$: Line $j+N$ describes Ted's next change using two space-separated integers: $A_j$ and $B_j$.", "outputFormat": "Lines $1 \\cdots T$: Line $i$ contains \"Yes\" if Ted can win the game after change $i$, and \"No\" otherwise.", "hint": "Testdata source: bzoj.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10HOL] Rocks and Trees G", "background": "```\nMy country's bigger than most\nAnd if asked I boast\n'Cause I'm really proud\nSo I shout it loud\nThough our numbers are few\nWe will welcome you\nAlthough we don't have history\nGold medal winning teams\nHeroes or prisoners\nWorld famous volcanoes\nStill what we've got's glorious\n'Cause we've got\nRocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd water\n-The Arrogant Worms, on Canada\n（本段为诗歌，具体内容与题目无关）", "description": "After moving across the 49th parallel to Canada, the land of rocks and trees, Farmer John's cows invented a game to spend their leisure time on the pasture; naturally, it involved the rocks and trees! Cowboy Ted likes this game very much, but so poor is his luck that he always loses to other cows. This time, he is going to seek your help. \n\nThe game's rules are simple. It is played with a tree that has both $N$$(2 \\leqslant N \\leqslant10000)$nodes conveniently numbered $1 \\cdots N$ and also $N-1$ branches. Node 1 is the root of this tree; except for node 1, node $i$ has parent $P_i$ $(1 \\leqslant P_i < i)$. Initially, Each node contains some rocks (except the root node, which has no rocks). In particular, non-root node $i$ has exactly $R_i (1 \\leqslant R_i \\leqslant 1000)$ rocks at the beginning of the game. \n\nTwo players alternate turns to play this game in turn, with Ted going first. In each turn, the current player can choose a non-root node $i$ and move at most $L (1 \\leqslant L \\leqslant 1000)$ rocks from this node one branch closer to the root (i.e., move these rocks to the parent node). He must move at least one rock, and, of course, he cannot exceed the current number of rocks on this node. The game ends when a player can't make a legal move (i.e., when all the rocks are on node 1); that player loses. \n\nTed needs your help. He has given you the initial configuration of the game, and he will then make $T (1 \\leqslant T \\leqslant 10000)$changes to the configuration one by one. Please help him determine, after each step, if he can win the game beginning from this configuration, assuming both he and his opponent use the best possible strategy. \n\nTed's changes are specified as two integers $A_j (1 < A_j \\leqslant N)$ and $B_j (1 \\leqslant B_j \\leqslant 1000)$, meaning that Ted will change the number of rocks on node $A_j$ to $B_j$ (this is a `set` not a `subtract` or `add`), and will then ask you whether he can win. Changes accumulate; node $A_j$'s rocks stay at $B_j$ until another change for $A_j$ appears.\n\nConsider this example with three nodes numbered as shown and the shape shown in Board 0. Initially, there are 5 rocks on node 2 and 3 rocks on node 3; see Board 1.\n\nFor the first change, Ted removes 2 rocks from node 2 (thus leaving 3); see Board 2. For the second change, Ted removes 2 rocks from node 3 (thus leaving 1). Note that node 2 still has 3 rocks; see Board 3.\n\nBoard 0 Board 1 Board 2 Board 3\n\n（原题面并未给出链接）\n\nYour program should determine in each case who wins.\n\nFor about 30% of the test cases, $N \\leqslant 10$, and $T \\leqslant 100$, and no tree node will have more than 5 rocks on it after any of Ted's changes.\n\nPartial feedback will be provided for your first $50$ submissions.", "inputFormat": "Line $1$: Three space-separated integers: $N$, $T$, and $L$.  \nLines $2 \\cdots N$: Line i contains two space-separted integers: $P_i$ and $R_i$.  \nLines $N+1 \\cdots N+T$: Line $j+N$ describes Ted's next change using two space-separated integers: $A_j$ and $B_j$.", "outputFormat": "Lines $1 \\cdots T$: Line $i$ contains `Yes` if Ted can win the game after change $i$; and `No` otherwise.", "hint": "数据来源：bzoj。", "locale": "zh-CN"}}}
{"pid": "P2973", "type": "P", "difficulty": 6, "samples": [["2 1 1 2 \n1 2 \n", "0.666666667 \n0.333333333 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO", "Special Judge", "O2优化", "高斯消元"], "title": "[USACO10HOL] Driving Out the Piggies G", "background": "", "description": "The Cows have constructed a randomized stink bomb for the purpose of driving away the Piggies. The Piggy civilization consists of N (2 <= N <= 300) Piggy cities conveniently numbered 1..N connected by M (1 <= M <= 44,850) bidirectional roads specified by their distinct endpoints A\\_j and B\\_j (1 <= A\\_j <= N; 1 <= B\\_j <= N). Piggy city 1 is always connected to at least one other city.\n\nThe stink bomb is deployed in Piggy city 1. Each hour (including the first one), it has a P/Q (1 <= P <= 1,000,000; 1 <= Q <=\n\n1,000,000; P <= Q) chance of polluting the city it occupies. If it does not go off, it chooses a random road out of the city and follows it until it reaches a new city.  All roads out of a city are equally likely to be chosen.\n\nBecause of the random nature of the stink bomb, the Cows are wondering which cities are most likely to be polluted. Given a map of the Piggy civilization and the probability that the stink bomb detonates in a given hour, compute for each city the probability that it will be polluted.\n\nFor example, suppose that the Piggie civilization consists of two cities connected together and that the stink bomb, which starts in city 1, has a probability of 1/2 of detonating each time it enters a city:\n\n1--2\nWe have the following possible paths for the stink bomb (where the last entry is the ending city):\n\n1: 1\n2: 1-2\n3: 1-2-1\n\n4: 1-2-1-2\n\n5: 1-2-1-2-1\n\netc.\nTo find the probability that the stink bomb ends at city 1, we can add up the probabilities of taking the 1st, 3rd, 5th, ... paths above (specifically, every odd-numbered path in the above list). The probability of taking path number k is exactly (1/2)^k - the bomb must not remain in its city for k - 1 turns (each time with a probability of 1 - 1/2 = 1/2) and then land in the last city\n\n(probability 1/2). \n\nSo our probability of ending in city 1 is represented by the sum 1/2 + (1/2)^3 + (1/2)^5 + ... . When we sum these terms infinitely, we will end up with exactly 2/3 as our probability, approximately 0.666666667. This means the probability of landing in city 2 is 1/3, approximately 0.333333333. \n\nPartial feedback will be provided for your first 50 submissions. ", "inputFormat": "\\* Line 1: Four space separated integers: N, M, P, and Q\n\n\\* Lines 2..M+1: Line i+1 describes a road with two space separated integers: A\\_j and B\\_j\n", "outputFormat": "\\* Lines 1..N: On line i, print the probability that city i will be destroyed as a floating point number. An answer with an absolute error of at most 10^-6 will be accepted (note that you should output at least 6 decimal places for this to take effect).\n", "hint": "感谢 @[Alpha](https://www.luogu.com.cn/user/87058) 贡献 Special Judge。", "locale": "en", "translations": {"en": {"title": "[USACO10HOL] Driving Out the Piggies G", "background": "", "description": "The Cows have constructed a randomized stink bomb for the purpose of driving away the Piggies. The Piggy civilization consists of N (2 <= N <= 300) Piggy cities conveniently numbered 1..N connected by M (1 <= M <= 44,850) bidirectional roads specified by their distinct endpoints A\\_j and B\\_j (1 <= A\\_j <= N; 1 <= B\\_j <= N). Piggy city 1 is always connected to at least one other city.\n\nThe stink bomb is deployed in Piggy city 1. Each hour (including the first one), it has a P/Q (1 <= P <= 1,000,000; 1 <= Q <=\n\n1,000,000; P <= Q) chance of polluting the city it occupies. If it does not go off, it chooses a random road out of the city and follows it until it reaches a new city.  All roads out of a city are equally likely to be chosen.\n\nBecause of the random nature of the stink bomb, the Cows are wondering which cities are most likely to be polluted. Given a map of the Piggy civilization and the probability that the stink bomb detonates in a given hour, compute for each city the probability that it will be polluted.\n\nFor example, suppose that the Piggie civilization consists of two cities connected together and that the stink bomb, which starts in city 1, has a probability of 1/2 of detonating each time it enters a city:\n\n1--2\nWe have the following possible paths for the stink bomb (where the last entry is the ending city):\n\n1: 1\n2: 1-2\n3: 1-2-1\n\n4: 1-2-1-2\n\n5: 1-2-1-2-1\n\netc.\nTo find the probability that the stink bomb ends at city 1, we can add up the probabilities of taking the 1st, 3rd, 5th, ... paths above (specifically, every odd-numbered path in the above list). The probability of taking path number k is exactly (1/2)^k - the bomb must not remain in its city for k - 1 turns (each time with a probability of 1 - 1/2 = 1/2) and then land in the last city\n\n(probability 1/2). \n\nSo our probability of ending in city 1 is represented by the sum 1/2 + (1/2)^3 + (1/2)^5 + ... . When we sum these terms infinitely, we will end up with exactly 2/3 as our probability, approximately 0.666666667. This means the probability of landing in city 2 is 1/3, approximately 0.333333333. \n\nPartial feedback will be provided for your first 50 submissions. ", "inputFormat": "\\* Line 1: Four space separated integers: N, M, P, and Q\n\n\\* Lines 2..M+1: Line i+1 describes a road with two space separated integers: A\\_j and B\\_j\n", "outputFormat": "\\* Lines 1..N: On line i, print the probability that city i will be destroyed as a floating point number. An answer with an absolute error of at most 10^-6 will be accepted (note that you should output at least 6 decimal places for this to take effect).\n", "hint": "感谢 @[Alpha](https://www.luogu.com.cn/user/87058) 贡献 Special Judge。", "locale": "en"}, "zh-CN": {"title": "[USACO10HOL] Driving Out the Piggies G", "background": null, "description": "奶牛们制造了一种随机臭弹，目的是驱赶小猪。小猪文明由 $ N (2 \\leq N \\leq 300) $ 个小猪城市组成，这些城市编号为 1 到 N，通过 $ M (1 \\leq M \\leq 44,850) $ 条双向道路连接，具体由它们的不同端点 $A_j$ 和 $B_j$ 指定 $ (1 \\leq A_j \\leq N; 1 \\leq B_j \\leq N) $。小猪城市 $1$ 总是与至少一个其他城市相连。\n\n臭弹在小猪城市 $1$ 部署。每小时（包括第一小时），它有 $P/Q (1 \\leq P \\leq 1,000,000, 1 \\leq Q \\leq 1,000,000; P \\leq Q) $ 的概率爆炸并污染它所在的城市。如果它没有爆炸，它会随机选择一条通往其他城市的道路并沿着它走，直到到达一个新城市。所有从一个城市出发的道路被选择的概率相同。\n\n由于臭弹的随机性质，奶牛们想知道哪些城市最有可能被污染。给定小猪文明的地图以及臭弹在每个小时内爆炸的概率，计算每个城市被污染的概率。\n\n例如，假设小猪文明由两个城市组成并且相连，臭弹从城市 $1$ 开始，每次进入一个城市时有 $\\frac12$ 的概率爆炸：\n\n1--2\n\n我们有以下可能的臭弹路径（最后一个城市是终点城市）：\n\n1: 1\n\n2: 1-2\n\n3: 1-2-1\n\n4: 1-2-1-2\n\n5: 1-2-1-2-1\n\n等等。\n要找到臭弹最终停留在城市 $1$ 的概率，我们可以将上述每条路径的概率相加（具体来说，就是上述列表中每一个奇数编号的路径）。选择第 $k$ 条路径的概率正好是 $(1/2)^k$ ——臭弹必须在前 $k-1$ 次不留在它的城市（每次概率为 $1-\\frac12=\\frac12$），然后在最后一个城市停留（概率为 $\\frac12$）。\n\n因此，我们在城市 $1$ 停留的概率由无穷级数 $\\displaystyle\\sum_{2\\nmid k}\\left(\\frac12\\right)^k$ 表示。当我们无限地求和这些项时，最终得到的概率恰好是 $\\frac23$，大约为 $0.666666667$。这意味着在城市 $2$ 停留的概率是 $\\frac13$，大约为 $0.333333333$。", "inputFormat": "第 $1$ 行：四个用空格分隔的整数：$N,M,P,Q$。\n\n第 $2$ 行到第 $M+1$ 行：第 $i+1$ 行描述一条道路，包含两个用空格分隔的整数：$A_j$ 和 $B_j$。", "outputFormat": "第 $1$ 行到第 $N$ 行：在第 $i$ 行，输出城市 $i$ 被摧毁的概率，格式为浮点数。绝对误差最多为 $10^{-6}$ 的答案将被接受（注意，您应该输出至少 $6$ 位小数以满足此要求）。", "hint": "感谢 @[Alpha](https://www.luogu.com.cn/user/87058) 贡献 Special Judge。", "locale": "zh-CN"}}}
{"pid": "P2974", "type": "P", "difficulty": 6, "samples": [["5 4 \nTEJTJ \n1 2 \n2 3 \n3 4 \n4 5 \n", "2 \nMOVE 3 2 \nATTACK 2 1 \nATTACK 5 4 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2010", "USACO", "Special Judge", "费用流"], "title": "[USACO10HOL] Cow War G", "background": "", "description": "Farmer John has long had a dispute with neighbor Farmer Tom over a group of V (1 <= V <= 1,000) pastures conveniently numbered 1..V. Both farmers currently graze their cows on the pastures; each pasture might be empty or might have a single cow which is owned by either Farmer John or Farmer Tom.\n\nFarmer John's patience is at an end, and he wishes to settle the dispute with Farmer Tom by tipping over Tom's cows. Of course, he wants to strike first and to tip as many of Farmer Tom's cows as possible.\n\nA total of E (1 <= E <= 5,000) bidirectional cowpaths connect pairs of pastures. No two pastures are connected by more than one cowpath; each path connects exactly two distinct pastures. Paths are described by their endpoints P1\\_i and P2\\_i (1 <= P1\\_i <= V; 1 <= P2\\_i <= V).\n\nDuring his offense, each of Farmer John's cows can traverse a single cowpath if she wishes. Whether or not she chooses to traverse a cowpath, she can then (if she wishes) launch a cow tipping attack to a pasture connected to her pasture by a single cowpath, thus tipping the enemy cow on that pasture. Note that a cow can move and then attack -- but she is not able to attack and then move.\n\nEach pasture can hold exactly one cow at a time; no cow can move to a pasture occupied by another cow, especially if it has been tipped. Of course, if a pasture is vacated, another cow can later move in to take its place. A tipped cow cannot be tipped again.\n\nFarmer John wants to know two things:\n\n\\* How many of Farmer Tom's cows he can tip in the first salvo\n\nof the war\n\n\\* How to command his cows to move and attack so as to tip\n\nthat maximal number of Farmer Tom's cows in that first salvo\n\nFind the maximum number of cows that can be tipped and construct a sequence of move and attack commands to his cows that then obey the rules and tip that number of cows. Any such sequence is acceptable, as long as it tips the maximum number of Farmer Tom's cows.\n\nConsider, for instance, a group of 5 pastures arranged in a line, with each pasture connected (via '--'; see diagram below) to its left and right neighbors (if they exist). In other words, there is a cowpath from Pasture 1 to Pasture 2, Pasture 2 to Pasture 3, etc. Farmer Tom ('T') has 2 cows, standing on pastures 1 and 4, while Farmer John ('J') has 2 cows standing on pastures 3 and 5 ('E' means empty):\n\n1    2    3    4    5\n\nT -- E -- J -- T -- J\n\nIn this case, Farmer John can tip both of Farmer Tom's cows by first moving his cow on Pasture 3 to Pasture 2, so that the pastures in order are now TJETJ. Farmer John can then have both of his cows attack to the left.  Note that although the cow in Pasture 3 could have attacked to the right without moving, the rightmost cow would then be unable to attack. The only valid solutions thus have the same move and attacks, although the order in which Farmer John commands his cows can vary slightly.\n\nIf you compute the correct maximum number but do not provide a sequence (or your sequence is wrong), you will get 50% of the points for that test case. A program will grade your output.\n\nPartial feedback will be provided for your first 50 submissions.", "inputFormat": "\\* Line 1: Two space separated integers: V and E\n\n\\* Line 2: A string of V characters (no spaces); character #i indicates whether pasture #i is empty ('E') or has a cow owned by Farmer John ('J') or Farmer Tom ('T')\n\n\\* Lines 3..E+2: Line i+2 contains two space separated integers: P1\\_i and P2\\_i\n", "outputFormat": "\\* Line 1: A single integer, the maximum number of enemy cows Farmer John can have tipped\n\n\\* Lines 2.....: One of Farmer John's instructions to his cows (to be executed in the order given):\n\nMOVE A B\n\nor\nATTACK A B\n\nwhere A is the vertex the cow occupies before taking the action and B is the vertex it is moving to or attacking, respectively. Note that when instructing a cow that has already moved to attack, the instruction specifies the location the cow is currently standing, not where it was originally.\n", "hint": "The other valid outputs are:\n\n2\nMOVE 3 2\n\nATTACK 5 4\n\nATTACK 2 1\n\nand\n2\nATTACK 5 4\n\nMOVE 3 2\n\nATTACK 2 1\n\nwhich are just reorderings of the output shown.  This might not be true on other testdata.\n", "locale": "en", "translations": {"en": {"title": "[USACO10HOL] Cow War G", "background": "", "description": "Farmer John has long had a dispute with neighbor Farmer Tom over a group of V (1 <= V <= 1,000) pastures conveniently numbered 1..V. Both farmers currently graze their cows on the pastures; each pasture might be empty or might have a single cow which is owned by either Farmer John or Farmer Tom.\n\nFarmer John's patience is at an end, and he wishes to settle the dispute with Farmer Tom by tipping over Tom's cows. Of course, he wants to strike first and to tip as many of Farmer Tom's cows as possible.\n\nA total of E (1 <= E <= 5,000) bidirectional cowpaths connect pairs of pastures. No two pastures are connected by more than one cowpath; each path connects exactly two distinct pastures. Paths are described by their endpoints P1\\_i and P2\\_i (1 <= P1\\_i <= V; 1 <= P2\\_i <= V).\n\nDuring his offense, each of Farmer John's cows can traverse a single cowpath if she wishes. Whether or not she chooses to traverse a cowpath, she can then (if she wishes) launch a cow tipping attack to a pasture connected to her pasture by a single cowpath, thus tipping the enemy cow on that pasture. Note that a cow can move and then attack -- but she is not able to attack and then move.\n\nEach pasture can hold exactly one cow at a time; no cow can move to a pasture occupied by another cow, especially if it has been tipped. Of course, if a pasture is vacated, another cow can later move in to take its place. A tipped cow cannot be tipped again.\n\nFarmer John wants to know two things:\n\n\\* How many of Farmer Tom's cows he can tip in the first salvo\n\nof the war\n\n\\* How to command his cows to move and attack so as to tip\n\nthat maximal number of Farmer Tom's cows in that first salvo\n\nFind the maximum number of cows that can be tipped and construct a sequence of move and attack commands to his cows that then obey the rules and tip that number of cows. Any such sequence is acceptable, as long as it tips the maximum number of Farmer Tom's cows.\n\nConsider, for instance, a group of 5 pastures arranged in a line, with each pasture connected (via '--'; see diagram below) to its left and right neighbors (if they exist). In other words, there is a cowpath from Pasture 1 to Pasture 2, Pasture 2 to Pasture 3, etc. Farmer Tom ('T') has 2 cows, standing on pastures 1 and 4, while Farmer John ('J') has 2 cows standing on pastures 3 and 5 ('E' means empty):\n\n1    2    3    4    5\n\nT -- E -- J -- T -- J\n\nIn this case, Farmer John can tip both of Farmer Tom's cows by first moving his cow on Pasture 3 to Pasture 2, so that the pastures in order are now TJETJ. Farmer John can then have both of his cows attack to the left.  Note that although the cow in Pasture 3 could have attacked to the right without moving, the rightmost cow would then be unable to attack. The only valid solutions thus have the same move and attacks, although the order in which Farmer John commands his cows can vary slightly.\n\nIf you compute the correct maximum number but do not provide a sequence (or your sequence is wrong), you will get 50% of the points for that test case. A program will grade your output.\n\nPartial feedback will be provided for your first 50 submissions.", "inputFormat": "\\* Line 1: Two space separated integers: V and E\n\n\\* Line 2: A string of V characters (no spaces); character #i indicates whether pasture #i is empty ('E') or has a cow owned by Farmer John ('J') or Farmer Tom ('T')\n\n\\* Lines 3..E+2: Line i+2 contains two space separated integers: P1\\_i and P2\\_i\n", "outputFormat": "\\* Line 1: A single integer, the maximum number of enemy cows Farmer John can have tipped\n\n\\* Lines 2.....: One of Farmer John's instructions to his cows (to be executed in the order given):\n\nMOVE A B\n\nor\nATTACK A B\n\nwhere A is the vertex the cow occupies before taking the action and B is the vertex it is moving to or attacking, respectively. Note that when instructing a cow that has already moved to attack, the instruction specifies the location the cow is currently standing, not where it was originally.\n", "hint": "The other valid outputs are:\n\n2\nMOVE 3 2\n\nATTACK 5 4\n\nATTACK 2 1\n\nand\n2\nATTACK 5 4\n\nMOVE 3 2\n\nATTACK 2 1\n\nwhich are just reorderings of the output shown.  This might not be true on other testdata.\n", "locale": "en"}, "zh-CN": {"title": "[USACO10HOL] Cow War G", "background": null, "description": "给定 $V$ 个点，$E$ 条边的无向图。\n一开始每个点上有 `T` 牛，`J` 牛，或者没有（`E`）。\n`J` 牛可以 `MOVE` 到一个相邻的点，也可以 `ATTACK` 相邻点上的一个 `T` 牛。不过操作有限制，只能按照 `MOVE`,`ATTACK` 或者 `MOVE` 然后 `ATTACK` 三种方式操作。\n一个 `T` 牛仅能被 `ATTACK` 一次，被 `ATTACK` 后它会留在原地。\n需要保证任意时刻，每个点上有且仅有一头牛。\n求所有 `T` 牛被 `ATTACK` 的最大次数，并给出一个可行的操作方案。", "inputFormat": "第一行两个整数 $V,E$，表示无向图的点数和边数。\n接下来一行 $V$ 个字符，第 $i$ 个字符表示第 $i$ 个点的初始状态。\n接下来 $E$ 行每行两个整数 $u,v$，表示存在一条连接 $u,v$ 的无向边。", "outputFormat": "第一行一个整数，表示所有 `T` 牛被 `ATTACK` 的最大次数。\n接下来若干行，每行以 `MOVE u v` 或 `ATTACK u v` 的形式给出，表示你的操作方案。", "hint": "对于测试点 $1\\sim5$，$1\\leq V\\leq 30,1\\leq E\\leq 50$。\n\n对于测试点 $6\\sim 10$，$1\\leq V\\leq 500,1\\leq E\\leq 2\\times 10^3$。\n\n对于测试点 $11\\sim 15$，$1\\leq V\\leq 10^3,1\\leq E\\leq 5\\times 10^3$。\n\n注意：一个操作需要描述现在的位置，例如：点 $3$ 上的牛先 `MOVE` 到点 $2$，再 `ATTACK` 点 $4$，应该写为：\n\n```\nMOVE 3 2\nATTACK 2 4\n```", "locale": "zh-CN"}}}
{"pid": "P2975", "type": "P", "difficulty": 5, "samples": [["6 \n17 \n5 \n9 \n10 \n3 \n8 \n", "27 17 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10JAN] Taking Turns G", "background": "", "description": "Farmer John has invented a new way of feeding his cows. He lays out N (1 <= N <= 700,000) hay bales conveniently numbered 1..N in a long line in the barn. Hay bale i has weight W\\_i (1 <= W\\_i <=\n\n2,000,000,000). A sequence of six weights might look something like:\n\n17 5 9 10 3 8\n\nA pair of cows named Bessie and Dessie walks down this line after examining all the haybales to learn their weights. Bessie is the first chooser. They take turns picking haybales to eat as they walk (once a haybale is skipped, they cannot return to it). For instance, if cows Bessie and Dessie go down the line, a possible scenario is:\n\n\\* Bessie picks the weight 17 haybale\n\n\\* Dessie skips the weight 5 haybale and picks the weight 9 haybale \\* Bessie picks the weight 10 haybale\n\n\\* Dessie skips the weight 3 haybale and picks the weight 8 haybale\n\nDiagrammatically:\n\nBessie   |      | \n17 5 9 10 3 8\n\nDessie       |      | \nThis scenario only shows a single skipped bale; either cow can skip as many as she pleases when it's her turn.\n\nEach cow wishes to maximize the total weight of hay she herself consumes (and each knows that the other cow has this goal).\n\nFurthermore, a cow will choose to eat the first bale of hay that maximimizes her total weight consumed.\n\nGiven a sequence of hay weights, determine the amount of hay that a pair of cows will eat as they go down the line of hay.\n\n两头奶牛 Bessi 和 Dessie 走过一条路吃草，共 $n(1\\le n \\le 7\\times 10 ^ 5)$ 个格子，第 $i$ 个格子有重量为 $W_i(1 \\le W_i \\le 2 \\times 10 ^{9})$ 的草，两牛轮流走，一旦某头牛走过了一格，那么这格的草再也不可能被任一头奶牛吃，每格的草只能被吃一次，所以两头牛只能往后走。Bessi 先走，每头牛每次都往最终自己能吃到最多草的格子走（若有多个格子则选择第一个能吃到最多草的格子），他们都知道对方也想吃到最多的草，问最后 Bessi 和 Dessie 各吃到的草的重量。\n\n输入格式：\n\n第一行一个正整数 $n(1\\leq n\\le 7\\times 10 ^ 5)$，接下来有 $n$ 行，第 $i+1$ 行为 $W_i(1 \\le W_i \\le 2 \\times 10 ^{9})$。", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: W\\_i\n", "outputFormat": "\\* Line 1: Two space-separated integers, the total weight of hay consumed by Bessie and Dessie respectively\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10JAN] Taking Turns G", "background": "", "description": "Farmer John lays out $n$ hay bales in a line, conveniently numbered $1..n$. Hay bale $i$ has weight $W_i$. The constraints are $1 \\le n \\le 7 \\times 10^5$ and $1 \\le W_i \\le 2 \\times 10^9$.\n\nA sequence of six weights might look like:\n17 5 9 10 3 8.\n\nTwo cows, Bessie and Dessie, walk down this line after examining all the hay bales and learning their weights. Bessie chooses first. They take turns picking hay bales to eat as they proceed from left to right. Either cow may skip any number of bales on her turn, but once a bale has been passed, neither cow can return to it, and each bale can be eaten at most once.\n\nFor example, as they go down the line, a possible scenario is:\n- Bessie picks the 17-weight bale.\n- Dessie skips the 5-weight bale and picks the 9-weight bale.\n- Bessie picks the 10-weight bale.\n- Dessie skips the 3-weight bale and picks the 8-weight bale.\nThis scenario shows just one skipped bale; in general, either cow may skip any number of bales on her turn.\n\nEach cow wishes to maximize the total weight of hay she herself consumes (and each knows the other has this goal). Furthermore, whenever multiple choices lead to the same maximum total for herself under optimal play, a cow will choose the first bale (the earliest position) among those optimal choices.\n\nGiven the sequence of hay weights, determine the total weight of hay eaten by Bessie and by Dessie, respectively.", "inputFormat": "- Line 1: A single integer $n$.\n- Lines $2..n+1$: Line $i+1$ contains a single integer $W_i$.", "outputFormat": "- Line 1: Two space-separated integers: the total weight consumed by Bessie and by Dessie, respectively.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10JAN] Taking Turns G", "background": "", "description": "Farmer John has invented a new way of feeding his cows. He lays out N (1 <= N <= 700,000) hay bales conveniently numbered 1..N in a long line in the barn. Hay bale i has weight W\\_i (1 <= W\\_i <=\n\n2,000,000,000). A sequence of six weights might look something like:\n\n17 5 9 10 3 8\n\nA pair of cows named Bessie and Dessie walks down this line after examining all the haybales to learn their weights. Bessie is the first chooser. They take turns picking haybales to eat as they walk (once a haybale is skipped, they cannot return to it). For instance, if cows Bessie and Dessie go down the line, a possible scenario is:\n\n\\* Bessie picks the weight 17 haybale\n\n\\* Dessie skips the weight 5 haybale and picks the weight 9 haybale \\* Bessie picks the weight 10 haybale\n\n\\* Dessie skips the weight 3 haybale and picks the weight 8 haybale\n\nDiagrammatically:\n\nBessie   |      | \n17 5 9 10 3 8\n\nDessie       |      | \nThis scenario only shows a single skipped bale; either cow can skip as many as she pleases when it's her turn.\n\nEach cow wishes to maximize the total weight of hay she herself consumes (and each knows that the other cow has this goal).\n\nFurthermore, a cow will choose to eat the first bale of hay that maximimizes her total weight consumed.\n\nGiven a sequence of hay weights, determine the amount of hay that a pair of cows will eat as they go down the line of hay.\n\n两头奶牛 Bessi 和 Dessie 走过一条路吃草，共 $n(1\\le n \\le 7\\times 10 ^ 5)$ 个格子，第 $i$ 个格子有重量为 $W_i(1 \\le W_i \\le 2 \\times 10 ^{9})$ 的草，两牛轮流走，一旦某头牛走过了一格，那么这格的草再也不可能被任一头奶牛吃，每格的草只能被吃一次，所以两头牛只能往后走。Bessi 先走，每头牛每次都往最终自己能吃到最多草的格子走（若有多个格子则选择第一个能吃到最多草的格子），他们都知道对方也想吃到最多的草，问最后 Bessi 和 Dessie 各吃到的草的重量。\n\n输入格式：\n\n第一行一个正整数 $n(1\\leq n\\le 7\\times 10 ^ 5)$，接下来有 $n$ 行，第 $i+1$ 行为 $W_i(1 \\le W_i \\le 2 \\times 10 ^{9})$。", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: W\\_i\n", "outputFormat": "\\* Line 1: Two space-separated integers, the total weight of hay consumed by Bessie and Dessie respectively\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2976", "type": "P", "difficulty": 6, "samples": [["12 19 \n................... \n................... \n.....A............. \n.....A..x.......... \n..x..A.....AAAA.... \n.....A.....A..A.... \n.....AAAAAAAA.A.... \n........A.....A.... \n.xx...AAA...x.A.... \n......A............ \n...AAAAAAAAAAAAA... \n................... \n", "62 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10JAN] Shipping Around an Island G", "background": "", "description": "Farmer John decided to start his own cruise ship line! He has but one ship, but is hoping for big growth. He recently acquired a map of the area of ocean where his cruise ship will operate. It looks something like the diagram below, with height H (3 <= H <= 1000) and width W (3 <= W <= 1000).\n\n```cpp\n................... \n................... \n.....A............. \n.....A..x.......... \n..x..A.....AAAA.... \n.....A.....A..A.... \n.....AAAAAAAA.A.... \n........A.....A.... \n.xx...AAA...x.A.... \n......A............ \n...AAAAAAAAAAAAA... \n................... \n```\nIn this map, '.' denotes water; 'A' is an element of the main island; and 'x' are other islands.\n\nFarmer John has decided his cruise ship will loop around the main island. However, due to trade restrictions, the path his ship takes is NOT allowed to go around any OTHER islands. For instance, the following path of length 50 is not allowed because it encloses the island denoted by 'x'.\n\n```cpp\n................... \n....+--+........... \n....|A.|........... \n....|A.|x.+-----+.. \n..x.|A.+--+AAAA.|.. \n....|A.....A..A.|.. \n....|AAAAAAAA.A.|.. \n....|...A.....A.|.. \n.xx.|.AAA...x.A.|..    <--- route circumnavigates 'x' -- illegal! ..+-+.A.........|.. \n..|AAAAAAAAAAAAA|.. \n..+-------------+.. \n```\nGiven a map, help Farmer John determine the shortest path his cruise ship can take to go around the main island without going around any other islands.\n\nTwo cells are considered connected if they lie vertically or\n\nhorizontally across from one another (not diagonally). It is\n\nguaranteed that the main island is connected and that a solution exists.\n\nNote that FJ's path may visit the same square more than once, for instance there are three squares that are visited more than once in FJ's optimal path (of length 62) for the example:\n\n```cpp\n................... \n....+--+........... \n....|A.|........... \n....|A.|x.+----+... \n..x.|A.+--+AAAA|... \n....|A.....A..A|... \n....|AAAAAAAA.A|... \n....|...A..+-+A|... \n.xx.|.AAA..|x|A|... \n..+-+.A....+-+-++.. \n..|AAAAAAAAAAAAA|.. \n..+-------------+.. \n```\nThe above diagram is somewhat unclear because of the path overlapping itself.  Drawn in two stages, FJ's optimal path is:\n\n```cpp\n...................            ................... \n...................            ....+--+........... \n.....A.............            ....|A.|........... \n.....A..x..........            ....|A.|x.+----+... \n..x..A.....AAAA....            ..x.|A.+--+AAAA|... \n.....A.....A..A....  and then  ....|A.....A..A|... \n.....AAAAAAAA.A....            ....|AAAAAAAA.A|... \n....V...A..+>.A....            ....V...A...>+A|... \n.xx.|.AAA..|x.A....            .xx...AAA...x|A|... \n..+-+.A....+----+..            .....A.......+-+... \n..|AAAAAAAAAAAAA|..            ...AAAAAAAAAAAAA... \n..+-------------+..            ................... \n```\n\nJohn 得到一份地图，长 $H$（$3 \\leq H\\leq 1000$）宽 $W$（$3 \\leq W\\leq 1000$），地图中 ``.`` 表示水，`A` 表示大陆，`x` 表示其他小岛。他决定驾驶他的船绕大陆一圈，但并不想环绕其他小岛。John 可以再任意有水的格子出发，求绕一周最小路径长度（一个格子可以经过任意多次）。\n\n输入格式：\n\n第一行两个空格隔开正整数 $H$ 和 $W$（$3 \\leq H,W\\leq 1000$），接下来有 $H$ 行，每行 $W$ 个字符表示地图。", "inputFormat": "\\* Line 1: Two space-separated integers: H and W\n\n\\* Lines 2..H+1: Line i+1 contains contains W characters that are the elements of map row i (all '.' or 'x' or 'A')\n", "outputFormat": "\\* Line 1: The minimum length of a path that Farmer John's cruise ship can take\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10JAN] Shipping Around an Island G", "background": "", "description": "Farmer John decided to start his own cruise ship line! He has but one ship, but is hoping for big growth. He recently acquired a map of the area of ocean where his cruise ship will operate. It looks something like the diagram below, with height $H$ ($3 \\leq H \\leq 1000$) and width $W$ ($3 \\leq W \\leq 1000$).\n\n```cpp\n................... \n................... \n.....A............. \n.....A..x.......... \n..x..A.....AAAA.... \n.....A.....A..A.... \n.....AAAAAAAA.A.... \n........A.....A.... \n.xx...AAA...x.A.... \n......A............ \n...AAAAAAAAAAAAA... \n................... \n```\n\nIn this map, '.' denotes water; 'A' is an element of the main island; and 'x' are other islands.\n\nFarmer John has decided his cruise ship will loop around the main island. However, due to trade restrictions, the path his ship takes is NOT allowed to go around any other islands. For instance, the following path of length 50 is not allowed because it encloses the island denoted by 'x'.\n\n```cpp\n................... \n....+--+........... \n....|A.|........... \n....|A.|x.+-----+.. \n..x.|A.+--+AAAA.|.. \n....|A.....A..A.|.. \n....|AAAAAAAA.A.|.. \n....|...A.....A.|.. \n.xx.|.AAA...x.A.|..    <--- route circumnavigates 'x' -- illegal! ..+-+.A.........|.. \n..|AAAAAAAAAAAAA|.. \n..+-------------+.. \n```\n\nGiven a map, help Farmer John determine the shortest path his cruise ship can take to go around the main island without going around any other islands.\n\nTwo cells are considered connected if they lie vertically or horizontally across from one another (not diagonally). It is guaranteed that the main island is connected and that a solution exists. The path may start on any water cell and may visit the same square more than once. For instance, there are three squares that are visited more than once in FJ's optimal path (of length 62) for the example:\n\n```cpp\n................... \n....+--+........... \n....|A.|........... \n....|A.|x.+----+... \n..x.|A.+--+AAAA|... \n....|A.....A..A|... \n....|AAAAAAAA.A|... \n....|...A..+-+A|... \n.xx.|.AAA..|x|A|... \n..+-+.A....+-+-++.. \n..|AAAAAAAAAAAAA|.. \n..+-------------+.. \n```\n\nThe above diagram is somewhat unclear because of the path overlapping itself. Drawn in two stages, FJ's optimal path is:\n\n```cpp\n...................            ................... \n...................            ....+--+........... \n.....A.............            ....|A.|........... \n.....A..x..........            ....|A.|x.+----+... \n..x..A.....AAAA....            ..x.|A.+--+AAAA|... \n.....A.....A..A....  and then  ....|A.....A..A|... \n.....AAAAAAAA.A....            ....|AAAAAAAA.A|... \n....V...A..+>.A....            ....V...A...>+A|... \n.xx.|.AAA..|x.A....            .xx...AAA...x|A|... \n..+-+.A....+----+..            .....A.......+-+... \n..|AAAAAAAAAAAAA|..            ...AAAAAAAAAAAAA... \n..+-------------+..            ................... \n```\n\nJohn obtained a map of size $H$ ($3 \\leq H \\leq 1000$) by $W$ ($3 \\leq W \\leq 1000$). '.' denotes water, 'A' denotes the main island, and 'x' denotes other small islands. He wants to pilot his ship once around the main island, but the route must not circumnavigate any other islands. The path may start on any water cell, and a cell may be visited any number of times. Find the minimum length of such a route.", "inputFormat": "- Line 1: Two space-separated integers $H$ and $W$ ($3 \\leq H, W \\leq 1000$).\n- Lines 2..$H+1$: Each of the next $H$ lines contains $W$ characters describing a map row, each character being '.' or 'x' or 'A'.", "outputFormat": "- Line 1: A single integer — the minimum length of a valid path that Farmer John's cruise ship can take.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10JAN] Shipping Around an Island G", "background": "", "description": "Farmer John decided to start his own cruise ship line! He has but one ship, but is hoping for big growth. He recently acquired a map of the area of ocean where his cruise ship will operate. It looks something like the diagram below, with height H (3 <= H <= 1000) and width W (3 <= W <= 1000).\n\n```cpp\n................... \n................... \n.....A............. \n.....A..x.......... \n..x..A.....AAAA.... \n.....A.....A..A.... \n.....AAAAAAAA.A.... \n........A.....A.... \n.xx...AAA...x.A.... \n......A............ \n...AAAAAAAAAAAAA... \n................... \n```\nIn this map, '.' denotes water; 'A' is an element of the main island; and 'x' are other islands.\n\nFarmer John has decided his cruise ship will loop around the main island. However, due to trade restrictions, the path his ship takes is NOT allowed to go around any OTHER islands. For instance, the following path of length 50 is not allowed because it encloses the island denoted by 'x'.\n\n```cpp\n................... \n....+--+........... \n....|A.|........... \n....|A.|x.+-----+.. \n..x.|A.+--+AAAA.|.. \n....|A.....A..A.|.. \n....|AAAAAAAA.A.|.. \n....|...A.....A.|.. \n.xx.|.AAA...x.A.|..    <--- route circumnavigates 'x' -- illegal! ..+-+.A.........|.. \n..|AAAAAAAAAAAAA|.. \n..+-------------+.. \n```\nGiven a map, help Farmer John determine the shortest path his cruise ship can take to go around the main island without going around any other islands.\n\nTwo cells are considered connected if they lie vertically or\n\nhorizontally across from one another (not diagonally). It is\n\nguaranteed that the main island is connected and that a solution exists.\n\nNote that FJ's path may visit the same square more than once, for instance there are three squares that are visited more than once in FJ's optimal path (of length 62) for the example:\n\n```cpp\n................... \n....+--+........... \n....|A.|........... \n....|A.|x.+----+... \n..x.|A.+--+AAAA|... \n....|A.....A..A|... \n....|AAAAAAAA.A|... \n....|...A..+-+A|... \n.xx.|.AAA..|x|A|... \n..+-+.A....+-+-++.. \n..|AAAAAAAAAAAAA|.. \n..+-------------+.. \n```\nThe above diagram is somewhat unclear because of the path overlapping itself.  Drawn in two stages, FJ's optimal path is:\n\n```cpp\n...................            ................... \n...................            ....+--+........... \n.....A.............            ....|A.|........... \n.....A..x..........            ....|A.|x.+----+... \n..x..A.....AAAA....            ..x.|A.+--+AAAA|... \n.....A.....A..A....  and then  ....|A.....A..A|... \n.....AAAAAAAA.A....            ....|AAAAAAAA.A|... \n....V...A..+>.A....            ....V...A...>+A|... \n.xx.|.AAA..|x.A....            .xx...AAA...x|A|... \n..+-+.A....+----+..            .....A.......+-+... \n..|AAAAAAAAAAAAA|..            ...AAAAAAAAAAAAA... \n..+-------------+..            ................... \n```\n\nJohn 得到一份地图，长 $H$（$3 \\leq H\\leq 1000$）宽 $W$（$3 \\leq W\\leq 1000$），地图中 ``.`` 表示水，`A` 表示大陆，`x` 表示其他小岛。他决定驾驶他的船绕大陆一圈，但并不想环绕其他小岛。John 可以再任意有水的格子出发，求绕一周最小路径长度（一个格子可以经过任意多次）。\n\n输入格式：\n\n第一行两个空格隔开正整数 $H$ 和 $W$（$3 \\leq H,W\\leq 1000$），接下来有 $H$ 行，每行 $W$ 个字符表示地图。", "inputFormat": "\\* Line 1: Two space-separated integers: H and W\n\n\\* Lines 2..H+1: Line i+1 contains contains W characters that are the elements of map row i (all '.' or 'x' or 'A')\n", "outputFormat": "\\* Line 1: The minimum length of a path that Farmer John's cruise ship can take\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2977", "type": "P", "difficulty": 5, "samples": [["6 1 \n1 2 \n2 3 \n2 4 \n4 5 \n4 6 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "递推", "2010", "USACO", "排序"], "title": "[USACO10JAN] Cow Telephones G", "background": null, "description": "奶牛们建立了一个电话网络，对于这个题目可以将其视为一个有 $N$（$1 \\le N \\le 100{,}000$）个结点的无根树，为了方便将其编号为 $1\\cdots N$。每个结点代表一个电话交换机，每条边代表用于连接两个交换机的电话线。第 $i$ 条边由该边连接的两个结点 $A_i$ 和 $B_i$ 表示（$1 \\le A_i \\le N, 1 \\le B_i \\le N, A_i \\ne B_i$）。\n\n有些交换机只有一条电话线连接到另一个交换机，这些是树的叶子结点，每个叶子结点都是一个位于奶牛田中的电话亭。\n\n两只奶牛交流时的对话沿着两个奶牛所在节点之间的唯一的最短路径传递。一个交换机最多可以同时处理 $K$（$1 \\le K \\le 10$）个对话，并且在任何时候每个电话线上最多只能有一个对话。\n\n假设每个叶子结点上都有一头奶牛，那么最多有多少对奶牛可以同时进行对话？当然，一头奶牛最多只能参与一个对话。", "inputFormat": "第 $1$ 行：两个由空格分隔的整数 $N$ 和 $K$。\n\n第 $2\\cdots N$ 行：第 $i + 1$ 行包含两个由空格分隔的整数 $A_i$ 和 $B_i$。", "outputFormat": "第 $1$ 行：可以同时进行对话的奶牛对数。", "hint": "```plain\n1   5          C1   C5 \n|   |          ||   || \n2---4   -->    |2---4| \n|   |          ||   || \n3   6          C3   C6\n```\n\n考虑这个有 $6$ 个结点且 $K = 1$ 的电话树：\n\n有四头分别位于节点 $1$、$3$、$5$ 和 $6$ 的奶牛。如果奶牛 $1$ 和奶牛 $3$ 交谈，奶牛 $5$ 和奶牛 $6$ 交谈，那么它们不会超过每个交换机的最大对话数，所以在这个样例中答案是 $2$（即有两对奶牛可以同时进行交谈）。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10JAN] Cow Telephones G", "background": null, "description": "The cows have set up a telephone network, which for the purposes of this problem can be considered to be an unrooted tree of unspecified degree with $N$ ($1 \\le N \\le 100{,}000$) vertices conveniently numbered $1\\dots N$. Each vertex represents a telephone switchboard, and each edge represents a telephone wire between two switchboards. Edge $i$ is specified by two integers $A_i$ and $B_i$ the are the two vertices joined by edge $i$ ($1 \\le A_i \\le N$; $1 \\le B_i \\le N$; $A_i \\ne B_i$).\n\nSome switchboards have only one telephone wire connecting them to another switchboard; these are the leaves of the tree, each of which is a telephone booth located in a cow field.\n\nFor two cows to communicate, their conversation passes along the unique shortest path between the two vertices where the cows are located. A switchboard can accomodate only up to $K$ ($1 \\le K \\le 10$) simultaneous conversations, and there can be at most one conversation going through a given wire at any one time.\n\nGiven that there is a cow at each leaf of the tree, what is the maximum number of pairs of cows that can simultaneously hold conversations? A cow can, of course, participate in at most one conversation.", "inputFormat": "\\* Line $1$: Two space separated integers: $N$ and $K$.\n\n\\* Lines $2\\dots N$: Line $i+1$ contains two space-separated integers: $A_i$ and $B_i$.", "outputFormat": "\\* Line $1$: The number of pairs of cows that can simultaneously hold conversations.", "hint": "```plain\n1   5          C1   C5 \n|   |          ||   || \n2---4   -->    |2---4| \n|   |          ||   || \n3   6          C3   C6 \n```\nConsider this six-node telephone tree with $K=1$: \n\nThere are four cows, located at vertices $1$, $3$, $5$ and $6$. If cow $1$ talks to cow $3$, and cow $5$ talks to cow $6$, then they do not exceed the maximum number of conversations per switchboard, so for this example the answer is $2$ (for two pairs of cows talking simultaneously).", "locale": "en"}, "zh-CN": {"title": "[USACO10JAN] Cow Telephones G", "background": null, "description": "奶牛们建立了一个电话网络，对于这个题目可以将其视为一个有 $N$（$1 \\le N \\le 100{,}000$）个结点的无根树，为了方便将其编号为 $1\\cdots N$。每个结点代表一个电话交换机，每条边代表用于连接两个交换机的电话线。第 $i$ 条边由该边连接的两个结点 $A_i$ 和 $B_i$ 表示（$1 \\le A_i \\le N, 1 \\le B_i \\le N, A_i \\ne B_i$）。\n\n有些交换机只有一条电话线连接到另一个交换机，这些是树的叶子结点，每个叶子结点都是一个位于奶牛田中的电话亭。\n\n两只奶牛交流时的对话沿着两个奶牛所在节点之间的唯一的最短路径传递。一个交换机最多可以同时处理 $K$（$1 \\le K \\le 10$）个对话，并且在任何时候每个电话线上最多只能有一个对话。\n\n假设每个叶子结点上都有一头奶牛，那么最多有多少对奶牛可以同时进行对话？当然，一头奶牛最多只能参与一个对话。", "inputFormat": "第 $1$ 行：两个由空格分隔的整数 $N$ 和 $K$。\n\n第 $2\\cdots N$ 行：第 $i + 1$ 行包含两个由空格分隔的整数 $A_i$ 和 $B_i$。", "outputFormat": "第 $1$ 行：可以同时进行对话的奶牛对数。", "hint": "```plain\n1   5          C1   C5 \n|   |          ||   || \n2---4   -->    |2---4| \n|   |          ||   || \n3   6          C3   C6\n```\n\n考虑这个有 $6$ 个结点且 $K = 1$ 的电话树：\n\n有四头分别位于节点 $1$、$3$、$5$ 和 $6$ 的奶牛。如果奶牛 $1$ 和奶牛 $3$ 交谈，奶牛 $5$ 和奶牛 $6$ 交谈，那么它们不会超过每个交换机的最大对话数，所以在这个样例中答案是 $2$（即有两对奶牛可以同时进行交谈）。", "locale": "zh-CN"}}}
{"pid": "P2978", "type": "P", "difficulty": 2, "samples": [["5 3 3 \n2 5 \n2 3 \n4 5 \n2 3 \n3 5 \n1 5 \n", "Y \nY \nN \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10JAN] Tea Time S", "background": null, "description": "$N (1 \\leq N \\leq 1000)$ 头奶牛，编号为 $1 \\dots N$，在参加一个喝茶时间活动。在喝茶时间活动开始之前，已经有 $M (1 \\leq M \\leq 2,000)$ 对奶牛彼此认识（是朋友）。第i对彼此认识的奶牛通过两个不相同的整数 $A_i$ 和 $B_i$ 给定（$1 \\leq A_i \\leq N, 1 \\leq B_i \\leq N$）。输入数据保证一对奶牛不会出现多次。 在喝茶时间活动中，如果奶牛 $i$ 和奶牛 $j$ 有一个相同的朋友奶牛 $k$，那么他们会在某次的喝茶活动中去认识对方（成为朋友），从而扩大他们的社交圈。请判断，在喝茶活动举办很久以后（直到没有新的奶牛彼此认识），$Q (1 \\leq Q \\leq 100)$ 对奶牛是否已经彼此认识。询问j包含一对不同的奶牛编号 $X_j$ 和 $Y_j$（$1 \\leq X_j \\leq N, 1 \\leq Y_j \\leq N$）。\n\n例如，假设共有 $5$ 头奶牛，我们知道 $2$ 号认识 $5$ 号，$2$ 号认识 $3$ 号，而且 $4$ 号认识 $5$ 号；如下图 (a)。\n\n```cpp\n   2---3           2---3            2---3\n    \\              |\\  |            |\\ /|\n1    \\     -->  1  | \\ |    -->  1  | X |\n      \\            |  \\|            |/ \\|\n   4---5           4---5            4---5\n    (a)             (b)              (c)\n```\n在第一次喝茶活动中，$2$ 号认识 $4$ 号，$3$ 号认识 $5$ 号，如上图 (b) 所示。接下来的喝茶活动中，$3$ 号认识了 $4$ 号，如上图 (c) 所示。", "inputFormat": "第 $1$ 行：三个空格隔开的整数：$N$，$M$ 和 $Q$。\n\n\n第 $2 \\dots M+1$ 行：第 $i+1$ 行包含两个空格隔开的整数 $A_i$ 和 $B_i$。\n\n第 $M+2 \\dots M+Q+1$ 行：第 $j+M+1$ 行包含两个空格隔开的整数 $X_j$ 和 $Y_j$，表示询问 $j$。", "outputFormat": "第 $1 \\dots Q$ 行：如果第 $j$ 个询问的两头奶牛认识， 第 $j$ 行输出 `Y`。如果不认识，第 $j$ 行输出 `N`。", "hint": "感谢@蒟蒻orz神犇 提供翻译。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10JAN] Tea Time S", "background": null, "description": "$N (1 \\leq N \\leq 1000)$ cows, conveniently numbered $1 \\dots N$ all attend a tea time every day. $M (1 \\leq M \\leq 2,000)$ unique pairs of those cows have already met before the first tea time. Pair $i$ of these cows who have met is specified by two differing integers $A_i$ and $B_i $ ($1 \\leq A_i \\leq N, 1 \\leq B_i \\leq N$). The input never indicates that cows have met each other more than once.\n\nAt tea time, any cow $i$ and cow $j$ who have met a mutual friend cow $k$ will meet sometime during that tea time and thus expand their circle of known cows.\n\nDetermine whether $Q (1 \\leq Q \\leq 100)$ pairs of cows have met after tea times are held for long enough that no new cow meetings are occurring. Query $j$ consists of a pair of different cows $X_j$ and $Y_j$ ($1 \\leq X_j \\leq N, 1 \\leq Y_j \\leq N$).\n\nFor example, suppose that out of cows $1$ through $5$, we know that $2$ has met $5$, $2$ has met $3$, and $4$ has met $5$; see (a) below.\n\n```\n   2---3           2---3            2---3\n    \\              |\\  |            |\\ /|\n1    \\     -->  1  | \\ |    -->  1  | X |\n      \\            |  \\|            |/ \\|\n   4---5           4---5            4---5\n    (a)             (b)              (c)\n```\n\nIn the first tea time, cow $2$ meets cow $4$, and cow $3$ meets cow $5$; see (b) above. In the second tea time, cow $3$ meets cow $4$; see (c) above.", "inputFormat": "Line $1$: Three space-separated integers: $N$, $M$, and $Q$.\n\nLines $2 \\dots M+1$: Line $i+1$ contains two space-separated integers: $A_i$ and $B_i$.\n\nLines $M+2 \\dots M+Q+1$: Line $j+M+1$ contains query $j$ as two space-separated integers: $X_j$ and $Y_j$.", "outputFormat": "Lines $1 \\dots Q$: Line $j$ should be `Y` if the cows in the $j$-th query have met and `N` if they have not met.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO10JAN] Tea Time S", "background": null, "description": "$N (1 \\leq N \\leq 1000)$ 头奶牛，编号为 $1 \\dots N$，在参加一个喝茶时间活动。在喝茶时间活动开始之前，已经有 $M (1 \\leq M \\leq 2,000)$ 对奶牛彼此认识（是朋友）。第i对彼此认识的奶牛通过两个不相同的整数 $A_i$ 和 $B_i$ 给定（$1 \\leq A_i \\leq N, 1 \\leq B_i \\leq N$）。输入数据保证一对奶牛不会出现多次。 在喝茶时间活动中，如果奶牛 $i$ 和奶牛 $j$ 有一个相同的朋友奶牛 $k$，那么他们会在某次的喝茶活动中去认识对方（成为朋友），从而扩大他们的社交圈。请判断，在喝茶活动举办很久以后（直到没有新的奶牛彼此认识），$Q (1 \\leq Q \\leq 100)$ 对奶牛是否已经彼此认识。询问j包含一对不同的奶牛编号 $X_j$ 和 $Y_j$（$1 \\leq X_j \\leq N, 1 \\leq Y_j \\leq N$）。\n\n例如，假设共有 $5$ 头奶牛，我们知道 $2$ 号认识 $5$ 号，$2$ 号认识 $3$ 号，而且 $4$ 号认识 $5$ 号；如下图 (a)。\n\n```cpp\n   2---3           2---3            2---3\n    \\              |\\  |            |\\ /|\n1    \\     -->  1  | \\ |    -->  1  | X |\n      \\            |  \\|            |/ \\|\n   4---5           4---5            4---5\n    (a)             (b)              (c)\n```\n在第一次喝茶活动中，$2$ 号认识 $4$ 号，$3$ 号认识 $5$ 号，如上图 (b) 所示。接下来的喝茶活动中，$3$ 号认识了 $4$ 号，如上图 (c) 所示。", "inputFormat": "第 $1$ 行：三个空格隔开的整数：$N$，$M$ 和 $Q$。\n\n\n第 $2 \\dots M+1$ 行：第 $i+1$ 行包含两个空格隔开的整数 $A_i$ 和 $B_i$。\n\n第 $M+2 \\dots M+Q+1$ 行：第 $j+M+1$ 行包含两个空格隔开的整数 $X_j$ 和 $Y_j$，表示询问 $j$。", "outputFormat": "第 $1 \\dots Q$ 行：如果第 $j$ 个询问的两头奶牛认识， 第 $j$ 行输出 `Y`。如果不认识，第 $j$ 行输出 `N`。", "hint": "感谢@蒟蒻orz神犇 提供翻译。", "locale": "zh-CN"}}}
{"pid": "P2979", "type": "P", "difficulty": 4, "samples": [["3 53 25 \n100 25 \n20 5 \n40 10 \n", "240 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "USACO", "枚举", "背包 DP"], "title": "[USACO10JAN] Cheese Towers S", "background": "", "description": "Farmer John wants to save some blocks of his cows' delicious Wisconsin cheese varieties in his cellar for the coming winter. He has room for one tower of cheese in his cellar, and that tower's height can be at most T (1 <= T <= 1,000). The cows have provided him with a virtually unlimited number of blocks of each kind of N (1 <= N <= 100) different types of cheese (conveniently numbered 1..N). He'd like to store (subject to the constraints of height) the most\n\nvaluable set of blocks he possibly can. The cows will sell the rest to support the orphan calves association.\n\nEach block of the i-th type of cheese has some value V\\_i (1 <= V\\_i <= 1,000,000) and some height H\\_i (5 <= H\\_i <= T), which is always a multiple of 5.\n\nCheese compresses. A block of cheese that has height greater than or equal to K (1 <= K <= T) is considered 'large' and will crush any and all of the cheese blocks (even other large ones) located below it in the tower. A crushed block of cheese doesn't lose any value, but its height reduces to just 4/5 of its old height. Because the height of a block of cheese is always a multiple of 5, the height of a crushed block of cheese will always be an integer. A block of cheese is either crushed or not crushed; having multiple large blocks above it does not crush it more. Only tall blocks of cheese crush other blocks; aggregate height of a tower does not affect whether a block is crushed or not.\n\nWhat is the total value of the best cheese tower FJ can construct?\n\nConsider, for example, a cheese tower whose maximum height can be 53 to be build from three types of cheese blocks. Large blocks are those that are greater than or equal to 25. Below is a chart of the values and heights of the various cheese blocks he stacks:\n\nType    Value      Height \n\n1      100         25\n\n2       20          5\n\n3       40         10\n\nFJ constructs the following tower: \n\nType Height Value \n\ntop -> [1]   25    100\n\n```cpp\n[2]    4     20   <- crushed by [1] above \n[3]    8     40   <- crushed by [1] above \n[3]    8     40   <- crushed by [1] above \nbottom -> [3]    8     40   <- crushed by [1] above \n```\nThe topmost cheese block is so large that the blocks below it are crushed. The total height is:\n```cpp\n25 + 4 + 8 + 8 + 8 = 53 \nThe total height does not exceed 53 and thus is 'legal'. The total value is: \n100 + 20 + 40 + 40 + 40 = 240. \nThis is the best tower for this particular set of cheese blocks. \n要建一个奶酪塔，高度最大为T。他有N块奶酪。第i块高度为Hi（一定是5的倍数），价值为Vi。一块高度>=K的奶酪被称为大奶酪，一个奶酪如果在它上方有大奶酪（多块只算一次），它的高度就会变成原来的4/5.。 很显然John想让他的奶酪他价值和最大。求这个最大值。\n```", "inputFormat": "\\* Line 1: Three space-separated integers: N, T, and K\n\n\\* Lines 2..N+1: Line i+1 contains two space separated integers: V\\_i and H\\_i\n", "outputFormat": "\\* Line 1: The value of the best tower FJ can build\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10JAN] Cheese Towers S", "background": "", "description": "Farmer John wants to save some blocks of his cows' delicious Wisconsin cheese varieties in his cellar for the coming winter. He has room for one tower of cheese in his cellar, and that tower's height can be at most T (1 <= T <= 1,000). The cows have provided him with a virtually unlimited number of blocks of each kind of N (1 <= N <= 100) different types of cheese (conveniently numbered 1..N). He'd like to store (subject to the constraints of height) the most\n\nvaluable set of blocks he possibly can. The cows will sell the rest to support the orphan calves association.\n\nEach block of the i-th type of cheese has some value V\\_i (1 <= V\\_i <= 1,000,000) and some height H\\_i (5 <= H\\_i <= T), which is always a multiple of 5.\n\nCheese compresses. A block of cheese that has height greater than or equal to K (1 <= K <= T) is considered 'large' and will crush any and all of the cheese blocks (even other large ones) located below it in the tower. A crushed block of cheese doesn't lose any value, but its height reduces to just 4/5 of its old height. Because the height of a block of cheese is always a multiple of 5, the height of a crushed block of cheese will always be an integer. A block of cheese is either crushed or not crushed; having multiple large blocks above it does not crush it more. Only tall blocks of cheese crush other blocks; aggregate height of a tower does not affect whether a block is crushed or not.\n\nWhat is the total value of the best cheese tower FJ can construct?\n\nConsider, for example, a cheese tower whose maximum height can be 53 to be build from three types of cheese blocks. Large blocks are those that are greater than or equal to 25. Below is a chart of the values and heights of the various cheese blocks he stacks:\n\nType    Value      Height \n\n1      100         25\n\n2       20          5\n\n3       40         10\n\nFJ constructs the following tower: \n\nType Height Value \n\ntop -> [1]   25    100\n\n```cpp\n[2]    4     20   <- crushed by [1] above \n[3]    8     40   <- crushed by [1] above \n[3]    8     40   <- crushed by [1] above \nbottom -> [3]    8     40   <- crushed by [1] above \n```\nThe topmost cheese block is so large that the blocks below it are crushed. The total height is:\n```cpp\n25 + 4 + 8 + 8 + 8 = 53 \nThe total height does not exceed 53 and thus is 'legal'. The total value is: \n100 + 20 + 40 + 40 + 40 = 240. \nThis is the best tower for this particular set of cheese blocks. \n要建一个奶酪塔，高度最大为T。他有N块奶酪。第i块高度为Hi（一定是5的倍数），价值为Vi。一块高度>=K的奶酪被称为大奶酪，一个奶酪如果在它上方有大奶酪（多块只算一次），它的高度就会变成原来的4/5.。 很显然John想让他的奶酪他价值和最大。求这个最大值。\n```", "inputFormat": "\\* Line 1: Three space-separated integers: N, T, and K\n\n\\* Lines 2..N+1: Line i+1 contains two space separated integers: V\\_i and H\\_i\n", "outputFormat": "\\* Line 1: The value of the best tower FJ can build\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10JAN] Cheese Towers S", "background": "", "description": "FJ 要建一个奶酪塔，高度最大为 $T\\ (1 \\le T \\le 10^3)$ 。他有 $N\\ (1 \\le N \\le 10^2)$ 种奶酪。第 $i$ 种奶酪的高度为 $H_i\\ (5\\le H_i \\le T\\text{ 且 }5 \\mid H_i)$ ，价值为 $V_i\\ (1 \\le V_i \\le 10^6)$ 。一块高度 $H_i\\ge K\\ (1 \\le K \\le T)$ 的奶酪被称为大奶酪，如果一个奶酪上方有大奶酪（如果有多块就只算一次），这个奶酪的高度 $H_i$ 就会变成原来的 $\\frac{4}{5}$。FJ 想让他的奶酪塔价值和最大。请你求出这个最大值。\n\n例如，考虑一种奶酪塔，其最大高度可以是 $53$，可以用三种类型的奶酪块建造。大块是大于或等于 $25$ 的块。下面是他堆叠的各种奶酪块的值和高度的图表：\n\n|类型|价值|高度|\n| :----------: | :----------: | :----------: |\n|1|100|25|\n|2|20|5|\n|3|40|10|\n\nFJ建造了以下奶酪塔：\n\n|类型|价值|高度|\n| :----------: | :----------: | :----------: |\n|1|100|25|\n|2|20|4|\n|3|40|8|\n|3|40|8|\n|3|40|8|\n\n总高度是 $25 + 4 + 8 + 8 + 8 = 53$，除塔顶奶酪外，其余高度均被压低。总价值是 $100 + 20 + 40 + 40 + 40 = 240$。", "inputFormat": "第1行为三个用空格隔开的整数 $N,T,K$。\n\n第2至 $N+1$ 行中第 $i+1$ 行包含两个用空格隔开的整数 $V_i,H_i$。", "outputFormat": "一行一个整数为奶酪塔的最大价值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2980", "type": "P", "difficulty": 5, "samples": [["5 3 \n0 1 \n1 2 \n3 3 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10FEB] Covering the Corral G", "background": "", "description": "The cows are so modest that they want Farmer John to install covers around the circular corral where they occasionally gather. The corral has circumference $C$ with $1 \\le C \\le 1{,}000{,}000{,}000$, and FJ can choose from a set of $M$ covers with $1 \\le M \\le 100{,}000$, each with a fixed starting point and size. It is guaranteed that at least one set of covers can surround the entire corral.\n\nCover $i$ can be installed at integer location $x_i$ (the distance from the starting point around the corral) with $0 \\le x_i < C$, and has integer length $l_i$ with $1 \\le l_i \\le C$.\n\nFJ wants to minimize the number of segments he must install. What is the minimum number of segments required to cover the entire circumference of the corral?\n\nConsider a corral of circumference $5$, shown below as a pair of connected line segments where both '0's are the same point on the corral (as are both 1's, 2's, and 3's).\n\nThree potential covering segments are available for installation:\n```\nStart   Length\ni      x_i     l_i\n1       0       1\n2       1       2\n3       3       3\n```\n```\n0   1   2   3   4   0   1   2   3  ...\ncorral: +---+---+---+---+--:+---+---+---+- ...\n11111               1111\n22222222            22222222\n333333333333\n|..................|\n```\nAs shown, installing segments 2 and 3 covers an extent of (at least) five units around the circumference. FJ has no trouble with overlap, so do not worry about that.", "inputFormat": "- Line 1: Two space-separated integers $C$ and $M$.\n- Lines $2..M+1$: Line $i+1$ contains two space-separated integers $x_i$ and $l_i$.", "outputFormat": "- Line 1: A single integer, the minimum number of segments required to cover the entire circumference of the corral.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en", "translations": {"en": {"title": "[USACO10FEB] Covering the Corral G", "background": "", "description": "The cows are so modest that they want Farmer John to install covers around the circular corral where they occasionally gather. The corral has circumference $C$ with $1 \\le C \\le 1{,}000{,}000{,}000$, and FJ can choose from a set of $M$ covers with $1 \\le M \\le 100{,}000$, each with a fixed starting point and size. It is guaranteed that at least one set of covers can surround the entire corral.\n\nCover $i$ can be installed at integer location $x_i$ (the distance from the starting point around the corral) with $0 \\le x_i < C$, and has integer length $l_i$ with $1 \\le l_i \\le C$.\n\nFJ wants to minimize the number of segments he must install. What is the minimum number of segments required to cover the entire circumference of the corral?\n\nConsider a corral of circumference $5$, shown below as a pair of connected line segments where both '0's are the same point on the corral (as are both 1's, 2's, and 3's).\n\nThree potential covering segments are available for installation:\n```\nStart   Length\ni      x_i     l_i\n1       0       1\n2       1       2\n3       3       3\n```\n```\n0   1   2   3   4   0   1   2   3  ...\ncorral: +---+---+---+---+--:+---+---+---+- ...\n11111               1111\n22222222            22222222\n333333333333\n|..................|\n```\nAs shown, installing segments 2 and 3 covers an extent of (at least) five units around the circumference. FJ has no trouble with overlap, so do not worry about that.", "inputFormat": "- Line 1: Two space-separated integers $C$ and $M$.\n- Lines $2..M+1$: Line $i+1$ contains two space-separated integers $x_i$ and $l_i$.", "outputFormat": "- Line 1: A single integer, the minimum number of segments required to cover the entire circumference of the corral.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10FEB] Covering the Corral G", "background": "", "description": "The cows are so modest they want Farmer John to install covers around the circular corral where they occasionally gather. The corral has circumference C (1 <= C <= 1,000,000,000), and FJ can choose from a set of M (1 <= M <= 100,000) covers that have fixed starting points and sizes. At least one set of covers can surround the entire corral.\n\nCover i can be installed at integer location x\\_i (distance from starting point around corral) (0 <= x\\_i < C) and has integer length l\\_i (1 <= l\\_i <= C).\n\nFJ wants to minimize the number of segments he must install. What is the minimum number of segments required to cover the entire circumference of the corral?\n\nConsider a corral of circumference 5, shown below as a pair of connected line segments where both '0's are the same point on the corral (as are both 1's, 2's, and 3's).\n\nThree potential covering segments are available for installation:\n\nStart   Length\n\ni     x\\_i     l\\_i\n\n1      0       1\n\n2      1       2\n\n3      3       3\n\n0   1   2   3   4   0   1   2   3  ...\n\ncorral: +---+---+---+---+--:+---+---+---+- ...\n\n11111               1111\n\n22222222            22222222\n\n333333333333\n\n|..................| \nAs shown, installing segments 2 and 3 cover an extent of (at least) five units around the circumference. FJ has no trouble with the overlap, so don't worry about that.\n\n奶牛们非常羞涩，他们要求Farmer John在他们的圆形牛棚周围建造围栏。牛棚的周长为c(1 <= C <= 1,000,000,000)，现在，FJ希望从一些有固定起点和终点的栏杆的集合里选出一些栏杆。 栏杆i 的起点可以被建造在一个整数位置 x\\_i(相距围栏起点i个长度) (0 <= x\\_i < C),并且，这个栏杆有一个整数长度l\\_i(1 <= l\\_i <= C)。 FJ 希望最小化栏杆的数量，从而达到覆盖整个牛棚的外圈。\n", "inputFormat": "\\* Line 1: Two space-separated integers: C and M\n\n\\* Lines 2..M+1: Line i+1 contains two space-separated integers: x\\_i and l\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the minimum number of segments required to cover all segments of the circumference of the corral\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2981", "type": "P", "difficulty": 5, "samples": [["6 2 1 5 1 \n5 4 \n2 3 \n1 1 \n6 2 \n5 0 \n0 0 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10FEB] Cows on Ice G", "background": null, "description": "Bessie 在一个冰封的湖面上溜冰，湖面可以表示为二维的平面，坐标范围是 $-10^9 \\cdots10^9$。湖面上的 $N(1 \\le N \\le 20000)$ 个位置有石块(编号分别为 $1$ 到 $N$)，第 $i$ 个石块在 $(X_i, Y_i)$，其它位置是滑溜溜的冰面。\n\n由于 Bessie 滑冰技术不够好，她通过推动自己旁边的石块，依靠反作用力向某一个方向前进，在碰到一个新的石块之前，Bessie 是不会停下来的。(当然，最后会停留在某块石块的前一个格子里)由于 Bessie 无法计算复杂的角度，她只能够向东南西北四个方向前进。很显然，Bessie 不能够穿越石块，因此，Bessie 仅仅可以向三个方向滑。 \n\n滑冰不是没有风险，Bessie滑向某个方向后必须能碰到某个石块，因此她必须很小心。\n\n考虑下面的状况：Bessie 想要到达在她东边的 $(5, 1)$（`.` 表示冰，`*` 表示石头，`B` 表示 Bessie，`G` 表示终点）。如果她直接向东滑，她会滑过头，因为她只能在撞击一块石头时停下。可以用下面的方式到达 $(5, 1)$\n\n```cpp\n    (a)             (b)             (c)             (d)\n4 .....*.         .....*.         .....*.         .....*.\n3 ..*....    ^    ..*....    >    ..*....    v    ..*....\n2 ......*    ^    ..B...*    >    .....B*    v    ......*\n1 .*B..G. ------> .*...G. ------> .*...G. ------> .*...B.\n0 *....*.         *....*.         *....*.         *....*.\n  0123456\n```\n\n在情况（a）中 Bessie 可以向北、东和南滑动，但是只有向北滑能够撞击石头。在情况（b）中 Bessie 同理只能向东滑。\n\nBessie 一开始在 $(B_x, B_y)$，她需要到达 $(G_x, G_y)$。\n\nBessie 不太介意滑冰。但是，由于她的体重问题（毕竟她是一只牛），她需要很大的力气才能够把自己推动并向某一个方向滑去。所以，Farmer John 想要知道她至少需要几次才能够到达目的地。", "inputFormat": "第一行五个整数 $N$，$B_x$，$B_y$，$G_x$ 与 $G_y$。\n\n接下来 $N$ 行，第 $i$ 行两个整数 $X_i$ 和 $Y_i$。", "outputFormat": "一行一个整数，表示 Bessie 最少需要推动自己几次。", "hint": "保证没有两个石块在同一个位置上。\n\n保证有解。\n\n\n$1 \\le N \\le 20000$,$-10^9 \\le X_i, Y_i, B_x, B_y, G_x, G_y \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10FEB] Cows on Ice G", "background": "", "description": "Bessie is ice skating on a large frozen lake modelled as a 2-dimensional grid with coordinates in the range $-10^9 \\cdots 10^9$. $N(1 \\le N \\le 20,000)$ of the lake's grid cells contain rocks(conveniently numbered $1 \\cdots N$). The other cells contain slippery ice.\n\nSince Bessie is not a very good skater, she traverses the lake's cells by pushing herself away from her current position near a rock and sliding continuously in the same direction until she hits another rock (stopping in the square before she hits the rock, of course). Never good with complicated angles, Bessie can push herself only straight north, east, south, or west. She can't push herself through the rock, of course, and thus generally has only three possible directions to move.\n\nSliding is not without risks. Bessie must hit a rock or might end up sliding for a very long time. She must aim her pushes carefully.\n\nConsider the situation depicted below; Bessie wants to get to location $(5, 1)$, which is east of her current location (`.` = ice, `*` = rock, `B` = Bessie, `G` = goal). If she slides directly to the east, she will slide past the location since she can stop only by encountering a rock head on. One way to get to $(5, 1)$ is the following:\n\n```cpp\n    (a)             (b)             (c)             (d)\n4 .....*.         .....*.         .....*.         .....*.\n3 ..*....  slide  ..*....  slide  ..*....  slide  ..*....\n2 ......*  north  ..B...*  east   .....B*  south  ......*\n1 .*B..G. ------> .*...G. ------> .*...G. ------> .*...B.\n0 *....*.         *....*.         *....*.         *....*.\n  0123456\n```\n\nBessie could slide north, east, or south in situation (a), but only north has a rock for stopping. For situation (b), she can slide only east for the same reason.\n\nFor the input, rock i is located at cell $(X_i,Y_i)(-10^9 \\le X_i \\le 10^9,-10^9 \\le Y_i \\le 10^9)$, and no two rocks occupy the same position. Bessie starts at $B_x$,$B_y$ (which is next to a rock) $(-10^9 \\le Bx \\le 10^9,-10^9 \\le By \\le 10^9)$. Bessie's goal is $G_x$,$G_y$ $(-10 \\le Gx \\le 10^9,-10^9 \\le Gy \\le 10^9)$. Bessie can always reach the goal one way or another.\n\nBessie doesn't mind sliding. However, pushing herself away from a rock is very tiring. To prepare her, FJ would like to know the minimum number of pushes Bessie needs to do.", "inputFormat": "* Line 1: Five space separated integers: $N$, $B_x$, $B_y$, $G_x$, and $G_y$.\n\n* Lines $2 \\cdots N+1$: Line $i+1$ describes a rock location with space separated integers: $X_i$ and $Y_i$.", "outputFormat": "Line 1: A single integer that is the minimum number of pushes for Bessie to get to her goal.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10FEB] Cows on Ice G", "background": null, "description": "Bessie 在一个冰封的湖面上溜冰，湖面可以表示为二维的平面，坐标范围是 $-10^9 \\cdots10^9$。湖面上的 $N(1 \\le N \\le 20000)$ 个位置有石块(编号分别为 $1$ 到 $N$)，第 $i$ 个石块在 $(X_i, Y_i)$，其它位置是滑溜溜的冰面。\n\n由于 Bessie 滑冰技术不够好，她通过推动自己旁边的石块，依靠反作用力向某一个方向前进，在碰到一个新的石块之前，Bessie 是不会停下来的。(当然，最后会停留在某块石块的前一个格子里)由于 Bessie 无法计算复杂的角度，她只能够向东南西北四个方向前进。很显然，Bessie 不能够穿越石块，因此，Bessie 仅仅可以向三个方向滑。 \n\n滑冰不是没有风险，Bessie滑向某个方向后必须能碰到某个石块，因此她必须很小心。\n\n考虑下面的状况：Bessie 想要到达在她东边的 $(5, 1)$（`.` 表示冰，`*` 表示石头，`B` 表示 Bessie，`G` 表示终点）。如果她直接向东滑，她会滑过头，因为她只能在撞击一块石头时停下。可以用下面的方式到达 $(5, 1)$\n\n```cpp\n    (a)             (b)             (c)             (d)\n4 .....*.         .....*.         .....*.         .....*.\n3 ..*....    ^    ..*....    >    ..*....    v    ..*....\n2 ......*    ^    ..B...*    >    .....B*    v    ......*\n1 .*B..G. ------> .*...G. ------> .*...G. ------> .*...B.\n0 *....*.         *....*.         *....*.         *....*.\n  0123456\n```\n\n在情况（a）中 Bessie 可以向北、东和南滑动，但是只有向北滑能够撞击石头。在情况（b）中 Bessie 同理只能向东滑。\n\nBessie 一开始在 $(B_x, B_y)$，她需要到达 $(G_x, G_y)$。\n\nBessie 不太介意滑冰。但是，由于她的体重问题（毕竟她是一只牛），她需要很大的力气才能够把自己推动并向某一个方向滑去。所以，Farmer John 想要知道她至少需要几次才能够到达目的地。", "inputFormat": "第一行五个整数 $N$，$B_x$，$B_y$，$G_x$ 与 $G_y$。\n\n接下来 $N$ 行，第 $i$ 行两个整数 $X_i$ 和 $Y_i$。", "outputFormat": "一行一个整数，表示 Bessie 最少需要推动自己几次。", "hint": "保证没有两个石块在同一个位置上。\n\n保证有解。\n\n\n$1 \\le N \\le 20000$,$-10^9 \\le X_i, Y_i, B_x, B_y, G_x, G_y \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P2982", "type": "P", "difficulty": 5, "samples": [["5 \n1 4 \n5 4 \n1 3 \n2 4 \n4 \n2 \n1 \n5 \n3 \n", "0 \n1 \n0 \n2 \n1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "线段树", "USACO", "树状数组", "深度优先搜索 DFS"], "title": "[USACO10FEB] Slowing down G", "background": "", "description": "Every day each of Farmer John's N $(1 \\le N \\le 100,000)$ cows conveniently numbered $1..N$ move from the barn to her private pasture. The pastures are organized as a tree, with the barn being on pasture $1$. Exactly $N-1$ cow unidirectional paths connect the pastures; directly connected pastures have exactly one path. Path $i$ connects pastures $A_i$ and $B_i$ $(1 \\le A_i \\le N,1 \\le B_i \\le N)$.\n\nCow $i$ has a private pasture $P_i(1 \\le P_i \\le N)$. The barn's small door lets only one cow exit at a time; and the patient cows wait until their predecessor arrives at her private pasture. First cow $1$ exits and moves to pasture $P_1$. Then cow $2$ exits and goes to pasture $P_2$, and so on.\n\nWhile cow $i$ walks to $P_i$ she might or might not pass through a pasture that already contains an eating cow. When a cow is present in a pasture, cow $i$ walks slower than usual to prevent annoying her friend.\n\n```cpp\nConsider the following pasture network, where the number between\nparentheses indicates the pastures' owner.\n\n        1 (3)        \n       / \\\n  (1) 4   3 (5)\n     / \\   \n(2) 2   5 (4)\n\nFirst, cow 1 walks to her pasture:\n\n        1 (3)        \n       / \\\n  [1] 4*  3 (5)\n     / \\   \n(2) 2   5 (4)\n\nWhen cow 2 moves to her pasture, she first passes into the barn's\npasture, pasture 1. Then she sneaks around cow 1 in pasture 4 before\narriving at her own pasture.\n\n        1 (3)\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5 (4)\n\nCow 3 doesn't get far at all -- she lounges in the barn's pasture, #1.\n\n        1* [3]\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5 (4)\n\nCow 4 must slow for pasture 1 and 4 on her way to pasture 5:\n\n        1* [3]\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5* [4]\n\nCow 5 slows for cow 3 in pasture 1 and then enters her own private pasture:\n\n        1* [3]\n       / \\\n  [1] 4*  3*[5]\n     / \\   \n[2] 2*  5* [4]\n```\n\nFJ would like to know how many times each cow has to slow down.\n\n每天 Farmer John 的 $N$ 头奶牛，编号 $1 \\ldots N$，从粮仓走向他的自己的牧场。牧场构成了一棵树，粮仓在 $1$ 号牧场。恰好有 $N-1$ 条道路直接连接着牧场，使得牧场之间都恰好有一条路径相连。第 $i$ 条路连接着 $A_i$ 和 $B_i$。奶牛们每人有一个私人牧场 $P_i$。粮仓的门每次只能让一只奶牛离开。耐心的奶牛们会等到他们的前面的朋友们到达了自己的私人牧场后才离开。首先奶牛 $1$ 离开，前往 $P_1$；然后是奶牛 $2$，以此类推。\n\n当奶牛 $i$ 走向牧场 $P_i$ 的时候，他可能会经过正在吃草的同伴旁。当路过已经有奶牛的牧场时，奶牛 $i$ 会放慢自己的速度，防止打扰他的朋友。\n\nFJ 想要知道奶牛们总共要放慢多少次速度。", "inputFormat": "\n\\* Line $1$: Line $1$ contains a single integer: $N$\n\n\\* Lines $2..N$: Line $i+1$ contains two space-separated integers: $A_i$ and $B_i$\n\n\\* Lines $N+1..N+N$: line $N+i$ contains a single integer: $P_i$\n\n第一行：有一个整数 $N$。\n\n第 $2 \\sim N$ 行：第 $i+1$ 行有两个以空格隔开的整数 $A_i$ 和 $B_i$。\n\n第 $N+1 \\sim N+N$ 行：第 $N+i$ 行有一个整数 $P_i$。", "outputFormat": "\\* Lines $1 \\sim N$：Line $i$ contains the number of times cow $i$ has to slow down.\n\n第 $1 \\sim N$ 行：第 $i$ 行包括奶牛 $i$ 需要放慢速度的次数。", "hint": "数据范围：$1 \\leq A_i,B_i,P_i\\leq N \\leq 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10FEB] Slowing down G", "background": "", "description": "Every day, each of Farmer John's $N$ $(1 \\le N \\le 100{,}000)$ cows, conveniently numbered $1..N$, moves from the barn to her private pasture. The pastures form a tree, with the barn at pasture $1$. Exactly $N-1$ undirected paths connect the pastures; directly connected pastures have exactly one path. Path $i$ connects pastures $A_i$ and $B_i$ $(1 \\le A_i \\le N, 1 \\le B_i \\le N)$.\n\nCow $i$ has a private pasture $P_i$ $(1 \\le P_i \\le N)$. The barn's small door lets only one cow exit at a time, and the patient cows wait until their predecessor arrives at her private pasture. First, cow $1$ exits and moves to pasture $P_1$. Then cow $2$ exits and goes to pasture $P_2$, and so on.\n\nWhile cow $i$ walks to $P_i$, she might or might not pass through a pasture that already contains an eating cow. When a cow is present in a pasture, cow $i$ walks slower than usual while passing through that pasture to avoid annoying her friend.\n\n```cpp\nConsider the following pasture network, where the number between\nparentheses indicates the pastures' owner.\n\n        1 (3)        \n       / \\\n  (1) 4   3 (5)\n     / \\   \n(2) 2   5 (4)\n\nFirst, cow 1 walks to her pasture:\n\n        1 (3)        \n       / \\\n  [1] 4*  3 (5)\n     / \\   \n(2) 2   5 (4)\n\nWhen cow 2 moves to her pasture, she first passes into the barn's\npasture, pasture 1. Then she sneaks around cow 1 in pasture 4 before\narriving at her own pasture.\n\n        1 (3)\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5 (4)\n\nCow 3 doesn't get far at all -- she lounges in the barn's pasture, #1.\n\n        1* [3]\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5 (4)\n\nCow 4 must slow for pasture 1 and 4 on her way to pasture 5:\n\n        1* [3]\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5* [4]\n\nCow 5 slows for cow 3 in pasture 1 and then enters her own private pasture:\n\n        1* [3]\n       / \\\n  [1] 4*  3*[5]\n     / \\   \n[2] 2*  5* [4]\n```\n\nFJ would like to know how many times each cow has to slow down.", "inputFormat": "- Line 1: An integer $N$.\n- Lines $2..N$: Line $i+1$ contains two space-separated integers $A_i$ and $B_i$.\n- Lines $N+1..N+N$: Line $N+i$ contains a single integer $P_i$.", "outputFormat": "- Lines $1..N$: Line $i$ contains the number of times cow $i$ has to slow down.", "hint": "Constraints: $1 \\leq A_i, B_i, P_i \\leq N \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10FEB] Slowing down G", "background": "", "description": "Every day each of Farmer John's N $(1 \\le N \\le 100,000)$ cows conveniently numbered $1..N$ move from the barn to her private pasture. The pastures are organized as a tree, with the barn being on pasture $1$. Exactly $N-1$ cow unidirectional paths connect the pastures; directly connected pastures have exactly one path. Path $i$ connects pastures $A_i$ and $B_i$ $(1 \\le A_i \\le N,1 \\le B_i \\le N)$.\n\nCow $i$ has a private pasture $P_i(1 \\le P_i \\le N)$. The barn's small door lets only one cow exit at a time; and the patient cows wait until their predecessor arrives at her private pasture. First cow $1$ exits and moves to pasture $P_1$. Then cow $2$ exits and goes to pasture $P_2$, and so on.\n\nWhile cow $i$ walks to $P_i$ she might or might not pass through a pasture that already contains an eating cow. When a cow is present in a pasture, cow $i$ walks slower than usual to prevent annoying her friend.\n\n```cpp\nConsider the following pasture network, where the number between\nparentheses indicates the pastures' owner.\n\n        1 (3)        \n       / \\\n  (1) 4   3 (5)\n     / \\   \n(2) 2   5 (4)\n\nFirst, cow 1 walks to her pasture:\n\n        1 (3)        \n       / \\\n  [1] 4*  3 (5)\n     / \\   \n(2) 2   5 (4)\n\nWhen cow 2 moves to her pasture, she first passes into the barn's\npasture, pasture 1. Then she sneaks around cow 1 in pasture 4 before\narriving at her own pasture.\n\n        1 (3)\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5 (4)\n\nCow 3 doesn't get far at all -- she lounges in the barn's pasture, #1.\n\n        1* [3]\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5 (4)\n\nCow 4 must slow for pasture 1 and 4 on her way to pasture 5:\n\n        1* [3]\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5* [4]\n\nCow 5 slows for cow 3 in pasture 1 and then enters her own private pasture:\n\n        1* [3]\n       / \\\n  [1] 4*  3*[5]\n     / \\   \n[2] 2*  5* [4]\n```\n\nFJ would like to know how many times each cow has to slow down.\n\n每天 Farmer John 的 $N$ 头奶牛，编号 $1 \\ldots N$，从粮仓走向他的自己的牧场。牧场构成了一棵树，粮仓在 $1$ 号牧场。恰好有 $N-1$ 条道路直接连接着牧场，使得牧场之间都恰好有一条路径相连。第 $i$ 条路连接着 $A_i$ 和 $B_i$。奶牛们每人有一个私人牧场 $P_i$。粮仓的门每次只能让一只奶牛离开。耐心的奶牛们会等到他们的前面的朋友们到达了自己的私人牧场后才离开。首先奶牛 $1$ 离开，前往 $P_1$；然后是奶牛 $2$，以此类推。\n\n当奶牛 $i$ 走向牧场 $P_i$ 的时候，他可能会经过正在吃草的同伴旁。当路过已经有奶牛的牧场时，奶牛 $i$ 会放慢自己的速度，防止打扰他的朋友。\n\nFJ 想要知道奶牛们总共要放慢多少次速度。", "inputFormat": "\n\\* Line $1$: Line $1$ contains a single integer: $N$\n\n\\* Lines $2..N$: Line $i+1$ contains two space-separated integers: $A_i$ and $B_i$\n\n\\* Lines $N+1..N+N$: line $N+i$ contains a single integer: $P_i$\n\n第一行：有一个整数 $N$。\n\n第 $2 \\sim N$ 行：第 $i+1$ 行有两个以空格隔开的整数 $A_i$ 和 $B_i$。\n\n第 $N+1 \\sim N+N$ 行：第 $N+i$ 行有一个整数 $P_i$。", "outputFormat": "\\* Lines $1 \\sim N$：Line $i$ contains the number of times cow $i$ has to slow down.\n\n第 $1 \\sim N$ 行：第 $i$ 行包括奶牛 $i$ 需要放慢速度的次数。", "hint": "数据范围：$1 \\leq A_i,B_i,P_i\\leq N \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P2983", "type": "P", "difficulty": 3, "samples": [["5 50 \n5 3 \n1 1 \n10 4 \n7 2 \n60 1 \n", "8 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2010", "USACO"], "title": "[USACO10FEB] Chocolate Buying S", "background": "", "description": "Bessie and the herd love chocolate so Farmer John is buying them some.\n\nThe Bovine Chocolate Store features $N (1 \\le N \\le 100,000)$ kinds of chocolate in essentially unlimited quantities.  Each type i of chocolate has price $P_i (1 \\le P_i \\le 10^{18})$ per piece and there are $C_i (1 \\le C_i \\le 10^{18})$ cows that want that type of chocolate.\n\nFarmer John has a budget of $B (1 \\le B \\le 10^{18})$ that he can spend on chocolates for the cows. What is the maximum number of cows that he can satisfy?  All cows only want one type of chocolate, and will be satisfied only by that type.\n\nConsider an example where FJ has $50$ to spend on $5$ different types of chocolate. A total of eleven cows have various chocolate preferences:\n\n|Chocolate\\_Type|Per\\_Chocolate\\_Cost|Cows\\_preferring\\_this\\_type| \n|:-----------:|:-----------:|:-----------:|\n|$1$|$5$|$3$|\n|$2$|$1$|$1$|\n|$3$|$10$|$4$|\n|$4$|$7$|$2$|\n|$5$|$60$|$1$|\n\nObviously, FJ can't purchase chocolate type $5$, since he doesn't have enough money. Even if it cost only $50$, it's a counterproductive purchase since only one cow would be satisfied.\n\nLooking at the chocolates start at the less expensive ones, he can purchase $1$ chocolate of type $2$ for $1 \\times 1$ leaving $50-1=49$, then purchase $3$ chocolate of type $1$ for $3 \\times 5$ leaving $49-15=34$, then  purchase $2$ chocolate of type $4$ for $2 \\times 7$ leaving $34-14=20$, then  purchase $2$ chocolate of type $3$ for $2 \\times 10$ leaving $20-20=0$.\n\nHe would thus satisfy $1 + 3 + 2 + 2 = 8$ cows. ", "inputFormat": "\nLine $1$: Two space separated integers: $N$ and $B$.\n\nLines $2\\ldots N+1$: Line $i$ contains two space separated integers defining chocolate type $i$: $P_i$ and $C_i$.", "outputFormat": "Line $1$: A single integer that is the maximum number of cows that Farmer John can satisfy.", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10FEB] Chocolate Buying S", "background": "", "description": "Bessie and the herd love chocolate so Farmer John is buying them some.\n\nThe Bovine Chocolate Store features $N (1 \\le N \\le 100,000)$ kinds of chocolate in essentially unlimited quantities.  Each type i of chocolate has price $P_i (1 \\le P_i \\le 10^{18})$ per piece and there are $C_i (1 \\le C_i \\le 10^{18})$ cows that want that type of chocolate.\n\nFarmer John has a budget of $B (1 \\le B \\le 10^{18})$ that he can spend on chocolates for the cows. What is the maximum number of cows that he can satisfy?  All cows only want one type of chocolate, and will be satisfied only by that type.\n\nConsider an example where FJ has $50$ to spend on $5$ different types of chocolate. A total of eleven cows have various chocolate preferences:\n\n|Chocolate\\_Type|Per\\_Chocolate\\_Cost|Cows\\_preferring\\_this\\_type| \n|:-----------:|:-----------:|:-----------:|\n|$1$|$5$|$3$|\n|$2$|$1$|$1$|\n|$3$|$10$|$4$|\n|$4$|$7$|$2$|\n|$5$|$60$|$1$|\n\nObviously, FJ can't purchase chocolate type $5$, since he doesn't have enough money. Even if it cost only $50$, it's a counterproductive purchase since only one cow would be satisfied.\n\nLooking at the chocolates start at the less expensive ones, he can purchase $1$ chocolate of type $2$ for $1 \\times 1$ leaving $50-1=49$, then purchase $3$ chocolate of type $1$ for $3 \\times 5$ leaving $49-15=34$, then  purchase $2$ chocolate of type $4$ for $2 \\times 7$ leaving $34-14=20$, then  purchase $2$ chocolate of type $3$ for $2 \\times 10$ leaving $20-20=0$.\n\nHe would thus satisfy $1 + 3 + 2 + 2 = 8$ cows. ", "inputFormat": "\nLine $1$: Two space separated integers: $N$ and $B$.\n\nLines $2\\ldots N+1$: Line $i$ contains two space separated integers defining chocolate type $i$: $P_i$ and $C_i$.", "outputFormat": "Line $1$: A single integer that is the maximum number of cows that Farmer John can satisfy.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10FEB] Chocolate Buying S", "background": "", "description": "Bessie 和牛群都非常喜欢巧克力，所以农夫约翰打算为它们购买一些。\n\n牛巧克力商店提供 $N$ 种巧克力（$1 \\le N \\le 100,000$），每种巧克力的数量基本上是无限的。每种巧克力 $i$ 的单价为 $P_i$（$1 \\le P_i \\le 10^{18}$），并且有 $C_i$（$1 \\le C_i \\le 10^{18}$）头牛想要这种巧克力。\n\n农夫约翰有一个预算 $B$（$1 \\le B \\le 10^{18}$），他可以用来为牛群购买巧克力。他最多能满足多少头牛？所有的牛只想要一种巧克力，并且只会对这种巧克力感到满意。\n\n考虑一个例子，假设农夫约翰有 $50$ 元可以花在 $5$ 种不同的巧克力上。总共有 11 头牛对各种巧克力有不同的偏好：\n\n| 巧克力类型 | 每块巧克力的价格 | 喜欢这种类型的牛数量 | \n|:-----------:|:-----------:|:-----------:|\n| $1$ | $5$ | $3$ |\n| $2$ | $1$ | $1$ |\n| $3$ | $10$ | $4$ |\n| $4$ | $7$ | $2$ |\n| $5$ | $60$ | $1$ |\n\n显然，农夫约翰不能购买第 5 种巧克力，因为他没有足够的钱。即使它只花费 $50$，这也是一个不划算的购买，因为只有一头牛会感到满意。\n\n从价格较低的巧克力开始，他可以购买 1 块第 2 种巧克力，花费 $1 \\times 1$，剩下 $50-1=49$；然后购买 3 块第 1 种巧克力，花费 $3 \\times 5$，剩下 $49-15=34$；然后购买 2 块第 4 种巧克力，花费 $2 \\times 7$，剩下 $34-14=20$；最后购买 2 块第 3 种巧克力，花费 $2 \\times 10$，剩下 $20-20=0$。\n\n这样，他就能满足 $1 + 3 + 2 + 2 = 8$ 头牛。", "inputFormat": "\n第 1 行：两个用空格分隔的整数：$N$ 和 $B$。\n\n第 $2\\ldots N+1$ 行：第 $i$ 行包含两个用空格分隔的整数，定义巧克力类型 $i$：$P_i$ 和 $C_i$。", "outputFormat": "第 1 行：一个整数，表示农夫约翰最多能满足的牛的数量。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2984", "type": "P", "difficulty": 3, "samples": [["6 7 3 \n1 2 3 \n5 4 3 \n3 1 1 \n6 1 9 \n3 4 2 \n1 4 4 \n3 2 2 \n2 4 \n5 1 \n3 6 \n", "6 \n6 \n10 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2010", "USACO", "最短路"], "title": "[USACO10FEB] Chocolate Giving S", "background": null, "description": "Farmer John is distributing chocolates at the barn for Valentine's day, and $B$ ($1 \\le B \\le 25000$) of his bulls have a special cow in mind to receive a chocolate gift.\n\nEach of the bulls and cows is grazing alone in one of the farm's $N$ ($2\\times B \\le N \\le 50000$) pastures conveniently numbered $1\\dots N$ and connected by $M$ ($N-1 \\le M \\le 10^5$) bidirectional cowpaths of various lengths. Some pastures might be directly connected by more than one cowpath. Cowpath $i$ connects pastures $R_i $ and $S_i$ ($1 \\le R_i \\le N$; $1 \\le S_i \\le N$) and has length $L_i$ ($1 \\le L_i \\le 2000$).\n\nBull $i$ resides in pasture $P_i$ ($1 \\le P_i \\le N$) and wishes to give a chocolate to the cow in pasture $Q_i$ ($1 \\le Q_i \\le N$).\n\nHelp the bulls find the shortest path from their current pasture to the barn (which is located at pasture $1$) and then onward to the pasture where their special cow is grazing. The barn connects, one way or another (potentially via other cowpaths and pastures) to every pasture.\n\nAs an example, consider a farm with $6$ pastures, $6$ paths, and $3$ bulls (in pastures $2$, $3$, and $5$) who wish to bestow chocolates on their love-objects:\n\n```cpp\n\n                      *1  <-- Bull wants chocolates for pasture 1 cow\n             [4]--3--[5]  <-- [5] is the pasture ID\n            /  |\n           /   |\n          4    2          <-- 2 is the cowpath length\n         /     |               between [3] and [4]\n      [1]--1--[3]*6\n     /   \\    /\n    9     3  2\n   /       \\/\n [6]      [2]*4\n```\n\\* The Bull in pasture $2$ can travel distance $3$ (two different ways) to get to the barn then travel distance $2+1$ to pastures $[3]$ and $[4]$ to gift his chocolate. That's $6$ altogether.\n\n\\* The Bull in pasture $5$ can travel to pasture $4$ (distance $3$), then pastures $3$ and $1$ (total: $3 + 2 + 1 = 6$) to bestow his chocolate offer.\n\n\\* The Bull in pasture $3$ can travel distance $1$ to pasture $1$ and then take his chocolate $9$ more to pasture $6$, a total distance of $10$.", "inputFormat": "\\* Line $1$: Three space separated integers: $N$, $M$, and $B$;\n\n\\* Lines $2\\dots M+1$: Line $i+1$ describes cowpath $i$ with three space-separated integers: $R_i$, $S_i$, and $L_i$;\n\n\\* Lines $M+2\\dots M+B+1$: Line $M+i+1$ contains two space separated integers: $P_i$ and $Q_i$.", "outputFormat": "\\* Lines $1\\dots B$: Line $i$ should contain a single integer, the smallest distance that the bull in pasture $P_i$ must travel to get chocolates from the barn and then award them to the cow of his dreams in pasture $Q_i$.", "hint": null, "locale": "en", "translations": {"en": {"title": "[USACO10FEB] Chocolate Giving S", "background": null, "description": "Farmer John is distributing chocolates at the barn for Valentine's day, and $B$ ($1 \\le B \\le 25000$) of his bulls have a special cow in mind to receive a chocolate gift.\n\nEach of the bulls and cows is grazing alone in one of the farm's $N$ ($2\\times B \\le N \\le 50000$) pastures conveniently numbered $1\\dots N$ and connected by $M$ ($N-1 \\le M \\le 10^5$) bidirectional cowpaths of various lengths. Some pastures might be directly connected by more than one cowpath. Cowpath $i$ connects pastures $R_i $ and $S_i$ ($1 \\le R_i \\le N$; $1 \\le S_i \\le N$) and has length $L_i$ ($1 \\le L_i \\le 2000$).\n\nBull $i$ resides in pasture $P_i$ ($1 \\le P_i \\le N$) and wishes to give a chocolate to the cow in pasture $Q_i$ ($1 \\le Q_i \\le N$).\n\nHelp the bulls find the shortest path from their current pasture to the barn (which is located at pasture $1$) and then onward to the pasture where their special cow is grazing. The barn connects, one way or another (potentially via other cowpaths and pastures) to every pasture.\n\nAs an example, consider a farm with $6$ pastures, $6$ paths, and $3$ bulls (in pastures $2$, $3$, and $5$) who wish to bestow chocolates on their love-objects:\n\n```cpp\n\n                      *1  <-- Bull wants chocolates for pasture 1 cow\n             [4]--3--[5]  <-- [5] is the pasture ID\n            /  |\n           /   |\n          4    2          <-- 2 is the cowpath length\n         /     |               between [3] and [4]\n      [1]--1--[3]*6\n     /   \\    /\n    9     3  2\n   /       \\/\n [6]      [2]*4\n```\n\\* The Bull in pasture $2$ can travel distance $3$ (two different ways) to get to the barn then travel distance $2+1$ to pastures $[3]$ and $[4]$ to gift his chocolate. That's $6$ altogether.\n\n\\* The Bull in pasture $5$ can travel to pasture $4$ (distance $3$), then pastures $3$ and $1$ (total: $3 + 2 + 1 = 6$) to bestow his chocolate offer.\n\n\\* The Bull in pasture $3$ can travel distance $1$ to pasture $1$ and then take his chocolate $9$ more to pasture $6$, a total distance of $10$.", "inputFormat": "\\* Line $1$: Three space separated integers: $N$, $M$, and $B$;\n\n\\* Lines $2\\dots M+1$: Line $i+1$ describes cowpath $i$ with three space-separated integers: $R_i$, $S_i$, and $L_i$;\n\n\\* Lines $M+2\\dots M+B+1$: Line $M+i+1$ contains two space separated integers: $P_i$ and $Q_i$.", "outputFormat": "\\* Lines $1\\dots B$: Line $i$ should contain a single integer, the smallest distance that the bull in pasture $P_i$ must travel to get chocolates from the barn and then award them to the cow of his dreams in pasture $Q_i$.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO10FEB] Chocolate Giving S", "background": "", "description": "FJ 有 $B$ 头奶牛 $(1\\le B\\le 25000)$，有 $N(2\\times B\\le N\\le 50000)$ 个农场，编号 $1$ 到 $N$，有 $M(N-1\\le M\\le 100000)$ 条双向边，第 $i$ 条边连接农场 $R_i$ 和 $S_i(1\\le R_i\\le N, 1\\le S_i\\le N)$，该边的长度是 $L_i(1\\le L_i\\le 2000)$。居住在农场 $P_i$ 的奶牛 A $(1\\le P_i\\le N)$，想送一份新年礼物给居住在农场 $Q_i(1\\le Q_i\\le N)$ 的奶牛 B，但是奶牛 A 必须先到 FJ（居住在编号 $1$ 的农场）那里取礼物，然后再送给奶牛 B。你的任务是：奶牛 A 至少需要走多远的路程？", "inputFormat": "* 第一行三个整数 $N,M,B$。\n* 第 $2$ 至 $M+1$ 行，每行 $3$ 个整数 $R_i,S_i,L_i$。\n\n* 第 $M+2$ 至 $M+B+1$ 行，进行 $B$ 次询问，每行 $2$ 个整数 $P_i ,Q_i$。", "outputFormat": "每次询问输出一个整数，即答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2985", "type": "P", "difficulty": 3, "samples": [["5 5 \n10 \n40 \n13 \n22 \n7 \n", "24 \n1 \n1 \n3 \n4 \n5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2010", "二分", "USACO"], "title": "[USACO10FEB] Chocolate Eating S", "background": null, "description": "Bessie 从公牛们那里收到了 $N$（$1 \\leq N \\leq 5\\times10^4$）块巧克力，但她不想吃得太快，所以她计划在接下来的 $D$（$1 \\leq D \\leq 5\\times10^4$）天内安排吃巧克力的日程，以使这些天中她每天的最低幸福值尽可能高。\n\nBessie 的幸福值是一个整数，初始为 $0$，每晚睡觉时会减半（如果有小数则向下取整）。然而，当她吃掉第 $i$ 块巧克力时，幸福值会增加整数 $H_i$（$1 \\leq H_i \\leq 1\\times10^6$）。如果她在某天吃巧克力，那么当天的幸福值以吃完巧克力后的值为准。Bessie 坚持要按照收到巧克力的顺序来吃。\n\n如果有多个最优解，输出任意一个即可。\n\n考虑一个要在 $5$ 天内吃完 $5$ 块巧克力的例子，它们分别带来的幸福值为 $(10, 40, 13, 22, 7)$。\n\n如果 Bessie 在第一天吃掉第一块巧克力（$10$ 幸福值），然后等待之后再吃其他巧克力，她第一天的幸福值就是 $10$。\n\n以下是一个最大化最低幸福值的完整安排：\n\n第 $1$ 天：起床时幸福值 $0$ → 吃掉 $10+40$ → 睡前幸福值 $50$。\n\n第 $2$ 天：起床时幸福值 $25$ → 不吃 → 睡前幸福值 $25$。\n\n第 $3$ 天：起床时幸福值 $12$ → 吃掉 $13$ → 睡前幸福值 $25$。\n\n第 $4$ 天：起床时幸福值 $12$ → 吃掉 $22$ → 睡前幸福值 $34$。\n\n第 $5$ 天：起床时幸福值 $17$ → 吃掉 $7$ → 睡前幸福值 $24$。\n\n这样得到的最低睡前幸福值是 $24$，这是 Bessie 能做到的最好结果。", "inputFormat": "* 第 $1$ 行：两个用空格分隔的整数：$N$ 和 $D$。\n* 第 $2\\sim N+1$ 行：第 $i+1$ 行包含一个整数：$H_i$。", "outputFormat": "* 第 $1$ 行：一个整数，表示 Bessie 在接下来 $D$ 天中能达到的最高最低幸福值。\n* 第 $2\\sim N+1$ 行：第 $i+1$ 行包含一个整数，表示 Bessie 吃掉第 $i$ 块巧克力的日期。", "hint": "翻译由 DeepSeek 辅助完成。\n\nAssisted translation by DeepSeek.", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10FEB] Chocolate Eating S", "background": null, "description": "Bessie has received N (1 <= N <= 50,000) chocolates from the bulls, but doesn't want to eat them too quickly, so she wants to plan out her chocolate eating schedule for the next D (1 <= D <= 50,000) days in order to maximize her minimum happiness level over the set of those days.\n\nBessie's happiness level is an integer that starts at 0 and halves (rounding down if necessary) over night as she sleeps. However, when she eats chocolate i, her happiness level increases by integer H\\_i (1 <= H\\_i <= 1,000,000). If she eats chocolates on a day, her happiness for that day is considered the happiness level after she eats the chocolates. Bessie insists that she eat the chocolates in the order that she received them.\n\nIf more than one optimal solution exists, print any one of them.\n\nConsider a sequence of 5 chocolates to be eaten over a period of 5 days; they respectively bring happiness (10, 40, 13, 22, 7).\n\nIf Bessie eats the first chocolate (10 happiness) on the first day and then waits to eat the others, her happiness level is 10 after the first day.\n\nHere is the complete schedule which turns out to maximize her minimum happiness:\n\n\n|Day|  Wakeup happiness|   Happiness from eating|   Bedtime happiness|\n|-:|-:|-:|-:|\n|1|            0|             10 + 40|                   50|\n|2|           25|                 ---|                   25|\n|3|           12|                  13|                   25|\n|4|           12|                  22|                   34|\n|5|           17|                   7|                   24|\n\n\nThe minimum bedtime happiness is 24, which turns out to be the best Bessie can do.", "inputFormat": "\\* Line 1: Two space separated integers: N and D\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: H\\_i", "outputFormat": "\\* Line 1: A single integer, the highest Bessie's minimum happiness can be over the next D days\n\n\\* Lines 2..N+1: Line i+1 contains an integer that is the day on which Bessie eats chocolate i", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO10FEB] Chocolate Eating S", "background": null, "description": "Bessie 从公牛们那里收到了 $N$（$1 \\leq N \\leq 5\\times10^4$）块巧克力，但她不想吃得太快，所以她计划在接下来的 $D$（$1 \\leq D \\leq 5\\times10^4$）天内安排吃巧克力的日程，以使这些天中她每天的最低幸福值尽可能高。\n\nBessie 的幸福值是一个整数，初始为 $0$，每晚睡觉时会减半（如果有小数则向下取整）。然而，当她吃掉第 $i$ 块巧克力时，幸福值会增加整数 $H_i$（$1 \\leq H_i \\leq 1\\times10^6$）。如果她在某天吃巧克力，那么当天的幸福值以吃完巧克力后的值为准。Bessie 坚持要按照收到巧克力的顺序来吃。\n\n如果有多个最优解，输出任意一个即可。\n\n考虑一个要在 $5$ 天内吃完 $5$ 块巧克力的例子，它们分别带来的幸福值为 $(10, 40, 13, 22, 7)$。\n\n如果 Bessie 在第一天吃掉第一块巧克力（$10$ 幸福值），然后等待之后再吃其他巧克力，她第一天的幸福值就是 $10$。\n\n以下是一个最大化最低幸福值的完整安排：\n\n第 $1$ 天：起床时幸福值 $0$ → 吃掉 $10+40$ → 睡前幸福值 $50$。\n\n第 $2$ 天：起床时幸福值 $25$ → 不吃 → 睡前幸福值 $25$。\n\n第 $3$ 天：起床时幸福值 $12$ → 吃掉 $13$ → 睡前幸福值 $25$。\n\n第 $4$ 天：起床时幸福值 $12$ → 吃掉 $22$ → 睡前幸福值 $34$。\n\n第 $5$ 天：起床时幸福值 $17$ → 吃掉 $7$ → 睡前幸福值 $24$。\n\n这样得到的最低睡前幸福值是 $24$，这是 Bessie 能做到的最好结果。", "inputFormat": "* 第 $1$ 行：两个用空格分隔的整数：$N$ 和 $D$。\n* 第 $2\\sim N+1$ 行：第 $i+1$ 行包含一个整数：$H_i$。", "outputFormat": "* 第 $1$ 行：一个整数，表示 Bessie 在接下来 $D$ 天中能达到的最高最低幸福值。\n* 第 $2\\sim N+1$ 行：第 $i+1$ 行包含一个整数，表示 Bessie 吃掉第 $i$ 块巧克力的日期。", "hint": "翻译由 DeepSeek 辅助完成。\n\nAssisted translation by DeepSeek.", "locale": "zh-CN"}}}
{"pid": "P2986", "type": "P", "difficulty": 4, "samples": [["5 \n1 \n1 \n0 \n0 \n2 \n1 3 1 \n2 3 2 \n3 4 3 \n4 5 3 \n", "15 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2010", "USACO", "树形 DP"], "title": "[USACO10MAR] Great Cow Gathering G", "background": "", "description": "Bessie 正在计划一年一度的奶牛大集会，来自全国各地的奶牛将来参加这一次集会。当然，她会选择最方便的地点来举办这次集会。\n\n每个奶牛居住在 $N$ 个农场中的一个，这些农场由 $N-1$ 条道路连接，并且从任意一个农场都能够到达另外一个农场。道路 $i$ 连接农场 $A_i$ 和 $B_i$，长度为 $L_i$。集会可以在 $N$ 个农场中的任意一个举行。另外，每个牛棚中居住着 $C_i$ 只奶牛。\n\n在选择集会的地点的时候，Bessie 希望最大化方便的程度（也就是最小化不方便程度）。比如选择第 $X$ 个农场作为集会地点，它的不方便程度是其它牛棚中每只奶牛去参加集会所走的路程之和（比如，农场 $i$ 到达农场 $X$ 的距离是 $20$，那么总路程就是 $C_i\\times 20$）。帮助 Bessie 找出最方便的地点来举行大集会。", "inputFormat": "第一行一个整数 $N$ 。\n\n第二到 $N+1$ 行：第 $i+1$ 行有一个整数 $C_i$。\n\n第 $N+2$ 行到 $2N$ 行：第 $i+N+1$ 行为 $3$ 个整数：$A_i,B_i$ 和 $L_i$。", "outputFormat": "一行一个整数，表示最小的不方便值。", "hint": "$1\\leq N\\leq 10^5$，$1\\leq A_i\\leq B_i\\leq N$，$0 \\leq C_i,L_i \\leq 10^3$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10MAR] Great Cow Gathering G", "background": "", "description": "Bessie is planning the annual grand cow gathering, with cows coming from all over the country. Of course, she will choose the most convenient place to hold it.\n\nEach cow lives on one of the $N$ farms, which are connected by $N-1$ roads so that any farm is reachable from any other. Road $i$ connects farms $A_i$ and $B_i$ with length $L_i$. The gathering may be held at any of the $N$ farms. In addition, farm $i$ contains $C_i$ cows.\n\nWhen choosing the location, Bessie wants to maximize convenience (that is, minimize inconvenience). If farm $X$ is chosen as the location, its inconvenience is the sum, over all other farms, of the distance each cow must travel to attend. For example, if the distance from farm $i$ to farm $X$ is $20$, then the total distance contributed by farm $i$ is $C_i \\times 20$. Help Bessie find the most convenient farm for the gathering.", "inputFormat": "- Line 1: an integer $N$.\n- Lines 2 to $N+1$: line $i+1$ contains a single integer $C_i$.\n- Lines $N+2$ to $2N$: line $i+N+1$ contains $3$ integers $A_i$, $B_i$, and $L_i$.", "outputFormat": "A single line containing one integer, the minimum inconvenience.", "hint": "Constraints\n\n$1 \\leq N \\leq 10^5$, $1 \\leq A_i \\leq B_i \\leq N$, $0 \\leq C_i, L_i \\leq 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10MAR] Great Cow Gathering G", "background": "", "description": "Bessie 正在计划一年一度的奶牛大集会，来自全国各地的奶牛将来参加这一次集会。当然，她会选择最方便的地点来举办这次集会。\n\n每个奶牛居住在 $N$ 个农场中的一个，这些农场由 $N-1$ 条道路连接，并且从任意一个农场都能够到达另外一个农场。道路 $i$ 连接农场 $A_i$ 和 $B_i$，长度为 $L_i$。集会可以在 $N$ 个农场中的任意一个举行。另外，每个牛棚中居住着 $C_i$ 只奶牛。\n\n在选择集会的地点的时候，Bessie 希望最大化方便的程度（也就是最小化不方便程度）。比如选择第 $X$ 个农场作为集会地点，它的不方便程度是其它牛棚中每只奶牛去参加集会所走的路程之和（比如，农场 $i$ 到达农场 $X$ 的距离是 $20$，那么总路程就是 $C_i\\times 20$）。帮助 Bessie 找出最方便的地点来举行大集会。", "inputFormat": "第一行一个整数 $N$ 。\n\n第二到 $N+1$ 行：第 $i+1$ 行有一个整数 $C_i$。\n\n第 $N+2$ 行到 $2N$ 行：第 $i+N+1$ 行为 $3$ 个整数：$A_i,B_i$ 和 $L_i$。", "outputFormat": "一行一个整数，表示最小的不方便值。", "hint": "$1\\leq N\\leq 10^5$，$1\\leq A_i\\leq B_i\\leq N$，$0 \\leq C_i,L_i \\leq 10^3$。", "locale": "zh-CN"}}}
{"pid": "P2987", "type": "P", "difficulty": 6, "samples": [["3 3 \nJ 6 5 4 5 4 7 \nB 5 4 2 3 5 5 \nJ 9 0 10 8 2 7 \n6 6 4 5 4 7 \n9 0 10 8 2 6 \n3 4 8 4 4 6 \n", "J \nJ \nU \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10MAR] StarCowraft G", "background": "", "description": "The beta version of StarCowraft II is ready! Farmer John and Bessie are testing it, trying different strategies in one-on-one battles against each other's armies. The goal in StarCowraft II is to defeat your opponent's army in a battle.\n\nEach player's army fights in a battle. An army comprises as many as three different types of 'units' with respective strengths denoted by constant positive real numbers unknown to the players: cattlebruisers with strength S1, cow templars with strength S2, and ultracows with strength S3. The only given bounding information is that no unit is more than 100 times as strong as any another unit.\n\nAn army's total strength is the sum of the individual strengths of each of its units. An army that has, among others units, 23\n\ncattlebruisers would gain 23\\*S1 strength just from the cattlebruisers.\n\nWhen two opposing armies fight in a battle, the army with a higher total strength value wins.  If the armies have exactly equal strength values, one of the players randomly wins.\n\nFarmer John and Bessie played N (0 <= N <= 300) 'test battles'. In the i-th test battle, FJ's army had J1\\_i cattlebruisers, J2\\_i cow templars, and J3\\_i ultracows (0 <= J1\\_i + J2\\_i + J3\\_i <= 1,000). Similarly, Bessie's army had B1\\_i cattlebruisers, B2\\_i cow templars, and B3\\_i ultracows (0 <= B1\\_i + B2\\_i + B3\\_i <= 1,000). After their armies fought against each other, FJ and Bessie recorded the winner as a single 'victory letter' V\\_i: 'J' if Farm John won the battle; 'B' if Bessie won.\n\nAlthough these victory results are the only information that they have, they hope to predict some of the results of additional battles if they are given the unit compositions of two opposing armies. For some battles, though, they know it might not be possible to determine the winner with certainty.\n\nGiven the results of the N test battles that Farmer John and Bessie already played, write a program that decides the winner (if possible) for M (1 <= M <= 2,000) new battles.\n\nThe results reported for the test battles are correct; there exists at least one set of strength values which are consistent with the results.\n\nFor purposes of demonstrating the army strength evaluation functions, consider these test battles fought in a game where we (but neither FJ nor Bessie) know that S1=9.0, S2=7.0, and S3=4.0:\n\n```cpp\n---- Farmer John ----    ------- Bessie ------    Battle \nJ1  J2  J3 J_Strength    B1  B2  B3 B_Strength   Outcome \n6   5   4    105         5   4   7    101          J \n5   4   2     81         3   5   5     82          B \n9   0  10    121         8   2   7    114          J \n```\nThese results connote the following deduced results for the reasons shown:\n\n---- Farmer John ----    ------- Bessie ------    Battle\n\nJ1  J2  J3 J\\_Strength    B1  B2  B3 B\\_Strength   Outcome\n\n6   6   4    112         5   4   7    101          J\n\nFJ's army is even stronger than in test battle 1 9   0  10    121         8   2   6    110          J\n\nBessie's army is even weaker than in test battle 3\n\n《星际争霸2》全面公测啦！Farmer John和Bessie正在测试中——在1v1的战役中使用一些不同的策略来对抗对方的部队。《星际争霸2》的游戏目标就是在战役中打败你对手的军队。\n\n每个选手的军队都在战役中拼杀。一支军队由若干3种不同类型的单位所组成，不同单位有着不同的由正实数表示的，且不被选手所知道的力量值：cattlebruisers 的力量是S1，cow templars 的力量是S2，ultracows的力量是S3。唯一提供的信息是，没有一个单位的力量值超过另一个单位力量值的100倍。\n\n一支军队的总力量值，是其中各自单独的单位的力量值的总和。比如一支军队除了其他单位有23个cattlebruisers，那么这支军队单独从cattlebruisers就能获得23\\*S1的力量值。\n\n当两支对立的军队在战役中厮杀，有着更高力量值的军队将获得胜利。如果两支军队的力量值恰好相同，那么将随机产生一个获胜方。\n\nFarmer John 和 Bessie 进行了 N (0 <= N <= 300) 局的“测试战役”。在第 i 局测试战役中，Farmer John 有 J1\\_i 个 cattlebruisers，J2\\_i 个 cow templars 以及 J3\\_i 个 ultracows(0 <= J1\\_i + J2\\_i + J3\\_i <= 1,000)。相似的，Bessie的军队有 B1\\_i 个 cattlebruisers，B2\\_i 个 cow templars 以及 B3\\_i 个 ultracows (0 <= B1\\_i + B2\\_i + B3\\_i <= 1,000)。当他们的军队战斗结束后，FJ 和 Bessie 将胜者以一个单独的“胜利字母” V\\_i 记录下来：\"J\"表示 Farmer John 赢得了战役；\"B\" 表示 Bessie 获胜了。\n\n虽然这些结果是他们唯一所拥有的信息，但是他们希望预测一些额外的战役的结果——如果告知他们两支对立军队的组成。尽管，可能对于一些比赛他们是无法确定到底哪一方一定能获胜的。\n\n给出已经结束的 N 场测试战役的结果，写一个程序来确定(如果可能的话)M (1 <=M <=2,000)场额外战役的获胜方。\n\n所有给出的测试战役的结果都是正确的。至少存在一种合法的力量值的取值符合这些结果。\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 describes a test battle with seven\n\nspace-separated items -- a victory letter and six\n\nspace-separated integer unit counts: V\\_i, J1\\_i, J2\\_i, J3\\_i, B1\\_i, B2\\_i, and B3\\_i\n\n\\* Lines N+2..N+M+1: Line i+N+1 describes a 'new battle' using six space-separated integers: J1\\_i, J2\\_i, J3\\_i, B1\\_i, B2\\_i, and B3\\_i\n", "outputFormat": "\\* Lines 1..M: Line i contains the outcome of the i-th new battle: 'J' if Farmer John definitely wins, 'B' if Bessie definitely wins, and 'U' (undecidable) if it is impossible to decide the winner with the given information.\n", "hint": "First two games correspond to the examples in the description. The result of the last game cannot be determined with only the information that Farmer John and Bessie currently have. Specifically, both S\\_1=9.0, S\\_2=7.0, S\\_3=4.0 and S\\_1=12.0, S\\_2=20.0, S\\_3=10.0 are consistent with the &quot;test battles,&quot; but they give different results when plugged in the third &quot;new battle.&quot;\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10MAR] StarCowraft G", "background": "", "description": "The beta version of StarCowraft II is ready! Farmer John and Bessie are testing it, trying different strategies in one-on-one battles against each other’s armies. The goal in StarCowraft II is to defeat your opponent’s army in a battle.\n\nEach player’s army fights in a battle. An army comprises up to three different types of units with respective strengths denoted by constant positive real numbers unknown to the players: cattlebruisers with strength S1, cow templars with strength S2, and ultracows with strength S3. The only given bounding information is that no unit is more than 100 times as strong as any other unit.\n\nAn army’s total strength is the sum of the individual strengths of each of its units. For example, an army that has, among other units, 23 cattlebruisers would gain 23*S1 strength just from the cattlebruisers.\n\nWhen two opposing armies fight in a battle, the army with the higher total strength value wins. If the armies have exactly equal strength values, one of the players wins at random.\n\nFarmer John and Bessie played N (0 <= N <= 300) test battles. In the i-th test battle, FJ’s army had J1\\_i cattlebruisers, J2\\_i cow templars, and J3\\_i ultracows (0 <= J1\\_i + J2\\_i + J3\\_i <= 1,000). Similarly, Bessie’s army had B1\\_i cattlebruisers, B2\\_i cow templars, and B3\\_i ultracows (0 <= B1\\_i + B2\\_i + B3\\_i <= 1,000). After their armies fought, FJ and Bessie recorded the winner as a single victory letter V\\_i: ‘J’ if Farmer John won the battle; ‘B’ if Bessie won.\n\nAlthough these victory results are the only information they have, they hope to predict some of the results of additional battles if they are given the unit compositions of two opposing armies. For some battles, however, it might not be possible to determine the winner with certainty.\n\nGiven the results of the N test battles that Farmer John and Bessie already played, write a program that decides the winner (if possible) for M (1 <= M <= 2,000) new battles.\n\nThe results reported for the test battles are correct; there exists at least one set of strength values that is consistent with the results.\n\nFor purposes of demonstrating the army strength evaluation functions, consider these test battles fought in a game where we (but neither FJ nor Bessie) know that S1 = 9.0, S2 = 7.0, and S3 = 4.0:\n\n```cpp\n---- Farmer John ----    ------- Bessie ------    Battle \nJ1  J2  J3 J_Strength    B1  B2  B3 B_Strength   Outcome \n6   5   4    105         5   4   7    101          J \n5   4   2     81         3   5   5     82          B \n9   0  10    121         8   2   7    114          J \n```\n\nThese results imply the following deduced results, for the reasons shown:\n\n```cpp\n---- Farmer John ----    ------- Bessie ------    Battle\nJ1  J2  J3 J_Strength    B1  B2  B3 B_Strength   Outcome\n6   6   4    112         5   4   7    101          J\n9   0  10    121         8   2   6    110          J\n```\n\nFJ’s army is even stronger than in test battle 1.\nBessie’s army is even weaker than in test battle 3.", "inputFormat": "* Line 1: Two space-separated integers: N and M.\n* Lines 2..N+1: Line i+1 describes a test battle with seven space-separated items — a victory letter and six space-separated integer unit counts: V\\_i, J1\\_i, J2\\_i, J3\\_i, B1\\_i, B2\\_i, and B3\\_i.\n* Lines N+2..N+M+1: Line i+N+1 describes a new battle using six space-separated integers: J1\\_i, J2\\_i, J3\\_i, B1\\_i, B2\\_i, and B3\\_i.", "outputFormat": "* Lines 1..M: Line i contains the outcome of the i-th new battle: ‘J’ if Farmer John definitely wins, ‘B’ if Bessie definitely wins, and ‘U’ (undecidable) if it is impossible to decide the winner with the given information.", "hint": "The first two games correspond to the examples in the description. The result of the last game cannot be determined with only the information that Farmer John and Bessie currently have. Specifically, both S1 = 9.0, S2 = 7.0, S3 = 4.0 and S1 = 12.0, S2 = 20.0, S3 = 10.0 are consistent with the “test battles,” but they give different results when plugged into the third “new battle.”\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10MAR] StarCowraft G", "background": "", "description": "The beta version of StarCowraft II is ready! Farmer John and Bessie are testing it, trying different strategies in one-on-one battles against each other's armies. The goal in StarCowraft II is to defeat your opponent's army in a battle.\n\nEach player's army fights in a battle. An army comprises as many as three different types of 'units' with respective strengths denoted by constant positive real numbers unknown to the players: cattlebruisers with strength S1, cow templars with strength S2, and ultracows with strength S3. The only given bounding information is that no unit is more than 100 times as strong as any another unit.\n\nAn army's total strength is the sum of the individual strengths of each of its units. An army that has, among others units, 23\n\ncattlebruisers would gain 23\\*S1 strength just from the cattlebruisers.\n\nWhen two opposing armies fight in a battle, the army with a higher total strength value wins.  If the armies have exactly equal strength values, one of the players randomly wins.\n\nFarmer John and Bessie played N (0 <= N <= 300) 'test battles'. In the i-th test battle, FJ's army had J1\\_i cattlebruisers, J2\\_i cow templars, and J3\\_i ultracows (0 <= J1\\_i + J2\\_i + J3\\_i <= 1,000). Similarly, Bessie's army had B1\\_i cattlebruisers, B2\\_i cow templars, and B3\\_i ultracows (0 <= B1\\_i + B2\\_i + B3\\_i <= 1,000). After their armies fought against each other, FJ and Bessie recorded the winner as a single 'victory letter' V\\_i: 'J' if Farm John won the battle; 'B' if Bessie won.\n\nAlthough these victory results are the only information that they have, they hope to predict some of the results of additional battles if they are given the unit compositions of two opposing armies. For some battles, though, they know it might not be possible to determine the winner with certainty.\n\nGiven the results of the N test battles that Farmer John and Bessie already played, write a program that decides the winner (if possible) for M (1 <= M <= 2,000) new battles.\n\nThe results reported for the test battles are correct; there exists at least one set of strength values which are consistent with the results.\n\nFor purposes of demonstrating the army strength evaluation functions, consider these test battles fought in a game where we (but neither FJ nor Bessie) know that S1=9.0, S2=7.0, and S3=4.0:\n\n```cpp\n---- Farmer John ----    ------- Bessie ------    Battle \nJ1  J2  J3 J_Strength    B1  B2  B3 B_Strength   Outcome \n6   5   4    105         5   4   7    101          J \n5   4   2     81         3   5   5     82          B \n9   0  10    121         8   2   7    114          J \n```\nThese results connote the following deduced results for the reasons shown:\n\n---- Farmer John ----    ------- Bessie ------    Battle\n\nJ1  J2  J3 J\\_Strength    B1  B2  B3 B\\_Strength   Outcome\n\n6   6   4    112         5   4   7    101          J\n\nFJ's army is even stronger than in test battle 1 9   0  10    121         8   2   6    110          J\n\nBessie's army is even weaker than in test battle 3\n\n《星际争霸2》全面公测啦！Farmer John和Bessie正在测试中——在1v1的战役中使用一些不同的策略来对抗对方的部队。《星际争霸2》的游戏目标就是在战役中打败你对手的军队。\n\n每个选手的军队都在战役中拼杀。一支军队由若干3种不同类型的单位所组成，不同单位有着不同的由正实数表示的，且不被选手所知道的力量值：cattlebruisers 的力量是S1，cow templars 的力量是S2，ultracows的力量是S3。唯一提供的信息是，没有一个单位的力量值超过另一个单位力量值的100倍。\n\n一支军队的总力量值，是其中各自单独的单位的力量值的总和。比如一支军队除了其他单位有23个cattlebruisers，那么这支军队单独从cattlebruisers就能获得23\\*S1的力量值。\n\n当两支对立的军队在战役中厮杀，有着更高力量值的军队将获得胜利。如果两支军队的力量值恰好相同，那么将随机产生一个获胜方。\n\nFarmer John 和 Bessie 进行了 N (0 <= N <= 300) 局的“测试战役”。在第 i 局测试战役中，Farmer John 有 J1\\_i 个 cattlebruisers，J2\\_i 个 cow templars 以及 J3\\_i 个 ultracows(0 <= J1\\_i + J2\\_i + J3\\_i <= 1,000)。相似的，Bessie的军队有 B1\\_i 个 cattlebruisers，B2\\_i 个 cow templars 以及 B3\\_i 个 ultracows (0 <= B1\\_i + B2\\_i + B3\\_i <= 1,000)。当他们的军队战斗结束后，FJ 和 Bessie 将胜者以一个单独的“胜利字母” V\\_i 记录下来：\"J\"表示 Farmer John 赢得了战役；\"B\" 表示 Bessie 获胜了。\n\n虽然这些结果是他们唯一所拥有的信息，但是他们希望预测一些额外的战役的结果——如果告知他们两支对立军队的组成。尽管，可能对于一些比赛他们是无法确定到底哪一方一定能获胜的。\n\n给出已经结束的 N 场测试战役的结果，写一个程序来确定(如果可能的话)M (1 <=M <=2,000)场额外战役的获胜方。\n\n所有给出的测试战役的结果都是正确的。至少存在一种合法的力量值的取值符合这些结果。\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 describes a test battle with seven\n\nspace-separated items -- a victory letter and six\n\nspace-separated integer unit counts: V\\_i, J1\\_i, J2\\_i, J3\\_i, B1\\_i, B2\\_i, and B3\\_i\n\n\\* Lines N+2..N+M+1: Line i+N+1 describes a 'new battle' using six space-separated integers: J1\\_i, J2\\_i, J3\\_i, B1\\_i, B2\\_i, and B3\\_i\n", "outputFormat": "\\* Lines 1..M: Line i contains the outcome of the i-th new battle: 'J' if Farmer John definitely wins, 'B' if Bessie definitely wins, and 'U' (undecidable) if it is impossible to decide the winner with the given information.\n", "hint": "First two games correspond to the examples in the description. The result of the last game cannot be determined with only the information that Farmer John and Bessie currently have. Specifically, both S\\_1=9.0, S\\_2=7.0, S\\_3=4.0 and S\\_1=12.0, S\\_2=20.0, S\\_3=10.0 are consistent with the &quot;test battles,&quot; but they give different results when plugged in the third &quot;new battle.&quot;\n", "locale": "zh-CN"}}}
{"pid": "P2988", "type": "P", "difficulty": 3, "samples": [["6 2 \n0 \n3 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10MAR] Test Taking S", "background": "", "description": "Farmer John has to take his annual farming license test. The test comprises N (1 <= N <= 1,000,000) true/false questions. After FJ's dismal performance on last year's test Bessie wishes to help him.\n\nBessie has inside information that the number of questions whose answer is true will be one of t\\_1, t\\_2, t\\_3,..., or t\\_K (0 <= t\\_i <= N; 0 <= K <= 10,000) -- even though Bessie has no information about any answer to any specific question. Bessie wants to know the best score that FJ is guaranteed achieve by exploiting this information carefully, even if he doesn't know the actual answers to any test questions.\n\nTo demonstrate Bessie's idea, consider a license test with N=6 questions where Bessie knows that the number of questions with the answer 'true' is either 0 or 3. FJ can always get at least 3 answers correct using logic like this: If FJ answers 'false' on every\n\nquestion and there are 0 questions with the answer 'true' then he will get all 6 correct. If there are 3 questions with the answer 'true' then he will get 3 answers correct. So as long as he marks every answer as 'false' he is guaranteed to get at least 3 correct without knowing any answer to the test questions.\n\nOn the other hand, consider what happens if FJ chooses an inferior strategy: he guesses that some 3 answers are 'true' and the other 3 are 'false'. If it turns out that NO answers are 'true' then FJ will get 3 answers correct, the ones he guessed were false. If 3 answers are 'true' then FJ could get as few as 0 answers correct. If he answered incorrectly on all 3 of that answers for which he guessed 'true', and the other 3 (for which he guessed 'false') are true, then he gets 0 correct answers. Even though FJ could get 3 correct in this case by guessing 'false' every time, he can not always guarantee even 1 correct by guessing some 3 answers as 'true', so this strategy can not guarantee getting any answer correct. FJ should use the previous paragraph's strategy.\n\nGiven Bessie's inside information, determine the number of answers FJ can always get correct using this information assuming he uses it optimally.\n\n\nFarmer John要参加一年一度的农民资格考试。考试很简单，只有N个 （1≤N≤1，000，000)true/false的判断题。然而FJ去年考试却“杯具”了，Bessie：希望今年能帮帮他。\n\n\nBessie得到可靠的内部消息，有可能有T\\_1，T\\_2，T\\_3，...，或T\\_K(0≤T\\_i≤N；0≤K≤10，000)\n\n\n道题的答案为ture：，但具体哪道题的答案是什么却不知道。Bessie希望知道在认真研究了这些内部消息后(虽然不能确定任何一道题的具体答案)，一定保证FJ考试时能获得的最高分数是多少?\n\n\n为了说明Bessie的想法，考虑N=6的一次考试，Bessie知道答案为true的题的数量是0或者3。FJ可以按这样的做题策略来答对至少3题：如果FJ全部答'false'，那么当有0道题的正确答案是'true'，则FJ答对6题；而当有3道题的正确答案是'true'，则FJ答对3题。因此，只要FJ部答'false'，那么至少一定能答对3题，尽管FJ并不知道每道题的确切答案。\n\n\n另一方面，考虑如果FJ选择了另一种非最优的做题策略：他猜测某3道题为'true'而另3道题为'false'。当所有题目的正确答案是'false'时，那么FJ能答对3道题。而当有3道题的正确答案是'true'时，那么FJ有可能一道题都答不对。这是因为FJ有可能把3道正确答案为'true'的题全猜成'false'!这说明这种做题策略不如前一种优秀。\n\n给出Bessie获得的内部消息，计算出FJ采用最优做题策略保证能得到的最高分数是多少?\n\n第1行：2个整数N，K\n\n第2…K+1行：第i+1行包含一个整数t_i\n\n第1行：一个整数，表示FJ一定能获得的最高分数", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..K+1: Line i+1 contains a single integer: t\\_i\n\n第1行：2个整数N，K\n\n\n第2…K+1行：第i+1行包含一个整数t\\_i\n\n\n第1行：一个整数，表示FJ一定能获得的最高分数\n", "outputFormat": "\\* Line 1: A single integer, the best score FJ is guaranteed to achieve\n", "hint": "翻译提供： @fan404\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10MAR] Test Taking S", "background": "", "description": "Farmer John has to take his annual farming license test. The test has $N$ ($1 \\le N \\le 1{,}000{,}000$) true/false questions. After last year's poor performance, Bessie wants to help him.\n\nBessie knows that the number of questions whose answer is 'true' is one of $t_1, t_2, \\dots, t_K$ ($0 \\le t_i \\le N$; $0 \\le K \\le 10{,}000$). She has no information about which particular questions are true. Using only this information, she wants to know the best score Farmer John can always guarantee, even without knowing any individual answers.\n\nExample: For $N = 6$ and possible counts $\\{0, 3\\}$, if FJ answers 'false' on every question, then if the true count is $0$ he gets $6$ correct, and if it is $3$ he gets $3$ correct. So he can guarantee at least $3$ correct.\n\nBy contrast, if FJ answers 'true' on exactly $3$ questions and 'false' on the other $3$, then if the true count is $0$ he gets $3$ correct, but if the true count is $3$ he could get as few as $0$ correct (if he guessed 'true' on the $3$ that are actually 'false'). So this strategy does not guarantee any correct answers.\n\nGiven Bessie's information, compute the maximum number of answers FJ can always get correct if he uses an optimal strategy.\n\nConstraints: $1 \\le N \\le 1{,}000{,}000$, $0 \\le K \\le 10{,}000$, $0 \\le t_i \\le N$.", "inputFormat": "- Line 1: Two space-separated integers $N$ and $K$.\n- Lines $2..K+1$: Line $i+1$ contains a single integer $t_i$.", "outputFormat": "- Line 1: A single integer, the best score FJ is guaranteed to achieve.", "hint": "Translation provided by @fan404.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10MAR] Test Taking S", "background": "", "description": "Farmer John has to take his annual farming license test. The test comprises N (1 <= N <= 1,000,000) true/false questions. After FJ's dismal performance on last year's test Bessie wishes to help him.\n\nBessie has inside information that the number of questions whose answer is true will be one of t\\_1, t\\_2, t\\_3,..., or t\\_K (0 <= t\\_i <= N; 0 <= K <= 10,000) -- even though Bessie has no information about any answer to any specific question. Bessie wants to know the best score that FJ is guaranteed achieve by exploiting this information carefully, even if he doesn't know the actual answers to any test questions.\n\nTo demonstrate Bessie's idea, consider a license test with N=6 questions where Bessie knows that the number of questions with the answer 'true' is either 0 or 3. FJ can always get at least 3 answers correct using logic like this: If FJ answers 'false' on every\n\nquestion and there are 0 questions with the answer 'true' then he will get all 6 correct. If there are 3 questions with the answer 'true' then he will get 3 answers correct. So as long as he marks every answer as 'false' he is guaranteed to get at least 3 correct without knowing any answer to the test questions.\n\nOn the other hand, consider what happens if FJ chooses an inferior strategy: he guesses that some 3 answers are 'true' and the other 3 are 'false'. If it turns out that NO answers are 'true' then FJ will get 3 answers correct, the ones he guessed were false. If 3 answers are 'true' then FJ could get as few as 0 answers correct. If he answered incorrectly on all 3 of that answers for which he guessed 'true', and the other 3 (for which he guessed 'false') are true, then he gets 0 correct answers. Even though FJ could get 3 correct in this case by guessing 'false' every time, he can not always guarantee even 1 correct by guessing some 3 answers as 'true', so this strategy can not guarantee getting any answer correct. FJ should use the previous paragraph's strategy.\n\nGiven Bessie's inside information, determine the number of answers FJ can always get correct using this information assuming he uses it optimally.\n\n\nFarmer John要参加一年一度的农民资格考试。考试很简单，只有N个 （1≤N≤1，000，000)true/false的判断题。然而FJ去年考试却“杯具”了，Bessie：希望今年能帮帮他。\n\n\nBessie得到可靠的内部消息，有可能有T\\_1，T\\_2，T\\_3，...，或T\\_K(0≤T\\_i≤N；0≤K≤10，000)\n\n\n道题的答案为ture：，但具体哪道题的答案是什么却不知道。Bessie希望知道在认真研究了这些内部消息后(虽然不能确定任何一道题的具体答案)，一定保证FJ考试时能获得的最高分数是多少?\n\n\n为了说明Bessie的想法，考虑N=6的一次考试，Bessie知道答案为true的题的数量是0或者3。FJ可以按这样的做题策略来答对至少3题：如果FJ全部答'false'，那么当有0道题的正确答案是'true'，则FJ答对6题；而当有3道题的正确答案是'true'，则FJ答对3题。因此，只要FJ部答'false'，那么至少一定能答对3题，尽管FJ并不知道每道题的确切答案。\n\n\n另一方面，考虑如果FJ选择了另一种非最优的做题策略：他猜测某3道题为'true'而另3道题为'false'。当所有题目的正确答案是'false'时，那么FJ能答对3道题。而当有3道题的正确答案是'true'时，那么FJ有可能一道题都答不对。这是因为FJ有可能把3道正确答案为'true'的题全猜成'false'!这说明这种做题策略不如前一种优秀。\n\n给出Bessie获得的内部消息，计算出FJ采用最优做题策略保证能得到的最高分数是多少?\n\n第1行：2个整数N，K\n\n第2…K+1行：第i+1行包含一个整数t_i\n\n第1行：一个整数，表示FJ一定能获得的最高分数", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..K+1: Line i+1 contains a single integer: t\\_i\n\n第1行：2个整数N，K\n\n\n第2…K+1行：第i+1行包含一个整数t\\_i\n\n\n第1行：一个整数，表示FJ一定能获得的最高分数\n", "outputFormat": "\\* Line 1: A single integer, the best score FJ is guaranteed to achieve\n", "hint": "翻译提供： @fan404\n", "locale": "zh-CN"}}}
{"pid": "P2989", "type": "P", "difficulty": 3, "samples": [["1500 100 4 \n250 25 \n150 9 \n120 5 \n200 8 \n", "2 \n3 \n4 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10MAR] Need For Speed S", "background": "", "description": "Bessie is preparing her race car for the upcoming Grand Prix, but she wants to buy some extra parts to improve the car's performance. Her race car currently has mass M (1 <= M <= 1,000) and is able to push itself forward with a force of F (1 <= F <= 1,000,000). The Race Car Performance Store has N (1 <= N <= 10,000) parts\n\nconveniently numbered 1..N. Bessie can buy as many or as few parts as she wishes though the store stocks no more than one instance of each part.\n\nPart P\\_i adds force F\\_i (1 <= F\\_i <= 1,000,000) and has mass\n\nM\\_i (1 <= M\\_i <= 1,000). Newton's Second Law decrees that F =\n\nMA, where F is force, M is mass, and A is acceleration. If Bessie wants to maximize the total acceleration of her race car (and\n\nminimize the mass otherwise), which extra parts should she choose?\n\nConsider a race car with initial F=1500 and M=100. Four parts are available for enhancement:\n\ni  F\\_i  M\\_i\n\n1  250   25\n\n2  150    9\n\n3  120    5\n\n4  200    8\n\nAdding just part 2, e.g., would result in an acceleration of\n\n(1500+150)/(100+9) = 1650/109 = 15.13761. \n\nBelow is a chart of showing the acceleration for all possible \n\ncombinations of adding/not-adding the four parts (in column one, 1=part added, 0=part not added): \n\nParts   Aggregate   Aggregate\n\n1234        F           M       F/M\n\n0000      1500         100    15.0000\n\n0001      1700         108    15.7407\n\n0010      1620         105    15.4286\n\n0011      1820         113    16.1062\n\n0100      1650         109    15.1376\n\n0101      1850         117    15.8120\n\n0110      1770         114    15.5263\n\n0111      1970         122    16.1475 <-- highest F/M \n\n1000      1750         125    14.0000\n\n1001      1950         133    14.6617\n\n1010      1870         130    14.3846\n\n1011      2070         138    15.0000\n\n1100      1900         134    14.1791\n\n1101      2100         142    14.7887\n\n1110      2020         139    14.5324\n\n1111      2220         147    15.1020\n\nThus, the best additional part combination is parts 2, 3, and 4.\n", "inputFormat": "\\* Line 1: Three space-separated integers: F, M, and N\n\n\\* Lines 2..N+1: Line i+1 contains two space separated integers: F\\_i and M\\_i\n", "outputFormat": "\\* Lines 1..P: The index values of P extra parts, one per line, that Bessie should add to her racecar. If she should not add any, output 'NONE' (without quotes). The output should be given in increasing order, so if the optimal set of parts is {2,4,6,7}, then the output should be in the order 2,4,6,7 and not, for example, 4,2,7,6. Solutions will be unique.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10MAR] Need For Speed S", "background": "", "description": "Bessie is preparing her race car for the upcoming Grand Prix, but she wants to buy some extra parts to improve the car's performance. Her race car currently has mass M (1 <= M <= 1,000) and is able to push itself forward with a force of F (1 <= F <= 1,000,000). The Race Car Performance Store has N (1 <= N <= 10,000) parts\n\nconveniently numbered 1..N. Bessie can buy as many or as few parts as she wishes though the store stocks no more than one instance of each part.\n\nPart P\\_i adds force F\\_i (1 <= F\\_i <= 1,000,000) and has mass\n\nM\\_i (1 <= M\\_i <= 1,000). Newton's Second Law decrees that F =\n\nMA, where F is force, M is mass, and A is acceleration. If Bessie wants to maximize the total acceleration of her race car (and\n\nminimize the mass otherwise), which extra parts should she choose?\n\nConsider a race car with initial F=1500 and M=100. Four parts are available for enhancement:\n\ni  F\\_i  M\\_i\n\n1  250   25\n\n2  150    9\n\n3  120    5\n\n4  200    8\n\nAdding just part 2, e.g., would result in an acceleration of\n\n(1500+150)/(100+9) = 1650/109 = 15.13761. \n\nBelow is a chart of showing the acceleration for all possible \n\ncombinations of adding/not-adding the four parts (in column one, 1=part added, 0=part not added): \n\nParts   Aggregate   Aggregate\n\n1234        F           M       F/M\n\n0000      1500         100    15.0000\n\n0001      1700         108    15.7407\n\n0010      1620         105    15.4286\n\n0011      1820         113    16.1062\n\n0100      1650         109    15.1376\n\n0101      1850         117    15.8120\n\n0110      1770         114    15.5263\n\n0111      1970         122    16.1475 <-- highest F/M \n\n1000      1750         125    14.0000\n\n1001      1950         133    14.6617\n\n1010      1870         130    14.3846\n\n1011      2070         138    15.0000\n\n1100      1900         134    14.1791\n\n1101      2100         142    14.7887\n\n1110      2020         139    14.5324\n\n1111      2220         147    15.1020\n\nThus, the best additional part combination is parts 2, 3, and 4.\n", "inputFormat": "\\* Line 1: Three space-separated integers: F, M, and N\n\n\\* Lines 2..N+1: Line i+1 contains two space separated integers: F\\_i and M\\_i\n", "outputFormat": "\\* Lines 1..P: The index values of P extra parts, one per line, that Bessie should add to her racecar. If she should not add any, output 'NONE' (without quotes). The output should be given in increasing order, so if the optimal set of parts is {2,4,6,7}, then the output should be in the order 2,4,6,7 and not, for example, 4,2,7,6. Solutions will be unique.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10MAR] Need For Speed S", "background": "", "description": "Bessie 正在为即将到来的赛车比赛作准备。\n\n她有一辆赛车，质量为 $M$，且可以提供 $F$ 的力。现在她想要给这辆赛车安装一些零件（总共有 $N$ 个零件），每个零件具有属性 $M_i$ 和 $F_i$，表示其质量以及可以提供的力。\n\n设 $X_i = 1$ 或 $0$，表示第 $i$ 个零件选或不选。在最大化\n\n$$\\dfrac{F+\\sum_{i=1}^{n}X_i \\cdot F_i}{M+\\sum_{i=1}^{n}X_i \\cdot M_i}$$\n\n\n的前提下最小化\n\n$$\\sum_{i=1}^{n}X_i \\cdot M_i + M.$$", "inputFormat": "第一行是三个用空格分开的正整数 $F,\\,M,\\,N$。\n\n接下来 $N$ 行，每行两个用空格分开的正整数，第 $i+1$ 行的两个数代表 $F_i$ 和 $M_i$。", "outputFormat": "输出包含 $P$ 行，表示 Bessie 需要安装的 $P$ 个零件的下标。若 Bessie 不需要给这辆车安装零件，输出 `NONE`。\n\n输出应按递增顺序给出，如果最佳零件集为 $\\{2,4,6,7\\}$，则输出应按 $2,4,6,7$ 的顺序，而不是 $4,2,7,6$ 的顺序。解决方案将是唯一的。", "hint": "#### 数据范围\n\n$1 \\le N \\le 10\\,000$；\n\n$1 \\le M,M_i\\le1\\,000$；\n\n$1 \\le F,F_i \\le 1\\,000\\,000$。\n\n\n感谢 @tyqtyq 提供的翻译。", "locale": "zh-CN"}}}
{"pid": "P2990", "type": "P", "difficulty": 5, "samples": [["6 3 \n0 \n1 \n2 \n-3 \n4 \n5 \n", "12 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10OPEN] Cow Hopscotch G", "background": null, "description": "奶牛们正在回味童年，玩一个类似跳格子的游戏，在这个游戏里，奶牛们在草地上画了一行 $N$ 个格子，编号为 $1\\dots N$。\n\n就像任何一个好游戏一样，这样的跳格子游戏也有奖励！第 $i$ 个格子标有一个数字 $v_i$ 表示这个格子的钱。奶牛们想看看最后谁能得到最多的钱。\n\n规则很简单：\n\n* 每个奶牛从 $0$ 号格子出发。($0$ 号格子在 $1$ 号之前，那里没钱)\n\n* 然后她执行一个可能为空的跳跃序列前往格子 $N$。她每次落地所在的格子距离前一个格子最多 $K$ 个格子（例如，如果 $K=2$，从格子 $1$ 出发，她最多可以跳到格子 $2$ 或 $3$）。\n\n* 在任何时候，她都可以选择回头往 $0$ 号格子跳，直到跳到 $0$ 号格子。\n\n另外，除了以上规则之外（包括 $K$ 限制），回头跳的时候还有两条规则：\n\n* 不可以跳到前进序列中的格子（格子 $0$ 除外）。\n\n* 除了 $0$ 号格子之外，她在回来的时候，停留的格子必须是恰巧过去的时候停留的某个格子的前一格（尽管她可能在返回时做一些更大的跳跃，从而跳过一些潜在的返回格子）。\n\n她赚取的金钱数量等于她跳过的所有格子的金钱价值之和。请找出奶牛能赚到的最大金额。\n\n举例说明，考虑一个有六个格子的路线，其中 $K = 3$。\n\n```\n格子编号:       0      1      2      3      4      5      6 \n            +---+  +---+  +---+  +---+  +---+  +---+  +---+ \n            |///|--|   |--|   |--|   |--|   |--|   |--|   | \n            +---+  +---+  +---+  +---+  +---+  +---+  +---+ \n值:            -      0      1      2     -3      4      5 \n```\n\nBessie 的一种最优途径为（括号中表示当前格子的金钱收益）： $0[0] \\to 1[0]\\to 3[2]\\to 6[5] \\to 5[4] \\to 2[1] \\to 0[0]$。\n\n如果 Bessie 跳了一个以 $0, 1, 2, 3, 4, \\dots$ 开始的序列，那么她将无法返回，因为她无法合法地跳回到一个未被触碰过的格子上。", "inputFormat": "第一行，两个用空格隔开的整数 $N, K$。\n\n接下来 $N$ 行，每行一个整数 $V_i$。", "outputFormat": "第一行，输出一个整数表示最大的钱数是多少。", "hint": "**【数据范围】**\n\n\n数据保证：$-2 \n\\times 10 ^9 \\le V_i \\le 2 \\times 10 ^ 9$，$3 \\le N \\le 2.5 \\times 10^5$，$2 \\le K \\le N$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10OPEN] Cow Hopscotch G", "background": null, "description": "The cows have reverted to their childhood and are playing a game similar to human hopscotch. Their hopscotch game features a line of $N (3 \\le N \\le 250,000)$ squares conveniently labeled $1\\dots N$ that are chalked onto the grass.\n\nLike any good game, this version of hopscotch has prizes!  Square i is labeled with some integer monetary value $V_i (-2 \\times 10^9 \\le V_i \\le 2 \\times 10^9)$. The cows play the game to see who can earn the most money.\n\nThe rules are fairly simple:\n\n* A cow starts at square $0$ (located just before square $1$; it has no monetary value).\n\n* She then executes a potentially empty sequence of jumps toward square N. Each square she lands on can be a maximum of $K (2 \\le K \\le N)$ squares from its predecessor square (i.e., from square $1$, she can jump outbound to squares $2$ or $3$ if $K=2$).\n\n* Whenever she wishes, the cow turns around and jumps back towards square $0$, stopping when she arrives there.\n\n\n\nIn addition to the restrictions above (including the $K$ limit), two additional restrictions apply:\n\n* She is not allowed to land on any square she touched on her outbound trip (except square $0$, of course).\n\n* Except for square $0$, the squares she lands on during the return trip must directly precede squares she landed on.\n\nduring the outbound trip (though she might make some larger leaps that skip potential return squares altogether).\n\nShe earns an amount of money equal to the sum of the monetary values of all the squares she jumped on. Find the largest amount of cash a cow can earn.\n\nBy way of example, consider this six-box cow-hopscotch course where $K$ has the value $3$:\n\n```\nSquare Num:    0      1      2      3      4      5      6 \n+---+  +---+  +---+  +---+  +---+  +---+  +---+ \n|///|--|   |--|   |--|   |--|   |--|   |--|   | \n+---+  +---+  +---+  +---+  +---+  +---+  +---+ \nValue:    -      0      1      2     -3      4      5 \n```\nOne (optimal) sequence Bessie could jump (shown with respective bracketed monetary values) is:  \n$1[0], 3[2], 6[5], 5[4], 2[1], 0[0]$ would yield a monetary total of $0+2+5+4+1+0=12$.\n\nIf Bessie jumped a sequence beginning with $0, 1, 2, 3, 4, \\dots$ then she would be unable to return since she could not legally jump back to an untouched square.", "inputFormat": "- Line $1$: Two space separated integers: N and K\n\n- Lines $2 \\dots N+1$: Line $i+1$ contains a single integer: $V_i$", "outputFormat": "* Line $1$: A single line with a single integer that is the maximum amount of money a cow can earn", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO10OPEN] Cow Hopscotch G", "background": null, "description": "奶牛们正在回味童年，玩一个类似跳格子的游戏，在这个游戏里，奶牛们在草地上画了一行 $N$ 个格子，编号为 $1\\dots N$。\n\n就像任何一个好游戏一样，这样的跳格子游戏也有奖励！第 $i$ 个格子标有一个数字 $v_i$ 表示这个格子的钱。奶牛们想看看最后谁能得到最多的钱。\n\n规则很简单：\n\n* 每个奶牛从 $0$ 号格子出发。($0$ 号格子在 $1$ 号之前，那里没钱)\n\n* 然后她执行一个可能为空的跳跃序列前往格子 $N$。她每次落地所在的格子距离前一个格子最多 $K$ 个格子（例如，如果 $K=2$，从格子 $1$ 出发，她最多可以跳到格子 $2$ 或 $3$）。\n\n* 在任何时候，她都可以选择回头往 $0$ 号格子跳，直到跳到 $0$ 号格子。\n\n另外，除了以上规则之外（包括 $K$ 限制），回头跳的时候还有两条规则：\n\n* 不可以跳到前进序列中的格子（格子 $0$ 除外）。\n\n* 除了 $0$ 号格子之外，她在回来的时候，停留的格子必须是恰巧过去的时候停留的某个格子的前一格（尽管她可能在返回时做一些更大的跳跃，从而跳过一些潜在的返回格子）。\n\n她赚取的金钱数量等于她跳过的所有格子的金钱价值之和。请找出奶牛能赚到的最大金额。\n\n举例说明，考虑一个有六个格子的路线，其中 $K = 3$。\n\n```\n格子编号:       0      1      2      3      4      5      6 \n            +---+  +---+  +---+  +---+  +---+  +---+  +---+ \n            |///|--|   |--|   |--|   |--|   |--|   |--|   | \n            +---+  +---+  +---+  +---+  +---+  +---+  +---+ \n值:            -      0      1      2     -3      4      5 \n```\n\nBessie 的一种最优途径为（括号中表示当前格子的金钱收益）： $0[0] \\to 1[0]\\to 3[2]\\to 6[5] \\to 5[4] \\to 2[1] \\to 0[0]$。\n\n如果 Bessie 跳了一个以 $0, 1, 2, 3, 4, \\dots$ 开始的序列，那么她将无法返回，因为她无法合法地跳回到一个未被触碰过的格子上。", "inputFormat": "第一行，两个用空格隔开的整数 $N, K$。\n\n接下来 $N$ 行，每行一个整数 $V_i$。", "outputFormat": "第一行，输出一个整数表示最大的钱数是多少。", "hint": "**【数据范围】**\n\n\n数据保证：$-2 \n\\times 10 ^9 \\le V_i \\le 2 \\times 10 ^ 9$，$3 \\le N \\le 2.5 \\times 10^5$，$2 \\le K \\le N$。", "locale": "zh-CN"}}}
{"pid": "P2991", "type": "P", "difficulty": 5, "samples": [["3 4 1 \n2 3 5 \n1 2 5 \n1 3 9 \n2 3 3 \n", "9 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10OPEN] Water Slides G", "background": "", "description": "Inspired by the new water park at Machu Picchu in Peru, Farmer John has decided to build one for the cows. Its biggest\n\nattraction is to be a giant water slide of a peculiar design. The superslide comprises E (1 <= E <=\n\n150,000) mini slides connecting V (2 <= V <= 50,000) small pools conveniently labeled 1..V. Every mini slide must be traversed in its proper direction and may not be traversed backwards. The cows start at pool number 1 and traverse successive mini slides until they end up in the pool number V, the final pool. Every pool (except 1, the first one) includes at least one mini slide entering it and (except V, the last one) at least one (different) mini slide exiting it.\n\nFurthermore, a cow can reach the end of the ride (pool V) from any pool by going down a sequence of mini slides. Finally, since this is a slide, it is not possible to leave a pool and then encounter that pool again after traversing some set of mini slides.\n\nEach mini slide i runs from pool P\\_i to pool Q\\_i (1 <= P\\_i <= V; 1 <= Q\\_i <= V; P\\_i != Q\\_i) and has an associated fun value F\\_i (0 <= F\\_i <= 2,000,000,000). Bessie's total fun for any given trip down the superslide is the sum of the fun values of all the mini slides traversed.\n\nBessie naturally wants to have as much fun as possible, given the long time that she spends in the slide's queue waiting for the ride. Generally, she carefully chooses which mini slide to follow out of each pool. She is a cow, however, and no more than K (1 <= K <= 10) times as she splashes down the slide, she loses control and follows a random mini slide out of a pool (this can even happen on pool 1).\n\nIf Bessie chooses so as to maximize her fun in the worst case, how much fun is she guaranteed to have for a given super-slide?\n\nBy way of example, consider a small park that has 3 pools (pool id's shown in brackets) and four mini slides; K has the value 1 (fun values shown outside of brackets):\n\n[1]\n/   \\\n5 -> /     \\ <- 9 \n\n/       \\\n\n[2]---3---[3]\n\n\\_\\_5\\_\\_/\n\nShe alway starts at pool 1 and ends and pool 3. If she had her way, she'd ride direct from pool 1 to pool 2 and then on the higher-fun mini slide (with fun value 5) to slide 3 for a total fun value of 5+5=10. But, if she loses control at pool 1, she might slide directly from pool 1 to pool 3 for total fun 9. If she loses control at pool 2, she could reduce her total fun to just 5+3 = 8.\n\nBessie wants to find the most fun she can have so she strives to choose 1->3 for a total fun of 9. If she loses control at pool 1 and ends up on mini slide 1->2, she knows she will not lose control at pool 2 and will end up with fun 10. Thus, she knows her minimum fun will always be at least 9.\n", "inputFormat": "\\* Line 1: Three space separated integers: V, E, and K\n\n\\* Lines 2..E + 1: Line i+1 contains three space separated integers: P\\_i, Q\\_i, and F\\_i\n", "outputFormat": "\\* Line 1: A single line with a single integer that is the minimum fun that Bessie can guarantee she can have.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10OPEN] Water Slides G", "background": "", "description": "Inspired by the new water park at Machu Picchu in Peru, Farmer John has decided to build one for the cows. Its biggest\n\nattraction is to be a giant water slide of a peculiar design. The superslide comprises E (1 <= E <=\n\n150,000) mini slides connecting V (2 <= V <= 50,000) small pools conveniently labeled 1..V. Every mini slide must be traversed in its proper direction and may not be traversed backwards. The cows start at pool number 1 and traverse successive mini slides until they end up in the pool number V, the final pool. Every pool (except 1, the first one) includes at least one mini slide entering it and (except V, the last one) at least one (different) mini slide exiting it.\n\nFurthermore, a cow can reach the end of the ride (pool V) from any pool by going down a sequence of mini slides. Finally, since this is a slide, it is not possible to leave a pool and then encounter that pool again after traversing some set of mini slides.\n\nEach mini slide i runs from pool P\\_i to pool Q\\_i (1 <= P\\_i <= V; 1 <= Q\\_i <= V; P\\_i != Q\\_i) and has an associated fun value F\\_i (0 <= F\\_i <= 2,000,000,000). Bessie's total fun for any given trip down the superslide is the sum of the fun values of all the mini slides traversed.\n\nBessie naturally wants to have as much fun as possible, given the long time that she spends in the slide's queue waiting for the ride. Generally, she carefully chooses which mini slide to follow out of each pool. She is a cow, however, and no more than K (1 <= K <= 10) times as she splashes down the slide, she loses control and follows a random mini slide out of a pool (this can even happen on pool 1).\n\nIf Bessie chooses so as to maximize her fun in the worst case, how much fun is she guaranteed to have for a given super-slide?\n\nBy way of example, consider a small park that has 3 pools (pool id's shown in brackets) and four mini slides; K has the value 1 (fun values shown outside of brackets):\n\n[1]\n/   \\\n5 -> /     \\ <- 9 \n\n/       \\\n\n[2]---3---[3]\n\n\\_\\_5\\_\\_/\n\nShe alway starts at pool 1 and ends and pool 3. If she had her way, she'd ride direct from pool 1 to pool 2 and then on the higher-fun mini slide (with fun value 5) to slide 3 for a total fun value of 5+5=10. But, if she loses control at pool 1, she might slide directly from pool 1 to pool 3 for total fun 9. If she loses control at pool 2, she could reduce her total fun to just 5+3 = 8.\n\nBessie wants to find the most fun she can have so she strives to choose 1->3 for a total fun of 9. If she loses control at pool 1 and ends up on mini slide 1->2, she knows she will not lose control at pool 2 and will end up with fun 10. Thus, she knows her minimum fun will always be at least 9.\n", "inputFormat": "\\* Line 1: Three space separated integers: V, E, and K\n\n\\* Lines 2..E + 1: Line i+1 contains three space separated integers: P\\_i, Q\\_i, and F\\_i\n", "outputFormat": "\\* Line 1: A single line with a single integer that is the minimum fun that Bessie can guarantee she can have.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10OPEN] Water Slides G", "background": null, "description": "受到秘鲁马丘比丘新建水上乐园的启发，约翰农夫决定为奶牛们建造一个水上乐园。其最大的吸引力将是一个设计独特的巨型滑梯。超级滑梯由 $E(1 \\le E\\le150,000)$ 个迷你滑梯连接 $V(2\\le V\\le50,000)$ 个小水池，这些水池被方便地标记为 $1$ 到 $V$。每个迷你滑梯必须按照正确的方向滑行，不能逆向滑行。奶牛们从编号为 $1$ 的水池出发，依次滑过迷你滑梯，直到到达编号为 $V$ 的终点水池。每个水池（除了第一个水池 $1$）至少有一个迷你滑梯进入它，（除了最后一个水池 $V$）至少有一个（不同的）迷你滑梯从它出去。\n\n此外，奶牛可以通过一系列迷你滑梯从任何水池到达终点水池 $V$。最后，由于这是一个滑梯，不可能离开一个水池后，再经过一系列迷你滑梯后重新回到该水池。\n\n每个迷你滑梯 $i$ 从水池 $P_i$ 到水池 $Q_i$ （$1\\le P_i\\le V; 1\\le Q_i\\le V; P_i\\ne Q_i$），并且有一个与之关联的乐趣值 $F_i(0\\le F_i\\le 2,000,000,000)$。对于任何一次超级滑梯的滑行，贝茜的总乐趣是所有经过的迷你滑梯的乐趣值之和。\n\n贝茜自然希望在滑梯排队等待的漫长时间里尽可能多地享受乐趣。通常，她会仔细选择从每个水池出来的迷你滑梯。然而，她是一头奶牛，在滑下滑梯的过程中最多有 $K(1\\le K\\le 10)$ 次会失去控制，随机选择一个迷你滑梯离开水池（这甚至可能发生在水池 $1$）。\n\n如果贝茜选择以最坏情况下最大化她的乐趣，她在给定的超级滑梯上能保证获得多少乐趣？\n\n例如，考虑一个有 $3$ 个水池（水池编号如括号中所示）和四个迷你滑梯的小型乐园；$K$ 的值为 $1$（乐趣值如括号外所示）：\n\n[1]\n/   \\ 5 -> /     \\ <- 9 \n\n/       \\ \n[2]---3---[3]\n\n\\_\\_5\\_\\_/\n\n她总是从水池 $1$ 开始，到达水池 $3$。如果她可以选择，她会直接从水池 $1$ 到水池 $2$，然后通过乐趣值较高的迷你滑梯（乐趣值为 $5$）到达滑梯 $3$，总乐趣值为 $5+5=10$。但是，如果她在水池 $1$ 失去控制，她可能会直接从水池 $1$ 滑到水池 $3$，总乐趣为 $9$。如果她在水池 $2$ 失去控制，她的总乐趣可能会减少到 $5+3 = 8$。\n\n贝茜希望找到她能获得的最大乐趣，因此她努力选择 $1\\to3$，总乐趣为 $9$。如果她在水池 $1$ 失去控制而滑到迷你滑梯 $1\\to2$，她知道她在水池 $2$ 不会失去控制，并且最终乐趣为 $10$。因此，她知道她的最小乐趣总是至少为 $9$。", "inputFormat": "\\* 第 $1$ 行：三个用空格分隔的整数：$V$，$E$ 和 $K$。\n\n\\* 第 $2$ 行到第 $E+1$ 行：第 $i+1$ 行包含三个用空格分隔的整数：$P_i$，$Q_i$ 和 $F_i$。", "outputFormat": "\\* 第 $1$ 行：一个整数，表示贝茜可以保证获得的最小乐趣。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2992", "type": "P", "difficulty": 5, "samples": [["5 \n-5 0 \n0 2 \n11 2 \n-11 -6 \n11 -5 \n", "5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2010", "USACO", "排序", "容斥原理", "双指针 two-pointer"], "title": "[USACO10OPEN] Triangle Counting G", "background": "", "description": "在一只大灰狼偷偷潜入 Farmer Don 的牛群被群牛发现后，贝西现在不得不履行着她站岗的职责。从她的守卫塔向下瞭望简直就是一件烦透了的事情。她决定做一些开发智力的小练习，防止她睡着了。\n\n想象牧场是一个 $X\\times Y$ 平面的网格。她将 $N$ 只奶牛标记为 $1\\cdots N$，每只奶牛的坐标为 $X_i,Y_i$ ($1 \\le i \\le N$)。然后她脑海里想象着所有可能由奶牛构成的三角形。如果一个三角形完全包含了原点 $(0,0)$，那么她称这个三角形为“黄金三角形”。原点不会落在任何一对奶牛的连线上。另外，不会有奶牛在原点。\n\n给出奶牛的坐标，计算出有多少个“黄金三角形”。", "inputFormat": "第一行，包含一个正整数 $N$。\n\n第 $2\\sim N+1$ 行，每行两个正整数 $X_i,Y_i$ 表示第 $i$ 头牛的坐标。", "outputFormat": "一行一个正整数表示答案。", "hint": "$1 \\le N \\le 100,000$\n\n$-100,000 \\le X_i,Y_i \\le 100,000$", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10OPEN] Triangle Counting G", "background": "Bessie is standing guard duty after the big bad wolf was spotted stalking cows over at Farmer Don's spread. \n\nLooking down from her guard tower in \nutter boredom, she's decided to \nperform intellectual exercises in order to keep awake.", "description": "After imagining the field as an $X\\times Y$ grid, she recorded the coordinates of the N ($1 \\le N \\le 100,000$, conveniently numbered $1\\cdots N$) cows as $X_i,Y_i$ ($-100,000 \\le X_i \\le 100,000; \n-100,000 \\le Y_i \\le 100,000; 1 \\le i \\le N$). She then mentally formed all possible triangles that could be made from subsets of the entire set of cow coordinates. She counts a triangle as 'golden' if it wholly contains the origin (0,0). The origin does not fall on the line between any pair of cows. Additionally, no cow is standing exactly on the origin. \n\nGiven the list of cow locations, calculate the number of 'golden' triangles that contain the origin so Bessie will know if she's doing a good job. \n\nBy way of example, consider 5 cows at these locations:\n\n$(-5,0)$   $(0,2)$   $(11,2)$   $(-11,-6)$   $(11,-5)$\n\nBelow is a schematic layout of the field from Betsy's point of view:\n\n```cpp\n............|............ \n............*..........*. \n............|............ \n-------*----+------------ \n............|............ \n............|............ \n............|............ \n............|............ \n............|..........*. \n.*..........|............ \n............|............ \n```\n\nTen triangles can be formed from the five points above.\n\nBy inspection, 5 of them contain the origin and hence are 'golden'.", "inputFormat": "\\* Line 1: A single integer: $N$\n\n\\* Lines $2\\cdots N+1$: Each line contains two integers, the coordinates of a single cow: $X_i$ and $Y_i$", "outputFormat": "\\* Line 1: A single line with a single integer that is the count of the number of times a triangle formed by the cow locations contains the origin", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO10OPEN] Triangle Counting G", "background": "", "description": "在一只大灰狼偷偷潜入 Farmer Don 的牛群被群牛发现后，贝西现在不得不履行着她站岗的职责。从她的守卫塔向下瞭望简直就是一件烦透了的事情。她决定做一些开发智力的小练习，防止她睡着了。\n\n想象牧场是一个 $X\\times Y$ 平面的网格。她将 $N$ 只奶牛标记为 $1\\cdots N$，每只奶牛的坐标为 $X_i,Y_i$ ($1 \\le i \\le N$)。然后她脑海里想象着所有可能由奶牛构成的三角形。如果一个三角形完全包含了原点 $(0,0)$，那么她称这个三角形为“黄金三角形”。原点不会落在任何一对奶牛的连线上。另外，不会有奶牛在原点。\n\n给出奶牛的坐标，计算出有多少个“黄金三角形”。", "inputFormat": "第一行，包含一个正整数 $N$。\n\n第 $2\\sim N+1$ 行，每行两个正整数 $X_i,Y_i$ 表示第 $i$ 头牛的坐标。", "outputFormat": "一行一个正整数表示答案。", "hint": "$1 \\le N \\le 100,000$\n\n$-100,000 \\le X_i,Y_i \\le 100,000$", "locale": "zh-CN"}}}
{"pid": "P2993", "type": "P", "difficulty": 6, "samples": [["6 6 4\n1 2 1\n2 3 1\n3 4 1\n2 5 1\n3 6 1\n5 6 1", "3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "各省省选", "福建"], "title": "[FJOI2014] 最短路径树问题", "background": "", "description": "给一个包含 $n$ 个点，$m$ 条边的无向连通图。从顶点 $1$ 出发，往其余所有点分别走一次并返回。\n\n往某一个点走时，选择总长度最短的路径走。若有多条长度最短的路径，则选择经过的顶点序列字典序最小的那条路径（如路径 A 为 $1,32,11$，路径 B 为 $1,3,2,11$，路径 B 字典序较小。注意是序列的字典序的最小，而非路径中节点编号相连的字符串字典序最小）。到达该点后按原路返回，然后往其他点走，直到所有点都走过。\n\n可以知道，经过的边会构成一棵最短路径树。请问，在这棵最短路径树上，最长的包含 $K$ 个点的简单路径长度为多长？包含 $K$ 个点的长度为该最长长度的不同路径有多少条？\n\n这里的简单路径是指：对于一个点最多只经过一次的路径。不同路径是指路径两端端点至少有一个不同，点 A 到点 B 的路径和点 B 到点 A 视为同一条路径。", "inputFormat": "第一行输入三个正整数 $n,m,K$，表示有 $n$ 个点 $m$ 条边，要求的路径需要经过 $K$ 个点。\n\n接下来输入 $m$ 行，每行三个正整数 $A_i,B_i,C_i(1\\leq Ai,Bi\\leq n,1\\leq C_i \\leq 10000)$，表示 $A_i$ 和 $B_i$ 间有一条长度为 $C_i$ 的边。\n\n数据保证输入的是连通的无向图。", "outputFormat": "输出一行两个整数，以一个空格隔开，第一个整数表示包含 $K$ 个点的路径最长为多长，第二个整数表示包含 $K$ 个点的长度为该最长长度的不同路径有多少条。", "hint": "对于所有数据 $n\\leq 30000,m\\leq 60000，2\\leq K\\leq n$。\n\n数据保证最短路径树上至少存在一条长度为 $K$ 的路径。", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2014] Shortest Path Tree Problem", "background": "", "description": "You are given a connected undirected graph with $n$ vertices and $m$ edges. Starting from vertex 1, for each of the other vertices, walk to it once and then return.\n\nWhen walking to a vertex, choose a path with the smallest total length. If there are multiple shortest paths, choose the one whose sequence of visited vertices is lexicographically smallest (for example, path A is 1,32,11 and path B is 1,3,2,11; path B is lexicographically smaller. Note that we compare the lexicographical order of the vertex sequence, not the lex order of the concatenated string of node labels). After reaching that vertex, return along the same path, then proceed to the next vertex, until all vertices have been visited.\n\nIt can be shown that the edges traversed form a shortest path tree. On this shortest path tree, what is the length of the longest simple path that contains $K$ vertices? How many different paths that contain $K$ vertices achieve this maximum length?\n\nA simple path means a path that visits any vertex at most once. Different paths mean the two endpoints are not the same pair; the path from A to B and the path from B to A are considered the same path.", "inputFormat": "The first line contains three positive integers $n, m, K$, meaning there are $n$ vertices and $m$ edges, and the required path must contain $K$ vertices.\n\nEach of the next $m$ lines contains three positive integers $A_i, B_i, C_i$ ($1 \\leq A_i, B_i \\leq n, 1 \\leq C_i \\leq 10000$), indicating there is an edge of length $C_i$ between $A_i$ and $B_i$.\n\nIt is guaranteed that the input graph is connected and undirected.", "outputFormat": "Output one line with two integers separated by a space. The first integer is the maximum length of a simple path that contains $K$ vertices, and the second integer is the number of different paths that contain $K$ vertices and achieve this maximum length.", "hint": "Constraints: For all testdata, $n \\leq 30000$, $m \\leq 60000$, $2 \\leq K \\leq n$.\n\nIt is guaranteed that the shortest path tree contains at least one path that visits $K$ vertices.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2014] 最短路径树问题", "background": "", "description": "给一个包含 $n$ 个点，$m$ 条边的无向连通图。从顶点 $1$ 出发，往其余所有点分别走一次并返回。\n\n往某一个点走时，选择总长度最短的路径走。若有多条长度最短的路径，则选择经过的顶点序列字典序最小的那条路径（如路径 A 为 $1,32,11$，路径 B 为 $1,3,2,11$，路径 B 字典序较小。注意是序列的字典序的最小，而非路径中节点编号相连的字符串字典序最小）。到达该点后按原路返回，然后往其他点走，直到所有点都走过。\n\n可以知道，经过的边会构成一棵最短路径树。请问，在这棵最短路径树上，最长的包含 $K$ 个点的简单路径长度为多长？包含 $K$ 个点的长度为该最长长度的不同路径有多少条？\n\n这里的简单路径是指：对于一个点最多只经过一次的路径。不同路径是指路径两端端点至少有一个不同，点 A 到点 B 的路径和点 B 到点 A 视为同一条路径。", "inputFormat": "第一行输入三个正整数 $n,m,K$，表示有 $n$ 个点 $m$ 条边，要求的路径需要经过 $K$ 个点。\n\n接下来输入 $m$ 行，每行三个正整数 $A_i,B_i,C_i(1\\leq Ai,Bi\\leq n,1\\leq C_i \\leq 10000)$，表示 $A_i$ 和 $B_i$ 间有一条长度为 $C_i$ 的边。\n\n数据保证输入的是连通的无向图。", "outputFormat": "输出一行两个整数，以一个空格隔开，第一个整数表示包含 $K$ 个点的路径最长为多长，第二个整数表示包含 $K$ 个点的长度为该最长长度的不同路径有多少条。", "hint": "对于所有数据 $n\\leq 30000,m\\leq 60000，2\\leq K\\leq n$。\n\n数据保证最短路径树上至少存在一条长度为 $K$ 的路径。", "locale": "zh-CN"}}}
{"pid": "P2994", "type": "P", "difficulty": 4, "samples": [["2 1 \n0 1 \n1 0 \n1 10 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2010", "USACO", "排序"], "title": "[USACO10OCT] Dinner Time S", "background": "", "description": "Farmer John's N (1 <= N <= 1,000) cows conveniently numbered 1..N are participating in the IOI in Bulgaria. The cows like the Bulgarian sun and are enjoying their holiday. All seems well.\n\nThis changes around dinner time. The restaurant is rather small, having only M (1 <= M <= N) cow seats conveniently numbered 1..M. Each cow starts at a location CX\\_i, CY\\_i (-1,000,000 <= CX\\_i <= 1,000,000; -1,000,000 <= CY\\_i <= 1,000,000); the seats can be found at SX\\_j, SY\\_j (-1,000,000 <= SX\\_j <= 1,000,000; -1,000,000 <= SY\\_j <= 1,000,000).\n\nThe cows have a very efficient (though primitive) method to distribute themselves into the seats. As soon as a cow is certain she will get to a seat first, she rushes there as fast as she can (all cows runs equally fast).\n\nFarmer John's cows, like all prize cows, have no problem jumping over seats, tables, or other cows, so they can run in a straight line. When multiple cows can reach a seat at the very same time, the oldest cow (the one appearing earlier in the input data) gets the seat.  Likewise, when a cow can be the first to reach multiple seats she will also choose the one appearing earliest in the input.\n\nSome cows won't be able to eat dinner, and those hungry cows are collectively planning to steal Farmer John's very own food. Farmer John would like a list of cows he should be wary of. (In the case when there are no hungry cows, output 0). Can you help him?\n\nNOTE: Standard distance calculations will likely require an\n\nintermediate result that will fit into a 64-bit integer but not into a 32-bit integer.", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 contains two space separated integers: CX\\_i and CY\\_i\n\n\\* Lines N+2..N+M+1: Line j+N+1 contains two space separated integers: SX\\_j and SY\\_j", "outputFormat": "\\* Lines 1..N-M: Line i contains the number of the ith cow that Farmer John should be wary of. The cow numbers should be listed in increasing order.", "hint": "2 cows: Cow 1 starts at (0, 1) and cow 2 at (1, 0). There \n\nis only 1 seat at (1, 10). \n\nCow 1 is closer to the seat than cow 2, so cow 1 will get the only seat.\n", "locale": "en", "translations": {"en": {"title": "[USACO10OCT] Dinner Time S", "background": "", "description": "Farmer John's N (1 <= N <= 1,000) cows conveniently numbered 1..N are participating in the IOI in Bulgaria. The cows like the Bulgarian sun and are enjoying their holiday. All seems well.\n\nThis changes around dinner time. The restaurant is rather small, having only M (1 <= M <= N) cow seats conveniently numbered 1..M. Each cow starts at a location CX\\_i, CY\\_i (-1,000,000 <= CX\\_i <= 1,000,000; -1,000,000 <= CY\\_i <= 1,000,000); the seats can be found at SX\\_j, SY\\_j (-1,000,000 <= SX\\_j <= 1,000,000; -1,000,000 <= SY\\_j <= 1,000,000).\n\nThe cows have a very efficient (though primitive) method to distribute themselves into the seats. As soon as a cow is certain she will get to a seat first, she rushes there as fast as she can (all cows runs equally fast).\n\nFarmer John's cows, like all prize cows, have no problem jumping over seats, tables, or other cows, so they can run in a straight line. When multiple cows can reach a seat at the very same time, the oldest cow (the one appearing earlier in the input data) gets the seat.  Likewise, when a cow can be the first to reach multiple seats she will also choose the one appearing earliest in the input.\n\nSome cows won't be able to eat dinner, and those hungry cows are collectively planning to steal Farmer John's very own food. Farmer John would like a list of cows he should be wary of. (In the case when there are no hungry cows, output 0). Can you help him?\n\nNOTE: Standard distance calculations will likely require an\n\nintermediate result that will fit into a 64-bit integer but not into a 32-bit integer.", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 contains two space separated integers: CX\\_i and CY\\_i\n\n\\* Lines N+2..N+M+1: Line j+N+1 contains two space separated integers: SX\\_j and SY\\_j", "outputFormat": "\\* Lines 1..N-M: Line i contains the number of the ith cow that Farmer John should be wary of. The cow numbers should be listed in increasing order.", "hint": "2 cows: Cow 1 starts at (0, 1) and cow 2 at (1, 0). There \n\nis only 1 seat at (1, 10). \n\nCow 1 is closer to the seat than cow 2, so cow 1 will get the only seat.\n", "locale": "en"}, "zh-CN": {"title": "[USACO10OCT] Dinner Time S", "background": "", "description": "农场主约翰的 $N$（$1 \\le N \\le 10 ^ 3$）头奶牛被编号为 $1 \\sim N$，它们正在保加利亚参加 IOI。奶牛们喜欢保加利亚的太阳并享受着它们的假日，一切看起来都没问题。\n\n变化发生在晚餐时间前后。这家餐馆很小，只有 $M$（$1 \\le M \\le N$）个座位，编号为 $1 \\sim M$。每头牛从一个位置 $CX_i$，$CY_i$ 进入餐馆（$-10 ^ 6 \\le CX_i \\le 10 ^ 6,-10 ^ 6 \\le CY_i \\le 10 ^ 6$）；座位可以在 $SX_j$，$SY_j$ 找到（$-10 ^ 6 \\le SX_j \\le10 ^ 6,-10 ^ 6\\le SY_j\\le 10 ^ 6$）。\n\n\n\n奶牛有一种非常有效的（尽管很原始）方法把自己分配到座位上。一旦某只奶牛确定她会先到某个座位上，她就会尽快赶到那里（所有的奶牛都跑得一样快）。\n\n\n\n农场主约翰的奶牛和所有获奖的奶牛一样，跳过座位、桌子或其他奶牛都没有问题，因此它们可以直线奔跑。当多头牛可以同时到达一个座位时，最老的牛（在输入数据中出现得更早的牛）获得座位。当一头牛可以第一个到达多个座位时，她也会选择在输入中最早出现的座位。\n\n\n\n一些奶牛将不能吃晚饭，这些吃不到饭的饥饿的奶牛正集体计划偷农场主约翰自己的食物。农场主约翰想要一份他应该提防的奶牛名单。（如果没有饥饿的奶牛，则输出 $0$）。你能帮他吗？\n\n\n\n注：在计算中可能会有超过 $32$ 位整数范围但在 $64$ 位整数范围内的数。\n\n------------", "inputFormat": "第一行：两个空格分隔的整数：$N$ 和 $M$。\n\n第 $2 \\sim N + 1$ 行：第 $i+1$ 行包含两个空格分隔的整数：$CX_i$ 和 $CY_i$。\n\n\n\n第 $N+2 \\sim N+M+1$ 行：行 $j+N+1$ 包含两个空格分隔的整数：$SX_j$ 和 $SY_j$。\n\n\n------------", "outputFormat": "第 $1$ 行到第 $(N-M)$ 行：第 $i$ 行包含农场主约翰应该提防的第 $i$ 头牛的编号。奶牛的编号应递增排序。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2995", "type": "P", "difficulty": 5, "samples": [["5 \n3 \n5 \n4 \n2 \n1 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO", "O2优化"], "title": "[USACO10NOV] Cow Photographs G", "background": "", "description": "Farmer John wants to take a picture of his entire herd of N (1 <= N <= 100,000) cows conveniently numbered 1..N so he can show off to his friends.\n\nOn picture day, the cows run to form a single line in some arbitrary order with position i containing cow c\\_i (1 <= c\\_i <= N). Farmer John has his own ideas about how the cows should line up.\n\nFJ thinks cow i may stand only to the left of cow i+1 (for all i, 1 <= i <= N-1) and that cow N may only stand to the left of Cow 1. Of course, no cow will stand to the left of the first (leftmost) cow in the line.\n\nThe cows are hungry for the promised post-photo dinner, so Farmer John wants to take the picture as quickly as possible. Cows are not great at following directions, so he will only choose a pair of adjacent cows and have them switch places once per minute. How quickly is Farmer John able to get them into some acceptable order?\n\nConsider a set of 5 cows whose initial lineup looks like this:\n\nLeft           Right\n\n3  5  4  2  1\n\nHe can first swap the second pair of cows:\n\n3  4  5  2 1\n\nand then swap the rightmost pair: \n\n3  4  5  1  2\n\nto yield an acceptable lineup that required but two minutes of cow swapping.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains the number of the i-th cow in line: c\\_i\n", "outputFormat": "\\* Line 1: The minimum amount of time, in minutes, that it takes Farmer John to get the cows into some appropriate order.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10NOV] Cow Photographs G", "background": "", "description": "Farmer John wants to take a picture of his entire herd of N (1 <= N <= 100,000) cows conveniently numbered 1..N so he can show off to his friends.\n\nOn picture day, the cows run to form a single line in some arbitrary order with position i containing cow c\\_i (1 <= c\\_i <= N). Farmer John has his own ideas about how the cows should line up.\n\nFJ thinks cow i may stand only to the left of cow i+1 (for all i, 1 <= i <= N-1) and that cow N may only stand to the left of Cow 1. Of course, no cow will stand to the left of the first (leftmost) cow in the line.\n\nThe cows are hungry for the promised post-photo dinner, so Farmer John wants to take the picture as quickly as possible. Cows are not great at following directions, so he will only choose a pair of adjacent cows and have them switch places once per minute. How quickly is Farmer John able to get them into some acceptable order?\n\nConsider a set of 5 cows whose initial lineup looks like this:\n\nLeft           Right\n\n3  5  4  2  1\n\nHe can first swap the second pair of cows:\n\n3  4  5  2 1\n\nand then swap the rightmost pair: \n\n3  4  5  1  2\n\nto yield an acceptable lineup that required but two minutes of cow swapping.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains the number of the i-th cow in line: c\\_i\n", "outputFormat": "\\* Line 1: The minimum amount of time, in minutes, that it takes Farmer John to get the cows into some appropriate order.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10NOV] Cow Photographs G", "background": "", "description": "农夫约翰想要给他全部的 N (1 <= N <= 100,000) 头奶牛拍张照片，这些奶牛被方便地编号为 1 到 N，以便他能向朋友们炫耀。\n\n在拍照日，奶牛们会跑到一起形成一条单行队列，位置 i 上是奶牛 c\\_i (1 <= c\\_i <= N)。农夫约翰有他自己关于奶牛应该如何排列的想法。\n\n约翰认为奶牛 i 只能站在奶牛 i+1 的左边（对于所有 i，1 <= i <= N-1），并且奶牛 N 只能站在奶牛 1 的左边。当然，没有奶牛会站在队列中第一头（最左边的）奶牛的左边。\n\n奶牛们渴望拍照后承诺的晚餐，因此农夫约翰想尽快拍完照片。奶牛们不太擅长遵循指示，所以他每分钟只能选择一对相邻的奶牛并让它们交换位置。农夫约翰能多快将它们排成某种合适的顺序？\n\n考虑一组 5 头奶牛，其初始排列如下：\n\n左           右\n\n3  5  4  2  1\n\n他可以先交换第二对奶牛：\n\n3  4  5  2 1\n\n然后交换最右边的一对：\n\n3  4  5  1  2\n\n这样就得到一个合适的排列，只需要两分钟的奶牛交换。\n", "inputFormat": "\\* 第 1 行：一个整数：N\n\n\\* 第 2 行到第 N+1 行：第 i+1 行包含第 i 头奶牛在队列中的编号：c\\_i\n", "outputFormat": "\\* 第 1 行：农夫约翰将奶牛排成某种合适顺序所需的最少时间，以分钟为单位。\n", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2996", "type": "P", "difficulty": 3, "samples": [["7 \n6 2 \n3 4 \n2 3 \n1 2 \n7 6 \n5 6 \n", "4 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO", "树形 DP"], "title": "[USACO10NOV] Visiting Cows G", "background": null, "description": "经过了几周的辛苦工作，Bessie 终于迎来了一个假期。\n\n作为奶牛群中最会社交的牛，她希望去拜访 $N(1 \\le N \\le 50000)$ 个朋友。这些朋友被标号为 $1,2,\\dots,N$。这些奶牛有一个不同寻常的交通系统，里面有 $N-1$ 条路，每条路连接了一对编号为 $C_1$ 和 $C_2$ 的奶牛 $(1 \\le C_1 \\le N, 1 \\le C_2 \\le N, C_1 \\ne C_2)$。这样，在每一对奶牛之间都有一条唯一的通路。\n\nFJ 希望 Bessie 尽快的回到农场。于是，他就指示 Bessie：如果对于一条路直接相连的两个奶牛，Bessie 只能拜访其中的一个。当然，Bessie 希望她的假期越长越好，所以她想知道她可以拜访的奶牛的最大数目。", "inputFormat": "第一行，$1$ 个整数 $N$。\n\n接下来 $N - 1$ 行，每行 $2$ 个整数 $C_1,C_2$，表示有一条通路连接了编号为 $C_1$ 和 $C_2$ 的奶牛。", "outputFormat": "第一行，$1$ 个整数，代表 Bessie 最多能拜访有多少头奶牛。", "hint": "Bessie 希望去拜访 $7$ 头奶牛。第六头和第二头通过一条道路直接连接，像第三头和第四头、第二头和第三头等一样。下方的插图描述了连接奶牛们的所有道路。\n\n```plain\n1--2--3--4\n   |\n5--6--7\n```\n\nBessie 能拜访 $4$ 头奶牛。最好的组合包含 $2$ 头在上面的奶牛与 $2$ 头在底下的奶牛（如上图）。她不能在同时拜访第五和第七头奶牛的情况下拜访第六头奶牛。因此，她拜访了第五和第七头。她还可以拜访在上面的奶牛：第 $(1,3), (1,4)$ 或者第 $(2,4)$ 头奶牛。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10NOV] Visiting Cows G", "background": null, "description": "After many weeks of hard work, Bessie is finally getting a vacation. She wants to visit $N$ friends, labeled $1,2 \\dots, N$. The cows have set up an unusual road network with exactly $N - 1$ roads connecting pairs of cows $C_1$ and $C_2$ ($1 \\le C_1 \\le N$, $1 \\le C_2 \\le N$, $C_1 \\ne C_2$), so that there is a unique path between any two cows.\n\nFJ wants Bessie to come back to the farm soon; therefore, if two cows are directly connected by a road, she may not visit both. Bessie would like her vacation to be as long as possible, so she wants to determine the maximum number of cows she can visit.\n\nConstraints: $1 \\le N \\le 50000$.", "inputFormat": "* Line 1: A single integer $N$.\n* Lines 2..$N$: Each line describes one road with two space-separated integers: $C_1$ and $C_2$.", "outputFormat": "* Line 1: A single integer representing the maximum number of cows that Bessie can visit.", "hint": "Bessie knows $7$ cows. The roads form the following tree:\n```plain\n1--2--3--4\n   |\n5--6--7\n```\nBessie can visit four cows. The best combinations include two cows on the top row and two on the bottom. She cannot visit cow 6 since that would prevent visiting cows 5 and 7; thus she visits 5 and 7. She can also visit two cows on the top row: $\\{1, 3\\}$, $\\{1, 4\\}$, or $\\{2, 4\\}$.", "locale": "en"}, "zh-CN": {"title": "[USACO10NOV] Visiting Cows G", "background": null, "description": "经过了几周的辛苦工作，Bessie 终于迎来了一个假期。\n\n作为奶牛群中最会社交的牛，她希望去拜访 $N(1 \\le N \\le 50000)$ 个朋友。这些朋友被标号为 $1,2,\\dots,N$。这些奶牛有一个不同寻常的交通系统，里面有 $N-1$ 条路，每条路连接了一对编号为 $C_1$ 和 $C_2$ 的奶牛 $(1 \\le C_1 \\le N, 1 \\le C_2 \\le N, C_1 \\ne C_2)$。这样，在每一对奶牛之间都有一条唯一的通路。\n\nFJ 希望 Bessie 尽快的回到农场。于是，他就指示 Bessie：如果对于一条路直接相连的两个奶牛，Bessie 只能拜访其中的一个。当然，Bessie 希望她的假期越长越好，所以她想知道她可以拜访的奶牛的最大数目。", "inputFormat": "第一行，$1$ 个整数 $N$。\n\n接下来 $N - 1$ 行，每行 $2$ 个整数 $C_1,C_2$，表示有一条通路连接了编号为 $C_1$ 和 $C_2$ 的奶牛。", "outputFormat": "第一行，$1$ 个整数，代表 Bessie 最多能拜访有多少头奶牛。", "hint": "Bessie 希望去拜访 $7$ 头奶牛。第六头和第二头通过一条道路直接连接，像第三头和第四头、第二头和第三头等一样。下方的插图描述了连接奶牛们的所有道路。\n\n```plain\n1--2--3--4\n   |\n5--6--7\n```\n\nBessie 能拜访 $4$ 头奶牛。最好的组合包含 $2$ 头在上面的奶牛与 $2$ 头在底下的奶牛（如上图）。她不能在同时拜访第五和第七头奶牛的情况下拜访第六头奶牛。因此，她拜访了第五和第七头。她还可以拜访在上面的奶牛：第 $(1,3), (1,4)$ 或者第 $(2,4)$ 头奶牛。", "locale": "zh-CN"}}}
{"pid": "P2997", "type": "P", "difficulty": 3, "samples": [["2 1 2 3 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10NOV] Banner S", "background": "题目大意(by:曹彦臣)：\n\n\n平面上有(0,0)到(n,m)的(n+1)\\*(m+1)个点。问有多少点对所连的线段不过其他点，且长度在[l,h]范围内。\n", "description": "Bessie is returning from a long trip abroad, and Farmer John wants to erect a nice 'Welcome Home' banner in her pasture for her arrival. The banner will hang between two poles on a wire whose length is in the range L1..L2 (1 <= L1 <= L2; L1 <= L2 <= 1,500).\n\nThe pasture's size is W x H (1 <= W <= 1,000; 1 <= H <= 1,000), and Farmer John has installed a post at every point with integer\n\ncoordinates. Of these (W + 1) \\* (H + 1) points, Farmer John must pick just two that will hold either end of the wire from which he will hang the banner.\n\nFJ wants no interference with his banner as it hangs and requires that no post be directly under the tight wire he stretches between the two chosen posts.\n\nFarmer John needs your help to figure out how many possible ways he can hang the banner. He knows the number is large and that a 32-bit integer might not be sufficient to compute the answer.\n\nConsider the example pasture below, with W = 2 and H = 1: \n\n\\* \\* \\*\n\\* \\* \\*\nThe banner size is in the range 2..3. This pasture contains (2+1) \\* (1+1) = 6 points and has (6 take 2) = (6\\*5)/(2\\*1) = 15 different potential pairs of points between which the banner-holding wire might stretch:\n\n```cpp\n(0,0)-(0,1)   (0,0)-(2,1)   (0,1)-(2,1)   (1,1)-(2,0) \n(0,0)-(1,0)   (0,1)-(1,0)   (1,0)-(1,1)   (1,1)-(2,1) \n(0,0)-(1,1)   (0,1)-(1,1)   (1,0)-(2,0)   (2,0)-(2,1) \n(0,0)-(2,0)   (0,1)-(2,0)   (1,0)-(2,1) \n```\nOf these pairs, only four have a length in the range 2..3:\nLen                       Len\n\n(0,0)-(2,0) 2.00          (0,1)-(2,0) 2.24 \n\n(0,0)-(2,1) 2.24          (0,1)-(2,1) 2.00 \n\nOf these four, the pairs (0,0)-(2,0) and (0,1)-(2,1) both have a post directly on the line between the endpoints, and thus are \n\nunsuitable.\n\nSo, just two pairs of points out of 15 are acceptable candidates for hanging the banner wire.\n", "inputFormat": "\\* Line 1: Four space-separated integers: W, H, L1, and L2\n", "outputFormat": "\\* Line 1: A single integer denoting the number of possible banners\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10NOV] Banner S", "background": "题目大意(by:曹彦臣)：\n\n\n平面上有(0,0)到(n,m)的(n+1)\\*(m+1)个点。问有多少点对所连的线段不过其他点，且长度在[l,h]范围内。\n", "description": "Bessie is returning from a long trip abroad, and Farmer John wants to erect a nice 'Welcome Home' banner in her pasture for her arrival. The banner will hang between two poles on a wire whose length is in the range L1..L2 (1 <= L1 <= L2; L1 <= L2 <= 1,500).\n\nThe pasture's size is W x H (1 <= W <= 1,000; 1 <= H <= 1,000), and Farmer John has installed a post at every point with integer\n\ncoordinates. Of these (W + 1) \\* (H + 1) points, Farmer John must pick just two that will hold either end of the wire from which he will hang the banner.\n\nFJ wants no interference with his banner as it hangs and requires that no post be directly under the tight wire he stretches between the two chosen posts.\n\nFarmer John needs your help to figure out how many possible ways he can hang the banner. He knows the number is large and that a 32-bit integer might not be sufficient to compute the answer.\n\nConsider the example pasture below, with W = 2 and H = 1: \n\n\\* \\* \\*\n\\* \\* \\*\nThe banner size is in the range 2..3. This pasture contains (2+1) \\* (1+1) = 6 points and has (6 take 2) = (6\\*5)/(2\\*1) = 15 different potential pairs of points between which the banner-holding wire might stretch:\n\n```cpp\n(0,0)-(0,1)   (0,0)-(2,1)   (0,1)-(2,1)   (1,1)-(2,0) \n(0,0)-(1,0)   (0,1)-(1,0)   (1,0)-(1,1)   (1,1)-(2,1) \n(0,0)-(1,1)   (0,1)-(1,1)   (1,0)-(2,0)   (2,0)-(2,1) \n(0,0)-(2,0)   (0,1)-(2,0)   (1,0)-(2,1) \n```\nOf these pairs, only four have a length in the range 2..3:\nLen                       Len\n\n(0,0)-(2,0) 2.00          (0,1)-(2,0) 2.24 \n\n(0,0)-(2,1) 2.24          (0,1)-(2,1) 2.00 \n\nOf these four, the pairs (0,0)-(2,0) and (0,1)-(2,1) both have a post directly on the line between the endpoints, and thus are \n\nunsuitable.\n\nSo, just two pairs of points out of 15 are acceptable candidates for hanging the banner wire.\n", "inputFormat": "\\* Line 1: Four space-separated integers: W, H, L1, and L2\n", "outputFormat": "\\* Line 1: A single integer denoting the number of possible banners\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10NOV] Banner S", "background": "", "description": "Bessie 刚从国外长途旅行回来，农夫约翰想在她的牧场里竖起一个漂亮的「欢迎回家」横幅。横幅将挂在两根柱子之间的电线上，电线的长度范围是 $L_1..L_2$，其中 $1 \\le L_1 \\le L_2$，且 $L_1 \\le L_2 \\le 1,500$。\n\n牧场的大小为 $W \\times H$，其中 $1 \\le W \\le 1,000$，$1 \\le H \\le 1,000$，农夫约翰在每个整数坐标点上都安装了一根柱子。在这些 $(W + 1) \\times (H + 1)$ 个点中，农夫约翰必须选择两个点来固定电线的两端，以便悬挂横幅。\n\n约翰希望横幅悬挂时不受干扰，并要求在他拉紧的电线下方没有柱子。\n\n农夫约翰需要你的帮助来计算他有多少种可能的方式来悬挂横幅。他知道这个数量很大，32 位整数可能不足以计算出答案。\n\n考虑下面的牧场示例，其中 $W = 2$ 和 $H = 1$：\n\n\\* \\* \\*\n\\* \\* \\*\n横幅的长度范围是 $2..3$。这个牧场包含 $(2+1) \\times (1+1) = 6$ 个点，并且有 $\\binom{6}{2} = \\frac{6\\times5}{2\\times1} = 15$ 对不同的点对，可以在其间拉伸横幅固定电线：\n\n```cpp\n(0,0)-(0,1)   (0,0)-(2,1)   (0,1)-(2,1)   (1,1)-(2,0) \n(0,0)-(1,0)   (0,1)-(1,0)   (1,0)-(1,1)   (1,1)-(2,1) \n(0,0)-(1,1)   (0,1)-(1,1)   (1,0)-(2,0)   (2,0)-(2,1) \n(0,0)-(2,0)   (0,1)-(2,0)   (1,0)-(2,1) \n```\n在这些点对中，只有四对的长度在 $2..3$ 的范围内：\n长度                       长度\n\n(0,0)-(2,0) 2.00          (0,1)-(2,0) 2.24 \n\n(0,0)-(2,1) 2.24          (0,1)-(2,1) 2.00 \n\n在这四对中，点对 (0,0)-(2,0) 和 (0,1)-(2,1) 的连线上都有柱子，因此不合适。\n\n所以，在 15 对点中，只有两对是合适的悬挂横幅电线的候选者。\n", "inputFormat": "\\* 第 1 行：四个用空格分隔的整数：$W$，$H$，$L_1$ 和 $L_2$。\n", "outputFormat": "\\* 第 1 行：一个整数，表示可能的横幅数量。\n", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2998", "type": "P", "difficulty": 4, "samples": [["10 2 2 1 \n3 \n5 \n4 \n2 \n", "12 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10NOV] Candy S", "background": null, "description": "FJ 知道贝茜喜欢吃糖果。FJ 有 $N (1 \\le N \\le 40000)$ 颗糖果，他想在若干天内将这些糖果送给贝茜。每一天，FJ 会让贝茜从他提供的一个列表中选择她当天想吃多少糖果，该列表有 $Nopt(1 \\le Nopt \\le 50)$ 种不同的选项 $C_i (1 \\le C_i \\le N)$ 。她必须恰好拿走 $C_i$ 颗糖果。\n\n农夫约翰给出了 $F(1 \\le F \\le 50)$ 个他喜欢的数字 $FN_i (1 \\le FN_i \\le N)$ 。每当一天结束时，如果剩余的糖果数量恰好等于这些数字之一，贝茜可以选择添加 $M（1 \\le M \\le 100)$ 颗糖果。如果添加糖果后又出现了另一个 FJ 喜欢的数字，贝茜可能会再次获得添加 $M$ 颗糖果的机会。在最好的情况下，贝茜可以获得无限多的糖果！\n\n当贝茜无法在列表中选择糖果数量（因为糖果不够）时，她就无法再获得更多糖果。\n\n不幸的是，贝茜不知道该如何规划才能吃掉尽可能多的糖果，所以她需要你的帮助。\n\n举例来说，考虑以下场景：\n\n* FJ 最初有 $10$ 颗糖果\n* 贝茜每天可以选择吃掉 $3$ 或 $5$ 颗糖果\n* 当剩余的糖果数量是 $2$ 或 $4$ 时，FJ 会添加 $1$ 颗糖果\n\n贝茜可以使用以下选择来最大化她能吃掉的糖果数量：\n\n```cpp\n                  初始糖果数     吃掉糖果数     剩余糖果数     奖励糖果数     最终糖果数\n        第1天        10            3            7             0            7\n        第2天         7            3            4             1            5\n        第3天         5            3            2             1            3\n        第4天         3            3            0             0            0\n```", "inputFormat": "* 第 $1$ 行：四个由空格分隔的整数：$N,Nopt,F,M$\n* 第 $2$ 行到第 $Nopt+1$ 行：第 $i+1$ 行包含一个整数：$C_i$\n* 第 $Nopt+2$ 行到第 $Nopt+F+1$ 行：第 $i+Nopt+1$ 行包含一个整数：$FN_i$", "outputFormat": "* 第 $1$ 行：一个整数，表示贝茜能吃掉的最大糖果数量，如果贝茜能吃掉无限多的糖果，则输出 `-1`。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[USACO10NOV] Candy S", "background": "", "description": "Farmer John knows that Bessie loves to eat candy. FJ has N (1 <= N <= 40,000) candies that he wants to give Bessie over some number of days. Each day, Farmer John gives Bessie a choice of how many candies she chooses to eat that day by choosing the number from a master list FJ supplies that has Nopt (1 <= Nopt <= 50) different options, C\\_i (1 <= C\\_i <= N). She must take exactly C\\_i candies, no more, no less.\n\nFarmer John has also disclosed F (1 <= F <= 50) of his favorite numbers, FN\\_i (1 <= FN\\_i <= N). Whenever the number of candies remaining at the end of the day precisely matches one of these favorite numbers, Bessie has the option to have him add exactly M (1 <= M <= 100) more candies to the candy supply. Bessie might get another option to add M candies several times if adding candies creates another favorite number. In the best circumstances, Bessie can obtain an infinite amount of candy!\n\nWhen Bessie cannot choose some amount of candy to take (because there is not enough), and the number of candies remaining is not any of FJ's favorite numbers, she cannot have any more candy.\n\nUnfortunately, Bessie cannot think ahead as far as she'd like to, so she needs your help in order to eat as many candies as possible.\n\nBy way of example, consider this scenario:\n\n\\* Farmer John's basket initially contains 10 candies\n\n\\* Bessie can chose to eat either 3 or 5 candies each day\n\n\\* Farmer John will add 1 candy any time the remaining number of candies is 2 or 4\n\nBessie could use this set of choices to maximize the amount of candy she can eat:\n\n```cpp\n\n                  Initial      # Candies   Remaining     Bonus     Final\n        Day      # Candies       Eaten      Candies     Candies   Candies\n\n         1          10             3          7            0        7\n         2           7             3          4            1        5\n         3           5             3          2            1        3\n         4           3             3          0            0        0\n\n```\n\nTotal candies eaten = 3 + 3 + 3 + 3 = 12. \n\n", "inputFormat": "\\* Line 1: Four space-separated integers: N, Nopt, F, and M\n\n\\* Lines 2..Nopt+1: Line i+1 contains a single integer: C\\_i\n\n\\* Lines Nopt+2..Nopt+F+1: Line i+Nopt+1 contains a single integer: FN\\_i\n\n\n\n", "outputFormat": "\\* Line 1: A single integer, denoting the maximum amount of candies Bessie can eat, or -1 if  Bessie can eat an infinite amount of candy.\n\n\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10NOV] Candy S", "background": null, "description": "FJ 知道贝茜喜欢吃糖果。FJ 有 $N (1 \\le N \\le 40000)$ 颗糖果，他想在若干天内将这些糖果送给贝茜。每一天，FJ 会让贝茜从他提供的一个列表中选择她当天想吃多少糖果，该列表有 $Nopt(1 \\le Nopt \\le 50)$ 种不同的选项 $C_i (1 \\le C_i \\le N)$ 。她必须恰好拿走 $C_i$ 颗糖果。\n\n农夫约翰给出了 $F(1 \\le F \\le 50)$ 个他喜欢的数字 $FN_i (1 \\le FN_i \\le N)$ 。每当一天结束时，如果剩余的糖果数量恰好等于这些数字之一，贝茜可以选择添加 $M（1 \\le M \\le 100)$ 颗糖果。如果添加糖果后又出现了另一个 FJ 喜欢的数字，贝茜可能会再次获得添加 $M$ 颗糖果的机会。在最好的情况下，贝茜可以获得无限多的糖果！\n\n当贝茜无法在列表中选择糖果数量（因为糖果不够）时，她就无法再获得更多糖果。\n\n不幸的是，贝茜不知道该如何规划才能吃掉尽可能多的糖果，所以她需要你的帮助。\n\n举例来说，考虑以下场景：\n\n* FJ 最初有 $10$ 颗糖果\n* 贝茜每天可以选择吃掉 $3$ 或 $5$ 颗糖果\n* 当剩余的糖果数量是 $2$ 或 $4$ 时，FJ 会添加 $1$ 颗糖果\n\n贝茜可以使用以下选择来最大化她能吃掉的糖果数量：\n\n```cpp\n                  初始糖果数     吃掉糖果数     剩余糖果数     奖励糖果数     最终糖果数\n        第1天        10            3            7             0            7\n        第2天         7            3            4             1            5\n        第3天         5            3            2             1            3\n        第4天         3            3            0             0            0\n```", "inputFormat": "* 第 $1$ 行：四个由空格分隔的整数：$N,Nopt,F,M$\n* 第 $2$ 行到第 $Nopt+1$ 行：第 $i+1$ 行包含一个整数：$C_i$\n* 第 $Nopt+2$ 行到第 $Nopt+F+1$ 行：第 $i+Nopt+1$ 行包含一个整数：$FN_i$", "outputFormat": "* 第 $1$ 行：一个整数，表示贝茜能吃掉的最大糖果数量，如果贝茜能吃掉无限多的糖果，则输出 `-1`。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2999", "type": "P", "difficulty": 3, "samples": [["9 \n1 4 \n3 5 \n2 4 \n5 6 \n6 7 \n7 8 \n4 6 \n7 9 \n", "6 \n7 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10NOV] Chocolate Milk S", "background": "", "description": "Farmer John's milk production and shipping system is an intricate one! He uses milking machines for his many cows to harvest the milk that then flows into pipes.\n\nEach of these pipes connects a milking machine to a joint, where it might be joined by exactly one more pipe (the milk flowing through both pipes merges). The milk then flows through additional pipes (which all start and end at joints) until it reaches the long central pipe connecting to the distribution room.\n\nThe milk then goes through a reverse process of splitting at various joints until it is flows into milk tanks that are picked up and taken to market.\n\nFarmer John notices that there is at most one way for milk to travel from one joint to any other joint. Furthermore, since Farmer John is an efficient man by nature, he has made sure that milk will flow through each and every pipe; in other words, no pipe is unneeded.\n\nIf we think of a milking machine, joint, or milk tank as a node, there are N (2 <= N <= 100,000) nodes in total (and N-1 pipes\n\nconnecting them). The input describes each pipe as an ordered pair of nodes, A\\_i (1 <= A\\_i <= N) and B\\_i (1 <= B\\_i <= N; A\\_i < B\\_i) indicating milk flows from node A\\_i to node B\\_i. If there is no pipe coming in to A\\_i, it is a milking machine. Likewise, if no pipe goes out from B\\_i, it is a tank.\n\nThe demand of chocolate milk has skyrocketed in recent months, and Farmer John wants to install a chocolate inserter at one of the joints so he can create delicious chocolate milk for customers.\n\nBeing thrifty, Farmer John has only bought one chocolate inserter, so he wants to place it at a joint through which all the milk passes. He knows that such a joint exists.\n\nHelp Farmer John find all the possible places he can install the chocolate inserter.  (Note that Farmer John cannot install the chocolate inserter at the same location as a milking machine.)\n\nAs an example, consider a milking setup like this one:\n\n```cpp\n\n           1 ----+\n                 |\n                 v\n           2 --> 4 --> 6 ------------------> 7 --> 8\n                       ^                     |\n                       |                     |\n           3 --> 5 ----+                     + --> 9\n\n```\nVisual inspection shows that the chocolate inserter can be installed at either joint 6 or 7, as all milk flows through those joints.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N: Line i+1 contains two space-separated integers that describe a pipe's connectivity: A\\_i and B\\_i\n", "outputFormat": "\\* Lines 1..??: Integers, one per line and in ascending order, each denoting a possible joint at which to install the chocolate inserter.", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10NOV] Chocolate Milk S", "background": "", "description": "Farmer John's milk production and shipping system is an intricate one! He uses milking machines for his many cows to harvest the milk that then flows into pipes.\n\nEach of these pipes connects a milking machine to a joint, where it might be joined by exactly one more pipe (the milk flowing through both pipes merges). The milk then flows through additional pipes (which all start and end at joints) until it reaches the long central pipe connecting to the distribution room.\n\nThe milk then goes through a reverse process of splitting at various joints until it is flows into milk tanks that are picked up and taken to market.\n\nFarmer John notices that there is at most one way for milk to travel from one joint to any other joint. Furthermore, since Farmer John is an efficient man by nature, he has made sure that milk will flow through each and every pipe; in other words, no pipe is unneeded.\n\nIf we think of a milking machine, joint, or milk tank as a node, there are N (2 <= N <= 100,000) nodes in total (and N-1 pipes\n\nconnecting them). The input describes each pipe as an ordered pair of nodes, A\\_i (1 <= A\\_i <= N) and B\\_i (1 <= B\\_i <= N; A\\_i < B\\_i) indicating milk flows from node A\\_i to node B\\_i. If there is no pipe coming in to A\\_i, it is a milking machine. Likewise, if no pipe goes out from B\\_i, it is a tank.\n\nThe demand of chocolate milk has skyrocketed in recent months, and Farmer John wants to install a chocolate inserter at one of the joints so he can create delicious chocolate milk for customers.\n\nBeing thrifty, Farmer John has only bought one chocolate inserter, so he wants to place it at a joint through which all the milk passes. He knows that such a joint exists.\n\nHelp Farmer John find all the possible places he can install the chocolate inserter.  (Note that Farmer John cannot install the chocolate inserter at the same location as a milking machine.)\n\nAs an example, consider a milking setup like this one:\n\n```cpp\n\n           1 ----+\n                 |\n                 v\n           2 --> 4 --> 6 ------------------> 7 --> 8\n                       ^                     |\n                       |                     |\n           3 --> 5 ----+                     + --> 9\n\n```\nVisual inspection shows that the chocolate inserter can be installed at either joint 6 or 7, as all milk flows through those joints.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N: Line i+1 contains two space-separated integers that describe a pipe's connectivity: A\\_i and B\\_i\n", "outputFormat": "\\* Lines 1..??: Integers, one per line and in ascending order, each denoting a possible joint at which to install the chocolate inserter.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10NOV] Chocolate Milk S", "background": null, "description": "农民约翰的牛奶生产和运输是一个复杂的过程，他用挤奶器给他的那么多头奶牛挤奶，然后流入管道。\n\n每一个管道把一台挤奶器和一个可能连有一台或多台挤奶器的接口连接起来（这样几个管道里的牛奶就汇合了）。然后牛奶流入附加管道（连在各个接口之间的管道）直到流到中央管道，通向储存室。 然后这些牛奶又经历一个逆向的过程通过管道分流到各个牛奶桶，最后被运至市场。\n\n约翰发现对于牛奶来说，最多只有一种方式从一个接口流到另一个接口。并且由于约翰是一个高效率的人，他需要确保每一个管道都有牛奶经过，也就是说，没有多余的管道。\n\n如果我们把每个挤奶机、接口和奶罐都看成一个节点，就共有 $N$ 个节点，输入有序的节点对 $A_{i}$ 和 $B_{i}$ ，代表牛奶从 $A_{i}$ 节点流到 $B_{i}$ 节点，如果没有相对应的父节点，那就说明这是一个挤奶器，同样的如果没有对应的尾节点，则这是一个奶罐。\n\n这几个月巧克力牛奶的需求量激增，所以约翰想要在某一个接口处安装一个巧克力混合器以得到巧克力牛奶，为了节约，约翰只买了一个巧克力混合器。所以他想把这个东西放到一个所有牛奶都能经过的接口，事实上，有这种接口存在。\n\n帮助约翰找到这样的节点（注意：不能把巧克力混合器放在挤奶机里）。\n```\n\n           1 ----+\n                 |\n                 v\n           2 --> 4 --> 6 ------------------> 7 --> 8\n                       ^                     |\n                       |                     |\n           3 --> 5 ----+                     + --> 9\n\n```\n所有的牛奶都会流经6号或7号节点，所以巧克力混合器可以放在这两个节点上。", "inputFormat": "第 $1$ 行一个整数 $N$（$2\\le N\\le10^5$）。\n\n第 $2$ 到第 $N$ 行：包含空格分隔的两个整数，描述第 $i$ 个管道连接的两个节点：$A_{i}$ 和 $B_{i}$（$1\\le A_{i}<B_{i}\\le N$）。", "outputFormat": "第 $1$ 行到 ？？行：每行一个整数，升序输出每个可以安装巧克力混合器的节点。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3000", "type": "P", "difficulty": 5, "samples": [["7 2 \n6 7 \n3 4 \n6 5 \n1 2 \n3 2 \n4 5 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "二分", "USACO", "树的直径"], "title": "[USACO10DEC] Cow Calisthenics G", "background": null, "description": "Farmer John 为了保持奶牛们的健康，让可怜的奶牛们不停在牧场之间的小路上奔跑。这些奶牛的路径集合可以被表示成一个点集和一些连接两个顶点的双向路，使得每对点之间恰好有一条简单路径。简单的说来， 这些点的布局就是一棵树，且每条边等长，都为 $1$。\n\n对于给定的一个奶牛路径集合，精明的奶牛们会计算出任意点对路径的最大值， 我们称之为这个路径集合的直径。如果直径太大，奶牛们就会拒绝锻炼。\n\nFarmer John 把每个点标记为 $1\\cdots V(2\\le V\\le 10^5)$。为了获得更加短的直径，他可以选择封锁一些已经存在的道路，这样就可以得到更多的路径集合， 从而减小一些路径集合的直径。我们从一棵树开始，Farmer John 可以选择封锁 $S(1\\le S\\le V-1)$ 条双向路，从而获得 $S+1$个路径集合。\n\n你要做的是计算出最佳的封锁方案，使得他得到的所有路径集合直径的最大值尽可能小。Farmer John 告诉你所有 $V-1$ 条双向道路，每条表述为：顶点 $A_i(1\\le A_i\\le V)$ 和 $B_i(1\\le B_i\\le V,A_i\\ne B_i)$ 连接。", "inputFormat": "第 $1$ 行：两个空格分隔的整数：$V$ 和 $S$，\n\n第 $2$ 到 $V$ 行：两个空格分隔的整数：$A_i$ 和 $B_i$。", "outputFormat": "一个整数，这是 FJ 用 $s$ 块可以实现的最佳最大路径长度", "hint": "Consider this rather linear cowpath set (a tree with 7 vertices):\n\n1---2---3---4---5---6---7\n\nIf FJ can block two paths, he might choose them to make a map like this:\n\n1---2 | 3---4 | 5---6---7 where the longest pathlength is 2, which would be the answer in this case. He can do no better than this.", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10DEC] Cow Calisthenics G", "background": "", "description": "To keep the cows healthy, Farmer John makes the poor cows run back and forth along paths between pastures. The cows’ path system can be represented as a set of vertices and some bidirectional roads connecting pairs of vertices, such that between every pair of vertices there is exactly one simple path. In other words, the layout of these vertices forms a tree, and every edge has the same length, equal to $1$.\n\nFor a given cowpath set, the clever cows compute the maximum distance between any pair of vertices, which we call the diameter of this path set. If the diameter is too large, the cows will refuse to exercise.\n\nFarmer John labels each vertex $1\\cdots V(2\\le V\\le 10^5)$. To obtain a smaller diameter, he can choose to block some existing roads, thus producing more cowpath sets and potentially reducing the diameters of some of them. Starting from a tree, Farmer John may block $S(1\\le S\\le V-1)$ bidirectional roads, thereby obtaining $S+1$ cowpath sets.\n\nYour task is to compute the best blocking plan so that the maximum diameter among all resulting cowpath sets is as small as possible. Farmer John gives you all $V-1$ bidirectional roads, each described as: vertices $A_i(1\\le A_i\\le V)$ and $B_i(1\\le B_i\\le V,A_i\\ne B_i)$ are connected.", "inputFormat": "Line 1: Two space-separated integers: $V$ and $S$.\n\nLines 2 to $V$: Two space-separated integers: $A_i$ and $B_i$.", "outputFormat": "A single integer, the best possible maximum path length that FJ can achieve using $S$ blocked roads.", "hint": "Consider this rather linear cowpath set (a tree with 7 vertices):\n\n1---2---3---4---5---6---7\n\nIf FJ can block two paths, he might choose them to make a map like this:\n\n1---2 | 3---4 | 5---6---7 where the longest path length is 2, which would be the answer in this case. He can do no better than this.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10DEC] Cow Calisthenics G", "background": null, "description": "Farmer John 为了保持奶牛们的健康，让可怜的奶牛们不停在牧场之间的小路上奔跑。这些奶牛的路径集合可以被表示成一个点集和一些连接两个顶点的双向路，使得每对点之间恰好有一条简单路径。简单的说来， 这些点的布局就是一棵树，且每条边等长，都为 $1$。\n\n对于给定的一个奶牛路径集合，精明的奶牛们会计算出任意点对路径的最大值， 我们称之为这个路径集合的直径。如果直径太大，奶牛们就会拒绝锻炼。\n\nFarmer John 把每个点标记为 $1\\cdots V(2\\le V\\le 10^5)$。为了获得更加短的直径，他可以选择封锁一些已经存在的道路，这样就可以得到更多的路径集合， 从而减小一些路径集合的直径。我们从一棵树开始，Farmer John 可以选择封锁 $S(1\\le S\\le V-1)$ 条双向路，从而获得 $S+1$个路径集合。\n\n你要做的是计算出最佳的封锁方案，使得他得到的所有路径集合直径的最大值尽可能小。Farmer John 告诉你所有 $V-1$ 条双向道路，每条表述为：顶点 $A_i(1\\le A_i\\le V)$ 和 $B_i(1\\le B_i\\le V,A_i\\ne B_i)$ 连接。", "inputFormat": "第 $1$ 行：两个空格分隔的整数：$V$ 和 $S$，\n\n第 $2$ 到 $V$ 行：两个空格分隔的整数：$A_i$ 和 $B_i$。", "outputFormat": "一个整数，这是 FJ 用 $s$ 块可以实现的最佳最大路径长度", "hint": "Consider this rather linear cowpath set (a tree with 7 vertices):\n\n1---2---3---4---5---6---7\n\nIf FJ can block two paths, he might choose them to make a map like this:\n\n1---2 | 3---4 | 5---6---7 where the longest pathlength is 2, which would be the answer in this case. He can do no better than this.", "locale": "zh-CN"}}}
{"pid": "P3001", "type": "P", "difficulty": 3, "samples": [["3 4 60 1 2 \n1 2 0.2 \n1 3 5 \n3 2 0.5 \n2 1 5 \n", "12.00 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO", "Special Judge", "最短路"], "title": "[USACO10DEC] Big Macs Around the World G", "background": "", "description": "Bessie is studying her favorite subject, Macroeconomics, in cowllege. For her final project, she will be presenting research on exchange rates between countries around the world.\n\n\nIn order to make her presentation more lively, she would like to show the relative prices of Big Macs around the world, despite their rather unsavory contents. To illustrate, suppose that Bessie would like to find smallest value of a Big Mac in a country given its value in some initial country and exchange rates from which other country's values can be calculated (as illustrated below):\n\n\n\n\n```cpp\n* A Big Mac is worth 60 dollars in the United States \n* The exchange rate from US dollars to Canadian dollars is 0.2 Canadian dollars per US dollar \n* The exchange rate from US dollars to British Pounds is 5.00 British Pounds per US Dollar \n* The exchange rate from British Pounds to Canadian dollars is 0.5 Canadian dollars per British Pound \n* The exchange rate between Canadian dollars to US dollars is 5.00 US dollars per Canadian dollar and Bessie would like to find the smallest possible value of a Big Mac in Canada that can be obtained by exchanging currencies. There are two ways: \n* Going from US dollars directly to Canada dollars would yield a burger worth 60.00 US dollars * 0.2 Canadian dollars / US dollar = 12.00 Canadian dollars \n* Going from US dollars to British Pounds to Canadian dollars would yield a burger worth 60.00 US$ * 5.00 GBP / 1 US$ * 0.5 C$ / 1 GBP = 150.00 C$ (Canadian dollars). \n```\nBessie would choose the former option, since she would much rather pay 12.00 Canadian dollars instead of 150.00 Canadian dollars for a Big Mac in Canada. \n\nBessie has N (1 <= N <= 2,000) countries conveniently labeled 1 to N that she would like to consider along with a list of M (1 <= M <= 25,000) exchange rates e_ij (0.1 < e_ij <= 10), each between countries i and j (1 <= i <= N; 1 <= j <= N). \n\nGiven the value V (1 <= V <= 1,000,000,000,000), which is not necessarily an integer, of the Big Mac in her starting country A (1 <= A <= N), help her find the smallest possible value of a Big Mac in country B (1 <= B <= N; B != A) after a series of currency conversions. If there is no minimum, output 0. \n\nIt is guaranteed that the answer is, if not 0, between 1 and 10^15.\n\nIt is also guaranteed that, for any country's currency, it is possible to get to any other country's currency.\n\n\n\n", "inputFormat": "Line 1: Five space-separated numbers: N, M, V, A, B\n\nLines 2..M+1: Three space-separated numbers: i, j, e\\_ij\n", "outputFormat": "Line 1: A single positive number, the price of the Big Mac, with absolute or relative error at most 10^-6. If there is no minimum, output 0.", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10DEC] Big Macs Around the World G", "background": "", "description": "Bessie is studying her favorite subject, Macroeconomics, in cowllege. For her final project, she will be presenting research on exchange rates between countries around the world.\n\n\nIn order to make her presentation more lively, she would like to show the relative prices of Big Macs around the world, despite their rather unsavory contents. To illustrate, suppose that Bessie would like to find smallest value of a Big Mac in a country given its value in some initial country and exchange rates from which other country's values can be calculated (as illustrated below):\n\n\n\n\n```cpp\n* A Big Mac is worth 60 dollars in the United States \n* The exchange rate from US dollars to Canadian dollars is 0.2 Canadian dollars per US dollar \n* The exchange rate from US dollars to British Pounds is 5.00 British Pounds per US Dollar \n* The exchange rate from British Pounds to Canadian dollars is 0.5 Canadian dollars per British Pound \n* The exchange rate between Canadian dollars to US dollars is 5.00 US dollars per Canadian dollar and Bessie would like to find the smallest possible value of a Big Mac in Canada that can be obtained by exchanging currencies. There are two ways: \n* Going from US dollars directly to Canada dollars would yield a burger worth 60.00 US dollars * 0.2 Canadian dollars / US dollar = 12.00 Canadian dollars \n* Going from US dollars to British Pounds to Canadian dollars would yield a burger worth 60.00 US$ * 5.00 GBP / 1 US$ * 0.5 C$ / 1 GBP = 150.00 C$ (Canadian dollars). \n```\nBessie would choose the former option, since she would much rather pay 12.00 Canadian dollars instead of 150.00 Canadian dollars for a Big Mac in Canada. \n\nBessie has N (1 <= N <= 2,000) countries conveniently labeled 1 to N that she would like to consider along with a list of M (1 <= M <= 25,000) exchange rates e_ij (0.1 < e_ij <= 10), each between countries i and j (1 <= i <= N; 1 <= j <= N). \n\nGiven the value V (1 <= V <= 1,000,000,000,000), which is not necessarily an integer, of the Big Mac in her starting country A (1 <= A <= N), help her find the smallest possible value of a Big Mac in country B (1 <= B <= N; B != A) after a series of currency conversions. If there is no minimum, output 0. \n\nIt is guaranteed that the answer is, if not 0, between 1 and 10^15.\n\nIt is also guaranteed that, for any country's currency, it is possible to get to any other country's currency.\n\n\n\n", "inputFormat": "Line 1: Five space-separated numbers: N, M, V, A, B\n\nLines 2..M+1: Three space-separated numbers: i, j, e\\_ij\n", "outputFormat": "Line 1: A single positive number, the price of the Big Mac, with absolute or relative error at most 10^-6. If there is no minimum, output 0.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10DEC] Big Macs Around the World G", "background": "", "description": "Bessie 正在学习她最喜欢的科目宏观经济学，作为她最后一门学科，她将对世界各种货币的汇率进行研究。\n\n为了让她的演讲更加生动，她会展示一个叫做 BM 的商品在全世界的相对价格。举个例子，Bessie 会通过其他国家的汇率去找到一件 BM 在一个国家的最小价值。\n\n- 一件 BM 在美国值 $60$ 美元；\n- 美元与加拿大元的汇率为 $1$ 美元换 $0.2$ 加拿大元（$1:0.2$）。\n- 美元与英镑的汇率为 $1$ 美元换 $5$ 英镑（$1:5$）。\n- 英镑与加拿大元的汇率为 $1$ 英镑换 $0.5$ 加拿大元（$1:0.5$）。\n- 加拿大元与美元的汇率是 $5$ 美元换一加拿大元（$5:1$），Bessie 有两种方法通过货币兑换在加拿大这个国家找到一件 BM 的最低价值：\n\n1. 拿着美元直接去加拿大，通过汇率得出一件 BM 只要 $12$ 加拿大元；\n2. 拿着美元去英国，兑换为英镑后再去加拿大，得出一件 BM 要 $150$ 加拿大元。\n\nBessie 会选择前一种方案因为她更乐意为在加拿大买一件 BM 支付 $12$ 加元而不是 $150$ 加元。\n\nBessie 有 $N(1\\leq N\\leq 2000)$ 个国家的信息和 $M(1\\leq M\\leq25000)$ 种汇率，在 $i,j$ 国间的汇率表示为 $e_{ij}(0.1\\leq e_{ij}\\leq 10)$。\n\n给你一个值 $V(1\\leq V\\leq 10^{12})$，$V$ 不一定是一个整数。$V$ 是 BM 在起始国家 A 的价格，帮助 Bessie 寻找到在 B 国 BM 最低的价格，如果不存在，则输出 $0$。\n\n据保证答案小于 $10^{15}$，也保证所有国家都可以通过汇率将钱币转为别的国家的。", "inputFormat": "第 $1$ 行：五个数：$N,M,V,A,B$，分别一个空格隔开。\n\n第 $2$ 到 $M+1$ 行：三个数 $i,j,e_{ij}$，分别一个空格隔开。", "outputFormat": "一行：BM 在 B 国的最低价格，精确到 $10^{-6}$。如果没有最小值，输出 $0$。\n\n**注意，本题的汇率是单向的**。\n\n感谢 @JJYZ\\_cbh 的耐心翻译", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3002", "type": "P", "difficulty": 6, "samples": [["38 9 \nTHEQUICKBROWNFOXDO \nGJUMPSOVERTHELAZYDOG \nFOXDOG \nDOG \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2010", "USACO", "后缀自动机 SAM", "后缀数组 SA"], "title": "[USACO10DEC] Threatening Letter G", "background": null, "description": "FJ 刚刚和邻居发生了一场可怕的争吵，他咽不下这口气，于是决定佚名发给他的邻居一封脏话连篇的信。他有无限张完全相同的已经打印好的纸张，都包含 $N$ 个字母（用一个长为 $N$ 的字符串表示）。他有一把举世无双的剪刀，可以从某张纸中通过一刀剪出连续的一段（也可以通过一刀获得整个字符串），然后将剪出的段落拼成 $M$ 个字母长的一封信（用一个长为 $M$ 的字符串表示）。他想知道获得这封信最少需要剪多少刀。保证这总是可能的。\n\n注意：输入中以上两个字符串均被摊到了若干行中。", "inputFormat": "第一行，两个正整数 $N, M$，含义见上。\n\n接下来若干行，一共 $N$ 个字母，表示纸上原有内容。\n\n接下来若干行，一共 $M$ 个字母，表示 FJ 想要拼出的信的内容。\n\n保证每行不超过 $80$ 个字符。", "outputFormat": "一行一个整数，表示最少需要剪多少次。", "hint": "$1\\le N,M\\le 5*10^4$", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10DEC] Threatening Letter G", "background": null, "description": "FJ has had a terrible fight with his neighbor and wants to send him a nasty letter, but wants to remain anonymous. As so many before him have done, he plans to cut out printed letters and paste them onto a sheet of paper. He has an infinite number of the most recent issue of the Moo York Times that has $N$ ($1 \\le N \\le 50,000$) uppercase letters laid out in a long string (though read in as a series of shorter strings). Likewise, he has a message he'd like to compose that is a single long string of letters but that is read in as a set of shorter strings.\n\nBeing lazy, he wants to make the smallest possible number of cuts. FJ has a really great set of scissors that enables him to remove any single-line snippet from the Moo York Times with one cut. He notices that he can cut entire words or phrases with a single cut, thus reducing his total number of cuts.\n\nWhat is the minimum amount of cuts he has to make to construct his letter of $M$ ($1 \\le M \\le 50,000$) letters?\n\nIt is guaranteed that it is possible for FJ to complete his task.\n\nConsider a 38 letter Moo York Times:\n\n```cpp\nTHEQUICKBROWNFOXDO \nGJUMPSOVERTHELAZYDOG\n```\nfrom which FJ wants to construct a 9 letter message: \n```cpp\nFOXDOG \nDOG \n```\n\nThese input lines represent a pair of strings:\n\n`THEQUICKBROWNFOXDOGJUMPSOVERTHELAZYDOG`\n\n`FOXDOGDOG `\n\nSince `FOXDOG` exists in the newspaper, FJ can cut this piece out and then get the last `DOG` by cutting out either instance of the word `DOG`. \n\nThus, he requires but two cuts.", "inputFormat": "\\* Line 1: Two space-separated integers: $N$ and $M$\n\n\\* Lines 2..?: $N$ letters laid out on several input lines; this is the text of the one copy of the Moo York Times. Each line will have no more than 80 characters.\n\n\\* Lines ?..?: $M$ letters that are the text of FJ's letter. Each line will have no more than 80 characters.", "outputFormat": "\\* Line 1: The minimum number of cuts FJ has to make to create his message", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO10DEC] Threatening Letter G", "background": null, "description": "FJ 刚刚和邻居发生了一场可怕的争吵，他咽不下这口气，于是决定佚名发给他的邻居一封脏话连篇的信。他有无限张完全相同的已经打印好的纸张，都包含 $N$ 个字母（用一个长为 $N$ 的字符串表示）。他有一把举世无双的剪刀，可以从某张纸中通过一刀剪出连续的一段（也可以通过一刀获得整个字符串），然后将剪出的段落拼成 $M$ 个字母长的一封信（用一个长为 $M$ 的字符串表示）。他想知道获得这封信最少需要剪多少刀。保证这总是可能的。\n\n注意：输入中以上两个字符串均被摊到了若干行中。", "inputFormat": "第一行，两个正整数 $N, M$，含义见上。\n\n接下来若干行，一共 $N$ 个字母，表示纸上原有内容。\n\n接下来若干行，一共 $M$ 个字母，表示 FJ 想要拼出的信的内容。\n\n保证每行不超过 $80$ 个字符。", "outputFormat": "一行一个整数，表示最少需要剪多少次。", "hint": "$1\\le N,M\\le 5*10^4$", "locale": "zh-CN"}}}
{"pid": "P3003", "type": "P", "difficulty": 3, "samples": [["9 7 5 1 4 \n5 1 7 \n6 7 2 \n4 7 2 \n5 6 1 \n5 2 4 \n4 3 2 \n1 2 3 \n3 2 2 \n2 6 3 \n", "12 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO", "最短路"], "title": "[USACO10DEC] Apple Delivery S", "background": "", "description": "Bessie has two crisp red apples to deliver to two of her friends in the herd. Of course, she travels the C (1 <= C <= 200,000)\n\ncowpaths which are arranged as the usual graph which connects P (1 <= P <= 100,000) pastures conveniently numbered from 1..P: no cowpath leads from a pasture to itself, cowpaths are bidirectional, each cowpath has an associated distance, and, best of all, it is always possible to get from any pasture to any other pasture. Each cowpath connects two differing pastures P1\\_i (1 <= P1\\_i <= P) and P2\\_i (1 <= P2\\_i <= P) with a distance between them of D\\_i. The sum of all the distances D\\_i does not exceed 2,000,000,000.\n\nWhat is the minimum total distance Bessie must travel to deliver both apples by starting at pasture PB (1 <= PB <= P) and visiting pastures PA1 (1 <= PA1 <= P) and PA2 (1 <= PA2 <= P) in any order. All three of these pastures are distinct, of course.\n\nConsider this map of bracketed pasture numbers and cowpaths with distances:\n\n```cpp\n               3        2       2\n           [1]-----[2]------[3]-----[4]\n             \\     / \\              /\n             7\\   /4  \\3           /2\n               \\ /     \\          /\n               [5]-----[6]------[7]\n                    1       2\n```\nIf Bessie starts at pasture [5] and delivers apples to pastures [1] and [4], her best path is:\n\n5 -> 6-> 7 -> 4\\* -> 3 -> 2 -> 1\\*\n\nwith a total distance of 12.", "inputFormat": "\\* Line 1: Line 1 contains five space-separated integers: C, P, PB, PA1, and PA2\n\n\\* Lines 2..C+1: Line i+1 describes cowpath i by naming two pastures it connects and the distance between them: P1\\_i, P2\\_i, D\\_i\n", "outputFormat": "\\* Line 1: The shortest distance Bessie must travel to deliver both apples\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10DEC] Apple Delivery S", "background": "", "description": "Bessie has two crisp red apples to deliver to two of her friends in the herd. Of course, she travels the C (1 <= C <= 200,000)\n\ncowpaths which are arranged as the usual graph which connects P (1 <= P <= 100,000) pastures conveniently numbered from 1..P: no cowpath leads from a pasture to itself, cowpaths are bidirectional, each cowpath has an associated distance, and, best of all, it is always possible to get from any pasture to any other pasture. Each cowpath connects two differing pastures P1\\_i (1 <= P1\\_i <= P) and P2\\_i (1 <= P2\\_i <= P) with a distance between them of D\\_i. The sum of all the distances D\\_i does not exceed 2,000,000,000.\n\nWhat is the minimum total distance Bessie must travel to deliver both apples by starting at pasture PB (1 <= PB <= P) and visiting pastures PA1 (1 <= PA1 <= P) and PA2 (1 <= PA2 <= P) in any order. All three of these pastures are distinct, of course.\n\nConsider this map of bracketed pasture numbers and cowpaths with distances:\n\n```cpp\n               3        2       2\n           [1]-----[2]------[3]-----[4]\n             \\     / \\              /\n             7\\   /4  \\3           /2\n               \\ /     \\          /\n               [5]-----[6]------[7]\n                    1       2\n```\nIf Bessie starts at pasture [5] and delivers apples to pastures [1] and [4], her best path is:\n\n5 -> 6-> 7 -> 4\\* -> 3 -> 2 -> 1\\*\n\nwith a total distance of 12.", "inputFormat": "\\* Line 1: Line 1 contains five space-separated integers: C, P, PB, PA1, and PA2\n\n\\* Lines 2..C+1: Line i+1 describes cowpath i by naming two pastures it connects and the distance between them: P1\\_i, P2\\_i, D\\_i\n", "outputFormat": "\\* Line 1: The shortest distance Bessie must travel to deliver both apples\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10DEC] Apple Delivery S", "background": null, "description": "Bessie 有两只鲜红的苹果要送给她在牛群中的两个朋友。当然，她要走 $C$ 条牛道（$1 \\le C \\le 2\\times 10^5$），这些牛道构成了一个常见的图，方便地连接了 $P$ 个牧场（$1 \\le P \\le 10^5$），这些牧场的编号从 $1$ 到 $P$：没有牛道从一个牧场通向自身，牛道是双向的，每条牛道都有一个相关的距离，最重要的是，总是可以从任何一个牧场到达另一个牧场。每条牛道连接两个不同的牧场 $P1_i$（$1 \\le P1_i \\le P$）和 $P2_i$（$1 \\le P2_i \\le P$），它们之间的距离为 $D_i$。所有距离 $D_i$ 的总和不超过 $2\\times 10^9$。\n\nBessie 要从牧场 $PB$（$1 \\le PB \\le P$）出发，按任意顺序访问牧场 $PA_1$（$1 \\le PA_1 \\le P$）和 $PA_2$（$1 \\le PA_2 \\le P$），送完两个苹果后，求她必须行走的最小总距离。当然，这三个牧场是不同的。\n\n考虑这个用括号标注牧场编号和牛道距离的地图：\n\n```cpp\n               3        2       2\n           [1]-----[2]------[3]-----[4]\n             \\     / \\              /\n             7\\   /4  \\3           /2\n               \\ /     \\          /\n               [5]-----[6]------[7]\n                    1       2\n```\n如果 Bessie 从牧场 $[5]$ 出发，将苹果送到牧场 $[1]$ 和 $[4]$，她的最佳路径是：\n\n$5$ -> $6$ -> $7$ -> $4*$ -> $3$ -> $2$ -> $1*$\n\n总距离为 $12$。", "inputFormat": "\\* 第 $1$ 行：包含五个用空格分隔的整数：$C, P, PB, PA_1 $ 和 $PA_2$。\n\n\\* 第 $2$ 行到第 $C+1$ 行：第 $i+1$ 行描述牛道 $i$，给出它连接的两个牧场及其之间的距离：$P1_i$, $P2_i$, $D_i$。", "outputFormat": "\\* 第 $1$ 行：Bessie 必须行走的最短距离。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3004", "type": "P", "difficulty": 4, "samples": [["4 \n30 \n25 \n10 \n35 \n", "60 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["动态规划 DP", "递推", "2010", "USACO"], "title": "[USACO10DEC] Treasure Chest S", "background": "", "description": "Bessie and Bonnie have found a treasure chest full of marvelous gold coins! Being cows, though, they can't just walk into a store and buy stuff, so instead they decide to have some fun with the coins.\n\nThe N (1 <= N <= 5,000) coins, each with some value C\\_i (1 <= C\\_i <= 5,000) are placed in a straight line. Bessie and Bonnie take turns, and for each cow's turn, she takes exactly one coin off of either the left end or the right end of the line. The game ends when there are no coins left.\n\nBessie and Bonnie are each trying to get as much wealth as possible for themselves. Bessie goes first. Help her figure out the maximum value she can win, assuming that both cows play optimally.\n\nConsider a game in which four coins are lined up with these values:\n\n30  25  10  35\n\nConsider this game sequence:\n\nBessie    Bonnie       New Coin\n\nPlayer   Side   CoinValue   Total     Total         Line\n\nBessie   Right     35        35         0       30  25  10\n\nBonnie   Left      30        35        30         25  10\n\nBessie   Left      25        60        30           10\n\nBonnie   Right     10        60        40           --\n\nThis is the best game Bessie can play.\n\n小 A 和小 B 在玩游戏。\n\n初始时，有 $n$ 个硬币被摆成了一行，从左至右数第 $i$ 个硬币的价值为 $c_i$。\n\n小 A 和小 B 每人一回合，在一个人的回合中，他可以选择**当前**硬币序列最左侧或者最右侧的硬币，并将他从序列中取出，将其价值累加到自己获得的累计价值中，然后进行另一个人的回合。当硬币全部被取走时，游戏结束。\n\n请求出在双方都尽可能的使自己累计价值最大的情况下，若由小 A 进行第一回合，那么他能获得的累计价值最大是多少。", "inputFormat": "输入的第一行是一个整数 $n$，代表硬币的个数。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i + 1)$ 行的整数代表第 $i$ 个硬币的价值 $c_i$。", "outputFormat": "输出一行一个整数，代表小 A 能获得的最大累计价值。", "hint": "#### 输入输出样例 $1$ 解释\n\n初始时，硬币序列为 $\\{30,~25,~10,~35\\}$。\n\n第一回合，小 A 取走最右侧的硬币，序列变为 $\\{30,~25,~10\\}$，小 A 的累加价值为 $35$。\n\n第二回合，小 B 取走最左侧的硬币，序列变为 $\\{25,~10\\}$，小 B 的累加价值为 $30$。\n\n第三回合，小 A 取走最左侧的硬币，序列变为 $\\{10\\}$，小 A 的累加价值为 $35 + 25 = 60$。\n\n第四回合，小 B 取走最左侧的硬币，序列变为空，小 B 的累加价值为 $30 + 10 = 40$，游戏结束。\n\n小 A 获得的最大累计价值为 $60$。\n\n#### 数据范围与约定\n\n对于全部的测试点，$1 \\leq n \\leq 5 \\times 10^3$，$1 \\leq c_i \\leq 5 \\times 10^3$。\n\n**提示：请注意，本题的空间限制为 $64$ Mib。**", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10DEC] Treasure Chest S", "background": "", "description": "Two players, A and B, are playing a game.\n\nInitially, there are $n$ coins in a line. From left to right, the value of the $i$-th coin is $c_i$.\n\nA and B take turns, one move per turn. On a player's turn, they must choose the leftmost or the rightmost coin from the current sequence, remove it from the sequence, and add its value to their own total. The game ends when all coins have been taken.\n\nAssuming both players play optimally to maximize their own total value, and player A moves first, determine the maximum total value that A can obtain.", "inputFormat": "- The first line contains an integer $n$, the number of coins.\n- Lines $2$ to $(n + 1)$ each contain one integer. The integer on line $(i + 1)$ is the value $c_i$ of the $i$-th coin.", "outputFormat": "Output a single integer: the maximum total value that player A can obtain.", "hint": "- Sample explanation:\n\n  Initially, the coin sequence is $\\{30,~25,~10,~35\\}$.\n\n  - Turn 1: A takes the rightmost coin, the sequence becomes $\\{30,~25,~10\\}$, and A’s total is $35$.\n  - Turn 2: B takes the leftmost coin, the sequence becomes $\\{25,~10\\}$, and B’s total is $30$.\n  - Turn 3: A takes the leftmost coin, the sequence becomes $\\{10\\}$, and A’s total is $35 + 25 = 60$.\n  - Turn 4: B takes the leftmost coin, the sequence becomes empty, and B’s total is $30 + 10 = 40$. The game ends.\n\n  The maximum total value that A can obtain is $60$.\n\n- Constraints:\n\n  For all testdata, $1 \\leq n \\leq 5 \\times 10^3$, $1 \\leq c_i \\leq 5 \\times 10^3$.\n\n- Note: The memory limit is $64$ MiB.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10DEC] Treasure Chest S", "background": "", "description": "Bessie and Bonnie have found a treasure chest full of marvelous gold coins! Being cows, though, they can't just walk into a store and buy stuff, so instead they decide to have some fun with the coins.\n\nThe N (1 <= N <= 5,000) coins, each with some value C\\_i (1 <= C\\_i <= 5,000) are placed in a straight line. Bessie and Bonnie take turns, and for each cow's turn, she takes exactly one coin off of either the left end or the right end of the line. The game ends when there are no coins left.\n\nBessie and Bonnie are each trying to get as much wealth as possible for themselves. Bessie goes first. Help her figure out the maximum value she can win, assuming that both cows play optimally.\n\nConsider a game in which four coins are lined up with these values:\n\n30  25  10  35\n\nConsider this game sequence:\n\nBessie    Bonnie       New Coin\n\nPlayer   Side   CoinValue   Total     Total         Line\n\nBessie   Right     35        35         0       30  25  10\n\nBonnie   Left      30        35        30         25  10\n\nBessie   Left      25        60        30           10\n\nBonnie   Right     10        60        40           --\n\nThis is the best game Bessie can play.\n\n小 A 和小 B 在玩游戏。\n\n初始时，有 $n$ 个硬币被摆成了一行，从左至右数第 $i$ 个硬币的价值为 $c_i$。\n\n小 A 和小 B 每人一回合，在一个人的回合中，他可以选择**当前**硬币序列最左侧或者最右侧的硬币，并将他从序列中取出，将其价值累加到自己获得的累计价值中，然后进行另一个人的回合。当硬币全部被取走时，游戏结束。\n\n请求出在双方都尽可能的使自己累计价值最大的情况下，若由小 A 进行第一回合，那么他能获得的累计价值最大是多少。", "inputFormat": "输入的第一行是一个整数 $n$，代表硬币的个数。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i + 1)$ 行的整数代表第 $i$ 个硬币的价值 $c_i$。", "outputFormat": "输出一行一个整数，代表小 A 能获得的最大累计价值。", "hint": "#### 输入输出样例 $1$ 解释\n\n初始时，硬币序列为 $\\{30,~25,~10,~35\\}$。\n\n第一回合，小 A 取走最右侧的硬币，序列变为 $\\{30,~25,~10\\}$，小 A 的累加价值为 $35$。\n\n第二回合，小 B 取走最左侧的硬币，序列变为 $\\{25,~10\\}$，小 B 的累加价值为 $30$。\n\n第三回合，小 A 取走最左侧的硬币，序列变为 $\\{10\\}$，小 A 的累加价值为 $35 + 25 = 60$。\n\n第四回合，小 B 取走最左侧的硬币，序列变为空，小 B 的累加价值为 $30 + 10 = 40$，游戏结束。\n\n小 A 获得的最大累计价值为 $60$。\n\n#### 数据范围与约定\n\n对于全部的测试点，$1 \\leq n \\leq 5 \\times 10^3$，$1 \\leq c_i \\leq 5 \\times 10^3$。\n\n**提示：请注意，本题的空间限制为 $64$ Mib。**", "locale": "zh-CN"}}}
{"pid": "P3005", "type": "P", "difficulty": 3, "samples": [["4 4 \n1000 1 \n0110 1 \n1001 1 \n0011 1 \n", "1010 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10DEC] The Trough Game S", "background": "", "description": "Farmer John and Bessie are playing games again. This one has to do with troughs of water.\n\nFarmer John has hidden N (1 <= N <= 20) troughs behind the barn, and has filled some of them with food. Bessie has asked M (1 <= M <= 100) questions of the form, 'How many troughs from this list (which she recites) are filled?'.\n\nBessie needs your help to deduce which troughs are actually filled.\n\nConsider an example with four troughs where Bessie has asked these questions (and received the indicated answers):\n\n1) 'How many of these troughs are filled: trough 1' -->  1 trough is filled\n\n2) 'How many of these troughs are filled: troughs 2 and 3' -->  1 trough is filled\n\n3) 'How many of these troughs are filled: troughs 1 and 4' -->  1 trough is filled\n\n4) 'How many of these troughs are filled: troughs 3 and 4' -->  1 trough is filled\n\nFrom question 1, we know trough 1 is filled.\n\nFrom question 3, we then know trough 4 is empty. \n\nFrom question 4, we then know that trough 3 is filled. \n\nFrom question 2, we then know that trough 2 is empty. \n\nFarmer John 和 Bessie 在玩一个游戏。\n\nFarmer John 准备了 $n$ 个槽（$1\\le n\\le20$），其中一些槽中藏有食物。Bessie 为了知道哪些槽中有食物，会询问 $m$ 个形如“第 $x_1\\cdots x_k$ 号槽中是否有食物？”的问题（$1\\le m\\le100,1\\le k\\le n$）。\n\n请你帮忙求出哪几个槽中有食物。\n\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: A subset of troughs, specified as a sequence of contiguous N 0's and 1's, followed by a single integer that is the number of troughs in the specified subset that are filled.\n\n第一行包含两个整数 $n,m$，分别表示槽的个数和 Bessie 询问的问题数。\n\n接下来 $m$ 行每行包含一个长度为 $n$ 的 $01$ 序列和一个整数 $t$，其中 $01$ 序列中的 $1$ 表示询问中提到了这个位置的槽，$t$ 表示这些槽中有 $t$ 份食物。\n", "outputFormat": "\\* Line 1: A single line with:\n\n\\* The string 'IMPOSSIBLE' if there is no possible set of filled troughs compatible with Farmer John's answers.\n\n\\* The string 'NOT UNIQUE' if Bessie cannot determine from the given data exactly what troughs are filled.\n\n\\* Otherwise, a sequence of contiguous N 0's and 1's specifying which troughs are filled.\n\n\n\n输出共一行。\n\n若无解，则输出 `IMPOSSIBLE`。\n\n若不止一个解，则输出 `NOT UNIQUE`。\n\n若有唯一解，则输出一个 $01$ 序列，其中 $1$ 表示这个位置的槽中有食物。", "hint": "### 样例解释\n四个序列分别表示如下对话：\n\n1. 问：在第一个槽中有多少个槽里有食物？——答：$1$ 个。\n2. 问：在第二个和第三个槽中有多少个槽里有食物？——答：$1$ 个。\n3. 问：在第一个和第四个槽中有多少个槽里有食物？——答：$1$ 个。\n4. 问：在第三个和第四个槽中有多少个槽里有食物？——答：$1$ 个。\n\n从第一个问题可以知道，第一个槽是有食物的。\n\n从第三个问题可以知道，第四个槽是没有食物的。\n\n从第四个问题可以知道，第三个槽是有食物的。\n\n从第二个问题可以知道，第二个槽是没有食物的。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10DEC] The Trough Game S", "background": "", "description": "Farmer John and Bessie are playing games again. This one has to do with troughs of water.\n\nFarmer John has hidden N (1 <= N <= 20) troughs behind the barn, and has filled some of them with food. Bessie has asked M (1 <= M <= 100) questions of the form, 'How many troughs from this list (which she recites) are filled?'.\n\nBessie needs your help to deduce which troughs are actually filled.\n\nConsider an example with four troughs where Bessie has asked these questions (and received the indicated answers):\n\n1) 'How many of these troughs are filled: trough 1' --> 1 trough is filled.\n\n2) 'How many of these troughs are filled: troughs 2 and 3' --> 1 trough is filled.\n\n3) 'How many of these troughs are filled: troughs 1 and 4' --> 1 trough is filled.\n\n4) 'How many of these troughs are filled: troughs 3 and 4' --> 1 trough is filled.\n\nFrom question 1, we know trough 1 is filled.\n\nFrom question 3, we then know trough 4 is empty.\n\nFrom question 4, we then know that trough 3 is filled.\n\nFrom question 2, we then know that trough 2 is empty.\n\nFarmer John and Bessie are playing a game.\n\nFarmer John has prepared $n$ troughs ($1 \\le n \\le 20$), and some of them contain food. To figure out which troughs contain food, Bessie asks $m$ questions of the form “How many of the troughs numbered $x_1 \\cdots x_k$ are filled?” ($1 \\le m \\le 100$, $1 \\le k \\le n$).\n\nPlease determine which troughs contain food.", "inputFormat": "- Line 1: Two space-separated integers: N and M.\n\n- Lines 2..M+1: A subset of troughs, specified as a sequence of contiguous N 0's and 1's, followed by a single integer that is the number of troughs in the specified subset that are filled.\n\nThe first line contains two integers $n, m$, denoting the number of troughs and the number of questions, respectively.\n\nEach of the next $m$ lines contains a $01$ string of length $n$ and an integer $t$, where a $1$ in the $01$ string indicates the trough at that position is included in the query, and $t$ is the number of included troughs that are filled.", "outputFormat": "- Line 1: A single line with:\n- The string 'IMPOSSIBLE' if there is no possible set of filled troughs compatible with Farmer John's answers.\n- The string 'NOT UNIQUE' if Bessie cannot determine from the given data exactly what troughs are filled.\n- Otherwise, a sequence of contiguous N 0's and 1's specifying which troughs are filled.\n\nIf there is no solution, print `IMPOSSIBLE`.\n\nIf there is more than one solution, print `NOT UNIQUE`.\n\nIf there is a unique solution, print a $01$ string in which a $1$ indicates the trough at that position contains food.", "hint": "Sample explanation:\nThe four sequences correspond to the following dialogue:\n\n1. Q: How many of the first troughs contain food? — A: $1$.\n2. Q: How many of the second and third troughs contain food? — A: $1$.\n3. Q: How many of the first and fourth troughs contain food? — A: $1$.\n4. Q: How many of the third and fourth troughs contain food? — A: $1$.\n\nFrom the first question, we can tell the first trough contains food.\n\nFrom the third question, we can tell the fourth trough does not contain food.\n\nFrom the fourth question, we can tell the third trough contains food.\n\nFrom the second question, we can tell the second trough does not contain food.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10DEC] The Trough Game S", "background": "", "description": "Farmer John and Bessie are playing games again. This one has to do with troughs of water.\n\nFarmer John has hidden N (1 <= N <= 20) troughs behind the barn, and has filled some of them with food. Bessie has asked M (1 <= M <= 100) questions of the form, 'How many troughs from this list (which she recites) are filled?'.\n\nBessie needs your help to deduce which troughs are actually filled.\n\nConsider an example with four troughs where Bessie has asked these questions (and received the indicated answers):\n\n1) 'How many of these troughs are filled: trough 1' -->  1 trough is filled\n\n2) 'How many of these troughs are filled: troughs 2 and 3' -->  1 trough is filled\n\n3) 'How many of these troughs are filled: troughs 1 and 4' -->  1 trough is filled\n\n4) 'How many of these troughs are filled: troughs 3 and 4' -->  1 trough is filled\n\nFrom question 1, we know trough 1 is filled.\n\nFrom question 3, we then know trough 4 is empty. \n\nFrom question 4, we then know that trough 3 is filled. \n\nFrom question 2, we then know that trough 2 is empty. \n\nFarmer John 和 Bessie 在玩一个游戏。\n\nFarmer John 准备了 $n$ 个槽（$1\\le n\\le20$），其中一些槽中藏有食物。Bessie 为了知道哪些槽中有食物，会询问 $m$ 个形如“第 $x_1\\cdots x_k$ 号槽中是否有食物？”的问题（$1\\le m\\le100,1\\le k\\le n$）。\n\n请你帮忙求出哪几个槽中有食物。\n\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: A subset of troughs, specified as a sequence of contiguous N 0's and 1's, followed by a single integer that is the number of troughs in the specified subset that are filled.\n\n第一行包含两个整数 $n,m$，分别表示槽的个数和 Bessie 询问的问题数。\n\n接下来 $m$ 行每行包含一个长度为 $n$ 的 $01$ 序列和一个整数 $t$，其中 $01$ 序列中的 $1$ 表示询问中提到了这个位置的槽，$t$ 表示这些槽中有 $t$ 份食物。\n", "outputFormat": "\\* Line 1: A single line with:\n\n\\* The string 'IMPOSSIBLE' if there is no possible set of filled troughs compatible with Farmer John's answers.\n\n\\* The string 'NOT UNIQUE' if Bessie cannot determine from the given data exactly what troughs are filled.\n\n\\* Otherwise, a sequence of contiguous N 0's and 1's specifying which troughs are filled.\n\n\n\n输出共一行。\n\n若无解，则输出 `IMPOSSIBLE`。\n\n若不止一个解，则输出 `NOT UNIQUE`。\n\n若有唯一解，则输出一个 $01$ 序列，其中 $1$ 表示这个位置的槽中有食物。", "hint": "### 样例解释\n四个序列分别表示如下对话：\n\n1. 问：在第一个槽中有多少个槽里有食物？——答：$1$ 个。\n2. 问：在第二个和第三个槽中有多少个槽里有食物？——答：$1$ 个。\n3. 问：在第一个和第四个槽中有多少个槽里有食物？——答：$1$ 个。\n4. 问：在第三个和第四个槽中有多少个槽里有食物？——答：$1$ 个。\n\n从第一个问题可以知道，第一个槽是有食物的。\n\n从第三个问题可以知道，第四个槽是没有食物的。\n\n从第四个问题可以知道，第三个槽是有食物的。\n\n从第二个问题可以知道，第二个槽是没有食物的。", "locale": "zh-CN"}}}
{"pid": "P3006", "type": "P", "difficulty": 6, "samples": [["4 1 \n1 1 5 \n2 12 7 \n3 12 3 \n5 \n", "25 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "线段树", "USACO", "最短路", "树链剖分"], "title": "[USACO11JAN] Bottleneck G", "background": "", "description": "Farmer John is gathering the cows. His farm contains a network of N (1 <= N <= 100,000) fields conveniently numbered 1..N and connected by N-1 unidirectional paths that eventually lead to field 1. The fields and paths form a tree.\n\nEach field i > 1 has a single one-way, exiting path to field P\\_i, and currently contains C\\_i cows (1 <= C\\_i <= 1,000,000,000). In each time unit, no more than M\\_i (0 <= M\\_i <= 1,000,000,000) cows can travel from field i to field P\\_i (1 <= P\\_i <= N) (i.e., only M\\_i cows can traverse the path).\n\nFarmer John wants all the cows to congregate in field 1 (which has no limit on the number of cows it may have). Rules are as follows:\n\n\\* Time is considered in discrete units.\n\n\\* Any given cow might traverse multiple paths in the same time unit. However, no more than M\\_i total cows can leave field i (i.e., traverse its exit path) in the same time unit.\n\n\\* Cows never move \\*away\\* from field #1.\n\nIn other words, every time step, each cow has the choice either to\n\na) stay in its current field\n\nb) move through one or more fields toward field #1, as long as the bottleneck constraints for each path are not violated\n\nFarmer John wants to know how many cows can arrive in field 1 by certain times. In particular, he has a list of K (1 <= K <= 10,000) times T\\_i (1 <= T\\_i <= 1,000,000,000), and he wants to know, for each T\\_i in the list, the maximum number of cows that can arrive at field 1 by T\\_i if scheduled to optimize this quantity.\n\nConsider an example where the tree is a straight line, and the T\\_i list contains only T\\_1=5, and cows are distibuted as shown:\n\n```cpp\nLocn:      1---2---3---4      <-- Pasture ID numbers \nC_i:       0   1   12  12     <-- Current number of cows \nM_i:           5   8   3      <-- Limits on path traversal; field 1 has no limit since it has no exit \nThe solution is as follows; the goal is to move cows to field 1: \n```\nTree:      1---2---3---4\n```cpp\nt=0        0   1   12  12     <-- Initial state \nt=1        5   4   7   9      <-- field 1 has cows from field 2 and 3 t=2        10  7   2   6 \nt=3        15  7   0   3 \nt=4        20  5   0   0 \nt=5        25  0   0   0 \nThus, the answer is 25: all 25 cows can arrive at field 1 by time t=5. \n", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..N: Line i (not i+1) describes field i with three \n\nspace-separated integers: P\\_i, C\\_i, and M\\_i\n\n\\* Lines N+1..N+K: Line N+i contains a single integer: T\\_i\n", "outputFormat": "\\* Lines 1..K: Line i contains a single integer that is the maximum number of cows that can arrive at field 1 by time T\\_i.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11JAN] Bottleneck G", "background": "", "description": "Farmer John is gathering the cows. His farm contains a network of N (1 <= N <= 100,000) fields conveniently numbered 1..N and connected by N-1 unidirectional paths that eventually lead to field 1. The fields and paths form a tree.\n\nEach field i > 1 has a single one-way, exiting path to field P\\_i, and currently contains C\\_i cows (1 <= C\\_i <= 1,000,000,000). In each time unit, no more than M\\_i (0 <= M\\_i <= 1,000,000,000) cows can travel from field i to field P\\_i (1 <= P\\_i <= N) (i.e., only M\\_i cows can traverse the path).\n\nFarmer John wants all the cows to congregate in field 1 (which has no limit on the number of cows it may have). Rules are as follows:\n\n\\* Time is considered in discrete units.\n\n\\* Any given cow might traverse multiple paths in the same time unit. However, no more than M\\_i total cows can leave field i (i.e., traverse its exit path) in the same time unit.\n\n\\* Cows never move \\*away\\* from field #1.\n\nIn other words, every time step, each cow has the choice either to\n\na) stay in its current field\n\nb) move through one or more fields toward field #1, as long as the bottleneck constraints for each path are not violated\n\nFarmer John wants to know how many cows can arrive in field 1 by certain times. In particular, he has a list of K (1 <= K <= 10,000) times T\\_i (1 <= T\\_i <= 1,000,000,000), and he wants to know, for each T\\_i in the list, the maximum number of cows that can arrive at field 1 by T\\_i if scheduled to optimize this quantity.\n\nConsider an example where the tree is a straight line, and the T\\_i list contains only T\\_1=5, and cows are distibuted as shown:\n\n```cpp\nLocn:      1---2---3---4      <-- Pasture ID numbers \nC_i:       0   1   12  12     <-- Current number of cows \nM_i:           5   8   3      <-- Limits on path traversal; field 1 has no limit since it has no exit \nThe solution is as follows; the goal is to move cows to field 1: \n```\nTree:      1---2---3---4\n```cpp\nt=0        0   1   12  12     <-- Initial state \nt=1        5   4   7   9      <-- field 1 has cows from field 2 and 3 t=2        10  7   2   6 \nt=3        15  7   0   3 \nt=4        20  5   0   0 \nt=5        25  0   0   0 \nThus, the answer is 25: all 25 cows can arrive at field 1 by time t=5. \n", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..N: Line i (not i+1) describes field i with three \n\nspace-separated integers: P\\_i, C\\_i, and M\\_i\n\n\\* Lines N+1..N+K: Line N+i contains a single integer: T\\_i\n", "outputFormat": "\\* Lines 1..K: Line i contains a single integer that is the maximum number of cows that can arrive at field 1 by time T\\_i.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11JAN] Bottleneck G", "background": null, "description": "Farmer John 正在聚集他的奶牛。他的农场包含了一个网络，这个网络由 $N(1\\le N\\le10^5)$ 块编号从 $1$ 到 $N$ 的田地构成，田地之间由 $N-1$ 条有向的路径连接，保证从每块田地出发都能到达 $1$ 号田地。这些田地和路径形成了一棵树的结构。\n\n每块满足编号大于 $1$ 的田地 $i$ 有一条有向路径连向 $P_i(1\\le P_i\\le N)$，同时这块田地上面有 $C_i(1\\le C_i\\le10^9)$ 头奶牛。在每个单位时间内，最多 $M_i(0\\le M_i\\le10^9)$ 头奶牛可以通过从 $i$ 连向 $P_i$ 的这条路径。\n\nFarmer John 想要让所有的奶牛集合到没有奶牛数量限制的田地 $1$ 上。但是这一过程要符合以下规则：\n\n- 时间是离散的。\n\n- 任何给定的奶牛在同一时间单位内都可能穿过多条路径。但在每个单位时间内，最多 $M_i(0\\le M_i\\le10^9)$ 头奶牛可以通过从 $i$ 连向 $P_i$ 的这条路径。\n\n- 奶牛不会从田地 $1$ 离开。\n\n换句话说，每一时刻，奶牛都必须从以下几项中选择一项：\n\n- 在它现在所在的田地里待着；\n\n- 沿着路径向着田地 $1$ 经过一块或多块田地，同时不能违反每条路径的 $M_i$ 的限制。\n\nFarmer John 想要知道在特定时间内有多少奶牛可以到达田地 $1$。具体的，他有一个包含了 $K(1\\le K\\le10^4)$ 个时间 $T_i(1\\le T_i\\le 10^9)$ 的列表，他想要知道，对于每一个列表中的 $T_i$，最多有多少头奶牛可以在 $T_i$ 时间内到达田地 $1$。", "inputFormat": "第一行：两个用空格分隔的整数：$N$ 和 $K$。\n\n第 $2$ 至 $N$ 行：第 $i$ 行用三个用空格分隔的整数描述了田地 $i$：$P_i$，$C_i$ 和 $M_i$。\n\n第 $N+1$ 至 $N+K$ 行：第 $N+i$ 行包含一个整数：$T_i$。", "outputFormat": "第 $1$ 至 $K$ 行：第 $i$ 行包含一个整数，表示可以在 $T_i$ 时间内到达田地 $1$ 的奶牛的数量的最大值。\n\ntranslated by 350558", "hint": "$1\\le P_i\\le N\\le10^5$，$1\\le C_i,T_i\\le10^9$，$0\\le M_i\\le10^9$，$1\\le K\\le10^4$。", "locale": "zh-CN"}}}
{"pid": "P3007", "type": "P", "difficulty": 5, "samples": [["3 4 \n1 Y 2 N \n1 N 2 N \n1 Y 3 Y \n1 Y 2 Y \n", "YN? \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO", "2-SAT"], "title": "[USACO11JAN] The Continental Cowngress G", "background": "", "description": "Displeased with Farmer John's leadership, the cows have seceded from the farm and have formed the first Continental Cowngress. Built on the principle of 'every cow gets something they want,' they've decided on the following voting system:\n\nThe M (1 <= M <= 4000) cows in attendance will vote on  N (1 <= N <= 1,000) legislative bills. Each cow casts a 'yes' or 'no' vote (denoted as 'Y' or 'N' in the input file) on exactly two (distinct) bills B\\_i and C\\_i (1 <= B\\_i <= N; 1 <= C\\_i <= N). The votes are called VB\\_i (VB\\_i in {'Y', 'N'}) and VC\\_i (VC\\_i in {'Y', 'N'}) respectively.\n\nFinally, the bills are to be passed or not in such a way that every cow gets her way on at least one of her votes. For example, if Bessie votes 'yes' on Bill 1, and 'no' on Bill 2, then in any valid solution, it must be the case that either Bill 1 gets passed or Bill 2 gets rejected (or both).\n\nGiven the votes of each of the cows, it's your job to figure out which bills will be passed and which bills will be rejected in order to conform to the rules above.  If there is no solution, print 'IMPOSSIBLE'. If there is at least one solution, then for each bill, display:\n\nY  if in every solution this bill passes\n\nN  if in every solution this bill fails\n\n?  if there are solutions where this bill passes and solutions where it does not pass\n\nConsider the following set of votes (two for each cow): \n```\n- - - - - BILL - - - - -\n\n1        2        3\n\nCow 1   YES      NO\n\nCow 2   NO       NO\n\nCow 3   YES               YES\n\nCow 4   YES      YES\n```\nFrom this, two solutions satisfy every cow:\n\n\\* Bill 1 passes (this then satisfies cows 1, 3, and 4) \n\n\\* Bill 2 fails (this then satisfies cow 2) \n\n\\* Bill 3 could pass or fail (and this is the reason there are two solutions) \n\nIn fact, these are the only two solutions, so the answer is the three character string below:\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Line i+1 describes cow i's votes with four\n\nspace-separated fields -- an integer, a vote, another integer, and another vote: B\\_i, VB\\_i, C\\_i, VC\\_i\n", "outputFormat": "\\* Line 1: A string with N characters, where the ith character is either a 'Y' if the ith bill must pass, an 'N' if the ith bill must fail, or a '?' if it cannot be determined whether the bill passes from these votes.\n\nIf there is no solution which satisfies every cow, then output the single line 'IMPOSSIBLE'.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11JAN] The Continental Cowngress G", "background": "", "description": "Displeased with Farmer John's leadership, the cows have seceded from the farm and have formed the first Continental Cowngress. Built on the principle of 'every cow gets something they want,' they've decided on the following voting system:\n\nThe M (1 <= M <= 4000) cows in attendance will vote on  N (1 <= N <= 1,000) legislative bills. Each cow casts a 'yes' or 'no' vote (denoted as 'Y' or 'N' in the input file) on exactly two (distinct) bills B\\_i and C\\_i (1 <= B\\_i <= N; 1 <= C\\_i <= N). The votes are called VB\\_i (VB\\_i in {'Y', 'N'}) and VC\\_i (VC\\_i in {'Y', 'N'}) respectively.\n\nFinally, the bills are to be passed or not in such a way that every cow gets her way on at least one of her votes. For example, if Bessie votes 'yes' on Bill 1, and 'no' on Bill 2, then in any valid solution, it must be the case that either Bill 1 gets passed or Bill 2 gets rejected (or both).\n\nGiven the votes of each of the cows, it's your job to figure out which bills will be passed and which bills will be rejected in order to conform to the rules above.  If there is no solution, print 'IMPOSSIBLE'. If there is at least one solution, then for each bill, display:\n\nY  if in every solution this bill passes\n\nN  if in every solution this bill fails\n\n?  if there are solutions where this bill passes and solutions where it does not pass\n\nConsider the following set of votes (two for each cow): \n```\n- - - - - BILL - - - - -\n\n1        2        3\n\nCow 1   YES      NO\n\nCow 2   NO       NO\n\nCow 3   YES               YES\n\nCow 4   YES      YES\n```\nFrom this, two solutions satisfy every cow:\n\n\\* Bill 1 passes (this then satisfies cows 1, 3, and 4) \n\n\\* Bill 2 fails (this then satisfies cow 2) \n\n\\* Bill 3 could pass or fail (and this is the reason there are two solutions) \n\nIn fact, these are the only two solutions, so the answer is the three character string below:\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Line i+1 describes cow i's votes with four\n\nspace-separated fields -- an integer, a vote, another integer, and another vote: B\\_i, VB\\_i, C\\_i, VC\\_i\n", "outputFormat": "\\* Line 1: A string with N characters, where the ith character is either a 'Y' if the ith bill must pass, an 'N' if the ith bill must fail, or a '?' if it cannot be determined whether the bill passes from these votes.\n\nIf there is no solution which satisfies every cow, then output the single line 'IMPOSSIBLE'.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11JAN] The Continental Cowngress G", "background": null, "description": "由于对农场主约翰的领导不满，奶牛们已经从农场中分离出来，并成立了第一个大陆奶牛议会。基于「每头奶牛都能得到她想要的东西」这一原则，她们决定采用以下投票系统：\n\n出席的 $M$ 头奶牛将对 $N$ 项立法议案进行投票。每头奶牛对两个（不同的）议案 $B_i$ 和 $C_i$ 分别投下「赞成」或「反对」票（在输入文件中用 `Y` 或 `N` 表示）。这些投票分别称为 $VB_i$ 和 $VC_i$。\n\n最终，议案的通过与否必须满足每头奶牛至少有一个投票结果符合她的意愿。例如，如果 Bessie 对议案 $1$ 投了「赞成」票，对议案 $2$ 投了「反对」票，那么在任何有效的解决方案中，要么议案 $1$ 通过，要么议案 $2$ 被否决（或者两者都满足）。\n\n给定每头奶牛的投票情况，你的任务是找出哪些议案将被通过，哪些议案将被否决，以符合上述规则。如果没有解决方案，请输出 `IMPOSSIBLE`。如果至少有一个解决方案，那么对于每个议案，显示：\n\n`Y` 如果在每个解决方案中该议案都通过\n\n`N` 如果在每个解决方案中该议案都被否决\n\n`?` 如果存在一些解决方案中该议案通过，而在另一些解决方案中该议案没有通过\n\n考虑以下投票集（每头奶牛投两票）：  \n\n|编号|$1$|$2$|$3$|\n|:-:|:-:|:-:|:-:\n|奶牛 $1$|赞成|反对\n|奶牛 $2$|反对|反对\n|奶牛 $3$|赞成||赞成\n|奶牛 $4$|赞成|赞成\n\n由此，两个解决方案满足每头奶牛：\n\n+ 议案 $1$ 通过（这满足了奶牛 $1$、$3$ 和 $4$）\n+ 议案 $2$ 被否决（这满足了奶牛 $2$）\n+ 议案 $3$ 可以通过或被否决（这就是有两个解决方案的原因）\n\n事实上，这些是仅有的两个解决方案，因此答案是 `YN?`。", "inputFormat": "第 $1$ 行：两个用空格分隔的整数：$N$ 和 $M$\n\n第 $2$ 行到第 $M+1$ 行：第 $i+1$ 行描述奶牛 $i$ 的投票情况，包含四个用空格分隔的字段——一个整数，一个投票，另一个整数，和另一个投票：$B_i,VB_i,C_i,VC_i$", "outputFormat": "第 $1$ 行：一个包含 $N$ 个字符的字符串，其中第 $i$ 个字符是 `Y` 表示第 $i$ 个议案必须通过，`N` 表示第 $i$ 个议案必须被否决，或者 `?` 表示无法从这些投票中确定该议案是否通过。\n\n如果没有满足每头奶牛的解决方案，则输出单行 `IMPOSSIBLE`。", "hint": "对于 $100\\%$ 的数据，$1\\le M\\le4000$，$1\\le N\\le1000$，$1\\le B_i,C_i\\le N$，$VB_i,VC_i\\in\\{Y,N\\}$。  \n（本题由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3008", "type": "P", "difficulty": 5, "samples": [["6 3 3 4 \n1 2 5 \n3 4 5 \n5 6 10 \n3 5 -100 \n4 6 -100 \n1 3 -10 \n", "NO PATH \nNO PATH \n5 \n0 \n-95 \n-100 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO", "拓扑排序", "最短路"], "title": "[USACO11JAN] Roads and Planes G", "background": "", "description": "Farmer John is conducting research for a new milk contract in a new territory. He intends to distribute milk to T (1 <= T <= 25,000) towns conveniently numbered 1..T which are connected by up to R (1 <= R <= 50,000) roads conveniently numbered 1..R and/or P (1 <= P <= 50,000) airplane flights conveniently numbered 1..P.\n\nEither road i or plane i connects town A\\_i (1 <= A\\_i <= T) to town B\\_i (1 <= B\\_i <= T) with traversal cost C\\_i. For roads, 0 <= C\\_i <= 10,000; however, due to the strange finances of the airlines, the cost for planes can be quite negative (-10,000 <= C\\_i <= 10,000).\n\nRoads are bidirectional and can be traversed from A\\_i to B\\_i or B\\_i to A\\_i for the same cost; the cost of a road must be non-negative.\n\nPlanes, however, can only be used in the direction from A\\_i to B\\_i specified in the input. In fact, if there is a plane from A\\_i to B\\_i it is guaranteed that there is no way to return from B\\_i to A\\_i with any sequence of roads and planes due to recent antiterror regulation.\n\nFarmer John is known around the world as the source of the world's finest dairy cows. He has in fact received orders for his cows from every single town. He therefore wants to find the cheapest price for delivery to each town from his distribution center in town S (1 <= S <= T) or to know that it is not possible if this is the case.\n\nMEMORY LIMIT: 64MB", "inputFormat": "\\* Line 1: Four space separated integers: T, R, P, and S\n\n\\* Lines 2..R+1: Three space separated integers describing a road: A\\_i, B\\_i and C\\_i\n\n\\* Lines R+2..R+P+1: Three space separated integers describing a plane: A\\_i, B\\_i and C\\_i\n", "outputFormat": "\\* Lines 1..T: The minimum cost to get from town S to town i, or 'NO PATH' if this is not possible\n", "hint": "6 towns.  There are roads between town 1 and town 2, town 3 and town 4, and town 5 and town 6 with costs 5, 5 and 10; there are planes from town 3 to town 5, from town 4 to town 6, and from town 1 to town 3 with costs -100, - 100 and -10.  FJ is based in town 4.\n\n\nFJ's cows begin at town 4, and can get to town 3 on the road.  They can get to towns 5 and 6 using planes from towns 3 and 4.  However, there is no way to get to towns 1 and 2, since they cannot go\n\nbackwards on the plane from 1 to 3.\n", "locale": "en", "translations": {"en": {"title": "[USACO11JAN] Roads and Planes G", "background": "", "description": "Farmer John is conducting research for a new milk contract in a new territory. He intends to distribute milk to T (1 <= T <= 25,000) towns conveniently numbered 1..T which are connected by up to R (1 <= R <= 50,000) roads conveniently numbered 1..R and/or P (1 <= P <= 50,000) airplane flights conveniently numbered 1..P.\n\nEither road i or plane i connects town A\\_i (1 <= A\\_i <= T) to town B\\_i (1 <= B\\_i <= T) with traversal cost C\\_i. For roads, 0 <= C\\_i <= 10,000; however, due to the strange finances of the airlines, the cost for planes can be quite negative (-10,000 <= C\\_i <= 10,000).\n\nRoads are bidirectional and can be traversed from A\\_i to B\\_i or B\\_i to A\\_i for the same cost; the cost of a road must be non-negative.\n\nPlanes, however, can only be used in the direction from A\\_i to B\\_i specified in the input. In fact, if there is a plane from A\\_i to B\\_i it is guaranteed that there is no way to return from B\\_i to A\\_i with any sequence of roads and planes due to recent antiterror regulation.\n\nFarmer John is known around the world as the source of the world's finest dairy cows. He has in fact received orders for his cows from every single town. He therefore wants to find the cheapest price for delivery to each town from his distribution center in town S (1 <= S <= T) or to know that it is not possible if this is the case.\n\nMEMORY LIMIT: 64MB", "inputFormat": "\\* Line 1: Four space separated integers: T, R, P, and S\n\n\\* Lines 2..R+1: Three space separated integers describing a road: A\\_i, B\\_i and C\\_i\n\n\\* Lines R+2..R+P+1: Three space separated integers describing a plane: A\\_i, B\\_i and C\\_i\n", "outputFormat": "\\* Lines 1..T: The minimum cost to get from town S to town i, or 'NO PATH' if this is not possible\n", "hint": "6 towns.  There are roads between town 1 and town 2, town 3 and town 4, and town 5 and town 6 with costs 5, 5 and 10; there are planes from town 3 to town 5, from town 4 to town 6, and from town 1 to town 3 with costs -100, - 100 and -10.  FJ is based in town 4.\n\n\nFJ's cows begin at town 4, and can get to town 3 on the road.  They can get to towns 5 and 6 using planes from towns 3 and 4.  However, there is no way to get to towns 1 and 2, since they cannot go\n\nbackwards on the plane from 1 to 3.\n", "locale": "en"}, "zh-CN": {"title": "[USACO11JAN] Roads and Planes G", "background": null, "description": "Farmer John 正在一个新的销售区域对他的牛奶销售方案进行调查。他想把牛奶送到 $T$ 个城镇（$1 \\le T \\le 25,000$），编号为 $1$ 到 $T$。这些城镇之间通过 $R$ 条道路（$1 \\le R \\le 50,000$，编号为 $1$ 到 $R$）和 $P$ 条航线（$1 \\le P \\le 50,000$，编号为 $1$ 到 $P$）连接。每条道路 $i$ 或者航线 $i$ 连接城镇 $A_i$（$1 \\le A_i \\le T$）到 $B_i$（$1 \\le B_i \\le T$），花费为 $C_i$。\n\n对于道路 $0 \\le C_i \\le 10,000$；然而航线的花费很神奇，花费 $C_i$ 可能是负数（$-10,000 \\le C_i \\le 10,000$）。道路是双向的，可以从 $A_i$ 到 $B_i$，也可以从 $B_i$ 到 $A_i$，花费都是 $C_i$。然而航线与之不同，只可以从 $A_i$ 到 $B_i$。\n\n事实上，由于最近恐怖主义太嚣张，为了社会和谐，出台了一些政策保证：如果有一条航线可以从 $A_i$ 到 $B_i$，那么保证不可能通过一些道路和航线从 $B_i$ 回到 $A_i$。由于 FJ 的奶牛世界公认十分给力，他需要运送奶牛到每一个城镇。他想找到从发送中心城镇 $S$（$1 \\le S \\le T$）把奶牛送到每个城镇的最便宜的方案，或者知道这是不可能的。", "inputFormat": "共 $R+P+1$ 行。\n\n第 $1$ 行：四个整数 $T,R,P$ 和 $S$，分别表示城镇的数量，道路的数量，航线的数量和中心城镇。\n\n第 $2$ 到 $R+1$ 行：每行三个整数 $A_i,B_i$ 和 $C_i$，描述一条道路。\n\n第 $R+2$ 到 $R+P+1$ 行：每行三个整数 $A_i,B_i$ 和 $C_i$，描述一条航线。", "outputFormat": "共 $T$ 行，第 $i$ 行输出城市 $S$ 到城市 $i$ 的最小花费。如果不能到达，输出 `NO PATH`。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3009", "type": "P", "difficulty": 2, "samples": [["7 \n-3 \n4 \n9 \n-2 \n-5 \n8 \n-3 \n", "14 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2011", "USACO"], "title": "[USACO11JAN] Profits S", "background": null, "description": "奶牛们开始了新的生意，它们的主人约翰想知道它们到底能做得多好。这笔生意已经做了 $N(1\\le N\\le 10^5)$ 天，每天奶牛们都会记录下这一天的利润 $P\n_i(\\vert Pi\\vert ≤1,000)$。\n\n约翰想要找到奶牛们在连续的时间期间所获得的最大的总利润。（注：连续时间的周期长度范围从第一天到第 $N$ 天）。\n\n请你写一个计算最大利润的程序来帮助他。", "inputFormat": "第一行，一个单独的整数 $N$。\n\n接下来 $N$ 行，第 $i+1$ 行包括一个单独的整数 $P_i$。", "outputFormat": "一行，一个整数，表示任意连续时间段利润最大和的数值。", "hint": "**【样例解释】**\n\n取区间 $[2,6]$ 的和可以得到最大值 $14$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO11JAN] Profits S", "background": null, "description": "The cows have opened a new business, and Farmer John wants to see how well they are doing. The business has been running for $N (1 \\leq N \\leq 10^5)$ days, and every day i the cows recorded their net profit $P_i (-1,000\\leq P_i \\leq 1,000)$.\n\nFarmer John wants to find the largest total profit that the cows have made during any consecutive time period. (Note that a consecutive time period can range in length from one day through $N$ days.) Help him by writing a program to calculate the largest sum of consecutive profits.", "inputFormat": "- Line $1$: A single integer: $N$.\n\n- Lines $2\\dots N+1$: Line $i+1$ contains a single integer: $P_i$.", "outputFormat": "- Line $1$: A single integer representing the value of the maximum sum of profits for any consecutive time period.", "hint": "The maximum sum is obtained by taking the sum from the second through the sixth number $(4, 9, -2, -5, 8) \\geq 14$.", "locale": "en"}, "zh-CN": {"title": "[USACO11JAN] Profits S", "background": null, "description": "奶牛们开始了新的生意，它们的主人约翰想知道它们到底能做得多好。这笔生意已经做了 $N(1\\le N\\le 10^5)$ 天，每天奶牛们都会记录下这一天的利润 $P\n_i(\\vert Pi\\vert ≤1,000)$。\n\n约翰想要找到奶牛们在连续的时间期间所获得的最大的总利润。（注：连续时间的周期长度范围从第一天到第 $N$ 天）。\n\n请你写一个计算最大利润的程序来帮助他。", "inputFormat": "第一行，一个单独的整数 $N$。\n\n接下来 $N$ 行，第 $i+1$ 行包括一个单独的整数 $P_i$。", "outputFormat": "一行，一个整数，表示任意连续时间段利润最大和的数值。", "hint": "**【样例解释】**\n\n取区间 $[2,6]$ 的和可以得到最大值 $14$。", "locale": "zh-CN"}}}
{"pid": "P3010", "type": "P", "difficulty": 4, "samples": [["5 \n2 \n1 \n8 \n4 \n16 \n", "1 \n1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11JAN] Dividing the Gold S", "background": "", "description": "Bessie and Canmuu found a sack of N (1 <= N <= 250) gold coins that they wish to divide as evenly as possible. Coin i has value v\\_i (1 <= V\\_i <= 2,000). The cows would like to split the pile as evenly as they can, but that is not always possible. What is the smallest difference between the values of the two piles?\n\nIn addition, the Bessie and Canmuu have found that there might be multiple ways to split the piles with that minimum difference. They would also like to know the number of ways to split the coins as fairly as possible. If it isn't possible to split the piles evenly, Bessie will get the higher-valued pile.\n\nBy way of example, consider a sack of five coins of values: 2, 1, 8, 4, and 16. Bessie and Canmuu split the coins into two piles, one pile with one coin worth 16, and the other pile with the remaining coins worth 1+2+4+8=15. Therefore the difference is 16-15 = 1.  This is the only way for them to split the coins this way, so the number of ways to split it evenly is just 1.\n\nNote that same-valued coins can be switched among the piles to increase the number of ways to perform an optimal split. Thus, the set of coins {1, 1, 1, 1} has six different ways to split into two optimal partitions, each with two coins.", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: V\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the smallest difference of two partitions.\n\n\\* Line 2: A single integer that is the number of ways to split the coins with the minimum difference printed in line 1. Since this number can get quite large, print the remainder when divided by 1,000,000.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11JAN] Dividing the Gold S", "background": "", "description": "Bessie and Canmuu found a sack of N (1 <= N <= 250) gold coins that they wish to divide as evenly as possible. Coin i has value v\\_i (1 <= V\\_i <= 2,000). The cows would like to split the pile as evenly as they can, but that is not always possible. What is the smallest difference between the values of the two piles?\n\nIn addition, the Bessie and Canmuu have found that there might be multiple ways to split the piles with that minimum difference. They would also like to know the number of ways to split the coins as fairly as possible. If it isn't possible to split the piles evenly, Bessie will get the higher-valued pile.\n\nBy way of example, consider a sack of five coins of values: 2, 1, 8, 4, and 16. Bessie and Canmuu split the coins into two piles, one pile with one coin worth 16, and the other pile with the remaining coins worth 1+2+4+8=15. Therefore the difference is 16-15 = 1.  This is the only way for them to split the coins this way, so the number of ways to split it evenly is just 1.\n\nNote that same-valued coins can be switched among the piles to increase the number of ways to perform an optimal split. Thus, the set of coins {1, 1, 1, 1} has six different ways to split into two optimal partitions, each with two coins.", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: V\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the smallest difference of two partitions.\n\n\\* Line 2: A single integer that is the number of ways to split the coins with the minimum difference printed in line 1. Since this number can get quite large, print the remainder when divided by 1,000,000.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11JAN] Dividing the Gold S", "background": null, "description": "Bessie 和 Canmuu 找到了一袋 $N (1 \\leq N \\leq 250)$ 枚金币，他们希望尽可能均匀地分配这些金币。第 $i$ 枚金币的价值为 $v_i (1 \\leq v_i \\leq 2,000)$。奶牛们希望尽可能均匀地分割这堆金币，但这并不总是可能的。两个堆之间的最小价值差是多少？\n\n此外，Bessie 和 Canmuu 发现可能有多种方法以该最小差异分割金币。他们还想知道以最公平方式分割金币的方法数。如果无法均匀分割，Bessie 将得到价值较高的一堆。\n\n例如，考虑一袋五枚金币，价值分别为：$2、1、8、4$ 和 $16$。Bessie 和 Canmuu 将金币分成两堆，一堆有一枚价值为 16 的金币，另一堆有剩下的金币，价值为 $1+2+4+8=15$。因此，差异为 $16-15 = 1$。这是他们以这种方式分割金币的唯一方法，所以均匀分割的方法数只有 $1$。\n\n注意，相同价值的金币可以在堆之间交换，以增加执行最佳分割的方法数。因此，硬币集合 $\\{1, 1, 1, 1\\}$ 有六种不同的方法分割成两个最佳分区，每个分区有两枚硬币。", "inputFormat": "第 1 行：一个整数：$N$。\n\n第 2 行到第 $N+1$ 行：第 $i+1$ 行包含一个整数：$V_i$。", "outputFormat": "第 1 行：一个整数，表示两个分区的最小差异。\n\n第 2 行：一个整数，表示以第 1 行打印的最小差异分割金币的方法数。由于这个数可能会非常大，输出时请对 $1,000,000$ 取余。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3011", "type": "P", "difficulty": 6, "samples": [["1 4 \n4 5 \nB 2 16 99 \nP 6 32 13 \nP 2 87 4 \nP 38 96 49 \n1 2 4 \n1 3 40 \n2 3 75 \n2 4 76 \n3 4 77 \n", "127 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11JAN] Traffic Lights S", "background": "征求翻译。如果你能提供翻译或者题意简述，请直接发讨论，感谢你的贡献。\n", "description": "Kenosha, the city nearest Farmer John, has M (1 <= M <= 14,000) roads conveniently numbered 1..M that connect N (2 <= N <= 300) junctions which are conveniently numbered 1..N. No two roads connect the same pair of junctions. No road connects a junction to itself. The integer travel time T\\_ij (1 <= T\\_ij <= 100) between junctions i and j is the same for both directions (i.e., T\\_ij = T\\_ji).\n\nEach junction has a single traffic light with two colors: blue or purple. The color of each light alternates periodically: blue for certain duration and then purple for another duration.  Traffic is permitted to commence travel down the road between any two junctions, if and only if the lights at both junctions are the same color at the moment of departing from one junction for the other.  The lights do not necessarily have to be the same on the whole trip down the road.\n\nIf a vehicle arrives at a junction just at the moment the lights switch it must consider the new colors of lights. Vehicles are allowed to wait at the junctions. You are given the city map which shows:\n\n```cpp\n                                    Init  Remg  Blue   Purple\n       4       76         Junction  Color Time  Cycle  Cycle\n>>[1B]===[2P]======          1        B    2     16      99\n    |   /          \\         2        P    6     32      13\n  40|  /75          \\        3        P    2     87       4\n    | /              \\       4        P   38     96      49\n  [3P]===============[4P]>>\n           77\n```\n```cpp\n* The travel times T_ij for all roads \n* The durations of the two colors at junction i. (DB_i (1 <= DB_i <= 100) for the blue light and DP_i (1 <= DP_i <= 100) for the purple light) \n* The initial color C_i of the light at junction i (a letter 'B' or 'P' with the obvious meaning) and the remaining time R_i (1 <= R_i <= 100) for this color to change \nFind the minimum time one needs to get from a given source S (1 <= S <= N) to a given destination D (1 <= D <= N; D != S). \nConsider the map below with four junctions and five roads. FJ wants to travel from junction 1 to junction 4. The first light is blue; the rest are purple. \n```\nThe minimum time is 127 utilizing the path 1-2-4.\nInitially, the light at junction 1 is blue. Since the light at junction 2 is purple, vehicle waits at junction 1 for 2 seconds then travels 4 seconds to junction 2.\n\nAt time 6, the light at junction 2 switches to blue whereas the light at junction 4 has 32 more seconds to switch to blue. However, after 32 seconds, the light at junction 2 switches to purple and the light at junction 4 switches to blue at the same time. So the vehicle needs to wait 13 seconds more for junction 2 to switch to blue then the lights have the same color and vehicle travels 76 seconds to the destination junction 4.\n\nThe total time is 2+4+32+13+76=127 seconds. \n\nBelow is a more graphical presentation of this travel plan:\n\n```cpp\n                                                                                                      1    1    1    1    1    1\n             1    1    2    2    3    3    4    4    5    5    6    6    7    7    8    8    9    9    0    0    1    1    2    2\n   0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5..\n   --------------------------------------------------------------------------------------------------------------------------------\nJ1 BBBPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPBBBBBBBBBBBBBBBBPPPPPPPPPP\nJ2 PPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBPPPPPPPPPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBPPPPPPPPPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nJ3 PPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nJ4 PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nFJ 1..>>>2............................................>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>4\n```", "inputFormat": "\\* Line 1: Two space-separated integers: S and D\n\n\\* Line 2: Two space-separated integers: N and M\n\n\\* Lines 3..N+2: Line i+2 line describes junction i with a character and three integers (all separated by a single space): C\\_i, R\\_i, DB\\_i, and DP\\_i\n\n\\* Lines N+3..N+M+2: Line N+2+k describes road k with three integers: i, j, and T\\_ij\n", "outputFormat": "\\* Line 1: One integer: the time taken by a minimum-time path from the source junction to the destination junction. If there is no path, output 0.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11JAN] Traffic Lights S", "background": "征求翻译。如果你能提供翻译或者题意简述，请直接发讨论，感谢你的贡献。\n", "description": "Kenosha, the city nearest Farmer John, has M (1 <= M <= 14,000) roads conveniently numbered 1..M that connect N (2 <= N <= 300) junctions which are conveniently numbered 1..N. No two roads connect the same pair of junctions. No road connects a junction to itself. The integer travel time T\\_ij (1 <= T\\_ij <= 100) between junctions i and j is the same for both directions (i.e., T\\_ij = T\\_ji).\n\nEach junction has a single traffic light with two colors: blue or purple. The color of each light alternates periodically: blue for certain duration and then purple for another duration.  Traffic is permitted to commence travel down the road between any two junctions, if and only if the lights at both junctions are the same color at the moment of departing from one junction for the other.  The lights do not necessarily have to be the same on the whole trip down the road.\n\nIf a vehicle arrives at a junction just at the moment the lights switch it must consider the new colors of lights. Vehicles are allowed to wait at the junctions. You are given the city map which shows:\n\n```cpp\n                                    Init  Remg  Blue   Purple\n       4       76         Junction  Color Time  Cycle  Cycle\n>>[1B]===[2P]======          1        B    2     16      99\n    |   /          \\         2        P    6     32      13\n  40|  /75          \\        3        P    2     87       4\n    | /              \\       4        P   38     96      49\n  [3P]===============[4P]>>\n           77\n```\n```cpp\n* The travel times T_ij for all roads \n* The durations of the two colors at junction i. (DB_i (1 <= DB_i <= 100) for the blue light and DP_i (1 <= DP_i <= 100) for the purple light) \n* The initial color C_i of the light at junction i (a letter 'B' or 'P' with the obvious meaning) and the remaining time R_i (1 <= R_i <= 100) for this color to change \nFind the minimum time one needs to get from a given source S (1 <= S <= N) to a given destination D (1 <= D <= N; D != S). \nConsider the map below with four junctions and five roads. FJ wants to travel from junction 1 to junction 4. The first light is blue; the rest are purple. \n```\nThe minimum time is 127 utilizing the path 1-2-4.\nInitially, the light at junction 1 is blue. Since the light at junction 2 is purple, vehicle waits at junction 1 for 2 seconds then travels 4 seconds to junction 2.\n\nAt time 6, the light at junction 2 switches to blue whereas the light at junction 4 has 32 more seconds to switch to blue. However, after 32 seconds, the light at junction 2 switches to purple and the light at junction 4 switches to blue at the same time. So the vehicle needs to wait 13 seconds more for junction 2 to switch to blue then the lights have the same color and vehicle travels 76 seconds to the destination junction 4.\n\nThe total time is 2+4+32+13+76=127 seconds. \n\nBelow is a more graphical presentation of this travel plan:\n\n```cpp\n                                                                                                      1    1    1    1    1    1\n             1    1    2    2    3    3    4    4    5    5    6    6    7    7    8    8    9    9    0    0    1    1    2    2\n   0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5..\n   --------------------------------------------------------------------------------------------------------------------------------\nJ1 BBBPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPBBBBBBBBBBBBBBBBPPPPPPPPPP\nJ2 PPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBPPPPPPPPPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBPPPPPPPPPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nJ3 PPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nJ4 PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nFJ 1..>>>2............................................>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>4\n```", "inputFormat": "\\* Line 1: Two space-separated integers: S and D\n\n\\* Line 2: Two space-separated integers: N and M\n\n\\* Lines 3..N+2: Line i+2 line describes junction i with a character and three integers (all separated by a single space): C\\_i, R\\_i, DB\\_i, and DP\\_i\n\n\\* Lines N+3..N+M+2: Line N+2+k describes road k with three integers: i, j, and T\\_ij\n", "outputFormat": "\\* Line 1: One integer: the time taken by a minimum-time path from the source junction to the destination junction. If there is no path, output 0.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11JAN] Traffic Lights S", "background": null, "description": "和FJ靠的最近的城市Kenosha市有 $M$ 条道路。(编号为 $1-M$) 连接着 $N$ 个路口 (编号为 $1-N$) 。保证没有重边和自环。 \n\n从点 $i$ 到点 $j$ 需要的时间是 $T_{i,j}$， 且保证 $T_{i,j}$ = $T_{j,i}$\n\n每个路口有一个交通灯，有两种颜色：蓝色和紫色。两个颜色周期性的交替。蓝色持续一定时间，然后紫色持续一定时间。\n\n想要从 $i$ 到 $j$ 只有在 $i$ 和 $j$ 的信号灯颜色相同的时候才可以走(从 T1 时刻离开 $i$ 走向 $j$，只需 T1 时刻 $i$ 与 $j$ 的颜色相同即可，无其他任何约束。)\n\n如果在变幻灯的那一秒到 $j$，考虑的是变幻后的颜色。\n给你所有第 $i$ 个路口的蓝色灯持续时间 $DB_i$ 和紫色灯持续时间 $DP_i$ 和每个路口刚开始灯的颜色 $C_i$,剩余持续时间 $R_i$。\n\n求一个给定的原点 $S$ 到给定目标点 $D$ 的最小时间。", "inputFormat": "* 第 1 行两个整数 $S$ 和 $D$。\n * 第 2 行两个整数 $N$ 和 $M$。\n * 第 3 至 $N+2$ 行。第 $i+2$ 行描述点 $i$ 的信号灯情况 $C_i$，$R_i$，$DB_i$，$DP_i$。\n * 第 $N+3$ 至 $N+M+2$ 行：第 $N+2+k$ 行描述第 $k$ 条道路 : $i$，$j$，$T_{i,j}$。", "outputFormat": "* 一个整数代表从 $S$ 到 $D$ 最少消耗的时间， 如果 $S$、$D$ 不连通，输出 0。\n\n感谢@ToBiChi 提供翻译", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3012", "type": "P", "difficulty": 4, "samples": [["2 2 7 \nAB \nab \nBA \nba \nAa \nBb \nbB \n", "7 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11FEB] Cowlphabet G", "background": null, "description": "Like all bovines, Farmer John's cows speak the peculiar 'Cow'\n\nlanguage. Like so many languages, each word in this language comprises a sequence of upper and lowercase letters (A-Z and a-z).  A word is valid if and only if each ordered pair of adjacent letters in the word is a valid pair.\n\nFarmer John, ever worried that his cows are plotting against him, recently tried to eavesdrop on their conversation. He overheard one word before the cows noticed his presence. The Cow language is spoken so quickly, and its sounds are so strange, that all that Farmer John was able to perceive was the total number of uppercase letters, $U$ ($1 \\leq U \\leq 250$) and the total number of lowercase letters, $L$ ($1 \\leq L \\leq 250$) in the word. \n\nFarmer John knows all $P$ ($1 \\leq P \\leq 200$) valid ordered pairs of adjacent letters.  He wishes to know how many different valid words are consistent with his limited data.  However, since this number may be very large, he only needs the value modulo $97654321$.\n\n约翰家的奶牛用别人听不懂的“牛语”联络。牛语采用英文字母，而且区分大小写。牛语中的语法中，前后字母的衔接非常重要，存在 $P$ 个基本组合，每个字母之后只能接固定的几个字母。约翰担心奶牛正在密谋反对他，于是最近一直在偷听她们的对话。可是牛语太复杂了，他只模模糊糊地听到了一个单词，并确定了这个单词中有 $U$（$1 \\leq U \\leq 250$）个大写字母，$L$（$1 \\leq L \\leq 250$）个小写字母。约翰对这个单词很在意，他想知道，有多少牛语词汇拥有 $U$ 个大写字母，$L$ 个小写字母。由于这个数字太大了，你只要输出答案取 $97654321$ 的余数就可以了。", "inputFormat": "- Line 1: Three space-separated integers: U, L and P.\n\n - 第一行：三个用空格分开的整数 $U$，$L$ 和 $P$。\n\n - Lines 2..P+1: Two letters (each of which may be uppercase or lowercase), representing one valid ordered pair of adjacent letters in Cow.\n\n - 第二至 $P+1$ 行：两个字母 $A_i$ 和 $B_i$，表示字母 $A_i$ 后面可以接 $B_i$，没有一对 $A_i$ 和 $B_i$ 是完全相同的。", "outputFormat": "- Line 1: A single integer, the number of valid words consistent with Farmer John's data mod $97654321$.\n\n - 第一行：单独一个整数，与 FJ 的数据吻合的单词数模 $97654321$ 的值。", "hint": "The word Farmer John overheard had 2 uppercase and 2 lowercase letters.  The valid pairs of adjacent letters are AB, ab, BA, ba, Aa, Bb and bB.\n\n\nThe possible words are:\n\nAabB\nABba\nabBA\nBAab\nBbBb\nbBAa\nbBbB", "locale": "zh-CN", "translations": {"en": {"title": "[USACO11FEB] Cowlphabet G", "background": "", "description": "Like all bovines, Farmer John's cows speak the peculiar \"Cow\" language. As in many languages, each word in this language is a sequence of uppercase and lowercase letters (A-Z and a-z). A word is valid if and only if each ordered pair of adjacent letters in the word is a valid pair.\n\nFarmer John, ever worried that his cows are plotting against him, recently tried to eavesdrop on their conversation. He overheard one word before the cows noticed his presence. The Cow language is spoken so quickly, and its sounds are so strange, that all Farmer John was able to perceive was the total number of uppercase letters, $U$ ($1 \\leq U \\leq 250$), and the total number of lowercase letters, $L$ ($1 \\leq L \\leq 250$), in the word.\n\nFarmer John knows all $P$ ($1 \\leq P \\leq 200$) valid ordered pairs of adjacent letters. He wishes to know how many different valid words are consistent with his limited data. However, since this number may be very large, he only needs the value modulo $97654321$.", "inputFormat": "- Line 1: Three space-separated integers: $U$, $L$, and $P$.\n- Lines 2 to $P+1$: Two letters $A_i$ and $B_i$ (each of which may be uppercase or lowercase), representing one valid ordered pair of adjacent letters in Cow, meaning $A_i$ can be followed by $B_i$. No ordered pair appears more than once.", "outputFormat": "- Line 1: A single integer, the number of valid words consistent with Farmer John's data, modulo $97654321$.", "hint": "The word Farmer John overheard had 2 uppercase and 2 lowercase letters. The valid pairs of adjacent letters are AB, ab, BA, ba, Aa, Bb and bB.\n\nThe possible words are:\nAabB\nABba\nabBA\nBAab\nBbBb\nbBAa\nbBbB\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO11FEB] Cowlphabet G", "background": null, "description": "Like all bovines, Farmer John's cows speak the peculiar 'Cow'\n\nlanguage. Like so many languages, each word in this language comprises a sequence of upper and lowercase letters (A-Z and a-z).  A word is valid if and only if each ordered pair of adjacent letters in the word is a valid pair.\n\nFarmer John, ever worried that his cows are plotting against him, recently tried to eavesdrop on their conversation. He overheard one word before the cows noticed his presence. The Cow language is spoken so quickly, and its sounds are so strange, that all that Farmer John was able to perceive was the total number of uppercase letters, $U$ ($1 \\leq U \\leq 250$) and the total number of lowercase letters, $L$ ($1 \\leq L \\leq 250$) in the word. \n\nFarmer John knows all $P$ ($1 \\leq P \\leq 200$) valid ordered pairs of adjacent letters.  He wishes to know how many different valid words are consistent with his limited data.  However, since this number may be very large, he only needs the value modulo $97654321$.\n\n约翰家的奶牛用别人听不懂的“牛语”联络。牛语采用英文字母，而且区分大小写。牛语中的语法中，前后字母的衔接非常重要，存在 $P$ 个基本组合，每个字母之后只能接固定的几个字母。约翰担心奶牛正在密谋反对他，于是最近一直在偷听她们的对话。可是牛语太复杂了，他只模模糊糊地听到了一个单词，并确定了这个单词中有 $U$（$1 \\leq U \\leq 250$）个大写字母，$L$（$1 \\leq L \\leq 250$）个小写字母。约翰对这个单词很在意，他想知道，有多少牛语词汇拥有 $U$ 个大写字母，$L$ 个小写字母。由于这个数字太大了，你只要输出答案取 $97654321$ 的余数就可以了。", "inputFormat": "- Line 1: Three space-separated integers: U, L and P.\n\n - 第一行：三个用空格分开的整数 $U$，$L$ 和 $P$。\n\n - Lines 2..P+1: Two letters (each of which may be uppercase or lowercase), representing one valid ordered pair of adjacent letters in Cow.\n\n - 第二至 $P+1$ 行：两个字母 $A_i$ 和 $B_i$，表示字母 $A_i$ 后面可以接 $B_i$，没有一对 $A_i$ 和 $B_i$ 是完全相同的。", "outputFormat": "- Line 1: A single integer, the number of valid words consistent with Farmer John's data mod $97654321$.\n\n - 第一行：单独一个整数，与 FJ 的数据吻合的单词数模 $97654321$ 的值。", "hint": "The word Farmer John overheard had 2 uppercase and 2 lowercase letters.  The valid pairs of adjacent letters are AB, ab, BA, ba, Aa, Bb and bB.\n\n\nThe possible words are:\n\nAabB\nABba\nabBA\nBAab\nBbBb\nbBAa\nbBbB", "locale": "zh-CN"}}}
{"pid": "P3013", "type": "P", "difficulty": 5, "samples": [["4 3 \n4 4 1 3 \n1 3 2 4 \n4 2 3 1 \n", "1 \n2 \n1 \n2 \n3 \n1 \n3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2011", "USACO", "Special Judge", "广度优先搜索 BFS", "深度优先搜索 DFS"], "title": "[USACO11FEB] The Lost Cows G", "background": "", "description": "One sunny day farmer John was kidnapped by evil farmer Marcus's cows. FJ wasn't too concerned about his forced holiday but wanted to make sure that his cows got home safely together.\n\nThe cows are spread out in every one of FJ's N (3 <= N <= 200) pastures conveniently numbered 1..N. The barn is located at pasture 1. The farm has an interesting navigation system: at every pasture i there are M (1 <= M <= 200) signs S\\_ij (1 <= S\\_ij <= N) which one could reference as S\\_i1..S\\_iM; each sign points the way to a pasture. Sometimes a sign points to a path that leads back to the same\n\npasture.\n\nFarmer Marcus's cows allow FJ to write a single message to all of his cows. FJ's plan is to write a list of sign numbers such that any cow who follows those instructions will all arrive at the barn when each cow has completed all the instructions.\n\nWhen a cow starts at a given pasture then she will first follow the path indicated by the first sign number on FJ's list. When she arrives at the second pasture, she looks at the second sign of FJ's list and follows the path marked by that sign. She continues until she exhausts the instruction list, at which point she should be at the barn.\n\nFind a list of instructions containing no more than 5,000,000 sign numbers that will guide every cow, from every pasture, to the barn after all instructions are followed.  It is guaranteed that such a list exists.\n\nConsider a set of three signs in four pastures that direct the cows like these do:\n\n```cpp\n** Pasture# ** \n1    2    3    4 \nSign 1   4    4    1    3 \nSign 2   1    3    2    4 \nSign 3   4    2    3    1 \n```\nThe set of instructions below will direct cows to the barn from any of the four pastures:\n\n```cpp\nInstruction#   Sign#            Instruction#   Sign# \n1           1                   5           3 \n2           2                   6           1 \n3           1                   7           3 \n4           2 \n```\nThe cow in pasture 1 will read sign #1 at time 1 and be directed to pasture 4.  At time 2, she is in pasture 4 and (per FJ's\n\ninstructions) read sign #2 and then be directed to pasture 4. Below is a table that shows the cow's travels:\n\n```cpp\n* * * *  Cow in pasture  1  * * * * \nTime    CurrentPasture#    WhichSign     Sign->Nextpasture \n1            1               1                4 \n2            4               2                4 (same pasture!) \n3            4               1                3 \n4            3               2                2 \n5            2               3                2 (same pasture)\n6            2               1                4 \n7            4               3                1 Barn! \n```\nSimilarly: Pasture 2's cow visits pastures [2]-4-4-3-2-2-4-1. Pasture 3's cow visits pastures [3]-1-1-4-4-1-4-1.\n\nPasture 4's cow visits pastures [4]-3-2-4-4-1-4-1.\n\n\nGiven a set of signs, create a set of instructions. \n", "inputFormat": "\\* Line 1: Two space separated integers: N and M\n\n\\* Lines 2..M+1: Line i+1 describes the contents of each pasture's N signs with N integers: S\\_1i..S\\_Ni\n", "outputFormat": "\\* Lines 1..?: The sign numbers the cows should follow, one per line.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11FEB] The Lost Cows G", "background": "", "description": "One sunny day farmer John was kidnapped by evil farmer Marcus's cows. FJ wasn't too concerned about his forced holiday but wanted to make sure that his cows got home safely together.\n\nThe cows are spread out in every one of FJ's N (3 <= N <= 200) pastures conveniently numbered 1..N. The barn is located at pasture 1. The farm has an interesting navigation system: at every pasture i there are M (1 <= M <= 200) signs S\\_ij (1 <= S\\_ij <= N) which one could reference as S\\_i1..S\\_iM; each sign points the way to a pasture. Sometimes a sign points to a path that leads back to the same\n\npasture.\n\nFarmer Marcus's cows allow FJ to write a single message to all of his cows. FJ's plan is to write a list of sign numbers such that any cow who follows those instructions will all arrive at the barn when each cow has completed all the instructions.\n\nWhen a cow starts at a given pasture then she will first follow the path indicated by the first sign number on FJ's list. When she arrives at the second pasture, she looks at the second sign of FJ's list and follows the path marked by that sign. She continues until she exhausts the instruction list, at which point she should be at the barn.\n\nFind a list of instructions containing no more than 5,000,000 sign numbers that will guide every cow, from every pasture, to the barn after all instructions are followed.  It is guaranteed that such a list exists.\n\nConsider a set of three signs in four pastures that direct the cows like these do:\n\n```cpp\n** Pasture# ** \n1    2    3    4 \nSign 1   4    4    1    3 \nSign 2   1    3    2    4 \nSign 3   4    2    3    1 \n```\nThe set of instructions below will direct cows to the barn from any of the four pastures:\n\n```cpp\nInstruction#   Sign#            Instruction#   Sign# \n1           1                   5           3 \n2           2                   6           1 \n3           1                   7           3 \n4           2 \n```\nThe cow in pasture 1 will read sign #1 at time 1 and be directed to pasture 4.  At time 2, she is in pasture 4 and (per FJ's\n\ninstructions) read sign #2 and then be directed to pasture 4. Below is a table that shows the cow's travels:\n\n```cpp\n* * * *  Cow in pasture  1  * * * * \nTime    CurrentPasture#    WhichSign     Sign->Nextpasture \n1            1               1                4 \n2            4               2                4 (same pasture!) \n3            4               1                3 \n4            3               2                2 \n5            2               3                2 (same pasture)\n6            2               1                4 \n7            4               3                1 Barn! \n```\nSimilarly: Pasture 2's cow visits pastures [2]-4-4-3-2-2-4-1. Pasture 3's cow visits pastures [3]-1-1-4-4-1-4-1.\n\nPasture 4's cow visits pastures [4]-3-2-4-4-1-4-1.\n\n\nGiven a set of signs, create a set of instructions. \n", "inputFormat": "\\* Line 1: Two space separated integers: N and M\n\n\\* Lines 2..M+1: Line i+1 describes the contents of each pasture's N signs with N integers: S\\_1i..S\\_Ni\n", "outputFormat": "\\* Lines 1..?: The sign numbers the cows should follow, one per line.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11FEB] The Lost Cows G", "background": "", "description": "给定一张 $n(3\\leq n\\leq 200)$ 个点的图，每个点都恰好有 $m(1\\leq m\\leq 200)$ 条出边，第 $i$ 个点的第 $j$ 条出边指向 $a_{i,j}$。\n\n现在这张图上每个点都有一头牛。每次你可以报出一个数 $x(1\\leq x\\leq m)$，这会使得每一头牛沿着当前所在的点的第 $x$ 条边走一步（即当前在点 $u$ 的牛移动到点 $a_{u,x}$）。\n\n你需要发出不超过 $5\\times 10^6$ 条指令，使得在所有的指令执行完后，所有的牛都在编号为 $1$ 的点上。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $m$ 行每行 $n$ 个整数，第 $i$ 行的第 $j$ 个整数是 $a_{j,i}$。", "outputFormat": "在第 $i$ 行输出你发出的第 $i$ 条指令。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3014", "type": "P", "difficulty": 4, "samples": [["5 2 \nP \n3 \nQ \n1 2 5 3 4 \n", "1 2 4 3 5 \n5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2011", "USACO", "枚举", "康托展开"], "title": "[USACO11FEB] Cow Line S", "background": "", "description": "The N (1 <= N <= 20) cows conveniently numbered 1...N are playing yet another one of their crazy games with Farmer John. The cows will arrange themselves in a line and ask Farmer John what their line number is. In return, Farmer John can give them a line number and the cows must rearrange themselves into that line.\n\nA line number is assigned by numbering all the permutations of the line in lexicographic order.\n\nConsider this example:\n\nFarmer John has 5 cows and gives them the line number of 3.\n\nThe permutations of the line in ascending lexicographic order: 1st: 1 2 3 4 5\n\n2nd: 1 2 3 5 4\n\n3rd: 1 2 4 3 5\n\nTherefore, the cows will line themselves in the cow line 1 2 4 3 5.\n\nThe cows, in return, line themselves in the configuration '1 2 5 3 4' and ask Farmer John what their line number is.\n\nContinuing with the list:\n\n4th : 1 2 4 5 3\n\n5th : 1 2 5 3 4\n\nFarmer John can see the answer here is 5\n\nFarmer John and the cows would like your help to play their game. They have K (1 <= K <= 10,000) queries that they need help with. Query i has two parts: C\\_i will be the command, which is either 'P' or 'Q'.\n\nIf C\\_i is 'P', then the second part of the query will be one integer A\\_i (1 <= A\\_i <= N!), which is a line number. This is Farmer John challenging the cows to line up in the correct cow line.\n\nIf C\\_i is 'Q', then the second part of the query will be N distinct integers B\\_ij (1 <= B\\_ij <= N). This will denote a cow line. These are the cows challenging Farmer John to find their line number.\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..2\\*K+1: Line 2\\*i and 2\\*i+1 will contain a single query.\n\nLine 2\\*i will contain just one character: 'Q' if the cows are lining up and asking Farmer John for their line number or 'P' if Farmer John gives the cows a line number.\n\nIf the line 2\\*i is 'Q', then line 2\\*i+1 will contain N space-separated integers B\\_ij which represent the cow line. If the line 2\\*i is 'P', then line 2\\*i+1 will contain a single integer A\\_i which is the line number to solve for.\n", "outputFormat": "\\* Lines 1..K: Line i will contain the answer to query i.\n\nIf line 2\\*i of the input was 'Q', then this line will contain a single integer, which is the line number of the cow line in line 2\\*i+1.\n\nIf line 2\\*i of the input was 'P', then this line will contain N space separated integers giving the cow line of the number in line 2\\*i+1.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11FEB] Cow Line S", "background": "", "description": "The N (1 <= N <= 20) cows conveniently numbered 1...N are playing yet another one of their crazy games with Farmer John. The cows will arrange themselves in a line and ask Farmer John what their line number is. In return, Farmer John can give them a line number and the cows must rearrange themselves into that line.\n\nA line number is assigned by numbering all the permutations of the line in lexicographic order.\n\nConsider this example:\n\nFarmer John has 5 cows and gives them the line number of 3.\n\nThe permutations of the line in ascending lexicographic order: 1st: 1 2 3 4 5\n\n2nd: 1 2 3 5 4\n\n3rd: 1 2 4 3 5\n\nTherefore, the cows will line themselves in the cow line 1 2 4 3 5.\n\nThe cows, in return, line themselves in the configuration '1 2 5 3 4' and ask Farmer John what their line number is.\n\nContinuing with the list:\n\n4th : 1 2 4 5 3\n\n5th : 1 2 5 3 4\n\nFarmer John can see the answer here is 5\n\nFarmer John and the cows would like your help to play their game. They have K (1 <= K <= 10,000) queries that they need help with. Query i has two parts: C\\_i will be the command, which is either 'P' or 'Q'.\n\nIf C\\_i is 'P', then the second part of the query will be one integer A\\_i (1 <= A\\_i <= N!), which is a line number. This is Farmer John challenging the cows to line up in the correct cow line.\n\nIf C\\_i is 'Q', then the second part of the query will be N distinct integers B\\_ij (1 <= B\\_ij <= N). This will denote a cow line. These are the cows challenging Farmer John to find their line number.\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..2\\*K+1: Line 2\\*i and 2\\*i+1 will contain a single query.\n\nLine 2\\*i will contain just one character: 'Q' if the cows are lining up and asking Farmer John for their line number or 'P' if Farmer John gives the cows a line number.\n\nIf the line 2\\*i is 'Q', then line 2\\*i+1 will contain N space-separated integers B\\_ij which represent the cow line. If the line 2\\*i is 'P', then line 2\\*i+1 will contain a single integer A\\_i which is the line number to solve for.\n", "outputFormat": "\\* Lines 1..K: Line i will contain the answer to query i.\n\nIf line 2\\*i of the input was 'Q', then this line will contain a single integer, which is the line number of the cow line in line 2\\*i+1.\n\nIf line 2\\*i of the input was 'P', then this line will contain N space separated integers giving the cow line of the number in line 2\\*i+1.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11FEB] Cow Line S", "background": null, "description": "编号为 $1$ 到 $N (1 \\leq N \\leq 20)$ 的 $N$ 头奶牛正在和农夫约翰玩他们的又一个疯狂游戏。奶牛们将自己排列成一行，并询问农夫约翰它们的排列编号是多少。作为回应，农夫约翰可以给它们一个排列编号，奶牛们必须重新排列成那个排列。\n\n排列编号是通过按字典序给所有排列编号来分配的。\n\n考虑这个例子：\n\n农夫约翰有 $5$ 头奶牛，并给它们排列编号 $3$ 。\n\n按升序字典序排列的排列：第 $1$ 个：$1,2,3,4,5$\n\n第 $2$ 个：$1,2,3,5,4$\n\n第 $3$ 个：$1,2,4,3,5$\n\n因此，奶牛们将自己排列成奶牛排列 $1,2,4,3,5$。\n\n奶牛们反过来排列成配置「$1,2,5,3,4$」，并询问农夫约翰它们的排列编号是多少。\n\n继续列表：\n\n第 $4$ 个：$1,2,4,5,3$\n\n第 $5$ 个：$1,2,5,3,4$\n\n农夫约翰可以看到答案是 $5$ 。\n\n农夫约翰和奶牛们希望你能帮助他们玩这个游戏。他们有 $K (1 \\leq K \\leq 10,000)$ 个查询需要帮助。查询 $i$ 有两个部分：$C_i$ 是命令，可以是 `P` 或 `Q` 。\n\n如果 $C_i$ 是 `P` ，那么查询的第二部分将是一个整数 $A_i (1 \\leq A_i \\leq N!)$，这是一个排列编号。这是农夫约翰挑战奶牛们排成正确的奶牛排列。\n\n如果 $C_i$ 是 `Q`，那么查询的第二部分将是 $N$ 个不同的整数 $B_{ij} (1 \\leq B_{ij} \\leq N)$。这将表示一个奶牛排列。这是奶牛们挑战农夫约翰找出它们的排列编号。", "inputFormat": "\\* 第 $1$ 行：两个用空格分隔的整数：$N$ 和 $K$\n\n\\* 第 $2$ 行到第 $2 \\times K + 1$ 行：第 $2 \\times i$ 行和第 $2 \\times i + 1$ 行将包含一个查询。\n\n第 $2 \\times i$ 行将只包含一个字符：如果奶牛们排列并询问农夫约翰它们的排列编号，则为 `Q`；如果农夫约翰给奶牛们一个排列编号，则为 `P`。\n\n如果第 $2 \\times i$ 行是 `Q`，那么第 $2 \\times i + 1$ 行将包含 $N$ 个用空格分隔的整数 $B_ij$，表示奶牛排列。如果第 $2 \\times i$ 行是 `P`，那么第 $2 \\times i + 1$ 行将包含一个整数 $A_i$，这是要解决的排列编号。", "outputFormat": "\\* 第 $1$ 行到第 $K$ 行：第 $i$ 行将包含查询 $i$ 的答案。\n\n如果输入的第 $2 \\times i$ 行是 `Q`，那么这一行将包含一个整数，即第 $2 \\times i + 1$ 行中奶牛排列的排列编号。\n\n如果输入的第 $2 \\times i$ 行是 `P`，那么这一行将包含 $N$ 个用空格分隔的整数，给出第 $2 \\times i + 1$ 行中编号的奶牛排列。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3015", "type": "P", "difficulty": 3, "samples": [["6 \n0 \n0 \n1 \n1 \n0 \n1 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "字符串", "2011", "USACO", "栈"], "title": "[USACO11FEB] Best Parenthesis S", "background": null, "description": "给定一个只包含左右括号的字符串，得分规则如下：\n\n如果一对括号内没有括号，那么这对括号的得分为1；如果两对括号互不包含（即并列存在），那这两对括号的得分相加；如果括号内包含一对括号，那么这个括号的得分记为内部括号序列的得分 $\\times 2$。\n\n例如：对于这样一个字符串：`() ()`，两对括号并列存在，则得分为 $1+1=2$;\n\n而对于这样一个字符串：`(())`，最外层的括号内层包含一对括号，则得分为 $2 \\times 1 = 2$。\n\n\nBessie 想击败所有同事的牛，所以她需要计算某个字符串的评分。给定一个长度为 $n$ 、只包含括号的字符串（$2 \\le N \\le 100000$），计算其得分帮助 Bessie。", "inputFormat": "第一行，输入一个整数 $n$。  \n接下来 $n$ 行，每行一个数字，如果是 $0$，表示这个字符是 `(`；如果是 $1$，表示这个字符是 `)`。", "outputFormat": "字符串的分数，由于数字可能会变得很大，所以对 $12345678910$ 取模。", "hint": "样例的字符串是 `(())()`。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO11FEB] Best Parenthesis S", "background": null, "description": "Recently, the cows have been competing with strings of balanced parentheses and comparing them with each other to see who has the best one.\n\nSuch strings are scored as follows (all strings are balanced): the string '()' has score 1; if 'A' has score s(A) then '(A)' has score 2\\*s(A); and if 'A' and 'B' have scores s(A) and s(B), respectively, then 'AB' has score s(A)+s(B). For example, s('(())()') = s('(())')+s('()') = 2\\*s('()')+1 = 2\\*1+1 = 3.\n\nBessie wants to beat all of her fellow cows, so she needs to calculate the score of some strings. Given a string of balanced parentheses of length N (2 <= N <= 100,000), help Bessie compute its score.", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N + 1: Line i+1 will contain 1 integer: 0 if the ith character of the string is '(',  and 1 if the ith character of the string is ')'", "outputFormat": "\\* Line 1: The score of the string. Since this number can get quite large, output the  score modulo 12345678910.", "hint": "This corresponds to the string \"(())()\". \n\nAs discussed above.", "locale": "en"}, "zh-CN": {"title": "[USACO11FEB] Best Parenthesis S", "background": null, "description": "给定一个只包含左右括号的字符串，得分规则如下：\n\n如果一对括号内没有括号，那么这对括号的得分为1；如果两对括号互不包含（即并列存在），那这两对括号的得分相加；如果括号内包含一对括号，那么这个括号的得分记为内部括号序列的得分 $\\times 2$。\n\n例如：对于这样一个字符串：`() ()`，两对括号并列存在，则得分为 $1+1=2$;\n\n而对于这样一个字符串：`(())`，最外层的括号内层包含一对括号，则得分为 $2 \\times 1 = 2$。\n\n\nBessie 想击败所有同事的牛，所以她需要计算某个字符串的评分。给定一个长度为 $n$ 、只包含括号的字符串（$2 \\le N \\le 100000$），计算其得分帮助 Bessie。", "inputFormat": "第一行，输入一个整数 $n$。  \n接下来 $n$ 行，每行一个数字，如果是 $0$，表示这个字符是 `(`；如果是 $1$，表示这个字符是 `)`。", "outputFormat": "字符串的分数，由于数字可能会变得很大，所以对 $12345678910$ 取模。", "hint": "样例的字符串是 `(())()`。", "locale": "zh-CN"}}}
{"pid": "P3016", "type": "P", "difficulty": 3, "samples": [["3 2 \n5 \n-8 4 \n2 -3 6 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11FEB] The Triangle S", "background": "", "description": "\nFor her spectacular milk output for the previous month, Farmer John has awarded Bessie a prize -- with a twist.  He has given her a triangular grid with N (1 <= N <= 700) rows (whose lengths vary from 1 through N, of course). Row i of the the grid has i values labeled v\\_ij (-1,000,000,000 <= v\\_ij <= 1,000,000,000) where j is in the range 1..i.\n\nBessie chooses a sub-triangle whose side length is at least K (1 <= K <= 20; 1 <= K <= N) within the triangular grid. The sub-triangle is another triangular grid which might be oriented the same as the original triangle or might be 'upside down' with its shorter rows on the bottom instead of the top.\n\nAfter she chooses her sub-triangle, Farmer John will take the average of all the numbers in the sub-triangle, discarding the digits to the right of the decimal point, and give her that many gold coins (or take that many gold coins from her if the number is negative). Naturally, Bessie would like to maximize her prize (or minimize her loss). Help her solve this problem.\n\nBy way of example, Bessie is given this triangular grid with N = 3 rows and must choose a sub-triangle with a side length of at least K = 2. A graphical representation of the triangle is shown below:\n\n```cpp\n    / \\\n   / 5 \\\n  /-8  4\\\n /2 -3  6\\\n ---------\n```\nShe could choose any of five valid sub-triangles (one of which is the entire original triangle):\n\n```cpp\n                                                   /\\\n    / \\         / \\        / \\         / \\        /5 \\       \n   / 5 \\       / \\5\\      / 5 \\       / 5/\\      /----\\    \n  /-8  4\\     /-8 \\4\\    /-8  4\\     /-8/ 4\\    /\\-8 4/\\ \n /2 -3  6\\   / 2 -3\\6\\  /-------\\   / 2/-3 6\\  / 2\\-3/6 \\ \n ---------   ---------  -2  -3  6   ---------  ----------  \n  entire      lower        top          lower     upside\n triangle     left                      right      down\n```\nThe one that is lined below is the one with the highest average:\n\n```cpp\n    / \\\n   / 5/\\\n  /-8/ 4\\\n / 2/-3 6\\\n ---------\n```\nThe average of this sub-triangle is (4+6-3)/3, which is about\n\n2.3333...; without the fraction, the answer is 2. \n\nHelp Bessie calculate the maximum amount of coins which she could receive.", "inputFormat": "\n\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..N+1: Line i+1 will contain i space-separated integers: v\\_ij", "outputFormat": "\n\\* Line 1: The maximum number of coins that Bessie can receive (or, if negative, the best she can do for her loss).\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11FEB] The Triangle S", "background": "", "description": "\nFor her spectacular milk output for the previous month, Farmer John has awarded Bessie a prize -- with a twist.  He has given her a triangular grid with N (1 <= N <= 700) rows (whose lengths vary from 1 through N, of course). Row i of the the grid has i values labeled v\\_ij (-1,000,000,000 <= v\\_ij <= 1,000,000,000) where j is in the range 1..i.\n\nBessie chooses a sub-triangle whose side length is at least K (1 <= K <= 20; 1 <= K <= N) within the triangular grid. The sub-triangle is another triangular grid which might be oriented the same as the original triangle or might be 'upside down' with its shorter rows on the bottom instead of the top.\n\nAfter she chooses her sub-triangle, Farmer John will take the average of all the numbers in the sub-triangle, discarding the digits to the right of the decimal point, and give her that many gold coins (or take that many gold coins from her if the number is negative). Naturally, Bessie would like to maximize her prize (or minimize her loss). Help her solve this problem.\n\nBy way of example, Bessie is given this triangular grid with N = 3 rows and must choose a sub-triangle with a side length of at least K = 2. A graphical representation of the triangle is shown below:\n\n```cpp\n    / \\\n   / 5 \\\n  /-8  4\\\n /2 -3  6\\\n ---------\n```\nShe could choose any of five valid sub-triangles (one of which is the entire original triangle):\n\n```cpp\n                                                   /\\\n    / \\         / \\        / \\         / \\        /5 \\       \n   / 5 \\       / \\5\\      / 5 \\       / 5/\\      /----\\    \n  /-8  4\\     /-8 \\4\\    /-8  4\\     /-8/ 4\\    /\\-8 4/\\ \n /2 -3  6\\   / 2 -3\\6\\  /-------\\   / 2/-3 6\\  / 2\\-3/6 \\ \n ---------   ---------  -2  -3  6   ---------  ----------  \n  entire      lower        top          lower     upside\n triangle     left                      right      down\n```\nThe one that is lined below is the one with the highest average:\n\n```cpp\n    / \\\n   / 5/\\\n  /-8/ 4\\\n / 2/-3 6\\\n ---------\n```\nThe average of this sub-triangle is (4+6-3)/3, which is about\n\n2.3333...; without the fraction, the answer is 2. \n\nHelp Bessie calculate the maximum amount of coins which she could receive.", "inputFormat": "\n\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..N+1: Line i+1 will contain i space-separated integers: v\\_ij", "outputFormat": "\n\\* Line 1: The maximum number of coins that Bessie can receive (or, if negative, the best she can do for her loss).\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11FEB] The Triangle S", "background": null, "description": "农夫 FJ 颁给 Bessie 一个奇怪的奖项，以奖励她前几个月壮观的牛奶产量。他给她一个 $N$ 行的三角形网格（当然，三角形网格每行是 $1$ 到 $N$ 之间递增）。网格中第 $i$ 行有 $i$ 个数，数值为 $v_{i,j}$（$-10^9\\le v_{i,j}\\le 10^9$），其中 $j$ 为 $1\\sim i$ 的数列。\n\nBessie 在这个三角形网格中选择了一个行数至少为 $K$ 的子三角形网格（$1 \\le K \\le N \\le 700$，$1\\le K\\le 20$）。子三角形网格有可能和原来的三角形朝向相反，即子三角形网格朝向的较短行对应原来三角形的较长行。\n\nBessie 选择完子三角形网格后，FJ 会将子三角形中的所有数值求平均数，并抹除小数，然后给 Bessie 相对应的金币（若平均值为负，则从 Bessie 处拿相应的金币），Bessie 想要取得最大的利益（或最小的代价），请你帮她解决问题\n\n例如，Bessie 被给了一个 $N=5,K=3$ 的三角形网格。这个问题的图像为:\n\n```cpp\n    / \\\n   / 5 \\\n  /-8  4\\\n /2 -3  6\\\n ---------\n```\n她可以选择 $5$ 个子三角形的任意一个\n\n```cpp\n                                                   /\\\n    / \\         / \\        / \\         / \\        /5 \\       \n   / 5 \\       / \\5\\      / 5 \\       / 5/\\      /----\\    \n  /-8  4\\     /-8 \\4\\    /-8  4\\     /-8/ 4\\    /\\-8 4/\\ \n /2 -3  6\\   / 2 -3\\6\\  /-------\\   / 2/-3 6\\  / 2\\-3/6 \\ \n ---------   ---------  -2  -3  6   ---------  ----------  \n  三角形      左下          顶部         右下      中间\n   整体                          \n```\n这是平均值最大的一组:\n\n```cpp\n    / \\\n   / 5/\\\n  /-8/ 4\\\n / 2/-3 6\\\n ---------\n```\n这个子三角形的平均值为 $(4-3+6)\\div3$，等于 $2.\\dot3$（即 $2.333\\dots$），所以答案为 $2$。\n\n帮助 Bessie 求出她可获得金币的最大值。\n\n**时简限制**: 2 秒。\n\n**空间限制**: 32 MB。", "inputFormat": "* 第一行两个用空格隔开的正整数 $N,K$。\n* 第 $2\\sim N$ 行，$i+1$ 行输入 $i$ 个用空格隔开的整数 $v_{i,j}$。", "outputFormat": "* 一行，输出 Bessie 得到的金币最大值（可能为负）。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3017", "type": "P", "difficulty": 5, "samples": [["5 4 4 2 \n1 2 2 1 \n3 1 1 1 \n2 0 1 3 \n1 1 1 1 \n1 1 1 1 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "二分", "USACO", "枚举", "前缀和"], "title": "[USACO11MAR] Brownie Slicing G", "background": "", "description": "Bessie has baked a rectangular brownie that can be thought of as an RxC grid (1 <= R <= 500; 1 <= C <= 500) of little brownie squares. The square at row i, column j contains N\\_ij (0 <= N\\_ij <= 4,000) chocolate chips.\n\nBessie wants to partition the brownie up into A\\*B chunks (1 <= A <= R; 1 <= B <= C): one for each of the A\\*B cows. The brownie is cut by first making A-1 horizontal cuts (always along integer\n\ncoordinates) to divide the brownie into A strips.  Then cut each strip \\*independently\\* with B-1 vertical cuts, also on integer\n\nboundaries. The other A\\*B-1 cows then each choose a brownie piece, leaving the last chunk for Bessie. Being greedy, they leave Bessie the brownie that has the least number of chocolate chips on it.\n\nDetermine the maximum number of chocolate chips Bessie can receive, assuming she cuts the brownies optimally.\n\nAs an example, consider a 5 row x 4 column brownie with chips\n\ndistributed like this:\n```\n1 2 2 1\n3 1 1 1\n2 0 1 3\n1 1 1 1\n1 1 1 1\n```\n\nBessie must partition the brownie into 4 horizontal strips, each with two pieces. Bessie can cut the brownie like this:\n\n```\n1 2 | 2 1\n---------\n3 | 1 1 1\n---------\n2 0 1 | 3\n---------\n1 1 | 1 1\n1 1 | 1 1\n```\n\nThus, when the other greedy cows take their brownie piece, Bessie still gets 3 chocolate chips.", "inputFormat": "\\* Line 1: Four space-separated integers: R, C, A, and B\n\n\\* Lines 2..R+1: Line i+1 contains C space-separated integers: N\\_i1, ..., N\\_iC\n", "outputFormat": "\\* Line 1: A single integer: the maximum number of chocolate chips that Bessie guarantee on her brownie\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11MAR] Brownie Slicing G", "background": "", "description": "Bessie has baked a rectangular brownie that can be thought of as an RxC grid (1 <= R <= 500; 1 <= C <= 500) of little brownie squares. The square at row i, column j contains N\\_ij (0 <= N\\_ij <= 4,000) chocolate chips.\n\nBessie wants to partition the brownie up into A\\*B chunks (1 <= A <= R; 1 <= B <= C): one for each of the A\\*B cows. The brownie is cut by first making A-1 horizontal cuts (always along integer\n\ncoordinates) to divide the brownie into A strips.  Then cut each strip \\*independently\\* with B-1 vertical cuts, also on integer\n\nboundaries. The other A\\*B-1 cows then each choose a brownie piece, leaving the last chunk for Bessie. Being greedy, they leave Bessie the brownie that has the least number of chocolate chips on it.\n\nDetermine the maximum number of chocolate chips Bessie can receive, assuming she cuts the brownies optimally.\n\nAs an example, consider a 5 row x 4 column brownie with chips\n\ndistributed like this:\n```\n1 2 2 1\n3 1 1 1\n2 0 1 3\n1 1 1 1\n1 1 1 1\n```\n\nBessie must partition the brownie into 4 horizontal strips, each with two pieces. Bessie can cut the brownie like this:\n\n```\n1 2 | 2 1\n---------\n3 | 1 1 1\n---------\n2 0 1 | 3\n---------\n1 1 | 1 1\n1 1 | 1 1\n```\n\nThus, when the other greedy cows take their brownie piece, Bessie still gets 3 chocolate chips.", "inputFormat": "\\* Line 1: Four space-separated integers: R, C, A, and B\n\n\\* Lines 2..R+1: Line i+1 contains C space-separated integers: N\\_i1, ..., N\\_iC\n", "outputFormat": "\\* Line 1: A single integer: the maximum number of chocolate chips that Bessie guarantee on her brownie\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11MAR] Brownie Slicing G", "background": "", "description": "Bessie 烤了一个长方形的布朗尼，可以看作是一个 $R \\times C$ 的网格（$1 \\le R \\le 500$；$1 \\le C \\le 500$），由小方块组成。在第 $i$ 行，第 $j$ 列的方块中有 $N_{ij}$（$0 \\le N_{ij} \\le 4,000$）颗巧克力豆。\n\nBessie 想把布朗尼分成 $A \\times B$ 块（$1 \\le A \\le R$；$1 \\le B \\le C$）：每头牛一块。布朗尼的切割方式是先进行 $A-1$ 次水平切割（总是在整数坐标上），将布朗尼分成 $A$ 条带。然后每条带独立地进行 $B-1$ 次垂直切割，也是在整数边界上。其他 $A \\times B - 1$ 头牛各自选择一块布朗尼，剩下最后一块给 Bessie。由于它们很贪心，它们会把巧克力豆最少的一块留给 Bessie。\n\n假设 Bessie 以最优方式切割布朗尼，求 Bessie 能获得的最多巧克力豆数。\n\n例如，考虑一个 5 行 4 列的布朗尼，巧克力豆分布如下：\n```\n1 2 2 1\n3 1 1 1\n2 0 1 3\n1 1 1 1\n1 1 1 1\n```\n\nBessie 必须将布朗尼分成 4 条水平带，每条带有两块。Bessie 可以这样切割布朗尼：\n\n```\n1 2 | 2 1\n---------\n3 | 1 1 1\n---------\n2 0 1 | 3\n---------\n1 1 | 1 1\n1 1 | 1 1\n```\n\n因此，当其他贪心的牛选择它们的布朗尼块时，Bessie 仍然可以得到 3 颗巧克力豆。", "inputFormat": "\\* 第 1 行：四个用空格分隔的整数：$R$，$C$，$A$ 和 $B$\n\n\\* 第 2 行到第 $R+1$ 行：第 $i+1$ 行包含 $C$ 个用空格分隔的整数：$N_{i1}, ..., N_{iC}$", "outputFormat": "\\* 第 1 行：一个整数：Bessie 在她的布朗尼上能保证获得的最多巧克力豆数", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3018", "type": "P", "difficulty": 4, "samples": [["5 \n-1 9 3 \n1 2 2 \n5 3 2 \n5 1 4 \n2 3 3 \n", "20 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11MAR] Tree Decoration G", "background": "", "description": "Farmer John is decorating his Spring Equinox Tree (like a Christmas tree but popular about three months later). It can be modeled as a rooted mathematical tree with N (1 <= N <= 100,000) elements, labeled 1...N, with element 1 as the root of the tree. Each tree element e > 1 has a parent, P\\_e (1 <= P\\_e <= N). Element 1 has no parent (denoted '-1' in the input), of course, because it is the root of the tree.\n\nEach element i has a corresponding subtree (potentially of size 1) rooted there. FJ would like to make sure that the subtree corresponding to element i has a total of at least C\\_i (0 <= C\\_i <= 10,000,000) ornaments scattered among its members. He would also like to minimize the total amount of time it takes him to place all the ornaments (it takes time K\\*T\\_i to place K ornaments at element i (1 <= T\\_i <= 100)).\n\nHelp FJ determine the minimum amount of time it takes to place ornaments that satisfy the constraints.  Note that this answer might not fit into a 32-bit integer, but it will fit into a signed 64-bit integer.\n\nFor example, consider the tree below where nodes located higher on the display are parents of connected lower nodes (1 is the root):\n\n```cpp\nFor example, consider the tree below where nodes located higher on\nthe display are parents of connected lower nodes (1 is the root):\n\n               1 \n               |\n               2\n               |\n               5\n              / \\\n             4   3\n\nSuppose that FJ has the following subtree constraints:\n\n                  Minimum ornaments the subtree requires\n                    |     Time to install an ornament\n       Subtree      |       |\n        root   |   C_i  |  T_i\n       --------+--------+-------\n          1    |    9   |   3\n          2    |    2   |   2\n          3    |    3   |   2\n          4    |    1   |   4\n          5    |    3   |   3\n\nThen FJ can place all the ornaments as shown below, for a total\ncost of 20:\n\n            1 [0/9(0)]     legend: element# [ornaments here/\n            |                      total ornaments in subtree(node install time)]\n            2 [3/9(6)]\n            |\n            5 [0/6(0)]\n           / \\\n [1/1(4)] 4   3 [5/5(10)]\n```", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains three space-separated integers: P\\_i, C\\_i, and T\\_i\n", "outputFormat": "\\* Line 1: A single integer: The minimum time to place all the\n\nornaments\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11MAR] Tree Decoration G", "background": "", "description": "Farmer John is decorating his Spring Equinox Tree (like a Christmas tree but popular about three months later). It can be modeled as a rooted mathematical tree with N (1 <= N <= 100,000) elements, labeled 1...N, with element 1 as the root of the tree. Each tree element e > 1 has a parent, P\\_e (1 <= P\\_e <= N). Element 1 has no parent (denoted '-1' in the input), of course, because it is the root of the tree.\n\nEach element i has a corresponding subtree (potentially of size 1) rooted there. FJ would like to make sure that the subtree corresponding to element i has a total of at least C\\_i (0 <= C\\_i <= 10,000,000) ornaments scattered among its members. He would also like to minimize the total amount of time it takes him to place all the ornaments (it takes time K\\*T\\_i to place K ornaments at element i (1 <= T\\_i <= 100)).\n\nHelp FJ determine the minimum amount of time it takes to place ornaments that satisfy the constraints.  Note that this answer might not fit into a 32-bit integer, but it will fit into a signed 64-bit integer.\n\nFor example, consider the tree below where nodes located higher on the display are parents of connected lower nodes (1 is the root):\n\n```cpp\nFor example, consider the tree below where nodes located higher on\nthe display are parents of connected lower nodes (1 is the root):\n\n               1 \n               |\n               2\n               |\n               5\n              / \\\n             4   3\n\nSuppose that FJ has the following subtree constraints:\n\n                  Minimum ornaments the subtree requires\n                    |     Time to install an ornament\n       Subtree      |       |\n        root   |   C_i  |  T_i\n       --------+--------+-------\n          1    |    9   |   3\n          2    |    2   |   2\n          3    |    3   |   2\n          4    |    1   |   4\n          5    |    3   |   3\n\nThen FJ can place all the ornaments as shown below, for a total\ncost of 20:\n\n            1 [0/9(0)]     legend: element# [ornaments here/\n            |                      total ornaments in subtree(node install time)]\n            2 [3/9(6)]\n            |\n            5 [0/6(0)]\n           / \\\n [1/1(4)] 4   3 [5/5(10)]\n```", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains three space-separated integers: P\\_i, C\\_i, and T\\_i\n", "outputFormat": "\\* Line 1: A single integer: The minimum time to place all the\n\nornaments\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11MAR] Tree Decoration G", "background": "", "description": "给定一颗以 $1$ 为根的有根树，第 $i$ 个结点的父结点为 $P_i$（$P_1=-1$），在第 $i$ 个结点上挂一个装饰物的代价为 $T_i$，每个结点可以挂任意个。现在给定每棵树子树中至少挂的装饰物个数 $C_i$，求满足要求的最少花费。\n\n$1 \\leq n \\leq 10^5$，$1 \\leq T_i \\leq 100$，$1 \\leq C_i \\leq 10^7$，请注意要开 long long。", "inputFormat": "第一行一个整数 $n$。\n\n第 $1$ 行至第 $n$ 行，在第 $i+1$ 行有三个整数，分别表示 $P_i$，$C_i$ 和 $T_i$。", "outputFormat": "一行一个整数表示最小花费。\n\n### 样例解释\n```\n样例中给出的树如下：\n               1 \n               |\n               2\n               |\n               5\n              / \\\n             4   3\n\n给定如下数据：\n\n                  该子树中所需的装饰物个数\n                    |     在该节点挂一个装饰物的花费\n                    |       |\n       结点编号 |   C_i  |  T_i\n       --------+--------+-------\n          1    |    9   |   3\n          2    |    2   |   2\n          3    |    3   |   2\n          4    |    1   |   4\n          5    |    3   |   3\n\n最佳方案如下：\n\n            1 [0/9(0)]\n            |\n            2 [3/9(6)]\n            |\n            5 [0/6(0)]\n           / \\\n [1/1(4)] 4   3 [5/5(10)]\n\n（格式：[在此处挂的装饰物个数/子树中装饰物总数(在此结点花费代价)]）\n```", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3019", "type": "P", "difficulty": 3, "samples": [["9 6 \n1 \n1 \n2 \n8 \n1 \n8 \n6 \n6 \n2 7 \n4 2 \n3 3 \n4 1 \n7 5 \n9 5 \n", "1 \n2 \n3 \n1 \n8 \n6 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11MAR] Meeting Place S", "background": "", "description": "Bessie and Jonell are great friends. Since Farmer John scrambles where the cows graze every day, they are sometimes quite far from each other and can't talk.\n\nThe pastures and paths on FJ's farm form a 'tree' structure.  Each pasture has exactly one distinct path to any other pasture, and each pasture (except pasture #1, the 'root') also has a single parent node.\n\nBessie and Jonell have decided that they will always meet at the closest pasture that that is both an ancestor of Jonell's pasture and of Bessie's pasture.\n\nFJ created a map of his N (1 <= N <= 1,000) pastures (conveniently numbered 1..N) that tells the parent P\\_i (1 <= P\\_i <= N) of each pasture except pasture 1, which has no parent.\n\nFJ has released his daily grazing schedule for the next M (1 <= M <= 1,000) days, so Bessie and Jonell are deciding where they should meet each day for gossip. On day k, Bessie is in pasture B\\_k (1 <= B\\_k <= N) and Jonell is in pasture J\\_k (1 <= J\\_k <= N).\n\nGiven a map and schedule, help Bessie and Jonell find their meeting places.\n\n```cpp\nConsider, for example, the following farm layout:\n\n                            Pasture      Parent Pasture\n             [1]           ---------    ----------------\n            / | \\              1              ---\n           /  |  \\             2               1 \n         [2] [3] [6]           3               1\n         /        | \\          4               2\n        /         |  \\         5               8\n      [4]        [8]  [9]      6               1\n                /   \\          7               8\n               /     \\         8               6\n             [5]     [7]       9               6\n\nHere are the meeting places that Bessie and Jonell would choose\ngiven a six day schedule of their initial grazing locations:\n\n              Bessie      Jonell       Meeting Place\n             --------    --------     ---------------\n                 2           7               1\n                 4           2               2\n                 1           1               1\n                 4           1               1\n                 7           5               8\n                 9           5               6\n```\n\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N: Line i contains a single integer that describes the parent of pasture i:  P\\_i\n\n\\* Lines N+1..N+M: Line k+N describes Bessie and Jonell's respective pastures with two space-separated integers: B\\_k and J\\_k\n\n\n", "outputFormat": "\\* Lines 1..M: Line j contains the meeting place Bessie and Jonell would use for line j+N of the input\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11MAR] Meeting Place S", "background": "", "description": "Bessie and Jonell are great friends. Since Farmer John scrambles where the cows graze every day, they are sometimes quite far from each other and can't talk.\n\nThe pastures and paths on FJ's farm form a 'tree' structure.  Each pasture has exactly one distinct path to any other pasture, and each pasture (except pasture #1, the 'root') also has a single parent node.\n\nBessie and Jonell have decided that they will always meet at the closest pasture that that is both an ancestor of Jonell's pasture and of Bessie's pasture.\n\nFJ created a map of his N (1 <= N <= 1,000) pastures (conveniently numbered 1..N) that tells the parent P\\_i (1 <= P\\_i <= N) of each pasture except pasture 1, which has no parent.\n\nFJ has released his daily grazing schedule for the next M (1 <= M <= 1,000) days, so Bessie and Jonell are deciding where they should meet each day for gossip. On day k, Bessie is in pasture B\\_k (1 <= B\\_k <= N) and Jonell is in pasture J\\_k (1 <= J\\_k <= N).\n\nGiven a map and schedule, help Bessie and Jonell find their meeting places.\n\n```cpp\nConsider, for example, the following farm layout:\n\n                            Pasture      Parent Pasture\n             [1]           ---------    ----------------\n            / | \\              1              ---\n           /  |  \\             2               1 \n         [2] [3] [6]           3               1\n         /        | \\          4               2\n        /         |  \\         5               8\n      [4]        [8]  [9]      6               1\n                /   \\          7               8\n               /     \\         8               6\n             [5]     [7]       9               6\n\nHere are the meeting places that Bessie and Jonell would choose\ngiven a six day schedule of their initial grazing locations:\n\n              Bessie      Jonell       Meeting Place\n             --------    --------     ---------------\n                 2           7               1\n                 4           2               2\n                 1           1               1\n                 4           1               1\n                 7           5               8\n                 9           5               6\n```\n\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N: Line i contains a single integer that describes the parent of pasture i:  P\\_i\n\n\\* Lines N+1..N+M: Line k+N describes Bessie and Jonell's respective pastures with two space-separated integers: B\\_k and J\\_k\n\n\n", "outputFormat": "\\* Lines 1..M: Line j contains the meeting place Bessie and Jonell would use for line j+N of the input\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11MAR] Meeting Place S", "background": null, "description": "贝西和乔内尔是好朋友。由于农夫约翰每天都会重新安排奶牛的放牧地点，有时他们相距甚远，无法交谈。\n\n农夫约翰的农场上的牧场和路径形成了一种「树」结构。每个牧场到其他任何牧场都有且仅有一条独特的路径，并且每个牧场（除了牧场 #1，即「根」）都有一个父节点。\n\n贝西和乔内尔决定，他们总是会在一个既是乔内尔牧场的祖先又是贝西牧场的祖先的最近的牧场见面。\n\n农夫约翰创建了一张他的 $N (1 \\le N \\le 1,000)$ 个牧场（编号为 $1$ 到 $N$）的地图，地图上标明了每个牧场的父节点 $P_i (1 \\le P_i \\le N)$，除了牧场 $1$，它没有父节点。\n\n农夫约翰发布了他未来 $M (1 \\le M \\le 1,000)$ 天的放牧计划，因此贝西和乔内尔正在决定他们每天应该在哪里见面进行闲聊。在第 $k$ 天，贝西在牧场 $B_k (1 \\le B_k \\le N)$，乔内尔在牧场 $J_k (1 \\le J_k \\le N)$。\n\n给定地图和计划，帮助贝西和乔内尔找到他们的会面地点。\n\n例如，考虑以下农场布局：\n\n```plain\n                            牧场      父牧场\n             [1]           ---------    ----------------\n            / | \\              1              ---\n           /  |  \\             2               1 \n         [2] [3] [6]           3               1\n         /        | \\          4               2\n        /         |  \\         5               8\n      [4]        [8]  [9]      6               1\n                /   \\          7               8\n               /     \\         8               6\n             [5]     [7]       9               6\n```\n\n以下是贝西和乔内尔在给定六天的初始放牧地点计划时选择的会面地点：\n\n```plain\n              贝西      乔内尔       会面地点\n             --------    --------     ---------------\n                 2           7               1\n                 4           2               2\n                 1           1               1\n                 4           1               1\n                 7           5               8\n                 9           5               6\n```", "inputFormat": "* 第 $1$ 行：两个用空格分隔的整数：$N$ 和 $M$\n* 第 $2$ 行到第 $N$ 行：第 $i$ 行包含一个整数，描述牧场 $i$ 的父牧场：$P_i$\n* 第 $N+1$ 行到第 $N+M$ 行：第 $k+N$ 行描述贝西和乔内尔各自所在的牧场，用两个空格分隔的整数：$B_k$ 和 $J_k$", "outputFormat": "* 第 $1$ 行到第 $M$ 行：第 $j$ 行包含贝西和乔内尔在输入的第 $j+N$ 行使用的会面地点", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3020", "type": "P", "difficulty": 3, "samples": [["6 8 \n4 5 3 \n2 4 0 \n4 1 4 \n2 1 1 \n5 6 1 \n3 6 2 \n3 2 6 \n3 4 4 \n", "5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO", "最短路"], "title": "[USACO11MAR] Package Delivery S", "background": "", "description": "Farmer John must deliver a package to Farmer Dan, and is preparing to make his journey. To keep the peace, he gives a tasty treat to every cow that he meets along his way and, of course, FJ is so frugal that he would like to encounter as few cows as possible.\n\n农夫约翰必须送一个包裹给农夫丹，并准备去旅行。为了保持和平，他必须给每一头遇到的奶牛一些吃的，当然，FJ很节俭，他想可能遇到尽可能少的奶牛。\n\nFJ has plotted a map of N (1 <= N <= 50,000) barns, connected by M (1 <= M <= 50,000) bi-directional cow paths, each with C\\_i (0 <= C\\_i <= 1,000) cows ambling along it. A cow path connects two distinct barns, A\\_i and B\\_i (1 <= A\\_i <= N; 1 <= B\\_i <= N; A\\_i != B\\_i). Two barns may be directly connected by more than one path. He is currently located at barn 1, and Farmer Dan is located at barn N.\n\nFJ 已经绘制了 $N(1 \\le N \\le 50000)$ 个谷仓的地图，通过 $M(1 \\le M \\le 50000)$ 条双向牛道，每条双向牛道上有 $c[i](0 \\le c[i] \\le 1000)$ 奶牛漫步。双向牛道连接两个不同的谷仓，$a[i]$ 和 $b[i](1 \\le a[i] \\le N,1 \\le b[i] \\le N, a[i] \\neq b[i])$。两个谷仓可以由一条以上的小路直接连接。他目前在 $1$ 号谷仓，农夫丹位于 $N$ 号谷仓。\n\nConsider the following map:\n\n```cpp\n           [2]---\n          / |    \\\n         /1 |     \\ 6\n        /   |      \\\n     [1]   0|    --[3]\n        \\   |   /     \\2\n        4\\  |  /4      [6]\n          \\ | /       /1\n           [4]-----[5] \n                3  \n```\nThe best path for Farmer John to take is to go from 1 -> 2 -> 4 -> 5 -> 6, because it will cost him 1 + 0 + 3 + 1 = 5 treats.\n\nGiven FJ's map, what is the minimal number of treats that he should bring with him, given that he will feed each distinct cow he meets exactly one treat? He does not care about the length of his journey.\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Three space-separated integers: A\\_i, B\\_i, and C\\_i\n", "outputFormat": "\\* Line 1: The minimum number of treats that FJ must bring\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO11MAR] Package Delivery S", "background": "", "description": "Farmer John must deliver a package to Farmer Dan and is preparing to set out. To keep the peace, he gives a tasty treat to every cow he meets along the way, and since FJ is frugal, he wants to encounter as few cows as possible.\n\nFJ has a map of $N(1 \\le N \\le 50000)$ barns connected by $M(1 \\le M \\le 50000)$ bidirectional cow paths. Each path $i$ has $c[i](0 \\le c[i] \\le 1000)$ cows ambling along it. A cow path connects two distinct barns $a[i]$ and $b[i]$ with $1 \\le a[i] \\le N$, $1 \\le b[i] \\le N$, and $a[i] \\ne b[i]$. Two barns may be directly connected by more than one path. He is currently at barn $1$, and Farmer Dan is at barn $N$.\n\nConsider the following map:\n\n```cpp\n           [2]---\n          / |    \\\n         /1 |     \\ 6\n        /   |      \\\n     [1]   0|    --[3]\n        \\   |   /     \\2\n        4\\  |  /4      [6]\n          \\ | /       /1\n           [4]-----[5] \n                3  \n```\n\nThe best path for Farmer John is 1 -> 2 -> 4 -> 5 -> 6, because it will cost him 1 + 0 + 3 + 1 = 5 treats.\n\nGiven FJ’s map, what is the minimal number of treats he should bring, assuming he feeds each distinct cow he meets exactly one treat? He does not care about the length of his journey.", "inputFormat": "- Line 1: Two space-separated integers: N and M.\n- Lines 2 to M+1: Three space-separated integers: A_i, B_i, and C_i.", "outputFormat": "- Line 1: The minimum number of treats that FJ must bring.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO11MAR] Package Delivery S", "background": "", "description": "Farmer John must deliver a package to Farmer Dan, and is preparing to make his journey. To keep the peace, he gives a tasty treat to every cow that he meets along his way and, of course, FJ is so frugal that he would like to encounter as few cows as possible.\n\n农夫约翰必须送一个包裹给农夫丹，并准备去旅行。为了保持和平，他必须给每一头遇到的奶牛一些吃的，当然，FJ很节俭，他想可能遇到尽可能少的奶牛。\n\nFJ has plotted a map of N (1 <= N <= 50,000) barns, connected by M (1 <= M <= 50,000) bi-directional cow paths, each with C\\_i (0 <= C\\_i <= 1,000) cows ambling along it. A cow path connects two distinct barns, A\\_i and B\\_i (1 <= A\\_i <= N; 1 <= B\\_i <= N; A\\_i != B\\_i). Two barns may be directly connected by more than one path. He is currently located at barn 1, and Farmer Dan is located at barn N.\n\nFJ 已经绘制了 $N(1 \\le N \\le 50000)$ 个谷仓的地图，通过 $M(1 \\le M \\le 50000)$ 条双向牛道，每条双向牛道上有 $c[i](0 \\le c[i] \\le 1000)$ 奶牛漫步。双向牛道连接两个不同的谷仓，$a[i]$ 和 $b[i](1 \\le a[i] \\le N,1 \\le b[i] \\le N, a[i] \\neq b[i])$。两个谷仓可以由一条以上的小路直接连接。他目前在 $1$ 号谷仓，农夫丹位于 $N$ 号谷仓。\n\nConsider the following map:\n\n```cpp\n           [2]---\n          / |    \\\n         /1 |     \\ 6\n        /   |      \\\n     [1]   0|    --[3]\n        \\   |   /     \\2\n        4\\  |  /4      [6]\n          \\ | /       /1\n           [4]-----[5] \n                3  \n```\nThe best path for Farmer John to take is to go from 1 -> 2 -> 4 -> 5 -> 6, because it will cost him 1 + 0 + 3 + 1 = 5 treats.\n\nGiven FJ's map, what is the minimal number of treats that he should bring with him, given that he will feed each distinct cow he meets exactly one treat? He does not care about the length of his journey.\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Three space-separated integers: A\\_i, B\\_i, and C\\_i\n", "outputFormat": "\\* Line 1: The minimum number of treats that FJ must bring\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3021", "type": "P", "difficulty": 3, "samples": [["8 \n-3 0 \n-2 0 \n-1 1 \n0 3 \n2 0 \n-3 1 \n3 0 \n-2 2 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11MAR] Bovine Bridge Battle S", "background": "给定N（4 <= N <= 1,000）个整点的坐标 (-1,000,000,000 <= X\\_i <= 1,000,000,000; -1,000,000,000 <= Y\\_i <= 1,000,000,000，X\\_i，Y\\_i∈Z)，求card{{(X\\_a,Y\\_a),(X\\_b,Y\\_b),(X\\_c,Y\\_c),(X\\_d,Y\\_d)}|四点呈中心对称}\n", "description": "Each of Farmer John's N (4 <= N <= 1,000) cows is patiently waiting in the main pasture with cow i at point with integer coordinates (X\\_i, Y\\_i) (-1,000,000,000 <= X\\_i <= 1,000,000,000; -1,000,000,000 <= Y\\_i <= 1,000,000,000).\n\nThe cows wish to form into groups of four in order to play Bridge, their new favorite card game. Each group must satisfy an important constraint: four cows are allowed to team up if and only if there exists some point X somewhere in the plane (and not coincident with any of the four points of the potential group of four) such that rotating any of the group's cows 180 degrees about that point X gives the position of some other cow in the group.\n\nPlease help the cows determine the number of sets of four cows that can form a Bridge group.\n\nBy way of example, suppose eight cows are standing at eight points:\n\n|\nf\\*\n```cpp\n|             a = (-3, 1)    e = (-1, 1) \nb*     |             b = (-2, 2)    f = ( 0, 3) \na      e  |             c = (-3, 0)    g = ( 2, 0) \n*     *  |             d = (-2, 0)    h = ( 3, 0) \n```\nc  d     |     g  h\n---------\\*--\\*-----+-----\\*--\\*---------\n\n|\nThen the three legal sets of four cows are {a, b, e, d} (they rotate around point (-2, 1)), {b, c, e, f} (around the point (-1.5, 1.5)), and {c, d, g, h} (around (0,0)).\n\nThe supplied locations of the cows given are all distinct, although they are supplied in no particular order. Furthermore, the answer will fit into a signed 32-bit integer.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: X\\_i and Y\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the number of sets of 4 cows that form valid groups for bridge.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11MAR] Bovine Bridge Battle S", "background": "给定N（4 <= N <= 1,000）个整点的坐标 (-1,000,000,000 <= X\\_i <= 1,000,000,000; -1,000,000,000 <= Y\\_i <= 1,000,000,000，X\\_i，Y\\_i∈Z)，求card{{(X\\_a,Y\\_a),(X\\_b,Y\\_b),(X\\_c,Y\\_c),(X\\_d,Y\\_d)}|四点呈中心对称}\n", "description": "Each of Farmer John's N (4 <= N <= 1,000) cows is patiently waiting in the main pasture with cow i at point with integer coordinates (X\\_i, Y\\_i) (-1,000,000,000 <= X\\_i <= 1,000,000,000; -1,000,000,000 <= Y\\_i <= 1,000,000,000).\n\nThe cows wish to form into groups of four in order to play Bridge, their new favorite card game. Each group must satisfy an important constraint: four cows are allowed to team up if and only if there exists some point X somewhere in the plane (and not coincident with any of the four points of the potential group of four) such that rotating any of the group's cows 180 degrees about that point X gives the position of some other cow in the group.\n\nPlease help the cows determine the number of sets of four cows that can form a Bridge group.\n\nBy way of example, suppose eight cows are standing at eight points:\n\n|\nf\\*\n```cpp\n|             a = (-3, 1)    e = (-1, 1) \nb*     |             b = (-2, 2)    f = ( 0, 3) \na      e  |             c = (-3, 0)    g = ( 2, 0) \n*     *  |             d = (-2, 0)    h = ( 3, 0) \n```\nc  d     |     g  h\n---------\\*--\\*-----+-----\\*--\\*---------\n\n|\nThen the three legal sets of four cows are {a, b, e, d} (they rotate around point (-2, 1)), {b, c, e, f} (around the point (-1.5, 1.5)), and {c, d, g, h} (around (0,0)).\n\nThe supplied locations of the cows given are all distinct, although they are supplied in no particular order. Furthermore, the answer will fit into a signed 32-bit integer.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: X\\_i and Y\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the number of sets of 4 cows that form valid groups for bridge.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11MAR] Bovine Bridge Battle S", "background": "", "description": "Farmer John 的每头牛（共 $N$ 头，$4 \\le N \\le 1,000$）都耐心地在主牧场等待，其中第 $i$ 头牛位于整数坐标 $(X_i, Y_i)$ 上（$-1,000,000,000 \\le X_i \\le 1,000,000,000$，$-1,000,000,000 \\le Y_i \\le 1,000,000,000$）。\n\n这些牛希望组成四个一组，以便玩他们的新宠卡牌游戏「桥牌」。每组必须满足一个重要的约束条件：如果且仅如果在平面上存在某个点 $X$（并且不与潜在四牛组的任何四个点重合），使得围绕该点 $X$ 将组内任意一头牛旋转 $180$ 度后得到组内的另一头牛的位置，四头牛才可以组队。\n\n请帮助这些牛确定可以组成桥牌组的四牛组合的数量。\n\n例如，假设有八头牛分别站在八个点上：\n\n|\nf\\*\n```cpp\n|             a = (-3, 1)    e = (-1, 1) \nb*     |             b = (-2, 2)    f = ( 0, 3) \na      e  |             c = (-3, 0)    g = ( 2, 0) \n*     *  |             d = (-2, 0)    h = ( 3, 0) \n```\nc  d     |     g  h\n---------\\*--\\*-----+-----\\*--\\*---------\n\n|\n那么，三个合法的四牛组合是 {a, b, e, d}（它们围绕点 $(-2, 1)$ 旋转），{b, c, e, f}（围绕点 $(-1.5, 1.5)$），以及 {c, d, g, h}（围绕点 $(0,0)$）。\n\n提供的牛的位置都是不同的，尽管它们的顺序没有特定的规则。此外，答案将适合一个有符号的 32 位整数。\n", "inputFormat": "\\* 第 1 行：一个整数：$N$\n\n\\* 第 2 行到第 $N+1$ 行：第 $i+1$ 行包含两个用空格分隔的整数：$X_i$ 和 $Y_i$\n", "outputFormat": "\\* 第 1 行：一个整数，表示可以组成桥牌有效组的四牛组合的数量。\n", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3022", "type": "P", "difficulty": 5, "samples": [["4 4 \n1 2 \n2 3 \n3 1 \n3 4 \n", "3 \n2 \n3 \n4 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2011", "USACO", "Special Judge", "深度优先搜索 DFS", "树形 DP"], "title": "[USACO11OPEN] Odd degrees G", "background": "", "description": "The cows are being invaded! Their republic comprises N (1 <= N <= 50,000) towns that are connected by M (1 <= M <= 100,000) undirected paths between two towns A\\_i and B\\_i (1 <= A\\_i <= N; 1 <= B\\_i <= N; A\\_i != B\\_i; no duplicate paths will occur). However the republic is not necessarily connected--there may be pairs of towns that are unable to reach each other through the paths.\n\nThe cows know their invaders plan to conduct an inventory of every path within their republic, so they are willing to shut down various paths to make it as difficult as possible for their invaders to do so.\n\nPlease help the cows find a way to shut down a subset of the paths such that each town has an odd number of remaining paths connected to it, or determine if no such subset exists.\n\nFor example, consider the following cow republic: \n\n1---2\n\\ /\n3---4\nIf we keep the paths 1-3, 2-3, and 3-4, and remove the path 1-2, then towns 1, 2, and 4 will be an endpoint of exactly one path, whereas town 3 will be an endpoint of three paths:\n\n1   2\n\\ /\n3---4", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Line i+1 contains two space-separated integers: A\\_i and B\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the number of paths to keep. If no subset exists output only a single line with the integer -1.\n\n\\* Lines 2..K+1: Each line contains an index of an path to keep, in the range 1..M. These indices must be pairwise distinct.\n", "hint": "感谢@cn：苏卿念 提供的Special Judge", "locale": "en", "translations": {"en": {"title": "[USACO11OPEN] Odd degrees G", "background": "", "description": "The cows are being invaded! Their republic comprises N (1 <= N <= 50,000) towns that are connected by M (1 <= M <= 100,000) undirected paths between two towns A\\_i and B\\_i (1 <= A\\_i <= N; 1 <= B\\_i <= N; A\\_i != B\\_i; no duplicate paths will occur). However the republic is not necessarily connected--there may be pairs of towns that are unable to reach each other through the paths.\n\nThe cows know their invaders plan to conduct an inventory of every path within their republic, so they are willing to shut down various paths to make it as difficult as possible for their invaders to do so.\n\nPlease help the cows find a way to shut down a subset of the paths such that each town has an odd number of remaining paths connected to it, or determine if no such subset exists.\n\nFor example, consider the following cow republic: \n\n1---2\n\\ /\n3---4\nIf we keep the paths 1-3, 2-3, and 3-4, and remove the path 1-2, then towns 1, 2, and 4 will be an endpoint of exactly one path, whereas town 3 will be an endpoint of three paths:\n\n1   2\n\\ /\n3---4", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Line i+1 contains two space-separated integers: A\\_i and B\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the number of paths to keep. If no subset exists output only a single line with the integer -1.\n\n\\* Lines 2..K+1: Each line contains an index of an path to keep, in the range 1..M. These indices must be pairwise distinct.\n", "hint": "感谢@cn：苏卿念 提供的Special Judge", "locale": "en"}, "zh-CN": {"title": "[USACO11OPEN] Odd degrees G", "background": "", "description": "奶牛们正在遭受入侵！它们的共和国由 $N$ 个城镇组成（$1 \\leq N \\leq 50,000$），这些城镇通过 $M$ 条无向路径连接（$1 \\leq M \\leq 100,000$），每条路径连接两个城镇 $A_i$ 和 $B_i$（$1 \\leq A_i \\leq N$；$1 \\leq B_i \\leq N$；$A_i \neq B_i$；不会出现重复路径）。然而，共和国不一定是连通的——可能存在无法通过路径到达彼此的城镇对。\n\n奶牛们知道入侵者计划对它们共和国内的每一条路径进行清点，所以它们愿意关闭各种路径，以使入侵者的工作尽可能困难。\n\n请帮助奶牛们找到一种关闭路径子集的方法，使得每个城镇连接的剩余路径数为奇数，或者确定不存在这样的子集。\n\n例如，考虑以下的奶牛共和国：\n\n1---2\n\\ /\n3---4\n如果我们保留路径 1-3、2-3 和 3-4，并移除路径 1-2，那么城镇 1、2 和 4 将成为正好一条路径的端点，而城镇 3 将成为三条路径的端点：\n\n1   2\n\\ /\n3---4", "inputFormat": "\\* 第 1 行：两个用空格分隔的整数：$N$ 和 $M$\n\n\\* 第 2 行到第 $M+1$ 行：第 $i+1$ 行包含两个用空格分隔的整数：$A_i$ 和 $B_i$\n", "outputFormat": "\\* 第 1 行：一个整数，表示要保留的路径数量。如果不存在这样的子集，则仅输出一行，包含整数 -1。\n\n\\* 第 2 行到第 $K+1$ 行：每行包含一个要保留的路径的索引，范围为 1 到 $M$。这些索引必须两两不同。\n", "hint": "感谢 @cn：苏侨念 提供的 Special Judge（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3023", "type": "P", "difficulty": 6, "samples": [["6 \n1 2 \n1 3 \n1 4 \n1 5 \n1 6 \n", "7 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2011", "USACO", "斜率优化", "树形 DP"], "title": "[USACO11OPEN] Soldering G", "background": "", "description": "The cows are playing with wires! They have learned a technique called soldering, in which they connect two pieces of wire together by attaching the endpoint of one wire to a location along the length of the other. (Soldering endpoint to endpoint is not allowed.) There can be multiple solder junctions at the same point.\n\nThe cows have a plan for an Amazing Structure they would like to build. It is in the form of a graph with $N$($1 \\leq N \\leq 50,000$) nodes and $N - 1$ edges of unit length so that each pair of nodes is connected. Each edge is described by a pair of integers, $A$ and $B$($1 \\leq A \\leq N; 1 \\leq B \\leq N; A \\neq B$).\n\nThe cows are able to buy wire from a local store; however longer wire is more expensive. In particular the cows can buy a wire of length L with cost $L * L$, but they cannot cut wires or join wires together.\n\nGiven the plan, the cows would like solder wires together to build their Amazing Structure. Please help them find the minimum possible cost!", "inputFormat": "Line $1$: A single integer: $N$\n\nLines $2 \\sim N$: Two space-separated integers describing an edge: $A$ and $B$", "outputFormat": "Line $1$: A single integer, the cost of soldering the tree together. \n\n**Note that this number may not always fit in a 32-bit integer.**", "hint": "Since all nodes in the structure are connected to node $1$, we only need to buy one wire of length $2$ and three of length $1$, for a total cost of $2 * 2 + 1 * 1 + 1 * 1 + 1 * 1 = 7$.\n\nTest data worth at least $50\\%$ of the points will have $N \\leq 2,000$.", "locale": "en", "translations": {"en": {"title": "[USACO11OPEN] Soldering G", "background": "", "description": "The cows are playing with wires! They have learned a technique called soldering, in which they connect two pieces of wire together by attaching the endpoint of one wire to a location along the length of the other. (Soldering endpoint to endpoint is not allowed.) There can be multiple solder junctions at the same point.\n\nThe cows have a plan for an Amazing Structure they would like to build. It is in the form of a graph with $N$($1 \\leq N \\leq 50,000$) nodes and $N - 1$ edges of unit length so that each pair of nodes is connected. Each edge is described by a pair of integers, $A$ and $B$($1 \\leq A \\leq N; 1 \\leq B \\leq N; A \\neq B$).\n\nThe cows are able to buy wire from a local store; however longer wire is more expensive. In particular the cows can buy a wire of length L with cost $L * L$, but they cannot cut wires or join wires together.\n\nGiven the plan, the cows would like solder wires together to build their Amazing Structure. Please help them find the minimum possible cost!", "inputFormat": "Line $1$: A single integer: $N$\n\nLines $2 \\sim N$: Two space-separated integers describing an edge: $A$ and $B$", "outputFormat": "Line $1$: A single integer, the cost of soldering the tree together. \n\n**Note that this number may not always fit in a 32-bit integer.**", "hint": "Since all nodes in the structure are connected to node $1$, we only need to buy one wire of length $2$ and three of length $1$, for a total cost of $2 * 2 + 1 * 1 + 1 * 1 + 1 * 1 = 7$.\n\nTest data worth at least $50\\%$ of the points will have $N \\leq 2,000$.", "locale": "en"}, "zh-CN": {"title": "[USACO11OPEN] Soldering G", "background": null, "description": "奶牛决定用电线焊接出一张图，这张图是连通的，由 $N$ 个点，$N-1$ 条边组成，每条边的长度都是 $1$。焊接所用的电线要从当地的商店里买。越长的电线越贵，一条长度为 $L$ 的电线售价为 $L^2$。奶牛们已经学会了基本的焊接方法，她们会把某条电线的一个端点焊接到另一条电线的中间某个位置，但她们没有学会如何把两条电线的端点直接焊接起来，也没有学会怎么把电线剪断。给定奶牛准备焊接的图，请告诉奶牛怎么焊接才能最节约材料费用。", "inputFormat": "第 $1$ 行：一个整数 $N$。\n\n第 $2 \\sim N$ 行：描述边的两个以空格分隔的整数：$A$ 和 $B$。", "outputFormat": "第 $1$ 行：一个整数，将树焊接在一起的成本。\n\n**请注意，此数字可能并不总是适合32位整数。**", "hint": "由于结构中的所有节点都连接到节点 $1$，我们只需要购买一根长度为 $2$ 的电线和三根长度为 $1$ 的电线，总成本为 $2 * 2 + 1 * 1 + 1 * 1 + 1 * 1 = 7$。\n\n对于至少 $50\\%$ 的测试数据，有 $N \\leq 2,000$。", "locale": "zh-CN"}}}
{"pid": "P3024", "type": "P", "difficulty": 5, "samples": [["3 3 \n1 \n1 1 \n", "Bessie \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "博弈论", "2011", "USACO", "排序"], "title": "[USACO11OPEN] Cow Checkers S", "background": null, "description": "有一天，Bessie 准备玩一个叫做奶牛跳棋的游戏，来挑战 Farmer John。这个游戏的棋盘大小为 $M\\times N$。\n\n最初棋盘上只有一个棋子在 $(X,Y)$，棋盘的左下角坐标是 $(0,0)$，右上角的坐标是 $(M-1,N-1)$。每次游戏 Bessie 都是先手，之后两个人轮流进行操作。每次操作可以在以下三种移动中选择一种：\n\n1. 向左走任意步。\n\n2. 向下走任意步。\n\n3. 向左走 $k$ 步然后向下走 $k$ 步（$k$ 为任意能保证不走出棋盘的正整数）。\n\n首个无法操作的人为败者。\n\n游戏共有 $T$ 次，每次都会给出一个新的坐标 $(X,Y)$，请输出每一轮胜者的名字。", "inputFormat": "第 $1$ 行，两个用空格隔开的正整数，代表 $M$ 和 $N$。\n\n第 $2$ 行，一个正整数代表 $T$。\n\n第 $3$ 行到第 $(T+2)$ 行，分别有两个空格隔开的非负整数，代表 $X,Y$。", "outputFormat": "共 $T$ 行，每一行输出那一轮的胜者。", "hint": "**【数据范围】**\n\n保证 $1\\le M,N\\le 10^6$，$0 \\le X < M$，$0 \\le Y < N$，$1\\le T\\le10^3$。\n\n**【样例解释 #1】**\n\n起点在 $(1,1)$，一开始有三种选择 $(1,0)$、$(0,1)$、$(0,0)$。只要 Bessie 在开始时将棋子移到 $(0,0)$，就必胜无疑。\n\n感谢 @[\\_Trangle\\_](/user/768144) 提供的翻译。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO11OPEN] Cow Checkers S", "background": null, "description": "One day, Bessie decides to challenge Farmer John to a game of 'Cow Checkers'. The game is played on an M\\*N (1 <= M <= 1,000,000; 1 <= N <= 1,000,000) checkerboard that initially contains a single checker piece on the checkboard square coordinates (X, Y) (0 <= X < M; 0 <= Y < N). The bottom leftmost square of the checkerboard has\n\ncoordinates (0, 0), and the top rightmost square has coordinates (M-1, N-1). Bessie always moves first, and then the two players alternate turns.  Each turn comprises one of three types of moves:\n\n1) Move the checker piece to any square on the same row to the left of its current position.\n\n2) Move the checker piece to any square on the same column below its current position.\n\n3) Move the checker piece to any spot k squares below and k squares to the left of the current square (where k is any positive integer such that this new spot is still on the checkerboard).\n\nThe first player unable to make a move (i.e., because the checker is at (0, 0)) loses. Given that Bessie always goes first, determine who will win the game if both play optimally.\n\nPlay and report the winner for T games (1 <= T <= 1,000) reading in a new X,Y starting value for each new game.", "inputFormat": "\\* Line 1: Two space-separated integers: M and N\n\n\\* Line 2: A single integer: T\n\n\\* Lines 3..T+2: Two space-separated integers: X and Y", "outputFormat": "\\* Lines 1..T: Should contain either 'Farmer John' or 'Bessie' depending on who wins each  game.", "hint": "Farmer John and Bessie are playing one game on a 3\\*3 checkerboard with the checker piece initially at (1, 1) (i.e. at the center of the board).\n\n\nBessie initially can only move the checker piece to either (1, 0) or (0, 1), or (0, 0). Bessie can immediately win by moving the piece to (0, 0).", "locale": "en"}, "zh-CN": {"title": "[USACO11OPEN] Cow Checkers S", "background": null, "description": "有一天，Bessie 准备玩一个叫做奶牛跳棋的游戏，来挑战 Farmer John。这个游戏的棋盘大小为 $M\\times N$。\n\n最初棋盘上只有一个棋子在 $(X,Y)$，棋盘的左下角坐标是 $(0,0)$，右上角的坐标是 $(M-1,N-1)$。每次游戏 Bessie 都是先手，之后两个人轮流进行操作。每次操作可以在以下三种移动中选择一种：\n\n1. 向左走任意步。\n\n2. 向下走任意步。\n\n3. 向左走 $k$ 步然后向下走 $k$ 步（$k$ 为任意能保证不走出棋盘的正整数）。\n\n首个无法操作的人为败者。\n\n游戏共有 $T$ 次，每次都会给出一个新的坐标 $(X,Y)$，请输出每一轮胜者的名字。", "inputFormat": "第 $1$ 行，两个用空格隔开的正整数，代表 $M$ 和 $N$。\n\n第 $2$ 行，一个正整数代表 $T$。\n\n第 $3$ 行到第 $(T+2)$ 行，分别有两个空格隔开的非负整数，代表 $X,Y$。", "outputFormat": "共 $T$ 行，每一行输出那一轮的胜者。", "hint": "**【数据范围】**\n\n保证 $1\\le M,N\\le 10^6$，$0 \\le X < M$，$0 \\le Y < N$，$1\\le T\\le10^3$。\n\n**【样例解释 #1】**\n\n起点在 $(1,1)$，一开始有三种选择 $(1,0)$、$(0,1)$、$(0,0)$。只要 Bessie 在开始时将棋子移到 $(0,0)$，就必胜无疑。\n\n感谢 @[\\_Trangle\\_](/user/768144) 提供的翻译。", "locale": "zh-CN"}}}
{"pid": "P3025", "type": "P", "difficulty": 5, "samples": [["15 6 \na??l?ban??????? \napple \ncow \nfarmer \nbanana \nbananas \npies \n", "applebananapies \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11OPEN] Forgotten Password S", "background": "", "description": "就像在我们身上经常发生的那样，Bessie 又一次忘记了她的牛场管理员密码，她只能记得密码的一部分。\n\n首先，她记得密码 $P$ 是长度为 $L$（$1 \\le L \\le 1000$）的字符串，并且她的密码中出现过的所有单词都记录在她的共有 $NW$（$1 \\le NW \\le 1000$）个单词的字典中，每个字典中的单词 $W_i$ 都是由 $1$ 至 $20$ 个小写拉丁字母组成的。\n\n她只记得密码中的一部分字母和它的位置。例如，Bessie 记得她的密码为 `a??l?ban???????`，其中，`?` 是她忘记的字母。她的字典中有这些单词：`apple cow farmer banana bananas pies`。所以，Bessie 的密码的两种可能是`applebananapies` 和 `applebananascow`.\n\n现在，给你 Bessie 还记得的字母和她的字典，求可能的密码。如果有多个答案，则输出字典序最小的那一个。", "inputFormat": "第一行输入她密码的长度 $L$ 和字典中的单词数量 $NW$，用一个空格隔开。\n\n第二行输入长为 $L$ 的字符串 $P$。\n\n此后 $NW$ 行，每行输入一个字符串 $W_i$。", "outputFormat": "只输出一行：Bessie 的密码。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO11OPEN] Forgotten Password S", "background": "", "description": "As often happens to us, Bessie has once again forgotten her barn manager password. She can only remember part of it.\n\nFirst, she remembers that the password $P$ is a string of length $L$ ($1 \\le L \\le 1000$), and that the password is formed by concatenating one or more words, each of which is recorded in her dictionary of $NW$ ($1 \\le NW \\le 1000$) words. Every dictionary word $W_i$ consists of $1$ to $20$ lowercase Latin letters.\n\nShe only remembers some letters in the password and their positions. For example, Bessie remembers her password as `a??l?ban???????`, where `?` stands for a letter she forgot. Her dictionary contains these words: `apple cow farmer banana bananas pies`. Therefore, two possible passwords for Bessie are `applebananapies` and `applebananascow`.\n\nNow, given the letters Bessie still remembers and her dictionary, find a possible password. If there are multiple answers, output the lexicographically smallest one.", "inputFormat": "The first line contains the length $L$ of her password and the number of words $NW$ in the dictionary, separated by a space.\n\nThe second line contains the string $P$ of length $L$.\n\nThen follow $NW$ lines, each containing a string $W_i$.", "outputFormat": "Output exactly one line: Bessie’s password.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO11OPEN] Forgotten Password S", "background": "", "description": "就像在我们身上经常发生的那样，Bessie 又一次忘记了她的牛场管理员密码，她只能记得密码的一部分。\n\n首先，她记得密码 $P$ 是长度为 $L$（$1 \\le L \\le 1000$）的字符串，并且她的密码中出现过的所有单词都记录在她的共有 $NW$（$1 \\le NW \\le 1000$）个单词的字典中，每个字典中的单词 $W_i$ 都是由 $1$ 至 $20$ 个小写拉丁字母组成的。\n\n她只记得密码中的一部分字母和它的位置。例如，Bessie 记得她的密码为 `a??l?ban???????`，其中，`?` 是她忘记的字母。她的字典中有这些单词：`apple cow farmer banana bananas pies`。所以，Bessie 的密码的两种可能是`applebananapies` 和 `applebananascow`.\n\n现在，给你 Bessie 还记得的字母和她的字典，求可能的密码。如果有多个答案，则输出字典序最小的那一个。", "inputFormat": "第一行输入她密码的长度 $L$ 和字典中的单词数量 $NW$，用一个空格隔开。\n\n第二行输入长为 $L$ 的字符串 $P$。\n\n此后 $NW$ 行，每行输入一个字符串 $W_i$。", "outputFormat": "只输出一行：Bessie 的密码。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3026", "type": "P", "difficulty": 5, "samples": [["3 3 \n2 3 2 \n1 2 \n1 1 \n", "1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11OPEN] Learning Languages S", "background": "", "description": "Farmer John's N (2 <= N <= 10,000) cows, conveniently numbered 1..N, are fluent in some M (1 <= M <= 30,000) languages, also conveniently numbered from 1..M. Cow i can speak in K\\_i (1 <= K\\_i <= M) languages, namely L\\_i1, L\\_i2,..., L\\_{iK\\_i} (1 <= L\\_ij <= M). FJ's cows aren't THAT smart, so the sum of K\\_i over all cows i is at most 100,000.\n\nTwo cows can't directly talk to each other unless both speak a common language. However, cows can pass messages along, translating if necessary. In other words, cows A and B can have a conversation if and only if there exists a sequence of cows T\\_1, T\\_2, ..., T\\_k such that A and T\\_1 share a language, T\\_1 and T\\_2 share a language, etc., and T\\_k and B share a language.\n\nFarmer John wishes that his cows could be even more social, so he wants all his cows to be able to socialize with any other cow. He can buy books to teach any one of his cows any language he pleases. Being a fairly frugal farmer, FJ wants to purchase the minimum number of books necessary to enable all of his cows to speak to each other. Help him determine:\n\n\\* The minimum number of books he must purchase\n\n\\* Any set of books assigned to cows in any order which will help him meet this goal; a program will grade your output.\n\nBy way of example, suppose there are three cows named Alberta, Bessie, and Contessa along with three languages denoted as #1, #2, and #3. Alberta can speak languages #2 and #3, Bessie can speak language #2, and Contessa can speak language #1. Currently, Alberta and Bessie can talk to each other, but Contessa is left alone.\n\n```\n#1   #2   #3\nAlberta           x    x\nBessie            x\nContessa     x\n```\nFJ wants to fix this situation, so he can buy Contessa a book to teach her language #2. This will ensure all cows speak the same language, so they can all communicate with one another.\n\nNote that an alternate solution exists: instead, FJ could buy\n\nContessa a book to teach her language #3. Not all cows would speak the same language, but this would still be a valid solution because Contessa could communicate through Alberta (who also speaks language #3) if she wants to talk to Bessie. Other alternatives exist, and any valid alternate solution will also be accepted.\n\n农夫约翰的$N(2<=N<=10,000)$只奶牛标号为$1..N$，同样的有$M(1<=M<=30,000)$种牛语标号为$1..M$，第i只奶牛会说$K_i(1<=K_i<=M)$种牛语，分别为$L_i1,L_i2,…,L_{iK_i}(1<=L_ij<=M)$，农夫的奶牛不是特别聪明，所以$K_i$的累加和不大于$100,000$。\n\n两只奶牛只有当他们至少有一门语言一样的时候才可以沟通。否则这两只奶牛就需要别人来帮他们翻译才能交流。换句话说，A和B要进行沟通，他们可以通过$T_1,T_2,…,T_k$来传递，比如A和$T_1,T_1$和$T_2,…,T_k$和B进行交流。\n\n农夫希望他的奶牛可以多多沟通，所以他买了很多课本去教她的奶牛语言。当然农夫非常的吝啬，他希望买最少的书就可以让所有的奶牛可以交流。你的任务就是帮他算出最少需要买几本书。\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 describes the languages that cow i can speak with $(K_i)+1$ space-separated integers: $K_i$, $L_i1$,\n\nL\\_i2,...,L\\_i{K\\_i}. \n\n", "outputFormat": "\\* Line 1: A single integer that is the minimum number of books that FJ must purchase.\n\n\\* Lines 2..B+1: Line i+1 contains two space-separated integers: the language id # and the id # of the cow to receive book i. If multiple solutions exist, print any one.\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO11OPEN] Learning Languages S", "background": "", "description": "Farmer John's $N$ ($2 \\le N \\le 10{,}000$) cows, conveniently numbered $1..N$, are fluent in some $M$ ($1 \\le M \\le 30{,}000$) languages, also conveniently numbered $1..M$. Cow $i$ can speak $K_i$ ($1 \\le K_i \\le M$) languages, namely $L_{i1}, L_{i2}, ..., L_{i K_i}$ ($1 \\le L_{ij} \\le M$). FJ's cows are not that smart, so the sum of $K_i$ over all cows $i$ is at most $100{,}000$.\n\nTwo cows cannot directly talk to each other unless they both speak a common language. However, cows can pass messages along, translating if necessary. In other words, cows $A$ and $B$ can have a conversation if and only if there exists a sequence of cows $T_1, T_2, ..., T_k$ such that $A$ and $T_1$ share a language, $T_1$ and $T_2$ share a language, ..., and $T_k$ and $B$ share a language.\n\nFarmer John wants all his cows to be able to socialize with any other cow. He can buy books to teach any one of his cows any language he pleases. Being frugal, FJ wants to purchase the minimum number of books necessary to enable all of his cows to speak to each other. Help him determine:\n- The minimum number of books he must purchase.\n- Any set of books assigned to cows, in any order, that will achieve this goal; a program will grade your output.\n\nBy way of example, suppose there are three cows named Alberta, Bessie, and Contessa along with three languages denoted as #1, #2, and #3. Alberta can speak languages #2 and #3, Bessie can speak language #2, and Contessa can speak language #1. Currently, Alberta and Bessie can talk to each other, but Contessa is left alone.\n\n```\n#1   #2   #3\nAlberta           x    x\nBessie            x\nContessa     x\n```\nFJ wants to fix this situation, so he can buy Contessa a book to teach her language #2. This will ensure all cows speak the same language, so they can all communicate with one another.\n\nNote that an alternate solution exists: instead, FJ could buy Contessa a book to teach her language #3. Not all cows would speak the same language, but this would still be a valid solution because Contessa could communicate through Alberta (who also speaks language #3) if she wants to talk to Bessie. Other alternatives exist, and any valid alternate solution will also be accepted.", "inputFormat": "* Line 1: Two space-separated integers: $N$ and $M$.\n* Lines $2..N+1$: Line $i+1$ describes the languages that cow $i$ can speak with $K_i + 1$ space-separated integers: $K_i$, $L_{i1}$, $L_{i2}$, ..., $L_{i K_i}$.", "outputFormat": "* Line 1: A single integer that is the minimum number of books that FJ must purchase.\n* Lines $2..B+1$: Line $i+1$ contains two space-separated integers: the language id and the id of the cow to receive book $i$, where $B$ is the number printed on line 1. If multiple solutions exist, print any one.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO11OPEN] Learning Languages S", "background": "", "description": "Farmer John's N (2 <= N <= 10,000) cows, conveniently numbered 1..N, are fluent in some M (1 <= M <= 30,000) languages, also conveniently numbered from 1..M. Cow i can speak in K\\_i (1 <= K\\_i <= M) languages, namely L\\_i1, L\\_i2,..., L\\_{iK\\_i} (1 <= L\\_ij <= M). FJ's cows aren't THAT smart, so the sum of K\\_i over all cows i is at most 100,000.\n\nTwo cows can't directly talk to each other unless both speak a common language. However, cows can pass messages along, translating if necessary. In other words, cows A and B can have a conversation if and only if there exists a sequence of cows T\\_1, T\\_2, ..., T\\_k such that A and T\\_1 share a language, T\\_1 and T\\_2 share a language, etc., and T\\_k and B share a language.\n\nFarmer John wishes that his cows could be even more social, so he wants all his cows to be able to socialize with any other cow. He can buy books to teach any one of his cows any language he pleases. Being a fairly frugal farmer, FJ wants to purchase the minimum number of books necessary to enable all of his cows to speak to each other. Help him determine:\n\n\\* The minimum number of books he must purchase\n\n\\* Any set of books assigned to cows in any order which will help him meet this goal; a program will grade your output.\n\nBy way of example, suppose there are three cows named Alberta, Bessie, and Contessa along with three languages denoted as #1, #2, and #3. Alberta can speak languages #2 and #3, Bessie can speak language #2, and Contessa can speak language #1. Currently, Alberta and Bessie can talk to each other, but Contessa is left alone.\n\n```\n#1   #2   #3\nAlberta           x    x\nBessie            x\nContessa     x\n```\nFJ wants to fix this situation, so he can buy Contessa a book to teach her language #2. This will ensure all cows speak the same language, so they can all communicate with one another.\n\nNote that an alternate solution exists: instead, FJ could buy\n\nContessa a book to teach her language #3. Not all cows would speak the same language, but this would still be a valid solution because Contessa could communicate through Alberta (who also speaks language #3) if she wants to talk to Bessie. Other alternatives exist, and any valid alternate solution will also be accepted.\n\n农夫约翰的$N(2<=N<=10,000)$只奶牛标号为$1..N$，同样的有$M(1<=M<=30,000)$种牛语标号为$1..M$，第i只奶牛会说$K_i(1<=K_i<=M)$种牛语，分别为$L_i1,L_i2,…,L_{iK_i}(1<=L_ij<=M)$，农夫的奶牛不是特别聪明，所以$K_i$的累加和不大于$100,000$。\n\n两只奶牛只有当他们至少有一门语言一样的时候才可以沟通。否则这两只奶牛就需要别人来帮他们翻译才能交流。换句话说，A和B要进行沟通，他们可以通过$T_1,T_2,…,T_k$来传递，比如A和$T_1,T_1$和$T_2,…,T_k$和B进行交流。\n\n农夫希望他的奶牛可以多多沟通，所以他买了很多课本去教她的奶牛语言。当然农夫非常的吝啬，他希望买最少的书就可以让所有的奶牛可以交流。你的任务就是帮他算出最少需要买几本书。\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 describes the languages that cow i can speak with $(K_i)+1$ space-separated integers: $K_i$, $L_i1$,\n\nL\\_i2,...,L\\_i{K\\_i}. \n\n", "outputFormat": "\\* Line 1: A single integer that is the minimum number of books that FJ must purchase.\n\n\\* Lines 2..B+1: Line i+1 contains two space-separated integers: the language id # and the id # of the cow to receive book i. If multiple solutions exist, print any one.\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3027", "type": "P", "difficulty": 3, "samples": [["3 17 \n2 4 \n5 6 \n3 7 \n", "22 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "USACO", "背包 DP"], "title": "[USACO10OCT] Making Money G", "background": "", "description": "FJ has gone into the curio business, buying and selling knickknacks like cow Christmas tree ornaments. He knows he will sell every single curio he can stock from a catalog of N (1 <= N <= 100)\n\ndifferent cow curios, and he can buy as many of each kind of curio as his heart desires. He has only M (1 <= M <= 100,000) money to invest but wants to maximize his profit (which has a slightly unusual definition) at the end of his first year in business.\n\nCurio type i costs C\\_i (1 <= C\\_i <= 100,000) money to purchase and yields R\\_i (1 <= R\\_i <= 100,000) revenue for each curio sold (a profit of R\\_i-C\\_i). FJ can mix and match the curios he sells in any way he wishes. He need not spend all his money when purchasing curios.\n\nWhat is the greatest amount of total profit (profit = initial\\_cash - all\\_costs + all\\_sales) FJ can have at the end of his first year? This number is guaranteed to be less than 1,000,000,000.\n\nConsider the situation when FJ has just 3 kinds of curios and starts with M=17. Below are the cost and revenue numbers for each curio:\n\nCurio     Cost     Revenue\n\n#        C\\_i       R\\_i\n\n1         2         4\n\n2         5         6\n\n3         3         7\n\nIn this case, FJ should purchase 5 curios of type 3 for 15 money and 1 more curio of type 1 for 2 money, a total of 17 money. His profit will be 5 \\* (7-3) + 1 \\* (4-2) = 5\\*4 + 1\\*2 = 22 money. He can do no better than this given the cost and revenue structure.\n\nNOTE: The second test case is challenging -- but our answer is correct.\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: C\\_i and R\\_i\n", "outputFormat": "\\* Line 1: The maximum profit FJ can generate given the costs and revenues\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10OCT] Making Money G", "background": "", "description": "FJ has gone into the curio business, buying and selling knickknacks like cow Christmas tree ornaments. He knows he will sell every single curio he can stock from a catalog of N (1 <= N <= 100)\n\ndifferent cow curios, and he can buy as many of each kind of curio as his heart desires. He has only M (1 <= M <= 100,000) money to invest but wants to maximize his profit (which has a slightly unusual definition) at the end of his first year in business.\n\nCurio type i costs C\\_i (1 <= C\\_i <= 100,000) money to purchase and yields R\\_i (1 <= R\\_i <= 100,000) revenue for each curio sold (a profit of R\\_i-C\\_i). FJ can mix and match the curios he sells in any way he wishes. He need not spend all his money when purchasing curios.\n\nWhat is the greatest amount of total profit (profit = initial\\_cash - all\\_costs + all\\_sales) FJ can have at the end of his first year? This number is guaranteed to be less than 1,000,000,000.\n\nConsider the situation when FJ has just 3 kinds of curios and starts with M=17. Below are the cost and revenue numbers for each curio:\n\nCurio     Cost     Revenue\n\n#        C\\_i       R\\_i\n\n1         2         4\n\n2         5         6\n\n3         3         7\n\nIn this case, FJ should purchase 5 curios of type 3 for 15 money and 1 more curio of type 1 for 2 money, a total of 17 money. His profit will be 5 \\* (7-3) + 1 \\* (4-2) = 5\\*4 + 1\\*2 = 22 money. He can do no better than this given the cost and revenue structure.\n\nNOTE: The second test case is challenging -- but our answer is correct.\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: C\\_i and R\\_i\n", "outputFormat": "\\* Line 1: The maximum profit FJ can generate given the costs and revenues\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10OCT] Making Money G", "background": null, "description": "FJ 又经营起了古董生意，买卖一些像奶牛圣诞树上的装饰之类的小玩意。他知道他会将他能存储的 $N(1 \\le N \\le 100)$ 件不同的奶牛古董每件都卖出。\n\n\n而且如果他的钱足够多他可以买他想要的任意数量的古董（即他可以购买的古董数量没有限制）。他只有 $M(1\\le M\\le 10^5)$ 元钱来买古董，但他想要在他经商的第一年年末最大化他的利润（这有点难以解释）。\n\n\n第 $i$ 种古董采购需要花费 $C_i(1\\le C_i \\le 10^5)$ 元钱，每卖掉一件可以获得 $R_i(1\\le R_i \\le 10^5)$ 元钱（每卖一件的利润为 $R_i-C_i$）。FJ 可以以任意顺序卖出他的货物。他并不需要花光他所有的钱来购买古董。\n\n\nFJ 在他经商的第一年年末能得到的最大总利润（利润 = 初始钱数 - 总花费 + 总收入）是多少呢？输入数据保证这个数字不会超过 $10^9$。\n\n\n假设 FJ 只有 $3$ 种古董而且开始时有 $M=17$ 元钱。下面是三种古董的花费和收入。\n\n\n| 古董 | 花费 | 收入 |\n|:---:|:---:|:---:|\n| 1 | 2 | 4 |\n| 2 | 5 | 6 |\n| 3 | 3 | 7 |\n\n在这种情况下，FJ 应该花 $15$ 元购买 $5$ 个 $3$ 号古董，再花 $2$ 元购买 $1$ 个 $1$ 号古董，总共 $17$ 元。他的利润是 $5\\times(7-3)+1\\times(4-2)=5\\times4+1\\times2=22$ 元。他不能获得比这更多的利润了。\n\n\n提示：第二个样例很有挑战性，但我们的答案是正确的。", "inputFormat": "* 第 $1$ 行：两个用空格分隔的整数：$N$ 和 $M$。\n* 第 $2$ 行到第 $N+1$ 行：第 $i+1$ 行包含两个用空格分隔的整数：$C_i$ 和 $R_i$。", "outputFormat": "* 第 $1$ 行：FJ 在给定成本和收入的情况下可以产生的最大利润。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
