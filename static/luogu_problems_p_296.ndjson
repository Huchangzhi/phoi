{"pid": "P6990", "type": "P", "difficulty": 0, "samples": [["23 4 3 5 7 11\n3\neffde7\nc07902\n0800c1\n3 2 4 6\n", "2 0 2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Filter", "background": "", "description": "\n\nYou are working on a new high-performance database engine -- Instant Compression and Processing Codec $(ICPC).$ ICPC stores user activity records. Each user activity record has an integer user identifier. The records are stored in a number of data files. Each data file is compressed and can contain records from multiple users, however ICPC has to process queries that look for a specific subsets of users. In order to do so, there has to be a way to quickly determine which data files may contain records for a specific user before attempting to decompress them, which may be a long and CPU-consuming process.\n\nICPC uses an algorithm called Bloom Filter. The way it is implemented in ICPC is described below. For each ICPC database the following integer parameters are chosen:\n\n$m$ is the number of bits in the filter;\n\n$f$ is the number of hash functions in the filter;\n\n$a_{i}$ are the parameters for hash functions for $0 \\le i$\n\nA value of the bloom filter is computed for each data file. The data file's bloom filter is a vector of $m$ bits. A bit number $j (0 \\le j < m)$ is set to one if and only if there is a record in this data file for some user identifier $u_{k},$ such that for some hash function $i (0 \\le i < f)$ the following equality holds:\n\n$j = (u_{k} · a_{i})$ mod $m$ (1)\n\nYour task is to implement ICPC filtering logic. You are given filter parameters and values for a number of data files and a set of user identifiers. Your task is determine which data files may contain record with at least one user identifier from the specified set. A data file may contain a record with a user identifier $u_{k}$ if and only if for all $i (0 \\le i < f)$ all the bits $j$ given by equality (1) in its filter value are set to one.\n\n", "inputFormat": "\n\nThe first line of the input file contains filter parameters -- integer numbers $m , f$ , and $a_{i}$ for $0 \\le i < f (1 \\le m \\le 1000 , 1 \\le f \\le 100 , 1 \\le a_{i} < 2^{31}).$\n\nThe second line of the input file contains an integer $n$ -- the number of data files $(1 \\le n \\le 1000)$ . Each of the following $n$ lines contains bloom filter value of the corresponding file in hexadecimal form. Each value is represented by a string of $⌈m/4⌉$ hexadecimal digits (one of $0123456789abcdef).$ The first digit of the string represents bits $0-3$ of the value (stored in order from the least significant bit of a hexadecimal digit to the most significant bit), the second digit -- bits $4-7$ , the third -- $8-11$ , etc. When $m$ mod $4 ≠ 0$ , then the last hexadecimal digit represents the last $m$ mod $4$ bits of the value in its least significant bits.\n\nThe following line of the input file contains an integer $q$ -- the number of user identifiers in a query $(1 \\le q \\le 1000)$ , followed by $q$ integers $u_{k}$ -- the set of distinct user identifiers in the query $(1 \\le u_{k} < 2^{31}).$\n\n", "outputFormat": "\n\nWrite a line with the integer number $s$ to the output file -- the number of data files that may contain a record with at least one user identifier from the specified set, followed by $s$ numbers $d_{t} (0 \\le d_{t} < n)$ -- the $0-based$ numbers of the corresponding data files in ascending order.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Filter", "background": "", "description": "\n\nYou are working on a new high-performance database engine -- Instant Compression and Processing Codec $(ICPC).$ ICPC stores user activity records. Each user activity record has an integer user identifier. The records are stored in a number of data files. Each data file is compressed and can contain records from multiple users, however ICPC has to process queries that look for a specific subsets of users. In order to do so, there has to be a way to quickly determine which data files may contain records for a specific user before attempting to decompress them, which may be a long and CPU-consuming process.\n\nICPC uses an algorithm called Bloom Filter. The way it is implemented in ICPC is described below. For each ICPC database the following integer parameters are chosen:\n\n$m$ is the number of bits in the filter;\n\n$f$ is the number of hash functions in the filter;\n\n$a_{i}$ are the parameters for hash functions for $0 \\le i$\n\nA value of the bloom filter is computed for each data file. The data file's bloom filter is a vector of $m$ bits. A bit number $j (0 \\le j < m)$ is set to one if and only if there is a record in this data file for some user identifier $u_{k},$ such that for some hash function $i (0 \\le i < f)$ the following equality holds:\n\n$j = (u_{k} · a_{i})$ mod $m$ (1)\n\nYour task is to implement ICPC filtering logic. You are given filter parameters and values for a number of data files and a set of user identifiers. Your task is determine which data files may contain record with at least one user identifier from the specified set. A data file may contain a record with a user identifier $u_{k}$ if and only if for all $i (0 \\le i < f)$ all the bits $j$ given by equality (1) in its filter value are set to one.\n\n", "inputFormat": "\n\nThe first line of the input file contains filter parameters -- integer numbers $m , f$ , and $a_{i}$ for $0 \\le i < f (1 \\le m \\le 1000 , 1 \\le f \\le 100 , 1 \\le a_{i} < 2^{31}).$\n\nThe second line of the input file contains an integer $n$ -- the number of data files $(1 \\le n \\le 1000)$ . Each of the following $n$ lines contains bloom filter value of the corresponding file in hexadecimal form. Each value is represented by a string of $⌈m/4⌉$ hexadecimal digits (one of $0123456789abcdef).$ The first digit of the string represents bits $0-3$ of the value (stored in order from the least significant bit of a hexadecimal digit to the most significant bit), the second digit -- bits $4-7$ , the third -- $8-11$ , etc. When $m$ mod $4 ≠ 0$ , then the last hexadecimal digit represents the last $m$ mod $4$ bits of the value in its least significant bits.\n\nThe following line of the input file contains an integer $q$ -- the number of user identifiers in a query $(1 \\le q \\le 1000)$ , followed by $q$ integers $u_{k}$ -- the set of distinct user identifiers in the query $(1 \\le u_{k} < 2^{31}).$\n\n", "outputFormat": "\n\nWrite a line with the integer number $s$ to the output file -- the number of data files that may contain a record with at least one user identifier from the specified set, followed by $s$ numbers $d_{t} (0 \\le d_{t} < n)$ -- the $0-based$ numbers of the corresponding data files in ascending order.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Filter", "background": "", "description": "你正在开发一个新的高性能数据库引擎——即时压缩和处理编解码器（Instant Compression and Processing Codec，ICPC）。ICPC 存储用户活动记录。每条用户活动记录都有一个整数用户标识符。记录存储在多个数据文件中。每个数据文件都是压缩的，可以包含来自多个用户的记录，然而 ICPC 必须处理查询以查找特定的用户子集。为此，必须有一种方法可以快速确定哪些数据文件可能包含特定用户的记录，然后再尝试解压它们，因为这可能是一个耗时且消耗 CPU 的过程。\n\nICPC 使用一种称为布隆过滤器的算法。ICPC 中的实现方式如下所述。对于每个 ICPC 数据库，选择以下整数参数：\n\n$m$ 是过滤器中的位数；\n\n$f$ 是过滤器中的哈希函数数量；\n\n$a_{i}$ 是哈希函数的参数，$0 \\le i$。\n\n为每个数据文件计算布隆过滤器的值。数据文件的布隆过滤器是一个 $m$ 位的向量。只有当在该数据文件中存在某个用户标识符 $u_{k}$ 的记录时，位号 $j (0 \\le j < m)$ 才会被设置为 1，并且对于某个哈希函数 $i (0 \\le i < f)$，满足以下等式：\n\n$$j = (u_{k} \\cdot a_{i}) \\mod m$$ (1)\n\n你的任务是实现 ICPC 过滤逻辑。给定过滤器参数和若干数据文件的值以及一组用户标识符。你的任务是确定哪些数据文件可能包含指定集合中至少一个用户标识符的记录。只有当对于所有 $i (0 \\le i < f)$，其过滤器值中由等式 (1) 给出的所有位 $j$ 都被设置为 1 时，数据文件才可能包含用户标识符 $u_{k}$ 的记录。", "inputFormat": "输入文件的第一行包含过滤器参数——整数 $m, f$ 和 $a_{i}$，其中 $0 \\le i < f (1 \\le m \\le 1000, 1 \\le f \\le 100, 1 \\le a_{i} < 2^{31})$。\n\n输入文件的第二行包含一个整数 $n$——数据文件的数量 $(1 \\le n \\le 1000)$。接下来的 $n$ 行中的每一行包含相应文件的布隆过滤器值，以十六进制形式表示。每个值由一个 $\\lceil m/4 \\rceil$ 个十六进制数字的字符串表示（取值为 $0123456789abcdef$ 中的一个）。字符串的第一个数字表示值的位 $0-3$（按从十六进制数字的最低有效位到最高有效位的顺序存储），第二个数字表示位 $4-7$，第三个表示 $8-11$，等等。当 $m \\mod 4 \neq 0$ 时，最后一个十六进制数字表示值的最后 $m \\mod 4$ 位，以其最低有效位表示。\n\n输入文件的下一行包含一个整数 $q$——查询中的用户标识符数量 $(1 \\le q \\le 1000)$，后跟 $q$ 个整数 $u_{k}$——查询中的一组不同的用户标识符 $(1 \\le u_{k} < 2^{31})$。", "outputFormat": "在输出文件中写入一行，包含整数 $s$——可能包含指定集合中至少一个用户标识符的记录的数据文件数量，后跟 $s$ 个数字 $d_{t} (0 \\le d_{t} < n)$——对应数据文件的从 0 开始的编号，按升序排列。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6991", "type": "P", "difficulty": 6, "samples": [["10 10\n10 11\n10 12\n10 13\n9 10\n9 11\n9 9\n11 13\n-1 -1\n", "11 10\n11 11\n10 9\n10 14\n8 9\n11 9\n11 12\n11 8\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Gomoku", "background": "这是一道 IO 交互题。", "description": "\n\nThis is an interactive problem.\n\nGomoku is a two-player game on a two-dimensional grid. Each cell of the grid can be either empty, contain the first player's mark $(black),$ or contain the second player's mark $(white),$ but not both. Initially the entire grid is empty. Two players make alternating moves, starting with the first player. At each move, a player can put her mark into exactly one empty cell. The first player to have her five adjacent marks in a single row wins. The winning row can be either vertical, horizontal or diagonal.\n\n![](https://upload.acmicpc.net/23c94254-2783-405a-907b-7b66bea5514b/-/preview/)\n\nPosition where the second player (white marks) had won.\n\nThe players use a $19 \\times 19$ grid in this problem. If the entire grid gets filled with marks but no player has won, the game is declared a draw.\n\nThe first player uses the following strategy: as the first move, she puts her mark into the center cell of the grid. At every other move, she picks such a move that maximizes the score of the resulting position.\n\nIn order to find the score of a position, the first player considers all possible places where the winning combination might eventually form -- in other words, all horizonal, vertical and diagonal rows of five consecutive cells on the board (of course, they may overlap each other). If such a row contains both the first player's marks and the second player's marks, it is disregarded. If such a row contains no marks, it is disregarded as well. For each row with exactly $k (1 \\le k \\le 5)$ marks of the first player and no marks of the second player, add $50^{2k−1}$ to the score of the position. For each row with exactly $k$ marks of the second player and no marks of the first player, subtract $50^{2k}$ from the score of the position. Finally, add a random integer number between $0$ and $50^{2} − 1$ to the score. This random number is chosen uniformly.\n\nIn case when several moves of the first player have equal scores (such ties are quite rare because of the random addition mentioned above), the first player picks the one with the smallest x-coordinate, and in case of equal x-coordinates, the one with the smallest y-coordinate.\n\nYour task is to write a program that plays the second player and beats this strategy.\n\nYour program will play $100$ games against the strategy described above, with different seeds of random generator. Your program must win all these games.\n\n", "inputFormat": "\n\n", "outputFormat": "\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Gomoku", "background": "这是一道 IO 交互题。", "description": "\n\nThis is an interactive problem.\n\nGomoku is a two-player game on a two-dimensional grid. Each cell of the grid can be either empty, contain the first player's mark $(black),$ or contain the second player's mark $(white),$ but not both. Initially the entire grid is empty. Two players make alternating moves, starting with the first player. At each move, a player can put her mark into exactly one empty cell. The first player to have her five adjacent marks in a single row wins. The winning row can be either vertical, horizontal or diagonal.\n\n![](https://upload.acmicpc.net/23c94254-2783-405a-907b-7b66bea5514b/-/preview/)\n\nPosition where the second player (white marks) had won.\n\nThe players use a $19 \\times 19$ grid in this problem. If the entire grid gets filled with marks but no player has won, the game is declared a draw.\n\nThe first player uses the following strategy: as the first move, she puts her mark into the center cell of the grid. At every other move, she picks such a move that maximizes the score of the resulting position.\n\nIn order to find the score of a position, the first player considers all possible places where the winning combination might eventually form -- in other words, all horizonal, vertical and diagonal rows of five consecutive cells on the board (of course, they may overlap each other). If such a row contains both the first player's marks and the second player's marks, it is disregarded. If such a row contains no marks, it is disregarded as well. For each row with exactly $k (1 \\le k \\le 5)$ marks of the first player and no marks of the second player, add $50^{2k−1}$ to the score of the position. For each row with exactly $k$ marks of the second player and no marks of the first player, subtract $50^{2k}$ from the score of the position. Finally, add a random integer number between $0$ and $50^{2} − 1$ to the score. This random number is chosen uniformly.\n\nIn case when several moves of the first player have equal scores (such ties are quite rare because of the random addition mentioned above), the first player picks the one with the smallest x-coordinate, and in case of equal x-coordinates, the one with the smallest y-coordinate.\n\nYour task is to write a program that plays the second player and beats this strategy.\n\nYour program will play $100$ games against the strategy described above, with different seeds of random generator. Your program must win all these games.\n\n", "inputFormat": "\n\n", "outputFormat": "\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Gomoku", "background": "", "description": "这是一个交互式问题。\n\n五子棋是一种在二维网格上进行的双人游戏。网格的每个单元格可以是空的，包含第一位玩家的标记（黑色），或者包含第二位玩家的标记（白色），但不能同时包含两者。最初整个网格是空的。两位玩家轮流下棋，从第一位玩家开始。每次移动时，玩家可以在一个空单元格中放置她的标记。第一个在一行中有五个相邻标记的玩家获胜。获胜的行可以是垂直的、水平的或对角线的。\n\n![](https://upload.acmicpc.net/23c94254-2783-405a-907b-7b66bea5514b/-/preview/)\n\n第二位玩家（白色标记）获胜的位置。\n\n在这个问题中，玩家使用一个 $19 \\times 19$ 的网格。如果整个网格被标记填满但没有玩家获胜，游戏被判为平局。\n\n第一位玩家使用以下策略：作为第一次移动，她将她的标记放在网格的中心单元格。在每次其他移动中，她选择一个能最大化结果位置得分的移动。\n\n为了找到一个位置的得分，第一位玩家考虑所有可能最终形成获胜组合的位置——换句话说，棋盘上所有水平、垂直和对角线的五个连续单元格的行（当然，它们可能相互重叠）。如果这样的行同时包含第一位玩家和第二位玩家的标记，则不予考虑。如果这样的行不包含任何标记，也不予考虑。对于每个只包含第一位玩家的标记且没有第二位玩家标记的行，添加 $50^{2k-1}$ 到位置的得分，其中 $k$ 是第一位玩家的标记数量（$1 \\le k \\le 5$）。对于每个只包含第二位玩家的标记且没有第一位玩家标记的行，从位置的得分中减去 $50^{2k}$。最后，随机添加一个介于 $0$ 和 $50^{2} - 1$ 之间的整数到得分中。这个随机数是均匀选择的。\n\n在第一位玩家的几个移动得分相等的情况下（由于上述随机加法，这种平局很少见），第一位玩家选择 x 坐标最小的移动，如果 x 坐标相同，则选择 y 坐标最小的移动。\n\n你的任务是编写一个程序，扮演第二位玩家并击败这种策略。\n\n你的程序将与上述策略进行 100 场比赛，使用不同的随机生成器种子。你的程序必须赢得所有这些比赛。", "inputFormat": "", "outputFormat": "", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6992", "type": "P", "difficulty": 6, "samples": [["2\n2 1 1\n", "1\n"], ["5\n2 4 4\n1 2 5\n5 4 2\n5 3 3\n", "3.50\n"], ["5\n4 1 2\n5 3 2\n4 2 3\n5 4 7\n", "3.1666666667\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Hidden Maze", "background": "", "description": "\n\nHelen and Henry are fans of the TV show `Hidden Maze`, which is very popular in Hiddenland. During this show two participants (usually a married couple) are rushing through the maze consisting of $n$ halls connected by some tunnels. Each tunnel connects two different halls and there can't be more than one tunnel connecting any pair of halls.\n\nIn the beginning of the show, two participants are placed in two different halls. Then they need to move very quickly to meet each other before the time runs out. To pass through each tunnel, the participant needs to find a clue which is some positive integer number written on a small piece of paper.\n\nIf the participants finally meet in some tunnel before the time runs out, and successfully find a clue contained in the tunnel where they met, they are considered winners. The value of their prize is calculated by sorting all the clues found by them and taking the median value. The game is always set up in such a way, that the number of clues they find is odd.\n\nHelen and Henry saw a large number of episodes of the show, and now they understand a lot about the mechanics of it. They noticed that the maze doesn't change between episodes, and they drew a complete map of the maze. Shortly after, Helen and Henry have discovered that the maze is built in such a manner that if you visit any tunnel at most once, then there is exactly one path between any two halls.\n\nHelen and Henry have been wondering how this great maze is created, and not so long time ago they have seen an interview with Hillary, who worked for the company which had built the maze. Hillary has told that to make the show fair, the maze had been created using the following randomized algorithm:\n\nPick the number of halls $n$ . Build $n$ halls enumerated from $1$ to $n$ .\n\nChoose at random two integers $i$ and $j$ , each of them uniformly distributed between $1$ and $n$ .\n\nIf halls $i$ and $j$ are the same or are already connected with some path of tunnels, then go to step $2$ .\n\nBuild the tunnel between $i$ and $j$ . If there is a path of tunnels from any hall to any other one, stop the process, otherwise go to step $2$ .\n\nHelen and Henry have also noticed that each tunnel contains exactly one clue and its value never changes from episode to episode. However, they don't know what algorithm was used to generate clue values. Helen and Henry have written on their map the value of the clue for each tunnel.\n\nIt always takes $1$ minute to find a clue and to run through the tunnel from one hall to another. It takes half a minute to run from the hall to the center of the tunnel when the participants meet in the center of the tunnel at the end. The time given to participants is only enough to meet each other if they act optimally, that is they just run to each other via the shortest possible path, never make mistakes when finding clues, and never turn into any other tunnels that do not belong to the shortest path. To make the participants meet in the center of some tunnel, they are placed in the beginning of the show in such a way that the length of the shortest path between the halls where they are placed is odd.\n\nHelen and Henry want to participate in the show. They know the maze by heart and they are pretty sure that they will succeed in moving optimally to each other and finding all clues in time. Provided that the pair of initial halls is selected uniformly from all pairs with an odd-length shortest path between them, they need to know the expected value of the prize they win. Your task is to help them find this expected value.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer number $n (2 \\le n \\le 30 000)$ -- the number of halls. Each of the following $n − 1$ lines contains three integers: $u_{i}, v_{i}, c_{i} (1 \\le u_{i}, v_{i} \\le n , 1 \\le c_{i} \\le 10^{6}),$ describing the i-th tunnel connecting the halls $u_{i}$ and $v_{i},$ containing the clue with the value $c_{i}.$ The maze is always created by the randomized algorithm that is specified in the problem statement.\n\n", "outputFormat": "\n\nWrite to the output file a single real number -- the expected value of the prize. The absolute or relative error of the answer must not exceed $10^{−9}.$\n\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Hidden Maze", "background": "", "description": "\n\nHelen and Henry are fans of the TV show `Hidden Maze`, which is very popular in Hiddenland. During this show two participants (usually a married couple) are rushing through the maze consisting of $n$ halls connected by some tunnels. Each tunnel connects two different halls and there can't be more than one tunnel connecting any pair of halls.\n\nIn the beginning of the show, two participants are placed in two different halls. Then they need to move very quickly to meet each other before the time runs out. To pass through each tunnel, the participant needs to find a clue which is some positive integer number written on a small piece of paper.\n\nIf the participants finally meet in some tunnel before the time runs out, and successfully find a clue contained in the tunnel where they met, they are considered winners. The value of their prize is calculated by sorting all the clues found by them and taking the median value. The game is always set up in such a way, that the number of clues they find is odd.\n\nHelen and Henry saw a large number of episodes of the show, and now they understand a lot about the mechanics of it. They noticed that the maze doesn't change between episodes, and they drew a complete map of the maze. Shortly after, Helen and Henry have discovered that the maze is built in such a manner that if you visit any tunnel at most once, then there is exactly one path between any two halls.\n\nHelen and Henry have been wondering how this great maze is created, and not so long time ago they have seen an interview with Hillary, who worked for the company which had built the maze. Hillary has told that to make the show fair, the maze had been created using the following randomized algorithm:\n\nPick the number of halls $n$ . Build $n$ halls enumerated from $1$ to $n$ .\n\nChoose at random two integers $i$ and $j$ , each of them uniformly distributed between $1$ and $n$ .\n\nIf halls $i$ and $j$ are the same or are already connected with some path of tunnels, then go to step $2$ .\n\nBuild the tunnel between $i$ and $j$ . If there is a path of tunnels from any hall to any other one, stop the process, otherwise go to step $2$ .\n\nHelen and Henry have also noticed that each tunnel contains exactly one clue and its value never changes from episode to episode. However, they don't know what algorithm was used to generate clue values. Helen and Henry have written on their map the value of the clue for each tunnel.\n\nIt always takes $1$ minute to find a clue and to run through the tunnel from one hall to another. It takes half a minute to run from the hall to the center of the tunnel when the participants meet in the center of the tunnel at the end. The time given to participants is only enough to meet each other if they act optimally, that is they just run to each other via the shortest possible path, never make mistakes when finding clues, and never turn into any other tunnels that do not belong to the shortest path. To make the participants meet in the center of some tunnel, they are placed in the beginning of the show in such a way that the length of the shortest path between the halls where they are placed is odd.\n\nHelen and Henry want to participate in the show. They know the maze by heart and they are pretty sure that they will succeed in moving optimally to each other and finding all clues in time. Provided that the pair of initial halls is selected uniformly from all pairs with an odd-length shortest path between them, they need to know the expected value of the prize they win. Your task is to help them find this expected value.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer number $n (2 \\le n \\le 30 000)$ -- the number of halls. Each of the following $n − 1$ lines contains three integers: $u_{i}, v_{i}, c_{i} (1 \\le u_{i}, v_{i} \\le n , 1 \\le c_{i} \\le 10^{6}),$ describing the i-th tunnel connecting the halls $u_{i}$ and $v_{i},$ containing the clue with the value $c_{i}.$ The maze is always created by the randomized algorithm that is specified in the problem statement.\n\n", "outputFormat": "\n\nWrite to the output file a single real number -- the expected value of the prize. The absolute or relative error of the answer must not exceed $10^{−9}.$\n\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] 隐藏迷宫", "background": null, "description": "海伦和亨利是《隐藏迷宫》这档在 Hidden Land 超火的综艺节目的铁杆粉丝。节目里，两位选手（通常是一对夫妻）要在由 $n$ 个大厅组成的迷宫中飞速穿行，这些大厅通过若干条隧道相连。每条隧道连接两个不同的大厅，且任意一对大厅之间最多只有一条隧道。\n\n比赛一开始，两位选手分别被放置在两个不同的大厅里。然后，他们要争分夺秒地赶去见面，必须在时间耗尽前相遇。穿过每条隧道时，选手会找到一张写有正整数线索的小纸条。\n\n如果两人最终在某条隧道中相遇，并成功找到了该隧道上的线索，他们就算赢了。奖金的数额是将他们找到的所有线索排序后取中位数。游戏设计保证他们找到的线索数总是奇数。\n\n海伦和亨利看了无数集节目，渐渐摸清了游戏的套路。他们发现迷宫结构始终不变，还画出了完整地图。后来他们发现，这个迷宫设计得很巧妙：只要每条隧道最多走一次，任意两个大厅之间就只有一条唯一的路径。\n\n他们还听过一位名叫希拉里的工作人员讲过，这个迷宫是用下面的随机算法建造的：\n\n步骤 $1$：先确定大厅数目 $n$，建造 $n$ 个大厅，编号从 $1$ 到 $n$。\n\n步骤 $2$：随机选两个整数 $i$ 和 $j$，它们均匀分布在 $1$ 到 $n$ 之间。\n\n步骤 $3$：如果大厅 $i$ 和 $j$ 是同一个，或者它们之间已经有通路了，跳转到步骤 $2$。\n\n步骤 $4$：在大厅 $i$ 和 $j$ 之间建造一条隧道。如果此时任意两个大厅间都有通路了，结束；否则跳转到步骤 $2$。\n\n海伦和亨利还注意到，每条隧道上的线索数值固定不变，但他们不知道线索数值是如何生成的。他们把每条隧道对应的线索值都标在了地图上。\n\n穿过一条隧道并找到线索需要 $1$ 分钟，选手们从大厅跑到隧道中心相遇时需要半分钟。给定的时间刚好够他们以最优策略相遇——即走最短路径，不出错，且不绕路。为了让他们能在隧道中心相遇，比赛一开始两人被放在的两个大厅间的最短路径长度是奇数。\n\n海伦和亨利想参加节目，他们对迷宫了如指掌，确信自己能以最优策略完成任务。现在，假设初始两个大厅的选择是均匀随机的，且只选那些最短路径长度为奇数的大厅对。他们想知道自己赢得奖金的期望值是多少。请帮他们算出这个期望。", "inputFormat": "第一行输入一个整数 $n (2 \\le n \\le 30 000)$，表示大厅数。\n\n接下来 $n − 1$ 行，每行三个整数：$u_{i}, v_{i}, c_{i} (1 \\le u_{i}, v_{i} \\le n , 1 \\le c_{i} \\le 10^{6})$，表示第 $i$ 条隧道连接的两个大厅 $u_{i}$ 和 $v_{i}$，以及该隧道上的线索值 $c_{i}$。\n\n迷宫保证是题目中描述的随机算法生成的。", "outputFormat": "输出一个实数，表示奖金的期望值。答案的绝对或相对误差不得超过 $10^{−9}$。", "hint": "时间限制：3 秒，内存限制：256 MB。\n\n题面翻译由 GPT-4.1-mini 提供。", "locale": "zh-CN"}}}
{"pid": "P6993", "type": "P", "difficulty": 6, "samples": [["4\n1 3 2 4\n", "3\n"], ["4\n1 4 2 3\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Improvements", "background": "", "description": "\n\nSon Halo owns $n$ spaceships numbered from $1$ to $n$ and a space station. They are initially placed on one line with the space station so the spaceship $i$ is positioned $x_i$ meters from the station and all ships are on the same side from the station $(x_i > 0)$ . All $x_i$ are distinct. Station is considered to have number $0$ and $x_0$ is considered to be equal to $0$ .\n\nEvery two spaceships with consequent numbers are connected by a rope, and the first one is connected to the station. The rope number $i$ (for $1 \\le i \\le n)$ connects ships $i$ and $i-1.$ Note, that the rope number $1$ connects the first ship to the station.\n\nSon Halo considers that the rope $i$ and the rope $j$ intersect when the segments $[x_{i}^{min}, x_{i}^{max}]$ and $[x_{j}^{min}, x_{j}^{max}]$ have common internal point but neither one of them is completely contained in the other, where $x_{k}^{min} = \\min(x_{k−1}, x_k)$, $x_{k}^{max} = max(x_{k−1}, x_k).$ That is:\n\n$$\\begin{cases} x_{i}^{min} < x_{j}^{min} \\sim \\& \\sim x_{j}^{min} < x_{i}^{max} \\sim \\& \\sim x_{i}^{max} < x_{j}^{max} \\\\ x_{j}^{min} < x_{i}^{min} \\sim \\& \\sim x_{i}^{min} < x_{j}^{max} \\sim \\& \\sim x_{j}^{max} < x_{i}^{max}  \\end{cases}$$\n\nSon Halo wants to rearrange spaceships in such a way, that there are no rope intersections. Because he is lazy, he wants to rearrange the ships in such a way, that the total number of ships that remain at their original position $x_i$ is maximal. All the ships must stay on the same side of the station and at different positions $x_i$ after rearrangement. However, ships can occupy any real positions $x_i$ after rearrangement.\n\nYour task is to figure out what is the maximal number of ships that can remain at their initial positions.\n\n", "inputFormat": "\n\nThe first line of the input file contains $\\(n\\) (1 \\le \\(n\\) \\le 200 000)$ -- the number of ships. The following line contains $\\(n\\)$ distinct integers $\\(x_i\\) (1 \\le \\(x_i\\) \\le \\(n\\))$ -- the initial positions of the spaceships.\n\n", "outputFormat": "\n\nThe output file must contain one integer -- the maximal number of ships that can remain at their initial positions in the solution of this problem.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Improvements", "background": "", "description": "\n\nSon Halo owns $n$ spaceships numbered from $1$ to $n$ and a space station. They are initially placed on one line with the space station so the spaceship $i$ is positioned $x_i$ meters from the station and all ships are on the same side from the station $(x_i > 0)$ . All $x_i$ are distinct. Station is considered to have number $0$ and $x_0$ is considered to be equal to $0$ .\n\nEvery two spaceships with consequent numbers are connected by a rope, and the first one is connected to the station. The rope number $i$ (for $1 \\le i \\le n)$ connects ships $i$ and $i-1.$ Note, that the rope number $1$ connects the first ship to the station.\n\nSon Halo considers that the rope $i$ and the rope $j$ intersect when the segments $[x_{i}^{min}, x_{i}^{max}]$ and $[x_{j}^{min}, x_{j}^{max}]$ have common internal point but neither one of them is completely contained in the other, where $x_{k}^{min} = \\min(x_{k−1}, x_k)$, $x_{k}^{max} = max(x_{k−1}, x_k).$ That is:\n\n$$\\begin{cases} x_{i}^{min} < x_{j}^{min} \\sim \\& \\sim x_{j}^{min} < x_{i}^{max} \\sim \\& \\sim x_{i}^{max} < x_{j}^{max} \\\\ x_{j}^{min} < x_{i}^{min} \\sim \\& \\sim x_{i}^{min} < x_{j}^{max} \\sim \\& \\sim x_{j}^{max} < x_{i}^{max}  \\end{cases}$$\n\nSon Halo wants to rearrange spaceships in such a way, that there are no rope intersections. Because he is lazy, he wants to rearrange the ships in such a way, that the total number of ships that remain at their original position $x_i$ is maximal. All the ships must stay on the same side of the station and at different positions $x_i$ after rearrangement. However, ships can occupy any real positions $x_i$ after rearrangement.\n\nYour task is to figure out what is the maximal number of ships that can remain at their initial positions.\n\n", "inputFormat": "\n\nThe first line of the input file contains $\\(n\\) (1 \\le \\(n\\) \\le 200 000)$ -- the number of ships. The following line contains $\\(n\\)$ distinct integers $\\(x_i\\) (1 \\le \\(x_i\\) \\le \\(n\\))$ -- the initial positions of the spaceships.\n\n", "outputFormat": "\n\nThe output file must contain one integer -- the maximal number of ships that can remain at their initial positions in the solution of this problem.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Improvements", "background": "", "description": "Son Halo 拥有编号从 1 到 $n$ 的 $n$ 艘飞船和一个空间站。它们最初与空间站在一条直线上排列，因此飞船 $i$ 距离空间站 $x_i$ 米，并且所有飞船都在空间站的同一侧（$x_i > 0$）。所有 $x_i$ 都是不同的。空间站被认为是编号为 0，并且 $x_0$ 被认为等于 0。\n\n每两艘连续编号的飞船之间用绳子连接，第一艘飞船与空间站连接。编号为 $i$ 的绳子（对于 $1 \\le i \\le n$）连接飞船 $i$ 和 $i-1$。注意，编号为 1 的绳子连接第一艘飞船与空间站。\n\nSon Halo 认为绳子 $i$ 和绳子 $j$ 相交，当且仅当线段 $[x_{i}^{min}, x_{i}^{max}]$ 和 $[x_{j}^{min}, x_{j}^{max}]$ 有公共的内部点，但它们中的任何一个都不完全包含在另一个中，其中 $x_{k}^{min} = \\min(x_{k-1}, x_k)$，$x_{k}^{max} = \\max(x_{k-1}, x_k)$。即：\n\n$$\n\\begin{cases} \nx_{i}^{min} < x_{j}^{min} \\sim \\& \\sim x_{j}^{min} < x_{i}^{max} \\sim \\& \\sim x_{i}^{max} < x_{j}^{max} \\\\\nx_{j}^{min} < x_{i}^{min} \\sim \\& \\sim x_{i}^{min} < x_{j}^{max} \\sim \\& \\sim x_{j}^{max} < x_{i}^{max} \\ \n\\end{cases}\n$$\n\nSon Halo 想要重新排列飞船，使得没有绳子相交。因为他很懒，他希望以一种方式重新排列飞船，使得保持在原始位置 $x_i$ 的飞船总数最大化。所有飞船在重新排列后必须保持在空间站的同一侧，并且在不同的位置 $x_i$。然而，飞船在重新排列后可以占据任何实数位置 $x_i$。\n\n你的任务是找出可以保持在其初始位置的飞船的最大数量。", "inputFormat": "输入文件的第一行包含 $n$ $(1 \\le n \\le 200\\,000)$ —— 飞船的数量。接下来的行包含 $n$ 个不同的整数 $x_i$ $(1 \\le x_i \\le n)$ —— 飞船的初始位置。", "outputFormat": "输出文件必须包含一个整数 —— 在该问题的解决方案中可以保持在其初始位置的飞船的最大数量。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6994", "type": "P", "difficulty": 3, "samples": [["4111109876532\n", "4 1 11 10 9 8 7 6 5 3 2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Joke with permutation", "background": "", "description": "Joey had saved a permutation of integers from $1$ to $n$ in a text file. All the numbers were written as decimal numbers without leading spaces.\n\nThen Joe made a practical joke on her: he removed all the spaces in the file.\n\nHelp Joey to restore the original permutation after the Joe's joke! ", "inputFormat": "The input file contains a single line with a single string -- the Joey's permutation without spaces.\n\nThe Joey's permutation had at least $1$ and at most $50$ numbers. ", "outputFormat": "Write a line to the output file with the restored permutation. Don’t forget the spaces!\n\nIf there are several possible original permutations, write any one of them.", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\nThanks to checker provider:@[Arcturus1350\n](/user/57699).", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Joke with permutation", "background": "", "description": "Joey had saved a permutation of integers from $1$ to $n$ in a text file. All the numbers were written as decimal numbers without leading spaces.\n\nThen Joe made a practical joke on her: he removed all the spaces in the file.\n\nHelp Joey to restore the original permutation after the Joe's joke! ", "inputFormat": "The input file contains a single line with a single string -- the Joey's permutation without spaces.\n\nThe Joey's permutation had at least $1$ and at most $50$ numbers. ", "outputFormat": "Write a line to the output file with the restored permutation. Don’t forget the spaces!\n\nIf there are several possible original permutations, write any one of them.", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\nThanks to checker provider:@[Arcturus1350\n](/user/57699).", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Joke with permutation", "background": null, "description": "Joey 在一个文本文件中保存了一个从 $1$ 到 $n$ 的整数排列。所有的数字都以十进制数字的形式书写，没有前导空格。\n\n然后 Joe 开了个玩笑：他把文件中的所有空格都去掉了。\n\n帮助 Joey 恢复 Joe 玩笑后的原始排列！", "inputFormat": "输入文件包含一行，一个字符串——去掉空格后的 Joey 的排列。\n\nJoey 的排列至少有 $1$ 个，最多有 $50$ 个数。", "outputFormat": "在输出文件中写出恢复后的排列。不要忘记空格！\n\n如果有多个可能的原始排列，输出其中任意一个。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n感谢检查者提供者：@[Arcturus1350](\\/user\\/57699)。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6995", "type": "P", "difficulty": 2, "samples": [["5 5\n0 1\n0 2\n2 3\n3 5\n4 5\n0 5 0\n0 1 2\n0 2 1\n2 5 2\n2 5 3\n", "5\n1\n2\n4\n3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Knockout Racing", "background": "", "description": "\n\nThe races became more popular than ever at Pandora planet. But these races are quite unusual. There are $n$ cars participating in a race on the long straight track. Each car moves with a speed of $1$ meter per second. Track has coordinates in meters.\n\nThe car number $i$ moves between two points on the track with coordinates $a_{i}$ and $b_{i}$ starting at the second $0$ in the point $a_{i}.$ The car moves from $a_{i}$ to $b_{i},$ then from $b_{i}$ to $a_{i},$ then from $a_{i}$ to $b_{i}$ again, and so on.\n\nHandsome Mike wants to knock some cars out of the race using dynamite. Thus he has $m$ questions. The question number $j$ is: what is the number of cars in the coordinates between $x_{j}$ and $y_{j}$ inclusive after $t_{j}$ seconds from the start?\n\nYour task is to answer Mike's questions.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $m (1 \\le n , m \\le 1000)$ -- the number of cars in the race and the number of questions.\n\nEach of the following $n$ lines contains a description of the car: two integers $a_{i}$ and $b_{i} (0 \\le a_{i}, b_{i} \\le 10^{9}, a_{i} ≠ b_{i})$ -- the coordinates of the two points between which the car $i$ moves.\n\nEach of the following $m$ lines contains a description of the question: three integers $x_{j} , y_{j}$ , and $t_{j} (0 \\le x_{j} \\le y_{j} \\le 10^{9}, 0 \\le t_{j} \\le 10^{9})$ -- the coordinate range and the time for the question $j$ .\n\n", "outputFormat": "\n\nWrite $m$ lines to the output file. Each line must contain one integer -- the answer to the corresponding question in order they are given in the input file.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Knockout Racing", "background": "", "description": "\n\nThe races became more popular than ever at Pandora planet. But these races are quite unusual. There are $n$ cars participating in a race on the long straight track. Each car moves with a speed of $1$ meter per second. Track has coordinates in meters.\n\nThe car number $i$ moves between two points on the track with coordinates $a_{i}$ and $b_{i}$ starting at the second $0$ in the point $a_{i}.$ The car moves from $a_{i}$ to $b_{i},$ then from $b_{i}$ to $a_{i},$ then from $a_{i}$ to $b_{i}$ again, and so on.\n\nHandsome Mike wants to knock some cars out of the race using dynamite. Thus he has $m$ questions. The question number $j$ is: what is the number of cars in the coordinates between $x_{j}$ and $y_{j}$ inclusive after $t_{j}$ seconds from the start?\n\nYour task is to answer Mike's questions.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $m (1 \\le n , m \\le 1000)$ -- the number of cars in the race and the number of questions.\n\nEach of the following $n$ lines contains a description of the car: two integers $a_{i}$ and $b_{i} (0 \\le a_{i}, b_{i} \\le 10^{9}, a_{i} ≠ b_{i})$ -- the coordinates of the two points between which the car $i$ moves.\n\nEach of the following $m$ lines contains a description of the question: three integers $x_{j} , y_{j}$ , and $t_{j} (0 \\le x_{j} \\le y_{j} \\le 10^{9}, 0 \\le t_{j} \\le 10^{9})$ -- the coordinate range and the time for the question $j$ .\n\n", "outputFormat": "\n\nWrite $m$ lines to the output file. Each line must contain one integer -- the answer to the corresponding question in order they are given in the input file.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Knockout Racing", "background": "", "description": "在 Pandora 星球上，比赛比以往任何时候都更受欢迎。但这些比赛相当不寻常。有 $n$ 辆车在一条长直赛道上参加比赛。每辆车以每秒 1 米的速度移动。赛道的坐标以米为单位。\n\n第 $i$ 号车在赛道上两个坐标为 $a_{i}$ 和 $b_{i}$ 的点之间移动，起始于第 0 秒在点 $a_{i}$。车从 $a_{i}$ 移动到 $b_{i}$，然后从 $b_{i}$ 移动到 $a_{i}$，然后再从 $a_{i}$ 移动到 $b_{i}$，如此往复。\n\n英俊的 Mike 想用炸药将一些车淘汰出比赛。因此他有 $m$ 个问题。第 $j$ 个问题是：从开始到 $t_{j}$ 秒后，坐标在 $x_{j}$ 到 $y_{j}$ 之间（包括边界）的车的数量是多少？\n\n你的任务是回答 Mike 的问题。", "inputFormat": "输入文件的第一行包含两个整数 $n$ 和 $m$ $(1 \\le n , m \\le 1000)$ —— 比赛中的车的数量和问题的数量。\n\n接下来的 $n$ 行中的每一行包含一辆车的描述：两个整数 $a_{i}$ 和 $b_{i}$ $(0 \\le a_{i}, b_{i} \\le 10^{9}, a_{i} \neq b_{i})$ —— 车 $i$ 在其间移动的两个点的坐标。\n\n接下来的 $m$ 行中的每一行包含一个问题的描述：三个整数 $x_{j}$, $y_{j}$ 和 $t_{j}$ $(0 \\le x_{j} \\le y_{j} \\le 10^{9}, 0 \\le t_{j} \\le 10^{9})$ —— 问题 $j$ 的坐标范围和时间。", "outputFormat": "将 $m$ 行写入输出文件。每行必须包含一个整数 —— 按输入文件中给出的顺序对应问题的答案。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6996", "type": "P", "difficulty": 5, "samples": [["4 4 3\n..........\n..........\n...AAAA...\n...AAAAAA.\n...A.AA...\n..........\n..........\n\n..........\n..........\n...BBBB...\n.....BB...\n...BBBB...\n....BB....\n.....B....\n\n..........\n..........\n...C..C...\n..CCC.C...\n...CCCC...\n..........\n..........\n\n..........\n....D.....\n...DDDD...\n...DDD....\n...DDDD...\n..........\n..........\n", "8 6\nAAAABBBB\nAAAAAABB\nADAABBBB\nDDDDCBBC\nDDDCCCBC\nDDDDCCCC\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] ASCII Puzzle", "background": "", "description": "\n\nFili and Floi play a puzzle game. Fili takes a rectangular piece of paper that is lined with a $W \\times H$ grid of square cells, cuts it into pieces on its grid lines, and carefully shuffles the pieces so that pieces do not rotate. Floi has to recombine the pieces back into the rectangle without rotating them.\n\nFili observes a number of constraints while cutting an original paper into pieces to make sure that the resulting puzzle is well-formed. First of all, Fili picks three integer numbers $w , h$ , and $n$ , so that an original rectangular paper has a width of $W = w_n$ cells and a height of $H = h_n$ cells. Here $w$ and $h$ are known to Floi, but $n , W$ , and $H$ are not. This way, the original rectangular piece of paper can be cut into a trivial puzzle of $k = n^{2}$ rectangles with a width of $w$ cells and a height of $h$ cells each. However, this trivial puzzle for $k > 1$ is not considered a well-formed puzzle for this game. Instead, the pieces int which the original rectangle is cut are based on these trivial $w \\times h$ cell rectangles with the jagged edges between the adjacent pieces. Formally, the pieces into which the original $W \\times H$ paper is cut satisfy the following constraints of a well-formed puzzle:\n\nThere are $k = n^{2}$ pieces.\n\nEach piece is a simple $4-connected$ region of cells without holes.\n\nEach cell of the original rectangular $W \\times H$ paper is a part of exactly one piece.\n\nEach piece contains four corners of the corresponding $w \\times h$ rectangle in the trivial puzzle for the original paper.\n\nThe cells of each piece can come only from the corresponding $w \\times h$ rectangle in the trivial puzzle, from the cells adjacent to this rectangle, and from the interior cells of the adjacent rectangles in the trivial puzzle.\n\nThe cut between two adjacent pieces cannot be straight. Only pieces that lie on the border of the original $W \\times H$ paper have straight sides.\n\nThe corollary of these constraints is that each piece of a well-formed puzzle fits into a rectangle of (3w $− 2) \\times $ (3h $− 2)$ cells. Moreover, the description of each piece will be given as a (3w $− 2) \\times $ (3h $− 2)$ grid of cells in such a way, that the corresponding $w \\times h$ rectangle of the trivial puzzle is exactly in the center.\n\nThe picture below to the left shows a sample rectangular piece of paper that is lined with a $W \\times H = 12 \\times 9$ square grid of cells and is cut into a trivial puzzle of $k = 9$ rectangles with a width of $w = 4$ cells and a height of $h = 3$ cells each with bold dashed lines. The corners of the central $3 \\times 4$ piece of this trivial puzzle are shown in black. They have to be a part of the central piece of any well-formed puzzle. The other potential cells of the central piece of a well-formed puzzle are shown in gray. The bold black line shows (3w $− 2) \\times $ (3h $− 2) = 10 \\times 7$ rectangular region that will be describing this central piece. The picture to the right shows the same for the piece in the upper-right corner of the puzzle.\n\n![](/upload/images2/neerc_a.png)\n\nYour task is to help Floi solve the puzzle.\n\n", "inputFormat": "\n\nThe first line of the input file contains there integers $k , w$ and $h$ . Here $k$ is the number of pieces in the puzzle, $w$ is a width and $h$ is a height of a trivial puzzle piece $(k = n^{2}$ for $1 \\le n \\le 4 , 3 \\le w , h \\le 5)$ . The rest of the input file contains descriptions of $k$ pieces of a well-formed puzzle. Each piece is described by 3h $− 2$ lines that contain 3w $− 2$ characters each. Pieces are labeled with a consecutive English letters in uppercase (1st piece -- $‘A', 2nd$ piece -- $‘B',$ and etc). Each piece description uses only two characters on its 3h $− 2$ lines of 3w $− 2$ characters. The English letter corresponding to the piece denotes a cell that is a part of this piece, while $‘. '$ (dot) character denotes a cell that is not.\n\nEmpty lines separate different pieces.\n\n", "outputFormat": "\n\nThe first line of the output file shall contain $W$ and $H$ -- the size of the original piece of paper that was cut into the puzzle pieces. The following $H$ lines shall contain $W$ English letters each, describing the solution of the puzzle. Letters denote the cells that belong to the corresponding puzzle pieces. If there are multiple ways to solve the puzzle, then print any solution.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] ASCII Puzzle", "background": "", "description": "\n\nFili and Floi play a puzzle game. Fili takes a rectangular piece of paper that is lined with a $W \\times H$ grid of square cells, cuts it into pieces on its grid lines, and carefully shuffles the pieces so that pieces do not rotate. Floi has to recombine the pieces back into the rectangle without rotating them.\n\nFili observes a number of constraints while cutting an original paper into pieces to make sure that the resulting puzzle is well-formed. First of all, Fili picks three integer numbers $w , h$ , and $n$ , so that an original rectangular paper has a width of $W = w_n$ cells and a height of $H = h_n$ cells. Here $w$ and $h$ are known to Floi, but $n , W$ , and $H$ are not. This way, the original rectangular piece of paper can be cut into a trivial puzzle of $k = n^{2}$ rectangles with a width of $w$ cells and a height of $h$ cells each. However, this trivial puzzle for $k > 1$ is not considered a well-formed puzzle for this game. Instead, the pieces int which the original rectangle is cut are based on these trivial $w \\times h$ cell rectangles with the jagged edges between the adjacent pieces. Formally, the pieces into which the original $W \\times H$ paper is cut satisfy the following constraints of a well-formed puzzle:\n\nThere are $k = n^{2}$ pieces.\n\nEach piece is a simple $4-connected$ region of cells without holes.\n\nEach cell of the original rectangular $W \\times H$ paper is a part of exactly one piece.\n\nEach piece contains four corners of the corresponding $w \\times h$ rectangle in the trivial puzzle for the original paper.\n\nThe cells of each piece can come only from the corresponding $w \\times h$ rectangle in the trivial puzzle, from the cells adjacent to this rectangle, and from the interior cells of the adjacent rectangles in the trivial puzzle.\n\nThe cut between two adjacent pieces cannot be straight. Only pieces that lie on the border of the original $W \\times H$ paper have straight sides.\n\nThe corollary of these constraints is that each piece of a well-formed puzzle fits into a rectangle of (3w $− 2) \\times $ (3h $− 2)$ cells. Moreover, the description of each piece will be given as a (3w $− 2) \\times $ (3h $− 2)$ grid of cells in such a way, that the corresponding $w \\times h$ rectangle of the trivial puzzle is exactly in the center.\n\nThe picture below to the left shows a sample rectangular piece of paper that is lined with a $W \\times H = 12 \\times 9$ square grid of cells and is cut into a trivial puzzle of $k = 9$ rectangles with a width of $w = 4$ cells and a height of $h = 3$ cells each with bold dashed lines. The corners of the central $3 \\times 4$ piece of this trivial puzzle are shown in black. They have to be a part of the central piece of any well-formed puzzle. The other potential cells of the central piece of a well-formed puzzle are shown in gray. The bold black line shows (3w $− 2) \\times $ (3h $− 2) = 10 \\times 7$ rectangular region that will be describing this central piece. The picture to the right shows the same for the piece in the upper-right corner of the puzzle.\n\n![](/upload/images2/neerc_a.png)\n\nYour task is to help Floi solve the puzzle.\n\n", "inputFormat": "\n\nThe first line of the input file contains there integers $k , w$ and $h$ . Here $k$ is the number of pieces in the puzzle, $w$ is a width and $h$ is a height of a trivial puzzle piece $(k = n^{2}$ for $1 \\le n \\le 4 , 3 \\le w , h \\le 5)$ . The rest of the input file contains descriptions of $k$ pieces of a well-formed puzzle. Each piece is described by 3h $− 2$ lines that contain 3w $− 2$ characters each. Pieces are labeled with a consecutive English letters in uppercase (1st piece -- $‘A', 2nd$ piece -- $‘B',$ and etc). Each piece description uses only two characters on its 3h $− 2$ lines of 3w $− 2$ characters. The English letter corresponding to the piece denotes a cell that is a part of this piece, while $‘. '$ (dot) character denotes a cell that is not.\n\nEmpty lines separate different pieces.\n\n", "outputFormat": "\n\nThe first line of the output file shall contain $W$ and $H$ -- the size of the original piece of paper that was cut into the puzzle pieces. The following $H$ lines shall contain $W$ English letters each, describing the solution of the puzzle. Letters denote the cells that belong to the corresponding puzzle pieces. If there are multiple ways to solve the puzzle, then print any solution.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] ASCII Puzzle", "background": "", "description": "Fili 和 Floi 玩一个拼图游戏。Fili 拿出一张用 $W \\times H$ 网格线划分的矩形纸，在网格线上将其切成若干块，并小心地将这些块打乱，但不旋转。Floi 必须在不旋转的情况下将这些块重新组合成矩形。\n\nFili 在将原始纸张切成块时遵循了一些约束，以确保生成的拼图是合理的。首先，Fili 选择三个整数 $w, h$ 和 $n$，使得原始矩形纸的宽度为 $W = w_n$ 个单元格，高度为 $H = h_n$ 个单元格。这里 $w$ 和 $h$ 是 Floi 已知的，但 $n, W$ 和 $H$ 是未知的。这样，原始矩形纸可以被切割成一个简单的 $k = n^{2}$ 个矩形拼图，每个矩形的宽度为 $w$ 个单元格，高度为 $h$ 个单元格。然而，对于 $k > 1$ 的简单拼图不被认为是这个游戏的合理拼图。相反，原始矩形被切割成的块是基于这些简单的 $w \\times h$ 单元格矩形，并在相邻块之间有锯齿边缘。正式地说，原始 $W \\times H$ 纸张被切割成的块满足以下合理拼图的约束：\n\n有 $k = n^{2}$ 个块。\n\n每个块是一个简单的 $4$ 连通的无孔单元格区域。\n\n原始矩形 $W \\times H$ 纸张的每个单元格恰好属于一个块。\n\n每个块包含原始纸张简单拼图中对应 $w \\times h$ 矩形的四个角。\n\n每个块的单元格只能来自简单拼图中对应的 $w \\times h$ 矩形、与该矩形相邻的单元格以及简单拼图中相邻矩形的内部单元格。\n\n两个相邻块之间的切割不能是直的。只有位于原始 $W \\times H$ 纸张边界上的块才有直边。\n\n这些约束的推论是，每个合理拼图的块都适合一个 $(3w - 2) \\times (3h - 2)$ 单元格的矩形。此外，每个块的描述将以 $(3w - 2) \\times (3h - 2)$ 的单元格网格给出，使得简单拼图中对应的 $w \\times h$ 矩形正好位于中心。\n\n下图左侧显示了一张样例矩形纸，用 $W \\times H = 12 \\times 9$ 的方格网格划分，并用粗虚线切割成一个简单拼图，包含 $k = 9$ 个宽度为 $w = 4$ 个单元格，高度为 $h = 3$ 个单元格的矩形。这个简单拼图的中央 $3 \\times 4$ 块的角用黑色显示。它们必须是任何合理拼图的中央块的一部分。合理拼图中央块的其他潜在单元格用灰色显示。粗黑线显示了 $(3w - 2) \\times (3h - 2) = 10 \\times 7$ 的矩形区域，将描述这个中央块。右图显示了拼图右上角块的相同情况。\n\n![](/upload/images2/neerc_a.png)\n\n你的任务是帮助 Floi 解决这个拼图。", "inputFormat": "输入文件的第一行包含三个整数 $k, w$ 和 $h$。这里 $k$ 是拼图中的块数，$w$ 是简单拼图块的宽度，$h$ 是高度（$k = n^{2}$ 且 $1 \\le n \\le 4, 3 \\le w, h \\le 5$）。输入文件的其余部分包含 $k$ 个合理拼图块的描述。每个块由 $3h - 2$ 行描述，每行包含 $3w - 2$ 个字符。块用连续的大写英文字母标记（第一个块为 'A'，第二个块为 'B'，等等）。每个块描述在其 $3h - 2$ 行中仅使用两个字符。与块对应的英文字母表示属于该块的单元格，而 '.'（点）字符表示不属于的单元格。\n\n空行分隔不同的块。", "outputFormat": "输出文件的第一行应包含 $W$ 和 $H$——被切割成拼图块的原始纸张的大小。接下来的 $H$ 行应包含 $W$ 个英文字母，描述拼图的解决方案。字母表示属于相应拼图块的单元格。如果有多种方法可以解决拼图，则输出任意一个解决方案。", "hint": "时间限制：1 秒，内存限制：128 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6997", "type": "P", "difficulty": 4, "samples": [["1 1 2\n", "0.3333333333333333\n0.2\n"], ["10 10 10\n", "0.5870875690480144\n0.3640355515319861\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Bonus Cards", "background": "", "description": "\n\nDmitry loves programming competitions very much. The Finals of the famed Champions League are taking place in Dmitry's home city, so he wants to visit the competition. The competition is very popular, but most tickets to the competition are reserved for VIPs and for sponsors.\n\nFor the general public tickets to the Champions League Finals are distributed in the following way. Spectators, that want to see the competition, submit their request that states the payment method they want to use to pay for their ticket. Suppose there are $n$ seats available. Several draw round are conducted. In each round every request that is not yet fulfilled receives some number of slots depending on the payment method. Then one of those slots is selected uniformly at random. The request to which this slot belongs is considered fulfilled and does not take part in subsequent drawing rounds. Draw ends after $n$ rounds or when there are no more unfulfilled requests, whichever occurs first. An International Card Processing Corporation (ICPC) is a sponsor of the Champions League. Those who chose ICPC card as a payment method receive two slots in each draw round, while users of other payment methods receive only one.\n\nDmitry has a card from ICPC, but he also has a card from Advanced Credit Merchandise $(ACM),$ which offers him a bonus on all his spendings. His brother Petr works in a company that conducts draw to distribute tickets, so he told Dmitry in advance how many people had already decided to use ICPC card and how many had decided to use other methods. Now Dmitry want to know the probabilities he would get a ticket if he would use his ICPC card or if he would use his ACM card, so that he can make an informed choice. His request is going to be in addition to the number of requests Petr had told him about.\n\nCan you help?\n\n", "inputFormat": "\n\nThe first and the only line of the input contains $3$ integer numbers -- the number of seats available for a draw $n (1 \\le n \\le 3000)$ , the number of requests with ICPC card as a payment method a , and the number of requests with other payment methods $b (0 \\le $ a , $b \\le 10^{9}).$\n\n", "outputFormat": "\n\nOn the first line output the probability of getting a ticket using ICPC card. On the second line output the probability of getting a ticket using ACM card. Answers should have an absolute error of no more than $10^{-9}.$\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Bonus Cards", "background": "", "description": "\n\nDmitry loves programming competitions very much. The Finals of the famed Champions League are taking place in Dmitry's home city, so he wants to visit the competition. The competition is very popular, but most tickets to the competition are reserved for VIPs and for sponsors.\n\nFor the general public tickets to the Champions League Finals are distributed in the following way. Spectators, that want to see the competition, submit their request that states the payment method they want to use to pay for their ticket. Suppose there are $n$ seats available. Several draw round are conducted. In each round every request that is not yet fulfilled receives some number of slots depending on the payment method. Then one of those slots is selected uniformly at random. The request to which this slot belongs is considered fulfilled and does not take part in subsequent drawing rounds. Draw ends after $n$ rounds or when there are no more unfulfilled requests, whichever occurs first. An International Card Processing Corporation (ICPC) is a sponsor of the Champions League. Those who chose ICPC card as a payment method receive two slots in each draw round, while users of other payment methods receive only one.\n\nDmitry has a card from ICPC, but he also has a card from Advanced Credit Merchandise $(ACM),$ which offers him a bonus on all his spendings. His brother Petr works in a company that conducts draw to distribute tickets, so he told Dmitry in advance how many people had already decided to use ICPC card and how many had decided to use other methods. Now Dmitry want to know the probabilities he would get a ticket if he would use his ICPC card or if he would use his ACM card, so that he can make an informed choice. His request is going to be in addition to the number of requests Petr had told him about.\n\nCan you help?\n\n", "inputFormat": "\n\nThe first and the only line of the input contains $3$ integer numbers -- the number of seats available for a draw $n (1 \\le n \\le 3000)$ , the number of requests with ICPC card as a payment method a , and the number of requests with other payment methods $b (0 \\le $ a , $b \\le 10^{9}).$\n\n", "outputFormat": "\n\nOn the first line output the probability of getting a ticket using ICPC card. On the second line output the probability of getting a ticket using ACM card. Answers should have an absolute error of no more than $10^{-9}.$\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Bonus Cards", "background": "", "description": "德米特里非常喜欢编程比赛。著名的冠军联赛决赛正在德米特里的家乡城市举行，所以他想去观看比赛。比赛非常受欢迎，但大多数门票都保留给 VIP 和赞助商。  \n\n对于普通公众，冠军联赛决赛的门票以以下方式分发。希望观看比赛的观众提交他们的请求，说明他们希望用哪种支付方式来支付门票。假设有 $n$ 个可用座位。进行若干轮抽签。在每一轮中，每个尚未满足的请求根据支付方式获得一定数量的抽签机会。然后从这些机会中随机选择一个。该机会所属的请求被视为已满足，并不再参与后续的抽签轮次。抽签在 $n$ 轮后或没有未满足请求时结束，以先发生者为准。国际卡处理公司（ICPC）是冠军联赛的赞助商。选择 ICPC 卡作为支付方式的人在每轮抽签中获得两个机会，而使用其他支付方式的用户仅获得一个。  \n\n德米特里有一张 ICPC 的卡，但他也有一张高级信用商品（ACM）的卡，该卡为他的所有消费提供奖金。他的兄弟 Petr 在负责分发门票的公司工作，所以他提前告诉德米特里已经有多少人决定使用 ICPC 卡以及多少人决定使用其他方法。现在德米特里想知道如果他使用 ICPC 卡或 ACM 卡，获得门票的概率是多少，以便做出明智的选择。他的请求将是 Petr 告诉他的请求数量的附加。  \n\n你能帮忙吗？", "inputFormat": "输入的第一行也是唯一一行包含 3 个整数——可用于抽签的座位数 $n (1 \\le n \\le 3000)$，使用 ICPC 卡作为支付方式的请求数 $a$，以及使用其他支付方式的请求数 $b (0 \\le a, b \\le 10^{9})$。", "outputFormat": "第一行输出使用 ICPC 卡获得门票的概率。第二行输出使用 ACM 卡获得门票的概率。答案的绝对误差不超过 $10^{-9}$。", "hint": "时间限制：1 秒，内存限制：128 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6998", "type": "P", "difficulty": 6, "samples": [["15 3\n9 1 2 3 4 5 6 7 8 3\n7 2 9 10 11 12 13 10\n5 2 14 9 15 10\n", "1\n2 2\n"], ["2 1\n2 1 2\n", "1\n2 1\n"], ["15 7\n3 1 2 3\n3 4 2 5\n3 6 2 7\n3 8 2 9\n3 10 2 11\n3 12 2 13\n3 14 2 15\n", "6\n2 11\n3 5\n5 2\n7 2\n11 1\n13 1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Cactus Automorphisms", "background": "", "description": "\n\nNEERC had featured a number of problems in previous years about cactuses -- connected undirected graphs in which every edge belongs to at most one simple cycle. Intuitively, cactus is a generalization of a tree where some cycles are allowed.\n\nIn $2005$ , the first year where problems about cactuses had appeared, the problem was called simply `Cactus`. In $2007$ it was `Cactus Reloaded` and in $2010$ it was called `Cactus Revolution`. An example of cactus from NEERC $2007$ problem is given on the picture below.\n\n![](/upload/images2/cac.png)\n\nThe challenge that judges face when preparing test cases for those problems is that some wrong solutions may depend on the numbering of vertices in the input file. So, for the most interesting test cases judges typically include several inputs with the same graph, but having a different numbering of vertices. However, some graphs are so regular that the graph remains the same even if you renumber its vertices. Judges need some metric about the graph that tells how regular the given graph is in order to make an objective decision about the number of test cases that need to be created for this graph.\n\nThe metric you have to compute is the number of graph automorphisms. Given an undirected graph $(V , E)$ , where $V$ is a set of vertices and $E$ is a set of edges, where each edge is a set of two distinct vertices ${v_{1}, v_{2}} (v_{1}, v_{2} ∈ V ),$ graph automorphism is a bijection $m$ from $V$ onto $V$ , such that for each pair of vertices $v_{1}$ and $v_{2}$ that are connected by an edge (so ${v_{1}, v_{2}} ∈ E)$ the following condition holds: ${m(v_{1}), m(v_{2})} ∈ E$ .\n\nEach graph has at least one automorphism (one where $m$ is an identity function) and may have up to $n$ ! automorphisms for a graph with $n$ vertices. Because the number of automorphisms may be a very big number, the answer must be presented as a prime factorization $∏^{k}_{i=1} p_{i}^{q_{i}},$ where $p_{i}$ are prime numbers in ascending order $(p_{i} \\ge 2 , p_{i} 0)$ .\n\n", "inputFormat": "\n\nThe first line of the input file contains two integer numbers $n$ and $m (1 \\le n \\le 50 000 , 0 \\le m \\le 50 000)$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ . Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths.\n\nEach of the following $m$ lines contains a path in the graph. A path starts with an integer number $k_{i} (2 \\le k_{i} \\le 1000)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. Adjacent vertices in a path are distinct. Path can go to the same vertex multiple times, but every edge is traversed exactly once in the whole input file. There are no multiedges in the graph (there is at most one edge between any two vertices).\n\nThe graph in the input file is a cactus.\n\n", "outputFormat": "\n\nOn the first line of the output file write number $k$ -- the number of prime factors in the factorization of the number of graph automorphisms. Write $0$ if the number of graph automorphisms is $1$ . On the following $k$ lines write prime numbers $p_{i}$ and their powers $q_i$ separated by a space. Prime numbers must be given in ascending order.\n\n", "hint": "Time limit: 5 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Cactus Automorphisms", "background": "", "description": "\n\nNEERC had featured a number of problems in previous years about cactuses -- connected undirected graphs in which every edge belongs to at most one simple cycle. Intuitively, cactus is a generalization of a tree where some cycles are allowed.\n\nIn $2005$ , the first year where problems about cactuses had appeared, the problem was called simply `Cactus`. In $2007$ it was `Cactus Reloaded` and in $2010$ it was called `Cactus Revolution`. An example of cactus from NEERC $2007$ problem is given on the picture below.\n\n![](/upload/images2/cac.png)\n\nThe challenge that judges face when preparing test cases for those problems is that some wrong solutions may depend on the numbering of vertices in the input file. So, for the most interesting test cases judges typically include several inputs with the same graph, but having a different numbering of vertices. However, some graphs are so regular that the graph remains the same even if you renumber its vertices. Judges need some metric about the graph that tells how regular the given graph is in order to make an objective decision about the number of test cases that need to be created for this graph.\n\nThe metric you have to compute is the number of graph automorphisms. Given an undirected graph $(V , E)$ , where $V$ is a set of vertices and $E$ is a set of edges, where each edge is a set of two distinct vertices ${v_{1}, v_{2}} (v_{1}, v_{2} ∈ V ),$ graph automorphism is a bijection $m$ from $V$ onto $V$ , such that for each pair of vertices $v_{1}$ and $v_{2}$ that are connected by an edge (so ${v_{1}, v_{2}} ∈ E)$ the following condition holds: ${m(v_{1}), m(v_{2})} ∈ E$ .\n\nEach graph has at least one automorphism (one where $m$ is an identity function) and may have up to $n$ ! automorphisms for a graph with $n$ vertices. Because the number of automorphisms may be a very big number, the answer must be presented as a prime factorization $∏^{k}_{i=1} p_{i}^{q_{i}},$ where $p_{i}$ are prime numbers in ascending order $(p_{i} \\ge 2 , p_{i} 0)$ .\n\n", "inputFormat": "\n\nThe first line of the input file contains two integer numbers $n$ and $m (1 \\le n \\le 50 000 , 0 \\le m \\le 50 000)$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ . Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths.\n\nEach of the following $m$ lines contains a path in the graph. A path starts with an integer number $k_{i} (2 \\le k_{i} \\le 1000)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. Adjacent vertices in a path are distinct. Path can go to the same vertex multiple times, but every edge is traversed exactly once in the whole input file. There are no multiedges in the graph (there is at most one edge between any two vertices).\n\nThe graph in the input file is a cactus.\n\n", "outputFormat": "\n\nOn the first line of the output file write number $k$ -- the number of prime factors in the factorization of the number of graph automorphisms. Write $0$ if the number of graph automorphisms is $1$ . On the following $k$ lines write prime numbers $p_{i}$ and their powers $q_i$ separated by a space. Prime numbers must be given in ascending order.\n\n", "hint": "Time limit: 5 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Cactus Automorphisms", "background": "", "description": "NEERC 在前几年中曾出现过一些关于仙人掌图的问题——仙人掌图是一个连通的无向图，其中每条边最多属于一个简单环。从直观上看，仙人掌图是树的一种推广，其中允许存在一些环。\n\n在 2005 年，首次出现关于仙人掌图的问题时，问题被简单地称为“Cactus”。在 2007 年，它被称为“Cactus Reloaded”，而在 2010 年，它被称为“Cactus Revolution”。下图展示了 NEERC 2007 年问题中的一个仙人掌图示例。\n\n![](/upload/images2/cac.png)\n\n在为这些问题准备测试用例时，评委面临的挑战是，一些错误的解决方案可能依赖于输入文件中顶点的编号。因此，对于最有趣的测试用例，评委通常会包含几个具有相同图但顶点编号不同的输入。然而，有些图是如此规则，以至于即使重新编号其顶点，图仍保持不变。评委需要一些关于图的度量来判断给定图的规则性，以便对需要为该图创建的测试用例数量做出客观决定。\n\n你需要计算的度量是图的自同构数量。给定一个无向图 $(V , E)$，其中 $V$ 是顶点集，$E$ 是边集，每条边是由两个不同顶点组成的集合 $\\{v_{1}, v_{2}\\} (v_{1}, v_{2} \\in V)$，图的自同构是一个从 $V$ 到 $V$ 的双射 $m$，使得对于每对由边连接的顶点 $v_{1}$ 和 $v_{2}$（即 $\\{v_{1}, v_{2}\\} \\in E$），以下条件成立：$\\{m(v_{1}), m(v_{2})\\} \\in E$。\n\n每个图至少有一个自同构（当 $m$ 是恒等函数时），对于具有 $n$ 个顶点的图，最多可能有 $n!$ 个自同构。由于自同构的数量可能是一个非常大的数字，答案必须以素因数分解的形式呈现 $\\prod^{k}_{i=1} p_{i}^{q_{i}}$，其中 $p_{i}$ 是按升序排列的素数 $(p_{i} \\ge 2, q_{i} > 0)$。", "inputFormat": "输入文件的第一行包含两个整数 $n$ 和 $m (1 \\le n \\le 50 000, 0 \\le m \\le 50 000)$。这里 $n$ 是图中的顶点数。顶点从 $1$ 到 $n$ 编号。图的边由一组边不重复的路径表示，其中 $m$ 是这样的路径数。\n\n接下来的 $m$ 行中的每一行包含图中的一条路径。路径以一个整数 $k_{i} (2 \\le k_{i} \\le 1000)$ 开头，后跟 $k_{i}$ 个从 $1$ 到 $n$ 的整数。这些 $k_{i}$ 个整数表示路径的顶点。路径中的相邻顶点是不同的。路径可以多次经过同一顶点，但整个输入文件中每条边恰好被遍历一次。图中没有重边（任意两个顶点之间最多有一条边）。\n\n输入文件中的图是一个仙人掌图。", "outputFormat": "在输出文件的第一行写入数字 $k$——图自同构数量的素因数分解中的素因子数量。如果图自同构的数量是 $1$，则写入 $0$。在接下来的 $k$ 行中写入素数 $p_{i}$ 及其幂 $q_i$，用空格分隔。素数必须按升序给出。", "hint": "时间限制：5 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6999", "type": "P", "difficulty": 6, "samples": [["5\nnorth\neastern\neuropean\nregional\ncontest\n", "31\n0\n7 n\n2 o\n18 t\n4 h\n29 e\n17 a\n7 s\n8 t\n9 e\n10 r\n11 n\n6 u\n13 r\n14 o\n15 p\n16 e\n3 r\n18 e\n19 g\n20 i\n21 o\n22 n\n23 a\n24 l\n1 c\n26 o\n27 n\n28 t\n6 s\n30 t\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Dictionary", "background": "", "description": "\n\nPetr and Dmitry are working on a novel data compression scheme. Their task is to compress a given set of words. To compress a given set of words they have to build a rooted tree. Each edge of the tree is marked with exactly one letter.\n\nLet us define a dictionary that is produced by this kind of tree as a set of words that can be constructed by concatenating letters on edges on any path from any vertex in the tree (not necessarily root) and going away from root down to the leaves (but not necessarily finishing on a leaf).\n\nBoys have to construct such a tree with a dictionary that is a superset of the set of words that they are given to compress. This tree should have the smallest number of vertices between trees that satisfy the above condition. Any tree with the same number of vertices will do. Your task is to help them.\n\n![](/upload/images2/dict.png)\n\nFor example, in a tree on the picture above with the root marked as $1$ , a path from $7$ to $5$ reads `north`, a path from $16$ to $12$ reads `eastern`, a path from $29$ to $2$ reads `european`, a path from $3$ to $25$ reads `regional`, and a path from $1$ to $31$ reads `contest`.\n\n", "inputFormat": "\n\nThe first line of the input file contains the number of words in a given set $n (1 \\le n \\le 50)$ . The following $n$ lines contain different non-empty words, one word per line, consisting of lowercase English letters. The length of each word is at most $10$ characters.\n\n", "outputFormat": "\n\nOn the first line output the number of vertices in the tree $m$ . The following $m$ lines shall contain descriptions of tree vertices, one description per line. Vertices are indexed from $1$ to $n$ in the order of their corresponding description lines. If the corresponding vertex is a tree root, then its description line shall contain a single integer number $0$ , otherwise its description line shall contain an index of its parent node and a letter on the edge to its parent node, separated by a space.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Dictionary", "background": "", "description": "\n\nPetr and Dmitry are working on a novel data compression scheme. Their task is to compress a given set of words. To compress a given set of words they have to build a rooted tree. Each edge of the tree is marked with exactly one letter.\n\nLet us define a dictionary that is produced by this kind of tree as a set of words that can be constructed by concatenating letters on edges on any path from any vertex in the tree (not necessarily root) and going away from root down to the leaves (but not necessarily finishing on a leaf).\n\nBoys have to construct such a tree with a dictionary that is a superset of the set of words that they are given to compress. This tree should have the smallest number of vertices between trees that satisfy the above condition. Any tree with the same number of vertices will do. Your task is to help them.\n\n![](/upload/images2/dict.png)\n\nFor example, in a tree on the picture above with the root marked as $1$ , a path from $7$ to $5$ reads `north`, a path from $16$ to $12$ reads `eastern`, a path from $29$ to $2$ reads `european`, a path from $3$ to $25$ reads `regional`, and a path from $1$ to $31$ reads `contest`.\n\n", "inputFormat": "\n\nThe first line of the input file contains the number of words in a given set $n (1 \\le n \\le 50)$ . The following $n$ lines contain different non-empty words, one word per line, consisting of lowercase English letters. The length of each word is at most $10$ characters.\n\n", "outputFormat": "\n\nOn the first line output the number of vertices in the tree $m$ . The following $m$ lines shall contain descriptions of tree vertices, one description per line. Vertices are indexed from $1$ to $n$ in the order of their corresponding description lines. If the corresponding vertex is a tree root, then its description line shall contain a single integer number $0$ , otherwise its description line shall contain an index of its parent node and a letter on the edge to its parent node, separated by a space.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Dictionary", "background": "", "description": "Petr和Dmitry正在研究一种新的数据压缩方案。他们的任务是压缩一组给定的单词。为了压缩给定的一组单词，他们必须建立一个有根的树。这棵树的每一个边缘都有一个字母。\n\n让我们定义一个由这种树生成的字典，它是一组单词，可以通过在树的任何顶点（不一定是根节点）的任何路径上的边上连接字母，从根向下到叶子（但不一定在叶节点上完成）来构造。\n\n男孩们必须用字典来构造这样一棵树，字典是一组单词的超集，他们被给予压缩。满足上述条件的树之间的顶点数应该最小。任何具有相同顶点数的树都可以。你的任务是帮助他们。\n\n例如，上图中的一棵树的根标记为1，从7到5的路径表示north，从16到12的路径表示eastern，从29到22的路径表示european，从3到25的路径表示regional，从1到31的路径表示contest。", "inputFormat": "第一行是一个数字n（0<n<50）\n接下来n行都是一个长度小于10的字符串", "outputFormat": "在第一行输出树中的顶点数m。每行树应包含一行描述的顶点。顶点按其相应描述行的顺序从1索引到n。如果对应的顶点是树根，则其描述行应包含单个整数0，否则其描述行应包含其父节点的索引和父节点边缘上的字母，用空格隔开。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7000", "type": "P", "difficulty": 6, "samples": [["4\n5 1\n2 4\n3 7\n7 3\n", "3.5 2.5 5.5 4.5\n"], ["5\n1 1\n1 4\n4 7\n7 4\n7 1\n", "1 1 7 4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2013", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Easy Geometry", "background": "", "description": "\n\nEva studies geometry. The current topic is about convex polygons, but Eva prefers rectangles. Eva's workbook contains drawings of several convex polygons and she is curious what is the area of the maximum rectangle that fits inside each of them.\n\n![](/upload/images2/eg.png)\n\nHelp Eva! Given the convex polygon, find the rectangle of the maximum possible area that fits inside this polygon. Sides of the rectangle must be parallel to the coordinate axes.\n\n", "inputFormat": "\n\nThe first line contains a single integer $n$ -- the number of sides of the polygon $(3 \\le n \\le 100 000)$ . The following $n$ lines contain Cartesian coordinates of the polygon's vertices -- two integers $x_{i}$ and $y_{i} (-10^{9} \\le x_{i}, y_{i} \\le 10^{9})$ per line. Vertices are given in the clockwise order.\n\nThe polygon is convex.\n\n", "outputFormat": "\n\nOutput four real numbers $x_{mi_n}, y_{mi_n}, x_{max}$ and $y_{max}$ -- the coordinates of two rectangle's corners $(x_{mi_n} < x_{max}, y_{mi_n} < y_{max}).$ The rectangle must fit into the polygon and have the maximum possible area.\n\nThe absolute precision of the coordinates should be at least $10-^{5}.$\n\nThe absolute or relative precision of the rectangle area should be at least $10^{-5}.$ That is, if $A'$ ; is the actual maximum possible area, the following must hold: $mi_n(|A-A'|,|A−A'|/A') ) \\le 10^{-5}.$\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Easy Geometry", "background": "", "description": "\n\nEva studies geometry. The current topic is about convex polygons, but Eva prefers rectangles. Eva's workbook contains drawings of several convex polygons and she is curious what is the area of the maximum rectangle that fits inside each of them.\n\n![](/upload/images2/eg.png)\n\nHelp Eva! Given the convex polygon, find the rectangle of the maximum possible area that fits inside this polygon. Sides of the rectangle must be parallel to the coordinate axes.\n\n", "inputFormat": "\n\nThe first line contains a single integer $n$ -- the number of sides of the polygon $(3 \\le n \\le 100 000)$ . The following $n$ lines contain Cartesian coordinates of the polygon's vertices -- two integers $x_{i}$ and $y_{i} (-10^{9} \\le x_{i}, y_{i} \\le 10^{9})$ per line. Vertices are given in the clockwise order.\n\nThe polygon is convex.\n\n", "outputFormat": "\n\nOutput four real numbers $x_{mi_n}, y_{mi_n}, x_{max}$ and $y_{max}$ -- the coordinates of two rectangle's corners $(x_{mi_n} < x_{max}, y_{mi_n} < y_{max}).$ The rectangle must fit into the polygon and have the maximum possible area.\n\nThe absolute precision of the coordinates should be at least $10-^{5}.$\n\nThe absolute or relative precision of the rectangle area should be at least $10^{-5}.$ That is, if $A'$ ; is the actual maximum possible area, the following must hold: $mi_n(|A-A'|,|A−A'|/A') ) \\le 10^{-5}.$\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Easy Geometry", "background": "", "description": "**一句话题意：** \n\n给你一个凸 $n$ 边形，并按顺时针给出每一个顶点的坐标，求出在这个凸 $n$ 边形之内的面积最大的一个边平行坐标轴的矩形的四个顶点。", "inputFormat": "第一行是一个正整数 $n$ ，且 $3\\le n \\le 100000$ 。\n\n接下来 $n$ 行，每行两个整数 $x$ ， $y$ ，代表一个顶点的 $x$ 坐标和 $y$ 坐标。 $-10^9 \\le x,y \\le 10^9$ 。", "outputFormat": "输出四个整数 $x_{min},y_{min},x_{max},y_{max}$ ，代表你给出的这个面积最大的矩形。其中 $x_{min} \\le x_{max} $ ， $y_{min} \\le y_{max} $ 。\n\n精度要求：如果 $A$ 是你算出的值， $A'$ 是真实的最大面积，那么你需要保证 $min( |A-A'|,|A-A'|/A') \\le10^{-5}$ 。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7001", "type": "P", "difficulty": 1, "samples": [["A**1MP19*\n4\nA001MP199\nE885EE098\nA111MP199\nKT7351TTB\n", "2\nA001MP199\nA111MP199\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Fraud Busters", "background": "", "description": "\n\nThe number of cars in Default City that travel to the city center daily vastly exceeds the number of available parking spots. The City Council had decided to introduce parking fees to combat the problem of overspill parking on the city streets. Parking fees are enforced using an automated vehicle registration plate scanners that take a picture of the vehicle registration plate, recognize the sequence of digits and letters in the code on the plate, and check the code against a vehicle registration database to ensure that parking fees are dutifully paid or to automatically issue a fine to the vehicle owner otherwise.\n\nAs soon as parking fees were introduced, a parking fee fraud had appeared. Some vehicle owners had started to close one or several digits or letters on their vehicle registration plate with pieces of paper while they park, thus making it impossible for the current version of the automated scanner to recognize their vehicle's registration code and to issue them a fine.\n\nThe Default City Council had instituted the Fraud Busters Initiative (FBI) to design a solution to prevent this kind of fraud. The overall approach that FBI had selected is to expand the number of vehicle features that scanners recognize (including features like vehicle type and color), as well as excluding from the list any vehicles that are detected to be elsewhere at this time. This information should help to identify the correct vehicle by narrowing down the search in the vehicle registration database.\n\nYou are working for FBI. Your colleagues had already written all the complex pieces of the recognition software that analyses various vehicle features and provides you with a list of registration codes that might potentially belong to a scanned car. Your task it to take this list and a recognized code from the license plate (which may be partially unrecognized) and find all the registration codes that match.\n\n", "inputFormat": "\n\nThe first line of the input file contains $9$ characters of the code as recognized by the scanner. Code that was recognized by the the scanner is represented as a sequence of $9$ digits, uppercase English letters, and characters $` \\times ` (star).$ Star represents a digit or a letter that scanner could not recognize.\n\nThe second line of the input file contains a single integer number $n (1 \\le n \\le 1000)$ -- the number of vehicle registration codes from the vehicle registration database.\n\nThe following $n$ lines contain the corresponding registration codes, one code per line. Vehicle registration codes are represented as a sequence of $9$ digits and uppercase English letters. All codes on these $n$ lines of the input file are different.\n\n", "outputFormat": "\n\nOn the first line of the output file write a single integer $k (0 \\le k \\le n)$ -- the number of codes from the input file that match the code that was recognized by the scanner. The code from the scanner matches the code from the database if the characters on all the corresponding positions in the codes are equal or the character from the scanner code is $` \\times `.$\n\nOn the following $k$ lines write the matching codes, one code per line, in the same order as they are given in the input file.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Fraud Busters", "background": "", "description": "\n\nThe number of cars in Default City that travel to the city center daily vastly exceeds the number of available parking spots. The City Council had decided to introduce parking fees to combat the problem of overspill parking on the city streets. Parking fees are enforced using an automated vehicle registration plate scanners that take a picture of the vehicle registration plate, recognize the sequence of digits and letters in the code on the plate, and check the code against a vehicle registration database to ensure that parking fees are dutifully paid or to automatically issue a fine to the vehicle owner otherwise.\n\nAs soon as parking fees were introduced, a parking fee fraud had appeared. Some vehicle owners had started to close one or several digits or letters on their vehicle registration plate with pieces of paper while they park, thus making it impossible for the current version of the automated scanner to recognize their vehicle's registration code and to issue them a fine.\n\nThe Default City Council had instituted the Fraud Busters Initiative (FBI) to design a solution to prevent this kind of fraud. The overall approach that FBI had selected is to expand the number of vehicle features that scanners recognize (including features like vehicle type and color), as well as excluding from the list any vehicles that are detected to be elsewhere at this time. This information should help to identify the correct vehicle by narrowing down the search in the vehicle registration database.\n\nYou are working for FBI. Your colleagues had already written all the complex pieces of the recognition software that analyses various vehicle features and provides you with a list of registration codes that might potentially belong to a scanned car. Your task it to take this list and a recognized code from the license plate (which may be partially unrecognized) and find all the registration codes that match.\n\n", "inputFormat": "\n\nThe first line of the input file contains $9$ characters of the code as recognized by the scanner. Code that was recognized by the the scanner is represented as a sequence of $9$ digits, uppercase English letters, and characters $` \\times ` (star).$ Star represents a digit or a letter that scanner could not recognize.\n\nThe second line of the input file contains a single integer number $n (1 \\le n \\le 1000)$ -- the number of vehicle registration codes from the vehicle registration database.\n\nThe following $n$ lines contain the corresponding registration codes, one code per line. Vehicle registration codes are represented as a sequence of $9$ digits and uppercase English letters. All codes on these $n$ lines of the input file are different.\n\n", "outputFormat": "\n\nOn the first line of the output file write a single integer $k (0 \\le k \\le n)$ -- the number of codes from the input file that match the code that was recognized by the scanner. The code from the scanner matches the code from the database if the characters on all the corresponding positions in the codes are equal or the character from the scanner code is $` \\times `.$\n\nOn the following $k$ lines write the matching codes, one code per line, in the same order as they are given in the input file.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Fraud Busters", "background": "", "description": "在 Default City，每天进入市中心的汽车数量远远超过可用停车位的数量。市议会决定引入停车费，以解决城市街道上溢出的停车问题。停车费通过自动车牌扫描仪来执行，该扫描仪拍摄车辆车牌的照片，识别车牌上的字母和数字序列，并将代码与车辆注册数据库进行比对，以确保停车费已被支付，或者自动向车主开具罚单。  \n\n停车费一经引入，停车费欺诈行为就出现了。一些车主开始在停车时用纸片遮住车牌上的一个或几个数字或字母，从而使当前版本的自动扫描仪无法识别其车辆的注册代码，也无法对其开具罚单。  \n\nDefault City 市议会成立了“欺诈克星计划”（FBI）来设计解决方案以防止此类欺诈行为。FBI 选择的总体方法是扩展扫描仪识别的车辆特征数量（包括车辆类型和颜色等特征），并从列表中排除在该时间被检测到在其他地方的车辆。这些信息有助于通过缩小车辆注册数据库中的搜索范围来识别正确的车辆。  \n\n你在为 FBI 工作。你的同事们已经编写了所有复杂的识别软件，这些软件分析各种车辆特征，并为你提供可能属于被扫描车辆的注册代码列表。你的任务是获取这个列表和车牌上识别出的代码（可能部分未识别），并找到所有匹配的注册代码。", "inputFormat": "输入文件的第一行包含扫描仪识别出的代码的 $9$ 个字符。扫描仪识别出的代码表示为 $9$ 个数字、大写英文字母和字符 $`\\times`$（星号）的序列。星号表示扫描仪无法识别的数字或字母。  \n\n输入文件的第二行包含一个整数 $n (1 \\le n \\le 1000)$ ——车辆注册数据库中的车辆注册代码数量。  \n\n接下来的 $n$ 行包含相应的注册代码，每行一个代码。车辆注册代码表示为 $9$ 个数字和大写英文字母的序列。输入文件中这 $n$ 行的所有代码都是不同的。", "outputFormat": "输出文件的第一行写一个整数 $k (0 \\le k \\le n)$ ——与扫描仪识别的代码匹配的输入文件中的代码数量。如果代码中所有对应位置的字符相等，或者扫描仪代码中的字符是 $`\\times`$，则扫描仪的代码与数据库中的代码匹配。  \n\n在接下来的 $k$ 行中，按输入文件中给出的顺序，每行写一个匹配的代码。", "hint": "时间限制：1 秒，内存限制：128 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7002", "type": "P", "difficulty": 5, "samples": [["5 4 10\n20 10 20 15 10\n0 10\n40 20\n50 0\n70 30\n", "52.342888649592545\n16.0\n0.0\n70.0\n65.3\n65.3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Green Energy", "background": "", "description": "\n\nThe technological progress in Flatland is impressive. This year, for example, the solar power stations of a new type will be build. In these stations solar panels are mounted not on the ground, but on high towers, along their heights.\n\nThere are $n$ towers to be mounted. The towers are already bought. The height of i-th tower is $h_{i}.$ Now engineers want to choose the points where they should be mounted to get the maximal total power.\n\nThe landscape of a territory of the power plant is described by a polyline with $m$ vertices. Vertices of the landscape polyline have coordinates $(x_{i}, y_{i}),$ such that $x_{i} < x_{i+1}.$\n\nThe sun angle is always $α$ degrees in Flatland. The sun is shining from the top-left to the bottom-right. The power that is produced by a tower depends on the length of its surface illuminated by the sun.\n\nWhen two towers are mounted close to each other, the shadow of the left tower may fall onto the right tower, so the power, produced by the right tower, decreases. Also, the landscape itself may contain high points that drop shadows on some towers.\n\n![](/upload/images2/ge.png)\n\nYour task is to find the points on the territory of the plant to mount the given towers to maximize the total length of towers surface that is illuminated by the sun.\n\n", "inputFormat": "\n\nThe first line of the input file contains three integers $n , m$ and $α (1 \\le n \\le 10^{4}, 2 \\le m \\le 10^{4}, 1 \\le α < 90)$ . The second line contains $n$ integers $h_{i}$ -- the heights of the towers $(1 \\le h_{i} \\le 10^{3}).$ The following $m$ lines contain pairs $x_{i}, y_{i}$ -- the coordinates of the vertices of the landscape $(|x_{i}| \\le 10^{5}, x_{i} < x_{i+1}, |y_{i}| \\le 10^{3}).$\n\n", "outputFormat": "\n\nOn the first line output the maximal possible summary length of towers that can be illuminated by the sun with an absolute precision of at least $10^{-6}.$ On the next $n$ lines output the x-coordinates of the points where the towers should be mounted to achieve this maximum with an absolute precision of at least $10^{-9}.$ Towers should be listed in the same order they are given in the input file.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Green Energy", "background": "", "description": "\n\nThe technological progress in Flatland is impressive. This year, for example, the solar power stations of a new type will be build. In these stations solar panels are mounted not on the ground, but on high towers, along their heights.\n\nThere are $n$ towers to be mounted. The towers are already bought. The height of i-th tower is $h_{i}.$ Now engineers want to choose the points where they should be mounted to get the maximal total power.\n\nThe landscape of a territory of the power plant is described by a polyline with $m$ vertices. Vertices of the landscape polyline have coordinates $(x_{i}, y_{i}),$ such that $x_{i} < x_{i+1}.$\n\nThe sun angle is always $α$ degrees in Flatland. The sun is shining from the top-left to the bottom-right. The power that is produced by a tower depends on the length of its surface illuminated by the sun.\n\nWhen two towers are mounted close to each other, the shadow of the left tower may fall onto the right tower, so the power, produced by the right tower, decreases. Also, the landscape itself may contain high points that drop shadows on some towers.\n\n![](/upload/images2/ge.png)\n\nYour task is to find the points on the territory of the plant to mount the given towers to maximize the total length of towers surface that is illuminated by the sun.\n\n", "inputFormat": "\n\nThe first line of the input file contains three integers $n , m$ and $α (1 \\le n \\le 10^{4}, 2 \\le m \\le 10^{4}, 1 \\le α < 90)$ . The second line contains $n$ integers $h_{i}$ -- the heights of the towers $(1 \\le h_{i} \\le 10^{3}).$ The following $m$ lines contain pairs $x_{i}, y_{i}$ -- the coordinates of the vertices of the landscape $(|x_{i}| \\le 10^{5}, x_{i} < x_{i+1}, |y_{i}| \\le 10^{3}).$\n\n", "outputFormat": "\n\nOn the first line output the maximal possible summary length of towers that can be illuminated by the sun with an absolute precision of at least $10^{-6}.$ On the next $n$ lines output the x-coordinates of the points where the towers should be mounted to achieve this maximum with an absolute precision of at least $10^{-9}.$ Towers should be listed in the same order they are given in the input file.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Green Energy", "background": "", "description": "平地上的技术进步令人惊叹。今年正要建造一种新型的太阳能发电站。在这些发电站中，太阳能电池板不是安装在地面上，而是安装在高塔上。\n\n在二为世界中有要安装$i$个高塔。这些塔塔高固定。第$i$座塔的高度是$h_i$。现在，工程师们想要选择安装点，以获得最大的总功率。\n\n电厂区域由有$m$顶点的线连接。这些线的顶点坐标为$(x_i,y_i)$满足$x_i<x_{i+1}$\n在平地上，太阳的角度总是$\\alpha$度。太阳从左上角照射到右下角。塔产生的功率取决于其表面被太阳照射的面积(其实是长度)。\n\n当安装的两个塔彼此靠近时，左侧塔的阴影可能落在右侧塔上，从而右侧塔产生的功率降低。此外，电厂区域本身可能包含在某些塔楼上投下阴影的高点。\n\n你的任务是在电厂区域内找到安装给定塔架的点，以得到太阳照射下塔架最大总表面积(长度)。", "inputFormat": "输入第一行包含三个整数：$n$,$m$,$\\alpha$ $(1 \\le n \\le 10^4,2 \\le m \\le 10^4,1 \\le \\alpha <90)$。第二行包含$n$整数$h_i$(塔高）$(1 \\le h_i \\le 10^3)$。后面的$m$行每行有$x_i$,$y_i$一对数（电厂顶点坐标)$(|x_i|\\le 10^5,x_i < x_{i+1},|y_i|\\le 10^3)$", "outputFormat": "第一行:以至少$10^{-6}$精度输出可被太阳照亮的塔的最大可能汇总面积（长度)。在后n行上，输出此时塔安装点的x坐标，绝对精度至少为$10^{-9}$。塔的输出顺序应与输入顺序相同。", "hint": "时间限制：1h\n\n空间顺序：128PB", "locale": "zh-CN"}}}
{"pid": "P7003", "type": "P", "difficulty": 5, "samples": [["4\n1 2 3 3\n", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Hack Protection", "background": "", "description": "\n\nPavel is sending to his friend Egor some array of non-negative integers. He wants to be sure, that nobody hacks the array before his friend gets it. To solve this problem Pavel need to compute some kind of a checksum or a digest for his array. Pavel has an innovative mind, so he invents the following algorithm to compute the digest for his array: count the number of subarrays in which the bitwise xor of the numbers in the subarray is equal to the bitwise and of the same numbers.\n\nFor example, consider an array of four binary numbers `01`, `10`, `11`, and `11`. The table below to the left lists the results of the bitwise xor of numbers for each subarray of this array, and the table below to the right list the results of the bitwise and of numbers for each subarray of this array. The rows of the table correspond to the starting elements of the subarray from the $1st$ element of the array to the $4th$ one, while columns correspond to the ending elements of the subarray. Matching values are highlighted with gray background.\n\n![](/upload/images2/hp.png)\n\nYour task is to help Pavel compute this kind of a digest of the given array.\n\n", "inputFormat": "\n\nThe first line contains one integer $n (1 \\le n \\le 100 000)$ . The second line contains $n$ non-negative integers $a_{i} (0 \\le a_{i} \\le 2^{31}-1)$ that are written in decimal notation.\n\n", "outputFormat": "\n\nOn the first line of the output print Pavel's digest of the given array.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Hack Protection", "background": "", "description": "\n\nPavel is sending to his friend Egor some array of non-negative integers. He wants to be sure, that nobody hacks the array before his friend gets it. To solve this problem Pavel need to compute some kind of a checksum or a digest for his array. Pavel has an innovative mind, so he invents the following algorithm to compute the digest for his array: count the number of subarrays in which the bitwise xor of the numbers in the subarray is equal to the bitwise and of the same numbers.\n\nFor example, consider an array of four binary numbers `01`, `10`, `11`, and `11`. The table below to the left lists the results of the bitwise xor of numbers for each subarray of this array, and the table below to the right list the results of the bitwise and of numbers for each subarray of this array. The rows of the table correspond to the starting elements of the subarray from the $1st$ element of the array to the $4th$ one, while columns correspond to the ending elements of the subarray. Matching values are highlighted with gray background.\n\n![](/upload/images2/hp.png)\n\nYour task is to help Pavel compute this kind of a digest of the given array.\n\n", "inputFormat": "\n\nThe first line contains one integer $n (1 \\le n \\le 100 000)$ . The second line contains $n$ non-negative integers $a_{i} (0 \\le a_{i} \\le 2^{31}-1)$ that are written in decimal notation.\n\n", "outputFormat": "\n\nOn the first line of the output print Pavel's digest of the given array.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Hack Protection", "background": null, "description": "Pavel 正在给他的朋友 Egor 发送一些非负整数数组。他希望确保在他的朋友收到数组之前，没有人篡改过它。为了解决这个问题，Pavel 需要为他的数组计算某种校验和或摘要。Pavel 有一个创新的头脑，所以他发明了以下算法来计算他的数组的摘要：计算子数组中数字的按位异或等于相同数字的按位与的子数组的数量。\n\n例如，考虑一个由四个二进制数 `01`、`10`、`11` 和 `11` 组成的数组。左下表列出了该数组每个子数组的数字的按位异或结果，右下表列出了该数组每个子数组的数字的按位与结果。表格的行对应于子数组的起始元素，从数组的第 $1$ 个元素到第 $4$ 个元素，而列对应于子数组的结束元素。匹配的值用灰色背景突出显示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9rnw871w.png)\n\n你的任务是帮助 Pavel 计算给定数组的这种摘要。", "inputFormat": "第一行包含一个整数 $n (1 \\le n \\le 100 000)$。第二行包含 $n$ 个以十进制表示的非负整数 $a_{i} (0 \\le a_{i} \\le 2^{31}-1)$。", "outputFormat": "输出的第一行打印给定数组的 Pavel 的摘要。", "hint": "时间限制：1 秒，内存限制：128 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7004", "type": "P", "difficulty": 6, "samples": [["2 2\nYes\nNo\nYes\nYes", "check 1 3\ncheck 3 5\ncheck 2 4\ncheck 4 5\nanswer 5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Interactive Interception", "background": "", "description": "This is an interactive problem.\n\nNorth Eastern Emergency Rocket Control agency (NEERC) has developed a new radar control system that is designed to better control ballistic rocket interception. To test the new system NEERC agency had developed a mathematical model that is intended to show this system’s abilities.\n\nLet us represent a rocket as a point on a line. Initially the point is at some unknown integer location between $0$ and $p$, inclusive. It has some unknown speed of $q$ which is an integer between $0$ and $v$, inclusive.\n\nEach second the following happens. First, the control system makes a query to the radar of a form “`check L R`” and gets an answer whether the point is currently between $L$ and $R$, inclusive, or not.\n\nAfter that, the point’s coordinate increases by $q$.\n\nThe goal of the radar control system is to learn the exact location of the point at the beginning of some second. When it does learn the point’s location, then instead of making a query to the radar, it gives a command to intercept the point at that location.\n\nYou have to implement the control system that locates and intercepts the point while making at most $100$ queries to the radar.\n\n### Interaction protocol\nInteraction starts with your program reading two integers — the values of $p$ and $v$ from the standard input($1\\leq p\\leq 10^5$,$1\\leq v\\leq 10^5$).\n\nAfter that your program must print commands to the standard output. Each command must be one of the following two.\n\n- “`check L R`” — make a query to the radar to get an answer whether the point is currently between $L$ and $R$, inclusive, or not. The answer must be read from the standard input and is either “`Yes`” or “`No`”. After that the point’s coordinate is increased by $q$. $L$ and $R$ must be integers.\n- “`answer x`” — the exact coordinate $x$ of the point is known, and you order to intercept the point. After printing this command your program must exit.\n\nYour program must write end-of-line sequence and flush the standard output after each command, including the last command “`answer x`” (end-of-line must be written and flushed before exiting).\n\n", "inputFormat": "", "outputFormat": "", "hint": "In the given example the point was initially at location $1$ and is moving at a speed $q = 1$.", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Interactive Interception", "background": "", "description": "This is an interactive problem.\n\nNorth Eastern Emergency Rocket Control agency (NEERC) has developed a new radar control system that is designed to better control ballistic rocket interception. To test the new system NEERC agency had developed a mathematical model that is intended to show this system’s abilities.\n\nLet us represent a rocket as a point on a line. Initially the point is at some unknown integer location between $0$ and $p$, inclusive. It has some unknown speed of $q$ which is an integer between $0$ and $v$, inclusive.\n\nEach second the following happens. First, the control system makes a query to the radar of a form “`check L R`” and gets an answer whether the point is currently between $L$ and $R$, inclusive, or not.\n\nAfter that, the point’s coordinate increases by $q$.\n\nThe goal of the radar control system is to learn the exact location of the point at the beginning of some second. When it does learn the point’s location, then instead of making a query to the radar, it gives a command to intercept the point at that location.\n\nYou have to implement the control system that locates and intercepts the point while making at most $100$ queries to the radar.\n\n### Interaction protocol\nInteraction starts with your program reading two integers — the values of $p$ and $v$ from the standard input($1\\leq p\\leq 10^5$,$1\\leq v\\leq 10^5$).\n\nAfter that your program must print commands to the standard output. Each command must be one of the following two.\n\n- “`check L R`” — make a query to the radar to get an answer whether the point is currently between $L$ and $R$, inclusive, or not. The answer must be read from the standard input and is either “`Yes`” or “`No`”. After that the point’s coordinate is increased by $q$. $L$ and $R$ must be integers.\n- “`answer x`” — the exact coordinate $x$ of the point is known, and you order to intercept the point. After printing this command your program must exit.\n\nYour program must write end-of-line sequence and flush the standard output after each command, including the last command “`answer x`” (end-of-line must be written and flushed before exiting).\n\n", "inputFormat": "", "outputFormat": "", "hint": "In the given example the point was initially at location $1$ and is moving at a speed $q = 1$.", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Interactive Interception", "background": "", "description": "这是一个交互式问题。\n\n东北紧急火箭控制局（NEERC）开发了一种新的雷达控制系统，旨在更好地控制弹道火箭拦截。为了测试新系统，NEERC 机构开发了一个数学模型，旨在展示该系统的能力。\n\n让我们将火箭表示为一条线上的一个点。最初，该点位于 $0$ 到 $p$ 之间的某个未知整数位置（包括 $0$ 和 $p$）。它具有某个未知速度 $q$，这是一个介于 $0$ 和 $v$ 之间的整数（包括 $0$ 和 $v$）。\n\n每秒会发生以下情况。首先，控制系统向雷达发出一个形式为“`check L R`”的查询，并得到一个答案，指出该点当前是否在 $L$ 和 $R$ 之间（包括 $L$ 和 $R$）。之后，该点的坐标增加 $q$。\n\n雷达控制系统的目标是在某一秒开始时准确地确定该点的位置。当它确实知道该点的位置时，不再向雷达发出查询，而是发出命令在该位置拦截该点。\n\n你必须实现控制系统，在最多进行 100 次雷达查询的情况下定位并拦截该点。\n\n### 交互协议\n交互从你的程序读取两个整数——$p$ 和 $v$ 的值开始（$1 \\leq p \\leq 10^5$，$1 \\leq v \\leq 10^5$）。\n\n之后，你的程序必须向标准输出打印命令。每个命令必须是以下两种之一。\n\n- “`check L R`”——向雷达发出查询以获得答案，指出该点当前是否在 $L$ 和 $R$ 之间（包括 $L$ 和 $R$）。答案必须从标准输入读取，答案是“`Yes`”或“`No`”。之后，该点的坐标增加 $q$。$L$ 和 $R$ 必须是整数。\n- “`answer x`”——已知该点的确切坐标 $x$，并命令拦截该点。在打印此命令后，你的程序必须退出。\n\n你的程序必须在每个命令后，包括最后一个命令“`answer x`”后写入行结束符并刷新标准输出（在退出之前必须写入并刷新行结束符）。", "inputFormat": "", "outputFormat": "", "hint": "在给定的例子中，该点最初位于位置 $1$，并以速度 $q = 1$ 移动。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7005", "type": "P", "difficulty": 5, "samples": [["6\n@Petr: Leaving for #NEERC tomorrow!\n@Roman: This #NEERC is going to be awesome!\n@Stone_in_forest: Nothing happened today.\n@NEERCNews: @Petr Don't forget an umbrella :)\n@Lydia: @NEERCNews cares about @Petr - so cute ^_^\n@Lydia: @Lydia @NEERCNews @Petr it won't be raining though!\n", "3\n1 4 5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2013", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Join the Conversation", "background": "", "description": "\n\nAbstract Communication Mastership (ACM) is a software company that develops a unique social network called tWinter.\n\nEach tWinter user has a handle that starts with a commercial at $(‘@')$ character. Users of tWinter social network publish short messages to the network.\n\nIf a user's message contains another user's handle (preceded by a space or at the beginning of the message, and followed by a space or at the end of the message) then it is called a mention.\n\nA sequence of messages is called a conversation if each message in the sequence (except the first one) contains a mention of the author of the previous message in the sequence.\n\nYou are hired to find the longest conversation in the given chronological log of messages.\n\n", "inputFormat": "\n\nThe first line of the input file contains an integer $n (1 \\le n \\le 50 000)$ -- the number of messages in the chronological log.\n\nEach of the next $n$ lines contains a message preceded by its author's handle, a colon $(‘:')$ character, and a space.\n\nEach message is at most $139$ characters long. Each handle is at most $20$ characters long and does not contain colons or spaces.\n\nThe input file contains only characters with ASCII codes between $32$ and $126$ , inclusive, and line breaks.\n\n", "outputFormat": "\n\nOn the first line of the output file write the length of the longest conversation in the given log. On the second line write $1-based$ indices of the messages in that conversation in ascending order.\n\nIf there are multiple longest conversations, write any one of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Join the Conversation", "background": "", "description": "\n\nAbstract Communication Mastership (ACM) is a software company that develops a unique social network called tWinter.\n\nEach tWinter user has a handle that starts with a commercial at $(‘@')$ character. Users of tWinter social network publish short messages to the network.\n\nIf a user's message contains another user's handle (preceded by a space or at the beginning of the message, and followed by a space or at the end of the message) then it is called a mention.\n\nA sequence of messages is called a conversation if each message in the sequence (except the first one) contains a mention of the author of the previous message in the sequence.\n\nYou are hired to find the longest conversation in the given chronological log of messages.\n\n", "inputFormat": "\n\nThe first line of the input file contains an integer $n (1 \\le n \\le 50 000)$ -- the number of messages in the chronological log.\n\nEach of the next $n$ lines contains a message preceded by its author's handle, a colon $(‘:')$ character, and a space.\n\nEach message is at most $139$ characters long. Each handle is at most $20$ characters long and does not contain colons or spaces.\n\nThe input file contains only characters with ASCII codes between $32$ and $126$ , inclusive, and line breaks.\n\n", "outputFormat": "\n\nOn the first line of the output file write the length of the longest conversation in the given log. On the second line write $1-based$ indices of the messages in that conversation in ascending order.\n\nIf there are multiple longest conversations, write any one of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Join the Conversation", "background": "", "description": "Abstract Communication Mastership (ACM)是一家软件公司，开发一种名为$“tWinter”$的独特社交网络。\n\n每个$“tWinter”$用户都有一个句柄，句柄由$‘(’$或$‘‘’$或$‘@’$或$‘′’$或 $‘)’$开头。\n\n每个$“tWinter”$社交网络的用户可以向网络发布短消息。\n\n如果用户的消息包含另一个用户的句柄（句柄前面是空格或句柄是消息的开头并且后跟空格或消息末尾），则称为提及。\n\n如果消息序列中的每条消息（第一条消息除外）都提及序列中前一条消息的作者，则该消息序列称为会话。\n\n您需要在给定的消息时间顺序日志中查找最长的对话。", "inputFormat": "输入文件共$n+1$行；\n\n第一行包含一个整数$n(1≤n≤50000)$为消息日志中消息个数；\n\n接下来$n$行每行一条消息，前面是其作者的句柄，句柄后是一个冒号，冒号后为消息正文。\n\n每条消息长度最多为$139$个字符。每个手柄长度(不包含冒号或空格)最多为$20$个字符。\n\n输入文件仅包含 ASCII 代码介于32和126（含）之间和换行符。", "outputFormat": "输出文件共$2$行；\n\n第一行上，写入给定日志中最长对话的长度；\n\n在第二行写该对话中消息基于1的索引，按升序排列。", "hint": "时间限制：2S；\n\n空间限制：128MB。", "locale": "zh-CN"}}}
{"pid": "P7006", "type": "P", "difficulty": 4, "samples": [["6 3 4 2\n2 1 2 3 2 2\n2 1 1\n", "1\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Kabaleo Lite", "background": "", "description": "\n\nKabaleo Lite is a board game. The board consists of several stacks of conical chips of various colors. Only the color of the top chip of the stack is visible.\n\nEach player has a unique target color and a set of colored chips. The target color is hidden from other players, while the set of chips is visible to them. On his turn, player selects one of his chips and puts it on one of the board stacks, thus recoloring it to the color of the chosen chip.\n\nAfter the last turn, the number of visible board chips of each color is calculated. The winning color is the color that occurs the maximum times. The player (if any) that has this color as his target color, wins the game. If there is no such player or if there are two or more colors that occur the maximum times, the game ends in a draw.\n\nYou are playing your last chip in the Kabaleo Lite game. Other players also have one chip left. You want to determine all possible moves that lead you to winning the game. You do not know the target colors of other players and you cannot predict their moves, so your move must guarantee your victory regardless of moves of your opponents.\n\n", "inputFormat": "\n\nThe first line contains four integers $n , p , c$ and $h$ -- the number of stacks on the board $(1 \\le n \\le 10^{6}),$ the number of players $(1 \\le p \\le 10^{6}),$ the number of chips' colors $(p \\le c \\le 10^{6}),$ and your hidden color $(1 \\le h \\le c)$ .\n\nThe second line contains $n$ integers $b_{i}$ -- the color of the visible board chip for each stack on the board $(1 \\le b_{i} \\le c)$ .\n\nThe third line contains $p$ integers $l_{i}$ -- the color of the last chip for each player $(1 \\le l_{i} \\le c)$ . The players are numbered from one (you) to $n$ in the order of their turns.\n\n", "outputFormat": "\n\nThe first line must contain $w$ -- the number of winning moves.\n\nThe second line must contain $w$ distinct numbers $m_{i}$ -- the numbers of the stacks on which your chip should be put to win. Stacks are numbered starting from $1$ in the order that their visible colors are given in the input file. You can output their numbers in any order on this line.\n\nRemember, that your move should be winning regardless of the moves of all other players.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Kabaleo Lite", "background": "", "description": "\n\nKabaleo Lite is a board game. The board consists of several stacks of conical chips of various colors. Only the color of the top chip of the stack is visible.\n\nEach player has a unique target color and a set of colored chips. The target color is hidden from other players, while the set of chips is visible to them. On his turn, player selects one of his chips and puts it on one of the board stacks, thus recoloring it to the color of the chosen chip.\n\nAfter the last turn, the number of visible board chips of each color is calculated. The winning color is the color that occurs the maximum times. The player (if any) that has this color as his target color, wins the game. If there is no such player or if there are two or more colors that occur the maximum times, the game ends in a draw.\n\nYou are playing your last chip in the Kabaleo Lite game. Other players also have one chip left. You want to determine all possible moves that lead you to winning the game. You do not know the target colors of other players and you cannot predict their moves, so your move must guarantee your victory regardless of moves of your opponents.\n\n", "inputFormat": "\n\nThe first line contains four integers $n , p , c$ and $h$ -- the number of stacks on the board $(1 \\le n \\le 10^{6}),$ the number of players $(1 \\le p \\le 10^{6}),$ the number of chips' colors $(p \\le c \\le 10^{6}),$ and your hidden color $(1 \\le h \\le c)$ .\n\nThe second line contains $n$ integers $b_{i}$ -- the color of the visible board chip for each stack on the board $(1 \\le b_{i} \\le c)$ .\n\nThe third line contains $p$ integers $l_{i}$ -- the color of the last chip for each player $(1 \\le l_{i} \\le c)$ . The players are numbered from one (you) to $n$ in the order of their turns.\n\n", "outputFormat": "\n\nThe first line must contain $w$ -- the number of winning moves.\n\nThe second line must contain $w$ distinct numbers $m_{i}$ -- the numbers of the stacks on which your chip should be put to win. Stacks are numbered starting from $1$ in the order that their visible colors are given in the input file. You can output their numbers in any order on this line.\n\nRemember, that your move should be winning regardless of the moves of all other players.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Kabaleo Lite", "background": null, "description": "有一种棋盘游戏：棋盘上有 $n$ 个格子，每个格子上可以堆叠若干个有颜色的筹码，只有每个格子中最上方的筹码的颜色是可见的。\n\n参加游戏的每个玩家都有各自不同的一个目标颜色，以及一些彩色筹码。每个人只知道自己的目标颜色，但各自拥有的筹码颜色和数量都是公开的。每个回合中，所有玩家轮流在棋盘上选一个格子放置筹码，同时覆盖下方的筹码。游戏结束后，数出棋盘上可见筹码数最多的颜色，以该颜色为目标颜色的玩家即获胜。若该颜色不是任何玩家的目标颜色，或者棋盘上出现最多的颜色不唯一，则游戏平局。\n\n现在，一局游戏进行到了最后，你和其他所有玩家都只剩最后一个筹码。现在恰好轮到你操作，在不知道其他人的目标颜色的前提下，你想知道你一共有哪些操作可以保证必胜。", "inputFormat": "第一行 $4$ 个整数 $n,p,c,h$，分别表示棋盘格数、玩家数、筹码颜色总数和你的目标颜色；\n\n第二行 $n$ 个整数 $b_i$，表示棋盘上现有的筹码颜色，棋盘格编号从 $1$ 开始；\n\n第三行 $p$ 个整数 $l_i$，表示每个玩家的最后一枚筹码的颜色，玩家编号从你开始。", "outputFormat": "第一行 $1$ 个整数 $w$，表示你有多少种必胜操作。\n\n第二行 $w$ 个整数 $m_i$，表示你应该把筹码放在哪个格子上。顺序不限。", "hint": "$1\\leq n\\leq 10^6$，$1\\leq p\\leq c\\leq  10^6$，$1\\leq h,b_i,l_i\\leq c$。", "locale": "zh-CN"}}}
{"pid": "P7007", "type": "P", "difficulty": 6, "samples": [["4\n\n3 3\n1 2 3\n4 5 6\n9 8 7\n\n4 2\n1 2 3 4\n5 6 7 8\n\n4 4\n1 2 15 4\n8 7 11 5\n12 6 10 9\n13 14 3 16\n\n3 4\n1 2 4\n3 5 6\n7 8 9\n10 11 12\n", "POSSIBLE 1 R3\nPOSSIBLE 0\nPOSSIBLE 3 R3 C3 R2\nIMPOSSIBLE\n"]], "limits": {"time": [3000, 3000, 3000], "memory": [131072, 131072, 131072]}, "tags": ["2013", "Special Judge", "ICPC", "CERC"], "title": "[CERC2013] Rubik's Rectangle", "background": "", "description": "A new puzzle which aims to conquer the game market is a fusion of Rubik's Cube and Fifteen. The board is an $H \\times W$ frame with tiles with all numbers from $1$ to $H · W$ printed on them.\n\n![](/upload/images2/rubik1.png)\n\nThe only type of move that is allowed is flipping either one of the rows or one of the columns. Flipping reverses the order of the row's (or column's) elements. Below the third row is flipped:\n\n![](/upload/images2/rubik2.png)\n\nYou are given a board with tiles numbered in some arbitrary order. Determine a sequence of flips that brings the board to the nicely sorted position, if possible.\n\n![](/upload/images2/rubik3.png)\n\n", "inputFormat": "The first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe description of each test case starts with an empty line. The next line contains two space-separated integers $W$ and $H (1 \\leq W,H \\leq 100) -$ the width and height of the puzzle, respectively. Each of the next $H$ lines contains $W$ space-separated integers $-$ the numbers printed on consecutive tiles.\n\n", "outputFormat": "Print the answers to the test cases in the order in which they appear in the input. Start the output for each test case with the word POSSIBLE or IMPOSSIBLE, depending on whether it is possible to solve the puzzle. If a solution exists, print (in the same line) first the number of moves (possibly $0$) and then their descriptions, each consisting of a single letter $R$ or $C$ specifying whether we are to flip a row or a column, concatenated with the index of the row or column to flip.\n\nAny solution will be accepted as long as it does not use more than $10 · W · H$ moves. Each test case is either solvable within this limit, or not solvable at all.\n\n", "hint": "Time limit: 6 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[CERC2013] Rubik's Rectangle", "background": "", "description": "A new puzzle which aims to conquer the game market is a fusion of Rubik's Cube and Fifteen. The board is an $H \\times W$ frame with tiles with all numbers from $1$ to $H · W$ printed on them.\n\n![](/upload/images2/rubik1.png)\n\nThe only type of move that is allowed is flipping either one of the rows or one of the columns. Flipping reverses the order of the row's (or column's) elements. Below the third row is flipped:\n\n![](/upload/images2/rubik2.png)\n\nYou are given a board with tiles numbered in some arbitrary order. Determine a sequence of flips that brings the board to the nicely sorted position, if possible.\n\n![](/upload/images2/rubik3.png)\n\n", "inputFormat": "The first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe description of each test case starts with an empty line. The next line contains two space-separated integers $W$ and $H (1 \\leq W,H \\leq 100) -$ the width and height of the puzzle, respectively. Each of the next $H$ lines contains $W$ space-separated integers $-$ the numbers printed on consecutive tiles.\n\n", "outputFormat": "Print the answers to the test cases in the order in which they appear in the input. Start the output for each test case with the word POSSIBLE or IMPOSSIBLE, depending on whether it is possible to solve the puzzle. If a solution exists, print (in the same line) first the number of moves (possibly $0$) and then their descriptions, each consisting of a single letter $R$ or $C$ specifying whether we are to flip a row or a column, concatenated with the index of the row or column to flip.\n\nAny solution will be accepted as long as it does not use more than $10 · W · H$ moves. Each test case is either solvable within this limit, or not solvable at all.\n\n", "hint": "Time limit: 6 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Rubik's Rectangle", "background": "", "description": "一种旨在征服游戏市场的新型益智游戏是魔方与十五数码的融合。棋盘是一个 $H \\times W$ 的框架，上面印有从 $1$ 到 $H \\cdot W$ 的所有数字。\n\n![](/upload/images2/rubik1.png)\n\n唯一允许的移动类型是翻转其中一行或一列。翻转会逆转该行（或列）元素的顺序。下面第三行被翻转：\n\n![](/upload/images2/rubik2.png)\n\n给定一个以某种任意顺序编号的棋盘。确定一系列翻转操作，使棋盘达到整齐排序的位置，如果可能的话。\n\n![](/upload/images2/rubik3.png)", "inputFormat": "输入的第一行包含测试用例的数量 $T$。测试用例的描述如下：\n\n每个测试用例的描述以一个空行开始。下一行包含两个用空格分隔的整数 $W$ 和 $H (1 \\leq W,H \\leq 100)$，分别表示拼图的宽度和高度。接下来的 $H$ 行中的每一行包含 $W$ 个用空格分隔的整数，表示连续瓷砖上印刷的数字。", "outputFormat": "按输入中出现的顺序打印测试用例的答案。对于每个测试用例的输出以单词 POSSIBLE 或 IMPOSSIBLE 开始，具体取决于是否有可能解决拼图。如果存在解决方案，请在同一行打印首先是移动的次数（可能为 $0$），然后是它们的描述，每个描述由一个字母 $R$ 或 $C$ 组成，指定我们是要翻转行还是列，并与要翻转的行或列的索引连接。\n\n只要解决方案不使用超过 $10 \\cdot W \\cdot H$ 次移动，任何解决方案都将被接受。每个测试用例要么在此限制内可解，要么根本不可解。", "hint": "时间限制：6 秒，内存限制：128 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7008", "type": "P", "difficulty": 2, "samples": [["1\ntoot woof wa ow ow ow pa blub blub pa toot pa blub pa pa ow pow toot\ndog goes woof\nfish goes blub\nelephant goes toot\nseal goes ow\nwhat does the fox say?\n", "wa pa pa pa pa pa pow\n"]], "limits": {"time": [1000], "memory": [1048576]}, "tags": ["模拟", "2013", "ICPC", "CERC"], "title": "[CERC2013] What does the fox say?", "background": "", "description": "Determined to discover the ancient mystery—the sound that the fox makes—you went into the forest, armed with a very good digital audio recorder. The forest is, however, full of animals’ voices, and on your recording, many different sounds can be heard. But you are well prepared for your task: you know exactly all the sounds which other animals make. Therefore the rest of the recording—all the unidentified noises—must have been made by the fox.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe first line of each test case contains the recording—words over lower case English alphabet, separated by spaces. Each contains at most 100 letters and there are no more than 100 words. The next few lines are your pre-gathered information about other animals, in the format <animal> goes <sound>. There are no more than 100 animals, their names are not longer than 100 letters each and are actual names of animals in English. There is no fox goes ... among these lines.\n\nThe last line of the test case is exactly the question you are supposed to answer: what does the fox say?", "outputFormat": "For each test case, output one line containing the sounds made by the fox, in the order from the recording. You may assume that the fox was not silent (contrary to popular belief, foxes do not communicate by Morse code).", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n Central Europe Regional Contest (CERC) 2013", "locale": "en", "translations": {"en": {"title": "[CERC2013] What does the fox say?", "background": "", "description": "Determined to discover the ancient mystery—the sound that the fox makes—you went into the forest, armed with a very good digital audio recorder. The forest is, however, full of animals’ voices, and on your recording, many different sounds can be heard. But you are well prepared for your task: you know exactly all the sounds which other animals make. Therefore the rest of the recording—all the unidentified noises—must have been made by the fox.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe first line of each test case contains the recording—words over lower case English alphabet, separated by spaces. Each contains at most 100 letters and there are no more than 100 words. The next few lines are your pre-gathered information about other animals, in the format <animal> goes <sound>. There are no more than 100 animals, their names are not longer than 100 letters each and are actual names of animals in English. There is no fox goes ... among these lines.\n\nThe last line of the test case is exactly the question you are supposed to answer: what does the fox say?", "outputFormat": "For each test case, output one line containing the sounds made by the fox, in the order from the recording. You may assume that the fox was not silent (contrary to popular belief, foxes do not communicate by Morse code).", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n Central Europe Regional Contest (CERC) 2013", "locale": "en"}, "zh-CN": {"title": "[CERC2013] What does the fox say?", "background": "", "description": "### 题目大意\n\n森林里面有很多声响，你想知道有哪些声响是由狐狸发出来的。\n\n已知你搜集到了 $n$ 个声响，并且还知道某些其他动物能够发出的声响，已知如果没有哪一个声响是由其他任何一种动物发出来的话，那这个声响绝对是由狐狸发出来的。现在，给定你这 $n$ 个声响，以及某些其他动物能够发出的声响，请你求出狐狸发出的声响。", "inputFormat": "**本题有多组询问。**\n\n第一行包含一个整数 $T$，表示数据的组数。  \n接下来若干组数据，每组数据由三部分组成：\n\n- 第一行 $n$ 个仅由小写字母组成的字符串，代表搜集到的 $n$ 个声响。\n- 接下来有若干行，代表某些其他动物能够发出的声响。格式为 ``<animal> goes <sound>``，其中 `<animal>` 代表动物的名称（仅由一个字符串组成），`<sound>` 代表这个动物发出的声响（仅由一个字符串组成）。保证不会在这些动物中出现狐狸。\n- 最后一行，一个确定的字符串 ``what does the fox say?``。", "outputFormat": "对于每组数据，输出仅一行，代表狐狸能够发出的声响。", "hint": "$n\\leqslant 100$。  \n保证每个字符串的长度不超过 $100$。\n\nTranslated by Eason_AC  \n2020.10.30", "locale": "zh-CN"}}}
{"pid": "P7009", "type": "P", "difficulty": 5, "samples": [["1\n5\n30 60 20 20 20\n", "80\n"]], "limits": {"time": [8000], "memory": [1048576]}, "tags": ["2013", "ICPC", "CERC"], "title": "[CERC2013] Magical GCD", "background": "", "description": "The Magical GCD of a nonempty sequence of positive integers is defined as the product of its length and the greatest common divisor of all its elements.\n\nGiven a sequence $(a_1, \\ldots , a_ n)$, find the largest possible Magical GCD of its connected subsequences.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe description of each test case starts with a line containing a single integer $n$, $1 \\leq n \\leq 100\\, 000$. The next line contains the sequence $a_1, a_2 , \\ldots , a _ n$, $1 \\leq a_ i \\leq 10^{12}$.", "outputFormat": "For each test case output one line containing a single integer: the largest Magical GCD of a connected subsequence of the input sequence.", "hint": "Time limit: 8000 ms, Memory limit: 1048576 kB. \n\n Central Europe Regional Contest (CERC) 2013", "locale": "en", "translations": {"en": {"title": "[CERC2013] Magical GCD", "background": "", "description": "The Magical GCD of a nonempty sequence of positive integers is defined as the product of its length and the greatest common divisor of all its elements.\n\nGiven a sequence $(a_1, \\ldots , a_ n)$, find the largest possible Magical GCD of its connected subsequences.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe description of each test case starts with a line containing a single integer $n$, $1 \\leq n \\leq 100\\, 000$. The next line contains the sequence $a_1, a_2 , \\ldots , a _ n$, $1 \\leq a_ i \\leq 10^{12}$.", "outputFormat": "For each test case output one line containing a single integer: the largest Magical GCD of a connected subsequence of the input sequence.", "hint": "Time limit: 8000 ms, Memory limit: 1048576 kB. \n\n Central Europe Regional Contest (CERC) 2013", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Magical GCD", "background": "", "description": "一个非空正整数序列的“神奇 GCD”定义为其长度与所有元素的最大公约数的乘积。\n\n给定一个序列 $(a_1, \\ldots , a_n)$，找出其所有连续子序列中可能的最大“神奇 GCD”。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。每个测试用例的描述如下：\n\n每个测试用例的描述以一行开始，包含一个整数 $n$，$1 \\leq n \\leq 100\\,000$。下一行包含序列 $a_1, a_2 , \\ldots , a_n$，$1 \\leq a_i \\leq 10^{12}$。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数：输入序列的一个连续子序列的最大“神奇 GCD”。", "hint": "时间限制：8000 毫秒，内存限制：1048576 kB。\n\nCentral Europe Regional Contest (CERC) 2013。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
