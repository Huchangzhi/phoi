{"pid": "P13215", "type": "P", "difficulty": 2, "samples": [["4\n4\n10 5 15 5\n2\n100 100\n8\n81 81 81 81 81 81 81 0\n6\n23 90 40 0 100 9", "Case #1: 15 25\nCase #2: 0 0\nCase #3: 81 567\nCase #4: 181 244"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["模拟", "贪心", "2015", "Google Code Jam"], "title": "[GCJ 2015 #1A] Mushroom Monster", "background": "", "description": "Kaylin loves mushrooms. Put them on her plate and she'll eat them up! In this problem she's eating a plate of mushrooms, and Bartholomew is putting more pieces on her plate.\n\nIn this problem, we'll look at how many pieces of mushroom are on her plate at $10$-second intervals. Bartholomew could put any non-negative integer number of mushroom pieces down at any time, and the only way they can leave the plate is by being eaten.\n\nFigure out the minimum number of mushrooms that Kaylin could have eaten using two different methods of computation:\n\n1. Assume Kaylin could eat any number of mushroom pieces at any time.\n2. Assume that, starting with the first time we look at the plate, Kaylin eats mushrooms at a constant rate whenever there are mushrooms on her plate.\n\nFor example, if the input is $10$ $5$ $15$ $5$:\n\nWith the first method, Kaylin must have eaten at least $15$ mushroom pieces: first she eats $5$, then $10$ more are put on her plate, then she eats another $10$. There's no way she could have eaten fewer pieces.\n\nWith the second method, Kaylin must have eaten at least $25$ mushroom pieces. We can determine that she must eat mushrooms at a rate of at least $1$ piece per second. She starts with $10$ pieces on her plate. In the first $10$ seconds, she eats $10$ pieces, and $5$ more are put on her plate. In the next $5$ seconds, she eats $5$ pieces, then her plate stays empty for $5$ seconds, and then Bartholomew puts $15$ more pieces on her plate. Then she eats $10$ pieces in the last $10$ seconds.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each will consist of one line containing a single integer $N$, followed by a line containing $N$ space-separated integers $m_i$; the number of mushrooms on Kaylin's plate at the start, and at $10$-second intervals.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$ $z$\", where $x$ is the test case number (starting from $1$), $y$ is the minimum number of mushrooms Kaylin could have eaten using the first method of computation, and $z$ is the minimum number of mushrooms Kaylin could have eaten using the second method of computation.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Small dataset(7 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $2 \\leq N \\leq 10$.\n- $0 \\leq m_i \\leq 100$.\n\n**Large dataset(8 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $2 \\leq N \\leq 1000$.\n- $0 \\leq m_i \\leq 10000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #1A] Mushroom Monster", "background": "", "description": "Kaylin loves mushrooms. Put them on her plate and she'll eat them up! In this problem she's eating a plate of mushrooms, and Bartholomew is putting more pieces on her plate.\n\nIn this problem, we'll look at how many pieces of mushroom are on her plate at $10$-second intervals. Bartholomew could put any non-negative integer number of mushroom pieces down at any time, and the only way they can leave the plate is by being eaten.\n\nFigure out the minimum number of mushrooms that Kaylin could have eaten using two different methods of computation:\n\n1. Assume Kaylin could eat any number of mushroom pieces at any time.\n2. Assume that, starting with the first time we look at the plate, Kaylin eats mushrooms at a constant rate whenever there are mushrooms on her plate.\n\nFor example, if the input is $10$ $5$ $15$ $5$:\n\nWith the first method, Kaylin must have eaten at least $15$ mushroom pieces: first she eats $5$, then $10$ more are put on her plate, then she eats another $10$. There's no way she could have eaten fewer pieces.\n\nWith the second method, Kaylin must have eaten at least $25$ mushroom pieces. We can determine that she must eat mushrooms at a rate of at least $1$ piece per second. She starts with $10$ pieces on her plate. In the first $10$ seconds, she eats $10$ pieces, and $5$ more are put on her plate. In the next $5$ seconds, she eats $5$ pieces, then her plate stays empty for $5$ seconds, and then Bartholomew puts $15$ more pieces on her plate. Then she eats $10$ pieces in the last $10$ seconds.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each will consist of one line containing a single integer $N$, followed by a line containing $N$ space-separated integers $m_i$; the number of mushrooms on Kaylin's plate at the start, and at $10$-second intervals.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$ $z$\", where $x$ is the test case number (starting from $1$), $y$ is the minimum number of mushrooms Kaylin could have eaten using the first method of computation, and $z$ is the minimum number of mushrooms Kaylin could have eaten using the second method of computation.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Small dataset(7 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $2 \\leq N \\leq 10$.\n- $0 \\leq m_i \\leq 100$.\n\n**Large dataset(8 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $2 \\leq N \\leq 1000$.\n- $0 \\leq m_i \\leq 10000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #1A] Mushroom Monster", "background": null, "description": "Kaylin 喜欢蘑菇。只要把蘑菇放到她的盘子里，她就会把它们吃掉！在本题中，她正在吃一盘蘑菇，而 Bartholomew 会不断往她的盘子里加蘑菇。\n\n我们每隔 $10$ 秒观察一次她盘子里的蘑菇数量。Bartholomew 可以在任何时刻往盘子里加任意个（非负整数）蘑菇，蘑菇离开盘子的唯一方式就是被 Kaylin 吃掉。\n\n请你用两种不同的方法计算出 Kaylin 至少吃了多少个蘑菇：\n\n1. 假设 Kaylin 可以在任何时刻吃掉任意数量的蘑菇。\n2. 假设从第一次观察开始，只要盘子里有蘑菇，Kaylin 就以一个恒定的速度吃蘑菇。\n\n例如，若输入为 $10$ $5$ $15$ $5$：\n\n用第一种方法，Kaylin 至少吃了 $15$ 个蘑菇：她先吃掉 $5$ 个，然后 Bartholomew 又加了 $10$ 个蘑菇，然后她又吃掉了 $10$ 个。无论如何，她都不可能吃得更少。\n\n用第二种方法，Kaylin 至少吃了 $25$ 个蘑菇。我们可以确定她吃蘑菇的速度至少为每秒 $1$ 个。她一开始盘子里有 $10$ 个蘑菇。在前 $10$ 秒内，她吃掉 $10$ 个蘑菇，Bartholomew 又加了 $5$ 个蘑菇。接下来的 $5$ 秒，她吃掉 $5$ 个蘑菇，然后盘子在 $5$ 秒内保持空，接着 Bartholomew 又加了 $15$ 个蘑菇。最后 $10$ 秒，她又吃掉了 $10$ 个蘑菇。", "inputFormat": "第一行输入一个整数 $T$，表示测试用例的数量。接下来有 $T$ 组测试数据。每组测试数据包含两行，第一行为一个整数 $N$，第二行为 $N$ 个用空格分隔的整数 $m_i$，表示 Kaylin 盘子里在每个 $10$ 秒时刻的蘑菇数量（包括初始时刻）。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #$x$: $y$ $z$\"，其中 $x$ 表示测试用例编号（从 $1$ 开始），$y$ 表示用第一种方法计算的 Kaylin 至少吃掉的蘑菇数量，$z$ 表示用第二种方法计算的 Kaylin 至少吃掉的蘑菇数量。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 100$。\n\n**小数据集（7 分）**\n\n- 时间限制：5 秒。\n- $2 \\leq N \\leq 10$。\n- $0 \\leq m_i \\leq 100$。\n\n**大数据集（8 分）**\n\n- 时间限制：10 秒。\n- $2 \\leq N \\leq 1000$。\n- $0 \\leq m_i \\leq 10000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13216", "type": "P", "difficulty": 3, "samples": [["3\n2 4\n10 5\n3 12\n7 7 7\n3 8\n4 2 1", "Case #1: 1\nCase #2: 3\nCase #3: 1"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["2015", "二分", "Google Code Jam"], "title": "[GCJ 2015 #1A] Haircut", "background": "", "description": "You are waiting in a long line to get a haircut at a trendy barber shop. The shop has $B$ barbers on duty, and they are numbered $1$ through $B$. It always takes the $k$th barber exactly $M_k$ minutes to cut a customer's hair, and a barber can only cut one customer's hair at a time. Once a barber finishes cutting hair, he is immediately free to help another customer.\n\nWhile the shop is open, the customer at the head of the queue always goes to the lowest-numbered barber who is available. When no barber is available, that customer waits until at least one becomes available.\n\nYou are the $N$-th person in line, and the shop has just opened. Which barber will cut your hair?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of two lines. The first contains two space-separated integers $B$ and $N$ -- the number of barbers and your place in line. The customer at the head of the line is number $1$, the next one is number $2$, and so on. The second line contains $M_1$, $M_2$, $\\dots $, $M_B$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is the number of the barber who will cut your hair.", "hint": "**Sample Explanation**\n\nIn Case #1, you are the fourth person in line, and barbers $1$ and $2$ take $10$ and $5$ minutes, respectively, to cut hair. When the shop opens, the first customer immediately has the choice of barbers $1$ and $2$, and she will choose the lowest-numbered barber, $1$. The second customer will immediately be served by barber $2$. The third customer will wait since there are no more free barbers. After $5$ minutes, barber $2$ will finish cutting the second customer's hair, and will serve the third customer. After $10$ minutes, both barbers $1$ and $2$ will finish; you are next in line, and you will have the choice of barbers $1$ and $2$, and will choose $1$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 10^9$.\n\n**Small dataset(11 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq B \\leq 5$.\n- $1 \\leq M_k \\leq 25$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq B \\leq 1000$.\n- $1 \\leq M_k \\leq 100000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #1A] Haircut", "background": "", "description": "You are waiting in a long line to get a haircut at a trendy barber shop. The shop has $B$ barbers on duty, and they are numbered $1$ through $B$. It always takes the $k$th barber exactly $M_k$ minutes to cut a customer's hair, and a barber can only cut one customer's hair at a time. Once a barber finishes cutting hair, he is immediately free to help another customer.\n\nWhile the shop is open, the customer at the head of the queue always goes to the lowest-numbered barber who is available. When no barber is available, that customer waits until at least one becomes available.\n\nYou are the $N$-th person in line, and the shop has just opened. Which barber will cut your hair?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of two lines. The first contains two space-separated integers $B$ and $N$ -- the number of barbers and your place in line. The customer at the head of the line is number $1$, the next one is number $2$, and so on. The second line contains $M_1$, $M_2$, $\\dots $, $M_B$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is the number of the barber who will cut your hair.", "hint": "**Sample Explanation**\n\nIn Case #1, you are the fourth person in line, and barbers $1$ and $2$ take $10$ and $5$ minutes, respectively, to cut hair. When the shop opens, the first customer immediately has the choice of barbers $1$ and $2$, and she will choose the lowest-numbered barber, $1$. The second customer will immediately be served by barber $2$. The third customer will wait since there are no more free barbers. After $5$ minutes, barber $2$ will finish cutting the second customer's hair, and will serve the third customer. After $10$ minutes, both barbers $1$ and $2$ will finish; you are next in line, and you will have the choice of barbers $1$ and $2$, and will choose $1$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 10^9$.\n\n**Small dataset(11 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq B \\leq 5$.\n- $1 \\leq M_k \\leq 25$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq B \\leq 1000$.\n- $1 \\leq M_k \\leq 100000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #1A] Haircut", "background": null, "description": "你正在一家时尚理发店排长队等着理发。店里有 $B$ 位理发师，编号为 $1$ 到 $B$。第 $k$ 位理发师理一个顾客的头发恰好需要 $M_k$ 分钟，并且每位理发师一次只能为一位顾客服务。当理发师完成理发后，会立即空闲，可以为下一位顾客服务。\n\n在理发店营业期间，队首的顾客总是会选择编号最小的空闲理发师。如果没有理发师空闲，该顾客会等待，直到至少有一位理发师空闲。\n\n你是队伍中的第 $N$ 位顾客，理发店刚刚开门。请问哪位理发师会为你理发？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试用例，每组包含两行。第一行包含两个用空格分隔的整数 $B$ 和 $N$，分别表示理发师数量和你在队伍中的位置。队首顾客编号为 $1$，下一个为 $2$，以此类推。第二行包含 $M_1, M_2, \\dots, M_B$，分别表示每位理发师理发所需的时间。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是为你理发的理发师编号。", "hint": "**样例解释**\n\n在第 1 组样例中，你是队伍中的第 4 位顾客，理发师 $1$ 和 $2$ 理发分别需要 $10$ 分钟和 $5$ 分钟。当理发店开门时，第一位顾客可以选择理发师 $1$ 或 $2$，她会选择编号最小的理发师 $1$。第二位顾客会立即由理发师 $2$ 服务。第三位顾客需要等待，因为没有空闲理发师。5 分钟后，理发师 $2$ 完成第二位顾客的理发，并为第三位顾客服务。10 分钟后，理发师 $1$ 和 $2$ 都完成了理发，你是下一个顾客，可以选择理发师 $1$ 或 $2$，你会选择 $1$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq N \\leq 10^9$。\n\n**小数据集（11 分）**\n\n- 时间限制：5 秒。\n- $1 \\leq B \\leq 5$。\n- $1 \\leq M_k \\leq 25$。\n\n**大数据集**\n\n- 时间限制：10 秒。\n- $1 \\leq B \\leq 1000$。\n- $1 \\leq M_k \\leq 100000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13217", "type": "P", "difficulty": 5, "samples": [["2\n5\n0 0\n10 0\n10 10\n0 10\n5 5\n9\n0 0\n5 0\n10 0\n0 5\n5 5\n10 5\n0 10\n5 10\n10 10", "Case #1:\n0\n0\n0\n0\n1\nCase #2:\n0\n0\n0\n0\n3\n0\n0\n0\n0"]], "limits": {"time": [5000, 20000], "memory": [1048576, 1048576]}, "tags": ["计算几何", "2015", "凸包", "极角排序", "Google Code Jam"], "title": "[GCJ 2015 #1A] Logging", "background": "", "description": "A certain forest consists of $N$ trees, each of which is inhabited by a squirrel.\n\nThe **boundary** of the forest is the convex polygon of smallest area which contains every tree, as if a giant rubber band had been stretched around the outside of the forest.\n\nFormally, every tree is a single point in two-dimensional space with unique coordinates $(X_i, Y_i)$, and the boundary is the convex hull of those points.\n\nSome trees are **on the boundary** of the forest, which means they are on an edge or a corner of the polygon. The squirrels wonder how close their trees are to being on the boundary of the forest.\n\nOne at a time, each squirrel climbs down from its tree, examines the forest, and determines the minimum number of trees that would need to be cut down for its own tree to be on the boundary. It then writes that number down on a log.\n\nDetermine the list of numbers written on the log.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of a single line with an integer $N$, the number of trees, followed by $N$ lines with two space-separated integers $X_i$ and $Y_i$, the coordinates of each tree. No two trees will have the same coordinates.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$:\", followed by $N$ lines with one integer each, where line $i$ contains the number of trees that the squirrel living in tree $i$ would need to cut down.", "hint": "**Sample Explanation**\n\nIn the first sample case, there are four trees forming a square, and a fifth tree inside the square. Since the first four trees are already on the boundary, the squirrels for those trees each write down $0$. Since one tree needs to be cut down for the fifth tree to be on the boundary, the fifth squirrel writes down $1$.\n\n**Limits**\n\n- $-10^6 \\leq X_i, Y_i \\leq 10^6$.\n\n**Small dataset**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 15$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 20 seconds.\n- $1 \\leq T \\leq 14$.\n- $1 \\leq N \\leq 3000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #1A] Logging", "background": "", "description": "A certain forest consists of $N$ trees, each of which is inhabited by a squirrel.\n\nThe **boundary** of the forest is the convex polygon of smallest area which contains every tree, as if a giant rubber band had been stretched around the outside of the forest.\n\nFormally, every tree is a single point in two-dimensional space with unique coordinates $(X_i, Y_i)$, and the boundary is the convex hull of those points.\n\nSome trees are **on the boundary** of the forest, which means they are on an edge or a corner of the polygon. The squirrels wonder how close their trees are to being on the boundary of the forest.\n\nOne at a time, each squirrel climbs down from its tree, examines the forest, and determines the minimum number of trees that would need to be cut down for its own tree to be on the boundary. It then writes that number down on a log.\n\nDetermine the list of numbers written on the log.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of a single line with an integer $N$, the number of trees, followed by $N$ lines with two space-separated integers $X_i$ and $Y_i$, the coordinates of each tree. No two trees will have the same coordinates.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$:\", followed by $N$ lines with one integer each, where line $i$ contains the number of trees that the squirrel living in tree $i$ would need to cut down.", "hint": "**Sample Explanation**\n\nIn the first sample case, there are four trees forming a square, and a fifth tree inside the square. Since the first four trees are already on the boundary, the squirrels for those trees each write down $0$. Since one tree needs to be cut down for the fifth tree to be on the boundary, the fifth squirrel writes down $1$.\n\n**Limits**\n\n- $-10^6 \\leq X_i, Y_i \\leq 10^6$.\n\n**Small dataset**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 15$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 20 seconds.\n- $1 \\leq T \\leq 14$.\n- $1 \\leq N \\leq 3000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #1A] Logging", "background": null, "description": "某片森林中有 $N$ 棵树，每棵树上都住着一只松鼠。\n\n森林的**边界**是指包含所有树的最小面积凸多边形，就像用一根巨大的橡皮筋把整个森林包裹起来一样。\n\n形式化地说，每棵树在二维平面上是一个唯一坐标为 $(X_i, Y_i)$ 的点，边界就是这些点的凸包。\n\n有些树**在森林的边界上**，也就是说它们位于凸多边形的边或顶点上。松鼠们想知道它们的树距离成为森林边界上的树还有多远。\n\n每次，一只松鼠会从它的树上下来，观察整个森林，并确定至少需要砍掉多少棵树，才能让它自己的树处于森林的边界上。然后它会把这个数字记在一根木头上。\n\n请你求出所有松鼠记下的数字列表。", "inputFormat": "输入的第一行是测试用例的数量 $T$。接下来有 $T$ 组测试数据；每组测试数据第一行为一个整数 $N$，表示树的数量，接下来的 $N$ 行，每行包含两个用空格分隔的整数 $X_i$ 和 $Y_i$，表示每棵树的坐标。任意两棵树的坐标都不相同。", "outputFormat": "对于每组测试数据，输出一行 \"Case #$x$:\"，接下来输出 $N$ 行，每行一个整数，第 $i$ 行表示住在第 $i$ 棵树上的松鼠需要砍掉多少棵树，才能让它的树处于边界上。", "hint": "**样例解释**\n\n在第一个样例中，有四棵树形成一个正方形，第五棵树在正方形内部。前四棵树已经在边界上，所以这些松鼠都写下 $0$。第五棵树需要砍掉一棵树才能在边界上，所以第五只松鼠写下 $1$。\n\n**数据范围**\n\n- $-10^6 \\leq X_i, Y_i \\leq 10^6$。\n\n**小数据范围**\n\n- 时间限制：5 秒。\n- $1 \\leq T \\leq 100$。\n- $1 \\leq N \\leq 15$。\n\n**大数据范围**\n\n- 时间限制：20 秒。\n- $1 \\leq T \\leq 14$。\n- $1 \\leq N \\leq 3000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13218", "type": "P", "difficulty": 4, "samples": [["3\n1\n19\n23", "Case #1: 1\nCase #2: 19\nCase #3: 15"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2015", "Google Code Jam"], "title": "[GCJ 2015 #1B] Counter Culture", "background": "", "description": "In the Counting Poetry Slam, a performer takes the microphone, chooses a number $N$, and counts aloud from $1$ to $N$. That is, she starts by saying $1$, and then repeatedly says the number that is $1$ greater than the previous number she said, stopping after she has said $N$.\n\nIt's your turn to perform, but you find this process tedious, and you want to add a twist to speed it up: sometimes, instead of adding $1$ to the previous number, you might reverse the digits of the number (removing any leading zeroes that this creates). For example, after saying \"16\", you could next say either \"17\" or \"61\"; after saying \"2300\", you could next say either \"2301\" or \"32\". You may reverse as many times as you want (or not at all) within a performance.\n\nThe first number you say must be $1$; what is the fewest number of numbers you will need to say in order to reach the number $N$? $1$ and $N$ count toward this total. If you say the same number multiple times, each of those times counts separately.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each has one integer $N$, the number you must reach.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is the minimum number of numbers you need to say.", "hint": "**Sample Explanation**\n\nIn Case #2, flipping does not help and the optimal strategy is to just count up to $19$.\n\nIn Case #3, the optimal strategy is to count up to $12$, flip to $21$, and then continue counting up to $23$. That is, the numbers you will say are $1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 21, 22, 23$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Small dataset**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq N \\leq 10^6$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq N \\leq 10^{14}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #1B] Counter Culture", "background": "", "description": "In the Counting Poetry Slam, a performer takes the microphone, chooses a number $N$, and counts aloud from $1$ to $N$. That is, she starts by saying $1$, and then repeatedly says the number that is $1$ greater than the previous number she said, stopping after she has said $N$.\n\nIt's your turn to perform, but you find this process tedious, and you want to add a twist to speed it up: sometimes, instead of adding $1$ to the previous number, you might reverse the digits of the number (removing any leading zeroes that this creates). For example, after saying \"16\", you could next say either \"17\" or \"61\"; after saying \"2300\", you could next say either \"2301\" or \"32\". You may reverse as many times as you want (or not at all) within a performance.\n\nThe first number you say must be $1$; what is the fewest number of numbers you will need to say in order to reach the number $N$? $1$ and $N$ count toward this total. If you say the same number multiple times, each of those times counts separately.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each has one integer $N$, the number you must reach.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is the minimum number of numbers you need to say.", "hint": "**Sample Explanation**\n\nIn Case #2, flipping does not help and the optimal strategy is to just count up to $19$.\n\nIn Case #3, the optimal strategy is to count up to $12$, flip to $21$, and then continue counting up to $23$. That is, the numbers you will say are $1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 21, 22, 23$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Small dataset**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq N \\leq 10^6$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq N \\leq 10^{14}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #1B] Counter Culture", "background": null, "description": "在 Counting Poetry Slam 中，表演者拿起麦克风，选择一个数字 $N$，然后从 $1$ 开始大声数数直到 $N$。也就是说，她先说出 $1$，然后每次说出比上一个数字大 $1$ 的数字，直到说到 $N$ 为止。\n\n现在轮到你表演了，但你觉得这个过程太无聊，想加点花样来加快进度：有时候，你可以选择不加 $1$，而是将当前数字的各位数字反转（去除反转后产生的前导零）。例如，在说完“16”后，你可以接着说“17”或者“61”；在说完“2300”后，你可以接着说“2301”或者“32”。你可以在表演过程中任意多次进行反转操作（也可以一次都不反转）。\n\n你说的第一个数字必须是 $1$；请问，最少需要说多少个数字才能到达 $N$？$1$ 和 $N$ 都要计入总数。如果你多次说同一个数字，每次都要计数。", "inputFormat": "第一行输入一个整数 $T$，表示测试用例的数量。接下来的 $T$ 行，每行一个整数 $N$，表示你需要到达的数字。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是到达 $N$ 所需说出的最少数字个数。", "hint": "**样例解释**\n\n在第 2 个用例中，反转操作没有帮助，最优策略是直接数到 $19$。\n\n在第 3 个用例中，最优策略是先数到 $12$，反转到 $21$，然后继续数到 $23$。你说出的数字依次为 $1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 21, 22, 23$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n\n**小数据范围**\n\n- 时间限制：5 秒。\n- $1 \\leq N \\leq 10^6$。\n\n**大数据范围**\n\n- 时间限制：10 秒。\n- $1 \\leq N \\leq 10^{14}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13219", "type": "P", "difficulty": 4, "samples": [["4\n2 3 6\n4 1 2\n3 3 8\n5 2 0", "Case #1: 7\nCase #2: 0\nCase #3: 8\nCase #4: 0"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2015", "构造", "Google Code Jam"], "title": "[GCJ 2015 #1B] Noisy Neighbors", "background": "", "description": "You are a landlord who owns a building that is an $R \\times C$ grid of apartments; each apartment is a unit square cell with four walls. You want to rent out $N$ of these apartments to tenants, with exactly one tenant per apartment, and leave the others empty. Unfortunately, all of your potential tenants are noisy, so whenever any two occupied apartments share a wall (and not just a corner), this will add one point of unhappiness to the building. For example, a $2 \\times 2$ building in which every apartment is occupied has four walls that are shared by neighboring tenants, and so the building's unhappiness score is $4$.\n\nIf you place your $N$ tenants optimally, what is the minimum unhappiness value for your building?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow; each contains three space-separated integers: $R$, $C$, and $N$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is the minimum possible unhappiness for the building.", "hint": "**Sample Explanation**\n\nIn Case #1, every room is occupied by a tenant and all seven internal walls have tenants on either side.\n\nIn Case #2, there are various ways to place the two tenants so that they do not share a wall. One is illustrated below.\n\nIn Case #3, the optimal strategy is to place the eight tenants in a ring, leaving the middle apartment unoccupied.\n\nHere are illustrations of sample cases 1-3. Each red wall adds a point of unhappiness.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sivst9rm.png)\n\n**Sample Explanation**\n\n- $1 \\leq T \\leq 1000$.\n- $0 \\leq N \\leq R \\times C$.\n\n**Small dataset(12 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq R \\times C \\leq 16$.\n\n**Large dataset(15 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq R \\times C \\leq 10000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #1B] Noisy Neighbors", "background": "", "description": "You are a landlord who owns a building that is an $R \\times C$ grid of apartments; each apartment is a unit square cell with four walls. You want to rent out $N$ of these apartments to tenants, with exactly one tenant per apartment, and leave the others empty. Unfortunately, all of your potential tenants are noisy, so whenever any two occupied apartments share a wall (and not just a corner), this will add one point of unhappiness to the building. For example, a $2 \\times 2$ building in which every apartment is occupied has four walls that are shared by neighboring tenants, and so the building's unhappiness score is $4$.\n\nIf you place your $N$ tenants optimally, what is the minimum unhappiness value for your building?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow; each contains three space-separated integers: $R$, $C$, and $N$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is the minimum possible unhappiness for the building.", "hint": "**Sample Explanation**\n\nIn Case #1, every room is occupied by a tenant and all seven internal walls have tenants on either side.\n\nIn Case #2, there are various ways to place the two tenants so that they do not share a wall. One is illustrated below.\n\nIn Case #3, the optimal strategy is to place the eight tenants in a ring, leaving the middle apartment unoccupied.\n\nHere are illustrations of sample cases 1-3. Each red wall adds a point of unhappiness.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sivst9rm.png)\n\n**Sample Explanation**\n\n- $1 \\leq T \\leq 1000$.\n- $0 \\leq N \\leq R \\times C$.\n\n**Small dataset(12 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq R \\times C \\leq 16$.\n\n**Large dataset(15 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq R \\times C \\leq 10000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #1B] Noisy Neighbors", "background": null, "description": "你是一名房东，拥有一栋由 $R \\times C$ 个公寓组成的大楼，每个公寓是一个单位正方形单元格，四面都有墙。你打算将其中 $N$ 个公寓出租，每个公寓恰好住一名租客，其余公寓保持空置。不幸的是，所有潜在租客都很吵，因此每当有两个被占用的公寓共享一面墙（仅限于共享墙，而不是仅仅是角），大楼的“不愉快值”就会增加 $1$。例如，在一个 $2 \\times 2$ 的大楼中，如果每个公寓都被占用，则有四面墙被相邻租客共享，因此大楼的“不愉快值”为 $4$。\n\n如果你以最优方式安排这 $N$ 名租客入住，最小的不愉快值是多少？", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来的 $T$ 行，每行包含三个用空格分隔的整数：$R$、$C$ 和 $N$。", "outputFormat": "对于每个测试用例，输出一行，格式为 “Case #$x$: $y$”，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是该大楼可能的最小不愉快值。", "hint": "**样例解释**\n\n在第 1 个样例中，每个房间都被租客占据，所有 7 面内部墙都有租客在两侧。\n\n在第 2 个样例中，有多种方式可以安排两名租客，使他们不共享墙。其中一种方式如下图所示。\n\n在第 3 个样例中，最优策略是将 8 名租客安排成一个环，中间的公寓空着。\n\n下图展示了样例 1-3 的示意图。每一面红色的墙都会增加一分不愉快值。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sivst9rm.png)\n\n**样例说明**\n\n- $1 \\leq T \\leq 1000$。\n- $0 \\leq N \\leq R \\times C$。\n\n**小数据集（12 分）**\n\n- 时间限制：~~240~~ 5 秒。\n- $1 \\leq R \\times C \\leq 16$。\n\n**大数据集（15 分）**\n\n- 时间限制：~~480~~ 10 秒。\n- $1 \\leq R \\times C \\leq 10000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13220", "type": "P", "difficulty": 5, "samples": [["3\n4\n1 1 12\n359 1 12\n2 1 12\n358 1 12\n2\n180 1 100000\n180 1 1\n1\n180 2 1", "Case #1: 0\nCase #2: 1\nCase #3: 0"]], "limits": {"time": [5000, 5000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2015", "堆", "Google Code Jam"], "title": "[GCJ 2015 #1B] Hiking Deer", "background": "", "description": "Herbert Hooves the deer is going for a hike: one clockwise loop around his favorite circular trail, starting at degree zero. Herbert has perfect control over his speed, which can be any nonnegative value (not necessarily an integer) at any time -- he can change his speed instantaneously whenever he wants. When Herbert reaches his starting point again, the hike is over.\n\nThe trail is also used by human hikers, who also walk clockwise around the trail. Each hiker has a starting point and moves at her own constant speed. Humans continue to walk around and around the trail forever.\n\nHerbert is a skittish deer who is afraid of people. He does not like to have encounters with hikers. An encounter occurs whenever Herbert and a hiker are in exactly the same place at the same time. You should consider Herbert and the hikers to be points on the circumference of a circle.\n\nHerbert can have multiple separate encounters with the same hiker.\n\nIf more than one hiker is encountered at the same instant, all of them count as separate encounters.\n\nAny encounter at the exact instant that Herbert finishes his hike still counts as an encounter.\n\nIf Herbert were to have an encounter with a hiker and then change his speed to exactly match that hiker's speed and follow along, he would have infinitely many encounters! Of course, he must never do this.\n\nEncounters do not change the hikers' behavior, and nothing happens when hikers encounter each other.\n\nHerbert knows the starting position and speed of each hiker. What is the minimum number of encounters with hikers that he can possibly have?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with an integer $N$, and is followed by $N$ lines, each of which represents a group of hikers starting at the same position on the trail. The $i$th of these lines has three space-separated integers: a starting position $D_i$ (representing $D_i / 360$-ths of the way around the trail from the deer's starting point), the number $H_i$ of hikers in the group, and $M_i$, the amount of time (in minutes) it takes for the fastest hiker in that group to make each complete revolution around the circle. The other hikers in that group each complete a revolution in $M_i + 1$, $M_i + 2$, ..., $M_i + H_i - 1$ minutes. For example, the line\n\n```\n180 3 4\n```\n\nwould mean that three hikers begin halfway around the trail from the deer's starting point, and that they take 4, 5, and 6 minutes, respectively, to complete each full revolution around the trail.\n\nHerbert always starts at position 0 ($0/360$-ths of the way around the circle), and no group of hikers does. Multiple groups of hikers may begin in the same place, but no two hikers will both begin in the same place and have the same speed.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from 1) and $y$ is the minimum number of encounters with hikers that the deer can have.", "hint": "**Sample Explanation**\n\nIn Case #1, the hikers all happen to be moving at the same speed, and one way for Herbert to avoid encountering any of them is to move exactly as fast as they do.\n\nIn Case #2, the second hiker is moving much faster than the first, and if Herbert goes slowly enough to avoid overtaking the first hiker, he will have multiple encounters with the speedy second hiker. One optimal strategy for Herbert is to go exactly as fast as the second hiker, encountering the first hiker once and never encountering the second hiker at all.\n\nIn Case #3, the two hikers start in the same place, but one is twice as fast as the other. One optimal strategy is for Herbert to immediately catch up to the slower hiker without overtaking him, follow just behind him until he passes the deer's starting position, and then finish quickly before the faster hiker can catch Herbert.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq D_i \\leq 359$.\n- $1 \\leq N \\leq 1000$.\n- $1 \\leq H_i$.\n- $1 \\leq M_i \\leq 10^9$. (Note that this only puts a cap on the time required for the fastest hiker in each group to complete a revolution. Slower hikers in the group will take longer.)\n\n**Small dataset 1**\n\n- Time limit: ~~240~~ 5 seconds.\n- The total number of hikers in each test case will not exceed $2$.\n\n**Small dataset 2**\n\n- Time limit: ~~240~~ 5 seconds.\n- The total number of hikers in each test case will not exceed $10$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 30 seconds.\n- The total number of hikers in each test case will not exceed $500000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #1B] Hiking Deer", "background": "", "description": "Herbert Hooves the deer is going for a hike: one clockwise loop around his favorite circular trail, starting at degree zero. Herbert has perfect control over his speed, which can be any nonnegative value (not necessarily an integer) at any time -- he can change his speed instantaneously whenever he wants. When Herbert reaches his starting point again, the hike is over.\n\nThe trail is also used by human hikers, who also walk clockwise around the trail. Each hiker has a starting point and moves at her own constant speed. Humans continue to walk around and around the trail forever.\n\nHerbert is a skittish deer who is afraid of people. He does not like to have encounters with hikers. An encounter occurs whenever Herbert and a hiker are in exactly the same place at the same time. You should consider Herbert and the hikers to be points on the circumference of a circle.\n\nHerbert can have multiple separate encounters with the same hiker.\n\nIf more than one hiker is encountered at the same instant, all of them count as separate encounters.\n\nAny encounter at the exact instant that Herbert finishes his hike still counts as an encounter.\n\nIf Herbert were to have an encounter with a hiker and then change his speed to exactly match that hiker's speed and follow along, he would have infinitely many encounters! Of course, he must never do this.\n\nEncounters do not change the hikers' behavior, and nothing happens when hikers encounter each other.\n\nHerbert knows the starting position and speed of each hiker. What is the minimum number of encounters with hikers that he can possibly have?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with an integer $N$, and is followed by $N$ lines, each of which represents a group of hikers starting at the same position on the trail. The $i$th of these lines has three space-separated integers: a starting position $D_i$ (representing $D_i / 360$-ths of the way around the trail from the deer's starting point), the number $H_i$ of hikers in the group, and $M_i$, the amount of time (in minutes) it takes for the fastest hiker in that group to make each complete revolution around the circle. The other hikers in that group each complete a revolution in $M_i + 1$, $M_i + 2$, ..., $M_i + H_i - 1$ minutes. For example, the line\n\n```\n180 3 4\n```\n\nwould mean that three hikers begin halfway around the trail from the deer's starting point, and that they take 4, 5, and 6 minutes, respectively, to complete each full revolution around the trail.\n\nHerbert always starts at position 0 ($0/360$-ths of the way around the circle), and no group of hikers does. Multiple groups of hikers may begin in the same place, but no two hikers will both begin in the same place and have the same speed.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from 1) and $y$ is the minimum number of encounters with hikers that the deer can have.", "hint": "**Sample Explanation**\n\nIn Case #1, the hikers all happen to be moving at the same speed, and one way for Herbert to avoid encountering any of them is to move exactly as fast as they do.\n\nIn Case #2, the second hiker is moving much faster than the first, and if Herbert goes slowly enough to avoid overtaking the first hiker, he will have multiple encounters with the speedy second hiker. One optimal strategy for Herbert is to go exactly as fast as the second hiker, encountering the first hiker once and never encountering the second hiker at all.\n\nIn Case #3, the two hikers start in the same place, but one is twice as fast as the other. One optimal strategy is for Herbert to immediately catch up to the slower hiker without overtaking him, follow just behind him until he passes the deer's starting position, and then finish quickly before the faster hiker can catch Herbert.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq D_i \\leq 359$.\n- $1 \\leq N \\leq 1000$.\n- $1 \\leq H_i$.\n- $1 \\leq M_i \\leq 10^9$. (Note that this only puts a cap on the time required for the fastest hiker in each group to complete a revolution. Slower hikers in the group will take longer.)\n\n**Small dataset 1**\n\n- Time limit: ~~240~~ 5 seconds.\n- The total number of hikers in each test case will not exceed $2$.\n\n**Small dataset 2**\n\n- Time limit: ~~240~~ 5 seconds.\n- The total number of hikers in each test case will not exceed $10$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 30 seconds.\n- The total number of hikers in each test case will not exceed $500000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #1B] Hiking Deer", "background": null, "description": "鹿 Herbert Hooves 要去徒步旅行：他将顺时针绕着他最喜欢的环形小径走一圈，从 $0$ 度起点出发。Herbert 可以完美地控制自己的速度，随时可以选择任意非负速度（不一定是整数），并且可以随时瞬间改变速度。当 Herbert 再次回到起点时，徒步旅行就结束了。\n\n这条小径也有其他人类徒步者，他们也会顺时针绕着小径行走。每个人类徒步者有自己的起点，并以自己的恒定速度行走。人类徒步者会一直不停地绕圈行走。\n\nHerbert 是一只胆小的鹿，他害怕人类。他不喜欢与徒步者“相遇”。当 Herbert 和某个人类徒步者在同一时刻、同一位置时，就算作一次“相遇”。你可以将 Herbert 和徒步者都视为圆周上的点。\n\nHerbert 可能会与同一个徒步者多次相遇。\n\n如果在同一时刻遇到多名徒步者，每个人都算作一次单独的相遇。\n\n如果 Herbert 在完成徒步旅行的那一刻与某个徒步者相遇，这也算作一次相遇。\n\n如果 Herbert 与某个徒步者相遇后，选择与该徒步者速度完全相同并一直跟随，那么他会与该徒步者发生无限多次相遇！当然，他绝不能这样做。\n\n相遇不会影响徒步者的行为，徒步者之间相遇也不会发生任何事情。\n\nHerbert 已经知道每个徒步者的起点和速度。请你计算，Herbert 最少会与多少名徒步者相遇？", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为一个整数 $N$，接下来有 $N$ 行，每行描述一组起点相同的徒步者。第 $i$ 行包含三个用空格分隔的整数：起点 $D_i$（表示距离鹿的起点 $D_i/360$ 圆周长度），该组徒步者人数 $H_i$，以及该组中最快徒步者每圈所需时间 $M_i$（单位为分钟）。该组的其他徒步者每圈所需时间分别为 $M_i+1$，$M_i+2$，……，$M_i+H_i-1$ 分钟。例如：\n\n```\n180 3 4\n```\n\n表示有三名徒步者从距离鹿起点一半圆周的位置出发，他们每圈分别需要 $4$、$5$、$6$ 分钟。\n\nHerbert 总是从 $0$ 位置（$0/360$ 圆周长度）出发，且没有徒步者从该点出发。多个徒步者组可以从同一位置出发，但不会有两名徒步者既起点相同又速度相同。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是鹿最少会遇到的徒步者人数。", "hint": "**样例解释**\n\n第 1 组中，所有徒步者速度相同，Herbert 可以选择与他们相同的速度，从而完全避免相遇。\n\n第 2 组中，第二名徒步者速度远快于第一名。如果 Herbert 选择足够慢的速度以避免追上第一名徒步者，他会与第二名徒步者多次相遇。最优策略是选择与第二名徒步者相同的速度，这样只会与第一名徒步者相遇一次，永远不会遇到第二名徒步者。\n\n第 3 组中，两名徒步者起点相同，但其中一人速度是另一人的两倍。最优策略是：Herbert 立即追上较慢的徒步者但不超过他，紧跟其后直到该徒步者经过鹿的起点，然后在更快的徒步者追上之前迅速完成剩余路程。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq D_i \\leq 359$。\n- $1 \\leq N \\leq 1000$。\n- $1 \\leq H_i$。\n- $1 \\leq M_i \\leq 10^9$。（注意，这只是限制每组中最快徒步者每圈所需的最短时间。组内较慢的徒步者每圈所需时间更长。）\n\n**小数据集 1**\n\n- 时间限制：5 秒。\n- 每个测试用例中徒步者总数不超过 $2$。\n\n**小数据集 2**\n\n- 时间限制：5 秒。\n- 每个测试用例中徒步者总数不超过 $10$。\n\n**大数据集**\n\n- 时间限制：30 秒。\n- 每个测试用例中徒步者总数不超过 $500000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13221", "type": "P", "difficulty": 2, "samples": [["3\n1 4 2\n1 7 7\n2 5 1", "Case #1: 3\nCase #2: 7\nCase #3: 10"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["贪心", "博弈论", "2015", "Google Code Jam"], "title": "[GCJ 2015 #1C] Brattleship", "background": "", "description": "You're about to play a simplified \"battleship\" game with your little brother. The board for this game is a rectangular grid with $R$ rows and $C$ columns. At the start of the game, you will close your eyes, and you will keep them closed until the end of the game. Your little brother will take a single rectangular $1 \\times W$ ship and place it **horizontally** somewhere on the board. The ship must always fit entirely on the board, with each cell of the ship occupying exactly one of the grid's cells, and it can never be rotated.\n\nIn each turn of the game, you name a cell on the board, and your little brother tells you whether that is a hit (one of the cells occupied by the ship) or a miss. (Your little brother doesn't say which part of the ship was hit -- just that the cell you named has a part of the ship in it.) You have perfect memory, and can keep track of all the information he has given you. Once you have named all of the cells occupied by the ship, the game is over (the ship is sunk), and your score is the number of turns taken. Your goal is to minimize your score.\n\nAlthough the ship is not supposed to be moved once it is placed, you know that your little brother, who is a brat, plans to cheat by changing the location of the ship whenever he wants, as long as the ship remains horizontal and completely on the board, and the new location is consistent with all the information he has given so far. For example, for a $1 \\times 4$ board and $1 \\times 2$ ship, your little brother could initially place the ship such that it overlaps the leftmost two columns. If your first guess was row 1, column 2, he could choose to secretly move the ship to the rightmost two columns, and tell you that $(1, 2)$ was a miss. If your next guess after that was $(1, 3)$, though, then he could not say that was also a miss and move the ship back to its original location, since that would be inconsistent with what he said about $(1, 2)$ earlier.\n\nNot only do you know that your little brother will cheat, he knows that you know. If you both play optimally (you to minimize your score, him to maximize it), what is the lowest score that you can **guarantee** you will achieve, regardless of what your little brother does?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow, each with three space-separated integers $R$, $C$, and $W$: the number of rows and columns of the board, followed by the width of the ship.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from 1) and $y$ is the minimum score you can guarantee.", "hint": "**Sample Explanation**\n\nIn Case #1, the board has one row and four columns, and the ship takes up one row and two columns. One optimal strategy is for you to start by naming cell $(1, 2)$:\n\nIf your little brother says it is a hit, then the other cell of the $1 \\times 2$ ship must be in either $(1, 1)$ or $(1, 3)$, and you just have to name both. If you happen to correctly name the cell where the other part of the ship is, your little brother will just reposition the ship so that $(1, 2)$ is still hit, but your guess is a miss. Notice that your little brother can still move the ship even after it has been hit, as long as the new position is not inconsistent with the information he has already given.\n\nIf your little brother says it is a miss, then the only remaining consistent scenario is that the ship is in $(1, 3)$ and $(1, 4)$, and your little brother will be unable to change this from now on; you just need to name those two cells.\n\nSo no matter what your little brother does after you say $(1, 2)$, you can finish the game in two more moves after that, for a total of three moves.\n\nMoreover, a three-move solution is optimal, because it is impossible to guarantee a finish in only two moves: without loss of generality, pick a first move. No matter what you pick, there is still a $1 \\times 2$ area open and your little brother can just move the ship there and claim that you missed. It is impossible for you to sink that ship, which has not yet been hit, with only one more move.\n\nIn Case #2, the ship completely fills in the board and so your little brother has only one place to put it. All you have to do is name every cell.\n\nIn Case #3, your little brother can always move the $1 \\times 1$ ship to a cell you have not tried yet, so you must name all 10 cells, only finally getting a hit (and immediately sinking the ship) on the last one.\n\n**Limits**\n\n- $1 \\leq W \\leq C$.\n\n**Small dataset**\n\n- Time limit: ~~240~~ 5 seconds.\n- $T = 55$.\n- $R = 1$.\n- $1 \\leq C \\leq 10$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq T \\leq 100$.\n- $1 \\leq R \\leq 20$.\n- $1 \\leq C \\leq 20$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #1C] Brattleship", "background": "", "description": "You're about to play a simplified \"battleship\" game with your little brother. The board for this game is a rectangular grid with $R$ rows and $C$ columns. At the start of the game, you will close your eyes, and you will keep them closed until the end of the game. Your little brother will take a single rectangular $1 \\times W$ ship and place it **horizontally** somewhere on the board. The ship must always fit entirely on the board, with each cell of the ship occupying exactly one of the grid's cells, and it can never be rotated.\n\nIn each turn of the game, you name a cell on the board, and your little brother tells you whether that is a hit (one of the cells occupied by the ship) or a miss. (Your little brother doesn't say which part of the ship was hit -- just that the cell you named has a part of the ship in it.) You have perfect memory, and can keep track of all the information he has given you. Once you have named all of the cells occupied by the ship, the game is over (the ship is sunk), and your score is the number of turns taken. Your goal is to minimize your score.\n\nAlthough the ship is not supposed to be moved once it is placed, you know that your little brother, who is a brat, plans to cheat by changing the location of the ship whenever he wants, as long as the ship remains horizontal and completely on the board, and the new location is consistent with all the information he has given so far. For example, for a $1 \\times 4$ board and $1 \\times 2$ ship, your little brother could initially place the ship such that it overlaps the leftmost two columns. If your first guess was row 1, column 2, he could choose to secretly move the ship to the rightmost two columns, and tell you that $(1, 2)$ was a miss. If your next guess after that was $(1, 3)$, though, then he could not say that was also a miss and move the ship back to its original location, since that would be inconsistent with what he said about $(1, 2)$ earlier.\n\nNot only do you know that your little brother will cheat, he knows that you know. If you both play optimally (you to minimize your score, him to maximize it), what is the lowest score that you can **guarantee** you will achieve, regardless of what your little brother does?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow, each with three space-separated integers $R$, $C$, and $W$: the number of rows and columns of the board, followed by the width of the ship.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from 1) and $y$ is the minimum score you can guarantee.", "hint": "**Sample Explanation**\n\nIn Case #1, the board has one row and four columns, and the ship takes up one row and two columns. One optimal strategy is for you to start by naming cell $(1, 2)$:\n\nIf your little brother says it is a hit, then the other cell of the $1 \\times 2$ ship must be in either $(1, 1)$ or $(1, 3)$, and you just have to name both. If you happen to correctly name the cell where the other part of the ship is, your little brother will just reposition the ship so that $(1, 2)$ is still hit, but your guess is a miss. Notice that your little brother can still move the ship even after it has been hit, as long as the new position is not inconsistent with the information he has already given.\n\nIf your little brother says it is a miss, then the only remaining consistent scenario is that the ship is in $(1, 3)$ and $(1, 4)$, and your little brother will be unable to change this from now on; you just need to name those two cells.\n\nSo no matter what your little brother does after you say $(1, 2)$, you can finish the game in two more moves after that, for a total of three moves.\n\nMoreover, a three-move solution is optimal, because it is impossible to guarantee a finish in only two moves: without loss of generality, pick a first move. No matter what you pick, there is still a $1 \\times 2$ area open and your little brother can just move the ship there and claim that you missed. It is impossible for you to sink that ship, which has not yet been hit, with only one more move.\n\nIn Case #2, the ship completely fills in the board and so your little brother has only one place to put it. All you have to do is name every cell.\n\nIn Case #3, your little brother can always move the $1 \\times 1$ ship to a cell you have not tried yet, so you must name all 10 cells, only finally getting a hit (and immediately sinking the ship) on the last one.\n\n**Limits**\n\n- $1 \\leq W \\leq C$.\n\n**Small dataset**\n\n- Time limit: ~~240~~ 5 seconds.\n- $T = 55$.\n- $R = 1$.\n- $1 \\leq C \\leq 10$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq T \\leq 100$.\n- $1 \\leq R \\leq 20$.\n- $1 \\leq C \\leq 20$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #1C] Brattleship", "background": null, "description": "你将和你的小弟弟玩一个简化版的“战舰”游戏。游戏的棋盘是一个有 $R$ 行 $C$ 列的矩形网格。在游戏开始时，你会闭上眼睛，并且直到游戏结束都不会睁开。你的小弟弟会在棋盘上放置一艘 $1 \\times W$ 的矩形战舰，且只能**水平**放置。战舰必须完全放在棋盘内，每个船格正好占据棋盘的一个格子，且不能旋转。\n\n游戏的每一回合，你可以指定棋盘上的一个格子，你的小弟弟会告诉你这个格子是否命中（即该格子是否被战舰占据）或未命中。（你的小弟弟不会告诉你命中的是战舰的哪一部分——只会告诉你该格子是否有船。）你有完美的记忆力，能记录下他给你的所有信息。当你已经指出了战舰占据的所有格子时，游戏结束（战舰被击沉），你的得分是你所用的回合数。你的目标是让得分尽可能小。\n\n虽然战舰一旦放置后理论上不应移动，但你知道你的小弟弟会作弊，只要新的位置依然是水平且完全在棋盘内，并且与他之前给你的所有信息一致，他就会随时移动战舰。例如，在一个 $1 \\times 4$ 的棋盘上放一艘 $1 \\times 2$ 的战舰，他可以最初把船放在最左边的两列。如果你第一次猜 $(1,2)$，他可以偷偷把船移到最右边的两列，并告诉你 $(1,2)$ 是未命中。如果你下一步猜 $(1,3)$，他就不能再说未命中并把船移回原来的位置了，因为那样会和他之前说的 $(1,2)$ 是未命中矛盾。\n\n不仅如此，你知道你的小弟弟会作弊，他也知道你知道。如果你们都采取最优策略（你想让得分最小，他想让得分最大），你**无论如何都能保证**的最小得分是多少？", "inputFormat": "输入的第一行是测试用例数 $T$。接下来的 $T$ 行，每行包含三个用空格分隔的整数 $R$、$C$ 和 $W$，分别表示棋盘的行数、列数和战舰的宽度。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是你能保证的最小得分。", "hint": "**样例解释**\n\n在第 1 个用例中，棋盘有一行四列，战舰占据一行两列。一种最优策略是你先猜 $(1,2)$：\n\n如果你的小弟弟说命中，那么 $1 \\times 2$ 的战舰的另一个格子只能在 $(1,1)$ 或 $(1,3)$，你只需分别猜这两个格子。如果你正好猜中了另一个格子，你的小弟弟会把船移到 $(1,2)$ 依然命中但你猜的那个格子未命中的位置。注意即使你已经命中，小弟弟依然可以移动船，只要不和之前的信息矛盾。\n\n如果你的小弟弟说未命中，那么唯一剩下的可能就是船在 $(1,3)$ 和 $(1,4)$，你只需猜这两个格子。\n\n所以无论小弟弟怎么做，在你猜 $(1,2)$ 后，最多再用两步就能结束，总共三步。\n\n而且三步是最优的，因为你不可能保证用两步完成：无论你第一步猜哪里，小弟弟都可以把船移到剩下的 $1 \\times 2$ 区域，并说未命中。你无法在只剩一步的情况下击沉还未被命中的船。\n\n在第 2 个用例中，战舰完全填满棋盘，所以小弟弟只有一种放法。你只需把所有格子都猜一遍。\n\n在第 3 个用例中，小弟弟总能把 $1 \\times 1$ 的战舰移到你没猜过的格子，所以你必须把 10 个格子都猜一遍，最后一个才会命中并击沉战舰。\n\n**限制条件**\n\n- $1 \\leq W \\leq C$。\n\n**小数据范围**\n\n- 时间限制：5 秒。\n- $T = 55$。\n- $R = 1$。\n- $1 \\leq C \\leq 10$。\n\n**大数据范围**\n\n- 时间限制：10 秒。\n- $1 \\leq T \\leq 100$。\n- $1 \\leq R \\leq 20$。\n- $1 \\leq C \\leq 20$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13222", "type": "P", "difficulty": 4, "samples": [["5\n7 6 6\nBANANAS\nMONKEY\n2 3 4\nAA\nAAA\n2 1 2\nAB\nB\n6 2 2\nGOOGLE\nGO\n26 11 100\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nROSENCRANTZ", "Case #1: 0.0\nCase #2: 0.0\nCase #3: 1.0\nCase #4: 0.8888889\nCase #5: 9.0"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2015", "Special Judge", "期望", "KMP 算法", "Google Code Jam"], "title": "[GCJ 2015 #1C] Typewriter Monkey", "background": "", "description": "Your publishing house has decided to use monkeys randomly typing at keyboards to write great works of literature. You are the supervisor for one monkey with a keyboard containing $K$ keys, each of which is labeled with an uppercase English letter. (There may be multiple keys displaying the same letter.) The monkey will start with an empty string and repeat the following $S$ times: choose a key from its keyboard uniformly at random and press it, adding a copy of that key's letter to the right end of the string. The final resulting string will have length $S$.\n\nYou have a *target word* of length $L$ that you are hoping the monkey will type. (The target word will not necessarily be a real English word.) This target word may even appear multiple times in what the monkey types. (Overlapping instances count too -- for example, if \"ABA\" is the target word and the monkey types \"ABABA\", that contains two instances of the target.)\n\nYou plan to pay the monkey one banana for each instance of the target word that it types. When you go to inspect the monkey's work, you will bring along the minimum number of bananas that you need to ensure that you will always have enough bananas to pay the monkey, no matter what it has typed. Then, you will pay the monkey one banana for each instance of the target word that it actually typed. You will keep the remaining bananas that you brought with you.\n\nWhat is the expected number of bananas that you will get to keep?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of three lines. The first contains three space-separated positive integers: $K$, $L$, and $S$. The second contains a string of $K$ uppercase English letters representing the monkey's keyboard. The third contains a string of $L$ uppercase English letters representing the target word.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $y$ is the expected number of bananas you will get to keep after paying the monkey.\n\n$y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nNote that Case #5 is not within the limits for the Small dataset.\n\nIn Case #1, the monkey has no chance of typing the target word \"MONKEY\" even once (because his keyboard lacks most of the letters in \"MONKEY\"), so you do not bring any bananas along when you visit, and of course you do not pay any. Poor monkey!\n\nIn Case #2, the monkey is guaranteed to type \"AAAA\", which has two overlapping instances of the target word \"AAA\". You will bring two bananas and then pay both.\n\nIn Case #3, the monkey will produce the following outputs with equal probability (1/4 each): \"AA\", \"AB\", \"BA\", \"BB\". These have 0, 1, 1, and 2 instances of the target word, respectively. You must bring 2 bananas to be ready for the \"BB\" case, but you will on average pay $(0 + 1 + 1 + 2) / 4 = 1$.\n\nIn Case #4, the monkey has a $1/3$ chance of typing a \"G\" first and a $1/3$ chance of typing an \"O\" second, for a $1/9$ chance of typing \"GO\". You will bring one banana and give it up $1/9$ of the time.\n\nIn Case #5, the monkey could in theory type \"ROSENCRANTZ\" up to nine times, but the chances of this happening even once are so small that they are negligible compared to the acceptable margin of error for answers.\n\n**Limits**\n\n$1 \\leq T \\leq 100$.\n\n**Small dataset(11 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq K \\leq 7$.\n- $1 \\leq L \\leq S \\leq 7$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq K \\leq 100$.\n- $1 \\leq L \\leq S \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #1C] Typewriter Monkey", "background": "", "description": "Your publishing house has decided to use monkeys randomly typing at keyboards to write great works of literature. You are the supervisor for one monkey with a keyboard containing $K$ keys, each of which is labeled with an uppercase English letter. (There may be multiple keys displaying the same letter.) The monkey will start with an empty string and repeat the following $S$ times: choose a key from its keyboard uniformly at random and press it, adding a copy of that key's letter to the right end of the string. The final resulting string will have length $S$.\n\nYou have a *target word* of length $L$ that you are hoping the monkey will type. (The target word will not necessarily be a real English word.) This target word may even appear multiple times in what the monkey types. (Overlapping instances count too -- for example, if \"ABA\" is the target word and the monkey types \"ABABA\", that contains two instances of the target.)\n\nYou plan to pay the monkey one banana for each instance of the target word that it types. When you go to inspect the monkey's work, you will bring along the minimum number of bananas that you need to ensure that you will always have enough bananas to pay the monkey, no matter what it has typed. Then, you will pay the monkey one banana for each instance of the target word that it actually typed. You will keep the remaining bananas that you brought with you.\n\nWhat is the expected number of bananas that you will get to keep?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of three lines. The first contains three space-separated positive integers: $K$, $L$, and $S$. The second contains a string of $K$ uppercase English letters representing the monkey's keyboard. The third contains a string of $L$ uppercase English letters representing the target word.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $y$ is the expected number of bananas you will get to keep after paying the monkey.\n\n$y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nNote that Case #5 is not within the limits for the Small dataset.\n\nIn Case #1, the monkey has no chance of typing the target word \"MONKEY\" even once (because his keyboard lacks most of the letters in \"MONKEY\"), so you do not bring any bananas along when you visit, and of course you do not pay any. Poor monkey!\n\nIn Case #2, the monkey is guaranteed to type \"AAAA\", which has two overlapping instances of the target word \"AAA\". You will bring two bananas and then pay both.\n\nIn Case #3, the monkey will produce the following outputs with equal probability (1/4 each): \"AA\", \"AB\", \"BA\", \"BB\". These have 0, 1, 1, and 2 instances of the target word, respectively. You must bring 2 bananas to be ready for the \"BB\" case, but you will on average pay $(0 + 1 + 1 + 2) / 4 = 1$.\n\nIn Case #4, the monkey has a $1/3$ chance of typing a \"G\" first and a $1/3$ chance of typing an \"O\" second, for a $1/9$ chance of typing \"GO\". You will bring one banana and give it up $1/9$ of the time.\n\nIn Case #5, the monkey could in theory type \"ROSENCRANTZ\" up to nine times, but the chances of this happening even once are so small that they are negligible compared to the acceptable margin of error for answers.\n\n**Limits**\n\n$1 \\leq T \\leq 100$.\n\n**Small dataset(11 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq K \\leq 7$.\n- $1 \\leq L \\leq S \\leq 7$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq K \\leq 100$.\n- $1 \\leq L \\leq S \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #1C] Typewriter Monkey", "background": null, "description": "你的出版社决定让猴子随机敲击键盘来创作伟大的文学作品。你是一个猴子的监督员，这只猴子的键盘上有 $K$ 个按键，每个按键上都标有一个大写英文字母（同一个字母可能出现在多个按键上）。猴子将从一个空字符串开始，重复 $S$ 次以下操作：从键盘上等概率随机选择一个按键并按下，将该按键上的字母添加到字符串的末尾。最终得到的字符串长度为 $S$。\n\n你有一个长度为 $L$ 的*目标单词*，你希望猴子能够敲出来（目标单词不一定是真正的英文单词）。这个目标单词可能在猴子敲出的字符串中出现多次（重叠的情况也算，例如目标单词为 \"ABA\"，猴子敲出 \"ABABA\" 时，包含两个 \"ABA\"）。\n\n你打算每出现一次目标单词就给猴子一根香蕉。当你去检查猴子的作品时，你会带上足够多的香蕉，以保证无论猴子敲出了什么，你都能支付得起。然后，你会根据猴子实际敲出的目标单词次数支付香蕉，剩下的香蕉归你所有。\n\n你期望最终能留下多少根香蕉？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据包含三行：\n\n第一行包含三个用空格分隔的正整数：$K$、$L$ 和 $S$。\n\n第二行为一个长度为 $K$ 的仅包含大写英文字母的字符串，表示猴子的键盘。\n\n第三行为一个长度为 $L$ 的仅包含大写英文字母的字符串，表示目标单词。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为你期望能留下的香蕉数。\n\n如果 $y$ 的绝对误差或相对误差在 $10^{-6}$ 以内，则视为正确。", "hint": "**样例解释**\n\n注意，第 5 组样例不在 Small 数据集的范围内。\n\n在第 1 组样例中，猴子根本无法敲出目标单词 \"MONKEY\"（因为键盘上缺少目标单词中的大部分字母），所以你无需带香蕉，也不会支付任何香蕉。可怜的猴子！\n\n在第 2 组样例中，猴子一定会敲出 \"AAAA\"，其中目标单词 \"AAA\" 会出现两次（重叠），你需要带两根香蕉并全部支付出去。\n\n在第 3 组样例中，猴子可能敲出的字符串有 \"AA\"、\"AB\"、\"BA\"、\"BB\"，每种概率均为 $1/4$，它们分别包含 0、1、1、2 次目标单词。你需要带两根香蕉以备 \"BB\" 的情况，但平均支付 $(0 + 1 + 1 + 2) / 4 = 1$ 根香蕉。\n\n在第 4 组样例中，猴子第一步有 $1/3$ 的概率敲 \"G\"，第二步有 $1/3$ 的概率敲 \"O\"，所以敲出 \"GO\" 的概率为 $1/9$，你需要带一根香蕉，并在 $1/9$ 的情况下支付出去。\n\n在第 5 组样例中，理论上猴子最多能敲出 9 次 \"ROSENCRANTZ\"，但实际出现一次的概率都极小，可以忽略不计。\n\n**数据范围**\n\n$1 \\leq T \\leq 100$。\n\n**小数据集（11 分）**\n\n- 时间限制：~~240~~ 5 秒。\n- $1 \\leq K \\leq 7$。\n- $1 \\leq L \\leq S \\leq 7$。\n\n**大数据集**\n\n- 时间限制：~~480~~ 10 秒。\n- $1 \\leq K \\leq 100$。\n- $1 \\leq L \\leq S \\leq 100$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13223", "type": "P", "difficulty": 4, "samples": [["4\n1 2 3\n1 2\n1 3 6\n1 2 5\n2 1 3\n3\n1 6 100\n1 5 10 25 50 100", "Case #1: 0\nCase #2: 1\nCase #3: 1\nCase #4: 3"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2015", "Google Code Jam"], "title": "[GCJ 2015 #1C] Less Money, More Problems", "background": "", "description": "Up until today, the nation you live in has used $\\mathbf{D}$ different positive integer denominations of coin for all transactions. Today, the queen got angry when a subject tried to pay his taxes with a giant sack of low-valued coins, and she just decreed that no more than $\\mathbf{C}$ coins of any one denomination may be used in any one purchase. For instance, if $\\mathbf{C} = 2$ and the existing denominations are $1$ and $5$, it is possible to buy something of value $11$ by using two $5$s and one $1$, or something of value $12$ by using two $5$s and two $1$s, but it is impossible to buy something of value $9$ or $17$.\n\nYou cannot directly challenge the queen's decree, but you happen to be in charge of the mint, and you can issue new denominations of coin. You want to make it possible for any item of positive value at most $\\mathbf{V}$ to be purchased under the queen's new rules. (Note that this may not necessarily have been possible before the queen's decree.) Moreover, you want to introduce as few new denominations as possible, and your final combined set of pre-existing and new denominations may not have any repeats.\n\nWhat is the smallest number of new denominations required?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with three space-separated values $\\mathbf{C}$, $\\mathbf{D}$, and $\\mathbf{V}$, followed by another line with $\\mathbf{D}$ distinct space-separated values representing the preexisting denominations, in ascending order.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where x is the test case number (starting from $1$) and y is the minimum number of new denominations required, as described above.", "hint": "**Sample Explanation**\n\nNote that Cases #3 and #4 are not within the limits for the Small dataset.\n\nIn Case #1, it is already possible to make all the required values ($1, 2$, and $3$) using at most one copy of each of the existing denominations.\n\nIn Case #2, it suffices to add a denomination of either $3$ or $4$ -- whichever you choose, only one new denomination is required.\n\nIn Case #3, the optimal solution is to add a denomination of $1$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each existing denomination $\\leq \\mathbf{V}$.\n\n**Small dataset(11 Pts)**\n- Time limit: ~~240~~ 5 seconds.\n- $\\mathbf{C} = 1$.\n- $1 \\leq \\mathbf{D} \\leq 5$.\n- $1 \\leq \\mathbf{V} \\leq 30$.\n\n**Large dataset(23 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{C} \\leq 100$.\n- $1 \\leq \\mathbf{D} \\leq 100$.\n- $1 \\leq \\mathbf{V} \\leq 10^9$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #1C] Less Money, More Problems", "background": "", "description": "Up until today, the nation you live in has used $\\mathbf{D}$ different positive integer denominations of coin for all transactions. Today, the queen got angry when a subject tried to pay his taxes with a giant sack of low-valued coins, and she just decreed that no more than $\\mathbf{C}$ coins of any one denomination may be used in any one purchase. For instance, if $\\mathbf{C} = 2$ and the existing denominations are $1$ and $5$, it is possible to buy something of value $11$ by using two $5$s and one $1$, or something of value $12$ by using two $5$s and two $1$s, but it is impossible to buy something of value $9$ or $17$.\n\nYou cannot directly challenge the queen's decree, but you happen to be in charge of the mint, and you can issue new denominations of coin. You want to make it possible for any item of positive value at most $\\mathbf{V}$ to be purchased under the queen's new rules. (Note that this may not necessarily have been possible before the queen's decree.) Moreover, you want to introduce as few new denominations as possible, and your final combined set of pre-existing and new denominations may not have any repeats.\n\nWhat is the smallest number of new denominations required?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with three space-separated values $\\mathbf{C}$, $\\mathbf{D}$, and $\\mathbf{V}$, followed by another line with $\\mathbf{D}$ distinct space-separated values representing the preexisting denominations, in ascending order.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where x is the test case number (starting from $1$) and y is the minimum number of new denominations required, as described above.", "hint": "**Sample Explanation**\n\nNote that Cases #3 and #4 are not within the limits for the Small dataset.\n\nIn Case #1, it is already possible to make all the required values ($1, 2$, and $3$) using at most one copy of each of the existing denominations.\n\nIn Case #2, it suffices to add a denomination of either $3$ or $4$ -- whichever you choose, only one new denomination is required.\n\nIn Case #3, the optimal solution is to add a denomination of $1$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each existing denomination $\\leq \\mathbf{V}$.\n\n**Small dataset(11 Pts)**\n- Time limit: ~~240~~ 5 seconds.\n- $\\mathbf{C} = 1$.\n- $1 \\leq \\mathbf{D} \\leq 5$.\n- $1 \\leq \\mathbf{V} \\leq 30$.\n\n**Large dataset(23 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{C} \\leq 100$.\n- $1 \\leq \\mathbf{D} \\leq 100$.\n- $1 \\leq \\mathbf{V} \\leq 10^9$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #1C] Less Money, More Problems", "background": null, "description": "直到今天，你所在的国家一直使用 $\\mathbf{D}$ 种不同面值的正整数硬币进行所有交易。今天，女王因一位臣民试图用一大袋低面值硬币缴税而大为光火，并下令：在任何一次购买中，每种面值的硬币最多只能使用 $\\mathbf{C}$ 枚。例如，如果 $\\mathbf{C} = 2$，现有的面值为 $1$ 和 $5$，那么可以用两个 $5$ 和一个 $1$ 买到价值 $11$ 的物品，或者用两个 $5$ 和两个 $1$ 买到价值 $12$ 的物品，但无法买到价值 $9$ 或 $17$ 的物品。\n\n你无法直接挑战女王的命令，但你恰好负责铸币厂，可以发行新的硬币面值。你希望在女王新规定下，使得任意不超过 $\\mathbf{V}$ 的正整数金额都能被购买（注意，在女王下令前，这可能并不总是可行）。此外，你希望新增的面值数量尽可能少，并且最终的面值集合（包括原有和新增）不能有重复。\n\n请问，最少需要新增多少种面值？", "inputFormat": "输入的第一行为测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例包含两行，第一行为三个用空格分隔的整数 $\\mathbf{C}$、$\\mathbf{D}$ 和 $\\mathbf{V}$，第二行为 $\\mathbf{D}$ 个升序排列的不同整数，表示已有的硬币面值。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 表示测试用例编号（从 $1$ 开始），$y$ 表示所需新增的最少面值数量。", "hint": "**样例解释**\n\n注意，样例中的第 3 和第 4 组数据不在 Small 数据集的限制范围内。\n\n在第 1 组中，已经可以用现有的面值（每种最多用一枚）组合出所有需要的金额（$1, 2, 3$）。\n\n在第 2 组中，只需新增面值 $3$ 或 $4$ 中的任意一个即可——无论选择哪一个，只需新增一种面值。\n\n在第 3 组中，最优解是新增面值 $1$。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 每种已有面值 $\\leq \\mathbf{V}$。\n\n**Small 数据集（11 分）**\n- 时间限制：~~240~~ 5 秒。\n- $\\mathbf{C} = 1$。\n- $1 \\leq \\mathbf{D} \\leq 5$。\n- $1 \\leq \\mathbf{V} \\leq 30$。\n\n**Large 数据集（23 分）**\n\n- 时间限制：~~480~~ 10 秒。\n- $1 \\leq \\mathbf{C} \\leq 100$。\n- $1 \\leq \\mathbf{D} \\leq 100$。\n- $1 \\leq \\mathbf{V} \\leq 10^9$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13224", "type": "P", "difficulty": 2, "samples": [["4\n2 1\n^\n^\n2 2\n>v\n^<\n3 3\n...\n.^.\n...\n1 1\n.", "Case #1: 1\nCase #2: 0\nCase #3: IMPOSSIBLE\nCase #4: 0"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2015", "Google Code Jam"], "title": "[GCJ 2015 #2] Pegman", "background": "", "description": "While using Google Street View, you may have picked up and dropped the character Pegman before. Today, a mischievous user is going to place Pegman in some cell of a rectangular grid of unit cells with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. Each of the cells in this grid might be blank, or it might be labeled with an arrow pointing in one of four possible directions: up, right, down, or left.\n\nWhen Pegman is placed on a grid cell, if that cell is blank, Pegman stands still forever. However, if that cell has an arrow, Pegman starts to walk in that direction. As he walks, whenever he encounters a blank cell, he just keeps walking in his current direction, but whenever he encounters another arrow, he changes to the direction of that arrow and then keeps walking.\n\nYou know that it is possible that Pegman might keep happily walking around and around the grid forever, but it is also possible that Pegman's walk will take him over the edge of the grid! You may be able to prevent this and save him by changing the direction of one or more arrows. (Each arrow's direction can only be changed to one of the other three possible directions; arrows can only be changed, not added or removed.)\n\nWhat is the smallest number of arrows you will need to change to ensure that Pegman will not walk off the edge, no matter where on the grid he is initially placed?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with two space-separated integers $\\mathbf{R}$, $\\mathbf{C}$. This line is followed by $\\mathbf{R}$ lines, each of which has $\\mathbf{C}$ characters, each of which describes a grid cell and is one of the following:\n\n```\n. period = no arrow\n^ caret = up arrow\n> greater than = right arrow\nv lowercase v = down arrow\n< less than = left arrow\n```\n\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from 1) and $y$ is the minimum number of arrows that must be changed to ensure that Pegman will not leave the grid no matter where he is initially placed, or the text IMPOSSIBLE if it is not possible to ensure this, no matter how many arrows you change.", "hint": "**Sample Explanation**\n\nIn Case #1, Pegman is guaranteed to walk off the top edge of the grid, no matter where he is placed. You can prevent that by changing the topmost arrow to point down, which will cause him to walk back and forth between those two arrows forever.\n\nIn Case #2, no matter where Pegman is placed, he will walk around and around the board clockwise in a circle. No arrows need to be changed.\n\nIn Case #3, the mischievous user might place Pegman on the up arrow in the middle of the grid, in which case he will start walking and then walk off the top edge of the grid. Changing the direction of this arrow won't help: it would just make him walk off a different edge.\n\nIn Case #4, the only possible starting cell is blank, so Pegman will stand still forever and is in no danger.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Small dataset(5 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathbf{R}, \\mathbf{C} \\leq 4$.\n \n**Large dataset(10 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{R}, \\mathbf{C} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #2] Pegman", "background": "", "description": "While using Google Street View, you may have picked up and dropped the character Pegman before. Today, a mischievous user is going to place Pegman in some cell of a rectangular grid of unit cells with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. Each of the cells in this grid might be blank, or it might be labeled with an arrow pointing in one of four possible directions: up, right, down, or left.\n\nWhen Pegman is placed on a grid cell, if that cell is blank, Pegman stands still forever. However, if that cell has an arrow, Pegman starts to walk in that direction. As he walks, whenever he encounters a blank cell, he just keeps walking in his current direction, but whenever he encounters another arrow, he changes to the direction of that arrow and then keeps walking.\n\nYou know that it is possible that Pegman might keep happily walking around and around the grid forever, but it is also possible that Pegman's walk will take him over the edge of the grid! You may be able to prevent this and save him by changing the direction of one or more arrows. (Each arrow's direction can only be changed to one of the other three possible directions; arrows can only be changed, not added or removed.)\n\nWhat is the smallest number of arrows you will need to change to ensure that Pegman will not walk off the edge, no matter where on the grid he is initially placed?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with two space-separated integers $\\mathbf{R}$, $\\mathbf{C}$. This line is followed by $\\mathbf{R}$ lines, each of which has $\\mathbf{C}$ characters, each of which describes a grid cell and is one of the following:\n\n```\n. period = no arrow\n^ caret = up arrow\n> greater than = right arrow\nv lowercase v = down arrow\n< less than = left arrow\n```\n\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from 1) and $y$ is the minimum number of arrows that must be changed to ensure that Pegman will not leave the grid no matter where he is initially placed, or the text IMPOSSIBLE if it is not possible to ensure this, no matter how many arrows you change.", "hint": "**Sample Explanation**\n\nIn Case #1, Pegman is guaranteed to walk off the top edge of the grid, no matter where he is placed. You can prevent that by changing the topmost arrow to point down, which will cause him to walk back and forth between those two arrows forever.\n\nIn Case #2, no matter where Pegman is placed, he will walk around and around the board clockwise in a circle. No arrows need to be changed.\n\nIn Case #3, the mischievous user might place Pegman on the up arrow in the middle of the grid, in which case he will start walking and then walk off the top edge of the grid. Changing the direction of this arrow won't help: it would just make him walk off a different edge.\n\nIn Case #4, the only possible starting cell is blank, so Pegman will stand still forever and is in no danger.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Small dataset(5 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathbf{R}, \\mathbf{C} \\leq 4$.\n \n**Large dataset(10 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{R}, \\mathbf{C} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #2] Pegman", "background": null, "description": "在使用 Google 街景时，你可能曾经拖动并放下过角色 Pegman。今天，一个调皮的用户要把 Pegman 放在一个 $R$ 行 $C$ 列的单位格矩形网格中的某个格子里。这个网格中的每个格子可能是空白的，也可能标有一个箭头，箭头指向四个可能的方向之一：上、右、下或左。\n\n当 Pegman 被放在一个格子上时，如果该格子是空白的，Pegman 会永远静止不动。然而，如果该格子上有一个箭头，Pegman 会开始朝那个方向行走。在行走过程中，每当他遇到空白格子时，他会继续保持当前方向前进；但每当他遇到另一个箭头时，他会转向该箭头指示的方向，然后继续行走。\n\n你知道 Pegman 可能会一直在网格上快乐地循环行走，但也有可能 Pegman 会走出网格的边界！你可以通过改变一个或多个箭头的方向来防止这种情况发生，从而拯救他。（每个箭头的方向只能更改为另外三种可能的方向；只能更改箭头，不能添加或移除箭头。）\n\n你需要求出，最少需要更改多少个箭头的方向，才能确保无论 Pegman 最初被放在网格的哪个位置，他都不会走出网格边界？如果无论怎么更改箭头都无法保证这一点，则输出 IMPOSSIBLE。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为两个用空格分隔的整数 $R$ 和 $C$。接下来有 $R$ 行，每行有 $C$ 个字符，描述网格的每个格子，每个字符为以下之一：\n\n```\n. 句点 = 无箭头\n^ 上箭头\n> 右箭头\nv 下箭头\n< 左箭头\n```", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为最少需要更改的箭头数量，或者如果无论如何都无法保证 Pegman 不会走出网格，则输出 IMPOSSIBLE。", "hint": "**样例解释**\n\n在第 1 组样例中，无论 Pegman 被放在哪里，他都一定会走出网格的上边界。你可以通过将最上面的箭头改为向下，从而让 Pegman 在这两个箭头之间来回循环，避免走出网格。\n\n在第 2 组样例中，无论 Pegman 被放在哪里，他都会顺时针绕着网格循环行走，无需更改任何箭头。\n\n在第 3 组样例中，调皮的用户可能会把 Pegman 放在网格中央的上箭头上，这样他会开始行走并最终走出网格的上边界。更改这个箭头的方向也无济于事：他只会从别的边界走出去。\n\n在第 4 组样例中，唯一的起始格子是空白格，Pegman 会永远静止，不会有危险。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n\n**小数据集（5 分）**\n\n- 时间限制：5 秒。\n- $1 \\leq R, C \\leq 4$。\n\n**大数据集（10 分）**\n\n- 时间限制：10 秒。\n- $1 \\leq R, C \\leq 100$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13225", "type": "P", "difficulty": 4, "samples": [["6\n1 10.0000 50.0000\n0.2000 50.0000\n2 30.0000 65.4321\n0.0001 50.0000\n100.0000 99.9000\n2 5.0000 99.9000\n30.0000 99.8999\n20.0000 99.7000\n2 0.0001 77.2831\n0.0001 97.3911\n0.0001 57.1751\n2 100.0000 75.6127\n70.0263 75.6127\n27.0364 27.7990\n4 5000.0000 75.0000\n10.0000 30.0000\n20.0000 50.0000\n300.0000 95.0000\n40.0000 2.0000", "Case #1: 50.0000000\nCase #2: 207221.843687375\nCase #3: IMPOSSIBLE\nCase #4: 0.500000000\nCase #5: 1.428034895\nCase #6: 18.975332068"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["数学", "贪心", "2015", "Special Judge", "Google Code Jam"], "title": "[GCJ 2015 #2] Kiddie Pool", "background": "", "description": "A kiddie pool is a big container in which you can put water, so that small children can play in it.\n\nYou have access to $\\mathbf{N}$ different sources of water. The $i^{\\text {th }}$ source of water produces water at rate $\\mathbf{R}_{i}$ and at temperature $\\mathbf{C}_{i}$. Initially, all of the water sources are off. Each source of water can be switched on only once, and switched off only once; the act of switching a source on or off takes no additional time. Multiple sources can be on at the same time.\n\nYour pool can hold an infinite amount of water, but you want to fill the pool to a volume of exactly $\\mathbf{V}$ with a temperature of exactly $\\mathbf{X}$, as quickly as possible. If you turn sources on and off optimally (not every source necessarily has to be used), what's the minimum number of seconds it will take you to do this?\n\nFor the purposes of this problem, combining water that has volume $\\mathbf{V}_{0}$ and temperature $\\mathbf{X}_{0}$ with water that has volume $\\mathbf{V}_{1}$ and temperature $\\mathbf{X}_{1}$ will instantaneously create water with volume $\\mathbf{V}_{0}+\\mathbf{V}_{1}$ and temperature $\\left(\\mathbf{V}_{0} \\mathbf{X}_{0}+\\mathbf{V}_{1} \\mathbf{X}_{1}\\right) /\\left(\\mathbf{V}_{0}+\\mathbf{V}_{1}\\right)$. For example, combining $5 \\mathrm{~L}$ of water at 10 degrees with $10 \\mathrm{~L}$ of water at 40 degrees will result in $15 \\mathrm{~L}$ of water at 30 degrees. You should also assume that water does not heat or cool over time except as a result of being combined with other water.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of each test case contains three space-separated numbers: an integer $\\mathbf{N}$, and real numbers $\\mathbf{V}$ and $\\mathbf{X}$ as described above.\n\nThe next $\\mathbf{N}$ lines each contain two space-separated real numbers, $\\mathbf{R}_{i}$ and $\\mathbf{C}_{i}$, the rate of flow and temperature of the $i^{\\text {th }}$ water source respectively. The volume is expressed in liters, rates of flow are expressed in liters per second, and temperatures are expressed in degrees Celsius.\n\nAll real numbers will be exactly specified to four decimal places.", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the minimum number of seconds it takes to fill the kiddie pool to the right volume and temperature. If it is impossible to do so given the inputs, $\\mathrm{y}$ should be the string IMPOSSIBLE.\n\n$\\mathrm{y}$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nNote that Case #6 is not within the limits for the Small dataset.\n\nIn Case #1, the one available source happens to be the exact temperature we need. The optimal strategy is to immediately turn it on and let it run until we have $10$ L. Since $0.2$ L will come out every second, this takes $50$ seconds.\n\nIn Case #2, one optimal strategy is to turn on the first source and let it run for $207221.843687375$ seconds, and then, about $0.092778156$ seconds before the end, also turn on the second source.\n\nIn Case #3, both available water sources are cooler than the target temperature, so there is no way to reach it.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0.1 \\leq \\mathbf{X} \\leq 99.9$.\n- $0.1 \\leq \\mathbf{C}_{i} \\leq 99.9$.\n\n**Small dataset(7 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 2$.\n- $0.0001 \\leq \\mathbf{V} \\leq 100.0$.\n- $0.0001 \\leq \\mathbf{R}_{i} \\leq 100.0$.\n\n**Large dataset(18 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{N} \\leq 100$.\n- $0.0001 \\leq \\mathbf{V} \\leq 10000.0$.\n- $0.0001 \\leq \\mathbf{R}_{i} \\leq 10000.0$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #2] Kiddie Pool", "background": "", "description": "A kiddie pool is a big container in which you can put water, so that small children can play in it.\n\nYou have access to $\\mathbf{N}$ different sources of water. The $i^{\\text {th }}$ source of water produces water at rate $\\mathbf{R}_{i}$ and at temperature $\\mathbf{C}_{i}$. Initially, all of the water sources are off. Each source of water can be switched on only once, and switched off only once; the act of switching a source on or off takes no additional time. Multiple sources can be on at the same time.\n\nYour pool can hold an infinite amount of water, but you want to fill the pool to a volume of exactly $\\mathbf{V}$ with a temperature of exactly $\\mathbf{X}$, as quickly as possible. If you turn sources on and off optimally (not every source necessarily has to be used), what's the minimum number of seconds it will take you to do this?\n\nFor the purposes of this problem, combining water that has volume $\\mathbf{V}_{0}$ and temperature $\\mathbf{X}_{0}$ with water that has volume $\\mathbf{V}_{1}$ and temperature $\\mathbf{X}_{1}$ will instantaneously create water with volume $\\mathbf{V}_{0}+\\mathbf{V}_{1}$ and temperature $\\left(\\mathbf{V}_{0} \\mathbf{X}_{0}+\\mathbf{V}_{1} \\mathbf{X}_{1}\\right) /\\left(\\mathbf{V}_{0}+\\mathbf{V}_{1}\\right)$. For example, combining $5 \\mathrm{~L}$ of water at 10 degrees with $10 \\mathrm{~L}$ of water at 40 degrees will result in $15 \\mathrm{~L}$ of water at 30 degrees. You should also assume that water does not heat or cool over time except as a result of being combined with other water.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of each test case contains three space-separated numbers: an integer $\\mathbf{N}$, and real numbers $\\mathbf{V}$ and $\\mathbf{X}$ as described above.\n\nThe next $\\mathbf{N}$ lines each contain two space-separated real numbers, $\\mathbf{R}_{i}$ and $\\mathbf{C}_{i}$, the rate of flow and temperature of the $i^{\\text {th }}$ water source respectively. The volume is expressed in liters, rates of flow are expressed in liters per second, and temperatures are expressed in degrees Celsius.\n\nAll real numbers will be exactly specified to four decimal places.", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the minimum number of seconds it takes to fill the kiddie pool to the right volume and temperature. If it is impossible to do so given the inputs, $\\mathrm{y}$ should be the string IMPOSSIBLE.\n\n$\\mathrm{y}$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nNote that Case #6 is not within the limits for the Small dataset.\n\nIn Case #1, the one available source happens to be the exact temperature we need. The optimal strategy is to immediately turn it on and let it run until we have $10$ L. Since $0.2$ L will come out every second, this takes $50$ seconds.\n\nIn Case #2, one optimal strategy is to turn on the first source and let it run for $207221.843687375$ seconds, and then, about $0.092778156$ seconds before the end, also turn on the second source.\n\nIn Case #3, both available water sources are cooler than the target temperature, so there is no way to reach it.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0.1 \\leq \\mathbf{X} \\leq 99.9$.\n- $0.1 \\leq \\mathbf{C}_{i} \\leq 99.9$.\n\n**Small dataset(7 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 2$.\n- $0.0001 \\leq \\mathbf{V} \\leq 100.0$.\n- $0.0001 \\leq \\mathbf{R}_{i} \\leq 100.0$.\n\n**Large dataset(18 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{N} \\leq 100$.\n- $0.0001 \\leq \\mathbf{V} \\leq 10000.0$.\n- $0.0001 \\leq \\mathbf{R}_{i} \\leq 10000.0$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #2] Kiddie Pool", "background": null, "description": "儿童泳池是一个可以盛水的大容器，小孩子可以在里面玩耍。\n\n你有 $N$ 个不同的水源可用。第 $i$ 个水源的出水速率为 $R_i$，水温为 $C_i$。最初，所有水源都是关闭的。每个水源只能被打开一次，也只能被关闭一次；打开或关闭水源的操作不需要额外时间。多个水源可以同时开启。\n\n你的泳池可以容纳无限量的水，但你希望以最快的速度将泳池注满体积恰好为 $V$、温度恰好为 $X$ 的水。你可以最优地控制水源的开关（并非每个水源都必须使用），请问最少需要多少秒才能完成？\n\n在本题中，将体积为 $V_0$、温度为 $X_0$ 的水与体积为 $V_1$、温度为 $X_1$ 的水混合后，会瞬间得到体积为 $V_0+V_1$、温度为 $\\frac{V_0 X_0 + V_1 X_1}{V_0 + V_1}$ 的水。例如，将 $5$ 升 $10$ 度的水与 $10$ 升 $40$ 度的水混合后，会得到 $15$ 升 $30$ 度的水。你可以假设水只会因混合而改变温度，不会随时间加热或冷却。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为三个用空格分隔的数：一个整数 $N$，两个实数 $V$ 和 $X$，含义如上所述。\n\n接下来的 $N$ 行，每行包含两个用空格分隔的实数，分别为第 $i$ 个水源的出水速率 $R_i$ 和水温 $C_i$。体积以升为单位，流速以升每秒为单位，温度以摄氏度为单位。\n\n所有实数均精确到小数点后四位。", "outputFormat": "对于每个测试用例，输出一行，格式为 “Case #x: y”，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是将儿童泳池注满到指定体积和温度所需的最少秒数。如果无法实现，则 $y$ 应为字符串 IMPOSSIBLE。\n\n如果 $y$ 的绝对误差或相对误差在 $10^{-6}$ 以内，则视为正确。", "hint": "**样例解释**\n\n注意，第 6 个样例不在 Small 数据集的范围内。\n\n在第 1 个样例中，唯一的水源温度正好是目标温度。最优策略是立即打开它，直到注满 $10$ 升。由于每秒流出 $0.2$ 升，需要 $50$ 秒。\n\n在第 2 个样例中，一种最优策略是先打开第一个水源，持续 $207221.843687375$ 秒，然后在结束前约 $0.092778156$ 秒打开第二个水源。\n\n在第 3 个样例中，所有水源温度都低于目标温度，因此无法实现目标。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $0.1 \\leq X \\leq 99.9$。\n- $0.1 \\leq C_i \\leq 99.9$。\n\n**小数据集（7 分）**\n\n- 时间限制：5 秒。\n- $1 \\leq N \\leq 2$。\n- $0.0001 \\leq V \\leq 100.0$。\n- $0.0001 \\leq R_i \\leq 100.0$。\n\n**大数据集（18 分）**\n\n- 时间限制：10 秒。\n- $1 \\leq N \\leq 100$。\n- $0.0001 \\leq V \\leq 10000.0$。\n- $0.0001 \\leq R_i \\leq 10000.0$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13226", "type": "P", "difficulty": 6, "samples": [["4\n2\nhe loves to eat baguettes\nil aime manger des baguettes\n4\na b c d e\nf g h i j\na b c i j\nf g h d e\n4\nhe drove into a cul de sac\nelle a conduit sa voiture\nil a conduit dans un cul de sac\nil mange pendant que il conduit sa voiture\n6\nadieu joie de vivre je ne regrette rien\nadieu joie de vivre je ne regrette rien\na b c d e\nf g h i j\na b c i j\nf g h d e", "Case #1: 1\nCase #2: 4\nCase #3: 3\nCase #4: 8"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["2015", "网络流", "最大流最小割定理", "Google Code Jam"], "title": "[GCJ 2015 #2] Bilingual", "background": "", "description": "Elliot's parents speak French and English to him at home. He has heard a lot of words, but it isn't always clear to him which word comes from which language! Elliot knows one sentence that he's sure is English and one sentence that he's sure is French, and some other sentences that could be either English or French. If a word appears in an English sentence, it must be a word in English. If a word appears in a French sentence, it must be a word in French.\n\nConsidering all the sentences that Elliot has heard, what is the minimum possible number of words that he's heard that must be words in both English and French?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each starts with a single line containing an integer $\\mathbf{N}$. $\\mathbf{N}$ lines follow, each of which contains a series of space-separated \"words\". Each \"word\" is made up only of lowercase characters a-z. The first of those $\\mathbf{N}$ lines is a \"sentence\" in English, and the second is a \"sentence\" in French. The rest could be \"sentences\" in either English or French. (Note that the \"words\" and \"sentences\" are not guaranteed to be valid in any real language.)", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the minimum number of words that Elliot has heard that must be words in both English and French.", "hint": "**Sample Explanation**\n\nIn Case #1, Elliot knows for sure that the first sentence is in English and the second is in French, so there is no ambiguity; the only word that must be in both English and French is \"baguettes\".\n\nIn Case #2, the last two sentences could either be: English English, English French, French English, or French French. The second of those possibilities is the one that minimizes the number of words common to both languages; that set turns out to be d, e, i, and j.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 25$.\n- Each word will contain no more than 10 characters.\n- The two \"known\" sentences will contain no more than 1000 words each.\n- The \"unknown\" sentences will contain no more than 10 words each.\n\n**Small dataset**\n\n- Time limit: ~~240~~ 5 seconds.\n- $2 \\leq \\mathbf{N} \\leq 20$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- $2 \\leq \\mathbf{N} \\leq 200$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #2] Bilingual", "background": "", "description": "Elliot's parents speak French and English to him at home. He has heard a lot of words, but it isn't always clear to him which word comes from which language! Elliot knows one sentence that he's sure is English and one sentence that he's sure is French, and some other sentences that could be either English or French. If a word appears in an English sentence, it must be a word in English. If a word appears in a French sentence, it must be a word in French.\n\nConsidering all the sentences that Elliot has heard, what is the minimum possible number of words that he's heard that must be words in both English and French?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each starts with a single line containing an integer $\\mathbf{N}$. $\\mathbf{N}$ lines follow, each of which contains a series of space-separated \"words\". Each \"word\" is made up only of lowercase characters a-z. The first of those $\\mathbf{N}$ lines is a \"sentence\" in English, and the second is a \"sentence\" in French. The rest could be \"sentences\" in either English or French. (Note that the \"words\" and \"sentences\" are not guaranteed to be valid in any real language.)", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the minimum number of words that Elliot has heard that must be words in both English and French.", "hint": "**Sample Explanation**\n\nIn Case #1, Elliot knows for sure that the first sentence is in English and the second is in French, so there is no ambiguity; the only word that must be in both English and French is \"baguettes\".\n\nIn Case #2, the last two sentences could either be: English English, English French, French English, or French French. The second of those possibilities is the one that minimizes the number of words common to both languages; that set turns out to be d, e, i, and j.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 25$.\n- Each word will contain no more than 10 characters.\n- The two \"known\" sentences will contain no more than 1000 words each.\n- The \"unknown\" sentences will contain no more than 10 words each.\n\n**Small dataset**\n\n- Time limit: ~~240~~ 5 seconds.\n- $2 \\leq \\mathbf{N} \\leq 20$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- $2 \\leq \\mathbf{N} \\leq 200$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #2] Bilingual", "background": null, "description": "Elliot 的父母在家里用法语和英语与他交流。他听过很多单词，但并不总是清楚每个单词来自哪种语言！Elliot 确定有一句话是英语句子，有一句话是法语句子，还有一些其他句子可能是英语也可能是法语。如果一个单词出现在英语句子中，那么它一定是英语单词。如果一个单词出现在法语句子中，那么它一定是法语单词。\n\n考虑 Elliot 听过的所有句子，问他听到的单词中，最少有多少个单词必须同时属于英语和法语单词？", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行包含一个整数 $N$。接下来的 $N$ 行，每行包含若干用空格分隔的“单词”。每个“单词”仅由小写字母 a-z 组成。前 $N$ 行中的第一行是确定为英语的句子，第二行是确定为法语的句子，其余的句子可能是英语也可能是法语。（注意，这些“单词”和“句子”不保证在任何真实语言中有效。）", "outputFormat": "对于每个测试用例，输出一行，格式为 “Case #$x$: $y$”，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 Elliot 听到的必须同时属于英语和法语的单词的最小数量。", "hint": "**样例解释**\n\n在第 1 个测试用例中，Elliot 确定第一句是英语，第二句是法语，因此没有歧义；唯一必须同时属于英语和法语的单词是 “baguettes”。\n\n在第 2 个测试用例中，最后两句可以分别是：英语 英语、英语 法语、法语 英语、法语 法语。第二种分配方式可以最小化同时属于英语和法语的单词数量；最终这个集合是 d、e、i 和 j。\n\n**数据范围**\n\n- $1 \\leq T \\leq 25$。\n- 每个单词不超过 10 个字符。\n- 两个“已知”句子各包含不超过 1000 个单词。\n- “未知”句子各包含不超过 10 个单词。\n\n**小数据范围**\n\n- 时间限制：5 秒。\n- $2 \\leq N \\leq 20$。\n\n**大数据范围**\n\n- 时间限制：10 秒。\n- $2 \\leq N \\leq 200$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13227", "type": "P", "difficulty": 6, "samples": [["2\n2 4\n3 5", "Case #1: 1\nCase #2: 2"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2015", "Pólya 定理", "Google Code Jam"], "title": "[GCJ 2015 #2] Drum Decorator", "background": "", "description": "You are the drummer in the rock band Denise and the Integers. Your drum is a cylinder around which you've wrapped a rectangular grid of cells.\n\nYour band is scheduled to perform in Mathland. The Mathlanders are a tough audience, and they will expect every cell of your drum to contain a positive integer; zeroes and negative integers are not allowed. Moreover, each integer $\\mathrm{K}$ must border (share an edge, and not just a point, with) exactly $\\mathrm{K}$ other cells with the same integer -- that is, a cell with a 1 must touch exactly one other cell with a 1 , a cell with a 2 must touch exactly 2 other cells with a 2 , and so on. Apart from this restriction, it does not matter what other cells a cell touches. (The circular top and bottom of the drum do not count as cells and do not need to be decorated. Note that this means that the cells along the top and bottom of the drum only touch three other cells each, whereas all the other cells touch four other cells each.)\n\nFor example, this is a valid decoration of a cylinder formed by a grid with 3 rows and 5 columns:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/irlqdayl.png)\n\n(Imagine that the unseen two columns on the back of the drum are the same as the three visible columns.)\n\nYou want to know how many different valid decorations are possible. Two decorations are different if one cannot be rotated (around the cylinder's axis of symmetry) to produce the other. The top and bottom of a drum are considered different, so this decoration of a $3\\times 5$ grid is different from the one above:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3aiizfme.png)\n\n(Again, imagine that the unseen two columns on the back of the drum are the same as the three visible columns.)\n\nYour drum has $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. How many different valid decorations are possible? The number may be large, so return the number of decorations modulo $10^{9}+7$ ($1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow; each contains two space-separated integers, $\\mathbf{R}$ and $\\mathbf{C}$, which are the number of rows and columns in the drum.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the number of valid decorations modulo $10^{9}+7$, as described above.", "hint": "**Sample Explanation**\n\nIn Case #1, the only solution is to fill all cells with 3s.\n\nIn Case #2, the only two solutions are the two depicted in the problem statement.\n\n**Small dataset(11 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathrm{T} \\leq 20$.\n- $2 \\leq \\mathrm{R} \\leq 6$.\n- $3 \\leq \\mathrm{C} \\leq 6$.\n\n**Large dataset(10 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathrm{T} \\leq 100$.\n- $2 \\leq \\mathrm{R} \\leq 100$.\n- $3 \\leq \\mathrm{C} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #2] Drum Decorator", "background": "", "description": "You are the drummer in the rock band Denise and the Integers. Your drum is a cylinder around which you've wrapped a rectangular grid of cells.\n\nYour band is scheduled to perform in Mathland. The Mathlanders are a tough audience, and they will expect every cell of your drum to contain a positive integer; zeroes and negative integers are not allowed. Moreover, each integer $\\mathrm{K}$ must border (share an edge, and not just a point, with) exactly $\\mathrm{K}$ other cells with the same integer -- that is, a cell with a 1 must touch exactly one other cell with a 1 , a cell with a 2 must touch exactly 2 other cells with a 2 , and so on. Apart from this restriction, it does not matter what other cells a cell touches. (The circular top and bottom of the drum do not count as cells and do not need to be decorated. Note that this means that the cells along the top and bottom of the drum only touch three other cells each, whereas all the other cells touch four other cells each.)\n\nFor example, this is a valid decoration of a cylinder formed by a grid with 3 rows and 5 columns:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/irlqdayl.png)\n\n(Imagine that the unseen two columns on the back of the drum are the same as the three visible columns.)\n\nYou want to know how many different valid decorations are possible. Two decorations are different if one cannot be rotated (around the cylinder's axis of symmetry) to produce the other. The top and bottom of a drum are considered different, so this decoration of a $3\\times 5$ grid is different from the one above:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3aiizfme.png)\n\n(Again, imagine that the unseen two columns on the back of the drum are the same as the three visible columns.)\n\nYour drum has $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. How many different valid decorations are possible? The number may be large, so return the number of decorations modulo $10^{9}+7$ ($1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow; each contains two space-separated integers, $\\mathbf{R}$ and $\\mathbf{C}$, which are the number of rows and columns in the drum.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the number of valid decorations modulo $10^{9}+7$, as described above.", "hint": "**Sample Explanation**\n\nIn Case #1, the only solution is to fill all cells with 3s.\n\nIn Case #2, the only two solutions are the two depicted in the problem statement.\n\n**Small dataset(11 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathrm{T} \\leq 20$.\n- $2 \\leq \\mathrm{R} \\leq 6$.\n- $3 \\leq \\mathrm{C} \\leq 6$.\n\n**Large dataset(10 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathrm{T} \\leq 100$.\n- $2 \\leq \\mathrm{R} \\leq 100$.\n- $3 \\leq \\mathrm{C} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #2] Drum Decorator", "background": null, "description": "你是摇滚乐队 Denise and the Integers 的鼓手。你的鼓是一个圆柱体，你在鼓面上包裹了一张矩形网格。\n\n你的乐队即将在 Mathland 演出。Mathland 的观众非常挑剔，他们要求你的鼓面上的每个格子都填上正整数，不能有零或负数。此外，每个整数 $K$ 必须恰好与 $K$ 个相同整数的格子相邻（即共享一条边，而不仅仅是一个点）。也就是说，一个填了 $1$ 的格子，必须恰好与一个填了 $1$ 的格子相邻；一个填了 $2$ 的格子，必须恰好与两个填了 $2$ 的格子相邻，依此类推。除此之外，格子与其它格子的接触情况没有限制。（鼓的顶部和底部不是格子，不需要装饰。注意，这意味着鼓面最上面和最下面一行的格子每个只与三个格子相邻，而其它格子每个与四个格子相邻。）\n\n例如，下图是一个 $3$ 行 $5$ 列的圆柱鼓面的一种合法装饰方式：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/irlqdayl.png)\n\n（请想象鼓背面的两列与正面看到的三列是连续相连的。）\n\n你想知道有多少种不同的合法装饰方案。如果两个装饰无法通过绕圆柱轴旋转得到彼此，则认为它们是不同的。鼓的顶部和底部视为不同，因此下图的 $3\\times 5$ 鼓面装饰与上图不同：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3aiizfme.png)\n\n（同样，鼓背面的两列与正面三列是连续相连的。）\n\n你的鼓有 $\\mathbf{R}$ 行和 $\\mathbf{C}$ 列。请问有多少种不同的合法装饰方案？答案可能很大，请输出方案数对 $10^9+7$（$1000000007$）取模后的结果。", "inputFormat": "第一行输入测试用例数 $\\mathbf{T}$。接下来的 $\\mathbf{T}$ 行，每行包含两个用空格分隔的整数 $\\mathbf{R}$ 和 $\\mathbf{C}$，分别表示鼓面的行数和列数。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是合法装饰方案数对 $10^9+7$ 取模后的结果。", "hint": "**样例解释**\n\n对于第 1 个样例，唯一的方案是所有格子都填 $3$。\n\n对于第 2 个样例，只有题目描述中给出的两种方案。\n\n**小数据集（11 分）**\n\n- 时间限制：5 秒。\n- $1 \\leq \\mathrm{T} \\leq 20$。\n- $2 \\leq \\mathrm{R} \\leq 6$。\n- $3 \\leq \\mathrm{C} \\leq 6$。\n\n**大数据集（10 分）**\n\n- 时间限制：10 秒。\n- $1 \\leq \\mathrm{T} \\leq 100$。\n- $2 \\leq \\mathrm{R} \\leq 100$。\n- $3 \\leq \\mathrm{C} \\leq 100$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13228", "type": "P", "difficulty": 4, "samples": [["3\n1 395\n18 246 615815 60\n73 228 14618 195\n6 5\n10 1 3 17\n5 2 7 19\n10 13\n28 931 601463 36\n231 539 556432 258", "Case #1: 1\nCase #2: 3\nCase #3: 5"]], "limits": {"time": [5000, 20000], "memory": [1048576, 1048576]}, "tags": ["2015", "深度优先搜索 DFS", "树形 DP", "树的遍历", "差分", "Google Code Jam"], "title": "[GCJ 2015 #3] Fairland", "background": "", "description": "The country of Fairland has very strict laws governing how companies organize and pay their employees:\n\n1. Each company must have exactly one CEO, who has no manager.\n2. Every employee except for the CEO must have exactly one manager. (This means that the org chart showing all of the employees in a company is a tree, without cycles.)\n3. As long as an employee is working for the company, their manager must never change. This means that if a manager leaves, then all of the employees reporting to that manager must also leave.\n4. The CEO must never leave the company.\n5. Every employee receives a salary -- some amount of Fairland dollars per year. An employee's salary must never change.\n6. Different employees may have different salaries, and an employee's salary is not necessarily correlated with where in the org chart that employee is.\n\nThe government of Fairland has just passed one additional law:\n\n7. The difference between the largest salary and the smallest salary in the whole company must be at most $\\mathbf{D}$ Fairland dollars.\n\nMarie is the CEO of the Fairland General Stuff Corporation, and she has to ensure that her company complies with the new law. This may require laying off some employees. She has the list of the company's employees, their managers, and their salaries. What is the largest number of employees she can keep, including herself?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line containing two space-separated integers $\\mathbf{N}$ (the number of employees) and $\\mathbf{D}$ (the maximum allowed salary difference). This is followed by one line with four space-separated integers $\\left(\\mathbf{S}_{0}, \\mathbf{A}_{\\mathrm{S}}, \\mathbf{C}_{\\mathrm{S}}, \\mathbf{R}_{\\mathrm{S}}\\right)$ and then another line with four more space-separated integers $\\left(\\mathbf{M}_{0}, \\mathbf{A}_{\\mathrm{m}}, \\mathbf{C}_{\\mathrm{m}}\\right.$ and $\\left.\\mathbf{R}_{\\mathrm{m}}\\right)$. These last eight integers define the following sequences:\n\n* $\\mathbf{S}_{\\mathrm{i}+1}=\\left(\\mathbf{S}_{\\mathrm{i}}\\times \\mathbf{A}_{\\mathrm{S}}+\\mathbf{C}_{\\mathrm{S}}\\right) \\bmod \\mathbf{R}_{\\mathrm{S}}$\n* $\\mathbf{M}_{\\mathrm{i}+1}=\\left(\\mathbf{M}_{\\mathrm{i}}\\times \\mathbf{A}_{\\mathrm{m}}+\\mathbf{C}_{\\mathrm{m}}\\right) \\bmod \\mathbf{R}_{\\mathrm{m}}$\n\nMarie's employee ID is 0, and all other employees have IDs from 1 to $\\mathbf{N}-1$, inclusive. The salary of employee $\\mathrm{i}$ is $\\mathbf{S}_{\\mathrm{i}}$. For every employee $\\mathrm{i}$ other than Marie, the manager is $\\mathbf{M}_{\\mathrm{i}} \\bmod \\mathrm{i}$. (Note that this means that $\\mathbf{M}_{0}$ does not affect Marie's manager -- she has none!)\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the largest number of employees Marie can keep at the company, including herself, such that all of laws 1-7 are obeyed.", "hint": "**Sample Explanation**\n\nIn Case #1, the company has only a CEO and no other employees, but it does not violate any of the laws, so no changes need to be made.\n\nHere is the org chart for Case #2:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9h2ae4xp.png)\n\nThe optimal strategy is to save employees $0,1,$ and $5$ (who have salaries of $10,13,$ and $8$, respectively). It is not possible to save employee $2$, for example, because her salary is more than $5$ away from employee 0's salary of $10$; since employee 0 cannot be laid off, employee $2$ must be laid off (along with all employees who report to her).\n\nIf you want to check your sequences for employees 1 through 5, they are:\n\n- $\\mathbf{S}: 13,16,2,5,8$\n- $\\mathbf{M}: 17,3,13,14,16$\n- Manager numbers: $17 \\bmod 1=0,3 \\bmod 2=1,13 \\bmod 3=1,14 \\bmod 4=2,16 \\bmod 5=1$\n\n**Limits**\n\n- $1 \\leq \\mathrm{T} \\leq 100 .$\n- $0 \\leq \\mathrm{S}_{0}<\\mathrm{R}_{\\mathrm{S}} .$\n- $0 \\leq \\mathrm{M}_{0}<\\mathrm{R}_{\\mathrm{m}} .$\n- $0 \\leq \\mathrm{A}_{\\mathrm{S}}, \\mathrm{A}_{\\mathrm{m}} \\leq 1000 .$\n- $0 \\leq \\mathrm{C}_{\\mathrm{S}}, \\mathrm{C}_{\\mathrm{m}} \\leq 10^{9} .$\n\n**Small dataset**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathrm{N} \\leq 1000 .$\n- $1 \\leq \\mathrm{D} \\leq 1000 .$\n- $1 \\leq \\mathrm{R}_{\\mathrm{S}}, \\mathrm{R}_{\\mathrm{m}} \\leq 1000 .$\n\n**Large dataset**\n\n- Time limit: ~~480~~ 20 seconds.\n- $1 \\leq \\mathrm{N} \\leq 10^{6} .$\n- $1 \\leq \\mathrm{D} \\leq 10^{6} .$\n- $1 \\leq \\mathrm{R}_{\\mathrm{S}}, \\mathrm{R}_{\\mathrm{m}} \\leq 10^{6} .$", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #3] Fairland", "background": "", "description": "The country of Fairland has very strict laws governing how companies organize and pay their employees:\n\n1. Each company must have exactly one CEO, who has no manager.\n2. Every employee except for the CEO must have exactly one manager. (This means that the org chart showing all of the employees in a company is a tree, without cycles.)\n3. As long as an employee is working for the company, their manager must never change. This means that if a manager leaves, then all of the employees reporting to that manager must also leave.\n4. The CEO must never leave the company.\n5. Every employee receives a salary -- some amount of Fairland dollars per year. An employee's salary must never change.\n6. Different employees may have different salaries, and an employee's salary is not necessarily correlated with where in the org chart that employee is.\n\nThe government of Fairland has just passed one additional law:\n\n7. The difference between the largest salary and the smallest salary in the whole company must be at most $\\mathbf{D}$ Fairland dollars.\n\nMarie is the CEO of the Fairland General Stuff Corporation, and she has to ensure that her company complies with the new law. This may require laying off some employees. She has the list of the company's employees, their managers, and their salaries. What is the largest number of employees she can keep, including herself?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line containing two space-separated integers $\\mathbf{N}$ (the number of employees) and $\\mathbf{D}$ (the maximum allowed salary difference). This is followed by one line with four space-separated integers $\\left(\\mathbf{S}_{0}, \\mathbf{A}_{\\mathrm{S}}, \\mathbf{C}_{\\mathrm{S}}, \\mathbf{R}_{\\mathrm{S}}\\right)$ and then another line with four more space-separated integers $\\left(\\mathbf{M}_{0}, \\mathbf{A}_{\\mathrm{m}}, \\mathbf{C}_{\\mathrm{m}}\\right.$ and $\\left.\\mathbf{R}_{\\mathrm{m}}\\right)$. These last eight integers define the following sequences:\n\n* $\\mathbf{S}_{\\mathrm{i}+1}=\\left(\\mathbf{S}_{\\mathrm{i}}\\times \\mathbf{A}_{\\mathrm{S}}+\\mathbf{C}_{\\mathrm{S}}\\right) \\bmod \\mathbf{R}_{\\mathrm{S}}$\n* $\\mathbf{M}_{\\mathrm{i}+1}=\\left(\\mathbf{M}_{\\mathrm{i}}\\times \\mathbf{A}_{\\mathrm{m}}+\\mathbf{C}_{\\mathrm{m}}\\right) \\bmod \\mathbf{R}_{\\mathrm{m}}$\n\nMarie's employee ID is 0, and all other employees have IDs from 1 to $\\mathbf{N}-1$, inclusive. The salary of employee $\\mathrm{i}$ is $\\mathbf{S}_{\\mathrm{i}}$. For every employee $\\mathrm{i}$ other than Marie, the manager is $\\mathbf{M}_{\\mathrm{i}} \\bmod \\mathrm{i}$. (Note that this means that $\\mathbf{M}_{0}$ does not affect Marie's manager -- she has none!)\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the largest number of employees Marie can keep at the company, including herself, such that all of laws 1-7 are obeyed.", "hint": "**Sample Explanation**\n\nIn Case #1, the company has only a CEO and no other employees, but it does not violate any of the laws, so no changes need to be made.\n\nHere is the org chart for Case #2:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9h2ae4xp.png)\n\nThe optimal strategy is to save employees $0,1,$ and $5$ (who have salaries of $10,13,$ and $8$, respectively). It is not possible to save employee $2$, for example, because her salary is more than $5$ away from employee 0's salary of $10$; since employee 0 cannot be laid off, employee $2$ must be laid off (along with all employees who report to her).\n\nIf you want to check your sequences for employees 1 through 5, they are:\n\n- $\\mathbf{S}: 13,16,2,5,8$\n- $\\mathbf{M}: 17,3,13,14,16$\n- Manager numbers: $17 \\bmod 1=0,3 \\bmod 2=1,13 \\bmod 3=1,14 \\bmod 4=2,16 \\bmod 5=1$\n\n**Limits**\n\n- $1 \\leq \\mathrm{T} \\leq 100 .$\n- $0 \\leq \\mathrm{S}_{0}<\\mathrm{R}_{\\mathrm{S}} .$\n- $0 \\leq \\mathrm{M}_{0}<\\mathrm{R}_{\\mathrm{m}} .$\n- $0 \\leq \\mathrm{A}_{\\mathrm{S}}, \\mathrm{A}_{\\mathrm{m}} \\leq 1000 .$\n- $0 \\leq \\mathrm{C}_{\\mathrm{S}}, \\mathrm{C}_{\\mathrm{m}} \\leq 10^{9} .$\n\n**Small dataset**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathrm{N} \\leq 1000 .$\n- $1 \\leq \\mathrm{D} \\leq 1000 .$\n- $1 \\leq \\mathrm{R}_{\\mathrm{S}}, \\mathrm{R}_{\\mathrm{m}} \\leq 1000 .$\n\n**Large dataset**\n\n- Time limit: ~~480~~ 20 seconds.\n- $1 \\leq \\mathrm{N} \\leq 10^{6} .$\n- $1 \\leq \\mathrm{D} \\leq 10^{6} .$\n- $1 \\leq \\mathrm{R}_{\\mathrm{S}}, \\mathrm{R}_{\\mathrm{m}} \\leq 10^{6} .$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #3] Fairland", "background": null, "description": "Fairland 国有非常严格的法律来规范公司如何组织和支付员工工资：\n\n1. 每家公司必须有且仅有一名 CEO，且 CEO 没有上级。\n2. 除 CEO 外，每位员工必须有且仅有一名上级。（这意味着公司的组织结构图是一棵树，没有环。）\n3. 只要员工在公司工作，其上级不得更换。这意味着如果一名上级离开，则所有直接下属也必须离开。\n4. CEO 绝不能离开公司。\n5. 每位员工都有一份工资——每年一定数额的 Fairland 元。员工的工资不得更改。\n6. 不同员工的工资可以不同，且员工的工资与其在组织结构中的位置不一定相关。\n\nFairland 政府刚刚通过了一项新法律：\n\n7. 公司内最高工资与最低工资的差额不得超过 $\\mathbf{D}$ Fairland 元。\n\nMarie 是 Fairland General Stuff Corporation 的 CEO，她必须确保公司遵守新法律。这可能需要裁员。她有公司员工名单、各自的上级以及工资信息。请问她最多能保留多少名员工（包括她自己），使得公司仍然符合所有法律规定？", "inputFormat": "输入的第一行为测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据。每组测试数据的第一行为两个用空格分隔的整数 $\\mathbf{N}$（员工总数）和 $\\mathbf{D}$（允许的最大工资差）。接下来一行包含四个用空格分隔的整数 $\\left(\\mathbf{S}_{0}, \\mathbf{A}_{\\mathrm{S}}, \\mathbf{C}_{\\mathrm{S}}, \\mathbf{R}_{\\mathrm{S}}\\right)$，再下一行包含四个用空格分隔的整数 $\\left(\\mathbf{M}_{0}, \\mathbf{A}_{\\mathrm{m}}, \\mathbf{C}_{\\mathrm{m}}, \\mathbf{R}_{\\mathrm{m}}\\right)$。这八个整数定义了如下序列：\n\n- $\\mathbf{S}_{\\mathrm{i}+1} = \\left(\\mathbf{S}_{\\mathrm{i}} \\times \\mathbf{A}_{\\mathrm{S}} + \\mathbf{C}_{\\mathrm{S}}\\right) \\bmod \\mathbf{R}_{\\mathrm{S}}$\n- $\\mathbf{M}_{\\mathrm{i}+1} = \\left(\\mathbf{M}_{\\mathrm{i}} \\times \\mathbf{A}_{\\mathrm{m}} + \\mathbf{C}_{\\mathrm{m}}\\right) \\bmod \\mathbf{R}_{\\mathrm{m}}$\n\nMarie 的员工编号为 0，其余员工编号为 $1$ 到 $N-1$。第 $i$ 位员工的工资为 $\\mathbf{S}_i$。对于 Marie 以外的每位员工 $i$，其上级编号为 $\\mathbf{M}_i \\bmod i$。（注意 $\\mathbf{M}_0$ 不影响 Marie 的上级——她没有上级！）", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #x: y\"，其中 $x$ 为测试编号（从 1 开始），$y$ 为 Marie 能够保留的最大员工数（包括她自己），使得所有法律 1-7 均被遵守。", "hint": "**样例解释**\n\n第 1 组数据中，公司只有 CEO 一人，没有其他员工，不违反任何法律，无需做出改变。\n\n第 2 组数据的组织结构如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9h2ae4xp.png)\n\n最优策略是保留员工 $0,1,5$（工资分别为 $10,13,8$）。例如，无法保留员工 $2$，因为她的工资与员工 0 的工资 $10$ 相差超过 $5$；由于员工 0 不能被裁员，员工 2 必须被裁掉（以及所有直属于她的员工）。\n\n如果你想检查 1 到 5 号员工的序列如下：\n\n- $\\mathbf{S}$：$13,16,2,5,8$\n- $\\mathbf{M}$：$17,3,13,14,16$\n- 上级编号：$17 \\bmod 1=0, 3 \\bmod 2=1, 13 \\bmod 3=1, 14 \\bmod 4=2, 16 \\bmod 5=1$\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $0 \\leq S_0 < R_S$。\n- $0 \\leq M_0 < R_m$。\n- $0 \\leq A_S, A_m \\leq 1000$。\n- $0 \\leq C_S, C_m \\leq 10^9$。\n\n**小数据范围**\n\n- 时间限制：5 秒。\n- $1 \\leq N \\leq 1000$。\n- $1 \\leq D \\leq 1000$。\n- $1 \\leq R_S, R_m \\leq 1000$。\n\n**大数据范围**\n\n- 时间限制：20 秒。\n- $1 \\leq N \\leq 10^6$。\n- $1 \\leq D \\leq 10^6$。\n- $1 \\leq R_S, R_m \\leq 10^6$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13229", "type": "P", "difficulty": 5, "samples": [["3\n10 2\n1 2 3 4 5 6 7 8 9\n100 100\n-100\n7 3\n0 12 0 12 0", "Case #1: 5\nCase #2: 0\nCase #3: 12"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2015", "差分", "Google Code Jam"], "title": "[GCJ 2015 #3] Smoothing Window", "background": "", "description": "Adamma is a climate scientist interested in temperature. Every minute, she records the current temperature as an integer, creating a long list of integers: $x_{1}, x_{2}, \\ldots, x_{\\mathrm{N}}$. (Adamma uses her own special temperature scale rather than a familiar one like Celsius or Kelvin, so it's possible for the values to be large and negative!) She often plots these temperatures on her computer screen.\n\nThis morning, she decided to compute a sliding average of this list in order to get a smoother plot. She used a smoothing window of size $\\mathbf{K}$, which means that she converted the sequence of $\\mathbf{N}$ temperatures into a sequence of $(\\mathbf{N}-\\mathbf{K}+1)$ average temperatures: $s_{1}, s_{2}, \\ldots, s_{\\mathbf{N}-\\mathbf{K}+1}$. Each $s_{i}$ is the average of the values $x_{i}, x_{i+1}, \\ldots, x_{i+\\mathbf{K}-1}$. The original $x_{i}$ values were all integers, but some of the $s_{i}$ may be fractional.\n\nUnfortunately, Adamma forgot to save the original sequence of temperatures! And now she wants to answer a different question -- what was the difference between the largest temperature and the smallest temperature? In other words, she needs to compute $\\max \\left\\{x_{1}, \\ldots, x_{\\mathrm{N}}\\right\\}-\\min \\left\\{x_{1}, \\ldots, x_{\\mathrm{N}}\\right\\}$. But she only has $\\mathrm{N}, \\mathrm{K}$, and the smoothed sequence.\n\nAfter some thinking, Adamma has realized that this might be impossible because there may be several valid answers. In that case, she wants to know the smallest possible answer among all of the possible original sequences that could have produced her smoothed sequence with the given values of $\\mathrm{N}$ and $\\mathrm{K}$.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow; each test case consists of two lines. The first line contains integers $\\mathrm{N}$ and $\\mathbf{K}$ separated by a space character. The second line contains integer values $\\operatorname{sum}_{1}, \\operatorname{sum}_{2}, \\ldots, \\operatorname{sum}_{\\mathrm{N}-\\mathbf{K}+1}$, separated by space characters. $s_{i}$ is given by $\\operatorname{sum}_{i} / \\mathbf{K}$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the smallest possible difference between the largest and smallest temperature.", "hint": "**Sample Explanation**\n\nIn Case #1, the smoothed sequence is:\n\n$$0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5$$\n\nThe integer sequence that gives the smallest difference is:\n\n$$0, 1, 1, 2, 2, 3, 3, 4, 4, 5$$\n\nNote that the sequence:\n\n$$0.5, 0.5, 1.5, 1.5, 2.5, 2.5, 3.5, 3.5, 4.5, 4.5$$\n\nWould give the same smoothed sequence with a maximum difference of $4$, but this is not a valid answer because the original temperatures are known to have been integers.\n\nIn Case #2, all we know is that the sum of the $100$ original values was $-100$. It's possible that all of the original values were exactly $-1$, in which case the difference between the largest and smallest temperatures would be $0$, which is as small as differences get!\n\nIn Case #3, the original sequence could have been:\n\n$$-4, 8, -4, 8, -4, 8, -4$$\n\n**Sample Explanation**\n\n- $1 \\leq \\mathrm{T} \\leq 100 .$\n- $2 \\leq \\mathbf{K} \\leq \\mathrm{N} .$\n- The $\\operatorname{sum}_{i}$ will be integers between -10000 and 10000, inclusive.\n\n**Small dataset(6 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $2 \\leq \\mathrm{N} \\leq 100 .$\n\n**Large dataset(7 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $2 \\leq \\mathrm{N} \\leq 1000 .$\n- $2 \\leq \\mathbf{K} \\leq 100 .$", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #3] Smoothing Window", "background": "", "description": "Adamma is a climate scientist interested in temperature. Every minute, she records the current temperature as an integer, creating a long list of integers: $x_{1}, x_{2}, \\ldots, x_{\\mathrm{N}}$. (Adamma uses her own special temperature scale rather than a familiar one like Celsius or Kelvin, so it's possible for the values to be large and negative!) She often plots these temperatures on her computer screen.\n\nThis morning, she decided to compute a sliding average of this list in order to get a smoother plot. She used a smoothing window of size $\\mathbf{K}$, which means that she converted the sequence of $\\mathbf{N}$ temperatures into a sequence of $(\\mathbf{N}-\\mathbf{K}+1)$ average temperatures: $s_{1}, s_{2}, \\ldots, s_{\\mathbf{N}-\\mathbf{K}+1}$. Each $s_{i}$ is the average of the values $x_{i}, x_{i+1}, \\ldots, x_{i+\\mathbf{K}-1}$. The original $x_{i}$ values were all integers, but some of the $s_{i}$ may be fractional.\n\nUnfortunately, Adamma forgot to save the original sequence of temperatures! And now she wants to answer a different question -- what was the difference between the largest temperature and the smallest temperature? In other words, she needs to compute $\\max \\left\\{x_{1}, \\ldots, x_{\\mathrm{N}}\\right\\}-\\min \\left\\{x_{1}, \\ldots, x_{\\mathrm{N}}\\right\\}$. But she only has $\\mathrm{N}, \\mathrm{K}$, and the smoothed sequence.\n\nAfter some thinking, Adamma has realized that this might be impossible because there may be several valid answers. In that case, she wants to know the smallest possible answer among all of the possible original sequences that could have produced her smoothed sequence with the given values of $\\mathrm{N}$ and $\\mathrm{K}$.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow; each test case consists of two lines. The first line contains integers $\\mathrm{N}$ and $\\mathbf{K}$ separated by a space character. The second line contains integer values $\\operatorname{sum}_{1}, \\operatorname{sum}_{2}, \\ldots, \\operatorname{sum}_{\\mathrm{N}-\\mathbf{K}+1}$, separated by space characters. $s_{i}$ is given by $\\operatorname{sum}_{i} / \\mathbf{K}$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the smallest possible difference between the largest and smallest temperature.", "hint": "**Sample Explanation**\n\nIn Case #1, the smoothed sequence is:\n\n$$0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5$$\n\nThe integer sequence that gives the smallest difference is:\n\n$$0, 1, 1, 2, 2, 3, 3, 4, 4, 5$$\n\nNote that the sequence:\n\n$$0.5, 0.5, 1.5, 1.5, 2.5, 2.5, 3.5, 3.5, 4.5, 4.5$$\n\nWould give the same smoothed sequence with a maximum difference of $4$, but this is not a valid answer because the original temperatures are known to have been integers.\n\nIn Case #2, all we know is that the sum of the $100$ original values was $-100$. It's possible that all of the original values were exactly $-1$, in which case the difference between the largest and smallest temperatures would be $0$, which is as small as differences get!\n\nIn Case #3, the original sequence could have been:\n\n$$-4, 8, -4, 8, -4, 8, -4$$\n\n**Sample Explanation**\n\n- $1 \\leq \\mathrm{T} \\leq 100 .$\n- $2 \\leq \\mathbf{K} \\leq \\mathrm{N} .$\n- The $\\operatorname{sum}_{i}$ will be integers between -10000 and 10000, inclusive.\n\n**Small dataset(6 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $2 \\leq \\mathrm{N} \\leq 100 .$\n\n**Large dataset(7 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $2 \\leq \\mathrm{N} \\leq 1000 .$\n- $2 \\leq \\mathbf{K} \\leq 100 .$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #3] Smoothing Window", "background": null, "description": "Adamma 是一位对温度感兴趣的气候科学家。她每分钟记录一次当前温度，得到一个整数序列：$x_{1}, x_{2}, \\ldots, x_{\\mathrm{N}}$。（Adamma 使用自己特殊的温标，而不是常见的摄氏度或开尔文，因此这些值可能很大也可能为负数！）她经常把这些温度绘制在电脑屏幕上。\n\n今天早上，她决定计算这个序列的滑动平均值，以获得更平滑的曲线。她使用了大小为 $\\mathbf{K}$ 的平滑窗口，这意味着她将 $\\mathbf{N}$ 个温度值转换为 $(\\mathbf{N}-\\mathbf{K}+1)$ 个平均温度值：$s_{1}, s_{2}, \\ldots, s_{\\mathbf{N}-\\mathbf{K}+1}$。每个 $s_{i}$ 是 $x_{i}, x_{i+1}, \\ldots, x_{i+\\mathbf{K}-1}$ 的平均值。原始的 $x_{i}$ 都是整数，但 $s_{i}$ 可能是小数。\n\n不幸的是，Adamma 忘记保存原始的温度序列了！现在她想要回答另一个问题——原始序列中最大温度和最小温度的差是多少？换句话说，她需要计算 $\\max \\left\\{x_{1}, \\ldots, x_{\\mathrm{N}}\\right\\}-\\min \\left\\{x_{1}, \\ldots, x_{\\mathrm{N}}\\right\\}$。但她手头只有 $\\mathrm{N}$、$\\mathrm{K}$ 和平滑后的序列。\n\n经过一番思考，Adamma 意识到这可能无法唯一确定，因为可能有多种原始序列都能产生相同的平滑序列。在这种情况下，她想知道所有可能的原始序列中，最大温度和最小温度的差的最小值是多少。", "inputFormat": "输入的第一行为测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试用例，每组测试用例包含两行。第一行包含两个整数 $\\mathrm{N}$ 和 $\\mathbf{K}$，用空格分隔。第二行包含整数 $\\operatorname{sum}_{1}, \\operatorname{sum}_{2}, \\ldots, \\operatorname{sum}_{\\mathrm{N}-\\mathbf{K}+1}$，用空格分隔。$s_{i}$ 由 $\\operatorname{sum}_{i} / \\mathbf{K}$ 给出。", "outputFormat": "对于每组测试用例，输出一行，格式为 \"Case #x: y\"，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为最大温度和最小温度的最小可能差值。", "hint": "**样例解释**\n\n在第 1 组测试用例中，平滑后的序列为：\n\n$$0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5$$\n\n能够得到最小差值的整数序列为：\n\n$$0, 1, 1, 2, 2, 3, 3, 4, 4, 5$$\n\n注意，序列：\n\n$$0.5, 0.5, 1.5, 1.5, 2.5, 2.5, 3.5, 3.5, 4.5, 4.5$$\n\n虽然也能得到相同的平滑序列且最大差值为 $4$，但这不是有效答案，因为原始温度必须为整数。\n\n在第 2 组测试用例中，我们只知道 $100$ 个原始值的和为 $-100$。所有原始值都为 $-1$ 也是可能的，此时最大最小差为 $0$，这是最小可能的差值。\n\n在第 3 组测试用例中，原始序列可能为：\n\n$$-4, 8, -4, 8, -4, 8, -4$$\n\n**数据范围**\n\n- $1 \\leq \\mathrm{T} \\leq 100$。\n- $2 \\leq \\mathbf{K} \\leq \\mathrm{N}$。\n- $\\operatorname{sum}_{i}$ 为 $-10000$ 到 $10000$ 之间的整数。\n\n**小数据范围（6 分）**\n\n- 时间限制：5 秒。\n- $2 \\leq \\mathrm{N} \\leq 100$。\n\n**大数据范围（7 分）**\n\n- 时间限制：10 秒。\n- $2 \\leq \\mathrm{N} \\leq 1000$。\n- $2 \\leq \\mathbf{K} \\leq 100$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13230", "type": "P", "difficulty": 6, "samples": [["2\n4 3\n-3 -6 -9\n3 2 1\n2 2\n1 -1\n1 1", "Case #1: 3.000000\nCase #2: 5.000000"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2015", "Special Judge", "Google Code Jam"], "title": "[GCJ 2015 #3] Runaway Quail", "background": "", "description": "Oh no -- your $\\mathrm{N}$ pet quail have all gotten loose! You are currently at position 0 on a line; the $\\mathrm{i}$ th quail starts off at some nonzero integer (positive or negative) position $\\mathbf{P}_{\\mathrm{i}}$ on that line, in meters, and will continuously run away from you at a constant integer speed of $\\mathbf{S}_{\\mathrm{i}}$ meters per second. You can run at a constant integer speed of $\\mathrm{Y}$ meters per second, and can change direction instantaneously whenever you want. Note that quail constantly run away from you even if you are not running toward them at the time. Whenever you occupy the same point as a quail, that quail is caught (this takes no additional time).\n\nWhat is the minimum number of seconds it will take you to catch all of the quail?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with two space-separated integers $\\mathrm{Y}$, your speed, and $\\mathrm{N}$, the number of quail, and is followed by two more lines with $\\mathrm{N}$ space-separated integers each. The first of these gives the positions $\\mathbf{P}_{\\mathrm{i}}$ of the quail, and the second gives the speeds $\\mathbf{S}_{\\mathrm{i}}$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the minimum number of seconds needed to catch all the quail.\n\n$\\mathrm{y}$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn Case #1, you can run to the left and catch all three quail at the same time, 12 meters to the left of the starting position, which takes 3 seconds.\n\nIn Case #2, one optimal strategy is to run to the left until the second quail is caught at $-2$ m, which takes one second, and then run to the right in pursuit of the first quail, which you will catch at 6 m, taking four more seconds.\n\n**Limits**\n\n- $1 \\leq \\mathrm{T} \\leq 100 .$\n- $2 \\leq \\mathrm{Y} \\leq 1000 .$\n- $-10^{7} \\leq \\mathrm{P}_{\\mathrm{i}} \\leq 10^{7}$; no $\\mathrm{P}_{\\mathrm{i}}$ is 0 .\n- $1 \\leq \\mathrm{S}_{\\mathrm{i}}<\\mathrm{Y} .$\n\n**Small dataset(8 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathrm{N} \\leq 25 .$\n\n**Large dataset(15 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathrm{N} \\leq 500 .$", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #3] Runaway Quail", "background": "", "description": "Oh no -- your $\\mathrm{N}$ pet quail have all gotten loose! You are currently at position 0 on a line; the $\\mathrm{i}$ th quail starts off at some nonzero integer (positive or negative) position $\\mathbf{P}_{\\mathrm{i}}$ on that line, in meters, and will continuously run away from you at a constant integer speed of $\\mathbf{S}_{\\mathrm{i}}$ meters per second. You can run at a constant integer speed of $\\mathrm{Y}$ meters per second, and can change direction instantaneously whenever you want. Note that quail constantly run away from you even if you are not running toward them at the time. Whenever you occupy the same point as a quail, that quail is caught (this takes no additional time).\n\nWhat is the minimum number of seconds it will take you to catch all of the quail?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with two space-separated integers $\\mathrm{Y}$, your speed, and $\\mathrm{N}$, the number of quail, and is followed by two more lines with $\\mathrm{N}$ space-separated integers each. The first of these gives the positions $\\mathbf{P}_{\\mathrm{i}}$ of the quail, and the second gives the speeds $\\mathbf{S}_{\\mathrm{i}}$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the minimum number of seconds needed to catch all the quail.\n\n$\\mathrm{y}$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn Case #1, you can run to the left and catch all three quail at the same time, 12 meters to the left of the starting position, which takes 3 seconds.\n\nIn Case #2, one optimal strategy is to run to the left until the second quail is caught at $-2$ m, which takes one second, and then run to the right in pursuit of the first quail, which you will catch at 6 m, taking four more seconds.\n\n**Limits**\n\n- $1 \\leq \\mathrm{T} \\leq 100 .$\n- $2 \\leq \\mathrm{Y} \\leq 1000 .$\n- $-10^{7} \\leq \\mathrm{P}_{\\mathrm{i}} \\leq 10^{7}$; no $\\mathrm{P}_{\\mathrm{i}}$ is 0 .\n- $1 \\leq \\mathrm{S}_{\\mathrm{i}}<\\mathrm{Y} .$\n\n**Small dataset(8 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathrm{N} \\leq 25 .$\n\n**Large dataset(15 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathrm{N} \\leq 500 .$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #3] Runaway Quail", "background": null, "description": "哦不——你的 $N$ 只鹌鹑全都跑掉了！你现在位于一条直线上的 $0$ 位置；第 $i$ 只鹌鹑一开始在该直线上的某个非零整数位置 $P_i$（可以为正也可以为负，单位为米），并且会以恒定的整数速度 $S_i$ 米每秒不断地远离你奔跑。你可以以恒定的整数速度 $Y$ 米每秒奔跑，并且可以随时瞬间改变方向。注意，即使你没有朝着某只鹌鹑奔跑，鹌鹑也会一直远离你。当你和某只鹌鹑处于同一位置时，你就能抓住它（不需要额外时间）。\n\n你需要用最少多少秒才能抓住所有的鹌鹑？", "inputFormat": "输入的第一行是测试用例的数量 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为两个用空格分隔的整数 $Y$（你的速度）和 $N$（鹌鹑的数量），接下来两行各有 $N$ 个用空格分隔的整数。第一行为各只鹌鹑的初始位置 $P_i$，第二行为各只鹌鹑的速度 $S_i$。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #x: y\"，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为抓住所有鹌鹑所需的最少秒数。\n\n如果你的答案 $y$ 与正确答案的绝对误差或相对误差不超过 $10^{-6}$，则视为正确。", "hint": "**样例解释**\n\n在第 1 组样例中，你可以向左跑，在距离起点左侧 12 米处同时抓住三只鹌鹑，用时 3 秒。\n\n在第 2 组样例中，一种最优策略是先向左跑，1 秒后在 $-2$ 米处抓住第二只鹌鹑，然后掉头向右追第一只鹌鹑，在 6 米处抓住它，总共用时 4 秒。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq Y \\leq 1000$。\n- $-10^7 \\leq P_i \\leq 10^7$，且所有 $P_i$ 均不为 0。\n- $1 \\leq S_i < Y$。\n\n**小数据集（8 分）**\n\n- 时间限制：5 秒。\n- $1 \\leq N \\leq 25$。\n\n**大数据集（15 分）**\n\n- 时间限制：10 秒。\n- $1 \\leq N \\leq 500$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13231", "type": "P", "difficulty": 5, "samples": [["5\n8\n0 1 2 3 4 5 6 7\n1 1 1 1 1 1 1 1\n4\n0 1 2 3\n1 3 3 1\n4\n0 1 3 4\n4 4 4 4\n3\n-1 0 1\n1 2 1\n5\n-2 -1 0 1 2\n1 2 2 2 1", "Case #1: 1 2 4\nCase #2: 1 1 1\nCase #3: 0 0 1 3\nCase #4: -1 1\nCase #5: -2 1 1"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2015", "Google Code Jam"], "title": "[GCJ 2015 #3] Log Set", "background": "", "description": "The power set of a set $\\mathrm{S}$ is the set of all subsets of $\\mathrm{S}$ (including the empty set and $\\mathrm{S}$ itself). It's easy to go from a set to a power set, but in this problem, we'll go in the other direction!\n\nWe've started with a set of (not necessarily unique) integers $\\mathrm{S}$, found its power set, and then replaced every element in the power set with the sum of elements of that element, forming a new set $\\mathrm{S}^{\\prime}$. For example, if $\\mathrm{S}=\\{-1,1\\}$, then the power set of $\\mathrm{S}$ is $\\{\\{\\},\\{-1\\},\\{1\\},\\{-1,1\\}\\}$, and so $\\mathrm{S}^{\\prime}=\\{0,-1,1,0\\}$. $\\mathrm{S}^{\\prime}$ is allowed to contain duplicates, so if $\\mathrm{S}$ has $\\mathrm{N}$ elements, then $\\mathrm{S}^{\\prime}$ always has exactly $2^{\\mathrm{N}}$ elements.\n\nGiven a description of the elements in $\\mathrm{S}^{\\prime}$ and their frequencies, can you determine our original $\\mathrm{S}$ ? It is guaranteed that $\\mathrm{S}$ exists. If there are multiple possible sets $\\mathrm{S}$ that could have produced $\\mathrm{S}^{\\prime}$, we guarantee that our original set $\\mathrm{S}$ was the earliest one of those possibilities. To determine whether a set $\\mathrm{S}_{1}$ is earlier than a different set $\\mathrm{S}_{2}$ of the same length, sort each set into nondecreasing order and then examine the leftmost position at which the sets differ. $\\mathrm{S}_{1}$ is earlier iff the element at that position in $\\mathrm{S}_{1}$ is smaller than the element at that position in $\\mathrm{S}_{2}$.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each consists of one line with an integer $\\mathrm{P}$, followed by two more lines, each of which has $\\mathrm{P}$ space-separated integers. The first of those lines will have all of the different elements $\\mathrm{E}_{1}, \\mathrm{E}_{2}, \\ldots, \\mathrm{E}_{\\mathrm{P}}$ that appear in $\\mathrm{S}^{\\prime}$, sorted in ascending order. The second of those lines will have the number of times $\\mathrm{F}_{1}, \\mathrm{~F}_{2}, \\ldots, \\mathrm{F}_{\\mathrm{P}}$ that each of those values appears in $\\mathrm{S}^{\\prime}$. That is, for any $\\mathrm{i}$, the element $\\mathrm{E}_{\\mathrm{i}}$ appears $\\mathrm{F}_{\\mathrm{i}}$ times in $\\mathrm{S}^{\\prime}$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: \", where $\\mathrm{x}$ is the test case number (starting from 1), followed by the elements of our original set $\\mathrm{S}$, separated by spaces, in nondecreasing order. (You will be listing the elements of $\\mathrm{S}$ directly, and not providing two lists of elements and frequencies as we do for $\\mathrm{S}^{\\prime}$.)", "hint": "**Sample Explanation**\n\nNote that Cases #4 and #5 are not within the limits for the Small dataset.\n\nIn Case #4, $\\mathrm{S}=\\{-1,1\\}$ is the only possible set that satisfies the conditions. (Its subsets are $\\{\\},\\{-1\\},\\{1\\}$, and $\\{-1,1\\}$. Those have sums $0, -1, 1$, and $0$, respectively, so $\\mathrm{S}^{\\prime}$ has one copy of $-1$, two copies of $0$, and one copy of $1$, which matches the specifications in the input.)\n\nFor Case #5, note that $\\mathrm{S}=\\{-1,-1,2\\}$ also produces the same $\\mathrm{S}^{\\prime}=\\{-2,-1,-1,0,0,1,1,2\\}$, but $\\mathrm{S}=\\{-2,1,1\\}$ is earlier than $\\{-1,-1,2\\}$, since at the first point of difference, $-2<-1$. So $-1\\ -1\\ 2$ would not be an acceptable answer. $1\\ -2\\ 1$ would also be unacceptable, even though it is the correct set, because the elements are not listed in nondecreasing order.\n\n**Limits**\n\n- $1 \\leq \\mathrm{T} \\leq 100 .$\n- $1 \\leq \\mathrm{P} \\leq 10000 .$\n- $\\mathrm{F}_{\\mathrm{i}} \\geq 1$.\n\n**Small dataset**\n\n- Time limit: ~~240~~ 5 seconds.\n- $\\mathrm{S}$ will contain between 1 and 20 elements.\n- $0 \\leq$ each $\\mathrm{E}_{\\mathrm{i}} \\leq 10^{8}$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- $\\mathrm{S}$ will contain between 1 and 60 elements.\n- $-10^{10} \\leq$ each $\\mathrm{E}_{\\mathrm{i}} \\leq 10^{10}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #3] Log Set", "background": "", "description": "The power set of a set $\\mathrm{S}$ is the set of all subsets of $\\mathrm{S}$ (including the empty set and $\\mathrm{S}$ itself). It's easy to go from a set to a power set, but in this problem, we'll go in the other direction!\n\nWe've started with a set of (not necessarily unique) integers $\\mathrm{S}$, found its power set, and then replaced every element in the power set with the sum of elements of that element, forming a new set $\\mathrm{S}^{\\prime}$. For example, if $\\mathrm{S}=\\{-1,1\\}$, then the power set of $\\mathrm{S}$ is $\\{\\{\\},\\{-1\\},\\{1\\},\\{-1,1\\}\\}$, and so $\\mathrm{S}^{\\prime}=\\{0,-1,1,0\\}$. $\\mathrm{S}^{\\prime}$ is allowed to contain duplicates, so if $\\mathrm{S}$ has $\\mathrm{N}$ elements, then $\\mathrm{S}^{\\prime}$ always has exactly $2^{\\mathrm{N}}$ elements.\n\nGiven a description of the elements in $\\mathrm{S}^{\\prime}$ and their frequencies, can you determine our original $\\mathrm{S}$ ? It is guaranteed that $\\mathrm{S}$ exists. If there are multiple possible sets $\\mathrm{S}$ that could have produced $\\mathrm{S}^{\\prime}$, we guarantee that our original set $\\mathrm{S}$ was the earliest one of those possibilities. To determine whether a set $\\mathrm{S}_{1}$ is earlier than a different set $\\mathrm{S}_{2}$ of the same length, sort each set into nondecreasing order and then examine the leftmost position at which the sets differ. $\\mathrm{S}_{1}$ is earlier iff the element at that position in $\\mathrm{S}_{1}$ is smaller than the element at that position in $\\mathrm{S}_{2}$.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each consists of one line with an integer $\\mathrm{P}$, followed by two more lines, each of which has $\\mathrm{P}$ space-separated integers. The first of those lines will have all of the different elements $\\mathrm{E}_{1}, \\mathrm{E}_{2}, \\ldots, \\mathrm{E}_{\\mathrm{P}}$ that appear in $\\mathrm{S}^{\\prime}$, sorted in ascending order. The second of those lines will have the number of times $\\mathrm{F}_{1}, \\mathrm{~F}_{2}, \\ldots, \\mathrm{F}_{\\mathrm{P}}$ that each of those values appears in $\\mathrm{S}^{\\prime}$. That is, for any $\\mathrm{i}$, the element $\\mathrm{E}_{\\mathrm{i}}$ appears $\\mathrm{F}_{\\mathrm{i}}$ times in $\\mathrm{S}^{\\prime}$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: \", where $\\mathrm{x}$ is the test case number (starting from 1), followed by the elements of our original set $\\mathrm{S}$, separated by spaces, in nondecreasing order. (You will be listing the elements of $\\mathrm{S}$ directly, and not providing two lists of elements and frequencies as we do for $\\mathrm{S}^{\\prime}$.)", "hint": "**Sample Explanation**\n\nNote that Cases #4 and #5 are not within the limits for the Small dataset.\n\nIn Case #4, $\\mathrm{S}=\\{-1,1\\}$ is the only possible set that satisfies the conditions. (Its subsets are $\\{\\},\\{-1\\},\\{1\\}$, and $\\{-1,1\\}$. Those have sums $0, -1, 1$, and $0$, respectively, so $\\mathrm{S}^{\\prime}$ has one copy of $-1$, two copies of $0$, and one copy of $1$, which matches the specifications in the input.)\n\nFor Case #5, note that $\\mathrm{S}=\\{-1,-1,2\\}$ also produces the same $\\mathrm{S}^{\\prime}=\\{-2,-1,-1,0,0,1,1,2\\}$, but $\\mathrm{S}=\\{-2,1,1\\}$ is earlier than $\\{-1,-1,2\\}$, since at the first point of difference, $-2<-1$. So $-1\\ -1\\ 2$ would not be an acceptable answer. $1\\ -2\\ 1$ would also be unacceptable, even though it is the correct set, because the elements are not listed in nondecreasing order.\n\n**Limits**\n\n- $1 \\leq \\mathrm{T} \\leq 100 .$\n- $1 \\leq \\mathrm{P} \\leq 10000 .$\n- $\\mathrm{F}_{\\mathrm{i}} \\geq 1$.\n\n**Small dataset**\n\n- Time limit: ~~240~~ 5 seconds.\n- $\\mathrm{S}$ will contain between 1 and 20 elements.\n- $0 \\leq$ each $\\mathrm{E}_{\\mathrm{i}} \\leq 10^{8}$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- $\\mathrm{S}$ will contain between 1 and 60 elements.\n- $-10^{10} \\leq$ each $\\mathrm{E}_{\\mathrm{i}} \\leq 10^{10}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #3] Log Set", "background": null, "description": "集合 $\\mathrm{S}$ 的幂集是 $\\mathrm{S}$ 的所有子集（包括空集和 $\\mathrm{S}$ 本身）组成的集合。从一个集合得到它的幂集很容易，但在本题中，我们要反过来操作！\n\n我们从一个（元素不一定唯一的）整数集合 $\\mathrm{S}$ 出发，求出它的幂集，然后将幂集中的每个元素替换为该子集元素之和，得到一个新集合 $\\mathrm{S}^{\\prime}$。例如，如果 $\\mathrm{S}=\\{-1,1\\}$，那么 $\\mathrm{S}$ 的幂集为 $\\{\\{\\},\\{-1\\},\\{1\\},\\{-1,1\\}\\}$，所以 $\\mathrm{S}^{\\prime}=\\{0,-1,1,0\\}$。$\\mathrm{S}^{\\prime}$ 允许包含重复元素，因此如果 $\\mathrm{S}$ 有 $\\mathrm{N}$ 个元素，则 $\\mathrm{S}^{\\prime}$ 一定有 $2^{\\mathrm{N}}$ 个元素。\n\n给定 $\\mathrm{S}^{\\prime}$ 中各元素及其出现次数的信息，你能还原出原始集合 $\\mathrm{S}$ 吗？保证 $\\mathrm{S}$ 存在。如果有多个可能的集合 $\\mathrm{S}$ 能生成相同的 $\\mathrm{S}^{\\prime}$，则保证原始集合 $\\mathrm{S}$ 是这些可能集合中“最早”的那个。判断集合 $\\mathrm{S}_1$ 是否比集合 $\\mathrm{S}_2$ 更早的方法如下：将每个集合按非递减顺序排序，比较第一个不同的位置，若 $\\mathrm{S}_1$ 在该位置的元素小于 $\\mathrm{S}_2$，则 $\\mathrm{S}_1$ 更早。", "inputFormat": "输入的第一行包含测试用例数 $\\mathrm{T}$。接下来有 $\\mathrm{T}$ 组测试数据。每组测试数据包括一行整数 $\\mathrm{P}$，接着两行，每行有 $\\mathrm{P}$ 个用空格分隔的整数。第一行为所有出现在 $\\mathrm{S}^{\\prime}$ 中的不同元素 $\\mathrm{E}_1, \\mathrm{E}_2, \\ldots, \\mathrm{E}_{\\mathrm{P}}$，按升序排列。第二行为这些元素在 $\\mathrm{S}^{\\prime}$ 中出现的次数 $\\mathrm{F}_1, \\mathrm{F}_2, \\ldots, \\mathrm{F}_{\\mathrm{P}}$。也就是说，对于任意 $i$，元素 $\\mathrm{E}_i$ 在 $\\mathrm{S}^{\\prime}$ 中出现 $\\mathrm{F}_i$ 次。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #x: \"，其中 $x$ 为测试用例编号（从 1 开始），后接原始集合 $\\mathrm{S}$ 的所有元素，按非递减顺序，用空格分隔。（你需要直接输出 $\\mathrm{S}$ 的元素，不需要像 $\\mathrm{S}^{\\prime}$ 那样输出元素和出现次数两行。）", "hint": "**样例解释**\n\n注意，第 4、5 组样例不在 Small 数据范围内。\n\n第 4 组样例中，$\\mathrm{S}=\\{-1,1\\}$ 是唯一满足条件的集合。（它的子集为 $\\{\\},\\{-1\\},\\{1\\},\\{-1,1\\}$，这些子集的和分别为 $0, -1, 1, 0$，所以 $\\mathrm{S}^{\\prime}$ 包含 $-1$ 一次，$0$ 两次，$1$ 一次，正好与输入相符。）\n\n对于第 5 组样例，$\\mathrm{S}=\\{-1,-1,2\\}$ 也能生成相同的 $\\mathrm{S}^{\\prime}=\\{-2,-1,-1,0,0,1,1,2\\}$，但 $\\mathrm{S}=\\{-2,1,1\\}$ 比 $\\{-1,-1,2\\}$ 更早，因为在第一个不同的位置，$-2<-1$。因此 $-1\\ -1\\ 2$ 不是可接受答案。$1\\ -2\\ 1$ 也不被接受，虽然它是正确集合，但元素未按非递减顺序输出。\n\n**数据范围**\n\n- $1 \\leq \\mathrm{T} \\leq 100$。\n- $1 \\leq \\mathrm{P} \\leq 10000$。\n- $\\mathrm{F}_i \\geq 1$。\n\n**Small 数据集**\n\n- 时间限制：5 秒。\n- $\\mathrm{S}$ 的元素个数在 1 到 20 之间。\n- $0 \\leq$ 每个 $\\mathrm{E}_i \\leq 10^8$。\n\n**Large 数据集**\n\n- 时间限制：10 秒。\n- $\\mathrm{S}$ 的元素个数在 1 到 60 之间。\n- $-10^{10} \\leq$ 每个 $\\mathrm{E}_i \\leq 10^{10}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13232", "type": "P", "difficulty": 6, "samples": [["4\n5 2\n2 2 2 2 2\n6 2\n1 1 1 0 0 0\n8 4\n2 1 1 0 0 1 1 2\n8 4\n0 1 1 3 1 2 2 2", "Case #1: 0\nCase #2: CHEATERS!\nCase #3: 2\nCase #4: 3"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["2015", "差分", "Ad-hoc", "Google Code Jam"], "title": "[GCJ 2015 #3] River Flow", "background": "", "description": "The city you live in lies on the banks of the spectacular Binary river. The water in the river comes from some tributary streams that start way up in the mountains. Unfortunately for your city, there are farmers who live in the mountains who need to use up some of the water in the tributary streams for their crops.\n\nLong ago, the city struck a deal with the farmers to allow them to farm while keeping the river flowing: each farmer was allowed to use the water for her crops exactly half the time. The farmers would alternately divert water for their crops for a day and leave the water to run down the river for a day. The result was a disaster! Because the farmers' water usage was synchronized, with everyone either diverting or not diverting water at the same time, the river would run dry every other day and then flood the city the next.\n\nTo solve this problem, the city went back to the farmers and asked each one to choose some integer power of 2 (this is the Binary River after all) between 1 and $\\mathbf{D}$, inclusive, and toggle her water usage (either start or stop collecting water) every time that number of days has elapsed. (Not every power of 2 between 1 and $\\mathbf{D}$ was necessarily represented, and multiple farmers may have selected the same integer. 1 counts as a power of 2.) The idea was that this would make the water usage more even overall, and so the droughts and flooding would become less frequent.\n\nThis all happened a long time ago, and you and the other citizens have recently become suspicious that the farmers aren't sticking to the agreement. (You're not even sure how many farmers there are right now!) However, the only data you have is $\\mathbf{N}$ days' history of the amount of water flowing through the city. Can you tell if the farmers are being honest?\n\nEach tributary stream has flow 1 and the flow through the main river is the sum of all the tributary streams that are not being diverted for farming. (Before looking at the records, you don't know how many tributary streams there are.) At most 1 farmer will divert the water from each tributary stream, but there may be some tributary streams from which no farmers ever divert water. Note that the farmers started their water diversion cycles long before the city started recording the water flow, but there is no guarantee that they all started on the same day.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two space-separated integers $\\mathbf{N}$ and $\\mathbf{D}$. The next line contains $\\mathbf{N}$ space-separated integers, with the $\\mathrm{i}$ th integer $\\mathbf{d}_{\\mathrm{i}}$ giving the river flow on the $\\mathrm{i}$ th day.\n", "outputFormat": "For each case, output one line containing \"Case #x: M\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathbf{M}$ is the smallest number of farmers who could be diverting water from the streams according to the described model, consistent with the observed flow through the river.\n\nIf you are sure that at least one farmer is active, but there is no way that the supplied input could be explained by farmers obeying the rules, then output CHEATERS! instead of a number.", "hint": "**Sample Explanation**\n\nCase #1 is consistent with two tributary streams with no farmers drawing from them.\n\nCase #2 could a single tributary stream being diverted every $4$ days. However, $\\mathbf D$ is $2$ in this case, so this farmer is breaking the agreement.\n\nCase #3 could be two farmers each with a diversion cycle of $4$ days.\n\nCase #4 could be three farmers with diversion cycles of $1, 2$ and $4$ days.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 50$.\n- $\\mathbf{D}$ will be a power of 2 .\n- $1 \\leq \\mathbf{D} \\leq \\operatorname{floor}(\\mathbf{N} / 2)$.\n\n**Small dataset(10 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 50$.\n- $0 \\leq \\mathbf{d}_{\\mathrm{i}} \\leq 5$.\n\n**Large dataset(17 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{N} \\leq 5000$. \n- $0 \\leq \\mathbf{d}_{\\mathrm{i}} \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 #3] River Flow", "background": "", "description": "The city you live in lies on the banks of the spectacular Binary river. The water in the river comes from some tributary streams that start way up in the mountains. Unfortunately for your city, there are farmers who live in the mountains who need to use up some of the water in the tributary streams for their crops.\n\nLong ago, the city struck a deal with the farmers to allow them to farm while keeping the river flowing: each farmer was allowed to use the water for her crops exactly half the time. The farmers would alternately divert water for their crops for a day and leave the water to run down the river for a day. The result was a disaster! Because the farmers' water usage was synchronized, with everyone either diverting or not diverting water at the same time, the river would run dry every other day and then flood the city the next.\n\nTo solve this problem, the city went back to the farmers and asked each one to choose some integer power of 2 (this is the Binary River after all) between 1 and $\\mathbf{D}$, inclusive, and toggle her water usage (either start or stop collecting water) every time that number of days has elapsed. (Not every power of 2 between 1 and $\\mathbf{D}$ was necessarily represented, and multiple farmers may have selected the same integer. 1 counts as a power of 2.) The idea was that this would make the water usage more even overall, and so the droughts and flooding would become less frequent.\n\nThis all happened a long time ago, and you and the other citizens have recently become suspicious that the farmers aren't sticking to the agreement. (You're not even sure how many farmers there are right now!) However, the only data you have is $\\mathbf{N}$ days' history of the amount of water flowing through the city. Can you tell if the farmers are being honest?\n\nEach tributary stream has flow 1 and the flow through the main river is the sum of all the tributary streams that are not being diverted for farming. (Before looking at the records, you don't know how many tributary streams there are.) At most 1 farmer will divert the water from each tributary stream, but there may be some tributary streams from which no farmers ever divert water. Note that the farmers started their water diversion cycles long before the city started recording the water flow, but there is no guarantee that they all started on the same day.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two space-separated integers $\\mathbf{N}$ and $\\mathbf{D}$. The next line contains $\\mathbf{N}$ space-separated integers, with the $\\mathrm{i}$ th integer $\\mathbf{d}_{\\mathrm{i}}$ giving the river flow on the $\\mathrm{i}$ th day.\n", "outputFormat": "For each case, output one line containing \"Case #x: M\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathbf{M}$ is the smallest number of farmers who could be diverting water from the streams according to the described model, consistent with the observed flow through the river.\n\nIf you are sure that at least one farmer is active, but there is no way that the supplied input could be explained by farmers obeying the rules, then output CHEATERS! instead of a number.", "hint": "**Sample Explanation**\n\nCase #1 is consistent with two tributary streams with no farmers drawing from them.\n\nCase #2 could a single tributary stream being diverted every $4$ days. However, $\\mathbf D$ is $2$ in this case, so this farmer is breaking the agreement.\n\nCase #3 could be two farmers each with a diversion cycle of $4$ days.\n\nCase #4 could be three farmers with diversion cycles of $1, 2$ and $4$ days.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 50$.\n- $\\mathbf{D}$ will be a power of 2 .\n- $1 \\leq \\mathbf{D} \\leq \\operatorname{floor}(\\mathbf{N} / 2)$.\n\n**Small dataset(10 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 50$.\n- $0 \\leq \\mathbf{d}_{\\mathrm{i}} \\leq 5$.\n\n**Large dataset(17 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{N} \\leq 5000$. \n- $0 \\leq \\mathbf{d}_{\\mathrm{i}} \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 #3] River Flow", "background": null, "description": "你所在的城市坐落在壮观的二进制河（Binary river）岸边。河水来自高山上的一些支流。不幸的是，山上的农民需要用这些支流的水来灌溉庄稼。\n\n很久以前，城市与农民达成了一项协议，允许他们在保证河水流动的同时进行耕作：每位农民被允许在一半的时间里为庄稼用水。农民们轮流用一天水，然后让水流入河一天。结果却是一场灾难！因为所有农民的用水时间是同步的，要么全部用水，要么全部不取水，导致河流每隔一天就会干涸，接着第二天又会泛滥。\n\n为了解决这个问题，城市再次与农民协商，让每位农民选择一个介于 $1$ 到 $\\mathbf{D}$（包含）之间的 $2$ 的整数次幂（毕竟这是二进制河），并且每经过该天数就切换一次用水状态（即开始或停止取水）。（并不是每个 $1$ 到 $\\mathbf{D}$ 之间的 $2$ 的幂都一定被选择，多个农民可以选择相同的数字。$1$ 也算作 $2$ 的幂。）这样做的目的是让整体用水更加均匀，从而减少干旱和洪水的发生。\n\n这一切都发生在很久以前，而你和其他市民最近开始怀疑农民们并没有遵守协议。（你甚至不知道现在有多少农民！）然而，你们唯一掌握的数据是 $\\mathbf{N}$ 天的河流水量历史记录。你能判断农民们是否诚实吗？\n\n每条支流的流量为 $1$，主河道的流量等于所有未被农民取水的支流流量之和。（在查看记录之前，你并不知道有多少条支流。）每条支流最多只会被一位农民取水，也可能有些支流从未被农民取水。注意，农民们在城市开始记录水流之前就已经开始了他们的用水周期，但并不能保证他们都是在同一天开始的。", "inputFormat": "输入的第一行是测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例的第一行包含两个用空格分隔的整数 $\\mathbf{N}$ 和 $\\mathbf{D}$。下一行包含 $\\mathbf{N}$ 个用空格分隔的整数，第 $\\mathrm{i}$ 个整数 $\\mathbf{d}_{\\mathrm{i}}$ 表示第 $\\mathrm{i}$ 天河流的流量。", "outputFormat": "对于每组测试用例，输出一行，格式为 \"Case #x: M\"，其中 $\\mathrm{x}$ 是测试用例编号（从 $1$ 开始），$\\mathbf{M}$ 是根据上述模型、与观测到的河流流量一致的最少农民数量。\n\n如果你确定至少有一位农民在活动，但没有任何方式可以用遵守规则的农民来解释给定的输入，则输出 CHEATERS! 代替数字。", "hint": "**样例解释**\n\n第 1 组数据可以解释为有两条支流，没有农民从中取水。\n\n第 2 组数据可以看作有一条支流，每隔 $4$ 天被取水一次。然而，这组数据的 $\\mathbf D$ 是 $2$，所以这位农民违反了协议。\n\n第 3 组数据可以看作有两位农民，各自的取水周期为 $4$ 天。\n\n第 4 组数据可以看作有三位农民，取水周期分别为 $1, 2$ 和 $4$ 天。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 50$。\n- $\\mathbf{D}$ 是 $2$ 的幂。\n- $1 \\leq \\mathbf{D} \\leq \\operatorname{floor}(\\mathbf{N} / 2)$。\n\n**小数据集（10 分）**\n\n- 时间限制：~~240~~ 5 秒。\n- $1 \\leq \\mathbf{N} \\leq 50$。\n- $0 \\leq \\mathbf{d}_{\\mathrm{i}} \\leq 5$。\n\n**大数据集（17 分）**\n\n- 时间限制：~~480~~ 10 秒。\n- $1 \\leq \\mathbf{N} \\leq 5000$。\n- $0 \\leq \\mathbf{d}_{\\mathrm{i}} \\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13233", "type": "P", "difficulty": 6, "samples": [["4\n111\n1111\n1111111\n1111119", "Case #1: 2\nCase #2: 3\nCase #3: 3\nCase #4: 10"]], "limits": {"time": [5000, 30000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2015", "Google Code Jam"], "title": "[GCJ 2015 Finals] Costly Binary Search", "background": "", "description": "You were asked to implement arguably the most important algorithm of all: binary search. More precisely, you have a sorted array of objects, and a new object that you want to insert into the array. In order to find the insertion position, you can compare your object with the objects in the array. Each comparison can return either \"greater\", meaning that your object should be inserted to the right of the compared object, or \"less\", meaning that your object should be inserted to the left of the compared object. For simplicity, comparisons never return \"equal\" in this problem. It is guaranteed that when your object is greater than some object in the array, it is also greater than all objects to the left of that object; similarly, when your object is less than some object of the array, it is also less than all objects to the right of that object. If the array has $\\mathrm{n}$ elements, there are $\\mathrm{n}+1$ possible outcomes for your algorithm.\n\nIn this problem, not all comparisons have the same cost. More precisely, comparing your object with $\\mathrm{i}$-th object in the array costs $\\mathrm{a}_{\\mathrm{i}}$, an integer between 1 and 9, inclusive.\n\nWhat will be the total cost, in the worst case, of your binary search? Assume you follow an optimal strategy and try to minimize the total cost in the worst case.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each of those lines contains one sequence of digits describing the comparison costs $\\mathbf{a}_{\\mathbf{i}}$ for one testcase. The size of the array $\\mathrm{n}$ is given by the length of this sequence.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the total binary search cost in the worst case.", "hint": "**Sample Explanation**\n\n- $1 \\leq \\mathrm{T} \\leq 50$.\n- All digits are between 1 and 9, inclusive.\n- There are no spaces between digits on one line.\n\n**Small dataset(8 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathrm{n} \\leq 10^{4}$.\n\n**Large dataset(19 Pts)**\n\n- Time limit: ~~480~~ 30 seconds.\n- $1 \\leq \\mathrm{n} \\leq 10^{6}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 Finals] Costly Binary Search", "background": "", "description": "You were asked to implement arguably the most important algorithm of all: binary search. More precisely, you have a sorted array of objects, and a new object that you want to insert into the array. In order to find the insertion position, you can compare your object with the objects in the array. Each comparison can return either \"greater\", meaning that your object should be inserted to the right of the compared object, or \"less\", meaning that your object should be inserted to the left of the compared object. For simplicity, comparisons never return \"equal\" in this problem. It is guaranteed that when your object is greater than some object in the array, it is also greater than all objects to the left of that object; similarly, when your object is less than some object of the array, it is also less than all objects to the right of that object. If the array has $\\mathrm{n}$ elements, there are $\\mathrm{n}+1$ possible outcomes for your algorithm.\n\nIn this problem, not all comparisons have the same cost. More precisely, comparing your object with $\\mathrm{i}$-th object in the array costs $\\mathrm{a}_{\\mathrm{i}}$, an integer between 1 and 9, inclusive.\n\nWhat will be the total cost, in the worst case, of your binary search? Assume you follow an optimal strategy and try to minimize the total cost in the worst case.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each of those lines contains one sequence of digits describing the comparison costs $\\mathbf{a}_{\\mathbf{i}}$ for one testcase. The size of the array $\\mathrm{n}$ is given by the length of this sequence.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the total binary search cost in the worst case.", "hint": "**Sample Explanation**\n\n- $1 \\leq \\mathrm{T} \\leq 50$.\n- All digits are between 1 and 9, inclusive.\n- There are no spaces between digits on one line.\n\n**Small dataset(8 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathrm{n} \\leq 10^{4}$.\n\n**Large dataset(19 Pts)**\n\n- Time limit: ~~480~~ 30 seconds.\n- $1 \\leq \\mathrm{n} \\leq 10^{6}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 Finals] Costly Binary Search", "background": null, "description": "你被要求实现可以说是最重要的算法之一：二分查找。更准确地说，你有一个已排序的对象数组，以及一个你想要插入到数组中的新对象。为了找到插入的位置，你可以将你的对象与数组中的对象进行比较。每次比较的结果要么是“更大”，意味着你的对象应该插入到被比较对象的右侧；要么是“更小”，意味着你的对象应该插入到被比较对象的左侧。为简化问题，比较结果不会出现“相等”。保证当你的对象大于数组中的某个对象时，也大于该对象左侧的所有对象；同理，当你的对象小于数组中的某个对象时，也小于该对象右侧的所有对象。如果数组有 $n$ 个元素，那么你的算法可能有 $n+1$ 种不同的结果。\n\n在本题中，并非所有的比较花费都是相同的。更准确地说，将你的对象与数组中第 $i$ 个对象进行比较的代价为 $a_i$，其中 $a_i$ 是一个介于 1 到 9 之间的整数。\n\n你的二分查找在最坏情况下的总代价是多少？假设你总是采用最优策略，尽量使最坏情况下的总代价最小。", "inputFormat": "输入的第一行给出测试用例的数量 $T$。接下来有 $T$ 行，每行包含一个数字序列，描述一个测试用例的比较代价 $a_i$。数组的大小 $n$ 由该序列的长度给出。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #x: y\"，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是最坏情况下二分查找的总代价。", "hint": "**样例说明**\n\n- $1 \\leq T \\leq 50$。\n- 所有数字都在 1 到 9 之间。\n- 每行数字之间没有空格。\n\n**小数据集（8 分）**\n\n- 时间限制：5 秒。\n- $1 \\leq n \\leq 10^{4}$。\n\n**大数据集（19 分）**\n\n- 时间限制：30 秒。\n- $1 \\leq n \\leq 10^{6}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13234", "type": "P", "difficulty": 5, "samples": [["3\n2 2\n3 1\n15 0", "Case #1: 2\nCase #2: 24\nCase #3: 738721209"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["2015", "组合数学", "Google Code Jam"], "title": "[GCJ 2015 Finals] Campinatorics", "background": null, "description": "\"Summer is finally here: time to relax, have some fun, go outside and enjoy the nice weather!\" says Alice, a very dedicated Ranger working in a popular National Park. During the summer, lots of families take some time off to camp there and have a good time, and it is Alice's job to accommodate the visitors.\n\nAlice is in charge of one of the many camps around the park. The camp can be described as a matrix of size $\\mathbf{N} \\times \\mathbf{N}$, where each cell has enough space for at most one tent. In order to arrange the families in the camp, there are several regulations that Alice needs to follow:\n\n* Only families with $\\mathbf{1 , 2}$ or $\\mathbf{3}$ members are allowed in the camp. Also, each tent can contain members of only one family, and families cannot be split across multiple tents.\n* For security reasons, Alice doesn't want the rows or columns to be too crowded or too empty, so she wants exactly 3 members in each row and column.\n* Also, according to the park's safety policies, there shouldn't be more than 2 tents in any row or column.\n\nAdditionally, Alice knows in advance that at least $\\mathrm{X}$ three-member families will be visiting the camp, and that there will be enough one- or two-member families to fill the rest of the camp.\n\nFor example, these are valid arrangements for $\\mathrm{N}=3$ and $\\mathrm{X}=0$:\n\n$\\begin{array}{llllll}1 & 2 & 0\\\\ 0 & 1 & 2\\\\ 2 & 0 & 1\\end{array}$\n\n$\\begin{array}{llllll}3 & 0 & 0\\\\0 & 1 & 2\\\\0 & 2 & 1\\end{array}$\n\nThese are not valid arrangements for $\\mathrm{N}=3$ and $\\mathrm{X}=1$:\n\n$\\begin{array}{llllllll}1 & 2 & 0\\\\0 & 1 & 2\\\\ 2 & 0 & 1\\end{array}$\n\n$\\begin{array}{llllllll}0 & 3 & 0\\\\3 & 0 & 0\\\\0 & 0 & 0\\end{array}$\n\n$\\begin{array}{llllllll}1 & 2 & 0\\\\0 & 2 & 0\\\\2 & 0 & 1\\end{array}$\n\n$\\begin{array}{llllllll}1 & 1 & 1\\\\1 & 1 & 1\\\\1 & 1 & 1 \\end{array}$\n\n* The first one is not valid because there should be at least one three-member family.\n* The second example is not valid because the number of persons in the third row (and column) is not three.\n* The third one is invalid because there are more than three members in the second column (and fewer than three in the second row).\n* The last example contains more than two tents per row or column.\n\nFinally, Alice likes to keep things interesting. She would like to know how many different arrangements are possible given $\\mathrm{N}$ and $\\mathrm{X}$.\n\nTwo arrangements $\\mathrm{A}$ and $\\mathrm{B}$ are considered different, if a cell in one arrangement contains a tent, but the same cell in the other arrangement doesn't; or if there is a tent in the same cell of both arrangements, but the number of members in that cell in $\\mathrm{A}$ is different than the number of members in the same cell in $\\mathrm{B}$.", "inputFormat": "The first line of the input contains $\\mathbf{T}$, the number of test cases. $\\mathbf{T}$ test cases follow. Each test case consists of exactly one line with two integers $\\mathbf{N}$ and $\\mathbf{X}$ corresponding to the number of rows (and columns) in Alice's camp and the minimum number of three-member families, respectively.", "outputFormat": "For each test case, output one line containing \"Case #X: Y\", where $\\mathrm{X}$ is the test case number (starting from 1) and $\\mathrm{Y}$ is the number of possible arrangements.\n\nThe answer may be huge, so output the answer modulo $10^{9}+7$.", "hint": "In case #1, you have two different valid arrangements:\n\n```\n0 3  |  3 0\n3 0  |  0 3\n```\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 200$.\n- $0 \\leq \\mathbf{X} \\leq \\mathbf{N}$.\n\n**Small dataset(6 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 20$.\n\n**Large dataset(21 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{N} \\leq 10^{6}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 Finals] Campinatorics", "background": null, "description": "\"Summer is finally here: time to relax, have some fun, go outside and enjoy the nice weather!\" says Alice, a very dedicated Ranger working in a popular National Park. During the summer, lots of families take some time off to camp there and have a good time, and it is Alice's job to accommodate the visitors.\n\nAlice is in charge of one of the many camps around the park. The camp can be described as a matrix of size $\\mathbf{N} \\times \\mathbf{N}$, where each cell has enough space for at most one tent. In order to arrange the families in the camp, there are several regulations that Alice needs to follow:\n\n* Only families with $\\mathbf{1 , 2}$ or $\\mathbf{3}$ members are allowed in the camp. Also, each tent can contain members of only one family, and families cannot be split across multiple tents.\n* For security reasons, Alice doesn't want the rows or columns to be too crowded or too empty, so she wants exactly 3 members in each row and column.\n* Also, according to the park's safety policies, there shouldn't be more than 2 tents in any row or column.\n\nAdditionally, Alice knows in advance that at least $\\mathrm{X}$ three-member families will be visiting the camp, and that there will be enough one- or two-member families to fill the rest of the camp.\n\nFor example, these are valid arrangements for $\\mathrm{N}=3$ and $\\mathrm{X}=0$:\n\n$\\begin{array}{llllll}1 & 2 & 0\\\\ 0 & 1 & 2\\\\ 2 & 0 & 1\\end{array}$\n\n$\\begin{array}{llllll}3 & 0 & 0\\\\0 & 1 & 2\\\\0 & 2 & 1\\end{array}$\n\nThese are not valid arrangements for $\\mathrm{N}=3$ and $\\mathrm{X}=1$:\n\n$\\begin{array}{llllllll}1 & 2 & 0\\\\0 & 1 & 2\\\\ 2 & 0 & 1\\end{array}$\n\n$\\begin{array}{llllllll}0 & 3 & 0\\\\3 & 0 & 0\\\\0 & 0 & 0\\end{array}$\n\n$\\begin{array}{llllllll}1 & 2 & 0\\\\0 & 2 & 0\\\\2 & 0 & 1\\end{array}$\n\n$\\begin{array}{llllllll}1 & 1 & 1\\\\1 & 1 & 1\\\\1 & 1 & 1 \\end{array}$\n\n* The first one is not valid because there should be at least one three-member family.\n* The second example is not valid because the number of persons in the third row (and column) is not three.\n* The third one is invalid because there are more than three members in the second column (and fewer than three in the second row).\n* The last example contains more than two tents per row or column.\n\nFinally, Alice likes to keep things interesting. She would like to know how many different arrangements are possible given $\\mathrm{N}$ and $\\mathrm{X}$.\n\nTwo arrangements $\\mathrm{A}$ and $\\mathrm{B}$ are considered different, if a cell in one arrangement contains a tent, but the same cell in the other arrangement doesn't; or if there is a tent in the same cell of both arrangements, but the number of members in that cell in $\\mathrm{A}$ is different than the number of members in the same cell in $\\mathrm{B}$.", "inputFormat": "The first line of the input contains $\\mathbf{T}$, the number of test cases. $\\mathbf{T}$ test cases follow. Each test case consists of exactly one line with two integers $\\mathbf{N}$ and $\\mathbf{X}$ corresponding to the number of rows (and columns) in Alice's camp and the minimum number of three-member families, respectively.", "outputFormat": "For each test case, output one line containing \"Case #X: Y\", where $\\mathrm{X}$ is the test case number (starting from 1) and $\\mathrm{Y}$ is the number of possible arrangements.\n\nThe answer may be huge, so output the answer modulo $10^{9}+7$.", "hint": "In case #1, you have two different valid arrangements:\n\n```\n0 3  |  3 0\n3 0  |  0 3\n```\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 200$.\n- $0 \\leq \\mathbf{X} \\leq \\mathbf{N}$.\n\n**Small dataset(6 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 20$.\n\n**Large dataset(21 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{N} \\leq 10^{6}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 Finals] Campinatorics", "background": null, "description": "“夏天终于来了：是时候放松一下，享受乐趣，走到户外，感受美好天气了！”Alice 是一位非常敬业的护林员，在一个著名的国家公园工作。夏天，许多家庭会抽时间来这里露营、享受美好时光，而 Alice 的工作就是安排这些游客。\n\nAlice 负责管理公园内的一个营地。该营地可以描述为一个 $N \\times N$ 的矩阵，每个格子最多只能容纳一个帐篷。为了安排家庭入住营地，Alice 需要遵守以下规定：\n\n- 只允许有 $1$、$2$ 或 $3$ 人的家庭入住营地。每个帐篷只能住一个家庭，且一个家庭不能分开住在多个帐篷里。\n- 出于安全考虑，Alice 不希望某一行或某一列太拥挤或太空旷，因此每一行和每一列必须恰好有 $3$ 个人。\n- 同时，根据公园的安全政策，每一行或每一列最多只能有 $2$ 个帐篷。\n\n此外，Alice 已经提前知道，至少会有 $X$ 个三人家庭来营地，其余的空位将由足够多的一人或两人家庭填补。\n\n例如，以下是 $N=3$ 且 $X=0$ 时的合法安排：\n\n$\\begin{array}{llllll}1 & 2 & 0\\\\ 0 & 1 & 2\\\\ 2 & 0 & 1\\end{array}$\n\n$\\begin{array}{llllll}3 & 0 & 0\\\\0 & 1 & 2\\\\0 & 2 & 1\\end{array}$\n\n以下是 $N=3$ 且 $X=1$ 时的不合法安排：\n\n$\\begin{array}{llllllll}1 & 2 & 0\\\\0 & 1 & 2\\\\ 2 & 0 & 1\\end{array}$\n\n$\\begin{array}{llllllll}0 & 3 & 0\\\\3 & 0 & 0\\\\0 & 0 & 0\\end{array}$\n\n$\\begin{array}{llllllll}1 & 2 & 0\\\\0 & 2 & 0\\\\2 & 0 & 1\\end{array}$\n\n$\\begin{array}{llllllll}1 & 1 & 1\\\\1 & 1 & 1\\\\1 & 1 & 1 \\end{array}$\n\n- 第一个不合法，因为至少需要有一个三人家庭。\n- 第二个不合法，因为第三行和第三列的人数不是 $3$。\n- 第三个不合法，因为第二列人数超过了 $3$（而第二行人数不足 $3$）。\n- 最后一个不合法，因为某一行或某一列有超过两个帐篷。\n\n最后，Alice 想知道，在给定 $N$ 和 $X$ 的情况下，有多少种不同的安排方式。\n\n如果两个安排 $A$ 和 $B$ 满足：存在某个格子在一个安排中有帐篷而另一个没有，或者同一个格子都有帐篷但帐篷内人数不同，则认为这两个安排是不同的。", "inputFormat": "第一行输入一个整数 $T$，表示测试用例的数量。接下来有 $T$ 个测试用例。每个测试用例占一行，包含两个整数 $N$ 和 $X$，分别表示营地的行数（和列数）以及至少需要安排的三人家庭数量。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #X: Y\"，其中 $X$ 是测试用例编号（从 1 开始），$Y$ 是可能的安排数量。\n\n答案可能很大，请输出对 $10^9+7$ 取模后的结果。", "hint": "在第 1 个测试用例中，有两种不同的合法安排：\n\n```\n0 3  |  3 0\n3 0  |  0 3\n```\n\n**限制条件**\n\n- $1 \\leq T \\leq 200$。\n- $0 \\leq X \\leq N$。\n\n**小数据集（6 分）**\n\n- 时间限制：5 秒。\n- $1 \\leq N \\leq 20$。\n\n**大数据集（21 分）**\n\n- 时间限制：10 秒。\n- $1 \\leq N \\leq 10^{6}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
