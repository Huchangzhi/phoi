{"pid": "P14218", "type": "P", "difficulty": 2, "samples": [["2\n3 10\n239 141 526\n6\n2 1\n300 100\n1000", "91\n1400"]], "limits": {"time": [1000, 1000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2024", "排序", "ICPC", "昆明"], "title": "[ICPC 2024 Kunming I] 金牌", "background": "", "description": "真是忙碌的一周！这个周末，将会有 $n$ 场程序设竞赛同时进行。\n\n每场竞赛将会从每 $k$ 支参加该竞赛的队伍中颁发一枚金牌。也就是说，如果有 $t$ 支队伍参加竞赛，将会颁发 $\\lfloor \\frac{t}{k} \\rfloor$ 枚金牌，其中 $\\lfloor x \\rfloor$ 是不超过 $x$ 的最大整数。目前第 $i$ 场竞赛有 $a_i$ 支队伍参加。\n\n堡堡是一所大学的教练，该大学有 $m$ 支队伍，并且他还没有决定每支队伍应该参加哪场竞赛。请帮助他为每支队伍分配一场竞赛，使得所有竞赛颁发的金牌总数最多。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$（$1 \\le T \\le 100$）表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $k$（$1 \\le n \\le 100$，$1 \\le k \\le 10^9$），表示竞赛的数量和金牌的比例。\n\n第二行输入 $n$ 个整数 $a_1, a_2, \\cdots, a_n$（$1 \\le a_i \\le 10^9$），其中 $a_i$ 表示目前有几支队伍参加第 $i$ 场竞赛。\n\n第三行输入一个整数 $m$（$1 \\le m \\le 10^9$），表示您需要为多少支队伍安排竞赛。", "outputFormat": "每组数据输出一行一个整数，表示所有竞赛最多一共颁发多少金牌。", "hint": "对于第一组样例数据，派 $2$ 支队伍去第 $1$ 场竞赛，$4$ 支队伍去第 $3$ 场竞赛。金牌总数为 $\\lfloor \\frac{239 + 2}{10} \\rfloor + \\lfloor \\frac{141 + 0}{10} \\rfloor + \\lfloor \\frac{526 + 4}{10} \\rfloor = 24 + 14 + 53 = 91$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Kunming I] 金牌", "background": "", "description": "真是忙碌的一周！这个周末，将会有 $n$ 场程序设竞赛同时进行。\n\n每场竞赛将会从每 $k$ 支参加该竞赛的队伍中颁发一枚金牌。也就是说，如果有 $t$ 支队伍参加竞赛，将会颁发 $\\lfloor \\frac{t}{k} \\rfloor$ 枚金牌，其中 $\\lfloor x \\rfloor$ 是不超过 $x$ 的最大整数。目前第 $i$ 场竞赛有 $a_i$ 支队伍参加。\n\n堡堡是一所大学的教练，该大学有 $m$ 支队伍，并且他还没有决定每支队伍应该参加哪场竞赛。请帮助他为每支队伍分配一场竞赛，使得所有竞赛颁发的金牌总数最多。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$（$1 \\le T \\le 100$）表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $k$（$1 \\le n \\le 100$，$1 \\le k \\le 10^9$），表示竞赛的数量和金牌的比例。\n\n第二行输入 $n$ 个整数 $a_1, a_2, \\cdots, a_n$（$1 \\le a_i \\le 10^9$），其中 $a_i$ 表示目前有几支队伍参加第 $i$ 场竞赛。\n\n第三行输入一个整数 $m$（$1 \\le m \\le 10^9$），表示您需要为多少支队伍安排竞赛。", "outputFormat": "每组数据输出一行一个整数，表示所有竞赛最多一共颁发多少金牌。", "hint": "对于第一组样例数据，派 $2$ 支队伍去第 $1$ 场竞赛，$4$ 支队伍去第 $3$ 场竞赛。金牌总数为 $\\lfloor \\frac{239 + 2}{10} \\rfloor + \\lfloor \\frac{141 + 0}{10} \\rfloor + \\lfloor \\frac{526 + 4}{10} \\rfloor = 24 + 14 + 53 = 91$。", "locale": "zh-CN"}}}
{"pid": "P14219", "type": "P", "difficulty": 6, "samples": [["3\n8 6 4\n1 3\n2 1\n2 6\n4 1\n4 7\n6 1\n6 3\n6 6\n2 3\n3 1\n4 3\n4 6\n5 2\n6 4\n3 2 1\n10 12\n10 10\n10 11\n1 4\n1 5\n1 3 2\n1 1\n2 1\n2 2\n2 3", "4\n6 3 2 5\n2\n1\n0\n1 2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "ICPC", "昆明"], "title": "[ICPC 2024 Kunming I] 阻止城堡 2", "background": "", "description": "一块有 $10^9$ 行和 $10^9$ 列的棋盘上放着 $n$ 座城堡与 $m$ 个障碍物。每座城堡或每个障碍物恰好占据一个格子，且被占据的格子两两不同。两座城堡可以互相攻击，若它们位于同一行或同一列，且它们之间没有障碍物或其它城堡。更正式地，令 $(i, j)$ 表示位于第 $i$ 行第 $j$ 列的格子，位于 $(i_1, j_1)$ 和 $(i_2, j_2)$ 的两座城堡可以互相攻击，若以下条件中有一条成立：\n\n- $i_1 = i_2$，且对于所有 $\\min(j_1, j_2) < j < \\max(j_1, j_2)$，不存在位于 $(i_1, j)$ 的障碍物或城堡。\n- $j_1 = j_2$，且对于所有 $\\min(i_1, i_2) < i < \\max(i_1, i_2)$，不存在位于 $(i, j_1)$ 的障碍物或城堡。\n\n您需要从棋盘上移除 $k$ 个障碍物，但您不希望太多城堡可以互相攻击。从棋盘上移除恰好 $k$ 个障碍物之后，最小化可以互相攻击的城堡对数。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入三个整数 $n$，$m$ 和 $k$（$1 \\le n, m \\le 10^5$，$1 \\le k \\le m$）表示城堡的数量，障碍物的数量，以及您需要移除的障碍物的数量。\n\n对于接下来 $n$ 行，第 $i$ 行输入两个整数 $r_i$ 和 $c_i$（$1 \\le r_i, c_i \\le 10^9$），表示第 $i$ 座城堡位于第 $r_i$ 行第 $c_i$ 列。\n\n对于接下来 $m$ 行，第 $i$ 行输入两个整数 $r'_i$ 和 $c'_i$（$1 \\le r'_i, c'_i \\le 10^9$），表示第 $i$ 个障碍物位于第 $r'_i$ 行第 $c'_i$ 列。\n\n保证被占据的格子两两不同。同时保证所有数据 $n$ 之和与 $m$ 之和均不超过 $10^5$。", "outputFormat": "每组数据首先输出一行一个整数，表示恰好移除 $k$ 个障碍物之后，最少有几对城堡可以互相攻击。接下来输出一行 $k$ 个不同的由单个空格分隔的整数 $b_1, b_2, \\cdots, b_k$（$1 \\le b_i \\le m$），表示您移除的障碍物的编号。如果有多种合法答案，您可以输出任意一种。", "hint": "对于第一组样例数据，左边的图片展示了原本的棋盘，右边的图片展示了移除 $4$ 个障碍物之后的棋盘。在移除障碍物之后，可以互相攻击的城堡对有：第 $2$ 和第 $4$ 座城堡，第 $4$ 和第 $6$ 座城堡，第 $6$ 和第 $7$ 座城堡，第 $7$ 和第 $8$ 座城堡。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/u6jlu4a5.png)\n:::\n\n对于第三组样例数据，由于只有 $1$ 座城堡，不存在可以互相攻击的城堡对。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Kunming I] 阻止城堡 2", "background": "", "description": "一块有 $10^9$ 行和 $10^9$ 列的棋盘上放着 $n$ 座城堡与 $m$ 个障碍物。每座城堡或每个障碍物恰好占据一个格子，且被占据的格子两两不同。两座城堡可以互相攻击，若它们位于同一行或同一列，且它们之间没有障碍物或其它城堡。更正式地，令 $(i, j)$ 表示位于第 $i$ 行第 $j$ 列的格子，位于 $(i_1, j_1)$ 和 $(i_2, j_2)$ 的两座城堡可以互相攻击，若以下条件中有一条成立：\n\n- $i_1 = i_2$，且对于所有 $\\min(j_1, j_2) < j < \\max(j_1, j_2)$，不存在位于 $(i_1, j)$ 的障碍物或城堡。\n- $j_1 = j_2$，且对于所有 $\\min(i_1, i_2) < i < \\max(i_1, i_2)$，不存在位于 $(i, j_1)$ 的障碍物或城堡。\n\n您需要从棋盘上移除 $k$ 个障碍物，但您不希望太多城堡可以互相攻击。从棋盘上移除恰好 $k$ 个障碍物之后，最小化可以互相攻击的城堡对数。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入三个整数 $n$，$m$ 和 $k$（$1 \\le n, m \\le 10^5$，$1 \\le k \\le m$）表示城堡的数量，障碍物的数量，以及您需要移除的障碍物的数量。\n\n对于接下来 $n$ 行，第 $i$ 行输入两个整数 $r_i$ 和 $c_i$（$1 \\le r_i, c_i \\le 10^9$），表示第 $i$ 座城堡位于第 $r_i$ 行第 $c_i$ 列。\n\n对于接下来 $m$ 行，第 $i$ 行输入两个整数 $r'_i$ 和 $c'_i$（$1 \\le r'_i, c'_i \\le 10^9$），表示第 $i$ 个障碍物位于第 $r'_i$ 行第 $c'_i$ 列。\n\n保证被占据的格子两两不同。同时保证所有数据 $n$ 之和与 $m$ 之和均不超过 $10^5$。", "outputFormat": "每组数据首先输出一行一个整数，表示恰好移除 $k$ 个障碍物之后，最少有几对城堡可以互相攻击。接下来输出一行 $k$ 个不同的由单个空格分隔的整数 $b_1, b_2, \\cdots, b_k$（$1 \\le b_i \\le m$），表示您移除的障碍物的编号。如果有多种合法答案，您可以输出任意一种。", "hint": "对于第一组样例数据，左边的图片展示了原本的棋盘，右边的图片展示了移除 $4$ 个障碍物之后的棋盘。在移除障碍物之后，可以互相攻击的城堡对有：第 $2$ 和第 $4$ 座城堡，第 $4$ 和第 $6$ 座城堡，第 $6$ 和第 $7$ 座城堡，第 $7$ 和第 $8$ 座城堡。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/u6jlu4a5.png)\n:::\n\n对于第三组样例数据，由于只有 $1$ 座城堡，不存在可以互相攻击的城堡对。", "locale": "zh-CN"}}}
{"pid": "P14220", "type": "P", "difficulty": 7, "samples": [["8 7\nabcaabbc\n+ 3 1 3 2 4 3 8\n+ 2 1 4 1 8\n+ 1 2 4\n? 1 5 6 1 7 8\n- 3\n+ 1 2 5\n? 1 2 3 1 5 5", "2\n1"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC", "昆明"], "title": "[ICPC 2024 Kunming I] 生成字符串", "background": "", "description": "给定一个长度为 $n$ 的模板字符串 $S = s_1s_2\\cdots s_n$。一个生成字符串指的是由模板字符串 $S$ 的若干子串连接而成的字符串。更正式地，每个生成字符串 $T = f(k, \\{l_i\\}_{i=1}^k, \\{r_i\\}_{i=1}^k)$ 可以被描述为一个正整数 $k$ 以及 $k$ 对整数 $(l_i, r_i)$，其中 $T = s[l_1:r_1]+s[l_2:r_2]+\\cdots+s[l_k: r_k]$。这里我们用 $s[l: r]$ 表示子串 $s_ls_{l+1}\\cdots s_r$，用 $+$ 表示字符串连接。\n\n您需要维护一个由字符串构成的可重集合 $\\mathbb{A}$，支持以下三种操作：\n- $\\texttt{+ } k\\ l_1\\ r_1\\ l_2\\ r_2\\ \\cdots\\ l_k\\ r_k$：将 $f(k, \\{l_i\\}_{i=1}^k, \\{r_i\\}_{i=1}^k)$ 加入可重集合 $\\mathbb{A}$。\n- $\\texttt{- } t$：将第 $t$ 次操作加入的字符串从可重集合 $\\mathbb{A}$ 里删除。保证第 $t$ 次操作是一次加入操作，且该字符串目前还没有被删除。\n- $\\texttt{? } k\\ l_1\\ r_1\\ l_2\\ r_2\\ \\cdots\\ l_k\\ r_k\\ m\\ u_1\\ v_1\\ u_2\\ v_2\\ \\cdots u_m\\ v_m$：求可重集合 $\\mathbb{A}$ 里有几个字符串以 $f(k, \\{l_i\\}_{i=1}^k, \\{r_i\\}_{i=1}^k)$ 为开头，且以 $f(m, \\{u_i\\}_{i=1}^m, \\{v_i\\}_{i=1}^m)$ 为结尾。", "inputFormat": "每个测试文件仅有一组测试数据。\n\n第一行输入两个整数 $n$ 和 $q$（$1\\leq n, q\\leq 10^5$），表示 $S$ 的长度和操作的数量。\n\n第二行输入一个由小写英文字母构成的字符串 $s_1s_2\\cdots s_n$，表示模板字符串。\n\n对于接下来的 $q$ 行，第 $i$ 行输入一个操作，格式如上所述。保证 $1\\leq l_i\\leq r_i\\leq n$，$1\\leq u_i\\leq v_i\\leq n$。另外保证所有 $\\texttt{+}$ 类型的操作的 $k$ 之和，加上所有 $\\texttt{?}$ 类型的操作的 $k$ 之和，加上所有 $\\texttt{?}$ 类型的操作的 $m$ 之和不超过 $3 \\times 10^5$。", "outputFormat": "每次 $\\texttt{?}$ 类型的操作输出一行一个整数表示答案。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Kunming I] 生成字符串", "background": "", "description": "给定一个长度为 $n$ 的模板字符串 $S = s_1s_2\\cdots s_n$。一个生成字符串指的是由模板字符串 $S$ 的若干子串连接而成的字符串。更正式地，每个生成字符串 $T = f(k, \\{l_i\\}_{i=1}^k, \\{r_i\\}_{i=1}^k)$ 可以被描述为一个正整数 $k$ 以及 $k$ 对整数 $(l_i, r_i)$，其中 $T = s[l_1:r_1]+s[l_2:r_2]+\\cdots+s[l_k: r_k]$。这里我们用 $s[l: r]$ 表示子串 $s_ls_{l+1}\\cdots s_r$，用 $+$ 表示字符串连接。\n\n您需要维护一个由字符串构成的可重集合 $\\mathbb{A}$，支持以下三种操作：\n- $\\texttt{+ } k\\ l_1\\ r_1\\ l_2\\ r_2\\ \\cdots\\ l_k\\ r_k$：将 $f(k, \\{l_i\\}_{i=1}^k, \\{r_i\\}_{i=1}^k)$ 加入可重集合 $\\mathbb{A}$。\n- $\\texttt{- } t$：将第 $t$ 次操作加入的字符串从可重集合 $\\mathbb{A}$ 里删除。保证第 $t$ 次操作是一次加入操作，且该字符串目前还没有被删除。\n- $\\texttt{? } k\\ l_1\\ r_1\\ l_2\\ r_2\\ \\cdots\\ l_k\\ r_k\\ m\\ u_1\\ v_1\\ u_2\\ v_2\\ \\cdots u_m\\ v_m$：求可重集合 $\\mathbb{A}$ 里有几个字符串以 $f(k, \\{l_i\\}_{i=1}^k, \\{r_i\\}_{i=1}^k)$ 为开头，且以 $f(m, \\{u_i\\}_{i=1}^m, \\{v_i\\}_{i=1}^m)$ 为结尾。", "inputFormat": "每个测试文件仅有一组测试数据。\n\n第一行输入两个整数 $n$ 和 $q$（$1\\leq n, q\\leq 10^5$），表示 $S$ 的长度和操作的数量。\n\n第二行输入一个由小写英文字母构成的字符串 $s_1s_2\\cdots s_n$，表示模板字符串。\n\n对于接下来的 $q$ 行，第 $i$ 行输入一个操作，格式如上所述。保证 $1\\leq l_i\\leq r_i\\leq n$，$1\\leq u_i\\leq v_i\\leq n$。另外保证所有 $\\texttt{+}$ 类型的操作的 $k$ 之和，加上所有 $\\texttt{?}$ 类型的操作的 $k$ 之和，加上所有 $\\texttt{?}$ 类型的操作的 $m$ 之和不超过 $3 \\times 10^5$。", "outputFormat": "每次 $\\texttt{?}$ 类型的操作输出一行一个整数表示答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14221", "type": "P", "difficulty": 4, "samples": [["2\n6 2\n5 3 13 8 10 555\n3 0\n3 6 9", "5\n3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC", "昆明"], "title": "[ICPC 2024 Kunming I] 学而时习之", "background": "", "description": "给定长度为 $n$ 的正整数序列 $a_1, a_2, \\cdots, a_n$ 以及一个非负整数 $k$，您可以执行以下操作至多一次：选择两个整数 $l$ 和 $r$ 满足 $1 \\le l \\le r \\le n$，之后对于每个 $l \\le i \\le r$，将 $a_i$ 变为 $(a_i + k)$。\n\n最大化整个序列的最大公因数。\n\n称整数 $g$ 是整个序列的公因数，若对于所有 $1 \\le i \\le n$ 都满足 $a_i$ 能被 $g$ 整除。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $k$（$1\\leq n\\leq 3 \\times 10^5$，$0\\leq k\\leq 10^{18}$）。\n\n第二行输入 $n$ 个整数 $a_1, a_2, \\cdots, a_n$（$1 \\le a_i \\le 10^{18}$）表示序列。\n\n保证所有数据 $n$ 之和不超过 $3 \\times 10^5$。\n", "outputFormat": "每组数据输出一行一个整数，表示整个序列最大的最大公因数。", "hint": "对于第一组样例数据，选择 $l = 2$ 以及 $r = 4$。序列会变为 $\\{5, 5, 15, 10, 10, 555\\}$。序列的最大公因数是 $5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Kunming I] 学而时习之", "background": "", "description": "给定长度为 $n$ 的正整数序列 $a_1, a_2, \\cdots, a_n$ 以及一个非负整数 $k$，您可以执行以下操作至多一次：选择两个整数 $l$ 和 $r$ 满足 $1 \\le l \\le r \\le n$，之后对于每个 $l \\le i \\le r$，将 $a_i$ 变为 $(a_i + k)$。\n\n最大化整个序列的最大公因数。\n\n称整数 $g$ 是整个序列的公因数，若对于所有 $1 \\le i \\le n$ 都满足 $a_i$ 能被 $g$ 整除。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $k$（$1\\leq n\\leq 3 \\times 10^5$，$0\\leq k\\leq 10^{18}$）。\n\n第二行输入 $n$ 个整数 $a_1, a_2, \\cdots, a_n$（$1 \\le a_i \\le 10^{18}$）表示序列。\n\n保证所有数据 $n$ 之和不超过 $3 \\times 10^5$。\n", "outputFormat": "每组数据输出一行一个整数，表示整个序列最大的最大公因数。", "hint": "对于第一组样例数据，选择 $l = 2$ 以及 $r = 4$。序列会变为 $\\{5, 5, 15, 10, 10, 555\\}$。序列的最大公因数是 $5$。", "locale": "zh-CN"}}}
{"pid": "P14222", "type": "P", "difficulty": 6, "samples": [["3\n5\n1 1\n3 7\n3 4\n4 3\n5 10\n1\n10 100\n3\n10 100\n10 1000\n10 10000", "2\n0\n-1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["二分", "2024", "ICPC", "昆明"], "title": "[ICPC 2024 Kunming I] 收集硬币", "background": "", "description": "有 $10^9$ 个格子排成一行，从左到右编号从 $1$ 到 $10^9$。两个机器人正在格子里巡逻。每个机器人的最大速度是 $v$ 格每秒（$v$ 是整数），表示如果机器人目前在格子 $p$，它在下一秒可以移动到任意一个格子 $p'$，只要满足 $1 \\le p' \\le 10^9$ 且 $|p' - p| \\le v$。\n\n将有 $n$ 枚硬币在格子中出现。第 $i$ 枚硬币会在第 $t_i$ 秒出现在格子 $c_i$。如果有一个机器人同时也位于那个格子，它就会把硬币捡起来。否则硬币会马上消失。\n\n更正式地，在每一秒内，以下事件会依次发生：\n\n- 每个机器人可以移动到距离不超过 $v$ 的格子（也可以待在当前的格子里）。\n- 硬币在格子中出现。\n- 如果至少一个机器人和一枚硬币在同一个格子里，这枚硬币就会被收集。\n- 所有未被收集的硬币消失。\n\n您需要决定两个机器人在第 $1$ 秒开始前的初始位置，并合理地移动它们，使得所有硬币都能被收集，并且 $v$ 尽可能小。输出 $v$ 的最小值。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入一个整数 $n$（$1 \\le n \\le 10^6$）表示格子里将会出现的硬币数量。\n\n对于接下来 $n$ 行，第 $i$ 行输入两个整数 $t_i$ 和 $c_i$（$1 \\le t_i, c_i \\le 10^9$）表示第 $i$ 枚硬币出现的时间以及第 $i$ 枚硬币出现的位置。保证对于所有 $1 \\le i < n$ 有 $t_i \\le t_{i + 1}$。同时保证对于所有 $i \\ne j$ 有 $t_i \\ne t_j$ 或 $c_i \\ne c_j$。\n\n保证所有数据 $n$ 之和不超过 $10^6$。\n", "outputFormat": "每组数据输出一行一个整数，表示机器人最大速度的最小值。如果不可能收集所有硬币，输出 $\\texttt{-1}$。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Kunming I] 收集硬币", "background": "", "description": "有 $10^9$ 个格子排成一行，从左到右编号从 $1$ 到 $10^9$。两个机器人正在格子里巡逻。每个机器人的最大速度是 $v$ 格每秒（$v$ 是整数），表示如果机器人目前在格子 $p$，它在下一秒可以移动到任意一个格子 $p'$，只要满足 $1 \\le p' \\le 10^9$ 且 $|p' - p| \\le v$。\n\n将有 $n$ 枚硬币在格子中出现。第 $i$ 枚硬币会在第 $t_i$ 秒出现在格子 $c_i$。如果有一个机器人同时也位于那个格子，它就会把硬币捡起来。否则硬币会马上消失。\n\n更正式地，在每一秒内，以下事件会依次发生：\n\n- 每个机器人可以移动到距离不超过 $v$ 的格子（也可以待在当前的格子里）。\n- 硬币在格子中出现。\n- 如果至少一个机器人和一枚硬币在同一个格子里，这枚硬币就会被收集。\n- 所有未被收集的硬币消失。\n\n您需要决定两个机器人在第 $1$ 秒开始前的初始位置，并合理地移动它们，使得所有硬币都能被收集，并且 $v$ 尽可能小。输出 $v$ 的最小值。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入一个整数 $n$（$1 \\le n \\le 10^6$）表示格子里将会出现的硬币数量。\n\n对于接下来 $n$ 行，第 $i$ 行输入两个整数 $t_i$ 和 $c_i$（$1 \\le t_i, c_i \\le 10^9$）表示第 $i$ 枚硬币出现的时间以及第 $i$ 枚硬币出现的位置。保证对于所有 $1 \\le i < n$ 有 $t_i \\le t_{i + 1}$。同时保证对于所有 $i \\ne j$ 有 $t_i \\ne t_j$ 或 $c_i \\ne c_j$。\n\n保证所有数据 $n$ 之和不超过 $10^6$。\n", "outputFormat": "每组数据输出一行一个整数，表示机器人最大速度的最小值。如果不可能收集所有硬币，输出 $\\texttt{-1}$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14223", "type": "P", "difficulty": 3, "samples": [["4\n1\n2\n3\n4", "impossible\n1 0\n1 0 2\nimpossible"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "构造", "ICPC", "昆明"], "title": "[ICPC 2024 Kunming I] 乐观向上", "background": "", "description": "求字典序最小的序列 $p_0, p_1, p_2 \\cdots, p_{n-1}$，该序列是 $0, 1, 2, \\cdots, (n - 1)$ 的一个排列，且满足以下限制：对于所有 $0 \\le i < n$，都有 $p_0 \\oplus p_1 \\oplus \\cdots \\oplus p_i > 0$。这里 $\\oplus$ 是按位异或运算。\n\n称一个长度为 $n$ 的序列 $p_0, p_1, \\cdots, p_{n - 1}$ 的字典序小于另一个长度为 $n$ 的序列 $q_0, q_1, \\cdots, q_{n - 1}$，若存在一个整数 $0 \\le k < n$ 使得对于所有 $0 \\le i < k$ 有 $p_i = q_i$，以及 $p_k < q_k$。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入一个整数 $n$（$1 \\le n \\le 10^6$）。\n\n保证所有数据 $n$ 之和不超过 $10^6$。", "outputFormat": "每组数据输出一行 $n$ 个由单个空格分隔的整数，表示字典序最小的且满足限制的排列。如果不存在这种排列，输出 $\\texttt{impossible}$。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Kunming I] 乐观向上", "background": "", "description": "求字典序最小的序列 $p_0, p_1, p_2 \\cdots, p_{n-1}$，该序列是 $0, 1, 2, \\cdots, (n - 1)$ 的一个排列，且满足以下限制：对于所有 $0 \\le i < n$，都有 $p_0 \\oplus p_1 \\oplus \\cdots \\oplus p_i > 0$。这里 $\\oplus$ 是按位异或运算。\n\n称一个长度为 $n$ 的序列 $p_0, p_1, \\cdots, p_{n - 1}$ 的字典序小于另一个长度为 $n$ 的序列 $q_0, q_1, \\cdots, q_{n - 1}$，若存在一个整数 $0 \\le k < n$ 使得对于所有 $0 \\le i < k$ 有 $p_i = q_i$，以及 $p_k < q_k$。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入一个整数 $n$（$1 \\le n \\le 10^6$）。\n\n保证所有数据 $n$ 之和不超过 $10^6$。", "outputFormat": "每组数据输出一行 $n$ 个由单个空格分隔的整数，表示字典序最小的且满足限制的排列。如果不存在这种排列，输出 $\\texttt{impossible}$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14224", "type": "P", "difficulty": 6, "samples": [["3\n11\n1 1 2 1 2 2 3 3 2 3 1\n3\n2024 5 26\n3\n1000000000 1000000000 1000000000", "2564\n36\n20"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "快速数论变换 NTT", "ICPC", "单调栈", "昆明"], "title": "[ICPC 2024 Kunming I] 子数组", "background": "", "description": "给定长度为 $n$ 的整数序列 $a_1, a_2, \\cdots, a_n$，称一个连续子数组 $a_l, a_{l + 1}, \\cdots, a_r$ 是好的，若子数组里的最大元素在子数组里恰好出现了 $k$ 次。对每个 $1 \\le k \\le n$ 计算好的子数组的数量。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入一个整数 $n$（$1 \\le n \\le 4 \\times 10^5$）表示序列的长度。\n\n第二行输入 $n$ 个整数 $a_1, a_2, \\cdots, a_n$（$1 \\le a_i \\le 10^9$）表示序列。\n\n保证所有数据 $n$ 之和不超过 $4 \\times 10^5$。", "outputFormat": "令 $c_i$ 表示 $k = i$ 时好的子数组的数量。为了减少输出的大小，每组数据只需要输出一行一个整数，表示 $\\sum\\limits_{i = 1}^n (i \\times c_i^2)$ 对 $998244353$ 取模的结果。", "hint": "令 $[l, r]$ 表示连续子数组 $a_l, a_{l + 1}, \\cdots, a_r$。对于第一组样例数据：\n\n- $c_1 = 27$，$c_2 = 22$，$c_3 = 17$，而 $c_4, c_5, \\cdots, c_{11}$ 均为 $0$。所以答案为 $(1 \\times 27^2 + 2 \\times 22^2 + 3 \\times 17^2) \\bmod 998244353 = 2564$。\n- 当 $k = 1$ 时，一些好的子数组的例子有 $[3, 3]$（最大元素 $2$ 出现了一次），$[4, 5]$（最大元素 $2$ 出现了一次），以及 $[9, 10]$（最大元素 $3$ 出现了一次）。\n- 当 $k = 2$ 时，一些好的子数组的例子有 $[1, 2]$（最大元素 $1$ 出现了两次），$[4, 6]$（最大元素 $2$ 出现了两次），以及 $[6, 9]$（最大元素 $3$ 出现了两次）。\n- 当 $k = 3$ 时，一些好的子数组的例子有 $[3, 6]$（最大元素 $2$ 出现了三次），$[2, 6]$（最大元素 $2$ 出现了三次），以及 $[1, 11]$（最大元素 $3$ 出现了三次）。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Kunming I] 子数组", "background": "", "description": "给定长度为 $n$ 的整数序列 $a_1, a_2, \\cdots, a_n$，称一个连续子数组 $a_l, a_{l + 1}, \\cdots, a_r$ 是好的，若子数组里的最大元素在子数组里恰好出现了 $k$ 次。对每个 $1 \\le k \\le n$ 计算好的子数组的数量。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入一个整数 $n$（$1 \\le n \\le 4 \\times 10^5$）表示序列的长度。\n\n第二行输入 $n$ 个整数 $a_1, a_2, \\cdots, a_n$（$1 \\le a_i \\le 10^9$）表示序列。\n\n保证所有数据 $n$ 之和不超过 $4 \\times 10^5$。", "outputFormat": "令 $c_i$ 表示 $k = i$ 时好的子数组的数量。为了减少输出的大小，每组数据只需要输出一行一个整数，表示 $\\sum\\limits_{i = 1}^n (i \\times c_i^2)$ 对 $998244353$ 取模的结果。", "hint": "令 $[l, r]$ 表示连续子数组 $a_l, a_{l + 1}, \\cdots, a_r$。对于第一组样例数据：\n\n- $c_1 = 27$，$c_2 = 22$，$c_3 = 17$，而 $c_4, c_5, \\cdots, c_{11}$ 均为 $0$。所以答案为 $(1 \\times 27^2 + 2 \\times 22^2 + 3 \\times 17^2) \\bmod 998244353 = 2564$。\n- 当 $k = 1$ 时，一些好的子数组的例子有 $[3, 3]$（最大元素 $2$ 出现了一次），$[4, 5]$（最大元素 $2$ 出现了一次），以及 $[9, 10]$（最大元素 $3$ 出现了一次）。\n- 当 $k = 2$ 时，一些好的子数组的例子有 $[1, 2]$（最大元素 $1$ 出现了两次），$[4, 6]$（最大元素 $2$ 出现了两次），以及 $[6, 9]$（最大元素 $3$ 出现了两次）。\n- 当 $k = 3$ 时，一些好的子数组的例子有 $[3, 6]$（最大元素 $2$ 出现了三次），$[2, 6]$（最大元素 $2$ 出现了三次），以及 $[1, 11]$（最大元素 $3$ 出现了三次）。", "locale": "zh-CN"}}}
{"pid": "P14225", "type": "P", "difficulty": 2, "samples": [["3\nabccbbbbd\nabcde\nx", "2\n0\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2024", "ICPC", "昆明"], "title": "[ICPC 2024 Kunming I] 左移 2", "background": "", "description": "给定一个由小写字母组成的字符串，称该字符串是美丽的，若字符串中每一对相邻的字符都不相同。例如，$\\texttt{icpc}$ 和 $\\texttt{kunming}$ 是美丽的，但 $\\texttt{hello}$ 不是，因为它的第 $3$ 个和第 $4$ 个字符相同。\n\n给定由小写英文字母组成的，长度为 $n$ 的字符串 $S = s_0s_1\\cdots s_{n-1}$，令 $f(S, d)$ 表示将 $S$ 左移 $d$ 次后获得的字符串。也就是说 $f(S, d) = s_{(d+0)\\bmod n}s_{(d+1)\\bmod n}\\cdots s_{(d+n-1)\\bmod n}$。\n\n令 $g(S, d)$ 表示将 $f(S, d)$ 变得美丽的最小操作次数。每次操作中，您可以将 $f(S, d)$ 中的任意一个字符改为任意小写字母。\n\n找到一个非负整数 $d$ 最小化 $g(S, d)$，并输出这个最小化的值。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入一个仅由小写字母组成的字符串 $s_0s_1\\cdots s_{n-1}$（$1 \\le n \\le 5 \\times 10^5$）。\n\n保证所有数据 $n$ 之和不超过 $5 \\times 10^5$。", "outputFormat": "每组数据输出一行一个整数，表示最小的 $g(S, d)$。", "hint": "对于第一组样例数据，考虑 $d = 5$。有 $f(S, 5) = $ $\\texttt{bbbdabccb}$。对于这个字符串，我们可以将它的第 $2$ 个字符改成 $\\texttt{x}$，并将它的第 $8$ 个字符改成 $\\texttt{y}$。这样字符串就会变成 $\\texttt{bxbdabcyb}$，是一个美丽的字符串。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Kunming I] 左移 2", "background": "", "description": "给定一个由小写字母组成的字符串，称该字符串是美丽的，若字符串中每一对相邻的字符都不相同。例如，$\\texttt{icpc}$ 和 $\\texttt{kunming}$ 是美丽的，但 $\\texttt{hello}$ 不是，因为它的第 $3$ 个和第 $4$ 个字符相同。\n\n给定由小写英文字母组成的，长度为 $n$ 的字符串 $S = s_0s_1\\cdots s_{n-1}$，令 $f(S, d)$ 表示将 $S$ 左移 $d$ 次后获得的字符串。也就是说 $f(S, d) = s_{(d+0)\\bmod n}s_{(d+1)\\bmod n}\\cdots s_{(d+n-1)\\bmod n}$。\n\n令 $g(S, d)$ 表示将 $f(S, d)$ 变得美丽的最小操作次数。每次操作中，您可以将 $f(S, d)$ 中的任意一个字符改为任意小写字母。\n\n找到一个非负整数 $d$ 最小化 $g(S, d)$，并输出这个最小化的值。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入一个仅由小写字母组成的字符串 $s_0s_1\\cdots s_{n-1}$（$1 \\le n \\le 5 \\times 10^5$）。\n\n保证所有数据 $n$ 之和不超过 $5 \\times 10^5$。", "outputFormat": "每组数据输出一行一个整数，表示最小的 $g(S, d)$。", "hint": "对于第一组样例数据，考虑 $d = 5$。有 $f(S, 5) = $ $\\texttt{bbbdabccb}$。对于这个字符串，我们可以将它的第 $2$ 个字符改成 $\\texttt{x}$，并将它的第 $8$ 个字符改成 $\\texttt{y}$。这样字符串就会变成 $\\texttt{bxbdabcyb}$，是一个美丽的字符串。", "locale": "zh-CN"}}}
{"pid": "P14226", "type": "P", "difficulty": 5, "samples": [["2\n5 6 4\n1 2 1 30\n2 3 1 50\n2 5 5 50\n3 4 6 10\n2 4 5 30\n2 5 1 40\n1 70\n6 100\n5 40\n1 30\n3 1 1\n2 3 1 10\n1 100", "11011\n100"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "最短路", "ICPC", "昆明"], "title": "[ICPC 2024 Kunming I] 冲向黄金城", "background": "", "description": "某个国家有 $n$ 座城市以及 $m$ 条连接城市的双向铁路。第 $i$ 条铁路由第 $c_i$ 家铁路公司运营，铁路的长度是 $l_i$。\n\n您想要从城市 $1$ 开始进行全国旅行。您已经为旅行购买了 $k$ 张车票。第 $i$ 张车票可以记为两个整数 $a_i$ 和 $b_i$，表示如果您使用了这张车票，就可以一次性经过若干条均由公司 $a_i$ 运营的，且总长度不超过 $b_i$ 的铁路。即使您使用了车票，也可以选择待在当前城市。您同时只能使用一张车票，且每张车票只能使用一次。\n\n由于决定车票的使用顺序太麻烦了，您打算直接按现有的顺序使用车票。更正式地，您将执行 $k$ 次操作。在第 $i$ 次操作中，您可以选择待在当前的城市 $u$；也可以选择一座不同的城市 $v$，满足城市 $u$ 和 $v$ 之间存在一条路径，且路径上的所有铁路均由公司 $a_i$ 运营，且铁路总长不超过 $b_i$，然后移动到城市 $v$。\n\n对于每座城市，判断在使用 $k$ 张车票之后能否到达该城市。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入三个整数 $n$，$m$ 和 $k$（$2 \\le n \\le 5 \\times 10^5$，$1 \\le m \\le 5 \\times 10^5$，$1 \\le k \\le 5 \\times 10^5$）表示城市的数量，铁路的数量以及车票的数量。\n\n对于接下来 $m$ 行，第 $i$ 行输入四个整数 $u_i$，$v_i$，$c_i$ 和 $l_i$（$1 \\le u_i, v_i \\le n$，$u_i \\ne v_i$，$1 \\le c_i \\le m$，$1 \\le l_i \\le 10^9$），表示第 $i$ 条铁路连接了城市 $u_i$ 和 $v_i$，该铁路由公司 $c_i$ 运营，且铁路长度为 $l_i$。注意，可能有多条铁路连接同一对城市。\n\n对于接下来 $k$ 行，第 $i$ 行输入两个整数 $a_i$ 和 $b_i$（$1 \\le a_i \\le m$，$1 \\le b_i \\le 10^9$），表示如果您使用了第 $i$ 张车票，就可以一次性经过若干条均由公司 $a_i$ 运营的，且总长度不超过 $b_i$ 的铁路。\n\n保证所有数据 $n$ 之和，$m$ 之和与 $k$ 之和均不超过 $5 \\times 10^5$。", "outputFormat": "每组数据输出一行一个长度为 $n$ 的字符串 $s_1s_2\\cdots s_n$，其中每个字符要么是 $0$，要么是 $1$。如果您可以用 $k$ 张车票从城市 $1$ 到达城市 $i$，则 $s_i = 1$；否则 $s_i = 0$。", "hint": "对于第一组样例数据：\n\n- 为了到达城市 $4$，您可以使用第 $1$ 张车票从城市 $1$ 移动到城市 $2$，然后在使用第 $2$ 张车票的时候待在城市 $2$，然后使用第 $3$ 张车票从城市 $2$ 移动到城市 $4$，然后在使用第 $4$ 张车票的时候待在城市 $4$。\n- 为了到达城市 $5$，您可以使用第 $1$ 张车票，经由第 $1$ 条和第 $6$ 条铁路从城市 $1$ 移动到城市 $5$，然后在使用后续车票的时候待在城市 $5$。\n- 由于您不能更改使用车票的顺序，您无法到达城市 $3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Kunming I] 冲向黄金城", "background": "", "description": "某个国家有 $n$ 座城市以及 $m$ 条连接城市的双向铁路。第 $i$ 条铁路由第 $c_i$ 家铁路公司运营，铁路的长度是 $l_i$。\n\n您想要从城市 $1$ 开始进行全国旅行。您已经为旅行购买了 $k$ 张车票。第 $i$ 张车票可以记为两个整数 $a_i$ 和 $b_i$，表示如果您使用了这张车票，就可以一次性经过若干条均由公司 $a_i$ 运营的，且总长度不超过 $b_i$ 的铁路。即使您使用了车票，也可以选择待在当前城市。您同时只能使用一张车票，且每张车票只能使用一次。\n\n由于决定车票的使用顺序太麻烦了，您打算直接按现有的顺序使用车票。更正式地，您将执行 $k$ 次操作。在第 $i$ 次操作中，您可以选择待在当前的城市 $u$；也可以选择一座不同的城市 $v$，满足城市 $u$ 和 $v$ 之间存在一条路径，且路径上的所有铁路均由公司 $a_i$ 运营，且铁路总长不超过 $b_i$，然后移动到城市 $v$。\n\n对于每座城市，判断在使用 $k$ 张车票之后能否到达该城市。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入三个整数 $n$，$m$ 和 $k$（$2 \\le n \\le 5 \\times 10^5$，$1 \\le m \\le 5 \\times 10^5$，$1 \\le k \\le 5 \\times 10^5$）表示城市的数量，铁路的数量以及车票的数量。\n\n对于接下来 $m$ 行，第 $i$ 行输入四个整数 $u_i$，$v_i$，$c_i$ 和 $l_i$（$1 \\le u_i, v_i \\le n$，$u_i \\ne v_i$，$1 \\le c_i \\le m$，$1 \\le l_i \\le 10^9$），表示第 $i$ 条铁路连接了城市 $u_i$ 和 $v_i$，该铁路由公司 $c_i$ 运营，且铁路长度为 $l_i$。注意，可能有多条铁路连接同一对城市。\n\n对于接下来 $k$ 行，第 $i$ 行输入两个整数 $a_i$ 和 $b_i$（$1 \\le a_i \\le m$，$1 \\le b_i \\le 10^9$），表示如果您使用了第 $i$ 张车票，就可以一次性经过若干条均由公司 $a_i$ 运营的，且总长度不超过 $b_i$ 的铁路。\n\n保证所有数据 $n$ 之和，$m$ 之和与 $k$ 之和均不超过 $5 \\times 10^5$。", "outputFormat": "每组数据输出一行一个长度为 $n$ 的字符串 $s_1s_2\\cdots s_n$，其中每个字符要么是 $0$，要么是 $1$。如果您可以用 $k$ 张车票从城市 $1$ 到达城市 $i$，则 $s_i = 1$；否则 $s_i = 0$。", "hint": "对于第一组样例数据：\n\n- 为了到达城市 $4$，您可以使用第 $1$ 张车票从城市 $1$ 移动到城市 $2$，然后在使用第 $2$ 张车票的时候待在城市 $2$，然后使用第 $3$ 张车票从城市 $2$ 移动到城市 $4$，然后在使用第 $4$ 张车票的时候待在城市 $4$。\n- 为了到达城市 $5$，您可以使用第 $1$ 张车票，经由第 $1$ 条和第 $6$ 条铁路从城市 $1$ 移动到城市 $5$，然后在使用后续车票的时候待在城市 $5$。\n- 由于您不能更改使用车票的顺序，您无法到达城市 $3$。", "locale": "zh-CN"}}}
{"pid": "P14227", "type": "P", "difficulty": 6, "samples": [["5\n\n3\n\n4\n\n2\n", "\n0 3 1 3 2 2\n\n0 3 1 5 2 2\n\n0 3 5 4 4 4\n\n1 3 1 5 2 4"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "交互题", "Special Judge", "ICPC", "昆明"], "title": "[ICPC 2024 Kunming I] 排列", "background": "", "description": "这是一道交互题。\n\n有一个隐藏的 $n$ 的排列。请回忆：$n$ 的排列指的是一个序列，从 $1$ 到 $n$（含两端）的每个整数在序列中都恰好出现一次。Piggy 准备通过若干次询问找出这个隐藏的排列。\n\n每次询问包含一个长度为 $n$ 的整数序列（可以不是排列），每个元素的取值范围从 $1$ 到 $n$（含两端）。每次询问之后，Piggy 会收到一个答案 $x$，表示他询问的序列中，有几个位置和隐藏的排列相同。例如，假设隐藏的排列是 $\\{1, 3, 4, 2, 5\\}$，Piggy 询问的序列是 $\\{2, 3, 5, 2, 5\\}$，那么他将收到 $3$ 作为回答。\n\n然而 Piggy 最近太忙了，所以他把问题交给了您。您需要在 $6666$ 次询问内找出这个排列。", "inputFormat": "每个测试文件仅有一组测试数据。\n\n第一行输入一个整数 $n$（$1 \\le n \\le 10^3$），表示隐藏的排列的长度。\n\n### 交互格式\n\n要提出询问，请输出一行。首先输出一个 $\\texttt{0}$，之后跟一个空格，然后输出 $n$ 个范围在 $1$ 到 $n$ 之间的整数，整数之间由单个空格分隔。在清空输出缓冲区之后，您的程序需要读入一个整数 $x$，表示对您的询问的回答。\n\n要猜想排列，请输出一行。首先输出一个 $\\texttt{1}$，之后跟一个空格，然后输出一个 $n$ 的排列，整数之间由单个空格分隔。在清空输出缓冲区之后，您的程序应该立即退出。\n\n请注意，每组测试数据的答案都是预先确定的。也就是说，裁判程序并不是适应性的。还请注意，猜想排列不算一次询问。\n\n清空输出缓冲区可以使用以下方式：\n\n- C 和 C++ 使用 $\\texttt{fflush(stdout)}$（如果您使用 $\\texttt{printf}$）或 $\\texttt{cout.flush()}$（如果您使用 $\\texttt{cout}$）。\n- Java 使用 $\\texttt{System.out.flush()}$。\n- Python 使用 $\\texttt{stdout.flush()}$。", "outputFormat": "", "hint": "请注意，如果您收到了 Time Limit Exceeded 的评测结果，有可能是因为您的询问不合法，或您的询问次数超出了限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Kunming I] 排列", "background": "", "description": "这是一道交互题。\n\n有一个隐藏的 $n$ 的排列。请回忆：$n$ 的排列指的是一个序列，从 $1$ 到 $n$（含两端）的每个整数在序列中都恰好出现一次。Piggy 准备通过若干次询问找出这个隐藏的排列。\n\n每次询问包含一个长度为 $n$ 的整数序列（可以不是排列），每个元素的取值范围从 $1$ 到 $n$（含两端）。每次询问之后，Piggy 会收到一个答案 $x$，表示他询问的序列中，有几个位置和隐藏的排列相同。例如，假设隐藏的排列是 $\\{1, 3, 4, 2, 5\\}$，Piggy 询问的序列是 $\\{2, 3, 5, 2, 5\\}$，那么他将收到 $3$ 作为回答。\n\n然而 Piggy 最近太忙了，所以他把问题交给了您。您需要在 $6666$ 次询问内找出这个排列。", "inputFormat": "每个测试文件仅有一组测试数据。\n\n第一行输入一个整数 $n$（$1 \\le n \\le 10^3$），表示隐藏的排列的长度。\n\n### 交互格式\n\n要提出询问，请输出一行。首先输出一个 $\\texttt{0}$，之后跟一个空格，然后输出 $n$ 个范围在 $1$ 到 $n$ 之间的整数，整数之间由单个空格分隔。在清空输出缓冲区之后，您的程序需要读入一个整数 $x$，表示对您的询问的回答。\n\n要猜想排列，请输出一行。首先输出一个 $\\texttt{1}$，之后跟一个空格，然后输出一个 $n$ 的排列，整数之间由单个空格分隔。在清空输出缓冲区之后，您的程序应该立即退出。\n\n请注意，每组测试数据的答案都是预先确定的。也就是说，裁判程序并不是适应性的。还请注意，猜想排列不算一次询问。\n\n清空输出缓冲区可以使用以下方式：\n\n- C 和 C++ 使用 $\\texttt{fflush(stdout)}$（如果您使用 $\\texttt{printf}$）或 $\\texttt{cout.flush()}$（如果您使用 $\\texttt{cout}$）。\n- Java 使用 $\\texttt{System.out.flush()}$。\n- Python 使用 $\\texttt{stdout.flush()}$。", "outputFormat": "", "hint": "请注意，如果您收到了 Time Limit Exceeded 的评测结果，有可能是因为您的询问不合法，或您的询问次数超出了限制。", "locale": "zh-CN"}}}
{"pid": "P14228", "type": "P", "difficulty": 5, "samples": [["2\n3 2 4\n1 1\n0 2\n0 0\n1 100 100\n1000 1000", "34\n1020100"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "二分", "2024", "颜色段均摊（珂朵莉树 ODT）", "扫描线", "ICPC", "昆明"], "title": "[ICPC 2024 Kunming I] 漫步野径", "background": "", "description": "堡堡正在一块无穷大的二维平面上散步。对于平面上每个满足 $x$ 和 $y$ 均是整数的点 $(x, y)$，都有一条双向小径连接点 $(x, y)$ 和 $(x + 1, y)$，还有另一条双向小径连接点 $(x, y)$ 和 $(x, y + 1)$。另外，还有 $n$ 条额外的双向小径，其中第 $i$ 条连接点 $(x_i, y_i)$ 和 $(x_i + 1, y_i + 1)$。\n\n堡堡只能沿着小径移动。令 $f(x, y)$ 表示堡堡从点 $(0, 0)$ 出发到达点 $(x, y)$ 最少需要经过几条小径。给定两个整数 $p$ 和 $q$，计算\n\n$$\n\\sum\\limits_{x = 0}^p \\sum\\limits_{y = 0}^q f(x, y)\n$$", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入三个整数 $n$，$p$ 和 $q$（$1 \\le n \\le 10^6$，$0 \\le p, q \\le 10^6$）。它们的含义如上所述。\n\n对于接下来的 $n$ 行，第 $i$ 行输入两个整数 $x_i$ 和 $y_i$（$0 \\le x_i, y_i \\le 10^6$）表示第 $i$ 条额外小径连接点 $(x_i, y_i)$ 和 $(x_i + 1, y_i + 1)$。保证对于所有 $i \\ne j$ 有 $x_i \\ne x_j$ 或 $y_i \\ne y_j$。\n\n保证所有数据 $n$ 之和不超过 $10^6$。请注意，$p$ 与 $q$ 之和没有限制。", "outputFormat": "每组数据输出一行一个整数表示答案。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Kunming I] 漫步野径", "background": "", "description": "堡堡正在一块无穷大的二维平面上散步。对于平面上每个满足 $x$ 和 $y$ 均是整数的点 $(x, y)$，都有一条双向小径连接点 $(x, y)$ 和 $(x + 1, y)$，还有另一条双向小径连接点 $(x, y)$ 和 $(x, y + 1)$。另外，还有 $n$ 条额外的双向小径，其中第 $i$ 条连接点 $(x_i, y_i)$ 和 $(x_i + 1, y_i + 1)$。\n\n堡堡只能沿着小径移动。令 $f(x, y)$ 表示堡堡从点 $(0, 0)$ 出发到达点 $(x, y)$ 最少需要经过几条小径。给定两个整数 $p$ 和 $q$，计算\n\n$$\n\\sum\\limits_{x = 0}^p \\sum\\limits_{y = 0}^q f(x, y)\n$$", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入三个整数 $n$，$p$ 和 $q$（$1 \\le n \\le 10^6$，$0 \\le p, q \\le 10^6$）。它们的含义如上所述。\n\n对于接下来的 $n$ 行，第 $i$ 行输入两个整数 $x_i$ 和 $y_i$（$0 \\le x_i, y_i \\le 10^6$）表示第 $i$ 条额外小径连接点 $(x_i, y_i)$ 和 $(x_i + 1, y_i + 1)$。保证对于所有 $i \\ne j$ 有 $x_i \\ne x_j$ 或 $y_i \\ne y_j$。\n\n保证所有数据 $n$ 之和不超过 $10^6$。请注意，$p$ 与 $q$ 之和没有限制。", "outputFormat": "每组数据输出一行一个整数表示答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14229", "type": "P", "difficulty": 5, "samples": [["3\n5\n1 1 1\n0 0\n1 0\n5 0\n3 3\n0 5\n6\n2 4 1\n2 0\n4 0\n6 3\n4 6\n2 6\n0 3\n4\n3 3 1\n3 0\n6 3\n3 6\n0 3", "5\n24\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["计算几何", "2024", "ICPC", "昆明"], "title": "[ICPC 2024 Kunming I] 意大利美食", "background": "", "description": "堡堡为您准备了一份披萨！这个披萨是一个凸多边形，每条饼边里都有芝士夹心。但这些夹心边很脆弱，导致切披萨的时候只能经过多边形的顶点，而不能从边的中间切开。不幸的是，披萨上有一片您肯定不喜欢的，巨大的圆形菠萝片。\n\n求沿着直线切一刀之后，可以获得的最大的没有菠萝的披萨的面积。称一块披萨上没有菠萝，当且仅当菠萝没有任何部分严格位于披萨块内。也就是说，菠萝和披萨的相交面积为 $0$。", "inputFormat": "有多个测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入一个整数 $n$（$3 \\le n \\le 10^5$）表示披萨的顶点数。\n\n第二行输入三个整数 $x_c$，$y_c$ 和 $r$（$-10^9 \\le x_c,y_c \\le 10^9$，$1 \\le r \\le 10^9$）表示菠萝的中心坐标和半径。\n\n对于接下来的 $n$ 行，第 $i$ 行输入两个整数 $x_i$ 和 $y_i$（$-10^9 \\le x_i,y_i \\le 10^9$）表示第 $i$ 个顶点的坐标。顶点按逆时针顺序列出。保证任意两点不重合。但可能有三个点在同一直线上。\n\n保证菠萝的任何部分都不会超出披萨的边界。另外保证所有数据 $n$ 之和不超过 $10^5$。", "outputFormat": "每组测试数据输出一行一个整数，表示最大的没有菠萝的披萨的面积乘以 $2$。可以证明这个值始终是一个整数。如果无法切出没有菠萝的披萨块，输出 $0$。\n", "hint": "样例数据如下图所示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/pk4601qh.png)\n:::", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Kunming I] 意大利美食", "background": "", "description": "堡堡为您准备了一份披萨！这个披萨是一个凸多边形，每条饼边里都有芝士夹心。但这些夹心边很脆弱，导致切披萨的时候只能经过多边形的顶点，而不能从边的中间切开。不幸的是，披萨上有一片您肯定不喜欢的，巨大的圆形菠萝片。\n\n求沿着直线切一刀之后，可以获得的最大的没有菠萝的披萨的面积。称一块披萨上没有菠萝，当且仅当菠萝没有任何部分严格位于披萨块内。也就是说，菠萝和披萨的相交面积为 $0$。", "inputFormat": "有多个测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入一个整数 $n$（$3 \\le n \\le 10^5$）表示披萨的顶点数。\n\n第二行输入三个整数 $x_c$，$y_c$ 和 $r$（$-10^9 \\le x_c,y_c \\le 10^9$，$1 \\le r \\le 10^9$）表示菠萝的中心坐标和半径。\n\n对于接下来的 $n$ 行，第 $i$ 行输入两个整数 $x_i$ 和 $y_i$（$-10^9 \\le x_i,y_i \\le 10^9$）表示第 $i$ 个顶点的坐标。顶点按逆时针顺序列出。保证任意两点不重合。但可能有三个点在同一直线上。\n\n保证菠萝的任何部分都不会超出披萨的边界。另外保证所有数据 $n$ 之和不超过 $10^5$。", "outputFormat": "每组测试数据输出一行一个整数，表示最大的没有菠萝的披萨的面积乘以 $2$。可以证明这个值始终是一个整数。如果无法切出没有菠萝的披萨块，输出 $0$。\n", "hint": "样例数据如下图所示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/pk4601qh.png)\n:::", "locale": "zh-CN"}}}
{"pid": "P14230", "type": "P", "difficulty": 6, "samples": [["3\n1 2 3", "19"], ["3\n1 2 2", "12"], ["10\n5 5 2 5 3 4 1 4 4 3 \n", "15735"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2024", "O2优化"], "title": "不连续子串 / subseq", "background": "前有连续子序列，接下来，读题很有用。\n\n前无马。", "description": "给你一个长为 $n$ 的序列 $a_{1\\dots n}$，你需要求出其所有本质不同非空子序列的本质不同非空子序列数量之和。\n\n形式化地，你需要求出有多少正整数序列对 $(b_{1\\dots l_1},c_{1\\dots l_2})$，满足存在两个序列 $p_{1\\dots l_1},q_{1\\dots l_2}$ 使得：\n- $1\\le p_1<p_2<\\dots<p_{l_1}\\le n$；\n- $\\forall i\\in[1,l_1],b_i=a_{p_i}$；\n- $1\\le q_1<q_2<\\dots<q_{l_2}\\le l_1$；\n- $\\forall i\\in[1,l_2],c_i=b_{q_i}$。\n\n将答案对 $10^9+7$ 取模。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个正整数描述 $a_{1\\dots n}$。", "outputFormat": "一行一个整数表示答案，对 $10^9+7$ 取模。", "hint": "### 样例 1 解释\n有如下共 $19$ 种合法序列对：\n\n- $b=(1,2,3),c=(1,2,3)$；\n- $b=(1,2,3),c=(1,2)$；\n- $b=(1,2,3),c=(1,3)$；\n- $b=(1,2,3),c=(2,3)$；\n- $b=(1,2,3),c=(1)$；\n- $b=(1,2,3),c=(2)$；\n- $b=(1,2,3),c=(3)$；\n- $b=(1,2),c=(1,2)$；\n- $b=(1,2),c=(1)$；\n- $b=(1,2),c=(2)$；\n- $b=(2,3),c=(2,3)$；\n- $b=(2,3),c=(2)$；\n- $b=(2,3),c=(3)$；\n- $b=(1,3),c=(1,3)$；\n- $b=(1,3),c=(1)$；\n- $b=(1,3),c=(3)$；\n- $b=(1),c=(1)$；\n- $b=(2),c=(2)$；\n- $b=(3),c=(3)$。\n\n### 样例 2 解释\n\n有如下共 $12$ 种合法序列对：\n\n- $b=(1,2,2),c=(1,2,2)$；\n- $b=(1,2,2),c=(1,2)$；\n- $b=(1,2,2),c=(2,2)$；\n- $b=(1,2,2),c=(1)$；\n- $b=(1,2,2),c=(2)$；\n- $b=(1,2),c=(1,2)$；\n- $b=(1,2),c=(1)$；\n- $b=(1,2),c=(2)$；\n- $b=(2,2),c=(2,2)$；\n- $b=(2,2),c=(2)$；\n- $b=(1),c=(1)$；\n- $b=(2),c=(2)$。\n\n### 数据范围与约定\n\n**本题采用捆绑测试。**\n\n::cute-table\n| 子任务编号 | $n\\le$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | 无 | $10$ |\n| $2$ | $20$ | ^ | $10$ |\n| $3$ | $100$ | ^ | $15$ |\n| $4$ | $500$ | ^ | $15$ |\n| $5$ | $8000$ | $a_i\\le 2$ | $15$ |\n| $6$ | ^ | $a_i\\le 5$ | $10$ |\n| $7$ | ^ | 无 | $25$ |\n\n对于所有数据，保证 $1\\le n\\le 8000$，$1\\le a_i\\le n$。\n\n**保证本题模数 $\\bm{10^9+7}$ 不等于 $\\bm{998244853}$ 或 $\\bm{2^{23}}$。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "不连续子串 / subseq", "background": "前有连续子序列，接下来，读题很有用。\n\n前无马。", "description": "给你一个长为 $n$ 的序列 $a_{1\\dots n}$，你需要求出其所有本质不同非空子序列的本质不同非空子序列数量之和。\n\n形式化地，你需要求出有多少正整数序列对 $(b_{1\\dots l_1},c_{1\\dots l_2})$，满足存在两个序列 $p_{1\\dots l_1},q_{1\\dots l_2}$ 使得：\n- $1\\le p_1<p_2<\\dots<p_{l_1}\\le n$；\n- $\\forall i\\in[1,l_1],b_i=a_{p_i}$；\n- $1\\le q_1<q_2<\\dots<q_{l_2}\\le l_1$；\n- $\\forall i\\in[1,l_2],c_i=b_{q_i}$。\n\n将答案对 $10^9+7$ 取模。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个正整数描述 $a_{1\\dots n}$。", "outputFormat": "一行一个整数表示答案，对 $10^9+7$ 取模。", "hint": "### 样例 1 解释\n有如下共 $19$ 种合法序列对：\n\n- $b=(1,2,3),c=(1,2,3)$；\n- $b=(1,2,3),c=(1,2)$；\n- $b=(1,2,3),c=(1,3)$；\n- $b=(1,2,3),c=(2,3)$；\n- $b=(1,2,3),c=(1)$；\n- $b=(1,2,3),c=(2)$；\n- $b=(1,2,3),c=(3)$；\n- $b=(1,2),c=(1,2)$；\n- $b=(1,2),c=(1)$；\n- $b=(1,2),c=(2)$；\n- $b=(2,3),c=(2,3)$；\n- $b=(2,3),c=(2)$；\n- $b=(2,3),c=(3)$；\n- $b=(1,3),c=(1,3)$；\n- $b=(1,3),c=(1)$；\n- $b=(1,3),c=(3)$；\n- $b=(1),c=(1)$；\n- $b=(2),c=(2)$；\n- $b=(3),c=(3)$。\n\n### 样例 2 解释\n\n有如下共 $12$ 种合法序列对：\n\n- $b=(1,2,2),c=(1,2,2)$；\n- $b=(1,2,2),c=(1,2)$；\n- $b=(1,2,2),c=(2,2)$；\n- $b=(1,2,2),c=(1)$；\n- $b=(1,2,2),c=(2)$；\n- $b=(1,2),c=(1,2)$；\n- $b=(1,2),c=(1)$；\n- $b=(1,2),c=(2)$；\n- $b=(2,2),c=(2,2)$；\n- $b=(2,2),c=(2)$；\n- $b=(1),c=(1)$；\n- $b=(2),c=(2)$。\n\n### 数据范围与约定\n\n**本题采用捆绑测试。**\n\n::cute-table\n| 子任务编号 | $n\\le$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | 无 | $10$ |\n| $2$ | $20$ | ^ | $10$ |\n| $3$ | $100$ | ^ | $15$ |\n| $4$ | $500$ | ^ | $15$ |\n| $5$ | $8000$ | $a_i\\le 2$ | $15$ |\n| $6$ | ^ | $a_i\\le 5$ | $10$ |\n| $7$ | ^ | 无 | $25$ |\n\n对于所有数据，保证 $1\\le n\\le 8000$，$1\\le a_i\\le n$。\n\n**保证本题模数 $\\bm{10^9+7}$ 不等于 $\\bm{998244853}$ 或 $\\bm{2^{23}}$。**", "locale": "zh-CN"}}}
{"pid": "P14231", "type": "P", "difficulty": 7, "samples": [["6 6\n4 2 1 6 3 3 \n3 5 3\n1 5 5\n1 6 3\n3 5 2\n4 6 2\n1 5 3", "9\n9\n4\n4\n6\n4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "O2优化", "整体二分"], "title": "复读机 / repeat", "background": "模拟赛偶遇联考，子序列复读强如怪物，拼尽全力无法战胜。\n\n并非偶遇，并非怪物，并非无法战胜。", "description": "给你一个长度为 $n$ 的序列 $a_{1\\dots n}$。\n\n接下来有 $q$ 次查询，每次给出一个区间 $[l,r]$ 和 $k$，你需要：\n\n- 在区间中选择一个长为 $k$ 的子序列，最小化相邻两项的和的最大值。\n\n形式化地说，选择一组 $l\\le p_1 <p_2 <\\dots <p_k \\le r$，最小化 $\\displaystyle\\max_{i=1}^{k-1} (a_{p_i}+a_{p_{i+1}})$。", "inputFormat": "第一行两个整数 $n,q$。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$。\n\n接下来 $q$ 行，每行 $3$ 个整数 $l,r,k$ 表示一次询问。", "outputFormat": "共 $q$ 行，每行一个整数表示答案。", "hint": "### 数据范围与约定\n\n**本题采用捆绑测试。**\n\n::cute-table\n| 子任务编号 | $n\\le$ | $q\\le$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $18$ | $18$ | 无 | $5$ |\n| $2$ | $40$ | $2\\times10^5$ | ^ | $10$ |\n| $3$ | $1000$ | $1000$ | ^ | $5$ |\n| $4$ | $10^5$ | $10$ | ^ | $20$ |\n| $5$ | ^ | $2\\times 10^5$ | $a_i\\le 2$ | $15$ |\n| $6$ | ^ | ^ | $a_i\\le 5$ | $15$ |\n| $7$ | ^ | ^ | 无 | $25$ |\n| $8$ | $3\\times 10^5$ | $3\\times 10^5$ | ^ | $5$ |\n\n\n对于所有数据，保证 $1\\le n,q\\le 3\\times 10^5$，$1\\le a_i \\le n$，$1\\le l\\le r\\le n$，$2\\le k\\le r-l+1$。\n\n**保证你在本场模拟赛的得分不超过 $\\bm{998244853}$。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "复读机 / repeat", "background": "模拟赛偶遇联考，子序列复读强如怪物，拼尽全力无法战胜。\n\n并非偶遇，并非怪物，并非无法战胜。", "description": "给你一个长度为 $n$ 的序列 $a_{1\\dots n}$。\n\n接下来有 $q$ 次查询，每次给出一个区间 $[l,r]$ 和 $k$，你需要：\n\n- 在区间中选择一个长为 $k$ 的子序列，最小化相邻两项的和的最大值。\n\n形式化地说，选择一组 $l\\le p_1 <p_2 <\\dots <p_k \\le r$，最小化 $\\displaystyle\\max_{i=1}^{k-1} (a_{p_i}+a_{p_{i+1}})$。", "inputFormat": "第一行两个整数 $n,q$。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$。\n\n接下来 $q$ 行，每行 $3$ 个整数 $l,r,k$ 表示一次询问。", "outputFormat": "共 $q$ 行，每行一个整数表示答案。", "hint": "### 数据范围与约定\n\n**本题采用捆绑测试。**\n\n::cute-table\n| 子任务编号 | $n\\le$ | $q\\le$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $18$ | $18$ | 无 | $5$ |\n| $2$ | $40$ | $2\\times10^5$ | ^ | $10$ |\n| $3$ | $1000$ | $1000$ | ^ | $5$ |\n| $4$ | $10^5$ | $10$ | ^ | $20$ |\n| $5$ | ^ | $2\\times 10^5$ | $a_i\\le 2$ | $15$ |\n| $6$ | ^ | ^ | $a_i\\le 5$ | $15$ |\n| $7$ | ^ | ^ | 无 | $25$ |\n| $8$ | $3\\times 10^5$ | $3\\times 10^5$ | ^ | $5$ |\n\n\n对于所有数据，保证 $1\\le n,q\\le 3\\times 10^5$，$1\\le a_i \\le n$，$1\\le l\\le r\\le n$，$2\\le k\\le r-l+1$。\n\n**保证你在本场模拟赛的得分不超过 $\\bm{998244853}$。**", "locale": "zh-CN"}}}
{"pid": "P14232", "type": "P", "difficulty": 4, "samples": [["3 \n3 2 1", "1\n2: 3 1"], ["5 \n2 3 1 5 4", "2 \n3: 1 2 3 \n2: 5 4 "], ["5 \n1 2 3 4 5\n", "0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2011", "Special Judge", "排序", "构造", "COI（克罗地亚）"], "title": "[COI 2011] 排序 / SORT", "background": "译自 [COI 2011 T1](https://hsin.hr/hio2011/zadaci/)。", "description": "为了将工厂中的工作自动化，Mirko 希望利用一台老旧的分拣机器人来整理箱子。工厂中有 $N$ 个箱子，编号分别为 $1$ 到 $N$ 的不同整数，需要按照编号升序排列。\n\n这台分拣机器人只能执行一种特定操作：对于给定的一组不同位置，机器人会循环移动这些位置上的箱子。例如，如果初始箱子顺序为 $[4, 1, 5, 2, 3]$，而 Mirko 向机器人发出指令 $[2, 1, 3]$，则机器人会将位置 $2$ 的箱子移到位置 $1$，位置 $1$ 的箱子移到位置 $3$，位置 $3$ 的箱子移到位置 $2$。操作后的箱子顺序将变为 $[1, 5, 4, 2, 3]$。\n\n请编写一个程序，设计必要的指令，使得机器人能够用最少的操作次数将给定的箱子序列排序。在此过程中，单次操作的长度（即需要循环移动的位置数量）并不重要。\n", "inputFormat": "第一行输入一个整数 $N$ $(2 \\le N \\le 1000)$，表示仓库中的箱子数量。\n\n第二行包含 $N$ 个不同的正整数，按顺序表示箱子的初始顺序标签。\n", "outputFormat": "第一行输出一个整数 $X$，表示所需的最少操作次数。\n\n接下来的 $X$ 行每行描述一次操作：首先输出一个正整数表示该操作涉及的位置总数，接着是一个 `:` 字符、一个空格，然后按顺序列出需要循环移动的位置，各位置之间用一个空格分隔。\n\n**注意**：解不一定唯一。如果存在多个可能的解，输出其中任意一个即可。\n", "hint": "如果程序在某个测试用例中的操作次数不超过 $1000$ 但也并非最少的，只要能够正确排序就可以获得该测试点 $50\\%$ 的分数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COI 2011] 排序 / SORT", "background": "译自 [COI 2011 T1](https://hsin.hr/hio2011/zadaci/)。", "description": "为了将工厂中的工作自动化，Mirko 希望利用一台老旧的分拣机器人来整理箱子。工厂中有 $N$ 个箱子，编号分别为 $1$ 到 $N$ 的不同整数，需要按照编号升序排列。\n\n这台分拣机器人只能执行一种特定操作：对于给定的一组不同位置，机器人会循环移动这些位置上的箱子。例如，如果初始箱子顺序为 $[4, 1, 5, 2, 3]$，而 Mirko 向机器人发出指令 $[2, 1, 3]$，则机器人会将位置 $2$ 的箱子移到位置 $1$，位置 $1$ 的箱子移到位置 $3$，位置 $3$ 的箱子移到位置 $2$。操作后的箱子顺序将变为 $[1, 5, 4, 2, 3]$。\n\n请编写一个程序，设计必要的指令，使得机器人能够用最少的操作次数将给定的箱子序列排序。在此过程中，单次操作的长度（即需要循环移动的位置数量）并不重要。\n", "inputFormat": "第一行输入一个整数 $N$ $(2 \\le N \\le 1000)$，表示仓库中的箱子数量。\n\n第二行包含 $N$ 个不同的正整数，按顺序表示箱子的初始顺序标签。\n", "outputFormat": "第一行输出一个整数 $X$，表示所需的最少操作次数。\n\n接下来的 $X$ 行每行描述一次操作：首先输出一个正整数表示该操作涉及的位置总数，接着是一个 `:` 字符、一个空格，然后按顺序列出需要循环移动的位置，各位置之间用一个空格分隔。\n\n**注意**：解不一定唯一。如果存在多个可能的解，输出其中任意一个即可。\n", "hint": "如果程序在某个测试用例中的操作次数不超过 $1000$ 但也并非最少的，只要能够正确排序就可以获得该测试点 $50\\%$ 的分数。", "locale": "zh-CN"}}}
{"pid": "P14233", "type": "P", "difficulty": 4, "samples": [["5 \n00:00:00 - 00:00:01 \n00:00:01 - 00:00:03 \n00:00:00 - 00:00:02 \n00:00:05 - 00:00:09 \n00:00:06 - 00:00:06 \n5 \n00:00:00 - 00:00:03 \n00:00:07 - 00:00:09 \n00:00:06 - 00:00:06 \n00:00:05 - 00:00:09 \n00:00:00 - 00:00:09", "2.0000000000 \n1.0000000000 \n2.0000000000 \n1.2000000000 \n1.4000000000"], ["3 \n00:00:00 - 10:00:00 \n10:00:00 - 00:00:00 \n01:01:01 - 02:02:02 \n4 \n00:00:00 - 23:59:59 \n23:59:59 - 23:59:58 \n23:59:59 - 23:59:59 \n08:34:43 - 12:22:17 ", "1.0424074074 \n1.0424074074 \n1.0000000000 \n1.0000732332 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2011", "线段树", "树状数组", "Special Judge", "前缀和", "差分", "COI（克罗地亚）"], "title": "[COI 2011] 收视率 / TELKA", "background": "译自 [COI 2011 T2](https://hsin.hr/hio2011/zadaci/)。", "description": "最近，Mirko 所在的地区进行了一次人口普查。除了记录每位居民的众多信息外，地区特别关注电视收视数据。\n\n每位居民在普查中提供了以下格式的两个时间点：  \n\n$$\\text{HH:MM:SS – HH:MM:SS}$$\n\n第一个时间表示该居民开始观看电视的时刻，第二个时间表示停止观看电视的时刻（以秒为单位）。居民观看电视的时间完全包含两个端点。\n\n需注意，部分居民可能在前一天深夜开始观看电视（例如 $\\text{23:45:30}$），并在次日结束观看（例如 $\\text{01:15:00}$）。  \n\n居民的收视行为每天在同一时间段重复。\n\n数据收集完成后，统计人员开始进行分析。电视节目在某一秒的\"收视热度\"定义为该秒内正在观看电视的总人数。  \n统计人员需要计算 $Q$ 个特别关注时间区间内的平均收视热度。某个时间区间的平均收视热度等于该区间内每秒收视热度之和除以区间总秒数。\n", "inputFormat": "第一行输入一个自然数 $N$ $(N \\le 100,000)$，表示居民数量。  \n\n随后 $N$ 行每行包含一位居民提供的两个时间点，格式如上所述。其中 $0 \\le \\text{HH} \\le 23, 0 \\le \\text{MM} \\le 59, 0 \\le \\text{SS} \\le 59$。 \n\n下一行输入一个自然数 $Q$ $(Q \\le 100,000)$，表示待分析的特别关注时间区间数量。  \n\n随后 $Q$ 行每行包含一个时间区间，格式与居民时间记录相同。\n", "outputFormat": "对于每个时间区间，单独输出一行该区间内的平均收视热度。  \n\n只要输出结果与标准答案的绝对误差或相对误差不超过 $10^{-6}$，即被视为正确。", "hint": "对于 $25\\%$ 的测试数据满足：$N \\le 500$ 且 $Q \\le 500$。\n\n对于另外 $25\\%$ 的测试数据满足：$N \\le 500$ 且 $Q \\le 100,000$。  \n\n对于另外 $25\\%$ 的测试数据满足：$N \\le 100,000$ 且 $Q \\le 500$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COI 2011] 收视率 / TELKA", "background": "译自 [COI 2011 T2](https://hsin.hr/hio2011/zadaci/)。", "description": "最近，Mirko 所在的地区进行了一次人口普查。除了记录每位居民的众多信息外，地区特别关注电视收视数据。\n\n每位居民在普查中提供了以下格式的两个时间点：  \n\n$$\\text{HH:MM:SS – HH:MM:SS}$$\n\n第一个时间表示该居民开始观看电视的时刻，第二个时间表示停止观看电视的时刻（以秒为单位）。居民观看电视的时间完全包含两个端点。\n\n需注意，部分居民可能在前一天深夜开始观看电视（例如 $\\text{23:45:30}$），并在次日结束观看（例如 $\\text{01:15:00}$）。  \n\n居民的收视行为每天在同一时间段重复。\n\n数据收集完成后，统计人员开始进行分析。电视节目在某一秒的\"收视热度\"定义为该秒内正在观看电视的总人数。  \n统计人员需要计算 $Q$ 个特别关注时间区间内的平均收视热度。某个时间区间的平均收视热度等于该区间内每秒收视热度之和除以区间总秒数。\n", "inputFormat": "第一行输入一个自然数 $N$ $(N \\le 100,000)$，表示居民数量。  \n\n随后 $N$ 行每行包含一位居民提供的两个时间点，格式如上所述。其中 $0 \\le \\text{HH} \\le 23, 0 \\le \\text{MM} \\le 59, 0 \\le \\text{SS} \\le 59$。 \n\n下一行输入一个自然数 $Q$ $(Q \\le 100,000)$，表示待分析的特别关注时间区间数量。  \n\n随后 $Q$ 行每行包含一个时间区间，格式与居民时间记录相同。\n", "outputFormat": "对于每个时间区间，单独输出一行该区间内的平均收视热度。  \n\n只要输出结果与标准答案的绝对误差或相对误差不超过 $10^{-6}$，即被视为正确。", "hint": "对于 $25\\%$ 的测试数据满足：$N \\le 500$ 且 $Q \\le 500$。\n\n对于另外 $25\\%$ 的测试数据满足：$N \\le 500$ 且 $Q \\le 100,000$。  \n\n对于另外 $25\\%$ 的测试数据满足：$N \\le 100,000$ 且 $Q \\le 500$。", "locale": "zh-CN"}}}
{"pid": "P14234", "type": "P", "difficulty": 4, "samples": [["2 10 \n2 8 \n6 4 ", "14"], ["8 15 \n1 12 \n3 1 \n3 9 \n4 2 \n7 13 \n12 11 \n14 11 \n14 13 ", "27"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["贪心", "2011", "COI（克罗地亚）"], "title": "[COI 2011] 河流 / RIJEKA", "background": "译自 [COI 2011 T3](https://hsin.hr/hio2011/zadaci/)。", "description": "在一个遥远的国度，有一条大河，沿岸分布着许多村庄。村庄按河流沿岸的顺序从 $0$ 到 $M$ 编号。相邻两个村庄之间的距离恰好为 $1$ 公里。\n\n在编号为 $0$ 的村庄里，住着一位名叫 Mirko 的村民，他拥有一艘船，专门从事村庄间的客运服务。今天， Mirko 需要从 $0$ 号村庄出发前往 $M$ 号村庄，并在途中运送一些乘客。具体来说，今天共有 $N$ 名乘客需要出行，每名乘客的当前所在村庄和目的村庄均已知晓。\n\nMirko 的船容量很大，可以同时搭载任意数量的乘客。\n例如，乘客 A 需要从 $2$ 号村庄前往 $8$ 号村庄，乘客 B 需要从 $6$ 号村庄前往 $4$ 号村庄。那么 Mirko 从 $0$ 号村庄出发后可以这样操作：在 $2$ 号村庄接上乘客 A，继续行驶至 $6$ 号村庄接上乘客 B，然后返回 $4$ 号村庄让乘客 B 下船，再继续行驶至 $8$ 号村庄让乘客 A 下船，最后前往 M 号村庄。此方案对应下文第一个测试样例。\n\n请编写程序计算 Mirko 从 $0$ 号村庄出发，将所有乘客运送至目的地，并最终成功到达 $M$ 号村庄所需行驶的最小总公里数。", "inputFormat": "第一行输入两个自然数 $N$ 和 $M$ $(N \\le 300,000, 3 \\le M \\le 10^9)$，含义如题目描述，以空格分隔。\n\n接下来 $N$ 行每行包含两名乘客的信息，一行输入两个不同的整数（均大于 $0$ 且小于 $M$ ），分别表示该乘客的出发村庄和目的村庄。", "outputFormat": "输出一行一个整数，表示 Mirko 行驶路径的最小总公里数。", "hint": "对于 $40\\%$ 的测试数据满足：$N \\le 5000$。\n\n对于另外 $50\\%$ 的测试数据满足：$M \\le 2,000,000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COI 2011] 河流 / RIJEKA", "background": "译自 [COI 2011 T3](https://hsin.hr/hio2011/zadaci/)。", "description": "在一个遥远的国度，有一条大河，沿岸分布着许多村庄。村庄按河流沿岸的顺序从 $0$ 到 $M$ 编号。相邻两个村庄之间的距离恰好为 $1$ 公里。\n\n在编号为 $0$ 的村庄里，住着一位名叫 Mirko 的村民，他拥有一艘船，专门从事村庄间的客运服务。今天， Mirko 需要从 $0$ 号村庄出发前往 $M$ 号村庄，并在途中运送一些乘客。具体来说，今天共有 $N$ 名乘客需要出行，每名乘客的当前所在村庄和目的村庄均已知晓。\n\nMirko 的船容量很大，可以同时搭载任意数量的乘客。\n例如，乘客 A 需要从 $2$ 号村庄前往 $8$ 号村庄，乘客 B 需要从 $6$ 号村庄前往 $4$ 号村庄。那么 Mirko 从 $0$ 号村庄出发后可以这样操作：在 $2$ 号村庄接上乘客 A，继续行驶至 $6$ 号村庄接上乘客 B，然后返回 $4$ 号村庄让乘客 B 下船，再继续行驶至 $8$ 号村庄让乘客 A 下船，最后前往 M 号村庄。此方案对应下文第一个测试样例。\n\n请编写程序计算 Mirko 从 $0$ 号村庄出发，将所有乘客运送至目的地，并最终成功到达 $M$ 号村庄所需行驶的最小总公里数。", "inputFormat": "第一行输入两个自然数 $N$ 和 $M$ $(N \\le 300,000, 3 \\le M \\le 10^9)$，含义如题目描述，以空格分隔。\n\n接下来 $N$ 行每行包含两名乘客的信息，一行输入两个不同的整数（均大于 $0$ 且小于 $M$ ），分别表示该乘客的出发村庄和目的村庄。", "outputFormat": "输出一行一个整数，表示 Mirko 行驶路径的最小总公里数。", "hint": "对于 $40\\%$ 的测试数据满足：$N \\le 5000$。\n\n对于另外 $50\\%$ 的测试数据满足：$M \\le 2,000,000$。", "locale": "zh-CN"}}}
{"pid": "P14235", "type": "P", "difficulty": 5, "samples": [["2 1 10 \n1 2 a ", "0"], ["7 9 5 \n1 2 A \n2 3 B \n2 5 \n5 3 C \n3 4 b \n3 6 c \n3 7 \n4 7 a \n6 7 a ", "4"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["图论", "2011", "动态规划优化", "COI（克罗地亚）"], "title": "[COI 2011] 卡车 / KAMION", "background": "译自 [COI 2011 T4](https://hsin.hr/hio2011/zadaci/)。", "description": "Mirko 找到了一份卡车司机的工作。他的任务是在城市间的道路上行驶，同时进行货物的装货和卸货。Mirko 的卡车容量非常大，可以装载无限量的货物，但由于自动化装卸系统的限制，他只能卸下最后装上卡车的货物。总共有 $26$ 种不同类型的货物，分别用英文字母表示。\n\n城市之间通过单向道路连接，每条道路恰好长 $1$ 公里，Mirko 在这些道路上需要进行货物的装货/卸货操作。具体来说，存在三种类型的道路，分别用数字 $1$、$2$、$3$ 标识，其规则如下：\n\n1. **每当** Mirko 经过此类道路时，**必须**装载一个该道路指定的特定类型货物。\n\n2. **每当** Mirko 经过此类道路时，**必须**从卡车上卸下一个该道路指定的特定类型货物。\n\n3. Mirko 可以自由通过此类道路，无需任何操作。\n\n除了在通过道路时必须执行的操作外，Mirko 不得进行任何其他装卸货操作。\n\nMirko 可以在总共 $E$ 条道路上行驶，这些道路连接着 $N$ 个城市。Mirko 初始位于编号为 $1$ 的城市，他的目标是到达编号为 $N$ 的城市。到达城市 $N$ 时，卡车不需要为空。\n\n请编写程序计算 Mirko 在最多行驶 $K$ 公里的条件下，有多少种不同的方式可以完成这段旅程。\n\n注意：解中可能包括多次经过城市 $N$ 的路径，只要旅程最终在该城市结束即可。换句话说，所有城市和道路都可以被多次访问（但每次通过道路时都需要重新遵守对应的通行规则）。\n", "inputFormat": "第一行输入包含三个整数 $N, E$ 和 $K$ $(2 \\le N \\le 50, 1 \\le E \\le 2450，1 \\le K \\le 50)$，分别表示城市数量、道路数量以及 Mirko 在到达目的地前最多可行驶的公里数。\n\n接下来 $E$ 行描述 Mirko 可以行驶的道路。由于存在三种不同类型的道路，它们在输入中的描述方式也不同。以下列表对应上述道路类型（按编号对应）：\n\n1. 需要装载货物类型 $\\text C$ 的道路将以 `x y C` 的格式表示，其中 $x$ 和 $y$ 为自然数，$\\text C$ 为任意一个大写英文字母。该格式表示存在从城市 $x$ 到城市 $y$ 的道路，且 Mirko 在通过时必须装载类型为 $\\text C$ 的货物。\n\n2. 需要卸货类型 $\\text c$ 的道路将以 `x y c` 的格式表示，其中 $x$ 和 $y$ 为自然数，$\\text c$ 为小写英文字母。该格式表示存在从城市 $x$ 到城市 $y$ 的道路，且 Mirko 在通过时必须卸下类型为 $\\text c$ 的货物。\n\n3. 可自由通行的道路将以 `x y` 的格式表示，其中 $x$ 和 $y$ 为自然数。该格式表示存在从城市 $x$ 到城市 $y$ 的道路，Mirko 通过时无需任何操作。\n\n上述描述中始终满足 $1 \\le x, y \\le N, x \\ne y$，且 $\\text C$ 和 $\\text c$ 分别表示大写和小写英文字母。不存在两条不同道路以相同方向连接同一对城市。", "outputFormat": "输出一行，包含从城市 $1$ 到达城市 $N$ 的合法路径数量。由于该数值可能很大，请输出其除以 $10007$ 的余数。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COI 2011] 卡车 / KAMION", "background": "译自 [COI 2011 T4](https://hsin.hr/hio2011/zadaci/)。", "description": "Mirko 找到了一份卡车司机的工作。他的任务是在城市间的道路上行驶，同时进行货物的装货和卸货。Mirko 的卡车容量非常大，可以装载无限量的货物，但由于自动化装卸系统的限制，他只能卸下最后装上卡车的货物。总共有 $26$ 种不同类型的货物，分别用英文字母表示。\n\n城市之间通过单向道路连接，每条道路恰好长 $1$ 公里，Mirko 在这些道路上需要进行货物的装货/卸货操作。具体来说，存在三种类型的道路，分别用数字 $1$、$2$、$3$ 标识，其规则如下：\n\n1. **每当** Mirko 经过此类道路时，**必须**装载一个该道路指定的特定类型货物。\n\n2. **每当** Mirko 经过此类道路时，**必须**从卡车上卸下一个该道路指定的特定类型货物。\n\n3. Mirko 可以自由通过此类道路，无需任何操作。\n\n除了在通过道路时必须执行的操作外，Mirko 不得进行任何其他装卸货操作。\n\nMirko 可以在总共 $E$ 条道路上行驶，这些道路连接着 $N$ 个城市。Mirko 初始位于编号为 $1$ 的城市，他的目标是到达编号为 $N$ 的城市。到达城市 $N$ 时，卡车不需要为空。\n\n请编写程序计算 Mirko 在最多行驶 $K$ 公里的条件下，有多少种不同的方式可以完成这段旅程。\n\n注意：解中可能包括多次经过城市 $N$ 的路径，只要旅程最终在该城市结束即可。换句话说，所有城市和道路都可以被多次访问（但每次通过道路时都需要重新遵守对应的通行规则）。\n", "inputFormat": "第一行输入包含三个整数 $N, E$ 和 $K$ $(2 \\le N \\le 50, 1 \\le E \\le 2450，1 \\le K \\le 50)$，分别表示城市数量、道路数量以及 Mirko 在到达目的地前最多可行驶的公里数。\n\n接下来 $E$ 行描述 Mirko 可以行驶的道路。由于存在三种不同类型的道路，它们在输入中的描述方式也不同。以下列表对应上述道路类型（按编号对应）：\n\n1. 需要装载货物类型 $\\text C$ 的道路将以 `x y C` 的格式表示，其中 $x$ 和 $y$ 为自然数，$\\text C$ 为任意一个大写英文字母。该格式表示存在从城市 $x$ 到城市 $y$ 的道路，且 Mirko 在通过时必须装载类型为 $\\text C$ 的货物。\n\n2. 需要卸货类型 $\\text c$ 的道路将以 `x y c` 的格式表示，其中 $x$ 和 $y$ 为自然数，$\\text c$ 为小写英文字母。该格式表示存在从城市 $x$ 到城市 $y$ 的道路，且 Mirko 在通过时必须卸下类型为 $\\text c$ 的货物。\n\n3. 可自由通行的道路将以 `x y` 的格式表示，其中 $x$ 和 $y$ 为自然数。该格式表示存在从城市 $x$ 到城市 $y$ 的道路，Mirko 通过时无需任何操作。\n\n上述描述中始终满足 $1 \\le x, y \\le N, x \\ne y$，且 $\\text C$ 和 $\\text c$ 分别表示大写和小写英文字母。不存在两条不同道路以相同方向连接同一对城市。", "outputFormat": "输出一行，包含从城市 $1$ 到达城市 $N$ 的合法路径数量。由于该数值可能很大，请输出其除以 $10007$ 的余数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14236", "type": "P", "difficulty": 6, "samples": [["2 0 \n0 -9 -9 0 \n0 1 1 0 \n1 0 0 1 \n0 0 6 0 ", "4"], ["2 1 \n0 -9 -9 0 \n0 1 1 0 \n1 0 0 1 \n0 0 6 0 ", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2011", "Ad-hoc", "COI（克罗地亚）"], "title": "[COI 2011] 主教 / LOVCI", "background": "译自 [COI 2011 T5](https://hsin.hr/hio2011/zadaci/)。", "description": "Mirko 画了一个 $2N$ 行 $2N$ 列的棋盘，并在上面玩以下游戏：\n\n他在每个格子上写了一个整数，表示该格子的**价值**。他在第一行的中间并排放置了两个国际象棋的主教（分别位于第 $N$ 列和第 $N+1$ 列）。现在，Mirko 在思考每个主教能**看到**的格子：即位于该主教**所在对角线**上的所有格子（除了主教当前所在的格子本身）。\n\n例如，如果 $N=3$，初始时两个主教（标记为 `L`）可以看到标记为 `X` 的 $10$ 个格子：\n\n```\nOOLLOO\nOXXXXO\nXXOOXX\nXOOOOX\nOOOOOO\nOOOOOO\n```\n\n在给定的步数内，Mirko 试图通过以下方式获得尽可能高的分数：\n\n1. 在走任何一步之前，Mirko 获得的分数等于两个主教从初始位置能**看到**的所有格子的价值之和。\n\n2. 在每一步中，他选择其中一个主教，并将其沿对角线移动至该主教能**看到**的任意一个格子。\n\n3. 在新位置上，主教现在可以看到一些从游戏开始至今**未被任何主教看到过**的新格子。这些新发现的格子的价值之和将被加到 Mirko 的分数中。\n\n主教总是能看到所有与其在同一对角线上的格子，并且总是可以跳到这些格子中的任意一个。\n\n请编写一个程序，计算 Mirko 在 $K$ 步之内能够获得的最大总分数。", "inputFormat": "第一行输入包含两个整数 $N$ 和 $K$ $(1 \\le N \\le 10, 0 \\le K \\le 100)$，分别是棋盘尺寸的一半和步数。\n\n接下来的 $2N$ 行给出了棋盘每一行格子的价值：每行包含 $2N$ 个整数 $X$ $(-1,000,000 \\le X \\le 1,000,000)$，表示该行每个格子的价值。\n", "outputFormat": "输出一行一个整数，包含所求的最大分数。", "hint": "对于 $40\\%$ 的测试数据满足：$K \\le 5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COI 2011] 主教 / LOVCI", "background": "译自 [COI 2011 T5](https://hsin.hr/hio2011/zadaci/)。", "description": "Mirko 画了一个 $2N$ 行 $2N$ 列的棋盘，并在上面玩以下游戏：\n\n他在每个格子上写了一个整数，表示该格子的**价值**。他在第一行的中间并排放置了两个国际象棋的主教（分别位于第 $N$ 列和第 $N+1$ 列）。现在，Mirko 在思考每个主教能**看到**的格子：即位于该主教**所在对角线**上的所有格子（除了主教当前所在的格子本身）。\n\n例如，如果 $N=3$，初始时两个主教（标记为 `L`）可以看到标记为 `X` 的 $10$ 个格子：\n\n```\nOOLLOO\nOXXXXO\nXXOOXX\nXOOOOX\nOOOOOO\nOOOOOO\n```\n\n在给定的步数内，Mirko 试图通过以下方式获得尽可能高的分数：\n\n1. 在走任何一步之前，Mirko 获得的分数等于两个主教从初始位置能**看到**的所有格子的价值之和。\n\n2. 在每一步中，他选择其中一个主教，并将其沿对角线移动至该主教能**看到**的任意一个格子。\n\n3. 在新位置上，主教现在可以看到一些从游戏开始至今**未被任何主教看到过**的新格子。这些新发现的格子的价值之和将被加到 Mirko 的分数中。\n\n主教总是能看到所有与其在同一对角线上的格子，并且总是可以跳到这些格子中的任意一个。\n\n请编写一个程序，计算 Mirko 在 $K$ 步之内能够获得的最大总分数。", "inputFormat": "第一行输入包含两个整数 $N$ 和 $K$ $(1 \\le N \\le 10, 0 \\le K \\le 100)$，分别是棋盘尺寸的一半和步数。\n\n接下来的 $2N$ 行给出了棋盘每一行格子的价值：每行包含 $2N$ 个整数 $X$ $(-1,000,000 \\le X \\le 1,000,000)$，表示该行每个格子的价值。\n", "outputFormat": "输出一行一个整数，包含所求的最大分数。", "hint": "对于 $40\\%$ 的测试数据满足：$K \\le 5$。", "locale": "zh-CN"}}}
{"pid": "P14237", "type": "P", "difficulty": 2, "samples": [["2\n3 15\n3 4 5\n5 7 2\n1 2 20\n1 100\n1 1 100", "25\n10000"]], "limits": {"time": [1000, 1000], "memory": [1048576, 1048576]}, "tags": ["2024", "山东", "省赛/邀请赛"], "title": "[CCPC 2024 Shandong I] 打印机", "background": "", "description": "SUA 程序设计竞赛命题组的裁判们正在为即将举行的 2024 中国大学生程序设计竞赛全国邀请赛（山东）暨 CCPC 山东省大学生程序设计竞赛打印试题。\n\n文印店里共有 $n$ 台打印机。第 $i$ 台打印机每 $t_i$ 秒可以打印一份试题。然而，第 $i$ 台打印机每次打印出 $l_i$ 份试题后，必须停机 $w_i$ 秒防止过热。也就是说，第 $i$ 台打印机将重复进行以下工作计划：持续工作 $t_i \\times l_i$ 秒，然后停机 $w_i$ 秒。\n\n裁判们将同时使用所有打印机。求打印 $k$ 份试题至少需要多少秒。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$（$1 \\le T \\le 100$）表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $k$（$1 \\le n \\le 100$，$1 \\le k \\le 10^9$）表示打印机的数量和需要的试题数量。\n\n对于接下来的 $n$ 行，第 $i$ 行输入三个整数 $t_i$，$l_i$ 和 $w_i$（$1 \\le t_i, l_i, w_i \\le 10^9$）。它们的意义如上所述。", "outputFormat": "每组数据输出一行一个整数，表示打印试题至少需要多少秒。", "hint": "对于第一组样例数据，在 $25$ 秒内，第一台打印机可以打印 $6$ 份试题，第二台打印机可以打印 $5$ 份试题，第三台打印机可以打印 $4$ 份试题。所以一共打印了 $6 + 5 + 4 = 15$ 份试题。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCPC 2024 Shandong I] 打印机", "background": "", "description": "SUA 程序设计竞赛命题组的裁判们正在为即将举行的 2024 中国大学生程序设计竞赛全国邀请赛（山东）暨 CCPC 山东省大学生程序设计竞赛打印试题。\n\n文印店里共有 $n$ 台打印机。第 $i$ 台打印机每 $t_i$ 秒可以打印一份试题。然而，第 $i$ 台打印机每次打印出 $l_i$ 份试题后，必须停机 $w_i$ 秒防止过热。也就是说，第 $i$ 台打印机将重复进行以下工作计划：持续工作 $t_i \\times l_i$ 秒，然后停机 $w_i$ 秒。\n\n裁判们将同时使用所有打印机。求打印 $k$ 份试题至少需要多少秒。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$（$1 \\le T \\le 100$）表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $k$（$1 \\le n \\le 100$，$1 \\le k \\le 10^9$）表示打印机的数量和需要的试题数量。\n\n对于接下来的 $n$ 行，第 $i$ 行输入三个整数 $t_i$，$l_i$ 和 $w_i$（$1 \\le t_i, l_i, w_i \\le 10^9$）。它们的意义如上所述。", "outputFormat": "每组数据输出一行一个整数，表示打印试题至少需要多少秒。", "hint": "对于第一组样例数据，在 $25$ 秒内，第一台打印机可以打印 $6$ 份试题，第二台打印机可以打印 $5$ 份试题，第三台打印机可以打印 $4$ 份试题。所以一共打印了 $6 + 5 + 4 = 15$ 份试题。", "locale": "zh-CN"}}}
