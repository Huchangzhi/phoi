{"pid": "P6116", "type": "P", "difficulty": 5, "samples": [["5\nRRGYY", "2"], ["6\nRRRRRG", "-1"], ["20\nYYGYYYGGGGRGYYGRGRYG", "8"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "JOI（日本）"], "title": "[JOI 2019 Final] 有趣的家庭菜园 3 / Growing Vegetables is Fun 3", "background": "JOI 2019 Final T3", "description": "家庭菜园专家 JOI 先生在他的家庭菜园中种植了一种叫 Joy 草的植物。在他的菜园里，有 $N$ 个花盆自东向西摆放，第 $i$ 个编号为 $i$。每个花盆中有一株 Joy 草。\n\n春天到了，JOI 先生注意到 Joy 草如他期望地长出了各种颜色的叶子，但他也发现 Joy 草的生长速度没有他期望的那么快。他查阅了书籍，找到了草的以下特点：\n\n - Joy 草有三种品种，分别会长出红色、绿色和黄色的叶子。\n\n - 如果两株同一颜色的 Joy 草紧密相邻，它们的生长速度就会减慢。\n\n因此，JOI 先生决定重新摆放花盆，使得没有两株相邻的 Joy 草颜色相同。\n\n花盆非常沉重，因此 JOI 先生每次只能交换相邻的两个花盆。形式化的说，JOI 先生每次操作可以选择一个 $i$，然后交换花盆 $i$ 和花盆 $i+1$。\n\n请编写一个程序，计算最少的交换次数。", "inputFormat": "第一行一个整数 $N$。\n\n接下来一行一个长度为 $N$ 的字符串 ，每个字符为 `R`,`G`,`Y` 中的一个，表示 Joy 草的颜色。", "outputFormat": "输出一行一个整数，表示完成目标所需的最少操作次数。如果无解，输出 $-1$。", "hint": "### 样例解释\n\n样例解释 $1$:  \n\n一种合法的方案是：\n  \n第一步：交换第三个花盆和第四个花盆。 \n \n第二步：交换第二个花盆和第三个花盆。 \n \n可以证明，不存在次数更少的方案 \n\n样例解释 $2$：  \n\n可以证明，无论如何移动，均不可达到目标。\n\n### 子任务\n\nSubtask 1（5 分）：$N\\le 15$。\n\nSubtask 2（55 分）：$N\\le 60$。\n\nSubtask 3（15 分）：字符串仅包含 `R`,`G`。\n\nSubtask 4（25 分）：$N\\le 400$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI 2019 Final] 有趣的家庭菜园 3 / Growing Vegetables is Fun 3", "background": "JOI 2019 Final T3", "description": "家庭菜园专家 JOI 先生在他的家庭菜园中种植了一种叫 Joy 草的植物。在他的菜园里，有 $N$ 个花盆自东向西摆放，第 $i$ 个编号为 $i$。每个花盆中有一株 Joy 草。\n\n春天到了，JOI 先生注意到 Joy 草如他期望地长出了各种颜色的叶子，但他也发现 Joy 草的生长速度没有他期望的那么快。他查阅了书籍，找到了草的以下特点：\n\n - Joy 草有三种品种，分别会长出红色、绿色和黄色的叶子。\n\n - 如果两株同一颜色的 Joy 草紧密相邻，它们的生长速度就会减慢。\n\n因此，JOI 先生决定重新摆放花盆，使得没有两株相邻的 Joy 草颜色相同。\n\n花盆非常沉重，因此 JOI 先生每次只能交换相邻的两个花盆。形式化的说，JOI 先生每次操作可以选择一个 $i$，然后交换花盆 $i$ 和花盆 $i+1$。\n\n请编写一个程序，计算最少的交换次数。", "inputFormat": "第一行一个整数 $N$。\n\n接下来一行一个长度为 $N$ 的字符串 ，每个字符为 `R`,`G`,`Y` 中的一个，表示 Joy 草的颜色。", "outputFormat": "输出一行一个整数，表示完成目标所需的最少操作次数。如果无解，输出 $-1$。", "hint": "### 样例解释\n\n样例解释 $1$:  \n\n一种合法的方案是：\n  \n第一步：交换第三个花盆和第四个花盆。 \n \n第二步：交换第二个花盆和第三个花盆。 \n \n可以证明，不存在次数更少的方案 \n\n样例解释 $2$：  \n\n可以证明，无论如何移动，均不可达到目标。\n\n### 子任务\n\nSubtask 1（5 分）：$N\\le 15$。\n\nSubtask 2（55 分）：$N\\le 60$。\n\nSubtask 3（15 分）：字符串仅包含 `R`,`G`。\n\nSubtask 4（25 分）：$N\\le 400$。", "locale": "zh-CN"}}}
{"pid": "P6117", "type": "P", "difficulty": 5, "samples": [["3\n0 0\n0 4\n4 0\n2 1\n2 5\n-1 1", "15"], ["4\n2 1\n2 1\n2 1\n3 1\n3 1\n3 1\n3 1\n3 1", "9"], ["5\n1000000000 1000000000\n-1000000000 1000000000\n-1000000000 -1000000000\n1000000000 -1000000000\n-1 -5\n-2 2\n2 8\n4 7\n-2 5\n7 3", "8000000029"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2019", "JOI（日本）"], "title": "[JOI 2019 Final] 硬币收藏 / Coin Collecting", "background": "JOI 2019 Final T4", "description": "JOI 先生的收藏室里有一张巨大的桌子，上面有许多稀有的硬币。为了清理桌子，他要重新摆放硬币。\n\n桌面可视为 $(2\\times 10^9+1)\\times (2\\times 10^9+1)$ 的网格。JOI 先生有 $2N$ 枚硬币。初始时，第 $i$ 枚 $(1\\le i\\le 2N)$ 硬币被放在坐标为 $(X_i,Y_i)$ 的格子里。JOI 先生的目标是在每个满足 $1\\le x \\le N,1\\le y\\le 2$ 的格子 $(x,y)$ 上恰好放一枚硬币。为了不损坏硬币，他能做的唯一一个操作是钦定一枚硬币然后将其移动到相邻的一个格子中（我们说两个格子相邻，当且仅当这两个格子有公共边）。在移动硬币的过程中，允许两个硬币处在同一个格子中。JOI 先生希望通过尽量少的操作次数完成目标。\n\n现在给出硬币的数量和初始时所在的位置，编写一个程序，计算完成 JOI 先生目标所需的最少操作次数。", "inputFormat": "第一行一个整数 $N$。\n\n接下来 $2N$ 行，第 $i$ 行为两个整数 $X_i$ 和 $Y_i$。", "outputFormat": "输出一行一个整数，表示完成目标所需的最少操作次数。", "hint": "### 样例解释\n\n样例解释 $1$:  \n\n一种合法的移动方案是：  \n\n第一枚硬币：$(0,0)\\rightarrow(1,0)\\rightarrow(1,1)\\rightarrow(1,2)$  \n\n第二枚硬币：$(0,4)\\rightarrow(1,4)\\rightarrow(1,3)\\rightarrow(2,3)\\rightarrow(3,3)\\rightarrow(3,2)$  \n\n第三枚硬币：$(4,0)\\rightarrow(4,1)\\rightarrow(3,1)$  \n\n第四枚硬币：不动  \n\n第五枚硬币：$(2,5)\\rightarrow(2,4)\\rightarrow(2,3)\\rightarrow(2,2)$ \n \n第六枚硬币：$(-1,1)\\rightarrow(0,1)\\rightarrow(1,1)$  \n\n可以证明 JOI 先生不能用少于 $15$ 次移动完成目标。\n\n### 数据范围\n\nSubtask1（8 分），$N\\le 10$。\n\nSubtask2（29 分），$N\\le 1000$。\n\nSubtask3（63 分），无其他限制。\n\n对于 $100\\%$ 的数据，$N\\le 10^5,-10^9\\le X_i,Y_i\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI 2019 Final] 硬币收藏 / Coin Collecting", "background": "JOI 2019 Final T4", "description": "JOI 先生的收藏室里有一张巨大的桌子，上面有许多稀有的硬币。为了清理桌子，他要重新摆放硬币。\n\n桌面可视为 $(2\\times 10^9+1)\\times (2\\times 10^9+1)$ 的网格。JOI 先生有 $2N$ 枚硬币。初始时，第 $i$ 枚 $(1\\le i\\le 2N)$ 硬币被放在坐标为 $(X_i,Y_i)$ 的格子里。JOI 先生的目标是在每个满足 $1\\le x \\le N,1\\le y\\le 2$ 的格子 $(x,y)$ 上恰好放一枚硬币。为了不损坏硬币，他能做的唯一一个操作是钦定一枚硬币然后将其移动到相邻的一个格子中（我们说两个格子相邻，当且仅当这两个格子有公共边）。在移动硬币的过程中，允许两个硬币处在同一个格子中。JOI 先生希望通过尽量少的操作次数完成目标。\n\n现在给出硬币的数量和初始时所在的位置，编写一个程序，计算完成 JOI 先生目标所需的最少操作次数。", "inputFormat": "第一行一个整数 $N$。\n\n接下来 $2N$ 行，第 $i$ 行为两个整数 $X_i$ 和 $Y_i$。", "outputFormat": "输出一行一个整数，表示完成目标所需的最少操作次数。", "hint": "### 样例解释\n\n样例解释 $1$:  \n\n一种合法的移动方案是：  \n\n第一枚硬币：$(0,0)\\rightarrow(1,0)\\rightarrow(1,1)\\rightarrow(1,2)$  \n\n第二枚硬币：$(0,4)\\rightarrow(1,4)\\rightarrow(1,3)\\rightarrow(2,3)\\rightarrow(3,3)\\rightarrow(3,2)$  \n\n第三枚硬币：$(4,0)\\rightarrow(4,1)\\rightarrow(3,1)$  \n\n第四枚硬币：不动  \n\n第五枚硬币：$(2,5)\\rightarrow(2,4)\\rightarrow(2,3)\\rightarrow(2,2)$ \n \n第六枚硬币：$(-1,1)\\rightarrow(0,1)\\rightarrow(1,1)$  \n\n可以证明 JOI 先生不能用少于 $15$ 次移动完成目标。\n\n### 数据范围\n\nSubtask1（8 分），$N\\le 10$。\n\nSubtask2（29 分），$N\\le 1000$。\n\nSubtask3（63 分），无其他限制。\n\n对于 $100\\%$ 的数据，$N\\le 10^5,-10^9\\le X_i,Y_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P6118", "type": "P", "difficulty": 6, "samples": [["5 4\n1 2\n2 3\n3 4\n3 5\n1 2 1 2 4", "2\n0\n1\n1\n1"], ["7 1\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n1 1 1 1 1 1 1", "1\n1\n1\n0\n1\n1\n1"], ["10 10\n2 6\n5 8\n10 8\n1 4\n10 6\n4 5\n10 7\n6 9\n3 7\n1 2 3 4 5 6 7 8 9 10", "4\n3\n4\n2\n0\n2\n2\n0\n3\n2"], ["22 12\n9 6\n12 13\n4 20\n21 22\n3 19\n2 9\n6 18\n18 11\n18 3\n16 2\n6 4\n3 17\n16 10\n8 16\n22 1\n16 14\n15 8\n9 21\n2 12\n21 5\n12 7\n1 1 4 8 4 11 7 6 7 11 6 11 10 4 7 5 3 12 9 6 12 2", "2\n0\n1\n1\n1\n1\n1\n0\n0\n1\n2\n0\n1\n1\n2\n0\n2\n1\n2\n3\n0\n0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "树的直径", "栈", "JOI（日本）"], "title": "[JOI 2019 Final] 独特的城市 / Unique Cities", "background": "JOI 2019 Final T5", "description": "JOI 国有 $N$ 个城市，城市从 $1$ 到 $N$ 编号。这些城市被 $N-1$ 条双向道路连接，第 $i$ 条路连接两个城市 $A_i$ 和 $B_i$。从任何城市出发，可以到达所有城市。\n\nJOI 国有些特产，每种特产的编号都在 $1$ 到 $M$ 之间（包括 $1$ 和 $M$），但是 $1$ 到 $M$ 的某些整数可能不代表 JOI 国的特产。JOI 国的每个城市都产一种特产。$j$ 城产的特产是 $C_j$。多个城市可能产相同的特产。\n\n我们定义两个城市之间的距离为从一个城市到另一个城市需要经过的最少道路数，对于城市 $x$，我们定义城市 $y$（$y\\neq x$）是**独特的城市**当且仅当对于任何一个城市 $z$（$z\\neq x,z\\neq y$），$x$ 与 $y$ 间的距离不等于 $x$ 与 $z$ 之间的距离。\n\nJOI 国交通部部长 K 先生想知道对于城市 $j$ 的**独特的城市**一共能产多少种特产。\n\n给出 JOI 国的道路信息与每个城市产的特产，写一个程序计算对于每个城市的**独特的城市**，一共能产多少种特产。", "inputFormat": "第一行两个整数 $N,M$，意义如题目描述。\n\n接下来 $N-1$ 行，每行两个整数 $A_i,B_i$，意义如题目描述。\n\n最后一行 $N$ 个正整数，第 $i$ 个为 $C_i$，意义如题目描述。", "outputFormat": "输出 $N$ 行，第 $i$ 行表示对于城市 $i$ 的独特的城市一共能产多少种特产。", "hint": "样例解释 $1$：  \n\n对于城市 $1$，它的独特城市是城市 $2,3$，城市 $2$ 产特产 $2$，城市 $3$ 产特产 $3$，一共产两种特产，因此答案是 $2$；  \n\n对于城市 $2$，没有独特城市，因此输出 $0$；\n  \n对于城市 $3$，它的独特城市是城市 $1$，城市 $1$ 产特产 ，因此答案是 $1$；  \n\n对于城市 $4$，它的独特城市是城市 $1,3$，城市 $1,3$ 均产特产 $1$，因此答案是 $1$；  \n\n对于城市 $5$，它的独特城市是城市 $1,3$，城市 $1,3$ 均产特产 $1$，因此答案是 $1$。  \n\n注意：没有城市产特产 $3$。  \n\n对于 $4\\%$ 的数据，$N\\le 2000$。\n\n另有 $32\\%$ 的数据，$M=1$。\n\n另有 $32\\%$ 的数据，$M=N,C_j=j(1\\le j \\le N)$。\n\n对于 $100\\%$ 的数据，$1\\le N \\le 2\\times 10^5,1\\le M,A_i,B_i \\le N,A_i \\neq B_i,1\\le C_j \\le M$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI 2019 Final] 独特的城市 / Unique Cities", "background": "JOI 2019 Final T5", "description": "JOI 国有 $N$ 个城市，城市从 $1$ 到 $N$ 编号。这些城市被 $N-1$ 条双向道路连接，第 $i$ 条路连接两个城市 $A_i$ 和 $B_i$。从任何城市出发，可以到达所有城市。\n\nJOI 国有些特产，每种特产的编号都在 $1$ 到 $M$ 之间（包括 $1$ 和 $M$），但是 $1$ 到 $M$ 的某些整数可能不代表 JOI 国的特产。JOI 国的每个城市都产一种特产。$j$ 城产的特产是 $C_j$。多个城市可能产相同的特产。\n\n我们定义两个城市之间的距离为从一个城市到另一个城市需要经过的最少道路数，对于城市 $x$，我们定义城市 $y$（$y\\neq x$）是**独特的城市**当且仅当对于任何一个城市 $z$（$z\\neq x,z\\neq y$），$x$ 与 $y$ 间的距离不等于 $x$ 与 $z$ 之间的距离。\n\nJOI 国交通部部长 K 先生想知道对于城市 $j$ 的**独特的城市**一共能产多少种特产。\n\n给出 JOI 国的道路信息与每个城市产的特产，写一个程序计算对于每个城市的**独特的城市**，一共能产多少种特产。", "inputFormat": "第一行两个整数 $N,M$，意义如题目描述。\n\n接下来 $N-1$ 行，每行两个整数 $A_i,B_i$，意义如题目描述。\n\n最后一行 $N$ 个正整数，第 $i$ 个为 $C_i$，意义如题目描述。", "outputFormat": "输出 $N$ 行，第 $i$ 行表示对于城市 $i$ 的独特的城市一共能产多少种特产。", "hint": "样例解释 $1$：  \n\n对于城市 $1$，它的独特城市是城市 $2,3$，城市 $2$ 产特产 $2$，城市 $3$ 产特产 $3$，一共产两种特产，因此答案是 $2$；  \n\n对于城市 $2$，没有独特城市，因此输出 $0$；\n  \n对于城市 $3$，它的独特城市是城市 $1$，城市 $1$ 产特产 ，因此答案是 $1$；  \n\n对于城市 $4$，它的独特城市是城市 $1,3$，城市 $1,3$ 均产特产 $1$，因此答案是 $1$；  \n\n对于城市 $5$，它的独特城市是城市 $1,3$，城市 $1,3$ 均产特产 $1$，因此答案是 $1$。  \n\n注意：没有城市产特产 $3$。  \n\n对于 $4\\%$ 的数据，$N\\le 2000$。\n\n另有 $32\\%$ 的数据，$M=1$。\n\n另有 $32\\%$ 的数据，$M=N,C_j=j(1\\le j \\le N)$。\n\n对于 $100\\%$ 的数据，$1\\le N \\le 2\\times 10^5,1\\le M,A_i,B_i \\le N,A_i \\neq B_i,1\\le C_j \\le M$。", "locale": "zh-CN"}}}
{"pid": "P6119", "type": "P", "difficulty": 4, "samples": [["6\n1\n2\n3\n4\n5\n6\n6\n5\n4\n3\n2\n1", "5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "USACO"], "title": "[USACO17FEB] Why Did the Cow Cross the Road II G", "background": "*本题与 [白金组同名题目](/problem/P3657) 在题意上一致，唯一的差别是数据范围。*", "description": "Farmer John 饲养了 $N$ 种奶牛，编号从 $1$ 到 $N$。一些品种的奶牛和其他奶牛间相处良好，事实证明，如果两个品种的奶牛编号分别为 $a,b$，当 $|a-b| \\leq 4$ 时，这两个品种的奶牛能友好相处，否则不能友好相处。\n\n一条长长的道路贯穿整个农场，道路的左侧有 $N$ 个牧场（每个品种的奶牛恰好占据一个牧场），道路的右侧也有 $N$ 个牧场（每个品种的奶牛恰好占据一个牧场）。为了让奶牛们安全穿过马路，Farmer John 希望能在马路上画出一些人行道（牛行道？），要求这些人行道满足如下条件：\n\n1. 人行道从左侧的某个牧场出发，连接到右侧的某个牧场；\n2. 人行道连接的两个牧场的奶牛要能友好相处；\n3. 人行道不能在道路中间相交；\n4. 每个牧场只能与一条人行道相连。\n\n你需要帮 FJ 求出最多能有多少条人行道。", "inputFormat": "输入第一行一个整数 $N$（$1 \\leq N \\leq 1000$）。\n\n接下来 $N$ 行，每行一个整数 $a_i$，代表道路左侧第 $i$ 个牧场的奶牛品种编号。\n\n接下来 $N$ 行，每行一个整数 $b_i$，代表道路右侧第 $i$ 个牧场的奶牛品种编号。", "outputFormat": "输出最多能画多少条人行道。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO17FEB] Why Did the Cow Cross the Road II G", "background": "*本题与 [白金组同名题目](/problem/P3657) 在题意上一致，唯一的差别是数据范围。*", "description": "Farmer John 饲养了 $N$ 种奶牛，编号从 $1$ 到 $N$。一些品种的奶牛和其他奶牛间相处良好，事实证明，如果两个品种的奶牛编号分别为 $a,b$，当 $|a-b| \\leq 4$ 时，这两个品种的奶牛能友好相处，否则不能友好相处。\n\n一条长长的道路贯穿整个农场，道路的左侧有 $N$ 个牧场（每个品种的奶牛恰好占据一个牧场），道路的右侧也有 $N$ 个牧场（每个品种的奶牛恰好占据一个牧场）。为了让奶牛们安全穿过马路，Farmer John 希望能在马路上画出一些人行道（牛行道？），要求这些人行道满足如下条件：\n\n1. 人行道从左侧的某个牧场出发，连接到右侧的某个牧场；\n2. 人行道连接的两个牧场的奶牛要能友好相处；\n3. 人行道不能在道路中间相交；\n4. 每个牧场只能与一条人行道相连。\n\n你需要帮 FJ 求出最多能有多少条人行道。", "inputFormat": "输入第一行一个整数 $N$（$1 \\leq N \\leq 1000$）。\n\n接下来 $N$ 行，每行一个整数 $a_i$，代表道路左侧第 $i$ 个牧场的奶牛品种编号。\n\n接下来 $N$ 行，每行一个整数 $b_i$，代表道路右侧第 $i$ 个牧场的奶牛品种编号。", "outputFormat": "输出最多能画多少条人行道。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6120", "type": "P", "difficulty": 3, "samples": [["5\nP\nP\nH\nP\nS", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "USACO"], "title": "[USACO17JAN] Hoof, Paper, Scissor S", "background": "*本题与 [金组同名题目](/problem/P3609) 在题意上一致，唯一的差别在于对变手势次数的限制。*", "description": "你可能玩过“石头，剪刀，布”，这个游戏在奶牛中同样流行，不过它的名字变成了“蹄子，剪刀，布”。\n\n“蹄子，剪刀，布”和“石头，剪刀，布”的规则十分类似，两只奶牛数到三，然后出一个代表蹄子，剪刀或布的手势。蹄子胜过剪刀，剪刀胜过布，布胜过蹄子。特别地，如果两只奶牛的手势相同，则视为平局。\n\n现在 FJ 和 Bessie 要进行 $N$ 轮对抗。Bessie 已经预测了 FJ 每一轮要出的手势。然而 Bessie 很懒，她最多只想变换一次手势。\n\n现在请你帮 Bessie 求出她最多能赢多少轮。", "inputFormat": "第一行输入一个整数 $N$（$1 \\leq N \\leq 10^5$）。\n\n接下来 $N$ 行，每行一个字母，代表 FJ 这一轮出的手势。`H` 代表蹄子（Hoof），`S` 代表剪刀（Scissors），`P` 代表布（Paper）。", "outputFormat": "输出一个整数，代表 Bessie 在最多变换一次手势的前提下最多赢多少轮。", "hint": null, "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO17JAN] Hoof, Paper, Scissor S", "background": "*本题与 [金组同名题目](/problem/P3609) 在题意上一致，唯一的差别在于对变手势次数的限制。*", "description": "你可能玩过“石头，剪刀，布”，这个游戏在奶牛中同样流行，不过它的名字变成了“蹄子，剪刀，布”。\n\n“蹄子，剪刀，布”和“石头，剪刀，布”的规则十分类似，两只奶牛数到三，然后出一个代表蹄子，剪刀或布的手势。蹄子胜过剪刀，剪刀胜过布，布胜过蹄子。特别地，如果两只奶牛的手势相同，则视为平局。\n\n现在 FJ 和 Bessie 要进行 $N$ 轮对抗。Bessie 已经预测了 FJ 每一轮要出的手势。然而 Bessie 很懒，她最多只想变换一次手势。\n\n现在请你帮 Bessie 求出她最多能赢多少轮。", "inputFormat": "第一行输入一个整数 $N$（$1 \\leq N \\leq 10^5$）。\n\n接下来 $N$ 行，每行一个字母，代表 FJ 这一轮出的手势。`H` 代表蹄子（Hoof），`S` 代表剪刀（Scissors），`P` 代表布（Paper）。", "outputFormat": "输出一个整数，代表 Bessie 在最多变换一次手势的前提下最多赢多少轮。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P6121", "type": "P", "difficulty": 4, "samples": [["4 3\n1 2\n2 3\n3 4\n3\n4\n1\n2", "YES\nNO\nYES\nYES"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["图论", "2016", "USACO", "并查集", "链表"], "title": "[USACO16OPEN] Closing the Farm G", "background": "*本题和 [银组同名题目](/problem/P3144) 在题意上一致，唯一的不同是数据范围。*", "description": "FJ 和他的奶牛们正在计划离开小镇做一次长的旅行，同时 FJ 想临时地关掉他的农场以节省一些金钱。\n\n这个农场一共有被用 $M$ 条双向道路连接的 $N$ 个谷仓（$1 \\leq N,M \\leq 2 \\times 10^5$）。为了关闭整个农场，FJ 计划每一次关闭掉一个谷仓。当一个谷仓被关闭了，所有的连接到这个谷仓的道路都会被关闭，而且再也不能够被使用。\n\nFJ 现在正感兴趣于知道在每一个时间（这里的“时间”指在每一次关闭谷仓之前的时间）时他的农场是否是“全连通的”——也就是说从任意的一个开着的谷仓开始，能够到达另外的一个谷仓。注意自从某一个时间之后，可能整个农场都开始不会是“全连通的”。", "inputFormat": "输入第一行两个整数 $N,M$。\n\n接下来 $M$ 行，每行两个整数 $u,v$（$1 \\leq u,v \\leq N$），描述一条连接 $u,v$ 两个农场的路。\n\n最后 $N$ 行每行一个整数，表示第 $i$ 个被关闭的农场编号。", "outputFormat": "输出 $N$ 行，每行包含 `YES` 或 `NO`，表示某个时刻农场是否是全连通的。\n\n第一行输出最初的状态，第 $i$ 行（$2 \\leq i \\leq N$）输出第 $i-1$ 个农场被关闭后的状态。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO16OPEN] Closing the Farm G", "background": "*本题和 [银组同名题目](/problem/P3144) 在题意上一致，唯一的不同是数据范围。*", "description": "FJ 和他的奶牛们正在计划离开小镇做一次长的旅行，同时 FJ 想临时地关掉他的农场以节省一些金钱。\n\n这个农场一共有被用 $M$ 条双向道路连接的 $N$ 个谷仓（$1 \\leq N,M \\leq 2 \\times 10^5$）。为了关闭整个农场，FJ 计划每一次关闭掉一个谷仓。当一个谷仓被关闭了，所有的连接到这个谷仓的道路都会被关闭，而且再也不能够被使用。\n\nFJ 现在正感兴趣于知道在每一个时间（这里的“时间”指在每一次关闭谷仓之前的时间）时他的农场是否是“全连通的”——也就是说从任意的一个开着的谷仓开始，能够到达另外的一个谷仓。注意自从某一个时间之后，可能整个农场都开始不会是“全连通的”。", "inputFormat": "输入第一行两个整数 $N,M$。\n\n接下来 $M$ 行，每行两个整数 $u,v$（$1 \\leq u,v \\leq N$），描述一条连接 $u,v$ 两个农场的路。\n\n最后 $N$ 行每行一个整数，表示第 $i$ 个被关闭的农场编号。", "outputFormat": "输出 $N$ 行，每行包含 `YES` 或 `NO`，表示某个时刻农场是否是全连通的。\n\n第一行输出最初的状态，第 $i$ 行（$2 \\leq i \\leq N$）输出第 $i-1$ 个农场被关闭后的状态。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6122", "type": "P", "difficulty": 6, "samples": [["5 4\n0 0 4 1 1\n2 4 5 2", "1 1 2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "ICPC", "模拟费用流", "NERC/NEERC"], "title": "[NEERC 2016] Mole Tunnels", "background": null, "description": "鼹鼠们在底下开凿了 $n$ 个洞，由 $n-1$ 条隧道连接，对于任意的 $i>1$，第 $i$ 个洞都会和第 $\\lfloor \\frac{i}{2}\\rfloor$ 个洞间有一条隧道，第 $i$ 个洞内还有 $c_i$ 个食物能供最多 $c_i$ 只鼹鼠吃。一共有 $m$ 只鼹鼠，第 $i$ 只鼹鼠住在第 $p_i$ 个洞内。\n\n一天早晨，前 $k$ 只鼹鼠醒来了，而后 $m-k$ 只鼹鼠均在睡觉，前 $k$ 只鼹鼠就开始觅食，最终他们都会到达某一个洞，使得所有洞的 $c_i$ 均大于等于该洞内醒着的鼹鼠个数，而且要求鼹鼠行动路径总长度最小。现对于所有的 $1 \\le k \\le m$，输出最小的鼹鼠行动路径的总长度，保证一定存在某种合法方案。", "inputFormat": "第一行两个数 $n,m$，表示有 $n$ 个洞，$m$ 只鼹鼠。\n\n第二行 $n$ 个整数 $c_i$ 表示第 $i$ 个洞的食物数。\n\n第三行 $m$ 个整数 $p_i$ 表示第 $i$ 只鼹鼠所在洞 $p_i$。", "outputFormat": "输出一行 $m$ 个整数，第 $i$ 个整数表示当 $k=i$ 时最小的鼹鼠行动路径总长度。", "hint": "对于全部的数据满足：$1 \\le n,m \\le 10^5$，$0 \\le c_i \\le m$，$1 \\le p_i \\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NEERC 2016] Mole Tunnels", "background": null, "description": "鼹鼠们在底下开凿了 $n$ 个洞，由 $n-1$ 条隧道连接，对于任意的 $i>1$，第 $i$ 个洞都会和第 $\\lfloor \\frac{i}{2}\\rfloor$ 个洞间有一条隧道，第 $i$ 个洞内还有 $c_i$ 个食物能供最多 $c_i$ 只鼹鼠吃。一共有 $m$ 只鼹鼠，第 $i$ 只鼹鼠住在第 $p_i$ 个洞内。\n\n一天早晨，前 $k$ 只鼹鼠醒来了，而后 $m-k$ 只鼹鼠均在睡觉，前 $k$ 只鼹鼠就开始觅食，最终他们都会到达某一个洞，使得所有洞的 $c_i$ 均大于等于该洞内醒着的鼹鼠个数，而且要求鼹鼠行动路径总长度最小。现对于所有的 $1 \\le k \\le m$，输出最小的鼹鼠行动路径的总长度，保证一定存在某种合法方案。", "inputFormat": "第一行两个数 $n,m$，表示有 $n$ 个洞，$m$ 只鼹鼠。\n\n第二行 $n$ 个整数 $c_i$ 表示第 $i$ 个洞的食物数。\n\n第三行 $m$ 个整数 $p_i$ 表示第 $i$ 只鼹鼠所在洞 $p_i$。", "outputFormat": "输出一行 $m$ 个整数，第 $i$ 个整数表示当 $k=i$ 时最小的鼹鼠行动路径总长度。", "hint": "对于全部的数据满足：$1 \\le n,m \\le 10^5$，$0 \\le c_i \\le m$，$1 \\le p_i \\le n$。", "locale": "zh-CN"}}}
{"pid": "P6123", "type": "P", "difficulty": 3, "samples": [["x >= 5 && x <= 10 ||\nx >= 7 && x <= 20 ||\nx <= 2 ||\nx >= 21 && x <= 25 ||\nx >= 8 && x <= 10 ||\nx >= 100", "x <= 2 ||\nx >= 5 && x <= 25 ||\nx >= 100"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2016", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Hard Refactoring", "background": "", "description": "对于一个变量 $x$，给出一些约束条件，形如 $x \\geq a$，$x \\le a$ \n这些约束条件之间用```||```连接，然后你需要将这些约束条件简化，最后输出简化后的约束条件。", "inputFormat": "输入不超过 $10^3$ 行，每行要么是两个用 ```&&``` 连接的约束条件，要么就是单个的约束条件。\n\n如果一行有两个约束条件，第一个约束条件总是 $x \\geq a$ 的形式，第二个约束总是 $x \\leq a$ 的形式。\n\n除了输入的最后一行，每一行末尾都有一个 ```||```。\n\n并且所有的字符（除了`>=`，`<=`，`&&`，`||`）之间均由空格隔开，且没有多余的前置、后置空格。", "outputFormat": "输出若干行，表示最简的约束条件的形式（也就是使输出的行数尽量少），其余格式与输入格式保持一致。\n\n输出的若干行可以不按照特定的顺序输出。\n\n特别地，如果对于任意的 $x∈[-32768,32767]$，$x$均能满足约束条件，仅输出一行```true```，反之，若对于任意的 $x∈[-32768,32767]$，$x$均不能满足约束条件，仅输出一行```false```。", "hint": "对于所有在这一题中出现的数字（包括 $x$），都$\\ge -32768$（$-2^{15}$） 且 $\\le 32767 $（$2^{15}-1$）。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NEERC 2016] Hard Refactoring", "background": "", "description": "对于一个变量 $x$，给出一些约束条件，形如 $x \\geq a$，$x \\le a$ \n这些约束条件之间用```||```连接，然后你需要将这些约束条件简化，最后输出简化后的约束条件。", "inputFormat": "输入不超过 $10^3$ 行，每行要么是两个用 ```&&``` 连接的约束条件，要么就是单个的约束条件。\n\n如果一行有两个约束条件，第一个约束条件总是 $x \\geq a$ 的形式，第二个约束总是 $x \\leq a$ 的形式。\n\n除了输入的最后一行，每一行末尾都有一个 ```||```。\n\n并且所有的字符（除了`>=`，`<=`，`&&`，`||`）之间均由空格隔开，且没有多余的前置、后置空格。", "outputFormat": "输出若干行，表示最简的约束条件的形式（也就是使输出的行数尽量少），其余格式与输入格式保持一致。\n\n输出的若干行可以不按照特定的顺序输出。\n\n特别地，如果对于任意的 $x∈[-32768,32767]$，$x$均能满足约束条件，仅输出一行```true```，反之，若对于任意的 $x∈[-32768,32767]$，$x$均不能满足约束条件，仅输出一行```false```。", "hint": "对于所有在这一题中出现的数字（包括 $x$），都$\\ge -32768$（$-2^{15}$） 且 $\\le 32767 $（$2^{15}-1$）。", "locale": "zh-CN"}}}
{"pid": "P6124", "type": "P", "difficulty": 6, "samples": [["2", "10"], ["10", "1100"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["高精度", "2015", "广度优先搜索 BFS", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Binary vs Decimal", "background": "", "description": "一个正数 $A$，如果它只包含 `0` 或 `1`，且它转成二进制后的 $B$，$A$ 是 $B$ 的后缀，这个数就是我们所要的。\n\n现在给出数字 $N$，求第 $N$ 个这样的数。", "inputFormat": "一行一个数 $N$。", "outputFormat": "一行一个数，第 $N$ 个数。", "hint": "$1 \\le N \\le 10^4$。\n\n|原数|二进制|评论|\n| :-----------: | :-----------: | :-----------: |\n|$1$|$1$|√|\n|$10$|$1010$|√|\n|$11$|$1011$|√|\n|$100$|$1100100$|√|\n|$101$|$1100101$|√|\n|$110$|$1101110$|√|\n|$111$|$1101111$|√|\n|$1000$|$1111101000$|√|\n|$1001$|$1111101001$|√|\n|$1010$|$1111110010$|×|\n|$1011$|$1111110011$|×|\n|$1100$|$10001001100$|√| ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NEERC 2015] Binary vs Decimal", "background": "", "description": "一个正数 $A$，如果它只包含 `0` 或 `1`，且它转成二进制后的 $B$，$A$ 是 $B$ 的后缀，这个数就是我们所要的。\n\n现在给出数字 $N$，求第 $N$ 个这样的数。", "inputFormat": "一行一个数 $N$。", "outputFormat": "一行一个数，第 $N$ 个数。", "hint": "$1 \\le N \\le 10^4$。\n\n|原数|二进制|评论|\n| :-----------: | :-----------: | :-----------: |\n|$1$|$1$|√|\n|$10$|$1010$|√|\n|$11$|$1011$|√|\n|$100$|$1100100$|√|\n|$101$|$1100101$|√|\n|$110$|$1101110$|√|\n|$111$|$1101111$|√|\n|$1000$|$1111101000$|√|\n|$1001$|$1111101001$|√|\n|$1010$|$1111110010$|×|\n|$1011$|$1111110011$|×|\n|$1100$|$10001001100$|√| ", "locale": "zh-CN"}}}
{"pid": "P6125", "type": "P", "difficulty": 6, "samples": [["3 2 2\n1 2\n1 2\nAB\nBA\nAA", "0.25\n0.50\n0.25"], ["3 4 2\n1 2\n1 2\nAABA\nABAA\nBAAA", "0.31\n0.33\n0.37"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "2009", "各省省选", "江苏", "高斯消元", "AC 自动机"], "title": "[JSOI2009] 有趣的游戏", "background": "", "description": "小阳阳发明了一个有趣的游戏：有 $n$ 个玩家，每个玩家都有一个长度为 $l$ 的字母序列，任何两个玩家的字母序列不同。共有 $m$ 种不同的字母，所有的字母序列都由这 $m$ 种字母构成。为了方便，我们取大写字母的前 $m$ 个字母。   \n例如 $m=3,l=4,\\texttt{ABAA}$ 和 $\\texttt{CBCA}$ 是两个合法的字母序列。       \n现在由小阳阳来操控一台神奇的机器，每个时刻机器会随机产生一个字母，其中第 $i$ 种字母随机出来的概率为 $\\dfrac{p_i}{q_i}$ ，显然 $\\sum \\limits_{k=1}^m \\dfrac{p_i}{q_i}=1$。  \n这样 $T$ 个时刻后机器会产生一个长度为 $T$ 的字母序列。  \n如果某个时刻某个玩家发现自己的字母序列在机器产生的字母序列中出现了，“出现”的定义是玩家的字母序列是机器产生的字母序列中连续的一段，那么我们称这个玩家获胜，游戏结束。       \n现在小阳阳感兴趣的一个问题是，每个玩家分别有多大的概率能获得这场游戏的胜利呢？  ", "inputFormat": "第一行有三个正整数 $n,l,m$ 表示有 $n$ 个人，每个字母的序列长度均为 $l$，共有 $m$ 个字母。   \n接下来 $m$ 行，每行有两个非负整数 $p, q$，表示随机到第 $i$ 个字母的概率为 $\\frac{p}{q}$。   \n接下来 $n$ 行，每行有一个长度为 $l$ 的字母序列，表示第 $i$ 个人的字母序列。", "outputFormat": "包含 $n$ 行，每行一个实数，表示第 $i$ 个人获胜的概率，输出结果四舍五入到两位小数。 ", "hint": "$1 \\leq n,l,m \\leq 10$，$0 \\leq p_i \\leq q_i \\leq 10$ 且 $\\gcd(p,q) = 1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2009] 有趣的游戏", "background": "", "description": "小阳阳发明了一个有趣的游戏：有 $n$ 个玩家，每个玩家都有一个长度为 $l$ 的字母序列，任何两个玩家的字母序列不同。共有 $m$ 种不同的字母，所有的字母序列都由这 $m$ 种字母构成。为了方便，我们取大写字母的前 $m$ 个字母。   \n例如 $m=3,l=4,\\texttt{ABAA}$ 和 $\\texttt{CBCA}$ 是两个合法的字母序列。       \n现在由小阳阳来操控一台神奇的机器，每个时刻机器会随机产生一个字母，其中第 $i$ 种字母随机出来的概率为 $\\dfrac{p_i}{q_i}$ ，显然 $\\sum \\limits_{k=1}^m \\dfrac{p_i}{q_i}=1$。  \n这样 $T$ 个时刻后机器会产生一个长度为 $T$ 的字母序列。  \n如果某个时刻某个玩家发现自己的字母序列在机器产生的字母序列中出现了，“出现”的定义是玩家的字母序列是机器产生的字母序列中连续的一段，那么我们称这个玩家获胜，游戏结束。       \n现在小阳阳感兴趣的一个问题是，每个玩家分别有多大的概率能获得这场游戏的胜利呢？  ", "inputFormat": "第一行有三个正整数 $n,l,m$ 表示有 $n$ 个人，每个字母的序列长度均为 $l$，共有 $m$ 个字母。   \n接下来 $m$ 行，每行有两个非负整数 $p, q$，表示随机到第 $i$ 个字母的概率为 $\\frac{p}{q}$。   \n接下来 $n$ 行，每行有一个长度为 $l$ 的字母序列，表示第 $i$ 个人的字母序列。", "outputFormat": "包含 $n$ 行，每行一个实数，表示第 $i$ 个人获胜的概率，输出结果四舍五入到两位小数。 ", "hint": "$1 \\leq n,l,m \\leq 10$，$0 \\leq p_i \\leq q_i \\leq 10$ 且 $\\gcd(p,q) = 1$。", "locale": "zh-CN"}}}
{"pid": "P6126", "type": "P", "difficulty": 6, "samples": [["5\n3 2 3 4\n2 1 3\n4 2 1 4 5\n2 1 3\n1 3", "3\n1 2 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2012", "各省省选", "江苏", "Special Judge", "高斯消元"], "title": "[JSOI2012] 始祖鸟", "background": null, "description": "最近，进香河地带出现了一家“始祖鸟专卖店”，然而这并不只是一时的心血来潮。         \n                         \n早在远古时期，进香河地带就以其秀美的环境和适宜的温度吸引了成群的始祖鸟。始祖鸟是一种团结的鸟类，它们总是通过各种方式来增强种群内部的交流，聚会则是其中之一。因为聚会不但可以增强朋友之间的友谊，而且可以认识新的朋友。        \n                             \n现在有 $N$ 只始祖鸟，我们从 $1$ 开始编号。对于第 $i$ 只始祖鸟，有 $M_i$ 个认识的朋友，它们的编号分别是 $F_{i,1},F_{i,2},\\dots,F_{i,M_i}$。朋友的认识关系是单向的，也就是说如果第 $s$ 只始祖鸟认识第 $t$ 只始祖鸟，那么第 $t$ 只始祖鸟不一定认识第 $s$ 只始祖鸟。        \n   \n聚会的地点分为两处，一处在上游，一处在下游。对于每一处聚会场所，都必须满足对于在这个聚会场所中的始祖鸟，有恰好有偶数个自己认识的朋友与之在同一个聚会场所中。当然，每一只始祖鸟都必须在两处聚会场所之一。         \n       \n现在需要你给出一种安排方式。你只需要给出在上游的始祖鸟编号，如果有多组解，请输出任何一组解。", "inputFormat": "输入数据包含 $N+1$ 行，第一行是数字 $N$，代表始祖鸟的个数。       \n接下来 $N$ 行，第 $i+1$ 行的第一个数字是 $M_i$，表示第 $i$ 只鸟的朋友个数。之后有 $M_i$ 个数字依次为 $F_{i,1},F_{i,2},\\dots,F_{i,M_i}$ 表示第 $i$ 只始祖鸟朋友的标号。", "outputFormat": "输出数据包含 $2$ 行，第一行有一个非负整数 $k$，表示在上游参加聚会的始祖鸟个数。第二行有 $k$ 个正整数，表示在这个 $k$ 只始祖鸟的编号，你可以以任意顺序输出这些编号。如果无法满足要求，只输出一行 `Impossible`。", "hint": "#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，$1 \\le N \\le 2000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2012] 始祖鸟", "background": null, "description": "最近，进香河地带出现了一家“始祖鸟专卖店”，然而这并不只是一时的心血来潮。         \n                         \n早在远古时期，进香河地带就以其秀美的环境和适宜的温度吸引了成群的始祖鸟。始祖鸟是一种团结的鸟类，它们总是通过各种方式来增强种群内部的交流，聚会则是其中之一。因为聚会不但可以增强朋友之间的友谊，而且可以认识新的朋友。        \n                             \n现在有 $N$ 只始祖鸟，我们从 $1$ 开始编号。对于第 $i$ 只始祖鸟，有 $M_i$ 个认识的朋友，它们的编号分别是 $F_{i,1},F_{i,2},\\dots,F_{i,M_i}$。朋友的认识关系是单向的，也就是说如果第 $s$ 只始祖鸟认识第 $t$ 只始祖鸟，那么第 $t$ 只始祖鸟不一定认识第 $s$ 只始祖鸟。        \n   \n聚会的地点分为两处，一处在上游，一处在下游。对于每一处聚会场所，都必须满足对于在这个聚会场所中的始祖鸟，有恰好有偶数个自己认识的朋友与之在同一个聚会场所中。当然，每一只始祖鸟都必须在两处聚会场所之一。         \n       \n现在需要你给出一种安排方式。你只需要给出在上游的始祖鸟编号，如果有多组解，请输出任何一组解。", "inputFormat": "输入数据包含 $N+1$ 行，第一行是数字 $N$，代表始祖鸟的个数。       \n接下来 $N$ 行，第 $i+1$ 行的第一个数字是 $M_i$，表示第 $i$ 只鸟的朋友个数。之后有 $M_i$ 个数字依次为 $F_{i,1},F_{i,2},\\dots,F_{i,M_i}$ 表示第 $i$ 只始祖鸟朋友的标号。", "outputFormat": "输出数据包含 $2$ 行，第一行有一个非负整数 $k$，表示在上游参加聚会的始祖鸟个数。第二行有 $k$ 个正整数，表示在这个 $k$ 只始祖鸟的编号，你可以以任意顺序输出这些编号。如果无法满足要求，只输出一行 `Impossible`。", "hint": "#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，$1 \\le N \\le 2000$。", "locale": "zh-CN"}}}
{"pid": "P6127", "type": "P", "difficulty": 7, "samples": [["3\nTTTT\nTTFT\nTFTT\nTFFF\nFTTT\nFTFF\nFFTF\nFFFF\n", "a&b|(a|b&c)"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "贪心", "2000", "Special Judge", "CTSC/CTS"], "title": "[CTSC2000] 逻辑范式", "background": "", "description": "逻辑学是对命题以及命题真假性进行研究的一门科学。命题一般用一个小写字母表示，任何命题的值非真即假。我们用 `T` 表示命题的值为真，用 `F` 表示命题的值为假。\n\n命题间的运算符称为命题操作联结词，简称联结词。逻辑系统中最基本的三个联结词是非、且和或，为了简便，我们用 $!$ 表示联结词非，用 $\\&$ 表示联结词且，用 $|$ 表示联结词或。\n\n联结词非是一个一元联结词，对于任意命题 $p$ ，$!p$ 的真值总是和 $p$ 相反。\n\n联结词且又称合取，是一个二元联结词，对于任意命题 $p$ 和 $q$ ，当且仅当 $p$ 和 $q$ 同为真时， $p\\&q$ 为真，否则 $p\\&q$ 为假。\n\n联结词或又称析取，是一个二元联结词，对于任意命题 $p$ 和 $q$ ，当且仅当 $p$ 和 $q$ 同为假时， $p|q$ 为假，否则 $p|q$ 为真。\n\n下面给出三个基本命题运算联结词的真值表：\n\n| 命题 $p$ | 命题 $q$ | $!p$ | $p\\&q$ | $p\\|q$   |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| T | T | F | T | T |\n| T | F | F | F | T | \n| F | T | T | F | T |\n| F | T | T | F | T |\n| F | F | T | F | F | \n\n\n逻辑表达式是由命题、联结词和括号组成的。它的定义如下：\n\n`<表达式>      ::=<合取式> or <析取式> or <否定式> or (<表达式>) or <元素>`\n\n`<合取式>      ::=<表达式>&<表达式>`\n\n`<析取式>      ::=<表达式>|<表达式>`\n\n`<否定式>      ::=!<表达式>`\n\n`<元素>      ::=<命题>`\n\n注：其中 <命题> 是 $a$ 到 $z$ 的小写字母，`::=` 表示定义为， `or` 表示或。\n\n对表达式的求值过程是根据表达式中各命题的值和真值表进行命题运算操作的过程。运算优先级为 $()$ 、 $!$ 、 $\\&$ 和 $|$ 。$\\&$ 和 $|$ 的优先级相同。相同优先级从左到右运算。\n\n与或非逻辑范式（这里简称为范式）是一种逻辑表达式，它能够符合特定的真值表。例如一般逻辑里定义的蕴涵运算 $\\rightarrow$ 的真值表为：\n\n| 命题 $p$ | 命题 $q$ | $p \\rightarrow q$ |\n| :----------: | :----------: | :----------: |\n| T | T | T |\n| T | F | F |\n| F | T | T |\n| F | F | T |\n\n\n我们可以用表达式 $!p|q$ 来表示这个蕴涵运算。表达式  $!p|q$ 的真值表为：\n\n| 命题 $p$ | 命题 $q$ | $!p\\|q$ |\n| :----------: | :----------: | :----------: |\n| T | T | T |\n| T | F | F |\n| F | T | T |\n| F | F | T |\n\n这样，我们就说 $p \\to q$ 的范式为 $!p|q$ 。\n\n完备定理告诉我们，对于任意一个 $n$ 元逻辑运算函数 $A$ ，已知 $A$ 的真值表，总可以求出 $A$ 的范式。范式只含命题、三个基本联结词和括号。例如，下面是一个三元运算 $A(p,q,r)$ 的真值表：\n\n| 命题 $p$ | 命题 $q$ | 命题 $r$ | $A(p,q,r)$ |\n| :----------: | :----------: | :----------: | :----------: |\n| T | T | T | T |\n| T | T | F | T |\n| T | F | T | T |\n| T | F | F | F |\n| F | T | T | T |\n| F | T | F | F |\n| F | F | T | F |\n| F | F | F | F |\n\n也就是说，在命题 $p,q,r$ 有两个或两个以上为真时， $A$ 为真；反之 $A$ 为假。\n\n当然，范式并不是唯一的。假设存在一种 $A$ 的范式为 $(p\\&q\\&r)|(!p\\&q\\&r)|(p\\&!q\\&r)|(p\\&q\\&!r)$ ， 表达式 $(p\\&q)|(q\\&r)|(p\\&r)$ 也是 $A$ 的范式，并且它的长度比前式更短。\n\n我们的要求是：给定 $n$ 元函数 $A$ 的真值表，求 $A$ 的范式，并要求范式尽可能短。", "inputFormat": "输入文件第一行为 $n$（$n \\leq 6$），表示 $A$ 是 $n$ 元函数。随后有 $2^n$ 行，每行为一个长度为 $n+1$ 的字符串。字符串仅包含字符 `T` 和 `F` 。前 $n$ 个依次表示第 $n$ 个命题的值，最后一个表示当 $n$ 个命题按此取值时 $A$ 的值。", "outputFormat": "输出文件包含一行，为你给出的范式。命题依次用小写字母 $a, b, c, d, \\ldots $表示。", "hint": "**评分标准**：\n\n- 如果你给定的范式错误或者在规定时间内没有出解，该测试点得 $0$ 分。\n- 如果你给定的范式长度小于等于标准答案的长度，该测试点得满分。\n- 如果你给定的范式长度大于等于标准答案长度的两倍，该测试点得 $0$ 分。\n- 如果你给定的范式长度大于标准答案的长度，小于标准答案长度的两倍，该测试点得分计算公式为： \n\n$$\nScore=FullScore \\times \\frac{2L_{std}-L}{L_{std}}\n$$\n\n其中 $FullScore$ 为该测试点满分， $L_{std}$ 为标准答案长度， $L$ 为你的答案长度。\n\n**感谢 [tiger2005](https://www.luogu.com.cn/user/60864) 提供 SPJ ！**\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CTSC2000] 逻辑范式", "background": "", "description": "逻辑学是对命题以及命题真假性进行研究的一门科学。命题一般用一个小写字母表示，任何命题的值非真即假。我们用 `T` 表示命题的值为真，用 `F` 表示命题的值为假。\n\n命题间的运算符称为命题操作联结词，简称联结词。逻辑系统中最基本的三个联结词是非、且和或，为了简便，我们用 $!$ 表示联结词非，用 $\\&$ 表示联结词且，用 $|$ 表示联结词或。\n\n联结词非是一个一元联结词，对于任意命题 $p$ ，$!p$ 的真值总是和 $p$ 相反。\n\n联结词且又称合取，是一个二元联结词，对于任意命题 $p$ 和 $q$ ，当且仅当 $p$ 和 $q$ 同为真时， $p\\&q$ 为真，否则 $p\\&q$ 为假。\n\n联结词或又称析取，是一个二元联结词，对于任意命题 $p$ 和 $q$ ，当且仅当 $p$ 和 $q$ 同为假时， $p|q$ 为假，否则 $p|q$ 为真。\n\n下面给出三个基本命题运算联结词的真值表：\n\n| 命题 $p$ | 命题 $q$ | $!p$ | $p\\&q$ | $p\\|q$   |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| T | T | F | T | T |\n| T | F | F | F | T | \n| F | T | T | F | T |\n| F | T | T | F | T |\n| F | F | T | F | F | \n\n\n逻辑表达式是由命题、联结词和括号组成的。它的定义如下：\n\n`<表达式>      ::=<合取式> or <析取式> or <否定式> or (<表达式>) or <元素>`\n\n`<合取式>      ::=<表达式>&<表达式>`\n\n`<析取式>      ::=<表达式>|<表达式>`\n\n`<否定式>      ::=!<表达式>`\n\n`<元素>      ::=<命题>`\n\n注：其中 <命题> 是 $a$ 到 $z$ 的小写字母，`::=` 表示定义为， `or` 表示或。\n\n对表达式的求值过程是根据表达式中各命题的值和真值表进行命题运算操作的过程。运算优先级为 $()$ 、 $!$ 、 $\\&$ 和 $|$ 。$\\&$ 和 $|$ 的优先级相同。相同优先级从左到右运算。\n\n与或非逻辑范式（这里简称为范式）是一种逻辑表达式，它能够符合特定的真值表。例如一般逻辑里定义的蕴涵运算 $\\rightarrow$ 的真值表为：\n\n| 命题 $p$ | 命题 $q$ | $p \\rightarrow q$ |\n| :----------: | :----------: | :----------: |\n| T | T | T |\n| T | F | F |\n| F | T | T |\n| F | F | T |\n\n\n我们可以用表达式 $!p|q$ 来表示这个蕴涵运算。表达式  $!p|q$ 的真值表为：\n\n| 命题 $p$ | 命题 $q$ | $!p\\|q$ |\n| :----------: | :----------: | :----------: |\n| T | T | T |\n| T | F | F |\n| F | T | T |\n| F | F | T |\n\n这样，我们就说 $p \\to q$ 的范式为 $!p|q$ 。\n\n完备定理告诉我们，对于任意一个 $n$ 元逻辑运算函数 $A$ ，已知 $A$ 的真值表，总可以求出 $A$ 的范式。范式只含命题、三个基本联结词和括号。例如，下面是一个三元运算 $A(p,q,r)$ 的真值表：\n\n| 命题 $p$ | 命题 $q$ | 命题 $r$ | $A(p,q,r)$ |\n| :----------: | :----------: | :----------: | :----------: |\n| T | T | T | T |\n| T | T | F | T |\n| T | F | T | T |\n| T | F | F | F |\n| F | T | T | T |\n| F | T | F | F |\n| F | F | T | F |\n| F | F | F | F |\n\n也就是说，在命题 $p,q,r$ 有两个或两个以上为真时， $A$ 为真；反之 $A$ 为假。\n\n当然，范式并不是唯一的。假设存在一种 $A$ 的范式为 $(p\\&q\\&r)|(!p\\&q\\&r)|(p\\&!q\\&r)|(p\\&q\\&!r)$ ， 表达式 $(p\\&q)|(q\\&r)|(p\\&r)$ 也是 $A$ 的范式，并且它的长度比前式更短。\n\n我们的要求是：给定 $n$ 元函数 $A$ 的真值表，求 $A$ 的范式，并要求范式尽可能短。", "inputFormat": "输入文件第一行为 $n$（$n \\leq 6$），表示 $A$ 是 $n$ 元函数。随后有 $2^n$ 行，每行为一个长度为 $n+1$ 的字符串。字符串仅包含字符 `T` 和 `F` 。前 $n$ 个依次表示第 $n$ 个命题的值，最后一个表示当 $n$ 个命题按此取值时 $A$ 的值。", "outputFormat": "输出文件包含一行，为你给出的范式。命题依次用小写字母 $a, b, c, d, \\ldots $表示。", "hint": "**评分标准**：\n\n- 如果你给定的范式错误或者在规定时间内没有出解，该测试点得 $0$ 分。\n- 如果你给定的范式长度小于等于标准答案的长度，该测试点得满分。\n- 如果你给定的范式长度大于等于标准答案长度的两倍，该测试点得 $0$ 分。\n- 如果你给定的范式长度大于标准答案的长度，小于标准答案长度的两倍，该测试点得分计算公式为： \n\n$$\nScore=FullScore \\times \\frac{2L_{std}-L}{L_{std}}\n$$\n\n其中 $FullScore$ 为该测试点满分， $L_{std}$ 为标准答案长度， $L$ 为你的答案长度。\n\n**感谢 [tiger2005](https://www.luogu.com.cn/user/60864) 提供 SPJ ！**\n", "locale": "zh-CN"}}}
{"pid": "P6128", "type": "P", "difficulty": 6, "samples": [["3 6 2\n2 2\n2 5 ", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "各省省选", "江苏"], "title": "[JSOI2012] 幼儿园的游戏", "background": "", "description": "公元 $1770$ 年，纪昀先生途经进香河，与百姓谈说人世，谈说友善。他所告诉人们的为友之道，流传至今，深深影响着当地的人们，甚至是幼儿园的孩童。                 \n一天，多诺达新幼儿园的孩子们与老师们排排坐，形成了一个 $n \\times m$ 的矩形队列，一共有 $k$ 个老师，他们融入在了这个矩形队列之中，与小朋友们欢乐地唱着歌。“手拉手，我们永远都是好朋友！”于是老师要求每一位小朋友都和四周(即上下左右四个方向)的任意两个小朋友牵手。                 \n作为幼儿园里最聪明的小朋友，你马上意识到这并不是单纯的游戏，而是一个非常有意义的问题。你非常希望知道一共有多少种不同的牵手方案，满足每一位小朋友都可以和四周恰好两位小朋友牵手。当然，每一位小朋友都只能和小朋友牵手，不能去和老师牵手。任何一位小朋友都不允许自己和自己牵手(即左手拉右手)。 \n你所需要知道的只是方案个数，因为答案可能太大，所以需要对 $1000000007$ 取模。 ", "inputFormat": "第一行有三个整数，分别是 $n$,$m$ 和 $k$。如题。            \n接下来 $k$ 行，每一行有 $2$ 个整数 $x$ 和 $y$，描述了一位老师的位置。 ", "outputFormat": "你只需要输出一个整数，表示答案关于 $10^9+7$ 取模后的结果。 ", "hint": "对于 $100\\%$ 的数据， $1 \\le n \\le 8,1 \\le m \\le 2^{31}-1$，$1 \\le k \\le 100$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2012] 幼儿园的游戏", "background": "", "description": "公元 $1770$ 年，纪昀先生途经进香河，与百姓谈说人世，谈说友善。他所告诉人们的为友之道，流传至今，深深影响着当地的人们，甚至是幼儿园的孩童。                 \n一天，多诺达新幼儿园的孩子们与老师们排排坐，形成了一个 $n \\times m$ 的矩形队列，一共有 $k$ 个老师，他们融入在了这个矩形队列之中，与小朋友们欢乐地唱着歌。“手拉手，我们永远都是好朋友！”于是老师要求每一位小朋友都和四周(即上下左右四个方向)的任意两个小朋友牵手。                 \n作为幼儿园里最聪明的小朋友，你马上意识到这并不是单纯的游戏，而是一个非常有意义的问题。你非常希望知道一共有多少种不同的牵手方案，满足每一位小朋友都可以和四周恰好两位小朋友牵手。当然，每一位小朋友都只能和小朋友牵手，不能去和老师牵手。任何一位小朋友都不允许自己和自己牵手(即左手拉右手)。 \n你所需要知道的只是方案个数，因为答案可能太大，所以需要对 $1000000007$ 取模。 ", "inputFormat": "第一行有三个整数，分别是 $n$,$m$ 和 $k$。如题。            \n接下来 $k$ 行，每一行有 $2$ 个整数 $x$ 和 $y$，描述了一位老师的位置。 ", "outputFormat": "你只需要输出一个整数，表示答案关于 $10^9+7$ 取模后的结果。 ", "hint": "对于 $100\\%$ 的数据， $1 \\le n \\le 8,1 \\le m \\le 2^{31}-1$，$1 \\le k \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P6129", "type": "P", "difficulty": 6, "samples": [["2\n5 -1\n3\n1 4 1 0\n2 3 1 0\n1 5 1 2", "1.00 2.00\n2.00 3.00\n1.00 1.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "各省省选", "江苏"], "title": "[JSOI2012] 铁拳", "background": "经过了可怕的第三次世界大战后，国家政府崩溃，各大财团趁机夺取掌控世界。长年战争后，八大财团幸存并割据一方，其中最强的当属掌控北美的铁拳。 \n在铁拳财团所维护的文明区域中，有一项最为光荣、重要的赛事——`Iron Fist`，也就是铁拳大赛。$IF$中云集了世界各地各财团鼎力资助的世外高手，只为了赢得`IF Champion`，得到无上的荣耀，当然还有随之而来的权力。本来一切秩序井然，但一个来自贫民窟的少年风间仁意外地在海选中赢了 $IF$ 正式选手，获得了决赛资格，从此格局被打乱……                                           \n为了应对这突如其来的变数， $IF$ 管理层决定先对联盟中所有的选手进行评估，以更好地掌握大局。 ", "description": "已知最近 $m$ 届比赛出现过的 $n$ 位选手，背后都有着各自财团的资助，并且签下了合同。由于这是各财团的高度机密，合同的具体细节无从得知，但铁拳财团的间谍们通过各种渠道得知了每个选手的薪金范围（显然薪金是非负数）。 \n对于最近 $m$ 届的 $IF$ 比赛（从 $1$ 开始编号），每一届联盟都会进行清算，通过国际金融手段准确计算出这一届联盟选手身价总和的变化。每一届中，会有一些新选手加入，也会有部分选手在比赛中丧失了战斗能力，而被踢出联盟，流放到贫民窟。                                                 \n现在给出联盟中 $n$ 位选手的身价范围，以及他们 进入联盟的届数（ $0$ 表示在 $m+1$ 届以前就已经是联盟选手） 和 离开联盟的届数（ $0$ 表示是现役选手）。同时给出最近 $m$ 届中，每一届联盟选手身价总和减去上一届的值。                         \n请你根据现有信息，尽可能准确地给出每个选手可能的薪金范围。各选手之间的薪金范围可以不同时成立，但对于一位选手的范围中的每一个数，都必须至少存在一种合法方案使该选手能得到相应薪金，而且这个范围跨度要尽可能大。        \n如果输入信息有误，请输出`-1`，表示无解。 ", "inputFormat": "第一行一个正整数 $m$，意义同上。                                 \n第二行包含 $m$ 个整数，第 $i$ 个表示第 $i$ 届中 选手身价总和 的变化情况。                        \n第三行一个正整数 $n$。                            \n接下来 $n$ 行，每行包含四个整数，分别表示 身价下限 、 身价上限 、 出道届数 、 退役届数，细节请参照上文。                      \n保证出道时间严格比退役时间小（ $0$ 除外）。 ", "outputFormat": "如果输入信息有误，仅输出一行一个整数`-1`。                      \n否则输出 $n$行，每行两个实数，第 $i$ 行表示第 $i$ 个选手实际身价的准确范围，并保留两位小数。 ", "hint": "#### 样例解释#1\n\n第二届只有 $3$ 号离开了，可以锁定 $3$ 号的薪金是 $1$。 \n\n如此一来， $1$ 号和 $2$ 号薪金之和为 $4$，那么 $1$ 号最少能拿 $1$，最多能拿 $2$；$2$ 号最少能拿到 $2$，最多能拿到 $3$。\n\n#### 数据范围\n\n\n对于 $100\\%$的数据，$1 \\le n \\le 200,1 \\le m \\le 100$，给定薪金范围不超过 $20000$。  ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2012] 铁拳", "background": "经过了可怕的第三次世界大战后，国家政府崩溃，各大财团趁机夺取掌控世界。长年战争后，八大财团幸存并割据一方，其中最强的当属掌控北美的铁拳。 \n在铁拳财团所维护的文明区域中，有一项最为光荣、重要的赛事——`Iron Fist`，也就是铁拳大赛。$IF$中云集了世界各地各财团鼎力资助的世外高手，只为了赢得`IF Champion`，得到无上的荣耀，当然还有随之而来的权力。本来一切秩序井然，但一个来自贫民窟的少年风间仁意外地在海选中赢了 $IF$ 正式选手，获得了决赛资格，从此格局被打乱……                                           \n为了应对这突如其来的变数， $IF$ 管理层决定先对联盟中所有的选手进行评估，以更好地掌握大局。 ", "description": "已知最近 $m$ 届比赛出现过的 $n$ 位选手，背后都有着各自财团的资助，并且签下了合同。由于这是各财团的高度机密，合同的具体细节无从得知，但铁拳财团的间谍们通过各种渠道得知了每个选手的薪金范围（显然薪金是非负数）。 \n对于最近 $m$ 届的 $IF$ 比赛（从 $1$ 开始编号），每一届联盟都会进行清算，通过国际金融手段准确计算出这一届联盟选手身价总和的变化。每一届中，会有一些新选手加入，也会有部分选手在比赛中丧失了战斗能力，而被踢出联盟，流放到贫民窟。                                                 \n现在给出联盟中 $n$ 位选手的身价范围，以及他们 进入联盟的届数（ $0$ 表示在 $m+1$ 届以前就已经是联盟选手） 和 离开联盟的届数（ $0$ 表示是现役选手）。同时给出最近 $m$ 届中，每一届联盟选手身价总和减去上一届的值。                         \n请你根据现有信息，尽可能准确地给出每个选手可能的薪金范围。各选手之间的薪金范围可以不同时成立，但对于一位选手的范围中的每一个数，都必须至少存在一种合法方案使该选手能得到相应薪金，而且这个范围跨度要尽可能大。        \n如果输入信息有误，请输出`-1`，表示无解。 ", "inputFormat": "第一行一个正整数 $m$，意义同上。                                 \n第二行包含 $m$ 个整数，第 $i$ 个表示第 $i$ 届中 选手身价总和 的变化情况。                        \n第三行一个正整数 $n$。                            \n接下来 $n$ 行，每行包含四个整数，分别表示 身价下限 、 身价上限 、 出道届数 、 退役届数，细节请参照上文。                      \n保证出道时间严格比退役时间小（ $0$ 除外）。 ", "outputFormat": "如果输入信息有误，仅输出一行一个整数`-1`。                      \n否则输出 $n$行，每行两个实数，第 $i$ 行表示第 $i$ 个选手实际身价的准确范围，并保留两位小数。 ", "hint": "#### 样例解释#1\n\n第二届只有 $3$ 号离开了，可以锁定 $3$ 号的薪金是 $1$。 \n\n如此一来， $1$ 号和 $2$ 号薪金之和为 $4$，那么 $1$ 号最少能拿 $1$，最多能拿 $2$；$2$ 号最少能拿到 $2$，最多能拿到 $3$。\n\n#### 数据范围\n\n\n对于 $100\\%$的数据，$1 \\le n \\le 200,1 \\le m \\le 100$，给定薪金范围不超过 $20000$。  ", "locale": "zh-CN"}}}
{"pid": "P6130", "type": "P", "difficulty": 6, "samples": [["3\n1 1\n2 2\n2 1", "574619649"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000]}, "tags": ["数学", "O2优化", "前缀和", "逆元"], "title": "随机红包", "background": "出题人准备发一个微信红包给一些人，他很好奇如何随机分配里面的钱。", "description": "出题人蒟蒻的红包里有着 $1$ 块钱，他要把这块钱随机分给 $n$ 个人。\n\n为了随机，他设计了以下算法进行分配：（用伪代码表示）\n```\na[0]=0,a[n]=1\nfor i=1 to n-1 do{\n    a[i]=rand()\n}\nsort(a)\nfor i=1 to n do{\n    money[i]=a[i]-a[i-1]\n}\n```\n这里的 `rand()` 函数会等概率随机返回一个 $[0,1]$ 之间的实数值，`sort()` 函数会将一个数组从小到大排序。\n\n现在，出题人蒟蒻很好奇得到钱数第 $k$ 少的人得到的钱的期望。\n\n由于他要根据这个值去推算他要发多少个红包，所以他要问你 $T$ 次。\n\n为了避免精度丢失，答案对 $998244353$ 取模。\n\n为了避免输出量过大，输出所有答案的异或和。", "inputFormat": "**本题有多组数据**。\n\n第一行为整数 $T$，表示数据组数。\n\n对于每组数据，一行两个整数 $n,k$。", "outputFormat": "共一行一个整数，表示所有询问的答案的异或和。", "hint": "**【样例解释】**\n\n第一个问题，$n=k=1$，答案是 $1$。\n\n第二个问题，较大的数在 $[\\dfrac{1}{2},1]$ 上均匀分布，期望为 $\\dfrac{3}{4}$，取模后为 $249561089$。\n\n第三个问题，较小的数在 $[0,\\dfrac{1}{2}]$ 上均匀分布，期望为 $\\dfrac{1}{4}$，取模后为 $748683265$。\n\n异或和为 $574619649$。\n\n------\n\n**【数据范围】**\n\n**本题采用捆绑测试**。\n\n$\\text{Subtask 1 (4 pts)}$：$n \\le 10$，$k=1$。\n\n$\\text{Subtask 2 (16 pts)}$：$n \\le 5 \\times 10^3$。\n\n$\\text{Subtask 3 (20 pts)}$：$k=1$。\n\n$\\text{Subtask 4 (28 pts)}$：$n \\le 10^5$。\n\n$\\text{Subtask 5 (32 pts)}$：没有任何额外限制。\n\n对于 $100\\%$ 的数据，$1 \\le k \\le n \\le 10^7$，$1 \\le T \\le 2 \\times 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "随机红包", "background": "出题人准备发一个微信红包给一些人，他很好奇如何随机分配里面的钱。", "description": "出题人蒟蒻的红包里有着 $1$ 块钱，他要把这块钱随机分给 $n$ 个人。\n\n为了随机，他设计了以下算法进行分配：（用伪代码表示）\n```\na[0]=0,a[n]=1\nfor i=1 to n-1 do{\n    a[i]=rand()\n}\nsort(a)\nfor i=1 to n do{\n    money[i]=a[i]-a[i-1]\n}\n```\n这里的 `rand()` 函数会等概率随机返回一个 $[0,1]$ 之间的实数值，`sort()` 函数会将一个数组从小到大排序。\n\n现在，出题人蒟蒻很好奇得到钱数第 $k$ 少的人得到的钱的期望。\n\n由于他要根据这个值去推算他要发多少个红包，所以他要问你 $T$ 次。\n\n为了避免精度丢失，答案对 $998244353$ 取模。\n\n为了避免输出量过大，输出所有答案的异或和。", "inputFormat": "**本题有多组数据**。\n\n第一行为整数 $T$，表示数据组数。\n\n对于每组数据，一行两个整数 $n,k$。", "outputFormat": "共一行一个整数，表示所有询问的答案的异或和。", "hint": "**【样例解释】**\n\n第一个问题，$n=k=1$，答案是 $1$。\n\n第二个问题，较大的数在 $[\\dfrac{1}{2},1]$ 上均匀分布，期望为 $\\dfrac{3}{4}$，取模后为 $249561089$。\n\n第三个问题，较小的数在 $[0,\\dfrac{1}{2}]$ 上均匀分布，期望为 $\\dfrac{1}{4}$，取模后为 $748683265$。\n\n异或和为 $574619649$。\n\n------\n\n**【数据范围】**\n\n**本题采用捆绑测试**。\n\n$\\text{Subtask 1 (4 pts)}$：$n \\le 10$，$k=1$。\n\n$\\text{Subtask 2 (16 pts)}$：$n \\le 5 \\times 10^3$。\n\n$\\text{Subtask 3 (20 pts)}$：$k=1$。\n\n$\\text{Subtask 4 (28 pts)}$：$n \\le 10^5$。\n\n$\\text{Subtask 5 (32 pts)}$：没有任何额外限制。\n\n对于 $100\\%$ 的数据，$1 \\le k \\le n \\le 10^7$，$1 \\le T \\le 2 \\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P6131", "type": "P", "difficulty": 4, "samples": [["6 16\n................\n..XXXX....XXX...\n...XXXX....XX...\n.XXXX......XXX..\n........XXXXX...\n..XXX....XXX....", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2011", "USACO"], "title": "[USACO11NOV] Cow Beauty Pageant S", "background": "", "description": "听说最近流行表皮有三个斑点的奶牛，Farmer John 迅速购买了不少这样的奶牛。但流行趋势也在改变，最近改为流行只有一个斑点的奶牛了。\n\nFJ 决定在他的奶牛上涂色，从而把三个斑点合并成一个。牛皮由一个 $N \\times M$ 的矩阵来表示，像这样：\n\n```plain\n................\n..XXXX....XXX...\n...XXXX....XX...\n.XXXX......XXX..\n........XXXXX...\n..XXX....XXX....\n```\n\n每个 `X` 表示斑点的一部分。如果两个 `X` 在竖直或水平方向上相邻，则它们属于同一个斑点（对角线相邻不算）。因此上面表示的是一头具有三个斑点的奶牛。\n\nFJ 可以通过将一些 `.` 涂成 `X` 来改变牛身上的图案。他希望使用尽可能少的涂料将三个斑点合并为一个斑点。对于上图，下面是一种消耗涂料最少的方案（只涂了 4 个格子，新涂的格将用 `*` 表示）：\n\n```plain\n................\n..XXXX....XXX...\n...XXXX*...XX...\n.XXXX..**..XXX..\n...*....XXXXX...\n..XXX....XXX....\n```\n\n现在请你帮 FJ 算出将三个斑点合并为一个斑点最少需要涂多少格子。", "inputFormat": "第一行两个整数 $N,M$（$1 \\leq N,M \\leq 50$）。\n\n接下来 $N$ 行，每行 $M$ 个字符（`.` 或 `X`），描述牛表皮的斑点分布情况。保证这头牛恰好有三个斑点。", "outputFormat": "输出将三个斑点合并为一个斑点最少需要涂多少格子。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO11NOV] Cow Beauty Pageant S", "background": "", "description": "听说最近流行表皮有三个斑点的奶牛，Farmer John 迅速购买了不少这样的奶牛。但流行趋势也在改变，最近改为流行只有一个斑点的奶牛了。\n\nFJ 决定在他的奶牛上涂色，从而把三个斑点合并成一个。牛皮由一个 $N \\times M$ 的矩阵来表示，像这样：\n\n```plain\n................\n..XXXX....XXX...\n...XXXX....XX...\n.XXXX......XXX..\n........XXXXX...\n..XXX....XXX....\n```\n\n每个 `X` 表示斑点的一部分。如果两个 `X` 在竖直或水平方向上相邻，则它们属于同一个斑点（对角线相邻不算）。因此上面表示的是一头具有三个斑点的奶牛。\n\nFJ 可以通过将一些 `.` 涂成 `X` 来改变牛身上的图案。他希望使用尽可能少的涂料将三个斑点合并为一个斑点。对于上图，下面是一种消耗涂料最少的方案（只涂了 4 个格子，新涂的格将用 `*` 表示）：\n\n```plain\n................\n..XXXX....XXX...\n...XXXX*...XX...\n.XXXX..**..XXX..\n...*....XXXXX...\n..XXX....XXX....\n```\n\n现在请你帮 FJ 算出将三个斑点合并为一个斑点最少需要涂多少格子。", "inputFormat": "第一行两个整数 $N,M$（$1 \\leq N,M \\leq 50$）。\n\n接下来 $N$ 行，每行 $M$ 个字符（`.` 或 `X`），描述牛表皮的斑点分布情况。保证这头牛恰好有三个斑点。", "outputFormat": "输出将三个斑点合并为一个斑点最少需要涂多少格子。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6132", "type": "P", "difficulty": 7, "samples": [["3 1 2\n0 1", "13"], ["8 2 3\n0 2 3", "7497953"], ["3000 2 3\n0 1 3", "500207304"], ["10000000 3 2\n0 3", "238588124"], ["876543210 233 4\n0 1 2 3", "467638557"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2019", "集训队互测", "O2优化", "矩阵加速", "组合数学", "生成函数", "快速傅里叶变换 FFT"], "title": "[集训队互测 2019] 简单计数", "background": "### 警告，滥用本题者将被封号。\n\n\n$\\mathsf C \\color{red}\\mathsf{auchySheep}$ 近期优化了他的 快速数论变换 (NTT) 模板的常数，现在他能在 $0.1\\text s$ 内轻松跑过 $n=10^9$ 了，所以他准备用下面的这个简单计数题也考验一下你的常数优化水平。", "description": "传说，在很久很久以前，有一张 $n​$ 个点的带标号**有向无环**图。每条边有一个颜色，为 $k$ 种不同颜色中的一种。这张图满足如下性质：\n\n- 每个点有不超过 $1$ 条出边  \n- 每个点的入边条数在集合 $S$ 中\n\n由于某种原因，你想知道这样的图的个数。由于这样的图可能很多，你只要输出答案对 $998244353​$ 取模的值。\n\n两个图不同当且仅当存在一条从某个点 $a$ 到某个点 $b$ 的有向边，它只在恰好一个图中出现，或在两个图中都出现但颜色不同。", "inputFormat": "第一行输入三个正整数 $n, k, |S|$。  \n第二行从小到大输入 $|S|$ 个不同的非负整数，表示 $S$ 集合中的元素。", "outputFormat": "输出一行一个 $[0,998244352]$ 的整数，表示符合题意的图的个数对 $998244353​$ 取模的值。", "hint": "【样例一解释】  \n有如下 $13$ 个符合题意的图，其中 $a \\to b$ 表示一条从 $a$ 连向 $b$ 的有向边：\n\n1. 没有边\n2. $1 \\to 2$\n3. $2 \\to 1$\n4. $1 \\to3$\n5. $3 \\to 1$\n6. $2 \\to 3$\n7. $3 \\to 2$\n8. $1 \\to 2 \\to 3$\n9. $1 \\to 3 \\to 2$\n10. $2 \\to 1 \\to 3$\n11. $2 \\to 3 \\to 1$\n12. $3 \\to 1 \\to 2$\n13. $3 \\to 2 \\to 1$\n\n【数据范围】  \n数据共分为 $7$ 个子任务。\n\n- 子任务 $1$（$5$ 分）：$n \\leq 8$。\n- 子任务 $2$（$10$ 分）：$n \\leq 5000$。\n- 子任务 $3$（$30$ 分）：$n \\leq 10^5$。\n- 子任务 $4$（$20$ 分）：$n \\leq 10^7$。\n- 子任务 $5$（$15$ 分）：$n \\leq 10^8$。\n- 子任务 $6$（$10$ 分）：$S=\\{0,1\\}$。\n- 子任务 $7$（$10$ 分）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 9 \\times 10^8​$，$1 \\le k \\le 10^7$，$S \\neq \\varnothing$，$S \\subseteq \\{0,1,2,3\\}$。 \n\nBy：fjzzq2002  \n来源：2019 年集训队互测 Day5", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2019] 简单计数", "background": "### 警告，滥用本题者将被封号。\n\n\n$\\mathsf C \\color{red}\\mathsf{auchySheep}$ 近期优化了他的 快速数论变换 (NTT) 模板的常数，现在他能在 $0.1\\text s$ 内轻松跑过 $n=10^9$ 了，所以他准备用下面的这个简单计数题也考验一下你的常数优化水平。", "description": "传说，在很久很久以前，有一张 $n​$ 个点的带标号**有向无环**图。每条边有一个颜色，为 $k$ 种不同颜色中的一种。这张图满足如下性质：\n\n- 每个点有不超过 $1$ 条出边  \n- 每个点的入边条数在集合 $S$ 中\n\n由于某种原因，你想知道这样的图的个数。由于这样的图可能很多，你只要输出答案对 $998244353​$ 取模的值。\n\n两个图不同当且仅当存在一条从某个点 $a$ 到某个点 $b$ 的有向边，它只在恰好一个图中出现，或在两个图中都出现但颜色不同。", "inputFormat": "第一行输入三个正整数 $n, k, |S|$。  \n第二行从小到大输入 $|S|$ 个不同的非负整数，表示 $S$ 集合中的元素。", "outputFormat": "输出一行一个 $[0,998244352]$ 的整数，表示符合题意的图的个数对 $998244353​$ 取模的值。", "hint": "【样例一解释】  \n有如下 $13$ 个符合题意的图，其中 $a \\to b$ 表示一条从 $a$ 连向 $b$ 的有向边：\n\n1. 没有边\n2. $1 \\to 2$\n3. $2 \\to 1$\n4. $1 \\to3$\n5. $3 \\to 1$\n6. $2 \\to 3$\n7. $3 \\to 2$\n8. $1 \\to 2 \\to 3$\n9. $1 \\to 3 \\to 2$\n10. $2 \\to 1 \\to 3$\n11. $2 \\to 3 \\to 1$\n12. $3 \\to 1 \\to 2$\n13. $3 \\to 2 \\to 1$\n\n【数据范围】  \n数据共分为 $7$ 个子任务。\n\n- 子任务 $1$（$5$ 分）：$n \\leq 8$。\n- 子任务 $2$（$10$ 分）：$n \\leq 5000$。\n- 子任务 $3$（$30$ 分）：$n \\leq 10^5$。\n- 子任务 $4$（$20$ 分）：$n \\leq 10^7$。\n- 子任务 $5$（$15$ 分）：$n \\leq 10^8$。\n- 子任务 $6$（$10$ 分）：$S=\\{0,1\\}$。\n- 子任务 $7$（$10$ 分）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 9 \\times 10^8​$，$1 \\le k \\le 10^7$，$S \\neq \\varnothing$，$S \\subseteq \\{0,1,2,3\\}$。 \n\nBy：fjzzq2002  \n来源：2019 年集训队互测 Day5", "locale": "zh-CN"}}}
{"pid": "P6134", "type": "P", "difficulty": 5, "samples": [["5 6\n1 2\n2 3\n3 5\n4 5\n1 5\n1 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "各省省选", "江苏", "拓扑排序", "bitset"], "title": "[JSOI2015] 最小表示", "background": "还记得去年 JYY 所研究的强连通分量的问题吗？去年的题目里，JYY 研究了对于有向图的“加边”问题。对于图论有着强烈兴趣的 JYY，今年又琢磨起了“删边”的问题。", "description": "对于一个 $N$ 个点（每个点从 $1$ 到 $N$ 编号），$M$ 条边的有向图，JYY 发现，如果从图中删去一些边，那么原图的连通性会发生改变；而也有一些边，删去之后图的连通性并不会发生改变。\n\nJYY 想知道，如果想要使得原图任意两点的连通性保持不变，我们最多能删掉多少条边呢？\n\n\n为了简化一下大家的工作量，这次 JYY 保证他给定的有向图一定是一个有向无环图（JYY：大家经过去年的问题，都知道对于给任意有向图的问题，最后都能转化为有向无环图上的问题，所以今年 JYY 就干脆简化一下大家的工作）。", "inputFormat": "第一行包含两个正整数 $N$ 和 $M$。\n\n接下来 $M$ 行，每行包含两个 $1$ 到 $N$ 之间的正整数 $x_i$ 和 $y_i$，表示图中存在一条从 $x_i$ 到 $y_i$ 的有向边。\n\n输入数据保证，任意两点间只会有至多一条边存在。", "outputFormat": "输出一行包含一个整数，表示JYY最多可以删掉的边数。", "hint": "### 样例解释\n\n一种合法方案为删去 $1\\rightarrow 5$ 和 $1\\rightarrow 3$。容易证明没有比 $2$ 更优的答案。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$1 \\leq N\\leq 3\\times 10^4$，$0 \\leq M\\leq 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2015] 最小表示", "background": "还记得去年 JYY 所研究的强连通分量的问题吗？去年的题目里，JYY 研究了对于有向图的“加边”问题。对于图论有着强烈兴趣的 JYY，今年又琢磨起了“删边”的问题。", "description": "对于一个 $N$ 个点（每个点从 $1$ 到 $N$ 编号），$M$ 条边的有向图，JYY 发现，如果从图中删去一些边，那么原图的连通性会发生改变；而也有一些边，删去之后图的连通性并不会发生改变。\n\nJYY 想知道，如果想要使得原图任意两点的连通性保持不变，我们最多能删掉多少条边呢？\n\n\n为了简化一下大家的工作量，这次 JYY 保证他给定的有向图一定是一个有向无环图（JYY：大家经过去年的问题，都知道对于给任意有向图的问题，最后都能转化为有向无环图上的问题，所以今年 JYY 就干脆简化一下大家的工作）。", "inputFormat": "第一行包含两个正整数 $N$ 和 $M$。\n\n接下来 $M$ 行，每行包含两个 $1$ 到 $N$ 之间的正整数 $x_i$ 和 $y_i$，表示图中存在一条从 $x_i$ 到 $y_i$ 的有向边。\n\n输入数据保证，任意两点间只会有至多一条边存在。", "outputFormat": "输出一行包含一个整数，表示JYY最多可以删掉的边数。", "hint": "### 样例解释\n\n一种合法方案为删去 $1\\rightarrow 5$ 和 $1\\rightarrow 3$。容易证明没有比 $2$ 更优的答案。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$1 \\leq N\\leq 3\\times 10^4$，$0 \\leq M\\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P6136", "type": "P", "difficulty": 5, "samples": [["6 7\n1 1 4 5 1 4\n2 1\n1 9\n4 1\n5 8\n3 13\n6 7\n1 4\n", "6\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["平衡树", "O2优化", "模板题"], "title": "【模板】普通平衡树（数据加强版）", "background": "本题是 P3369 数据加强版，**扩大数据范围**并增加了**强制在线**。\n\n**题目的输入、输出和原题略有不同**，但需要支持的操作相同。", "description": "您需要动态地维护一个可重集合 $M$，并且提供以下操作：\n\n1. 向 $M$ 中插入一个数 $x$。\n2. 从 $M$ 中删除一个数 $x$（若有多个相同的数，应只删除一个）。\n3. 查询 $M$ 中有多少个数比 $x$ 小，并且将得到的答案加一。\n4. 查询如果将 $M$ 从小到大排列后，排名位于第 $x$ 位的数。\n5. 查询 $M$ 中 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。\n6. 查询 $M$ 中 $x$ 的后继（后继定义为大于 $x$，且最小的数）。\n\n本题**强制在线**，保证所有操作合法（操作 $2$ 保证存在至少一个 $x$，操作 $4,5,6$ 保证存在答案）。", "inputFormat": "第一行两个正整数 $n,m$，表示**初始数的个数**和操作的个数。\n\n**第二行 $n$ 个整数 $a_1,a_2,a_3,\\ldots,a_n$，表示初始的数**。\n\n接下来 $m$ 行，每行有两个整数 $\\text{opt}$ 和 $x'$，$\\text{opt}$ 表示操作的序号（$ 1 \\leq \\text{opt} \\leq 6 $），$x'$ 表示加密后的操作数。\n\n我们记 $\\text{last}$ 表示上一次 $3,4,5,6$ 操作的答案，则每次操作的 $x'$ 都要**异或**上 $\\text{last}$ 才是真实的 $x$。初始 $\\text{last}$ 为 $0$。", "outputFormat": "输出一行一个整数，表示所有 $3,4,5,6$ 操作的答案的**异或和**。", "hint": "### 样例解释\n\n样例加密前为：\n```plain\n6 7\n1 1 4 5 1 4\n2 1\n1 9\n4 1\n5 9\n3 8\n6 1\n1 0\n```\n::::info[每一个操作的输出]\n执行第一个操作前，$M=\\{1,1,1,4,4,5\\}$，完成后 $M=\\{1,1,4,4,5\\}$。\n\n执行第二个操作后 $M=\\{1,1,4,4,5,9\\}$。\n\n第三个操作查询 $M$ 中第 $1$ 小的数字，答案为 $1$。\n\n第四个操作查询 $M$ 中 $9$ 的前驱，答案为 $5$。\n\n第五个操作查询 $M$ 中有多少个数比 $8$ 小，并且将答案加 $1$，答案为 $6$。\n\n第六个操作查询 $M$ 中 $1$ 的后继，答案为 $4$。\n\n第七个操作完成后 $M=\\{0,1,1,4,4,5,9\\}$。\n\n输出 $1\\oplus5\\oplus6\\oplus4=6$。\n::::\n\n### 限制与约定\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 10^5$，$1\\leq m\\leq 10^6$，$0\\leq a_i,x\\lt 2^{30}$。\n\n**本题输入数据较大，请使用较快的读入方式。**\n\n---\n\n$\\text{upd 2022.7.22}$：新增加 $9$ 组 Hack 数据。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【模板】普通平衡树（数据加强版）", "background": "本题是 P3369 数据加强版，**扩大数据范围**并增加了**强制在线**。\n\n**题目的输入、输出和原题略有不同**，但需要支持的操作相同。", "description": "您需要动态地维护一个可重集合 $M$，并且提供以下操作：\n\n1. 向 $M$ 中插入一个数 $x$。\n2. 从 $M$ 中删除一个数 $x$（若有多个相同的数，应只删除一个）。\n3. 查询 $M$ 中有多少个数比 $x$ 小，并且将得到的答案加一。\n4. 查询如果将 $M$ 从小到大排列后，排名位于第 $x$ 位的数。\n5. 查询 $M$ 中 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。\n6. 查询 $M$ 中 $x$ 的后继（后继定义为大于 $x$，且最小的数）。\n\n本题**强制在线**，保证所有操作合法（操作 $2$ 保证存在至少一个 $x$，操作 $4,5,6$ 保证存在答案）。", "inputFormat": "第一行两个正整数 $n,m$，表示**初始数的个数**和操作的个数。\n\n**第二行 $n$ 个整数 $a_1,a_2,a_3,\\ldots,a_n$，表示初始的数**。\n\n接下来 $m$ 行，每行有两个整数 $\\text{opt}$ 和 $x'$，$\\text{opt}$ 表示操作的序号（$ 1 \\leq \\text{opt} \\leq 6 $），$x'$ 表示加密后的操作数。\n\n我们记 $\\text{last}$ 表示上一次 $3,4,5,6$ 操作的答案，则每次操作的 $x'$ 都要**异或**上 $\\text{last}$ 才是真实的 $x$。初始 $\\text{last}$ 为 $0$。", "outputFormat": "输出一行一个整数，表示所有 $3,4,5,6$ 操作的答案的**异或和**。", "hint": "### 样例解释\n\n样例加密前为：\n```plain\n6 7\n1 1 4 5 1 4\n2 1\n1 9\n4 1\n5 9\n3 8\n6 1\n1 0\n```\n::::info[每一个操作的输出]\n执行第一个操作前，$M=\\{1,1,1,4,4,5\\}$，完成后 $M=\\{1,1,4,4,5\\}$。\n\n执行第二个操作后 $M=\\{1,1,4,4,5,9\\}$。\n\n第三个操作查询 $M$ 中第 $1$ 小的数字，答案为 $1$。\n\n第四个操作查询 $M$ 中 $9$ 的前驱，答案为 $5$。\n\n第五个操作查询 $M$ 中有多少个数比 $8$ 小，并且将答案加 $1$，答案为 $6$。\n\n第六个操作查询 $M$ 中 $1$ 的后继，答案为 $4$。\n\n第七个操作完成后 $M=\\{0,1,1,4,4,5,9\\}$。\n\n输出 $1\\oplus5\\oplus6\\oplus4=6$。\n::::\n\n### 限制与约定\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 10^5$，$1\\leq m\\leq 10^6$，$0\\leq a_i,x\\lt 2^{30}$。\n\n**本题输入数据较大，请使用较快的读入方式。**\n\n---\n\n$\\text{upd 2022.7.22}$：新增加 $9$ 组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P6137", "type": "P", "difficulty": 6, "samples": [["11\n2 5\n2 6\n3 3\n3 6\n4 3\n4 4\n4 5\n4 6\n5 3\n5 4\n5 6\n", "174"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "IOI"], "title": "[IOI 2012] 理想城", "background": null, "description": "像许多同龄的科学家和艺术家一样，小 L 对城市规划和城区设计很感兴趣.他致力于构建一个理想城。理想城由 $N$ 个区块组成，而这些区块放在一个无限大的正方形网格上。第 $x$ 行第 $y$ 列的单元格由有序数对 $(x,y)$来标识。单元格 $(0,0)$ 位于网格的左上角。给定一个单元格 $(x,y)$，与之相邻的单元格（如果存在的话）分别为：$(x-1,y)$，$(x+1,y)$，$(x,y-1)$，$(x,y+1)$。每个区块在网格上恰好覆盖一个单元格。一个区块能够被放置在单元格 $(x,y)$ 上，当且仅当 $1 \\le x,y \\le 2^{31}-2$ 。我们将使用单元格的坐标同时来代表单元格上面的区块。若两个区块被放在相邻的单元格中，则视它们为相邻区块.理想城所有的区块连在一起，里面没有“洞”存在.换言之，所有单元格必须满足下述两个条件：\n- 对于任意两个空白的单元格，至少存在一连串相邻的空白单元格连接它们。\n- 对于任意两个非空的单元格，至少存在一连串相邻的非空单元格连接它们。\n\n以下 $4$ 个图中的区块放置均不满足理想城的条件。前两个图不满足第一个条件。第 $3$ 个图不满足第二个条件，第 $4$ 个图两个条件均不满足。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uzw8c8c8.png)\n\n当遍历理想城时，一个**跳步**代表**从一个区块走到一个相邻的区块**。跳步时不能移进空白单元格。假设 $v_0,v_1,\\cdots,v_{N-1}$ 是 $N$ 个区块的坐标。对于任意两个不同的区块 $v_i$ 和 $v_j$，它们的距离 $d(v_i,v_j)$ 是从 $v_i$ 移动到 $v_j$ 所需的最小跳步数目。\n\n下图是一个由 $11$ 个区块组成的理想城。区块坐标分别为\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5whsvyjh.png)\n\n$$v_0=(2,5) \\quad v_1=(2,6) \\quad v_2=(3,3)$$\n$$v_3=(3,6) \\quad v_4=(4,3) \\quad v_5=(4,4)$$\n$$v_6=(4,5) \\quad v_7=(4,6) \\quad v_8=(5,3)$$\n$$v_9=(5,4) \\quad v_{10}=(5,6)$$\n\n\n其中，$d(v_1,v_3)=1$，$d(v_1,v_8)=6$，$d(v_6,v_{10})=2$，$d(v_9,v_{10})=4$。\n\n给定一个理想域，试求\n$$S=\\sum_{i=0}^{N-2}\\sum_{j=i+1}^{N-1}d(v_i,v_j)$$", "inputFormat": "第 $1$ 行为一个正整数 $N$，为理想城区块的数目。\n\n第 $2$ 行到第 $N+1$ 行，每行有两个非负整数。第 $i+2$ 行为第 $i$ 个区块的坐标 $v_i = (x_i， y_i)$。", "outputFormat": "输出仅一行一个正整数，为 $S$ 的值。由于 $S$ 的值可能较大，你只需输出 $S$ 对 $10^9$ 取模的值。", "hint": "对于 $100\\%$ 的数据，$1 \\le N \\le 10^5$，$1 \\le x_i,y_i \\le 2^{31}-2$ 。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2012] Ideal City", "background": "", "description": "Like many scientists and artists of his age, Little L is very interested in city planning and urban design. He is devoted to building an ideal city. The ideal city consists of $N$ blocks, and these blocks are placed on an infinite square grid. The cell in row $x$ and column $y$ is identified by the ordered pair $(x,y)$. The cell $(0,0)$ is located at the upper-left corner of the grid. Given a cell $(x,y)$, the adjacent cells (if they exist) are: $(x-1,y)$, $(x+1,y)$, $(x,y-1)$, $(x,y+1)$. Each block covers exactly one cell on the grid. A block can be placed on cell $(x,y)$ if and only if $1 \\le x,y \\le 2^{31}-2$. We will use the coordinates of a cell to also denote the block on that cell. If two blocks are placed in adjacent cells, they are considered adjacent blocks. All blocks in the ideal city are connected, and there are no “holes” inside. In other words, all cells must satisfy the following two conditions:\n\n- For any two empty cells, there exists at least one sequence of adjacent empty cells connecting them.\n- For any two non-empty cells, there exists at least one sequence of adjacent non-empty cells connecting them.\n\nThe block placements in the following $4$ figures do not satisfy the conditions of an ideal city. The first two figures do not satisfy the first condition. The $3$rd figure does not satisfy the second condition, and the $4$th figure satisfies neither condition.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uzw8c8c8.png)\n\nWhen traversing the ideal city, one **step** means **moving from one block to an adjacent block**. During a step, you cannot move into an empty cell. Suppose $v_0,v_1,\\cdots,v_{N-1}$ are the coordinates of the $N$ blocks. For any two different blocks $v_i$ and $v_j$, their distance $d(v_i,v_j)$ is the minimum number of steps needed to move from $v_i$ to $v_j$.\n\nThe figure below shows an ideal city consisting of $11$ blocks. The block coordinates are:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5whsvyjh.png)\n\n$$v_0=(2,5) \\quad v_1=(2,6) \\quad v_2=(3,3)$$\n$$v_3=(3,6) \\quad v_4=(4,3) \\quad v_5=(4,4)$$\n$$v_6=(4,5) \\quad v_7=(4,6) \\quad v_8=(5,3)$$\n$$v_9=(5,4) \\quad v_{10}=(5,6)$$\n\nHere, $d(v_1,v_3)=1$, $d(v_1,v_8)=6$, $d(v_6,v_{10})=2$, and $d(v_9,v_{10})=4$.\n\nGiven an ideal city, compute\n$$S=\\sum_{i=0}^{N-2}\\sum_{j=i+1}^{N-1}d(v_i,v_j)$$", "inputFormat": "The first line contains a positive integer $N$, the number of blocks in the ideal city.\n\nLines $2$ to $N+1$ each contain two non-negative integers. Line $i+2$ gives the coordinates of the $i$-th block $v_i = (x_i, y_i)$.", "outputFormat": "Output a single line containing a positive integer, the value of $S$. Since $S$ may be very large, you only need to output $S$ modulo $10^9$.", "hint": "For $100\\%$ of the testdata, $1 \\le N \\le 10^5$, and $1 \\le x_i,y_i \\le 2^{31}-2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2012] 理想城", "background": null, "description": "像许多同龄的科学家和艺术家一样，小 L 对城市规划和城区设计很感兴趣.他致力于构建一个理想城。理想城由 $N$ 个区块组成，而这些区块放在一个无限大的正方形网格上。第 $x$ 行第 $y$ 列的单元格由有序数对 $(x,y)$来标识。单元格 $(0,0)$ 位于网格的左上角。给定一个单元格 $(x,y)$，与之相邻的单元格（如果存在的话）分别为：$(x-1,y)$，$(x+1,y)$，$(x,y-1)$，$(x,y+1)$。每个区块在网格上恰好覆盖一个单元格。一个区块能够被放置在单元格 $(x,y)$ 上，当且仅当 $1 \\le x,y \\le 2^{31}-2$ 。我们将使用单元格的坐标同时来代表单元格上面的区块。若两个区块被放在相邻的单元格中，则视它们为相邻区块.理想城所有的区块连在一起，里面没有“洞”存在.换言之，所有单元格必须满足下述两个条件：\n- 对于任意两个空白的单元格，至少存在一连串相邻的空白单元格连接它们。\n- 对于任意两个非空的单元格，至少存在一连串相邻的非空单元格连接它们。\n\n以下 $4$ 个图中的区块放置均不满足理想城的条件。前两个图不满足第一个条件。第 $3$ 个图不满足第二个条件，第 $4$ 个图两个条件均不满足。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uzw8c8c8.png)\n\n当遍历理想城时，一个**跳步**代表**从一个区块走到一个相邻的区块**。跳步时不能移进空白单元格。假设 $v_0,v_1,\\cdots,v_{N-1}$ 是 $N$ 个区块的坐标。对于任意两个不同的区块 $v_i$ 和 $v_j$，它们的距离 $d(v_i,v_j)$ 是从 $v_i$ 移动到 $v_j$ 所需的最小跳步数目。\n\n下图是一个由 $11$ 个区块组成的理想城。区块坐标分别为\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5whsvyjh.png)\n\n$$v_0=(2,5) \\quad v_1=(2,6) \\quad v_2=(3,3)$$\n$$v_3=(3,6) \\quad v_4=(4,3) \\quad v_5=(4,4)$$\n$$v_6=(4,5) \\quad v_7=(4,6) \\quad v_8=(5,3)$$\n$$v_9=(5,4) \\quad v_{10}=(5,6)$$\n\n\n其中，$d(v_1,v_3)=1$，$d(v_1,v_8)=6$，$d(v_6,v_{10})=2$，$d(v_9,v_{10})=4$。\n\n给定一个理想域，试求\n$$S=\\sum_{i=0}^{N-2}\\sum_{j=i+1}^{N-1}d(v_i,v_j)$$", "inputFormat": "第 $1$ 行为一个正整数 $N$，为理想城区块的数目。\n\n第 $2$ 行到第 $N+1$ 行，每行有两个非负整数。第 $i+2$ 行为第 $i$ 个区块的坐标 $v_i = (x_i， y_i)$。", "outputFormat": "输出仅一行一个正整数，为 $S$ 的值。由于 $S$ 的值可能较大，你只需输出 $S$ 对 $10^9$ 取模的值。", "hint": "对于 $100\\%$ 的数据，$1 \\le N \\le 10^5$，$1 \\le x_i,y_i \\le 2^{31}-2$ 。", "locale": "zh-CN"}}}
