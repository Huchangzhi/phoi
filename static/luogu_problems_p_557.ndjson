{"pid": "P12304", "type": "P", "difficulty": 7, "samples": [["4 2\n1 2 10 5\n", "17\n"], ["4 6\n1 2 10 5\n", "10\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "2023", "ICPC", "WF"], "title": "[ICPC 2022/2023 WF] Bridging the Gap", "background": "", "description": "A group of walkers arrives at a river in the night. They want to cross a bridge, which can hold a limited number of walkers at a time. The walkers have just one torch, which needs to be used when crossing the bridge. Each walker takes a certain time to cross; a group crossing together must walk at the slowest walker's pace. What is the shortest time it takes for all walkers to cross the bridge?\n\nFor example, Sample Input 1 assumes the bridge can hold $2$ walkers at a time and there are $4$ walkers with crossing times $1$ minute, $2$ minutes, $5$ minutes and $10$ minutes, respectively. The shortest time of $17$ minutes can be achieved by the following sequence of crossings. First, the two fastest walkers cross in $2$ minutes. Second, the fastest walker crosses back in $1$ minute. Third, the two slowest walkers cross in $10$ minutes. Fourth, the second-fastest walker crosses back in $2$ minutes. Fifth, the two fastest walkers cross in $2$ minutes.", "inputFormat": "The first line of input contains two integers $n$ and $c$, where $n$ ($2 \\le n \\le 10^4$) is the number of walkers, and $c$ ($2 \\le c \\le 10^4$) is the number of walkers the bridge can hold at a time.\n\nThen follows a line containing $n$ integers $t_1, \\ldots , t_n$ ($1 \\le t_i \\le 10^9$ for all $i$). The $i^\\text{th}$ walker takes time $t_i$ to cross.", "outputFormat": "Output the minimum total time it takes for the entire group to cross the bridge.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022/2023 WF] Bridging the Gap", "background": "", "description": "A group of walkers arrives at a river in the night. They want to cross a bridge, which can hold a limited number of walkers at a time. The walkers have just one torch, which needs to be used when crossing the bridge. Each walker takes a certain time to cross; a group crossing together must walk at the slowest walker's pace. What is the shortest time it takes for all walkers to cross the bridge?\n\nFor example, Sample Input 1 assumes the bridge can hold $2$ walkers at a time and there are $4$ walkers with crossing times $1$ minute, $2$ minutes, $5$ minutes and $10$ minutes, respectively. The shortest time of $17$ minutes can be achieved by the following sequence of crossings. First, the two fastest walkers cross in $2$ minutes. Second, the fastest walker crosses back in $1$ minute. Third, the two slowest walkers cross in $10$ minutes. Fourth, the second-fastest walker crosses back in $2$ minutes. Fifth, the two fastest walkers cross in $2$ minutes.", "inputFormat": "The first line of input contains two integers $n$ and $c$, where $n$ ($2 \\le n \\le 10^4$) is the number of walkers, and $c$ ($2 \\le c \\le 10^4$) is the number of walkers the bridge can hold at a time.\n\nThen follows a line containing $n$ integers $t_1, \\ldots , t_n$ ($1 \\le t_i \\le 10^9$ for all $i$). The $i^\\text{th}$ walker takes time $t_i$ to cross.", "outputFormat": "Output the minimum total time it takes for the entire group to cross the bridge.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022/2023 WF] 过桥", "background": "", "description": "一群徒步旅行者在晚上来到一条河边。他们要过一座桥，但桥每次只能容纳有限的旅行者。旅行者只有一个手电筒，过桥时必须使用。每个旅行者都需要一定的时间过桥；一起过桥的旅行者必须以最慢的那个旅行者的速度步行。所有旅行者过桥所需的最短时间是多少？\n\n例如，样例一假设一座桥可以同时容纳 $2$ 个旅行者，有 $4$ 个旅行者要过桥，他们的过桥时间分别是 $1$ 分钟，$2$ 分钟，$5$ 分钟和 $10$ 分钟。$17$ 分钟的最短用时可以按如下过桥序列得到。首先，最快的两个旅行者过桥，用时 $2$ 分钟。然后，最快的旅行者过桥回来，用时 $1$ 分钟。第三步，最慢的两个旅行者过桥，用时 $10$ 分钟。第四步，第二快的旅行者过桥回来，用时 $2$ 分钟。最后，最快的两个旅行者过桥，用时 $2$ 分钟。", "inputFormat": "第一行两个整数 $n$ 和 $c$，其中 $n$（$2\\le n\\le 10^4$）为旅行者人数，$c$（$2\\le c\\le 10^4$）为这座桥同时可以容纳的旅行者人数。\n\n接下来一行 $n$ 个整数 $t_1,\\ldots,t_n$（$1\\le t_i\\le 10^9$）。第 $i$ 个旅行者过桥的用时为 $t_i$。", "outputFormat": "输出这些旅行者过桥所需的最短时间。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12305", "type": "P", "difficulty": 6, "samples": [["5 8\nABCDEP\nAEHOXU\nAISOLR\nABCDEF\nABCSCC\nPARSE\nPAUSE\nPHASE\nPOISE\nPROSE\nPULSE\nPURSE\nPEACE\n", "9.677887141\n"], ["2 1\nAAAAAA\nBBBBBB\nAB\n", "1.0\n"], ["3 1\n123456\n123456\n123456\n666\n", "10.555444555\n"], ["2 1\nABCDEF\nGHI234\nAB\n", "impossible\n"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2023 WF] Alea Iacta Est", "background": "", "description": "You play a game with multiple fair six-sided dice. Each die's face displays a single symbol. The objective of the game is to roll the dice and create a valid word from the symbols on top of each die. If you cannot form a word, you may reroll the dice for another attempt.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qfyfnr7e.png)\n\nFigure K.1: Five dice making a valid word corresponding to Sample Input 1.\n\nSuppose there are five dice: one of them contains letters `A`, `B`, `C`, `D`, `E`, and `P` (abbreviated as `ABCDEP`), and the other dice contain letters `AEHOXU`, `AISOLR`, `ABCDEF`, and `ABCSCC`. The first roll yields the following letters on the tops of respective dice: `P`, `X`, `R`, `E`, and `S`. As it is impossible to arrange these letters into a valid word, you decide to keep the `P`, `S`, and `E`, and reroll the other dice, in an attempt to make words like `PARSE`, `PAUSE`, `PHASE`, `POISE`, `PROSE`, `PULSE`, or `PURSE`. The two dice yield `E` and `A`, resulting in the following five letters: `P`, `E`, `A`, `E`, and `S`. You still cannot think of a valid word, so you decide to keep four letters and reroll only the last die, which has three sides with letter `C`. By doing so, there is a $50\\%$ chance that it will be possible to make a final valid word: `PEACE`, as shown in Figure K.1.\n\nWhen you roll a die, it lands on any one of its faces with equal probability. What is the expected number of rolls needed to make a valid word, assuming you use an optimal strategy?", "inputFormat": "The first line of input contains two numbers $d$ and $w$, where $d$ ($1 \\le d \\le 6$) is the number of dice and $w$ ($1 \\le w \\le 2\\cdot 10^5$) is the number of valid words in the dictionary. The following $d$ lines each have $6$ symbols, one for each face of the die. The final $w$ lines contain $w$ distinct valid words in the dictionary. Every word has exactly $d$ symbols.\n\nAll symbols in the input are either uppercase letters (`A-Z`) or digits (`0-9`).", "outputFormat": "If it is possible to make a valid word, output the expected number of rolls needed to make a valid word when using an optimal strategy. Otherwise, output `impossible`. Your answer should have an absolute or relative error of at most $10^{-6}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2023 WF] Alea Iacta Est", "background": "", "description": "You play a game with multiple fair six-sided dice. Each die's face displays a single symbol. The objective of the game is to roll the dice and create a valid word from the symbols on top of each die. If you cannot form a word, you may reroll the dice for another attempt.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qfyfnr7e.png)\n\nFigure K.1: Five dice making a valid word corresponding to Sample Input 1.\n\nSuppose there are five dice: one of them contains letters `A`, `B`, `C`, `D`, `E`, and `P` (abbreviated as `ABCDEP`), and the other dice contain letters `AEHOXU`, `AISOLR`, `ABCDEF`, and `ABCSCC`. The first roll yields the following letters on the tops of respective dice: `P`, `X`, `R`, `E`, and `S`. As it is impossible to arrange these letters into a valid word, you decide to keep the `P`, `S`, and `E`, and reroll the other dice, in an attempt to make words like `PARSE`, `PAUSE`, `PHASE`, `POISE`, `PROSE`, `PULSE`, or `PURSE`. The two dice yield `E` and `A`, resulting in the following five letters: `P`, `E`, `A`, `E`, and `S`. You still cannot think of a valid word, so you decide to keep four letters and reroll only the last die, which has three sides with letter `C`. By doing so, there is a $50\\%$ chance that it will be possible to make a final valid word: `PEACE`, as shown in Figure K.1.\n\nWhen you roll a die, it lands on any one of its faces with equal probability. What is the expected number of rolls needed to make a valid word, assuming you use an optimal strategy?", "inputFormat": "The first line of input contains two numbers $d$ and $w$, where $d$ ($1 \\le d \\le 6$) is the number of dice and $w$ ($1 \\le w \\le 2\\cdot 10^5$) is the number of valid words in the dictionary. The following $d$ lines each have $6$ symbols, one for each face of the die. The final $w$ lines contain $w$ distinct valid words in the dictionary. Every word has exactly $d$ symbols.\n\nAll symbols in the input are either uppercase letters (`A-Z`) or digits (`0-9`).", "outputFormat": "If it is possible to make a valid word, output the expected number of rolls needed to make a valid word when using an optimal strategy. Otherwise, output `impossible`. Your answer should have an absolute or relative error of at most $10^{-6}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 WF] 骰子已被掷下", "background": "", "description": "> 译者注：标题原文为 [*Alea Iacta Est*](https://en.wikipedia.org/wiki/Alea_iacta_est)，常被译作「破釜沉舟」，「木已成舟」等。本题题目取其掷骰子的本意。\n\n你正在用一些六面公平骰子玩游戏。骰子的每个表面有一个符号。游戏的目的是掷出骰子并根据每个骰子上面的符号组成一个合法的单词。如果不能组成一个单词，可以重新掷骰子再试一次。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qfyfnr7e.png)\n\n图 K.1. 样例 1 中形成合法单词的五个骰子\n\n假设有五个骰子：其中一个包含字母 `A`、`B`、`C`、`D`、`E` 和 `P`（简写为 `ABCDEP`），其他骰子包含字母 `AEHOXU`、`AISOLR`、`ABCDEF` 和 `ABCSCC`。第一次掷骰子时，骰子朝上的面会出现以下字母：`P`、`X`、`R`、`E` 和 `S`。由于无法将这些字母组合成一个合法的单词，你决定保留 `P`、`S` 和 `E`，重新掷其他骰子，试图组成 `PARSE`、`PAUSE`、`PHASE`、`POISE`、`PROSE`、`PULSE` 或 `PURSE` 等单词。重新掷两颗骰子，分别掷出 `E` 和 `A`，得到以下五个字母：`P`、`E`、`A`、`E` 和 `S`。你仍然想不到一个合法的单词，于是决定保留四个字母，只重新掷最后一个骰子，该骰子三面都是字母 `C`。如图 K.1 所示，这样做有 $50\\%$ 的几率可以得到一个最终有效的单词：`PEACE`。\n\n当你掷骰子时，骰子每个面朝上的概率相等。假定使用最优策略，那么掷出一个合法单词所需的期望掷骰次数是多少？", "inputFormat": "第一行输入包含两个数字 $d$ 和 $w$，其中 $d$（$1 \\le d \\le 6$）是骰子的个数，$w$（$1 \\le w \\le 2\\cdot 10^5$）是字典中合法单词的个数。接下来 $d$ 行每行有 $6$ 个符号，表示骰子的每个面上的符号。最后的 $w$ 行包含字典中 $w$ 个互不相同的合法单词。每个单词恰好包含 $d$ 个符号。\n\n输入中所有符号要么是大写英文字母（`A-Z`），要么是数字（`0-9`）。", "outputFormat": "如果有可能掷出一个合法单词，则输出使用最优策略掷出一个合法单词所需的期望掷骰次数。否则，输出 `impossible`。输出与答案的绝对或相对误差应不超过 $10^{-6}$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12306", "type": "P", "difficulty": 4, "samples": [["5\n4 2 5 3 1\n", "7.000\n"], ["6\n1 2 3 4 5 6\n", "13.500\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2022 WF]  Doing the Container Shuffle", "background": "", "description": "Majestic cargo ships, each carrying thousands of shipping containers, roam the world's seas every day. They make modern trade possible by being so efficient that shipping goods halfway around the world costs only pennies.\n\nOnce the ships reach their destination, their standard-size cargo containers are unloaded from the ship onto stacks on land, from which they are moved to trains or trucks that deliver them to their destination. It turns out that moving containers is expensive, so port operators try to minimize the number of moves necessary for delivering cargo.\n\nIn this problem, we consider such a container-unloading scenario. We need to unload $n$ containers, which are placed into two stacks built from bottom to top. The placement of each container is at random, with equal probability it will be put onto the first or the second stack (independently of other containers). Once all containers are unloaded, they will be picked up by trucks in a given order. When a truck wants to load a specific container, there are two cases. If the container is on top of its stack, then the container can be moved to the truck without moving any other containers. Otherwise, containers have to be moved from one stack to the other until the requested container is at the top of its stack. At that point the container can be moved onto the truck.\n\nAs an example, consider a case of three containers that arrive in order 1, 2, 3. Assume that 1 and 3 are in the first stack, and 2 is in the second. If the containers are moved onto trucks in order 1, 2, 3, then five moves of containers have to take place:\n\n|    Stack $1$    |    Stack $2$     |                Comment                |\n| :------------: | :-------------: | :--------------------------------: |\n|     `1 3`      |       `2`       |        Initial configuration (stacks bottom to top)        |\n|      `1`       |      `2 3`      | Move container $3$ from stack $1$ to stack $2$ |\n|                | `2 3` |     Move container $1$ to truck      |\n|      `3`       |       `2`       | Move container $3$ from stack $2$ to stack $1$ |\n| `3`  |                 |     Move container $2$ to truck      |\n|                |       |     Move container $3$ to truck      |\n\nWe want to know how many moves are necessary to deliver all containers to the customers. Assuming that container placement is random, we ask you to compute the expected number of moves necessary for a given truck-loading order.", "inputFormat": "The first line of input contains an integer $n$ ($1 \\le n \\le 10^6$), the number of containers. The containers are numbered $1, 2, \\ldots , n$, and are unloaded from the ship in this order. The second line of input contains $n$ integers $a_1, \\ldots , a_n$. These numbers are a permutation of $\\{1, 2, \\ldots , n\\}$, and specify the order in which the containers are loaded onto trucks.", "outputFormat": "Output the expected number of moves necessary to load the containers onto the trucks — this excludes the cost of unloading them from the ship, but includes both moves between stacks and from a stack to a truck. Your answer should have an absolute error of at most $10^{-3}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 WF]  Doing the Container Shuffle", "background": "", "description": "Majestic cargo ships, each carrying thousands of shipping containers, roam the world's seas every day. They make modern trade possible by being so efficient that shipping goods halfway around the world costs only pennies.\n\nOnce the ships reach their destination, their standard-size cargo containers are unloaded from the ship onto stacks on land, from which they are moved to trains or trucks that deliver them to their destination. It turns out that moving containers is expensive, so port operators try to minimize the number of moves necessary for delivering cargo.\n\nIn this problem, we consider such a container-unloading scenario. We need to unload $n$ containers, which are placed into two stacks built from bottom to top. The placement of each container is at random, with equal probability it will be put onto the first or the second stack (independently of other containers). Once all containers are unloaded, they will be picked up by trucks in a given order. When a truck wants to load a specific container, there are two cases. If the container is on top of its stack, then the container can be moved to the truck without moving any other containers. Otherwise, containers have to be moved from one stack to the other until the requested container is at the top of its stack. At that point the container can be moved onto the truck.\n\nAs an example, consider a case of three containers that arrive in order 1, 2, 3. Assume that 1 and 3 are in the first stack, and 2 is in the second. If the containers are moved onto trucks in order 1, 2, 3, then five moves of containers have to take place:\n\n|    Stack $1$    |    Stack $2$     |                Comment                |\n| :------------: | :-------------: | :--------------------------------: |\n|     `1 3`      |       `2`       |        Initial configuration (stacks bottom to top)        |\n|      `1`       |      `2 3`      | Move container $3$ from stack $1$ to stack $2$ |\n|                | `2 3` |     Move container $1$ to truck      |\n|      `3`       |       `2`       | Move container $3$ from stack $2$ to stack $1$ |\n| `3`  |                 |     Move container $2$ to truck      |\n|                |       |     Move container $3$ to truck      |\n\nWe want to know how many moves are necessary to deliver all containers to the customers. Assuming that container placement is random, we ask you to compute the expected number of moves necessary for a given truck-loading order.", "inputFormat": "The first line of input contains an integer $n$ ($1 \\le n \\le 10^6$), the number of containers. The containers are numbered $1, 2, \\ldots , n$, and are unloaded from the ship in this order. The second line of input contains $n$ integers $a_1, \\ldots , a_n$. These numbers are a permutation of $\\{1, 2, \\ldots , n\\}$, and specify the order in which the containers are loaded onto trucks.", "outputFormat": "Output the expected number of moves necessary to load the containers onto the trucks — this excludes the cost of unloading them from the ship, but includes both moves between stacks and from a stack to a truck. Your answer should have an absolute error of at most $10^{-3}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 WF] 移动集装箱", "background": "", "description": "每天都有载有数千个集装箱宏伟货轮在海上航行。使用海运将货物运送到地球另一端的花费极低，这种高效的运输方式使现代贸易成为可能。\n\n当货轮到达港口时，它所携带的标准尺寸集装箱就从船上卸下并堆叠在陆地上，然后再转运到火车或卡车上运送至最终目的地。事实证明，集装箱移动是一项费用高昂的工作，因此港口操作人员会尽量减少货物交付过程中的移动次数。\n\n本题中，我们考虑这样一个集装箱卸载场景。我们需要卸载 $n$ 个集装箱，将它们放置在两个从底部向上建立的堆栈中。每个集装箱都随机放置，它们会等概率地被放在第一或第二个堆栈中（独立于其他集装箱）。所有集装箱都被卸载后，它们将按照给定的顺序装载到卡车上。当一辆卡车需要装一个特定的集装箱时，有两种情况。如果该集装箱在堆栈的顶部，那么它可以直接移动到卡车上而无需移动其他集装箱。否则，必须将集装箱从一个堆栈移动到另一个堆栈，直至所需集装箱位于堆栈的顶部，然后才能移动到卡车上。\n\n例如，考虑三个集装箱按照 $1,2,3$ 的顺序到达的情况。假设 $1$ 和 $3$ 在第一个堆栈，$2$ 在第二个堆栈。如果集装箱按照 $1,2,3$ 的顺序装载到卡车上，那么需要进行 $5$ 次集装箱移动：\n\n|    堆栈 $1$    |    堆栈 $2$     |                注释                |\n| :------------: | :-------------: | :--------------------------------: |\n|     `1 3`      |       `2`       |        初始状态（自底向上）        |\n|      `1`       |      `2 3`      | 将集装箱 $3$ 从堆栈 $1$ 移动到 $2$ |\n|                | `2 3` |     将集装箱 $1$ 移动到卡车上      |\n|      `3`       |       `2`       | 将集装箱 $3$ 从堆栈 $2$ 移动到 $1$ |\n| `3`  |                 |     将集装箱 $2$ 移动到卡车上      |\n|                |       |     将集装箱 $3$ 移动到卡车上      |\n\n我们想知道把所有集装箱交付给客户所需的移动次数。假设集装箱的放置是随机的，请计算给定的卡车装载顺序所需的移动次数的期望。", "inputFormat": "第一行一个整数 $n$（$1\\le n\\le 10^6$），表示集装箱的数量。集装箱的编号为 $1, 2, \\ldots , n$，并按此顺序从船上卸下。第二行包含 $n$ 个整数 $a_1, \\ldots , a_n$。这些整数是 $\\{1, 2, \\ldots , n\\}$ 的一个排列，表示集装箱装上卡车的顺序。", "outputFormat": "输出将集装箱装上卡车所需的移动次数的期望——这不包括将集装箱从船上卸下的移动次数，但包括在堆栈之间移动和从堆栈到卡车的移动。输出与答案之间的绝对误差应不超过 $10^{-3}$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12307", "type": "P", "difficulty": 7, "samples": [["3 3\n1 4\n4 7\n7 1\n1 2\n2 3\n1 3\n", "possible\n"], ["2 1\n1 2\n2 1\n1 2\n", "impossible\n"], ["5 6\n10 40\n20 30\n30 50\n40 20\n50 10\n1 2\n2 3\n1 3\n3 4\n3 5\n4 5\n", "possible\n"], ["4 4\n10 10\n10 20\n20 10\n20 20\n1 2\n2 3\n3 4\n1 4\n", "impossible\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["图论", "2022", "Tarjan", "双连通分量", "ICPC", "分类讨论", "WF"], "title": "[ICPC 2022 WF] Zoo Management", "background": "", "description": "When managing a zoo, you sometimes want to move the animals between enclosures. You might figure out that the zebras will enjoy the spacier enclosure currently occupied by the penguins, while the penguins might want to move to the colder enclosure where the koalas currently live; and koalas will move to an empty enclosure that can be filled up with eucalyptus. So, you would move the koalas first, to free up the colder enclosure, then move the penguins there, and finally move the zebras.\n\nThe way you move animals is by using special tunnels that connect the enclosures — you do not want the animals to move outside, both because of the risk that they will be scared, and because of the risk that they might run away and hurt themselves.\n\nUnfortunately, you have acquired more animals recently, and all the enclosures are now full, which makes moving animals around much harder. Imagine, for instance, that the koalas were to move to the former zebra enclosure — you cannot move any set of animals first. Instead, what you learned to do, is to move the animals at the same time — the zebras, koalas and penguins start moving down different tunnels at the same time, and arrive at their new enclosures at the same time — and thus they never meet. Note that you cannot just swap the animals in two connected enclosures this way (because they would meet in the tunnel and become scared).\n\nSo, now you have a puzzle. You have a list of enclosures, each with an animal type inside; some of those enclosures are connected by tunnels. You can, any number of times, choose some set of animals and move each one to an enclosure adjacent by tunnel, as long as the animal in that enclosure is also moved as the part of the same move, and no tunnel is used more than once as a part of the same move. You also have your vision of the perfect way to position the animals. Is it possible to do so, in a series of moves?", "inputFormat": "The first line of the input consists of two integers $n$ ($1 \\le n \\le 4\\cdot 10^5$) and $m$ ($0 \\le m \\le 4\\cdot 10^5$), indicating the number of enclosures and tunnels. Then follow $n$ lines, the $i^\\text{th}$ of which contains two integers $b_i$ ($1 \\le b_i \\le 10^6$) and $e_i$ ($1 \\le e \\le 10^6$), indicating the type of animal that is in enclosure $i$ at the beginning, and the type of animal that you want to be in enclosure $i$ after all the moves. You may assume that $e_1, \\ldots , e_n$ is a permutation of $b_1, \\ldots , b_n$.\n\nThen follow $m$ lines describing the tunnels. Each line contains two integers $x$ and $y$ ($1 \\le x < y \\le n$), indicating that enclosures $x$ and $y$ are connected by a two-way tunnel. No two enclosures are connected by more than one tunnel.", "outputFormat": "If it is possible to move the animals so that every enclosure contains the desired animal type, output `possible`. Otherwise, output `impossible`.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 WF] Zoo Management", "background": "", "description": "When managing a zoo, you sometimes want to move the animals between enclosures. You might figure out that the zebras will enjoy the spacier enclosure currently occupied by the penguins, while the penguins might want to move to the colder enclosure where the koalas currently live; and koalas will move to an empty enclosure that can be filled up with eucalyptus. So, you would move the koalas first, to free up the colder enclosure, then move the penguins there, and finally move the zebras.\n\nThe way you move animals is by using special tunnels that connect the enclosures — you do not want the animals to move outside, both because of the risk that they will be scared, and because of the risk that they might run away and hurt themselves.\n\nUnfortunately, you have acquired more animals recently, and all the enclosures are now full, which makes moving animals around much harder. Imagine, for instance, that the koalas were to move to the former zebra enclosure — you cannot move any set of animals first. Instead, what you learned to do, is to move the animals at the same time — the zebras, koalas and penguins start moving down different tunnels at the same time, and arrive at their new enclosures at the same time — and thus they never meet. Note that you cannot just swap the animals in two connected enclosures this way (because they would meet in the tunnel and become scared).\n\nSo, now you have a puzzle. You have a list of enclosures, each with an animal type inside; some of those enclosures are connected by tunnels. You can, any number of times, choose some set of animals and move each one to an enclosure adjacent by tunnel, as long as the animal in that enclosure is also moved as the part of the same move, and no tunnel is used more than once as a part of the same move. You also have your vision of the perfect way to position the animals. Is it possible to do so, in a series of moves?", "inputFormat": "The first line of the input consists of two integers $n$ ($1 \\le n \\le 4\\cdot 10^5$) and $m$ ($0 \\le m \\le 4\\cdot 10^5$), indicating the number of enclosures and tunnels. Then follow $n$ lines, the $i^\\text{th}$ of which contains two integers $b_i$ ($1 \\le b_i \\le 10^6$) and $e_i$ ($1 \\le e \\le 10^6$), indicating the type of animal that is in enclosure $i$ at the beginning, and the type of animal that you want to be in enclosure $i$ after all the moves. You may assume that $e_1, \\ldots , e_n$ is a permutation of $b_1, \\ldots , b_n$.\n\nThen follow $m$ lines describing the tunnels. Each line contains two integers $x$ and $y$ ($1 \\le x < y \\le n$), indicating that enclosures $x$ and $y$ are connected by a two-way tunnel. No two enclosures are connected by more than one tunnel.", "outputFormat": "If it is possible to move the animals so that every enclosure contains the desired animal type, output `possible`. Otherwise, output `impossible`.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 WF] 动物园管理", "background": "", "description": "在管理一个动物园的时候，你有时需要在不同的动物馆之间移动动物。你可能会发现斑马会喜欢更宽敞的企鹅馆，而企鹅可能想搬到目前考拉所在的更冷的场馆里；考拉则可以搬到一个没有动物居住，但充满桉树的场馆里。因此你会先移动考拉，腾出那个更冷的场馆，然后将企鹅移到那里，最后再把斑马移过去。\n\n你移动动物的方式是使用连接这些场馆的特殊隧道——你不希望动物在户外移动，因为这会让它们受到惊吓，并且可能会逃走并伤到他们自己。\n\n不幸的是，你最近又收养了更多的动物，所有的动物馆现在都已经满了，这使得移动动物变得更加困难。比如说，如果你想将考拉搬到之前斑马所在的圈子里——你无法先移动任何一种动物。你反而学会了同时移动动物——将斑马、考拉和企鹅同时通过不同的隧道进行移动，并且同时到达各自的新场馆——这样它们就不会相遇。请注意，你不能仅仅交换两个相连场馆里的动物（因为它们会在隧道里相遇并受到惊吓）。\n\n因此，现在你面临一个难题。你有一个动物馆的列表，每个场馆里都有一种动物；有些场馆通过隧道相连。你可以任意次数地选择某些动物，将它们移动到与隧道连接的另一个场馆，前提是该场馆里的动物也要作为同一次移动的一部分被移动，并且同一次移动中不能使用同一条隧道超过一次。你也有自己关于动物最佳分布的设想。请问，你是否能够通过一系列移动实现这个目标？", "inputFormat": "第一行包含两个整数 $n$ 和 $m$（$1\\le n\\le 4\\cdot 10^5,0\\le m\\le 4\\cdot 10^5$），分别表示动物馆数和隧道数。然后 $n$ 行，第 $i$ 行包含两个整数 $b_i$ 和 $e_i$（$1\\le b_i,e_i\\le 10^6$），表示动物馆 $i$ 开始时居住的动物种类和在所有移动结束后你希望居住在动物馆 $i$ 的动物种类。你可以假设 $e_1,\\ldots,e_n$ 是 $b_1,\\ldots,b_n$ 的一个排列。\n\n接下来 $m$ 行描述隧道，每行两个整数 $x$ 和 $y$（$1\\le x<y\\le n$），表示动物馆 $x$ 和 $y$ 之间被一条双向隧道连接。没有两个动物馆被超过一条隧道连接。", "outputFormat": "如果可以通过一系列移动操作，使得每个动物馆都容纳希望的动物类型，则输出 `possible`。否则输出 `impossible`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12308", "type": "P", "difficulty": 5, "samples": [["4 12\n", "LSRLLRLSLSRLLSRL\n"], ["1 5\n", "LLLL\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "Special Judge", "构造", "ICPC", "WF"], "title": "[ICPC 2022 WF] Toy Train Tracks", "background": "", "description": "Every little child, and quite a number of adults, are fascinated by toy trains. From a toddler's choo-choo train to a hobbyist's elaborate model railroad filling an entire basement, they are a profitable business. The Toy Train Tracks Construction Company (TTTCC) manufactures train tracks for all ages and skill levels. To keep their existing customers busy and maybe attract some new ones, the TTTCC has recently started publishing maps for how to connect their train tracks into elaborate layouts. Usually, this starts with a designer coming up with an interesting track layout, and then publishing both the layout and the required number of different track segments (say, curves and straight parts) needed to construct it. But the TTTCC has recently learned that many customers are looking for the reverse: they already have train track segments lying around (maybe found in grandma's attic), and would like to use them to create a large train course. How difficult might that be?\n\nTo study the feasibility of automating the layout-creation process, TTTCC is interested in constructing train courses using two different shapes: straight line segments, and $90$-degree turns (see Figure U.1).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qc95fugq.png)\n\nFigure U.1: A straight track segment and a curved track segment.\n\nValid layouts are created by placing these shapes on a square grid, with each track piece taking up exactly one grid cell. Both types of pieces can be rotated in $90$-degree increments. A \"proper\" train track needs to be connected, and should form a single closed loop. Given a set of straight and curved track segments, what is the longest closed loop that one can construct?\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/snvx45ju.png)\n\nFigure U.2: A sample track using four straight track segments and twelve curves. This corresponds to Sample Output 1.", "inputFormat": "The input consists of a single line containing two integers $s$ and $c$, the number of straight and curved track segments available, respectively ($0 \\le s \\le 10^5$, $4 \\le c \\le 10^5$).", "outputFormat": "Output a train loop using at most $s$ straight segments and $c$ curved segments, that has the longest length (in number of track segments used) under this restriction. The loop must be closed and cannot intersect itself. If there are multiple loops of maximal length, any one of them will be accepted.\n\nIf the loop is of length $n$, then print a single string of length $n$, where the characters represent the loop's segments as encountered in a single traversal. The character \"`S`\" stands for a straight-line segment, \"`L`\" for a curved segment that is a left turn, and \"`R`\" for a curved segment that is a right turn.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 WF] Toy Train Tracks", "background": "", "description": "Every little child, and quite a number of adults, are fascinated by toy trains. From a toddler's choo-choo train to a hobbyist's elaborate model railroad filling an entire basement, they are a profitable business. The Toy Train Tracks Construction Company (TTTCC) manufactures train tracks for all ages and skill levels. To keep their existing customers busy and maybe attract some new ones, the TTTCC has recently started publishing maps for how to connect their train tracks into elaborate layouts. Usually, this starts with a designer coming up with an interesting track layout, and then publishing both the layout and the required number of different track segments (say, curves and straight parts) needed to construct it. But the TTTCC has recently learned that many customers are looking for the reverse: they already have train track segments lying around (maybe found in grandma's attic), and would like to use them to create a large train course. How difficult might that be?\n\nTo study the feasibility of automating the layout-creation process, TTTCC is interested in constructing train courses using two different shapes: straight line segments, and $90$-degree turns (see Figure U.1).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qc95fugq.png)\n\nFigure U.1: A straight track segment and a curved track segment.\n\nValid layouts are created by placing these shapes on a square grid, with each track piece taking up exactly one grid cell. Both types of pieces can be rotated in $90$-degree increments. A \"proper\" train track needs to be connected, and should form a single closed loop. Given a set of straight and curved track segments, what is the longest closed loop that one can construct?\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/snvx45ju.png)\n\nFigure U.2: A sample track using four straight track segments and twelve curves. This corresponds to Sample Output 1.", "inputFormat": "The input consists of a single line containing two integers $s$ and $c$, the number of straight and curved track segments available, respectively ($0 \\le s \\le 10^5$, $4 \\le c \\le 10^5$).", "outputFormat": "Output a train loop using at most $s$ straight segments and $c$ curved segments, that has the longest length (in number of track segments used) under this restriction. The loop must be closed and cannot intersect itself. If there are multiple loops of maximal length, any one of them will be accepted.\n\nIf the loop is of length $n$, then print a single string of length $n$, where the characters represent the loop's segments as encountered in a single traversal. The character \"`S`\" stands for a straight-line segment, \"`L`\" for a curved segment that is a left turn, and \"`R`\" for a curved segment that is a right turn.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 WF] 玩具火车轨道", "background": "", "description": "每个小孩和很多成年人都对玩具火车着迷。从蹒跚学步的孩子玩的玩具火车到业余爱好者精心制作的能摆满整个地下室的铁路模型，玩具火车都是一项利润丰厚的生意。玩具火车轨道建设公司（*The Toy Train Tracks Construction Company*, TTTCC）生产的火车轨道适合各个年龄段和技能水平。为了让老客户保持消费，并可能能吸引一些新客户，TTTCC 最近开始发布如何将火车轨道连接得更精致的指南。通常情况下，设计者会先想出一个有趣的轨道布局，然后公布布局以及拼成这种布局所需的不同轨道段（例如曲线和直线部分）的数量。但 TTTCC 最近了解到，许多客户正在寻找相反的情况：他们已经有了火车轨道段（也许是在奶奶的阁楼上找到的），并希望用它们来创建一个大型火车线路。这有多难呢？\n\n为了研究布局创建过程自动化的可行性，TTTCC 希望使用两种不同的轨道段构建轨道：直轨道段和 $90$ 度弯轨道段（见图 U.1）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qc95fugq.png)\n\n图 U.1. 一个直轨道段和一个弯轨道段。\n\n将这些轨道段放置在正方形网格上，每个轨道段正好占据一个网格单元，即可形成合法的布局。两种轨道都可以以 $90$ 度为单位旋转。一条「合适」的轨道需要是连通的，并形成一个闭合的环路。给定一组直轨道段和弯轨道段，可以形成的最长闭合环路是什么？\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/snvx45ju.png)\n\n图 U.2. 对于样例 1，使用 4 个直轨道段和 12 个弯轨道段形成的轨道。", "inputFormat": "一行两个整数 $s$ 和 $c$，分别表示可用的直轨道段数和弯轨道段数（$0\\le s\\le 10^5,4\\le c\\le 10^5$）。", "outputFormat": "在最多使用 $s$ 个直轨道段和 $c$ 个弯轨道段的情况下，输出一个长度（以使用的轨道段数表示）最长的轨道环路。该环路必须是封闭的，且不能与自身相交。如果存在多个长度最长的环路，输出任意一个均可。\n\n如果环路的长度为 $n$，则输出一个长度为 $n$ 的字符串，其中的字符代表在一次遍历中遇到的环路上的轨道段。字符 `S` 代表直轨道段，`L` 代表左转的弯轨道段，`R` 代表右转的弯轨道段。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12309", "type": "P", "difficulty": 6, "samples": [["4\n1 A 2 3C no\n2 A 3 3A yes\n2 A 4 3D yes\n2 A 1 3C no\n", "no\n4\n"], ["6\n1 A 2 3C no\n2 A 3 3A yes\n2 A 4 3D yes\n2 A 1 3B no\n1 A 4 5B yes\n1 Q 5\n", "yes\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "ICPC", "WF"], "title": "[ICPC 2022 WF] Quartets", "background": "", "description": "You are watching a group of kids playing a friendly game of [Quartets](https://en.wikipedia.org/wiki/Quartets_(card_game)) and having fun. At one moment, you started being suspicious that some of the kids may be cheating. It seems the kids themselves are not bothered by that at all. Quite the contrary, this brings them even more fun, especially when someone gets caught cheating. As a programmer, you immediately started to think about ways to detect cheating by just observing their game.\n\nQuartets is a 4-player card game that uses a deck of 32 cards divided into 8 sets of 4 cards each. Actual cards often contain educational images, which helps players to learn not only individual objects but also their classification. For example, the cards may display animals while the sets correspond to various groups of animals (mammals, reptiles, etc.).\n\nAt the beginning of a Quartets game, every player is dealt 8 cards and player 1 starts their turn. In each turn, a player asks another player whether they have one particular card. If the asked player has that card, they must give it to the requester, and the requester continues their turn by asking any of the players for another card. If the asked player does not possess the requested card, the requesting player loses the turn and the asked player starts their turn. An important rule states that the requesting player must already have at least one card from the same set as the card they ask for.\n\nIf, during their turn, a player holds a full set (\"quartet\") in their hand, the player may show the quartet to the other players, put it aside and gain one point. The four cards of the quartet are permanently removed from the current game. If at any point a player has no cards left, that player leaves the game. If it was that player's turn, the turn passes to the next player in sequence (player $1-2-3-4-1-\\ldots$) who still has any cards. If no players have any cards, the game ends and the player with the most points is declared the winner.\n\nPlayers are not allowed to ask for cards that have been removed from the game, and they cannot ask for a card from a player who has left the game.\n\nCheating in the game of Quartets is conceivable in two situations where a player falsely claims to have (or not have) some card. Specifically, the cheating occurs if\n\n- a player asks for a card although they have no card of the corresponding set, or\n- a player being asked claims not to have the requested card although they have it.\n\nNeedless to say, cheating is often discovered later. Theoretically, a watchful opponent can eventually find out about any cheating, as all cards are finally revealed at some point before the game ends.\n\nNote that asking for a card that the asked player cannot possibly have (for example, because the requester has it in their own hand) is not exactly a smart move but is not considered cheating by itself.", "inputFormat": "The first line of input contains an integer $n$ ($1 \\le n \\le 1000$), the number of consecutive actions in one game of Quartets, starting from the beginning of a game. The next $n$ lines each contain a description of an action. Each action is described by one line and may be one of the following:\n\n- $x$ `A` $y$ $sk$ `yes` — player $x$ asks player $y$ for the card $sk$, and player $y$ hands that card to player $x$;\n- $x$ `A` $y$ $sk$ `no` — player $x$ asks player $y$ for the card $sk$, player $y$ claims not to have it, and starts their turn;\n- $x$ `Q` $s$ — player $x$ puts aside a quartet $s$.\n\nIn all actions, $x$ and $y$ ($1 \\le x, y \\le 4$, $x \\neq y$) are integers denoting the players, $s$ ($1 \\le s \\le 8$) is a onedigit integer corresponding to one of the sets/quartets, and $k \\in \\{\\texttt{A}, \\texttt{B}, \\texttt{C}, \\texttt{D}\\}$ is a character identifying the four cards within a set. Thus the cards sk are labeled `1A`, `1B`, `1C`, `1D`, `2A`, `2B`, ..., `8C`, `8D`. The four cards that share the same first digit form a single set.\n\nThe given sequence describes a valid game being played among 4 players. That is, except for the two possible ways of cheating mentioned above, all actions satisfy all the rules.", "outputFormat": "If there is a possible initial distribution of the cards such that the sequence of actions corresponds to a (possibly partial) game with all players following the rules, output yes. Otherwise, output no, followed by a line giving the number of the first action after which it is certain that some player must have cheated. Actions are numbered sequentially starting with 1, the actions of putting quartets aside are also counted.", "hint": "### Sample 1 Explanation\n\nPlayers 1 and 2 both claim not having 3C, and neither of them had 3A or 3D. So one of them either lied about not having 3C, or asked for 3C without having 3B (the only remaining card from set 3).", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 WF] Quartets", "background": "", "description": "You are watching a group of kids playing a friendly game of [Quartets](https://en.wikipedia.org/wiki/Quartets_(card_game)) and having fun. At one moment, you started being suspicious that some of the kids may be cheating. It seems the kids themselves are not bothered by that at all. Quite the contrary, this brings them even more fun, especially when someone gets caught cheating. As a programmer, you immediately started to think about ways to detect cheating by just observing their game.\n\nQuartets is a 4-player card game that uses a deck of 32 cards divided into 8 sets of 4 cards each. Actual cards often contain educational images, which helps players to learn not only individual objects but also their classification. For example, the cards may display animals while the sets correspond to various groups of animals (mammals, reptiles, etc.).\n\nAt the beginning of a Quartets game, every player is dealt 8 cards and player 1 starts their turn. In each turn, a player asks another player whether they have one particular card. If the asked player has that card, they must give it to the requester, and the requester continues their turn by asking any of the players for another card. If the asked player does not possess the requested card, the requesting player loses the turn and the asked player starts their turn. An important rule states that the requesting player must already have at least one card from the same set as the card they ask for.\n\nIf, during their turn, a player holds a full set (\"quartet\") in their hand, the player may show the quartet to the other players, put it aside and gain one point. The four cards of the quartet are permanently removed from the current game. If at any point a player has no cards left, that player leaves the game. If it was that player's turn, the turn passes to the next player in sequence (player $1-2-3-4-1-\\ldots$) who still has any cards. If no players have any cards, the game ends and the player with the most points is declared the winner.\n\nPlayers are not allowed to ask for cards that have been removed from the game, and they cannot ask for a card from a player who has left the game.\n\nCheating in the game of Quartets is conceivable in two situations where a player falsely claims to have (or not have) some card. Specifically, the cheating occurs if\n\n- a player asks for a card although they have no card of the corresponding set, or\n- a player being asked claims not to have the requested card although they have it.\n\nNeedless to say, cheating is often discovered later. Theoretically, a watchful opponent can eventually find out about any cheating, as all cards are finally revealed at some point before the game ends.\n\nNote that asking for a card that the asked player cannot possibly have (for example, because the requester has it in their own hand) is not exactly a smart move but is not considered cheating by itself.", "inputFormat": "The first line of input contains an integer $n$ ($1 \\le n \\le 1000$), the number of consecutive actions in one game of Quartets, starting from the beginning of a game. The next $n$ lines each contain a description of an action. Each action is described by one line and may be one of the following:\n\n- $x$ `A` $y$ $sk$ `yes` — player $x$ asks player $y$ for the card $sk$, and player $y$ hands that card to player $x$;\n- $x$ `A` $y$ $sk$ `no` — player $x$ asks player $y$ for the card $sk$, player $y$ claims not to have it, and starts their turn;\n- $x$ `Q` $s$ — player $x$ puts aside a quartet $s$.\n\nIn all actions, $x$ and $y$ ($1 \\le x, y \\le 4$, $x \\neq y$) are integers denoting the players, $s$ ($1 \\le s \\le 8$) is a onedigit integer corresponding to one of the sets/quartets, and $k \\in \\{\\texttt{A}, \\texttt{B}, \\texttt{C}, \\texttt{D}\\}$ is a character identifying the four cards within a set. Thus the cards sk are labeled `1A`, `1B`, `1C`, `1D`, `2A`, `2B`, ..., `8C`, `8D`. The four cards that share the same first digit form a single set.\n\nThe given sequence describes a valid game being played among 4 players. That is, except for the two possible ways of cheating mentioned above, all actions satisfy all the rules.", "outputFormat": "If there is a possible initial distribution of the cards such that the sequence of actions corresponds to a (possibly partial) game with all players following the rules, output yes. Otherwise, output no, followed by a line giving the number of the first action after which it is certain that some player must have cheated. Actions are numbered sequentially starting with 1, the actions of putting quartets aside are also counted.", "hint": "### Sample 1 Explanation\n\nPlayers 1 and 2 both claim not having 3C, and neither of them had 3A or 3D. So one of them either lied about not having 3C, or asked for 3C without having 3B (the only remaining card from set 3).", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 WF] Quartets", "background": "", "description": "> 译者注：由于国内并没有和题意相符的扑克牌游戏，因此保留原词。\n\n你正在看一群小孩儿玩 [Quartets](https://en.wikipedia.org/wiki/Quartets_(card_game))，他们玩得不亦乐乎。突然你开始怀疑有些孩子可能在作弊。但孩子们自己似乎一点也不在意。恰恰相反，这给他们带来了更多乐趣，尤其是当有人作弊被抓时。作为程序员，你立即开始思考如何通过观察他们的游戏来发现作弊行为。\n\nQuartets 是一种四人纸牌游戏，使用一副 $32$ 张牌，分成 $8$ 组，每组 $4$ 张牌。实际的纸牌通常印有教育意义的图片，这不仅有助于玩家学到东西，还能学到这些东西的类别。例如，纸牌上会印有动物，而牌组则对应不同的动物类别（哺乳动物、爬行动物等）。\n\nQuartets 开始时，每个玩家都会得到 $8$ 张牌，然后玩家 $1$ 开始。在每一轮中，一名玩家会询问另一名玩家是否有某张牌。如果被问的玩家有这张牌，他们必须把牌交给问牌者，问牌者可以继续问牌，也就是可以再向其他玩家要另一张牌。如果被问到的玩家没有所问的牌，则问牌者的轮次结束，被问到的玩家开始他的轮次。有一条重要的规则，问牌者必须已经有至少一张与他问的牌所在组相同的牌。\n\n如果玩家在其回合内拿到了一整组牌（quartet），则可以向其他玩家展示这组牌，将其放在一边并获得一分。quartet 中的四张牌将从当前游戏中永久移除。如果某玩家在某个时候没有牌了，该玩家就会离开游戏。如果轮到该玩家，则轮到仍有牌的下一位玩家（玩家 $1-2-3-4-1-\\ldots$）。如果没有玩家有牌，游戏结束，积分最高的玩家获胜。\n\n玩家不能要已从游戏中删除的牌，也不得向已离开游戏的玩家要牌。\n\n在 Quartets 中，有两种情况是可以作弊的，即玩家谎称自己有（或没有）某张牌。具体来说，作弊发生在以下情况：\n\n- 玩家要求获得一张牌，尽管他没有相应的类别的牌，或\n- 被问到的玩家声称自己没有被问的牌，尽管他有。\n\n显而易见，作弊行为往往是后来才被发现的。从理论上讲，细心的对手最终会发现任何作弊行为，因为在游戏结束前的某个时刻，所有的牌都会被展示。\n\n需要注意的是，要一张被问者不可能拥有的牌（例如，因为问牌者自己手中就有）并不是一个聪明的举动，但它本身并不被视为作弊。", "inputFormat": "第一行包含一个整数 $n$（$1\\le n\\le 1000$），表示在一次 Quartets 游戏中从游戏开始的连续操作数。接下来 $n$ 行，每行描述一次操作。每次操作用一行如下格式的数据描述：\n\n- $x$ `A` $y$ $sk$ `yes`：玩家 $x$ 向玩家 $y$ 要牌 $sk$，然后玩家 $y$ 把牌给了 $x$；\n- $x$ `A` $y$ $sk$ `no`：玩家 $x$ 向玩家 $y$ 要牌 $sk$，然后玩家 $y$ 声称自己没有牌 $sk$，并开始他的轮次；\n- $x$ `Q` $s$：玩家 $x$ 将一组牌 $s$ 放在一边。\n\n在所有操作中，$x$ 和 $y$（$1\\le x,y\\le 4,x\\neq y$）是表示玩家的整数，$s$（$1\\le s\\le 8$）是一位整数，表示一组牌（quartet），$k\\in\\{\\texttt{A}, \\texttt{B},\\texttt{C},\\texttt{D}\\}$ 用来区分在同一组内的四张牌。因此牌 $sk$ 可以用 `1A`，`1B`，`1C`，`1D`，`2A`，`2B`，……，`8C`，`8D` 来表示。第一位相同的四张牌来自同一组。\n\n给出的操作描述了一个由 $4$ 个玩家进行的合法游戏。也就是说，除了上述两种可能的作弊方式外，所有操作都符合所有规则。", "outputFormat": "如果存在一种可能的初始牌分配方式，使得给出的操作序列对应所有玩家都遵守规则的游戏过程（可能是部分游戏过程），则输出 `yes`。否则，输出 `no`，并在接下来一行给出第一个操作的编号，满足在操作完后可以肯定有玩家作弊。操作从 $1$ 开始依次编号，将一组牌放在一边的操作也算在内。", "hint": "### 样例 1 解释\n\n玩家 1 和 2 都声称没有 `3C`，而他们都没有 `3A` 或 `3D`。因此，其中一人要么谎称没有 `3C`，要么在没有 `3B`（第 3 组中唯一剩下的牌）的情况下要了 `3C`。", "locale": "zh-CN"}}}
{"pid": "P12310", "type": "P", "difficulty": 2, "samples": [["1111\n", "1\n"], ["101\n", "101\n"], ["10110\n", "10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["字符串", "2022", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2022 WF] Compression", "background": "", "description": "Infinite Compression Plan Consortium (ICPC) has developed a new, great data compression strategy, called \"Don't Repeat Yourself\" (DRY). DRY works on a string of characters, and if the string contains two consecutive instances of the same substring, it simply removes one of them. For example, in the string \"`alfalfa seeds`\", it could remove one of the two \"`e`\" substrings in \"`seeds`\", and one of the two \"`lfa`\" substrings in \"`alfalfa`\", resulting in \"`alfa seds`\". DRY can also take advantage of previous removals — for instance, in the string \"`seventeenth baggage`\", it will first remove the duplicate \"`e`\" in \"`seventeenth`\" and the duplicate \"`g`\" in \"`baggage`\", resulting in \"`sevententh bagage`\", and then remove the duplicate \"`ent`\" in \"`sevententh`\" and \"`ag`\" in \"`bagage`\", resulting in \"`seventh bage`\".\n\nIf there are multiple choices of repeating consecutive substrings to remove, DRY should choose in a way that results in the shortest possible final string. For example, in the string \"`ABBCDCABCDCD`\", DRY has two choices — either removing the repeated \"`B`\" near the beginning, or the repeated \"`CD`\" at the end. If the \"`B`\" is removed, then DRY will be able to remove the repeated \"`ABCDC`\", resulting in \"`ABCDCD`\", from which the \"`CD`\" at the end will finally be removed, resulting in \"`ABCD`\". However, if DRY removed the \"`CD`\" at the end first, it would be left with \"`ABBCDCABCD`\", from which only the repeated \"`B`\" can be removed to obtain \"`ABCDCABCD`\" — and from that string nothing more can be removed. So, the correct choice for DRY is to begin by compressing the double \"`B`\", and to finally end up with \"`ABCD`\".\n\nICPC observed that DRY obtains the best results on binary strings — that is, strings composed only of zeroes and ones. So, it has tasked you with implementing the best possible DRY algorithm working on binary strings. For any binary string, you should output a shortest string that can be obtained by repeatedly applying DRY to it.", "inputFormat": "The input consists of a single line containing a nonempty string of length less than or equal to $10^5$, consisting only of zeroes and ones.", "outputFormat": "Output one line, containing a shortest possible result of running DRY on the input string. If there is more than one possible shortest result, any one will be accepted.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 WF] Compression", "background": "", "description": "Infinite Compression Plan Consortium (ICPC) has developed a new, great data compression strategy, called \"Don't Repeat Yourself\" (DRY). DRY works on a string of characters, and if the string contains two consecutive instances of the same substring, it simply removes one of them. For example, in the string \"`alfalfa seeds`\", it could remove one of the two \"`e`\" substrings in \"`seeds`\", and one of the two \"`lfa`\" substrings in \"`alfalfa`\", resulting in \"`alfa seds`\". DRY can also take advantage of previous removals — for instance, in the string \"`seventeenth baggage`\", it will first remove the duplicate \"`e`\" in \"`seventeenth`\" and the duplicate \"`g`\" in \"`baggage`\", resulting in \"`sevententh bagage`\", and then remove the duplicate \"`ent`\" in \"`sevententh`\" and \"`ag`\" in \"`bagage`\", resulting in \"`seventh bage`\".\n\nIf there are multiple choices of repeating consecutive substrings to remove, DRY should choose in a way that results in the shortest possible final string. For example, in the string \"`ABBCDCABCDCD`\", DRY has two choices — either removing the repeated \"`B`\" near the beginning, or the repeated \"`CD`\" at the end. If the \"`B`\" is removed, then DRY will be able to remove the repeated \"`ABCDC`\", resulting in \"`ABCDCD`\", from which the \"`CD`\" at the end will finally be removed, resulting in \"`ABCD`\". However, if DRY removed the \"`CD`\" at the end first, it would be left with \"`ABBCDCABCD`\", from which only the repeated \"`B`\" can be removed to obtain \"`ABCDCABCD`\" — and from that string nothing more can be removed. So, the correct choice for DRY is to begin by compressing the double \"`B`\", and to finally end up with \"`ABCD`\".\n\nICPC observed that DRY obtains the best results on binary strings — that is, strings composed only of zeroes and ones. So, it has tasked you with implementing the best possible DRY algorithm working on binary strings. For any binary string, you should output a shortest string that can be obtained by repeatedly applying DRY to it.", "inputFormat": "The input consists of a single line containing a nonempty string of length less than or equal to $10^5$, consisting only of zeroes and ones.", "outputFormat": "Output one line, containing a shortest possible result of running DRY on the input string. If there is more than one possible shortest result, any one will be accepted.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 WF] 压缩", "background": "", "description": "无限压缩计划联盟（*Infinite Compression Plan Consortium*, ICPC）开发出了一种全新的，伟大的数据压缩策略，称作「不要重复自己」（*Don't Repeat Yourself*, DRY）。DRY 适用于字符串，如果字符串中包含连续两个相同的子串，它就会删除其中一个。例如，在字符串 `alfalfa seeds` 中，它可以移除子串 `seeds` 中两个 `e` 中的一个，和子串 `alfalfa` 中两个 `lfa` 中的一个，结果为 `alfa seds`。DRY 也可以利用之前的删除操作——例如，在字符串 `seventeenth baggage` 中，首先会移除 `seventeenth` 中重复的 `e` 和 `baggage` 中重复的 `g`，得到 `sevententh bagage`，然后删除 `sevententh` 中重复的 `ent` 和 `bagage` 中重复的 `ag`，得到 `seventh bage`。\n\n如果有多种删除连续重复子串的方法，DRY 会选择可以得到最短的最终子串的删除方法。例如，对于字符串 `ABBCDCABCDCD`，DRY 有两种选择——要么删除靠近开头的两个重复的 `B` 中的一个，或者删除结尾处重复的 `CD`。如果删除了 `B`，则 DRY 就可以删除重复的 `ABCDC`，获得 `ABCDCD`，然后就可以删除结尾的 `CD`，最终得到 `ABCD`。然而，如果 DRY 首先移除了结尾的 `CD`，首先会得到 `ABBCDCABCD`，这样只能删除连续的 `B`，得到 `ABCDCABCD`——这个字符串不能移除更多字符了。因此，对于 DRY 来说正确的选择是先压缩两个 `B`，然后得到 `ABCD`。\n\nICPC 观察到 DRY 在二进制串上能得到最佳结果——也就是只包含 0 和 1 的字符串。因此，因此，你的任务就是在二进制字符串上实现最佳的 DRY 算法。对于任意二进制串，你都应该输出一个通过反复使用 DRY 算法可以得到的最短字符串。", "inputFormat": "一行一个非空字符串，长度小于等于 $10^5$，且仅包含 0 和 1。", "outputFormat": "输出一行，表示对输入字符串进行 DRY 算法后获得的最短可能字符串。如果有多于一种可能的结果，输出任意一种均可。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12311", "type": "P", "difficulty": 7, "samples": [["2 3 4\nEEE 1\nEIA 1\nIAE 1\nAAA 1\n", "+-0\n+++\n"], ["3 2 2\nIA 4\nAA 4\n", "-0\n00\n00\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2022 WF] Archaeological Recovery", "background": "", "description": "Renowned professor of Egyptology Z Mummer is exploring a newly discovered tomb in Luxor where she finds a mysterious construction. On a wall, there is a row of $k$ pyramid-shaped stone slabs. Each stone features three hieroglyphs: an ankh (top), an eye of Horus (bottom left), and an ibis (bottom right).\n\nNext to the wall there are $n$ levers. Cautiously experimenting with these, wary of potential traps, the professor realizes that each lever rotates some of the pyramids clockwise or counter-clockwise so that another hieroglyph is pointing upwards on them. Flipping back a lever rotates the same pyramids in the opposite direction back to their original position. The levers operate completely independently of each other, so flipping or unflipping a lever has the same effect regardless of what states the other levers are in. See Figure Z.1 for an illustration.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jebg902f.png)\n\nFigure Z.1: Illustration of a wall with k = 3 pyramids and n = 2 levers. The first lever rotates the first pyramid clockwise, the second pyramid counterclockwise, and leaves the third pyramid unchanged. The second lever rotates all three pyramids clockwise. This corresponds to Sample Input 1.\n\nIntrigued, Professor Mummer records the individual effect of each lever. Back at her university after the expedition, she assigns one of her students the laborious task of figuring out all $2^n$ possible pyramid configurations (some of which may be identical) that can be achieved by flipping some subset of the levers, so that these can be studied further.\n\nAfter many nights of careful calculations, the student is finally done and starts gathering his papers. But then disaster strikes: he accidentally spills some ink and completely destroys the professor's original notes, which contained the only record of the individual effects of each lever.\n\nThe only chance to escape Professor Mummer's wrath is to reconstruct the original notes from the list of possible pyramid configurations. This cannot be done completely unambiguously (for example, there is no way of distinguishing between different orderings of the same set of levers). But as long as the levers still result in the calculated list of pyramid configurations, this error is unlikely to be noticed (at least not until after the student has graduated).", "inputFormat": "The first line of input contains three integers $n$, $k$ and $t$, where $n$ ($1 \\le n \\le 40$) and $k$ ($1 \\le k \\le 5$) are the number of levers and pyramids, respectively, and $t$ ($1 \\le t \\le 3^k$) is the number of different pyramid configurations. Then follow $t$ lines describing the distinct possible pyramid configurations. Each such line consists of a string of length $k$ describing the configuration and an integer $f$ ($1 \\le f \\le 2^n$) indicating the number of different lever settings which result in this configuration. The configuration is described using the letters '`A`', '`E`', and '`I`'. The jth character indicates the hieroglyph facing upwards on the jth pyramid: '`A`' for ankh, '`E`' for eye of Horus, and '`I`' for ibis.\n\nThe $t$ configurations given are pairwise distinct, the sum of $f$-values over all $t$ lines equals $2^n$, and the input is such that at least one list of levers results in the given multiset of configurations.", "outputFormat": "Output $n$ lines describing a possible set of levers that gives rise to the given multiset of pyramid configurations. Each line describes one lever using a string of length $k$ consisting of the symbols '`+`', '`-`', or '`0`'. In each such string, the $j^\\text{th}$ symbol describes the action of this lever on the $j^\\text{th}$ pyramid: '`+`' if the lever moves the pyramid clockwise, '`-`' if the lever moves it counterclockwise, and '`0`' if the lever does not move this pyramid.\n\nIf there is more than one possible solution, any one will be accepted.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 WF] Archaeological Recovery", "background": "", "description": "Renowned professor of Egyptology Z Mummer is exploring a newly discovered tomb in Luxor where she finds a mysterious construction. On a wall, there is a row of $k$ pyramid-shaped stone slabs. Each stone features three hieroglyphs: an ankh (top), an eye of Horus (bottom left), and an ibis (bottom right).\n\nNext to the wall there are $n$ levers. Cautiously experimenting with these, wary of potential traps, the professor realizes that each lever rotates some of the pyramids clockwise or counter-clockwise so that another hieroglyph is pointing upwards on them. Flipping back a lever rotates the same pyramids in the opposite direction back to their original position. The levers operate completely independently of each other, so flipping or unflipping a lever has the same effect regardless of what states the other levers are in. See Figure Z.1 for an illustration.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jebg902f.png)\n\nFigure Z.1: Illustration of a wall with k = 3 pyramids and n = 2 levers. The first lever rotates the first pyramid clockwise, the second pyramid counterclockwise, and leaves the third pyramid unchanged. The second lever rotates all three pyramids clockwise. This corresponds to Sample Input 1.\n\nIntrigued, Professor Mummer records the individual effect of each lever. Back at her university after the expedition, she assigns one of her students the laborious task of figuring out all $2^n$ possible pyramid configurations (some of which may be identical) that can be achieved by flipping some subset of the levers, so that these can be studied further.\n\nAfter many nights of careful calculations, the student is finally done and starts gathering his papers. But then disaster strikes: he accidentally spills some ink and completely destroys the professor's original notes, which contained the only record of the individual effects of each lever.\n\nThe only chance to escape Professor Mummer's wrath is to reconstruct the original notes from the list of possible pyramid configurations. This cannot be done completely unambiguously (for example, there is no way of distinguishing between different orderings of the same set of levers). But as long as the levers still result in the calculated list of pyramid configurations, this error is unlikely to be noticed (at least not until after the student has graduated).", "inputFormat": "The first line of input contains three integers $n$, $k$ and $t$, where $n$ ($1 \\le n \\le 40$) and $k$ ($1 \\le k \\le 5$) are the number of levers and pyramids, respectively, and $t$ ($1 \\le t \\le 3^k$) is the number of different pyramid configurations. Then follow $t$ lines describing the distinct possible pyramid configurations. Each such line consists of a string of length $k$ describing the configuration and an integer $f$ ($1 \\le f \\le 2^n$) indicating the number of different lever settings which result in this configuration. The configuration is described using the letters '`A`', '`E`', and '`I`'. The jth character indicates the hieroglyph facing upwards on the jth pyramid: '`A`' for ankh, '`E`' for eye of Horus, and '`I`' for ibis.\n\nThe $t$ configurations given are pairwise distinct, the sum of $f$-values over all $t$ lines equals $2^n$, and the input is such that at least one list of levers results in the given multiset of configurations.", "outputFormat": "Output $n$ lines describing a possible set of levers that gives rise to the given multiset of pyramid configurations. Each line describes one lever using a string of length $k$ consisting of the symbols '`+`', '`-`', or '`0`'. In each such string, the $j^\\text{th}$ symbol describes the action of this lever on the $j^\\text{th}$ pyramid: '`+`' if the lever moves the pyramid clockwise, '`-`' if the lever moves it counterclockwise, and '`0`' if the lever does not move this pyramid.\n\nIf there is more than one possible solution, any one will be accepted.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 WF] Archaeological Recovery", "background": "", "description": "著名的埃及学教授 Z Mummer 正在卢克索新发现的墓室中探索，在其中她发现了一个神秘的构造。在墙上，有一排 $k$ 个金字塔形的石板。每块石板上都有三个象形文字：生命之符（上部），荷鲁斯之眼（左下部）以及朱鹮（右下部）。\n\n在墙边有 $n$ 个操纵杆。教授小心地试验这些操纵杆，警惕潜在的陷阱，她发现每个操纵杆都可以使某些石板顺时针或逆时针旋转，使另一个象形文字位于上部。回拨操纵杆可以使相同的石板以相反的方向旋转回到原位。这些操纵杆是完全独立的，因此无论其他操纵杆的状态如何，拨动或回拨某个操纵杆都会产生相同的效果。见图 Z.1 示意图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qylupp3m.png)\n\n图 Z.1 展示了一堵有 3 个金字塔石板和 2 个操纵杆的墙。第一个操纵杆使第一个金字塔顺时针旋转，第二个金字塔逆时针旋转，第三个金字塔保持不变。第二个操纵杆使三个金字塔都顺时针旋转。这对应样例 1。\n\n出于好奇，Mummer 教授记录了每个操纵杆各自的效果。回到大学后，她让一名学生干了一件体力活：对于所有 $2^n$ 种可能的操作杆状态，找出所有石板可能的排布情况（其中一些可能相同），以便进一步研究。\n\n经过很多天的精心计算，学生终于完成了任务，开始整理资料。但灾难随即发生：他不小心打翻了墨水，完全毁坏了教授最初的笔记，这些笔记是记录每个操纵杆各自效果的唯一记录。\n\n避免 Mummer 教授生气的唯一机会就是从可能的石板排布列表重建原始笔记。这无法完全无歧义地进行（例如，无法区分同一组操纵杆的不同操作顺序）。但只要根据复原的笔记仍然能计算出石板的排布情况，这种错误就不太可能被发现（至少在这个学生毕业之前不会被发现）。", "inputFormat": "第一行包含三个整数 $n,k,t$。其中 $n$（$1\\le n\\le 40$）和 $k$（$1\\le k\\le 5$）分别为操纵杆数和金字塔形石板数，$t$（$1\\le t\\le 3^k$）表示不同的石板排布状态数。接下来 $t$ 行描述这些互不相同的石板排布状态。首先一个长为 $k$ 的字符串，描述这个状态，然后一个整数 $f$（$1\\le f\\le 2^n$）表示有多少种操纵杆状态可以使石板达到这个状态。石板状态用 `A`，`E` 和 `I` 三种字母表示。第 $j$ 个字母表示第 $j$ 个石板上朝上的象形文字：`A` 表示生命之符，`E` 表示荷鲁斯之眼，`I` 表示朱鹮。\n\n这 $t$ 个状态两两不同，所有状态的 $f$ 值相加等于 $2^n$，输入中至少存在一组操纵杆能产生给定的多组状态。", "outputFormat": "输出 $n$ 行描述一组可能得到给定石板排布数的操纵杆配置。每行用 $k$ 个字符 `+`，`-` 或 `0` 描述一个操纵杆。每个字符串中的第 $j$ 个字符描述这个操纵杆对第 $j$ 个石板的影响：如果让石板顺时针旋转，则为 `+`，如果让石板逆时针旋转，则为 `-`，如果让石板保持不动，则为 `0`。\n\n如果有多种可能的答案，输出任意一种均可。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12312", "type": "P", "difficulty": 3, "samples": [], "limits": {"time": [3000], "memory": [524288]}, "tags": ["数学", "2024", "数论", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国 C] 六一儿童节", "background": "", "description": "在蓝桥小镇，每年的六一儿童节是许多孩子最期待的日子。在这一天，神秘的数字精灵会出现，为孩子们带来惊喜和祝福。\n\n今年的六一儿童节格外特别，因为数字精灵带来了一项有趣的挑战给小镇上的孩子们。\n\n挑战的内容是：从数字 $1$ 至 $20240601$ 中找出两个不同的整数 $x$ 和 $y$，使得 $x, y$ 满足 $x$ 小于 $y$，且 $x^x + y^y$ 能够被 $6421$ 整除。成功找到这样一对数字的孩子们将会得到数字精灵准备的豪华大礼包。\n\n对此，请你帮助孩子们计算出所有符合条件的整数对 $(x, y)$ 的数量，帮助小镇上的孩子们解决数字精灵的挑战，让他们能够在六一儿童节收获满满的快乐和难忘的回忆！", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只需要**编写一个程序输出这个整数**，输出多余的内容将无法得分。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国 C] 六一儿童节", "background": "", "description": "在蓝桥小镇，每年的六一儿童节是许多孩子最期待的日子。在这一天，神秘的数字精灵会出现，为孩子们带来惊喜和祝福。\n\n今年的六一儿童节格外特别，因为数字精灵带来了一项有趣的挑战给小镇上的孩子们。\n\n挑战的内容是：从数字 $1$ 至 $20240601$ 中找出两个不同的整数 $x$ 和 $y$，使得 $x, y$ 满足 $x$ 小于 $y$，且 $x^x + y^y$ 能够被 $6421$ 整除。成功找到这样一对数字的孩子们将会得到数字精灵准备的豪华大礼包。\n\n对此，请你帮助孩子们计算出所有符合条件的整数对 $(x, y)$ 的数量，帮助小镇上的孩子们解决数字精灵的挑战，让他们能够在六一儿童节收获满满的快乐和难忘的回忆！", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只需要**编写一个程序输出这个整数**，输出多余的内容将无法得分。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12313", "type": "P", "difficulty": 2, "samples": [["4\n10000.00\n-10000.01\n300.01\n500.02", "10000.00\n0.49\n300.50\n800.53"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2024", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国 C] 存钱", "background": "", "description": "小蓝将钱存在了银行，每天银行会按照小蓝存款的 $0.005\\%$ 给予小蓝一定的利息，上一天结束时的存款余额会在下一天开始时参与利息的计算，余额的最小单位为 $0.01$ 元（$1$ 分），每天的利息小于 $0.01$ 元的部分忽略不计。\n\n给定小蓝在 $M$ 天内的存取记录，求小蓝每天结束时的存款数量。\n\n一开始小蓝的余额为 $0$，保证任何时候取出的钱不会超出余额。", "inputFormat": "输入的第一行包含一个整数 $M$ 表示天数。\n\n接下来 $M$ 行，每行包含一个实数 $A_i$，小数位数不超过 $2$ 位，表示小蓝在第 $i$ 天的净存取量（正数表示存款，负数表示取款，$0$ 表示不存不取，单位为元）。", "outputFormat": "输出 $M$ 行，每行包含一个实数 $B_i$，保留正好两位小数，表示第 $i$ 天结束时小蓝存款的余额（单位为元）。", "hint": "### 评测用例规模与约定\n\n- 对于 $40\\%$ 的评测用例，$1 \\leq M \\leq 50$，$0 \\leq |A_i| \\leq 50$；\n- 对于所有评测用例，$1 \\leq M \\leq 2 \\times 10^5$，$0 \\leq |A_i| \\leq 10^4$，$A_i$ 的小数点后最多只有两位数字。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国 C] 存钱", "background": "", "description": "小蓝将钱存在了银行，每天银行会按照小蓝存款的 $0.005\\%$ 给予小蓝一定的利息，上一天结束时的存款余额会在下一天开始时参与利息的计算，余额的最小单位为 $0.01$ 元（$1$ 分），每天的利息小于 $0.01$ 元的部分忽略不计。\n\n给定小蓝在 $M$ 天内的存取记录，求小蓝每天结束时的存款数量。\n\n一开始小蓝的余额为 $0$，保证任何时候取出的钱不会超出余额。", "inputFormat": "输入的第一行包含一个整数 $M$ 表示天数。\n\n接下来 $M$ 行，每行包含一个实数 $A_i$，小数位数不超过 $2$ 位，表示小蓝在第 $i$ 天的净存取量（正数表示存款，负数表示取款，$0$ 表示不存不取，单位为元）。", "outputFormat": "输出 $M$ 行，每行包含一个实数 $B_i$，保留正好两位小数，表示第 $i$ 天结束时小蓝存款的余额（单位为元）。", "hint": "### 评测用例规模与约定\n\n- 对于 $40\\%$ 的评测用例，$1 \\leq M \\leq 50$，$0 \\leq |A_i| \\leq 50$；\n- 对于所有评测用例，$1 \\leq M \\leq 2 \\times 10^5$，$0 \\leq |A_i| \\leq 10^4$，$A_i$ 的小数点后最多只有两位数字。", "locale": "zh-CN"}}}
{"pid": "P12314", "type": "P", "difficulty": 3, "samples": [["3\n{\"a\",\"b\",\"b\",\"b\"}\n{\"a\",\"a\",\"b\",\"b\"}\n{\"a\",\"a\",\"a\",\"b\"}", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "字符串", "2024", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国 C] 集合的数量", "background": "截止 2025 年 4 月 23 日，蓝桥杯官网本题测试数据不符合测试点范围要求（或者说，本题数据点范围限制不明确），存在类似如下的数据：\n\n```\n9\n{}\n{}\n{\"\"}\n{\"ejoa\"}\n{\"aehr\",\"ncuy\"}\n{\"lidm\",\"dgxy\"}\n{\"fzxh\"}\n{\"vtfh\",\"vtfh\",\"ksoc\",\"vtfh\"}\n{\"ksoc\",\"vtfh\",\"ksoc\",\"vtfh\"}\n```\n\n洛谷的数据剔除了此类情况。如果需要在蓝桥杯题库提交本题请注意这个问题。", "description": "小蓝有 $n$ 个集合，这些集合中的元素还未去重。每个集合 $S_i$ 最多含有 $5$ 个长度不大于 $4$ 的仅含小写字母的字符串 $S_{i,j}$。\n\n你需要计算小蓝的这些集合去重后有多少个（集合内的元素和集合之间都要去重）。\n\n每个集合用 `{\"abc\"}`，`{\"a\",\"b\",\"c\",\"d\"}` 的形式输入 (无空格)。\n", "inputFormat": "输入的第一行包含一个整数 $n$。\n\n接下来 $n$ 行，每行包含一个字符串，描述一个集合 $S_i$。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "### 样例说明\n\n三个集合本质上都是 `{\"a\",\"b\"}`。\n\n### 评测用例规模与约定\n- 对于 $40\\%$ 的评测用例，$n \\leq 10$；\n- 对于所有评测用例，$1 \\leq n \\leq 1000$，$|S_i| \\leq 5$，$|S_{i,j}| \\leq 4$ 。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国 C] 集合的数量", "background": "截止 2025 年 4 月 23 日，蓝桥杯官网本题测试数据不符合测试点范围要求（或者说，本题数据点范围限制不明确），存在类似如下的数据：\n\n```\n9\n{}\n{}\n{\"\"}\n{\"ejoa\"}\n{\"aehr\",\"ncuy\"}\n{\"lidm\",\"dgxy\"}\n{\"fzxh\"}\n{\"vtfh\",\"vtfh\",\"ksoc\",\"vtfh\"}\n{\"ksoc\",\"vtfh\",\"ksoc\",\"vtfh\"}\n```\n\n洛谷的数据剔除了此类情况。如果需要在蓝桥杯题库提交本题请注意这个问题。", "description": "小蓝有 $n$ 个集合，这些集合中的元素还未去重。每个集合 $S_i$ 最多含有 $5$ 个长度不大于 $4$ 的仅含小写字母的字符串 $S_{i,j}$。\n\n你需要计算小蓝的这些集合去重后有多少个（集合内的元素和集合之间都要去重）。\n\n每个集合用 `{\"abc\"}`，`{\"a\",\"b\",\"c\",\"d\"}` 的形式输入 (无空格)。\n", "inputFormat": "输入的第一行包含一个整数 $n$。\n\n接下来 $n$ 行，每行包含一个字符串，描述一个集合 $S_i$。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "### 样例说明\n\n三个集合本质上都是 `{\"a\",\"b\"}`。\n\n### 评测用例规模与约定\n- 对于 $40\\%$ 的评测用例，$n \\leq 10$；\n- 对于所有评测用例，$1 \\leq n \\leq 1000$，$|S_i| \\leq 5$，$|S_{i,j}| \\leq 4$ 。\n", "locale": "zh-CN"}}}
{"pid": "P12315", "type": "P", "difficulty": 3, "samples": [["5 5 1\n8 4 6 7 6", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "双指针 two-pointer", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国 C] 挑苹果", "background": "", "description": "老师在班级里准备给同学们发苹果，一共有 $n$ 种苹果，第 $i$ 种苹果的美味值为 $a_i$，每名同学需要选择一个非负整数 $x$，这名同学可以获得所有满足条件 $[(a_i + x) \\bmod k] \\leq t$ 的苹果每种一个。小蓝使用魔法偷偷得知了 $k$ 和 $t$ 的值，小蓝想知道自己最多能获得多少个苹果。\n", "inputFormat": "输入的第一行包含三个正整数 $n, k, t$，相邻整数之间使用一个空格分隔。\n\n第二行包含 $n$ 个正整数 $a_1, a_2, \\cdots, a_n$，相邻整数之间使用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "### 样例说明\n\n取 $x = 4$ 时，第 $3, 4, 5$ 种苹果都能获得。\n\n### 评测用例规模与约定\n\n- 对于 $20\\%$ 的评测用例，$1 \\leq n, t, k \\leq 1000$；\n- 对于所有评测用例，$1 \\leq n \\leq 10^5$，$1 \\leq a_i \\leq 10^8$，$1 \\leq t, k \\leq 10^8$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国 C] 挑苹果", "background": "", "description": "老师在班级里准备给同学们发苹果，一共有 $n$ 种苹果，第 $i$ 种苹果的美味值为 $a_i$，每名同学需要选择一个非负整数 $x$，这名同学可以获得所有满足条件 $[(a_i + x) \\bmod k] \\leq t$ 的苹果每种一个。小蓝使用魔法偷偷得知了 $k$ 和 $t$ 的值，小蓝想知道自己最多能获得多少个苹果。\n", "inputFormat": "输入的第一行包含三个正整数 $n, k, t$，相邻整数之间使用一个空格分隔。\n\n第二行包含 $n$ 个正整数 $a_1, a_2, \\cdots, a_n$，相邻整数之间使用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "### 样例说明\n\n取 $x = 4$ 时，第 $3, 4, 5$ 种苹果都能获得。\n\n### 评测用例规模与约定\n\n- 对于 $20\\%$ 的评测用例，$1 \\leq n, t, k \\leq 1000$；\n- 对于所有评测用例，$1 \\leq n \\leq 10^5$，$1 \\leq a_i \\leq 10^8$，$1 \\leq t, k \\leq 10^8$。", "locale": "zh-CN"}}}
{"pid": "P12316", "type": "P", "difficulty": 4, "samples": [["3 9\n2365587456\n2399141888\n9437184", "7535067152"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2024", "背包 DP", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国 C] 循环位运算", "background": "蓝桥杯原题为 **做完 $m$ 次操作**，根据下载得到的测试数据分析应当为 **做了不超过 $m$ 次操作**。洛谷的题面根据实际测试数据进行编写。", "description": "给定 $n$ 个数 $A_i$，每个数我们都将其视为一个 $32$ 位的二进制数。你可以进行 $m$ 次操作，每次选择任意一个数将其循环左移一次。\n\n循环左移表示将某个数的二进制位均左移一位，同时最高位移动到最低位。例如对于一个 $8$ 位二进制数 $10010010$，循环左移一次后为 $00100101$，两次后为 $01001010$。\n\n问做了**不超过** $m$ 次操作后，$n$ 个数的和最大是多少。", "inputFormat": "输入的第一行包含两个整数 $n, m$，用一个空格分隔。\n\n接下来 $n$ 行，每行包含一个整数 $A_i$。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "### 评测用例规模与约定\n\n- 对于 $30\\%$ 的评测用例，$n, m \\leq 12$；\n- 对于 $60\\%$ 的评测用例，$n, m \\leq 100$；\n- 对于所有评测用例，$1 \\leq n, m \\leq 1000$，$0 \\leq A_i < 2^{32}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国 C] 循环位运算", "background": "蓝桥杯原题为 **做完 $m$ 次操作**，根据下载得到的测试数据分析应当为 **做了不超过 $m$ 次操作**。洛谷的题面根据实际测试数据进行编写。", "description": "给定 $n$ 个数 $A_i$，每个数我们都将其视为一个 $32$ 位的二进制数。你可以进行 $m$ 次操作，每次选择任意一个数将其循环左移一次。\n\n循环左移表示将某个数的二进制位均左移一位，同时最高位移动到最低位。例如对于一个 $8$ 位二进制数 $10010010$，循环左移一次后为 $00100101$，两次后为 $01001010$。\n\n问做了**不超过** $m$ 次操作后，$n$ 个数的和最大是多少。", "inputFormat": "输入的第一行包含两个整数 $n, m$，用一个空格分隔。\n\n接下来 $n$ 行，每行包含一个整数 $A_i$。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "### 评测用例规模与约定\n\n- 对于 $30\\%$ 的评测用例，$n, m \\leq 12$；\n- 对于 $60\\%$ 的评测用例，$n, m \\leq 100$；\n- 对于所有评测用例，$1 \\leq n, m \\leq 1000$，$0 \\leq A_i < 2^{32}$。", "locale": "zh-CN"}}}
{"pid": "P12317", "type": "P", "difficulty": 3, "samples": [["5\n1\n2\n1\n2", "3\n1\n1\n1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "深度优先搜索 DFS", "树的遍历", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国 C] 树的结点值", "background": "", "description": "给定一棵包含 $n$ 个结点的树，其树根编号为 $1$。我们规定其第 $i$ 个结点的值为其对应的子树内所有与 $i$ 奇偶性相同的结点数量。请按编号从小到大的顺序输出其每个结点的值。", "inputFormat": "输入的第一行包含一个整数 $n$。\n\n接下来 $n-1$ 行描述每个结点的父结点，其中第 $i$ 行包含一个整数 $F_{i+1}$，表示第 $i+1$ 个结点的父结点。", "outputFormat": "输出 $n$ 行，每行包含一个整数表示编号为 $i$ 的结点的值。", "hint": "### 评测用例规模与约定\n\n- 对于 $40\\%$ 的评测用例，$1 \\leq n \\leq 5000$；\n- 对于所有评测用例，$1 \\leq n \\leq 2 \\times 10^5$，$1 \\leq F_i < i$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国 C] 树的结点值", "background": "", "description": "给定一棵包含 $n$ 个结点的树，其树根编号为 $1$。我们规定其第 $i$ 个结点的值为其对应的子树内所有与 $i$ 奇偶性相同的结点数量。请按编号从小到大的顺序输出其每个结点的值。", "inputFormat": "输入的第一行包含一个整数 $n$。\n\n接下来 $n-1$ 行描述每个结点的父结点，其中第 $i$ 行包含一个整数 $F_{i+1}$，表示第 $i+1$ 个结点的父结点。", "outputFormat": "输出 $n$ 行，每行包含一个整数表示编号为 $i$ 的结点的值。", "hint": "### 评测用例规模与约定\n\n- 对于 $40\\%$ 的评测用例，$1 \\leq n \\leq 5000$；\n- 对于所有评测用例，$1 \\leq n \\leq 2 \\times 10^5$，$1 \\leq F_i < i$。", "locale": "zh-CN"}}}
{"pid": "P12318", "type": "P", "difficulty": 4, "samples": [["abab", "4\nab\naba\nba\nbab"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "字符串", "图论", "2024", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国研究生组] 分割字符串", "background": "", "description": "给定一个仅含小写字母的字符串 $S$ ，你可将其分割成任意份子串。我们要求分割后任何一段的长度都不大于 $5$ ，且相邻的两个子串不能含有相同的字母。例如 $\\tt{abcdae}$ 分割为 $\\tt{abcd}$ 和 $\\tt{ae}$ 都含 $\\tt{a}$，不合法，但可以分割为 $\\tt{abcda}$ 和 $\\tt{e}$，或者 $\\tt{ab}$、$\\tt{cd}$、$\\tt{ae}$ 等。\n\n问该字符串的所有长度小于等于 $5$ 的本质不同的子串中，哪些在任何分割方案中都没有出现过，按字典序将它们全部输出。\n", "inputFormat": "输入一行包含一个字符串表示 $S$。", "outputFormat": "输出的第一行包含一个整数 $t$ ，表示题目要求的字符串的数量。\n\n接下来 $t$ 行，每行包含一个要求的字符串 $r_i$ ，按字典序排序。", "hint": "### 评测用例规模与约定\n\n- 对于 $30\\%$ 的评测用例，$|S| \\leq 10$；\n- 对于 $60\\%$ 的评测用例，$|S| \\leq 5000$；\n- 对于所有评测用例，$1 \\leq |S| \\leq 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国研究生组] 分割字符串", "background": "", "description": "给定一个仅含小写字母的字符串 $S$ ，你可将其分割成任意份子串。我们要求分割后任何一段的长度都不大于 $5$ ，且相邻的两个子串不能含有相同的字母。例如 $\\tt{abcdae}$ 分割为 $\\tt{abcd}$ 和 $\\tt{ae}$ 都含 $\\tt{a}$，不合法，但可以分割为 $\\tt{abcda}$ 和 $\\tt{e}$，或者 $\\tt{ab}$、$\\tt{cd}$、$\\tt{ae}$ 等。\n\n问该字符串的所有长度小于等于 $5$ 的本质不同的子串中，哪些在任何分割方案中都没有出现过，按字典序将它们全部输出。\n", "inputFormat": "输入一行包含一个字符串表示 $S$。", "outputFormat": "输出的第一行包含一个整数 $t$ ，表示题目要求的字符串的数量。\n\n接下来 $t$ 行，每行包含一个要求的字符串 $r_i$ ，按字典序排序。", "hint": "### 评测用例规模与约定\n\n- 对于 $30\\%$ 的评测用例，$|S| \\leq 10$；\n- 对于 $60\\%$ 的评测用例，$|S| \\leq 5000$；\n- 对于所有评测用例，$1 \\leq |S| \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P12319", "type": "P", "difficulty": 5, "samples": [["3\n0 1 1\n0 1 0\n1 0 0\n4\n2 1 1\n1 2 2\n1 3 3\n3 1 4", "-1\n1\n2\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2024", "矩阵加速", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国研究生组] 最短路", "background": "", "description": "给定一个包含 $n$ 个点的图 $G$，用邻接矩阵 $A_{i,j}$ 表示，其中 $A_{i,j} = 0$ 表示无边，$A_{i,j} > 0$ 表示有边，$A_{i,j}$ 的值为边权。\n\n给定 $m$ 次询问，每次询问你需要找出从 $a_i$ 到 $b_i$ 恰好经过 $c_i$ 条边的边权和最小的路径。对于每次询问，你可以选择某一条边，将其中的一次经过的边权整除 $2$（如果多次经过一条边，只有一次整除 $2$，其它次按原边权计算）。", "inputFormat": "输入的第一行包含一个整数 $n$。\n\n接下来 $n$ 行，每行包含 $n$ 个整数，表示邻接矩阵 $A_{i,j}$，相邻整数之间使用一个空格分隔。\n\n接下来一行包含一个整数 $m$。\n\n接下来 $m$ 行，每行包含 3 个整数 $a_i, b_i, c_i$ 表示一次询问，相邻整数之间使用一个空格分隔。", "outputFormat": "输出 $m$ 行，每行包含一个整数依次表示每次询问的答案。如果有恰好经过 $c_i$ 条边的路径，输出路径的最小权值和。如果没有恰好经过 $c_i$ 条边的路径，输出 $-1$。", "hint": "### 评测用例规模与约定\n\n- 对于 $40\\%$ 的评测用例，$m = 1$，$c_i \\leq 50$；\n- 另有 $10\\%$ 的评测用例，$m \\leq 100$，$c_i \\leq 50$；\n- 另有 $20\\%$ 的评测用例，$m = 1$，$c_i < 2^{24}$；\n- 对于所有评测用例，$1 \\leq n \\leq 50$，$1 \\leq m \\leq 1000$，$1 \\leq a_i, b_i \\leq n$，$1 \\leq c_i \\leq 10^9$，$0 \\leq A_{i,j} \\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国研究生组] 最短路", "background": "", "description": "给定一个包含 $n$ 个点的图 $G$，用邻接矩阵 $A_{i,j}$ 表示，其中 $A_{i,j} = 0$ 表示无边，$A_{i,j} > 0$ 表示有边，$A_{i,j}$ 的值为边权。\n\n给定 $m$ 次询问，每次询问你需要找出从 $a_i$ 到 $b_i$ 恰好经过 $c_i$ 条边的边权和最小的路径。对于每次询问，你可以选择某一条边，将其中的一次经过的边权整除 $2$（如果多次经过一条边，只有一次整除 $2$，其它次按原边权计算）。", "inputFormat": "输入的第一行包含一个整数 $n$。\n\n接下来 $n$ 行，每行包含 $n$ 个整数，表示邻接矩阵 $A_{i,j}$，相邻整数之间使用一个空格分隔。\n\n接下来一行包含一个整数 $m$。\n\n接下来 $m$ 行，每行包含 3 个整数 $a_i, b_i, c_i$ 表示一次询问，相邻整数之间使用一个空格分隔。", "outputFormat": "输出 $m$ 行，每行包含一个整数依次表示每次询问的答案。如果有恰好经过 $c_i$ 条边的路径，输出路径的最小权值和。如果没有恰好经过 $c_i$ 条边的路径，输出 $-1$。", "hint": "### 评测用例规模与约定\n\n- 对于 $40\\%$ 的评测用例，$m = 1$，$c_i \\leq 50$；\n- 另有 $10\\%$ 的评测用例，$m \\leq 100$，$c_i \\leq 50$；\n- 另有 $20\\%$ 的评测用例，$m = 1$，$c_i < 2^{24}$；\n- 对于所有评测用例，$1 \\leq n \\leq 50$，$1 \\leq m \\leq 1000$，$1 \\leq a_i, b_i \\leq n$，$1 \\leq c_i \\leq 10^9$，$0 \\leq A_{i,j} \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P12320", "type": "P", "difficulty": 6, "samples": [["2\n1 -1", "0"], ["4\n0 1 -1 1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "组合数学", "容斥原理", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国研究生组] 深度优先搜索", "background": "", "description": "小蓝正在学习深度优先搜索。给出一段小蓝写的代码\n\n```cpp\nvoid dfs(int rt, int deep, int fa) {\n    a[++cnt] = deep;\n    for (int i = head[rt]; i; i = e[i].next)\n        if (e[i].to != fa) dfs(e[i].to, deep + 1, rt);\n}\n```\n\n对一个有根树执行 `dfs(root, 0, 0)` 可以生成一个长度为树中结点个数的序列，依次表示对遍历的所有结点的深度，小蓝认为假如一个序列能够通过对一个有根树执行 `dfs` 得到，这个序列就是合法的。现在小蓝有一个只包含 $-1$ 和非负整数的序列，小蓝想要知道，有多少种把 $-1$ 替换成任意非负整数的方案，使得该序列合法。", "inputFormat": "输入的第一行包含一个正整数 $n$ 表示序列长度。\n\n第二行包含 $n$ 个非负整数或 $-1$，相邻整数之间使用一个空格分隔，表示序列中的数 $a_i$。", "outputFormat": "输出一行包含一个整数，表示答案除以 $10^9 + 7$ 的余数。", "hint": "### 样例说明\n\n对于样例 $2$，两个合法的序列是 $\\{0, 1, 1, 1\\}$ 和 $\\{0, 1, 2, 1\\}$。\n\n### 评测用例规模与约定\n\n- 对于 $30\\%$ 的评测用例，保证序列中不会出现两个连续的 $-1$，即若 $a_i = -1$，则 $a_{i+1} \\neq -1$。\n- 对于 $50\\%$ 的评测用例，$n \\leq 300$；\n- 对于所有评测用例，$1 \\leq n \\leq 1000000$，$-1 \\leq a_i \\leq n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国研究生组] 深度优先搜索", "background": "", "description": "小蓝正在学习深度优先搜索。给出一段小蓝写的代码\n\n```cpp\nvoid dfs(int rt, int deep, int fa) {\n    a[++cnt] = deep;\n    for (int i = head[rt]; i; i = e[i].next)\n        if (e[i].to != fa) dfs(e[i].to, deep + 1, rt);\n}\n```\n\n对一个有根树执行 `dfs(root, 0, 0)` 可以生成一个长度为树中结点个数的序列，依次表示对遍历的所有结点的深度，小蓝认为假如一个序列能够通过对一个有根树执行 `dfs` 得到，这个序列就是合法的。现在小蓝有一个只包含 $-1$ 和非负整数的序列，小蓝想要知道，有多少种把 $-1$ 替换成任意非负整数的方案，使得该序列合法。", "inputFormat": "输入的第一行包含一个正整数 $n$ 表示序列长度。\n\n第二行包含 $n$ 个非负整数或 $-1$，相邻整数之间使用一个空格分隔，表示序列中的数 $a_i$。", "outputFormat": "输出一行包含一个整数，表示答案除以 $10^9 + 7$ 的余数。", "hint": "### 样例说明\n\n对于样例 $2$，两个合法的序列是 $\\{0, 1, 1, 1\\}$ 和 $\\{0, 1, 2, 1\\}$。\n\n### 评测用例规模与约定\n\n- 对于 $30\\%$ 的评测用例，保证序列中不会出现两个连续的 $-1$，即若 $a_i = -1$，则 $a_{i+1} \\neq -1$。\n- 对于 $50\\%$ 的评测用例，$n \\leq 300$；\n- 对于所有评测用例，$1 \\leq n \\leq 1000000$，$-1 \\leq a_i \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P12321", "type": "P", "difficulty": 6, "samples": [["4", "4\n2\n0\n0"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "快速傅里叶变换 FFT", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国研究生组] 生成树问题", "background": "", "description": "给定 $n$ 个点，编号 $1$ 至 $n$，任意两点 $x, y$ 之间均有且仅有一条边。如果 $x \\cdot y$ 为完全平方数（也即存在整数 $z$ 满足 $z^2 = x \\cdot y$），那么其边权为 $1$，否则为 $0$。\n\n小蓝想要得到一棵生成树，其除 $1$ 以外的每个点都有一个编号小于自己的点与其相邻。求小蓝想得到的所有生成树中，边权和为 $0$ 至 $n-1$ 的分别各有多少种，请输出答案对 $998244353$ 取模的结果。", "inputFormat": "输入一行包含一个整数 $n$。", "outputFormat": "输出 $n$ 行，每行包含一个整数，依次表示边权和为 $0 \\sim n-1$ 的生成树种数。", "hint": "### 评测用例规模与约定\n\n- 对于 $60\\%$ 的评测用例，$n \\leq 5000$；\n- 对于 $85\\%$ 的评测用例，$n \\leq 10^5$；\n\n对于所有评测用例，$1 \\leq n \\leq 3 \\times 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国研究生组] 生成树问题", "background": "", "description": "给定 $n$ 个点，编号 $1$ 至 $n$，任意两点 $x, y$ 之间均有且仅有一条边。如果 $x \\cdot y$ 为完全平方数（也即存在整数 $z$ 满足 $z^2 = x \\cdot y$），那么其边权为 $1$，否则为 $0$。\n\n小蓝想要得到一棵生成树，其除 $1$ 以外的每个点都有一个编号小于自己的点与其相邻。求小蓝想得到的所有生成树中，边权和为 $0$ 至 $n-1$ 的分别各有多少种，请输出答案对 $998244353$ 取模的结果。", "inputFormat": "输入一行包含一个整数 $n$。", "outputFormat": "输出 $n$ 行，每行包含一个整数，依次表示边权和为 $0 \\sim n-1$ 的生成树种数。", "hint": "### 评测用例规模与约定\n\n- 对于 $60\\%$ 的评测用例，$n \\leq 5000$；\n- 对于 $85\\%$ 的评测用例，$n \\leq 10^5$；\n\n对于所有评测用例，$1 \\leq n \\leq 3 \\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P12322", "type": "P", "difficulty": 3, "samples": [["2 10\n1 2", "3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "2024", "广度优先搜索 BFS", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国 Java C] 瞬移", "background": "", "description": "小蓝在环游宇宙的过程中误入了一个数轴上的秘境，秘境的入口为 $1$，这是小蓝的初始位置，出口为 $L$，小蓝每次可以选取两个正整数 $x, y$，其中 $x, y \\in \\{a_1, a_2, \\cdots, a_n\\}$，并向右瞬间移动 $x + y$ 的距离，然而，秘境有大小限制，如果小蓝当前位置为 $p$，则瞬移后的位置为 $(p + x + y - 1) \\bmod L + 1$，当小蓝的位置在出口 $L$ 时即可离开秘境，请问小蓝最少瞬移多少次之后可以离开秘境？\n", "inputFormat": "输入的第一行包含两个正整数 $n, L$，用一个空格分隔。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\cdots, a_n$，相邻整数之间使用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案，如果小蓝永远无法离开秘境，输出 $-1$。", "hint": "### 样例说明\n\n- 第一次选取 $x = 1, y = 1$，到达位置 $3$，\n- 第二次选取 $x = 1, y = 2$，到达位置 $6$，\n- 第三次选取 $x = 2, y = 2$，到达位置 $10$。\n\n### 评测用例规模与约定\n\n- 对于 $20\\%$ 的评测用例，$1 \\leq n \\leq 200$，$1 \\leq L \\leq 200$；\n- 对于所有评测用例，$1 \\leq n \\leq 2000$，$1 \\leq L \\leq 2000$，$0 \\leq a_i \\leq 10^8$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国 Java C] 瞬移", "background": "", "description": "小蓝在环游宇宙的过程中误入了一个数轴上的秘境，秘境的入口为 $1$，这是小蓝的初始位置，出口为 $L$，小蓝每次可以选取两个正整数 $x, y$，其中 $x, y \\in \\{a_1, a_2, \\cdots, a_n\\}$，并向右瞬间移动 $x + y$ 的距离，然而，秘境有大小限制，如果小蓝当前位置为 $p$，则瞬移后的位置为 $(p + x + y - 1) \\bmod L + 1$，当小蓝的位置在出口 $L$ 时即可离开秘境，请问小蓝最少瞬移多少次之后可以离开秘境？\n", "inputFormat": "输入的第一行包含两个正整数 $n, L$，用一个空格分隔。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\cdots, a_n$，相邻整数之间使用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案，如果小蓝永远无法离开秘境，输出 $-1$。", "hint": "### 样例说明\n\n- 第一次选取 $x = 1, y = 1$，到达位置 $3$，\n- 第二次选取 $x = 1, y = 2$，到达位置 $6$，\n- 第三次选取 $x = 2, y = 2$，到达位置 $10$。\n\n### 评测用例规模与约定\n\n- 对于 $20\\%$ 的评测用例，$1 \\leq n \\leq 200$，$1 \\leq L \\leq 200$；\n- 对于所有评测用例，$1 \\leq n \\leq 2000$，$1 \\leq L \\leq 2000$，$0 \\leq a_i \\leq 10^8$。", "locale": "zh-CN"}}}
{"pid": "P12323", "type": "P", "difficulty": 2, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["数学", "2023", "数论", "蓝桥杯省赛"], "title": "[蓝桥杯 2023 省 Java B] 阶乘求和", "background": "", "description": "令 $S = 1! + 2! + 3! + \\cdots + 202320232023!$，求 $S$ 的末尾 $9$ 位数字。\n\n提示：答案首位不为 $0$。", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只需要**编写一个程序输出这个整数**，输出多余的内容将无法得分。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2023 省 Java B] 阶乘求和", "background": "", "description": "令 $S = 1! + 2! + 3! + \\cdots + 202320232023!$，求 $S$ 的末尾 $9$ 位数字。\n\n提示：答案首位不为 $0$。", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只需要**编写一个程序输出这个整数**，输出多余的内容将无法得分。", "hint": "", "locale": "zh-CN"}}}
