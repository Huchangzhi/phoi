{"pid": "P13455", "type": "P", "difficulty": 3, "samples": [["2\n5\n3 2\n09:00 12:00\n10:00 13:00\n11:00 12:30\n12:02 15:00\n09:00 10:30\n2\n2 0\n09:00 09:01\n12:00 12:02", "Case #1: 2 2\nCase #2: 2 0"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2008", "堆", "Google Code Jam"], "title": "[GCJ 2008 Qualification] Train Timetable", "background": "", "description": "A train line has two stations on it, A and B. Trains can take trips from A to B or from B to A multiple times during a day. When a train arrives at B from A (or arrives at A from B), it needs a certain amount of time before it is ready to take the return journey - this is the turnaround time. For example, if a train arrives at 12:00 and the turnaround time is 0 minutes, it can leave immediately, at 12:00.\n\nA train timetable specifies departure and arrival time of all trips between A and B. The train company needs to know how many trains have to start the day at A and B in order to make the timetable work: whenever a train is supposed to leave A or B, there must actually be one there ready to go. There are passing sections on the track, so trains don't necessarily arrive in the same order that they leave. Trains may not travel on trips that do not appear on the schedule.", "inputFormat": "The first line of input gives the number of cases, $N$. $N$ test cases follow.\n\nEach case contains a number of lines. The first line is the turnaround time, $T$, in minutes. The next line has two numbers on it, $N_A$ and $N_B$. $N_A$ is the number of trips from A to B, and $N_B$ is the number of trips from B to A. Then there are $N_A$ lines giving the details of the trips from A to B.\n\nEach line contains two fields, giving the HH:MM departure and arrival time for that trip. The departure time for each trip will be earlier than the arrival time. All arrivals and departures occur on the same day. The trips may appear in any order - they are not necessarily sorted by time. The hour and minute values are both two digits, zero-padded, and are on a 24-hour clock (00:00 through 23:59).\n\nAfter these $N_A$ lines, there are $N_B$ lines giving the departure and arrival times for the trips from B to A.", "outputFormat": "For each test case, output one line containing \"Case #$x$: \" followed by the number of trains that must start at A and the number of trains that must start at B.", "hint": "**Limits**\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 20$\n- $0 \\leq N_A, N_B \\leq 20$\n- $0 \\leq T \\leq 5$\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 100$\n- $0 \\leq N_A, N_B \\leq 100$\n- $0 \\leq T \\leq 60$", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 Qualification] Train Timetable", "background": "", "description": "A train line has two stations on it, A and B. Trains can take trips from A to B or from B to A multiple times during a day. When a train arrives at B from A (or arrives at A from B), it needs a certain amount of time before it is ready to take the return journey - this is the turnaround time. For example, if a train arrives at 12:00 and the turnaround time is 0 minutes, it can leave immediately, at 12:00.\n\nA train timetable specifies departure and arrival time of all trips between A and B. The train company needs to know how many trains have to start the day at A and B in order to make the timetable work: whenever a train is supposed to leave A or B, there must actually be one there ready to go. There are passing sections on the track, so trains don't necessarily arrive in the same order that they leave. Trains may not travel on trips that do not appear on the schedule.", "inputFormat": "The first line of input gives the number of cases, $N$. $N$ test cases follow.\n\nEach case contains a number of lines. The first line is the turnaround time, $T$, in minutes. The next line has two numbers on it, $N_A$ and $N_B$. $N_A$ is the number of trips from A to B, and $N_B$ is the number of trips from B to A. Then there are $N_A$ lines giving the details of the trips from A to B.\n\nEach line contains two fields, giving the HH:MM departure and arrival time for that trip. The departure time for each trip will be earlier than the arrival time. All arrivals and departures occur on the same day. The trips may appear in any order - they are not necessarily sorted by time. The hour and minute values are both two digits, zero-padded, and are on a 24-hour clock (00:00 through 23:59).\n\nAfter these $N_A$ lines, there are $N_B$ lines giving the departure and arrival times for the trips from B to A.", "outputFormat": "For each test case, output one line containing \"Case #$x$: \" followed by the number of trains that must start at A and the number of trains that must start at B.", "hint": "**Limits**\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 20$\n- $0 \\leq N_A, N_B \\leq 20$\n- $0 \\leq T \\leq 5$\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 100$\n- $0 \\leq N_A, N_B \\leq 100$\n- $0 \\leq T \\leq 60$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 Qualification] Train Timetable", "background": null, "description": "一条铁路线有两个车站，A 和 B。列车可以在一天内多次往返于 A 和 B 之间。当一列列车从 A 到达 B（或从 B 到达 A）后，需要一定的时间才能准备好进行返程——这段时间称为周转时间。例如，如果一列列车在 12:00 到达，且周转时间为 0 分钟，则它可以在 12:00 立即出发。\n\n列车时刻表给出了所有 A 到 B 和 B 到 A 之间的行程的出发和到达时间。铁路公司需要知道，为了使时刻表能够顺利运行，早上分别需要在 A 和 B 各准备多少列列车：每当有列车需要从 A 或 B 出发时，必须有一列已经准备好的列车在该站等候。铁路线中有会车段，因此列车的到达顺序不一定与出发顺序相同。列车不能执行时刻表上未列出的行程。", "inputFormat": "输入的第一行为测试用例数 $N$。接下来有 $N$ 组测试数据。\n\n每组测试数据包含若干行。第一行为周转时间 $T$，单位为分钟。下一行为两个整数 $N_A$ 和 $N_B$，分别表示从 A 到 B 和从 B 到 A 的行程数。接下来有 $N_A$ 行，每行包含两个字段，分别为该行程的出发时间和到达时间，格式为 HH:MM。每个行程的出发时间早于到达时间，所有出发和到达均在同一天内。行程的顺序不一定按时间排序。小时和分钟均为两位数，前导零补齐，采用 24 小时制（00:00 到 23:59）。\n\n在这 $N_A$ 行之后，有 $N_B$ 行，给出从 B 到 A 的行程的出发和到达时间。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #$x$: \"，后接需要在 A 和 B 各自准备的列车数量。", "hint": "**数据范围**\n\n**小数据集（5 分，测试点 1 - 可见）**\n\n- $1 \\leq N \\leq 20$\n- $0 \\leq N_A, N_B \\leq 20$\n- $0 \\leq T \\leq 5$\n\n**大数据集（20 分，测试点 2 - 隐藏）**\n\n- $1 \\leq N \\leq 100$\n- $0 \\leq N_A, N_B \\leq 100$\n- $0 \\leq T \\leq 60$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13456", "type": "P", "difficulty": 5, "samples": [["5\n0.250000 1.000000 0.100000 0.010000 0.500000\n0.250000 1.000000 0.100000 0.010000 0.900000\n0.000010 10000.000000 0.000010 0.000010 1000.000000\n0.400000 10000.000000 0.000010 0.000010 700.000000\n1.000000 100.000000 1.000000 1.000000 10.000000", "Case #1: 1.000000\nCase #2: 0.910015\nCase #3: 0.000000\nCase #4: 0.002371\nCase #5: 0.573972"]], "limits": {"time": [6000, 6000], "memory": [1048576, 1048576]}, "tags": ["数学", "计算几何", "2008", "Special Judge", "Google Code Jam"], "title": "[GCJ 2008 Qualification] Fly Swatter", "background": "", "description": "What are your chances of hitting a fly with a tennis racquet?\n\nTo start with, ignore the racquet's handle. Assume the racquet is a perfect ring, of outer radius $R$ and thickness $t$ (so the inner radius of the ring is $R - t$).\n\nThe ring is covered with horizontal and vertical strings. Each string is a cylinder of radius $r$. Each string is a chord of the ring (a straight line connecting two points of the circle). There is a gap of length $g$ between neighbouring strings. The strings are symmetric with respect to the center of the racquet i.e. there is a pair of strings whose centers meet at the center of the ring.\n\nThe fly is a sphere of radius $f$. Assume that the racquet is moving in a straight line perpendicular to the plane of the ring. Assume also that the fly's center is inside the outer radius of the racquet and is equally likely to be anywhere within that radius. Any overlap between the fly and the racquet (the ring or a string) counts as a hit.", "inputFormat": "One line containing an integer $N$, the number of test cases in the input file.\n\nThe next $N$ lines will each contain the numbers $f$, $R$, $t$, $r$ and $g$ separated by exactly one space. Also the numbers will have exactly 6 digits after the decimal point.\n", "outputFormat": "$N$ lines, each of the form \"Case #$k$: $P$\", where $k$ is the number of the test case and $P$ is the probability of hitting the fly with a piece of the racquet.\n\nAnswers with a relative or absolute error of at most $10^{-6}$ will be considered correct.", "hint": "- $f$, $R$, $t$, $r$ and $g$ will be positive and smaller or equal to 10000.\n- $t < R$\n- $f < R$\n- $r < R$\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 30$\n- The total number of strings will be at most 60 (so at most 30 in each direction).\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 100$\n- The total number of strings will be at most 2000 (so at most 1000 in each direction).\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 Qualification] Fly Swatter", "background": "", "description": "What are your chances of hitting a fly with a tennis racquet?\n\nTo start with, ignore the racquet's handle. Assume the racquet is a perfect ring, of outer radius $R$ and thickness $t$ (so the inner radius of the ring is $R - t$).\n\nThe ring is covered with horizontal and vertical strings. Each string is a cylinder of radius $r$. Each string is a chord of the ring (a straight line connecting two points of the circle). There is a gap of length $g$ between neighbouring strings. The strings are symmetric with respect to the center of the racquet i.e. there is a pair of strings whose centers meet at the center of the ring.\n\nThe fly is a sphere of radius $f$. Assume that the racquet is moving in a straight line perpendicular to the plane of the ring. Assume also that the fly's center is inside the outer radius of the racquet and is equally likely to be anywhere within that radius. Any overlap between the fly and the racquet (the ring or a string) counts as a hit.", "inputFormat": "One line containing an integer $N$, the number of test cases in the input file.\n\nThe next $N$ lines will each contain the numbers $f$, $R$, $t$, $r$ and $g$ separated by exactly one space. Also the numbers will have exactly 6 digits after the decimal point.\n", "outputFormat": "$N$ lines, each of the form \"Case #$k$: $P$\", where $k$ is the number of the test case and $P$ is the probability of hitting the fly with a piece of the racquet.\n\nAnswers with a relative or absolute error of at most $10^{-6}$ will be considered correct.", "hint": "- $f$, $R$, $t$, $r$ and $g$ will be positive and smaller or equal to 10000.\n- $t < R$\n- $f < R$\n- $r < R$\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 30$\n- The total number of strings will be at most 60 (so at most 30 in each direction).\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 100$\n- The total number of strings will be at most 2000 (so at most 1000 in each direction).\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 Qualification] Fly Swatter", "background": null, "description": "你用网球拍打中一只苍蝇的概率是多少？\n\n首先，忽略球拍的手柄。假设球拍是一个完美的圆环，外半径为 $R$，厚度为 $t$（因此圆环的内半径为 $R - t$）。\n\n圆环上覆盖有水平和垂直的球线。每根球线都是半径为 $r$ 的圆柱体。每根球线都是圆环上的一条弦（即连接圆上两点的直线）。相邻两根球线之间有长度为 $g$ 的空隙。所有球线关于圆心对称，即有一对球线的中心正好经过圆环的中心。\n\n苍蝇是一个半径为 $f$ 的球体。假设球拍沿垂直于圆环平面的直线运动。还假设苍蝇的中心在球拍外半径以内，并且在该半径范围内的任意位置出现的概率相等。只要苍蝇与球拍（包括圆环或球线）有任何重叠，就算打中了苍蝇。", "inputFormat": "第一行包含一个整数 $N$，表示测试用例的数量。\n\n接下来的 $N$ 行，每行包含 $f$、$R$、$t$、$r$ 和 $g$ 五个数，数值之间用一个空格隔开。所有数值均保留 6 位小数。", "outputFormat": "共 $N$ 行，每行格式为 \"Case #$k$: $P$\"，其中 $k$ 表示测试用例编号，$P$ 表示苍蝇被球拍打中的概率。\n\n只要答案的相对或绝对误差不超过 $10^{-6}$，即视为正确。", "hint": "- $f$、$R$、$t$、$r$ 和 $g$ 均为正数，且不超过 10000。\n- $t < R$\n- $f < R$\n- $r < R$\n\n**小数据集（5 分，测试集 1 - 可见）**\n\n- $1 \\leq N \\leq 30$\n- 球线总数最多为 60（即每个方向最多 30 根）。\n\n**大数据集（20 分，测试集 2 - 隐藏）**\n\n- $1 \\leq N \\leq 100$\n- 球线总数最多为 2000（即每个方向最多 1000 根）。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13457", "type": "P", "difficulty": 2, "samples": [["2\n3\n1 3 -5\n-2 4 1\n5\n1 2 3 4 5\n1 0 1 0 1", "Case #1: -25\nCase #2: 6"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["数学", "贪心", "2008", "Google Code Jam"], "title": "[GCJ 2008 #1A] Minimum Scalar Product", "background": "", "description": "You are given two vectors $v_1 = (x_1, x_2, ..., x_n)$ and $v_2 = (y_1, y_2, ..., y_n)$. The scalar product of these vectors is a single number, calculated as $x_1y_1 + x_2y_2 + ... + x_ny_n$.\n\nSuppose you are allowed to permute the coordinates of each vector as you wish. Choose two permutations such that the scalar product of your two new vectors is the smallest possible, and output that minimum scalar product.\n", "inputFormat": "The first line of the input file contains integer number $T$ - the number of test cases. For each test case, the first line contains integer number $n$. The next two lines contain $n$ integers each, giving the coordinates of $v_1$ and $v_2$ respectively.\n", "outputFormat": "For each test case, output a line\n\nCase #$X$: $Y$\n\nwhere $X$ is the test case number, starting from 1, and $Y$ is the minimum scalar product of all permutations of the two given vectors.", "hint": "**Limits**\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $T = 1000$\n- $1 \\leq n \\leq 8$\n- $-1000 \\leq x_i, y_i \\leq 1000$\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $T = 10$\n- $100 \\leq n \\leq 800$\n- $-100000 \\leq x_i, y_i \\leq 100000$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 #1A] Minimum Scalar Product", "background": "", "description": "You are given two vectors $v_1 = (x_1, x_2, ..., x_n)$ and $v_2 = (y_1, y_2, ..., y_n)$. The scalar product of these vectors is a single number, calculated as $x_1y_1 + x_2y_2 + ... + x_ny_n$.\n\nSuppose you are allowed to permute the coordinates of each vector as you wish. Choose two permutations such that the scalar product of your two new vectors is the smallest possible, and output that minimum scalar product.\n", "inputFormat": "The first line of the input file contains integer number $T$ - the number of test cases. For each test case, the first line contains integer number $n$. The next two lines contain $n$ integers each, giving the coordinates of $v_1$ and $v_2$ respectively.\n", "outputFormat": "For each test case, output a line\n\nCase #$X$: $Y$\n\nwhere $X$ is the test case number, starting from 1, and $Y$ is the minimum scalar product of all permutations of the two given vectors.", "hint": "**Limits**\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $T = 1000$\n- $1 \\leq n \\leq 8$\n- $-1000 \\leq x_i, y_i \\leq 1000$\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $T = 10$\n- $100 \\leq n \\leq 800$\n- $-100000 \\leq x_i, y_i \\leq 100000$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 #1A] Minimum Scalar Product", "background": null, "description": "给定两个向量 $v_1 = (x_1, x_2, ..., x_n)$ 和 $v_2 = (y_1, y_2, ..., y_n)$。这两个向量的标量积是一个单一的数，计算方式为 $x_1y_1 + x_2y_2 + ... + x_ny_n$。\n\n现在你可以任意排列每个向量的坐标。请选择两个排列，使得这两个新向量的标量积尽可能小，并输出这个最小的标量积。", "inputFormat": "输入文件的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例，第一行包含一个整数 $n$。接下来的两行每行包含 $n$ 个整数，分别表示 $v_1$ 和 $v_2$ 的各个坐标。", "outputFormat": "对于每个测试用例，输出一行：\n\nCase #$X$: $Y$\n\n其中 $X$ 是测试用例编号（从 1 开始），$Y$ 是所有排列下两个向量的最小标量积。", "hint": "**数据范围**\n\n**小数据集（5 分，测试集 1 - 可见）**\n\n- $T = 1000$\n- $1 \\leq n \\leq 8$\n- $-1000 \\leq x_i, y_i \\leq 1000$\n\n**大数据集（10 分，测试集 2 - 隐藏）**\n\n- $T = 10$\n- $100 \\leq n \\leq 800$\n- $-100000 \\leq x_i, y_i \\leq 100000$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13458", "type": "P", "difficulty": 4, "samples": [["2\n5\n3\n1 1 1\n2 1 0 2 0\n1 5 0\n1\n2\n1 1 0\n1 1 1", "Case #1: 1 0 0 0 0\nCase #2: IMPOSSIBLE"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2008", "Google Code Jam"], "title": "[GCJ 2008 #1A] Milkshakes", "background": "", "description": "You own a milkshake shop. There are $N$ different flavors that you can prepare, and each flavor can be prepared \"malted\" or \"unmalted\". So, you can make $2N$ different types of milkshakes.\n\nEach of your customers has a set of milkshake types that they like, and they will be satisfied if you have at least one of those types prepared. At most one of the types a customer likes will be a \"malted\" flavor.\n\nYou want to make $N$ batches of milkshakes, so that:\n\n- There is exactly one batch for each flavor of milkshake, and it is either malted or unmalted.\n- For each customer, you make at least one milkshake type that they like.\n- The minimum possible number of batches are malted.\n\nFind whether it is possible to satisfy all your customers given these constraints, and if it is, what milkshake types you should make.\n\nIf it is possible to satisfy all your customers, there will be only one answer which minimizes the number of malted batches.", "inputFormat": "One line containing an integer $C$, the number of test cases in the input file.\n\nFor each test case, there will be:\n\n* One line containing the integer $N$, the number of milkshake flavors.\n* One line containing the integer $M$, the number of customers.\n* $M$ lines, one for each customer, each containing:\n    * An integer $T \\geq 1$, the number of milkshake types the customer likes, followed by\n    * $T$ pairs of integers \"X Y\", one for each type the customer likes, where $X$ is the milkshake flavor between $1$ and $N$ inclusive, and $Y$ is either $0$ to indicate unmalted, or $1$ to indicated malted.\n\nNote that:\n\n* No pair will occur more than once for a single customer.\n* Each customer will have at least one flavor that they like ($T \\geq 1$).\n* Each customer will like at most one malted flavor. (At most one pair for each customer has $Y = 1$).\n\nAll of these numbers are separated by single spaces.", "outputFormat": "$C$ lines, one for each test case in the order they occur in the input file, each containing the string \"Case #$X$: \" where $X$ is the number of the test case, starting from $1$, followed by:\n\n* The string \"IMPOSSIBLE\", if the customers' preferences cannot be satisfied; OR\n* $N$ space-separated integers, one for each flavor from $1$ to $N$, which are $0$ if the corresponding flavor should be prepared unmalted, and $1$ if it should be malted.", "hint": "**Sample Explanation**\n\nIn the first case, you must make flavor #1 malted, to satisfy the first customer. Every other flavor can be unmalted. The second customer is satisfied by getting flavor #2 unmalted, and the third customer is satisfied by getting flavor #5 unmalted.\n\nIn the second case, there is only one flavor. One of your customers wants it malted and one wants it unmalted. You cannot satisfy them both.\n\n**Limits**\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $C = 100$\n- $1 \\leq N \\leq 10$\n- $1 \\leq M \\leq 100$\n\n**Large dataset (25 Pts, Test set 2 - Hidden)**\n\n- $C = 5$\n- $1 \\leq N \\leq 2000$\n- $1 \\leq M \\leq 2000$\n\nThe sum of all the $T$ values for the customers in a test case will not exceed $3000$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 #1A] Milkshakes", "background": "", "description": "You own a milkshake shop. There are $N$ different flavors that you can prepare, and each flavor can be prepared \"malted\" or \"unmalted\". So, you can make $2N$ different types of milkshakes.\n\nEach of your customers has a set of milkshake types that they like, and they will be satisfied if you have at least one of those types prepared. At most one of the types a customer likes will be a \"malted\" flavor.\n\nYou want to make $N$ batches of milkshakes, so that:\n\n- There is exactly one batch for each flavor of milkshake, and it is either malted or unmalted.\n- For each customer, you make at least one milkshake type that they like.\n- The minimum possible number of batches are malted.\n\nFind whether it is possible to satisfy all your customers given these constraints, and if it is, what milkshake types you should make.\n\nIf it is possible to satisfy all your customers, there will be only one answer which minimizes the number of malted batches.", "inputFormat": "One line containing an integer $C$, the number of test cases in the input file.\n\nFor each test case, there will be:\n\n* One line containing the integer $N$, the number of milkshake flavors.\n* One line containing the integer $M$, the number of customers.\n* $M$ lines, one for each customer, each containing:\n    * An integer $T \\geq 1$, the number of milkshake types the customer likes, followed by\n    * $T$ pairs of integers \"X Y\", one for each type the customer likes, where $X$ is the milkshake flavor between $1$ and $N$ inclusive, and $Y$ is either $0$ to indicate unmalted, or $1$ to indicated malted.\n\nNote that:\n\n* No pair will occur more than once for a single customer.\n* Each customer will have at least one flavor that they like ($T \\geq 1$).\n* Each customer will like at most one malted flavor. (At most one pair for each customer has $Y = 1$).\n\nAll of these numbers are separated by single spaces.", "outputFormat": "$C$ lines, one for each test case in the order they occur in the input file, each containing the string \"Case #$X$: \" where $X$ is the number of the test case, starting from $1$, followed by:\n\n* The string \"IMPOSSIBLE\", if the customers' preferences cannot be satisfied; OR\n* $N$ space-separated integers, one for each flavor from $1$ to $N$, which are $0$ if the corresponding flavor should be prepared unmalted, and $1$ if it should be malted.", "hint": "**Sample Explanation**\n\nIn the first case, you must make flavor #1 malted, to satisfy the first customer. Every other flavor can be unmalted. The second customer is satisfied by getting flavor #2 unmalted, and the third customer is satisfied by getting flavor #5 unmalted.\n\nIn the second case, there is only one flavor. One of your customers wants it malted and one wants it unmalted. You cannot satisfy them both.\n\n**Limits**\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $C = 100$\n- $1 \\leq N \\leq 10$\n- $1 \\leq M \\leq 100$\n\n**Large dataset (25 Pts, Test set 2 - Hidden)**\n\n- $C = 5$\n- $1 \\leq N \\leq 2000$\n- $1 \\leq M \\leq 2000$\n\nThe sum of all the $T$ values for the customers in a test case will not exceed $3000$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 #1A] Milkshakes", "background": null, "description": "你经营着一家奶昔店。有 $N$ 种不同口味的奶昔，每种口味可以制作成“麦芽味”或“非麦芽味”。因此，你可以制作 $2N$ 种不同类型的奶昔。\n\n你的每位顾客都有一组喜欢的奶昔类型，只要你准备了他们喜欢的任意一种类型，他们就会满意。每位顾客喜欢的类型中，最多只有一种是“麦芽味”。\n\n你需要制作 $N$ 批奶昔，要求如下：\n\n- 每种口味的奶昔只制作一批，该批可以是麦芽味或非麦芽味。\n- 对于每位顾客，你至少要制作出一种他们喜欢的奶昔类型。\n- 使得麦芽味批次的数量尽可能少。\n\n请判断在上述约束下，是否有可能让所有顾客都满意。如果可以，请给出每种口味应制作成麦芽味还是非麦芽味的方案。\n\n如果存在满足条件的方案，且麦芽味批次数最少，则答案唯一。", "inputFormat": "第一行包含一个整数 $C$，表示测试用例的数量。\n\n对于每个测试用例，包含如下内容：\n\n- 一行包含整数 $N$，表示奶昔口味的数量。\n- 一行包含整数 $M$，表示顾客的数量。\n- 接下来的 $M$ 行，每行描述一位顾客，格式如下：\n    - 一个整数 $T \\geq 1$，表示该顾客喜欢的奶昔类型数量，后跟\n    - $T$ 对整数“X Y”，每对表示一种该顾客喜欢的类型，其中 $X$ 为口味编号（$1$ 到 $N$），$Y$ 为 $0$ 表示非麦芽味，$1$ 表示麦芽味。\n\n注意：\n\n- 对于同一位顾客，不会有重复的“X Y”对。\n- 每位顾客至少喜欢一种口味（$T \\geq 1$）。\n- 每位顾客喜欢的类型中，最多只有一种是麦芽味（即每位顾客最多只有一对 $Y = 1$）。\n\n所有数字之间用单个空格分隔。", "outputFormat": "共 $C$ 行，每行对应一个测试用例，格式为 \"Case #$X$: \"，其中 $X$ 为测试用例编号（从 $1$ 开始），后接：\n\n- 如果无法满足所有顾客的需求，输出字符串 \"IMPOSSIBLE\"；\n- 否则，输出 $N$ 个用空格分隔的整数，分别表示每种口味应制作成非麦芽味（$0$）还是麦芽味（$1$）。", "hint": "**样例解释**\n\n在第一个样例中，你必须将第 $1$ 号口味制作成麦芽味，以满足第一个顾客。其他口味都可以制作成非麦芽味。第二个顾客通过第 $2$ 号口味的非麦芽味得到满足，第三个顾客通过第 $5$ 号口味的非麦芽味得到满足。\n\n在第二个样例中，只有一种口味。一位顾客想要麦芽味，另一位想要非麦芽味，无法同时满足两人。\n\n**数据范围**\n\n**小数据集（10 分，测试点 1 - 可见）**\n\n- $C = 100$\n- $1 \\leq N \\leq 10$\n- $1 \\leq M \\leq 100$\n\n**大数据集（25 分，测试点 2 - 隐藏）**\n\n- $C = 5$\n- $1 \\leq N \\leq 2000$\n- $1 \\leq M \\leq 2000$\n\n每个测试用例中，所有顾客的 $T$ 之和不超过 $3000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13459", "type": "P", "difficulty": 4, "samples": [["2\n5\n2", "Case #1: 935\nCase #2: 027"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["数学", "2008", "矩阵加速", "Google Code Jam"], "title": "[GCJ 2008 #1A] Numbers", "background": "", "description": "In this problem, you have to find the last three digits before the decimal point for the number $(3 + \\sqrt{5})^n$.\n\nFor example, when $n = 5$, $(3 + \\sqrt{5})^5 = 3935.73982\\dots$ The answer is $935$.\n\nFor $n = 2$, $(3 + \\sqrt{5})^2 = 27.4164079\\dots$ The answer is $027$.", "inputFormat": "The first line of input gives the number of cases, $T$. $T$ test cases follow, each on a separate line. Each test case contains one positive integer $n$.\n", "outputFormat": "For each input case, you should output:\n\nCase #$X$: $Y$\n\nwhere $X$ is the number of the test case and $Y$ is the last three integer digits of the number $(3 + \\sqrt{5})^n$. In case that number has fewer than three integer digits, add leading zeros so that your output contains exactly three digits.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$\n\n**Small dataset (15 Pts, Test set 1 - Visible)**\n\n- $2 \\leq n \\leq 30$\n\n**Large dataset (35 Pts, Test set 2 - Hidden)**\n\n- $2 \\leq n \\leq 20000000000$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 #1A] Numbers", "background": "", "description": "In this problem, you have to find the last three digits before the decimal point for the number $(3 + \\sqrt{5})^n$.\n\nFor example, when $n = 5$, $(3 + \\sqrt{5})^5 = 3935.73982\\dots$ The answer is $935$.\n\nFor $n = 2$, $(3 + \\sqrt{5})^2 = 27.4164079\\dots$ The answer is $027$.", "inputFormat": "The first line of input gives the number of cases, $T$. $T$ test cases follow, each on a separate line. Each test case contains one positive integer $n$.\n", "outputFormat": "For each input case, you should output:\n\nCase #$X$: $Y$\n\nwhere $X$ is the number of the test case and $Y$ is the last three integer digits of the number $(3 + \\sqrt{5})^n$. In case that number has fewer than three integer digits, add leading zeros so that your output contains exactly three digits.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$\n\n**Small dataset (15 Pts, Test set 1 - Visible)**\n\n- $2 \\leq n \\leq 30$\n\n**Large dataset (35 Pts, Test set 2 - Hidden)**\n\n- $2 \\leq n \\leq 20000000000$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 #1A] Numbers", "background": "", "description": "在本题中，你需要找出数字 $(3 + \\sqrt{5})^n$ 小数点前的最后三位数字。\n\n例如，当 $n = 5$ 时，$(3 + \\sqrt{5})^5 = 3935.73982\\dots$，答案是 $935$。\n\n当 $n = 2$ 时，$(3 + \\sqrt{5})^2 = 27.4164079\\dots$，答案是 $027$。", "inputFormat": "输入的第一行包含一个整数 $T$，表示测试用例的数量。接下来的 $T$ 行，每行包含一个正整数 $n$，表示一个测试用例。", "outputFormat": "对于每个输入用例，输出格式如下：\n\nCase #$X$: $Y$\n\n其中 $X$ 表示测试用例编号，$Y$ 表示 $(3 + \\sqrt{5})^n$ 小数点前的最后三位数字。如果该数字不足三位，需要在前面补零，使输出恰好为三位数字。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 100$\n\n**小数据集（15 分，测试点 1 - 可见）**\n\n- $2 \\leq n \\leq 30$\n\n**大数据集（35 分，测试点 2 - 隐藏）**\n\n- $2 \\leq n \\leq 2\\times10^{10}$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13460", "type": "P", "difficulty": 3, "samples": [["2\n4 10 7 1 2 0 1 20\n6 2 0 2 1 1 2 11", "Case #1: 1\nCase #2: 2"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["数学", "2008", "组合数学", "Google Code Jam"], "title": "[GCJ 2008 #1B] Crop Triangles", "background": "", "description": "Some pranksters have watched too much Discovery Channel and now they want to build a crop triangle during the night. They want to build it inside a large crop that looks like an evenly spaced grid from above. There are some trees planted on the field. Each tree is situated on an intersection of two grid lines (a grid point). The pranksters want the vertices of their crop triangle to be located at these trees. Also, for their crop triangle to be more interesting they want the center of that triangle to be located at some grid point as well. We remind you that if a triangle has the vertices $(x_1, y_1)$, $(x_2, y_2)$ and $(x_3, y_3)$, then the center for this triangle will have the coordinates $((x_1 + x_2 + x_3) / 3, (y_1 + y_2 + y_3) / 3)$.\n\nYou will be given a set of points with integer coordinates giving the location of all the trees on the grid. You are asked to compute how many triangles you can form with distinct vertexes in this set of points so that their center is a grid point as well (i.e. the center has integer coordinates).\n\nIf a triangle has area 0 we will still consider it a valid triangle.", "inputFormat": "The first line of input gives the number of cases, $N$. $N$ test cases follow. Each test case consists of one line containing the integers $n$, $A$, $B$, $C$, $D$, $x_0$, $y_0$ and $M$ separated by exactly one space. $n$ will be the number of trees in the input set. Using the numbers $n$, $A$, $B$, $C$, $D$, $x_0$, $y_0$ and $M$ the following pseudocode will print the coordinates of the trees in the input set. $mod$ indicates the remainder operation.\n\nThe parameters will be chosen such that the input set of trees will not have duplicates.\n\n```\nX = x0, Y = y0\nprint X, Y\nfor i = 1 to n-1\n  X = (A * X + B) mod M\n  Y = (C * Y + D) mod M\n  print X, Y\n```", "outputFormat": "For each test case, output one line containing \"Case #$X$: \" where $X$ is the test case number (starting from 1). This should be followed by an integer indicating the number of triangles which can be located at 3 distinct trees and has a center that is a grid point.\n", "hint": "**Sample Explanation**\n\nIn the first test case, the $4$ trees in the generated input set are $(0, 1), (7, 3), (17, 5), (17, 7)$.\n\n**Limits**\n\n- $1 \\leq N \\leq 10$,\n- $0 \\leq A, B, C, D, x_0, y_0 \\leq 10^9$,\n- $1 \\leq M \\leq 10^9$.\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $3 \\leq n \\leq 100$.\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $3 \\leq n \\leq 100000$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 #1B] Crop Triangles", "background": "", "description": "Some pranksters have watched too much Discovery Channel and now they want to build a crop triangle during the night. They want to build it inside a large crop that looks like an evenly spaced grid from above. There are some trees planted on the field. Each tree is situated on an intersection of two grid lines (a grid point). The pranksters want the vertices of their crop triangle to be located at these trees. Also, for their crop triangle to be more interesting they want the center of that triangle to be located at some grid point as well. We remind you that if a triangle has the vertices $(x_1, y_1)$, $(x_2, y_2)$ and $(x_3, y_3)$, then the center for this triangle will have the coordinates $((x_1 + x_2 + x_3) / 3, (y_1 + y_2 + y_3) / 3)$.\n\nYou will be given a set of points with integer coordinates giving the location of all the trees on the grid. You are asked to compute how many triangles you can form with distinct vertexes in this set of points so that their center is a grid point as well (i.e. the center has integer coordinates).\n\nIf a triangle has area 0 we will still consider it a valid triangle.", "inputFormat": "The first line of input gives the number of cases, $N$. $N$ test cases follow. Each test case consists of one line containing the integers $n$, $A$, $B$, $C$, $D$, $x_0$, $y_0$ and $M$ separated by exactly one space. $n$ will be the number of trees in the input set. Using the numbers $n$, $A$, $B$, $C$, $D$, $x_0$, $y_0$ and $M$ the following pseudocode will print the coordinates of the trees in the input set. $mod$ indicates the remainder operation.\n\nThe parameters will be chosen such that the input set of trees will not have duplicates.\n\n```\nX = x0, Y = y0\nprint X, Y\nfor i = 1 to n-1\n  X = (A * X + B) mod M\n  Y = (C * Y + D) mod M\n  print X, Y\n```", "outputFormat": "For each test case, output one line containing \"Case #$X$: \" where $X$ is the test case number (starting from 1). This should be followed by an integer indicating the number of triangles which can be located at 3 distinct trees and has a center that is a grid point.\n", "hint": "**Sample Explanation**\n\nIn the first test case, the $4$ trees in the generated input set are $(0, 1), (7, 3), (17, 5), (17, 7)$.\n\n**Limits**\n\n- $1 \\leq N \\leq 10$,\n- $0 \\leq A, B, C, D, x_0, y_0 \\leq 10^9$,\n- $1 \\leq M \\leq 10^9$.\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $3 \\leq n \\leq 100$.\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $3 \\leq n \\leq 100000$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 #1B] Crop Triangles", "background": null, "description": "一些恶作剧者看了太多的 Discovery Channel，现在他们想在夜晚建造一个“作物三角形”。他们想要在一片看起来像均匀网格的大农田里建造这个三角形。从上方看，农田是一个均匀分布的网格。有一些树被种在田地里，每棵树都位于两条网格线的交点（即网格点）上。恶作剧者希望他们的作物三角形的顶点都位于这些树上。此外，为了让三角形更有趣，他们还希望三角形的中心也位于某个网格点上。我们提醒你，如果一个三角形的顶点分别为 $(x_1, y_1)$、$(x_2, y_2)$ 和 $(x_3, y_3)$，那么该三角形的中心坐标为 $((x_1 + x_2 + x_3) / 3, (y_1 + y_2 + y_3) / 3)$。\n\n你将获得一组整数坐标点，表示所有树在网格上的位置。请你计算，在这些点中可以选出多少个不同的三元组，使得它们组成的三角形的中心也是一个网格点（即中心坐标也是整数）。\n\n如果三角形的面积为 $0$，我们仍然认为它是一个合法的三角形。", "inputFormat": "第一行输入一个整数 $N$，表示测试用例的数量。接下来有 $N$ 组测试数据。每组测试数据占一行，包含整数 $n$、$A$、$B$、$C$、$D$、$x_0$、$y_0$ 和 $M$，用一个空格隔开。$n$ 表示树的数量。利用 $n$、$A$、$B$、$C$、$D$、$x_0$、$y_0$ 和 $M$，可以按照如下伪代码生成所有树的坐标。$mod$ 表示取余操作。\n\n保证生成的树的坐标不会重复。\n\n```\nX = x0, Y = y0\nprint X, Y\nfor i = 1 to n-1\n  X = (A * X + B) mod M\n  Y = (C * Y + D) mod M\n  print X, Y\n```", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #$X$: \"，其中 $X$ 是测试用例编号（从 $1$ 开始）。后接一个整数，表示可以选出的满足条件的三角形数量。", "hint": "**样例解释**\n\n在第一个测试用例中，生成的 $4$ 棵树的坐标分别为 $(0, 1)$、$(7, 3)$、$(17, 5)$、$(17, 7)$。\n\n**数据范围**\n\n- $1 \\leq N \\leq 10$，\n- $0 \\leq A, B, C, D, x_0, y_0 \\leq 10^9$，\n- $1 \\leq M \\leq 10^9$。\n\n**小数据范围（5 分，测试点 1 - 可见）**\n\n- $3 \\leq n \\leq 100$。\n\n**大数据范围（10 分，测试点 2 - 隐藏）**\n\n- $3 \\leq n \\leq 100000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13461", "type": "P", "difficulty": 4, "samples": [["2\n10 20 5\n10 20 3", "Case #1: 9\nCase #2: 7"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["2008", "并查集", "素数判断,质数,筛法", "Google Code Jam"], "title": "[GCJ 2008 #1B] Number Sets", "background": "", "description": "You start with a sequence of consecutive integers. You want to group them into sets.\n\nYou are given the interval, and an integer $P$. Initially, each number in the interval is in its own set.\n\nThen you consider each pair of integers in the interval. If the two integers share a prime factor which is at least $P$, then you merge the two sets to which the two integers belong.\n\nHow many different sets there will be at the end of this process?", "inputFormat": "One line containing an integer $C$, the number of test cases in the input file.\n\nFor each test case, there will be one line containing three single-space-separated integers $A$, $B$, and $P$. $A$ and $B$ are the first and last integers in the interval, and $P$ is the number as described above.\n", "outputFormat": "For each test case, output one line containing the string \"Case #$X$: $Y$\" where $X$ is the number of the test case, starting from 1, and $Y$ is the number of sets.", "hint": "**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leq C \\leq 10$\n- $1 \\leq A \\leq B \\leq 1000$\n- $2 \\leq P \\leq B$\n\n**Large dataset (25 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq C \\leq 100$\n- $1 \\leq A \\leq B \\leq 10^{12}$\n- $B \\leq A + 1000000$\n- $2 \\leq P \\leq B$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 #1B] Number Sets", "background": "", "description": "You start with a sequence of consecutive integers. You want to group them into sets.\n\nYou are given the interval, and an integer $P$. Initially, each number in the interval is in its own set.\n\nThen you consider each pair of integers in the interval. If the two integers share a prime factor which is at least $P$, then you merge the two sets to which the two integers belong.\n\nHow many different sets there will be at the end of this process?", "inputFormat": "One line containing an integer $C$, the number of test cases in the input file.\n\nFor each test case, there will be one line containing three single-space-separated integers $A$, $B$, and $P$. $A$ and $B$ are the first and last integers in the interval, and $P$ is the number as described above.\n", "outputFormat": "For each test case, output one line containing the string \"Case #$X$: $Y$\" where $X$ is the number of the test case, starting from 1, and $Y$ is the number of sets.", "hint": "**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leq C \\leq 10$\n- $1 \\leq A \\leq B \\leq 1000$\n- $2 \\leq P \\leq B$\n\n**Large dataset (25 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq C \\leq 100$\n- $1 \\leq A \\leq B \\leq 10^{12}$\n- $B \\leq A + 1000000$\n- $2 \\leq P \\leq B$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 #1B] Number Sets", "background": null, "description": "你有一个连续整数序列。你希望将它们分组为若干集合。\n\n给定一个区间和一个整数 $P$。最初，区间内的每个整数各自属于一个集合。\n\n然后，你会考虑区间内的每一对整数。如果这两个整数有一个不小于 $P$ 的质因数，则将这两个整数所在的集合合并。\n\n最终，这个过程中会剩下多少个不同的集合？", "inputFormat": "第一行包含一个整数 $C$，表示测试用例的数量。\n\n对于每个测试用例，有一行包含三个用空格分隔的整数 $A$、$B$ 和 $P$。$A$ 和 $B$ 分别是区间的起始和结束整数，$P$ 如上所述。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$X$: $Y$\"，其中 $X$ 是测试用例编号（从 1 开始），$Y$ 是最终集合的数量。", "hint": "**小数据集（10 分，测试集 1 - 可见）**\n\n- $1 \\leq C \\leq 10$\n- $1 \\leq A \\leq B \\leq 1000$\n- $2 \\leq P \\leq B$\n\n**大数据集（25 分，测试集 2 - 隐藏）**\n\n- $1 \\leq C \\leq 100$\n- $1 \\leq A \\leq B \\leq 10^{12}$\n- $B \\leq A + 1000000$\n- $2 \\leq P \\leq B$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13462", "type": "P", "difficulty": 4, "samples": [["2\n5\n5 1 2 3 4 5\n15\n4 3 4 7 10", "Case #1: 1 3 2 5 4\nCase #2: 2 8 13 4"]], "limits": {"time": [6000, 18000], "memory": [1048576, 1048576]}, "tags": ["2008", "线段树", "Google Code Jam"], "title": "[GCJ 2008 #1B] Mousetrap", "background": "", "description": "Mousetrap is a simple card game for one player. It is played with a shuffled deck of cards numbered $1$ through $K$, face down. You play by revealing the top card of the deck and then putting it on the bottom of the deck, keeping count of how many cards you have revealed. If you reveal a card whose number matches the current count, remove it from the deck and reset the count. If the count ever reaches $K+1$, you have lost. If the deck runs out of cards, you win.\n\nSuppose you have a deck of $5$ cards, in the order $2, 5, 3, 1, 4$. You will reveal the $2$ on count $1$, the $5$ on count $2$, then the $3$ on count $3$. Since the value matches the count, you remove the $3$ from the deck, and reset the count. You now have $4$ cards left in the order $1, 4, 2, 5$. You then reveal the $1$ on count $1$, and remove it as well (you're doing great so far!). Continuing in this way you will remove the $2$, then the $4$, and then finally the $5$ for victory.\n\nYou would like to set up a deck of cards in such a way that you will win the game and remove the cards in increasing order. We'll call a deck organized in this way \"perfect.\" For example, with $4$ cards you can organize the deck as $1, 4, 2, 3$, and you will win by removing the cards in the order $1, 2, 3, 4$.", "inputFormat": "The first line of input gives the number of cases, $T$. Each test case starts with a line containing $K$, the number of cards in a deck. The next line starts with an integer $n$, which is followed by $n$ integers $(d_1, d_2, \\ldots)$, indices into the deck.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: \" followed by $n$ integers $(k_1, k_2, \\ldots)$, where $k_i$ is the value of the card at index $d_i$ of a perfect deck of size $K$. The numbers in the output should be separated by spaces, and there must be at least one space following the colon in each \"Case #$x$: \" line.", "hint": "**Small dataset (15 Pts, Test set 1 - Visible)**\n\n- Time limit: ~~60~~ 6 seconds.\n- $T = 100,$\n- $1 \\leq K \\leq 5000,$\n- $1 \\leq n \\leq 100,$\n- $1 \\leq d_i \\leq K.$\n\n**Large dataset (Test set 2 - Hidden)**\n\n- Time limit: ~~180~~ 18 seconds.\n- $T = 10,$\n- $1 \\leq K \\leq 1000000,$\n- $1 \\leq n \\leq 100,$\n- $1 \\leq d_i \\leq K.$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 #1B] Mousetrap", "background": "", "description": "Mousetrap is a simple card game for one player. It is played with a shuffled deck of cards numbered $1$ through $K$, face down. You play by revealing the top card of the deck and then putting it on the bottom of the deck, keeping count of how many cards you have revealed. If you reveal a card whose number matches the current count, remove it from the deck and reset the count. If the count ever reaches $K+1$, you have lost. If the deck runs out of cards, you win.\n\nSuppose you have a deck of $5$ cards, in the order $2, 5, 3, 1, 4$. You will reveal the $2$ on count $1$, the $5$ on count $2$, then the $3$ on count $3$. Since the value matches the count, you remove the $3$ from the deck, and reset the count. You now have $4$ cards left in the order $1, 4, 2, 5$. You then reveal the $1$ on count $1$, and remove it as well (you're doing great so far!). Continuing in this way you will remove the $2$, then the $4$, and then finally the $5$ for victory.\n\nYou would like to set up a deck of cards in such a way that you will win the game and remove the cards in increasing order. We'll call a deck organized in this way \"perfect.\" For example, with $4$ cards you can organize the deck as $1, 4, 2, 3$, and you will win by removing the cards in the order $1, 2, 3, 4$.", "inputFormat": "The first line of input gives the number of cases, $T$. Each test case starts with a line containing $K$, the number of cards in a deck. The next line starts with an integer $n$, which is followed by $n$ integers $(d_1, d_2, \\ldots)$, indices into the deck.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: \" followed by $n$ integers $(k_1, k_2, \\ldots)$, where $k_i$ is the value of the card at index $d_i$ of a perfect deck of size $K$. The numbers in the output should be separated by spaces, and there must be at least one space following the colon in each \"Case #$x$: \" line.", "hint": "**Small dataset (15 Pts, Test set 1 - Visible)**\n\n- Time limit: ~~60~~ 6 seconds.\n- $T = 100,$\n- $1 \\leq K \\leq 5000,$\n- $1 \\leq n \\leq 100,$\n- $1 \\leq d_i \\leq K.$\n\n**Large dataset (Test set 2 - Hidden)**\n\n- Time limit: ~~180~~ 18 seconds.\n- $T = 10,$\n- $1 \\leq K \\leq 1000000,$\n- $1 \\leq n \\leq 100,$\n- $1 \\leq d_i \\leq K.$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 #1B] Mousetrap", "background": null, "description": "Mousetrap 是一个单人纸牌游戏。游戏使用一副洗牌后的编号为 $1$ 到 $K$ 的牌，牌面朝下。你需要依次揭开牌堆顶的牌，然后将其放到牌堆底部，同时记录你已经揭开的牌数。如果你揭开的牌的数字与当前计数相同，则将该牌从牌堆中移除，并将计数重置。如果计数达到 $K+1$，你就输了。如果牌堆中的牌被移除完，你就赢了。\n\n假设你有 $5$ 张牌，顺序为 $2, 5, 3, 1, 4$。你会在计数 $1$ 时揭开 $2$，计数 $2$ 时揭开 $5$，计数 $3$ 时揭开 $3$。由于牌面数字与计数相同，你将 $3$ 移除，并将计数重置。现在剩下 $4$ 张牌，顺序为 $1, 4, 2, 5$。你在计数 $1$ 时揭开 $1$，并将其移除（你目前做得很棒！）。继续这样操作，你会依次移除 $2$，然后是 $4$，最后是 $5$，最终获胜。\n\n你希望将牌堆排列成一种方式，使你能够赢得游戏，并且以递增顺序移除所有牌。我们称这种排列为“完美”牌堆。例如，对于 $4$ 张牌，你可以将牌堆排列为 $1, 4, 2, 3$，你会以 $1, 2, 3, 4$ 的顺序移除所有牌并获胜。", "inputFormat": "输入的第一行为测试用例数 $T$。每个测试用例第一行为一个整数 $K$，表示牌堆中的牌数。下一行为一个整数 $n$，接着是 $n$ 个整数 $(d_1, d_2, \\ldots)$，表示牌堆中的索引。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: \"，后接 $n$ 个整数 $(k_1, k_2, \\ldots)$，其中 $k_i$ 表示在大小为 $K$ 的完美牌堆中，第 $d_i$ 个位置上的牌的数字。输出的数字之间用空格分隔，并且每行的冒号后至少有一个空格。", "hint": "**小数据集（15 分，测试点 1 - 可见）**\n\n- 时间限制：~~60~~ 6 秒。\n- $T = 100$\n- $1 \\leq K \\leq 5000$\n- $1 \\leq n \\leq 100$\n- $1 \\leq d_i \\leq K$\n\n**大数据集（测试点 2 - 隐藏）**\n\n- 时间限制：~~180~~ 18 秒。\n- $T = 10$\n- $1 \\leq K \\leq 1000000$\n- $1 \\leq n \\leq 100$\n- $1 \\leq d_i \\leq K$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13463", "type": "P", "difficulty": 2, "samples": [["2\n3 2 6\n8 2 5 2 4 9\n3 9 26\n1 1 1 100 100 1 1 1 1 1 1 1 1 1 1 1 1 10 11 11 11 11 1 1 1 100", "Case #1: 47\nCase #2: 397"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2008", "Google Code Jam"], "title": "[GCJ 2008 #1C] Text Messaging Outrage", "background": "", "description": "Professor Loony, a dear friend of mine, stormed into my office. His face was red and he looked very angry. The first thing that came out of his mouth was \"Damn those phone manufacturers. I was trying to send a text message, and it took me more than ten minutes to type a one-line message.\" I tried to calm him down. \"But what is wrong? Why did it take you so long?\" He continued, \"Don't you see?! Their placement of the letters is so messed up? Why is 's' the 4th letter on its key? and 'e'? Why is it not the first letter on its key? I have to press '7' FOUR times to type an 's'? This is lunacy!\"\n\n\"Calm down, my friend,\" I said, \"This scheme has been in use for so long, even before text messaging was invented. They had to keep it that way.\"\n\n\"That's not an excuse,\" his face growing redder and redder. \"It is time to change all this. It was a stupid idea to start with. And while we are at it, how come they only put letters on 8 keys? Why not use all 12? And why do they have to be consecutive?\"\n\n\"Umm... I... don't... know,\" I replied.\n\n\"Ok, that's it. Those people are clearly incompetent. I am sure someone can come up with a better scheme.\"\n\nHe was one of those people, I could see. People who complain about the problem, but never actually try to solve it.\n\nIn this problem, you are required to come up with the best letter placement of keys to minimize the number of key presses required to type a message. You will be given the number of keys, the maximum number of letters we can put on every key, the total number of letters in the alphabet, and the frequency of every letter in the message. Letters can be placed anywhere on the keys and in any order. Each letter can only appear on one key. Also, the alphabet can have more than 26 letters (it is not English).\n\nFor reference, the current phone keypad looks like this\n\n```\nkey 2: abc\nkey 3: def\nkey 4: ghi\nkey 5: jkl\nkey 6: mno\nkey 7: pqrs\nkey 8: tuv\nkey 9: wxyz\n```\n\nThe first press of a key types the first letter. Each subsequent press advances to the next letter. For example, to type the word \"snow\", you need to press \"7\" four times, followed by \"6\" twice, followed by \"6\" three times, followed by \"9\" once. The total number of key presses is 10.", "inputFormat": "The first line in the input file contains the number of test cases $N$. This is followed by $N$ cases. Each case consists of two lines. On the first line we have the maximum number of letters to place on a key ($P$), the number of keys available ($K$) and the number of letters in our alphabet ($L$) all separated by single spaces. The second line has $L$ non-negative integers. Each number represents the frequency of a certain letter. The first number is how many times the first letter is used, the second number is how many times the second letter is used, and so on.", "outputFormat": "For each case, you should output the following\n\nCase #$x$: [minimum number of keypad presses]\n\nindicating the number of keypad presses to type the message for the optimal layout.", "hint": "**Limits**\n\n- $P \\times K \\geq L$\n- $0 \\leq \\text{The frequency of each letter} \\leq 1000000$\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 10$\n- $1 \\leq P \\leq 10$\n- $1 \\leq K \\leq 12$\n- $1 \\leq L \\leq 100$\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 100$\n- $1 \\leq P \\leq 1000$\n- $1 \\leq K \\leq 1000$\n- $1 \\leq L \\leq 1000$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 #1C] Text Messaging Outrage", "background": "", "description": "Professor Loony, a dear friend of mine, stormed into my office. His face was red and he looked very angry. The first thing that came out of his mouth was \"Damn those phone manufacturers. I was trying to send a text message, and it took me more than ten minutes to type a one-line message.\" I tried to calm him down. \"But what is wrong? Why did it take you so long?\" He continued, \"Don't you see?! Their placement of the letters is so messed up? Why is 's' the 4th letter on its key? and 'e'? Why is it not the first letter on its key? I have to press '7' FOUR times to type an 's'? This is lunacy!\"\n\n\"Calm down, my friend,\" I said, \"This scheme has been in use for so long, even before text messaging was invented. They had to keep it that way.\"\n\n\"That's not an excuse,\" his face growing redder and redder. \"It is time to change all this. It was a stupid idea to start with. And while we are at it, how come they only put letters on 8 keys? Why not use all 12? And why do they have to be consecutive?\"\n\n\"Umm... I... don't... know,\" I replied.\n\n\"Ok, that's it. Those people are clearly incompetent. I am sure someone can come up with a better scheme.\"\n\nHe was one of those people, I could see. People who complain about the problem, but never actually try to solve it.\n\nIn this problem, you are required to come up with the best letter placement of keys to minimize the number of key presses required to type a message. You will be given the number of keys, the maximum number of letters we can put on every key, the total number of letters in the alphabet, and the frequency of every letter in the message. Letters can be placed anywhere on the keys and in any order. Each letter can only appear on one key. Also, the alphabet can have more than 26 letters (it is not English).\n\nFor reference, the current phone keypad looks like this\n\n```\nkey 2: abc\nkey 3: def\nkey 4: ghi\nkey 5: jkl\nkey 6: mno\nkey 7: pqrs\nkey 8: tuv\nkey 9: wxyz\n```\n\nThe first press of a key types the first letter. Each subsequent press advances to the next letter. For example, to type the word \"snow\", you need to press \"7\" four times, followed by \"6\" twice, followed by \"6\" three times, followed by \"9\" once. The total number of key presses is 10.", "inputFormat": "The first line in the input file contains the number of test cases $N$. This is followed by $N$ cases. Each case consists of two lines. On the first line we have the maximum number of letters to place on a key ($P$), the number of keys available ($K$) and the number of letters in our alphabet ($L$) all separated by single spaces. The second line has $L$ non-negative integers. Each number represents the frequency of a certain letter. The first number is how many times the first letter is used, the second number is how many times the second letter is used, and so on.", "outputFormat": "For each case, you should output the following\n\nCase #$x$: [minimum number of keypad presses]\n\nindicating the number of keypad presses to type the message for the optimal layout.", "hint": "**Limits**\n\n- $P \\times K \\geq L$\n- $0 \\leq \\text{The frequency of each letter} \\leq 1000000$\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 10$\n- $1 \\leq P \\leq 10$\n- $1 \\leq K \\leq 12$\n- $1 \\leq L \\leq 100$\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 100$\n- $1 \\leq P \\leq 1000$\n- $1 \\leq K \\leq 1000$\n- $1 \\leq L \\leq 1000$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 #1C] Text Messaging Outrage", "background": null, "description": "我的一位亲密朋友 Loony 教授冲进了我的办公室。他满脸通红，看起来非常生气。他张口就说：“该死的手机制造商。我只是想发条短信，结果打一行字花了我十多分钟！”我试图安慰他：“到底怎么了？为什么花了你这么久？”他继续说道：“你难道没发现吗？！他们把字母排得一团糟？为什么 ‘s’ 是它所在按键的第 4 个字母？还有 ‘e’？为什么不是它所在按键的第一个字母？我得按 ‘7’ 四次才能打出一个 ‘s’？这太疯狂了！”\n\n“冷静点，我的朋友，”我说，“这种方案已经用了很久了，甚至在短信发明之前就有了。他们不得不保持这种方式。”\n\n“这不是借口，”他的脸越来越红。“是时候改变这一切了。一开始就是个愚蠢的主意。既然如此，为什么只在 8 个按键上放字母？为什么不用全部 12 个？为什么还必须是连续的？”\n\n“呃……我……不知道……”我回答。\n\n“好了，就这样。这些人显然不称职。我相信一定有人能想出更好的方案。”\n\n我能看出来，他就是那种只会抱怨问题，却从不真正尝试解决问题的人。\n\n在本题中，你需要设计一种最优的字母分配方案，使得输入一条消息所需的按键次数最少。你将得到可用按键数、每个按键最多可放的字母数、字母表的总字母数，以及每个字母在消息中出现的频率。字母可以任意分配到任意按键，顺序也可以任意。每个字母只能出现在一个按键上。字母表可能超过 26 个字母（不一定是英语）。\n\n作为参考，目前手机键盘的布局如下：\n\n```\n按键 2：abc\n按键 3：def\n按键 4：ghi\n按键 5：jkl\n按键 6：mno\n按键 7：pqrs\n按键 8：tuv\n按键 9：wxyz\n```\n\n第一次按某个按键会输入该键的第一个字母，每多按一次就输入下一个字母。例如，要输入单词 “snow”，你需要按 “7” 四次，再按 “6” 两次，再按 “6” 三次，最后按 “9” 一次。总共需要按键 10 次。", "inputFormat": "输入文件的第一行包含测试用例数 $N$。接下来是 $N$ 个测试用例。每个用例包含两行。第一行有三个用空格分隔的整数，分别为每个按键最多可放的字母数 $P$、可用按键数 $K$、字母表中字母总数 $L$。第二行有 $L$ 个非负整数，分别表示每个字母在消息中出现的频率。第一个数字表示第一个字母出现的次数，第二个数字表示第二个字母出现的次数，依此类推。", "outputFormat": "对于每个测试用例，输出如下格式：\n\nCase #$x$: [最少按键次数]\n\n表示在最优布局下输入消息所需的最少按键次数。", "hint": "**限制条件**\n\n- $P \\times K \\geq L$\n- $0 \\leq$ 每个字母的出现频率 $\\leq 1000000$\n\n**小数据集（5 分，测试集 1 - 可见）**\n\n- $1 \\leq N \\leq 10$\n- $1 \\leq P \\leq 10$\n- $1 \\leq K \\leq 12$\n- $1 \\leq L \\leq 100$\n\n**大数据集（10 分，测试集 2 - 隐藏）**\n\n- $1 \\leq N \\leq 100$\n- $1 \\leq P \\leq 1000$\n- $1 \\leq K \\leq 1000$\n- $1 \\leq L \\leq 1000$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13464", "type": "P", "difficulty": 4, "samples": [["4\n1\n9\n011\n12345", "Case #1: 0\nCase #2: 1\nCase #3: 6\nCase #4: 64"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "数学", "2008", "数论", "Google Code Jam"], "title": "[GCJ 2008 #1C] Ugly Numbers", "background": "", "description": "Once upon a time in a strange situation, people called a number *ugly* if it was divisible by any of the one-digit primes ($2$, $3$, $5$ or $7$). Thus, $14$ is ugly, but $13$ is fine. $39$ is ugly, but $121$ is not. Note that $0$ is ugly. Also note that negative numbers can also be ugly; $-14$ and $-39$ are examples of such numbers.\n\nOne day on your free time, you are gazing at a string of digits, something like:\n\n$123456$\n\nYou are amused by how many possibilities there are if you are allowed to insert *plus* or *minus* signs between the digits. For example you can make\n\n$1 + 234 - 5 + 6 = 236$\n\nwhich is ugly. Or\n\n$123 + 4 - 56 = 71$\n\nwhich is not ugly.\n\nIt is easy to count the number of different ways you can play with the digits: Between each two adjacent digits you may choose put a plus sign, a minus sign, or nothing. Therefore, if you start with $D$ digits there are $3^{D-1}$ expressions you can make.\n\nNote that it is fine to have leading zeros for a number. If the string is \"01023\", then \"01023\", \"0+1-02+3\" and \"01-023\" are legal expressions.\n\nYour task is simple: Among the $3^{D-1}$ expressions, count how many of them evaluate to an ugly number.", "inputFormat": "The first line of the input file contains the number of cases, $N$. Each test case will be a single line containing a non-empty string of decimal digits.\n", "outputFormat": "For each test case, you should output a line\n\nCase #X: Y\n\nwhere $X$ is the case number, starting from $1$, and $Y$ is the number of expressions that evaluate to an ugly number.", "hint": "**Limits**\n\n- $0 \\leq N \\leq 100$.\n- The string in each test case will be non-empty and will contain only characters '0' through '9'.\n\n**Small dataset (Test set 1 - Visible)**\n\n- Each string is no more than 13 characters long.\n\n**Large dataset (Test set 2 - Hidden)**\n\n- Each string is no more than 40 characters long.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 #1C] Ugly Numbers", "background": "", "description": "Once upon a time in a strange situation, people called a number *ugly* if it was divisible by any of the one-digit primes ($2$, $3$, $5$ or $7$). Thus, $14$ is ugly, but $13$ is fine. $39$ is ugly, but $121$ is not. Note that $0$ is ugly. Also note that negative numbers can also be ugly; $-14$ and $-39$ are examples of such numbers.\n\nOne day on your free time, you are gazing at a string of digits, something like:\n\n$123456$\n\nYou are amused by how many possibilities there are if you are allowed to insert *plus* or *minus* signs between the digits. For example you can make\n\n$1 + 234 - 5 + 6 = 236$\n\nwhich is ugly. Or\n\n$123 + 4 - 56 = 71$\n\nwhich is not ugly.\n\nIt is easy to count the number of different ways you can play with the digits: Between each two adjacent digits you may choose put a plus sign, a minus sign, or nothing. Therefore, if you start with $D$ digits there are $3^{D-1}$ expressions you can make.\n\nNote that it is fine to have leading zeros for a number. If the string is \"01023\", then \"01023\", \"0+1-02+3\" and \"01-023\" are legal expressions.\n\nYour task is simple: Among the $3^{D-1}$ expressions, count how many of them evaluate to an ugly number.", "inputFormat": "The first line of the input file contains the number of cases, $N$. Each test case will be a single line containing a non-empty string of decimal digits.\n", "outputFormat": "For each test case, you should output a line\n\nCase #X: Y\n\nwhere $X$ is the case number, starting from $1$, and $Y$ is the number of expressions that evaluate to an ugly number.", "hint": "**Limits**\n\n- $0 \\leq N \\leq 100$.\n- The string in each test case will be non-empty and will contain only characters '0' through '9'.\n\n**Small dataset (Test set 1 - Visible)**\n\n- Each string is no more than 13 characters long.\n\n**Large dataset (Test set 2 - Hidden)**\n\n- Each string is no more than 40 characters long.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 #1C] Ugly Numbers", "background": null, "description": "从前在一个奇特的世界里，人们称一个数为“丑数”，如果它能被任意一个一位质数（$2$、$3$、$5$ 或 $7$）整除。因此，$14$ 是丑数，但 $13$ 不是。$39$ 是丑数，但 $121$ 不是。注意，$0$ 也是丑数。同时，负数也可以是丑数，比如 $-14$ 和 $-39$。\n\n有一天，你闲来无事，盯着一串数字，比如：\n\n$123456$\n\n你很好奇，如果允许你在数字之间插入加号或减号，会有多少种可能的表达式。例如，你可以得到：\n\n$1 + 234 - 5 + 6 = 236$\n\n这是一个丑数。或者\n\n$123 + 4 - 56 = 71$\n\n这不是丑数。\n\n计算你可以操作的方式很简单：在每两个相邻数字之间，你可以选择插入加号、减号或什么都不插。因此，如果你有 $D$ 位数字，总共可以构造 $3^{D-1}$ 个表达式。\n\n注意，数字可以有前导零。如果字符串是 \"01023\"，那么 \"01023\"、\"0+1-02+3\" 和 \"01-023\" 都是合法表达式。\n\n你的任务很简单：在这 $3^{D-1}$ 个表达式中，统计有多少个表达式的结果是丑数。", "inputFormat": "输入的第一行包含一个整数 $N$，表示测试用例的数量。每个测试用例为一行，包含一个非空的十进制数字字符串。", "outputFormat": "对于每个测试用例，输出一行：\n\nCase #X: Y\n\n其中 $X$ 是测试用例编号（从 $1$ 开始），$Y$ 是表达式结果为丑数的表达式个数。", "hint": "**限制条件**\n\n- $0 \\leq N \\leq 100$。\n- 每个测试用例的字符串非空，仅包含字符 '0' 到 '9'。\n\n**小数据集（测试集 1 - 可见）**\n\n- 每个字符串长度不超过 $13$。\n\n**大数据集（测试集 2 - 隐藏）**\n\n- 每个字符串长度不超过 $40$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13465", "type": "P", "difficulty": 4, "samples": [["2\n5 5 0 0 5\n1\n2\n1\n2\n3\n6 2 2 1000000000 6\n1\n2", "Case #1: 15\nCase #2: 13"]], "limits": {"time": [6000, 6000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2008", "树状数组", "Google Code Jam"], "title": "[GCJ 2008 #1C] Increasing Speed Limits", "background": "", "description": "You were driving along a highway when you got caught by the road police for speeding. It turns out that they've been following you, and they were amazed by the fact that you were accelerating the whole time without using the brakes! And now you desperately need an excuse to explain that.\n\nYou've decided that it would be reasonable to say \"all the speed limit signs I saw were in increasing order, that's why I've been accelerating\". The police officer laughs in reply, and tells you all the signs that are placed along the segment of highway you drove, and says that's unlikely that you were so lucky just to see some part of these signs that were in increasing order.\n\nNow you need to estimate that likelihood, or, in other words, find out how many different subsequences of the given sequence are strictly increasing. The empty subsequence does not count since that would imply you didn't look at any speed limits signs at all!\n\nFor example, $(1, 2, 5)$ is an increasing subsequence of $(1, 4, 2, 3, 5, 5)$, and we count it twice because there are two ways to select $(1, 2, 5)$ from the list.", "inputFormat": "The first line of input gives the number of cases, $N$. $N$ test cases follow. The first line of each case contains $n$, $m$, $X$, $Y$ and $Z$ each separated by a space. $n$ will be the length of the sequence of speed limits. $m$ will be the length of the generating array $A$. The next $m$ lines will contain the $m$ elements of $A$, one integer per line (from $A[0]$ to $A[m-1]$).\n\nUsing $A$, $X$, $Y$ and $Z$, the following pseudocode will print the speed limit sequence in order. mod indicates the remainder operation.\n\n```\nfor i = 0 to n-1\n  print A[i mod m]\n  A[i mod m] = (X * A[i mod m] + Y * (i + 1)) mod Z\n```\n\nNote: The way that the input is generated has nothing to do with the intended solution and exists solely to keep the size of the input files low.", "outputFormat": "For each test case you should output one line containing \"Case #$T$: $S$\" (quotes for clarity) where $T$ is the number of the test case and $S$ is the number of non-empty increasing subsequences mod $1\\ 000\\ 000\\ 007$.\n", "hint": "**Sample Explanation**\n\nThe sequence of speed limit signs for case $2$ should be $1, 2, 0, 0, 0, 4$.\n\n**Limits**\n\n- $1 \\leq N \\leq 20$\n- $1 \\leq m \\leq 100$\n- $0 \\leq X \\leq 10^9$\n- $0 \\leq Y \\leq 10^9$\n- $1 \\leq Z \\leq 10^9$\n- $0 \\leq A[i] < Z$\n\n**Small dataset (15 Pts, Test set 1 - Visible)**\n\n- $1 \\leq m \\leq n \\leq 1000$\n\n**Large dataset (35 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq m \\leq n \\leq 500000$", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 #1C] Increasing Speed Limits", "background": "", "description": "You were driving along a highway when you got caught by the road police for speeding. It turns out that they've been following you, and they were amazed by the fact that you were accelerating the whole time without using the brakes! And now you desperately need an excuse to explain that.\n\nYou've decided that it would be reasonable to say \"all the speed limit signs I saw were in increasing order, that's why I've been accelerating\". The police officer laughs in reply, and tells you all the signs that are placed along the segment of highway you drove, and says that's unlikely that you were so lucky just to see some part of these signs that were in increasing order.\n\nNow you need to estimate that likelihood, or, in other words, find out how many different subsequences of the given sequence are strictly increasing. The empty subsequence does not count since that would imply you didn't look at any speed limits signs at all!\n\nFor example, $(1, 2, 5)$ is an increasing subsequence of $(1, 4, 2, 3, 5, 5)$, and we count it twice because there are two ways to select $(1, 2, 5)$ from the list.", "inputFormat": "The first line of input gives the number of cases, $N$. $N$ test cases follow. The first line of each case contains $n$, $m$, $X$, $Y$ and $Z$ each separated by a space. $n$ will be the length of the sequence of speed limits. $m$ will be the length of the generating array $A$. The next $m$ lines will contain the $m$ elements of $A$, one integer per line (from $A[0]$ to $A[m-1]$).\n\nUsing $A$, $X$, $Y$ and $Z$, the following pseudocode will print the speed limit sequence in order. mod indicates the remainder operation.\n\n```\nfor i = 0 to n-1\n  print A[i mod m]\n  A[i mod m] = (X * A[i mod m] + Y * (i + 1)) mod Z\n```\n\nNote: The way that the input is generated has nothing to do with the intended solution and exists solely to keep the size of the input files low.", "outputFormat": "For each test case you should output one line containing \"Case #$T$: $S$\" (quotes for clarity) where $T$ is the number of the test case and $S$ is the number of non-empty increasing subsequences mod $1\\ 000\\ 000\\ 007$.\n", "hint": "**Sample Explanation**\n\nThe sequence of speed limit signs for case $2$ should be $1, 2, 0, 0, 0, 4$.\n\n**Limits**\n\n- $1 \\leq N \\leq 20$\n- $1 \\leq m \\leq 100$\n- $0 \\leq X \\leq 10^9$\n- $0 \\leq Y \\leq 10^9$\n- $1 \\leq Z \\leq 10^9$\n- $0 \\leq A[i] < Z$\n\n**Small dataset (15 Pts, Test set 1 - Visible)**\n\n- $1 \\leq m \\leq n \\leq 1000$\n\n**Large dataset (35 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq m \\leq n \\leq 500000$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 #1C] Increasing Speed Limits", "background": null, "description": "你在高速公路上行驶时因超速被交警拦下。原来他们一直在跟踪你，他们惊讶地发现你一路都在加速，完全没有踩刹车！现在你急需一个借口来解释这一切。\n\n你决定说：“我看到的所有限速标志都是递增的，所以我一直在加速。”警察听后大笑，并把你经过的这段高速公路上所有的限速标志都告诉了你，并表示你不太可能这么幸运，刚好只看到了一段递增的标志。\n\n现在你需要估算这种情况发生的概率，换句话说，就是要找出给定序列中有多少个不同的严格递增子序列。空子序列不计入答案，因为那意味着你根本没看任何限速标志！\n\n例如，$(1, 2, 5)$ 是 $(1, 4, 2, 3, 5, 5)$ 的一个递增子序列，并且我们要计数两次，因为有两种方式可以从原序列中选出 $(1, 2, 5)$。", "inputFormat": "第一行输入一个整数 $N$，表示测试用例的数量。接下来有 $N$ 组测试数据。每组测试数据的第一行为 $n$、$m$、$X$、$Y$ 和 $Z$，用空格分隔。$n$ 表示限速标志序列的长度，$m$ 表示生成数组 $A$ 的长度。接下来的 $m$ 行，每行一个整数，依次为 $A[0]$ 到 $A[m-1]$。\n\n使用 $A$、$X$、$Y$ 和 $Z$，按照如下伪代码生成限速标志序列。mod 表示取余操作。\n\n```\nfor i = 0 to n-1\n  print A[i mod m]\n  A[i mod m] = (X * A[i mod m] + Y * (i + 1)) mod Z\n```\n\n注意：输入的生成方式仅用于减小输入文件的体积，与解题方法无关。", "outputFormat": "对于每个测试用例，输出一行，格式为 “Case #$T$: $S$”，其中 $T$ 表示测试用例编号，$S$ 表示非空严格递增子序列的数量，对 $1\\ 000\\ 000\\ 007$ 取模。", "hint": "**样例说明**\n\n对于第 $2$ 个测试用例，限速标志序列应为 $1, 2, 0, 0, 0, 4$。\n\n**数据范围**\n\n- $1 \\leq N \\leq 20$\n- $1 \\leq m \\leq 100$\n- $0 \\leq X \\leq 10^9$\n- $0 \\leq Y \\leq 10^9$\n- $1 \\leq Z \\leq 10^9$\n- $0 \\leq A[i] < Z$\n\n**小数据范围（15 分，测试点 1 - 可见）**\n\n- $1 \\leq m \\leq n \\leq 1000$\n\n**大数据范围（35 分，测试点 2 - 隐藏）**\n\n- $1 \\leq m \\leq n \\leq 500000$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13466", "type": "P", "difficulty": 3, "samples": [["2\n9 1\n1 0\n1 1\n1 1\n0 0\n1\n0\n1\n0\n1\n5 0\n1 1\n0 0\n1\n1\n0", "Case #1: 1\nCase #2: IMPOSSIBLE"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2008", "Google Code Jam"], "title": "[GCJ 2008 #2] Cheating a Boolean Tree", "background": "", "description": "For this problem we will consider a type of binary tree that we will call a boolean tree. In this tree, every row is completely filled, except possibly the last (deepest) row, and the nodes in the last row are as far to the left as possible. Additionally, every node in the tree will either have 0 or 2 children.\n\nWhat makes a boolean tree special is that each node has a boolean value associated with it, $1$ or $0$. In addition, each interior node has either an \"AND\" or an \"OR\" gate associated with it. The value of an \"AND\" gate node is given by the logical AND of its two children's values. The value of an \"OR\" gate likewise is given by the logical OR of its two children's values. The value of all of the leaf nodes will be given as input so that the value of all nodes can be calculated up the tree.\n\nThe root of the tree is of particular interest to us. We would really like for the root to have the value $V$, either $1$ or $0$. Unfortunately, this may not be the value the root actually has. Luckily for us, we can cheat and change the type of gate for some of the nodes; we can change an AND gate to an OR gate or an OR gate to an AND gate.\n\nGiven a description of a boolean tree and what gates can be changed, find the minimum number of gates that need to be changed to make the value of the root node $V$. If this is impossible, output \"IMPOSSIBLE\" (quotes for clarity).\n", "inputFormat": "The first line of the input file contains the number of cases, $N$. $N$ test cases follow.\n\nEach case begins with $M$ and $V$. $M$ represents the number of nodes in the tree and will be odd to ensure all nodes have 0 or 2 children. $V$ is the desired value for the root node, 0 or 1.\n\n$M$ lines follow describing each of the tree's nodes. The $X^{th}$ line will describe node $X$, starting with node 1 on the first line.\n\nThe first $(M-1)/2$ lines describe the interior nodes. Each line contains $G$ and $C$, each being either 0 or 1. If $G$ is 1 then the gate for this node is an AND gate, otherwise it is an OR gate. If $C$ is 1 then the gate for this node is changeable, otherwise it is not. Interior node $X$ has nodes $2X$ and $2X+1$ as children.\n\nThe next $(M+1)/2$ lines describe the leaf nodes. Each line contains one value $I$, 0 or 1, the value of the leaf node.\n\nTo help visualize, here is a picture of the tree in the first sample input.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lid7b65w.png)", "outputFormat": "For each test case, you should output:\n\nCase #X: Y\n\nwhere $X$ is the number of the test case and $Y$ is the minimum number of gates that must be changed to make the output of the root node $V$, or \"IMPOSSIBLE\" (quotes for clarity) if this is impossible.\n", "hint": "**Sample Explanation**\n\nIn case 1, we can change the gate on node 3 to an OR gate to achieve the desired result at the root.\n\nIn case 2, only the root can be changed but changing it to an OR gate does not help.\n\n**Limits**\n\n- $1 < N \\leq 20$\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $2 < M < 30$\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $2 < M < 10000$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 #2] Cheating a Boolean Tree", "background": "", "description": "For this problem we will consider a type of binary tree that we will call a boolean tree. In this tree, every row is completely filled, except possibly the last (deepest) row, and the nodes in the last row are as far to the left as possible. Additionally, every node in the tree will either have 0 or 2 children.\n\nWhat makes a boolean tree special is that each node has a boolean value associated with it, $1$ or $0$. In addition, each interior node has either an \"AND\" or an \"OR\" gate associated with it. The value of an \"AND\" gate node is given by the logical AND of its two children's values. The value of an \"OR\" gate likewise is given by the logical OR of its two children's values. The value of all of the leaf nodes will be given as input so that the value of all nodes can be calculated up the tree.\n\nThe root of the tree is of particular interest to us. We would really like for the root to have the value $V$, either $1$ or $0$. Unfortunately, this may not be the value the root actually has. Luckily for us, we can cheat and change the type of gate for some of the nodes; we can change an AND gate to an OR gate or an OR gate to an AND gate.\n\nGiven a description of a boolean tree and what gates can be changed, find the minimum number of gates that need to be changed to make the value of the root node $V$. If this is impossible, output \"IMPOSSIBLE\" (quotes for clarity).\n", "inputFormat": "The first line of the input file contains the number of cases, $N$. $N$ test cases follow.\n\nEach case begins with $M$ and $V$. $M$ represents the number of nodes in the tree and will be odd to ensure all nodes have 0 or 2 children. $V$ is the desired value for the root node, 0 or 1.\n\n$M$ lines follow describing each of the tree's nodes. The $X^{th}$ line will describe node $X$, starting with node 1 on the first line.\n\nThe first $(M-1)/2$ lines describe the interior nodes. Each line contains $G$ and $C$, each being either 0 or 1. If $G$ is 1 then the gate for this node is an AND gate, otherwise it is an OR gate. If $C$ is 1 then the gate for this node is changeable, otherwise it is not. Interior node $X$ has nodes $2X$ and $2X+1$ as children.\n\nThe next $(M+1)/2$ lines describe the leaf nodes. Each line contains one value $I$, 0 or 1, the value of the leaf node.\n\nTo help visualize, here is a picture of the tree in the first sample input.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lid7b65w.png)", "outputFormat": "For each test case, you should output:\n\nCase #X: Y\n\nwhere $X$ is the number of the test case and $Y$ is the minimum number of gates that must be changed to make the output of the root node $V$, or \"IMPOSSIBLE\" (quotes for clarity) if this is impossible.\n", "hint": "**Sample Explanation**\n\nIn case 1, we can change the gate on node 3 to an OR gate to achieve the desired result at the root.\n\nIn case 2, only the root can be changed but changing it to an OR gate does not help.\n\n**Limits**\n\n- $1 < N \\leq 20$\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $2 < M < 30$\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $2 < M < 10000$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 #2] Cheating a Boolean Tree", "background": null, "description": "在本题中，我们将考虑一种称为布尔树的二叉树。在这种树中，除了最后（最深）一层外，每一层都被完全填满，并且最后一层的节点尽可能靠左。此外，树中的每个节点要么有 $0$ 个子节点，要么有 $2$ 个子节点。\n\n布尔树的特殊之处在于，每个节点都与一个布尔值相关联，取 $1$ 或 $0$。此外，每个内部节点都与一个“AND”或“OR”门相关联。一个“AND”门节点的值由其两个子节点的值进行逻辑与运算得到。同理，“OR”门节点的值由其两个子节点的值进行逻辑或运算得到。所有叶子节点的值将作为输入给出，因此可以自底向上计算所有节点的值。\n\n我们特别关注树的根节点。我们希望根节点的值为 $V$，即 $1$ 或 $0$。不幸的是，根节点的实际值可能并非如此。幸运的是，我们可以作弊，将某些节点的门类型进行更改；即可以将 AND 门改为 OR 门，或将 OR 门改为 AND 门。\n\n给定一个布尔树的描述以及哪些门可以更改，求最少需要更改多少个门，才能使根节点的值为 $V$。如果无法实现，则输出 \"IMPOSSIBLE\"（带引号，仅为清晰起见）。", "inputFormat": "输入的第一行包含测试用例数 $N$。接下来有 $N$ 个测试用例。\n\n每个测试用例以 $M$ 和 $V$ 开头。$M$ 表示树中节点的数量，且 $M$ 为奇数，以确保所有节点要么有 $0$ 个子节点，要么有 $2$ 个子节点。$V$ 是根节点期望的值，取 $0$ 或 $1$。\n\n接下来的 $M$ 行描述树中每个节点。第 $X$ 行描述编号为 $X$ 的节点，节点编号从 $1$ 开始。\n\n前 $(M-1)/2$ 行描述内部节点。每行包含 $G$ 和 $C$，均为 $0$ 或 $1$。若 $G$ 为 $1$，则该节点为 AND 门，否则为 OR 门。若 $C$ 为 $1$，则该门类型可以更改，否则不可更改。内部节点 $X$ 的两个子节点分别为 $2X$ 和 $2X+1$。\n\n接下来的 $(M+1)/2$ 行描述叶子节点。每行包含一个值 $I$，为 $0$ 或 $1$，表示该叶子节点的值。\n\n为帮助理解，以下是第一个样例输入对应的树结构图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lid7b65w.png)", "outputFormat": "对于每个测试用例，输出：\n\nCase #X: Y\n\n其中 $X$ 是测试用例编号，$Y$ 是使根节点输出为 $V$ 所需更改门的最小次数；如果无法实现，则输出 \"IMPOSSIBLE\"（带引号，仅为清晰起见）。", "hint": "**样例说明**\n\n在第 1 个测试用例中，我们可以将节点 3 的门更改为 OR 门，从而使根节点达到期望的结果。\n\n在第 2 个测试用例中，只有根节点可以更改，但将其改为 OR 门也无法实现目标。\n\n**数据范围**\n\n- $1 < N \\leq 20$\n\n**小数据集（5 分，测试点 1 - 可见）**\n\n- $2 < M < 30$\n\n**大数据集（10 分，测试点 2 - 隐藏）**\n\n- $2 < M < 10000$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13467", "type": "P", "difficulty": 4, "samples": [["3\n1 1 1\n1 2 64\n10 10 1", "Case #1: 0 0 0 1 1 1\nCase #2: IMPOSSIBLE\nCase #3: 1 1 2 3 5 8"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["数学", "计算几何", "2008", "Special Judge", "Google Code Jam"], "title": "[GCJ 2008 #2] Triangle Areas", "background": "", "description": "Ten-year-old Tangor has just discovered how to compute the area of a triangle. Being a bright boy, he is amazed by how many different ways one can compute the area. He also convinced himself that, if all the points of the triangle have integer coordinates, then the triangle's area is always either an integer or half of an integer! Isn't that nice?\n\nBut today Tangor is trying to go in the opposite direction. Instead of taking a triangle and computing its area, he is taking an integer $A$ and trying to draw a triangle of area $A/2$. He restricts himself to using only the integer points on his graph paper for the triangle's vertices.\n\nMore precisely, the sheet of graph paper is divided into an $N$ by $M$ grid of square cells. The triangle's vertices may only be placed in the corners of those cells. If you imagine a coordinate system on the paper, then these points are of the form $(x, y)$, where $x$ and $y$ are integers such that $0 \\leq x \\leq N$ and $0 \\leq y \\leq M$.\n\nGiven the integer $A$, help Tangor find three integer points on the sheet of graph paper such that the area of the triangle formed by those points is exactly $A/2$, if that is possible. In case there is more than one way to do this, any solution will make him happy.\n", "inputFormat": "One line containing an integer $C$, the number of test cases in the input file.\n\nThe next $C$ lines will each contain three integers $N$, $M$, and $A$, as described above.\n", "outputFormat": "For each test case, output one line. If there is no way to satisfy the condition, output\n\nCase #k: IMPOSSIBLE\n\nwhere $k$ is the case number, starting from 1. Otherwise, output\n\nCase #k: $x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$\n\nwhere $k$ is the case number and $(x_1, y_1)$, $(x_2, y_2)$, $(x_3, y_3)$ are any three integer points on the graph paper that form a triangle of area $A/2$.", "hint": "**Limits**\n\n- $0 \\leq C \\leq 1000$\n- $1 \\leq A \\leq 10^8$\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 50$\n- $1 \\leq M \\leq 50$\n\n**Large dataset (15 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 10000$\n- $1 \\leq M \\leq 10000$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 #2] Triangle Areas", "background": "", "description": "Ten-year-old Tangor has just discovered how to compute the area of a triangle. Being a bright boy, he is amazed by how many different ways one can compute the area. He also convinced himself that, if all the points of the triangle have integer coordinates, then the triangle's area is always either an integer or half of an integer! Isn't that nice?\n\nBut today Tangor is trying to go in the opposite direction. Instead of taking a triangle and computing its area, he is taking an integer $A$ and trying to draw a triangle of area $A/2$. He restricts himself to using only the integer points on his graph paper for the triangle's vertices.\n\nMore precisely, the sheet of graph paper is divided into an $N$ by $M$ grid of square cells. The triangle's vertices may only be placed in the corners of those cells. If you imagine a coordinate system on the paper, then these points are of the form $(x, y)$, where $x$ and $y$ are integers such that $0 \\leq x \\leq N$ and $0 \\leq y \\leq M$.\n\nGiven the integer $A$, help Tangor find three integer points on the sheet of graph paper such that the area of the triangle formed by those points is exactly $A/2$, if that is possible. In case there is more than one way to do this, any solution will make him happy.\n", "inputFormat": "One line containing an integer $C$, the number of test cases in the input file.\n\nThe next $C$ lines will each contain three integers $N$, $M$, and $A$, as described above.\n", "outputFormat": "For each test case, output one line. If there is no way to satisfy the condition, output\n\nCase #k: IMPOSSIBLE\n\nwhere $k$ is the case number, starting from 1. Otherwise, output\n\nCase #k: $x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$\n\nwhere $k$ is the case number and $(x_1, y_1)$, $(x_2, y_2)$, $(x_3, y_3)$ are any three integer points on the graph paper that form a triangle of area $A/2$.", "hint": "**Limits**\n\n- $0 \\leq C \\leq 1000$\n- $1 \\leq A \\leq 10^8$\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 50$\n- $1 \\leq M \\leq 50$\n\n**Large dataset (15 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 10000$\n- $1 \\leq M \\leq 10000$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 #2] Triangle Areas", "background": null, "description": "十岁的 Tangor 刚刚学会了如何计算三角形的面积。作为一个聪明的孩子，他对计算面积的多种方法感到惊奇。他还确信，如果三角形的所有顶点坐标都是整数，那么三角形的面积总是整数或半整数！这不是很神奇吗？\n\n但今天 Tangor 想要反过来。他不是给定一个三角形去计算面积，而是给定一个整数 $A$，试图画出一个面积为 $A/2$ 的三角形。他只允许使用方格纸上的整数点作为三角形的顶点。\n\n更具体地说，这张方格纸被划分为 $N$ 行 $M$ 列的正方形格子。三角形的顶点只能放在这些格子的角上。如果你在纸上建立一个坐标系，这些点的形式为 $(x, y)$，其中 $x$ 和 $y$ 是整数，满足 $0 \\leq x \\leq N$ 且 $0 \\leq y \\leq M$。\n\n给定整数 $A$，请你帮助 Tangor 找到方格纸上的三个整数点，使得它们组成的三角形面积恰好为 $A/2$，如果可能的话。如果有多种方案，任意一种都可以让他高兴。", "inputFormat": "第一行包含一个整数 $C$，表示输入文件中的测试用例数。\n\n接下来的 $C$ 行，每行包含三个整数 $N$、$M$ 和 $A$，如上所述。", "outputFormat": "对于每个测试用例，输出一行。如果无法满足条件，输出\n\nCase #k: IMPOSSIBLE\n\n其中 $k$ 是测试用例编号，从 1 开始。否则，输出\n\nCase #k: $x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$\n\n其中 $k$ 是测试用例编号，$(x_1, y_1)$、$(x_2, y_2)$、$(x_3, y_3)$ 是任意三个在方格纸上的整数点，且它们组成的三角形面积恰好为 $A/2$。", "hint": "**数据范围**\n\n- $0 \\leq C \\leq 1000$\n- $1 \\leq A \\leq 10^8$\n\n**小数据集（5 分，测试点 1 - 可见）**\n\n- $1 \\leq N \\leq 50$\n- $1 \\leq M \\leq 50$\n\n**大数据集（15 分，测试点 2 - 隐藏）**\n\n- $1 \\leq N \\leq 10000$\n- $1 \\leq M \\leq 10000$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13468", "type": "P", "difficulty": 4, "samples": [["3\n4\n0 0 0 1\n1 2 0 1\n3 4 0 1\n2 1 0 1\n1\n1 1 1 1\n3\n1 0 0 1\n2 1 1 4\n3 2 3 2", "Case #1: 3.50000000\nCase #2: 0.00000000\nCase #3: 2.33333333"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["数学", "2008", "Special Judge", "线性规划", "Google Code Jam"], "title": "[GCJ 2008 #2] Star Wars", "background": "", "description": "Near the planet Mars, in a faraway galaxy eerily similar to our own, there is a fight to the death between the imperial forces and the rebels. The rebel army has $N$ ships which we will consider as points $(x_i, y_i, z_i)$. Each ship has a receiver with power $p_i$. The rebel army needs to be able to send messages from the central cruiser to all the ships, but they are tight on finances, so they cannot afford a strong transmitter.\n\nIf the cruiser is placed at $(x, y, z)$, and one of the other ships is at $(x_i, y_i, z_i)$ and has a receiver of power $p_i$, then the power of the cruiser's transmitter needs to be at least:\n\n$(|x_i - x| + |y_i - y| + |z_i - z|) / p_i$\n\nYour task is to find the position for the cruiser that minimizes the power required for its transmitter, and to output that power.\n", "inputFormat": "The first line of input gives the number of cases, $T$. $T$ test cases follow.\n\nEach test case contains on the first line the integer $N$, the number of ships in the test case.\n\n$N$ lines follow, each line containing four integer numbers $x_i$, $y_i$, $z_i$ and $p_i$, separated by single spaces. These are the coordinates of the $i$-th ship, and the power of its receiver. There may be more than one ship at the same coordinates.\n", "outputFormat": "For each input case, you should output:\n\nCase #X: Y\n\nwhere $X$ is the number of the test case and $Y$ is the minimal power that is enough to reach all the fleet's ships. Answers with a relative or absolute error of at most $10^{-6}$ will be considered correct.", "hint": "**Sample Explanation**\n\nIn the first test case, the four ships have coordinates $(0, 0, 0), (1, 2, 0), (3, 4, 0), (2, 1, 0)$ and powers $1, 1, 1, 1$ respectively. We can place a cruiser with the power $3.5$ at the coordinates $(1.5, 2, 0)$ which will be able to reach all the ships.\n\nIn the second case we can place the cruiser right on top of the ship, with transmitter power 0.\n\n**Sample Explanation**\n\n- $1 \\leq T \\leq 10$\n- $0 \\leq x_i, y_i, z_i \\leq 10^6$\n- $1 \\leq p_i \\leq 10^6$\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 10$\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 1000$", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 #2] Star Wars", "background": "", "description": "Near the planet Mars, in a faraway galaxy eerily similar to our own, there is a fight to the death between the imperial forces and the rebels. The rebel army has $N$ ships which we will consider as points $(x_i, y_i, z_i)$. Each ship has a receiver with power $p_i$. The rebel army needs to be able to send messages from the central cruiser to all the ships, but they are tight on finances, so they cannot afford a strong transmitter.\n\nIf the cruiser is placed at $(x, y, z)$, and one of the other ships is at $(x_i, y_i, z_i)$ and has a receiver of power $p_i$, then the power of the cruiser's transmitter needs to be at least:\n\n$(|x_i - x| + |y_i - y| + |z_i - z|) / p_i$\n\nYour task is to find the position for the cruiser that minimizes the power required for its transmitter, and to output that power.\n", "inputFormat": "The first line of input gives the number of cases, $T$. $T$ test cases follow.\n\nEach test case contains on the first line the integer $N$, the number of ships in the test case.\n\n$N$ lines follow, each line containing four integer numbers $x_i$, $y_i$, $z_i$ and $p_i$, separated by single spaces. These are the coordinates of the $i$-th ship, and the power of its receiver. There may be more than one ship at the same coordinates.\n", "outputFormat": "For each input case, you should output:\n\nCase #X: Y\n\nwhere $X$ is the number of the test case and $Y$ is the minimal power that is enough to reach all the fleet's ships. Answers with a relative or absolute error of at most $10^{-6}$ will be considered correct.", "hint": "**Sample Explanation**\n\nIn the first test case, the four ships have coordinates $(0, 0, 0), (1, 2, 0), (3, 4, 0), (2, 1, 0)$ and powers $1, 1, 1, 1$ respectively. We can place a cruiser with the power $3.5$ at the coordinates $(1.5, 2, 0)$ which will be able to reach all the ships.\n\nIn the second case we can place the cruiser right on top of the ship, with transmitter power 0.\n\n**Sample Explanation**\n\n- $1 \\leq T \\leq 10$\n- $0 \\leq x_i, y_i, z_i \\leq 10^6$\n- $1 \\leq p_i \\leq 10^6$\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 10$\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 1000$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 #2] Star Wars", "background": null, "description": "在遥远的银河系中，火星附近正爆发着帝国军与反叛军之间的殊死战斗。反叛军拥有 $N$ 艘飞船，我们将每艘飞船视为一个点 $(x_i, y_i, z_i)$。每艘飞船都配备了接收器，其接收功率为 $p_i$。反叛军需要能够从中央巡洋舰向所有飞船发送消息，但由于经费紧张，他们无法负担高功率的发射器。\n\n如果巡洋舰被放置在 $(x, y, z)$，而另一艘飞船位于 $(x_i, y_i, z_i)$，其接收功率为 $p_i$，那么巡洋舰的发射器功率至少需要为：\n\n$$(|x_i - x| + |y_i - y| + |z_i - z|) / p_i$$\n\n你的任务是找到一个巡洋舰的位置，使得所需的发射器功率最小，并输出该最小功率。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。\n\n每组测试数据的第一行为整数 $N$，表示该组中飞船的数量。\n\n接下来的 $N$ 行，每行包含四个整数 $x_i, y_i, z_i, p_i$，用空格分隔，分别表示第 $i$ 艘飞船的坐标和接收功率。可能有多艘飞船位于相同坐标。", "outputFormat": "对于每组输入数据，输出一行：\n\nCase #X: Y\n\n其中 $X$ 表示测试用例编号，$Y$ 表示能够覆盖所有飞船的最小发射功率。若答案的相对或绝对误差不超过 $10^{-6}$，则视为正确。", "hint": "**样例解释**\n\n在第一个测试用例中，四艘飞船的坐标分别为 $(0, 0, 0), (1, 2, 0), (3, 4, 0), (2, 1, 0)$，接收功率均为 $1$。我们可以将巡洋舰放在 $(1.5, 2, 0)$，此时所需发射功率为 $3.5$，能够覆盖所有飞船。\n\n在第二个测试用例中，我们可以将巡洋舰直接放在飞船上，所需发射功率为 $0$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 10$\n- $0 \\leq x_i, y_i, z_i \\leq 10^6$\n- $1 \\leq p_i \\leq 10^6$\n\n**小数据范围（10 分，测试点 1 - 可见）**\n\n- $1 \\leq N \\leq 10$\n\n**大数据范围（20 分，测试点 2 - 隐藏）**\n\n- $1 \\leq N \\leq 1000$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13469", "type": "P", "difficulty": 5, "samples": [["2\n4\nabcabcabcabc\n3\nabcabcabcabc", "Case #1: 7\nCase #2: 12"]], "limits": {"time": [10000, 10000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2008", "状压 DP", "Google Code Jam"], "title": "[GCJ 2008 #2] PermRLE", "background": "", "description": "You've invented a slight modification of the run-length encoding (RLE) compression algorithm, called PermRLE.\n\nTo compress a string, this algorithm chooses some permutation of integers between $1$ and $k$, applies this permutation to the first $k$ letters of the given string, then to the next block of $k$ letters, and so on. The length of the string must be divisible by $k$. After permuting all blocks, the new string is compressed using RLE, which is described later.\n\nTo apply the given permutation $p$ to a block of $k$ letters means to place the $p[1]$-th of these letters in the first position, then $p[2]$-th of these letters in the second position, and so on. For example, applying the permutation $\\{3,1,4,2\\}$ to the block \"abcd\" yields \"cadb\". Applying it to the longer string \"abcdefghij\" in blocks yields \"cadbgehfik\".\n\nThe permuted string is then compressed using run-length encoding. To simplify, we will consider the compressed size of the string to be the number of groups of consecutive equal letters. For example, the compressed size of \"aabcaaaa\" is $4$; the first of the four groups is a group of two letters \"a\", then two groups \"b\" and \"c\" each containing only one letter, and finally a longer group of letters \"a\".\n\nObviously, the compressed size may depend on the chosen permutation. Since the goal of compression algorithms is to minimize the size of the compressed text, it is your job to choose the permutation that yields the smallest possible compressed size, and output that size.", "inputFormat": "The first line of input gives the number of cases, $N$. $N$ test cases follow.\n\nThe first line of each case will contain $k$. The second line will contain $S$, the string to be compressed.\n", "outputFormat": "For each test case you should output one line containing \"Case #X: Y\" (quotes for clarity) where $X$ is the number of the test case and $Y$ is the minimum compressed size of $S$.", "hint": "**Limits**\n\n- $N = 20$\n- $S$ will contain only lowercase letters 'a' through 'z'\n- The length of $S$ will be divisible by $k$\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $2 \\leq k \\leq 5$\n- $1 \\leq \\text{length of } S \\leq 1000$\n\n**Large dataset (30 Pts, Test set 2 - Hidden)**\n\n- $2 \\leq k \\leq 16$\n- $1 \\leq \\text{length of } S \\leq 50000$", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 #2] PermRLE", "background": "", "description": "You've invented a slight modification of the run-length encoding (RLE) compression algorithm, called PermRLE.\n\nTo compress a string, this algorithm chooses some permutation of integers between $1$ and $k$, applies this permutation to the first $k$ letters of the given string, then to the next block of $k$ letters, and so on. The length of the string must be divisible by $k$. After permuting all blocks, the new string is compressed using RLE, which is described later.\n\nTo apply the given permutation $p$ to a block of $k$ letters means to place the $p[1]$-th of these letters in the first position, then $p[2]$-th of these letters in the second position, and so on. For example, applying the permutation $\\{3,1,4,2\\}$ to the block \"abcd\" yields \"cadb\". Applying it to the longer string \"abcdefghij\" in blocks yields \"cadbgehfik\".\n\nThe permuted string is then compressed using run-length encoding. To simplify, we will consider the compressed size of the string to be the number of groups of consecutive equal letters. For example, the compressed size of \"aabcaaaa\" is $4$; the first of the four groups is a group of two letters \"a\", then two groups \"b\" and \"c\" each containing only one letter, and finally a longer group of letters \"a\".\n\nObviously, the compressed size may depend on the chosen permutation. Since the goal of compression algorithms is to minimize the size of the compressed text, it is your job to choose the permutation that yields the smallest possible compressed size, and output that size.", "inputFormat": "The first line of input gives the number of cases, $N$. $N$ test cases follow.\n\nThe first line of each case will contain $k$. The second line will contain $S$, the string to be compressed.\n", "outputFormat": "For each test case you should output one line containing \"Case #X: Y\" (quotes for clarity) where $X$ is the number of the test case and $Y$ is the minimum compressed size of $S$.", "hint": "**Limits**\n\n- $N = 20$\n- $S$ will contain only lowercase letters 'a' through 'z'\n- The length of $S$ will be divisible by $k$\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $2 \\leq k \\leq 5$\n- $1 \\leq \\text{length of } S \\leq 1000$\n\n**Large dataset (30 Pts, Test set 2 - Hidden)**\n\n- $2 \\leq k \\leq 16$\n- $1 \\leq \\text{length of } S \\leq 50000$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 #2] PermRLE", "background": null, "description": "你发明了一种对游程编码（RLE）压缩算法的轻微修改，称为 PermRLE。\n\n为了压缩一个字符串，该算法选择 $1$ 到 $k$ 之间整数的某个排列，将该排列应用到给定字符串的前 $k$ 个字母，然后应用到接下来的 $k$ 个字母的块，依此类推。字符串的长度必须能被 $k$ 整除。在对所有块进行排列后，新的字符串将使用 RLE 进行压缩，RLE 的描述见下文。\n\n将给定的排列 $p$ 应用于一个 $k$ 个字母的块，意味着将这些字母中的第 $p[1]$ 个放在第一个位置，第 $p[2]$ 个放在第二个位置，依此类推。例如，将排列 $\\{3,1,4,2\\}$ 应用于块 \"abcd\"，得到 \"cadb\"。将其应用于更长的字符串 \"abcdefghij\" 的各个块，得到 \"cadbgehfik\"。\n\n排列后的字符串随后使用游程编码进行压缩。为简化起见，我们将字符串的压缩大小定义为连续相同字母分组的数量。例如，\"aabcaaaa\" 的压缩大小为 $4$；四个分组分别是两个字母 \"a\" 的一组，然后 \"b\" 和 \"c\" 各自为一组，最后是一组较长的 \"a\"。\n\n显然，压缩大小可能取决于所选择的排列。由于压缩算法的目标是最小化压缩文本的大小，你的任务是选择能得到最小压缩大小的排列，并输出该最小值。", "inputFormat": "第一行输入一个整数 $N$，表示测试用例的数量。接下来有 $N$ 组测试用例。\n\n每组测试用例的第一行包含一个整数 $k$。第二行包含要压缩的字符串 $S$。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #X: Y\"，其中 $X$ 是测试用例编号，$Y$ 是 $S$ 的最小压缩大小。", "hint": "**限制条件**\n\n- $N = 20$\n- $S$ 只包含小写字母 'a' 到 'z'\n- $S$ 的长度能被 $k$ 整除\n\n**小数据范围（5 分，测试集 1 - 可见）**\n\n- $2 \\leq k \\leq 5$\n- $1 \\leq S$ 的长度 $\\leq 1000$\n\n**大数据范围（30 分，测试集 2 - 隐藏）**\n\n- $2 \\leq k \\leq 16$\n- $1 \\leq S$ 的长度 $\\leq 50000$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13470", "type": "P", "difficulty": 5, "samples": [["2\n1\nFFFR 4\n9\nF 6 R 1 F 4 RFF 2 LFF 1\nLFFFR 1 F 2 R 1 F 5", "Case #1: 0\nCase #2: 4"]], "limits": {"time": [12000, 12000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2008", "Google Code Jam"], "title": "[GCJ 2008 #3] How Big Are the Pockets?", "background": "", "description": "Professor Polygonovich, an honest citizen of Flatland, likes to take random walks along integer points in the plane. He starts from the origin in the morning, facing north. There are three types of actions he makes:\n\n- 'F': move forward one unit of length.\n- 'L': turn left 90 degrees.\n- 'R': turn right 90 degrees.\n\nAt the end of the day (yes, it is a long walk!), he returns to the origin. He never visits the same point twice except for the origin, so his path encloses a polygon. In the following picture the interior of the polygon is colored blue (ignore the points $x$, $y$, $z$, and $w$ for now; they will be explained soon):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/w7kjurb8.png)\n\nNotice that as long as Professor Polygonovich makes more than $4$ turns, the polygon is not convex. So there are pockets in it.\n\n**Warning!** To make your task more difficult, our definition of pockets might be different from what you may have heard before.\n\nThe gray area below indicates pockets of the polygon.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5yr728ir.png)\n\nFormally, a point $p$ is said to be in a pocket if it is not inside the polygon, and at least one of the following two conditions holds.\n\n- There are boundary points directly both east and west of $p$; or\n- There are boundary points directly both north and south of $p$.\n\nBoundary points are the points traversed by Mr. Poligonovich on his walk (these include all points, not just those with integer coordinates).\n\nConsider again the first picture from above. Point $x$ satisfies the first condition; $y$ satisfies both; $z$ satisfies the second one. All three points are in pockets. The point $w$ is not in a pocket.\n\nGiven Polygonovich's walk, your job is to find the total area of the pockets.\n", "inputFormat": "The first line of input gives the number of cases, $N$. $N$ test cases follow.\n\nEach test case has the description of one walk of Professor Polygonovich. It starts with an integer $L$. Following are $L$ \"S T\" pairs, where $S$ is a string consisting of 'L', 'R', and 'F' characters, and $T$ is an integer indicating how many times $S$ is repeated.\n\nIn other words, the input for one test case looks like this:\n$S_1$ $T_1$ $S_2$ $T_2$ ... $S_L$ $T_L$\n\nThe actions taken are the concatenation of $T_1$ copies of $S_1$, followed by $T_2$ copies of $S_2$, and so on.\n\nThe \"S T\" pairs for a single test case may not all be on the same line, but the strings $S$ will not be split across multiple lines. The second example below demonstrates this.\n", "outputFormat": "For each test case, output one line containing \"Case #$X$: $Y$\", where $X$ is the 1-based case number, and $Y$ is the total area of all pockets.", "hint": "**Sample Explanation**\n\nThe following picture illustrates the two sample test cases. \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x4te7gae.png)\n\n**Limits**\n\n- $1 \\leqslant N \\leqslant 100$\n- $1 \\leqslant T$ (bounded from above by constraints in the problem statement, \"Small dataset\" and \"Large dataset\" sections)\n- The path, when concatenated from the input strings, will not have two consecutive direction changes (that is, there will be no 'LL', 'RR', 'LR', nor 'RL' in the concatenated path). There will be at least one 'F' in the path.\n- The path described will not intersect itself, except at the end, and it will end back at the origin.\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leqslant L \\leqslant 100$\n- The length of each string $S$ will be between 1 and 16, inclusive.\n- The professor will not visit any point with a coordinate bigger than 100 in absolute value.\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $1 \\leqslant L \\leqslant 1000$\n- The length of each string $S$ will be between 1 and 32, inclusive.\n- The professor will not visit any point with a coordinate bigger than 3000 in absolute value.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 #3] How Big Are the Pockets?", "background": "", "description": "Professor Polygonovich, an honest citizen of Flatland, likes to take random walks along integer points in the plane. He starts from the origin in the morning, facing north. There are three types of actions he makes:\n\n- 'F': move forward one unit of length.\n- 'L': turn left 90 degrees.\n- 'R': turn right 90 degrees.\n\nAt the end of the day (yes, it is a long walk!), he returns to the origin. He never visits the same point twice except for the origin, so his path encloses a polygon. In the following picture the interior of the polygon is colored blue (ignore the points $x$, $y$, $z$, and $w$ for now; they will be explained soon):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/w7kjurb8.png)\n\nNotice that as long as Professor Polygonovich makes more than $4$ turns, the polygon is not convex. So there are pockets in it.\n\n**Warning!** To make your task more difficult, our definition of pockets might be different from what you may have heard before.\n\nThe gray area below indicates pockets of the polygon.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5yr728ir.png)\n\nFormally, a point $p$ is said to be in a pocket if it is not inside the polygon, and at least one of the following two conditions holds.\n\n- There are boundary points directly both east and west of $p$; or\n- There are boundary points directly both north and south of $p$.\n\nBoundary points are the points traversed by Mr. Poligonovich on his walk (these include all points, not just those with integer coordinates).\n\nConsider again the first picture from above. Point $x$ satisfies the first condition; $y$ satisfies both; $z$ satisfies the second one. All three points are in pockets. The point $w$ is not in a pocket.\n\nGiven Polygonovich's walk, your job is to find the total area of the pockets.\n", "inputFormat": "The first line of input gives the number of cases, $N$. $N$ test cases follow.\n\nEach test case has the description of one walk of Professor Polygonovich. It starts with an integer $L$. Following are $L$ \"S T\" pairs, where $S$ is a string consisting of 'L', 'R', and 'F' characters, and $T$ is an integer indicating how many times $S$ is repeated.\n\nIn other words, the input for one test case looks like this:\n$S_1$ $T_1$ $S_2$ $T_2$ ... $S_L$ $T_L$\n\nThe actions taken are the concatenation of $T_1$ copies of $S_1$, followed by $T_2$ copies of $S_2$, and so on.\n\nThe \"S T\" pairs for a single test case may not all be on the same line, but the strings $S$ will not be split across multiple lines. The second example below demonstrates this.\n", "outputFormat": "For each test case, output one line containing \"Case #$X$: $Y$\", where $X$ is the 1-based case number, and $Y$ is the total area of all pockets.", "hint": "**Sample Explanation**\n\nThe following picture illustrates the two sample test cases. \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x4te7gae.png)\n\n**Limits**\n\n- $1 \\leqslant N \\leqslant 100$\n- $1 \\leqslant T$ (bounded from above by constraints in the problem statement, \"Small dataset\" and \"Large dataset\" sections)\n- The path, when concatenated from the input strings, will not have two consecutive direction changes (that is, there will be no 'LL', 'RR', 'LR', nor 'RL' in the concatenated path). There will be at least one 'F' in the path.\n- The path described will not intersect itself, except at the end, and it will end back at the origin.\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leqslant L \\leqslant 100$\n- The length of each string $S$ will be between 1 and 16, inclusive.\n- The professor will not visit any point with a coordinate bigger than 100 in absolute value.\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $1 \\leqslant L \\leqslant 1000$\n- The length of each string $S$ will be between 1 and 32, inclusive.\n- The professor will not visit any point with a coordinate bigger than 3000 in absolute value.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 #3] How Big Are the Pockets?", "background": null, "description": "Polygonovich 教授是 Flatland 的一位诚实市民，他喜欢在平面上的整数点之间进行随机行走。他每天早晨从原点出发，面朝北方。他有三种行动方式：\n\n- 'F'：向前移动一个单位长度。\n- 'L'：向左转 $90$ 度。\n- 'R'：向右转 $90$ 度。\n\n一天结束时（是的，他走了很久！），他会回到原点。他在行走过程中，除了原点外，绝不会两次经过同一个点，因此他的路径围成了一个多边形。下图中，多边形的内部被涂成了蓝色（暂时忽略 $x$、$y$、$z$ 和 $w$ 这几个点，稍后会解释）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/w7kjurb8.png)\n\n注意，只要 Polygonovich 教授转弯次数超过 $4$ 次，这个多边形就不是凸多边形，因此会出现“口袋”区域。\n\n**注意！** 为了增加难度，我们对“口袋”的定义可能与你以往听说的不同。\n\n下图中灰色区域表示多边形的口袋。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5yr728ir.png)\n\n形式化地说，一个点 $p$ 被认为在口袋中，当且仅当它不在多边形内部，并且满足以下两个条件之一：\n\n- $p$ 的正东和正西方向上都存在边界点；或者\n- $p$ 的正北和正南方向上都存在边界点。\n\n边界点指的是 Polygonovich 先生在行走过程中经过的所有点（包括所有点，不仅限于整数坐标点）。\n\n再看上面的第一张图。点 $x$ 满足第一个条件；$y$ 同时满足两个条件；$z$ 满足第二个条件。这三个点都在口袋中。点 $w$ 不在口袋中。\n\n给定 Polygonovich 教授的行走路径，请你计算所有口袋区域的总面积。", "inputFormat": "输入的第一行是测试用例数 $N$。接下来有 $N$ 组测试数据。\n\n每组测试数据描述了 Polygonovich 教授的一次行走。每组数据以一个整数 $L$ 开头。接下来是 $L$ 个 \"S T\" 对，其中 $S$ 是仅由 'L'、'R'、'F' 组成的字符串，$T$ 是一个整数，表示 $S$ 重复的次数。\n\n换句话说，每组测试数据的输入格式如下：\n$S_1$ $T_1$ $S_2$ $T_2$ ... $S_L$ $T_L$\n\n实际的行动序列是 $T_1$ 个 $S_1$，接着 $T_2$ 个 $S_2$，依此类推，拼接而成。\n\n同一组测试数据中的 \"S T\" 对可能不会全部在同一行，但字符串 $S$ 不会被拆分到多行。下面的第二个样例演示了这一点。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #$X$: $Y$\"，其中 $X$ 是测试用例编号（从 $1$ 开始），$Y$ 是所有口袋区域的总面积。", "hint": "**样例解释**\n\n下图展示了两个样例测试数据的情况。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x4te7gae.png)\n\n**数据范围**\n\n- $1 \\leqslant N \\leqslant 100$\n- $1 \\leqslant T$（上界见下述“小数据集”和“大数据集”说明）\n- 输入拼接后的路径中不会出现连续的方向变化（即不会有 'LL'、'RR'、'LR' 或 'RL'），并且路径中至少包含一个 'F'。\n- 路径不会自交，除了起点和终点重合，并且最终会回到原点。\n\n**小数据集（5 分，测试点 1 - 可见）**\n\n- $1 \\leqslant L \\leqslant 100$\n- 每个字符串 $S$ 的长度为 $1$ 到 $16$。\n- 教授不会经过绝对值大于 $100$ 的点。\n\n**大数据集（10 分，测试点 2 - 隐藏）**\n\n- $1 \\leqslant L \\leqslant 1000$\n- 每个字符串 $S$ 的长度为 $1$ 到 $32$。\n- 教授不会经过绝对值大于 $3000$ 的点。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13471", "type": "P", "difficulty": 5, "samples": [["3\n4 7\n.O..##.\n.#.....\n.#.####\n.#...X.\n5 5\nO....\n.....\n.....\n.....\n....X\n1 3\nO#X", "Case #1: 4\nCase #2: 2\nCase #3: THE CAKE IS A LIE"]], "limits": {"time": [6000, 6000], "memory": [1048576, 1048576]}, "tags": ["2008", "广度优先搜索 BFS", "最短路", "Google Code Jam"], "title": "[GCJ 2008 #3] Portal", "background": "", "description": "Portal$^{\\text{TM}}$ is a first-person puzzle/platform game developed and published by Valve Software. The idea of the game was to create two portals on walls and then jump through one portal and come out the other. This problem has a similar idea but it does not assume you have played Portal.\n\nFor this problem you find yourself in a $R$ by $C$ grid. Additionally there is a delicious cake somewhere else in the grid. You're very hungry and wish to arrive at the cake with as few moves as possible. You can move north, south, east or west to an empty cell. Additionally, you have the ability to create portals on walls.\n\nTo help you get to the cake you have a portal gun which can shoot two types of portals, a yellow portal and a blue portal. A portal is created by shooting your portal gun either north, south, east or west. This emits a ball of energy that creates a portal on the first wall it hits. Note that for this problem shooting the portal gun does not count as a move. If you fire your portal gun at the cake, the energy ball will go right through it.\n\nAfter creating a yellow portal and a blue portal, you can move through the yellow portal to arrive at the blue portal or vice versa. Using these portals you may be able to reach the cake even faster! You can only use portals after you create both a yellow and a blue portal.\n\nConsider the following grid:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tz8ceyn5.png)\n\nGray cells represent walls, white cells represent empty cells, and the red circle indicates your position.\n\nSuppose you shoot a blue portal east. The portal is created on the first wall it hits, resulting in:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rzvxatnz.png)\n\nNow suppose you shoot a yellow portal south:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b3pvr2mg.png)\n\nNext you move south once:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4ogui6pq.png)\n\nNow comes the interesting part. If you move south one more time you go through the yellow portal to the blue portal:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k1k8ybii.png)\n\nThere can only be one yellow portal and one blue portal at any time. For example if you attempt to create a blue portal to the west the other blue portal will disappear:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/u3zzj14r.png)\n\nA portal disappears only when another portal of the same color is fired.\n\nNote that the portals are created on one side of the wall. If a wall has a portal on its east side you must move into the wall from the east to go through the portal. Otherwise you'll be moving into a wall, which is improbable.\n\nFinally, you may not put two portals on top of each other. If you try to fire a portal at a side of a wall that already has a portal, the second portal will fail to form.\n\nGiven the maze, your initial position, and the cake's position, you want to find the minimum number of moves needed to reach the cake if it is possible. Remember that shooting the portal gun does not count as a move.", "inputFormat": "The first line of input gives the number of cases, $N$. $N$ test cases follow.\n\nThe first line of each test case will contain the integers $R$ and $C$ separated by a space. $R$ lines follow containing $C$ characters each, representing the map:\n\n* . indicates an empty cell;\n* \\# indicates a wall;\n* o indicates your starting position; and\n* x indicates the cake's position.\n\nThere will be exactly one o and one x character per case.\n\nCells outside of the grid are all walls and you may use them to create portals.", "outputFormat": "For each test case you should output one line containing \"Case #$X$: $Y$\" (quotes for clarity) where $X$ is the number of the test case and $Y$ is the minimum number of moves needed to reach the cake or \"THE CAKE IS A LIE\" (quotes for clarity) if the cake cannot be reached.", "hint": "**Sample Explanation**\n\nHere is the sequence of moves for the first case (note that shooting the portal gun does not count as a move):\n\n- Move one step east.\n- Shoot a blue portal north.\n- Shoot a yellow portal south.\n- Move one step north through the blue portal.\n- Shoot a blue portal east.\n- Move one step south through the yellow portal.\n- Move one step west.\n- Eat your delicious and moist cake.\n\nPortal$^{\\text{TM}}$ is a trademark of Valve Inc. Valve Inc. does not endorse and has no involvement with Google Code Jam.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $N=200$\n- $1 \\leqslant R, C \\leqslant 8$\n\n**Large dataset (15 Pts, Test set 2 - Hidden)**\n\n- $N=50$\n- $1 \\leqslant R, C \\leqslant 15$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 #3] Portal", "background": "", "description": "Portal$^{\\text{TM}}$ is a first-person puzzle/platform game developed and published by Valve Software. The idea of the game was to create two portals on walls and then jump through one portal and come out the other. This problem has a similar idea but it does not assume you have played Portal.\n\nFor this problem you find yourself in a $R$ by $C$ grid. Additionally there is a delicious cake somewhere else in the grid. You're very hungry and wish to arrive at the cake with as few moves as possible. You can move north, south, east or west to an empty cell. Additionally, you have the ability to create portals on walls.\n\nTo help you get to the cake you have a portal gun which can shoot two types of portals, a yellow portal and a blue portal. A portal is created by shooting your portal gun either north, south, east or west. This emits a ball of energy that creates a portal on the first wall it hits. Note that for this problem shooting the portal gun does not count as a move. If you fire your portal gun at the cake, the energy ball will go right through it.\n\nAfter creating a yellow portal and a blue portal, you can move through the yellow portal to arrive at the blue portal or vice versa. Using these portals you may be able to reach the cake even faster! You can only use portals after you create both a yellow and a blue portal.\n\nConsider the following grid:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tz8ceyn5.png)\n\nGray cells represent walls, white cells represent empty cells, and the red circle indicates your position.\n\nSuppose you shoot a blue portal east. The portal is created on the first wall it hits, resulting in:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rzvxatnz.png)\n\nNow suppose you shoot a yellow portal south:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b3pvr2mg.png)\n\nNext you move south once:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4ogui6pq.png)\n\nNow comes the interesting part. If you move south one more time you go through the yellow portal to the blue portal:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k1k8ybii.png)\n\nThere can only be one yellow portal and one blue portal at any time. For example if you attempt to create a blue portal to the west the other blue portal will disappear:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/u3zzj14r.png)\n\nA portal disappears only when another portal of the same color is fired.\n\nNote that the portals are created on one side of the wall. If a wall has a portal on its east side you must move into the wall from the east to go through the portal. Otherwise you'll be moving into a wall, which is improbable.\n\nFinally, you may not put two portals on top of each other. If you try to fire a portal at a side of a wall that already has a portal, the second portal will fail to form.\n\nGiven the maze, your initial position, and the cake's position, you want to find the minimum number of moves needed to reach the cake if it is possible. Remember that shooting the portal gun does not count as a move.", "inputFormat": "The first line of input gives the number of cases, $N$. $N$ test cases follow.\n\nThe first line of each test case will contain the integers $R$ and $C$ separated by a space. $R$ lines follow containing $C$ characters each, representing the map:\n\n* . indicates an empty cell;\n* \\# indicates a wall;\n* o indicates your starting position; and\n* x indicates the cake's position.\n\nThere will be exactly one o and one x character per case.\n\nCells outside of the grid are all walls and you may use them to create portals.", "outputFormat": "For each test case you should output one line containing \"Case #$X$: $Y$\" (quotes for clarity) where $X$ is the number of the test case and $Y$ is the minimum number of moves needed to reach the cake or \"THE CAKE IS A LIE\" (quotes for clarity) if the cake cannot be reached.", "hint": "**Sample Explanation**\n\nHere is the sequence of moves for the first case (note that shooting the portal gun does not count as a move):\n\n- Move one step east.\n- Shoot a blue portal north.\n- Shoot a yellow portal south.\n- Move one step north through the blue portal.\n- Shoot a blue portal east.\n- Move one step south through the yellow portal.\n- Move one step west.\n- Eat your delicious and moist cake.\n\nPortal$^{\\text{TM}}$ is a trademark of Valve Inc. Valve Inc. does not endorse and has no involvement with Google Code Jam.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $N=200$\n- $1 \\leqslant R, C \\leqslant 8$\n\n**Large dataset (15 Pts, Test set 2 - Hidden)**\n\n- $N=50$\n- $1 \\leqslant R, C \\leqslant 15$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 #3] Portal", "background": null, "description": "Portal$^{\\text{TM}}$ 是由 Valve Software 开发并发行的一款第一人称解谜/平台游戏。游戏的核心思想是在墙上创建两个传送门，然后通过一个传送门跳进去，从另一个传送门出来。本题与此类似，但不要求你玩过 Portal。\n\n在本题中，你处于一个 $R$ 行 $C$ 列的网格中。此外，网格的某处有一块美味的蛋糕。你非常饿，希望用尽量少的步数到达蛋糕。你可以向北、南、东或西移动到一个空单元格。此外，你还可以在墙上创建传送门。\n\n为了帮助你到达蛋糕，你有一把传送门枪，可以发射两种传送门：黄色传送门和蓝色传送门。通过向北、南、东或西方向射击传送门枪，可以发射能量球，在遇到的第一个墙上创建一个传送门。注意，在本题中，射击传送门枪不计为一次移动。如果你向蛋糕射击，能量球会直接穿过蛋糕。\n\n在创建了一个黄色传送门和一个蓝色传送门后，你可以通过黄色传送门到达蓝色传送门，反之亦然。利用这些传送门，你也许能更快地到达蛋糕！只有在你创建了一个黄色和一个蓝色传送门后，才能使用传送门。\n\n请参考下图的网格：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tz8ceyn5.png)\n\n灰色格子表示墙，白色格子表示空单元格，红色圆圈表示你的位置。\n\n假设你向东射击蓝色传送门。传送门会出现在能量球遇到的第一个墙上，如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rzvxatnz.png)\n\n现在假设你向南射击黄色传送门：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b3pvr2mg.png)\n\n接下来你向南移动一步：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4ogui6pq.png)\n\n有趣的部分来了。如果你再向南移动一步，你会通过黄色传送门到达蓝色传送门：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k1k8ybii.png)\n\n任意时刻只能存在一个黄色传送门和一个蓝色传送门。例如，如果你尝试向西创建一个蓝色传送门，原来的蓝色传送门会消失：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/u3zzj14r.png)\n\n只有当你再次发射同色传送门时，原有的传送门才会消失。\n\n注意，传送门是创建在墙的一侧的。如果一堵墙的东侧有一个传送门，你必须从东侧进入墙才能通过传送门。否则你只是撞到了一堵墙，这是不可能的。\n\n最后，你不能在同一位置放置两个传送门。如果你试图在已有传送门的一侧再次放置传送门，第二个传送门将无法形成。\n\n给定迷宫、你的初始位置和蛋糕的位置，判断你是否能到达蛋糕，并输出最少需要多少步。注意，射击传送门枪不计为移动步数。", "inputFormat": "输入的第一行为测试用例数 $N$。接下来有 $N$ 组测试数据。\n\n每组测试数据的第一行为两个整数 $R$ 和 $C$，用空格分隔。接下来有 $R$ 行，每行包含 $C$ 个字符，表示地图：\n\n- . 表示空单元格；\n- \\# 表示墙；\n- o 表示你的起始位置；\n- x 表示蛋糕的位置。\n\n每组数据中恰好有一个 o 和一个 x。\n\n网格外的所有单元格都视为墙，你可以用它们来创建传送门。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #$X$: $Y$\"，其中 $X$ 是测试用例编号，$Y$ 是到达蛋糕所需的最小步数。如果无法到达蛋糕，则输出 \"THE CAKE IS A LIE\"。", "hint": "**样例解释**\n\n以下是第一组数据的移动顺序（注意，射击传送门枪不计为移动步数）：\n\n- 向东移动一步。\n- 向北射击蓝色传送门。\n- 向南射击黄色传送门。\n- 向北移动一步，通过蓝色传送门。\n- 向东射击蓝色传送门。\n- 向南移动一步，通过黄色传送门。\n- 向西移动一步。\n- 吃掉你美味多汁的蛋糕。\n\nPortal$^{\\text{TM}}$ 是 Valve Inc. 的商标。Valve Inc. 未参与本题的设计，也未对 Google Code Jam 进行任何背书。\n\n**小数据集（10 分，测试集 1 - 可见）**\n\n- $N=200$\n- $1 \\leqslant R, C \\leqslant 8$\n\n**大数据集（15 分，测试集 2 - 隐藏）**\n\n- $N=50$\n- $1 \\leqslant R, C \\leqslant 15$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13472", "type": "P", "difficulty": 5, "samples": [["4\n2 3\n...\n...\n2 3\nx.x\nxxx\n2 3\nx.x\nx.x\n10 10\n....x.....\n..........\n..........\n..x.......\n..........\nx...x.x...\n.........x\n...x......\n........x.\n.x...x....", "Case #1: 4\nCase #2: 1\nCase #3: 2\nCase #4: 46"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["2008", "二分图", "Google Code Jam"], "title": "[GCJ 2008 #3] No Cheating", "background": "", "description": "A local high school is going to hold a final exam in a big classroom. However, some students in this school are always trying to see each other's answer sheet during exams!\n\nThe classroom can be regarded as a rectangle of $M$ rows by $N$ columns of unit squares, where each unit square represents a seat.\n\nThe school principal decided to set the following rule to prevent cheating: Assume a student is able to see his left, right, upper-left, and upper-right neighbors' answer sheets. The assignment of seats must guarantee that nobody's answer sheet can be seen by any other student.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9h75fz4n.png)\n\nAs in this picture, it will not be a good idea to seat anyone in A, C, D, or E because the boy in the back row would be able to see their answer sheets. However, if there is a girl sitting in B, he will not be able to see her answer sheet.\n\nSome seats in the classroom are broken, and we cannot put a student in a broken seat.\n\nThe principal asked you to answer the following question: What is the maximum number of students that can be placed in the classroom so that no one can cheat?", "inputFormat": "The first line of input gives the number of cases, $C$. $C$ test cases follow. Each case consists of two parts.\n\nThe first part is a single line with two integers $M$ and $N$: The height and width of the rectangular classroom.\n\nThe second part will be exactly $M$ lines, with exactly $N$ characters in each of these lines. Each character is either a '.' (the seat is not broken) or 'x' (the seat is broken, lowercase x).\n", "outputFormat": "For each test case, output one line containing \"Case #$X$: $Y$\", where $X$ is the case number, starting from 1, and $Y$ is the maximum possible number of students that can take the exam in the classroom.", "hint": "**Limits**\n\n- $C=20$\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leqslant M \\leqslant 10$\n- $1 \\leqslant N \\leqslant 10$\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leqslant M \\leqslant 80$\n- $1 \\leqslant N \\leqslant 80$", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 #3] No Cheating", "background": "", "description": "A local high school is going to hold a final exam in a big classroom. However, some students in this school are always trying to see each other's answer sheet during exams!\n\nThe classroom can be regarded as a rectangle of $M$ rows by $N$ columns of unit squares, where each unit square represents a seat.\n\nThe school principal decided to set the following rule to prevent cheating: Assume a student is able to see his left, right, upper-left, and upper-right neighbors' answer sheets. The assignment of seats must guarantee that nobody's answer sheet can be seen by any other student.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9h75fz4n.png)\n\nAs in this picture, it will not be a good idea to seat anyone in A, C, D, or E because the boy in the back row would be able to see their answer sheets. However, if there is a girl sitting in B, he will not be able to see her answer sheet.\n\nSome seats in the classroom are broken, and we cannot put a student in a broken seat.\n\nThe principal asked you to answer the following question: What is the maximum number of students that can be placed in the classroom so that no one can cheat?", "inputFormat": "The first line of input gives the number of cases, $C$. $C$ test cases follow. Each case consists of two parts.\n\nThe first part is a single line with two integers $M$ and $N$: The height and width of the rectangular classroom.\n\nThe second part will be exactly $M$ lines, with exactly $N$ characters in each of these lines. Each character is either a '.' (the seat is not broken) or 'x' (the seat is broken, lowercase x).\n", "outputFormat": "For each test case, output one line containing \"Case #$X$: $Y$\", where $X$ is the case number, starting from 1, and $Y$ is the maximum possible number of students that can take the exam in the classroom.", "hint": "**Limits**\n\n- $C=20$\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leqslant M \\leqslant 10$\n- $1 \\leqslant N \\leqslant 10$\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leqslant M \\leqslant 80$\n- $1 \\leqslant N \\leqslant 80$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 #3] No Cheating", "background": null, "description": "一所当地的高中将在一个大教室里举行期末考试。然而，这所学校的一些学生总是试图在考试时偷看彼此的答题卡！\n\n教室可以看作是一个 $M$ 行 $N$ 列的矩形网格，每个单元格代表一个座位。\n\n校长决定制定如下规则以防止作弊：假设一个学生可以看到他左边、右边、左上方和右上方邻座同学的答题卡。座位的安排必须保证没有任何人的答题卡会被其他学生看到。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9h75fz4n.png)\n\n如图所示，如果有人坐在 A、C、D 或 E，后排的男孩就能看到他们的答题卡，这样的安排并不好。然而，如果有女生坐在 B，他就无法看到她的答题卡。\n\n教室中有些座位是坏的，不能安排学生坐在坏掉的座位上。\n\n校长请你回答如下问题：在没有人能作弊的前提下，最多能安排多少名学生参加考试？", "inputFormat": "输入的第一行为测试用例数 $C$。接下来有 $C$ 组测试数据。每组测试数据包括两部分。\n\n第一部分为一行，包含两个整数 $M$ 和 $N$，表示教室的行数和列数。\n\n第二部分为恰好 $M$ 行，每行恰好 $N$ 个字符。每个字符为 '.'（表示该座位未坏）或 'x'（表示该座位已坏，小写字母 x）。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$X$: $Y$\"，其中 $X$ 表示测试用例编号（从 1 开始），$Y$ 表示在教室中最多能安排的学生人数。", "hint": "**数据范围**\n\n- $C=20$\n\n**小数据范围（10 分，测试点 1 - 可见）**\n\n- $1 \\leqslant M \\leqslant 10$\n- $1 \\leqslant N \\leqslant 10$\n\n**大数据范围（20 分，测试点 2 - 隐藏）**\n\n- $1 \\leqslant M \\leqslant 80$\n- $1 \\leqslant N \\leqslant 80$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13473", "type": "P", "difficulty": 5, "samples": [["5\n1 1 0\n4 4 1\n2 1\n3 3 0\n7 10 2\n1 2\n7 1\n4 4 1\n3 2", "Case #1: 1\nCase #2: 2\nCase #3: 0\nCase #4: 5\nCase #5: 1"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["2008", "组合数学", "容斥原理", "Lucas 定理", "Google Code Jam"], "title": "[GCJ 2008 #3] Endless Knight", "background": "", "description": "In the game of chess, there is a piece called the knight. A knight is special -- instead of moving in a straight line like other pieces, it jumps in an \"L\" shape. Specifically, a knight can jump from square $(r_1, c_1)$ to $(r_2, c_2)$ if and only if $(r_1 - r_2)^2 + (c_1 - c_2)^2 = 5$.\n\nIn this problem, one of our knights is going to undertake a chivalrous quest of moving from the top-left corner (the $(1, 1)$ square) to the bottom-right corner (the $(H, W)$ square) on a gigantic board. The chessboard is of height $H$ and width $W$.\n\nHere are some restrictions you need to know.\n\n* The knight is so straightforward and ardent that he is only willing to move towards the right and the bottom. In other words, in each step he only moves to a square with a bigger row number and a bigger column number. Note that, this might mean that there is no way to achieve his goal, for example, on a 3 by 10 board.\n* There are $R$ squares on the chessboard that contain rocks with evil power. Your knight may not land on any of such squares, although flying over them during a jump is allowed.\n\nYour task is to find the number of unique ways for the knight to move from the top-left corner to the bottom-right corner, under the above restrictions. It should be clear that sometimes the answer is huge. You are asked to output the remainder of the answer when divided by $10007$, a prime number.", "inputFormat": "Input begins with a line containing a single integer, $N$. $N$ test cases follow.\n\nThe first line of each test case contains 3 integers, $H$, $W$, and $R$. The next $R$ lines each contain 2 integers each, $r$ and $c$, the row and column numbers of one rock. You may assume that $(1, 1)$ and $(H, W)$ never contain rocks and that no two rocks are at the same position.\n", "outputFormat": "For each test case, output a single line of output, prefixed by \"Case #$X$: \", where $X$ is the 1-based case number, followed by a single integer indicating the number of ways of reaching the goal, modulo $10007$.", "hint": "**Limits**\n\n- $1 \\leq N \\leq 100$\n- $0 \\leq R \\leq 10$\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leq W \\leq 100$\n- $1 \\leq H \\leq 100$\n- $1 \\leq r \\leq H$\n- $1 \\leq c \\leq W$\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq W \\leq 10^{8}$\n- $1 \\leq H \\leq 10^{8}$\n- $1 \\leq r \\leq H$\n- $1 \\leq c \\leq W$", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 #3] Endless Knight", "background": "", "description": "In the game of chess, there is a piece called the knight. A knight is special -- instead of moving in a straight line like other pieces, it jumps in an \"L\" shape. Specifically, a knight can jump from square $(r_1, c_1)$ to $(r_2, c_2)$ if and only if $(r_1 - r_2)^2 + (c_1 - c_2)^2 = 5$.\n\nIn this problem, one of our knights is going to undertake a chivalrous quest of moving from the top-left corner (the $(1, 1)$ square) to the bottom-right corner (the $(H, W)$ square) on a gigantic board. The chessboard is of height $H$ and width $W$.\n\nHere are some restrictions you need to know.\n\n* The knight is so straightforward and ardent that he is only willing to move towards the right and the bottom. In other words, in each step he only moves to a square with a bigger row number and a bigger column number. Note that, this might mean that there is no way to achieve his goal, for example, on a 3 by 10 board.\n* There are $R$ squares on the chessboard that contain rocks with evil power. Your knight may not land on any of such squares, although flying over them during a jump is allowed.\n\nYour task is to find the number of unique ways for the knight to move from the top-left corner to the bottom-right corner, under the above restrictions. It should be clear that sometimes the answer is huge. You are asked to output the remainder of the answer when divided by $10007$, a prime number.", "inputFormat": "Input begins with a line containing a single integer, $N$. $N$ test cases follow.\n\nThe first line of each test case contains 3 integers, $H$, $W$, and $R$. The next $R$ lines each contain 2 integers each, $r$ and $c$, the row and column numbers of one rock. You may assume that $(1, 1)$ and $(H, W)$ never contain rocks and that no two rocks are at the same position.\n", "outputFormat": "For each test case, output a single line of output, prefixed by \"Case #$X$: \", where $X$ is the 1-based case number, followed by a single integer indicating the number of ways of reaching the goal, modulo $10007$.", "hint": "**Limits**\n\n- $1 \\leq N \\leq 100$\n- $0 \\leq R \\leq 10$\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leq W \\leq 100$\n- $1 \\leq H \\leq 100$\n- $1 \\leq r \\leq H$\n- $1 \\leq c \\leq W$\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq W \\leq 10^{8}$\n- $1 \\leq H \\leq 10^{8}$\n- $1 \\leq r \\leq H$\n- $1 \\leq c \\leq W$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 #3] Endless Knight", "background": null, "description": "在国际象棋游戏中，有一种棋子叫做骑士。骑士很特别——它不像其他棋子那样沿直线移动，而是以“L”形跳跃。具体来说，若 $(r_1, c_1)$ 到 $(r_2, c_2)$ 满足 $(r_1 - r_2)^2 + (c_1 - c_2)^2 = 5$，则骑士可以从 $(r_1, c_1)$ 跳到 $(r_2, c_2)$。\n\n在本题中，我们的骑士将踏上一次骑士之旅，从左上角 $(1, 1)$ 走到右下角 $(H, W)$ 的巨大棋盘上。棋盘的高度为 $H$，宽度为 $W$。\n\n你需要注意以下限制：\n\n- 骑士非常正直且热情，只愿意向右和向下移动。也就是说，每一步只能跳到行号和列号都更大的格子。注意，这意味着有些情况下无法到达目标，例如在 $3 \\times 10$ 的棋盘上。\n- 棋盘上有 $R$ 个格子上有带有邪恶力量的石头。骑士不能落在这些格子上，但跳跃时可以飞越这些格子。\n\n你的任务是计算骑士从左上角走到右下角的不同方案数，满足上述所有限制。显然，答案有时会非常大。请输出方案数对 $10007$ 取模的结果，$10007$ 是一个质数。", "inputFormat": "输入以一个整数 $N$ 开头，表示测试用例数。接下来有 $N$ 组测试数据。\n\n每组测试数据的第一行包含三个整数 $H$、$W$ 和 $R$。接下来的 $R$ 行，每行包含两个整数 $r$ 和 $c$，表示一个有石头的格子的行号和列号。保证 $(1, 1)$ 和 $(H, W)$ 不会有石头，且没有两个石头在同一位置。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #$X$: \"，其中 $X$ 是测试用例编号（从 1 开始），后接一个整数，表示到达目标的方案数对 $10007$ 取模的结果。", "hint": "**数据范围**\n\n- $1 \\leq N \\leq 100$\n- $0 \\leq R \\leq 10$\n\n**小数据集（5 分，测试点 1 - 可见）**\n\n- $1 \\leq W \\leq 100$\n- $1 \\leq H \\leq 100$\n- $1 \\leq r \\leq H$\n- $1 \\leq c \\leq W$\n\n**大数据集（20 分，测试点 2 - 隐藏）**\n\n- $1 \\leq W \\leq 10^{8}$\n- $1 \\leq H \\leq 10^{8}$\n- $1 \\leq r \\leq H$\n- $1 \\leq c \\leq W$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13474", "type": "P", "difficulty": 3, "samples": [["3\n5\n1000 1000 BIRD\n2000 1000 BIRD\n2000 2000 BIRD\n1000 2000 BIRD\n1500 2010 NOT BIRD\n3\n1500 1500\n900 900\n1400 2020\n3\n500 700 NOT BIRD\n501 700 BIRD\n502 700 NOT BIRD\n2\n501 600\n502 501\n1\n100 100 NOT BIRD\n3\n107 93\n86 70\n110 115", "Case #1:\nBIRD\nUNKNOWN\nNOT BIRD\nCase #2:\nUNKNOWN\nNOT BIRD\nCase #3:\nUNKNOWN\nUNKNOWN\nUNKNOWN"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["数学", "2008", "Google Code Jam"], "title": "[GCJ 2008 APAC SemiFinal] What are Birds?", "background": "", "description": "You are studying animals in a forest, and are trying to determine which animals are birds and which are not.\n\nYou do this by taking two measurements of each animal – their height and their weight. For an animal to be a bird, its height needs to be within some range, and its weight needs to be within another range, but you're not sure what the height and weight ranges are. You also know that every animal that satisfies these ranges is a bird.\n\nYou have taken some of the animals you have measured and shown them to biologists, and they have told you which are birds and which are not. This has given you some information on what the height and weight ranges for a bird must be. For the remaining animals, your program should determine if they are definitely birds, definitely not birds, or if you don't know from the information you have.\n", "inputFormat": "One line containing an integer $C$, the number of test cases in the input.\n\nThen for each of the $C$ test cases:\n\n* One line containing an integer $N$, the number of animals you have shown to the biologists.\n* $N$ lines, one for each of these animals, each of the format \"H W X\", where $H$ is the height of the animal, $W$ is the weight of the animal, and $X$ is either the string \"BIRD\" or \"NOT BIRD\". All numbers are positive integers.\n* One line containing an integer $M$, the number of animals you have not shown to the biologists.\n* $M$ lines, one for each of these animals, each of the format \"H W\", where $H$ is the height of the animal and $W$ is the weight of the animal. All numbers are positive integers.\n", "outputFormat": "For each of the $C$ test cases:\n\n* One line containing the string \"Case #$X$: \" where $X$ is the number of the test case, starting from 1.\n* $M$ lines, each containing one of \"BIRD\", \"NOT BIRD\", or \"UNKNOWN\" (quotes are just for clarity and should not be part of the output).", "hint": "**Sample Explanation**\n\nCase 1:\n\nThe animal \"1500 1500\" must be within the ranges for birds, since we know that the ranges for height and weight each include 1000 and 2000.\n\nThe animal \"900 900\" may or may not be a bird; we don't know if the ranges for height and weight include 900.\n\nThe animal \"1400 2020\" is within the height range for birds, but if 2020 was in the weight range, then the animal \"1500 2010\", which we know is not a bird, would also have to be within the weight range.\n\nCase 2:\n\nIn this case we know that birds must have a height of 501. But we don't know what the weight range for a bird is, other than that it includes weight 700.\n\nCase 3:\n\nIn this case, we know that anything with height 100 and weight 100 is not a bird, but we just don't know what birds are.\n\n**Limits**\n\n- $1 \\leq C \\leq 10$\n- $1 \\leq \\text{all heights and weights} \\leq 1000000$\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 10$\n- $1 \\leq M \\leq 10$\n\n**Large dataset (12 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 1000$\n- $1 \\leq M \\leq 1000$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 APAC SemiFinal] What are Birds?", "background": "", "description": "You are studying animals in a forest, and are trying to determine which animals are birds and which are not.\n\nYou do this by taking two measurements of each animal – their height and their weight. For an animal to be a bird, its height needs to be within some range, and its weight needs to be within another range, but you're not sure what the height and weight ranges are. You also know that every animal that satisfies these ranges is a bird.\n\nYou have taken some of the animals you have measured and shown them to biologists, and they have told you which are birds and which are not. This has given you some information on what the height and weight ranges for a bird must be. For the remaining animals, your program should determine if they are definitely birds, definitely not birds, or if you don't know from the information you have.\n", "inputFormat": "One line containing an integer $C$, the number of test cases in the input.\n\nThen for each of the $C$ test cases:\n\n* One line containing an integer $N$, the number of animals you have shown to the biologists.\n* $N$ lines, one for each of these animals, each of the format \"H W X\", where $H$ is the height of the animal, $W$ is the weight of the animal, and $X$ is either the string \"BIRD\" or \"NOT BIRD\". All numbers are positive integers.\n* One line containing an integer $M$, the number of animals you have not shown to the biologists.\n* $M$ lines, one for each of these animals, each of the format \"H W\", where $H$ is the height of the animal and $W$ is the weight of the animal. All numbers are positive integers.\n", "outputFormat": "For each of the $C$ test cases:\n\n* One line containing the string \"Case #$X$: \" where $X$ is the number of the test case, starting from 1.\n* $M$ lines, each containing one of \"BIRD\", \"NOT BIRD\", or \"UNKNOWN\" (quotes are just for clarity and should not be part of the output).", "hint": "**Sample Explanation**\n\nCase 1:\n\nThe animal \"1500 1500\" must be within the ranges for birds, since we know that the ranges for height and weight each include 1000 and 2000.\n\nThe animal \"900 900\" may or may not be a bird; we don't know if the ranges for height and weight include 900.\n\nThe animal \"1400 2020\" is within the height range for birds, but if 2020 was in the weight range, then the animal \"1500 2010\", which we know is not a bird, would also have to be within the weight range.\n\nCase 2:\n\nIn this case we know that birds must have a height of 501. But we don't know what the weight range for a bird is, other than that it includes weight 700.\n\nCase 3:\n\nIn this case, we know that anything with height 100 and weight 100 is not a bird, but we just don't know what birds are.\n\n**Limits**\n\n- $1 \\leq C \\leq 10$\n- $1 \\leq \\text{all heights and weights} \\leq 1000000$\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 10$\n- $1 \\leq M \\leq 10$\n\n**Large dataset (12 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 1000$\n- $1 \\leq M \\leq 1000$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 APAC SemiFinal] What are Birds?", "background": null, "description": "你正在研究森林中的动物，并试图判断哪些动物是鸟，哪些不是鸟。\n\n你通过测量每只动物的身高和体重来进行判断。要成为一只鸟，动物的身高需要在某个范围内，体重也需要在另一个范围内，但你并不确定这两个范围具体是多少。你还知道，所有满足这两个范围的动物一定是鸟。\n\n你已经将部分测量过的动物展示给生物学家，他们告诉你哪些是鸟，哪些不是。这为你提供了一些关于鸟类身高和体重范围的信息。对于剩下的动物，你的程序需要判断它们是否一定是鸟、一定不是鸟，或者根据已有信息无法确定。", "inputFormat": "第一行包含一个整数 $C$，表示测试用例的数量。\n\n接下来对于每个测试用例：\n\n- 第一行包含一个整数 $N$，表示你已经展示给生物学家的动物数量。\n- 接下来的 $N$ 行，每行格式为 \"H W X\"，其中 $H$ 表示动物的身高，$W$ 表示动物的体重，$X$ 为字符串 \"BIRD\" 或 \"NOT BIRD\"。所有数字均为正整数。\n- 接下来一行包含一个整数 $M$，表示你未展示给生物学家的动物数量。\n- 接下来的 $M$ 行，每行格式为 \"H W\"，其中 $H$ 表示动物的身高，$W$ 表示动物的体重。所有数字均为正整数。", "outputFormat": "对于每个测试用例：\n\n- 输出一行，格式为 \"Case #$X$: \"，其中 $X$ 为测试用例编号，从 1 开始。\n- 接下来 $M$ 行，每行输出 \"BIRD\"、\"NOT BIRD\" 或 \"UNKNOWN\"（不包含引号），分别表示该动物一定是鸟、一定不是鸟或无法确定。", "hint": "**样例解释**\n\n第 $1$ 组：\n\n动物 “1500 1500” 必然在鸟类的范围内，因为我们知道身高和体重的范围都包含 $1000$ 和 $2000$。\n\n动物 “900 900” 可能是鸟，也可能不是；我们无法确定身高和体重的范围是否包含 $900$。\n\n动物 “1400 2020” 的身高在鸟类范围内，但如果体重 $2020$ 也在范围内，那么 “1500 2010” 这只我们已知不是鸟的动物也必须在体重范围内。\n\n第 $2$ 组：\n\n在这种情况下，我们知道鸟的身高必须是 $501$。但我们只知道鸟的体重范围包含 $700$，其他不确定。\n\n第 3 组：\n\n在这种情况下，我们知道身高 $100$ 且体重 $100$ 的动物不是鸟，但我们对鸟的范围一无所知。\n\n**数据范围**\n\n- $1 \\leq C \\leq 10$\n- $1 \\leq$ 所有身高和体重 $\\leq 1000000$\n\n**小数据集（5 分，测试点 1 - 可见）**\n\n- $1 \\leq N \\leq 10$\n- $1 \\leq M \\leq 10$\n\n**大数据集（12 分，测试点 2 - 隐藏）**\n\n- $1 \\leq N \\leq 1000$\n- $1 \\leq M \\leq 1000$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
