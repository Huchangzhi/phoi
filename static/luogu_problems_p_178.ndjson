{"pid": "P4599", "type": "P", "difficulty": 7, "samples": [["2 5 50 ", "30"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "各省省选", "河北"], "title": "[HEOI2012] 赵州桥", "background": "fyg 背着他的电脑来到河北省来，就是为了见一眼古老的赵州桥。 \n\n终于，他来到了赵州桥，放下了电脑，正准备休息。一阵风吹来，从中闪现出一人影。 fyg 只觉天昏地暗，待得再次睁开眼时，发觉自己已经到了一神奇的国度，置身于一巨大的圆盘之上。放眼看去，四周都是奇形怪状的桥，不远处有一老头盘膝而坐。 ", "description": "fyg 还沉浸在惊奇之中，老头（难道就是传说中走过赵州桥的张老头！！）便开口了：凡人，你现在在我的世界中，想要出去就要回答我的问题。fyg 只得点头，老头继续道：你现在要去闯关，我给你$m$种颜色，总共有$n$关（神仙也懂数学，表示压力巨大。。==）。每一关中有一座桥，在第$i$关中，桥长度有$i$个单位，每个单位长度上有$2$个格子（也就是说这座桥有$2i$个格子），现在你要计算出：在这座桥上涂色使得桥上相邻格子的颜色不一样总方案数，然后再乘上$(2\\times i)^m$。如在第$1$关，若你手上有$2$种颜色，分别为蓝色和绿色。则总 方案数为$2\\times 2\\times 2=8$种，涂色方案数为 2（如下图，旋转、翻转相同算不同的方案），然后 还要再乘 2 个 2，最后你出来之后我会问你所有关中计算出来的数的和。如果你能答对，我就可以让你出去了，否则就无限轮回吧。 \n\n![](https://cdn.luogu.com.cn/upload/pic/19158.png )\n\nfyg 表示这个问题太水了，完全不想算。。。于是，他马上打开电脑上了QQ找到了喜欢计算的你，求你帮他直接把最终答案算出来，让他回到赵州桥上。 \n\n这两个数都有可能很大，fyg 不想为难你，所以你只要告诉他其除以 $p$ 的余数。 ", "inputFormat": "只有一行，其中包含三个正数 $n$、$m$、$p$，分别由一个空格分开。$n$、$m$、$p$ 含义和题目描述一致。 ", "outputFormat": "一行，表示方案数的和除以 $p$ 的余数。 ", "hint": "### 【样例说明】\n总共有 $2$ 关。\n\n第一关的桥长度为 $1$，总共有 $2$ 个格子，涂色方案数为 $20$，再乘上 $2 ^ 5$，第一关中计算出的数为 $640$。 \n\n第二关的桥长度为 $2$，总共有 $4$ 个格子，涂色方案数为 $260$，再乘上 $4 ^ 5$，第二关中计算出的数为 $266240$。\n\n两个数字加起来除以 $50$ 余 $30$，故输出为 $30$。 \n\n### 【数据范围】  \n\n对于其中 25%的数据，满足 $n\\leq10^6$，$m\\leq200$，$p\\leq10^9$；  \n\n对于其中 40%的数据，满足 $n\\leq10^9$，$m\\leq120$，$p\\leq10^9$；  \n\n对于其中 15%的数据，满足 $n\\leq10^9$，$m\\leq200$，$p \\leq10^9$；  \n\n对于最后 20%的数据，满足 $n\\leq10^9$，$m\\leq3000$，$p\\leq3000$； \n\nHEOI 2012 Day2 Task1", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2012] Zhaozhou Bridge", "background": "fyg carried his computer to Hebei just to catch a glimpse of the ancient Zhaozhou Bridge.\n\nAt last, he arrived at Zhaozhou Bridge, set down his computer, and was about to rest. A gust of wind blew, and a figure flashed out of it. fyg felt the world spin; when he opened his eyes again, he found himself in a magical realm, standing on a giant disk. Looking around, there were strange bridges everywhere, and not far away an old man was sitting cross-legged.", "description": "While fyg was still amazed, the old man (could it be the legendary Mr. Zhang who once crossed Zhaozhou Bridge?!) began to speak: Mortal, you are now in my world. If you want to leave, you must answer my question. fyg nodded, and the old man continued: You are going to clear a series of levels. I give you $m$ colors, and there are $n$ levels in total (even immortals know math—what pressure...). In each level, there is a bridge. In level $i$, the bridge has length $i$ units, and each unit length has $2$ cells (that is, the bridge has $2i$ cells). Now you need to compute: the number of ways to color this bridge so that adjacent cells have different colors, then multiply it by $(2 \\times i)^m$. For example, in level $1$, if you have $2$ colors, blue and green, then the final number would be $2 \\times 2 \\times 2 = 8$; the number of coloring schemes is $2$ (as shown in the figure; rotations and reflections are counted as different), and then you also multiply by two 2s. After you come out, I will ask you for the sum of the numbers computed for all levels. If you answer correctly, I will let you go; otherwise, you will be trapped in an endless cycle.\n\n![](https://cdn.luogu.com.cn/upload/pic/19158.png)\n\nfyg thought the problem was too trivial and did not want to compute it at all... So he immediately opened his computer, logged into QQ, and found you, who enjoy calculations, asking you to directly compute the final answer and help him return to Zhaozhou Bridge.\n\nThese two numbers can both be very large, and fyg does not want to make it hard for you, so you only need to tell him the remainder when divided by $p$.", "inputFormat": "A single line containing three positive integers $n$, $m$, and $p$, separated by spaces. The meanings of $n$, $m$, and $p$ are as described in the problem statement.", "outputFormat": "One line, the remainder of the sum of the values modulo $p$.", "hint": "### Sample Explanation\nThere are $2$ levels in total.\n\n- In the first level, the bridge length is $1$, there are $2$ cells in total, the number of coloring schemes is $20$, then multiply by $2^5$, and the number computed for the first level is $640$.\n- In the second level, the bridge length is $2$, there are $4$ cells in total, the number of coloring schemes is $260$, then multiply by $4^5$, and the number computed for the second level is $266240$.\n\nThe sum of the two numbers leaves a remainder $30$ when divided by $50$, so the output is $30$.\n\n### Constraints\n- For 25% of the testdata, $n \\leq 10^6$, $m \\leq 200$, $p \\leq 10^9$.\n- For 40% of the testdata, $n \\leq 10^9$, $m \\leq 120$, $p \\leq 10^9$.\n- For 15% of the testdata, $n \\leq 10^9$, $m \\leq 200$, $p \\leq 10^9$.\n- For the final 20% of the testdata, $n \\leq 10^9$, $m \\leq 3000$, $p \\leq 3000$.\n\nHEOI 2012 Day2 Task1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2012] 赵州桥", "background": "fyg 背着他的电脑来到河北省来，就是为了见一眼古老的赵州桥。 \n\n终于，他来到了赵州桥，放下了电脑，正准备休息。一阵风吹来，从中闪现出一人影。 fyg 只觉天昏地暗，待得再次睁开眼时，发觉自己已经到了一神奇的国度，置身于一巨大的圆盘之上。放眼看去，四周都是奇形怪状的桥，不远处有一老头盘膝而坐。 ", "description": "fyg 还沉浸在惊奇之中，老头（难道就是传说中走过赵州桥的张老头！！）便开口了：凡人，你现在在我的世界中，想要出去就要回答我的问题。fyg 只得点头，老头继续道：你现在要去闯关，我给你$m$种颜色，总共有$n$关（神仙也懂数学，表示压力巨大。。==）。每一关中有一座桥，在第$i$关中，桥长度有$i$个单位，每个单位长度上有$2$个格子（也就是说这座桥有$2i$个格子），现在你要计算出：在这座桥上涂色使得桥上相邻格子的颜色不一样总方案数，然后再乘上$(2\\times i)^m$。如在第$1$关，若你手上有$2$种颜色，分别为蓝色和绿色。则总 方案数为$2\\times 2\\times 2=8$种，涂色方案数为 2（如下图，旋转、翻转相同算不同的方案），然后 还要再乘 2 个 2，最后你出来之后我会问你所有关中计算出来的数的和。如果你能答对，我就可以让你出去了，否则就无限轮回吧。 \n\n![](https://cdn.luogu.com.cn/upload/pic/19158.png )\n\nfyg 表示这个问题太水了，完全不想算。。。于是，他马上打开电脑上了QQ找到了喜欢计算的你，求你帮他直接把最终答案算出来，让他回到赵州桥上。 \n\n这两个数都有可能很大，fyg 不想为难你，所以你只要告诉他其除以 $p$ 的余数。 ", "inputFormat": "只有一行，其中包含三个正数 $n$、$m$、$p$，分别由一个空格分开。$n$、$m$、$p$ 含义和题目描述一致。 ", "outputFormat": "一行，表示方案数的和除以 $p$ 的余数。 ", "hint": "### 【样例说明】\n总共有 $2$ 关。\n\n第一关的桥长度为 $1$，总共有 $2$ 个格子，涂色方案数为 $20$，再乘上 $2 ^ 5$，第一关中计算出的数为 $640$。 \n\n第二关的桥长度为 $2$，总共有 $4$ 个格子，涂色方案数为 $260$，再乘上 $4 ^ 5$，第二关中计算出的数为 $266240$。\n\n两个数字加起来除以 $50$ 余 $30$，故输出为 $30$。 \n\n### 【数据范围】  \n\n对于其中 25%的数据，满足 $n\\leq10^6$，$m\\leq200$，$p\\leq10^9$；  \n\n对于其中 40%的数据，满足 $n\\leq10^9$，$m\\leq120$，$p\\leq10^9$；  \n\n对于其中 15%的数据，满足 $n\\leq10^9$，$m\\leq200$，$p \\leq10^9$；  \n\n对于最后 20%的数据，满足 $n\\leq10^9$，$m\\leq3000$，$p\\leq3000$； \n\nHEOI 2012 Day2 Task1", "locale": "zh-CN"}}}
{"pid": "P4600", "type": "P", "difficulty": 6, "samples": [["2\naabb\nbabb\n2\n1 3 2 3\n1 4 2 4 ", "1\n1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "线段树", "各省省选", "河北", "最近公共祖先 LCA", "AC 自动机"], "title": "[HEOI2012] 旅行问题", "background": "", "description": "yz 是 Z 国的领导人，他规定每个地区的名字只能为 $26$ 个小写拉丁字母的一个。由于地区数有可能超过 $26$ 个，便产生了一个问题，如何辨别名字相同的地区？于是 yz 规定，一个地区的描述必须包含它的所有上级，且上级按次序排列。于是，一个地区的描述是一个字符串。比如说，一个地区的名字为 $\\tt c$，它的上级为 $\\tt b$，$\\tt b$ 的上级为 $\\tt a$，$\\tt a$ 没有上级，那么这个地区就描述为 $\\tt abc$。显然，这个描述同时包含了 $\\tt c$ 的上级 $\\tt b$ 和 $\\tt b$ 的上级 $\\tt a$ 的描述，分别为 $\\tt ab$ 和 $\\tt a$。\n\n值得注意的是，每个地区最多有一个上级，同一上级的地区之间名字不同，没有上级的地区之间名字不同。\n\n现在，yz 对外公布了 $n$ 个地区的描述，这些描述中包含了 Z 国所有地区的描述，并让你处理来访者的旅行问题。\n\n现有 $m$ 对人访问这个国家，对于每对人，第一个人喜欢第 $i$ 个描述中的第 $j$ 个地区，设这个地区描述为 $s_1$，第二个人喜欢第 $k$ 个描述中的第 $l$ 个地区，设这个地区描述为 $s_2$。他们为了统一行程，决定访问描述为 $s$ 的地区（显然他们只关心地区的名字，并非是地区本身），设 $s$ 的长度为 $t$，$s$ 需要满足以下条件：\n\n1. $t\\leq j$，$t\\leq l$。\n2. $s[1\\cdots t]=s_1[j-t+1\\cdots j]$，$s[1\\cdots t]=s_2[l-t+1\\cdots l]$，即 $s$ 为 $s_1$ 中 $1$ 到 $j$ 位与 $s_2$ 中 $1$ 到 $l$ 位的公共后缀。\n2. $t$ 最大化。\n\n为了不使输出过大，你只需把这个字符串按照如下生成的 $26$ 进制数转成 $10$ 进制后 $\\bmod\\ (10^9+7)$ 后输出：\n\n- $a \\to 0$；\n- $b \\to 1$；\n- ……\n- $z \\to 25$。\n\n比如地区 $\\tt cab$ 被编码成 $2\\times26^2+0\\times26^1+1\\times26^0=1353$。", "inputFormat": "第一行给定一个整数 $n$。\n\n第 $2\\cdots n+1$ 行，每 $i+1$ 行给定一个字符串 $a_i$，表示第 $i$ 个描述。\n\n接下来一行一个整数 $m$。 \n\n接下来 $m$ 行，每行给定四个整数 $i,j,k,l$，字母含义与题目描述一致。 ", "outputFormat": "共 $m$ 行，每行一个整数，表示答案字符串的编码。 ", "hint": "### 样例解释\n\n询问 $1$ 中的公共后有 $\\tt ab$ 和 $\\tt b$，但是没有 $\\tt ab$ 这个地区，只有 $\\tt b$ 地区，所以只能选择 $\\tt b$ 这个地区；\n\n询问 $2$ 中的公共后有 $\\tt abb$，$\\tt bb$ 和 $\\tt b$，但是没有 $\\tt abb$ 和 $\\tt bb$ 这两个地区，只有 $\\tt b$ 地区，所以只能选择 $\\tt b$ 这个地区。\n\n### 数据范围及约定\n\n设这个国家地区总数数为 $tot$（注意：输入的字符串总长度可能超过 $tot$！）\n\n- 对于 $30\\%$ 的数据，满足 $1\\le tot, m, n \\le 100$；\n- 对于 $50\\%$ 的数据，满足 $1\\le tot, m, n \\le 1000$；\n- 对于 $80\\%$ 的数据，满足 $1\\le tot, m, n \\le 10^5$；\n- 对于 $100\\%$ 的数据，满足$1\\le  tot, m, n \\le 10^6$。\n\n保证输入文件不超过 $20\\text{MB}$。\n\nHEOI2012 Day 2 Task 2", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2012] Travel Problem", "background": "", "description": "yz is the leader of Country Z. He requires that the name of each region can only be one of the $26$ lowercase Latin letters. Since the number of regions may exceed $26$, a problem arises: how can we tell regions with the same name apart? Therefore, yz specifies that the description of a region must include all of its superiors, and the superiors must be listed in order. Thus, a region’s description is a string. For example, if a region’s name is $\\tt c$, its superior is $\\tt b$, the superior of $\\tt b$ is $\\tt a$, and $\\tt a$ has no superior, then this region is described as $\\tt abc$. Clearly, this description also contains the descriptions of $\\tt c$’s superior $\\tt b$ and $\\tt b$’s superior $\\tt a$, which are $\\tt ab$ and $\\tt a$, respectively.\n\nNote that each region has at most one superior. Among regions with the same superior, their names are different. Among regions with no superior, their names are also different.\n\nNow, yz has published the descriptions of $n$ regions to the public. These descriptions include the descriptions of all regions in Country Z, and you are asked to handle visitors’ travel problems.\n\nThere are $m$ pairs of people visiting this country. For each pair, the first person likes the $j$-th region in the $i$-th description; let this region’s description be $s_1$. The second person likes the $l$-th region in the $k$-th description; let this region’s description be $s_2$. To unify their itinerary, they decide to visit the region whose description is $s$ (obviously, they only care about the region name, not the region itself). Let the length of $s$ be $t$. The string $s$ must satisfy:\n\n1. $t\\leq j$, $t\\leq l$.\n2. $s[1\\cdots t]=s_1[j-t+1\\cdots j]$, $s[1\\cdots t]=s_2[l-t+1\\cdots l]$, i.e., $s$ is a common suffix of the prefix $s_1[1\\cdots j]$ and the prefix $s_2[1\\cdots l]$.\n3. Maximize $t$.\n\nTo avoid overly large output, you only need to convert this string into a base-$26$ number (as generated below), then convert it to base $10$ and output it modulo $(10^9+7)$:\n\n- $a \\to 0$;\n- $b \\to 1$;\n- ……\n- $z \\to 25$.\n\nFor example, region $\\tt cab$ is encoded as $2\\times26^2+0\\times26^1+1\\times26^0=1353$.", "inputFormat": "The first line contains an integer $n$.\n\nLines $2$ to $n+1$: the $(i+1)$-th line contains a string $a_i$, representing the $i$-th description.\n\nThe next line contains an integer $m$.\n\nThe next $m$ lines each contain four integers $i,j,k,l$, with the meanings consistent with the statement.", "outputFormat": "There are $m$ lines. Each line contains one integer, which is the encoding of the answer string.", "hint": "### Sample Explanation\n\nIn query $1$, the common suffixes include $\\tt ab$ and $\\tt b$, but there is no region $\\tt ab$, only region $\\tt b$, so they can only choose region $\\tt b$.\n\nIn query $2$, the common suffixes include $\\tt abb$, $\\tt bb$, and $\\tt b$, but there are no regions $\\tt abb$ or $\\tt bb$, only region $\\tt b$, so they can only choose region $\\tt b$.\n\n### Constraints and Notes\n\nLet the total number of regions in this country be $tot$ (note that the total length of input strings may exceed $tot$!).\n\n- For $30\\%$ of the testdata, $1\\le tot, m, n \\le 100$.\n- For $50\\%$ of the testdata, $1\\le tot, m, n \\le 1000$.\n- For $80\\%$ of the testdata, $1\\le tot, m, n \\le 10^5$.\n- For $100\\%$ of the testdata, $1\\le tot, m, n \\le 10^6$.\n\nIt is guaranteed that the input file does not exceed $20\\text{MB}$.\n\nHEOI2012 Day 2 Task 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2012] 旅行问题", "background": "", "description": "yz 是 Z 国的领导人，他规定每个地区的名字只能为 $26$ 个小写拉丁字母的一个。由于地区数有可能超过 $26$ 个，便产生了一个问题，如何辨别名字相同的地区？于是 yz 规定，一个地区的描述必须包含它的所有上级，且上级按次序排列。于是，一个地区的描述是一个字符串。比如说，一个地区的名字为 $\\tt c$，它的上级为 $\\tt b$，$\\tt b$ 的上级为 $\\tt a$，$\\tt a$ 没有上级，那么这个地区就描述为 $\\tt abc$。显然，这个描述同时包含了 $\\tt c$ 的上级 $\\tt b$ 和 $\\tt b$ 的上级 $\\tt a$ 的描述，分别为 $\\tt ab$ 和 $\\tt a$。\n\n值得注意的是，每个地区最多有一个上级，同一上级的地区之间名字不同，没有上级的地区之间名字不同。\n\n现在，yz 对外公布了 $n$ 个地区的描述，这些描述中包含了 Z 国所有地区的描述，并让你处理来访者的旅行问题。\n\n现有 $m$ 对人访问这个国家，对于每对人，第一个人喜欢第 $i$ 个描述中的第 $j$ 个地区，设这个地区描述为 $s_1$，第二个人喜欢第 $k$ 个描述中的第 $l$ 个地区，设这个地区描述为 $s_2$。他们为了统一行程，决定访问描述为 $s$ 的地区（显然他们只关心地区的名字，并非是地区本身），设 $s$ 的长度为 $t$，$s$ 需要满足以下条件：\n\n1. $t\\leq j$，$t\\leq l$。\n2. $s[1\\cdots t]=s_1[j-t+1\\cdots j]$，$s[1\\cdots t]=s_2[l-t+1\\cdots l]$，即 $s$ 为 $s_1$ 中 $1$ 到 $j$ 位与 $s_2$ 中 $1$ 到 $l$ 位的公共后缀。\n2. $t$ 最大化。\n\n为了不使输出过大，你只需把这个字符串按照如下生成的 $26$ 进制数转成 $10$ 进制后 $\\bmod\\ (10^9+7)$ 后输出：\n\n- $a \\to 0$；\n- $b \\to 1$；\n- ……\n- $z \\to 25$。\n\n比如地区 $\\tt cab$ 被编码成 $2\\times26^2+0\\times26^1+1\\times26^0=1353$。", "inputFormat": "第一行给定一个整数 $n$。\n\n第 $2\\cdots n+1$ 行，每 $i+1$ 行给定一个字符串 $a_i$，表示第 $i$ 个描述。\n\n接下来一行一个整数 $m$。 \n\n接下来 $m$ 行，每行给定四个整数 $i,j,k,l$，字母含义与题目描述一致。 ", "outputFormat": "共 $m$ 行，每行一个整数，表示答案字符串的编码。 ", "hint": "### 样例解释\n\n询问 $1$ 中的公共后有 $\\tt ab$ 和 $\\tt b$，但是没有 $\\tt ab$ 这个地区，只有 $\\tt b$ 地区，所以只能选择 $\\tt b$ 这个地区；\n\n询问 $2$ 中的公共后有 $\\tt abb$，$\\tt bb$ 和 $\\tt b$，但是没有 $\\tt abb$ 和 $\\tt bb$ 这两个地区，只有 $\\tt b$ 地区，所以只能选择 $\\tt b$ 这个地区。\n\n### 数据范围及约定\n\n设这个国家地区总数数为 $tot$（注意：输入的字符串总长度可能超过 $tot$！）\n\n- 对于 $30\\%$ 的数据，满足 $1\\le tot, m, n \\le 100$；\n- 对于 $50\\%$ 的数据，满足 $1\\le tot, m, n \\le 1000$；\n- 对于 $80\\%$ 的数据，满足 $1\\le tot, m, n \\le 10^5$；\n- 对于 $100\\%$ 的数据，满足$1\\le  tot, m, n \\le 10^6$。\n\n保证输入文件不超过 $20\\text{MB}$。\n\nHEOI2012 Day 2 Task 2", "locale": "zh-CN"}}}
{"pid": "P4601", "type": "P", "difficulty": 0, "samples": [["3 3 2\nH#.\n*..\n…\n1 0\n0 1\n2\n1\n2 ", "1\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "各省省选", "河北"], "title": "[HEOI2012] 野外探险", "background": "小 H 是一位探险家。在险峻的珠穆朗玛峰，原始辽阔的非洲大草原，美丽冻人的南极大陆等地方都留下过这位探险家的足迹。这次，他来到了位于南美洲充斥着大量毒虫猛兽的以及各式各样传说的亚马逊热带雨林进行探险。为此，他花了许多时间来准备这次激动人心的探险。在准备就绪后，小 H 和他的助手在当地导游的带领下踏入了这片雨林。 ", "description": "通过 GPS 定位系统，他们获得了雨林大致的地图。这个地图是一个 $n$ 行 $m$ 列的字符网格图，’.’表示的是空地，’*’表示的是不可通行的区域，’#’表示的是需要清理的区域，’H’表示小H所在的位置，该区域是空地。他们的移动方式有 $t$ 种，用$a[i]$,$b[i]$($1\\leq i\\leq t$)表示，假设他们所在的位置为第 $x$ 行第 $y$ 列，那么他们下一步的位置将是第 $x+a[i]$行第 $y+b[i]$列，也可以是反方向，即第 $x-a[i]$行第 $y-b[i]$列。小 H 一行人每天可在选择一种移动方式，朝着正方向或者反方向连续走若干步之后停下，不可以不走。在当天的行走过程中，他们不可以到达不可通行的区域，如果他们到达了一个需要清理的区域，他们会停止移动。为了以后探险的方便，他们会用该天剩下的时间来清理该区域，之后该区域将永久变成空地。\n\n现在，为了使探险活动顺利的进行，他们将 $q$ 个询问通过网络发送给了你，询问他们在第 $d[i]$($1\\leq i\\leq q$)天能到达的区域个数，题目保证不会有无路可走的情况。你能帮助他解决这个问题吗？ ", "inputFormat": "输入的第 $1$ 行包含三个正整数，分别表示 $n$、$m$、$t$。\n\n在第 $2$ 行至第 $n+1$ 行中，每行都有 $m$ 个字符（只可能是’.’，’*’，’#’，’H’，其中’H’ 有且只有一个）。 \n\n在第 $n+2$ 行至第 $n+t+1$行中，每行有两个整数，分别表示 $a[i]$，$b[i]$（$a[i]$，$b[i]$不可能同时为 $0$）。 \n\n在第 $n+t+2$ 行包含一个正整数，表示 $q$。 \n\n在第 $n+t+3$ 行至第 $n+t+q+2$ 行共有 $q$ 个整数，表示他们所询问的时间点（即 $d[i]$）。 ", "outputFormat": "输出共 $q$ 行，对于每一个询问，输出他们所能走到的地点的个数。 ", "hint": "对于 20%的数据，满足 $n,m\\leq4$, $q\\leq100$；\n\n对于 70%的数据，满足 $n,m\\leq300$；\n\n对于 100%的数据，满足 $n,m\\leq1000$, $t\\leq5$, $q\\leq1000$, $0\\leq d[i]\\leq10^9$； \n\n\nHEOI 2012 Day2 Task3", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2012] Wilderness Expedition", "background": "Xiao H is an explorer. He has left his footprints on Mount Everest, the vast African savanna, and the beautiful yet frigid Antarctic continent. This time, he heads to the Amazon rainforest in South America, a place full of venomous insects, ferocious beasts, and all kinds of legends. He spent a lot of time preparing for this exciting expedition. Once ready, Xiao H and his assistant, led by a local guide, stepped into the rainforest.", "description": "Using a GPS system, they obtained a rough map of the rainforest. The map is an $n$-by-$m$ character grid: '.' denotes empty ground, '*' denotes impassable terrain, '#' denotes an area that needs to be cleared, and 'H' marks Xiao H's position, which is also empty ground.\n\nThere are $t$ types of movements, denoted by $a[i]$, $b[i]$ ($1 \\leq i \\leq t$). If they are currently at row $x$, column $y$, then their next position can be row $x + a[i]$, column $y + b[i]$, or the opposite direction, row $x - a[i]$, column $y - b[i]$. Each day, they may choose exactly one movement type and move a positive number of steps continuously in the forward or backward direction, then stop; they are not allowed to stay put.\n\nDuring that day’s movement, they may not enter any impassable cells ('*'). If they reach a cell marked '#', they stop moving immediately. For the rest of the day, they clear that cell; afterwards, it permanently becomes empty ground ('.').\n\nThey send you $q$ queries over the network, asking for the number of cells they can reach on day $d[i]$ ($1 \\leq i \\leq q$). It is guaranteed that there is no situation where they cannot move at all. Can you help them?", "inputFormat": "- The first line contains three positive integers $n$, $m$, and $t$.\n- Lines $2$ to $n+1$: each line contains $m$ characters (each is one of '.', '*', '#', 'H'; there is exactly one 'H').\n- Lines $n+2$ to $n+t+1$: each line contains two integers $a[i]$ and $b[i]$ (not both $0$).\n- Line $n+t+2$: a single integer $q$.\n- Lines $n+t+3$ to $n+t+q+2$: each of the next $q$ lines contains one integer $d[i]$, the queried day.", "outputFormat": "Output $q$ lines. For each query, output the number of cells that can be reached on day $d[i]$.", "hint": "Constraints:\n- For 20% of the testdata, $n, m \\leq 4$, $q \\leq 100$.\n- For 70% of the testdata, $n, m \\leq 300$.\n- For 100% of the testdata, $n, m \\leq 1000$, $t \\leq 5$, $q \\leq 1000$, $0 \\leq d[i] \\leq 10^9$.\n\nHEOI 2012 Day 2 Task 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2012] 野外探险", "background": "小 H 是一位探险家。在险峻的珠穆朗玛峰，原始辽阔的非洲大草原，美丽冻人的南极大陆等地方都留下过这位探险家的足迹。这次，他来到了位于南美洲充斥着大量毒虫猛兽的以及各式各样传说的亚马逊热带雨林进行探险。为此，他花了许多时间来准备这次激动人心的探险。在准备就绪后，小 H 和他的助手在当地导游的带领下踏入了这片雨林。 ", "description": "通过 GPS 定位系统，他们获得了雨林大致的地图。这个地图是一个 $n$ 行 $m$ 列的字符网格图，’.’表示的是空地，’*’表示的是不可通行的区域，’#’表示的是需要清理的区域，’H’表示小H所在的位置，该区域是空地。他们的移动方式有 $t$ 种，用$a[i]$,$b[i]$($1\\leq i\\leq t$)表示，假设他们所在的位置为第 $x$ 行第 $y$ 列，那么他们下一步的位置将是第 $x+a[i]$行第 $y+b[i]$列，也可以是反方向，即第 $x-a[i]$行第 $y-b[i]$列。小 H 一行人每天可在选择一种移动方式，朝着正方向或者反方向连续走若干步之后停下，不可以不走。在当天的行走过程中，他们不可以到达不可通行的区域，如果他们到达了一个需要清理的区域，他们会停止移动。为了以后探险的方便，他们会用该天剩下的时间来清理该区域，之后该区域将永久变成空地。\n\n现在，为了使探险活动顺利的进行，他们将 $q$ 个询问通过网络发送给了你，询问他们在第 $d[i]$($1\\leq i\\leq q$)天能到达的区域个数，题目保证不会有无路可走的情况。你能帮助他解决这个问题吗？ ", "inputFormat": "输入的第 $1$ 行包含三个正整数，分别表示 $n$、$m$、$t$。\n\n在第 $2$ 行至第 $n+1$ 行中，每行都有 $m$ 个字符（只可能是’.’，’*’，’#’，’H’，其中’H’ 有且只有一个）。 \n\n在第 $n+2$ 行至第 $n+t+1$行中，每行有两个整数，分别表示 $a[i]$，$b[i]$（$a[i]$，$b[i]$不可能同时为 $0$）。 \n\n在第 $n+t+2$ 行包含一个正整数，表示 $q$。 \n\n在第 $n+t+3$ 行至第 $n+t+q+2$ 行共有 $q$ 个整数，表示他们所询问的时间点（即 $d[i]$）。 ", "outputFormat": "输出共 $q$ 行，对于每一个询问，输出他们所能走到的地点的个数。 ", "hint": "对于 20%的数据，满足 $n,m\\leq4$, $q\\leq100$；\n\n对于 70%的数据，满足 $n,m\\leq300$；\n\n对于 100%的数据，满足 $n,m\\leq1000$, $t\\leq5$, $q\\leq1000$, $0\\leq d[i]\\leq10^9$； \n\n\nHEOI 2012 Day2 Task3", "locale": "zh-CN"}}}
{"pid": "P4602", "type": "P", "difficulty": 6, "samples": [["3 4\n1 3 5\n2 1 3\n3 2 5\n6 3\n5 3\n10 10\n20 10", "3\n2\n-1\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "线段树", "二分", "O2优化", "可持久化", "整体二分", "CTSC/CTS"], "title": "[CTSC2018] 混合果汁", "background": "", "description": "小 R 热衷于做黑暗料理，尤其是混合果汁。\n\n商店里有 $n$ 种果汁，编号为 $0,1,\\cdots,n-1$ 。$i$ 号果汁的美味度是 $d_i$，每升价格为 $p_i$。小 R 在制作混合果汁时，还有一些特殊的规定，即在一瓶混合果汁中，$i$ 号果汁最多只能添加 $l_i$ 升。\n\n现在有 $m$ 个小朋友过来找小 R 要混合果汁喝，他们都希望小 R 用商店里的果汁制作成一瓶混合果汁。其中，第 $j$ 个小朋友希望他得到的混合果汁总价格不大于 $g_j$，体积不小于 $L_j$。在上述这些限制条件下，小朋友们还希望混合果汁的美味度尽可能地高，一瓶混合果汁的美味度等于所有参与混合的果汁的美味度的最小值。请你计算每个小朋友能喝到的最美味的混合果汁的美味度。", "inputFormat": "输入第一行包含两个正整数 $n, m$，表示果汁的种数和小朋友的数量。\n\n接下来 $n$ 行，每行三个正整数 $d_i, p_i, l_i$，表示 $i$ 号果汁的美味度为 $d_i$，每升价格为 $p_i$，在一瓶果汁中的添加上限为 $l_i$。\n\n接下来 $m$ 行依次描述所有小朋友：每行两个数正整数 $g_j, L_j$ 描述一个小朋友，表示他最多能支付 $g_j$ 元钱，他想要至少 $L_j$ 升果汁。", "outputFormat": "对于所有小朋友依次输出：对于每个小朋友，输出一行，包含一个整数，表示他能喝到的最美味的混合果汁的美味度。如果无法满足他的需求，则输出 $-1$。\n", "hint": "对于所有的测试数据，保证 $n, m \\le 100000$，$1 \\le d_i,p_i,l_i \\le 10^5$，$1 \\le g_j, L_j \\le 10^{18}$。\n\n测试点编号|$n=$|$m=$|其他限制\n-|-|-|-\n$1,2,3$|$10$|$10$|无\n$4,5,6$|$500$|$500$|无\n$7,8,9$|$5000$|$5000$|无\n$10,11,12$|$100000$|$100000$|$p_i=1$\n$13,14,15$|$100000$|$100000$|$l_i=1$\n$16,17,18,19,20$|$100000$|$100000$|无", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2018] Mixed Juice", "background": "", "description": "Little R is obsessed with making “dark cuisine”, especially mixed juice.\n\nThere are $n$ kinds of juice in the store, numbered $0,1,\\cdots,n-1$. The deliciousness of juice $i$ is $d_i$, and its price per liter is $p_i$. When making mixed juice, Little R also has some special rules: in a bottle of mixed juice, juice $i$ can be added at most $l_i$ liters.\n\nNow $m$ children come to Little R for mixed juice. They all want Little R to use the juices in the store to make a bottle of mixed juice for them. For the $j$-th child, they want the total price of the mixed juice to be no more than $g_j$, and the volume to be at least $L_j$. Under these constraints, the children also hope the deliciousness of the mixed juice is as high as possible. The deliciousness of a bottle of mixed juice equals the minimum deliciousness among all juices that participate in the mixture. Please compute the highest deliciousness each child can get.", "inputFormat": "The first line contains two positive integers $n, m$, the number of kinds of juice and the number of children.\n\nThe next $n$ lines each contain three positive integers $d_i, p_i, l_i$, meaning the deliciousness of juice $i$ is $d_i$, its price per liter is $p_i$, and its addition limit in one bottle is $l_i$ liters.\n\nThe next $m$ lines describe all children: each line contains two positive integers $g_j, L_j$, meaning the $j$-th child can pay at most $g_j$ yuan, and wants at least $L_j$ liters of juice.", "outputFormat": "For all children in order, output one line for each child containing an integer, the highest deliciousness of the mixed juice they can drink. If their request cannot be satisfied, output $-1$.", "hint": "For all testdata, it is guaranteed that $n, m \\le 100000$, $1 \\le d_i,p_i,l_i \\le 10^5$, $1 \\le g_j, L_j \\le 10^{18}$.\n\n测试点编号|$n=$|$m=$|其他限制\n-|-|-|-\n$1,2,3$|$10$|$10$|None\n$4,5,6$|$500$|$500$|None\n$7,8,9$|$5000$|$5000$|None\n$10,11,12$|$100000$|$100000$|$p_i=1$\n$13,14,15$|$100000$|$100000$|$l_i=1$\n$16,17,18,19,20$|$100000$|$100000$|None\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2018] 混合果汁", "background": "", "description": "小 R 热衷于做黑暗料理，尤其是混合果汁。\n\n商店里有 $n$ 种果汁，编号为 $0,1,\\cdots,n-1$ 。$i$ 号果汁的美味度是 $d_i$，每升价格为 $p_i$。小 R 在制作混合果汁时，还有一些特殊的规定，即在一瓶混合果汁中，$i$ 号果汁最多只能添加 $l_i$ 升。\n\n现在有 $m$ 个小朋友过来找小 R 要混合果汁喝，他们都希望小 R 用商店里的果汁制作成一瓶混合果汁。其中，第 $j$ 个小朋友希望他得到的混合果汁总价格不大于 $g_j$，体积不小于 $L_j$。在上述这些限制条件下，小朋友们还希望混合果汁的美味度尽可能地高，一瓶混合果汁的美味度等于所有参与混合的果汁的美味度的最小值。请你计算每个小朋友能喝到的最美味的混合果汁的美味度。", "inputFormat": "输入第一行包含两个正整数 $n, m$，表示果汁的种数和小朋友的数量。\n\n接下来 $n$ 行，每行三个正整数 $d_i, p_i, l_i$，表示 $i$ 号果汁的美味度为 $d_i$，每升价格为 $p_i$，在一瓶果汁中的添加上限为 $l_i$。\n\n接下来 $m$ 行依次描述所有小朋友：每行两个数正整数 $g_j, L_j$ 描述一个小朋友，表示他最多能支付 $g_j$ 元钱，他想要至少 $L_j$ 升果汁。", "outputFormat": "对于所有小朋友依次输出：对于每个小朋友，输出一行，包含一个整数，表示他能喝到的最美味的混合果汁的美味度。如果无法满足他的需求，则输出 $-1$。\n", "hint": "对于所有的测试数据，保证 $n, m \\le 100000$，$1 \\le d_i,p_i,l_i \\le 10^5$，$1 \\le g_j, L_j \\le 10^{18}$。\n\n测试点编号|$n=$|$m=$|其他限制\n-|-|-|-\n$1,2,3$|$10$|$10$|无\n$4,5,6$|$500$|$500$|无\n$7,8,9$|$5000$|$5000$|无\n$10,11,12$|$100000$|$100000$|$p_i=1$\n$13,14,15$|$100000$|$100000$|$l_i=1$\n$16,17,18,19,20$|$100000$|$100000$|无", "locale": "zh-CN"}}}
{"pid": "P4603", "type": "P", "difficulty": 7, "samples": [["1\n2,?3,2?71?4420?2641?\n0 1 2 3 4 5 6 7 8 6 10 7 4 4 14 3 2 1 1 0", "2,13,207104420026411\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "O2优化", "CTSC/CTS"], "title": "[CTSC2018] 字典树", "background": "", "description": "Access Globe 有若干个**递增**的正整数序列。他把这些正整数序列中的每个正整数的十进制表示（无前导零）依次写了下来，相邻两个整数之间用逗号 , 隔开。Access Globe 把这个序列视为一个由 $0\\sim 9$ 的数字和逗号 , 组成的字符串，然后用一棵 Trie 树存储这些字符串。你并不需要知道 Trie 树究竟是什么，你只需要知道，Access Globe 得到的 Trie 是一棵以 $0$ 号节点为根的有根树，每条边上都有一个字符，并且从根到每个叶节点的路径上的边上的字符顺次拼接构成的字符串是一个他写下的一个递增的正整数序列。\n\n可爱的小 Tommy 决定篡改这棵 Trie 树。他先将 Trie 上的一些边上的字符删去，然后填上另一些字符。为了不被发现，Tommy 必须保证修改后的 Trie 仍然满足上述性 质，即从根到每个叶节点的路径上的边上的字符顺次拼接构成的字符串是一个递增的正整数序列，且每个正整数无前导零。\n\n现在 Tommy 已经删去了一些边上的字符，请你帮他完成“填上字符”的操作。如果有多解，请输出字典序最小的解。", "inputFormat": "输入文件包含多组数据，整个文件的第一行是一个整数 $T$，表示数据组数。对于每一组数据：\n\n第一行包含一个长度为 $n$ 的、仅包含 $0$ 到 $9$、, 和 `?` 的字符串，第 $i$ 个整数表示连接节点 $i$ 的父亲和节点 $i$ 的边上的字符，`?` 表示这条边上的字符已经被删去； 第二行包含 $n$ 个整数，第 $i$ 个整数表示节点 $i$ 的父亲节点 $f_i$，保证 $0 \\le f_i < i$。", "outputFormat": "输出 $T$ 行。对于每组数据，输出一个长度为 $n$ 的字符串，表示字典序最小的填写问号的方式中每个点的字符，第 $i$ 个整数表示节点 $i$ 的字符。\n\n如果不存在任何合法的填写方式，请输出 `failed`。\n", "hint": "### 样例解释\n\nTommy 填写的 Trie 如下图，红色的节点为所有叶子节点，注意，根节点在左下方。\n\n![](https://cdn.luogu.com.cn/upload/pic/19267.png)\n\n### 数据范围\n\n对于 $20\\%$ 的数据，$T \\le 10$，对于每组数据 $n \\le 80$ ，`?` 个数不超过 $8$；  \n对于另外 $10\\%$ 的数据，$T \\le 20$，对于每组数据 $n \\le 80$，$f_i=i-1$；  \n对于另外 $20\\%$ 的数据，$f_i=i-1$；  \n对于另外 $10\\%$ 的数据，$n \\le 80$；  \n对于所有数据，$T \\le 100$，对于每组数据 $n \\le 200$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2018] Trie", "background": "", "description": "Access Globe has several **strictly increasing** sequences of positive integers. He writes down the decimal representation (without leading zeros) of each positive integer in these sequences in order, separating every two adjacent integers with a comma `,`. Access Globe treats each such sequence as a string consisting of digits $0 \\sim 9$ and commas `,`, and then stores these strings in a Trie. You do not need to know what a Trie actually is. You only need to know that the Trie obtained by Access Globe is a rooted tree with node $0$ as the root, each edge labeled with a character, and for every path from the root to a leaf, the characters on the edges along the path, concatenated in order, form one of the strictly increasing positive integer sequences he wrote down.\n\nCute little Tommy decides to tamper with this Trie. He first deletes the characters on some edges of the Trie, and then fills in some other characters. To avoid being discovered, Tommy must ensure that the modified Trie still satisfies the property above: for every path from the root to a leaf, the characters on the edges along the path, concatenated in order, form a strictly increasing sequence of positive integers, and each positive integer has no leading zeros.\n\nNow Tommy has already deleted the characters on some edges. Please help him complete the “fill in characters” operation. If there are multiple solutions, output the lexicographically smallest one.", "inputFormat": "The input file contains multiple test cases. The first line of the file is an integer $T$, which indicates the number of test cases. For each test case:\n\nThe first line contains a string of length $n$ consisting only of `0` to `9`, `,`, and `?`. The $i$-th character represents the character on the edge connecting node $i$ and its parent. `?` means that the character on this edge has been deleted.  \nThe second line contains $n$ integers. The $i$-th integer represents the parent node $f_i$ of node $i$. It is guaranteed that $0 \\le f_i < i$.", "outputFormat": "Output $T$ lines. For each test case, output a string of length $n$, representing, among all ways to fill in the question marks, the lexicographically smallest one. The $i$-th character represents the character of node $i$.\n\nIf there is no valid way to fill in the characters, output `failed`.", "hint": "### Sample Explanation\n\nThe Trie filled in by Tommy is shown in the figure below. The red nodes are all leaf nodes. Note that the root node is at the lower left.\n\n![](https://cdn.luogu.com.cn/upload/pic/19267.png)\n\n### Constraints\n\nFor $20\\%$ of the testdata, $T \\le 10$, and for each test case $n \\le 80$, with the number of `?` not exceeding $8$;  \nFor another $10\\%$ of the testdata, $T \\le 20$, and for each test case $n \\le 80$, $f_i = i - 1$;  \nFor another $20\\%$ of the testdata, $f_i = i - 1$;  \nFor another $10\\%$ of the testdata, $n \\le 80$;  \nFor all testdata, $T \\le 100$, and for each test case $n \\le 200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2018] 字典树", "background": "", "description": "Access Globe 有若干个**递增**的正整数序列。他把这些正整数序列中的每个正整数的十进制表示（无前导零）依次写了下来，相邻两个整数之间用逗号 , 隔开。Access Globe 把这个序列视为一个由 $0\\sim 9$ 的数字和逗号 , 组成的字符串，然后用一棵 Trie 树存储这些字符串。你并不需要知道 Trie 树究竟是什么，你只需要知道，Access Globe 得到的 Trie 是一棵以 $0$ 号节点为根的有根树，每条边上都有一个字符，并且从根到每个叶节点的路径上的边上的字符顺次拼接构成的字符串是一个他写下的一个递增的正整数序列。\n\n可爱的小 Tommy 决定篡改这棵 Trie 树。他先将 Trie 上的一些边上的字符删去，然后填上另一些字符。为了不被发现，Tommy 必须保证修改后的 Trie 仍然满足上述性 质，即从根到每个叶节点的路径上的边上的字符顺次拼接构成的字符串是一个递增的正整数序列，且每个正整数无前导零。\n\n现在 Tommy 已经删去了一些边上的字符，请你帮他完成“填上字符”的操作。如果有多解，请输出字典序最小的解。", "inputFormat": "输入文件包含多组数据，整个文件的第一行是一个整数 $T$，表示数据组数。对于每一组数据：\n\n第一行包含一个长度为 $n$ 的、仅包含 $0$ 到 $9$、, 和 `?` 的字符串，第 $i$ 个整数表示连接节点 $i$ 的父亲和节点 $i$ 的边上的字符，`?` 表示这条边上的字符已经被删去； 第二行包含 $n$ 个整数，第 $i$ 个整数表示节点 $i$ 的父亲节点 $f_i$，保证 $0 \\le f_i < i$。", "outputFormat": "输出 $T$ 行。对于每组数据，输出一个长度为 $n$ 的字符串，表示字典序最小的填写问号的方式中每个点的字符，第 $i$ 个整数表示节点 $i$ 的字符。\n\n如果不存在任何合法的填写方式，请输出 `failed`。\n", "hint": "### 样例解释\n\nTommy 填写的 Trie 如下图，红色的节点为所有叶子节点，注意，根节点在左下方。\n\n![](https://cdn.luogu.com.cn/upload/pic/19267.png)\n\n### 数据范围\n\n对于 $20\\%$ 的数据，$T \\le 10$，对于每组数据 $n \\le 80$ ，`?` 个数不超过 $8$；  \n对于另外 $10\\%$ 的数据，$T \\le 20$，对于每组数据 $n \\le 80$，$f_i=i-1$；  \n对于另外 $20\\%$ 的数据，$f_i=i-1$；  \n对于另外 $10\\%$ 的数据，$n \\le 80$；  \n对于所有数据，$T \\le 100$，对于每组数据 $n \\le 200$。", "locale": "zh-CN"}}}
{"pid": "P4604", "type": "P", "difficulty": 7, "samples": [["1\n100000 2017012501", "4275990336"], ["2\n6 6\n200100\n200211\n5 3 1\n2 0 1\n2 0 3\n2 0 2\n2 3 4\n0 1 3", "3349208141"], ["3\n4\n(???", "2"], ["3\n4\n)???", "0"]], "limits": {"time": [3000, 4000, 6000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2017", "O2优化", "WC"], "title": "[WC2017] 挑战", "background": "### 洛谷不保证此类毒瘤题的评测结果准确性。\n\n你和同学们找了三道题目用来练习。\n\n这次练习的目标是写出能在时间限制里通过尽量大规模数据的代码。\n\n同学们纷纷写出了优秀的代码。现在，他们向你发起了挑战，他们对每个问题都设置了若干个测试数据，这是他们能通过的最大规模的测试数据。现在，他们想看一看你写的代码究竟能超过多少同学的代码，通过多大规模的测试数据。\n\n本题分为 $3$ 个任务，每个任务对应一道题和相应的若干个测试点，你需要对于每个任务，设计一个能通过尽量多测试点的程序。", "description": "## 任务一\n\n给定 $n$ 个 $32$ 位无符号整数，将它们从小到大排序。\n\n## 任务二\n\n有 $2n$ 个人在玩 「石头剪刀布」 游戏。他们排成两排，每排 $n$ 个人。每个人在每一局游戏都使用固定策略，即对于第 $i (i \\in 1, 2)$ 排的第 $j (0 \\leq j < n)$ 个人，用一个整数 $a_{ij}$ 表示他的策略，其中 $0$ 表示只出石头，$1$ 表示只出剪刀，$2$ 表示只出布。\n\n现在有 $q$ 个询问，每个询问给定三个整数 $x,y,l(0\\leq x,y<n,1\\leq l\\leq n-max(x,y))$， 问将第一排的第 $x∼x+l-1$ 个人和第二排的第 $y∼y+l-1$ 个人比赛之后，第一排有多少个人会赢。\n\n上文中 「比赛」 的意思是，对于所有整数 $i$ 满足 $0\\leq i<l$,让第一排的第 $x+i$ 个人和 第二排的第 $y+i$ 个人进行 「石头剪刀布」 游戏。\n\n## 任务三\n\n我们称一个合法的括号串为：只由左括号和右括号构成，两种括号的数量相等， 且任意一个前缀的左括号数量不少于右括号数量的串。现在给定一个由 ```(```，```)``` 和```?``` 构成的串，问有多少种不同的方案，使得将每个 ```?``` 都替换成一个括号之后，该串变成一 个合法的括号串。两种方案不同，当且仅当至少有一个位置的 ```?``` 被替换成了不同的括号。", "inputFormat": "此题提供了模板程序。选手可以在此基础上编写自己的程序，模板程序详见下文数据范围与提示。\n\n第一行一个整数$ task\\_id(1\\leq task\\_id\\leq3)$，表示任务编号。接下来是每个具体任务的输入内容。\n\n在输入的同一行中，相邻的两个整数会被一个空格隔开。\n\n对于任务一：一行，两个整数 $n,s$。令 $a_0=next\\_integer(s),a_i=next\\_integer(a_{i-1}),1\\leq i<n$，则 $a_0,a_1,…,a_{n-1}$ 即为需要排序的 $n$ 个整数。\n\n对于任务二：第一行两个整数 $n,q$。第二行一个仅包含 $0, 1, 2$ 的长度为 $n$ 的字符串，第 $i$ 个字符所代表的整数表示第一排第 $i$ 个人的策略（即 $a_{1i}$​​）。第三行格式同第二行，表示第二排各个人的策略。\n\n对于任务三：第一行一个整数 $n$，表示给定的串的长度。第二行一个字符串，即为给定的串。", "outputFormat": "对于任务1：令 $b$ 为已经排好序的数组，调用 ```output_arr(b, n * 4)``` 即可。\n\n对于任务2：将每个询问的答案依次存入 $32$ 位无符号整数数组 $b$ 中（即，存入 $b_0,b_1,⋯,b_{q-1}$ 中），然后调用 ```output_arr(b, q * 4)``` 即可。\n\n对于任务3：输出一个整数，表示不同的方案数除以 $2^{32}$​​ 得到的余数。", "hint": "## 数据范围与提示\n\n| 任务编号 | 分值 | 测试点编号 | 数据范围与约定 | 时间限制 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| 1 | 5 | 1 | $n=100000$ | 3s |\n| 1 | 19 | 2 | $n=10^8$ | 4s |\n| 1 | 11 | 3 | $n=2\\times10^8$ | 6s |\n| 2 | 7 | 4 | $n=q=1000$ | 3s |\n| 2 | 23 | 5 | $n=q=300000$ | 3s |\n| 3 | 9 | 6 | $n=1000$ | 3s |\n| 3 | 5 | 7 | $n=120000$ | 3s |\n| 3 | 7 | 8 | $n=225000$ | 3s |\n| 3 | 14 | 9 | $n=266666$ | 3s |\n\n\n## 模板程序\n\n### C++模板\n\n```\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n\ninline u32 next_integer(u32 x) {\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return x;\n}\n\nbool output_arr(void *a, u32 size) {\n    if (size % 4) {\n        return puts(\"-1\"), 0;\n    }\n\n    u32 blocks = size / 4;\n    u32 *A = (u32 *)a;\n    u32 ret = size;\n    u32 x = 23333333;\n    for (u32 i = 0; i < blocks; i++) {\n        ret = ret ^ (A[i] + x);\n        x ^= x << 13;\n        x ^= x >> 17;\n        x ^= x << 5;\n    }\n\n    return printf(\"%u\\n\", ret), 1;\n}\n\n// ===== header ======\n\nnamespace Sorting {\nvoid init_data(u32 *a, int n, u32 seed) {\n    for (int i = 0; i < n; i++) {\n        seed = next_integer(seed);\n        a[i] = seed;\n    }\n}\n\nvoid main() {\n    int n;\n    u32 seed;\n    scanf(\"%d%u\", &n, &seed);\n\n    u32 *a = new u32[n];\n    init_data(a, n, seed);\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\n}\n}\n\nnamespace Game {\nvoid main() {\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n\n    char *s1 = new char[n + 1];\n    char *s2 = new char[n + 1];\n    scanf(\"%s%s\", s1, s2);\n\n    u32 *anss = new u32[q];\n    int *q_x = new int[q];\n    int *q_y = new int[q];\n    int *q_len = new int[q];\n\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d%d%d\", q_x + i, q_y + i, q_len + i);\n    }\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\n}\n}\n\nnamespace Parentheses {\nvoid main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char *s = new char[n + 1];\n    scanf(\"%s\", s);\n\n    u32 ans;\n    // ans = solve(n, s);\n\n    printf(\"%u\\n\", ans);\n}\n}\n\nint main() {\n    int task_id;\n    scanf(\"%d\", &task_id);\n\n    switch (task_id) {\n        case 1:\n            Sorting::main();\n            break;\n        case 2:\n            Game::main();\n            break;\n        case 3:\n            Parentheses::main();\n            break;\n    }\n\n    return 0;\n}\n```\n\n### C模板\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define bool int\n#define true 1\n#define false 0\n\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n\ninline u32 next_integer(u32 x) {\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return x;\n}\n\nbool output_arr(void *a, u32 size) {\n    if (size % 4) {\n        return puts(\"-1\"), 0;\n    }\n\n    u32 blocks = size / 4;\n    u32 *A = (u32 *)a;\n    u32 ret = size;\n    u32 x = 23333333;\n    u32 i;\n    for (i = 0; i < blocks; i++) {\n        ret = ret ^ (A[i] + x);\n        x ^= x << 13;\n        x ^= x >> 17;\n        x ^= x << 5;\n    }\n\n    return printf(\"%u\\n\", ret), 1;\n}\n\n// ===== header ======\n\nvoid Sorting_main() {\n    int n;\n    u32 seed;\n    scanf(\"%d%u\", &n, &seed);\n\n    u32 *a = malloc(n * sizeof(u32));\n    int i;\n    for (i = 0; i < n; i++) {\n        seed = next_integer(seed);\n        a[i] = seed;\n    }\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\n}\n\nvoid Game_main() {\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n\n    char *s1 = malloc((n + 1) * sizeof(char));\n    char *s2 = malloc((n + 1) * sizeof(char));\n    scanf(\"%s%s\", s1, s2);\n\n    u32 *anss = malloc(q * sizeof(u32));\n    int *q_x = malloc(q * sizeof(int));\n    int *q_y = malloc(q * sizeof(int));\n    int *q_len = malloc(q * sizeof(int));\n\n    int i;\n\n    for (i = 0; i < q; i++) {\n        scanf(\"%d%d%d\", q_x + i, q_y + i, q_len + i);\n    }\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\n}\n\nvoid Parentheses_main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char *s = malloc((n + 1) * sizeof(char));\n    scanf(\"%s\", s);\n\n    u32 ans;\n    // ans = solve(n, s);\n\n    printf(\"%u\\n\", ans);\n}\n\nint main() {\n    int task_id;\n    scanf(\"%d\", &task_id);\n\n    switch (task_id) {\n        case 1:\n            Sorting_main();\n            break;\n        case 2:\n            Game_main();\n            break;\n        case 3:\n            Parentheses_main();\n            break;\n    }\n\n    return 0;\n}\n```\n\n### Pascal模板\n\n```\ntype\n    u32 = dword;\n    u64 = qword;\n    u32_p = ^u32;\n    u64_p = ^u64;\n    longint_p = ^longint;\n\nfunction next_integer(x : u32) : u32; inline;\nbegin\n    x := x xor (x << 13);\n    x := x xor (x >> 17);\n    x := x xor (x << 5);\n    exit(x);\nend;\n\nfunction output_arr(a_in : pointer; size : u32) : boolean;\nvar\n    blocks : u32;\n    a, a_ed : u32_p;\n    ret, x : u32;\nbegin\n    if size mod 4 <> 0 then begin\n        writeln(-1);\n        exit(false);\n    end;\n\n    blocks := size div 4;\n    ret := size;\n    a := a_in;\n    a_ed := a + blocks;\n    x := 23333333;\n\n    while a < a_ed do begin\n        ret := ret xor (a[0] + x);\n        x := x xor (x << 13);\n        x := x xor (x >> 17);\n        x := x xor (x << 5);\n        inc(a);\n    end;\n\n    writeln(ret);\n    exit(true);\nend;\n\n// ====== header ======\n\n\nprocedure init_data(a : u32_p; n : longint; seed : u32);\nvar\n    a_ed : u32_p;\nbegin\n    a_ed := a + n;\n    while a < a_ed do begin\n        seed := next_integer(seed);\n        a[0] := seed;\n        inc(a);\n    end;\nend;\n\nprocedure Sorting_main();\nvar\n    n : longint;\n    seed : u32;\n    a : u32_p;\n    i : u32;\nbegin\n    read(n, seed);\n\n    a := Getmem(n * sizeof(u32));\n    init_data(a, n, seed);\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\nend;\n\n\nprocedure Game_main();\nvar\n    n, q : longint;\n    s1, s2 : ansistring;\n    anss : u32_p;\n    q_x, q_y, q_len : longint_p;\n    i : longint;\nbegin\n    readln(n, q);\n    readln(s1);\n    readln(s2);\n\n    anss := Getmem(q * sizeof(u32));\n    q_x := Getmem(q * sizeof(longint));\n    q_y := Getmem(q * sizeof(longint));\n    q_len := Getmem(q * sizeof(longint));\n\n    for i := 0 to q - 1 do begin\n        read(q_x[i], q_y[i], q_len[i]);\n    end;\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\nend;\n\n\nprocedure Parentheses_main();\nvar\n    n : longint;\n    s : ansistring;\n    ans : u32;\nbegin\n    read(n);\n    read(s);\n\n    // ans := solve(n, s);\n\n    writeln(ans);\nend;\n\n\nvar\n    task_id : longint;\n\nbegin\n    read(task_id);\n\n    if task_id = 1 then begin\n        Sorting_main();\n    end else if task_id = 2 then begin\n        Game_main();\n    end else if task_id = 3 then begin\n        Parentheses_main();\n    end;\n    close(input); close(output);\nend.\n```", "locale": "zh-CN", "translations": {"en": {"title": "[WC2017] Challenge", "background": "### Luogu does not guarantee the accuracy of judging results for this kind of extremely tricky problem.\n\nYou and your classmates found three problems to practice.\n\nThe goal of this practice is to write code that can pass testdata of as large a size as possible within the time limit.\n\nYour classmates have written excellent code. Now, they challenge you: for each problem, they have prepared several test cases, representing the largest-scale testdata that their own code can pass. Now, they want to see how many classmates’ code your program can outperform, and how large-scale testdata it can pass.\n\nThis problem is divided into $3$ tasks. Each task corresponds to one problem and its related test points. For each task, you need to design a program that can pass as many test points as possible.", "description": "## Task 1\n\nGiven $n$ $32$-bit unsigned integers, sort them in non-decreasing order.\n\n## Task 2\n\nThere are $2n$ people playing Rock-Paper-Scissors. They stand in two rows, with $n$ people in each row. Each person uses a fixed strategy in every round. Specifically, for the $j$-th person $(0 \\leq j < n)$ in row $i$ $(i \\in 1, 2)$, use an integer $a_{ij}$ to represent their strategy, where $0$ means always play Rock, $1$ means always play Scissors, and $2$ means always play Paper.\n\nNow there are $q$ queries. Each query gives three integers $x, y, l(0\\leq x,y<n,1\\leq l\\leq n-max(x,y))$, asking: after the people from $x \\sim x+l-1$ in the first row play against the people from $y \\sim y+l-1$ in the second row, how many people in the first row will win.\n\nHere, “play against” means: for all integers $i$ such that $0 \\leq i < l$, let the person at position $x+i$ in the first row play Rock-Paper-Scissors against the person at position $y+i$ in the second row.\n\n## Task 3\n\nWe call a bracket sequence valid if it consists only of left and right parentheses, the numbers of the two types are equal, and in any prefix the number of left parentheses is not less than the number of right parentheses. Now you are given a string consisting of ```(```, ``` )``` and ```?```. How many different ways are there to replace each ```?``` with a parenthesis so that the string becomes a valid bracket sequence. Two ways are different if and only if there is at least one position where ```?``` is replaced by different parentheses.", "inputFormat": "This problem provides template code. Contestants may write their program based on it. The template code is shown below in the Constraints and Hint section.\n\nThe first line contains one integer $task\\_id(1\\leq task\\_id\\leq3)$, indicating the task number. The following input depends on the specific task.\n\nIn the same input line, any two adjacent integers are separated by a single space.\n\nFor Task 1: one line with two integers $n, s$. Let $a_0=next\\_integer(s),a_i=next\\_integer(a_{i-1}),1\\leq i<n$. Then $a_0,a_1,\\ldots,a_{n-1}$ are the $n$ integers to be sorted.\n\nFor Task 2: the first line contains two integers $n, q$. The second line contains a string of length $n$ consisting only of $0, 1, 2$. The integer represented by the $i$-th character is the strategy of the $i$-th person in the first row (i.e., $a_{1i}$). The third line has the same format as the second line, representing the strategies of the people in the second row.\n\nFor Task 3: the first line contains one integer $n$, the length of the given string. The second line contains one string, which is the given string.", "outputFormat": "For Task 1: let $b$ be the sorted array, and call ```output_arr(b, n * 4)```.\n\nFor Task 2: store the answer of each query in order into a $32$-bit unsigned integer array $b$ (i.e., into $b_0,b_1,\\cdots,b_{q-1}$), then call ```output_arr(b, q * 4)```.\n\nFor Task 3: output one integer, which is the remainder of the number of different ways modulo $2^{32}$.", "hint": "## Constraints and Hint\n\n| Task ID | Score | Test Point ID | Constraints and Notes | Time Limit |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| 1 | 5 | 1 | $n=100000$ | 3s |\n| 1 | 19 | 2 | $n=10^8$ | 4s |\n| 1 | 11 | 3 | $n=2\\times10^8$ | 6s |\n| 2 | 7 | 4 | $n=q=1000$ | 3s |\n| 2 | 23 | 5 | $n=q=300000$ | 3s |\n| 3 | 9 | 6 | $n=1000$ | 3s |\n| 3 | 5 | 7 | $n=120000$ | 3s |\n| 3 | 7 | 8 | $n=225000$ | 3s |\n| 3 | 14 | 9 | $n=266666$ | 3s |\n\n## Template Code\n\n### C++ Template\n\n```\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n\ninline u32 next_integer(u32 x) {\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return x;\n}\n\nbool output_arr(void *a, u32 size) {\n    if (size % 4) {\n        return puts(\"-1\"), 0;\n    }\n\n    u32 blocks = size / 4;\n    u32 *A = (u32 *)a;\n    u32 ret = size;\n    u32 x = 23333333;\n    for (u32 i = 0; i < blocks; i++) {\n        ret = ret ^ (A[i] + x);\n        x ^= x << 13;\n        x ^= x >> 17;\n        x ^= x << 5;\n    }\n\n    return printf(\"%u\\n\", ret), 1;\n}\n\n// ===== header ======\n\nnamespace Sorting {\nvoid init_data(u32 *a, int n, u32 seed) {\n    for (int i = 0; i < n; i++) {\n        seed = next_integer(seed);\n        a[i] = seed;\n    }\n}\n\nvoid main() {\n    int n;\n    u32 seed;\n    scanf(\"%d%u\", &n, &seed);\n\n    u32 *a = new u32[n];\n    init_data(a, n, seed);\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\n}\n}\n\nnamespace Game {\nvoid main() {\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n\n    char *s1 = new char[n + 1];\n    char *s2 = new char[n + 1];\n    scanf(\"%s%s\", s1, s2);\n\n    u32 *anss = new u32[q];\n    int *q_x = new int[q];\n    int *q_y = new int[q];\n    int *q_len = new int[q];\n\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d%d%d\", q_x + i, q_y + i, q_len + i);\n    }\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\n}\n}\n\nnamespace Parentheses {\nvoid main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char *s = new char[n + 1];\n    scanf(\"%s\", s);\n\n    u32 ans;\n    // ans = solve(n, s);\n\n    printf(\"%u\\n\", ans);\n}\n}\n\nint main() {\n    int task_id;\n    scanf(\"%d\", &task_id);\n\n    switch (task_id) {\n        case 1:\n            Sorting::main();\n            break;\n        case 2:\n            Game::main();\n            break;\n        case 3:\n            Parentheses::main();\n            break;\n    }\n\n    return 0;\n}\n```\n\n### C Template\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define bool int\n#define true 1\n#define false 0\n\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n\ninline u32 next_integer(u32 x) {\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return x;\n}\n\nbool output_arr(void *a, u32 size) {\n    if (size % 4) {\n        return puts(\"-1\"), 0;\n    }\n\n    u32 blocks = size / 4;\n    u32 *A = (u32 *)a;\n    u32 ret = size;\n    u32 x = 23333333;\n    u32 i;\n    for (i = 0; i < blocks; i++) {\n        ret = ret ^ (A[i] + x);\n        x ^= x << 13;\n        x ^= x >> 17;\n        x ^= x << 5;\n    }\n\n    return printf(\"%u\\n\", ret), 1;\n}\n\n// ===== header ======\n\nvoid Sorting_main() {\n    int n;\n    u32 seed;\n    scanf(\"%d%u\", &n, &seed);\n\n    u32 *a = malloc(n * sizeof(u32));\n    int i;\n    for (i = 0; i < n; i++) {\n        seed = next_integer(seed);\n        a[i] = seed;\n    }\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\n}\n\nvoid Game_main() {\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n\n    char *s1 = malloc((n + 1) * sizeof(char));\n    char *s2 = malloc((n + 1) * sizeof(char));\n    scanf(\"%s%s\", s1, s2);\n\n    u32 *anss = malloc(q * sizeof(u32));\n    int *q_x = malloc(q * sizeof(int));\n    int *q_y = malloc(q * sizeof(int));\n    int *q_len = malloc(q * sizeof(int));\n\n    int i;\n\n    for (i = 0; i < q; i++) {\n        scanf(\"%d%d%d\", q_x + i, q_y + i, q_len + i);\n    }\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\n}\n\nvoid Parentheses_main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char *s = malloc((n + 1) * sizeof(char));\n    scanf(\"%s\", s);\n\n    u32 ans;\n    // ans = solve(n, s);\n\n    printf(\"%u\\n\", ans);\n}\n\nint main() {\n    int task_id;\n    scanf(\"%d\", &task_id);\n\n    switch (task_id) {\n        case 1:\n            Sorting_main();\n            break;\n        case 2:\n            Game_main();\n            break;\n        case 3:\n            Parentheses_main();\n            break;\n    }\n\n    return 0;\n}\n```\n\n### Pascal Template\n\n```\ntype\n    u32 = dword;\n    u64 = qword;\n    u32_p = ^u32;\n    u64_p = ^u64;\n    longint_p = ^longint;\n\nfunction next_integer(x : u32) : u32; inline;\nbegin\n    x := x xor (x << 13);\n    x := x xor (x >> 17);\n    x := x xor (x << 5);\n    exit(x);\nend;\n\nfunction output_arr(a_in : pointer; size : u32) : boolean;\nvar\n    blocks : u32;\n    a, a_ed : u32_p;\n    ret, x : u32;\nbegin\n    if size mod 4 <> 0 then begin\n        writeln(-1);\n        exit(false);\n    end;\n\n    blocks := size div 4;\n    ret := size;\n    a := a_in;\n    a_ed := a + blocks;\n    x := 23333333;\n\n    while a < a_ed do begin\n        ret := ret xor (a[0] + x);\n        x := x xor (x << 13);\n        x := x xor (x >> 17);\n        x := x xor (x << 5);\n        inc(a);\n    end;\n\n    writeln(ret);\n    exit(true);\nend;\n\n// ====== header ======\n\n\nprocedure init_data(a : u32_p; n : longint; seed : u32);\nvar\n    a_ed : u32_p;\nbegin\n    a_ed := a + n;\n    while a < a_ed do begin\n        seed := next_integer(seed);\n        a[0] := seed;\n        inc(a);\n    end;\nend;\n\nprocedure Sorting_main();\nvar\n    n : longint;\n    seed : u32;\n    a : u32_p;\n    i : u32;\nbegin\n    read(n, seed);\n\n    a := Getmem(n * sizeof(u32));\n    init_data(a, n, seed);\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\nend;\n\n\nprocedure Game_main();\nvar\n    n, q : longint;\n    s1, s2 : ansistring;\n    anss : u32_p;\n    q_x, q_y, q_len : longint_p;\n    i : longint;\nbegin\n    readln(n, q);\n    readln(s1);\n    readln(s2);\n\n    anss := Getmem(q * sizeof(u32));\n    q_x := Getmem(q * sizeof(longint));\n    q_y := Getmem(q * sizeof(longint));\n    q_len := Getmem(q * sizeof(longint));\n\n    for i := 0 to q - 1 do begin\n        read(q_x[i], q_y[i], q_len[i]);\n    end;\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\nend;\n\n\nprocedure Parentheses_main();\nvar\n    n : longint;\n    s : ansistring;\n    ans : u32;\nbegin\n    read(n);\n    read(s);\n\n    // ans := solve(n, s);\n\n    writeln(ans);\nend;\n\n\nvar\n    task_id : longint;\n\nbegin\n    read(task_id);\n\n    if task_id = 1 then begin\n        Sorting_main();\n    end else if task_id = 2 then begin\n        Game_main();\n    end else if task_id = 3 then begin\n        Parentheses_main();\n    end;\n    close(input); close(output);\nend.\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2017] 挑战", "background": "### 洛谷不保证此类毒瘤题的评测结果准确性。\n\n你和同学们找了三道题目用来练习。\n\n这次练习的目标是写出能在时间限制里通过尽量大规模数据的代码。\n\n同学们纷纷写出了优秀的代码。现在，他们向你发起了挑战，他们对每个问题都设置了若干个测试数据，这是他们能通过的最大规模的测试数据。现在，他们想看一看你写的代码究竟能超过多少同学的代码，通过多大规模的测试数据。\n\n本题分为 $3$ 个任务，每个任务对应一道题和相应的若干个测试点，你需要对于每个任务，设计一个能通过尽量多测试点的程序。", "description": "## 任务一\n\n给定 $n$ 个 $32$ 位无符号整数，将它们从小到大排序。\n\n## 任务二\n\n有 $2n$ 个人在玩 「石头剪刀布」 游戏。他们排成两排，每排 $n$ 个人。每个人在每一局游戏都使用固定策略，即对于第 $i (i \\in 1, 2)$ 排的第 $j (0 \\leq j < n)$ 个人，用一个整数 $a_{ij}$ 表示他的策略，其中 $0$ 表示只出石头，$1$ 表示只出剪刀，$2$ 表示只出布。\n\n现在有 $q$ 个询问，每个询问给定三个整数 $x,y,l(0\\leq x,y<n,1\\leq l\\leq n-max(x,y))$， 问将第一排的第 $x∼x+l-1$ 个人和第二排的第 $y∼y+l-1$ 个人比赛之后，第一排有多少个人会赢。\n\n上文中 「比赛」 的意思是，对于所有整数 $i$ 满足 $0\\leq i<l$,让第一排的第 $x+i$ 个人和 第二排的第 $y+i$ 个人进行 「石头剪刀布」 游戏。\n\n## 任务三\n\n我们称一个合法的括号串为：只由左括号和右括号构成，两种括号的数量相等， 且任意一个前缀的左括号数量不少于右括号数量的串。现在给定一个由 ```(```，```)``` 和```?``` 构成的串，问有多少种不同的方案，使得将每个 ```?``` 都替换成一个括号之后，该串变成一 个合法的括号串。两种方案不同，当且仅当至少有一个位置的 ```?``` 被替换成了不同的括号。", "inputFormat": "此题提供了模板程序。选手可以在此基础上编写自己的程序，模板程序详见下文数据范围与提示。\n\n第一行一个整数$ task\\_id(1\\leq task\\_id\\leq3)$，表示任务编号。接下来是每个具体任务的输入内容。\n\n在输入的同一行中，相邻的两个整数会被一个空格隔开。\n\n对于任务一：一行，两个整数 $n,s$。令 $a_0=next\\_integer(s),a_i=next\\_integer(a_{i-1}),1\\leq i<n$，则 $a_0,a_1,…,a_{n-1}$ 即为需要排序的 $n$ 个整数。\n\n对于任务二：第一行两个整数 $n,q$。第二行一个仅包含 $0, 1, 2$ 的长度为 $n$ 的字符串，第 $i$ 个字符所代表的整数表示第一排第 $i$ 个人的策略（即 $a_{1i}$​​）。第三行格式同第二行，表示第二排各个人的策略。\n\n对于任务三：第一行一个整数 $n$，表示给定的串的长度。第二行一个字符串，即为给定的串。", "outputFormat": "对于任务1：令 $b$ 为已经排好序的数组，调用 ```output_arr(b, n * 4)``` 即可。\n\n对于任务2：将每个询问的答案依次存入 $32$ 位无符号整数数组 $b$ 中（即，存入 $b_0,b_1,⋯,b_{q-1}$ 中），然后调用 ```output_arr(b, q * 4)``` 即可。\n\n对于任务3：输出一个整数，表示不同的方案数除以 $2^{32}$​​ 得到的余数。", "hint": "## 数据范围与提示\n\n| 任务编号 | 分值 | 测试点编号 | 数据范围与约定 | 时间限制 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| 1 | 5 | 1 | $n=100000$ | 3s |\n| 1 | 19 | 2 | $n=10^8$ | 4s |\n| 1 | 11 | 3 | $n=2\\times10^8$ | 6s |\n| 2 | 7 | 4 | $n=q=1000$ | 3s |\n| 2 | 23 | 5 | $n=q=300000$ | 3s |\n| 3 | 9 | 6 | $n=1000$ | 3s |\n| 3 | 5 | 7 | $n=120000$ | 3s |\n| 3 | 7 | 8 | $n=225000$ | 3s |\n| 3 | 14 | 9 | $n=266666$ | 3s |\n\n\n## 模板程序\n\n### C++模板\n\n```\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n\ninline u32 next_integer(u32 x) {\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return x;\n}\n\nbool output_arr(void *a, u32 size) {\n    if (size % 4) {\n        return puts(\"-1\"), 0;\n    }\n\n    u32 blocks = size / 4;\n    u32 *A = (u32 *)a;\n    u32 ret = size;\n    u32 x = 23333333;\n    for (u32 i = 0; i < blocks; i++) {\n        ret = ret ^ (A[i] + x);\n        x ^= x << 13;\n        x ^= x >> 17;\n        x ^= x << 5;\n    }\n\n    return printf(\"%u\\n\", ret), 1;\n}\n\n// ===== header ======\n\nnamespace Sorting {\nvoid init_data(u32 *a, int n, u32 seed) {\n    for (int i = 0; i < n; i++) {\n        seed = next_integer(seed);\n        a[i] = seed;\n    }\n}\n\nvoid main() {\n    int n;\n    u32 seed;\n    scanf(\"%d%u\", &n, &seed);\n\n    u32 *a = new u32[n];\n    init_data(a, n, seed);\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\n}\n}\n\nnamespace Game {\nvoid main() {\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n\n    char *s1 = new char[n + 1];\n    char *s2 = new char[n + 1];\n    scanf(\"%s%s\", s1, s2);\n\n    u32 *anss = new u32[q];\n    int *q_x = new int[q];\n    int *q_y = new int[q];\n    int *q_len = new int[q];\n\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d%d%d\", q_x + i, q_y + i, q_len + i);\n    }\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\n}\n}\n\nnamespace Parentheses {\nvoid main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char *s = new char[n + 1];\n    scanf(\"%s\", s);\n\n    u32 ans;\n    // ans = solve(n, s);\n\n    printf(\"%u\\n\", ans);\n}\n}\n\nint main() {\n    int task_id;\n    scanf(\"%d\", &task_id);\n\n    switch (task_id) {\n        case 1:\n            Sorting::main();\n            break;\n        case 2:\n            Game::main();\n            break;\n        case 3:\n            Parentheses::main();\n            break;\n    }\n\n    return 0;\n}\n```\n\n### C模板\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define bool int\n#define true 1\n#define false 0\n\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n\ninline u32 next_integer(u32 x) {\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return x;\n}\n\nbool output_arr(void *a, u32 size) {\n    if (size % 4) {\n        return puts(\"-1\"), 0;\n    }\n\n    u32 blocks = size / 4;\n    u32 *A = (u32 *)a;\n    u32 ret = size;\n    u32 x = 23333333;\n    u32 i;\n    for (i = 0; i < blocks; i++) {\n        ret = ret ^ (A[i] + x);\n        x ^= x << 13;\n        x ^= x >> 17;\n        x ^= x << 5;\n    }\n\n    return printf(\"%u\\n\", ret), 1;\n}\n\n// ===== header ======\n\nvoid Sorting_main() {\n    int n;\n    u32 seed;\n    scanf(\"%d%u\", &n, &seed);\n\n    u32 *a = malloc(n * sizeof(u32));\n    int i;\n    for (i = 0; i < n; i++) {\n        seed = next_integer(seed);\n        a[i] = seed;\n    }\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\n}\n\nvoid Game_main() {\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n\n    char *s1 = malloc((n + 1) * sizeof(char));\n    char *s2 = malloc((n + 1) * sizeof(char));\n    scanf(\"%s%s\", s1, s2);\n\n    u32 *anss = malloc(q * sizeof(u32));\n    int *q_x = malloc(q * sizeof(int));\n    int *q_y = malloc(q * sizeof(int));\n    int *q_len = malloc(q * sizeof(int));\n\n    int i;\n\n    for (i = 0; i < q; i++) {\n        scanf(\"%d%d%d\", q_x + i, q_y + i, q_len + i);\n    }\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\n}\n\nvoid Parentheses_main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char *s = malloc((n + 1) * sizeof(char));\n    scanf(\"%s\", s);\n\n    u32 ans;\n    // ans = solve(n, s);\n\n    printf(\"%u\\n\", ans);\n}\n\nint main() {\n    int task_id;\n    scanf(\"%d\", &task_id);\n\n    switch (task_id) {\n        case 1:\n            Sorting_main();\n            break;\n        case 2:\n            Game_main();\n            break;\n        case 3:\n            Parentheses_main();\n            break;\n    }\n\n    return 0;\n}\n```\n\n### Pascal模板\n\n```\ntype\n    u32 = dword;\n    u64 = qword;\n    u32_p = ^u32;\n    u64_p = ^u64;\n    longint_p = ^longint;\n\nfunction next_integer(x : u32) : u32; inline;\nbegin\n    x := x xor (x << 13);\n    x := x xor (x >> 17);\n    x := x xor (x << 5);\n    exit(x);\nend;\n\nfunction output_arr(a_in : pointer; size : u32) : boolean;\nvar\n    blocks : u32;\n    a, a_ed : u32_p;\n    ret, x : u32;\nbegin\n    if size mod 4 <> 0 then begin\n        writeln(-1);\n        exit(false);\n    end;\n\n    blocks := size div 4;\n    ret := size;\n    a := a_in;\n    a_ed := a + blocks;\n    x := 23333333;\n\n    while a < a_ed do begin\n        ret := ret xor (a[0] + x);\n        x := x xor (x << 13);\n        x := x xor (x >> 17);\n        x := x xor (x << 5);\n        inc(a);\n    end;\n\n    writeln(ret);\n    exit(true);\nend;\n\n// ====== header ======\n\n\nprocedure init_data(a : u32_p; n : longint; seed : u32);\nvar\n    a_ed : u32_p;\nbegin\n    a_ed := a + n;\n    while a < a_ed do begin\n        seed := next_integer(seed);\n        a[0] := seed;\n        inc(a);\n    end;\nend;\n\nprocedure Sorting_main();\nvar\n    n : longint;\n    seed : u32;\n    a : u32_p;\n    i : u32;\nbegin\n    read(n, seed);\n\n    a := Getmem(n * sizeof(u32));\n    init_data(a, n, seed);\n\n    // sort(a, n);\n\n    output_arr(a, n * sizeof(u32));\nend;\n\n\nprocedure Game_main();\nvar\n    n, q : longint;\n    s1, s2 : ansistring;\n    anss : u32_p;\n    q_x, q_y, q_len : longint_p;\n    i : longint;\nbegin\n    readln(n, q);\n    readln(s1);\n    readln(s2);\n\n    anss := Getmem(q * sizeof(u32));\n    q_x := Getmem(q * sizeof(longint));\n    q_y := Getmem(q * sizeof(longint));\n    q_len := Getmem(q * sizeof(longint));\n\n    for i := 0 to q - 1 do begin\n        read(q_x[i], q_y[i], q_len[i]);\n    end;\n\n    // solve(n, q, s1, s2, q_x, q_y, q_len, anss);\n\n    output_arr(anss, q * sizeof(u32));\nend;\n\n\nprocedure Parentheses_main();\nvar\n    n : longint;\n    s : ansistring;\n    ans : u32;\nbegin\n    read(n);\n    read(s);\n\n    // ans := solve(n, s);\n\n    writeln(ans);\nend;\n\n\nvar\n    task_id : longint;\n\nbegin\n    read(task_id);\n\n    if task_id = 1 then begin\n        Sorting_main();\n    end else if task_id = 2 then begin\n        Game_main();\n    end else if task_id = 3 then begin\n        Parentheses_main();\n    end;\n    close(input); close(output);\nend.\n```", "locale": "zh-CN"}}}
{"pid": "P4605", "type": "P", "difficulty": 7, "samples": [["3\n4\n-3 2 -1 2\n-1 -1 1 -1\n0 1 2 1\n2 -2 4 -2\n0 0 1 0 2\n4\n1 1 3 3\n2 1 4 2\n3 1 5 1\n3 -1 4 -1\n0 0 -1 0 2\n4\n-2 0 1 2\n1 3 -3 2\n1 -3 5 -1\n2 -1 4 3\n0 0 1 1 2\n", "3.000000000000000\n3.118033988749895\n4.251303782246768\n"]], "limits": {"time": [10000, 10000, 10000], "memory": [512000, 512000, 512000]}, "tags": ["2018", "各省省选", "平衡树", "山东", "Special Judge", "O2优化", "前缀和", "向量"], "title": "[SDOI2018] 物理实验", "background": "", "description": "小 T 这学期有物理实验课，为了顺利完成下一节课的实验，他打算在课前对实验内容进行预习。\n\n这次实验在一个二维平面上进行，平面上放置了一条无限长的直线导轨，导轨上放置了一个长为$L$的激光发射器，激光发射器会向导轨两侧沿导轨垂直方向发射宽度为$L$的激光束。\n\n平面上还放置了 $n$ 个挡板，每个挡板可以看作是一条线段，现在每个挡板都不和直线导轨接触，且\n和直线导轨的夹角不超过 $85\t\\degree$，任意两个挡板也不会相互接触，激光束不能穿透这些挡板，并且会被挡板吸收掉，不会被挡板反射出去。\n\n小 T 想确定一个激光发射器的位置使得被激光束照射到的挡板长度之和最大，你需要帮小 T 算出这\n个最大值。", "inputFormat": "第一行包含一个正整数 T，表示测试数据的组数。\n\n对于每组测试数据，第一行是一个整数 $n$，表示挡板个数；  \n接下来 n 行，每行包含四个整数 $x1, y1, x2, y2$，表示挡板的两端点分别是 $(x1, y1)$ 和 $(x2, y2)$，保证$(x1, y1){=}\\mathllap{/\\,}(x2, y2)$。  \n第 $n + 2$ 行是五个整数 $x1, y1, x2, y2, L$，表示直线导轨经过了点 $(x1, y1)$ 和 $(x2, y2)$，且激光发射器的长度为 $L$，同样保证 $(x1, y1)\\mathrlap{\\,/}{=}(x2, y2)$。", "outputFormat": "对于每组测试数据，输出一行，包含一个实数，表示激光束能照射到的挡板长度之和的最大值，要求相对误差不超过 $10^{-6}$，也就是说，令输出结果为 $a$，标准答案为 $b$，若满足 $\\dfrac{|a-b|}{max(1,b)}$ $≤$ $10^{-6}$，则输出结果会被认为是正确答案。", "hint": "- $T ≤ 100$\n- $1 ≤ n ≤ 10^4$，\n- $1 ≤ L ≤ 2 × 10^9$，\n- 所有坐标的绝对值不超过 $10^9$。\n\n## SubTasks\n\n- 子任务 1 (40 分)：满足 $1 ≤ n ≤ 100$ 且所有坐标的绝对值不超过 $10^4$。\n- 子任务 2 (40 分)：所有坐标的绝对值不超过 $10^6$。\n- 子任务 3 (20 分)：没有任何附加的限制。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2018] Physics Experiment", "background": "", "description": "Xiao T has a physics lab class this semester. To successfully finish the experiment in the next class, he plans to preview it before class.\n\nThis experiment is conducted on a 2D plane. On the plane there is an infinitely long straight guide rail. On the rail, there is a laser emitter of length $L$. The laser emitter emits laser beams of width $L$ to both sides of the rail along the direction perpendicular to the rail.\n\nThere are also $n$ baffles on the plane. Each baffle can be regarded as a line segment. Now each baffle does not touch the straight guide rail, and the angle between it and the rail is at most $85\\degree$. Any two baffles also do not touch each other. The laser beams cannot pass through these baffles, and will be absorbed by them, not reflected.\n\nXiao T wants to determine a position of the laser emitter such that the total length of baffles illuminated by the laser beams is maximized. You need to help Xiao T compute this maximum value.", "inputFormat": "The first line contains a positive integer $T$, indicating the number of testdata groups.\n\nFor each testdata group, the first line contains an integer $n$, indicating the number of baffles.  \nThe next $n$ lines each contain four integers $x1, y1, x2, y2$, indicating that the two endpoints of the baffle are $(x1, y1)$ and $(x2, y2)$, guaranteeing $(x1, y1){=}\\mathllap{/\\,}(x2, y2)$.  \nThe $(n + 2)$-th line contains five integers $x1, y1, x2, y2, L$, indicating that the straight guide rail passes through points $(x1, y1)$ and $(x2, y2)$, and the length of the laser emitter is $L$, also guaranteeing $(x1, y1)\\mathrlap{\\,/}{=}(x2, y2)$.", "outputFormat": "For each testdata group, output one line containing a real number, representing the maximum total length of baffles that can be illuminated by the laser beams. The relative error must not exceed $10^{-6}$, that is, let your output be $a$ and the standard answer be $b$. If $\\dfrac{|a-b|}{max(1,b)}$ $≤$ $10^{-6}$, then your output will be considered correct.", "hint": "## Constraints\n\n- $T ≤ 100$.\n- $1 ≤ n ≤ 10^4$.\n- $1 ≤ L ≤ 2 × 10^9$.\n- The absolute value of all coordinates does not exceed $10^9$.\n\n## SubTasks\n\n- Subtask 1 (40 points): $1 ≤ n ≤ 100$ and the absolute value of all coordinates does not exceed $10^4$.\n- Subtask 2 (40 points): the absolute value of all coordinates does not exceed $10^6$.\n- Subtask 3 (20 points): no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2018] 物理实验", "background": "", "description": "小 T 这学期有物理实验课，为了顺利完成下一节课的实验，他打算在课前对实验内容进行预习。\n\n这次实验在一个二维平面上进行，平面上放置了一条无限长的直线导轨，导轨上放置了一个长为$L$的激光发射器，激光发射器会向导轨两侧沿导轨垂直方向发射宽度为$L$的激光束。\n\n平面上还放置了 $n$ 个挡板，每个挡板可以看作是一条线段，现在每个挡板都不和直线导轨接触，且\n和直线导轨的夹角不超过 $85\t\\degree$，任意两个挡板也不会相互接触，激光束不能穿透这些挡板，并且会被挡板吸收掉，不会被挡板反射出去。\n\n小 T 想确定一个激光发射器的位置使得被激光束照射到的挡板长度之和最大，你需要帮小 T 算出这\n个最大值。", "inputFormat": "第一行包含一个正整数 T，表示测试数据的组数。\n\n对于每组测试数据，第一行是一个整数 $n$，表示挡板个数；  \n接下来 n 行，每行包含四个整数 $x1, y1, x2, y2$，表示挡板的两端点分别是 $(x1, y1)$ 和 $(x2, y2)$，保证$(x1, y1){=}\\mathllap{/\\,}(x2, y2)$。  \n第 $n + 2$ 行是五个整数 $x1, y1, x2, y2, L$，表示直线导轨经过了点 $(x1, y1)$ 和 $(x2, y2)$，且激光发射器的长度为 $L$，同样保证 $(x1, y1)\\mathrlap{\\,/}{=}(x2, y2)$。", "outputFormat": "对于每组测试数据，输出一行，包含一个实数，表示激光束能照射到的挡板长度之和的最大值，要求相对误差不超过 $10^{-6}$，也就是说，令输出结果为 $a$，标准答案为 $b$，若满足 $\\dfrac{|a-b|}{max(1,b)}$ $≤$ $10^{-6}$，则输出结果会被认为是正确答案。", "hint": "- $T ≤ 100$\n- $1 ≤ n ≤ 10^4$，\n- $1 ≤ L ≤ 2 × 10^9$，\n- 所有坐标的绝对值不超过 $10^9$。\n\n## SubTasks\n\n- 子任务 1 (40 分)：满足 $1 ≤ n ≤ 100$ 且所有坐标的绝对值不超过 $10^4$。\n- 子任务 2 (40 分)：所有坐标的绝对值不超过 $10^6$。\n- 子任务 3 (20 分)：没有任何附加的限制。\n", "locale": "zh-CN"}}}
{"pid": "P4606", "type": "P", "difficulty": 6, "samples": [["2\n7 6\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n3\n2 1 2\n3 2 3 4\n4 4 5 6 7\n6 6\n1 2\n1 3\n2 3\n1 4\n2 5\n3 6\n4\n3 1 2 3\n3 1 2 6\n3 1 5 6\n3 4 5 6\n", "0\n1\n3\n0\n1\n2\n3"]], "limits": {"time": [10000, 10000, 10000], "memory": [500000, 500000, 500000]}, "tags": ["2018", "各省省选", "山东", "O2优化", "深度优先搜索 DFS", "双连通分量", "虚树", "圆方树"], "title": "[SDOI2018] 战略游戏", "background": "", "description": "省选临近，放飞自我的小 Q 无心刷题，于是怂恿小 C 和他一起颓废，玩起了一款战略游戏。\n\n这款战略游戏的地图由 $n$ 个城市以及 $m$ 条连接这些城市的双向道路构成，并且从任意一个城市出发总能沿着道路走到任意其他城市。\n\n现在小 C 已经占领了其中至少两个城市，小 Q 可以摧毁一个小 C 没占领的城市，同时摧毁所有连接这个城市的道路。只要在摧毁这个城市之后能够找到某两个小 C 占领的城市 $u$ 和 $v$，使得从 $u$ 出发沿着道路无论如何都不能走到 $v$，那么小 Q 就能赢下这一局游戏。\n\n小 Q 和小 C 一共进行了 $q$ 局游戏，每一局游戏会给出小 C 占领的城市集合 $S$，你需要帮小 Q 数出有多少个城市在他摧毁之后能够让他赢下这一局游戏。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n\n对于每组测试数据：\n\n第一行是两个整数 $n$ 和 $m$ ，表示地图的城市数和道路数。\n\n接下来 $m$ 行，每行包含两个整数 $u$ 和 $v (1 \\le u < v \\le n)$，表示第 $u$ 个城市和第 $v$ 个城市之间有一条道路，同一对城市之间可能有多条道路连接。\n\n\n第 $m + 1$ 是一个整数 $q$，表示游戏的局数，\n\n接下来 $q$ 行，每行先给出一个整数 $|S| (2 \\le |S| \\le n)$，表示小 C 占领的城市数量，然后给出 $|S|$ 个整数 $(1 \\le S_1 < S_2 < \\cdots < S_{|S|} ≤ n)$，表示小 C 占领的城市。", "outputFormat": "对于每一局游戏，输出一行，包含一个整数，表示这一局游戏中有多少个城市在小 Q 摧毁之后能够让他赢下这一局游戏。", "hint": "- $1 \\le T \\le 10$；\n- $2 \\le n \\le 10^5$ 且 $n - 1 \\le m \\le 2\\times 10 ^ 5$；\n- $1 \\le q \\le 10^5$；\n- 对于每组测试数据，有 $\\sum|S| \\le 2 \\times 10^5$。\n\n### Subtasks\n\n- 子任务 1 (30 分)：对于每组测试数据，满足 $\\sum|S| \\le 20$；\n- 子任务 2 (45 分)：对于每一次询问，满足 $|S| = 2$；\n- 子任务 3 (25 分)：没有任何附加的限制。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2018] Strategic Game", "background": "", "description": "With the NOI Qualifier approaching, carefree Xiao Q has no desire to practice problems. He coaxes Xiao C to slack off with him and play a strategic game.\n\nThe map of this strategic game consists of $n$ cities and $m$ undirected roads connecting these cities. From any city, it is always possible to reach any other city by following the roads.\n\nXiao C has already occupied at least two cities. Xiao Q may destroy one city not occupied by Xiao C, and simultaneously destroy all roads incident to that city. If, after destroying this city, there exist two cities $u$ and $v$ occupied by Xiao C such that starting from $u$ it is impossible to reach $v$ along the roads, then Xiao Q wins that round.\n\nXiao Q and Xiao C play $q$ rounds in total. In each round, you are given the set $S$ of cities occupied by Xiao C. You need to help Xiao Q count how many cities, if destroyed, would allow him to win that round.", "inputFormat": "The first line contains a single integer $T$, the number of test cases.\n\nFor each test case:\n\n- The first line contains two integers $n$ and $m$, the number of cities and the number of roads.\n- The next $m$ lines each contain two integers $u$ and $v$ ($1 \\le u < v \\le n$), indicating there is a road between city $u$ and city $v$. There may be multiple roads between the same pair of cities.\n- The $(m + 1)$-th line contains an integer $q$, the number of game rounds.\n- The next $q$ lines: each line first gives an integer $|S|$ ($2 \\le |S| \\le n$), the number of cities occupied by Xiao C, followed by $|S|$ integers $S_1, S_2, \\ldots, S_{|S|}$ ($1 \\le S_1 < S_2 < \\cdots < S_{|S|} \\le n$), denoting the cities occupied by Xiao C.", "outputFormat": "For each round, output a single line containing one integer: the number of cities whose destruction would allow Xiao Q to win that round.", "hint": "Constraints\n- $1 \\le T \\le 10$.\n- $2 \\le n \\le 10^5$ and $n - 1 \\le m \\le 2 \\times 10^5$.\n- $1 \\le q \\le 10^5$.\n- For each test case, $\\sum |S| \\le 2 \\times 10^5$.\n\n### Subtasks\n\n- Subtask 1 (30 points): For each test case, $\\sum |S| \\le 20$.\n- Subtask 2 (45 points): For each query, $|S| = 2$.\n- Subtask 3 (25 points): No additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2018] 战略游戏", "background": "", "description": "省选临近，放飞自我的小 Q 无心刷题，于是怂恿小 C 和他一起颓废，玩起了一款战略游戏。\n\n这款战略游戏的地图由 $n$ 个城市以及 $m$ 条连接这些城市的双向道路构成，并且从任意一个城市出发总能沿着道路走到任意其他城市。\n\n现在小 C 已经占领了其中至少两个城市，小 Q 可以摧毁一个小 C 没占领的城市，同时摧毁所有连接这个城市的道路。只要在摧毁这个城市之后能够找到某两个小 C 占领的城市 $u$ 和 $v$，使得从 $u$ 出发沿着道路无论如何都不能走到 $v$，那么小 Q 就能赢下这一局游戏。\n\n小 Q 和小 C 一共进行了 $q$ 局游戏，每一局游戏会给出小 C 占领的城市集合 $S$，你需要帮小 Q 数出有多少个城市在他摧毁之后能够让他赢下这一局游戏。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n\n对于每组测试数据：\n\n第一行是两个整数 $n$ 和 $m$ ，表示地图的城市数和道路数。\n\n接下来 $m$ 行，每行包含两个整数 $u$ 和 $v (1 \\le u < v \\le n)$，表示第 $u$ 个城市和第 $v$ 个城市之间有一条道路，同一对城市之间可能有多条道路连接。\n\n\n第 $m + 1$ 是一个整数 $q$，表示游戏的局数，\n\n接下来 $q$ 行，每行先给出一个整数 $|S| (2 \\le |S| \\le n)$，表示小 C 占领的城市数量，然后给出 $|S|$ 个整数 $(1 \\le S_1 < S_2 < \\cdots < S_{|S|} ≤ n)$，表示小 C 占领的城市。", "outputFormat": "对于每一局游戏，输出一行，包含一个整数，表示这一局游戏中有多少个城市在小 Q 摧毁之后能够让他赢下这一局游戏。", "hint": "- $1 \\le T \\le 10$；\n- $2 \\le n \\le 10^5$ 且 $n - 1 \\le m \\le 2\\times 10 ^ 5$；\n- $1 \\le q \\le 10^5$；\n- 对于每组测试数据，有 $\\sum|S| \\le 2 \\times 10^5$。\n\n### Subtasks\n\n- 子任务 1 (30 分)：对于每组测试数据，满足 $\\sum|S| \\le 20$；\n- 子任务 2 (45 分)：对于每一次询问，满足 $|S| = 2$；\n- 子任务 3 (25 分)：没有任何附加的限制。\n", "locale": "zh-CN"}}}
{"pid": "P4607", "type": "P", "difficulty": 7, "samples": [["10\n1 1 1000000001\n2 2 1000000003\n3 2 1000000005\n3 3 1000000007\n4 2 1000000009\n4 3 1000000011\n4 4 1000000013\n5 5 1000000015\n7 7 1000000017\n9 9 1000000019", "1\n2\n8\n21\n6\n15\n28\n605\n16765\n530937\n"], ["10\n8821612800 758922381 1073365919\n8380532160 166822173 1001828119\n9311702400 7367823578 1015387267\n6983776800 1646145481 1030885259\n6692786100 1953515781 1073365919\n7138971840 2649942813 1001828119\n6469693230 2585876408 1015387267\n8031343320 1646145481 1030885259\n9995200351 645412247 1030328983\n9302162851 1649517328 1053299347\n", "896784901\n911577797\n674524325\n392648220\n646549222\n879297585\n384496639\n889650008\n957785169\n413147483"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000]}, "tags": ["字符串", "2018", "各省省选", "山东", "O2优化", "枚举", "素数判断,质数,筛法"], "title": "[SDOI2018] 反回文串", "background": "", "description": "“回文串什么的最讨厌了……”\n\n小 $Q$ 讨厌任何形式的回文串：\n\n- 如果一个字符串从左往右读和从右往左读是一样的，那么小 $Q$ 讨厌它；例如 $aa$ 和 $aba$。\n\n- 对于一个字符串来说，若将某个前缀子串移除并拼接到字符串的尾部，能得到一个小 $Q$ 讨厌的字符串，那么小 $Q$ 也会讨厌原来的这个字符串；例如 $aab$ 和 $baa$。\n\n那么问题来了，如果任意字符串只可以由 $k$ 种已知的字符组成，那么长度为 $n$ 的所有字符串里，有多少字符串是小 $Q$ 讨厌的？\n\n答案可能很大，你只需要给出答案对 $p$ 取模的值。\n", "inputFormat": "第一行包含一个正整数 $T$，表示有 $T$ 组测试数据。\n接下来 $T$ 行，每行描述一组测试数据，包含三个正整数 $n, k$ 和 $p$。", "outputFormat": "对于每组测试数据，输出一行，包含一个整数，表示答案对 $p$ 取模的值。", "hint": "- 对于 $30\\%$ 的数据，有 $1 ≤ n ≤ 10^{10}$。\n\n- 对于 $60\\%$ 的数据，有 $1 ≤ n ≤ 10^{14}$。\n\n- 对于 $100\\%$ 的数据，有\n$1 ≤ T ≤ 10, 1 ≤ n ≤ 10^{18}, 1 ≤ k ≤ n, 10^9 ≤ p ≤ 2^{30}$\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2018] Anti-Palindromic String", "background": "", "description": "“I really hate palindromic strings...”\n\nXiao $Q$ hates any form of palindromic string:\n\n- If a string reads the same from left to right and from right to left, then Xiao $Q$ hates it; for example, $aa$ and $aba$.\n\n- For a string, if by removing some prefix substring and appending it to the end of the string you can obtain a string that Xiao $Q$ hates, then Xiao $Q$ also hates the original string; for example, $aab$ and $baa$.\n\nNow the question is: if any string may only be formed from $k$ known characters, among all strings of length $n$, how many strings are hated by Xiao $Q$?\n\nThe answer can be large. You only need to output the answer modulo $p$.", "inputFormat": "The first line contains a positive integer $T$, indicating that there are $T$ test cases.\nThe next $T$ lines each describe a test case, containing three positive integers $n$, $k$, and $p$.", "outputFormat": "For each test case, output one line containing an integer, which is the answer modulo $p$.", "hint": "- For $30\\%$ of the testdata, $1 \\le n \\le 10^{10}$.\n\n- For $60\\%$ of the testdata, $1 \\le n \\le 10^{14}$.\n\n- For $100\\%$ of the testdata, \n$1 \\le T \\le 10$, $1 \\le n \\le 10^{18}$, $1 \\le k \\le n$, $10^9 \\le p \\le 2^{30}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2018] 反回文串", "background": "", "description": "“回文串什么的最讨厌了……”\n\n小 $Q$ 讨厌任何形式的回文串：\n\n- 如果一个字符串从左往右读和从右往左读是一样的，那么小 $Q$ 讨厌它；例如 $aa$ 和 $aba$。\n\n- 对于一个字符串来说，若将某个前缀子串移除并拼接到字符串的尾部，能得到一个小 $Q$ 讨厌的字符串，那么小 $Q$ 也会讨厌原来的这个字符串；例如 $aab$ 和 $baa$。\n\n那么问题来了，如果任意字符串只可以由 $k$ 种已知的字符组成，那么长度为 $n$ 的所有字符串里，有多少字符串是小 $Q$ 讨厌的？\n\n答案可能很大，你只需要给出答案对 $p$ 取模的值。\n", "inputFormat": "第一行包含一个正整数 $T$，表示有 $T$ 组测试数据。\n接下来 $T$ 行，每行描述一组测试数据，包含三个正整数 $n, k$ 和 $p$。", "outputFormat": "对于每组测试数据，输出一行，包含一个整数，表示答案对 $p$ 取模的值。", "hint": "- 对于 $30\\%$ 的数据，有 $1 ≤ n ≤ 10^{10}$。\n\n- 对于 $60\\%$ 的数据，有 $1 ≤ n ≤ 10^{14}$。\n\n- 对于 $100\\%$ 的数据，有\n$1 ≤ T ≤ 10, 1 ≤ n ≤ 10^{18}, 1 ≤ k ≤ n, 10^9 ≤ p ≤ 2^{30}$\n", "locale": "zh-CN"}}}
{"pid": "P4608", "type": "P", "difficulty": 6, "samples": [["6 6\nGCTACT\nGATCCT 1", "A\nAC\nACT\nAT \nC  \nCC \nCCT\nCT \nG  \nGA \nGAC\nGACT\nGAT \nGC  \nGCC \nGCCT\nGCT \nGT  \nGTC \nGTCT\nGTT \nT   \nTC  \nTCT \nTT  \n26"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["字符串", "高精度", "2016", "各省省选", "福建", "有限状态自动机"], "title": "[FJOI2016] 所有公共子序列问题", "background": "", "description": "一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列 $X=x_1x_2\\ldots x_m$，则另一序列 $Z=z_1z_2\\ldots z_k$ 是 $X$ 的子序列是指存在一个严格递增下标序列 $i_1,i_2, \\ldots ,i_k$ 使得对于所有 $j=1,2,…,k$ 有 $z_j=x_{i_j}$。\n\n例如，序列 $Z=$``GACT`` 是序列 $X=$``GCTACT`` 的子序列，相应的递增下标序列为 $1,4,5,6$。给定两个序列 $X$ 和 $Y$，当另一序列 $Z$ 既是 $X$ 的子序列又是 $Y$ 的子序列时，称 $Z$ 是序列 $X$ 和 $Y$ 的公共子序列。例如，若 $X=$``GCTACT``， $Y=$``GATCCT``，序列 $T$ 是 $X$ 和 $Y$ 的一个公共子序列，序列 ``GACT`` 也是 $X$ 和 $Y$ 的一个公共子序列。注意对于任何给定的序列 $X$ 和 $Y$，空序列总是它们的一个公共子序列。\n\n所有公共子序列问题是要求对于给定的 $2$ 个序列 $X=x_1x_2\\ldots x_m$ 和 $Y=y_1y_2\\ldots y_m$，找出 $X$ 和 $Y$ 的所有不同的公共子序列。", "inputFormat": "文件的第一行有两个正整数 $m$ 和 $n$，分别表示 $2$ 个输入序列 $X$ 和 $Y$ 的长度。\n\n接下来的两行分别给出输入序列 $X=x_1x_2\\cdots x_m$ 和 $Y=y_1y_2\\cdots y_m$，其中序列中每个元素均为二十六个英文大小写字母。\n\n文件的最后一行给出一个非负整数 $k$。\n\n$k$ 的值为 $1$ 时，表示计算结果要输出 $X$ 和 $Y$ 的所有不同的公共子序列，以及 $X$ 和 $Y$ 有多少个不同的公共子序列。\n\n$k$ 的值为 $0$ 时，表示计算结果只要输出 $X$ 和 $Y$ 有多少个不同的公共子序列。", "outputFormat": "将计算出的 $X$ 和 $Y$ 的所有不同的公共子序列，或 $X$ 和 $Y$ 有多少个不同的公共子序列输出到文件中。当 $k=1$ 时，先输出 $X$ 和 $Y$ 的所有不同的公共子序列，每行输出一个公共子序列，按字典序从小到大输出。最后输出不同的公共子序列的个数。当 $k=0$ 时，只要输出不同的公共子序列的个数。", "hint": "$1 \\leq m,n \\leq 3010$\n\n答案....很大啦", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2016] All Common Subsequences", "background": "", "description": "A subsequence of a given sequence is obtained by deleting some elements from that sequence. Precisely, given a sequence $X = x_1 x_2 \\ldots x_m$, another sequence $Z = z_1 z_2 \\ldots z_k$ is a subsequence of $X$ if there exists a strictly increasing index sequence $i_1, i_2, \\ldots, i_k$ such that for all $j = 1, 2, \\ldots, k$ we have $z_j = x_{i_j}$.\n\nFor example, the sequence $Z = ``GACT''$ is a subsequence of the sequence $X = ``GCTACT''$, with the corresponding increasing index sequence $1, 4, 5, 6$. Given two sequences $X$ and $Y$, when another sequence $Z$ is a subsequence of both $X$ and $Y$, we call $Z$ a common subsequence of $X$ and $Y$. For example, if $X = ``GCTACT''$ and $Y = ``GATCCT''$, the sequence ``T'' is a common subsequence of $X$ and $Y$, and the sequence ``GACT'' is also a common subsequence of $X$ and $Y$. Note that for any given sequences $X$ and $Y$, the empty sequence is always their common subsequence.\n\nThe All Common Subsequences problem asks you, given two sequences $X = x_1 x_2 \\ldots x_m$ and $Y = y_1 y_2 \\ldots y_n$, to find all distinct common subsequences of $X$ and $Y$.", "inputFormat": "The first line contains two positive integers $m$ and $n$, the lengths of the two input sequences $X$ and $Y$.\n\nThe next two lines give the input sequences $X = x_1 x_2 \\cdots x_m$ and $Y = y_1 y_2 \\cdots y_n$, where each element of a sequence is an English letter, uppercase or lowercase.\n\nThe last line contains a non-negative integer $k$.\n\nIf $k = 1$, you must output all distinct common subsequences of $X$ and $Y$, and also how many distinct common subsequences $X$ and $Y$ have.\n\nIf $k = 0$, you must output only how many distinct common subsequences $X$ and $Y$ have.", "outputFormat": "Output all distinct common subsequences of $X$ and $Y$, or output how many distinct common subsequences $X$ and $Y$ have. When $k = 1$, first output all distinct common subsequences of $X$ and $Y$, one per line, in ascending lexicographic order. Finally, output the number of distinct common subsequences. When $k = 0$, output only the number of distinct common subsequences.", "hint": "$1 \\leq m, n \\leq 3010$.\n\nThe answer can be very large.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2016] 所有公共子序列问题", "background": "", "description": "一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列 $X=x_1x_2\\ldots x_m$，则另一序列 $Z=z_1z_2\\ldots z_k$ 是 $X$ 的子序列是指存在一个严格递增下标序列 $i_1,i_2, \\ldots ,i_k$ 使得对于所有 $j=1,2,…,k$ 有 $z_j=x_{i_j}$。\n\n例如，序列 $Z=$``GACT`` 是序列 $X=$``GCTACT`` 的子序列，相应的递增下标序列为 $1,4,5,6$。给定两个序列 $X$ 和 $Y$，当另一序列 $Z$ 既是 $X$ 的子序列又是 $Y$ 的子序列时，称 $Z$ 是序列 $X$ 和 $Y$ 的公共子序列。例如，若 $X=$``GCTACT``， $Y=$``GATCCT``，序列 $T$ 是 $X$ 和 $Y$ 的一个公共子序列，序列 ``GACT`` 也是 $X$ 和 $Y$ 的一个公共子序列。注意对于任何给定的序列 $X$ 和 $Y$，空序列总是它们的一个公共子序列。\n\n所有公共子序列问题是要求对于给定的 $2$ 个序列 $X=x_1x_2\\ldots x_m$ 和 $Y=y_1y_2\\ldots y_m$，找出 $X$ 和 $Y$ 的所有不同的公共子序列。", "inputFormat": "文件的第一行有两个正整数 $m$ 和 $n$，分别表示 $2$ 个输入序列 $X$ 和 $Y$ 的长度。\n\n接下来的两行分别给出输入序列 $X=x_1x_2\\cdots x_m$ 和 $Y=y_1y_2\\cdots y_m$，其中序列中每个元素均为二十六个英文大小写字母。\n\n文件的最后一行给出一个非负整数 $k$。\n\n$k$ 的值为 $1$ 时，表示计算结果要输出 $X$ 和 $Y$ 的所有不同的公共子序列，以及 $X$ 和 $Y$ 有多少个不同的公共子序列。\n\n$k$ 的值为 $0$ 时，表示计算结果只要输出 $X$ 和 $Y$ 有多少个不同的公共子序列。", "outputFormat": "将计算出的 $X$ 和 $Y$ 的所有不同的公共子序列，或 $X$ 和 $Y$ 有多少个不同的公共子序列输出到文件中。当 $k=1$ 时，先输出 $X$ 和 $Y$ 的所有不同的公共子序列，每行输出一个公共子序列，按字典序从小到大输出。最后输出不同的公共子序列的个数。当 $k=0$ 时，只要输出不同的公共子序列的个数。", "hint": "$1 \\leq m,n \\leq 3010$\n\n答案....很大啦", "locale": "zh-CN"}}}
{"pid": "P4609", "type": "P", "difficulty": 6, "samples": [["2\n3 2 2\n3 1 2", "2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["数学", "递推", "2016", "各省省选", "福建", "组合数学", "Stirling 数"], "title": "[FJOI2016] 建筑师", "background": "", "description": "小 Z 是一个很有名的建筑师，有一天他接到了一个很奇怪的任务：在数轴上建 $n$ 个建筑，每个建筑的高度是 $1$ 到 $n$ 之间的一个整数。\n\n小 Z 有很严重的强迫症，他不喜欢有两个建筑的高度相同。另外小 Z 觉得如果从最左边（所有建筑都在右边）看能看到 $A$ 个建筑，从最右边（所有建筑都在左边）看能看到 $B$ 个建筑，这样的建筑群有着独特的美感。现在，小 Z 想知道满足上述所有条件的建筑方案有多少种？\n\n如果建筑 $i$ 的左(右)边没有任何建造比它高，则建筑 $i$ 可以从左(右)边看到。两种方案不同，当且仅当存在某个建筑在两种方案下的高度不同。", "inputFormat": "第一行一个整数 $T$，代表 $T$ 组数据。\n接下来 $T$ 行，每行三个整数 $n,A,B$。", "outputFormat": "对于每组数据输出一行答案 $\\text{mod } 10^9+7$。", "hint": "对于 $10 \\%$ 的数据 ： $1 \\leq n \\leq 10$。\n\n对于 $20 \\%$ 的数据 ： $1 \\leq n \\leq 100$。\n\n对于 $40 \\%$ 的数据 ： $1 \\leq n \\leq 50000, \\ 1 \\leq T \\leq 5$。\n\n对于 $100 \\%$ 的数据 ：$1 \\leq n \\leq 50000, \\ 1 \\leq A, B \\leq 100, \\ 1 \\leq T \\leq 200000$。", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2016] Architect", "background": "", "description": "Xiao Z is a very famous architect. One day he received a strange task: build $n$ buildings on a number line, where each building’s height is an integer between $1$ and $n$.\n\nXiao Z has severe OCD; he dislikes having two buildings with the same height. Moreover, Xiao Z feels that a skyline is uniquely beautiful if, when viewed from the far left (all buildings lie to the right), exactly $A$ buildings are visible, and when viewed from the far right (all buildings lie to the left), exactly $B$ buildings are visible. Now Xiao Z wants to know how many building arrangements satisfy all of the above conditions.\n\nBuilding $i$ is visible from the left (right) if there is no building taller than it on its left (right). Two arrangements are different if and only if there exists at least one building whose height differs between the two arrangements.", "inputFormat": "The first line contains an integer $T$, the number of test cases.  \nEach of the next $T$ lines contains three integers $n, A, B$.", "outputFormat": "For each test case, output the answer $\\text{mod } 10^9+7$.", "hint": "For $10\\%$ of the testdata: $1 \\leq n \\leq 10$.\n\nFor $20\\%$ of the testdata: $1 \\leq n \\leq 100$.\n\nFor $40\\%$ of the testdata: $1 \\leq n \\leq 50000, \\ 1 \\leq T \\leq 5$.\n\nFor $100\\%$ of the testdata: $1 \\leq n \\leq 50000, \\ 1 \\leq A, B \\leq 100, \\ 1 \\leq T \\leq 200000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2016] 建筑师", "background": "", "description": "小 Z 是一个很有名的建筑师，有一天他接到了一个很奇怪的任务：在数轴上建 $n$ 个建筑，每个建筑的高度是 $1$ 到 $n$ 之间的一个整数。\n\n小 Z 有很严重的强迫症，他不喜欢有两个建筑的高度相同。另外小 Z 觉得如果从最左边（所有建筑都在右边）看能看到 $A$ 个建筑，从最右边（所有建筑都在左边）看能看到 $B$ 个建筑，这样的建筑群有着独特的美感。现在，小 Z 想知道满足上述所有条件的建筑方案有多少种？\n\n如果建筑 $i$ 的左(右)边没有任何建造比它高，则建筑 $i$ 可以从左(右)边看到。两种方案不同，当且仅当存在某个建筑在两种方案下的高度不同。", "inputFormat": "第一行一个整数 $T$，代表 $T$ 组数据。\n接下来 $T$ 行，每行三个整数 $n,A,B$。", "outputFormat": "对于每组数据输出一行答案 $\\text{mod } 10^9+7$。", "hint": "对于 $10 \\%$ 的数据 ： $1 \\leq n \\leq 10$。\n\n对于 $20 \\%$ 的数据 ： $1 \\leq n \\leq 100$。\n\n对于 $40 \\%$ 的数据 ： $1 \\leq n \\leq 50000, \\ 1 \\leq T \\leq 5$。\n\n对于 $100 \\%$ 的数据 ：$1 \\leq n \\leq 50000, \\ 1 \\leq A, B \\leq 100, \\ 1 \\leq T \\leq 200000$。", "locale": "zh-CN"}}}
{"pid": "P4610", "type": "P", "difficulty": 6, "samples": [["6 7\n1 3\n3 4\n4 5\n5 1\n4 2\n2 6\n6 3", "6"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "COI（克罗地亚）"], "title": "[COI 2012] KAMPANJA", "background": "临近选举，总统要在城市 $1$ 和城市 $2$ 举行演讲。他乘汽车完成巡回演讲，从 $1$ 出发，途中要经过城市 $2$，最后必须回到城市 $1$。特勤局对总统要经过的所有城市监控。为了使得费用最小，必须使得监控的城市最少。求最少要监控的城市。", "description": "一共有 $N$ 个城市和 $M$ 条有向边。满足 $2 \\le N \\le 100,2 \\le M \\le 200$。\n\n我们要求出从 $1$ 号城市出发途中要经过 $2$ 城市，最后要回到 $1$ 城市的路线中最少要经过的点的数目。测试数据保证一定存在解。", "inputFormat": "第一行包含 $2$ 个整数 $N,M$。$N$ 表示城市的数目，$M$ 表示有向边的数目。\n\n接下来 $M$ 行，每行两个数 $A,B$，表示从 $A$ 到 $B$ 有一条有向边。", "outputFormat": "最少要监控的城市的数量。", "hint": "对于 $100\\%$ 的数据，满足 $2 \\le N \\le 100,2 \\le M \\le 200$。\n\n本题数据加强by Imagine", "locale": "zh-CN", "translations": {"en": {"title": "[COI 2012] KAMPANJA", "background": "As the election approaches, the president will give speeches in city $1$ and city $2$. He travels by car on a campaign tour, starting from $1$, passing through city $2$ on the way, and finally must return to city $1$. The Secret Service monitors all cities the president passes through. To minimize the cost, the number of monitored cities must be as small as possible. Find the minimum number of cities that need to be monitored.", "description": "There are $N$ cities and $M$ directed edges, satisfying $2 \\le N \\le 100, 2 \\le M \\le 200$.\n\nWe need to find, among all routes that start from city $1$, pass through city $2$ on the way, and finally return to city $1$, the minimum number of cities that need to be visited. The testdata guarantees that a solution exists.", "inputFormat": "The first line contains two integers $N, M$. $N$ is the number of cities, and $M$ is the number of directed edges.\n\nThe next $M$ lines each contain two integers $A, B$, indicating a directed edge from $A$ to $B$.", "outputFormat": "Output the minimum number of cities that need to be monitored.", "hint": "For $100\\%$ of the testdata, $2 \\le N \\le 100, 2 \\le M \\le 200$ holds.\n\nThe testdata for this problem is strengthened by Imagine.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COI 2012] KAMPANJA", "background": "临近选举，总统要在城市 $1$ 和城市 $2$ 举行演讲。他乘汽车完成巡回演讲，从 $1$ 出发，途中要经过城市 $2$，最后必须回到城市 $1$。特勤局对总统要经过的所有城市监控。为了使得费用最小，必须使得监控的城市最少。求最少要监控的城市。", "description": "一共有 $N$ 个城市和 $M$ 条有向边。满足 $2 \\le N \\le 100,2 \\le M \\le 200$。\n\n我们要求出从 $1$ 号城市出发途中要经过 $2$ 城市，最后要回到 $1$ 城市的路线中最少要经过的点的数目。测试数据保证一定存在解。", "inputFormat": "第一行包含 $2$ 个整数 $N,M$。$N$ 表示城市的数目，$M$ 表示有向边的数目。\n\n接下来 $M$ 行，每行两个数 $A,B$，表示从 $A$ 到 $B$ 有一条有向边。", "outputFormat": "最少要监控的城市的数量。", "hint": "对于 $100\\%$ 的数据，满足 $2 \\le N \\le 100,2 \\le M \\le 200$。\n\n本题数据加强by Imagine", "locale": "zh-CN"}}}
{"pid": "P4611", "type": "P", "difficulty": 5, "samples": [["6 4\n12 16 16 16 14 14\n.T....", "5"], ["10 1\n10 7 3 1 1 9 8 2 4 10\n..T..T....", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2012", "COI（克罗地亚）"], "title": "[COI 2012] TRAMPOLIN", "background": "有很多超级英雄：蝙蝠侠，蜘蛛侠，超人等。其中，有一位叫牛。今天他想模仿蜘蛛侠，所以他选择了一排高大的摩天楼来跳。", "description": "具体而言，他选择了一个由 N 个摩天大楼构成的序\n列，从左到右编号从 1 到 N.他最初位于第 K 座摩天大厦。不幸的是，这样的他的能力有限，所以只能向左或向右跳到相邻的摩天楼，只有那些摩天大楼的高度不大于他目前的摩天大楼\n的高度的楼房才行。然而，他使蹦床上一些摩天大楼，从这些摩天大厦，他可以跳到任何其\n他的摩天大楼，无论多么高以及位置在何处。\n找出从第 K 座楼房开始，他能跳到的最多的不同的楼房数。如果一个楼房被多次访问，我\n们只计算一次。楼房 K 也被计算在内，不管我们是否回到过楼房 K。", "inputFormat": "第一行，包含两个数Ｎ和 K (3 ≤ N ≤ 300 000, 1 ≤ K ≤ N)，表示楼房总数和开始的楼\n房。\n第二行Ｎ个数，均小于 10^6，从左到右依次表示楼房的高度。\n第三行Ｎ个字符'.' 或'T'.如果第 i 个字符是'T'，表示这里有一个蹦床在第 i 个楼房。", "outputFormat": "一个数，有示最多能到的楼房数。", "hint": "样例 2 线路如下：\n1 –>2 –>3 –>6 –>10 –>9 –>8.", "locale": "zh-CN", "translations": {"en": {"title": "[COI 2012] TRAMPOLIN", "background": "There are many superheroes: Batman, Spider-Man, Superman, etc. Among them, there is one called Niu. Today he wants to imitate Spider-Man, so he chose a row of tall skyscrapers to jump across.", "description": "Specifically, he chose a sequence of $N$ skyscrapers, numbered from $1$ to $N$ from left to right. He initially stays on the $K$-th skyscraper. Unfortunately, his ability is limited, so he can only jump left or right to an adjacent skyscraper, and only to a skyscraper whose height is not greater than the height of his current skyscraper.\n\nHowever, some skyscrapers have trampolines. From such a skyscraper, he can jump to any other skyscraper, no matter how tall it is and no matter where it is.\n\nFind the maximum number of distinct skyscrapers he can reach starting from the $K$-th skyscraper. If a skyscraper is visited multiple times, it is counted only once. Skyscraper $K$ is also counted, whether or not he returns to it.", "inputFormat": "The first line contains two integers $N$ and $K$ ($3 \\le N \\le 300\\,000$, $1 \\le K \\le N$), representing the total number of skyscrapers and the starting skyscraper.\n\nThe second line contains $N$ integers, each less than $10^6$, describing the heights of the skyscrapers from left to right.\n\nThe third line contains $N$ characters, `.` or `T`. If the $i$-th character is `T`, it means there is a trampoline on the $i$-th skyscraper.", "outputFormat": "Output one integer, the maximum number of skyscrapers that can be reached.", "hint": "The route for Sample 2 is as follows:\n$1 \\to 2 \\to 3 \\to 6 \\to 10 \\to 9 \\to 8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COI 2012] TRAMPOLIN", "background": "有很多超级英雄：蝙蝠侠，蜘蛛侠，超人等。其中，有一位叫牛。今天他想模仿蜘蛛侠，所以他选择了一排高大的摩天楼来跳。", "description": "具体而言，他选择了一个由 N 个摩天大楼构成的序\n列，从左到右编号从 1 到 N.他最初位于第 K 座摩天大厦。不幸的是，这样的他的能力有限，所以只能向左或向右跳到相邻的摩天楼，只有那些摩天大楼的高度不大于他目前的摩天大楼\n的高度的楼房才行。然而，他使蹦床上一些摩天大楼，从这些摩天大厦，他可以跳到任何其\n他的摩天大楼，无论多么高以及位置在何处。\n找出从第 K 座楼房开始，他能跳到的最多的不同的楼房数。如果一个楼房被多次访问，我\n们只计算一次。楼房 K 也被计算在内，不管我们是否回到过楼房 K。", "inputFormat": "第一行，包含两个数Ｎ和 K (3 ≤ N ≤ 300 000, 1 ≤ K ≤ N)，表示楼房总数和开始的楼\n房。\n第二行Ｎ个数，均小于 10^6，从左到右依次表示楼房的高度。\n第三行Ｎ个字符'.' 或'T'.如果第 i 个字符是'T'，表示这里有一个蹦床在第 i 个楼房。", "outputFormat": "一个数，有示最多能到的楼房数。", "hint": "样例 2 线路如下：\n1 –>2 –>3 –>6 –>10 –>9 –>8.", "locale": "zh-CN"}}}
{"pid": "P4612", "type": "P", "difficulty": 5, "samples": [["3\n3 10 2\n8 4 2\n2 5 2", "4"], ["4\n3 3 5\n7 11 5\n20 8 10\n30 18 3", "19"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "COI（克罗地亚）"], "title": "[COI 2012] SETNJA", "background": "Mirko 要给朋友们送音乐会门票。", "description": "朋友的家可表示为二维平面的网格。Mirko 在行走时，可以朝 $8$ 个方向移动，每次都是整数坐标。他每一步朝上、下、左、右以及 $4$ 个对角方向走一格。\n\n每个朋友的家可表示为平面上的点 $(x,y)$。当 Mirko 到某朋友家送票时，朋友也可以走出来迎接他，也可以向 $8$ 个方向行走。因此，Mirko 和这个朋友最多可以在距离他家 $P$ 步远的位置相遇。$P$ 随每个朋友不同。\n\nMirko 的起始位置与终点位置都未知。\n\n请求出 Mirko 送完所有票的最少移动步数。", "inputFormat": "第一行一个整数，表示 Mirko 的朋友数 $N (2 ≤ N ≤ 200{,}000)$；\n\n接下来 $N$ 行，每行 $3$ 个数，分别表示 $x,y,P\\ (0 ≤ x, y, P ≤ 200{,}000)$。朋友按 Mirko 送票的顺序给出。", "outputFormat": "共一行一个整数，表示 Mirko 必须走的最少移动步数。", "hint": "对于全部数据，保证 $2 ≤ N ≤ 200{,}000$，$0 ≤ x, y, P ≤ 200{,}000$。", "locale": "zh-CN", "translations": {"en": {"title": "[COI 2012] SETNJA", "background": "Mirko is going to deliver concert tickets to his friends.", "description": "Each friend’s home can be represented on a 2D grid. When Mirko walks, he can move in $8$ directions, always staying on integer coordinates. In each step, he moves one grid unit up, down, left, right, or along one of the $4$ diagonal directions.\n\nEach friend’s home is a point $(x, y)$ on the plane. When Mirko arrives to deliver a ticket, the friend can also walk out to meet him, and can also move in $8$ directions. Therefore, Mirko and the friend can meet at a position up to $P$ steps away from the friend’s home. The value of $P$ may be different for each friend.\n\nMirko’s starting position and ending position are both unknown.\n\nFind the minimum number of steps Mirko needs to move in order to deliver all tickets.", "inputFormat": "The first line contains an integer $N$, the number of Mirko’s friends $(2 \\le N \\le 200{,}000)$.\n\nThe next $N$ lines each contain three numbers $x, y, P\\ (0 \\le x, y, P \\le 200{,}000)$. The friends are given in the order in which Mirko delivers the tickets.", "outputFormat": "Output one integer: the minimum number of steps Mirko must walk.", "hint": "For all testdata, it is guaranteed that $2 \\le N \\le 200{,}000$ and $0 \\le x, y, P \\le 200{,}000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COI 2012] SETNJA", "background": "Mirko 要给朋友们送音乐会门票。", "description": "朋友的家可表示为二维平面的网格。Mirko 在行走时，可以朝 $8$ 个方向移动，每次都是整数坐标。他每一步朝上、下、左、右以及 $4$ 个对角方向走一格。\n\n每个朋友的家可表示为平面上的点 $(x,y)$。当 Mirko 到某朋友家送票时，朋友也可以走出来迎接他，也可以向 $8$ 个方向行走。因此，Mirko 和这个朋友最多可以在距离他家 $P$ 步远的位置相遇。$P$ 随每个朋友不同。\n\nMirko 的起始位置与终点位置都未知。\n\n请求出 Mirko 送完所有票的最少移动步数。", "inputFormat": "第一行一个整数，表示 Mirko 的朋友数 $N (2 ≤ N ≤ 200{,}000)$；\n\n接下来 $N$ 行，每行 $3$ 个数，分别表示 $x,y,P\\ (0 ≤ x, y, P ≤ 200{,}000)$。朋友按 Mirko 送票的顺序给出。", "outputFormat": "共一行一个整数，表示 Mirko 必须走的最少移动步数。", "hint": "对于全部数据，保证 $2 ≤ N ≤ 200{,}000$，$0 ≤ x, y, P ≤ 200{,}000$。", "locale": "zh-CN"}}}
{"pid": "P4613", "type": "P", "difficulty": 1, "samples": [["3\n7 9 5\n6 13 10", "DA"], ["4\n5 3 3 5\n10 2 10 10", "NE"], ["4\n5 2 3 2\n3 8 3 3", "DA"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #5] Olivander", "background": "", "description": "Harry Potter has damaged his magic wand in a fight with Lord Voldemort. He has decided to\nget a new wand in Olivander's wand shop. On the floor of the shop, he saw ​N wands and ​N\nwand boxes. The lengths of the wands are, respectively, $X_1$\n,$X_2$\n...​$X_n$\n, and the box sizes are\n$Y_1$\n,​$Y_2$\n...$Y_n$\n. A wand of length ​X can be placed in a box of size ​Y if ​X ≤ ​Y\n. Harry wants to know\nif he can place all the wands in boxes so that each box contains exactly one wand.\nHelp him solve this difficult problem.", "inputFormat": "The first line of input contains the positive integer ​N\n(1 ≤ ​N\n≤ 100), the number from the task.\nThe second line contains ​N\npositive integers ​$X_i$\n(1 ≤ ​$X_i$\n≤ $10^9$​ ), the numbers from the task.\nThe third line contains ​N\npositive integers ​$X_i$\n(1 ≤ $X_i$\n≤ $10^9$​​ ), the numbers from the task.", "outputFormat": "If Harry can place all the wands in boxes, output “DA” (Croatian for yes), otherwise output\n“NE” (Croatian for no).", "hint": "In test cases worth 60% of total points, it will hold ​N\n≤ 9.\n\n**Clarification of the first test case:**\n\nHarry can place the wands in boxes. For example, he can place the wand of length 5 in a box of size\n6, wand of length 7 in a box of size 13, and wand of length 9 in a box of size 10.\n\n**Clarification of the second test case:**\n\nHarry can’t place the wands in boxes because the box of size 2 can’t fit any of the wands.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #5] Olivander", "background": "", "description": "Harry Potter has damaged his magic wand in a fight with Lord Voldemort. He has decided to\nget a new wand in Olivander's wand shop. On the floor of the shop, he saw ​N wands and ​N\nwand boxes. The lengths of the wands are, respectively, $X_1$\n,$X_2$\n...​$X_n$\n, and the box sizes are\n$Y_1$\n,​$Y_2$\n...$Y_n$\n. A wand of length ​X can be placed in a box of size ​Y if ​X ≤ ​Y\n. Harry wants to know\nif he can place all the wands in boxes so that each box contains exactly one wand.\nHelp him solve this difficult problem.", "inputFormat": "The first line of input contains the positive integer ​N\n(1 ≤ ​N\n≤ 100), the number from the task.\nThe second line contains ​N\npositive integers ​$X_i$\n(1 ≤ ​$X_i$\n≤ $10^9$​ ), the numbers from the task.\nThe third line contains ​N\npositive integers ​$X_i$\n(1 ≤ $X_i$\n≤ $10^9$​​ ), the numbers from the task.", "outputFormat": "If Harry can place all the wands in boxes, output “DA” (Croatian for yes), otherwise output\n“NE” (Croatian for no).", "hint": "In test cases worth 60% of total points, it will hold ​N\n≤ 9.\n\n**Clarification of the first test case:**\n\nHarry can place the wands in boxes. For example, he can place the wand of length 5 in a box of size\n6, wand of length 7 in a box of size 13, and wand of length 9 in a box of size 10.\n\n**Clarification of the second test case:**\n\nHarry can’t place the wands in boxes because the box of size 2 can’t fit any of the wands.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #5] Olivander", "background": "", "description": "哈利·波特在与伏地魔的战斗中损坏了他的魔杖。他决定去奥利凡德的魔杖店买一根新的。在商店的地板上，他看到 N 根魔杖和 N 个魔杖盒。魔杖的长度分别是 $X_1$，$X_2$，...，$X_n$，盒子的尺寸是 $Y_1$，$Y_2$，...，$Y_n$。如果魔杖的长度 X 可以放入尺寸为 Y 的盒子中，则 X ≤ Y。哈利想知道他是否可以将所有的魔杖放入盒子中，使得每个盒子恰好包含一根魔杖。帮助他解决这个难题。", "inputFormat": "输入的第一行包含正整数 N (1 ≤ N ≤ 100)，这是任务中的数字。第二行包含 N 个正整数 $X_i$ (1 ≤ $X_i$ ≤ $10^9$)，这是任务中的数字。第三行包含 N 个正整数 $Y_i$ (1 ≤ $Y_i$ ≤ $10^9$)，这是任务中的数字。", "outputFormat": "如果哈利可以将所有的魔杖放入盒子中，输出“DA”（克罗地亚语中的“是”），否则输出“NE”（克罗地亚语中的“否”）。", "hint": "在总分数的 60% 的测试用例中，将满足 N ≤ 9。\n\n**第一个测试用例的说明：**\n\n哈利可以将魔杖放入盒子中。例如，他可以将长度为 5 的魔杖放入尺寸为 6 的盒子中，长度为 7 的魔杖放入尺寸为 13 的盒子中，长度为 9 的魔杖放入尺寸为 10 的盒子中。\n\n**第二个测试用例的说明：**\n\n哈利不能将魔杖放入盒子中，因为尺寸为 2 的盒子无法容纳任何魔杖。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4614", "type": "P", "difficulty": 3, "samples": [["3 3 1\n2 2 0", "9 2 3\n8 1 4\n7 6 5"], ["3 3 1\n2 2 1", "3 2 9\n4 1 8\n5 6 7"], ["3 3 2\n1 1 0\n1 2 0", "1 1 4\n6 5 5\n19 18 17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #5] Spirale", "background": "", "description": "Little Stjepan often likes to go out with his friends and have fun in a popular nightclub in\nZagreb. However, Stjepan sometimes drinks too much soda and gets light headed from all\nthe sugar. Last night was an example of this, which is why Stjepan had the same image in\nhis mind the whole time. It was a scribble of number spirals of some sort. Since he can’t\nquite remember what the image looked like, but can describe it, he is asking you to\nreconstruct it for him.\n\nStjepan recalls that the image was of the shape of a table consisting of numbers written in ​N\nrows and ​M columns. Also, he recalls that there were ​K spirals in that table. For each spiral,\nthe starting position is known, as well as the direction it’s moving in, which can be clockwise\nand counter-clockwise. An example is shown in the images below. The spirals created\nStjepan’s image in exactly $10^{100}$ steps in the following way:\n1. Initially, the table is empty, and each spiral is in its own starting position.\n2. In each following step, each spiral moves to its next position. It is possible that, at\ntimes, the spirals leave the boundaries of the table, but also to return within it.\n3. After exactly $10^{100}$ steps, for each field in the table, the final value is the value of the\nearliest step in which one of the spirals touched that field.\n\n![](https://cdn.luogu.com.cn/upload/pic/19205.png)", "inputFormat": "The first line of input contains positive integers ​N\n, ​M\n(1 ≤ ​N\n, ​M\n≤ 50) and ​K\n(1 ≤ ​K\n≤ ​N\n*​M\n).\nEach of the following ​K lines contains three positive integers ​$X_i$\n, ​$Y_i$ and ​$T_i$ (1 ≤ ​X ≤ ​N\n, 1 ≤ ​Y ≤\nM\n, 0 ≤ ​T ≤ 1), the starting position of the $i^{th}$\nspiral and its direction (0 - clockwise, 1 -\ncounter-clockwise). No two spirals will begin in the same field.", "outputFormat": "You must output ​N lines with ​M numbers, representing the table after each spiral makes\n$10^{100}$ steps.", "hint": "In test cases worth 50% of total points, it will hold: ​N\n=​M\ni ​K\n=1 and ​$X_i$\n=​$Y_i$\n=$\\lfloor\\frac{N+1}{2}\\rfloor$, i.e. ​$X_i$\nand ​$Y_i$ \nwill be equal to the integer division of ​N\n+1 with 2.\n\n![](https://cdn.luogu.com.cn/upload/pic/19206.png)\n\nFor simplicity’s sake, the letter A was added to the numbers from the first spiral, and the letter B to the\nnumbers from the second spiral. Only the first 20 steps of the first spiral are shown, and 21 steps of\nthe second spiral. The fields in gray are the fields from the table we’re interested in, all other fields are\nout of the table’s bounds, but are shown to illustrate the way the spirals move outside of the table.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #5] Spirale", "background": "", "description": "Little Stjepan often likes to go out with his friends and have fun in a popular nightclub in\nZagreb. However, Stjepan sometimes drinks too much soda and gets light headed from all\nthe sugar. Last night was an example of this, which is why Stjepan had the same image in\nhis mind the whole time. It was a scribble of number spirals of some sort. Since he can’t\nquite remember what the image looked like, but can describe it, he is asking you to\nreconstruct it for him.\n\nStjepan recalls that the image was of the shape of a table consisting of numbers written in ​N\nrows and ​M columns. Also, he recalls that there were ​K spirals in that table. For each spiral,\nthe starting position is known, as well as the direction it’s moving in, which can be clockwise\nand counter-clockwise. An example is shown in the images below. The spirals created\nStjepan’s image in exactly $10^{100}$ steps in the following way:\n1. Initially, the table is empty, and each spiral is in its own starting position.\n2. In each following step, each spiral moves to its next position. It is possible that, at\ntimes, the spirals leave the boundaries of the table, but also to return within it.\n3. After exactly $10^{100}$ steps, for each field in the table, the final value is the value of the\nearliest step in which one of the spirals touched that field.\n\n![](https://cdn.luogu.com.cn/upload/pic/19205.png)", "inputFormat": "The first line of input contains positive integers ​N\n, ​M\n(1 ≤ ​N\n, ​M\n≤ 50) and ​K\n(1 ≤ ​K\n≤ ​N\n*​M\n).\nEach of the following ​K lines contains three positive integers ​$X_i$\n, ​$Y_i$ and ​$T_i$ (1 ≤ ​X ≤ ​N\n, 1 ≤ ​Y ≤\nM\n, 0 ≤ ​T ≤ 1), the starting position of the $i^{th}$\nspiral and its direction (0 - clockwise, 1 -\ncounter-clockwise). No two spirals will begin in the same field.", "outputFormat": "You must output ​N lines with ​M numbers, representing the table after each spiral makes\n$10^{100}$ steps.", "hint": "In test cases worth 50% of total points, it will hold: ​N\n=​M\ni ​K\n=1 and ​$X_i$\n=​$Y_i$\n=$\\lfloor\\frac{N+1}{2}\\rfloor$, i.e. ​$X_i$\nand ​$Y_i$ \nwill be equal to the integer division of ​N\n+1 with 2.\n\n![](https://cdn.luogu.com.cn/upload/pic/19206.png)\n\nFor simplicity’s sake, the letter A was added to the numbers from the first spiral, and the letter B to the\nnumbers from the second spiral. Only the first 20 steps of the first spiral are shown, and 21 steps of\nthe second spiral. The fields in gray are the fields from the table we’re interested in, all other fields are\nout of the table’s bounds, but are shown to illustrate the way the spirals move outside of the table.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #5] Spirale", "background": "", "description": "小斯捷潘经常喜欢和朋友们一起去萨格勒布一家很受欢迎的夜总会玩。不过，斯捷潘有时会喝太多苏打水，糖分过多会让他头晕目眩。昨晚就是一个例子，所以斯捷潘脑海中一直浮现着同一个画面。那是一个潦草的数字螺旋。由于他不太记得那幅图的样子，但可以描述出来，所以他请求您为他重现那幅图。\n\n斯捷潘回忆说，图像是一张表格，由 $N$ 行 $M$ 列数字组成。此外，他还记得表格中有 $K$ 个螺旋。每个螺旋的起始位置和移动方向都是已知的，有顺时针和逆时针两种。下面的图片就是一个例子。这些螺旋以如下方式创建了斯捷潘的图像，步数正好为 $10^{100}$ ：\n\n1. 一开始，表格是空的，每个螺旋都在自己的起始位置。\n2. 在接下来的每一步中，每个螺旋都会移动到下一个位置。有时，螺旋可能会离开表格，但也可能会返回到表格内。\n3. 经过整整 $10^{100}$ 步后，对于表格中的每个格子，格子中的数值就是其中一个螺旋最少经过该格子的步数。\n\n![](https://cdn.luogu.com.cn/upload/pic/19205.png)", "inputFormat": "第一行输入包含正整数 $N$ , $M$ （ $1 ≤ N , M ≤ 50$ ）和 $K$ （ $1 ≤ K ≤ N \\times M$ ）。下面 $K$ 行中的每一行都包含三个正整数 $X_i,Y_i,T_i$ （ $1 ≤ X_i ≤ N , 1 ≤ Y_i ≤ M , 0 ≤ T_i ≤ 1$ ），第 $i$ 个螺旋的起始位置和方向（ $0$ 表示顺时针，$1$ 表示逆时针）。没有螺旋的起始位置在同一格子上。", "outputFormat": "您必须输出一个 $N$ 行 $M$ 列的表格，表示在每个螺旋移动 $10^{100}$ 步之后的表格。", "hint": "对于 $50\\%$ 的数据来说，保证 $N=M,K=1$ 并且 $X_i=Y_i=\\lfloor\\frac{N+1}{2}\\rfloor$ （也就是说， $X_i$ 和 $Y_i$ 会等于 $N+1$ 除以 $2$ 再下取整的结果。）\n\n![](https://cdn.luogu.com.cn/upload/pic/19206.png)\n\n为简单起见，在第一个螺旋的数字后面加上字母 `A` ，在第二个螺旋的数字后面加上字母 `B` 。只显示了第一个螺旋的前 $20$ 步和第二个螺旋的前 $21$ 步。灰色格子是表格中的格子，其他格子都超出了表格的范围，但显示出来是为了说明螺旋在表格外移动的方式。", "locale": "zh-CN"}}}
{"pid": "P4615", "type": "P", "difficulty": 3, "samples": [["3\n1 1", "5 1 1"], ["5\n1 2 2 4", "13 8 1 3 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #5] Birokracija", "background": "", "description": "Mirko has become CEO of a huge corporation. This corporation consists of ​N people,\nlabeled from 1 to ​N\n, and Mirko is labeled 1. The corporation is structured so that each\nemployee (except Mirko) has a boss, and we say that employee is an assistant to that boss.\nEach boss can have multiple assistants, but still reports to their boss. This holds for\neveryone except Mirko, who is at the top of the pyramid and doesn’t have a boss, but has his\nassistants.\n\nWhen Mirko gets a task from the investors, he then delegates that task to his assistant with\nthe minimal number. This assistant then delegates the task to their assistant with the\nminimal number, and this process repeats until the task is given to an unlucky person\nwithout an assistant, who then must do the task.\n\nThis is when the real problems begin. The person that did the task gets paid 1 coin, the boss\nof that person gets 2 coins, the boss of that person gets 3 coins, and so on, all the way to\nMirko, who gets as many coins as there are people in this sequence. After that, the\nemployee that really did the job realizes how unfair the system is and quits their job out of\nprinciple.\n\nWhen it comes to doing the next task in the corporation, there is a person less, so maybe the\npaychecks are less, but the work must continue. Tasks are piling up, so the whole procedure\n(assigning a new task, doing it, dividing paychecks and the person doing the task quitting)\nrepeats until Mirko is left alone in the corporation and does his first (also his last) task.\n\nOf course, Mirko will have amassed quite a fortune until then, but he also wants to know how\nmuch money each of the employees earned.", "inputFormat": "The first line of input contains the positive integer ​N (2 ≤ ​N ≤ 2·$10^5$​ ), the number of\nemployees (including Mirko).\n\nThe following line contains ​N- 1 positive integers $a_2$​ , ​$a_3$​ , ​$a_4$ , …, ​$a_n$\n(1 ≤ ​$a_i$\n< ​i\n), where ​$a_i$\ndenotes the boss of employee ​i\n.", "outputFormat": "You must output a single line consisting of ​N numbers, the $i^{th}$ number corresponding to the\namount of money earned by the $i^{th}$ employee.", "hint": "In test cases worth 50% of total points, it will hold 2 ≤ ​N\n≤ 5000.\n\n**Clarification of the second test case:**\n\nMirko assigns the first task to employee 2, who then assigns it to employee 3, who then does it. For\nthis, employee 3 gets 1 coin, employee 2 gets 2 coins, and employee 1 (Mirko) gets 3 coins.\nEmployee 3 then quits.\n\nMirko assigns the second task to employee 2, who then assigns it to employee 4 (because employee\n3 quit), who then assigns it to employee 5, who then does it. For this, employee 5 gets 1 coin,\nemployee 4 gets 2 coins, employee 2 gets 3 coins, and employee 1 gets 4 coins. Employee 5 then quits.\n\nThe procedure is repeated for a total of 5 tasks.\n\nIn total, Mirko gets 13 coins, employee 2 gets 8, employee 4 gets 3, and employee 3 and 5 each get 1\ncoin.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #5] Birokracija", "background": "", "description": "Mirko has become CEO of a huge corporation. This corporation consists of ​N people,\nlabeled from 1 to ​N\n, and Mirko is labeled 1. The corporation is structured so that each\nemployee (except Mirko) has a boss, and we say that employee is an assistant to that boss.\nEach boss can have multiple assistants, but still reports to their boss. This holds for\neveryone except Mirko, who is at the top of the pyramid and doesn’t have a boss, but has his\nassistants.\n\nWhen Mirko gets a task from the investors, he then delegates that task to his assistant with\nthe minimal number. This assistant then delegates the task to their assistant with the\nminimal number, and this process repeats until the task is given to an unlucky person\nwithout an assistant, who then must do the task.\n\nThis is when the real problems begin. The person that did the task gets paid 1 coin, the boss\nof that person gets 2 coins, the boss of that person gets 3 coins, and so on, all the way to\nMirko, who gets as many coins as there are people in this sequence. After that, the\nemployee that really did the job realizes how unfair the system is and quits their job out of\nprinciple.\n\nWhen it comes to doing the next task in the corporation, there is a person less, so maybe the\npaychecks are less, but the work must continue. Tasks are piling up, so the whole procedure\n(assigning a new task, doing it, dividing paychecks and the person doing the task quitting)\nrepeats until Mirko is left alone in the corporation and does his first (also his last) task.\n\nOf course, Mirko will have amassed quite a fortune until then, but he also wants to know how\nmuch money each of the employees earned.", "inputFormat": "The first line of input contains the positive integer ​N (2 ≤ ​N ≤ 2·$10^5$​ ), the number of\nemployees (including Mirko).\n\nThe following line contains ​N- 1 positive integers $a_2$​ , ​$a_3$​ , ​$a_4$ , …, ​$a_n$\n(1 ≤ ​$a_i$\n< ​i\n), where ​$a_i$\ndenotes the boss of employee ​i\n.", "outputFormat": "You must output a single line consisting of ​N numbers, the $i^{th}$ number corresponding to the\namount of money earned by the $i^{th}$ employee.", "hint": "In test cases worth 50% of total points, it will hold 2 ≤ ​N\n≤ 5000.\n\n**Clarification of the second test case:**\n\nMirko assigns the first task to employee 2, who then assigns it to employee 3, who then does it. For\nthis, employee 3 gets 1 coin, employee 2 gets 2 coins, and employee 1 (Mirko) gets 3 coins.\nEmployee 3 then quits.\n\nMirko assigns the second task to employee 2, who then assigns it to employee 4 (because employee\n3 quit), who then assigns it to employee 5, who then does it. For this, employee 5 gets 1 coin,\nemployee 4 gets 2 coins, employee 2 gets 3 coins, and employee 1 gets 4 coins. Employee 5 then quits.\n\nThe procedure is repeated for a total of 5 tasks.\n\nIn total, Mirko gets 13 coins, employee 2 gets 8, employee 4 gets 3, and employee 3 and 5 each get 1\ncoin.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #5] Birokracija", "background": null, "description": "Mirko 是一家大公司的 CEO。该公司由 $N$ 人组成，编号为 $1$ 到 $N$，Mirko 编号为 $1$ 。公司的结构像一棵树一样，每个员工（Mirko 除外）都有老板，我们说这个员工是该老板的助手。每个老板都可以有多名助手。Mirko 没有老板，但有他的助手。\n\n之后会有一些任务，Mirko 会将该任务委托给他编号最小的助手。然后，该助手也将任务委托给他编号最小的助手，并且这个过程重复进行，直到任务被发送给没有助手的人，然后他必须亲自完成任务。\n\n执行任务的人获得 $1$ 个硬币，那个人的老板获得 $2$ 个硬币，那个人的老板获得 $3$ 个硬币，依此类推，一直到 Mirko。之后，真正完成工作的员工意识到系统的不公平并感到伤心，并且不会再执行任务（也就是辞职）。\n\n当公司收到的下一个任务时，因为少了一个人，所以薪水可能更少，但工作必须继续。任务是无限多的（直到公司倒闭），因此整个过程（分配新任务，执行任务，划分薪水和执行任务人员的退出）重复进行，最后 Mirko 独自留在公司并完成他的第一个（也是他的最后一个）任务。\n\n当然，在此之前， Mirko 将积累相当多的财富，但他也想知道每个员工赚了多少钱。", "inputFormat": "第一行有一个整数 $N(2 \\le N \\le 2 \\times 10^5)$，即包括 Mirko 在内的员工的个数。\n\n紧接着第二行有 $N-1$ 个整数，分别为 $a_2,a_3,\\cdots ,a_N(1 \\le a_i < i )$，$a_i$ 表示员工 $i$ 的老板。", "outputFormat": "输出一行 $N$ 个整数，第 $i$ 个整数表示编号为 $i$ 的人能得到的金币数。", "hint": "$50\\%$ 的数据满足 $2 \\le N \\le 5000$。", "locale": "zh-CN"}}}
{"pid": "P4616", "type": "P", "difficulty": 5, "samples": [["8 3 3\n2 5\n3 6\n4 8", "3\n1\n2"], ["25 6 1\n20 9", "4"], ["9999 2222 2\n1025 2405\n3154 8949", "1980\n2160"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "并查集", "Kruskal 重构树", "最近公共祖先 LCA", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #5] Pictionary", "background": "", "description": "There is a planet, in a yet undiscovered part of the universe, with a country inhabited solely\nby mathematicians. In this country, there are a total of ​N mathematicians, and the interesting\nfact is that each mathematician lives in their own city. Is it also interesting that no two cities\nare connected with a road, because mathematicians can communicate online or by\nreviewing academic papers. Naturally, the cities are labeled with numbers from 1 to ​N.\n\nLife was perfect until one mathematician decided to write an academic paper on their\nsmartphone. The smartphone auto-corrected the word “self-evident” to “Pictionary” and the\npaper was published as such. Soon after, the entire country discovered pictionary and\nwanted to meet up and play, so construction work on roads between cities began shortly.\n.\nThe road construction will last a total of ​M days, according to the following schedule: on the\nfirst day, construction is done on roads between all pairs of cities that have ​M as their\ngreatest common divisor. On the second day, construction is done on roads between all\npairs of cities that have ​M-1 as their greatest common divisor, and so on until the ​$M^{th}$ day\nwhen construction is done on roads between all pairs of cities that are co-prime. More\nformally, on the $i^{th}$ day, construction is done on roads between cities ​a and ​b if ​gcd(a, b) = $M-i+1$.\n\nSince the mathematicians are busy with construction work, they’ve asked you to help them\ndetermine the minimal number of days before a given pair of mathematicians can play\npictionary together.", "inputFormat": "The first line of input contains three positive integers ​N, M\nand ​Q\n(1 ≤ ​N\n, ​Q ≤ 100 000, 1 ≤ ​M\n≤ ​N\n), the number of cities, the number of days it takes to build the roads, and the number of\nqueries.\n\nEach of the following ​Q lines contains two distinct positive integers ​A and ​B\n(1 ≤ ​A\n, ​B ≤ ​N\n)\nthat denote the cities of the mathematicians who want to find out the minimal number of days\nbefore they can play pictionary together.", "outputFormat": "The $i^{th}$ line must contain the minimal number of days before the mathematicians from the $i^{th}$ query can play pictionary together.", "hint": "In test cases worth 40% of total points, it will hold ​N\n≤ 1000, ​Q\n≤ 100 000.\n\n**Clarification of the first test case:**\n\nOn the first day, road (3, 6) is built. Therefore the answer to the second query is 1.\n\nOn the second day, roads (2, 4), (2, 6), (2, 8), (4, 6) and (6, 8) are built. Cities 4 and 8 are now\nconnected (it is possible to get from the first to the second using city 6).\n\nOn the third day, roads between relatively prime cities are built, so cities 2 and 5 are connected.\n\n**Clarification of the second test case:**\n\nOn the second day, road (20, 15) is built, whereas on the fourth day, road (15, 9) is built. After the\nfourth day, cities 20 and 9 are connected via city 15.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #5] Pictionary", "background": "", "description": "There is a planet, in a yet undiscovered part of the universe, with a country inhabited solely\nby mathematicians. In this country, there are a total of ​N mathematicians, and the interesting\nfact is that each mathematician lives in their own city. Is it also interesting that no two cities\nare connected with a road, because mathematicians can communicate online or by\nreviewing academic papers. Naturally, the cities are labeled with numbers from 1 to ​N.\n\nLife was perfect until one mathematician decided to write an academic paper on their\nsmartphone. The smartphone auto-corrected the word “self-evident” to “Pictionary” and the\npaper was published as such. Soon after, the entire country discovered pictionary and\nwanted to meet up and play, so construction work on roads between cities began shortly.\n.\nThe road construction will last a total of ​M days, according to the following schedule: on the\nfirst day, construction is done on roads between all pairs of cities that have ​M as their\ngreatest common divisor. On the second day, construction is done on roads between all\npairs of cities that have ​M-1 as their greatest common divisor, and so on until the ​$M^{th}$ day\nwhen construction is done on roads between all pairs of cities that are co-prime. More\nformally, on the $i^{th}$ day, construction is done on roads between cities ​a and ​b if ​gcd(a, b) = $M-i+1$.\n\nSince the mathematicians are busy with construction work, they’ve asked you to help them\ndetermine the minimal number of days before a given pair of mathematicians can play\npictionary together.", "inputFormat": "The first line of input contains three positive integers ​N, M\nand ​Q\n(1 ≤ ​N\n, ​Q ≤ 100 000, 1 ≤ ​M\n≤ ​N\n), the number of cities, the number of days it takes to build the roads, and the number of\nqueries.\n\nEach of the following ​Q lines contains two distinct positive integers ​A and ​B\n(1 ≤ ​A\n, ​B ≤ ​N\n)\nthat denote the cities of the mathematicians who want to find out the minimal number of days\nbefore they can play pictionary together.", "outputFormat": "The $i^{th}$ line must contain the minimal number of days before the mathematicians from the $i^{th}$ query can play pictionary together.", "hint": "In test cases worth 40% of total points, it will hold ​N\n≤ 1000, ​Q\n≤ 100 000.\n\n**Clarification of the first test case:**\n\nOn the first day, road (3, 6) is built. Therefore the answer to the second query is 1.\n\nOn the second day, roads (2, 4), (2, 6), (2, 8), (4, 6) and (6, 8) are built. Cities 4 and 8 are now\nconnected (it is possible to get from the first to the second using city 6).\n\nOn the third day, roads between relatively prime cities are built, so cities 2 and 5 are connected.\n\n**Clarification of the second test case:**\n\nOn the second day, road (20, 15) is built, whereas on the fourth day, road (15, 9) is built. After the\nfourth day, cities 20 and 9 are connected via city 15.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #5] Pictionary", "background": "", "description": "在宇宙一个不为人知的地方，有一个星球，上面有一个国家，只有数学家居住。\n在这个国家有$n$个数学家，有趣的是，每个数学家都住在自己的城市，且城市间无道路相连，因为他们可以在线交流。当然，城市有从$1$到$n$的编号。\n\n一位数学家决定用手机发论文，而手机将“不言而喻”自动更正成了“猜谜游戏”。\n不久之后，这个国家就发现了猜谜游戏。他们想要见面一起玩，于是这个国家就开始了修路工程。\n道路修建会持续$m$天。对于第$i$天，若$\\gcd(a,b)=m-i+1$，则$a$和$b$城市间会修一条路。\n\n由于数学家们忙于建筑工作，请你来确定一对数学家最早什么时候能凑到一起玩。", "inputFormat": "第一行有三个正整数$n,m,q$，表示城市数量、修路持续天数、询问数量。\n接下来$q$行，每行有两个正整数$a,b$，表示询问$a$和$b$两个城市的数学家最早什么时候能在一起玩。", "outputFormat": "输出$q$行，第$i$行有一个正整数，表示第$i$次询问的结果\n\n## 说明", "hint": "对于$40\\%$的数据：\n$n≤4000,q≤10^5$  \n对于全部数据：  \n$1≤n,q≤10^5$  \n$1≤m≤n$\n\n样例1解释：\n在第一天，$(3,6)$之间修了一条路，因此第二次询问输出`1`  \n在第二天，$(2,4),(2,6),(2,8),(4,6),(6,8)$之间都修了一条路，此时$4$和$8$号城市连通，第三次询问输出`2`  \n在第三天，所有编号互质的城市之间都修了路，$2$和$5$号城市在此时连通，第一次询问输出`1`\n\n样例2解释：\n在第二天，$(20,15)$之间修了一条路  \n第四天，$(15,9)$之间修了一条路  \n所以$20$和$9$号城市在第四天连通，输出`4`", "locale": "zh-CN"}}}
{"pid": "P4617", "type": "P", "difficulty": 6, "samples": [["2 3\n1 2\n2 2\n2 1", "Slavko\nSlavko"], ["4 5\n2 2\n1 2\n1 1\n1 3\n4 2", "Slavko\nMirko\nMirko\nMirko"], ["4 5\n1 2\n1 3\n2 2\n2 3\n4 1", "Slavko\nSlavko\nMirko\nSlavko"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #5] Planinarenje", "background": "", "description": "Mirko and Slavko like to hike together. Mirko likes mountain peaks, and Slavko likes valleys.\nBecause of this, every time they climb to a peak, Slavko decides which valley they are going\nto descend to, given that a trail exists to it. Similarly, in each valley, Mirko decides which\npeak they are going to climb up to. It will never be possible to directly climb from one peak to\nanother, or to get from one valley to another valley. In order to make the hiking as fun as\npossible, they never visit the same spot twice (whether it’s a peak or a valley). Once they\nreach a spot that only leads to spots they’ve visited before, they call the mountain rangers to\npick them up. If the final spot is a peak, Mirko wins, and if it is a valley, Slavko wins.\n\nNaturally, you must already know what your task is: If we assume that both of them play\noptimally, who wins? Answer this question for all initial peaks.", "inputFormat": "The first line contains two positive integers, ​N and ​M (1 ≤ ​N ≤ 5000, 1 ≤ ​M ≤ min(5000, ​N\n·​N\n)).\nHere ​N denotes the number of peaks and valleys (therefore, there are ​N peaks and ​N\nvalleys), and ​M\ndenotes the number of hiking trails.\n\nEach of the following ​M lines contains two positive integers: ​$v_i$ and ​​$d_i$ (1 ≤ ​​$v_i$ , ​​$d_i$ ≤ ​N) that\ndenote there is a trail between peak ​​$v_i$ and valley ​$d_i$.\nBetween each peak and valley, there will exist at most one trail.", "outputFormat": "You must output ​N\nlines. The ​$i^{th}$ line denotes the winner if the starting point is peak ​i\n.", "hint": "In test cases worth 30% of total points, it will hold 1 ≤ ​N\n≤ 10 and 1 ≤ ​M\n≤ ​N\n·​N\n.\n\nIn test cases worth an additional 20% of total points, for each two connected spots, there will\nexist a unique path between them. In other words, the graph will be a forest.\n\n**Clarification of the second test case:**\n\nStarting from the first peak, Slavko can choose to go to the first valley, so Slavko wins.\n\nStarting from the second peak, Slavko can choose to go to the second valley, after which Mirko wins\nby choosing to go to the fourth peak.\n\nStarting from the third peak, there are no trails, so Mirko wins.\n\nStarting from the fourth peak, Slavko must choose to go to the second valley, after which Mirko wins\nby choosing the second peak.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #5] Planinarenje", "background": "", "description": "Mirko and Slavko like to hike together. Mirko likes mountain peaks, and Slavko likes valleys.\nBecause of this, every time they climb to a peak, Slavko decides which valley they are going\nto descend to, given that a trail exists to it. Similarly, in each valley, Mirko decides which\npeak they are going to climb up to. It will never be possible to directly climb from one peak to\nanother, or to get from one valley to another valley. In order to make the hiking as fun as\npossible, they never visit the same spot twice (whether it’s a peak or a valley). Once they\nreach a spot that only leads to spots they’ve visited before, they call the mountain rangers to\npick them up. If the final spot is a peak, Mirko wins, and if it is a valley, Slavko wins.\n\nNaturally, you must already know what your task is: If we assume that both of them play\noptimally, who wins? Answer this question for all initial peaks.", "inputFormat": "The first line contains two positive integers, ​N and ​M (1 ≤ ​N ≤ 5000, 1 ≤ ​M ≤ min(5000, ​N\n·​N\n)).\nHere ​N denotes the number of peaks and valleys (therefore, there are ​N peaks and ​N\nvalleys), and ​M\ndenotes the number of hiking trails.\n\nEach of the following ​M lines contains two positive integers: ​$v_i$ and ​​$d_i$ (1 ≤ ​​$v_i$ , ​​$d_i$ ≤ ​N) that\ndenote there is a trail between peak ​​$v_i$ and valley ​$d_i$.\nBetween each peak and valley, there will exist at most one trail.", "outputFormat": "You must output ​N\nlines. The ​$i^{th}$ line denotes the winner if the starting point is peak ​i\n.", "hint": "In test cases worth 30% of total points, it will hold 1 ≤ ​N\n≤ 10 and 1 ≤ ​M\n≤ ​N\n·​N\n.\n\nIn test cases worth an additional 20% of total points, for each two connected spots, there will\nexist a unique path between them. In other words, the graph will be a forest.\n\n**Clarification of the second test case:**\n\nStarting from the first peak, Slavko can choose to go to the first valley, so Slavko wins.\n\nStarting from the second peak, Slavko can choose to go to the second valley, after which Mirko wins\nby choosing to go to the fourth peak.\n\nStarting from the third peak, there are no trails, so Mirko wins.\n\nStarting from the fourth peak, Slavko must choose to go to the second valley, after which Mirko wins\nby choosing the second peak.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #5] Planinarenje", "background": "", "description": "米尔科和斯拉夫科喜欢一起徒步旅行。米尔科喜欢山峰，而斯拉夫科喜欢山谷。因此，每次他们爬到一个山峰时，斯拉夫科决定他们要下到哪个山谷，前提是有通往该山谷的小径。同样地，在每个山谷中，米尔科决定他们要爬上哪个山峰。永远不可能直接从一个山峰爬到另一个山峰，或从一个山谷到另一个山谷。为了使徒步旅行尽可能有趣，他们从不重复访问同一个地点（无论是山峰还是山谷）。一旦他们到达一个只能通往他们之前访问过的地点的地方，他们就会叫山地救援队来接他们。如果最后一个地点是山峰，米尔科获胜；如果是山谷，斯拉夫科获胜。\n\n显然，你已经知道你的任务是什么：如果我们假设他们两个都以最佳方式进行游戏，谁会获胜？请为所有初始山峰回答这个问题。", "inputFormat": "第一行包含两个正整数，$N$ 和 $M$（$1 \\leq N \\leq 5000$，$1 \\leq M \\leq \\min(5000, N \\cdot N)$）。这里 $N$ 表示山峰和山谷的数量（因此，有 $N$ 个山峰和 $N$ 个山谷），而 $M$ 表示徒步小径的数量。\n\n接下来的 $M$ 行中的每一行包含两个正整数：$v_i$ 和 $d_i$（$1 \\leq v_i, d_i \\leq N$），表示在山峰 $v_i$ 和山谷 $d_i$ 之间有一条小径。每对山峰和山谷之间最多存在一条小径。", "outputFormat": "你必须输出 $N$ 行。第 $i$ 行表示如果起点是山峰 $i$，谁是获胜者。", "hint": "在占总分数 30% 的测试用例中，将满足 $1 \\leq N \\leq 10$ 和 $1 \\leq M \\leq N \\cdot N$。\n\n在额外占总分数 20% 的测试用例中，对于每两个连接的地点之间，将存在唯一的路径。换句话说，图将是一个森林。\n\n**第二个测试用例的说明：**\n\n从第一个山峰开始，斯拉夫科可以选择去第一个山谷，所以斯拉夫科获胜。\n\n从第二个山峰开始，斯拉夫科可以选择去第二个山谷，之后米尔科通过选择去第四个山峰获胜。\n\n从第三个山峰开始，没有小径，所以米尔科获胜。\n\n从第四个山峰开始，斯拉夫科必须选择去第二个山谷，之后米尔科通过选择第二个山峰获胜。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4618", "type": "P", "difficulty": 7, "samples": [["2\n5 3 10000 12345 54321\n3\n1 2 3\n2 1 3\n1 3 2\n10 6 23456 77777 55555\n5\n1 1 10\n2 3 5\n2 7 5\n2 5 4\n1 8 6", "1\n5\n1\n4\n34\n61\n45\n3"]], "limits": {"time": [10000, 10000, 10000], "memory": [512000, 512000, 512000]}, "tags": ["2018", "各省省选", "山东", "O2优化", "可持久化线段树"], "title": "[SDOI2018] 原题识别", "background": "- Input file: old.in\n - Output file: old.out\n - Time limit: 10 seconds\n - Memory limit: 512 megabytes", "description": "“人肉题库” 小 $Q$ 刷题非常勤奋，题量破万。每当有人拿题目请教他时，小 $Q$ 总能在 $1$ 秒内报出这\n是哪个 $OJ$ 的哪道题。因此，小 $Q$ 是被当作 “原题搜索机” 一样的存在。\n\n有一天，小 $Q$ 来到了一棵 $n$ 个节点的有根树下，这棵树的根节点为 $1$ 号点，且每个节点都印着一道\n题目。凭借超大的题量，小 $Q$ 迅速识别出了每道题的来源，并发现有些题目被搬运了好多次。他把每个\n节点的题目都做了一个分类，第 $i$ 个节点的题目对应的题目种类为 $a_i$，当且仅当 $a_i=a_j$ 时，$i$ 点和 $j$ 点的题目来源是相同的。\n\n同一道题目做多次除了增加 $AC$ 数以外，对本身的水平没有任何提高。为了调查这棵树的题目质量，\n小 $Q$ 会不断提出以下两种询问共 $m$ 次：\n\n- $1$ $x$ $y$：如果将 $x$ 点到 $y$ 点的最短路径上的所有点 (包括 $x$ 和 $y$) 对应的题目都做一遍，那么一共可\n以做到多少道本质不同的题目？\n\n- $2$ $A$ $B$：如果在 $A$ 点到根的最短路径上 (包括 $A$ 点和根) 等概率随机选择一个点 $x$，在 $B$ 点到根的最短路径上 (包括 $B$ 点和根) 等概率随机选择一个点 $y$，那么询问 $1$ $x$ $y$ 的答案期望是多少？\n\n定义 $cnt_x$ 表示 $x$ 点到根最短路径上的节点个数，因为小 $Q$ 不喜欢分数，而且第 $2$ 类询问的答案一\n定可以表示成 $\\frac{ans}{{cnt_A}\\times{cnt_B}}$ 的形式，你只需要告诉他 $ans$ 的值就可以了。\n\n识别这些题目消耗了小 $Q$ 太大的精力，他没有办法自己去计算这些简单的询问的答案。请写一个程序回答小 $Q$ 的所有 $m$ 个问题。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n每组数据第一行包含 $5$ 个正整数 $n, p, SA, SB, SC$，其中 $n$ 表示树的节点个数。\n\n为了在某种程度上减少输入量，树边和每个点的题目种类 $a[]$ 将由以下代码生成：\n```\nunsigned int SA, SB, SC;\nunsigned int rng61(){\n\tSA ^= SA << 16;\n\tSA ^= SA >> 5;\n\tSA ^= SA << 1;\n\tunsigned int t = SA;\n\tSA = SB;\n\tSB = SC;\n\tSC ^= t ^ SA;\n\treturn SC;\n}\nvoid gen(){\n\tscanf(\"%d%d%u%u%u\", &n, &p, &SA, &SB, &SC);\n\tfor(int i = 2; i <= p; i++)\n\taddedge(i - 1, i);\n\tfor(int i = p + 1; i <= n; i++)\n\taddedge(rng61() % (i - 1) + 1, i);\n\tfor(int i = 1; i <= n; i++)\n\ta[i] = rng61() % n + 1;\n}\n```\n第二行包含一个正整数 $m$，表示询问次数。\n\n接下来 $m$ 行，每行 $3$ 个正整数，形式为 $1$ $x$ $y$ 或者 $2$ $A$ $B$，依次表示每个询问。", "outputFormat": "对于每组数据，输出 $m$ 行，每行一个整数，依次回答每个询问。", "hint": "- $1 \\le T \\le 3,2 \\le p \\le n \\le 10^5,1 \\le m \\le 2\\times 10^5$\n - $ 10^4 \\le SA, SB, SC \\le 10^6,1 \\le x, y, A, B \\le n$\n\n子任务 $1$（$30$ 分）：只含第 $1$ 类询问。\n\n子任务 $2$（$30$ 分）：满足 $p = n$。\n\n子任务 $3$（$40$ 分）：没有任何附加的限制。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2018] Original Problem Identification", "background": "- Input file: old.in\n- Output file: old.out\n- Time limit: 10 seconds.\n- Memory limit: 512 megabytes.", "description": "“Human problem database” Little $Q$ practices very hard and has solved over ten thousand problems. Whenever someone asks him about a problem, Little $Q$ can tell within $1$ second which $OJ$ and which problem it is. Therefore, Little $Q$ is like an “original problem search engine”.\n\nOne day, Little $Q$ came to a rooted tree with $n$ nodes. The root is node $1$, and each node has a problem printed on it. With his huge amount of experience, Little $Q$ quickly identified the source of every problem, and found that some problems had been reposted many times. He classified the problem on each node: the problem type of node $i$ is $a_i$. The problems at node $i$ and node $j$ come from the same source if and only if $a_i = a_j$.\n\nSolving the same problem multiple times does not improve skill, except increasing the number of $AC$ submissions. To investigate the quality of the problems on this tree, Little $Q$ will ask the following two types of queries for a total of $m$ times:\n\n- $1$ $x$ $y$: If you solve all problems on the shortest path from node $x$ to node $y$ (including $x$ and $y$), how many essentially different problems can you solve in total?\n\n- $2$ $A$ $B$: If you choose a node $x$ uniformly at random on the shortest path from node $A$ to the root (including $A$ and the root), and choose a node $y$ uniformly at random on the shortest path from node $B$ to the root (including $B$ and the root), what is the expected answer to query $1$ $x$ $y$?\n\nLet $cnt_x$ denote the number of nodes on the shortest path from node $x$ to the root. Since Little $Q$ does not like fractions, and the answer to the second type of query can always be written as $\\frac{ans}{{cnt_A}\\times{cnt_B}}$, you only need to output the value of $ans$.\n\nIdentifying these problems has consumed too much of Little $Q$’s energy, so he cannot compute the answers to these simple queries by himself. Please write a program to answer all $m$ queries for Little $Q$.", "inputFormat": "The first line contains a positive integer $T$, denoting the number of testdata.\n\nFor each testdata, the first line contains $5$ positive integers $n, p, SA, SB, SC$, where $n$ is the number of nodes in the tree.\n\nTo reduce the input size to some extent, the tree edges and the problem type array $a[]$ will be generated by the following code:\n```\nunsigned int SA, SB, SC;\nunsigned int rng61(){\n\tSA ^= SA << 16;\n\tSA ^= SA >> 5;\n\tSA ^= SA << 1;\n\tunsigned int t = SA;\n\tSA = SB;\n\tSB = SC;\n\tSC ^= t ^ SA;\n\treturn SC;\n}\nvoid gen(){\n\tscanf(\"%d%d%u%u%u\", &n, &p, &SA, &SB, &SC);\n\tfor(int i = 2; i <= p; i++)\n\taddedge(i - 1, i);\n\tfor(int i = p + 1; i <= n; i++)\n\taddedge(rng61() % (i - 1) + 1, i);\n\tfor(int i = 1; i <= n; i++)\n\ta[i] = rng61() % n + 1;\n}\n```\n\nThe second line contains a positive integer $m$, denoting the number of queries.\n\nThe next $m$ lines each contain $3$ positive integers, in the form $1$ $x$ $y$ or $2$ $A$ $B$, representing each query in order.", "outputFormat": "For each testdata, output $m$ lines, one integer per line, answering each query in order.", "hint": "- $1 \\le T \\le 3,2 \\le p \\le n \\le 10^5,1 \\le m \\le 2\\times 10^5$.\n- $10^4 \\le SA, SB, SC \\le 10^6,1 \\le x, y, A, B \\le n$.\n\nSubtask $1$ ($30$ points): only contains type $1$ queries.\n\nSubtask $2$ ($30$ points): satisfies $p = n$.\n\nSubtask $3$ ($40$ points): no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2018] 原题识别", "background": "- Input file: old.in\n - Output file: old.out\n - Time limit: 10 seconds\n - Memory limit: 512 megabytes", "description": "“人肉题库” 小 $Q$ 刷题非常勤奋，题量破万。每当有人拿题目请教他时，小 $Q$ 总能在 $1$ 秒内报出这\n是哪个 $OJ$ 的哪道题。因此，小 $Q$ 是被当作 “原题搜索机” 一样的存在。\n\n有一天，小 $Q$ 来到了一棵 $n$ 个节点的有根树下，这棵树的根节点为 $1$ 号点，且每个节点都印着一道\n题目。凭借超大的题量，小 $Q$ 迅速识别出了每道题的来源，并发现有些题目被搬运了好多次。他把每个\n节点的题目都做了一个分类，第 $i$ 个节点的题目对应的题目种类为 $a_i$，当且仅当 $a_i=a_j$ 时，$i$ 点和 $j$ 点的题目来源是相同的。\n\n同一道题目做多次除了增加 $AC$ 数以外，对本身的水平没有任何提高。为了调查这棵树的题目质量，\n小 $Q$ 会不断提出以下两种询问共 $m$ 次：\n\n- $1$ $x$ $y$：如果将 $x$ 点到 $y$ 点的最短路径上的所有点 (包括 $x$ 和 $y$) 对应的题目都做一遍，那么一共可\n以做到多少道本质不同的题目？\n\n- $2$ $A$ $B$：如果在 $A$ 点到根的最短路径上 (包括 $A$ 点和根) 等概率随机选择一个点 $x$，在 $B$ 点到根的最短路径上 (包括 $B$ 点和根) 等概率随机选择一个点 $y$，那么询问 $1$ $x$ $y$ 的答案期望是多少？\n\n定义 $cnt_x$ 表示 $x$ 点到根最短路径上的节点个数，因为小 $Q$ 不喜欢分数，而且第 $2$ 类询问的答案一\n定可以表示成 $\\frac{ans}{{cnt_A}\\times{cnt_B}}$ 的形式，你只需要告诉他 $ans$ 的值就可以了。\n\n识别这些题目消耗了小 $Q$ 太大的精力，他没有办法自己去计算这些简单的询问的答案。请写一个程序回答小 $Q$ 的所有 $m$ 个问题。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n每组数据第一行包含 $5$ 个正整数 $n, p, SA, SB, SC$，其中 $n$ 表示树的节点个数。\n\n为了在某种程度上减少输入量，树边和每个点的题目种类 $a[]$ 将由以下代码生成：\n```\nunsigned int SA, SB, SC;\nunsigned int rng61(){\n\tSA ^= SA << 16;\n\tSA ^= SA >> 5;\n\tSA ^= SA << 1;\n\tunsigned int t = SA;\n\tSA = SB;\n\tSB = SC;\n\tSC ^= t ^ SA;\n\treturn SC;\n}\nvoid gen(){\n\tscanf(\"%d%d%u%u%u\", &n, &p, &SA, &SB, &SC);\n\tfor(int i = 2; i <= p; i++)\n\taddedge(i - 1, i);\n\tfor(int i = p + 1; i <= n; i++)\n\taddedge(rng61() % (i - 1) + 1, i);\n\tfor(int i = 1; i <= n; i++)\n\ta[i] = rng61() % n + 1;\n}\n```\n第二行包含一个正整数 $m$，表示询问次数。\n\n接下来 $m$ 行，每行 $3$ 个正整数，形式为 $1$ $x$ $y$ 或者 $2$ $A$ $B$，依次表示每个询问。", "outputFormat": "对于每组数据，输出 $m$ 行，每行一个整数，依次回答每个询问。", "hint": "- $1 \\le T \\le 3,2 \\le p \\le n \\le 10^5,1 \\le m \\le 2\\times 10^5$\n - $ 10^4 \\le SA, SB, SC \\le 10^6,1 \\le x, y, A, B \\le n$\n\n子任务 $1$（$30$ 分）：只含第 $1$ 类询问。\n\n子任务 $2$（$30$ 分）：满足 $p = n$。\n\n子任务 $3$（$40$ 分）：没有任何附加的限制。", "locale": "zh-CN"}}}
