{"pid": "P2908", "type": "P", "difficulty": 2, "samples": [["5 3 \nBessie \nJonathan \nMontgomery \nAlicia \nAngola \nse \nnGo \nOnt \n", "1 \n1 \n2 \n0 \n1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "2008", "USACO"], "title": "[USACO08OPEN] Word Power S", "background": null, "description": "约翰想要计算他那 $N(l \\le N \\le 1000)$ 只奶牛的名字的能量。每只奶牛的名字由不超过 $1000$ 个字符构成，没有一个名字是空字符串。\n\n约翰有一张“能量字符串表”，上面有 $M(1 \\le M \\le 100)$ 个代表能量的字符串。每个字符串由不超过 $30$ 个字符构成，同样不存在空字符串。一个奶牛的名字蕴含多少个能量字符串，这个名字就有多少能量。所谓“蕴含”，是指某个能量字符串的所有字符都在名字串中按顺序出现（不一定一个紧接着一个）。\n\n所有的大写字母和小写字母都是等价的。比如，在贝茜的名字 `Bessie` 里，蕴含有 `Be`、`si`、`EE`、`Es` 等等字符串，但不蕴含 `Ls` 或 `eB`。请帮约翰计算他的奶牛的名字的能量。", "inputFormat": "第一行两个正整数 $N,M$。\n\n下面 $N$ 行，每行一个字符串，代表一只奶牛的名字。\n\n下面 $M$ 行，每行一个字符串，代表一个能量字符串。", "outputFormat": "对每个名字输出一行一个整数表示其能量值。", "hint": "样例解释：\n\n|奶牛名字|`se`|`nGo`|`Ont`|\n|:-:|:-:|:-:|:-:|\n|`Bessie`|蕴含|不蕴含|不蕴含|\n|`Jonathan`|不蕴含|不蕴含|蕴含|\n|`Montgomery`|不蕴含|蕴含|蕴含|\n|`Alicia`|不蕴含|不蕴含|不蕴含|\n|`Angola`|不蕴含|蕴含|不蕴含|", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08OPEN] Word Power S", "background": null, "description": "Farmer John wants to evaluate the quality of the names of his $N (1 \\le N \\le 1000)$ cows. Each name is a string with no more than 1000 characters, all of which are non-blank.\n\nHe has created a set of $M (1 \\le M \\le 100)$ 'good' strings (no longer than 30 characters and fully non-blank). If the sequence letters of a cow's name contains the letters of a 'good' string in the correct order as a subsequence (i.e., not necessarily all next to each other), the cow's name gets 1 quality point.\n\nAll strings is case-insensitive, i.e., capital letters and lower case letters are considered equivalent. For example, the name $\\texttt{Bessie}$ contains the letters of $\\texttt{Be}$, $\\texttt{sI}$, $\\texttt{EE}$, and $\\text{Es}$ in the correct order, but not $\\texttt{is}$ or $\\texttt{eB}$. Help Farmer John determine the number of quality points in each of his cow's names.", "inputFormat": "* Line $1$: Two space-separated integers: $N$ and $M$.\n\n* Lines $2 \\sim N+1$: Line $i+1$ contains a string that is the name of the ith cow.\n\n* Lines $N+2 \\sim N+M+1$: Line $N+i+1$ contains the ith good string.", "outputFormat": "* Lines $1 \\sim N+1$: Line $i+1$ contains the number of quality points of the ith name.", "hint": "There are 5 cows, and their names are $\\texttt{Bessie}$, $\\texttt{Jonathan}$, $\\texttt{Montgomery}$, $\\texttt{Alicia}$, and $\\texttt{Angola}$. The 3 good strings are $\\texttt{se}$, $\\texttt{nGo}$, and $\\texttt{Ont}$.\n\n$\\texttt{Bessie}$ contains $\\texttt{se}$, $\\texttt{Jonathan}$ contains $\\texttt{Ont}$, $\\texttt{Montgomery}$ contains both $\\texttt{nGo}$ and $\\texttt{Ont}$, $\\texttt{Alicia}$ contains none of the good strings, and $\\texttt{Angola}$ contains $\\texttt{nGo}$.", "locale": "en"}, "zh-CN": {"title": "[USACO08OPEN] Word Power S", "background": null, "description": "约翰想要计算他那 $N(l \\le N \\le 1000)$ 只奶牛的名字的能量。每只奶牛的名字由不超过 $1000$ 个字符构成，没有一个名字是空字符串。\n\n约翰有一张“能量字符串表”，上面有 $M(1 \\le M \\le 100)$ 个代表能量的字符串。每个字符串由不超过 $30$ 个字符构成，同样不存在空字符串。一个奶牛的名字蕴含多少个能量字符串，这个名字就有多少能量。所谓“蕴含”，是指某个能量字符串的所有字符都在名字串中按顺序出现（不一定一个紧接着一个）。\n\n所有的大写字母和小写字母都是等价的。比如，在贝茜的名字 `Bessie` 里，蕴含有 `Be`、`si`、`EE`、`Es` 等等字符串，但不蕴含 `Ls` 或 `eB`。请帮约翰计算他的奶牛的名字的能量。", "inputFormat": "第一行两个正整数 $N,M$。\n\n下面 $N$ 行，每行一个字符串，代表一只奶牛的名字。\n\n下面 $M$ 行，每行一个字符串，代表一个能量字符串。", "outputFormat": "对每个名字输出一行一个整数表示其能量值。", "hint": "样例解释：\n\n|奶牛名字|`se`|`nGo`|`Ont`|\n|:-:|:-:|:-:|:-:|\n|`Bessie`|蕴含|不蕴含|不蕴含|\n|`Jonathan`|不蕴含|不蕴含|蕴含|\n|`Montgomery`|不蕴含|蕴含|蕴含|\n|`Alicia`|不蕴含|不蕴含|不蕴含|\n|`Angola`|不蕴含|蕴含|不蕴含|", "locale": "zh-CN"}}}
{"pid": "P2909", "type": "P", "difficulty": 2, "samples": [["3 1 1 5 \n5 \n7 \n5 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2008", "USACO", "排序"], "title": "[USACO08OPEN] Cow Cars S", "background": "", "description": "N (1 <= N <= 50,000) cows conveniently numbered 1..N are driving in separate cars along a highway in Cowtopia. Cow i can drive in any of M different high lanes (1 <= M <= N) and can travel at a maximum speed of S\\_i (1 <= S\\_i <= 1,000,000) km/hour.\n\nAfter their other bad driving experience, the cows hate collisions and take extraordinary measures to avoid them. On this highway, cow i reduces its speed by D (0 <= D <= 5,000) km/hour for each cow in front of it on the highway (though never below 0 km/hour). Thus, if there are K cows in front of cow i, the cow will travel at a speed of max[S\\_i - D \\* K, 0]. While a cow might actually travel faster than a cow directly in front of it, the cows are spaced far enough apart so crashes will not occur once cows slow down as\n\ndescribed,\n\nCowtopia has a minimum speed law which requires everyone on the highway to travel at a a minimum speed of L (1 <= L <= 1,000,000) km/hour so sometimes some of the cows will be unable to take the highway if they follow the rules above. Write a program that will find the maximum number of cows that can drive on the highway while obeying the minimum speed limit law.\n", "inputFormat": "\\* Line 1: Four space-separated integers: N, M, D, and L\n\n\\* Lines 2..N+1: Line i+1 describes cow i's initial speed with a single integer: S\\_i\n", "outputFormat": "\\* Line 1: A single integer representing the maximum number of cows that can use the highway\n", "hint": "There are three cows with one lane to drive on, a speed decrease of 1, and a minimum speed limit of 5.\n\n\nTwo cows are possible, by putting either cow with speed 5 first and the cow with speed 7 second.\n", "locale": "en", "translations": {"en": {"title": "[USACO08OPEN] Cow Cars S", "background": "", "description": "N (1 <= N <= 50,000) cows conveniently numbered 1..N are driving in separate cars along a highway in Cowtopia. Cow i can drive in any of M different high lanes (1 <= M <= N) and can travel at a maximum speed of S\\_i (1 <= S\\_i <= 1,000,000) km/hour.\n\nAfter their other bad driving experience, the cows hate collisions and take extraordinary measures to avoid them. On this highway, cow i reduces its speed by D (0 <= D <= 5,000) km/hour for each cow in front of it on the highway (though never below 0 km/hour). Thus, if there are K cows in front of cow i, the cow will travel at a speed of max[S\\_i - D \\* K, 0]. While a cow might actually travel faster than a cow directly in front of it, the cows are spaced far enough apart so crashes will not occur once cows slow down as\n\ndescribed,\n\nCowtopia has a minimum speed law which requires everyone on the highway to travel at a a minimum speed of L (1 <= L <= 1,000,000) km/hour so sometimes some of the cows will be unable to take the highway if they follow the rules above. Write a program that will find the maximum number of cows that can drive on the highway while obeying the minimum speed limit law.\n", "inputFormat": "\\* Line 1: Four space-separated integers: N, M, D, and L\n\n\\* Lines 2..N+1: Line i+1 describes cow i's initial speed with a single integer: S\\_i\n", "outputFormat": "\\* Line 1: A single integer representing the maximum number of cows that can use the highway\n", "hint": "There are three cows with one lane to drive on, a speed decrease of 1, and a minimum speed limit of 5.\n\n\nTwo cows are possible, by putting either cow with speed 5 first and the cow with speed 7 second.\n", "locale": "en"}, "zh-CN": {"title": "[USACO08OPEN] Cow Cars S", "background": "", "description": "在 Cowtopia 的高速公路上，有 $N$ 头奶牛（$1 \\leq N \\leq 50,000$），它们被方便地编号为 $1..N$，分别驾驶着不同的汽车。奶牛 $i$ 可以在 $M$ 条不同的高速车道上行驶（$1 \\leq M \\leq N$），并且可以以最大速度 $S_i$（$1 \\leq S_i \\leq 1,000,000$）公里/小时行驶。\n\n在经历了其他糟糕的驾驶体验后，奶牛们讨厌碰撞，并采取了极端措施来避免它们。在这条高速公路上，奶牛 $i$ 会因为在它前面的每一头奶牛而将速度减少 $D$（$0 \\leq D \\leq 5,000$）公里/小时（但速度不会低于 0 公里/小时）。因此，如果在奶牛 $i$ 前面有 $K$ 头奶牛，那么它将以 $\\max[S_i - D \\times K, 0]$ 的速度行驶。虽然奶牛实际上可能比直接在它前面的奶牛行驶得更快，但奶牛之间的间距足够大，因此一旦奶牛减速，就不会发生碰撞。\n\nCowtopia 有一条最低速度法则，要求高速公路上的所有车辆都必须以最低速度 $L$（$1 \\leq L \\leq 1,000,000$）公里/小时行驶，因此有时一些奶牛在遵循上述规则时将无法上高速公路。编写一个程序，找出在遵守最低速度限制法的情况下，能够在高速公路上行驶的最大奶牛数量。\n", "inputFormat": "\\* 第 1 行：四个以空格分隔的整数：$N$，$M$，$D$ 和 $L$\n\n\\* 第 2 行到第 $N+1$ 行：第 $i+1$ 行用一个整数描述奶牛 $i$ 的初始速度：$S_i$\n", "outputFormat": "\\* 第 1 行：一个整数，表示可以使用高速公路的最大奶牛数量\n", "hint": "有三头奶牛，只有一条车道可供行驶，速度减少为 1，最低速度限制为 5。\n\n\n可以让两头奶牛上高速公路，方法是先让速度为 5 的奶牛上路，然后让速度为 7 的奶牛上路。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2910", "type": "P", "difficulty": 3, "samples": [["3 4 \n1 \n2 \n1 \n3 \n0 5 1 \n5 0 2 \n1 2 0 \n", "7 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO", "最短路"], "title": "[USACO08OPEN] Clear And Present Danger S", "background": null, "description": "Farmer John is on a boat seeking fabled treasure on one of the $N (1 \\le N \\le 100)$ islands conveniently labeled $1 \\sim N$ in the Cowribbean Sea.\n\nThe treasure map tells him that he must travel through a certain sequence $A_1, A_2, \\dots, A_M$ of $M (2 \\le M \\le 10^4)$ islands, starting on island $1$ and ending on island $N$ before the treasure will appear to him. He can visit these and other islands out of order and even more than once, but his trip must include the $A_i$ sequence in the order specified by the map.\n\nFJ wants to avoid pirates and knows the pirate-danger rating $(0 \\le danger \\le 10^5)$ between each pair of islands. The total danger rating of his mission is the sum of the danger ratings of all the paths he traverses.\n\nHelp Farmer John find the least dangerous route to the treasure that satisfies the treasure map's requirement.", "inputFormat": "Line $1$: Two space-separated integers: $N$ and $M$.\n\nLines $2 \\sim M+1$: Line $i+1$ describes the $i$-th island FJ must visit with a single integer: $A_i$.\n\nLines $M+2\\sim N+M+1$: Line $i+M+1$ contains $N$ space-separated integers that are the respective danger rating of the path between island i and islands $1, 2, \\dots$, and $N$, respectively. The ith integer is always zero.", "outputFormat": "Line $1$: The minimum danger that Farmer John can encounter while obtaining the treasure.", "hint": "There are $3$ islands and the treasure map requires Farmer John to visit a sequence of $4$ islands in order: island $1$, island $2$, island $1$ again, and finally island $3$. The danger ratings of the paths are given: the paths $(1, 2); (2, 3); (3, 1)$ and the reverse paths have danger ratings of $5, 2$, and $1$, respectively.\n\n\nHe can get the treasure with a total danger of $7$ by traveling in the sequence of islands $1, 3, 2, 3, 1$, and $3$. The cow map's requirement ($1, 2, 1$, and $3$) is satisfied by this route. We avoid the path between islands $1$ and $2$ because it has a large danger rating.", "locale": "en", "translations": {"en": {"title": "[USACO08OPEN] Clear And Present Danger S", "background": null, "description": "Farmer John is on a boat seeking fabled treasure on one of the $N (1 \\le N \\le 100)$ islands conveniently labeled $1 \\sim N$ in the Cowribbean Sea.\n\nThe treasure map tells him that he must travel through a certain sequence $A_1, A_2, \\dots, A_M$ of $M (2 \\le M \\le 10^4)$ islands, starting on island $1$ and ending on island $N$ before the treasure will appear to him. He can visit these and other islands out of order and even more than once, but his trip must include the $A_i$ sequence in the order specified by the map.\n\nFJ wants to avoid pirates and knows the pirate-danger rating $(0 \\le danger \\le 10^5)$ between each pair of islands. The total danger rating of his mission is the sum of the danger ratings of all the paths he traverses.\n\nHelp Farmer John find the least dangerous route to the treasure that satisfies the treasure map's requirement.", "inputFormat": "Line $1$: Two space-separated integers: $N$ and $M$.\n\nLines $2 \\sim M+1$: Line $i+1$ describes the $i$-th island FJ must visit with a single integer: $A_i$.\n\nLines $M+2\\sim N+M+1$: Line $i+M+1$ contains $N$ space-separated integers that are the respective danger rating of the path between island i and islands $1, 2, \\dots$, and $N$, respectively. The ith integer is always zero.", "outputFormat": "Line $1$: The minimum danger that Farmer John can encounter while obtaining the treasure.", "hint": "There are $3$ islands and the treasure map requires Farmer John to visit a sequence of $4$ islands in order: island $1$, island $2$, island $1$ again, and finally island $3$. The danger ratings of the paths are given: the paths $(1, 2); (2, 3); (3, 1)$ and the reverse paths have danger ratings of $5, 2$, and $1$, respectively.\n\n\nHe can get the treasure with a total danger of $7$ by traveling in the sequence of islands $1, 3, 2, 3, 1$, and $3$. The cow map's requirement ($1, 2, 1$, and $3$) is satisfied by this route. We avoid the path between islands $1$ and $2$ because it has a large danger rating.", "locale": "en"}, "zh-CN": {"title": "[USACO08OPEN] Clear And Present Danger S", "background": null, "description": "农夫约翰正驾驶一条小艇在牛勒比海上航行。\n\n海上有 $N(1\\leq N\\leq 100)$ 个岛屿，用 $1$ 到 $N$ 编号。约翰从 $1$ 号小岛出发，最后到达 $N$ 号小岛。\n\n一张藏宝图上说，如果他的路程上经过的小岛依次出现了  $A_1,A_2,\\dots ,A_M(2\\leq M\\leq 10000)$ 这样的序列（不一定相邻），那他最终就能找到古老的宝藏。但是，由于牛勒比海有海盗出没，约翰知道任意两个岛屿之间的航线上海盗出没的概率，他用一个危险指数 $D_{i,j}(0\\leq D_{i,j}\\leq 100000)$ 来描述。他希望他的寻宝活动经过的航线危险指数之和最小。那么，在找到宝藏的前提下，这个最小的危险指数是多少呢？", "inputFormat": "第一行：两个用空格隔开的正整数 $N$ 和 $M$。\n\n第二到第 $M+1$ 行：第 $i+1$ 行用一个整数 $A_i$ 表示 FJ 必须经过的第 $i$ 个岛屿。保证 $A_1=1,A_M=N$。\n\n第 $M+2$ 到第 $N+M+1$ 行：第 $i+M+1$ 行包含 $N$ 个用空格隔开的非负整数分别表示 $i$ 号小岛到第 $1\\dots N$ 号小岛的航线各自的危险指数。保证第 $i$ 个数是 $0$。", "outputFormat": "第一行：FJ 在找到宝藏的前提下经过的航线的危险指数之和的最小值。", "hint": "### 样例说明 #1\n这组数据中有三个岛屿，藏宝图要求 FJ 按顺序经过四个岛屿：$1$ 号岛屿、$2$ 号岛屿、回到 $1$ 号岛屿、最后到 $3$ 号岛屿。每条航线的危险指数也给出了：航路$(1,2),(2,3),(3,1)$ 和它们的反向路径的危险指数分别是 $5,2,1$。\n\nFJ 可以通过依次经过 $1,3,2,3,1,3$ 号岛屿以 $7$ 的最小总危险指数获得宝藏。这条道路满足了奶牛地图的要求 $(1,2,1,3)$。我们避开了 $1$ 号和 $2$ 号岛屿之间的航线，因为它的危险指数太大了。\n\n注意：测试数据中 $a$ 到 $b$ 的危险指数不一定等于 $b$ 到 $a$ 的危险指数！\n\nTranslated by @LJC00125", "locale": "zh-CN"}}}
{"pid": "P2911", "type": "P", "difficulty": 1, "samples": [["3 2 3 \n", "5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO", "枚举", "期望"], "title": "[USACO08OCT] Bovine Bones G", "background": null, "description": "Bessie loves board games and role-playing games so she persuaded Farmer John to drive her to the hobby shop where she purchased three dice for rolling. These fair dice have $S_1$, $S_2$, and $S_3$ sides respectively ($2 \\le S_1 \\le 20; 2 \\le S_2 \\le 20; 2 \\le S_3 \\le 40$). \n\nBessie rolls and rolls and rolls trying to figure out which three-dice sum appears most often.\n\nGiven the number of sides on each of the three dice, determine which three-dice sum appears most frequently. If more than one sum can appear most frequently, report the smallest such sum.\n\nPOINTS: $70$", "inputFormat": "\\* Line 1: Three space-separated integers: $S_1$, $S_2$, and $S_3$.", "outputFormat": "\\* Line 1: The smallest integer sum that appears most frequently when the dice are rolled in every possible combination.", "hint": "Here are all the possible outcomes.\n\n```\n1 1 1 -> 3  \n1 2 1 -> 4  \n2 1 1 -> 4  \n2 2 1 -> 5  \n3 1 1 -> 5  \n3 2 1 -> 6 \n1 1 2 -> 4  \n1 2 2 -> 5  \n2 1 2 -> 5  \n2 2 2 -> 6  \n3 1 2 -> 6  \n3 2 2 -> 7 \n1 1 3 -> 5  \n1 2 3 -> 6  \n2 1 3 -> 6  \n2 2 3 -> 7  \n3 1 3 -> 7  \n3 2 3 -> 8\n```\nBoth 5 and 6 appear most frequently (five times each), so 5 is the answer.", "locale": "en", "translations": {"en": {"title": "[USACO08OCT] Bovine Bones G", "background": null, "description": "Bessie loves board games and role-playing games so she persuaded Farmer John to drive her to the hobby shop where she purchased three dice for rolling. These fair dice have $S_1$, $S_2$, and $S_3$ sides respectively ($2 \\le S_1 \\le 20; 2 \\le S_2 \\le 20; 2 \\le S_3 \\le 40$). \n\nBessie rolls and rolls and rolls trying to figure out which three-dice sum appears most often.\n\nGiven the number of sides on each of the three dice, determine which three-dice sum appears most frequently. If more than one sum can appear most frequently, report the smallest such sum.\n\nPOINTS: $70$", "inputFormat": "\\* Line 1: Three space-separated integers: $S_1$, $S_2$, and $S_3$.", "outputFormat": "\\* Line 1: The smallest integer sum that appears most frequently when the dice are rolled in every possible combination.", "hint": "Here are all the possible outcomes.\n\n```\n1 1 1 -> 3  \n1 2 1 -> 4  \n2 1 1 -> 4  \n2 2 1 -> 5  \n3 1 1 -> 5  \n3 2 1 -> 6 \n1 1 2 -> 4  \n1 2 2 -> 5  \n2 1 2 -> 5  \n2 2 2 -> 6  \n3 1 2 -> 6  \n3 2 2 -> 7 \n1 1 3 -> 5  \n1 2 3 -> 6  \n2 1 3 -> 6  \n2 2 3 -> 7  \n3 1 3 -> 7  \n3 2 3 -> 8\n```\nBoth 5 and 6 appear most frequently (five times each), so 5 is the answer.", "locale": "en"}, "zh-CN": {"title": "[USACO08OCT] Bovine Bones G", "background": null, "description": "Bessie 喜欢桌游和角色扮演游戏，所以她说服了 Farmer John 驾车送她去爱好商店，在那里她购买了三个用于掷骰子的骰子。这些公平的骰子分别有 $S_1$、$S_2$ 和 $S_3$ 个面（$2 \\leq S_1 \\leq 20$；$2 \\leq S_2 \\leq 20$；$2 \\leq S_3 \\leq 40$），上面分别包含 $1$ 到 $S_1$，$S_2$ 和 $S_3$ 之间的所有整数。Bessie 不断地掷骰子，试图找出哪个三个骰子的点数和出现得最频繁。如果有多个和出现得最频繁，输出其中最小的和。", "inputFormat": "第 1 行：三个用空格分隔的整数：$S_1$、$S_2$ 和 $S_3$。", "outputFormat": "第 1 行：当骰子以每种可能的组合掷出时，出现次数最多的最小整数和。", "hint": "这里是所有可能的结果。\n\n```\n1 1 1 -> 3  \n1 2 1 -> 4  \n2 1 1 -> 4  \n2 2 1 -> 5  \n3 1 1 -> 5  \n3 2 1 -> 6 \n1 1 2 -> 4  \n1 2 2 -> 5  \n2 1 2 -> 5  \n2 2 2 -> 6  \n3 1 2 -> 6  \n3 2 2 -> 7 \n1 1 3 -> 5  \n1 2 3 -> 6  \n2 1 3 -> 6  \n2 2 3 -> 7  \n3 1 3 -> 7  \n3 2 3 -> 8\n```\n\n5 和 6 都出现得最频繁（各五次），所以答案是 5。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P2912", "type": "P", "difficulty": 3, "samples": [["4 2 \n2 1 2 \n4 3 2 \n1 4 3 \n1 2 \n3 2 \n", "2 \n7 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO"], "title": "[USACO08OCT] Pasture Walking G", "background": null, "description": "The $N$ cows ($2 \\le N \\le 1,000$) conveniently numbered $1$…$N$ are grazing among the $N$ pastures also conveniently numbered $1$…$N$. Most conveniently of all, cow $i$ is grazing in pasture $i$.\n\nSome pairs of pastures are connected by one of $N-1$ bidirectional walkways that the cows can traverse. Walkway $i$ connects pastures $A_i$ and $B_i$ ($1 \\le A_i \\le N; 1 \\le B_i \\le N$) and has a length of $L_i$ ($1 \\le L_i \\le 10,000$).\n\nThe walkways are set up in such a way that between any two distinct pastures, there is exactly one path of walkways that travels between them. Thus, the walkways form a tree.\n\nThe cows are very social and wish to visit each other often. Ever in a hurry, they want you to help them schedule their visits by computing the lengths of the paths between $1 \\le L_i \\le 10,000$ pairs of pastures (each pair given as a query $p1$,$p2$ ($1 \\le p1 \\le N; 1 \\le p2 \\le N$).\n\nPOINTS: 200\n\n有$N$（$2 \\le N \\le 1,000$）头奶牛，编号为 $1$ 到 $N$，它们正在同样编号为 $1$ 到 $N$ 的牧场上行走.为了方便，我们假设编号为 $i$ 的牛恰好在第 $i$ 号牧场上。\n\n有一些牧场间每两个牧场用一条双向道路相连，道路总共有 $N - 1$ 条，奶牛可以在这些道路上行走。第i条道路把第 $A_i$ 个牧场和第 $B_i$ 个牧场连了起来（$1 \\le A_i \\le N; 1 \\le B_i \\le N$），而它的长度是 $1 \\le L_i \\le 10,000$ 在任意两个牧场间，有且仅有一条由若干道路组成的路径相连。也就是说，所有的道路构成了一棵树。\n\n奶牛们十分希望经常互相见面。它们十分着急，所以希望你帮助它们计划它们的行程，你只 需要计算出 $Q$（$1 < Q < 1000$）对点之间的路径长度。每对点以一个询问 $p1$，$p2$ ($1 \\le p1 \\le N; 1 \\le p2 \\le N$) 的形式给出。", "inputFormat": "\\* Line 1: Two space-separated integers: $N$ and $Q$\n\n\\* Lines $2$…$N$: Line $i+1$ contains three space-separated integers: $A_i$, $B_i$, and $L_i$\n\n\\* Lines $N+1$…$N+Q$: Each line contains two space-separated integers representing two distinct pastures between which the cows wish to travel: $p1$ and $p2$", "outputFormat": "\\* Lines $1$…$Q$: Line $i$ contains the length of the path between the two pastures in query $i$.", "hint": "Query 1: The walkway between pastures $1$ and $2$ has length $2$.\n\nQuery 2: Travel through the walkway between pastures $3$ and $4$, then the one between $4$ and $1$, and finally the one between $1$ and $2$, for a total length of $7$.", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08OCT] Pasture Walking G", "background": "", "description": "The $N$ cows ($2 \\le N \\le 1,000$), conveniently numbered $1$…$N$, are grazing among the $N$ pastures also conveniently numbered $1$…$N$. Most conveniently of all, cow $i$ is grazing in pasture $i$.\n\nSome pairs of pastures are connected by one of $N - 1$ bidirectional walkways that the cows can traverse. Walkway $i$ connects pastures $A_i$ and $B_i$ ($1 \\le A_i \\le N; 1 \\le B_i \\le N$) and has a length of $L_i$ ($1 \\le L_i \\le 10,000$).\n\nThe walkways are set up so that between any two distinct pastures, there is exactly one path of walkways that travels between them. Thus, the walkways form a tree.\n\nThe cows are very social and wish to visit each other often. Being in a hurry, they want you to help schedule their visits by computing the lengths of the paths for $Q$ pairs of pastures ($1 < Q < 1,000$). Each pair is given as a query $p1$, $p2$ ($1 \\le p1 \\le N; 1 \\le p2 \\le N$).", "inputFormat": "* Line 1: Two space-separated integers $N$ and $Q$.\n* Lines $2$…$N$: Line $i+1$ contains three space-separated integers $A_i$, $B_i$, and $L_i$.\n* Lines $N+1$…$N+Q$: Each line contains two space-separated integers representing two distinct pastures between which the cows wish to travel: $p1$ and $p2$.", "outputFormat": "* Lines $1$…$Q$: Line $i$ contains the length of the path between the two pastures in query $i$.", "hint": "Query 1: The walkway between pastures $1$ and $2$ has length $2$.\n\nQuery 2: Travel through the walkway between pastures $3$ and $4$, then the one between $4$ and $1$, and finally the one between $1$ and $2$, for a total length of $7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO08OCT] Pasture Walking G", "background": null, "description": "The $N$ cows ($2 \\le N \\le 1,000$) conveniently numbered $1$…$N$ are grazing among the $N$ pastures also conveniently numbered $1$…$N$. Most conveniently of all, cow $i$ is grazing in pasture $i$.\n\nSome pairs of pastures are connected by one of $N-1$ bidirectional walkways that the cows can traverse. Walkway $i$ connects pastures $A_i$ and $B_i$ ($1 \\le A_i \\le N; 1 \\le B_i \\le N$) and has a length of $L_i$ ($1 \\le L_i \\le 10,000$).\n\nThe walkways are set up in such a way that between any two distinct pastures, there is exactly one path of walkways that travels between them. Thus, the walkways form a tree.\n\nThe cows are very social and wish to visit each other often. Ever in a hurry, they want you to help them schedule their visits by computing the lengths of the paths between $1 \\le L_i \\le 10,000$ pairs of pastures (each pair given as a query $p1$,$p2$ ($1 \\le p1 \\le N; 1 \\le p2 \\le N$).\n\nPOINTS: 200\n\n有$N$（$2 \\le N \\le 1,000$）头奶牛，编号为 $1$ 到 $N$，它们正在同样编号为 $1$ 到 $N$ 的牧场上行走.为了方便，我们假设编号为 $i$ 的牛恰好在第 $i$ 号牧场上。\n\n有一些牧场间每两个牧场用一条双向道路相连，道路总共有 $N - 1$ 条，奶牛可以在这些道路上行走。第i条道路把第 $A_i$ 个牧场和第 $B_i$ 个牧场连了起来（$1 \\le A_i \\le N; 1 \\le B_i \\le N$），而它的长度是 $1 \\le L_i \\le 10,000$ 在任意两个牧场间，有且仅有一条由若干道路组成的路径相连。也就是说，所有的道路构成了一棵树。\n\n奶牛们十分希望经常互相见面。它们十分着急，所以希望你帮助它们计划它们的行程，你只 需要计算出 $Q$（$1 < Q < 1000$）对点之间的路径长度。每对点以一个询问 $p1$，$p2$ ($1 \\le p1 \\le N; 1 \\le p2 \\le N$) 的形式给出。", "inputFormat": "\\* Line 1: Two space-separated integers: $N$ and $Q$\n\n\\* Lines $2$…$N$: Line $i+1$ contains three space-separated integers: $A_i$, $B_i$, and $L_i$\n\n\\* Lines $N+1$…$N+Q$: Each line contains two space-separated integers representing two distinct pastures between which the cows wish to travel: $p1$ and $p2$", "outputFormat": "\\* Lines $1$…$Q$: Line $i$ contains the length of the path between the two pastures in query $i$.", "hint": "Query 1: The walkway between pastures $1$ and $2$ has length $2$.\n\nQuery 2: Travel through the walkway between pastures $3$ and $4$, then the one between $4$ and $1$, and finally the one between $1$ and $2$, for a total length of $7$.", "locale": "zh-CN"}}}
{"pid": "P2913", "type": "P", "difficulty": 2, "samples": [["4 \n2 3 0 \n3 4 1 \n1 2 0 \n", "1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO"], "title": "[USACO08OCT] Wheel Rotation G", "background": "", "description": "Farmer John has an old-time thresher (wheat harvester) that requires belts to be installed on various gears to turn the parts. The engine drives pulley 1 in a clockwise direction which attaches via a belt to pulley 2. Pulley 2 attaches via a belt to pulley 3 and so on through a total of N (2 <= N <= 1,000) pulleys (and N-1 belts).\n\nThe diagram above depicts the two ways a belt can be installed between two gears. In this illustration, pulley 1's belt directly drives pulley 2 (a 'straight' connection) and thus they will rotate in the same direction. Pulley 3 drives pulley 4 via a 'crossed belt' that reverses the direction of the rotation.\n\nGiven a list of the belt types that connect the pulleys along with the fact that pulley 1 is driven in a clockwise direction by the engine, determine the drive direction of pulley N. Each belt is described by three integers:\n\n```cpp\n* S_i -- the driving (source) pulley \n* D_i -- the driven (destination) pulley \n* C_i -- the connection type (0=straight, 1=crossed) \nUnfortunately, FJ lists the belts in random order. \nBy way of example, consider the illustration below. N = 4, and pulley 1 is driven clockwise by the thresher engine. Straight \nbelts drive pulley 2 and then pulley 3, so they rotate clockwise. The crosswise belt reverses the rotation direction so pulley 4 (pulley N) rotates counterclockwise. \n```\nPOINTS: 70\n约翰有一个过时的收割机，需要在它的各种滑轮上装配皮带才能让收割机的各个部分运作起 来.引擎能够驱动滑轮1向顺时针方向转动，滑轮1通过一条皮带又连接到滑轮2.滑轮2又通过一 条皮带连接到滑轮3，等等，总共有N(2 <= N <= 1000)个滑轮和N - 1条皮带.\n\n皮带连接两个滑轮有两种方式：直接连接和交叉连接.直接连接的两个滑轮旋转方向相同， 即同为顺时针或同为逆时针.交叉连接的两个滑轮旋转方向相反.\n\n现在给出一个列表，里面列出所有皮带的连接方式.已经知道滑轮1被引擎驱动着向顺时针方 向转动.每一条皮带由下面三个数定义：\n\n•驱动滑轮S，输入驱动力的滑轮.\n\n•被驱动滑轮D;，被驱使转动的滑轮.\n\n•连接类型C，0表示直接连接，1表示交叉连接.\n\n不幸的是，约翰的这个列表中，皮带的顺序是混乱的.所以请你写一个程序来求出滑轮N的 转动方向.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N: Each line describes a belt with three integers: S\\_i, D\\_i, and C\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the rotation direction for pulley N (0=clockwise, 1=counterclockwise)\n", "hint": "As in the example illustration.\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08OCT] Wheel Rotation G", "background": "", "description": "Farmer John has an old-time thresher that uses belts on pulleys to transmit motion. The engine drives pulley 1 in a clockwise direction. Pulley 1 is connected to pulley 2 by a belt, pulley 2 to pulley 3, and so on, for a total of $N$ pulleys ($2 \\le N \\le 1000$) and $N - 1$ belts.\n\nThere are two ways to install a belt between two pulleys:\n- Straight connection: the two pulleys rotate in the same direction.\n- Crossed connection: the two pulleys rotate in opposite directions.\n\nYou are given a list of all belts. Each belt is specified by three integers:\n- $S_i$: the driving (source) pulley.\n- $D_i$: the driven (destination) pulley.\n- $C_i$: the connection type ($0$ = straight, $1$ = crossed).\n\nThe belts are listed in random order. Knowing that pulley 1 rotates clockwise, determine the rotation direction of pulley $N$.\n\n```cpp\n* S_i -- the driving (source) pulley \n* D_i -- the driven (destination) pulley \n* C_i -- the connection type (0=straight, 1=crossed) \nUnfortunately, FJ lists the belts in random order. \nBy way of example, consider the illustration below. N = 4, and pulley 1 is driven clockwise by the thresher engine. Straight \nbelts drive pulley 2 and then pulley 3, so they rotate clockwise. The crosswise belt reverses the rotation direction so pulley 4 (pulley N) rotates counterclockwise. \n```", "inputFormat": "- Line 1: A single integer $N$.\n- Lines 2 to $N$: Each line describes a belt with three integers $S_i$, $D_i$, and $C_i$.", "outputFormat": "- Line 1: A single integer indicating the rotation direction of pulley $N$ ($0$ = clockwise, $1$ = counterclockwise).", "hint": "As in the example illustration.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO08OCT] Wheel Rotation G", "background": "", "description": "Farmer John has an old-time thresher (wheat harvester) that requires belts to be installed on various gears to turn the parts. The engine drives pulley 1 in a clockwise direction which attaches via a belt to pulley 2. Pulley 2 attaches via a belt to pulley 3 and so on through a total of N (2 <= N <= 1,000) pulleys (and N-1 belts).\n\nThe diagram above depicts the two ways a belt can be installed between two gears. In this illustration, pulley 1's belt directly drives pulley 2 (a 'straight' connection) and thus they will rotate in the same direction. Pulley 3 drives pulley 4 via a 'crossed belt' that reverses the direction of the rotation.\n\nGiven a list of the belt types that connect the pulleys along with the fact that pulley 1 is driven in a clockwise direction by the engine, determine the drive direction of pulley N. Each belt is described by three integers:\n\n```cpp\n* S_i -- the driving (source) pulley \n* D_i -- the driven (destination) pulley \n* C_i -- the connection type (0=straight, 1=crossed) \nUnfortunately, FJ lists the belts in random order. \nBy way of example, consider the illustration below. N = 4, and pulley 1 is driven clockwise by the thresher engine. Straight \nbelts drive pulley 2 and then pulley 3, so they rotate clockwise. The crosswise belt reverses the rotation direction so pulley 4 (pulley N) rotates counterclockwise. \n```\nPOINTS: 70\n约翰有一个过时的收割机，需要在它的各种滑轮上装配皮带才能让收割机的各个部分运作起 来.引擎能够驱动滑轮1向顺时针方向转动，滑轮1通过一条皮带又连接到滑轮2.滑轮2又通过一 条皮带连接到滑轮3，等等，总共有N(2 <= N <= 1000)个滑轮和N - 1条皮带.\n\n皮带连接两个滑轮有两种方式：直接连接和交叉连接.直接连接的两个滑轮旋转方向相同， 即同为顺时针或同为逆时针.交叉连接的两个滑轮旋转方向相反.\n\n现在给出一个列表，里面列出所有皮带的连接方式.已经知道滑轮1被引擎驱动着向顺时针方 向转动.每一条皮带由下面三个数定义：\n\n•驱动滑轮S，输入驱动力的滑轮.\n\n•被驱动滑轮D;，被驱使转动的滑轮.\n\n•连接类型C，0表示直接连接，1表示交叉连接.\n\n不幸的是，约翰的这个列表中，皮带的顺序是混乱的.所以请你写一个程序来求出滑轮N的 转动方向.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N: Each line describes a belt with three integers: S\\_i, D\\_i, and C\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the rotation direction for pulley N (0=clockwise, 1=counterclockwise)\n", "hint": "As in the example illustration.\n", "locale": "zh-CN"}}}
{"pid": "P2914", "type": "P", "difficulty": 4, "samples": [["9 3 \n2.0 \n0 0 \n0 1 \n1 1 \n2 1 \n2 2 \n3 2 \n3 3 \n4 1 \n4 3 \n1 2 \n2 3 \n3 4 \n", "2828 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO"], "title": "[USACO08OCT] Power Failure G", "background": "", "description": "A vicious thunderstorm has destroyed some of the wires of the farm's electrical power grid! Farmer John has a map of all $N$ ($2\\le N \\le 1000$) of the powerpoles, which are conveniently numbered $1\\ldots N$ and located on integer plane coordinates $(x_i,y_i)$ ($-100000 \\le x_i \\le 100000, -100000 \\le y_i \\le 100000$).\n\nSome $W$ ($1 \\le W \\le 10000$) power wires connect pairs of power poles $P_i$ and $P_j$ ($1 \\le Pi \\le N, 1 \\le Pj \\le N$).\n\nHe needs to get power from pole $1$ to pole $N$ (which means that some series of wires can traverse from pole $1$ to pole $N$, probably through some intermediate set of poles).\n\nGiven the locations of the $N$ poles and the list of remaining power wires, determine the minimum length of power wire required to restore the electrical connection so that electricity can flow from pole $1$ to pole $N$.  No wire can be longer than some real number $M$ ($0.0 < M \\le 200000.0$).\n\nAs an example, below on the left is a map of the $9$ poles and $3$ wires after the storm. For this task, $M = 2.0$. The best set of wires to add would connect poles $4$ and $6$ and also poles $6$ and $9$.\n\n```cpp\n   After the storm              Optimally reconnected\n3  . . . 7 9 . . . . .          3  . . . 7 9 . . . . .\n                                          /\n2  . . 5 6 . . . . . .          2  . . 5 6 . . . . . .\n                                        /\n1  2-3-4 . 8 . . . . .          1  2-3-4 . 8 . . . . .\n   |                               |\n0  1 . . . . . . . . .          0  1 . . . . . . . . .\n\n   0 1 2 3 4 5 6 7 8 9             0 1 2 3 4 5 6 7 8 9\n```\n\nThe total length is then $1.414213562 + 1.414213562 = 2.828427124$.\n\nPOINTS: 350\n", "inputFormat": "Line $1$: Two space-separated integers: $N$ and $W$.\n\nLine $2$: A single real number: $M$.\n\nLines $3\\ldots N+2$: Each line contains two space-separated integers: $x_i$ and $y_i$.\n\nLines $N+3\\ldots N+2+W$: Two space-separated integers: $P_i$ and $P_j$.\n", "outputFormat": "Line 1: A single integer on a single line. If restoring connection is impossible, output `-1`. Otherwise, output a single integer that is $1000$ times the total minimum cost to restoreelectricity. Do not perform any rounding; truncate the resulting product.\n", "hint": "Just as in the diagram above.\n\n\nAs above.\n", "locale": "en", "translations": {"en": {"title": "[USACO08OCT] Power Failure G", "background": "", "description": "A vicious thunderstorm has destroyed some of the wires of the farm's electrical power grid! Farmer John has a map of all $N$ ($2\\le N \\le 1000$) of the powerpoles, which are conveniently numbered $1\\ldots N$ and located on integer plane coordinates $(x_i,y_i)$ ($-100000 \\le x_i \\le 100000, -100000 \\le y_i \\le 100000$).\n\nSome $W$ ($1 \\le W \\le 10000$) power wires connect pairs of power poles $P_i$ and $P_j$ ($1 \\le Pi \\le N, 1 \\le Pj \\le N$).\n\nHe needs to get power from pole $1$ to pole $N$ (which means that some series of wires can traverse from pole $1$ to pole $N$, probably through some intermediate set of poles).\n\nGiven the locations of the $N$ poles and the list of remaining power wires, determine the minimum length of power wire required to restore the electrical connection so that electricity can flow from pole $1$ to pole $N$.  No wire can be longer than some real number $M$ ($0.0 < M \\le 200000.0$).\n\nAs an example, below on the left is a map of the $9$ poles and $3$ wires after the storm. For this task, $M = 2.0$. The best set of wires to add would connect poles $4$ and $6$ and also poles $6$ and $9$.\n\n```cpp\n   After the storm              Optimally reconnected\n3  . . . 7 9 . . . . .          3  . . . 7 9 . . . . .\n                                          /\n2  . . 5 6 . . . . . .          2  . . 5 6 . . . . . .\n                                        /\n1  2-3-4 . 8 . . . . .          1  2-3-4 . 8 . . . . .\n   |                               |\n0  1 . . . . . . . . .          0  1 . . . . . . . . .\n\n   0 1 2 3 4 5 6 7 8 9             0 1 2 3 4 5 6 7 8 9\n```\n\nThe total length is then $1.414213562 + 1.414213562 = 2.828427124$.\n\nPOINTS: 350\n", "inputFormat": "Line $1$: Two space-separated integers: $N$ and $W$.\n\nLine $2$: A single real number: $M$.\n\nLines $3\\ldots N+2$: Each line contains two space-separated integers: $x_i$ and $y_i$.\n\nLines $N+3\\ldots N+2+W$: Two space-separated integers: $P_i$ and $P_j$.\n", "outputFormat": "Line 1: A single integer on a single line. If restoring connection is impossible, output `-1`. Otherwise, output a single integer that is $1000$ times the total minimum cost to restoreelectricity. Do not perform any rounding; truncate the resulting product.\n", "hint": "Just as in the diagram above.\n\n\nAs above.\n", "locale": "en"}, "zh-CN": {"title": "[USACO08OCT] Power Failure G", "background": "", "description": "一场猛烈的雷暴摧毁了农场电力网的一些电线！农夫约翰有一张所有 $N$ 根电线杆的地图（$2 \\le N \\le 1000$），这些电线杆被方便地编号为 $1\\ldots N$，并位于整数平面坐标 $(x_i, y_i)$ 上（$-100000 \\le x_i \\le 100000, -100000 \\le y_i \\le 100000$）。\n\n有 $W$ 根电线（$1 \\le W \\le 10000$）连接成对的电线杆 $P_i$ 和 $P_j$（$1 \\le P_i \\le N, 1 \\le P_j \\le N$）。\n\n他需要从电线杆 $1$ 获取电力到电线杆 $N$（这意味着一些电线可以从电线杆 $1$ 通过某些中间电线杆传输到电线杆 $N$）。\n\n给定 $N$ 根电线杆的位置和剩余电线的列表，确定恢复电力连接所需的最小电线长度，以便电力可以从电线杆 $1$ 流向电线杆 $N$。没有电线可以长于某个实数 $M$（$0.0 < M \\le 200000.0$）。\n\n例如，下面左侧是暴风雨后 $9$ 根电线杆和 $3$ 根电线的地图。对于这个任务，$M = 2.0$。最佳的电线连接方案是连接电线杆 $4$ 和 $6$，以及电线杆 $6$ 和 $9$。\n\n```cpp\n   暴风雨后                  最优重新连接\n3  . . . 7 9 . . . . .          3  . . . 7 9 . . . . .\n                                          /\n2  . . 5 6 . . . . . .          2  . . 5 6 . . . . . .\n                                        /\n1  2-3-4 . 8 . . . . .          1  2-3-4 . 8 . . . . .\n   |                               |\n0  1 . . . . . . . . .          0  1 . . . . . . . . .\n\n   0 1 2 3 4 5 6 7 8 9             0 1 2 3 4 5 6 7 8 9\n```\n\n总长度为 $1.414213562 + 1.414213562 = 2.828427124$。\n\n分值：350\n", "inputFormat": "第 $1$ 行：两个用空格分隔的整数：$N$ 和 $W$。\n\n第 $2$ 行：一个实数：$M$。\n\n第 $3\\ldots N+2$ 行：每行包含两个用空格分隔的整数：$x_i$ 和 $y_i$。\n\n第 $N+3\\ldots N+2+W$ 行：两个用空格分隔的整数：$P_i$ 和 $P_j$。\n", "outputFormat": "第 1 行：单独一行上的一个整数。如果无法恢复连接，输出 `-1`。否则，输出一个整数，该整数是恢复电力所需的总最小成本的 $1000$ 倍。不要进行任何四舍五入；截断结果乘积。\n", "hint": "就像上面的图示一样。\n\n\n如上所述。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2915", "type": "P", "difficulty": 5, "samples": [["4 1 \n3 \n4 \n2 \n1 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO", "状压 DP"], "title": "[USACO08NOV] Mixed Up Cows G", "background": "", "description": "Each of Farmer John's N (4 <= N <= 16) cows has a unique serial number S\\_i (1 <= S\\_i <= 25,000). The cows are so proud of it that each one now wears her number in a gangsta manner engraved in large letters on a gold plate hung around her ample bovine neck.\n\nGangsta cows are rebellious and line up to be milked in an order called 'Mixed Up'. A cow order is 'Mixed Up' if the sequence of serial numbers formed by their milking line is such that the serial numbers of every pair of consecutive cows in line differs by more than K (1 <= K <= 3400). For example, if N = 6 and K = 1 then 1, 3, 5, 2, 6, 4 is a 'Mixed Up' lineup but 1, 3, 6, 5, 2, 4 is not (since the consecutive numbers 5 and 6 differ by 1).\n\nHow many different ways can N cows be Mixed Up?\n\nFor your first 10 submissions, you will be provided with the results of running your program on a part of the actual test data.\n\nPOINTS: 200\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..N+1: Line i+1 contains a single integer that is the serial number of cow i: S\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the number of ways that N cows can be 'Mixed Up'. The answer is guaranteed to fit in a 64 bit integer.\n", "hint": "The 2 possible Mixed Up arrangements are:\n\n3 1 4 2\n\n2 4 1 3\n", "locale": "en", "translations": {"en": {"title": "[USACO08NOV] Mixed Up Cows G", "background": "", "description": "Each of Farmer John's N (4 <= N <= 16) cows has a unique serial number S\\_i (1 <= S\\_i <= 25,000). The cows are so proud of it that each one now wears her number in a gangsta manner engraved in large letters on a gold plate hung around her ample bovine neck.\n\nGangsta cows are rebellious and line up to be milked in an order called 'Mixed Up'. A cow order is 'Mixed Up' if the sequence of serial numbers formed by their milking line is such that the serial numbers of every pair of consecutive cows in line differs by more than K (1 <= K <= 3400). For example, if N = 6 and K = 1 then 1, 3, 5, 2, 6, 4 is a 'Mixed Up' lineup but 1, 3, 6, 5, 2, 4 is not (since the consecutive numbers 5 and 6 differ by 1).\n\nHow many different ways can N cows be Mixed Up?\n\nFor your first 10 submissions, you will be provided with the results of running your program on a part of the actual test data.\n\nPOINTS: 200\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..N+1: Line i+1 contains a single integer that is the serial number of cow i: S\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the number of ways that N cows can be 'Mixed Up'. The answer is guaranteed to fit in a 64 bit integer.\n", "hint": "The 2 possible Mixed Up arrangements are:\n\n3 1 4 2\n\n2 4 1 3\n", "locale": "en"}, "zh-CN": {"title": "[USACO08NOV] Mixed Up Cows G", "background": null, "description": "约翰家有 $N$（$4\\le N\\le16$）头奶牛，第 $i$ 头奶牛的编号是 $S_i$（$1\\le S_i \\le 25,000$），每头奶牛的编号都是唯一的。\n\n这些奶牛最近在闹脾气，为表达不满的情绪，她们在挤奶的时候一定要排成混乱的队伍。在一只混乱的队伍中，相邻奶牛的编号之差均超过 $K$（$1\\le K \\le 3,400$）。比如当 $K=1$ 时，$[1,3,5,2,6,4]$ 就是一支混乱的队伍，而 $[1,3,6,5,2,4]$ 不是，因为 $6$ 和 $5$ 只差 $1$。\n\n请数一数，有多少种队形是混乱的呢？", "inputFormat": "第 $1$ 行：两个用空格分隔的整数 $N$ 和 $K$。\n\n第 $2\\sim N+1$ 行：第 $i+1$ 行包含奶牛 $i$ 的序列号 $S_i$。", "outputFormat": "输出一行答案，表示混乱的队形数量。保证可以使用 64 位整型存下。", "hint": "两种可能的混乱队形如下：\n\n- $3,1,4,2$\n\n- $2,4,1,3$", "locale": "zh-CN"}}}
{"pid": "P2916", "type": "P", "difficulty": 4, "samples": [["5 7 \n10 \n10 \n20 \n6 \n30 \n1 2 5 \n2 3 5 \n2 4 12 \n3 4 17 \n2 5 15 \n3 5 6 \n4 5 12 \n", "176 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO", "生成树"], "title": "[USACO08NOV] Cheering up the Cow G", "background": "", "description": "农夫约翰有 $$ N $$ 个牧场（编号为 $$ 1 $$ 到 $$ N $$，$$ 5 \\leq N \\leq 10,000 $$），每个牧场住着一头牛。这些牧场通过 $$ P $$ 条双向路径（$$ N-1 \\leq P \\leq 100,000 $$）连接。每条路径 $$ j $$ 连接牧场 $$ S_j $$ 和 $$ E_j $$（$$ 1 \\leq S_j \\leq N $$；$$ 1 \\leq E_j \\leq N $$；$$ S_j \\neq E_j $$），穿越该路径需要耗费 $$ L_j $$（$$ 0 \\leq L_j \\leq 1,000 $$）单位时间。任意两座牧场之间最多只有一条直接相连的路径。\n\n约翰打算在保持各牧场连通的情况下去掉尽量多的道路。约翰知道，在道路被强拆后，奶牛会非常伤心，所以他计划拆除道路之后就去安抚她们。约翰可以选择从任意一个牧场出发开始他的安抚工作。当他走访完所有的奶牛之后，还要回到他的出发地。每次路过牧场 $i$ 的时候，他必须花 $C_i( 1 \\leq C_i \\leq 1000 )$ 的时间和奶牛交谈，即使之前已经谈过了，也要留下来再谈一次。注意约翰在出发和回去的时候，都要和出发地的奶牛谈一次话。\n\n假设农夫约翰采纳了你关于保留路径的建议，并且你选择了最优的住宿牧场，请计算满足每天至少拜访每头牛一次的前提下，所需的最小总时间。", "inputFormat": "* 第 $1$ 行：两个用空格分隔的整数：$$ N $$ 和 $$ P $$  \n\n* 第 $2$ 行到第 $$ N+1 $$ 行：第 $$ i+1 $$ 行包含一个整数：$$ C_i $$  。\n\n* 第 $$ N+2 $$ 行到第 $$ N+P+1 $$ 行：第 $$ N+j+1 $$ 行包含三个用空格分隔的整数：$$ S_j $$、$$ E_j $$ 和 $$ L_j $$。", "outputFormat": "* 第 1 行：一个整数，表示拜访所有奶牛（包括在睡觉牧场进行的两次交谈）所需的最小总时间。", "hint": "```cpp\n   +-(15)-+\n  /        \\\n /          \\\n1-(5)-2-(5)-3-(6)--5\n   \\   /(17)  /\n(12)\\ /      /(12)\n     4------+\n\n保留这些路径：\n1-(5)-2-(5)-3      5\n       \\          /\n    (12)\\        /(12)\n        *4------+\n```\n\n选择牧场 $4$ 作为住处，按照 $4→5→4→2→3→2→1→2→4$ 的顺序拜访所有牧场，最终返回睡觉，总耗时为 $176$ 单位时间。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08NOV] Cheering up the Cow G", "background": "", "description": "Farmer John has $N$ pastures (numbered $1$ to $N$, $5 \\leq N \\leq 10,000$), each inhabited by one cow. These pastures are connected by $P$ bidirectional paths ($N-1 \\leq P \\leq 100,000$). Each path $j$ connects pastures $S_j$ and $E_j$ ($1 \\leq S_j \\leq N$; $1 \\leq E_j \\leq N$; $S_j \\neq E_j$), and traversing it takes $L_j$ units of time ($0 \\leq L_j \\leq 1,000$). There is at most one direct path between any pair of pastures.\n\nJohn plans to remove as many roads as possible while keeping all pastures connected. He knows the cows will be very sad after the demolition, so he plans to comfort them afterward. John may choose any pasture to start his comforting tour. After he has visited all cows, he must return to his starting pasture. Each time he passes pasture $i$, he must spend $C_i$ ($1 \\leq C_i \\leq 1000$) units of time to talk with the cow there; even if he has already talked before, he must stop and talk again. Note that both when setting out and when returning, he must talk to the cow at the starting pasture.\n\nAssume Farmer John follows your recommendation on which paths to keep, and you also choose the optimal lodging pasture. Compute the minimal total time required while ensuring that each cow is visited at least once.", "inputFormat": "- Line $1$: Two space-separated integers: $N$ and $P$.\n- Lines $2$ to $N+1$: Line $i+1$ contains one integer: $C_i$.\n- Lines $N+2$ to $N+P+1$: Line $N+j+1$ contains three space-separated integers: $S_j$, $E_j$, and $L_j$.", "outputFormat": "- Line $1$: A single integer, the minimal total time needed to visit all cows (including the two chats at the lodging pasture).", "hint": "```cpp\n   +-(15)-+\n  /        \\\n /          \\\n1-(5)-2-(5)-3-(6)--5\n   \\   /(17)  /\n(12)\\ /      /(12)\n     4------+\n\nKeep these paths:\n1-(5)-2-(5)-3      5\n       \\          /\n    (12)\\        /(12)\n        *4------+\n```\n\nChoose pasture $4$ as the lodging pasture, visit in the order $4 \\to 5 \\to 4 \\to 2 \\to 3 \\to 2 \\to 1 \\to 2 \\to 4$, and finally return to sleep. The total time is $176$ units.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO08NOV] Cheering up the Cow G", "background": "", "description": "农夫约翰有 $$ N $$ 个牧场（编号为 $$ 1 $$ 到 $$ N $$，$$ 5 \\leq N \\leq 10,000 $$），每个牧场住着一头牛。这些牧场通过 $$ P $$ 条双向路径（$$ N-1 \\leq P \\leq 100,000 $$）连接。每条路径 $$ j $$ 连接牧场 $$ S_j $$ 和 $$ E_j $$（$$ 1 \\leq S_j \\leq N $$；$$ 1 \\leq E_j \\leq N $$；$$ S_j \\neq E_j $$），穿越该路径需要耗费 $$ L_j $$（$$ 0 \\leq L_j \\leq 1,000 $$）单位时间。任意两座牧场之间最多只有一条直接相连的路径。\n\n约翰打算在保持各牧场连通的情况下去掉尽量多的道路。约翰知道，在道路被强拆后，奶牛会非常伤心，所以他计划拆除道路之后就去安抚她们。约翰可以选择从任意一个牧场出发开始他的安抚工作。当他走访完所有的奶牛之后，还要回到他的出发地。每次路过牧场 $i$ 的时候，他必须花 $C_i( 1 \\leq C_i \\leq 1000 )$ 的时间和奶牛交谈，即使之前已经谈过了，也要留下来再谈一次。注意约翰在出发和回去的时候，都要和出发地的奶牛谈一次话。\n\n假设农夫约翰采纳了你关于保留路径的建议，并且你选择了最优的住宿牧场，请计算满足每天至少拜访每头牛一次的前提下，所需的最小总时间。", "inputFormat": "* 第 $1$ 行：两个用空格分隔的整数：$$ N $$ 和 $$ P $$  \n\n* 第 $2$ 行到第 $$ N+1 $$ 行：第 $$ i+1 $$ 行包含一个整数：$$ C_i $$  。\n\n* 第 $$ N+2 $$ 行到第 $$ N+P+1 $$ 行：第 $$ N+j+1 $$ 行包含三个用空格分隔的整数：$$ S_j $$、$$ E_j $$ 和 $$ L_j $$。", "outputFormat": "* 第 1 行：一个整数，表示拜访所有奶牛（包括在睡觉牧场进行的两次交谈）所需的最小总时间。", "hint": "```cpp\n   +-(15)-+\n  /        \\\n /          \\\n1-(5)-2-(5)-3-(6)--5\n   \\   /(17)  /\n(12)\\ /      /(12)\n     4------+\n\n保留这些路径：\n1-(5)-2-(5)-3      5\n       \\          /\n    (12)\\        /(12)\n        *4------+\n```\n\n选择牧场 $4$ 作为住处，按照 $4→5→4→2→3→2→1→2→4$ 的顺序拜访所有牧场，最终返回睡觉，总耗时为 $176$ 单位时间。", "locale": "zh-CN"}}}
{"pid": "P2917", "type": "P", "difficulty": 6, "samples": [["4 1 2 2 1 3 \n8 \n2 \n1 \n6 \n", "35 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2008", "USACO", "生成树", "状压 DP"], "title": "[USACO08NOV] Toys G", "background": "", "description": "Bessie's birthday is coming up, and she wishes to celebrate for the next D (1 <= D <= 100,000; 70% of testdata has 1 <= D <= 500) days. Cows have short attention spans so Bessie wants to provide toys to entertain them. She has calculated that she will require T\\_i (1 <= T\\_i <= 50) toys on day i.\n\nBessie's kindergarten provides many services to its aspiring bovine programmers, including a toy shop which sells toys for Tc (1 <= Tc <= 60) dollars. Bessie wishes to save money by reusing toys, but Farmer John is worried about transmitting diseases and requires toys to be disinfected before use. (The toy shop disinfects the toys when it sells them.)\n\nThe two disinfectant services near the farm provide handy complete services. The first one charges C1 dollars and requires N1 nights to complete; the second charges C2 dollars and requires N2 nights to complete (1 <= N1 <= D; 1 <= N2 <= D; 1 <= C1 <= 60; 1 <= C2 <= 60). Bessie takes the toys to the disinfecters after the party and can pay and pick them back up the next morning if one night service is rendered, or on later mornings if more nights are required for disinfecting.\n\nBeing an educated cow, Bessie has already learned the value of saving her money. Help her find the cheapest way she can provide toys for her party.\n\nPOINTS: 400\n", "inputFormat": "\\* Line 1: Six space-separated integers: D, N1, N2, C1, C2, Tc\n\n\\* Lines 2..D+1: Line i+1 contains a single integer: T\\_i\n", "outputFormat": "\\* Line 1: The minimum cost to provide safe and sanitary toys for Bessie's birthday parties.\n", "hint": "Bessie wishes to party for 4 days, and requires 8 toys the first day, 2 toys the second, 1 toy the third, and 6 toys on the fourth day. The first disinfectant service takes 1 day and charges \\$2, and the second takes 2 days and charges \\$1. Buying a new toy costs \\$3.\n\n\nDay 1   Purchase 8 toys in the morning for $24; party in the\n\nafternoon. Take 2 toys to the fast cleaner (overnight) and \n\nthe other 6 toys to the slow cleaner (two nights). \n\nDay 2   Pick up the two toys at the fast cleaner; pay $4. Party in the afternoon. Take 1 toy to the slow cleaner. \n\nDay 3   Pick up 6 toys from the slow cleaner and pay $6. Party in the afternoon.\n\nDay 4   Pick up the final remaining toy from the slow cleaner\n\n(bringing the number of toys onsite back to 6); pay $1. Party hearty with the realization that a minimum amount of money was spent.\n", "locale": "en", "translations": {"en": {"title": "[USACO08NOV] Toys G", "background": "", "description": "Bessie's birthday is coming up, and she wishes to celebrate for the next D (1 <= D <= 100,000; 70% of testdata has 1 <= D <= 500) days. Cows have short attention spans so Bessie wants to provide toys to entertain them. She has calculated that she will require T\\_i (1 <= T\\_i <= 50) toys on day i.\n\nBessie's kindergarten provides many services to its aspiring bovine programmers, including a toy shop which sells toys for Tc (1 <= Tc <= 60) dollars. Bessie wishes to save money by reusing toys, but Farmer John is worried about transmitting diseases and requires toys to be disinfected before use. (The toy shop disinfects the toys when it sells them.)\n\nThe two disinfectant services near the farm provide handy complete services. The first one charges C1 dollars and requires N1 nights to complete; the second charges C2 dollars and requires N2 nights to complete (1 <= N1 <= D; 1 <= N2 <= D; 1 <= C1 <= 60; 1 <= C2 <= 60). Bessie takes the toys to the disinfecters after the party and can pay and pick them back up the next morning if one night service is rendered, or on later mornings if more nights are required for disinfecting.\n\nBeing an educated cow, Bessie has already learned the value of saving her money. Help her find the cheapest way she can provide toys for her party.\n\nPOINTS: 400\n", "inputFormat": "\\* Line 1: Six space-separated integers: D, N1, N2, C1, C2, Tc\n\n\\* Lines 2..D+1: Line i+1 contains a single integer: T\\_i\n", "outputFormat": "\\* Line 1: The minimum cost to provide safe and sanitary toys for Bessie's birthday parties.\n", "hint": "Bessie wishes to party for 4 days, and requires 8 toys the first day, 2 toys the second, 1 toy the third, and 6 toys on the fourth day. The first disinfectant service takes 1 day and charges \\$2, and the second takes 2 days and charges \\$1. Buying a new toy costs \\$3.\n\n\nDay 1   Purchase 8 toys in the morning for $24; party in the\n\nafternoon. Take 2 toys to the fast cleaner (overnight) and \n\nthe other 6 toys to the slow cleaner (two nights). \n\nDay 2   Pick up the two toys at the fast cleaner; pay $4. Party in the afternoon. Take 1 toy to the slow cleaner. \n\nDay 3   Pick up 6 toys from the slow cleaner and pay $6. Party in the afternoon.\n\nDay 4   Pick up the final remaining toy from the slow cleaner\n\n(bringing the number of toys onsite back to 6); pay $1. Party hearty with the realization that a minimum amount of money was spent.\n", "locale": "en"}, "zh-CN": {"title": "[USACO08NOV] Toys G", "background": "", "description": "贝茜的生日快到了，她希望在接下来的 D 天（1 <= D <= 100,000；70% 的测试数据满足 1 <= D <= 500）里庆祝。奶牛们注意力短暂，所以贝茜想要提供玩具来娱乐它们。她计算出她在第 i 天需要 T_i（1 <= T_i <= 50）个玩具。\n\n贝茜的幼儿园为其有抱负的牛程序员提供许多服务，包括一个玩具店，玩具售价为 Tc（1 <= Tc <= 60）美元。贝茜希望通过重复使用玩具来省钱，但农夫约翰担心传染病，要求玩具在使用前进行消毒。（玩具店在销售玩具时会对其进行消毒。）\n\n农场附近的两个消毒服务提供便捷的全套服务。第一个服务收费 C1 美元，需要 N1 个晚上完成；第二个服务收费 C2 美元，需要 N2 个晚上完成（1 <= N1 <= D；1 <= N2 <= D；1 <= C1 <= 60；1 <= C2 <= 60）。贝茜在派对后将玩具送去消毒，如果是一个晚上的服务，她可以在第二天早上支付并取回玩具，或者如果需要更多晚上的消毒，则在之后的早晨取回。\n\n作为一头有学问的奶牛，贝茜已经学会了节省金钱的价值。帮助她找到为她的派对提供玩具的最便宜的方法。\n\nPOINTS: 400", "inputFormat": "* 第 1 行：六个用空格分隔的整数：D, N1, N2, C1, C2, Tc\n\n* 第 2 行到第 D+1 行：第 i+1 行包含一个整数：T_i", "outputFormat": "* 第 1 行：为贝茜的生日派对提供安全卫生玩具的最低成本。", "hint": "贝茜希望庆祝 4 天，第一天需要 8 个玩具，第二天需要 2 个玩具，第三天需要 1 个玩具，第四天需要 6 个玩具。第一个消毒服务需要 1 天，收费 2 美元，第二个需要 2 天，收费 1 美元。购买一个新玩具需要 3 美元。\n\n第 1 天 早上购买 8 个玩具，花费 24 美元；下午开派对。将 2 个玩具送去快速清洗（过夜），其余 6 个玩具送去慢速清洗（两晚）。\n\n第 2 天 从快速清洗处取回 2 个玩具；支付 4 美元。下午开派对。将 1 个玩具送去慢速清洗。\n\n第 3 天 从慢速清洗处取回 6 个玩具并支付 6 美元。下午开派对。\n\n第 4 天 从慢速清洗处取回最后一个玩具（将现场玩具数量恢复到 6 个）；支付 1 美元。开心地开派对，意识到花费了最少的钱。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P2918", "type": "P", "difficulty": 3, "samples": [["2 15 \n3 2 \n5 3 \n", "9 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "USACO", "背包 DP"], "title": "[USACO08NOV] Buying Hay S", "background": "", "description": "Farmer John is running out of supplies and needs to purchase H (1 <= H <= 50,000) pounds of hay for his cows.\n\nHe knows N (1 <= N <= 100) hay suppliers conveniently numbered 1..N. Supplier i sells packages that contain P\\_i (1 <= P\\_i <= 5,000) pounds of hay at a cost of C\\_i (1 <= C\\_i <= 5,000) dollars. Each supplier has an unlimited number of packages available, and the packages must be bought whole.\n\nHelp FJ by finding the minimum cost necessary to purchase at least H pounds of hay.", "inputFormat": "\\* Line 1: Two space-separated integers: N and H\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: P\\_i and C\\_i", "outputFormat": "\\* Line 1: A single integer representing the minimum cost FJ needs to pay to obtain at least H pounds of hay.", "hint": "FJ can buy three packages from the second supplier for a total cost of 9.", "locale": "en", "translations": {"en": {"title": "[USACO08NOV] Buying Hay S", "background": "", "description": "Farmer John is running out of supplies and needs to purchase H (1 <= H <= 50,000) pounds of hay for his cows.\n\nHe knows N (1 <= N <= 100) hay suppliers conveniently numbered 1..N. Supplier i sells packages that contain P\\_i (1 <= P\\_i <= 5,000) pounds of hay at a cost of C\\_i (1 <= C\\_i <= 5,000) dollars. Each supplier has an unlimited number of packages available, and the packages must be bought whole.\n\nHelp FJ by finding the minimum cost necessary to purchase at least H pounds of hay.", "inputFormat": "\\* Line 1: Two space-separated integers: N and H\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: P\\_i and C\\_i", "outputFormat": "\\* Line 1: A single integer representing the minimum cost FJ needs to pay to obtain at least H pounds of hay.", "hint": "FJ can buy three packages from the second supplier for a total cost of 9.", "locale": "en"}, "zh-CN": {"title": "[USACO08NOV] Buying Hay S", "background": null, "description": "约翰的干草库存已经告罄，他打算为奶牛们采购 $H(1 \\leq H \\leq 50000)$ 磅干草。\n\n他知道 $N(1 \\leq N\\leq 100)$ 个干草公司，现在用 $1$ 到 $N$ 给它们编号。第 $i$ 公司卖的干草包重量为 $P_i (1 \\leq P_i \\leq 5,000)$ 磅，需要的开销为 $C_i (1 \\leq C_i \\leq 5,000)$ 美元。每个干草公司的货源都十分充足， 可以卖出无限多的干草包。\n\n帮助约翰找到最小的开销来满足需要，即采购到至少 $H$ 磅干草。", "inputFormat": "第 $1$ 行：两个整数： $N$ 与 $H$ ，以空格分隔。\n\n第 $2$ 行至第 $N+1$ 行：其中第 $i+1$ 行包含两个整数： $P_i$ 与 $C_i$ ，以空格分隔。", "outputFormat": "一个整数，表示 FJ 至少采购到 $H$ 磅干草所需的最少花费。", "hint": "FJ 可以在第二家公司买 $3$ 包干草，共花费 $9$ 美元。", "locale": "zh-CN"}}}
{"pid": "P2919", "type": "P", "difficulty": 4, "samples": [["8 7 \n4 3 2 2 1 0 1 \n3 3 3 2 1 0 1 \n2 2 2 2 1 0 0 \n2 1 1 1 1 0 0 \n1 1 0 0 0 1 0 \n0 0 0 1 1 1 0 \n0 1 2 2 1 1 0 \n0 1 1 1 2 1 0 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2008", "USACO", "广度优先搜索 BFS", "深度优先搜索 DFS"], "title": "[USACO08NOV] Guarding the Farm S", "background": "", "description": "The farm has many hills upon which Farmer John would like to place guards to ensure the safety of his valuable milk-cows.\n\nHe wonders how many guards he will need if he wishes to put one on top of each hill. He has a map supplied as a matrix of integers; the matrix has N (1 < N <= 700) rows and M (1 < M <= 700) columns. Each member of the matrix is an altitude H\\_ij (0 <= H\\_ij <= 10,000). Help him determine the number of hilltops on the map.\n\nA hilltop is one or more adjacent matrix elements of the same value surrounded exclusively by either the edge of the map or elements with a lower (smaller) altitude. Two different elements are adjacent if the magnitude of difference in their X coordinates is no greater than 1 and the magnitude of differences in their Y coordinates is also no greater than 1.\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 describes row i of the matrix with M\n\nspace-separated integers: H\\_ij\n", "outputFormat": "\\* Line 1: A single integer that specifies the number of hilltops\n", "hint": "There are three peaks: The one with height 4 on the left top, one of the points with height 2 at the bottom part, and one of the points with height 1 on the right top corner.\n", "locale": "en", "translations": {"en": {"title": "[USACO08NOV] Guarding the Farm S", "background": "", "description": "The farm has many hills upon which Farmer John would like to place guards to ensure the safety of his valuable milk-cows.\n\nHe wonders how many guards he will need if he wishes to put one on top of each hill. He has a map supplied as a matrix of integers; the matrix has N (1 < N <= 700) rows and M (1 < M <= 700) columns. Each member of the matrix is an altitude H\\_ij (0 <= H\\_ij <= 10,000). Help him determine the number of hilltops on the map.\n\nA hilltop is one or more adjacent matrix elements of the same value surrounded exclusively by either the edge of the map or elements with a lower (smaller) altitude. Two different elements are adjacent if the magnitude of difference in their X coordinates is no greater than 1 and the magnitude of differences in their Y coordinates is also no greater than 1.\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 describes row i of the matrix with M\n\nspace-separated integers: H\\_ij\n", "outputFormat": "\\* Line 1: A single integer that specifies the number of hilltops\n", "hint": "There are three peaks: The one with height 4 on the left top, one of the points with height 2 at the bottom part, and one of the points with height 1 on the right top corner.\n", "locale": "en"}, "zh-CN": {"title": "[USACO08NOV] Guarding the Farm S", "background": "", "description": "农场有许多小山丘，约翰农夫希望在这些小山丘上放置守卫，以确保他珍贵的奶牛的安全。\n\n他想知道如果他希望在每个小山丘的顶部放置一个守卫，他需要多少守卫。他有一张地图，这张地图是一个整数矩阵；矩阵有 $N$ 行（$1 < N \\leq 700$）和 $M$ 列（$1 < M \\leq 700$）。矩阵中的每个元素表示一个高度 $H_{ij}$（$0 \\leq H_{ij} \\leq 10,000$）。请帮助他确定地图上有多少个山顶。\n\n一个山顶是由一个或多个相邻且具有相同值的矩阵元素组成，这些元素被地图的边缘或具有较低（较小）高度的元素完全包围。如果两个不同的元素的 $X$ 坐标差的绝对值不大于 1，且 $Y$ 坐标差的绝对值也不大于 1，则它们是相邻的。\n", "inputFormat": "\\* 第 1 行：两个用空格分隔的整数：$N$ 和 $M$\n\n\\* 第 2 行到第 $N+1$ 行：第 $i+1$ 行描述矩阵的第 $i$ 行，包含 $M$ 个用空格分隔的整数：$H_{ij}$\n", "outputFormat": "\\* 第 1 行：一个整数，表示山顶的数量\n", "hint": "有三个山峰：左上角高度为 4 的一个，底部高度为 2 的一个点，以及右上角高度为 1 的一个点。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2920", "type": "P", "difficulty": 3, "samples": [["4 \n3 5 \n8 14 \n5 20 \n1 16 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2008", "二分", "USACO", "排序"], "title": "[USACO08NOV] Time Management S", "background": "", "description": "作为一名忙碌的商人，约翰知道必须高效地安排他的时间。他有 $N(1\\le N\\le 1000)$ 个工作要做，比如给奶牛挤奶，清洗牛棚，修理栅栏之类的。\n\n为了高效，约翰列出了所有工作的清单。第 $i(1\\le i\\le N)$ 个工作需要 $T_i(1\\le T_i\\le 1000)$ 单位的时间来完成，而且必须在 $1\\le S_i\\le 10^6$ 或之前完成。现在是 $0$ 时刻。约翰做一份工作必须直到做完才能停止。\n\n所有的商人都喜欢睡懒觉。请帮约翰计算他最迟什么时候开始工作，可以让所有工作按时完成。（如果始终无法完成全部任务，输出 `-1`）", "inputFormat": "第一行，一个整数 $N$\n\n接下来 $N$ 行，每行 $2$ 个有空格分隔的整数 $T_i,S_i$", "outputFormat": "一行，一个整数，表示约翰可以开始工作的最晚时间，如果约翰无法完成所有工作，则为 `-1`", "hint": "**【样例解释】**\n\n约翰有 $4$ 个工作要做，分别需要 $3、8、5$ 和 $1$ 个时间单位，并且必须分别在时间 $5、14、20$ 和 $16$ 之前完成。\n\n约翰必须在时间 $2$ 开始第一个作业。然后他可以按此顺序完成第二、第四和第三项工作，以按时完成。", "locale": "zh-CN", "translations": {"en": {"title": "", "background": "", "description": "Ever the maturing businessman, Farmer John realizes that he must manage his time effectively. He has N jobs conveniently numbered 1..N (1 <= N <= 1,000) to accomplish (like milking the cows, cleaning the barn, mending the fences, and so on).\n\nTo manage his time effectively, he has created a list of the jobs that must be finished. Job i requires a certain amount of time T\\_i (1 <= T\\_i <= 1,000) to complete and furthermore must be finished by time S\\_i (1 <= S\\_i <= 1,000,000). Farmer John starts his day at time t=0 and can only work on one job at a time until it is finished.\n\nEven a maturing businessman likes to sleep late; help Farmer John determine the latest he can start working and still finish all the jobs on time.", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: T\\_i and S\\_i\n", "outputFormat": "Farmer John has 4 jobs to do, which take 3, 8, 5, and 1 units of time, respectively, and must be completed by time 5, 14, 20, and 16, respectively.\n\n\nFarmer John must start the first job at time 2. Then he can do the second, fourth, and third jobs in that order to finish on time.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO08NOV] Time Management S", "background": "", "description": "作为一名忙碌的商人，约翰知道必须高效地安排他的时间。他有 $N(1\\le N\\le 1000)$ 个工作要做，比如给奶牛挤奶，清洗牛棚，修理栅栏之类的。\n\n为了高效，约翰列出了所有工作的清单。第 $i(1\\le i\\le N)$ 个工作需要 $T_i(1\\le T_i\\le 1000)$ 单位的时间来完成，而且必须在 $1\\le S_i\\le 10^6$ 或之前完成。现在是 $0$ 时刻。约翰做一份工作必须直到做完才能停止。\n\n所有的商人都喜欢睡懒觉。请帮约翰计算他最迟什么时候开始工作，可以让所有工作按时完成。（如果始终无法完成全部任务，输出 `-1`）", "inputFormat": "第一行，一个整数 $N$\n\n接下来 $N$ 行，每行 $2$ 个有空格分隔的整数 $T_i,S_i$", "outputFormat": "一行，一个整数，表示约翰可以开始工作的最晚时间，如果约翰无法完成所有工作，则为 `-1`", "hint": "**【样例解释】**\n\n约翰有 $4$ 个工作要做，分别需要 $3、8、5$ 和 $1$ 个时间单位，并且必须分别在时间 $5、14、20$ 和 $16$ 之前完成。\n\n约翰必须在时间 $2$ 开始第一个作业。然后他可以按此顺序完成第二、第四和第三项工作，以按时完成。", "locale": "zh-CN"}}}
{"pid": "P2921", "type": "P", "difficulty": 4, "samples": [["4 \n1 \n3 \n2 \n3 \n", "1 \n2 \n2 \n3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "2008", "USACO", "记忆化搜索", "Tarjan", "基环树"], "title": "[USACO08DEC] Trick or Treat on the Farm G", "background": "", "description": "Every year in Wisconsin the cows celebrate the USA autumn holiday of Halloween by dressing up in costumes and collecting candy that Farmer John leaves in the N (1 <= N <= 100,000) stalls conveniently numbered 1..N.\n\nBecause the barn is not so large, FJ makes sure the cows extend their fun by specifying a traversal route the cows must follow.  To implement this scheme for traveling back and forth through the barn, FJ has posted a 'next stall number' next\\_i (1 <= next\\_i <= N) on stall i that tells the cows which stall to visit next; the cows thus might travel the length of the barn many times in order to collect their candy.\n\nFJ mandates that cow i should start collecting candy at stall i. A cow stops her candy collection if she arrives back at any stall she has already visited.\n\nCalculate the number of unique stalls each cow visits before being forced to stop her candy collection.\n\nPOINTS: 100", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: next\\_i\n", "outputFormat": "\\* Lines 1..N: Line i contains a single integer that is the total number of unique stalls visited by cow i before she returns to a stall  she has previously visited.\n", "hint": "Four stalls.\n\n\\* Stall 1 directs the cow back to stall 1.\n\n\\* Stall 2 directs the cow to stall 3\n\n\\* Stall 3 directs the cow to stall 2\n\n\\* Stall 4 directs the cow to stall 3\n\n\nCow 1:  Start at 1, next is 1.  Total stalls visited: 1.\n\nCow 2:  Start at 2, next is 3, next is 2.  Total stalls visited: 2. Cow 3:  Start at 3, next is 2, next is 3.  Total stalls visited: 2. Cow 4:  Start at 4, next is 3, next is 2, next is 3. Total stalls visited: 3.\n", "locale": "en", "translations": {"en": {"title": "[USACO08DEC] Trick or Treat on the Farm G", "background": "", "description": "Every year in Wisconsin the cows celebrate the USA autumn holiday of Halloween by dressing up in costumes and collecting candy that Farmer John leaves in the N (1 <= N <= 100,000) stalls conveniently numbered 1..N.\n\nBecause the barn is not so large, FJ makes sure the cows extend their fun by specifying a traversal route the cows must follow.  To implement this scheme for traveling back and forth through the barn, FJ has posted a 'next stall number' next\\_i (1 <= next\\_i <= N) on stall i that tells the cows which stall to visit next; the cows thus might travel the length of the barn many times in order to collect their candy.\n\nFJ mandates that cow i should start collecting candy at stall i. A cow stops her candy collection if she arrives back at any stall she has already visited.\n\nCalculate the number of unique stalls each cow visits before being forced to stop her candy collection.\n\nPOINTS: 100", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: next\\_i\n", "outputFormat": "\\* Lines 1..N: Line i contains a single integer that is the total number of unique stalls visited by cow i before she returns to a stall  she has previously visited.\n", "hint": "Four stalls.\n\n\\* Stall 1 directs the cow back to stall 1.\n\n\\* Stall 2 directs the cow to stall 3\n\n\\* Stall 3 directs the cow to stall 2\n\n\\* Stall 4 directs the cow to stall 3\n\n\nCow 1:  Start at 1, next is 1.  Total stalls visited: 1.\n\nCow 2:  Start at 2, next is 3, next is 2.  Total stalls visited: 2. Cow 3:  Start at 3, next is 2, next is 3.  Total stalls visited: 2. Cow 4:  Start at 4, next is 3, next is 2, next is 3. Total stalls visited: 3.\n", "locale": "en"}, "zh-CN": {"title": "[USACO08DEC] Trick or Treat on the Farm G", "background": null, "description": "每年，在威斯康星州，奶牛们都会穿上衣服，收集农夫约翰在 $N(1\\le N\\le 100,000)$ 个牛棚隔间中留下的糖果，以此来庆祝美国秋天的万圣节。\n\n由于牛棚不太大，FJ 通过指定奶牛必须遵循的穿越路线来确保奶牛的乐趣。为了实现这个让奶牛在牛棚里来回穿梭的方案，FJ 在第 $i$ 号隔间上张贴了一个 “下一个隔间：$next_i(1\\le next_i\\le N)$” 的标语，告诉奶牛要去的下一个隔间。这样，为了收集它们的糖果，奶牛就会在牛棚里来回穿梭了。\n\nFJ 命令奶牛 $i$ 应该从 $i$ 号隔间开始收集糖果。如果一只奶牛回到某一个她已经去过的隔间，她就会停止收集糖果。\n\n在被迫停止收集糖果之前，计算一下每头奶牛要前往的隔间数（包含起点）。", "inputFormat": "第一行一个整数 $n$，表示牛棚隔间的数量。\n\n第 $2$ 至 $n+1$ 行，每行包含一个整数 $next_i$，表示 $i$ 号隔间的下一个隔间。", "outputFormat": "输出共 $n$ 行，第 $i$ 行包含一个整数，表示第 $i$ 只奶牛要前往的隔间数。", "hint": "有 $4$ 个隔间。\n\n- 隔间 $1$ 要求牛到隔间 $1$，\n\n- 隔间 $2$ 要求牛到隔间 $3$，\n\n- 隔间 $3$ 要求牛到隔间 $2$，\n\n- 隔间 $4$ 要求牛到隔间 $3$。\n\n牛 $1$：从 $1\\rightarrow 1$，总共访问 $1$ 个隔间；\n\n牛 $2$：$2\\rightarrow 3\\rightarrow 2$，总共访问 $2$ 个隔间；\n\n牛 $3$：$3\\rightarrow 2\\rightarrow 3$，总共访问 $2$ 个隔间；\n\n牛 $4$：$4\\rightarrow 3\\rightarrow 2\\rightarrow 3$，总共访问 $3$ 个隔间。\n\n翻译提供者：[busy_programmer](https://www.luogu.com.cn/user/649315)。", "locale": "zh-CN"}}}
{"pid": "P2922", "type": "P", "difficulty": 4, "samples": [["4 5 \n3 0 1 0 \n1 1 \n3 1 0 0 \n3 1 1 0 \n1 0 \n1 1 \n2 0 1 \n5 0 1 0 0 1 \n2 1 1 \n", "1 \n3 \n1 \n1 \n2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO", "进制", "字典树 Trie"], "title": "[USACO08DEC] Secret Message G", "background": null, "description": "贝茜正在领导奶牛们逃跑。为了联络，奶牛们互相发送秘密信息。\n\n信息是二进制的，共有 $M$（$1 \\le M \\le 50000$）条，反间谍能力很强的约翰已经部分拦截了这些信息，知道了第  $i$ 条二进制信息的前 $b_i$（$1 \\le b_i \\le 10000$）位，他同时知道，奶牛使用 $N$（$1 \\le N \\le 50000$）条暗号．但是，他仅仅知道第 $j$ 条暗号的前 $c_j$（$1 \\le c_j \\le 10000$）位。\n\n对于每条暗号 $j$，他想知道有多少截得的信息能够和它匹配。也就是说，有多少信息和这条暗号有着相同的前缀。当然，这个前缀长度必须等于暗号和那条信息长度的较小者。\n\n在输入文件中，位的总数（即 $\\sum b_i + \\sum c_i$）不会超过 $5 \\times 10^5$。", "inputFormat": "第 $1$ 行：两个整数 $M$ 和 $N$。\n\n接下来 $M$ 行，其中的第 $i$ 行：一个整数 $b_i$，后跟 $b_i$ 个空格分隔的“0”和“1”，描述截取的消息 $i$。\n\n接下来 $N$ 行，其中的第 $j$ 行：一个整数 $c_j$，后跟 $c_j$ 个空格分隔的“0”和“1”，描述暗号 $j$。", "outputFormat": "$N$ 行，第 $i$ 行表示第 $i$ 个暗号可以匹配的消息数。", "hint": "四条消息；五条暗号。截获的消息以 `010`、`1`、`100` 和 `110` 开头。可能的暗号以 `0`、`1`、`01`、`01001` 和 `11` 开头。\n\n`0`：匹配 `010`: $1$ 个匹配。\n\n`1`：匹配 `1`、`100` 和 `110`，$3$ 个匹配。\n\n`01`：匹配 `010`，$1$ 个匹配。\n\n`01001`：匹配 `010`，$1$ 个匹配。\n\n`11`： 匹配 `1` 和 `110`，$2$ 个匹配。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08DEC] Secret Message G", "background": null, "description": "Bessie is leading the cows in an attempt to escape! To do this, the cows are sending secret binary messages to each other.\n\nEver the clever counterspy, Farmer John has intercepted the first $b_i$ ($1 \\le b_i \\le 10,000$) bits of each of $M$ ($1 \\le M \\le 50,000$) of these secret binary messages.\n\nHe has compiled a list of $N$ ($1 \\le N \\le 50,000$) partial codewords that he thinks the cows are using. Sadly, he only knows the first $c_j$ ($1 \\le c_j \\le 10,000$) bits of codeword $j$.\n\nFor each codeword $j$, he wants to know how many of the intercepted messages match that codeword (i.e., for codeword $j$, how many times does a message and the codeword have the same initial bits). Your job is to compute this number.\n\nThe total number of bits in the input (i.e., the sum of the $b_i$ and the $c_j$) will not exceed  $500,000$.", "inputFormat": "Line $1$: Two integers: $M$ and $N$.\n\nLines $2 \\ldots M+1$: Line $i+1$ describes intercepted code $i$ with an integer $b_i$ followed by $b_i$ space-separated `0`'s and `1`'s.\n\nLines $M+2 \\ldots M+N+1$: Line $M+j+1$ describes codeword $j$ with an integer $c_j$ followed by $c_j$ space-separated `0`'s and `1`'s.", "outputFormat": "Lines $1 \\ldots N$: Line $j$: The number of messages that the $j$-th codeword could match.", "hint": "Four messages; five codewords. \n\nThe intercepted messages start with 010, 1, 100, and 110.\n\nThe possible codewords start with 0, 1, 01, 01001, and 11.\n\n\n0 matches only 010: 1 match\n\n1 matches 1, 100, and 110: 3 matches\n\n01 matches only 010: 1 match\n\n01001 matches 010: 1 match\n\n11 matches 1 and 110: 2 matches", "locale": "en"}, "zh-CN": {"title": "[USACO08DEC] Secret Message G", "background": null, "description": "贝茜正在领导奶牛们逃跑。为了联络，奶牛们互相发送秘密信息。\n\n信息是二进制的，共有 $M$（$1 \\le M \\le 50000$）条，反间谍能力很强的约翰已经部分拦截了这些信息，知道了第  $i$ 条二进制信息的前 $b_i$（$1 \\le b_i \\le 10000$）位，他同时知道，奶牛使用 $N$（$1 \\le N \\le 50000$）条暗号．但是，他仅仅知道第 $j$ 条暗号的前 $c_j$（$1 \\le c_j \\le 10000$）位。\n\n对于每条暗号 $j$，他想知道有多少截得的信息能够和它匹配。也就是说，有多少信息和这条暗号有着相同的前缀。当然，这个前缀长度必须等于暗号和那条信息长度的较小者。\n\n在输入文件中，位的总数（即 $\\sum b_i + \\sum c_i$）不会超过 $5 \\times 10^5$。", "inputFormat": "第 $1$ 行：两个整数 $M$ 和 $N$。\n\n接下来 $M$ 行，其中的第 $i$ 行：一个整数 $b_i$，后跟 $b_i$ 个空格分隔的“0”和“1”，描述截取的消息 $i$。\n\n接下来 $N$ 行，其中的第 $j$ 行：一个整数 $c_j$，后跟 $c_j$ 个空格分隔的“0”和“1”，描述暗号 $j$。", "outputFormat": "$N$ 行，第 $i$ 行表示第 $i$ 个暗号可以匹配的消息数。", "hint": "四条消息；五条暗号。截获的消息以 `010`、`1`、`100` 和 `110` 开头。可能的暗号以 `0`、`1`、`01`、`01001` 和 `11` 开头。\n\n`0`：匹配 `010`: $1$ 个匹配。\n\n`1`：匹配 `1`、`100` 和 `110`，$3$ 个匹配。\n\n`01`：匹配 `010`，$1$ 个匹配。\n\n`01001`：匹配 `010`，$1$ 个匹配。\n\n`11`： 匹配 `1` 和 `110`，$2$ 个匹配。", "locale": "zh-CN"}}}
{"pid": "P2923", "type": "P", "difficulty": 5, "samples": [["8 \n-+-+-+-+ \n+-+-+-+- \n-+-K-+-+ \n+-+-+-+- \n-o-o-+-+ \n+-K-+-+- \n-o-+-+-+ \n+-K-+-K- \n", "8 3 \n6 1 \n4 3 \n6 5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2008", "USACO", "队列"], "title": "[USACO08DEC] Winning Checkers G", "background": "", "description": "The cows have taken up the game of checkers with a vengeance.\n\nUnfortunately, despite their unlimited enjoyment of playing, they are terrible at the endgame and want your help.\n\nGiven an NxN (4 <= N <= 500) checkboard, determine the optimal set of moves (i.e., smallest number of moves) to end the game on the next move. Checkers move only on the '+' squares and capture by jumping 'over' an opponent's piece in the traditional way. The piece is removed as soon as it is jumped.  See the example below where N=8:\n\n```cpp\n- + - + - + - +  The K's mark Bessie's kings; the o's represent the \n+ - + - + - + -  opponent's checkers. Bessie always moves next. The \n- + - K - + - +  Kings jump opponent's checkers successively in any \n+ - + - + - + -  diagonal direction (and removes pieces when jumped). \n- o - o - + - + \n+ - K - + - + -  For this board, the best solution requires the lower \n- o - + - + - +  left King to jump successively across all three of the \n+ - K - + - K -  opponents' checkers, thus ending the game (moving K marked as >K<): \nOriginal          After move 1       After move 2        After move 3 \n- + - + - + - +     - + - + - + - +    - + - + - + - +     - + - + - + - + \n+ - + - + - + -     + - + - + - + -    + - + - + - + -     + - + - + - + - \n- + - K - + - +     - + - K - + - +    - + - K - + - +     - + - K - + - + \n+ - + - + - + -     + - + - + - + -    + ->K<- + - + -     + - + - + - + - \n- o - o - + - +     - o - o - + - +    - + - o - + - +     - + - + - + - + \n+ - K - + - + -    >K<- K - + - + -    + - K - + - + -     + - K ->K<- + - \n- o - + - + - +     - + - + - + - +    - + - + - + - +     - + - + - + - + \n+ ->K<- + - K -     + - + - + - K -    + - K - + - K -     + - K - + - K - \n\nThe moves traversed these squares: \n1 2 3 4 5 6 7 8           R C \n1 - + - + - + - +    start: 8 3 \n2 + - + - + - + -    move:  6 1 \n3 - + - K - + - +    move:  4 3 \n4 + - * - + - + -    move:  6 5 \n5 - o - o - + - + \n6 * - K - * - + - \n7 - o - + - + - + \n8 + - K - + - K - \n```\nWrite a program to determine the game-ending sequence for an NxN input board if it exists. There is at least a king and at least one opponent piece on the board. The king can jump a piece on every move of the optimal solution.\n\nPOINTS: 330\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains N characters (each one of: '-', '+', 'K', or 'o') that represent row i of a proper checkboard. Line 2 always begins with '-'.\n", "outputFormat": "\\* Lines 1..?: If there is no winning sequence of jump, output\n\n'impossible' on a line by itself. If such a sequence exists, each line contains two space-separated integers that represent successive locations of a king whose moves will win the game. Any such sequence is acceptable.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO08DEC] Winning Checkers G", "background": "", "description": "The cows have taken up the game of checkers with a vengeance.\n\nUnfortunately, despite their unlimited enjoyment of playing, they are terrible at the endgame and want your help.\n\nGiven an NxN (4 <= N <= 500) checkboard, determine the optimal set of moves (i.e., smallest number of moves) to end the game on the next move. Checkers move only on the '+' squares and capture by jumping 'over' an opponent's piece in the traditional way. The piece is removed as soon as it is jumped.  See the example below where N=8:\n\n```cpp\n- + - + - + - +  The K's mark Bessie's kings; the o's represent the \n+ - + - + - + -  opponent's checkers. Bessie always moves next. The \n- + - K - + - +  Kings jump opponent's checkers successively in any \n+ - + - + - + -  diagonal direction (and removes pieces when jumped). \n- o - o - + - + \n+ - K - + - + -  For this board, the best solution requires the lower \n- o - + - + - +  left King to jump successively across all three of the \n+ - K - + - K -  opponents' checkers, thus ending the game (moving K marked as >K<): \nOriginal          After move 1       After move 2        After move 3 \n- + - + - + - +     - + - + - + - +    - + - + - + - +     - + - + - + - + \n+ - + - + - + -     + - + - + - + -    + - + - + - + -     + - + - + - + - \n- + - K - + - +     - + - K - + - +    - + - K - + - +     - + - K - + - + \n+ - + - + - + -     + - + - + - + -    + ->K<- + - + -     + - + - + - + - \n- o - o - + - +     - o - o - + - +    - + - o - + - +     - + - + - + - + \n+ - K - + - + -    >K<- K - + - + -    + - K - + - + -     + - K ->K<- + - \n- o - + - + - +     - + - + - + - +    - + - + - + - +     - + - + - + - + \n+ ->K<- + - K -     + - + - + - K -    + - K - + - K -     + - K - + - K - \n\nThe moves traversed these squares: \n1 2 3 4 5 6 7 8           R C \n1 - + - + - + - +    start: 8 3 \n2 + - + - + - + -    move:  6 1 \n3 - + - K - + - +    move:  4 3 \n4 + - * - + - + -    move:  6 5 \n5 - o - o - + - + \n6 * - K - * - + - \n7 - o - + - + - + \n8 + - K - + - K - \n```\nWrite a program to determine the game-ending sequence for an NxN input board if it exists. There is at least a king and at least one opponent piece on the board. The king can jump a piece on every move of the optimal solution.\n\nPOINTS: 330\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains N characters (each one of: '-', '+', 'K', or 'o') that represent row i of a proper checkboard. Line 2 always begins with '-'.\n", "outputFormat": "\\* Lines 1..?: If there is no winning sequence of jump, output\n\n'impossible' on a line by itself. If such a sequence exists, each line contains two space-separated integers that represent successive locations of a king whose moves will win the game. Any such sequence is acceptable.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO08DEC] Winning Checkers G", "background": "", "description": "奶牛在激烈地下跳棋。\n\n不幸的是，尽管他们玩得很开心，但他们在最后阶段很艰难，需要你的帮助。\n\n给定一个 $N \\times N(4 \\le N \\le 500)$ 的棋盘，确定帮助贝西“吃”掉**所有对方棋子**的移动次数最少的路径。\n\n移动规则：\n\n1. 沿对角线方向移动。\n\n1. 必须越过对方棋子到达下一个位子。\n\n1. 被越过的对方棋子视为“吃”掉。\n\n1. 贝西只能操控她的其中**1**个国王**连续**移动。\n\n请看下面的例子，其中 $N=8$ ：\n\n1. 对手棋子标记为 o\n\n1. 贝西的国王标记为 K\n\n1. 正在移动的国王标记为 >K<\n\n```\n初始状态             移动一次后          移动两次后           移动三次后\n- + - + - + - +     - + - + - + - +    - + - + - + - +     - + - + - + - + \n+ - + - + - + -     + - + - + - + -    + - + - + - + -     + - + - + - + - \n- + - K - + - +     - + - K - + - +    - + - K - + - +     - + - K - + - + \n+ - + - + - + -     + - + - + - + -    + ->K<- + - + -     + - + - + - + - \n- o - o - + - +     - o - o - + - +    - + - o - + - +     - + - + - + - + \n+ - K - + - + -    >K<- K - + - + -    + - K - + - + -     + - K ->K<- + - \n- o - + - + - +     - + - + - + - +    - + - + - + - +     - + - + - + - + \n+ ->K<- + - K -     + - + - + - K -    + - K - + - K -     + - K - + - K - \n\n这次移动的路径（标记为 * ）：\n\n  1 2 3 4 5 6 7 8          行 列 \n1 - + - + - + - +    起点:  8  3 \n2 + - + - + - + -    路径:  6  1 \n3 - + - K - + - +    路径:  4  3 \n4 + - * - + - + -    路径:  6  5 \n5 - o - o - + - + \n6 * - K - * - + - \n7 - o - + - + - + \n8 + - K - + - K - \n```\n\n编写一个程序来确定贝西的国王的移动路径。棋盘上至少有一个国王和一个对手棋子。", "inputFormat": "第一行有一个整数 $N$。\n\n接下来 $N$ 行是一个 $N \\times N$ 的矩阵，每个字符之间没有空格。", "outputFormat": "若有一条路径，输出每行包含两个空格分隔的整数，表示一位国王的连续位置。\n\n若没有这样的路径,则一行输出\"impossible\"。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2924", "type": "P", "difficulty": 6, "samples": [["6 \n5 5 \n2 3 \n3 2 \n1 5 \n5 1 \n1 1 \n", "5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2008", "USACO", "凸包", "极角排序"], "title": "[USACO08DEC] Largest Fence G", "background": null, "description": "Farmer John 的农场里有 $N$（$5\\le N\\le250$）个篱笆桩，每个都有独一无二的坐标 $(x_i,y_i)$（$1\\le x_i,y_i \\le1000$）。他想选择尽量多的篱笆桩来构建他的围栏。这个围栏要美观，所以必须是凸多边形的。那他最多能选多少个呢？\n\n所有的篱笆桩中不存在三点共线。", "inputFormat": "第一行一个整数 $N$。\n\n接下来的 $N$ 行，每行包含两个整数 $x_i,y_i$，表示第 $i$ 个篱笆桩的坐标。", "outputFormat": "输出一个整数，为构成凸多边形的最大顶点数。", "hint": "样例构成的图形可以理解为一个正方形，其内部有两个点。\n能够围成的最大凸多边形是五边形，其顶点依次为 $(2,3),(3,2),(5,1),(5,5),(1,5)$。\n\n对于 $45\\%$ 的数据，保证 $N\\le 65$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08DEC] Largest Fence G", "background": null, "description": "Farmer John has purchased $N$ ($5 \\le N \\le 250$) fence posts in order to build a very nice-looking fence. Everyone knows the best fences are convex polygons where fence posts form vertices of a polygon. The pasture is represented as a rectilinear grid; fencepost $i$ is at integer coordinates $(x_i, y_i)$ ($1 \\le x_i \\le 1000,1 \\le y_i \\le 1000$).\n\nGiven the locations of $N$ fence posts (which, intriguingly, feature no set of three points which are collinear), what is the largest number of fence posts FJ can use to create a fence that is convex?\n\nFor test cases worth $45\\%$ of the points for this problem, $N \\le 65$.", "inputFormat": "- Line $1$: A single integer: $N$.\n\n- Lines $2\\dots N+1$: Line $i+1$ describes fence post $i$'s location with two space-separated integers: $x_i$ and $y_i$.", "outputFormat": "- Line $1$: A single integer, the maximum possible number of fence posts that form a convex polygon.", "hint": "A square with two points inside.\n\nThe largest convex polygon is the pentagon $(2,3), (3,2), (5,1), (5,5), (1,5)$.", "locale": "en"}, "zh-CN": {"title": "[USACO08DEC] Largest Fence G", "background": null, "description": "Farmer John 的农场里有 $N$（$5\\le N\\le250$）个篱笆桩，每个都有独一无二的坐标 $(x_i,y_i)$（$1\\le x_i,y_i \\le1000$）。他想选择尽量多的篱笆桩来构建他的围栏。这个围栏要美观，所以必须是凸多边形的。那他最多能选多少个呢？\n\n所有的篱笆桩中不存在三点共线。", "inputFormat": "第一行一个整数 $N$。\n\n接下来的 $N$ 行，每行包含两个整数 $x_i,y_i$，表示第 $i$ 个篱笆桩的坐标。", "outputFormat": "输出一个整数，为构成凸多边形的最大顶点数。", "hint": "样例构成的图形可以理解为一个正方形，其内部有两个点。\n能够围成的最大凸多边形是五边形，其顶点依次为 $(2,3),(3,2),(5,1),(5,5),(1,5)$。\n\n对于 $45\\%$ 的数据，保证 $N\\le 65$。", "locale": "zh-CN"}}}
{"pid": "P2925", "type": "P", "difficulty": 2, "samples": [["7 3 \n2 \n6 \n5 \n", "7 \n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "USACO", "背包 DP"], "title": "[USACO08DEC] Hay For Sale S", "background": "", "description": "Farmer John suffered a terrible loss when giant Australian cockroaches ate the entirety of his hay inventory, leaving him with nothing to feed the cows. He hitched up his wagon with capacity $C$ ($1\\le C\\le 50000$) cubic units and sauntered over to Farmer Don's to get some hay before the cows miss a meal.\n\nFarmer Don had a wide variety of $H$ ($1\\le H\\le 5000$) hay bales for sale, each with its own volume ($1\\le V_i\\le C$). Bales of hay, you know, are somewhat flexible and can be jammed into the oddest of spaces in a wagon.\n\nFJ carefully evaluates the volumes so that he can figure out the largest amount of hay he can purchase for his cows.\n\nGiven the volume constraint and a list of bales to buy, what is the greatest volume of hay FJ can purchase?  He can't purchase partial bales, of course. Each input line (after the first) lists a single bale FJ can buy.", "inputFormat": "\\* Line $1$: Two space-separated integers: $C$ and $H$;\n\n\\* Lines $2\\dots H+1$: Each line describes the volume of a single bale: $V_i$.", "outputFormat": "\\* Line $1$: A single integer which is the greatest volume of hay FJ can purchase given the list of bales for sale and constraints.", "hint": "The wagon holds $7$ volumetric units; three bales are offered for sale with volumes of $2$, $6$, and $5$ units, respectively.\n\n\nBuying the two smaller bales fills the wagon.", "locale": "en", "translations": {"en": {"title": "[USACO08DEC] Hay For Sale S", "background": "", "description": "Farmer John suffered a terrible loss when giant Australian cockroaches ate the entirety of his hay inventory, leaving him with nothing to feed the cows. He hitched up his wagon with capacity $C$ ($1\\le C\\le 50000$) cubic units and sauntered over to Farmer Don's to get some hay before the cows miss a meal.\n\nFarmer Don had a wide variety of $H$ ($1\\le H\\le 5000$) hay bales for sale, each with its own volume ($1\\le V_i\\le C$). Bales of hay, you know, are somewhat flexible and can be jammed into the oddest of spaces in a wagon.\n\nFJ carefully evaluates the volumes so that he can figure out the largest amount of hay he can purchase for his cows.\n\nGiven the volume constraint and a list of bales to buy, what is the greatest volume of hay FJ can purchase?  He can't purchase partial bales, of course. Each input line (after the first) lists a single bale FJ can buy.", "inputFormat": "\\* Line $1$: Two space-separated integers: $C$ and $H$;\n\n\\* Lines $2\\dots H+1$: Each line describes the volume of a single bale: $V_i$.", "outputFormat": "\\* Line $1$: A single integer which is the greatest volume of hay FJ can purchase given the list of bales for sale and constraints.", "hint": "The wagon holds $7$ volumetric units; three bales are offered for sale with volumes of $2$, $6$, and $5$ units, respectively.\n\n\nBuying the two smaller bales fills the wagon.", "locale": "en"}, "zh-CN": {"title": "[USACO08DEC] Hay For Sale S", "background": "", "description": "农民 John 面临一个很可怕的事，因为防范力度不大所以他存储的所有稻草都被蟑螂吃光了，他将面临没有稻草喂养奶牛的局面。在奶牛断粮之前，John 拉着他的马车到农民 Don 的农场中买一些稻草给奶牛过冬。已知 John 的马车可以装的下 $C(1\\le C\\le5\\times10^4)$ 立方的稻草。\n\n农民 Don 有 $H(1\\le H\\le5\\times10^3)$ 捆体积不同的稻草可供购买，每一捆稻草有它自己的体积 $V_i(1\\le V_i\\le C)$。面对这些稻草 John 认真的计算如何充分利用马车的空间购买尽量多的稻草给他的奶牛过冬。\n\n现在给定马车的最大容积 $C$ 和每一捆稻草的体积 $V_i$，John 如何在不超过马车最大容积的情况下买到最大体积的稻草？他不可以把一捆稻草分开来买。", "inputFormat": "第一行两个整数，分别为 $C$ 和 $H$。\n第 $2$ 到 $H+1$ 行:每一行一个整数代表第 $i$ 捆稻草的体积 $V_i$。", "outputFormat": "一个整数，为 John 能买到的稻草的体积。\n\n###### 修改 by zhangsenhao6728", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2926", "type": "P", "difficulty": 3, "samples": [["5 \n2 \n1 \n2 \n3 \n4 \n", "2 \n0 \n2 \n1 \n3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO", "素数判断,质数,筛法"], "title": "[USACO08DEC] Patting Heads S", "background": "", "description": "It's Bessie's birthday and time for party games! Bessie has instructed the N (1 <= N <= 100,000) cows conveniently numbered 1..N to sit in a circle (so that cow i [except at the ends] sits next to cows i-1 and i+1; cow N sits next to cow 1). Meanwhile, Farmer John fills a barrel with one billion slips of paper, each containing some integer in the range 1..1,000,000.\n\nEach cow i then draws a number A\\_i (1 <= A\\_i <= 1,000,000) (which is not necessarily unique, of course) from the giant barrel.  Taking turns, each cow i then takes a walk around the circle and pats the heads of all other cows j such that her number A\\_i is exactly\n\ndivisible by cow j's number A\\_j; she then sits again back in her original position.\n\nThe cows would like you to help them determine, for each cow, the number of other cows she should pat.\n\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: A\\_i\n", "outputFormat": "\\* Lines 1..N: On line i, print a single integer that is the number of other cows patted by cow i.\n", "hint": "The 5 cows are given the numbers 2, 1, 2, 3, and 4, respectively.\n\n\nThe first cow pats the second and third cows; the second cows pats no cows; etc.\n", "locale": "en", "translations": {"en": {"title": "[USACO08DEC] Patting Heads S", "background": "", "description": "It's Bessie's birthday and time for party games! Bessie has instructed the N (1 <= N <= 100,000) cows conveniently numbered 1..N to sit in a circle (so that cow i [except at the ends] sits next to cows i-1 and i+1; cow N sits next to cow 1). Meanwhile, Farmer John fills a barrel with one billion slips of paper, each containing some integer in the range 1..1,000,000.\n\nEach cow i then draws a number A\\_i (1 <= A\\_i <= 1,000,000) (which is not necessarily unique, of course) from the giant barrel.  Taking turns, each cow i then takes a walk around the circle and pats the heads of all other cows j such that her number A\\_i is exactly\n\ndivisible by cow j's number A\\_j; she then sits again back in her original position.\n\nThe cows would like you to help them determine, for each cow, the number of other cows she should pat.\n\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: A\\_i\n", "outputFormat": "\\* Lines 1..N: On line i, print a single integer that is the number of other cows patted by cow i.\n", "hint": "The 5 cows are given the numbers 2, 1, 2, 3, and 4, respectively.\n\n\nThe first cow pats the second and third cows; the second cows pats no cows; etc.\n", "locale": "en"}, "zh-CN": {"title": "[USACO08DEC] Patting Heads S", "background": null, "description": "今天是 Bessie 的生日，正是玩派对游戏的好时机！Bessie 指示编号为 $1$ 到 $N$ 的 $N$ 头奶牛（$1 \\le N \\le 100,000$）围成一个圆圈坐下（因此奶牛 $i$ [除了两端] 坐在奶牛 $i-1$ 和 $i+1$ 的旁边；奶牛 $N$ 坐在奶牛 $1$ 的旁边）。与此同时，Farmer John 往一个桶里装了十亿张纸条，每张纸条上都写着一个范围在 $1$ 到 $1,000,000$ 之间的整数。\n\n每头奶牛 $i$ 然后从这个巨大的桶中抽取一个数字 $A_i$（$1 \\le A_i \\le 1,000,000$）（当然，这个数字不一定是唯一的）。轮到每头奶牛 $i$ 时，她会绕着圈走一圈，拍所有其他奶牛 $j$ 的头，只要她的数字 $A_i$ 能被奶牛 $j$ 的数字 $A_j$ 整除；然后她回到原来的位置坐下。\n\n奶牛们希望你帮助她们确定，对于每头奶牛，她应该拍多少下其他奶牛的头。", "inputFormat": "\\* 第 1 行：一个整数： $N$\n\n\\* 第 2 到 $N+1$ 行：第 $i+1$ 行包含一个整数：$A_i$", "outputFormat": "\\* 第 $1$ 到 $N$ 行：在第 $i$ 行，输出一个整数，表示被第 $i$ 头奶牛拍头的其他奶牛的数量。", "hint": "5 头奶牛分别被赋予数字 2、1、2、3 和 4。\n\n\n第一头奶牛拍了第二和第三头奶牛；第二头奶牛没有拍任何奶牛；等等。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2927", "type": "P", "difficulty": 4, "samples": [["2 3 \n1 c d 0 0 \n2 0 d b 0 \n3 c 0 d a \n4 b a b 0 \n5 d 0 0 e \n6 0 0 b e \n", "1 0 c d 0 \n3 0 d a c \n5 0 0 e d \n2 d b 0 0 \n4 a b 0 b \n6 e 0 0 b \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "USACO"], "title": "[USACO08DEC] Jigsaw Puzzles S", "background": null, "description": "奶牛们在玩按字母表顺序排列的拼图谜题。每道谜题是有 $R$（$1 \\le R \\le 10$）列 $C$（$1 \\le C \\le 10$）行的拼图块，它们边缘是由字母或封闭边界组成，完成后的整副拼图外围是边界线，中间的边界是字母。\n\n每块拼图块都有一个序列号和 $4$ 个字母或者数字表示边界线（顺序为上右下左），在输入中，数字充当边界线。\n\n拼图可以换位和旋转，完成后的拼图在边缘的块上靠近外围的是边界线，拼图完成后，一块拼图若与另一块相邻，它们的边界字母必须相同。\n\n现在，奶牛们拿到了一系列拼图块，但由于 FJ 喊他们去吃饭，他们没有时间去拼，于是这个重大的问题就交给了你解决：这个拼图如何拼出来。", "inputFormat": "第一行两个整数 $R$，$C$。\n\n接下来 $R*C$ 行，每行描述一块拼图。", "outputFormat": "共 $R*C$ 行，每行 $5$ 个数字或字母，描述一个拼图，表示它的编号和上、右、下、左的边界线。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "", "background": "", "description": "The cows have taken up alphabetical jigsaw puzzles. In these puzzles with R (1 <= R <= 10) rows and C (1 <= C <= 10) columns, the edges are not funny-shaped cardboard shapes but rather are letters.\n\nEach piece has a serial number and 4 letters (or borders) that must be aligned as in a regular jigsaw puzzle. The pseudo-letter '0' (the digit 0) will represent a border (and a piece can have several borders if it is a corner piece or even the top of column in a, e.g., 4x1 puzzle).  Below is a set of six pieces (the borders are marked with lines instead of '0's) assembled in one way (of many) that completes the puzzle:\n\n+---+  +---+  +---+\n\n| 1 c  c 3 d  d 5 | \n+-d-+  + a +  +-e-+\n\n+-d-+  +-a-+  +-e-+\n\n| 2 b  b 4 b  b 6 | \n+---+  +---+  +---+\n\nNote that each edge letter of each piece matches the border letter of the piece adjacent to it; the borders appear properly on the top, bottom, and sides.\n\nPieces are represented by a serial number and a clockwise list of their four edges (where edges are the letters a..z and 0). Pieces might require rotation when placed in the puzzle.\n\nGiven a set of pieces, find at least one way to assemble them into a puzzle. Test data for puzzles with larger R and C are easier to solve because they have a more varied set of edge letters.\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: R and C\n\n\\* Lines 2..R\\*C+1: Each line contains five space-separated entities: an integer serial number and four edge identifiers\n", "outputFormat": "\\* Lines 1..R\\*C: Line R\\*(i-1)+j describes the puzzle piece placed a row i, column j with an integer and five space-separated entities: the serial number of the puzzle piece and the four piece edge identifiers in the order top, right, bottom, left.\n", "hint": "Describes the input puzzle although with some of the pieces rotated compared to the sample solution.\n\n\nAs shown in the diagram in the task text. Other solutions (like reflections) are possible; a grading program will check your answer.\n", "locale": "en"}, "zh-CN": {"title": "[USACO08DEC] Jigsaw Puzzles S", "background": null, "description": "奶牛们在玩按字母表顺序排列的拼图谜题。每道谜题是有 $R$（$1 \\le R \\le 10$）列 $C$（$1 \\le C \\le 10$）行的拼图块，它们边缘是由字母或封闭边界组成，完成后的整副拼图外围是边界线，中间的边界是字母。\n\n每块拼图块都有一个序列号和 $4$ 个字母或者数字表示边界线（顺序为上右下左），在输入中，数字充当边界线。\n\n拼图可以换位和旋转，完成后的拼图在边缘的块上靠近外围的是边界线，拼图完成后，一块拼图若与另一块相邻，它们的边界字母必须相同。\n\n现在，奶牛们拿到了一系列拼图块，但由于 FJ 喊他们去吃饭，他们没有时间去拼，于是这个重大的问题就交给了你解决：这个拼图如何拼出来。", "inputFormat": "第一行两个整数 $R$，$C$。\n\n接下来 $R*C$ 行，每行描述一块拼图。", "outputFormat": "共 $R*C$ 行，每行 $5$ 个数字或字母，描述一个拼图，表示它的编号和上、右、下、左的边界线。", "hint": null, "locale": "zh-CN"}}}
