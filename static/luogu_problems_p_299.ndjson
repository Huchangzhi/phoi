{"pid": "P7050", "type": "P", "difficulty": 3, "samples": [["cat\ndog\n", "9\n"], ["tree\nheap\n", "14\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Concatenation", "background": "", "description": "\n\nFamous programmer Gennady likes to create new words. One way to do it is to concatenate existing words. That means writing one word after another. For example, if he has words `cat` and `dog`, he would get a word `catdog`, that could mean something like the name of a creature with two heads: one cat head and one dog head.\n\nGennady is a bit bored of this way of creating new words, so he has invented another method. He takes a non-empty prefix of the first word, a non-empty suffix of the second word, and concatenates them. For example, if he has words `tree` and `heap`, he can get such words as `treap`, `tap`, or `theap`. Who knows what they could mean?\n\nGennady chooses two words and wants to know how many different words he can create using his new method. Of course, being a famous programmer, he has already calculated the answer. Can you do the same?\n\n", "inputFormat": "\n\nTwo lines of the input file contain words chosen by Gennady. They have lengths between $1$ and $100 000$ characters and consist of lowercase English letters only.\n\n", "outputFormat": "\n\nOutput one integer -- the number of different words Gennady can create out of words given in the input file.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Concatenation", "background": "", "description": "\n\nFamous programmer Gennady likes to create new words. One way to do it is to concatenate existing words. That means writing one word after another. For example, if he has words `cat` and `dog`, he would get a word `catdog`, that could mean something like the name of a creature with two heads: one cat head and one dog head.\n\nGennady is a bit bored of this way of creating new words, so he has invented another method. He takes a non-empty prefix of the first word, a non-empty suffix of the second word, and concatenates them. For example, if he has words `tree` and `heap`, he can get such words as `treap`, `tap`, or `theap`. Who knows what they could mean?\n\nGennady chooses two words and wants to know how many different words he can create using his new method. Of course, being a famous programmer, he has already calculated the answer. Can you do the same?\n\n", "inputFormat": "\n\nTwo lines of the input file contain words chosen by Gennady. They have lengths between $1$ and $100 000$ characters and consist of lowercase English letters only.\n\n", "outputFormat": "\n\nOutput one integer -- the number of different words Gennady can create out of words given in the input file.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Concatenation", "background": "", "description": "著名的程序员 Gennady 喜欢创造新单词。其中一种方法是连接现有单词。\n\n举个例子：如果 Gennady 有 `cat` 和 `dog` 两个词，那么他会得到一个新词： `catdog`，这可能意味着带有两个头的生物的名字：一个猫头和一个狗头。\n\nGennady 觉得这种创建新单词的方式有点无聊，因此他发明了另一种方法：使用第一个单词的非空前缀，第二个单词的非空后缀，并将它们连接起来。例如，如果他有单词 `tree` 和 `heap` ，则可以得到诸如 `treap`，`tap` 或 `theap` 之类的单词。\n\nGennady 选择了两个单词，并想知道他可以使用新方法创建多少个不同的单词。当然，作为著名的程序员，他已经计算出了答案。他突然想考考你，那么你能编写一个程序把答案计算出来吗？", "inputFormat": "两行，每行有一个 Gennady 选择的单词 $s_i$ （$1\\leq |s_i| \\leq 100000$，$s_i$ 仅由小写英文字母组成）。", "outputFormat": "输出一个整数，这个整数表示 Gennady 可以从这两个给定的单词中创建不同单词的数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7051", "type": "P", "difficulty": 3, "samples": [["4\n1\n2\n3\n10\n", "1\n1\n1\n2\n1\n3\n2\n4 6\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Distribution in Metagonia", "background": "", "description": "\n\nThere are one hundred noble families in the country of Metagonia, and each year some of these families receive several ritual cubes from the Seer of the One. The One has several rules about cube distribution: if a family receives at least one cube, every prime divisor of the number of cubes received should be either $2$ or $3$ , moreover if one family receives a $> 0$ cubes and another family in the same year receives $b > 0$ cubes then a should not be divisible by $b$ and vice versa.\n\nYou are the Seer of the One. You know in advance how many cubes would be available for distribution for the next $t$ years. You want to find any valid distribution of cubes for each of these years. Each year you have to distribute all cubes available for that year.\n\n", "inputFormat": "\n\nThe first line of input file contains a single integer $t$ -- the number of years to come $(1 \\le t \\le 1000)$ . Each of the following $t$ lines contains a single integer $n_{i}$ -- the number of cubes to distribute in i-th year $(1 \\le n_{i} \\le 10^{18}).$\n\n", "outputFormat": "\n\nFor each year $i$ output two lines. The first line should contain $m_{i}$ -- the number of families that would receive at least one cube in i-th year $(1 \\le m_{i} \\le 100)$ . The second line should contain $m_{i}$ integers -- the number of cubes received by each family. The sum of these numbers should be equal to $n_{i}.$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Distribution in Metagonia", "background": "", "description": "\n\nThere are one hundred noble families in the country of Metagonia, and each year some of these families receive several ritual cubes from the Seer of the One. The One has several rules about cube distribution: if a family receives at least one cube, every prime divisor of the number of cubes received should be either $2$ or $3$ , moreover if one family receives a $> 0$ cubes and another family in the same year receives $b > 0$ cubes then a should not be divisible by $b$ and vice versa.\n\nYou are the Seer of the One. You know in advance how many cubes would be available for distribution for the next $t$ years. You want to find any valid distribution of cubes for each of these years. Each year you have to distribute all cubes available for that year.\n\n", "inputFormat": "\n\nThe first line of input file contains a single integer $t$ -- the number of years to come $(1 \\le t \\le 1000)$ . Each of the following $t$ lines contains a single integer $n_{i}$ -- the number of cubes to distribute in i-th year $(1 \\le n_{i} \\le 10^{18}).$\n\n", "outputFormat": "\n\nFor each year $i$ output two lines. The first line should contain $m_{i}$ -- the number of families that would receive at least one cube in i-th year $(1 \\le m_{i} \\le 100)$ . The second line should contain $m_{i}$ integers -- the number of cubes received by each family. The sum of these numbers should be equal to $n_{i}.$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Distribution in Metagonia", "background": "", "description": "在梅塔戈尼亚国有一百个贵族家庭，每年这些家庭中的一些会从“唯一者”的先知那里收到几个仪式立方体。“唯一者”对立方体的分配有几个规则：如果一个家庭收到至少一个立方体，那么收到的立方体数量的所有质因数应该是 $2$ 或 $3$。此外，如果一个家庭收到 $a > 0$ 个立方体，而同一年另一个家庭收到 $b > 0$ 个立方体，那么 $a$ 不应该能被 $b$ 整除，反之亦然。\n\n你是“唯一者”的先知。你提前知道未来 $t$ 年将有多少立方体可供分配。你想为这些年中的每一年找到任何有效的立方体分配方案。每年你必须分配掉该年所有可用的立方体。", "inputFormat": "输入文件的第一行包含一个整数 $t$ —— 即将到来的年份数 $(1 \\le t \\le 1000)$。接下来的 $t$ 行中的每一行包含一个整数 $n_{i}$ —— 在第 $i$ 年要分配的立方体数量 $(1 \\le n_{i} \\le 10^{18})$。", "outputFormat": "对于每一年 $i$ 输出两行。第一行应包含 $m_{i}$ —— 在第 $i$ 年至少收到一个立方体的家庭数量 $(1 \\le m_{i} \\le 100)$。第二行应包含 $m_{i}$ 个整数 —— 每个家庭收到的立方体数量。这些数字的总和应等于 $n_{i}$。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7052", "type": "P", "difficulty": 2, "samples": [["10+20-30\n", "10+20-3+0\n"], ["-3-4-1\n", "-3-4-1\n"], ["+10\n", "+10\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["字符串", "2015", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Easy Arithmetic", "background": "", "description": "\n\nEva is a third-grade elementary school student. She has just learned how to perform addition and subtraction of arbitrary-precision integers. Her homework is to evaluate some expressions. It is boring, so she decided to add a little trick to the homework. Eva wants to add some plus and minus signs to the expression to make its value as large as possible.\n\n", "inputFormat": "\n\nThe single line of the input file contains the original arithmetic expression. It contains only digits, plus $(‘+')$ and minus $(‘-')$ signs.\n\nThe original expression is correct, that is:\n\nnumbers have no leading zeroes;\n\nthere are no two consecutive signs;\n\nthe last character of the expression is a digit.\n\nThe length of the original expression does not exceed $1000$ characters.\n\n", "outputFormat": "\n\nOutput a single line -- the original expression with some plus and minus signs added. Output expression must satisfy the same correctness constraints as the original one. Its value must be as large as possible.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Easy Arithmetic", "background": "", "description": "\n\nEva is a third-grade elementary school student. She has just learned how to perform addition and subtraction of arbitrary-precision integers. Her homework is to evaluate some expressions. It is boring, so she decided to add a little trick to the homework. Eva wants to add some plus and minus signs to the expression to make its value as large as possible.\n\n", "inputFormat": "\n\nThe single line of the input file contains the original arithmetic expression. It contains only digits, plus $(‘+')$ and minus $(‘-')$ signs.\n\nThe original expression is correct, that is:\n\nnumbers have no leading zeroes;\n\nthere are no two consecutive signs;\n\nthe last character of the expression is a digit.\n\nThe length of the original expression does not exceed $1000$ characters.\n\n", "outputFormat": "\n\nOutput a single line -- the original expression with some plus and minus signs added. Output expression must satisfy the same correctness constraints as the original one. Its value must be as large as possible.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Easy Arithmetic", "background": "", "description": "Eva 是一名三年级的小学生。她刚刚学会了如何进行任意精度整数的加减法。她的作业是计算一些表达式。这很无聊，所以她决定在作业中增加一点小技巧。Eva 想在表达式中添加一些加号和减号，使其值尽可能大。", "inputFormat": "输入文件的单行包含原始算术表达式。它只包含数字、加号（‘+’）和减号（‘-’）符号。\n\n原始表达式是正确的，即：\n\n数字没有前导零；\n\n没有两个连续的符号；\n\n表达式的最后一个字符是数字。\n\n原始表达式的长度不超过 1000 个字符。", "outputFormat": "输出一行——在原始表达式中添加了一些加号和减号。输出的表达式必须满足与原始表达式相同的正确性约束。其值必须尽可能大。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7053", "type": "P", "difficulty": 5, "samples": [["for i in range(n):\n    for j in range(i):\n        lag\nfor x in range(5):\n    for y in range(n):\n        for z in range(n):\n            lag\n    lag\n", "1/2 * n * (n-1) + 5 * (n*n + 1)\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Fygon", "background": "", "description": "\n\nFrederick is a young programmer. He participates in all programming contests he can find and always uses his favorite programming language Fygon. Unfortunately, he often receives Time Limit Exceeded outcome, even when his algorithm is asymptotically optimal. That's because the Fygon interpreter is very slow. Nevertheless, Frederick likes Fygon so much, that he uses non-asymptotical optimizations to fit the solution into time limit. To make it easier, he asks you to write a program, which will be able to estimate the exact number of operations that his Fygon program makes.\n\nFor simplicity, we will assume that Fygon has only two statements. The first statement is lag. It substitutes almost any other statement. The second statement is a for loop:\n\nfor in range $():$\n\nThis means that iterates over values from $0$ to $−1$ . In Fygon is a lowercase letter from a to $z$ , and is either already defined or a positive integer constant. The of the loop is indented by four spaces and contains at least one statement.\n\nThe program receives the input in the variable $n$ . This variable has special meaning and cannot be used as a loop variable.\n\nYour task is to find the formula that calculates the number of performed lag operations by the given Fygon program, depending on the value of the variable $n$ .\n\n", "inputFormat": "\n\nThe input file contains the Fygon program. No two loops use the same variable as iterators. Each variable used inside a range is either $n$ or declared in some outer loop.\n\nThe program has at most $20$ statements and at most $6$ of them are loops. All integer constants are from $1$ to $9$ . Outpu\n\n", "outputFormat": "\n\nOutput the formula for the number of performed lag operations depending on $n$ . The length of the formula should be at most $100$ characters (excluding spaces). The formula should correspond to the following grammar:\n\n$〈Expressio_n〉 ::= 〈Product〉 ( (‘+' | ‘-') 〈Product〉) ^{ \\times }$\n\n$〈Product〉 ::= 〈Value〉 (‘ \\times '〈Value〉) ^{ \\times }$\n\n$〈Value〉 ::= ‘n' | 〈Number〉 | ‘-'〈Value〉 | ‘('〈Expressio_n〉‘)'$\n\n$〈Number〉 ::= [‘0' \\cdots ‘9'] ^{+} (‘/' [‘0' \\cdots ‘9'] ^{+}) ^{?}$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Fygon", "background": "", "description": "\n\nFrederick is a young programmer. He participates in all programming contests he can find and always uses his favorite programming language Fygon. Unfortunately, he often receives Time Limit Exceeded outcome, even when his algorithm is asymptotically optimal. That's because the Fygon interpreter is very slow. Nevertheless, Frederick likes Fygon so much, that he uses non-asymptotical optimizations to fit the solution into time limit. To make it easier, he asks you to write a program, which will be able to estimate the exact number of operations that his Fygon program makes.\n\nFor simplicity, we will assume that Fygon has only two statements. The first statement is lag. It substitutes almost any other statement. The second statement is a for loop:\n\nfor in range $():$\n\nThis means that iterates over values from $0$ to $−1$ . In Fygon is a lowercase letter from a to $z$ , and is either already defined or a positive integer constant. The of the loop is indented by four spaces and contains at least one statement.\n\nThe program receives the input in the variable $n$ . This variable has special meaning and cannot be used as a loop variable.\n\nYour task is to find the formula that calculates the number of performed lag operations by the given Fygon program, depending on the value of the variable $n$ .\n\n", "inputFormat": "\n\nThe input file contains the Fygon program. No two loops use the same variable as iterators. Each variable used inside a range is either $n$ or declared in some outer loop.\n\nThe program has at most $20$ statements and at most $6$ of them are loops. All integer constants are from $1$ to $9$ . Outpu\n\n", "outputFormat": "\n\nOutput the formula for the number of performed lag operations depending on $n$ . The length of the formula should be at most $100$ characters (excluding spaces). The formula should correspond to the following grammar:\n\n$〈Expressio_n〉 ::= 〈Product〉 ( (‘+' | ‘-') 〈Product〉) ^{ \\times }$\n\n$〈Product〉 ::= 〈Value〉 (‘ \\times '〈Value〉) ^{ \\times }$\n\n$〈Value〉 ::= ‘n' | 〈Number〉 | ‘-'〈Value〉 | ‘('〈Expressio_n〉‘)'$\n\n$〈Number〉 ::= [‘0' \\cdots ‘9'] ^{+} (‘/' [‘0' \\cdots ‘9'] ^{+}) ^{?}$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Fygon", "background": "", "description": "# [NWRRC2015] Fygon 翻译\n\n\n弗雷德里克是一名年轻的程序员。他参加了所有能找到的编程比赛，并总是使用他最喜欢的编程语言 Fygon。不幸的是，他经常收到 \"超过时间限制 \"的结果，即使他的算法是渐近最优的。这是因为 Fygon 解释器非常慢。尽管如此，弗雷德里克还是非常喜欢 Fygon，所以他使用了非渐进优化的方法来使求解符合时间限制。为了方便起见，他要求你写一个程序，能够估算出他的 Fygon 程序所做的确切操作次数。\n\n为了简单起见，我们假设 Fygon 只有两条语句。第一条语句是滞后的。它几乎可以替代任何其他语句。第二条语句是 for 循环：\n\nfor in range $():$\n\n这意味着遍历从 $0$ 到 $-1$ 的值。 在 Fygon 中是从 $a$ 到 $z$ 的小写字母，并且要么是已经定义的，要么是正整数常数。循环语句缩进四个空格，至少包含一条语句。\n\n程序接收变量 $n$ 的输入。该变量具有特殊含义，不能用作循环变量。您的任务是根据变量 $n$ 的值，找出计算 Fygon 程序执行滞后操作次数的公式。", "inputFormat": "输入文件包含 Fygon 程序。没有两个循环使用相同的变量作为迭代器。范围内使用的每个变量要么是 $n$，要么是在某个外循环中声明的。\n\n程序最多有 $20$ 语句，其中最多有 $6$ 是循环。所有整数常量从 $1$ 到 $9$ 不等。", "outputFormat": "根据 $n$ 输出已执行滞后运算次数的公式。公式长度最多为 $100$ 字符（不包括空格）。公式应符合以下语法：\n\n$〈表达式〉 ::= 〈产物〉 ( (‘+' | ‘-') 〈产物〉) ^{ \\times }$\n\n$〈产物〉 ::= 〈价值〉 (‘ \\times '〈价值〉) ^{ \\times }$\n\n$〈价值〉 ::= ‘n' | 〈数〉 | ‘-'〈价值〉 | ‘('〈表达式〉‘)'$\n\n$〈数〉 ::= [‘0' \\cdots ‘9'] ^{+} (‘/' [‘0' \\cdots ‘9'] ^{+}) ^{?}$\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\nfor i in range(n):\n    for j in range(i):\n        lag\nfor x in range(5):\n    for y in range(n):\n        for z in range(n):\n            lag\n    lag\n```\n\n### 样例输出 #1\n\n```\n1/2 * n * (n-1) + 5 * (n*n + 1)\n```", "hint": "时间限制：2 秒，内存限制：256 MB。", "locale": "zh-CN"}}}
{"pid": "P7054", "type": "P", "difficulty": 7, "samples": [["5 3 2\n1 4\n4 2\n1 3\n", "5 1 4 2 3\n2\n4 3\n5 1\n"], ["2 2 20\n1 2\n1 2\n", "1 2\n1\n1 2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "堆", "Special Judge", "拓扑排序", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Graph", "background": "", "description": "\n\nThe sequence $a_{1}, a_{2},$ . . . , $a_{n}$ is called a permutation, if it contains every integer from $1$ to $n$ .\n\nThe permutation of vertices $a_{1}, a_{2},$ . . . , $a_{n}$ is a topological sort of a directed graph, if for every directed edge from $u$ to $v$ , vertex $u$ comes before $v$ in this permutation.\n\nThe permutation $a_{1}, a_{2},$ . . . , $a_{n}$ is lexicographically smaller than the permutation $b_{1}, b_{2},$ . . . , $b_{n},$ if there exists $m$ such that $a_{i} = b_{i}$ for every $1 \\le i < m$ and $a_{m} < b_{m}.$\n\nGiven a directed acyclic graph, add at most $k$ directed edges to it in such a way, that the resulting graph still has no cycles and the lexicographically minimal topological sort of the graph is maximum possible.\n\n", "inputFormat": "\n\nThe first line of the input file contains three integers $n , m$ and $k$ -- the number of vertices and directed edges in the original graph, and the number of directed edges, that you are allowed to add $(1 \\le n \\le 100 000$ ; $0 \\le m , k \\le 100 000)$ .\n\nEach of the following $m$ lines contains two integers $u_{i}, v_{i},$ describing directed edge from $u_{i}$ to $v_{i} (1 \\le u_{i}, v_{i} \\le n)$ .\n\nThe graph has no cycles.\n\n", "outputFormat": "\n\nThe first line of the output file should contain $n$ integers -- the lexicographically minimal topological sort of the modified graph. The second line should contain a single integer $x (0 \\le x \\le k)$ -- the number of directed edges to add. The following $x$ lines of the output should contain description of added directed edges in the same format as in the input file.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Graph", "background": "", "description": "\n\nThe sequence $a_{1}, a_{2},$ . . . , $a_{n}$ is called a permutation, if it contains every integer from $1$ to $n$ .\n\nThe permutation of vertices $a_{1}, a_{2},$ . . . , $a_{n}$ is a topological sort of a directed graph, if for every directed edge from $u$ to $v$ , vertex $u$ comes before $v$ in this permutation.\n\nThe permutation $a_{1}, a_{2},$ . . . , $a_{n}$ is lexicographically smaller than the permutation $b_{1}, b_{2},$ . . . , $b_{n},$ if there exists $m$ such that $a_{i} = b_{i}$ for every $1 \\le i < m$ and $a_{m} < b_{m}.$\n\nGiven a directed acyclic graph, add at most $k$ directed edges to it in such a way, that the resulting graph still has no cycles and the lexicographically minimal topological sort of the graph is maximum possible.\n\n", "inputFormat": "\n\nThe first line of the input file contains three integers $n , m$ and $k$ -- the number of vertices and directed edges in the original graph, and the number of directed edges, that you are allowed to add $(1 \\le n \\le 100 000$ ; $0 \\le m , k \\le 100 000)$ .\n\nEach of the following $m$ lines contains two integers $u_{i}, v_{i},$ describing directed edge from $u_{i}$ to $v_{i} (1 \\le u_{i}, v_{i} \\le n)$ .\n\nThe graph has no cycles.\n\n", "outputFormat": "\n\nThe first line of the output file should contain $n$ integers -- the lexicographically minimal topological sort of the modified graph. The second line should contain a single integer $x (0 \\le x \\le k)$ -- the number of directed edges to add. The following $x$ lines of the output should contain description of added directed edges in the same format as in the input file.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Graph", "background": "", "description": "序列 $a_{1}, a_{2}, \\ldots, a_{n}$ 被称为一个排列，如果它包含从 $1$ 到 $n$ 的每一个整数。\n\n如果顶点的排列 $a_{1}, a_{2}, \\ldots, a_{n}$ 是一个有向图的拓扑排序，那么对于每一条从 $u$ 到 $v$ 的有向边，顶点 $u$ 在这个排列中出现在 $v$ 之前。\n\n排列 $a_{1}, a_{2}, \\ldots, a_{n}$ 在字典序上小于排列 $b_{1}, b_{2}, \\ldots, b_{n}$，如果存在某个 $m$ 使得对于每一个 $1 \\le i < m$，都有 $a_{i} = b_{i}$，并且 $a_{m} < b_{m}$。\n\n给定一个有向无环图，最多添加 $k$ 条有向边，使得结果图仍然没有环，并且图的字典序最小的拓扑排序尽可能大。", "inputFormat": "输入文件的第一行包含三个整数 $n, m$ 和 $k$ —— 原始图中的顶点数和有向边数，以及允许添加的有向边数 $(1 \\le n \\le 100 000; 0 \\le m, k \\le 100 000)$。\n\n接下来的 $m$ 行中的每一行包含两个整数 $u_{i}, v_{i}$，描述从 $u_{i}$ 到 $v_{i}$ 的有向边 $(1 \\le u_{i}, v_{i} \\le n)$。\n\n图中没有环。", "outputFormat": "输出文件的第一行应包含 $n$ 个整数 —— 修改后的图的字典序最小的拓扑排序。第二行应包含一个整数 $x (0 \\le x \\le k)$ —— 添加的有向边的数量。接下来的 $x$ 行应包含添加的有向边的描述，格式与输入文件相同。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7055", "type": "P", "difficulty": 2, "samples": [["4\n", "edHs\nmENAGeS\nfEHs\nedIT\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["字符串", "2015", "Special Judge", "哈希 hashing", "构造", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Hash Code Hacker", "background": "", "description": "\n\nAccording to Java standard library documentation, the hash code of String is computed as\n\n$s[0] \\times 31 ^ {n -1} + s[1] \\times 31 ^ {n -2} + \\cdots + s[n -1]$\n\nHere $s[i]$ is the i-th character of the string, $n$ is the length of the string, and $^$ indicates exponentiation. Computation uses signed $32-bit$ integers in two's complement form.\n\nHeather is going to hack the servers of Not Entirely Evil Recording Company $(NEERC).$ To perform an attack she needs $k$ distinct query strings that have equal hash codes. Unfortunately, NEERC servers accept query string containing lower- and uppercase English letters only.\n\nHeather hired you to write a program that generates such query strings for her.\n\n", "inputFormat": "\n\nThe single line of the input file contains integer $k$ -- the number of required query strings to generate $(2 \\le k \\le 1000)$ .\n\n", "outputFormat": "\n\nOutput $k$ lines. Each line should contain a single query string. Each query string should be non-empty and its length should not exceed $1000$ characters. Query string should contain only lower- and uppercase English letters. All query strings should be distinct and should have equal hash codes.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Hash Code Hacker", "background": "", "description": "\n\nAccording to Java standard library documentation, the hash code of String is computed as\n\n$s[0] \\times 31 ^ {n -1} + s[1] \\times 31 ^ {n -2} + \\cdots + s[n -1]$\n\nHere $s[i]$ is the i-th character of the string, $n$ is the length of the string, and $^$ indicates exponentiation. Computation uses signed $32-bit$ integers in two's complement form.\n\nHeather is going to hack the servers of Not Entirely Evil Recording Company $(NEERC).$ To perform an attack she needs $k$ distinct query strings that have equal hash codes. Unfortunately, NEERC servers accept query string containing lower- and uppercase English letters only.\n\nHeather hired you to write a program that generates such query strings for her.\n\n", "inputFormat": "\n\nThe single line of the input file contains integer $k$ -- the number of required query strings to generate $(2 \\le k \\le 1000)$ .\n\n", "outputFormat": "\n\nOutput $k$ lines. Each line should contain a single query string. Each query string should be non-empty and its length should not exceed $1000$ characters. Query string should contain only lower- and uppercase English letters. All query strings should be distinct and should have equal hash codes.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Hash Code Hacker", "background": null, "description": "根据 Java 标准库文档，字符串的哈希码计算如下：\n\n$$s[0] \\times 31 ^ {n -1} + s[1] \\times 31 ^ {n -2} + \\cdots + s[n -1]$$\n\n其中 $s[i]$ 是字符串的第 $i$ 个字符，$n$ 是字符串的长度，`^` 表示指数运算。计算使用的是二进制补码形式的有符号 $32$ 位整数。\n\nHeather 准备入侵 Not Entirely Evil Recording Company (NEERC) 的服务器。为了进行攻击，她需要 $k$ 个具有相同哈希码的不同查询字符串。不幸的是，NEERC 服务器只接受包含大小写英文字符的查询字符串。\n\nHeather 雇佣你编写一个程序，为她生成这样的查询字符串。", "inputFormat": "输入文件的单行包含整数 $k$ —— 需要生成的查询字符串数量 $(2 \\le k \\le 1000)$。", "outputFormat": "输出 $k$ 行。每行应包含一个查询字符串。每个查询字符串应为非空，且长度不超过 $1000$ 个字符。查询字符串应仅包含大小写英文字符。所有查询字符串应不同且具有相同的哈希码。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7056", "type": "P", "difficulty": 7, "samples": [["4 3\n1 2 3\n1 2 3\n1 4 3\n", "4 3 2 1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Insider's Information", "background": "", "description": "\n\nIan works for a rating agency that publishes ratings of the best universities. Irene is a journalist who plans to write a scandalous article about the upcoming rating.\n\nUsing various social engineering techniques (let's not get into more details), Irene received some insider's information from Ian.\n\nSpecifically, Irene received several triples $(a_{i}, b_{i}, c_{i}),$ meaning that in the upcoming rating, university $b_{i}$ stands between universities $a_{i}$ and $c_{i}.$ That is, either $a_{i}$ comes before $b_{i}$ which comes before $c_{i},$ or the opposite. All triples told by Ian are consistent -- let's say that actual rating satisfies them all.\n\nTo start working on the first draft of the future article, Irene needs to see at least some approximation to the actual rating. She asked you to find a proposal of a rating in which at least half of the triples known by Irene are satisfied.\n\n", "inputFormat": "\n\nThe first line contains integers $n$ and $m$ , the number of rated universities, and the number of triples given to Irene by Ian $(3 \\le n \\le 100 000$ ; $1 \\le m \\le 100 000)$ .\n\nEach of the next $m$ lines contains three distinct integers $a_{i}, b_{i}, c_{i}$ -- the universities making a triple $(1 \\le a_{i}, b_{i}, c_{i} \\le n)$ .\n\n", "outputFormat": "\n\nOutput the proposal of a rating from the first university to the last one. The proposal rating should satisfy at least $m/2$ triples. If there are many such proposals, output any one of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Insider's Information", "background": "", "description": "\n\nIan works for a rating agency that publishes ratings of the best universities. Irene is a journalist who plans to write a scandalous article about the upcoming rating.\n\nUsing various social engineering techniques (let's not get into more details), Irene received some insider's information from Ian.\n\nSpecifically, Irene received several triples $(a_{i}, b_{i}, c_{i}),$ meaning that in the upcoming rating, university $b_{i}$ stands between universities $a_{i}$ and $c_{i}.$ That is, either $a_{i}$ comes before $b_{i}$ which comes before $c_{i},$ or the opposite. All triples told by Ian are consistent -- let's say that actual rating satisfies them all.\n\nTo start working on the first draft of the future article, Irene needs to see at least some approximation to the actual rating. She asked you to find a proposal of a rating in which at least half of the triples known by Irene are satisfied.\n\n", "inputFormat": "\n\nThe first line contains integers $n$ and $m$ , the number of rated universities, and the number of triples given to Irene by Ian $(3 \\le n \\le 100 000$ ; $1 \\le m \\le 100 000)$ .\n\nEach of the next $m$ lines contains three distinct integers $a_{i}, b_{i}, c_{i}$ -- the universities making a triple $(1 \\le a_{i}, b_{i}, c_{i} \\le n)$ .\n\n", "outputFormat": "\n\nOutput the proposal of a rating from the first university to the last one. The proposal rating should satisfy at least $m/2$ triples. If there are many such proposals, output any one of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Insider's Information", "background": "", "description": "伊恩在一家评级机构工作，该机构发布最佳大学的评级。艾琳是一名记者，计划撰写一篇关于即将发布的评级的轰动性文章。\n\n通过各种社会工程技术（我们不深入细节），艾琳从伊恩那里获得了一些内部信息。\n\n具体来说，艾琳收到了几个三元组 $(a_{i}, b_{i}, c_{i})$，这意味着在即将发布的评级中，大学 $b_{i}$ 位于大学 $a_{i}$ 和 $c_{i}$ 之间。也就是说，要么 $a_{i}$ 在 $b_{i}$ 之前，$b_{i}$ 在 $c_{i}$ 之前，要么相反。伊恩提供的所有三元组都是一致的——假设实际评级满足它们。\n\n为了开始撰写未来文章的初稿，艾琳需要看到至少某种对实际评级的近似。她要求你找到一个评级提案，其中至少有一半的艾琳已知的三元组得到满足。", "inputFormat": "第一行包含整数 $n$ 和 $m$，分别表示被评级的大学数量和伊恩给艾琳的三元组数量 $(3 \\le n \\le 100 000$；$1 \\le m \\le 100 000)$。\n\n接下来的 $m$ 行中的每一行包含三个不同的整数 $a_{i}, b_{i}, c_{i}$——构成一个三元组的大学 $(1 \\le a_{i}, b_{i}, c_{i} \\le n)$。", "outputFormat": "输出从第一所大学到最后一所大学的评级提案。该提案评级应满足至少 $m/2$ 个三元组。如果有多个这样的提案，输出其中任意一个。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7057", "type": "P", "difficulty": 4, "samples": [["4 4\n1 2 3\n1 4\n", "2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2015", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Journey to the “The World’s Start”", "background": "", "description": "\n\nJerry Prince is the fourth grade student and he goes to New-Lodnon to visit the most popular amusement park `The World's Start`.\n\nAn airport he arrives at is next to the first stop of the metro line. This line has $n$ stops and `The World's Start` is on the last of them. The metro of New-Lodnon is pretty fast so you may assume that you can get from a stop to the next one in just one minute.\n\nJerry needs a travel card to use the metro. Each travel card has a range $r$ and a price $p$ . With a travel card of range $r$ Jerry may travel no more than $r$ stops at once. Therefore, if Jerry enters metro at the stop $i$ he should exit on one of the stops from $i − r$ to $i + r$ inclusive. It takes $d_{i}$ minutes to exit and reenter metro at i-th stop. There is no time required to enter the first stop or exit the last one.\n\nJerry is not very rich but he has some spare time, so he decided to buy the cheapest travel card that will allow him to travel from the first metro stop to the last one in no more than $t$ minutes.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $t$ -- the number of stops and the maximum possible time $(2 \\le n \\le 50 000$ ; $n - 1 \\le t \\le 10^{9}).$\n\nThe second line contains $n - 1$ integers $p_{r}$ -- the prices of travel cards with range $r = 1$ . . . $n − 1 (1 \\le p_{r} \\le 100 000)$\n\nThe third line contains $n - 2$ integers $d_{i}$ -- the number of minutes required to reenter metro at stop $i = 2$ . . . $n - 1 (1 \\le d_{i} \\le 10^{5}).$\n\n", "outputFormat": "\n\nOutput a single integer $p$ -- the lowest possible price of one travel card that allows Jerry to travel from the first to the last stop in no more than $t$ minutes.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Journey to the “The World’s Start”", "background": "", "description": "\n\nJerry Prince is the fourth grade student and he goes to New-Lodnon to visit the most popular amusement park `The World's Start`.\n\nAn airport he arrives at is next to the first stop of the metro line. This line has $n$ stops and `The World's Start` is on the last of them. The metro of New-Lodnon is pretty fast so you may assume that you can get from a stop to the next one in just one minute.\n\nJerry needs a travel card to use the metro. Each travel card has a range $r$ and a price $p$ . With a travel card of range $r$ Jerry may travel no more than $r$ stops at once. Therefore, if Jerry enters metro at the stop $i$ he should exit on one of the stops from $i − r$ to $i + r$ inclusive. It takes $d_{i}$ minutes to exit and reenter metro at i-th stop. There is no time required to enter the first stop or exit the last one.\n\nJerry is not very rich but he has some spare time, so he decided to buy the cheapest travel card that will allow him to travel from the first metro stop to the last one in no more than $t$ minutes.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $t$ -- the number of stops and the maximum possible time $(2 \\le n \\le 50 000$ ; $n - 1 \\le t \\le 10^{9}).$\n\nThe second line contains $n - 1$ integers $p_{r}$ -- the prices of travel cards with range $r = 1$ . . . $n − 1 (1 \\le p_{r} \\le 100 000)$\n\nThe third line contains $n - 2$ integers $d_{i}$ -- the number of minutes required to reenter metro at stop $i = 2$ . . . $n - 1 (1 \\le d_{i} \\le 10^{5}).$\n\n", "outputFormat": "\n\nOutput a single integer $p$ -- the lowest possible price of one travel card that allows Jerry to travel from the first to the last stop in no more than $t$ minutes.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Journey to the “The World’s Start”", "background": null, "description": "Jerry Prince 是一名四年级学生，他去 New-Lodnon 参观最受欢迎的游乐园 \"The World's Start\"。\n\n他到达的机场就在地铁线的第一站旁边。这条地铁线有 $n$ 个站点，\"The World's Start\" 位于最后一个站点。New-Lodnon 的地铁非常快，所以你可以假设从一个站到下一个站只需要一分钟。\n\nJerry 需要一张地铁通行卡才能使用地铁。每张通行卡都有一个范围 $r$ 和一个价格 $p$。使用范围为 $r$ 的通行卡，Jerry 一次最多可以旅行 $r$ 个站。因此，如果 Jerry 在第 $i$ 个站进入地铁，他应该在从 $i - r$ 到 $i + r$ 的某个站点下车。需要 $d_{i}$ 分钟才能在第 $i$ 个站点下车并重新进入地铁。在第一站进入或最后一站下车不需要时间。\n\nJerry 不是很富有，但他有一些空闲时间，所以他决定购买最便宜的通行卡，使他能够在不超过 $t$ 分钟的时间内从第一站旅行到最后一站。", "inputFormat": "输入文件的第一行包含两个整数 $n$ 和 $t$ —— 站点的数量和最大可能的时间 $(2 \\le n \\le 50 000$ ; $n - 1 \\le t \\le 10^{9})$。\n\n第二行包含 $n - 1$ 个整数 $p_{r}$ —— 范围为 $r = 1$ 到 $n - 1$ 的通行卡的价格 $(1 \\le p_{r} \\le 100 000)$。\n\n第三行包含 $n - 2$ 个整数 $d_{i}$ —— 在第 $i = 2$ 到 $n - 1$ 站点重新进入地铁所需的分钟数 $(1 \\le d_{i} \\le 10^{5})$。", "outputFormat": "输出一个整数 $p$ —— 允许 Jerry 在不超过 $t$ 分钟内从第一站到最后一站的最便宜的通行卡的价格。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7058", "type": "P", "difficulty": 7, "samples": [["5 2\n2 6\n8 2\n14 2\n12 9\n13 8\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Kingdom Trip", "background": "", "description": "\n\nOnce upon a time, there was a kingdom ruled by a wise king. After forty three years of his reign, by means of successful military actions and skillful diplomacy, the kingdom became an infinite flat two-dimensional surface. This form of the kingdom greatly simplified travelling, as there were no borders.\n\nA big holiday was planned in the kingdom. There were $n$ locations for people to gather. As the king wanted to have a closer look at his people, he ordered to make a trip through these locations. He wanted to give a speech in each of these locations. Initially his trip was designed as a polygonal chain $p$ : $p_{1} \\to p_{2} \\to $ . . . $ \\to p_{n}.$\n\nNot only the king was wise, but he was old, too. Therefore, his assistants came up with an idea to skip some locations, to make the king to give as few speeches as possible. The new plan of the trip has to be a polygonal chain consisting of some subsequence of $p$ : starting at $p_{1}$ and ending at $p_{n},$ formally, $p_{i_{1}} \\to p_{i_{2}} \\to · · · \\to p_{i_{m}},$ where $1 = i_{1} < i_{2} < · · · < i_{m} = n$ . Assistants know that the king wouldn't allow to skip location $j$ , if the distance from $p_{j}$ to segment $p_{i_{k}} \\to p_{i_{k+1}}$ exceeds $d$ , for such $k$ , that $i_{k} < j < i_{k+1}.$\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11476/1.png)\n\nOriginal route\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11476/2.png)\n\nNew route\n\nHelp the assistants to find the new route that contains the minimum possible number of locations.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $d$ -- the number of locations in the initial plan of the trip and the maximum allowed distance to skipped locations $(2 \\le n \\le 2000$ ; $1 \\le d \\le 10^{6}).$\n\nThe following $n$ lines describe the trip. The i-th of these lines contains two integers $x_{i}$ and $y_{i}$ -- coordinates of point $p_{i}.$ The absolute value of coordinates does not exceed $10^{6}.$ No two points coincide.\n\n", "outputFormat": "\n\nOutput the minimum number of locations the king will visit. It is guaranteed that the answer is the same for $d ± 10^{−4}.$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Kingdom Trip", "background": "", "description": "\n\nOnce upon a time, there was a kingdom ruled by a wise king. After forty three years of his reign, by means of successful military actions and skillful diplomacy, the kingdom became an infinite flat two-dimensional surface. This form of the kingdom greatly simplified travelling, as there were no borders.\n\nA big holiday was planned in the kingdom. There were $n$ locations for people to gather. As the king wanted to have a closer look at his people, he ordered to make a trip through these locations. He wanted to give a speech in each of these locations. Initially his trip was designed as a polygonal chain $p$ : $p_{1} \\to p_{2} \\to $ . . . $ \\to p_{n}.$\n\nNot only the king was wise, but he was old, too. Therefore, his assistants came up with an idea to skip some locations, to make the king to give as few speeches as possible. The new plan of the trip has to be a polygonal chain consisting of some subsequence of $p$ : starting at $p_{1}$ and ending at $p_{n},$ formally, $p_{i_{1}} \\to p_{i_{2}} \\to · · · \\to p_{i_{m}},$ where $1 = i_{1} < i_{2} < · · · < i_{m} = n$ . Assistants know that the king wouldn't allow to skip location $j$ , if the distance from $p_{j}$ to segment $p_{i_{k}} \\to p_{i_{k+1}}$ exceeds $d$ , for such $k$ , that $i_{k} < j < i_{k+1}.$\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11476/1.png)\n\nOriginal route\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11476/2.png)\n\nNew route\n\nHelp the assistants to find the new route that contains the minimum possible number of locations.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $d$ -- the number of locations in the initial plan of the trip and the maximum allowed distance to skipped locations $(2 \\le n \\le 2000$ ; $1 \\le d \\le 10^{6}).$\n\nThe following $n$ lines describe the trip. The i-th of these lines contains two integers $x_{i}$ and $y_{i}$ -- coordinates of point $p_{i}.$ The absolute value of coordinates does not exceed $10^{6}.$ No two points coincide.\n\n", "outputFormat": "\n\nOutput the minimum number of locations the king will visit. It is guaranteed that the answer is the same for $d ± 10^{−4}.$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Kingdom Trip", "background": "", "description": "从前有一个王国，由一位聪明的国王统治。在他统治的四十三年间，通过成功的军事行动和娴熟的外交手段，王国变成了一个无限平坦的二维平面。这样的形式极大地简化了旅行，因为没有边界。\n\n王国计划举办一个盛大的节日。有 $n$ 个地点供人们聚集。国王希望能更近距离地观察他的子民，因此他下令在这些地点之间进行旅行。他希望在每个地点发表演讲。最初，他的旅行被设计为一个多边形链 $p$：$p_{1} \\to p_{2} \\to \\ldots \\to p_{n}$。\n\n国王不仅聪明，而且年事已高。因此，他的助手们想出了一个主意，跳过一些地点，以便让国王尽可能少地发表演讲。新的旅行计划必须是由 $p$ 的某个子序列组成的多边形链：从 $p_{1}$ 开始，到 $p_{n}$ 结束，形式上为 $p_{i_{1}} \\to p_{i_{2}} \\to \\cdots \\to p_{i_{m}}$，其中 $1 = i_{1} < i_{2} < \\cdots < i_{m} = n$。助手们知道，如果从 $p_{j}$ 到线段 $p_{i_{k}} \\to p_{i_{k+1}}$ 的距离超过 $d$，对于这样的 $k$，即 $i_{k} < j < i_{k+1}$，国王不会允许跳过地点 $j$。\n\n帮助助手们找到包含最少可能地点的新路线。", "inputFormat": "输入文件的第一行包含两个整数 $n$ 和 $d$——旅行初始计划中的地点数和允许跳过地点的最大距离 $(2 \\le n \\le 2000$；$1 \\le d \\le 10^{6})$。\n\n接下来的 $n$ 行描述了旅行。第 $i$ 行包含两个整数 $x_{i}$ 和 $y_{i}$——点 $p_{i}$ 的坐标。坐标的绝对值不超过 $10^{6}$。没有两个点重合。", "outputFormat": "输出国王将访问的最少地点数。保证对于 $d \\pm 10^{-4}$，答案是相同的。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7059", "type": "P", "difficulty": 2, "samples": [["3 4\n5 3 9 10\n1 8 8 2\n4 3 4 3\n", "25\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Lucky Chances", "background": "", "description": "\n\nLucky Chances is a lottery game. Each lottery ticket has a play field and a scratch area. The play field is a rectangular $r \\times c$ field filled with numbers. The scratch area hides row and column numbers that specify the bet cell.\n\nThere are four possible winning directions: up, down, left and right. You win a direction if all numbers in this direction from the bet cell are strictly less than a number in the bet cell. And if the bet cell is on the edge of the grid, you win the corresponding direction automatically!\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11477/1.png)\n\nUnscratched ticket\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11477/2.png)\n\nScratched ticket $1$\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11477/3.png)\n\nScratched ticket $2$\n\nLarry wants to choose the ticket that has maximum total number of winning directions for all possible bet cells. Write a program that determines this number for the given grid.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $r$ and $c$ -- the number of rows and columns in the grid $(1 \\le r , c \\le 100)$ .\n\nThe following $r$ lines contain $c$ integers each -- the numbers printed on the grid. Each number is positive and does not exceed $1000$ .\n\n", "outputFormat": "\n\nOutput a single integer $w$ -- the total number of winning directions for the given grid.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Lucky Chances", "background": "", "description": "\n\nLucky Chances is a lottery game. Each lottery ticket has a play field and a scratch area. The play field is a rectangular $r \\times c$ field filled with numbers. The scratch area hides row and column numbers that specify the bet cell.\n\nThere are four possible winning directions: up, down, left and right. You win a direction if all numbers in this direction from the bet cell are strictly less than a number in the bet cell. And if the bet cell is on the edge of the grid, you win the corresponding direction automatically!\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11477/1.png)\n\nUnscratched ticket\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11477/2.png)\n\nScratched ticket $1$\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11477/3.png)\n\nScratched ticket $2$\n\nLarry wants to choose the ticket that has maximum total number of winning directions for all possible bet cells. Write a program that determines this number for the given grid.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $r$ and $c$ -- the number of rows and columns in the grid $(1 \\le r , c \\le 100)$ .\n\nThe following $r$ lines contain $c$ integers each -- the numbers printed on the grid. Each number is positive and does not exceed $1000$ .\n\n", "outputFormat": "\n\nOutput a single integer $w$ -- the total number of winning directions for the given grid.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Lucky Chances", "background": "", "description": "幸运机会是一种彩票游戏。每张彩票都有一个游戏区域和一个刮刮区。游戏区域是一个 $r \\times c$ 的矩形区域，填满了数字。刮刮区隐藏了指定投注单元格的行号和列号。\n\n有四种可能的获胜方向：上、下、左和右。如果从投注单元格开始的某个方向上的所有数字都严格小于投注单元格中的数字，那么你就赢得了这个方向。如果投注单元格位于网格的边缘，你将自动赢得相应的方向！\n\n未刮开的票\n\n刮开的票 1\n\n刮开的票 2\n\n拉里想选择一张在所有可能的投注单元格中获胜方向总数最多的票。编写一个程序来确定给定网格的这个数字。", "inputFormat": "输入文件的第一行包含两个整数 $r$ 和 $c$ —— 网格中的行数和列数 $(1 \\le r , c \\le 100)$。\n\n接下来的 $r$ 行每行包含 $c$ 个整数 —— 网格上打印的数字。每个数字都是正数且不超过 $1000$。", "outputFormat": "输出一个整数 $w$ —— 给定网格的获胜方向总数。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7060", "type": "P", "difficulty": 2, "samples": [["23\n", "09:30\n"], ["28\n", "Impossible\n"], ["2\n", "Impossible\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Alarm Clock", "background": "", "description": "\n\nAlice likes her digital alarm clock. She sets them up every evening. Last night Alice had a dream about her clock. Unfortunately, the only thing she is able to remember is the number of highlighted segments of the clock. Alice wonders what time was set on the clock in her dream.\n\nAlice's clock have four digits: two for hours and two for minutes. For example, the clock below shows $9:30$ (note the leading zero).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6dl4fhwk.png)\n\nThe clock uses following digit representation.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/igdzsez5.png)\n\n", "inputFormat": "\n\nThe only line of the input file contains single integer $n$ — the number of highlighted segments of the clock in Alice's dream $(0 \\le n \\le 30)$ .\n\n", "outputFormat": "\n\nOutput five characters in $\\text{hh:mm}$ format — the time shown on the clock in Alice's dream. The time must be correct: $0 \\le \\text{hh} < 24$ and $0 \\le \\text{mm} < 60$ . If there are many possible correct times, output any of them. If there is none, output `Impossible`.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\nspj provider: @[rzh123](user/237530)", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Alarm Clock", "background": "", "description": "\n\nAlice likes her digital alarm clock. She sets them up every evening. Last night Alice had a dream about her clock. Unfortunately, the only thing she is able to remember is the number of highlighted segments of the clock. Alice wonders what time was set on the clock in her dream.\n\nAlice's clock have four digits: two for hours and two for minutes. For example, the clock below shows $9:30$ (note the leading zero).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6dl4fhwk.png)\n\nThe clock uses following digit representation.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/igdzsez5.png)\n\n", "inputFormat": "\n\nThe only line of the input file contains single integer $n$ — the number of highlighted segments of the clock in Alice's dream $(0 \\le n \\le 30)$ .\n\n", "outputFormat": "\n\nOutput five characters in $\\text{hh:mm}$ format — the time shown on the clock in Alice's dream. The time must be correct: $0 \\le \\text{hh} < 24$ and $0 \\le \\text{mm} < 60$ . If there are many possible correct times, output any of them. If there is none, output `Impossible`.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\nspj provider: @[rzh123](user/237530)", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Alarm Clock", "background": "", "description": "Alice 喜欢她的数字闹钟。她每天晚上都会设置好闹钟。昨晚 Alice 做了一个关于她闹钟的梦。不幸的是，她唯一能记得的是闹钟上高亮显示的段数。Alice 想知道她梦中闹钟上设置的时间。\n\nAlice 的闹钟有四位数字：两个表示小时，两个表示分钟。例如，下面的闹钟显示的是 $9:30$（注意前导零）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6dl4fhwk.png)\n\n闹钟使用以下数字表示法。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/igdzsez5.png)", "inputFormat": "输入文件的唯一一行包含一个整数 $n$ — Alice 梦中闹钟上高亮显示的段数 $(0 \\le n \\le 30)$。", "outputFormat": "输出五个字符，格式为 $\\\\text{hh:mm}$ — Alice 梦中闹钟上显示的时间。时间必须是正确的：$0 \\le \\\\text{hh} < 24$ 且 $0 \\le \\\\text{mm} < 60$。如果有多个可能的正确时间，输出其中任何一个。如果没有，输出 `Impossible`。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\nspj 提供者：@[rzh123](user/237530)\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7061", "type": "P", "difficulty": 0, "samples": [["70 3 2 2\n40 30\n50 40\n", "2 1\n2 1\n1\n"], ["1 2 3 4\n6 6 5\n8 10 7 9\n", "2 0\n1 2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Buffcraft", "background": "", "description": "\n\nBrenda enjoys a new role-playing game Buffcraft. Shields, swords, books and other carry-on items do not affects character stats in Buffcraft. The only way to increase the stats of your character is to buff her.\n\nThere are two types of buffs in Buffcraft. Direct buffs increase a base value of the stat, while percentage buffs increase stats by the fraction of the base value. To be precise, if unbuffed base value of your character stat is $b$ , you have buffed her using $n$ direct buffs of strength $d_1 , d_2 , \\cdots d_n$ and $m$ percentage buffs of strength $p_{1}, p_{2}, \\cdots , p_{m},$ the resulting stat will be equal to $(b + d_{1} + d_{2} + · · · + d_{n})(100 + p_{1} + p_{2} + · · · + p_{m})/100$ . Note that the resulting stat may be fractional.\n\nUnfortunately, your character has only $k$ buff slots and if you apply more than $k$ buffs on her, only the last $k$ buffs remains active. Thus, there is no reason to apply more than $k$ buffs simultaneously. You cannot apply the same buff more than once.\n\nBrenda is going to send his character to raid and wants to buff her health to maximal possible value. She has some direct and some percentage buffs at her disposal and needs your help to select the set of buffs that leads to maximal possible total health.\n\n", "inputFormat": "\n\nThe first line of the input file contains four integers $b , k , c_{d}$ and $c_{p}$ — the base health of the character, the number of buff slots, the number of available directs buffs, and the number of available percentage buffs.\n\nThe following line contains $c_{d}$ integers $d_{i}$ — strengths of direct buffs.\n\nThe last line of the input file contains $c_{p}$ integer numbers $p_{i}$ — strengths of percentage buffs.\n\nAll numbers in the input file are greater than or equal to zero, and less than or equal to fifty thousand.\n\n", "outputFormat": "\n\nThe first line of the output file must contain two integers $n$ and $m$ — the number of direct and percentage buffs to use $(0 \\le n \\le c_{d}; 0 \\le m \\le c_{p}; 0 \\le n + m \\le k)$ .\n\nThe following line must contain $n$ different numbers — indices of direct buffs to apply (buffs are numbered from one).\n\nThe last line of the output must contain $m$ different numbers — indices of percentage buffs to apply (also numbered from one).\n\nThe resulting total health after application of all $n + m$ buffs must be maximal possible.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Buffcraft", "background": "", "description": "\n\nBrenda enjoys a new role-playing game Buffcraft. Shields, swords, books and other carry-on items do not affects character stats in Buffcraft. The only way to increase the stats of your character is to buff her.\n\nThere are two types of buffs in Buffcraft. Direct buffs increase a base value of the stat, while percentage buffs increase stats by the fraction of the base value. To be precise, if unbuffed base value of your character stat is $b$ , you have buffed her using $n$ direct buffs of strength $d_1 , d_2 , \\cdots d_n$ and $m$ percentage buffs of strength $p_{1}, p_{2}, \\cdots , p_{m},$ the resulting stat will be equal to $(b + d_{1} + d_{2} + · · · + d_{n})(100 + p_{1} + p_{2} + · · · + p_{m})/100$ . Note that the resulting stat may be fractional.\n\nUnfortunately, your character has only $k$ buff slots and if you apply more than $k$ buffs on her, only the last $k$ buffs remains active. Thus, there is no reason to apply more than $k$ buffs simultaneously. You cannot apply the same buff more than once.\n\nBrenda is going to send his character to raid and wants to buff her health to maximal possible value. She has some direct and some percentage buffs at her disposal and needs your help to select the set of buffs that leads to maximal possible total health.\n\n", "inputFormat": "\n\nThe first line of the input file contains four integers $b , k , c_{d}$ and $c_{p}$ — the base health of the character, the number of buff slots, the number of available directs buffs, and the number of available percentage buffs.\n\nThe following line contains $c_{d}$ integers $d_{i}$ — strengths of direct buffs.\n\nThe last line of the input file contains $c_{p}$ integer numbers $p_{i}$ — strengths of percentage buffs.\n\nAll numbers in the input file are greater than or equal to zero, and less than or equal to fifty thousand.\n\n", "outputFormat": "\n\nThe first line of the output file must contain two integers $n$ and $m$ — the number of direct and percentage buffs to use $(0 \\le n \\le c_{d}; 0 \\le m \\le c_{p}; 0 \\le n + m \\le k)$ .\n\nThe following line must contain $n$ different numbers — indices of direct buffs to apply (buffs are numbered from one).\n\nThe last line of the output must contain $m$ different numbers — indices of percentage buffs to apply (also numbered from one).\n\nThe resulting total health after application of all $n + m$ buffs must be maximal possible.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Buffcraft", "background": "", "description": "Brenda喜欢一款新的游戏Buffcraft。没有任何物品可以影响Buffcraft中的角色属性。增加你角色属性的唯一方法就是给予它buff。\n\nBuffcraft中有两种类型的buff。  \n1.直接增加buff的值;  \n2.百分比增加buff的值;  \n如果你的角色buff初始值是$b$，那么你使用$n$个增益分别为$d_1,d_2,\\cdots,d_n$的第一种buff和$m$个增益分别为$p_{1},p_{2}\\cdots,p_{m}$的第二种buff，得到的结果将等于$(b+d_{1}+d_{2}+··+d_{n})(100+p_{1}+p_{2}-··+p_{m})/100$。请注意，这个结果可能不是整数。\n\n不幸的是，你的角色只有$k$个buff槽，如果你在她身上应用了$k$个以上的buff，那么只有最后的$k$个buff有效。因此，你不能同时拥有$k$个以上buff。当然，一个buff不能被多次使用。\n\nBrenda将派她的角色去战斗，并希望将角色的buff值提升到最大。有一些第一种buff和一些第二种buff可供她使用。她需要你的帮助来选择一种buff的搭配方式，以获得最大可能的总buff值。", "inputFormat": "第一行包含四个整数$b,k,n,m$；分别代表角色的基础buff值、buff槽数、第一种buff的数量与第二种buff的数量。     \n第二行包含$n$个整数$d_{i}$，代表每个第一种buff的增益量。   \n第三行包含$m$个整数$p_{i}$，代表每个第二种buff的增益量。", "outputFormat": "第一行是两个整数$x,y$代表用了多少第一种buff和用了多少第二种buff。$(0 \\le x \\le n; 0 \\le y \\le m; 0 \\le x + y \\le k)$ .\n  \n第二行是$x$个数字-要应用的每一个第一种buff的索引。  \n第二行是$y$个数字-要应用的每一个第二种buff的索引。\n你的方案要让所有buff应用后产生的总buff值尽可能最大。\n\n## 输入输出样例\n\n### 样例输入#1\n```\n70 3 2 2\n40 30\n50 40\n```\n### 样例输出#1\n```\n2 1\n2 1\n1\n```\n### 样例输入#2\n```\n1 2 3 4\n6 6 5\n8 10 7 9\n```\n### 样例输出#2\n```\n2 0\n1 2\n```", "hint": "$0 \\le b,k,n,m,d_{i},p_{i} \\le 50000$  \n数组的索引从1开始  \n时间限制:2s;空间限制:256MB。", "locale": "zh-CN"}}}
{"pid": "P7062", "type": "P", "difficulty": 6, "samples": [["C(K(II)(IC))\n", "2\n"], ["CIBI\n", "3\n"], ["BBBBBCCCCCKKKKKIIIII\n", "15\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Combinator Expression", "background": "", "description": "Combinatory logic may be thought as one of computational models allowing to express any computable function as a composition of functions from a small finite basis. In this problem we consider a restricted variant of BCKW basis, BCKI.\n\nCombinator expression in BCKI basis is a string, corresponding to the following grammar:\n\n```plain\n⟨Expression⟩ ::= ⟨Expression⟩ ⟨Term⟩ | ⟨Term⟩\n⟨Term⟩ ::= ‘(’⟨Expression⟩‘)’ | ‘B’ | ‘C’ | ‘K’ | ‘I’\n```\n\nAs we can see from the grammar, the expression is a tree of applications where leafs are combinators $B, C, K$ and $I$. The application is left-associative. For example $BIC$ is equivalent to $(BI)C,$ but not to $B(IC)$.\n\nFor the sake of the explanation we will use lowercase English letters $(a \\cdots z)$ to represent sub-expressions. These lowercase letters will not appear in real data. For example, $BIC$ can be represented by $BxC$ (that is, $B\\underbrace { I }_{ x }C)$, $x(\\underbrace {BIC}_{ x })$, $xy(\\underbrace {BI}_{ x } \\underbrace { C }_{ y })$, $Bxy (B\\underbrace { I }_{ x }\\underbrace { C }_{ y })$, but not by $Bx$.\n\nWe say that in expression $pq$ we apply $p$ to $q$. We can employ our intuition by saying that $p$ is a function and $q$ is its parameter. However, the evaluation process is quite different from traditional computation — instead of passing values over fixed expression tree, we evaluate by altering that tree so that the result is also some combinator expression.\n\nTo evaluate an expression, we need to select some sub-expression, corresponding to one of the patterns specified in the table below — that is, there should exist such $x$ (and maybe $y$ and $z$) that the pattern from the table becomes equal to the sub-expression. Then we need to replace the sub-expression with the reduction result from the table.\n\n| Pattern | Reduction result |                   Description                   |\n| :-----: | :--------------: | :---------------------------------------------: |\n| $Bxyz$  |     $x(yz)$      | Composition function (Zusammensetzungsfunktion) |\n| $Cxyz$  |     $(xz)y$      |    Exchange function (Vertauschungsfunktion)    |\n|  $Kxy$  |       $x$        |      Constant function (Konstanzfunktion)       |\n|  $Ix$   |       $x$        |     Identity function (Identitätsfunktion)      |\n\nAfter the replacement took place we must repeat the process, until there remains no suitable subexpressions. This final expression is normal form of the original one. For example, in expression $CIC(CB)I$ we can make the following letter assignment\n\n$$\\underbrace { C }_{ C }\\underbrace { I }_{ x }\\underbrace { C }_{ y }\\underbrace {(CB)}_{ z }I$$\n\nand see that $CIC(CB)I ≡ (((CI)C)(CB))I ≡ (((Cx)y)z)I$ contains $C$ combinator pattern and thus reduces to $((xz)y)I ≡ I(CB)CI:$\n\n$$(\\underbrace { C }_{ C }\\underbrace { I }_{ x }\\underbrace { C }_{ y }\\underbrace { (CB) }_{ Z })I \\rightarrow (\\underbrace { I }_{ x } \\underbrace {(CB)}_{ z }\\underbrace { C }_{ y })I$$\n\nOne more example: $B((CK)I)IC$ expression. Let us first reduce combinator $B:$\n\n$$(\\underbrace { B }_{ B }\\underbrace { ((CK)I) }_{ x }\\underbrace { I }_{ y }\\underbrace { C }_{ z } \\rightarrow \\underbrace { ((CK)I) }_{ x } (\\underbrace { I }_{ y }\\underbrace { C }_{ z })$$\n\nNow, let's reduce the last $I:$\n\n$$((CK)I)(\\underbrace { I }_{ I } \\underbrace { C }_{ x }) \\rightarrow ((CK)I)C$$\n\nAnd now we finish evaluation with two more reductions:\n\n$$((\\underbrace { C }_{ C }\\underbrace { K }_{ x }) \\underbrace { I }_{ y }) \\underbrace { C }_{ z } \\rightarrow (\\underbrace { K }_{ K }\\underbrace { C }_{ x }) \\underbrace { I }_{ y } \\rightarrow C$$\n\nIt is possible to show that the normal form remains the same irrespectable to the order of evaluation. For example, the following evaluation order:\n\n$$C(K(II)(\\underbrace { I }_{ I }\\underbrace { C }_{ x })) \\rightarrow C(K(\\underbrace { I }_{ I }\\underbrace {  I}_{ x })(C)) \\rightarrow C((\\underbrace { K }_{ K }\\underbrace { I }_{ x }) \\underbrace { C }_{ y }) \\rightarrow CI$$\n\nleads to the same result as \n\n$$C(K(\\underbrace {I}_{ I }\\underbrace { I }_{ x })(IC)) \\rightarrow C((\\underbrace { K }_{ K }\\underbrace { I }_{ x })\\underbrace { (IC)}_{ y }) \\rightarrow CI$$\n\nHowever, as you see, the number of reductions is different: $3$ in the first case and $2$ in the second. This poses an interesting problem -- to find an evaluation order with the minimal number of reductions for a given formula.\n\nYour task is to write a program which finds the minimal number of reductions required for a given combinator expression to be evaluated to its normal form.", "inputFormat": "\n\nThe only line of the input file contains a combinator expression corresponding to the grammar above. The length of the expression does not exceed $30 000$ . The expression contains no whitespaces or symbols not specified in the grammar.\n\n", "outputFormat": "\n\nOutput a single integer — the minimal number of reductions required for the given formula to evaluate it to normal form.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Combinator Expression", "background": "", "description": "Combinatory logic may be thought as one of computational models allowing to express any computable function as a composition of functions from a small finite basis. In this problem we consider a restricted variant of BCKW basis, BCKI.\n\nCombinator expression in BCKI basis is a string, corresponding to the following grammar:\n\n```plain\n⟨Expression⟩ ::= ⟨Expression⟩ ⟨Term⟩ | ⟨Term⟩\n⟨Term⟩ ::= ‘(’⟨Expression⟩‘)’ | ‘B’ | ‘C’ | ‘K’ | ‘I’\n```\n\nAs we can see from the grammar, the expression is a tree of applications where leafs are combinators $B, C, K$ and $I$. The application is left-associative. For example $BIC$ is equivalent to $(BI)C,$ but not to $B(IC)$.\n\nFor the sake of the explanation we will use lowercase English letters $(a \\cdots z)$ to represent sub-expressions. These lowercase letters will not appear in real data. For example, $BIC$ can be represented by $BxC$ (that is, $B\\underbrace { I }_{ x }C)$, $x(\\underbrace {BIC}_{ x })$, $xy(\\underbrace {BI}_{ x } \\underbrace { C }_{ y })$, $Bxy (B\\underbrace { I }_{ x }\\underbrace { C }_{ y })$, but not by $Bx$.\n\nWe say that in expression $pq$ we apply $p$ to $q$. We can employ our intuition by saying that $p$ is a function and $q$ is its parameter. However, the evaluation process is quite different from traditional computation — instead of passing values over fixed expression tree, we evaluate by altering that tree so that the result is also some combinator expression.\n\nTo evaluate an expression, we need to select some sub-expression, corresponding to one of the patterns specified in the table below — that is, there should exist such $x$ (and maybe $y$ and $z$) that the pattern from the table becomes equal to the sub-expression. Then we need to replace the sub-expression with the reduction result from the table.\n\n| Pattern | Reduction result |                   Description                   |\n| :-----: | :--------------: | :---------------------------------------------: |\n| $Bxyz$  |     $x(yz)$      | Composition function (Zusammensetzungsfunktion) |\n| $Cxyz$  |     $(xz)y$      |    Exchange function (Vertauschungsfunktion)    |\n|  $Kxy$  |       $x$        |      Constant function (Konstanzfunktion)       |\n|  $Ix$   |       $x$        |     Identity function (Identitätsfunktion)      |\n\nAfter the replacement took place we must repeat the process, until there remains no suitable subexpressions. This final expression is normal form of the original one. For example, in expression $CIC(CB)I$ we can make the following letter assignment\n\n$$\\underbrace { C }_{ C }\\underbrace { I }_{ x }\\underbrace { C }_{ y }\\underbrace {(CB)}_{ z }I$$\n\nand see that $CIC(CB)I ≡ (((CI)C)(CB))I ≡ (((Cx)y)z)I$ contains $C$ combinator pattern and thus reduces to $((xz)y)I ≡ I(CB)CI:$\n\n$$(\\underbrace { C }_{ C }\\underbrace { I }_{ x }\\underbrace { C }_{ y }\\underbrace { (CB) }_{ Z })I \\rightarrow (\\underbrace { I }_{ x } \\underbrace {(CB)}_{ z }\\underbrace { C }_{ y })I$$\n\nOne more example: $B((CK)I)IC$ expression. Let us first reduce combinator $B:$\n\n$$(\\underbrace { B }_{ B }\\underbrace { ((CK)I) }_{ x }\\underbrace { I }_{ y }\\underbrace { C }_{ z } \\rightarrow \\underbrace { ((CK)I) }_{ x } (\\underbrace { I }_{ y }\\underbrace { C }_{ z })$$\n\nNow, let's reduce the last $I:$\n\n$$((CK)I)(\\underbrace { I }_{ I } \\underbrace { C }_{ x }) \\rightarrow ((CK)I)C$$\n\nAnd now we finish evaluation with two more reductions:\n\n$$((\\underbrace { C }_{ C }\\underbrace { K }_{ x }) \\underbrace { I }_{ y }) \\underbrace { C }_{ z } \\rightarrow (\\underbrace { K }_{ K }\\underbrace { C }_{ x }) \\underbrace { I }_{ y } \\rightarrow C$$\n\nIt is possible to show that the normal form remains the same irrespectable to the order of evaluation. For example, the following evaluation order:\n\n$$C(K(II)(\\underbrace { I }_{ I }\\underbrace { C }_{ x })) \\rightarrow C(K(\\underbrace { I }_{ I }\\underbrace {  I}_{ x })(C)) \\rightarrow C((\\underbrace { K }_{ K }\\underbrace { I }_{ x }) \\underbrace { C }_{ y }) \\rightarrow CI$$\n\nleads to the same result as \n\n$$C(K(\\underbrace {I}_{ I }\\underbrace { I }_{ x })(IC)) \\rightarrow C((\\underbrace { K }_{ K }\\underbrace { I }_{ x })\\underbrace { (IC)}_{ y }) \\rightarrow CI$$\n\nHowever, as you see, the number of reductions is different: $3$ in the first case and $2$ in the second. This poses an interesting problem -- to find an evaluation order with the minimal number of reductions for a given formula.\n\nYour task is to write a program which finds the minimal number of reductions required for a given combinator expression to be evaluated to its normal form.", "inputFormat": "\n\nThe only line of the input file contains a combinator expression corresponding to the grammar above. The length of the expression does not exceed $30 000$ . The expression contains no whitespaces or symbols not specified in the grammar.\n\n", "outputFormat": "\n\nOutput a single integer — the minimal number of reductions required for the given formula to evaluate it to normal form.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Combinator Expression", "background": "", "description": "## 题目背景\n\n组合逻辑可以看作是一种计算模型，允许将任何可计算函数表示为从小的有限基底中选取的函数的组合。在这个问题中，我们考虑 BCKW 基底的一个受限变体，即 BCKI。\n\nBCKI 基底中的组合表达式是一个字符串，对应于以下文法：\n\n```plain\n⟨表达式⟩ ::= ⟨表达式⟩ ⟨项⟩ | ⟨项⟩\n⟨项⟩ ::= ‘(’⟨表达式⟩‘)’ | ‘B’ | ‘C’ | ‘K’ | ‘I’\n```\n\n从文法可以看出，表达式是应用树，叶子是组合子 $B, C, K$ 和 $I$。应用是左结合的。例如，$BIC$ 等价于 $(BI)C$，但不等价于 $B(IC)$。\n\n为了便于解释，我们将使用小写英文字母 $(a \\cdots z)$ 来表示子表达式。这些小写字母不会出现在实际数据中。例如，$BIC$ 可以表示为 $BxC$（即 $B\\underbrace { I }_{ x }C$），$x(\\underbrace {BIC}_{ x })$，$xy(\\underbrace {BI}_{ x } \\underbrace { C }_{ y })$，$Bxy (B\\underbrace { I }_{ x }\\underbrace { C }_{ y })$，但不能表示为 $Bx$。\n\n在表达式 $pq$ 中，我们说将 $p$ 应用于 $q$。我们可以用直觉来理解，$p$ 是一个函数，而 $q$ 是它的参数。然而，求值过程与传统的计算非常不同——不是通过固定表达式树传递值，而是通过改变树结构，使得结果也是一个组合表达式。\n\n为了求值一个表达式，我们需要选择一个子表达式，该子表达式应符合下表中的某个模式——也就是说，应该存在这样的 $x$（可能还有 $y$ 和 $z$），使得表中的模式与子表达式相等。然后我们需要将子表达式替换为表中的简化结果。\n\n| 模式  | 简化结果 | 描述                           |\n| :---: | :-------: | :-----------------------------: |\n| $Bxyz$ | $x(yz)$  | 组合函数（Zusammensetzungsfunktion） |\n| $Cxyz$ | $(xz)y$  | 交换函数（Vertauschungsfunktion）   |\n| $Kxy$  | $x$      | 常数函数（Konstanzfunktion）       |\n| $Ix$   | $x$      | 恒等函数（Identitätsfunktion）     |\n\n替换完成后，我们必须重复这个过程，直到没有合适的子表达式为止。这个最终表达式就是原始表达式的规范形式。例如，在表达式 $CIC(CB)I$ 中，我们可以进行如下字母分配\n\n$$\\underbrace { C }_{ C }\\underbrace { I }_{ x }\\underbrace { C }_{ y }\\underbrace {(CB)}_{ z }I$$\n\n并看到 $CIC(CB)I ≡ (((CI)C)(CB))I ≡ (((Cx)y)z)I$ 包含了 $C$ 组合子模式，因此简化为 $((xz)y)I ≡ I(CB)CI:$\n\n$$(\\underbrace { C }_{ C }\\underbrace { I }_{ x }\\underbrace { C }_{ y }\\underbrace { (CB) }_{ Z })I \\rightarrow (\\underbrace { I }_{ x } \\underbrace {(CB)}_{ z }\\underbrace { C }_{ y })I$$\n\n另一个例子：$B((CK)I)IC$ 表达式。让我们先简化组合子 $B:$\n\n$$(\\underbrace { B }_{ B }\\underbrace { ((CK)I) }_{ x }\\underbrace { I }_{ y }\\underbrace { C }_{ z } \\rightarrow \\underbrace { ((CK)I) }_{ x } (\\underbrace { I }_{ y }\\underbrace { C }_{ z }))$$\n\n现在，让我们简化最后一个 $I:$\n\n$$((CK)I)(\\underbrace { I }_{ I } \\underbrace { C }_{ x }) \\rightarrow ((CK)I)C$$\n\n最后，我们通过两次更多的简化完成求值：\n\n$$((\\underbrace { C }_{ C }\\underbrace { K }_{ x }) \\underbrace { I }_{ y }) \\underbrace { C }_{ z } \\rightarrow (\\underbrace { K }_{ K }\\underbrace { C }_{ x }) \\underbrace { I }_{ y } \\rightarrow C$$\n\n可以证明，无论求值顺序如何，规范形式都是一样的。例如，以下求值顺序：\n\n$$C(K(II)(\\underbrace { I }_{ I }\\underbrace { C }_{ x })) \\rightarrow C(K(\\underbrace { I }_{ I }\\underbrace {  I}_{ x })(C)) \\rightarrow C((\\underbrace { K }_{ K }\\underbrace { I }_{ x }) \\underbrace { C }_{ y }) \\rightarrow CI$$\n\n和\n\n$$C(K(\\underbrace {I}_{ I }\\underbrace { I }_{ x })(IC)) \\rightarrow C((\\underbrace { K }_{ K }\\underbrace { I }_{ x })\\underbrace { (IC)}_{ y }) \\rightarrow CI$$\n\n得到的结果相同。然而，如你所见，简化的次数不同：第一个情况下为 $3$ 次，第二个情况下为 $2$ 次。这提出了一个有趣的问题——找到一个给定公式所需的最小简化次数。\n\n你的任务是编写一个程序，找到给定组合表达式求值到其规范形式所需的最小简化次数。", "inputFormat": "输入文件只有一行，包含一个符合上述文法的组合表达式。表达式的长度不超过 $30 000$。表达式中不含空格或文法未指定的符号。", "outputFormat": "输出一个整数——给定公式求值到规范形式所需的最小简化次数。", "hint": "时间限制：1 秒，内存限制：256 MB。", "locale": "zh-CN"}}}
{"pid": "P7063", "type": "P", "difficulty": 1, "samples": [["2\n", "11\n"], ["3\n", "33\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "2014", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Digits", "background": "", "description": "\n\nLittle Petya likes integers. Recently he has learned about different properties of sums of number's digits. For example, if the sum of number's digits is divisible by $9$ , then the number itself is divisible by $9$ as well.\n\nNow little Petya is interested in numbers with equal sum of digits. He asks his older brother Dima to find $n$ positive integers with equal sum of digits and minimal possible total sum. Dima has other important things to do, so he asked you to write a program that solves this problem for him.\n\n", "inputFormat": "\n\nInput file contains a single integer $n (1 \\le n \\le 5000)$ .\n\n", "outputFormat": "\n\nOutput the minimal possible sum of $n$ positive integers, that all have same sum of digits.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Digits", "background": "", "description": "\n\nLittle Petya likes integers. Recently he has learned about different properties of sums of number's digits. For example, if the sum of number's digits is divisible by $9$ , then the number itself is divisible by $9$ as well.\n\nNow little Petya is interested in numbers with equal sum of digits. He asks his older brother Dima to find $n$ positive integers with equal sum of digits and minimal possible total sum. Dima has other important things to do, so he asked you to write a program that solves this problem for him.\n\n", "inputFormat": "\n\nInput file contains a single integer $n (1 \\le n \\le 5000)$ .\n\n", "outputFormat": "\n\nOutput the minimal possible sum of $n$ positive integers, that all have same sum of digits.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Digits", "background": "", "description": "小 Petya 喜欢整数。最近他了解到数字和的不同性质。例如，如果一个数字的各位数字之和可以被 $9$ 整除，那么这个数字本身也可以被 $9$ 整除。\n\n现在小 Petya 对具有相同数字和的数字感兴趣。他请求他的哥哥 Dima 找出 $n$ 个具有相同数字和且总和最小的正整数。Dima 有其他重要的事情要做，所以他请你为他编写一个程序来解决这个问题。", "inputFormat": "输入文件包含一个整数 $n (1 \\le n \\le 5000)$。", "outputFormat": "输出 $n$ 个正整数的最小可能总和，这些整数的数字和相同。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7064", "type": "P", "difficulty": 7, "samples": [["a.*b\nbab\n", "abab\n"], ["(ab)*\nbb\n", "NO\n"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Expression", "background": "", "description": "\n\nIn computing, regular expressions is a powerful tool for text search and string matching. In this problem a simplified version of regular expressions is used:\n\n- An empty string ` ` is a regular expression, only the empty string matches it.\n\n- A single lowercase letter `c` is a regular expression, a string consisting of a single letter $c$ matches it.\n\n- A dot `.` is a regular expression, a string consisting of any single letter matches it.\n\n- Alternation: if $α$ and $β$ are regular expressions then `(α|β)` is a regular expression, a string $s$ matches it only if $s$ matches $α$ or $s$ matches $β$.\n\n- Concatenation: if $α$ and $β$ are regular expressions then `(αβ)` is a regular expression, a string $s$ matches it only if $s =$ `xy`, $x$ matches $α$ and $y$ matches $β$.\n\n- Kleene star: if $α$ is regular expression then `(α∗)` is a regular expression, a string $s$ matches it only if $s$ is empty or $s =$ `xy`, $x$ is nonempty and matches $α$ and $y$ matches $(α∗).$ In other words, $s$ consists of zero or more strings, each of them matches $α.$\n\nParentheses can be omitted, in this problem Kleene star has the highest priority, concatenation has medium priority and alternation has lowest priority. Thus `abc*|de` means `(ab(c*))|(de)`.\n\nFor example, string `abcabcab` matches `a(bc|a)*ab`, but string `abcbab` does not.\n\nYour task is to find the shortest string that matches the given regular expression $E$ and contains the given substring $S$ .\n\n", "inputFormat": "\n\nThe first line of the input file contains the regular expression $E$ . The second line of the input file contains the substring $S (1 \\le |E| , |S| \\le 10 000)$ .\n\nString $S$ consists of lowercase English letters. Expression $E$ consists of lowercase English letters and special characters: dots (`.`), parentheses (`(`) and (`)`), pipes (`|`), and asterisks (`*`).\n\n", "outputFormat": "\n\nOutput the shortest possible string $T$ that both matches $E$ and contains $S$ as substring. If there are no such strings, output `NO`.\n\nThe string $T$ should contain only lowercase English letters.\n\n", "hint": "Time limit: 10 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Expression", "background": "", "description": "\n\nIn computing, regular expressions is a powerful tool for text search and string matching. In this problem a simplified version of regular expressions is used:\n\n- An empty string ` ` is a regular expression, only the empty string matches it.\n\n- A single lowercase letter `c` is a regular expression, a string consisting of a single letter $c$ matches it.\n\n- A dot `.` is a regular expression, a string consisting of any single letter matches it.\n\n- Alternation: if $α$ and $β$ are regular expressions then `(α|β)` is a regular expression, a string $s$ matches it only if $s$ matches $α$ or $s$ matches $β$.\n\n- Concatenation: if $α$ and $β$ are regular expressions then `(αβ)` is a regular expression, a string $s$ matches it only if $s =$ `xy`, $x$ matches $α$ and $y$ matches $β$.\n\n- Kleene star: if $α$ is regular expression then `(α∗)` is a regular expression, a string $s$ matches it only if $s$ is empty or $s =$ `xy`, $x$ is nonempty and matches $α$ and $y$ matches $(α∗).$ In other words, $s$ consists of zero or more strings, each of them matches $α.$\n\nParentheses can be omitted, in this problem Kleene star has the highest priority, concatenation has medium priority and alternation has lowest priority. Thus `abc*|de` means `(ab(c*))|(de)`.\n\nFor example, string `abcabcab` matches `a(bc|a)*ab`, but string `abcbab` does not.\n\nYour task is to find the shortest string that matches the given regular expression $E$ and contains the given substring $S$ .\n\n", "inputFormat": "\n\nThe first line of the input file contains the regular expression $E$ . The second line of the input file contains the substring $S (1 \\le |E| , |S| \\le 10 000)$ .\n\nString $S$ consists of lowercase English letters. Expression $E$ consists of lowercase English letters and special characters: dots (`.`), parentheses (`(`) and (`)`), pipes (`|`), and asterisks (`*`).\n\n", "outputFormat": "\n\nOutput the shortest possible string $T$ that both matches $E$ and contains $S$ as substring. If there are no such strings, output `NO`.\n\nThe string $T$ should contain only lowercase English letters.\n\n", "hint": "Time limit: 10 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Expression", "background": "", "description": "在计算机科学中，正则表达式是一种用于文本搜索和字符串匹配的强大工具。在这个问题中，使用了简化版的正则表达式：\n\n- 空字符串 ` ` 是一个正则表达式，只有空字符串匹配它。\n\n- 单个小写字母 `c` 是一个正则表达式，由单个字母 $c$ 组成的字符串匹配它。\n\n- 点号 `.` 是一个正则表达式，由任意单个字母组成的字符串匹配它。\n\n- 或运算：如果 $\\alpha$ 和 $\\beta$ 是正则表达式，那么 `(\\alpha|\\beta)` 是一个正则表达式，只有当字符串 $s$ 匹配 $\\alpha$ 或 $s$ 匹配 $\\beta$ 时，$s$ 才匹配它。\n\n- 连接运算：如果 $\\alpha$ 和 $\\beta$ 是正则表达式，那么 `(\\alpha\\beta)` 是一个正则表达式，只有当字符串 $s = xy$，$x$ 匹配 $\\alpha$ 且 $y$ 匹配 $\\beta$ 时，$s$ 才匹配它。\n\n- Kleene 星号：如果 $\\alpha$ 是正则表达式，那么 `(\\alpha*)` 是一个正则表达式，只有当字符串 $s$ 是空的或 $s = xy$，$x$ 非空且匹配 $\\alpha$ 且 $y$ 匹配 $(\\alpha*)$ 时，$s$ 才匹配它。换句话说，$s$ 由零个或多个字符串组成，每个字符串都匹配 $\\alpha$。\n\n括号可以省略，在这个问题中，Kleene 星号具有最高优先级，连接运算具有中等优先级，或运算具有最低优先级。因此 `abc*|de` 表示 `(ab(c*))|(de)`。\n\n例如，字符串 `abcabcab` 匹配 `a(bc|a)*ab`，但字符串 `abcbab` 不匹配。\n\n你的任务是找到匹配给定正则表达式 $E$ 并包含给定子串 $S$ 的最短字符串。", "inputFormat": "输入文件的第一行包含正则表达式 $E$。输入文件的第二行包含子串 $S$（$1 \\le |E|, |S| \\le 10\\,000$）。\n\n字符串 $S$ 由小写英文字母组成。表达式 $E$ 由小写英文字母和特殊字符组成：点号 (`.`)、括号 (`(` 和 `)`)、管道符号 (`|`) 和星号 (`*`)。", "outputFormat": "输出同时匹配 $E$ 并包含 $S$ 作为子串的最短可能字符串 $T$。如果没有这样的字符串，输出 `NO`。\n\n字符串 $T$ 只能包含小写英文字母。", "hint": "时间限制：10 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7065", "type": "P", "difficulty": 6, "samples": [["7\n2 3 1 1 2 2 1\n", "3\n2 4 1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Fragmentation", "background": "", "description": "\n\nFelix is working on a startup project in his garage. He has already found a great name for his project: SuperFastZilla. By now he is not sure what SuperFastZilla should do, but he is pretty sure it should do it fast, super fast.\n\nOnce he noticed that SuperFastZilla is working too slow, inspite of the fast algorithms used in it. Felix thinks that the problem may be caused by storage fragmentation.\n\nThe storage used by SuperFastZilla consists of $n$ blocks of memory. SuperFastZilla performs some operations on this storage. Each block is used in one operation only, the i-th block is used in the $a_{i}$-th operation.\n\nFelix wants to sort these blocks by the index of the operation they are used. To make it faster, Felix wants to split the storage into minimal number of segments of consecutive blocks, and then rearrange these segments to get the sorted array of blocks. After this rearrangement the order of block's indices of operations must be non-decreasing.\n\nHelp Felix to find the way to split the storage that minimizes the number of segments.\n\nFor example, if $a = [2 , 3 , 1 , 1 , 2 , 2 , 1],$ it can be split into three parts: $[2 , 3], [1 , 1 , 2 , 2]$ and $[1].$ These parts can be rearranged to make the sorted array: $[1], [1 , 1 , 2 , 2], [2 , 3].$\n\n", "inputFormat": "\n\nThe first line of input file contains an integer $n (1 \\le n \\le 10^{5}).$ The next line contains $n$ integers $a_{i} (1 \\le a_{i} \\le 10^{5}).$\n\n", "outputFormat": "\n\nThe first line of the output file must contain an integer number $m$ — the minimal number of segments.\n\nThe next line must contains $m$ integers, the lengths of the segments, from left to right.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Fragmentation", "background": "", "description": "\n\nFelix is working on a startup project in his garage. He has already found a great name for his project: SuperFastZilla. By now he is not sure what SuperFastZilla should do, but he is pretty sure it should do it fast, super fast.\n\nOnce he noticed that SuperFastZilla is working too slow, inspite of the fast algorithms used in it. Felix thinks that the problem may be caused by storage fragmentation.\n\nThe storage used by SuperFastZilla consists of $n$ blocks of memory. SuperFastZilla performs some operations on this storage. Each block is used in one operation only, the i-th block is used in the $a_{i}$-th operation.\n\nFelix wants to sort these blocks by the index of the operation they are used. To make it faster, Felix wants to split the storage into minimal number of segments of consecutive blocks, and then rearrange these segments to get the sorted array of blocks. After this rearrangement the order of block's indices of operations must be non-decreasing.\n\nHelp Felix to find the way to split the storage that minimizes the number of segments.\n\nFor example, if $a = [2 , 3 , 1 , 1 , 2 , 2 , 1],$ it can be split into three parts: $[2 , 3], [1 , 1 , 2 , 2]$ and $[1].$ These parts can be rearranged to make the sorted array: $[1], [1 , 1 , 2 , 2], [2 , 3].$\n\n", "inputFormat": "\n\nThe first line of input file contains an integer $n (1 \\le n \\le 10^{5}).$ The next line contains $n$ integers $a_{i} (1 \\le a_{i} \\le 10^{5}).$\n\n", "outputFormat": "\n\nThe first line of the output file must contain an integer number $m$ — the minimal number of segments.\n\nThe next line must contains $m$ integers, the lengths of the segments, from left to right.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Fragmentation", "background": "", "description": "Felix 正在他的车库里进行一个创业项目。他已经为他的项目找到了一个很棒的名字：SuperFastZilla。目前他还不确定 SuperFastZilla 应该做什么，但他非常确定它应该做得很快，超级快。\n\n有一次他注意到 SuperFastZilla 的运行速度太慢，尽管它使用了快速算法。Felix 认为问题可能是由存储碎片引起的。\n\nSuperFastZilla 使用的存储由 $n$ 个内存块组成。SuperFastZilla 在这个存储上执行一些操作。每个块只在一个操作中使用，第 $i$ 个块在第 $a_{i}$ 个操作中使用。\n\nFelix 想按它们使用的操作索引对这些块进行排序。为了加快速度，Felix 想将存储分成最少数量的连续块段，然后重新排列这些段以获得排序后的块数组。重新排列后，块的操作索引顺序必须是非递减的。\n\n帮助 Felix 找到一种分割存储的方法，以最小化段的数量。\n\n例如，如果 $a = [2 , 3 , 1 , 1 , 2 , 2 , 1]$，它可以分成三部分：$[2 , 3], [1 , 1 , 2 , 2]$ 和 $[1]$。这些部分可以重新排列以形成排序后的数组：$[1], [1 , 1 , 2 , 2], [2 , 3]$。", "inputFormat": "输入文件的第一行包含一个整数 $n (1 \\le n \\le 10^{5})$。下一行包含 $n$ 个整数 $a_{i} (1 \\le a_{i} \\le 10^{5})$。", "outputFormat": "输出文件的第一行必须包含一个整数 $m$ — 最小的段数。\n\n下一行必须包含 $m$ 个整数，表示从左到右的段的长度。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7066", "type": "P", "difficulty": 1, "samples": [["1 1 11 8\n2 3 8 6\n3 2\n", "Yes\n"], ["1 1 11 8\n2 3 8 6\n4 3\n", "No\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Grave", "background": "", "description": "\n\nGerard develops a Halloween computer game. The game is played on a rectangular graveyard with a rectangular chapel in it. During the game, the player places new rectangular graves on the graveyard. The grave should completely fit inside graveyard territory and should not overlap with the chapel. The grave may touch borders of the graveyard or the chapel.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qktc13ls.png)\n\nGerard asked you to write a program that determines whether it is possible to place a new grave of given size or there is no enough space for it.\n\n", "inputFormat": "\n\nThe first line of the input file contains two pairs of integers: $x_{1}, y_{1}, x_{2}, y_{2} (−10^{9} \\le x_{1} < x_{2} \\le 10^{9}; −10^{9} \\le y_{1} < y_{2} \\le 10^{9})$ — coordinates of bottom left and top right corners of the graveyard. The second line also contains two pairs of integers $x_{3}, y_{3}, x_{4}, y_{4} (x_{1} < x_{3} < x_{4} < x_{2}; y_{1} < y_{3} < y_{4} < y_{2})$ — coordinates of bottom left and top right corners of the chapel.\n\nThe third line contains two integers $w , h$ — width and height of the new grave $(1 \\le w , h \\le 10^{9}).$ Side with length $w$ should be placed along OX axis, side with length $h$ — along OY axis.\n\n", "outputFormat": "\n\nThe only line of the output file should contain single word: `Yes`, if it is possible to place the new grave, or `No`, if there is not enough space for it.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Grave", "background": "", "description": "\n\nGerard develops a Halloween computer game. The game is played on a rectangular graveyard with a rectangular chapel in it. During the game, the player places new rectangular graves on the graveyard. The grave should completely fit inside graveyard territory and should not overlap with the chapel. The grave may touch borders of the graveyard or the chapel.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qktc13ls.png)\n\nGerard asked you to write a program that determines whether it is possible to place a new grave of given size or there is no enough space for it.\n\n", "inputFormat": "\n\nThe first line of the input file contains two pairs of integers: $x_{1}, y_{1}, x_{2}, y_{2} (−10^{9} \\le x_{1} < x_{2} \\le 10^{9}; −10^{9} \\le y_{1} < y_{2} \\le 10^{9})$ — coordinates of bottom left and top right corners of the graveyard. The second line also contains two pairs of integers $x_{3}, y_{3}, x_{4}, y_{4} (x_{1} < x_{3} < x_{4} < x_{2}; y_{1} < y_{3} < y_{4} < y_{2})$ — coordinates of bottom left and top right corners of the chapel.\n\nThe third line contains two integers $w , h$ — width and height of the new grave $(1 \\le w , h \\le 10^{9}).$ Side with length $w$ should be placed along OX axis, side with length $h$ — along OY axis.\n\n", "outputFormat": "\n\nThe only line of the output file should contain single word: `Yes`, if it is possible to place the new grave, or `No`, if there is not enough space for it.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Grave", "background": "", "description": "Gerard 开发了一款万圣节电脑游戏。游戏在一个矩形墓地上进行，墓地中有一个矩形教堂。在游戏中，玩家需要在墓地上放置新的矩形墓碑。墓碑必须完全放置在墓地范围内，并且不能与教堂重叠。墓碑可以接触墓地或教堂的边界。\n\nGerard 要求你编写一个程序，判断是否可以放置给定大小的新墓碑，或者是否没有足够的空间。", "inputFormat": "输入文件的第一行包含两对整数：$x_{1}, y_{1}, x_{2}, y_{2} (-10^{9} \\le x_{1} < x_{2} \\le 10^{9}; -10^{9} \\le y_{1} < y_{2} \\le 10^{9})$——墓地左下角和右上角的坐标。第二行也包含两对整数 $x_{3}, y_{3}, x_{4}, y_{4} (x_{1} < x_{3} < x_{4} < x_{2}; y_{1} < y_{3} < y_{4} < y_{2})$——教堂左下角和右上角的坐标。\n\n第三行包含两个整数 $w , h$——新墓碑的宽度和高度 $(1 \\le w , h \\le 10^{9})$。长度为 $w$ 的边应沿 OX 轴放置，长度为 $h$ 的边应沿 OY 轴放置。", "outputFormat": "输出文件的唯一一行应包含一个单词：如果可以放置新墓碑，则为 `Yes`，如果没有足够的空间，则为 `No`。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7067", "type": "P", "difficulty": 5, "samples": [["8\n1000000 0 0 1000000 1000000 150000 600000 600000 400000\n0 1000000 0 600000 600000 400000 600000 1000000 300000\n0 1000000 0 400000 300000 150000 600000 600000 400000\n400000 0 200000 1000000 0 0 400000 300000 150000\n400000 300000 150000 1000000 0 0 600000 600000 400000\n600000 600000 400000 1000000 1000000 150000 600000 1000000 300000\n0 0 0 400000 0 200000 400000 300000 150000\n0 1000000 0 0 0 0 400000 300000 150000\n100000 700000 37500\n900000 400000 137500\n", "4\n100000 700000 37500\n400000 300000 150000\n900000 150000 100000\n900000 400000 137500\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Hiking in the Hills", "background": "", "description": "\n\nHelen is hiking with her friends in a highland. Their plan is to hike from their camp $A$ to a beautiful showplace $B$ .\n\nUnfortunately, Helen started feeling dizzy due to altitude sickness. Help her group find a route such that the topmost height on that route is as small as possible.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o2199eky.png)\n", "inputFormat": "\n\nThe input file contains full information about the landscape of a square region $10^{6} \\times 10^{6}$ in the following format. The first line contains integer $n$ — the number of triangles in the landscape $(2 \\le n \\le 2000)$ . Each of following $n$ lines contains nine integers $x_{i_1}, y_{i_1}, z_{i_1}, x_{i_2}, y_{i_2}, z_{i_2}, x_{i3}, y_{i3}, z_{i3}$ — coordinates of a triangle. All coordinates belong to the closed interval $[0 , 10^{6}]$. The two last lines contain three integers each: $x_{A}, y_{A}, z_{A}$ and $x_{B}, y_{B}, z_{B}$ — coordinates of the camp A and the showplace $B$ .\n\nThe given triangles are guaranteed to describe a consistent continuous landscape. Projections of triangles onto $XY$ plane are non-degenerate and fill the square without overlapping. A vertex of one triangle never lays inside an edge of another triangle. Points $A$ and $B$ belong to the landscape surface and are different.\n\n", "outputFormat": "\n\nOutput a polyline route from $A$ to $B$ with the smallest possible topmost height. The first line should contain $m$ , the number of vertices in this polyline. Each of following $m$ lines should contain three integer coordinates of a polyline vertex: $x_{i}, y_{i},$ and $z_{i}.$ Vertices must be listed along the polyline, from $A$ to $B$ (including these two endpoints).\n\nAll coordinates of polyline vertices should be integer. Each polyline edge must belong to some triangle from the input file (possibly, to its edge). The number of vertices in the polyline must not exceed $5n$.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Hiking in the Hills", "background": "", "description": "\n\nHelen is hiking with her friends in a highland. Their plan is to hike from their camp $A$ to a beautiful showplace $B$ .\n\nUnfortunately, Helen started feeling dizzy due to altitude sickness. Help her group find a route such that the topmost height on that route is as small as possible.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o2199eky.png)\n", "inputFormat": "\n\nThe input file contains full information about the landscape of a square region $10^{6} \\times 10^{6}$ in the following format. The first line contains integer $n$ — the number of triangles in the landscape $(2 \\le n \\le 2000)$ . Each of following $n$ lines contains nine integers $x_{i_1}, y_{i_1}, z_{i_1}, x_{i_2}, y_{i_2}, z_{i_2}, x_{i3}, y_{i3}, z_{i3}$ — coordinates of a triangle. All coordinates belong to the closed interval $[0 , 10^{6}]$. The two last lines contain three integers each: $x_{A}, y_{A}, z_{A}$ and $x_{B}, y_{B}, z_{B}$ — coordinates of the camp A and the showplace $B$ .\n\nThe given triangles are guaranteed to describe a consistent continuous landscape. Projections of triangles onto $XY$ plane are non-degenerate and fill the square without overlapping. A vertex of one triangle never lays inside an edge of another triangle. Points $A$ and $B$ belong to the landscape surface and are different.\n\n", "outputFormat": "\n\nOutput a polyline route from $A$ to $B$ with the smallest possible topmost height. The first line should contain $m$ , the number of vertices in this polyline. Each of following $m$ lines should contain three integer coordinates of a polyline vertex: $x_{i}, y_{i},$ and $z_{i}.$ Vertices must be listed along the polyline, from $A$ to $B$ (including these two endpoints).\n\nAll coordinates of polyline vertices should be integer. Each polyline edge must belong to some triangle from the input file (possibly, to its edge). The number of vertices in the polyline must not exceed $5n$.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Hiking in the Hills", "background": "", "description": "H正在和她的朋友在高原徒步，他们计划着从他们的营地A徒步到一个风景名胜B。\n\n可惜的是，H有了点高原反应。请你帮助他们找到一条路线，使该路线的最高高度尽可能小。\n![](https://cdn.luogu.com.cn/upload/image_hosting/o2199eky.png)（$1:10^5$）", "inputFormat": "输入数据包含整个$10^6 \\times 10^6$的的完整信息，格式如下：\n\n第一行包含了一个整数$n$，表示着这个空间内的三角形的数量。接下来的$n$行，每行包含九个整数，分别是\n$x_{i_1},y_{i_1},z_{i_1},x_{i_2},y_{i_2},z_{i_2},x_{i_3},y_{i_3},z_{i_3}$\n，是一个三角形的坐标。每个三角形的坐标都在区间[$0, 10^6$]之间。最后两行分别包含了A处的坐标和B处的坐标。\n\n给定的三角形保证在一个一致的坐标系。三角形在XY平面上的投影是非简并的，并且填充正方形而不重叠。一个三角形的顶点永远不会位于另一个三角形的边内。A点和B点属于同一个坐标系，且两者不同位置。", "outputFormat": "输出从A到B的路线，其最高高度可能最小。第一行应包含m，即此多段线中的顶点数。下面的每m条线都应该包含多段线顶点的三个整数坐标。\n\n顶点必须沿路线列出，从A到B（包括这两个端点）。\n路线顶点的所有坐标都应为整数。每个多段线边必须属于输入文件（可能是其边）中的某个三角形。路线的拐点数不能超过5n。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7068", "type": "P", "difficulty": 0, "samples": [["7\ns 0\ns 1\ns 1\np 2 a\np 2 b\np 3 c\np 3 d\n5\n0 a\n1 c\n3 b\n4 a\n5 d\n", "6\n1 2\n1 4\n2 4\n2 6\n1 6\n3 7\n"], ["5\ns 0\np 1 y\ns 1\np 3 z\np 3 x\n3\n7 y\n8 y\n15 y\n", "0\n"], ["3\ns 0\np 1 y\np 1 z\n3\n7 y\n8 y\n10 y\n", "5\n1 1\n1 2\n1 2\n1 3\n1 200\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Instruction", "background": "", "description": "\n\nIngrid is a head of a big railway station and, among other duties, is responsible for routing trains to the right platforms. The station has one entrance, and there are many switches that direct trains to other switches and platforms.\n\nEach switch has one inbound track and two outbound tracks, platforms have one inbound track, and station entrance has one outbound track. Each outbound track is connected to one inbound track and vice versa. Every switch and platform is reachable from station entrance.\n\nPlatforms have a rail dead ends and you may assume that trains disappear from the platform immediately after arriving to it.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i6zwkhqd.png)\n\nEach morning Ingrid looks at the timetable and writes switch toggling instruction: when and which switch to toggle. She would like to automate this process to save a lot of time.\n\n", "inputFormat": "\n\nThe first line of the input file contains a single integer $n$ — the total number of switches and platforms on the station $(3 \\le n \\le 51)$ .\n\nThe i-th of the following $n$ lines describes a switch or a platform with an index $i$ . Description starts with a character `p` for a platform or `s` for a switch. Next number $q_{i}$ indicates the number of the switch the inbound track is connected to or $0$ if it is connected to station entrance $(0 \\le q_{i} < i)$ . Description of the platform also contains a unique lowercase English letter — the platform identifier.\n\nTrains spend exactly one minute to move between two connected switches or a switch and a platform. In the morning, each switch is toggled in a way that a train would pass to the one of the two outbound tracks connected to the switch/platform with the lower number.\n\nNext line of the input file contains a single integer $m (1 \\le m \\le 1000)$ — the number of trains in timetable.\n\nEach of the following $m$ lines contains integer $a_{i} (0 \\le a_{i} \\le 10 000$ ; $a_{i} > a_{i−1})$ — the time in minutes when a train arrives to the station entrance, and the letter $p_{i}$ — identifier of the destination platform for this train.\n\n", "outputFormat": "\n\nIn the first line output integer $c$ — the number of commands in the switch toggling instruction. For each command, output two integers $s_{i}$ and $t_{i} (1 \\le s_{i} \\le n$ ; $0 \\le t_{i} \\le 10^{9})$ — the number of the switch and the time to toggle it. Assume that the switch is toggled between minutes $t_{i} − 1$ and $t_{i}.$\n\nOutput commands in order of non-decreasing time. The number of commands should not exceed $100 000$ .\n\n", "hint": "Below is the time trace for the first example.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j38jeq0g.png)\n\nTime limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Instruction", "background": "", "description": "\n\nIngrid is a head of a big railway station and, among other duties, is responsible for routing trains to the right platforms. The station has one entrance, and there are many switches that direct trains to other switches and platforms.\n\nEach switch has one inbound track and two outbound tracks, platforms have one inbound track, and station entrance has one outbound track. Each outbound track is connected to one inbound track and vice versa. Every switch and platform is reachable from station entrance.\n\nPlatforms have a rail dead ends and you may assume that trains disappear from the platform immediately after arriving to it.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i6zwkhqd.png)\n\nEach morning Ingrid looks at the timetable and writes switch toggling instruction: when and which switch to toggle. She would like to automate this process to save a lot of time.\n\n", "inputFormat": "\n\nThe first line of the input file contains a single integer $n$ — the total number of switches and platforms on the station $(3 \\le n \\le 51)$ .\n\nThe i-th of the following $n$ lines describes a switch or a platform with an index $i$ . Description starts with a character `p` for a platform or `s` for a switch. Next number $q_{i}$ indicates the number of the switch the inbound track is connected to or $0$ if it is connected to station entrance $(0 \\le q_{i} < i)$ . Description of the platform also contains a unique lowercase English letter — the platform identifier.\n\nTrains spend exactly one minute to move between two connected switches or a switch and a platform. In the morning, each switch is toggled in a way that a train would pass to the one of the two outbound tracks connected to the switch/platform with the lower number.\n\nNext line of the input file contains a single integer $m (1 \\le m \\le 1000)$ — the number of trains in timetable.\n\nEach of the following $m$ lines contains integer $a_{i} (0 \\le a_{i} \\le 10 000$ ; $a_{i} > a_{i−1})$ — the time in minutes when a train arrives to the station entrance, and the letter $p_{i}$ — identifier of the destination platform for this train.\n\n", "outputFormat": "\n\nIn the first line output integer $c$ — the number of commands in the switch toggling instruction. For each command, output two integers $s_{i}$ and $t_{i} (1 \\le s_{i} \\le n$ ; $0 \\le t_{i} \\le 10^{9})$ — the number of the switch and the time to toggle it. Assume that the switch is toggled between minutes $t_{i} − 1$ and $t_{i}.$\n\nOutput commands in order of non-decreasing time. The number of commands should not exceed $100 000$ .\n\n", "hint": "Below is the time trace for the first example.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j38jeq0g.png)\n\nTime limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Instruction", "background": "", "description": "英格丽德是一家大型火车站的站长，除其他职责外，还负责将火车开到正确的站台。车站有一个入口，有许多道岔将列车引导至其他道岔和站台。\n\n每个道岔有一条入站轨道和两条出站轨道，站台有一条入站轨道，车站入口有一条出站轨道。每个出站磁道连接到一个入站磁道，反之亦然。每个道岔和站台都可以从车站入口到达。\n\n月台有一个铁路死胡同，你可以假设火车到达月台后立即从月台上消失。\n\n每天早上，英格丽德都会查看时间表，并编写切换指令：何时以及切换哪个开关。她希望将此过程自动化以节省大量时间。", "inputFormat": "输入文件的第一行包含一个整数n—站点上交换机和平台的总数\n\n以下n行的第i行描述了具有索引i的交换机或平台。说明以字符p开头表示平台，以字符s开头表示交换机。下一个数字q`i`表示入站轨道连接到的道岔的编号，如果连接到车站入口，则表示0(0≤q$i$≤i)平台说明还包含一个唯一的小写英文字母 -- 平台标识符。\n\n列车在两个相连的道岔或道岔与站台之间移动只需一分钟。早上，每一个道岔都会以一种方式进行切换，列车将通过连接到道岔/站台的两条出站轨道中编号较低的一条。\n输入文件的下一行包含一个整数m(0≤m≤1000) -- 时刻表上的列车数量。\n\n以下m行中的每一行都包含整数a*i* (0≤a$i$ ≤10000;a$i$>a$i-1$) -- 列车到达车站入口的时间（以分钟为单位），以及字母p*i* -- 列车目的站台的标识符。", "outputFormat": "在第一行输出整数c中，开关切换指令中的命令数。对于每个命令，输出两个整数 s`i`和 t$i$ (1≤s$i$ ≤n;0≤ t$i$ ≤10^9) -- 开关的编号和切换开关的时间。假设开关在分钟之间切换 t$i$-1 和 `t`。\n\n按非递减时间顺序输出命令。命令的数量不应超过100000。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7069", "type": "P", "difficulty": 4, "samples": [["1 1 7 4\n2 3 10\n0 1 2\n2 2 0", "Yes\n3 2.5\n5 2.5\n7 4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Joy of Flight", "background": "", "description": "Jacob likes to play with his radio-controlled aircraft. The weather today is pretty windy and Jacob has to plan flight carefully. He has a weather forecast — the speed and direction of the wind for every second of the planned flight.\n\nThe plane may have airspeed up to $v_{\\max}$ units per second in any direction. The wind blows away plane in the following way: if airspeed speed of the plane is $(v_x, v_y)$ and the wind speed is $(w_x, w_y)$, the plane moves by $(v_x+w_x, v_y+w_y)$ each second.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2uyb1zpd.png)\n\nJacob has a fuel for exactly $k$ seconds, and he wants to learn, whether the plane is able to fly from start to finish in this time. If it is possible he needs to know the flight plan: the position of the plane after every second of flight.", "inputFormat": "The first line of the input file contains four integers $S_x, S_y, F_x, F_y$ — coordinates of start and finish ($−10 000 ≤ S_x, S_y, F_x, F_y ≤ 10 000$).\n\nThe second line contains three integers $n, k$ and $v_{\\max}$ — the number of wind condition changes, duration of Jacob’s flight in seconds and maximum aircraft speed ($1 ≤ n, k, v_{\\max} ≤ 10 000$).\n\nThe following $n$ lines contain the wind conditions description. The $i$-th of these lines contains integers $t_i, w_{x_i}$ and $w_{y_i}$ — starting at time $t_i$ the wind will blow by vector $(w_{x_i}, w_{y_i})$ each second ($0 = t_1 < ··· < t_i < t_{i+1} < ··· < k; \\sqrt{w_{x_i}^2 + w_{y_i}^2} ≤ v_{\\max}$).", "outputFormat": "The first line must contain `Yes` if Jacob’s plane is able to fly from start to finish in k seconds, and `No` otherwise.\n\nIf it can to do that, the following $k$ lines must contain the flight plan. The $i$-th of these lines must contain two floating point numbers $x$ and $y$ — the coordinates of the position ($P_i$) of the plane after $i$-th second of the flight.\n\nThe plan is correct if for every $1 ≤ i ≤ k$ it is possible to fly in one second from $P_{i−1}$ to some point $Q_i$, such that distance between $Q_i$ and $P_i$ doesn’t exceed $10^{−5}$, where $P_0 = S$. Moreover the distance between $P_k$ and $F$ should not exceed $10^{-5}$ as well.", "hint": "Time limit: 2 s, Memory limit: 256 MB.", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Joy of Flight", "background": "", "description": "Jacob likes to play with his radio-controlled aircraft. The weather today is pretty windy and Jacob has to plan flight carefully. He has a weather forecast — the speed and direction of the wind for every second of the planned flight.\n\nThe plane may have airspeed up to $v_{\\max}$ units per second in any direction. The wind blows away plane in the following way: if airspeed speed of the plane is $(v_x, v_y)$ and the wind speed is $(w_x, w_y)$, the plane moves by $(v_x+w_x, v_y+w_y)$ each second.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2uyb1zpd.png)\n\nJacob has a fuel for exactly $k$ seconds, and he wants to learn, whether the plane is able to fly from start to finish in this time. If it is possible he needs to know the flight plan: the position of the plane after every second of flight.", "inputFormat": "The first line of the input file contains four integers $S_x, S_y, F_x, F_y$ — coordinates of start and finish ($−10 000 ≤ S_x, S_y, F_x, F_y ≤ 10 000$).\n\nThe second line contains three integers $n, k$ and $v_{\\max}$ — the number of wind condition changes, duration of Jacob’s flight in seconds and maximum aircraft speed ($1 ≤ n, k, v_{\\max} ≤ 10 000$).\n\nThe following $n$ lines contain the wind conditions description. The $i$-th of these lines contains integers $t_i, w_{x_i}$ and $w_{y_i}$ — starting at time $t_i$ the wind will blow by vector $(w_{x_i}, w_{y_i})$ each second ($0 = t_1 < ··· < t_i < t_{i+1} < ··· < k; \\sqrt{w_{x_i}^2 + w_{y_i}^2} ≤ v_{\\max}$).", "outputFormat": "The first line must contain `Yes` if Jacob’s plane is able to fly from start to finish in k seconds, and `No` otherwise.\n\nIf it can to do that, the following $k$ lines must contain the flight plan. The $i$-th of these lines must contain two floating point numbers $x$ and $y$ — the coordinates of the position ($P_i$) of the plane after $i$-th second of the flight.\n\nThe plan is correct if for every $1 ≤ i ≤ k$ it is possible to fly in one second from $P_{i−1}$ to some point $Q_i$, such that distance between $Q_i$ and $P_i$ doesn’t exceed $10^{−5}$, where $P_0 = S$. Moreover the distance between $P_k$ and $F$ should not exceed $10^{-5}$ as well.", "hint": "Time limit: 2 s, Memory limit: 256 MB.", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Joy of Flight", "background": "", "description": "大意就是一架飞机要从起点飞到终点，飞机有最大空速，飞行最大时间，给出风速的变化和风如何影响飞机飞行，求出飞机是否能到达终点，如果能就输出飞机的位置变化。\n\n\n雅各布（Jacob）喜欢玩他的无线电摇制飞机。今天的风很大，雅各布必须小心地计划飞行。他有一个天气预报——飞行计划中每秒钟的风速和风向。\n\n飞机每秒在任何方向的空速最大都可以达到 $v_{max}$ 。风吹动飞机的方式如下：如果飞机的空速是 $(v_x,v_y)$ 并且风速是 $(w_x,w_y)$ ，那么飞机每秒将移动 $(v_x+w_x,v_y+w_y)$ 。\n\n![P7069-1](https://cdn.luogu.com.cn/upload/image_hosting/2uyb1zpd.png)\n\n雅各布（Jacob）有一种刚好能使用$k$秒的燃料，他想知道，飞机是否能在这段时间内从起点飞到终点。如果可能的话，他需要知道飞行计划：每飞行一秒后飞机的位置。", "inputFormat": "输入文件的第一行有四个整数 $S_x,S_y,F_x,F_y$ ，代表起始位置 $(-10000 \\le S_x,S_y,F_x,F_y \\le 10000)$ 。\n\n第二行有三个整数 $n,k 和 v_{max}$ ——风况变化的次数，雅各布（Jacob）飞行持续的时间（以秒为单位）和飞机最大空速。\n\n剩下的 $n$ 行是对风向的描述，第 $i$ 行有三个整数 $t_i,w_{xi} 和 w_{yi}$ ——从时间 $t_i$ 开始，风速为每秒 $(w_{xi},w_{yi})$ （一个向量） $(0=t_1< \\cdots <t_i<t_{i+1}< \\cdots <k; \\sqrt{{w^2_{xi}}+{w^2_{yi}}} \\le v_{max})$ 。", "outputFormat": "如果 $k$ 秒内雅各布（Jacob）的飞机能从起点飞到终点则应输出 `Yes` ，否则输出 `No` 。\n\n如果它能飞到，接下来的 $k$ 行必须包括飞行计划。第 $i$ 行必须包括两个浮点数 $x$ 和 $y$ （保留几位貌似没说）——飞行了第 $i$ 秒的平面位置 $(P_i)$ 。\n\n如果对于每个 $1 \\le i \\le k$ 都能在一秒内从点 $P_{i-1}$ 飞到某个点 $Q_i$ ，使得 $Q_i$ 和 $P_i$ 间距离不超过 $10^{-5}$ ，其中 $P_0=S$ ，那么这个计划就是正确的。此外 $P_k$ 和 $F$ 间的距离也应不超过 $10^{-5}$ 。", "hint": "时间限制： $2s$ ；内存限制： $256MB$ \n\nby XYY1411\n\n2020/12/08", "locale": "zh-CN"}}}
