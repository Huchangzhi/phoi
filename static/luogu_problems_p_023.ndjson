{"pid": "P6820", "type": "P", "difficulty": 5, "samples": [["3\n1 2 3\n3 2 1", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2012", "PA（波兰）"], "title": "[PA 2012 Finals] Two Cakes", "background": "", "description": "你有两个 $1\\sim n$ 的排列。你用左手和右手分别从左到右写两个排列，每只手每写一个数需要 $1$ 单位时间，两只手可以同时工作。若你两只手不能同时写同一个数，那你至少需要多久写完这两个排列呢？", "inputFormat": "第一行一个正整数 $n$。\n\n接下来一行 $n$ 个整数，为一个 $1\\sim n$ 的排列。\n\n接下来一行 $n$ 个整数，为另一个 $1\\sim n$ 的排列。", "outputFormat": "仅一个整数，为最短时间。", "hint": "**样例解释**\n\n第一单位时间：左手写 $1$，右手写 $3$。\n\n第二单位时间：左手写 $2$。\n\n第三单位时间：右手写 $2$。\n\n第四单位时间：左手写 $3$，右手写 $1$。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，$1\\le n\\le 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2012 Finals] Two Cakes", "background": "", "description": "你有两个 $1\\sim n$ 的排列。你用左手和右手分别从左到右写两个排列，每只手每写一个数需要 $1$ 单位时间，两只手可以同时工作。若你两只手不能同时写同一个数，那你至少需要多久写完这两个排列呢？", "inputFormat": "第一行一个正整数 $n$。\n\n接下来一行 $n$ 个整数，为一个 $1\\sim n$ 的排列。\n\n接下来一行 $n$ 个整数，为另一个 $1\\sim n$ 的排列。", "outputFormat": "仅一个整数，为最短时间。", "hint": "**样例解释**\n\n第一单位时间：左手写 $1$，右手写 $3$。\n\n第二单位时间：左手写 $2$。\n\n第三单位时间：右手写 $2$。\n\n第四单位时间：左手写 $3$，右手写 $1$。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，$1\\le n\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P6821", "type": "P", "difficulty": 6, "samples": [["5 2\n7 -3 4 -9 5", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2012", "O2优化", "PA（波兰）"], "title": "[PA 2012] Tanie linie", "background": "PA 2012 R5.", "description": "给定含 $n$ 个数的序列，求至多 $k$ 个不相交子段的和的最大值。", "inputFormat": "第一行两个正整数 $n,k$。\n\n接下来一行 $n$ 个整数，为这个序列。", "outputFormat": "输出一个整数，为答案。", "hint": "对于 $100\\%$ 的数据，$1\\le k\\le n\\le 10^6$。序列内所有数在 $[-10^9,10^9]$ 内。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2012] Tanie linie", "background": "PA 2012 R5.", "description": "给定含 $n$ 个数的序列，求至多 $k$ 个不相交子段的和的最大值。", "inputFormat": "第一行两个正整数 $n,k$。\n\n接下来一行 $n$ 个整数，为这个序列。", "outputFormat": "输出一个整数，为答案。", "hint": "对于 $100\\%$ 的数据，$1\\le k\\le n\\le 10^6$。序列内所有数在 $[-10^9,10^9]$ 内。", "locale": "zh-CN"}}}
{"pid": "P6822", "type": "P", "difficulty": 6, "samples": [["4 5\n1 2 5\n1 3 2\n2 3 1\n2 4 4\n3 4 8", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2012", "PA（波兰）"], "title": "[PA 2012 Finals] Tax", "background": "", "description": "给出一个 $n$ 个点 $m$ 条边的无向图，经过一个点的代价是进入和离开这个点的两条边的边权的较大值，求从起点 $1$ 到点 $n$ 的最小代价。起点的代价是离开起点的边的边权，终点的代价是进入终点的边的边权。", "inputFormat": "第一行两个数 $n,m$，分别表示点数和边数。\n\n接下来 $m$ 行，每行三个数 $a,b,c$，表示 $a,b$ 之间存在一条长度为 $c$ 的边。\n\n", "outputFormat": "一行一个数，表示答案。", "hint": "$1\\leq n\\leq 10^5$，$1\\leq m\\leq 2\\times 10^5$，$1\\leq c\\leq 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2012 Finals] Tax", "background": "", "description": "给出一个 $n$ 个点 $m$ 条边的无向图，经过一个点的代价是进入和离开这个点的两条边的边权的较大值，求从起点 $1$ 到点 $n$ 的最小代价。起点的代价是离开起点的边的边权，终点的代价是进入终点的边的边权。", "inputFormat": "第一行两个数 $n,m$，分别表示点数和边数。\n\n接下来 $m$ 行，每行三个数 $a,b,c$，表示 $a,b$ 之间存在一条长度为 $c$ 的边。\n\n", "outputFormat": "一行一个数，表示答案。", "hint": "$1\\leq n\\leq 10^5$，$1\\leq m\\leq 2\\times 10^5$，$1\\leq c\\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P6823", "type": "P", "difficulty": 2, "samples": [["5 5\n1\n2\n3 2 4\n4\n3 1 5", "5 4 3 2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": [], "title": "「EZEC-4」paulzrm Loves Array", "background": "原题面：\n\n$\\color{gray}\\text{zrmpaul}$ has an array consisting of $n$ integers: $a_1,a_2,...,a_n$. The initial value of $a_i$ is $i(1\\le i\\le n)$. There are $m$ operations, including four types as follows.\n\nType $1$: `1` sort the array.   \nType $2$: `2` sort the array and reverse it.   \nType $3$: `3 x y` swap $a_x,a_y$. **It is guaranteed that $x$ is not equal to $y$, and $1\\leq x ,y \\leq n$**.    \nType $4$: `4` reverse the array.\n\nYou need to output the array after $m$ operations.\n\nFirst line with two intergers $n,m(1\\leq n,m\\leq 10^6)$.\n\nNext $m$ lines are the operations.\n\nOne line, $n$ numbers, the array.", "description": "小 Z 有一个下标从 $1$ 开始并且长度为 $n$ 的序列，初始时下标为 $i$ 位置的数字为 $i$。有 $m$ 个操作，每个操作会是以下四种之一。\n\n- `1` 对序列从小到大进行排序。\n- `2` 对序列从小到大进行排序后将其翻转，(译者注：就是从大到小排序）。\n- `3 x y` 将下标为 $x,y$ 的数交换位置。保证 $x\\neq y$ 且 $1\\le x,y\\le n$。\n- `4` 将序列翻转。\n\n你要输出在 $m$ 次操作后的序列。", "inputFormat": "第一行两个整数 $n,m$ ，表示序列的长度以及操作的数量。\n\n接下来 $m$ 行，每行一个操作。保证操作合法。", "outputFormat": "一行包含 $n$ 个整数，表示操作后的序列。", "hint": "【数据范围】\n\n**【本题采用捆绑测试】**\n\nsubtask 1（24pts）: $1\\leq n,m\\leq 2 \\times 10^3$ 。\n\nsubtask 2（13pts）: 没有操作三。\n\nsubtask 3（63pts）: $1\\leq n,m\\leq 10^6$ 。\n\n\n【样例解释】\n\n序列经过的操作为：\n> $1, 2, 3, 4, 5$     \n$1, 2, 3, 4, 5$   \n$5, 4, 3, 2, 1$   \n$5, 2, 3, 4, 1$   \n$1, 4, 3, 2, 5$   \n$5, 4, 3, 2, 1$\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「EZEC-4」paulzrm Loves Array", "background": "原题面：\n\n$\\color{gray}\\text{zrmpaul}$ has an array consisting of $n$ integers: $a_1,a_2,...,a_n$. The initial value of $a_i$ is $i(1\\le i\\le n)$. There are $m$ operations, including four types as follows.\n\nType $1$: `1` sort the array.   \nType $2$: `2` sort the array and reverse it.   \nType $3$: `3 x y` swap $a_x,a_y$. **It is guaranteed that $x$ is not equal to $y$, and $1\\leq x ,y \\leq n$**.    \nType $4$: `4` reverse the array.\n\nYou need to output the array after $m$ operations.\n\nFirst line with two intergers $n,m(1\\leq n,m\\leq 10^6)$.\n\nNext $m$ lines are the operations.\n\nOne line, $n$ numbers, the array.", "description": "小 Z 有一个下标从 $1$ 开始并且长度为 $n$ 的序列，初始时下标为 $i$ 位置的数字为 $i$。有 $m$ 个操作，每个操作会是以下四种之一。\n\n- `1` 对序列从小到大进行排序。\n- `2` 对序列从小到大进行排序后将其翻转，(译者注：就是从大到小排序）。\n- `3 x y` 将下标为 $x,y$ 的数交换位置。保证 $x\\neq y$ 且 $1\\le x,y\\le n$。\n- `4` 将序列翻转。\n\n你要输出在 $m$ 次操作后的序列。", "inputFormat": "第一行两个整数 $n,m$ ，表示序列的长度以及操作的数量。\n\n接下来 $m$ 行，每行一个操作。保证操作合法。", "outputFormat": "一行包含 $n$ 个整数，表示操作后的序列。", "hint": "【数据范围】\n\n**【本题采用捆绑测试】**\n\nsubtask 1（24pts）: $1\\leq n,m\\leq 2 \\times 10^3$ 。\n\nsubtask 2（13pts）: 没有操作三。\n\nsubtask 3（63pts）: $1\\leq n,m\\leq 10^6$ 。\n\n\n【样例解释】\n\n序列经过的操作为：\n> $1, 2, 3, 4, 5$     \n$1, 2, 3, 4, 5$   \n$5, 4, 3, 2, 1$   \n$5, 2, 3, 4, 1$   \n$1, 4, 3, 2, 5$   \n$5, 4, 3, 2, 1$\n\n", "locale": "zh-CN"}}}
{"pid": "P6824", "type": "P", "difficulty": 4, "samples": [["3 5\n2\n3\n4", "3"], ["4 625\n879\n480\n671\n853\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "字典树 Trie", "差分"], "title": "「EZEC-4」可乐", "background": "很久以前，有一个 pigstd，非常迷恋美味的可乐。为了得到美味的可乐，他几乎用尽了所有的钱，他甚至对自己的 npy 也漠不关心~~其实是因为他没有 npy~~，更不爱好看戏。除非买了新可乐，才会坐上马车出门炫耀一番。每一天，每个钟头他都要喝上一瓶新可乐。\n\npigstd 最近又买了许多箱新可乐——当然，这些可乐只有聪明的人才能喝到。", "description": "pigstd 现在有 $n$ 箱可乐，第 $i$ 箱可乐上标着一个正整数 $a_{i}$。\n\n若 pigstd 的聪明值为一个非负整数 $x$，对于第 $i$ 箱可乐，如果 $(a_{i} \\oplus x )\\le k$，那么 pigstd 就能喝到这箱可乐。\n\n现在 pigstd 告诉了你 $k$ 与序列 $a$，你可以决定 pigstd 的聪明值 $x$，使得他能喝到的可乐的箱数最大。求出这个最大值。", "inputFormat": "第一行两个由空格分隔开的整数 $n,k$。\n\n接下来 $n$ 行，每行一个整数 $a_i$，表示第 $i$ 箱可乐上标的数。", "outputFormat": "一行一个正整数，表示 pigstd 最多能喝到的可乐的箱数。", "hint": "### 提示\n\n**pigstd 的聪明值 $x$ 可以为 $0$。**\n\n### 样例解释\n\n样例 1 解释：容易构造当 $x = 0$ 时，可以喝到所有可乐。\n\n样例 2 解释：容易构造 $x = 913$，可以喝到所有可乐。\n\n**样例解释未必是唯一的方法。**\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n- Subtask 1（29 points）：$1 \\le n,k,a_{i} \\le 1000$。\n\n- Subtask 2（1 points）：$a_{i} \\le k$。\n\n- Subtask 3（70 points）：无特殊限制。\n\n对于所有数据，保证 $1 \\le n,k,a_{i} \\le 10^6$。\n\n$\\oplus$ 代表异或，如果您不知道什么是异或，请单击[这里](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677?fr=aladdin)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「EZEC-4」可乐", "background": "很久以前，有一个 pigstd，非常迷恋美味的可乐。为了得到美味的可乐，他几乎用尽了所有的钱，他甚至对自己的 npy 也漠不关心~~其实是因为他没有 npy~~，更不爱好看戏。除非买了新可乐，才会坐上马车出门炫耀一番。每一天，每个钟头他都要喝上一瓶新可乐。\n\npigstd 最近又买了许多箱新可乐——当然，这些可乐只有聪明的人才能喝到。", "description": "pigstd 现在有 $n$ 箱可乐，第 $i$ 箱可乐上标着一个正整数 $a_{i}$。\n\n若 pigstd 的聪明值为一个非负整数 $x$，对于第 $i$ 箱可乐，如果 $(a_{i} \\oplus x )\\le k$，那么 pigstd 就能喝到这箱可乐。\n\n现在 pigstd 告诉了你 $k$ 与序列 $a$，你可以决定 pigstd 的聪明值 $x$，使得他能喝到的可乐的箱数最大。求出这个最大值。", "inputFormat": "第一行两个由空格分隔开的整数 $n,k$。\n\n接下来 $n$ 行，每行一个整数 $a_i$，表示第 $i$ 箱可乐上标的数。", "outputFormat": "一行一个正整数，表示 pigstd 最多能喝到的可乐的箱数。", "hint": "### 提示\n\n**pigstd 的聪明值 $x$ 可以为 $0$。**\n\n### 样例解释\n\n样例 1 解释：容易构造当 $x = 0$ 时，可以喝到所有可乐。\n\n样例 2 解释：容易构造 $x = 913$，可以喝到所有可乐。\n\n**样例解释未必是唯一的方法。**\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n- Subtask 1（29 points）：$1 \\le n,k,a_{i} \\le 1000$。\n\n- Subtask 2（1 points）：$a_{i} \\le k$。\n\n- Subtask 3（70 points）：无特殊限制。\n\n对于所有数据，保证 $1 \\le n,k,a_{i} \\le 10^6$。\n\n$\\oplus$ 代表异或，如果您不知道什么是异或，请单击[这里](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677?fr=aladdin)。", "locale": "zh-CN"}}}
{"pid": "P6825", "type": "P", "difficulty": 6, "samples": [["2\n2 1000000007\n3 998244353", "19\n752"], ["2\n4 998244353\n123456 1000000007", "66420\n3252328"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 3200, 3200, 3200, 3200, 3200, 6000, 6000, 6000, 6000, 6000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "O2优化"], "title": "「EZEC-4」求和", "background": "", "description": "给定正整数 $n$ 的值，求出下面这个式子的值：\n\n$$\\displaystyle\\sum_{i = 1}^n \\sum_{j = 1}^n \\gcd(i,j)^{i + j}$$\n\n由于结果可能很大，所以你只需要求出结果对 $p$ 取模的值。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n一行，两个正整数 $n, p$。", "outputFormat": "对于每组数据，输出一行，一个正整数，表示所求的值。", "hint": "\n**本题开启 O2 优化和捆绑测试。**\n\n**为了卡掉错解开大了数据范围，请注意常数因子对程序产生的影响。**\n\n### 样例解释\n#### 样例 #1\n对于第一组数据：$\\operatorname{ans} = \\gcd(1, 1)^2 + \\gcd(1, 2)^3 + \\gcd(2, 1)^3 + \\gcd(2, 2)^4 = 1^2 + 1^3 + 1^3 + 2^4 = 3 + 16 = 19$。所以答案为 $19 \\bmod (10^9 + 7) = 19$。\n### 数据范围\n\n| Subtask | $\\sum n$ | 分值 | 时限 |\n| :------: | :------: | :------: | :------: |\n| $1$ | $1 \\leq \\sum n \\leq 500$ | $10 \\operatorname{pts}$ | $1.00 \\operatorname{s}$ |\n| $2$ | $1 \\leq \\sum n \\leq 5 \\times 10^5$ | $40 \\operatorname{pts}$ | $3.20 \\operatorname{s}$ |\n| $3$ | 无特殊限制 | $50 \\operatorname{pts}$ | $6.00 \\operatorname{s}$ |\n\n对于 $100\\%$ 的数据，$1 \\leq \\sum n \\leq 1.5 \\times 10^6$，$2 \\leq p \\leq 2^{31} - 1$ 且 $p$ 为质数，$1 \\leq T \\leq 2$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「EZEC-4」求和", "background": "", "description": "给定正整数 $n$ 的值，求出下面这个式子的值：\n\n$$\\displaystyle\\sum_{i = 1}^n \\sum_{j = 1}^n \\gcd(i,j)^{i + j}$$\n\n由于结果可能很大，所以你只需要求出结果对 $p$ 取模的值。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n一行，两个正整数 $n, p$。", "outputFormat": "对于每组数据，输出一行，一个正整数，表示所求的值。", "hint": "\n**本题开启 O2 优化和捆绑测试。**\n\n**为了卡掉错解开大了数据范围，请注意常数因子对程序产生的影响。**\n\n### 样例解释\n#### 样例 #1\n对于第一组数据：$\\operatorname{ans} = \\gcd(1, 1)^2 + \\gcd(1, 2)^3 + \\gcd(2, 1)^3 + \\gcd(2, 2)^4 = 1^2 + 1^3 + 1^3 + 2^4 = 3 + 16 = 19$。所以答案为 $19 \\bmod (10^9 + 7) = 19$。\n### 数据范围\n\n| Subtask | $\\sum n$ | 分值 | 时限 |\n| :------: | :------: | :------: | :------: |\n| $1$ | $1 \\leq \\sum n \\leq 500$ | $10 \\operatorname{pts}$ | $1.00 \\operatorname{s}$ |\n| $2$ | $1 \\leq \\sum n \\leq 5 \\times 10^5$ | $40 \\operatorname{pts}$ | $3.20 \\operatorname{s}$ |\n| $3$ | 无特殊限制 | $50 \\operatorname{pts}$ | $6.00 \\operatorname{s}$ |\n\n对于 $100\\%$ 的数据，$1 \\leq \\sum n \\leq 1.5 \\times 10^6$，$2 \\leq p \\leq 2^{31} - 1$ 且 $p$ 为质数，$1 \\leq T \\leq 2$。", "locale": "zh-CN"}}}
{"pid": "P6826", "type": "P", "difficulty": 6, "samples": [["1\n2 3 5", "20"], ["2\n23333 23333 233233\n114514 19260817 1919810   ", "356712294\n125194507"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1500, 1500, 1500, 1500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "枚举", "前缀和"], "title": "「EZEC-4」月下轻花舞", "background": ">月下的轻花，随轻风飘舞，勾起了你我的记忆......\n\n![](http://p1.music.126.net/mi-oogxsSXkHwPACQRsxgw==/109951163115816964.jpg?param=557y315)", "description": "在轻花林中，有从 $l$ 到 $r$ 编号的轻花树，编号为 $i$ 的树有 $i-1$ 棵，轻花林很美，所以每棵树上都有编号为 $1\\sim n$ 的 $n$ 朵轻花，编号为 $i$ 的树上编号为 $j$ 的轻花落下会产生大小为 $\\left\\lceil\\log_ij\\right\\rceil$ 的魅力值。  \n\n夜幕降临，所有树上的所有轻花全部落下，花痴（雾）tlx 想知道总共有多大的魅力值，但是只算一次太简单了，所以他会设置不同情境询问你 $T$ 次，不过由于答案很大，你只需要告诉他魅力值总和对 $998244353$ 取模的结果。    \n\n**一句话题意**： $T$ 组询问，每次给定三个整数 $l,r,n$，求出下式的值： \n\n$$\\sum_{i=l}^r(i-1)\\sum_{j=1}^n \\left\\lceil\\log_ij\\right\\rceil\\;\\;\\bmod998244353$$", "inputFormat": "第一行一个整数 $T$，代表询问个数。  \n\n接下来 $T$ 行，每行三个整数 $l,r,n$，分别代表树编号的起始值，终止值，以及一棵树上轻花的朵数。", "outputFormat": "共 $T$ 行，每行一个整数，代表每一个询问的结果对 $998244353$ 取模的结果。", "hint": "**【数据范围与约束】**   \n\n**本题采用捆绑测试，具体约束如下：**  \n\n- Subtask 1 $(1\\text{ pts})$：$T=1$，$n=1$；   \n- Subtask 2 $(9\\text{ pts})$：$l=r=2$；   \n- Subtask 3 $(10\\text{ pts})$：$T=1$，$n\\leq 10^3$，$r\\leq 10^3$；   \n- Subtask 4 $(10\\text{ pts})$：$l=r\\not=2$；      \n- Subtask 5 $(20\\text{ pts})$：$T=1$，$n\\leq 10^6$；\n- Subtask 6 $(20\\text{ pts})$：$T=1$，$r\\leq 10^6$；\n- Subtask 7 $(20\\text{ pts})$：$T\\leq 3000$；\n- Subtask 8 $(10\\text{ pts})$：无特殊限制，时间限制 $1.5\\;\\text{s}$。\n\n对于所有数据，满足：  \n\n$1\\leq T\\leq 10^5$，$1\\leq n\\leq 10^{18}$，$2\\leq l\\leq r\\leq 10^{18}$。  \n\n**注意：在具体约束中没有提到的数据范围均为极限数据范围。**\n\n\n\n------------\n\n\n**【样例解释 #1】**   \n\n$$\\left\\lceil\\log_21\\right\\rceil+\\left\\lceil\\log_22\\right\\rceil+\\left\\lceil\\log_23\\right\\rceil+\\left\\lceil\\log_24\\right\\rceil+\\left\\lceil\\log_25\\right\\rceil=8$$\n\n$$\\left\\lceil\\log_31\\right\\rceil+\\left\\lceil\\log_32\\right\\rceil+\\left\\lceil\\log_33\\right\\rceil+\\left\\lceil\\log_34\\right\\rceil+\\left\\lceil\\log_35\\right\\rceil=6$$   \n\n故：\n\n$$ans=8×(2-1)+6×(3-1)=20$$   \n\n对于样例 #2，我相信您聪明的大脑可以分分钟得到答案的。\n\n\n\n------------\n\n**【其他提示】**  \n\n如果你不了解对数（$\\log$）运算,可以查看[这里](https://baike.baidu.com/item/对数公式/5557846?fr=aladdin)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「EZEC-4」月下轻花舞", "background": ">月下的轻花，随轻风飘舞，勾起了你我的记忆......\n\n![](http://p1.music.126.net/mi-oogxsSXkHwPACQRsxgw==/109951163115816964.jpg?param=557y315)", "description": "在轻花林中，有从 $l$ 到 $r$ 编号的轻花树，编号为 $i$ 的树有 $i-1$ 棵，轻花林很美，所以每棵树上都有编号为 $1\\sim n$ 的 $n$ 朵轻花，编号为 $i$ 的树上编号为 $j$ 的轻花落下会产生大小为 $\\left\\lceil\\log_ij\\right\\rceil$ 的魅力值。  \n\n夜幕降临，所有树上的所有轻花全部落下，花痴（雾）tlx 想知道总共有多大的魅力值，但是只算一次太简单了，所以他会设置不同情境询问你 $T$ 次，不过由于答案很大，你只需要告诉他魅力值总和对 $998244353$ 取模的结果。    \n\n**一句话题意**： $T$ 组询问，每次给定三个整数 $l,r,n$，求出下式的值： \n\n$$\\sum_{i=l}^r(i-1)\\sum_{j=1}^n \\left\\lceil\\log_ij\\right\\rceil\\;\\;\\bmod998244353$$", "inputFormat": "第一行一个整数 $T$，代表询问个数。  \n\n接下来 $T$ 行，每行三个整数 $l,r,n$，分别代表树编号的起始值，终止值，以及一棵树上轻花的朵数。", "outputFormat": "共 $T$ 行，每行一个整数，代表每一个询问的结果对 $998244353$ 取模的结果。", "hint": "**【数据范围与约束】**   \n\n**本题采用捆绑测试，具体约束如下：**  \n\n- Subtask 1 $(1\\text{ pts})$：$T=1$，$n=1$；   \n- Subtask 2 $(9\\text{ pts})$：$l=r=2$；   \n- Subtask 3 $(10\\text{ pts})$：$T=1$，$n\\leq 10^3$，$r\\leq 10^3$；   \n- Subtask 4 $(10\\text{ pts})$：$l=r\\not=2$；      \n- Subtask 5 $(20\\text{ pts})$：$T=1$，$n\\leq 10^6$；\n- Subtask 6 $(20\\text{ pts})$：$T=1$，$r\\leq 10^6$；\n- Subtask 7 $(20\\text{ pts})$：$T\\leq 3000$；\n- Subtask 8 $(10\\text{ pts})$：无特殊限制，时间限制 $1.5\\;\\text{s}$。\n\n对于所有数据，满足：  \n\n$1\\leq T\\leq 10^5$，$1\\leq n\\leq 10^{18}$，$2\\leq l\\leq r\\leq 10^{18}$。  \n\n**注意：在具体约束中没有提到的数据范围均为极限数据范围。**\n\n\n\n------------\n\n\n**【样例解释 #1】**   \n\n$$\\left\\lceil\\log_21\\right\\rceil+\\left\\lceil\\log_22\\right\\rceil+\\left\\lceil\\log_23\\right\\rceil+\\left\\lceil\\log_24\\right\\rceil+\\left\\lceil\\log_25\\right\\rceil=8$$\n\n$$\\left\\lceil\\log_31\\right\\rceil+\\left\\lceil\\log_32\\right\\rceil+\\left\\lceil\\log_33\\right\\rceil+\\left\\lceil\\log_34\\right\\rceil+\\left\\lceil\\log_35\\right\\rceil=6$$   \n\n故：\n\n$$ans=8×(2-1)+6×(3-1)=20$$   \n\n对于样例 #2，我相信您聪明的大脑可以分分钟得到答案的。\n\n\n\n------------\n\n**【其他提示】**  \n\n如果你不了解对数（$\\log$）运算,可以查看[这里](https://baike.baidu.com/item/对数公式/5557846?fr=aladdin)。", "locale": "zh-CN"}}}
{"pid": "P6827", "type": "P", "difficulty": 6, "samples": [["3 \n((()())(()\n(() 4\n() 2\n()()() 5", "32"], ["3\n())()))()\n()) 9\n()() 8\n())) 7", "73"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化", "分块", "状压 DP"], "title": "「EZEC-4」括号", "background": "> 离景似是昨日，转眼却已经年$\\newline$ 往事依旧，物是全非\n\n", "description": "给一个由小括号组成的序列和 $n$ 个括号串，要你在序列中匹配允许不连续的子串。\n\n母序列的每个括号最多被匹配一次。\n\n一种可能的不连续子串匹配方式为 ```)()(``` 中匹配 ``` ))(``` 。\n\n每个括号串有一个值 $v$，代表对这个串每匹配一个括号得到的价值。\n\n每个括号串均可以多次匹配，可以随时停止匹配，但是不能在未匹配完一个括号串的情况下开始匹配其他括号串。\n\n注意如果你跳过了母序列的某几个括号去匹配后面的，那么你将不能返回前面继续进行匹配。\n\n求匹配能得到的最大值。", "inputFormat": "第一行一个整数 $n$，表示括号串的个数。\n\n第二行一个字符串 $k$，表示给出的母序列。\n\n接下来 $n$ 行，每行一个括号串 $a$ 和一个数字 $v$。在这 $n$ 行中，第 $i$ 行的字符 $a_i,v_i$ 表示一个存在的括号串以及匹配这个括号串内一个括号所能得到的价值。\n\n\n\n", "outputFormat": "一个数 $r$，表示能取得的最大值。", "hint": "【温馨提示】\n\n**为了卡掉错解开大了数据范围，请注意常数因子对程序产生的影响。**\n\n【数据范围】\n\n**本题使用捆绑测试。**\n\n对于 $100\\%$ 的数据， $1 \\le n \\le 500, 1 \\le len(k) \\le 10^4, 1 \\le len(a) \\le 300,0 \\le v \\le 10^3$。\n\n| Subtask | $ n \\le$ | $ len(k) \\le$ | $ len(a) \\le$ |   时间 | 分值|特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |:----------: | :----------: |:----------: |\n| $1$ | $10$ | $7$| $7$ | $1\\text s$ |$5$|保证最优解每个 a 最多只用一次 |\n| $2$ | $10$ | $50$| $8$| $1\\text s$|$5$|数据随机，若 AC subtask3 则不计入总分|\n| $3$ | $10$ | $1000$| $8$| $1\\text s$|$10$|保证最优解每个 a 最多只用一次|\n| $4$ | $100$ | $10^4$ | $8$ | $1\\text s$ |$15$| 无 |\n| $5$ | $500$ | $10^4$ | $8$ | $1\\text s$ |$10$| 无 |\n| $6$ | $500$ | $10^4$ | $300$| $2.2\\text s$ |$60$| 无|\n\n【样例 $1$ 解释】\n\n最佳方案为先匹配 ```(()``` ，后匹配 ```()()()``` （ 注意最多只能匹配到 ```()()``` ），答案为 $4\\times3 + 5 \\times 4 = 32$。\n\n一种可行的匹配方法为方括号括起来的部分 ```(【(()()】)(【()】``` 。\n\n而若先匹配 ```(()``` ，再匹配 ```()``` ，最后匹配 ```(()``` 的价值为 $4\\times 3 + 2\\times 2 + 4\\times 3 = 28$，并非最佳方案。\n\n注意我们不能先匹配 ```(()``` ，再匹配 ```()()()``` 中一个括号，最后匹配 ```(()``` ，因为我们可以随时停止匹配，但不能在未匹配完某个串的情况下开始匹配另一个串。\n\n【样例 $2$ 解释】\n\n最佳方案先匹配 ```())```，再匹配 ```()))``` 最后匹配 ```())``` （ 注意最多只能匹配到 ```()``` ）, 答案为 $9\\times 3 + 7 \\times 4 + 9 \\times 2 = 73$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「EZEC-4」括号", "background": "> 离景似是昨日，转眼却已经年$\\newline$ 往事依旧，物是全非\n\n", "description": "给一个由小括号组成的序列和 $n$ 个括号串，要你在序列中匹配允许不连续的子串。\n\n母序列的每个括号最多被匹配一次。\n\n一种可能的不连续子串匹配方式为 ```)()(``` 中匹配 ``` ))(``` 。\n\n每个括号串有一个值 $v$，代表对这个串每匹配一个括号得到的价值。\n\n每个括号串均可以多次匹配，可以随时停止匹配，但是不能在未匹配完一个括号串的情况下开始匹配其他括号串。\n\n注意如果你跳过了母序列的某几个括号去匹配后面的，那么你将不能返回前面继续进行匹配。\n\n求匹配能得到的最大值。", "inputFormat": "第一行一个整数 $n$，表示括号串的个数。\n\n第二行一个字符串 $k$，表示给出的母序列。\n\n接下来 $n$ 行，每行一个括号串 $a$ 和一个数字 $v$。在这 $n$ 行中，第 $i$ 行的字符 $a_i,v_i$ 表示一个存在的括号串以及匹配这个括号串内一个括号所能得到的价值。\n\n\n\n", "outputFormat": "一个数 $r$，表示能取得的最大值。", "hint": "【温馨提示】\n\n**为了卡掉错解开大了数据范围，请注意常数因子对程序产生的影响。**\n\n【数据范围】\n\n**本题使用捆绑测试。**\n\n对于 $100\\%$ 的数据， $1 \\le n \\le 500, 1 \\le len(k) \\le 10^4, 1 \\le len(a) \\le 300,0 \\le v \\le 10^3$。\n\n| Subtask | $ n \\le$ | $ len(k) \\le$ | $ len(a) \\le$ |   时间 | 分值|特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |:----------: | :----------: |:----------: |\n| $1$ | $10$ | $7$| $7$ | $1\\text s$ |$5$|保证最优解每个 a 最多只用一次 |\n| $2$ | $10$ | $50$| $8$| $1\\text s$|$5$|数据随机，若 AC subtask3 则不计入总分|\n| $3$ | $10$ | $1000$| $8$| $1\\text s$|$10$|保证最优解每个 a 最多只用一次|\n| $4$ | $100$ | $10^4$ | $8$ | $1\\text s$ |$15$| 无 |\n| $5$ | $500$ | $10^4$ | $8$ | $1\\text s$ |$10$| 无 |\n| $6$ | $500$ | $10^4$ | $300$| $2.2\\text s$ |$60$| 无|\n\n【样例 $1$ 解释】\n\n最佳方案为先匹配 ```(()``` ，后匹配 ```()()()``` （ 注意最多只能匹配到 ```()()``` ），答案为 $4\\times3 + 5 \\times 4 = 32$。\n\n一种可行的匹配方法为方括号括起来的部分 ```(【(()()】)(【()】``` 。\n\n而若先匹配 ```(()``` ，再匹配 ```()``` ，最后匹配 ```(()``` 的价值为 $4\\times 3 + 2\\times 2 + 4\\times 3 = 28$，并非最佳方案。\n\n注意我们不能先匹配 ```(()``` ，再匹配 ```()()()``` 中一个括号，最后匹配 ```(()``` ，因为我们可以随时停止匹配，但不能在未匹配完某个串的情况下开始匹配另一个串。\n\n【样例 $2$ 解释】\n\n最佳方案先匹配 ```())```，再匹配 ```()))``` 最后匹配 ```())``` （ 注意最多只能匹配到 ```()``` ）, 答案为 $9\\times 3 + 7 \\times 4 + 9 \\times 2 = 73$。", "locale": "zh-CN"}}}
{"pid": "P6828", "type": "P", "difficulty": 7, "samples": [["6 108616 6\n1 0 8 6 1 6", "22 772456230 866731294 299746576 978045696 394365866"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化"], "title": "任意模数 Chirp Z-Transform", "background": "大家应该知道原时空限是 1.23s 345MB。", "description": "给定一个 $n$ 项多项式 $P(x)$ 以及 $c, m$，请计算 $P(c^0),P(c^1),\\dots,P(c^{m-1})$。所有答案都对 $10^9+7$ 取模。", "inputFormat": "第一行三个正整数 $n,c,m$。  \n第二行 $n$ 个非负整数 $a_0,a_1,\\dots,a_{n-1}$，由低到高表示 $P(x)$ 的系数。\n", "outputFormat": "一行 $m$ 个正整数，第 $i$ 个数表示 $P(c^{i-1})$。", "hint": "对于 $100\\%$ 的数据，$1\\le n,m\\le 6\\cdot10^5,0\\le c,a_i<10^9+7$.  \n| 测试点编号 | $n,m$ 限制 |\n| :-----------: | :-----------: |\n| $1$ | $n=m=1000$ |\n| $2$ | $n=m=64000$ |\n| $3$ | $n=m=5\\cdot10^5$ |\n| $4$ | $n=5\\cdot10^5,m=6\\cdot10^5$ |\n| $5$ | $n=6\\cdot10^5,m=5\\cdot10^5$ |\n\n出题人很遗憾由于精度和洛谷自带资料限制无法开到 $10^6$。  \n提示：$7$ 次 $FFT$ 可能过不了。  \n提示：出题人没有用 `long double`。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "任意模数 Chirp Z-Transform", "background": "大家应该知道原时空限是 1.23s 345MB。", "description": "给定一个 $n$ 项多项式 $P(x)$ 以及 $c, m$，请计算 $P(c^0),P(c^1),\\dots,P(c^{m-1})$。所有答案都对 $10^9+7$ 取模。", "inputFormat": "第一行三个正整数 $n,c,m$。  \n第二行 $n$ 个非负整数 $a_0,a_1,\\dots,a_{n-1}$，由低到高表示 $P(x)$ 的系数。\n", "outputFormat": "一行 $m$ 个正整数，第 $i$ 个数表示 $P(c^{i-1})$。", "hint": "对于 $100\\%$ 的数据，$1\\le n,m\\le 6\\cdot10^5,0\\le c,a_i<10^9+7$.  \n| 测试点编号 | $n,m$ 限制 |\n| :-----------: | :-----------: |\n| $1$ | $n=m=1000$ |\n| $2$ | $n=m=64000$ |\n| $3$ | $n=m=5\\cdot10^5$ |\n| $4$ | $n=5\\cdot10^5,m=6\\cdot10^5$ |\n| $5$ | $n=6\\cdot10^5,m=5\\cdot10^5$ |\n\n出题人很遗憾由于精度和洛谷自带资料限制无法开到 $10^6$。  \n提示：$7$ 次 $FFT$ 可能过不了。  \n提示：出题人没有用 `long double`。", "locale": "zh-CN"}}}
{"pid": "P6829", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "线段树", "倍增", "IOI", "交互题"], "title": "[IOI 2020] 植物比较", "background": "**这是一道交互题**。\n\n本题仅支持 C++ 系列语言，提交时不需要包含 `plant.h` 头文件。", "description": "植物学家 Hazel 参观过新加坡植物园的一个特别展览。在这次展览中，有 $n$ 棵 **高度互不相同** 的植物，它们排成了一个圆。这些植物按顺时针方向从 $0$ 到 $n-1$ 编号，植物 $n-1 $ 与植物 $0$ 是相邻的。\n\n对于每棵植物 $i\\ (0 \\le i \\le n-1$)，Hazel 将它与顺时针方向的后 $k-1$ 棵植物进行比较，记录下数值 $r[i]$ 以表示这 $k-1$ 棵植物中有多少棵的高度大于植物 $i$。因此，每个 $r[i]$ 的数值是由某段连续 $k$ 棵植物的相对高度决定的。\n\n例如，假设 $n=5$，$k=3$，$i=3$。植物 $3$ 顺时针方向的后 $k-1=2$ 棵植物是植物 $4$ 和植物 $0$。如果植物 $4$ 比植物 $3$ 高，且植物 $0$ 比植物 $3$ 矮，那么 Hazel 将会记录 $r[3]=1$。\n\n你可以假设 Hazel 记录的数值 $r[i]$ 都是正确的。也就是说，这些植物至少存在一组互不相同的高度符合 Hazel 所记录的数值。\n\n本题要求你比较 $q$ 对植物的高度。由于你没有机会参观这次展览，你仅有的信息来源是 Hazel 的笔记本，其中记录了 $k$ 和序列 $r[0],\\ldots, r[n-1]$ 的值。\n\n对于每对需要比较的植物 $x$ 和 $y$（$x$ 和 $y$ 不同），判定它们符合以下哪种情况：\n\n- 植物 $x$ 一定比植物 $y$ 高：对于任意一组符合数组 $r$ 且互不相同的高度 $h[0],\\ldots h[n-1]$，都有 $h[x] > h[y]$。\n- 植物 $x$ 一定比植物 $y$ 矮：对于任意一组符合数组 $r$ 且互不相同的高度 $h[0],\\ldots h[n-1]$，都有 $h[x]<h[y]$。\n- 该比较没有定论：以上两种情况都不成立。\n\n#### 实现细节\n\n要求你实现以下函数：\n```cpp\nvoid init(int k, std::vector<int> r)\n```\n- $k$：决定每个 $r[i]$ 数值的连续植物的棵数。\n- $r$：一个大小为 $n$ 的数组，其中 $r[i]$ 是植物 $i$ 顺时针方向的后 $k-1$ 棵植物中比它高的棵数。\n- 该函数恰好被调用一次，且在对 `compare_plants` 的任何调用前。\n```cpp\nint compare_plants(int x, int y)\n```\n- $x,y$ ：待比较的植物的编号。\n- 该函数应该返回：\n\t- $1$，如果植物 $x$ 一定比植物 $y$ 高，\n\t- $-1$，如果植物 $x$ 一定比植物 $y$ 矮，\n\t- $0$，如果该比较没有定论。\n- 该函数恰好被调用 $q$ 次。", "inputFormat": "", "outputFormat": "", "hint": "#### 样例说明\n\n#### 例 1\n\n考虑以下调用：\n```cpp\ninit(3, [0, 1, 1, 2])\n```\n假设评测程序调用了 `compare_plants(0, 2)`。由 $r[0]=0$ 可以推断植物 $2$ 不比植物 $0$ 高，因此该调用应该返回 $1$。\n\n假设评测程序接下来调用了 `compare_plants(1, 2)`。由于对每组符合以上条件的植物高度，都有植物 $1$ 比物 $2$ 矮，因此该调用应该返回 $-1$。\n\n#### 例 2\n\n考虑以下调用：\n```cpp\ninit(2, [0, 1, 0, 1])\n```\n假设评测程序调用了 `compare_plants(0, 3)`。由 $r[3]=1$ 可以推断植物 $0$ 比植物 $3$ 高，因此该调用应该返回 $1$。\n\n假设评测程序接下来调用了 `compare_plants(1, 3)`。两组高度 $[3,1,4,2]$ 和 $[3,2,4,1]$ 都符合 Hazel 的观测记录，由于在第一种情况中植物 $1$ 比植物 $3$ 矮，而在第二种情况中它比植物 $3$ 高，因此该调用应该返回 $0$。\n\n#### 约束条件\n\n- $2\\le k\\le n\\le 200\\ 000$\n- $1\\le q\\le 200\\ 000$\n- $0 \\le r[i]\\le k-1$（对所有 $0 \\le i \\le n-1$）\n- $0\\le x<y\\le n-1$\n- 存在一组或多组 **互不相同的高度** 符合数组 $r$ 记录的情况\n\n#### 子任务\n\n1. （5 分）$k=2$\n2. （14 分）$n \\le 5000,2 \\cdot k > n$\n3. （13 分）$2 \\cdot k > n$\n4. （17 分）每次 `compare_plants` 调用的正确答案是 $1$ 或 $-1$\n5. （11 分）$n\\le 300, q\\le \\frac{n\\cdot (n-1)}{2}$\n6. （15 分）每次调用 `compare_plants` 时有 $x=0$\n7. （25 分）没有附加约束条件\n\n#### 评测程序示例\n\n评测程序示例以如下格式读取输⼊数据：\n\n第 $1$ 行：$n\\ k\\ q$     \n第 $2$ 行：$r[0]\\ r[1]\\ \\cdots\\ r[n-1]$        \n第 $3+i\\ (0\\le i\\le q-1)$ 行：$x\\ y$，表⽰第 $i$ 次调用 `compare_plants` 时的参数\n\n评测程序示例以如下格式打印你的答案：\n\n第 $1+i\\ (0\\le i\\le q-1)$ 行：第 $i$ 次调用 `compare_plants` 的返回值", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2020] 植物比较", "background": "**这是一道交互题**。\n\n本题仅支持 C++ 系列语言，提交时不需要包含 `plant.h` 头文件。", "description": "植物学家 Hazel 参观过新加坡植物园的一个特别展览。在这次展览中，有 $n$ 棵 **高度互不相同** 的植物，它们排成了一个圆。这些植物按顺时针方向从 $0$ 到 $n-1$ 编号，植物 $n-1 $ 与植物 $0$ 是相邻的。\n\n对于每棵植物 $i\\ (0 \\le i \\le n-1$)，Hazel 将它与顺时针方向的后 $k-1$ 棵植物进行比较，记录下数值 $r[i]$ 以表示这 $k-1$ 棵植物中有多少棵的高度大于植物 $i$。因此，每个 $r[i]$ 的数值是由某段连续 $k$ 棵植物的相对高度决定的。\n\n例如，假设 $n=5$，$k=3$，$i=3$。植物 $3$ 顺时针方向的后 $k-1=2$ 棵植物是植物 $4$ 和植物 $0$。如果植物 $4$ 比植物 $3$ 高，且植物 $0$ 比植物 $3$ 矮，那么 Hazel 将会记录 $r[3]=1$。\n\n你可以假设 Hazel 记录的数值 $r[i]$ 都是正确的。也就是说，这些植物至少存在一组互不相同的高度符合 Hazel 所记录的数值。\n\n本题要求你比较 $q$ 对植物的高度。由于你没有机会参观这次展览，你仅有的信息来源是 Hazel 的笔记本，其中记录了 $k$ 和序列 $r[0],\\ldots, r[n-1]$ 的值。\n\n对于每对需要比较的植物 $x$ 和 $y$（$x$ 和 $y$ 不同），判定它们符合以下哪种情况：\n\n- 植物 $x$ 一定比植物 $y$ 高：对于任意一组符合数组 $r$ 且互不相同的高度 $h[0],\\ldots h[n-1]$，都有 $h[x] > h[y]$。\n- 植物 $x$ 一定比植物 $y$ 矮：对于任意一组符合数组 $r$ 且互不相同的高度 $h[0],\\ldots h[n-1]$，都有 $h[x]<h[y]$。\n- 该比较没有定论：以上两种情况都不成立。\n\n#### 实现细节\n\n要求你实现以下函数：\n```cpp\nvoid init(int k, std::vector<int> r)\n```\n- $k$：决定每个 $r[i]$ 数值的连续植物的棵数。\n- $r$：一个大小为 $n$ 的数组，其中 $r[i]$ 是植物 $i$ 顺时针方向的后 $k-1$ 棵植物中比它高的棵数。\n- 该函数恰好被调用一次，且在对 `compare_plants` 的任何调用前。\n```cpp\nint compare_plants(int x, int y)\n```\n- $x,y$ ：待比较的植物的编号。\n- 该函数应该返回：\n\t- $1$，如果植物 $x$ 一定比植物 $y$ 高，\n\t- $-1$，如果植物 $x$ 一定比植物 $y$ 矮，\n\t- $0$，如果该比较没有定论。\n- 该函数恰好被调用 $q$ 次。", "inputFormat": "", "outputFormat": "", "hint": "#### 样例说明\n\n#### 例 1\n\n考虑以下调用：\n```cpp\ninit(3, [0, 1, 1, 2])\n```\n假设评测程序调用了 `compare_plants(0, 2)`。由 $r[0]=0$ 可以推断植物 $2$ 不比植物 $0$ 高，因此该调用应该返回 $1$。\n\n假设评测程序接下来调用了 `compare_plants(1, 2)`。由于对每组符合以上条件的植物高度，都有植物 $1$ 比物 $2$ 矮，因此该调用应该返回 $-1$。\n\n#### 例 2\n\n考虑以下调用：\n```cpp\ninit(2, [0, 1, 0, 1])\n```\n假设评测程序调用了 `compare_plants(0, 3)`。由 $r[3]=1$ 可以推断植物 $0$ 比植物 $3$ 高，因此该调用应该返回 $1$。\n\n假设评测程序接下来调用了 `compare_plants(1, 3)`。两组高度 $[3,1,4,2]$ 和 $[3,2,4,1]$ 都符合 Hazel 的观测记录，由于在第一种情况中植物 $1$ 比植物 $3$ 矮，而在第二种情况中它比植物 $3$ 高，因此该调用应该返回 $0$。\n\n#### 约束条件\n\n- $2\\le k\\le n\\le 200\\ 000$\n- $1\\le q\\le 200\\ 000$\n- $0 \\le r[i]\\le k-1$（对所有 $0 \\le i \\le n-1$）\n- $0\\le x<y\\le n-1$\n- 存在一组或多组 **互不相同的高度** 符合数组 $r$ 记录的情况\n\n#### 子任务\n\n1. （5 分）$k=2$\n2. （14 分）$n \\le 5000,2 \\cdot k > n$\n3. （13 分）$2 \\cdot k > n$\n4. （17 分）每次 `compare_plants` 调用的正确答案是 $1$ 或 $-1$\n5. （11 分）$n\\le 300, q\\le \\frac{n\\cdot (n-1)}{2}$\n6. （15 分）每次调用 `compare_plants` 时有 $x=0$\n7. （25 分）没有附加约束条件\n\n#### 评测程序示例\n\n评测程序示例以如下格式读取输⼊数据：\n\n第 $1$ 行：$n\\ k\\ q$     \n第 $2$ 行：$r[0]\\ r[1]\\ \\cdots\\ r[n-1]$        \n第 $3+i\\ (0\\le i\\le q-1)$ 行：$x\\ y$，表⽰第 $i$ 次调用 `compare_plants` 时的参数\n\n评测程序示例以如下格式打印你的答案：\n\n第 $1+i\\ (0\\le i\\le q-1)$ 行：第 $i$ 次调用 `compare_plants` 的返回值", "locale": "zh-CN"}}}
{"pid": "P6830", "type": "P", "difficulty": 5, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "并查集", "IOI", "交互题", "Special Judge", "深度优先搜索 DFS"], "title": "[IOI 2020] 连接擎天树", "background": "**这是一道交互题。**\n\n本题仅支持 C++ 系列语言，提交时**不需要**包含 `supertrees.h` 头文件，但**需要**在程序开头包含 `vector` 头文件以及声明函数 `void build(std::vector<std::vector<int> > b);`", "description": "滨海湾花园是新加坡的一个大型自然公园。公园内有 $n$ 个塔，称之为“擎天树”。这些塔的编号为 $0$ 到 $n-1$。我们希望建立一个桥的集合（桥的数目大于等于 $0$）。每⼀座桥连接两个不同的塔，而且可以双向通行。没有两座桥连接相同的一对塔。\n\n一条从塔 $x$ 到塔 $y$ 的路径是一个满足以下条件的塔序列（塔的数目大于等于 $1$）：\n\n- 序列的第一个元素是 $x$，\n- 序列的最后一个元素是 $y$，\n- 序列中所有元素互不相同，\n\n序列中每两个相邻元素（塔）都是被某一座桥连接起来的。\n\n注意根据定义，一个塔到它自己有且仅有一条路径，并且从塔 $i$ 到塔 $j$ 的不同路径的数目和从塔 $j$ 到塔 $i$ 的不同路径的数目是一样的。\n\n负责该项设计的首席设计师希望待建造的桥梁要符合：任意给定 $0 \\le i,j \\le n-1$，恰好有 $p[i][j]$ 条从塔 $i$ 到塔 $j$ 的不同路径，其中 $0 \\le p[i][j] \\le 3$。\n\n请构造一个桥的集合来满足设计师的要求，或判定这样的桥梁集合不可能存在。\n\n#### 实现细节\n\n你需要实现下面的这个函数：\n\n```cpp\nint construct(std::vector<std::vector<int> > p)\n```\n\n- $p$：⼀个表示设计师要求的 $n \\times n$ 数组。\n- 如果这个建设方案是存在的，该函数应该恰好调用一次 `build`（见下文）来给出建设方案，然后应返回 $1$。\n- 否则，该函数应该返回 $0$，并且不要调用 `build`。\n- 该函数将被调用恰好一次。\n\n函数 `build` 定义如下：\n\n```cpp\nvoid build(std::vector<std::vector<int> > b)\n```\n  \n- $b$：一个 $n \\times n$ 的数组，$b[i][j]=1$ 表示有一座桥连接塔 $i$ 和塔 $j$，否则 $b[i][j]=0$。\n- 注意该数组必须满足：对所有 $0 \\le i,j \\le n-1$，$b[i][j]=b[j][i]$；并且对所有 $0 \\le i \\le n-1$，$b[i][i]=0$。", "inputFormat": "", "outputFormat": "", "hint": "#### 样例说明\n\n#### 例 1\n\n考虑以下调用：\n\n```cpp\nconstruct([[1, 1, 2, 2], [1, 1, 2, 2], [2, 2, 1, 2], [2, 2, 2, 1]])\n```\n  \n这表明从塔 $0$ 到塔 $1$ 恰好有一条路径。对于所有其他的塔对 $(x,y)(0 \\le x<y \\le 3)$, 恰好有两条不同的路径连接塔 $x$ 和塔 $y$。这可以通过建设 $4$ 座桥来实现：连接塔对 $(0, 1), (1, 2), (1, 3)$ 和 $(2,3)$。\n\n为了给出这个解决方案，函数 `construct` 应该做以下调用：\n\n```cpp\nbuild([[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]])\n  ```\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lf8q5wrk.png)\n\n函数应该返回 $1$。\n\n对于这个例子，存在多种不同的建设方案来满足要求，所有这些方案都被认为是正确的。\n\n#### 例 2\n\n考虑以下调用：\n\n```cpp\nconstruct([[1, 0], [0, 1]])\n```\n  \n  这表明无法在两个塔之间进行旅行。这只能通过不建设桥梁来满足。\n\n因此，函数 `construct` 应该做以下调用：\n```cpp\nbuild([[0, 0], [0, 0]])\n```\n  然后，函数 `construct` 应该返回 $1$。\n  \n  #### 例 3\n  \n考虑以下调用：\n\n```cpp\nconstruct([[1, 3], [3, 1]])\n```\n\n这表明从塔 $0$ 到塔 $1$ 恰好有 $3$ 条路径。这些要求无法满足。因此，函数 `construct` 应该返回 $0$ 并且不要调用 `build`。\n\n#### 约束条件\n\n- $1\\le n\\le 1000$\n- $p[i][i]=1$（对所有 $0 \\le i \\le n-1$）\n- $p[i][j]=p[j][i]$（对所有 $0 \\le i,j \\le n-1$）\n- $0 \\le p[i][j] \\le 3$（对所有 $0 \\le i,j \\le n-1$）\n\n#### 子任务\n\n1. （11 分）$p[i][j]=1$（对所有 $0 \\le i,j \\le n-1$）\n2. （10 分）$p[i][j] \\in \\{0,1\\}$（对所有 $0 \\le i,j \\le n-1$）\n1. （19 分）$p[i][j] \\in \\{0,2\\}$（对所有 $i \\ne j,0 \\le i,j \\le n-1$）\n1. （35 分）$0 \\le p[i][j]\\le 2$（对所有 $0 \\le i,j \\le n-1$）并且至少有一种建设方案满足要求\n1. （21 分）$0 \\le p[i][j] \\le 2$（对所有 $0 \\le i,j \\le n-1$）\n1. （4 分）没有额外约束条件\n\n#### 评测程序示例\n\n评测程序示例以如下格式读取输入数据：\n\n第 $1$ 行：$n$       \n第 $2+i$ 行（$0 \\le i \\le n+1$）：$p[i][0]\\ p[i][1]\\ \\ldots\\ p[i][n]$\n\n评测程序示例的输出格式如下：\n\n第 $1$ 行: `construct` 的返回值。\n\n如果 `construct` 的返回值为 $1$，评测程序示例会额外打印：\n\n第 $2+i$ 行（$0 \\le i \\le n+1$）：$b[i][0]\\ b[i][1]\\ \\ldots\\ b[i][n]$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2020] 连接擎天树", "background": "**这是一道交互题。**\n\n本题仅支持 C++ 系列语言，提交时**不需要**包含 `supertrees.h` 头文件，但**需要**在程序开头包含 `vector` 头文件以及声明函数 `void build(std::vector<std::vector<int> > b);`", "description": "滨海湾花园是新加坡的一个大型自然公园。公园内有 $n$ 个塔，称之为“擎天树”。这些塔的编号为 $0$ 到 $n-1$。我们希望建立一个桥的集合（桥的数目大于等于 $0$）。每⼀座桥连接两个不同的塔，而且可以双向通行。没有两座桥连接相同的一对塔。\n\n一条从塔 $x$ 到塔 $y$ 的路径是一个满足以下条件的塔序列（塔的数目大于等于 $1$）：\n\n- 序列的第一个元素是 $x$，\n- 序列的最后一个元素是 $y$，\n- 序列中所有元素互不相同，\n\n序列中每两个相邻元素（塔）都是被某一座桥连接起来的。\n\n注意根据定义，一个塔到它自己有且仅有一条路径，并且从塔 $i$ 到塔 $j$ 的不同路径的数目和从塔 $j$ 到塔 $i$ 的不同路径的数目是一样的。\n\n负责该项设计的首席设计师希望待建造的桥梁要符合：任意给定 $0 \\le i,j \\le n-1$，恰好有 $p[i][j]$ 条从塔 $i$ 到塔 $j$ 的不同路径，其中 $0 \\le p[i][j] \\le 3$。\n\n请构造一个桥的集合来满足设计师的要求，或判定这样的桥梁集合不可能存在。\n\n#### 实现细节\n\n你需要实现下面的这个函数：\n\n```cpp\nint construct(std::vector<std::vector<int> > p)\n```\n\n- $p$：⼀个表示设计师要求的 $n \\times n$ 数组。\n- 如果这个建设方案是存在的，该函数应该恰好调用一次 `build`（见下文）来给出建设方案，然后应返回 $1$。\n- 否则，该函数应该返回 $0$，并且不要调用 `build`。\n- 该函数将被调用恰好一次。\n\n函数 `build` 定义如下：\n\n```cpp\nvoid build(std::vector<std::vector<int> > b)\n```\n  \n- $b$：一个 $n \\times n$ 的数组，$b[i][j]=1$ 表示有一座桥连接塔 $i$ 和塔 $j$，否则 $b[i][j]=0$。\n- 注意该数组必须满足：对所有 $0 \\le i,j \\le n-1$，$b[i][j]=b[j][i]$；并且对所有 $0 \\le i \\le n-1$，$b[i][i]=0$。", "inputFormat": "", "outputFormat": "", "hint": "#### 样例说明\n\n#### 例 1\n\n考虑以下调用：\n\n```cpp\nconstruct([[1, 1, 2, 2], [1, 1, 2, 2], [2, 2, 1, 2], [2, 2, 2, 1]])\n```\n  \n这表明从塔 $0$ 到塔 $1$ 恰好有一条路径。对于所有其他的塔对 $(x,y)(0 \\le x<y \\le 3)$, 恰好有两条不同的路径连接塔 $x$ 和塔 $y$。这可以通过建设 $4$ 座桥来实现：连接塔对 $(0, 1), (1, 2), (1, 3)$ 和 $(2,3)$。\n\n为了给出这个解决方案，函数 `construct` 应该做以下调用：\n\n```cpp\nbuild([[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]])\n  ```\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lf8q5wrk.png)\n\n函数应该返回 $1$。\n\n对于这个例子，存在多种不同的建设方案来满足要求，所有这些方案都被认为是正确的。\n\n#### 例 2\n\n考虑以下调用：\n\n```cpp\nconstruct([[1, 0], [0, 1]])\n```\n  \n  这表明无法在两个塔之间进行旅行。这只能通过不建设桥梁来满足。\n\n因此，函数 `construct` 应该做以下调用：\n```cpp\nbuild([[0, 0], [0, 0]])\n```\n  然后，函数 `construct` 应该返回 $1$。\n  \n  #### 例 3\n  \n考虑以下调用：\n\n```cpp\nconstruct([[1, 3], [3, 1]])\n```\n\n这表明从塔 $0$ 到塔 $1$ 恰好有 $3$ 条路径。这些要求无法满足。因此，函数 `construct` 应该返回 $0$ 并且不要调用 `build`。\n\n#### 约束条件\n\n- $1\\le n\\le 1000$\n- $p[i][i]=1$（对所有 $0 \\le i \\le n-1$）\n- $p[i][j]=p[j][i]$（对所有 $0 \\le i,j \\le n-1$）\n- $0 \\le p[i][j] \\le 3$（对所有 $0 \\le i,j \\le n-1$）\n\n#### 子任务\n\n1. （11 分）$p[i][j]=1$（对所有 $0 \\le i,j \\le n-1$）\n2. （10 分）$p[i][j] \\in \\{0,1\\}$（对所有 $0 \\le i,j \\le n-1$）\n1. （19 分）$p[i][j] \\in \\{0,2\\}$（对所有 $i \\ne j,0 \\le i,j \\le n-1$）\n1. （35 分）$0 \\le p[i][j]\\le 2$（对所有 $0 \\le i,j \\le n-1$）并且至少有一种建设方案满足要求\n1. （21 分）$0 \\le p[i][j] \\le 2$（对所有 $0 \\le i,j \\le n-1$）\n1. （4 分）没有额外约束条件\n\n#### 评测程序示例\n\n评测程序示例以如下格式读取输入数据：\n\n第 $1$ 行：$n$       \n第 $2+i$ 行（$0 \\le i \\le n+1$）：$p[i][0]\\ p[i][1]\\ \\ldots\\ p[i][n]$\n\n评测程序示例的输出格式如下：\n\n第 $1$ 行: `construct` 的返回值。\n\n如果 `construct` 的返回值为 $1$，评测程序示例会额外打印：\n\n第 $2+i$ 行（$0 \\le i \\le n+1$）：$b[i][0]\\ b[i][1]\\ \\ldots\\ b[i][n]$", "locale": "zh-CN"}}}
{"pid": "P6831", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2020", "IOI", "交互题", "Special Judge"], "title": "[IOI 2020] 嘉年华奖券", "background": "**本题为交互题。**\n\n请在程序开头声明 `void allocate_tickets(std::vector<std::vector<int> > s);` 和使用 vector 头文件，并且请在调用函数前加上 `extern \"C\"`。\n\n请使用 **C++17 / 20** 提交。", "description": "Ringo 正在参加在新加坡举办的一个嘉年华活动。他的口袋里装有一些奖券，这些奖券可以在嘉年华的游戏展位使用。假设共有 $n$ 种颜色的奖券，每张奖券涂上了其中的一种颜色并且印上了一个非负整数。不同奖券上的数字可能相同。依据嘉年华活动的规则要求，$n$ 保证是偶数。\n\nRingo 每种颜色的奖券有 $m$ 张，也就是说他共有 $n \\cdot m$ 张奖券。其中，第 $i$ 种颜色对应的第 $j$ 张奖券上印的数字为 $x[i][j]$（$0 \\le i \\le n-1$ 且 $0 \\le j \\le m-1$）。\n\n一次奖券游戏要进行 $k$ 轮，轮次的序号从 $0$ 到 $k-1$。每一轮按照下面的方式进行：\n\n- 首先，Ringo 从每种颜色的奖券中各选出一张奖券，形成一个 $n$ 张奖券的 **集合**。\n- 随后，游戏负责人记录下这个集合中奖券上的数字 $a[0],a[1],\\ldots,a[n-1]$。不需要考虑这 $n$ 个整数的顺序。\n- 接下来，游戏负责人从一个幸运抽奖箱中抽取一张特殊卡片，上面印有整数 $b$。\n- 对于上述集合中每一个奖券上的数字 $a[i](0\\le i \\le n-1)$，游戏负责人会计算 $a[i]$ 和 $b$ 的差的绝对值。让 $S$ 代表这 $n$ 个差的绝对值之和。\n- 所得到的数字 $S$ 就是 Ringo 本轮能够获得的奖励数额。\n- 一轮游戏结束后，本轮集合中的奖券全部被丢弃，不会在未来的轮次所使用。\n\n当 $k$ 轮游戏结束后，Ringo 会丢弃口袋中的所有奖券。\n\n通过仔细观察，Ringo 发现这个奖券游戏被操控了！实际上，幸运抽奖箱里面内置了一台打印机。在每一轮，游戏负责人首先找到一个能够最小化当前轮次游戏奖励的整数 $b$，然后将该数字打印在他所抽取的特殊卡片上。\n\n知道了这些信息之后，Ringo 想要设计每轮游戏中的奖券分配方案，使得 $k$ 轮游戏中获得的总体奖励数额之和最大。\n\n#### 实现细节\n\n你需要实现下面这个函数：\n\n```cpp\nlong long find_maximum(int k,std::vector<std::vector<int>> x)\n```\n\n- $k$：游戏的轮数。\n- $x$：一个 $n \\times m$ 的数组，记录了奖券上的数字。每种颜色的奖券按照上面的数字非递减顺序排序。\n- 这个函数只会被调用一次。\n- 这个函数应该只调用一次函数 `allocate_tickets`（参见下面的内容），它描述了 $k$ 轮游戏中的奖券分配方案，每一轮对应一个奖券集合。奖券的分配方案应该使得所获奖励数额之和达到最大。\n- 这个函数需要返回能够获得的最大的奖励数额之和。\n\n函数 `allocate_tickets` 按照如下的方式进行定义：\n\n```cpp\nvoid allocate_tickets(std::vector<std::vector<int>> s)\n```\n  \n- $s$：一个 $n \\times m$ 的数组。如果第 $i$ 种颜色的第 $j$ 张奖券如果被分配到了第 $r$ 轮游戏，那么 $s[i][j]$ 的值应该为 $r$；如果未被使用，应该为 $-1$。\n- 对于 $0 \\le i \\le n-1$，在 $s[i][0],s[i][1],\\ldots,s[i][m-1]$ 中，每个值 $0,1,\\ldots,k-1$ 必须只出现一次，而其他元素应该为 $-1$。\n- 如果存在多种奖券分配方案能够达到最优的奖励数值，可以给出其中任何一种最优方案。", "inputFormat": "", "outputFormat": "", "hint": "#### 样例说明\n\n#### 例 1\n\n考虑下面的函数调用：\n\n```cpp\nfind_maximum(2, [[0, 2, 5],[1, 1, 3]])\n  ```\n这意味着：\n\n- 游戏共进行 $k=2$ 轮；\n- 第 $0$ 种颜色奖券上的整数数字分别是 $0,2$ 和 $5$；\n- 第 $1$ 种颜色奖券上的整数数字分别是 $1,1$ 和 $3$；\n\n一种能够获得最优奖励数值的分配方案是：\n\n- 在第 $0$ 轮，Ringo 选择第 $0$ 种颜色的第 $0$ 张奖券（印有整数 $0$）和第 $1$ 种颜色的第 $2$ 张奖券（印有整数 $3$）。本轮获得的最小奖励数额是 $3$。例如，游戏负责人可以选择 $b=1$：$|1-0| + |1-3| = 1+2 = 3$。\n- 在第 $1$ 轮，Ringo 选择第 $0$ 种颜色的第 $2$ 张奖券（印有整数 $5$）和第 $1$ 种颜色的第 $1$ 张奖券（印有整数 $1$）。本轮能够获得的最小奖励是 $4$。例如，游戏负责人可以选择 $b=3$：$|3-1|+|3-5|=2+2=4$。\n- 因此，本次游戏两轮的奖励之和为 $3+4=7$。\n\n为了给出这个分配方案，函数 `find_maximum` 应该按照如下方式调用 `allocate_tickets`：\n\n```cpp\nallocate_tickets([[0, -1, 1], [-1, 1, 0]])\n```\n  \n  最终，函数 `find_maximum` 应该返回数字 $7$。\n  \n#### 例 2\n\n考虑下面的函数调用：\n\n```cpp\nfind_maximum(1, [[5, 9], [1, 4], [3, 6], [2, 7]])\n```\n\n这意味着：\n\n- 游戏只进行一轮；\n- 第 $0$ 种颜色奖券上的数字分别是 $5$ 和 $9$；\n- 第 $1$ 种颜色奖券上的数字分别是 $1$ 和 $4$；\n- 第 $2$ 种颜色奖券上的数字分别是 $3$ 和 $6$；\n- 第 $3$ 种颜色奖券上的数字分别是 $2$ 和 $7$；\n\n一种能够获得最优奖励的分配方案是：\n\n- 在第 $0$ 轮，Ringo 选择第 $0$ 种颜色的第 $1$ 张奖券（印有整数 $9$），第 $1$ 种颜色的第 $0$ 张奖券（印有整数 $1$），第 $2$ 种颜色的第 $0$ 张奖券（印有整数 $3$），第 $3$ 种颜色的第 $1$ 张奖券（印有整数 $7$）。本轮能够获得的最小奖励是 $12$。例如，游戏负责人可以选择 $b=3$：$|3-9| + |3-1| + |3-3| + |3-7| = 6 + 2 + 0 + 4 = 12$。\n\n为了给出这个分配方案，函数 `find_maximum` 应该按照如下方式调用 `allocate_tickets`：\n\n```cpp\nallocate_tickets([[-1, 0], [0, -1], [0, -1], [-1, 0]])\n```\n\n最终，函数 `find_maximum` 应该返回数字 $12$。\n\n#### 约束条件\n\n- $2\\le n\\le 1500$ 且 $n$ 为偶数\n- $1\\le k\\le m\\le 1500$\n- $0 \\le x[i][j] \\le 10^9$（对于所有的 $0 \\le i \\le n-1$ 且 $0 \\le j \\le m-1$）\n- $x[i][j-1] \\le x[i][j]$（对于所有的 $0 \\le i \\le n-1$ 且 $0 \\le j \\le m-1$）\n\n#### 子任务\n\n1. （11 分）$m=1$\n2. （16 分）$k=1$\n3. （14 分）$0 \\le x[i][j] \\le 1$（对于所有的 $0 \\le i \\le n-1$ 且 $0 \\le j \\le m-1$）\n4. （14 分）$k=m$\n5. （12 分）$n,m \\le 80$\n6. （23 分）$n,m \\le 300$\n7. （10 分）没有额外约束条件\n\n#### 评测程序示例\n\n评测程序示例按照下面的格式读入数据：\n\n第 $1$ 行：$n\\ m\\ k$        \n第 $2+i$ 行（$0 \\le i \\le n-1$）：$x[i][0]\\ x[i][1]\\ \\ldots \\ x[i][m-1]$\n\n评测程序示例按照下面的格式打印你的答案：\n\n第 $1$ 行：`find_maximum` 的返回值       \n第 $2+i$ 行（$0 \\le i \\le n-1$）：$s[i][0]\\ s[i][1]\\ \\ldots\\ s[i][m-1]$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2020] 嘉年华奖券", "background": "**本题为交互题。**\n\n请在程序开头声明 `void allocate_tickets(std::vector<std::vector<int> > s);` 和使用 vector 头文件，并且请在调用函数前加上 `extern \"C\"`。\n\n请使用 **C++17 / 20** 提交。", "description": "Ringo 正在参加在新加坡举办的一个嘉年华活动。他的口袋里装有一些奖券，这些奖券可以在嘉年华的游戏展位使用。假设共有 $n$ 种颜色的奖券，每张奖券涂上了其中的一种颜色并且印上了一个非负整数。不同奖券上的数字可能相同。依据嘉年华活动的规则要求，$n$ 保证是偶数。\n\nRingo 每种颜色的奖券有 $m$ 张，也就是说他共有 $n \\cdot m$ 张奖券。其中，第 $i$ 种颜色对应的第 $j$ 张奖券上印的数字为 $x[i][j]$（$0 \\le i \\le n-1$ 且 $0 \\le j \\le m-1$）。\n\n一次奖券游戏要进行 $k$ 轮，轮次的序号从 $0$ 到 $k-1$。每一轮按照下面的方式进行：\n\n- 首先，Ringo 从每种颜色的奖券中各选出一张奖券，形成一个 $n$ 张奖券的 **集合**。\n- 随后，游戏负责人记录下这个集合中奖券上的数字 $a[0],a[1],\\ldots,a[n-1]$。不需要考虑这 $n$ 个整数的顺序。\n- 接下来，游戏负责人从一个幸运抽奖箱中抽取一张特殊卡片，上面印有整数 $b$。\n- 对于上述集合中每一个奖券上的数字 $a[i](0\\le i \\le n-1)$，游戏负责人会计算 $a[i]$ 和 $b$ 的差的绝对值。让 $S$ 代表这 $n$ 个差的绝对值之和。\n- 所得到的数字 $S$ 就是 Ringo 本轮能够获得的奖励数额。\n- 一轮游戏结束后，本轮集合中的奖券全部被丢弃，不会在未来的轮次所使用。\n\n当 $k$ 轮游戏结束后，Ringo 会丢弃口袋中的所有奖券。\n\n通过仔细观察，Ringo 发现这个奖券游戏被操控了！实际上，幸运抽奖箱里面内置了一台打印机。在每一轮，游戏负责人首先找到一个能够最小化当前轮次游戏奖励的整数 $b$，然后将该数字打印在他所抽取的特殊卡片上。\n\n知道了这些信息之后，Ringo 想要设计每轮游戏中的奖券分配方案，使得 $k$ 轮游戏中获得的总体奖励数额之和最大。\n\n#### 实现细节\n\n你需要实现下面这个函数：\n\n```cpp\nlong long find_maximum(int k,std::vector<std::vector<int>> x)\n```\n\n- $k$：游戏的轮数。\n- $x$：一个 $n \\times m$ 的数组，记录了奖券上的数字。每种颜色的奖券按照上面的数字非递减顺序排序。\n- 这个函数只会被调用一次。\n- 这个函数应该只调用一次函数 `allocate_tickets`（参见下面的内容），它描述了 $k$ 轮游戏中的奖券分配方案，每一轮对应一个奖券集合。奖券的分配方案应该使得所获奖励数额之和达到最大。\n- 这个函数需要返回能够获得的最大的奖励数额之和。\n\n函数 `allocate_tickets` 按照如下的方式进行定义：\n\n```cpp\nvoid allocate_tickets(std::vector<std::vector<int>> s)\n```\n  \n- $s$：一个 $n \\times m$ 的数组。如果第 $i$ 种颜色的第 $j$ 张奖券如果被分配到了第 $r$ 轮游戏，那么 $s[i][j]$ 的值应该为 $r$；如果未被使用，应该为 $-1$。\n- 对于 $0 \\le i \\le n-1$，在 $s[i][0],s[i][1],\\ldots,s[i][m-1]$ 中，每个值 $0,1,\\ldots,k-1$ 必须只出现一次，而其他元素应该为 $-1$。\n- 如果存在多种奖券分配方案能够达到最优的奖励数值，可以给出其中任何一种最优方案。", "inputFormat": "", "outputFormat": "", "hint": "#### 样例说明\n\n#### 例 1\n\n考虑下面的函数调用：\n\n```cpp\nfind_maximum(2, [[0, 2, 5],[1, 1, 3]])\n  ```\n这意味着：\n\n- 游戏共进行 $k=2$ 轮；\n- 第 $0$ 种颜色奖券上的整数数字分别是 $0,2$ 和 $5$；\n- 第 $1$ 种颜色奖券上的整数数字分别是 $1,1$ 和 $3$；\n\n一种能够获得最优奖励数值的分配方案是：\n\n- 在第 $0$ 轮，Ringo 选择第 $0$ 种颜色的第 $0$ 张奖券（印有整数 $0$）和第 $1$ 种颜色的第 $2$ 张奖券（印有整数 $3$）。本轮获得的最小奖励数额是 $3$。例如，游戏负责人可以选择 $b=1$：$|1-0| + |1-3| = 1+2 = 3$。\n- 在第 $1$ 轮，Ringo 选择第 $0$ 种颜色的第 $2$ 张奖券（印有整数 $5$）和第 $1$ 种颜色的第 $1$ 张奖券（印有整数 $1$）。本轮能够获得的最小奖励是 $4$。例如，游戏负责人可以选择 $b=3$：$|3-1|+|3-5|=2+2=4$。\n- 因此，本次游戏两轮的奖励之和为 $3+4=7$。\n\n为了给出这个分配方案，函数 `find_maximum` 应该按照如下方式调用 `allocate_tickets`：\n\n```cpp\nallocate_tickets([[0, -1, 1], [-1, 1, 0]])\n```\n  \n  最终，函数 `find_maximum` 应该返回数字 $7$。\n  \n#### 例 2\n\n考虑下面的函数调用：\n\n```cpp\nfind_maximum(1, [[5, 9], [1, 4], [3, 6], [2, 7]])\n```\n\n这意味着：\n\n- 游戏只进行一轮；\n- 第 $0$ 种颜色奖券上的数字分别是 $5$ 和 $9$；\n- 第 $1$ 种颜色奖券上的数字分别是 $1$ 和 $4$；\n- 第 $2$ 种颜色奖券上的数字分别是 $3$ 和 $6$；\n- 第 $3$ 种颜色奖券上的数字分别是 $2$ 和 $7$；\n\n一种能够获得最优奖励的分配方案是：\n\n- 在第 $0$ 轮，Ringo 选择第 $0$ 种颜色的第 $1$ 张奖券（印有整数 $9$），第 $1$ 种颜色的第 $0$ 张奖券（印有整数 $1$），第 $2$ 种颜色的第 $0$ 张奖券（印有整数 $3$），第 $3$ 种颜色的第 $1$ 张奖券（印有整数 $7$）。本轮能够获得的最小奖励是 $12$。例如，游戏负责人可以选择 $b=3$：$|3-9| + |3-1| + |3-3| + |3-7| = 6 + 2 + 0 + 4 = 12$。\n\n为了给出这个分配方案，函数 `find_maximum` 应该按照如下方式调用 `allocate_tickets`：\n\n```cpp\nallocate_tickets([[-1, 0], [0, -1], [0, -1], [-1, 0]])\n```\n\n最终，函数 `find_maximum` 应该返回数字 $12$。\n\n#### 约束条件\n\n- $2\\le n\\le 1500$ 且 $n$ 为偶数\n- $1\\le k\\le m\\le 1500$\n- $0 \\le x[i][j] \\le 10^9$（对于所有的 $0 \\le i \\le n-1$ 且 $0 \\le j \\le m-1$）\n- $x[i][j-1] \\le x[i][j]$（对于所有的 $0 \\le i \\le n-1$ 且 $0 \\le j \\le m-1$）\n\n#### 子任务\n\n1. （11 分）$m=1$\n2. （16 分）$k=1$\n3. （14 分）$0 \\le x[i][j] \\le 1$（对于所有的 $0 \\le i \\le n-1$ 且 $0 \\le j \\le m-1$）\n4. （14 分）$k=m$\n5. （12 分）$n,m \\le 80$\n6. （23 分）$n,m \\le 300$\n7. （10 分）没有额外约束条件\n\n#### 评测程序示例\n\n评测程序示例按照下面的格式读入数据：\n\n第 $1$ 行：$n\\ m\\ k$        \n第 $2+i$ 行（$0 \\le i \\le n-1$）：$x[i][0]\\ x[i][1]\\ \\ldots \\ x[i][m-1]$\n\n评测程序示例按照下面的格式打印你的答案：\n\n第 $1$ 行：`find_maximum` 的返回值       \n第 $2+i$ 行（$0 \\le i \\le n-1$）：$s[i][0]\\ s[i][1]\\ \\ldots\\ s[i][m-1]$", "locale": "zh-CN"}}}
{"pid": "P6832", "type": "P", "difficulty": 1, "samples": [["abababab", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "贪心", "2020", "O2优化", "洛谷月赛"], "title": "[Cnoi2020] 子弦", "background": "", "description": "Cirno 有一个字符串 $\\texttt{S}$，并希望你能求出 $\\texttt{S}$ 出现次数最多的非空子串的出现次数，记作 $p$。", "inputFormat": "一行，一个字符串 $\\texttt{S}$。", "outputFormat": "一行，一个整数 $p$。", "hint": "### 数据范围与约定\n\n对于 $100\\%$ 的数据保证: $0< |\\texttt{S}| \\le 10^7$，$\\texttt{S}_x\\in[\\texttt{a},\\texttt{z}]$。\n\n#### 子任务「本题采用捆绑测试」\n - Subtask1（$40\\%$）：$|\\texttt{S}| \\le 100$。\n - Subtask2（$40\\%$）：$|\\texttt{S}| \\le 10^5$。\n - Subtask3（$20\\%$）：无特殊限制。\n\n### 名词解释\n - **子串**：字符串中任意个连续的字符组成的子序列称为该串的子串。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Cnoi2020] 子弦", "background": "", "description": "Cirno 有一个字符串 $\\texttt{S}$，并希望你能求出 $\\texttt{S}$ 出现次数最多的非空子串的出现次数，记作 $p$。", "inputFormat": "一行，一个字符串 $\\texttt{S}$。", "outputFormat": "一行，一个整数 $p$。", "hint": "### 数据范围与约定\n\n对于 $100\\%$ 的数据保证: $0< |\\texttt{S}| \\le 10^7$，$\\texttt{S}_x\\in[\\texttt{a},\\texttt{z}]$。\n\n#### 子任务「本题采用捆绑测试」\n - Subtask1（$40\\%$）：$|\\texttt{S}| \\le 100$。\n - Subtask2（$40\\%$）：$|\\texttt{S}| \\le 10^5$。\n - Subtask3（$20\\%$）：无特殊限制。\n\n### 名词解释\n - **子串**：字符串中任意个连续的字符组成的子序列称为该串的子串。\n", "locale": "zh-CN"}}}
{"pid": "P6833", "type": "P", "difficulty": 4, "samples": [["5 5 1 2 4\n1 8 1 6 6\n1 1 1 2 4\n8 3 1 2 2\n1 2 1 9 1\n1 0 9 1 1", "15"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "2020", "O2优化", "最短路", "洛谷月赛"], "title": "[Cnoi2020] 雷雨", "background": "> 令人不安的云开始笼罩天空。  \n巨大的建筑在强风中轧轧作响。  \n幻想乡中响彻着不和协音。  \n——「东方辉针城 ～ Double Dealing Character」\n\n一个雷雨交加的夜晚，一束闪电击中了雾之湖畔的红魔馆和迷途竹林。\n\n似乎有什么大事要发生，Cirno 在小屋静静地中思考着。", "description": "幻想乡的纵切面可以抽象成一个 $n\\times m$ 的矩形。\n\n其中每一个 $1\\times 1$ 的单元格 $(i,j)$ 都有一个**电阻计量值**(虚构的概念) $R_{i,j}$。\n\n闪电从**雷雨云**上的 $\\texttt{O}(n,a)$ 发出，击中了**地面**上的*红魔馆* $\\texttt{A}(1,b)$ 与*迷途竹林* $\\texttt{B}(1,c)$。\n\n雷电是自然的造物，所以覆盖的位置电阻计量值总和最小，即从 $\\texttt{O}$ 到 $\\texttt{A}$ 与 $\\texttt{B}$ 的**两条路径的并集**的电阻计量值的和最小。\n\n所以在所有位置电阻计量已知的情况下，Cirno 想知道雷电的经过的路径的最小电阻计量值的和。", "inputFormat": "第一行，五个整数 $n,m,a,b,c$。$(0<a,b,c\\le m)$\n\n以下 $n$ 行，每行 $m$ 个整数，表示电阻计量 $R_{i,j}$，其中第一行表示雷雨云，最后一行表示地面。", "outputFormat": "一行，一个整数，表示答案。", "hint": "## 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ozs40i3.png)\n\n如图黄色线为闪电的路径。\n\n## 数据范围与约定\n\n对于 $100\\%$ 的数据保证：$0<n,m \\le 1000$，$0 \\le R_{i,j}\\le 10^9$，$0< a,b,c \\le m$。\n\n#### 子任务「本题采用捆绑测试」\n\n - Subtask1（$10\\%$）: $R_{i,j}\\in\\{1\\}$。\n - Subtask2（$10\\%$）: $R_{i,j}\\in\\{0,1\\}$。\n - Subtask3（$10\\%$）: $a=b=c$。\n - Subtask4（$10\\%$）: $n,m \\le 5$。\n - Subtask5（$60\\%$）: 无特殊限制。\n ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Cnoi2020] 雷雨", "background": "> 令人不安的云开始笼罩天空。  \n巨大的建筑在强风中轧轧作响。  \n幻想乡中响彻着不和协音。  \n——「东方辉针城 ～ Double Dealing Character」\n\n一个雷雨交加的夜晚，一束闪电击中了雾之湖畔的红魔馆和迷途竹林。\n\n似乎有什么大事要发生，Cirno 在小屋静静地中思考着。", "description": "幻想乡的纵切面可以抽象成一个 $n\\times m$ 的矩形。\n\n其中每一个 $1\\times 1$ 的单元格 $(i,j)$ 都有一个**电阻计量值**(虚构的概念) $R_{i,j}$。\n\n闪电从**雷雨云**上的 $\\texttt{O}(n,a)$ 发出，击中了**地面**上的*红魔馆* $\\texttt{A}(1,b)$ 与*迷途竹林* $\\texttt{B}(1,c)$。\n\n雷电是自然的造物，所以覆盖的位置电阻计量值总和最小，即从 $\\texttt{O}$ 到 $\\texttt{A}$ 与 $\\texttt{B}$ 的**两条路径的并集**的电阻计量值的和最小。\n\n所以在所有位置电阻计量已知的情况下，Cirno 想知道雷电的经过的路径的最小电阻计量值的和。", "inputFormat": "第一行，五个整数 $n,m,a,b,c$。$(0<a,b,c\\le m)$\n\n以下 $n$ 行，每行 $m$ 个整数，表示电阻计量 $R_{i,j}$，其中第一行表示雷雨云，最后一行表示地面。", "outputFormat": "一行，一个整数，表示答案。", "hint": "## 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ozs40i3.png)\n\n如图黄色线为闪电的路径。\n\n## 数据范围与约定\n\n对于 $100\\%$ 的数据保证：$0<n,m \\le 1000$，$0 \\le R_{i,j}\\le 10^9$，$0< a,b,c \\le m$。\n\n#### 子任务「本题采用捆绑测试」\n\n - Subtask1（$10\\%$）: $R_{i,j}\\in\\{1\\}$。\n - Subtask2（$10\\%$）: $R_{i,j}\\in\\{0,1\\}$。\n - Subtask3（$10\\%$）: $a=b=c$。\n - Subtask4（$10\\%$）: $n,m \\le 5$。\n - Subtask5（$60\\%$）: 无特殊限制。\n ", "locale": "zh-CN"}}}
{"pid": "P6834", "type": "P", "difficulty": 5, "samples": [["3 2\n2 1 3", "499122180"], ["10 1\n580461319 261515299 384092031 741339597 746815717 566875585 354719606 821499852 330315651 349091676", "553073655"], ["10 9\n497873025 114058764 159468194 207476408 138162972 678927661 223886159 325207554 470061543 658861685", "180853894"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "O2优化", "洛谷月赛"], "title": "[Cnoi2020] 梦原", "background": "> 成熟是一种明亮而不刺眼的光辉，一种圆润而不腻耳的音响，一种不再需要对别人察言观色的从容，一种终于停止向周围申述求告的大气，一种不理会哄闹的微笑，一种洗刷了偏激的淡漠,一种无须声张的厚实，一种并不陡峭的高度。勃郁的豪情发过了酵，尖利的山风收住了劲，湍急的溪流汇成了湖。  \n——余秋雨《文化苦旅》\n\n在一个偶然的梦境中，Cirno 发现了一棵树，在一望无际的昏暗平原上，发出了淡淡的蓝色荧光。\n\nHere lies $\\ \\ \\ \\ \\ \\ \\ \\ \\ $.  ", "description": "不幸的是，这棵树尚未长成，只有一个根节点 $1$。\n\nCirno 只能知道这棵树将会有 $n$ 个结点，上面分别有 $a_1,a_2,\\ldots,a_n$ 颗果实，却无法知道树的形状。\n\n但是树的生长总是具有某种规律。\n\n对于结点 $i$，它会**等概率地**从 $[i-k,i-1] \\cap N^+$ 中选择一个结点连接，并成为那个节点的子节点。\n\n其中，$k$ 是一个 Cirno 已经测出的常数。\n\n为了摘下所有的果实，在树长成之后，Cirno 会多次使用魔法。其中每次会在树上选一个联通块，并从联通块内每个结点上摘取一个果子（必须保证该联通块内**每个结点都有果子**）。\n\n显然，Cirno 会采取**最佳策略**使得使用魔法的次数最少。\n\n现在，Cirno 已经知道了 $n$，$k$ 和每个结点将会长出的果子数 $a_i$，请你帮她计算出她最少使用的魔法次数的数学期望。为了简单起见，你只需要输出答案除以 $998244353$ 的余数。", "inputFormat": "第一行输入两个整数 $n$，$k$，含义如上所述。\n\n第二行输入 $n$ 个整数，表示 $a_1,a_2,\\cdots,a_n$。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "## 样例 1 解释：\n\n可能长成的树有如下两种（黑色为结点编号，红色为结点上果子数）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vpdxwme.png)\n\n最佳方案是对联通块 $\\{1,2,3\\}$ 和 $\\{1\\}$ 各使用一次魔法，$\\{3\\}$ 使用两次，共四次。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nnbwq0af.png)\n\n最佳方案对联通块 $\\{1,2,3\\},\\{1,3\\}$ 和 $\\{3\\}$ 各使用一次魔法，共三次。\n\n所以答案为 $\\frac{7}{2}\\equiv 499122180\\pmod{998244353}$\n\n## 数据范围与约定\n\n对于 $100\\%$ 的数据，保证 $1\\le k<n\\le 10^6$，$0\\le a_i<998244353$。\n\n### 子任务「本题采用捆绑测试」\n\n- Subtask1（$10\\%$）: $k=1$。\n- Subtask2（$10\\%$）: $n \\le 10$，$a_i \\in \\{0,1\\}$。\n- Subtask3（$10\\%$）: $n \\le 10$。\n- Subtask4（$10\\%$）: $n \\le 1000$。\n- Subtask5（$60\\%$）: 无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Cnoi2020] 梦原", "background": "> 成熟是一种明亮而不刺眼的光辉，一种圆润而不腻耳的音响，一种不再需要对别人察言观色的从容，一种终于停止向周围申述求告的大气，一种不理会哄闹的微笑，一种洗刷了偏激的淡漠,一种无须声张的厚实，一种并不陡峭的高度。勃郁的豪情发过了酵，尖利的山风收住了劲，湍急的溪流汇成了湖。  \n——余秋雨《文化苦旅》\n\n在一个偶然的梦境中，Cirno 发现了一棵树，在一望无际的昏暗平原上，发出了淡淡的蓝色荧光。\n\nHere lies $\\ \\ \\ \\ \\ \\ \\ \\ \\ $.  ", "description": "不幸的是，这棵树尚未长成，只有一个根节点 $1$。\n\nCirno 只能知道这棵树将会有 $n$ 个结点，上面分别有 $a_1,a_2,\\ldots,a_n$ 颗果实，却无法知道树的形状。\n\n但是树的生长总是具有某种规律。\n\n对于结点 $i$，它会**等概率地**从 $[i-k,i-1] \\cap N^+$ 中选择一个结点连接，并成为那个节点的子节点。\n\n其中，$k$ 是一个 Cirno 已经测出的常数。\n\n为了摘下所有的果实，在树长成之后，Cirno 会多次使用魔法。其中每次会在树上选一个联通块，并从联通块内每个结点上摘取一个果子（必须保证该联通块内**每个结点都有果子**）。\n\n显然，Cirno 会采取**最佳策略**使得使用魔法的次数最少。\n\n现在，Cirno 已经知道了 $n$，$k$ 和每个结点将会长出的果子数 $a_i$，请你帮她计算出她最少使用的魔法次数的数学期望。为了简单起见，你只需要输出答案除以 $998244353$ 的余数。", "inputFormat": "第一行输入两个整数 $n$，$k$，含义如上所述。\n\n第二行输入 $n$ 个整数，表示 $a_1,a_2,\\cdots,a_n$。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "## 样例 1 解释：\n\n可能长成的树有如下两种（黑色为结点编号，红色为结点上果子数）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vpdxwme.png)\n\n最佳方案是对联通块 $\\{1,2,3\\}$ 和 $\\{1\\}$ 各使用一次魔法，$\\{3\\}$ 使用两次，共四次。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nnbwq0af.png)\n\n最佳方案对联通块 $\\{1,2,3\\},\\{1,3\\}$ 和 $\\{3\\}$ 各使用一次魔法，共三次。\n\n所以答案为 $\\frac{7}{2}\\equiv 499122180\\pmod{998244353}$\n\n## 数据范围与约定\n\n对于 $100\\%$ 的数据，保证 $1\\le k<n\\le 10^6$，$0\\le a_i<998244353$。\n\n### 子任务「本题采用捆绑测试」\n\n- Subtask1（$10\\%$）: $k=1$。\n- Subtask2（$10\\%$）: $n \\le 10$，$a_i \\in \\{0,1\\}$。\n- Subtask3（$10\\%$）: $n \\le 10$。\n- Subtask4（$10\\%$）: $n \\le 1000$。\n- Subtask5（$60\\%$）: 无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P6835", "type": "P", "difficulty": 5, "samples": [["1 5 5\n1 1\n2 2\n3 3\n4 4\n5 5", "10"], ["2 5 5\n1 1\n2 1\n3 2\n4 3\n5 4", "30"], ["3 5 5\n1 1\n2 1\n3 1\n4 1\n5 1", "62"], ["4 5 5\n1 1\n3 1\n4 2\n5 1\n5 5", "35"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2020", "O2优化", "期望", "洛谷月赛"], "title": "[Cnoi2020] 线形生物", "background": "> 为了能够在冥界过上这种愉快的生活而不是被判入地狱，人类们摒弃了自行结束生命的做法，拼尽全力地生活着。如此看来，人类似乎也显得有些积极与可爱了呢。  （射命丸 文） \n\n线形生物沿着一维的阶梯向着冥界单向地前行着。\n\n照这样的话，它只需要一级一级地，走 $n$ 步就能够到达白玉楼。\n\n但 Cirno 觉得这样太单调了，于是，一维的壁垒被打破，链状的道路生出了花椰菜状的枝桠。\n\n", "description": "线形生物要从 $1$ 号台阶走到 $n+1$ 号台阶。\n\n最开始，$1,2,3,\\ldots,n$ 号台阶都有一条连向下一台阶的有向边 $i\\rightarrow i+1$。\n\n之后 Cirno 加入了 $m$ 条**返祖边** $u_i \\rightarrow v_i (u_i \\ge v_i)$，它们构成了一个**返祖图**。\n\n线形生物每步会 **等概率地** 选取当前台阶的一条出边并走向对应的台阶。\n\n当走到 $n+1$ 号台阶时，线形生物就会停止行走。\n\n同时，Cirno 会统计线性生物总共走的步数，记作 $\\delta$。\n\nCirno 想知道 $E(\\delta)$（即 $\\delta$ 的**数学期望**）对 $998244353$ 取模后的结果。", "inputFormat": "第一行三个整数 $id$，$n$，$m$。\n\n以下 $m$ 行，每行两个整数 $u_i$，$v_i$。\n\n$id$ 表示 subtask 编号，其它字母含义同上文。", "outputFormat": "一行，一个整数 $E(\\delta)$，字母含义同上文。", "hint": "## 后置数学知识\n - **可能用到的幂级数求和** : 若 $x>1$，则有 $\\sum\\limits_{i=1}^{\\infty}\\big(\\frac{1}{x}\\big)^i=\\frac{1}{x}+\\frac{1}{x^2}+\\frac{1}{x^3}+\\cdots=\\frac{1}{x-1}$。\n - **数学期望** : 随机试验中每次可能结果的概率乘以其结果的总和，反映随机变量平均取值的大小。\n - **离散期望公式** : $E(x)=\\sum\\limits_{k=1}^{\\infty}x_kp_k$。\n \n## 数据范围与约定\n\n对于 $100\\%$ 的数据，保证：$id \\in \\{1,2,3,4,5\\}$，$0 < n,m \\le 10^6$，$1 \\le v_i \\le u_i \\le n$。\n\n#### 子任务「本题采用捆绑测试」\n\n - Subtask1（$10\\%$）: 返祖图中所有点都有自环且所有边均为自环(未画出)，总图形如 :  \n ![](https://cdn.luogu.com.cn/upload/image_hosting/6fikv6ft.png)\n   \n - Subtask2（$10\\%$）: 返祖图中所有点均向且仅向自己的前驱连边，特别地，$1$ 号节点的前驱是 $1$ 号节点，总图形如 :  \n   ![](https://cdn.luogu.com.cn/upload/image_hosting/6rc9dazb.png)\n \n - Subtask3（$10\\%$）: 返祖图中所有点均向且仅向 $1$ 号节点连边，总图形如 :  \n ![](https://cdn.luogu.com.cn/upload/image_hosting/wup1ctvu.png)\n \n - Subtask4（$10\\%$）: $n \\le 100$，$m \\le 1000$。\n \n - Subtask5（$60\\%$）: 无特殊限制。\n \n ## 后记\n \n  题目名称出自 th17 东方鬼形兽 6 Boss 埴安神袿姬 Hard / Lunatic 难度符卡 線形「リニアクリーチャー」。\n  ", "locale": "zh-CN", "translations": {"en": {"title": "[Cnoi2020] Linear Creatures.", "background": "> In order to live happily in the Underworld rather than being sentenced to hell, humans have abandoned the practice of ending their own lives and are doing their best to live. From this perspective, humans seem somewhat positive and lovable. (Shameimaru Aya)\n\nLinear creatures move one-way toward the Underworld along a one-dimensional staircase.\n\nIn that case, it only needs to climb step by step for $n$ steps to reach Hakugyokurou.\n\nBut Cirno felt this was too monotonous, so the one-dimensional barrier was broken, and the chain-like road grew cauliflower-like branches.", "description": "A linear creature needs to walk from step $1$ to step $n+1$.\n\nAt the beginning, for steps $1,2,3,\\ldots,n$, each step has a directed edge to the next step $i\\rightarrow i+1$.\n\nThen Cirno adds $m$ **atavistic edges** $u_i \\rightarrow v_i (u_i \\ge v_i)$, which form an **atavistic graph**.\n\nAt each step, the linear creature will choose **uniformly at random** one outgoing edge from the current step and move to the corresponding step.\n\nWhen it reaches step $n+1$, it stops walking.\n\nMeanwhile, Cirno counts the total number of steps the linear creature takes, denoted by $\\delta$.\n\nCirno wants to know the value of $E(\\delta)$ (i.e. the **mathematical expectation** of $\\delta$) modulo $998244353$.", "inputFormat": "The first line contains three integers $id$, $n$, and $m$.\n\nThe next $m$ lines each contain two integers $u_i$ and $v_i$.\n\n$id$ indicates the subtask ID. The meanings of the other letters are the same as above.", "outputFormat": "One line with one integer: $E(\\delta)$. The meanings of the letters are the same as above.", "hint": "## Required Mathematical Knowledge\n - **Power series summation that may be used**: If $x>1$, then $\\sum\\limits_{i=1}^{\\infty}\\big(\\frac{1}{x}\\big)^i=\\frac{1}{x}+\\frac{1}{x^2}+\\frac{1}{x^3}+\\cdots=\\frac{1}{x-1}$.\n - **Mathematical expectation**: In a random experiment, the sum of the probability of each possible outcome multiplied by its outcome, reflecting the average value of a random variable.\n - **Discrete expectation formula**: $E(x)=\\sum\\limits_{k=1}^{\\infty}x_kp_k$.\n\n## Constraints and Conventions\n\nFor $100\\%$ of the testdata, it is guaranteed that $id \\in \\{1,2,3,4,5\\}$, $0 < n,m \\le 10^6$, and $1 \\le v_i \\le u_i \\le n$.\n\n#### Subtasks (This problem uses bundled evaluation)\n\n - Subtask1 ($10\\%$): In the atavistic graph, every node has a self-loop and all edges are self-loops (not drawn). The whole graph looks like:  \n ![](https://cdn.luogu.com.cn/upload/image_hosting/6fikv6ft.png)\n\n - Subtask2 ($10\\%$): In the atavistic graph, every node has an edge to and only to its predecessor. In particular, the predecessor of node $1$ is node $1$. The whole graph looks like:  \n   ![](https://cdn.luogu.com.cn/upload/image_hosting/6rc9dazb.png)\n\n - Subtask3 ($10\\%$): In the atavistic graph, every node has an edge to and only to node $1$. The whole graph looks like:  \n ![](https://cdn.luogu.com.cn/upload/image_hosting/wup1ctvu.png)\n\n - Subtask4 ($10\\%$): $n \\le 100$, $m \\le 1000$.\n\n - Subtask5 ($60\\%$): No special restrictions.\n\n## Postscript\n\nThe problem name comes from Touhou Kikeijuu (th17), Stage 6 Boss Keiki Haniyasushin, Hard / Lunatic difficulty spell card: 線形「リニアクリーチャー」.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Cnoi2020] 线形生物", "background": "> 为了能够在冥界过上这种愉快的生活而不是被判入地狱，人类们摒弃了自行结束生命的做法，拼尽全力地生活着。如此看来，人类似乎也显得有些积极与可爱了呢。  （射命丸 文） \n\n线形生物沿着一维的阶梯向着冥界单向地前行着。\n\n照这样的话，它只需要一级一级地，走 $n$ 步就能够到达白玉楼。\n\n但 Cirno 觉得这样太单调了，于是，一维的壁垒被打破，链状的道路生出了花椰菜状的枝桠。\n\n", "description": "线形生物要从 $1$ 号台阶走到 $n+1$ 号台阶。\n\n最开始，$1,2,3,\\ldots,n$ 号台阶都有一条连向下一台阶的有向边 $i\\rightarrow i+1$。\n\n之后 Cirno 加入了 $m$ 条**返祖边** $u_i \\rightarrow v_i (u_i \\ge v_i)$，它们构成了一个**返祖图**。\n\n线形生物每步会 **等概率地** 选取当前台阶的一条出边并走向对应的台阶。\n\n当走到 $n+1$ 号台阶时，线形生物就会停止行走。\n\n同时，Cirno 会统计线性生物总共走的步数，记作 $\\delta$。\n\nCirno 想知道 $E(\\delta)$（即 $\\delta$ 的**数学期望**）对 $998244353$ 取模后的结果。", "inputFormat": "第一行三个整数 $id$，$n$，$m$。\n\n以下 $m$ 行，每行两个整数 $u_i$，$v_i$。\n\n$id$ 表示 subtask 编号，其它字母含义同上文。", "outputFormat": "一行，一个整数 $E(\\delta)$，字母含义同上文。", "hint": "## 后置数学知识\n - **可能用到的幂级数求和** : 若 $x>1$，则有 $\\sum\\limits_{i=1}^{\\infty}\\big(\\frac{1}{x}\\big)^i=\\frac{1}{x}+\\frac{1}{x^2}+\\frac{1}{x^3}+\\cdots=\\frac{1}{x-1}$。\n - **数学期望** : 随机试验中每次可能结果的概率乘以其结果的总和，反映随机变量平均取值的大小。\n - **离散期望公式** : $E(x)=\\sum\\limits_{k=1}^{\\infty}x_kp_k$。\n \n## 数据范围与约定\n\n对于 $100\\%$ 的数据，保证：$id \\in \\{1,2,3,4,5\\}$，$0 < n,m \\le 10^6$，$1 \\le v_i \\le u_i \\le n$。\n\n#### 子任务「本题采用捆绑测试」\n\n - Subtask1（$10\\%$）: 返祖图中所有点都有自环且所有边均为自环(未画出)，总图形如 :  \n ![](https://cdn.luogu.com.cn/upload/image_hosting/6fikv6ft.png)\n   \n - Subtask2（$10\\%$）: 返祖图中所有点均向且仅向自己的前驱连边，特别地，$1$ 号节点的前驱是 $1$ 号节点，总图形如 :  \n   ![](https://cdn.luogu.com.cn/upload/image_hosting/6rc9dazb.png)\n \n - Subtask3（$10\\%$）: 返祖图中所有点均向且仅向 $1$ 号节点连边，总图形如 :  \n ![](https://cdn.luogu.com.cn/upload/image_hosting/wup1ctvu.png)\n \n - Subtask4（$10\\%$）: $n \\le 100$，$m \\le 1000$。\n \n - Subtask5（$60\\%$）: 无特殊限制。\n \n ## 后记\n \n  题目名称出自 th17 东方鬼形兽 6 Boss 埴安神袿姬 Hard / Lunatic 难度符卡 線形「リニアクリーチャー」。\n  ", "locale": "zh-CN"}}}
{"pid": "P6836", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2020", "IOI", "交互题"], "title": "[IOI 2020] 装饼干", "background": "### 注意：本题仅支持 C++ 语言提交，且不应使用 C++14 (GCC 9)。\n\n你无需在代码中添加：\n\n```cpp\n#include \"biscuits.h\"\n```", "description": "Khong 阿姨在组织一场有 $x$ 位选手参加的竞赛，她打算给每位选手一 **袋饼干**。总共有 $k$ 种不同类型的饼干，编号为从 $0$ 到 $k-1$。类型为 $i(0 \\le i \\le k-1)$ 的每块饼干都有一个 **口味值** $2^i$。在 Khong 阿姨的食品储藏室里，有 $a[i]$（有可能为 $0$）块类型为 $i$ 的饼干。\n\n对每种类型的饼干，Khong 阿姨在每个袋子都会装上 $0$ 或者多块。所有袋子里面类型为 $i$ 的饼干的总块数不能超过 $a[i]$。一个袋子里面所有饼干的口味值的总和，被称为这袋饼干的 **总口味值**。\n\n请帮 Khong 阿姨算一下，究竟存在多少不同的 $y$ 值，使得她可以装出 $x$ 袋饼干，而且每袋饼干的总口味值都等于 $y$。\n\n#### 实现细节\n\n你需要实现下面的这个函数：\n\n```cpp\nlong long count_tastiness(long long x, std::vector<long long> a)\n```\n\n- $x$：需要装的饼干袋的数量。\n- $a$：长度为 $k$ 的数组。对 $0 \\le i \\le k-1$，$a[i]$ 表示在食物储藏室里类型为 $i$ 的饼干数量。\n- 此函数应当返回不同 $y$ 值的数目，使得阿姨可以装出 $x$ 袋饼干，且每袋饼干的总口味值都为 $y$。\n- 此函数会被调用 $q$ 次 (对于允许的 $q$ 值，详见约束条件和子任务部分)。每次调用应当被看成是独立的场景。", "inputFormat": "见实现细节。", "outputFormat": "见实现细节。", "hint": "#### 样例说明\n\n#### 例 1\n\n考虑如下调用：\n\n```cpp\ncount_tastiness(3, [5, 2, 1])\n```\n\n这意味着阿姨打算装 $3$ 袋饼干，而在食物储藏室里总共有 $3$ 种类型的饼干：\n\n- $5$ 块类型为 $0$ 的饼干，每块的口味值为 $1$，\n- $2$ 块类型为 $1$ 的饼干，每块的口味值为 $2$，\n- $1$ 块类型为 $2$ 的饼干，其口味值为 $4$。\n\n$y$ 能够取的值为 $[0,1,2,3,4]$。举例来说，为了装出总口味值均为 $3$ 的 $3$ 袋饼干，阿姨可以这样装：\n\n- 一袋饼干里有 $3$ 块类型为 $0$ 的饼干，以及\n- 两袋饼干，其中各有一块类型为 $0$ 的饼干和一块类型为 $1$ 的饼干。\n\n由于总共有 $5$ 个可能的 $y$ 值，函数应当返回 $5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/db3xoxfy.png)\n\n#### 例 2\n\n考虑如下调用：\n\n```cpp\ncount_tastiness(2, [2, 1, 2])\n```\n\n这意味着阿姨打算装 $2$ 袋饼干，而在食物储藏室里总共有 $3$ 种类型的饼干：\n\n- $2$ 块类型为 $0$ 的饼干，每块的口味值为 $1$，\n- $1$ 块类型为 $1$ 的饼干，其口味值为 $2$，\n- $2$ 块类型为 $2$ 的饼干，每块的口味值为 $4$。\n\n$y$ 能够取的值为 $[0,1,2,4,5,6]$。由于总共有 $6$ 个可能的 $y$ 值，函数应当返回 $6$。\n\n#### 约束条件\n\n- $1 \\le k \\le 60$\n- $1 \\le q \\le 1000$\n- $1 \\le x \\le 10^{18}$\n- $0 \\le a[i] \\le 10^{18}$（对于所有的 $0 \\le i \\le k-1$）\n- 对于 `count_tastiness` 的每次调用，食物储藏室里所有饼干的口味值总和都不会超过 $10^{18}$。\n\n#### 子任务\n\n1. (9 分) $q \\le 10$，且对于 `count_tastiness` 的每次调用，食物储藏室里所有饼干的口味值总和都不会超过 $10^5$。\n2. (12 分) $x=1,q \\le 10$\n3. (21 分) $x \\le 10^4,q \\le 10$\n4. (35 分) 对于 `count_tastiness` 的每次调用，正确的返回结果都不会超过 $2 \\times 10^5$。\n5. (23 分) 没有附加限制条件。\n\n#### 评测程序示例\n\n评测程序示例将读取如下格式的输入数据。第一行包含一个整数 $q$。接下来是 $q$ 对这样的两行：它们按照下面的格式来描述一个单独的场景：\n\n第 $1$ ⾏：$k\\ x$       \n第 $2$ ⾏：$a[0]\\ a[1]\\ \\ldots\\ a[k-1]$\n\n评测程序示例的输出结果的格式如下：\n\n第 $i$ 行 ($1 \\le i \\le q$)：`count_tastiness` 对于输入数据中第 $i$ 个场景的返回值。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2020] 装饼干", "background": "### 注意：本题仅支持 C++ 语言提交，且不应使用 C++14 (GCC 9)。\n\n你无需在代码中添加：\n\n```cpp\n#include \"biscuits.h\"\n```", "description": "Khong 阿姨在组织一场有 $x$ 位选手参加的竞赛，她打算给每位选手一 **袋饼干**。总共有 $k$ 种不同类型的饼干，编号为从 $0$ 到 $k-1$。类型为 $i(0 \\le i \\le k-1)$ 的每块饼干都有一个 **口味值** $2^i$。在 Khong 阿姨的食品储藏室里，有 $a[i]$（有可能为 $0$）块类型为 $i$ 的饼干。\n\n对每种类型的饼干，Khong 阿姨在每个袋子都会装上 $0$ 或者多块。所有袋子里面类型为 $i$ 的饼干的总块数不能超过 $a[i]$。一个袋子里面所有饼干的口味值的总和，被称为这袋饼干的 **总口味值**。\n\n请帮 Khong 阿姨算一下，究竟存在多少不同的 $y$ 值，使得她可以装出 $x$ 袋饼干，而且每袋饼干的总口味值都等于 $y$。\n\n#### 实现细节\n\n你需要实现下面的这个函数：\n\n```cpp\nlong long count_tastiness(long long x, std::vector<long long> a)\n```\n\n- $x$：需要装的饼干袋的数量。\n- $a$：长度为 $k$ 的数组。对 $0 \\le i \\le k-1$，$a[i]$ 表示在食物储藏室里类型为 $i$ 的饼干数量。\n- 此函数应当返回不同 $y$ 值的数目，使得阿姨可以装出 $x$ 袋饼干，且每袋饼干的总口味值都为 $y$。\n- 此函数会被调用 $q$ 次 (对于允许的 $q$ 值，详见约束条件和子任务部分)。每次调用应当被看成是独立的场景。", "inputFormat": "见实现细节。", "outputFormat": "见实现细节。", "hint": "#### 样例说明\n\n#### 例 1\n\n考虑如下调用：\n\n```cpp\ncount_tastiness(3, [5, 2, 1])\n```\n\n这意味着阿姨打算装 $3$ 袋饼干，而在食物储藏室里总共有 $3$ 种类型的饼干：\n\n- $5$ 块类型为 $0$ 的饼干，每块的口味值为 $1$，\n- $2$ 块类型为 $1$ 的饼干，每块的口味值为 $2$，\n- $1$ 块类型为 $2$ 的饼干，其口味值为 $4$。\n\n$y$ 能够取的值为 $[0,1,2,3,4]$。举例来说，为了装出总口味值均为 $3$ 的 $3$ 袋饼干，阿姨可以这样装：\n\n- 一袋饼干里有 $3$ 块类型为 $0$ 的饼干，以及\n- 两袋饼干，其中各有一块类型为 $0$ 的饼干和一块类型为 $1$ 的饼干。\n\n由于总共有 $5$ 个可能的 $y$ 值，函数应当返回 $5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/db3xoxfy.png)\n\n#### 例 2\n\n考虑如下调用：\n\n```cpp\ncount_tastiness(2, [2, 1, 2])\n```\n\n这意味着阿姨打算装 $2$ 袋饼干，而在食物储藏室里总共有 $3$ 种类型的饼干：\n\n- $2$ 块类型为 $0$ 的饼干，每块的口味值为 $1$，\n- $1$ 块类型为 $1$ 的饼干，其口味值为 $2$，\n- $2$ 块类型为 $2$ 的饼干，每块的口味值为 $4$。\n\n$y$ 能够取的值为 $[0,1,2,4,5,6]$。由于总共有 $6$ 个可能的 $y$ 值，函数应当返回 $6$。\n\n#### 约束条件\n\n- $1 \\le k \\le 60$\n- $1 \\le q \\le 1000$\n- $1 \\le x \\le 10^{18}$\n- $0 \\le a[i] \\le 10^{18}$（对于所有的 $0 \\le i \\le k-1$）\n- 对于 `count_tastiness` 的每次调用，食物储藏室里所有饼干的口味值总和都不会超过 $10^{18}$。\n\n#### 子任务\n\n1. (9 分) $q \\le 10$，且对于 `count_tastiness` 的每次调用，食物储藏室里所有饼干的口味值总和都不会超过 $10^5$。\n2. (12 分) $x=1,q \\le 10$\n3. (21 分) $x \\le 10^4,q \\le 10$\n4. (35 分) 对于 `count_tastiness` 的每次调用，正确的返回结果都不会超过 $2 \\times 10^5$。\n5. (23 分) 没有附加限制条件。\n\n#### 评测程序示例\n\n评测程序示例将读取如下格式的输入数据。第一行包含一个整数 $q$。接下来是 $q$ 对这样的两行：它们按照下面的格式来描述一个单独的场景：\n\n第 $1$ ⾏：$k\\ x$       \n第 $2$ ⾏：$a[0]\\ a[1]\\ \\ldots\\ a[k-1]$\n\n评测程序示例的输出结果的格式如下：\n\n第 $i$ 行 ($1 \\le i \\le q$)：`count_tastiness` 对于输入数据中第 $i$ 个场景的返回值。", "locale": "zh-CN"}}}
{"pid": "P6837", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "IOI", "交互题", "Special Judge"], "title": "[IOI 2020] 数蘑菇", "background": "不要 `#include \"mushrooms.h\"`。\n\n你需要在文件头加入以下内容，并**使用 $\\text{\\textcolor{red}{C++\\,23}}$ 提交**：\n\n```cpp line-numbers\n#include <vector>\nint use_machine(std::vector<int> x);\n```", "description": "研究蘑菇的专家安德鲁在研究新加坡的本地蘑菇。\n\n作为研究的一部分，安德鲁采集了 $n$ 个蘑菇，编号为 $0$ 到 $n-1$。每个蘑菇均为两种蘑菇种类之⼀，称为 $A$ 或 $B$。\n\n安德鲁知道**蘑菇 $0$ 属于种类 $A$**, 但是由于这两种蘑菇看起来很相似，他不知道蘑菇 $1$ 到 $n-1$ 属于哪一种。\n\n幸运的是，安德鲁的实验室里有一台机器可以帮助他。在使用这台机器时，需要将两个或者多个蘑菇放到机器里，并摆成一排（以任意顺序），然后打开机器。接下来，这台机器会计算所有不属于同一种类的**相邻**蘑菇对的个数。例如，如果你把种类为 $\\left[A, B, B, A\\right]$ 的蘑菇（按照这个顺序）放到机器中，结果应该是 $2$。\n\n但是，因为机器操作非常昂贵，机器只能使用有限的次数。此外，在机器的所有使用中，放置到机器中的蘑菇总数不能超过 $10^5$。请使用这台机器帮助安德鲁来数一数他采集了多少个种类为 $A$ 的蘑菇。\n\n#### 实现细节\n\n你需要实现以下函数：\n\n```cpp line-numbers\nint count_mushrooms(int n)\n```\n\n- `n`: 安德鲁采集到的蘑菇数量。\n- 该函数应该被调用恰好一次，而且要返回种类为 $A$ 的蘑菇的个数。\n\n以上函数可以调用以下函数：\n\n```cpp line-numbers\nint use_machine(vector<int> x)\n```\n\n- `x`: 一个长度介于 $2$ 和 $n$ 的数组（包括 $2$ 和 $n$)，按顺序给出放在机器中的蘑菇的编号。\n- `x` 的元素必须是在 $0$ 到 $n-1$ 之间（包括 $0$ 和 $n-1$) **互不相同** 的整数。\n- 假设数组 `x` 的长度为 $d$。那么，此函数返回不同的下标 $j$ 的个数，满足 $0 \\le j \\le d-2$ 并且 $x[j]$ 和 $x[j+1]$ 属于不同种类。\n- 该函数最多可以被调用 $2 \\times 10^4$ 次。\n- 在对函数 `use_machine` 的所有调用中，所有被传到该函数 `use_machine` 的 $x$ 的总长度不能超过 $10^5$。", "inputFormat": null, "outputFormat": null, "hint": "#### 样例说明\n\n#### 例 1\n\n考虑以下场景：有 $3$ 个蘑菇，种类依次为 $\\left[A,B,B\\right]$。函数 `count_mushrooms` 用以下方式调用：\n\n```cpp line-numbers\ncount_mushrooms(3)\n```\n\n该函数可以调用 `use_machine([0, 1, 2])`，在该场景下调用返回 $1$。函数接着调用 `use_machine([2, 1])`，该调用返回 $0$。\n\n此时，已经有足够的信息来推出只有 $1$ 个 $A$ 类蘑菇。所以，函数 `count_mushrooms` 应该返回 $1$。\n\n#### 例 2\n\n考虑一个例子：有 $4$ 个蘑菇，种类依次为 $\\left[A,B,A,A\\right]$。函数 `count_mushrooms` 被调用如下：\n\n```cpp line-numbers\ncount_mushrooms(4)\n```\n\n该函数可以调用 `use_machine([0, 2, 1, 3])`，该调用返回 $2$。接着调用 `use_machine([1,2])`，该调用返回 $1$。\n\n此时，已有足够的信息推出：有 $3$ 个 $A$ 类蘑菇。因此，函数 `count_mushrooms` 应该返回 $3$。\n\n#### 约束条件\n\n- $2 \\le n \\le 2 \\times 10^4$\n\n#### 计分\n\n在所有测试用例中，如果对函数 `use_machine` 的调用不符合上面所述的要求，或者 `count_mushrooms` 的返回值不正确，你的解答得分将为 $0$。否则，令 $Q$ 为所有测试样例中对函数 `use_machine` 的最大调用次数。那么，得分将按照以下表格进行计算：\n\n|条件|得分|\n|:-:|:-:|\n|$2 \\times 10^4 \\le Q$|$0$|\n|$10010 < Q \\le 2 \\times 10^4$|$10$|\n|$904 < Q \\le 10010$|$25$|\n|$226 < Q \\le 904$|$\\dfrac{226}{Q} \\cdot 100$|\n|$Q \\le 226$|$100$|\n\n在有些测试用例上，评测程序的行为是自适应的。也就是说，在这些测试用例中，评测程序并没有一个固定的蘑菇种类序列。相反，评测程序中所给出的回答可能依赖于此前对 `use_machine` 的调用。\n\n但是可以保证，评测程序中所给出的回答满足：在每次交互之后，至少存在一个蘑菇种类序列，它能够与当前所给出过的所有回答都相符。\n\n#### 评测程序示例\n\n评测程序示例读入一个整数数组 $s$，该数组给出了蘑菇的种类。对于所有 $0 \\le i \\le n-1$，$s[i]=0$ 表示蘑菇 $i$ 的种类是 $A$，$s[i]=1$ 表示蘑菇 $i$ 的种类是 $B$。评测程序示例读取如下格式的输入数据：\n\n第 $1$ 行: $n$ \\\n第 $2$ 行: $s[0]\\ s[1]\\ \\ldots\\ s[n-1]$\n\n评测程序示例的输出为如下格式：\n\n第 $1$ 行: `count_mushrooms` 的返回值。 \\\n第 $2$ 行: 调用 `use_machine` 的次数。\n\n注意评测程序示例不是自适应的。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2020] 数蘑菇", "background": "不要 `#include \"mushrooms.h\"`。\n\n你需要在文件头加入以下内容，并**使用 $\\text{\\textcolor{red}{C++\\,23}}$ 提交**：\n\n```cpp line-numbers\n#include <vector>\nint use_machine(std::vector<int> x);\n```", "description": "研究蘑菇的专家安德鲁在研究新加坡的本地蘑菇。\n\n作为研究的一部分，安德鲁采集了 $n$ 个蘑菇，编号为 $0$ 到 $n-1$。每个蘑菇均为两种蘑菇种类之⼀，称为 $A$ 或 $B$。\n\n安德鲁知道**蘑菇 $0$ 属于种类 $A$**, 但是由于这两种蘑菇看起来很相似，他不知道蘑菇 $1$ 到 $n-1$ 属于哪一种。\n\n幸运的是，安德鲁的实验室里有一台机器可以帮助他。在使用这台机器时，需要将两个或者多个蘑菇放到机器里，并摆成一排（以任意顺序），然后打开机器。接下来，这台机器会计算所有不属于同一种类的**相邻**蘑菇对的个数。例如，如果你把种类为 $\\left[A, B, B, A\\right]$ 的蘑菇（按照这个顺序）放到机器中，结果应该是 $2$。\n\n但是，因为机器操作非常昂贵，机器只能使用有限的次数。此外，在机器的所有使用中，放置到机器中的蘑菇总数不能超过 $10^5$。请使用这台机器帮助安德鲁来数一数他采集了多少个种类为 $A$ 的蘑菇。\n\n#### 实现细节\n\n你需要实现以下函数：\n\n```cpp line-numbers\nint count_mushrooms(int n)\n```\n\n- `n`: 安德鲁采集到的蘑菇数量。\n- 该函数应该被调用恰好一次，而且要返回种类为 $A$ 的蘑菇的个数。\n\n以上函数可以调用以下函数：\n\n```cpp line-numbers\nint use_machine(vector<int> x)\n```\n\n- `x`: 一个长度介于 $2$ 和 $n$ 的数组（包括 $2$ 和 $n$)，按顺序给出放在机器中的蘑菇的编号。\n- `x` 的元素必须是在 $0$ 到 $n-1$ 之间（包括 $0$ 和 $n-1$) **互不相同** 的整数。\n- 假设数组 `x` 的长度为 $d$。那么，此函数返回不同的下标 $j$ 的个数，满足 $0 \\le j \\le d-2$ 并且 $x[j]$ 和 $x[j+1]$ 属于不同种类。\n- 该函数最多可以被调用 $2 \\times 10^4$ 次。\n- 在对函数 `use_machine` 的所有调用中，所有被传到该函数 `use_machine` 的 $x$ 的总长度不能超过 $10^5$。", "inputFormat": null, "outputFormat": null, "hint": "#### 样例说明\n\n#### 例 1\n\n考虑以下场景：有 $3$ 个蘑菇，种类依次为 $\\left[A,B,B\\right]$。函数 `count_mushrooms` 用以下方式调用：\n\n```cpp line-numbers\ncount_mushrooms(3)\n```\n\n该函数可以调用 `use_machine([0, 1, 2])`，在该场景下调用返回 $1$。函数接着调用 `use_machine([2, 1])`，该调用返回 $0$。\n\n此时，已经有足够的信息来推出只有 $1$ 个 $A$ 类蘑菇。所以，函数 `count_mushrooms` 应该返回 $1$。\n\n#### 例 2\n\n考虑一个例子：有 $4$ 个蘑菇，种类依次为 $\\left[A,B,A,A\\right]$。函数 `count_mushrooms` 被调用如下：\n\n```cpp line-numbers\ncount_mushrooms(4)\n```\n\n该函数可以调用 `use_machine([0, 2, 1, 3])`，该调用返回 $2$。接着调用 `use_machine([1,2])`，该调用返回 $1$。\n\n此时，已有足够的信息推出：有 $3$ 个 $A$ 类蘑菇。因此，函数 `count_mushrooms` 应该返回 $3$。\n\n#### 约束条件\n\n- $2 \\le n \\le 2 \\times 10^4$\n\n#### 计分\n\n在所有测试用例中，如果对函数 `use_machine` 的调用不符合上面所述的要求，或者 `count_mushrooms` 的返回值不正确，你的解答得分将为 $0$。否则，令 $Q$ 为所有测试样例中对函数 `use_machine` 的最大调用次数。那么，得分将按照以下表格进行计算：\n\n|条件|得分|\n|:-:|:-:|\n|$2 \\times 10^4 \\le Q$|$0$|\n|$10010 < Q \\le 2 \\times 10^4$|$10$|\n|$904 < Q \\le 10010$|$25$|\n|$226 < Q \\le 904$|$\\dfrac{226}{Q} \\cdot 100$|\n|$Q \\le 226$|$100$|\n\n在有些测试用例上，评测程序的行为是自适应的。也就是说，在这些测试用例中，评测程序并没有一个固定的蘑菇种类序列。相反，评测程序中所给出的回答可能依赖于此前对 `use_machine` 的调用。\n\n但是可以保证，评测程序中所给出的回答满足：在每次交互之后，至少存在一个蘑菇种类序列，它能够与当前所给出过的所有回答都相符。\n\n#### 评测程序示例\n\n评测程序示例读入一个整数数组 $s$，该数组给出了蘑菇的种类。对于所有 $0 \\le i \\le n-1$，$s[i]=0$ 表示蘑菇 $i$ 的种类是 $A$，$s[i]=1$ 表示蘑菇 $i$ 的种类是 $B$。评测程序示例读取如下格式的输入数据：\n\n第 $1$ 行: $n$ \\\n第 $2$ 行: $s[0]\\ s[1]\\ \\ldots\\ s[n-1]$\n\n评测程序示例的输出为如下格式：\n\n第 $1$ 行: `count_mushrooms` 的返回值。 \\\n第 $2$ 行: 调用 `use_machine` 的次数。\n\n注意评测程序示例不是自适应的。", "locale": "zh-CN"}}}
{"pid": "P6838", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "IOI", "Special Judge", "深度优先搜索 DFS", "通信题"], "title": "[IOI 2020] 网络站点（无法评测）", "background": null, "description": "新加坡的互联网主干网由 $n$ 个网络站点组成，这些站点分配了从 $0$ 到 $n-1$ 的 **序号**。互联网中还有 $n-1$ 条双向链路，它们从 $0$ 到 $n-2$ 编号。每条链路连接两个不同的站点。被一条链路连接着的两个站点互相称作对方的邻居。\n\n一个由互不相同的站点所组成的站点序列 $a_0,a_1,\\ldots,a_p$ 被称作一条从站点 $x$ 到站点 $y$ 的路径，当且仅当 $a_0=x$，$a_p=y$，并且序列中每两个连续的站点都是邻居。保证从任意站点 $x$ 到任意其他站点 $y$ **有且仅有** 一条路径。\n\n任意站点 $x$ 可以生成一个数据包，并把它发送给任意其他站点 $y$，站点 $y$ 称作这个数据包的 **目的站点**。数据包需要按下述规则在站点 $x$ 到站点 $y$ 的唯一路径上进行路由。假设数据包当前发送到了站点 $z$，其中 $y$ 是数据包的目的站点且 $z \\ne y$，则站点 $z$ 会：\n\n1. 执行 **路由函数**，找到 $z$ 到 $y$ 的唯⼀路径中 $z$ 的邻居。然后\n2. 将数据包转发给这个邻居。\n\n然而，站点有存储内存限制，可能无法存下路由函数中需要使用的完整的主干网链路列表。\n\n你的任务是实现主干网的路由机制，它由两个函数组成。\n\n- 第一个函数的输入参数为 $n$、主干网链路的列表和一个整数 $k \\ge n-1$。该函数需要为每个站点分配一个独一无二的 **编号**，其大小在 $0$ 到 $k$ 之间（包括 $0$ 和 $k$）。\n- 第二个函数是路由函数，它在站点编号分配好后部署到所有站点上。它的输入参数如下：\n\t- $s$，数据包当前所处的站点的 **编号**，\n\t- $t$，数据包的目的站点的 **编号** $(t \\ne s)$，\n\t- $c$，表示 $s$ 的所有邻居站点的 **编号** 的列表。\n\n该函数应该返回一个 $s$ 的邻居的 **编号**，表示数据包需要转发到的下个站点。\n\n在每个子任务中，你的得分取决于所有站点被分配到的编号的最大值（通常来说，编号最大值越小越好）。\n\n#### 实现细节\n\n你需要实现下列函数：\n\n```cpp\nint[] label(int n, int k, int[] u, int[] v)\n```\n\n- $n$: 主干网中站点的数量。\n- $k$: 可用的编号的最大值。\n- $u$ 和 $v$: 大小为 $n-1$ 的数组，表示链路。对每个 $i(0 \\le i \\le n-2)$，链路 $i$ 连接着序号为 $u[i]$ 和 $v[i]$ 的站点。\n- 该函数应该返回一个大小为 $n$ 的数组 $L$。对每个 $i(0 \\le i \\le n-1)$，$L[i]$ 表示序号为 $i$ 的站点所分配到的编号。数组 $L$ 中的所有元素必须互不相同并且大小在 $0$ 到 $k$ 之间。\n\n```cpp\nint find_next_station(int s, int t, int[] c)\n```\n\n- $s$: 数据包当前所在站点的编号。\n- $t$: 数据包目的站点的编号。\n- $c$: 一个数组，包含 $s$ 的所有邻居的编号。数组 $c$ 按照元素大小升序排列。\n- 该函数应该返回一个 $s$ 的邻居的编号，表示数据包需要转发到的下个站点。\n\n每个测试用例包含一个或多个独立的场景（也就是不同的主干网描述）。 对于一个包含 $r$ 个场景的测试用例，调用上述函数的评测程序会按下列步骤运行恰好两次。\n\n程序第一次运行期间：\n\n- `label` 函数被调用 $r$ 次。\n- 返回的编号将被评测系统保存。\n- 并且 `find_next_station` 不会被调用。\n\n程序第二次运行期间：\n\n- `find_next_station` 会被调用若干次。对于每次调用，评测程序会选择任意某个场景，该场景中的 `label` 函数所返回的编号方式将用于本次 `find_next_station` 调用。\n- `label` 不会被调用。\n- 特别地，在评测程序第一次运行期间，保存在静态或全局变量中的信息将无法在 `find_next_station` 函数中使用。", "inputFormat": null, "outputFormat": null, "hint": "#### 样例说明\n\n#### 例 1\n\n考虑下列调用：\n\n```cpp\nlabel(5, 10, [0, 1, 1, 2], [1, 2, 3, 4])\n```\n\n共有 $5$ 个站点和 $4$ 条链路，链路对应的站点序号对分别为 $(0,1)$, $(1,2)$, $(1,3)$ 和 $(2,4)$。编号的大小范围为 $0$ 到 $k=10$。\n\n为了返回下列编号方案：\n\n|序号|编号|\n|:-:|:-:|\n|$0$| $6$|\n|$1$| $2$|\n|$2$|$9$|\n|$3$ |$3$|\n|$4$ |$7$|\n\n函数 `label` 应该返回 $[6,2,9,3,7]$。下图中的数字表示站点的序号（左图）与分配到的编号（右图）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xpq3km1p.png)\n\n假设编号按照上图所示进行分配，考虑下列的调用：\n\n```cpp\nfind_next_station(9, 6, [2, 7])\n```\n\n它表示数据包当前所处的站点编号为 $9$，其目的站点的编号为 $6$。从当前站点到目的站点的路径上，站点编号依次为 $[9,2,6]$。因此，函数应该返回 $2$，表示数据包应该转发给编号为 $2$ 的站点（其序号为 $1$）。\n\n考虑另一个可能的调用：\n\n```cpp\nfind_next_station(2, 3, [3, 6, 9])\n  ```\n该函数应该返回 $3$，因为目的站点（编号 $3$）是当前站点（编号 $2$）的邻居，因此目的站点直接接收到了数据包。\n\n#### 约束条件\n\n- $1 \\le r \\le 10$\n\n对于 `label` 的每次调用：\n\n- $2 \\le n \\le 1000$\n- $k \\ge n-1$\n- $0 \\le u[i],v[i] \\le n-1$（对于所有 $0 \\le i \\le n-2$）\n\n对于 `find_next_station` 的每次调用，其输入参数来自于任意选择的某次之前对 `label` 的调用。考虑它所产生的编号，\n\n- $s$ 和 $t$ 是两个不同站点的编号。\n- $c$ 是编号为 $s$ 的站点的所有邻居的编号的序列，升序排列。\n\n对于每个测试用例，所有场景加到⼀起，传递给函数  `find_next_station` 的所有数组 $c$ 的总长度不超过 $10^5$。\n\n#### 子任务\n\n1. （5 分）$k=1000$，不会出现拥有多于 $2$ 个邻居的站点。\n2. （8 分）$k=1000$，链路 $i$ 连接站点 $i+1$ 和 $\\lfloor\\frac{i}{2}\\rfloor$。\n3. （16 分）$k=10^6$，最多一个站点拥有多于 $2$ 个的邻居。\n4. （10 分）$n \\le 8$，$k = 10^9$\n5. （61 分）$k = 10^9$\n\n在子任务 5 中，你可以获得部分分。 令 $m$ 为所有场景中 `label` 返回的最大编号。 对于这个子任务，你的得分将根据下表计算得到：\n\n|最大编号|得分|\n|:-:|:-:|\n|$m \\ge 10^9$|$0$|\n|$2000 \\le m < 10^9$|$50 \\cdot \\log_{5 \\cdot10^5}(\\frac{10^9}{m})$|\n|$1000 < m < 5000$|$50$|\n|$m \\le 1000$|$61$|\n\n#### 评测程序示例\n\n评测程序示例以如下格式读取输入数据：\n\n第 $1$ 行：$r$\n\n接下来是 $r$ 块内容，每块描述了一个单独的场景，格式如下：\n\n第 $1$ 行：$n\\ k$        \n第 $2+i(0 \\le i \\le n-2)$ 行：$u[i]\\ v[i]$         \n第 $1+n$ 行：$q$，`find_next_station` 的调用次数    \n第 $2+n+j(0 \\le j \\le q-1)$ 行：$z[j]\\ y[j]\\ w[j]$，第 $j$ 次调用 `find_next_station` 时所涉及的站点的 **序号**。此时，数据包在站点 $z[j]$，目的站点为 $y[j]$，应该要转发给站点 $w[j]$。\n\n评测程序示例以如下格式打印你的结果：\n\n第 $1$ 行：$m$\n\n接下来是 $r$ 块内容，分别对应输入中的场景。每块的格式如下：\n\n第 $1+j(0 \\le j \\le q-1)$ 行：站点的 **序号**，它所对应的 **编号** 是第 $j$ 次调用 `find_next_station` 时返回的结果。\n\n注意：评测程序示例每次执行时会同时调用 `label` 和 `find_next_station`。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2020] 网络站点（无法评测）", "background": null, "description": "新加坡的互联网主干网由 $n$ 个网络站点组成，这些站点分配了从 $0$ 到 $n-1$ 的 **序号**。互联网中还有 $n-1$ 条双向链路，它们从 $0$ 到 $n-2$ 编号。每条链路连接两个不同的站点。被一条链路连接着的两个站点互相称作对方的邻居。\n\n一个由互不相同的站点所组成的站点序列 $a_0,a_1,\\ldots,a_p$ 被称作一条从站点 $x$ 到站点 $y$ 的路径，当且仅当 $a_0=x$，$a_p=y$，并且序列中每两个连续的站点都是邻居。保证从任意站点 $x$ 到任意其他站点 $y$ **有且仅有** 一条路径。\n\n任意站点 $x$ 可以生成一个数据包，并把它发送给任意其他站点 $y$，站点 $y$ 称作这个数据包的 **目的站点**。数据包需要按下述规则在站点 $x$ 到站点 $y$ 的唯一路径上进行路由。假设数据包当前发送到了站点 $z$，其中 $y$ 是数据包的目的站点且 $z \\ne y$，则站点 $z$ 会：\n\n1. 执行 **路由函数**，找到 $z$ 到 $y$ 的唯⼀路径中 $z$ 的邻居。然后\n2. 将数据包转发给这个邻居。\n\n然而，站点有存储内存限制，可能无法存下路由函数中需要使用的完整的主干网链路列表。\n\n你的任务是实现主干网的路由机制，它由两个函数组成。\n\n- 第一个函数的输入参数为 $n$、主干网链路的列表和一个整数 $k \\ge n-1$。该函数需要为每个站点分配一个独一无二的 **编号**，其大小在 $0$ 到 $k$ 之间（包括 $0$ 和 $k$）。\n- 第二个函数是路由函数，它在站点编号分配好后部署到所有站点上。它的输入参数如下：\n\t- $s$，数据包当前所处的站点的 **编号**，\n\t- $t$，数据包的目的站点的 **编号** $(t \\ne s)$，\n\t- $c$，表示 $s$ 的所有邻居站点的 **编号** 的列表。\n\n该函数应该返回一个 $s$ 的邻居的 **编号**，表示数据包需要转发到的下个站点。\n\n在每个子任务中，你的得分取决于所有站点被分配到的编号的最大值（通常来说，编号最大值越小越好）。\n\n#### 实现细节\n\n你需要实现下列函数：\n\n```cpp\nint[] label(int n, int k, int[] u, int[] v)\n```\n\n- $n$: 主干网中站点的数量。\n- $k$: 可用的编号的最大值。\n- $u$ 和 $v$: 大小为 $n-1$ 的数组，表示链路。对每个 $i(0 \\le i \\le n-2)$，链路 $i$ 连接着序号为 $u[i]$ 和 $v[i]$ 的站点。\n- 该函数应该返回一个大小为 $n$ 的数组 $L$。对每个 $i(0 \\le i \\le n-1)$，$L[i]$ 表示序号为 $i$ 的站点所分配到的编号。数组 $L$ 中的所有元素必须互不相同并且大小在 $0$ 到 $k$ 之间。\n\n```cpp\nint find_next_station(int s, int t, int[] c)\n```\n\n- $s$: 数据包当前所在站点的编号。\n- $t$: 数据包目的站点的编号。\n- $c$: 一个数组，包含 $s$ 的所有邻居的编号。数组 $c$ 按照元素大小升序排列。\n- 该函数应该返回一个 $s$ 的邻居的编号，表示数据包需要转发到的下个站点。\n\n每个测试用例包含一个或多个独立的场景（也就是不同的主干网描述）。 对于一个包含 $r$ 个场景的测试用例，调用上述函数的评测程序会按下列步骤运行恰好两次。\n\n程序第一次运行期间：\n\n- `label` 函数被调用 $r$ 次。\n- 返回的编号将被评测系统保存。\n- 并且 `find_next_station` 不会被调用。\n\n程序第二次运行期间：\n\n- `find_next_station` 会被调用若干次。对于每次调用，评测程序会选择任意某个场景，该场景中的 `label` 函数所返回的编号方式将用于本次 `find_next_station` 调用。\n- `label` 不会被调用。\n- 特别地，在评测程序第一次运行期间，保存在静态或全局变量中的信息将无法在 `find_next_station` 函数中使用。", "inputFormat": null, "outputFormat": null, "hint": "#### 样例说明\n\n#### 例 1\n\n考虑下列调用：\n\n```cpp\nlabel(5, 10, [0, 1, 1, 2], [1, 2, 3, 4])\n```\n\n共有 $5$ 个站点和 $4$ 条链路，链路对应的站点序号对分别为 $(0,1)$, $(1,2)$, $(1,3)$ 和 $(2,4)$。编号的大小范围为 $0$ 到 $k=10$。\n\n为了返回下列编号方案：\n\n|序号|编号|\n|:-:|:-:|\n|$0$| $6$|\n|$1$| $2$|\n|$2$|$9$|\n|$3$ |$3$|\n|$4$ |$7$|\n\n函数 `label` 应该返回 $[6,2,9,3,7]$。下图中的数字表示站点的序号（左图）与分配到的编号（右图）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xpq3km1p.png)\n\n假设编号按照上图所示进行分配，考虑下列的调用：\n\n```cpp\nfind_next_station(9, 6, [2, 7])\n```\n\n它表示数据包当前所处的站点编号为 $9$，其目的站点的编号为 $6$。从当前站点到目的站点的路径上，站点编号依次为 $[9,2,6]$。因此，函数应该返回 $2$，表示数据包应该转发给编号为 $2$ 的站点（其序号为 $1$）。\n\n考虑另一个可能的调用：\n\n```cpp\nfind_next_station(2, 3, [3, 6, 9])\n  ```\n该函数应该返回 $3$，因为目的站点（编号 $3$）是当前站点（编号 $2$）的邻居，因此目的站点直接接收到了数据包。\n\n#### 约束条件\n\n- $1 \\le r \\le 10$\n\n对于 `label` 的每次调用：\n\n- $2 \\le n \\le 1000$\n- $k \\ge n-1$\n- $0 \\le u[i],v[i] \\le n-1$（对于所有 $0 \\le i \\le n-2$）\n\n对于 `find_next_station` 的每次调用，其输入参数来自于任意选择的某次之前对 `label` 的调用。考虑它所产生的编号，\n\n- $s$ 和 $t$ 是两个不同站点的编号。\n- $c$ 是编号为 $s$ 的站点的所有邻居的编号的序列，升序排列。\n\n对于每个测试用例，所有场景加到⼀起，传递给函数  `find_next_station` 的所有数组 $c$ 的总长度不超过 $10^5$。\n\n#### 子任务\n\n1. （5 分）$k=1000$，不会出现拥有多于 $2$ 个邻居的站点。\n2. （8 分）$k=1000$，链路 $i$ 连接站点 $i+1$ 和 $\\lfloor\\frac{i}{2}\\rfloor$。\n3. （16 分）$k=10^6$，最多一个站点拥有多于 $2$ 个的邻居。\n4. （10 分）$n \\le 8$，$k = 10^9$\n5. （61 分）$k = 10^9$\n\n在子任务 5 中，你可以获得部分分。 令 $m$ 为所有场景中 `label` 返回的最大编号。 对于这个子任务，你的得分将根据下表计算得到：\n\n|最大编号|得分|\n|:-:|:-:|\n|$m \\ge 10^9$|$0$|\n|$2000 \\le m < 10^9$|$50 \\cdot \\log_{5 \\cdot10^5}(\\frac{10^9}{m})$|\n|$1000 < m < 5000$|$50$|\n|$m \\le 1000$|$61$|\n\n#### 评测程序示例\n\n评测程序示例以如下格式读取输入数据：\n\n第 $1$ 行：$r$\n\n接下来是 $r$ 块内容，每块描述了一个单独的场景，格式如下：\n\n第 $1$ 行：$n\\ k$        \n第 $2+i(0 \\le i \\le n-2)$ 行：$u[i]\\ v[i]$         \n第 $1+n$ 行：$q$，`find_next_station` 的调用次数    \n第 $2+n+j(0 \\le j \\le q-1)$ 行：$z[j]\\ y[j]\\ w[j]$，第 $j$ 次调用 `find_next_station` 时所涉及的站点的 **序号**。此时，数据包在站点 $z[j]$，目的站点为 $y[j]$，应该要转发给站点 $w[j]$。\n\n评测程序示例以如下格式打印你的结果：\n\n第 $1$ 行：$m$\n\n接下来是 $r$ 块内容，分别对应输入中的场景。每块的格式如下：\n\n第 $1+j(0 \\le j \\le q-1)$ 行：站点的 **序号**，它所对应的 **编号** 是第 $j$ 次调用 `find_next_station` 时返回的结果。\n\n注意：评测程序示例每次执行时会同时调用 `label` 和 `find_next_station`。", "locale": "zh-CN"}}}
{"pid": "P6839", "type": "P", "difficulty": 7, "samples": [["2 4 1\nw 1\nha 9", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "各省省选", "北京"], "title": "[BJOI2016] 打字机", "background": "", "description": "小 J 在搬家的过程中发现了一台古老的打字机。 好奇的小 J 决定研究如何使用它。首先，需要将一条长度为 $m$ \n的纸带放入打字机。打字机上共有 26 个按键，分别是小写字母 `a` 到 `z` 。每当你按下一个按键时，打字机\n就会立即在纸带上打印出那个字符，并将纸带平移一个单位距离。聪明的小 J 很快就掌握了这款打字机的使用技巧，并想尝试新的挑战。\n\n他拿出了一本字典，挑选了 $n$ 个单词，并给每个单词设定了分数。纸带中每出现一次指定的单词，就会得到对应的分数。例如， 单词 `eye` 的分数为 $2$， `year` 的分数为 $3$，那么纸带 `eyeyeyear` 的分数为 $9$ 分。小 J 希望挑战自己，打出分数最高的纸带。\n\n特别地，小 J 偶尔会手抖，按到自己不想输入的字符。由于这台古老的打字机没有退格（删除）功能，所以小 J 只能接受按错这个事实，重新规划在按错的情况下如何得最高分。倘若小 J 有可能在任意位置按错按键，并保证整个过程中按错的次数不超过 $k$ 次，那么请你算出他在最坏情况下的最高得分是多少。", "inputFormat": "第一行包含 3 个非负整数 $n, m, k$，分别表示单词数量、纸带长度和最多按错次数。\n\n接下来 $n$ 行，每行为一个字符串 $S$ 和正整数 $a_i$，由空格隔开，描述一个单词及其得分。", "outputFormat": "仅一行，包含一个整数，表示最坏情况下的最大得分。", "hint": "【样例解释】\n\n以下是一种错误思路：\n\n\"共 $4$ 种情况，即第 $1$ 位按错、第 $2$ 位按错、第 $3$ 位按错和第 $4$ 位按错。\n1. 第 $1$ 位按错（不妨假设按成 `x`，下同），最高得分为 `xwha`，得分为 $10$。\n2. 第 $2$ 位按错，最高得分为 `wxha`，同样为 $10$ 分。\n3. 第 $3$ 位按错，最高得分为 `haxw`，同样为 $10$ 分。\n4. 第 $4$ 位按错，最高得分为 `hawx`，同样为 $10$ 分。\n\n综上，最坏情况下最高得分为 $10$ 分。\"\n\n这种思路的错误之处在于，你不能根据哪一位按错决定你第一位按哪个键。 换种说法，你在哪一位按错，是在按下那个按键之后才能知道的事情。 正确的思路如下：\n\n1. 第 $1$ 位先按 `h`，倘若按对， 跳至 2，倘若按错， 跳至 4；\n2. 第 $2$ 位按 `a`，倘若按对， 跳至 3，倘若按错， 跳至 5；\n3. 第 $3$ 位和第 $4$ 位都按 `w`， 结束。 至多错 1 次，最终纸带为 `hawx` 或 `haxw`，得分为 $10$ 分。\n4. 后面三位依次按 `haw`， 结束。 因为不会再错， 最终纸带为 `xhaw`，得分为 $10$ 分。\n5. 后面两位依次按 `ha`， 结束。因为不会再错， 最终纸带为 `hxha`，得分为 $9$ 分。\n\n综上，最坏情况下，最高得分为 $9$ 分。\n\n【数据范围】\n\n测试点 $1,2$ 满足，$n = 1$ 或 $k = 0$；\n\n测试点 $1\\sim 6$ 满足，$n ≤ 100$，$m ≤ 500$，$∑|S| ≤ 500$，$a_i ≤1000$；\n\n测试点 $7,8$ 满足，$k = 0$，$∑|S| ≤ 200$；\n\n测试点 $9,10$ 满足，$∑|S| ≤ 50$，$a_i ≤1$。\n\n对于 $100\\%$ 的数据，$n ≤ 100$，$m ≤ 10^9$ ，$∑|S| ≤ 500$，$a_i ≤1000$，$k ≤ 5$。**请注意，每一个测试点都有相应特殊性质。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BJOI2016] 打字机", "background": "", "description": "小 J 在搬家的过程中发现了一台古老的打字机。 好奇的小 J 决定研究如何使用它。首先，需要将一条长度为 $m$ \n的纸带放入打字机。打字机上共有 26 个按键，分别是小写字母 `a` 到 `z` 。每当你按下一个按键时，打字机\n就会立即在纸带上打印出那个字符，并将纸带平移一个单位距离。聪明的小 J 很快就掌握了这款打字机的使用技巧，并想尝试新的挑战。\n\n他拿出了一本字典，挑选了 $n$ 个单词，并给每个单词设定了分数。纸带中每出现一次指定的单词，就会得到对应的分数。例如， 单词 `eye` 的分数为 $2$， `year` 的分数为 $3$，那么纸带 `eyeyeyear` 的分数为 $9$ 分。小 J 希望挑战自己，打出分数最高的纸带。\n\n特别地，小 J 偶尔会手抖，按到自己不想输入的字符。由于这台古老的打字机没有退格（删除）功能，所以小 J 只能接受按错这个事实，重新规划在按错的情况下如何得最高分。倘若小 J 有可能在任意位置按错按键，并保证整个过程中按错的次数不超过 $k$ 次，那么请你算出他在最坏情况下的最高得分是多少。", "inputFormat": "第一行包含 3 个非负整数 $n, m, k$，分别表示单词数量、纸带长度和最多按错次数。\n\n接下来 $n$ 行，每行为一个字符串 $S$ 和正整数 $a_i$，由空格隔开，描述一个单词及其得分。", "outputFormat": "仅一行，包含一个整数，表示最坏情况下的最大得分。", "hint": "【样例解释】\n\n以下是一种错误思路：\n\n\"共 $4$ 种情况，即第 $1$ 位按错、第 $2$ 位按错、第 $3$ 位按错和第 $4$ 位按错。\n1. 第 $1$ 位按错（不妨假设按成 `x`，下同），最高得分为 `xwha`，得分为 $10$。\n2. 第 $2$ 位按错，最高得分为 `wxha`，同样为 $10$ 分。\n3. 第 $3$ 位按错，最高得分为 `haxw`，同样为 $10$ 分。\n4. 第 $4$ 位按错，最高得分为 `hawx`，同样为 $10$ 分。\n\n综上，最坏情况下最高得分为 $10$ 分。\"\n\n这种思路的错误之处在于，你不能根据哪一位按错决定你第一位按哪个键。 换种说法，你在哪一位按错，是在按下那个按键之后才能知道的事情。 正确的思路如下：\n\n1. 第 $1$ 位先按 `h`，倘若按对， 跳至 2，倘若按错， 跳至 4；\n2. 第 $2$ 位按 `a`，倘若按对， 跳至 3，倘若按错， 跳至 5；\n3. 第 $3$ 位和第 $4$ 位都按 `w`， 结束。 至多错 1 次，最终纸带为 `hawx` 或 `haxw`，得分为 $10$ 分。\n4. 后面三位依次按 `haw`， 结束。 因为不会再错， 最终纸带为 `xhaw`，得分为 $10$ 分。\n5. 后面两位依次按 `ha`， 结束。因为不会再错， 最终纸带为 `hxha`，得分为 $9$ 分。\n\n综上，最坏情况下，最高得分为 $9$ 分。\n\n【数据范围】\n\n测试点 $1,2$ 满足，$n = 1$ 或 $k = 0$；\n\n测试点 $1\\sim 6$ 满足，$n ≤ 100$，$m ≤ 500$，$∑|S| ≤ 500$，$a_i ≤1000$；\n\n测试点 $7,8$ 满足，$k = 0$，$∑|S| ≤ 200$；\n\n测试点 $9,10$ 满足，$∑|S| ≤ 50$，$a_i ≤1$。\n\n对于 $100\\%$ 的数据，$n ≤ 100$，$m ≤ 10^9$ ，$∑|S| ≤ 500$，$a_i ≤1000$，$k ≤ 5$。**请注意，每一个测试点都有相应特殊性质。**", "locale": "zh-CN"}}}
{"pid": "P6840", "type": "P", "difficulty": 5, "samples": [["6 9 2.5 9\n0.0 5.0 0.0 1\n0.0 0.0 -5.0 0\n0.0 -5.0 0.0 0\n0.0 0.0 5.0 0\n3.0 4.0 0.0 0\n4.0 3.0 0.0 1\n1 2 5\n2 3 8\n1 4 5\n4 3 5\n1 5 1\n5 6 9\n5 2 1\n2 6 2\n6 4 4\n1 3", "12.5663706144"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "2009", "Special Judge", "最短路", "BalkanOI（巴尔干半岛）"], "title": "[BalkanOI 2009] year2012 - A New Beginning", "background": "[英文题面](/problem/U126972) | [题目来源](http://www.cs.org.mk/boi2009/tasks.html)\n\n本题官方题解最大点时间 1.56s，故本题时间限制 2s。", "description": "一次极端的太阳爆发使地球升温，造成了一场巨大的灾难。地壳板块在地幔中自由浮动；震级未知的地震正在导致大都市倒塌；山峦被巨大的海啸淹没；各国正转向熔岩和火山灰的海洋。\n\n现在是 $2012$ 年 $12$ 月 $21$ 日，你唯一能让你和你的家人免于世界末日的机会就是登上喜马拉雅山的政府船，这是拯救人类的现代方舟。你有一架匀速飞行的飞机和一张有所有固定机场的地图。不幸的是，并不是所有的机场都连接在一起——巨大的火山灰云阻塞了一些航线，而其他机场却相距太远。此外，并不是所有的机场都有燃料供应——有些机场除了光秃秃的道路什么都没有留下——而且在那里你无法给飞机加油。由于所有的导航手段都被摧毁了，两个机场之间唯一可能的路径就是最短的一条。最重要的是，由于大气不稳定和空气密度的急剧变化，发动机的燃油效率在飞行中会有所不同。因此油耗也不同。好的新情况是你知道在哪一个机场可以飞行，所需的燃料量，以及你可以在哪里加油。你所要做的就是想办法尽快从机场到喜马拉雅山的机场。编写一个 `year2012` 程序，根据每个机场的坐标、是否有燃油、飞机的油箱容量、飞机的速度、一个潜在的航班连接的几对机场以及每一次飞行需要多少燃料，计算完成这项任务所需的最短时间。", "inputFormat": "从标准输入读入。\n\n第一行四个整数（译者注：可以看到样例并没有严格遵守此规则，具体的数据范围建议以【提示说明】中的为准，下同）$N,M,V,C$，分别表示机场数量、可用航线数量、飞机恒定速度和油箱容量。\n\n接下来 $N$ 行，每行由三个实数 $X_i,Y_i,Z_i$ 和一个布尔值 $R_i$ 组成。三个实数表示 $i$ 号机场的空间坐标， $R_i=0$ 表示不能在这个机场加油，$R_i=1$ 表示可以加油。\n\n接下来 $M$ 行，每行三个整数 $A_k,B_k,F_k$，表示这条航线的两端和花费的燃油量。每条航线都是双向的。\n\n最后一行两个整数 $S,T$，表示路线上第一个和最后一个机场。", "outputFormat": "输出到标准输出。\n\n一行，一个实数，表示从 $S$ 到 $T$ 的最短时间。如果你的答案与标准答案的绝对误差不超过 $10^{-4}$，你的答案将被认为是正确的。\n\n如果你无法到达目的地，输出 $0$。", "hint": "**数据范围**\n\n- 机场数量 $N\\in\\left[2,10^3\\right]\\cap\\Z$。\n- 可用航线数量 $M\\in\\left[1,10^4\\right]\\cap\\Z$。\n- 飞机恒定速度 $V\\in\\left[1,10^3\\right]$ 为小数点后最多 $3$ 位的实数。\n- 油箱容量 $C\\in\\left[1,10^3\\right]\\cap\\Z$。\n- 机场空间坐标 $X_i, Y_i, Z_i\\in\\left[-100,100\\right]$，为小数点后最多 $18$ 位的实数。另外，保证 $X_i^2+Y_i^2+Z_i^2$ 对于所有 $i$ 均相同。换句话说，对于一个测试数据，所有的机场距离地心的距离均相同。\n- 可以加油的机场数量 $\\in\\left[1,20\\right]\\cap\\Z$。\n- 地球半径为不小于 $1$ 的整数。\n- 航线的两端 $A_k, B_k\\in\\left[1,N\\right]\\cap\\Z$ 且 $A_k\\ne B_k$。满足同一条航线只会出现一次。\n- 航线花费的油量 $F_k\\in\\left[1,C\\right]\\cap\\Z$。\n\n**备注**\n\n- 一条航线的距离为球体上最短的弧。这种弧可能有很多个，但是我们只关心距离。\n- 所有航线距离均不小于 $10^{-6}$。\n- 由于实数运算可能的精度误差，每个机场到地心的距离可能略有不同。但是数据保证所有距离的绝对误差不超过 $10^{-10}$，因此算法的正确性不受影响。\n- $R_s = 1$，这意味着飞机的油箱初始是满的。每次路过一个可以加油的机场，油箱将会再次加满。\n- 飞机降落、加油、起飞、加速的过程可以被忽略，即认为是 $0$。\n- 所有可用的航线都是彼此独立的。这意味着如果有航线从 $A$ 到 $B$，路过 $C$，这不代表有从 $A$ 到 $C$、或从 $B$ 到 $C$ 的可用航线。\n\n**部分分**\n\n对于 $40\\%$ 的数据，$N\\le 8$.\n\n---\n\n**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ae9vdygi.png)\n\n地球的半径为 $5$。飞机速度为 $2.5$，油箱容量为 $9$。我们想要从 $1$ 到 $3$。如图，黑实线代表可用的航线，机场编号在矩形的内部，油量花费在黑实线边上备注。我们可以加油的机场的点是空心的。显然，我们不能直接通过 $1\\rightarrow 2\\rightarrow 3$ 或者 $1\\rightarrow 4\\rightarrow 3$——它们的油量花费分别为 $13$ 和 $10$，超过了油箱的最大容量。事实上，所有路线都花费了大于 $9$ 的燃油，因此我们必须经过 $6$ 号机场。我们有三条可能的路线：$1\\rightarrow 2\\rightarrow 6$、$1\\rightarrow 4\\rightarrow 6$ 和 $1\\rightarrow 5\\rightarrow 2\\rightarrow 6$。前两种显然是最短的两个（航线 $1\\rightarrow 2$、$5\\rightarrow 2$、$2\\rightarrow 6$、$1\\rightarrow 4$ 和 $4\\rightarrow 6$ 花费同样长的时间）。在我们在 $6$ 号机场加满油后，如果我们前往 $2$ 号机场，我们依然不能到达目的地——我们缺少一个单位的燃油。为一可行的路线是通过 $4$，然后花光所有燃油到达 $3$。最后，我们可选的路线有 $1\\rightarrow 2\\rightarrow 6\\rightarrow 4\\rightarrow 3$ 和 $1\\rightarrow 4\\rightarrow 6\\rightarrow 4\\rightarrow 3$。他们都有四个直角弯，因此它们的总长度相等，都等于地球的赤道周长，或 $2\\pi R$。因此，花费的时间为 $\\dfrac{2\\pi R}{V}\\approx 12.566370614359172953850573533118$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalkanOI 2009] year2012 - A New Beginning", "background": "[英文题面](/problem/U126972) | [题目来源](http://www.cs.org.mk/boi2009/tasks.html)\n\n本题官方题解最大点时间 1.56s，故本题时间限制 2s。", "description": "一次极端的太阳爆发使地球升温，造成了一场巨大的灾难。地壳板块在地幔中自由浮动；震级未知的地震正在导致大都市倒塌；山峦被巨大的海啸淹没；各国正转向熔岩和火山灰的海洋。\n\n现在是 $2012$ 年 $12$ 月 $21$ 日，你唯一能让你和你的家人免于世界末日的机会就是登上喜马拉雅山的政府船，这是拯救人类的现代方舟。你有一架匀速飞行的飞机和一张有所有固定机场的地图。不幸的是，并不是所有的机场都连接在一起——巨大的火山灰云阻塞了一些航线，而其他机场却相距太远。此外，并不是所有的机场都有燃料供应——有些机场除了光秃秃的道路什么都没有留下——而且在那里你无法给飞机加油。由于所有的导航手段都被摧毁了，两个机场之间唯一可能的路径就是最短的一条。最重要的是，由于大气不稳定和空气密度的急剧变化，发动机的燃油效率在飞行中会有所不同。因此油耗也不同。好的新情况是你知道在哪一个机场可以飞行，所需的燃料量，以及你可以在哪里加油。你所要做的就是想办法尽快从机场到喜马拉雅山的机场。编写一个 `year2012` 程序，根据每个机场的坐标、是否有燃油、飞机的油箱容量、飞机的速度、一个潜在的航班连接的几对机场以及每一次飞行需要多少燃料，计算完成这项任务所需的最短时间。", "inputFormat": "从标准输入读入。\n\n第一行四个整数（译者注：可以看到样例并没有严格遵守此规则，具体的数据范围建议以【提示说明】中的为准，下同）$N,M,V,C$，分别表示机场数量、可用航线数量、飞机恒定速度和油箱容量。\n\n接下来 $N$ 行，每行由三个实数 $X_i,Y_i,Z_i$ 和一个布尔值 $R_i$ 组成。三个实数表示 $i$ 号机场的空间坐标， $R_i=0$ 表示不能在这个机场加油，$R_i=1$ 表示可以加油。\n\n接下来 $M$ 行，每行三个整数 $A_k,B_k,F_k$，表示这条航线的两端和花费的燃油量。每条航线都是双向的。\n\n最后一行两个整数 $S,T$，表示路线上第一个和最后一个机场。", "outputFormat": "输出到标准输出。\n\n一行，一个实数，表示从 $S$ 到 $T$ 的最短时间。如果你的答案与标准答案的绝对误差不超过 $10^{-4}$，你的答案将被认为是正确的。\n\n如果你无法到达目的地，输出 $0$。", "hint": "**数据范围**\n\n- 机场数量 $N\\in\\left[2,10^3\\right]\\cap\\Z$。\n- 可用航线数量 $M\\in\\left[1,10^4\\right]\\cap\\Z$。\n- 飞机恒定速度 $V\\in\\left[1,10^3\\right]$ 为小数点后最多 $3$ 位的实数。\n- 油箱容量 $C\\in\\left[1,10^3\\right]\\cap\\Z$。\n- 机场空间坐标 $X_i, Y_i, Z_i\\in\\left[-100,100\\right]$，为小数点后最多 $18$ 位的实数。另外，保证 $X_i^2+Y_i^2+Z_i^2$ 对于所有 $i$ 均相同。换句话说，对于一个测试数据，所有的机场距离地心的距离均相同。\n- 可以加油的机场数量 $\\in\\left[1,20\\right]\\cap\\Z$。\n- 地球半径为不小于 $1$ 的整数。\n- 航线的两端 $A_k, B_k\\in\\left[1,N\\right]\\cap\\Z$ 且 $A_k\\ne B_k$。满足同一条航线只会出现一次。\n- 航线花费的油量 $F_k\\in\\left[1,C\\right]\\cap\\Z$。\n\n**备注**\n\n- 一条航线的距离为球体上最短的弧。这种弧可能有很多个，但是我们只关心距离。\n- 所有航线距离均不小于 $10^{-6}$。\n- 由于实数运算可能的精度误差，每个机场到地心的距离可能略有不同。但是数据保证所有距离的绝对误差不超过 $10^{-10}$，因此算法的正确性不受影响。\n- $R_s = 1$，这意味着飞机的油箱初始是满的。每次路过一个可以加油的机场，油箱将会再次加满。\n- 飞机降落、加油、起飞、加速的过程可以被忽略，即认为是 $0$。\n- 所有可用的航线都是彼此独立的。这意味着如果有航线从 $A$ 到 $B$，路过 $C$，这不代表有从 $A$ 到 $C$、或从 $B$ 到 $C$ 的可用航线。\n\n**部分分**\n\n对于 $40\\%$ 的数据，$N\\le 8$.\n\n---\n\n**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ae9vdygi.png)\n\n地球的半径为 $5$。飞机速度为 $2.5$，油箱容量为 $9$。我们想要从 $1$ 到 $3$。如图，黑实线代表可用的航线，机场编号在矩形的内部，油量花费在黑实线边上备注。我们可以加油的机场的点是空心的。显然，我们不能直接通过 $1\\rightarrow 2\\rightarrow 3$ 或者 $1\\rightarrow 4\\rightarrow 3$——它们的油量花费分别为 $13$ 和 $10$，超过了油箱的最大容量。事实上，所有路线都花费了大于 $9$ 的燃油，因此我们必须经过 $6$ 号机场。我们有三条可能的路线：$1\\rightarrow 2\\rightarrow 6$、$1\\rightarrow 4\\rightarrow 6$ 和 $1\\rightarrow 5\\rightarrow 2\\rightarrow 6$。前两种显然是最短的两个（航线 $1\\rightarrow 2$、$5\\rightarrow 2$、$2\\rightarrow 6$、$1\\rightarrow 4$ 和 $4\\rightarrow 6$ 花费同样长的时间）。在我们在 $6$ 号机场加满油后，如果我们前往 $2$ 号机场，我们依然不能到达目的地——我们缺少一个单位的燃油。为一可行的路线是通过 $4$，然后花光所有燃油到达 $3$。最后，我们可选的路线有 $1\\rightarrow 2\\rightarrow 6\\rightarrow 4\\rightarrow 3$ 和 $1\\rightarrow 4\\rightarrow 6\\rightarrow 4\\rightarrow 3$。他们都有四个直角弯，因此它们的总长度相等，都等于地球的赤道周长，或 $2\\pi R$。因此，花费的时间为 $\\dfrac{2\\pi R}{V}\\approx 12.566370614359172953850573533118$。", "locale": "zh-CN"}}}
{"pid": "P6841", "type": "P", "difficulty": 6, "samples": [["20 10\ne l 3\ne o 1\no n 2\no r 4\nr a 4\ni n 5\ne n 2\nn t 3\nt w 3\nw i 5", "470059518"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "2009", "矩阵乘法", "BalkanOI（巴尔干半岛）"], "title": "[BalkanOI 2009] Reading", "background": "[英文题面](/problem/U126973) | [题目来源](http://www.cs.org.mk/boi2009/tasks.html)", "description": "有一个关于人脑有趣的事实：在阅读时，它主要分析每个单词的第一个和最后一个字母，而不一定要按照正确的顺序来构造单词。因此，即使一句话基本上没有正确的单词，也可能会被正确的理解。（原文中这段文字的部分单词的字母顺序被打乱，但是译者认为这样会影响阅读，因此没有改变翻译中文字的顺序）\n\nElly 已经注意到，打乱某些字母会得到更好的结果！例如，字母 `l` 和 `i`、`a` 和 `o`、`x` 和 `m` 非常相似。于是她定义了一个字母的值，从 $1$ 到 $5$ 。其中，相似的字母的值较低，而非常不同的字母值较高。等号字母的值是 $1$。通过这种方式，每个单词可以被赋予一个值——相邻字母之间所有值的总和。\n\n想象一下，她把 `e` 和 `l` 的值定义为 $3$，`l` 和 `y` 的值定义为 $2$，`i` 和 `l` 的值定义为 $1$。那么单词 `elly` 的值是 $3+1+2=6$（记住，相邻的相等字母的距离是 $1$）。单词 `lily` 的值为 $4$，而 `i` 的值为 $0$）。长单词的价值不一定比短单词大——比如 `lilii`（保加利亚语中`lily` 的复数形式）——它的值只有 $4$，但 `elle`（法语中的意思是 `she`）的价值是 $7$。但是，每增加一个字母，至少会增加一个单词的值。\n\nEllenora 希望构建一种即使有大量混乱的字母也很容易阅读的语言。求出值不大于 $N$ 的所有非空单词数目。", "inputFormat": "从标准输入读入。\n\n第一行两个整数 $N$ 和 $M$，表示单词的值的最大值（$1\\le N\\le 10^9$）和字符对的数量。Elly 已经定义了一个值。所有未提及的字母对的距离都等于 $1$。接下来的 $M$ 行中的每一行都包含一个三元组 $L_1\\,L_2\\,F$，这意味着字母 $a\\le L_1,L_2\\le z$ 之间的距离为 $1\\le F\\le 5$。从 $L_1$ 到 $L_2$ 的距离与从 $L_2$ 到 $L_1$ 的距离相同，即距离是无序的。", "outputFormat": "输出到标准输出。\n\n一行，一个整数，表示由小写英文字母组成的单词数，满足它的值不大于 $N$。因为这个数量可能非常大，所以你只需要输出它对 $10^9+7$ 取模后的结果。", "hint": "**数据范围**\n\n对于 $50\\%$ 的数据，$N\\le 10^6$。\n\n对于全部数据，$1\\le N\\le 10^9$，每一对字母最多只会出现一次。\n\n---\n\n**样例解释**\n\n一些可行的单词有：`elleonora`、`entwine`、`aaaaaaaaaaaaaaaaaaaaa`。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalkanOI 2009] Reading", "background": "[英文题面](/problem/U126973) | [题目来源](http://www.cs.org.mk/boi2009/tasks.html)", "description": "有一个关于人脑有趣的事实：在阅读时，它主要分析每个单词的第一个和最后一个字母，而不一定要按照正确的顺序来构造单词。因此，即使一句话基本上没有正确的单词，也可能会被正确的理解。（原文中这段文字的部分单词的字母顺序被打乱，但是译者认为这样会影响阅读，因此没有改变翻译中文字的顺序）\n\nElly 已经注意到，打乱某些字母会得到更好的结果！例如，字母 `l` 和 `i`、`a` 和 `o`、`x` 和 `m` 非常相似。于是她定义了一个字母的值，从 $1$ 到 $5$ 。其中，相似的字母的值较低，而非常不同的字母值较高。等号字母的值是 $1$。通过这种方式，每个单词可以被赋予一个值——相邻字母之间所有值的总和。\n\n想象一下，她把 `e` 和 `l` 的值定义为 $3$，`l` 和 `y` 的值定义为 $2$，`i` 和 `l` 的值定义为 $1$。那么单词 `elly` 的值是 $3+1+2=6$（记住，相邻的相等字母的距离是 $1$）。单词 `lily` 的值为 $4$，而 `i` 的值为 $0$）。长单词的价值不一定比短单词大——比如 `lilii`（保加利亚语中`lily` 的复数形式）——它的值只有 $4$，但 `elle`（法语中的意思是 `she`）的价值是 $7$。但是，每增加一个字母，至少会增加一个单词的值。\n\nEllenora 希望构建一种即使有大量混乱的字母也很容易阅读的语言。求出值不大于 $N$ 的所有非空单词数目。", "inputFormat": "从标准输入读入。\n\n第一行两个整数 $N$ 和 $M$，表示单词的值的最大值（$1\\le N\\le 10^9$）和字符对的数量。Elly 已经定义了一个值。所有未提及的字母对的距离都等于 $1$。接下来的 $M$ 行中的每一行都包含一个三元组 $L_1\\,L_2\\,F$，这意味着字母 $a\\le L_1,L_2\\le z$ 之间的距离为 $1\\le F\\le 5$。从 $L_1$ 到 $L_2$ 的距离与从 $L_2$ 到 $L_1$ 的距离相同，即距离是无序的。", "outputFormat": "输出到标准输出。\n\n一行，一个整数，表示由小写英文字母组成的单词数，满足它的值不大于 $N$。因为这个数量可能非常大，所以你只需要输出它对 $10^9+7$ 取模后的结果。", "hint": "**数据范围**\n\n对于 $50\\%$ 的数据，$N\\le 10^6$。\n\n对于全部数据，$1\\le N\\le 10^9$，每一对字母最多只会出现一次。\n\n---\n\n**样例解释**\n\n一些可行的单词有：`elleonora`、`entwine`、`aaaaaaaaaaaaaaaaaaaaa`。", "locale": "zh-CN"}}}
{"pid": "P6842", "type": "P", "difficulty": 0, "samples": [["7 2\n3 2", "3"], ["9 5\n5 9 2 8 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "数学", "2009", "BalkanOI（巴尔干半岛）"], "title": "[BalkanOI 2009] Strip", "background": "[英文题面](/problem/U126974) | [题目来源](http://www.cs.org.mk/boi2009/tasks.html)", "description": "让我们考虑一条宽度为 $1$、长度为 $n$、厚度为可忽略的条带，由单位正方形组成。如图所示（其中 $n=7$），从它的左边开始，我们使用从 $0$ 到 $n$ 的非负整数命名每个垂直的线。我们只能沿着这些垂直线折叠长方形条带，并且在这之后两个部分被粘在一起，不再会被拉直。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j9hdlgas.png)\n\n自然地，在折叠之后，一些编号会重叠在一起，形成一个有更多编号的垂直线。图中显示了沿垂直线 $3$ 折叠后的情况。在此操作之后，有一些线会有两个编号。例如，我们同样可以说 $1$ 或 $5$，他们代表的是同一条垂直线。再沿着 $2$ 折叠（我们也可以说 $4$，都是一样的），就会有一条垂直线有甚至三个名称，正如我们所看到的：$(1;3;5)$。举个例子，如果我们沿着段 $3$ 对长方形条带进行折叠，我们只需旋转条带，而不改变其名称或长度。我们把这样的折叠称为“空的”：它**不是**非法的，只是没有做任何重大的改变。\n\n按照这种方式，一组长度为 $k$ 的整数数列（每个整数从 $0$ 到 $n$）唯一地定义了条带的折叠方法。编写一个程序，找出折叠完成后该条带的长度。", "inputFormat": "从标准输入读入。\n- 第一行两个正整数 $n,k$，表示条带长度和折叠次数。\n- 第二行 $k$ 个非负整数，表示折叠的顺序，每个数都在 $\\left[0,n\\right]$ 的范围内。", "outputFormat": "输出到标准输出。\n\n一行，一个整数，表示折叠后的长度。", "hint": "**数据范围**\n\n$n$ 有不超过 $18$ 个整数位，$k\\le 10000$。\n\n---\n\n**样例 $2$ 解释**\n\n折叠步骤如图：\n\n初始情况：$\\{0\\,1\\,2\\,3\\,4\\,5\\,6\\,7\\,8\\,9\\}$。\n\n折叠步骤：$\\rightarrow \\{0\\,(1;9)\\,(2;8)\\,(3;7)\\,(4;6)\\,5\\}\\rightarrow \\{(1;9)\\,(0;2;8)\\,(3;7)\\,(4;6)\\,5\\}\\rightarrow \\{(0;2;8)\\,(1;3;7;9)\\,(4;6)\\,5\\}\\rightarrow \\{(1;3;7;9)\\,(0;2;4;6;8)\\,5\\}$。\n\n（备注：样例 $1$ 与图片相同）", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalkanOI 2009] Strip", "background": "[英文题面](/problem/U126974) | [题目来源](http://www.cs.org.mk/boi2009/tasks.html)", "description": "让我们考虑一条宽度为 $1$、长度为 $n$、厚度为可忽略的条带，由单位正方形组成。如图所示（其中 $n=7$），从它的左边开始，我们使用从 $0$ 到 $n$ 的非负整数命名每个垂直的线。我们只能沿着这些垂直线折叠长方形条带，并且在这之后两个部分被粘在一起，不再会被拉直。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j9hdlgas.png)\n\n自然地，在折叠之后，一些编号会重叠在一起，形成一个有更多编号的垂直线。图中显示了沿垂直线 $3$ 折叠后的情况。在此操作之后，有一些线会有两个编号。例如，我们同样可以说 $1$ 或 $5$，他们代表的是同一条垂直线。再沿着 $2$ 折叠（我们也可以说 $4$，都是一样的），就会有一条垂直线有甚至三个名称，正如我们所看到的：$(1;3;5)$。举个例子，如果我们沿着段 $3$ 对长方形条带进行折叠，我们只需旋转条带，而不改变其名称或长度。我们把这样的折叠称为“空的”：它**不是**非法的，只是没有做任何重大的改变。\n\n按照这种方式，一组长度为 $k$ 的整数数列（每个整数从 $0$ 到 $n$）唯一地定义了条带的折叠方法。编写一个程序，找出折叠完成后该条带的长度。", "inputFormat": "从标准输入读入。\n- 第一行两个正整数 $n,k$，表示条带长度和折叠次数。\n- 第二行 $k$ 个非负整数，表示折叠的顺序，每个数都在 $\\left[0,n\\right]$ 的范围内。", "outputFormat": "输出到标准输出。\n\n一行，一个整数，表示折叠后的长度。", "hint": "**数据范围**\n\n$n$ 有不超过 $18$ 个整数位，$k\\le 10000$。\n\n---\n\n**样例 $2$ 解释**\n\n折叠步骤如图：\n\n初始情况：$\\{0\\,1\\,2\\,3\\,4\\,5\\,6\\,7\\,8\\,9\\}$。\n\n折叠步骤：$\\rightarrow \\{0\\,(1;9)\\,(2;8)\\,(3;7)\\,(4;6)\\,5\\}\\rightarrow \\{(1;9)\\,(0;2;8)\\,(3;7)\\,(4;6)\\,5\\}\\rightarrow \\{(0;2;8)\\,(1;3;7;9)\\,(4;6)\\,5\\}\\rightarrow \\{(1;3;7;9)\\,(0;2;4;6;8)\\,5\\}$。\n\n（备注：样例 $1$ 与图片相同）", "locale": "zh-CN"}}}
{"pid": "P6843", "type": "P", "difficulty": 5, "samples": [["2 4 22\n2\n0 1\n1 5\n2 13\n2 10\n1 4\n0 7", "YES\nYES\nYES\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["图论", "2015", "深度优先搜索 DFS", "BalticOI（波罗的海）"], "title": "[BalticOI 2015] File Paths", "background": "", "description": "一个文件 $\\tt file$ 都需要在一个包含很多文件 $\\tt dir1,dir2,\\cdots,dirj$ 的目录中，这个文件的 absolute file path 为 $\\tt/dir1/dir2/\\cdots/dirj/file$，根目录用 $\\tt /$ 表示，每一个放在根目录下的文件的 absolute file path 的形式为 $\\tt /file$。\n\n符号链接指向一个已被命名的目录，可以看作一个快捷方式，他可以放置在任意目录下，注意，符号链接不能指向文件。比如，我们在 $\\tt /$ 下放一个指向 $\\tt /$ 的符号链接 $\\tt hello$，那么，$\\tt /dir/file$，$\\tt /hello/dir/file$，$\\tt /hello/hello/dir/dile$ 都指向同一个文件 $\\tt file$。另比如，我们在 $\\tt /dir$ 下放一个指向 $\\tt /$ 的符号链接 $\\tt hi$，那么，$\\tt /dir/file$，$\\tt /dir/hi/dir/file$，$\\tt /dir/hi/dir/hi/dir/file$ 都指向同一个文件 $\\tt file$。符号链接指向上一层，下一层，甚至同层都可以，但是不允许 $\\tt ./$，$\\tt ../$，$\\tt //$ 之类的操作。\n\n现在想问，是否能通过引入一个长为 $s$ 的符号链接使得找到一个文件的 absolute file path 长度恰好为 $k$？", "inputFormat": "第一行三个整数 $n,m,k$ 代表除根目录之外的目录数，文件数和要求等于的路径长度。        \n第二行一个整数 $s$ 代表符号链接长。       \n接下来 $n$ 行每行两个整数 $p_i,l_i$ 描述一个目录，这个目录编号为 $l_i$，父目录编号为 $p_i$。        \n接下来 $m$ 行每行两个整数 $p_j,l_j$，描述一个文件，这个文件的长度为 $l_j$，父目录编号为 $p_j$。", "outputFormat": "$m$ 行每行一个字符串代表是否能通过引入一个长为 $s$ 的符号链接使得找到编号为 $j$ 的文件的 absolute file path 长度恰好为 $k$，如果是的话输出 $\\tt YES$，否则输出 $\\tt NO$。", "hint": "#### 样例 1 解释\n\n假设符号链接名字为 $\\tt LL$，目录名字为 $\\tt a$，$\\tt bbbbb$，文件名字为 $\\tt ccccccccccccc$，$\\tt dddddddddd$，$\\tt eee$，$\\tt fffffff$，根目录下包含目录 $\\tt a$ 和文件 $\\tt fffffff$，目录 $\\tt a$ 下包含目录 $\\tt bbbbb$ 和文件 $\\tt eee$，目录 $\\tt bbbbb$ 包含文件 $\\tt ccccccccccccc$ 和 $\\tt dddddddddd$。下面是形象化的表述：\n\n```plain\n/\n|-- a\n| |-- bbbbb\n| | |-- ccccccccccccc\n| | +-- dddddddddd\n| +-- eeee\n+-- fffffff\n```\n\n- 对于第 $1$ 个文件，满足条件的路径为 $\\tt /a/bbbbb/ccccccccccccc$。\n- 对于第 $2$ 个文件，满足条件的路径为 $\\tt /a/LL/bbbbb/dddddddddd$。\n- 对于第 $3$ 个文件，满足条件的路径为 $\\tt /a/LL/a/LL/a/LL/a/eeee$。\n- 对于第 $4$ 个文件，无满足条件的路径。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（33 pts）：$n,m \\le 500$。\n- Subtask 2（33 pts）：$n,m \\le 3 \\times 10^3$，符号链接最多被调用一次。\n- Subtask 3（34 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le k,s \\le 10^6$，$1\\le m,n\\le 3\\times 10^3$。\n\n#### 说明\n\n翻译自 [BalticOI 2015 Day2 A File Paths](https://boi.cses.fi/files/boi2015_day2.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2015] File Paths", "background": "", "description": "一个文件 $\\tt file$ 都需要在一个包含很多文件 $\\tt dir1,dir2,\\cdots,dirj$ 的目录中，这个文件的 absolute file path 为 $\\tt/dir1/dir2/\\cdots/dirj/file$，根目录用 $\\tt /$ 表示，每一个放在根目录下的文件的 absolute file path 的形式为 $\\tt /file$。\n\n符号链接指向一个已被命名的目录，可以看作一个快捷方式，他可以放置在任意目录下，注意，符号链接不能指向文件。比如，我们在 $\\tt /$ 下放一个指向 $\\tt /$ 的符号链接 $\\tt hello$，那么，$\\tt /dir/file$，$\\tt /hello/dir/file$，$\\tt /hello/hello/dir/dile$ 都指向同一个文件 $\\tt file$。另比如，我们在 $\\tt /dir$ 下放一个指向 $\\tt /$ 的符号链接 $\\tt hi$，那么，$\\tt /dir/file$，$\\tt /dir/hi/dir/file$，$\\tt /dir/hi/dir/hi/dir/file$ 都指向同一个文件 $\\tt file$。符号链接指向上一层，下一层，甚至同层都可以，但是不允许 $\\tt ./$，$\\tt ../$，$\\tt //$ 之类的操作。\n\n现在想问，是否能通过引入一个长为 $s$ 的符号链接使得找到一个文件的 absolute file path 长度恰好为 $k$？", "inputFormat": "第一行三个整数 $n,m,k$ 代表除根目录之外的目录数，文件数和要求等于的路径长度。        \n第二行一个整数 $s$ 代表符号链接长。       \n接下来 $n$ 行每行两个整数 $p_i,l_i$ 描述一个目录，这个目录编号为 $l_i$，父目录编号为 $p_i$。        \n接下来 $m$ 行每行两个整数 $p_j,l_j$，描述一个文件，这个文件的长度为 $l_j$，父目录编号为 $p_j$。", "outputFormat": "$m$ 行每行一个字符串代表是否能通过引入一个长为 $s$ 的符号链接使得找到编号为 $j$ 的文件的 absolute file path 长度恰好为 $k$，如果是的话输出 $\\tt YES$，否则输出 $\\tt NO$。", "hint": "#### 样例 1 解释\n\n假设符号链接名字为 $\\tt LL$，目录名字为 $\\tt a$，$\\tt bbbbb$，文件名字为 $\\tt ccccccccccccc$，$\\tt dddddddddd$，$\\tt eee$，$\\tt fffffff$，根目录下包含目录 $\\tt a$ 和文件 $\\tt fffffff$，目录 $\\tt a$ 下包含目录 $\\tt bbbbb$ 和文件 $\\tt eee$，目录 $\\tt bbbbb$ 包含文件 $\\tt ccccccccccccc$ 和 $\\tt dddddddddd$。下面是形象化的表述：\n\n```plain\n/\n|-- a\n| |-- bbbbb\n| | |-- ccccccccccccc\n| | +-- dddddddddd\n| +-- eeee\n+-- fffffff\n```\n\n- 对于第 $1$ 个文件，满足条件的路径为 $\\tt /a/bbbbb/ccccccccccccc$。\n- 对于第 $2$ 个文件，满足条件的路径为 $\\tt /a/LL/bbbbb/dddddddddd$。\n- 对于第 $3$ 个文件，满足条件的路径为 $\\tt /a/LL/a/LL/a/LL/a/eeee$。\n- 对于第 $4$ 个文件，无满足条件的路径。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（33 pts）：$n,m \\le 500$。\n- Subtask 2（33 pts）：$n,m \\le 3 \\times 10^3$，符号链接最多被调用一次。\n- Subtask 3（34 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le k,s \\le 10^6$，$1\\le m,n\\le 3\\times 10^3$。\n\n#### 说明\n\n翻译自 [BalticOI 2015 Day2 A File Paths](https://boi.cses.fi/files/boi2015_day2.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6844", "type": "P", "difficulty": 7, "samples": [["3\n2\n0 0\n0 1\n0 2", "YES\n1\n2\n3\n"], ["3\n1\n0 0\n1 1\n2 2", "YES\n2\n3\n1"], ["2\n1\n0 0\n0 2\n", "NO"]], "limits": {"time": [3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "Special Judge", "CEOI（中欧）"], "title": "[CEOI 2019] Building Skyscrapers", "background": "", "description": "在 2D 平面上，有 $n$ 个计划建摩天楼的格子，第 $i$ 座计划建的摩天楼的格子位于 $(r_i,c_i)$。\n\n您可以选择任意一种建摩天楼的顺序，但是要满足如下设定：\n\n- 设建摩天楼的顺序为 $s$。\n- 对于任意 $2\\le i\\le n$，都要保证，第 $s_i$ 座至少和前面任意一座摩天楼有公共边或公共角。\n- 对于任意 $1\\le i\\le n$，都要保证，从第 $s_i$ 座计划建摩天楼的格子到 2D 平面的边界，有路径相连（从一个格子只能走到与其有公共边的格子），且路径上除第 $s_i$ 座摩天楼无其他摩天楼。\n\n同时会输入一个 $t$，表示输出的类别：\n\n- 若 $t=1$，您需要构造任意一种建造的顺序。\n- 若 $t=2$，您需要构造 $(s_n, s_{n - 1}, \\dots, s_1)$ 字典序最大的建造顺序。", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个整数 $t$。\n\n接下来 $n$ 行，每行两个整数 $r_i,c_i$，第 $i$ 行表示第 $i$ 座计划建的摩天楼的坐标为 $(r_i,c_i)$。", "outputFormat": "第一行为一个字符串 `YES` 或者 `NO`，表示是否有一种可行的方案。\n\n若有一种可行的方案，接下来输出 $n$ 行，一行一个整数表示您构造的方案。\n\n- 若 $t=1$，您需要构造任意一种建造的顺序。\n- 若 $t=2$，您需要构造 $(s_n, s_{n - 1}, \\dots, s_1)$ 字典序最大的建造顺序。", "hint": "#### 样例解释\n\n#### 样例 1 解释\n\n这是三个摩天楼连成一行，自然有如下几种解：\n\n- $1,2,3$\n- $2,1,3$\n- $2,3,1$\n- $3,2,1$\n\n因为 $t=2$，所以输出第一种。\n\n#### 样例 2 解释\n\n和样例 1 的区别只是三个摩天楼连成一条对角线，与样例 1 的解一致，又因为 $t=1$，随便输出一组即可。\n\n#### 样例 3 解释\n\n两个摩天楼无相交部分，自然无法建立。\n#### 数据范围\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 1.5\\times 10^5$，$1\\le t\\le 2$，$\\lvert r_i \\rvert,\\lvert c_i \\rvert\\le 10^9$。\n\n详细子任务限制及分值如下表：\n\n| 子任务编号 | 限制 | 分值 |\n| :-: |:-:|:-:|\n| 1 | $t=1$ 且 $n\\le 10$ | $8$ | \n| 2 | $t=1$ 且 $n\\le 200$ | $14$ | \n| 3 | $t=1$ 且 $n\\le 2\\times 10^3$ | $12$ | \n| 4 | $t=2$ 且 $n\\le 2\\times 10^3$ | $17$ | \n| 5 | $t=1$ | $20$ | \n| 6 | $t=2$，$n\\le 7\\times 10^4$ 且 $\\lvert r_i \\rvert,\\lvert c_i \\rvert\\le 900$ | $10$ | \n| 7 | $t=2$ | $19$ | \n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 1](https://ceoi.sk/tasks/) [T1 Building Skyscrapers](https://ceoi.sk/static/statements/skyscrapers-ENG.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2019] Building Skyscrapers", "background": "", "description": "在 2D 平面上，有 $n$ 个计划建摩天楼的格子，第 $i$ 座计划建的摩天楼的格子位于 $(r_i,c_i)$。\n\n您可以选择任意一种建摩天楼的顺序，但是要满足如下设定：\n\n- 设建摩天楼的顺序为 $s$。\n- 对于任意 $2\\le i\\le n$，都要保证，第 $s_i$ 座至少和前面任意一座摩天楼有公共边或公共角。\n- 对于任意 $1\\le i\\le n$，都要保证，从第 $s_i$ 座计划建摩天楼的格子到 2D 平面的边界，有路径相连（从一个格子只能走到与其有公共边的格子），且路径上除第 $s_i$ 座摩天楼无其他摩天楼。\n\n同时会输入一个 $t$，表示输出的类别：\n\n- 若 $t=1$，您需要构造任意一种建造的顺序。\n- 若 $t=2$，您需要构造 $(s_n, s_{n - 1}, \\dots, s_1)$ 字典序最大的建造顺序。", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个整数 $t$。\n\n接下来 $n$ 行，每行两个整数 $r_i,c_i$，第 $i$ 行表示第 $i$ 座计划建的摩天楼的坐标为 $(r_i,c_i)$。", "outputFormat": "第一行为一个字符串 `YES` 或者 `NO`，表示是否有一种可行的方案。\n\n若有一种可行的方案，接下来输出 $n$ 行，一行一个整数表示您构造的方案。\n\n- 若 $t=1$，您需要构造任意一种建造的顺序。\n- 若 $t=2$，您需要构造 $(s_n, s_{n - 1}, \\dots, s_1)$ 字典序最大的建造顺序。", "hint": "#### 样例解释\n\n#### 样例 1 解释\n\n这是三个摩天楼连成一行，自然有如下几种解：\n\n- $1,2,3$\n- $2,1,3$\n- $2,3,1$\n- $3,2,1$\n\n因为 $t=2$，所以输出第一种。\n\n#### 样例 2 解释\n\n和样例 1 的区别只是三个摩天楼连成一条对角线，与样例 1 的解一致，又因为 $t=1$，随便输出一组即可。\n\n#### 样例 3 解释\n\n两个摩天楼无相交部分，自然无法建立。\n#### 数据范围\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 1.5\\times 10^5$，$1\\le t\\le 2$，$\\lvert r_i \\rvert,\\lvert c_i \\rvert\\le 10^9$。\n\n详细子任务限制及分值如下表：\n\n| 子任务编号 | 限制 | 分值 |\n| :-: |:-:|:-:|\n| 1 | $t=1$ 且 $n\\le 10$ | $8$ | \n| 2 | $t=1$ 且 $n\\le 200$ | $14$ | \n| 3 | $t=1$ 且 $n\\le 2\\times 10^3$ | $12$ | \n| 4 | $t=2$ 且 $n\\le 2\\times 10^3$ | $17$ | \n| 5 | $t=1$ | $20$ | \n| 6 | $t=2$，$n\\le 7\\times 10^4$ 且 $\\lvert r_i \\rvert,\\lvert c_i \\rvert\\le 900$ | $10$ | \n| 7 | $t=2$ | $19$ | \n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 1](https://ceoi.sk/tasks/) [T1 Building Skyscrapers](https://ceoi.sk/static/statements/skyscrapers-ENG.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6845", "type": "P", "difficulty": 6, "samples": [["4 3 2000\n1 2 100\n2 3 1000\n2 4 1000\n2 1030\n1 1020\n1 890", "2030\n2080\n2050\n"], ["10 10 10000\n1 9 1241\n5 6 1630\n10 5 1630\n2 6 853\n10 1 511\n5 3 760\n8 3 1076\n4 10 1483\n7 10 40\n8 2051\n5 6294\n5 4168\n7 1861\n0 5244\n6 5156\n3 3001\n8 5267\n5 3102\n8 3623", "6164\n7812\n8385\n6737\n6738\n7205\n6641\n7062\n6581\n5155"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "线段树", "点分治", "CEOI（中欧）", "深度优先搜索 DFS", "树的遍历", "树的直径", "树链剖分", "动态树分治", "动态 DP"], "title": "[CEOI 2019] Dynamic Diameter", "background": "", "description": "有一棵树，含 $n$ 个节点，边带权。\n\n会有 $q$ 次修改，每次会将树上的一条边的边权进行修改，在每次修改后，您需要求出每次修改后，这棵树的直径上的边权和。\n\n**本题强制在线。**", "inputFormat": "第一行为三个整数 $n,q,w$，分别表示点的个数，询问的个数和边权的上限。\n\n接下来 $n-1$ 行，每一行为三个整数 $a_i,b_i,c_i$，表示 $a_i$ 到 $b_i$ 有一条边权为 $c_i$ 的边。\n\n接下来 $q$ 行，每行两个经过加密的整数 $d_j,e_j$。\n\n解密方式如下：\n- $d_j'=(d_j+\\text{last})\\bmod(n-1)$\n- $e_j'=(e_j+\\text{last})\\bmod w$\n\n其中 $\\text{last}$ 表示上一个询问的答案，初值为 $0$。\n\n表示将第 $d_j'+1$ 条边的边权改为 $e_j'$。", "outputFormat": "共输出 $q$ 行，一行一个整数，第 $i$ 行的整数表示在第 $i$ 次修改后的直径上的权值总和。", "hint": "#### 样例 1 解释\n\n解密后的修改如下：\n```\n2 1030\n0 1050\n2 970\n```\n如图为树的边权变化过程，红边代表树的直径：\n![](https://cdn.luogu.com.cn/upload/image_hosting/sswn0icz.png)\n#### 数据范围\n对于 $100\\%$ 的数据，保证 $2\\le n\\le 10^5$，$1\\le q\\le 10^5$，$1\\le w\\le 2\\times 10^{13}$，$1\\le a_i,b_i\\le n$，$0\\le c_i,e_j<w$，$0\\le d_j<n-1$。\n\n详细子任务限制及分值如下表：\n\n| 子任务编号 | 限制 | 分值 |\n| :-: |:-:|:-:|\n| 1 | $n,q\\le 100$ 且 $w\\le 10^4$ | $11$ | \n| 2 | $n,q\\le 5\\times 10^3$ 且 $w\\le 10^4$ | $13$ | \n| 3 | $w\\le 10^4$ 且边的形式均为 $(1,i)$ | $7$ | \n| 4 | $w\\le 10^4$ 且边的形式均为 $(i,2\\times i)$ 或 $(i,2\\times i+1)$ | $18$ | \n| 5 | 保证有一条直径经过 $1$ 号节点 | $24$ | \n| 6 | 无特殊限制 | $27$ | \n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 1](https://ceoi.sk/tasks/) [T2 Dynamic Diameter](https://ceoi.sk/static/statements/diameter-ENG.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2019] Dynamic Diameter", "background": "", "description": "有一棵树，含 $n$ 个节点，边带权。\n\n会有 $q$ 次修改，每次会将树上的一条边的边权进行修改，在每次修改后，您需要求出每次修改后，这棵树的直径上的边权和。\n\n**本题强制在线。**", "inputFormat": "第一行为三个整数 $n,q,w$，分别表示点的个数，询问的个数和边权的上限。\n\n接下来 $n-1$ 行，每一行为三个整数 $a_i,b_i,c_i$，表示 $a_i$ 到 $b_i$ 有一条边权为 $c_i$ 的边。\n\n接下来 $q$ 行，每行两个经过加密的整数 $d_j,e_j$。\n\n解密方式如下：\n- $d_j'=(d_j+\\text{last})\\bmod(n-1)$\n- $e_j'=(e_j+\\text{last})\\bmod w$\n\n其中 $\\text{last}$ 表示上一个询问的答案，初值为 $0$。\n\n表示将第 $d_j'+1$ 条边的边权改为 $e_j'$。", "outputFormat": "共输出 $q$ 行，一行一个整数，第 $i$ 行的整数表示在第 $i$ 次修改后的直径上的权值总和。", "hint": "#### 样例 1 解释\n\n解密后的修改如下：\n```\n2 1030\n0 1050\n2 970\n```\n如图为树的边权变化过程，红边代表树的直径：\n![](https://cdn.luogu.com.cn/upload/image_hosting/sswn0icz.png)\n#### 数据范围\n对于 $100\\%$ 的数据，保证 $2\\le n\\le 10^5$，$1\\le q\\le 10^5$，$1\\le w\\le 2\\times 10^{13}$，$1\\le a_i,b_i\\le n$，$0\\le c_i,e_j<w$，$0\\le d_j<n-1$。\n\n详细子任务限制及分值如下表：\n\n| 子任务编号 | 限制 | 分值 |\n| :-: |:-:|:-:|\n| 1 | $n,q\\le 100$ 且 $w\\le 10^4$ | $11$ | \n| 2 | $n,q\\le 5\\times 10^3$ 且 $w\\le 10^4$ | $13$ | \n| 3 | $w\\le 10^4$ 且边的形式均为 $(1,i)$ | $7$ | \n| 4 | $w\\le 10^4$ 且边的形式均为 $(i,2\\times i)$ 或 $(i,2\\times i+1)$ | $18$ | \n| 5 | 保证有一条直径经过 $1$ 号节点 | $24$ | \n| 6 | 无特殊限制 | $27$ | \n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 1](https://ceoi.sk/tasks/) [T2 Dynamic Diameter](https://ceoi.sk/static/statements/diameter-ENG.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6846", "type": "P", "difficulty": 6, "samples": [["2 1\n1 2\n", "1\n"], ["3 3\n1 2\n2 3\n1 3", "9"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "CEOI（中欧）"], "title": "[CEOI 2019] Amusement Park", "background": "", "description": "有一个含 $n$ 个点，$m$ 条边的有向图，图无重边，无自环，两点之间不成环。\n\n现在我们想改变一些边的方向，使得该有向图无环。\n\n您需要求出，每一种改变方向后使得该有向图无环的方案的需改变边的数量之和 $\\bmod\\ 998244353$ 之后的答案。", "inputFormat": "第一行为两个整数 $n,m$。\n\n接下来 $m$ 行，一行两个整数 $a_i,b_i$，表示有一条起点为 $a_i$，终点为 $b_i$ 的有向边。", "outputFormat": "仅一行一个整数，表示每一种改变方向后使得该有向图无环的方案的需改变边的数量之和 $\\bmod\\ 998244353$ 之后的答案。", "hint": "#### 样例解释\n#### 样例 1 解释\n有如下两种方案：\n- 改变方向。\n- 不改变方向。\n\n所以输出 $1+0=1$。\n#### 样例 2 解释\n共有六种可行的方案：\n- $1\\to2,2\\to3,1\\to3$\n- $1\\to2,3\\to2,1\\to3$\n- $1\\to2,3\\to2,3\\to1$\n- $2\\to1,2\\to3,1\\to3$\n- $2\\to1,2\\to3,3\\to1$\n- $2\\to1,3\\to2,3\\to1$\n\n所以输出 $0+1+2+1+2+3=9$。\n#### 数据范围\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 18$，$0\\le m\\le \\frac{n\\times (n-1)}{2}$，$1\\le a_i,b_i\\le n$，$a_i\\not=b_i$，对于 $i\\not=j$，均有 $a_i\\not=a_j$ 或者 $b_i\\not=b_j$，无序数对 $\\{a_i,b_i\\}$ 互不相同。\n\n详细子任务限制及分值如下表：\n\n| 子任务编号 | 限制 | 分值 |\n| :-: |:-:|:-:|\n| 1 | $n\\le 3$ | $7$ | \n| 2 | $n\\le 6$ | $12$ | \n| 3 | $n\\le 10$ | $23$ | \n| 4 | $n\\le 15$ | $21$ | \n| 5 | 无特殊限制 | $37$ | \n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 2](https://ceoi.sk/tasks/) [T1 Amusement Park](https://ceoi.sk/static/statements/amusementpark-ENG.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2019] Amusement Park", "background": "", "description": "有一个含 $n$ 个点，$m$ 条边的有向图，图无重边，无自环，两点之间不成环。\n\n现在我们想改变一些边的方向，使得该有向图无环。\n\n您需要求出，每一种改变方向后使得该有向图无环的方案的需改变边的数量之和 $\\bmod\\ 998244353$ 之后的答案。", "inputFormat": "第一行为两个整数 $n,m$。\n\n接下来 $m$ 行，一行两个整数 $a_i,b_i$，表示有一条起点为 $a_i$，终点为 $b_i$ 的有向边。", "outputFormat": "仅一行一个整数，表示每一种改变方向后使得该有向图无环的方案的需改变边的数量之和 $\\bmod\\ 998244353$ 之后的答案。", "hint": "#### 样例解释\n#### 样例 1 解释\n有如下两种方案：\n- 改变方向。\n- 不改变方向。\n\n所以输出 $1+0=1$。\n#### 样例 2 解释\n共有六种可行的方案：\n- $1\\to2,2\\to3,1\\to3$\n- $1\\to2,3\\to2,1\\to3$\n- $1\\to2,3\\to2,3\\to1$\n- $2\\to1,2\\to3,1\\to3$\n- $2\\to1,2\\to3,3\\to1$\n- $2\\to1,3\\to2,3\\to1$\n\n所以输出 $0+1+2+1+2+3=9$。\n#### 数据范围\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 18$，$0\\le m\\le \\frac{n\\times (n-1)}{2}$，$1\\le a_i,b_i\\le n$，$a_i\\not=b_i$，对于 $i\\not=j$，均有 $a_i\\not=a_j$ 或者 $b_i\\not=b_j$，无序数对 $\\{a_i,b_i\\}$ 互不相同。\n\n详细子任务限制及分值如下表：\n\n| 子任务编号 | 限制 | 分值 |\n| :-: |:-:|:-:|\n| 1 | $n\\le 3$ | $7$ | \n| 2 | $n\\le 6$ | $12$ | \n| 3 | $n\\le 10$ | $23$ | \n| 4 | $n\\le 15$ | $21$ | \n| 5 | 无特殊限制 | $37$ | \n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 2](https://ceoi.sk/tasks/) [T1 Amusement Park](https://ceoi.sk/static/statements/amusementpark-ENG.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6847", "type": "P", "difficulty": 6, "samples": [["6 4 10\n1\n2\n1\n4\n4\n3 4 5\n4 7 2\n5 4 1\n6 9 3\n", "9\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "CEOI（中欧）"], "title": "[CEOI 2019] Magic Tree", "background": null, "description": "有一棵以 $1$ 为根，节点从 $1$ 到 $n$ 编号的树。\n\n在这棵树上有许多果实，第 $j$ 个果实会于第 $d_j$ 天在节点 $v_j$ 成熟，并且在收获后可获得 $w_j$ 的果汁。\n\n第 $j$ 个果实仅能在第 $d_j$ 天收获。\n\n收获的方式是断掉这棵树的一条边，这会获得在这条边上作为儿子的那个点的子树上的当天成熟的果实的果汁。\n\n同时，以您砍掉那条边的儿子为根的那个子树会掉在地上，所有掉在地上的未成熟水果都会被丢弃，无法收集它们的果汁。\n\n您要求出最多可以获得多少果汁。", "inputFormat": "第一行为三个整数 $n,m,k$，分别表示节点的个数，果实的个数和果实可能成熟天数的最大值。\n\n接下来 $n-1$ 行，一行一个整数 $p_i$，表示 $i+1$ 号节点的父亲是 $p_i$。\n\n接下来 $m$ 行一行三个整数 $v_j,d_j,w_j$。", "outputFormat": "一行一个数，表示最多可以获得多少果汁。", "hint": "#### 样例解释\n最优方案如下：\n- 在第四天，断掉 $(4,5)$ 和 $(1,2)$，获得第一个和第三个果实，获得的果汁数量累计为 $6$。\n- 在第七天，虽然我们有一个果实成熟，但是我们最好什么都不干。\n- 在第九天，断掉 $(1,4)$，获得最后一个果实，获得的果汁数量累计为 $9$。\n#### 数据范围\n对于 $100\\%$ 的数据，保证 $2\\le n\\le 10^5$，$1\\le m\\le n-1$，$1\\le k\\le 10^5$，$1\\le p_i\\le i-1$，$2\\le v_j\\le n$，$1\\le d_j\\le k$，$1\\le w_j\\le 10^9$，$v_j$ 互不相同。\n\n详细子任务限制及分值如下表：\n\n| 子任务编号 | 限制 | 分值 |\n| :-: |:-:|:-:|\n| 1 | $n,k\\le 20$ 且 $w_j=1$ | $6$ | \n| 2 | $v_j\\in $ 叶子节点 | $3$ | \n| 3 | 图是一条链且 $w_j=1$ | $11$ | \n| 4 | $k\\le 2$ | $12$ | \n| 5 | $k\\le 20$ 且 $w_j=1$ | $16$ | \n| 6 | $m\\le 10^3$ | $13$ | \n| 7 | $w_j=1$ | $22$ | \n| 8 | 无特殊性质 | $17$ | \n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 2](https://ceoi.sk/tasks/) [T2 Magic Tree](https://ceoi.sk/static/statements/magictree-ENG.pdf)。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2019] Magic Tree", "background": null, "description": "We have a magic tree: a rooted tree on $n$ vertices. The vertices are numbered $1$ through $n$. Vertex $1$ is the root.\n\nThe magic tree gives us magic fruit. The fruit only grows in vertices of the tree other than the root. Each vertex contains at most one piece of fruit.\n\nIt is now day $0$ and no fruit is ripe yet. Each fruit will only be ripe for a single day. For each fruit, we are given the vertex $v_j$ where it grows, the day $d_j$ on which it will be ripe, and the amount $w_j$ of magic juice we can extract from it if we harvest it when it is ripe.\n\nThe fruits have to be harvested by cutting some branches of the tree. On each day, you may cut as many branches of the tree as you like. The parts of the tree you cut off will fall to the ground and you can collect all the ripe fruits they contain. All fruits that fall to the ground when they are not ripe are discarded and no magic juice is collected from them.\n\nFormally, on each day, you may erase some edges of the tree. Whenever you do so, the tree will split into multiple connected components. You then erase all components that do not contain the root and you harvest all ripe fruits those components contained.\n\nGiven is a description of the tree together with the locations, ripening days and juiciness of all $m$ fruits. Calculate the maximum total amount of magic juice we can harvest from the tree.", "inputFormat": "The first line contains three space-separated integers $n$ ($2 \\leq n \\leq 10^5$), $m$ ($1 \\leq m \\leq n − 1$) and $k$ ($1 \\leq k \\leq10^5$)– the number of vertices, the number of fruits, and the maximum day on which a fruit may become ripe.\n\nThe following $n−1$ lines contain the integers $p_2,...,p_n$, one per line.For each $i$ (from $2$ to $n$, inclusive), vertex $p_i$($1 \\leq p_i \\leq i−1$) is the parent of vertex $i$.\n\nEach of the last m lines describes one fruit. The $\\text{j-th}$ of these lines has the form $“v_j\\; d_j\\;w_j”$ ($2 \\leq v_j \\leq n, 1 \\leq d_j \\leq k, 1 \\leq w_j ≤10^9$).\n\nIt is guaranteed that no vertex contains more than one fruit ($\\text{i.e.}$, the values $v_j$ are distinct).", "outputFormat": "Output a single line with a single integer, the maximum amount of magic juice we can harvest from the tree.", "hint": "Subtask 1 (6 points): $n,k \\leq 20$, and $w_j = 1$ for all $j$\n\nSubtask 2 (3 points): fruits only grow in the leaves of the tree\n\nSubtask 3 (11 points): $p_i = i −1$ for each $i$, and $w_j = 1$ for all $j$\n\nSubtask 4 (12 points): $k \\leq 2$\n\nSubtask 5 (16 points): $k \\leq 20$, and $w_j = 1$ for all $j$\n\nSubtask 6 (13 points): $m \\leq 10^3$\n\nSubtask 7 (22 points): $w_j = 1$ for all $j$\n\nSubtask 8 (17 points): no additional constraints", "locale": "en"}, "zh-CN": {"title": "[CEOI 2019] Magic Tree", "background": null, "description": "有一棵以 $1$ 为根，节点从 $1$ 到 $n$ 编号的树。\n\n在这棵树上有许多果实，第 $j$ 个果实会于第 $d_j$ 天在节点 $v_j$ 成熟，并且在收获后可获得 $w_j$ 的果汁。\n\n第 $j$ 个果实仅能在第 $d_j$ 天收获。\n\n收获的方式是断掉这棵树的一条边，这会获得在这条边上作为儿子的那个点的子树上的当天成熟的果实的果汁。\n\n同时，以您砍掉那条边的儿子为根的那个子树会掉在地上，所有掉在地上的未成熟水果都会被丢弃，无法收集它们的果汁。\n\n您要求出最多可以获得多少果汁。", "inputFormat": "第一行为三个整数 $n,m,k$，分别表示节点的个数，果实的个数和果实可能成熟天数的最大值。\n\n接下来 $n-1$ 行，一行一个整数 $p_i$，表示 $i+1$ 号节点的父亲是 $p_i$。\n\n接下来 $m$ 行一行三个整数 $v_j,d_j,w_j$。", "outputFormat": "一行一个数，表示最多可以获得多少果汁。", "hint": "#### 样例解释\n最优方案如下：\n- 在第四天，断掉 $(4,5)$ 和 $(1,2)$，获得第一个和第三个果实，获得的果汁数量累计为 $6$。\n- 在第七天，虽然我们有一个果实成熟，但是我们最好什么都不干。\n- 在第九天，断掉 $(1,4)$，获得最后一个果实，获得的果汁数量累计为 $9$。\n#### 数据范围\n对于 $100\\%$ 的数据，保证 $2\\le n\\le 10^5$，$1\\le m\\le n-1$，$1\\le k\\le 10^5$，$1\\le p_i\\le i-1$，$2\\le v_j\\le n$，$1\\le d_j\\le k$，$1\\le w_j\\le 10^9$，$v_j$ 互不相同。\n\n详细子任务限制及分值如下表：\n\n| 子任务编号 | 限制 | 分值 |\n| :-: |:-:|:-:|\n| 1 | $n,k\\le 20$ 且 $w_j=1$ | $6$ | \n| 2 | $v_j\\in $ 叶子节点 | $3$ | \n| 3 | 图是一条链且 $w_j=1$ | $11$ | \n| 4 | $k\\le 2$ | $12$ | \n| 5 | $k\\le 20$ 且 $w_j=1$ | $16$ | \n| 6 | $m\\le 10^3$ | $13$ | \n| 7 | $w_j=1$ | $22$ | \n| 8 | 无特殊性质 | $17$ | \n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 2](https://ceoi.sk/tasks/) [T2 Magic Tree](https://ceoi.sk/static/statements/magictree-ENG.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6848", "type": "P", "difficulty": 7, "samples": [["6 0 0 6 0 6 4 5 4 5 9 0 9\n4 0 0 7 0 7 7 0 7\n", "scissors\n0 5\n3 0 0 3 0 3 4\n3 3 4 0 4 0 0\n3 3 0 6 0 6 4\n3 6 4 3 4 3 0\n4 0 4 5 4 5 9 0 9\ntape\n5 1 2 5 3 4\n3 0 3 0 0 4 0\n3 4 0 7 0 7 4\n4 0 3 4 0 7 4 3 7\n3 7 4 7 7 3 7\n3 3 7 0 7 0 3\n4 0 0 7 0 7 7 0 7"], ["4 0 0 3 0 3 3 0 3\n4 7 -1 10 -1 11 2 8 2\n", "scissors\n0 2\n3 0 0 1 3 0 3\n4 1 3 0 0 3 0 3 3\ntape\n2 1 2\n3 110 -1 111 2 110 2\n4 108 2 107 -1 110 -1 110 2\n4 107 -1 110 -1 111 2 108 2\n"], ["4 0 0 9 0 9 1 0 1\n4 0 0 3 0 3 3 0 3\n", "scissors\n0 2\n4 1.47000000000 0 9 0 9 1 1.470000000 1\n4 0 0 1.470000000 0 1.470000000 1 0 1\nscissors\n1 2\n4 1.470000000 0 6 0 6 1 1.470000000 1\n4 9 0 9 1 6 1 6 0\ntape\n2 4 3\n4 3 2 3 1 6 1 6 2\n4 6 1 1.470000000 1 1.470000000 0 6 0\n6 1.470000000 0 6 0 6 2 3 2 3 1 1.47 1\nscissors\n5 4\n4 1.470000000 0 3 0 3 1 1.470000000 1\n4 3 0 4 0 4 2 3 2\n4 4 2 4 0 5 0 5 2\n4 5 0 6 0 6 2 5 2\ntape\n5 2 6 7 8 9\n4 0 0 1.470000000 0 1.470000000 1 0 1\n4 1.470000000 0 3 0 3 1 1.470000000 1\n4 0 2 0 1 2 1 2 2\n4 0 2 2 2 2 3 0 3\n4 3 3 2 3 2 1 3 1\n4 0 0 3 0 3 3 0 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "Special Judge", "CEOI（中欧）"], "title": "[CEOI 2019] Scissors and Tape", "background": "", "description": "您有一个简单多边形 $S$，现在您想将其变成与其面积相等的简单多边形 $T$。\n\n您可以使用两种工具：剪刀和胶带。剪刀可将任何多边形切割成较小的多边形。胶带可将较小的多边形组合成较大的多边形。您可以按任何顺序多次使用每个工具。\n\n输入中的多边形的顶点坐标均为整数，但您的方案允许产生顶点坐标不为整数的多边形。\n\n任务的形式化定义如下：\n\n一个形状 $Q=(Q_0,\\ldots Q_{n-1})$ 是平面中三个点及以上的序列，满足：\n\n- 闭合折线 $Q_0,Q_1,Q_2,\\ldots Q_{n-1},Q_0$ 不相交。\n- 这段折线以逆时针围绕多边形的边界。\n\n以形状 $Q$ 为边界的多边形为 $P(Q)$。\n\n两个形状等效当且仅当一个形状经过平移或旋转之后与另一个形状相同。\n\n不允许对形状进行对称，且点的顺序与形状有关：$(Q_0,Q_1\\ldots Q_{n-1})$ 不一定等价于 $(Q_1\\ldots Q_{n-1},Q_0)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ttm5ro7.png)\n\n在上图中，形状 $U$ 和 $V$ 是等价的，但形状 $W$ 与他们不等价，原因是给出的点的顺序不同，无论如何，第四个形状都不与前三个形状相同，因为不允许对称形状。\n\n每一个形状的表示由 $2\\times n+1$ 个数组成，第一个数为 $n$，表示形状的点数，接下来 $2\\times n$ 个数 $Q_{0,x},Q_{0,y},Q_{1,x},\\ldots,Q_{n-1,x},Q_{n-1,y}$，每两个数均表示形状里一个点的坐标，如 $(Q_{0,x},Q_{0,y})$ 为 $Q_0$ 的坐标。\n\n形状 $B_1,B_2,\\ldots B_k$ 被称为形状 $A$ 的划分，当且仅当：\n\n- 所有 $P(B_i)$ 的并集为 $P(A)$。\n- 对于所有的 $i\\not=j$，$P(B_i)$ 与 $P(B_j)$ 无交。\n\n形状是有 ID 的，$S$ 的 ID 为 $0$，您在解决方案中生成的 ID 为 $1,2,3,\\ldots$。\n\n剪刀将会剪开一个现有的形状 $A$，并产生 $A$ 的一个划分 $B_1,B_2,\\ldots B_k$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dz34b81y.png)\n\n在上图中，形状 $A$ 被划分成了 $B_1,B_2,B_3$ 三个三角形。其中描述红色三角形的一种方式为 `3 3 1 6 1 5.1 4`。\n\n胶带可以粘合存在的形状 $A_1,\\ldots A_k$ 并使其变成形状 $B$，要执行这个操作，需要给定 $C_1,\\ldots,C_k$ 和最终形状 $B$ 并满足如下要求：\n\n- $C_i$ 等价于 $A_i$。\n- $C_1,\\ldots,C_k$ 是 $B$ 的划分。\n\n通俗地说，你选择了形状 $B$，然后展示如何把每个存在的 $A_i$ 移动到构成 $B$ 的正确的位置 $C_I$。注意形状 $B$ 需要分配一个新 ID，但 $C_i$ 不需要。", "inputFormat": "第一行为形状 $S$。\n\n第二行为形状 $T$。", "outputFormat": "每当使用剪刀时，按如下格式输出：\n```\nscissors\nid(A) k\nB_1\nB_2\n...\nB_k\n```\n每当使用胶布时，按如下格式输出：\n```\ntape\nk id(A_1) ... id(A_k)\nC_1\nC_2\n...\nC_k\nB\n```\n您的输出需要保证以下限制：\n- 输出的所有点坐标在 $[-10^7,10^7]$ 之内。\n- 输出的每个形状最多能有 $100$ 个点。\n- 每次操作中，$1\\le k\\le 100$。\n- 操作数不多于 $2\\times 10^3$。\n- 输出中所有形状的总点数不超过 $2\\times 10^4$。\n- 最后必须只剩下一个形状，且这个形状等价于 $T$。", "hint": "#### 样例解释\n#### 样例 1 解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/nn0psa1v.png)\n\n上左图是使用剪刀操作后的原始图形，右侧是使用胶带后对应 $C_i$。\n#### 样例 2 解释\n请注意，目标和您的最后达成的多边形只需等价即可，不需完全相同。\n#### 样例 3 解释\n下图显示了这个样例输出的三个阶段：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bk5bbncz.png)\n#### 数据范围及限制\n对于 $100\\%$ 的数据，保证 $S$ 与 $T$ 的点数 $\\le 10$ 且 $\\ge 3$，输入的所有点坐标在 $[-10^6,10^6]$ 之内，无三点共线的情况，$P(S)$ 与 $P(T)$ 的面积相等。\n\n如果一个形状的顶点分别为 $(0,0),(x,0),(0,y),(x,y)$ 且 $x,y$ 为正整数，则称它为好矩形。\n\n如果一个形状是好矩形且 $x=y$，则称它为好正方形。\n\n如果多边形 $P(A)$ 的每个内角都小于 $180$ 度，则称形状 $A$ 为严格凸多边形。\n\n详细子任务限制如下：\n| 子任务编号 | 限制 | 分数 |\n| :-: | :-: | :-: |\n| 1 | $S$ 和 $T$ 是好矩形且输入的所有点坐标在 $[1,10]$ 之内 | $5$ | \n| 2 | $S$ 是好矩形且 $x>y$，$T$ 是好正方形 | $13$ |\n| 3 | $S,T$ 是好矩形 | $12$ |\n| 4 | $S$ 是三角形，$T$ 是好正方形 | $14$ |\n| 5 | $S,T$ 均是三角形 | $10$ |\n| 6 | $S$ 是严格凸多边形，$T$ 是好矩形 | $16$ |\n| 7 | $T$ 是好矩形 | $11$ |\n| 8 | 无特殊限制 | $19$ |\n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 2](https://ceoi.sk/tasks/) [T3 Scissors and Tape](https://ceoi.sk/static/statements/scissors-ENG.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2019] Scissors and Tape", "background": "", "description": "您有一个简单多边形 $S$，现在您想将其变成与其面积相等的简单多边形 $T$。\n\n您可以使用两种工具：剪刀和胶带。剪刀可将任何多边形切割成较小的多边形。胶带可将较小的多边形组合成较大的多边形。您可以按任何顺序多次使用每个工具。\n\n输入中的多边形的顶点坐标均为整数，但您的方案允许产生顶点坐标不为整数的多边形。\n\n任务的形式化定义如下：\n\n一个形状 $Q=(Q_0,\\ldots Q_{n-1})$ 是平面中三个点及以上的序列，满足：\n\n- 闭合折线 $Q_0,Q_1,Q_2,\\ldots Q_{n-1},Q_0$ 不相交。\n- 这段折线以逆时针围绕多边形的边界。\n\n以形状 $Q$ 为边界的多边形为 $P(Q)$。\n\n两个形状等效当且仅当一个形状经过平移或旋转之后与另一个形状相同。\n\n不允许对形状进行对称，且点的顺序与形状有关：$(Q_0,Q_1\\ldots Q_{n-1})$ 不一定等价于 $(Q_1\\ldots Q_{n-1},Q_0)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ttm5ro7.png)\n\n在上图中，形状 $U$ 和 $V$ 是等价的，但形状 $W$ 与他们不等价，原因是给出的点的顺序不同，无论如何，第四个形状都不与前三个形状相同，因为不允许对称形状。\n\n每一个形状的表示由 $2\\times n+1$ 个数组成，第一个数为 $n$，表示形状的点数，接下来 $2\\times n$ 个数 $Q_{0,x},Q_{0,y},Q_{1,x},\\ldots,Q_{n-1,x},Q_{n-1,y}$，每两个数均表示形状里一个点的坐标，如 $(Q_{0,x},Q_{0,y})$ 为 $Q_0$ 的坐标。\n\n形状 $B_1,B_2,\\ldots B_k$ 被称为形状 $A$ 的划分，当且仅当：\n\n- 所有 $P(B_i)$ 的并集为 $P(A)$。\n- 对于所有的 $i\\not=j$，$P(B_i)$ 与 $P(B_j)$ 无交。\n\n形状是有 ID 的，$S$ 的 ID 为 $0$，您在解决方案中生成的 ID 为 $1,2,3,\\ldots$。\n\n剪刀将会剪开一个现有的形状 $A$，并产生 $A$ 的一个划分 $B_1,B_2,\\ldots B_k$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dz34b81y.png)\n\n在上图中，形状 $A$ 被划分成了 $B_1,B_2,B_3$ 三个三角形。其中描述红色三角形的一种方式为 `3 3 1 6 1 5.1 4`。\n\n胶带可以粘合存在的形状 $A_1,\\ldots A_k$ 并使其变成形状 $B$，要执行这个操作，需要给定 $C_1,\\ldots,C_k$ 和最终形状 $B$ 并满足如下要求：\n\n- $C_i$ 等价于 $A_i$。\n- $C_1,\\ldots,C_k$ 是 $B$ 的划分。\n\n通俗地说，你选择了形状 $B$，然后展示如何把每个存在的 $A_i$ 移动到构成 $B$ 的正确的位置 $C_I$。注意形状 $B$ 需要分配一个新 ID，但 $C_i$ 不需要。", "inputFormat": "第一行为形状 $S$。\n\n第二行为形状 $T$。", "outputFormat": "每当使用剪刀时，按如下格式输出：\n```\nscissors\nid(A) k\nB_1\nB_2\n...\nB_k\n```\n每当使用胶布时，按如下格式输出：\n```\ntape\nk id(A_1) ... id(A_k)\nC_1\nC_2\n...\nC_k\nB\n```\n您的输出需要保证以下限制：\n- 输出的所有点坐标在 $[-10^7,10^7]$ 之内。\n- 输出的每个形状最多能有 $100$ 个点。\n- 每次操作中，$1\\le k\\le 100$。\n- 操作数不多于 $2\\times 10^3$。\n- 输出中所有形状的总点数不超过 $2\\times 10^4$。\n- 最后必须只剩下一个形状，且这个形状等价于 $T$。", "hint": "#### 样例解释\n#### 样例 1 解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/nn0psa1v.png)\n\n上左图是使用剪刀操作后的原始图形，右侧是使用胶带后对应 $C_i$。\n#### 样例 2 解释\n请注意，目标和您的最后达成的多边形只需等价即可，不需完全相同。\n#### 样例 3 解释\n下图显示了这个样例输出的三个阶段：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bk5bbncz.png)\n#### 数据范围及限制\n对于 $100\\%$ 的数据，保证 $S$ 与 $T$ 的点数 $\\le 10$ 且 $\\ge 3$，输入的所有点坐标在 $[-10^6,10^6]$ 之内，无三点共线的情况，$P(S)$ 与 $P(T)$ 的面积相等。\n\n如果一个形状的顶点分别为 $(0,0),(x,0),(0,y),(x,y)$ 且 $x,y$ 为正整数，则称它为好矩形。\n\n如果一个形状是好矩形且 $x=y$，则称它为好正方形。\n\n如果多边形 $P(A)$ 的每个内角都小于 $180$ 度，则称形状 $A$ 为严格凸多边形。\n\n详细子任务限制如下：\n| 子任务编号 | 限制 | 分数 |\n| :-: | :-: | :-: |\n| 1 | $S$ 和 $T$ 是好矩形且输入的所有点坐标在 $[1,10]$ 之内 | $5$ | \n| 2 | $S$ 是好矩形且 $x>y$，$T$ 是好正方形 | $13$ |\n| 3 | $S,T$ 是好矩形 | $12$ |\n| 4 | $S$ 是三角形，$T$ 是好正方形 | $14$ |\n| 5 | $S,T$ 均是三角形 | $10$ |\n| 6 | $S$ 是严格凸多边形，$T$ 是好矩形 | $16$ |\n| 7 | $T$ 是好矩形 | $11$ |\n| 8 | 无特殊限制 | $19$ |\n#### 说明\n本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 2](https://ceoi.sk/tasks/) [T3 Scissors and Tape](https://ceoi.sk/static/statements/scissors-ENG.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6849", "type": "P", "difficulty": 7, "samples": [["3 4\n1 1 2\n2 1 2 3\n1 2 1 1\n2 1 2 1\n3 1 0 1", "2\n0\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "搜索", "2017", "提交答案", "Special Judge", "剪枝", "模拟退火", "背包 DP", "费用流", "随机化", "THUWC"], "title": "[THUWC 2017] 大葱的神力", "background": "**本题为提交答案题。**\n\n大葱是我国自古以来的美食，像我国传统美食北京烤鸭，用鸭子点缀出大葱的香味，令人赞不绝口。民间也流传着有「每天一棵葱，不当单身狗」的说法。\n\n然而，大葱要发挥出独属于自己的神力，也是有条件的。", "description": "现在小葱同学有 $N$ 棵大葱和 $M$ 个抽屉，将第 $i$ 棵大葱放到第 $j$ 个抽屉里面会产生 $w_{i,j}$ 的神力。自然小葱同学希望获得尽量多的神力，但是抽屉有着容积的限制，大葱也有着自己的体积。第 $i$ 棵大葱的体积为 $a_i$，第 $j$ 个抽屉的容积为 $b_j$。一个抽屉里面装着的大葱的体积之和不能超过这个抽屉的容积，一棵大葱不能拆分放到两个抽屉中。\n\n小葱同学现在想知道，在这样的条件下，这些大葱最多会产生多少的神力？", "inputFormat": "**本题为提交答案题**，输入文件为 `drawer1.in ~ drawer10.in`，详见附加文件。\n\n第一行两个整数 $N,M$，代表大葱的个数和抽屉的个数。\n\n接下来一行 $N$ 个整数，代表每棵大葱的体积。\n\n接下来一行 $M$ 个整数，代表每个抽屉的容积。\n\n接下来 $N$ 行每行 $M$ 个整数，第 $i$ 行第 $j$ 个数代表第 $i$ 棵大葱放到第 $j$ 个抽屉中会产生的神力。", "outputFormat": "输出文件为 `drawer1.out ~ drawer10.out`，分别对应相应的输入文件。\n\n对于每组输入数据，输出 $N$ 行每行一个整数，第 $i$ 个数代表第 $i$ 棵大葱被放到了哪个抽屉里面。如果第 $i$ 棵大葱没有被放到任何一个抽屉里面，则输出 $0$。", "hint": "#### 样例说明\n\n样例只是一种合法情况，获得的总神力值为 $2+3=5$。\n\n#### 评分方式\n\n**本题使用 Special Judge**，对于每个测试点，我们都有 $10$ 个参数 $a_1,a_2,\\cdots,a_{10}$，如果你的输出所产生的的神力 $v$ 满足 $v \\ge a_i$，则我们保证该测试点你至少会得到 $i$ 分。\n\n#### 如何测试你的输出\n\n在附加文件中，我们提供了 `scorer.cpp`，请自行编译来测试输出，这个程序将用于评判你的输出能够产生多少的神力。\n\n若编译后文件名称为 `scorer`，在终端（Linux）中，输入以下命令：\n\n```plain\n./scorer <input_name> <output_name>\n```\n\n或在命令提示符（Windows）中，输入以下命令：\n```plain\nscorer <input_name> <output_name>\n```\n来对你的输出进行评判。其中 `<input_name>` 为输入文件名称，`<output_name>` 为输出文件名称。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUWC 2017] 大葱的神力", "background": "**本题为提交答案题。**\n\n大葱是我国自古以来的美食，像我国传统美食北京烤鸭，用鸭子点缀出大葱的香味，令人赞不绝口。民间也流传着有「每天一棵葱，不当单身狗」的说法。\n\n然而，大葱要发挥出独属于自己的神力，也是有条件的。", "description": "现在小葱同学有 $N$ 棵大葱和 $M$ 个抽屉，将第 $i$ 棵大葱放到第 $j$ 个抽屉里面会产生 $w_{i,j}$ 的神力。自然小葱同学希望获得尽量多的神力，但是抽屉有着容积的限制，大葱也有着自己的体积。第 $i$ 棵大葱的体积为 $a_i$，第 $j$ 个抽屉的容积为 $b_j$。一个抽屉里面装着的大葱的体积之和不能超过这个抽屉的容积，一棵大葱不能拆分放到两个抽屉中。\n\n小葱同学现在想知道，在这样的条件下，这些大葱最多会产生多少的神力？", "inputFormat": "**本题为提交答案题**，输入文件为 `drawer1.in ~ drawer10.in`，详见附加文件。\n\n第一行两个整数 $N,M$，代表大葱的个数和抽屉的个数。\n\n接下来一行 $N$ 个整数，代表每棵大葱的体积。\n\n接下来一行 $M$ 个整数，代表每个抽屉的容积。\n\n接下来 $N$ 行每行 $M$ 个整数，第 $i$ 行第 $j$ 个数代表第 $i$ 棵大葱放到第 $j$ 个抽屉中会产生的神力。", "outputFormat": "输出文件为 `drawer1.out ~ drawer10.out`，分别对应相应的输入文件。\n\n对于每组输入数据，输出 $N$ 行每行一个整数，第 $i$ 个数代表第 $i$ 棵大葱被放到了哪个抽屉里面。如果第 $i$ 棵大葱没有被放到任何一个抽屉里面，则输出 $0$。", "hint": "#### 样例说明\n\n样例只是一种合法情况，获得的总神力值为 $2+3=5$。\n\n#### 评分方式\n\n**本题使用 Special Judge**，对于每个测试点，我们都有 $10$ 个参数 $a_1,a_2,\\cdots,a_{10}$，如果你的输出所产生的的神力 $v$ 满足 $v \\ge a_i$，则我们保证该测试点你至少会得到 $i$ 分。\n\n#### 如何测试你的输出\n\n在附加文件中，我们提供了 `scorer.cpp`，请自行编译来测试输出，这个程序将用于评判你的输出能够产生多少的神力。\n\n若编译后文件名称为 `scorer`，在终端（Linux）中，输入以下命令：\n\n```plain\n./scorer <input_name> <output_name>\n```\n\n或在命令提示符（Windows）中，输入以下命令：\n```plain\nscorer <input_name> <output_name>\n```\n来对你的输出进行评判。其中 `<input_name>` 为输入文件名称，`<output_name>` 为输出文件名称。", "locale": "zh-CN"}}}
{"pid": "P6850", "type": "P", "difficulty": 1, "samples": [["50 50 72 56 100 40 0 1 446", "AFO"], ["50 95 100 64 100 72 30 0 446", "AKIOI"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["洛谷月赛"], "title": "NOI", "background": "小 L 是一个菜鸡。\n\n啥也不会的小 L 上了 NOI 考场。", "description": "由于小 L 不会算数，现在小 L 告诉了你他每题的分数和队线，请你告诉他是否进队。\n\nNOI 分数的计算方式是：\n\n1. 笔试基础有 $50$ 分，每通过一题加 $1$ 分。\n2. 实际得分是每题的分数加上笔试的分数。\n3. 如果是 A 类，总分在此基础上再加 $5$ 分。\n\n\n", "inputFormat": "输入 $9$ 个数 $a,b,c,d,e,f,g,h,i$，分别表示笔试通过题数, D1T1,D1T2,D1T3,D2T1,D2T2,D2T3 得分，是否 A 类（是 $1$，不是 $0$），集训队分数线。\n", "outputFormat": "输出一行一个字符串。\n\n如果进了集训队，则输出 `AKIOI`。\n\n如果没进，输出 `AFO`。", "hint": "#### 「样例解释」\n\n样例第一个是退役菜鸡小 L 的 NOI2020 成绩。\n\n第二个是某位队爷的 NOI2020 成绩。\n\n~~这不是啥都没解释吗~~\n\n---\n\n#### 「数据范围与说明」\n\n**本题采用捆绑测试**。仅有通过某个 Subtask 中所有测试点才能获得该 Subtask 的分数。\n\n- Subtask 1(30 points)：$h = 0$，$a = 50$，$i = 700$；\n- Subtask 2(30 points)：$h = 0$，$a = 50$；\n- Subtask 3(40 points)：无特殊限制。\n\n对于所有数据，$0\\leq a \\leq 50$，$0\\leq b,c,d,e,f,g \\leq 100$，$0 \\leq h \\leq 1$，$205\\leq i \\leq 705$。\n\n此处不考虑第 $50$ 名同分的情况，可以认为如果同分小 L 优先。\n\n不保证测试数据为真实成绩。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "NOI", "background": "小 L 是一个菜鸡。\n\n啥也不会的小 L 上了 NOI 考场。", "description": "由于小 L 不会算数，现在小 L 告诉了你他每题的分数和队线，请你告诉他是否进队。\n\nNOI 分数的计算方式是：\n\n1. 笔试基础有 $50$ 分，每通过一题加 $1$ 分。\n2. 实际得分是每题的分数加上笔试的分数。\n3. 如果是 A 类，总分在此基础上再加 $5$ 分。\n\n\n", "inputFormat": "输入 $9$ 个数 $a,b,c,d,e,f,g,h,i$，分别表示笔试通过题数, D1T1,D1T2,D1T3,D2T1,D2T2,D2T3 得分，是否 A 类（是 $1$，不是 $0$），集训队分数线。\n", "outputFormat": "输出一行一个字符串。\n\n如果进了集训队，则输出 `AKIOI`。\n\n如果没进，输出 `AFO`。", "hint": "#### 「样例解释」\n\n样例第一个是退役菜鸡小 L 的 NOI2020 成绩。\n\n第二个是某位队爷的 NOI2020 成绩。\n\n~~这不是啥都没解释吗~~\n\n---\n\n#### 「数据范围与说明」\n\n**本题采用捆绑测试**。仅有通过某个 Subtask 中所有测试点才能获得该 Subtask 的分数。\n\n- Subtask 1(30 points)：$h = 0$，$a = 50$，$i = 700$；\n- Subtask 2(30 points)：$h = 0$，$a = 50$；\n- Subtask 3(40 points)：无特殊限制。\n\n对于所有数据，$0\\leq a \\leq 50$，$0\\leq b,c,d,e,f,g \\leq 100$，$0 \\leq h \\leq 1$，$205\\leq i \\leq 705$。\n\n此处不考虑第 $50$ 名同分的情况，可以认为如果同分小 L 优先。\n\n不保证测试数据为真实成绩。", "locale": "zh-CN"}}}
{"pid": "P6851", "type": "P", "difficulty": 3, "samples": [["3 3 1 4\n3 5\n1 2\n2 6\n1 6\n3 5\n1 4", "10\n2\n1\n-1"], ["1 2 1 5\n1 5\n1 8\n1 4", "10\n-1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["Special Judge", "O2优化", "洛谷月赛"], "title": "onu", "background": "小 C 和小 D 是好朋友。他们正在尝试一种全新的牌类游戏——onu！", "description": "为了增加一点趣味性，小 C 和小 D 每人买了 $v$ 颗糖用来当作筹码。\n\nonu 的规则是这样的：\n\n游戏共 $m$ 轮，由两人进行，一位先手，一位后手。在这里，我们默认先手的玩家是小 C，而后手的玩家是小 D。\n\n在最开始时，小 C 会得到 $m$ 张牌，每张牌有其对应的花色、点数。而小 D 会得到 $n$ 张牌。\n\n每一轮开始时，小 C 会打出一张牌，放在桌面上展示给小 D 看。\n\n在此之后，小 D 需要跟牌，即打出他手上的一张牌，且该张牌必须满足其花色与小 C 打出的牌相同。若小 D 没有满足条件的牌或者是他**选择弃权（也就是说，可以选择当前回合是否打出牌）**，弃掉小 C 打出的牌后跳过该轮，视为小 D 败。\n\n在小 D 打出满足要求的牌后，进行一次拼点，也即比较小 C 和小 D 打出的牌的点数：如果小 D 出的牌的点数**大于等于**小 C 的牌的点数，则小 D 胜，否则小 D 败。容易知道，这样不会出现平局的情况。\n\n最后，胜的一方会从败的一方拿走 $c$ 颗糖，且双方均需弃掉打出的牌，并会**再从商店买等于自己打出的牌的点数颗糖**。例如小 C 和小 D 打的点数分别是 $3$ 和 $5$，那么小 C 会去购买 $3$ 颗糖，小 D 购买 $5$ 颗。\n\n为了不破坏两人间的友好关系，不出现一方被另一方完全赢光的情况，他们在最开始买糖时，已经约定好了 $v \\ge c \\times m$。\n\n现在，小 D 通过一些神秘手段，知道了小 C 在这 $m$ 轮中打出的所有牌，他希望在 $m$ 轮游戏进行之后，让自己的糖数尽量多。你可以帮他找到最优的方案吗？", "inputFormat": "第一行四个正整数表示 $n, m, c, v$，含义如题目描述所示。\n\n接下来 $n$ 行中，第 $i$ 行每行两个正整数 $a _i, b _i$，表示了小 D 一开始拥有的第 $i$ 张牌的花色、点数。\n\n接下来 $m$ 行中，第 $i$ 行每行两个正整数 $a _i, b _i$，表示小 C 第 $i$ 轮会打出的牌的花色、点数。\n\n注意可能会有花色点数均相同的牌。", "outputFormat": "输出共 $m + 1$ 行。\n\n第一行输出一个正整数，表示在最优方案中，小 D 最多能剩余的糖数。\n\n接下来 $m$ 行中，第 $i$ 行输出一行一个正整数，表示小 D 在第 $i$ 轮打出的牌的编号。如果小 D 跳过了该轮，输出 `-1`。\n\n**本题采用 Special Judge，如果有多种最优方案，输出任意一个即可。**", "hint": "#### 「样例 1 解释」\n\n以 $(a, b)$ 来表示一张花色为 $a$，点数为 $b$ 的牌。\n\n一开始，小 D 有 $4$ 颗糖。小 C 会依次打出 $(1, 6), (3, 5), (1, 4)$ 三张牌。\n\n一种最优的方案是：\n\n第一轮，小 C 打出第一张牌 $(1, 6)$，小 D 打出第二张牌 $(1, 2)$，小 D 负，被拿走 $1$ 颗糖，购买 $2$ 颗糖。此时其有 $5$ 颗糖。\n\n第二轮，小 C 打出 $(3, 5)$，小 D 打出 $(3, 5)$，由于点数**大于等于**小 C 的牌，所以小 D 胜，拿到 $1$ 颗糖，购买 $5$ 颗糖。此时其有 $11$ 颗糖。\n\n第三轮，小 C 打出 $(1, 4)$。由于小 D 在第一轮已经打出过第二张牌 $(1, 2)$ 了，所以没有牌能打，输出 $-1$ 并判小 D 负，被拿走 $1$ 颗糖，此时其有 $10$ 颗糖。\n\n#### 「样例 2 解释」\n\n最开始有 $5$ 颗糖。\n\n第一轮时小 C 打出 $(1, 8)$，小 D 选择弃权，败，于是剩下了 $5 - 1 = 4$ 颗糖；\n\n第二轮时小 C 打出 $(1, 4)$，小 D 打出 $(1, 5)$，胜，得到 $5 + 1$ 颗糖，故最终小 D 有 $10$ 颗糖。\n\n----\n\n#### 「Special Judge 说明」\n\n**请认真阅读输出格式**。\n\n每个测试点仅有 $0$ 分和满分的区别。如果你的输出出现了以下情况，将会被判为 $0$ 分：\n\n- 输出格式不符，如没有正确换行，输出了一些奇奇怪怪的字符等。\n- 输出的最优糖果数与标准答案不同。\n- 打牌的方案不合法，即不能打出已经弃掉的牌，也不能打出花色与小 C 打出的牌不相同的牌。\n- 按照你所输出的方案打完牌后，小 D 的剩余糖果数与你第一行所输出的数字不同。\n\n---\n\n#### 「数据范围」\n\n**本题采用捆绑测试**。\n\n- Subtask 1(10 points)：$n, m \\le 5$；\n- Subtask 2(30 points)：$n, m \\le 1000$；\n- Subtask 3(20 points)：$c = 0$；\n- Subtask 4(20 points)：$a _i = 1$；\n- Subtask 5(20 points)：无特殊限制。\n\n所有数据保证 $1 \\le n, m, a _i, b _i\\le 10 ^5$，$0 \\le c \\le 10 ^5$，$c \\times m \\le v \\le 10 ^{12}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "onu", "background": "小 C 和小 D 是好朋友。他们正在尝试一种全新的牌类游戏——onu！", "description": "为了增加一点趣味性，小 C 和小 D 每人买了 $v$ 颗糖用来当作筹码。\n\nonu 的规则是这样的：\n\n游戏共 $m$ 轮，由两人进行，一位先手，一位后手。在这里，我们默认先手的玩家是小 C，而后手的玩家是小 D。\n\n在最开始时，小 C 会得到 $m$ 张牌，每张牌有其对应的花色、点数。而小 D 会得到 $n$ 张牌。\n\n每一轮开始时，小 C 会打出一张牌，放在桌面上展示给小 D 看。\n\n在此之后，小 D 需要跟牌，即打出他手上的一张牌，且该张牌必须满足其花色与小 C 打出的牌相同。若小 D 没有满足条件的牌或者是他**选择弃权（也就是说，可以选择当前回合是否打出牌）**，弃掉小 C 打出的牌后跳过该轮，视为小 D 败。\n\n在小 D 打出满足要求的牌后，进行一次拼点，也即比较小 C 和小 D 打出的牌的点数：如果小 D 出的牌的点数**大于等于**小 C 的牌的点数，则小 D 胜，否则小 D 败。容易知道，这样不会出现平局的情况。\n\n最后，胜的一方会从败的一方拿走 $c$ 颗糖，且双方均需弃掉打出的牌，并会**再从商店买等于自己打出的牌的点数颗糖**。例如小 C 和小 D 打的点数分别是 $3$ 和 $5$，那么小 C 会去购买 $3$ 颗糖，小 D 购买 $5$ 颗。\n\n为了不破坏两人间的友好关系，不出现一方被另一方完全赢光的情况，他们在最开始买糖时，已经约定好了 $v \\ge c \\times m$。\n\n现在，小 D 通过一些神秘手段，知道了小 C 在这 $m$ 轮中打出的所有牌，他希望在 $m$ 轮游戏进行之后，让自己的糖数尽量多。你可以帮他找到最优的方案吗？", "inputFormat": "第一行四个正整数表示 $n, m, c, v$，含义如题目描述所示。\n\n接下来 $n$ 行中，第 $i$ 行每行两个正整数 $a _i, b _i$，表示了小 D 一开始拥有的第 $i$ 张牌的花色、点数。\n\n接下来 $m$ 行中，第 $i$ 行每行两个正整数 $a _i, b _i$，表示小 C 第 $i$ 轮会打出的牌的花色、点数。\n\n注意可能会有花色点数均相同的牌。", "outputFormat": "输出共 $m + 1$ 行。\n\n第一行输出一个正整数，表示在最优方案中，小 D 最多能剩余的糖数。\n\n接下来 $m$ 行中，第 $i$ 行输出一行一个正整数，表示小 D 在第 $i$ 轮打出的牌的编号。如果小 D 跳过了该轮，输出 `-1`。\n\n**本题采用 Special Judge，如果有多种最优方案，输出任意一个即可。**", "hint": "#### 「样例 1 解释」\n\n以 $(a, b)$ 来表示一张花色为 $a$，点数为 $b$ 的牌。\n\n一开始，小 D 有 $4$ 颗糖。小 C 会依次打出 $(1, 6), (3, 5), (1, 4)$ 三张牌。\n\n一种最优的方案是：\n\n第一轮，小 C 打出第一张牌 $(1, 6)$，小 D 打出第二张牌 $(1, 2)$，小 D 负，被拿走 $1$ 颗糖，购买 $2$ 颗糖。此时其有 $5$ 颗糖。\n\n第二轮，小 C 打出 $(3, 5)$，小 D 打出 $(3, 5)$，由于点数**大于等于**小 C 的牌，所以小 D 胜，拿到 $1$ 颗糖，购买 $5$ 颗糖。此时其有 $11$ 颗糖。\n\n第三轮，小 C 打出 $(1, 4)$。由于小 D 在第一轮已经打出过第二张牌 $(1, 2)$ 了，所以没有牌能打，输出 $-1$ 并判小 D 负，被拿走 $1$ 颗糖，此时其有 $10$ 颗糖。\n\n#### 「样例 2 解释」\n\n最开始有 $5$ 颗糖。\n\n第一轮时小 C 打出 $(1, 8)$，小 D 选择弃权，败，于是剩下了 $5 - 1 = 4$ 颗糖；\n\n第二轮时小 C 打出 $(1, 4)$，小 D 打出 $(1, 5)$，胜，得到 $5 + 1$ 颗糖，故最终小 D 有 $10$ 颗糖。\n\n----\n\n#### 「Special Judge 说明」\n\n**请认真阅读输出格式**。\n\n每个测试点仅有 $0$ 分和满分的区别。如果你的输出出现了以下情况，将会被判为 $0$ 分：\n\n- 输出格式不符，如没有正确换行，输出了一些奇奇怪怪的字符等。\n- 输出的最优糖果数与标准答案不同。\n- 打牌的方案不合法，即不能打出已经弃掉的牌，也不能打出花色与小 C 打出的牌不相同的牌。\n- 按照你所输出的方案打完牌后，小 D 的剩余糖果数与你第一行所输出的数字不同。\n\n---\n\n#### 「数据范围」\n\n**本题采用捆绑测试**。\n\n- Subtask 1(10 points)：$n, m \\le 5$；\n- Subtask 2(30 points)：$n, m \\le 1000$；\n- Subtask 3(20 points)：$c = 0$；\n- Subtask 4(20 points)：$a _i = 1$；\n- Subtask 5(20 points)：无特殊限制。\n\n所有数据保证 $1 \\le n, m, a _i, b _i\\le 10 ^5$，$0 \\le c \\le 10 ^5$，$c \\times m \\le v \\le 10 ^{12}$。", "locale": "zh-CN"}}}
{"pid": "P6852", "type": "P", "difficulty": 5, "samples": [["3 4\n0 0 0\n0 1 1\n0 2 2\n1 3 3", "3 0 1 2"], ["5 7\n0 1 0\n4 5 0\n1 3 1\n0 5 6\n0 5 6\n2 5 3\n2 3 1", "4 3 5 0 1 2 "]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["Special Judge", "洛谷月赛"], "title": "Mex", "background": "忘掉种过的花/重新的出发/放弃理想吧。", "description": "小 G 曾经有一个 $0$ 到 $n$ 的排列（下标从 $0$ 开始），但他忘记了这个排列。\n\n现在他想把这个排列找回来，他努力地回想，只能回想起关于这个排列的 $m$ 条信息，每条信息形如 $(l,r,val)$，表示区间 $[l,r]$ 的 ${\\rm mex}$ 值为 $val$。一个区间的 ${\\rm mex}$ 值是最小的没有在这个区间中出现的自然数。\n\n小 G 把 $n$ 和这 $m$ 条信息告诉了你，希望你能帮他还原出一个排列，或者告诉他他的回忆出现了问题。\n\n", "inputFormat": "第一行两个整数 $n$ 和 $m$，含义见上。\n\n随后 $m$ 行每行三个整数 $l,r,val$ 描述一条信息，表示区间 $[l,r]$ 的 ${\\rm mex}$ 值为 $val$。", "outputFormat": "如果不存在满足所有条件的排列，输出 $-1$。\n\n否则输出一行 $n+1$ 个正整数，表示一个 $0$ 到 $n$ 的排列。\n\n**本题采用 Special Judge**。如果满足条件的排列有多个，你可以输出任意一个。", "hint": "**本题采用捆绑测试**。你只有通过 subtask 中的所有测试点才能获得该 subtask 的分数。\n\n- Subtask 1(15 points)：$n,m\\le 10$；\n- Subtask 2(20 points)：$n,m\\le 20$；\n- Subtask 3(10 points)：$val=0$；\n- Subtask 4(15 points)：数据随机生成；\n- Subtask 5(10 points)：$n\\le 10^5$；\n- Subtask 6(30 points)：无特殊限制。\n\n对于所有的数据满足：$1 \\le n,m\\le 5\\times 10^5$，$ 0\\le l,r\\le n$，$0\\le val\\le n+1$。\n\nSubtask4 的数据生成方式为：随机生成一个排列，再随机 $m$ 个区间求出它们的 ${\\rm mex}$ 值作为条件。\n\n本题输入输出量较大，请注意使用效率较高的 IO 方式。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Mex", "background": "忘掉种过的花/重新的出发/放弃理想吧。", "description": "小 G 曾经有一个 $0$ 到 $n$ 的排列（下标从 $0$ 开始），但他忘记了这个排列。\n\n现在他想把这个排列找回来，他努力地回想，只能回想起关于这个排列的 $m$ 条信息，每条信息形如 $(l,r,val)$，表示区间 $[l,r]$ 的 ${\\rm mex}$ 值为 $val$。一个区间的 ${\\rm mex}$ 值是最小的没有在这个区间中出现的自然数。\n\n小 G 把 $n$ 和这 $m$ 条信息告诉了你，希望你能帮他还原出一个排列，或者告诉他他的回忆出现了问题。\n\n", "inputFormat": "第一行两个整数 $n$ 和 $m$，含义见上。\n\n随后 $m$ 行每行三个整数 $l,r,val$ 描述一条信息，表示区间 $[l,r]$ 的 ${\\rm mex}$ 值为 $val$。", "outputFormat": "如果不存在满足所有条件的排列，输出 $-1$。\n\n否则输出一行 $n+1$ 个正整数，表示一个 $0$ 到 $n$ 的排列。\n\n**本题采用 Special Judge**。如果满足条件的排列有多个，你可以输出任意一个。", "hint": "**本题采用捆绑测试**。你只有通过 subtask 中的所有测试点才能获得该 subtask 的分数。\n\n- Subtask 1(15 points)：$n,m\\le 10$；\n- Subtask 2(20 points)：$n,m\\le 20$；\n- Subtask 3(10 points)：$val=0$；\n- Subtask 4(15 points)：数据随机生成；\n- Subtask 5(10 points)：$n\\le 10^5$；\n- Subtask 6(30 points)：无特殊限制。\n\n对于所有的数据满足：$1 \\le n,m\\le 5\\times 10^5$，$ 0\\le l,r\\le n$，$0\\le val\\le n+1$。\n\nSubtask4 的数据生成方式为：随机生成一个排列，再随机 $m$ 个区间求出它们的 ${\\rm mex}$ 值作为条件。\n\n本题输入输出量较大，请注意使用效率较高的 IO 方式。", "locale": "zh-CN"}}}
{"pid": "P6853", "type": "P", "difficulty": 5, "samples": [["4", "4\n2 1 2\n2 2 4\n2 2 3\n3 1 3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["Special Judge", "O2优化", "洛谷月赛"], "title": "station", "background": "", "description": "你需要规划一个城市的公交路线。\n\n总共有 $n$ 条路线和 $m$ 个车站，编号均从 $1$ 开始。\n\n你的主要任务是，规划每一条路线应该经过哪些车站。换言之，你要任意选择一个车站的子集，让这条路线经过这个子集中的所有车站。\n\n定义两条路线是**关联**的，当且仅当它们经过了同一个车站，也就是它们的经过车站集合有交。\n\n一个路线方案必须满足如下限制：\n\n1. 一条线路不可能只通过一个车站，所以**每条线路至少要经过两个车站**；\n\n2. 一个车站的运载能力是有限的，所以**一个车站最多只能被三条线路经过**。\n\n3. 为了保证交通顺畅，对于任意两条不同线路 $i, j(i \\not = j)$，都存在第三条线路 $k (k \\not = i, k \\not = j)$，使得 $k$ 与 $i, j$ 均**关联**。\n\n现给定 $n$，请求出一个最小的 $m$ 和具体规划方案。", "inputFormat": "一行一个正整数 $n$，含义如题目所示。", "outputFormat": "第一行输出一个正整数 $m$，表示在你的规划方案中所用车站的数量。\n\n接下来 $n$ 行中，第 $i$ 行输出一个正整数 $c$ 和若干个正整数 $a _1, a _2, \\cdots, a _c$，表示在你的方案中第 $i$ 条路线经过的车站数目以及经过车站的编号。", "hint": "#### 「样例 1 解释」\n\n如图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/shh1iy56.png)\n\n首先易知其满足题目描述中所给定的一、二条件。下面考虑三条件。\n\n先考虑 $1, 2, 4$ 号线，可以发现这三条线路构成了一个三角形，任意两个线路均有剩下的一条线路与它们**关联**；\n\n再对 $3$ 号线与 $1, 2, 4$ 号线分别考虑，容易验证满足对于任意 $x \\in \\{1, 2, 4\\}$，均有另一条线路 $y \\in \\{1, 2, 4\\}, y \\not = x$ 与 $3, x$ 同时**关联**，满足题目条件。\n\n---\n\n#### 「Special Judge 说明与评分细则」\n\n**请认真阅读输出格式**。\n\n如果你的输出出现了如下情况，将会被判为 $0$ 分：\n\n- 输出格式不符。如没有正确换行，输出了一些奇奇怪怪的字符，未输出车站个数等。\n- 某一条线路经过了相同的车站，或者有某一个车站的编号不在 $[1, m]$ 内。\n- 没有满足题目描述中所给定的三条限制。\n- 输出文件大小过大或者是 $m$ 过大。如果你的 $m$ 大于 $10 ^6$ 将直接判为 $0$ 分。输出文件过大将导致 TLE 或 OLE，建议将输出文件大小控制在 25Mb 以内。\n\n在没有被判为 $0$ 分的基础上，将会根据你输出的 $m$ 的大小进行判分。\n\n每个测试点评测时会有 $10$ 个评测参数 $w _1, w _2, \\cdots, w _{10}$，若你输出的 $m$ 小于等于其中 $k$ 个参数，那么你将得到该测试点 $k \\times 10\\%$ 的分数。\n\n这 $10$ 个参数是对外不可见的，也即你的程序在运行时无法获知这些评测参数。\n\n---\n\n#### 「数据范围」\n\n**本题采用捆绑测试**。你在某个 subtask 的得分为在**该 subtask 的所有测试点中的最小得分**。\n\n- Subtask 1(20 points)：$n \\le 10$。此处我们保证 $10$ 个评分参数均为 $10 ^6$。\n- Subtask 2(40 points)：$n \\le 200$。\n- Subtask 3(40 points)：无特殊限制。\n\n对于所有数据，均满足 $3 \\le n \\le 4 \\times 10 ^3$，且 $ans + 5 \\le w _1 \\le w _2 \\le \\cdots \\le w _{10} = 10 ^6$，其中 $ans$ 表示标准答案。\n\n请注意此处的 $w _{10} = 10^6$ 的条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "station", "background": "", "description": "你需要规划一个城市的公交路线。\n\n总共有 $n$ 条路线和 $m$ 个车站，编号均从 $1$ 开始。\n\n你的主要任务是，规划每一条路线应该经过哪些车站。换言之，你要任意选择一个车站的子集，让这条路线经过这个子集中的所有车站。\n\n定义两条路线是**关联**的，当且仅当它们经过了同一个车站，也就是它们的经过车站集合有交。\n\n一个路线方案必须满足如下限制：\n\n1. 一条线路不可能只通过一个车站，所以**每条线路至少要经过两个车站**；\n\n2. 一个车站的运载能力是有限的，所以**一个车站最多只能被三条线路经过**。\n\n3. 为了保证交通顺畅，对于任意两条不同线路 $i, j(i \\not = j)$，都存在第三条线路 $k (k \\not = i, k \\not = j)$，使得 $k$ 与 $i, j$ 均**关联**。\n\n现给定 $n$，请求出一个最小的 $m$ 和具体规划方案。", "inputFormat": "一行一个正整数 $n$，含义如题目所示。", "outputFormat": "第一行输出一个正整数 $m$，表示在你的规划方案中所用车站的数量。\n\n接下来 $n$ 行中，第 $i$ 行输出一个正整数 $c$ 和若干个正整数 $a _1, a _2, \\cdots, a _c$，表示在你的方案中第 $i$ 条路线经过的车站数目以及经过车站的编号。", "hint": "#### 「样例 1 解释」\n\n如图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/shh1iy56.png)\n\n首先易知其满足题目描述中所给定的一、二条件。下面考虑三条件。\n\n先考虑 $1, 2, 4$ 号线，可以发现这三条线路构成了一个三角形，任意两个线路均有剩下的一条线路与它们**关联**；\n\n再对 $3$ 号线与 $1, 2, 4$ 号线分别考虑，容易验证满足对于任意 $x \\in \\{1, 2, 4\\}$，均有另一条线路 $y \\in \\{1, 2, 4\\}, y \\not = x$ 与 $3, x$ 同时**关联**，满足题目条件。\n\n---\n\n#### 「Special Judge 说明与评分细则」\n\n**请认真阅读输出格式**。\n\n如果你的输出出现了如下情况，将会被判为 $0$ 分：\n\n- 输出格式不符。如没有正确换行，输出了一些奇奇怪怪的字符，未输出车站个数等。\n- 某一条线路经过了相同的车站，或者有某一个车站的编号不在 $[1, m]$ 内。\n- 没有满足题目描述中所给定的三条限制。\n- 输出文件大小过大或者是 $m$ 过大。如果你的 $m$ 大于 $10 ^6$ 将直接判为 $0$ 分。输出文件过大将导致 TLE 或 OLE，建议将输出文件大小控制在 25Mb 以内。\n\n在没有被判为 $0$ 分的基础上，将会根据你输出的 $m$ 的大小进行判分。\n\n每个测试点评测时会有 $10$ 个评测参数 $w _1, w _2, \\cdots, w _{10}$，若你输出的 $m$ 小于等于其中 $k$ 个参数，那么你将得到该测试点 $k \\times 10\\%$ 的分数。\n\n这 $10$ 个参数是对外不可见的，也即你的程序在运行时无法获知这些评测参数。\n\n---\n\n#### 「数据范围」\n\n**本题采用捆绑测试**。你在某个 subtask 的得分为在**该 subtask 的所有测试点中的最小得分**。\n\n- Subtask 1(20 points)：$n \\le 10$。此处我们保证 $10$ 个评分参数均为 $10 ^6$。\n- Subtask 2(40 points)：$n \\le 200$。\n- Subtask 3(40 points)：无特殊限制。\n\n对于所有数据，均满足 $3 \\le n \\le 4 \\times 10 ^3$，且 $ans + 5 \\le w _1 \\le w _2 \\le \\cdots \\le w _{10} = 10 ^6$，其中 $ans$ 表示标准答案。\n\n请注意此处的 $w _{10} = 10^6$ 的条件。", "locale": "zh-CN"}}}
{"pid": "P6854", "type": "P", "difficulty": 6, "samples": [["10\n2 2 1 1 2 2 3 1 3 3 ", "8"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["线段树", "洛谷月赛"], "title": "Tram", "background": "电车开了，他的声音在我的脑海中萦绕不散：\n\n「留下来，跟我来。」\n\n我回头去看车站，他不见了。\n\n我在德辅道寻找他的身影。\n\n路人不多，但他却消失了。\n\n我把窗拉下来，微风轻拂我的脸。\n\n他到哪儿去了？\n\n路人、街道、高楼大厦。\n\n在我身边轻轻地流走。\n\n", "description": "你就要出道了！\n\n你的教练和同学为你联系了摄影师，你们来到德辅道边拍宣传照。\n\n街上一共有 $n$ 幢楼房，从左到右排成一列，从 $1$ 到 $n$ 编号，编号为 $i$ 的楼房的高度是 $a_i$。\n\n一张照片可以用二元组 $(l,r)$ 描述，其中 $1\\le l\\le r\\le n$，这张照片中包含了编号在 $[l,r]$ 之间的所有楼房。\n\n摄影师认为，一张照片是美丽的，当且仅当其同时满足下面的两个条件：\n\n- 对于任意的 $i<j<k$，如果高度为 $i$ 和 $k$ 的楼房都在照片中出现过，那么高度为 $j$ 的楼房也在照片中出现过。\n- 对于任意的 $i$，高度为 $i$ 的楼房要么不出现在照片中，要么在照片中出现恰好 $i$ 次。\n\n摄像师问你，一共能拍出多少不同的美丽的照片呢？\n\n两张照片 $(l_1,r_1)$ 和 $(l_2,r_2)$ 不同，当且仅当 $l_1\\ne l_2$ 或 $r_1\\ne r_2$。", "inputFormat": "第一行一个正整数 $n$，表示楼房数量。\n\n随后一行 $n$ 个正整数，第 $i$ 个为编号为 $i$ 的楼房的高度。", "outputFormat": "输出一行一个整数表示能拍出的不同的美丽的照片数量。", "hint": "**本题采用捆绑测试**。你只有通过 subtask 中的所有测试点才能获得该 subtask 的分数。\n\n- Subtask 1(10 points)：$n\\le 200$；\n- Subtask 2(5 points)：$n\\le 1000$；\n- Subtask 3(10 points)：$n\\le 6000$；\n- Subtask 4(20 points)：$n\\le 3\\times 10^4$；\n- Subtask 5(30 points)：$n\\le 10^5$；\n- Subtask 6(25 points)：$n\\le 10^6$。\n\n\n对于所有数据满足：$1\\le n,a_i\\le 10^6$。\n\n注意答案的大小可能超过 $32$ 位有符号整数的范围。\n\n本题输入数据量较大，请使用较快的读入方式。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Tram", "background": "电车开了，他的声音在我的脑海中萦绕不散：\n\n「留下来，跟我来。」\n\n我回头去看车站，他不见了。\n\n我在德辅道寻找他的身影。\n\n路人不多，但他却消失了。\n\n我把窗拉下来，微风轻拂我的脸。\n\n他到哪儿去了？\n\n路人、街道、高楼大厦。\n\n在我身边轻轻地流走。\n\n", "description": "你就要出道了！\n\n你的教练和同学为你联系了摄影师，你们来到德辅道边拍宣传照。\n\n街上一共有 $n$ 幢楼房，从左到右排成一列，从 $1$ 到 $n$ 编号，编号为 $i$ 的楼房的高度是 $a_i$。\n\n一张照片可以用二元组 $(l,r)$ 描述，其中 $1\\le l\\le r\\le n$，这张照片中包含了编号在 $[l,r]$ 之间的所有楼房。\n\n摄影师认为，一张照片是美丽的，当且仅当其同时满足下面的两个条件：\n\n- 对于任意的 $i<j<k$，如果高度为 $i$ 和 $k$ 的楼房都在照片中出现过，那么高度为 $j$ 的楼房也在照片中出现过。\n- 对于任意的 $i$，高度为 $i$ 的楼房要么不出现在照片中，要么在照片中出现恰好 $i$ 次。\n\n摄像师问你，一共能拍出多少不同的美丽的照片呢？\n\n两张照片 $(l_1,r_1)$ 和 $(l_2,r_2)$ 不同，当且仅当 $l_1\\ne l_2$ 或 $r_1\\ne r_2$。", "inputFormat": "第一行一个正整数 $n$，表示楼房数量。\n\n随后一行 $n$ 个正整数，第 $i$ 个为编号为 $i$ 的楼房的高度。", "outputFormat": "输出一行一个整数表示能拍出的不同的美丽的照片数量。", "hint": "**本题采用捆绑测试**。你只有通过 subtask 中的所有测试点才能获得该 subtask 的分数。\n\n- Subtask 1(10 points)：$n\\le 200$；\n- Subtask 2(5 points)：$n\\le 1000$；\n- Subtask 3(10 points)：$n\\le 6000$；\n- Subtask 4(20 points)：$n\\le 3\\times 10^4$；\n- Subtask 5(30 points)：$n\\le 10^5$；\n- Subtask 6(25 points)：$n\\le 10^6$。\n\n\n对于所有数据满足：$1\\le n,a_i\\le 10^6$。\n\n注意答案的大小可能超过 $32$ 位有符号整数的范围。\n\n本题输入数据量较大，请使用较快的读入方式。", "locale": "zh-CN"}}}
{"pid": "P6855", "type": "P", "difficulty": 5, "samples": [["2 2\n3 3 \n6 4", "9"], ["3 3\n1 1 1\n2 1 2\n3 1 1", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP"], "title": "「EZEC-4.5」走方格", "background": "", "description": "有 $n\\times m$ 的方格矩阵，小 A 从 $(1,1)$ 出发到 $(n,m)$ ，只能向下或向右走，获得的分数为他经过方格的权值之和。\n\n已知每个方格 $(i,j) $的权值 $a_{i,j}$，你可以将其中任意一个方格上的权值变为 $0$，求变化后小 A 最多能获得分数的**最小值**。", "inputFormat": "第一行两个整数 $n,m$。\n\n下面 $n$ 行每行 $m$ 个整数 $a_{i,j}$", "outputFormat": "一个整数表示变化后小 A 最多能获得分数的**最小值**。", "hint": "[大样例](https://www.luogu.com.cn/paste/aeqswjyj)\n\n### 本题使用捆绑测试。\n\n### 【样例解释】：\n\n样例1： 将 $(2,2)$ 的权值变为 $0$，路径为 $(1,1) $ -> $(2,1) $ ->$(2,2)$ ，获得分数为 $3+6+0=9$。\n\n样例2： 将 $(2,1)$ 的权值变成 $0$，路径为 $(1,1) $ -> $(2,1) $ ->$(3,1)$  ->$(3,2)$  ->$(3,3)$ ，获得分数为 $1+0+3+1+1=6$。\n\n### 【数据范围】：\n\n$Subtask1(40分):1\\le n,m \\le 100$。\n\n$Subtask2(30分):1\\le n,m \\le 500$。\n\n$Subtask3(30分):1\\le n,m \\le 2 \\times 10^3$。\n\n对于 $100\\%$ 的数据：$1\\le n,m\\le 2\\times 10^3,1\\le a_{i,j} \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「EZEC-4.5」走方格", "background": "", "description": "有 $n\\times m$ 的方格矩阵，小 A 从 $(1,1)$ 出发到 $(n,m)$ ，只能向下或向右走，获得的分数为他经过方格的权值之和。\n\n已知每个方格 $(i,j) $的权值 $a_{i,j}$，你可以将其中任意一个方格上的权值变为 $0$，求变化后小 A 最多能获得分数的**最小值**。", "inputFormat": "第一行两个整数 $n,m$。\n\n下面 $n$ 行每行 $m$ 个整数 $a_{i,j}$", "outputFormat": "一个整数表示变化后小 A 最多能获得分数的**最小值**。", "hint": "[大样例](https://www.luogu.com.cn/paste/aeqswjyj)\n\n### 本题使用捆绑测试。\n\n### 【样例解释】：\n\n样例1： 将 $(2,2)$ 的权值变为 $0$，路径为 $(1,1) $ -> $(2,1) $ ->$(2,2)$ ，获得分数为 $3+6+0=9$。\n\n样例2： 将 $(2,1)$ 的权值变成 $0$，路径为 $(1,1) $ -> $(2,1) $ ->$(3,1)$  ->$(3,2)$  ->$(3,3)$ ，获得分数为 $1+0+3+1+1=6$。\n\n### 【数据范围】：\n\n$Subtask1(40分):1\\le n,m \\le 100$。\n\n$Subtask2(30分):1\\le n,m \\le 500$。\n\n$Subtask3(30分):1\\le n,m \\le 2 \\times 10^3$。\n\n对于 $100\\%$ 的数据：$1\\le n,m\\le 2\\times 10^3,1\\le a_{i,j} \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P6856", "type": "P", "difficulty": 5, "samples": [["4 1 1000000007\n1 2 3 4", "150"], ["3 2 114\n2 3 4", "65"], ["12 8 10042020\n1 1 4 5 1 4 1 9 1 9 8 10", "2797740"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["递推", "线段树", "分块"], "title": "「EZEC-4.5」子序列", "background": "作为唯一一道有背景的题，此题由出题人基于 @[Ecrade_](https://www.luogu.com.cn/user/322075) 的原创题“子集”拓展而来。\n\n“子集”便是本题中 $k=n-1$ 的情况。", "description": "给定一个有 $n$ 个元素的序列 $a$。\n\n定义一个有 $x$ 个元素的序列 $s$ 的值为：\n$$\\sum \\limits _{i=1} ^ x s_i \\times \\prod \\limits _{i=1} ^ x s_i $$\n\n将序列 $a$ 的一个有 $x$ 个元素的子序列表示为 $s = \\{a_{p_1},a_{p_2},...,a_{p_x}\\}$，其中 $p$ 为严格单调递增的序列，$1 \\le p_1 \\le p_x \\le n$ 。\n\n给定整数 $k$，定义序列 $a$ 的一个有 $x$ 个元素的合法的子序列 $s$ 需满足 $p_x - p_1 \\le k$。\n\n求序列 $a$ 的所有合法子序列的值之和对 $mod$ 取模的值。 ", "inputFormat": "第一行三个整数，$n,k,mod$ 。 \n\n第二行 $n$ 个整数，$a_i$。 ", "outputFormat": "一行一个整数表示答案对 $mod$ 取模的值。 ", "hint": "[大样例](https://www.luogu.com.cn/paste/5sg4ahwn)\n\n### 【样例解释】：\n\n样例1：\n\n- 所有合法的子序列为 $\\{1\\}，\\{2\\}，\\{3\\}，\\{4\\}，\\{1,2\\}，\\{2,3\\}，\\{3,4\\}$ \n\n- 答案为 $1 \\times 1 + 2 \\times 2 + 3 \\times 3 + 4 \\times 4 + (1+2) \\times 1 \\times 2 + (2+3) \\times 2 \\times 3 + (3+4) \\times 3 \\times 4 = 150$\n\n\n样例2：\n\n- 所有合法的子序列为 $\\{2\\},\\{3\\},\\{4\\},\\{2,3\\},\\{3,4\\},\\{2,4\\},\\{2,3,4\\}$， 答案为 $ 407 \\mod 114 = 65 $。  \n\n\n\n### 【数据范围】：\n\n| 数据点编号 | $ n\\le$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n|$1\\sim 4$ |$20$  |无 |\n|$5\\sim 11$ |$10^3$  |无|\n|$12$ |$10^6$  |$k=0$  |\n|$13\\sim 14$ |$10^5$  |$a_i=1$|\n|$15\\sim 17$ |$10^5$  |$mod=10^9+7$|\n|$18\\sim 22$ |$10^5$  |无|\n|$23\\sim 25$ |$10^6$  |无 |\n\n- 对于 $100\\%$ 的数据，$0 \\le k < n \\le 10^6 , 1 \\le a_i \\le 10^9 , 1 \\le mod \\le 10^9+7$ ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「EZEC-4.5」子序列", "background": "作为唯一一道有背景的题，此题由出题人基于 @[Ecrade_](https://www.luogu.com.cn/user/322075) 的原创题“子集”拓展而来。\n\n“子集”便是本题中 $k=n-1$ 的情况。", "description": "给定一个有 $n$ 个元素的序列 $a$。\n\n定义一个有 $x$ 个元素的序列 $s$ 的值为：\n$$\\sum \\limits _{i=1} ^ x s_i \\times \\prod \\limits _{i=1} ^ x s_i $$\n\n将序列 $a$ 的一个有 $x$ 个元素的子序列表示为 $s = \\{a_{p_1},a_{p_2},...,a_{p_x}\\}$，其中 $p$ 为严格单调递增的序列，$1 \\le p_1 \\le p_x \\le n$ 。\n\n给定整数 $k$，定义序列 $a$ 的一个有 $x$ 个元素的合法的子序列 $s$ 需满足 $p_x - p_1 \\le k$。\n\n求序列 $a$ 的所有合法子序列的值之和对 $mod$ 取模的值。 ", "inputFormat": "第一行三个整数，$n,k,mod$ 。 \n\n第二行 $n$ 个整数，$a_i$。 ", "outputFormat": "一行一个整数表示答案对 $mod$ 取模的值。 ", "hint": "[大样例](https://www.luogu.com.cn/paste/5sg4ahwn)\n\n### 【样例解释】：\n\n样例1：\n\n- 所有合法的子序列为 $\\{1\\}，\\{2\\}，\\{3\\}，\\{4\\}，\\{1,2\\}，\\{2,3\\}，\\{3,4\\}$ \n\n- 答案为 $1 \\times 1 + 2 \\times 2 + 3 \\times 3 + 4 \\times 4 + (1+2) \\times 1 \\times 2 + (2+3) \\times 2 \\times 3 + (3+4) \\times 3 \\times 4 = 150$\n\n\n样例2：\n\n- 所有合法的子序列为 $\\{2\\},\\{3\\},\\{4\\},\\{2,3\\},\\{3,4\\},\\{2,4\\},\\{2,3,4\\}$， 答案为 $ 407 \\mod 114 = 65 $。  \n\n\n\n### 【数据范围】：\n\n| 数据点编号 | $ n\\le$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n|$1\\sim 4$ |$20$  |无 |\n|$5\\sim 11$ |$10^3$  |无|\n|$12$ |$10^6$  |$k=0$  |\n|$13\\sim 14$ |$10^5$  |$a_i=1$|\n|$15\\sim 17$ |$10^5$  |$mod=10^9+7$|\n|$18\\sim 22$ |$10^5$  |无|\n|$23\\sim 25$ |$10^6$  |无 |\n\n- 对于 $100\\%$ 的数据，$0 \\le k < n \\le 10^6 , 1 \\le a_i \\le 10^9 , 1 \\le mod \\le 10^9+7$ ", "locale": "zh-CN"}}}
{"pid": "P6857", "type": "P", "difficulty": 2, "samples": [["1\n3", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["洛谷月赛"], "title": "梦中梦与不再有梦", "background": "Amazing John 做了一个梦，梦到他做了很多梦。\n\n记得最好的梦，是不再有梦。", "description": "Amazing John 想要以自己的梦出一道题。\n\nAmazing John 做了 $n$ 个梦。每两个梦之间都有且仅有一条桥梁直接相连，不会有桥梁从一个梦连向自身。\n\n通过桥梁 $e_{u,v}$ 可以从梦 $u$ 到达 梦 $v$ 或从 $v$ 到达 $u$ ，并且获得 $1$ 点休息值。\n\n对于每个桥梁 $e_{u,v}$ ，它只能被经过一次，无论是正向经过还是反向经过。\n\n当到达一个梦且与它相连的所有桥梁都不能经过时， Amazing John 就会结束他的做梦。\n\n现在 Amazing John 很困，他想知道从任意一个梦出发，最多可以获得多少休息值？", "inputFormat": "**本题有多组数据。**\n\n第一行包含一个正整数 $T$ ，表示有 $T$ 组数据。\n\n接下来有 $T$ 行，每行包含一个正整数 $n$ ，表示他做了 $n$ 个梦。", "outputFormat": "输出共 $T$ 行。\n\n对于每组数据，输出一行一个正整数 $ans$ ，表示最多可以获得的休息值。", "hint": "样例解释：\n\n从 $1$ 出发，沿 $e_{1,2}$ 到达 $2$ ，再沿 $e_{2,3}$ 到达 $3$ ，最后沿 $e_{3,1}$ 到达 $1$。\n\n总共获得了 $3$ 点休息值。\n\n|子任务|数据点|数据范围|分数|\n-|-|-|-|\n|$1$|$1\\sim2$|$n≤6,T=3$|$30$|\n|$2$|$3\\sim5$|$n≤10^9,T≤10^5$|$70$|\n\n对于一个子任务，你能获得它的分数当且仅当你通过了其中所有的数据点。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "梦中梦与不再有梦", "background": "Amazing John 做了一个梦，梦到他做了很多梦。\n\n记得最好的梦，是不再有梦。", "description": "Amazing John 想要以自己的梦出一道题。\n\nAmazing John 做了 $n$ 个梦。每两个梦之间都有且仅有一条桥梁直接相连，不会有桥梁从一个梦连向自身。\n\n通过桥梁 $e_{u,v}$ 可以从梦 $u$ 到达 梦 $v$ 或从 $v$ 到达 $u$ ，并且获得 $1$ 点休息值。\n\n对于每个桥梁 $e_{u,v}$ ，它只能被经过一次，无论是正向经过还是反向经过。\n\n当到达一个梦且与它相连的所有桥梁都不能经过时， Amazing John 就会结束他的做梦。\n\n现在 Amazing John 很困，他想知道从任意一个梦出发，最多可以获得多少休息值？", "inputFormat": "**本题有多组数据。**\n\n第一行包含一个正整数 $T$ ，表示有 $T$ 组数据。\n\n接下来有 $T$ 行，每行包含一个正整数 $n$ ，表示他做了 $n$ 个梦。", "outputFormat": "输出共 $T$ 行。\n\n对于每组数据，输出一行一个正整数 $ans$ ，表示最多可以获得的休息值。", "hint": "样例解释：\n\n从 $1$ 出发，沿 $e_{1,2}$ 到达 $2$ ，再沿 $e_{2,3}$ 到达 $3$ ，最后沿 $e_{3,1}$ 到达 $1$。\n\n总共获得了 $3$ 点休息值。\n\n|子任务|数据点|数据范围|分数|\n-|-|-|-|\n|$1$|$1\\sim2$|$n≤6,T=3$|$30$|\n|$2$|$3\\sim5$|$n≤10^9,T≤10^5$|$70$|\n\n对于一个子任务，你能获得它的分数当且仅当你通过了其中所有的数据点。", "locale": "zh-CN"}}}
{"pid": "P6858", "type": "P", "difficulty": 5, "samples": [["2 1", "8"], ["10 10", "499122389"], ["10 0", "65"], ["2 0", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["洛谷月赛"], "title": "深海少女与胖头鱼", "background": "Amazing John 做了一个梦，梦到他上上辈子是个少女。\n\n她跳入了 OI ~~炉石~~ 的海洋，成为了[深海少女](https://music.163.com/#/song?id=22677451)，维护着海洋的秩序。\n\n某一天，海洋遭到了胖头鱼群的入侵。为了维护深海的安全，Amazing John 带着大佬们与胖头鱼们战斗了 $9$ 天 $9$ 夜，但是鱼的数量并没减少。\n\n![FGNB](https://cdn.luogu.com.cn/upload/image_hosting/7r0sort3.png)\n", "description": "经过漫长的战斗，Amazing John 发现了战胜胖头鱼的方法：\n\n总共有 $n$ 条带 「圣盾」的「胖头鱼」和 $m$ 条不带圣盾的胖头鱼，每次等概率对一条存活的胖头鱼造成「剧毒」伤害。\n\n现在 Amazing John 想知道，期望造成多少次伤害可以杀死全部胖头鱼？\n\n答案对 $998244353$ 取模。\n\n「圣盾」：当拥有圣盾的胖头鱼受到伤害时，免疫这条鱼所受到的本次伤害。免疫伤害后，圣盾被破坏。\n\n「胖头鱼」：在一条胖头鱼的圣盾被破坏后，给予其他所有没有死亡且没有圣盾的胖头鱼圣盾。\n\n「剧毒」：立即杀死没有圣盾的胖头鱼。\n\n", "inputFormat": "输入共一行，包含两个非负整数 $n,m$，表示有 $n$ 条带圣盾的胖头鱼，有 $m$ 条不带圣盾的胖头鱼。", "outputFormat": "输出共一行，一个非负整数 $s$，表示期望造成伤害次数对 $998244353$ 取模的值。\n\n具体的，答案必然可以表示成 $\\frac{p}{q}(p,q\\in \\mathbb{N},q\\neq 0)$ 的形式，而你需要输出 $p×q^{-1}$ 在模 $998244353$ 意义下的值。", "hint": "本题共有 $20$ 个数据点，数据点从 $1$ 到 $20$ 编号。对于一个子任务，只有通过其中所有数据点才能获得该子任务的分数。\n|子任务|数据点|数据范围|分数|\n-|-|-|-|\n|$1$|$1\\sim3$|$n,m \\le 5 \\times 10^3$|$15$|\n|$2$|$4\\sim5$|$n \\le 10^6$，$m=0$|$10$|\n|$3$|$6\\sim10$|$n,m \\le 10^6$|$25$|\n|$4$|$11\\sim14$|$n \\le 10^{14}$，$m=0$|$20$|\n|$5$|$15\\sim20$|$n \\le 10^{14}$，$m\\le 10^6$|$30$|\n\n答案的形式 $\\frac{p}{q}$ 必然满足 $(p,q\\in \\mathbb{N},998244353\\nmid q)$\n\n~~我会暗中支持你的，可别告诉别人——鲍勃。~~\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "深海少女与胖头鱼", "background": "Amazing John 做了一个梦，梦到他上上辈子是个少女。\n\n她跳入了 OI ~~炉石~~ 的海洋，成为了[深海少女](https://music.163.com/#/song?id=22677451)，维护着海洋的秩序。\n\n某一天，海洋遭到了胖头鱼群的入侵。为了维护深海的安全，Amazing John 带着大佬们与胖头鱼们战斗了 $9$ 天 $9$ 夜，但是鱼的数量并没减少。\n\n![FGNB](https://cdn.luogu.com.cn/upload/image_hosting/7r0sort3.png)\n", "description": "经过漫长的战斗，Amazing John 发现了战胜胖头鱼的方法：\n\n总共有 $n$ 条带 「圣盾」的「胖头鱼」和 $m$ 条不带圣盾的胖头鱼，每次等概率对一条存活的胖头鱼造成「剧毒」伤害。\n\n现在 Amazing John 想知道，期望造成多少次伤害可以杀死全部胖头鱼？\n\n答案对 $998244353$ 取模。\n\n「圣盾」：当拥有圣盾的胖头鱼受到伤害时，免疫这条鱼所受到的本次伤害。免疫伤害后，圣盾被破坏。\n\n「胖头鱼」：在一条胖头鱼的圣盾被破坏后，给予其他所有没有死亡且没有圣盾的胖头鱼圣盾。\n\n「剧毒」：立即杀死没有圣盾的胖头鱼。\n\n", "inputFormat": "输入共一行，包含两个非负整数 $n,m$，表示有 $n$ 条带圣盾的胖头鱼，有 $m$ 条不带圣盾的胖头鱼。", "outputFormat": "输出共一行，一个非负整数 $s$，表示期望造成伤害次数对 $998244353$ 取模的值。\n\n具体的，答案必然可以表示成 $\\frac{p}{q}(p,q\\in \\mathbb{N},q\\neq 0)$ 的形式，而你需要输出 $p×q^{-1}$ 在模 $998244353$ 意义下的值。", "hint": "本题共有 $20$ 个数据点，数据点从 $1$ 到 $20$ 编号。对于一个子任务，只有通过其中所有数据点才能获得该子任务的分数。\n|子任务|数据点|数据范围|分数|\n-|-|-|-|\n|$1$|$1\\sim3$|$n,m \\le 5 \\times 10^3$|$15$|\n|$2$|$4\\sim5$|$n \\le 10^6$，$m=0$|$10$|\n|$3$|$6\\sim10$|$n,m \\le 10^6$|$25$|\n|$4$|$11\\sim14$|$n \\le 10^{14}$，$m=0$|$20$|\n|$5$|$15\\sim20$|$n \\le 10^{14}$，$m\\le 10^6$|$30$|\n\n答案的形式 $\\frac{p}{q}$ 必然满足 $(p,q\\in \\mathbb{N},998244353\\nmid q)$\n\n~~我会暗中支持你的，可别告诉别人——鲍勃。~~\n", "locale": "zh-CN"}}}
{"pid": "P6859", "type": "P", "difficulty": 5, "samples": [["5 4\n1 2 2 1 1\nA 5\nC 1 2\nA 5\nA 233", "1 3\n2 4\nnone"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["洛谷月赛"], "title": "蝴蝶与花", "background": "Amazing John 做了一个梦，梦到他上辈子是只苍茫蝶。\n\n深壑幽兰，雨落苍茫。\n\n怜其折翅，苦其执魔。\n\n琼片织翼，花露饯行。\n\n伶仃蝶碎，兰枯有情。\n\n君不识妾，妾仍思君。", "description": "Amazing John 很喜欢花。\n\nAmazing John 的花圃里有 $n$ 朵花，他每天都会在花园里散步。\n\n对于每一朵花 Amazing John 会评价它好看或不好看。被评价好看的花的美丽值为 $2$，被评价不好看的花的美丽值为 $1$。\n\n我们可以抽象的把这 $n$ 朵花看做在一条直线上。每次散步时， Amazing John 会从任意一朵花开始，一直往下一朵花走。到任意一朵花结束。在路途中，他会将所有经过的花的美丽值统计下来。（当然包括开始的花和结束的花）\n\n现在 Amazing John 想知道，能否有一种散步方案，使得他从第 $l$ 朵花走到第 $r$ 朵花的美丽值之和正好是 $s$？\n\n为了少走一些路， Amazing John 要你给出在所有方案中 $l$ 最小的方案。\n\n当然，为了避免在花圃中散步过于单调， Amazing John 随时可能会将一朵花的美丽值更改。\n\n每个询问之间互相独立，即统计过的花朵在下次询问时仍可被统计。", "inputFormat": "第一行两个数 $n,m$，分别表示花的个数和 Amazing John 的要求个数。\n\n第二行 $n$ 个数字 $a_i$，表示第 $i$ 朵花的美丽值。\n\n接下来 $m$ 行，每一行表示一个询问操作或一个修改操作。\n\n询问操作格式为 `A s`，表示询问是否有一种散步方案使得美丽值之和为 $s$。\n\n修改操作格式为 `C i val`，表示将第 $i$ 朵花的美丽值改成 $val(val=1$ 或 $2)$。", "outputFormat": "若有 $q$ 个 `A` 操作，输出应有 $q$ 行。\n\n对于每一个询问，若有合法的方案，输出这个方案的左右端点位置（多种方案时输出左端点最小的方案），否则输出 `none`。\n\n您应该保证 $1\\leq l\\leq r\\leq n$。", "hint": "$\\operatorname{Subtask\\ 1}\\ (20pts)$：对于数据点 $1\\sim 5$，满足 $1\\leq n,m\\leq 1000$。\n\n$\\operatorname{Subtask\\ 2}\\ (30pts)$：对于数据点 $6\\sim 10$，满足 $1\\leq n,m\\leq 2.5\\times 10^5$。\n\n$\\operatorname{Subtask\\ 3}\\ (50pts)$：对于数据点 $11\\sim 15$，满足 $1\\leq n,m\\leq 2\\times 10^6$。\n\n对于 $100\\%$ 的数据，有 $1\\leq n,m\\leq 2\\times 10^6,0\\leq s\\leq 2^{31}-1$。每次修改操作时 $i\\in[1,n],val\\in\\{1,2\\}$。\n\n对于所有数据点，时间限制 $2000\\operatorname{ms}$，空间限制 $256\\operatorname{MB}$。", "locale": "zh-CN", "translations": {"en": {"title": "Butterflies and Flowers", "background": "Amazing John had a dream that in his previous life he was a vast, misty butterfly.\n\nDeep ravines and hidden orchids, rain falling into the boundless haze.\n\nPity its broken wings, sorrow for its stubborn obsession.\n\nJade-like flakes weave wings, flower dew sees it off.\n\nA lonely butterfly shatters, the orchid withers yet still has feelings.\n\nYou do not know me, yet I still miss you.", "description": "Amazing John likes flowers very much.\n\nThere are $n$ flowers in Amazing John's garden, and every day he takes a walk in it.\n\nFor each flower, Amazing John will judge it as beautiful or not beautiful. A flower judged as beautiful has beauty value $2$, and a flower judged as not beautiful has beauty value $1$.\n\nWe can abstract these $n$ flowers as being on a straight line. During each walk, Amazing John may start from any flower and keep moving to the next flower, and end at any flower. Along the way, he sums up the beauty values of all flowers he passes (including the starting flower and the ending flower).\n\nNow Amazing John wants to know whether there exists a walking plan such that the sum of beauty values from the $l$-th flower to the $r$-th flower is exactly $s$.\n\nTo walk less, among all valid plans, Amazing John asks you to output the plan with the smallest $l$.\n\nOf course, to avoid the walk being too boring, Amazing John may change the beauty value of a flower at any time.\n\nEach query is independent. That is, flowers counted in one query can still be counted in the next query.", "inputFormat": "The first line contains two numbers $n,m$, representing the number of flowers and the number of requests from Amazing John.\n\nThe second line contains $n$ numbers $a_i$, where $a_i$ is the beauty value of the $i$-th flower.\n\nThe next $m$ lines each describe either a query operation or a modification operation.\n\nThe query operation format is `A s`, asking whether there exists a walking plan such that the sum of beauty values is $s$.\n\nThe modification operation format is `C i val`, meaning to change the beauty value of the $i$-th flower to $val(val=1$ or $2)$.", "outputFormat": "If there are $q$ operations of type `A`, the output should contain $q$ lines.\n\nFor each query, if there is a valid plan, output the left and right endpoint positions of that plan (if there are multiple plans, output the one with the smallest left endpoint). Otherwise, output `none`.\n\nYou should guarantee that $1\\leq l\\leq r\\leq n$.", "hint": "$\\operatorname{Subtask\\ 1}\\ (20pts)$: For testdata points $1\\sim 5$, $1\\leq n,m\\leq 1000$.\n\n$\\operatorname{Subtask\\ 2}\\ (30pts)$: For testdata points $6\\sim 10$, $1\\leq n,m\\leq 2.5\\times 10^5$.\n\n$\\operatorname{Subtask\\ 3}\\ (50pts)$: For testdata points $11\\sim 15$, $1\\leq n,m\\leq 2\\times 10^6$.\n\nFor $100\\%$ of the testdata, $1\\leq n,m\\leq 2\\times 10^6,0\\leq s\\leq 2^{31}-1$. For each modification operation, $i\\in[1,n],val\\in\\{1,2\\}$.\n\nFor all testdata points, the time limit is $2000\\operatorname{ms}$ and the memory limit is $256\\operatorname{MB}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "蝴蝶与花", "background": "Amazing John 做了一个梦，梦到他上辈子是只苍茫蝶。\n\n深壑幽兰，雨落苍茫。\n\n怜其折翅，苦其执魔。\n\n琼片织翼，花露饯行。\n\n伶仃蝶碎，兰枯有情。\n\n君不识妾，妾仍思君。", "description": "Amazing John 很喜欢花。\n\nAmazing John 的花圃里有 $n$ 朵花，他每天都会在花园里散步。\n\n对于每一朵花 Amazing John 会评价它好看或不好看。被评价好看的花的美丽值为 $2$，被评价不好看的花的美丽值为 $1$。\n\n我们可以抽象的把这 $n$ 朵花看做在一条直线上。每次散步时， Amazing John 会从任意一朵花开始，一直往下一朵花走。到任意一朵花结束。在路途中，他会将所有经过的花的美丽值统计下来。（当然包括开始的花和结束的花）\n\n现在 Amazing John 想知道，能否有一种散步方案，使得他从第 $l$ 朵花走到第 $r$ 朵花的美丽值之和正好是 $s$？\n\n为了少走一些路， Amazing John 要你给出在所有方案中 $l$ 最小的方案。\n\n当然，为了避免在花圃中散步过于单调， Amazing John 随时可能会将一朵花的美丽值更改。\n\n每个询问之间互相独立，即统计过的花朵在下次询问时仍可被统计。", "inputFormat": "第一行两个数 $n,m$，分别表示花的个数和 Amazing John 的要求个数。\n\n第二行 $n$ 个数字 $a_i$，表示第 $i$ 朵花的美丽值。\n\n接下来 $m$ 行，每一行表示一个询问操作或一个修改操作。\n\n询问操作格式为 `A s`，表示询问是否有一种散步方案使得美丽值之和为 $s$。\n\n修改操作格式为 `C i val`，表示将第 $i$ 朵花的美丽值改成 $val(val=1$ 或 $2)$。", "outputFormat": "若有 $q$ 个 `A` 操作，输出应有 $q$ 行。\n\n对于每一个询问，若有合法的方案，输出这个方案的左右端点位置（多种方案时输出左端点最小的方案），否则输出 `none`。\n\n您应该保证 $1\\leq l\\leq r\\leq n$。", "hint": "$\\operatorname{Subtask\\ 1}\\ (20pts)$：对于数据点 $1\\sim 5$，满足 $1\\leq n,m\\leq 1000$。\n\n$\\operatorname{Subtask\\ 2}\\ (30pts)$：对于数据点 $6\\sim 10$，满足 $1\\leq n,m\\leq 2.5\\times 10^5$。\n\n$\\operatorname{Subtask\\ 3}\\ (50pts)$：对于数据点 $11\\sim 15$，满足 $1\\leq n,m\\leq 2\\times 10^6$。\n\n对于 $100\\%$ 的数据，有 $1\\leq n,m\\leq 2\\times 10^6,0\\leq s\\leq 2^{31}-1$。每次修改操作时 $i\\in[1,n],val\\in\\{1,2\\}$。\n\n对于所有数据点，时间限制 $2000\\operatorname{ms}$，空间限制 $256\\operatorname{MB}$。", "locale": "zh-CN"}}}
{"pid": "P6860", "type": "P", "difficulty": 6, "samples": [["3\n2\n3\n4", "2\n4\n8"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化", "莫比乌斯反演", "洛谷月赛", "Bézout 定理", "杜教筛"], "title": "象棋与马", "background": "Amazing John 做了一个梦，梦到他下辈子是个象棋大师。\n\n因为人与人之间是不能一概而论的，马与象之间也不能相提并论。\n\nAmazing John 在极度愤怒的情况下创造了一种新的棋：马棋。\n\n“啊这，不会真有人不会下这种棋吧？”\n\n现在他想请你来体验一下这种新棋。", "description": "Amazing John 有一个无限大的棋盘来下马棋。\n\n有一个马最开始在 $(0,0)$，它的每一步可以走一个 $a\\times b$ 的矩形（ 即能够从$(x,y)$到达 $(x\\pm a,y\\pm b)$ 或 $(x\\pm b,y\\pm a)$ ）。\n\n若马通过上述移动方式可以到达棋盘中任意一个点，那么 $p(a,b)=1$，否则 $p(a,b)=0$。\n\n现在 Amazing John 给你 $T$ 组询问，每组询问他会给出一个正整数 $n$，他想知道 \n\n$$\\left ( \\sum_{a=1}^n\\sum_{b=1}^np(a,b) \\right )\\bmod\\ 2^{64}$$\n\n的值。", "inputFormat": "**本题含有多组数据。**\n\n输入的第一行为一个整数，表示数据组数 $T$。\n\n接下来 $T$ 行，每行一个整数 $n$，表示一个询问。", "outputFormat": "输出共 $T$ 行。\n\n对于每组询问，输出一行一个整数，即\n$$\\left ( \\sum_{a=1}^n\\sum_{b=1}^np(a,b) \\right )\\bmod\\ 2^{64}$$\n的值。", "hint": "样例解释：当 $n=3$ 时，值为 $1$ 的有 $p(1,2),p(2,1),p(2,3),p(3,2)$。\n\n**本题开启Subtask**\n|子任务|数据点|数据范围|分数|\n|-|-|-|-\n|$1$|$1$|$n\\leq 10,T\\leq5$|$5$|\n|$2$|$2\\sim 5$|$n\\leq 3000,T\\leq5$|$15$|\n|$3$|$6\\sim 10$|$n\\leq 10^5,T\\leq 5$|$15$|\n|$4$|$11\\sim 15$|$n\\leq 10^7,T\\leq5$|$15$|\n|$5$|$16\\sim 18$|$n\\leq10^9,T\\leq 5$|$15$|\n|$6$|$19\\sim 25$|$n\\times T\\leq 10^{11},T\\leq 5$|$35$|\n\n注 1：对于 $n\\times T\\geq 5*10^{10}$ 的数据点，时限为 **4s** ，其余均为 **2.5s** 。且对于所有数据点，空间限制为 **500MB** 。\n\n注 2：输出答案 $\\bmod\\ 2^{64}$ 即对 **64位无符号整数** 自然溢出。\n\n本题开启 -O2 优化开关。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "象棋与马", "background": "Amazing John 做了一个梦，梦到他下辈子是个象棋大师。\n\n因为人与人之间是不能一概而论的，马与象之间也不能相提并论。\n\nAmazing John 在极度愤怒的情况下创造了一种新的棋：马棋。\n\n“啊这，不会真有人不会下这种棋吧？”\n\n现在他想请你来体验一下这种新棋。", "description": "Amazing John 有一个无限大的棋盘来下马棋。\n\n有一个马最开始在 $(0,0)$，它的每一步可以走一个 $a\\times b$ 的矩形（ 即能够从$(x,y)$到达 $(x\\pm a,y\\pm b)$ 或 $(x\\pm b,y\\pm a)$ ）。\n\n若马通过上述移动方式可以到达棋盘中任意一个点，那么 $p(a,b)=1$，否则 $p(a,b)=0$。\n\n现在 Amazing John 给你 $T$ 组询问，每组询问他会给出一个正整数 $n$，他想知道 \n\n$$\\left ( \\sum_{a=1}^n\\sum_{b=1}^np(a,b) \\right )\\bmod\\ 2^{64}$$\n\n的值。", "inputFormat": "**本题含有多组数据。**\n\n输入的第一行为一个整数，表示数据组数 $T$。\n\n接下来 $T$ 行，每行一个整数 $n$，表示一个询问。", "outputFormat": "输出共 $T$ 行。\n\n对于每组询问，输出一行一个整数，即\n$$\\left ( \\sum_{a=1}^n\\sum_{b=1}^np(a,b) \\right )\\bmod\\ 2^{64}$$\n的值。", "hint": "样例解释：当 $n=3$ 时，值为 $1$ 的有 $p(1,2),p(2,1),p(2,3),p(3,2)$。\n\n**本题开启Subtask**\n|子任务|数据点|数据范围|分数|\n|-|-|-|-\n|$1$|$1$|$n\\leq 10,T\\leq5$|$5$|\n|$2$|$2\\sim 5$|$n\\leq 3000,T\\leq5$|$15$|\n|$3$|$6\\sim 10$|$n\\leq 10^5,T\\leq 5$|$15$|\n|$4$|$11\\sim 15$|$n\\leq 10^7,T\\leq5$|$15$|\n|$5$|$16\\sim 18$|$n\\leq10^9,T\\leq 5$|$15$|\n|$6$|$19\\sim 25$|$n\\times T\\leq 10^{11},T\\leq 5$|$35$|\n\n注 1：对于 $n\\times T\\geq 5*10^{10}$ 的数据点，时限为 **4s** ，其余均为 **2.5s** 。且对于所有数据点，空间限制为 **500MB** 。\n\n注 2：输出答案 $\\bmod\\ 2^{64}$ 即对 **64位无符号整数** 自然溢出。\n\n本题开启 -O2 优化开关。", "locale": "zh-CN"}}}
{"pid": "P6861", "type": "P", "difficulty": 2, "samples": [["5", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": [], "title": "[RC-03] 难题", "background": "", "description": "求两个整数 $a,b$ $(1\\le a,b\\le n)$，使 $(a\\ \\mathrm{or}\\ b)+(a\\ \\mathrm{xor}\\ b)$ 最大。只需输出这个最大值。", "inputFormat": "一个正整数 $n$。", "outputFormat": "一个正整数，为答案。", "hint": "样例说明：$(5\\ \\mathrm{or}\\ 2)+(5\\ \\mathrm{xor}\\ 2)=14$。\n\n对于 $80\\%$ 的数据，$n\\le 1000$。\n\n对于 $100\\%$ 的数据，$2\\le n\\le 10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RC-03] 难题", "background": "", "description": "求两个整数 $a,b$ $(1\\le a,b\\le n)$，使 $(a\\ \\mathrm{or}\\ b)+(a\\ \\mathrm{xor}\\ b)$ 最大。只需输出这个最大值。", "inputFormat": "一个正整数 $n$。", "outputFormat": "一个正整数，为答案。", "hint": "样例说明：$(5\\ \\mathrm{or}\\ 2)+(5\\ \\mathrm{xor}\\ 2)=14$。\n\n对于 $80\\%$ 的数据，$n\\le 1000$。\n\n对于 $100\\%$ 的数据，$2\\le n\\le 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P6862", "type": "P", "difficulty": 4, "samples": [["3\n3 1\n3 2\n3 3", "3\n3\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "前缀和", "期望", "逆元"], "title": "[RC-03] 随机树生成器", "background": "", "description": "小 R 有一个随机树生成器，其工作原理如下：\n- 输入 $n$，则对于每个 $1<i\\le n$，随机选择一个 $[1,i)$ 中的节点作为其父亲。返回这棵树。\n\n给定 $n,k$，小 R 想知道可能生成的所有 $n$ 个点的树中，$k$ 号点的度数和。\n\n由于答案可能很大，请输出答案模 $10^9+9$ 的值。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数，是数据组数 $T$。\n\n接下来 $T$ 行，每行两个正整数 $n,k$。", "outputFormat": "$T$ 行，每行一个整数，为这组数据的答案模 $10^9+9$ 的值。", "hint": "【样例说明】\n\n- 数据 $1$：一共有两种情况，$1$ 号点的度数分别为 $1,2$。因此答案为 $3$。\n- 数据 $2$：一共有两种情况，$2$ 号点的度数分别为 $1,2$。因此答案为 $3$。\n- 数据 $3$：一共有两种情况，$3$ 号点的度数均为 $1$。因此答案为 $2$。\n\n【数据范围】\n\n本题捆绑测试。\n\n对于 $100\\%$ 的数据，$1\\le T\\le 10^5$，$1\\le k\\le n\\le 10^7$。详细数据范围如下。\n\n- Subtask 1（20 分）：$T\\le 50$，$n\\le 8$。\n- Subtask 2（55 分）：$T=1$，$n\\le 10^5$。\n- Subtask 3（20 分）：$T=1$。\n- Subtask 4（5 分）：没有任何附加限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RC-03] 随机树生成器", "background": "", "description": "小 R 有一个随机树生成器，其工作原理如下：\n- 输入 $n$，则对于每个 $1<i\\le n$，随机选择一个 $[1,i)$ 中的节点作为其父亲。返回这棵树。\n\n给定 $n,k$，小 R 想知道可能生成的所有 $n$ 个点的树中，$k$ 号点的度数和。\n\n由于答案可能很大，请输出答案模 $10^9+9$ 的值。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数，是数据组数 $T$。\n\n接下来 $T$ 行，每行两个正整数 $n,k$。", "outputFormat": "$T$ 行，每行一个整数，为这组数据的答案模 $10^9+9$ 的值。", "hint": "【样例说明】\n\n- 数据 $1$：一共有两种情况，$1$ 号点的度数分别为 $1,2$。因此答案为 $3$。\n- 数据 $2$：一共有两种情况，$2$ 号点的度数分别为 $1,2$。因此答案为 $3$。\n- 数据 $3$：一共有两种情况，$3$ 号点的度数均为 $1$。因此答案为 $2$。\n\n【数据范围】\n\n本题捆绑测试。\n\n对于 $100\\%$ 的数据，$1\\le T\\le 10^5$，$1\\le k\\le n\\le 10^7$。详细数据范围如下。\n\n- Subtask 1（20 分）：$T\\le 50$，$n\\le 8$。\n- Subtask 2（55 分）：$T=1$，$n\\le 10^5$。\n- Subtask 3（20 分）：$T=1$。\n- Subtask 4（5 分）：没有任何附加限制。", "locale": "zh-CN"}}}
{"pid": "P6863", "type": "P", "difficulty": 5, "samples": [["5 16\n2 2 2 2 1\n2 2 2 2", "-4 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": [], "title": "[RC-03] 上下求索", "background": "", "description": "有一个关于 $x_i(i∈\\{1,2,3,...,n\\},x_i∈\\mathbb{R})$ 的 $n$ 元二次方程：\n\n$$\\sum_{i=1}^na_ix_i^2+\\sum_{i=1}^{n-1}b_ix_ix_{i+1}=m$$\n\n请您在这个方程中，求出保证方程有解的 $x_1$ 的取值范围。\n\n保证 $x_1$ 有上下界。", "inputFormat": "输入一共有三行，\n\n第一行有两个整数 $n,m$；\n\n第二行共有 $n$ 个整数 $a_i$，其中 $i∈\\{1,2,3,..,n\\}$；\n\n第三行 $n-1$ 个整数 $b_i$，其中 $i∈\\{1,2,3,..,n-1\\}$。", "outputFormat": "一行两个整数，用空格隔开，表示 $x_1$ 的下界与上界（数据保证输出一定是整数）。", "hint": "【样例 $1$ 说明】\n\n原方程为 $2x_1^2+2x_1x_2+2x_2^2+2x_2x_3+2x_3^2+2x_3x_4+2x_4^2+2x_4x_5+x_5^2=16$。\n\n当 $x_1=-4$ 有 $x_1=-4$；$x_2=4$；$x_3=-4$；$x_4=4$；$x_5=-4$。  \n当 $x_1=4$ 有 $x_1=4$；$x_2=-4$；$x_3=4$；$x_4=-4$；$x_5=4$。  \n当 $x_1>4$ 或 $x_1<-4$ 时原方程左必 $>16$。  \n$∴ -4\\leq x_1\\leq 4$。\n\n---\n  \n【数据范围】\n\n对于 $4\\%$ 的数据，$n=1$。\n\n对于 $16\\%$ 的数据，$n\\le 2$。 \n\n对于另外 $16\\%$ 的数据，$n\\le 8$，$m\\le 30$。 \n\n对于 $60\\%$ 的数据，$n\\le 10^3$。 \n\n对于 $100\\%$ 的数据，$1\\le a_i,b_i,m\\leq 10^9$，$1\\le n\\leq 5\\times 10^5$。  ", "locale": "zh-CN", "translations": {"en": {"title": "[RC-03] Seeking Up and Down", "background": "", "description": "There is an $n$-variable quadratic equation about $x_i(i∈\\{1,2,3,...,n\\},x_i∈\\mathbb{R})$:\n\n$$\\sum_{i=1}^na_ix_i^2+\\sum_{i=1}^{n-1}b_ix_ix_{i+1}=m$$\n\nIn this equation, please find the range of values of $x_1$ that guarantees the equation has at least one solution.\n\nIt is guaranteed that $x_1$ has both a lower bound and an upper bound.", "inputFormat": "The input has three lines.\n\nThe first line contains two integers $n,m$.\n\nThe second line contains $n$ integers $a_i$, where $i∈\\{1,2,3,..,n\\}$.\n\nThe third line contains $n-1$ integers $b_i$, where $i∈\\{1,2,3,..,n-1\\}$.", "outputFormat": "Output one line with two integers separated by a space, representing the lower bound and upper bound of $x_1$ (it is guaranteed that the output is always integers).", "hint": "[Sample $1$ Explanation]\n\nThe original equation is $2x_1^2+2x_1x_2+2x_2^2+2x_2x_3+2x_3^2+2x_3x_4+2x_4^2+2x_4x_5+x_5^2=16$.\n\nWhen $x_1=-4$, we have $x_1=-4$; $x_2=4$; $x_3=-4$; $x_4=4$; $x_5=-4$.  \nWhen $x_1=4$, we have $x_1=4$; $x_2=-4$; $x_3=4$; $x_4=-4$; $x_5=4$.  \nWhen $x_1>4$ or $x_1<-4$, the left-hand side of the original equation must be $>16$.  \nTherefore, $-4\\leq x_1\\leq 4$.\n\n---\n\n[Constraints]\n\nFor $4\\%$ of the testdata, $n=1$.\n\nFor $16\\%$ of the testdata, $n\\le 2$.\n\nFor another $16\\%$ of the testdata, $n\\le 8$, $m\\le 30$.\n\nFor $60\\%$ of the testdata, $n\\le 10^3$.\n\nFor $100\\%$ of the testdata, $1\\le a_i,b_i,m\\leq 10^9$, $1\\le n\\leq 5\\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[RC-03] 上下求索", "background": "", "description": "有一个关于 $x_i(i∈\\{1,2,3,...,n\\},x_i∈\\mathbb{R})$ 的 $n$ 元二次方程：\n\n$$\\sum_{i=1}^na_ix_i^2+\\sum_{i=1}^{n-1}b_ix_ix_{i+1}=m$$\n\n请您在这个方程中，求出保证方程有解的 $x_1$ 的取值范围。\n\n保证 $x_1$ 有上下界。", "inputFormat": "输入一共有三行，\n\n第一行有两个整数 $n,m$；\n\n第二行共有 $n$ 个整数 $a_i$，其中 $i∈\\{1,2,3,..,n\\}$；\n\n第三行 $n-1$ 个整数 $b_i$，其中 $i∈\\{1,2,3,..,n-1\\}$。", "outputFormat": "一行两个整数，用空格隔开，表示 $x_1$ 的下界与上界（数据保证输出一定是整数）。", "hint": "【样例 $1$ 说明】\n\n原方程为 $2x_1^2+2x_1x_2+2x_2^2+2x_2x_3+2x_3^2+2x_3x_4+2x_4^2+2x_4x_5+x_5^2=16$。\n\n当 $x_1=-4$ 有 $x_1=-4$；$x_2=4$；$x_3=-4$；$x_4=4$；$x_5=-4$。  \n当 $x_1=4$ 有 $x_1=4$；$x_2=-4$；$x_3=4$；$x_4=-4$；$x_5=4$。  \n当 $x_1>4$ 或 $x_1<-4$ 时原方程左必 $>16$。  \n$∴ -4\\leq x_1\\leq 4$。\n\n---\n  \n【数据范围】\n\n对于 $4\\%$ 的数据，$n=1$。\n\n对于 $16\\%$ 的数据，$n\\le 2$。 \n\n对于另外 $16\\%$ 的数据，$n\\le 8$，$m\\le 30$。 \n\n对于 $60\\%$ 的数据，$n\\le 10^3$。 \n\n对于 $100\\%$ 的数据，$1\\le a_i,b_i,m\\leq 10^9$，$1\\le n\\leq 5\\times 10^5$。  ", "locale": "zh-CN"}}}
{"pid": "P6864", "type": "P", "difficulty": 6, "samples": [["6\n1\n2\n3 1\n1\n3 3\n3 5\n", "3\n4\n2\n4\n6\n4\n"], ["10\n1\n2\n2\n3 2\n1\n3 3\n3 6\n1\n2\n1\n", "3\n4\n5\n4\n6\n6\n6\n9\n10\n12\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["线段树", "二分", "树状数组", "矩阵乘法"], "title": "[RC-03] 记忆", "background": "小 W 想写一个关于记忆的题目背景，但是他忘记了。", "description": "有一个括号串 $S$，一开始 $S$ 中只包含一对括号（即初始的 $S$ 为 `()`），接下来有 $n$ 个操作，操作分为三种：\n\n1. 在当前 $S$ 的末尾加一对括号（即 $S$ 变为 `S()`）；\n\n2. 在当前 $S$ 的最外面加一对括号（即 $S$ 变为 `(S)`）；\n\n3. 取消第 $x$ 个操作，即去除第 $x$ 个操作造成过的**一切影响**（例如，如果第 $x$ 个操作也是取消操作，且取消了第 $y$ 个操作，那么当前操作的实质就是恢复了第 $y$ 个操作的作用效果）。\n\n每次操作后，你需要输出 $S$ 的能够括号匹配的非空子串（子串要求连续）个数。\n\n一个括号串能够括号匹配，当且仅当其左右括号数量相等，且任意一个前缀中左括号数量不少于右括号数量。", "inputFormat": "第一行：一个整数 $n$，表示操作的个数。\n\n接下来 $n$ 行：每行先有一个整数 $op$，表示操作的种类：\n\n若 $op=1$，则表示执行了操作 $1$；\n\n若 $op=2$，则表示执行了操作 $2$；\n\n若 $op=3$，接下来还有一个整数 $x$，表示执行操作 $3$，取消了第 $x$ 个操作（操作按 $1$ 到 $n$ 编号，保证第 $x$ 个操作已发生），注意取消操作**并不影响任何操作的编号**，编号只取决于输入顺序。", "outputFormat": "共 $n$ 行：第 $i$ 行输出一个整数 $ans_i$，表示第 $i$ 次操作结束后整个括号串的括号匹配的非空子串个数。", "hint": "【样例 $1$ 解释】\n\n用 $S[i,j]$ 表示从 $S_i$ 到 $S_j$ 的子串（下标从 $1$ 开始）。\n\n一开始 $S$ 为 `()`，每次操作后：\n\n第 $1$ 次操作后：$S$ 为 `()()`，匹配的子串有 $S[1,2]$，$S[1,4]$ 和 $S[3,4]$，共 $3$ 个。\n\n第 $2$ 次操作后：$S$ 为 `(()())`，匹配的子串有 $S[1,6]$，$S[2,3]$，$S[2,5]$ 和 $S[4,5]$，共 $4$ 个。\n\n第 $3$ 次操作后：$S$ 为 `(())`，匹配的子串有 $S[1,4]$ 和 $S[2,3]$，共 $2$ 个。\n\n第 $4$ 次操作后：$S$ 为 `(())()`，匹配的子串有 $S[1,4]$，$S[1,6]$，$S[2,3]$ 和 $S[5,6]$，共 $4$ 个。\n\n第 $5$ 次操作后：$S$ 为 `(()())()`，匹配的子串有 $S[1,6]$，$S[1,8]$，$S[2,3]$，$S[2,5]$，$S[4,5]$ 和 $S[7,8]$，共 $6$ 个。\n\n第 $6$ 次操作后：$S$ 为 `(())()`，匹配的子串有 $S[1,4]$，$S[1,6]$，$S[2,3]$ 和 $S[5,6]$，共 $4$ 个。\n\n---\n\n【数据范围】\n\n**本题采用捆绑测试。**\n\n对于全部数据：$1\\leq n\\leq 2\\times 10^5$，$op\\in \\{1,2,3\\}$，$1\\leq x\\leq n$，一个操作在形式上最多只会被取消一次（即所有 $x$ 互不相同）。\n\n| 子任务编号 |    $n\\leq$     |   $op\\in$   | 分值 |\n| :--------: | :------------: | :---------: | :--: |\n| Subtask 1  |     $100$      | $\\{1,2,3\\}$ | $10$ |\n| Subtask 2  |     $10^3$     | $\\{1,2,3\\}$ | $10$ |\n| Subtask 3  |     $10^5$     | $\\{1,2,3\\}$ | $30$ |\n| Subtask 4  | $2\\times 10^5$ |  $\\{1,2\\}$  | $20$ |\n| Subtask 5  | $2\\times 10^5$ | $\\{1,2,3\\}$ | $30$ |\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[RC-03] Memory", "background": "Little W wants to write a background story about memory, but he forgot it.", "description": "There is a bracket string $S$. Initially, $S$ contains only one pair of brackets (that is, the initial $S$ is `()`). Then there are $n$ operations of three types:\n\n1. Append one pair of brackets to the end of the current $S$ (that is, $S$ becomes `S()`);\n\n2. Add one pair of brackets around the outside of the current $S$ (that is, $S$ becomes `(S)`);\n\n3. Cancel the $x$-th operation, i.e., remove **all effects** caused by the $x$-th operation (for example, if the $x$-th operation is also a cancel operation and it canceled the $y$-th operation, then the essence of the current operation is to restore the effect of the $y$-th operation).\n\nAfter each operation, you need to output the number of non-empty substrings (substrings must be contiguous) of $S$ that can be matched as brackets.\n\nA bracket string can be matched if and only if the numbers of left and right brackets are equal, and in every prefix, the number of left brackets is not less than the number of right brackets.", "inputFormat": "The first line: an integer $n$, the number of operations.\n\nThe next $n$ lines: each line starts with an integer $op$, indicating the type of the operation:\n\nIf $op=1$, it means operation $1$ is performed.\n\nIf $op=2$, it means operation $2$ is performed.\n\nIf $op=3$, there is also an integer $x$ afterwards, meaning operation $3$ is performed and the $x$-th operation is canceled (operations are numbered from $1$ to $n$, and it is guaranteed that the $x$-th operation has already happened). Note that a cancel operation **does not affect any operation indices**. Indices depend only on the input order.", "outputFormat": "Output $n$ lines in total. On line $i$, output an integer $ans_i$, the number of non-empty substrings of the whole bracket string that can be matched after the $i$-th operation ends.", "hint": "[Sample $1$ Explanation]\n\nUse $S[i,j]$ to denote the substring from $S_i$ to $S_j$ (indices start from $1$).\n\nInitially, $S$ is `()`. After each operation:\n\nAfter the $1$-st operation: $S$ is `()()`. The matched substrings are $S[1,2]$, $S[1,4]$, and $S[3,4]$, for a total of $3$.\n\nAfter the $2$-nd operation: $S$ is `(()())`. The matched substrings are $S[1,6]$, $S[2,3]$, $S[2,5]$, and $S[4,5]$, for a total of $4$.\n\nAfter the $3$-rd operation: $S$ is `(())`. The matched substrings are $S[1,4]$ and $S[2,3]$, for a total of $2$.\n\nAfter the $4$-th operation: $S$ is `(())()`. The matched substrings are $S[1,4]$, $S[1,6]$, $S[2,3]$, and $S[5,6]$, for a total of $4$.\n\nAfter the $5$-th operation: $S$ is `(()())()`. The matched substrings are $S[1,6]$, $S[1,8]$, $S[2,3]$, $S[2,5]$, $S[4,5]$, and $S[7,8]$, for a total of $6$.\n\nAfter the $6$-th operation: $S$ is `(())()`. The matched substrings are $S[1,4]$, $S[1,6]$, $S[2,3]$, and $S[5,6]$, for a total of $4$.\n\n---\n\n[Constraints]\n\n**This problem uses bundled testdata.**\n\nFor all data: $1\\leq n\\leq 2\\times 10^5$, $op\\in \\{1,2,3\\}$, $1\\leq x\\leq n$. Each operation can be canceled at most once in form (i.e., all $x$ are distinct).\n\n| Subtask ID |    $n\\leq$     |   $op\\in$   | Score |\n| :--------: | :------------: | :---------: | :---: |\n| Subtask 1  |     $100$      | $\\{1,2,3\\}$ | $10$  |\n| Subtask 2  |     $10^3$     | $\\{1,2,3\\}$ | $10$  |\n| Subtask 3  |     $10^5$     | $\\{1,2,3\\}$ | $30$  |\n| Subtask 4  | $2\\times 10^5$ |  $\\{1,2\\}$  | $20$  |\n| Subtask 5  | $2\\times 10^5$ | $\\{1,2,3\\}$ | $30$  |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[RC-03] 记忆", "background": "小 W 想写一个关于记忆的题目背景，但是他忘记了。", "description": "有一个括号串 $S$，一开始 $S$ 中只包含一对括号（即初始的 $S$ 为 `()`），接下来有 $n$ 个操作，操作分为三种：\n\n1. 在当前 $S$ 的末尾加一对括号（即 $S$ 变为 `S()`）；\n\n2. 在当前 $S$ 的最外面加一对括号（即 $S$ 变为 `(S)`）；\n\n3. 取消第 $x$ 个操作，即去除第 $x$ 个操作造成过的**一切影响**（例如，如果第 $x$ 个操作也是取消操作，且取消了第 $y$ 个操作，那么当前操作的实质就是恢复了第 $y$ 个操作的作用效果）。\n\n每次操作后，你需要输出 $S$ 的能够括号匹配的非空子串（子串要求连续）个数。\n\n一个括号串能够括号匹配，当且仅当其左右括号数量相等，且任意一个前缀中左括号数量不少于右括号数量。", "inputFormat": "第一行：一个整数 $n$，表示操作的个数。\n\n接下来 $n$ 行：每行先有一个整数 $op$，表示操作的种类：\n\n若 $op=1$，则表示执行了操作 $1$；\n\n若 $op=2$，则表示执行了操作 $2$；\n\n若 $op=3$，接下来还有一个整数 $x$，表示执行操作 $3$，取消了第 $x$ 个操作（操作按 $1$ 到 $n$ 编号，保证第 $x$ 个操作已发生），注意取消操作**并不影响任何操作的编号**，编号只取决于输入顺序。", "outputFormat": "共 $n$ 行：第 $i$ 行输出一个整数 $ans_i$，表示第 $i$ 次操作结束后整个括号串的括号匹配的非空子串个数。", "hint": "【样例 $1$ 解释】\n\n用 $S[i,j]$ 表示从 $S_i$ 到 $S_j$ 的子串（下标从 $1$ 开始）。\n\n一开始 $S$ 为 `()`，每次操作后：\n\n第 $1$ 次操作后：$S$ 为 `()()`，匹配的子串有 $S[1,2]$，$S[1,4]$ 和 $S[3,4]$，共 $3$ 个。\n\n第 $2$ 次操作后：$S$ 为 `(()())`，匹配的子串有 $S[1,6]$，$S[2,3]$，$S[2,5]$ 和 $S[4,5]$，共 $4$ 个。\n\n第 $3$ 次操作后：$S$ 为 `(())`，匹配的子串有 $S[1,4]$ 和 $S[2,3]$，共 $2$ 个。\n\n第 $4$ 次操作后：$S$ 为 `(())()`，匹配的子串有 $S[1,4]$，$S[1,6]$，$S[2,3]$ 和 $S[5,6]$，共 $4$ 个。\n\n第 $5$ 次操作后：$S$ 为 `(()())()`，匹配的子串有 $S[1,6]$，$S[1,8]$，$S[2,3]$，$S[2,5]$，$S[4,5]$ 和 $S[7,8]$，共 $6$ 个。\n\n第 $6$ 次操作后：$S$ 为 `(())()`，匹配的子串有 $S[1,4]$，$S[1,6]$，$S[2,3]$ 和 $S[5,6]$，共 $4$ 个。\n\n---\n\n【数据范围】\n\n**本题采用捆绑测试。**\n\n对于全部数据：$1\\leq n\\leq 2\\times 10^5$，$op\\in \\{1,2,3\\}$，$1\\leq x\\leq n$，一个操作在形式上最多只会被取消一次（即所有 $x$ 互不相同）。\n\n| 子任务编号 |    $n\\leq$     |   $op\\in$   | 分值 |\n| :--------: | :------------: | :---------: | :--: |\n| Subtask 1  |     $100$      | $\\{1,2,3\\}$ | $10$ |\n| Subtask 2  |     $10^3$     | $\\{1,2,3\\}$ | $10$ |\n| Subtask 3  |     $10^5$     | $\\{1,2,3\\}$ | $30$ |\n| Subtask 4  | $2\\times 10^5$ |  $\\{1,2\\}$  | $20$ |\n| Subtask 5  | $2\\times 10^5$ | $\\{1,2,3\\}$ | $30$ |\n\n", "locale": "zh-CN"}}}
{"pid": "P6865", "type": "P", "difficulty": 7, "samples": [["3 3 3\n1 2\n2 3\n3 1", "3\n1 2 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["提交答案", "Special Judge"], "title": "[RC-03] 染色", "background": "提示：输入文件很大，因此下载可能较慢（约需 3 分钟），请耐心等待。\n\n**本题为提交答案题。** 输入数据请在[这里](http://119.27.163.117/images/files/input.zip)下载。\n\n你提交的答案**最好**依次命名为：\n\n- 01.out\n- 02.out\n- $\\dots$\n- 18.out", "description": "给一个无向图，求尽量小的 $k$，使得能够把节点分为 $k$ 个集合，且同一集合的点间没有边。", "inputFormat": "第一行三个整数：$n,m,k_0$，表示有 $n$ 个点，$m$ 条边，你的 $k$ 只要满足 $k\\le k_0$ 就能得到满分。\n\n接下来 $m$ 行，每行两个数 $x,y$，描述一条边 $(x,y)$。$(1\\le x,y\\le n,x\\ne y)$", "outputFormat": "两行，第一行为一个整数 $k$，为你的答案。$(1\\le k\\le n)$\n\n第二行 $n$ 个整数，第 $i$ 个表示 $i$ 被分到的集合编号 $a_i$。$(1\\le a_i\\le k)$", "hint": "对于每个测试点：\n\n- 若你的输出不合法，你将得到 $0$ 分。\n- 若 $k\\le k_0$，你将得到满分。\n- 否则你将得到（设该测试点满分为 $a$）：$\\lfloor a \\times \\dfrac{k_0}{k}\\rfloor$ 分。\n\n本题共有 $18$ 个测试点，所有测试点均满足 $1\\le n\\le 10^5$，$1\\le m\\le 5\\times 10^5$，且保证存在一种满足 $k\\le k_0$ 的方案。以下是每个测试点的分值：\n\n| 测试点编号 | 分值 |\n| :----------: | :----------: |\n| $1\\sim 4$ | $4$ |\n| $5\\sim 6$ | $5$ |\n| $7\\sim 17$ | $6$ |\n| $18$ | $8$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RC-03] 染色", "background": "提示：输入文件很大，因此下载可能较慢（约需 3 分钟），请耐心等待。\n\n**本题为提交答案题。** 输入数据请在[这里](http://119.27.163.117/images/files/input.zip)下载。\n\n你提交的答案**最好**依次命名为：\n\n- 01.out\n- 02.out\n- $\\dots$\n- 18.out", "description": "给一个无向图，求尽量小的 $k$，使得能够把节点分为 $k$ 个集合，且同一集合的点间没有边。", "inputFormat": "第一行三个整数：$n,m,k_0$，表示有 $n$ 个点，$m$ 条边，你的 $k$ 只要满足 $k\\le k_0$ 就能得到满分。\n\n接下来 $m$ 行，每行两个数 $x,y$，描述一条边 $(x,y)$。$(1\\le x,y\\le n,x\\ne y)$", "outputFormat": "两行，第一行为一个整数 $k$，为你的答案。$(1\\le k\\le n)$\n\n第二行 $n$ 个整数，第 $i$ 个表示 $i$ 被分到的集合编号 $a_i$。$(1\\le a_i\\le k)$", "hint": "对于每个测试点：\n\n- 若你的输出不合法，你将得到 $0$ 分。\n- 若 $k\\le k_0$，你将得到满分。\n- 否则你将得到（设该测试点满分为 $a$）：$\\lfloor a \\times \\dfrac{k_0}{k}\\rfloor$ 分。\n\n本题共有 $18$ 个测试点，所有测试点均满足 $1\\le n\\le 10^5$，$1\\le m\\le 5\\times 10^5$，且保证存在一种满足 $k\\le k_0$ 的方案。以下是每个测试点的分值：\n\n| 测试点编号 | 分值 |\n| :----------: | :----------: |\n| $1\\sim 4$ | $4$ |\n| $5\\sim 6$ | $5$ |\n| $7\\sim 17$ | $6$ |\n| $18$ | $8$ |", "locale": "zh-CN"}}}
{"pid": "P6866", "type": "P", "difficulty": 1, "samples": [["6 7\n***....\n***..**\n.....**\n.***.**\n.***...\n.***...\n", "3"], ["3 3\n*.*\n...\n*.*\n", "4"], ["1 10\n.*.**.***.\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "COCI（克罗地亚）"], "title": "[COCI 2019/2020 #5] Emacs", "background": "", "description": "给定一个 $n\\times m$ 的只含有 `.` 和 `*` 的矩阵。\n\n矩阵中 `*` 形成一些不重叠的长方形。它们不在边缘或顶点接触。\n\n求长方形有多少个？", "inputFormat": "第一行：两个正整数 $n$ 和 $m$。\n\n以下 $n$ 行：表示题目描述中的矩阵。矩阵只含有 `.` 和 `*`。", "outputFormat": "一行一个非负整数，你的答案。", "hint": "### 数据范围\n\n- 对于 $10 pts$ 的数据，矩阵中每个长方形只含一个 `*`。\n- 对于另外 $15 pts$ 的数据，保证 $n=1$。\n- 对于所有的数据，$1\\leq n,m\\leq 100$。\n\n### 说明\n\n**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #5](https://hsin.hr/coci/archive/2019_2020/contest5_tasks.pdf)  _T1 Emacs_** ，译者 [90693](/user/90693)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2019/2020 #5] Emacs", "background": "", "description": "给定一个 $n\\times m$ 的只含有 `.` 和 `*` 的矩阵。\n\n矩阵中 `*` 形成一些不重叠的长方形。它们不在边缘或顶点接触。\n\n求长方形有多少个？", "inputFormat": "第一行：两个正整数 $n$ 和 $m$。\n\n以下 $n$ 行：表示题目描述中的矩阵。矩阵只含有 `.` 和 `*`。", "outputFormat": "一行一个非负整数，你的答案。", "hint": "### 数据范围\n\n- 对于 $10 pts$ 的数据，矩阵中每个长方形只含一个 `*`。\n- 对于另外 $15 pts$ 的数据，保证 $n=1$。\n- 对于所有的数据，$1\\leq n,m\\leq 100$。\n\n### 说明\n\n**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #5](https://hsin.hr/coci/archive/2019_2020/contest5_tasks.pdf)  _T1 Emacs_** ，译者 [90693](/user/90693)。", "locale": "zh-CN"}}}
{"pid": "P6867", "type": "P", "difficulty": 2, "samples": [["2 4\n0 2\n1 0\n", "2"], ["3 7\n0 3 2\n3 0 3\n2 1 0\n", "1"], ["4 7\n0 4 3 2\n4 0 4 1\n2 1 0 1\n3 2 3 0\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "COCI（克罗地亚）"], "title": "[COCI 2019/2020 #5] Politicari", "background": "", "description": "有 $n$ 个人互相批评。\n\n另提供矩阵 $A$。\n\n规则如下：\n\n- 第一次，第 $1$ 个人批评第 $2$ 个人。\n\n- 如果第 $i-1$ 次为第 $u$ 个人批评第 $v$ 个人，\n\n\t那么第 $i$ 次为第 $v$ 个人批评第 $A_{v,u}$ 个人。\n\n求第 $k$ 次是谁**进行**批评（注意：不是**被**批评）。", "inputFormat": "第一行：两个正整数，$n$ 和 $k$。\n\n以下 $n$ 行：矩阵 $A$。矩阵的主对角线（就是从左上到右下的那条对角线）全是 $0$，其他部分由从 $1$ 到 $n$ 的正整数组成。", "outputFormat": "一行：你的答案。", "hint": "### 数据范围\n\n- 对于 $35 pts$ 的数据，保证 $1\\leq k\\leq 10^5$。\n- 对于所有的数据，$2\\leq n\\leq 500$ 且 $1\\leq k\\leq 10^{18}$。\n\n### 说明\n\n**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #5](https://hsin.hr/coci/archive/2019_2020/contest5_tasks.pdf)  _T2 Političari_** ，译者 [90693](/user/90693)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2019/2020 #5] Politicari", "background": "", "description": "有 $n$ 个人互相批评。\n\n另提供矩阵 $A$。\n\n规则如下：\n\n- 第一次，第 $1$ 个人批评第 $2$ 个人。\n\n- 如果第 $i-1$ 次为第 $u$ 个人批评第 $v$ 个人，\n\n\t那么第 $i$ 次为第 $v$ 个人批评第 $A_{v,u}$ 个人。\n\n求第 $k$ 次是谁**进行**批评（注意：不是**被**批评）。", "inputFormat": "第一行：两个正整数，$n$ 和 $k$。\n\n以下 $n$ 行：矩阵 $A$。矩阵的主对角线（就是从左上到右下的那条对角线）全是 $0$，其他部分由从 $1$ 到 $n$ 的正整数组成。", "outputFormat": "一行：你的答案。", "hint": "### 数据范围\n\n- 对于 $35 pts$ 的数据，保证 $1\\leq k\\leq 10^5$。\n- 对于所有的数据，$2\\leq n\\leq 500$ 且 $1\\leq k\\leq 10^{18}$。\n\n### 说明\n\n**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #5](https://hsin.hr/coci/archive/2019_2020/contest5_tasks.pdf)  _T2 Političari_** ，译者 [90693](/user/90693)。", "locale": "zh-CN"}}}
{"pid": "P6868", "type": "P", "difficulty": 6, "samples": [["8\n1 1\n1 3\n2 2\n2 4\n3 1\n3 3\n4 2\n4 4\n", "DA\n1 5\n3 7\n2 6\n4 8"], ["6\n1 2\n1 3\n2 1\n2 4\n3 2\n3 3\n", "DA\n1 2\n3 4\n5 6"], ["2\n1 1\n2 2\n", "NE"], ["20\n62488 5330\n62488 5027\n76436 5027\n39827 79374\n95732 59715\n66222 46366\n8346 59715\n49581 53207\n66222 79374\n80123 46366\n76436 5330\n39590 5690\n82990 89723\n95732 89723\n8346 79295\n80123 16069\n39827 16069\n49581 5690\n82990 79295\n39590 53207\n", "DA\n3 11\n1 2\n16 10\n6 9\n4 17\n13 19\n15 7\n5 14\n12 20\n8 18"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "Special Judge", "COCI（克罗地亚）"], "title": "[COCI 2019/2020 #5] Matching", "background": "", "description": "给你二维平面上的 $n$ 个整点。保证 $\\forall a$，有至多两个形如 $(a,x)$ 的点；$\\forall b$，有至多两个形如 $(x,b)$ 的点。\n\n请你用 $n\\over 2$ 条线段连接这 $n$ 个点。要求每个点都是一条线段的端点。要求这些线段都是水平的或竖直的。要求这些线段都不相交。\n\n请你求出这是否可能。如果可能，请你输出任意一种方法。", "inputFormat": "- 第一行有一个偶正整数 $n$。\n\n- 接下来有 $n$ 行。第 $i$ 行有两个正整数 $x_i,y_i$，表示第 $i$ 个点的坐标。", "outputFormat": "如果不可能，请在一行输出 `NE`。\n\n如果可能，请在第一行输出 `DA`。在接下来的 $n\\over 2$ 行中各输出两个整数，表示一条线段（整数是端点的编号，从 $1$ 开始）。", "hint": "### 数据范围\n\n**本题捆绑测试。**\n\n- 对于 $5 pts$ 的数据：$2\\leq n\\leq 20$，且 $\\forall a$ ，有偶数个形如 $(a,x)$ 的点和偶数个形如 $(x,a)$ 的点。\n- 对于另外 $6 pts$ 的数据：$2\\leq n\\leq 20$。\n- 对于另外 $7 pts$ 的数据：$2\\leq n\\leq 40$。\n- 对于另外 $40 pts$ 的数据：$2\\leq n\\leq 2000$。\n- 对于所有的数据：$2\\leq n\\leq 100000$ 且 $1\\leq x_i,y_i\\leq 100000$。对于任何整数 $a$ ，有至多 $2$ 个点 $(a,x)$ 和 至多 $2$ 个点 $(x,a)$。\n\n### 说明\n\n**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #5](https://hsin.hr/coci/archive/2019_2020/contest5_tasks.pdf)  _T3 Matching_** ，译者 [90693](/user/90693)。\n\nspj by [90693](/user/90693)，有任何问题请直接私信或@。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2019/2020 #5] Matching", "background": "", "description": "给你二维平面上的 $n$ 个整点。保证 $\\forall a$，有至多两个形如 $(a,x)$ 的点；$\\forall b$，有至多两个形如 $(x,b)$ 的点。\n\n请你用 $n\\over 2$ 条线段连接这 $n$ 个点。要求每个点都是一条线段的端点。要求这些线段都是水平的或竖直的。要求这些线段都不相交。\n\n请你求出这是否可能。如果可能，请你输出任意一种方法。", "inputFormat": "- 第一行有一个偶正整数 $n$。\n\n- 接下来有 $n$ 行。第 $i$ 行有两个正整数 $x_i,y_i$，表示第 $i$ 个点的坐标。", "outputFormat": "如果不可能，请在一行输出 `NE`。\n\n如果可能，请在第一行输出 `DA`。在接下来的 $n\\over 2$ 行中各输出两个整数，表示一条线段（整数是端点的编号，从 $1$ 开始）。", "hint": "### 数据范围\n\n**本题捆绑测试。**\n\n- 对于 $5 pts$ 的数据：$2\\leq n\\leq 20$，且 $\\forall a$ ，有偶数个形如 $(a,x)$ 的点和偶数个形如 $(x,a)$ 的点。\n- 对于另外 $6 pts$ 的数据：$2\\leq n\\leq 20$。\n- 对于另外 $7 pts$ 的数据：$2\\leq n\\leq 40$。\n- 对于另外 $40 pts$ 的数据：$2\\leq n\\leq 2000$。\n- 对于所有的数据：$2\\leq n\\leq 100000$ 且 $1\\leq x_i,y_i\\leq 100000$。对于任何整数 $a$ ，有至多 $2$ 个点 $(a,x)$ 和 至多 $2$ 个点 $(x,a)$。\n\n### 说明\n\n**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #5](https://hsin.hr/coci/archive/2019_2020/contest5_tasks.pdf)  _T3 Matching_** ，译者 [90693](/user/90693)。\n\nspj by [90693](/user/90693)，有任何问题请直接私信或@。", "locale": "zh-CN"}}}
{"pid": "P6869", "type": "P", "difficulty": 4, "samples": [["4\n1 2 3 5\n1 3 2 4\n2 4 1 3\n", "10"], ["4\n1 4 5 5\n3 4 4 7\n2 4 2 6\n", "16"], ["5\n1 2 2 3\n1 3 2 3\n1 4 2 3\n1 5 2 3\n", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "最近公共祖先 LCA", "差分", "COCI（克罗地亚）"], "title": "[COCI 2019/2020 #5] Putovanje", "background": null, "description": "给你一棵有 $n$ 个点的树，节点编号从 $1$ 到 $n$。\n\n你会按编号从小到大顺序访问每个节点。\n\n经过树上的边需要收费。第 $i$ 条边有单程票（只能用一次）价格 $c_{i1}$ 和多程票（可以用无限次）价格 $c_{i2}$。你在访问途中可能会重复走一条边，所以多程票有时更划算。\n\n请你求出从 $1$ 访问到 $n$ 最少需要多少费用。", "inputFormat": "- 第一行：一个正整数 $n$。\n\n- 接下来的 $n-1$ 行描述 $n-1$ 条边：有 $4$ 个正整数 $a_i,b_i,c_{i1},c_{i2}$，表示有一条连接 $a_i$ 和 $b_i$ 的单程票价格为 $c_{i1}$、多程票价格为 $c_{i2}$ 的边。", "outputFormat": "一行一个正整数：你的答案。", "hint": "### 样例#1 解释\n\n- $1\\to 2$：多程票，费用 $5$。\n- $2\\to 1\\to 3$：$2\\to 1$ 使用买过的多程票，无费用；$1\\to 3$ 单程票，费用 $2$。\n- $3\\to 1\\to 2\\to 4$：$3\\to 1$ 单程票，费用 $2$；$1\\to 2$ 使用买过的多程票，无费用；$2\\to 4$ 单程票，费用 $1$。\n- 费用共 $5+2+2+1=10$。\n\n### 数据范围\n\n**本题捆绑测试。**\n\n- 对于 $20 pts$ 的数据，$2\\leq n\\leq 2000$。\n\n- 对于另外 $25 pts$ 的数据，每个城镇最多与另外两个城镇直接相连。\n\n- 对于所有的数据，$2\\leq n\\leq 2\\times10^5$，$1\\leq a_i,b_i\\leq n$，$1\\leq c_{i1}\\leq c_{i2}\\leq 10^5$。\n\n### 说明\n\n**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #5](https://hsin.hr/coci/archive/2019_2020/contest5_tasks.pdf)  _T4 Putovanje_**。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2019/2020 #5] Putovanje", "background": null, "description": "给你一棵有 $n$ 个点的树，节点编号从 $1$ 到 $n$。\n\n你会按编号从小到大顺序访问每个节点。\n\n经过树上的边需要收费。第 $i$ 条边有单程票（只能用一次）价格 $c_{i1}$ 和多程票（可以用无限次）价格 $c_{i2}$。你在访问途中可能会重复走一条边，所以多程票有时更划算。\n\n请你求出从 $1$ 访问到 $n$ 最少需要多少费用。", "inputFormat": "- 第一行：一个正整数 $n$。\n\n- 接下来的 $n-1$ 行描述 $n-1$ 条边：有 $4$ 个正整数 $a_i,b_i,c_{i1},c_{i2}$，表示有一条连接 $a_i$ 和 $b_i$ 的单程票价格为 $c_{i1}$、多程票价格为 $c_{i2}$ 的边。", "outputFormat": "一行一个正整数：你的答案。", "hint": "### 样例#1 解释\n\n- $1\\to 2$：多程票，费用 $5$。\n- $2\\to 1\\to 3$：$2\\to 1$ 使用买过的多程票，无费用；$1\\to 3$ 单程票，费用 $2$。\n- $3\\to 1\\to 2\\to 4$：$3\\to 1$ 单程票，费用 $2$；$1\\to 2$ 使用买过的多程票，无费用；$2\\to 4$ 单程票，费用 $1$。\n- 费用共 $5+2+2+1=10$。\n\n### 数据范围\n\n**本题捆绑测试。**\n\n- 对于 $20 pts$ 的数据，$2\\leq n\\leq 2000$。\n\n- 对于另外 $25 pts$ 的数据，每个城镇最多与另外两个城镇直接相连。\n\n- 对于所有的数据，$2\\leq n\\leq 2\\times10^5$，$1\\leq a_i,b_i\\leq n$，$1\\leq c_{i1}\\leq c_{i2}\\leq 10^5$。\n\n### 说明\n\n**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #5](https://hsin.hr/coci/archive/2019_2020/contest5_tasks.pdf)  _T4 Putovanje_**。", "locale": "zh-CN"}}}
{"pid": "P6870", "type": "P", "difficulty": 4, "samples": [["1\n", "1"], ["2\n", "3"], ["314\n", "192940893"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "数学", "2019", "组合数学", "排列组合", "容斥原理", "COCI（克罗地亚）"], "title": "[COCI 2019/2020 #5] Zapina", "background": null, "description": "有 $n$ 个**不同的**人和 $n$ 道**不同的**题。\n\n第 $i$ 个人开心当且仅当他被分配到 $i$ 道题。\n\n求让至少一个人开心的分配方案数。", "inputFormat": "一个正整数：$n$。", "outputFormat": "一个数字：你的答案 $\\bmod(10^9+7)$。", "hint": "### 数据范围\n\n**本题捆绑测试。**\n\n- 对于 $22$ pts 的数据，$2\\leq n\\leq 7$。\n- 对于另外 $33$ pts 的数据，$1\\leq n\\leq 20$。\n- 对于所有的数据，$1\\leq n\\leq 350$。\n\n### 样例 #2 解释\n\n有以下 $3$ 种方案：\n\n- 第一题给第一个人，第二题给第二个人。\n\n- 第二题给第一个人，第一题给第二个人。\n\n- 两题都给第二个人。\n\n### 说明\n\n**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #5](https://hsin.hr/coci/archive/2019_2020/contest5_tasks.pdf)  _T5 Zapina_** ，译者 [90693](/user/90693)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2019/2020 #5] Zapina", "background": null, "description": "有 $n$ 个**不同的**人和 $n$ 道**不同的**题。\n\n第 $i$ 个人开心当且仅当他被分配到 $i$ 道题。\n\n求让至少一个人开心的分配方案数。", "inputFormat": "一个正整数：$n$。", "outputFormat": "一个数字：你的答案 $\\bmod(10^9+7)$。", "hint": "### 数据范围\n\n**本题捆绑测试。**\n\n- 对于 $22$ pts 的数据，$2\\leq n\\leq 7$。\n- 对于另外 $33$ pts 的数据，$1\\leq n\\leq 20$。\n- 对于所有的数据，$1\\leq n\\leq 350$。\n\n### 样例 #2 解释\n\n有以下 $3$ 种方案：\n\n- 第一题给第一个人，第二题给第二个人。\n\n- 第二题给第一个人，第一题给第二个人。\n\n- 两题都给第二个人。\n\n### 说明\n\n**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #5](https://hsin.hr/coci/archive/2019_2020/contest5_tasks.pdf)  _T5 Zapina_** ，译者 [90693](/user/90693)。", "locale": "zh-CN"}}}
{"pid": "P6871", "type": "P", "difficulty": 4, "samples": [["1 0 10 ", "0"], ["1 2 10", "1"], ["3 16 10", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "深度优先搜索 DFS", "COCI（克罗地亚）", "折半搜索 meet in the middle"], "title": "[COCI 2013/2014 #6] HASH", "background": "Mirko 正在研究一个哈希函数。 ", "description": "此哈希函数如此定义：\n\n- $f(\\rm{NULL})=0$\n- $f(a_i+s_i)=((f(s_i)\\times33)\\operatorname{xor}\\ \\operatorname{ord}(a_i))\\bmod MOD$\n\n其中 $a_i$ 代表一个字符，$s_i$ 代表一个字符串，均由小写字母组成。\n\n- $\\operatorname{xor}$ 代表按位异或算符。\n- $\\operatorname{ord(letter)}$ 代表字母中字母的序数（如：$\\operatorname{ord(a)=1}$，$\\operatorname{ord(z)= 26}$）。\n\n$MOD$ 是 $2^m$ 形式的整数。\n\n当 $m=10$ 时，哈希函数的一些值如下：\n\n- $f(\\texttt{a})=1$\n- $f(\\texttt{aa})=32$\n- $f(\\texttt{kit})=438$\n\n请问有多少个单词的哈希值为 $k$ 且长度为 $n$？", "inputFormat": "输入一行，包含三个整数 $n$，$k$ 和 $m$。", "outputFormat": "输出一行，哈希值为 $k$ 且长度为 $n$ 的单词个数。", "hint": "#### 【样例解释】\n#### 样例 1 解释\n字母表中的所有字符的 $\\text{ord}$ 值均不为 $0$。\n#### 样例 2 解释\n单词`b`。\n#### 样例 3 解释\n词语为`dxl`，`hph`，`lxd` 和 `xpx`。\n\n#### 【数据规模与约定】\n$1\\le n\\le 10$，$0\\le k<2^m$，$6\\le m\\le 25$。\n\n#### 【说明】\n**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #6](https://hsin.hr/coci/archive/2013_2014/contest6_tasks.pdf)  _T5 HASH_。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2013/2014 #6] HASH", "background": "Mirko 正在研究一个哈希函数。 ", "description": "此哈希函数如此定义：\n\n- $f(\\rm{NULL})=0$\n- $f(a_i+s_i)=((f(s_i)\\times33)\\operatorname{xor}\\ \\operatorname{ord}(a_i))\\bmod MOD$\n\n其中 $a_i$ 代表一个字符，$s_i$ 代表一个字符串，均由小写字母组成。\n\n- $\\operatorname{xor}$ 代表按位异或算符。\n- $\\operatorname{ord(letter)}$ 代表字母中字母的序数（如：$\\operatorname{ord(a)=1}$，$\\operatorname{ord(z)= 26}$）。\n\n$MOD$ 是 $2^m$ 形式的整数。\n\n当 $m=10$ 时，哈希函数的一些值如下：\n\n- $f(\\texttt{a})=1$\n- $f(\\texttt{aa})=32$\n- $f(\\texttt{kit})=438$\n\n请问有多少个单词的哈希值为 $k$ 且长度为 $n$？", "inputFormat": "输入一行，包含三个整数 $n$，$k$ 和 $m$。", "outputFormat": "输出一行，哈希值为 $k$ 且长度为 $n$ 的单词个数。", "hint": "#### 【样例解释】\n#### 样例 1 解释\n字母表中的所有字符的 $\\text{ord}$ 值均不为 $0$。\n#### 样例 2 解释\n单词`b`。\n#### 样例 3 解释\n词语为`dxl`，`hph`，`lxd` 和 `xpx`。\n\n#### 【数据规模与约定】\n$1\\le n\\le 10$，$0\\le k<2^m$，$6\\le m\\le 25$。\n\n#### 【说明】\n**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #6](https://hsin.hr/coci/archive/2013_2014/contest6_tasks.pdf)  _T5 HASH_。**", "locale": "zh-CN"}}}
{"pid": "P6872", "type": "P", "difficulty": 2, "samples": [["3\na*d\nabcd\nanestonestod\nfacebook", "DA\nDA\nNE"], ["6\nh*n\nhuhovdjestvarnomozedocisvastan\nhonijezakon\natila\nje\nbio\nhun ", "DA\nDA\nNE\nNE\nNE\nDA"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["2013", "COCI（克罗地亚）"], "title": "[COCI 2013/2014 #6] VJEKO", "background": "Vjeko 在业余时间喜欢浏览目录中的文件。", "description": "模式串是由英文字母的小写字母和一个星号组成的字符串。\n\n星号可以替换为由小写字母组成的字符串，如果通过替换能使模式字符串等于文件名，则文件名与模式串匹配。\n\n举个例子，字符串 `abcd`，`ad`和`anestonestod` 都与模式 `a*d` 匹配，而字符串 `bcd` 则不匹配。\n\n编写一个程序，该程序将给出一个模式和一些文件名，输出是否与该模式匹配。", "inputFormat": "输入的第一行包含整数 $N$，即文件数。\n\n输入的第二行包含一个字符串，该字符串仅由英文字母的小写字母和一个星号组成。 \n\n字符串的长度将不超过 $100$，并且星号不会位于字符串的开头或结尾。\n\n接下来的 $N$ 行中的每一行都包含文件名。\n\n文件名仅由英文字母的小写字母组成，且长度不超过  $100$。", "outputFormat": "输出共 $N$ 行。\n\n对于每一个文件名，匹配输出 `DA`，反之输出 `NE`。", "hint": "#### 【数据规模与约定】\n$1\\le N\\le 100$。\n\n#### 【说明】\n**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #6](https://hsin.hr/coci/archive/2013_2014/contest6_tasks.pdf)  _T1 VJEKO_。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2013/2014 #6] VJEKO", "background": "Vjeko 在业余时间喜欢浏览目录中的文件。", "description": "模式串是由英文字母的小写字母和一个星号组成的字符串。\n\n星号可以替换为由小写字母组成的字符串，如果通过替换能使模式字符串等于文件名，则文件名与模式串匹配。\n\n举个例子，字符串 `abcd`，`ad`和`anestonestod` 都与模式 `a*d` 匹配，而字符串 `bcd` 则不匹配。\n\n编写一个程序，该程序将给出一个模式和一些文件名，输出是否与该模式匹配。", "inputFormat": "输入的第一行包含整数 $N$，即文件数。\n\n输入的第二行包含一个字符串，该字符串仅由英文字母的小写字母和一个星号组成。 \n\n字符串的长度将不超过 $100$，并且星号不会位于字符串的开头或结尾。\n\n接下来的 $N$ 行中的每一行都包含文件名。\n\n文件名仅由英文字母的小写字母组成，且长度不超过  $100$。", "outputFormat": "输出共 $N$ 行。\n\n对于每一个文件名，匹配输出 `DA`，反之输出 `NE`。", "hint": "#### 【数据规模与约定】\n$1\\le N\\le 100$。\n\n#### 【说明】\n**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #6](https://hsin.hr/coci/archive/2013_2014/contest6_tasks.pdf)  _T1 VJEKO_。**", "locale": "zh-CN"}}}
{"pid": "P6873", "type": "P", "difficulty": 2, "samples": [["9\nthe\nquick\nbrown\nfox\njumps\nover\na\nsleazy\ndog", "2"], ["3\na\nb\nc ", "0"], ["15\nabcdefghijkl\nbcdefghijklm\ncdefghijklmn\ndefghijklmno\nefghijklmnop\nfghijklmnopq\nghijklmnopqr\nhijklmnopqrs\nijklmnopqrst\njklmnopqrstu\nklmnopqrstuv\nlmnopqrstuvw\nmnopqrstuvwx\nnopqrstuvwxy\nopqrstuvwxyz ", "8189"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["2013", "深度优先搜索 DFS", "COCI（克罗地亚）"], "title": "[COCI 2013/2014 #6]  FONT", "background": "", "description": "我们定义测试句为包含所有小写英文字母的字符串。\n\n现在给你 $N$ 个单词，请问这些单词最多能组成多少个测试句。\n\n每个单词只能在测试句中使用一次，而单词在句子中的顺序不考虑，即 `uvijek jedem sarmu` 和 `jedem sarmu uvijek` 是相等的。", "inputFormat": "输入的第一行包含整数 $N$，即单词个数。\n\n接下来 $N$ 行，每行一个单词，其长度不超过 $100$ 。\n\n保证所有单词不同。", "outputFormat": "输出最多能组成多少个测试句。", "hint": "#### 【数据范围与约定】\n$1\\le N\\le 25$。\n#### 【样例解释】\n\n#### 样例 1 解释\n\n除 `a` 外的所有单词都必须在测试句子中使用，因为每个单词都包含一个在其他单词中找不到的字母。因此，有两个方案。第一个是包含所有单词的句子，第二个是由除 `a` 之外的所有单词组成的句子。\n\n#### 样例 3 解释\n这个样例由英语小写连续字母组成。\n\n#### 【说明】\n\n**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #6](https://hsin.hr/coci/archive/2013_2014/contest6_tasks.pdf) _T2  FONT。_**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2013/2014 #6]  FONT", "background": "", "description": "我们定义测试句为包含所有小写英文字母的字符串。\n\n现在给你 $N$ 个单词，请问这些单词最多能组成多少个测试句。\n\n每个单词只能在测试句中使用一次，而单词在句子中的顺序不考虑，即 `uvijek jedem sarmu` 和 `jedem sarmu uvijek` 是相等的。", "inputFormat": "输入的第一行包含整数 $N$，即单词个数。\n\n接下来 $N$ 行，每行一个单词，其长度不超过 $100$ 。\n\n保证所有单词不同。", "outputFormat": "输出最多能组成多少个测试句。", "hint": "#### 【数据范围与约定】\n$1\\le N\\le 25$。\n#### 【样例解释】\n\n#### 样例 1 解释\n\n除 `a` 外的所有单词都必须在测试句子中使用，因为每个单词都包含一个在其他单词中找不到的字母。因此，有两个方案。第一个是包含所有单词的句子，第二个是由除 `a` 之外的所有单词组成的句子。\n\n#### 样例 3 解释\n这个样例由英语小写连续字母组成。\n\n#### 【说明】\n\n**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #6](https://hsin.hr/coci/archive/2013_2014/contest6_tasks.pdf) _T2  FONT。_**", "locale": "zh-CN"}}}
{"pid": "P6874", "type": "P", "difficulty": 4, "samples": [["3\n1 2 3\n3 2 2", "3"], ["5\n2 3 0 1 4\n3 3 2 3 1", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["贪心", "2013", "排序", "COCI（克罗地亚）"], "title": "[COCI 2013/2014 #6] KOCKICE", "background": "堆积木！", "description": "Mirko 和 Slavko 在玩积木。他们俩都有自己的一堆砖头。一共有 $N$ 列砖头（其中 $N$ 为奇数）。\n\nMirko 桩的第 $i$ 列中有 $m_i$ 块砖，而 Slavko 每列有 $s_i$ 个。\n\n他们决定创建两堆一样的砖头，这几堆的高度首先是严格下降，然后是严格上升（参见下方右图），相邻列的高度恰好相差 $1$（见图）。最低的列的左右两侧的砖头数量必须相同。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aeiop47b.png)\n\n允许两种操作：\n\n- 从某一列的顶部移除一块砖。\n- 在某一列的顶部加上一块砖。\n\n问在满足上述要求的情况下，最少要几次操作？", "inputFormat": "输入的第一行包含一个奇数 $N$，即两个人砖头的堆数。\n\n输入的第二行包含 $N$ 个整数 $m_i$，即 Mirko 堆中的列高。\n\n输入的第三行包含 $N$ 个整数 $s_i$，即 Slavko 堆中的列高。", "outputFormat": "输出所需的最少操作次数。", "hint": "#### 样例 1 解释\nMirko 在其桩的第一列的顶部放置了两块砖，而 Slavko 在他桩的第三列的顶部放置了一块砖。\n\n#### 【数据规模与约定】\n\n- 对于 $40\\%$ 的数据，满足 $1\\le N\\le 1000$，$0\\le m_i,s_i\\le 1000$。\n- 对于 $100\\%$ 的数据，满足 $1\\le N\\le 3\\times 10^5$，$0\\le m_i,s_i\\le 10^{12}$。\n\n#### 【说明】\n**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #6](https://hsin.hr/coci/archive/2013_2014/contest6_tasks.pdf)  _T3 KOCKICE_。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2013/2014 #6] KOCKICE", "background": "堆积木！", "description": "Mirko 和 Slavko 在玩积木。他们俩都有自己的一堆砖头。一共有 $N$ 列砖头（其中 $N$ 为奇数）。\n\nMirko 桩的第 $i$ 列中有 $m_i$ 块砖，而 Slavko 每列有 $s_i$ 个。\n\n他们决定创建两堆一样的砖头，这几堆的高度首先是严格下降，然后是严格上升（参见下方右图），相邻列的高度恰好相差 $1$（见图）。最低的列的左右两侧的砖头数量必须相同。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aeiop47b.png)\n\n允许两种操作：\n\n- 从某一列的顶部移除一块砖。\n- 在某一列的顶部加上一块砖。\n\n问在满足上述要求的情况下，最少要几次操作？", "inputFormat": "输入的第一行包含一个奇数 $N$，即两个人砖头的堆数。\n\n输入的第二行包含 $N$ 个整数 $m_i$，即 Mirko 堆中的列高。\n\n输入的第三行包含 $N$ 个整数 $s_i$，即 Slavko 堆中的列高。", "outputFormat": "输出所需的最少操作次数。", "hint": "#### 样例 1 解释\nMirko 在其桩的第一列的顶部放置了两块砖，而 Slavko 在他桩的第三列的顶部放置了一块砖。\n\n#### 【数据规模与约定】\n\n- 对于 $40\\%$ 的数据，满足 $1\\le N\\le 1000$，$0\\le m_i,s_i\\le 1000$。\n- 对于 $100\\%$ 的数据，满足 $1\\le N\\le 3\\times 10^5$，$0\\le m_i,s_i\\le 10^{12}$。\n\n#### 【说明】\n**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #6](https://hsin.hr/coci/archive/2013_2014/contest6_tasks.pdf)  _T3 KOCKICE_。**", "locale": "zh-CN"}}}
{"pid": "P6875", "type": "P", "difficulty": 5, "samples": [["2\n1 3\n5 1 ", "3"], ["3\n2 2\n1 1\n3 1 ", "5"], ["4\n7 5\n-9 11\n11 9\n0 20 ", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["2013", "COCI（克罗地亚）"], "title": "[COCI 2013/2014 #6] KRUŽNICE", "background": "", "description": "现在有 $N$ 个以 $x$ 轴为中心的互不相交的圆，但圆周可以接触。请问这些圆把平面分成多少块？", "inputFormat": "输入的第一行包含整数 $N$，即圆的数目。\n\n下列n行中的每一个包含两个整数 $x_i$ 和 $r_i$， $x_i$ 表示第 $i$ 个圆的 $x$ 坐标，$r_i$ 表示第 $i$ 个圆的半径。\n\n输入中的所有圆保证都是唯一的。", "outputFormat": "输出这些圆把平面分成多少区域。", "hint": "#### 【样例解释】\n#### 样例 3 解释\n该样例对应下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/38z2b5fh.png)\n\n#### 【数据规模与约定】\n- 对于 $40\\%$ 的数据，$1 \\le N \\le 5\\times 10^3$。\n- 对于 $100\\%$ 的数据，$1 \\le N \\le 3\\times 10^5,-10^9 \\leq x_i \\leq 10^9$，$1 \\leq r_i \\leq 10^9$。\n#### 【说明】\n**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #6](https://hsin.hr/coci/archive/2013_2014/contest6_tasks.pdf) _T4 KRUŽNICE。_**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2013/2014 #6] KRUŽNICE", "background": "", "description": "现在有 $N$ 个以 $x$ 轴为中心的互不相交的圆，但圆周可以接触。请问这些圆把平面分成多少块？", "inputFormat": "输入的第一行包含整数 $N$，即圆的数目。\n\n下列n行中的每一个包含两个整数 $x_i$ 和 $r_i$， $x_i$ 表示第 $i$ 个圆的 $x$ 坐标，$r_i$ 表示第 $i$ 个圆的半径。\n\n输入中的所有圆保证都是唯一的。", "outputFormat": "输出这些圆把平面分成多少区域。", "hint": "#### 【样例解释】\n#### 样例 3 解释\n该样例对应下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/38z2b5fh.png)\n\n#### 【数据规模与约定】\n- 对于 $40\\%$ 的数据，$1 \\le N \\le 5\\times 10^3$。\n- 对于 $100\\%$ 的数据，$1 \\le N \\le 3\\times 10^5,-10^9 \\leq x_i \\leq 10^9$，$1 \\leq r_i \\leq 10^9$。\n#### 【说明】\n**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #6](https://hsin.hr/coci/archive/2013_2014/contest6_tasks.pdf) _T4 KRUŽNICE。_**", "locale": "zh-CN"}}}
{"pid": "P6876", "type": "P", "difficulty": 0, "samples": [["2\n1 1\n3 3 ", "1 3"], ["3\n2 5\n5 2\n3 3 ", "3 5\n5 3 "], ["5\n1 3\n2 5\n3 4\n4 1\n5 2 ", "1 5\n3 3\n3 5\n4 2\n4 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["2013", "COCI（克罗地亚）"], "title": "[COCI 2013/2014 #6] GRAŠKRIŽJA（征集spj）", "background": "", "description": "有很多纵横交错的街道，街道均为双向。水平和垂直街道的交叉口称为十字路口。\n\n现决定在 $N$ 个十字路口设红绿灯，若两个十字路口间的一条路无红绿灯则转弯危险，反之安全。\n\n只要在每两个红绿灯之间有至少一条最短的路径是安全的就符合要求，你需要设置一些额外的红绿灯以满足要求。", "inputFormat": "第一行输入由整数 $N$ 组成，即最初的红绿灯数。\n\n接下来 $N$ 行，每行两个整数 $x_i$ 和 $y_i$，表示第 $i$ 个红绿灯的坐标。\n\n所有的红绿灯的坐标互不相同。", "outputFormat": "输出新红绿灯的位置，允许在同一位置放置多个红绿灯，新增红绿灯数量必须少于 $7\\times 10^5$ 个。", "hint": "#### 【数据规模与约定】\n- $2 \\leq N \\leq 5\\times 10^4$。\n- $1 \\leq x_i,y_i \\leq 5\\times 10^4$。\n#### 【说明】\n\n**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #6](https://hsin.hr/coci/archive/2013_2014/contest6_tasks.pdf) _T6 GRAŠKRIŽJA。_**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2013/2014 #6] GRAŠKRIŽJA（征集spj）", "background": "", "description": "有很多纵横交错的街道，街道均为双向。水平和垂直街道的交叉口称为十字路口。\n\n现决定在 $N$ 个十字路口设红绿灯，若两个十字路口间的一条路无红绿灯则转弯危险，反之安全。\n\n只要在每两个红绿灯之间有至少一条最短的路径是安全的就符合要求，你需要设置一些额外的红绿灯以满足要求。", "inputFormat": "第一行输入由整数 $N$ 组成，即最初的红绿灯数。\n\n接下来 $N$ 行，每行两个整数 $x_i$ 和 $y_i$，表示第 $i$ 个红绿灯的坐标。\n\n所有的红绿灯的坐标互不相同。", "outputFormat": "输出新红绿灯的位置，允许在同一位置放置多个红绿灯，新增红绿灯数量必须少于 $7\\times 10^5$ 个。", "hint": "#### 【数据规模与约定】\n- $2 \\leq N \\leq 5\\times 10^4$。\n- $1 \\leq x_i,y_i \\leq 5\\times 10^4$。\n#### 【说明】\n\n**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #6](https://hsin.hr/coci/archive/2013_2014/contest6_tasks.pdf) _T6 GRAŠKRIŽJA。_**", "locale": "zh-CN"}}}
{"pid": "P6877", "type": "P", "difficulty": 4, "samples": [["3\n4 3 7 6\n2 6 4", "2 2 1 1"], ["5\n4 7 9 10 11 12\n3 5 7 9 11", "4 4 3 2 2 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2020", "JOI（日本）"], "title": "[JOI 2020 Final] 只不过是长的领带 / Just Long Neckties", "background": "", "description": "JOI 公司发明了一种领带，一共有 $N+1$ 条领带，编号为 $1$ 到 $N+1$，第 $i$ 条领带的长度为 $A_i$。\n\nJOI 公司开了一个派对，派对中有 $N$ 名员工，第 $j$ 名员工刚开始戴了长度为 $B_j$ 的领带。\n\n派对这样举行：\n\n1. 首先，JOI 公司的老板 JOI 君选出一条领带拿走。\n2. 然后，每个员工选一条领带，保证没有两名员工选了相同的领带。\n3. 最后，他们取下最先戴的领带，戴上选择的领带。\n\n如果一名员工刚开始戴的领带长度为 $b$，选择的领带长度为 $a$，那么他就会产生 $\\max\\{a-b,0\\}$ 的奇怪感，整场派对的奇怪程度为所有员工的奇怪感的最大值。\n\n于是 JOI 君定义 $C_k$ 为他选出第 $k$ 条领带后的最小奇怪程度。\n\nJOI 君想知道 $C_k$ 的具体值。", "inputFormat": "第一行一个整数 $N$ 代表员工数。       \n第二行 $N+1$ 个整数 $A_i$ 代表每个领带的长度。     \n第三行 $N$ 个整数 $B_j$ 代表每个人最开始戴的领带的长度。", "outputFormat": "一行 $N+1$ 个整数 $C_k$ 代表选出每个领带后的最小奇怪程度。", "hint": "#### 样例 1 解释\n\n让我们假设 JOI 君选择了第 $4$ 条领带，那么员工们可以这么选择：\n\n- 第 $1$ 名员工选择第 $1$ 条领带，产生奇怪感 $2$\n- 第 $2$ 名员工选择第 $2$ 条领带，产生奇怪感 $0$\n- 第 $3$ 名员工选择第 $3$ 条领带，产生奇怪感 $3$\n\n奇怪程度为 $3$。\n\n但我们还可以继续减小奇怪程度：\n\n- 第 $1$ 名员工选择第 $2$ 条领带，产生奇怪感 $1$\n- 第 $2$ 名员工选择第 $3$ 条领带，产生奇怪感 $1$\n- 第 $3$ 名员工选择第 $1$ 条领带，产生奇怪感 $0$\n\n奇怪程度为 $1$。\n\n因此 $C_4=1$。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（1 pts）：$N \\le 10$。\n- Subtask 2（8 pts）：$N \\le 2000$。\n- Subtask 3（91 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le N \\le 2 \\times 10^5$。\n- $1 \\le A_i \\le 10^9$。\n- $1 \\le B_j \\le 10^9$。\n\n#### 说明\n\n翻译自 [第19回日本情報オリンピック　本選](https://www.ioi-jp.org/joi/2019/2020-ho/index.html) [A 長いだけのネクタイ](https://www.ioi-jp.org/joi/2019/2020-ho/2020-ho-t1.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI 2020 Final] 只不过是长的领带 / Just Long Neckties", "background": "", "description": "JOI 公司发明了一种领带，一共有 $N+1$ 条领带，编号为 $1$ 到 $N+1$，第 $i$ 条领带的长度为 $A_i$。\n\nJOI 公司开了一个派对，派对中有 $N$ 名员工，第 $j$ 名员工刚开始戴了长度为 $B_j$ 的领带。\n\n派对这样举行：\n\n1. 首先，JOI 公司的老板 JOI 君选出一条领带拿走。\n2. 然后，每个员工选一条领带，保证没有两名员工选了相同的领带。\n3. 最后，他们取下最先戴的领带，戴上选择的领带。\n\n如果一名员工刚开始戴的领带长度为 $b$，选择的领带长度为 $a$，那么他就会产生 $\\max\\{a-b,0\\}$ 的奇怪感，整场派对的奇怪程度为所有员工的奇怪感的最大值。\n\n于是 JOI 君定义 $C_k$ 为他选出第 $k$ 条领带后的最小奇怪程度。\n\nJOI 君想知道 $C_k$ 的具体值。", "inputFormat": "第一行一个整数 $N$ 代表员工数。       \n第二行 $N+1$ 个整数 $A_i$ 代表每个领带的长度。     \n第三行 $N$ 个整数 $B_j$ 代表每个人最开始戴的领带的长度。", "outputFormat": "一行 $N+1$ 个整数 $C_k$ 代表选出每个领带后的最小奇怪程度。", "hint": "#### 样例 1 解释\n\n让我们假设 JOI 君选择了第 $4$ 条领带，那么员工们可以这么选择：\n\n- 第 $1$ 名员工选择第 $1$ 条领带，产生奇怪感 $2$\n- 第 $2$ 名员工选择第 $2$ 条领带，产生奇怪感 $0$\n- 第 $3$ 名员工选择第 $3$ 条领带，产生奇怪感 $3$\n\n奇怪程度为 $3$。\n\n但我们还可以继续减小奇怪程度：\n\n- 第 $1$ 名员工选择第 $2$ 条领带，产生奇怪感 $1$\n- 第 $2$ 名员工选择第 $3$ 条领带，产生奇怪感 $1$\n- 第 $3$ 名员工选择第 $1$ 条领带，产生奇怪感 $0$\n\n奇怪程度为 $1$。\n\n因此 $C_4=1$。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（1 pts）：$N \\le 10$。\n- Subtask 2（8 pts）：$N \\le 2000$。\n- Subtask 3（91 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le N \\le 2 \\times 10^5$。\n- $1 \\le A_i \\le 10^9$。\n- $1 \\le B_j \\le 10^9$。\n\n#### 说明\n\n翻译自 [第19回日本情報オリンピック　本選](https://www.ioi-jp.org/joi/2019/2020-ho/index.html) [A 長いだけのネクタイ](https://www.ioi-jp.org/joi/2019/2020-ho/2020-ho-t1.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6878", "type": "P", "difficulty": 4, "samples": [["10 2\nOJIJOIOIIJ", "2"], ["9 3\nJJJOOOIII\n", "0"], ["9 1\nIIIOOOJJJ\n", "-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2020", "二分", "前缀和", "JOI（日本）"], "title": "[JOI 2020 Final] JJOOII 2", "background": "", "description": "定义有连续 $K$ 个 $\\tt J$ 和连续 $K$ 个 $\\tt O$ 和连续 $K$ 个 $\\tt I$ 组成的字符串为 $K$ 阶 JOI 串。\n\n比如，$\\tt JJOOII$ 为 $2$ 阶 JOI 串，**但是，注意要有顺序**，比如 $\\tt OOJJII$ 就不是 $2$ 阶 JOI 串。\n\n现在，给定一个长度为 $N$ 的字符串 $S$，可以对他进行 $3$ 种操作：\n\n- 操作 $1$：删除 $S$ 开头的字符\n- 操作 $2$：删除 $S$ 结尾的字符\n- 操作 $3$：删除 $S$ 除了开头和结尾之外的一个字符\n\n我们要通过这些操作让 $S$ 变为 $K$ 阶 JOI 串。\n\n但是，我们想让操作 $3$ 尽量的少。\n\n所以我们想知道，变为 $K$ 阶 JOI 串操作 $3$ 最少需要进行多少次？\n\n如果不能变为 $K$ 阶 JOI 串，那么输出 $-1$。", "inputFormat": "第一行两个整数 $N,K$ 代表字符串长度和要构造的 JOI 串的阶数。         \n第二行 $N$ 个字符代表字符串 $S$。", "outputFormat": "一行一个整数代表操作 $3$ 的最小进行次数。        \n如果不能变为 $K$ 阶 JOI 串，那么输出 $-1$。", "hint": "#### 样例 1 解释\n\n1. 进行一次操作 $1$，变为 $\\tt JIJOIOIIJ$。\n2. 进行一次操作 $2$，变为 $\\tt JIJOIOII$。\n3. 进行一次操作 $3$，删掉字符 $2$，变为 $\\tt JJOIOII$。\n4. 进行一次操作 $3$，删掉字符 $4$，变为 $\\tt JJOOII$。\n\n#### 样例 2 解释\n\n$\\tt JJJOOOIII$ 已经是 $3$ 阶 JOI 串了，所以不需要进行操作。\n\n#### 样例 3 解释\n\n$\\tt IIIOOOJJJ$ 无法变为 $1$ 阶 JOI 串，无解。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（1 pts）：$N \\le 21$。\n- Subtask 2（12 pts）：$N \\le 3000$。\n- Subtask 3（87 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据：\n\n- $3 \\le N \\le 2 \\times 10^5$。\n- $1 \\le K \\le \\dfrac{N}{3}$。\n- $S$ 只包含 $\\tt J$，$\\tt O$，$\\tt I$ 且长度为 $N$。\n\n#### 说明\n\n翻译自 [第19回日本情報オリンピック　本選](https://www.ioi-jp.org/joi/2019/2020-ho/index.html) [B JJOOII 2](https://www.ioi-jp.org/joi/2019/2020-ho/2020-ho-t2.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI 2020 Final] JJOOII 2", "background": "", "description": "定义有连续 $K$ 个 $\\tt J$ 和连续 $K$ 个 $\\tt O$ 和连续 $K$ 个 $\\tt I$ 组成的字符串为 $K$ 阶 JOI 串。\n\n比如，$\\tt JJOOII$ 为 $2$ 阶 JOI 串，**但是，注意要有顺序**，比如 $\\tt OOJJII$ 就不是 $2$ 阶 JOI 串。\n\n现在，给定一个长度为 $N$ 的字符串 $S$，可以对他进行 $3$ 种操作：\n\n- 操作 $1$：删除 $S$ 开头的字符\n- 操作 $2$：删除 $S$ 结尾的字符\n- 操作 $3$：删除 $S$ 除了开头和结尾之外的一个字符\n\n我们要通过这些操作让 $S$ 变为 $K$ 阶 JOI 串。\n\n但是，我们想让操作 $3$ 尽量的少。\n\n所以我们想知道，变为 $K$ 阶 JOI 串操作 $3$ 最少需要进行多少次？\n\n如果不能变为 $K$ 阶 JOI 串，那么输出 $-1$。", "inputFormat": "第一行两个整数 $N,K$ 代表字符串长度和要构造的 JOI 串的阶数。         \n第二行 $N$ 个字符代表字符串 $S$。", "outputFormat": "一行一个整数代表操作 $3$ 的最小进行次数。        \n如果不能变为 $K$ 阶 JOI 串，那么输出 $-1$。", "hint": "#### 样例 1 解释\n\n1. 进行一次操作 $1$，变为 $\\tt JIJOIOIIJ$。\n2. 进行一次操作 $2$，变为 $\\tt JIJOIOII$。\n3. 进行一次操作 $3$，删掉字符 $2$，变为 $\\tt JJOIOII$。\n4. 进行一次操作 $3$，删掉字符 $4$，变为 $\\tt JJOOII$。\n\n#### 样例 2 解释\n\n$\\tt JJJOOOIII$ 已经是 $3$ 阶 JOI 串了，所以不需要进行操作。\n\n#### 样例 3 解释\n\n$\\tt IIIOOOJJJ$ 无法变为 $1$ 阶 JOI 串，无解。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（1 pts）：$N \\le 21$。\n- Subtask 2（12 pts）：$N \\le 3000$。\n- Subtask 3（87 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据：\n\n- $3 \\le N \\le 2 \\times 10^5$。\n- $1 \\le K \\le \\dfrac{N}{3}$。\n- $S$ 只包含 $\\tt J$，$\\tt O$，$\\tt I$ 且长度为 $N$。\n\n#### 说明\n\n翻译自 [第19回日本情報オリンピック　本選](https://www.ioi-jp.org/joi/2019/2020-ho/index.html) [B JJOOII 2](https://www.ioi-jp.org/joi/2019/2020-ho/2020-ho-t2.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6879", "type": "P", "difficulty": 5, "samples": [["6 25\n3 4 7 17 21 23\n11 7 17 10 8 10", "4"], ["5 20\n4 5 8 13 17\n18 23 15 7 10\n", "5"], ["4 19\n3 7 12 14\n2 0 5 4\n", "0"], ["10 87\n9 23 33 38 42 44 45 62 67 78\n15 91 7 27 31 53 12 91 89 46\n", "5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2020", "区间 DP", "JOI（日本）"], "title": "[JOI 2020 Final] 集邮比赛 3 / Collecting Stamps 3", "background": "", "description": "给定一个周长为 $L$ 的圆，从一个点出发，有 $N$ 个黑白熊雕像，编号为 $1$ 到 $N$，第 $i$ 个雕像在顺时针 $X_i$ 米处，如果你没有在 $T_i$ 秒内收集到这个黑白熊雕像，那么这个雕像就会发出“唔噗噗噗”的声音然后爆炸。\n\n现在 JOI 君在这个点，他每一秒可以移动一米，并且他可以顺时针或者逆时针的移动。\n\nJOI 君想问，他最多能收集到多少个黑白熊雕像？", "inputFormat": "第一行两个整数 $N,L$ 代表雕像数和圆的周长。      \n第二行 $N$ 个整数 $X_i$ 代表每个雕像在顺时针多少米处。       \n第三行 $N$ 个整数 $T_i$ 代表每个雕像需要在多少秒内拿到。", "outputFormat": "一行一个整数代表答案。", "hint": "#### 样例 1 解释\n\nJOI 君可以按照如下策略拿到 $4$ 个黑白熊雕像：\n\n|方向|路程|总时间|第几个雕像|能否拿到|\n|:-:|:-:|:-:|:-:|:-:|\n|逆时针|$2$ 米|$2$ 秒|$6$|$\\sqrt{}$|\n|逆时针|$2$ 米|$4$ 秒|$5$|$\\sqrt{}$|\n|顺时针|$7$ 米|$11$ 秒|$1$|$\\sqrt{}$|\n|顺时针|$1$ 米|$12$ 秒|$2$|$\\times$|\n|顺时针|$3$ 米|$15$ 秒|$3$|$\\sqrt{}$|\n\n#### 样例 2 解释\n\nJOI 君可以直接一直逆时针走。\n\n#### 样例 3 解释\n\nJOI 君无法得到任何一个雕像。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n- Subtask 1（5 pts）：$N \\le 12$，$L \\le 200$，$X_i \\le 200$。\n- Subtask 2（10 pts）：$N \\le 15$。\n- Subtask 3（10 pts）：$L \\le 200$，$T_i \\le 200$。\n- Subtaks 4（75 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le N \\le 200$。\n- $2 \\le L \\le 10^9$。\n- $1 \\le X_i<L$。\n- $X_i < X_{i+1}$。\n- $0 \\le T_i \\le 10^9$。\n\n#### 说明\n\n翻译自 [第19回日本情報オリンピック　本選](https://www.ioi-jp.org/joi/2019/2020-ho/index.html) [C スタンプラリー 3](https://www.ioi-jp.org/joi/2019/2020-ho/2020-ho-t3.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI 2020 Final] 集邮比赛 3 / Collecting Stamps 3", "background": "", "description": "给定一个周长为 $L$ 的圆，从一个点出发，有 $N$ 个黑白熊雕像，编号为 $1$ 到 $N$，第 $i$ 个雕像在顺时针 $X_i$ 米处，如果你没有在 $T_i$ 秒内收集到这个黑白熊雕像，那么这个雕像就会发出“唔噗噗噗”的声音然后爆炸。\n\n现在 JOI 君在这个点，他每一秒可以移动一米，并且他可以顺时针或者逆时针的移动。\n\nJOI 君想问，他最多能收集到多少个黑白熊雕像？", "inputFormat": "第一行两个整数 $N,L$ 代表雕像数和圆的周长。      \n第二行 $N$ 个整数 $X_i$ 代表每个雕像在顺时针多少米处。       \n第三行 $N$ 个整数 $T_i$ 代表每个雕像需要在多少秒内拿到。", "outputFormat": "一行一个整数代表答案。", "hint": "#### 样例 1 解释\n\nJOI 君可以按照如下策略拿到 $4$ 个黑白熊雕像：\n\n|方向|路程|总时间|第几个雕像|能否拿到|\n|:-:|:-:|:-:|:-:|:-:|\n|逆时针|$2$ 米|$2$ 秒|$6$|$\\sqrt{}$|\n|逆时针|$2$ 米|$4$ 秒|$5$|$\\sqrt{}$|\n|顺时针|$7$ 米|$11$ 秒|$1$|$\\sqrt{}$|\n|顺时针|$1$ 米|$12$ 秒|$2$|$\\times$|\n|顺时针|$3$ 米|$15$ 秒|$3$|$\\sqrt{}$|\n\n#### 样例 2 解释\n\nJOI 君可以直接一直逆时针走。\n\n#### 样例 3 解释\n\nJOI 君无法得到任何一个雕像。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n- Subtask 1（5 pts）：$N \\le 12$，$L \\le 200$，$X_i \\le 200$。\n- Subtask 2（10 pts）：$N \\le 15$。\n- Subtask 3（10 pts）：$L \\le 200$，$T_i \\le 200$。\n- Subtaks 4（75 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le N \\le 200$。\n- $2 \\le L \\le 10^9$。\n- $1 \\le X_i<L$。\n- $X_i < X_{i+1}$。\n- $0 \\le T_i \\le 10^9$。\n\n#### 说明\n\n翻译自 [第19回日本情報オリンピック　本選](https://www.ioi-jp.org/joi/2019/2020-ho/index.html) [C スタンプラリー 3](https://www.ioi-jp.org/joi/2019/2020-ho/2020-ho-t3.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6880", "type": "P", "difficulty": 6, "samples": [["4 5\n1 2 4 4\n1 3 2 1\n4 3 1 2\n4 1 6 1\n2 4 2 5", "10"], ["4 10\n1 2 4 4\n1 2 4 4\n1 3 2 1\n1 3 2 1\n4 3 1 2\n4 3 1 2\n4 1 6 1\n4 1 6 1\n2 4 2 5\n2 4 2 5", "10"], ["4 4\n1 2 0 4\n1 3 0 1\n4 3 0 2\n4 1 0 1", "2"], ["4 5\n1 2 4 4\n1 3 2 4\n4 3 1 5\n4 1 6 1\n2 4 2 5", "12"], ["4 5\n2 1 4 4\n1 3 2 1\n4 3 1 2\n4 3 6 1\n2 4 2 5", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "最短路", "JOI（日本）"], "title": "[JOI 2020 Final] 奥运公交 / Olympic Bus", "background": null, "description": "给定一个含有 $N$ 个点，$M$ 条边的有向图，点的编号从 $1$ 到 $N$。每条边从 $U_i$ 指向 $V_i$，经过这条边的代价为 $C_i$。图中可能存在重边。\n\n在最开始时，我们可以翻转至多一条边，即让这条边从 $U_i\\to V_i$ 永久变为 $V_i\\to U_i$，并产生 $D_i$ 的代价。\n\n你要从点 $1$ 到点 $N$，再从点 $N$ 回到点 $1$，你想知道，通过翻转至多一条边，能得到的最小代价和为多少？", "inputFormat": "第一行两个整数 $N,M$ 代表点数和边数。\n\n接下来 $M$ 行每行四个整数 $U_i,V_i,C_i,D_i$ 代表一条边。", "outputFormat": "一行一个整数代表最小代价和。无解输出 $-1$。", "hint": "### 样例 1 解释\n\n最优解为翻转第二条边，总代价为：\n\n- 翻转的代价 $1$。\n- 从点 $1$ 到点 $N$ 再返回的最短路径 $1 \\to 2 \\to 4 \\to 3 \\to 1$，代价为 $4+2+1+2=9$。\n\n### 样例 4 解释\n\n不一定需要翻转某条边。\n\n### 样例 5 解释\n\n从点 $4$ 到点 $3$ 的边有两条。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（5 pts）：$M \\le 1000$。\n- Subtask 2（11 pts）：$M$ 为偶数，且 $U_{2i}=U_{2i-1}$，$V_{2i}=V_{2i-1}$，$C_{2i}=C_{2i-1}$。\n- Subtask 3（21 pts）：$C_i=0$。\n- Subtask 4（63 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据：\n\n- $2 \\le N \\le 200$。\n- $1 \\le M \\le 5 \\times 10^4$。\n- $1 \\le U_i \\le N$。\n- $1 \\le V_i \\le N$。\n- $U_i \\ne V_i$。\n- $0 \\le C_i \\le 10^6$。\n- $0 \\le D_i \\le 10^9$。\n\n### 说明\n\n翻译自 [第 19 回日本情報オリンピック　本選](https://www.ioi-jp.org/joi/2019/2020-ho/index.html) [D オリンピックバス](https://www.ioi-jp.org/joi/2019/2020-ho/2020-ho-t4.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI 2020 Final] 奥运公交 / Olympic Bus", "background": null, "description": "给定一个含有 $N$ 个点，$M$ 条边的有向图，点的编号从 $1$ 到 $N$。每条边从 $U_i$ 指向 $V_i$，经过这条边的代价为 $C_i$。图中可能存在重边。\n\n在最开始时，我们可以翻转至多一条边，即让这条边从 $U_i\\to V_i$ 永久变为 $V_i\\to U_i$，并产生 $D_i$ 的代价。\n\n你要从点 $1$ 到点 $N$，再从点 $N$ 回到点 $1$，你想知道，通过翻转至多一条边，能得到的最小代价和为多少？", "inputFormat": "第一行两个整数 $N,M$ 代表点数和边数。\n\n接下来 $M$ 行每行四个整数 $U_i,V_i,C_i,D_i$ 代表一条边。", "outputFormat": "一行一个整数代表最小代价和。无解输出 $-1$。", "hint": "### 样例 1 解释\n\n最优解为翻转第二条边，总代价为：\n\n- 翻转的代价 $1$。\n- 从点 $1$ 到点 $N$ 再返回的最短路径 $1 \\to 2 \\to 4 \\to 3 \\to 1$，代价为 $4+2+1+2=9$。\n\n### 样例 4 解释\n\n不一定需要翻转某条边。\n\n### 样例 5 解释\n\n从点 $4$ 到点 $3$ 的边有两条。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（5 pts）：$M \\le 1000$。\n- Subtask 2（11 pts）：$M$ 为偶数，且 $U_{2i}=U_{2i-1}$，$V_{2i}=V_{2i-1}$，$C_{2i}=C_{2i-1}$。\n- Subtask 3（21 pts）：$C_i=0$。\n- Subtask 4（63 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据：\n\n- $2 \\le N \\le 200$。\n- $1 \\le M \\le 5 \\times 10^4$。\n- $1 \\le U_i \\le N$。\n- $1 \\le V_i \\le N$。\n- $U_i \\ne V_i$。\n- $0 \\le C_i \\le 10^6$。\n- $0 \\le D_i \\le 10^9$。\n\n### 说明\n\n翻译自 [第 19 回日本情報オリンピック　本選](https://www.ioi-jp.org/joi/2019/2020-ho/index.html) [D オリンピックバス](https://www.ioi-jp.org/joi/2019/2020-ho/2020-ho-t4.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6881", "type": "P", "difficulty": 7, "samples": [["5 5\n9 3 2 6 5\n1 1 3\n2 1 5\n3 2 5\n4 3 3\n5 3 5", "21\n39\n33\n9\n27"], ["10 10\n3 1 4 1 5 9 2 6 5 3\n1 1 6\n2 8 10\n4 2 7\n8 3 3\n6 1 10\n3 2 8\n5 1 9\n7 4 5\n9 7 9\n10 10 10", "28\n21\n34\n4\n64\n43\n55\n9\n27\n9"], ["10 10\n3 1 4 1 5 9 2 6 5 3\n1 6 6\n2 8 8\n4 2 2\n8 3 3\n6 1 1\n3 4 4\n5 5 5\n7 10 10\n9 8 8\n10 7 7", "9\n9\n3\n4\n3\n4\n5\n9\n9\n9"], ["10 10\n3 1 4 1 5 9 2 6 5 3\n7 1 6\n7 8 10\n7 2 7\n7 3 3\n7 1 10\n7 2 8\n7 1 9\n7 4 5\n7 7 9\n7 10 10", "28\n27\n34\n4\n64\n43\n55\n9\n27\n9"], ["20 20\n2 1 2 2 1 1 1 1 2 2 2 1 2 1 1 2 1 2 1 1\n1 1 14\n2 3 18\n4 10 15\n8 2 17\n9 20 20\n4 8 19\n7 2 20\n11 1 5\n13 2 8\n20 1 20\n2 12 15\n7 1 14\n12 7 18\n14 2 17\n9 19 20\n12 12 12\n6 2 15\n11 2 15\n19 12 17\n4 1 20", "25\n30\n12\n32\n2\n24\n38\n10\n14\n40\n8\n28\n24\n32\n4\n2\n28\n28\n12\n40"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "线段树", "JOI（日本）"], "title": "[JOI 2020 Final] 火灾 / Fire", "background": "原题测试点配置信息：\n\n```\nSubtask 1 (1): 01-*, 02-*, sample-*\nSubtask 2 (6): 01-*, 04-*, sample-04\nSubtask 3 (7): 01-*, 05-*, sample-03\nSubtask 4 (6): 06-*, sample-05\nSubtask 5 (80): *\n```", "description": "给定一个长为 $N$ 的序列 $S_i$，刚开始为时刻 $0$。\n\n定义 $t$ 时刻第 $i$ 个数为 $S_i(t)$，那么：\n\n$$\\begin{cases}\n        S_0(t)=0\\\\S_i(0)=S_i\\\\S_i(t)=\\max\\{S_{i-1}(t-1),S_i(t-1)\\} \n\\end{cases}$$\n\n你将对 $Q$ 个操作进行评估，第 $j$ 个操作让时刻 $T_j$ 时的区间 $[L_j,R_j]$ 全部变为 $0$。\n\n执行一个操作需要一定的代价，执行第 $j$ 个操作需要以下的代价：\n\n$$\\sum\\limits_{k=L_j}^{R_j}S_k(T_j)$$\n\n求每个操作需要的代价。\n\n注意：每个操作都是独立的。", "inputFormat": "第一行两个整数 $N,Q$ 代表序列长度和操作数。     \n第二行 $N$ 个整数 $S_i$ 代表这个序列。       \n接下来 $Q$ 行每行三个整数 $T_j,L_j,R_j$ 代表一个操作。", "outputFormat": "$Q$ 行每行一个整数代表这个操作需要的代价。", "hint": "#### 样例 1 解释\n\n- $S_i(0)=\\{9,3,2,6,5\\}$。\n- $S_i(1)=\\{9,9,3,6,6\\}$，第一个操作需要的代价为 $9+9+3=21$。\n- $S_i(2)=\\{9,9,9,6,6\\}$，第二个操作需要的代价为 $9+9+9+6+6=39$。\n- $S_i(3)=\\{9,9,9,9,6\\}$，第三个操作需要的代价为 $9+9+9+9+6=33$。\n- $S_i(4)=\\{9,9,9,9,9\\}$，第四个操作需要的代价为 $9$。\n- $S_i(5)=\\{9,9,9,9,9\\}$，第五个操作需要的代价为 $27$。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（1 pts）：$N,Q \\le 200$。\n- Subtask 2（6 pts）：$T_j$ 互相相等。\n- Subtask 3（7 pts）：$L_j=R_j$。\n- Subtask 4（6 pts）：$S_i \\le 2$。\n- Subtask 5（80 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le N \\le 2 \\times 10^5$。\n- $1 \\le Q \\le 2 \\times 10^5$。\n- $1 \\le S_i \\le 10^9$。\n- $1 \\le T_j \\le N$。\n- $1 \\le L_j \\le R_j \\le N$。\n\n#### 说明\n\n翻译自 [第19回日本情報オリンピック　本選](https://www.ioi-jp.org/joi/2019/2020-ho/index.html) [E 火事](https://www.ioi-jp.org/joi/2019/2020-ho/2020-ho-t5.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI 2020 Final] 火灾 / Fire", "background": "原题测试点配置信息：\n\n```\nSubtask 1 (1): 01-*, 02-*, sample-*\nSubtask 2 (6): 01-*, 04-*, sample-04\nSubtask 3 (7): 01-*, 05-*, sample-03\nSubtask 4 (6): 06-*, sample-05\nSubtask 5 (80): *\n```", "description": "给定一个长为 $N$ 的序列 $S_i$，刚开始为时刻 $0$。\n\n定义 $t$ 时刻第 $i$ 个数为 $S_i(t)$，那么：\n\n$$\\begin{cases}\n        S_0(t)=0\\\\S_i(0)=S_i\\\\S_i(t)=\\max\\{S_{i-1}(t-1),S_i(t-1)\\} \n\\end{cases}$$\n\n你将对 $Q$ 个操作进行评估，第 $j$ 个操作让时刻 $T_j$ 时的区间 $[L_j,R_j]$ 全部变为 $0$。\n\n执行一个操作需要一定的代价，执行第 $j$ 个操作需要以下的代价：\n\n$$\\sum\\limits_{k=L_j}^{R_j}S_k(T_j)$$\n\n求每个操作需要的代价。\n\n注意：每个操作都是独立的。", "inputFormat": "第一行两个整数 $N,Q$ 代表序列长度和操作数。     \n第二行 $N$ 个整数 $S_i$ 代表这个序列。       \n接下来 $Q$ 行每行三个整数 $T_j,L_j,R_j$ 代表一个操作。", "outputFormat": "$Q$ 行每行一个整数代表这个操作需要的代价。", "hint": "#### 样例 1 解释\n\n- $S_i(0)=\\{9,3,2,6,5\\}$。\n- $S_i(1)=\\{9,9,3,6,6\\}$，第一个操作需要的代价为 $9+9+3=21$。\n- $S_i(2)=\\{9,9,9,6,6\\}$，第二个操作需要的代价为 $9+9+9+6+6=39$。\n- $S_i(3)=\\{9,9,9,9,6\\}$，第三个操作需要的代价为 $9+9+9+9+6=33$。\n- $S_i(4)=\\{9,9,9,9,9\\}$，第四个操作需要的代价为 $9$。\n- $S_i(5)=\\{9,9,9,9,9\\}$，第五个操作需要的代价为 $27$。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（1 pts）：$N,Q \\le 200$。\n- Subtask 2（6 pts）：$T_j$ 互相相等。\n- Subtask 3（7 pts）：$L_j=R_j$。\n- Subtask 4（6 pts）：$S_i \\le 2$。\n- Subtask 5（80 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le N \\le 2 \\times 10^5$。\n- $1 \\le Q \\le 2 \\times 10^5$。\n- $1 \\le S_i \\le 10^9$。\n- $1 \\le T_j \\le N$。\n- $1 \\le L_j \\le R_j \\le N$。\n\n#### 说明\n\n翻译自 [第19回日本情報オリンピック　本選](https://www.ioi-jp.org/joi/2019/2020-ho/index.html) [E 火事](https://www.ioi-jp.org/joi/2019/2020-ho/2020-ho-t5.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6882", "type": "P", "difficulty": 1, "samples": [["1\nSpavas li Mirno del Potro Juan martine?", "4"], ["2\nAn4 voli Milovana. Ana nabra par Banana. ", "1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["字符串", "2016", "COCI（克罗地亚）"], "title": "[COCI 2016/2017 #3] Imena", "background": "", "description": "单词是由大写或小写字母组成的字符串。特别的，末尾也可以是标点符号（`.`,`?`,`!`）。名字是 **有且仅有首字母为大写字母** 的单词。\n\n句子是由一些单词组成的字符串，并且最后一个字符是标点符号（`.`,`?`,`!`）\n。\n\n给定 $N$ 个句子，Mirko 想让你统计每个句子中分别有多少个名字。\n\n\n\n\n", "inputFormat": "第一行包含一个正整数 $N$，表示句子的个数。\n\n第二行包含这 $N$ 个句子。这些句子的字符总数不会超过 $10^3$。 ", "outputFormat": "包含 $N$ 行，每行一个正整数。第 $i$ 行表示第 $i$ 个句子的名字总数。", "hint": "### 样例解释\n\n#### 样例 2 解释\n\n第一个句子中的名字有 `Milovana`，共 $1$ 个；第二个句子中的名字有 `Ana`,`Banana`，共 $2$ 个。注意第一个句子中，尽管 `An4` 的开头是一个大写字母，但它包含了一个数字，所以不是一个名字。\n\n### 数据规模与约定\n\n对于 $40\\%$ 的数据，满足 $N=1$。\n\n对于 $100\\%$ 的数据，满足 $1\\le N \\le 5$。\n\n### 说明\n**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #3](https://hsin.hr/coci/archive/2016_2017/contest3_tasks.pdf) _T1 Imena_**。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2016/2017 #3] Imena", "background": "", "description": "单词是由大写或小写字母组成的字符串。特别的，末尾也可以是标点符号（`.`,`?`,`!`）。名字是 **有且仅有首字母为大写字母** 的单词。\n\n句子是由一些单词组成的字符串，并且最后一个字符是标点符号（`.`,`?`,`!`）\n。\n\n给定 $N$ 个句子，Mirko 想让你统计每个句子中分别有多少个名字。\n\n\n\n\n", "inputFormat": "第一行包含一个正整数 $N$，表示句子的个数。\n\n第二行包含这 $N$ 个句子。这些句子的字符总数不会超过 $10^3$。 ", "outputFormat": "包含 $N$ 行，每行一个正整数。第 $i$ 行表示第 $i$ 个句子的名字总数。", "hint": "### 样例解释\n\n#### 样例 2 解释\n\n第一个句子中的名字有 `Milovana`，共 $1$ 个；第二个句子中的名字有 `Ana`,`Banana`，共 $2$ 个。注意第一个句子中，尽管 `An4` 的开头是一个大写字母，但它包含了一个数字，所以不是一个名字。\n\n### 数据规模与约定\n\n对于 $40\\%$ 的数据，满足 $N=1$。\n\n对于 $100\\%$ 的数据，满足 $1\\le N \\le 5$。\n\n### 说明\n**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #3](https://hsin.hr/coci/archive/2016_2017/contest3_tasks.pdf) _T1 Imena_**。", "locale": "zh-CN"}}}
{"pid": "P6883", "type": "P", "difficulty": 4, "samples": [["3 3\n0 1 1\n1 0 1\n1 1 0 ", "0"], ["3 2\n0 1 1\n1 0 1\n1 1 0 ", "1"], ["5 2\n0 5 4 3 2\n7 0 4 4 4\n3 3 0 1 2\n4 3 1 0 5\n4 5 5 5 0 ", "5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["动态规划 DP", "2016", "位运算", "COCI（克罗地亚）", "状压 DP"], "title": "[COCI 2016/2017 #3] Kroničan", "background": "", "description": "Mislav 有 $N$ 个玻璃杯，从 $1\\sim N$  编号，每个玻璃杯中都有一定的水。你需要通过倒水（将某个杯子中的水倒入另一个杯子），使这些杯子中只有 $K$ 个有水。\n\n已知将第 $i$ 号玻璃杯中的水倒入第 $j$ 号，需要消耗 $C_{i,j}$ 的代价。Mislav 想知道，经过倒水后满足只有 $K$ 个（或更少）玻璃杯中有水时，消耗的代价总和的最小值。", "inputFormat": "第一行包含两个正整数，$N,K$。\n\n接下来 $N$ 行，每行包含 $N$ 个非负整数 $C_{i,j}$。第 $i$ 行 $j$ 列的数表示从玻璃杯 $i$ 倒水到玻璃杯 $j$ 需要付出的代价。保证 $C_{i,i}$ 一定是 $0$。", "outputFormat": "输出 Mislav 达成目标需要付出的最小代价和。", "hint": "#### 样例 1 解释\n\nMislav 不需要倒水。代价和是 $0$。\n\n#### 样例 2 解释\n\nMislav 需要将任意一个玻璃杯中的水倒入任何其他玻璃杯中，使其满足只有两个玻璃杯中有水。代价和为 $1$。\n\n#### 样例 3 解释\n\nMislav 可以将水从玻璃杯 $4$ 倒入玻璃杯 $3$，然后将玻璃杯 $3$ 中的水倒入玻璃杯 $5$，最后将玻璃杯 $1$ 中的水倒入玻璃杯 $5$。总共付出代价和为 $1+2+2=5$。\n\n### 数据规模与约定\n\n对于 $40\\%$ 的数据，满足 $N\\le 10$。\n\n对于 $100\\%$ 的数据，满足 $1\\le K\\le N\\le 20,C_{i,j}\\le10^5$\n\n\n\n### 说明\n\n**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #3](https://hsin.hr/coci/archive/2016_2017/contest3_tasks.pdf) _T3 Kroničan_**。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2016/2017 #3] Kroničan", "background": "", "description": "Mislav 有 $N$ 个玻璃杯，从 $1\\sim N$  编号，每个玻璃杯中都有一定的水。你需要通过倒水（将某个杯子中的水倒入另一个杯子），使这些杯子中只有 $K$ 个有水。\n\n已知将第 $i$ 号玻璃杯中的水倒入第 $j$ 号，需要消耗 $C_{i,j}$ 的代价。Mislav 想知道，经过倒水后满足只有 $K$ 个（或更少）玻璃杯中有水时，消耗的代价总和的最小值。", "inputFormat": "第一行包含两个正整数，$N,K$。\n\n接下来 $N$ 行，每行包含 $N$ 个非负整数 $C_{i,j}$。第 $i$ 行 $j$ 列的数表示从玻璃杯 $i$ 倒水到玻璃杯 $j$ 需要付出的代价。保证 $C_{i,i}$ 一定是 $0$。", "outputFormat": "输出 Mislav 达成目标需要付出的最小代价和。", "hint": "#### 样例 1 解释\n\nMislav 不需要倒水。代价和是 $0$。\n\n#### 样例 2 解释\n\nMislav 需要将任意一个玻璃杯中的水倒入任何其他玻璃杯中，使其满足只有两个玻璃杯中有水。代价和为 $1$。\n\n#### 样例 3 解释\n\nMislav 可以将水从玻璃杯 $4$ 倒入玻璃杯 $3$，然后将玻璃杯 $3$ 中的水倒入玻璃杯 $5$，最后将玻璃杯 $1$ 中的水倒入玻璃杯 $5$。总共付出代价和为 $1+2+2=5$。\n\n### 数据规模与约定\n\n对于 $40\\%$ 的数据，满足 $N\\le 10$。\n\n对于 $100\\%$ 的数据，满足 $1\\le K\\le N\\le 20,C_{i,j}\\le10^5$\n\n\n\n### 说明\n\n**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #3](https://hsin.hr/coci/archive/2016_2017/contest3_tasks.pdf) _T3 Kroničan_**。", "locale": "zh-CN"}}}
{"pid": "P6884", "type": "P", "difficulty": 4, "samples": [["2\n10 6\n((?)+(?))", "6.00000"], ["3\n2 5 3 \n(((?)+(?))*(?))", "6.00000"], ["3 \n2 10 6 \n((?)*(?)*(?))", "8.0000000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["数学", "贪心", "2016", "Special Judge", "COCI（克罗地亚）"], "title": "[COCI 2016/2017 #3] Kvalitetni", "background": "", "description": "定义一个算术表达式是有质量的，当且仅当这个算术表达式只由括号，数字，乘法符号和加法符号组成。\n\n一个有质量的算术表达式由下列方式递归定义：\n\n- 仅包含一个正实数**小于等于** $Z_1$。这种表达形式如下：\n \n $$(x)$$\n \n 例如当 $Z_1=5$，那么 $(4)$ 就是有质量的算术表达式。\n\n- 如果 $A_1,A_2,\\cdots,A_k(2\\le k\\le K)$ 都是有质量的算术表达式，并且这些有质量的算术表达式的和**小于等于** $Z_k$，那么\n\n$$(A_1+A_2+\\cdots+A_k)$$\n\n$$(A_1*A_2*\\cdots*A_k)$$\n\n也是有质量的算术表达式。\n\n你会得到一条**所有数字都被问号代替**的算术表达式，求满足这个表达式是有质量的算术表达式的前提下，这个表达式可能的最大值。\n", "inputFormat": "第一行包含一个正整数 $K$。\n\n第二行包含 $K$ 个被空格隔开的正整数，表示 $Z_1,Z_2,\\cdots,Z_K$。\n\n第三行包含了一个所有数字被 `?` 代替的算术质量表达式。这个表达式只包含 `?`,`+`,`*`,`(`,`)`。", "outputFormat": "**本题采用 Special Judge**。\n\n你需要输出这个表达式的最大值。\n\n你的解被接受当且仅当你的输出和标准答案的绝对值 $\\le 10^{-3}$。", "hint": "#### 样例 1 解释\n\n表达式 $((3)+(3))$ 满足条件，因此它是一个算术表达式。容易证明，$6$ 是这个表达式的最大值。\n\n#### 样例 2 解释\n\n对于表达式 $(((1)+(2))*(2))$ 可以达到最大值。\n\n#### 样例 3 解释\n\n对于表达式 $((2)*(2)*(2))$ 可以得到最大值。\n\n### 数据规模与约定\n\n对于 $100\\%$ 的数据，满足 $2\\le K\\le 50,1\\le Z_i\\le 50$，表达式的长度 $\\le 10^6$。\n\n### 说明\n\n**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #3](https://hsin.hr/coci/archive/2016_2017/contest3_tasks.pdf) _T4 Kvalitetni_**。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2016/2017 #3] Kvalitetni", "background": "", "description": "定义一个算术表达式是有质量的，当且仅当这个算术表达式只由括号，数字，乘法符号和加法符号组成。\n\n一个有质量的算术表达式由下列方式递归定义：\n\n- 仅包含一个正实数**小于等于** $Z_1$。这种表达形式如下：\n \n $$(x)$$\n \n 例如当 $Z_1=5$，那么 $(4)$ 就是有质量的算术表达式。\n\n- 如果 $A_1,A_2,\\cdots,A_k(2\\le k\\le K)$ 都是有质量的算术表达式，并且这些有质量的算术表达式的和**小于等于** $Z_k$，那么\n\n$$(A_1+A_2+\\cdots+A_k)$$\n\n$$(A_1*A_2*\\cdots*A_k)$$\n\n也是有质量的算术表达式。\n\n你会得到一条**所有数字都被问号代替**的算术表达式，求满足这个表达式是有质量的算术表达式的前提下，这个表达式可能的最大值。\n", "inputFormat": "第一行包含一个正整数 $K$。\n\n第二行包含 $K$ 个被空格隔开的正整数，表示 $Z_1,Z_2,\\cdots,Z_K$。\n\n第三行包含了一个所有数字被 `?` 代替的算术质量表达式。这个表达式只包含 `?`,`+`,`*`,`(`,`)`。", "outputFormat": "**本题采用 Special Judge**。\n\n你需要输出这个表达式的最大值。\n\n你的解被接受当且仅当你的输出和标准答案的绝对值 $\\le 10^{-3}$。", "hint": "#### 样例 1 解释\n\n表达式 $((3)+(3))$ 满足条件，因此它是一个算术表达式。容易证明，$6$ 是这个表达式的最大值。\n\n#### 样例 2 解释\n\n对于表达式 $(((1)+(2))*(2))$ 可以达到最大值。\n\n#### 样例 3 解释\n\n对于表达式 $((2)*(2)*(2))$ 可以得到最大值。\n\n### 数据规模与约定\n\n对于 $100\\%$ 的数据，满足 $2\\le K\\le 50,1\\le Z_i\\le 50$，表达式的长度 $\\le 10^6$。\n\n### 说明\n\n**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #3](https://hsin.hr/coci/archive/2016_2017/contest3_tasks.pdf) _T4 Kvalitetni_**。", "locale": "zh-CN"}}}
{"pid": "P6885", "type": "P", "difficulty": 5, "samples": [["2\n1 1 ", "1 4 "], ["4\n2 1 3 4 ", "4 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["动态规划 DP", "2016", "树状数组", "COCI（克罗地亚）"], "title": "[COCI 2016/2017 #3] Zoltan", "background": "", "description": "Marton 的朋友 Cero 有一个由 $N$ 个正整数组成的数组。\n\n首先 Cero 会在黑板上写下这个数组中的第一个数字。接下来他会在之前写下的所有数的左边或者右边写下一个数字。重复以上操作得到一个序列。\n\n请注意，根据上述方法构造出的两个序列相同**当且仅当每一个数字写下的顺序完全相同**。例如，$1,1$ 可能和 $1,1$ 不同，前者的第二个数在第一个数的左边，后者的第二个数在第一个数的右边。\n\n求这些数组成的所有序列中，最长严格递增子序列长度的最大值 $M$，以及所有最长严格递增子序列长度等于 $M$ 的序列中，最长严格递增子序列个数的总和。考虑到答案可能很大，Marton 只想知道这个数对 $10^9+7$ 取模的值。", "inputFormat": "第一行包含一个正整数 $N$。\n\n接下来的一行包含 $N$ 个正整数，表示按顺序给出的这个数组的各个元素。", "outputFormat": "仅一行，输出这个最长的子序列长度以及总个数模上 $10^9+7$ 的值。", "hint": "### 样例解释\n\n#### 样例 1 解释\n\nCero 可以构造 $2$ 个不同的序列，$1,1$ 和 $1,1$。\n\n显然最长的严格上升子序列长度为 $1$，有 $4$ 个子序列满足。\n\n#### 样例 2 解释\n\n最长的严格上升子序列长度为 $4$，只有 $1,2,3,4$ 满足。\n \n### 数据规模与约定\n\n对于 $30\\%$ 的数据，满足 $N\\le 20$。\n\n对于 $50\\%$ 的数据，满足 $N\\le 10^3$。\n\n对于 $100\\%$ 的数据，满足 $N\\le 2\\times10^5$，数组中的每个元素 $\\le10^9$。\n\n### 说明\n\n**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #3](https://hsin.hr/coci/archive/2016_2017/contest3_tasks.pdf) _T5 Zoltan_**。\n\n样例 1,2 的解释非官方。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2016/2017 #3] Zoltan", "background": "", "description": "Marton 的朋友 Cero 有一个由 $N$ 个正整数组成的数组。\n\n首先 Cero 会在黑板上写下这个数组中的第一个数字。接下来他会在之前写下的所有数的左边或者右边写下一个数字。重复以上操作得到一个序列。\n\n请注意，根据上述方法构造出的两个序列相同**当且仅当每一个数字写下的顺序完全相同**。例如，$1,1$ 可能和 $1,1$ 不同，前者的第二个数在第一个数的左边，后者的第二个数在第一个数的右边。\n\n求这些数组成的所有序列中，最长严格递增子序列长度的最大值 $M$，以及所有最长严格递增子序列长度等于 $M$ 的序列中，最长严格递增子序列个数的总和。考虑到答案可能很大，Marton 只想知道这个数对 $10^9+7$ 取模的值。", "inputFormat": "第一行包含一个正整数 $N$。\n\n接下来的一行包含 $N$ 个正整数，表示按顺序给出的这个数组的各个元素。", "outputFormat": "仅一行，输出这个最长的子序列长度以及总个数模上 $10^9+7$ 的值。", "hint": "### 样例解释\n\n#### 样例 1 解释\n\nCero 可以构造 $2$ 个不同的序列，$1,1$ 和 $1,1$。\n\n显然最长的严格上升子序列长度为 $1$，有 $4$ 个子序列满足。\n\n#### 样例 2 解释\n\n最长的严格上升子序列长度为 $4$，只有 $1,2,3,4$ 满足。\n \n### 数据规模与约定\n\n对于 $30\\%$ 的数据，满足 $N\\le 20$。\n\n对于 $50\\%$ 的数据，满足 $N\\le 10^3$。\n\n对于 $100\\%$ 的数据，满足 $N\\le 2\\times10^5$，数组中的每个元素 $\\le10^9$。\n\n### 说明\n\n**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #3](https://hsin.hr/coci/archive/2016_2017/contest3_tasks.pdf) _T5 Zoltan_**。\n\n样例 1,2 的解释非官方。", "locale": "zh-CN"}}}
{"pid": "P6886", "type": "P", "difficulty": 0, "samples": [["4 5 2\n1 3\n3 4\n4\n0 0\n2 0\n2 2\n0 2 ", "4"], ["5 5 3\n1 4\n1 3\n2 2\n3\n4 7\n6 3\n7 6 ", "3"], ["6 7 2\n2 5\n4 5\n8\n1 4\n3 3\n4 1\n5 3\n7 4\n5 5\n4 7\n3 5 ", "1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["计算几何", "2016", "快速傅里叶变换 FFT", "COCI（克罗地亚）"], "title": "[COCI 2016/2017 #3] Meksikanac", "background": "", "description": "Norman 有一个给定的 $K$ 边形的苍蝇拍。他想知道有多少种放置苍蝇拍的方法，使得这个苍蝇拍的顶点在顶点为 $(0,0)$ 和 $(X_p,Y_p)$ 的矩形中，并且各个顶点是整点，满足没有一个苍蝇被伤害。\n\n其中，整点的定义是横坐标和纵坐标都是整数的点。\n\n这个矩形中有 $N$ 个苍蝇，每一个苍蝇可以看成一个点 $(X,Y)$。一个苍蝇会被伤害，当且仅当这个苍蝇在这个苍蝇拍的顶点，边或内部。\n\n苍蝇拍不能旋转或翻折。", "inputFormat": "第一行包含三个正整数 $X_p,Y_p,N$，意义同上。\n\n以下 $N$ 行，每行包含两个正整数 $(X,Y)$，表示第 $i$ 个苍蝇的坐标。\n\n接下来一行有一个正整数 $K$ 表示多边形的点数。\n\n以下 $K$ 行，每行两个正整数 $(X_i,Y_i)$，表示当苍蝇拍的第一个顶点的坐标为 $(X_1,Y_1)$ 的时候，其他顶点的坐标。各个顶点是顺次给出的。", "outputFormat": "你需要输出有多少可行的放置苍蝇拍的方案。", "hint": "### 样例解释\n\n#### 样例 1 解释\n\n可以放置的苍蝇拍的位置如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n0zxm7n4.png?x-oss-process=image/resize,m_lfit,h_340,w_450)\n\n共 $4$ 种。\n\n#### 样例 2 解释\n\n可以放置的苍蝇拍的位置如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6mcgzh88.png?x-oss-process=image/resize,m_lfit,h_340,w_450)\n\n共 $3$ 种。\n\n#### 样例 3 解释\n\n可以放置的苍蝇拍的位置如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cj9f17kw.png?x-oss-process=image/resize,m_lfit,h_340,w_450)\n\n\n\n共 $1$ 种。\n\n### 数据规模与约定\n\n对于 $63\\%$ 的数据，满足 $1\\le X_p,Y_p\\le100$。\n\n对于 $100\\%$ 的数据，满足 $1\\le X_p,Y_p\\le500,1\\le N\\le X_p\\times Y_p,3\\le K\\le10^4,0<X<X_p,0<Y<Y_p,-10^9\\le X_i,Y_i\\le10^9$。\n\n### 说明\n\n**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #3](https://hsin.hr/coci/archive/2016_2017/contest3_tasks.pdf) _T6 Meksikanac_**。\n\n样例 1,2 的解释非官方。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2016/2017 #3] Meksikanac", "background": "", "description": "Norman 有一个给定的 $K$ 边形的苍蝇拍。他想知道有多少种放置苍蝇拍的方法，使得这个苍蝇拍的顶点在顶点为 $(0,0)$ 和 $(X_p,Y_p)$ 的矩形中，并且各个顶点是整点，满足没有一个苍蝇被伤害。\n\n其中，整点的定义是横坐标和纵坐标都是整数的点。\n\n这个矩形中有 $N$ 个苍蝇，每一个苍蝇可以看成一个点 $(X,Y)$。一个苍蝇会被伤害，当且仅当这个苍蝇在这个苍蝇拍的顶点，边或内部。\n\n苍蝇拍不能旋转或翻折。", "inputFormat": "第一行包含三个正整数 $X_p,Y_p,N$，意义同上。\n\n以下 $N$ 行，每行包含两个正整数 $(X,Y)$，表示第 $i$ 个苍蝇的坐标。\n\n接下来一行有一个正整数 $K$ 表示多边形的点数。\n\n以下 $K$ 行，每行两个正整数 $(X_i,Y_i)$，表示当苍蝇拍的第一个顶点的坐标为 $(X_1,Y_1)$ 的时候，其他顶点的坐标。各个顶点是顺次给出的。", "outputFormat": "你需要输出有多少可行的放置苍蝇拍的方案。", "hint": "### 样例解释\n\n#### 样例 1 解释\n\n可以放置的苍蝇拍的位置如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n0zxm7n4.png?x-oss-process=image/resize,m_lfit,h_340,w_450)\n\n共 $4$ 种。\n\n#### 样例 2 解释\n\n可以放置的苍蝇拍的位置如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6mcgzh88.png?x-oss-process=image/resize,m_lfit,h_340,w_450)\n\n共 $3$ 种。\n\n#### 样例 3 解释\n\n可以放置的苍蝇拍的位置如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cj9f17kw.png?x-oss-process=image/resize,m_lfit,h_340,w_450)\n\n\n\n共 $1$ 种。\n\n### 数据规模与约定\n\n对于 $63\\%$ 的数据，满足 $1\\le X_p,Y_p\\le100$。\n\n对于 $100\\%$ 的数据，满足 $1\\le X_p,Y_p\\le500,1\\le N\\le X_p\\times Y_p,3\\le K\\le10^4,0<X<X_p,0<Y<Y_p,-10^9\\le X_i,Y_i\\le10^9$。\n\n### 说明\n\n**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #3](https://hsin.hr/coci/archive/2016_2017/contest3_tasks.pdf) _T6 Meksikanac_**。\n\n样例 1,2 的解释非官方。", "locale": "zh-CN"}}}
{"pid": "P6887", "type": "P", "difficulty": 0, "samples": [["2\n6 3\n9 6\n8\nL 1\nL 2\nL 3\nL 4\nP 1\nP 2\nP 3\nP 4 ", "1\n2\n9\n6\n1\n2\n5\n6 "], ["5\n7 2\n2 7\n9 7\n10 1\n100005 99995\n9\nL 1\nP 2\nL 2\nP 7\nL 7\nP 9\nP 10\nP 99999\nL 100000 ", "10\n3\n1\n5\n4\n4\n1\n100000\n99999 "]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2006", "CEOI（中欧）"], "title": "[CEOI 2006] Queue", "background": "", "description": "If you are an average football fan, you probably know that obtaining tickets for this year's World Cup in\nGermany was an almost impossible task. Greedy organizers and football federations grabbed the majority of\navailable tickets and divided them among sponsors, friends and family members. As a result, jet setters have\nflooded the venues, while die-hard fans sit at home enjoying the games between advertisements featuring crappy\nbeer and sugar-free chewing gum.\n\nA couple of tickets are left for the final game and a huge queue has formed in front of the ticket office. As fans\nwere arriving, they were labeled with successive integers. The first person in queue was labeled with number one,\nthe second with number two, etc.\n\nSince the fans arrived the night before, they had to wait for a long time before the ticket counter was open and,\nnaturally, some of them had to use the restroom. Each time a person needs to use the restroom, he/she steps\nout of the queue and, after completing the task, steps back into the queue, though not necessarily at the same\nposition as before. Since there is only one restroom available, no person leaves the queue before the previous\nperson has returned (hence, at any moment there is at most one person missing from the queue).\n\nDuring the course of the night, a total of N restroom visits have occurred. Each visit is described by two positive\nintegers A and B, denoting that the person labeled **A stepped out of the queue** and then stepped back into the\nqueue **immediately in front of the person labeled B**. Now that all the visits have completed, the officials have\nto answer a series of questions. Each question is either of the form 'P X', asking for **the position of the person\nlabeled X**, or of the form 'L X', asking for **the label of the person at position X**.\n\nThe first person in queue is considered to be at position one, the second at position two, etc.\n\nWrite a program that, given the description of the visits and a number of questions, **answers all of the\nquestions**. ", "inputFormat": "The first line of input contains an integer N (2 ≤ N ≤ 50 000) – the total number of restroom visits.\n\nEach of the following N lines contains two different integers A and B (1 ≤ A, B ≤ 109), describing one restroom\nvisit. The next line contains an integer Q (1 ≤ Q ≤ 50 000) – the total number of questions.\n\nEach of the following Q lines contains a single character (either the uppercase letter 'P' or the uppercase letter\n'L') and an integer X (1 ≤ X ≤ 109), describing one question. ", "outputFormat": "The output should consist of a total of Q lines.\n\nThe ith line of output should contain a single integer R – the answer to the ith question.\n\nIf the corresponding question is of the form 'P Xi' then R should be the final position of the person labeled Xi.\n\nIf the corresponding question is of the form 'L Xi' then R should be the label of the person at position Xi. ", "hint": "Partial credit is awarded for incorrect solutions that correctly answer all questions of one type. If all questions of\nthe form 'P X' are answered correctly or if all questions of the form 'L X' are answered correctly, you will receive\n50% of the points for the corresponding test case.\n\nIn order to receive partial credit, the output should be formatted according to the specifications. Therefore, even\nif you choose to answer only one type of questions, you should still produce output for all questions of the other\ntype. ", "locale": "en", "translations": {"en": {"title": "[CEOI 2006] Queue", "background": "", "description": "If you are an average football fan, you probably know that obtaining tickets for this year's World Cup in\nGermany was an almost impossible task. Greedy organizers and football federations grabbed the majority of\navailable tickets and divided them among sponsors, friends and family members. As a result, jet setters have\nflooded the venues, while die-hard fans sit at home enjoying the games between advertisements featuring crappy\nbeer and sugar-free chewing gum.\n\nA couple of tickets are left for the final game and a huge queue has formed in front of the ticket office. As fans\nwere arriving, they were labeled with successive integers. The first person in queue was labeled with number one,\nthe second with number two, etc.\n\nSince the fans arrived the night before, they had to wait for a long time before the ticket counter was open and,\nnaturally, some of them had to use the restroom. Each time a person needs to use the restroom, he/she steps\nout of the queue and, after completing the task, steps back into the queue, though not necessarily at the same\nposition as before. Since there is only one restroom available, no person leaves the queue before the previous\nperson has returned (hence, at any moment there is at most one person missing from the queue).\n\nDuring the course of the night, a total of N restroom visits have occurred. Each visit is described by two positive\nintegers A and B, denoting that the person labeled **A stepped out of the queue** and then stepped back into the\nqueue **immediately in front of the person labeled B**. Now that all the visits have completed, the officials have\nto answer a series of questions. Each question is either of the form 'P X', asking for **the position of the person\nlabeled X**, or of the form 'L X', asking for **the label of the person at position X**.\n\nThe first person in queue is considered to be at position one, the second at position two, etc.\n\nWrite a program that, given the description of the visits and a number of questions, **answers all of the\nquestions**. ", "inputFormat": "The first line of input contains an integer N (2 ≤ N ≤ 50 000) – the total number of restroom visits.\n\nEach of the following N lines contains two different integers A and B (1 ≤ A, B ≤ 109), describing one restroom\nvisit. The next line contains an integer Q (1 ≤ Q ≤ 50 000) – the total number of questions.\n\nEach of the following Q lines contains a single character (either the uppercase letter 'P' or the uppercase letter\n'L') and an integer X (1 ≤ X ≤ 109), describing one question. ", "outputFormat": "The output should consist of a total of Q lines.\n\nThe ith line of output should contain a single integer R – the answer to the ith question.\n\nIf the corresponding question is of the form 'P Xi' then R should be the final position of the person labeled Xi.\n\nIf the corresponding question is of the form 'L Xi' then R should be the label of the person at position Xi. ", "hint": "Partial credit is awarded for incorrect solutions that correctly answer all questions of one type. If all questions of\nthe form 'P X' are answered correctly or if all questions of the form 'L X' are answered correctly, you will receive\n50% of the points for the corresponding test case.\n\nIn order to receive partial credit, the output should be formatted according to the specifications. Therefore, even\nif you choose to answer only one type of questions, you should still produce output for all questions of the other\ntype. ", "locale": "en"}, "zh-CN": {"title": "[CEOI 2006] Queue", "background": "", "description": "如果你是一个普通的足球迷，你可能知道今年在德国举办的世界杯门票几乎是不可能获得的。贪婪的组织者和足球联合会抢走了大部分可用的门票，并将它们分给了赞助商、朋友和家人。结果是，场馆被旅行者占据，而铁杆球迷则坐在家里观看比赛，中间夹杂着劣质啤酒和无糖口香糖的广告。\n\n还有几张决赛的门票剩下，售票处前排起了长队。随着球迷的到来，他们被依次标记为连续的整数。队伍中的第一个人被标记为 1 号，第二个为 2 号，依此类推。\n\n由于球迷们是前一天晚上到达的，他们不得不在售票窗口开放前等待很长时间，自然有些人需要去洗手间。每次有人需要去洗手间时，他/她会离开队伍，完成任务后再回到队伍中，但不一定回到之前的位置。由于只有一个洗手间，所以在前一个人返回之前，没有人会离开队伍（因此，在任何时刻队伍中最多只有一个人缺席）。\n\n在晚上，总共发生了 N 次洗手间访问。每次访问由两个正整数 A 和 B 描述，表示标记为 A 的人离开队伍，然后在标记为 B 的人前面立即回到队伍中。现在所有的访问都已完成，官员们必须回答一系列问题。每个问题的形式要么是 'P X'，询问标记为 X 的人的位置，要么是 'L X'，询问位置 X 的人的标记。\n\n队伍中的第一个人被认为是在位置 1，第二个在位置 2，依此类推。\n\n编写一个程序，给定访问的描述和若干问题，回答所有的问题。", "inputFormat": "输入的第一行包含一个整数 N（2 ≤ N ≤ 50 000）——洗手间访问的总次数。\n\n接下来的 N 行中的每一行包含两个不同的整数 A 和 B（1 ≤ A, B ≤ 10^9），描述一次洗手间访问。下一行包含一个整数 Q（1 ≤ Q ≤ 50 000）——问题的总数。\n\n接下来的 Q 行中的每一行包含一个单个字符（大写字母 'P' 或大写字母 'L'）和一个整数 X（1 ≤ X ≤ 10^9），描述一个问题。", "outputFormat": "输出应包含总共 Q 行。\n\n输出的第 i 行应包含一个整数 R——第 i 个问题的答案。\n\n如果相应的问题是形式 'P Xi'，那么 R 应该是标记为 Xi 的人的最终位置。\n\n如果相应的问题是形式 'L Xi'，那么 R 应该是位置 Xi 的人的标记。", "hint": "对于错误的解决方案，如果所有形式为 'P X' 的问题都正确回答，或者所有形式为 'L X' 的问题都正确回答，将获得部分分数。对于相应的测试用例，你将获得 50% 的分数。\n\n为了获得部分分数，输出应按照规格格式化。因此，即使你选择只回答一种类型的问题，你仍然应该为所有其他类型的问题生成输出。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6888", "type": "P", "difficulty": 6, "samples": [["9 1 \n2 \n5 -3 8 3 \n10 -3 13 3", "16"], ["12 0 \n5 \n2 -1 3 1 \n6 -7 8 -1 \n6 1 8 6 \n4 3 4 5 \n10 -5 10 3", "24"], ["42 33\n66\n35 37 37 37\n13 -41 13 6\n40 -2 42 -1\n27 -2 28 -2\n15 -4 16 2\n29 16 29 16\n38 -34 38 -11\n22 -5 22 -5\n34 27 34 35\n28 12 29 12\n10 11 11 13\n11 25 11 25\n24 4 25 40\n27 9 27 10\n27 -4 27 -4\n29 7 29 10\n3 -13 5 -13\n16 17 16 17\n18 6 18 48\n4 7 4 14\n5 2 5 5\n40 22 44 32\n21 13 21 13\n34 3 34 25\n41 11 42 20\n15 -15 16 -9\n24 -46 25 -6\n5 -4 5 -3\n10 17 11 17\n28 14 29 14\n3 -15 4 -15\n10 15 10 15\n16 8 16 9\n2 2 2 2\n1 -4 3 -3\n10 21 10 21\n22 8 22 8\n20 -3 21 2\n10 19 11 19\n7 -47 8 3\n28 -11 28 -6\n20 4 20 9\n11 23 11 23\n15 -17 16 -17\n27 0 27 3\n43 5 43 8\n15 -7 16 -6\n16 -19 16 -19\n11 -10 11 -10\n21 11 22 11\n4 0 4 0\n15 5 16 6\n3 -11 5 -7\n11 -8 11 -1\n28 -13 28 -13\n21 15 22 15\n40 -30 43 -5\n41 34 43 35\n15 14 16 15\n21 -16 22 -13\n1 -1 2 -1\n10 1 11 9\n22 17 22 17\n31 -50 32 -1\n22 -8 22 -7\n16 -21 16 -21", "89"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2006", "线段树", "平衡树", "CEOI（中欧）"], "title": "[CEOI 2006] Walk", "background": "", "description": "Finding your destination in a big unknown city can be challenging, especially if you are a computer scientist like \nKirk, always trying to use the shortest possible path. Planning can help – given the map of the city Kirk wants to \nfind the shortest path between his current position and his destination. \n\nThe map of the city can be represented in the plane as an infinite grid composed of unit squares. \n\nKirk is currently located at the square (0, 0) and his destination is the square (X, Y). \n\nThere are N buildings in the city. Each building is a rectangle fully occupying a number of unit squares. **No two \nbuildings touch or overlap**, i.e. Kirk can walk freely around every building. A building is defined by specifying \nthe coordinates of two diagonally opposite squares occupied by the building. \n\nIn each step, Kirk can walk to one of the four neighboring squares, but he is not allowed to step onto a square \noccupied by a building. His current position is at the west entrance to the city and the x coordinate of every \nsquare occupied by a building is **strictly greater than zero**. \n\nWrite a program that, given the locations of the buildings, finds **one shortest possible path** from Kirk's current \nposition to his destination. A path should be reported as a sequence of vertical and horizontal segments, with no \ntwo consecutive segments parallel. The length of a path is the number of squares contained in the path, \nexcluding the initial square.", "inputFormat": "The first line of input contains two integers X, Y (1 ≤ X ≤ 106, -106 ≤ Y ≤ 106) – the coordinates of the \ndestination square. The second line of input contains a single integer N (0 ≤ N ≤ 100 000) – the number of \nbuildings in the city. Each of the following N lines contains four integers X1, Y1, X2, Y2 (1 ≤ X1, X2 ≤ 106, \n-106 ≤ Y1, Y2 ≤ 106) – the coordinates of two diagonally opposite squares occupied by the building.", "outputFormat": "The first line of output should contain an integer L – the length of the shortest path to the destination. \nThe second line of output should contain an integer M – the number of segments in the shortest path. The \nnumber of segments M must not exceed 1,000,000. \n\nEach of the following M lines should contain two integers, DX and DY, describing Kirk's relative movement in \none segment. For each segment, **exactly one** of the values DX, DY should be zero, and no two consecutive \nsegments should be parallel. \n\nNote: if there are multiple solutions, you should output any one of them.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/tyf2lbht.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/ddujl7ea.png)\n\n**Note**: each of the figures depicts the respective input, along with the supplied solution.\n\n**注意：原题还要求输出方案，本题略去。**", "locale": "en", "translations": {"en": {"title": "[CEOI 2006] Walk", "background": "", "description": "Finding your destination in a big unknown city can be challenging, especially if you are a computer scientist like \nKirk, always trying to use the shortest possible path. Planning can help – given the map of the city Kirk wants to \nfind the shortest path between his current position and his destination. \n\nThe map of the city can be represented in the plane as an infinite grid composed of unit squares. \n\nKirk is currently located at the square (0, 0) and his destination is the square (X, Y). \n\nThere are N buildings in the city. Each building is a rectangle fully occupying a number of unit squares. **No two \nbuildings touch or overlap**, i.e. Kirk can walk freely around every building. A building is defined by specifying \nthe coordinates of two diagonally opposite squares occupied by the building. \n\nIn each step, Kirk can walk to one of the four neighboring squares, but he is not allowed to step onto a square \noccupied by a building. His current position is at the west entrance to the city and the x coordinate of every \nsquare occupied by a building is **strictly greater than zero**. \n\nWrite a program that, given the locations of the buildings, finds **one shortest possible path** from Kirk's current \nposition to his destination. A path should be reported as a sequence of vertical and horizontal segments, with no \ntwo consecutive segments parallel. The length of a path is the number of squares contained in the path, \nexcluding the initial square.", "inputFormat": "The first line of input contains two integers X, Y (1 ≤ X ≤ 106, -106 ≤ Y ≤ 106) – the coordinates of the \ndestination square. The second line of input contains a single integer N (0 ≤ N ≤ 100 000) – the number of \nbuildings in the city. Each of the following N lines contains four integers X1, Y1, X2, Y2 (1 ≤ X1, X2 ≤ 106, \n-106 ≤ Y1, Y2 ≤ 106) – the coordinates of two diagonally opposite squares occupied by the building.", "outputFormat": "The first line of output should contain an integer L – the length of the shortest path to the destination. \nThe second line of output should contain an integer M – the number of segments in the shortest path. The \nnumber of segments M must not exceed 1,000,000. \n\nEach of the following M lines should contain two integers, DX and DY, describing Kirk's relative movement in \none segment. For each segment, **exactly one** of the values DX, DY should be zero, and no two consecutive \nsegments should be parallel. \n\nNote: if there are multiple solutions, you should output any one of them.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/tyf2lbht.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/ddujl7ea.png)\n\n**Note**: each of the figures depicts the respective input, along with the supplied solution.\n\n**注意：原题还要求输出方案，本题略去。**", "locale": "en"}, "zh-CN": {"title": "[CEOI 2006] Walk", "background": "", "description": "在一个陌生的大城市中找到你的目的地可能是一个挑战，尤其是如果你像 Kirk 一样是一名计算机科学家，总是试图使用最短的路径。规划可以有所帮助——给定城市的地图，Kirk 想要找到他当前位置和目的地之间的最短路径。\n\n城市的地图可以在平面上表示为由单位方格组成的无限网格。\n\nKirk 目前位于方格 (0, 0)，他的目的地是方格 (X, Y)。\n\n城市中有 N 座建筑。每座建筑是一个完全占据若干单位方格的矩形。**没有两座建筑接触或重叠**，即 Kirk 可以自由地绕过每座建筑。建筑通过指定建筑占据的两个对角方格的坐标来定义。\n\n在每一步中，Kirk 可以走到四个相邻方格之一，但他不能踏上被建筑占据的方格。他目前的位置在城市的西入口，每个被建筑占据的方格的 x 坐标**严格大于零**。\n\n编写一个程序，给定建筑的位置，找到从 Kirk 当前的位置到他目的地的**一条最短路径**。路径应报告为一系列垂直和水平线段，且没有两个连续的线段是平行的。路径的长度是路径中包含的方格数，不包括初始方格。", "inputFormat": "输入的第一行包含两个整数 X, Y (1 ≤ X ≤ 10^6, -10^6 ≤ Y ≤ 10^6)——目的地方格的坐标。输入的第二行包含一个整数 N (0 ≤ N ≤ 100,000)——城市中的建筑数量。接下来的 N 行中的每一行包含四个整数 X1, Y1, X2, Y2 (1 ≤ X1, X2 ≤ 10^6, -10^6 ≤ Y1, Y2 ≤ 10^6)——建筑占据的两个对角方格的坐标。", "outputFormat": "输出的第一行应包含一个整数 L——到达目的地的最短路径的长度。输出的第二行应包含一个整数 M——最短路径中的线段数量。线段数量 M 不得超过 1,000,000。\n\n接下来的 M 行中的每一行应包含两个整数 DX 和 DY，描述 Kirk 在一个线段中的相对移动。对于每个线段，**恰好一个**值 DX 或 DY 应为零，并且没有两个连续的线段是平行的。\n\n注意：如果有多个解决方案，你应该输出其中任何一个。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/tyf2lbht.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/ddujl7ea.png)\n\n**注意：原题还要求输出方案，本题略去。**\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6889", "type": "P", "difficulty": 0, "samples": [["17 15\n+-+-+-+-+-+-+-+\n|             |\n+ + + + + + + +\n|X  |   |     |\n+ + + + + + + +\n|   |   |  X  |\n+-+ + + + + + +\n|       |     |\n+ + + +-+-+-+-+\n|            X|\n+ + +-+-+-+-+ +\n|             |\n+ + + + + + + +\n|  X|         |\n+ + + + + + + +\n|  |          |\n+-+-+-+-+-+-+-+", "30\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2006", "CEOI（中欧）"], "title": "[CEOI 2006] CONNECT", "background": "", "description": "Back in the day when the famous sixteen-bit three-letter operating system most often used on an 25x80 terminal dominated the PC market, \"Nibbles\" was everyone's favorite computer game. This problem, however, is not related to Nibbles – it is related to a game called \"Connect\" which is almost, but not quite, entirely unlike\nNibbles.\n\nConnect is played on a board composed of squares organized into R rows and $C$ columns, where both $R$ and $C$ are **odd numbers**. Rows and columns are numbered $1$ to $R$ and $1$ to $C$, respectively. Each position on the board\nis either free or blocked by a wall. Additionally, each board satisfies the following constraints:\n\n- Squares with **both coordinates even** are called rooms. They are **never blocked**.\n- Squares with **both coordinates odd** are called barriers. They are **always blocked**\n- All other squares are called corridors. They may or may not be blocked.\n- Corridors **along the edge** of the board are **always blocked**.\n\nBarriers are represented by the '+' (plus) character, blocked horizontal corridors by the '|' (pipe) character, while blocked vertical corridors are represented by the '–' (minus) character. Rooms and free corridors are represented by the blank character.\n\n  At the beginning of the game an **even number** of figures (represented by the uppercase letter 'X') are placed on the board – each in a separate **room**. $A$ path between figures $A$ and $B$ is a sequence of **free** squares starting from $A$, ending with $B$ and moving in one of the **four possible directions** in each step (the path includes both endpoint squares, $A$ and $B$). The length of the path is the total number of steps needed to get from $A$ to $B$  (which is equal to the number of squares contained in the path minus one).\n\n  The goal of the player is to first **divide all the figures into pairs**, and then, for each pair, **connect** the two figures with a path. The pairs should be connected in such a way that **no two paths share a common square**.\n\n  For a completed game, the score is defined as **the sum of the lengths** of all paths.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ytczh4t.png)\n\nWrite a program that, given the starting position of the Connect game, plays the game in such a way that the **minimum possible score** is achieved.\nThe test data will guarantee that a solution, although not necessarily unique, will always exist. \n\n\n\n", "inputFormat": "The first line of input is two integers: $R$ and $C$, where $R$ is the number of rows and $C$ is the number of columns. $R$ and $C$ are both odd numbers.\n\nThe next $R$ lines each contain $C$ characters, each of which is one of `+`, `|`, `-`, space or `X`, representing obstacles and two types of walls, respectively, a space represents a room or a passable corridor, and `X` represents an item in the room.", "outputFormat": "The first line of output is an integer, which is the minimum score.\n\nThis task **does not** require outputting a legal solution", "hint": "$5 \\leqslant R \\leqslant 25$，$5 \\leqslant C \\leqslant 80$", "locale": "en", "translations": {"en": {"title": "[CEOI 2006] CONNECT", "background": "", "description": "Back in the day when the famous sixteen-bit three-letter operating system most often used on an 25x80 terminal dominated the PC market, \"Nibbles\" was everyone's favorite computer game. This problem, however, is not related to Nibbles – it is related to a game called \"Connect\" which is almost, but not quite, entirely unlike\nNibbles.\n\nConnect is played on a board composed of squares organized into R rows and $C$ columns, where both $R$ and $C$ are **odd numbers**. Rows and columns are numbered $1$ to $R$ and $1$ to $C$, respectively. Each position on the board\nis either free or blocked by a wall. Additionally, each board satisfies the following constraints:\n\n- Squares with **both coordinates even** are called rooms. They are **never blocked**.\n- Squares with **both coordinates odd** are called barriers. They are **always blocked**\n- All other squares are called corridors. They may or may not be blocked.\n- Corridors **along the edge** of the board are **always blocked**.\n\nBarriers are represented by the '+' (plus) character, blocked horizontal corridors by the '|' (pipe) character, while blocked vertical corridors are represented by the '–' (minus) character. Rooms and free corridors are represented by the blank character.\n\n  At the beginning of the game an **even number** of figures (represented by the uppercase letter 'X') are placed on the board – each in a separate **room**. $A$ path between figures $A$ and $B$ is a sequence of **free** squares starting from $A$, ending with $B$ and moving in one of the **four possible directions** in each step (the path includes both endpoint squares, $A$ and $B$). The length of the path is the total number of steps needed to get from $A$ to $B$  (which is equal to the number of squares contained in the path minus one).\n\n  The goal of the player is to first **divide all the figures into pairs**, and then, for each pair, **connect** the two figures with a path. The pairs should be connected in such a way that **no two paths share a common square**.\n\n  For a completed game, the score is defined as **the sum of the lengths** of all paths.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ytczh4t.png)\n\nWrite a program that, given the starting position of the Connect game, plays the game in such a way that the **minimum possible score** is achieved.\nThe test data will guarantee that a solution, although not necessarily unique, will always exist. \n\n\n\n", "inputFormat": "The first line of input is two integers: $R$ and $C$, where $R$ is the number of rows and $C$ is the number of columns. $R$ and $C$ are both odd numbers.\n\nThe next $R$ lines each contain $C$ characters, each of which is one of `+`, `|`, `-`, space or `X`, representing obstacles and two types of walls, respectively, a space represents a room or a passable corridor, and `X` represents an item in the room.", "outputFormat": "The first line of output is an integer, which is the minimum score.\n\nThis task **does not** require outputting a legal solution", "hint": "$5 \\leqslant R \\leqslant 25$，$5 \\leqslant C \\leqslant 80$", "locale": "en"}, "zh-CN": {"title": "[CEOI 2006] CONNECT", "background": "", "description": "早些年，当著名的十六位三字母操作系统最常用于 25x80 终端并主导 PC 市场时，“Nibbles” 是每个人最喜欢的电脑游戏。然而，这个问题与 Nibbles 无关——它与一个名为“Connect”的游戏有关，这个游戏几乎完全不像 Nibbles。\n\nConnect 在一个由方格组成的棋盘上进行，棋盘由 R 行和 C 列组成，其中 R 和 C 都是**奇数**。行和列分别编号为 1 到 R 和 1 到 C。棋盘上的每个位置要么是空闲的，要么被墙壁阻挡。此外，每个棋盘满足以下约束：\n\n- **两个坐标都是偶数**的方格称为房间。它们**永远不会被阻挡**。\n- **两个坐标都是奇数**的方格称为障碍物。它们**总是被阻挡**。\n- 所有其他方格称为走廊。它们可能被阻挡，也可能不被阻挡。\n- **沿着棋盘边缘**的走廊**总是被阻挡**。\n\n障碍物用 '+'（加号）字符表示，阻挡的水平走廊用 '|'（竖线）字符表示，而阻挡的垂直走廊用 '–'（减号）字符表示。房间和空闲走廊用空白字符表示。\n\n在游戏开始时，**偶数个**棋子（用大写字母 'X' 表示）被放置在棋盘上——每个棋子在一个单独的**房间**里。棋子 A 和 B 之间的路径是一系列**空闲**方格，从 A 开始，以 B 结束，每一步都在**四个可能的方向**之一移动（路径包括两个端点方格，A 和 B）。路径的长度是从 A 到 B 所需的总步数（等于路径中包含的方格数减一）。\n\n玩家的目标是首先**将所有棋子分成对**，然后，对于每对棋子，**用路径连接**这两个棋子。对应该以这样的方式连接，即**没有两条路径共享一个公共方格**。\n\n对于完成的游戏，得分定义为所有路径的长度之和。\n\n编写一个程序，给定 Connect 游戏的起始位置，以实现**可能的最小得分**来进行游戏。测试数据将保证一个解，尽管不一定是唯一的，总是存在的。", "inputFormat": "第一行输入为两个整数：$R$ 和 $C$，其中 $R$ 为行数，$C$ 为列数，$R$，$C$ 均为奇数。\n\n接下来的 $R$ 行每行包括 $C$ 个字符，每个字符都是 `+`、`|`、`-`、空格或 `X` 中的一个，分别表示障碍及两种墙壁，空格表示房间或可通过的走廊，`X` 表示房间中的物品。", "outputFormat": "输出的第一行是一个整数，即最小分值。\n\n本题**不要求**输出合法方案。", "hint": "$5 \\leqslant R \\leqslant 25$，$5 \\leqslant C \\leqslant 80$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6890", "type": "P", "difficulty": 5, "samples": [["8 3\n1 2\n2 3\n3 5\n4 5\n5 6\n6 7\n7 8\n8 5", "2"], ["14 4\n1 2\n2 3\n3 4\n4 5\n7 5\n5 6\n6 3\n8 10\n10 9\n9 8\n14 13\n13 12\n12 11\n11 14", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2006", "CEOI（中欧）"], "title": "[CEOI 2006] Link", "background": "", "description": "Webmaster Kirk is reorganizing his school's website. There are a number of pages on the website and the\ncontent is fine, but he noticed that the pages are not properly linked. In fact, every page contains exactly one link, pointing to some other page in the website. This is a poor design – starting from the homepage, a visitor will usually have to follow many links before reaching the page of his interest, and some pages might not be reachable from the homepage at all. As a first step, he wants to add a few links so that every page can be quickly accessed from the homepage. New links can be added anywhere in the website.\n\nThe website contains N pages marked with integers 1 to N and the homepage is marked with the number 1.\n\nThere are also N links; **each page contains exactly one link** pointing to some **different** page. For an integer\nK, a website is said to be **K-reachable** if every page on the website other than the homepage can be reached from the homepage by following **at most K** links.\n\nWrite a program that, given the description of the website and an integer K, finds the **minimum number of links that need to be added** in order to make the website K-reachable.", "inputFormat": "The first line of input contains two integers $N$ and $K$ ($2\\leq N\\leq500000$, $1\\leq K\\leq20000$) – the number of pages and the target maximum number of links to be followed.\n\nEach of the following $N$ lines contains two different integers $A$ and $B$ ($1\\leq A, B\\leq N$) meaning that the link on page $A$ points to page $B$.", "outputFormat": "The first and only line of output should contain a single integer, the minimum number of additional links required to make the website $K$ - reachable. ", "hint": "在第二组样例中，一个合法的路径集合 $\\{1\\to 7,1\\to 14,14\\to 10\\}$。\n\n$2 ≤ N ≤ 500 000$, $1 ≤ K ≤ 20 000$。", "locale": "en", "translations": {"en": {"title": "[CEOI 2006] Link", "background": "", "description": "Webmaster Kirk is reorganizing his school's website. There are a number of pages on the website and the\ncontent is fine, but he noticed that the pages are not properly linked. In fact, every page contains exactly one link, pointing to some other page in the website. This is a poor design – starting from the homepage, a visitor will usually have to follow many links before reaching the page of his interest, and some pages might not be reachable from the homepage at all. As a first step, he wants to add a few links so that every page can be quickly accessed from the homepage. New links can be added anywhere in the website.\n\nThe website contains N pages marked with integers 1 to N and the homepage is marked with the number 1.\n\nThere are also N links; **each page contains exactly one link** pointing to some **different** page. For an integer\nK, a website is said to be **K-reachable** if every page on the website other than the homepage can be reached from the homepage by following **at most K** links.\n\nWrite a program that, given the description of the website and an integer K, finds the **minimum number of links that need to be added** in order to make the website K-reachable.", "inputFormat": "The first line of input contains two integers $N$ and $K$ ($2\\leq N\\leq500000$, $1\\leq K\\leq20000$) – the number of pages and the target maximum number of links to be followed.\n\nEach of the following $N$ lines contains two different integers $A$ and $B$ ($1\\leq A, B\\leq N$) meaning that the link on page $A$ points to page $B$.", "outputFormat": "The first and only line of output should contain a single integer, the minimum number of additional links required to make the website $K$ - reachable. ", "hint": "在第二组样例中，一个合法的路径集合 $\\{1\\to 7,1\\to 14,14\\to 10\\}$。\n\n$2 ≤ N ≤ 500 000$, $1 ≤ K ≤ 20 000$。", "locale": "en"}, "zh-CN": {"title": "[CEOI 2006] Link", "background": "", "description": "网站管理员 Kirk 正在重新组织他学校的网站。网站上有许多页面，内容很好，但他注意到页面之间的链接不够合理。事实上，每个页面都只包含一个链接，指向网站中的其他页面。这是一个糟糕的设计——从主页开始，访问者通常需要点击许多链接才能到达他感兴趣的页面，而且有些页面可能根本无法从主页访问。作为第一步，他想添加一些链接，以便每个页面都可以从主页快速访问。新链接可以添加在网站的任何地方。\n\n网站包含 $N$ 个页面，用整数 1 到 $N$ 标记，主页标记为数字 1。\n\n每个页面也有 $N$ 个链接；**每个页面都包含一个指向其他页面的链接**。对于整数 $K$，如果网站上的每个页面（除了主页）都可以通过**最多 $K$ 个链接**从主页访问，则称该网站是 **K-可达的**。\n\n编写一个程序，给定网站的描述和整数 $K$，找出为了使网站 K-可达所需添加的**最少链接数**。", "inputFormat": "第一行是两个整数用空格隔开 $N$ 和 $K$。\n\n接下来 $N$ 行：\n\n其中第 $i+1$ 行 $(1\\leqslant i\\leqslant N)$ 输入两个整数 $x$ 和 $y$，表示存在一条从 $x$ 到 $y$ 的单向边。", "outputFormat": "输出仅一个整数：表示最少需要添加的边数。", "hint": "在第二组样例中，一个合法的路径集合 $\\{1\\to 7,1\\to 14,14\\to 10\\}$。\n\n$2 \\leq N \\leq 500 000$, $1 \\leq K \\leq 20 000$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6891", "type": "P", "difficulty": 6, "samples": [["3\n2 5 4 9 15 11\n6 7 6 8 12 14", "AABABB"], ["2\n1 4 10 20\n3 5 8 13", "BBAA"], ["2\n3 4 5 6\n10 9 8 7", "-1"], ["6\n25 18 40 37 29 95 41 53 39 69 61 90\n14 18 22 28 18 30 32 32 63 58 71 78", "BABBABAABABA"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "Special Judge", "JOISC/JOIST（日本）"], "title": "[JOISC 2020] ビルの飾り付け 4", "background": "JOISC2020 Day 1 T1", "description": "给定两个长度为 $2n$ 的序列 $A,B$，构造一个长度为 $2n$ 的序列 $C$ 满足以下条件：\n\n- 对于 $1\\leq i\\leq 2n$，$C_i$ 只能从 $A_i$ 和 $B_i$ 中选取\n\n- $C_i$ 从 $A_i$ 中选取的次数和从 $B_i$ 中选取的次数都恰好为 $n$。\n\n- $C$ 为单调不降的序列。\n\n如果满足条件的 $C$ 有多个，只需要输出一个。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $2n$ 个数字，第 $i$ 个为 $A_i$。\n\n第三行 $2n$ 个数字，第 $i$ 个为 $B_i$。", "outputFormat": "如果无解则输出 $-1$，否则按照以下方式输出一个字符串 $s$：\n\n对于 $1\\leq i\\leq 2n$，如果 $C_i$ 是从 $A_i$ 选取的则 $s_i=\\texttt{A}$，否则 $s_i=\\texttt{B}$。", "hint": "#### 样例 1 解释\n\n构造的 $C=[2,5,6,9,12,14]$，可以自行这是满足条件的方案。\n\n#### 样例 2 解释\n\n另外有 $\\texttt{AABB},\\texttt{ABAB},\\texttt{BABA},\\texttt{BAAB},\\texttt{ABBA}$ 这 $5$ 组解，输出任何一组均可。\n\n#### 样例 3 解释\n\n没有满足条件的方案。\n\n#### 子任务\n\n| 子任务 | 特殊性质 | 分数 |\n| :----------: | :----------: | :----------: |\n| $1$ | $1\\leq n\\leq 2\\times 10^3$ | $11$ |\n| $2$ | 无 | $89$ |\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 5\\times 10^5,1\\leq A_i,B_i\\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2020] ビルの飾り付け 4", "background": "JOISC2020 Day 1 T1", "description": "给定两个长度为 $2n$ 的序列 $A,B$，构造一个长度为 $2n$ 的序列 $C$ 满足以下条件：\n\n- 对于 $1\\leq i\\leq 2n$，$C_i$ 只能从 $A_i$ 和 $B_i$ 中选取\n\n- $C_i$ 从 $A_i$ 中选取的次数和从 $B_i$ 中选取的次数都恰好为 $n$。\n\n- $C$ 为单调不降的序列。\n\n如果满足条件的 $C$ 有多个，只需要输出一个。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $2n$ 个数字，第 $i$ 个为 $A_i$。\n\n第三行 $2n$ 个数字，第 $i$ 个为 $B_i$。", "outputFormat": "如果无解则输出 $-1$，否则按照以下方式输出一个字符串 $s$：\n\n对于 $1\\leq i\\leq 2n$，如果 $C_i$ 是从 $A_i$ 选取的则 $s_i=\\texttt{A}$，否则 $s_i=\\texttt{B}$。", "hint": "#### 样例 1 解释\n\n构造的 $C=[2,5,6,9,12,14]$，可以自行这是满足条件的方案。\n\n#### 样例 2 解释\n\n另外有 $\\texttt{AABB},\\texttt{ABAB},\\texttt{BABA},\\texttt{BAAB},\\texttt{ABBA}$ 这 $5$ 组解，输出任何一组均可。\n\n#### 样例 3 解释\n\n没有满足条件的方案。\n\n#### 子任务\n\n| 子任务 | 特殊性质 | 分数 |\n| :----------: | :----------: | :----------: |\n| $1$ | $1\\leq n\\leq 2\\times 10^3$ | $11$ |\n| $2$ | 无 | $89$ |\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 5\\times 10^5,1\\leq A_i,B_i\\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P6892", "type": "P", "difficulty": 7, "samples": [["5\n", "8 to -1\n3 to 8\n6 to 3\n0 to 6\n9 to 0\n"], ["8\n", "10 to -1\n3 to 10\n14 to 3\n7 to 14\n0 to 7\n11 to 0\n4 to 11\n15 to 4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2014", "Special Judge", "构造", "ICPC", "WF"], "title": "[ICPC 2014 WF] Baggage", "background": "", "description": "An airline has two flights leaving at about the same time from ICPCity, one to city B and one to city A. The airline also has $n$ counters where passengers check their baggage. At each counter there is a pair of identical baggage bins, one for city B and one for city A.\n\nJust before the flights depart, each pair of baggage bins is moved by a motorized cart to a sorting area. The cart always moves two bins at a time, one for city B and one for city A. After all the bins have been moved, they line up in the sorting area like this:\n\n  B A B A B A ... B A \n\nThat is, there are $2n$ baggage bins in a row, starting with a bin for city B, then one for city A, and so forth. The task now is to reorder them so all the baggage bins for city A precede the baggage bins for city B. Then the bins can be loaded on the appropriate aircraft.\n\nThe reordering is done by moving pairs of adjacent baggage bins (not necessarily B then A), again via the motorized cart. For proper balance, the cart must always carry two bins, never just one. A pair of bins must always be moved to an empty space that is at least two bins wide. On the left of the first bin are some empty spaces that can be used as needed during the reordering.\n\nWhen the reordering process begins, the bin locations are numbered from $1$ (initially containing the leftmost B baggage bin) to $2n$ (initially containing the rightmost A baggage bin). There are $2n$ initially empty spaces to the left of the bins, numbered from $0$ to $-2n+1$, as shown in Figure 1 for the case $n=4$.\n![](https://cdn.luogu.com.cn/upload/image_hosting/fwkcv2gq.png)\n\n   Figure 1: Initial configuration of bins and empty spaces for $n = 4$ \n\nGiven $n$, find a shortest sequence of moves that will reorder the bins so that all the A bins are to the left of all the B bins. At the end of the process, it is possible that the leftmost A bin is at some location other than $1$, but the bins must be adjacent in a sequence of $2n$ locations.", "inputFormat": "The input consists of a single test case, which consists of the integer $n$ $(3 \\leq n \\leq 100)$.", "outputFormat": "Display a shortest sequence of moves that will correctly reorder the bins. Each move is of the form “$f$ to $t$”, where $f$ and $t$ are integers representing the movement of the bins in locations $f$ and $f + 1$ to locations $t$ and $t + 1$. If multiple solutions are possible, display any one of them.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Baggage", "background": "", "description": "An airline has two flights leaving at about the same time from ICPCity, one to city B and one to city A. The airline also has $n$ counters where passengers check their baggage. At each counter there is a pair of identical baggage bins, one for city B and one for city A.\n\nJust before the flights depart, each pair of baggage bins is moved by a motorized cart to a sorting area. The cart always moves two bins at a time, one for city B and one for city A. After all the bins have been moved, they line up in the sorting area like this:\n\n  B A B A B A ... B A \n\nThat is, there are $2n$ baggage bins in a row, starting with a bin for city B, then one for city A, and so forth. The task now is to reorder them so all the baggage bins for city A precede the baggage bins for city B. Then the bins can be loaded on the appropriate aircraft.\n\nThe reordering is done by moving pairs of adjacent baggage bins (not necessarily B then A), again via the motorized cart. For proper balance, the cart must always carry two bins, never just one. A pair of bins must always be moved to an empty space that is at least two bins wide. On the left of the first bin are some empty spaces that can be used as needed during the reordering.\n\nWhen the reordering process begins, the bin locations are numbered from $1$ (initially containing the leftmost B baggage bin) to $2n$ (initially containing the rightmost A baggage bin). There are $2n$ initially empty spaces to the left of the bins, numbered from $0$ to $-2n+1$, as shown in Figure 1 for the case $n=4$.\n![](https://cdn.luogu.com.cn/upload/image_hosting/fwkcv2gq.png)\n\n   Figure 1: Initial configuration of bins and empty spaces for $n = 4$ \n\nGiven $n$, find a shortest sequence of moves that will reorder the bins so that all the A bins are to the left of all the B bins. At the end of the process, it is possible that the leftmost A bin is at some location other than $1$, but the bins must be adjacent in a sequence of $2n$ locations.", "inputFormat": "The input consists of a single test case, which consists of the integer $n$ $(3 \\leq n \\leq 100)$.", "outputFormat": "Display a shortest sequence of moves that will correctly reorder the bins. Each move is of the form “$f$ to $t$”, where $f$ and $t$ are integers representing the movement of the bins in locations $f$ and $f + 1$ to locations $t$ and $t + 1$. If multiple solutions are possible, display any one of them.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Baggage", "background": null, "description": "一家航空公司有两趟航班几乎同时从 ICPCity 出发，一趟飞往城市 B，另一趟飞往城市 A。航空公司有 $n$ 个柜台供乘客托运行李。每个柜台都有一对相同的行李箱，一个用于城市 B，一个用于城市 A。\n\n就在航班起飞前，每对行李箱会被一辆电动推车移动到一个分拣区。推车总是一次移动两个箱子，一个用于城市 B，一个用于城市 A。所有箱子移动完后，它们在分拣区排成如下的顺序：\n\nB A B A B A ... B A\n\n也就是说，有 $2n$ 个行李箱排成一行，从一个城市 B 的箱子开始，然后是一个城市 A 的箱子，如此交替。现在的任务是重新排列它们，使得所有城市 A 的行李箱都排在城市 B 的行李箱之前。然后这些箱子可以被装载到相应的飞机上。\n\n重新排列是通过移动相邻的一对行李箱（不一定是 B 然后是 A），同样通过电动推车进行。为了保持平衡，推车必须总是携带两个箱子，不能只携带一个。每对箱子必须移动到至少有两个箱子宽度的空位上。在第一个箱子的左边有一些空位，在重新排列过程中可以根据需要使用。\n\n当重新排列过程开始时，箱子的位置从 $1$ 开始编号（最初包含最左边的 B 行李箱）到 $2n$（最初包含最右边的 A 行李箱）。在箱子的左边有 $2n$ 个初始空位，编号从 $0$ 到 $-2n+1$，如图 1 所示，$n=4$ 的情况。\n\n![图 1](https://cdn.luogu.com.cn/upload/image_hosting/fwkcv2gq.png)\n\n图 1：$n = 4$ 时箱子和空位的初始配置\n\n给定 $n$，找出一个最短的移动序列，以便重新排列箱子，使得所有 A 箱子都在所有 B 箱子的左边。在过程结束时，最左边的 A 箱子可能在位置 $1$ 之外的某个位置，但箱子必须在 $2n$ 个位置的序列中相邻。", "inputFormat": "输入由一个单一的测试用例组成，包含一个整数 $n$ $(3 \\leq n \\leq 100)$。", "outputFormat": "显示一个最短的移动序列，该序列可以正确地重新排列箱子。每个移动的形式为“$f$ to $t$”，其中 $f$ 和 $t$ 是整数，表示位置 $f$ 和 $f + 1$ 的箱子移动到位置 $t$ 和 $t + 1$。如果有多个解决方案，显示其中任意一个。", "hint": "时间限制：1000 毫秒，内存限制：1048576 KB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2014。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6893", "type": "P", "difficulty": 6, "samples": [["2 15\nD 4 10 1\nC 6 1\n", "40.500000000\n"], ["3 15\nD 4 10 1\nC 6 1\nC 9 3\n", "49.000000000\n"], ["2 19\nD 4 5 1\nD 6 3 2\n", "impossible\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2014", "Special Judge", "背包 DP", "ICPC", "WF"], "title": "[ICPC 2014 WF] Buffed Buffet", "background": "", "description": "You are buying lunch at a buffet. A number of different dishes are available, and you can mix and match them to your heart’s desire. Some of the dishes, such as dumplings and roasted potatoes, consist of pieces of roughly equal size, and you can pick an integral number of such pieces (no splitting is allowed). Refer to these as “discrete dishes.” Other dishes, such as tzatziki or mashed potatoes, are fluid and you can pick an arbitrary real-valued amount of them. Refer to this second type as “continuous dishes.”\n\nOf course, you like some of the dishes more than others, but how much you like a dish also depends on how much of it you have already eaten. For instance, even if you generally prefer dumplings to potatoes, you might prefer a potato over a dumpling if you have already eaten ten dumplings. To model this, each dish $i$ has an initial tastiness $t_ i$, and a rate of decay of the tastiness $\\Delta t_ i$. For discrete dishes, the tastiness you experience when eating the $n^{th}$ item of the dish is $t_ i - (n-1)\\Delta t_ i$. For continuous dishes, the tastiness you experience when eating an infinitesimal amount $d x$ grams of the dish after already having eaten $x$ grams is $(t_ i - x \\Delta t_ i) d x$. In other words, the respective total amounts of tastiness you experience when eating $N$ items of a discrete dish or $X$ grams of a continuous dish are as follows:\n\n$$\\begin{aligned} \\sum _{n=1}^{N} (t_ i - (n-1)\\Delta t_ i) & &  \\text {and} & & \\int _{0}^ X (t_ i - x\\Delta t_ i) dx  \\end{aligned} $$\n\nFor simplicity, do not take into account that different dishes may or may not go well together, so define the total tastiness that you experience from a meal as the sum of the total tastinesses of the individual dishes in the meal (and the same goes for the weight of a meal – there are no food antiparticles in the buffet!).\n\nYou have spent days of painstaking research determining the numbers $t_ i$ and $\\Delta t_ i$ for each of the dishes in the buffet. All that remains is to compute the maximum possible total tastiness that can be achieved in a meal of weight $w$. Better hurry up, lunch is going to be served soon!", "inputFormat": "The input consists of a single test case. The first line of input consists of two integers $d$ and $w$ ($1 \\le d \\le {250}$ and $1 \\le w \\le {10\\, 000}$), where $d$ is the number of different dishes at the buffet and $w$ is the desired total weight of your meal in grams.\n\nThen follow $d$ lines, the $i^{th}$ of which describes the $i^{th}$ dish. Each dish description is in one of the following two forms:\n\nA description of the form “D $w_ i$ $t_ i$ $\\Delta t_ i$” indicates that this is a discrete dish where each item weighs $w_ i$ grams, with initial tastiness $t_ i$ and decay of tastiness $\\Delta t_ i$.\n\nA description of the form “C $t_ i$ $\\Delta t_ i$” indicates that this is a continuous dish with initial tastiness $t_ i$ and decay of tastiness $\\Delta t_ i$.\n\nThe numbers $w_ i$, $t_ i$, and $\\Delta t_ i$ are integers satisfying $1 \\le w_ i \\le {10\\, 000}$ and $0 \\le t_ i, \\Delta t_ i \\le {10\\, 000}$.", "outputFormat": "Display the maximum possible total tastiness of a meal of weight $w$ based on the available dishes. Give the answer with a relative or absolute error of at most $10^{-6}$. If it is impossible to make a meal of total weight exactly $w$ based on the available dishes, display impossible.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Buffed Buffet", "background": "", "description": "You are buying lunch at a buffet. A number of different dishes are available, and you can mix and match them to your heart’s desire. Some of the dishes, such as dumplings and roasted potatoes, consist of pieces of roughly equal size, and you can pick an integral number of such pieces (no splitting is allowed). Refer to these as “discrete dishes.” Other dishes, such as tzatziki or mashed potatoes, are fluid and you can pick an arbitrary real-valued amount of them. Refer to this second type as “continuous dishes.”\n\nOf course, you like some of the dishes more than others, but how much you like a dish also depends on how much of it you have already eaten. For instance, even if you generally prefer dumplings to potatoes, you might prefer a potato over a dumpling if you have already eaten ten dumplings. To model this, each dish $i$ has an initial tastiness $t_ i$, and a rate of decay of the tastiness $\\Delta t_ i$. For discrete dishes, the tastiness you experience when eating the $n^{th}$ item of the dish is $t_ i - (n-1)\\Delta t_ i$. For continuous dishes, the tastiness you experience when eating an infinitesimal amount $d x$ grams of the dish after already having eaten $x$ grams is $(t_ i - x \\Delta t_ i) d x$. In other words, the respective total amounts of tastiness you experience when eating $N$ items of a discrete dish or $X$ grams of a continuous dish are as follows:\n\n$$\\begin{aligned} \\sum _{n=1}^{N} (t_ i - (n-1)\\Delta t_ i) & &  \\text {and} & & \\int _{0}^ X (t_ i - x\\Delta t_ i) dx  \\end{aligned} $$\n\nFor simplicity, do not take into account that different dishes may or may not go well together, so define the total tastiness that you experience from a meal as the sum of the total tastinesses of the individual dishes in the meal (and the same goes for the weight of a meal – there are no food antiparticles in the buffet!).\n\nYou have spent days of painstaking research determining the numbers $t_ i$ and $\\Delta t_ i$ for each of the dishes in the buffet. All that remains is to compute the maximum possible total tastiness that can be achieved in a meal of weight $w$. Better hurry up, lunch is going to be served soon!", "inputFormat": "The input consists of a single test case. The first line of input consists of two integers $d$ and $w$ ($1 \\le d \\le {250}$ and $1 \\le w \\le {10\\, 000}$), where $d$ is the number of different dishes at the buffet and $w$ is the desired total weight of your meal in grams.\n\nThen follow $d$ lines, the $i^{th}$ of which describes the $i^{th}$ dish. Each dish description is in one of the following two forms:\n\nA description of the form “D $w_ i$ $t_ i$ $\\Delta t_ i$” indicates that this is a discrete dish where each item weighs $w_ i$ grams, with initial tastiness $t_ i$ and decay of tastiness $\\Delta t_ i$.\n\nA description of the form “C $t_ i$ $\\Delta t_ i$” indicates that this is a continuous dish with initial tastiness $t_ i$ and decay of tastiness $\\Delta t_ i$.\n\nThe numbers $w_ i$, $t_ i$, and $\\Delta t_ i$ are integers satisfying $1 \\le w_ i \\le {10\\, 000}$ and $0 \\le t_ i, \\Delta t_ i \\le {10\\, 000}$.", "outputFormat": "Display the maximum possible total tastiness of a meal of weight $w$ based on the available dishes. Give the answer with a relative or absolute error of at most $10^{-6}$. If it is impossible to make a meal of total weight exactly $w$ based on the available dishes, display impossible.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Buffed Buffet", "background": null, "description": "自助餐厅里有 $n$ 种食物，分为两大类，为 “离散食物”和“连续食物”。你可以通过吃食物来获得收益。\n\n离散食物用 $(w,t_0,\\Delta t)$ 描述。对于这种食物，你只能吃整数个，每个重为 $w$。吃的第一个收益为 $t_0$，后面每吃一个收益减少 $\\Delta t$。具体的，吃的第 $i$ 个这种食物 （从 $1$ 开始标号），收益为 $t_0-(i-1)\\Delta t$。\n\n连续食物用 $(t_0,\\Delta t)$ 描述。对于这种食物，你可以吃任意食物的重量。如果你吃的重量为 $w$，获得的收益是 $t_0w-\\dfrac{1}{2}\\Delta t w^2$。\n\n你现在要吃重量和 **恰好** 为 $W$ 的食物。最大化你的收益。", "inputFormat": "第一行是两个整数 $n,W$，接下来每行先来一个字母，如果是 C 表示连续食物，后面跟两个整数表示 $t_0,\\Delta t$；如果是 D 表示离散食物，后面跟三个整数，表示 $w,t_0,\\Delta t$。", "outputFormat": "一行一个数表示答案。相对或绝对误差不超过 $1e-6$。\n\n如果没有一种方案使重量和恰好为 $W$ 输出 `impossible`。", "hint": "$n\\le 250,W\\le 10000$。\n\n对于离散食物，满足 $1\\le w\\le 10000$。\n\n对于所有食物，满足 $0\\le t_0,t\\le 10000$。", "locale": "zh-CN"}}}
{"pid": "P6894", "type": "P", "difficulty": 5, "samples": [["7\n50 50\n0 50\n0 0\n30 0\n30 30\n40 40\n50 40\n", "0 .. 1017\n"], ["7\n50 50\n0 50\n0 0\n10 0\n10 30\n20 40\n50 40\n", "unstable\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "计算几何", "2014", "ICPC", "WF"], "title": "[ICPC 2014 WF] Crane Balancing", "background": "", "description": "Wherever there is large-scale construction, you will find cranes that do the lifting. One hardly ever thinks about what marvelous examples of engineering cranes are: a structure of (relatively) little weight that can lift much heavier loads. But even the best-built cranes may have a limit on how much weight they can lift.\n\nThe Association of Crane Manufacturers (ACM) needs a program to compute the range of weights that a crane can lift. Since cranes are symmetric, ACM engineers have decided to consider only a cross section of each crane, which can be viewed as a polygon resting on the $x$-axis.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2lyejm47.png)\n\n   Figure 1: Crane cross section \n\nFigure 1 shows a cross section of the crane in the first sample input. Assume that every $1 \\times 1$ unit of crane cross section weighs 1 kilogram and that the weight to be lifted will be attached at one of the polygon vertices (indicated by the arrow in Figure 1). Write a program that determines the weight range for which the crane will not topple to the left or to the right.", "inputFormat": "The input consists of a single test case. The test case starts with a single integer $n$ ($3 \\le n \\le 100$), the number of points of the polygon used to describe the crane’s shape. The following $n$ pairs of integers $x_ i, y_ i$ ($-2\\, 000 \\le x_ i \\le 2\\, 000, 0 \\le y_ i \\le 2\\, 000$) are the coordinates of the polygon points in order. The weight is attached at the first polygon point and at least two polygon points are lying on the $x$-axis.", "outputFormat": "Display the weight range (in kilograms) that can be attached to the crane without the crane toppling over. If the range is $[a,b]$, display $\\lfloor a \\rfloor $ .. $\\lceil b \\rceil $. For example, if the range is $[1.5,13.3]$, display 1 .. 14. If the range is $[a,\\infty )$, display $\\lfloor a \\rfloor $ .. inf. If the crane cannot carry any weight, display unstable instead.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Crane Balancing", "background": "", "description": "Wherever there is large-scale construction, you will find cranes that do the lifting. One hardly ever thinks about what marvelous examples of engineering cranes are: a structure of (relatively) little weight that can lift much heavier loads. But even the best-built cranes may have a limit on how much weight they can lift.\n\nThe Association of Crane Manufacturers (ACM) needs a program to compute the range of weights that a crane can lift. Since cranes are symmetric, ACM engineers have decided to consider only a cross section of each crane, which can be viewed as a polygon resting on the $x$-axis.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2lyejm47.png)\n\n   Figure 1: Crane cross section \n\nFigure 1 shows a cross section of the crane in the first sample input. Assume that every $1 \\times 1$ unit of crane cross section weighs 1 kilogram and that the weight to be lifted will be attached at one of the polygon vertices (indicated by the arrow in Figure 1). Write a program that determines the weight range for which the crane will not topple to the left or to the right.", "inputFormat": "The input consists of a single test case. The test case starts with a single integer $n$ ($3 \\le n \\le 100$), the number of points of the polygon used to describe the crane’s shape. The following $n$ pairs of integers $x_ i, y_ i$ ($-2\\, 000 \\le x_ i \\le 2\\, 000, 0 \\le y_ i \\le 2\\, 000$) are the coordinates of the polygon points in order. The weight is attached at the first polygon point and at least two polygon points are lying on the $x$-axis.", "outputFormat": "Display the weight range (in kilograms) that can be attached to the crane without the crane toppling over. If the range is $[a,b]$, display $\\lfloor a \\rfloor $ .. $\\lceil b \\rceil $. For example, if the range is $[1.5,13.3]$, display 1 .. 14. If the range is $[a,\\infty )$, display $\\lfloor a \\rfloor $ .. inf. If the crane cannot carry any weight, display unstable instead.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Crane Balancing", "background": null, "description": "无论在哪里进行大规模的建筑施工，你都会看到起重机在进行吊装。人们很少会想到起重机是多么奇妙的工程范例：一个（相对）重量较轻的结构可以举起更重的负载。但即使是建造得最好的起重机也可能对它们能举起的重量有一个限制。\n\n起重机制造商协会（ACM）需要一个程序来计算起重机可以举起的重量范围。由于起重机是对称的，ACM 工程师决定只考虑每个起重机的截面，可以视为一个位于 $x$ 轴上的多边形。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2lyejm47.png)\n\n图 1：起重机截面\n\n图 1 显示了第一个样例输入中起重机的截面。假设每 $1 \\times 1$ 单位的起重机截面重 1 千克，所要举起的重量将附着在多边形的一个顶点（图 1 中箭头所示）。编写一个程序来确定起重机不会向左或向右倾覆的重量范围。", "inputFormat": "输入由一个单一的测试用例组成。测试用例以一个整数 $n$ 开始（$3 \\le n \\le 100$），表示用于描述起重机形状的多边形的顶点数。接下来的 $n$ 对整数 $x_i, y_i$ ($-2,000 \\le x_i \\le 2,000, 0 \\le y_i \\le 2,000$) 是多边形顶点的坐标，按顺序给出。重量附着在第一个多边形顶点上，且至少有两个多边形顶点位于 $x$ 轴上。", "outputFormat": "显示可以附加到起重机而不会使其倾覆的重量范围（以千克为单位）。如果范围是 $[a,b]$，则显示 $\\lfloor a \\rfloor\\texttt{ .. }\\lceil b \\rceil$。例如，如果范围是 $[1.5,13.3]$，则显示 $\\texttt{1 .. 14}$。如果范围是 $[a,\\infty)$，则显示 $\\lfloor a \\rfloor\\texttt{ .. inf}$。如果起重机无法承载任何重量，则显示 `unstable`。", "hint": "时间限制：1000 毫秒，内存限制：1048576 KB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2014。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6895", "type": "P", "difficulty": 5, "samples": [["2\n2 ab b\n1 b\n", "0 1 \n-1 0\n"], ["3\n1 b\n2 b a\n2 ab ac\n", "0 1 -1 \n1 0 -1 \n2 2 0\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2014", "ICPC", "WF"], "title": "[ICPC 2014 WF] Game Strategy", "background": "", "description": "Alice and Bob are playing a board game. The board is divided into positions labeled $a, b, c, d, \\dots $ and the players use a gamepiece to mark the current position. Each round of the game consists of two steps:\n\nAlice makes a choice. Depending on the current position, she has different options, where each option is a set of positions. Alice chooses one set $S$ among the available sets of positions.\n\nBob makes a choice. His choice is one position $p$ from the set $S$ that Alice chose in step 1. Bob moves the gamepiece to position $p$, which is the position for the start of the next round.\n\nPrior to the first round, each player independently selects one of the positions and reveals it at the start of the game. Bob’s position is where the game starts. Alice wins the game if she can force Bob to move the gamepiece to the position she has chosen. To make things interesting, they have decided that Bob will pay Alice a certain amount if he loses, but Alice must pay Bob a certain amount after every round. The game now ends if Alice’s position is reached or when Alice runs out of cash.\n\nBoth Alice and Bob play optimally: Alice will always choose an option that will lead to her winning the game, if this is possible, and Bob will always try to prevent Alice from winning.\n\nFor all possible start and end positions, Alice would like you to determine whether she can win the game and if so, how many rounds it will take.", "inputFormat": "The input consists of a single test case. The first line contains the number of positions $n$ ($1 \\leq n \\leq 25$). The $n$ positions are labeled using the first $n$ letters of the English alphabet in lowercase. The rest of the test case consists of $n$ lines, one for each position $p$, in alphabetical order. The line for position $p$ contains the options available to Alice in position $p$. It starts with the number of options $m$ ($1 \\leq m < 2^ n$), which is followed by $m$ distinct strings, one for each option. Each string contains the positions available to Bob if Alice chooses that option. The string has at least $1$ character, the characters (which correspond to valid board positions) are in alphabetical order, and no characters are duplicated. The total number of options for the test case is at most $10^6$.", "outputFormat": "For each position $p$ in alphabetical order, display one line. In that line, for each position $q$ in alphabetical order display the minimal number of rounds in which Alice can be guaranteed to arrive at position $q$ when starting the game in position $p$, or $-1$ if Alice cannot be guaranteed to reach $q$ from $p$.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Game Strategy", "background": "", "description": "Alice and Bob are playing a board game. The board is divided into positions labeled $a, b, c, d, \\dots $ and the players use a gamepiece to mark the current position. Each round of the game consists of two steps:\n\nAlice makes a choice. Depending on the current position, she has different options, where each option is a set of positions. Alice chooses one set $S$ among the available sets of positions.\n\nBob makes a choice. His choice is one position $p$ from the set $S$ that Alice chose in step 1. Bob moves the gamepiece to position $p$, which is the position for the start of the next round.\n\nPrior to the first round, each player independently selects one of the positions and reveals it at the start of the game. Bob’s position is where the game starts. Alice wins the game if she can force Bob to move the gamepiece to the position she has chosen. To make things interesting, they have decided that Bob will pay Alice a certain amount if he loses, but Alice must pay Bob a certain amount after every round. The game now ends if Alice’s position is reached or when Alice runs out of cash.\n\nBoth Alice and Bob play optimally: Alice will always choose an option that will lead to her winning the game, if this is possible, and Bob will always try to prevent Alice from winning.\n\nFor all possible start and end positions, Alice would like you to determine whether she can win the game and if so, how many rounds it will take.", "inputFormat": "The input consists of a single test case. The first line contains the number of positions $n$ ($1 \\leq n \\leq 25$). The $n$ positions are labeled using the first $n$ letters of the English alphabet in lowercase. The rest of the test case consists of $n$ lines, one for each position $p$, in alphabetical order. The line for position $p$ contains the options available to Alice in position $p$. It starts with the number of options $m$ ($1 \\leq m < 2^ n$), which is followed by $m$ distinct strings, one for each option. Each string contains the positions available to Bob if Alice chooses that option. The string has at least $1$ character, the characters (which correspond to valid board positions) are in alphabetical order, and no characters are duplicated. The total number of options for the test case is at most $10^6$.", "outputFormat": "For each position $p$ in alphabetical order, display one line. In that line, for each position $q$ in alphabetical order display the minimal number of rounds in which Alice can be guaranteed to arrive at position $q$ when starting the game in position $p$, or $-1$ if Alice cannot be guaranteed to reach $q$ from $p$.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Game Strategy", "background": "", "description": "Alice 和 Bob 正在玩一款棋盘游戏。棋盘被分成了标有 $a,b,c,d,...$ 的位置，玩家们使用游戏棋子来标记当前位置。游戏的每一轮包括两个步骤：\n\nAlice 行动。根据当前位置，她有不同的选择，每个选择都是一组位置。Alice 将从可用的位置集合中选择一个集合 $S$。\n\nBob 行动。他的选择是集合 $S$ 中的一个位置 $p$。Bob 将游戏棋子移动到位置 $p$，这会是下一轮游戏的起始位置。\n\n在第一轮之前，每个玩家独立选择一个位置并在游戏开始时公开位置。Bob 的位置是游戏开始的地方。如果 Alice 能够迫使 Bob 将游戏棋子移动到她选择的位置，Alice 就赢得了比赛。为了使事情更有趣，他们决定如果 Bob 输了，他将支付给 Alice 一定金额，但 Alice 必须在每轮之后向 Bob 支付一定金额。如果 Bob 到达 Alice 的位置或者 Alice 没钱了，游戏就结束了。Alice 和 Bob 都采取最佳策略：如果可能的话，Alice 总是选择会能让她赢得比赛的方案，而 Bob 总是试图阻止 Alice 获胜。对于所有可能的起始和结束位置，Alice 希望你确定她是否能够赢得比赛，如果可以，需要多少轮才能赢得比赛。", "inputFormat": "输入由单组数据组成。第一行包含位置数 $n$ $(1\\le n\\le 25)$，这些位置用英文小写字母的前 $n$ 个字母标记。接下来 $n$ 行，每行表示位置 $p$，按字母顺序排列。位置 $p$ 这一行包含 $Alice$ 在该位置的可选项。每行首先输入一个数 $m$ $(1 \\le m < 2^n)$，后跟 $m$ 个不同字符串，每个字符串表示 Alice 选择该方案时 Bob 可移动到的位置。字符串至少包含 $1$ 个字符，这些字符（对应有效的棋盘位置）按字母顺序排列，没有重复字符。数据的方案总数最多为 $10^6$。", "outputFormat": "对于每一个 $p$ 单独输出一行。在该行中，按字母顺序输出每个位置 $q$ 表示 Alice 开始游戏时可以保证到达的最小轮次，或者如果 Alice 不能保证从 $p$ 到达 $q$，则显示 $-1$。\n\n### **说明/提示**\n\n时间限制： $5000$ ms，空间限制：$1048576$ kB。\n\n来源：International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6896", "type": "P", "difficulty": 6, "samples": [["13\n2 2 4\n3 1 3 5\n2 2 4\n3 1 3 6\n2 2 6\n2 4 5\n2 8 9\n2 7 9\n2 7 8\n2 11 13\n2 10 12\n2 11 13\n2 10 12\n", "2 4\n5 6\n7 8 9 10 11 12 13\n"], ["6\n3 3 4 5\n0\n1 1\n1 1\n2 1 6\n1 5\n", "none\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2014", "哈希 hashing", "ICPC", "WF"], "title": "[ICPC 2014 WF] Maze Reduction", "background": "", "description": "Jay runs a small carnival that has various rides and attractions. Unfortunately, times are tough. A recent roller coaster accident, flooding in the restrooms, and an unfortunate clown incident have given Jay’s carnival a bad reputation with the public. With fewer paying customers and reduced revenue, he will need to cut some costs to stay in business.\n\nOne of the biggest carnival attractions is a large, confusing maze. It consists of a variety of circular rooms connected by narrow, twisting corridors. Visitors love getting lost in it and trying to map it out. It has come to Jay’s attention that some of the rooms might be effectively identical to each other. If that’s the case, he will be able to reduce its size without anyone noticing.\n\nTwo rooms $A$ and $B$ are effectively identical if, when you are dropped into either room $A$ or $B$ (and you know the map of the maze), you cannot tell whether you began in $A$ or $B$ just by exploring the maze. The corridor exits are evenly spaced around each room, and you cannot mark or leave anything in a room (in particular, you cannot tell whether you have previously visited it). The only identifying feature that rooms have is their number of exits. Corridors are also twisty enough to be indistinguishable from each other, but when you enter a room you know which corridor you came from, so you can navigate a little by using the order they appear around the room.\n\nJay has appealed to the Association for Carnival Mazery for help. That’s you! Write a program to determine all the sets of effectively identical rooms in the maze.", "inputFormat": "The input consists of a single test case. The first line contains an integer $n$, the number of rooms in the maze ($1 \\leq n \\leq 100$). Rooms are numbered from 1 to $n$. Following this are $n$ lines, describing each room in order. Each line consists of an integer $k$, indicating that this room has $k$ corridors ($0 \\leq k < 100$), and then $k$ distinct integers listing the rooms each corridor connects to (in clockwise order, from an arbitrary starting point). Rooms do not connect to themselves.", "outputFormat": "Display one line for each maximal set of effectively identical rooms (ignoring sets of size 1) containing the room numbers in the set in increasing order. Order the sets by their smallest room numbers. If there are no such sets, display none instead.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Maze Reduction", "background": "", "description": "Jay runs a small carnival that has various rides and attractions. Unfortunately, times are tough. A recent roller coaster accident, flooding in the restrooms, and an unfortunate clown incident have given Jay’s carnival a bad reputation with the public. With fewer paying customers and reduced revenue, he will need to cut some costs to stay in business.\n\nOne of the biggest carnival attractions is a large, confusing maze. It consists of a variety of circular rooms connected by narrow, twisting corridors. Visitors love getting lost in it and trying to map it out. It has come to Jay’s attention that some of the rooms might be effectively identical to each other. If that’s the case, he will be able to reduce its size without anyone noticing.\n\nTwo rooms $A$ and $B$ are effectively identical if, when you are dropped into either room $A$ or $B$ (and you know the map of the maze), you cannot tell whether you began in $A$ or $B$ just by exploring the maze. The corridor exits are evenly spaced around each room, and you cannot mark or leave anything in a room (in particular, you cannot tell whether you have previously visited it). The only identifying feature that rooms have is their number of exits. Corridors are also twisty enough to be indistinguishable from each other, but when you enter a room you know which corridor you came from, so you can navigate a little by using the order they appear around the room.\n\nJay has appealed to the Association for Carnival Mazery for help. That’s you! Write a program to determine all the sets of effectively identical rooms in the maze.", "inputFormat": "The input consists of a single test case. The first line contains an integer $n$, the number of rooms in the maze ($1 \\leq n \\leq 100$). Rooms are numbered from 1 to $n$. Following this are $n$ lines, describing each room in order. Each line consists of an integer $k$, indicating that this room has $k$ corridors ($0 \\leq k < 100$), and then $k$ distinct integers listing the rooms each corridor connects to (in clockwise order, from an arbitrary starting point). Rooms do not connect to themselves.", "outputFormat": "Display one line for each maximal set of effectively identical rooms (ignoring sets of size 1) containing the room numbers in the set in increasing order. Order the sets by their smallest room numbers. If there are no such sets, display none instead.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Maze Reduction", "background": "", "description": "Jay 经营着一个小型嘉年华，里面有各种游乐设施。不幸的是，最近发生的过山车事故、厕所的水灾以及小丑事件使得 Jay 的嘉年华在公众中声誉不佳。由于付费顾客减少和收入下降，他需要削减一些成本以维持经营。\n\n嘉年华中最大的吸引点之一是一个大型且复杂的迷宫。它由各种圆形房间组成，这些房间通过狭窄、曲折的走廊连接。游客们喜欢在其中迷路并尝试绘制地图。Jay 注意到，有些房间可能实际上是相同的。如果是这样，他可以在不被人注意的情况下缩小迷宫的规模。\n\n如果你被放置在房间 $A$ 或 $B$ 中（并且你知道迷宫的地图），仅通过探索迷宫无法判断你是从 $A$ 还是 $B$ 开始的，那么两个房间 $A$ 和 $B$ 就是实际上相同的。每个房间的走廊出口均匀分布，你不能在房间中做标记或留下任何东西（特别是，你无法判断你是否曾经访问过它）。房间的唯一识别特征是它们的出口数量。走廊也足够曲折，以至于彼此无法区分，但当你进入一个房间时，你知道你是从哪个走廊来的，因此可以通过它们在房间周围出现的顺序进行一些导航。\n\nJay 向嘉年华迷宫协会求助。那就是你！编写一个程序来确定迷宫中所有实际上相同的房间集合。", "inputFormat": "输入由一个单一的测试用例组成。第一行包含一个整数 $n$，表示迷宫中的房间数量（$1 \\leq n \\leq 100$）。房间从 1 到 $n$ 编号。接下来的 $n$ 行按顺序描述每个房间。每行由一个整数 $k$ 组成，表示该房间有 $k$ 个走廊（$0 \\leq k < 100$），然后是 $k$ 个不同的整数，按顺时针顺序列出每个走廊连接到的房间（从任意起点开始）。房间不与自身连接。", "outputFormat": "对于每个最大化的实际上相同的房间集合（忽略大小为 1 的集合），显示一行，其中包含集合中房间编号的递增顺序。按最小房间编号对集合进行排序。如果没有这样的集合，则显示 none。", "hint": "时间限制：2000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2014。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6897", "type": "P", "difficulty": 7, "samples": [["2\n0 0\n0 10\n2\n4 10\n4 0\n", "4.00000\n"], ["2\n0 0\n1 0\n3\n2 0\n3 0\n3 10\n", "5.00000\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["计算几何", "2014", "二分", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2014 WF] Messenger", "background": "", "description": "Misha needs to send packages to his friend Nadia. Both of them often travel across Russia, which is very large. So they decide to hire a messenger. Since the cost of the messenger service depends on the time it takes to deliver the package, they need your help to optimize a little bit.\n\nAssume Misha and Nadia move on a two-dimensional plane, each visiting a sequence of places and moving along straight line segments from place to place. Your task is to find the shortest possible delivery time given their two paths.\n\nMisha hands the package to the messenger at some point along his path. The messenger moves without delay along a straight line from the pick-up to intercept Nadia, who is traveling along her path. Misha, Nadia and the messenger move with a constant speed of $1$ distance unit per time unit. The delivery time is the time between Misha handing over the package and Nadia receiving it.", "inputFormat": "The input consists of a single test case. The test case contains two path descriptions, the first for Misha and the second for Nadia. Each path description starts with a line containing an integer $n$, the number of places visited ($2 \\leq n \\leq 50\\, 000$). This is followed by $n$ lines, each with two integers $x_ i$ and $y_ i$ specifying the coordinates of a place ($0 \\leq x_ i, y_ i \\leq 30\\, 000$). Coordinates of the places are listed in the order in which they are to be visited, and successive places do not have the same coordinates.\n\nMisha and Nadia start their journeys at the same time, visiting the places along their paths without stopping. The length of each path is at most $10^6$. The package must be picked up at the latest when Misha reaches his final place and it must be delivered at the latest when Nadia reaches her final place.", "outputFormat": "Display the minimal time needed for delivery. Give the answer with an absolute error of at most $10^{-3}$ or a relative error of at most $10^{-5}$. If the package cannot be delivered, display impossible instead.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Messenger", "background": "", "description": "Misha needs to send packages to his friend Nadia. Both of them often travel across Russia, which is very large. So they decide to hire a messenger. Since the cost of the messenger service depends on the time it takes to deliver the package, they need your help to optimize a little bit.\n\nAssume Misha and Nadia move on a two-dimensional plane, each visiting a sequence of places and moving along straight line segments from place to place. Your task is to find the shortest possible delivery time given their two paths.\n\nMisha hands the package to the messenger at some point along his path. The messenger moves without delay along a straight line from the pick-up to intercept Nadia, who is traveling along her path. Misha, Nadia and the messenger move with a constant speed of $1$ distance unit per time unit. The delivery time is the time between Misha handing over the package and Nadia receiving it.", "inputFormat": "The input consists of a single test case. The test case contains two path descriptions, the first for Misha and the second for Nadia. Each path description starts with a line containing an integer $n$, the number of places visited ($2 \\leq n \\leq 50\\, 000$). This is followed by $n$ lines, each with two integers $x_ i$ and $y_ i$ specifying the coordinates of a place ($0 \\leq x_ i, y_ i \\leq 30\\, 000$). Coordinates of the places are listed in the order in which they are to be visited, and successive places do not have the same coordinates.\n\nMisha and Nadia start their journeys at the same time, visiting the places along their paths without stopping. The length of each path is at most $10^6$. The package must be picked up at the latest when Misha reaches his final place and it must be delivered at the latest when Nadia reaches her final place.", "outputFormat": "Display the minimal time needed for delivery. Give the answer with an absolute error of at most $10^{-3}$ or a relative error of at most $10^{-5}$. If the package cannot be delivered, display impossible instead.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Messenger", "background": "", "description": "平面上有两个移动的点 A,B，其中 A 想要向 B 发送一条信息。两个点会同时出发，各自沿着一个折线移动到终点为止。A 会在移动的途中发送一条信息，这条信息可以视作一个点 C，它会沿一条射线匀速运动，当 C 与 B 重合时，B 即可收到该信息。\n\nA,B,C 的移动速度都是 1 单位长度每秒，A 最晚在它到达终点时发出信息，B 最晚需要在它到达终点时收到信息。令 $t_A$ 代表发送信息的时间，$t_B$ 代表接收信息的时间，那么你需要最小化 $t_B-t_A$ 的值。特别地，如果 B 无论如何都无法收到信息，你需要输出 `impossible`。", "inputFormat": "第一行包含一个整数 $n$，代表 A 经过折线的点数；  \n下面 $n$ 行，每行输入两个整数 $x_i,y_i$，依次描述 A 所走折线的点。  \n下面一行包含一个整数 $m$，B 过折线的点数；  \n下面 $m$ 行，每行输入两个整数 $u_i,v_i$，描述 B 所走折线。", "outputFormat": "一行，输出一个实数，代表答案。若无法满足，则输出`impossible`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6898", "type": "P", "difficulty": 7, "samples": [["5\n4 5 0 2\n1 3 7\n2 0\n4\n", "4\n"], ["7\n1 10 5 5 5 5\n5 10 5 5 5\n100 100 5 5\n10 5 5\n98 99\n3\n", "15\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2014", "2-SAT", "ICPC", "WF"], "title": "[ICPC 2014 WF] Metal Processing Plant", "background": "", "description": "Yulia works for a metal processing plant in Ekaterinburg. This plant processes ores mined in the Ural mountains, extracting precious metals such as chalcopyrite, platinum and gold from the ores. Every month the plant receives $n$ shipments of unprocessed ore. Yulia needs to partition these shipments into two groups based on their similarity. Then, each group is sent to one of two ore processing buildings of the plant.\n\nTo perform this partitioning, Yulia first calculates a numeric distance $d(i, j)$ for each pair of shipments $1 \\le i \\le n$ and $1 \\le j \\le n$, where the smaller the distance, the more similar the shipments $i$ and $j$ are. For a subset $S \\subseteq \\{ 1, \\ldots , n\\} $ of shipments, she then defines the disparity $D$ of $S$ as the maximum distance between a pair of shipments in the subset, that is,\n\n$$ D(S) = \\max _{i, j \\in S} d(i, j). $$\n\nYulia then partitions the shipments into two subsets $A$ and $B$ in such a way that the sum of their disparities $D(A) + D(B)$ is minimized. Your task is to help her find this partitioning.", "inputFormat": "The input consists of a single test case. The first line contains an integer $n$ ($1 \\le n \\le 200$) indicating the number of shipments. The following $n - 1$ lines contain the distances $d(i,j)$. The $i^{th}$ of these lines contains $n - i$ integers and the $j^{th}$ integer of that line gives the value of $d(i, i+j)$. The distances are symmetric, so $d(j, i) = d(i, j)$, and the distance of a shipment to itself is $0$. All distances are integers between $0$ and $10^9$ (inclusive).", "outputFormat": "Display the minimum possible sum of disparities for partitioning the shipments into two groups.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Metal Processing Plant", "background": "", "description": "Yulia works for a metal processing plant in Ekaterinburg. This plant processes ores mined in the Ural mountains, extracting precious metals such as chalcopyrite, platinum and gold from the ores. Every month the plant receives $n$ shipments of unprocessed ore. Yulia needs to partition these shipments into two groups based on their similarity. Then, each group is sent to one of two ore processing buildings of the plant.\n\nTo perform this partitioning, Yulia first calculates a numeric distance $d(i, j)$ for each pair of shipments $1 \\le i \\le n$ and $1 \\le j \\le n$, where the smaller the distance, the more similar the shipments $i$ and $j$ are. For a subset $S \\subseteq \\{ 1, \\ldots , n\\} $ of shipments, she then defines the disparity $D$ of $S$ as the maximum distance between a pair of shipments in the subset, that is,\n\n$$ D(S) = \\max _{i, j \\in S} d(i, j). $$\n\nYulia then partitions the shipments into two subsets $A$ and $B$ in such a way that the sum of their disparities $D(A) + D(B)$ is minimized. Your task is to help her find this partitioning.", "inputFormat": "The input consists of a single test case. The first line contains an integer $n$ ($1 \\le n \\le 200$) indicating the number of shipments. The following $n - 1$ lines contain the distances $d(i,j)$. The $i^{th}$ of these lines contains $n - i$ integers and the $j^{th}$ integer of that line gives the value of $d(i, i+j)$. The distances are symmetric, so $d(j, i) = d(i, j)$, and the distance of a shipment to itself is $0$. All distances are integers between $0$ and $10^9$ (inclusive).", "outputFormat": "Display the minimum possible sum of disparities for partitioning the shipments into two groups.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Metal Processing Plant", "background": "", "description": "Yulia 在叶卡捷琳堡的一家金属加工厂工作。该工厂处理从乌拉尔山脉开采的矿石，从中提取黄铜矿、铂金和黄金等贵金属。每个月，工厂会收到 $n$ 批未加工的矿石。Yulia 需要根据相似性将这些矿石分成两组。然后，每组被送往工厂的两个矿石加工建筑之一。\n\n为了进行这种划分，Yulia 首先为每对矿石 $1 \\le i \\le n$ 和 $1 \\le j \\le n$ 计算一个数值距离 $d(i, j)$，距离越小，矿石 $i$ 和 $j$ 越相似。对于矿石的一个子集 $S \\subseteq \\{ 1, \\ldots , n\\} $，她定义 $S$ 的差异度 $D$ 为子集中一对矿石之间的最大距离，即，\n\n$$ D(S) = \\max _{i, j \\in S} d(i, j). $$\n\n然后，Yulia 将矿石划分为两个子集 $A$ 和 $B$，使得它们的差异度之和 $D(A) + D(B)$ 最小。你的任务是帮助她找到这种划分。", "inputFormat": "输入由一个单一的测试用例组成。第一行包含一个整数 $n$ ($1 \\le n \\le 200$)，表示矿石的数量。接下来的 $n - 1$ 行包含距离 $d(i,j)$。这些行的第 $i$ 行包含 $n - i$ 个整数，该行的第 $j$ 个整数给出 $d(i, i+j)$ 的值。距离是对称的，因此 $d(j, i) = d(i, j)$，且矿石自身的距离为 $0$。所有距离都是 $0$ 到 $10^9$（含）之间的整数。", "outputFormat": "输出将矿石划分为两组的差异度之和的最小可能值。", "hint": "时间限制：2000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2014。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6899", "type": "P", "difficulty": 6, "samples": [["3 2\n20 20 20 40\nX.X\nT.T\n", "0.333333333\n0.666666667\n"], ["4 5\n12 33 28 27\n....\n.XX.\n....\nT..T\nXTTX\n", "0.435853889\n0.403753221\n0.081202502\n0.079190387\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2014", "Special Judge", "期望", "ICPC", "WF"], "title": "[ICPC 2014 WF] Pachinko", "background": "", "description": "You have been hired by Addictive Coin Machines to help design the next hit in their line of eye-catching, coin-guzzling, just-one-more-try Pachinko machines for casinos around the world.\n\nPlaying a Pachinko machine involves launching balls into a rectangular grid filled with pegs, obstacles, and targets. The ball bounces around the grid until it eventually hits one of the targets. The player earns a certain number of points depending on which target is hit.\n\nThe grid pattern for the next Pachinko machine has already been designed, but point values for the targets have not been assigned. These must be set so that like all casino machines, the machine is profitable but not too profitable. Thus it is important to figure out the probability of a ball hitting any particular target. That’s your job!\n\nFor simplicity, the grid is modeled as a tall rectangle filled with mostly-open spaces (each represented by ‘.’), impassable obstacles (each represented by ‘X’), and targets (each represented by ‘T’).\n\nA ball is launched randomly with uniform probability into one of the mostly-open spaces on the top row of the grid. From that point on, collisions with pegs cause the ball to randomly bounce up, down, left, or right, with various given probabilities. For simplicity, assume these probabilities are the same for every space in the grid. If the ball bounces into an obstacle or attempts to move off the grid, it won’t actually move from its current space. When the ball moves into a target it is removed from play.\n\nYou can safely assume that the average number of spaces visited by a ball before hitting a target will not exceed $10^{9}$. It would not make for a very enjoyable game if the ball just bounces forever!\n\nFor each target, calculate the probability that it is the one hit by a launched ball.", "inputFormat": "The input consists of a single test case. The first line contains integers $w$ and $h$, which are the width and height of the Pachinko grid ($1 \\leq w \\leq 20$ and $2 \\leq h \\leq 10\\, 000$). The next line contains four non-negative integers $u$, $d$, $l$, and $r$, which sum to 100 and are the percentage probabilities of the ball bouncing up, down, left, or right from any open space.\n\nEach of the next $h$ lines contains $w$ characters, each of which is ‘.’, ‘X’, or ‘T’. These lines describe the Pachinko grid. The first line, which describes the top row of the grid, contains at least one ‘.’ and no ‘T’s.", "outputFormat": "Display one line for each ‘T’ in the grid, in order from top to bottom, breaking ties left to right. For each target, display the probability that a launched ball will hit it. Give the answer with an absolute error of at most $10^{-6}$.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Pachinko", "background": "", "description": "You have been hired by Addictive Coin Machines to help design the next hit in their line of eye-catching, coin-guzzling, just-one-more-try Pachinko machines for casinos around the world.\n\nPlaying a Pachinko machine involves launching balls into a rectangular grid filled with pegs, obstacles, and targets. The ball bounces around the grid until it eventually hits one of the targets. The player earns a certain number of points depending on which target is hit.\n\nThe grid pattern for the next Pachinko machine has already been designed, but point values for the targets have not been assigned. These must be set so that like all casino machines, the machine is profitable but not too profitable. Thus it is important to figure out the probability of a ball hitting any particular target. That’s your job!\n\nFor simplicity, the grid is modeled as a tall rectangle filled with mostly-open spaces (each represented by ‘.’), impassable obstacles (each represented by ‘X’), and targets (each represented by ‘T’).\n\nA ball is launched randomly with uniform probability into one of the mostly-open spaces on the top row of the grid. From that point on, collisions with pegs cause the ball to randomly bounce up, down, left, or right, with various given probabilities. For simplicity, assume these probabilities are the same for every space in the grid. If the ball bounces into an obstacle or attempts to move off the grid, it won’t actually move from its current space. When the ball moves into a target it is removed from play.\n\nYou can safely assume that the average number of spaces visited by a ball before hitting a target will not exceed $10^{9}$. It would not make for a very enjoyable game if the ball just bounces forever!\n\nFor each target, calculate the probability that it is the one hit by a launched ball.", "inputFormat": "The input consists of a single test case. The first line contains integers $w$ and $h$, which are the width and height of the Pachinko grid ($1 \\leq w \\leq 20$ and $2 \\leq h \\leq 10\\, 000$). The next line contains four non-negative integers $u$, $d$, $l$, and $r$, which sum to 100 and are the percentage probabilities of the ball bouncing up, down, left, or right from any open space.\n\nEach of the next $h$ lines contains $w$ characters, each of which is ‘.’, ‘X’, or ‘T’. These lines describe the Pachinko grid. The first line, which describes the top row of the grid, contains at least one ‘.’ and no ‘T’s.", "outputFormat": "Display one line for each ‘T’ in the grid, in order from top to bottom, breaking ties left to right. For each target, display the probability that a launched ball will hit it. Give the answer with an absolute error of at most $10^{-6}$.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Pachinko", "background": "", "description": "有一个宽度为 $w$ 高度为 $h$ 的方格纸， $ w \\times h$ 的格子中，有一些是空的，有一些是洞，有一些是障碍物。从第一行的空的格子中随机选一个放置一个球，向上下左右移动的概率比为 $p_u : p_d : p_l : p_r$（满足 $p_u + p_d + p_l + p_r = 100$），不能移动到有障碍物的格子上。对于每个洞，输出落入该洞的概率。$w \\le 20, h \\le 10000$。保证第一行没有洞。", "inputFormat": "第一行两个整数表示 $w, h$ 。\n\n第二行四个整数表示 $p_u, p_d, p_l, p_r$ 。\n\n接下来有一个 $h$ 行 $w$ 的字符矩阵，其中 `.` 表示空，`X` 表示障碍物，`T` 表示洞。", "outputFormat": "若干行，每一行一个整数，按照矩阵从上到下，从左到右的顺序，输出每个洞的答案。绝对误差不超过 $10^{-6}$ 即为正确。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6900", "type": "P", "difficulty": 6, "samples": [["4 1\n0 0\n0 1\n1 0\n1 1\n", "2\n1 2\n"], ["5 20\n0 0\n0 2\n100 100\n100 110\n100 120\n", "3\n4 3 5\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2014", "Special Judge", "二分图", "随机化", "ICPC", "WF"], "title": "[ICPC 2014 WF] Sensor Network", "background": "", "description": "\nA wireless sensor network consists of autonomous sensors scattered in an environment where they monitor conditions such as temperature, sound, and pressure. \n\nSamantha is a researcher working on the Amazon Carbon-dioxide Measurement (ACM) project. In this project, a wireless sensor network in the Amazon rainforest gathers environmental information. The Amazon rainforest stores an amount of carbon equivalent to a decade of global fossil fuel emissions, and it plays a crucial role in the world’s oxygen-transfer processes. Because of the huge size of this forest, changes in the forest affect not only the local environment but also global climate by altering wind and ocean current patterns. The goal of the ACM project is to help scientists better understand earth’s complex ecosystems and the impact of human activities.\n\nSamantha has an important hypothesis and to test her hypothesis, she needs to find a subset of sensors in which each pair of sensors can communicate directly with each other. A sensor can communicate directly with any other sensor having distance at most $d$ from it. In order for her experiments to be as accurate as possible, Samantha wants to choose as many sensors as possible.\n\nAs one does not simply walk into the Amazon, Samantha cannot add new sensors or move those that are currently in place. So given the current locations of the sensors, she needs your help to find the largest subset satisfying her criteria. For simplicity, represent the location of each sensor as a point in a two-dimensional plane with the distance between two points being the usual Euclidean distance.", "inputFormat": "The input consists of a single test case. The first line contains two integers $n$ and $d$ ($1 \\le n \\le 100$ and $1 \\le d \\le 10\\, 000$), where $n$ is the number of sensors available and $d$ is the maximum distance between sensors that can communicate directly. Sensors are numbered $1$ to $n$. Each of the next $n$ lines contains two integers $x$ and $y$ ($-10\\, 000\\le x, y \\le 10\\, 000$) indicating the sensor coordinates, starting with the first sensor.", "outputFormat": "Display a maximum subset of sensors in which each pair of sensors can communicate directly. The first line of output should be the size of the subset. The second line of output should be the (one-based) indices of the sensors in the subset. If there are multiple such subsets, any one of them will be accepted.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Sensor Network", "background": "", "description": "\nA wireless sensor network consists of autonomous sensors scattered in an environment where they monitor conditions such as temperature, sound, and pressure. \n\nSamantha is a researcher working on the Amazon Carbon-dioxide Measurement (ACM) project. In this project, a wireless sensor network in the Amazon rainforest gathers environmental information. The Amazon rainforest stores an amount of carbon equivalent to a decade of global fossil fuel emissions, and it plays a crucial role in the world’s oxygen-transfer processes. Because of the huge size of this forest, changes in the forest affect not only the local environment but also global climate by altering wind and ocean current patterns. The goal of the ACM project is to help scientists better understand earth’s complex ecosystems and the impact of human activities.\n\nSamantha has an important hypothesis and to test her hypothesis, she needs to find a subset of sensors in which each pair of sensors can communicate directly with each other. A sensor can communicate directly with any other sensor having distance at most $d$ from it. In order for her experiments to be as accurate as possible, Samantha wants to choose as many sensors as possible.\n\nAs one does not simply walk into the Amazon, Samantha cannot add new sensors or move those that are currently in place. So given the current locations of the sensors, she needs your help to find the largest subset satisfying her criteria. For simplicity, represent the location of each sensor as a point in a two-dimensional plane with the distance between two points being the usual Euclidean distance.", "inputFormat": "The input consists of a single test case. The first line contains two integers $n$ and $d$ ($1 \\le n \\le 100$ and $1 \\le d \\le 10\\, 000$), where $n$ is the number of sensors available and $d$ is the maximum distance between sensors that can communicate directly. Sensors are numbered $1$ to $n$. Each of the next $n$ lines contains two integers $x$ and $y$ ($-10\\, 000\\le x, y \\le 10\\, 000$) indicating the sensor coordinates, starting with the first sensor.", "outputFormat": "Display a maximum subset of sensors in which each pair of sensors can communicate directly. The first line of output should be the size of the subset. The second line of output should be the (one-based) indices of the sensors in the subset. If there are multiple such subsets, any one of them will be accepted.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Sensor Network", "background": "", "description": "一个无线传感器网络由分散在环境中的自主传感器组成，它们监测温度、声音和压力等条件。\n\nSamantha 是一名研究人员，正在从事亚马逊二氧化碳测量（ACM）项目。在该项目中，亚马逊雨林中的无线传感器网络收集环境信息。亚马逊雨林储存的碳量相当于全球化石燃料排放量的十年，并在全球氧气传输过程中发挥着关键作用。由于这片森林的巨大规模，森林的变化不仅影响当地环境，还通过改变风和洋流模式影响全球气候。ACM 项目的目标是帮助科学家更好地理解地球复杂的生态系统以及人类活动的影响。\n\nSamantha 有一个重要的假设，为了验证她的假设，她需要找到一个传感器子集，其中每对传感器可以直接相互通信。一个传感器可以与距离不超过 $d$ 的任何其他传感器直接通信。为了使她的实验尽可能准确，Samantha 希望选择尽可能多的传感器。\n\n由于不能简单地进入亚马逊，Samantha 不能添加新的传感器或移动当前的位置。因此，给定传感器的当前位置，她需要你的帮助来找到满足她标准的最大子集。为简单起见，将每个传感器的位置表示为二维平面上的一个点，两个点之间的距离为通常的欧几里得距离。", "inputFormat": "输入由一个测试用例组成。第一行包含两个整数 $n$ 和 $d$（$1 \\le n \\le 100$ 且 $1 \\le d \\le 10\\, 000$），其中 $n$ 是可用传感器的数量，$d$ 是可以直接通信的传感器之间的最大距离。传感器编号为 $1$ 到 $n$。接下来的 $n$ 行中的每一行包含两个整数 $x$ 和 $y$（$-10\\, 000\\le x, y \\le 10\\, 000$），表示传感器的坐标，从第一个传感器开始。", "outputFormat": "输出一个最大传感器子集，其中每对传感器可以直接通信。输出的第一行应为子集的大小。第二行应为子集中传感器的（从 1 开始的）索引。如果有多个这样的子集，任何一个都将被接受。", "hint": "时间限制：2000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2014。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6901", "type": "P", "difficulty": 7, "samples": [["4 100 400\n-100 100\n50 200\n-100 300\n150 300\n", "1 2 4\n"], ["1 100 100\n1000 10\n", "Cannot visit any targets\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2014", "ICPC", "WF"], "title": "[ICPC 2014 WF] skiing", "background": "", "description": "As you know, the ACM ICPC is not the only major sporting event taking place in Russia this year. Several months ago, the 2014 Winter Olympics were held in Sochi, which is about 3 000 km from Ekaterinburg.\n\nIn an increasing number of sports, it is not only the ability of the athletes that determines who wins a competition but also their equipment. For example in downhill skiing, having the latest ski technology enables athletes to increase their speeds and improve their turning ability.\n\nYou have been hired to determine the effect of the latest ski technology on the ability of skiers to navigate a downhill course. The course contains several target locations, and the skier wants to pass over as many of them as possible. Naturally, the better the ski technology, the easier it will be to do this.\n\nFor simplicity, use a two-dimensional coordinate system where the skier starts at position (0,0) and where “downhill” corresponds to the direction of the positive $y$-axis.\n\nAssume the $y$-component of the athlete’s velocity is a constant $v_ y$. The athlete can change speed laterally (in the $x$-direction), but the skiing equipment limits this to a maximal lateral acceleration $a_{max}$. The skier starts with a lateral velocity of 0.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/us59dhj8.png)\n\n   Figure 1: Downhill ski path passing over three targets \n\nIn Figure 1 (which corresponds to the first sample input), the optimal path passes over three out of four possible targets. If $a_{max}$ were smaller, then the skier might be able to pass over only two or fewer of the targets.", "inputFormat": "The input contains a single test case. The first line contains three integers $n$, $v_ y$, and $a_{max}$ ($0 \\leq n \\leq 250$, $0 < v_ y \\leq 10^5$ and $0 \\leq a_{max} \\leq 10^7$), where $n$ is the number of targets, $v_ y$ is the $y$-component of the skier’s velocity, and $a_{max}$ is the maximum lateral acceleration. Here $v_ y$ is given in meters per hour and $a_{max}$ in meters per hour squared.\n\nFollowing this are $n$ lines, each containing two integers $x_ i$ and $y_ i$ ($-10^5 \\leq x_ i, y_ i \\leq 10^5$). These give the coordinates of each target to be visited on the course. All coordinates are given in meters. Targets are numbered 1, 2, ..., $n$ in the order they are given.", "outputFormat": "Display the maximal-length sequence of targets that the athlete could pass over on the course in a single run. Display the targets in the order they are visited. If there are multiple maximal-length sequences, display only the lexicographically first one. (So the sequence 2 15 would come before the sequence 10 15.) If the athlete cannot pass over any targets, print Cannot visit any targets instead.\n\nTo ensure floating-point stability, you may assume the answer will not change if $a_{max}$ is perturbed by up to 0.1.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] skiing", "background": "", "description": "As you know, the ACM ICPC is not the only major sporting event taking place in Russia this year. Several months ago, the 2014 Winter Olympics were held in Sochi, which is about 3 000 km from Ekaterinburg.\n\nIn an increasing number of sports, it is not only the ability of the athletes that determines who wins a competition but also their equipment. For example in downhill skiing, having the latest ski technology enables athletes to increase their speeds and improve their turning ability.\n\nYou have been hired to determine the effect of the latest ski technology on the ability of skiers to navigate a downhill course. The course contains several target locations, and the skier wants to pass over as many of them as possible. Naturally, the better the ski technology, the easier it will be to do this.\n\nFor simplicity, use a two-dimensional coordinate system where the skier starts at position (0,0) and where “downhill” corresponds to the direction of the positive $y$-axis.\n\nAssume the $y$-component of the athlete’s velocity is a constant $v_ y$. The athlete can change speed laterally (in the $x$-direction), but the skiing equipment limits this to a maximal lateral acceleration $a_{max}$. The skier starts with a lateral velocity of 0.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/us59dhj8.png)\n\n   Figure 1: Downhill ski path passing over three targets \n\nIn Figure 1 (which corresponds to the first sample input), the optimal path passes over three out of four possible targets. If $a_{max}$ were smaller, then the skier might be able to pass over only two or fewer of the targets.", "inputFormat": "The input contains a single test case. The first line contains three integers $n$, $v_ y$, and $a_{max}$ ($0 \\leq n \\leq 250$, $0 < v_ y \\leq 10^5$ and $0 \\leq a_{max} \\leq 10^7$), where $n$ is the number of targets, $v_ y$ is the $y$-component of the skier’s velocity, and $a_{max}$ is the maximum lateral acceleration. Here $v_ y$ is given in meters per hour and $a_{max}$ in meters per hour squared.\n\nFollowing this are $n$ lines, each containing two integers $x_ i$ and $y_ i$ ($-10^5 \\leq x_ i, y_ i \\leq 10^5$). These give the coordinates of each target to be visited on the course. All coordinates are given in meters. Targets are numbered 1, 2, ..., $n$ in the order they are given.", "outputFormat": "Display the maximal-length sequence of targets that the athlete could pass over on the course in a single run. Display the targets in the order they are visited. If there are multiple maximal-length sequences, display only the lexicographically first one. (So the sequence 2 15 would come before the sequence 10 15.) If the athlete cannot pass over any targets, print Cannot visit any targets instead.\n\nTo ensure floating-point stability, you may assume the answer will not change if $a_{max}$ is perturbed by up to 0.1.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] skiing", "background": null, "description": "滑雪运动员进行的一次训练可以看作平面上一条从 $(0, 0)$ 出发的曲线，这条曲线在 $y$ 轴正方向上的**速度**是 $v_y$，由于装备限制，在 $x$ 轴上的**加速度**不得超过 $a_{max}$。滑雪运动员在 $x$ 轴上的速度从 $0$ 开始。\n\n在这一次训练中，滑雪运动员需要经过所有 $n$ 个目标点 $(x_i, y_i)$ 中尽可能多的目标点，现在他希望你通过控制他每一时刻的加速度，实现这个目标。", "inputFormat": "第一行三个整数 $n, v_y, a_{max}$ 分别表示目标点数，$y$ 轴速度（米每秒）以及 $x$ 轴加速度上限（米每二次方秒）。\n\n接下来 $n$ 行每行两个整数 $x, y$ 表示目标点的横坐标（米）以及纵坐标（米）。", "outputFormat": "按照目标点被经过的顺序输出最长的目标点序列。若有多个可能的答案，输出字典序最小的。若运动员不能经过任意一个目标点，输出 `Cannot visit any targets`。\n\n为了避免浮点误差，你可以假设对 $a_{max}$ 进行不超过 $0.1$ 的扰动的情况下，答案不变。", "hint": "$0\\le n\\le 250, 0\\le v_y\\le 10^5\n, 0\\le a_{max}\\le 10^7\n, −10^5\\le x, y\\le 10^5$\n, 目标点编号从 1 开始。\n\n~~一句话の题意：输入一些数，输出一些数（或字符串），使输出符合要求。~~", "locale": "zh-CN"}}}
{"pid": "P6902", "type": "P", "difficulty": 5, "samples": [["100 7\n1 50\n50 70\n70 90\n90 40\n20 60\n60 80\n80 20\n", "3\n"], ["8 2\n8 3\n5 7\n", "impossible\n"], ["8 2\n8 4\n5 7\n", "2\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2014", "倍增", "ICPC", "WF"], "title": "[ICPC 2014 WF] Surveillance", "background": "", "description": "The International Corporation for Protection and Control (ICPC) develops efficient technology for, well, protection and control. Naturally, they are keen to have their own headquarters protected and controlled. Viewed from above, the headquarters building has the shape of a convex polygon. There are several suitable places around it where cameras can be installed to monitor the building. Each camera covers a certain range of the polygon sides (building walls), depending on its position. ICPC wants to minimize the number of cameras needed to cover the whole building.", "inputFormat": "The input consists of a single test case. Its first line contains two integers $n$ and $k$ ($3 \\le n \\le 10^6$ and $1 \\le k \\le 10^6$), where $n$ is the number of walls and $k$ is the number of possible places for installing cameras. Each of the remaining $k$ lines contains two integers $a_ i$ and $b_ i$ ($1 \\le a_ i, b_ i \\le n$). These integers specify which walls a camera at the $i^{th}$ place would cover. If $a_ i \\le b_ i$ then the camera covers each wall $j$ such that $a_ i \\le j \\le b_ i$. If $a_ i > b_ i$ then the camera covers each wall $j$ such that $a_ i \\le j \\le n$ or $1 \\le j \\le b_ i$.", "outputFormat": "Display the minimal number of cameras that suffice to cover each wall of the building. The ranges covered by two cameras may overlap. If the building cannot be covered, display impossible instead.", "hint": "Time limit: 4000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Surveillance", "background": "", "description": "The International Corporation for Protection and Control (ICPC) develops efficient technology for, well, protection and control. Naturally, they are keen to have their own headquarters protected and controlled. Viewed from above, the headquarters building has the shape of a convex polygon. There are several suitable places around it where cameras can be installed to monitor the building. Each camera covers a certain range of the polygon sides (building walls), depending on its position. ICPC wants to minimize the number of cameras needed to cover the whole building.", "inputFormat": "The input consists of a single test case. Its first line contains two integers $n$ and $k$ ($3 \\le n \\le 10^6$ and $1 \\le k \\le 10^6$), where $n$ is the number of walls and $k$ is the number of possible places for installing cameras. Each of the remaining $k$ lines contains two integers $a_ i$ and $b_ i$ ($1 \\le a_ i, b_ i \\le n$). These integers specify which walls a camera at the $i^{th}$ place would cover. If $a_ i \\le b_ i$ then the camera covers each wall $j$ such that $a_ i \\le j \\le b_ i$. If $a_ i > b_ i$ then the camera covers each wall $j$ such that $a_ i \\le j \\le n$ or $1 \\le j \\le b_ i$.", "outputFormat": "Display the minimal number of cameras that suffice to cover each wall of the building. The ranges covered by two cameras may overlap. If the building cannot be covered, display impossible instead.", "hint": "Time limit: 4000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Surveillance", "background": null, "description": "给定一个长度为 $n$ 的环，有 $k$ 个区域被覆盖，求最小的满足环被完全覆盖的区域数量。", "inputFormat": "第一行两个整数 $n,k$。\n接下来 $k$ 行，每行两个整数表示一个区域。", "outputFormat": "若环不可能被完全覆盖，输出 `impossible`；否则输出一个整数，表示最少的区域数量。", "hint": "$3\\leq n\\leq 10^6,1\\leq k\\leq 10^6.$", "locale": "zh-CN"}}}
{"pid": "P6903", "type": "P", "difficulty": 7, "samples": [["8 3 3 19 3\n0 1 22 1\n0 5 22 5\n1 0 1 6\n5 0 5 6\n9 0 9 6\n13 0 13 6\n17 0 17 6\n21 0 21 6\n", "2\n"], ["1 0 5 10 5\n0 0 10 10\n", "0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["计算几何", "2014", "平面图", "ICPC", "WF"], "title": "[ICPC 2014 WF] Wire Crossing", "background": "", "description": "Moore’s Law states that the number of transistors on a chip will double every two years. Amazingly, this law has held true for over half a century. Whenever current technology no longer allowed more growth, researchers have come up with new manufacturing technologies to pack circuits even denser. In the near future, this might mean that chips are constructed in three dimensions instead two. But for this problem, two dimensions will be enough.\n\nA problem common to all two-dimensional hardware design (for example chips, graphics cards, motherboards, and so on) is wire placement. Whenever wires are routed on the hardware, it is problematic if they have to cross each other. When a crossing occurs special gadgets have to be used to allow two electrical wires to pass over each other, and this makes manufacturing more expensive.\n\nOur problem is the following: you are given a hardware design with several wires already in place (all of them straight line segments). You are also given the start and end points for a new wire connection to be added. You will have to determine the minimum number of existing wires that have to be crossed in order to connect the start and end points. This connection need not be a straight line. The only requirement is that it cannot cross at a point where two or more wires already meet or intersect.\n\n  ![](https://vj.z180.cn/df2653f5a1b23d354dbe2e33d6438ea6?v=1602904232) \n\n   Figure 1: First sample input \n\nFigure 1 shows the first sample input. Eight existing wires form five squares. The start and end points of the new connection are in the leftmost and rightmost squares, respectively. The black dashed line shows that a direct connection would cross four wires, whereas the optimal solution crosses only two wires (the curved blue line).", "inputFormat": "The input consists of a single test case. The first line contains five integers $m, x_0, y_0, x_1, y_1$, which are the number of pre-existing wires ($m \\le 100$) and the start and end points that need to be connected. This is followed by $m$ lines, each containing four integers $x_ a, y_ a, x_ b, y_ b$ describing an existing wire of non-zero length from $(x_ a, y_ a)$ to $(x_ b,y_ b)$. The absolute value of each input coordinate is less than $10^5$. Each pair of wires has at most one point in common, that is, wires do not overlap. The start and end points for the new wire do not lie on a pre-existing wire.", "outputFormat": "Display the minimum number of wires that have to be crossed to connect the start and end points.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Wire Crossing", "background": "", "description": "Moore’s Law states that the number of transistors on a chip will double every two years. Amazingly, this law has held true for over half a century. Whenever current technology no longer allowed more growth, researchers have come up with new manufacturing technologies to pack circuits even denser. In the near future, this might mean that chips are constructed in three dimensions instead two. But for this problem, two dimensions will be enough.\n\nA problem common to all two-dimensional hardware design (for example chips, graphics cards, motherboards, and so on) is wire placement. Whenever wires are routed on the hardware, it is problematic if they have to cross each other. When a crossing occurs special gadgets have to be used to allow two electrical wires to pass over each other, and this makes manufacturing more expensive.\n\nOur problem is the following: you are given a hardware design with several wires already in place (all of them straight line segments). You are also given the start and end points for a new wire connection to be added. You will have to determine the minimum number of existing wires that have to be crossed in order to connect the start and end points. This connection need not be a straight line. The only requirement is that it cannot cross at a point where two or more wires already meet or intersect.\n\n  ![](https://vj.z180.cn/df2653f5a1b23d354dbe2e33d6438ea6?v=1602904232) \n\n   Figure 1: First sample input \n\nFigure 1 shows the first sample input. Eight existing wires form five squares. The start and end points of the new connection are in the leftmost and rightmost squares, respectively. The black dashed line shows that a direct connection would cross four wires, whereas the optimal solution crosses only two wires (the curved blue line).", "inputFormat": "The input consists of a single test case. The first line contains five integers $m, x_0, y_0, x_1, y_1$, which are the number of pre-existing wires ($m \\le 100$) and the start and end points that need to be connected. This is followed by $m$ lines, each containing four integers $x_ a, y_ a, x_ b, y_ b$ describing an existing wire of non-zero length from $(x_ a, y_ a)$ to $(x_ b,y_ b)$. The absolute value of each input coordinate is less than $10^5$. Each pair of wires has at most one point in common, that is, wires do not overlap. The start and end points for the new wire do not lie on a pre-existing wire.", "outputFormat": "Display the minimum number of wires that have to be crossed to connect the start and end points.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Wire Crossing", "background": "", "description": "摩尔定律指出，芯片上的晶体管数量每两年会翻一番。令人惊讶的是，这一定律在过去半个世纪中一直成立。每当当前技术无法再支持更多增长时，研究人员就会提出新的制造技术，以便将电路打包得更密集。在不久的将来，这可能意味着芯片将以三维而非二维构建。但对于这个问题，二维已经足够了。\n\n所有二维硬件设计（例如芯片、显卡、主板等）中常见的问题是布线。当导线在硬件上布线时，如果它们必须相互交叉，就会出现问题。当发生交叉时，必须使用特殊装置以允许两根电线相互通过，这使得制造成本更高。\n\n我们的问题如下：给定一个已经布置了几根导线的硬件设计（所有导线都是直线段）。还给定一个新的导线连接的起点和终点。你需要确定为了连接起点和终点，必须交叉的现有导线的最小数量。这个连接不需要是直线。唯一的要求是它不能在两个或多个导线已经相交或相遇的点上交叉。\n\n   ![](https://vj.z180.cn/df2653f5a1b23d354dbe2e33d6438ea6?v=1602904232)\n\n   图 1：第一个样例输入\n\n图 1 显示了第一个样例输入。八根现有导线形成了五个正方形。新连接的起点和终点分别位于最左边和最右边的正方形中。黑色虚线表明直接连接将交叉四根导线，而最优解仅交叉两根导线（蓝色曲线）。", "inputFormat": "输入由一个测试用例组成。第一行包含五个整数 $m, x_0, y_0, x_1, y_1$，分别表示已有导线的数量（$m \\le 100$）以及需要连接的起点和终点。接下来是 $m$ 行，每行包含四个整数 $x_ a, y_ a, x_ b, y_ b$，描述了一根从 $(x_ a, y_ a)$ 到 $(x_ b, y_ b)$ 的非零长度的现有导线。每个输入坐标的绝对值小于 $10^5$。每对导线最多有一个公共点，即导线不重叠。新导线的起点和终点不位于已有导线上。", "outputFormat": "输出连接起点和终点所需交叉的最小导线数量。", "hint": "时间限制：2000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2014。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6904", "type": "P", "difficulty": 2, "samples": [["42 1 23 4 8 10\n", "104.855110477\n"], ["100 7 615 998 801 3\n", "0.00\n"], ["100 432 406 867 60 1000\n", "399.303813\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2015", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2015 WF] Amalgamated Artichokes", "background": "", "description": " ![](https://vj.z180.cn/751a8fdd9863b69e86176e87e1fd5b20?v=1600415919)  \n\nFatima Cynara is an analyst at Amalgamated Artichokes (AA). As with any company, AA has had some very good times as well as some bad ones. Fatima does trending analysis of the stock prices for AA, and she wants to determine the largest decline in stock prices over various time spans. For example, if over a span of time the stock prices were $19$, $12$, $13$, $11$, $20$ and $14$, then the largest decline would be $8$ between the first and fourth price. If the last price had been $10$ instead of $14$, then the largest decline would have been $10$ between the last two prices. \n\nFatima has done some previous analyses and has found that the stock price over any period of time can be modelled reasonably accurately with the following equation:\n\n$$ \\operatorname {price}(k) = p \\cdot (\\sin (a \\cdot k+b) + \\cos (c \\cdot k+d) + 2) $$\n\nwhere $p$, $a$, $b$, $c$ and $d$ are constants. Fatima would like you to write a program to determine the largest price decline over a given sequence of prices. Figure 1 illustrates the price function for Sample Input 1. You have to consider the prices only for integer values of $k$.\n\n  ![](https://vj.z180.cn/800605356b7337600d5163d2e5d7aab4?v=1600415919) \n\n   Figure 1: Sample Input 1. The largest decline occurs from the fourth to the seventh price. ", "inputFormat": "The input consists of a single line containing $6$ integers $p$ ($1 \\le p \\le 1\\, 000$), $a$, $b$, $c$, $d$ ($0 \\le a, b, c, d \\le 1\\, 000$) and $n$ ($1 \\le n \\le 10^6$). The first $5$ integers are described above. The sequence of stock prices to consider is $\\operatorname {price(1)}, \\operatorname {price(2)}, \\ldots , \\operatorname {price}(n)$.", "outputFormat": "Display the maximum decline in the stock prices. If there is no decline, display the number $0$. Your output should have an absolute or relative error of at most $10^{-6}$.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Amalgamated Artichokes", "background": "", "description": " ![](https://vj.z180.cn/751a8fdd9863b69e86176e87e1fd5b20?v=1600415919)  \n\nFatima Cynara is an analyst at Amalgamated Artichokes (AA). As with any company, AA has had some very good times as well as some bad ones. Fatima does trending analysis of the stock prices for AA, and she wants to determine the largest decline in stock prices over various time spans. For example, if over a span of time the stock prices were $19$, $12$, $13$, $11$, $20$ and $14$, then the largest decline would be $8$ between the first and fourth price. If the last price had been $10$ instead of $14$, then the largest decline would have been $10$ between the last two prices. \n\nFatima has done some previous analyses and has found that the stock price over any period of time can be modelled reasonably accurately with the following equation:\n\n$$ \\operatorname {price}(k) = p \\cdot (\\sin (a \\cdot k+b) + \\cos (c \\cdot k+d) + 2) $$\n\nwhere $p$, $a$, $b$, $c$ and $d$ are constants. Fatima would like you to write a program to determine the largest price decline over a given sequence of prices. Figure 1 illustrates the price function for Sample Input 1. You have to consider the prices only for integer values of $k$.\n\n  ![](https://vj.z180.cn/800605356b7337600d5163d2e5d7aab4?v=1600415919) \n\n   Figure 1: Sample Input 1. The largest decline occurs from the fourth to the seventh price. ", "inputFormat": "The input consists of a single line containing $6$ integers $p$ ($1 \\le p \\le 1\\, 000$), $a$, $b$, $c$, $d$ ($0 \\le a, b, c, d \\le 1\\, 000$) and $n$ ($1 \\le n \\le 10^6$). The first $5$ integers are described above. The sequence of stock prices to consider is $\\operatorname {price(1)}, \\operatorname {price(2)}, \\ldots , \\operatorname {price}(n)$.", "outputFormat": "Display the maximum decline in the stock prices. If there is no decline, display the number $0$. Your output should have an absolute or relative error of at most $10^{-6}$.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Amalgamated Artichokes", "background": "", "description": "**题目背景**\n\n法蒂玛是针对联合洋蓟果业公司 (Amalgamated Artichokes , AA) 的股票分析员。和其他的公司一样，联合洋蓟果业公司有的时候行情较好，有的时候不太行。法蒂玛对联合洋蓟果业公司的股票价格做了跟踪分析，她想确定不同时间段内股价最大跌幅是多少。比如如果一段时间内股价分别为19元，12元，13元，11元，20元，14元，则最大的跌幅为第一天和第四天之间的8。如果最后一天的价格不是14元而是10元，则最大跌幅为最后两天股价之间的10元。\n\n法蒂玛做了些前期的分析，发现一段时间的股价可以建模精确合理地表示为以下方程式：\n$$\nprice⁡(k)=p⋅(sin⁡(a⋅k+b)+cos⁡(c⋅k+d)+2)\n$$\n其中$p,a,b,c,d$均为常数。法蒂玛想要你写个程序确定给定价格序列上的最大股价跌幅。\n\n图1说明了第一组样例的价格函数，你只能考虑时间为整数$k$时的价格。\n\n对于第一组样例，最大股价跌幅出现在第四天和第七天之间。\n\n**一句话题意**\n\n对于给定序列，求差值最大的逆序对", "inputFormat": "输入共一行，包含六个整数$p (1 \\le p \\le 1000), a, b, c, d ( 0 \\le a, b, c, d \\le 1\\, 000)$ 和$ n (1 \\le n \\le 10^6).$\n\n前五个整数意义如题目所述，给定序列长度为n。", "outputFormat": "输出股价最大跌幅，如果没有股价下跌则输出0。\n\n输出最多和标准答案有$10^{-6}$的相对或绝对误差。", "hint": "时间限制: 5000 ms \n\n空间限制: 1048576 kB.\n\nInternational Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "zh-CN"}}}
{"pid": "P6905", "type": "P", "difficulty": 7, "samples": [["6 3 2 2 4 3 6 6 6 7 4 6 2 2 2\n4 18 5 22 9 26 5 22 1 -2 1\n", "4.193518\n"], ["4 0 0 0 2 2 2 2 0 -1 1\n4 10 0 10 2 12 2 12 0 1 1\n", "never\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2015 WF] Asteroids", "background": "", "description": "The year is 2115. The asteroid communication relay system was set up a decade ago by the Asteroid Communication Ministry. It is running fine except for one small problem – there are too many asteroids! The smaller ones not only keep interfering with the signals from the relay stations but they are also a danger to all the maintenance aircrafts that fly between the stations. These small asteroids must be destroyed! The Interplanetary Coalition to Prevent Catastrophes (ICPC) has been charged with removing these dangerous asteroids and has hired an elite team of hot-shot pilots for the job. Han Duo is the captain of this team of asteroid destroyers. Armed with his missiles, Han flies through the asteroid belt blowing up any asteroid that the ICPC deems a nuisance.\n\nThe ICPC is having some unfortunate budgetary problems. One result of this is that Han and his team do not have as many missiles as they would like, so they cannot blow up all the troublesome asteroids. But the asteroids are small and the missiles are powerful. So if two asteroids are near each other and line up properly, it is possible to take out both with a single missile.\n\nHan’s screen displays asteroids as non-rotating two-dimensional simple convex polygons, each of which moves at a fixed velocity. He has decided that the best time to hit two asteroids is when the overlap of the two polygons is at a maximum. For example, Figure 1, which illustrates Sample Input 1, shows two asteroids and snapshots of their subsequent positions at 1-second intervals. The two asteroids start touching after $3$ seconds and the maximum overlap area occurs between $4$ and $5$ seconds.\n\n  ![](https://vj.z180.cn/c0ee84911e97a539823bc119cb23e0d7?v=1603764626) \n\n   Figure 1: Sample Input 1. Two asteroids with crossing paths. \n\nCalculating when the maximum overlap occurs for two asteroids requires a bit of programming, but unfortunately Han slept through most of his coding classes at the flight academy. This is where you come in.", "inputFormat": "The input consists of two asteroid specifications. Each has the form $n\\; x_{1}\\; y_{1}\\; x_{2}\\; y_{2}\\; \\ldots \\; x_{n}\\; y_{n}\\; v_{x}\\; v_{y}$ where $n$ $(3 \\le n \\le 10)$ is the number of vertices, each $x_{i}, y_{i}$ ($-10\\, 000 \\le x_{i}, y_{i} \\le 10\\, 000$) are the coordinates of a vertex of the asteroid on Han’s screen given in clockwise order, and $v_{x}, v_{y}$ ($-100 \\le v_{x}, v_{y} \\le 100$) are the $x$ and $y$ velocities (in units/second) of the asteroid. The $x_{i}$, $y_{i}$ values specify the location of each asteroid at time $t=0$, and the polygons do not intersect or touch at this time. The maximum length of any side of an asteroid is $500$. All numbers in the input are integers.", "outputFormat": "Display the time in seconds when the two polygons have maximum intersection, using the earliest such time if there is more than one. If the two polygons never overlap but touch each other, treat it as an intersection where the common area is zero and display the earliest such time. If the polygons never overlap or touch, display never instead. You should consider positive times only. Your output should have an absolute or relative error of at most $10^{-3}$.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015\n \nspj provider:@[shenyouran](/user/137367).", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Asteroids", "background": "", "description": "The year is 2115. The asteroid communication relay system was set up a decade ago by the Asteroid Communication Ministry. It is running fine except for one small problem – there are too many asteroids! The smaller ones not only keep interfering with the signals from the relay stations but they are also a danger to all the maintenance aircrafts that fly between the stations. These small asteroids must be destroyed! The Interplanetary Coalition to Prevent Catastrophes (ICPC) has been charged with removing these dangerous asteroids and has hired an elite team of hot-shot pilots for the job. Han Duo is the captain of this team of asteroid destroyers. Armed with his missiles, Han flies through the asteroid belt blowing up any asteroid that the ICPC deems a nuisance.\n\nThe ICPC is having some unfortunate budgetary problems. One result of this is that Han and his team do not have as many missiles as they would like, so they cannot blow up all the troublesome asteroids. But the asteroids are small and the missiles are powerful. So if two asteroids are near each other and line up properly, it is possible to take out both with a single missile.\n\nHan’s screen displays asteroids as non-rotating two-dimensional simple convex polygons, each of which moves at a fixed velocity. He has decided that the best time to hit two asteroids is when the overlap of the two polygons is at a maximum. For example, Figure 1, which illustrates Sample Input 1, shows two asteroids and snapshots of their subsequent positions at 1-second intervals. The two asteroids start touching after $3$ seconds and the maximum overlap area occurs between $4$ and $5$ seconds.\n\n  ![](https://vj.z180.cn/c0ee84911e97a539823bc119cb23e0d7?v=1603764626) \n\n   Figure 1: Sample Input 1. Two asteroids with crossing paths. \n\nCalculating when the maximum overlap occurs for two asteroids requires a bit of programming, but unfortunately Han slept through most of his coding classes at the flight academy. This is where you come in.", "inputFormat": "The input consists of two asteroid specifications. Each has the form $n\\; x_{1}\\; y_{1}\\; x_{2}\\; y_{2}\\; \\ldots \\; x_{n}\\; y_{n}\\; v_{x}\\; v_{y}$ where $n$ $(3 \\le n \\le 10)$ is the number of vertices, each $x_{i}, y_{i}$ ($-10\\, 000 \\le x_{i}, y_{i} \\le 10\\, 000$) are the coordinates of a vertex of the asteroid on Han’s screen given in clockwise order, and $v_{x}, v_{y}$ ($-100 \\le v_{x}, v_{y} \\le 100$) are the $x$ and $y$ velocities (in units/second) of the asteroid. The $x_{i}$, $y_{i}$ values specify the location of each asteroid at time $t=0$, and the polygons do not intersect or touch at this time. The maximum length of any side of an asteroid is $500$. All numbers in the input are integers.", "outputFormat": "Display the time in seconds when the two polygons have maximum intersection, using the earliest such time if there is more than one. If the two polygons never overlap but touch each other, treat it as an intersection where the common area is zero and display the earliest such time. If the polygons never overlap or touch, display never instead. You should consider positive times only. Your output should have an absolute or relative error of at most $10^{-3}$.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015\n \nspj provider:@[shenyouran](/user/137367).", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Asteroids", "background": "今年是 $2115$ 年。小行星通信中继系统是十年前由小行星通信部建立的。有一个小问题——小行星太多，它们很危险！比较小的小行星不仅不断干扰中继站的信号，而且对在中继站之间飞行的所有维修飞机也是一种危险。这些小行星必须被摧毁！防止危险的星际联盟（ICPC）已被下达移除这些危险的小行星的指令，并请了一支精英团队来完成这项工作。Han Duo 是这个小行星驱逐舰小组的队长。Han Duo 带着他的导弹飞过小行星带，炸毁了 ICPC 认为的令人讨厌的任何小行星。", "description": "ICPC 没那么多钱。后果是 Han Duo 和他的团队没有他们想要的那么多导弹，因此他们无法炸毁所有麻烦的小行星。但是小行星很小，导弹也很强大。因此，如果两颗小行星彼此靠近并正确排列，就有可能用一枚导弹将两者都摧毁。\n\nHan Duo 的屏幕将小行星显示为非旋转的二维简单凸多边形，每个多边形都以固定速度移动。他认为撞击两颗小行星的最佳时间是两个多边形的重叠达到最大值时。例如，图 $1$ 演示了样例输入 $1$，显示了两颗小行星及其后续的位置，间隔 $1$ 秒。两颗小行星在 $33$ 秒后开始接触，最大重叠区域出现在 $44$ 到 $55$ 秒之间。\n\n图 $1$：样例输入 $1$。两颗有交叉路径的小行星。\n\n计算两颗小行星的最大重叠时间需要计算机来完成，但不幸的是，Han Duo 在飞行学院的大部分程序设计课中都在睡大觉。现在把这个任务交由你。", "inputFormat": "输入包括两个小行星规格。每个形式为 $n, x_1, y_1 ,x_2,y_2 \\cdots x_n ,y_n ,v_x, v_y$，其中 $n$（$3 \\le n \\le10$）是顶点的数量，每个 $x_i,y_i$（$-10000 \\leq x_i,y_i \\leq 10000$）在屏幕上按顺时针顺序给出的小行星顶点的坐标，$v_x,v_y$（$-100 \\le v_x,v_y \\le 100$）是小行星的 $x$ 和 $y$ 速度（单位/秒），$x,y$ 值代表 $t=0$ 时每个小行星的位置，此时多边形不相交或接触。小行星任意一侧的最大长度为 $500$。输入中的所有数字都是整数。", "outputFormat": "以秒为单位输出两个多边形具有最大相交的时间，如果存在多个多边形，则使用最早的时间。如果两个多边形从不重叠，而是彼此接触，则将其视为公共面积为零的交点，并输出最早的时间。如果多边形从不重叠或接触，则输出 `never`。你应该只考虑确定的时候。输出的绝对或相对的误差应不超过 $10^{-3}$。", "hint": "时间限制：$2000$ 毫秒，内存限制：$1048576$ kB。\n\n2015年国际大学生编程大赛（ACM-ICPC）世界总决赛。", "locale": "zh-CN"}}}
{"pid": "P6906", "type": "P", "difficulty": 6, "samples": [["3 2\n40 30 40\n50 10\n50\n", "80\n"], ["3 2\n10 10 10\n20 21\n21\n", "40\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "ICPC", "WF"], "title": "[ICPC 2015 WF] Catering", "background": "", "description": "Paul owns a catering company and business is booming. The company has $k$ catering teams, each in charge of one set of catering equipment. Every week, the company accepts $n$ catering requests for various events. For every request, they send a catering team with their equipment to the event location. The team delivers the food, sets up the equipment, and instructs the host on how to use the equipment and serve the food. After the event, the host is responsible for returning the equipment back to Paul’s company. \n\nUnfortunately, in some weeks the number of catering teams is less than the number of requests, so some teams may have to be used for more than one event. In these cases, the company cannot wait for the host to return the equipment and must keep the team on-site to move the equipment to another location. The company has an accurate estimate of the cost to move a set of equipment from any location to any other location. Given these costs, Paul wants to prepare an Advance Catering Map to service the requests while minimizing the total moving cost of equipment (including the cost of the first move), even if that means not using all the available teams. Paul needs your help to write a program to accomplish this task. The requests are sorted in ascending order of their event times and they are chosen in such a way that for any $i < j$, there is enough time to transport the equipment used in the $i^{th}$ request to the location of the $j^{th}$ request.", "inputFormat": "The first line of input contains two integers $n$ ($1 \\le n \\le 100$) and $k$ ($1 \\le k \\le 100$) which are the number of requests and the number of catering teams, respectively. Following that are $n$ lines, where the $i^{th}$ line contains $n-i+1$ integers between $0$ and $1\\, 000\\, 000$ inclusive. The $j^{th}$ number in the $i^{th}$ line is the cost of moving a set of equipment from location $i$ to location $i+j$. The company is at location $1$ and the $n$ requests are at locations $2$ to $n+1$.", "outputFormat": "Display the minimum moving cost to service all requests. (This amount does not include the cost of moving the equipment back to the catering company.)", "hint": "Time limit: 4000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Catering", "background": "", "description": "Paul owns a catering company and business is booming. The company has $k$ catering teams, each in charge of one set of catering equipment. Every week, the company accepts $n$ catering requests for various events. For every request, they send a catering team with their equipment to the event location. The team delivers the food, sets up the equipment, and instructs the host on how to use the equipment and serve the food. After the event, the host is responsible for returning the equipment back to Paul’s company. \n\nUnfortunately, in some weeks the number of catering teams is less than the number of requests, so some teams may have to be used for more than one event. In these cases, the company cannot wait for the host to return the equipment and must keep the team on-site to move the equipment to another location. The company has an accurate estimate of the cost to move a set of equipment from any location to any other location. Given these costs, Paul wants to prepare an Advance Catering Map to service the requests while minimizing the total moving cost of equipment (including the cost of the first move), even if that means not using all the available teams. Paul needs your help to write a program to accomplish this task. The requests are sorted in ascending order of their event times and they are chosen in such a way that for any $i < j$, there is enough time to transport the equipment used in the $i^{th}$ request to the location of the $j^{th}$ request.", "inputFormat": "The first line of input contains two integers $n$ ($1 \\le n \\le 100$) and $k$ ($1 \\le k \\le 100$) which are the number of requests and the number of catering teams, respectively. Following that are $n$ lines, where the $i^{th}$ line contains $n-i+1$ integers between $0$ and $1\\, 000\\, 000$ inclusive. The $j^{th}$ number in the $i^{th}$ line is the cost of moving a set of equipment from location $i$ to location $i+j$. The company is at location $1$ and the $n$ requests are at locations $2$ to $n+1$.", "outputFormat": "Display the minimum moving cost to service all requests. (This amount does not include the cost of moving the equipment back to the catering company.)", "hint": "Time limit: 4000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Catering", "background": "", "description": "Paul 拥有一家餐饮公司，生意兴隆。公司有 $k$ 个餐饮团队，每个团队负责一套餐饮设备。每周，公司会接受 $n$ 个不同活动的餐饮请求。对于每个请求，他们会派遣一个餐饮团队及其设备到活动地点。团队负责送餐、安装设备，并指导主办方如何使用设备和提供餐饮。活动结束后，主办方负责将设备归还给 Paul 的公司。\n\n不幸的是，有些周的餐饮团队数量少于请求数量，因此一些团队可能需要用于多个活动。在这种情况下，公司不能等待主办方归还设备，必须让团队留在现场以便将设备转移到另一个地点。公司可以准确估算从任何地点到任何其他地点移动一套设备的成本。鉴于这些成本，Paul 希望准备一份“高级餐饮地图”以满足请求，同时最小化设备的总移动成本（包括首次移动的成本），即使这意味着不使用所有可用的团队。Paul 需要你的帮助来编写一个程序来完成这个任务。请求按活动时间的升序排序，并且选择这些请求的方式是，对于任何 $i < j$，都有足够的时间将用于第 $i$ 个请求的设备运输到第 $j$ 个请求的地点。", "inputFormat": "输入的第一行包含两个整数 $n$ ($1 \\le n \\le 100$) 和 $k$ ($1 \\le k \\le 100$)，分别表示请求的数量和餐饮团队的数量。接下来的 $n$ 行中，第 $i$ 行包含 $n-i+1$ 个整数，范围在 $0$ 到 $1,000,000$ 之间（包含）。第 $i$ 行的第 $j$ 个数字表示将一套设备从位置 $i$ 移动到位置 $i+j$ 的成本。公司位于位置 $1$，$n$ 个请求位于位置 $2$ 到 $n+1$。", "outputFormat": "显示服务所有请求的最小移动成本。（此金额不包括将设备移回餐饮公司的成本。）", "hint": "时间限制：4000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2015。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6907", "type": "P", "difficulty": 5, "samples": [["0 4\n", "25.000000000\n25.000000000\n25.000000000\n25.000000000\n"], ["2 5\n10000 10000 20000 20000\n40000 40000 50000 60000\n", "14.611103142\n16.269801734\n24.092457788\n27.002992272\n18.023645064\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2015 WF] Cutting Cheese", "background": "", "description": " ![](https://vj.z180.cn/5f637f1053193ffad543787cd8bc5b2a?v=1601501213)  \n\nOf course you have all heard of the International Cheese Processing Company. Their machine for cutting a piece of cheese into slices of exactly the same thickness is a classic. Recently they produced a machine able to cut a spherical cheese (such as Edam) into slices – no, not all of the same thickness, but all of the same weight! But new challenges lie ahead: cutting Swiss cheese. \n\nSwiss cheese such as Emmentaler has holes in it, and the holes may have different sizes. A slice with holes contains less cheese and has a lower weight than a slice without holes. So here is the challenge: cut a cheese with holes in it into slices of equal weight.\n\nBy smart sonar techniques (the same techniques used to scan unborn babies and oil fields), it is possible to locate the holes in the cheese up to micrometer precision. For the present problem you may assume that the holes are perfect spheres.\n\nEach uncut block has size $100 \\times 100 \\times 100$ where each dimension is measured in millimeters. Your task is to cut it into $s$ slices of equal weight. The slices will be $100$ mm wide and $100$ mm high, and your job is to determine the thickness of each slice.", "inputFormat": "The first line of the input contains two integers $n$ and $s$, where $0 \\leq n \\leq 10\\, 000$ is the number of holes in the cheese, and $1 \\le s \\le 100$ is the number of slices to cut. The next $n$ lines each contain four positive integers $r$, $x$, $y$, and $z$ that describe a hole, where $r$ is the radius and $x$, $y$, and $z$ are the coordinates of the center, all in micrometers.\n\nThe cheese block occupies the points $(x,y,z)$ where $0 \\le x,y,z \\le 100\\, 000$, except for the points that are part of some hole. The cuts are made perpendicular to the $z$ axis.\n\nYou may assume that holes do not overlap but may touch, and that the holes are fully contained in the cheese but may touch its boundary.", "outputFormat": "Display the $s$ slice thicknesses in millimeters, starting from the end of the cheese with $z=0$. Your output should have an absolute or relative error of at most $10^{-6}$.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Cutting Cheese", "background": "", "description": " ![](https://vj.z180.cn/5f637f1053193ffad543787cd8bc5b2a?v=1601501213)  \n\nOf course you have all heard of the International Cheese Processing Company. Their machine for cutting a piece of cheese into slices of exactly the same thickness is a classic. Recently they produced a machine able to cut a spherical cheese (such as Edam) into slices – no, not all of the same thickness, but all of the same weight! But new challenges lie ahead: cutting Swiss cheese. \n\nSwiss cheese such as Emmentaler has holes in it, and the holes may have different sizes. A slice with holes contains less cheese and has a lower weight than a slice without holes. So here is the challenge: cut a cheese with holes in it into slices of equal weight.\n\nBy smart sonar techniques (the same techniques used to scan unborn babies and oil fields), it is possible to locate the holes in the cheese up to micrometer precision. For the present problem you may assume that the holes are perfect spheres.\n\nEach uncut block has size $100 \\times 100 \\times 100$ where each dimension is measured in millimeters. Your task is to cut it into $s$ slices of equal weight. The slices will be $100$ mm wide and $100$ mm high, and your job is to determine the thickness of each slice.", "inputFormat": "The first line of the input contains two integers $n$ and $s$, where $0 \\leq n \\leq 10\\, 000$ is the number of holes in the cheese, and $1 \\le s \\le 100$ is the number of slices to cut. The next $n$ lines each contain four positive integers $r$, $x$, $y$, and $z$ that describe a hole, where $r$ is the radius and $x$, $y$, and $z$ are the coordinates of the center, all in micrometers.\n\nThe cheese block occupies the points $(x,y,z)$ where $0 \\le x,y,z \\le 100\\, 000$, except for the points that are part of some hole. The cuts are made perpendicular to the $z$ axis.\n\nYou may assume that holes do not overlap but may touch, and that the holes are fully contained in the cheese but may touch its boundary.", "outputFormat": "Display the $s$ slice thicknesses in millimeters, starting from the end of the cheese with $z=0$. Your output should have an absolute or relative error of at most $10^{-6}$.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Cutting Cheese", "background": "", "description": "# 题目背景\n\n当然，你们都已经听说过国际奶酪加工公司。他们将一块奶酪切成完全相同厚度的薄片的机器是一个经典。最近，他们生产了一种能将球形奶酪（比如荷兰球形干酪）切成薄片的机器——不，不是所有的厚度都一样，而是所有的质量都一样！但是新的挑战摆在面前：切瑞士奶酪。\n\n瑞士奶酪，比如瑞士多孔奶酪，在其中有很多洞，并且这些洞大小可能不同。一片有空洞的奶酪比一片没有洞的奶酪含量更少，质量更轻。所以这是一个挑战：将一块有空洞的奶酪切成质量相同的薄片。\n\n通过智能声呐技术（与过去常常探测未出生的婴儿和油田的技术一样），可以将空洞定位精确到微米级别。对于目前的问题，你可以认为这些洞是完美球体。\n\n每一个未切割的奶酪块尺寸为 $100\\times100\\times100$，其中单位为毫米。你的任务是把它切成 $s$ 个质量相等的薄片。这些薄片宽度和高度都应当是 $100\\operatorname{mm}$，然后你的工作是求出每个薄片的厚度。\n\n## 简化题意\n\n有一个 $100 \\text{mm} \\times 100 \\text{mm} \\times 100 \\text{mm}$ 的质地均匀的正方体，垂直于 $z$ 轴的切成 $s$ 个薄片，使得每一片质量相等。每一薄片宽度和高度都是 $100 \\text{mm}$，请从奶酪底端 $z=0$ 开始依次输出每一片的厚度。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $s$，其中 $0 \\leq n \\leq 10000$ 表示奶酪中洞的个数，然后 $1 \\le s \\le 100$ 表示要切割的薄片数。接下来的 $n$ 行分别包含四个描述空洞的正整数 $r,x,y,z$，其中 $r$ 表示半径，$x$、$y$ 和 $z$ 表示空洞中心坐标，都以微米为单位。\n\n奶酪的圆心 $(x,y,z)$ 中 $0 \\le x,y,z \\le 100000$，除了某个孔的部分点（即某个孔的部分点可能超出该范围，但是圆心一定在这之内）。刀切的方向垂直于 $z$ 轴。\n\n你可以认为这些洞没有重叠但是可能接触，并且这些孔完全包含在奶酪里，但可能接触奶酪的边界。", "outputFormat": "输出保留 $9$ 位小数。从奶酪底端 $z=0$ 开始，以毫米为单位输出 $s$ 个薄片厚度。相对误差或绝对误差不能超过 $10^{-6}$。", "hint": "时间限制：$3000 \\text{ms}$，空间限制：$1048576\\text{kB}$。\n\n2015年国际大学生编程大赛（ACM-ICPC）世界总决赛", "locale": "zh-CN"}}}
{"pid": "P6908", "type": "P", "difficulty": 5, "samples": [["5\nAACCMMAA\nACA\nMM\nACMAA\nAA\nA\n", "1 4\nMM\nA\nAA\nACA\nACMAA\n"], ["3\nACMA\nACM\nACA\nAMA\n", "impossible\n"], ["1\nAM\nMA\n", "impossible\n"], ["4\nAAAAAA\nAA\nAAA\nA\nAAAAA\n", "0 4\nA\nAA\nAAA\nAAAAA\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2015", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2015 WF] Evolution in Parallel", "background": "", "description": "It is 2178, and alien life has been discovered on a distant planet. There seems to be only one species on the planet and they do not reproduce as animals on Earth do. Even more amazing, the genetic makeup of every single organism is identical!\n\nThe genetic makeup of each organism is a single sequence of nucleotides. The nucleotides come in three types, denoted by ‘A’ (Adenine), ‘C’ (Cytosine), and ‘M’ (Muamine). According to one hypothesis, evolution on this planet occurs when a new nucleotide is inserted somewhere into the genetic sequence of an existing organism. If this change is evolutionarily advantageous, then organisms with the new sequence quickly replace ones with the old sequence.\n\nIt was originally thought that the current species evolved this way from a single, very simple organism with a single-nucleotide genetic sequence, by way of mutations as described above. However, fossil evidence suggests that this might not have been the case. Right now, the research team you are working with is trying to validate the concept of “parallel evolution” – that there might actually have been two evolutionary paths evolving in the fashion described above, and eventually both paths evolved to the single species present on the planet today. Your task is to verify whether the parallel evolution hypothesis is consistent with the genetic material found in the fossil samples gathered by your team.", "inputFormat": "The input begins with a number $n$ ($1\\le n\\le 4\\, 000$) denoting the number of nucleotide sequences found in the fossils. The second line describes the nucleotide sequence of the species currently living on the planet. Each of the next $n$ lines describes one nucleotide sequence found in the fossils.\n\nEach nucleotide sequence consists of a string of at least one but no more than $4\\, 000$ letters. The strings contain only upper-case letters A, C, and M. All the nucleotide sequences, including that of the currently live species, are distinct.", "outputFormat": "Display an example of how the nucleotide sequences in the fossil record participate in two evolutionary paths. The example should begin with one line containing two integers $s_1$ and $s_2$, the number of nucleotide sequences in the fossil record that participate in the first path and second path, respectively. This should be followed by $s_1$ lines containing the sequences attributed to the first path, in chronological order (from the earliest), and then $s_2$ lines containing the sequences attributed to the second path, also in chronological order. If there are multiple examples, display any one of them. If it is possible that a sequence could appear in the genetic history of both species, your example should assign it to exactly one of the evolutionary paths.\n\nIf it is impossible for all the fossil material to come from two evolutionary paths, display the word impossible.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Evolution in Parallel", "background": "", "description": "It is 2178, and alien life has been discovered on a distant planet. There seems to be only one species on the planet and they do not reproduce as animals on Earth do. Even more amazing, the genetic makeup of every single organism is identical!\n\nThe genetic makeup of each organism is a single sequence of nucleotides. The nucleotides come in three types, denoted by ‘A’ (Adenine), ‘C’ (Cytosine), and ‘M’ (Muamine). According to one hypothesis, evolution on this planet occurs when a new nucleotide is inserted somewhere into the genetic sequence of an existing organism. If this change is evolutionarily advantageous, then organisms with the new sequence quickly replace ones with the old sequence.\n\nIt was originally thought that the current species evolved this way from a single, very simple organism with a single-nucleotide genetic sequence, by way of mutations as described above. However, fossil evidence suggests that this might not have been the case. Right now, the research team you are working with is trying to validate the concept of “parallel evolution” – that there might actually have been two evolutionary paths evolving in the fashion described above, and eventually both paths evolved to the single species present on the planet today. Your task is to verify whether the parallel evolution hypothesis is consistent with the genetic material found in the fossil samples gathered by your team.", "inputFormat": "The input begins with a number $n$ ($1\\le n\\le 4\\, 000$) denoting the number of nucleotide sequences found in the fossils. The second line describes the nucleotide sequence of the species currently living on the planet. Each of the next $n$ lines describes one nucleotide sequence found in the fossils.\n\nEach nucleotide sequence consists of a string of at least one but no more than $4\\, 000$ letters. The strings contain only upper-case letters A, C, and M. All the nucleotide sequences, including that of the currently live species, are distinct.", "outputFormat": "Display an example of how the nucleotide sequences in the fossil record participate in two evolutionary paths. The example should begin with one line containing two integers $s_1$ and $s_2$, the number of nucleotide sequences in the fossil record that participate in the first path and second path, respectively. This should be followed by $s_1$ lines containing the sequences attributed to the first path, in chronological order (from the earliest), and then $s_2$ lines containing the sequences attributed to the second path, also in chronological order. If there are multiple examples, display any one of them. If it is possible that a sequence could appear in the genetic history of both species, your example should assign it to exactly one of the evolutionary paths.\n\nIf it is impossible for all the fossil material to come from two evolutionary paths, display the word impossible.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Evolution in Parallel", "background": null, "description": "### 题目背景\n\n公元2178年，人类在一颗遥远的行星上发现了外星生命。但是似乎这颗行星上只有单一物种而且它们并不像地球上的动物一样繁殖。更神奇的是，每个生物的基因构成是完全相同的！\n\n每个生物的基因构成是单一核苷酸序列。在它们基因中有三种核苷酸，表示为‘A’  (腺嘌呤，Adenine), ‘C’ (胞嘧啶，Cytosine), and ‘M’ (膜嘌呤，Muamine)。根据某种假说，在这颗星球上只有某个新的核苷酸插入现存的生物基因序列某处时才会出现进化。如果这个改变是对进化有利的，这个带有新基因序列的生物会迅速取代没有变异的旧生物。\n\n我们起初认为这种生物是从基因序列只含有单一核苷酸的生物经过多次上述的变异进化而来。然而化石证据表明可能并不是一直是这种情况。目前，与你协作的科研团队正在尝试证实“平行进化”的概念。“平行进化”指可能事实上有两条如同上述的进化路径，最终他们都进化成了这颗行星如今的物种。你的任务是证实平行进化假说是否与你的团队在化石中发现的遗传物质样本一致。 \n\n( TRANSLATED by  [@MolotovM](https://www.luogu.com.cn/user/99461))\n\n### 题目含义\n\n给定一个字符串和 $n$ 个字符串，求不多于两个的字符串的子串包含其他所有字符串，且这不多于两个的字符串都是给定字符串的子串。", "inputFormat": "第一行输入为一个整数 $n (1\\le n\\le 4000)$，表示化石中发现的遗传物质样本数量\n\n第二行输入为给定字符串表示当前生物的基因序列\n\n接下来 $n$ 行，每行输入一个字符串，表示化石中发现的遗传物质样本\n\n每个遗传物质样本由不超过 4000 个字母构成，且只包含大写字母A,C和M。\n\n包括当前生物基因序列的所有基因序列都是独特的。", "outputFormat": "输出每个化石中的遗传物质样本是怎样参与两条进化路径的。\n\n第一行包含两个整数 $s_1,s_2$ 为两条进化路径的化石数量。\n\n接下来 $s_1$ 行每行包含一个字符串表示第一条进化路径中的遗传物质样本\n\n接下来 $s_2$ 行每行包含一个字符串表示第二条进化路径中的遗传物质样本\n\n样本按年代顺序输出(从最早的开始)，如果一个样本可以同时出现在两条进化路径中，你需要表明它具体参与了哪种进化。\n\n如果不可能满足有不多于两条进化路径，输出 \"impossible\"。\n\n### 时空限制\n\n时间限制: 2000 ms\n\n空间限制: 1048576 kB", "hint": null, "locale": "zh-CN"}}}
{"pid": "P6909", "type": "P", "difficulty": 4, "samples": [["4 7\nABCDEFG\nHIJKLMN\nOPQRSTU\nVWXYZ**\nCONTEST\n", "30\n"], ["5 20\n12233445566778899000\nQQWWEERRTTYYUUIIOOPP\n-AASSDDFFGGHHJJKKLL*\n--ZZXXCCVVBBNNMM--**\n--------------------\nACM-ICPC-WORLD-FINALS-2015\n", "160\n"], ["2 19\nABCDEFGHIJKLMNOPQZY\nX*****************Y\nAZAZ\n", "19\n"], ["6 4\nAXYB\nBBBB\nKLMB\nOPQB\nDEFB\nGHI*\nAB\n", "7\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "ICPC", "WF"], "title": "[ICPC 2015 WF] Keyboarding", "background": "", "description": "How many keystrokes are necessary to type a text message? You may think that it is equal to the number of characters in the text, but this is correct only if one keystroke generates one character. With pocket-size devices, the possibilities for typing text are often limited. Some devices provide only a few buttons, significantly fewer than the number of letters in the alphabet. For such devices, several strokes may be needed to type a single character. One mechanism to deal with these limitations is a virtual keyboard displayed on a screen, with a cursor that can be moved from key to key to select characters. Four arrow buttons control the movement of the cursor, and when the cursor is positioned over an appropriate key, pressing the fifth button selects the corresponding character and appends it to the end of the text. To terminate the text, the user must navigate to and select the Enter key. This provides users with an arbitrary set of characters and enables them to type text of any length with only five hardware buttons.\n\nIn this problem, you are given a virtual keyboard layout and your task is to determine the minimal number of strokes needed to type a given text, where pressing any of the five hardware buttons constitutes a stroke. The keys are arranged in a rectangular grid, such that each virtual key occupies one or more connected unit squares of the grid. The cursor starts in the upper left corner of the keyboard and moves in the four cardinal directions, in such a way that it always skips to the next unit square in that direction that belongs to a different key. If there is no such unit square, the cursor does not move.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3cxjl2y4.png)\n\n   Figure 1: Sample Input 1. An example virtual keyboard and hardware buttons. \n\nFigure 1, illustrating Sample Input 1, shows a possible way to type CONTEST using 30 strokes on an example virtual keyboard. The red dots represent the virtual keys where the select button was pressed.", "inputFormat": "The first line of the input contains two integers $r$ and $c$ ($1 \\leq r, c \\leq 50$), giving the number of rows and columns of the virtual keyboard grid. The virtual keyboard is specified in the next $r$ lines, each of which contains $c$ characters. The possible values of these characters are uppercase letters, digits, a dash, and an asterisk (representing Enter). There is only one key corresponding to any given character. Each key is made up of one or more grid squares, which will always form a connected region. The last line of the input contains the text to be typed. This text is a non-empty string of at most $10\\, 000$ of the available characters other than the asterisk.", "outputFormat": "Display the minimal number of strokes necessary to type the whole text, including the Enter key at the end. It is guaranteed that the text can be typed.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Keyboarding", "background": "", "description": "How many keystrokes are necessary to type a text message? You may think that it is equal to the number of characters in the text, but this is correct only if one keystroke generates one character. With pocket-size devices, the possibilities for typing text are often limited. Some devices provide only a few buttons, significantly fewer than the number of letters in the alphabet. For such devices, several strokes may be needed to type a single character. One mechanism to deal with these limitations is a virtual keyboard displayed on a screen, with a cursor that can be moved from key to key to select characters. Four arrow buttons control the movement of the cursor, and when the cursor is positioned over an appropriate key, pressing the fifth button selects the corresponding character and appends it to the end of the text. To terminate the text, the user must navigate to and select the Enter key. This provides users with an arbitrary set of characters and enables them to type text of any length with only five hardware buttons.\n\nIn this problem, you are given a virtual keyboard layout and your task is to determine the minimal number of strokes needed to type a given text, where pressing any of the five hardware buttons constitutes a stroke. The keys are arranged in a rectangular grid, such that each virtual key occupies one or more connected unit squares of the grid. The cursor starts in the upper left corner of the keyboard and moves in the four cardinal directions, in such a way that it always skips to the next unit square in that direction that belongs to a different key. If there is no such unit square, the cursor does not move.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3cxjl2y4.png)\n\n   Figure 1: Sample Input 1. An example virtual keyboard and hardware buttons. \n\nFigure 1, illustrating Sample Input 1, shows a possible way to type CONTEST using 30 strokes on an example virtual keyboard. The red dots represent the virtual keys where the select button was pressed.", "inputFormat": "The first line of the input contains two integers $r$ and $c$ ($1 \\leq r, c \\leq 50$), giving the number of rows and columns of the virtual keyboard grid. The virtual keyboard is specified in the next $r$ lines, each of which contains $c$ characters. The possible values of these characters are uppercase letters, digits, a dash, and an asterisk (representing Enter). There is only one key corresponding to any given character. Each key is made up of one or more grid squares, which will always form a connected region. The last line of the input contains the text to be typed. This text is a non-empty string of at most $10\\, 000$ of the available characters other than the asterisk.", "outputFormat": "Display the minimal number of strokes necessary to type the whole text, including the Enter key at the end. It is guaranteed that the text can be typed.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Keyboarding", "background": "", "description": "输入一个文本消息需要多少次按键？你可能认为这等同于文本中的字符数，但这仅在一次按键生成一个字符时才正确。对于口袋大小的设备，输入文本的可能性通常受到限制。有些设备仅提供少量按钮，远少于字母表中的字母数量。对于这样的设备，输入一个字符可能需要多次按键。为了解决这些限制，一种机制是在屏幕上显示虚拟键盘，并提供一个可以从一个键移动到另一个键的光标来选择字符。四个方向键控制光标的移动，当光标位于适当的键上时，按下第五个按钮选择相应的字符并将其附加到文本末尾。要终止文本，用户必须导航到并选择 Enter 键。这使用户可以使用任意字符集并仅用五个硬件按钮输入任意长度的文本。\n\n在这个问题中，给定一个虚拟键盘布局，你的任务是确定输入给定文本所需的最少按键次数，其中按下任何一个五个硬件按钮都算作一次按键。键以矩形网格排列，每个虚拟键占据网格的一个或多个连接单元格。光标从键盘的左上角开始，并在四个基本方向上移动，以便它总是跳到该方向上属于不同键的下一个单元格。如果没有这样的单元格，光标不会移动。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3cxjl2y4.png)\n\n图 1：样例输入 1。一个示例虚拟键盘和硬件按钮。\n\n图 1，说明了样例输入 1，展示了一种在示例虚拟键盘上使用 30 次按键输入 CONTEST 的可能方式。红点表示按下选择按钮的虚拟键。", "inputFormat": "输入的第一行包含两个整数 $r$ 和 $c$ ($1 \\leq r, c \\leq 50$)，表示虚拟键盘网格的行数和列数。虚拟键盘在接下来的 $r$ 行中指定，每行包含 $c$ 个字符。这些字符的可能值是大写字母、数字、一个破折号和一个星号（表示 Enter）。每个字符仅对应一个键。每个键由一个或多个网格单元组成，这些单元将始终形成一个连接区域。输入的最后一行包含要输入的文本。此文本是一个最多包含 $10\\, 000$ 个可用字符（不包括星号）的非空字符串。", "outputFormat": "显示输入整个文本所需的最少按键次数，包括最后的 Enter 键。保证文本可以被输入。", "hint": "时间限制：3000 毫秒，内存限制：1048576 KB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2015。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6910", "type": "P", "difficulty": 7, "samples": [["3\n1000 1 30 1 1\n60 2 10 2 5\n59 2 10 2 5\n", "5\n3\nimpossible\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2015", "ICPC", "WF"], "title": "[ICPC 2015 WF] Pipe Stream", "background": "", "description": " ![](https://vj.z180.cn/ba87a214c6b94e2e93a88f7b226c2064?v=1602042036)  \n\nYour hometown has hired some contractors – including you! – to manage its municipal pipe network. They built the network, at great expense, to supply Flubber to every home in town. Unfortunately, nobody has found a use for Flubber yet, but never mind. It was a Flubber network or a fire department, and honestly, houses burn down so rarely, a fire department hardly seems necessary. \n\nIn the possible event that somebody somewhere decides they want some Flubber, they would like to know how quickly it will flow through the pipes. Measuring its rate of flow is your job.\n\nYou have access to one of the pipes connected to the network. The pipe is $l$ meters long, and you can start the flow of Flubber through this pipe at a time of your choosing. You know that it flows with a constant real-valued speed, which is at least $v_1$ meters/second and at most $v_2$ meters/second. You want to estimate this speed with an absolute error of at most $\\frac{t}{2}$ meters/second.\n\nUnfortunately, the pipe is opaque, so the only thing you can do is to knock on the pipe at any point along its length, that is, in the closed real-valued range $[0,l]$. Listening to the sound of the knock will tell you whether or not the Flubber has reached that point. You are not infinitely fast. Your first knock must be at least $s$ seconds after starting the flow, and there must be at least $s$ seconds between knocks.\n\nDetermine a strategy that will require the fewest knocks, in the worst case, to estimate how fast the Flubber is flowing. Note that in some cases the desired estimation might be impossible (for example, if the Flubber reaches the end of the pipe too quickly).", "inputFormat": "The input consists of multiple test cases. The first line of input contains an integer $c$ ($1 \\leq c \\leq 100$), the number of test cases. Each of the next $c$ lines describes one test case. Each test case contains the five integers $l$, $v_1$, $v_2$, $t$ and $s$ ($1 \\leq l, v_1, v_2, t, s \\leq 10^9$ and $v_1 < v_2$), which are described above.", "outputFormat": "For each test case, display the minimal number of knocks required to estimate the flow speed in the worst case. If it might be impossible to measure the flow speed accurately enough, display impossible instead.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Pipe Stream", "background": "", "description": " ![](https://vj.z180.cn/ba87a214c6b94e2e93a88f7b226c2064?v=1602042036)  \n\nYour hometown has hired some contractors – including you! – to manage its municipal pipe network. They built the network, at great expense, to supply Flubber to every home in town. Unfortunately, nobody has found a use for Flubber yet, but never mind. It was a Flubber network or a fire department, and honestly, houses burn down so rarely, a fire department hardly seems necessary. \n\nIn the possible event that somebody somewhere decides they want some Flubber, they would like to know how quickly it will flow through the pipes. Measuring its rate of flow is your job.\n\nYou have access to one of the pipes connected to the network. The pipe is $l$ meters long, and you can start the flow of Flubber through this pipe at a time of your choosing. You know that it flows with a constant real-valued speed, which is at least $v_1$ meters/second and at most $v_2$ meters/second. You want to estimate this speed with an absolute error of at most $\\frac{t}{2}$ meters/second.\n\nUnfortunately, the pipe is opaque, so the only thing you can do is to knock on the pipe at any point along its length, that is, in the closed real-valued range $[0,l]$. Listening to the sound of the knock will tell you whether or not the Flubber has reached that point. You are not infinitely fast. Your first knock must be at least $s$ seconds after starting the flow, and there must be at least $s$ seconds between knocks.\n\nDetermine a strategy that will require the fewest knocks, in the worst case, to estimate how fast the Flubber is flowing. Note that in some cases the desired estimation might be impossible (for example, if the Flubber reaches the end of the pipe too quickly).", "inputFormat": "The input consists of multiple test cases. The first line of input contains an integer $c$ ($1 \\leq c \\leq 100$), the number of test cases. Each of the next $c$ lines describes one test case. Each test case contains the five integers $l$, $v_1$, $v_2$, $t$ and $s$ ($1 \\leq l, v_1, v_2, t, s \\leq 10^9$ and $v_1 < v_2$), which are described above.", "outputFormat": "For each test case, display the minimal number of knocks required to estimate the flow speed in the worst case. If it might be impossible to measure the flow speed accurately enough, display impossible instead.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Pipe Stream", "background": "", "description": "你的家乡雇了一些承包商——包括你！—— 来管理市政管道网络。他们花费巨资建设了该网络，以向城镇中的每个家庭供应弹力胶。不幸的是，目前还没有人找到弹力胶的用途，但没关系。这要么是一个弹力胶网络，要么是一个消防部门。但老实说，房屋很少烧毁，似乎并不需要消防部门。\n\n假设某个地方有人决定要制作一些弹力胶，他们希望知道它会在管道中以多快的速度流动。测量它的流动速度就是你的工作。\n\n你可以访问与网络连接的其中一根管道。该管道长度为 $l$ 米，并且你可以在选择的时间开始通过此管道传输弹力胶。你知道它以恒定的实数速度流动，该速度至少为 $v_1$ 米/秒，最多为 $v_2$ 米/秒。你希望以至多 $\\frac{t}{2}$ 米/秒的绝对误差估计此速度(即绝对误差不大于 $\\frac {t}{2}$)。\n\n不幸的是，管道是不透明的，所以你唯一能做的事就是在管道的任意一点敲打，即在闭合的实数范围 $[0,l]$ 内。通过听到敲打声，你可以知道弹力胶是否到达了那个点。你的速度并不是无限快的。你第一次敲打必须在开始流动后至少 $s$ 秒，并且敲打之间必须有至少 $s$ 秒的间隔。\n\n你的任务是确定一种策略，需要在最坏情况下用最少的敲击来估算弹力胶的流速。注意，在某些情况下，所需的估计可能是不可能的（例如，弹力胶可能过快地到达管道的末端）。", "inputFormat": "输入包含多组数据。输入的第一行包含一个整数 $c$ $(1 \\le c \\le 100)$，表示数据组数。接下来的 $c$ 行描述了每组数据。每组数据包含五个整数 $l$，$v_1$，$v_2$ ，$t$ 和 $s$ $（1 \\le l, v_1, v_2, t, s \\le 10^9 \\text{并且}v_1<v_2)$，含义如上所述。", "outputFormat": "对于每组数据，输出在最坏情况下估计流速所需的最小敲击次数。如果无法准确测量流速，则输出 \"$impossible$\"(不含引号)。", "hint": "时间限制：$1000$ ms，空间限制：$1048576$ kB。\n\n### 题目来源\n\n> International Collegiate Programming Contest (ACM-ICPC) World Finals 2015\n\n> [icpc2015.pdf](https://icpc.global/worldfinals/problems/2015-ICPC-World-Finals/icpc2015.pdf)", "locale": "zh-CN"}}}
{"pid": "P6911", "type": "P", "difficulty": 5, "samples": [["8 4 1\n", "31.500000\n3.000000\n"], ["195 65 2\n", "12220.000000\n48.000000\n108.000000\n"], ["10000 1 1000\n", "30141.885677\n9.956721\n19.913443\n29.870164\n39.826887\n49.783610\n59.740334\n69.697060\n79.653786\n89.610515\n99.567245\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2015", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2015 WF] Qanat", "background": "", "description": "A qanat is an irrigation system widely used to deliver water in hot, arid climates. The technology was originally developed by Persians over 2000 years ago. In Morocco, qanats are known as khettara and are still used today in the southern part of the country.\n\nThe basic feature of a qanat is an essentially horizontal channel that brings water from an underground water source to an outlet near a civilization. There is also a shaft known as a mother well that rises vertically from the underground water source to the surface of a mountain or hill. Creating such a system is extremely expensive, and was especially so in ancient times, since all of the materials excavated from the channel and mother well must be carried above ground, either through the channel outlet or the top of the mother well. To aid in the construction, there are often one or more additional vertical shafts placed at strategic locations above the underground channel. Although these shafts must also be excavated, they provide a means for lifting additional dirt from the horizontal channel as illustrated in Figure 1.\n\n  ![](https://vj.z180.cn/4dea3d690f1497e79acad3985c8a9915?v=1603314265) \n\n   Figure 1: An illustration of a qanat. \n\nFor this problem, model the cross-section of a qanat as shown in Figure 2, with the channel outlet at $(0,0)$, the water source at $(w,0)$, and the top of the mother well at $(w,h)$ with $w > h$. The surface of the mountain extends along a straight line from $(w,h)$ to $(0,0)$.\n\n  ![](https://vj.z180.cn/a58cc42544b91877083973369ca77d3c?v=1603314265) \n\n   Figure 2: A simplified model of a qanat cross-section. \n\nEvery qanat must have a vertical mother well from the water source to the mountain surface above, along with $n$ additional vertical shafts. The channel and all shafts are modeled as line segments. Your goal is to determine the placement for those additional shafts so as to minimize the overall excavation cost. This cost is equal to the sum of the distances that each piece of excavated dirt must be transported to reach the surface (using any combination of horizontal and vertical movement). For example, the cost of excavating a continuous section of dirt starting from the surface and going along a path of length $\\ell $ (possibly including turns) is $\\int _0^{\\ell } x \\, dx = \\frac{1}{2} \\ell ^2$.", "inputFormat": "The input consists of a single line containing three integers $w$ ($1 \\le w \\le 10\\, 000$), $h$ ($1 \\le h < w$), and $n$ ($1 \\le n \\le 1\\, 000$). The value $w$ is the horizontal distance from the water source to the qanat outlet. The value $h$ is the vertical distance from the water source to the mountain surface. The value $n$ is the number of vertical shafts that must be used in addition to the mother well.", "outputFormat": "First, display the minimum overall excavation cost. Next, display the $x$-coordinates, in increasing order, for $n$ optimally placed vertical shafts. If $n > 10$, display only the first $10$ $x$-coordinates. Answers within an absolute or relative error of $10^{-4}$ will be accepted. You may assume that there is a unique solution. No test case will result in a shaft within $0.001$ units from the outlet of the qanat channel or from another shaft.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Qanat", "background": "", "description": "A qanat is an irrigation system widely used to deliver water in hot, arid climates. The technology was originally developed by Persians over 2000 years ago. In Morocco, qanats are known as khettara and are still used today in the southern part of the country.\n\nThe basic feature of a qanat is an essentially horizontal channel that brings water from an underground water source to an outlet near a civilization. There is also a shaft known as a mother well that rises vertically from the underground water source to the surface of a mountain or hill. Creating such a system is extremely expensive, and was especially so in ancient times, since all of the materials excavated from the channel and mother well must be carried above ground, either through the channel outlet or the top of the mother well. To aid in the construction, there are often one or more additional vertical shafts placed at strategic locations above the underground channel. Although these shafts must also be excavated, they provide a means for lifting additional dirt from the horizontal channel as illustrated in Figure 1.\n\n  ![](https://vj.z180.cn/4dea3d690f1497e79acad3985c8a9915?v=1603314265) \n\n   Figure 1: An illustration of a qanat. \n\nFor this problem, model the cross-section of a qanat as shown in Figure 2, with the channel outlet at $(0,0)$, the water source at $(w,0)$, and the top of the mother well at $(w,h)$ with $w > h$. The surface of the mountain extends along a straight line from $(w,h)$ to $(0,0)$.\n\n  ![](https://vj.z180.cn/a58cc42544b91877083973369ca77d3c?v=1603314265) \n\n   Figure 2: A simplified model of a qanat cross-section. \n\nEvery qanat must have a vertical mother well from the water source to the mountain surface above, along with $n$ additional vertical shafts. The channel and all shafts are modeled as line segments. Your goal is to determine the placement for those additional shafts so as to minimize the overall excavation cost. This cost is equal to the sum of the distances that each piece of excavated dirt must be transported to reach the surface (using any combination of horizontal and vertical movement). For example, the cost of excavating a continuous section of dirt starting from the surface and going along a path of length $\\ell $ (possibly including turns) is $\\int _0^{\\ell } x \\, dx = \\frac{1}{2} \\ell ^2$.", "inputFormat": "The input consists of a single line containing three integers $w$ ($1 \\le w \\le 10\\, 000$), $h$ ($1 \\le h < w$), and $n$ ($1 \\le n \\le 1\\, 000$). The value $w$ is the horizontal distance from the water source to the qanat outlet. The value $h$ is the vertical distance from the water source to the mountain surface. The value $n$ is the number of vertical shafts that must be used in addition to the mother well.", "outputFormat": "First, display the minimum overall excavation cost. Next, display the $x$-coordinates, in increasing order, for $n$ optimally placed vertical shafts. If $n > 10$, display only the first $10$ $x$-coordinates. Answers within an absolute or relative error of $10^{-4}$ will be accepted. You may assume that there is a unique solution. No test case will result in a shaft within $0.001$ units from the outlet of the qanat channel or from another shaft.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Qanat", "background": "", "description": "[原题面链接](https://icpc.global/worldfinals/problems/2015-ICPC-World-Finals/icpc2015.pdf)\n\n\nqanat 是一种广泛用在气候炎热、干旱的地区中供水的灌溉系统。这项技术最初由波斯人在 $2000$ 多年前发明。在摩洛哥，qanat 被称为 khettara。至今该系统在该国南部地区仍然被使用。\n\nqanat 的基本特点是用一个基本上是水平的沟渠，把水从地下水源带到靠近城市的出水口。还有一个被称为母井的轴垂直向上延升，从地下水源上升到山脉或山丘的地表。建设这样的系统非常昂贵，在古代更加如此，因为从沟渠和母井中挖出的所有材料都必须在地表运输。这可以通过沟渠出口或母井顶部来进行。为了帮助施工，通常在地下沟渠上方的关键位置还会放置一个或多个额外的垂直井口。尽管这些井口也必须需要被挖掘，但它们提供了一种从水平沟渠中运输额外泥土的手段，如图 $1$ 所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s71tofvr.png)\n\n对于这个问题，模拟一个 qanat 的横截面，如图 $2$ 所示，其中通道出口在 $(0,0)$，水源在 $(w,0)$，母井顶部在 $(w,h)$，其中 $w > h$。山的表面沿着一条直线延伸，从 $(w,h)$ 到 $(0,0)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4bk00ojs.png)\n\n每个 qanat 必须从水源到山体表面上有一个垂直的母井，还需要 $n$ 个额外的垂直井。水道和所有垂直井都被建模为线段。你的目标是确定这些额外井的位置，以最小化整体的挖掘成本。这个成本等于每块挖掘的土壤必须被运输到表面的距离的总和（任何水平和垂直运动的组合）。例如，从表面开始并沿着长度为 $l$ 的路径挖掘连续的土壤的成本为 $\\int_0^l x \\ \\mathop{}\\!\\mathrm{dx}=\\frac{1}{2}l^2$。", "inputFormat": "输入是一行，包含三个整数 $w$ $(1\\le w\\le 10000)$， $h$ $(1\\le h<w)$，和 $n$ $(1\\le n\\le 1000)$，分别表示水源到 qanat 出口的水平距离，水源到山体表面的垂直距离和除了母井之外必须使用的垂直井口的数量。", "outputFormat": "首先，输出最小开挖成本。接下来，按照递增顺序输出 $n$ 个最优放置的竖井的 $x$ 坐标。如果 $n > 10$，则仅输出前 $10$ 个 $x$ 坐标。相对误差可以在 $10^{-4}$ 之内。你可以假设存在唯一解决方案。没有数据会导致竖井距离 qanat 渠道出口或其他竖井小于0.001单位。\n\n### **说明/提示**\n\n时间限制：$2000$ ms，空间限制：$1048576$ kB。\n\n来源：\n\n> International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6912", "type": "P", "difficulty": 0, "samples": [["3 100 5 10 0 100\nE 2 100 -300 50 -100\nW 3 10 60 50 200 200 400\nE 1 100 -300\n", "6.00000000\n"], ["1 100 5 10 0 200\nW 4 100 100 100 300 100 700 100 900\n", "50.00000000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "ICPC", "WF"], "title": "[ICPC 2015 WF] Ship Traffic", "background": "", "description": "Ferries crossing the Strait of Gibraltar from Morocco to Spain must carefully navigate to avoid the heavy ship traffic along the strait. Write a program to help ferry captains find the largest gaps in strait traffic for a safe crossing.\n\nYour program will use a simple model as follows. The strait has several parallel shipping lanes in east-west direction. Ships run with the same constant speed either eastbound or westbound. All ships in the same lane run in the same direction. Satellite data provides the positions of the ships in each lane. The ships may have different lengths. Ships do not change lanes and do not change speed for the crossing ferry.\n\nThe ferry waits for an appropriate time when there is an adequate gap in the ship traffic. It then crosses the strait heading northbound along a north-south line at a constant speed. From the moment a ferry enters a lane until the moment it leaves the lane, no ship in that lane may touch the crossing line. Ferries are so small you can neglect their size. Figure 1 illustrates the lanes and ships for Sample Input 1. Your task is to find the largest time interval within which the ferry can safely cross the strait.\n\n![](https://cdn.vjudge.net.cn/35b69cfdbd76aaea80c318132bb285b0)\n\n   Figure 1: Sample Input 1. ", "inputFormat": "The first line of input contains six integers: the number of lanes $n$ ($1 \\leq n \\leq 10^5$), the width $w$ of each lane ($1 \\leq w \\leq 1\\, 000$), the speed $u$ of ships and the speed $v$ of the ferry ($1 \\leq u, v \\leq 100$), the ferry’s earliest start time $t_1$ and the ferry’s latest start time $t_2$ ($0 \\leq t_1 < t_2 \\leq 10^6$). All lengths are given in meters, all speeds are given in meters/second, and all times are given in seconds.\n\nEach of the next $n$ lines contains the data for one lane. Each line starts with either E or W, where E indicates that ships in this lane are eastbound and W indicates that ships in this lane are westbound. Next in the line is an integer $m_ i$, the number of ships in this lane ($0 \\leq m_ i \\leq 10^5$ for each $1 \\leq i \\leq n$). It is followed by $m_ i$ pairs of integers $l_{ij}$ and $p_{ij}$ ($1 \\leq l_{ij} \\leq 1\\, 000$ and $-10^6 \\leq p_{ij} \\leq 10^6$). The length of ship $j$ in lane $i$ is $l_{ij}$, and $p_{ij}$ is the position at time $0$ of its forward end, that is, its front in the direction it moves.\n\nShip positions within each lane are relative to the ferry’s crossing line. Negative positions are west of the crossing line and positive positions are east of it. Ships do not overlap or touch, and are sorted in increasing order of their positions. Lanes are ordered by increasing distance from the ferry’s starting point, which is just south of the first lane. There is no space between lanes. The total number of ships is at least $1$ and at most $10^5$.", "outputFormat": "Display the maximal value $d$ for which there is a time $s$ such that the ferry can start a crossing at any time $t$ with $s \\leq t \\leq s+d$. Additionally the crossing must not start before time $t_1$ and must start no later than time $t_2$. The output must have an absolute or relative error of at most $10^{-3}$. You may assume that there is a time interval with $d > 0.1$ seconds for the ferry to cross.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Ship Traffic", "background": "", "description": "Ferries crossing the Strait of Gibraltar from Morocco to Spain must carefully navigate to avoid the heavy ship traffic along the strait. Write a program to help ferry captains find the largest gaps in strait traffic for a safe crossing.\n\nYour program will use a simple model as follows. The strait has several parallel shipping lanes in east-west direction. Ships run with the same constant speed either eastbound or westbound. All ships in the same lane run in the same direction. Satellite data provides the positions of the ships in each lane. The ships may have different lengths. Ships do not change lanes and do not change speed for the crossing ferry.\n\nThe ferry waits for an appropriate time when there is an adequate gap in the ship traffic. It then crosses the strait heading northbound along a north-south line at a constant speed. From the moment a ferry enters a lane until the moment it leaves the lane, no ship in that lane may touch the crossing line. Ferries are so small you can neglect their size. Figure 1 illustrates the lanes and ships for Sample Input 1. Your task is to find the largest time interval within which the ferry can safely cross the strait.\n\n![](https://cdn.vjudge.net.cn/35b69cfdbd76aaea80c318132bb285b0)\n\n   Figure 1: Sample Input 1. ", "inputFormat": "The first line of input contains six integers: the number of lanes $n$ ($1 \\leq n \\leq 10^5$), the width $w$ of each lane ($1 \\leq w \\leq 1\\, 000$), the speed $u$ of ships and the speed $v$ of the ferry ($1 \\leq u, v \\leq 100$), the ferry’s earliest start time $t_1$ and the ferry’s latest start time $t_2$ ($0 \\leq t_1 < t_2 \\leq 10^6$). All lengths are given in meters, all speeds are given in meters/second, and all times are given in seconds.\n\nEach of the next $n$ lines contains the data for one lane. Each line starts with either E or W, where E indicates that ships in this lane are eastbound and W indicates that ships in this lane are westbound. Next in the line is an integer $m_ i$, the number of ships in this lane ($0 \\leq m_ i \\leq 10^5$ for each $1 \\leq i \\leq n$). It is followed by $m_ i$ pairs of integers $l_{ij}$ and $p_{ij}$ ($1 \\leq l_{ij} \\leq 1\\, 000$ and $-10^6 \\leq p_{ij} \\leq 10^6$). The length of ship $j$ in lane $i$ is $l_{ij}$, and $p_{ij}$ is the position at time $0$ of its forward end, that is, its front in the direction it moves.\n\nShip positions within each lane are relative to the ferry’s crossing line. Negative positions are west of the crossing line and positive positions are east of it. Ships do not overlap or touch, and are sorted in increasing order of their positions. Lanes are ordered by increasing distance from the ferry’s starting point, which is just south of the first lane. There is no space between lanes. The total number of ships is at least $1$ and at most $10^5$.", "outputFormat": "Display the maximal value $d$ for which there is a time $s$ such that the ferry can start a crossing at any time $t$ with $s \\leq t \\leq s+d$. Additionally the crossing must not start before time $t_1$ and must start no later than time $t_2$. The output must have an absolute or relative error of at most $10^{-3}$. You may assume that there is a time interval with $d > 0.1$ seconds for the ferry to cross.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Ship Traffic", "background": "", "description": "从摩洛哥到西班牙穿越直布罗陀海峡的渡轮必须小心导航，以避免海峡内繁忙的船只交通。编写一个程序帮助渡轮船长找到海峡交通中最大的空隙，以便安全穿越。\n\n你的程序将使用如下简单模型。海峡有几条东西方向的平行航道。船只以相同的恒定速度向东或向西航行。同一航道上的所有船只都朝同一方向航行。卫星数据提供了每条航道上船只的位置。船只可能有不同的长度。船只在渡轮穿越时不会改变航道，也不会改变速度。\n\n渡轮等待适当的时间，当船只交通中有足够的空隙时，它就穿越海峡，沿南北方向以恒定速度航行。从渡轮进入航道的那一刻起，直到它离开航道的那一刻，该航道中的任何船只都不得碰触渡轮的穿越线。渡轮非常小，你可以忽略它的大小。下图展示了样例输入 1 的航道和船只。你的任务是找到渡轮可以安全穿越海峡的最大时间间隔。\n\n![](https://cdn.vjudge.net.cn/35b69cfdbd76aaea80c318132bb285b0)", "inputFormat": "输入的第一行包含六个整数：航道数量 $n$ ($1 \\leq n \\leq 10^5$)，每条航道的宽度 $w$ ($1 \\leq w \\leq 1,000$)，船只的速度 $u$ 和渡轮的速度 $v$ ($1 \\leq u, v \\leq 100$)，渡轮最早的出发时间 $t_1$ 和最晚的出发时间 $t_2$ ($0 \\leq t_1 < t_2 \\leq 10^6$)。所有长度以米为单位，所有速度以米/秒为单位，所有时间以秒为单位。\n\n接下来的 $n$ 行中，每行包含一个航道的数据。每行以 E 或 W 开头，其中 E 表示该航道上的船只向东航行，W 表示向西航行。接下来是一个整数 $m_i$，表示该航道上的船只数量 ($0 \\leq m_i \\leq 10^5$，对于每个 $1 \\leq i \\leq n$)。接下来是 $m_i$ 对整数 $l_{ij}$ 和 $p_{ij}$ ($1 \\leq l_{ij} \\leq 1,000$ 和 $-10^6 \\leq p_{ij} \\leq 10^6$)。航道 $i$ 上船只 $j$ 的长度为 $l_{ij}$，$p_{ij}$ 是其前端在时间 $0$ 的位置，即其移动方向上的前端。\n\n每条航道内的船只位置相对于渡轮的穿越线。负位置在穿越线的西侧，正位置在东侧。船只不重叠或接触，并按位置递增排序。航道按距离渡轮起点的距离递增排序，渡轮起点在第一条航道的正南方。航道之间没有空隙。船只总数至少为 $1$ 且最多为 $10^5$。", "outputFormat": "显示最大值 $d$，对于某个时间 $s$，渡轮可以在任何时间 $t$ 开始穿越，满足 $s \\leq t \\leq s+d$。此外，穿越不得早于时间 $t_1$ 开始，且不得晚于时间 $t_2$ 开始。输出的绝对或相对误差必须不超过 $10^{-3}$。你可以假设有一个时间间隔满足 $d > 0.1$ 秒，渡轮可以穿越。", "hint": "时间限制：3000 毫秒，内存限制：1048576 KB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2015\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6913", "type": "P", "difficulty": 6, "samples": [["2\n4 4\n2 6\n", "4 8\n6 20\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2015", "线段树", "ST 表", "快速傅里叶变换 FFT", "ICPC", "WF"], "title": "[ICPC 2015 WF] Tile Cutting", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/f8fpcjx7.png) \n\nYoussef is a Moroccan tile installer who specializes in mosaics like the one shown on the right. He has rectangular tiles of many dimensions at his disposal, and the dimensions of all his tiles are integer numbers of centimeters. When Youssef needs parallelogram-shaped tiles, he cuts them from his supply on hand. To make this work easier, he invented a tile cutting machine that superimposes a centimeter grid on the cutting surface to guide the cuts on the tiles. Due to machine limitations, aesthetic sensibilities, and Youssef’s dislike of wasted tiles, the following rules determine the possible cuts. \n\nThe rectangular tile to be cut must be positioned in the bottom left corner of the cutting surface and the edges must be aligned with the grid lines.\n\nThe cutting blade can cut along any line connecting two different grid points on the tile boundary as long as the points are on adjacent boundary edges.\n\nThe four corners of the resulting parallelogram tile must lie on the four sides of the original rectangular tile.\n\nNo edge of the parallelogram tile can lie along an edge of the rectangular tile.\n\nFigure 1 shows the eight different ways in which a parallelogram tile of area $4$ square centimeters can be cut out of a rectangular tile, subject to these restrictions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/figekxdx.png)\n\n   Figure 1: The eight different ways for cutting a parallelogram of area 4. \n\nYoussef needs to cut tiles of every area between $a_{\\text {lo}}$ and $a_{\\text {hi}}$. Now he wonders, for which area $a$ in this range can he cut the maximum number of different tiles?", "inputFormat": "The input consists of multiple test cases. The first line of input contains an integer $n$ ($1 \\le n \\le 500$), the number of test cases. The next $n$ lines each contain two integers $a_{\\text {lo}}, a_{\\text {hi}}$ ($1 \\le a_{\\text {lo}} \\le a_{\\text {hi}} \\le 500\\, 000$), the range of areas of the tiles.", "outputFormat": "For each test case $a_{\\text {lo}}$, $a_{\\text {hi}}$, display the value $a$ between $a_{\\text {lo}}$ and $a_{\\text {hi}}$ such that the number of possible ways to cut a parallelogram of area $a$ is maximized as well as the number of different ways $w$ in which such a parallelogram can be cut. If there are multiple possible values of $a$ display the smallest one.", "hint": "Time limit: 11000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Tile Cutting", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/f8fpcjx7.png) \n\nYoussef is a Moroccan tile installer who specializes in mosaics like the one shown on the right. He has rectangular tiles of many dimensions at his disposal, and the dimensions of all his tiles are integer numbers of centimeters. When Youssef needs parallelogram-shaped tiles, he cuts them from his supply on hand. To make this work easier, he invented a tile cutting machine that superimposes a centimeter grid on the cutting surface to guide the cuts on the tiles. Due to machine limitations, aesthetic sensibilities, and Youssef’s dislike of wasted tiles, the following rules determine the possible cuts. \n\nThe rectangular tile to be cut must be positioned in the bottom left corner of the cutting surface and the edges must be aligned with the grid lines.\n\nThe cutting blade can cut along any line connecting two different grid points on the tile boundary as long as the points are on adjacent boundary edges.\n\nThe four corners of the resulting parallelogram tile must lie on the four sides of the original rectangular tile.\n\nNo edge of the parallelogram tile can lie along an edge of the rectangular tile.\n\nFigure 1 shows the eight different ways in which a parallelogram tile of area $4$ square centimeters can be cut out of a rectangular tile, subject to these restrictions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/figekxdx.png)\n\n   Figure 1: The eight different ways for cutting a parallelogram of area 4. \n\nYoussef needs to cut tiles of every area between $a_{\\text {lo}}$ and $a_{\\text {hi}}$. Now he wonders, for which area $a$ in this range can he cut the maximum number of different tiles?", "inputFormat": "The input consists of multiple test cases. The first line of input contains an integer $n$ ($1 \\le n \\le 500$), the number of test cases. The next $n$ lines each contain two integers $a_{\\text {lo}}, a_{\\text {hi}}$ ($1 \\le a_{\\text {lo}} \\le a_{\\text {hi}} \\le 500\\, 000$), the range of areas of the tiles.", "outputFormat": "For each test case $a_{\\text {lo}}$, $a_{\\text {hi}}$, display the value $a$ between $a_{\\text {lo}}$ and $a_{\\text {hi}}$ such that the number of possible ways to cut a parallelogram of area $a$ is maximized as well as the number of different ways $w$ in which such a parallelogram can be cut. If there are multiple possible values of $a$ display the smallest one.", "hint": "Time limit: 11000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Tile Cutting", "background": "", "description": "Youssef 是一名专业贴瓷砖的修墙工，并且擅长用瓷砖贴出马赛克图案（如上图所示）。所有的瓷砖的尺寸长度均为整数，单位为 $cm$。在马赛克图案中，平行四边形是不可或缺的。因此，Youssef 会使用切割机，将矩形的瓷砖进行切割。在切割过程中，Youssef 选择使用网格辅助切割机进行切割（在瓷砖上布上 $cm$ 的网格方便切割）。\n\n切割过程有以下要求：\n\n1.\t可以从两个不同端点的连线切割（可以斜着切割）\n2.\t新平行四边形的四个角必须在矩形瓷砖的最外侧边上\n3.\t平行四边形的边不能与矩形的任意一条边边重叠\n\n现在给出切割的面积的两个边界值 $a_{lo}$ 和 $a_{hi}$，求出 Youssef 能够最多切割掉的小矩形瓷砖数量。", "inputFormat": "给出测试样例数量$n$($1≤n≤500$)。下面$n$行给出切割面积的两个边界值$a_{lo}$和$a_{hi}$（$1≤a_{lo}≤a_{hi}≤500 000$）", "outputFormat": "每行先输出平行四边形面积$a$，再输出小矩形最多切割数量$w$。如果$a$有不同值的时候，输出最小的即可。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6914", "type": "P", "difficulty": 7, "samples": [["4 5\n1 2\n2 3\n3 4\n1 4\n1 3\n", "1\n"], ["6 6\n1 2\n2 3\n1 3\n1 4\n2 5\n3 6\n", "1 3\n"]], "limits": {"time": [1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "ICPC", "WF"], "title": "[ICPC 2015 WF] Tours", "background": "", "description": "The Arca Carania Mountain national park is opening up for tourist traffic. The national park has a number of sites worth seeing and roads that connect pairs of sites. The park commissioners have put together a set of round tours in the park in which visitors can ride buses to view various sites. Each round tour starts at some site (potentially different sites for different tours), visits a number of other sites without repeating any, and then returns to where it started. At least 3 different sites are visited in each round tour. At least one round tour is possible in the national park.\n\nThe park commissioners have decided that, for any given road, all buses will be operated by a single company. The commissioners do not want to be accused of favoritism, so they want to be sure that each possible round tour in the park has exactly the same number of roads assigned to each bus company. They realize this may be difficult to achieve. Thus, they want to learn what numbers of bus companies allow for a valid assignment of companies to roads.\n\nConsider Sample Input 1, which is illustrated in Figure 1. There are a total of three round tours for these sites. Some company is assigned road 1-3. It must also be assigned some road on the round tour 1-2-3-4-1, say 2-3. But then it is assigned to two of the three roads on the round tour 1-2-3-1, and no other company can match this – so there can be no other companies. In Sample Input 2 there is only one round tour, so it is enough to assign the roads of this tour equally between companies.\n\n  ![](https://vj.z180.cn/17b3ab5defe058e1bc8649098ddaa63e?v=1603764959) \n\n   Figure 1: Sample Input 1. ", "inputFormat": "The first line of input contains two integers $n$ ($1 \\le n \\le 2\\, 000$), which is the number of sites in the park, and $m$ ($1 \\le m \\le 2\\, 000$), which is the number of roads between the sites. Following that are $m$ lines, each containing two integers $a_ i$ and $b_ i$ ($1 \\leq a_ i < b_ i \\leq n$), meaning the sites $a_ i$ and $b_ i$ are connected by a bidirectional road. No pair of sites is listed twice.", "outputFormat": "Display all integers $k$ such that it is possible to assign the roads to $k$ companies in the desired way. These integers should be in ascending order.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Tours", "background": "", "description": "The Arca Carania Mountain national park is opening up for tourist traffic. The national park has a number of sites worth seeing and roads that connect pairs of sites. The park commissioners have put together a set of round tours in the park in which visitors can ride buses to view various sites. Each round tour starts at some site (potentially different sites for different tours), visits a number of other sites without repeating any, and then returns to where it started. At least 3 different sites are visited in each round tour. At least one round tour is possible in the national park.\n\nThe park commissioners have decided that, for any given road, all buses will be operated by a single company. The commissioners do not want to be accused of favoritism, so they want to be sure that each possible round tour in the park has exactly the same number of roads assigned to each bus company. They realize this may be difficult to achieve. Thus, they want to learn what numbers of bus companies allow for a valid assignment of companies to roads.\n\nConsider Sample Input 1, which is illustrated in Figure 1. There are a total of three round tours for these sites. Some company is assigned road 1-3. It must also be assigned some road on the round tour 1-2-3-4-1, say 2-3. But then it is assigned to two of the three roads on the round tour 1-2-3-1, and no other company can match this – so there can be no other companies. In Sample Input 2 there is only one round tour, so it is enough to assign the roads of this tour equally between companies.\n\n  ![](https://vj.z180.cn/17b3ab5defe058e1bc8649098ddaa63e?v=1603764959) \n\n   Figure 1: Sample Input 1. ", "inputFormat": "The first line of input contains two integers $n$ ($1 \\le n \\le 2\\, 000$), which is the number of sites in the park, and $m$ ($1 \\le m \\le 2\\, 000$), which is the number of roads between the sites. Following that are $m$ lines, each containing two integers $a_ i$ and $b_ i$ ($1 \\leq a_ i < b_ i \\leq n$), meaning the sites $a_ i$ and $b_ i$ are connected by a bidirectional road. No pair of sites is listed twice.", "outputFormat": "Display all integers $k$ such that it is possible to assign the roads to $k$ companies in the desired way. These integers should be in ascending order.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Tours", "background": "", "description": "给定一张 $n$ 个点 $m$ 条边的无向图，你需要选择一个颜色种类数 $k$，然后用这 $k$ 种颜色给每条边染色，要求对于图中任意一个简单环，每种颜色的边的数量都相同。求所有可行的 $k$。\n\n保证图无重边，无自环。", "inputFormat": "第一行两个正整数 $n, m$（$1\\leq n, m\\leq 2\\times 10 ^ 3$）。\n\n接下来 $m$ 行，每行两个正整数 $x, y$（$1\\leq x < y \\leq n$），表示一条无向边。", "outputFormat": "一行按递增顺序输出所有可行的 $k$，用空格隔开。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6915", "type": "P", "difficulty": 6, "samples": [["2\n0.9 0.049999 0.05 0.000001\n", "1.457510\n"], ["20\n0.25 0.25 0.25 0.25\n", "40.000000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "Special Judge", "霍夫曼树", "ICPC", "WF"], "title": "[ICPC 2015 WF] Weather Report", "background": "", "description": " ![](https://cdn.luogu.com.cn/upload/image_hosting/xqo70y6n.png)\n\nYou have been hired by the Association for Climatological Measurement, a scientific organization interested in tracking global weather trends over a long period of time. Of course, this is no easy task. They have deployed many small devices around the world, designed to take periodic measurements of the local weather conditions. These are cheap devices with somewhat restricted capabilities. Every day they observe which of the four standard kinds of weather occurred: Sunny, Cloudy, Rainy, or Frogs. After every $n$ of these observations have been made, the results are reported to the main server for analysis. However, the massive number of devices has caused the available communication bandwidth to be overloaded. The Association needs your help to come up with a method of compressing these reports into fewer bits. \n\nFor a particular device’s location, you may assume that the weather each day is an independent random event, and you are given the predicted probabilities of the four possible weather types. Each of the $4^ n$ possible weather reports for a device must be encoded as a unique sequence of bits, such that no sequence is a prefix of any other sequence (an important property, or else the server would not know when each sequence ends). The goal is to use an encoding that minimizes the expected number of transmitted bits.", "inputFormat": "The first line of input contains an integer $1 \\le n \\le 20$, the number of observations that go into each report. The second line contains four positive floating-point numbers, $p_{\\text {sunny}}$, $p_{\\text {cloudy}}$, $p_{\\text {rainy}}$, and $p_{\\text {frogs}}$, representing the respective weather probabilities. These probabilities have at most 6 digits after the decimal point and sum to 1.", "outputFormat": "Display the minimum expected number of bits in the encoding of a report, with an absolute or relative error of at most $10^{-4}$.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Weather Report", "background": "", "description": " ![](https://cdn.luogu.com.cn/upload/image_hosting/xqo70y6n.png)\n\nYou have been hired by the Association for Climatological Measurement, a scientific organization interested in tracking global weather trends over a long period of time. Of course, this is no easy task. They have deployed many small devices around the world, designed to take periodic measurements of the local weather conditions. These are cheap devices with somewhat restricted capabilities. Every day they observe which of the four standard kinds of weather occurred: Sunny, Cloudy, Rainy, or Frogs. After every $n$ of these observations have been made, the results are reported to the main server for analysis. However, the massive number of devices has caused the available communication bandwidth to be overloaded. The Association needs your help to come up with a method of compressing these reports into fewer bits. \n\nFor a particular device’s location, you may assume that the weather each day is an independent random event, and you are given the predicted probabilities of the four possible weather types. Each of the $4^ n$ possible weather reports for a device must be encoded as a unique sequence of bits, such that no sequence is a prefix of any other sequence (an important property, or else the server would not know when each sequence ends). The goal is to use an encoding that minimizes the expected number of transmitted bits.", "inputFormat": "The first line of input contains an integer $1 \\le n \\le 20$, the number of observations that go into each report. The second line contains four positive floating-point numbers, $p_{\\text {sunny}}$, $p_{\\text {cloudy}}$, $p_{\\text {rainy}}$, and $p_{\\text {frogs}}$, representing the respective weather probabilities. These probabilities have at most 6 digits after the decimal point and sum to 1.", "outputFormat": "Display the minimum expected number of bits in the encoding of a report, with an absolute or relative error of at most $10^{-4}$.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Weather Report", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/xqo70y6n.png)\n\n你被气候测量协会雇佣，这是一家对长期跟踪全球天气趋势感兴趣的科学组织。当然，这不是一项简单的任务。他们在世界各地部署了许多小型设备，旨在定期测量当地的天气状况。这些设备价格低廉，功能有所限制。每天它们会观察四种标准天气中的哪一种发生：晴天、多云、雨天或青蛙雨。在每进行 $n$ 次这样的观察后，结果会被报告给主服务器进行分析。然而，设备数量庞大导致可用通信带宽超载。协会需要你的帮助来想出一种方法，将这些报告压缩成更少的比特。\n\n对于某个设备的位置，你可以假设每天的天气是一个独立的随机事件，并且你会得到四种可能天气类型的预测概率。设备的每一个 $4^n$ 种可能的天气报告必须被编码为一个唯一的比特序列，且没有序列是其他序列的前缀（这是一个重要的属性，否则服务器将不知道每个序列何时结束）。目标是使用一种编码，最小化传输比特的期望数量。", "inputFormat": "输入的第一行包含一个整数 $1 \\le n \\le 20$，表示每个报告中的观察次数。第二行包含四个正浮点数，$p_{\\text {sunny}}$，$p_{\\text {cloudy}}$，$p_{\\text {rainy}}$ 和 $p_{\\text {frogs}}$，表示各自的天气概率。这些概率小数点后最多有 6 位数字，并且总和为 1。", "outputFormat": "显示报告编码中比特的最小期望数量，绝对误差或相对误差最多为 $10^{-4}$。", "hint": "时间限制：1000 毫秒，内存限制：1048576 KB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2015。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6916", "type": "P", "difficulty": 6, "samples": [["320 200\nOPEN 50 50 10 10\nOPEN 70 55 10 10\nOPEN 90 50 10 10\nRESIZE 55 55 40 40\nRESIZE 55 55 15 15\nMOVE 55 55 40 0\nCLOSE 55 55\nCLOSE 110 60\nMOVE 95 55 0 -100\n", "Command 4: RESIZE - window does not fit\nCommand 7: CLOSE - no window at given position\nCommand 9: MOVE - moved 50 instead of 100\n2 window(s):\n90 0 15 15\n115 50 10 10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2015", "ICPC", "WF"], "title": "[ICPC 2015 WF] Window Manager", "background": "", "description": "The past few years have seen a revolution in user interface technology. For many years, keyboards and mice were the tools used to interact with computers. But with the introduction of smart phones and tablets, people are increasingly using their computers by tapping and moving their fingers on the screen. Naturally this has led to new paradigms in user interface design. One important principle is that objects on the display obey “physical” laws. In this problem, you will see an example of this.\n\nYou have been hired to build a simulator for the window manager to be used in the next generation of smart phones from Advanced Cellular Manufacturers (ACM). Each phone they produce will have a rectangular screen that fully displays zero or more rectangular windows. That is, no window exceeds the boundaries of the screen or overlaps any other window. The simulator must support the following commands.\n\nOPEN $x$ $y$ $w$ $h$ — open a new window with top-left corner coordinates $(x,y)$, width $w$ pixels and height $h$ pixels.\n\nCLOSE $x$ $y$ — close an open window that includes the pixel at $(x,y)$. This allows a user to tap anywhere on a window to close it.\n\nRESIZE $x$ $y$ $w$ $h$ — set the dimensions of the window that includes the pixel at $(x,y)$ to width $w$ and height $h$. The top-left corner of the window does not move.\n\nMOVE $x$ $y$ $d_ x$ $d_ y$ — move the window that includes the pixel at $(x,y)$. The movement is either $d_ x$ pixels in the horizontal direction or $d_ y$ pixels in the vertical direction. At most one of $d_ x$ and $d_ y$ will be non-zero.\n\nThe OPEN and RESIZE commands succeed only if the resulting window does not overlap any other windows and does not extend beyond the screen boundaries. The MOVE command will move the window by as many of the requested pixels as possible. For example, if $d_ x$ is 30 but the window can move only 15 pixels to the right, then it will move 15 pixels.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3zw4uj2x.png)\n\n   Figure 1: MOVE example \n\nACM is particularly proud of the MOVE command. A window being moved might “bump into” another window. In this case, the first window will push the second window in the same direction as far as appropriate, exactly as if the windows were physical objects. This behavior can cascade – a moving window might encounter additional windows which are also pushed along as necessary. Figure 1 shows an example with three windows, where window A is moved to the right, pushing the other two along.", "inputFormat": "The first line of input contains two positive integers $x_{\\max }$ and $y_{\\max }$, the horizontal and vertical dimensions of the screen, measured in pixels. Each is at most $10^9$ (ACM is planning on building displays with very high resolution). The top-left pixel of the screen has coordinates $(0,0)$. Each of the following lines contains a command as described above. One or more spaces separate the command name and the parameters from each other. The command parameters are integers that satisfy these conditions: $0 \\leq x < x_{\\max }$, $0 \\leq y < y_{\\max }$, $1 \\leq w,h \\leq 10^9$, and $|d_ x|,|d_ y| \\leq 10^9$. There will be at most 256 commands.", "outputFormat": "The output must follow the format illustrated in the sample output below.\n\nSimulate the commands in the order they appear in the input. If any errors are detected during a command’s simulation, display the command number, command name, and the first appropriate message from the following list, and ignore the results of simulating that command (except as noted).\n\nno window at given position — for the CLOSE, RESIZE, and MOVE commands — if there is no window that includes the pixel at the specified position.\n\nwindow does not fit — for the OPEN and RESIZE commands — if the resulting window would overlap another window or extend beyond the screen boundaries.\n\nmoved $d’$ instead of $d$ — for the MOVE command — if the command asked to move a window $d$ pixels, but it could only move $d’$ pixels before requiring a window to move beyond the screen boundaries. The values $d$ and $d’$ are the absolute number of pixels requested and moved, respectively. The window is still moved in this case, but only for the smaller distance.\n\nAfter all commands have been simulated and any error messages have been displayed, indicate the number of windows that are still open. Then for each open window, in the same order that they were opened, display the coordinates of the top-left corner $(x,y)$, the width, and the height.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Window Manager", "background": "", "description": "The past few years have seen a revolution in user interface technology. For many years, keyboards and mice were the tools used to interact with computers. But with the introduction of smart phones and tablets, people are increasingly using their computers by tapping and moving their fingers on the screen. Naturally this has led to new paradigms in user interface design. One important principle is that objects on the display obey “physical” laws. In this problem, you will see an example of this.\n\nYou have been hired to build a simulator for the window manager to be used in the next generation of smart phones from Advanced Cellular Manufacturers (ACM). Each phone they produce will have a rectangular screen that fully displays zero or more rectangular windows. That is, no window exceeds the boundaries of the screen or overlaps any other window. The simulator must support the following commands.\n\nOPEN $x$ $y$ $w$ $h$ — open a new window with top-left corner coordinates $(x,y)$, width $w$ pixels and height $h$ pixels.\n\nCLOSE $x$ $y$ — close an open window that includes the pixel at $(x,y)$. This allows a user to tap anywhere on a window to close it.\n\nRESIZE $x$ $y$ $w$ $h$ — set the dimensions of the window that includes the pixel at $(x,y)$ to width $w$ and height $h$. The top-left corner of the window does not move.\n\nMOVE $x$ $y$ $d_ x$ $d_ y$ — move the window that includes the pixel at $(x,y)$. The movement is either $d_ x$ pixels in the horizontal direction or $d_ y$ pixels in the vertical direction. At most one of $d_ x$ and $d_ y$ will be non-zero.\n\nThe OPEN and RESIZE commands succeed only if the resulting window does not overlap any other windows and does not extend beyond the screen boundaries. The MOVE command will move the window by as many of the requested pixels as possible. For example, if $d_ x$ is 30 but the window can move only 15 pixels to the right, then it will move 15 pixels.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3zw4uj2x.png)\n\n   Figure 1: MOVE example \n\nACM is particularly proud of the MOVE command. A window being moved might “bump into” another window. In this case, the first window will push the second window in the same direction as far as appropriate, exactly as if the windows were physical objects. This behavior can cascade – a moving window might encounter additional windows which are also pushed along as necessary. Figure 1 shows an example with three windows, where window A is moved to the right, pushing the other two along.", "inputFormat": "The first line of input contains two positive integers $x_{\\max }$ and $y_{\\max }$, the horizontal and vertical dimensions of the screen, measured in pixels. Each is at most $10^9$ (ACM is planning on building displays with very high resolution). The top-left pixel of the screen has coordinates $(0,0)$. Each of the following lines contains a command as described above. One or more spaces separate the command name and the parameters from each other. The command parameters are integers that satisfy these conditions: $0 \\leq x < x_{\\max }$, $0 \\leq y < y_{\\max }$, $1 \\leq w,h \\leq 10^9$, and $|d_ x|,|d_ y| \\leq 10^9$. There will be at most 256 commands.", "outputFormat": "The output must follow the format illustrated in the sample output below.\n\nSimulate the commands in the order they appear in the input. If any errors are detected during a command’s simulation, display the command number, command name, and the first appropriate message from the following list, and ignore the results of simulating that command (except as noted).\n\nno window at given position — for the CLOSE, RESIZE, and MOVE commands — if there is no window that includes the pixel at the specified position.\n\nwindow does not fit — for the OPEN and RESIZE commands — if the resulting window would overlap another window or extend beyond the screen boundaries.\n\nmoved $d’$ instead of $d$ — for the MOVE command — if the command asked to move a window $d$ pixels, but it could only move $d’$ pixels before requiring a window to move beyond the screen boundaries. The values $d$ and $d’$ are the absolute number of pixels requested and moved, respectively. The window is still moved in this case, but only for the smaller distance.\n\nAfter all commands have been simulated and any error messages have been displayed, indicate the number of windows that are still open. Then for each open window, in the same order that they were opened, display the coordinates of the top-left corner $(x,y)$, the width, and the height.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Window Manager", "background": null, "description": "过去几年，用户界面技术发生了一场革命。多年来，键盘和鼠标一直是与计算机交互的工具。但随着智能手机和平板电脑的推出，人们越来越多地通过在屏幕上敲击和移动手指来使用电脑。这自然导致了用户界面设计的新范式。一个重要的原则是显示器上的对象遵守“物理”定律。在这个问题中，您将看到一个例子。\n\n您已被聘请为 window manager 构建一个模拟器，用于高级手机制造商（Advanced Cellular Manufacturers，ACM）的下一代智能手机。他们生产的每款手机都有一个矩形屏幕，可以完全显示零个或多个矩形窗口。也就是说，没有窗口超出屏幕边界或与任何其他窗口重叠。模拟器必须支持以下命令。\n\n`OPEN x y w h` —— 打开一个具有左上角坐标 $(x,y)$、宽度 $w$ 像素和高度 $h$ 像素的新窗口。\n\n`CLOSE x y` —— 关闭一个打开的窗口，其中包括 $(x,y)$ 处的像素。这允许用户点击窗口上的任意位置以关闭窗口。\n\n`RESIZE x y w h` —— 将包含 $(x,y)$ 处像素的窗口尺寸设置为宽度 $w$  像素和高度 $h$  像素。窗口的左上角不移动。\n\n`MOVE x y dx dy` —— 移动包含 $(x,y)$ 处像素的窗口。移动是水平方向上的 $dx$ 像素或垂直方向上的 $dy$ 像素。$dx$ 和 $dy$ 中最多有一个为非零。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3zw4uj2x.png)\n\n _（图 1：移动示例）_ \n\nACM 对 `MOVE` 命令特别自豪。正在移动的窗口可能会“撞上”另一个窗口。在这种情况下，第一个窗口将以相同的方向尽可能远地推动第二个窗口，就像这些窗口是物理对象一样。此行为可能会层叠 —— 移动的窗口可能会遇到其他窗口，这些窗口也会根据需要被推送。图 $1$ 显示了一个有三个窗口的示例，其中窗口 A 向右移动，推动其他两个窗口。", "inputFormat": "第一行输入包含两个正整数 $x_{\\max}$ 和 $y_{\\max}$，即屏幕的水平和垂直尺寸，以像素为单位。\n\n每个显示器的最大分辨率为 $10^9$（ACM 正计划建造具有极高分辨率的显示器）。\n\n屏幕左上角的像素具有坐标 $(0,0)$。\n\n下面的每一行都包含一个如上所述的命令。\n\n命令名和参数之间用一个或多个空格分隔。\n\n命令参数是满足这些条件的整数：\n\n- $0 \\le x < x_{\\max}$；\n- $0 \\le y < y_{\\max}$；\n- $1 \\le w,h \\le 10^9$；\n- $-10^9 \\le dx,dy \\le 10^9$；\n- $dx \\cdot dy = 0$。\n\n最多有 $256$ 条命令。", "outputFormat": "输出必须遵循以下示例输出中所示的格式。\n\n按照命令在输入中出现的顺序模拟命令。如果在命令模拟过程中检测到任何错误，请显示命令编号、命令名称和下表中的第一条适当消息，并忽略模拟该命令的结果（除非另有说明）。\n\n如果在指定位置没有包含像素的窗口，则在给定位置没有窗口（用于关闭、调整大小和移动命令）。\n\n如果生成的窗口与另一个窗口重叠或超出屏幕边界，则窗口不适用于“打开”和“调整大小”命令。\n\n如果命令要求移动窗口 $d$ 个像素，则移动 $d'$ 而不是 $d$ —— 对于 `MOVE` 命令，但在要求窗口移动到屏幕边界之外之前，它只能移动 $d'$ 个像素。值 $d$ 和 $d'$ 分别是请求和移动的像素的绝对数量。在这种情况下，窗口仍会移动，但仅移动较小的距离。\n\n模拟所有命令并显示任何错误消息后，指示仍打开的窗口数。然后，对于每个打开的窗口，按照打开的顺序显示左上角 $(x,y)$ 的坐标、宽度和高度。", "hint": "时间限制：1000 毫秒，内存限制：1048576 kB。\n\n该题出自：2015 年国际大学生编程大赛（ACM-ICPC）世界总决赛。", "locale": "zh-CN"}}}
{"pid": "P6917", "type": "P", "difficulty": 5, "samples": [["6 5\n2 1 6 3 5 3\n1 2 5 3 5\n", "1\n\n"], ["6 4\n2 1 6 3 5 3\n1 2 5 3\n", "forever\n\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2016", "ICPC", "WF"], "title": "[ICPC 2016 WF] Balanced Diet", "background": "", "description": "Every day, Danny buys one sweet from the candy store and eats it. The store has $m$ types of sweets, numbered from $1$ to $m$. Danny knows that a balanced diet is important and is applying this concept to his sweet purchasing. To each sweet type $i$, he has assigned a target fraction, which is a real number $f_ i$ ($0 < f_ i \\le 1$). He wants the fraction of sweets of type $i$ among all sweets he has eaten to be roughly equal to $f_ i$. To be more precise, let $s_ i$ denote the number of sweets of type $i$ that Danny has eaten, and let $n = \\sum _{i=1}^ m s_ i$. We say the set of sweets is balanced if for every $i$ we have\n\n\\[ n f_ i - 1 < s_ i < n f_ i + 1. \\] \n\nDanny has been buying and eating sweets for a while and during this entire time the set of sweets has been balanced. He is now wondering how many more sweets he can buy while still fulfilling this condition. Given the target fractions $f_ i$ and the sequence of sweets he has eaten so far, determine how many more sweets he can buy and eat so that at any time the set of sweets is balanced.", "inputFormat": "The input consists of three lines. The first line contains two integers $m$ ($1 \\le m \\le 10^5$), which is the number of types of sweets, and $k$ ($0 \\le k \\le 10^5$), which is the number of sweets Danny has already eaten.\n\nThe second line contains $m$ positive integers $a_1, \\ldots , a_ m$. These numbers are proportional to $f_1, \\ldots , f_ m$, that is, $\\displaystyle f_ i = \\frac{a_ i}{\\sum _{j = 1}^ m a_ j}$. It is guaranteed that the sum of all $a_ j$ is no larger than $10^5$.\n\nThe third line contains $k$ integers $b_1, \\ldots , b_ k$ ($1 \\le b_ i \\le m$), where each $b_ i$ denotes the type of sweet Danny bought and ate on the $i^\\text {th}$ day. It is guaranteed that every prefix of this sequence (including the whole sequence) is balanced.", "outputFormat": "Display the maximum number of additional sweets that Danny can buy and eat while keeping his diet continuously balanced. If there is no upper limit on the number of sweets, display the word forever.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Balanced Diet", "background": "", "description": "Every day, Danny buys one sweet from the candy store and eats it. The store has $m$ types of sweets, numbered from $1$ to $m$. Danny knows that a balanced diet is important and is applying this concept to his sweet purchasing. To each sweet type $i$, he has assigned a target fraction, which is a real number $f_ i$ ($0 < f_ i \\le 1$). He wants the fraction of sweets of type $i$ among all sweets he has eaten to be roughly equal to $f_ i$. To be more precise, let $s_ i$ denote the number of sweets of type $i$ that Danny has eaten, and let $n = \\sum _{i=1}^ m s_ i$. We say the set of sweets is balanced if for every $i$ we have\n\n\\[ n f_ i - 1 < s_ i < n f_ i + 1. \\] \n\nDanny has been buying and eating sweets for a while and during this entire time the set of sweets has been balanced. He is now wondering how many more sweets he can buy while still fulfilling this condition. Given the target fractions $f_ i$ and the sequence of sweets he has eaten so far, determine how many more sweets he can buy and eat so that at any time the set of sweets is balanced.", "inputFormat": "The input consists of three lines. The first line contains two integers $m$ ($1 \\le m \\le 10^5$), which is the number of types of sweets, and $k$ ($0 \\le k \\le 10^5$), which is the number of sweets Danny has already eaten.\n\nThe second line contains $m$ positive integers $a_1, \\ldots , a_ m$. These numbers are proportional to $f_1, \\ldots , f_ m$, that is, $\\displaystyle f_ i = \\frac{a_ i}{\\sum _{j = 1}^ m a_ j}$. It is guaranteed that the sum of all $a_ j$ is no larger than $10^5$.\n\nThe third line contains $k$ integers $b_1, \\ldots , b_ k$ ($1 \\le b_ i \\le m$), where each $b_ i$ denotes the type of sweet Danny bought and ate on the $i^\\text {th}$ day. It is guaranteed that every prefix of this sequence (including the whole sequence) is balanced.", "outputFormat": "Display the maximum number of additional sweets that Danny can buy and eat while keeping his diet continuously balanced. If there is no upper limit on the number of sweets, display the word forever.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Balanced Diet", "background": "", "description": "每天，Danny 都会从糖果店买一颗糖并吃掉它。糖果店中有 $m$ 种糖，编号为 $1 \\dots m$ 。\n\nDanny 知道均衡饮食很重要，他正在尝试在购买糖果时有一个均衡的饮食。因此他给每种糖 $i$ 分配了一个目标分数 $f_i (0 \\le f_i \\le 1, f_i$ 为一个实数 $) $, 。他希望他所吃的所有糖中，第 $i$ 种糖的数量占比大概为 $f_i$ 。\n\n准确的说， 令 $s_ i$ 表示 Danny 已经吃掉的第 $i$ 种糖的数量,  $n = \\sum _{i=1}^ m s_ i$, 我们认为一种吃糖的方法是均衡的仅当对于所有的 $i$，满足：\n\n$$n f_ i - 1 < s_ i < n f_ i + 1$$\n\nDanny 已经购买并吃掉了一些糖，并且他保证每个前缀的饮食都是均衡的。他想知道在保证每个前缀均衡饮食的条件下，他最多还能吃多少颗糖。\n\n给定目标分数 $f_i$\n和他已经吃过的糖果序列，请你确定在保证每个前缀均衡饮食的条件下，Danny 最多还能购买并吃掉多少颗糖果。", "inputFormat": "输入包含三行。第一行包括两个整数 m $1 \\le m \\le 10^5$ 表示糖果的种类, $k(0 \\le k \\le 10^5)$ 表示 Danny 已经吃掉的糖果数量。\n\n第二行包括 $m$ 个正整数 $a_1 \\dots a_m$, 有   $ \\displaystyle f_ i = \\frac{a_ i}{\\sum _{j = 1}^ m a_ j}$, 保证\n$\\sum_{i=1}^m a_i \\le 10^5$ 。\n\n第三行包括 $k$ 个正整数 $b_1 \\dots b_k (1 \\le b_i \\le m)$, 表示 Danny 在第 $i$ 天购买并吃掉的糖的种类。保证序列的每个前缀（包括整个序列）是饮食均衡的。", "outputFormat": "输出在保证每个前缀饮食均衡的条件下，Danny 最多还能购买并吃掉多少颗糖。\n\n如果糖果的数量没有上限（即 Danny 能一直买下去），输出 `forever`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6918", "type": "P", "difficulty": 6, "samples": [["5 4 2 10\n5 2 1\n2 5 1\n3 5 5\n4 5 0\n1 5 1\n2 3 1\n3 2 5\n2 4 5\n2 1 1\n3 4 2\n", "13\n"], ["5 4 2 10\n5 2 1\n2 5 1\n3 5 5\n4 5 10\n1 5 1\n2 3 1\n3 2 5\n2 4 5\n2 1 1\n3 4 2\n", "24\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "四边形不等式", "ICPC", "WF"], "title": "[ICPC 2016 WF] Branch Assignment", "background": "", "description": "The Innovative Consumer Products Company (ICPC) is planning to start a top-secret project. This project consists of $s$ subprojects. There will be $b \\ge s$ branches of ICPC involved in this project and ICPC wants to assign each branch to one of the subprojects. In other words, the branches will form $s$ disjoint groups, with each group in charge of a subproject.\n\nAt the end of each month, each branch will send a message to every other branch in its group (a different message to each branch). ICPC has a particular protocol for its communications. Each branch $i$ has a secret key $k_ i$ known only to the branch and the ICPC headquarters. Assume branch $i$ wants to send a message to branch $j$. Branch $i$ encrypts its message with its key $k_ i$. A trusted courier picks up this message from this branch and delivers it to the ICPC headquarters. Headquarters decrypts the message with key $k_ i$ and re-encrypts it with key $k_ j$. The courier then delivers this newly encrypted message to branch $j$, which decrypts it with its own key $k_ j$. For security reasons, a courier can carry only one message at a time.\n\nGiven a road network and the locations of branches and the headquarters in this network, your task is to determine the minimum total distance that the couriers will need to travel to deliver all the end-of-month messages, over all possible assignments of branches to subprojects.", "inputFormat": "The first line of input contains four integers $n$, $b$, $s$, and $r$, where $n$ ($2 \\le n \\le 5\\, 000$) is the number of intersections, $b$ ($1 \\le b \\le n-1$) is the number of branches, $s$ ($1 \\le s \\le b$) is the number of subprojects, and $r$ ($1 \\le r \\le 50\\, 000$) is the number of roads. The intersections are numbered from $1$ through $n$. The branches are at intersections $1$ through $b$, and the headquarters is at intersection $b + 1$. Each of the next $r$ lines contains three integers $u$, $v$, and $\\ell $, indicating a one-way road from intersection $u$ to a different intersection $v$ ($1 \\leq u,v \\leq n$) of length $\\ell $ ($0 \\leq \\ell \\leq 10\\, 000$). No ordered pair $(u,v)$ appears more than once, and from any intersection it is possible to reach every other intersection.", "outputFormat": "Display the minimum total distance that the couriers will need to travel.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Branch Assignment", "background": "", "description": "The Innovative Consumer Products Company (ICPC) is planning to start a top-secret project. This project consists of $s$ subprojects. There will be $b \\ge s$ branches of ICPC involved in this project and ICPC wants to assign each branch to one of the subprojects. In other words, the branches will form $s$ disjoint groups, with each group in charge of a subproject.\n\nAt the end of each month, each branch will send a message to every other branch in its group (a different message to each branch). ICPC has a particular protocol for its communications. Each branch $i$ has a secret key $k_ i$ known only to the branch and the ICPC headquarters. Assume branch $i$ wants to send a message to branch $j$. Branch $i$ encrypts its message with its key $k_ i$. A trusted courier picks up this message from this branch and delivers it to the ICPC headquarters. Headquarters decrypts the message with key $k_ i$ and re-encrypts it with key $k_ j$. The courier then delivers this newly encrypted message to branch $j$, which decrypts it with its own key $k_ j$. For security reasons, a courier can carry only one message at a time.\n\nGiven a road network and the locations of branches and the headquarters in this network, your task is to determine the minimum total distance that the couriers will need to travel to deliver all the end-of-month messages, over all possible assignments of branches to subprojects.", "inputFormat": "The first line of input contains four integers $n$, $b$, $s$, and $r$, where $n$ ($2 \\le n \\le 5\\, 000$) is the number of intersections, $b$ ($1 \\le b \\le n-1$) is the number of branches, $s$ ($1 \\le s \\le b$) is the number of subprojects, and $r$ ($1 \\le r \\le 50\\, 000$) is the number of roads. The intersections are numbered from $1$ through $n$. The branches are at intersections $1$ through $b$, and the headquarters is at intersection $b + 1$. Each of the next $r$ lines contains three integers $u$, $v$, and $\\ell $, indicating a one-way road from intersection $u$ to a different intersection $v$ ($1 \\leq u,v \\leq n$) of length $\\ell $ ($0 \\leq \\ell \\leq 10\\, 000$). No ordered pair $(u,v)$ appears more than once, and from any intersection it is possible to reach every other intersection.", "outputFormat": "Display the minimum total distance that the couriers will need to travel.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Branch Assignment", "background": "", "description": "创新消费品公司（ICPC）计划启动一个绝密项目。该项目由 $s$ 个子项目组成。将有 $b \\ge s$ 个 ICPC 的分支机构参与此项目，ICPC 希望将每个分支机构分配给一个子项目。换句话说，这些分支机构将形成 $s$ 个不相交的组，每个组负责一个子项目。\n\n每个月底，每个分支机构将向其组内的每个其他分支机构发送一条消息（每个分支机构接收不同的消息）。ICPC 有一个特定的通信协议。每个分支机构 $i$ 有一个只有该分支机构和 ICPC 总部知道的密钥 $k_i$。假设分支机构 $i$ 想要向分支机构 $j$ 发送消息。分支机构 $i$ 用其密钥 $k_i$ 加密消息。一个可信的信使从该分支机构取走消息并将其交付给 ICPC 总部。总部用密钥 $k_i$ 解密消息，并用密钥 $k_j$ 重新加密。然后信使将这个新加密的消息交付给分支机构 $j$，分支机构 $j$ 用其自己的密钥 $k_j$ 解密。出于安全原因，信使一次只能携带一条消息。\n\n给定一个道路网络以及分支机构和总部在此网络中的位置，你的任务是确定信使在所有可能的分支机构到子项目的分配中，传递所有月底消息所需的最小总距离。", "inputFormat": "输入的第一行包含四个整数 $n$、$b$、$s$ 和 $r$，其中 $n$ ($2 \\le n \\le 5\\, 000$) 是交叉路口的数量，$b$ ($1 \\le b \\le n-1$) 是分支机构的数量，$s$ ($1 \\le s \\le b$) 是子项目的数量，$r$ ($1 \\le r \\le 50\\, 000$) 是道路的数量。交叉路口编号从 $1$ 到 $n$。分支机构位于交叉路口 $1$ 到 $b$，总部位于交叉路口 $b + 1$。接下来的 $r$ 行中的每一行包含三个整数 $u$、$v$ 和 $\\ell$，表示从交叉路口 $u$ 到不同交叉路口 $v$ ($1 \\leq u,v \\leq n$) 的一条单向道路，长度为 $\\ell$ ($0 \\leq \\ell \\leq 10\\, 000$)。没有有序对 $(u,v)$ 会出现多次，并且从任何交叉路口都可以到达每个其他交叉路口。", "outputFormat": "输出信使需要行驶的最小总距离。", "hint": "时间限制：2000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2016。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6919", "type": "P", "difficulty": 4, "samples": [["5 3\n2 7 1\n3 1 4\n1 5 9\n2 6 5\n9 7 3\n", "4\n"], ["3 4\n3 1 2 40000\n3 4 2 1\n33 42 17 23\n", "2\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "ICPC", "WF"], "title": "[ICPC 2016 WF] Ceiling Function", "background": "", "description": "Advanced Ceiling Manufacturers (ACM) is analyzing the properties of its new series of Incredibly Collapse-Proof Ceilings (ICPCs). An ICPC consists of $n$ layers of material, each with a different value of collapse resistance (measured as a positive integer). The analysis ACM wants to run will take the collapse-resistance values of the layers, store them in a binary search tree, and check whether the shape of this tree in any way correlates with the quality of the whole construction. Because, well, why should it not?\n\nTo be precise, ACM takes the collapse-resistance values for the layers, ordered from the top layer to the bottom layer, and inserts them one-by-one into a tree. The rules for inserting a value $v$ are:\n\nIf the tree is empty, make $v$ the root of the tree.\n\nIf the tree is not empty, compare $v$ with the root of the tree. If $v$ is smaller, insert $v$ into the left subtree of the root, otherwise insert $v$ into the right subtree.\n\nACM has a set of ceiling prototypes it wants to analyze by trying to collapse them. It wants to take each group of ceiling prototypes that have trees of the same shape and analyze them together.\n\nFor example, assume ACM is considering five ceiling prototypes with three layers each, as described by Sample Input 1 and shown in Figure 1. Notice that the first prototype’s top layer has collapse-resistance value 2, the middle layer has value 7, and the bottom layer has value 1. The second prototype has layers with collapse-resistance values of 3, 1, and 4 – and yet these two prototypes induce the same tree shape, so ACM will analyze them together.\n\nGiven a set of prototypes, your task is to determine how many different tree shapes they induce.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xvdteesl.png)\n\n   Figure 1: The four tree shapes induced by the ceiling prototypes in Sample Input 1. ", "inputFormat": "The first line of the input contains two integers $n$ ($1 \\le n \\le 50$), which is the number of ceiling prototypes to analyze, and $k$ ($1 \\le k \\le 20$), which is the number of layers in each of the prototypes.\n\nThe next $n$ lines describe the ceiling prototypes. Each of these lines contains $k$ distinct integers (between $1$ and $10^6$, inclusive), which are the collapse-resistance values of the layers in a ceiling prototype, ordered from top to bottom.", "outputFormat": "Display the number of different tree shapes.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Ceiling Function", "background": "", "description": "Advanced Ceiling Manufacturers (ACM) is analyzing the properties of its new series of Incredibly Collapse-Proof Ceilings (ICPCs). An ICPC consists of $n$ layers of material, each with a different value of collapse resistance (measured as a positive integer). The analysis ACM wants to run will take the collapse-resistance values of the layers, store them in a binary search tree, and check whether the shape of this tree in any way correlates with the quality of the whole construction. Because, well, why should it not?\n\nTo be precise, ACM takes the collapse-resistance values for the layers, ordered from the top layer to the bottom layer, and inserts them one-by-one into a tree. The rules for inserting a value $v$ are:\n\nIf the tree is empty, make $v$ the root of the tree.\n\nIf the tree is not empty, compare $v$ with the root of the tree. If $v$ is smaller, insert $v$ into the left subtree of the root, otherwise insert $v$ into the right subtree.\n\nACM has a set of ceiling prototypes it wants to analyze by trying to collapse them. It wants to take each group of ceiling prototypes that have trees of the same shape and analyze them together.\n\nFor example, assume ACM is considering five ceiling prototypes with three layers each, as described by Sample Input 1 and shown in Figure 1. Notice that the first prototype’s top layer has collapse-resistance value 2, the middle layer has value 7, and the bottom layer has value 1. The second prototype has layers with collapse-resistance values of 3, 1, and 4 – and yet these two prototypes induce the same tree shape, so ACM will analyze them together.\n\nGiven a set of prototypes, your task is to determine how many different tree shapes they induce.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xvdteesl.png)\n\n   Figure 1: The four tree shapes induced by the ceiling prototypes in Sample Input 1. ", "inputFormat": "The first line of the input contains two integers $n$ ($1 \\le n \\le 50$), which is the number of ceiling prototypes to analyze, and $k$ ($1 \\le k \\le 20$), which is the number of layers in each of the prototypes.\n\nThe next $n$ lines describe the ceiling prototypes. Each of these lines contains $k$ distinct integers (between $1$ and $10^6$, inclusive), which are the collapse-resistance values of the layers in a ceiling prototype, ordered from top to bottom.", "outputFormat": "Display the number of different tree shapes.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Ceiling Function", "background": "", "description": "高级天花板制造商（ACM）正在分析其新系列的极其防坍塌天花板（ICPC）的特性。一个 ICPC 由 $n$ 层材料组成，每层都有不同的抗坍塌值（以正整数表示）。ACM 想要进行的分析将把各层的抗坍塌值存储在一个二叉搜索树中，并检查该树的形状是否与整个结构的质量相关。因为，为什么不呢？\n\n具体来说，ACM 将从顶层到底层依次获取各层的抗坍塌值，并将它们逐一插入到树中。插入值 $v$ 的规则是：\n\n如果树是空的，则将 $v$ 作为树的根。\n\n如果树不为空，将 $v$ 与树的根进行比较。如果 $v$ 较小，则将 $v$ 插入到根的左子树中，否则插入到右子树中。\n\nACM 有一组天花板原型，它想通过尝试坍塌它们来进行分析。它想将具有相同树形状的天花板原型分组并一起分析。\n\n例如，假设 ACM 正在考虑五个具有三层的天花板原型，如样例输入 1 所述并如图 1 所示。注意，第一个原型的顶层抗坍塌值为 2，中间层的值为 7，底层的值为 1。第二个原型的层的抗坍塌值为 3、1 和 4——然而这两个原型产生了相同的树形状，因此 ACM 将一起分析它们。\n\n给定一组原型，您的任务是确定它们产生了多少种不同的树形状。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xvdteesl.png)\n\n图 1：样例输入 1 中天花板原型所产生的四种树形状。", "inputFormat": "输入的第一行包含两个整数 $n$ ($1 \\le n \\le 50$)，表示要分析的天花板原型的数量，以及 $k$ ($1 \\le k \\le 20$)，表示每个原型的层数。\n\n接下来的 $n$ 行描述了天花板原型。每行包含 $k$ 个不同的整数（范围在 $1$ 到 $10^6$ 之间，包括边界），这些整数是天花板原型中各层的抗坍塌值，从上到下排列。", "outputFormat": "输出不同树形状的数量。", "hint": "时间限制：5000 毫秒，内存限制：1048576 KB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2016。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6920", "type": "P", "difficulty": 6, "samples": [["3\n......XX.....XX...XX.\n.....X..X...X..X....X\n.....X..X.X.X..X....X\n.............XX...XX.\n.....X..X......X.X..X\n.....X..X......X.X..X\n......XX.....XX...XX.\n\n......XX.....XX...XX.\n.....X..X...X..X....X\n.....X..X.X.X..X....X\n.............XX...XX.\n.....X..X......X.X..X\n.....X..X......X.X..X\n......XX.....XX...XX.\n\n.............XX...XX.\n........X...X..X....X\n........X.X.X..X....X\n.............XX......\n........X...X..X.X..X\n........X...X..X.X..X\n......XX.....XX...XX.\n", ".??...WW.....??...??.\n?..?.W..?...?..1.0..?\n?..?.W..?.?.?..1.0..?\n.??...??.....11...WW.\n?..?.W..?.0.W..?.1..?\n?..?.W..?...W..?.1..?\n.??...11.....??...??.\n"], ["2\n......XX.....XX...XX.\n...X....X...X..X.X..X\n...X....X.X.X..X.X..X\n......XX..........XX.\n...X.X....X.X..X.X..X\n...X.X......X..X.X..X\n......XX.....XX...XX.\n\n......XX.....XX......\n...X....X...X..X.....\n...X....X.X.X..X.....\n......XX.............\n...X.X....X.X..X.....\n...X.X......X..X.....\n......XX.....XX......\n", "impossible\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2016", "枚举", "ICPC", "WF"], "title": "[ICPC 2016 WF] Clock Breaking", "background": "", "description": "After numerous unfortunate freak fatalities and the lawsuits, settlements, protests, and boycotts that naturally followed, the beleaguered executives at ACME Clock Manufacturers have decided they need to finally fix their disastrous quality control issues. It has been known for years that the digital clocks they manufacture have an unacceptably high ratio of faulty liquid-crystal display (LCD) screens, and yet these heartless souls have repeatedly failed to address the issue, or even warn their hapless consumers!\n\nYou have been called in as a quality consultant to finally put a stop to the madness. Your job is to write an automated program that can test a clock and find faults in its display.\n\nThese clocks use a standard 7-segment LCD display for all digits (shown on the left in Figure 1), plus two small segments for the ‘:’, and show all times in a 24-hour format. The minute before midnight is 23:59, and midnight is 0:00. The ‘:’ segments of a working clock are on at all times. The representation of each digit using the seven segments is shown on the right in Figure 1.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ornshtp.png)\n\n   Figure 1: LCD display of each digit. \n\nYour program will be given the display of a clock at several consecutive minutes, although you do not know exactly what time these displays start. Some of the LCD segments are burnt out (permanently off) and some are burnt in (permanently on). Your program must determine, where possible, which segments are definitely malfunctioning and which are definitely in working order.", "inputFormat": "The first input line contains a single integer $n$ ($1 \\leq n \\leq 100$), which is the number of consecutive minutes of a clock’s display. The next $8n-1$ lines contain $n$ ASCII images of these clock displays of size $7 \\times 21$, with a single blank line separating the representations.\n\nAll digit segments are represented by two characters, and each colon segment is represented by one character. The character ‘X’ indicates a segment that is on. The character ‘.’ indicates anything else (segments that are off or non-segment portions of the display). See the sample input/output for details; the first output shows every possible LCD segment along with the smaller segments used to represent the ‘:’. No clock representation has an ‘X’ in a non-segment position or only half of a segment showing.", "outputFormat": "Display a $7 \\times 21$ ASCII image with a ‘0’ for every segment that is burnt out, a ‘1’ for every segment that is burnt in, a ‘W’ for every segment that is definitely working, and a ‘?’ for every segment for which the status cannot be determined. Use ‘.’ for non-segments. If the given displays cannot come from consecutive minutes, display impossible.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Clock Breaking", "background": "", "description": "After numerous unfortunate freak fatalities and the lawsuits, settlements, protests, and boycotts that naturally followed, the beleaguered executives at ACME Clock Manufacturers have decided they need to finally fix their disastrous quality control issues. It has been known for years that the digital clocks they manufacture have an unacceptably high ratio of faulty liquid-crystal display (LCD) screens, and yet these heartless souls have repeatedly failed to address the issue, or even warn their hapless consumers!\n\nYou have been called in as a quality consultant to finally put a stop to the madness. Your job is to write an automated program that can test a clock and find faults in its display.\n\nThese clocks use a standard 7-segment LCD display for all digits (shown on the left in Figure 1), plus two small segments for the ‘:’, and show all times in a 24-hour format. The minute before midnight is 23:59, and midnight is 0:00. The ‘:’ segments of a working clock are on at all times. The representation of each digit using the seven segments is shown on the right in Figure 1.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ornshtp.png)\n\n   Figure 1: LCD display of each digit. \n\nYour program will be given the display of a clock at several consecutive minutes, although you do not know exactly what time these displays start. Some of the LCD segments are burnt out (permanently off) and some are burnt in (permanently on). Your program must determine, where possible, which segments are definitely malfunctioning and which are definitely in working order.", "inputFormat": "The first input line contains a single integer $n$ ($1 \\leq n \\leq 100$), which is the number of consecutive minutes of a clock’s display. The next $8n-1$ lines contain $n$ ASCII images of these clock displays of size $7 \\times 21$, with a single blank line separating the representations.\n\nAll digit segments are represented by two characters, and each colon segment is represented by one character. The character ‘X’ indicates a segment that is on. The character ‘.’ indicates anything else (segments that are off or non-segment portions of the display). See the sample input/output for details; the first output shows every possible LCD segment along with the smaller segments used to represent the ‘:’. No clock representation has an ‘X’ in a non-segment position or only half of a segment showing.", "outputFormat": "Display a $7 \\times 21$ ASCII image with a ‘0’ for every segment that is burnt out, a ‘1’ for every segment that is burnt in, a ‘W’ for every segment that is definitely working, and a ‘?’ for every segment for which the status cannot be determined. Use ‘.’ for non-segments. If the given displays cannot come from consecutive minutes, display impossible.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Clock Breaking", "background": "", "description": "在无数不幸的畸形死亡事件以及随之而来的诉讼、和解、抗议和抵制之后，ACME时钟制造商的高管们决定最终解决灾难性的质量控制问题。多年来，人们都知道，他们制造的数字钟的液晶显示屏故障率高得令人无法接受，然而，这些无情的人们却一再未能解决这个问题，甚至未能警告他们不幸的消费者！  \n\n你被邀请担任质量顾问，最终制止了这种疯狂。你的工作是编写一个自动程序，可以测试时钟并发现其显示中的故障。  \n\n这些时钟使用标准的7段LCD显示屏显示所有数字（如图1左侧所示），加上两个小段显示`：`，并以24小时计时法显示所有时间。午夜前一分钟是23:59，午夜是0:00。工作时钟的`：`段始终打开。图1右侧显示了使用七段表示的`0~9`每个数字。  \n\n![图1：每个数字的LCD显示。](https://cdn.luogu.com.cn/upload/image_hosting/3ornshtp.png)   \n\n图1：每个数字的LCD显示。", "inputFormat": "第一行有一个数$n(1\\ \\le\\ n\\ \\le\\ 100)$，这是时钟显示的连续分钟数。  \n\n接下来$8n-1$行包括$n$个时钟显示的$7\\times 21$的ASCII图像，每两个之间会有一行的空白用于间隔  \n\n所有表示数字的段由两个连续的字符表示，每个表示冒号的段由一个字符表示。字符`X`表示打开的段。字符`.`指示其他任何内容（显示的分段或非分段部分）。详见样本输入、输出；第一个输出显示每个可能的LCD段以及用于表示`：`的较小段。没有时钟表示在非段位置有`X`，或仅显示段的一半。", "outputFormat": "显示一个$7\\times 21$ASCII图像，每个烧坏的段显示一个`0`，每个烧进的段显示`1`，每个正常工作的段显示为`W`，以及一个`？`对于无法确定状态的每个段。使用`.`对于非分段。如果给定的显示不能来自连续分钟，则显示`impossible`。  \n\n### 输入输出样例", "hint": "时间限制：3000ms=3s  \n\n空间限制：1048576KB=1024MB=1GB  \n\n出处:2016年国际大学生编程大赛（`ACM-ICPC`）世界总决赛", "locale": "zh-CN"}}}
{"pid": "P6921", "type": "P", "difficulty": 5, "samples": [["32 20\n", "16\n"], ["2016 100\n", "42\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2016", "ICPC", "WF"], "title": "[ICPC 2016 WF] Forever Young", "background": "", "description": "My birthday is coming up. Alas, I am getting old and would like to feel young again. Fortunately, I have come up with an excellent way of feeling younger: if I write my age as a number in an appropriately chosen base $b$, then it appears to be smaller. For instance, suppose my age in base $10$ is $32$. Written in base $16$ it is only $20$!\n\nHowever, I cannot choose an arbitrary base when doing this. If my age written in base $b$ contains digits other than $0$ to $9$, then it will be obvious that I am cheating, which defeats the purpose. In addition, if my age written in base $b$ is too small then it would again be obvious that I am cheating.\n\nGiven my age $y$ and a lower bound $\\ell $ on how small I want my age to appear, find the largest base $b$ such that $y$ written in base $b$ contains only decimal digits, and is at least $\\ell $ when interpreted as a number in base $10$.", "inputFormat": "The input consists of a single line containing two base 10 integers $y$ ($10 \\le y \\le 10^{18}$ – yes, I am very old) and $\\ell $ ($10 \\le \\ell \\le y$).", "outputFormat": "Display the largest base $b$ as described above.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Forever Young", "background": "", "description": "My birthday is coming up. Alas, I am getting old and would like to feel young again. Fortunately, I have come up with an excellent way of feeling younger: if I write my age as a number in an appropriately chosen base $b$, then it appears to be smaller. For instance, suppose my age in base $10$ is $32$. Written in base $16$ it is only $20$!\n\nHowever, I cannot choose an arbitrary base when doing this. If my age written in base $b$ contains digits other than $0$ to $9$, then it will be obvious that I am cheating, which defeats the purpose. In addition, if my age written in base $b$ is too small then it would again be obvious that I am cheating.\n\nGiven my age $y$ and a lower bound $\\ell $ on how small I want my age to appear, find the largest base $b$ such that $y$ written in base $b$ contains only decimal digits, and is at least $\\ell $ when interpreted as a number in base $10$.", "inputFormat": "The input consists of a single line containing two base 10 integers $y$ ($10 \\le y \\le 10^{18}$ – yes, I am very old) and $\\ell $ ($10 \\le \\ell \\le y$).", "outputFormat": "Display the largest base $b$ as described above.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Forever Young", "background": "", "description": "# 题目大意\n\n我的生日快到了！唉，但如今我已经老了，我想重新获得年轻的感觉。\n\n幸运的是，我想出了一个让人感觉更年轻的好方法：如果我把我的年龄以适当选择的 $b$ 进制书写，那么它看起来会更小。例如，假设我以 $10$ 进制书写的年龄是 $32$ 岁；以 $16$ 进制书写，它只有 $20$（$\\texttt{0x20}$）！\n\n然而，在这样做时，我不能选择任意进制数。如果以 $b$ 进制为数写的我的年龄包含 $0-9$ 以外的数字，那么很明显我在作弊，这违背了目的。此外，如果我的年龄写成 $b$ 进制后数字太小，那么很明显我在作弊。\n\n在我希望我的年龄看起来有多小的问题上，考虑到我的年龄 $y$ 和下限 $l$，找到最大的进制数 $b$，这样写在基数 $b$ 中的 $y$ 只包含十进制数字，并且当将其看做一个十进制数字时至少是 $l$。", "inputFormat": "输入由一行组成，其中包含两个 $10$ 进制的整数 $y$（$10\\le y\\le10^{18}$ – 是的,我很老）和 $l$（$10\\le l \\le y$）", "outputFormat": "如上所述，输出最大进制数 $b$。", "hint": "时间限制：1s，内存限制：1GB。\n\n\n2016 年国际大学生编程大赛 ACM-ICPC 世界总决赛。", "locale": "zh-CN"}}}
{"pid": "P6922", "type": "P", "difficulty": 6, "samples": [["6 2\nPaSak 0 513\nNan 2 675\nYom 2 700\nWang 1 335\nPing 1 305\nThaChin 0 765\n0 353\n0 65\n", "PaSak 5\nNan 2\nYom 1\nWang 3\nPing 4\nThaChin 1\n"]], "limits": {"time": [9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "ICPC", "WF"], "title": "[ICPC 2016 WF] Longest Rivers", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/4ul9evsl.png)\n\nThe Chao Phraya River System is the main river system of Thailand. Its six longest rivers listed by decreasing length are:\n\nTha Chin ($765$ km)\n\nNan ($740$ km)\n\nYom ($700$ km)\n\nPing ($658$ km)\n\nPa Sak ($513$ km)\n\nWang ($335$ km)\n\nA simplified model of this river system is shown in Figure 1, where the smaller red numbers indicate the lengths of various sections of each river. The point where two or more rivers meet as they flow downstream is called a confluence. Confluences are labeled with the larger black numbers. In this model, each river either ends at a confluence or flows into the sea, which is labeled with the special confluence number $0$. When two or more rivers meet at a confluence (other than confluence $0$), the resulting merged river takes the name of one of those rivers. For example, the Ping and the Wang meet at confluence $1$ with the resulting merged river retaining the name Ping. With this naming, the Ping has length $658$ km while the Wang is only $335$ km. If instead the merged river had been named Wang, then the length of the Wang would be $688$ km while the length of the Ping would be only $305$ km.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n8uvzv81.png)\n\n   Figure 1: The river system in Sample Input 1. Same-colored edges indicate a river. \n\nThe raised awareness of this phenomenon causes bitter rivalries among the towns along the rivers. For example, the townspeople along the Wang protest that maybe with a proper naming scheme, their river could actually be the longest, or maybe the second longest (or at least not last!). To end all the guessing, your task is to validate all such claims.\n\nThe rank of a river is its position in a list of all rivers ordered by decreasing length, where the best rank is $1$ for the longest river. For each river, determine its best possible rank over all naming schemes. At any confluence, the name of a new, larger river in any naming scheme must be one of the names of the smaller rivers which join at that confluence. If two or more rivers have equal lengths in a naming scheme, all the tied rivers are considered to have the best possible ranking. For example, if one river is the longest and all other rivers are equal, those rivers all have rank $2$.", "inputFormat": "The first line of input contains two integers $n$ $(1 \\le n \\le 500\\, 000)$, which is the number of river sources in the system, and $m$ $(0 \\le m \\le n - 1)$, which is the number of confluences with positive labels. These confluences are numbered from $1$ to $m$.\n\nThe next $n$ lines describe the rivers. Each of these lines consists of a string, which is the name of the river at the source, and two integers $c$ $(0 \\leq c \\leq m)$ and $d$ $(1 \\leq d \\leq 10^9)$, where $c$ is the identifier of the nearest confluence downstream, and $d$ is the distance from the source to that confluence in kilometers. River names use only lowercase and uppercase letters a–z, and consist of between $1$ and $10$ characters, inclusive.\n\nThe final $m$ lines describe confluences $1$ to $m$ in a similar fashion. The $k^\\text {th}$ of these lines describes the confluence with identifier $k$ and contains two integers: the identifier of the nearest confluence downstream and the distance from confluence $k$ to this confluence in kilometers.\n\nIt is guaranteed that each confluence $1$ through $m$ appears as “the nearest downstream” at least twice, confluence $0$ appears at least once, and all sources are connected to confluence $0$.", "outputFormat": "Display one river per line in the same order as in the input. On that line, display the name of the river and its best possible rank.", "hint": "Time limit: 9000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Longest Rivers", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/4ul9evsl.png)\n\nThe Chao Phraya River System is the main river system of Thailand. Its six longest rivers listed by decreasing length are:\n\nTha Chin ($765$ km)\n\nNan ($740$ km)\n\nYom ($700$ km)\n\nPing ($658$ km)\n\nPa Sak ($513$ km)\n\nWang ($335$ km)\n\nA simplified model of this river system is shown in Figure 1, where the smaller red numbers indicate the lengths of various sections of each river. The point where two or more rivers meet as they flow downstream is called a confluence. Confluences are labeled with the larger black numbers. In this model, each river either ends at a confluence or flows into the sea, which is labeled with the special confluence number $0$. When two or more rivers meet at a confluence (other than confluence $0$), the resulting merged river takes the name of one of those rivers. For example, the Ping and the Wang meet at confluence $1$ with the resulting merged river retaining the name Ping. With this naming, the Ping has length $658$ km while the Wang is only $335$ km. If instead the merged river had been named Wang, then the length of the Wang would be $688$ km while the length of the Ping would be only $305$ km.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n8uvzv81.png)\n\n   Figure 1: The river system in Sample Input 1. Same-colored edges indicate a river. \n\nThe raised awareness of this phenomenon causes bitter rivalries among the towns along the rivers. For example, the townspeople along the Wang protest that maybe with a proper naming scheme, their river could actually be the longest, or maybe the second longest (or at least not last!). To end all the guessing, your task is to validate all such claims.\n\nThe rank of a river is its position in a list of all rivers ordered by decreasing length, where the best rank is $1$ for the longest river. For each river, determine its best possible rank over all naming schemes. At any confluence, the name of a new, larger river in any naming scheme must be one of the names of the smaller rivers which join at that confluence. If two or more rivers have equal lengths in a naming scheme, all the tied rivers are considered to have the best possible ranking. For example, if one river is the longest and all other rivers are equal, those rivers all have rank $2$.", "inputFormat": "The first line of input contains two integers $n$ $(1 \\le n \\le 500\\, 000)$, which is the number of river sources in the system, and $m$ $(0 \\le m \\le n - 1)$, which is the number of confluences with positive labels. These confluences are numbered from $1$ to $m$.\n\nThe next $n$ lines describe the rivers. Each of these lines consists of a string, which is the name of the river at the source, and two integers $c$ $(0 \\leq c \\leq m)$ and $d$ $(1 \\leq d \\leq 10^9)$, where $c$ is the identifier of the nearest confluence downstream, and $d$ is the distance from the source to that confluence in kilometers. River names use only lowercase and uppercase letters a–z, and consist of between $1$ and $10$ characters, inclusive.\n\nThe final $m$ lines describe confluences $1$ to $m$ in a similar fashion. The $k^\\text {th}$ of these lines describes the confluence with identifier $k$ and contains two integers: the identifier of the nearest confluence downstream and the distance from confluence $k$ to this confluence in kilometers.\n\nIt is guaranteed that each confluence $1$ through $m$ appears as “the nearest downstream” at least twice, confluence $0$ appears at least once, and all sources are connected to confluence $0$.", "outputFormat": "Display one river per line in the same order as in the input. On that line, display the name of the river and its best possible rank.", "hint": "Time limit: 9000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Longest Rivers", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/4ul9evsl.png)\n\n湄南河系统是泰国的主要河流系统。按长度递减排列的六条最长的河流是：\n\nTha Chin（$765$ 公里）\n\nNan（$740$ 公里）\n\nYom（$700$ 公里）\n\nPing（$658$ 公里）\n\nPa Sak（$513$ 公里）\n\nWang（$335$ 公里）\n\n图 1 展示了该河流系统的简化模型，其中较小的红色数字表示各河段的长度。两个或多个河流在下游汇合的点称为汇合点。汇合点用较大的黑色数字标记。在这个模型中，每条河流要么在汇合点结束，要么流入大海，流入大海的汇合点标记为特殊的汇合点编号 $0$。当两条或多条河流在汇合点（汇合点 $0$ 除外）汇合时，合并后的河流会取其中一条河流的名字。例如，Ping 和 Wang 在汇合点 $1$ 汇合，合并后的河流保留了 Ping 的名字。这样命名下，Ping 的长度为 $658$ 公里，而 Wang 只有 $335$ 公里。如果合并后的河流命名为 Wang，那么 Wang 的长度将为 $688$ 公里，而 Ping 的长度只有 $305$ 公里。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n8uvzv81.png)\n\n图 1：样例输入 1 中的河流系统。同色的边表示一条河流。\n\n对这一现象的关注引发了沿河城镇之间的激烈竞争。例如，沿 Wang 河的居民抗议说，也许通过适当的命名方案，他们的河流实际上可能是最长的，或者可能是第二长的（至少不是最后一名！）。为了结束所有的猜测，你的任务是验证所有这样的说法。\n\n河流的排名是按长度递减排列的所有河流中的位置，最长的河流排名为 $1$。对于每条河流，确定在所有命名方案中其可能的最佳排名。在任何汇合点，任何命名方案中新、较大的河流的名称必须是该汇合点汇合的较小河流之一的名称。如果在某个命名方案中两条或多条河流长度相等，则所有并列的河流被视为具有可能的最佳排名。例如，如果一条河流是最长的，而所有其他河流相等，则这些河流的排名均为 $2$。", "inputFormat": "输入的第一行包含两个整数 $n$ $(1 \\le n \\le 500\\, 000)$，表示系统中的河流源数量，以及 $m$ $(0 \\le m \\le n - 1)$，表示带有正标签的汇合点数量。这些汇合点编号从 $1$ 到 $m$。\n\n接下来的 $n$ 行描述了河流。每行由一个字符串（表示河流源头的名称）和两个整数 $c$ $(0 \\leq c \\leq m)$ 和 $d$ $(1 \\leq d \\leq 10^9)$ 组成，其中 $c$ 是下游最近的汇合点的标识符，$d$ 是从源头到该汇合点的距离（以公里为单位）。河流名称仅使用小写和大写字母 a–z，长度在 $1$ 到 $10$ 个字符之间（含）。\n\n最后的 $m$ 行以类似的方式描述了汇合点 $1$ 到 $m$。第 $k^\\text {th}$ 行描述了标识符为 $k$ 的汇合点，并包含两个整数：下游最近的汇合点的标识符和从汇合点 $k$ 到该汇合点的距离（以公里为单位）。\n\n保证每个汇合点 $1$ 到 $m$ 至少出现两次作为“下游最近的汇合点”，汇合点 $0$ 至少出现一次，并且所有源头都连接到汇合点 $0$。", "outputFormat": "按输入顺序每行显示一条河流。在该行上，显示河流的名称及其可能的最佳排名。", "hint": "时间限制：9000 毫秒，内存限制：1048576 KB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2016。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6923", "type": "P", "difficulty": 7, "samples": [["8\n0 0\n0 10\n10 10\n15 15\n24 6\n24 10\n30 10\n30 0\n7\n-5 0\n-5 10\n10 10\n15 5\n20 10\n35 10\n35 0\n", "30.142135624\n"], ["3\n1 0\n0 30\n40 0\n3\n1 0\n0 30\n40 0\n", "50\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2016 WF] Polygonal Puzzle", "background": "", "description": "During last year’s ACM ICPC World Finals in Marrakesh, one of the judges bought a pretty wooden puzzle depicting a camel and palm trees (see Figure 1). Unlike traditional jigsaw puzzles, which are usually created by cutting up an existing rectangular picture, all the pieces of this puzzle have been cut and painted separately. As a result, adjacent pieces often do not share common picture elements or colors. Moreover, the resulting picture itself is irregularly shaped. Given these properties, the shape of individual pieces is often the only possible way to tell where each piece should be placed.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ug8atpvc.png)\n\n   Figure 1: The judge’s wooden puzzle. \n\nThe judge has been wondering ever since last year whether it is possible to write a program to solve this puzzle. An important part of such a program is a method to evaluate how well two puzzle pieces “match” each other. The better the match, the more likely it is that those pieces are adjacent in the puzzle.\n\nPieces are modeled as simple polygons. Your task is to find a placement of two given polygons such that their interiors do not overlap but the polygons touch with their boundaries and the length of the common boundary is maximized. For this placement, polygons can be translated and rotated, but not reflected or resized. Figure 2 illustrates the optimal placement for Sample Input 1.\n\n ![](https://cdn.luogu.com.cn/upload/image_hosting/xhl8b2h0.png)\n\n   Figure 2: Sample Input 1 and its optimal placement. ", "inputFormat": "The input contains the description of two polygons, one after the other. Each polygon description starts with a line containing an integer $n$ ($3 \\leq n \\leq 50$) denoting the number of vertices of the polygon. This is followed by $n$ lines, each containing two integer coordinates $x$, $y$ of a polygon vertex ($|x|, |y| \\leq 100$). The vertices of each polygon are given in clockwise order, and no three consecutive vertices are collinear.\n\nThe input data is chosen so that even if the vertices were moved by a distance of up to $10^{-7}$, the answer would not increase by more than $10^{-4}$.", "outputFormat": "Display the maximum possible length of the common boundary of these polygons when they are optimally placed. Your answer should have an absolute or relative error of less than $10^{-3}$.", "hint": "Time limit: 18000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Polygonal Puzzle", "background": "", "description": "During last year’s ACM ICPC World Finals in Marrakesh, one of the judges bought a pretty wooden puzzle depicting a camel and palm trees (see Figure 1). Unlike traditional jigsaw puzzles, which are usually created by cutting up an existing rectangular picture, all the pieces of this puzzle have been cut and painted separately. As a result, adjacent pieces often do not share common picture elements or colors. Moreover, the resulting picture itself is irregularly shaped. Given these properties, the shape of individual pieces is often the only possible way to tell where each piece should be placed.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ug8atpvc.png)\n\n   Figure 1: The judge’s wooden puzzle. \n\nThe judge has been wondering ever since last year whether it is possible to write a program to solve this puzzle. An important part of such a program is a method to evaluate how well two puzzle pieces “match” each other. The better the match, the more likely it is that those pieces are adjacent in the puzzle.\n\nPieces are modeled as simple polygons. Your task is to find a placement of two given polygons such that their interiors do not overlap but the polygons touch with their boundaries and the length of the common boundary is maximized. For this placement, polygons can be translated and rotated, but not reflected or resized. Figure 2 illustrates the optimal placement for Sample Input 1.\n\n ![](https://cdn.luogu.com.cn/upload/image_hosting/xhl8b2h0.png)\n\n   Figure 2: Sample Input 1 and its optimal placement. ", "inputFormat": "The input contains the description of two polygons, one after the other. Each polygon description starts with a line containing an integer $n$ ($3 \\leq n \\leq 50$) denoting the number of vertices of the polygon. This is followed by $n$ lines, each containing two integer coordinates $x$, $y$ of a polygon vertex ($|x|, |y| \\leq 100$). The vertices of each polygon are given in clockwise order, and no three consecutive vertices are collinear.\n\nThe input data is chosen so that even if the vertices were moved by a distance of up to $10^{-7}$, the answer would not increase by more than $10^{-4}$.", "outputFormat": "Display the maximum possible length of the common boundary of these polygons when they are optimally placed. Your answer should have an absolute or relative error of less than $10^{-3}$.", "hint": "Time limit: 18000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Polygonal Puzzle", "background": null, "description": "有两个多边形，可以平移旋转（但不能对称、缩放等），求这两个多边形贴在一起但不重合的情况下贴贴部分的最大总长度。", "inputFormat": "第一行一个数字 $n_1$，表示第一个多边形是 $n_1$ 边形。\n\n接下来 $n_1$ 行，每行两个数字，表示第一个多边形每个端点的横、纵坐标。\n\n接下来一个数字 $n_2$，表示第二个多边形是 $n_2$ 边形。\n\n最后 $n_2$ 行，每行两个数字，表示第二个多边形每个端点的横、纵坐标。", "outputFormat": "一行，最大的贴贴部分长度，绝对误差或相对误差任一小于 $10^{-3}$ 即可通过。", "hint": "$3 \\leq n_1, n_2 \\leq 50$，横纵坐标均为整数且绝对值不超过 $100$。", "locale": "zh-CN"}}}
{"pid": "P6924", "type": "P", "difficulty": 7, "samples": [["3\n0 50 -1\n55 0 40\n-1 40 0\n1\n0 2 120\n3\n0 1\n1 2\n1 0\n", "0 1 50.0 80.0\n1 2 40.0 70.0\n1 0 55.0 110.0\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2016", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2016 WF] Road Times", "background": "", "description": "5s,1024MB\n\nUbol Narongdid is the founder of a brash new startup company called Special D-Liver-E. She wants to corner the market on overnight deliveries of organs between hospitals in the Phuket area. For scheduling purposes it is important to have accurate estimates for the times to perform such deliveries. Several trips between various hospitals have already been performed, so delivery times between those pairs of hospitals are known. The company currently has software to estimate times for other (as yet untraveled) trips, but so far all the estimates have been woefully inaccurate.\n\nYou have been asked to come up with a method to improve these estimates. You have at your disposal the following information: 1) the length (in kilometers) of the roads connecting each pair of cities in the Phuket area, and 2) a set of times (in minutes) for various previously executed deliveries.\n\nYou know that roads are one-way, and each road has a fixed speed limit that lies between $30$ and $60$ kilometers per hour. Speed limits are real-valued and need not be integers. You also know that delivery trucks always take the route that minimizes distance traveled, and on each road will always travel at a constant speed equal to that road’s speed limit. Thus you know, for example, that if a given trip is $50$ kilometers, the time it will take is between $50$ and $100$ minutes inclusive, in the absence of any other information. Ah, but you do have other information, namely the times of previous deliveries. It is up to you to use it to produce the best possible estimates.", "inputFormat": "The input starts with a line containing an integer $n$ ($1 \\le n \\leq 30$) indicating the number of cities, numbered $0$ to $n-1$. After that are $n$ lines each containing $n$ integers specifying the distance in kilometers between cities: the $j^{\\text {th}}$ value on the $i^{\\text {th}}$ line indicates the distance when traveling directly from city $i$ to city $j$. A value of $-1$ indicates there is no road directly connecting the two cities, and the distance from any city to itself is always $0$; all other distances are positive and at most $1\\, 000$. There are at most $100$ roads.\n\nFollowing this is a line with a single integer $r$ ($1 \\le r \\leq 100$) indicating the number of previously executed routes. The next $r$ lines each contain three integers $s$, $d$, and $t$, where $s$ and $d$ are the source and destination cities and $t$ is how long the delivery from $s$ to $d$ took, in minutes.\n\nFinally there is a line containing a single integer $q$ ($1 \\le q \\leq 100$) indicating the number of future delivery queries. The next $q$ lines each contain two integers $s$ and $d$ giving the source and destination cities for the query.\n\nYou may assume that for each of the $r+q$ source/destination pairs in the input there is a unique minimum-distance route.", "outputFormat": "Display a single line for each query containing the source and destination cities for that query, followed by the best low and high bounds on the estimate for the travel time, accurate to within an absolute or relative error of $10^{-6}$.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Road Times", "background": "", "description": "5s,1024MB\n\nUbol Narongdid is the founder of a brash new startup company called Special D-Liver-E. She wants to corner the market on overnight deliveries of organs between hospitals in the Phuket area. For scheduling purposes it is important to have accurate estimates for the times to perform such deliveries. Several trips between various hospitals have already been performed, so delivery times between those pairs of hospitals are known. The company currently has software to estimate times for other (as yet untraveled) trips, but so far all the estimates have been woefully inaccurate.\n\nYou have been asked to come up with a method to improve these estimates. You have at your disposal the following information: 1) the length (in kilometers) of the roads connecting each pair of cities in the Phuket area, and 2) a set of times (in minutes) for various previously executed deliveries.\n\nYou know that roads are one-way, and each road has a fixed speed limit that lies between $30$ and $60$ kilometers per hour. Speed limits are real-valued and need not be integers. You also know that delivery trucks always take the route that minimizes distance traveled, and on each road will always travel at a constant speed equal to that road’s speed limit. Thus you know, for example, that if a given trip is $50$ kilometers, the time it will take is between $50$ and $100$ minutes inclusive, in the absence of any other information. Ah, but you do have other information, namely the times of previous deliveries. It is up to you to use it to produce the best possible estimates.", "inputFormat": "The input starts with a line containing an integer $n$ ($1 \\le n \\leq 30$) indicating the number of cities, numbered $0$ to $n-1$. After that are $n$ lines each containing $n$ integers specifying the distance in kilometers between cities: the $j^{\\text {th}}$ value on the $i^{\\text {th}}$ line indicates the distance when traveling directly from city $i$ to city $j$. A value of $-1$ indicates there is no road directly connecting the two cities, and the distance from any city to itself is always $0$; all other distances are positive and at most $1\\, 000$. There are at most $100$ roads.\n\nFollowing this is a line with a single integer $r$ ($1 \\le r \\leq 100$) indicating the number of previously executed routes. The next $r$ lines each contain three integers $s$, $d$, and $t$, where $s$ and $d$ are the source and destination cities and $t$ is how long the delivery from $s$ to $d$ took, in minutes.\n\nFinally there is a line containing a single integer $q$ ($1 \\le q \\leq 100$) indicating the number of future delivery queries. The next $q$ lines each contain two integers $s$ and $d$ giving the source and destination cities for the query.\n\nYou may assume that for each of the $r+q$ source/destination pairs in the input there is a unique minimum-distance route.", "outputFormat": "Display a single line for each query containing the source and destination cities for that query, followed by the best low and high bounds on the estimate for the travel time, accurate to within an absolute or relative error of $10^{-6}$.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Road Times", "background": "", "description": "5 秒，1024 MB\n\nUbol Narongdid 是一家名为 Special D-Liver-E 的新兴初创公司的创始人。她想要垄断普吉岛地区医院之间的器官隔夜递送市场。为了安排计划，准确估计执行这些递送所需的时间非常重要。已经在一些医院之间进行了多次递送，因此这些医院对之间的递送时间是已知的。公司目前有软件来估计其他（尚未旅行过的）行程的时间，但到目前为止，所有的估计都非常不准确。\n\n你被要求提出一种方法来改善这些估计。你可以使用以下信息：1）普吉岛地区每对城市之间连接道路的长度（以公里为单位），以及 2）一组先前执行的各种递送的时间（以分钟为单位）。\n\n你知道道路是单向的，每条道路都有一个固定的速度限制，介于 $30$ 到 $60$ 公里每小时之间。速度限制是实数，不必是整数。你还知道递送卡车总是选择最小化行驶距离的路线，并且在每条道路上总是以等于该道路速度限制的恒定速度行驶。因此，例如，如果某次旅行是 $50$ 公里，所需时间在 $50$ 到 $100$ 分钟之间（包括边界），在没有其他信息的情况下。但你确实有其他信息，即先前递送的时间。你需要利用这些信息来产生尽可能好的估计。", "inputFormat": "输入以一行包含一个整数 $n$ ($1 \\le n \\leq 30$) 开始，表示城市的数量，编号为 $0$ 到 $n-1$。之后是 $n$ 行，每行包含 $n$ 个整数，指定城市之间的距离（以公里为单位）：第 $i$ 行的第 $j$ 个值表示从城市 $i$ 直接到城市 $j$ 的距离。当两个城市之间没有直接连接的道路时，值为 $-1$，从任何城市到自身的距离总是 $0$；所有其他距离为正数且最多为 $1\\, 000$。最多有 $100$ 条道路。\n\n接下来是一行包含一个整数 $r$ ($1 \\le r \\leq 100$)，表示先前执行的路线数量。接下来的 $r$ 行每行包含三个整数 $s$、$d$ 和 $t$，其中 $s$ 和 $d$ 是起始和目的城市，$t$ 是从 $s$ 到 $d$ 的递送所花费的时间，以分钟为单位。\n\n最后是一行包含一个整数 $q$ ($1 \\le q \\leq 100$)，表示未来递送查询的数量。接下来的 $q$ 行每行包含两个整数 $s$ 和 $d$，给出查询的起始和目的城市。\n\n你可以假设输入中的每对 $r+q$ 起始/目的地对都有唯一的最小距离路线。", "outputFormat": "对于每个查询，显示一行，包含该查询的起始和目的城市，后跟对旅行时间估计的最佳低和高界限，精确到绝对或相对误差为 $10^{-6}$。", "hint": "时间限制：5000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2016。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6925", "type": "P", "difficulty": 7, "samples": [["6\n0 10 0\n10 0 1\n12 8 1\n5 5 0\n11 2 1\n11 3 0\n", "4\n"], ["10\n6 1 1\n0 2 0\n2 1 1\n6 1 1\n8 2 0\n4 4 0\n4 0 0\n2 3 1\n6 1 0\n6 3 1\n", "8\n"], ["5\n5 7 0\n3 4 0\n5 7 0\n5 7 1\n9 4 0\n", "1\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2016", "ICPC", "WF"], "title": "[ICPC 2016 WF] Spin Doctor", "background": "", "description": "As an employee of the world’s most respected political polling corporation, you must take complex, real-world issues and simplify them down to a few numbers. It isn’t always easy. A big election is coming up and, at the request of Candidate X, you have just finished polling $n$ people. You have gathered three pieces of information from each person, with the values for the $i^\\text {th}$ person recorded as:\n\n$a_ i$ – the number of digits of $\\pi $ they have memorized\n\n$b_ i$ – the number of hairs on their head\n\n$c_ i$ – whether they will vote for Candidate X\n\nUnfortunately, you are beginning to wonder if these are really the most relevant questions to ask. In fact, you cannot see any correlation between $a$, $b$, and $c$ in the data. Of course, you cannot just contradict your customer – that is a good way to lose your job!\n\nPerhaps the answer is to find some weighting formula to make the results look meaningful. You will pick two real values $S$ and $T$, and sort the poll results $(a_ i, b_ i, c_ i)$ by the measure $a_ i \\cdot S + b_ i \\cdot T$. The sort will look best if the results having $c_ i$ true are clustered as close to each other as possible. More precisely, if $j$ and $k$ are the indices of the first and last results with $c_ i$ true, you want to minimize the cluster size which is $k-j+1$. Note that some choices of $S$ and $T$ will result in ties among the $(a_ i,b_ i,c_ i)$ triples. When this happens, you should assume the worst possible ordering occurs (that which maximizes the cluster size for this $(S, T)$ pair).", "inputFormat": "The input starts with a line containing $n$ ($1 \\leq n \\leq 250\\, 000$), which is the number of people polled. This is followed by one line for each person polled. Each of those lines contains integers $a_ i$ ($0 \\leq a_ i \\leq 2\\, 000\\, 000$), $b_ i$ ($0 \\leq b_ i \\leq 2\\, 000\\, 000$), and $c_ i$, where $c_ i$ is $1$ if the person will vote for Candidate X and $0$ otherwise. The input is guaranteed to contain at least one person who will vote for Candidate X.", "outputFormat": "Display the smallest possible cluster size over all possible $(S, T)$ pairs.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Spin Doctor", "background": "", "description": "As an employee of the world’s most respected political polling corporation, you must take complex, real-world issues and simplify them down to a few numbers. It isn’t always easy. A big election is coming up and, at the request of Candidate X, you have just finished polling $n$ people. You have gathered three pieces of information from each person, with the values for the $i^\\text {th}$ person recorded as:\n\n$a_ i$ – the number of digits of $\\pi $ they have memorized\n\n$b_ i$ – the number of hairs on their head\n\n$c_ i$ – whether they will vote for Candidate X\n\nUnfortunately, you are beginning to wonder if these are really the most relevant questions to ask. In fact, you cannot see any correlation between $a$, $b$, and $c$ in the data. Of course, you cannot just contradict your customer – that is a good way to lose your job!\n\nPerhaps the answer is to find some weighting formula to make the results look meaningful. You will pick two real values $S$ and $T$, and sort the poll results $(a_ i, b_ i, c_ i)$ by the measure $a_ i \\cdot S + b_ i \\cdot T$. The sort will look best if the results having $c_ i$ true are clustered as close to each other as possible. More precisely, if $j$ and $k$ are the indices of the first and last results with $c_ i$ true, you want to minimize the cluster size which is $k-j+1$. Note that some choices of $S$ and $T$ will result in ties among the $(a_ i,b_ i,c_ i)$ triples. When this happens, you should assume the worst possible ordering occurs (that which maximizes the cluster size for this $(S, T)$ pair).", "inputFormat": "The input starts with a line containing $n$ ($1 \\leq n \\leq 250\\, 000$), which is the number of people polled. This is followed by one line for each person polled. Each of those lines contains integers $a_ i$ ($0 \\leq a_ i \\leq 2\\, 000\\, 000$), $b_ i$ ($0 \\leq b_ i \\leq 2\\, 000\\, 000$), and $c_ i$, where $c_ i$ is $1$ if the person will vote for Candidate X and $0$ otherwise. The input is guaranteed to contain at least one person who will vote for Candidate X.", "outputFormat": "Display the smallest possible cluster size over all possible $(S, T)$ pairs.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Spin Doctor", "background": "", "description": "作为世界上最受尊敬的政治民意调查公司的员工，你必须将复杂的现实问题简化为几个数字。这并不总是容易的。一场重要的选举即将到来，应候选人 X 的要求，你刚刚完成了对 $n$ 人的民意调查。你从每个人那里收集了三条信息，第 $i$ 个人的信息记录为：\n\n$a_i$ —— 他们记住的 $\\pi$ 的位数\n\n$b_i$ —— 他们头上的头发数量\n\n$c_i$ —— 他们是否会投票给候选人 X\n\n不幸的是，你开始怀疑这些问题是否真的最相关。事实上，你在数据中看不到 $a$、$b$ 和 $c$ 之间的任何相关性。当然，你不能直接反驳你的客户——那是丢掉工作的好方法！\n\n也许答案是找到某种加权公式，使结果看起来有意义。你将选择两个实数 $S$ 和 $T$，并按测量值 $a_i \\cdot S + b_i \\cdot T$ 对民意调查结果 $(a_i, b_i, c_i)$ 进行排序。如果结果中 $c_i$ 为真的部分尽可能接近在一起，排序看起来会最好。更准确地说，如果 $j$ 和 $k$ 是 $c_i$ 为真的第一个和最后一个结果的索引，你希望最小化簇大小，即 $k-j+1$。注意，某些 $S$ 和 $T$ 的选择会导致 $(a_i, b_i, c_i)$ 三元组之间的平局。当这种情况发生时，你应该假设发生了最糟糕的排序（即最大化该 $(S, T)$ 对的簇大小）。", "inputFormat": "输入以一行开始，包含 $n$ ($1 \\leq n \\leq 250,000$)，即调查的人数。接下来是每个被调查者的一行。每行包含整数 $a_i$ ($0 \\leq a_i \\leq 2,000,000$)、$b_i$ ($0 \\leq b_i \\leq 2,000,000$) 和 $c_i$，其中 $c_i$ 为 $1$ 表示该人将投票给候选人 X，否则为 $0$。输入保证至少有一个人会投票给候选人 X。", "outputFormat": "输出所有可能的 $(S, T)$ 对中最小的簇大小。", "hint": "时间限制：5000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2016。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6926", "type": "P", "difficulty": 5, "samples": [["5\n2 1 1 1 3\n", "2\n"], ["1\n22\n", "4\n"], ["1\n1\n", "no quotation\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "ICPC", "WF"], "title": "[ICPC 2016 WF] String Theory", "background": "", "description": "Nested quotations are great not only for writing literature with a complex narrative structure, but also in programming languages. While it may seem necessary to use different quotation marks at different nesting levels for clarity, there is an alternative. We can display various nesting levels using $k$-quotations, which are defined as follows.\n\nA $1$-quotation is a string that begins with a quote character, ends with another quote character and contains no quote characters in-between. These are just the usual (unnested) quotations. For example, 'this is a string' is a $1$-quotation.\n\nFor $k > 1$, a $k$-quotation is a string that begins with $k$ quote characters, ends with another $k$ quote characters and contains a nested string in-between. The nested string is a non-empty sequence of $(k-1)$-quotations, which may be preceded, separated, and/or succeeded by any number of non-quote characters. For example, ''All 'work' and no 'play''' is a $2$-quotation.\n\nGiven a description of a string, you must determine its maximum possible nesting level.", "inputFormat": "The input consists of two lines. The first line contains an integer $n$ ($1 \\le n \\le 100$). The second line contains $n$ integers $a_1, a_2, \\ldots , a_ n$ ($1 \\le a_ i \\le 100$), which describe a string as follows. The string starts with $a_1$ quote characters, which are followed by a positive number of non-quote characters, which are followed by $a_2$ quote characters, which are followed by a positive number of non-quote characters, and so on, until the string ends with $a_ n$ quote characters.", "outputFormat": "Display the largest number $k$ such that a string described by the input is a $k$-quotation. If there is no such $k$, display no quotation instead.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] String Theory", "background": "", "description": "Nested quotations are great not only for writing literature with a complex narrative structure, but also in programming languages. While it may seem necessary to use different quotation marks at different nesting levels for clarity, there is an alternative. We can display various nesting levels using $k$-quotations, which are defined as follows.\n\nA $1$-quotation is a string that begins with a quote character, ends with another quote character and contains no quote characters in-between. These are just the usual (unnested) quotations. For example, 'this is a string' is a $1$-quotation.\n\nFor $k > 1$, a $k$-quotation is a string that begins with $k$ quote characters, ends with another $k$ quote characters and contains a nested string in-between. The nested string is a non-empty sequence of $(k-1)$-quotations, which may be preceded, separated, and/or succeeded by any number of non-quote characters. For example, ''All 'work' and no 'play''' is a $2$-quotation.\n\nGiven a description of a string, you must determine its maximum possible nesting level.", "inputFormat": "The input consists of two lines. The first line contains an integer $n$ ($1 \\le n \\le 100$). The second line contains $n$ integers $a_1, a_2, \\ldots , a_ n$ ($1 \\le a_ i \\le 100$), which describe a string as follows. The string starts with $a_1$ quote characters, which are followed by a positive number of non-quote characters, which are followed by $a_2$ quote characters, which are followed by a positive number of non-quote characters, and so on, until the string ends with $a_ n$ quote characters.", "outputFormat": "Display the largest number $k$ such that a string described by the input is a $k$-quotation. If there is no such $k$, display no quotation instead.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] String Theory", "background": "", "description": "嵌套引号不仅在写作具有复杂叙述结构的文学作品时很有用，在编程语言中也是如此。虽然在不同的嵌套层次使用不同的引号似乎是必要的，但还有一种替代方法。我们可以使用 $k$-引号来表示各种嵌套层次，其定义如下。\n\n一个 $1$-引号是一个以引号字符开始，以另一个引号字符结束且中间不包含引号字符的字符串。这只是通常的（未嵌套的）引号。例如，'this is a string' 是一个 $1$-引号。\n\n对于 $k > 1$，一个 $k$-引号是一个以 $k$ 个引号字符开始，以另一个 $k$ 个引号字符结束且中间包含一个嵌套字符串的字符串。嵌套字符串是一个非空的 $(k-1)$-引号序列，可以在前、后或中间被任意数量的非引号字符分隔。例如，''All 'work' and no 'play''' 是一个 $2$-引号。\n\n给定一个字符串的描述，你必须确定其最大可能的嵌套层次。", "inputFormat": "输入由两行组成。第一行包含一个整数 $n$ ($1 \\le n \\le 100$)。第二行包含 $n$ 个整数 $a_1, a_2, \\ldots , a_n$ ($1 \\le a_i \\le 100$)，描述一个字符串如下。字符串以 $a_1$ 个引号字符开始，后跟一个正数个非引号字符，接着是 $a_2$ 个引号字符，再跟一个正数个非引号字符，依此类推，直到字符串以 $a_n$ 个引号字符结束。", "outputFormat": "输出一个最大的数字 $k$，使得输入描述的字符串是一个 $k$-引号。如果没有这样的 $k$，则输出 no quotation。", "hint": "时间限制：2000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2016。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6927", "type": "P", "difficulty": 5, "samples": [["4\n6 6\n1 7\n3 5\n3 5\n", "1\n"], ["4\n2 2\n3 3\n5 1\n5 10\n", "5\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2016", "排序", "ICPC", "WF"], "title": "[ICPC 2016 WF] Swap Space", "background": "", "description": "You administer a large cluster of computers with hard drives that use various file system types to store data. You recently decided to unify the file systems to the same type. That is quite a challenge since all the drives are currently in use, all of them are filled with important data to the limits of their capacities, and you cannot afford to lose any of the data. Moreover, reformatting a drive to use a new file system may significantly change the drive’s capacity. To make the reformat possible, you will have to buy an extra hard drive. Obviously, you want to save money by minimizing the size of such extra storage.\n\nYou can reformat the drives in any order. Prior to reformatting a drive, you must move all data from that drive to one or more other drives, splitting the data if necessary. After a drive is reformatted, you can immediately start using it to store data from other drives. It is not necessary to put all the data on the same drives they originally started on – in fact, this might even be impossible if some of the drives have smaller capacity with the new file system. It is also allowed for some data to end up on the extra drive.\n\nAs an example, suppose you have four drives $A$, $B$, $C$, and $D$ with drive capacities $6$, $1$, $3$, and $3$ GB. Under the new file system, the capacities become $6$, $7$, $5$, and $5$ GB, respectively. If you buy only $1$ GB of extra space, you can move the data from drive $B$ there and then reformat drive $B$. Now you have $7$ GB free on drive $B$, so you can move the $6$ GB from drive $A$ there and reformat drive $A$. Finally, you move the six total gigabytes from drives $C$ and $D$ to drive $A$, and reformat $C$ and $D$.", "inputFormat": "The input begins with a line containing one integer $n$ ($1 \\le n \\le 10^6$), which is the number of drives in your cluster. Following this are $n$ lines, each describing a drive as two integers $a$ and $b$, where $a$ is the capacity with the old file system and $b$ is the capacity with the new file system.\n\nAll capacities are given in gigabytes and satisfy $1 \\le a,b \\le 10^9$. (One thousand petabytes should be enough for everyone, right?)", "outputFormat": "Display the total extra capacity in gigabytes you must buy to reformat the drives.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Swap Space", "background": "", "description": "You administer a large cluster of computers with hard drives that use various file system types to store data. You recently decided to unify the file systems to the same type. That is quite a challenge since all the drives are currently in use, all of them are filled with important data to the limits of their capacities, and you cannot afford to lose any of the data. Moreover, reformatting a drive to use a new file system may significantly change the drive’s capacity. To make the reformat possible, you will have to buy an extra hard drive. Obviously, you want to save money by minimizing the size of such extra storage.\n\nYou can reformat the drives in any order. Prior to reformatting a drive, you must move all data from that drive to one or more other drives, splitting the data if necessary. After a drive is reformatted, you can immediately start using it to store data from other drives. It is not necessary to put all the data on the same drives they originally started on – in fact, this might even be impossible if some of the drives have smaller capacity with the new file system. It is also allowed for some data to end up on the extra drive.\n\nAs an example, suppose you have four drives $A$, $B$, $C$, and $D$ with drive capacities $6$, $1$, $3$, and $3$ GB. Under the new file system, the capacities become $6$, $7$, $5$, and $5$ GB, respectively. If you buy only $1$ GB of extra space, you can move the data from drive $B$ there and then reformat drive $B$. Now you have $7$ GB free on drive $B$, so you can move the $6$ GB from drive $A$ there and reformat drive $A$. Finally, you move the six total gigabytes from drives $C$ and $D$ to drive $A$, and reformat $C$ and $D$.", "inputFormat": "The input begins with a line containing one integer $n$ ($1 \\le n \\le 10^6$), which is the number of drives in your cluster. Following this are $n$ lines, each describing a drive as two integers $a$ and $b$, where $a$ is the capacity with the old file system and $b$ is the capacity with the new file system.\n\nAll capacities are given in gigabytes and satisfy $1 \\le a,b \\le 10^9$. (One thousand petabytes should be enough for everyone, right?)", "outputFormat": "Display the total extra capacity in gigabytes you must buy to reformat the drives.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Swap Space", "background": "", "description": "你有许多电脑，它们的硬盘用不同的文件系统储存数据。你想要通过格式化来统一文件系统。格式化硬盘可能使它的容量发生变化。为了格式化，你需要买额外的硬盘。当然，你想要买容量最小的额外储存设备以便省钱。你可以按任意顺序格式化硬盘。格式化之前，你要把该硬盘上所有数据移到一个或更多的其他硬盘上（可以分割数据）。格式化后，该硬盘可以立刻开始使用。你没有必要把数据放到它原来所在的硬盘上。数据也可以被放到你额外买的硬盘上。举个例子，假设你有4个硬盘A、B、C、D，容量分别为6、1、3、3(GB)。新的文件系统下，它们的容量变为6、7、5、5(GB)。如果你只买1GB额外空间，你可以把B硬盘的数据放过去然后格式化硬盘B。现在你的B硬盘有7GB容量了，那么你就可以把A的数据放过去然后格式化A，最后把C、D的数据放到A上，再格式化C和D。", "inputFormat": "第一行一个数 $n(1≤n≤1,000,000)$，表示你的硬盘数。接下来 $n$ 行，每行两个数 $a$ 和 $b$，分别表示该硬盘的原容量和新文件系统下的容量。所有容量都以 GB 为单位，且$1≤a,b≤1,000,000,000$。", "outputFormat": "输出如果要格式化所有硬盘，你最少需要购买多少额外空间(GB)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6928", "type": "P", "difficulty": 6, "samples": [["3 1\n50 2 5 C1 L1 C1 U1 C1\n1 1 5 C1 L1 C100 U1 C1\n70 3 1 C1\n", "106\n107\n71\n"], ["3 3\n5 3 5 C1 L1 C1 U1 C1\n3 2 9 C1 L2 C1 L3 C1 U3 C1 U2 C1\n1 1 9 C1 L3 C3 L2 C1 U2 C1 U3 C1\n", "8\n15\n16\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2016", "ICPC", "WF"], "title": "[ICPC 2016 WF] What Really Happened on Mars?", "background": "", "description": "Real-time software in the Mars Pathfinder spacecraft suffered from an issue known as priority inversion. One technique to address this issue is to use the Priority Ceiling Protocol.\n\nIn this problem, you will simulate the execution of multiple tasks according to this protocol. The tasks share a collection of resources, each of which can be used by only one task at a time. To ensure this, resources must be locked before use and unlocked after use. Each task is defined by a start time, a unique base priority, and a sequence of instructions. Each task also has a current priority, which may change during execution. Instructions come in three types:\n\ncompute – perform a computation for one microsecond\n\nlock $k$ – lock resource $k$ (which takes no processor time)\n\nunlock $k$ – unlock resource $k$ (which takes no processor time)\n\nAfter locking a resource, a task is said to own the resource until the task unlocks it. A task will unlock only the owned resource it most recently locked, will not lock a resource it already owns, and will complete with no owned resources.\n\nEach resource has a fixed priority ceiling, which is the highest base priority of any task that contains an instruction to lock that resource.\n\nThere is a single processor that executes the tasks. When the processor starts, it initializes its clock to zero and then runs an infinite loop with the following steps:\n\n  Step 1.\n\nIdentify running tasks. A task is running if its start time is less than or equal to the current processor clock and not all of its instructions have been executed.\n\n  Step 2.\n\nDetermine the current priorities of the running tasks and which of the running tasks are blocked. A running task $T$ is blocked if the next instruction in $T$ is to lock resource $k$ and either resource $k$ is already owned or at least one other task owns a resource $\\ell $ whose priority ceiling is greater than or equal to the current priority of $T$. If $T$ is blocked, it is said to be blocked by every task owning such $k$ or $\\ell $. The current priority of a task $T$ is the maximum of $T$’s base priority and the current priorities of all tasks that $T$ blocks.\n\n  Step 3.\n\nExecute the next instruction of the non-blocked running task (if any) with the highest current priority. If there was no such task or if a compute instruction was executed, increment the processor clock by one microsecond. If a lock or unlock instruction was executed, do not increment the clock.\n\nThe Priority Ceiling Protocol defined above has the following properties:\n\nCurrent priority is defined in terms of current priority and blocking, and blocking is defined in terms of current priority. While this may appear circular, there will always be a unique set of current priorities that satisfy the definitions.\n\nAll tasks will eventually complete.\n\nThere will never be a tie in step 3.", "inputFormat": "The first line of the input contains two integers $t$ $(1 \\leq t \\leq 20)$, which is the number of tasks, and $r$ ($1 \\leq r \\leq 20$), which is the number of resources. This is followed by $t$ lines, where the $i^\\text {th}$ of these lines describes task $i$. The description of a task begins with three integers: the task’s start time $s$ ($1 \\leq s \\leq 10\\, 000$), its base priority $b$ ($1 \\leq b \\leq t$), and an integer $a$ ($1 \\leq a \\leq 100$). A task description is concluded by a sequence of $a$ strings describing the instructions. Each string is a letter (C or L or U) followed by an integer. The string C$n$ ($1 \\leq n \\leq 100$) indicates a sequence of $n$ compute instructions. The strings L$k$ and U$k$ ($1 \\leq k \\leq r$) indicate instructions locking and unlocking resource $k$ respectively.\n\nNo two tasks have the same base priority.", "outputFormat": "For each task, display the time it completes execution, in the same order that the tasks are given in the input.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] What Really Happened on Mars?", "background": "", "description": "Real-time software in the Mars Pathfinder spacecraft suffered from an issue known as priority inversion. One technique to address this issue is to use the Priority Ceiling Protocol.\n\nIn this problem, you will simulate the execution of multiple tasks according to this protocol. The tasks share a collection of resources, each of which can be used by only one task at a time. To ensure this, resources must be locked before use and unlocked after use. Each task is defined by a start time, a unique base priority, and a sequence of instructions. Each task also has a current priority, which may change during execution. Instructions come in three types:\n\ncompute – perform a computation for one microsecond\n\nlock $k$ – lock resource $k$ (which takes no processor time)\n\nunlock $k$ – unlock resource $k$ (which takes no processor time)\n\nAfter locking a resource, a task is said to own the resource until the task unlocks it. A task will unlock only the owned resource it most recently locked, will not lock a resource it already owns, and will complete with no owned resources.\n\nEach resource has a fixed priority ceiling, which is the highest base priority of any task that contains an instruction to lock that resource.\n\nThere is a single processor that executes the tasks. When the processor starts, it initializes its clock to zero and then runs an infinite loop with the following steps:\n\n  Step 1.\n\nIdentify running tasks. A task is running if its start time is less than or equal to the current processor clock and not all of its instructions have been executed.\n\n  Step 2.\n\nDetermine the current priorities of the running tasks and which of the running tasks are blocked. A running task $T$ is blocked if the next instruction in $T$ is to lock resource $k$ and either resource $k$ is already owned or at least one other task owns a resource $\\ell $ whose priority ceiling is greater than or equal to the current priority of $T$. If $T$ is blocked, it is said to be blocked by every task owning such $k$ or $\\ell $. The current priority of a task $T$ is the maximum of $T$’s base priority and the current priorities of all tasks that $T$ blocks.\n\n  Step 3.\n\nExecute the next instruction of the non-blocked running task (if any) with the highest current priority. If there was no such task or if a compute instruction was executed, increment the processor clock by one microsecond. If a lock or unlock instruction was executed, do not increment the clock.\n\nThe Priority Ceiling Protocol defined above has the following properties:\n\nCurrent priority is defined in terms of current priority and blocking, and blocking is defined in terms of current priority. While this may appear circular, there will always be a unique set of current priorities that satisfy the definitions.\n\nAll tasks will eventually complete.\n\nThere will never be a tie in step 3.", "inputFormat": "The first line of the input contains two integers $t$ $(1 \\leq t \\leq 20)$, which is the number of tasks, and $r$ ($1 \\leq r \\leq 20$), which is the number of resources. This is followed by $t$ lines, where the $i^\\text {th}$ of these lines describes task $i$. The description of a task begins with three integers: the task’s start time $s$ ($1 \\leq s \\leq 10\\, 000$), its base priority $b$ ($1 \\leq b \\leq t$), and an integer $a$ ($1 \\leq a \\leq 100$). A task description is concluded by a sequence of $a$ strings describing the instructions. Each string is a letter (C or L or U) followed by an integer. The string C$n$ ($1 \\leq n \\leq 100$) indicates a sequence of $n$ compute instructions. The strings L$k$ and U$k$ ($1 \\leq k \\leq r$) indicate instructions locking and unlocking resource $k$ respectively.\n\nNo two tasks have the same base priority.", "outputFormat": "For each task, display the time it completes execution, in the same order that the tasks are given in the input.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] What Really Happened on Mars?", "background": null, "description": "你有 $t$ 个进程和 $r$ 个资源，每个进程包含其起始时间与**基础优先级**（保证两两不同），以及若干条指令。指令有以下三种：\n\n- `compute`：进行计算，消耗 $1$ 微秒。\n- `lock k`：锁定编号为 $k$ 的资源，不耗时。\n- `unlock k`：解锁编号为 $k$ 的资源，不耗时。\n\n在进程锁定资源后，这个进程就拥有了这个资源直到这个进程将它解锁。保证任意进程只会解锁最近锁定的资源，不会锁定自身拥有的资源，且在进程结束时不会拥有任何资源。\n\n每个资源有一个固定的属性**最高优先级**，即包含锁定该资源指令的所有进程的最高**基础优先级**。\n\n有一个处理器处理这些进程。处理器有一个时钟初始为 $0$，然后重复执行下列步骤：\n\n1. 找出所有正在运行的进程。如果进程开始的时间不大于处理器的时钟且该进程的指令未运行完毕，那么称这个进程正在运行。\n\n2. 决定当前所有正在运行的进程的优先级，以及哪些正在运行的进程会被阻塞。进程 $T$ 会被阻塞当且仅当：\n\n   - 进程 $T$ 的下一条指令是锁定资源 $k$。\n   - 资源 $k$ 已经被其他进程拥有，或存在另一个进程拥有某个资源 $\\ell$，$\\ell$ 的**最高优先级**大于等于 $T$ 的**当前优先级**。\n\n   此时我们称进程 $T$ 被所有拥有资源 $k$ 或满足条件的资源 $\\ell$ 的进程阻塞。定义 $T$ 的**当前优先级**为所有它阻塞的进程的**当前优先级**与它本身的**基础优先级**的最大值。\n\n3. 执行**当前优先级**最高且没有被阻塞的进程的下一条指令。如果不存在这样的进程或者执行的指令是 `compute`，则将时钟加 $1$ 微秒。\n\n你需要求所有进程的结束时间。可以证明所有进程一定会结束。", "inputFormat": "第一行两个整数 $t,r$ 表示进程和资源个数。\n\n接下来 $t$ 行每行描述一个进程，格式如下：\n\n- 三个整数 $s,b,a$，表示进程起始时间、基础优先级、指令条数。\n- 接下来 $a$ 个字符串，每个字符串表示一条指令。字符串形如 `Cn` 表示连续 $n$ 个 `compute` 指令（**相互独立**），`Lk` 表示锁定资源 $k$，`Rk` 表示解锁资源 `k`。", "outputFormat": "$t$ 行每行一个整数表示进程执行完毕的时间。\n\n数据范围：$1 \\le t,r \\le 20,s \\le 10^4,1 \\le b \\le t$ 且互不相同，$a \\le 100$，`Cn` 中 $n \\le 100$，`Lk,Rk` 中 $1 \\le k \\le r$。\n\nTranslated by pokefunc (uid=188716)", "hint": null, "locale": "zh-CN"}}}
{"pid": "P6929", "type": "P", "difficulty": 6, "samples": [["7\n0 20\n40 0\n40 20\n70 50\n50 70\n30 50\n0 50\n", "76.157731059\n"], ["3\n0 2017\n-2017 -2017\n2017 0\n", "4510.149110617\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "2017", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2017 WF] Airport Construction", "background": "", "description": "\n\nThe tropical island nation of Piconesia is famous for its beautiful beaches, lush vegetation, cocoa and coffee plantations, and wonderful weather all year round. This paradise is being considered as a future location for the World Finals of the ACM International Collegiate Programming Contest (or at the very least a vacation spot for the executive council). There is only one small problem: the island is really hard to reach.\n\nCurrently, the fastest way to reach the island takes three days from the nearest airport, and uses a combination of fishing boat, oil tanker, kayak, and submarine. To make attending the ICPC World Finals slightly easier and to jump-start the island's tourism business, Piconesia is planning to build its first airport.\n\nSince longer landing strips can accommodate larger airplanes, Piconesia has decided to build the longest possible landing strip on their island. Unfortunately, they have been unable to determine where this landing strip should be located. Maybe you can help?\n\nFor this problem we model the boundary of Piconesia as a polygon. Given this polygon, you need to compute the length of the longest landing strip (i.e., straight line segment) that can be built on the island. The landing strip must not intersect the sea, but it may touch or run along the boundary of the island. Figure A.1 shows an example corresponding to the first sample input.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14633/1.png)\n\nFigure A.1 : The island modeled as a polygon. The longest possible landing strip is shown as a thick line.\n\n", "inputFormat": "\n\nThe input starts with a line containing an integer $n (3 \\le n \\le 200)$ specifying the number of vertices of the polygon. This is followed by $n$ lines, each containing two integers $x$ and $y (|x|, |y| \\le 10^{6})$ that give the coordinates $(x , y)$ of the vertices of the polygon in counter-clockwise order. The polygon is simple, i.e., its vertices are distinct and no two edges of the polygon intersect or touch, except that consecutive edges touch at their common vertex. In addition, no two consecutive edges are collinear.\n\n", "outputFormat": "\n\nDisplay the length of the longest straight line segment that fits inside the polygon, with an absolute or relative error of at most $10^{−6}.$\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2017 WF] Airport Construction", "background": "", "description": "\n\nThe tropical island nation of Piconesia is famous for its beautiful beaches, lush vegetation, cocoa and coffee plantations, and wonderful weather all year round. This paradise is being considered as a future location for the World Finals of the ACM International Collegiate Programming Contest (or at the very least a vacation spot for the executive council). There is only one small problem: the island is really hard to reach.\n\nCurrently, the fastest way to reach the island takes three days from the nearest airport, and uses a combination of fishing boat, oil tanker, kayak, and submarine. To make attending the ICPC World Finals slightly easier and to jump-start the island's tourism business, Piconesia is planning to build its first airport.\n\nSince longer landing strips can accommodate larger airplanes, Piconesia has decided to build the longest possible landing strip on their island. Unfortunately, they have been unable to determine where this landing strip should be located. Maybe you can help?\n\nFor this problem we model the boundary of Piconesia as a polygon. Given this polygon, you need to compute the length of the longest landing strip (i.e., straight line segment) that can be built on the island. The landing strip must not intersect the sea, but it may touch or run along the boundary of the island. Figure A.1 shows an example corresponding to the first sample input.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14633/1.png)\n\nFigure A.1 : The island modeled as a polygon. The longest possible landing strip is shown as a thick line.\n\n", "inputFormat": "\n\nThe input starts with a line containing an integer $n (3 \\le n \\le 200)$ specifying the number of vertices of the polygon. This is followed by $n$ lines, each containing two integers $x$ and $y (|x|, |y| \\le 10^{6})$ that give the coordinates $(x , y)$ of the vertices of the polygon in counter-clockwise order. The polygon is simple, i.e., its vertices are distinct and no two edges of the polygon intersect or touch, except that consecutive edges touch at their common vertex. In addition, no two consecutive edges are collinear.\n\n", "outputFormat": "\n\nDisplay the length of the longest straight line segment that fits inside the polygon, with an absolute or relative error of at most $10^{−6}.$\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2017 WF] Airport Construction", "background": "", "description": "热带岛国 Piconesia 以其美丽的海滩、郁郁葱葱的植被、可可和咖啡种植园以及全年宜人的天气而闻名。这个天堂般的地方正被考虑作为 ACM 国际大学生程序设计竞赛（ICPC）世界总决赛的未来举办地（或者至少是执行委员会的度假胜地）。只有一个小问题：这个岛屿真的很难到达。\n\n目前，最快到达该岛的方法需要从最近的机场出发，历时三天，并结合使用渔船、油轮、皮划艇和潜艇。为了使参加 ICPC 世界总决赛稍微容易一些，并启动该岛的旅游业务，Piconesia 计划建造其第一个机场。\n\n由于较长的跑道可以容纳更大的飞机，Piconesia 决定在他们的岛上建造尽可能长的跑道。不幸的是，他们无法确定这条跑道应该建在哪里。也许你可以帮忙？\n\n对于这个问题，我们将 Piconesia 的边界建模为一个多边形。给定这个多边形，你需要计算可以在岛上建造的最长跑道（即直线段）的长度。跑道不得与海相交，但可以接触或沿着岛的边界。图 A.1 显示了与第一个样例输入对应的示例。\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14633/1.png)\n\n图 A.1：将岛屿建模为多边形。最长的可能跑道显示为粗线。", "inputFormat": "输入以一行整数 $n (3 \\le n \\le 200)$ 开始，指定多边形的顶点数。接下来是 $n$ 行，每行包含两个整数 $x$ 和 $y (|x|, |y| \\le 10^{6})$，给出多边形顶点的坐标 $(x , y)$，按逆时针顺序排列。该多边形是简单的，即其顶点是不同的，并且多边形的两条边不相交或接触，除了相邻边在其公共顶点处接触。此外，没有两条相邻的边是共线的。", "outputFormat": "显示适合在多边形内的最长直线段的长度，绝对误差或相对误差不超过 $10^{-6}$。", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6930", "type": "P", "difficulty": 6, "samples": [["1\nB I P C F\nA G M - - -\n", "AGM\n"], ["2\nA B C D H\nF G M M\nF H M - *\n", "E??\n"], ["3\nA C M S D\nB G S - G\nA H S - - S\nC J S *\n", "???\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "WF"], "title": "[ICPC 2017 WF] Get a Clue!", "background": "", "description": "\n\nDeveloped in the $1940s$ in the United Kingdom, the game of Cluedo is one of the most popular board games in the world. The object of the game is to determine who murdered Mr. Body, which weapon was used to murder him, and where the murder took place. The game uses a set of cards representing six persons (labeled A , $B$ , . . . , $F)$ , six weapons (labeled $G , H$ , . . . , $L)$ and nine rooms (labeled $M , N$ , . . . , $U)$ . At the start of the game, one person card, one weapon card, and one room card are selected at random and removed from the deck so no one can see them $-$ they represent the murderer, the murder weapon, and the murder location. The remaining $18$ cards are shuffled and dealt to the players, starting with player $1$ , then to her right player $2$ , and so on. Some players may end up with one more card than others. For the purposes of this problem there are four players, so the person to the right of player $4$ is player $1$ .\n\nThe rest of the game is spent searching for clues. Players take turns, starting with player $1$ and moving to the right. A turn consists of making a suggestion (consisting of a murder suspect, a weapon, and a room) and asking other players if they have any evidence that refutes the suggestion. For example, you might say to another player `I believe the murderer was person A , using weapon $L$ , in room $T$ . $`$ If the other player is holding exactly one of these cards, that player must show you (and only you) that card. If they have more than one such card, they can show you any one of them.\n\nWhen making a suggestion, you must first ask the person to your right for any evidence. If they have none, you continue with the person on their right, and so on, until someone has evidence, or no one has any of the cards in your suggestion.\n\nMany times you can gain information even if you are not the person making the suggestion. Suppose, in the above example, you are the third player and have cards A and $T$ . If someone else shows evidence to the suggester, you know that it must be weapon card $L$ . Keeping track of suggestions and who gave evidence at each turn is an important strategy when playing the game.\n\nTo win the game, you must make an accusation, where you state your final guess of the murderer, weapon, and room. After stating your accusation, you check the three cards that were set aside at the start of the game $-$ if they match your accusation, you win! Needless to say, you want to be absolutely sure of your accusation before you make it.\n\nHere is your problem. You are player $1$ . Given a set of cards dealt to you and a history of suggestions and evidence, you need to decide how close you are to being able to make an accusation.\n\n", "inputFormat": "\n\nThe input starts with an integer $n (1 \\le n \\le 50)$ , the number of suggestions made during the game. Following this is a line containing the five cards you are dealt, all uppercase letters in the range $‘A'.$ . . $‘U'.$ The remaining $n$ lines contain one suggestion per line. Each of these lines starts with three characters representing the suggestion (in the order person, weapon, room), followed by the responses of up to three players, beginning with the player to the right of the player making the suggestion. If a player presents no evidence, a $‘-'$ (dash) is listed; otherwise an `evidence character` is listed. If the specific evidence card is seen by you (either because you provided it or you were the person receiving the evidence) then the evidence $character identifies$ that card; otherwise the evidence character is $‘ \\times '.$ Note that only the last response can be an evidence character. All characters are separated by single spaces. Only valid $suggestio_n/response$ sequences appear in the input.\n\n", "outputFormat": "\n\nDisplay a three character string identifying the murderer, the murder weapon, and the room. If the murderer can be identified, use the appropriate letter for that person; otherwise use $‘?'.$ Do the same for the murder weapon and the room.\n\n", "hint": "Time limit: 4 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2017 WF] Get a Clue!", "background": "", "description": "\n\nDeveloped in the $1940s$ in the United Kingdom, the game of Cluedo is one of the most popular board games in the world. The object of the game is to determine who murdered Mr. Body, which weapon was used to murder him, and where the murder took place. The game uses a set of cards representing six persons (labeled A , $B$ , . . . , $F)$ , six weapons (labeled $G , H$ , . . . , $L)$ and nine rooms (labeled $M , N$ , . . . , $U)$ . At the start of the game, one person card, one weapon card, and one room card are selected at random and removed from the deck so no one can see them $-$ they represent the murderer, the murder weapon, and the murder location. The remaining $18$ cards are shuffled and dealt to the players, starting with player $1$ , then to her right player $2$ , and so on. Some players may end up with one more card than others. For the purposes of this problem there are four players, so the person to the right of player $4$ is player $1$ .\n\nThe rest of the game is spent searching for clues. Players take turns, starting with player $1$ and moving to the right. A turn consists of making a suggestion (consisting of a murder suspect, a weapon, and a room) and asking other players if they have any evidence that refutes the suggestion. For example, you might say to another player `I believe the murderer was person A , using weapon $L$ , in room $T$ . $`$ If the other player is holding exactly one of these cards, that player must show you (and only you) that card. If they have more than one such card, they can show you any one of them.\n\nWhen making a suggestion, you must first ask the person to your right for any evidence. If they have none, you continue with the person on their right, and so on, until someone has evidence, or no one has any of the cards in your suggestion.\n\nMany times you can gain information even if you are not the person making the suggestion. Suppose, in the above example, you are the third player and have cards A and $T$ . If someone else shows evidence to the suggester, you know that it must be weapon card $L$ . Keeping track of suggestions and who gave evidence at each turn is an important strategy when playing the game.\n\nTo win the game, you must make an accusation, where you state your final guess of the murderer, weapon, and room. After stating your accusation, you check the three cards that were set aside at the start of the game $-$ if they match your accusation, you win! Needless to say, you want to be absolutely sure of your accusation before you make it.\n\nHere is your problem. You are player $1$ . Given a set of cards dealt to you and a history of suggestions and evidence, you need to decide how close you are to being able to make an accusation.\n\n", "inputFormat": "\n\nThe input starts with an integer $n (1 \\le n \\le 50)$ , the number of suggestions made during the game. Following this is a line containing the five cards you are dealt, all uppercase letters in the range $‘A'.$ . . $‘U'.$ The remaining $n$ lines contain one suggestion per line. Each of these lines starts with three characters representing the suggestion (in the order person, weapon, room), followed by the responses of up to three players, beginning with the player to the right of the player making the suggestion. If a player presents no evidence, a $‘-'$ (dash) is listed; otherwise an `evidence character` is listed. If the specific evidence card is seen by you (either because you provided it or you were the person receiving the evidence) then the evidence $character identifies$ that card; otherwise the evidence character is $‘ \\times '.$ Note that only the last response can be an evidence character. All characters are separated by single spaces. Only valid $suggestio_n/response$ sequences appear in the input.\n\n", "outputFormat": "\n\nDisplay a three character string identifying the murderer, the murder weapon, and the room. If the murderer can be identified, use the appropriate letter for that person; otherwise use $‘?'.$ Do the same for the murder weapon and the room.\n\n", "hint": "Time limit: 4 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2017 WF] Get a Clue!", "background": "", "description": "20 世纪 40 年代在英国开发的 Cluedo 游戏是世界上最受欢迎的棋盘游戏之一。游戏的目标是确定谁谋杀了 Mr. Body，使用了什么武器，以及谋杀发生的地点。游戏使用一套卡牌，代表六个人（标记为 A，B，……，F），六种武器（标记为 G，H，……，L）和九个房间（标记为 M，N，……，U）。在游戏开始时，随机选择一张人物卡、一张武器卡和一张房间卡，并从牌堆中移除，因此没有人可以看到它们——它们代表凶手、谋杀武器和谋杀地点。剩下的 18 张牌被洗牌并发给玩家，从玩家 1 开始，然后是她右边的玩家 2，依此类推。一些玩家可能会比其他玩家多一张牌。对于这个问题，有四名玩家，所以玩家 4 右边的人是玩家 1。\n\n游戏的其余时间用于寻找线索。玩家轮流行动，从玩家 1 开始并向右移动。每轮包括提出一个建议（包括一个谋杀嫌疑人、一种武器和一个房间），并询问其他玩家是否有证据可以反驳该建议。例如，你可能会对另一个玩家说：“我相信凶手是人物 A，使用武器 L，在房间 T。”如果其他玩家正好持有其中一张牌，该玩家必须向你（且仅向你）展示那张牌。如果他们有多于一张这样的牌，他们可以展示其中任意一张。\n\n在提出建议时，你必须首先询问你右边的人是否有任何证据。如果他们没有，你继续询问他们右边的人，依此类推，直到有人有证据，或者没有人持有你建议中的任何牌。\n\n即使你不是提出建议的人，很多时候你也可以获得信息。假设在上述例子中，你是第三个玩家，并持有牌 A 和 T。如果有人向建议者展示了证据，你就知道那一定是武器牌 L。记录每轮建议和谁提供了证据是玩游戏时的重要策略。\n\n要赢得游戏，你必须提出指控，陈述你对凶手、武器和房间的最终猜测。在陈述你的指控后，你检查游戏开始时放置的一组三张牌——如果它们与你的指控匹配，你就赢了！不用说，在提出指控之前，你要绝对确定你的指控。\n\n这是你的问题。你是玩家 1。给定一组发给你的牌和建议及证据的历史记录，你需要决定你距离能够提出指控有多近。", "inputFormat": "输入以一个整数 $n (1 \\le n \\le 50)$ 开始，表示游戏期间提出的建议次数。接下来是一行包含发给你的五张牌，所有大写字母在范围 'A' 到 'U' 之间。剩下的 $n$ 行中每行包含一个建议。每行以三个字符表示建议（按人物、武器、房间的顺序），后跟最多三个玩家的响应，从提出建议的玩家右边的玩家开始。如果玩家没有提供证据，则列出一个 '-'（破折号）；否则列出一个“证据字符”。如果你看到了具体的证据牌（因为你提供了它或者你是接收证据的人），那么证据字符标识那张牌；否则证据字符是 '×'。注意，只有最后一个响应可以是证据字符。所有字符用单个空格分隔。输入中只出现有效的建议/响应序列。", "outputFormat": "显示一个三字符的字符串，标识凶手、谋杀武器和房间。如果可以识别凶手，使用该人物的适当字母；否则使用 '?'。对谋杀武器和房间也做同样处理。", "hint": "时间限制：4 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6931", "type": "P", "difficulty": 6, "samples": [["5 5\n1 4 0 5 2\n2 1 2 0 1\n0 2 3 4 4\n0 3 0 3 1\n1 2 2 1 1\n", "9\n"], ["2 3\n50 20 3\n20 10 3\n", "30\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "WF"], "title": "[ICPC 2017 WF] Mission Improbable", "background": "", "description": "\n\nIt is a sunny day in spring and you are about to meet Patrick, a close friend and former partner in crime. Patrick lost most of his money betting on programming contests, so he needs to pull off another job. For this he needs your help, even though you have retired from a life of crime. You are reluctant at first, as you have no desire to return to your old criminal ways, but you figure there is no harm in listening to his plan.\n\nThere is a shipment of expensive consumer widgets in a nearby warehouse and Patrick intends to steal as much of it as he can. This entails finding a way into the building, incapacitating security guards, passing through various arrays of laser beams $-$ you know, the usual heist techniques. However, the heart of the warehouse has been equipped with a security system that Patrick cannot disable. This is where he needs your help.\n\nThe shipment is stored in large cubical crates, all of which have the same dimensions. The crates are stacked in neat piles, forming a three-dimensional grid. The security system takes pictures of the piles once per hour using three cameras: a front camera, a side camera and a top camera. The image from the front camera shows the height of the tallest pile in each column, the image from the side camera shows the height of the tallest pile in each row, and the image from the top camera shows whether or not each pile is empty. If the security system detects a change in any of the images, it sounds an alarm.\n\nOnce Patrick is inside, he will determine the heights of the piles and send them to you. Figure C.1 shows a possible layout of the grid and the view from each of the cameras.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14635/1.png)\n\nFigure C.1 : Grid of heights and the corresponding camera views.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14635/2.png)\n\nFigure C.2 : Possible grid of heights after the heist\n\nPatrick wants to steal as many crates as possible. Since he cannot disable the security system, he plans to fool it by arranging the remaining crates into piles so that the next set of camera images are the same. In the above example, it is possible to steal nine crates. Figure C.2 shows one possible post-heist configuration that appears identical to the security system.\n\nPatrick asks you to help him determine the maximum number of crates that can be stolen while leaving a configuration of crates that will fool the security system. Will you help him pull off this final job?\n\n", "inputFormat": "\n\nThe first line of input contains two integers $r (1 \\le r \\le 100)$ and $c (1 \\le c \\le 100)$ , the number of rows and columns in the grid, respectively. Each of the following $r$ lines contains $c$ integers, the heights (in crates) of the piles in the corresponding row. All heights are between $0$ and $10^{9}$ inclusive.\n\n", "outputFormat": "\n\nDisplay the maximum number of crates that can be stolen without being detected.\n\n", "hint": "Time limit: 1 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2017 WF] Mission Improbable", "background": "", "description": "\n\nIt is a sunny day in spring and you are about to meet Patrick, a close friend and former partner in crime. Patrick lost most of his money betting on programming contests, so he needs to pull off another job. For this he needs your help, even though you have retired from a life of crime. You are reluctant at first, as you have no desire to return to your old criminal ways, but you figure there is no harm in listening to his plan.\n\nThere is a shipment of expensive consumer widgets in a nearby warehouse and Patrick intends to steal as much of it as he can. This entails finding a way into the building, incapacitating security guards, passing through various arrays of laser beams $-$ you know, the usual heist techniques. However, the heart of the warehouse has been equipped with a security system that Patrick cannot disable. This is where he needs your help.\n\nThe shipment is stored in large cubical crates, all of which have the same dimensions. The crates are stacked in neat piles, forming a three-dimensional grid. The security system takes pictures of the piles once per hour using three cameras: a front camera, a side camera and a top camera. The image from the front camera shows the height of the tallest pile in each column, the image from the side camera shows the height of the tallest pile in each row, and the image from the top camera shows whether or not each pile is empty. If the security system detects a change in any of the images, it sounds an alarm.\n\nOnce Patrick is inside, he will determine the heights of the piles and send them to you. Figure C.1 shows a possible layout of the grid and the view from each of the cameras.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14635/1.png)\n\nFigure C.1 : Grid of heights and the corresponding camera views.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14635/2.png)\n\nFigure C.2 : Possible grid of heights after the heist\n\nPatrick wants to steal as many crates as possible. Since he cannot disable the security system, he plans to fool it by arranging the remaining crates into piles so that the next set of camera images are the same. In the above example, it is possible to steal nine crates. Figure C.2 shows one possible post-heist configuration that appears identical to the security system.\n\nPatrick asks you to help him determine the maximum number of crates that can be stolen while leaving a configuration of crates that will fool the security system. Will you help him pull off this final job?\n\n", "inputFormat": "\n\nThe first line of input contains two integers $r (1 \\le r \\le 100)$ and $c (1 \\le c \\le 100)$ , the number of rows and columns in the grid, respectively. Each of the following $r$ lines contains $c$ integers, the heights (in crates) of the piles in the corresponding row. All heights are between $0$ and $10^{9}$ inclusive.\n\n", "outputFormat": "\n\nDisplay the maximum number of crates that can be stolen without being detected.\n\n", "hint": "Time limit: 1 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2017 WF] Mission Improbable", "background": null, "description": "这是一个春天的晴天，你即将见到 Patrick，他是你的密友和前犯罪伙伴。Patrick 因为在编程比赛中赌博而损失了大部分的钱，所以他需要再干一票。为此，他需要你的帮助，尽管你已经从犯罪生活中退休。你起初很不情愿，因为你不想回到过去的犯罪生活，但你觉得听听他的计划也无妨。\n\n附近的一个仓库里有一批昂贵的消费品，Patrick 打算尽可能多地偷走这些物品。这需要找到进入建筑物的方法，制服保安，通过各种激光束——你知道的，通常的抢劫技巧。然而，仓库的核心部分配备了一个 Patrick 无法禁用的安全系统。这就是他需要你帮助的地方。\n\n货物存放在大型立方体箱子中，所有箱子的尺寸相同。箱子整齐地堆叠在一起，形成一个三维网格。安全系统每小时使用三个摄像头拍摄这些堆叠：一个前置摄像头，一个侧面摄像头和一个顶部摄像头。前置摄像头的图像显示每列中最高堆叠的高度，侧面摄像头的图像显示每行中最高堆叠的高度，顶部摄像头的图像显示每个堆叠是否为空。如果安全系统检测到任何图像的变化，它就会发出警报。\n\n一旦 Patrick 进入，他将确定堆叠的高度并发送给你。图 C.1 显示了网格的可能布局和每个摄像头的视图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4lbj63c1.png)\n\n图 C.1：高度网格和相应的摄像头视图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pcswms8b.png)\n\n图 C.2：抢劫后的可能高度网格\n\nPatrick 想要尽可能多地偷走箱子。由于他无法禁用安全系统，他计划通过将剩余的箱子重新排列成堆叠，使得下一组摄像头图像保持不变。在上述示例中，可以偷走九个箱子。图 C.2 显示了一个可能的抢劫后配置，看起来与安全系统相同。\n\nPatrick 请求你帮助他确定在不被检测到的情况下可以偷走的最大箱子数量。你会帮助他完成这最后一票吗？", "inputFormat": "输入的第一行包含两个整数 $r (1 \\le r \\le 100)$ 和 $c (1 \\le c \\le 100)$，分别表示网格的行数和列数。接下来的 $r$ 行中的每一行包含 $c$ 个整数，表示对应行中堆叠的高度（以箱子为单位）。所有高度都在 $0$ 到 $10^{9}$ 之间（含）。", "outputFormat": "输出可以在不被检测到的情况下偷走的最大箱子数量。", "hint": "时间限制：1 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6932", "type": "P", "difficulty": 6, "samples": [["2 2\n1 3\n2 1\n3 5\n7 2\n", "5\n"], ["1 2\n10 10\n9 11\n11 9\n", "0\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "WF"], "title": "[ICPC 2017 WF] Money for Nothing", "background": "", "description": "\n\nIn this problem you will be solving one of the most profound challenges of humans across the world since the beginning of time $-$ how to make lots of money.\n\nYou are a middleman in the widget market. Your job is to buy widgets from widget producer companies and sell them to widget consumer companies. Each widget consumer company has an open request for one widget per day, until some end date, and a price at which it is willing to buy the widgets. On the other hand, each widget producer company has a start date at which it can start delivering widgets and a price at which it will deliver each widget.\n\nDue to fair competition laws, you can sign a contract with only one producer company and only one consumer company. You will buy widgets from the producer company, one per day, starting on the day it can start delivering, and ending on the date specified by the consumer company. On each of those days you earn the difference between the producer's selling price and the consumer's buying price.\n\nYour goal is to choose the consumer company and the producer company that will maximize your profits.\n\n", "inputFormat": "\n\nThe first line of input contains two integers $m$ and $n (1 \\le m , n \\le 500 000)$ denoting the number of producer and consumer companies in the market, respectively. It is followed by $m$ lines, the $i$ th of which contains two integers $p_{i}$ and $d_{i} (1 \\le p_{i}, d_{i} \\le 10^{9}),$ the price (in dollars) at which the $i$ th producer sells one widget and the day on which the first widget will be available from this company. Then follow $n$ lines, the $j$ th of which contains two integers $q_{j}$ and $e_{j} (1 \\le q_{j}, e_{j} \\le 10^{9}),$ the price (in dollars) at which the $j$ th consumer is willing to buy widgets and the day immediately after the day on which the last widget has to be delivered to this company.\n\n", "outputFormat": "\n\nDisplay the maximum total number of dollars you can earn. If there is no way to sign contracts that gives you any profit, display $0$ .\n\n", "hint": "Time limit: 5 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2017 WF] Money for Nothing", "background": "", "description": "\n\nIn this problem you will be solving one of the most profound challenges of humans across the world since the beginning of time $-$ how to make lots of money.\n\nYou are a middleman in the widget market. Your job is to buy widgets from widget producer companies and sell them to widget consumer companies. Each widget consumer company has an open request for one widget per day, until some end date, and a price at which it is willing to buy the widgets. On the other hand, each widget producer company has a start date at which it can start delivering widgets and a price at which it will deliver each widget.\n\nDue to fair competition laws, you can sign a contract with only one producer company and only one consumer company. You will buy widgets from the producer company, one per day, starting on the day it can start delivering, and ending on the date specified by the consumer company. On each of those days you earn the difference between the producer's selling price and the consumer's buying price.\n\nYour goal is to choose the consumer company and the producer company that will maximize your profits.\n\n", "inputFormat": "\n\nThe first line of input contains two integers $m$ and $n (1 \\le m , n \\le 500 000)$ denoting the number of producer and consumer companies in the market, respectively. It is followed by $m$ lines, the $i$ th of which contains two integers $p_{i}$ and $d_{i} (1 \\le p_{i}, d_{i} \\le 10^{9}),$ the price (in dollars) at which the $i$ th producer sells one widget and the day on which the first widget will be available from this company. Then follow $n$ lines, the $j$ th of which contains two integers $q_{j}$ and $e_{j} (1 \\le q_{j}, e_{j} \\le 10^{9}),$ the price (in dollars) at which the $j$ th consumer is willing to buy widgets and the day immediately after the day on which the last widget has to be delivered to this company.\n\n", "outputFormat": "\n\nDisplay the maximum total number of dollars you can earn. If there is no way to sign contracts that gives you any profit, display $0$ .\n\n", "hint": "Time limit: 5 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2017 WF] Money for Nothing", "background": null, "description": "在这个问题中，你将解决自古以来人类面临的最深刻的挑战之一——如何赚很多钱。\n\n你是小工具市场中的一个中间商。你的工作是从小工具生产公司购买小工具，然后将其出售给小工具消费公司。每个小工具消费公司每天都有一个开放的请求，直到某个结束日期，并且有一个愿意购买小工具的价格。另一方面，每个小工具生产公司都有一个开始交付小工具的日期和一个交付每个小工具的价格。\n\n由于公平竞争法，你只能与一个生产公司和一个消费公司签订合同。你将从生产公司购买小工具，每天一个，从它可以开始交付的那天开始，到消费公司指定的日期结束。在这些天中，你赚取生产商的售价与消费者的购买价之间的差额。\n\n你的目标是选择能够最大化利润的消费公司和生产公司。", "inputFormat": "输入的第一行包含两个整数 $m$ 和 $n$ $(1 \\le m , n \\le 500 000)$，分别表示市场中的生产公司和消费公司的数量。接下来是 $m$ 行，第 $i$ 行包含两个整数 $p_{i}$ 和 $d_{i}$ $(1 \\le p_{i}, d_{i} \\le 10^{9})$，表示第 $i$ 个生产公司出售一个小工具的价格（美元）和该公司第一个小工具可用的日期。然后是 $n$ 行，第 $j$ 行包含两个整数 $q_{j}$ 和 $e_{j}$ $(1 \\le q_{j}, e_{j} \\le 10^{9})$，表示第 $j$ 个消费公司愿意购买小工具的价格（美元）和该公司最后一个小工具必须交付后的第二天。", "outputFormat": "请输出你能赚取的最大总美元数。如果没有办法签订合同以获得任何利润，则请输出 `0`。", "hint": "时间限制：5 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6933", "type": "P", "difficulty": 3, "samples": [["3 5\n4 -1\n4 0\n10 3\n", "3.000000000\n"], ["4 10\n5 3\n2 2\n3 6\n3 1\n", "-0.508653377\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2017 WF] Need for Speed", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/c7b5cigq.png)\n\nSheila is a student and she drives at ypical student car: it is old, slow, rusty, and falling apart. Recently,the needle on the speedometer fell off. She glued it back on, but she might have placed it at the wrong angle. Thus, when the speedometer reads $s$,her true speed is $s+c$, where $c$ is an unknown constant(possibly negative).\n\nSheila made a careful record of a recent journey and wants to use this to compute $c$ . The journey consisted of $n$ segments. In the $i^{th}$ segment she traveled a distance of $d_{i}$ and the speedometer read $s_{i}$ for the entire segment. This whole journey took time $t$ . Help Sheila by computing $c$ .\n\nNote that while Sheila's speedometer might have negative readings, her true speed was greater than zero for each segment of the journey.\n\n", "inputFormat": "\n\nThe first line of input contains two integers $n (1 \\le n \\le 1 000)$ , the number of sections in Sheila's journey, and $t (1 \\le t \\le 10^{6}),$ the total time. This is followed by $n$ lines, each describing one segment of Sheila's journey. The $i^{th}$ of these lines contains two integers $d_{i} (1 \\le d_{i} \\le 1 000)$ and $s_{i} (|s_{i}| \\le 1 000)$ , the distance and speedometer reading for the $i^{th}$ segment of the journey. Time is specified in hours, distance in miles, and speed in miles per hour.\n\n", "outputFormat": "\n\nDisplay the constant $c$ in miles per hour. Your answer should have an absolute or relative error of less than $10^{−6}.$\n\n", "hint": "Time limit: 1 s, Memory limit: 512 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en", "translations": {"en": {"title": "[ICPC 2017 WF] Need for Speed", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/c7b5cigq.png)\n\nSheila is a student and she drives at ypical student car: it is old, slow, rusty, and falling apart. Recently,the needle on the speedometer fell off. She glued it back on, but she might have placed it at the wrong angle. Thus, when the speedometer reads $s$,her true speed is $s+c$, where $c$ is an unknown constant(possibly negative).\n\nSheila made a careful record of a recent journey and wants to use this to compute $c$ . The journey consisted of $n$ segments. In the $i^{th}$ segment she traveled a distance of $d_{i}$ and the speedometer read $s_{i}$ for the entire segment. This whole journey took time $t$ . Help Sheila by computing $c$ .\n\nNote that while Sheila's speedometer might have negative readings, her true speed was greater than zero for each segment of the journey.\n\n", "inputFormat": "\n\nThe first line of input contains two integers $n (1 \\le n \\le 1 000)$ , the number of sections in Sheila's journey, and $t (1 \\le t \\le 10^{6}),$ the total time. This is followed by $n$ lines, each describing one segment of Sheila's journey. The $i^{th}$ of these lines contains two integers $d_{i} (1 \\le d_{i} \\le 1 000)$ and $s_{i} (|s_{i}| \\le 1 000)$ , the distance and speedometer reading for the $i^{th}$ segment of the journey. Time is specified in hours, distance in miles, and speed in miles per hour.\n\n", "outputFormat": "\n\nDisplay the constant $c$ in miles per hour. Your answer should have an absolute or relative error of less than $10^{−6}.$\n\n", "hint": "Time limit: 1 s, Memory limit: 512 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en"}, "zh-CN": {"title": "[ICPC 2017 WF] Need for Speed", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/c7b5cigq.png)\n\nSheila 是一名学生，她开着一辆典型的学生车：这辆车又旧又慢，生锈并且快要散架了。最近，车速表上的指针掉了下来。她把它粘回去了，但可能放错了角度。因此，当车速表显示速度为 $s$ 时，她的真实速度是 $s+c$，其中 $c$ 是一个未知常数（可能为负）。 \n\nSheila 详细记录了最近的一次旅程，并希望利用这些记录来计算 $c$。这次旅程由 $n$ 段组成。在第 $i$ 段中，她行驶的距离为 $d_{i}$，车速表在整个段落中显示的速度为 $s_{i}$。整个旅程花费的时间为 $t$。请帮助 Sheila 计算 $c$。\n\n注意，虽然 Sheila 的车速表可能显示负数，但她的真实速度在旅程的每一段中都是大于零的。", "inputFormat": "输入的第一行包含两个整数 $n (1 \\le n \\le 1 000)$，表示 Sheila 旅程的段数，以及 $t (1 \\le t \\le 10^{6})$，表示总时间。接下来有 $n$ 行，每行描述 Sheila 旅程的一个段。在这些行中的第 $i$ 行包含两个整数 $d_{i} (1 \\le d_{i} \\le 1 000)$ 和 $s_{i} (|s_{i}| \\le 1 000)$，分别表示旅程第 $i$ 段的距离和车速表读数。时间以小时为单位，距离以英里为单位，速度以英里每小时为单位。", "outputFormat": "输出常数 $c$，单位为英里每小时。你的答案的绝对误差或相对误差应小于 $10^{-6}$。", "hint": "时间限制：1 秒，内存限制：512 MB。\n\nspj 提供者：@[shenyouran](/user/137367)。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6934", "type": "P", "difficulty": 4, "samples": [["2 1\n50 20000\n150 10000\n", "66670000\n"], ["2 2\n50 20000\n150 10000\n", "0\n"], ["4 2\n0 30000\n25 30000\n50 30000\n255 30000\n", "37500000\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "WF"], "title": "[ICPC 2017 WF] Posterize", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/gc3c052t.png)\n\nPixels in a digital picture can be represented with three integers in the range $0$ to $255$ that indicate the intensity of the red, green, and blue colors. To compress an image or to create an artistic effect, many photo-editing tools include a `posterize` operation which works as follows. Each color channel is examined separately; this problem focuses only on the red channel. Rather than allow all integers from $0$ to $255$ for the red channel, a posterized image allows at most $k$ integers from this range. Each pixel's original red intensity is replaced with the nearest of the allowed integers. The photo-editing tool selects a set of $k$ integers that minimizes the sum of the squared errors introduced across all pixels in the original image. If there are $n$ pixels that have original red values $r_{1},$ . . . , $r_{n},$ and $k$ allowed integers $v_{1},$ . . . , $v_{k},$ the sum of squared errors is defined as\n\n$$\\sum\\limits_{i=1}^n \\min\\limits_{1 \\le j \\le k}(r_i-v_j)^2$$\n\nYour task is to compute the minimum achievable sum of squared errors, given parameter $k$ and a description of the red intensities of an image's pixels.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $d (1 \\le d \\le 256)$ , the number of distinct red values that occur in the original image, and $k (1 \\le k \\le d)$ , the number of distinct red values allowed in the posterized image. The remaining $d$ lines indicate the number of pixels of the image having various red values. Each such line contains two integers $r (0 \\le r \\le 255)$ and $p (1 \\le p \\le 2^{26}),$ where $r$ is a red intensity value and $p$ is the number of pixels having red intensity $r$ . Those $d$ lines are given in increasing order of red value.\n\n", "outputFormat": "\n\nDisplay the sum of the squared errors for an optimally chosen set of $k$ allowed integer values.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2017 WF] Posterize", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/gc3c052t.png)\n\nPixels in a digital picture can be represented with three integers in the range $0$ to $255$ that indicate the intensity of the red, green, and blue colors. To compress an image or to create an artistic effect, many photo-editing tools include a `posterize` operation which works as follows. Each color channel is examined separately; this problem focuses only on the red channel. Rather than allow all integers from $0$ to $255$ for the red channel, a posterized image allows at most $k$ integers from this range. Each pixel's original red intensity is replaced with the nearest of the allowed integers. The photo-editing tool selects a set of $k$ integers that minimizes the sum of the squared errors introduced across all pixels in the original image. If there are $n$ pixels that have original red values $r_{1},$ . . . , $r_{n},$ and $k$ allowed integers $v_{1},$ . . . , $v_{k},$ the sum of squared errors is defined as\n\n$$\\sum\\limits_{i=1}^n \\min\\limits_{1 \\le j \\le k}(r_i-v_j)^2$$\n\nYour task is to compute the minimum achievable sum of squared errors, given parameter $k$ and a description of the red intensities of an image's pixels.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $d (1 \\le d \\le 256)$ , the number of distinct red values that occur in the original image, and $k (1 \\le k \\le d)$ , the number of distinct red values allowed in the posterized image. The remaining $d$ lines indicate the number of pixels of the image having various red values. Each such line contains two integers $r (0 \\le r \\le 255)$ and $p (1 \\le p \\le 2^{26}),$ where $r$ is a red intensity value and $p$ is the number of pixels having red intensity $r$ . Those $d$ lines are given in increasing order of red value.\n\n", "outputFormat": "\n\nDisplay the sum of the squared errors for an optimally chosen set of $k$ allowed integer values.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2017 WF] Posterize", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/gc3c052t.png)\n\n数字图像中的像素可以用三个范围在 $0$ 到 $255$ 之间的整数表示，分别表示红、绿、蓝三种颜色的强度。为了压缩图像或创造艺术效果，许多照片编辑工具包括一个 `posterize` 操作，其工作原理如下。每个颜色通道单独检查；这个问题只关注红色通道。对于红色通道，posterized 图像最多允许 $k$ 个整数，而不是允许从 $0$ 到 $255$ 的所有整数。每个像素的原始红色强度被替换为允许整数中最接近的一个。照片编辑工具选择一组 $k$ 个整数，以最小化原始图像中所有像素引入的平方误差之和。如果有 $n$ 个像素的原始红色值为 $r_{1}, \\ldots, r_{n}$，并且有 $k$ 个允许的整数 $v_{1}, \\ldots, v_{k}$，则平方误差之和定义为\n\n$$\\sum\\limits_{i=1}^n \\min\\limits_{1 \\le j \\le k}(r_i-v_j)^2$$\n\n你的任务是计算在给定参数 $k$ 和图像像素红色强度描述的情况下，可以实现的最小平方误差之和。", "inputFormat": "输入的第一行包含两个整数 $d (1 \\le d \\le 256)$，表示原始图像中出现的不同红色值的数量，以及 $k (1 \\le k \\le d)$，表示 posterized 图像中允许的不同红色值的数量。接下来的 $d$ 行表示图像中具有各种红色值的像素数量。每行包含两个整数 $r (0 \\le r \\le 255)$ 和 $p (1 \\le p \\le 2^{26})$，其中 $r$ 是一个红色强度值，$p$ 是具有红色强度 $r$ 的像素数量。这 $d$ 行按红色值递增的顺序给出。", "outputFormat": "显示为优化选择的 $k$ 个允许整数值的平方误差之和。", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6935", "type": "P", "difficulty": 6, "samples": [["10 10\n.#...#...#\n##..##..##\n##.#.##...\n##.#.##...\n.#...#####\n...##..#.#\n......###.\n##.#.##...\n#..#..#..#\n##..##..##\n", ".#\n##\n"], ["8 8\n##..#.##\n#.####.#\n.#.#.#..\n.##.#.##\n.#.#.#..\n.##.#.##\n#..#.###\n##.#.##.\n", "####\n#..#\n#.##\n###.\n"], ["5 4\n#....\n..###\n..###\n..###\n", "#\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2017 WF] Replicate Replicate Rfplicbte", "background": "", "description": "\n\nThe owner of the Automatic Cellular Manufacturing corporation has just patented a new process for the mass production of identical parts. Her approach uses a two-dimensional lattice of two-state cells, each of which is either `empty` or `filled. ` The exact details are, of course, proprietary.\n\nInitially, a set of cells in the lattice is filled with a copy of the part that is to be reproduced. In a sequence of discrete steps, each cell in the lattice simultaneously updates its state by examining its own state and those of its eight surrounding neighbors. If an odd number of these nine cells are filled, the cell's state in the next time step will be filled, otherwise it will be empty. Figure G.1 shows several steps in the replication process for a simple pattern consisting of three filled cells.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14639/1.png)\n\nFigure G.1 : The replication process.\n\nHowever, a bug has crept into the process. After each update step, one cell in the lattice might spontaneously flip its state. For instance, Figure G.2 shows what might happen if a cell flipped its state after the first time step and another flipped its state after the third time step.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14639/2.png)\n\nFigure G.2 : Errors in the replication process. This figure corresponds to Sample Input $1$ .\n\nUnfortunately, the original patterns were lost, and only the (possibly corrupted) results of the replication remain. Can you write a program to determine a smallest possible nonempty initial pattern that could have resulted in a given final pattern?\n\n", "inputFormat": "\n\nThe first line of input contains two integers $w (1 \\le w \\le 300)$ and $h (1 \\le h \\le 300)$ , where $w$ and $h$ are the width and height of the bounding box of the final pattern. Following that are $h$ lines, each containing $w$ characters, giving the final pattern. Each character is either $‘. '$ (representing an empty cell) or $‘#'$ (representing a filled cell). There is at least one filled cell in the first row, in the last row, in the first column, and in the last column.\n\n", "outputFormat": "\n\nDisplay a minimum-size nonempty pattern that could have resulted in the given pattern, assuming that at each stage of the replication process at most one cell spontaneously changed state. The size of a pattern is the area of its bounding box. If there is more than one possible minimum-size nonempty starting pattern, any one will be accepted. Use the character $‘. '$ for empty cells and $‘#'$ for filled cells. Use the minimum number of rows and columns needed to display the pattern.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2017 WF] Replicate Replicate Rfplicbte", "background": "", "description": "\n\nThe owner of the Automatic Cellular Manufacturing corporation has just patented a new process for the mass production of identical parts. Her approach uses a two-dimensional lattice of two-state cells, each of which is either `empty` or `filled. ` The exact details are, of course, proprietary.\n\nInitially, a set of cells in the lattice is filled with a copy of the part that is to be reproduced. In a sequence of discrete steps, each cell in the lattice simultaneously updates its state by examining its own state and those of its eight surrounding neighbors. If an odd number of these nine cells are filled, the cell's state in the next time step will be filled, otherwise it will be empty. Figure G.1 shows several steps in the replication process for a simple pattern consisting of three filled cells.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14639/1.png)\n\nFigure G.1 : The replication process.\n\nHowever, a bug has crept into the process. After each update step, one cell in the lattice might spontaneously flip its state. For instance, Figure G.2 shows what might happen if a cell flipped its state after the first time step and another flipped its state after the third time step.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14639/2.png)\n\nFigure G.2 : Errors in the replication process. This figure corresponds to Sample Input $1$ .\n\nUnfortunately, the original patterns were lost, and only the (possibly corrupted) results of the replication remain. Can you write a program to determine a smallest possible nonempty initial pattern that could have resulted in a given final pattern?\n\n", "inputFormat": "\n\nThe first line of input contains two integers $w (1 \\le w \\le 300)$ and $h (1 \\le h \\le 300)$ , where $w$ and $h$ are the width and height of the bounding box of the final pattern. Following that are $h$ lines, each containing $w$ characters, giving the final pattern. Each character is either $‘. '$ (representing an empty cell) or $‘#'$ (representing a filled cell). There is at least one filled cell in the first row, in the last row, in the first column, and in the last column.\n\n", "outputFormat": "\n\nDisplay a minimum-size nonempty pattern that could have resulted in the given pattern, assuming that at each stage of the replication process at most one cell spontaneously changed state. The size of a pattern is the area of its bounding box. If there is more than one possible minimum-size nonempty starting pattern, any one will be accepted. Use the character $‘. '$ for empty cells and $‘#'$ for filled cells. Use the minimum number of rows and columns needed to display the pattern.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2017 WF] Replicate Replicate Rfplicbte", "background": "", "description": "自动化蜂窝制造公司的所有者刚刚为一种生产相同零件的新工艺申请了专利。她的方法使用了一个二维的两态单元格网格，每个单元格要么是“空的”，要么是“填充的”。具体细节当然是专有的。\n\n最初，网格中的一组单元格被填充为要复制的零件的副本。在一系列离散步骤中，网格中的每个单元格通过检查自身状态及其八个周围邻居的状态来同时更新其状态。如果这九个单元格中有奇数个是填充的，则该单元格在下一个时间步的状态将是填充的，否则将是空的。图 G.1 显示了一个由三个填充单元格组成的简单图案的复制过程中的几个步骤。\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14639/1.png)\n\n图 G.1：复制过程。\n\n然而，过程出现了一个错误。在每次更新步骤之后，网格中的一个单元格可能会自发地翻转其状态。例如，图 G.2 显示了如果一个单元格在第一次时间步后翻转其状态，另一个在第三次时间步后翻转其状态可能会发生的情况。\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14639/2.png)\n\n图 G.2：复制过程中的错误。此图对应于样例输入 $1$。\n\n不幸的是，原始图案丢失了，只剩下（可能被破坏的）复制结果。你能编写一个程序来确定可能导致给定最终图案的最小可能非空初始图案吗？", "inputFormat": "输入的第一行包含两个整数 $w (1 \\le w \\le 300)$ 和 $h (1 \\le h \\le 300)$，其中 $w$ 和 $h$ 是最终图案的边界框的宽度和高度。接下来的 $h$ 行，每行包含 $w$ 个字符，给出了最终图案。每个字符要么是 ‘.’（表示空单元格），要么是 ‘#’（表示填充单元格）。在第一行、最后一行、第一列和最后一列中至少有一个填充单元格。", "outputFormat": "显示一个可能导致给定图案的最小尺寸非空图案，假设在复制过程的每个阶段最多有一个单元格自发改变状态。图案的大小是其边界框的面积。如果有多个可能的最小尺寸非空起始图案，任何一个都将被接受。使用字符 ‘.’ 表示空单元格，‘#’ 表示填充单元格。使用显示图案所需的最少行和列。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6936", "type": "P", "difficulty": 7, "samples": [["2 10\n0 15\n5 20\n", "yes\n"], ["2 10\n1 15\n0 20\n", "no\n"], ["2 10\n5 30\n10 20\n", "yes\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "WF"], "title": "[ICPC 2017 WF] Scenery", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/jnez9lpt.png)\n\nImages by John Fowler, Carol Highsmith, and Richard Woodland\n\nYou have decided to spend a day of your trip to Rapid City taking photographs of the South Dakota Badlands, which are renowned for their spectacular and unusual land formations. You are an amateur photographer, yet very particular about lighting conditions.\n\nAfter some careful research, you have located a beautiful location in the Badlands, surrounded by picturesque landscapes. You have determined a variety of features that you wish to photograph from this location. For each feature you have identified the earliest and latest time of day at which the position of the sun is ideal. However, it will take quite a bit of time to take each photograph, given the need to reposition the tripod and camera and your general perfectionism. So you are wondering if it will be possible to successfully take photographs of all these features in one day.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $n (1 \\le n \\le 10^{4})$ and $t (1 \\le t \\le 10^{5}),$ where $n$ is the number of desired photographs and $t$ is the time you spend to take each photograph. Following that are $n$ additional lines, each describing the available time period for one of the photographs. Each such line contains two nonnegative integers a and $b$ , where a is the earliest time that you may begin working on that photograph, and $b$ is the time by which the photograph must be completed, with a $+ t \\le b \\le 10^{9}.$\n\n", "outputFormat": "\n\nDisplay yes if it is possible to take all $n$ photographs, and no otherwise.\n\n", "hint": "Time limit: 6 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2017 WF] Scenery", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/jnez9lpt.png)\n\nImages by John Fowler, Carol Highsmith, and Richard Woodland\n\nYou have decided to spend a day of your trip to Rapid City taking photographs of the South Dakota Badlands, which are renowned for their spectacular and unusual land formations. You are an amateur photographer, yet very particular about lighting conditions.\n\nAfter some careful research, you have located a beautiful location in the Badlands, surrounded by picturesque landscapes. You have determined a variety of features that you wish to photograph from this location. For each feature you have identified the earliest and latest time of day at which the position of the sun is ideal. However, it will take quite a bit of time to take each photograph, given the need to reposition the tripod and camera and your general perfectionism. So you are wondering if it will be possible to successfully take photographs of all these features in one day.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $n (1 \\le n \\le 10^{4})$ and $t (1 \\le t \\le 10^{5}),$ where $n$ is the number of desired photographs and $t$ is the time you spend to take each photograph. Following that are $n$ additional lines, each describing the available time period for one of the photographs. Each such line contains two nonnegative integers a and $b$ , where a is the earliest time that you may begin working on that photograph, and $b$ is the time by which the photograph must be completed, with a $+ t \\le b \\le 10^{9}.$\n\n", "outputFormat": "\n\nDisplay yes if it is possible to take all $n$ photographs, and no otherwise.\n\n", "hint": "Time limit: 6 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2017 WF] Scenery", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/jnez9lpt.png)\n\n图片由 John Fowler、Carol Highsmith 和 Richard Woodland 提供。\n\n你决定在前往拉皮德城的旅行中花一天时间拍摄南达科他州的荒地，这里因其壮观而独特的地貌而闻名。你是一位业余摄影师，但对光照条件非常讲究。\n\n经过仔细研究，你找到了一个美丽的拍摄地点，周围是如画的风景。你确定了希望从这个地点拍摄的各种景观特征。对于每个特征，你都确定了太阳位置理想的最早和最晚时间。然而，由于需要重新定位三脚架和相机以及你的完美主义，拍摄每张照片都需要相当长的时间。因此，你想知道是否有可能在一天内成功拍摄所有这些特征。", "inputFormat": "输入的第一行包含两个整数 $n (1 \\le n \\le 10^{4})$ 和 $t (1 \\le t \\le 10^{5})$，其中 $n$ 是希望拍摄的照片数量，$t$ 是拍摄每张照片所需的时间。接下来的 $n$ 行中，每行描述了一张照片的可用时间段。每行包含两个非负整数 $a$ 和 $b$，其中 $a$ 是可以开始拍摄该照片的最早时间，$b$ 是必须完成拍摄的时间，满足 $a + t \\le b \\le 10^{9}$。", "outputFormat": "如果可以拍摄所有 $n$ 张照片，则显示 yes，否则显示 no。", "hint": "时间限制：6 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6937", "type": "P", "difficulty": 3, "samples": [["9 5\nc t\ni r\nk p\no c\nr o\nt e\nt f\nu h\nw p\nwe we\ncan the\nwork people\nit of\nout the\n", "yes\nno\nno\nyes\nyes\n"], ["3 3\na c\nb a\na b\naaa abc\nabc aaa\nacm bcm\n", "yes\nno\nyes\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "WF"], "title": "[ICPC 2017 WF] Secret Chamber at Mount Rushmore", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/i8ay281j.png)\n\nBy now you have probably heard that there is a spectacular stone sculp-ture featuring four famous U.S. presidents at Mount Rushmore.  How-ever, very few people know that this monument contains a secret cham-ber. This sounds like something out of a plot of a Hollywood movie, butthe chamber really exists.  It can be found behind the head of AbrahamLincoln and was designed to serve as a Hall of Records to store impor-tant historical U.S. documents and artifacts.  Historians claim that theconstruction of the hall was halted in 1939 and the uncompleted cham-ber was left untouched until the late 1990s,  but this is not the wholetruth.\n\nIn $1982$ , the famous archaeologist $S$ . Dakota Jones secretly visited the monument and found that the chamber actually was completed, but it was kept confidential. This seemed suspicious and after some poking around, she found a hidden vault and some documents inside. Unfortunately, these documents did not make any sense and were all gibberish. She suspected that they had been written in a code, but she could not decipher them despite all her efforts.\n\nEarlier this week when she was in the area to follow the ACM-ICPC World Finals, Dr. Jones finally discovered the key to deciphering the documents, in Connolly Hall of $SDSM&T$ . She found a document that contains a list of translations of letters. Some letters may have more than one translation, and others may have no translation. By repeatedly applying some of these translations to individual letters in the gibberish documents, she might be able to decipher them to yield historical U.S . documents such as the Declaration of Independence and the Constitution. She needs your help.\n\nYou are given the possible translations of letters and a list of pairs of original and deciphered words. Your task is to verify whether the words in each pair match. Two words match if they have the same length and if each letter of the first word can be turned into the corresponding letter of the second word by using the available translations zero or more times.\n\n", "inputFormat": "\n\nThe first line of input contains two integers $m (1 \\le m \\le 500)$ and $n (1 \\le n \\le 50)$ , where $m$ is the number of translations of letters and $n$ is the number of word pairs. Each of the next $m$ lines contains two distinct space-separated letters a and $b$ , indicating that the letter a can be translated to the letter $b$ . Each ordered pair of letters $(a , b)$ appears at most once. Following this are $n$ lines, each containing a word pair to check. Translations and words use only lowercase letters $‘a'-‘z',$ and each word contains at least $1$ and at most $50$ letters.\n\n", "outputFormat": "\n\nFor each pair of words, display yes if the two words match, and no otherwise.\n\n", "hint": "Time limit: 1 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2017 WF] Secret Chamber at Mount Rushmore", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/i8ay281j.png)\n\nBy now you have probably heard that there is a spectacular stone sculp-ture featuring four famous U.S. presidents at Mount Rushmore.  How-ever, very few people know that this monument contains a secret cham-ber. This sounds like something out of a plot of a Hollywood movie, butthe chamber really exists.  It can be found behind the head of AbrahamLincoln and was designed to serve as a Hall of Records to store impor-tant historical U.S. documents and artifacts.  Historians claim that theconstruction of the hall was halted in 1939 and the uncompleted cham-ber was left untouched until the late 1990s,  but this is not the wholetruth.\n\nIn $1982$ , the famous archaeologist $S$ . Dakota Jones secretly visited the monument and found that the chamber actually was completed, but it was kept confidential. This seemed suspicious and after some poking around, she found a hidden vault and some documents inside. Unfortunately, these documents did not make any sense and were all gibberish. She suspected that they had been written in a code, but she could not decipher them despite all her efforts.\n\nEarlier this week when she was in the area to follow the ACM-ICPC World Finals, Dr. Jones finally discovered the key to deciphering the documents, in Connolly Hall of $SDSM&T$ . She found a document that contains a list of translations of letters. Some letters may have more than one translation, and others may have no translation. By repeatedly applying some of these translations to individual letters in the gibberish documents, she might be able to decipher them to yield historical U.S . documents such as the Declaration of Independence and the Constitution. She needs your help.\n\nYou are given the possible translations of letters and a list of pairs of original and deciphered words. Your task is to verify whether the words in each pair match. Two words match if they have the same length and if each letter of the first word can be turned into the corresponding letter of the second word by using the available translations zero or more times.\n\n", "inputFormat": "\n\nThe first line of input contains two integers $m (1 \\le m \\le 500)$ and $n (1 \\le n \\le 50)$ , where $m$ is the number of translations of letters and $n$ is the number of word pairs. Each of the next $m$ lines contains two distinct space-separated letters a and $b$ , indicating that the letter a can be translated to the letter $b$ . Each ordered pair of letters $(a , b)$ appears at most once. Following this are $n$ lines, each containing a word pair to check. Translations and words use only lowercase letters $‘a'-‘z',$ and each word contains at least $1$ and at most $50$ letters.\n\n", "outputFormat": "\n\nFor each pair of words, display yes if the two words match, and no otherwise.\n\n", "hint": "Time limit: 1 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2017 WF] Secret Chamber at Mount Rushmore", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/i8ay281j.png)\n\n到现在你可能已经听说过在拉什莫尔山上有一个壮观的石雕，展示了四位著名的美国总统。然而，很少有人知道这个纪念碑中包含一个秘密的房间。这听起来像是好莱坞电影的情节，但这个房间确实存在。它位于亚伯拉罕·林肯的头部后面，设计用作存放重要历史美国文件和文物的记录大厅。历史学家声称大厅的建设在 1939 年停止，未完成的房间直到 1990 年代末才被触及，但这并不是全部真相。\n\n在 1982 年，著名考古学家 S. Dakota Jones 秘密访问了该纪念碑，发现房间实际上已经完成，但被保密。这似乎很可疑，在一些调查之后，她发现了一个隐藏的保险库和一些文件。不幸的是，这些文件没有任何意义，都是乱码。她怀疑它们是用密码写的，但尽管她付出了所有努力，她也无法解码。\n\n本周早些时候，当她在该地区参加 ACM-ICPC 世界总决赛时，Jones 博士终于在 SDSM&T 的 Connolly Hall 发现了解码文件的关键。她找到了一份包含字母翻译列表的文件。有些字母可能有多个翻译，而其他字母可能没有翻译。通过对乱码文件中的单个字母反复应用这些翻译，她可能能够解码它们以获得历史美国文件，如《独立宣言》和《宪法》。她需要你的帮助。\n\n你被给定了字母的可能翻译和一对原始和解码单词的列表。你的任务是验证每对单词是否匹配。如果两个单词长度相同，并且第一个单词的每个字母都可以通过使用可用的翻译零次或多次转换为第二个单词的对应字母，则两个单词匹配。", "inputFormat": "输入的第一行包含两个整数 $m (1 \\le m \\le 500)$ 和 $n (1 \\le n \\le 50)$，其中 $m$ 是字母的翻译数量，$n$ 是单词对的数量。接下来的 $m$ 行中的每一行包含两个不同的空格分隔的字母 a 和 $b$，表示字母 a 可以翻译为字母 $b$。每个字母对 $(a , b)$ 最多出现一次。接下来是 $n$ 行，每行包含一个要检查的单词对。翻译和单词仅使用小写字母 'a'-'z'，每个单词至少包含 1 个字母，最多包含 50 个字母。", "outputFormat": "对于每对单词，如果两个单词匹配，则显示 yes，否则显示 no。", "hint": "时间限制：1 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6938", "type": "P", "difficulty": 7, "samples": [["6 6 3.0 0.66\n2 4 8\n4 6 1\n3 6 1\n4 5 5\n1 5 7\n3 5 3\n", "0.000000000 1.360000000\n0.000000000 1.000000000\n0.000000000 -1.000000000\n0.000000000 0.360000000\n0.880000000 0.000000000\n-0.880000000 -0.360000000\n1.02037965897\n"], ["5 5 1.0 0.5\n1 2 10\n2 3 10\n3 4 10\n4 5 10\n3 5 10\n", "5 0\n5 5\n4.2 3.14159\n4.2 3.14159\n-4.2 -3.14159\n5\n"]], "limits": {"time": [4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "网络流", "Special Judge", "导数", "ICPC", "WF"], "title": "[ICPC 2017 WF] Son of Pipe Stream", "background": "", "description": "\n\nTwo years ago, you helped install the nation's very first Flubber pipe network in your hometown, to great success. Polls show that everyone loves having their own Flubber dispenser in their kitchen, and now a few enterprising citizens have discovered a use for it. Apparently Flubber, when mixed with water, can help extinguish fires! This is a very timely discovery, as out-of-control fires have lately been surprisingly common.\n\nYour hometown's city council would like to make use of this property of Flubber by creating the $Flubber/water$ mixture at a centrally located station. This station, which is called the Flubber Department (FD) will also have specialized employees trained to travel to the locations of fires and make use of their processed Flubber to control the blazes.\n\nThe pipes are already in place all around the city. You are given a layout of the pipes, and must determine how to route Flubber from the Flubber factory and water from a local source through the pipes to the FD.\n\nNote that both Flubber and water will be flowing through the same network of pipes, perhaps even the same pipe. All pipes are bidirectional, but Flubber and water cannot move in opposite directions through the same pipe. Furthermore, if both liquids are sent in the same direction through the same pipe, they will inevitably mix. Therefore the nodes in the network have been equipped with special membranes and filters that enable you to separate and reorganize all incoming mixtures as you see fit. The network is a closed system, so the total rate of each fluid going into a node must equal the total rate of that fluid going out, except at the source of that fluid and the destination (the FD).\n\nEach pipe has a certain capacity. Flubber, being somewhat sluggish, has a viscosity value $v$ , so a pipe that can transport $v liters/second$ of water can transport only $1 liter/second$ of Flubber. The pipe's capacity scales linearly for mixtures of the two. To be precise, if $c$ denotes the water capacity of the pipe and $f$ and $w$ are the rates of Flubber and water moving through the pipe (all measured in $liters/second),$ then the capacity constraint is given by the inequality $v · f + w \\le c$ .\n\nYour main concern is balancing the mixture that reaches the FD. You would like as much total liquid as possible, but you also need a sufficient amount of water $-$ because undiluted Flubber is highly flammable $-$ and a sufficient amount of Flubber $-$ because it would not be much of a `Flubber Department` without Flubber! You have come up with a formula to measure the `value` of the final mixture: $F^{a} · W^{1−a},$ where $F$ is the rate of incoming Flubber in $liters/second, W$ is the rate of incoming water in $liters/second,$ and a is a given constant between $0$ and $1$ .\n\nDetermine the maximum value of $F^{a} · W^{1−a}$ that can be achieved and how to route the Flubber and water to achieve it.\n\n", "inputFormat": "\n\nThe input starts with a line containing the number of locations $n (3 \\le n \\le 200)$ , the number of pipes $p (n − 1 \\le p \\le $ n(n $− 1)/2)$ , and the real values $v (1 \\le v \\le 10)$ and a ($0$ . $01 \\le $ a $ \\le 0$ . $99$) . Locations are numbered from $1$ to $n$ ; $1$ is the Flubber factory, $2$ is the water source, and $3$ is the FD. The real values have at most $10$ digits after the decimal point.\n\nThe following $p$ lines each describe one pipe. Each line contains two integers $j$ and $k (1 \\le j < k \\le n)$ , giving the locations connected by the pipe, and an integer $c (1 \\le c \\le 10)$ , giving the water capacity of the pipe in $liters/second.$\n\nNo two pipes connect the same pair of locations. Furthermore, it is guaranteed that the network is connected.\n\n", "outputFormat": "\n\nFirst, for each pipe (in the order given in the input), display two values: the rate of Flubber moving through it, and the rate of water moving through it (negative if the liquid is moving from $k$ to $j)$ , such that $F^{a} ·W^{1−a}$ is maximized. Then display that maximum value accurate to within an absolute error of $10^{−4}.$\n\nIf there are multiple solutions, any one will be accepted. All constraints (not sending Flubber and water in opposite directions along the same pipe, flow conservation, pipe capacities, and consistency between the constructed solution and its claimed value) must be satisfied within an absolute error of $10^{−4}.$\n\n", "hint": "Time limit: 5 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2017 WF] Son of Pipe Stream", "background": "", "description": "\n\nTwo years ago, you helped install the nation's very first Flubber pipe network in your hometown, to great success. Polls show that everyone loves having their own Flubber dispenser in their kitchen, and now a few enterprising citizens have discovered a use for it. Apparently Flubber, when mixed with water, can help extinguish fires! This is a very timely discovery, as out-of-control fires have lately been surprisingly common.\n\nYour hometown's city council would like to make use of this property of Flubber by creating the $Flubber/water$ mixture at a centrally located station. This station, which is called the Flubber Department (FD) will also have specialized employees trained to travel to the locations of fires and make use of their processed Flubber to control the blazes.\n\nThe pipes are already in place all around the city. You are given a layout of the pipes, and must determine how to route Flubber from the Flubber factory and water from a local source through the pipes to the FD.\n\nNote that both Flubber and water will be flowing through the same network of pipes, perhaps even the same pipe. All pipes are bidirectional, but Flubber and water cannot move in opposite directions through the same pipe. Furthermore, if both liquids are sent in the same direction through the same pipe, they will inevitably mix. Therefore the nodes in the network have been equipped with special membranes and filters that enable you to separate and reorganize all incoming mixtures as you see fit. The network is a closed system, so the total rate of each fluid going into a node must equal the total rate of that fluid going out, except at the source of that fluid and the destination (the FD).\n\nEach pipe has a certain capacity. Flubber, being somewhat sluggish, has a viscosity value $v$ , so a pipe that can transport $v liters/second$ of water can transport only $1 liter/second$ of Flubber. The pipe's capacity scales linearly for mixtures of the two. To be precise, if $c$ denotes the water capacity of the pipe and $f$ and $w$ are the rates of Flubber and water moving through the pipe (all measured in $liters/second),$ then the capacity constraint is given by the inequality $v · f + w \\le c$ .\n\nYour main concern is balancing the mixture that reaches the FD. You would like as much total liquid as possible, but you also need a sufficient amount of water $-$ because undiluted Flubber is highly flammable $-$ and a sufficient amount of Flubber $-$ because it would not be much of a `Flubber Department` without Flubber! You have come up with a formula to measure the `value` of the final mixture: $F^{a} · W^{1−a},$ where $F$ is the rate of incoming Flubber in $liters/second, W$ is the rate of incoming water in $liters/second,$ and a is a given constant between $0$ and $1$ .\n\nDetermine the maximum value of $F^{a} · W^{1−a}$ that can be achieved and how to route the Flubber and water to achieve it.\n\n", "inputFormat": "\n\nThe input starts with a line containing the number of locations $n (3 \\le n \\le 200)$ , the number of pipes $p (n − 1 \\le p \\le $ n(n $− 1)/2)$ , and the real values $v (1 \\le v \\le 10)$ and a ($0$ . $01 \\le $ a $ \\le 0$ . $99$) . Locations are numbered from $1$ to $n$ ; $1$ is the Flubber factory, $2$ is the water source, and $3$ is the FD. The real values have at most $10$ digits after the decimal point.\n\nThe following $p$ lines each describe one pipe. Each line contains two integers $j$ and $k (1 \\le j < k \\le n)$ , giving the locations connected by the pipe, and an integer $c (1 \\le c \\le 10)$ , giving the water capacity of the pipe in $liters/second.$\n\nNo two pipes connect the same pair of locations. Furthermore, it is guaranteed that the network is connected.\n\n", "outputFormat": "\n\nFirst, for each pipe (in the order given in the input), display two values: the rate of Flubber moving through it, and the rate of water moving through it (negative if the liquid is moving from $k$ to $j)$ , such that $F^{a} ·W^{1−a}$ is maximized. Then display that maximum value accurate to within an absolute error of $10^{−4}.$\n\nIf there are multiple solutions, any one will be accepted. All constraints (not sending Flubber and water in opposite directions along the same pipe, flow conservation, pipe capacities, and consistency between the constructed solution and its claimed value) must be satisfied within an absolute error of $10^{−4}.$\n\n", "hint": "Time limit: 5 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2017 WF] Son of Pipe Stream", "background": "", "description": "两年以前，你帮助你的家乡安装了国内的第一个 Flubber 管道网络，获得了巨大成功。投票表明每个人都喜欢在自己家的厨房里装上 Flubber 分配器，而现在一些有进取心的市民发现了一种新的用途——Flubber 和水混合后似乎可以帮助灭火！这是一个很及时的发现，因为最近无法控制的大火出奇地常见。\n\n你家乡的市议会想在一个位于中央的地方制造 Flubber 和水的混合物以利用 Flubber 的这个属性。这个被称为 Flubber 部门的地方拥有专门训练的员工去往着火的地点并且利用经过处理的 Flubber 来控制火势。\n\n管道已经在城市中铺设好。你会得到管道布局，而你需要决定如何将 Flubber 从 Flubber 工厂、将水从一个本地水源通过管道运送至 Flubber 部门。\n\n注意 Flubber 和水会在同一管道网络中，甚至可能在同一条管道中流动。所有管道是双向的，但是 Flubber 和水不能在同一条管道中异向流动。此外，如果两种液体同向流过一条管道，它们会不可避免地混合，因此网络中的所有节点配备了特殊的膜和筛，如你所见，可以分离和重新组织所有流入的混合物。管道网络是个封闭系统，因此在每个节点处每种液体的总流入速率必须等于总流出速率，除了每种液体各自的源头和目的地（Flubber 部门）。\n\n每条管道有某个容量，有些粘稠的 Flubber 有一个粘度值 $v$，所以能运输 $v$ 升每秒的水的管道只能运输 $1$ 升每秒的 Flubber。管道对于混合物的容量是线性变化的。更精确地，假设 $c$ 表示管道对于水的容量，$f$ 和 $w$ 分别表示 Flubber 和水流过管道的速率（单位均为升每秒），则容量的限制用不等式 $v⋅f+w\\le c$ 表示。\n\n你主要关心的是平衡流到 Flubber 部门的混合物。你想要尽可能多的混合液体，但是也需要足够的水——因为未经稀释的 Flubber 是高度易燃的——也需要足够的 Flubber——因为 Flubber 部门可不能没了 Flubber！你想出了一个公式来衡量最终混合物的价值：$F^a⋅W^{1-a}$，其中 $F$ 是以升每秒为单位的 Flubber 的流入速率，$W$ 是以升每秒为单位的水的流入速率，$a$ 是一个给定的介于 0 和 1 之间的常数。\n\n求出 $F^a⋅W^{1−a}$ 能达到的最大值以及如何安排 Flubber 和水的路径来达到它。", "inputFormat": "输入的第一行包含地点的数量 $n (3\\le n\\le 300)$，管道的数量 $p (n-1\\le p\\le \\frac12n(n -1))$，和实数 $v (1\\le v\\le 10)$ 和 $a (0.01\\le a\\le 0.99)$。地点从 1 到 $n$ 标号；1 是 Flubber 工厂，2 是水源，3 是 Flutter 部门。实数的小数点后最多有十位。\n\n接下来的 $p$ 行每行描述了一条管道。每行有两个整数 $j$ 和 $k (1\\le j < k\\le n)$，表示管道连接的地点，和一个整数 $c (1\\le c\\le 10)$，表示这条管道的水容量，以升每秒为单位。\n\n没有两条管道连接相同的两个地点，此外，还保证网络是连通的。", "outputFormat": "首先，对于每条管道（按照输入的顺序），输出两个值：其中 Flubber 流过的速率和其中水流过的速率 （如果从 k 流到 j 则为负数），使得 $F^a⋅W^{1−a}$ 最大化。然后输出其最大值，在 $10^{−4}$ 的绝对误差以内。\n\n如果有多解，输出任意一种均可。所有限制（Flubber 和水没有在同一条管道内异向流动、流量守恒、管道容量以及构造的解和其声称的值的一致性）需要在 $10^{−4}$ 的绝对误差内满足。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6939", "type": "P", "difficulty": 6, "samples": [["3 4\nPP\nRR\nPS\nSS\n", "PS\nPP\nRR\nSS\n"], ["20 3\nPRSPS\nSSSSS\nPPSPP\n", "PRSPS\nPPSPP\nSSSSS\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "WF"], "title": "[ICPC 2017 WF] Tarot Sham Boast", "background": "", "description": "\n\nCurse your rival! Every year at the annual Rock Paper Scissors tournament, you have made it to the final match. (Your Rock technique is unmatched, and your Paper cuts to the bone! Your Scissors need a little work, though. ) But every year, he defeats you, even though his moves appear entirely random! And he claims to the press that he simply cannot be beaten. What is his secret?\n\nFortunately, you think you have figured it out. This year, just before the tournament, you caught him visiting various shamans around town. Aha! He is using the supernatural against you! You figured two can play at this game. So you went and visited a set of fortune-tellers, who have each used a Tarot deck to predict a sequence that your rival will end up using, sometime during the match.\n\nHowever, your initial excitement has passed, and now you are feeling a little silly. This cannot possibly work, right? In the end it feels like you have paid good money for a fraudulent, random set of predictions. Oh well; you might as well keep an eye out for some of them during the match. But which predictions will you use?\n\nIn the final match, you and your rival will play $n$ rounds of Rock Paper Scissors. In each round, your rival and you will both choose one of the three options (Rock, Paper, or Scissors). Based on your selections, a winner of the round will be determined (exactly how is irrelevant to this problem).\n\nGiven the length of the final match and the various predictions, sort them in order of how likely they are to appear sometime during the match as a contiguous sequence of options chosen by your rival, assuming he is choosing his symbol in each round independently and uniformly at random.\n\n", "inputFormat": "\n\nThe first line of input contains two integers $n (1 \\le n \\le 10^{6}),$ the number of rounds in the final match, and $s (1 \\le s \\le 10)$ , the number of sequences. The remaining $s$ lines each describe a prediction, consisting of a string of characters $‘R', ‘P',$ and $‘S'.$ All predictions have the same length, which is between $1$ and $n$ characters long, inclusive, and no longer than $10^{5}.$\n\n", "outputFormat": "\n\nDisplay all of the predictions, sorted by decreasing likelihood of appearance sometime during the final match. In the case of tied predictions, display them in the same order as in the input.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2017 WF] Tarot Sham Boast", "background": "", "description": "\n\nCurse your rival! Every year at the annual Rock Paper Scissors tournament, you have made it to the final match. (Your Rock technique is unmatched, and your Paper cuts to the bone! Your Scissors need a little work, though. ) But every year, he defeats you, even though his moves appear entirely random! And he claims to the press that he simply cannot be beaten. What is his secret?\n\nFortunately, you think you have figured it out. This year, just before the tournament, you caught him visiting various shamans around town. Aha! He is using the supernatural against you! You figured two can play at this game. So you went and visited a set of fortune-tellers, who have each used a Tarot deck to predict a sequence that your rival will end up using, sometime during the match.\n\nHowever, your initial excitement has passed, and now you are feeling a little silly. This cannot possibly work, right? In the end it feels like you have paid good money for a fraudulent, random set of predictions. Oh well; you might as well keep an eye out for some of them during the match. But which predictions will you use?\n\nIn the final match, you and your rival will play $n$ rounds of Rock Paper Scissors. In each round, your rival and you will both choose one of the three options (Rock, Paper, or Scissors). Based on your selections, a winner of the round will be determined (exactly how is irrelevant to this problem).\n\nGiven the length of the final match and the various predictions, sort them in order of how likely they are to appear sometime during the match as a contiguous sequence of options chosen by your rival, assuming he is choosing his symbol in each round independently and uniformly at random.\n\n", "inputFormat": "\n\nThe first line of input contains two integers $n (1 \\le n \\le 10^{6}),$ the number of rounds in the final match, and $s (1 \\le s \\le 10)$ , the number of sequences. The remaining $s$ lines each describe a prediction, consisting of a string of characters $‘R', ‘P',$ and $‘S'.$ All predictions have the same length, which is between $1$ and $n$ characters long, inclusive, and no longer than $10^{5}.$\n\n", "outputFormat": "\n\nDisplay all of the predictions, sorted by decreasing likelihood of appearance sometime during the final match. In the case of tied predictions, display them in the same order as in the input.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2017 WF] Tarot Sham Boast", "background": "", "description": "诅咒你的对手！每年在年度石头剪刀布比赛中，你都进入了最后的决赛。（你的石头技巧无与伦比，你的纸张切割如刀！不过你的剪刀还需要一些改进。）但每年，他都击败了你，尽管他的动作看起来完全是随机的！而且他对媒体声称他根本无法被击败。他的秘密是什么？\n\n幸运的是，你认为你已经找到了答案。今年，就在比赛前，你抓到他在城里拜访各种萨满。啊哈！他在用超自然力量对付你！你想到了可以以其人之道还治其人之身。所以你去拜访了一些算命师，他们每个人都用塔罗牌预测了一些你对手将在比赛中某个时候使用的序列。\n\n然而，你最初的兴奋已经过去，现在你觉得有点傻。这不可能奏效，对吧？最后你觉得自己花了不少钱买了一些虚假的、随机的预测。哦，好吧；你不妨在比赛中留意其中的一些。但你会使用哪些预测呢？\n\n在最后的比赛中，你和你的对手将进行 $n$ 轮石头剪刀布。在每一轮中，你的对手和你都将选择三种选项之一（石头、剪刀或布）。根据你们的选择，将决定该轮的胜者（具体如何决定与此问题无关）。\n\n给定最后比赛的长度和各种预测，按它们在比赛中作为你对手选择的连续序列出现的可能性排序，假设他在每一轮中独立且均匀地随机选择他的符号。", "inputFormat": "输入的第一行包含两个整数 $n (1 \\le n \\le 10^{6})$，即最后比赛的轮数，以及 $s (1 \\le s \\le 10)$，即序列的数量。接下来的 $s$ 行每行描述一个预测，由字符 'R'、'P' 和 'S' 组成的字符串。所有预测的长度相同，长度在 $1$ 到 $n$ 个字符之间（包括 $n$），且不超过 $10^{5}$。", "outputFormat": "显示所有预测，按在最后比赛中出现的可能性从高到低排序。如果预测的可能性相同，则按输入中的顺序显示。", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6940", "type": "P", "difficulty": 5, "samples": [["2\n4 7\n9 8\n14 17\n19 18\n", "2\n1\n"], ["2\n4 7\n14 17\n9 8\n19 18\n", "1\n2\n"], ["2\n4 8\n9 7\n14 18\n19 17\n", "syntax error\n"], ["3\n1 1\n4 8\n8 4\n10 6\n6 10\n10 10\n", "syntax error\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2017", "Special Judge", "扫描线", "ICPC", "WF"], "title": "[ICPC 2017 WF] Visual Python++", "background": "", "description": "\n\nIn the recently proposed Visual Python++ programming language, a block of statements is represented as a rectangle of characters with top-left corner in row $r_{1}$ and column $c_{1},$ and bottom-right corner in row $r_{2}$ and column $c_{2}.$ All characters at locations $(r , c)$ with $r_{1} \\le r \\le r_{2}$ and $c_{1} \\le c \\le c_{2}$ are then considered to belong to that block. Among these locations, the ones with $r = r_{1}$ or $r = r_{2}$ or $c = c_{1}$ or $c = c_{2}$ are called a border.\n\nStatement blocks can be nested (rectangles contained in other rectangles) to an arbitrary level. In a syntactically correct program, every two statement blocks are either nested (one contained in the other) or disjoint (not overlapping). In both cases, their borders may not overlap.\n\nProgrammers are not expected to draw the many rectangles contained in a typical program $-$ this takes too long, and Visual $Pytho_n++$ would not have a chance to become the next ICPC programming language. So a programmer only has to put one character $‘p'$ in the top-left corner of the rectangle and one character $‘y'$ in the bottom-right corner. The parser will automatically match up the appropriate corners to obtain the nesting structure of the program.\n\nYour team has just been awarded a five-hour contract to develop this part of the parser.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $n (1 \\le n \\le 10^{5}),$ the number of corner pairs. Each of the next $n$ lines contains two integers $r$ and $c (1 \\le r , c \\le 10^{9}),$ specifying that there is a top-left corner in row $r$ and column $c$ of the program you are parsing. Following that are $n$ lines specifying the bottom-right corners in the same way. All corner locations are distinct.\n\n", "outputFormat": "\n\nDisplay $n$ lines, each containing one integer. A number $j$ in line $i$ means that the $i^{th}$ top-left corner and the $j^{th}$ bottom-right corner form one rectangle. Top-left and bottom-right corners are each numbered from $1$ to $n$ in the order they appear in the input. The output must be a permutation of the numbers from $1$ to $n$ such that the matching results in properly nested rectangles. If there is more than one valid matching, any one will be accepted. If no such matching exists, display syntax error.\n\n", "hint": "Time limit: 5 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2017 WF] Visual Python++", "background": "", "description": "\n\nIn the recently proposed Visual Python++ programming language, a block of statements is represented as a rectangle of characters with top-left corner in row $r_{1}$ and column $c_{1},$ and bottom-right corner in row $r_{2}$ and column $c_{2}.$ All characters at locations $(r , c)$ with $r_{1} \\le r \\le r_{2}$ and $c_{1} \\le c \\le c_{2}$ are then considered to belong to that block. Among these locations, the ones with $r = r_{1}$ or $r = r_{2}$ or $c = c_{1}$ or $c = c_{2}$ are called a border.\n\nStatement blocks can be nested (rectangles contained in other rectangles) to an arbitrary level. In a syntactically correct program, every two statement blocks are either nested (one contained in the other) or disjoint (not overlapping). In both cases, their borders may not overlap.\n\nProgrammers are not expected to draw the many rectangles contained in a typical program $-$ this takes too long, and Visual $Pytho_n++$ would not have a chance to become the next ICPC programming language. So a programmer only has to put one character $‘p'$ in the top-left corner of the rectangle and one character $‘y'$ in the bottom-right corner. The parser will automatically match up the appropriate corners to obtain the nesting structure of the program.\n\nYour team has just been awarded a five-hour contract to develop this part of the parser.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $n (1 \\le n \\le 10^{5}),$ the number of corner pairs. Each of the next $n$ lines contains two integers $r$ and $c (1 \\le r , c \\le 10^{9}),$ specifying that there is a top-left corner in row $r$ and column $c$ of the program you are parsing. Following that are $n$ lines specifying the bottom-right corners in the same way. All corner locations are distinct.\n\n", "outputFormat": "\n\nDisplay $n$ lines, each containing one integer. A number $j$ in line $i$ means that the $i^{th}$ top-left corner and the $j^{th}$ bottom-right corner form one rectangle. Top-left and bottom-right corners are each numbered from $1$ to $n$ in the order they appear in the input. The output must be a permutation of the numbers from $1$ to $n$ such that the matching results in properly nested rectangles. If there is more than one valid matching, any one will be accepted. If no such matching exists, display syntax error.\n\n", "hint": "Time limit: 5 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2017 WF] Visual Python++", "background": null, "description": "在最近提出的 Visual Python++ 编程语言中，一个语句块被表示为一个字符矩形，其左上角位于第 $r_{1}$ 行第 $c_{1}$ 列，右下角位于第 $r_{2}$ 行第 $c_{2}$ 列。所有满足 $r_{1} \\le r \\le r_{2}$ 且 $c_{1} \\le c \\le c_{2}$ 的位置 $(r , c)$ 的字符都被认为属于该语句块。在这些位置中，满足 $r = r_{1}$ 或 $r = r_{2}$ 或 $c = c_{1}$ 或 $c = c_{2}$ 的位置称为边界。\n\n语句块可以嵌套（一个矩形包含在另一个矩形内）到任意深度。在一个语法正确的程序中，任意两个语句块要么是嵌套的（一个包含另一个），要么是不相交的（不重叠）。在这两种情况下，它们的边界都不能重叠。\n\n程序员不需要画出典型程序中的许多矩形——这太耗时了，而且 Visual Python++ 将没有机会成为下一届 ICPC 编程语言。因此，程序员只需要在矩形的左上角放置一个字符 `「`，在右下角放置一个字符 `」`。语法分析器将自动匹配相应的角以获取程序的嵌套结构。\n\n你的团队刚刚获得了一份五小时的合同，来开发语法分析器的这一部分。", "inputFormat": "输入的第一行包含一个整数 $n (1 \\le n \\le 10^{5})$，表示角对的数量。\n\n接下来的 $n$ 行每行包含两个整数 $r$ 和 $c (1 \\le r , c \\le 10^{9})$，表示在正在解析的程序中，第 $r$ 行第 $c$ 列有一个左上角。\n\n接下来 $n$ 行，以相同的方式指定右下角。所有角的位置都是不同的。", "outputFormat": "输出 $n$ 行，每行包含一个整数。第 $i$ 行的数字 $j$ 表示第 $i$ 个左上角与第 $j$ 个右下角组成一个矩形。左上角和右下角均按照它们在输入中出现的顺序从 $1$ 到 $n$ 编号。输出必须是 $1$ 到 $n$ 的一个排列，使得匹配后的矩形正确嵌套。如果有多个有效的匹配，输出任何一个均可。如果不存在这样的匹配，则输出 `syntax error`。", "hint": "翻译由 DeepSeek R1 完成", "locale": "zh-CN"}}}
{"pid": "P6941", "type": "P", "difficulty": 5, "samples": [["8 4\n1000\n0 1 0 900 0.2\n0 2 100 500 1.0\n2 1 500 700 1.0\n2 1 501 701 0.1\n0 3 200 400 0.5\n3 1 500 800 0.1\n3 0 550 650 0.9\n0 1 700 900 0.1\n", "0.3124\n"], ["4 2\n2\n0 1 0 1 0.5\n0 1 0 1 0.5\n0 1 1 2 0.4\n0 1 1 2 0.2\n", "0.7\n"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2018 WF] Catch the Plane", "background": "", "description": "\n\nYour plane to the ICPC Finals departs in a short time, and the only way to get to the airport is by bus. Unfortunately, some of the bus drivers are considering going on strike, so you do not know whether you can get to the airport on time. Your goal is to plan your journey in such a way as to maximize the probability of catching your plane.\n\nYou have a detailed map of the city, which includes all the bus stations. You are at station $0$ and the airport is at station $1$ . You also have a complete schedule of when each bus leaves its start station and arrives at its destination station. Additionally, for each bus you know the probability that it is actually going to run as scheduled, as opposed to its driver going on strike and taking the bus out of service. Assume all these events are independent. That is, the probability of a given bus running as planned does not change if you know whether any of the other buses run as planned.\n\nIf you arrive before the departure time of a bus, you can transfer to that bus. But if you arrive exactly at the departure time, you will not have enough time to get on the bus. You cannot verify ahead of time whether a given bus will run as planned $-$ you will find out only when you try to get on the bus. So if two or more buses leave a station at the same time, you can try to get on only one of them.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15689/1.png)\n\nFigure A.1 : Bus schedule corresponding to Sample Input $1$ .\n\nConsider the bus schedule shown in Figure A.1 . It lists the start and destination stations of several bus routes along with the departure and arrival times. You have written next to some of these the probability that that route will run. Bus routes with no probability written next to them have a $100\\%$ chance of running. You can try catching the first listed bus. If it runs, it will take you straight to the airport, and you can stop worrying. If it does not, things get more tricky. You could get on the second listed bus to station $2$ . It is certain to leave, but you would be too late to catch the third listed bus which otherwise would have delivered you to the airport on time. The fourth listed bus $-$ which you can catch $-$ has only a $0$ . $1$ probability of actually running. That is a bad bet, so it is better to stay at station $0$ and wait for the fifth listed bus. If you catch it, you can try to get onto the sixth listed bus to the airport; if that does not run, you still have the chance of returning to station $0$ and catching the last listed bus straight to the airport.\n\n", "inputFormat": "\n\nThe first line of input contains two integers $m (1 \\le m \\le 10^{6})$ and $n (2 \\le n \\le 10^{6}),$ denoting the number of buses and the number of stations in the city. The next line contains one integer $k (1 \\le k \\le 10^{18}),$ denoting the time by which you must arrive at the airport.\n\nEach of the next $m$ lines describes one bus. Each line contains integers a and $b (0 \\le $ a , $b < n$ , a $≠ b)$ , denoting the start and destination stations for the bus. Next are integers $s$ and $t (0 \\le s < t \\le k)$ , giving the departure time from station a and the arrival time at station $b$ . The last value on the line is $p (0 \\le p \\le 1$ , with at most $10$ digits after the decimal point), which denotes the probability that the bus will run as planned.\n\n", "outputFormat": "\n\nDisplay the probability that you will catch your plane, assuming you follow an optimal course of action. Your answer must be correct to within an absolute error of $10^{−6}.$\n\n", "hint": "Time limit: 10 s, Memory limit: 1024 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 WF] Catch the Plane", "background": "", "description": "\n\nYour plane to the ICPC Finals departs in a short time, and the only way to get to the airport is by bus. Unfortunately, some of the bus drivers are considering going on strike, so you do not know whether you can get to the airport on time. Your goal is to plan your journey in such a way as to maximize the probability of catching your plane.\n\nYou have a detailed map of the city, which includes all the bus stations. You are at station $0$ and the airport is at station $1$ . You also have a complete schedule of when each bus leaves its start station and arrives at its destination station. Additionally, for each bus you know the probability that it is actually going to run as scheduled, as opposed to its driver going on strike and taking the bus out of service. Assume all these events are independent. That is, the probability of a given bus running as planned does not change if you know whether any of the other buses run as planned.\n\nIf you arrive before the departure time of a bus, you can transfer to that bus. But if you arrive exactly at the departure time, you will not have enough time to get on the bus. You cannot verify ahead of time whether a given bus will run as planned $-$ you will find out only when you try to get on the bus. So if two or more buses leave a station at the same time, you can try to get on only one of them.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15689/1.png)\n\nFigure A.1 : Bus schedule corresponding to Sample Input $1$ .\n\nConsider the bus schedule shown in Figure A.1 . It lists the start and destination stations of several bus routes along with the departure and arrival times. You have written next to some of these the probability that that route will run. Bus routes with no probability written next to them have a $100\\%$ chance of running. You can try catching the first listed bus. If it runs, it will take you straight to the airport, and you can stop worrying. If it does not, things get more tricky. You could get on the second listed bus to station $2$ . It is certain to leave, but you would be too late to catch the third listed bus which otherwise would have delivered you to the airport on time. The fourth listed bus $-$ which you can catch $-$ has only a $0$ . $1$ probability of actually running. That is a bad bet, so it is better to stay at station $0$ and wait for the fifth listed bus. If you catch it, you can try to get onto the sixth listed bus to the airport; if that does not run, you still have the chance of returning to station $0$ and catching the last listed bus straight to the airport.\n\n", "inputFormat": "\n\nThe first line of input contains two integers $m (1 \\le m \\le 10^{6})$ and $n (2 \\le n \\le 10^{6}),$ denoting the number of buses and the number of stations in the city. The next line contains one integer $k (1 \\le k \\le 10^{18}),$ denoting the time by which you must arrive at the airport.\n\nEach of the next $m$ lines describes one bus. Each line contains integers a and $b (0 \\le $ a , $b < n$ , a $≠ b)$ , denoting the start and destination stations for the bus. Next are integers $s$ and $t (0 \\le s < t \\le k)$ , giving the departure time from station a and the arrival time at station $b$ . The last value on the line is $p (0 \\le p \\le 1$ , with at most $10$ digits after the decimal point), which denotes the probability that the bus will run as planned.\n\n", "outputFormat": "\n\nDisplay the probability that you will catch your plane, assuming you follow an optimal course of action. Your answer must be correct to within an absolute error of $10^{−6}.$\n\n", "hint": "Time limit: 10 s, Memory limit: 1024 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 WF] Catch the Plane", "background": "", "description": "你的飞机即将起飞去参加 ICPC 总决赛，而去机场的唯一方式是乘坐公交车。不幸的是，一些公交车司机正在考虑罢工，所以你不知道是否能按时到达机场。你的目标是规划你的行程，以最大化赶上飞机的概率。\n\n你有一张城市的详细地图，包括所有的公交车站。你现在在车站 $0$，机场在车站 $1$。你还有一份完整的公交车时刻表，记录了每辆公交车从起始站出发和到达目的站的时间。此外，对于每辆公交车，你知道它按计划运行的概率，而不是司机罢工导致公交车停运。假设所有这些事件是独立的。也就是说，某辆公交车按计划运行的概率不会因为你知道其他公交车是否按计划运行而改变。\n\n如果你在公交车出发时间之前到达，你可以转乘那辆公交车。但如果你正好在出发时间到达，你将没有足够的时间上车。你无法提前验证某辆公交车是否按计划运行——只有当你尝试上车时才会知道。所以如果两辆或更多公交车在同一时间离开一个车站，你只能尝试上其中一辆。\n\n考虑图 A.1 中显示的公交车时刻表。它列出了几条公交线路的起始站和目的站以及出发和到达时间。你在其中一些旁边写下了该线路运行的概率。没有写概率的公交线路有 $100\\%$ 的运行概率。你可以尝试赶上第一辆列出的公交车。如果它按计划运行，它会直接带你到机场，你就可以不再担心。如果没有，事情就会变得更加棘手。你可以乘坐第二辆列出的公交车到车站 $2$。它肯定会出发，但你会太晚而赶不上第三辆列出的公交车，否则它会按时把你送到机场。第四辆列出的公交车——你可以赶上——实际上只有 $0.1$ 的运行概率。这是一个糟糕的选择，所以最好留在车站 $0$ 等待第五辆列出的公交车。如果你赶上了它，你可以尝试搭乘第六辆列出的公交车去机场；如果那辆车不运行，你仍然有机会返回车站 $0$ 并赶上最后一辆直达机场的公交车。", "inputFormat": "输入的第一行包含两个整数 $m (1 \\le m \\le 10^{6})$ 和 $n (2 \\le n \\le 10^{6})$，表示城市中的公交车数量和车站数量。下一行包含一个整数 $k (1 \\le k \\le 10^{18})$，表示你必须到达机场的时间。\n\n接下来的 $m$ 行描述一辆公交车。每行包含整数 $a$ 和 $b (0 \\le a, b < n, a \neq b)$，表示公交车的起始站和目的站。接下来是整数 $s$ 和 $t (0 \\le s < t \\le k)$，给出从车站 $a$ 出发和到达车站 $b$ 的时间。行的最后一个值是 $p (0 \\le p \\le 1$，小数点后最多有 $10$ 位)，表示公交车按计划运行的概率。", "outputFormat": "显示你赶上飞机的概率，假设你遵循最佳行动方案。你的答案必须在绝对误差 $10^{-6}$ 范围内正确。", "hint": "时间限制：10 秒，内存限制：1024 MB。\n\n特别裁判提供者：@[shenyouran](\\/user\\/137367)。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6942", "type": "P", "difficulty": 3, "samples": [["please sit spot. sit spot, sit. spot here now here.\n", "please, sit spot. sit spot, sit. spot, here now, here.\n"], ["one, two. one tree. four tree. four four. five four. six five.\n", "one, two. one, tree. four, tree. four, four. five, four. six five.\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "ICPC", "WF"], "title": "[ICPC 2018 WF] Comma Sprinkler", "background": "", "description": "As practice will tell you, the English rules for comma placement are complex, frustrating, and often ambiguous. Many people, even the English, will, in practice, ignore them, and, apply custom rules, or, no rules, at all.\n\nDoctor Comma Sprinkler solved this issue by developing a set of rules that sprinkles commas in a sentence with no ambiguity and little simplicity. In this problem you will help Dr. Sprinkler by producing an algorithm to automatically apply her rules.\n\nDr. Sprinkler's rules for adding commas to an existing piece of text are as follows:\n\nIf a word anywhere in the text is preceded by a comma, find all occurrences of that word in the text, and put a comma before each of those occurrences, except in the case where such an occurrence is the first word of a sentence or already preceded by a comma.\n\nIf a word anywhere in the text is succeeded by a comma, find all occurrences of that word in the text, and put a comma after each of those occurrences, except in the case where such an occurrence is the last word of a sentence or already succeeded by a comma.\n\nApply rules $1$ and $2$ repeatedly until no new commas can be added using either of them.\n\nAs an example, consider the text\n\nplease sit spot. sit spot, sit. spot here now here.\n\nBecause there is a comma after spot in the second sentence, a comma should be added after spot in the third sentence as well (but not the first sentence, since it is the last word of that sentence). Also, because there is a comma before the word sit in the second sentence, one should be added before that word in the first sentence (but no comma is added before the word sit beginning the second sentence because it is the first word of that sentence). Finally, notice that once a comma is added after spot in the third sentence, there exists a comma before the first occurrence of the word here. Therefore, a comma is also added before the other occurrence of the word here. There are no more commas to be added so the final result is\n\nplease, sit spot. sit spot, sit. spot, here now, here.\n\n", "inputFormat": "\n\nThe input contains one line of text, containing at least $2$ characters and at most $1 000 000$ characters. Each character is either a lowercase letter, a comma, a period, or a space. We define a word to be a maximal sequence of letters within the text. The text adheres to the following constraints:\n\nThe text begins with a word.\n\nBetween every two words in the text, there is either a single space, a comma followed by a space, or a period followed by a space (denoting the end of a sentence and the beginning of a new one).\n\nThe last word of the text is followed by a period with no trailing space.\n\n", "outputFormat": "\n\nDisplay the result after applying Dr. Sprinkler's algorithm to the original text.\n\n", "hint": "Time limit: 8 s, Memory limit: 1024 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 WF] Comma Sprinkler", "background": "", "description": "As practice will tell you, the English rules for comma placement are complex, frustrating, and often ambiguous. Many people, even the English, will, in practice, ignore them, and, apply custom rules, or, no rules, at all.\n\nDoctor Comma Sprinkler solved this issue by developing a set of rules that sprinkles commas in a sentence with no ambiguity and little simplicity. In this problem you will help Dr. Sprinkler by producing an algorithm to automatically apply her rules.\n\nDr. Sprinkler's rules for adding commas to an existing piece of text are as follows:\n\nIf a word anywhere in the text is preceded by a comma, find all occurrences of that word in the text, and put a comma before each of those occurrences, except in the case where such an occurrence is the first word of a sentence or already preceded by a comma.\n\nIf a word anywhere in the text is succeeded by a comma, find all occurrences of that word in the text, and put a comma after each of those occurrences, except in the case where such an occurrence is the last word of a sentence or already succeeded by a comma.\n\nApply rules $1$ and $2$ repeatedly until no new commas can be added using either of them.\n\nAs an example, consider the text\n\nplease sit spot. sit spot, sit. spot here now here.\n\nBecause there is a comma after spot in the second sentence, a comma should be added after spot in the third sentence as well (but not the first sentence, since it is the last word of that sentence). Also, because there is a comma before the word sit in the second sentence, one should be added before that word in the first sentence (but no comma is added before the word sit beginning the second sentence because it is the first word of that sentence). Finally, notice that once a comma is added after spot in the third sentence, there exists a comma before the first occurrence of the word here. Therefore, a comma is also added before the other occurrence of the word here. There are no more commas to be added so the final result is\n\nplease, sit spot. sit spot, sit. spot, here now, here.\n\n", "inputFormat": "\n\nThe input contains one line of text, containing at least $2$ characters and at most $1 000 000$ characters. Each character is either a lowercase letter, a comma, a period, or a space. We define a word to be a maximal sequence of letters within the text. The text adheres to the following constraints:\n\nThe text begins with a word.\n\nBetween every two words in the text, there is either a single space, a comma followed by a space, or a period followed by a space (denoting the end of a sentence and the beginning of a new one).\n\nThe last word of the text is followed by a period with no trailing space.\n\n", "outputFormat": "\n\nDisplay the result after applying Dr. Sprinkler's algorithm to the original text.\n\n", "hint": "Time limit: 8 s, Memory limit: 1024 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 WF] Comma Sprinkler", "background": null, "description": "正如实践会告诉你的那样，英语中逗号的使用规则复杂、令人沮丧且常常模棱两可。许多人，甚至是英语母语者，在实践中会忽略它们，并应用自定义规则，或者根本不使用规则。\n\n逗号洒水器博士通过制定一套规则解决了这个问题，这些规则在句子中洒上逗号，既不含糊也不简单。在这个问题中，你将帮助洒水器博士编写一个算法来自动应用她的规则。\n\n洒水器博士为现有文本添加逗号的规则如下：\n\n1. 如果文本中的某个单词前面有逗号，则找到该单词在文本中的所有出现位置，并在每个出现位置前加上逗号，除非该出现位置是句子的第一个单词或已经有逗号在前。\n\n2. 如果文本中的某个单词后面有逗号，则找到该单词在文本中的所有出现位置，并在每个出现位置后加上逗号，除非该出现位置是句子的最后一个单词或已经有逗号在后。\n\n3. 重复应用规则 $1$ 和规则 $2$，直到无法再使用它们添加新的逗号为止。\n\n例如，考虑以下文本：\n\n```\nplease sit spot. sit spot, sit. spot here now here.\n```\n\n因为在第二个句子中，spot 后面有逗号，所以在第三个句子中的 spot 后面也应加上逗号（但不是第一个句子，因为它是该句子的最后一个单词）。此外，因为在第二个句子中，sit 前面有逗号，所以在第一个句子中的该单词前也应加上逗号（但不在第二个句子开头的 sit 前加逗号，因为它是该句子的第一个单词）。最后，注意到一旦在第三个句子中的 spot 后加上逗号，here 的第一个出现位置前就有逗号。因此，也在 here 的其他出现位置前加上逗号。没有更多逗号可以添加，所以最终结果是：\n\n```\nplease, sit spot. sit spot, sit. spot, here now, here.\n```", "inputFormat": "输入包含一行文本，至少包含 $2$ 个字符，最多包含 $10^6$ 个字符。每个字符均为小写字母、逗号、句号或空格。我们定义一个单词为文本中最大长度的字母序列。文本遵循以下约束：\n\n* 文本以一个单词开头。\n\n* 文本中的每两个单词之间，要么有一个空格，要么有一个逗号后跟一个空格，要么有一个句号后跟一个空格（表示一个句子的结束和新句子的开始）。\n\n* 文本的最后一个单词后面跟一个句号，没有尾随空格。", "outputFormat": "输出应用洒水器博士算法后的文本结果。", "hint": "时间限制：原题 $8$ 秒，依据评测机性能改为 $6$ 秒。\n\n内存限制：$\\text{1024MB}$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6943", "type": "P", "difficulty": 7, "samples": [["3\n1 2 5\n3 1 5\n2 1\n5 0\n1 3\n", "15\n"], ["6\n1 2 2\n1 3 5\n1 4 1\n2 5 5\n2 6 1\n0 0\n1 0\n2 1\n2 1\n0 1\n0 1\n", "9\n"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "ICPC", "WF"], "title": "[ICPC 2018 WF] Conquer The World", "background": "", "description": "\n\nBwahahahahaha!!! Your nemesis, the dashingly handsome spy Waco Powers, has at last fallen to your secret volcano base's deathtraps (or so you assume, being a little too busy to witness it firsthand). At long last, you are all set to CONQUER THE WORLD!\n\nNothing will stand in your way! Well, nothing except a minor problem of logistics. Your evil armies have announced that they will not continue carving their relentless path of destruction across the puny nations of the world without being paid. And unfortunately you are running low on cash $-$ a volcano lair has many wonderful qualities, but `reasonably affordable` is not one of them. You have had to pull funds from the travel budget to pay your ungrateful underlings. Now you are not sure how you will actually get your armies into position to CONQUER THE WORLD.\n\nYou have a map of the nations of the world and all your available transport routes between them. Each route connects two nations and has a fixed cost per army that uses it. The routes are laid out such that there is exactly one way to travel between any two nations. You know the current position of each of your armies and how many you will need to place permanently in each nation in order to subjugate it. How can you move the armies into place as cheaply as possible so you can CONQUER THE WORLD?\n\n", "inputFormat": "\n\nThe first line of input contains an integer $n (1 \\le n \\le 250 000)$ , the number of nations. This is followed by $n − 1$ lines, each containing three integers $u , v$ , and $c (1 \\le u , v \\le n , 1 \\le c \\le 10^{6}),$ indicating that there is a bidirectional route connecting nations $u$ and $v$ , which costs $c$ per army to use.\n\nFinally, another $n$ lines follow, the $i^{th}$ of which contains two non-negative integers $x_{i}$ and $y_{i},$ indicating that there are currently $x_{i}$ armies in nation $i$ , and you need at least $y_{i}$ armies to end up in that nation in the final configuration. The total number of armies (the sum of the $x_{i}$ values) is at least the sum of the $y_{i}$ values, and no more than $10^{6}.$\n\n", "outputFormat": "\n\nDisplay the minimum cost to move your armies such that there are at least $y_{i}$ armies in nation $i$ for all $i$ .\n\n", "hint": "Time limit: 8 s, Memory limit: 1024 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 WF] Conquer The World", "background": "", "description": "\n\nBwahahahahaha!!! Your nemesis, the dashingly handsome spy Waco Powers, has at last fallen to your secret volcano base's deathtraps (or so you assume, being a little too busy to witness it firsthand). At long last, you are all set to CONQUER THE WORLD!\n\nNothing will stand in your way! Well, nothing except a minor problem of logistics. Your evil armies have announced that they will not continue carving their relentless path of destruction across the puny nations of the world without being paid. And unfortunately you are running low on cash $-$ a volcano lair has many wonderful qualities, but `reasonably affordable` is not one of them. You have had to pull funds from the travel budget to pay your ungrateful underlings. Now you are not sure how you will actually get your armies into position to CONQUER THE WORLD.\n\nYou have a map of the nations of the world and all your available transport routes between them. Each route connects two nations and has a fixed cost per army that uses it. The routes are laid out such that there is exactly one way to travel between any two nations. You know the current position of each of your armies and how many you will need to place permanently in each nation in order to subjugate it. How can you move the armies into place as cheaply as possible so you can CONQUER THE WORLD?\n\n", "inputFormat": "\n\nThe first line of input contains an integer $n (1 \\le n \\le 250 000)$ , the number of nations. This is followed by $n − 1$ lines, each containing three integers $u , v$ , and $c (1 \\le u , v \\le n , 1 \\le c \\le 10^{6}),$ indicating that there is a bidirectional route connecting nations $u$ and $v$ , which costs $c$ per army to use.\n\nFinally, another $n$ lines follow, the $i^{th}$ of which contains two non-negative integers $x_{i}$ and $y_{i},$ indicating that there are currently $x_{i}$ armies in nation $i$ , and you need at least $y_{i}$ armies to end up in that nation in the final configuration. The total number of armies (the sum of the $x_{i}$ values) is at least the sum of the $y_{i}$ values, and no more than $10^{6}.$\n\n", "outputFormat": "\n\nDisplay the minimum cost to move your armies such that there are at least $y_{i}$ armies in nation $i$ for all $i$ .\n\n", "hint": "Time limit: 8 s, Memory limit: 1024 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 WF] Conquer The World", "background": "", "description": "哇哈哈哈哈哈！！！你的宿敌，英俊的间谍 Waco Powers，终于在你的秘密火山基地的死亡陷阱中落败（或者你是这样假设的，因为你太忙了，没能亲眼目睹）。终于，你准备好征服世界了！\n\n没有什么能阻挡你！嗯，除了一个小小的后勤问题。你的邪恶军队宣布，如果不支付报酬，他们将不会继续在世界上那些微不足道的国家中肆意破坏。不幸的是，你的现金快用完了——火山基地有很多优点，但“价格合理”不是其中之一。你不得不从旅行预算中抽出资金来支付你那些忘恩负义的下属。现在你不确定如何才能真正将你的军队部署到位以征服世界。\n\n你有一张世界各国的地图，以及它们之间所有可用的运输路线。每条路线连接两个国家，并且每支军队使用它都有固定的费用。路线的布局使得在任何两个国家之间恰好有一条路径。你知道每支军队的当前位置，以及为了征服每个国家需要永久驻扎在那里的军队数量。你如何才能以最低的成本将军队部署到位，以便征服世界？", "inputFormat": "输入的第一行包含一个整数 $n (1 \\le n \\le 250000)$，表示国家的数量。接下来是 $n - 1$ 行，每行包含三个整数 $u, v$ 和 $c (1 \\le u, v \\le n, 1 \\le c \\le 10^{6})$，表示有一条连接国家 $u$ 和 $v$ 的双向路线，每支军队使用该路线的费用为 $c$。\n\n最后，还有 $n$ 行，第 $i$ 行包含两个非负整数 $x_{i}$ 和 $y_{i}$，表示当前在国家 $i$ 有 $x_{i}$ 支军队，并且在最终配置中需要至少 $y_{i}$ 支军队驻扎在该国家。军队的总数量（所有 $x_{i}$ 值的和）至少是所有 $y_{i}$ 值的和，并且不超过 $10^{6}$。", "outputFormat": "显示移动军队的最低成本，使得对于所有 $i$，国家 $i$ 至少有 $y_{i}$ 支军队。", "hint": "时间限制：8 秒，内存限制：1024 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6944", "type": "P", "difficulty": 6, "samples": [["2 3 1\n", "3.5\n"], ["3 3 2\n", "4.9\n"], ["5 10 3\n", "12.2567433\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2018 WF] Gem Island", "background": "", "description": "\n\nGem Island is a tiny island in the middle of the Pacific Ocean. Until recently, it was known as one of the poorest, but also most peaceful, places on Earth. Today, it is neither poor nor peaceful. What happened?\n\nOne sunny morning, not too long ago, all inhabitants of Gem Island woke up to a surprise. That morning, each of them suddenly held one sparkling gem in their hand. The gems had magically appeared overnight. This was cause for much rejoicing $-$ everybody was suddenly rich, they could finally afford all the things they had ever dreamed of, and the name of their island made so much more sense now.\n\nThe next morning, one of the inhabitants woke up to another surprise $-$ her gem had magically split into two gems! The same thing happened on each of the following nights, when exactly one of the gems (apparently uniformly at random among all the gems on the island) would split into two.\n\nAfter a while, the inhabitants of Gem Island possessed a widely varying number of gems. Some had a lot and many had only a few. How come some inhabitants had more gems than others? Did they cheat, were they just lucky, or was something else at work?\n\nThe island elders have asked for your help. They want you to determine if the uneven distribution of gems is explained by pure chance. If so, that would greatly reduce tensions on the island.\n\nThe island has $n$ inhabitants. You are to determine the gem distribution after $d$ nights of gem splitting. In particular, you are interested in the expected number of gems collectively held by the $r$ people with the largest numbers of gems. More formally, suppose that after $d$ nights the numbers of gems held by the $n$ inhabitants are listed in non-increasing order as $a_{1} \\ge a_{2} \\ge $ . . . $ \\ge a_{n}.$ What is the expected value of $a_{1} + · · · + a_{r}?$\n\n", "inputFormat": "\n\nThe input consists of a single line containing the three integers $n , d$ , and $r (1 \\le n , d \\le 500 , 1 \\le r \\le n)$ , as described in the problem statement above.\n\n", "outputFormat": "\n\nDisplay the expected number of gems that the top $r$ inhabitants hold after $d$ nights, with an absolute or relative error of at most $10^{−6}.$\n\n", "hint": "Time limit: 3 s, Memory limit: 1024 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 WF] Gem Island", "background": "", "description": "\n\nGem Island is a tiny island in the middle of the Pacific Ocean. Until recently, it was known as one of the poorest, but also most peaceful, places on Earth. Today, it is neither poor nor peaceful. What happened?\n\nOne sunny morning, not too long ago, all inhabitants of Gem Island woke up to a surprise. That morning, each of them suddenly held one sparkling gem in their hand. The gems had magically appeared overnight. This was cause for much rejoicing $-$ everybody was suddenly rich, they could finally afford all the things they had ever dreamed of, and the name of their island made so much more sense now.\n\nThe next morning, one of the inhabitants woke up to another surprise $-$ her gem had magically split into two gems! The same thing happened on each of the following nights, when exactly one of the gems (apparently uniformly at random among all the gems on the island) would split into two.\n\nAfter a while, the inhabitants of Gem Island possessed a widely varying number of gems. Some had a lot and many had only a few. How come some inhabitants had more gems than others? Did they cheat, were they just lucky, or was something else at work?\n\nThe island elders have asked for your help. They want you to determine if the uneven distribution of gems is explained by pure chance. If so, that would greatly reduce tensions on the island.\n\nThe island has $n$ inhabitants. You are to determine the gem distribution after $d$ nights of gem splitting. In particular, you are interested in the expected number of gems collectively held by the $r$ people with the largest numbers of gems. More formally, suppose that after $d$ nights the numbers of gems held by the $n$ inhabitants are listed in non-increasing order as $a_{1} \\ge a_{2} \\ge $ . . . $ \\ge a_{n}.$ What is the expected value of $a_{1} + · · · + a_{r}?$\n\n", "inputFormat": "\n\nThe input consists of a single line containing the three integers $n , d$ , and $r (1 \\le n , d \\le 500 , 1 \\le r \\le n)$ , as described in the problem statement above.\n\n", "outputFormat": "\n\nDisplay the expected number of gems that the top $r$ inhabitants hold after $d$ nights, with an absolute or relative error of at most $10^{−6}.$\n\n", "hint": "Time limit: 3 s, Memory limit: 1024 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 WF] Gem Island", "background": "", "description": "宝石岛是位于太平洋中部的一个小岛。直到最近，它还被认为是地球上最贫穷但也是最和平的地方之一。如今，它既不贫穷也不和平。发生了什么？\n\n不久前的一个晴朗的早晨，宝石岛的所有居民都醒来时发现了一个惊喜。那天早上，他们每个人手中突然多了一颗闪闪发光的宝石。这些宝石在一夜之间神奇地出现了。这引起了极大的欢呼——每个人突然变得富有，他们终于可以买到他们梦寐以求的一切，他们岛的名字现在也更有意义了。\n\n第二天早上，其中一位居民醒来时又发现了一个惊喜——她的宝石神奇地分裂成了两颗！接下来的每个晚上，岛上的一颗宝石（显然是从岛上的所有宝石中均匀随机选择的）都会分裂成两颗。\n\n过了一段时间，宝石岛的居民拥有的宝石数量差异很大。有些人有很多，而许多人只有很少。为什么有些居民拥有的宝石比其他人多？他们是作弊了吗？他们只是幸运吗？还是有其他原因？\n\n岛上的长老们请求你的帮助。他们希望你能确定宝石分布的不均衡是否可以用纯粹的偶然性来解释。如果是这样的话，这将大大减少岛上的紧张局势。\n\n岛上有 $n$ 位居民。你需要确定经过 $d$ 个夜晚宝石分裂后的宝石分布。特别地，你感兴趣的是拥有最多宝石的 $r$ 个人所持有的宝石总数的期望值。更正式地说，假设经过 $d$ 个夜晚后，$n$ 位居民持有的宝石数量按非递增顺序排列为 $a_{1} \\ge a_{2} \\ge \\ldots \\ge a_{n}$。那么 $a_{1} + \\cdots + a_{r}$ 的期望值是多少？", "inputFormat": "输入由一行组成，包含三个整数 $n, d$ 和 $r (1 \\le n, d \\le 500, 1 \\le r \\le n)$，如题目描述所述。", "outputFormat": "输出前 $r$ 位居民在 $d$ 个夜晚后持有的宝石数量的期望值，绝对误差或相对误差最多为 $10^{-6}$。", "hint": "时间限制：3 秒，内存限制：1024 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6945", "type": "P", "difficulty": 6, "samples": [["4 1 100 55 1 1\n10 40 60 10\n", "0 1 1 1\n"], ["4 4 100 55 1 1\n0 10 20 30\n10 20 30 40\n20 30 200 50\n30 40 50 60\n", "0 1 1 2\n1 1 1 2\n1 1 X 2\n2 2 2 3\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "ICPC", "WF"], "title": "[ICPC 2018 WF] Getting a Jump on Crime", "background": "", "description": "\n\nYour friend Robin is a superhero. When you first found out about this, you figured `everybody needs a hobby, and this seems more exciting than stamp collecting,` but now you are really thankful that somebody is doing something about the crime in your hometown.\n\nEvery night, Robin patrols the city by jumping from roof to roof and watching what goes on below. Naturally, superheroes need to respond to crises immediately, so Robin asked you for help in figuring out how to get around your hometown quickly.\n\nYour hometown is built on a square grid, where each block is $w \\times w$ meters. Each block is filled by a single building. The buildings may have different heights (see Figure E.1) . To get from one building to another (not necessarily adjacent) building, Robin makes a single jump from the center of the roof of the first building to the center of the roof of the second building. Robin cannot change direction while in the air, but can choose the angle at which to lift off.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15693/1.png)\n\nFigure E.1 : Cross-section of buildings corresponding to the first sample input. Buildings are shown in black, and the jump from the roof at $(1 , 1)$ to the roof at $(4 , 1)$ is shown with a green line.\n\nOf course, Robin only wants to perform jumps without colliding with any buildings. Such collisions do little damage to a superhero, but building owners tend to get irritated when someone crashes through their windows. You explain the physics to Robin: `All your jumps are done with the same initial velocity $v$ , which has a horizontal component $v_{d}$ towards the destination and vertical component $v_{h}$ upwards, so $v_{d}^{2} + v_{h}^{2} = v^{2}$ . As you travel, your horizontal velocity stays constant $(v_{d}(t) = v_{d}),$ but your vertical velocity is affected by gravity $(v_{h}(t) = v_{h} − t · g)$ , where $g = 9$ . $80665 m/s^{2}$ in your hometown. Naturally, your cape allows you to ignore the effects of air resistance. This allows you to determine your flight path and $ \\cdots `$ at which point you notice that Robin has nodded off $-$ less math, more super-heroing!\n\nSo it falls to you: given a layout of the city and the location of Robin's secret hideout, you need to determine which building roofs Robin can reach, and the minimum number of jumps it takes to get to each roof.\n\nNote that if Robin's jump passes over the corner of a building (where four buildings meet), then the jump needs to be higher than all four adjacent buildings.\n\n$ $\n\n", "inputFormat": "\n\nThe input starts with a line containing six integers $d_{x}, d_{y}, w , v , ℓ_{x}, ℓ_{y}.$ These represent the size $d_{x} \\times d_{y}$ of the city grid $(1 \\le d_{x}, d_{y} \\le 20)$ in blocks, the width of each building $(1 \\le w \\le 10^{3})$ in meters, Robin's takeoff velocity $(1 \\le v \\le 10^{3})$ in meters per second, and the coordinates $(ℓ_{x}, ℓ_{y})$ of Robin's secret hideout $(1 \\le ℓ_{x} \\le d_{x}, 1 \\le ℓ_{y} \\le d_{y}).$\n\nThe first line is followed by a description of the heights of the buildings in the city grid. The description consists of $d_{y}$ lines, each containing $d_{x}$ non-negative integers. The $j^{th}$ line contains the heights for buildings $(1 , j),(2 , j)$ , . . . $,(d_{x}, j)$ . All heights are given in meters and are at most $10^{3}.$\n\n", "outputFormat": "\n\nDisplay the minimum number of jumps Robin needs to get from the secret hideout to the roof of each building. If there is no way to reach a building's roof, display $X$ instead of the number of jumps. Display the buildings in the same order as given in the input file, split into $d_{y}$ lines, each containing $d_{x}$ values.\n\nYou may assume that changing the height of any building by up to $10^{−6}$ would not change the answers.\n\n", "hint": "Time limit: 2 s, Memory limit: 1024 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 WF] Getting a Jump on Crime", "background": "", "description": "\n\nYour friend Robin is a superhero. When you first found out about this, you figured `everybody needs a hobby, and this seems more exciting than stamp collecting,` but now you are really thankful that somebody is doing something about the crime in your hometown.\n\nEvery night, Robin patrols the city by jumping from roof to roof and watching what goes on below. Naturally, superheroes need to respond to crises immediately, so Robin asked you for help in figuring out how to get around your hometown quickly.\n\nYour hometown is built on a square grid, where each block is $w \\times w$ meters. Each block is filled by a single building. The buildings may have different heights (see Figure E.1) . To get from one building to another (not necessarily adjacent) building, Robin makes a single jump from the center of the roof of the first building to the center of the roof of the second building. Robin cannot change direction while in the air, but can choose the angle at which to lift off.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15693/1.png)\n\nFigure E.1 : Cross-section of buildings corresponding to the first sample input. Buildings are shown in black, and the jump from the roof at $(1 , 1)$ to the roof at $(4 , 1)$ is shown with a green line.\n\nOf course, Robin only wants to perform jumps without colliding with any buildings. Such collisions do little damage to a superhero, but building owners tend to get irritated when someone crashes through their windows. You explain the physics to Robin: `All your jumps are done with the same initial velocity $v$ , which has a horizontal component $v_{d}$ towards the destination and vertical component $v_{h}$ upwards, so $v_{d}^{2} + v_{h}^{2} = v^{2}$ . As you travel, your horizontal velocity stays constant $(v_{d}(t) = v_{d}),$ but your vertical velocity is affected by gravity $(v_{h}(t) = v_{h} − t · g)$ , where $g = 9$ . $80665 m/s^{2}$ in your hometown. Naturally, your cape allows you to ignore the effects of air resistance. This allows you to determine your flight path and $ \\cdots `$ at which point you notice that Robin has nodded off $-$ less math, more super-heroing!\n\nSo it falls to you: given a layout of the city and the location of Robin's secret hideout, you need to determine which building roofs Robin can reach, and the minimum number of jumps it takes to get to each roof.\n\nNote that if Robin's jump passes over the corner of a building (where four buildings meet), then the jump needs to be higher than all four adjacent buildings.\n\n$ $\n\n", "inputFormat": "\n\nThe input starts with a line containing six integers $d_{x}, d_{y}, w , v , ℓ_{x}, ℓ_{y}.$ These represent the size $d_{x} \\times d_{y}$ of the city grid $(1 \\le d_{x}, d_{y} \\le 20)$ in blocks, the width of each building $(1 \\le w \\le 10^{3})$ in meters, Robin's takeoff velocity $(1 \\le v \\le 10^{3})$ in meters per second, and the coordinates $(ℓ_{x}, ℓ_{y})$ of Robin's secret hideout $(1 \\le ℓ_{x} \\le d_{x}, 1 \\le ℓ_{y} \\le d_{y}).$\n\nThe first line is followed by a description of the heights of the buildings in the city grid. The description consists of $d_{y}$ lines, each containing $d_{x}$ non-negative integers. The $j^{th}$ line contains the heights for buildings $(1 , j),(2 , j)$ , . . . $,(d_{x}, j)$ . All heights are given in meters and are at most $10^{3}.$\n\n", "outputFormat": "\n\nDisplay the minimum number of jumps Robin needs to get from the secret hideout to the roof of each building. If there is no way to reach a building's roof, display $X$ instead of the number of jumps. Display the buildings in the same order as given in the input file, split into $d_{y}$ lines, each containing $d_{x}$ values.\n\nYou may assume that changing the height of any building by up to $10^{−6}$ would not change the answers.\n\n", "hint": "Time limit: 2 s, Memory limit: 1024 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 WF] Getting a Jump on Crime", "background": "", "description": "你的朋友罗宾（Robin）是一位超级英雄。当你第一次发现这个事时，你认为“每个人都需要有爱好，这个看起来比收集邮票有意思多了”，但是现在你十分感谢那些在你的家乡胡作非为的人。\n\n每个晚上， 罗宾（Robin）用在房顶上跳跃的方式巡逻整座城市，并且看下面发生了什么。自然，超级英雄需要立即应对危机，所以罗宾（Robin）寻求你的帮助，帮他找出如何迅速走遍你的家乡。\n\n你的家乡建立在一个方形的格子上，其中每个区块有 $w\\times w$ 米。每个区块是一个独立的建筑，建筑有可能有不同的高度,为了从一个建筑到另一个（不一定相邻的）建筑，罗宾（Robin）从第一个房屋屋顶的中间跳到第二个房屋屋顶的中间。不能在空中改变方向，但可以选择起飞的角度。\n\n当然，罗宾（Robin）不想撞到任何一个建筑。一些碰撞很难对超级英雄造成伤害，但是当有人击穿房屋主人的窗户时，他们容易感到生气。你向罗宾（Robin）解释物理学：“你的每次跳都有一个初速度$v$，可以被分解成一个向前的水平分力$v_d$和一个向上的竖直分力$v_h$，且$v_{d}^{2} + v_{h}^{2} = v^{2}$.当你行动时，你的水平分力保持不变$(v_{dt} = v_{d}),$，但是竖直分力受到重力的影响$(v_{h}(t) = v_{h} − t · g)$，设在你的家乡重力加速度$g=9.80665$。自然，你的斗篷可以让你忽略空气阻力的影响。这可以让你确定你的飞行路线和……”这是你注意到罗宾（Robin）已经睡着了-少一点数学，多一点超级英雄！\n\n所以现在轮到你了：已经给出城市的布局和罗宾（Robin）秘密藏身处的位置，你需要确定罗宾（Robin）能到达哪些屋顶并给出最少跳跃次数。\n\n请注意，如果罗宾（Robin）的跳跃经过一栋建筑的角落（四栋建筑交汇的地方），那么跳跃需要比所有四栋相邻建筑都高。", "inputFormat": "输入的第一行包含六个整数$d_x$,$d_y$,$w$,$v$,$l_x$,$l_x$.这些代表了 $d_x\\times d_y$ 的城市面积（单位：区块）$(1 \\le d_{x}, d_{y} \\le 20)$，每座建筑的宽度$(1 \\le w \\le 10^{3})$，罗宾（Robin）的起跳速度$(1 \\le v \\le 10^{3})$（单位：米每秒），和罗宾（Robin）藏身处的坐标$(1 \\le ℓ_{x} \\le d_{x}, 1 \\le ℓ_{y} \\le d_{y}).$。\n\n第一行后面是对城市网格中建筑高度的描述。描述由$d_y$行组成，每个行包含$d_{x}$个非负整数。第j行包含建筑物$(1 , j),(2 , j)$ , . . . $,(d_{x}, j)$ 的高度（单位：米）。高度最高不超过$10^3$米。", "outputFormat": "输出罗宾从秘密藏身处跳到每栋建筑屋顶所需的最小跳跃次数。如果无法到达建筑物的屋顶，则显示$X$而不是跳跃次数。按输入文件中给定的顺序显示建筑，分为$d_{y}$行，每行包含$d_{x}$个值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6946", "type": "P", "difficulty": 4, "samples": [["21\nThe Yangtze is the third longest\nriver in Asia and the longest in\nthe world to flow\nentirely in one country\n", "15 5\n"], ["25\nWhen two or more rivers meet at\na confluence other than the sea\nthe resulting merged river takes\nthe name of one of those rivers\n", "21 6\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "ICPC", "WF"], "title": "[ICPC 2018 WF] Go with the Flow", "background": "", "description": "\n\nIn typesetting, a `river` is a string of spaces formed by gaps between words that extends down several lines of text. For instance, Figure F.1 shows several examples of rivers highlighted in red (text is intentionally blurred to make the rivers more visible).\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15694/1.png)\n\nFigure F.1 : Examples of rivers in typeset text.\n\nCelebrated river authority Flo Ng wants her new book on rivers of the world to include the longest typographic rivers possible. She plans to set the text in a mono-spaced font (all letters and spaces have equal width) in a left-aligned column of some fixed width, with exactly one space separating words on each line (the text is not aligned on the right). For Flo, a `river` is defined as a sequence of spaces lying in consecutive lines in which the position of each space in the sequence (except the first) differs by at most $1$ from the position of the space in the line above it. Trailing white space cannot appear in a river. Words must be packed as tightly as possible on lines; no words may be split across lines. The line width used must be at least as long as the longest word in the text. For instance, Figure F.2 shows the same text set with two different line widths.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15694/2.png)\n\nFigure F.2 : Longest rivers $( \\times )$ for two different line widths.\n\nGiven a text, you have been tasked with determining the line width that produces the longest river of spaces for that text.\n\n", "inputFormat": "\n\nThe first line of input contains an integer $n (2 \\le n \\le 2 500)$ specifying the number of words in the text. The following lines of input contain the words of text. Each word consists only of lowercase and uppercase letters, and words on the same line are separated by a single space. No word exceeds $80$ characters.\n\n", "outputFormat": "\n\nDisplay the line width for which the input text contains the longest possible river, followed by the length of the longest river. If more than one line width yields this maximum, display the shortest such line width.\n\n", "hint": "Time limit: 12 s, Memory limit: 1024 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 WF] Go with the Flow", "background": "", "description": "\n\nIn typesetting, a `river` is a string of spaces formed by gaps between words that extends down several lines of text. For instance, Figure F.1 shows several examples of rivers highlighted in red (text is intentionally blurred to make the rivers more visible).\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15694/1.png)\n\nFigure F.1 : Examples of rivers in typeset text.\n\nCelebrated river authority Flo Ng wants her new book on rivers of the world to include the longest typographic rivers possible. She plans to set the text in a mono-spaced font (all letters and spaces have equal width) in a left-aligned column of some fixed width, with exactly one space separating words on each line (the text is not aligned on the right). For Flo, a `river` is defined as a sequence of spaces lying in consecutive lines in which the position of each space in the sequence (except the first) differs by at most $1$ from the position of the space in the line above it. Trailing white space cannot appear in a river. Words must be packed as tightly as possible on lines; no words may be split across lines. The line width used must be at least as long as the longest word in the text. For instance, Figure F.2 shows the same text set with two different line widths.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15694/2.png)\n\nFigure F.2 : Longest rivers $( \\times )$ for two different line widths.\n\nGiven a text, you have been tasked with determining the line width that produces the longest river of spaces for that text.\n\n", "inputFormat": "\n\nThe first line of input contains an integer $n (2 \\le n \\le 2 500)$ specifying the number of words in the text. The following lines of input contain the words of text. Each word consists only of lowercase and uppercase letters, and words on the same line are separated by a single space. No word exceeds $80$ characters.\n\n", "outputFormat": "\n\nDisplay the line width for which the input text contains the longest possible river, followed by the length of the longest river. If more than one line width yields this maximum, display the shortest such line width.\n\n", "hint": "Time limit: 12 s, Memory limit: 1024 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 WF] Go with the Flow", "background": null, "description": "在字体排印学中，“川流”是由单词之间的间隙组成的连续几列的空格。如图所示为几个用红色高亮标出的“川流”（文本被有意模糊处理来凸显川流）：\n\n![img](https://cdn.luogu.com.cn/upload/image_hosting/vd2s7f3r.png)\n\n知名川流机构 Flo Ng 希望他在新的关于世界河流的书上出现尽可能长的川流。他会使用一种单一字宽的字体（每个字母和空格都具有相同的宽度）且左对齐，单词之间恰用一个空格分隔。对 Flo 来说，一条“川流”指的是连续几行里的空格，且相邻空格在行里出现的位置的距离不超过 $1$。川流不能包含末尾的空格。每行的单词都必须尽可能地紧凑，但不能有单词被拆到两行里。行宽至少不能短于文本中最长的一个单词。下图是同一个文本使用不同行宽的一个例子。\n\n![img](https://cdn.luogu.com.cn/upload/image_hosting/jgci4wvf.png)\n\n给定文本，你需要求出一个行宽使得该文本最长的川流尽可能长。", "inputFormat": "第一行有一个整数 $n(2≤n≤2500)$ 表示文本的单词个数。接下来几行为该文本的单词。每个单词都只包含大写和小写字母，且长度不超过 $80$ 个字符。", "outputFormat": "输出两个整数，分别表示使得文本出现最长的川流的行宽以及川流的长度。如果有多个行款达到川流长度的最大值，输出最小的行宽。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P6947", "type": "P", "difficulty": 7, "samples": [["5\n0 0\n170 0\n140 30\n60 30\n0 70\n", "50\n"], ["5\n0 0\n170 0\n140 30\n60 30\n0 100\n", "51.538820320\n"], ["5\n0 0\n1 2\n1 5\n0 2\n0 1\n", "1.581138830\n"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2018 WF] Panda Preserve", "background": "", "description": "\n\nLast month, Sichuan province secured funding to establish the Great Panda National Park, a natural preserve for a population of more than $1 800$ giant pandas. The park will be surrounded by a polygonal fence. In order for researchers to track the pandas, wireless receivers will be placed at each vertex of the enclosing polygon and each animal will be outfitted with a wireless transmitter. Each wireless receiver will cover a circular area centered at the location of the receiver, and all receivers will have the same range. Naturally, receivers with smaller range are cheaper, so your goal is to determine the smallest possible range that suffices to cover the entire park.\n\nAs an example, Figure G.1 shows the park described by the first sample input. Notice that a wireless range of $35$ does not suffice (a) , while the optimal range of $50$ covers the entire park (b) .\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15695/1.png)\n\nFigure G.1 : Illustration of Sample Input $1$ .\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $n (3 \\le n \\le 2 000)$ specifying the number of vertices of the polygon bounding the park. This is followed by $n$ lines, each containing two integers $x$ and $y (|x|, |y| \\le 10^{4})$ that give the coordinates $(x , y)$ of the vertices of the polygon in counter-clockwise order. The polygon is simple; that is, its vertices are distinct and no two edges of the polygon intersect or touch, except that consecutive edges touch at their common vertex.\n\n", "outputFormat": "\n\nDisplay the minimum wireless range that suffices to cover the park, with an absolute or relative error of at most $10^{−6}.$\n\n", "hint": "Time limit: 10 s, Memory limit: 1024 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 WF] Panda Preserve", "background": "", "description": "\n\nLast month, Sichuan province secured funding to establish the Great Panda National Park, a natural preserve for a population of more than $1 800$ giant pandas. The park will be surrounded by a polygonal fence. In order for researchers to track the pandas, wireless receivers will be placed at each vertex of the enclosing polygon and each animal will be outfitted with a wireless transmitter. Each wireless receiver will cover a circular area centered at the location of the receiver, and all receivers will have the same range. Naturally, receivers with smaller range are cheaper, so your goal is to determine the smallest possible range that suffices to cover the entire park.\n\nAs an example, Figure G.1 shows the park described by the first sample input. Notice that a wireless range of $35$ does not suffice (a) , while the optimal range of $50$ covers the entire park (b) .\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15695/1.png)\n\nFigure G.1 : Illustration of Sample Input $1$ .\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $n (3 \\le n \\le 2 000)$ specifying the number of vertices of the polygon bounding the park. This is followed by $n$ lines, each containing two integers $x$ and $y (|x|, |y| \\le 10^{4})$ that give the coordinates $(x , y)$ of the vertices of the polygon in counter-clockwise order. The polygon is simple; that is, its vertices are distinct and no two edges of the polygon intersect or touch, except that consecutive edges touch at their common vertex.\n\n", "outputFormat": "\n\nDisplay the minimum wireless range that suffices to cover the park, with an absolute or relative error of at most $10^{−6}.$\n\n", "hint": "Time limit: 10 s, Memory limit: 1024 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 WF] Panda Preserve", "background": null, "description": "上个月，四川省获得资金建立大熊猫国家公园，这是一处为超过 1800 只大熊猫提供栖息地的自然保护区。公园将被多边形围栏包围。为了让研究人员追踪大熊猫，将在围栏的每个顶点放置无线接收器，每只大熊猫都将配备无线发射器。每个无线接收器将覆盖以接收器位置为中心的圆形区域，并且所有接收器的覆盖范围相同。显然，覆盖范围较小的接收器更便宜，因此你的目标是确定能够覆盖整个公园的最小可能范围。\n\n例如，图 G.1 显示了由第一个样例输入描述的公园。注意，35 的无线范围不足以覆盖整个公园（a），而 50 的最佳范围则可以覆盖整个公园（b）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n9l4fete.png)\n\n图 G.1：样例输入 1 的示意图。", "inputFormat": "输入的第一行包含一个整数 $n (3 \\le n \\le 2000)$，表示公园边界多边形的顶点数。接下来是 $n$ 行，每行包含两个整数 $x$ 和 $y (|x|, |y| \\le 10^{4})$，表示多边形顶点的坐标 $(x, y)$，按逆时针顺序给出。该多边形是简单多边形，即其顶点是不同的，且多边形的任意两条边不相交或接触，除非是相邻边在其公共顶点处接触。", "outputFormat": "输出能够覆盖整个公园的最小无线范围，绝对误差或相对误差不超过 $10^{-6}$。", "hint": "时间限制：10 秒，内存限制：1024 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6948", "type": "P", "difficulty": 5, "samples": [["4 4 6\n0 1 4 4\n0 5 2 0\n0 3 3 6\n2 6 4 2\n", "1\n0 4 4 3\n"], ["5 4 6\n0 2 2 0\n0 3 2 6\n1 6 3 0\n1 0 4 4\n3 6 4 2\n", "2\n0 4 4 4.5\n0 1 4 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2018", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2018 WF] Single Cut of Failure", "background": "", "description": "\n\nThe Intrusion and Crime Prevention Company (ICPC) builds intrusion detection systems for homes and businesses. The International Collegiate Programming Contest (in a strange coincidence also known as ICPC) is considering hiring the company to secure the room that contains the problem set for next year's World Finals.\n\nThe contest staff wants to prevent the intrusion attempts that were made in past years, such as rappelling down the outside of the building to enter through a window, crawling through air ducts, impersonating Bill Poucher, and the creative use of an attack submarine. For that reason, the problems will be stored in a room that has a single door and no other exits.\n\nICPC (the company) proposes to install sensors on the four sides of the door, where pairs of sensors are connected by wires. If somebody opens the door, any connected sensor pair will detect this and cause an alarm to sound.\n\nThe system has one design flaw, however. An intruder might cut the wires before opening the door. To assess the security of the system, you need to determine the minimum number of line segments that cut all wires. Figure H.1 shows two configurations of wires on the door (corresponding to the two sample inputs), and minimum-size cuts that intersect all wires.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15696/1.png)\n\nFigure H.1 : Illustrations of Sample Inputs $1$ and $2$ .\n\n", "inputFormat": "\n\nThe input starts with a line containing three integers $n , w$ , and $h$ , which represent the number of wires installed $(1 \\le n \\le 10^{6})$ and the dimensions of the door $(1 \\le w , h \\le 10^{8}).$ This is followed by $n$ lines, each describing a wire placement. Each of these lines contains four integers $x_{1}, y_{1}, x_{2},$ and $y_{2} (0 \\le x_{1}, x_{2} \\le w , 0 \\le y_{1}, y_{2} \\le h)$ , meaning that a wire goes from $(x_{1}, y_{1})$ to $(x_{2}, y_{2}).$ Each wire connects different sides of the door. No wire is anchored to any of the four corners of the door. All locations in the input are distinct.\n\n", "outputFormat": "\n\nDisplay a minimum-size set of straight line cuts that intersect all wires. First, display the number of cuts needed. Then display the cuts, one per line in the format $x_{1} y_{1} x_{2} y_{2}$ for the cut between $(x_{1}, y_{1})$ and $(x_{2}, y_{2}).$ Each cut has to start and end on different sides of the door. Cuts cannot start or end closer than $10^{−6}$ to any wire anchor location or any corner of the door.\n\nCuts may be displayed in any order. The start and end locations of each cut may be displayed in either order. If there are multiple sets of cuts with the same minimum size, display any of them.\n\n", "hint": "Time limit: 6 s, Memory limit: 1024 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 WF] Single Cut of Failure", "background": "", "description": "\n\nThe Intrusion and Crime Prevention Company (ICPC) builds intrusion detection systems for homes and businesses. The International Collegiate Programming Contest (in a strange coincidence also known as ICPC) is considering hiring the company to secure the room that contains the problem set for next year's World Finals.\n\nThe contest staff wants to prevent the intrusion attempts that were made in past years, such as rappelling down the outside of the building to enter through a window, crawling through air ducts, impersonating Bill Poucher, and the creative use of an attack submarine. For that reason, the problems will be stored in a room that has a single door and no other exits.\n\nICPC (the company) proposes to install sensors on the four sides of the door, where pairs of sensors are connected by wires. If somebody opens the door, any connected sensor pair will detect this and cause an alarm to sound.\n\nThe system has one design flaw, however. An intruder might cut the wires before opening the door. To assess the security of the system, you need to determine the minimum number of line segments that cut all wires. Figure H.1 shows two configurations of wires on the door (corresponding to the two sample inputs), and minimum-size cuts that intersect all wires.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15696/1.png)\n\nFigure H.1 : Illustrations of Sample Inputs $1$ and $2$ .\n\n", "inputFormat": "\n\nThe input starts with a line containing three integers $n , w$ , and $h$ , which represent the number of wires installed $(1 \\le n \\le 10^{6})$ and the dimensions of the door $(1 \\le w , h \\le 10^{8}).$ This is followed by $n$ lines, each describing a wire placement. Each of these lines contains four integers $x_{1}, y_{1}, x_{2},$ and $y_{2} (0 \\le x_{1}, x_{2} \\le w , 0 \\le y_{1}, y_{2} \\le h)$ , meaning that a wire goes from $(x_{1}, y_{1})$ to $(x_{2}, y_{2}).$ Each wire connects different sides of the door. No wire is anchored to any of the four corners of the door. All locations in the input are distinct.\n\n", "outputFormat": "\n\nDisplay a minimum-size set of straight line cuts that intersect all wires. First, display the number of cuts needed. Then display the cuts, one per line in the format $x_{1} y_{1} x_{2} y_{2}$ for the cut between $(x_{1}, y_{1})$ and $(x_{2}, y_{2}).$ Each cut has to start and end on different sides of the door. Cuts cannot start or end closer than $10^{−6}$ to any wire anchor location or any corner of the door.\n\nCuts may be displayed in any order. The start and end locations of each cut may be displayed in either order. If there are multiple sets of cuts with the same minimum size, display any of them.\n\n", "hint": "Time limit: 6 s, Memory limit: 1024 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 WF] Single Cut of Failure", "background": null, "description": "入侵与犯罪预防公司 (the Intrusion and Crime Prevection Company, 简称 ICPC) 为家庭和商业公司建立了入侵检测系统。国际大学生编程竞赛 (the International Collegiate Programming Contest, 碰巧也简称 ICPC) 正在考虑雇佣该公司来确保下一年 World Finals 的题目文件的储藏房间的安全。\n\n比赛工作人员希望防止过去几年发生的入侵尝试，例如在大楼的外部垂直速降然后从窗户进入，从排气管道爬进来，冒充 Bill Poucher （译者注：某知名计算机科学教授，ACM-ICPC 的执行董事），以及创造性地使用攻击潜艇。正因如此，题目文件将被储藏在仅有一扇门而没有任何其他出入口的房间里。\n\nICPC （指公司）建议在门的四边安装传感器，每对传感器由电线连接。如果有人打开了门，任何连接的一对传感器将检测到这个动作并引起警报声。\n\n然而这个系统存在一个设计缺陷。入侵者可以在开门之前剪断这些电线。为了评估这个系统的安全性，你需要使用最少的线段剪断所有电线。下图展示了两种具有不同电线分布的门（对应于两个样例）以及最少的与所有电线相交的线段。\n\n![图](https://cdn.luogu.com.cn/upload/image_hosting/iat1ibs7.png)", "inputFormat": "第一行三个整数 $n, w, h$ 分别表示电线的数量 ($1 \\le n \\le 10^6$) 以及门的尺寸 ($1 \\le w, h \\le 10^8$) 。接下来 $n$ 行，每行描述一个电线的位置。这些行中每行包含四个整数 $x_1, y_1, x_2, y_2$ ($0 \\le x_1, x_2 \\le w, 0 \\le y_1, y_2 \\le h$) 表示该电线从 $(x_1, y_1)$ 连接到 $(x_2, y_2)$ 。每根电线连接门的不同的两边。没有电线连接到门的四个角落。输入的所有位置都是两两不同的。", "outputFormat": "输出最少的一组线段与所有电线有交。首先第一行输出线段的数量。然后逐行输出线段，每行以 $x_1$ $y_1$ $x_2$ $y_2$ 的格式给出一个从 $(x_1, y_1)$ 到 $(x_2, y_2)$ 的线段。每条线段的两个端点必须在门的不同的两边。线段的端点与任何电线端点及门的四个角落的距离不能小于 $10^{-6}$ 。\n\n线段可以以任意顺序输出。线段的两个端点也可以以任意顺序输出。如果有多种可行的解，输出任意一组解即可。\n\n译者注：线段的端点坐标可以是满足限制的任意**实数**。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P6949", "type": "P", "difficulty": 6, "samples": [["3 3\nx---x\n \\ /\n  x\n / \\\nx   x\n", "1\n"], ["4 10\nx   x---x---x   x\n     \\ /   / \\\n  x   x---x   x   x\n     / \\ / \\   \\\nx   x---x---x---x\n   /   / \\   \\ / \\\n  x---x---x---x---x\n", "12\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "ICPC", "WF"], "title": "[ICPC 2018 WF] Triangles", "background": "", "description": "\n\nFor your trip to Beijing, you have brought plenty of puzzle books, many of them containing challenges like the following: how many triangles can be found in Figure I.1 ?\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15697/1.png)\n\nFigure I.1 : Illustration of Sample Input $2$ .\n\nWhile these puzzles keep your interest for a while, you quickly get bored with them and instead start thinking about how you might solve them algorithmically. Who knows, maybe a problem like that will actually be used in this year's contest. Well, guess what? Today is your lucky day!\n\n", "inputFormat": "\n\nThe first line of input contains two integers $r$ and $c (1 \\le r \\le 3 000 , 1 \\le c \\le 6 000)$ , specifying the picture size, where $r$ is the number of rows of vertices and $c$ is the number of columns. Following this are 2r $− 1$ lines, each of them having at most 2c $− 1$ characters. Odd lines contain grid vertices (represented as lowercase $x$ characters) and zero or more horizontal edges, while even lines contain zero or more diagonal edges. Specifically, picture lines with numbers 4k $+ 1$ have vertices in positions $1 , 5 , 9 , 13$ , . . . while lines with numbers 4k $+ 3$ have vertices in positions $3 , 7 , 11 , 15$ , . . . . All possible vertices are represented in the input (for example, see how Figure I.1 is represented in Sample Input $2$) . Horizontal edges connecting neighboring vertices are represented by three dashes. Diagonal edges are represented by a single forward slash $(‘/')$ or backslash $(‘\\')$ character. The edge characters will be placed exactly between the corresponding vertices. All other characters will be space characters. Note that if any input line could contain trailing whitespace, that whitespace may be omitted.\n\n", "outputFormat": "\n\nDisplay the number of triangles (of any size) formed by grid edges in the input picture.\n\n", "hint": "Time limit: 6 s, Memory limit: 1024 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 WF] Triangles", "background": "", "description": "\n\nFor your trip to Beijing, you have brought plenty of puzzle books, many of them containing challenges like the following: how many triangles can be found in Figure I.1 ?\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15697/1.png)\n\nFigure I.1 : Illustration of Sample Input $2$ .\n\nWhile these puzzles keep your interest for a while, you quickly get bored with them and instead start thinking about how you might solve them algorithmically. Who knows, maybe a problem like that will actually be used in this year's contest. Well, guess what? Today is your lucky day!\n\n", "inputFormat": "\n\nThe first line of input contains two integers $r$ and $c (1 \\le r \\le 3 000 , 1 \\le c \\le 6 000)$ , specifying the picture size, where $r$ is the number of rows of vertices and $c$ is the number of columns. Following this are 2r $− 1$ lines, each of them having at most 2c $− 1$ characters. Odd lines contain grid vertices (represented as lowercase $x$ characters) and zero or more horizontal edges, while even lines contain zero or more diagonal edges. Specifically, picture lines with numbers 4k $+ 1$ have vertices in positions $1 , 5 , 9 , 13$ , . . . while lines with numbers 4k $+ 3$ have vertices in positions $3 , 7 , 11 , 15$ , . . . . All possible vertices are represented in the input (for example, see how Figure I.1 is represented in Sample Input $2$) . Horizontal edges connecting neighboring vertices are represented by three dashes. Diagonal edges are represented by a single forward slash $(‘/')$ or backslash $(‘\\')$ character. The edge characters will be placed exactly between the corresponding vertices. All other characters will be space characters. Note that if any input line could contain trailing whitespace, that whitespace may be omitted.\n\n", "outputFormat": "\n\nDisplay the number of triangles (of any size) formed by grid edges in the input picture.\n\n", "hint": "Time limit: 6 s, Memory limit: 1024 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 WF] Triangles", "background": null, "description": "在你去北京的旅行中，你带了很多谜题书，其中很多都包含类似以下的挑战：在图 I.1 中可以找到多少个三角形？\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7jipp6ud.png)\n\n图 I.1：样例输入 2 的插图。\n\n虽然这些谜题让你一时感兴趣，但你很快就对它们感到厌倦，转而开始思考如何用算法来解决它们。谁知道呢，也许这样的题目会在今年的比赛中出现。好吧，猜猜看？今天是你的幸运日！", "inputFormat": "输入的第一行包含两个整数 $r$ 和 $c$ $(1 \\le r \\le 3000, 1 \\le c \\le 6000)$，指定图像的大小，其中 $r$ 是顶点的行数，$c$ 是列数。接下来的 $2r - 1$ 行中，每行最多有 $2c - 1$ 个字符。奇数行包含网格顶点（用小写字母 $x$ 表示）和零个或多个水平边，而偶数行包含零个或多个对角边。具体来说，编号为 $4k + 1$ 的行在位置 $1, 5, 9, 13, \\ldots$ 处有顶点，而编号为 $4k + 3$ 的行在位置 $3, 7, 11, 15, \\ldots$ 处有顶点。输入中表示了所有可能的顶点（例如，参见样例输入 2 中图 I.1 的表示方式）。连接相邻顶点的水平边用三个短划线表示。对角边用一个正斜杠（‘/’）或反斜杠（‘\\\\’）字符表示。边字符将精确地放置在相应顶点之间。所有其他字符将是空格字符。注意，如果任何输入行可能包含尾随空格，则这些空格可能会被省略。", "outputFormat": "显示输入图像中由网格边形成的三角形（任意大小）的数量。", "hint": "时间限制：6 秒，内存限制：1024 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6950", "type": "P", "difficulty": 7, "samples": [["6 6\n", "12\n"], ["8 3\n", "6\n"], ["7 20\n", "80\n"], ["2 6\n", "0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "ICPC", "WF"], "title": "[ICPC 2018 WF] Uncrossed Knight's Tour", "background": "", "description": "\n\nA well-known puzzle is to `tour` all the squares of an $8 \\times 8$ chessboard using a knight, which is a piece that can move only by jumping one square in one direction and two squares in an orthogonal direction. The knight must visit every square of the chessboard, without repeats, and then return to its starting square. There are many ways to do this, and the chessboard size is manageable, so it is a reasonable puzzle for a human to solve.\n\nHowever, you have access to a computer, and some coding skills! So, we will give you a harder version of this problem on a rectangular $m \\times n$ chessboard with an additional constraint: the knight may never cross its own path. If you imagine its path consisting of straight line segments connecting the centers of squares it jumps between, these segments must form a simple polygon; that is, no two segments intersect or touch, except that consecutive segments touch at their common end point. This constraint makes it impossible to visit every square, so instead you must maximize the number of squares the knight visits. We keep the constraint that the knight must return to its starting square. Figure J.1 shows an optimal solution for the first sample input, a $6 \\times 6$ board.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15698/1.png)\n\nFigure J.1 : An optimal solution for a $6 \\times 6$ board.\n\n", "inputFormat": "\n\nThe input consists of a single line containing two integers $m (1 \\le m \\le 8)$ and $n (1 \\le n \\le 10^{15}),$ giving the dimensions of the rectangular chessboard.\n\n", "outputFormat": "\n\nDisplay the largest number of squares that a knight can visit in a tour on an $m \\times n$ chessboard that does not cross its path. If no such tour exists, display $0$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 1024 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 WF] Uncrossed Knight's Tour", "background": "", "description": "\n\nA well-known puzzle is to `tour` all the squares of an $8 \\times 8$ chessboard using a knight, which is a piece that can move only by jumping one square in one direction and two squares in an orthogonal direction. The knight must visit every square of the chessboard, without repeats, and then return to its starting square. There are many ways to do this, and the chessboard size is manageable, so it is a reasonable puzzle for a human to solve.\n\nHowever, you have access to a computer, and some coding skills! So, we will give you a harder version of this problem on a rectangular $m \\times n$ chessboard with an additional constraint: the knight may never cross its own path. If you imagine its path consisting of straight line segments connecting the centers of squares it jumps between, these segments must form a simple polygon; that is, no two segments intersect or touch, except that consecutive segments touch at their common end point. This constraint makes it impossible to visit every square, so instead you must maximize the number of squares the knight visits. We keep the constraint that the knight must return to its starting square. Figure J.1 shows an optimal solution for the first sample input, a $6 \\times 6$ board.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15698/1.png)\n\nFigure J.1 : An optimal solution for a $6 \\times 6$ board.\n\n", "inputFormat": "\n\nThe input consists of a single line containing two integers $m (1 \\le m \\le 8)$ and $n (1 \\le n \\le 10^{15}),$ giving the dimensions of the rectangular chessboard.\n\n", "outputFormat": "\n\nDisplay the largest number of squares that a knight can visit in a tour on an $m \\times n$ chessboard that does not cross its path. If no such tour exists, display $0$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 1024 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 WF] Uncrossed Knight's Tour", "background": "", "description": "马在 $m$ $\\times$ $n$ 大小的矩形棋盘上跳跃（走日字）。求从棋盘上一点开始，在保证【性质】的情况下，它最多经过几个格子（包括起点，且终点不算），可以回到初始点？\n\n【性质】：想象马的路径由直线段组成，这些直线段连接着它所跳跃的正方形的中心（如图），这些直线段必须形成一个简单的多边形。也就是说，没有两个线段相交或接触，除非连续线段在其公共端点处接触。", "inputFormat": "一行，两个正整数 $m$ $(1 \\le m \\le 8)$ 和 $n$ $(1 \\le n \\le 10^{15})$。", "outputFormat": "一行，马最多经过的格子数。\n若没有这样的路径，输出 $0$ 。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6951", "type": "P", "difficulty": 4, "samples": [["7 11\n0 1\n0 2\n0 5\n0 6\n1 3\n2 4\n1 2\n1 2\n1 5\n2 6\n5 6\n", "3\n7 6\n0 1\n0 2\n0 5\n0 6\n3 6\n4 6\n"], ["4 3\n0 1\n2 1\n2 3\n", "0\n4 3\n2 1\n1 3\n0 2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2018 WF] Wireless is the New Fiber", "background": "", "description": "\n\nA new type of unbounded-bandwidth wireless communication has just been tested and proved to be a suitable replacement for the existing, fiber-based communications network, which is struggling to keep up with traffic growth. You have been charged with deciding the layout of the new communications network. The current communications network consists of a set of nodes (which route messages), and links of fiber, each of which connects two different nodes. For each pair of nodes, there exists at least one way (but possibly more, for bandwidth purposes) to travel along the fiber between the two.\n\nThe new communications network will not have any fiber. Instead, it will have wireless links, each connecting two nodes. These links have unbounded bandwidth but are expensive, so it has been decided that as few of these links will be built as possible to provide connectivity; for each pair of nodes there should be exactly one way to travel between them along the wireless links. Moreover, you discovered that the nodes have each been built with a particular number of connections in mind. For each node, if it will be connected to a different number of links than it is today, it will have to be reorganized, and that is costly.\n\nYour task is to design the new network so that it has precisely one path between each pair of nodes while minimizing the number of nodes that do not have the same number of connections as in the original network. Figure K.1 shows the original network and a solution for Sample Input $1$ .\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15699/1.png)\n\nFigure K.1 : Illustration of Sample Input $1$ .\n\n", "inputFormat": "\n\nThe input begins with a line containing two integers $n (2 \\le n \\le 10^{4})$ and $m (1 \\le m \\le 10^{5}),$ denoting the number of nodes and the number of fiber links in the existing network. The nodes are numbered from $0$ to $n − 1$ . Each of the next $m$ lines contains two distinct integers $a_{i}$ and $b_{i},$ denoting the fact that the $i^{th}$ fiber link connects nodes numbered $a_{i}$ and $b_{i}.$ It is guaranteed that for each pair of nodes there exists at least one path connecting the two nodes. Any pair of nodes may have more than one fiber link connecting them.\n\n", "outputFormat": "\n\nDisplay the smallest number of nodes for which the number of connected links needs to change. Starting on the next line, display a system of connections in the same format as the input. That is, display a line containing the number of nodes (this will be the same as in the input) and the number of wireless links, and then on subsequent lines descriptions of the links. If more than one layout is possible, any valid layout will be accepted.\n\n", "hint": "Time limit: 2 s, Memory limit: 1024 MB. \n\nSPJ provider: @[shenyouran](/user/137367).", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 WF] Wireless is the New Fiber", "background": "", "description": "\n\nA new type of unbounded-bandwidth wireless communication has just been tested and proved to be a suitable replacement for the existing, fiber-based communications network, which is struggling to keep up with traffic growth. You have been charged with deciding the layout of the new communications network. The current communications network consists of a set of nodes (which route messages), and links of fiber, each of which connects two different nodes. For each pair of nodes, there exists at least one way (but possibly more, for bandwidth purposes) to travel along the fiber between the two.\n\nThe new communications network will not have any fiber. Instead, it will have wireless links, each connecting two nodes. These links have unbounded bandwidth but are expensive, so it has been decided that as few of these links will be built as possible to provide connectivity; for each pair of nodes there should be exactly one way to travel between them along the wireless links. Moreover, you discovered that the nodes have each been built with a particular number of connections in mind. For each node, if it will be connected to a different number of links than it is today, it will have to be reorganized, and that is costly.\n\nYour task is to design the new network so that it has precisely one path between each pair of nodes while minimizing the number of nodes that do not have the same number of connections as in the original network. Figure K.1 shows the original network and a solution for Sample Input $1$ .\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15699/1.png)\n\nFigure K.1 : Illustration of Sample Input $1$ .\n\n", "inputFormat": "\n\nThe input begins with a line containing two integers $n (2 \\le n \\le 10^{4})$ and $m (1 \\le m \\le 10^{5}),$ denoting the number of nodes and the number of fiber links in the existing network. The nodes are numbered from $0$ to $n − 1$ . Each of the next $m$ lines contains two distinct integers $a_{i}$ and $b_{i},$ denoting the fact that the $i^{th}$ fiber link connects nodes numbered $a_{i}$ and $b_{i}.$ It is guaranteed that for each pair of nodes there exists at least one path connecting the two nodes. Any pair of nodes may have more than one fiber link connecting them.\n\n", "outputFormat": "\n\nDisplay the smallest number of nodes for which the number of connected links needs to change. Starting on the next line, display a system of connections in the same format as the input. That is, display a line containing the number of nodes (this will be the same as in the input) and the number of wireless links, and then on subsequent lines descriptions of the links. If more than one layout is possible, any valid layout will be accepted.\n\n", "hint": "Time limit: 2 s, Memory limit: 1024 MB. \n\nSPJ provider: @[shenyouran](/user/137367).", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 WF] Wireless is the New Fiber", "background": "", "description": "一种新型的无限带宽无线通信刚刚通过测试，并被证明可以替代现有的基于光纤的通信网络，后者正努力跟上流量增长的步伐。你被委托决定新通信网络的布局。当前的通信网络由一组节点（用于路由消息）和光纤链路组成，每条链路连接两个不同的节点。对于每对节点，至少存在一条（但可能更多，为了带宽目的）光纤路径。\n\n新的通信网络将不再使用光纤。相反，它将使用无线链路，每条链路连接两个节点。这些链路具有无限带宽，但成本昂贵，因此决定尽可能少地建设这些链路以提供连通性；对于每对节点，应该只有一条路径通过无线链路连接。此外，你发现每个节点的设计都考虑了特定数量的连接。如果每个节点的连接数与今天不同，则需要重新组织，这将非常昂贵。\n\n你的任务是设计新的网络，使其在每对节点之间恰好有一条路径，同时最小化与原始网络连接数不同的节点数量。图 K.1 显示了原始网络和样例输入 1 的解决方案。\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15699/1.png)\n\n图 K.1：样例输入 1 的示意图。", "inputFormat": "输入以一行两个整数 $n (2 \\le n \\le 10^{4})$ 和 $m (1 \\le m \\le 10^{5})$ 开始，表示现有网络中的节点数和光纤链路数。节点编号从 $0$ 到 $n - 1$。接下来的 $m$ 行中的每一行包含两个不同的整数 $a_{i}$ 和 $b_{i}$，表示第 $i$ 条光纤链路连接编号为 $a_{i}$ 和 $b_{i}$ 的节点。保证对于每对节点，至少存在一条路径连接这两个节点。任何一对节点之间可能有多条光纤链路连接。", "outputFormat": "显示需要更改连接数的最小节点数。从下一行开始，以与输入相同的格式显示连接系统。即，显示一行包含节点数（这将与输入相同）和无线链路数，然后在后续行中描述这些链路。如果有多种布局可能，任何有效的布局都将被接受。", "hint": "时间限制：2 秒，内存限制：1024 MB。\n\nSPJ 提供者：@[shenyouran](/user/137367)。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6952", "type": "P", "difficulty": 6, "samples": [["8\n1 0 12\n2 -11 22\n1 24 10\n1 12 3\n2 12 12\n2 16 14\n1 28 15\n2 3 6\n", "-1\n-1\n3\n1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Archery Tournament", "background": "", "description": "\n\nYou were invited to the annual archery tournament. You are going to compete against the best archers from all of the Northern Eurasia. This year, a new type of competition is introduced, where a shooting range is dynamic and new targets might appear at any second.\n\nAs the shooting range is far enough from you, it can be represented as a 2D plane, where $y = 0$ is the ground level. There are some targets in a shape of a circle, and all the targets are standing on the ground. That means, if a target's center is $(x , y) (y > 0)$ , then its radius is equal to $y$ , so that it touches the line $y = 0$ . No two targets simultaneously present at the range at any given time intersect (but they may touch).\n\nInitially, the shooting range is empty. Your participation in this competition can be described as $n$ events: either a new target appears at the range, or you shoot an arrow at some point at the range. To hit a target, you must shoot strictly inside the circle (hitting the border does not count). If you shoot and hit some target, then the target is removed from the range and you are awarded one point.\n\n", "inputFormat": "\n\nThe first line of the input contains integer $n (1 \\le n \\le 2·10^{5}).$ Next $n$ lines describe the events happening at the tournament. The i-th line contains three integers $t_{i}, x_{i},$ and $y_{i} (t_{i} = 1 , 2$ ; $−10^{9} \\le x_{i}, y_{i} \\le 10^{9}$ ; $y_{i} > 0)$ .\n\nIf $t_{i} = 1$ , then a new target with center $(x_{i}, y_{i})$ and radius $y_{i}$ appears at the range.\n\nIf $t_{i} = 2$ , then you perform a shot, which hits the range at $(x_{i}, y_{i}).$\n\n", "outputFormat": "\n\nFor each of your shots, output a separate line with the single integer. If the shot did not hit any target, print `-1`. If the shot hit a target, print the number of event when that target was added to the range. Events are numbered starting from $1$ .\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Archery Tournament", "background": "", "description": "\n\nYou were invited to the annual archery tournament. You are going to compete against the best archers from all of the Northern Eurasia. This year, a new type of competition is introduced, where a shooting range is dynamic and new targets might appear at any second.\n\nAs the shooting range is far enough from you, it can be represented as a 2D plane, where $y = 0$ is the ground level. There are some targets in a shape of a circle, and all the targets are standing on the ground. That means, if a target's center is $(x , y) (y > 0)$ , then its radius is equal to $y$ , so that it touches the line $y = 0$ . No two targets simultaneously present at the range at any given time intersect (but they may touch).\n\nInitially, the shooting range is empty. Your participation in this competition can be described as $n$ events: either a new target appears at the range, or you shoot an arrow at some point at the range. To hit a target, you must shoot strictly inside the circle (hitting the border does not count). If you shoot and hit some target, then the target is removed from the range and you are awarded one point.\n\n", "inputFormat": "\n\nThe first line of the input contains integer $n (1 \\le n \\le 2·10^{5}).$ Next $n$ lines describe the events happening at the tournament. The i-th line contains three integers $t_{i}, x_{i},$ and $y_{i} (t_{i} = 1 , 2$ ; $−10^{9} \\le x_{i}, y_{i} \\le 10^{9}$ ; $y_{i} > 0)$ .\n\nIf $t_{i} = 1$ , then a new target with center $(x_{i}, y_{i})$ and radius $y_{i}$ appears at the range.\n\nIf $t_{i} = 2$ , then you perform a shot, which hits the range at $(x_{i}, y_{i}).$\n\n", "outputFormat": "\n\nFor each of your shots, output a separate line with the single integer. If the shot did not hit any target, print `-1`. If the shot hit a target, print the number of event when that target was added to the range. Events are numbered starting from $1$ .\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Archery Tournament", "background": "", "description": "你被邀请参加一年一度的射箭比赛。你将与来自整个北欧亚的最佳射手竞争。今年引入了一种新的比赛类型，射击场是动态的，新的目标可能会在任何时候出现。\n\n由于射击场离你足够远，可以表示为一个二维平面，其中 $y = 0$ 是地面。有一些目标是圆形的，所有的目标都站在地面上。这意味着，如果一个目标的中心是 $(x, y) (y > 0)$，那么它的半径等于 $y$，以便它接触到 $y = 0$ 的线。在任何给定时刻，射击场上没有两个目标同时存在相交（但它们可能接触）。\n\n最初，射击场是空的。你在这次比赛中的参与可以描述为 $n$ 个事件：要么一个新目标出现在射击场上，要么你在射击场的某个点射出一箭。要击中目标，你必须严格射入圆内（击中边界不算）。如果你射中并击中某个目标，那么该目标将从射击场上移除，你将获得一分。", "inputFormat": "输入的第一行包含整数 $n (1 \\le n \\le 2 \\cdot 10^{5})$。接下来的 $n$ 行描述了比赛中发生的事件。第 $i$ 行包含三个整数 $t_{i}, x_{i},$ 和 $y_{i} (t_{i} = 1 , 2$；$-10^{9} \\le x_{i}, y_{i} \\le 10^{9}$；$y_{i} > 0)$。\n\n如果 $t_{i} = 1$，则一个中心为 $(x_{i}, y_{i})$，半径为 $y_{i}$ 的新目标出现在射击场上。\n\n如果 $t_{i} = 2$，则你进行一次射击，击中射击场的 $(x_{i}, y_{i})$。", "outputFormat": "对于你的每次射击，输出一个单独的行，包含一个整数。如果射击没有击中任何目标，打印 `-1`。如果射击击中了一个目标，打印该目标被添加到射击场时的事件编号。事件编号从 $1$ 开始。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6953", "type": "P", "difficulty": 4, "samples": [["1 2 3\n6 5\n", "Yes\n"], ["1 2 3\n5 5\n", "No\n"], ["1 1 1\n10 2\n", "Yes\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Box", "background": "", "description": "\n\nBella is working in a factory that produces boxes. All boxes are in a shape of rectangular parallelepipeds. A net of the corresponding parallelepiped is cut out of a flat rectangular piece of cardboard of size $w$ *h . This net is a polygon with sides parallel to the sides of the rectangle of the cardboard. The net is bent along several lines and is connected along the edges of the resulting parallelepiped to form a box. The net is bent only along the edges of the resulting box.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15284/1.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15284/2.png)\n\nThe first example\n\nThe third example\n\nBella is a software developer and her task is to check whether it is possible to make a box of size $a \\times b \\times c$ out of a cardboard of size $w \\times h$ . Bella did write a program and boxes are being produced. Can you do the same?\n\n", "inputFormat": "\n\nThe first line contains three integers a , $b$ , and $c$ -- the dimensions of the box.\n\nThe second line contains two integers $w$ and $h$ -- the width and the height of the cardboard.\n\nAll integers are positive and do not exceed $10^{8}.$\n\n", "outputFormat": "\n\nPrint `Yes` if it is possible to cut a box a $ \\times b \\times c$ out of a cardboard of size $w \\times h$ . Print `No` otherwise.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Box", "background": "", "description": "\n\nBella is working in a factory that produces boxes. All boxes are in a shape of rectangular parallelepipeds. A net of the corresponding parallelepiped is cut out of a flat rectangular piece of cardboard of size $w$ *h . This net is a polygon with sides parallel to the sides of the rectangle of the cardboard. The net is bent along several lines and is connected along the edges of the resulting parallelepiped to form a box. The net is bent only along the edges of the resulting box.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15284/1.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15284/2.png)\n\nThe first example\n\nThe third example\n\nBella is a software developer and her task is to check whether it is possible to make a box of size $a \\times b \\times c$ out of a cardboard of size $w \\times h$ . Bella did write a program and boxes are being produced. Can you do the same?\n\n", "inputFormat": "\n\nThe first line contains three integers a , $b$ , and $c$ -- the dimensions of the box.\n\nThe second line contains two integers $w$ and $h$ -- the width and the height of the cardboard.\n\nAll integers are positive and do not exceed $10^{8}.$\n\n", "outputFormat": "\n\nPrint `Yes` if it is possible to cut a box a $ \\times b \\times c$ out of a cardboard of size $w \\times h$ . Print `No` otherwise.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Box", "background": null, "description": "Bella 在一家生产盒子的工厂工作。所有盒子都是长方体形状。对应长方体的展开图是从一个大小为 $w \\times h$ 的平面矩形纸板上裁剪出来的。这个展开图是一个多边形，其边与纸板矩形的边平行。展开图沿着几条线折叠，并沿着最终长方体的边缘连接形成一个盒子。展开图仅沿着最终盒子的边缘折叠。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oxlybr7q.png)\n\n第一组样例\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vk9knsg7.png)\n\n\n第三组样例\n\nBella 是一名软件开发人员，她的任务是检查是否可以用一个大小为 $w \\times h$ 的纸板制作一个大小为 $a \\times b \\times c$ 的盒子。Bella 编写了一个程序，盒子正在生产。你能做到吗？", "inputFormat": "第一行包含三个整数 $a$、$b$ 和 $c$——盒子的尺寸。\n\n第二行包含两个整数 $w$ 和 $h$——纸板的宽度和高度。\n\n所有整数都是正数且不超过 $10^8$。", "outputFormat": "如果可以从大小为 $w \\times h$ 的纸板上裁剪出一个大小为 $a \\times b \\times c$ 的盒子，则打印 `Yes`。否则打印 `No`。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6954", "type": "P", "difficulty": 5, "samples": [["1\n4 9\n1 2\n1 3\n2 3\n2 4\n3 2\n3 4\n4 1\n4 2\n4 3\n", "1 3\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Connections", "background": "", "description": "\n\nHard times are coming to Byteland. Quantum computing is becoming mainstream and Qubitland is going to occupy Byteland. The main problem is that Byteland does not have enough money for this war, so the King of Byteland Byteman $0x0B$ had decided to reform its road system to reduce expenses.\n\nByteland has $n$ cities that are connected by $m$ one-way roads and it is possible to get from any city to any other city using these roads. No two roads intersect outside of the cities and no other roads exist. By the way, roads are one-way because every road has a halfway barrier that may be passed in one direction only. These barriers are intended to force enemies to waste their time if they choose the wrong way.\n\nThe idea of the upcoming road reform is to abandon some roads so that exactly $2n$ roads remain. Advisers of the King think that it should be enough to keep the ability to get from any city to any other city. (Maybe even less is enough? They do not know for sure. ) The problem is how to choose roads to abandon. Everyone in Byteland knows that you are the only one who can solve this problem.\n\n", "inputFormat": "\n\nInput consists of several test cases. The first line of the input contains the number of tests cases.\n\nThe first line of each test case contains $n$ and $m$ -- the number of cities and the number of roads correspondingly $(n \\ge 4 , m > 2n).$ Each of the next $m$ lines contains two numbers $x_i$ and $y_i$ denoting a road from city $x_{i}$ to city $y_{i} (1 \\le x_{i}, y_{i} \\le n , x_{i} ≠ y_{i}).$ It is guaranteed that it is possible to get from any city to any other city using existing roads only. For each pair $(x , y)$ of cities there is at most one road going from city $x$ to city $y$ and at most one road going from city $y$ to city $x$ . The solution is guaranteed to exist. The sum of $m$ over all test cases in a single input does not exceed $100 000$ .\n\n", "outputFormat": "\n\nFor each test case output $m − 2n$ lines. Each line describes a road that should be abandoned. Print the road in the same format as in the input: the number of the source city and the number of the destination city. The order of roads in the output does not matter, but each road from the input may appear in the output at most once and each road in the output must have been in the input. It still must be possible to get from any city to any other city using the remaining roads.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Connections", "background": "", "description": "\n\nHard times are coming to Byteland. Quantum computing is becoming mainstream and Qubitland is going to occupy Byteland. The main problem is that Byteland does not have enough money for this war, so the King of Byteland Byteman $0x0B$ had decided to reform its road system to reduce expenses.\n\nByteland has $n$ cities that are connected by $m$ one-way roads and it is possible to get from any city to any other city using these roads. No two roads intersect outside of the cities and no other roads exist. By the way, roads are one-way because every road has a halfway barrier that may be passed in one direction only. These barriers are intended to force enemies to waste their time if they choose the wrong way.\n\nThe idea of the upcoming road reform is to abandon some roads so that exactly $2n$ roads remain. Advisers of the King think that it should be enough to keep the ability to get from any city to any other city. (Maybe even less is enough? They do not know for sure. ) The problem is how to choose roads to abandon. Everyone in Byteland knows that you are the only one who can solve this problem.\n\n", "inputFormat": "\n\nInput consists of several test cases. The first line of the input contains the number of tests cases.\n\nThe first line of each test case contains $n$ and $m$ -- the number of cities and the number of roads correspondingly $(n \\ge 4 , m > 2n).$ Each of the next $m$ lines contains two numbers $x_i$ and $y_i$ denoting a road from city $x_{i}$ to city $y_{i} (1 \\le x_{i}, y_{i} \\le n , x_{i} ≠ y_{i}).$ It is guaranteed that it is possible to get from any city to any other city using existing roads only. For each pair $(x , y)$ of cities there is at most one road going from city $x$ to city $y$ and at most one road going from city $y$ to city $x$ . The solution is guaranteed to exist. The sum of $m$ over all test cases in a single input does not exceed $100 000$ .\n\n", "outputFormat": "\n\nFor each test case output $m − 2n$ lines. Each line describes a road that should be abandoned. Print the road in the same format as in the input: the number of the source city and the number of the destination city. The order of roads in the output does not matter, but each road from the input may appear in the output at most once and each road in the output must have been in the input. It still must be possible to get from any city to any other city using the remaining roads.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Connections", "background": "", "description": "艰难的时刻即将降临到 Byteland。量子计算正在成为主流，而 Qubitland 即将占领 Byteland。主要问题是 Byteland 没有足够的资金来进行这场战争，因此 Byteland 的国王 Byteman $0x0B$ 决定改革其道路系统以减少开支。\n\nByteland 有 $n$ 个城市，通过 $m$ 条单向道路连接，可以通过这些道路从任何城市到达其他城市。没有两条道路在城市外相交，也不存在其他道路。顺便说一下，道路是单向的，因为每条道路都有一个只能单向通过的中途障碍。这些障碍旨在迫使敌人在选择错误的方向时浪费时间。\n\n即将到来的道路改革的想法是废弃一些道路，使得恰好剩下 $2n$ 条道路。国王的顾问认为这应该足以保持从任何城市到任何其他城市的通行能力。（也许更少也够？他们不确定。）问题是如何选择要废弃的道路。Byteland 的每个人都知道你是唯一能解决这个问题的人。", "inputFormat": "输入由多个测试用例组成。输入的第一行包含测试用例的数量。\n\n每个测试用例的第一行包含 $n$ 和 $m$ —— 分别是城市的数量和道路的数量 $(n \\ge 4 , m > 2n)$。接下来的 $m$ 行中的每一行包含两个数字 $x_i$ 和 $y_i$，表示从城市 $x_{i}$ 到城市 $y_{i}$ 的一条道路 $(1 \\le x_{i}, y_{i} \\le n , x_{i} \neq y_{i})$。保证可以仅使用现有道路从任何城市到达任何其他城市。对于每对城市 $(x , y)$，最多只有一条从城市 $x$ 到城市 $y$ 的道路，以及最多一条从城市 $y$ 到城市 $x$ 的道路。保证解的存在。单个输入中所有测试用例的 $m$ 之和不超过 $100 000$。", "outputFormat": "对于每个测试用例输出 $m - 2n$ 行。每行描述一条应该废弃的道路。以与输入相同的格式打印道路：源城市的编号和目的城市的编号。输出中道路的顺序无关紧要，但输入中的每条道路在输出中最多出现一次，并且输出中的每条道路必须在输入中出现。仍然必须可以使用剩余的道路从任何城市到达任何其他城市。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6955", "type": "P", "difficulty": 4, "samples": [["4 3 5\n", "6\n0 0 0\n0 1 0\n0 2 0\n0 2 2\n1 2 2\n0 0 2\n"], ["100 1 1\n", "-1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Designing the Toy", "background": "", "description": "\n\nYou are the main toy producer in the city. Recently you bought a $3D-printer$ that provides you with an unprecedented opportunity for designing new fancy toys for children.\n\nIn a package with the $3D-printer$ there is a booklet containing several examples of what can be created with it. One of the examples is a figure that looks like a triangle, like a circle, or like a square depending on which of its sides you are looking at.\n\nUnfortunately, it turned out that the booklet describes the most recent version of your printer. Your printer is only able to create figures that consist of voxels (three-dimensional pixels), i.e . figures that look like a union of a unit-length cubes that are the cells of a three-dimensional grid. Thus, you are not able to print any `smooth` figures (like a sphere, for example) with it. On the other hand, important feature of your model is its ability to create figures whose parts are not even connected with each other by putting wires of a negligible thickness between them.\n\nYou like the idea of the figure in the booklet, so you decided to improve upon this idea. Instead of specifying shapes of figure projections from different perspectives, you would specify their areas. In this problem, a voxel is defined by a triple of integers $(x , y , z)$ , which corresponds to a unit cube [x , $x + 1] \\times $ [y , $y + 1] \\times $ [z , $z + 1].$\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15286/1.png)\n\nYou are given three positive integers a , $b$ and $c$ . Your task is to find a description of a figure $F$ consisting of one or more voxels, for which the area of its orthogonal projection onto the plane Oxy is a , the area of its orthogonal projection onto the plane Oxz is $b$ , and the area of its orthogonal projection onto the plane Oyz is $c$ , or to determine that it is impossible.\n\n", "inputFormat": "\n\nThe only line of the input contains three integers a , $b$ , and $c (1 \\le $ a , $b , c \\le 100)$ -- the desired area of orthogonal projections onto the planes Oxy, Oxz, and Oyz correspondingly.\n\n", "outputFormat": "\n\nIf it is impossible to find the desired figure, print only the integer $−1$ .\n\nOtherwise, in the first line print the integer $n$ , defining the number of voxels in the figure. Then print $n$ triples $x , y , z (−100 \\le x , y , z \\le 100)$ defining the voxels of the figure. Voxels may be printed in any order, but no voxel may be repeated twice.\n\nThe number of voxels $n$ should not exceed $10^{6}.$\n\nAny figure with the requested projection areas is accepted.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Designing the Toy", "background": "", "description": "\n\nYou are the main toy producer in the city. Recently you bought a $3D-printer$ that provides you with an unprecedented opportunity for designing new fancy toys for children.\n\nIn a package with the $3D-printer$ there is a booklet containing several examples of what can be created with it. One of the examples is a figure that looks like a triangle, like a circle, or like a square depending on which of its sides you are looking at.\n\nUnfortunately, it turned out that the booklet describes the most recent version of your printer. Your printer is only able to create figures that consist of voxels (three-dimensional pixels), i.e . figures that look like a union of a unit-length cubes that are the cells of a three-dimensional grid. Thus, you are not able to print any `smooth` figures (like a sphere, for example) with it. On the other hand, important feature of your model is its ability to create figures whose parts are not even connected with each other by putting wires of a negligible thickness between them.\n\nYou like the idea of the figure in the booklet, so you decided to improve upon this idea. Instead of specifying shapes of figure projections from different perspectives, you would specify their areas. In this problem, a voxel is defined by a triple of integers $(x , y , z)$ , which corresponds to a unit cube [x , $x + 1] \\times $ [y , $y + 1] \\times $ [z , $z + 1].$\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15286/1.png)\n\nYou are given three positive integers a , $b$ and $c$ . Your task is to find a description of a figure $F$ consisting of one or more voxels, for which the area of its orthogonal projection onto the plane Oxy is a , the area of its orthogonal projection onto the plane Oxz is $b$ , and the area of its orthogonal projection onto the plane Oyz is $c$ , or to determine that it is impossible.\n\n", "inputFormat": "\n\nThe only line of the input contains three integers a , $b$ , and $c (1 \\le $ a , $b , c \\le 100)$ -- the desired area of orthogonal projections onto the planes Oxy, Oxz, and Oyz correspondingly.\n\n", "outputFormat": "\n\nIf it is impossible to find the desired figure, print only the integer $−1$ .\n\nOtherwise, in the first line print the integer $n$ , defining the number of voxels in the figure. Then print $n$ triples $x , y , z (−100 \\le x , y , z \\le 100)$ defining the voxels of the figure. Voxels may be printed in any order, but no voxel may be repeated twice.\n\nThe number of voxels $n$ should not exceed $10^{6}.$\n\nAny figure with the requested projection areas is accepted.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Designing the Toy", "background": "", "description": "你是这里的玩具生产大佬。最近你买了一台 3D 打印机，它给你提供了一个~~大赚一笔~~创造新玩具的机会。\n\n你的打印机只能打印由一个个单位方块（棱长为 $1$ 的正方体）构成的几何体。因此，你不能打印出任何“光滑”的几何体（比如球体）。另外，这台打印机打印的几何体可以有完全不相连甚至浮空的部分。\n\n建立空间直角坐标系。一个 $[x , x + 1] $ $\\times $ $[y , y + 1]$ $\\times $ $[z , z + 1]$ 的方块用整数三元组 $(x , y , z)$ 表示。\n\n现在你想指定打印出的几何体在平面 $Oxy$，平面 $Oxz$ 和平面 $Oyz$ 上的投影面积。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/udemly1h.png)\n\n给出三个正整数 $a,b,c$，依次表示几何体在平面 $Oxy$，平面 $Oxz$ 和平面 $Oyz$ 上的投影面积。判断该集合体是否存在，若存在，找到满足条件的几何体。", "inputFormat": "一行，包含 $3$ 个正整数 $a,b,c$ $(1 \\le a , b , c \\le 100)$。", "outputFormat": "如果所求几何体不存在，输出 `-1` 。\n\n否则，输出的第一行包含一个整数 $n$，表示图中方块的数量。\n\n接下来 $n$ 行，每行 $3$ 个整数 $x,y,z$ 表示每个方块的位置。方块可以按任意顺序输出，但不能重复。\n\n$n$ 的值不应超过 $10^{6}$。\n\n任何满足条件的几何体都算作正确。", "hint": "时间限制：3s，内存限制：512MB。\n\nTranslated by Georiky", "locale": "zh-CN"}}}
{"pid": "P6956", "type": "P", "difficulty": 3, "samples": [["10\n1 0 -4 0 0 -1 -3 0 -1 -2\n", "Yes\n4 1 3 2\n"], ["5\n5 8 0 -6 -3\n", "No\n"], ["3\n2 -2 -2\n", "No\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Easy Quest", "background": "", "description": "\n\nA young hero is starting his heroic life. The wise wizard suggested him an easy first quest. During this quest our young hero meets $n$ magical creatures, in specific order. In order to help the young hero, the wizard gave him a clue -- a list of $n$ integers $a_{i}.$\n\nIf $a_{i}$ is positive, then the i-th magical creature is benevolent and gives to our hero one magical item of type $a_{i}.$ The hero can keep several items of the same type.\n\nIf $a_i$ is negative, then the i-th magical creature is evil and in order to defeat it the young hero needs one magical item of type $−a_{i}.$ All magical items are fragile and can be used only once.\n\nIf $a_{i}$ is zero, then the i-th creature is a unicorn. It gives the hero any magical item he asks for, but only one.\n\nYour task is to help the young hero to finish the first quest, defeating all enemies on the way, or say that it is impossible.\n\n", "inputFormat": "\n\nThe first line of input contains one integer $n (1 \\le n \\le 1000)$ . The second line contains $n$ integers $a_{i} (−1000 \\le a_{i} \\le 1000)$ .\n\n", "outputFormat": "\n\nIf it is impossible to defeat all enemies, then output one string `No`. If it is possible, then output string `Yes`, and in the next line output the types of items the hero should ask the unicorns for, in order they meet during the quest. Types must be integers in range from $1$ to $1000$ inclusive. If there are several solutions, output any of them.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Easy Quest", "background": "", "description": "\n\nA young hero is starting his heroic life. The wise wizard suggested him an easy first quest. During this quest our young hero meets $n$ magical creatures, in specific order. In order to help the young hero, the wizard gave him a clue -- a list of $n$ integers $a_{i}.$\n\nIf $a_{i}$ is positive, then the i-th magical creature is benevolent and gives to our hero one magical item of type $a_{i}.$ The hero can keep several items of the same type.\n\nIf $a_i$ is negative, then the i-th magical creature is evil and in order to defeat it the young hero needs one magical item of type $−a_{i}.$ All magical items are fragile and can be used only once.\n\nIf $a_{i}$ is zero, then the i-th creature is a unicorn. It gives the hero any magical item he asks for, but only one.\n\nYour task is to help the young hero to finish the first quest, defeating all enemies on the way, or say that it is impossible.\n\n", "inputFormat": "\n\nThe first line of input contains one integer $n (1 \\le n \\le 1000)$ . The second line contains $n$ integers $a_{i} (−1000 \\le a_{i} \\le 1000)$ .\n\n", "outputFormat": "\n\nIf it is impossible to defeat all enemies, then output one string `No`. If it is possible, then output string `Yes`, and in the next line output the types of items the hero should ask the unicorns for, in order they meet during the quest. Types must be integers in range from $1$ to $1000$ inclusive. If there are several solutions, output any of them.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Easy Quest", "background": "", "description": "一位年轻的英雄开始了他的英雄生涯。聪明的巫师给他建议了一个简单的第一个任务。在这个任务中，我们的年轻英雄遇到了 $n$ 个魔法生物，按特定顺序排列。为了帮助年轻英雄，巫师给了他一个线索——一个包含 $n$ 个整数 $a_{i}$ 的列表。\n\n如果 $a_{i}$ 是正数，那么第 $i$ 个魔法生物是仁慈的，并给我们的英雄一个类型为 $a_{i}$ 的魔法物品。英雄可以保留多个相同类型的物品。\n\n如果 $a_i$ 是负数，那么第 $i$ 个魔法生物是邪恶的，为了打败它，年轻英雄需要一个类型为 $-a_{i}$ 的魔法物品。所有魔法物品都是易碎的，只能使用一次。\n\n如果 $a_{i}$ 是零，那么第 $i$ 个生物是独角兽。它会给英雄他所要求的任何魔法物品，但只能给一个。\n\n你的任务是帮助年轻英雄完成第一个任务，击败途中所有的敌人，或者说这是不可能的。", "inputFormat": "输入的第一行包含一个整数 $n (1 \\le n \\le 1000)$。第二行包含 $n$ 个整数 $a_{i} (-1000 \\le a_{i} \\le 1000)$。", "outputFormat": "如果无法击败所有敌人，则输出字符串 `No`。如果可以，则输出字符串 `Yes`，并在下一行输出英雄在任务中遇到的独角兽时应该请求的物品类型。类型必须是从 $1$ 到 $1000$ 范围内的整数。如果有多种解决方案，输出其中任何一种即可。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\nspj 提供者：@[shenyouran](\\/user\\/137367)。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6957", "type": "P", "difficulty": 6, "samples": [["2\n2 3 2\n4 -1 3\n", "2\n1 1 0 0\n1 2 2 3\n2\n0 0 2 -2\n3 -3 5 -1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] The Final Level", "background": "", "description": "\n\nFiora is a game designer. Now she is designing the final level for her new game.\n\nA level for this game is a labyrinth on a rectangular grid with lots of enemies. Player starts her game at the square $(0 , 0)$ and her purpose is to get to the square $(a , b)$ . Fiora has lots of ideas on how to put enemies, but she does not like designing labyrinths. She needs your help here.\n\nFiora is drawing levels in a special level editor which supports one basic block to design a labyrinth. This block is an L-shaped corner, consisting of two perpendicular rectangles $1 \\times n$ squares in size intersecting at $1 \\times 1$ square. It is possible to rotate this block in four ways. Blocks cannot intersect, but they can touch each other. Player can move through all the squares lying in any block. She can move between two squares if they are sharing a side, even if they are in different blocks.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15288/1.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15288/2.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15288/3.png)\n\nBlocks with $n = 3$\n\nThe first example\n\nThe second example\n\nFiora wants to design the final level with the minimal possible number of blocks. Of course, it should be possible to move from square $(0 , 0)$ to square $(a , b)$ .\n\n", "inputFormat": "\n\nThe first line of the input consists of a single integer $m (1 \\le m \\le 100)$ -- the number of test cases. It is followed by $m$ test cases. Each test case is on a separate line and consists of three integers a , $b$ , and $n (−10^{8} \\le $ a , $b \\le 10^{8}; 2 \\le n \\le 10^{8})$ -- a is the coordinate of the final point along the horizontal axis, $b$ is the coordinate of the final point along the vertical axis, and $n$ is the size of the block. The final point is not same as the starting one (either a $≠ 0$ or $b ≠ 0)$ .\n\n", "outputFormat": "\n\nFor each test case, in the first line print the minimal number $k$ of blocks you need. In the following $k$ lines print description of these blocks. Each L-shaped corner block is described by coordinates of two cells. Print coordinates of the end of its vertical rectangle, followed by coordinates of the end of its horizontal rectangle. Specify the coordinates of the ends that are opposite to the intersection of the rectangles. Note that the order of cells in the block description matters, since a change of the order results in a reflected block. Coordinates of each end should be printed with the coordinate along the horizontal axis first, followed by the coordinate along the vertical axis.\n\nAll coordinates in the output should not exceed $10^{9}$ by absolute value.\n\nIt is guaranteed that the total number of blocks in the correct output does not exceed $10^{5}$ for all test cases combined.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] The Final Level", "background": "", "description": "\n\nFiora is a game designer. Now she is designing the final level for her new game.\n\nA level for this game is a labyrinth on a rectangular grid with lots of enemies. Player starts her game at the square $(0 , 0)$ and her purpose is to get to the square $(a , b)$ . Fiora has lots of ideas on how to put enemies, but she does not like designing labyrinths. She needs your help here.\n\nFiora is drawing levels in a special level editor which supports one basic block to design a labyrinth. This block is an L-shaped corner, consisting of two perpendicular rectangles $1 \\times n$ squares in size intersecting at $1 \\times 1$ square. It is possible to rotate this block in four ways. Blocks cannot intersect, but they can touch each other. Player can move through all the squares lying in any block. She can move between two squares if they are sharing a side, even if they are in different blocks.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15288/1.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15288/2.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15288/3.png)\n\nBlocks with $n = 3$\n\nThe first example\n\nThe second example\n\nFiora wants to design the final level with the minimal possible number of blocks. Of course, it should be possible to move from square $(0 , 0)$ to square $(a , b)$ .\n\n", "inputFormat": "\n\nThe first line of the input consists of a single integer $m (1 \\le m \\le 100)$ -- the number of test cases. It is followed by $m$ test cases. Each test case is on a separate line and consists of three integers a , $b$ , and $n (−10^{8} \\le $ a , $b \\le 10^{8}; 2 \\le n \\le 10^{8})$ -- a is the coordinate of the final point along the horizontal axis, $b$ is the coordinate of the final point along the vertical axis, and $n$ is the size of the block. The final point is not same as the starting one (either a $≠ 0$ or $b ≠ 0)$ .\n\n", "outputFormat": "\n\nFor each test case, in the first line print the minimal number $k$ of blocks you need. In the following $k$ lines print description of these blocks. Each L-shaped corner block is described by coordinates of two cells. Print coordinates of the end of its vertical rectangle, followed by coordinates of the end of its horizontal rectangle. Specify the coordinates of the ends that are opposite to the intersection of the rectangles. Note that the order of cells in the block description matters, since a change of the order results in a reflected block. Coordinates of each end should be printed with the coordinate along the horizontal axis first, followed by the coordinate along the vertical axis.\n\nAll coordinates in the output should not exceed $10^{9}$ by absolute value.\n\nIt is guaranteed that the total number of blocks in the correct output does not exceed $10^{5}$ for all test cases combined.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] The Final Level", "background": "", "description": "用长度为 $n$ 的 L 型方块摆在二维网格平面上，仅通过方块从 $(0,0)$ 走到 $(a,b)$。", "inputFormat": "第一行一个正整数 $m$ ，下面 $m$ 行每行 $3$ 个正整数 $a, b, n$。", "outputFormat": "对于每组数据，输出最小 L 型块数 $k$，下面 $k$ 行每行按先横坐标后纵坐标的顺序输出每个 L 型块两端的坐标。", "hint": "对于 $100\\%$ 的数据，$1 \\le m \\le 100, -10^8 \\le a, b  \\le 10^8, 2 \\le n \\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P6958", "type": "P", "difficulty": 6, "samples": [["4 2 1\n1 2 3 4\n3 3 5 5\n7 7 7 7\n", "16\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] The Great Wall", "background": "", "description": "\n\nRecently you had become an emperor of a small country of Sinai. You had decided to build a big wall at the border to save your country from barbarian raids. You had contacted `W Corp`, the only company in the world that builds non-penetrable walls.\n\n`W Corp` builds each wall using the same pattern. The length of the wall is $n$ meters. Each one-meter piece of the wall is numbered by an integer from $1$ to $n$ along its length and may have a different height. The height pattern is based on three fixed arrays a , $b$ , and $c$ of $n$ elements each, such that $a_{i} < b_{i} < c_{i}$ for all $1 \\le i \\le n$ , and an integer $r (1 \\le r < n)$ . These arrays and $r$ are the same for any wall that is built by `W Corp`.\n\nThe choice of the specific wall design is determined by two distinct integers $x$ and $y (1 \\le x < y \\le n−r+1)$ in the following way. Take two ranges of integers: [x , $x+r−1]$ and [y , $y+r−1]$ (these ranges are inclusive of their ends). Then the height of the wall at one meter piece $i$ for all $1 \\le i \\le n$ is equal to:\n\n$a_{i}$ if $i$ does not belong to any of the chosen ranges;\n\n$b_{i}$ if $i$ belongs to exactly one chosen range;\n\n$c_{i}$ if $i$ belongs to both chosen ranges.\n\nA strength of a wall is defined as the sum of all heights of its $n$ one meter pieces.\n\nThe arrays a , $b , c$ , and an integer $r$ are the same for any wall built by `W Corp`, so the company provides a price list with all the possible wall designs, sorted in non-decreasing order of their strength. You choose the k-th wall design from the list. The task is to find the strength of the chosen wall.\n\n", "inputFormat": "\n\nThe first line of the input contains three integers $n , r$ and $k (2 \\le n \\le 30 000 , 1 \\le r < n , 1 \\le k \\le (n−r)(n−r+1)/2)$ -- the length of the wall, the length of the segments to choose, and the position of the wall in the price list.\n\nThe second line of the input contains the elements of the array a $(1 \\le a_{i} \\le 10^{6}).$\n\nThe third line of the input contains the elements of the array $b (a_{i} < b_{i} \\le 10^{6}).$\n\nThe fourth line of the input contains the elements of the array $c (b_{i} < c_{i} \\le 10^{6}).$\n\n", "outputFormat": "\n\nPrint one integer -- the strength of the k-th wall from `W Corp` price list.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] The Great Wall", "background": "", "description": "\n\nRecently you had become an emperor of a small country of Sinai. You had decided to build a big wall at the border to save your country from barbarian raids. You had contacted `W Corp`, the only company in the world that builds non-penetrable walls.\n\n`W Corp` builds each wall using the same pattern. The length of the wall is $n$ meters. Each one-meter piece of the wall is numbered by an integer from $1$ to $n$ along its length and may have a different height. The height pattern is based on three fixed arrays a , $b$ , and $c$ of $n$ elements each, such that $a_{i} < b_{i} < c_{i}$ for all $1 \\le i \\le n$ , and an integer $r (1 \\le r < n)$ . These arrays and $r$ are the same for any wall that is built by `W Corp`.\n\nThe choice of the specific wall design is determined by two distinct integers $x$ and $y (1 \\le x < y \\le n−r+1)$ in the following way. Take two ranges of integers: [x , $x+r−1]$ and [y , $y+r−1]$ (these ranges are inclusive of their ends). Then the height of the wall at one meter piece $i$ for all $1 \\le i \\le n$ is equal to:\n\n$a_{i}$ if $i$ does not belong to any of the chosen ranges;\n\n$b_{i}$ if $i$ belongs to exactly one chosen range;\n\n$c_{i}$ if $i$ belongs to both chosen ranges.\n\nA strength of a wall is defined as the sum of all heights of its $n$ one meter pieces.\n\nThe arrays a , $b , c$ , and an integer $r$ are the same for any wall built by `W Corp`, so the company provides a price list with all the possible wall designs, sorted in non-decreasing order of their strength. You choose the k-th wall design from the list. The task is to find the strength of the chosen wall.\n\n", "inputFormat": "\n\nThe first line of the input contains three integers $n , r$ and $k (2 \\le n \\le 30 000 , 1 \\le r < n , 1 \\le k \\le (n−r)(n−r+1)/2)$ -- the length of the wall, the length of the segments to choose, and the position of the wall in the price list.\n\nThe second line of the input contains the elements of the array a $(1 \\le a_{i} \\le 10^{6}).$\n\nThe third line of the input contains the elements of the array $b (a_{i} < b_{i} \\le 10^{6}).$\n\nThe fourth line of the input contains the elements of the array $c (b_{i} < c_{i} \\le 10^{6}).$\n\n", "outputFormat": "\n\nPrint one integer -- the strength of the k-th wall from `W Corp` price list.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] The Great Wall", "background": "", "description": "最近你成为了西奈一个小国家的皇帝。你决定在边界建造一座长城保护你的国家不被野蛮人抢劫。你联系了“W Corp”——世界上唯一的建造坚不可摧的墙的公司。\n\n“W Corp”用相同的格式建造所有墙。墙的长度是 $n$ 米，每一米墙按顺序从 $1$ 到 $n$ 编号，它们可能有不同的高度。高度的格式取决于三个固定的数组 $a,b,c$，它们各有 $n$ 个元素，对于任意 $1\\le i\\le n$ 满足 $a_i < b_i < c_i$，还有一个整数 $r\\ (1\\le r < n)$。三个数组和 $r$ 对于“W Corp”建造的任何墙都是相同的。\n\n按照如下方式，具体的墙体设计的选择取决于两个不同的整数 $x,y\\ (1\\le x < y\\le n-r+1)$。取两个整数区间：$[x,x+r-1]$ 和 $[y,y+r-1]$（区间包括端点）。那么第 $i$ 米墙的高度是：\n\n- $a_i$，当 $i$ 不属于这两个区间\n- $b_i$，当 $i$ 属于这两个区间中的恰好一个\n- $c_i$，当 $i$ 属于这两个区间中的两个\n\n墙的**强度**定义为每一米墙高度的和。\n\n在“W Corp”建造的所有墙中，数组 $a,b,c$ 和整数 $r$ 都是固定的。公司提供了一份所有可能的墙体设计的列表，按照强度单调不减排序。你选择了其中第 $k$ 种墙体设计。你的任务是，求出你选择的墙的强度。", "inputFormat": "第一行包括三个整数 $n,r,k\\ (2\\le n\\le 30000,\\ 1\\le r < n,\\ 1\\le k\\le \\frac{(n-r)(n-r+1)}{2}\\ \\ )$，分别代表墙的长度，取的区间的长度，你的选择在列表中的位置。\n\n第二行包括了数组 $a$ 的元素，$1\\le a_i\\le 10^6$。\n\n第三行包括了数组 $b$ 的元素，$1\\le b_i\\le 10^6$。\n\n第四行包括了数组 $c$ 的元素，$1\\le c_i\\le 10^6$。", "outputFormat": "输出一个整数，“W Corp”的列表中第 $k$ 种墙的强度\n\n### 样例解释\n\n在样例中，能建造出的不同的墙有三种：\n\n- 选择 $x=1,y=2$，墙的高度是 $[3,7,5,4]$，强度是 $19$。\n- 选择 $x=1,y=3$，墙的高度是 $[3,3,5,5]$，强度是 $16$。\n- 选择 $x=2,y=3$，墙的高度是 $[1,3,7,5]$，强度是 $16$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6959", "type": "P", "difficulty": 7, "samples": [["15\n980\n293", "? 3\n? 8\n! 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2017", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Hack", "background": "", "description": "Heidi is analyzing a peculiar device. This device takes an a as input and computes $a^d(mod n)$ using thefollowing pseudocode and some integers $d$ and $n$ stored in this device:\n\n ```\nmodPow(a, d, n) {\n  r = 1;\n  for (i = 0; i < 60; ++i) {\n    if ((d & (1 << i)) != 0) {\n      r = r * a % n;\n    }\n  a = a * a % n;\n  }\n}\n```\n\nNote that the pseudocode assumes arbitrary sized integers, $<<$ denotes bitwise shift left, $&$ denotes bitwise\n\nand, and % denotes modulo.\n\nThe device does not tell Heidi the result of the computation. However, Heidi can measure how long does the computation take. She knows that only multiplication modulo $n$ (lines $5$ and $7$ in the above pseudocode) takes any measurable amount of time, all other lines can be assumed to take $0$ nanoseconds.\n\nMoreover, she knows that it takes $(bits(x) + 1) · (bits(y) + 1)$ nanoseconds to multiply $x$ by $y$ modulo $n$ , where $bits(x)$ is the number of bits in the binary representation of $x$ without leading zeros, or more formally $\\text{bits(x)} = ⌈\\log_2 (x + 1)⌉.\n\nHeidi knows the integer $n$ but does not know the integer $d$ . She wants to find $d$ by feeding the device different integers a as input and measuring the time the computation takes for each a .\n\nShe knows that $n$ and $d$ were chosen in the following way: first, two prime numbers $p$ and $q$ with $30$ bits in binary representation (in other words, between $229$ and $230 −1)$ were picked independently and uniformly at random. Then the number $n$ was computed as $n = p · q$ . Then the number $m = φ(n) = (p−1)·(q −1)$\n\nwas computed. Then $d$ was picked uniformly at random between $1$ and $m − 1$ inclusive, such that it is coprime with $m$ .\n\n# Interaction Protocol\n\nFirst, the testing system writes the integer $n$ -- the modulo used by the device. Note that $n$ and the hidden number $d$ are guaranteed to have been generated according to the procedure described above.\n\nYour solution shall print requests of two types:\n\n- “? a” tells to feed a as input to the device. a must be an integer between $0$ and $n−1$ inclusive. The testing system responds with the time it took the device to compute `modPow(a , d , n)` in nanoseconds.\n\n- “! d” tells the value of $d$ that your program has determined.\n\nDon't forget to flush the output after each request!\n\nYour solution must issue exactly one request of the second type, which must be the last request, and the solution must terminate gracefully after issuing it.\n\nYour solution is allowed to issue at most $30 000$ requests of the first type.\n\nYour solution will be run on $30$ testcases, working with one $(n , d)$ pair per run. For each testcase the numbers $n$ and $d$ are fixed and were generated using the procedure described above. The example below\n\nwas not generated in that manner and thus will not be used for testing your solution; it only serves to illustrate the input/output format and provide a sanity check for your calculation of the computation time. ", "inputFormat": "", "outputFormat": "", "hint": "", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Hack", "background": "", "description": "Heidi is analyzing a peculiar device. This device takes an a as input and computes $a^d(mod n)$ using thefollowing pseudocode and some integers $d$ and $n$ stored in this device:\n\n ```\nmodPow(a, d, n) {\n  r = 1;\n  for (i = 0; i < 60; ++i) {\n    if ((d & (1 << i)) != 0) {\n      r = r * a % n;\n    }\n  a = a * a % n;\n  }\n}\n```\n\nNote that the pseudocode assumes arbitrary sized integers, $<<$ denotes bitwise shift left, $&$ denotes bitwise\n\nand, and % denotes modulo.\n\nThe device does not tell Heidi the result of the computation. However, Heidi can measure how long does the computation take. She knows that only multiplication modulo $n$ (lines $5$ and $7$ in the above pseudocode) takes any measurable amount of time, all other lines can be assumed to take $0$ nanoseconds.\n\nMoreover, she knows that it takes $(bits(x) + 1) · (bits(y) + 1)$ nanoseconds to multiply $x$ by $y$ modulo $n$ , where $bits(x)$ is the number of bits in the binary representation of $x$ without leading zeros, or more formally $\\text{bits(x)} = ⌈\\log_2 (x + 1)⌉.\n\nHeidi knows the integer $n$ but does not know the integer $d$ . She wants to find $d$ by feeding the device different integers a as input and measuring the time the computation takes for each a .\n\nShe knows that $n$ and $d$ were chosen in the following way: first, two prime numbers $p$ and $q$ with $30$ bits in binary representation (in other words, between $229$ and $230 −1)$ were picked independently and uniformly at random. Then the number $n$ was computed as $n = p · q$ . Then the number $m = φ(n) = (p−1)·(q −1)$\n\nwas computed. Then $d$ was picked uniformly at random between $1$ and $m − 1$ inclusive, such that it is coprime with $m$ .\n\n# Interaction Protocol\n\nFirst, the testing system writes the integer $n$ -- the modulo used by the device. Note that $n$ and the hidden number $d$ are guaranteed to have been generated according to the procedure described above.\n\nYour solution shall print requests of two types:\n\n- “? a” tells to feed a as input to the device. a must be an integer between $0$ and $n−1$ inclusive. The testing system responds with the time it took the device to compute `modPow(a , d , n)` in nanoseconds.\n\n- “! d” tells the value of $d$ that your program has determined.\n\nDon't forget to flush the output after each request!\n\nYour solution must issue exactly one request of the second type, which must be the last request, and the solution must terminate gracefully after issuing it.\n\nYour solution is allowed to issue at most $30 000$ requests of the first type.\n\nYour solution will be run on $30$ testcases, working with one $(n , d)$ pair per run. For each testcase the numbers $n$ and $d$ are fixed and were generated using the procedure described above. The example below\n\nwas not generated in that manner and thus will not be used for testing your solution; it only serves to illustrate the input/output format and provide a sanity check for your calculation of the computation time. ", "inputFormat": "", "outputFormat": "", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Hack", "background": "", "description": "Heidi 正在分析一个特殊的设备。该设备以一个 $a$ 作为输入，并使用以下伪代码和存储在设备中的一些整数 $d$ 和 $n$ 计算 $a^d \\bmod n$：\n\n```\nmodPow(a, d, n) {\n  r = 1;\n  for (i = 0; i < 60; ++i) {\n    if ((d & (1 << i)) != 0) {\n      r = r * a % n;\n    }\n  a = a * a % n;\n  }\n}\n```\n\n注意，伪代码假设整数可以是任意大小，$<<$ 表示按位左移，$&$ 表示按位与，% 表示取模。\n\n设备不会告诉 Heidi 计算结果。然而，Heidi 可以测量计算所需的时间。她知道只有模 $n$ 的乘法（上述伪代码中的第 5 行和第 7 行）需要可测量的时间，其他所有行可以假设为 0 纳秒。\n\n此外，她知道将 $x$ 和 $y$ 模 $n$ 相乘需要 $(\\text{bits}(x) + 1) \\cdot (\\text{bits}(y) + 1)$ 纳秒，其中 $\\text{bits}(x)$ 是 $x$ 的二进制表示中不含前导零的位数，更正式地，$\\text{bits}(x) = \\lceil \\log_2 (x + 1) \\rceil$。\n\nHeidi 知道整数 $n$，但不知道整数 $d$。她想通过将不同的整数 $a$ 作为输入提供给设备，并测量每个 $a$ 的计算时间来找到 $d$。\n\n她知道 $n$ 和 $d$ 是通过以下方式选择的：首先，两个具有 30 位二进制表示的素数 $p$ 和 $q$（换句话说，在 $2^{29}$ 和 $2^{30} - 1$ 之间）被独立且均匀地随机选择。然后计算 $n = p \\cdot q$。然后计算 $m = \\varphi(n) = (p-1) \\cdot (q-1)$。然后在 $1$ 到 $m - 1$ 之间均匀随机选择 $d$，使其与 $m$ 互质。\n\n# 交互协议\n\n首先，测试系统写入整数 $n$——设备使用的模数。注意，$n$ 和隐藏的数字 $d$ 保证是按照上述过程生成的。\n\n你的解决方案应打印两种类型的请求：\n\n- “? a” 告诉设备以 $a$ 作为输入。$a$ 必须是 $0$ 到 $n-1$ 之间的整数。测试系统会返回设备计算 `modPow(a , d , n)` 所需的时间（以纳秒为单位）。\n\n- “! d” 告诉你的程序已确定的 $d$ 值。\n\n不要忘记在每次请求后刷新输出！\n\n你的解决方案必须发出恰好一个第二种类型的请求，该请求必须是最后一个请求，并且解决方案在发出该请求后必须正常终止。\n\n你的解决方案最多可以发出 $30,000$ 个第一种类型的请求。\n\n你的解决方案将在 $30$ 个测试用例上运行，每次运行处理一个 $(n , d)$ 对。对于每个测试用例，数字 $n$ 和 $d$ 是固定的，并且是使用上述过程生成的。下面的例子不是以这种方式生成的，因此不会用于测试你的解决方案；它仅用于说明输入/输出格式并为计算时间的合理性检查提供一个 sanity check。", "inputFormat": "", "outputFormat": "", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6960", "type": "P", "difficulty": 6, "samples": [["5\n>\n>\n<\n>\n<\n<\n", "? 1 1\n? 1 2\n? 1 3\n? 2 1\n? 2 2\n? 2 3\n! 4 2 1 3 5"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Interactive Sort", "background": "这是一道 IO 交互题。", "description": "Ivan wants to play a game with you. He took all integers from $1$ to $n$ inclusive, shuffled them and then put all even numbers into array $e$ and all odd numbers into array $o$ .\n\nYour task is to find arrays $e$ and $o$ .\n\nYou can ask Ivan questions of certain kind. Each question consists of two integers $i$ and $j$ . For each question Ivan says whether $e[i] < o[j]$ or not.\n\nYou can ask at most $300 000$ questions.\n\n# Interaction Protocol\n\nFirst, the testing system writes the integer $n (1 \\le n \\le 10 000)$ -- the number of integers Ivan used.\n\nYour solution shall print requests of two types:\n\n• “? i j”. $1 \\le i \\le ⌊n/2⌋, 1 \\le j \\le ⌈n/2⌉$. The testing system responds with the symbol $“<”$ if $e[i] < o[j]$ or with the symbol $“>”$ otherwise.\n\n• “!\\ $e_1\\ e_2\\ \\cdots e_{⌊n/2⌋}\\ o_1\\ o_2 \\cdots o_{⌈n/2⌉}$” tells the values of $e$ and $o$ that your program has determined.\n\nDon't forget to flush the output after each request!\n\nYour solution must issue exactly one request of the second type, which must be the last request, and thesolution must terminate gracefully after issuing it.\n\nYour solution is allowed to issue at most $300 000$ requests of the first type.\n\nFor each test case the number $n$ is fixed and the numbers are shuffled using Java built-in shuffle functionwith fixed seed.\n\n\n", "inputFormat": "", "outputFormat": "", "hint": "", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Interactive Sort", "background": "这是一道 IO 交互题。", "description": "Ivan wants to play a game with you. He took all integers from $1$ to $n$ inclusive, shuffled them and then put all even numbers into array $e$ and all odd numbers into array $o$ .\n\nYour task is to find arrays $e$ and $o$ .\n\nYou can ask Ivan questions of certain kind. Each question consists of two integers $i$ and $j$ . For each question Ivan says whether $e[i] < o[j]$ or not.\n\nYou can ask at most $300 000$ questions.\n\n# Interaction Protocol\n\nFirst, the testing system writes the integer $n (1 \\le n \\le 10 000)$ -- the number of integers Ivan used.\n\nYour solution shall print requests of two types:\n\n• “? i j”. $1 \\le i \\le ⌊n/2⌋, 1 \\le j \\le ⌈n/2⌉$. The testing system responds with the symbol $“<”$ if $e[i] < o[j]$ or with the symbol $“>”$ otherwise.\n\n• “!\\ $e_1\\ e_2\\ \\cdots e_{⌊n/2⌋}\\ o_1\\ o_2 \\cdots o_{⌈n/2⌉}$” tells the values of $e$ and $o$ that your program has determined.\n\nDon't forget to flush the output after each request!\n\nYour solution must issue exactly one request of the second type, which must be the last request, and thesolution must terminate gracefully after issuing it.\n\nYour solution is allowed to issue at most $300 000$ requests of the first type.\n\nFor each test case the number $n$ is fixed and the numbers are shuffled using Java built-in shuffle functionwith fixed seed.\n\n\n", "inputFormat": "", "outputFormat": "", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Interactive Sort", "background": null, "description": "Ivan 想和你玩一个游戏。他选取了从 $1$ 到 $n$ 的所有整数，打乱顺序后，将所有偶数放入数组 $e$，所有奇数放入数组 $o$。\n\n你的任务是找出数组 $e$ 和 $o$。\n\n你可以向 Ivan 提出特定类型的问题。每个问题包含两个整数 $i$ 和 $j$。对于每个问题，Ivan 会回答 $e[i] < o[j]$ 是否成立。\n\n你最多可以提出 $300,000$ 个问题。\n\n## 交互协议\n\n首先，测试系统会输入整数 $n (1 \\le n \\le 10,000)$ —— Ivan 使用的整数数量。\n\n你的解决方案应输出两种类型的请求：\n\n• “? i j”。其中 $1 \\le i \\le ⌊n/2⌋, 1 \\le j \\le ⌈n/2⌉$。测试系统会响应符号 $“<”$ 表示 $e[i] < o[j]$，否则响应符号 $“>”$。\n\n• “! $e_1\\ e_2\\ \\cdots e_{⌊n/2⌋}\\ o_1\\ o_2 \\cdots o_{⌈n/2⌉}$” 表示你的程序确定的 $e$ 和 $o$ 的值。\n\n在每次请求后不要忘记刷新输出缓冲区！\n\n你的解决方案必须恰好发出一次第二种类型的请求，且该请求必须是最后一个请求，并在发出后正常终止。\n\n你的解决方案最多可以发出 $300,000$ 次第一种类型的请求。\n\n每个测试用例的 $n$ 值是固定的，数字使用 Java 内置的洗牌函数（使用固定种子）进行打乱。", "inputFormat": null, "outputFormat": null, "hint": "题面翻译由 Deepseek 提供。", "locale": "zh-CN"}}}
{"pid": "P6961", "type": "P", "difficulty": 6, "samples": [["6 7 2\n1 2 6\n2 3 1\n2 4 3\n2 5 5\n3 6 10\n4 6 9\n5 6 8\n", "14\n"], ["5 5 3\n2 1 1\n3 2 1\n4 3 1\n4 5 1\n1 5 2\n", "2\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "最短路", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Journey from Petersburg to Moscow", "background": "", "description": "\n\nTo conduct The World Programming Cup $2112$ a network of wonderful toll roads was build in European part of Russia. This network consists of $m$ bidirectional roads that connect $n$ cities. Each road connects exactly two distinct cities, no two roads connect the same pair of cities, and it is possible to travel from any city to any other city using only this road network. Moreover, to ease the process of charging, no two roads intersect outside of the cities.\n\nEach road is assigned some individual positive cost. Normally, if a driver makes a trip using some of these toll roads, at the end of his journey he would be charged the total cost equal to the sum of individual costs of all roads he has used. To increase the popularity of car travels between two capitals, the operator company Radishchev Inc introduced a special offer: make a journey from Saint Petersburg to Moscow and pay for only $k$ most expensive roads along your path.\n\nFormally, let some path consists of $l$ roads. Denote as $c_{1}$ the cost of the most expensive road along this path, as $c_{2}$ the second most expensive and so on. Thus, we have a sequence $c_{1} \\ge c_{2} \\ge c_{3} \\ge $ . . . $ \\ge c_{l}$ of individual costs of all roads along the chosen path. If $l \\le k$ , then the path is too short and the driver pays the sum of all individual costs as usual, i.e . $Σ^{l}_{i=1}c_{i}.$ If $l > k$ , then the driver only pays for $k$ most expensive roads, that is $Σ^{k}_{i=1}c_{i}.$\n\nAs the chief analyst of Radishchev Inc you were assigned a task to compute the cheapest possible journey from Saint Petersburg to Moscow.\n\n", "inputFormat": "\n\nThe first line of the input contains three integers $n , m$ and $k (2 \\le n \\le 3000 , 1 \\le m \\le 3000 , 1 \\le k < n)$ -- the number of cities, the number of roads in the road network, and the maximum number of roads that one should pay for in a single journey.\n\nNext $m$ lines contain description of roads. Each road description contains three integers $u_{i}, v_{i},$ and $w_{i} (1 \\le u_{i}, v_{i} \\le n , u_{i} ≠ v_{i}, 1 \\le w_{i} \\le 10^{9})$ -- the i-th bidirectional road that connects cities $u_{i}$ and $v_{i}$ with the cost of $w_{i}$ for any direction. It is guaranteed that there is at most one road between each pair of cities and it is possible to get from any city to any other city using only these roads.\n\n", "outputFormat": "\n\nPrint one integer equal to the minimum possible cost of travel from the city number $1$ (Saint Petersburg) to the city number $n (Moscow).$\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Journey from Petersburg to Moscow", "background": "", "description": "\n\nTo conduct The World Programming Cup $2112$ a network of wonderful toll roads was build in European part of Russia. This network consists of $m$ bidirectional roads that connect $n$ cities. Each road connects exactly two distinct cities, no two roads connect the same pair of cities, and it is possible to travel from any city to any other city using only this road network. Moreover, to ease the process of charging, no two roads intersect outside of the cities.\n\nEach road is assigned some individual positive cost. Normally, if a driver makes a trip using some of these toll roads, at the end of his journey he would be charged the total cost equal to the sum of individual costs of all roads he has used. To increase the popularity of car travels between two capitals, the operator company Radishchev Inc introduced a special offer: make a journey from Saint Petersburg to Moscow and pay for only $k$ most expensive roads along your path.\n\nFormally, let some path consists of $l$ roads. Denote as $c_{1}$ the cost of the most expensive road along this path, as $c_{2}$ the second most expensive and so on. Thus, we have a sequence $c_{1} \\ge c_{2} \\ge c_{3} \\ge $ . . . $ \\ge c_{l}$ of individual costs of all roads along the chosen path. If $l \\le k$ , then the path is too short and the driver pays the sum of all individual costs as usual, i.e . $Σ^{l}_{i=1}c_{i}.$ If $l > k$ , then the driver only pays for $k$ most expensive roads, that is $Σ^{k}_{i=1}c_{i}.$\n\nAs the chief analyst of Radishchev Inc you were assigned a task to compute the cheapest possible journey from Saint Petersburg to Moscow.\n\n", "inputFormat": "\n\nThe first line of the input contains three integers $n , m$ and $k (2 \\le n \\le 3000 , 1 \\le m \\le 3000 , 1 \\le k < n)$ -- the number of cities, the number of roads in the road network, and the maximum number of roads that one should pay for in a single journey.\n\nNext $m$ lines contain description of roads. Each road description contains three integers $u_{i}, v_{i},$ and $w_{i} (1 \\le u_{i}, v_{i} \\le n , u_{i} ≠ v_{i}, 1 \\le w_{i} \\le 10^{9})$ -- the i-th bidirectional road that connects cities $u_{i}$ and $v_{i}$ with the cost of $w_{i}$ for any direction. It is guaranteed that there is at most one road between each pair of cities and it is possible to get from any city to any other city using only these roads.\n\n", "outputFormat": "\n\nPrint one integer equal to the minimum possible cost of travel from the city number $1$ (Saint Petersburg) to the city number $n (Moscow).$\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Journey from Petersburg to Moscow", "background": null, "description": "为了举办世界编程杯 $2112$，在俄罗斯的欧洲部分建造了一张奇妙的收费公路网络。这个网络由 $m$ 条双向道路组成，连接了 $n$ 座城市。每条道路连接恰好两座不同的城市，没有两条道路连接相同的城市对，并且可以仅使用这张公路网络从任何城市到达其他城市。此外，为了简化收费过程，没有两条道路在城市外相交。\n\n每条道路都有一个单独的正费用。通常情况下，如果司机使用这些收费公路进行旅行，在旅程结束时，他将支付等于所使用的所有道路的单个费用之和的总费用。为了增加两座首都之间汽车旅行的受欢迎程度，运营公司 Radishchev Inc 推出了一项特别优惠：从圣彼得堡到莫斯科的旅程只需支付路径上 $k$ 条最贵道路的费用。\n\n正式地，假设某条路径由 $l$ 条道路组成。记 $c_{1}$ 为该路径上最贵的道路的费用，$c_{2}$ 为第二贵的，以此类推。因此，我们有一个序列 $c_{1} \\ge c_{2} \\ge c_{3} \\ge \\ldots \\ge c_{l}$，表示所选路径上所有道路的单个费用。如果 $l \\le k$，则路径太短，司机按通常方式支付所有单个费用之和，即 $\\Sigma^{l}_{i=1}c_{i}$。如果 $l > k$，则司机只需支付 $k$ 条最贵道路的费用，即 $\\Sigma^{k}_{i=1}c_{i}$。\n\n作为 Radishchev Inc 的首席分析师，你的任务是计算从圣彼得堡到莫斯科的最低可能旅程费用。", "inputFormat": "输入的第一行包含三个整数 $n, m$ 和 $k$ $(2 \\le n \\le 3000, 1 \\le m \\le 3000, 1 \\le k < n)$——城市的数量、道路网络中的道路数量，以及单次旅程中需要支付的最多道路数量。\n\n接下来的 $m$ 行包含道路的描述。每条道路的描述包含三个整数 $u_{i}, v_{i},$ 和 $w_{i}$ $(1 \\le u_{i}, v_{i} \\le n, u_{i} \\neq v_{i}, 1 \\le w_{i} \\le 10^{9})$——第 $i$ 条双向道路连接城市 $u_{i}$ 和 $v_{i}$，费用为 $w_{i}$，无论方向如何。保证每对城市之间最多只有一条道路，并且仅使用这些道路可以从任何城市到达其他城市。", "outputFormat": "输出一个整数，表示从城市编号 $1$（圣彼得堡）到城市编号 $n$（莫斯科）的最低可能旅行费用。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6962", "type": "P", "difficulty": 7, "samples": [["5\n10\n20\n50\n140\n420\n440\n", "01001\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2017", "数论", "枚举", "分治", "逆元", "位运算", "构造", "ICPC", "折半搜索 meet in the middle", "NERC/NEERC"], "title": "[NEERC 2017] Knapsack Cryptosystem", "background": "", "description": "\n\nThe Merkle-Hellman Knapsack Cryptosystem was one of the earliest public key cryptosystems invented by Ralph Merkle and Martin Hellman in $1978$ . Here is its description\n\nAlice chooses $n$ positive integers ${a_{1}, . . . , a_{n}}$ such that each $a_{i} > \\sum^{i−1}_{j=1}a_{j},$ a positive integer $q$ which is greater than the sum of all $a_{i},$ and a positive integer $r$ which is coprime with $q$ . These $n + 2$ integers are Alice's private key.\n\nThen Alice calculates $b_i = (a_{i} · r)$ mod $q$ . These $n$ integers are Alice's public key.\n\nKnowing her public key, Bob can transmit a message of $n$ bits to Alice. To do that he calculates $s$ , the sum of $b_{i}$ with indices $i$ such that his message has bit $1$ in i-th position. This value $s$ is the encrypted message.\n\nNote that an eavesdropper Eve, who knows the encrypted message and the public key, has to solve a (presumably hard) instance of the knapsack problem to find the original message. Meanwhile, after receiving $s$ , Alice can calculate the original message in linear time; we leave it to you as an exercise.\n\nIn this problem you deal with the implementation of the Merkle-Hellman Knapsack Cryptosystem in which Alice chose $q = 2^{64},$ for obvious performance reasons, and published this information. Since everyone knows her $q$ , she asks Bob to send her the calculated value $s$ taken modulo $2^{64}$ for simplicity of communication.\n\nYou are to break this implementation. Given the public key and an encrypted message, restore the original message.\n\n", "inputFormat": "\n\nThe first line contains one integer $n (1 \\le n \\le 64)$ .\n\nEach of the next $n$ lines contains one integer $b_{i} (1 \\le b_{i} < 2^{64}).$\n\nThe last line contains one integer $s$ mod $q$ -- the encrypted message $s$ taken modulo $q (0 \\le s$ mod $q < 2^{64}).$\n\nThe given sequence $b_{i}$ is a valid public key in the described implementation, and the given value $s$ mod $q$ is a valid encrypted message.\n\n", "outputFormat": "\n\nOutput exactly $n$ bits ($0$ or $1$ digits) -- the original message.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Knapsack Cryptosystem", "background": "", "description": "\n\nThe Merkle-Hellman Knapsack Cryptosystem was one of the earliest public key cryptosystems invented by Ralph Merkle and Martin Hellman in $1978$ . Here is its description\n\nAlice chooses $n$ positive integers ${a_{1}, . . . , a_{n}}$ such that each $a_{i} > \\sum^{i−1}_{j=1}a_{j},$ a positive integer $q$ which is greater than the sum of all $a_{i},$ and a positive integer $r$ which is coprime with $q$ . These $n + 2$ integers are Alice's private key.\n\nThen Alice calculates $b_i = (a_{i} · r)$ mod $q$ . These $n$ integers are Alice's public key.\n\nKnowing her public key, Bob can transmit a message of $n$ bits to Alice. To do that he calculates $s$ , the sum of $b_{i}$ with indices $i$ such that his message has bit $1$ in i-th position. This value $s$ is the encrypted message.\n\nNote that an eavesdropper Eve, who knows the encrypted message and the public key, has to solve a (presumably hard) instance of the knapsack problem to find the original message. Meanwhile, after receiving $s$ , Alice can calculate the original message in linear time; we leave it to you as an exercise.\n\nIn this problem you deal with the implementation of the Merkle-Hellman Knapsack Cryptosystem in which Alice chose $q = 2^{64},$ for obvious performance reasons, and published this information. Since everyone knows her $q$ , she asks Bob to send her the calculated value $s$ taken modulo $2^{64}$ for simplicity of communication.\n\nYou are to break this implementation. Given the public key and an encrypted message, restore the original message.\n\n", "inputFormat": "\n\nThe first line contains one integer $n (1 \\le n \\le 64)$ .\n\nEach of the next $n$ lines contains one integer $b_{i} (1 \\le b_{i} < 2^{64}).$\n\nThe last line contains one integer $s$ mod $q$ -- the encrypted message $s$ taken modulo $q (0 \\le s$ mod $q < 2^{64}).$\n\nThe given sequence $b_{i}$ is a valid public key in the described implementation, and the given value $s$ mod $q$ is a valid encrypted message.\n\n", "outputFormat": "\n\nOutput exactly $n$ bits ($0$ or $1$ digits) -- the original message.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Knapsack Cryptosystem", "background": "", "description": "Merkle-Hellman 背包密码系统是由 Ralph Merkle 和 Martin Hellman 于 1978 年发明的最早的公钥密码系统之一。以下是其描述：\n\nAlice 选择 $n$ 个正整数 ${a_{1}, . . . , a_{n}}$，使得每个 $a_{i} > \\sum^{i-1}_{j=1}a_{j}$，一个大于所有 $a_{i}$ 之和的正整数 $q$，以及一个与 $q$ 互质的正整数 $r$。这 $n + 2$ 个整数是 Alice 的私钥。\n\n然后 Alice 计算 $b_i = (a_{i} \\cdot r)$ mod $q$。这 $n$ 个整数是 Alice 的公钥。\n\n知道她的公钥后，Bob 可以向 Alice 传输一个 $n$ 位的消息。为此，他计算 $s$，即在消息中第 $i$ 位为 1 的位置上对应的 $b_{i}$ 的和。这个值 $s$ 是加密后的消息。\n\n注意，窃听者 Eve 知道加密消息和公钥，必须解决一个（可能很难的）背包问题实例才能找到原始消息。同时，在收到 $s$ 后，Alice 可以在线性时间内计算出原始消息；我们将其留给你作为练习。\n\n在这个问题中，你需要处理 Merkle-Hellman 背包密码系统的实现，其中 Alice 选择了 $q = 2^{64}$，出于显而易见的性能原因，并公布了此信息。由于每个人都知道她的 $q$，她要求 Bob 发送给她取模 $2^{64}$ 的计算值 $s$ 以简化通信。\n\n你需要破解这个实现。给定公钥和一个加密消息，恢复原始消息。", "inputFormat": "第一行包含一个整数 $n (1 \\le n \\le 64)$。\n\n接下来的 $n$ 行中，每行包含一个整数 $b_{i} (1 \\le b_{i} < 2^{64})$。\n\n最后一行包含一个整数 $s$ mod $q$ —— 取模 $q$ 的加密消息 $s$，其中 $0 \\le s$ mod $q < 2^{64}$。\n\n给定的序列 $b_{i}$ 是描述的实现中的有效公钥，给定的值 $s$ mod $q$ 是有效的加密消息。", "outputFormat": "输出恰好 $n$ 位（$0$ 或 $1$ 数字）——原始消息。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6963", "type": "P", "difficulty": 6, "samples": [["4 2\n1 2\n2 3\n2 4\n1 2\n4 2\n", "No\n"], ["6 5\n1 2\n2 3\n3 4\n5 6\n5 2\n2 1\n6 6\n1 4\n3 4\n4 1\n", "Yes\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Laminar Family", "background": "", "description": "\n\nWhile studying combinatorial optimization, Lucas came across the notion of `laminar set family`. A subset family $F$ of some set $Ω$ is called laminar if and only if it does not contain an empty set and for any two distinct sets A , $B ∈ F$ it is correct that either $A ⊂ B$ or $B ⊂ A$ or $A ∩ B = ∅$.\n\nAs an experienced problem setter Lucas always tries to apply each new piece of knowledge he gets as an idea for a programming competition problem. An area of his scientific interests covers recognition problems that usually sound like `Given some weird combinatorial property, check if the given structure satisfies it`.\n\nLucas believes that the perfect programming competition problem should contain a cactus a tree in it. Trying to put together laminar sets and trees into a recognition problem, he finally came up with the following problem: given an undirected tree on $n$ vertices and a family $F = {F_{1}, . . . , F_{k}}$ of sets, where $F_{i}$ consists of all vertices belonging to the simple path between some two vertices $a_{i}$ and $b_{i}$ of the tree, check if the family $F$ is a laminar family. Note that in this case $Ω = V$ , and each $F_{i} ⊆ V$ .\n\nAs you can see, Lucas had succeeded in suggesting this problem to the programming contest. Now it is up to you to solve it.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $n$ and $f (1 \\le n , f \\le 100 000)$ -- the number of vertices in the tree and the number of elements in a family $F$ .\n\nNext $n−1$ lines describe the tree structure. In the i-th line there are two integers $u_{i}$ and $v_{i} (1 \\le u_{i}, v_{i} \\le n , u_{i} ≠ v_{i})$ -- the indices of the vertices that are connected by the i-th edge of the tree.\n\nNext $f$ lines describe the sets forming the family $F$ . In the i-th line there are two integers $a_{i}$ and $b_{i} (1 \\le a_{i}, b_{i} \\le n)$ , such that $F_{i}$ consists of all vertices belonging to the simple path between vertices $a_{i}$ and $b_{i}$ in the tree (including $a_{i}$ and $b_{i}).$\n\n", "outputFormat": "\n\nOutput the only word `Yes` or `No` depending on whether or not the given set family is laminar.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Laminar Family", "background": "", "description": "\n\nWhile studying combinatorial optimization, Lucas came across the notion of `laminar set family`. A subset family $F$ of some set $Ω$ is called laminar if and only if it does not contain an empty set and for any two distinct sets A , $B ∈ F$ it is correct that either $A ⊂ B$ or $B ⊂ A$ or $A ∩ B = ∅$.\n\nAs an experienced problem setter Lucas always tries to apply each new piece of knowledge he gets as an idea for a programming competition problem. An area of his scientific interests covers recognition problems that usually sound like `Given some weird combinatorial property, check if the given structure satisfies it`.\n\nLucas believes that the perfect programming competition problem should contain a cactus a tree in it. Trying to put together laminar sets and trees into a recognition problem, he finally came up with the following problem: given an undirected tree on $n$ vertices and a family $F = {F_{1}, . . . , F_{k}}$ of sets, where $F_{i}$ consists of all vertices belonging to the simple path between some two vertices $a_{i}$ and $b_{i}$ of the tree, check if the family $F$ is a laminar family. Note that in this case $Ω = V$ , and each $F_{i} ⊆ V$ .\n\nAs you can see, Lucas had succeeded in suggesting this problem to the programming contest. Now it is up to you to solve it.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $n$ and $f (1 \\le n , f \\le 100 000)$ -- the number of vertices in the tree and the number of elements in a family $F$ .\n\nNext $n−1$ lines describe the tree structure. In the i-th line there are two integers $u_{i}$ and $v_{i} (1 \\le u_{i}, v_{i} \\le n , u_{i} ≠ v_{i})$ -- the indices of the vertices that are connected by the i-th edge of the tree.\n\nNext $f$ lines describe the sets forming the family $F$ . In the i-th line there are two integers $a_{i}$ and $b_{i} (1 \\le a_{i}, b_{i} \\le n)$ , such that $F_{i}$ consists of all vertices belonging to the simple path between vertices $a_{i}$ and $b_{i}$ in the tree (including $a_{i}$ and $b_{i}).$\n\n", "outputFormat": "\n\nOutput the only word `Yes` or `No` depending on whether or not the given set family is laminar.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Laminar Family", "background": "", "description": "在研究组合优化时，Lucas 遇到了“层状集合族”的概念。对于某个集合 $\\Omega$ 的子集族 $F$，如果它不包含空集，并且对于任何两个不同的集合 $A, B \\in F$，要么 $A \\subset B$，要么 $B \\subset A$，要么 $A \\cap B = \\emptyset$，则称其为层状集合族。\n\n作为一名经验丰富的题目设计者，Lucas 总是尝试将他获得的每一项新知识应用于编程竞赛题目。他的科学兴趣领域包括识别问题，这些问题通常听起来像是“给定某种奇怪的组合性质，检查给定结构是否满足它”。\n\nLucas 认为完美的编程竞赛题目应该包含一个仙人掌树。在尝试将层状集合和树结合成一个识别问题时，他最终提出了以下问题：给定一个有 $n$ 个顶点的无向树和一个集合族 $F = \\{F_{1}, \\ldots, F_{k}\\}$，其中 $F_{i}$ 包含树中某两个顶点 $a_{i}$ 和 $b_{i}$ 之间简单路径上的所有顶点，检查集合族 $F$ 是否为层状集合族。注意，在这种情况下 $\\Omega = V$，并且每个 $F_{i} \\subseteq V$。\n\n如你所见，Lucas 成功地将这个问题建议给了编程竞赛。现在轮到你来解决它了。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $f (1 \\le n, f \\le 100000)$ —— 树中的顶点数和集合族 $F$ 中的元素数。\n\n接下来的 $n-1$ 行描述了树的结构。在第 $i$ 行有两个整数 $u_{i}$ 和 $v_{i} (1 \\le u_{i}, v_{i} \\le n, u_{i} \neq v_{i})$ —— 由树的第 $i$ 条边连接的顶点的索引。\n\n接下来的 $f$ 行描述了构成集合族 $F$ 的集合。在第 $i$ 行有两个整数 $a_{i}$ 和 $b_{i} (1 \\le a_{i}, b_{i} \\le n)$，使得 $F_{i}$ 包含树中顶点 $a_{i}$ 和 $b_{i}$ 之间简单路径上的所有顶点（包括 $a_{i}$ 和 $b_{i}$）。", "outputFormat": "输出一个单词 `Yes` 或 `No`，取决于给定的集合族是否为层状集合族。", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6964", "type": "P", "difficulty": 4, "samples": [["This is ACM North Eastern European Regional Contest,\nsponsored by International Business Machines.\nThe. Best. Contest. Ever.\nA Great Opportunity for all contestants.\n", "This is ACM NEERC (North Eastern European Regional Contest),\nsponsored by IBM (International Business Machines).\nThe. Best. Contest. Ever.\nA GO (Great Opportunity) for all contestants.\n"], ["ab Ab A Abc AB Abcd ABc Abcde AbC\n", "ab Ab A Abc AB Abcd ABc Abcde AbC\n"], ["Oh  No  Extra Spaces.And,Punctuation Ruin Everything\n", "Oh  No  ES (Extra Spaces).And,PRE (Punctuation Ruin Everything)\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Abbreviation", "background": "", "description": "\n\nAn abbreviation (from Latin brevis, meaning short) is a shortened form of a word or phrase. In this problem you must write an automated tool that replaces a sequence of capitalized words with the corresponding abbreviation that consists of the first upper case letters only, followed by a full definition in parenthesis. See sample input and output.\n\nLet us make some formal definitions. A word in a text is a maximally long sequence of lower and upper case English letters. A capitalized word is a word that consists of an upper case letter followed by one or more lower case letters. For example, `Ab`, `Abc`, `Abcd`, and `Abcde` are all capitalized words, while `ab`, `A`, `AB`, `ABc` and `AbC` are not.\n\nAn abbreviatable sequence of words is a sequence of two or more capitalized words that are separated by exactly one space, no line breaks or punctuation are allowed inside it.\n\nAn abbreviation of an abbreviatable sequence of words is a sequence of the first (upper case) letters of each word, followed by a single space, an opening parenthesis, the original abbreviatable sequence, and a closing parenthesis.\n\n", "inputFormat": "\n\nThe input file consists of up to $1 000$ lines of text with up to $120$ characters on each line. Each line consists of spaces, upper and lower case letters, commas or dots. There are no leading or trailing spaces on lines and there are no empty lines. There is at least one line in the input file.\n\n", "outputFormat": "\n\nWrite to the output file the original text with every abbreviatable sequence of words replaced with the corresponding abbreviation.\n\n", "hint": "Time limit: 1 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Abbreviation", "background": "", "description": "\n\nAn abbreviation (from Latin brevis, meaning short) is a shortened form of a word or phrase. In this problem you must write an automated tool that replaces a sequence of capitalized words with the corresponding abbreviation that consists of the first upper case letters only, followed by a full definition in parenthesis. See sample input and output.\n\nLet us make some formal definitions. A word in a text is a maximally long sequence of lower and upper case English letters. A capitalized word is a word that consists of an upper case letter followed by one or more lower case letters. For example, `Ab`, `Abc`, `Abcd`, and `Abcde` are all capitalized words, while `ab`, `A`, `AB`, `ABc` and `AbC` are not.\n\nAn abbreviatable sequence of words is a sequence of two or more capitalized words that are separated by exactly one space, no line breaks or punctuation are allowed inside it.\n\nAn abbreviation of an abbreviatable sequence of words is a sequence of the first (upper case) letters of each word, followed by a single space, an opening parenthesis, the original abbreviatable sequence, and a closing parenthesis.\n\n", "inputFormat": "\n\nThe input file consists of up to $1 000$ lines of text with up to $120$ characters on each line. Each line consists of spaces, upper and lower case letters, commas or dots. There are no leading or trailing spaces on lines and there are no empty lines. There is at least one line in the input file.\n\n", "outputFormat": "\n\nWrite to the output file the original text with every abbreviatable sequence of words replaced with the corresponding abbreviation.\n\n", "hint": "Time limit: 1 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Abbreviation", "background": null, "description": "定义 word 为一个首字母大写、长度大于 $1$、 其他位为小写字母的单词，如 `Ab`、 `Abc`、 `Abcd` 和 `Abcde`，但 `ab`、`A`、 `AB`、 `ABc` 和 `AbC` 不是。\n\n定义一个 word 串为一个有大于 $1$ 个 word 、每两个 word 中有且只有一个空格的串，如 `International Business Machines`。\n\n现给你若干行，如遇到 word 串则让他变为缩写，缩写方式为：先提取首字母（大写），再加空格和 `(` ，再把全称写出来，最后加上 `)` ，如: `International Business Machines` 可缩写为 `IBM (International Business Machines)` 。", "inputFormat": "若干行（不超过 $1000$ 行）由大小写字母、标点和空格组成的的字符串（每行不超过 $120$ 个字符）。", "outputFormat": "缩写后的若干行字符串（无法缩写的不用缩写）。\n\n#### translate by:`ddgtang`", "hint": null, "locale": "zh-CN"}}}
{"pid": "P6965", "type": "P", "difficulty": 6, "samples": [["4\n00?\n0?00\n?1\n1?0\n", "YES\n000\n0100\n11\n100\n"], ["3\n0100\n01?0\n01?0\n", "NO\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2016", "Special Judge", "图论建模", "2-SAT", "字典树 Trie", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Binary Code", "background": "", "description": "\n\nBen has recently learned about binary prefix codes. A binary code is a set of $n$ distinct nonempty code words $s_{i}$ , each consisting of 0s and $1s.$ A code is called a prefix code if for every $i ≠ j$ neither $s_{i}$ is a prefix of $s_{j}$ nor $s_{j}$ is a prefix of $s_{i}$ . A word $x$ is called a prefix of a word $w$ if there exists a possibly empty word $y$ , such that xy $= w$ . For example, $x = 11$ is a prefix of $w = 110$ and $x = 0100$ is a prefix of $w = 0100$ .\n\nBen found a paper with $n$ lines of binary code in it. However, this paper is pretty old and there are some unreadable characters. Fortunately, each word contains at most one unreadable character.\n\nBen wants to know whether these $n$ lines could represent a binary prefix code. In other words, can he replace every unreadable character with $0$ or $1$ , so that the code becomes a prefix code?\n\n", "inputFormat": "\n\nThe first line contains integer $n$ -- the number of code words $(1 \\le n \\le 5 · 10^{5}).$\n\nNext $n$ lines contain nonempty code word records, one per line. Each code word record consists of `0`, `1` and `?` characters. Every code word record contains at most one `?` character that represents unreadable character.\n\nThe total length of words does not exceed $5 · 10^{5}$ .\n\n", "outputFormat": "\n\nOutput `NO` in the first line if the code cannot be a prefix code.\n\nOtherwise, output `YES` in the first line. Next $n$ lines shall contain code words in the same order as the corresponding code word records in the input.\n\nIf there are several prefix codes, that could have been written on the paper, output any one.\n\n", "hint": "Time limit: 2 s, Memory limit: 2048 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Binary Code", "background": "", "description": "\n\nBen has recently learned about binary prefix codes. A binary code is a set of $n$ distinct nonempty code words $s_{i}$ , each consisting of 0s and $1s.$ A code is called a prefix code if for every $i ≠ j$ neither $s_{i}$ is a prefix of $s_{j}$ nor $s_{j}$ is a prefix of $s_{i}$ . A word $x$ is called a prefix of a word $w$ if there exists a possibly empty word $y$ , such that xy $= w$ . For example, $x = 11$ is a prefix of $w = 110$ and $x = 0100$ is a prefix of $w = 0100$ .\n\nBen found a paper with $n$ lines of binary code in it. However, this paper is pretty old and there are some unreadable characters. Fortunately, each word contains at most one unreadable character.\n\nBen wants to know whether these $n$ lines could represent a binary prefix code. In other words, can he replace every unreadable character with $0$ or $1$ , so that the code becomes a prefix code?\n\n", "inputFormat": "\n\nThe first line contains integer $n$ -- the number of code words $(1 \\le n \\le 5 · 10^{5}).$\n\nNext $n$ lines contain nonempty code word records, one per line. Each code word record consists of `0`, `1` and `?` characters. Every code word record contains at most one `?` character that represents unreadable character.\n\nThe total length of words does not exceed $5 · 10^{5}$ .\n\n", "outputFormat": "\n\nOutput `NO` in the first line if the code cannot be a prefix code.\n\nOtherwise, output `YES` in the first line. Next $n$ lines shall contain code words in the same order as the corresponding code word records in the input.\n\nIf there are several prefix codes, that could have been written on the paper, output any one.\n\n", "hint": "Time limit: 2 s, Memory limit: 2048 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Binary Code", "background": "", "description": "给定 `n` 个01串，每个字符串至多有一位是未知的，可以填 `0` 或 `1` ，求是否存在一种方案，使得任意一个字符串不是其它任意一个字符串的前缀", "inputFormat": "第一行是一个正整数 `n` ，代表字符串的数量。 $(1 \\leq n \\leq 5 \\cdot 10^5)$\n\n接下来 `n` 行每行一个字符串，只可能由 `0` 、 `1` 或 `?` 组成。 `?` 代表未知的位置，每个字符串最多一个。\n\n保证字符串总长度不超过 $5 \\cdot 10^5$ 。", "outputFormat": "如果无解，只需要输出 `NO` 。\n\n如果有解，在第一行输出 `YES` ，接下来 `n` 行输出方案。\n\n如果有多组解，只需要输出任意一组。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6966", "type": "P", "difficulty": 6, "samples": [["8 2\n5 1 2 3 4 7\n5 4 5 6 1 8\n", "17\nr 2 1 2\nj 2 3\nc 2 1 2\nr 6 1 2\nj 5 6\nc 6 1 2\nr 4 1 3\nj 4 3\nj 4 6\nj 4 7\nc 4 3 1\nr 4 3 1\nr 8 1 2\nr 1 1 3\nj 1 8\nj 1 4\nc 1 3 2\n"], ["15 3\n9 1 2 3 4 5 6 7 8 3\n7 2 9 10 11 12 13 10\n5 2 14 9 15 10\n", "39\nr 7 1 2\nr 5 1 2\nj 7 8\nc 7 1 2\nj 5 4\nc 5 1 2\nr 6 1 3\nj 6 7\nj 6 5\nc 6 3 2\nr 3 1 4\nj 6 3\nc 6 4 1\nr 11 1 2\nr 13 1 2\nj 12 11\nj 12 13\nc 11 1 2\nr 10 1 3\nj 12 10\nc 10 2 3\nr 10 1 2\nr 10 4 2\nr 15 1 3\nj 15 10\nc 15 3 3\nj 9 10\nc 9 1 3\nr 9 3 2\nr 9 1 4\nr 14 1 4\nj 9 14\nc 9 4 4\nr 1 1 4\nr 3 1 2\nj 2 1\nj 2 14\nj 2 3\nc 2 1 4\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Cactus Construction", "background": "", "description": "\n\nLet us consider the following way of constructing graphs. Pick the number of colors $ˆc$ . Let $n$ be the number of vertices in a graph. To build a graph, we use a workspace with several graphs in it. Each vertex of each graph has a color. Colors are denoted by integers from $1$ to $ˆc$ . Initially, we have $n$ graphs in a workspace with one vertex in each graph, all colored with color $1$ , and no edges. The only vertex of i-th graph has number $i$ .\n\nThe following operations are permitted:\n\njoin a $b$ : join graphs containing vertices a and $b$ into one graph. No edges are added. Vertices a and $b$ must be in different graphs.\n\nrecolor a $c_{1 }c_{2}:$ in graph containing vertex a recolor all vertices of color $c_{1}$ with color $c_{2}.$\n\nconnect a $c_{1 }c_{2}:$ in graph containing vertex a create edges between all pairs of vertices where one vertex has color $c_{1}$ and the other has color $c_{2}.$ If $c_{1} = c_{2}$ loops are not created. If such an edge already exists, then the second parallel edge is created. Multi-edges are not allowed in this problem, so this case must not occur.\n\nAt the end we should have a single graph and colors of its vertices do not matter.\n\nThe minimal number of colors $ˆc$ , that can be used to construct a graph, is called a clique width of a graph. Clique width is one of the characteristics of graph complexity. Many NP-hard problems can be solved in polynomial time on graphs with bounded clique width, using dynamic programming on this process of building a graph. For a general graph, calculating the exact value of a clique width is known to be NP-hard. However, for some graph classes bounds on a clique width are known.\n\nCactus is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively cactus is a generalization of a tree where some cycles are allowed. Multi-edges (multiple edges between a pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus. It is known that a clique width of a cactus does not exceed $4$ .\n\nYou are given a cactus. Find out how to build it in the described way using at most $ˆc = 4$ colors.\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13991/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%207.31.10.png)\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13991/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%207.31.21.png)\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $m (1 \\le n \\le 50 000$ ; $0 \\le m \\le 50 000)$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ . Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths.\n\nEach of the following $m$ lines contains a path in the graph. A path starts with an integer $k_{i} (2 \\le k_{i } \\le 1000)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. Adjacent vertices in the path are distinct. The path can go to the same vertex multiple times, but every edge is traversed exactly once in the whole input file.\n\nThe graph in the input file is a cactus.\n\n", "outputFormat": "\n\nIn the first line print one integer $q$ -- the number of operations you need. This number should not be greater than $10^{6}$ . In the next $q$ lines print operations. Each operation is denoted by its first letter (`j` for join, `r` for recolor and `c` for connect) and its arguments in the order they are described in the problem statement.\n\nAt the end, after applying all these operations, one should have one graph, which is equal to the cactus in the input. This means that there should be exactly one edge between each pair of vertices connected in the input graph, and no edges between vertices not connected in the input graph.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Cactus Construction", "background": "", "description": "\n\nLet us consider the following way of constructing graphs. Pick the number of colors $ˆc$ . Let $n$ be the number of vertices in a graph. To build a graph, we use a workspace with several graphs in it. Each vertex of each graph has a color. Colors are denoted by integers from $1$ to $ˆc$ . Initially, we have $n$ graphs in a workspace with one vertex in each graph, all colored with color $1$ , and no edges. The only vertex of i-th graph has number $i$ .\n\nThe following operations are permitted:\n\njoin a $b$ : join graphs containing vertices a and $b$ into one graph. No edges are added. Vertices a and $b$ must be in different graphs.\n\nrecolor a $c_{1 }c_{2}:$ in graph containing vertex a recolor all vertices of color $c_{1}$ with color $c_{2}.$\n\nconnect a $c_{1 }c_{2}:$ in graph containing vertex a create edges between all pairs of vertices where one vertex has color $c_{1}$ and the other has color $c_{2}.$ If $c_{1} = c_{2}$ loops are not created. If such an edge already exists, then the second parallel edge is created. Multi-edges are not allowed in this problem, so this case must not occur.\n\nAt the end we should have a single graph and colors of its vertices do not matter.\n\nThe minimal number of colors $ˆc$ , that can be used to construct a graph, is called a clique width of a graph. Clique width is one of the characteristics of graph complexity. Many NP-hard problems can be solved in polynomial time on graphs with bounded clique width, using dynamic programming on this process of building a graph. For a general graph, calculating the exact value of a clique width is known to be NP-hard. However, for some graph classes bounds on a clique width are known.\n\nCactus is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively cactus is a generalization of a tree where some cycles are allowed. Multi-edges (multiple edges between a pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus. It is known that a clique width of a cactus does not exceed $4$ .\n\nYou are given a cactus. Find out how to build it in the described way using at most $ˆc = 4$ colors.\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13991/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%207.31.10.png)\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13991/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%207.31.21.png)\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $m (1 \\le n \\le 50 000$ ; $0 \\le m \\le 50 000)$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ . Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths.\n\nEach of the following $m$ lines contains a path in the graph. A path starts with an integer $k_{i} (2 \\le k_{i } \\le 1000)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. Adjacent vertices in the path are distinct. The path can go to the same vertex multiple times, but every edge is traversed exactly once in the whole input file.\n\nThe graph in the input file is a cactus.\n\n", "outputFormat": "\n\nIn the first line print one integer $q$ -- the number of operations you need. This number should not be greater than $10^{6}$ . In the next $q$ lines print operations. Each operation is denoted by its first letter (`j` for join, `r` for recolor and `c` for connect) and its arguments in the order they are described in the problem statement.\n\nAt the end, after applying all these operations, one should have one graph, which is equal to the cactus in the input. This means that there should be exactly one edge between each pair of vertices connected in the input graph, and no edges between vertices not connected in the input graph.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Cactus Construction", "background": "", "description": "让我们考虑以下构建图的方法。选择颜色数 $\\hat{c}$。设 $n$ 为图中的顶点数。为了构建一个图，我们使用一个包含多个图的工作空间。每个图的每个顶点都有一个颜色。颜色由从 $1$ 到 $\\hat{c}$ 的整数表示。最初，我们在工作空间中有 $n$ 个图，每个图中有一个顶点，所有顶点都被涂成颜色 $1$，且没有边。第 $i$ 个图的唯一顶点编号为 $i$。\n\n允许以下操作：\n\njoin a $b$：将包含顶点 $a$ 和 $b$ 的图合并为一个图。不添加边。顶点 $a$ 和 $b$ 必须在不同的图中。\n\nrecolor a $c_{1}c_{2}$：在包含顶点 $a$ 的图中，将所有颜色为 $c_{1}$ 的顶点重新着色为颜色 $c_{2}$。\n\nconnect a $c_{1}c_{2}$：在包含顶点 $a$ 的图中，创建所有颜色为 $c_{1}$ 的顶点与颜色为 $c_{2}$ 的顶点之间的边。如果 $c_{1} = c_{2}$，则不创建自环。如果这样的边已经存在，则创建第二条平行边。在这个问题中不允许多重边，所以这种情况不应发生。\n\n最后，我们应该有一个单一的图，并且其顶点的颜色无关紧要。\n\n可以用来构建图的最小颜色数 $\\hat{c}$ 称为图的团宽。团宽是图复杂度的特征之一。许多 NP 难问题可以在团宽有界的图上通过动态规划在这个构建图的过程中以多项式时间解决。对于一般图，计算团宽的确切值已知是 NP 难的。然而，对于某些图类，已知团宽的界限。\n\n仙人掌图是一个连通的无向图，其中每条边最多位于一个简单环上。直观上，仙人掌图是树的推广，其中允许一些环。仙人掌图中不允许多重边（在一对顶点之间的多条边）和自环（连接顶点自身的边）。已知仙人掌图的团宽不超过 $4$。\n\n给定一个仙人掌图。找出如何用最多 $\\hat{c} = 4$ 种颜色以描述的方式构建它。\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13991/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%207.31.10.png)\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13991/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%207.31.21.png)", "inputFormat": "输入文件的第一行包含两个整数 $n$ 和 $m (1 \\le n \\le 50 000$；$0 \\le m \\le 50 000)$。这里 $n$ 是图中的顶点数。顶点从 $1$ 到 $n$ 编号。图的边由一组边不同的路径表示，其中 $m$ 是这样的路径数。\n\n接下来的 $m$ 行中的每一行包含图中的一条路径。路径以一个整数 $k_{i} (2 \\le k_{i} \\le 1000)$ 开头，后跟 $k_{i}$ 个从 $1$ 到 $n$ 的整数。这些 $k_{i}$ 个整数表示路径的顶点。路径中的相邻顶点是不同的。路径可以多次经过同一个顶点，但整个输入文件中每条边仅被遍历一次。\n\n输入文件中的图是一个仙人掌图。", "outputFormat": "在第一行打印一个整数 $q$——你需要的操作数。这个数字不应大于 $10^{6}$。在接下来的 $q$ 行中打印操作。每个操作由其首字母（`j` 表示 join，`r` 表示 recolor 和 `c` 表示 connect）及其参数按问题描述的顺序表示。\n\n最后，在应用所有这些操作后，应该得到一个图，它等于输入中的仙人掌图。这意味着在输入图中连接的每对顶点之间应该正好有一条边，而在输入图中未连接的顶点之间不应有边。", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6967", "type": "P", "difficulty": 6, "samples": [["10 4 1 2\n1 2 3 4 5 6 7 8 9 10\n10 9 8 7 6 5 4 3 2 1\n", "69\nEEESESEESS\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "网络流", "Special Judge", "图论建模", "线性规划", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Delight for a Cat", "background": "", "description": "\n\nA cat is going on an adventure.\n\nEach hour, the cat can be either sleeping or eating. The cat cannot be doing both actions at the same hour, and the cat is doing exactly one of these actions for the whole hour.\n\nFor each of the next $n$ hours, the amount of delight the cat is getting if it is sleeping or eating during that hour is known. These amounts can be different for each hour.\n\nAn integer time period $k$ is also known. Among every $k$ consecutive hours, there should be at least $m_{s}$ hours when the cat is sleeping, and at least $m_{e}$ hours when the cat is eating. So, there are exactly $n − k + 1$ segments of $k$ hours for which this condition must be satisfied.\n\nFind the maximum total amount of delight the cat can get during the next $n$ hours.\n\n", "inputFormat": "\n\nThe first line of the input contains four integers $n , k , m_{s},$ and $m_{e} (1 \\le k \\le n \\le 1000$ ; $0 \\le m_{s}, m_{e} \\le k$ ; $m_{s} + m_{e} \\le k)$ -- the number of upcoming hours, the length of the period (in hours), and the minimum number of hours the cat should be sleeping and eating out of every $k$ consecutive hours, respectively.\n\nThe second line contains $n$ integers $s_{1}, s_{2},$ . . . , $s_{n} (0 \\le s_{i } \\le 10^{9}$ ) -- the amount of delight the cat gets when it is sleeping during the first, the second, $ \\cdots ,$ the n-th hour.\n\nThe third line contains $n$ integers $e_{1}, e_{2},$ . . . , $e_{n} (0 \\le e_{i} \\le 10^{9}$ ) -- the amount of delight the cat gets when it is eating during the first, the second, $ \\cdots ,$ the n-th hour.\n\n", "outputFormat": "\n\nIn the first line, output a single integer -- the maximum total amount of delight the cat can get during the next $n$ hours.\n\nIn the second line, output a string of length $n$ consisting of characters `S` and `E`. The i-th character of this string should correspond to whether the cat should sleep $(`S`)$ or eat $(`E`)$ in the i-th hour to get the maximum total amount of delight out of these $n$ hours.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Delight for a Cat", "background": "", "description": "\n\nA cat is going on an adventure.\n\nEach hour, the cat can be either sleeping or eating. The cat cannot be doing both actions at the same hour, and the cat is doing exactly one of these actions for the whole hour.\n\nFor each of the next $n$ hours, the amount of delight the cat is getting if it is sleeping or eating during that hour is known. These amounts can be different for each hour.\n\nAn integer time period $k$ is also known. Among every $k$ consecutive hours, there should be at least $m_{s}$ hours when the cat is sleeping, and at least $m_{e}$ hours when the cat is eating. So, there are exactly $n − k + 1$ segments of $k$ hours for which this condition must be satisfied.\n\nFind the maximum total amount of delight the cat can get during the next $n$ hours.\n\n", "inputFormat": "\n\nThe first line of the input contains four integers $n , k , m_{s},$ and $m_{e} (1 \\le k \\le n \\le 1000$ ; $0 \\le m_{s}, m_{e} \\le k$ ; $m_{s} + m_{e} \\le k)$ -- the number of upcoming hours, the length of the period (in hours), and the minimum number of hours the cat should be sleeping and eating out of every $k$ consecutive hours, respectively.\n\nThe second line contains $n$ integers $s_{1}, s_{2},$ . . . , $s_{n} (0 \\le s_{i } \\le 10^{9}$ ) -- the amount of delight the cat gets when it is sleeping during the first, the second, $ \\cdots ,$ the n-th hour.\n\nThe third line contains $n$ integers $e_{1}, e_{2},$ . . . , $e_{n} (0 \\le e_{i} \\le 10^{9}$ ) -- the amount of delight the cat gets when it is eating during the first, the second, $ \\cdots ,$ the n-th hour.\n\n", "outputFormat": "\n\nIn the first line, output a single integer -- the maximum total amount of delight the cat can get during the next $n$ hours.\n\nIn the second line, output a string of length $n$ consisting of characters `S` and `E`. The i-th character of this string should correspond to whether the cat should sleep $(`S`)$ or eat $(`E`)$ in the i-th hour to get the maximum total amount of delight out of these $n$ hours.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Delight for a Cat", "background": "", "description": "一只猫正在进行一次冒险。\n\n每小时，猫可以选择睡觉或吃东西。猫不能在同一小时内同时进行这两种活动，并且猫在整小时内只能进行其中一种活动。\n\n对于接下来的 $n$ 小时，已知猫在每小时内睡觉或吃东西所获得的快乐值。这些值在每小时内可能不同。\n\n还知道一个整数时间段 $k$。在每 $k$ 个连续的小时中，至少有 $m_{s}$ 小时猫在睡觉，至少有 $m_{e}$ 小时猫在吃东西。因此，有正好 $n - k + 1$ 个 $k$ 小时的时间段需要满足这个条件。\n\n求猫在接下来的 $n$ 小时内所能获得的最大总快乐值。", "inputFormat": "输入的第一行包含四个整数 $n, k, m_{s},$ 和 $m_{e}$ $(1 \\le k \\le n \\le 1000$；$0 \\le m_{s}, m_{e} \\le k$；$m_{s} + m_{e} \\le k)$ ——即将到来的小时数、时间段的长度（以小时为单位），以及在每 $k$ 个连续小时中猫至少应该睡觉和吃东西的小时数。\n\n第二行包含 $n$ 个整数 $s_{1}, s_{2}, \\ldots, s_{n}$ $(0 \\le s_{i} \\le 10^{9})$ ——猫在第 1 小时、第 2 小时、$\\cdots$、第 $n$ 小时睡觉时获得的快乐值。\n\n第三行包含 $n$ 个整数 $e_{1}, e_{2}, \\ldots, e_{n}$ $(0 \\le e_{i} \\le 10^{9})$ ——猫在第 1 小时、第 2 小时、$\\cdots$、第 $n$ 小时吃东西时获得的快乐值。", "outputFormat": "在第一行输出一个整数——猫在接下来的 $n$ 小时内所能获得的最大总快乐值。\n\n在第二行输出一个长度为 $n$ 的字符串，由字符 `S` 和 `E` 组成。这个字符串的第 $i$ 个字符应对应于猫在第 $i$ 小时应该睡觉 $(`S`)$ 还是吃东西 $(`E`)$，以便在这 $n$ 小时内获得最大的总快乐值。", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6968", "type": "P", "difficulty": 0, "samples": [["5 4\n- 1 1\n- 2 2\n+ 4 1\n- 6 1\n+ 7 2\n0 3 1 2\n", "INFINITY\n0\n8\n3\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Expect to Wait", "background": "", "description": "\n\nMayor Adam East wants to improve the public transport network of Harshel city by introducing the network of stations with unicycles. Any person who owns a special card can come to a station and request a unicycle to ride or drop one.\n\nThe procedure of requesting a unicycle is simple. The person enters a queue. If there is a unicycle available, then the first person from the queue takes it immediately. Otherwise, people in the queue wait until someone drops a unicycle at the station.\n\nLet the wait time be the time that person spends between the request (entrance to the queue) and obtaining a unicycle. If the person does not receive a unicycle at all, then the wait time is infinity. The total wait time is the sum of wait times for each person.\n\nAdam already knows the schedule of all the people for every day. He knows at what times people request and drop unicycles at the Central Station that can hold any number of unicycles at the same time. The only thing he does not know is how many unicycles should be placed there at the start of each day. He asks you several questions to calculate the total wait time given the starting number of unicycles.\n\n", "inputFormat": "\n\nThe first line contains $n$ and $q (1 \\le n , q \\le 10^{5} ),$ where $n$ is the total number of unicycle requests and unicycle drops at the Central Station, and $q$ is the number of questions Adam asks you. The next $n$ lines describe operations at the Central Station. Each line contains one description of operation:\n\n$`+ t$ k` when $k$ unicycles are dropped at time $t$ ;\n\n$`- t$ k` when $k$ people request unicycles at time $t$ .\n\nFor each of the described operations $1 \\le t \\le 10^{9}$ and $1 \\le k \\le 10^{4}$ . The last line of the input contains $q$ different integers $b_{i} (0 \\le b_{i} \\le 10^{9}$ ) -- the number of unicycles at the start of the day.\n\nThe operations are given in the strongly increasing order of time.\n\n", "outputFormat": "\n\nThe output shall consist of $q$ lines. The i-th line shall display the total wait time for the case of $b_{i}$ unicycles at the start of the day. If the total wait time is infinite, then the corresponding line shall display the word `INFINITY`.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Expect to Wait", "background": "", "description": "\n\nMayor Adam East wants to improve the public transport network of Harshel city by introducing the network of stations with unicycles. Any person who owns a special card can come to a station and request a unicycle to ride or drop one.\n\nThe procedure of requesting a unicycle is simple. The person enters a queue. If there is a unicycle available, then the first person from the queue takes it immediately. Otherwise, people in the queue wait until someone drops a unicycle at the station.\n\nLet the wait time be the time that person spends between the request (entrance to the queue) and obtaining a unicycle. If the person does not receive a unicycle at all, then the wait time is infinity. The total wait time is the sum of wait times for each person.\n\nAdam already knows the schedule of all the people for every day. He knows at what times people request and drop unicycles at the Central Station that can hold any number of unicycles at the same time. The only thing he does not know is how many unicycles should be placed there at the start of each day. He asks you several questions to calculate the total wait time given the starting number of unicycles.\n\n", "inputFormat": "\n\nThe first line contains $n$ and $q (1 \\le n , q \\le 10^{5} ),$ where $n$ is the total number of unicycle requests and unicycle drops at the Central Station, and $q$ is the number of questions Adam asks you. The next $n$ lines describe operations at the Central Station. Each line contains one description of operation:\n\n$`+ t$ k` when $k$ unicycles are dropped at time $t$ ;\n\n$`- t$ k` when $k$ people request unicycles at time $t$ .\n\nFor each of the described operations $1 \\le t \\le 10^{9}$ and $1 \\le k \\le 10^{4}$ . The last line of the input contains $q$ different integers $b_{i} (0 \\le b_{i} \\le 10^{9}$ ) -- the number of unicycles at the start of the day.\n\nThe operations are given in the strongly increasing order of time.\n\n", "outputFormat": "\n\nThe output shall consist of $q$ lines. The i-th line shall display the total wait time for the case of $b_{i}$ unicycles at the start of the day. If the total wait time is infinite, then the corresponding line shall display the word `INFINITY`.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Expect to Wait", "background": "", "description": "# [NEERC2016] Expect to Wait\n\n\n市长小A想要给H市添加独轮车车站，任何有“特殊的卡片”的人，都可以到车站请求骑车或停放。\n\n申请独轮车很简单，申请骑车的人到车站排队，如果那个站有独轮车停放，那么就让处于队头位置的人先骑，否则，排队的人会等到有人把独轮车送到车站。\n\n定义等待时间为从请求人开始排队到取到车所花的时间，如果一个人取不到独轮车，那么等待的时间是无限（infinity）的。总等待时间是每个人等待时间的总和。\n\n小A已经知道人们每天在什么时候向车站请求和放下独轮车，车站可以同时容纳无限独轮车。他会告诉你每天车站里人们的用车计划，然后对你进行n次询问，每次提问会告诉你一天开始时车站里有的独轮车数，请你来计算每个问题所对应的总等待时间。", "inputFormat": "第一行包含两个正整数 $n$ 和 $q (1 \\le n , q \\le 10^{5} ),$ $n$代表有n个用车计划, $q$代表小A会问你n个问题 接下来$n$行代表每个用车计划，每个计划包含一个操作说明：\n\n$+tk$ 代表人们在$t$时间要求停放$k$辆车;\n\n$- t k$ 代表人们在$t$时间要求取$k$辆车.\n\n对于每个用车计划： $1 \\le t \\le 10^{9}$ and $1 \\le k \\le 10^{4}$ . 输入的最后一行包含 $q$ 个不同的整数 $b_{i} (0 \\le b_{i} \\le 10^{9}$ ) -- 一天开始时独轮车的数量。\n\n操作的顺序是按时间复杂度从小到大的", "outputFormat": "输出应包括$q$行。第i行应显示当天开始时$b_{i}$独轮车的总等待时间。如果总等待时间是无限的，则相应的行应显示单词`INFINITY`。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5 4\n- 1 1\n- 2 2\n+ 4 1\n- 6 1\n+ 7 2\n0 3 1 2\n```\n\n### 样例输出 #1\n\n```\nINFINITY\n0\n8\n3\n```", "hint": "时间限制: 2 s,空间限制: 512 MB.", "locale": "zh-CN"}}}
{"pid": "P6969", "type": "P", "difficulty": 0, "samples": [["CWCC\n", "1.0\n"], ["WWCWCCW\n", "2.333333333333\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Foreign Postcards", "background": "", "description": "\n\nFedor is an avid traveler. As a result of his hobby, he has gathered a big collection of postcards from all over the world. Each postcard has a unique picture on the front side and some fields for address information and text on the back side.\n\nDuring one of the parties at Fedor's house, he decided to show all his of postcards to the guests. To achieve that, he wants to lay them all out on the table. Initially, all of his postcards are arranged in a single stack that Fedor is holding in his hands. Unfortunately, some of the postcards in that stack can be turned incorrectly -- upside down. Ideally, Fedor would like all postcards on the table to lie with the picture on top, but looking at every postcard and turning it over individually can be very time-consuming. Instead, he came up with the following process:\n\nLet $n$ be the number of postcards remaining in the stack in his hands. Fedor chooses a random number $k$ uniformly between $1$ and $n$ and takes top $k$ postcards from the stack.\n\nHe looks at the topmost postcard among these $k$ postcards. If it is oriented in the wrong way, he turns the whole stack of $k$ postcards upside down together.\n\nHe then puts these $k$ postcards on the table without any further rotations.\n\nIf there are still some postcards remaining in the stack in his hands, Fedor goes back to step $1$ .\n\nOf course, after all the postcards are on the table, there might still be some that lie back side up. What is the expected number of such postcards?\n\n", "inputFormat": "\n\nThe input consists of a single line of `C` and `W` characters -- i-th character corresponds to i-th postcard in the stack, counting from the top of the stack. `C` means that i-th postcard is oriented correctly in the initial stack, and `W` means that i-th postcard is oriented in the wrong way. The number of characters is between $1$ and $10^{6}$ inclusive.\n\n", "outputFormat": "\n\nOutput one real number -- the expected number of incorrectly placed postcards on the table. The absolute or relative error should not exceed $10^{−9}$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\nspj 由 [tiger2005](https://www.luogu.com.cn/user/60864) 提供。", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Foreign Postcards", "background": "", "description": "\n\nFedor is an avid traveler. As a result of his hobby, he has gathered a big collection of postcards from all over the world. Each postcard has a unique picture on the front side and some fields for address information and text on the back side.\n\nDuring one of the parties at Fedor's house, he decided to show all his of postcards to the guests. To achieve that, he wants to lay them all out on the table. Initially, all of his postcards are arranged in a single stack that Fedor is holding in his hands. Unfortunately, some of the postcards in that stack can be turned incorrectly -- upside down. Ideally, Fedor would like all postcards on the table to lie with the picture on top, but looking at every postcard and turning it over individually can be very time-consuming. Instead, he came up with the following process:\n\nLet $n$ be the number of postcards remaining in the stack in his hands. Fedor chooses a random number $k$ uniformly between $1$ and $n$ and takes top $k$ postcards from the stack.\n\nHe looks at the topmost postcard among these $k$ postcards. If it is oriented in the wrong way, he turns the whole stack of $k$ postcards upside down together.\n\nHe then puts these $k$ postcards on the table without any further rotations.\n\nIf there are still some postcards remaining in the stack in his hands, Fedor goes back to step $1$ .\n\nOf course, after all the postcards are on the table, there might still be some that lie back side up. What is the expected number of such postcards?\n\n", "inputFormat": "\n\nThe input consists of a single line of `C` and `W` characters -- i-th character corresponds to i-th postcard in the stack, counting from the top of the stack. `C` means that i-th postcard is oriented correctly in the initial stack, and `W` means that i-th postcard is oriented in the wrong way. The number of characters is between $1$ and $10^{6}$ inclusive.\n\n", "outputFormat": "\n\nOutput one real number -- the expected number of incorrectly placed postcards on the table. The absolute or relative error should not exceed $10^{−9}$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\nspj 由 [tiger2005](https://www.luogu.com.cn/user/60864) 提供。", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Foreign Postcards", "background": "", "description": "费多是个热心的旅行者。由于他的爱好，他收集了来自世界各地的大量明信片。每张明信片正面都有一张独特的图片，背面有一些地址信息和文本字段。\n\n在费多家的一次聚会上，他决定向客人展示他所有的明信片。为了实现这一目标，他想把它们全部摆在桌面上。起初，他所有的明信片都被安排在一个单叠里，费多拿在手里。不幸的是，这堆明信片中的一些可能会被错误地翻过来——颠倒过来。理想情况下，费多希望桌上的所有明信片都放在图片的上方，但查看每张明信片并逐个翻转可能非常耗时。相反，他提出了以下过程：\n\n让 $n$ 是他手中的那堆明信片的剩余数量。费多均匀地选择一个介于1和 $n$ 之间的随机数 $k$ ，并从堆栈中取出前 $k$ 张明信片。\n\n他看了看这 $k$ 张明信片中最上面的一张明信片。如果方向错误，他会将整叠明信片倒置在一起。\n\n然后，他把这 $k$ 张明信片放在桌子上，不再旋转。\n\n如果他手里还有一些明信片，费多会返回到步骤 $1$ 。\n\n当然，在所有的明信片都放在桌子上之后，可能仍然有一些明信片是倒着放的。这类明信片的预期数量是多少？", "inputFormat": "输入由一行 $C$ 和 $W$ 字符组成——第 $i$ 个字符对应于栈中的第 $i$ 个明信片，从栈顶部开始计数。$C$ 表示第 $i$ 张明信片在初始栈中的方向正确， $W$ 表示第 $i$ 张明信片的方向错误。字符数在 $1$ 到 $10^{6}$ 之间, $6$ 包括在内。", "outputFormat": "输出一个实数——表上错误放置的明信片的预期数量。绝对或相对误差不应超过 $10^{−9}$", "hint": "时间限制：2s，内存限制：512 MB。", "locale": "zh-CN"}}}
{"pid": "P6970", "type": "P", "difficulty": 6, "samples": [["6 7\n1 2\n2 1\n2 3\n1 4\n4 1\n4 5\n5 6\n", "WDLDWL\nDWLLWL \n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Game on Graph", "background": "", "description": "\n\nGennady and Georgiy are playing interesting game on a directed graph. The graph has $n$ vertices and $m$ arcs, loops are allowed. Gennady and Georgiy have a token placed in one of the graph vertices. Players take turns moving the token along one of the arcs that starts in the vertex the token is currently in. When there is no such arc, then this player loses the game.\n\nFor each initial position of the token and the player who is moving first, your task is to determine what kind of result the game is going to have. Does it seem to be easy? Not so much.\n\nOn one side, Gennady is having a lot of fun playing this game, so he wants to play as long as possible. He even prefers a strategy that leads to infinite game to a strategy that makes him a winner. But if he cannot make the game infinite, then he obviously prefers winning to losing.\n\nOn the other side, Georgiy has a lot of other work, so he does not want to play the game infinitely. Georgiy wants to win the game, but if he cannot win, then he prefers losing game to making it infinite.\n\nBoth players are playing optimally. Both players know preferences of the other player.\n\n", "inputFormat": "\n\nIn the first line there are two integers -- the number of vertices $n (1 \\le n \\le 100 000)$ and the number of arcs $m (1 \\le m \\le 200 000)$ . In the next $m$ lines there are two integers a and $b$ on each line, denoting an arc from vertex a to vertex $b$ . Vertices are numbered from $1$ to $n$ . Each $(a , b)$ tuple appears at most once.\n\n", "outputFormat": "\n\nIn the first line print $n$ characters -- i-th character should denote the result of the game if Gennady starts in vertex $i$ . In the second line print $n$ characters -- i-th character should denote the result of the game if Georgiy starts in vertex $i$ . The result of the game is denoted by `W` if the starting player wins the game, `L` if the starting player loses the game, and `D` (draw) if the game runs infinitely.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Game on Graph", "background": "", "description": "\n\nGennady and Georgiy are playing interesting game on a directed graph. The graph has $n$ vertices and $m$ arcs, loops are allowed. Gennady and Georgiy have a token placed in one of the graph vertices. Players take turns moving the token along one of the arcs that starts in the vertex the token is currently in. When there is no such arc, then this player loses the game.\n\nFor each initial position of the token and the player who is moving first, your task is to determine what kind of result the game is going to have. Does it seem to be easy? Not so much.\n\nOn one side, Gennady is having a lot of fun playing this game, so he wants to play as long as possible. He even prefers a strategy that leads to infinite game to a strategy that makes him a winner. But if he cannot make the game infinite, then he obviously prefers winning to losing.\n\nOn the other side, Georgiy has a lot of other work, so he does not want to play the game infinitely. Georgiy wants to win the game, but if he cannot win, then he prefers losing game to making it infinite.\n\nBoth players are playing optimally. Both players know preferences of the other player.\n\n", "inputFormat": "\n\nIn the first line there are two integers -- the number of vertices $n (1 \\le n \\le 100 000)$ and the number of arcs $m (1 \\le m \\le 200 000)$ . In the next $m$ lines there are two integers a and $b$ on each line, denoting an arc from vertex a to vertex $b$ . Vertices are numbered from $1$ to $n$ . Each $(a , b)$ tuple appears at most once.\n\n", "outputFormat": "\n\nIn the first line print $n$ characters -- i-th character should denote the result of the game if Gennady starts in vertex $i$ . In the second line print $n$ characters -- i-th character should denote the result of the game if Georgiy starts in vertex $i$ . The result of the game is denoted by `W` if the starting player wins the game, `L` if the starting player loses the game, and `D` (draw) if the game runs infinitely.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Game on Graph", "background": null, "description": "Gennady 和 Georgiy 在玩一个有向图上的游戏。这个图有 $n$ 个点 $m$ 条边，两人轮流操作，每次可以将棋子沿着其中一条边移动，不能移动者输。\n\n你要对于每个点，分别求出以这个点为起点开始游戏，两人分别作为先手，最终会输，赢，还是平局（游戏无限循环）。\n\n其中，Gennady 因为玩得很开心，所以他更期望将游戏变为平局；Georgiy 还有很多其他事，所以他更期望游戏不要平局。当然，在不平局的基础上，两人都更希望赢。", "inputFormat": "第一行两个数 $n$，$m$ 表示有 $n$ 个点 $m$ 条边。  \n接下来 $m$ 行每行两个数 $a,b$ 表示一条由 $a$ 至 $b$ 的边。", "outputFormat": "两行，第一行表示分别以每一个点为起点 Gennady 先手的胜负情况；第二行表示分别以每一个点为起点 Georgiy 先手的胜负情况。`W` 表示赢，`L` 表示输，`D` 表示平局。\n\nby a___", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^5$，$1\\le m\\le 2\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P6971", "type": "P", "difficulty": 0, "samples": [["5 2\n6 6\n4 1\n4 2\n4 5\n5 3\n4 3\n1 1\n", "yes\n5\n"], ["3 3\n10 1\n10 3\n", "no\n"], ["2 2\n2 1\n1 1\n", "yes\n1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Jenga Boom", "background": "", "description": "\n\nJane is a game designer and she designs the next version of Jenga Boom, where the blocks have dimensions of $1 \\times w \\times w_n$ instead of the ordinary $1 \\times 2 \\times 6$ . As usual, the initial tower is created at the game start. It consists of the blocks in levels of $n$ blocks placed next to each other along their long sides and at a right angle to the previous level. Players remove blocks from the tower in turns, until the tower collapses.\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13998/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%208.10.49.png)\n\nInitial tower\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13998/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%208.11.00.png)\n\nThe tower before collapse\n\nJane wants to build a game simulator that helps her to decide the best $n$ and $w$ . The simulator shall compute the moment when the tower collapses if blocks are removed in the specified order. Tower collapses if there is a cross-section between levels such that the center of the mass of the levels above it does not belong to or is at the edge of the convex hull of the previous level projection.\n\n", "inputFormat": "\n\nThe first line contains two integers $n$ and $w$ that define the dimensions of the block as described in the problem statement $(1 \\le n , w \\le 10 000)$ . The second line also contains two integers: $h$ -- the number of levels in the tower and $m$ -- the number of removed blocks $(1 \\le h , m \\le 5 000)$ .\n\nThe next $m$ lines contain coordinates of the removed blocks with two integers each: $l_{i}$ -- the level of the block, counting from the bottom and $k_{i}$ -- the position of the block, counting from the edge nearest to the players $(1 \\le l_{i} \\le h$ ; $1 \\le k_{i} \\le n)$ . Blocks are removed one by one and no block is removed twice.\n\n", "outputFormat": "\n\nIn the first line output `yes` if the tower collapses, and `no` otherwise. In the former case, output the number of the block (starting from $1$) , that was removed just before the collapse, in the next line.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Jenga Boom", "background": "", "description": "\n\nJane is a game designer and she designs the next version of Jenga Boom, where the blocks have dimensions of $1 \\times w \\times w_n$ instead of the ordinary $1 \\times 2 \\times 6$ . As usual, the initial tower is created at the game start. It consists of the blocks in levels of $n$ blocks placed next to each other along their long sides and at a right angle to the previous level. Players remove blocks from the tower in turns, until the tower collapses.\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13998/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%208.10.49.png)\n\nInitial tower\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13998/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%208.11.00.png)\n\nThe tower before collapse\n\nJane wants to build a game simulator that helps her to decide the best $n$ and $w$ . The simulator shall compute the moment when the tower collapses if blocks are removed in the specified order. Tower collapses if there is a cross-section between levels such that the center of the mass of the levels above it does not belong to or is at the edge of the convex hull of the previous level projection.\n\n", "inputFormat": "\n\nThe first line contains two integers $n$ and $w$ that define the dimensions of the block as described in the problem statement $(1 \\le n , w \\le 10 000)$ . The second line also contains two integers: $h$ -- the number of levels in the tower and $m$ -- the number of removed blocks $(1 \\le h , m \\le 5 000)$ .\n\nThe next $m$ lines contain coordinates of the removed blocks with two integers each: $l_{i}$ -- the level of the block, counting from the bottom and $k_{i}$ -- the position of the block, counting from the edge nearest to the players $(1 \\le l_{i} \\le h$ ; $1 \\le k_{i} \\le n)$ . Blocks are removed one by one and no block is removed twice.\n\n", "outputFormat": "\n\nIn the first line output `yes` if the tower collapses, and `no` otherwise. In the former case, output the number of the block (starting from $1$) , that was removed just before the collapse, in the next line.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Jenga Boom", "background": "", "description": "设有一个塔，它的积木块是 $1\\times w\\times (w\\times n)$ 的长方体，每层由 $n$ 个积木块，每两层交错摆放，共有 $h$ 层。有 $m$ 个抽积木的操作，对于第 $i$ 个操作给出从底往上数的第 $l_i$ 层和从左后方往右前方数的第 $k_i$ 块。某一层的左边或右边加上中间 (如果 $n$ 为偶数，那么忽略中间) 的积木块全被抽完，则塔倒塌。", "inputFormat": "第一行为 $n$ 和 $w$ ，($1\\le n,w\\le10000$) 。第二行为 $h$ 和 $m$  ,($1\\le h,m\\le5000$)。接下来的 $m$ 行为 $l_i$ 和 $k_i$ ($1\\le l_i\\le h;1\\le k_i\\le n$) 。一块积木只能移动一次。", "outputFormat": "如果塔能倒塌，则输出 \"yes\" 。否则输出 \"no\" 。对于第一种情况，在下一行输出倒塌前一步的编号 $i$ 。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6972", "type": "P", "difficulty": 5, "samples": [["3 3\n..*\n.*.\n*.*\n3 3\n**.\n..*\n.*.\n5 2\n.*\n*.\n**\n.*\n*.\n", "YES\n0 2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Kids Designing Kids", "background": "", "description": "\n\nKevin and Kimberly have freckles on their foreheads.\n\nThey both drew their freckle pictures on sheets of paper. Each picture is a rectangle of `pixels`: every cell either has a freckle or it has no freckle.\n\nThey are jokingly proposing that when they grow up, marry, and have a child, her freckle picture is produced as a result of the following procedure:\n\nKevin's and Kimberly's pictures are moved by a parallel translation, and then in each cell a child has a freckle if and only if exactly one of the parents has a freckle in this position.\n\nNow they wonder, whether there is a parallel translation that gives their child a specific freckle picture (for example, a lightning), and what is this parallel translation.\n\n", "inputFormat": "\n\nThe first line contains two integers, $h_{1 }and w_{1} (1 \\le h_{1}, w_{1} \\le 1000)$ -- the height and the width of Kevin's freckle picture. Each of the next $h_{1}$ lines consists of $w_{1}$ characters $‘ \\times '$ and $‘. '.$ Character $‘ \\times '$ means that there is a freckle, and $‘. '$ that there is not.\n\nThe next lines contain Kimberly's picture in the same format. Its height and width $h_2$ and $w_2$ follow the same constraints.\n\nIt is guaranteed that Kevin and Kimberly have at least one freckle each.\n\nThe next lines contain the picture they want for their child in the same format. Its dimensions $h_{3}$ and $w_{3}$ also have the same constraints.\n\n", "outputFormat": "\n\nIn the first line output `YES` if the desired picture can be produced, and `NO` otherwise.\n\nIf the answer is positive, then in the second line output two integers, $x$ and $y$ , with the following meaning: if you overlay the pictures so that their upper left corners coincide, then move Kimberly's picture $x$ cells right (negative number means moving picture left) and $y$ cells down (negative number means moving picture up), and then apply the procedure described above, the resulting picture can be moved by a parallel translation to coincide with the third picture from the input file.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Kids Designing Kids", "background": "", "description": "\n\nKevin and Kimberly have freckles on their foreheads.\n\nThey both drew their freckle pictures on sheets of paper. Each picture is a rectangle of `pixels`: every cell either has a freckle or it has no freckle.\n\nThey are jokingly proposing that when they grow up, marry, and have a child, her freckle picture is produced as a result of the following procedure:\n\nKevin's and Kimberly's pictures are moved by a parallel translation, and then in each cell a child has a freckle if and only if exactly one of the parents has a freckle in this position.\n\nNow they wonder, whether there is a parallel translation that gives their child a specific freckle picture (for example, a lightning), and what is this parallel translation.\n\n", "inputFormat": "\n\nThe first line contains two integers, $h_{1 }and w_{1} (1 \\le h_{1}, w_{1} \\le 1000)$ -- the height and the width of Kevin's freckle picture. Each of the next $h_{1}$ lines consists of $w_{1}$ characters $‘ \\times '$ and $‘. '.$ Character $‘ \\times '$ means that there is a freckle, and $‘. '$ that there is not.\n\nThe next lines contain Kimberly's picture in the same format. Its height and width $h_2$ and $w_2$ follow the same constraints.\n\nIt is guaranteed that Kevin and Kimberly have at least one freckle each.\n\nThe next lines contain the picture they want for their child in the same format. Its dimensions $h_{3}$ and $w_{3}$ also have the same constraints.\n\n", "outputFormat": "\n\nIn the first line output `YES` if the desired picture can be produced, and `NO` otherwise.\n\nIf the answer is positive, then in the second line output two integers, $x$ and $y$ , with the following meaning: if you overlay the pictures so that their upper left corners coincide, then move Kimberly's picture $x$ cells right (negative number means moving picture left) and $y$ cells down (negative number means moving picture up), and then apply the procedure described above, the resulting picture can be moved by a parallel translation to coincide with the third picture from the input file.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Kids Designing Kids", "background": null, "description": "凯文和金伯利的额头上都有雀斑。  \n\n他们都在纸上画了自己的雀斑图。每幅图都是一个由像素组成的矩形：每个单元格要么有雀斑，要么没有雀斑。  \n\n他们开玩笑地提议，当他们长大、结婚并有了孩子时，孩子的雀斑图是通过以下过程产生的：  \n\n凯文和金伯利的图通过平行平移移动，然后在每个单元格中，只有当且仅当父母中有一个人在这个位置有雀斑时，孩子才有雀斑。  \n\n现在他们想知道，是否存在一个平行平移可以使他们的孩子获得特定的雀斑图（例如，一个闪电），以及这个平行平移是什么。", "inputFormat": "第一行包含两个整数 $h_{1}$ 和 $w_{1}$ $(1 \\le h_{1}, w_{1} \\le 1000)$——凯文的雀斑图的高度和宽度。接下来的 $h_{1}$ 行中的每一行由 $w_{1}$ 个字符组成，字符为 `*` 和 `.`。字符 `*` 表示有雀斑，而 `.` 表示没有雀斑。  \n\n接下来的几行以相同的格式包含金伯利的图。其高度和宽度 $h_2$ 和 $w_2$ 遵循相同的约束条件。  \n\n保证凯文和金伯利各自至少有一个雀斑。  \n\n接下来的几行以相同的格式包含他们想要给孩子的图。其尺寸 $h_{3}$ 和 $w_{3}$ 也遵循相同的约束条件。", "outputFormat": "在第一行输出 `YES` 如果可以生成所需的图，否则输出 `NO`。  \n\n如果答案是肯定的，那么在第二行输出两个整数 $x$ 和 $y$，其含义如下：如果将图像叠加，使它们的左上角重合，然后将金伯利的图向右移动 $x$ 个单元格（负数表示向左移动图像）和向下移动 $y$ 个单元格（负数表示向上移动图像），然后应用上述过程，结果图可以通过平行平移移动以与输入文件中的第三幅图重合。", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6973", "type": "P", "difficulty": 6, "samples": [["1 35\n", "[2], [3], [2, 3], [5], [2, 5], [7],\n"], ["36 41\n", " [3, 5\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] List of Primes", "background": "", "description": "Lidia likes sets of prime numbers. When she is bored, she starts writing them down into the Extremely Long Notebook for Prime Sets.\n\nElements of each set are written down in ascending order. Each set of prime numbers appears in her notebook eventually. A set with a smaller sum always appears before a set with a larger sum. Sets with the same sum are sorted in ascending lexicographical order: they are compared by the first element, if the first elements are equal, then by second element, and so on.\n\nJust in case someone decides to parse her notebook, she writes down her sets in a machine-readable JSON format. Of course, she puts a space after each comma. Here's the beginning of her notebook:\n\n$[2], [3], [2 , 3], [5], [2 , 5], [7], [3 , 5], [2 , 7], [2 , 3 , 5], [3 , 7], [11], [2 , 3 , 7], [5 , 7], [2 , 11], [13], [2 , 5 , 7],$\n\nLidia wants to double-check her work, so here is her request for you: given two integers, $a$ and $b$ , output a substring of her notebook from the position $a$ to the position $b$ (inclusive, counting from $1$) .\n\n", "inputFormat": "\n\nThe first line contains two integers, $a$ and $b$ ($1 \\le a \\le b \\le 10^{18}; b - a \\le 10^{5}$).\n\n", "outputFormat": "\n\nOutput the substring of the notebook described in the problem statement from the position $a$ to the position $b$ . You must write a line with exactly $b - a + 1$ characters, including any leading or trailing spaces.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] List of Primes", "background": "", "description": "Lidia likes sets of prime numbers. When she is bored, she starts writing them down into the Extremely Long Notebook for Prime Sets.\n\nElements of each set are written down in ascending order. Each set of prime numbers appears in her notebook eventually. A set with a smaller sum always appears before a set with a larger sum. Sets with the same sum are sorted in ascending lexicographical order: they are compared by the first element, if the first elements are equal, then by second element, and so on.\n\nJust in case someone decides to parse her notebook, she writes down her sets in a machine-readable JSON format. Of course, she puts a space after each comma. Here's the beginning of her notebook:\n\n$[2], [3], [2 , 3], [5], [2 , 5], [7], [3 , 5], [2 , 7], [2 , 3 , 5], [3 , 7], [11], [2 , 3 , 7], [5 , 7], [2 , 11], [13], [2 , 5 , 7],$\n\nLidia wants to double-check her work, so here is her request for you: given two integers, $a$ and $b$ , output a substring of her notebook from the position $a$ to the position $b$ (inclusive, counting from $1$) .\n\n", "inputFormat": "\n\nThe first line contains two integers, $a$ and $b$ ($1 \\le a \\le b \\le 10^{18}; b - a \\le 10^{5}$).\n\n", "outputFormat": "\n\nOutput the substring of the notebook described in the problem statement from the position $a$ to the position $b$ . You must write a line with exactly $b - a + 1$ characters, including any leading or trailing spaces.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] List of Primes", "background": "", "description": "Lidia 喜欢质数集合。当她感到无聊时，她就开始把它们写在极长的质数集合笔记本上。\n\n每个集合的元素按升序排列。每个质数集合最终都会出现在她的笔记本上。和较小的集合总是出现在和较大的集合之前。和相同的集合按字典序升序排列：它们首先比较第一个元素，如果第一个元素相同，则比较第二个元素，依此类推。\n\n以防有人决定解析她的笔记本，她将她的集合写成机器可读的 JSON 格式。当然，她在每个逗号后面加了一个空格。以下是她笔记本的开头：\n\n$[2], [3], [2 , 3], [5], [2 , 5], [7], [3 , 5], [2 , 7], [2 , 3 , 5], [3 , 7], [11], [2 , 3 , 7], [5 , 7], [2 , 11], [13], [2 , 5 , 7],$\n\nLidia 想要仔细检查她的工作，所以她请求你：给定两个整数 $a$ 和 $b$，输出她的笔记本中从位置 $a$ 到位置 $b$（包括，位置从 $1$ 开始计数）的子字符串。", "inputFormat": "第一行包含两个整数，$a$ 和 $b$ ($1 \\le a \\le b \\le 10^{18}; b - a \\le 10^{5}$)。", "outputFormat": "输出题目描述中从位置 $a$ 到位置 $b$ 的笔记本子字符串。你必须输出一行，恰好包含 $b - a + 1$ 个字符，包括任何前导或尾随空格。", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6974", "type": "P", "difficulty": 2, "samples": [["3 7\nR 2\nC 3\nR 2\nR 1\nC 2\nC 1\nR 3\n", "12\n10\n0\n5\n5\n4\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Adjustment Office", "background": "", "description": "Garrison and Anderson are working in a company named “Adjustment Office”. In competing companies workers change the reality, in this company they try to predict the future.\n\nThey are given a big square board $n\\times n$. Initially in each cell $(x, y)$ of this board the value of $x + y$ is written $(1\\leq x, y\\leq n$). They know that in the future there will be two types of queries on the board:\n- “R $r$” — sum up all values in row $r$, print the result and set all values in row $r$ to zero;\n- “C $c$” — sum up all values in column $c$, print the result and set all values in column $c$ to zero.\n\nThey have predicted what queries and results there will be. They need to ensure that they have correctly predicted the results. Help them by computing the results of the queries.\n", "inputFormat": "The first line of the input contains two integers $n$ and $q$ $(1\\leq n\\leq10^6$, $1\\leq q\\leq10^5$) — the size of the square and the number of queries.\n\nEach of the next $q$ lines contains the description of the query. Each query is either “R $r$” $(1\\leq r\\leq n$) or “C $c$” $(1\\leq c\\leq n$).", "outputFormat": "The output file shall contain $q$ lines. The $i$ - th line shall contain one integer — the result of the $i$ - th query. ", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Adjustment Office", "background": "", "description": "Garrison and Anderson are working in a company named “Adjustment Office”. In competing companies workers change the reality, in this company they try to predict the future.\n\nThey are given a big square board $n\\times n$. Initially in each cell $(x, y)$ of this board the value of $x + y$ is written $(1\\leq x, y\\leq n$). They know that in the future there will be two types of queries on the board:\n- “R $r$” — sum up all values in row $r$, print the result and set all values in row $r$ to zero;\n- “C $c$” — sum up all values in column $c$, print the result and set all values in column $c$ to zero.\n\nThey have predicted what queries and results there will be. They need to ensure that they have correctly predicted the results. Help them by computing the results of the queries.\n", "inputFormat": "The first line of the input contains two integers $n$ and $q$ $(1\\leq n\\leq10^6$, $1\\leq q\\leq10^5$) — the size of the square and the number of queries.\n\nEach of the next $q$ lines contains the description of the query. Each query is either “R $r$” $(1\\leq r\\leq n$) or “C $c$” $(1\\leq c\\leq n$).", "outputFormat": "The output file shall contain $q$ lines. The $i$ - th line shall contain one integer — the result of the $i$ - th query. ", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Adjustment Office", "background": "", "description": "加里森和安德森在一家名为“Adjustment Office”的公司工作。在竞争公司中，员工改变现实，而在这家公司中，他们尝试预测未来。\n\n他们得到一个 $n \\times n$ 的大方板。最初在这个方板的每个单元格 $(x, y)$ 中写着 $x + y$ 的值（$1 \\leq x, y \\leq n$）。他们知道在未来将会有两种类型的查询：\n- “R $r$”——计算第 $r$ 行的所有值之和，打印结果并将第 $r$ 行的所有值设为零；\n- “C $c$”——计算第 $c$ 列的所有值之和，打印结果并将第 $c$ 列的所有值设为零。\n\n他们已经预测了将会有哪些查询和结果。他们需要确保他们正确预测了结果。请帮助他们计算查询的结果。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $q$（$1 \\leq n \\leq 10^6$，$1 \\leq q \\leq 10^5$）——方板的大小和查询的数量。\n\n接下来的 $q$ 行中的每一行包含一个查询的描述。每个查询要么是“R $r$”（$1 \\leq r \\leq n$），要么是“C $c$”（$1 \\leq c \\leq n$）。", "outputFormat": "输出文件应包含 $q$ 行。第 $i$ 行应包含一个整数——第 $i$ 个查询的结果。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6975", "type": "P", "difficulty": 6, "samples": [["6 1\n7 1 2 5 6 2 3 4\n", "42\n"], ["15 3\n9 1 2 3 4 5 6 7 8 3\n7 2 9 10 11 12 13 10\n5 2 14 9 15 10\n", "216\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Cactus Jubilee", "background": "", "description": "\n\nThis is the $20-th$ Northeastern European Regional Contest $(NEERC).$ Cactus problems had become a NEERC tradition. The first Cactus problem was given in $2005$ , so there is a jubilee -- $10$ years of Cactus.\n\nCactus is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively cactus is a generalization of a tree where some cycles are allowed. Multiedges (multiple edges between a pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus.\n\nYou are given a cactus. Let's move an edge -- remove one of graph's edges, but connect a different pair of vertices with an edge, so that a graph still remains a cactus. How many ways are there to perform such a move?\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11737/1.png)\n\nFor example, in the left cactus above (given in the first sample), there are $42$ ways to perform an edge move. In the right cactus (given in the second sample), which is the classical NEERC cactus since the original problem in $2005$ , there are $216$ ways to perform a move.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $m (1 \\le n \\le 50 000 , 0 \\le m \\le 50 000)$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ . Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths.\n\nEach of the following $m$ lines contains a path in the graph. A path starts with an integer $k_{i} (2 \\le k_{i} \\le 1000)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. Adjacent vertices in a path are distinct. Path can go to the same vertex multiple times, but every edge is traversed exactly once in the whole input file.\n\nThe graph in the input file is a cactus.\n\n", "outputFormat": "\n\nWrite to the output file a single integer -- the number of ways to move an edge in the cactus.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Cactus Jubilee", "background": "", "description": "\n\nThis is the $20-th$ Northeastern European Regional Contest $(NEERC).$ Cactus problems had become a NEERC tradition. The first Cactus problem was given in $2005$ , so there is a jubilee -- $10$ years of Cactus.\n\nCactus is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively cactus is a generalization of a tree where some cycles are allowed. Multiedges (multiple edges between a pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus.\n\nYou are given a cactus. Let's move an edge -- remove one of graph's edges, but connect a different pair of vertices with an edge, so that a graph still remains a cactus. How many ways are there to perform such a move?\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11737/1.png)\n\nFor example, in the left cactus above (given in the first sample), there are $42$ ways to perform an edge move. In the right cactus (given in the second sample), which is the classical NEERC cactus since the original problem in $2005$ , there are $216$ ways to perform a move.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $m (1 \\le n \\le 50 000 , 0 \\le m \\le 50 000)$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ . Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths.\n\nEach of the following $m$ lines contains a path in the graph. A path starts with an integer $k_{i} (2 \\le k_{i} \\le 1000)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. Adjacent vertices in a path are distinct. Path can go to the same vertex multiple times, but every edge is traversed exactly once in the whole input file.\n\nThe graph in the input file is a cactus.\n\n", "outputFormat": "\n\nWrite to the output file a single integer -- the number of ways to move an edge in the cactus.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Cactus Jubilee", "background": "", "description": "定义一种无向连通图叫`仙人掌图（Cactus图）`。仙人掌图中没有重边和自环，并且其中的每一条边至多位于一个简单环上。简单地说，`仙人掌图`是树的一种泛化形式，其中允许出现一些环。\n\n现在有一个`仙人掌图`，你每次可以移动一条边（移除图的一条边，并将另一对顶点用一条边连接起来）。问如果要让后来得到的新图仍然是`仙人掌图`，有多少种移动边的办法？", "inputFormat": "第一行包含两个整数n和m，分别表示图中的顶点数（顶点的编号分别为${1,2,3,...,n}$）和边的数目，且满足\n$$1≤n≤50000,0≤m≤50000$$\n\n第2~m+1行，每一行表示一条路径（从一个顶点出发一直往后走，直到当前所在的顶点没有任何未走过一条边）。\n\n（译者注：虽然应该都能看出来了，但是还是用一个递归函数更浅显易懂）\n\n设路径的开始点为$q_1$，$E_i$表示第$i$个点的边,$vis$数组中存储已经走过了的边，则整条路径可定义为：\n```\n1.x←q1\n2.f(x)\n\t1.add(vis[],x)\n\t2.for i∈Ex do\n\t1.if i not in vis[] then\n\t\t1.call f(i->to)\n3.print(vis[])\n```\n即：每一行的开始有一个整数$k_i$，满足\n$2≤k_i≤1000$，紧接着有$k_i$个整数，表示这条路径所经过的顶点$q_i$，满足$q_i∈[1,n]$。\n\n数据保证路径中的相邻顶点是不同的。\n\n在路径中可以多次到达同一个顶点，但在整个输入文件中，每条边只遍历一次。\n\n数据保证输入文件中的图形是仙人掌。", "outputFormat": "输出文件中只有一个整数，即移动`仙人掌图`中一条边的方法数。", "hint": "$$1≤n≤50000,0≤m≤50000,2≤k_i≤1000,q_i∈[1,n]$$", "locale": "zh-CN"}}}
{"pid": "P6976", "type": "P", "difficulty": 6, "samples": [["6\n1 5\n2 4\n5 2\n5\n1 3\n2 5\n3 4\n6 3\n6 6\n", "2\n1\n1\n3\n0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Distance on Triangulation", "background": "", "description": "\n\nYou have a convex polygon. The vertices of the polygon are successively numbered from $1$ to $n$ . You also have a triangulation of this polygon, given as a list of $n − 3$ diagonals.\n\nYou are also given $q$ queries. Each query consists of two vertex indices. For each query, find the shortest distance between these two vertices, provided that you can move by the sides and by the given diagonals of the polygon, and the distance is measured as the total number of sides and diagonals you have traversed.\n\n", "inputFormat": "\n\nThe first line of the input file contains an integer $n$ -- the number of vertices of the polygon $(4 \\le n \\le 50 000)$ .\n\nEach of the following $n−3$ lines contains two integers $a_{i}, b_{i}$ -- the ends of the i-th diagonal $(1 \\le a_{i}, b_{i} \\le n , a_{i} ≠ b_{i}).$\n\nThe next line contains an integer $q$ -- the number of queries $(1 \\le q \\le 100 000)$ .\n\nEach of the following $q$ lines contains two integers $x_{i}, y_{i}$ -- the vertices in the i-th query $(1 \\le x_{i}, y_{i} \\le n)$ .\n\nIt is guaranteed that no diagonal coincides with a side of the polygon, and that no two diagonals coincide or intersect.\n\n", "outputFormat": "\n\nFor each query output a line containing the shortest distance.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Distance on Triangulation", "background": "", "description": "\n\nYou have a convex polygon. The vertices of the polygon are successively numbered from $1$ to $n$ . You also have a triangulation of this polygon, given as a list of $n − 3$ diagonals.\n\nYou are also given $q$ queries. Each query consists of two vertex indices. For each query, find the shortest distance between these two vertices, provided that you can move by the sides and by the given diagonals of the polygon, and the distance is measured as the total number of sides and diagonals you have traversed.\n\n", "inputFormat": "\n\nThe first line of the input file contains an integer $n$ -- the number of vertices of the polygon $(4 \\le n \\le 50 000)$ .\n\nEach of the following $n−3$ lines contains two integers $a_{i}, b_{i}$ -- the ends of the i-th diagonal $(1 \\le a_{i}, b_{i} \\le n , a_{i} ≠ b_{i}).$\n\nThe next line contains an integer $q$ -- the number of queries $(1 \\le q \\le 100 000)$ .\n\nEach of the following $q$ lines contains two integers $x_{i}, y_{i}$ -- the vertices in the i-th query $(1 \\le x_{i}, y_{i} \\le n)$ .\n\nIt is guaranteed that no diagonal coincides with a side of the polygon, and that no two diagonals coincide or intersect.\n\n", "outputFormat": "\n\nFor each query output a line containing the shortest distance.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Distance on Triangulation", "background": null, "description": "你有一个凸多边形。多边形的顶点按顺序从 $1$ 到 $n$ 编号。你还有这个多边形的一个三角剖分，给出为 $n-3$ 条对角线的列表。\n\n你还会得到 $q$ 个查询。每个查询由两个顶点索引组成。对于每个查询，找到这两个顶点之间的最短距离，前提是你可以通过多边形的边和给定的对角线移动，距离以你经过的边和对角线的总数来衡量。", "inputFormat": "输入文件的第一行包含一个整数 $n$ —— 多边形的顶点数 $(4 \\le n \\le 50 000)$。\n\n接下来的 $n-3$ 行中的每一行包含两个整数 $a_{i}, b_{i}$ —— 第 $i$ 条对角线的两个端点 $(1 \\le a_{i}, b_{i} \\le n , a_{i} \n\\neq b_{i})$。\n\n下一行包含一个整数 $q$ —— 查询的数量 $(1 \\le q \\le 100 000)$。\n\n接下来的 $q$ 行中的每一行包含两个整数 $x_{i}, y_{i}$ —— 第 $i$ 个查询中的顶点 $(1 \\le x_{i}, y_{i} \\le n)$。\n\n保证没有对角线与多边形的边重合，并且没有两条对角线重合或相交。", "outputFormat": "对于每个查询，输出一行包含最短距离。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6977", "type": "P", "difficulty": 2, "samples": [["3 8\n5 0 3 12 1 10\n4 1 1 23 20\n4 1 5 17 49\n", "94\n"], ["3 10\n2 1 3\n1 1\n2 2 5\n", "354\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Easy Problemset", "background": "", "description": "\n\nPerhaps one of the hardest problems of any ACM ICPC contest is to create a problemset with a reasonable number of easy problems. On Not Easy European Regional Contest this problem is solved as follows.\n\nThere are $n$ jury members (judges). They are numbered from $1$ to $n$ . Judge number $i$ had prepared $p_{i}$ easy problems before the jury meeting. Each of these problems has a hardness between $0$ and $49$ (the higher the harder). Each judge also knows a very large (say infinite) number of hard problems (their hardness is $50$) . Judges need to select $k$ problems to be used on the contest during this meeting.\n\nThey start to propose problems in the ascending order of judges numbers. The first judge takes the first problem from his list of remaining easy problems (or a hard problem, if he has already proposed all his easy problems) and proposes it. The proposed problem is selected for the contest if its hardness is greater than or equal to the total hardness of the problems selected so far, otherwise it is considered too easy. Then the second judge does the same etc. ; after the n-th judge, the first one proposes his next problem, and so on. This procedure is stopped immediately when $k$ problems are selected.\n\nIf all judges have proposed all their easy problems, but they still have selected less than $k$ problems, then they take some hard problems to complete the problemset regardless of the total hardness.\n\nYour task is to calculate the total hardness of the problemset created by the judges.\n\n", "inputFormat": "\n\nThe first line of the input file contains the number of judges $n (2 \\le n \\le 10)$ and the number of problems $k (8 \\le k \\le 14)$ . The i-th of the following $n$ lines contains the description of the problems prepared by the i-th judge. It starts with $p_{i} (1 \\le p_{i} \\le 10)$ followed by $p_{i}$ non negative integers between $0$ and $49$ -- the hardnesses of the problems prepared by the i-th judge in the order they will be proposed.\n\n", "outputFormat": "\n\nOutput the only integer -- the total hardness of the selected problems.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Easy Problemset", "background": "", "description": "\n\nPerhaps one of the hardest problems of any ACM ICPC contest is to create a problemset with a reasonable number of easy problems. On Not Easy European Regional Contest this problem is solved as follows.\n\nThere are $n$ jury members (judges). They are numbered from $1$ to $n$ . Judge number $i$ had prepared $p_{i}$ easy problems before the jury meeting. Each of these problems has a hardness between $0$ and $49$ (the higher the harder). Each judge also knows a very large (say infinite) number of hard problems (their hardness is $50$) . Judges need to select $k$ problems to be used on the contest during this meeting.\n\nThey start to propose problems in the ascending order of judges numbers. The first judge takes the first problem from his list of remaining easy problems (or a hard problem, if he has already proposed all his easy problems) and proposes it. The proposed problem is selected for the contest if its hardness is greater than or equal to the total hardness of the problems selected so far, otherwise it is considered too easy. Then the second judge does the same etc. ; after the n-th judge, the first one proposes his next problem, and so on. This procedure is stopped immediately when $k$ problems are selected.\n\nIf all judges have proposed all their easy problems, but they still have selected less than $k$ problems, then they take some hard problems to complete the problemset regardless of the total hardness.\n\nYour task is to calculate the total hardness of the problemset created by the judges.\n\n", "inputFormat": "\n\nThe first line of the input file contains the number of judges $n (2 \\le n \\le 10)$ and the number of problems $k (8 \\le k \\le 14)$ . The i-th of the following $n$ lines contains the description of the problems prepared by the i-th judge. It starts with $p_{i} (1 \\le p_{i} \\le 10)$ followed by $p_{i}$ non negative integers between $0$ and $49$ -- the hardnesses of the problems prepared by the i-th judge in the order they will be proposed.\n\n", "outputFormat": "\n\nOutput the only integer -- the total hardness of the selected problems.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Easy Problemset", "background": "", "description": "或许在任何 ACM ICPC 比赛中最难的问题之一就是创建一个包含合理数量简单题目的题集。在 Not Easy 欧洲区域赛中，这个问题是这样解决的。\n\n有 $n$ 名评委（裁判）。他们从 $1$ 到 $n$ 编号。编号为 $i$ 的裁判在评委会议之前准备了 $p_{i}$ 道简单题目。这些题目的难度在 $0$ 到 $49$ 之间（数值越大越难）。每位裁判还知道大量（可以说是无限多）难题（它们的难度为 $50$）。裁判们需要在这次会议中选择 $k$ 道题目用于比赛。\n\n他们开始按裁判编号的升序提出题目。第一位裁判从他剩余的简单题目列表中取出第一道题（如果他已经提出了所有简单题目，则取一道难题）并提出。如果提出的题目难度大于或等于目前已选题目的总难度，则该题目被选中用于比赛，否则被认为太简单。然后第二位裁判也这样做，依此类推；在第 $n$ 位裁判之后，第一位裁判提出他的下一道题，如此循环。这个过程在选出 $k$ 道题目时立即停止。\n\n如果所有裁判都提出了他们的所有简单题目，但仍然选出的题目少于 $k$ 道，那么他们将不顾总难度，选择一些难题来完成题集。\n\n你的任务是计算由裁判们创建的题集的总难度。", "inputFormat": "输入文件的第一行包含裁判的数量 $n (2 \\le n \\le 10)$ 和题目的数量 $k (8 \\le k \\le 14)$。接下来的 $n$ 行中的第 $i$ 行包含第 $i$ 位裁判准备的题目的描述。它以 $p_{i} (1 \\le p_{i} \\le 10)$ 开始，后跟 $p_{i}$ 个介于 $0$ 和 $49$ 之间的非负整数——即第 $i$ 位裁判准备的题目的难度，按他们将提出的顺序排列。", "outputFormat": "输出一个整数——所选题目的总难度。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6978", "type": "P", "difficulty": 4, "samples": [["10 7\n2 2\n2 4\n5 1\n5 3\n8 2\n7 5\n9 4\n", "4.5 4.5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2015", "二分", "Special Judge", "最短路", "生成树", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Froggy Ford（征集SPJ）", "background": "", "description": "\n\nFiona designs a new computer game Froggy Ford. In this game, a player helps a frog to cross a river using stone fords. Frog leaps from the river's shore to the first stone ford, than to the second one and so on, until it reaches the other shore. Unfortunately, frog is pretty weak and its leap distance is quite limited. Thus, a player should choose the optimal route -- the route that minimizes the largest leap required to traverse the route.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11740/1.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11740/2.png)\n\nOptimal route\n\nOptimal route with added stone\n\nFiona thinks that this game is not challenging enough, so she plans to add a possibility to place a new stone in the river. She asks you to write a program that determines such a location of the new stone that minimizes the largest leap required to traverse the optimal route.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $w$ -- the width of the river and $n$ -- the number of stones in it $(1 \\le w \\le 10^{9}, 0 \\le n \\le 1000)$ .\n\nEach of the following $n$ lines contains two integers $x_{i}, y_{i}$ -- the coordinates of the stones $(0 < x_{i} < w , −10^{9} \\le y_i \\le 10^{9}).$ Coordinates of all stones are distinct. River shores have coordinates $x = 0$ and $x = w$ .\n\n", "outputFormat": "\n\nWrite to the output file two real numbers $x_{+}$ and $y_{+} (0 < x_{+} < w , −10^{9} \\le y_{+} \\le 10^{9})$ -- the coordinates of the stone to add. This stone shall minimize the largest leap required to traverse the optimal route. If a new stone cannot provide any improvement to the optimal route, then an arbitrary pair of $x_{+}$ and $y_{+}$ satisfying the constraints can be written, even coinciding with one of the existing stones. Your answer shall be precise up to three digits after the decimal point.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Froggy Ford（征集SPJ）", "background": "", "description": "\n\nFiona designs a new computer game Froggy Ford. In this game, a player helps a frog to cross a river using stone fords. Frog leaps from the river's shore to the first stone ford, than to the second one and so on, until it reaches the other shore. Unfortunately, frog is pretty weak and its leap distance is quite limited. Thus, a player should choose the optimal route -- the route that minimizes the largest leap required to traverse the route.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11740/1.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11740/2.png)\n\nOptimal route\n\nOptimal route with added stone\n\nFiona thinks that this game is not challenging enough, so she plans to add a possibility to place a new stone in the river. She asks you to write a program that determines such a location of the new stone that minimizes the largest leap required to traverse the optimal route.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $w$ -- the width of the river and $n$ -- the number of stones in it $(1 \\le w \\le 10^{9}, 0 \\le n \\le 1000)$ .\n\nEach of the following $n$ lines contains two integers $x_{i}, y_{i}$ -- the coordinates of the stones $(0 < x_{i} < w , −10^{9} \\le y_i \\le 10^{9}).$ Coordinates of all stones are distinct. River shores have coordinates $x = 0$ and $x = w$ .\n\n", "outputFormat": "\n\nWrite to the output file two real numbers $x_{+}$ and $y_{+} (0 < x_{+} < w , −10^{9} \\le y_{+} \\le 10^{9})$ -- the coordinates of the stone to add. This stone shall minimize the largest leap required to traverse the optimal route. If a new stone cannot provide any improvement to the optimal route, then an arbitrary pair of $x_{+}$ and $y_{+}$ satisfying the constraints can be written, even coinciding with one of the existing stones. Your answer shall be precise up to three digits after the decimal point.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Froggy Ford", "background": null, "description": "Fiona 设计了一款新的电脑游戏 **Froggy Ford**。在这个游戏中，玩家帮助一只青蛙利用河中石墩过河。青蛙从河岸跳到第一个石墩，然后跳到第二个石墩，依此类推，直到到达对岸。不幸的是，青蛙相当虚弱，其跳跃距离相当有限。因此，玩家应该选择最优路径——即最小化完成该路径所需的最大跳跃距离的路径。\n\n:::align{center}\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3doa91gk.png)\n\n最优路径\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vpvs91yd.png)\n\n添加石墩后的最优路径\n\n:::\n\nFiona 认为这个游戏还不够有挑战性，因此她计划添加在河中放置一个新石墩的功能。她请你编写一个程序，确定新石墩的位置，使得完成最优路径所需的最大跳跃距离最小化。", "inputFormat": "输入文件的第一行包含两个整数 $w$ ——河的宽度，以及 $n$ ——河中石墩的数量 $(1 \\le w \\le 10^{9}, 0 \\le n \\le 1000)$。\n\n接下来的 $n$ 行，每行包含两个整数 $x_{i}, y_{i}$ ——石墩的坐标 $(0 < x_{i} < w , −10^{9} \\le y_i \\le 10^{9})$。所有石墩的坐标互不相同。河岸的坐标为 $x = 0$ 和 $x = w$。", "outputFormat": "向输出文件写入两个实数 $x_{+}$ 和 $y_{+} (0 < x_{+} < w , −10^{9} \\le y_{+} \\le 10^{9})$ ——要添加的石墩的坐标。该石墩应能使完成最优路径所需的最大跳跃距离最小化。如果新石墩无法对最优路径提供任何改进，则可以输出满足约束的任意一对 $x_{+}$ 和 $y_{+}$，甚至可以与现有某个石墩的坐标重合。你的答案应精确到小数点后三位。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P6979", "type": "P", "difficulty": 3, "samples": [["2 3\n1 1 1 6\n2 4 0 5\n", "8\n4 1\n"], ["2 2\n0 7 2 8\n2 5 0 6\n", "-1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Generators", "background": "", "description": "\n\nLittle Roman is studying linear congruential generators -- one of the oldest and best known pseudorandom number generator algorithms. Linear congruential generator (LCG) starts with a non-negative integer number $x_{0}$ also known as seed and produces an infinite sequence of non-negative integer numbers $x_{i} (0 \\le x_{i} < c)$ which are given by the following recurrence relation:\n\n$x_{i+1} = (ax_{i} + b)$ mod $c$\n\nhere a , $b$ , and $c$ are non-negative integer numbers and $0 \\le x_{0} < c$ .\n\nRoman is curious about relations between sequences generated by different LCGs. In particular, he has $n$ different LCGs with parameters $a^{(j)}, b^{(j)},$ and $c^{(j)}$ for $1 \\le j \\le n$ , where the j-th LCG is generating a sequence $x_{i}^{(j)}.$ He wants to pick one number from each of the sequences generated by each LCG so that the sum of the numbers is the maximum one, but is not divisible by the given integer number $k$ .\n\nFormally, Roman wants to find integer numbers $t_{j} \\ge 0$ for $1 \\le j \\le n$ to maximize $s = Σ^{n}_{j=1} x_{t_{j}}^{(j)}  subject$ to constraint that $s$ mod $k ≠ 0$ .\n\n", "inputFormat": "\n\nThe first line of the input file contains two integer numbers $n$ and $k (1 \\le n \\le 10 000 , 1 \\le k \\le 10^{9}).$ The following $n$ lines describe LCGs. Each line contains four integer numbers $x_{0}^{(j)}, a^{(j)}, b^{(j)},$ and $c^{(j)} (0 \\le a^{(j)}, b^{(j)} \\le 1000 , 0 \\le x_{0}^{(j)} < c^{(j)} \\le 1000)$ .\n\n", "outputFormat": "\n\nIf Roman's problem has a solution, then write on the first line of the output file a single integer $s$ -- the maximum sum not divisible by $k$ , followed on the next line by $n$ integer numbers $t_{j} (0 \\le t_{j} \\le 10^{9})$ specifying some solution with this sum.\n\nOtherwise, write to the output file a single line with the number $−1$ .\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Generators", "background": "", "description": "\n\nLittle Roman is studying linear congruential generators -- one of the oldest and best known pseudorandom number generator algorithms. Linear congruential generator (LCG) starts with a non-negative integer number $x_{0}$ also known as seed and produces an infinite sequence of non-negative integer numbers $x_{i} (0 \\le x_{i} < c)$ which are given by the following recurrence relation:\n\n$x_{i+1} = (ax_{i} + b)$ mod $c$\n\nhere a , $b$ , and $c$ are non-negative integer numbers and $0 \\le x_{0} < c$ .\n\nRoman is curious about relations between sequences generated by different LCGs. In particular, he has $n$ different LCGs with parameters $a^{(j)}, b^{(j)},$ and $c^{(j)}$ for $1 \\le j \\le n$ , where the j-th LCG is generating a sequence $x_{i}^{(j)}.$ He wants to pick one number from each of the sequences generated by each LCG so that the sum of the numbers is the maximum one, but is not divisible by the given integer number $k$ .\n\nFormally, Roman wants to find integer numbers $t_{j} \\ge 0$ for $1 \\le j \\le n$ to maximize $s = Σ^{n}_{j=1} x_{t_{j}}^{(j)}  subject$ to constraint that $s$ mod $k ≠ 0$ .\n\n", "inputFormat": "\n\nThe first line of the input file contains two integer numbers $n$ and $k (1 \\le n \\le 10 000 , 1 \\le k \\le 10^{9}).$ The following $n$ lines describe LCGs. Each line contains four integer numbers $x_{0}^{(j)}, a^{(j)}, b^{(j)},$ and $c^{(j)} (0 \\le a^{(j)}, b^{(j)} \\le 1000 , 0 \\le x_{0}^{(j)} < c^{(j)} \\le 1000)$ .\n\n", "outputFormat": "\n\nIf Roman's problem has a solution, then write on the first line of the output file a single integer $s$ -- the maximum sum not divisible by $k$ , followed on the next line by $n$ integer numbers $t_{j} (0 \\le t_{j} \\le 10^{9})$ specifying some solution with this sum.\n\nOtherwise, write to the output file a single line with the number $−1$ .\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Generators", "background": "", "description": "罗曼在学习线性同余发生器——最古老，也是最广为人知的伪随机数生成算法之一。线性同余发生器（LCG）以 $x_0$ 为随机种子，生成很多非负整数 $x_i$ ,它遵循以下规则：\n\n给定非负整数 $a,b,c\\space(0≤x_0<c)$ ，\n$x_{i+1} = (ax_i+b)\\space mod \\space c$\n\n罗曼很好奇由不同LCG产生的序列之间的关系。特别地，他有 $n$ 个不同的LCG，含有参数 $a^{(j)}, b^{(j)}, c^{(j)}\\space(1≤j≤n)$。第 $j$ 个LCG会生成一个序列 $x_i^{(j)}$ 。\n\n他希望能从每个LCG产生的序列中挑出一个数，使他们的和最大，且不被给定的 $k$ 整除。\n\n**格式化一点来说**，他希望找到整数 $t_j \\space(t_j>0,1≤j≤n)$ ，使$s=\\sum\\limits_{j=1}^nx_{t_j}^{(j)}$最大，且$s\\not\\equiv0(mod\\space k)$。", "inputFormat": "第 $1$ 行包括两个整数$n,k$。\n\n$(1≤n≤10000,1≤k≤10^9)$\n\n\n接下来 $n$ 行描述LCG，每行包括4个整数：$x_0^{(j)},a^{(j)}, b^{(j)}, c^{(j)}$ 。\n\n$(0≤a^{(j)}, b^{(j)}≤1000,0≤x_0^{(j)}<c^{(j)}≤1000)$", "outputFormat": "如果有解，第 $1$ 行输出 $s$，第 $2$ 行输出 $n$ 个 $t_j$ 。\n\n$(0≤t_j≤10^9)$ 。\n\n如果无解，输出 $-1$ 。", "hint": "时间限制：1秒\n\n空间限制：256MB", "locale": "zh-CN"}}}
{"pid": "P6980", "type": "P", "difficulty": 6, "samples": [["3 3 4\n...\n.x.\n...\n.x.\nxxx\n.x.\n...\n.x.\n...\n...\n.x.\n...\n", "Yes\n"], ["8 1 1\nxxxxxxxx\n", "No\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Hypercube", "background": "", "description": "\n\nConsider a $4-hypercube$ also known as tesseract. A unit solid tesseract is a 4D figure that is equal to the convex hull of $16$ points with Cartesian coordinates $(±½, ±½, ±½, ±½)$ -- its vertices. It has $32$ edges $(1D), 24$ square faces $(2D),$ and $8$ cubic $3-faces$ (3D) also known as cells. We study hollow tesseracts and define a tesseract as a boundary of a solid tesseract. Thus, a tesseract is a connected union of $8$ solid cubes (its cells) that intersect between each other at $24$ tesseract's square faces, $32$ edges, and $16$ vertices.\n\nLet's cut a tesseract along $17$ of its $24$ faces, so that it still remains connected via $7$ faces that were left intact. Unfold the tesseract into a 3D hyperplane by rotating its constituting cubes along the faces that were left intact until all its cells lie in the same 3D hyperplane. The result is called a $3-net$ of a tesseract. This process is a natural generalization of how a 3D cube is cut and unfolded onto a 2D plane to produce a $2-net$ of a cube that consists of $6$ squares.\n\nIn this problem you are given a tree-like $8-polycube$ in 3D space also known as octocube. An octocube is a collection of $8$ unit cubical cells joined face-to-face. More formally, intersection of each pair of cubical cells constituting an octocube is either empty, a point, a unit line $(1D),$ or a unit square $(2D).$ The given octocube is tree-like in the following sense. Consider an adjacency graph of the octocube -- a graph with $8$ vertices corresponding to its $8$ cells. There is an edge in the adjacency graph between pairs of adjacent cells. Two cells of an octocube are called adjacent when their intersection is a square. Cells that intersect at a point or a line are not considered adjacent. An octocube is called tree-like when its adjacency graph is a tree.\n\nYour task is to determine whether the given tree-like octocube constitutes a $3-net$ of a tesseract. That is, whether this octocube being put onto a hyperplane in 4D space can be folded in 4D space along the squares of intersection between its cells into a tesseract.\n\nFor example, look at the leftmost picture below. It shows a wire-frame of the tree-like octocube. Rotate cell $GHLKG_{1}H_{1}L_{1}K_{1}$ around a plane GHLK and cell $FGKJF_{2}G_{2}K_{2}J_{2}$ around a plane FGKJ at angle $90$ degrees in $4-th$ dimension outside of the original hyperplane. As a result, point $G_{1}$ joins with $G_{2}$ and $K_{1}$ joins with $K_{2}.$ The face $GKK_{2}G_{2}$ is glued to face $GKK_{1}G_{1}.$ The result is shown on the right. The $4-th$ dimension is orthographically projected onto the $3$ shown in perspective. The points that have moved out of the original hyperplane are marked with hollow dots.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11742/1.png)\n\nRotate $EFJIE_{1}F_{1}J_{1}I_{1}$ around EFJI and $EHLIE_{2}H_{2}L_{2}I_{2}$ around EHLI. The result is shown on the following picture on the left. The remaining steps are as follows. Rotate MNOPQRST around MNOP, then rotate both MNOPQRST and IJKLMNOP around IJKL and rotate ABCDEFGH around EFGH. The last step is to glue all faces that meet together to get a tesseract that is shown on the right.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11742/2.png)\n\n", "inputFormat": "\n\nThe first line of the input file contains there integers $m , n , k$ -- the width, the depth, and the height of the box that contains the given octocube $(1 \\le m , n , k \\le 8)$ . The following $k$ groups of lines describe rectangular slices of the box from top to bottom. Each slice is described by $n$ rows with $m$ characters each. The characters on a line are either $‘. ',$ denoting an empty space, or $‘x',$ denoting a unit cube. The input file is guaranteed to describe a tree-like octocube.\n\n", "outputFormat": "\n\nWrite to the output file a single word `Yes` if the given octocube can be folded into a tesseract or `No` otherwise.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Hypercube", "background": "", "description": "\n\nConsider a $4-hypercube$ also known as tesseract. A unit solid tesseract is a 4D figure that is equal to the convex hull of $16$ points with Cartesian coordinates $(±½, ±½, ±½, ±½)$ -- its vertices. It has $32$ edges $(1D), 24$ square faces $(2D),$ and $8$ cubic $3-faces$ (3D) also known as cells. We study hollow tesseracts and define a tesseract as a boundary of a solid tesseract. Thus, a tesseract is a connected union of $8$ solid cubes (its cells) that intersect between each other at $24$ tesseract's square faces, $32$ edges, and $16$ vertices.\n\nLet's cut a tesseract along $17$ of its $24$ faces, so that it still remains connected via $7$ faces that were left intact. Unfold the tesseract into a 3D hyperplane by rotating its constituting cubes along the faces that were left intact until all its cells lie in the same 3D hyperplane. The result is called a $3-net$ of a tesseract. This process is a natural generalization of how a 3D cube is cut and unfolded onto a 2D plane to produce a $2-net$ of a cube that consists of $6$ squares.\n\nIn this problem you are given a tree-like $8-polycube$ in 3D space also known as octocube. An octocube is a collection of $8$ unit cubical cells joined face-to-face. More formally, intersection of each pair of cubical cells constituting an octocube is either empty, a point, a unit line $(1D),$ or a unit square $(2D).$ The given octocube is tree-like in the following sense. Consider an adjacency graph of the octocube -- a graph with $8$ vertices corresponding to its $8$ cells. There is an edge in the adjacency graph between pairs of adjacent cells. Two cells of an octocube are called adjacent when their intersection is a square. Cells that intersect at a point or a line are not considered adjacent. An octocube is called tree-like when its adjacency graph is a tree.\n\nYour task is to determine whether the given tree-like octocube constitutes a $3-net$ of a tesseract. That is, whether this octocube being put onto a hyperplane in 4D space can be folded in 4D space along the squares of intersection between its cells into a tesseract.\n\nFor example, look at the leftmost picture below. It shows a wire-frame of the tree-like octocube. Rotate cell $GHLKG_{1}H_{1}L_{1}K_{1}$ around a plane GHLK and cell $FGKJF_{2}G_{2}K_{2}J_{2}$ around a plane FGKJ at angle $90$ degrees in $4-th$ dimension outside of the original hyperplane. As a result, point $G_{1}$ joins with $G_{2}$ and $K_{1}$ joins with $K_{2}.$ The face $GKK_{2}G_{2}$ is glued to face $GKK_{1}G_{1}.$ The result is shown on the right. The $4-th$ dimension is orthographically projected onto the $3$ shown in perspective. The points that have moved out of the original hyperplane are marked with hollow dots.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11742/1.png)\n\nRotate $EFJIE_{1}F_{1}J_{1}I_{1}$ around EFJI and $EHLIE_{2}H_{2}L_{2}I_{2}$ around EHLI. The result is shown on the following picture on the left. The remaining steps are as follows. Rotate MNOPQRST around MNOP, then rotate both MNOPQRST and IJKLMNOP around IJKL and rotate ABCDEFGH around EFGH. The last step is to glue all faces that meet together to get a tesseract that is shown on the right.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11742/2.png)\n\n", "inputFormat": "\n\nThe first line of the input file contains there integers $m , n , k$ -- the width, the depth, and the height of the box that contains the given octocube $(1 \\le m , n , k \\le 8)$ . The following $k$ groups of lines describe rectangular slices of the box from top to bottom. Each slice is described by $n$ rows with $m$ characters each. The characters on a line are either $‘. ',$ denoting an empty space, or $‘x',$ denoting a unit cube. The input file is guaranteed to describe a tree-like octocube.\n\n", "outputFormat": "\n\nWrite to the output file a single word `Yes` if the given octocube can be folded into a tesseract or `No` otherwise.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Hypercube", "background": "", "description": "考虑一个 $4$-超立方体，也称为四维超正方体。一个单位实心四维超正方体是一个四维图形，它等于 $16$ 个点的凸包，这些点的笛卡尔坐标为 $(\\pm\\frac{1}{2}, \\pm\\frac{1}{2}, \\pm\\frac{1}{2}, \\pm\\frac{1}{2})$，即它的顶点。它有 $32$ 条边（$1D$），$24$ 个正方形面（$2D$），以及 $8$ 个立方体 $3$-面（$3D$），也称为单元。我们研究空心四维超正方体，并将四维超正方体定义为一个实心四维超正方体的边界。因此，四维超正方体是 $8$ 个实心立方体（其单元）的连接联合，这些立方体在四维超正方体的 $24$ 个正方形面、$32$ 条边和 $16$ 个顶点之间相交。\n\n让我们沿着四维超正方体的 $24$ 个面中的 $17$ 个面切割它，使其仍然通过剩下的 $7$ 个未被切割的面保持连接。通过沿着未被切割的面旋转其构成立方体，将四维超正方体展开到三维超平面中，直到其所有单元都位于同一三维超平面中。结果称为四维超正方体的 $3$-网。这一过程是三维立方体如何被切割并展开到二维平面上以产生由 $6$ 个正方形组成的立方体的 $2$-网的自然推广。\n\n在这个问题中，给定一个树状的 $8$-多立方体，也称为八立方体。八立方体是由 $8$ 个单位立方单元面对面连接而成的集合。更正式地说，构成八立方体的每对立方单元的交集要么为空，要么是一个点、一个单位线（$1D$），或一个单位正方形（$2D$）。给定的八立方体在以下意义上是树状的。考虑八立方体的邻接图——一个有 $8$ 个顶点的图，对应于其 $8$ 个单元。邻接图中存在一条边连接相邻单元对。当两个八立方体的单元的交集是一个正方形时，它们被称为相邻。当它们在一个点或一条线上相交时，不被认为是相邻的。当其邻接图是树时，八立方体被称为树状。\n\n你的任务是确定给定的树状八立方体是否构成四维超正方体的 $3$-网。也就是说，这个八立方体是否可以放置在四维空间的超平面上，并沿其单元之间的交叉正方形在四维空间中折叠成一个四维超正方体。\n\n例如，看看下面最左边的图片。它显示了树状八立方体的线框。将单元 $GHLKG_{1}H_{1}L_{1}K_{1}$ 绕平面 $GHLK$ 旋转，将单元 $FGKJF_{2}G_{2}K_{2}J_{2}$ 绕平面 $FGKJ$ 在第四维度上旋转 $90$ 度，超出原始超平面。结果，点 $G_{1}$ 与 $G_{2}$ 结合，$K_{1}$ 与 $K_{2}$ 结合。面 $GKK_{2}G_{2}$ 粘合到面 $GKK_{1}G_{1}$。结果如右图所示。第四维度正交投影到所示的三维透视图中。那些从原始超平面移出的点用空心点标记。\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11742/1.png)\n\n旋转 $EFJIE_{1}F_{1}J_{1}I_{1}$ 绕 $EFJI$，旋转 $EHLIE_{2}H_{2}L_{2}I_{2}$ 绕 $EHLI$。结果如下面左图所示。剩下的步骤如下。绕 $MNOPQRST$ 旋转，然后绕 $IJKL$ 旋转 $MNOPQRST$ 和 $IJKLMNOP$，最后绕 $EFGH$ 旋转 $ABCDEFGH$。最后一步是将所有相遇的面粘合在一起，得到右图所示的四维超正方体。\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11742/2.png)", "inputFormat": "输入文件的第一行包含三个整数 $m, n, k$——包含给定八立方体的盒子的宽度、深度和高度 $(1 \\le m, n, k \\le 8)$。接下来的 $k$ 组行描述了从上到下的盒子的矩形切片。每个切片由 $n$ 行组成，每行有 $m$ 个字符。行上的字符要么是 ‘.’，表示空格，要么是 ‘x’，表示单位立方体。输入文件保证描述了一个树状八立方体。", "outputFormat": "输出文件中写入一个单词 `Yes`，如果给定的八立方体可以折叠成一个四维超正方体，否则写入 `No`。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6981", "type": "P", "difficulty": 6, "samples": [["7\n42 1 100 200 20\n239 1 100 50 50\n1111 1 101 30 15\n1234 1 100 300 15\n4321 2 99 125 25\n5678 1 101 30 30\n8765 2 101 100 20\n", "42 4321 100 30\n239 4321 100 50\n1111 4321 101 30\n1234 4321 100 15\n5678 8765 101 30\n\n42 1 100 170 20 10\n1234 1 100 285 15 15\n8765 2 101 70 20 20\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Iceberg Orders", "background": "", "description": "\n\nYou are working for Metagonia stock exchange. Recently traders in Metagonia had heard about Iceberg orders traded on London stock exchange and asked your employer to add such functionality as well. A stock exchange is an engine that receives orders and generates trades.\n\nAn iceberg order is a quintuple of integers (ID, $T , P , V$ , TV). Each order has an identifier ID (unique among all orders), type $T$ (which is equal to either BUY $= 1$ or SELL $= 2)$ , price $P$ , total remaining volume $V$ and tip volume TV. For each order, exchange additionally keeps track of its current volume CV and priority PR. There is also a global priority counter of the exchange GP. An order book of the exchange is a set of orders.\n\nTrades that are generated by the exchange are quadruples of integers (BUY ID, SELL ID, $P , V)$ . Each trade has BUY ID and SELL ID -- identifiers of matching BUY and SELL orders, trade price $P$ , and trade volume $V$ .\n\nWhen an order is received by the exchange it is matched against orders currently on the order book. This is done as follows. Suppose an order a is received with $T_{a} =$ SELL. Among all orders currently on the order book we look for an order $b$ such that $T_{b} =$ BUY and $P_{b} \\ge P_{a}.$ We select such an order $b$ with the largest price, and if there are several -- one with the smallest priority. If there is such an order $b$ , then a trade $t$ is generated with BUY $ID_{t} = ID_{b}$ and SELL $ID_{t} = ID_{a}$ at trade price $P_{t} = P_{b}$ with trade volume $V_{t} = mi_n(V_{a}, CV_{b}). V_{a}, V_{b},$ and $CV_{b}$ are all decreased by trade volume. If $V_{b} = 0$ after this, then the order $b$ is removed from the order book. If $CV_{b} = 0$ (but $V_{b} > 0)$ then we set current volume of order $b$ to $CV_{b} = mi_n(V_{b}, TV_{b}),$ set $PR_{b} =$ GP, and increment GP. We continue these operations of selecting $b$ and generating trades until either $V_{a} = 0$ or there are no more orders $b$ on the order book which satisfy the condition. In the latter case, we add order a to the order book with $CV_{a} = mi_n(V_{a}, TV_{a})$ and $PR_{a} =$ GP, and then increment GP. When the process of matching the order a is finished with several trades between the same pair of orders a and $b$ (and there can be lots of them!), they are all united into a single trade with the volume equal to the sum of individual trade volumes.\n\nIf $T_{a} =$ BUY we are looking for an order $b$ with $T_{b} =$ SELL and $P_{b} \\le P_{a}$ and select such an order $b$ with the smallest price and the smallest priority among those. The rest of the matching process is as described above, with trades having BUY $ID_{t} = ID_{a},$ SELL $ID_{t} = ID_{b}, P_{t} = P_{b},$ and $V_{t} = mi_n(V_{a}, CV_{b}).$\n\nInitially the order book is empty. You are presented with several orders that are received by the exchange one by one. You need to print generated trades and the order book state after all orders are processed.\n\nHint: The priority and GP are introduced in the problem statement only for the purpose of a formal description of the algorithm. The actual implementation does not have to keep track of priority. Typically, an exchange simply keeps a priority-ordered list of orders of each type at each price in its order book.\n\n", "inputFormat": "\n\nThe first line of the input contains the number of orders $n (1 \\le n \\le 50 000)$ . Each of the following $n$ lines represent an order. Each order is given by a space-separated quintuple ID $T P V$ TV , where $1 \\le $ ID $ \\le 1 000 000 , T = 1$ for BUY and $T = 2$ for SELL, $1 \\le P \\le 100 000$ and $1 \\le $ TV $ \\le V \\le 1 000 000 000$ .\n\n", "outputFormat": "\n\nFor each order print all trades generated by processing this order, in ascending order of pairs (BUY ID, SELL ID), each trade on its own line. Each trade shall be printed as a space-separated quadruple of integers BUY ID SELL ID $P V$ . It is guaranteed that the total number of trades would not exceed $100 000$ . Print a blank line after all trades, followed by the order book. Each order that is still on the book shall be printed as a space-separated sextuple ID $T P V$ TV CV, sorted first by $P$ and then by PR.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Iceberg Orders", "background": "", "description": "\n\nYou are working for Metagonia stock exchange. Recently traders in Metagonia had heard about Iceberg orders traded on London stock exchange and asked your employer to add such functionality as well. A stock exchange is an engine that receives orders and generates trades.\n\nAn iceberg order is a quintuple of integers (ID, $T , P , V$ , TV). Each order has an identifier ID (unique among all orders), type $T$ (which is equal to either BUY $= 1$ or SELL $= 2)$ , price $P$ , total remaining volume $V$ and tip volume TV. For each order, exchange additionally keeps track of its current volume CV and priority PR. There is also a global priority counter of the exchange GP. An order book of the exchange is a set of orders.\n\nTrades that are generated by the exchange are quadruples of integers (BUY ID, SELL ID, $P , V)$ . Each trade has BUY ID and SELL ID -- identifiers of matching BUY and SELL orders, trade price $P$ , and trade volume $V$ .\n\nWhen an order is received by the exchange it is matched against orders currently on the order book. This is done as follows. Suppose an order a is received with $T_{a} =$ SELL. Among all orders currently on the order book we look for an order $b$ such that $T_{b} =$ BUY and $P_{b} \\ge P_{a}.$ We select such an order $b$ with the largest price, and if there are several -- one with the smallest priority. If there is such an order $b$ , then a trade $t$ is generated with BUY $ID_{t} = ID_{b}$ and SELL $ID_{t} = ID_{a}$ at trade price $P_{t} = P_{b}$ with trade volume $V_{t} = mi_n(V_{a}, CV_{b}). V_{a}, V_{b},$ and $CV_{b}$ are all decreased by trade volume. If $V_{b} = 0$ after this, then the order $b$ is removed from the order book. If $CV_{b} = 0$ (but $V_{b} > 0)$ then we set current volume of order $b$ to $CV_{b} = mi_n(V_{b}, TV_{b}),$ set $PR_{b} =$ GP, and increment GP. We continue these operations of selecting $b$ and generating trades until either $V_{a} = 0$ or there are no more orders $b$ on the order book which satisfy the condition. In the latter case, we add order a to the order book with $CV_{a} = mi_n(V_{a}, TV_{a})$ and $PR_{a} =$ GP, and then increment GP. When the process of matching the order a is finished with several trades between the same pair of orders a and $b$ (and there can be lots of them!), they are all united into a single trade with the volume equal to the sum of individual trade volumes.\n\nIf $T_{a} =$ BUY we are looking for an order $b$ with $T_{b} =$ SELL and $P_{b} \\le P_{a}$ and select such an order $b$ with the smallest price and the smallest priority among those. The rest of the matching process is as described above, with trades having BUY $ID_{t} = ID_{a},$ SELL $ID_{t} = ID_{b}, P_{t} = P_{b},$ and $V_{t} = mi_n(V_{a}, CV_{b}).$\n\nInitially the order book is empty. You are presented with several orders that are received by the exchange one by one. You need to print generated trades and the order book state after all orders are processed.\n\nHint: The priority and GP are introduced in the problem statement only for the purpose of a formal description of the algorithm. The actual implementation does not have to keep track of priority. Typically, an exchange simply keeps a priority-ordered list of orders of each type at each price in its order book.\n\n", "inputFormat": "\n\nThe first line of the input contains the number of orders $n (1 \\le n \\le 50 000)$ . Each of the following $n$ lines represent an order. Each order is given by a space-separated quintuple ID $T P V$ TV , where $1 \\le $ ID $ \\le 1 000 000 , T = 1$ for BUY and $T = 2$ for SELL, $1 \\le P \\le 100 000$ and $1 \\le $ TV $ \\le V \\le 1 000 000 000$ .\n\n", "outputFormat": "\n\nFor each order print all trades generated by processing this order, in ascending order of pairs (BUY ID, SELL ID), each trade on its own line. Each trade shall be printed as a space-separated quadruple of integers BUY ID SELL ID $P V$ . It is guaranteed that the total number of trades would not exceed $100 000$ . Print a blank line after all trades, followed by the order book. Each order that is still on the book shall be printed as a space-separated sextuple ID $T P V$ TV CV, sorted first by $P$ and then by PR.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Iceberg Orders", "background": "", "description": "你正在为 Metagonia 证券交易所工作。最近，Metagonia 的交易员听说了伦敦证券交易所的冰山订单，并要求你的雇主也增加这种功能。证券交易所是一个接收订单并生成交易的引擎。\n\n冰山订单是一个五元组整数 (ID, $T , P , V$ , TV)。每个订单都有一个标识符 ID（在所有订单中唯一），类型 $T$（等于 BUY $= 1$ 或 SELL $= 2$），价格 $P$，总剩余量 $V$ 和显示量 TV。对于每个订单，交易所还会跟踪其当前量 CV 和优先级 PR。交易所还有一个全局优先级计数器 GP。交易所的订单簿是一组订单。\n\n交易所生成的交易是一个四元组整数 (BUY ID, SELL ID, $P , V$)。每笔交易都有 BUY ID 和 SELL ID —— 匹配的买入和卖出订单的标识符，交易价格 $P$ 和交易量 $V$。\n\n当交易所收到一个订单时，它会与当前订单簿上的订单进行匹配。具体操作如下。假设收到一个订单 a，其 $T_{a} =$ SELL。在所有当前订单簿上的订单中，我们寻找一个订单 $b$，使得 $T_{b} =$ BUY 且 $P_{b} \\ge P_{a}$。我们选择这样的订单 $b$，其价格最大，如果有多个，则选择优先级最小的。如果存在这样的订单 $b$，则生成交易 $t$，其 BUY $ID_{t} = ID_{b}$ 和 SELL $ID_{t} = ID_{a}$，交易价格 $P_{t} = P_{b}$，交易量 $V_{t} = \\min(V_{a}, CV_{b})$。$V_{a}, V_{b},$ 和 $CV_{b}$ 都减少交易量。如果 $V_{b} = 0$ 之后，该订单 $b$ 从订单簿中移除。如果 $CV_{b} = 0$（但 $V_{b} > 0$），则我们设置订单 $b$ 的当前量为 $CV_{b} = \\min(V_{b}, TV_{b})$，设置 $PR_{b} =$ GP，并增加 GP。我们继续选择 $b$ 和生成交易的操作，直到 $V_{a} = 0$ 或者没有更多满足条件的订单 $b$ 在订单簿上。在后一种情况下，我们将订单 a 添加到订单簿中，$CV_{a} = \\min(V_{a}, TV_{a})$ 和 $PR_{a} =$ GP，然后增加 GP。当订单 a 的匹配过程结束时，如果在同一对订单 a 和 $b$ 之间有多个交易（可能有很多！），它们都合并为一个交易，交易量等于各个交易量的总和。\n\n如果 $T_{a} =$ BUY，我们寻找一个订单 $b$，使得 $T_{b} =$ SELL 且 $P_{b} \\le P_{a}$，并在其中选择价格最小且优先级最小的订单 $b$。其余的匹配过程如上所述，交易的 BUY $ID_{t} = ID_{a},$ SELL $ID_{t} = ID_{b}, P_{t} = P_{b},$ 和 $V_{t} = \\min(V_{a}, CV_{b})$。\n\n最初订单簿是空的。你将看到几个订单，一个接一个地被交易所接收。你需要打印生成的交易以及所有订单处理完后的订单簿状态。\n\n提示：优先级和 GP 在问题陈述中仅用于算法的形式描述。实际实现不必跟踪优先级。通常，交易所只需在其订单簿中保持每个价格的每种类型的订单的优先级排序列表。", "inputFormat": "输入的第一行包含订单数量 $n (1 \\le n \\le 50 000)$。接下来的 $n$ 行中的每一行代表一个订单。每个订单由一个以空格分隔的五元组 ID $T P V$ TV 给出，其中 $1 \\le $ ID $ \\le 1 000 000 , T = 1$ 表示 BUY，$T = 2$ 表示 SELL，$1 \\le P \\le 100 000$ 且 $1 \\le $ TV $ \\le V \\le 1 000 000 000$。", "outputFormat": "对于每个订单，打印处理该订单生成的所有交易，按 (BUY ID, SELL ID) 对的升序排列，每个交易占一行。每个交易应打印为一个以空格分隔的四元组整数 BUY ID SELL ID $P V$。保证交易总数不超过 $100 000$。在所有交易之后打印一个空行，接着是订单簿。订单簿上仍然存在的每个订单应打印为一个以空格分隔的六元组 ID $T P V$ TV CV，首先按 $P$ 排序，然后按 PR 排序。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6982", "type": "P", "difficulty": 6, "samples": [["2\n1\n0\n1\n2", "01\n11\n10\n00"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Jump", "background": "", "description": "Consider a toy interactive problem ONEMAX which is defined as follows.\n\nYou know an integer $n$ and there is a hidden bit - string $S$ of length $n$. The only thing you may do is to present the system a bit - string $Q$ of length $n$, and the system will return the number $\\text{ONEMAX}(Q)$ — the number of bits which coincide in $Q$ and $S$ at the corresponding positions. The name of ONEMAX problem stems from the fact that this problem and a simpler one explaining when $S = 11\\ldots11$, so that the problem turns into maximization (MAX) of the number of ones (ONE).\n\nWhen $n$ is even, there is a similar (but harder) interactive problem called JUMP. The simplest way to describe the JUMP is by using ONEMAX:\n$$\n\\text{JUMP}(Q)=\n\\begin{cases}\n\\text{ONEMAX}(Q) & \\text{if } \\text{ONEMAX}(Q)=n \\text{ or } \\text{ONEMAX}(Q)=n/2; \\\\\n0 & \\text{otherwise.}\n\\end{cases}\n$$\nBasically, the only nonzero values of ONEMAX which you can see with JUMP are $n$ (which means you've found the hidden string $S$) and $n/2$.\n\nGiven an even integer $n$ — the problem size, you have to solve the JUMP problem for the hidden string $S$ by making interactive JUMP queries. Your task is to eventually make a query $Q$ such that $Q = S$.\n\n### Interaction protocol\n\nFirst, the testing system tells the length of the bit - string $n$. Then, your solution asks the queries and the system answers them as given by the JUMP definition. When a solution asks the query $Q$ such that $Q = S$, the system answers $n$ and terminates, so if your solution, after reading the answer $n$, tries reading or writing anything, it will fail.\n\nThe limit on the number of queries is $n + 500$. If your solution asks a $(n + 501)$ - th query, then you will receive the “Wrong Answer” outcome. You will also receive this outcome if your solution terminates too early.\n\nIf your query contains wrong characters (neither 0, nor 1), or has a wrong length (not equal to $n$), the system will terminate the testing and you will receive the “Presentation Error” outcome.\n\nYou will receive the “Time Limit Exceeded” outcome and other errors for the usual violations.\n\nFinally, if everything is OK (e.g. your solution finds the hidden string) on every test, you will receive the “Accepted” outcome, in this case you will have solved the problem.", "inputFormat": "The first line of the input stream contains an even number $n$ ($2\\leq n\\leq1000$). The next lines of the input stream consist of the answers to the corresponding queries. Each answer is an integer — either $0$, $n/2$, or $n$. Each answer is on its own line.", "outputFormat": "To make a query, print a line which contains a string of length $n$ which consists of characters $0$ and $1$ only. Don't forget to put a newline character and to flush the output stream after you print your query. ", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NEERC 2015] Jump", "background": "", "description": "Consider a toy interactive problem ONEMAX which is defined as follows.\n\nYou know an integer $n$ and there is a hidden bit - string $S$ of length $n$. The only thing you may do is to present the system a bit - string $Q$ of length $n$, and the system will return the number $\\text{ONEMAX}(Q)$ — the number of bits which coincide in $Q$ and $S$ at the corresponding positions. The name of ONEMAX problem stems from the fact that this problem and a simpler one explaining when $S = 11\\ldots11$, so that the problem turns into maximization (MAX) of the number of ones (ONE).\n\nWhen $n$ is even, there is a similar (but harder) interactive problem called JUMP. The simplest way to describe the JUMP is by using ONEMAX:\n$$\n\\text{JUMP}(Q)=\n\\begin{cases}\n\\text{ONEMAX}(Q) & \\text{if } \\text{ONEMAX}(Q)=n \\text{ or } \\text{ONEMAX}(Q)=n/2; \\\\\n0 & \\text{otherwise.}\n\\end{cases}\n$$\nBasically, the only nonzero values of ONEMAX which you can see with JUMP are $n$ (which means you've found the hidden string $S$) and $n/2$.\n\nGiven an even integer $n$ — the problem size, you have to solve the JUMP problem for the hidden string $S$ by making interactive JUMP queries. Your task is to eventually make a query $Q$ such that $Q = S$.\n\n### Interaction protocol\n\nFirst, the testing system tells the length of the bit - string $n$. Then, your solution asks the queries and the system answers them as given by the JUMP definition. When a solution asks the query $Q$ such that $Q = S$, the system answers $n$ and terminates, so if your solution, after reading the answer $n$, tries reading or writing anything, it will fail.\n\nThe limit on the number of queries is $n + 500$. If your solution asks a $(n + 501)$ - th query, then you will receive the “Wrong Answer” outcome. You will also receive this outcome if your solution terminates too early.\n\nIf your query contains wrong characters (neither 0, nor 1), or has a wrong length (not equal to $n$), the system will terminate the testing and you will receive the “Presentation Error” outcome.\n\nYou will receive the “Time Limit Exceeded” outcome and other errors for the usual violations.\n\nFinally, if everything is OK (e.g. your solution finds the hidden string) on every test, you will receive the “Accepted” outcome, in this case you will have solved the problem.", "inputFormat": "The first line of the input stream contains an even number $n$ ($2\\leq n\\leq1000$). The next lines of the input stream consist of the answers to the corresponding queries. Each answer is an integer — either $0$, $n/2$, or $n$. Each answer is on its own line.", "outputFormat": "To make a query, print a line which contains a string of length $n$ which consists of characters $0$ and $1$ only. Don't forget to put a newline character and to flush the output stream after you print your query. ", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6983", "type": "P", "difficulty": 6, "samples": [["4 6\n1 4\n4 1\n4 2\n2 1\n3 4\n1 3\n", "1 3 4 2 1\n"], ["4 3\n1 4\n1 4\n2 2\n", "There is no route, Karl!\n"]], "limits": {"time": [3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] King’s Inspection", "background": "", "description": "\n\nKing Karl is a responsible and diligent ruler. Each year he travels across his country to make certain that all cities are doing well.\n\nThere are $n$ cities in his country and $m$ roads. In order to control the travelers, each road is unidirectional, that is a road from city a to city $b$ can not be passed from $b$ to a .\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11745/1.png)\n\nKarl wants to travel along the roads in such a way that he starts in the capital, visits every non-capital city exactly once, and finishes in the capital again.\n\nAs a transport minister, you are obliged to find such a route, or to determine that such a route doesn't exist.\n\n", "inputFormat": "\n\nThe first line contains two integers $n$ and $m (2 \\le n \\le 100 000 , 0 \\le m \\le n + 20)$ -- the number of cities and the number of roads in the country.\n\nEach of the next $m$ lines contains two integers $a_{i}$ and $b_{i} (1 \\le a_{i}, b_{i} \\le n)$ , meaning that there is a one-way road from city $a_{i}$ to city $b_{i}.$ Cities are numbered from $1$ to $n$ . The capital is numbered as $1$ .\n\n", "outputFormat": "\n\nIf there is a route that passes through each non-capital city exactly once, starting and finishing in the capital, then output $n + 1$ space-separated integers -- a list of cities along the route. Do output the capital city both in the beginning and in the end of the route.\n\nIf there is no desired route, output `There is no route, Karl!` (without quotation marks).\n\n", "hint": "Time limit: 10 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] King’s Inspection", "background": "", "description": "\n\nKing Karl is a responsible and diligent ruler. Each year he travels across his country to make certain that all cities are doing well.\n\nThere are $n$ cities in his country and $m$ roads. In order to control the travelers, each road is unidirectional, that is a road from city a to city $b$ can not be passed from $b$ to a .\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11745/1.png)\n\nKarl wants to travel along the roads in such a way that he starts in the capital, visits every non-capital city exactly once, and finishes in the capital again.\n\nAs a transport minister, you are obliged to find such a route, or to determine that such a route doesn't exist.\n\n", "inputFormat": "\n\nThe first line contains two integers $n$ and $m (2 \\le n \\le 100 000 , 0 \\le m \\le n + 20)$ -- the number of cities and the number of roads in the country.\n\nEach of the next $m$ lines contains two integers $a_{i}$ and $b_{i} (1 \\le a_{i}, b_{i} \\le n)$ , meaning that there is a one-way road from city $a_{i}$ to city $b_{i}.$ Cities are numbered from $1$ to $n$ . The capital is numbered as $1$ .\n\n", "outputFormat": "\n\nIf there is a route that passes through each non-capital city exactly once, starting and finishing in the capital, then output $n + 1$ space-separated integers -- a list of cities along the route. Do output the capital city both in the beginning and in the end of the route.\n\nIf there is no desired route, output `There is no route, Karl!` (without quotation marks).\n\n", "hint": "Time limit: 10 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] King’s Inspection", "background": "", "description": "国王 Karl 是一位负责且勤勉的统治者。每年他都会在全国各地巡游，以确保所有城市都运转良好。\n\n他的国家有 $n$ 个城市和 $m$ 条道路。为了控制旅行者，每条道路都是单向的，即从城市 $a$ 到城市 $b$ 的道路不能从 $b$ 到 $a$ 通过。\n\nKarl 想要沿着这些道路旅行，他希望从首都出发，恰好访问每个非首都城市一次，并最终回到首都。\n\n作为交通部长，你有责任找到这样一条路线，或者确定这样的路线不存在。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$ $(2 \\le n \\le 100000, 0 \\le m \\le n + 20)$ —— 国家中的城市数量和道路数量。\n\n接下来的 $m$ 行中的每一行包含两个整数 $a_{i}$ 和 $b_{i}$ $(1 \\le a_{i}, b_{i} \\le n)$，表示有一条从城市 $a_{i}$ 到城市 $b_{i}$ 的单向道路。城市编号从 $1$ 到 $n$。首都编号为 $1$。", "outputFormat": "如果存在一条路线可以恰好经过每个非首都城市一次，并且起点和终点都是首都，则输出 $n + 1$ 个以空格分隔的整数——表示沿途经过的城市列表。请在路线的开头和结尾都输出首都城市。\n\n如果没有符合条件的路线，则输出 `There is no route, Karl!`（不带引号）。", "hint": "时间限制：10 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6984", "type": "P", "difficulty": 6, "samples": [["8 4\n3\n4\n2\n1\n3\n3\n2\n4\n", "5\n"], ["3 100\n3\n3\n3\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NERC/NEERC"], "title": "[NEERC 2015] Landscape Improved", "background": "", "description": "\n\nLouis $L$ Le Roi-Univers has ordered to improve the landscape that is seen from the royal palace. His Majesty prefers to see a high mountain.\n\nThe Chief Landscape Manager is going to raise a mountain for Louis. He represents a landscape as a flat picture on a grid of unit squares. Some of the squares are already filled with rock, while others are empty. This greatly simplifies the design. Unit squares are small enough, and the landscape seems to be smooth from the royal palace.\n\nThe Chief Landscape Manager has a plan of the landscape -- the heights of all rock-filled columns for each unit of width. He is going to add at most $n$ square units of stones atop of the existing landscape to make a mountain with as high peak as possible. Unfortunately, piles of stones are quite unstable. A unit square of stones may be placed only exactly on top of the other filled square of stones or rock, moreover the squares immediately to the bottom-left and to bottom-right of it should be already filled.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11746/1.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11746/2.png)\n\nExisting landscape\n\nImproved landscape\n\nYour task is to help The Chief Landscape Manager to determine the maximum height of the highest mountain he can build.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $w$ -- the width of the existing landscape and $n$ -- the maximum number of squares of stones to add $(1 \\le w \\le 100 000 , 0 \\le n \\le 10^{18}).$\n\nEach of the following $w$ lines contains a single integer $h_{i}$ -- the height of the existing landscape column $(1 \\le h_{i} \\le 10^{9}).$\n\n", "outputFormat": "\n\nThe output file shall contain the single integer -- the maximum possible landscape height after at most $n$ unit squares of stones are added in a stable way.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2015] Landscape Improved", "background": "", "description": "\n\nLouis $L$ Le Roi-Univers has ordered to improve the landscape that is seen from the royal palace. His Majesty prefers to see a high mountain.\n\nThe Chief Landscape Manager is going to raise a mountain for Louis. He represents a landscape as a flat picture on a grid of unit squares. Some of the squares are already filled with rock, while others are empty. This greatly simplifies the design. Unit squares are small enough, and the landscape seems to be smooth from the royal palace.\n\nThe Chief Landscape Manager has a plan of the landscape -- the heights of all rock-filled columns for each unit of width. He is going to add at most $n$ square units of stones atop of the existing landscape to make a mountain with as high peak as possible. Unfortunately, piles of stones are quite unstable. A unit square of stones may be placed only exactly on top of the other filled square of stones or rock, moreover the squares immediately to the bottom-left and to bottom-right of it should be already filled.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11746/1.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11746/2.png)\n\nExisting landscape\n\nImproved landscape\n\nYour task is to help The Chief Landscape Manager to determine the maximum height of the highest mountain he can build.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $w$ -- the width of the existing landscape and $n$ -- the maximum number of squares of stones to add $(1 \\le w \\le 100 000 , 0 \\le n \\le 10^{18}).$\n\nEach of the following $w$ lines contains a single integer $h_{i}$ -- the height of the existing landscape column $(1 \\le h_{i} \\le 10^{9}).$\n\n", "outputFormat": "\n\nThe output file shall contain the single integer -- the maximum possible landscape height after at most $n$ unit squares of stones are added in a stable way.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2015] Landscape Improved", "background": "", "description": "路易斯 $L$ Le Roi-Univers 下令改善从皇宫看到的景观。陛下希望看到一座高山。  \n\n首席景观经理打算为路易斯建造一座山。他将景观表示为单位方格网格上的平面图。一些方格已经被岩石填满，而其他方格是空的。这大大简化了设计。单位方格足够小，从皇宫看去，景观似乎是平滑的。  \n\n首席景观经理有一个景观计划——每个单位宽度的所有岩石填充列的高度。他打算在现有景观上最多添加 $n$ 个单位方格的石头，以建造一座尽可能高的山峰。不幸的是，石头堆非常不稳定。一个单位方格的石头只能精确地放在其他填充的石头或岩石方格的正上方，而且其左下方和右下方的方格应该已经被填满。  \n\n现有景观  \n\n改进后的景观  \n\n你的任务是帮助首席景观经理确定他能建造的最高山峰的最大高度。", "inputFormat": "输入文件的第一行包含两个整数 $w$ ——现有景观的宽度和 $n$ ——最多可以添加的石头方格数 $(1 \\le w \\le 100 000 , 0 \\le n \\le 10^{18})$。  \n\n接下来的 $w$ 行中的每一行包含一个整数 $h_{i}$ ——现有景观列的高度 $(1 \\le h_{i} \\le 10^{9})$。", "outputFormat": "输出文件应包含一个整数——在最多添加 $n$ 个单位方格的石头后，景观可能达到的最大高度。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6985", "type": "P", "difficulty": 3, "samples": [["2 2\n", "2\n1 1 1 1\n2 2 2 2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Alter Board", "background": "", "description": "Little Dima gave his little brother Petya interactive chess board of size $n \\times m$ as a present. There are many awesome features of this board but one is Petya's favorite. He can choose any rectangle formed by board squares and perform an inversion. Every white cell in the inverted rectangle becomes black and every black one becomes white.\n\nIn the initial state the board is colored in chess style, namely every cell is either black or white and every two cells that share a side have different colors. Little Petya wants to perform several inversions described above to turn all cells into the same color. He is impatient, so he asks you to provide him with instructions to do it with the minimal number of inversions.", "inputFormat": "Contains two integers $n$ and $m (1 \\le n , m \\le 50) -$ the number of rows and columns on the board, respectively.", "outputFormat": "\nThe first line must contain the number of inversions $k$ required to transform the board.\n\nThe following $k$ lines must describe inversions, one per line. Each line must contains $4$ integers $-$ row and column of one of the corners of the corresponding rectangle and row and column of the opposite corner. Any two opposite corners can be used to specify a rectangle.\n\nRows of the board are numbered from $1$ to $n$ . Columns of the board are numbered from $1$ to $m$ . ", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Alter Board", "background": "", "description": "Little Dima gave his little brother Petya interactive chess board of size $n \\times m$ as a present. There are many awesome features of this board but one is Petya's favorite. He can choose any rectangle formed by board squares and perform an inversion. Every white cell in the inverted rectangle becomes black and every black one becomes white.\n\nIn the initial state the board is colored in chess style, namely every cell is either black or white and every two cells that share a side have different colors. Little Petya wants to perform several inversions described above to turn all cells into the same color. He is impatient, so he asks you to provide him with instructions to do it with the minimal number of inversions.", "inputFormat": "Contains two integers $n$ and $m (1 \\le n , m \\le 50) -$ the number of rows and columns on the board, respectively.", "outputFormat": "\nThe first line must contain the number of inversions $k$ required to transform the board.\n\nThe following $k$ lines must describe inversions, one per line. Each line must contains $4$ integers $-$ row and column of one of the corners of the corresponding rectangle and row and column of the opposite corner. Any two opposite corners can be used to specify a rectangle.\n\nRows of the board are numbered from $1$ to $n$ . Columns of the board are numbered from $1$ to $m$ . ", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Alter Board", "background": "", "description": "小 Dima 给了他的小弟弟 Petya 一个大小为 $n \\times m$ 的交互式棋盘作为礼物。这个棋盘有很多很棒的功能，但有一个是 Petya 最喜欢的。他可以选择由棋盘方格形成的任意矩形并进行反转。被反转矩形中的每个白色单元格变为黑色，每个黑色单元格变为白色。\n\n在初始状态下，棋盘是以国际象棋风格着色的，即每个单元格要么是黑色，要么是白色，并且每两个共享一条边的单元格具有不同的颜色。小 Petya 想执行上述几个反转操作以将所有单元格变为相同的颜色。他很不耐烦，所以他请你提供指令，以最少的反转次数完成。", "inputFormat": "包含两个整数 $n$ 和 $m (1 \\le n , m \\le 50)$ —— 棋盘上的行数和列数。", "outputFormat": "第一行必须包含将棋盘转换所需的反转次数 $k$。\n\n接下来的 $k$ 行必须描述反转，每行一个。每行必须包含 $4$ 个整数 —— 对应矩形的一个角的行和列以及相对角的行和列。可以使用任意两个相对角来指定一个矩形。\n\n棋盘的行从 $1$ 到 $n$ 编号。棋盘的列从 $1$ 到 $m$ 编号。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n特殊评测提供者：@[shenyouran](/user/137367)。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6986", "type": "P", "difficulty": 0, "samples": [["2 5 5\n2 2 1\n2 2 4\n", "5.5 5\n2 0.75\n"], ["2 5 5\n2 2 2\n2 2 4\n", "-1 -1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Burrito King（征集SPJ）", "background": "", "description": "\n\nTwo friends Albert and Barney came to the newly opened restaurant `Burrito King`. The restaurant had opened just yesterday, and Albert has got a special gift card, which allows the friends to get a free burrito. However, there is a constraint on the amount of ingredients -- the burrito can contain at most $g_i$ grams of ingredient $\\(i\\)$ for all $\\(i\\)$ from $1$ to $\\(n\\).$\n\nThere are two satisfaction parameters $\\(a_i\\)$ and $\\(b_i\\)$ for each ingredient -- the amount of Albert's joy per gram of the corresponding ingredient, and the amount of Barney's unhappiness per gram, correspondingly.\n\nTherefore, the total Albert's joy from the burrito is equal to:\n\n$\\[\\su_m_{i=1}^{n}{s_i \\cdot a_i}\\]$\n\nThe total Barney's unhappiness from the burrito is equal to:\n\n$\\[\\su_m_{i=1}^{n}{s_i \\cdot b_i}\\]$\n\nHere $\\(s_i\\)$ is the number of grams of the $\\(i\\)-th$ ingredient in the burrito. Note, that $\\(s_i\\)$ is not necessarily an integer, and $0 \\le \\(s_i\\) \\le \\(g_i\\).$\n\nAlbert wants to make his total joy from the burrito to be at least $\\(A\\).$ Barney is his best friend, so Albert wants Barney's total unhappiness to be no more than $\\(B\\).$ Among all possible burritos that satisfy the above constrains, Albert wants to choose one that maximises his total joy.\n\nYour task is to help Albert to choose $\\(s_i\\)$ to satisfy these conditions or to find out that there is no solution.\n\n", "inputFormat": "\n\nThe first line contains three integers $\\(n\\), \\(A\\),$ and $\\(B\\) (1 \\le \\(n\\) \\le 100 000 , 0 \\le \\(A\\), \\(B\\) \\le 10^{9}),$ the number of ingredients, the least amount of Albert's joy and the maximal amount of Barney's unhappiness. Each of the following $\\(n\\)$ lines contains a description of an ingredient: three integers $\\(g_i\\), \\(a_i\\), \\(b_i\\) (0 \\le \\(g_i\\), \\(a_i\\), \\(b_i\\) \\le 100)$ -- the maximal number of grams allowed, the amount of Albert's joy per gram and the amount of Barney's unhappiness per gram.\n\n", "outputFormat": "\n\nThe first line of the output must contain two real numbers -- the maximal amount of his joy and the amount of Barney's unhappiness that Albert can obtain, satisfying the conditions in the problem statement, or $`−1 −1`,$ if Albert cannot satisfy the conditions.\n\nIf the conditions are satisfiable the second line must contain $\\(n\\)$ real numbers -- the amount of each ingredient in grams.\n\nYour output must have an absolute or relative error of at most $10−8$ .\n\nAny way to reach maximal Albert's joy that satisfies the given conditions can be printed.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Burrito King（征集SPJ）", "background": "", "description": "\n\nTwo friends Albert and Barney came to the newly opened restaurant `Burrito King`. The restaurant had opened just yesterday, and Albert has got a special gift card, which allows the friends to get a free burrito. However, there is a constraint on the amount of ingredients -- the burrito can contain at most $g_i$ grams of ingredient $\\(i\\)$ for all $\\(i\\)$ from $1$ to $\\(n\\).$\n\nThere are two satisfaction parameters $\\(a_i\\)$ and $\\(b_i\\)$ for each ingredient -- the amount of Albert's joy per gram of the corresponding ingredient, and the amount of Barney's unhappiness per gram, correspondingly.\n\nTherefore, the total Albert's joy from the burrito is equal to:\n\n$\\[\\su_m_{i=1}^{n}{s_i \\cdot a_i}\\]$\n\nThe total Barney's unhappiness from the burrito is equal to:\n\n$\\[\\su_m_{i=1}^{n}{s_i \\cdot b_i}\\]$\n\nHere $\\(s_i\\)$ is the number of grams of the $\\(i\\)-th$ ingredient in the burrito. Note, that $\\(s_i\\)$ is not necessarily an integer, and $0 \\le \\(s_i\\) \\le \\(g_i\\).$\n\nAlbert wants to make his total joy from the burrito to be at least $\\(A\\).$ Barney is his best friend, so Albert wants Barney's total unhappiness to be no more than $\\(B\\).$ Among all possible burritos that satisfy the above constrains, Albert wants to choose one that maximises his total joy.\n\nYour task is to help Albert to choose $\\(s_i\\)$ to satisfy these conditions or to find out that there is no solution.\n\n", "inputFormat": "\n\nThe first line contains three integers $\\(n\\), \\(A\\),$ and $\\(B\\) (1 \\le \\(n\\) \\le 100 000 , 0 \\le \\(A\\), \\(B\\) \\le 10^{9}),$ the number of ingredients, the least amount of Albert's joy and the maximal amount of Barney's unhappiness. Each of the following $\\(n\\)$ lines contains a description of an ingredient: three integers $\\(g_i\\), \\(a_i\\), \\(b_i\\) (0 \\le \\(g_i\\), \\(a_i\\), \\(b_i\\) \\le 100)$ -- the maximal number of grams allowed, the amount of Albert's joy per gram and the amount of Barney's unhappiness per gram.\n\n", "outputFormat": "\n\nThe first line of the output must contain two real numbers -- the maximal amount of his joy and the amount of Barney's unhappiness that Albert can obtain, satisfying the conditions in the problem statement, or $`−1 −1`,$ if Albert cannot satisfy the conditions.\n\nIf the conditions are satisfiable the second line must contain $\\(n\\)$ real numbers -- the amount of each ingredient in grams.\n\nYour output must have an absolute or relative error of at most $10−8$ .\n\nAny way to reach maximal Albert's joy that satisfies the given conditions can be printed.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Burrito King（征集SPJ）", "background": "", "description": "两个朋友阿尔伯特和巴尼来到新开的 Burrito King 厅。这家餐厅昨天刚刚开业，阿尔伯特收到了一张特殊的礼品卡，可以让他们免费得到一份墨西哥卷饼。然而，配料的数量是有限制的。第 $i$ 种配料最多可以含有 $g_i$ 克（$1\\le i\\le n$）。\n\n每种成分都有两个满意度参数 $a_i$ 和 $b_i$。分别指每克相应成分的阿尔伯特获得的快乐量和每克巴尼获得的不快乐量。因此，阿尔伯特从墨西哥卷饼中获得的全部快乐等于：\n$$\\sum_{i=1}^{n}s_i\\cdot a_i$$\n巴尼对墨西哥卷饼的全部不快乐等于：\n$$\\sum_{i=1}^{n}s_i\\cdot b_i$$\n这里 $s_i$ 是墨西哥卷饼中第 $i$ 种配料分的克数。注意，$s_i$ 不一定是整数，并且 $0\\le s_i\\le g_i$。\n\n阿尔伯特想让他从墨西哥卷饼中获得的全部快乐至少是 $A$。巴尼是他最好的朋友，所以阿尔伯特希望巴尼的全部不快乐不超过 $B$。在所有可能满足上述限制的卷饼中，阿尔伯特想选择一种能最大限度地增加他全部快乐的卷饼。\n\n您的任务是帮助阿尔伯特选择 $s_i$ 来满足这些条件，或者发现没有解决方案。", "inputFormat": "第一行包含三个整数 $N$、$A$ 和 $B$（$1\\le N \\le 10^{5},0\\le A,B\\le 10^{9}$）。\n\n以下 $N$ 行都包含一种配料的描述：三个整数 $g_i$、 $a_i$、 $b_i$（$0\\le g_i,a_i,b_i\\le 100$），分别指第 $i$ 种配料的最大含有克数、每克阿尔伯特获得的快乐的量和每克巴尼获得的不快乐的量。", "outputFormat": "输出的第一行必须包含两个实数，指满足问题陈述中的条件时，阿尔伯特能获得的最大快乐量和巴尼的不快乐量，或者 `-1`（如果阿尔伯特不能满足条件）。\n\n如果条件可以满足，第二行包含 $N$ 个实数  $s_i$，单位为克。\n\n**您的输出必误差最多为 $10^{-8}$。任何满足给定条件的方法都判为正确。**", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6987", "type": "P", "difficulty": 6, "samples": [["c(c,t(loop(3),c(c,loop(6))),loop(c,c,t(c,loop(4))))\n", "15 1\n19 1 2 9 10 11 12 13 10 15 9 14 2 3 4 5 6 7 8 3\n"], ["c\n", "2 1\n2 1 2\n"], ["c(2)\n", "3 1\n3 1 2 3\n"], ["c(3)\n", "4 1\n4 1 2 3 4\n"], ["t(c(3),c,c)\n", "6 2\n2 1 2\n5 3 1 4 5 6\n"], ["c(2,t(c(2),c,c))\n", "9 3\n3 2 1 3\n3 4 5 6\n5 1 7 5 8 9\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Cactus Generator（征集SPJ）", "background": "", "description": "\n\nNEERC featured a number of problems about cactuses -- connected undirected graphs in which every edge belongs to at most one simple cycle. Intuitively, cactus is a generalization of a tree where some cycles are allowed.\n\nIn $2005$ , the first year where a problem about cactuses appeared, the problem was called simply `Cactus`. In $2007$ it was `Cactus Reloaded`, in $2010$ it was called `Cactus Revolution`, and in $2013$ it was called `Cactus Automorphisms`. Here is an example of cactus that was used in those problems:\n\n![](/upload/images2/cactus.png)\n\nFor four years judges had to generate test files for cactuses with thousands of vertices. Of course, a number of test generators of ever-increasing complexity were built, culminating with a domain-specific language called CGL -- Cactus Generator Language. CGL can compactly define a big cactus for purposes of a test. In this problem you have to parse a simplified version of this language, which we call SCGL -- Simple Cactus Generator Language, and output a resulting cactus.\n\nA cactus has to be output by listing the minimal set of edge-distinct paths that cover the whole graph.\n\nThe syntax of SCGL cactus definition is represented by the graph non-terminal in the grammar that is given below using the Extended Backus-Naur Form:\n\ngraph $=$ `c`\n\n$|$ `c(` list `)`\n\n$|$ `loop(` list `)`\n\n$|$ `t(` list `)`\n\nlist $=$ graph ${$ `,` graph $}$\n\n$|$ (number $|$ range $|$ variable ) $[$ `,` graph $]$\n\nnumber $=$ nzdig ${$ `0` $|$ nzdig $}$\n\nnzdig $=$ `1` $|$ `2` $| \\cdots |$ `8` $|$ `9`\n\nrange $=$ `range(` variable `,` numvar `,` numvar `)`\n\nvariable $=$ `A` $|$ `B` $| \\cdots |$ `Y` $|$ `Z`\n\nnumvar $=$ number $|$ variable\n\nA graph production rule denotes a graph with two labeled vertices -- the first and the last. Graphs definition rules have the following semantics:\n\nThe basic building block $c$ denotes a graph with just two vertices (one is the first and the other one is the last) and one edge.\n\nThe $c(σ)$ rule connects a specified list of graphs $σ$ from left to right into a chain, merging the last vertex of the first graph in the list with the first vertex of the second graph in the list, the last vertex of the second graph with the first of the third one, and so on. The resulting graph's first vertex is the first vertex of the first graph in the list, and the resulting graph's last vertex is the last vertex of the last graph in the list.\n\nThe $loo_p(σ)$ rule connects a specified list of graphs $σ$ from left to right, merging the last vertex of the first graph in the list with the first vertex of the second graph in the list, and so on like in $c(σ),$ while the last vertex of the last graph in the list is merged with the first vertex of the first graph in the list to form a loop. The resulting graph's first and last vertices are the first and the last vertices of the first graph in the list. Loop can be applied only to lists with more than one graph.\n\nThe $t(σ)$ rule connects a specified list of graphs $σ,$ merging their first vertices. The resulting graph's first and last vertices are the first and the last vertices of the first graph in the list.\n\nThe list of graphs is either specified explicitly, by a comma-separated list, or using a list repetition with a number, a range, or a variable, optionally followed by a comma and a graph. When a graph is not explicitly specified in a list repetition, then the given graph is assumed to be $c$ .\n\nThe simplest list repetition is defined using a number non-terminal. It denotes a list of graphs with the specified integer number of copies of the given graph.\n\nA range list repetition is defined by $range(ν, α, β)$ rule which has three components -- a variable $ν,$ and numbers $α$ and $β.$ If $ξ$ character sequence is a graph, then $c|loo_p|t(range(ν, α, β), ξ)$ are called rangeenabled rules and the variable $ν$ is called a bound variable in $ξ.$ In the context of a range-enabled rule, $ξ$ is repeated $|β − α| + 1$ times to form a list. Every occurrence of variable $ν$ in $ξ$ is replaced by consecutive integer numbers between $α$ and $β$ inclusive in ascending order. That produces a list of $|β −α|+ 1$ graphs, which are then connected according the specification of the corresponding range-enabled rule. The $α$ and $β$ themselves might refer to variables that are bound in the outer range-enabled rule.\n\nIn a well-formed graph:\n\neach variable non-terminal (a letter from A to $Z)$ occurs at most once as $ν$ in $range(ν, α, β)$ rules;\n\nall other occurrences of variable non-terminal that are allowed by the grammar are bound.\n\nNote, that if a character sequence $ξ$ is a graph, then $ξ, c(ξ),$ c(1 , $ξ), t(ξ),$ and t(1 , $ξ)$ all denote the same graph. On the other hand, neither $loo_p(ξ)$ nor loop(1 , $ξ)$ are allowed.\n\nThe following examples illustrate these basic rules. The graphs have their first and last vertices marked with letters $F$ and $L$ correspondingly.\n\n![](/upload/images2/cactus1.png)\n\n![](/upload/images2/cactus2.png)\n\n", "inputFormat": "\n\nThe input file contains a single line with a well-formed cactus definition in SCGL. While the syntax and semantics of SCGL themselves do not guarantee that the resulting graph is a cactus, the input file for this problem always defines a cactus -- every edge belongs to at most one simple cycle and there are no multiple edges between vertices. For example, neither loop(3 , $loo_p(3))$ nor $loo_p(2)$ are possible.\n\nThe line in the input file is at most $1000$ characters long and defines a cactus with at most $50 000$ vertices. Integer numbers represented by number non-terminals do not exceed $50 000$ .\n\n", "outputFormat": "\n\nThe first line of the output file must contain two integer numbers $n$ and $m$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ , where $1$ is the number of the first vertex of the graph and $n$ is the number of the last vertex of the graph. The other vertices can be numbered arbitrarily. Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the minimal number of such paths.\n\nEach of the following $m$ lines must contain a path in the graph. A path starts with an integer number $k_{i} (k_{i} \\ge 2)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. A path can go to the same vertex multiple times, but every edge must be traversed exactly once in the whole output file.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Cactus Generator（征集SPJ）", "background": "", "description": "\n\nNEERC featured a number of problems about cactuses -- connected undirected graphs in which every edge belongs to at most one simple cycle. Intuitively, cactus is a generalization of a tree where some cycles are allowed.\n\nIn $2005$ , the first year where a problem about cactuses appeared, the problem was called simply `Cactus`. In $2007$ it was `Cactus Reloaded`, in $2010$ it was called `Cactus Revolution`, and in $2013$ it was called `Cactus Automorphisms`. Here is an example of cactus that was used in those problems:\n\n![](/upload/images2/cactus.png)\n\nFor four years judges had to generate test files for cactuses with thousands of vertices. Of course, a number of test generators of ever-increasing complexity were built, culminating with a domain-specific language called CGL -- Cactus Generator Language. CGL can compactly define a big cactus for purposes of a test. In this problem you have to parse a simplified version of this language, which we call SCGL -- Simple Cactus Generator Language, and output a resulting cactus.\n\nA cactus has to be output by listing the minimal set of edge-distinct paths that cover the whole graph.\n\nThe syntax of SCGL cactus definition is represented by the graph non-terminal in the grammar that is given below using the Extended Backus-Naur Form:\n\ngraph $=$ `c`\n\n$|$ `c(` list `)`\n\n$|$ `loop(` list `)`\n\n$|$ `t(` list `)`\n\nlist $=$ graph ${$ `,` graph $}$\n\n$|$ (number $|$ range $|$ variable ) $[$ `,` graph $]$\n\nnumber $=$ nzdig ${$ `0` $|$ nzdig $}$\n\nnzdig $=$ `1` $|$ `2` $| \\cdots |$ `8` $|$ `9`\n\nrange $=$ `range(` variable `,` numvar `,` numvar `)`\n\nvariable $=$ `A` $|$ `B` $| \\cdots |$ `Y` $|$ `Z`\n\nnumvar $=$ number $|$ variable\n\nA graph production rule denotes a graph with two labeled vertices -- the first and the last. Graphs definition rules have the following semantics:\n\nThe basic building block $c$ denotes a graph with just two vertices (one is the first and the other one is the last) and one edge.\n\nThe $c(σ)$ rule connects a specified list of graphs $σ$ from left to right into a chain, merging the last vertex of the first graph in the list with the first vertex of the second graph in the list, the last vertex of the second graph with the first of the third one, and so on. The resulting graph's first vertex is the first vertex of the first graph in the list, and the resulting graph's last vertex is the last vertex of the last graph in the list.\n\nThe $loo_p(σ)$ rule connects a specified list of graphs $σ$ from left to right, merging the last vertex of the first graph in the list with the first vertex of the second graph in the list, and so on like in $c(σ),$ while the last vertex of the last graph in the list is merged with the first vertex of the first graph in the list to form a loop. The resulting graph's first and last vertices are the first and the last vertices of the first graph in the list. Loop can be applied only to lists with more than one graph.\n\nThe $t(σ)$ rule connects a specified list of graphs $σ,$ merging their first vertices. The resulting graph's first and last vertices are the first and the last vertices of the first graph in the list.\n\nThe list of graphs is either specified explicitly, by a comma-separated list, or using a list repetition with a number, a range, or a variable, optionally followed by a comma and a graph. When a graph is not explicitly specified in a list repetition, then the given graph is assumed to be $c$ .\n\nThe simplest list repetition is defined using a number non-terminal. It denotes a list of graphs with the specified integer number of copies of the given graph.\n\nA range list repetition is defined by $range(ν, α, β)$ rule which has three components -- a variable $ν,$ and numbers $α$ and $β.$ If $ξ$ character sequence is a graph, then $c|loo_p|t(range(ν, α, β), ξ)$ are called rangeenabled rules and the variable $ν$ is called a bound variable in $ξ.$ In the context of a range-enabled rule, $ξ$ is repeated $|β − α| + 1$ times to form a list. Every occurrence of variable $ν$ in $ξ$ is replaced by consecutive integer numbers between $α$ and $β$ inclusive in ascending order. That produces a list of $|β −α|+ 1$ graphs, which are then connected according the specification of the corresponding range-enabled rule. The $α$ and $β$ themselves might refer to variables that are bound in the outer range-enabled rule.\n\nIn a well-formed graph:\n\neach variable non-terminal (a letter from A to $Z)$ occurs at most once as $ν$ in $range(ν, α, β)$ rules;\n\nall other occurrences of variable non-terminal that are allowed by the grammar are bound.\n\nNote, that if a character sequence $ξ$ is a graph, then $ξ, c(ξ),$ c(1 , $ξ), t(ξ),$ and t(1 , $ξ)$ all denote the same graph. On the other hand, neither $loo_p(ξ)$ nor loop(1 , $ξ)$ are allowed.\n\nThe following examples illustrate these basic rules. The graphs have their first and last vertices marked with letters $F$ and $L$ correspondingly.\n\n![](/upload/images2/cactus1.png)\n\n![](/upload/images2/cactus2.png)\n\n", "inputFormat": "\n\nThe input file contains a single line with a well-formed cactus definition in SCGL. While the syntax and semantics of SCGL themselves do not guarantee that the resulting graph is a cactus, the input file for this problem always defines a cactus -- every edge belongs to at most one simple cycle and there are no multiple edges between vertices. For example, neither loop(3 , $loo_p(3))$ nor $loo_p(2)$ are possible.\n\nThe line in the input file is at most $1000$ characters long and defines a cactus with at most $50 000$ vertices. Integer numbers represented by number non-terminals do not exceed $50 000$ .\n\n", "outputFormat": "\n\nThe first line of the output file must contain two integer numbers $n$ and $m$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ , where $1$ is the number of the first vertex of the graph and $n$ is the number of the last vertex of the graph. The other vertices can be numbered arbitrarily. Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the minimal number of such paths.\n\nEach of the following $m$ lines must contain a path in the graph. A path starts with an integer number $k_{i} (k_{i} \\ge 2)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. A path can go to the same vertex multiple times, but every edge must be traversed exactly once in the whole output file.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Cactus Generator（征集SPJ）", "background": "", "description": "NEERC 以大量关于仙人掌的题目为特色——每条边属于至多一个简单环连通的无向图。直观的说，仙人掌是一种一些环被允许的广义树。\n\n2005年，第一个有关仙人掌的问题出现，这个问题被简单的叫做[“仙人掌”](https://codeforces.com/gym/101334)。在2007年是[“仙人掌再来”](https://codeforces.com/gym/100273)，在2010年叫做[“仙人掌变革”](https://codeforces.com/gym/101309)，以及2013年是[“仙人掌自同构”](https://codeforces.com/gym/100307)。以下是这些问题中使用的仙人掌例子：\n\n![](/upload/images2/cactus.png)\n\n四年来评测必须为顶点以千数的仙人掌生成测试文件。当然，复杂性日益增加的大量数据发生器被建立，最终有一个被称为 CGL（Cactus Generator Language，仙人掌发生器语言）的领域特定语言。CGL 可以为测试的目的简洁地定义一个大仙人掌。本题中你要解析该语言的我们称为 SCGL（Simple Cactus Generator Language，简单仙人掌发生器语言）的一个简化版本，输出一个仙人掌作结果。\n\n一个仙人掌要以列出边的极小集（覆盖全图的不同路径）输出。\n\nSCGL 仙人掌定义的语法由语法中的指定的用下面的扩展巴科斯-诺尔范式的非终止图表示：\n\n$$\n\\begin{aligned}\ngraph &= “\\texttt{\\textup{c}}”&&&&&&&&&&&&&&&&&&&&&&&&&&&\\\\\n&| “\\texttt{\\textup{c(}}” list “\\texttt{\\textup{)}}”\\\\\n&| “\\texttt{\\textup{loop(}}” list “\\texttt{\\textup{)}}”\\\\\n&| “\\texttt{\\textup{t(}}” list “\\texttt{\\textup{)}}”\\\\\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\nlist &= graph \\{ “\\texttt{\\textup{,}}” graph \\}&&&&&&&&&&&&\\\\\n&|(number | range | variable ) [ “\\texttt{\\textup{,}}” graph ]\\\\\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\n&number = nzdig \\{ “\\texttt{\\textup{0}}” | nzdig \\}\\\\\n&nzdig = “\\texttt{\\textup{1}}” | “\\texttt{\\textup{2}}” | \\cdots | “\\texttt{\\textup{8}}” | “\\texttt{\\textup{9}}”\\\\\n&range = “\\texttt{\\textup{range(}}” variable “\\texttt{\\textup{,}}” numvar “\\texttt{\\textup{,}}” numvar “\\texttt{\\textup{)}}”\\\\\n&variable = “\\texttt{\\textup{A}}” | “\\texttt{\\textup{B}}” | \\cdots | “\\texttt{\\textup{Y}}” | “\\texttt{\\textup{Z}}”\\\\\n&numvar = number | variable\n\\end{aligned}\n$$\n\n一个图的制造规则表示一个有两个点标记的图——首和尾。图定义规则有以下语义：\n\n- 基本建立块 $c$ 列表示一个仅有两个点（一首一尾）标记与一边的图。\n\n- $c(σ)$ 规则对于含有 $n$ 个图的指定图列表 $σ$ 将第 $i$ 图尾顶点与第 $i+1$ 图首顶点合并，加入列表。（$i\\in\\mathbb{N}^*,1\\le i< n$）结果图的首顶点为第一图首顶点，尾顶点为第 $n$ 图尾顶点。\n\n- $loop(σ)$ 规则与 $c(σ)$相似，但第 $n$ 图尾顶点与第一图首顶点合并,加入列表。结果图的首尾顶点为列表中第一图首尾顶点。环仅可被应用于一图以上的列表。\n\n- $t(σ)$ 规则连接一个指定图列表 $σ$，合并他们的首顶点。结果图的首尾顶点为列表中第一图首尾顶点。\n\n图列表不是以一逗号分隔列表明确指定，就是用一个有一个数字、范围或变量的选择性地跟随一个逗号或图的可重列表指定。当一图非于一可重列表中明确指定，则该指定图被假定为 $c$。\n\n最简单的可重列表用一个非终止数定义。它表示一个有指定整数个指定图的副本的列表。\n\n一个可重范围列表由有三个组件（变量 $ν$，数字 $α$ 与 $β$）的 $range(ν, α, β)$ 规则定义。若 $ξ$ 字符序列为一图，则 $c|loop|t(range(ν, α, β), ξ)$ 被称为范围启用规则，变量 $ν$ 被称为 $ξ$ 中的一个约束变量。在一个范围启用规则的语境中，$ξ$ 被重复 $|β − α| + 1$ 次以建立列表。变量 $ν$ 于 $ξ$ 中的每次出现按升序由连续的 $α$ 与 $β$ 之间的整数（包括 $α$ 与 $β$）取代。 那产出一个包括 $|β −α|+ 1$ 个图的列表，通过相应的范围启用规则的规范连接。$α$ 与 $β$ 自身可能指被约束于外范围启用规则的变量。\n\n在一个语法正确的图中：\n\n- 每一个非终止变量（一个从 A 到 Z 的字母）作为 $range(ν, α, β)$ 规则中的 $ν$ 至多存在一次；\n\n- 非终止变量的语法允许的所有其他事件被绑定。\n\n注意，若一字符序列 $ξ$ 为一图，那么 $ξ, c(ξ), c(1 , ξ), t(ξ),$ 与 $t(1 , ξ)$ 都指此一图。另一方面，不论 $loop(ξ)$ 还是 $loop(1 , ξ)$ 都不被允许。\n\n下列例子说明这些基本规则。这些图有以 F 与 L 相应标记的始末点。\n\n![](/upload/images2/cactus1.png)\n\n![](/upload/images2/cactus2.png)", "inputFormat": "输入文件包含一行，含有一个 SCGL 定义。定义格式正确，总描述一仙人掌，每条边属于至多一个简单环，无重边。比如，$loop(3 , loop(3))$ 与 $loop(2)$ 都不可能。\n\n输入文件中该行至多长 $1000$ 字符，定义的仙人掌至多 $50000$ 个顶点。由非终止数代列表的整数不超过 $50000$。", "outputFormat": "输出文件第一行必须包含两个整数 $n$ 与 $m$。$n$ 为图顶点数。顶点由 $1$ 到 $n$ 编号，$1$ 为首点编号，$n$ 为图尾点编号。其他点可随意编号。图中边由一个边不重路径集代表，$m$为该集合最小路径数。\n\n后 $m$ 行，每行必须包含图中一条路径。一条路径以一个整数 $k_{i} (k_{i} \\ge 2)$ 开始，后随 $k_{i}$ 个整数从 $1$ 到 $n$。这 $k_{i}$ 个整数代列表一条路径的顶点。一条路径可经过同一顶点多次，但每条边必须在整个输出文件中刚好经过一次。\n\n### 注释\n此题中出现的的EBNF：\n\n非终端符号为被定义的语言的句法部分。\n\n终端符号为由一个或多个字符组成的序列，是构成语言的不可约元素。\n\n本题中一条语法规则形如$元标识符=定义列表$\n\n定义列表形如$主要句法|主要句法|\\cdots$。\n\n其中主要句法为可选序列、重复序列、分组序列、元标识符、终端字符串、空序列之一。\n\n可选序列形如[定义列表]，重复序列形如{定义列表}，分组序列形如(定义列表)。\n\n元标识符是以字母开头的字母数字序列，即非终端符号的名称。\n\n由语法定义的语言的终端符号由终端字符串表示，终端字符串形如“一个或多个除该引号符号以外的任何终端字符的序列” 。\n\nEBNF的终端符号称为终端字符，是字母、数字, 与`=|{}“()[]`字符之一。\n\n需要注意的是，这里给出的EBNF不完整，但足以解决题目。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6988", "type": "P", "difficulty": 6, "samples": [["3000 6000 1600 0 3000\n", "50974.56\n"], ["3000 6000 1600 3441 4228\n", "40728.90\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Damage Assessment", "background": "", "description": "\n\nA tank car that transports gasoline via rail road has a shape of cylinder with two spherical caps at the sides. The cylinder has a diameter $\\(d\\)$ and a length $\\(l\\).$ The spherical caps have a radius $\\(r\\) (\\(2r\\) \\ge \\(d\\)).$ There was the rail road accident and the tank car had derailed. It now lies on the ground and some of the stored gasoline had flown out. The damage assessment must be performed. The location of the tank on the ground was established by measuring its tilt as the height difference $\\(t\\)$ from the bottom points of the cylinder on its left and right sides $(0 \\le \\(t\\) \\le \\(l\\)).$ The level of gasoline in the tank was established by measuring the height difference $\\(h\\)$ from the bottom point of the cylinder and the top level of gasoline. For the purpose of this problem, the top level of gasoline always intersects the cylinder part of the tank $(0 \\le \\(h\\) \\le \\(t + d \\sqrt{1 - (t/l)^2}).$\n\nYour task is to figure out how much gasoline was left in the tank.\n\n![](/upload/images2/dmaage.png)\n\n", "inputFormat": "\n\nThe input file consists of a single line with five integer numbers -- $\\(d\\), \\(l\\), \\(r\\), \\(t\\)$ and $\\(h\\),$ which represent the diameter and the length of the tank's cylinder part, the radius of its spherical caps, tilt and gasoline level measurements. They are all expressed in millimeters ($1$ millimeter $= 10^{−3}$ meters), they satisfy all constraints expressed in the problem statement and $\\(d\\), \\(l\\) \\ge 100 , \\(d\\), \\(l\\), \\(r\\) \\le 10 000$ .\n\n", "outputFormat": "\n\nWrite a single real number to the output file -- the volume of gasoline in the tank in liters ($1$ liter $= 10^{−3}$ cubic meters). The absolute error of the answer must not exceed $0$ . $1$ liters.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Damage Assessment", "background": "", "description": "\n\nA tank car that transports gasoline via rail road has a shape of cylinder with two spherical caps at the sides. The cylinder has a diameter $\\(d\\)$ and a length $\\(l\\).$ The spherical caps have a radius $\\(r\\) (\\(2r\\) \\ge \\(d\\)).$ There was the rail road accident and the tank car had derailed. It now lies on the ground and some of the stored gasoline had flown out. The damage assessment must be performed. The location of the tank on the ground was established by measuring its tilt as the height difference $\\(t\\)$ from the bottom points of the cylinder on its left and right sides $(0 \\le \\(t\\) \\le \\(l\\)).$ The level of gasoline in the tank was established by measuring the height difference $\\(h\\)$ from the bottom point of the cylinder and the top level of gasoline. For the purpose of this problem, the top level of gasoline always intersects the cylinder part of the tank $(0 \\le \\(h\\) \\le \\(t + d \\sqrt{1 - (t/l)^2}).$\n\nYour task is to figure out how much gasoline was left in the tank.\n\n![](/upload/images2/dmaage.png)\n\n", "inputFormat": "\n\nThe input file consists of a single line with five integer numbers -- $\\(d\\), \\(l\\), \\(r\\), \\(t\\)$ and $\\(h\\),$ which represent the diameter and the length of the tank's cylinder part, the radius of its spherical caps, tilt and gasoline level measurements. They are all expressed in millimeters ($1$ millimeter $= 10^{−3}$ meters), they satisfy all constraints expressed in the problem statement and $\\(d\\), \\(l\\) \\ge 100 , \\(d\\), \\(l\\), \\(r\\) \\le 10 000$ .\n\n", "outputFormat": "\n\nWrite a single real number to the output file -- the volume of gasoline in the tank in liters ($1$ liter $= 10^{−3}$ cubic meters). The absolute error of the answer must not exceed $0$ . $1$ liters.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Damage Assessment", "background": "", "description": "一个通过铁路运输汽油的罐车形状为两侧带有球形端盖的圆柱体。圆柱体的直径为 $d$，长度为 $l$。球形端盖的半径为 $r$（$2r \\ge d$）。发生了铁路事故，罐车脱轨，现在躺在地上，部分储存的汽油已经流出。需要进行损失评估。通过测量圆柱体左侧和右侧底部点的高度差 $t$ 来确定罐车在地上的位置（$0 \\le t \\le l$）。通过测量圆柱体底部点和汽油顶部水平面的高度差 $h$ 来确定罐内汽油的水平面。为了解决这个问题，汽油的顶部水平面总是与罐车的圆柱部分相交（$0 \\le h \\le t + d \\sqrt{1 - (t/l)^2}$）。\n\n你的任务是计算罐车中剩余的汽油量。\n\n![](/upload/images2/dmaage.png)", "inputFormat": "输入文件由一行组成，包含五个整数 $d, l, r, t$ 和 $h$，分别表示罐车圆柱部分的直径和长度、球形端盖的半径、倾斜度和汽油水平测量值。它们都以毫米为单位（$1$ 毫米 $= 10^{-3}$ 米），满足题目中表达的所有约束条件，并且 $d, l \\ge 100 , d, l, r \\le 10 000$。", "outputFormat": "输出文件中写一个实数，表示罐车中汽油的体积，以升为单位（$1$ 升 $= 10^{-3}$ 立方米）。答案的绝对误差不得超过 $0.1$ 升。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6989", "type": "P", "difficulty": 6, "samples": [["2\nR 1 1 2\nP 2 2 1\n", "2\nP 1 2 1\nS 1 1 1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["图论", "2014", "Special Judge", "模拟退火", "随机调整", "有限状态自动机", "随机化", "构造", "ICPC", "Ad-hoc", "NERC/NEERC"], "title": "[NEERC 2014] Epic Win!", "background": "", "description": "\n\nA game of rock-paper-scissors is played by two players who simultaneously show out their moves: Rock, Paper , or Scissors. If their moves are the same, it's a draw. Otherwise, Rock beats Scissors, Paper beats Rock, and Scissors beat Paper .\n\nThe described procedure can be repeated many times. In this problem, two Finite State Machines (FSMs) will compete in a series of rounds. (Formally speaking, by FSMs we mean Moore machines in this problem. )\n\nAn FSM for playing rock-paper-scissors has finitely many states. Each state is described by the following: what move the FSM will make in the upcoming round, and what will be the new state in case of its opponent playing Rock, Paper , and Scissors.\n\n![](/upload/images2/epic.png)\n\nFortunately, you know your opponent FSM -- the entire scheme except for one thing: you do not know the initial state of that FSM.\n\nYour task is to design your own FSM to fight the given one. Your FSM must beat the opponent in at least $99\\%$ of the first $1$ billion rounds. That's what we call an epic win!\n\n", "inputFormat": "\n\nThe input file contains a description of the opponent FSM in the following format.\n\nThe first line contains an integer $n (1 \\le n \\le 100)$ -- the number of states in the FSM. States are numbered from $1$ to $n$ . Each of the following $n$ lines contains a description of the state: a character $c_{i}$ denoting the move made by FSM and integers $r_{i}, p_{i}, s_{i}$ denoting the next state in case of seeing Rock, Paper, or Scissors respectively $(c_{i}$ can be `R`, `P`, or `S`; $1 \\le r_{i}, p_{i}, s_{i} \\le n$\n\n", "outputFormat": "\n\nWrite to the output the description of your FSM in the same format.\n\nThe initial state of your FSM is the first state.\n\nThe number of states may not exceed $50 000$ .\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Epic Win!", "background": "", "description": "\n\nA game of rock-paper-scissors is played by two players who simultaneously show out their moves: Rock, Paper , or Scissors. If their moves are the same, it's a draw. Otherwise, Rock beats Scissors, Paper beats Rock, and Scissors beat Paper .\n\nThe described procedure can be repeated many times. In this problem, two Finite State Machines (FSMs) will compete in a series of rounds. (Formally speaking, by FSMs we mean Moore machines in this problem. )\n\nAn FSM for playing rock-paper-scissors has finitely many states. Each state is described by the following: what move the FSM will make in the upcoming round, and what will be the new state in case of its opponent playing Rock, Paper , and Scissors.\n\n![](/upload/images2/epic.png)\n\nFortunately, you know your opponent FSM -- the entire scheme except for one thing: you do not know the initial state of that FSM.\n\nYour task is to design your own FSM to fight the given one. Your FSM must beat the opponent in at least $99\\%$ of the first $1$ billion rounds. That's what we call an epic win!\n\n", "inputFormat": "\n\nThe input file contains a description of the opponent FSM in the following format.\n\nThe first line contains an integer $n (1 \\le n \\le 100)$ -- the number of states in the FSM. States are numbered from $1$ to $n$ . Each of the following $n$ lines contains a description of the state: a character $c_{i}$ denoting the move made by FSM and integers $r_{i}, p_{i}, s_{i}$ denoting the next state in case of seeing Rock, Paper, or Scissors respectively $(c_{i}$ can be `R`, `P`, or `S`; $1 \\le r_{i}, p_{i}, s_{i} \\le n$\n\n", "outputFormat": "\n\nWrite to the output the description of your FSM in the same format.\n\nThe initial state of your FSM is the first state.\n\nThe number of states may not exceed $50 000$ .\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Epic Win!", "background": "", "description": "在游戏「石头、剪子、布」中，两名玩家分别同时出示自己的行动：*石头*、*剪子*、或*布*。如果两人的行动一致，则平局。否则*石头*打败*剪子*、*布*打败*石头*、*剪子*打败*布*。\n\n上述过程可以重复多次。在本题中，两台有限状态自动机（Finite State Machines，FSM）将游玩多轮「石头、剪子、布」（准确地说，本题中的 FSM 特指 Moore 状态机）。\n\n一台被设计用来游玩「石头、剪子、布」的 FSM 有着有限的状态。每个状态由以下信息描述：下一轮中本台自动机将会出示怎样的行动，以及当下一轮中对手出示了*石头*、*剪子*、或*布*时应该转移到的新状态。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j121iya3.png)\n\n幸运的是，你知道对手的 FSM：你知道它所有的结构，但唯独不知道它的初始状态。\n\n你的任务是设计一台你自己的 FSM 去和对手的进行对战。你的 FSM 必须在前十亿（${10}^9$）轮中打败对手至少 $99 \\%$ 轮。这就是所谓的史诗般的胜利（epic win）！\n\n\n对手的 FSM 持续出示*石头*或*布*（取决于初始状态）直到它接收到*剪子*：接收到*剪子*将导致它的行为改变。\n\n一种打败这样的 FSM 的方法是出示*布*。如果对手持续出示*石头*，只需继续出示*布*即可胜利。如果对手出示了*布*，通过出示一次*剪子*让它的行为改变，接下来它就会持续出示*石头*，然后你就可以用*布*打败它了。", "inputFormat": "从标准输入中读入对对手的 FSM 的描述，按如下格式：\n\n第一行一个正整数 $n$，表示 FSM 中的状态数。所有状态从 $1$ 到 $n$ 编号。\n\n接下来 $n$ 行，每行描述一个状态：一个字符 $c_i$ 以及三个正整数 $r_i, p_i, s_i$，分别表示该状态的行动、以及当对手出示了*石头*、*布*、或*剪子*后应该转移到的新状态的编号，其中 $c_i$ 只可能为 $\\{\\texttt{R}, \\texttt{P}, \\texttt{S}\\}$ 之一，如果为 $\\texttt{R}$ 则意味着行动为出示*石头*，如果为 $\\texttt{P}$ 则意味着行动为出示*布*，如果为 $\\texttt{S}$ 行动为出示*剪子*。", "outputFormat": "将你设计的 FSM 以相同格式输出到标准输出中。\n\n你的 FSM 的初始状态是 $1$ 号状态。\n\n你的 FSM 的状态数量不应超过 $50000$。\n\n**【样例解释】**", "hint": "对于全部数据，$1 \\le n \\le 100$，$c_i \\in \\{\\texttt{R}, \\texttt{P}, \\texttt{S}\\}$，$1 \\le r_i, p_i, s_i \\le n$。\n\n**翻译来源**：IOI 2021 集训队第一部分作业，PinkRabbit。", "locale": "zh-CN"}}}
{"pid": "P6990", "type": "P", "difficulty": 0, "samples": [["23 4 3 5 7 11\n3\neffde7\nc07902\n0800c1\n3 2 4 6\n", "2 0 2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Filter", "background": "", "description": "\n\nYou are working on a new high-performance database engine -- Instant Compression and Processing Codec $(ICPC).$ ICPC stores user activity records. Each user activity record has an integer user identifier. The records are stored in a number of data files. Each data file is compressed and can contain records from multiple users, however ICPC has to process queries that look for a specific subsets of users. In order to do so, there has to be a way to quickly determine which data files may contain records for a specific user before attempting to decompress them, which may be a long and CPU-consuming process.\n\nICPC uses an algorithm called Bloom Filter. The way it is implemented in ICPC is described below. For each ICPC database the following integer parameters are chosen:\n\n$m$ is the number of bits in the filter;\n\n$f$ is the number of hash functions in the filter;\n\n$a_{i}$ are the parameters for hash functions for $0 \\le i$\n\nA value of the bloom filter is computed for each data file. The data file's bloom filter is a vector of $m$ bits. A bit number $j (0 \\le j < m)$ is set to one if and only if there is a record in this data file for some user identifier $u_{k},$ such that for some hash function $i (0 \\le i < f)$ the following equality holds:\n\n$j = (u_{k} · a_{i})$ mod $m$ (1)\n\nYour task is to implement ICPC filtering logic. You are given filter parameters and values for a number of data files and a set of user identifiers. Your task is determine which data files may contain record with at least one user identifier from the specified set. A data file may contain a record with a user identifier $u_{k}$ if and only if for all $i (0 \\le i < f)$ all the bits $j$ given by equality (1) in its filter value are set to one.\n\n", "inputFormat": "\n\nThe first line of the input file contains filter parameters -- integer numbers $m , f$ , and $a_{i}$ for $0 \\le i < f (1 \\le m \\le 1000 , 1 \\le f \\le 100 , 1 \\le a_{i} < 2^{31}).$\n\nThe second line of the input file contains an integer $n$ -- the number of data files $(1 \\le n \\le 1000)$ . Each of the following $n$ lines contains bloom filter value of the corresponding file in hexadecimal form. Each value is represented by a string of $⌈m/4⌉$ hexadecimal digits (one of $0123456789abcdef).$ The first digit of the string represents bits $0-3$ of the value (stored in order from the least significant bit of a hexadecimal digit to the most significant bit), the second digit -- bits $4-7$ , the third -- $8-11$ , etc. When $m$ mod $4 ≠ 0$ , then the last hexadecimal digit represents the last $m$ mod $4$ bits of the value in its least significant bits.\n\nThe following line of the input file contains an integer $q$ -- the number of user identifiers in a query $(1 \\le q \\le 1000)$ , followed by $q$ integers $u_{k}$ -- the set of distinct user identifiers in the query $(1 \\le u_{k} < 2^{31}).$\n\n", "outputFormat": "\n\nWrite a line with the integer number $s$ to the output file -- the number of data files that may contain a record with at least one user identifier from the specified set, followed by $s$ numbers $d_{t} (0 \\le d_{t} < n)$ -- the $0-based$ numbers of the corresponding data files in ascending order.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Filter", "background": "", "description": "\n\nYou are working on a new high-performance database engine -- Instant Compression and Processing Codec $(ICPC).$ ICPC stores user activity records. Each user activity record has an integer user identifier. The records are stored in a number of data files. Each data file is compressed and can contain records from multiple users, however ICPC has to process queries that look for a specific subsets of users. In order to do so, there has to be a way to quickly determine which data files may contain records for a specific user before attempting to decompress them, which may be a long and CPU-consuming process.\n\nICPC uses an algorithm called Bloom Filter. The way it is implemented in ICPC is described below. For each ICPC database the following integer parameters are chosen:\n\n$m$ is the number of bits in the filter;\n\n$f$ is the number of hash functions in the filter;\n\n$a_{i}$ are the parameters for hash functions for $0 \\le i$\n\nA value of the bloom filter is computed for each data file. The data file's bloom filter is a vector of $m$ bits. A bit number $j (0 \\le j < m)$ is set to one if and only if there is a record in this data file for some user identifier $u_{k},$ such that for some hash function $i (0 \\le i < f)$ the following equality holds:\n\n$j = (u_{k} · a_{i})$ mod $m$ (1)\n\nYour task is to implement ICPC filtering logic. You are given filter parameters and values for a number of data files and a set of user identifiers. Your task is determine which data files may contain record with at least one user identifier from the specified set. A data file may contain a record with a user identifier $u_{k}$ if and only if for all $i (0 \\le i < f)$ all the bits $j$ given by equality (1) in its filter value are set to one.\n\n", "inputFormat": "\n\nThe first line of the input file contains filter parameters -- integer numbers $m , f$ , and $a_{i}$ for $0 \\le i < f (1 \\le m \\le 1000 , 1 \\le f \\le 100 , 1 \\le a_{i} < 2^{31}).$\n\nThe second line of the input file contains an integer $n$ -- the number of data files $(1 \\le n \\le 1000)$ . Each of the following $n$ lines contains bloom filter value of the corresponding file in hexadecimal form. Each value is represented by a string of $⌈m/4⌉$ hexadecimal digits (one of $0123456789abcdef).$ The first digit of the string represents bits $0-3$ of the value (stored in order from the least significant bit of a hexadecimal digit to the most significant bit), the second digit -- bits $4-7$ , the third -- $8-11$ , etc. When $m$ mod $4 ≠ 0$ , then the last hexadecimal digit represents the last $m$ mod $4$ bits of the value in its least significant bits.\n\nThe following line of the input file contains an integer $q$ -- the number of user identifiers in a query $(1 \\le q \\le 1000)$ , followed by $q$ integers $u_{k}$ -- the set of distinct user identifiers in the query $(1 \\le u_{k} < 2^{31}).$\n\n", "outputFormat": "\n\nWrite a line with the integer number $s$ to the output file -- the number of data files that may contain a record with at least one user identifier from the specified set, followed by $s$ numbers $d_{t} (0 \\le d_{t} < n)$ -- the $0-based$ numbers of the corresponding data files in ascending order.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Filter", "background": "", "description": "你正在开发一个新的高性能数据库引擎——即时压缩和处理编解码器（Instant Compression and Processing Codec，ICPC）。ICPC 存储用户活动记录。每条用户活动记录都有一个整数用户标识符。记录存储在多个数据文件中。每个数据文件都是压缩的，可以包含来自多个用户的记录，然而 ICPC 必须处理查询以查找特定的用户子集。为此，必须有一种方法可以快速确定哪些数据文件可能包含特定用户的记录，然后再尝试解压它们，因为这可能是一个耗时且消耗 CPU 的过程。\n\nICPC 使用一种称为布隆过滤器的算法。ICPC 中的实现方式如下所述。对于每个 ICPC 数据库，选择以下整数参数：\n\n$m$ 是过滤器中的位数；\n\n$f$ 是过滤器中的哈希函数数量；\n\n$a_{i}$ 是哈希函数的参数，$0 \\le i$。\n\n为每个数据文件计算布隆过滤器的值。数据文件的布隆过滤器是一个 $m$ 位的向量。只有当在该数据文件中存在某个用户标识符 $u_{k}$ 的记录时，位号 $j (0 \\le j < m)$ 才会被设置为 1，并且对于某个哈希函数 $i (0 \\le i < f)$，满足以下等式：\n\n$$j = (u_{k} \\cdot a_{i}) \\mod m$$ (1)\n\n你的任务是实现 ICPC 过滤逻辑。给定过滤器参数和若干数据文件的值以及一组用户标识符。你的任务是确定哪些数据文件可能包含指定集合中至少一个用户标识符的记录。只有当对于所有 $i (0 \\le i < f)$，其过滤器值中由等式 (1) 给出的所有位 $j$ 都被设置为 1 时，数据文件才可能包含用户标识符 $u_{k}$ 的记录。", "inputFormat": "输入文件的第一行包含过滤器参数——整数 $m, f$ 和 $a_{i}$，其中 $0 \\le i < f (1 \\le m \\le 1000, 1 \\le f \\le 100, 1 \\le a_{i} < 2^{31})$。\n\n输入文件的第二行包含一个整数 $n$——数据文件的数量 $(1 \\le n \\le 1000)$。接下来的 $n$ 行中的每一行包含相应文件的布隆过滤器值，以十六进制形式表示。每个值由一个 $\\lceil m/4 \\rceil$ 个十六进制数字的字符串表示（取值为 $0123456789abcdef$ 中的一个）。字符串的第一个数字表示值的位 $0-3$（按从十六进制数字的最低有效位到最高有效位的顺序存储），第二个数字表示位 $4-7$，第三个表示 $8-11$，等等。当 $m \\mod 4 \neq 0$ 时，最后一个十六进制数字表示值的最后 $m \\mod 4$ 位，以其最低有效位表示。\n\n输入文件的下一行包含一个整数 $q$——查询中的用户标识符数量 $(1 \\le q \\le 1000)$，后跟 $q$ 个整数 $u_{k}$——查询中的一组不同的用户标识符 $(1 \\le u_{k} < 2^{31})$。", "outputFormat": "在输出文件中写入一行，包含整数 $s$——可能包含指定集合中至少一个用户标识符的记录的数据文件数量，后跟 $s$ 个数字 $d_{t} (0 \\le d_{t} < n)$——对应数据文件的从 0 开始的编号，按升序排列。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6991", "type": "P", "difficulty": 6, "samples": [["10 10\n10 11\n10 12\n10 13\n9 10\n9 11\n9 9\n11 13\n-1 -1\n", "11 10\n11 11\n10 9\n10 14\n8 9\n11 9\n11 12\n11 8\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Gomoku", "background": "这是一道 IO 交互题。", "description": "\n\nThis is an interactive problem.\n\nGomoku is a two-player game on a two-dimensional grid. Each cell of the grid can be either empty, contain the first player's mark $(black),$ or contain the second player's mark $(white),$ but not both. Initially the entire grid is empty. Two players make alternating moves, starting with the first player. At each move, a player can put her mark into exactly one empty cell. The first player to have her five adjacent marks in a single row wins. The winning row can be either vertical, horizontal or diagonal.\n\n![](https://upload.acmicpc.net/23c94254-2783-405a-907b-7b66bea5514b/-/preview/)\n\nPosition where the second player (white marks) had won.\n\nThe players use a $19 \\times 19$ grid in this problem. If the entire grid gets filled with marks but no player has won, the game is declared a draw.\n\nThe first player uses the following strategy: as the first move, she puts her mark into the center cell of the grid. At every other move, she picks such a move that maximizes the score of the resulting position.\n\nIn order to find the score of a position, the first player considers all possible places where the winning combination might eventually form -- in other words, all horizonal, vertical and diagonal rows of five consecutive cells on the board (of course, they may overlap each other). If such a row contains both the first player's marks and the second player's marks, it is disregarded. If such a row contains no marks, it is disregarded as well. For each row with exactly $k (1 \\le k \\le 5)$ marks of the first player and no marks of the second player, add $50^{2k−1}$ to the score of the position. For each row with exactly $k$ marks of the second player and no marks of the first player, subtract $50^{2k}$ from the score of the position. Finally, add a random integer number between $0$ and $50^{2} − 1$ to the score. This random number is chosen uniformly.\n\nIn case when several moves of the first player have equal scores (such ties are quite rare because of the random addition mentioned above), the first player picks the one with the smallest x-coordinate, and in case of equal x-coordinates, the one with the smallest y-coordinate.\n\nYour task is to write a program that plays the second player and beats this strategy.\n\nYour program will play $100$ games against the strategy described above, with different seeds of random generator. Your program must win all these games.\n\n", "inputFormat": "\n\n", "outputFormat": "\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Gomoku", "background": "这是一道 IO 交互题。", "description": "\n\nThis is an interactive problem.\n\nGomoku is a two-player game on a two-dimensional grid. Each cell of the grid can be either empty, contain the first player's mark $(black),$ or contain the second player's mark $(white),$ but not both. Initially the entire grid is empty. Two players make alternating moves, starting with the first player. At each move, a player can put her mark into exactly one empty cell. The first player to have her five adjacent marks in a single row wins. The winning row can be either vertical, horizontal or diagonal.\n\n![](https://upload.acmicpc.net/23c94254-2783-405a-907b-7b66bea5514b/-/preview/)\n\nPosition where the second player (white marks) had won.\n\nThe players use a $19 \\times 19$ grid in this problem. If the entire grid gets filled with marks but no player has won, the game is declared a draw.\n\nThe first player uses the following strategy: as the first move, she puts her mark into the center cell of the grid. At every other move, she picks such a move that maximizes the score of the resulting position.\n\nIn order to find the score of a position, the first player considers all possible places where the winning combination might eventually form -- in other words, all horizonal, vertical and diagonal rows of five consecutive cells on the board (of course, they may overlap each other). If such a row contains both the first player's marks and the second player's marks, it is disregarded. If such a row contains no marks, it is disregarded as well. For each row with exactly $k (1 \\le k \\le 5)$ marks of the first player and no marks of the second player, add $50^{2k−1}$ to the score of the position. For each row with exactly $k$ marks of the second player and no marks of the first player, subtract $50^{2k}$ from the score of the position. Finally, add a random integer number between $0$ and $50^{2} − 1$ to the score. This random number is chosen uniformly.\n\nIn case when several moves of the first player have equal scores (such ties are quite rare because of the random addition mentioned above), the first player picks the one with the smallest x-coordinate, and in case of equal x-coordinates, the one with the smallest y-coordinate.\n\nYour task is to write a program that plays the second player and beats this strategy.\n\nYour program will play $100$ games against the strategy described above, with different seeds of random generator. Your program must win all these games.\n\n", "inputFormat": "\n\n", "outputFormat": "\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Gomoku", "background": "", "description": "这是一个交互式问题。\n\n五子棋是一种在二维网格上进行的双人游戏。网格的每个单元格可以是空的，包含第一位玩家的标记（黑色），或者包含第二位玩家的标记（白色），但不能同时包含两者。最初整个网格是空的。两位玩家轮流下棋，从第一位玩家开始。每次移动时，玩家可以在一个空单元格中放置她的标记。第一个在一行中有五个相邻标记的玩家获胜。获胜的行可以是垂直的、水平的或对角线的。\n\n![](https://upload.acmicpc.net/23c94254-2783-405a-907b-7b66bea5514b/-/preview/)\n\n第二位玩家（白色标记）获胜的位置。\n\n在这个问题中，玩家使用一个 $19 \\times 19$ 的网格。如果整个网格被标记填满但没有玩家获胜，游戏被判为平局。\n\n第一位玩家使用以下策略：作为第一次移动，她将她的标记放在网格的中心单元格。在每次其他移动中，她选择一个能最大化结果位置得分的移动。\n\n为了找到一个位置的得分，第一位玩家考虑所有可能最终形成获胜组合的位置——换句话说，棋盘上所有水平、垂直和对角线的五个连续单元格的行（当然，它们可能相互重叠）。如果这样的行同时包含第一位玩家和第二位玩家的标记，则不予考虑。如果这样的行不包含任何标记，也不予考虑。对于每个只包含第一位玩家的标记且没有第二位玩家标记的行，添加 $50^{2k-1}$ 到位置的得分，其中 $k$ 是第一位玩家的标记数量（$1 \\le k \\le 5$）。对于每个只包含第二位玩家的标记且没有第一位玩家标记的行，从位置的得分中减去 $50^{2k}$。最后，随机添加一个介于 $0$ 和 $50^{2} - 1$ 之间的整数到得分中。这个随机数是均匀选择的。\n\n在第一位玩家的几个移动得分相等的情况下（由于上述随机加法，这种平局很少见），第一位玩家选择 x 坐标最小的移动，如果 x 坐标相同，则选择 y 坐标最小的移动。\n\n你的任务是编写一个程序，扮演第二位玩家并击败这种策略。\n\n你的程序将与上述策略进行 100 场比赛，使用不同的随机生成器种子。你的程序必须赢得所有这些比赛。", "inputFormat": "", "outputFormat": "", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6992", "type": "P", "difficulty": 6, "samples": [["2\n2 1 1\n", "1\n"], ["5\n2 4 4\n1 2 5\n5 4 2\n5 3 3\n", "3.50\n"], ["5\n4 1 2\n5 3 2\n4 2 3\n5 4 7\n", "3.1666666667\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Hidden Maze", "background": "", "description": "\n\nHelen and Henry are fans of the TV show `Hidden Maze`, which is very popular in Hiddenland. During this show two participants (usually a married couple) are rushing through the maze consisting of $n$ halls connected by some tunnels. Each tunnel connects two different halls and there can't be more than one tunnel connecting any pair of halls.\n\nIn the beginning of the show, two participants are placed in two different halls. Then they need to move very quickly to meet each other before the time runs out. To pass through each tunnel, the participant needs to find a clue which is some positive integer number written on a small piece of paper.\n\nIf the participants finally meet in some tunnel before the time runs out, and successfully find a clue contained in the tunnel where they met, they are considered winners. The value of their prize is calculated by sorting all the clues found by them and taking the median value. The game is always set up in such a way, that the number of clues they find is odd.\n\nHelen and Henry saw a large number of episodes of the show, and now they understand a lot about the mechanics of it. They noticed that the maze doesn't change between episodes, and they drew a complete map of the maze. Shortly after, Helen and Henry have discovered that the maze is built in such a manner that if you visit any tunnel at most once, then there is exactly one path between any two halls.\n\nHelen and Henry have been wondering how this great maze is created, and not so long time ago they have seen an interview with Hillary, who worked for the company which had built the maze. Hillary has told that to make the show fair, the maze had been created using the following randomized algorithm:\n\nPick the number of halls $n$ . Build $n$ halls enumerated from $1$ to $n$ .\n\nChoose at random two integers $i$ and $j$ , each of them uniformly distributed between $1$ and $n$ .\n\nIf halls $i$ and $j$ are the same or are already connected with some path of tunnels, then go to step $2$ .\n\nBuild the tunnel between $i$ and $j$ . If there is a path of tunnels from any hall to any other one, stop the process, otherwise go to step $2$ .\n\nHelen and Henry have also noticed that each tunnel contains exactly one clue and its value never changes from episode to episode. However, they don't know what algorithm was used to generate clue values. Helen and Henry have written on their map the value of the clue for each tunnel.\n\nIt always takes $1$ minute to find a clue and to run through the tunnel from one hall to another. It takes half a minute to run from the hall to the center of the tunnel when the participants meet in the center of the tunnel at the end. The time given to participants is only enough to meet each other if they act optimally, that is they just run to each other via the shortest possible path, never make mistakes when finding clues, and never turn into any other tunnels that do not belong to the shortest path. To make the participants meet in the center of some tunnel, they are placed in the beginning of the show in such a way that the length of the shortest path between the halls where they are placed is odd.\n\nHelen and Henry want to participate in the show. They know the maze by heart and they are pretty sure that they will succeed in moving optimally to each other and finding all clues in time. Provided that the pair of initial halls is selected uniformly from all pairs with an odd-length shortest path between them, they need to know the expected value of the prize they win. Your task is to help them find this expected value.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer number $n (2 \\le n \\le 30 000)$ -- the number of halls. Each of the following $n − 1$ lines contains three integers: $u_{i}, v_{i}, c_{i} (1 \\le u_{i}, v_{i} \\le n , 1 \\le c_{i} \\le 10^{6}),$ describing the i-th tunnel connecting the halls $u_{i}$ and $v_{i},$ containing the clue with the value $c_{i}.$ The maze is always created by the randomized algorithm that is specified in the problem statement.\n\n", "outputFormat": "\n\nWrite to the output file a single real number -- the expected value of the prize. The absolute or relative error of the answer must not exceed $10^{−9}.$\n\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Hidden Maze", "background": "", "description": "\n\nHelen and Henry are fans of the TV show `Hidden Maze`, which is very popular in Hiddenland. During this show two participants (usually a married couple) are rushing through the maze consisting of $n$ halls connected by some tunnels. Each tunnel connects two different halls and there can't be more than one tunnel connecting any pair of halls.\n\nIn the beginning of the show, two participants are placed in two different halls. Then they need to move very quickly to meet each other before the time runs out. To pass through each tunnel, the participant needs to find a clue which is some positive integer number written on a small piece of paper.\n\nIf the participants finally meet in some tunnel before the time runs out, and successfully find a clue contained in the tunnel where they met, they are considered winners. The value of their prize is calculated by sorting all the clues found by them and taking the median value. The game is always set up in such a way, that the number of clues they find is odd.\n\nHelen and Henry saw a large number of episodes of the show, and now they understand a lot about the mechanics of it. They noticed that the maze doesn't change between episodes, and they drew a complete map of the maze. Shortly after, Helen and Henry have discovered that the maze is built in such a manner that if you visit any tunnel at most once, then there is exactly one path between any two halls.\n\nHelen and Henry have been wondering how this great maze is created, and not so long time ago they have seen an interview with Hillary, who worked for the company which had built the maze. Hillary has told that to make the show fair, the maze had been created using the following randomized algorithm:\n\nPick the number of halls $n$ . Build $n$ halls enumerated from $1$ to $n$ .\n\nChoose at random two integers $i$ and $j$ , each of them uniformly distributed between $1$ and $n$ .\n\nIf halls $i$ and $j$ are the same or are already connected with some path of tunnels, then go to step $2$ .\n\nBuild the tunnel between $i$ and $j$ . If there is a path of tunnels from any hall to any other one, stop the process, otherwise go to step $2$ .\n\nHelen and Henry have also noticed that each tunnel contains exactly one clue and its value never changes from episode to episode. However, they don't know what algorithm was used to generate clue values. Helen and Henry have written on their map the value of the clue for each tunnel.\n\nIt always takes $1$ minute to find a clue and to run through the tunnel from one hall to another. It takes half a minute to run from the hall to the center of the tunnel when the participants meet in the center of the tunnel at the end. The time given to participants is only enough to meet each other if they act optimally, that is they just run to each other via the shortest possible path, never make mistakes when finding clues, and never turn into any other tunnels that do not belong to the shortest path. To make the participants meet in the center of some tunnel, they are placed in the beginning of the show in such a way that the length of the shortest path between the halls where they are placed is odd.\n\nHelen and Henry want to participate in the show. They know the maze by heart and they are pretty sure that they will succeed in moving optimally to each other and finding all clues in time. Provided that the pair of initial halls is selected uniformly from all pairs with an odd-length shortest path between them, they need to know the expected value of the prize they win. Your task is to help them find this expected value.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer number $n (2 \\le n \\le 30 000)$ -- the number of halls. Each of the following $n − 1$ lines contains three integers: $u_{i}, v_{i}, c_{i} (1 \\le u_{i}, v_{i} \\le n , 1 \\le c_{i} \\le 10^{6}),$ describing the i-th tunnel connecting the halls $u_{i}$ and $v_{i},$ containing the clue with the value $c_{i}.$ The maze is always created by the randomized algorithm that is specified in the problem statement.\n\n", "outputFormat": "\n\nWrite to the output file a single real number -- the expected value of the prize. The absolute or relative error of the answer must not exceed $10^{−9}.$\n\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] 隐藏迷宫", "background": null, "description": "海伦和亨利是《隐藏迷宫》这档在 Hidden Land 超火的综艺节目的铁杆粉丝。节目里，两位选手（通常是一对夫妻）要在由 $n$ 个大厅组成的迷宫中飞速穿行，这些大厅通过若干条隧道相连。每条隧道连接两个不同的大厅，且任意一对大厅之间最多只有一条隧道。\n\n比赛一开始，两位选手分别被放置在两个不同的大厅里。然后，他们要争分夺秒地赶去见面，必须在时间耗尽前相遇。穿过每条隧道时，选手会找到一张写有正整数线索的小纸条。\n\n如果两人最终在某条隧道中相遇，并成功找到了该隧道上的线索，他们就算赢了。奖金的数额是将他们找到的所有线索排序后取中位数。游戏设计保证他们找到的线索数总是奇数。\n\n海伦和亨利看了无数集节目，渐渐摸清了游戏的套路。他们发现迷宫结构始终不变，还画出了完整地图。后来他们发现，这个迷宫设计得很巧妙：只要每条隧道最多走一次，任意两个大厅之间就只有一条唯一的路径。\n\n他们还听过一位名叫希拉里的工作人员讲过，这个迷宫是用下面的随机算法建造的：\n\n步骤 $1$：先确定大厅数目 $n$，建造 $n$ 个大厅，编号从 $1$ 到 $n$。\n\n步骤 $2$：随机选两个整数 $i$ 和 $j$，它们均匀分布在 $1$ 到 $n$ 之间。\n\n步骤 $3$：如果大厅 $i$ 和 $j$ 是同一个，或者它们之间已经有通路了，跳转到步骤 $2$。\n\n步骤 $4$：在大厅 $i$ 和 $j$ 之间建造一条隧道。如果此时任意两个大厅间都有通路了，结束；否则跳转到步骤 $2$。\n\n海伦和亨利还注意到，每条隧道上的线索数值固定不变，但他们不知道线索数值是如何生成的。他们把每条隧道对应的线索值都标在了地图上。\n\n穿过一条隧道并找到线索需要 $1$ 分钟，选手们从大厅跑到隧道中心相遇时需要半分钟。给定的时间刚好够他们以最优策略相遇——即走最短路径，不出错，且不绕路。为了让他们能在隧道中心相遇，比赛一开始两人被放在的两个大厅间的最短路径长度是奇数。\n\n海伦和亨利想参加节目，他们对迷宫了如指掌，确信自己能以最优策略完成任务。现在，假设初始两个大厅的选择是均匀随机的，且只选那些最短路径长度为奇数的大厅对。他们想知道自己赢得奖金的期望值是多少。请帮他们算出这个期望。", "inputFormat": "第一行输入一个整数 $n (2 \\le n \\le 30 000)$，表示大厅数。\n\n接下来 $n − 1$ 行，每行三个整数：$u_{i}, v_{i}, c_{i} (1 \\le u_{i}, v_{i} \\le n , 1 \\le c_{i} \\le 10^{6})$，表示第 $i$ 条隧道连接的两个大厅 $u_{i}$ 和 $v_{i}$，以及该隧道上的线索值 $c_{i}$。\n\n迷宫保证是题目中描述的随机算法生成的。", "outputFormat": "输出一个实数，表示奖金的期望值。答案的绝对或相对误差不得超过 $10^{−9}$。", "hint": "时间限制：3 秒，内存限制：256 MB。\n\n题面翻译由 GPT-4.1-mini 提供。", "locale": "zh-CN"}}}
{"pid": "P6993", "type": "P", "difficulty": 6, "samples": [["4\n1 3 2 4\n", "3\n"], ["4\n1 4 2 3\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Improvements", "background": "", "description": "\n\nSon Halo owns $n$ spaceships numbered from $1$ to $n$ and a space station. They are initially placed on one line with the space station so the spaceship $i$ is positioned $x_i$ meters from the station and all ships are on the same side from the station $(x_i > 0)$ . All $x_i$ are distinct. Station is considered to have number $0$ and $x_0$ is considered to be equal to $0$ .\n\nEvery two spaceships with consequent numbers are connected by a rope, and the first one is connected to the station. The rope number $i$ (for $1 \\le i \\le n)$ connects ships $i$ and $i-1.$ Note, that the rope number $1$ connects the first ship to the station.\n\nSon Halo considers that the rope $i$ and the rope $j$ intersect when the segments $[x_{i}^{min}, x_{i}^{max}]$ and $[x_{j}^{min}, x_{j}^{max}]$ have common internal point but neither one of them is completely contained in the other, where $x_{k}^{min} = \\min(x_{k−1}, x_k)$, $x_{k}^{max} = max(x_{k−1}, x_k).$ That is:\n\n$$\\begin{cases} x_{i}^{min} < x_{j}^{min} \\sim \\& \\sim x_{j}^{min} < x_{i}^{max} \\sim \\& \\sim x_{i}^{max} < x_{j}^{max} \\\\ x_{j}^{min} < x_{i}^{min} \\sim \\& \\sim x_{i}^{min} < x_{j}^{max} \\sim \\& \\sim x_{j}^{max} < x_{i}^{max}  \\end{cases}$$\n\nSon Halo wants to rearrange spaceships in such a way, that there are no rope intersections. Because he is lazy, he wants to rearrange the ships in such a way, that the total number of ships that remain at their original position $x_i$ is maximal. All the ships must stay on the same side of the station and at different positions $x_i$ after rearrangement. However, ships can occupy any real positions $x_i$ after rearrangement.\n\nYour task is to figure out what is the maximal number of ships that can remain at their initial positions.\n\n", "inputFormat": "\n\nThe first line of the input file contains $\\(n\\) (1 \\le \\(n\\) \\le 200 000)$ -- the number of ships. The following line contains $\\(n\\)$ distinct integers $\\(x_i\\) (1 \\le \\(x_i\\) \\le \\(n\\))$ -- the initial positions of the spaceships.\n\n", "outputFormat": "\n\nThe output file must contain one integer -- the maximal number of ships that can remain at their initial positions in the solution of this problem.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Improvements", "background": "", "description": "\n\nSon Halo owns $n$ spaceships numbered from $1$ to $n$ and a space station. They are initially placed on one line with the space station so the spaceship $i$ is positioned $x_i$ meters from the station and all ships are on the same side from the station $(x_i > 0)$ . All $x_i$ are distinct. Station is considered to have number $0$ and $x_0$ is considered to be equal to $0$ .\n\nEvery two spaceships with consequent numbers are connected by a rope, and the first one is connected to the station. The rope number $i$ (for $1 \\le i \\le n)$ connects ships $i$ and $i-1.$ Note, that the rope number $1$ connects the first ship to the station.\n\nSon Halo considers that the rope $i$ and the rope $j$ intersect when the segments $[x_{i}^{min}, x_{i}^{max}]$ and $[x_{j}^{min}, x_{j}^{max}]$ have common internal point but neither one of them is completely contained in the other, where $x_{k}^{min} = \\min(x_{k−1}, x_k)$, $x_{k}^{max} = max(x_{k−1}, x_k).$ That is:\n\n$$\\begin{cases} x_{i}^{min} < x_{j}^{min} \\sim \\& \\sim x_{j}^{min} < x_{i}^{max} \\sim \\& \\sim x_{i}^{max} < x_{j}^{max} \\\\ x_{j}^{min} < x_{i}^{min} \\sim \\& \\sim x_{i}^{min} < x_{j}^{max} \\sim \\& \\sim x_{j}^{max} < x_{i}^{max}  \\end{cases}$$\n\nSon Halo wants to rearrange spaceships in such a way, that there are no rope intersections. Because he is lazy, he wants to rearrange the ships in such a way, that the total number of ships that remain at their original position $x_i$ is maximal. All the ships must stay on the same side of the station and at different positions $x_i$ after rearrangement. However, ships can occupy any real positions $x_i$ after rearrangement.\n\nYour task is to figure out what is the maximal number of ships that can remain at their initial positions.\n\n", "inputFormat": "\n\nThe first line of the input file contains $\\(n\\) (1 \\le \\(n\\) \\le 200 000)$ -- the number of ships. The following line contains $\\(n\\)$ distinct integers $\\(x_i\\) (1 \\le \\(x_i\\) \\le \\(n\\))$ -- the initial positions of the spaceships.\n\n", "outputFormat": "\n\nThe output file must contain one integer -- the maximal number of ships that can remain at their initial positions in the solution of this problem.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Improvements", "background": "", "description": "Son Halo 拥有编号从 1 到 $n$ 的 $n$ 艘飞船和一个空间站。它们最初与空间站在一条直线上排列，因此飞船 $i$ 距离空间站 $x_i$ 米，并且所有飞船都在空间站的同一侧（$x_i > 0$）。所有 $x_i$ 都是不同的。空间站被认为是编号为 0，并且 $x_0$ 被认为等于 0。\n\n每两艘连续编号的飞船之间用绳子连接，第一艘飞船与空间站连接。编号为 $i$ 的绳子（对于 $1 \\le i \\le n$）连接飞船 $i$ 和 $i-1$。注意，编号为 1 的绳子连接第一艘飞船与空间站。\n\nSon Halo 认为绳子 $i$ 和绳子 $j$ 相交，当且仅当线段 $[x_{i}^{min}, x_{i}^{max}]$ 和 $[x_{j}^{min}, x_{j}^{max}]$ 有公共的内部点，但它们中的任何一个都不完全包含在另一个中，其中 $x_{k}^{min} = \\min(x_{k-1}, x_k)$，$x_{k}^{max} = \\max(x_{k-1}, x_k)$。即：\n\n$$\n\\begin{cases} \nx_{i}^{min} < x_{j}^{min} \\sim \\& \\sim x_{j}^{min} < x_{i}^{max} \\sim \\& \\sim x_{i}^{max} < x_{j}^{max} \\\\\nx_{j}^{min} < x_{i}^{min} \\sim \\& \\sim x_{i}^{min} < x_{j}^{max} \\sim \\& \\sim x_{j}^{max} < x_{i}^{max} \\ \n\\end{cases}\n$$\n\nSon Halo 想要重新排列飞船，使得没有绳子相交。因为他很懒，他希望以一种方式重新排列飞船，使得保持在原始位置 $x_i$ 的飞船总数最大化。所有飞船在重新排列后必须保持在空间站的同一侧，并且在不同的位置 $x_i$。然而，飞船在重新排列后可以占据任何实数位置 $x_i$。\n\n你的任务是找出可以保持在其初始位置的飞船的最大数量。", "inputFormat": "输入文件的第一行包含 $n$ $(1 \\le n \\le 200\\,000)$ —— 飞船的数量。接下来的行包含 $n$ 个不同的整数 $x_i$ $(1 \\le x_i \\le n)$ —— 飞船的初始位置。", "outputFormat": "输出文件必须包含一个整数 —— 在该问题的解决方案中可以保持在其初始位置的飞船的最大数量。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6994", "type": "P", "difficulty": 3, "samples": [["4111109876532\n", "4 1 11 10 9 8 7 6 5 3 2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Joke with permutation", "background": "", "description": "Joey had saved a permutation of integers from $1$ to $n$ in a text file. All the numbers were written as decimal numbers without leading spaces.\n\nThen Joe made a practical joke on her: he removed all the spaces in the file.\n\nHelp Joey to restore the original permutation after the Joe's joke! ", "inputFormat": "The input file contains a single line with a single string -- the Joey's permutation without spaces.\n\nThe Joey's permutation had at least $1$ and at most $50$ numbers. ", "outputFormat": "Write a line to the output file with the restored permutation. Don’t forget the spaces!\n\nIf there are several possible original permutations, write any one of them.", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\nThanks to checker provider:@[Arcturus1350\n](/user/57699).", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Joke with permutation", "background": "", "description": "Joey had saved a permutation of integers from $1$ to $n$ in a text file. All the numbers were written as decimal numbers without leading spaces.\n\nThen Joe made a practical joke on her: he removed all the spaces in the file.\n\nHelp Joey to restore the original permutation after the Joe's joke! ", "inputFormat": "The input file contains a single line with a single string -- the Joey's permutation without spaces.\n\nThe Joey's permutation had at least $1$ and at most $50$ numbers. ", "outputFormat": "Write a line to the output file with the restored permutation. Don’t forget the spaces!\n\nIf there are several possible original permutations, write any one of them.", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\nThanks to checker provider:@[Arcturus1350\n](/user/57699).", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Joke with permutation", "background": null, "description": "Joey 在一个文本文件中保存了一个从 $1$ 到 $n$ 的整数排列。所有的数字都以十进制数字的形式书写，没有前导空格。\n\n然后 Joe 开了个玩笑：他把文件中的所有空格都去掉了。\n\n帮助 Joey 恢复 Joe 玩笑后的原始排列！", "inputFormat": "输入文件包含一行，一个字符串——去掉空格后的 Joey 的排列。\n\nJoey 的排列至少有 $1$ 个，最多有 $50$ 个数。", "outputFormat": "在输出文件中写出恢复后的排列。不要忘记空格！\n\n如果有多个可能的原始排列，输出其中任意一个。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n感谢检查者提供者：@[Arcturus1350](\\/user\\/57699)。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6995", "type": "P", "difficulty": 2, "samples": [["5 5\n0 1\n0 2\n2 3\n3 5\n4 5\n0 5 0\n0 1 2\n0 2 1\n2 5 2\n2 5 3\n", "5\n1\n2\n4\n3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "ICPC", "NERC/NEERC"], "title": "[NEERC 2014] Knockout Racing", "background": "", "description": "\n\nThe races became more popular than ever at Pandora planet. But these races are quite unusual. There are $n$ cars participating in a race on the long straight track. Each car moves with a speed of $1$ meter per second. Track has coordinates in meters.\n\nThe car number $i$ moves between two points on the track with coordinates $a_{i}$ and $b_{i}$ starting at the second $0$ in the point $a_{i}.$ The car moves from $a_{i}$ to $b_{i},$ then from $b_{i}$ to $a_{i},$ then from $a_{i}$ to $b_{i}$ again, and so on.\n\nHandsome Mike wants to knock some cars out of the race using dynamite. Thus he has $m$ questions. The question number $j$ is: what is the number of cars in the coordinates between $x_{j}$ and $y_{j}$ inclusive after $t_{j}$ seconds from the start?\n\nYour task is to answer Mike's questions.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $m (1 \\le n , m \\le 1000)$ -- the number of cars in the race and the number of questions.\n\nEach of the following $n$ lines contains a description of the car: two integers $a_{i}$ and $b_{i} (0 \\le a_{i}, b_{i} \\le 10^{9}, a_{i} ≠ b_{i})$ -- the coordinates of the two points between which the car $i$ moves.\n\nEach of the following $m$ lines contains a description of the question: three integers $x_{j} , y_{j}$ , and $t_{j} (0 \\le x_{j} \\le y_{j} \\le 10^{9}, 0 \\le t_{j} \\le 10^{9})$ -- the coordinate range and the time for the question $j$ .\n\n", "outputFormat": "\n\nWrite $m$ lines to the output file. Each line must contain one integer -- the answer to the corresponding question in order they are given in the input file.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2014] Knockout Racing", "background": "", "description": "\n\nThe races became more popular than ever at Pandora planet. But these races are quite unusual. There are $n$ cars participating in a race on the long straight track. Each car moves with a speed of $1$ meter per second. Track has coordinates in meters.\n\nThe car number $i$ moves between two points on the track with coordinates $a_{i}$ and $b_{i}$ starting at the second $0$ in the point $a_{i}.$ The car moves from $a_{i}$ to $b_{i},$ then from $b_{i}$ to $a_{i},$ then from $a_{i}$ to $b_{i}$ again, and so on.\n\nHandsome Mike wants to knock some cars out of the race using dynamite. Thus he has $m$ questions. The question number $j$ is: what is the number of cars in the coordinates between $x_{j}$ and $y_{j}$ inclusive after $t_{j}$ seconds from the start?\n\nYour task is to answer Mike's questions.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $m (1 \\le n , m \\le 1000)$ -- the number of cars in the race and the number of questions.\n\nEach of the following $n$ lines contains a description of the car: two integers $a_{i}$ and $b_{i} (0 \\le a_{i}, b_{i} \\le 10^{9}, a_{i} ≠ b_{i})$ -- the coordinates of the two points between which the car $i$ moves.\n\nEach of the following $m$ lines contains a description of the question: three integers $x_{j} , y_{j}$ , and $t_{j} (0 \\le x_{j} \\le y_{j} \\le 10^{9}, 0 \\le t_{j} \\le 10^{9})$ -- the coordinate range and the time for the question $j$ .\n\n", "outputFormat": "\n\nWrite $m$ lines to the output file. Each line must contain one integer -- the answer to the corresponding question in order they are given in the input file.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2014] Knockout Racing", "background": "", "description": "在 Pandora 星球上，比赛比以往任何时候都更受欢迎。但这些比赛相当不寻常。有 $n$ 辆车在一条长直赛道上参加比赛。每辆车以每秒 1 米的速度移动。赛道的坐标以米为单位。\n\n第 $i$ 号车在赛道上两个坐标为 $a_{i}$ 和 $b_{i}$ 的点之间移动，起始于第 0 秒在点 $a_{i}$。车从 $a_{i}$ 移动到 $b_{i}$，然后从 $b_{i}$ 移动到 $a_{i}$，然后再从 $a_{i}$ 移动到 $b_{i}$，如此往复。\n\n英俊的 Mike 想用炸药将一些车淘汰出比赛。因此他有 $m$ 个问题。第 $j$ 个问题是：从开始到 $t_{j}$ 秒后，坐标在 $x_{j}$ 到 $y_{j}$ 之间（包括边界）的车的数量是多少？\n\n你的任务是回答 Mike 的问题。", "inputFormat": "输入文件的第一行包含两个整数 $n$ 和 $m$ $(1 \\le n , m \\le 1000)$ —— 比赛中的车的数量和问题的数量。\n\n接下来的 $n$ 行中的每一行包含一辆车的描述：两个整数 $a_{i}$ 和 $b_{i}$ $(0 \\le a_{i}, b_{i} \\le 10^{9}, a_{i} \neq b_{i})$ —— 车 $i$ 在其间移动的两个点的坐标。\n\n接下来的 $m$ 行中的每一行包含一个问题的描述：三个整数 $x_{j}$, $y_{j}$ 和 $t_{j}$ $(0 \\le x_{j} \\le y_{j} \\le 10^{9}, 0 \\le t_{j} \\le 10^{9})$ —— 问题 $j$ 的坐标范围和时间。", "outputFormat": "将 $m$ 行写入输出文件。每行必须包含一个整数 —— 按输入文件中给出的顺序对应问题的答案。", "hint": "时间限制：1 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6996", "type": "P", "difficulty": 5, "samples": [["4 4 3\n..........\n..........\n...AAAA...\n...AAAAAA.\n...A.AA...\n..........\n..........\n\n..........\n..........\n...BBBB...\n.....BB...\n...BBBB...\n....BB....\n.....B....\n\n..........\n..........\n...C..C...\n..CCC.C...\n...CCCC...\n..........\n..........\n\n..........\n....D.....\n...DDDD...\n...DDD....\n...DDDD...\n..........\n..........\n", "8 6\nAAAABBBB\nAAAAAABB\nADAABBBB\nDDDDCBBC\nDDDCCCBC\nDDDDCCCC\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] ASCII Puzzle", "background": "", "description": "\n\nFili and Floi play a puzzle game. Fili takes a rectangular piece of paper that is lined with a $W \\times H$ grid of square cells, cuts it into pieces on its grid lines, and carefully shuffles the pieces so that pieces do not rotate. Floi has to recombine the pieces back into the rectangle without rotating them.\n\nFili observes a number of constraints while cutting an original paper into pieces to make sure that the resulting puzzle is well-formed. First of all, Fili picks three integer numbers $w , h$ , and $n$ , so that an original rectangular paper has a width of $W = w_n$ cells and a height of $H = h_n$ cells. Here $w$ and $h$ are known to Floi, but $n , W$ , and $H$ are not. This way, the original rectangular piece of paper can be cut into a trivial puzzle of $k = n^{2}$ rectangles with a width of $w$ cells and a height of $h$ cells each. However, this trivial puzzle for $k > 1$ is not considered a well-formed puzzle for this game. Instead, the pieces int which the original rectangle is cut are based on these trivial $w \\times h$ cell rectangles with the jagged edges between the adjacent pieces. Formally, the pieces into which the original $W \\times H$ paper is cut satisfy the following constraints of a well-formed puzzle:\n\nThere are $k = n^{2}$ pieces.\n\nEach piece is a simple $4-connected$ region of cells without holes.\n\nEach cell of the original rectangular $W \\times H$ paper is a part of exactly one piece.\n\nEach piece contains four corners of the corresponding $w \\times h$ rectangle in the trivial puzzle for the original paper.\n\nThe cells of each piece can come only from the corresponding $w \\times h$ rectangle in the trivial puzzle, from the cells adjacent to this rectangle, and from the interior cells of the adjacent rectangles in the trivial puzzle.\n\nThe cut between two adjacent pieces cannot be straight. Only pieces that lie on the border of the original $W \\times H$ paper have straight sides.\n\nThe corollary of these constraints is that each piece of a well-formed puzzle fits into a rectangle of (3w $− 2) \\times $ (3h $− 2)$ cells. Moreover, the description of each piece will be given as a (3w $− 2) \\times $ (3h $− 2)$ grid of cells in such a way, that the corresponding $w \\times h$ rectangle of the trivial puzzle is exactly in the center.\n\nThe picture below to the left shows a sample rectangular piece of paper that is lined with a $W \\times H = 12 \\times 9$ square grid of cells and is cut into a trivial puzzle of $k = 9$ rectangles with a width of $w = 4$ cells and a height of $h = 3$ cells each with bold dashed lines. The corners of the central $3 \\times 4$ piece of this trivial puzzle are shown in black. They have to be a part of the central piece of any well-formed puzzle. The other potential cells of the central piece of a well-formed puzzle are shown in gray. The bold black line shows (3w $− 2) \\times $ (3h $− 2) = 10 \\times 7$ rectangular region that will be describing this central piece. The picture to the right shows the same for the piece in the upper-right corner of the puzzle.\n\n![](/upload/images2/neerc_a.png)\n\nYour task is to help Floi solve the puzzle.\n\n", "inputFormat": "\n\nThe first line of the input file contains there integers $k , w$ and $h$ . Here $k$ is the number of pieces in the puzzle, $w$ is a width and $h$ is a height of a trivial puzzle piece $(k = n^{2}$ for $1 \\le n \\le 4 , 3 \\le w , h \\le 5)$ . The rest of the input file contains descriptions of $k$ pieces of a well-formed puzzle. Each piece is described by 3h $− 2$ lines that contain 3w $− 2$ characters each. Pieces are labeled with a consecutive English letters in uppercase (1st piece -- $‘A', 2nd$ piece -- $‘B',$ and etc). Each piece description uses only two characters on its 3h $− 2$ lines of 3w $− 2$ characters. The English letter corresponding to the piece denotes a cell that is a part of this piece, while $‘. '$ (dot) character denotes a cell that is not.\n\nEmpty lines separate different pieces.\n\n", "outputFormat": "\n\nThe first line of the output file shall contain $W$ and $H$ -- the size of the original piece of paper that was cut into the puzzle pieces. The following $H$ lines shall contain $W$ English letters each, describing the solution of the puzzle. Letters denote the cells that belong to the corresponding puzzle pieces. If there are multiple ways to solve the puzzle, then print any solution.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] ASCII Puzzle", "background": "", "description": "\n\nFili and Floi play a puzzle game. Fili takes a rectangular piece of paper that is lined with a $W \\times H$ grid of square cells, cuts it into pieces on its grid lines, and carefully shuffles the pieces so that pieces do not rotate. Floi has to recombine the pieces back into the rectangle without rotating them.\n\nFili observes a number of constraints while cutting an original paper into pieces to make sure that the resulting puzzle is well-formed. First of all, Fili picks three integer numbers $w , h$ , and $n$ , so that an original rectangular paper has a width of $W = w_n$ cells and a height of $H = h_n$ cells. Here $w$ and $h$ are known to Floi, but $n , W$ , and $H$ are not. This way, the original rectangular piece of paper can be cut into a trivial puzzle of $k = n^{2}$ rectangles with a width of $w$ cells and a height of $h$ cells each. However, this trivial puzzle for $k > 1$ is not considered a well-formed puzzle for this game. Instead, the pieces int which the original rectangle is cut are based on these trivial $w \\times h$ cell rectangles with the jagged edges between the adjacent pieces. Formally, the pieces into which the original $W \\times H$ paper is cut satisfy the following constraints of a well-formed puzzle:\n\nThere are $k = n^{2}$ pieces.\n\nEach piece is a simple $4-connected$ region of cells without holes.\n\nEach cell of the original rectangular $W \\times H$ paper is a part of exactly one piece.\n\nEach piece contains four corners of the corresponding $w \\times h$ rectangle in the trivial puzzle for the original paper.\n\nThe cells of each piece can come only from the corresponding $w \\times h$ rectangle in the trivial puzzle, from the cells adjacent to this rectangle, and from the interior cells of the adjacent rectangles in the trivial puzzle.\n\nThe cut between two adjacent pieces cannot be straight. Only pieces that lie on the border of the original $W \\times H$ paper have straight sides.\n\nThe corollary of these constraints is that each piece of a well-formed puzzle fits into a rectangle of (3w $− 2) \\times $ (3h $− 2)$ cells. Moreover, the description of each piece will be given as a (3w $− 2) \\times $ (3h $− 2)$ grid of cells in such a way, that the corresponding $w \\times h$ rectangle of the trivial puzzle is exactly in the center.\n\nThe picture below to the left shows a sample rectangular piece of paper that is lined with a $W \\times H = 12 \\times 9$ square grid of cells and is cut into a trivial puzzle of $k = 9$ rectangles with a width of $w = 4$ cells and a height of $h = 3$ cells each with bold dashed lines. The corners of the central $3 \\times 4$ piece of this trivial puzzle are shown in black. They have to be a part of the central piece of any well-formed puzzle. The other potential cells of the central piece of a well-formed puzzle are shown in gray. The bold black line shows (3w $− 2) \\times $ (3h $− 2) = 10 \\times 7$ rectangular region that will be describing this central piece. The picture to the right shows the same for the piece in the upper-right corner of the puzzle.\n\n![](/upload/images2/neerc_a.png)\n\nYour task is to help Floi solve the puzzle.\n\n", "inputFormat": "\n\nThe first line of the input file contains there integers $k , w$ and $h$ . Here $k$ is the number of pieces in the puzzle, $w$ is a width and $h$ is a height of a trivial puzzle piece $(k = n^{2}$ for $1 \\le n \\le 4 , 3 \\le w , h \\le 5)$ . The rest of the input file contains descriptions of $k$ pieces of a well-formed puzzle. Each piece is described by 3h $− 2$ lines that contain 3w $− 2$ characters each. Pieces are labeled with a consecutive English letters in uppercase (1st piece -- $‘A', 2nd$ piece -- $‘B',$ and etc). Each piece description uses only two characters on its 3h $− 2$ lines of 3w $− 2$ characters. The English letter corresponding to the piece denotes a cell that is a part of this piece, while $‘. '$ (dot) character denotes a cell that is not.\n\nEmpty lines separate different pieces.\n\n", "outputFormat": "\n\nThe first line of the output file shall contain $W$ and $H$ -- the size of the original piece of paper that was cut into the puzzle pieces. The following $H$ lines shall contain $W$ English letters each, describing the solution of the puzzle. Letters denote the cells that belong to the corresponding puzzle pieces. If there are multiple ways to solve the puzzle, then print any solution.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] ASCII Puzzle", "background": "", "description": "Fili 和 Floi 玩一个拼图游戏。Fili 拿出一张用 $W \\times H$ 网格线划分的矩形纸，在网格线上将其切成若干块，并小心地将这些块打乱，但不旋转。Floi 必须在不旋转的情况下将这些块重新组合成矩形。\n\nFili 在将原始纸张切成块时遵循了一些约束，以确保生成的拼图是合理的。首先，Fili 选择三个整数 $w, h$ 和 $n$，使得原始矩形纸的宽度为 $W = w_n$ 个单元格，高度为 $H = h_n$ 个单元格。这里 $w$ 和 $h$ 是 Floi 已知的，但 $n, W$ 和 $H$ 是未知的。这样，原始矩形纸可以被切割成一个简单的 $k = n^{2}$ 个矩形拼图，每个矩形的宽度为 $w$ 个单元格，高度为 $h$ 个单元格。然而，对于 $k > 1$ 的简单拼图不被认为是这个游戏的合理拼图。相反，原始矩形被切割成的块是基于这些简单的 $w \\times h$ 单元格矩形，并在相邻块之间有锯齿边缘。正式地说，原始 $W \\times H$ 纸张被切割成的块满足以下合理拼图的约束：\n\n有 $k = n^{2}$ 个块。\n\n每个块是一个简单的 $4$ 连通的无孔单元格区域。\n\n原始矩形 $W \\times H$ 纸张的每个单元格恰好属于一个块。\n\n每个块包含原始纸张简单拼图中对应 $w \\times h$ 矩形的四个角。\n\n每个块的单元格只能来自简单拼图中对应的 $w \\times h$ 矩形、与该矩形相邻的单元格以及简单拼图中相邻矩形的内部单元格。\n\n两个相邻块之间的切割不能是直的。只有位于原始 $W \\times H$ 纸张边界上的块才有直边。\n\n这些约束的推论是，每个合理拼图的块都适合一个 $(3w - 2) \\times (3h - 2)$ 单元格的矩形。此外，每个块的描述将以 $(3w - 2) \\times (3h - 2)$ 的单元格网格给出，使得简单拼图中对应的 $w \\times h$ 矩形正好位于中心。\n\n下图左侧显示了一张样例矩形纸，用 $W \\times H = 12 \\times 9$ 的方格网格划分，并用粗虚线切割成一个简单拼图，包含 $k = 9$ 个宽度为 $w = 4$ 个单元格，高度为 $h = 3$ 个单元格的矩形。这个简单拼图的中央 $3 \\times 4$ 块的角用黑色显示。它们必须是任何合理拼图的中央块的一部分。合理拼图中央块的其他潜在单元格用灰色显示。粗黑线显示了 $(3w - 2) \\times (3h - 2) = 10 \\times 7$ 的矩形区域，将描述这个中央块。右图显示了拼图右上角块的相同情况。\n\n![](/upload/images2/neerc_a.png)\n\n你的任务是帮助 Floi 解决这个拼图。", "inputFormat": "输入文件的第一行包含三个整数 $k, w$ 和 $h$。这里 $k$ 是拼图中的块数，$w$ 是简单拼图块的宽度，$h$ 是高度（$k = n^{2}$ 且 $1 \\le n \\le 4, 3 \\le w, h \\le 5$）。输入文件的其余部分包含 $k$ 个合理拼图块的描述。每个块由 $3h - 2$ 行描述，每行包含 $3w - 2$ 个字符。块用连续的大写英文字母标记（第一个块为 'A'，第二个块为 'B'，等等）。每个块描述在其 $3h - 2$ 行中仅使用两个字符。与块对应的英文字母表示属于该块的单元格，而 '.'（点）字符表示不属于的单元格。\n\n空行分隔不同的块。", "outputFormat": "输出文件的第一行应包含 $W$ 和 $H$——被切割成拼图块的原始纸张的大小。接下来的 $H$ 行应包含 $W$ 个英文字母，描述拼图的解决方案。字母表示属于相应拼图块的单元格。如果有多种方法可以解决拼图，则输出任意一个解决方案。", "hint": "时间限制：1 秒，内存限制：128 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6997", "type": "P", "difficulty": 4, "samples": [["1 1 2\n", "0.3333333333333333\n0.2\n"], ["10 10 10\n", "0.5870875690480144\n0.3640355515319861\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Bonus Cards", "background": "", "description": "\n\nDmitry loves programming competitions very much. The Finals of the famed Champions League are taking place in Dmitry's home city, so he wants to visit the competition. The competition is very popular, but most tickets to the competition are reserved for VIPs and for sponsors.\n\nFor the general public tickets to the Champions League Finals are distributed in the following way. Spectators, that want to see the competition, submit their request that states the payment method they want to use to pay for their ticket. Suppose there are $n$ seats available. Several draw round are conducted. In each round every request that is not yet fulfilled receives some number of slots depending on the payment method. Then one of those slots is selected uniformly at random. The request to which this slot belongs is considered fulfilled and does not take part in subsequent drawing rounds. Draw ends after $n$ rounds or when there are no more unfulfilled requests, whichever occurs first. An International Card Processing Corporation (ICPC) is a sponsor of the Champions League. Those who chose ICPC card as a payment method receive two slots in each draw round, while users of other payment methods receive only one.\n\nDmitry has a card from ICPC, but he also has a card from Advanced Credit Merchandise $(ACM),$ which offers him a bonus on all his spendings. His brother Petr works in a company that conducts draw to distribute tickets, so he told Dmitry in advance how many people had already decided to use ICPC card and how many had decided to use other methods. Now Dmitry want to know the probabilities he would get a ticket if he would use his ICPC card or if he would use his ACM card, so that he can make an informed choice. His request is going to be in addition to the number of requests Petr had told him about.\n\nCan you help?\n\n", "inputFormat": "\n\nThe first and the only line of the input contains $3$ integer numbers -- the number of seats available for a draw $n (1 \\le n \\le 3000)$ , the number of requests with ICPC card as a payment method a , and the number of requests with other payment methods $b (0 \\le $ a , $b \\le 10^{9}).$\n\n", "outputFormat": "\n\nOn the first line output the probability of getting a ticket using ICPC card. On the second line output the probability of getting a ticket using ACM card. Answers should have an absolute error of no more than $10^{-9}.$\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Bonus Cards", "background": "", "description": "\n\nDmitry loves programming competitions very much. The Finals of the famed Champions League are taking place in Dmitry's home city, so he wants to visit the competition. The competition is very popular, but most tickets to the competition are reserved for VIPs and for sponsors.\n\nFor the general public tickets to the Champions League Finals are distributed in the following way. Spectators, that want to see the competition, submit their request that states the payment method they want to use to pay for their ticket. Suppose there are $n$ seats available. Several draw round are conducted. In each round every request that is not yet fulfilled receives some number of slots depending on the payment method. Then one of those slots is selected uniformly at random. The request to which this slot belongs is considered fulfilled and does not take part in subsequent drawing rounds. Draw ends after $n$ rounds or when there are no more unfulfilled requests, whichever occurs first. An International Card Processing Corporation (ICPC) is a sponsor of the Champions League. Those who chose ICPC card as a payment method receive two slots in each draw round, while users of other payment methods receive only one.\n\nDmitry has a card from ICPC, but he also has a card from Advanced Credit Merchandise $(ACM),$ which offers him a bonus on all his spendings. His brother Petr works in a company that conducts draw to distribute tickets, so he told Dmitry in advance how many people had already decided to use ICPC card and how many had decided to use other methods. Now Dmitry want to know the probabilities he would get a ticket if he would use his ICPC card or if he would use his ACM card, so that he can make an informed choice. His request is going to be in addition to the number of requests Petr had told him about.\n\nCan you help?\n\n", "inputFormat": "\n\nThe first and the only line of the input contains $3$ integer numbers -- the number of seats available for a draw $n (1 \\le n \\le 3000)$ , the number of requests with ICPC card as a payment method a , and the number of requests with other payment methods $b (0 \\le $ a , $b \\le 10^{9}).$\n\n", "outputFormat": "\n\nOn the first line output the probability of getting a ticket using ICPC card. On the second line output the probability of getting a ticket using ACM card. Answers should have an absolute error of no more than $10^{-9}.$\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Bonus Cards", "background": "", "description": "德米特里非常喜欢编程比赛。著名的冠军联赛决赛正在德米特里的家乡城市举行，所以他想去观看比赛。比赛非常受欢迎，但大多数门票都保留给 VIP 和赞助商。  \n\n对于普通公众，冠军联赛决赛的门票以以下方式分发。希望观看比赛的观众提交他们的请求，说明他们希望用哪种支付方式来支付门票。假设有 $n$ 个可用座位。进行若干轮抽签。在每一轮中，每个尚未满足的请求根据支付方式获得一定数量的抽签机会。然后从这些机会中随机选择一个。该机会所属的请求被视为已满足，并不再参与后续的抽签轮次。抽签在 $n$ 轮后或没有未满足请求时结束，以先发生者为准。国际卡处理公司（ICPC）是冠军联赛的赞助商。选择 ICPC 卡作为支付方式的人在每轮抽签中获得两个机会，而使用其他支付方式的用户仅获得一个。  \n\n德米特里有一张 ICPC 的卡，但他也有一张高级信用商品（ACM）的卡，该卡为他的所有消费提供奖金。他的兄弟 Petr 在负责分发门票的公司工作，所以他提前告诉德米特里已经有多少人决定使用 ICPC 卡以及多少人决定使用其他方法。现在德米特里想知道如果他使用 ICPC 卡或 ACM 卡，获得门票的概率是多少，以便做出明智的选择。他的请求将是 Petr 告诉他的请求数量的附加。  \n\n你能帮忙吗？", "inputFormat": "输入的第一行也是唯一一行包含 3 个整数——可用于抽签的座位数 $n (1 \\le n \\le 3000)$，使用 ICPC 卡作为支付方式的请求数 $a$，以及使用其他支付方式的请求数 $b (0 \\le a, b \\le 10^{9})$。", "outputFormat": "第一行输出使用 ICPC 卡获得门票的概率。第二行输出使用 ACM 卡获得门票的概率。答案的绝对误差不超过 $10^{-9}$。", "hint": "时间限制：1 秒，内存限制：128 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6998", "type": "P", "difficulty": 6, "samples": [["15 3\n9 1 2 3 4 5 6 7 8 3\n7 2 9 10 11 12 13 10\n5 2 14 9 15 10\n", "1\n2 2\n"], ["2 1\n2 1 2\n", "1\n2 1\n"], ["15 7\n3 1 2 3\n3 4 2 5\n3 6 2 7\n3 8 2 9\n3 10 2 11\n3 12 2 13\n3 14 2 15\n", "6\n2 11\n3 5\n5 2\n7 2\n11 1\n13 1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Cactus Automorphisms", "background": "", "description": "\n\nNEERC had featured a number of problems in previous years about cactuses -- connected undirected graphs in which every edge belongs to at most one simple cycle. Intuitively, cactus is a generalization of a tree where some cycles are allowed.\n\nIn $2005$ , the first year where problems about cactuses had appeared, the problem was called simply `Cactus`. In $2007$ it was `Cactus Reloaded` and in $2010$ it was called `Cactus Revolution`. An example of cactus from NEERC $2007$ problem is given on the picture below.\n\n![](/upload/images2/cac.png)\n\nThe challenge that judges face when preparing test cases for those problems is that some wrong solutions may depend on the numbering of vertices in the input file. So, for the most interesting test cases judges typically include several inputs with the same graph, but having a different numbering of vertices. However, some graphs are so regular that the graph remains the same even if you renumber its vertices. Judges need some metric about the graph that tells how regular the given graph is in order to make an objective decision about the number of test cases that need to be created for this graph.\n\nThe metric you have to compute is the number of graph automorphisms. Given an undirected graph $(V , E)$ , where $V$ is a set of vertices and $E$ is a set of edges, where each edge is a set of two distinct vertices ${v_{1}, v_{2}} (v_{1}, v_{2} ∈ V ),$ graph automorphism is a bijection $m$ from $V$ onto $V$ , such that for each pair of vertices $v_{1}$ and $v_{2}$ that are connected by an edge (so ${v_{1}, v_{2}} ∈ E)$ the following condition holds: ${m(v_{1}), m(v_{2})} ∈ E$ .\n\nEach graph has at least one automorphism (one where $m$ is an identity function) and may have up to $n$ ! automorphisms for a graph with $n$ vertices. Because the number of automorphisms may be a very big number, the answer must be presented as a prime factorization $∏^{k}_{i=1} p_{i}^{q_{i}},$ where $p_{i}$ are prime numbers in ascending order $(p_{i} \\ge 2 , p_{i} 0)$ .\n\n", "inputFormat": "\n\nThe first line of the input file contains two integer numbers $n$ and $m (1 \\le n \\le 50 000 , 0 \\le m \\le 50 000)$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ . Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths.\n\nEach of the following $m$ lines contains a path in the graph. A path starts with an integer number $k_{i} (2 \\le k_{i} \\le 1000)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. Adjacent vertices in a path are distinct. Path can go to the same vertex multiple times, but every edge is traversed exactly once in the whole input file. There are no multiedges in the graph (there is at most one edge between any two vertices).\n\nThe graph in the input file is a cactus.\n\n", "outputFormat": "\n\nOn the first line of the output file write number $k$ -- the number of prime factors in the factorization of the number of graph automorphisms. Write $0$ if the number of graph automorphisms is $1$ . On the following $k$ lines write prime numbers $p_{i}$ and their powers $q_i$ separated by a space. Prime numbers must be given in ascending order.\n\n", "hint": "Time limit: 5 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Cactus Automorphisms", "background": "", "description": "\n\nNEERC had featured a number of problems in previous years about cactuses -- connected undirected graphs in which every edge belongs to at most one simple cycle. Intuitively, cactus is a generalization of a tree where some cycles are allowed.\n\nIn $2005$ , the first year where problems about cactuses had appeared, the problem was called simply `Cactus`. In $2007$ it was `Cactus Reloaded` and in $2010$ it was called `Cactus Revolution`. An example of cactus from NEERC $2007$ problem is given on the picture below.\n\n![](/upload/images2/cac.png)\n\nThe challenge that judges face when preparing test cases for those problems is that some wrong solutions may depend on the numbering of vertices in the input file. So, for the most interesting test cases judges typically include several inputs with the same graph, but having a different numbering of vertices. However, some graphs are so regular that the graph remains the same even if you renumber its vertices. Judges need some metric about the graph that tells how regular the given graph is in order to make an objective decision about the number of test cases that need to be created for this graph.\n\nThe metric you have to compute is the number of graph automorphisms. Given an undirected graph $(V , E)$ , where $V$ is a set of vertices and $E$ is a set of edges, where each edge is a set of two distinct vertices ${v_{1}, v_{2}} (v_{1}, v_{2} ∈ V ),$ graph automorphism is a bijection $m$ from $V$ onto $V$ , such that for each pair of vertices $v_{1}$ and $v_{2}$ that are connected by an edge (so ${v_{1}, v_{2}} ∈ E)$ the following condition holds: ${m(v_{1}), m(v_{2})} ∈ E$ .\n\nEach graph has at least one automorphism (one where $m$ is an identity function) and may have up to $n$ ! automorphisms for a graph with $n$ vertices. Because the number of automorphisms may be a very big number, the answer must be presented as a prime factorization $∏^{k}_{i=1} p_{i}^{q_{i}},$ where $p_{i}$ are prime numbers in ascending order $(p_{i} \\ge 2 , p_{i} 0)$ .\n\n", "inputFormat": "\n\nThe first line of the input file contains two integer numbers $n$ and $m (1 \\le n \\le 50 000 , 0 \\le m \\le 50 000)$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ . Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths.\n\nEach of the following $m$ lines contains a path in the graph. A path starts with an integer number $k_{i} (2 \\le k_{i} \\le 1000)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. Adjacent vertices in a path are distinct. Path can go to the same vertex multiple times, but every edge is traversed exactly once in the whole input file. There are no multiedges in the graph (there is at most one edge between any two vertices).\n\nThe graph in the input file is a cactus.\n\n", "outputFormat": "\n\nOn the first line of the output file write number $k$ -- the number of prime factors in the factorization of the number of graph automorphisms. Write $0$ if the number of graph automorphisms is $1$ . On the following $k$ lines write prime numbers $p_{i}$ and their powers $q_i$ separated by a space. Prime numbers must be given in ascending order.\n\n", "hint": "Time limit: 5 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Cactus Automorphisms", "background": "", "description": "NEERC 在前几年中曾出现过一些关于仙人掌图的问题——仙人掌图是一个连通的无向图，其中每条边最多属于一个简单环。从直观上看，仙人掌图是树的一种推广，其中允许存在一些环。\n\n在 2005 年，首次出现关于仙人掌图的问题时，问题被简单地称为“Cactus”。在 2007 年，它被称为“Cactus Reloaded”，而在 2010 年，它被称为“Cactus Revolution”。下图展示了 NEERC 2007 年问题中的一个仙人掌图示例。\n\n![](/upload/images2/cac.png)\n\n在为这些问题准备测试用例时，评委面临的挑战是，一些错误的解决方案可能依赖于输入文件中顶点的编号。因此，对于最有趣的测试用例，评委通常会包含几个具有相同图但顶点编号不同的输入。然而，有些图是如此规则，以至于即使重新编号其顶点，图仍保持不变。评委需要一些关于图的度量来判断给定图的规则性，以便对需要为该图创建的测试用例数量做出客观决定。\n\n你需要计算的度量是图的自同构数量。给定一个无向图 $(V , E)$，其中 $V$ 是顶点集，$E$ 是边集，每条边是由两个不同顶点组成的集合 $\\{v_{1}, v_{2}\\} (v_{1}, v_{2} \\in V)$，图的自同构是一个从 $V$ 到 $V$ 的双射 $m$，使得对于每对由边连接的顶点 $v_{1}$ 和 $v_{2}$（即 $\\{v_{1}, v_{2}\\} \\in E$），以下条件成立：$\\{m(v_{1}), m(v_{2})\\} \\in E$。\n\n每个图至少有一个自同构（当 $m$ 是恒等函数时），对于具有 $n$ 个顶点的图，最多可能有 $n!$ 个自同构。由于自同构的数量可能是一个非常大的数字，答案必须以素因数分解的形式呈现 $\\prod^{k}_{i=1} p_{i}^{q_{i}}$，其中 $p_{i}$ 是按升序排列的素数 $(p_{i} \\ge 2, q_{i} > 0)$。", "inputFormat": "输入文件的第一行包含两个整数 $n$ 和 $m (1 \\le n \\le 50 000, 0 \\le m \\le 50 000)$。这里 $n$ 是图中的顶点数。顶点从 $1$ 到 $n$ 编号。图的边由一组边不重复的路径表示，其中 $m$ 是这样的路径数。\n\n接下来的 $m$ 行中的每一行包含图中的一条路径。路径以一个整数 $k_{i} (2 \\le k_{i} \\le 1000)$ 开头，后跟 $k_{i}$ 个从 $1$ 到 $n$ 的整数。这些 $k_{i}$ 个整数表示路径的顶点。路径中的相邻顶点是不同的。路径可以多次经过同一顶点，但整个输入文件中每条边恰好被遍历一次。图中没有重边（任意两个顶点之间最多有一条边）。\n\n输入文件中的图是一个仙人掌图。", "outputFormat": "在输出文件的第一行写入数字 $k$——图自同构数量的素因数分解中的素因子数量。如果图自同构的数量是 $1$，则写入 $0$。在接下来的 $k$ 行中写入素数 $p_{i}$ 及其幂 $q_i$，用空格分隔。素数必须按升序给出。", "hint": "时间限制：5 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6999", "type": "P", "difficulty": 6, "samples": [["5\nnorth\neastern\neuropean\nregional\ncontest\n", "31\n0\n7 n\n2 o\n18 t\n4 h\n29 e\n17 a\n7 s\n8 t\n9 e\n10 r\n11 n\n6 u\n13 r\n14 o\n15 p\n16 e\n3 r\n18 e\n19 g\n20 i\n21 o\n22 n\n23 a\n24 l\n1 c\n26 o\n27 n\n28 t\n6 s\n30 t\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Dictionary", "background": "", "description": "\n\nPetr and Dmitry are working on a novel data compression scheme. Their task is to compress a given set of words. To compress a given set of words they have to build a rooted tree. Each edge of the tree is marked with exactly one letter.\n\nLet us define a dictionary that is produced by this kind of tree as a set of words that can be constructed by concatenating letters on edges on any path from any vertex in the tree (not necessarily root) and going away from root down to the leaves (but not necessarily finishing on a leaf).\n\nBoys have to construct such a tree with a dictionary that is a superset of the set of words that they are given to compress. This tree should have the smallest number of vertices between trees that satisfy the above condition. Any tree with the same number of vertices will do. Your task is to help them.\n\n![](/upload/images2/dict.png)\n\nFor example, in a tree on the picture above with the root marked as $1$ , a path from $7$ to $5$ reads `north`, a path from $16$ to $12$ reads `eastern`, a path from $29$ to $2$ reads `european`, a path from $3$ to $25$ reads `regional`, and a path from $1$ to $31$ reads `contest`.\n\n", "inputFormat": "\n\nThe first line of the input file contains the number of words in a given set $n (1 \\le n \\le 50)$ . The following $n$ lines contain different non-empty words, one word per line, consisting of lowercase English letters. The length of each word is at most $10$ characters.\n\n", "outputFormat": "\n\nOn the first line output the number of vertices in the tree $m$ . The following $m$ lines shall contain descriptions of tree vertices, one description per line. Vertices are indexed from $1$ to $n$ in the order of their corresponding description lines. If the corresponding vertex is a tree root, then its description line shall contain a single integer number $0$ , otherwise its description line shall contain an index of its parent node and a letter on the edge to its parent node, separated by a space.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Dictionary", "background": "", "description": "\n\nPetr and Dmitry are working on a novel data compression scheme. Their task is to compress a given set of words. To compress a given set of words they have to build a rooted tree. Each edge of the tree is marked with exactly one letter.\n\nLet us define a dictionary that is produced by this kind of tree as a set of words that can be constructed by concatenating letters on edges on any path from any vertex in the tree (not necessarily root) and going away from root down to the leaves (but not necessarily finishing on a leaf).\n\nBoys have to construct such a tree with a dictionary that is a superset of the set of words that they are given to compress. This tree should have the smallest number of vertices between trees that satisfy the above condition. Any tree with the same number of vertices will do. Your task is to help them.\n\n![](/upload/images2/dict.png)\n\nFor example, in a tree on the picture above with the root marked as $1$ , a path from $7$ to $5$ reads `north`, a path from $16$ to $12$ reads `eastern`, a path from $29$ to $2$ reads `european`, a path from $3$ to $25$ reads `regional`, and a path from $1$ to $31$ reads `contest`.\n\n", "inputFormat": "\n\nThe first line of the input file contains the number of words in a given set $n (1 \\le n \\le 50)$ . The following $n$ lines contain different non-empty words, one word per line, consisting of lowercase English letters. The length of each word is at most $10$ characters.\n\n", "outputFormat": "\n\nOn the first line output the number of vertices in the tree $m$ . The following $m$ lines shall contain descriptions of tree vertices, one description per line. Vertices are indexed from $1$ to $n$ in the order of their corresponding description lines. If the corresponding vertex is a tree root, then its description line shall contain a single integer number $0$ , otherwise its description line shall contain an index of its parent node and a letter on the edge to its parent node, separated by a space.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Dictionary", "background": "", "description": "Petr和Dmitry正在研究一种新的数据压缩方案。他们的任务是压缩一组给定的单词。为了压缩给定的一组单词，他们必须建立一个有根的树。这棵树的每一个边缘都有一个字母。\n\n让我们定义一个由这种树生成的字典，它是一组单词，可以通过在树的任何顶点（不一定是根节点）的任何路径上的边上连接字母，从根向下到叶子（但不一定在叶节点上完成）来构造。\n\n男孩们必须用字典来构造这样一棵树，字典是一组单词的超集，他们被给予压缩。满足上述条件的树之间的顶点数应该最小。任何具有相同顶点数的树都可以。你的任务是帮助他们。\n\n例如，上图中的一棵树的根标记为1，从7到5的路径表示north，从16到12的路径表示eastern，从29到22的路径表示european，从3到25的路径表示regional，从1到31的路径表示contest。", "inputFormat": "第一行是一个数字n（0<n<50）\n接下来n行都是一个长度小于10的字符串", "outputFormat": "在第一行输出树中的顶点数m。每行树应包含一行描述的顶点。顶点按其相应描述行的顺序从1索引到n。如果对应的顶点是树根，则其描述行应包含单个整数0，否则其描述行应包含其父节点的索引和父节点边缘上的字母，用空格隔开。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7000", "type": "P", "difficulty": 6, "samples": [["4\n5 1\n2 4\n3 7\n7 3\n", "3.5 2.5 5.5 4.5\n"], ["5\n1 1\n1 4\n4 7\n7 4\n7 1\n", "1 1 7 4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2013", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Easy Geometry", "background": "", "description": "\n\nEva studies geometry. The current topic is about convex polygons, but Eva prefers rectangles. Eva's workbook contains drawings of several convex polygons and she is curious what is the area of the maximum rectangle that fits inside each of them.\n\n![](/upload/images2/eg.png)\n\nHelp Eva! Given the convex polygon, find the rectangle of the maximum possible area that fits inside this polygon. Sides of the rectangle must be parallel to the coordinate axes.\n\n", "inputFormat": "\n\nThe first line contains a single integer $n$ -- the number of sides of the polygon $(3 \\le n \\le 100 000)$ . The following $n$ lines contain Cartesian coordinates of the polygon's vertices -- two integers $x_{i}$ and $y_{i} (-10^{9} \\le x_{i}, y_{i} \\le 10^{9})$ per line. Vertices are given in the clockwise order.\n\nThe polygon is convex.\n\n", "outputFormat": "\n\nOutput four real numbers $x_{mi_n}, y_{mi_n}, x_{max}$ and $y_{max}$ -- the coordinates of two rectangle's corners $(x_{mi_n} < x_{max}, y_{mi_n} < y_{max}).$ The rectangle must fit into the polygon and have the maximum possible area.\n\nThe absolute precision of the coordinates should be at least $10-^{5}.$\n\nThe absolute or relative precision of the rectangle area should be at least $10^{-5}.$ That is, if $A'$ ; is the actual maximum possible area, the following must hold: $mi_n(|A-A'|,|A−A'|/A') ) \\le 10^{-5}.$\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Easy Geometry", "background": "", "description": "\n\nEva studies geometry. The current topic is about convex polygons, but Eva prefers rectangles. Eva's workbook contains drawings of several convex polygons and she is curious what is the area of the maximum rectangle that fits inside each of them.\n\n![](/upload/images2/eg.png)\n\nHelp Eva! Given the convex polygon, find the rectangle of the maximum possible area that fits inside this polygon. Sides of the rectangle must be parallel to the coordinate axes.\n\n", "inputFormat": "\n\nThe first line contains a single integer $n$ -- the number of sides of the polygon $(3 \\le n \\le 100 000)$ . The following $n$ lines contain Cartesian coordinates of the polygon's vertices -- two integers $x_{i}$ and $y_{i} (-10^{9} \\le x_{i}, y_{i} \\le 10^{9})$ per line. Vertices are given in the clockwise order.\n\nThe polygon is convex.\n\n", "outputFormat": "\n\nOutput four real numbers $x_{mi_n}, y_{mi_n}, x_{max}$ and $y_{max}$ -- the coordinates of two rectangle's corners $(x_{mi_n} < x_{max}, y_{mi_n} < y_{max}).$ The rectangle must fit into the polygon and have the maximum possible area.\n\nThe absolute precision of the coordinates should be at least $10-^{5}.$\n\nThe absolute or relative precision of the rectangle area should be at least $10^{-5}.$ That is, if $A'$ ; is the actual maximum possible area, the following must hold: $mi_n(|A-A'|,|A−A'|/A') ) \\le 10^{-5}.$\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Easy Geometry", "background": "", "description": "**一句话题意：** \n\n给你一个凸 $n$ 边形，并按顺时针给出每一个顶点的坐标，求出在这个凸 $n$ 边形之内的面积最大的一个边平行坐标轴的矩形的四个顶点。", "inputFormat": "第一行是一个正整数 $n$ ，且 $3\\le n \\le 100000$ 。\n\n接下来 $n$ 行，每行两个整数 $x$ ， $y$ ，代表一个顶点的 $x$ 坐标和 $y$ 坐标。 $-10^9 \\le x,y \\le 10^9$ 。", "outputFormat": "输出四个整数 $x_{min},y_{min},x_{max},y_{max}$ ，代表你给出的这个面积最大的矩形。其中 $x_{min} \\le x_{max} $ ， $y_{min} \\le y_{max} $ 。\n\n精度要求：如果 $A$ 是你算出的值， $A'$ 是真实的最大面积，那么你需要保证 $min( |A-A'|,|A-A'|/A') \\le10^{-5}$ 。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7001", "type": "P", "difficulty": 1, "samples": [["A**1MP19*\n4\nA001MP199\nE885EE098\nA111MP199\nKT7351TTB\n", "2\nA001MP199\nA111MP199\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Fraud Busters", "background": "", "description": "\n\nThe number of cars in Default City that travel to the city center daily vastly exceeds the number of available parking spots. The City Council had decided to introduce parking fees to combat the problem of overspill parking on the city streets. Parking fees are enforced using an automated vehicle registration plate scanners that take a picture of the vehicle registration plate, recognize the sequence of digits and letters in the code on the plate, and check the code against a vehicle registration database to ensure that parking fees are dutifully paid or to automatically issue a fine to the vehicle owner otherwise.\n\nAs soon as parking fees were introduced, a parking fee fraud had appeared. Some vehicle owners had started to close one or several digits or letters on their vehicle registration plate with pieces of paper while they park, thus making it impossible for the current version of the automated scanner to recognize their vehicle's registration code and to issue them a fine.\n\nThe Default City Council had instituted the Fraud Busters Initiative (FBI) to design a solution to prevent this kind of fraud. The overall approach that FBI had selected is to expand the number of vehicle features that scanners recognize (including features like vehicle type and color), as well as excluding from the list any vehicles that are detected to be elsewhere at this time. This information should help to identify the correct vehicle by narrowing down the search in the vehicle registration database.\n\nYou are working for FBI. Your colleagues had already written all the complex pieces of the recognition software that analyses various vehicle features and provides you with a list of registration codes that might potentially belong to a scanned car. Your task it to take this list and a recognized code from the license plate (which may be partially unrecognized) and find all the registration codes that match.\n\n", "inputFormat": "\n\nThe first line of the input file contains $9$ characters of the code as recognized by the scanner. Code that was recognized by the the scanner is represented as a sequence of $9$ digits, uppercase English letters, and characters $` \\times ` (star).$ Star represents a digit or a letter that scanner could not recognize.\n\nThe second line of the input file contains a single integer number $n (1 \\le n \\le 1000)$ -- the number of vehicle registration codes from the vehicle registration database.\n\nThe following $n$ lines contain the corresponding registration codes, one code per line. Vehicle registration codes are represented as a sequence of $9$ digits and uppercase English letters. All codes on these $n$ lines of the input file are different.\n\n", "outputFormat": "\n\nOn the first line of the output file write a single integer $k (0 \\le k \\le n)$ -- the number of codes from the input file that match the code that was recognized by the scanner. The code from the scanner matches the code from the database if the characters on all the corresponding positions in the codes are equal or the character from the scanner code is $` \\times `.$\n\nOn the following $k$ lines write the matching codes, one code per line, in the same order as they are given in the input file.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Fraud Busters", "background": "", "description": "\n\nThe number of cars in Default City that travel to the city center daily vastly exceeds the number of available parking spots. The City Council had decided to introduce parking fees to combat the problem of overspill parking on the city streets. Parking fees are enforced using an automated vehicle registration plate scanners that take a picture of the vehicle registration plate, recognize the sequence of digits and letters in the code on the plate, and check the code against a vehicle registration database to ensure that parking fees are dutifully paid or to automatically issue a fine to the vehicle owner otherwise.\n\nAs soon as parking fees were introduced, a parking fee fraud had appeared. Some vehicle owners had started to close one or several digits or letters on their vehicle registration plate with pieces of paper while they park, thus making it impossible for the current version of the automated scanner to recognize their vehicle's registration code and to issue them a fine.\n\nThe Default City Council had instituted the Fraud Busters Initiative (FBI) to design a solution to prevent this kind of fraud. The overall approach that FBI had selected is to expand the number of vehicle features that scanners recognize (including features like vehicle type and color), as well as excluding from the list any vehicles that are detected to be elsewhere at this time. This information should help to identify the correct vehicle by narrowing down the search in the vehicle registration database.\n\nYou are working for FBI. Your colleagues had already written all the complex pieces of the recognition software that analyses various vehicle features and provides you with a list of registration codes that might potentially belong to a scanned car. Your task it to take this list and a recognized code from the license plate (which may be partially unrecognized) and find all the registration codes that match.\n\n", "inputFormat": "\n\nThe first line of the input file contains $9$ characters of the code as recognized by the scanner. Code that was recognized by the the scanner is represented as a sequence of $9$ digits, uppercase English letters, and characters $` \\times ` (star).$ Star represents a digit or a letter that scanner could not recognize.\n\nThe second line of the input file contains a single integer number $n (1 \\le n \\le 1000)$ -- the number of vehicle registration codes from the vehicle registration database.\n\nThe following $n$ lines contain the corresponding registration codes, one code per line. Vehicle registration codes are represented as a sequence of $9$ digits and uppercase English letters. All codes on these $n$ lines of the input file are different.\n\n", "outputFormat": "\n\nOn the first line of the output file write a single integer $k (0 \\le k \\le n)$ -- the number of codes from the input file that match the code that was recognized by the scanner. The code from the scanner matches the code from the database if the characters on all the corresponding positions in the codes are equal or the character from the scanner code is $` \\times `.$\n\nOn the following $k$ lines write the matching codes, one code per line, in the same order as they are given in the input file.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Fraud Busters", "background": "", "description": "在 Default City，每天进入市中心的汽车数量远远超过可用停车位的数量。市议会决定引入停车费，以解决城市街道上溢出的停车问题。停车费通过自动车牌扫描仪来执行，该扫描仪拍摄车辆车牌的照片，识别车牌上的字母和数字序列，并将代码与车辆注册数据库进行比对，以确保停车费已被支付，或者自动向车主开具罚单。  \n\n停车费一经引入，停车费欺诈行为就出现了。一些车主开始在停车时用纸片遮住车牌上的一个或几个数字或字母，从而使当前版本的自动扫描仪无法识别其车辆的注册代码，也无法对其开具罚单。  \n\nDefault City 市议会成立了“欺诈克星计划”（FBI）来设计解决方案以防止此类欺诈行为。FBI 选择的总体方法是扩展扫描仪识别的车辆特征数量（包括车辆类型和颜色等特征），并从列表中排除在该时间被检测到在其他地方的车辆。这些信息有助于通过缩小车辆注册数据库中的搜索范围来识别正确的车辆。  \n\n你在为 FBI 工作。你的同事们已经编写了所有复杂的识别软件，这些软件分析各种车辆特征，并为你提供可能属于被扫描车辆的注册代码列表。你的任务是获取这个列表和车牌上识别出的代码（可能部分未识别），并找到所有匹配的注册代码。", "inputFormat": "输入文件的第一行包含扫描仪识别出的代码的 $9$ 个字符。扫描仪识别出的代码表示为 $9$ 个数字、大写英文字母和字符 $`\\times`$（星号）的序列。星号表示扫描仪无法识别的数字或字母。  \n\n输入文件的第二行包含一个整数 $n (1 \\le n \\le 1000)$ ——车辆注册数据库中的车辆注册代码数量。  \n\n接下来的 $n$ 行包含相应的注册代码，每行一个代码。车辆注册代码表示为 $9$ 个数字和大写英文字母的序列。输入文件中这 $n$ 行的所有代码都是不同的。", "outputFormat": "输出文件的第一行写一个整数 $k (0 \\le k \\le n)$ ——与扫描仪识别的代码匹配的输入文件中的代码数量。如果代码中所有对应位置的字符相等，或者扫描仪代码中的字符是 $`\\times`$，则扫描仪的代码与数据库中的代码匹配。  \n\n在接下来的 $k$ 行中，按输入文件中给出的顺序，每行写一个匹配的代码。", "hint": "时间限制：1 秒，内存限制：128 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7002", "type": "P", "difficulty": 5, "samples": [["5 4 10\n20 10 20 15 10\n0 10\n40 20\n50 0\n70 30\n", "52.342888649592545\n16.0\n0.0\n70.0\n65.3\n65.3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Green Energy", "background": "", "description": "\n\nThe technological progress in Flatland is impressive. This year, for example, the solar power stations of a new type will be build. In these stations solar panels are mounted not on the ground, but on high towers, along their heights.\n\nThere are $n$ towers to be mounted. The towers are already bought. The height of i-th tower is $h_{i}.$ Now engineers want to choose the points where they should be mounted to get the maximal total power.\n\nThe landscape of a territory of the power plant is described by a polyline with $m$ vertices. Vertices of the landscape polyline have coordinates $(x_{i}, y_{i}),$ such that $x_{i} < x_{i+1}.$\n\nThe sun angle is always $α$ degrees in Flatland. The sun is shining from the top-left to the bottom-right. The power that is produced by a tower depends on the length of its surface illuminated by the sun.\n\nWhen two towers are mounted close to each other, the shadow of the left tower may fall onto the right tower, so the power, produced by the right tower, decreases. Also, the landscape itself may contain high points that drop shadows on some towers.\n\n![](/upload/images2/ge.png)\n\nYour task is to find the points on the territory of the plant to mount the given towers to maximize the total length of towers surface that is illuminated by the sun.\n\n", "inputFormat": "\n\nThe first line of the input file contains three integers $n , m$ and $α (1 \\le n \\le 10^{4}, 2 \\le m \\le 10^{4}, 1 \\le α < 90)$ . The second line contains $n$ integers $h_{i}$ -- the heights of the towers $(1 \\le h_{i} \\le 10^{3}).$ The following $m$ lines contain pairs $x_{i}, y_{i}$ -- the coordinates of the vertices of the landscape $(|x_{i}| \\le 10^{5}, x_{i} < x_{i+1}, |y_{i}| \\le 10^{3}).$\n\n", "outputFormat": "\n\nOn the first line output the maximal possible summary length of towers that can be illuminated by the sun with an absolute precision of at least $10^{-6}.$ On the next $n$ lines output the x-coordinates of the points where the towers should be mounted to achieve this maximum with an absolute precision of at least $10^{-9}.$ Towers should be listed in the same order they are given in the input file.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Green Energy", "background": "", "description": "\n\nThe technological progress in Flatland is impressive. This year, for example, the solar power stations of a new type will be build. In these stations solar panels are mounted not on the ground, but on high towers, along their heights.\n\nThere are $n$ towers to be mounted. The towers are already bought. The height of i-th tower is $h_{i}.$ Now engineers want to choose the points where they should be mounted to get the maximal total power.\n\nThe landscape of a territory of the power plant is described by a polyline with $m$ vertices. Vertices of the landscape polyline have coordinates $(x_{i}, y_{i}),$ such that $x_{i} < x_{i+1}.$\n\nThe sun angle is always $α$ degrees in Flatland. The sun is shining from the top-left to the bottom-right. The power that is produced by a tower depends on the length of its surface illuminated by the sun.\n\nWhen two towers are mounted close to each other, the shadow of the left tower may fall onto the right tower, so the power, produced by the right tower, decreases. Also, the landscape itself may contain high points that drop shadows on some towers.\n\n![](/upload/images2/ge.png)\n\nYour task is to find the points on the territory of the plant to mount the given towers to maximize the total length of towers surface that is illuminated by the sun.\n\n", "inputFormat": "\n\nThe first line of the input file contains three integers $n , m$ and $α (1 \\le n \\le 10^{4}, 2 \\le m \\le 10^{4}, 1 \\le α < 90)$ . The second line contains $n$ integers $h_{i}$ -- the heights of the towers $(1 \\le h_{i} \\le 10^{3}).$ The following $m$ lines contain pairs $x_{i}, y_{i}$ -- the coordinates of the vertices of the landscape $(|x_{i}| \\le 10^{5}, x_{i} < x_{i+1}, |y_{i}| \\le 10^{3}).$\n\n", "outputFormat": "\n\nOn the first line output the maximal possible summary length of towers that can be illuminated by the sun with an absolute precision of at least $10^{-6}.$ On the next $n$ lines output the x-coordinates of the points where the towers should be mounted to achieve this maximum with an absolute precision of at least $10^{-9}.$ Towers should be listed in the same order they are given in the input file.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Green Energy", "background": "", "description": "平地上的技术进步令人惊叹。今年正要建造一种新型的太阳能发电站。在这些发电站中，太阳能电池板不是安装在地面上，而是安装在高塔上。\n\n在二为世界中有要安装$i$个高塔。这些塔塔高固定。第$i$座塔的高度是$h_i$。现在，工程师们想要选择安装点，以获得最大的总功率。\n\n电厂区域由有$m$顶点的线连接。这些线的顶点坐标为$(x_i,y_i)$满足$x_i<x_{i+1}$\n在平地上，太阳的角度总是$\\alpha$度。太阳从左上角照射到右下角。塔产生的功率取决于其表面被太阳照射的面积(其实是长度)。\n\n当安装的两个塔彼此靠近时，左侧塔的阴影可能落在右侧塔上，从而右侧塔产生的功率降低。此外，电厂区域本身可能包含在某些塔楼上投下阴影的高点。\n\n你的任务是在电厂区域内找到安装给定塔架的点，以得到太阳照射下塔架最大总表面积(长度)。", "inputFormat": "输入第一行包含三个整数：$n$,$m$,$\\alpha$ $(1 \\le n \\le 10^4,2 \\le m \\le 10^4,1 \\le \\alpha <90)$。第二行包含$n$整数$h_i$(塔高）$(1 \\le h_i \\le 10^3)$。后面的$m$行每行有$x_i$,$y_i$一对数（电厂顶点坐标)$(|x_i|\\le 10^5,x_i < x_{i+1},|y_i|\\le 10^3)$", "outputFormat": "第一行:以至少$10^{-6}$精度输出可被太阳照亮的塔的最大可能汇总面积（长度)。在后n行上，输出此时塔安装点的x坐标，绝对精度至少为$10^{-9}$。塔的输出顺序应与输入顺序相同。", "hint": "时间限制：1h\n\n空间顺序：128PB", "locale": "zh-CN"}}}
{"pid": "P7003", "type": "P", "difficulty": 5, "samples": [["4\n1 2 3 3\n", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Hack Protection", "background": "", "description": "\n\nPavel is sending to his friend Egor some array of non-negative integers. He wants to be sure, that nobody hacks the array before his friend gets it. To solve this problem Pavel need to compute some kind of a checksum or a digest for his array. Pavel has an innovative mind, so he invents the following algorithm to compute the digest for his array: count the number of subarrays in which the bitwise xor of the numbers in the subarray is equal to the bitwise and of the same numbers.\n\nFor example, consider an array of four binary numbers `01`, `10`, `11`, and `11`. The table below to the left lists the results of the bitwise xor of numbers for each subarray of this array, and the table below to the right list the results of the bitwise and of numbers for each subarray of this array. The rows of the table correspond to the starting elements of the subarray from the $1st$ element of the array to the $4th$ one, while columns correspond to the ending elements of the subarray. Matching values are highlighted with gray background.\n\n![](/upload/images2/hp.png)\n\nYour task is to help Pavel compute this kind of a digest of the given array.\n\n", "inputFormat": "\n\nThe first line contains one integer $n (1 \\le n \\le 100 000)$ . The second line contains $n$ non-negative integers $a_{i} (0 \\le a_{i} \\le 2^{31}-1)$ that are written in decimal notation.\n\n", "outputFormat": "\n\nOn the first line of the output print Pavel's digest of the given array.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Hack Protection", "background": "", "description": "\n\nPavel is sending to his friend Egor some array of non-negative integers. He wants to be sure, that nobody hacks the array before his friend gets it. To solve this problem Pavel need to compute some kind of a checksum or a digest for his array. Pavel has an innovative mind, so he invents the following algorithm to compute the digest for his array: count the number of subarrays in which the bitwise xor of the numbers in the subarray is equal to the bitwise and of the same numbers.\n\nFor example, consider an array of four binary numbers `01`, `10`, `11`, and `11`. The table below to the left lists the results of the bitwise xor of numbers for each subarray of this array, and the table below to the right list the results of the bitwise and of numbers for each subarray of this array. The rows of the table correspond to the starting elements of the subarray from the $1st$ element of the array to the $4th$ one, while columns correspond to the ending elements of the subarray. Matching values are highlighted with gray background.\n\n![](/upload/images2/hp.png)\n\nYour task is to help Pavel compute this kind of a digest of the given array.\n\n", "inputFormat": "\n\nThe first line contains one integer $n (1 \\le n \\le 100 000)$ . The second line contains $n$ non-negative integers $a_{i} (0 \\le a_{i} \\le 2^{31}-1)$ that are written in decimal notation.\n\n", "outputFormat": "\n\nOn the first line of the output print Pavel's digest of the given array.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Hack Protection", "background": null, "description": "Pavel 正在给他的朋友 Egor 发送一些非负整数数组。他希望确保在他的朋友收到数组之前，没有人篡改过它。为了解决这个问题，Pavel 需要为他的数组计算某种校验和或摘要。Pavel 有一个创新的头脑，所以他发明了以下算法来计算他的数组的摘要：计算子数组中数字的按位异或等于相同数字的按位与的子数组的数量。\n\n例如，考虑一个由四个二进制数 `01`、`10`、`11` 和 `11` 组成的数组。左下表列出了该数组每个子数组的数字的按位异或结果，右下表列出了该数组每个子数组的数字的按位与结果。表格的行对应于子数组的起始元素，从数组的第 $1$ 个元素到第 $4$ 个元素，而列对应于子数组的结束元素。匹配的值用灰色背景突出显示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9rnw871w.png)\n\n你的任务是帮助 Pavel 计算给定数组的这种摘要。", "inputFormat": "第一行包含一个整数 $n (1 \\le n \\le 100 000)$。第二行包含 $n$ 个以十进制表示的非负整数 $a_{i} (0 \\le a_{i} \\le 2^{31}-1)$。", "outputFormat": "输出的第一行打印给定数组的 Pavel 的摘要。", "hint": "时间限制：1 秒，内存限制：128 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7004", "type": "P", "difficulty": 6, "samples": [["2 2\nYes\nNo\nYes\nYes", "check 1 3\ncheck 3 5\ncheck 2 4\ncheck 4 5\nanswer 5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Interactive Interception", "background": "", "description": "This is an interactive problem.\n\nNorth Eastern Emergency Rocket Control agency (NEERC) has developed a new radar control system that is designed to better control ballistic rocket interception. To test the new system NEERC agency had developed a mathematical model that is intended to show this system’s abilities.\n\nLet us represent a rocket as a point on a line. Initially the point is at some unknown integer location between $0$ and $p$, inclusive. It has some unknown speed of $q$ which is an integer between $0$ and $v$, inclusive.\n\nEach second the following happens. First, the control system makes a query to the radar of a form “`check L R`” and gets an answer whether the point is currently between $L$ and $R$, inclusive, or not.\n\nAfter that, the point’s coordinate increases by $q$.\n\nThe goal of the radar control system is to learn the exact location of the point at the beginning of some second. When it does learn the point’s location, then instead of making a query to the radar, it gives a command to intercept the point at that location.\n\nYou have to implement the control system that locates and intercepts the point while making at most $100$ queries to the radar.\n\n### Interaction protocol\nInteraction starts with your program reading two integers — the values of $p$ and $v$ from the standard input($1\\leq p\\leq 10^5$,$1\\leq v\\leq 10^5$).\n\nAfter that your program must print commands to the standard output. Each command must be one of the following two.\n\n- “`check L R`” — make a query to the radar to get an answer whether the point is currently between $L$ and $R$, inclusive, or not. The answer must be read from the standard input and is either “`Yes`” or “`No`”. After that the point’s coordinate is increased by $q$. $L$ and $R$ must be integers.\n- “`answer x`” — the exact coordinate $x$ of the point is known, and you order to intercept the point. After printing this command your program must exit.\n\nYour program must write end-of-line sequence and flush the standard output after each command, including the last command “`answer x`” (end-of-line must be written and flushed before exiting).\n\n", "inputFormat": "", "outputFormat": "", "hint": "In the given example the point was initially at location $1$ and is moving at a speed $q = 1$.", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Interactive Interception", "background": "", "description": "This is an interactive problem.\n\nNorth Eastern Emergency Rocket Control agency (NEERC) has developed a new radar control system that is designed to better control ballistic rocket interception. To test the new system NEERC agency had developed a mathematical model that is intended to show this system’s abilities.\n\nLet us represent a rocket as a point on a line. Initially the point is at some unknown integer location between $0$ and $p$, inclusive. It has some unknown speed of $q$ which is an integer between $0$ and $v$, inclusive.\n\nEach second the following happens. First, the control system makes a query to the radar of a form “`check L R`” and gets an answer whether the point is currently between $L$ and $R$, inclusive, or not.\n\nAfter that, the point’s coordinate increases by $q$.\n\nThe goal of the radar control system is to learn the exact location of the point at the beginning of some second. When it does learn the point’s location, then instead of making a query to the radar, it gives a command to intercept the point at that location.\n\nYou have to implement the control system that locates and intercepts the point while making at most $100$ queries to the radar.\n\n### Interaction protocol\nInteraction starts with your program reading two integers — the values of $p$ and $v$ from the standard input($1\\leq p\\leq 10^5$,$1\\leq v\\leq 10^5$).\n\nAfter that your program must print commands to the standard output. Each command must be one of the following two.\n\n- “`check L R`” — make a query to the radar to get an answer whether the point is currently between $L$ and $R$, inclusive, or not. The answer must be read from the standard input and is either “`Yes`” or “`No`”. After that the point’s coordinate is increased by $q$. $L$ and $R$ must be integers.\n- “`answer x`” — the exact coordinate $x$ of the point is known, and you order to intercept the point. After printing this command your program must exit.\n\nYour program must write end-of-line sequence and flush the standard output after each command, including the last command “`answer x`” (end-of-line must be written and flushed before exiting).\n\n", "inputFormat": "", "outputFormat": "", "hint": "In the given example the point was initially at location $1$ and is moving at a speed $q = 1$.", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Interactive Interception", "background": "", "description": "这是一个交互式问题。\n\n东北紧急火箭控制局（NEERC）开发了一种新的雷达控制系统，旨在更好地控制弹道火箭拦截。为了测试新系统，NEERC 机构开发了一个数学模型，旨在展示该系统的能力。\n\n让我们将火箭表示为一条线上的一个点。最初，该点位于 $0$ 到 $p$ 之间的某个未知整数位置（包括 $0$ 和 $p$）。它具有某个未知速度 $q$，这是一个介于 $0$ 和 $v$ 之间的整数（包括 $0$ 和 $v$）。\n\n每秒会发生以下情况。首先，控制系统向雷达发出一个形式为“`check L R`”的查询，并得到一个答案，指出该点当前是否在 $L$ 和 $R$ 之间（包括 $L$ 和 $R$）。之后，该点的坐标增加 $q$。\n\n雷达控制系统的目标是在某一秒开始时准确地确定该点的位置。当它确实知道该点的位置时，不再向雷达发出查询，而是发出命令在该位置拦截该点。\n\n你必须实现控制系统，在最多进行 100 次雷达查询的情况下定位并拦截该点。\n\n### 交互协议\n交互从你的程序读取两个整数——$p$ 和 $v$ 的值开始（$1 \\leq p \\leq 10^5$，$1 \\leq v \\leq 10^5$）。\n\n之后，你的程序必须向标准输出打印命令。每个命令必须是以下两种之一。\n\n- “`check L R`”——向雷达发出查询以获得答案，指出该点当前是否在 $L$ 和 $R$ 之间（包括 $L$ 和 $R$）。答案必须从标准输入读取，答案是“`Yes`”或“`No`”。之后，该点的坐标增加 $q$。$L$ 和 $R$ 必须是整数。\n- “`answer x`”——已知该点的确切坐标 $x$，并命令拦截该点。在打印此命令后，你的程序必须退出。\n\n你的程序必须在每个命令后，包括最后一个命令“`answer x`”后写入行结束符并刷新标准输出（在退出之前必须写入并刷新行结束符）。", "inputFormat": "", "outputFormat": "", "hint": "在给定的例子中，该点最初位于位置 $1$，并以速度 $q = 1$ 移动。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7005", "type": "P", "difficulty": 5, "samples": [["6\n@Petr: Leaving for #NEERC tomorrow!\n@Roman: This #NEERC is going to be awesome!\n@Stone_in_forest: Nothing happened today.\n@NEERCNews: @Petr Don't forget an umbrella :)\n@Lydia: @NEERCNews cares about @Petr - so cute ^_^\n@Lydia: @Lydia @NEERCNews @Petr it won't be raining though!\n", "3\n1 4 5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2013", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Join the Conversation", "background": "", "description": "\n\nAbstract Communication Mastership (ACM) is a software company that develops a unique social network called tWinter.\n\nEach tWinter user has a handle that starts with a commercial at $(‘@')$ character. Users of tWinter social network publish short messages to the network.\n\nIf a user's message contains another user's handle (preceded by a space or at the beginning of the message, and followed by a space or at the end of the message) then it is called a mention.\n\nA sequence of messages is called a conversation if each message in the sequence (except the first one) contains a mention of the author of the previous message in the sequence.\n\nYou are hired to find the longest conversation in the given chronological log of messages.\n\n", "inputFormat": "\n\nThe first line of the input file contains an integer $n (1 \\le n \\le 50 000)$ -- the number of messages in the chronological log.\n\nEach of the next $n$ lines contains a message preceded by its author's handle, a colon $(‘:')$ character, and a space.\n\nEach message is at most $139$ characters long. Each handle is at most $20$ characters long and does not contain colons or spaces.\n\nThe input file contains only characters with ASCII codes between $32$ and $126$ , inclusive, and line breaks.\n\n", "outputFormat": "\n\nOn the first line of the output file write the length of the longest conversation in the given log. On the second line write $1-based$ indices of the messages in that conversation in ascending order.\n\nIf there are multiple longest conversations, write any one of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Join the Conversation", "background": "", "description": "\n\nAbstract Communication Mastership (ACM) is a software company that develops a unique social network called tWinter.\n\nEach tWinter user has a handle that starts with a commercial at $(‘@')$ character. Users of tWinter social network publish short messages to the network.\n\nIf a user's message contains another user's handle (preceded by a space or at the beginning of the message, and followed by a space or at the end of the message) then it is called a mention.\n\nA sequence of messages is called a conversation if each message in the sequence (except the first one) contains a mention of the author of the previous message in the sequence.\n\nYou are hired to find the longest conversation in the given chronological log of messages.\n\n", "inputFormat": "\n\nThe first line of the input file contains an integer $n (1 \\le n \\le 50 000)$ -- the number of messages in the chronological log.\n\nEach of the next $n$ lines contains a message preceded by its author's handle, a colon $(‘:')$ character, and a space.\n\nEach message is at most $139$ characters long. Each handle is at most $20$ characters long and does not contain colons or spaces.\n\nThe input file contains only characters with ASCII codes between $32$ and $126$ , inclusive, and line breaks.\n\n", "outputFormat": "\n\nOn the first line of the output file write the length of the longest conversation in the given log. On the second line write $1-based$ indices of the messages in that conversation in ascending order.\n\nIf there are multiple longest conversations, write any one of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Join the Conversation", "background": "", "description": "Abstract Communication Mastership (ACM)是一家软件公司，开发一种名为$“tWinter”$的独特社交网络。\n\n每个$“tWinter”$用户都有一个句柄，句柄由$‘(’$或$‘‘’$或$‘@’$或$‘′’$或 $‘)’$开头。\n\n每个$“tWinter”$社交网络的用户可以向网络发布短消息。\n\n如果用户的消息包含另一个用户的句柄（句柄前面是空格或句柄是消息的开头并且后跟空格或消息末尾），则称为提及。\n\n如果消息序列中的每条消息（第一条消息除外）都提及序列中前一条消息的作者，则该消息序列称为会话。\n\n您需要在给定的消息时间顺序日志中查找最长的对话。", "inputFormat": "输入文件共$n+1$行；\n\n第一行包含一个整数$n(1≤n≤50000)$为消息日志中消息个数；\n\n接下来$n$行每行一条消息，前面是其作者的句柄，句柄后是一个冒号，冒号后为消息正文。\n\n每条消息长度最多为$139$个字符。每个手柄长度(不包含冒号或空格)最多为$20$个字符。\n\n输入文件仅包含 ASCII 代码介于32和126（含）之间和换行符。", "outputFormat": "输出文件共$2$行；\n\n第一行上，写入给定日志中最长对话的长度；\n\n在第二行写该对话中消息基于1的索引，按升序排列。", "hint": "时间限制：2S；\n\n空间限制：128MB。", "locale": "zh-CN"}}}
{"pid": "P7006", "type": "P", "difficulty": 4, "samples": [["6 3 4 2\n2 1 2 3 2 2\n2 1 1\n", "1\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2013] Kabaleo Lite", "background": "", "description": "\n\nKabaleo Lite is a board game. The board consists of several stacks of conical chips of various colors. Only the color of the top chip of the stack is visible.\n\nEach player has a unique target color and a set of colored chips. The target color is hidden from other players, while the set of chips is visible to them. On his turn, player selects one of his chips and puts it on one of the board stacks, thus recoloring it to the color of the chosen chip.\n\nAfter the last turn, the number of visible board chips of each color is calculated. The winning color is the color that occurs the maximum times. The player (if any) that has this color as his target color, wins the game. If there is no such player or if there are two or more colors that occur the maximum times, the game ends in a draw.\n\nYou are playing your last chip in the Kabaleo Lite game. Other players also have one chip left. You want to determine all possible moves that lead you to winning the game. You do not know the target colors of other players and you cannot predict their moves, so your move must guarantee your victory regardless of moves of your opponents.\n\n", "inputFormat": "\n\nThe first line contains four integers $n , p , c$ and $h$ -- the number of stacks on the board $(1 \\le n \\le 10^{6}),$ the number of players $(1 \\le p \\le 10^{6}),$ the number of chips' colors $(p \\le c \\le 10^{6}),$ and your hidden color $(1 \\le h \\le c)$ .\n\nThe second line contains $n$ integers $b_{i}$ -- the color of the visible board chip for each stack on the board $(1 \\le b_{i} \\le c)$ .\n\nThe third line contains $p$ integers $l_{i}$ -- the color of the last chip for each player $(1 \\le l_{i} \\le c)$ . The players are numbered from one (you) to $n$ in the order of their turns.\n\n", "outputFormat": "\n\nThe first line must contain $w$ -- the number of winning moves.\n\nThe second line must contain $w$ distinct numbers $m_{i}$ -- the numbers of the stacks on which your chip should be put to win. Stacks are numbered starting from $1$ in the order that their visible colors are given in the input file. You can output their numbers in any order on this line.\n\nRemember, that your move should be winning regardless of the moves of all other players.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2013] Kabaleo Lite", "background": "", "description": "\n\nKabaleo Lite is a board game. The board consists of several stacks of conical chips of various colors. Only the color of the top chip of the stack is visible.\n\nEach player has a unique target color and a set of colored chips. The target color is hidden from other players, while the set of chips is visible to them. On his turn, player selects one of his chips and puts it on one of the board stacks, thus recoloring it to the color of the chosen chip.\n\nAfter the last turn, the number of visible board chips of each color is calculated. The winning color is the color that occurs the maximum times. The player (if any) that has this color as his target color, wins the game. If there is no such player or if there are two or more colors that occur the maximum times, the game ends in a draw.\n\nYou are playing your last chip in the Kabaleo Lite game. Other players also have one chip left. You want to determine all possible moves that lead you to winning the game. You do not know the target colors of other players and you cannot predict their moves, so your move must guarantee your victory regardless of moves of your opponents.\n\n", "inputFormat": "\n\nThe first line contains four integers $n , p , c$ and $h$ -- the number of stacks on the board $(1 \\le n \\le 10^{6}),$ the number of players $(1 \\le p \\le 10^{6}),$ the number of chips' colors $(p \\le c \\le 10^{6}),$ and your hidden color $(1 \\le h \\le c)$ .\n\nThe second line contains $n$ integers $b_{i}$ -- the color of the visible board chip for each stack on the board $(1 \\le b_{i} \\le c)$ .\n\nThe third line contains $p$ integers $l_{i}$ -- the color of the last chip for each player $(1 \\le l_{i} \\le c)$ . The players are numbered from one (you) to $n$ in the order of their turns.\n\n", "outputFormat": "\n\nThe first line must contain $w$ -- the number of winning moves.\n\nThe second line must contain $w$ distinct numbers $m_{i}$ -- the numbers of the stacks on which your chip should be put to win. Stacks are numbered starting from $1$ in the order that their visible colors are given in the input file. You can output their numbers in any order on this line.\n\nRemember, that your move should be winning regardless of the moves of all other players.\n\n", "hint": "Time limit: 1 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2013] Kabaleo Lite", "background": null, "description": "有一种棋盘游戏：棋盘上有 $n$ 个格子，每个格子上可以堆叠若干个有颜色的筹码，只有每个格子中最上方的筹码的颜色是可见的。\n\n参加游戏的每个玩家都有各自不同的一个目标颜色，以及一些彩色筹码。每个人只知道自己的目标颜色，但各自拥有的筹码颜色和数量都是公开的。每个回合中，所有玩家轮流在棋盘上选一个格子放置筹码，同时覆盖下方的筹码。游戏结束后，数出棋盘上可见筹码数最多的颜色，以该颜色为目标颜色的玩家即获胜。若该颜色不是任何玩家的目标颜色，或者棋盘上出现最多的颜色不唯一，则游戏平局。\n\n现在，一局游戏进行到了最后，你和其他所有玩家都只剩最后一个筹码。现在恰好轮到你操作，在不知道其他人的目标颜色的前提下，你想知道你一共有哪些操作可以保证必胜。", "inputFormat": "第一行 $4$ 个整数 $n,p,c,h$，分别表示棋盘格数、玩家数、筹码颜色总数和你的目标颜色；\n\n第二行 $n$ 个整数 $b_i$，表示棋盘上现有的筹码颜色，棋盘格编号从 $1$ 开始；\n\n第三行 $p$ 个整数 $l_i$，表示每个玩家的最后一枚筹码的颜色，玩家编号从你开始。", "outputFormat": "第一行 $1$ 个整数 $w$，表示你有多少种必胜操作。\n\n第二行 $w$ 个整数 $m_i$，表示你应该把筹码放在哪个格子上。顺序不限。", "hint": "$1\\leq n\\leq 10^6$，$1\\leq p\\leq c\\leq  10^6$，$1\\leq h,b_i,l_i\\leq c$。", "locale": "zh-CN"}}}
{"pid": "P7007", "type": "P", "difficulty": 6, "samples": [["4\n\n3 3\n1 2 3\n4 5 6\n9 8 7\n\n4 2\n1 2 3 4\n5 6 7 8\n\n4 4\n1 2 15 4\n8 7 11 5\n12 6 10 9\n13 14 3 16\n\n3 4\n1 2 4\n3 5 6\n7 8 9\n10 11 12\n", "POSSIBLE 1 R3\nPOSSIBLE 0\nPOSSIBLE 3 R3 C3 R2\nIMPOSSIBLE\n"]], "limits": {"time": [3000, 3000, 3000], "memory": [131072, 131072, 131072]}, "tags": ["2013", "Special Judge", "ICPC", "CERC"], "title": "[CERC2013] Rubik's Rectangle", "background": "", "description": "A new puzzle which aims to conquer the game market is a fusion of Rubik's Cube and Fifteen. The board is an $H \\times W$ frame with tiles with all numbers from $1$ to $H · W$ printed on them.\n\n![](/upload/images2/rubik1.png)\n\nThe only type of move that is allowed is flipping either one of the rows or one of the columns. Flipping reverses the order of the row's (or column's) elements. Below the third row is flipped:\n\n![](/upload/images2/rubik2.png)\n\nYou are given a board with tiles numbered in some arbitrary order. Determine a sequence of flips that brings the board to the nicely sorted position, if possible.\n\n![](/upload/images2/rubik3.png)\n\n", "inputFormat": "The first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe description of each test case starts with an empty line. The next line contains two space-separated integers $W$ and $H (1 \\leq W,H \\leq 100) -$ the width and height of the puzzle, respectively. Each of the next $H$ lines contains $W$ space-separated integers $-$ the numbers printed on consecutive tiles.\n\n", "outputFormat": "Print the answers to the test cases in the order in which they appear in the input. Start the output for each test case with the word POSSIBLE or IMPOSSIBLE, depending on whether it is possible to solve the puzzle. If a solution exists, print (in the same line) first the number of moves (possibly $0$) and then their descriptions, each consisting of a single letter $R$ or $C$ specifying whether we are to flip a row or a column, concatenated with the index of the row or column to flip.\n\nAny solution will be accepted as long as it does not use more than $10 · W · H$ moves. Each test case is either solvable within this limit, or not solvable at all.\n\n", "hint": "Time limit: 6 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[CERC2013] Rubik's Rectangle", "background": "", "description": "A new puzzle which aims to conquer the game market is a fusion of Rubik's Cube and Fifteen. The board is an $H \\times W$ frame with tiles with all numbers from $1$ to $H · W$ printed on them.\n\n![](/upload/images2/rubik1.png)\n\nThe only type of move that is allowed is flipping either one of the rows or one of the columns. Flipping reverses the order of the row's (or column's) elements. Below the third row is flipped:\n\n![](/upload/images2/rubik2.png)\n\nYou are given a board with tiles numbered in some arbitrary order. Determine a sequence of flips that brings the board to the nicely sorted position, if possible.\n\n![](/upload/images2/rubik3.png)\n\n", "inputFormat": "The first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe description of each test case starts with an empty line. The next line contains two space-separated integers $W$ and $H (1 \\leq W,H \\leq 100) -$ the width and height of the puzzle, respectively. Each of the next $H$ lines contains $W$ space-separated integers $-$ the numbers printed on consecutive tiles.\n\n", "outputFormat": "Print the answers to the test cases in the order in which they appear in the input. Start the output for each test case with the word POSSIBLE or IMPOSSIBLE, depending on whether it is possible to solve the puzzle. If a solution exists, print (in the same line) first the number of moves (possibly $0$) and then their descriptions, each consisting of a single letter $R$ or $C$ specifying whether we are to flip a row or a column, concatenated with the index of the row or column to flip.\n\nAny solution will be accepted as long as it does not use more than $10 · W · H$ moves. Each test case is either solvable within this limit, or not solvable at all.\n\n", "hint": "Time limit: 6 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Rubik's Rectangle", "background": "", "description": "一种旨在征服游戏市场的新型益智游戏是魔方与十五数码的融合。棋盘是一个 $H \\times W$ 的框架，上面印有从 $1$ 到 $H \\cdot W$ 的所有数字。\n\n![](/upload/images2/rubik1.png)\n\n唯一允许的移动类型是翻转其中一行或一列。翻转会逆转该行（或列）元素的顺序。下面第三行被翻转：\n\n![](/upload/images2/rubik2.png)\n\n给定一个以某种任意顺序编号的棋盘。确定一系列翻转操作，使棋盘达到整齐排序的位置，如果可能的话。\n\n![](/upload/images2/rubik3.png)", "inputFormat": "输入的第一行包含测试用例的数量 $T$。测试用例的描述如下：\n\n每个测试用例的描述以一个空行开始。下一行包含两个用空格分隔的整数 $W$ 和 $H (1 \\leq W,H \\leq 100)$，分别表示拼图的宽度和高度。接下来的 $H$ 行中的每一行包含 $W$ 个用空格分隔的整数，表示连续瓷砖上印刷的数字。", "outputFormat": "按输入中出现的顺序打印测试用例的答案。对于每个测试用例的输出以单词 POSSIBLE 或 IMPOSSIBLE 开始，具体取决于是否有可能解决拼图。如果存在解决方案，请在同一行打印首先是移动的次数（可能为 $0$），然后是它们的描述，每个描述由一个字母 $R$ 或 $C$ 组成，指定我们是要翻转行还是列，并与要翻转的行或列的索引连接。\n\n只要解决方案不使用超过 $10 \\cdot W \\cdot H$ 次移动，任何解决方案都将被接受。每个测试用例要么在此限制内可解，要么根本不可解。", "hint": "时间限制：6 秒，内存限制：128 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7008", "type": "P", "difficulty": 2, "samples": [["1\ntoot woof wa ow ow ow pa blub blub pa toot pa blub pa pa ow pow toot\ndog goes woof\nfish goes blub\nelephant goes toot\nseal goes ow\nwhat does the fox say?\n", "wa pa pa pa pa pa pow\n"]], "limits": {"time": [1000], "memory": [1048576]}, "tags": ["模拟", "2013", "ICPC", "CERC"], "title": "[CERC2013] What does the fox say?", "background": "", "description": "Determined to discover the ancient mystery—the sound that the fox makes—you went into the forest, armed with a very good digital audio recorder. The forest is, however, full of animals’ voices, and on your recording, many different sounds can be heard. But you are well prepared for your task: you know exactly all the sounds which other animals make. Therefore the rest of the recording—all the unidentified noises—must have been made by the fox.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe first line of each test case contains the recording—words over lower case English alphabet, separated by spaces. Each contains at most 100 letters and there are no more than 100 words. The next few lines are your pre-gathered information about other animals, in the format <animal> goes <sound>. There are no more than 100 animals, their names are not longer than 100 letters each and are actual names of animals in English. There is no fox goes ... among these lines.\n\nThe last line of the test case is exactly the question you are supposed to answer: what does the fox say?", "outputFormat": "For each test case, output one line containing the sounds made by the fox, in the order from the recording. You may assume that the fox was not silent (contrary to popular belief, foxes do not communicate by Morse code).", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n Central Europe Regional Contest (CERC) 2013", "locale": "en", "translations": {"en": {"title": "[CERC2013] What does the fox say?", "background": "", "description": "Determined to discover the ancient mystery—the sound that the fox makes—you went into the forest, armed with a very good digital audio recorder. The forest is, however, full of animals’ voices, and on your recording, many different sounds can be heard. But you are well prepared for your task: you know exactly all the sounds which other animals make. Therefore the rest of the recording—all the unidentified noises—must have been made by the fox.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe first line of each test case contains the recording—words over lower case English alphabet, separated by spaces. Each contains at most 100 letters and there are no more than 100 words. The next few lines are your pre-gathered information about other animals, in the format <animal> goes <sound>. There are no more than 100 animals, their names are not longer than 100 letters each and are actual names of animals in English. There is no fox goes ... among these lines.\n\nThe last line of the test case is exactly the question you are supposed to answer: what does the fox say?", "outputFormat": "For each test case, output one line containing the sounds made by the fox, in the order from the recording. You may assume that the fox was not silent (contrary to popular belief, foxes do not communicate by Morse code).", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n Central Europe Regional Contest (CERC) 2013", "locale": "en"}, "zh-CN": {"title": "[CERC2013] What does the fox say?", "background": "", "description": "### 题目大意\n\n森林里面有很多声响，你想知道有哪些声响是由狐狸发出来的。\n\n已知你搜集到了 $n$ 个声响，并且还知道某些其他动物能够发出的声响，已知如果没有哪一个声响是由其他任何一种动物发出来的话，那这个声响绝对是由狐狸发出来的。现在，给定你这 $n$ 个声响，以及某些其他动物能够发出的声响，请你求出狐狸发出的声响。", "inputFormat": "**本题有多组询问。**\n\n第一行包含一个整数 $T$，表示数据的组数。  \n接下来若干组数据，每组数据由三部分组成：\n\n- 第一行 $n$ 个仅由小写字母组成的字符串，代表搜集到的 $n$ 个声响。\n- 接下来有若干行，代表某些其他动物能够发出的声响。格式为 ``<animal> goes <sound>``，其中 `<animal>` 代表动物的名称（仅由一个字符串组成），`<sound>` 代表这个动物发出的声响（仅由一个字符串组成）。保证不会在这些动物中出现狐狸。\n- 最后一行，一个确定的字符串 ``what does the fox say?``。", "outputFormat": "对于每组数据，输出仅一行，代表狐狸能够发出的声响。", "hint": "$n\\leqslant 100$。  \n保证每个字符串的长度不超过 $100$。\n\nTranslated by Eason_AC  \n2020.10.30", "locale": "zh-CN"}}}
{"pid": "P7009", "type": "P", "difficulty": 5, "samples": [["1\n5\n30 60 20 20 20\n", "80\n"]], "limits": {"time": [8000], "memory": [1048576]}, "tags": ["2013", "ICPC", "CERC"], "title": "[CERC2013] Magical GCD", "background": "", "description": "The Magical GCD of a nonempty sequence of positive integers is defined as the product of its length and the greatest common divisor of all its elements.\n\nGiven a sequence $(a_1, \\ldots , a_ n)$, find the largest possible Magical GCD of its connected subsequences.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe description of each test case starts with a line containing a single integer $n$, $1 \\leq n \\leq 100\\, 000$. The next line contains the sequence $a_1, a_2 , \\ldots , a _ n$, $1 \\leq a_ i \\leq 10^{12}$.", "outputFormat": "For each test case output one line containing a single integer: the largest Magical GCD of a connected subsequence of the input sequence.", "hint": "Time limit: 8000 ms, Memory limit: 1048576 kB. \n\n Central Europe Regional Contest (CERC) 2013", "locale": "en", "translations": {"en": {"title": "[CERC2013] Magical GCD", "background": "", "description": "The Magical GCD of a nonempty sequence of positive integers is defined as the product of its length and the greatest common divisor of all its elements.\n\nGiven a sequence $(a_1, \\ldots , a_ n)$, find the largest possible Magical GCD of its connected subsequences.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe description of each test case starts with a line containing a single integer $n$, $1 \\leq n \\leq 100\\, 000$. The next line contains the sequence $a_1, a_2 , \\ldots , a _ n$, $1 \\leq a_ i \\leq 10^{12}$.", "outputFormat": "For each test case output one line containing a single integer: the largest Magical GCD of a connected subsequence of the input sequence.", "hint": "Time limit: 8000 ms, Memory limit: 1048576 kB. \n\n Central Europe Regional Contest (CERC) 2013", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Magical GCD", "background": "", "description": "一个非空正整数序列的“神奇 GCD”定义为其长度与所有元素的最大公约数的乘积。\n\n给定一个序列 $(a_1, \\ldots , a_n)$，找出其所有连续子序列中可能的最大“神奇 GCD”。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。每个测试用例的描述如下：\n\n每个测试用例的描述以一行开始，包含一个整数 $n$，$1 \\leq n \\leq 100\\,000$。下一行包含序列 $a_1, a_2 , \\ldots , a_n$，$1 \\leq a_i \\leq 10^{12}$。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数：输入序列的一个连续子序列的最大“神奇 GCD”。", "hint": "时间限制：8000 毫秒，内存限制：1048576 kB。\n\nCentral Europe Regional Contest (CERC) 2013。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7010", "type": "P", "difficulty": 5, "samples": [["3\n\nStops: OxfordCircus, PiccadillyCircus, HydeParkCorner, King'sCross, GreenPark, Arsenal, Victoria, Highbury&Islington, LeicesterSquare\nLines: Blue, Cyan\nCyan route: Highbury&Islington, King'sCross, OxfordCircus, GreenPark, Victoria\nBlue route: HydeParkCorner, GreenPark, PiccadillyCircus, LeicesterSquare, King'sCross, Arsenal\nJohny lives at King'sCross\nMichelle lives at GreenPark\n\nStops: OxfordCircus, PiccadillyCircus, HydeParkCorner, King'sCross, GreenPark, Arsenal, Victoria, Highbury&Islington, LeicesterSquare\nLines: Blue, Cyan\nCyan route: Highbury&Islington, King'sCross, OxfordCircus, GreenPark, Victoria\nBlue route: HydeParkCorner, GreenPark, PiccadillyCircus, LeicesterSquare, King'sCross, Arsenal\nJohny lives at PiccadillyCircus\nMichelle lives at LeicesterSquare\n\nStops: OxfordCircus, PiccadillyCircus, HydeParkCorner, King'sCross, GreenPark, Arsenal, Victoria, Highbury&Islington, LeicesterSquare\nLines: Blue, Cyan\nCyan route: Highbury&Islington, King'sCross, OxfordCircus, GreenPark, Victoria\nBlue route: HydeParkCorner, GreenPark, PiccadillyCircus, LeicesterSquare, King'sCross, Arsenal\nJohny lives at Victoria\nMichelle lives at HydeParkCorner\n", "optimal travel from King'sCross to GreenPark: 1 line, 3 minutes\noptimal travel from PiccadillyCircus to LeicesterSquare: 1 line, 1 minute\noptimal travel from Victoria to HydeParkCorner: 2 lines, 7 minutes\n"]], "limits": {"time": [8000, 8000, 8000], "memory": [262144, 262144, 262144]}, "tags": ["2013", "ICPC", "CERC"], "title": "[CERC2013] Subway", "background": "", "description": "\n\nJohny is going to visit his friend Michelle. His dad allowed him to go there on his own by subway. Johny loves traveling by subway and would gladly use this opportunity to spend half a day underground, but his dad obliged him to make as few line changes as possible. There are a lot of stations in the city, and several subway lines connecting them. All trains are perfectly synchronized $-$ the travel between two consecutive stations on every line takes exactly one minute, and changing lines at any station takes no time at all.\n\nGiven the subway map, help Johny to plan his trip so that he can travel for as long as possible, while still following his dad's order.\n\n", "inputFormat": "\n\nFirst line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe description of each test case starts with an empty line. The next two lines begin with the strings Stops: and Lines:, and contain the names (separated by a comma and a space) of all subway stops and lines, respectively. A single line for each subway line follows (in no particular order), beginning with route: and listing the names of the stops along this particular line. The final two lines specify the names of the (different) stations nearby Johny's and Michelle's homes.\n\nIn each test case, there are at most $300 000$ stations and $100 000$ lines, whose total length does not exceed $1 000 000$ . The names of lines and stations are between $1$ and $50$ characters long and can contain letters, digits, hyphens $(-),$ apostrophes $(‘)$ and `and` signs $(&).$ All lines are bidirectional (although changing the direction of travel counts as a line change) and there are no self-crossings.\n\n", "outputFormat": "\n\nPrint the answers to the test cases in the order in which they appear in the input. For each test case, print a single line summarizing the optimal route Johny can take (see example output for exact format). You may assume that such a route always exists.\n\n", "hint": "Time limit: 8 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[CERC2013] Subway", "background": "", "description": "\n\nJohny is going to visit his friend Michelle. His dad allowed him to go there on his own by subway. Johny loves traveling by subway and would gladly use this opportunity to spend half a day underground, but his dad obliged him to make as few line changes as possible. There are a lot of stations in the city, and several subway lines connecting them. All trains are perfectly synchronized $-$ the travel between two consecutive stations on every line takes exactly one minute, and changing lines at any station takes no time at all.\n\nGiven the subway map, help Johny to plan his trip so that he can travel for as long as possible, while still following his dad's order.\n\n", "inputFormat": "\n\nFirst line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe description of each test case starts with an empty line. The next two lines begin with the strings Stops: and Lines:, and contain the names (separated by a comma and a space) of all subway stops and lines, respectively. A single line for each subway line follows (in no particular order), beginning with route: and listing the names of the stops along this particular line. The final two lines specify the names of the (different) stations nearby Johny's and Michelle's homes.\n\nIn each test case, there are at most $300 000$ stations and $100 000$ lines, whose total length does not exceed $1 000 000$ . The names of lines and stations are between $1$ and $50$ characters long and can contain letters, digits, hyphens $(-),$ apostrophes $(‘)$ and `and` signs $(&).$ All lines are bidirectional (although changing the direction of travel counts as a line change) and there are no self-crossings.\n\n", "outputFormat": "\n\nPrint the answers to the test cases in the order in which they appear in the input. For each test case, print a single line summarizing the optimal route Johny can take (see example output for exact format). You may assume that such a route always exists.\n\n", "hint": "Time limit: 8 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Subway", "background": "", "description": "$Johny$ 准备去拜访他的朋友 $Michelle$。他的父亲允许他乘地铁独自去那里。$Johny$ 喜欢乘地铁旅行，并很愿意用这次机会在地铁里呆上半天，但是父亲要求他尽量减少换乘次数。这个城市有很多地铁车站，并有几条地铁线路连接它们。所有列车都完全同步——在每条线上的两个连续地铁站点之间地铁行驶的时间恰好需要 $1$ 分钟，而在该城市的任何一个地铁站点上更改线路是不需要花费时间的。\n\n现在 $Johny$ 有了该城市的地铁线路图，请帮助 $Johny$ 计划行程，以便他可以尽可能长时间的在地铁里呆着，同时还要尽量减少换乘次数。", "inputFormat": "输入的第 $1$ 行为测试数据 $T$ 的数量。\n\n每组测试数据均用空行分隔。接下来的两行以字符串以 $ Stops: $ 和  $Lines: $ 开头，并分别包含所有地铁站和线路的名称（以逗号和空格分隔）。每条地铁线路中的其中一条线路（不分先后）从 $route: $ 开始，并一一列出了该条线路的站点名称。最后两行给定了 $Johny$ 和 $Michelle$ 的家附近的车站的名称。\n\n在每组测试数据中，最多有 $300000$ 个站点以及 $100000$ 条铁路线路，保证其总长度不超过 $1000000$；铁路线路和地铁站点的名称长度均在 $1$ 至 $50$ 个字符之间，其名称中可以含有字母、数字、连字符 `-`、引号 `'` 和特殊符号 `&`。所有的地铁线路都是双向的（改变行进方向即该条线路被改变），并保证没有自交叉。", "outputFormat": "按照在输入中测试数据的顺序来输出每组测试数据的答案。对于每组测试用例，需输出一行来总结 Johny 可以采用的最佳路线（参见样例输出）。假设这样的线路始终存在。\n\n### 输入输出样例\n\n**输入 #1**\n\n```txt\n3\n\nStops: OxfordCircus, PiccadillyCircus, HydeParkCorner, King'sCross, GreenPark, Arsenal, Victoria, Highbury&Islington, LeicesterSquare\nLines: Blue, Cyan\nCyan route: Highbury&Islington, King'sCross, OxfordCircus, GreenPark, Victoria\nBlue route: HydeParkCorner, GreenPark, PiccadillyCircus, LeicesterSquare, King'sCross, Arsenal\nJohny lives at King'sCross\nMichelle lives at GreenPark\n\nStops: OxfordCircus, PiccadillyCircus, HydeParkCorner, King'sCross, GreenPark, Arsenal, Victoria, Highbury&Islington, LeicesterSquare\nLines: Blue, Cyan\nCyan route: Highbury&Islington, King'sCross, OxfordCircus, GreenPark, Victoria\nBlue route: HydeParkCorner, GreenPark, PiccadillyCircus, LeicesterSquare, King'sCross, Arsenal\nJohny lives at PiccadillyCircus\nMichelle lives at LeicesterSquare\n\nStops: OxfordCircus, PiccadillyCircus, HydeParkCorner, King'sCross, GreenPark, Arsenal, Victoria, Highbury&Islington, LeicesterSquare\nLines: Blue, Cyan\nCyan route: Highbury&Islington, King'sCross, OxfordCircus, GreenPark, Victoria\nBlue route: HydeParkCorner, GreenPark, PiccadillyCircus, LeicesterSquare, King'sCross, Arsenal\nJohny lives at Victoria\nMichelle lives at HydeParkCorner\n```\n\n**输出 #1**\n\n```txt\noptimal travel from King'sCross to GreenPark: 1 line, 3 minutes\noptimal travel from PiccadillyCircus to LeicesterSquare: 1 line, 1 minute\noptimal travel from Victoria to HydeParkCorner: 2 lines, 7 minutes\n```", "hint": "时间限制：$8s$\n\n内存限制：$256\\texttt{MB}$", "locale": "zh-CN"}}}
{"pid": "P7011", "type": "P", "difficulty": 6, "samples": [["2\n7 7\n0 -3 2 2 3 -4 0\n1 2\n2 3\n2 4\n1 5\n5 6\n6 7\n3 2\n3 3 -4\n1 3\n2 3\n", "escaped\ntrapped\n"]], "limits": {"time": [8000, 8000], "memory": [131072, 131072]}, "tags": ["2013", "ICPC", "CERC"], "title": "[CERC2013] Escape", "background": "", "description": "\n\nYou hit the emperor lich with full force and slay it. There is a stair leading upwards here. You climb upstairs. You drink from the pool. You feel much better. The karmic lizard punches through your armor and hits you. You die...\n\nAfter an epic fight with the emperor lich, the hero struggles to escape the dungeon consisting of $n$ chambers and $n − 1$ corridors connecting them. He starts in chamber number $1$ and must reach chamber number $t$ , moving only along the corridors. All chambers are reachable from chamber number $1$ . Bruised after the last fight, the hero starts the journey with $0$ hit-points $(HP).$ These points represent his health $-$ if ever they fall below zero, the hero's story ends there as a tragic one.\n\nIn some chambers there are monsters $-$ a monster must be fought, and it always manages to take some of the hero's HP. In some other chambers there are magic pools $-$ every pool restores some number of the hit-points. There is no upper limit on the hero's health. Every chamber can be visited multiple times, but the gain or loss of HP happens only once, on the very first visit.\n\nDetermine whether the hero can escape the dungeon alive.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe first line of each test case contains two integers: the number of chambers $n , 2 \\le n \\le 200 000$ , and the number of the exit chamber $t , 2 \\le t \\le n$ . The second line contains $n$ space separated integers between $-10^{6}$ and $10^{6} -$ the i-th of them denotes the HP gain in the i-th chamber (negative denotes a monster, positive $-$ a pool, and zero means that the chamber is empty). The first chamber does not contain a monster, but a pool is possible there. The exit chamber may contain a pool or a monster, and the monster will have to be fought before escaping.\n\nThe next $n−1$ lines contain the descriptions of corridors. Each one contains a pair of integers $-$ the ends of a corridor.\n\n", "outputFormat": "\n\nFor each test case print a single line containing the word escaped if escape is possible, or trapped otherwise.\n\n", "hint": "Time limit: 8 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[CERC2013] Escape", "background": "", "description": "\n\nYou hit the emperor lich with full force and slay it. There is a stair leading upwards here. You climb upstairs. You drink from the pool. You feel much better. The karmic lizard punches through your armor and hits you. You die...\n\nAfter an epic fight with the emperor lich, the hero struggles to escape the dungeon consisting of $n$ chambers and $n − 1$ corridors connecting them. He starts in chamber number $1$ and must reach chamber number $t$ , moving only along the corridors. All chambers are reachable from chamber number $1$ . Bruised after the last fight, the hero starts the journey with $0$ hit-points $(HP).$ These points represent his health $-$ if ever they fall below zero, the hero's story ends there as a tragic one.\n\nIn some chambers there are monsters $-$ a monster must be fought, and it always manages to take some of the hero's HP. In some other chambers there are magic pools $-$ every pool restores some number of the hit-points. There is no upper limit on the hero's health. Every chamber can be visited multiple times, but the gain or loss of HP happens only once, on the very first visit.\n\nDetermine whether the hero can escape the dungeon alive.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe first line of each test case contains two integers: the number of chambers $n , 2 \\le n \\le 200 000$ , and the number of the exit chamber $t , 2 \\le t \\le n$ . The second line contains $n$ space separated integers between $-10^{6}$ and $10^{6} -$ the i-th of them denotes the HP gain in the i-th chamber (negative denotes a monster, positive $-$ a pool, and zero means that the chamber is empty). The first chamber does not contain a monster, but a pool is possible there. The exit chamber may contain a pool or a monster, and the monster will have to be fought before escaping.\n\nThe next $n−1$ lines contain the descriptions of corridors. Each one contains a pair of integers $-$ the ends of a corridor.\n\n", "outputFormat": "\n\nFor each test case print a single line containing the word escaped if escape is possible, or trapped otherwise.\n\n", "hint": "Time limit: 8 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Escape", "background": "", "description": "### 题目背景\n\n在经历和巫妖王史诗级别的战斗后，英雄们想要从地牢中逃走。\n\n\n这个地牢是由 $n$ 个房间和 $n-1$ 条走廊连接组成的树状结构，英雄一开始在 $1$ 号房间，而且他只有抵达 $t$ 号房间才能逃离这个地牢。从 $1$ 号房间出发可以抵达任何一个其它的房间，可惜的是，在经历激烈的战斗后，英雄的精力使用完了，所以一开始该英雄的精力为 $0$，并且一旦英雄的精力低于 $0$，那么英雄就会当场逝世，以悲剧结束。在这些房间中，里面暗藏玄机，里面可能有怪兽，也有可能是可以补充精力的魔泉，当然也可能什么也没有，如果是怪兽，那么英雄就必须与它战斗从而消耗一些精力，如果是魔泉，那么英雄可以补充自己的精力。所有的怪兽只会战斗一次，所有的魔泉只能使用一次。（换句话说就是所有的精力的上升或者下降只会发生在第一次访问这个房间的时候）\n\n英雄的精力没有上限，每一个房间都可以反复走多次。", "inputFormat": "输入包括多组数据，第一行表示测试的数据的组数 $T$。\n\n每一个测试用例的第 $1$ 行都包括两个整数 $n$ $(2 \\le n \\le 200000 )$ 和 $t$ $(2 \\le t \\le n)$，分别表示地牢的房间的数量和英雄必须到达的房间号。第二行是 $n$ 个整数，代表了 $n$ 个房间的情况，其中第 $i$ 个数代表了第 $i$ 个房间情况，所有的数的绝对值都不大于 $10^{6}$。如果该数是负数，表明该房间里面有怪兽，精力会减少，如果是正数，表明房间里面有魔泉，可以补充精力，如果是 $0$，表明房间里面空空如也。注意 $1$ 号房间不会有怪兽，但是有可能会有魔泉，$t$ 号房间可能怪兽或者魔泉，如果是怪兽，那么英雄必须要击败怪兽才能逃离。\n\n在接下来的 $n-1$ 行中，每行两个整数 $a$ 和 $b$ ，表示房间 $a, b$ 之间有一条走廊连接。", "outputFormat": "对于每一个测试用例都单行输出：\n\n如果英雄能够逃脱，那么输出 `escaped`，否则输出 `trapped`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7012", "type": "P", "difficulty": 2, "samples": [["2\n\n.#.#.#.#.#\n#.#.#.#.#.\n.#.#.B.#.#\n#.#.#.#.#.\n.#.#.B.#.#\n#.#.W.#.#.\n.#.#.#.#.#\n#.#.#.B.#.\n.#.#.#.#.#\n#.#.#.#.#.\n\n.#.#.#.#.#\n#.#.#.#.#.\n.#.#.B.#.#\n#.B.#.B.#.\n.#.#.B.#.#\n#.B.W.#.#.\n.#.B.B.#.#\n#.#.#.#.#.\n.#.B.B.#.#\n#.#.#.#.#.\n", "2\n4\n"]], "limits": {"time": [2000, 2000], "memory": [262144, 262144]}, "tags": ["搜索", "2013", "广度优先搜索 BFS", "深度优先搜索 DFS", "ICPC", "CERC"], "title": "[CERC2013] Draughts", "background": "", "description": "\n\nDraughts (or checkers) is a game played by two opponents, on opposite sides of a $10 \\times 10$ board. The board squares are painted black and white, as on a classic chessboard. One player controls the dark, and the other the light pieces. The pieces can only occupy the black squares. The players make their moves alternately, each moving one of his own pieces.\n\nThe most interesting type of move is capturing: if a diagonally adjacent square contains an opponent's piece, it may be captured (and removed from the game) by jumping over it to the unoccupied square immediately beyond it. It is allowed to make several consecutive captures in one move, if they are all made with a single piece. It is also legal to capture by either forward or backward jumps.\n\n![](/upload/images2/dr.png)\n\nThe board before and after a single move with two captures.\n\nYou are given a draughts position. It is the light player's turn. Compute the maximal possible number of dark pieces he can capture in his next move.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nEach test case starts with an empty line. The following $10$ lines of $10$ characters each describe the board squares. The characters $#$ and . denote empty black and white squares, $W$ denotes a square with a light piece, $B -$ a square with a dark piece.\n\n", "outputFormat": "\n\nFor each test case print a single line containing the maximal possible number of captures. If there is no legal move (for example, there are no light pieces on the board), simply output $0$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[CERC2013] Draughts", "background": "", "description": "\n\nDraughts (or checkers) is a game played by two opponents, on opposite sides of a $10 \\times 10$ board. The board squares are painted black and white, as on a classic chessboard. One player controls the dark, and the other the light pieces. The pieces can only occupy the black squares. The players make their moves alternately, each moving one of his own pieces.\n\nThe most interesting type of move is capturing: if a diagonally adjacent square contains an opponent's piece, it may be captured (and removed from the game) by jumping over it to the unoccupied square immediately beyond it. It is allowed to make several consecutive captures in one move, if they are all made with a single piece. It is also legal to capture by either forward or backward jumps.\n\n![](/upload/images2/dr.png)\n\nThe board before and after a single move with two captures.\n\nYou are given a draughts position. It is the light player's turn. Compute the maximal possible number of dark pieces he can capture in his next move.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nEach test case starts with an empty line. The following $10$ lines of $10$ characters each describe the board squares. The characters $#$ and . denote empty black and white squares, $W$ denotes a square with a light piece, $B -$ a square with a dark piece.\n\n", "outputFormat": "\n\nFor each test case print a single line containing the maximal possible number of captures. If there is no legal move (for example, there are no light pieces on the board), simply output $0$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Draughts", "background": "", "description": "国际跳棋（或称跳棋）是一种由两个对手在 $10 \\times 10$ 的棋盘上进行的游戏。棋盘上的方块是黑色或白色的，就像经典的国际象棋棋盘一样。玩家一方控制黑棋，另一方控制白棋。棋子只能占据黑色的格子。棋手们交替走棋，各自移动自己的一个棋子。\n\n最有趣的走法是吃掉：如果一个对角线相邻的格子里有对手的棋子，可以通过跳过它到紧挨着它的未被占领的格子来吃掉（并从游戏中删除被吃掉的这个棋子）。允许在一步棋中用一个棋子连续吃掉几个棋子。通过向前或向后的跳跃来吃子也是合法的。\n\n你会得到一个棋子的位置。现在轮到白方了。计算他在下一步棋中能吃掉的最大可能的黑棋数量。", "inputFormat": "输入的第一行包含测试用例 $T$ 的数量。接下来是测试用例的描述。\n\n每个测试用例以空行开始。接下来的 10 行，每行都有 10 个字符，描述棋盘的方格。字符 # 和 . 表示空的黑色和白色方块，W 表示有浅色棋子的方块，B 表示有深色棋子的方块。", "outputFormat": "对于每个测试案例，输出一行一个整数，代表最多可以吃黑子的个数。如果没有合法的棋步（例如，棋盘上没有白棋），只需输出 0。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7013", "type": "P", "difficulty": 7, "samples": [["1\n3\n1 6\n2 3\n4 5\n", "1\n2 3\n1 6\n4 5\n"]], "limits": {"time": [10000, 10000], "memory": [131072, 131072]}, "tags": ["2013", "Special Judge", "ICPC", "CERC"], "title": "[CERC2013] History course", "background": "", "description": "You are to give a series of lectures on important historical events, one event per lecture, in some order. Each event lasted for some time interval $[a_i, b_i].$ We say that two events are related if their intervals have a common point. It would be convenient to schedule lectures on related events close to each other. Moreover, lectures on unrelated events should be given in the order in which the events have taken place (if an event A preceded an unrelated event $B$ , then the lecture on A should precede the lecture on $B)$ .\n\nFind the minimum integer $k \\ge 0$ and an order of the lectures such that any two related events are scheduled at most $k$ lectures apart from each other (lectures number $i$ and $j$ are considered to be $|i−j|$ lectures apart).", "inputFormat": "\nThe first line of input contains the number of test cases $t$ . The descriptions of the test cases follow:\n\nThe first line of each test case contains the number $n (1 \\le n \\le 50000)$ . Each of the next $n$ lines contains two integers $a_i$ and $b_i (-10^9  \\le a_i \\le b_i \\le 10^9) $ - the ends of the i-th interval. The intervals are pairwise different.", "outputFormat": "\nPrint the answers to the test cases in the order in which they appear in the input. The first line of the answer to each test case should contain the minimum value of $k$ . The next $n$ lines should list the intervals (in the same format as in the input) in an order such that any two related events are scheduled at most $k$ lectures apart. Remember to put any unrelated intervals in the proper order! ", "hint": "Time limit: 10 s, Memory limit: 128 MB. \n\n感谢 [hht2006](/user/175829) 提供的 Special Judge。", "locale": "en", "translations": {"en": {"title": "[CERC2013] History course", "background": "", "description": "You are to give a series of lectures on important historical events, one event per lecture, in some order. Each event lasted for some time interval $[a_i, b_i].$ We say that two events are related if their intervals have a common point. It would be convenient to schedule lectures on related events close to each other. Moreover, lectures on unrelated events should be given in the order in which the events have taken place (if an event A preceded an unrelated event $B$ , then the lecture on A should precede the lecture on $B)$ .\n\nFind the minimum integer $k \\ge 0$ and an order of the lectures such that any two related events are scheduled at most $k$ lectures apart from each other (lectures number $i$ and $j$ are considered to be $|i−j|$ lectures apart).", "inputFormat": "\nThe first line of input contains the number of test cases $t$ . The descriptions of the test cases follow:\n\nThe first line of each test case contains the number $n (1 \\le n \\le 50000)$ . Each of the next $n$ lines contains two integers $a_i$ and $b_i (-10^9  \\le a_i \\le b_i \\le 10^9) $ - the ends of the i-th interval. The intervals are pairwise different.", "outputFormat": "\nPrint the answers to the test cases in the order in which they appear in the input. The first line of the answer to each test case should contain the minimum value of $k$ . The next $n$ lines should list the intervals (in the same format as in the input) in an order such that any two related events are scheduled at most $k$ lectures apart. Remember to put any unrelated intervals in the proper order! ", "hint": "Time limit: 10 s, Memory limit: 128 MB. \n\n感谢 [hht2006](/user/175829) 提供的 Special Judge。", "locale": "en"}, "zh-CN": {"title": "[CERC2013] History course", "background": "", "description": "你需要按某种顺序为一系列重要历史事件安排讲座，每个讲座对应一个事件。每个事件持续一段时间区间 $[a_i, b_i]$。如果两个事件的时间区间有公共点，则称这两个事件是相关的。为了方便起见，安排相关事件的讲座时应尽量靠近。此外，对于不相关的事件，讲座应按照事件发生的顺序进行（如果事件 A 先于不相关事件 $B$ 发生，那么 A 的讲座应先于 B 的讲座）。找到最小的整数 $k \\ge 0$ 和一个讲座顺序，使得任何两个相关事件的讲座之间的间隔最多为 $k$（讲座编号 $i$ 和 $j$ 之间的间隔被认为是 $|i−j|$）。", "inputFormat": "输入的第一行包含测试用例的数量 $t$。每个测试用例的描述如下：每个测试用例的第一行包含一个整数 $n (1 \\le n \\le 50000)$。接下来的 $n$ 行中的每一行包含两个整数 $a_i$ 和 $b_i (-10^9 \\le a_i \\le b_i \\le 10^9)$，表示第 $i$ 个区间的两个端点。所有区间是两两不同的。", "outputFormat": "按输入中出现的顺序输出每个测试用例的答案。每个测试用例答案的第一行应包含最小值 $k$。接下来的 $n$ 行应按顺序列出区间（格式与输入相同），使得任何两个相关事件的讲座之间的间隔最多为 $k$。记得将任何不相关的区间按正确的顺序排列！", "hint": "时间限制：10 秒，内存限制：128 MB。感谢 [hht2006](/user/175829) 提供的 Special Judge。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7014", "type": "P", "difficulty": 6, "samples": [["3\n\n2\n0 0 0 0 10 10\n-5 5 15 5 5 25\n\n5\n0 0 0 0 10 10\n-5 5 6 5 5 16\n-5 5 -6 5 5 4\n-5 6 5 5 16 5\n-5 -6 5 5 4 5\n\n3\n0 0 0 3 0 -3\n1 -1 -1 1 2 -4\n-1 -2 -2 2 1 -2\n", "NO\nYES\nYES\n"]], "limits": {"time": [10000, 10000], "memory": [262144, 262144]}, "tags": ["2013", "ICPC", "CERC"], "title": "[CERC2013] Chain & Co.", "background": "", "description": "\n\nChain $&$ Co. specializes in producing infinitely strong chains. Because of their high quality products, they are quickly gaining market share. This leads to new challenges, some of which they could have never imagined before. Like, for example, automatic verification of link endurance with a computer program, which you are supposed to write.\n\nThe company produces links of equal size. Each link is an infinitely thin square frame in three dimensions (made of four infinitely thin segments).\n\nDuring tests all links are $axis-aligned^{1}$ and placed so that no two frames touch. To make a proper strength test, two sets of links A and $B$ are forged so that every link of A is inseparable from every link of $B$ (being inseparable means that they cannot be moved apart without breaking one of them).\n\nYou stumble upon some links (axis-aligned, pairwise disjoint). Are they in proper testing position? In other words, can they be divided into two non-empty sets A and $B$ with the desired property?\n\n$^{1}Axis-aligned$ means that all segments are parallel to either $X , Y$ , or $Z$ axis.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe description of each test case starts with an empty line. The next line contains an integer $n , 1 \\le n \\le 10^{6} -$ the number of links in the chain. Each of the next $n$ lines contains $6$ space separated integers $x_{i}, y_{i}, z_{i}, x_{i}', y_{i}', z_{i}',$ all between $-10^{9}$ and $10^{9} -$ the coordinates of two opposite corners of the i-th link.\n\n", "outputFormat": "\n\nFor each test case, print a single line containing the word YES if the set is in proper testing position, or NO otherwise.\n\n", "hint": "Time limit: 10 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[CERC2013] Chain & Co.", "background": "", "description": "\n\nChain $&$ Co. specializes in producing infinitely strong chains. Because of their high quality products, they are quickly gaining market share. This leads to new challenges, some of which they could have never imagined before. Like, for example, automatic verification of link endurance with a computer program, which you are supposed to write.\n\nThe company produces links of equal size. Each link is an infinitely thin square frame in three dimensions (made of four infinitely thin segments).\n\nDuring tests all links are $axis-aligned^{1}$ and placed so that no two frames touch. To make a proper strength test, two sets of links A and $B$ are forged so that every link of A is inseparable from every link of $B$ (being inseparable means that they cannot be moved apart without breaking one of them).\n\nYou stumble upon some links (axis-aligned, pairwise disjoint). Are they in proper testing position? In other words, can they be divided into two non-empty sets A and $B$ with the desired property?\n\n$^{1}Axis-aligned$ means that all segments are parallel to either $X , Y$ , or $Z$ axis.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe description of each test case starts with an empty line. The next line contains an integer $n , 1 \\le n \\le 10^{6} -$ the number of links in the chain. Each of the next $n$ lines contains $6$ space separated integers $x_{i}, y_{i}, z_{i}, x_{i}', y_{i}', z_{i}',$ all between $-10^{9}$ and $10^{9} -$ the coordinates of two opposite corners of the i-th link.\n\n", "outputFormat": "\n\nFor each test case, print a single line containing the word YES if the set is in proper testing position, or NO otherwise.\n\n", "hint": "Time limit: 10 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Chain & Co.", "background": "", "description": "Chain $&$ Co. 专注于生产无限强度的链条。由于其高质量的产品，他们迅速占领了市场。这带来了新的挑战，其中一些是他们之前从未想象过的。例如，使用计算机程序自动验证链环的耐久性，而这正是你需要编写的程序。\n\n公司生产的链环大小相同。每个链环都是三维空间中的一个无限薄的正方形框架（由四个无限薄的线段构成）。\n\n在测试过程中，所有链环都是“轴对齐的”并且放置得没有两个框架接触。为了进行适当的强度测试，锻造了两个链环集合 A 和 $B$，使得 A 的每个链环都与 B 的每个链环不可分离（不可分离意味着它们不能在不破坏其中一个的情况下分开）。\n\n你偶然发现了一些链环（轴对齐，成对不相交）。它们是否处于适当的测试位置？换句话说，它们能否被划分为两个非空集合 A 和 $B$，并具有所需的特性？\n\n“轴对齐”意味着所有线段都平行于 $X, Y$ 或 $Z$ 轴。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来的部分是测试用例的描述：\n\n每个测试用例的描述以一个空行开始。下一行包含一个整数 $n, 1 \\le n \\le 10^{6}$ —— 链条中的链环数量。接下来的 $n$ 行中的每一行包含 $6$ 个以空格分隔的整数 $x_{i}, y_{i}, z_{i}, x_{i}', y_{i}', z_{i}'$，所有数值都在 $-10^{9}$ 和 $10^{9}$ 之间 —— 这是第 $i$ 个链环两个对角的坐标。", "outputFormat": "对于每个测试用例，打印一行，包含单词 YES 如果集合处于适当的测试位置，否则打印 NO。", "hint": "时间限制：10 秒，内存限制：128 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7015", "type": "P", "difficulty": 4, "samples": [["2\n6\n5 4 6 3 2 1\n5\n1 2 3 4 5\n", "5\n1 2\n4 5\n5 6\n4 5\n1 6\n0\n"]], "limits": {"time": [4000], "memory": [131072]}, "tags": ["2013", "Special Judge", "ICPC", "CERC"], "title": "[CERC2013] Crane", "background": "", "description": "\n\nThere are $n$ crates waiting to be loaded onto a ship. The crates are numbered $1 , 2 , \\cdots , n$ , the numbers determining the order of loading. Unfortunately, someone messed up the transit and the crates are standing in a row in an arbitrary order. As there is only limited space in the dock area, you must sort the crates by swapping some of them.\n\nYou are given a crane that works in the following way: you select a connected interval of crates of even length. The crane then exchanges the first half of the interval with the second half. The order inside both halves remains unchanged. Determine the sequence of crane moves that reorders the crates properly.\n\nThe crane's software has a bug: the move counter is a $9-based$ (not $10-based,$ as you might think) integer with at most $6$ digits. Therefore, the crane stops working (and has to be serviced) after $9^{6} = 531441$ moves. Your solution must fit within this limit.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nEach test case starts with an integer $n , 1 \\le n \\le 10 000$ , denoting the number of crates. In the next line a permutation of numbers ${1 , 2 , \\cdots $ , n} follows.\n\n", "outputFormat": "\n\nFor each test case print a single line containing $m -$ the number of swaps $-$ followed by $m$ lines describing the swaps in the order in which they should be performed. A single swap is described by two numbers $-$ the indices of the first and the last element in the interval to be exchanged. Do not follow the crane's strange software design $-$ use standard decimal numeral system.\n\n", "hint": "Time limit: 4 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[CERC2013] Crane", "background": "", "description": "\n\nThere are $n$ crates waiting to be loaded onto a ship. The crates are numbered $1 , 2 , \\cdots , n$ , the numbers determining the order of loading. Unfortunately, someone messed up the transit and the crates are standing in a row in an arbitrary order. As there is only limited space in the dock area, you must sort the crates by swapping some of them.\n\nYou are given a crane that works in the following way: you select a connected interval of crates of even length. The crane then exchanges the first half of the interval with the second half. The order inside both halves remains unchanged. Determine the sequence of crane moves that reorders the crates properly.\n\nThe crane's software has a bug: the move counter is a $9-based$ (not $10-based,$ as you might think) integer with at most $6$ digits. Therefore, the crane stops working (and has to be serviced) after $9^{6} = 531441$ moves. Your solution must fit within this limit.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nEach test case starts with an integer $n , 1 \\le n \\le 10 000$ , denoting the number of crates. In the next line a permutation of numbers ${1 , 2 , \\cdots $ , n} follows.\n\n", "outputFormat": "\n\nFor each test case print a single line containing $m -$ the number of swaps $-$ followed by $m$ lines describing the swaps in the order in which they should be performed. A single swap is described by two numbers $-$ the indices of the first and the last element in the interval to be exchanged. Do not follow the crane's strange software design $-$ use standard decimal numeral system.\n\n", "hint": "Time limit: 4 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Crane", "background": "", "description": "有 $n$ 个箱子等着装上船。箱子的编号是 $a_1,a_2,\\cdots,a_n$。你的工作是通过若干次交换，将它们从小到大排列。你每次可以选择一个区间，将它的前半部分与后半部分交换，两半内部的顺序保持不变。你最多可以交换 $531441$ 次。", "inputFormat": "第一行输入包含数据组数 $T$。\n\n接下来 $2\\times T$ 行，表示 $T$ 组数据。每组数据的第一行为 $n\\ (1 \\leq n \\leq 10000)$，表示箱子的数量。第二行为 $n$ 个正整数$a_1,a_2,\\cdots,a_n $ ，表示箱子的编号。", "outputFormat": "对于每组数据，首先输出一个数 $m$ ，表示交换的次数。 然后输出 $m$ 行，按照顺序描述每一次交换。对于每次交换，输出要交换的区间中第一个元素和最后一个元素的下标。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7016", "type": "P", "difficulty": 6, "samples": [["2\n4 619\n5 25 125 6\n3 101\n5 11 29\n", "30\n83\n"]], "limits": {"time": [6000], "memory": [262144]}, "tags": ["2013", "ICPC", "CERC"], "title": "[CERC2013] Captain Obvious and the Rabbit-Man", "background": "", "description": "\n\nIt's you, Captain Obvious! - cried the evil Rabbit-Man - you came here to foil my evil plans!\n\nYes, it's me.  - said Captain Obvious.\n\nBut... how did you know that $I$ would be here, on $625$ Sunflower Street?! Did you crack my evil code?\n\nI did. Three days ago, you robbed a bank on $5$ Sunflower Street, the next day you blew up $25$ Sunflower Street, and yesterday you left quite a mess under number $125$ . These are all powers of $5$ . And last year you pulled a similar stunt with powers of $13$ . You seem to have a knack for Fibonacci numbers, Rabbit-Man. \n\nThat's not over! $I$ will learn... arithmetics! - Rabbit-Man screamed as he was dragged into custody - You will never know what to expect... Owww! Not my ears, you morons!\n\nMaybe, but right now you are being arrested.  - Captain added proudly.\n\nUnfortunately, Rabbit-Man has now indeed learned some more advanced arithmetics. To understand it, let us define the sequence $F_n$ (being not completely unlike the Fibonacci sequence):\n\n$F_{1} = 1$ ,\n\n$F_{2} = 2$ ,\n\n$F_{n} = F_{n-1} + F_{n-2}$ for $n \\ge 3$ .\n\nRabbit-Man has combined all his previous evil ideas into one master plan. On the i-th day, he does a malicious act on the spot number $p(i)$ , defined as follows:\n\n$p(i) = a_{1}·F_{1}^{i} + a_{2}·F_{2}^{i} + \\cdots + a_{k}·F_{k}^{i}.$\n\nThe number $k$ and the integer coefficients $a_1 , \\cdots $ , ak are fixed. Captain Obvious learned $k$ , but does not know the coefficients. Given $p(1) , p(2) , \\cdots , p(k)$ , help him to determine p(k $+ 1)$ . To avoid overwhelmingly large numbers, do all the calculations modulo a fixed prime number $M$ . You may assume that $F_1 , F_2 , \\cdots , F_n$ are pairwise distinct modulo $M$ . You may also assume that there always exists a unique solution for the given input.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe first line of each test case contains two integers $k$ and $M , 1 \\le k \\le 4000 , 3 \\le M \\le 10^{9}.$ The second line contains $k$ space-separated integers $-$ the values of $p(1) , p(2) , \\cdots , p(k)$ modulo $M$ .\n\n", "outputFormat": "\n\nPrint the answers to the test cases in the order in which they appear in the input. For each test case print a single line containing one integer: the value of $p(k + 1)$ modulo $M$ .\n\n", "hint": "Time limit: 6 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[CERC2013] Captain Obvious and the Rabbit-Man", "background": "", "description": "\n\nIt's you, Captain Obvious! - cried the evil Rabbit-Man - you came here to foil my evil plans!\n\nYes, it's me.  - said Captain Obvious.\n\nBut... how did you know that $I$ would be here, on $625$ Sunflower Street?! Did you crack my evil code?\n\nI did. Three days ago, you robbed a bank on $5$ Sunflower Street, the next day you blew up $25$ Sunflower Street, and yesterday you left quite a mess under number $125$ . These are all powers of $5$ . And last year you pulled a similar stunt with powers of $13$ . You seem to have a knack for Fibonacci numbers, Rabbit-Man. \n\nThat's not over! $I$ will learn... arithmetics! - Rabbit-Man screamed as he was dragged into custody - You will never know what to expect... Owww! Not my ears, you morons!\n\nMaybe, but right now you are being arrested.  - Captain added proudly.\n\nUnfortunately, Rabbit-Man has now indeed learned some more advanced arithmetics. To understand it, let us define the sequence $F_n$ (being not completely unlike the Fibonacci sequence):\n\n$F_{1} = 1$ ,\n\n$F_{2} = 2$ ,\n\n$F_{n} = F_{n-1} + F_{n-2}$ for $n \\ge 3$ .\n\nRabbit-Man has combined all his previous evil ideas into one master plan. On the i-th day, he does a malicious act on the spot number $p(i)$ , defined as follows:\n\n$p(i) = a_{1}·F_{1}^{i} + a_{2}·F_{2}^{i} + \\cdots + a_{k}·F_{k}^{i}.$\n\nThe number $k$ and the integer coefficients $a_1 , \\cdots $ , ak are fixed. Captain Obvious learned $k$ , but does not know the coefficients. Given $p(1) , p(2) , \\cdots , p(k)$ , help him to determine p(k $+ 1)$ . To avoid overwhelmingly large numbers, do all the calculations modulo a fixed prime number $M$ . You may assume that $F_1 , F_2 , \\cdots , F_n$ are pairwise distinct modulo $M$ . You may also assume that there always exists a unique solution for the given input.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe first line of each test case contains two integers $k$ and $M , 1 \\le k \\le 4000 , 3 \\le M \\le 10^{9}.$ The second line contains $k$ space-separated integers $-$ the values of $p(1) , p(2) , \\cdots , p(k)$ modulo $M$ .\n\n", "outputFormat": "\n\nPrint the answers to the test cases in the order in which they appear in the input. For each test case print a single line containing one integer: the value of $p(k + 1)$ modulo $M$ .\n\n", "hint": "Time limit: 6 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Captain Obvious and the Rabbit-Man", "background": "", "description": "“是你，显而易见船长！”邪恶的兔子人喊道，“你来这里是为了阻止我的邪恶计划！”\n\n“是的，是我。”显而易见船长说道。\n\n“但是……你怎么知道我会在向日葵街 625 号？！你破解了我的邪恶代码吗？”\n\n“我破解了。三天前，你抢劫了向日葵街 5 号的银行，第二天你炸毁了向日葵街 25 号，昨天你在 125 号制造了一场混乱。这些都是 5 的幂。而去年你用 13 的幂做了类似的事情。你似乎对斐波那契数有一种天赋，兔子人。”\n\n“这还没完！我会学习……算术！”兔子人被拖入拘留时尖叫道，“你永远不知道会发生什么……哎哟！别碰我的耳朵，你们这些笨蛋！”\n\n“也许吧，但现在你被捕了。”船长自豪地补充道。\n\n不幸的是，兔子人现在确实学会了一些更高级的算术。为了理解它，让我们定义序列 $F_n$（与斐波那契序列不完全相似）：\n\n$F_{1} = 1$，\n\n$F_{2} = 2$，\n\n$F_{n} = F_{n-1} + F_{n-2}$ 对于 $n \\ge 3$。\n\n兔子人将他所有以前的邪恶想法结合成一个总计划。在第 $i$ 天，他在编号为 $p(i)$ 的地方进行恶意行为，定义如下：\n\n$p(i) = a_{1}\\cdot F_{1}^{i} + a_{2}\\cdot F_{2}^{i} + \\cdots + a_{k}\\cdot F_{k}^{i}$。\n\n数字 $k$ 和整数系数 $a_1 , \\cdots , a_k$ 是固定的。显而易见船长知道 $k$，但不知道系数。给定 $p(1), p(2), \\cdots, p(k)$，帮助他确定 $p(k + 1)$。为了避免过大的数字，所有计算都在一个固定的素数 $M$ 模下进行。你可以假设 $F_1, F_2, \\cdots, F_n$ 在模 $M$ 下是两两不同的。你也可以假设给定的输入总是存在唯一解。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来的每个测试用例描述如下：\n\n每个测试用例的第一行包含两个整数 $k$ 和 $M$，其中 $1 \\le k \\le 4000, 3 \\le M \\le 10^{9}$。第二行包含 $k$ 个以空格分隔的整数——$p(1), p(2), \\cdots, p(k)$ 模 $M$ 的值。", "outputFormat": "按照输入中出现的顺序打印测试用例的答案。对于每个测试用例，打印一行包含一个整数：$p(k + 1)$ 模 $M$ 的值。", "hint": "时间限制：6 秒，内存限制：128 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7017", "type": "P", "difficulty": 4, "samples": [["2\n628\naa\naz\nba\nbb\nbc\nbd\nbe\nbf\nbg\nbh\nbi\nbj\nbk\nbl\nbm\nbn\nbo\nbp\nbq\nbr\nbs\nbt\nbu\nbv\nbw\nbx\nby\nca\ncb\ncc\ncd\nce\ncf\ncg\nch\nci\ncj\nck\ncl\ncm\ncn\nco\ncp\ncq\ncr\ncs\nct\ncu\ncv\ncw\ncx\ncy\nda\ndb\ndc\ndd\nde\ndf\ndg\ndh\ndi\ndj\ndk\ndl\ndm\ndn\ndo\ndp\ndq\ndr\nds\ndt\ndu\ndv\ndw\ndx\ndy\nea\neb\nec\ned\nee\nef\neg\neh\nei\nej\nek\nel\nem\nen\neo\nep\neq\ner\nes\net\neu\nev\new\nex\ney\nfa\nfb\nfc\nfd\nfe\nff\nfg\nfh\nfi\nfj\nfk\nfl\nfm\nfn\nfo\nfp\nfq\nfr\nfs\nft\nfu\nfv\nfw\nfx\nfy\nga\ngb\ngc\ngd\nge\ngf\ngg\ngh\ngi\ngj\ngk\ngl\ngm\ngn\ngo\ngp\ngq\ngr\ngs\ngt\ngu\ngv\ngw\ngx\ngy\nha\nhb\nhc\nhd\nhe\nhf\nhg\nhh\nhi\nhj\nhk\nhl\nhm\nhn\nho\nhp\nhq\nhr\nhs\nht\nhu\nhv\nhw\nhx\nhy\nia\nib\nic\nid\nie\nif\nig\nih\nii\nij\nik\nil\nim\nin\nio\nip\niq\nir\nis\nit\niu\niv\niw\nix\niy\nja\njb\njc\njd\nje\njf\njg\njh\nji\njj\njk\njl\njm\njn\njo\njp\njq\njr\njs\njt\nju\njv\njw\njx\njy\nka\nkb\nkc\nkd\nke\nkf\nkg\nkh\nki\nkj\nkk\nkl\nkm\nkn\nko\nkp\nkq\nkr\nks\nkt\nku\nkv\nkw\nkx\nky\nla\nlb\nlc\nld\nle\nlf\nlg\nlh\nli\nlj\nlk\nll\nlm\nln\nlo\nlp\nlq\nlr\nls\nlt\nlu\nlv\nlw\nlx\nly\nma\nmb\nmc\nmd\nme\nmf\nmg\nmh\nmi\nmj\nmk\nml\nmm\nmn\nmo\nmp\nmq\nmr\nms\nmt\nmu\nmv\nmw\nmx\nmy\nna\nnb\nnc\nnd\nne\nnf\nng\nnh\nni\nnj\nnk\nnl\nnm\nnn\nno\nnp\nnq\nnr\nns\nnt\nnu\nnv\nnw\nnx\nny\noa\nob\noc\nod\noe\nof\nog\noh\noi\noj\nok\nol\nom\non\noo\nop\noq\nor\nos\not\nou\nov\now\nox\noy\npa\npb\npc\npd\npe\npf\npg\nph\npi\npj\npk\npl\npm\npn\npo\npp\npq\npr\nps\npt\npu\npv\npw\npx\npy\nqa\nqb\nqc\nqd\nqe\nqf\nqg\nqh\nqi\nqj\nqk\nql\nqm\nqn\nqo\nqp\nqq\nqr\nqs\nqt\nqu\nqv\nqw\nqx\nqy\nra\nrb\nrc\nrd\nre\nrf\nrg\nrh\nri\nrj\nrk\nrl\nrm\nrn\nro\nrp\nrq\nrr\nrs\nrt\nru\nrv\nrw\nrx\nry\nsa\nsb\nsc\nsd\nse\nsf\nsg\nsh\nsi\nsj\nsk\nsl\nsm\nsn\nso\nsp\nsq\nsr\nss\nst\nsu\nsv\nsw\nsx\nsy\nta\ntb\ntc\ntd\nte\ntf\ntg\nth\nti\ntj\ntk\ntl\ntm\ntn\nto\ntp\ntq\ntr\nts\ntt\ntu\ntv\ntw\ntx\nty\nua\nub\nuc\nud\nue\nuf\nug\nuh\nui\nuj\nuk\nul\num\nun\nuo\nup\nuq\nur\nus\nut\nuu\nuv\nuw\nux\nuy\nva\nvb\nvc\nvd\nve\nvf\nvg\nvh\nvi\nvj\nvk\nvl\nvm\nvn\nvo\nvp\nvq\nvr\nvs\nvt\nvu\nvv\nvw\nvx\nvy\nwa\nwb\nwc\nwd\nwe\nwf\nwg\nwh\nwi\nwj\nwk\nwl\nwm\nwn\nwo\nwp\nwq\nwr\nws\nwt\nwu\nwv\nww\nwx\nwy\nxa\nxb\nxc\nxd\nxe\nxf\nxg\nxh\nxi\nxj\nxk\nxl\nxm\nxn\nxo\nxp\nxq\nxr\nxs\nxt\nxu\nxv\nxw\nxx\nxy\nya\nyb\nyc\nyd\nye\nyf\nyg\nyh\nyi\nyj\nyk\nyl\nym\nyn\nyo\nyp\nyq\nyr\nys\nyt\nyu\nyv\nyw\nyx\nyy\nza\nzb\nzc\nzd\nze\nzf\nzg\nzh\nzi\nzj\nzk\nzl\nzm\nzn\nzo\nzp\nzq\nzr\nzs\nzt\nzu\nzv\nzw\nzx\nzy\nzz\n2\naa\nbb\n", "aw\nwz\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\n"]], "limits": {"time": [2000, 2000], "memory": [1048576, 1048576]}, "tags": ["2013", "Special Judge", "ICPC", "CERC"], "title": "[CERC2013] Digraphs", "background": "", "description": "A digraph is a graph with orientation... oh, sorry, not this time. Let's stop being nerds for a minute and talk about languages (human languages, not PHP).\n\nDigraphs are pairs of characters that represent one phoneme (sound). For example, \"ch\" in English (as in \"church\") is a single consonant sound. The languages of Central Europe are fond of digraphs: Hungarian \"sz\", Czech \"ch\" and Polish \"rz\" are fine examples of them.\n\nDigraphs are very annoying for people who do not use them natively. We will make up a letter-puzzle specifically for those people. Given a list of digraphs, construct a biggest possible square of lower case English letters such that its rows and columns do not contain any of these digraphs. This means that no two consecutive letters (read from top to bottom or from left to right) can form a digraph.\n", "inputFormat": "\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nEach test case starts with an integer $n , 0 \\le n \\le 676$ , denoting the number of forbidden digraphs. The $n$ following lines contain the digraphs.\n", "outputFormat": "For each test case print a square of the largest possible size which does not contain any of the digraphs. If it is possible to construct a square of size $20 \\times 20$ or bigger, print only a $20 \\times 20$ square.\n\nWarning: Part of the example test data below was omitted for clarity. You can access full sample tests at your workstation. ", "hint": "Time limit: 2 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[CERC2013] Digraphs", "background": "", "description": "A digraph is a graph with orientation... oh, sorry, not this time. Let's stop being nerds for a minute and talk about languages (human languages, not PHP).\n\nDigraphs are pairs of characters that represent one phoneme (sound). For example, \"ch\" in English (as in \"church\") is a single consonant sound. The languages of Central Europe are fond of digraphs: Hungarian \"sz\", Czech \"ch\" and Polish \"rz\" are fine examples of them.\n\nDigraphs are very annoying for people who do not use them natively. We will make up a letter-puzzle specifically for those people. Given a list of digraphs, construct a biggest possible square of lower case English letters such that its rows and columns do not contain any of these digraphs. This means that no two consecutive letters (read from top to bottom or from left to right) can form a digraph.\n", "inputFormat": "\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nEach test case starts with an integer $n , 0 \\le n \\le 676$ , denoting the number of forbidden digraphs. The $n$ following lines contain the digraphs.\n", "outputFormat": "For each test case print a square of the largest possible size which does not contain any of the digraphs. If it is possible to construct a square of size $20 \\times 20$ or bigger, print only a $20 \\times 20$ square.\n\nWarning: Part of the example test data below was omitted for clarity. You can access full sample tests at your workstation. ", "hint": "Time limit: 2 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Digraphs", "background": null, "description": "有一些有向字母对，构造一个尽量大（最大 $20\\times20$）的方阵，使得这个方阵中任意两个相邻字母对（从左到右或从上到下）都不是这些有向字母对中的一个。", "inputFormat": "第一行一个整数 $T\\ (1 \\le T \\le 111)$，表示数据组数。\n\n每组数据第一行一个整数 $n\\ (0 \\le n \\le 676)$，表示有向字母对数。\n\n接下来 $n$ 行，每行 $2$ 个小写字母，表示一组有向字母对。", "outputFormat": "对于每组数据，输出一个尽量大的方阵，不包含任何一个有向字母对（如果可以构造比 $20\\times20$ 规模更大的方阵，只需要 $20\\times20$ 规模就够了）。\n\n如果有多组解，输出任意一组即可。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P7018", "type": "P", "difficulty": 1, "samples": [["2\n1\n3\n", "1\n7\n"]], "limits": {"time": [1000], "memory": [1048576]}, "tags": ["2013", "ICPC", "CERC"], "title": "[CERC2013] Bus", "background": "", "description": "A bus with $n$ passengers opens its door at the bus stop. Exactly half of its passengers and an additional half of a passenger get out. On the next stop, again, half of the passengers plus half of a passenger leave the bus. This goes on for $k$ stops in total. Knowing that the bus leaves the last stop empty, and that no one was hurt during the trip, determine the initial number $n$ of people in the bus.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe only line of each test case contains the number of stops $k$, $1 \\leq k \\leq 30$.", "outputFormat": "For each test case, output a single line containing a single integer—the initial number of bus passengers.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n Central Europe Regional Contest (CERC) 2013", "locale": "en", "translations": {"en": {"title": "[CERC2013] Bus", "background": "", "description": "A bus with $n$ passengers opens its door at the bus stop. Exactly half of its passengers and an additional half of a passenger get out. On the next stop, again, half of the passengers plus half of a passenger leave the bus. This goes on for $k$ stops in total. Knowing that the bus leaves the last stop empty, and that no one was hurt during the trip, determine the initial number $n$ of people in the bus.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe only line of each test case contains the number of stops $k$, $1 \\leq k \\leq 30$.", "outputFormat": "For each test case, output a single line containing a single integer—the initial number of bus passengers.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n Central Europe Regional Contest (CERC) 2013", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Bus", "background": "", "description": "# [CERC2013] Bus\n\n## 题面翻译\n\n有一个数 $n$ ，定义一次操作为使 $n\\rightarrow \\frac{n-1}{2}$ 。已知经过了 $k$ 次操作后 $n$ 恰好为 $0$，求 $n$。\n \n多测，有 $T$ 组数据，$T$ 在输入数据开头给出。 \n\n保证 $1\\leqslant k\\leqslant 30$。\n\n\nA bus with $n$ passengers opens its door at the bus stop. Exactly half of its passengers and an additional half of a passenger get out. On the next stop, again, half of the passengers plus half of a passenger leave the bus. This goes on for $k$ stops in total. Knowing that the bus leaves the last stop empty, and that no one was hurt during the trip, determine the initial number $n$ of people in the bus.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe only line of each test case contains the number of stops $k$, $1 \\leq k \\leq 30$.", "outputFormat": "For each test case, output a single line containing a single integer—the initial number of bus passengers.\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n2\n1\n3\n```\n\n### 样例输出 #1\n\n```\n1\n7\n```", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n Central Europe Regional Contest (CERC) 2013", "locale": "zh-CN"}}}
{"pid": "P7019", "type": "P", "difficulty": 2, "samples": [["4\n", "4\n"], ["7\n", "11\n"], ["6\n", "14\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Auxiliary Project", "background": "", "description": "\n\nAnna has just finished her course project. She has a lot of seven-segment LED displays as leftovers and a small power source. Each display consumes power proportionally to the number of lit segments, e.g . $‘9'$ consumes twice more power than $‘7'.$\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15131/1.png)\n\nAnna wonders what is the maximum possible sum of digits she is able to achieve, if her power source is able to light $n$ segments, and she wants to light exactly $n$ segments.\n\n", "inputFormat": "\n\nThe single line of the input contains one integer $n$ -- the number of segments that should be lit $(2 \\le n \\le 10^{6}).$\n\n", "outputFormat": "\n\nOutput a single integer -- the maximum possible sum of digits that can be displayed simultaneously.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Auxiliary Project", "background": "", "description": "\n\nAnna has just finished her course project. She has a lot of seven-segment LED displays as leftovers and a small power source. Each display consumes power proportionally to the number of lit segments, e.g . $‘9'$ consumes twice more power than $‘7'.$\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15131/1.png)\n\nAnna wonders what is the maximum possible sum of digits she is able to achieve, if her power source is able to light $n$ segments, and she wants to light exactly $n$ segments.\n\n", "inputFormat": "\n\nThe single line of the input contains one integer $n$ -- the number of segments that should be lit $(2 \\le n \\le 10^{6}).$\n\n", "outputFormat": "\n\nOutput a single integer -- the maximum possible sum of digits that can be displayed simultaneously.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Auxiliary Project", "background": "", "description": "Anna 刚刚完成了她的课程项目。她有很多七段 LED 显示器作为剩余物品，还有一个小型电源。每个显示器的耗电量与点亮的段数成正比，例如，数字 $9$ 的耗电量是数字 $7$ 的两倍。\n\nAnna 想知道，如果她的电源能够点亮 $n$ 个段，并且她想要恰好点亮 $n$ 个段，那么她能够实现的最大数字和是多少。", "inputFormat": "输入的单行包含一个整数 $n$，表示应该点亮的段数 $(2 \\le n \\le 10^{6})$。", "outputFormat": "输出一个整数，表示可以同时显示的最大数字和。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7020", "type": "P", "difficulty": 3, "samples": [["a\n", "1\n"], ["B|~B\n", "2\n"], ["c|~C\n", "3\n"], ["i|c|p|c\n", "7\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Boolean Satisfiability", "background": "", "description": "\n\nBoolean satisfiability problem (SAT) is known to be a very hard problem in computer science. In this problem you are given a Boolean formula, and you need to find out if the variables of a given formula can be consistently replaced by the values true or false in such a way that the formula evaluates to true. SAT is known to be NP-complete problem. Moreover, it is NP-complete even in case of $3-CNF$ formula $(3-SAT).$ However, for example, SAT problem for $2-CNF$ formulae $(2-SAT)$ is in $P$ .\n\n$#SAT$ is the extension of SAT problem. In this problem you need to check if it is possible, and count the number of ways to assign values to variables. This problem is known to be $#P-complete$ even for $2-CNF$ formulae. We ask you to solve $#1-DNF-SAT,$ which is $#SAT$ problem for $1-DNF$ formulae.\n\nYou are given a Boolean formula in $1-DNF$ form. It means that it is a disjunction (logical or) of one or more clauses, each clause is exactly one literal, each literal is either variable or its negation (logical not).\n\nFormally:\n\n$〈formula〉 ::= 〈clause〉 | 〈formula〉 ∨ 〈clause〉$\n\n$〈clause〉 ::= 〈literal〉$\n\n$〈literal〉 ::= 〈variable〉 | ¬ 〈variable〉$\n\n$〈variable〉 ::=$ A . . . $Z |$ a . . . $z$\n\nYour task is to find the number of ways to replace all variables with values true and false (all occurrences of the same variable should be replaced with same value), such that the formula evaluates to true.\n\n", "inputFormat": "\n\nThe only line of the input file contains a logical formula in $1-DNF$ form (not longer than $1000$ symbols). Logical operations are represented by $‘|'$ (disjunction) and $‘ \\sim ' (negatio_n).$ The variables are $‘A'$ . . . $‘Z'$ and $‘a'$ . . . $‘z'$ (uppercase and lowercase letters are different variables). The formula contains neither spaces nor other characters not mentioned in the grammar.\n\n", "outputFormat": "\n\nOutput a single integer -- the answer for $#SAT$ problem for the given formula.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Boolean Satisfiability", "background": "", "description": "\n\nBoolean satisfiability problem (SAT) is known to be a very hard problem in computer science. In this problem you are given a Boolean formula, and you need to find out if the variables of a given formula can be consistently replaced by the values true or false in such a way that the formula evaluates to true. SAT is known to be NP-complete problem. Moreover, it is NP-complete even in case of $3-CNF$ formula $(3-SAT).$ However, for example, SAT problem for $2-CNF$ formulae $(2-SAT)$ is in $P$ .\n\n$#SAT$ is the extension of SAT problem. In this problem you need to check if it is possible, and count the number of ways to assign values to variables. This problem is known to be $#P-complete$ even for $2-CNF$ formulae. We ask you to solve $#1-DNF-SAT,$ which is $#SAT$ problem for $1-DNF$ formulae.\n\nYou are given a Boolean formula in $1-DNF$ form. It means that it is a disjunction (logical or) of one or more clauses, each clause is exactly one literal, each literal is either variable or its negation (logical not).\n\nFormally:\n\n$〈formula〉 ::= 〈clause〉 | 〈formula〉 ∨ 〈clause〉$\n\n$〈clause〉 ::= 〈literal〉$\n\n$〈literal〉 ::= 〈variable〉 | ¬ 〈variable〉$\n\n$〈variable〉 ::=$ A . . . $Z |$ a . . . $z$\n\nYour task is to find the number of ways to replace all variables with values true and false (all occurrences of the same variable should be replaced with same value), such that the formula evaluates to true.\n\n", "inputFormat": "\n\nThe only line of the input file contains a logical formula in $1-DNF$ form (not longer than $1000$ symbols). Logical operations are represented by $‘|'$ (disjunction) and $‘ \\sim ' (negatio_n).$ The variables are $‘A'$ . . . $‘Z'$ and $‘a'$ . . . $‘z'$ (uppercase and lowercase letters are different variables). The formula contains neither spaces nor other characters not mentioned in the grammar.\n\n", "outputFormat": "\n\nOutput a single integer -- the answer for $#SAT$ problem for the given formula.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Boolean Satisfiability", "background": "", "description": "布尔可满足性问题（SAT）在计算机科学中被认为是一个非常困难的问题。在这个问题中，给定一个布尔公式，你需要判断该公式的变量是否可以被一致地替换为真或假，使得公式的结果为真。SAT 是已知的 NP 完全问题。此外，即使在 $3-CNF$ 公式（$3-SAT$）的情况下，它也是 NP 完全的。然而，例如，对于 $2-CNF$ 公式（$2-SAT$）的 SAT 问题是在 $P$ 中的。\n\n$#SAT$ 是 SAT 问题的扩展。在这个问题中，你需要检查是否可能，并计算赋值给变量的方式的数量。这个问题即使对于 $2-CNF$ 公式也是已知的 $#P$ 完全问题。我们要求你解决 $#1-DNF-SAT$，这是 $1-DNF$ 公式的 $#SAT$ 问题。\n\n你被给定一个 $1-DNF$ 形式的布尔公式。这意味着它是一个或多个子句的析取（逻辑或），每个子句正好是一个文字，每个文字要么是变量，要么是它的否定（逻辑非）。\n\n形式化地：\n\n$\\langle \\text{formula} \\rangle ::= \\langle \\text{clause} \\rangle \\ | \\ \\langle \\text{formula} \\rangle \\lor \\langle \\text{clause} \\rangle$\n\n$\\langle \\text{clause} \\rangle ::= \\langle \\text{literal} \\rangle$\n\n$\\langle \\text{literal} \\rangle ::= \\langle \\text{variable} \\rangle \\ | \\ \neg \\langle \\text{variable} \\rangle$\n\n$\\langle \\text{variable} \\rangle ::= A \\ldots Z \\ | \\ a \\ldots z$\n\n你的任务是找到将所有变量替换为真和假（同一变量的所有出现应替换为相同的值）的方法的数量，使得公式的结果为真。", "inputFormat": "输入文件的唯一一行包含一个 $1-DNF$ 形式的逻辑公式（不超过 $1000$ 个符号）。逻辑操作由 ‘|’（析取）和 ‘~’（否定）表示。变量是 ‘A’ 到 ‘Z’ 和 ‘a’ 到 ‘z’（大写和小写字母是不同的变量）。公式不包含空格或语法中未提到的其他字符。", "outputFormat": "输出一个整数——给定公式的 $#SAT$ 问题的答案。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7021", "type": "P", "difficulty": 4, "samples": [["consonants\n", "CoNsoNaNts\n"], ["destruction\n", "dEsTrUcTiOn\n"], ["strength\n", "StRenGtH\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Consonant Fencity", "background": "", "description": "\n\nThere are two kinds of sounds in spoken languages: vowels and consonants. Vowel is a sound, produced with an open vocal tract; and consonant is pronounced in such a way that the breath is at least partly obstructed. For example, letters a and $o$ are used to express vowel sounds, while letters $b$ and $p$ are the consonants (e.g . bad, pot).\n\na vowel (e.g . silly) or as a consonant (e.g . yellow). The letter $w$ , usually used as a consonant (e.g . wet) could produce a vowel after another vowel (e.g . growth) in English, and in some languages (e.g . Welsh) it could be even the only vowel in a word.\n\nIn this task, we consider $y$ and $w$ as vowels, so there are seven vowels in English alphabet: a , $e , i , o , u , w$ and $y$ , all other letters are consonants.\n\nLet's define the consonant fencity of a string as the number of pairs of consecutive letters in the string which both are consonants and have different cases (lowercase letter followed by uppercase or vice versa). For example, the consonant fencity of a string CoNsoNaNts is $2$ , the consonant fencity of a string dEsTrUcTiOn is $3$ and the consonant fencity of string StRenGtH is $5$ .\n\nYou will be given a string consisting of lowercase English letters. Your task is to change the case of some letters in such a way that all equal letters will be of the same case (that means, no letter can occur in resulting string as both lowercase and uppercase), and the consonant fencity of resulting string is maximal.\n\n", "inputFormat": "\n\nThe only line of the input contains non-empty original string consisting of no more than $10^{6}$ lowercase English letters.\n\n", "outputFormat": "\n\nOutput the only line: the input string changed to have maximum consonant fencity.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Consonant Fencity", "background": "", "description": "\n\nThere are two kinds of sounds in spoken languages: vowels and consonants. Vowel is a sound, produced with an open vocal tract; and consonant is pronounced in such a way that the breath is at least partly obstructed. For example, letters a and $o$ are used to express vowel sounds, while letters $b$ and $p$ are the consonants (e.g . bad, pot).\n\na vowel (e.g . silly) or as a consonant (e.g . yellow). The letter $w$ , usually used as a consonant (e.g . wet) could produce a vowel after another vowel (e.g . growth) in English, and in some languages (e.g . Welsh) it could be even the only vowel in a word.\n\nIn this task, we consider $y$ and $w$ as vowels, so there are seven vowels in English alphabet: a , $e , i , o , u , w$ and $y$ , all other letters are consonants.\n\nLet's define the consonant fencity of a string as the number of pairs of consecutive letters in the string which both are consonants and have different cases (lowercase letter followed by uppercase or vice versa). For example, the consonant fencity of a string CoNsoNaNts is $2$ , the consonant fencity of a string dEsTrUcTiOn is $3$ and the consonant fencity of string StRenGtH is $5$ .\n\nYou will be given a string consisting of lowercase English letters. Your task is to change the case of some letters in such a way that all equal letters will be of the same case (that means, no letter can occur in resulting string as both lowercase and uppercase), and the consonant fencity of resulting string is maximal.\n\n", "inputFormat": "\n\nThe only line of the input contains non-empty original string consisting of no more than $10^{6}$ lowercase English letters.\n\n", "outputFormat": "\n\nOutput the only line: the input string changed to have maximum consonant fencity.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Consonant Fencity", "background": "", "description": "在口语中有两种声音：元音和辅音。元音是通过开放的声道发出的声音；而辅音的发音方式是气流至少部分受阻。例如，字母 a 和 $o$ 用来表达元音，而字母 $b$ 和 $p$ 是辅音（例如 bad, pot）。\n\n字母 $y$ 可以作为元音（例如 silly）或辅音（例如 yellow）。字母 $w$ 通常用作辅音（例如 wet），但在另一个元音之后可以发出元音（例如 growth），在某些语言中（例如威尔士语），它甚至可以是单词中的唯一元音。\n\n在这个任务中，我们将 $y$ 和 $w$ 视为元音，所以在英语字母表中有七个元音：a, $e, i, o, u, w$ 和 $y$，其他所有字母都是辅音。\n\n我们定义一个字符串的辅音密度为字符串中连续字母对的数量，这些字母对都是辅音并且大小写不同（小写字母后跟大写字母或反之亦然）。例如，字符串 CoNsoNaNts 的辅音密度是 $2$，字符串 dEsTrUcTiOn 的辅音密度是 $3$，字符串 StRenGtH 的辅音密度是 $5$。\n\n你将得到一个由小写英文字母组成的字符串。你的任务是改变一些字母的大小写，使得所有相同的字母都具有相同的大小写（这意味着，结果字符串中不能同时出现同一个字母的小写和大写形式），并且结果字符串的辅音密度最大化。", "inputFormat": "输入的唯一一行包含一个非空的原始字符串，由不超过 $10^6$ 个小写英文字母组成。", "outputFormat": "输出唯一一行：将输入字符串更改为具有最大辅音密度的形式。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7022", "type": "P", "difficulty": 6, "samples": [["2\n1 0 1 0\n0 1 2 3\n", "3\n6 2 4\n4 2 2\n2 1 1\n5\n15 10 5\n10 5 5\n5 1 4\n4 2 2\n2 1 1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Dividing Marbles", "background": "", "description": "\n\nDebbie, Debby, Debra and Deborah are going to play a game with marbles together. Debbie has brought $2^{d_{1}}$ marbles, Debby -- $2^{d_{2}}$ marbles, Debra -- $2^{d3}$ marbles, while Deborah -- $2^{d4}$ marbles. The kids have gathered their marbles into a single pile containing $2^{d_{1}} + 2^{d_{2}} + 2^{d_{3}} + 2^{d_{4}}$ marbles, and the game is starting.\n\nThe game consists of turns. Each turn consists of two steps:\n\nThe kids choose any of their piles with more than one marble and divide it into two non-empty piles. That is, if the chosen pile contains $m \\ge 2$ marbles, the new piles must contain $m_{1}$ and $m_{2}$ marbles where $m_1$ and $m_2$ are positive integers, and $m_{1} + m_{2} = m$ .\n\nIf there are several piles with the same number of marbles, only one of these piles is kept, while all the others with this number of marbles are discarded (thrown away).\n\nThe game ends when only one pile is left, and this pile contains a single marble. The goal of the game is to end it in the least possible number of turns. Note that the game is cooperative, that is, the kids aren't playing against each other, but trying to reach a common goal together.\n\nHelp the kids and find the best way to play.\n\n", "inputFormat": "\n\nThe first line of the input contains a single integer $T$ -- the number of test cases $(1 \\le T \\le 500)$ .\n\nEach of the next $T$ lines describes one test case and contains four non-negative integers $d_{1}, d_{2}, d_{3}, d_{4} (0 \\le d_{i} \\le 20)$ .\n\n", "outputFormat": "\n\nFor each test case, output an integer $t$ -- the smallest number of turns required to end the game.\n\nThen, output $t$ turn descriptions, in the order the turns should be made. Each description should consist of three integers $m , m_{1}, m_{2}$ -- the size of the divided pile and the sizes of the new piles, respectively $(m \\ge 2$ ; $m_{1} > 0$ ; $m_{2} > 0$ ; $m_{1} + m_{2} = m)$ . Note that a pile of size $m$ must exist at that moment, and at the end of the game there should be only one pile left and that pile should contain a single marble.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Dividing Marbles", "background": "", "description": "\n\nDebbie, Debby, Debra and Deborah are going to play a game with marbles together. Debbie has brought $2^{d_{1}}$ marbles, Debby -- $2^{d_{2}}$ marbles, Debra -- $2^{d3}$ marbles, while Deborah -- $2^{d4}$ marbles. The kids have gathered their marbles into a single pile containing $2^{d_{1}} + 2^{d_{2}} + 2^{d_{3}} + 2^{d_{4}}$ marbles, and the game is starting.\n\nThe game consists of turns. Each turn consists of two steps:\n\nThe kids choose any of their piles with more than one marble and divide it into two non-empty piles. That is, if the chosen pile contains $m \\ge 2$ marbles, the new piles must contain $m_{1}$ and $m_{2}$ marbles where $m_1$ and $m_2$ are positive integers, and $m_{1} + m_{2} = m$ .\n\nIf there are several piles with the same number of marbles, only one of these piles is kept, while all the others with this number of marbles are discarded (thrown away).\n\nThe game ends when only one pile is left, and this pile contains a single marble. The goal of the game is to end it in the least possible number of turns. Note that the game is cooperative, that is, the kids aren't playing against each other, but trying to reach a common goal together.\n\nHelp the kids and find the best way to play.\n\n", "inputFormat": "\n\nThe first line of the input contains a single integer $T$ -- the number of test cases $(1 \\le T \\le 500)$ .\n\nEach of the next $T$ lines describes one test case and contains four non-negative integers $d_{1}, d_{2}, d_{3}, d_{4} (0 \\le d_{i} \\le 20)$ .\n\n", "outputFormat": "\n\nFor each test case, output an integer $t$ -- the smallest number of turns required to end the game.\n\nThen, output $t$ turn descriptions, in the order the turns should be made. Each description should consist of three integers $m , m_{1}, m_{2}$ -- the size of the divided pile and the sizes of the new piles, respectively $(m \\ge 2$ ; $m_{1} > 0$ ; $m_{2} > 0$ ; $m_{1} + m_{2} = m)$ . Note that a pile of size $m$ must exist at that moment, and at the end of the game there should be only one pile left and that pile should contain a single marble.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Dividing Marbles", "background": "", "description": "Debbie, Debby, Debra 和 Deborah要一起玩一个关于弹珠的游戏。Debbie 带来了  $2^{d_{1}}$ 颗弹珠, Debby 带来了  $2^{d_{2}}$ 颗弹珠, Debra 带来了  $2^{d3}$ 颗弹珠, 而 Deborah 带来了  $2^{d4}$ 颗弹珠。这些孩子们把他们的弹珠放在一起，总共有 $2^{d_{1}} + 2^{d_{2}} + 2^{d_{3}} + 2^{d_{4}}$ 颗, 游戏开始了。\n\n游戏是多回合制。每一个回合包括两个步骤：\n\n这些孩子们选择他们的任意一堆大于1个的弹珠然后分入两个大于0个的堆中。相当于，如果选中的那堆有 $m \\ge 2$ 颗弹珠, 新的一堆必须要有 $m_{1}$ 和 $m_{2}$ 颗弹珠且 $m_1$ 和 $m_2$ 为正整数, 且 $m_{1} + m_{2} = m$.\n\n如果有许多堆拥有同样数目的弹珠，只有一堆会被保留，其他的都会被丢弃。\n\n当只有一堆弹珠被留下且这堆弹珠只有一颗时，游戏就结束了。游戏的目标就是用尽量少的回合让游戏结束。注意这个游戏是合作性质的，那就是，这些孩子不是互相争斗的，而是一起尝试达成同一个目标。\n\n请帮助这些孩子找到游戏的最佳方案。", "inputFormat": "第一行包括一个单独的整数，T 即测试用例的数量$(1≤T≤500)$ .\n\n下面的每一行都描述一个测试用例且包含四个非负整数 $d_{1}, d_{2}, d_{3}, d_{4} (0 \\le d_{i} \\le 20)$", "outputFormat": "对于每一个测试用例，输出一个整数t，即游戏结束所需的最少次数。\n\n然后，按照回合的顺序，输出这些回合的说明。每一行说明都要包括三个整数 $ m , m_{1}, m_{2}$ 即是被分的堆和新堆的弹珠数量，依次为$(m≥2 ; m_{1} > 0; m_{2} > 0 ;  m_{1} + m_{2} = m)$ \n\n请注意大小为m的弹珠堆一定要存在，且在游戏结束时应该只剩下一堆且那一堆应该只有一颗弹珠。", "hint": "时间限制: 3 s, 内存限制: 512 MB.", "locale": "zh-CN"}}}
{"pid": "P7023", "type": "P", "difficulty": 4, "samples": [["6\n3 4 1 2 1 2\n", "4 4 3 3 2 2 1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Equal Numbers", "background": "", "description": "\n\nYou are given a list of $n$ integers $a_{1},$ . . . , $a_{n}.$ You can perform the following operation: choose some $a_{i}$ and multiply it by any positive integer.\n\nYour task is to compute the minimum number of different integers that could be on the list after $k$ operations for all $0 \\le k \\le n$ .\n\n", "inputFormat": "\n\nThe first line of the input contains single integer $n (1 \\le n \\le 3·10^{5}).$ The second line of the input contains $n$ integers $a_{i} (1 \\le a_{i} \\le 10^{6}).$\n\n", "outputFormat": "\n\nOutput a single line that contains $n + 1$ integers. The i-th integer should be the minimum possible number of different integers in the list after $i − 1$ operations.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Equal Numbers", "background": "", "description": "\n\nYou are given a list of $n$ integers $a_{1},$ . . . , $a_{n}.$ You can perform the following operation: choose some $a_{i}$ and multiply it by any positive integer.\n\nYour task is to compute the minimum number of different integers that could be on the list after $k$ operations for all $0 \\le k \\le n$ .\n\n", "inputFormat": "\n\nThe first line of the input contains single integer $n (1 \\le n \\le 3·10^{5}).$ The second line of the input contains $n$ integers $a_{i} (1 \\le a_{i} \\le 10^{6}).$\n\n", "outputFormat": "\n\nOutput a single line that contains $n + 1$ integers. The i-th integer should be the minimum possible number of different integers in the list after $i − 1$ operations.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Equal Numbers", "background": "", "description": "给定一个包含 $n$ 个整数 $a_{1}, \\ldots, a_{n}$ 的列表。你可以执行以下操作：选择某个 $a_{i}$ 并将其乘以任意正整数。  \n\n你的任务是计算在进行 $k$ 次操作后列表中可能出现的不同整数的最小数量，要求对所有 $0 \\le k \\le n$ 都进行计算。", "inputFormat": "输入的第一行包含一个整数 $n (1 \\le n \\le 3 \\times 10^{5})$。输入的第二行包含 $n$ 个整数 $a_{i} (1 \\le a_{i} \\le 10^{6})$。", "outputFormat": "输出一行包含 $n + 1$ 个整数。第 $i$ 个整数应为在进行 $i - 1$ 次操作后列表中可能的不同整数的最小数量。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7024", "type": "P", "difficulty": 6, "samples": [["4\nfor i in range(1, n):\n    for j in range(1, i):\n        for k in range(j, n):\n            lag", "3 1/3\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Fygon 2.0", "background": "", "description": "\n\nThe new version of beloved programming language Fygon has been released! The brand new Fygon $2$ . $0$ still has only two statements. The first statement is lag. It substitutes almost any other statement. Second statement is a for loop:\n\n```\nfor <variable> in range(<from>, <to>):\n    <body>\n```\n\nThe for loop makes iterate from to , both inclusive.\n\nIf is greater than , is not executed at all.\n\nis a lowercase letter from a to $z$ , except for $n$ , which is a variable that is defined prior to the given code snippet.\n\nand can be equal to any variable defined in outer loop. In addition to that, can be $1$ and can be $n$ .\n\nThe of the loop is indented by four spaces and contains at least one statement.\n\nIf you are familiar with Fygon $1$ . $0$ , you can notice that, in the spirit of the best programming practices, Fygon $2$ . $0$ is not backwards compatible, since the range function now requires two parameters.\n\nThe performance of the new version is significantly improved, so you can write more nested for loops. That is why we are no longer interested in the exact number of operations, but in the asymptotic complexity of the program instead. For simplicity, all for loops are nested in a single chain and there is exactly one lag statement that is inside all for loops. All loop variables are different and are not equal to $n$ .\n\nLet's define $f(n)$ as the number of lag operations exectuted by a given Fygon program as the function of $n$ . For non-negative integer $k$ and positive rational number $C$ we say that $C · n^{k}$ is the asymptotic complexity of the program if\n\n$$\\lim_{n \\to \\infty}{\\frac{f(n)}{C \\cdot n^k}} = 1$$\n\nGiven a Fygon $2$ . $0$ program, find its asymptotic complexity.\n\n", "inputFormat": "\n\nThe first line of the input contains single integer $m$ -- the number of lines in Fygon $2$ . $0$ program. Next $m$ lines contain the program itself. The program has at least $1$ and at most $20$ for statements. Each for statement contains either single nested for statement or lag statement.\n\n", "outputFormat": "\n\nOutput numbers $k$ and $C$ . $C$ should be output in the form of irreducible fraction $p/q$ , where $p$ and $q$ are coprime.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Fygon 2.0", "background": "", "description": "\n\nThe new version of beloved programming language Fygon has been released! The brand new Fygon $2$ . $0$ still has only two statements. The first statement is lag. It substitutes almost any other statement. Second statement is a for loop:\n\n```\nfor <variable> in range(<from>, <to>):\n    <body>\n```\n\nThe for loop makes iterate from to , both inclusive.\n\nIf is greater than , is not executed at all.\n\nis a lowercase letter from a to $z$ , except for $n$ , which is a variable that is defined prior to the given code snippet.\n\nand can be equal to any variable defined in outer loop. In addition to that, can be $1$ and can be $n$ .\n\nThe of the loop is indented by four spaces and contains at least one statement.\n\nIf you are familiar with Fygon $1$ . $0$ , you can notice that, in the spirit of the best programming practices, Fygon $2$ . $0$ is not backwards compatible, since the range function now requires two parameters.\n\nThe performance of the new version is significantly improved, so you can write more nested for loops. That is why we are no longer interested in the exact number of operations, but in the asymptotic complexity of the program instead. For simplicity, all for loops are nested in a single chain and there is exactly one lag statement that is inside all for loops. All loop variables are different and are not equal to $n$ .\n\nLet's define $f(n)$ as the number of lag operations exectuted by a given Fygon program as the function of $n$ . For non-negative integer $k$ and positive rational number $C$ we say that $C · n^{k}$ is the asymptotic complexity of the program if\n\n$$\\lim_{n \\to \\infty}{\\frac{f(n)}{C \\cdot n^k}} = 1$$\n\nGiven a Fygon $2$ . $0$ program, find its asymptotic complexity.\n\n", "inputFormat": "\n\nThe first line of the input contains single integer $m$ -- the number of lines in Fygon $2$ . $0$ program. Next $m$ lines contain the program itself. The program has at least $1$ and at most $20$ for statements. Each for statement contains either single nested for statement or lag statement.\n\n", "outputFormat": "\n\nOutput numbers $k$ and $C$ . $C$ should be output in the form of irreducible fraction $p/q$ , where $p$ and $q$ are coprime.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Fygon 2.0", "background": "", "description": "心爱的编程语言 Fygon 的新版本发布了！全新的 Fygon 2.0 仍然只有两个语句。第一个语句是 lag。它几乎可以替代任何其他语句。第二个语句是一个 for 循环：\n\n```\nfor <variable> in range(<from>, <to>):\n    <body>\n```\n\nfor 循环使得从 from 到 to 进行迭代，包含两端。\n\n如果 from 大于 to，则循环体不执行。\n\n<variable> 是从 a 到 z 的小写字母，除了 n，它是一个在给定代码片段之前定义的变量。\n\n<from> 和 <to> 可以等于外层循环中定义的任何变量。此外，<from> 可以是 1，<to> 可以是 n。\n\n循环体缩进四个空格，并且至少包含一个语句。\n\n如果你熟悉 Fygon 1.0，你会注意到，秉承最佳编程实践的精神，Fygon 2.0 不向后兼容，因为 range 函数现在需要两个参数。\n\n新版本的性能显著提高，因此你可以编写更多嵌套的 for 循环。这就是为什么我们不再关注操作的确切数量，而是关注程序的渐进复杂性。为简单起见，所有 for 循环都嵌套在一个链中，并且在所有 for 循环中恰好有一个 lag 语句。所有循环变量都不同，并且不等于 n。\n\n让我们定义 $f(n)$ 为给定 Fygon 程序执行的 lag 操作的数量，作为 n 的函数。对于非负整数 $k$ 和正有理数 $C$，如果\n\n$$\\lim_{n \\to \\infty}{\\frac{f(n)}{C \\cdot n^k}} = 1$$\n\n我们称 $C \\cdot n^{k}$ 是程序的渐进复杂性。\n\n给定一个 Fygon 2.0 程序，找出其渐进复杂性。", "inputFormat": "输入的第一行包含单个整数 $m$ —— Fygon 2.0 程序中的行数。接下来的 $m$ 行包含程序本身。程序至少有 1 个，最多有 20 个 for 语句。每个 for 语句包含一个嵌套的 for 语句或 lag 语句。", "outputFormat": "输出数字 $k$ 和 $C$。$C$ 应以不可约分数 $p/q$ 的形式输出，其中 $p$ 和 $q$ 互质。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7025", "type": "P", "difficulty": 6, "samples": [["2\n6 6\n3 6\n3 4\n1 4\n1 2\n1 3\n2 3\n3 1\n1 2\n", "1 3\n3 1 2 3\n2 1 3\n3 1 4 3\n-1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Grand Test", "background": "", "description": "\n\nJeremy, Richard and James like to test cars. It is always hard for them to decide where they should do it. Usually car test looks like this. They choose a country and examine its cities and two-way roads that connect them. To perform a test, they need to choose two different cities $S$ and $F$ , such that there exist three routes between them. Moreover, each city except $S$ and $F$ should be visited by at most one route, and none of the roads may be used twice.\n\nThen each of them takes a car in city $S$ , drives along one of those routes and tries to get to city $F$ faster than others.\n\nYou are given a description of multiple countries. For each country you should decide if it is possible to choose two cities and three routes between them in a way described above.\n\n", "inputFormat": "\n\nThe first line of the input contains a single integer $T$ -- number of countries $(1 \\le T \\le 100 000)$ . It is followed by $T$ country descriptions.\n\nThe first line of each country description contains two integers $n$ and $m$ -- the number of its cities and roads $(1 \\le n , m \\le 100 000)$ . The following $m$ lines contain two integer numbers each: $u_{i}$ and $v_{i}$ -- the cities at the ends of the road $(1 \\le u_{i} < v_{i} \\le n)$ . All roads are two-way. Each pair of cities is connected by at most one road.\n\nBoth the total number of cities and roads in all countries does not exceed $100 000$ .\n\n", "outputFormat": "\n\nOutput the answer for each country in the order they are given in the input.\n\nIf it is not possible to test cars in this country, the answer is $−1$ . Otherwise the first line of the answer should contain two integers $S$ and $F$ -- start and finish cities. The next three lines should contain three distinct routes. Each route is described by an integer $k$ -- the number of cities it visits, and $k$ numbers $v_{1}, v_{2}, \\cdots , v_{k}$ -- the cities, where $v_{1} = S , v_{k} = F$ , and there is a road between cities $v_{i}$ and $v_{i+1}$ for all $1 \\le i \\le k − 1$ .\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Grand Test", "background": "", "description": "\n\nJeremy, Richard and James like to test cars. It is always hard for them to decide where they should do it. Usually car test looks like this. They choose a country and examine its cities and two-way roads that connect them. To perform a test, they need to choose two different cities $S$ and $F$ , such that there exist three routes between them. Moreover, each city except $S$ and $F$ should be visited by at most one route, and none of the roads may be used twice.\n\nThen each of them takes a car in city $S$ , drives along one of those routes and tries to get to city $F$ faster than others.\n\nYou are given a description of multiple countries. For each country you should decide if it is possible to choose two cities and three routes between them in a way described above.\n\n", "inputFormat": "\n\nThe first line of the input contains a single integer $T$ -- number of countries $(1 \\le T \\le 100 000)$ . It is followed by $T$ country descriptions.\n\nThe first line of each country description contains two integers $n$ and $m$ -- the number of its cities and roads $(1 \\le n , m \\le 100 000)$ . The following $m$ lines contain two integer numbers each: $u_{i}$ and $v_{i}$ -- the cities at the ends of the road $(1 \\le u_{i} < v_{i} \\le n)$ . All roads are two-way. Each pair of cities is connected by at most one road.\n\nBoth the total number of cities and roads in all countries does not exceed $100 000$ .\n\n", "outputFormat": "\n\nOutput the answer for each country in the order they are given in the input.\n\nIf it is not possible to test cars in this country, the answer is $−1$ . Otherwise the first line of the answer should contain two integers $S$ and $F$ -- start and finish cities. The next three lines should contain three distinct routes. Each route is described by an integer $k$ -- the number of cities it visits, and $k$ numbers $v_{1}, v_{2}, \\cdots , v_{k}$ -- the cities, where $v_{1} = S , v_{k} = F$ , and there is a road between cities $v_{i}$ and $v_{i+1}$ for all $1 \\le i \\le k − 1$ .\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Grand Test", "background": "", "description": "给定一张 $n$ 个节点 $m$ 条边的无向图，请在图中找出两个点 $S$ 和 $F$，使得这两点间至少存在三条不相交的路径。", "inputFormat": "输入的第一行包数据组数 $T(1 \\leq T \\leq 100000)$。对于每组数据，第一行为两个整数 $n$ 和 $m$。接下来 $m$ 行每行包含两个整数 $u$ 和 $v(1 \\leq u < v \\leq n)$，表示节点 $u$ 和 $v$ 之间有一条边。每对节点至多被一条边连接。保证 $\\sum n$ 及 $\\sum m$ 不超过 $100000$。", "outputFormat": "对于每组数据，若不存在，则输出`-1`。若存在，则第一行输出 $S$ 和 $F$。接下来三行输出三条路径。每行先输出路径路径包含的点数，然后依次输出由 $S$ 到 $F$ 的路径上各点。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7026", "type": "P", "difficulty": 6, "samples": [["6\n3 1 0 4 4\n", "2\n3 1 2 4 4\n"], ["6\n3 1 0 6 4\n", "3\n3 1 1 6 4\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Hidden Supervisors", "background": "", "description": "\n\nHelena works in a big company as a psychologist. Her task is to organize a team building game to enhance social relations between employees. Each employee except the Big boss has a single supervisor. So, employees of the company form a tree where each employee is a node, and the parent of that node is their supervisor. The root of the tree is the Big boss.\n\nA team building game requires teams of two people. Every team should consist of an employee and their supervisor.\n\nHelena asked every employee except the Big boss to send their supervisor ID. Some of them didn't reply. She is going to assign a fake supervisor to every employee that didn't reply, so that she could arrange as many teams as possible. And, of course, fake and real supervisors must form a tree.\n\nHelena had a difficult, but a successful day organizing the event. Will you be able to assign fake supervisors?\n\n", "inputFormat": "\n\nThe first line of the input contains a single integer $n$ -- the number of employees in the company $(2 \\le n \\le 100 000)$ .\n\nThe following line contains $n − 1$ integers $p_{2}, p_{3},$ . . . , $p_{n},$ where $p_{i}$ is the supervisor of employee $i (0 \\le p_{i} \\le n)$ . If employee $i$ didn't reply to Helena, $p_{i}$ equals zero, and she needs to assign a fake supervisor to that employee. The Big boss has the number $1$ .\n\nIt's possible to assign a fake supervisor to each employee that didn't reply to Helena so that all employees will form a tree having the Big boss as a root.\n\n", "outputFormat": "\n\nIn the first line output a single integer $m$ -- the maximum possible number of arranged teams.\n\nThe next line should contain supervisors: $n−1$ integers, i-th of which denoting the supervisor of employee $i + 1$ (either fake or real). Of course, all real supervisors should be preserved, and employees must form a tree. It should be possible to arrange $m$ teams using specified supervisors.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Hidden Supervisors", "background": "", "description": "\n\nHelena works in a big company as a psychologist. Her task is to organize a team building game to enhance social relations between employees. Each employee except the Big boss has a single supervisor. So, employees of the company form a tree where each employee is a node, and the parent of that node is their supervisor. The root of the tree is the Big boss.\n\nA team building game requires teams of two people. Every team should consist of an employee and their supervisor.\n\nHelena asked every employee except the Big boss to send their supervisor ID. Some of them didn't reply. She is going to assign a fake supervisor to every employee that didn't reply, so that she could arrange as many teams as possible. And, of course, fake and real supervisors must form a tree.\n\nHelena had a difficult, but a successful day organizing the event. Will you be able to assign fake supervisors?\n\n", "inputFormat": "\n\nThe first line of the input contains a single integer $n$ -- the number of employees in the company $(2 \\le n \\le 100 000)$ .\n\nThe following line contains $n − 1$ integers $p_{2}, p_{3},$ . . . , $p_{n},$ where $p_{i}$ is the supervisor of employee $i (0 \\le p_{i} \\le n)$ . If employee $i$ didn't reply to Helena, $p_{i}$ equals zero, and she needs to assign a fake supervisor to that employee. The Big boss has the number $1$ .\n\nIt's possible to assign a fake supervisor to each employee that didn't reply to Helena so that all employees will form a tree having the Big boss as a root.\n\n", "outputFormat": "\n\nIn the first line output a single integer $m$ -- the maximum possible number of arranged teams.\n\nThe next line should contain supervisors: $n−1$ integers, i-th of which denoting the supervisor of employee $i + 1$ (either fake or real). Of course, all real supervisors should be preserved, and employees must form a tree. It should be possible to arrange $m$ teams using specified supervisors.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Hidden Supervisors", "background": null, "description": "有一棵大小为 $n$ 的有根树，根为 $1$，其中若干结点的父亲没有确定。试求出所有可能构成的以 $1$ 为根的有根树中，最大匹配的最大值是多少，并输出构造方案。保证数据有解。", "inputFormat": "第一行输入一个整数 $n$。\n\n第二行输入 $n-1$ 个整数 $p_2,p_3,\\cdots,p_n$，分别表示 $2,3,\\cdots,n$ 的父亲。其中 $p_i = 0$ 表示点 $i$ 的父亲未确定，$p_i \\neq 0$ 表示点 $i$ 的父亲已确定。", "outputFormat": "第一行输出一个整数表示最大匹配的最大值。\n\n第二行输出 $n-1$ 个整数 $p'_2,p'_3,\\cdots,p'_n$，分别表示 $2,3,\\cdots,n$ 的父亲。", "hint": "$2\\leq n\\leq 10^5,0\\leq p_i\\leq n.$", "locale": "zh-CN"}}}
{"pid": "P7027", "type": "P", "difficulty": 2, "samples": [["10\n1 1\n6 1\n6 4\n3 4\n3 3\n5 3\n5 2\n2 2\n2 3\n1 3\n", "6\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Intelligence in Perpendicularia", "background": null, "description": "There are only two directions in Perpendicularia: vertical and horizontal. Perpendicularia government are going to build a new secret service facility. They have some proposed facility plans and want to calculate total secured perimeter for each of them.\n\nThe total secured perimeter is calculated as the total length of the facility walls invisible for the perpendicularly-looking outside observer. The figure below shows one of the proposed plans and corresponding secured perimeter.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2ao0ncji.png)\n\nWrite a program that calculates the total secured perimeter for the given plan of the secret service facility.", "inputFormat": "The plan of the secret service facility is specified as a polygon.\n\nThe first line of the input contains one integer $n$ -- the number of vertices of the polygon $(4 \\le n \\le 1000)$ . Each of the following $n$ lines contains two integers $x_{i}$ and $y_{i} -$ the coordinates of the i-th vertex $(−10^{6} \\le x_{i}, y_{i} \\le 10^{6}).$ Vertices are listed in the consecutive order.\n\nAll polygon vertices are distinct and none of them lie at the polygon's edge. All polygon edges are either vertical $(x_{i} = x_{i+1} or$ horizontal $(y_{i} = y_{i+1})$ and none of them intersect each other.", "outputFormat": "Output a single integer -- the total secured perimeter of the secret service facility.", "hint": "Time limit: 3 s, Memory limit: 512 MB.", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Intelligence in Perpendicularia", "background": null, "description": "There are only two directions in Perpendicularia: vertical and horizontal. Perpendicularia government are going to build a new secret service facility. They have some proposed facility plans and want to calculate total secured perimeter for each of them.\n\nThe total secured perimeter is calculated as the total length of the facility walls invisible for the perpendicularly-looking outside observer. The figure below shows one of the proposed plans and corresponding secured perimeter.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2ao0ncji.png)\n\nWrite a program that calculates the total secured perimeter for the given plan of the secret service facility.", "inputFormat": "The plan of the secret service facility is specified as a polygon.\n\nThe first line of the input contains one integer $n$ -- the number of vertices of the polygon $(4 \\le n \\le 1000)$ . Each of the following $n$ lines contains two integers $x_{i}$ and $y_{i} -$ the coordinates of the i-th vertex $(−10^{6} \\le x_{i}, y_{i} \\le 10^{6}).$ Vertices are listed in the consecutive order.\n\nAll polygon vertices are distinct and none of them lie at the polygon's edge. All polygon edges are either vertical $(x_{i} = x_{i+1} or$ horizontal $(y_{i} = y_{i+1})$ and none of them intersect each other.", "outputFormat": "Output a single integer -- the total secured perimeter of the secret service facility.", "hint": "Time limit: 3 s, Memory limit: 512 MB.", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Intelligence in Perpendicularia", "background": "", "description": "给你一个数 $ n $ ，再给你 $ n $ 个点（$ x_i , y_i $），这 $ n $ 个点依次连成一个多边形。（保证多边形的每条边都与坐标轴平行或垂直，点不重合，点不在边上，边无相交）\n\n求有多长的边是安全的？\n\n（一个单位长度的边是安全的当且仅当它向外平移后能与其余边相遇，结合一下图看看）", "inputFormat": "第一行一个数$ n $,表示有多少个定点。\n\n接下来 $ n $ 行，行两个数 $ x_i \\; y_i $ 表示每个点的坐标。", "outputFormat": "一个数，表示安全的长度。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7028", "type": "P", "difficulty": 6, "samples": [["4 7\n1 -5 3 -5\n4 -1\n2 -1\n3 10\n4 10\n1 -1\n2 1\n3 -1\n", "3\n1\n3\n3\n1\n4\n4\n4\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "分块", "凸包", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Joker", "background": "", "description": "\n\nJoker prepares a new card trick with a strong mathematical background. You are asked to help Joker with calculations.\n\nThere is a row of $n$ cards with non-zero numbers $a_{i}$ written on them. Let's call the sum of all positive numbers $P$ and the sum of all negative numbers $N$ . Every card $i$ has a weight $w_{i} = a_{i}/P$ if $a_{i} > 0$ and $a_{i}/|N|$ otherwise.\n\nLet's denote $s_{i} = ( \\sum_{j=1}^{j \\le i}{w_j})$. Joker needs to know positive $i$ with the largest $s_{i}.$ If there is more than one such $i$ , he is interested in the smallest one.\n\nBut static tricks are boring, so Joker wants to change numbers on some cards, and after each change he needs to known where is the largest $s_{i}$ is.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $n$ and $m$ -- the number of cards and the number of changes $(1 \\le n , m \\le 50 000)$ .\n\nThe second line consists of $n$ integers $a_{i}$ -- numbers written on cards at the beginning $(−10^{9} \\le a_{i} \\le 10^{9}; a_{i} ≠ 0)$ .\n\nThe following $m$ lines contain two integers each: $p_{i}$ and $v_{i},$ that means value of card at position $p_{i}$ is changed to $v_{i} (1 \\le p_{i} \\le n$ ; $−10^{9} \\le v_{i} \\le 10^{9}; v_{i} ≠ 0)$ .\n\nIt is guaranteed that at each moment there is at least one card with positive number and at least one card with negative number. The sum of all positive cards will never exceed $10^{9}$ and the sum of all negative cards will never exceed $−10^{9}.$\n\n", "outputFormat": "\n\nYou should output $m+1$ integers. The first integer is the position of the largest $s_{i}$ for the initial numbers. Next $m$ numbers are positions of the largest $s_{i}$ after each change.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Joker", "background": "", "description": "\n\nJoker prepares a new card trick with a strong mathematical background. You are asked to help Joker with calculations.\n\nThere is a row of $n$ cards with non-zero numbers $a_{i}$ written on them. Let's call the sum of all positive numbers $P$ and the sum of all negative numbers $N$ . Every card $i$ has a weight $w_{i} = a_{i}/P$ if $a_{i} > 0$ and $a_{i}/|N|$ otherwise.\n\nLet's denote $s_{i} = ( \\sum_{j=1}^{j \\le i}{w_j})$. Joker needs to know positive $i$ with the largest $s_{i}.$ If there is more than one such $i$ , he is interested in the smallest one.\n\nBut static tricks are boring, so Joker wants to change numbers on some cards, and after each change he needs to known where is the largest $s_{i}$ is.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $n$ and $m$ -- the number of cards and the number of changes $(1 \\le n , m \\le 50 000)$ .\n\nThe second line consists of $n$ integers $a_{i}$ -- numbers written on cards at the beginning $(−10^{9} \\le a_{i} \\le 10^{9}; a_{i} ≠ 0)$ .\n\nThe following $m$ lines contain two integers each: $p_{i}$ and $v_{i},$ that means value of card at position $p_{i}$ is changed to $v_{i} (1 \\le p_{i} \\le n$ ; $−10^{9} \\le v_{i} \\le 10^{9}; v_{i} ≠ 0)$ .\n\nIt is guaranteed that at each moment there is at least one card with positive number and at least one card with negative number. The sum of all positive cards will never exceed $10^{9}$ and the sum of all negative cards will never exceed $−10^{9}.$\n\n", "outputFormat": "\n\nYou should output $m+1$ integers. The first integer is the position of the largest $s_{i}$ for the initial numbers. Next $m$ numbers are positions of the largest $s_{i}$ after each change.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Joker", "background": "", "description": "Joker 准备了一种新的纸牌戏法，具有强烈的数学背景。你被要求帮助 Joker 进行计算。\n\n有一排 $n$ 张牌，上面写着非零数字 $a_{i}$。我们称所有正数的和为 $P$，所有负数的和为 $N$。每张牌 $i$ 的权重为 $w_{i} = a_{i}/P$ 如果 $a_{i} > 0$，否则为 $a_{i}/|N|$。\n\n我们用 $s_{i} = ( \\sum_{j=1}^{j \\le i}{w_j})$ 表示。Joker 需要知道使 $s_{i}$ 最大的正整数 $i$。如果有多个这样的 $i$，他对最小的一个感兴趣。\n\n但静态的戏法很无聊，所以 Joker 想要改变一些牌上的数字，并且在每次改变后，他需要知道最大的 $s_{i}$ 在哪里。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $m$ —— 牌的数量和变化的次数 $(1 \\le n , m \\le 50 000)$。\n\n第二行包含 $n$ 个整数 $a_{i}$ —— 初始时牌上写的数字 $(-10^{9} \\le a_{i} \\le 10^{9}; a_{i} \neq 0)$。\n\n接下来的 $m$ 行每行包含两个整数：$p_{i}$ 和 $v_{i}$，表示位置 $p_{i}$ 的牌的值被改为 $v_{i} (1 \\le p_{i} \\le n$；$-10^{9} \\le v_{i} \\le 10^{9}; v_{i} \neq 0)$。\n\n保证在每个时刻至少有一张牌上的数字是正的，至少有一张牌上的数字是负的。所有正数牌的和不会超过 $10^{9}$，所有负数牌的和不会超过 $-10^{9}$。", "outputFormat": "你应该输出 $m+1$ 个整数。第一个整数是初始数字时最大的 $s_{i}$ 的位置。接下来的 $m$ 个数字是在每次变化后最大的 $s_{i}$ 的位置。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7029", "type": "P", "difficulty": 0, "samples": [["3 5 4\n", "..#..\n#####\n..#..\n"], ["2 1 1\n", "#\n.\n"], ["5 3 10\n", "Impossible\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Kotlin Island", "background": "", "description": "\n\nThere is an urban myth that Peter the Great wanted to make a rectangular channel-grid engineering masterpiece not only from Vasilyevskiy island, but also from Kotlin island (where the town of Kronstadt is located nowadays).\n\nThe following mathematical model was (allegedly) presented to the tsar. The island is considered a rectangular grid $h$ cells high and $w$ cells wide. Each cell is dry land initially but can become water.\n\nTechnologies of those days allowed engineers to dig a channel across the entire island. In that case an entire row or an entire column of cells became water. If some of these cells already were water, their status did not change.\n\nYour task is to propose a plan of the island which has exactly $n$ connected components of dry land cells.\n\n", "inputFormat": "\n\nThe only line of the input contains three integers $h , w$ , and $n$ -- grid's height, width and the desired number of connected components $(1 \\le h , w \\le 100$ ; $1 \\le n \\le 10^{9}).$\n\n", "outputFormat": "\n\nIf there is no valid plan containing $n$ connected components, output a single word `Impossible`.\n\nOtherwise output $h$ lines of length $w$ depicting the plan. Dot $(‘. ')$ represents a dry land cell, hash $(‘#')$ represents a water cell.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Kotlin Island", "background": "", "description": "\n\nThere is an urban myth that Peter the Great wanted to make a rectangular channel-grid engineering masterpiece not only from Vasilyevskiy island, but also from Kotlin island (where the town of Kronstadt is located nowadays).\n\nThe following mathematical model was (allegedly) presented to the tsar. The island is considered a rectangular grid $h$ cells high and $w$ cells wide. Each cell is dry land initially but can become water.\n\nTechnologies of those days allowed engineers to dig a channel across the entire island. In that case an entire row or an entire column of cells became water. If some of these cells already were water, their status did not change.\n\nYour task is to propose a plan of the island which has exactly $n$ connected components of dry land cells.\n\n", "inputFormat": "\n\nThe only line of the input contains three integers $h , w$ , and $n$ -- grid's height, width and the desired number of connected components $(1 \\le h , w \\le 100$ ; $1 \\le n \\le 10^{9}).$\n\n", "outputFormat": "\n\nIf there is no valid plan containing $n$ connected components, output a single word `Impossible`.\n\nOtherwise output $h$ lines of length $w$ depicting the plan. Dot $(‘. ')$ represents a dry land cell, hash $(‘#')$ represents a water cell.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Kotlin Island", "background": "", "description": "有一个都市传说，说彼得大帝不仅想把瓦西里耶夫斯基岛建造成一个矩形渠道网的工程杰作，还想把科特林岛（如今克朗施塔特镇所在地）也建造成这样的工程。据说，以下数学模型曾被呈现给沙皇。岛被视为一个矩形网格，高为 $h$ 个单元格，宽为 $w$ 个单元格。每个单元格最初都是陆地，但可以变成水。 当时的技术允许工程师在整个岛上挖掘一条渠道。在这种情况下，整个行或整个列的单元格变成水。如果其中一些单元格已经是水，它们的状态不会改变。你的任务是提出一个岛屿计划，使其恰好有 $n$ 个连通的陆地单元格。", "inputFormat": "输入的唯一一行包含三个整数 $h, w$ 和 $n$，分别表示网格的高度、宽度和所需的连通陆地区域的数量 $(1 \\le h, w \\le 100; 1 \\le n \\le 10^{9})$。", "outputFormat": "如果没有包含 $n$ 个连通区域的有效计划，则输出一个单词 `Impossible`。否则，输出 $h$ 行，每行长度为 $w$，描述该计划。点（‘.’）表示一个陆地单元格，井号（‘#’）表示一个水单元格。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7030", "type": "P", "difficulty": 3, "samples": [["12\n", "3\n1 12\n3 2 3 2\n2 4 3\n"], ["1\n", "-1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2017", "二分", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Little Difference", "background": "", "description": "\n\nLittle Lidia likes playing with numbers. Today she has a positive integer $n$ , and she wants to decompose it to the product of positive integers.\n\nBecause Lidia is little, she likes to play with numbers with little difference. So, all numbers in decomposition should differ by at most one. And of course, the product of all numbers in the decomposition must be equal to $n$ . She considers two decompositions the same if and only if they have the same number of integers and there is a permutation that transforms the first one to the second one.\n\nWrite a program that finds all decompositions, which little Lidia can play with today.\n\n", "inputFormat": "\n\nThe only line of the input contains a single integer $n (1 \\le n \\le 10^{18}).$\n\n", "outputFormat": "\n\nIn first line output the number of decompositions of $n$ , or $−1$ if this number is infinite. If number of decompositions is finite, print all of them one per line. In each line first print number $k_{i}$ of elements in decomposition. Then print $k_{i}$ integers in this decomposition in any order. Don't forget that decompositions which are different only in order of elements are considered the same.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Little Difference", "background": "", "description": "\n\nLittle Lidia likes playing with numbers. Today she has a positive integer $n$ , and she wants to decompose it to the product of positive integers.\n\nBecause Lidia is little, she likes to play with numbers with little difference. So, all numbers in decomposition should differ by at most one. And of course, the product of all numbers in the decomposition must be equal to $n$ . She considers two decompositions the same if and only if they have the same number of integers and there is a permutation that transforms the first one to the second one.\n\nWrite a program that finds all decompositions, which little Lidia can play with today.\n\n", "inputFormat": "\n\nThe only line of the input contains a single integer $n (1 \\le n \\le 10^{18}).$\n\n", "outputFormat": "\n\nIn first line output the number of decompositions of $n$ , or $−1$ if this number is infinite. If number of decompositions is finite, print all of them one per line. In each line first print number $k_{i}$ of elements in decomposition. Then print $k_{i}$ integers in this decomposition in any order. Don't forget that decompositions which are different only in order of elements are considered the same.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Little Difference", "background": "", "description": "小莉迪亚喜欢玩数字。今天她有一个正整数 $n$，她想把它分解为若干个正整数的乘积。  \n\n因为莉迪亚还小，她喜欢玩差别很小的数字。所以，分解中的所有数字的差值最多为 1。当然，分解中所有数字的乘积必须等于 $n$。她认为两个分解相同当且仅当它们有相同数量的整数，并且存在一个排列可以将第一个分解变换为第二个分解。  \n\n编写一个程序，找出所有小莉迪亚今天可以玩的分解。", "inputFormat": "输入的唯一一行包含一个整数 $n (1 \\le n \\le 10^{18})$。", "outputFormat": "第一行输出 $n$ 的分解数量，如果这个数量是无限的则输出 $-1$。如果分解数量是有限的，逐行输出所有分解。在每一行中，首先输出分解中元素的数量 $k_{i}$。然后输出该分解中的 $k_{i}$ 个整数，顺序可以是任意的。不要忘记，仅在元素顺序上不同的分解被认为是相同的。", "hint": "时间限制：3 秒，内存限制：512 MB。  \n\nspj 提供者：@[shenyouran](\\/user\\/137367)。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7031", "type": "P", "difficulty": 1, "samples": [["7 3 2 2 3 2 \n", "0 0 4 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2016", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2016] Anniversary Cake", "background": "", "description": "\n\nTwo students, Adam and Anton, are celebrating two-year anniversary of not passing their Math $Logic exa_m.$ After very careful search in a local supermarket, they bought a rectangular cake with $integer dimensions$ and two candles.\n\nLater in the campus Adam put the candles into different integer points of the cake and gave a knife $to Anto_n$ to cut the cake. The cut should start and end at integer points at the edges of the cake, and $it should$ not touch the candles. Also each piece should have exactly one candle at it. Please, help $Anto_n to$ find the starting and ending points of the cut.\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13473/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-11-01%20%EC%98%A4%ED%9B%84%202.30.49.png)\n\nA $7 \\times 3$ cake and two candles at $(2 , 2)$ and $(3 , 2)$ .\n\nAnton can cut this cake through $(0 , 0)$ and $(4 , 3)$ .\n\n", "inputFormat": "\n\nThe single line of the input contains six integers: $w , h$ -- cake dimensions; $a_{x}, a_{y}$ -- $x$ and $y coordinates$ of the first candle; $b_{x}, b_{y}$ -- the coordinates of the second candle $(3 \\le w , h \\le 10^{9}; 0 < a_{x}, b_{x} < w$ ; $0 < a_{y}, b_{y} < h$ ; $a_{x} ≠ b_{x}$ or $a_{y }≠ b_{y}).$\n\n", "outputFormat": "\n\nOutput four integers $s_{x}, s_{y}, e_{x},$ and $e_{y}$ -- the starting and ending coordinates of the cut. Both $starting and$ ending point of the cut should belong to the sides of the cake.\n\nIf there are several solutions, output any of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\nspj provider:@[shenyouran](/user/137367)", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Anniversary Cake", "background": "", "description": "\n\nTwo students, Adam and Anton, are celebrating two-year anniversary of not passing their Math $Logic exa_m.$ After very careful search in a local supermarket, they bought a rectangular cake with $integer dimensions$ and two candles.\n\nLater in the campus Adam put the candles into different integer points of the cake and gave a knife $to Anto_n$ to cut the cake. The cut should start and end at integer points at the edges of the cake, and $it should$ not touch the candles. Also each piece should have exactly one candle at it. Please, help $Anto_n to$ find the starting and ending points of the cut.\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13473/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-11-01%20%EC%98%A4%ED%9B%84%202.30.49.png)\n\nA $7 \\times 3$ cake and two candles at $(2 , 2)$ and $(3 , 2)$ .\n\nAnton can cut this cake through $(0 , 0)$ and $(4 , 3)$ .\n\n", "inputFormat": "\n\nThe single line of the input contains six integers: $w , h$ -- cake dimensions; $a_{x}, a_{y}$ -- $x$ and $y coordinates$ of the first candle; $b_{x}, b_{y}$ -- the coordinates of the second candle $(3 \\le w , h \\le 10^{9}; 0 < a_{x}, b_{x} < w$ ; $0 < a_{y}, b_{y} < h$ ; $a_{x} ≠ b_{x}$ or $a_{y }≠ b_{y}).$\n\n", "outputFormat": "\n\nOutput four integers $s_{x}, s_{y}, e_{x},$ and $e_{y}$ -- the starting and ending coordinates of the cut. Both $starting and$ ending point of the cut should belong to the sides of the cake.\n\nIf there are several solutions, output any of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\nspj provider:@[shenyouran](/user/137367)", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Anniversary Cake", "background": "", "description": "两个学生，Adam 和 Anton，正在庆祝他们未通过数学逻辑考试两周年。在当地超市经过仔细挑选后，他们买了一个长方形的蛋糕，蛋糕的尺寸是整数，并且有两根蜡烛。\n\n后来在校园里，Adam 把蜡烛插在蛋糕的不同整数点上，并把刀交给 Anton 来切蛋糕。切口应该从蛋糕边缘的整数点开始和结束，并且不能碰到蜡烛。每一块蛋糕上应该正好有一根蜡烛。请帮助 Anton 找到切口的起点和终点。\n\n一个 $7 \\times 3$ 的蛋糕和两个蜡烛放在 $(2, 2)$ 和 $(3, 2)$。\n\nAnton 可以从 $(0, 0)$ 到 $(4, 3)$ 切开这个蛋糕。", "inputFormat": "输入的单行包含六个整数：$w, h$ —— 蛋糕的尺寸；$a_{x}, a_{y}$ —— 第一根蜡烛的 $x$ 和 $y$ 坐标；$b_{x}, b_{y}$ —— 第二根蜡烛的坐标（$3 \\le w, h \\le 10^{9}; 0 < a_{x}, b_{x} < w; 0 < a_{y}, b_{y} < h; a_{x} \neq b_{x}$ 或 $a_{y} \neq b_{y}$）。", "outputFormat": "输出四个整数 $s_{x}, s_{y}, e_{x}, e_{y}$ —— 切口的起点和终点坐标。切口的起点和终点都应该在蛋糕的边缘上。\n\n如果有多个解决方案，输出其中任意一个。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\nspj 提供者：@[shenyouran](\\/user\\/137367)\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7032", "type": "P", "difficulty": 6, "samples": [["10 5 7\n", "BGBGBGBGGG\n"], ["10 3 8\n", "Impossible\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2016] Boys and Girls", "background": "", "description": "\n\nBob found a nice task in his old math book for children. It says:\n\nThere are $10$ children standing in a circle, $5$ of them stand next to a boy, and $7$ of them stand next to a girl. How is it possible?\n\nHere is the solution to the task. If $4$ boys and $6$ girls stand like this: BGBGBGBGGG, there are $5$ children who stand next to a boy (here they are underlined: BGBGBGBGGG), and $7$ children who stand next to a girl $(BGBGBGBGGG).$\n\nNow Bob wants to solve a generalized version of this task:\n\nThere are $n$ children standing in a circle, $x$ of them stand next to a boy, and $y$ of them stand next to a girl. How is it possible?\n\nHelp Bob by writing a program that solves the generalized task.\n\n", "inputFormat": "\n\nThe single line of the input contains three integers $n , x$ and $y (2 \\le n \\le 100 000$ ; $0 \\le x , y \\le n)$ .\n\n", "outputFormat": "\n\nIf there is a solution, output a string of length $n$ , describing the order of children in the circle. $Character ‘G'$ corresponds to a girl, character $‘B'$ corresponds to a boy. If there are several solutions, output any $of the_m.$\n\nIf there is no solution, output `Impossible`.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Boys and Girls", "background": "", "description": "\n\nBob found a nice task in his old math book for children. It says:\n\nThere are $10$ children standing in a circle, $5$ of them stand next to a boy, and $7$ of them stand next to a girl. How is it possible?\n\nHere is the solution to the task. If $4$ boys and $6$ girls stand like this: BGBGBGBGGG, there are $5$ children who stand next to a boy (here they are underlined: BGBGBGBGGG), and $7$ children who stand next to a girl $(BGBGBGBGGG).$\n\nNow Bob wants to solve a generalized version of this task:\n\nThere are $n$ children standing in a circle, $x$ of them stand next to a boy, and $y$ of them stand next to a girl. How is it possible?\n\nHelp Bob by writing a program that solves the generalized task.\n\n", "inputFormat": "\n\nThe single line of the input contains three integers $n , x$ and $y (2 \\le n \\le 100 000$ ; $0 \\le x , y \\le n)$ .\n\n", "outputFormat": "\n\nIf there is a solution, output a string of length $n$ , describing the order of children in the circle. $Character ‘G'$ corresponds to a girl, character $‘B'$ corresponds to a boy. If there are several solutions, output any $of the_m.$\n\nIf there is no solution, output `Impossible`.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Boys and Girls", "background": "", "description": "Bob在他那本给孩子们的旧数学书中找到了一个好任务。上面写着：\n\n有 $10$ 个孩子站成一个圆圈，其中 $5$ 个站在一个男孩旁边， $7$ 个站在一个女孩旁边。如何解决这个任务？\n\n这个任务的解决方案如下：如果 $4$ 个男孩和 $6$ 个女孩像这样站着：$bgbgbbggg$，那么有 555 个孩子站在一个男孩旁边（用粗体字标记：b**g**b**g**b**g**b**g**g**g**）， 777 个孩子站在一个女孩旁边（用粗体字标记：**b**g**b**g**b**g**bggg**）。\n\n现在Bob想解决这个任务的广义版本：\n\n有 $n$ 个孩子站在一个圆圈里，其中 $x$ 个孩子站在一个男孩旁边， $y$ 个孩子站在一个女孩旁边。如何解决这个任务？\n\n请编写一个程序来帮助Bob解决这个任务。", "inputFormat": "一行，包括三个整数 $n$ , $x$ , $y$ 。($2≤n≤100000$; $0≤x,y≤n$)", "outputFormat": "若有解，输出一个长度为 $n$ 的字符串，描述圆中元素的顺序。每个字符 $G$ 对应一个女孩，字符 $B$ 对应一个男孩。如果有多个解决方案，则输出其中任意一种。\n如果没有解决方案，输出```'Impossible'```\n。（不包括引号）", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7033", "type": "P", "difficulty": 4, "samples": [["4\n2 3\n3 2\n1 1\n4 5\n", "2\n2\n0\n3\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "ICPC", "NWRRC"], "title": "[NWRRC 2016] CodeCoder vs TopForces", "background": "", "description": "\n\nCompetitive programming is very popular in Byteland. In fact, every Bytelandian citizen is registered at two programming sites -- CodeCoder and TopForces. Each site maintains its own proprietary rating system. Each citizen has a unique integer rating at each site that approximates their skill. Greater rating corresponds to better skill.\n\nPeople of Byteland are naturally optimistic. Citizen A thinks that he has a chance to beat citizen B in a programming competition if there exists a sequence of Bytelandian citizens $A = P_{0}, P_{1},...,P_{k} = B$ for some $k \\ge 1$ such that for each $i (0 \\le i < k) , P_{i}$ has higher rating than $P_{i+1}$ at one or both sites.\n\nEach Bytelandian citizen wants to know how many other citizens they can possibly beat in a programming competition.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $n$ -- the number of citizens $(1 \\le n \\le 100 000)$ . $The following n$ lines contain information about ratings. The i-th of them contains two integers $CC_{i} and TF_{i}$ -- ratings of the i-th citizen at CodeCoder and TopForces $(1 \\le CC_{i}, TF_{i} \\le 10^{6}).$ All the ratings at each site are distinct.\n\n", "outputFormat": "\n\nFor each citizen $i$ output an integer $b_{i}$ -- how many other citizens they can possibly beat in a programming competition. Each $b_{i}$ should be printed in a separate line, in the order the citizens are given in the input.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] CodeCoder vs TopForces", "background": "", "description": "\n\nCompetitive programming is very popular in Byteland. In fact, every Bytelandian citizen is registered at two programming sites -- CodeCoder and TopForces. Each site maintains its own proprietary rating system. Each citizen has a unique integer rating at each site that approximates their skill. Greater rating corresponds to better skill.\n\nPeople of Byteland are naturally optimistic. Citizen A thinks that he has a chance to beat citizen B in a programming competition if there exists a sequence of Bytelandian citizens $A = P_{0}, P_{1},...,P_{k} = B$ for some $k \\ge 1$ such that for each $i (0 \\le i < k) , P_{i}$ has higher rating than $P_{i+1}$ at one or both sites.\n\nEach Bytelandian citizen wants to know how many other citizens they can possibly beat in a programming competition.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $n$ -- the number of citizens $(1 \\le n \\le 100 000)$ . $The following n$ lines contain information about ratings. The i-th of them contains two integers $CC_{i} and TF_{i}$ -- ratings of the i-th citizen at CodeCoder and TopForces $(1 \\le CC_{i}, TF_{i} \\le 10^{6}).$ All the ratings at each site are distinct.\n\n", "outputFormat": "\n\nFor each citizen $i$ output an integer $b_{i}$ -- how many other citizens they can possibly beat in a programming competition. Each $b_{i}$ should be printed in a separate line, in the order the citizens are given in the input.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] CodeCoder vs TopForces", "background": "", "description": "在 Byteland，竞赛编程非常流行。事实上，每位 Byteland 的公民都在两个编程网站——CodeCoder 和 TopForces 上注册。每个网站都有自己专有的评分系统。每位公民在每个网站上都有一个唯一的整数评分，代表他们的技能。评分越高，技能越好。\n\nByteland 的人天生乐观。公民 A 认为，如果存在一个 Byteland 公民的序列 $A = P_{0}, P_{1},...,P_{k} = B$，对于某个 $k \\ge 1$，使得对于每个 $i (0 \\le i < k)$，$P_{i}$ 在一个或两个网站上的评分都高于 $P_{i+1}$，那么他就有机会在编程比赛中击败公民 B。\n\n每位 Byteland 公民都想知道他们在编程比赛中可能击败多少其他公民。", "inputFormat": "输入的第一行包含一个整数 $n$——公民的数量 $(1 \\le n \\le 100 000)$。接下来的 $n$ 行包含关于评分的信息。第 $i$ 行包含两个整数 $CC_{i}$ 和 $TF_{i}$——第 $i$ 位公民在 CodeCoder 和 TopForces 上的评分 $(1 \\le CC_{i}, TF_{i} \\le 10^{6})$。每个网站上的所有评分都是不同的。", "outputFormat": "对于每位公民 $i$，输出一个整数 $b_{i}$——他们在编程比赛中可能击败的其他公民数量。每个 $b_{i}$ 应该单独一行输出，顺序与输入中给出的公民顺序相同。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7034", "type": "P", "difficulty": 5, "samples": [["2\n 1 1\n0 1 1\n 1 0\n0 1 1\n 1 1\n0 1 1\n 1 0\n0 1 1\n 0 0\n", "37\n34\n71\n"], ["1\n 1\n0 1\n 1\n1 1\n 1\n1 1\n 1\n0 1\n 0\n", "2\n2\n4\n"], ["1\n 1\n1 0\n 1\n1 1\n 1\n1 1\n 1\n0 1\n 0\n", "NO\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2016] Digital Addition", "background": "", "description": "\n\nDeidra is doing a columnar addition. She writes down two non-negative integer summands one below the other, left-pads them with zeroes so that they have equal length, and calculates the sum (e.g. $ 77 + 05 = 82$) . If the sum is longer than each of the summands (because of a carry, as in $96 + 07 = 103$) she appends a zero at the beginning of each summand ($096 + 007 = 103)$ . She allows herself to use unnecessary leading zeroes ( $007 + 004 = 011)$ as soon as the length of all three numbers is the same.\n\nAlso Deidra has a homemade printing press. She decided to print her addition without a plus or $a horizontal$ line, using the following standard font:\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13476/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-11-01%20%EC%98%A4%ED%9B%84%202.41.11.png)\n\nUnfortunately, she messed up with spacing, and all the digits were printed over each other in the following way. Digits that were supposed to be horizontally adjacent were printed so that the right two segments of the left digit coincide with the left two segments of the right digit. Digits that were supposed to be vertically adjacent were printed so that the bottom half (a square with 4 segments) of the upper digit coincides with the top half of the lower digit.\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13476/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-11-01%20%EC%98%A4%ED%9B%84%202.41.17.png)\n\nWhen one or more black segments are printed at the same position, the result looks black. When only empty segments are printed at the position, the result looks white.\n\nGiven the resulting picture, find a correct addition that could produce it or detect that there is none.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $w (1 \\le w \\le 100)$ -- the width of Deidra's addition $(number of$ digits in each line).\n\nThe following $9$ lines contain the description of the picture printed with the bad spacing. Each line contains $w$ or $w + 1$ digits. ‘1' denotes a black segment, ‘0' denotes a white one. Even lines start with a space. See the examples for clarification.\n\n", "outputFormat": "\n\nIf there is no valid addition, output `NO`.\n\nOtherwise output a valid addition that produces the given figure. The output should consist of three lines, each containing $w$ digits.\n\nIf there are several solutions, output any of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Digital Addition", "background": "", "description": "\n\nDeidra is doing a columnar addition. She writes down two non-negative integer summands one below the other, left-pads them with zeroes so that they have equal length, and calculates the sum (e.g. $ 77 + 05 = 82$) . If the sum is longer than each of the summands (because of a carry, as in $96 + 07 = 103$) she appends a zero at the beginning of each summand ($096 + 007 = 103)$ . She allows herself to use unnecessary leading zeroes ( $007 + 004 = 011)$ as soon as the length of all three numbers is the same.\n\nAlso Deidra has a homemade printing press. She decided to print her addition without a plus or $a horizontal$ line, using the following standard font:\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13476/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-11-01%20%EC%98%A4%ED%9B%84%202.41.11.png)\n\nUnfortunately, she messed up with spacing, and all the digits were printed over each other in the following way. Digits that were supposed to be horizontally adjacent were printed so that the right two segments of the left digit coincide with the left two segments of the right digit. Digits that were supposed to be vertically adjacent were printed so that the bottom half (a square with 4 segments) of the upper digit coincides with the top half of the lower digit.\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13476/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-11-01%20%EC%98%A4%ED%9B%84%202.41.17.png)\n\nWhen one or more black segments are printed at the same position, the result looks black. When only empty segments are printed at the position, the result looks white.\n\nGiven the resulting picture, find a correct addition that could produce it or detect that there is none.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $w (1 \\le w \\le 100)$ -- the width of Deidra's addition $(number of$ digits in each line).\n\nThe following $9$ lines contain the description of the picture printed with the bad spacing. Each line contains $w$ or $w + 1$ digits. ‘1' denotes a black segment, ‘0' denotes a white one. Even lines start with a space. See the examples for clarification.\n\n", "outputFormat": "\n\nIf there is no valid addition, output `NO`.\n\nOtherwise output a valid addition that produces the given figure. The output should consist of three lines, each containing $w$ digits.\n\nIf there are several solutions, output any of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Digital Addition", "background": null, "description": "Deidra 正在做一个列式的加法。她写下两个正整数来对其进行求和，且一个在另一个下方，在它们的左边添 0，使得他们拥有相同的长度，然后相加计算结果（例如 $77 + 05 = 82$）。如果这个结果的长度大于这两个加数任何一个的长度（由于进位，例如$96 + 07 = 103$），就在两个加数前面附加零（$096 + 007 = 103$）。她允许不必要的前导零的出现（$007 + 004 = 011$）只要算式中的三个数字的长度都相同。\n\nDeidra 还有一台自制的打印机。她决定在没有加号和水平线的情况下打印她的加法算式，使用下面的标准字体：\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13476/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-11-01%20%EC%98%A4%ED%9B%84%202.41.11.png)\n\n不幸的是，她弄乱了这些数字的间距，所有的数字都将以以下方式打印。打印这些本应水平相邻的数字时左边数字的右两段与右边数字的左两端重合。打印应该竖直相邻的数字时，上边数字的下半部分（由四段组成的正方形部分）与下边数字的上半部分重合。\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13476/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-11-01%20%EC%98%A4%ED%9B%84%202.41.17.png)\n\n如果在同一位置打印一个或多个线段时，将显示为黑色。当所在位置仅打印空段时，将显示为白色。\n\n给定一个生成的图片，找到可以通过打印机产生这个图片的正确算式。如果找不到符合要求的算式，就输出 `NO`。", "inputFormat": "第一行包含一个整数 $w(1\\le w \\le 100)$ 代表 Deidra 加法的宽度（接下来每行的数字个数）。\n\n接下来的 $9$ 行包含对于用错误打印机输出的图片的描述。每行包含 $w$ 或 $w+1$ 个数字。`1` 表示黑色段，`0` 表示白色段。偶数行以空格开头。有关说明请参阅样例。", "outputFormat": "如果没有符合要求的算式，则输出 `NO`。\n\n否则输出给定图片所对应的有效算式。输出应由三行组成，每行包含 $w$ 个数字。\n\n如果有多个符合规定的算式，请输出其任何一个。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P7035", "type": "P", "difficulty": 6, "samples": [["43\nyou should read statement really carefully.\n3 6\n...XX.\n..XXX.\n...XXX\n", "YES\n3 42\n"], ["43\nyou should read statement really carefully.\n3 2\nXX\nXX\nXX\n", "NO\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2016] Easy Reading", "background": "", "description": "\n\nEugene is reading a boring book. To make this process interesting he is drawing a picture at the  same time.  He has a piece of graph paper that is divided into square cells. All the cells are empty at  the beginning. \n\nEugene starts by painting over one cell. Then he opens the book at a random page and starts reading.   Whenever  he sees the letter  `u`  in the text, he moves his pen one cell up and then paints over the  cell under  his pen. Whenever he sees the letter  `d`,  he does the same but moves his pen one cell down  instead of  up. For letters  `l`  and  `r`  he moves to the left and to the right, respectively. If he wants to paint  a cell  that was already painted, he paints it again.\n\nYou have found a piece of paper and the text of the book. Now you want to understand if the picture  o_n the  paper could be drawn by Eugene at some point of his book reading. Remember that Eugene  could use  some substring of the text.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $l$ -- the length of the text $(1 \\le l \\le 100 000)$ . The $second line$ contains a string of length $l$ -- the text. It contains only lowercase English letters, spaces, commas and periods. The text neither begins nor ends with a space.\n\nThe third line contains two positive integers $n$ and $m$ -- the picture dimensions $(2 \\le n \\times m \\le 100 000)$ .\n\nEach of the following $n$ lines contains a string of length $m$ . Painted cells are denoted by `X`, while empty cells -- by `.` . It is guaranteed that there are at least two painted cells in the picture.\n\nThe first of these $n$ lines corresponds to the top of the picture and the last one corresponds to the bottom of it.\n\n", "outputFormat": "\n\nIf the picture could be painted by Eugene, output `YES` on the first line. On the second line print two integers b and $e$ such that if Eugene read all letters from $b$ to $e$ , inclusive, he would draw exactly $the same$ picture as described in the input $(1 \\le b \\le e \\le l)$ . If there are several solutions, output any of them.\n\nIf the picture couldn't be drawn by Eugene, output `NO`.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Easy Reading", "background": "", "description": "\n\nEugene is reading a boring book. To make this process interesting he is drawing a picture at the  same time.  He has a piece of graph paper that is divided into square cells. All the cells are empty at  the beginning. \n\nEugene starts by painting over one cell. Then he opens the book at a random page and starts reading.   Whenever  he sees the letter  `u`  in the text, he moves his pen one cell up and then paints over the  cell under  his pen. Whenever he sees the letter  `d`,  he does the same but moves his pen one cell down  instead of  up. For letters  `l`  and  `r`  he moves to the left and to the right, respectively. If he wants to paint  a cell  that was already painted, he paints it again.\n\nYou have found a piece of paper and the text of the book. Now you want to understand if the picture  o_n the  paper could be drawn by Eugene at some point of his book reading. Remember that Eugene  could use  some substring of the text.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $l$ -- the length of the text $(1 \\le l \\le 100 000)$ . The $second line$ contains a string of length $l$ -- the text. It contains only lowercase English letters, spaces, commas and periods. The text neither begins nor ends with a space.\n\nThe third line contains two positive integers $n$ and $m$ -- the picture dimensions $(2 \\le n \\times m \\le 100 000)$ .\n\nEach of the following $n$ lines contains a string of length $m$ . Painted cells are denoted by `X`, while empty cells -- by `.` . It is guaranteed that there are at least two painted cells in the picture.\n\nThe first of these $n$ lines corresponds to the top of the picture and the last one corresponds to the bottom of it.\n\n", "outputFormat": "\n\nIf the picture could be painted by Eugene, output `YES` on the first line. On the second line print two integers b and $e$ such that if Eugene read all letters from $b$ to $e$ , inclusive, he would draw exactly $the same$ picture as described in the input $(1 \\le b \\le e \\le l)$ . If there are several solutions, output any of them.\n\nIf the picture couldn't be drawn by Eugene, output `NO`.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Easy Reading", "background": "", "description": "Eugene正在读一本无聊的书。为了使阅读更有趣，他在阅读的同时同时作画。 他有一张方格纸。 所有的方格一开始都是空的。\n\nEugene一开始在一个方格上作画。让后他随机翻开一页并开始阅读。当他遇到字母 `u`  时, 他把笔向上移动一格并在这格上画画。 当他看到 `d`时, 他会做同样的操作，但是向下移动一格而不是向上移动一格。 `l` ,`r`分别是向左和向右一格。 如果这个单元格已经画过了他会再画一次。\n\n现在你有一张纸与这本书中的内容。 现在你想知道这张纸上的图片是否可能被Eugene在某一时刻画过。 记住：Eugene可以只使用用这个内容的子字符串。", "inputFormat": "第一行是一个整数$l(1 \\le l \\le 10^5)$--表示这个内容的长度。 \n\n第二行是一个长度为$l$的字符串$a$。它只包含小写英文字母、空格、逗号和句号。$a$既不会以空格开头也不会以空格结尾。\n\n第三行是两个整数$n$ 与 $m$--图的大小$(2 \\le n \\times m \\le 10^5)$ 。\n\n第$4$~$3+n$行，每行一个长度为$m$的字符串。画过的格子用`x`表示，没画过的用`.`表示。保证一幅图中至少有两个格子已被涂色。\n\n这 $n$ 行字符串中的第一行对应于图片的顶部，最后一行对应于图片的底部。", "outputFormat": "如果可能被绘制，第一行输出`YES`，第二行输出用空格隔开的两个整数$b$和$e$,表示Eugene从第$b$个字母开始读，到第$e$个字母结束(包含$b$和$e$)。\n\n如果不能，输出`NO`。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n43\nyou should read statement really carefully.\n3 6\n...XX.\n..XXX.\n...XXX\n```\n\n### 样例输出 #1\n\n```\nYES\n3 42\n```\n\n## 样例 #2\n\n### 样例输入 #2\n\n```\n43\nyou should read statement really carefully.\n3 2\nXX\nXX\nXX\n```\n\n### 样例输出 #2\n\n```\nNO\n```", "hint": "时限: 2 s, 内存限制: 256 MB.", "locale": "zh-CN"}}}
{"pid": "P7036", "type": "P", "difficulty": 2, "samples": [["2 7\n2 2\n", "2\n"], ["10 6\n4 8\n", "2\n"], ["5 5\n1 6\n", "-1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "ICPC", "NWRRC"], "title": "[NWRRC 2016] Folding", "background": "", "description": "\n\nAs you can remember, Alex is fond of origami. She switched from squares to rectangles, and rectangles are much more difficult to master. Her main interest is to determine what is the minimum possible number of folds required to transform $W \\times H$ rectangle to $w \\times h$ one. The result of each fold should also be rectangular, so it is only allowed to make folds that are parallel to the sides of the rectangle.\n\nHelp Alex and write a program that determines the minimum required number of folds.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $W$ and $H$ -- the initial rectangle dimensions. The second line contains two more integers $w$ and $h$ -- the target rectangle dimensions $(1 \\le W , H , w , h \\le 10^{9}).$\n\n", "outputFormat": "\n\nOutput a single integer -- the minimum required number of folds to transform the initial rectangle to the target one.\n\nIf the required transformation is not possible, output $−1$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Folding", "background": "", "description": "\n\nAs you can remember, Alex is fond of origami. She switched from squares to rectangles, and rectangles are much more difficult to master. Her main interest is to determine what is the minimum possible number of folds required to transform $W \\times H$ rectangle to $w \\times h$ one. The result of each fold should also be rectangular, so it is only allowed to make folds that are parallel to the sides of the rectangle.\n\nHelp Alex and write a program that determines the minimum required number of folds.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $W$ and $H$ -- the initial rectangle dimensions. The second line contains two more integers $w$ and $h$ -- the target rectangle dimensions $(1 \\le W , H , w , h \\le 10^{9}).$\n\n", "outputFormat": "\n\nOutput a single integer -- the minimum required number of folds to transform the initial rectangle to the target one.\n\nIf the required transformation is not possible, output $−1$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Folding", "background": "", "description": "### 题目大意：\n\n求一个 $W\\times H $ 的矩形通过折叠变为一个 $w\\times h$ 的矩形的最少折叠次数，其中每次折叠的折痕必须平行于矩形的一边。\n\n------------", "inputFormat": "第一行两个正整数 $W,H$，第二行两个正整数 $w,h$。\n\n$1\\le W,H,w,h\\le10^9$\n\n------------", "outputFormat": "输出最少折叠次数。若无法通过折叠变为目标矩形，输出 `-1`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7037", "type": "P", "difficulty": 6, "samples": [["7 6\n1 2 1 3 3 3\n+ 4\n+ 5\n+ 6\n+ 7\n- 6\n- 5\n", "1 0\n2 0\n2 1\n2 0\n2 1\n2 0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "ICPC", "NWRRC"], "title": "[NWRRC 2016] Gangsters in Central City", "background": "", "description": "\n\nFor a long time, there were no problems with water in Central City. The sewage of the city has a form of a rooted tree: the central reservoir is situated at the root and the houses are at the leaves. The water flows from the central reservoir to the houses by the pipes that runs along the edges of the tree. Each house has an access to water.\n\nSuddenly, gangsters captured some of the houses. As a mayor of the city you are very concerned, and you want to kick out the gangsters. So you want to stop the water flow to houses captured by the gangsters.  To do that you could clog some pipes of the sewage system. If the path from the reservoir to a house contains at least one clogged pipe, the house does not have an access to water.\n\nYou are very afraid of the gangsters, so you decided to clog up the minimal number of pipes, that it could look like an accident. At the same time, you care about the citizens, so for the chosen number of clogged pipes, you want to minimize the number of houses without gangsters and access to water.\n\nUnfortunately, the gangsters could appear and disappear from some houses. So, you are asking the scientists about the minimum required number of clogged pipes and the minimum required number of houses without gangsters and access to water after each change in the gangsters' location.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $n$ and $q$ -- the number of vertices in the tree which represents the sewage and the number of changes in the location of the gangsters $(2 \\le n \\le 100 000$ ; $1 \\le q \\le 100 000)$ .\n\nThe second line contains the description of the sewage: a sequence of $n − 1$ integers $p_{2}, p_{3},$ . . . , $p_{n}$, where $p_{i} is$ the parent of the vertex $i (1 \\le p_{i} < i)$ . The central reservoir is located at the vertex $1$ .\n\nThe next $q$ lines represent the changes in the location of the gangsters. Each change could be one of two different types: \n\n- `+ v` -- the gangsters capture the house at vertex $v$ ; \n- `- v` -- the gangsters leave the house at vertex $v$ .\n\nAt the beginning all the houses are free of gangsters. All the changes form the correct sequence: the gangsters cannot capture the house if it is already captured and the gangsters could not leave the house if it is not captured.\n\n", "outputFormat": "\n\nThe output should contain 2q integers, two in each line: $c_{i}$ -- the minimum number of clogged pipes and $h_{i}$ -- the minimum number of houses without gangsters and have no access to water for the chosen $c_{i}$\n\n.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Gangsters in Central City", "background": "", "description": "\n\nFor a long time, there were no problems with water in Central City. The sewage of the city has a form of a rooted tree: the central reservoir is situated at the root and the houses are at the leaves. The water flows from the central reservoir to the houses by the pipes that runs along the edges of the tree. Each house has an access to water.\n\nSuddenly, gangsters captured some of the houses. As a mayor of the city you are very concerned, and you want to kick out the gangsters. So you want to stop the water flow to houses captured by the gangsters.  To do that you could clog some pipes of the sewage system. If the path from the reservoir to a house contains at least one clogged pipe, the house does not have an access to water.\n\nYou are very afraid of the gangsters, so you decided to clog up the minimal number of pipes, that it could look like an accident. At the same time, you care about the citizens, so for the chosen number of clogged pipes, you want to minimize the number of houses without gangsters and access to water.\n\nUnfortunately, the gangsters could appear and disappear from some houses. So, you are asking the scientists about the minimum required number of clogged pipes and the minimum required number of houses without gangsters and access to water after each change in the gangsters' location.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $n$ and $q$ -- the number of vertices in the tree which represents the sewage and the number of changes in the location of the gangsters $(2 \\le n \\le 100 000$ ; $1 \\le q \\le 100 000)$ .\n\nThe second line contains the description of the sewage: a sequence of $n − 1$ integers $p_{2}, p_{3},$ . . . , $p_{n}$, where $p_{i} is$ the parent of the vertex $i (1 \\le p_{i} < i)$ . The central reservoir is located at the vertex $1$ .\n\nThe next $q$ lines represent the changes in the location of the gangsters. Each change could be one of two different types: \n\n- `+ v` -- the gangsters capture the house at vertex $v$ ; \n- `- v` -- the gangsters leave the house at vertex $v$ .\n\nAt the beginning all the houses are free of gangsters. All the changes form the correct sequence: the gangsters cannot capture the house if it is already captured and the gangsters could not leave the house if it is not captured.\n\n", "outputFormat": "\n\nThe output should contain 2q integers, two in each line: $c_{i}$ -- the minimum number of clogged pipes and $h_{i}$ -- the minimum number of houses without gangsters and have no access to water for the chosen $c_{i}$\n\n.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Gangsters in Central City", "background": "", "description": "长期以来，中央城的水供应一直没有问题。城市的排水系统呈现出一棵根树的形式：中央水库位于树根，房屋位于树叶。水通过沿着树的边缘运行的管道从中央水库流向房屋。每个房屋都能获得水。\n\n突然，黑帮占领了一些房屋。作为市长，你非常担心，并想要赶走这些黑帮。因此，你希望停止向被黑帮占领的房屋供水。为此，你可以堵塞排水系统中的一些管道。如果从水库到某个房屋的路径上至少有一根管道被堵塞，那么该房屋将无法获得水。\n\n你非常害怕这些黑帮，所以你决定堵塞最少数量的管道，以使其看起来像是意外。同时，你关心市民，因此对于选择的堵塞管道数量，你希望最小化没有黑帮且无法获得水的房屋数量。\n\n不幸的是，黑帮可能会在一些房屋中出现和消失。因此，你询问科学家在每次黑帮位置变化后所需的最小堵塞管道数量以及没有黑帮且无法获得水的房屋的最小数量。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $q$ —— 表示树中顶点的数量（代表排水系统）和黑帮位置变化的次数（$2 \\le n \\le 100 000$；$1 \\le q \\le 100 000$）。\n\n第二行包含排水系统的描述：一个由 $n - 1$ 个整数 $p_{2}, p_{3}, \\ldots, p_{n}$ 组成的序列，其中 $p_{i}$ 是顶点 $i$ 的父节点 $(1 \\le p_{i} < i)$。中央水库位于顶点 $1$。\n\n接下来的 $q$ 行表示黑帮位置的变化。每个变化可以是两种不同类型之一：\n\n- `+ v` —— 黑帮占领顶点 $v$ 处的房屋；\n- `- v` —— 黑帮离开顶点 $v$ 处的房屋。\n\n一开始所有房屋都没有被黑帮占领。所有变化形成了正确的序列：黑帮不能占领已经被占领的房屋，黑帮也不能离开未被占领的房屋。", "outputFormat": "输出应包含 2q 个整数，每行两个：$c_{i}$ —— 最小堵塞管道数量，以及 $h_{i}$ —— 在选择的 $c_{i}$ 下没有黑帮且无法获得水的房屋的最小数量。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7038", "type": "P", "difficulty": 7, "samples": [["3\n5 3\n5 6\n4 4\n", "4\n0 0 3\n3 0 2\n3 2 1\n4 2 1\n5\n0 0 2\n0 2 2\n0 4 2\n2 0 3\n2 3 3\n1\n0 0 4\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2016] Hard Cuts", "background": "", "description": "\n\nGiven a rectangle with integer side lengths, your task is to cut it into the smallest possible number $of squares$ with integer side lengths.\n\n", "inputFormat": "\n\nThe first line contains a single integer $T$ -- the number of test cases $(1 \\le T \\le 3600)$ . Each of the $next T$ lines contains two integers $w_{i}, h_{i}$ -- the dimensions of the rectangle $(1 \\le w_{i}, h_{i} \\le 60$ ; for any $i ≠ j, either w_{i }≠ w_{j}$ or $h_{i} ≠ h_{j} ).$\n\n", "outputFormat": "\n\nFor the i-th test case, output $k_{i}$ -- the minimal number of squares, such that it is possible to cut $the w_{i}$ by $h_{i}$ rectangle into $k_{i}$ squares. The following $k_{i} lines$ should contain three integers each: $x_{ij} , y_{ij} -- the$ coordinates of the bottom-left corner of the j-th square and $l_{ij }--$ its side length $(0 \\le x_{ij} \\le w_{i} − l_{ij} ; 0 \\le y_{ij} \\le h_{i} −l_{ij} ).$ The bottom-left corner of the rectangle has coordinates $(0 , 0)$ and the top-right $corner has$ coordinates $(w_{i}, h_{i}).$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Hard Cuts", "background": "", "description": "\n\nGiven a rectangle with integer side lengths, your task is to cut it into the smallest possible number $of squares$ with integer side lengths.\n\n", "inputFormat": "\n\nThe first line contains a single integer $T$ -- the number of test cases $(1 \\le T \\le 3600)$ . Each of the $next T$ lines contains two integers $w_{i}, h_{i}$ -- the dimensions of the rectangle $(1 \\le w_{i}, h_{i} \\le 60$ ; for any $i ≠ j, either w_{i }≠ w_{j}$ or $h_{i} ≠ h_{j} ).$\n\n", "outputFormat": "\n\nFor the i-th test case, output $k_{i}$ -- the minimal number of squares, such that it is possible to cut $the w_{i}$ by $h_{i}$ rectangle into $k_{i}$ squares. The following $k_{i} lines$ should contain three integers each: $x_{ij} , y_{ij} -- the$ coordinates of the bottom-left corner of the j-th square and $l_{ij }--$ its side length $(0 \\le x_{ij} \\le w_{i} − l_{ij} ; 0 \\le y_{ij} \\le h_{i} −l_{ij} ).$ The bottom-left corner of the rectangle has coordinates $(0 , 0)$ and the top-right $corner has$ coordinates $(w_{i}, h_{i}).$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Hard Cuts", "background": null, "description": "给定一个具有整数边长的矩形，你的任务是将其切割成尽可能少的整数边长的正方形。", "inputFormat": "第一行包含一个整数 $T$ —— 测试用例的数量 $(1 \\le T \\le 3600)$。接下来的 $T$ 行中的每一行包含两个整数 $w_{i}, h_{i}$ —— 矩形的尺寸 $(1 \\le w_{i}, h_{i} \\le 60$；对于任何 $i \\neq j$，要么 $w_{i} \\neq w_{j}$，要么 $h_{i} \\neq h_{j})$。", "outputFormat": "对于第 $i$ 个测试用例，输出 $k_{i}$ —— 最小的正方形数量，使得可以将 $w_{i}$ 乘以 $h_{i}$ 的矩形切割成 $k_{i}$ 个正方形。接下来的 $k_{i}$ 行应包含三个整数：$x_{ij}, y_{ij}$ —— 第 $j$ 个正方形左下角的坐标，以及 $l_{ij}$ —— 其边长 $(0 \\le x_{ij} \\le w_{i} - l_{ij}; 0 \\le y_{ij} \\le h_{i} - l_{ij})$。矩形的左下角坐标为 $(0, 0)$，右上角坐标为 $(w_{i}, h_{i})$。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7039", "type": "P", "difficulty": 6, "samples": [["5\n7 3\n3 5\n1 4\n2 1\n5 0\n", "3\n"], ["4\n1 1\n3 1\n5 5\n1 3\n", "2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["计算几何", "2016", "叉积", "ICPC", "状压 DP", "NWRRC"], "title": "[NWRRC 2016] Integral Polygons", "background": "", "description": "\n\nIngrid holds a polygon shop in a far away country. She sells only convex polygons with integer coordinates. Her customers prefer polygons that can be cut into two halves in a proper way, that is the cut should be straight  with starting and ending points in the polygon vertices and both halves should be non-empty and have integer areas. The more ways to cut the polygon in the proper way are -- the more expensive the polygon is.\n\nFor example, there are three ways to cut the left polygon in the proper way, and two ways for the right polygon.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fei0xc33.png)\n\nThe polygons in the shop are always of excellent quality, so the business is expanding. Now Ingrid needs some automatic tool to determine the number of ways to cut the polygon in the proper way. This is very important for her shop, since otherwise you will spend a lot of time on setting prices -- just imagine how much time would it take to set prices for a medium-sized van with polygons. Could you help Ingrid and write the tool for her?\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $n$ -- the number of polygon vertices $(4 \\le n \\le 200 000)$ . $ Each$ of the following $n$ lines contains vertex coordinates: a pair of integers $x_{i}$ and $y_{i}$ per line $(-10^{9} \\le x_{i}, y_{i} \\le 10^{9}).  The$ specified polygon is convex and its vertices are specified in the order of traversal.\n\n", "outputFormat": "\n\nOutput a single integer $w$ -- the number of ways to cut the polygon in the proper way.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Integral Polygons", "background": "", "description": "\n\nIngrid holds a polygon shop in a far away country. She sells only convex polygons with integer coordinates. Her customers prefer polygons that can be cut into two halves in a proper way, that is the cut should be straight  with starting and ending points in the polygon vertices and both halves should be non-empty and have integer areas. The more ways to cut the polygon in the proper way are -- the more expensive the polygon is.\n\nFor example, there are three ways to cut the left polygon in the proper way, and two ways for the right polygon.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fei0xc33.png)\n\nThe polygons in the shop are always of excellent quality, so the business is expanding. Now Ingrid needs some automatic tool to determine the number of ways to cut the polygon in the proper way. This is very important for her shop, since otherwise you will spend a lot of time on setting prices -- just imagine how much time would it take to set prices for a medium-sized van with polygons. Could you help Ingrid and write the tool for her?\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $n$ -- the number of polygon vertices $(4 \\le n \\le 200 000)$ . $ Each$ of the following $n$ lines contains vertex coordinates: a pair of integers $x_{i}$ and $y_{i}$ per line $(-10^{9} \\le x_{i}, y_{i} \\le 10^{9}).  The$ specified polygon is convex and its vertices are specified in the order of traversal.\n\n", "outputFormat": "\n\nOutput a single integer $w$ -- the number of ways to cut the polygon in the proper way.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Integral Polygons", "background": "", "description": "Ingrid 在一个遥远的国家经营着一家多边形商店。她只出售具有整数坐标的凸多边形。她的顾客更喜欢可以以适当方式切割成两半的多边形，即切割应是直线，起点和终点在多边形的顶点上，并且两半都不为空且面积为整数。切割多边形的适当方式越多，多边形就越昂贵。\n\n例如，左边的多边形有三种适当的切割方式，而右边的多边形有两种。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fei0xc33.png)\n\n商店里的多边形质量总是很优秀，所以业务正在扩展。现在 Ingrid 需要一些自动化工具来确定适当切割多边形的方式数量。这对她的商店非常重要，否则你将花费大量时间来设定价格——想象一下为一辆中型货车的多边形设定价格需要多少时间。你能帮助 Ingrid 编写这个工具吗？", "inputFormat": "输入的第一行包含一个整数 $n$ —— 多边形顶点的数量 $(4 \\le n \\le 200 000)$。接下来的 $n$ 行中的每一行包含顶点坐标：每行一对整数 $x_{i}$ 和 $y_{i}$ $(-10^{9} \\le x_{i}, y_{i} \\le 10^{9})$。指定的多边形是凸的，其顶点按遍历顺序指定。", "outputFormat": "输出一个整数 $w$ —— 以适当方式切割多边形的方式数量。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7040", "type": "P", "difficulty": 4, "samples": [["0\n", "? /?/ ?\n"], ["1\n", "a = ? max ?\n(a max a) / a\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2016] Java2016", "background": "", "description": "\n\nJohn likes to learn esoteric programming languages. Recently he discovered the probabilistic $\\textit{programming language}$ Java2K. Built-in functions of Java2K have only a certain probability to do whatever you $\\textit{intend them}$ to do.\n\nThe Java2K programming is very hard, so John designed a much simpler language for training: Java2016. $\\textit{Built-in}$ operators of Java2016 are deterministic, while their operands are random. Each value in $\\textit{Java2016 is}$ a positive integer in the range $0 \\cdots 255$ , inclusive.\n\nJava2016 supports six operators of three precedencies:\n\n$$\\begin{aligned}{\\langle \\mathrm{expression}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{min}\\text'}{\\langle \\mathrm{sum}\\rangle}\\mid{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{max}\\text'}{\\langle \\mathrm{sum}\\rangle}\\mid {\\langle \\mathrm{sum}\\rangle}\\\\{\\langle \\mathrm{sum}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{sum}\\rangle}\\operatorname{`\\texttt{+}\\text'}{\\langle \\mathrm{term}\\rangle}\\mid{\\langle \\mathrm{sum}\\rangle}\\operatorname{`\\texttt{-}\\text'}{\\langle \\mathrm{term}\\rangle}\\mid{\\langle \\mathrm{term}\\rangle}\\\\{\\langle \\mathrm{term}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{term}\\rangle}\\operatorname{`\\texttt{*}\\text'}{\\langle \\mathrm{factor}\\rangle}\\mid {\\langle \\mathrm{term}\\rangle}\\operatorname{`\\texttt{/}\\text'}{\\langle \\mathrm{factor}\\rangle}\\mid {\\langle \\mathrm{factor}\\rangle}\\\\{\\langle \\mathrm{factor}\\rangle}&\\quad::=\\quad\\operatorname{`\\texttt{(}\\text'}{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{)}\\text'}\\mid `\\texttt{?}\\text'\\mid {\\langle \\mathrm{macro}\\rangle}\\end{aligned}$$\n\nMinimum $(\\textit{`min'})$ and maximum $((\\textit{`max'}))$ operators are defined as usual. Addition $(\\text{`+'}),$ subtraction $(\\text{`--'}) and$ multiplication $(\\text{`}\\times\\text{'})$ are defined modulo $256$ . The result of the division $(\\text{`}/\\text{'})$ is rounded towards zero. $\\textit{If}$ the divider is zero, the program crashes. The argument of the operator is a result of another $\\textit{operator, evenly}$ distributed random value $(\\text{`}?\\text{'})$, or macro substitution.\n\nFor instance, the probability that $\\text{`?/?/?'}$ is evaluated to zero is $98.2\\%$, while the probability of $the crash$ is $0.8\\%$.\n\nThe Java2016 program consists of zero or more macro definitions, followed by the resulting expression. $ Each$ macro definition has a form of\n\n$$\\begin{aligned}{\\langle \\mathrm{macrodef}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{macro}\\rangle}\\operatorname{`\\texttt{=}\\text'}{\\langle \\mathrm{expression}\\rangle}\\\\{\\langle \\mathrm{macro}\\rangle}&\\quad::=\\quad\\operatorname{`\\texttt{a}\\text'}\\ldots\\operatorname{`\\texttt{z}\\text'}\\end{aligned}$$\n\n\nThe macro should be defined before the first use. It may not be redefined. The macro is expanded to $its definitio_n$ on each use. For instance,\n\n```plain\na = ? max ?\n(a max $a) / a\n```\n\nis expanded to `((? max ?) max (? max ?)) / (? max ?)`.\n\nJohn is going to add probabilistic constants to Java2016, so for each possible constant value he needs $a progra_m$ that successfully evaluates to this value with at least one-half probability. Crashes are $\\textit{counted toward}$ failures.\n\n", "inputFormat": "\n\nThe input contains a single integer $c$ -- the target constant $(0 \\le c \\le 255)$ .\n\n", "outputFormat": "\n\nOutput a Java2016 program that successfully evaluates to constant $c$ with probability no less than $1/2$ . $ The$ total length of the program should not exceed $256$ characters (excluding spaces).\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Java2016", "background": "", "description": "\n\nJohn likes to learn esoteric programming languages. Recently he discovered the probabilistic $\\textit{programming language}$ Java2K. Built-in functions of Java2K have only a certain probability to do whatever you $\\textit{intend them}$ to do.\n\nThe Java2K programming is very hard, so John designed a much simpler language for training: Java2016. $\\textit{Built-in}$ operators of Java2016 are deterministic, while their operands are random. Each value in $\\textit{Java2016 is}$ a positive integer in the range $0 \\cdots 255$ , inclusive.\n\nJava2016 supports six operators of three precedencies:\n\n$$\\begin{aligned}{\\langle \\mathrm{expression}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{min}\\text'}{\\langle \\mathrm{sum}\\rangle}\\mid{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{max}\\text'}{\\langle \\mathrm{sum}\\rangle}\\mid {\\langle \\mathrm{sum}\\rangle}\\\\{\\langle \\mathrm{sum}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{sum}\\rangle}\\operatorname{`\\texttt{+}\\text'}{\\langle \\mathrm{term}\\rangle}\\mid{\\langle \\mathrm{sum}\\rangle}\\operatorname{`\\texttt{-}\\text'}{\\langle \\mathrm{term}\\rangle}\\mid{\\langle \\mathrm{term}\\rangle}\\\\{\\langle \\mathrm{term}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{term}\\rangle}\\operatorname{`\\texttt{*}\\text'}{\\langle \\mathrm{factor}\\rangle}\\mid {\\langle \\mathrm{term}\\rangle}\\operatorname{`\\texttt{/}\\text'}{\\langle \\mathrm{factor}\\rangle}\\mid {\\langle \\mathrm{factor}\\rangle}\\\\{\\langle \\mathrm{factor}\\rangle}&\\quad::=\\quad\\operatorname{`\\texttt{(}\\text'}{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{)}\\text'}\\mid `\\texttt{?}\\text'\\mid {\\langle \\mathrm{macro}\\rangle}\\end{aligned}$$\n\nMinimum $(\\textit{`min'})$ and maximum $((\\textit{`max'}))$ operators are defined as usual. Addition $(\\text{`+'}),$ subtraction $(\\text{`--'}) and$ multiplication $(\\text{`}\\times\\text{'})$ are defined modulo $256$ . The result of the division $(\\text{`}/\\text{'})$ is rounded towards zero. $\\textit{If}$ the divider is zero, the program crashes. The argument of the operator is a result of another $\\textit{operator, evenly}$ distributed random value $(\\text{`}?\\text{'})$, or macro substitution.\n\nFor instance, the probability that $\\text{`?/?/?'}$ is evaluated to zero is $98.2\\%$, while the probability of $the crash$ is $0.8\\%$.\n\nThe Java2016 program consists of zero or more macro definitions, followed by the resulting expression. $ Each$ macro definition has a form of\n\n$$\\begin{aligned}{\\langle \\mathrm{macrodef}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{macro}\\rangle}\\operatorname{`\\texttt{=}\\text'}{\\langle \\mathrm{expression}\\rangle}\\\\{\\langle \\mathrm{macro}\\rangle}&\\quad::=\\quad\\operatorname{`\\texttt{a}\\text'}\\ldots\\operatorname{`\\texttt{z}\\text'}\\end{aligned}$$\n\n\nThe macro should be defined before the first use. It may not be redefined. The macro is expanded to $its definitio_n$ on each use. For instance,\n\n```plain\na = ? max ?\n(a max $a) / a\n```\n\nis expanded to `((? max ?) max (? max ?)) / (? max ?)`.\n\nJohn is going to add probabilistic constants to Java2016, so for each possible constant value he needs $a progra_m$ that successfully evaluates to this value with at least one-half probability. Crashes are $\\textit{counted toward}$ failures.\n\n", "inputFormat": "\n\nThe input contains a single integer $c$ -- the target constant $(0 \\le c \\le 255)$ .\n\n", "outputFormat": "\n\nOutput a Java2016 program that successfully evaluates to constant $c$ with probability no less than $1/2$ . $ The$ total length of the program should not exceed $256$ characters (excluding spaces).\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Java2016", "background": "", "description": "John 喜欢学习晦涩的编程语言。最近他发现了概率编程语言 Java2K。Java2K 的内置函数只有一定的概率能够执行你想让它们做的事情。\n\nJava2K 编程非常困难，所以 John 设计了一种更简单的语言用于训练：Java2016。Java2016 的内置运算符是确定性的，而它们的操作数是随机的。在 Java2016 中，每个值都是范围在 $0 \\cdots 255$ 之间的正整数。\n\nJava2016 支持三种优先级的六个运算符：\n\n$$\n\\begin{aligned}\n{\\langle \\mathrm{expression}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{min}\\text'}{\\langle \\mathrm{sum}\\rangle}\\mid{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{max}\\text'}{\\langle \\mathrm{sum}\\rangle}\\mid {\\langle \\mathrm{sum}\\rangle}\\\\\n{\\langle \\mathrm{sum}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{sum}\\rangle}\\operatorname{`\\texttt{+}\\text'}{\\langle \\mathrm{term}\\rangle}\\mid{\\langle \\mathrm{sum}\\rangle}\\operatorname{`\\texttt{-}\\text'}{\\langle \\mathrm{term}\\rangle}\\mid{\\langle \\mathrm{term}\\rangle}\\\\\n{\\langle \\mathrm{term}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{term}\\rangle}\\operatorname{`\\texttt{*}\\text'}{\\langle \\mathrm{factor}\\rangle}\\mid {\\langle \\mathrm{term}\\rangle}\\operatorname{`\\texttt{\\/}\\text'}{\\langle \\mathrm{factor}\\rangle}\\mid {\\langle \\mathrm{factor}\\rangle}\\\\\n{\\langle \\mathrm{factor}\\rangle}&\\quad::=\\quad\\operatorname{`\\texttt{(}\\text'}{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{)}\\text'}\\mid `\\texttt{?}\\text'\\mid {\\langle \\mathrm{macro}\\rangle}\n\\end{aligned}\n$$\n\n最小值（`min`）和最大值（`max`）运算符的定义与通常相同。加法（`+`）、减法（`-`）和乘法（`*`）的定义是模 $256$。除法（`/`）的结果向零取整。如果除数为零，程序崩溃。运算符的参数是另一个运算符的结果、均匀分布的随机值（`?`）或宏替换。\n\n例如，`?/?/?` 被评估为零的概率是 $98.2\\%$，而崩溃的概率是 $0.8\\%$。\n\nJava2016 程序由零个或多个宏定义组成，后跟结果表达式。每个宏定义的形式为：\n\n$$\n\\begin{aligned}\n{\\langle \\mathrm{macrodef}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{macro}\\rangle}\\operatorname{`\\texttt{=}\\text'}{\\langle \\mathrm{expression}\\rangle}\\\\\n{\\langle \\mathrm{macro}\\rangle}&\\quad::=\\quad\\operatorname{`\\texttt{a}\\text'}\\ldots\\operatorname{`\\texttt{z}\\text'}\n\\end{aligned}\n$$\n\n宏应该在第一次使用之前定义。它不能被重新定义。宏在每次使用时扩展为其定义。例如，\n\n```plain\na = ? max ?\n(a max $a) / a\n```\n\n被扩展为 `((? max ?) max (? max ?)) / (? max ?)`。\n\nJohn 打算向 Java2016 添加概率常量，因此对于每个可能的常量值，他需要一个程序，该程序能够以至少一半的概率成功评估为该值。崩溃被计入失败。", "inputFormat": "输入包含一个整数 $c$ —— 目标常量 $(0 \\le c \\le 255)$。", "outputFormat": "输出一个 Java2016 程序，该程序成功评估为常量 $c$ 的概率不小于 $1/2$。程序的总长度不应超过 $256$ 个字符（不包括空格）。", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7041", "type": "P", "difficulty": 2, "samples": [["22 10 2016\n7\n28 2 1999\n22 7 1995\n21 10 1998\n23 10 1998\n3 9 2000\n1 4 2013\n17 12 2004\n", "3\n"], ["22 10 2016\n1\n28 2 1999\n", "-1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "ICPC", "NWRRC"], "title": "[NWRRC 2016] King’s Heir", "background": "", "description": "\n\nThe king is dead, long live the king! After the sudden death of the king Fert XIII the people of the Flatland Kingdom are going to welcome the new king. Unfortunately, there is a problem, Fert has too many sons.\n\nActually, he has $n$ sons and he loved each new son more than all of his previous sons. Well, probably he just stopped loving his sons because of their bad behavior. Anyway, after the new son was born Fert made the new testament that declared that the newly born son would be the heir.\n\nHowever, there is a problem. Only the king's son who is at least $18$ years old at the moment of the $king's death$ can become a new king. Now the ministers of the government are trying to find the correct $new king,$ but they seem to fail. Help them!\n\n", "inputFormat": "\n\nThe first line of the input contains three integers: $d , m$ and $y$ -- the day, the month and the year of the king's death, $d$ is from $1$ to $31$ , $m$ is from $1$ to $12 , y$ is from $1$ to $9999$ . It is guaranteed that there exists day $d$ in month $m$ , all months have the same number of days in Flatland as in our country, except that Flatland calendar doesn't have leap years, so February (month $2$) always has $28$ days.\n\nThe second line contains $n (1 \\le n \\le 100)$ -- the number of king's sons. The following $n$ lines contain three integers each $d_{i}, m_{i}$ and $ y_{i}$ and specify the birth dates of king's sons. All dates are correct and no son is born after or on the day of king's death. The king had no twins, so no two sons were born on the same date.\n\n", "outputFormat": "\n\nOutput one integer -- the number of the son that would become the king, or $−1$ if none of them is $at least 18$ years old. The sons are numbered from $1$ to $n$ in order they are described in the input. The youngest son who is at least $18$ years old at the moment of the king's death would become the king. $If the$ son has his 18th birthday exactly on the day of the king's death, he can become a king.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] King’s Heir", "background": "", "description": "\n\nThe king is dead, long live the king! After the sudden death of the king Fert XIII the people of the Flatland Kingdom are going to welcome the new king. Unfortunately, there is a problem, Fert has too many sons.\n\nActually, he has $n$ sons and he loved each new son more than all of his previous sons. Well, probably he just stopped loving his sons because of their bad behavior. Anyway, after the new son was born Fert made the new testament that declared that the newly born son would be the heir.\n\nHowever, there is a problem. Only the king's son who is at least $18$ years old at the moment of the $king's death$ can become a new king. Now the ministers of the government are trying to find the correct $new king,$ but they seem to fail. Help them!\n\n", "inputFormat": "\n\nThe first line of the input contains three integers: $d , m$ and $y$ -- the day, the month and the year of the king's death, $d$ is from $1$ to $31$ , $m$ is from $1$ to $12 , y$ is from $1$ to $9999$ . It is guaranteed that there exists day $d$ in month $m$ , all months have the same number of days in Flatland as in our country, except that Flatland calendar doesn't have leap years, so February (month $2$) always has $28$ days.\n\nThe second line contains $n (1 \\le n \\le 100)$ -- the number of king's sons. The following $n$ lines contain three integers each $d_{i}, m_{i}$ and $ y_{i}$ and specify the birth dates of king's sons. All dates are correct and no son is born after or on the day of king's death. The king had no twins, so no two sons were born on the same date.\n\n", "outputFormat": "\n\nOutput one integer -- the number of the son that would become the king, or $−1$ if none of them is $at least 18$ years old. The sons are numbered from $1$ to $n$ in order they are described in the input. The youngest son who is at least $18$ years old at the moment of the king's death would become the king. $If the$ son has his 18th birthday exactly on the day of the king's death, he can become a king.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] King’s Heir", "background": "", "description": "国王去世了，国王万岁！在国王 Fert XIII 突然去世后，平面王国的人民将迎接新国王。不幸的是，出现了一个问题，Fert 有太多的儿子。\n\n实际上，他有 $n$ 个儿子，并且他对每个新儿子的爱都超过了他之前所有的儿子。可能是因为他们的坏行为，他不再爱他的儿子们。无论如何，在新儿子出生后，Fert 制定了新的遗嘱，宣布新出生的儿子将成为继承人。\n\n然而，问题在于，只有在国王去世时年满 $18$ 岁的国王儿子才能成为新国王。现在，政府的部长们正在努力寻找正确的新国王，但他们似乎失败了。请帮助他们！", "inputFormat": "输入的第一行包含三个整数：$d, m$ 和 $y$ —— 国王去世的日期、月份和年份，$d$ 从 $1$ 到 $31$，$m$ 从 $1$ 到 $12$，$y$ 从 $1$ 到 $9999$。可以保证在月份 $m$ 中存在日期 $d$，平面王国的所有月份的天数与我们国家相同，只是平面王国的日历没有闰年，因此二月（第 $2$ 个月）总是有 $28$ 天。\n\n第二行包含 $n (1 \\le n \\le 100)$ —— 国王的儿子数量。接下来的 $n$ 行每行包含三个整数 $d_{i}, m_{i}$ 和 $y_{i}$，指定国王儿子的出生日期。所有日期都是正确的，并且没有儿子在国王去世当天或之后出生。国王没有双胞胎，因此没有两个儿子在同一天出生。", "outputFormat": "输出一个整数 —— 成为国王的儿子的编号，如果没有一个儿子在国王去世时至少 $18$ 岁，则输出 $-1$。儿子按输入中描述的顺序从 $1$ 到 $n$ 编号。最年轻的在国王去世时至少 $18$ 岁的儿子将成为国王。如果儿子在国王去世当天正好满 $18$ 岁，他可以成为国王。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7042", "type": "P", "difficulty": 2, "samples": [["3\n1 3 3 1\n2 4 7 8\n2 3 1 4", "4\n0\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "计算几何", "O2优化", "洛谷月赛"], "title": "「MCOI-03」正方", "background": "MC 中没有圆。\n\n所以小 S 和小 Q 和小 U 和小 A 和小 R 和小 E 喜欢 Square。", "description": "给定一个正方形，求有多少个正方形内的点满足与正方形四个顶点划分出来的四块面积的比为 $a:b:c:d$。四个数不分顺序。\n\n比如如下图所示假设一个点 E 使得分成的四个三角形的面积之比为 $a:b:c:d$，那么这个点 E 就符合要求。因为不分顺序，所以分出来的比是 $d:b:a:c$ 也可以。但是点 E 不是唯一解，你要输出的是解的个数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/95llbbcx.png)\n\n因为小 S 和小 Q 和小 U 和小 A 和小 R 和小 E 很喜欢询问，所以本题给定了 $q$ 组询问。", "inputFormat": "第一行一个整数 $q$ 代表询问个数。     \n接下来 $q$ 行每行四个整数 $a,b,c,d$。", "outputFormat": "$q$ 行每行一个整数代表答案。", "hint": "#### 数据规模与约定\n\n对于 $20\\%$ 的数据，$a=b=c=d$。    \n对于 $100\\%$ 的数据，$1 \\le a,b,c,d \\le 9 \\times 10^{18}$，$1 \\le q \\le 100$，不保证 $a:b:c:d$ 为最简比，不保证 $a,b,c,d$ 为升序。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MCOI-03」正方", "background": "MC 中没有圆。\n\n所以小 S 和小 Q 和小 U 和小 A 和小 R 和小 E 喜欢 Square。", "description": "给定一个正方形，求有多少个正方形内的点满足与正方形四个顶点划分出来的四块面积的比为 $a:b:c:d$。四个数不分顺序。\n\n比如如下图所示假设一个点 E 使得分成的四个三角形的面积之比为 $a:b:c:d$，那么这个点 E 就符合要求。因为不分顺序，所以分出来的比是 $d:b:a:c$ 也可以。但是点 E 不是唯一解，你要输出的是解的个数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/95llbbcx.png)\n\n因为小 S 和小 Q 和小 U 和小 A 和小 R 和小 E 很喜欢询问，所以本题给定了 $q$ 组询问。", "inputFormat": "第一行一个整数 $q$ 代表询问个数。     \n接下来 $q$ 行每行四个整数 $a,b,c,d$。", "outputFormat": "$q$ 行每行一个整数代表答案。", "hint": "#### 数据规模与约定\n\n对于 $20\\%$ 的数据，$a=b=c=d$。    \n对于 $100\\%$ 的数据，$1 \\le a,b,c,d \\le 9 \\times 10^{18}$，$1 \\le q \\le 100$，不保证 $a:b:c:d$ 为最简比，不保证 $a,b,c,d$ 为升序。", "locale": "zh-CN"}}}
{"pid": "P7043", "type": "P", "difficulty": 3, "samples": [["2\n2 3\n2 6\n1 2\n3 5\n2 6 4\n1 3\n2 3", "2\n3"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144]}, "tags": ["O2优化", "洛谷月赛"], "title": "「MCOI-03」村国", "background": "$\\texttt{What did this player dream?}$\n\n他梦见了什么？\n\n$\\texttt{This player dreamed of sunlight and trees.Of fire and water.}$\n\n他梦见了阳光与树木。梦见了火与水。\n\n$\\texttt{It dreamed it created. And it dreamed it destroyed. It dreamed it hunted,}$ \n$\\texttt{and was hunted. It dreamed of shelter.}$\n\n他梦见他的创造，亦梦见他毁灭。它梦见他在狩猎，亦梦见被猎捕。他梦见温馨的居所。\n\n$\\texttt{Hah, the original interface. A million years old, and it still works.But}$ \n$\\texttt{ what true structure did this player create, in the reality behind the screen?}$\n\n哎，那原始的界面。经历百万年的岁月，它依然在工作。只是他在屏幕后的真实里，到底创造了什么真实的世界呢？", "description": "C 国一共有 $N$ 个村庄，$N-1$ 条道路。这些道路都可以双向通行。保证小 S 可以从一座村庄到其他任何一座村庄。这 $N$ 个村庄编号为 $1$ 到 $N$。\n\n刚开始小 S 对第 $i$ 个村庄的好感值为 $A_i$。小 S 的假期一共有 $M$ 天，他会在 C 国旅行一共 $M$ 天。每一天他会选择来到当前好感值最高的村庄。如果有好感值相同的村庄，他会选择编号最小的村庄。假设这一天他来到村庄 $X$，那么这一天结束后，与村庄 $X$ 直接相邻所有村庄的好感值都会增加 $1$。即能从 $X$ 出发仅经过一条道路到达的村庄好感值会增加 $1$。因为小 S 已经在村庄 $X$ 待过一天了，所以这一天结束后村庄 $X$ 的好感值并不会增加。\n\n现在小 S 想要知道经过 $M$ 天的旅行后好感值最高的村庄。\n\n如果有多个好感值最高的村庄，输出编号最小的。", "inputFormat": "**本题单个测试点包含多组测试数据**。        \n第一行一个正整数 $T$ 表示数据组数。      \n对于每组数据：      \n第一行包括两个正整数 $N,M$，表示村庄个数和旅行天数。     \n接下来一行 $N$ 个整数，第 $i$ 个整数表示第 $i$ 座村庄的好感值 $A_i$。        \n接下来 $N-1$ 行。每行两个整数 $x,y$ 表示村庄 $x$ 和村庄 $y$ 之间有一条双向通行的道路。", "outputFormat": "一个整数表示 $M$ 天结束后好感值最高的村庄的编号。如果有多个好感值最高的村庄，输出编号最小的。", "hint": "#### 样例说明\n\n对于第一组数据，小 S 在 $2$ 号村庄旅行了 $3$ 天，结束时村庄 $1,2$ 的好感值分别为 $5,6$。所以答案输出 $2$。\n\n对于第二组数据，结束时三个村庄的好感值分别为 $3,7,8$，所以答案输出 $3$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le N\\le 2\\times10^6$，$1 \\le M\\le10^{18}$，$1 \\le A_i\\le2^{31}-1$，$1 \\le T\\le10$。\n\n| 测试点编号 | $A_i\\le$ | $\\sum N \\le$ | $M \\le $ | 测试点分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $\\rm 1$ | $10$ | $20$ | $10$ | $5$ |\n| $\\rm 2$ | $10^2$ | $2 \\times 10^2$ | $10^2$ | $10$ |\n| $\\rm 3$ | $10^3$ | $2 \\times 10^3$ | $10^3$ | $15$ |\n| $\\rm 4$ | $10^5$ | $2 \\times 10^5$ | $10^5$ | $25$ |\n| $\\rm 5$ |  | $2 \\times 10^6$ |  | $45$ |\n\n#### 提示\n\n**本题输入量较大，请使用较快的读入方式。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MCOI-03」村国", "background": "$\\texttt{What did this player dream?}$\n\n他梦见了什么？\n\n$\\texttt{This player dreamed of sunlight and trees.Of fire and water.}$\n\n他梦见了阳光与树木。梦见了火与水。\n\n$\\texttt{It dreamed it created. And it dreamed it destroyed. It dreamed it hunted,}$ \n$\\texttt{and was hunted. It dreamed of shelter.}$\n\n他梦见他的创造，亦梦见他毁灭。它梦见他在狩猎，亦梦见被猎捕。他梦见温馨的居所。\n\n$\\texttt{Hah, the original interface. A million years old, and it still works.But}$ \n$\\texttt{ what true structure did this player create, in the reality behind the screen?}$\n\n哎，那原始的界面。经历百万年的岁月，它依然在工作。只是他在屏幕后的真实里，到底创造了什么真实的世界呢？", "description": "C 国一共有 $N$ 个村庄，$N-1$ 条道路。这些道路都可以双向通行。保证小 S 可以从一座村庄到其他任何一座村庄。这 $N$ 个村庄编号为 $1$ 到 $N$。\n\n刚开始小 S 对第 $i$ 个村庄的好感值为 $A_i$。小 S 的假期一共有 $M$ 天，他会在 C 国旅行一共 $M$ 天。每一天他会选择来到当前好感值最高的村庄。如果有好感值相同的村庄，他会选择编号最小的村庄。假设这一天他来到村庄 $X$，那么这一天结束后，与村庄 $X$ 直接相邻所有村庄的好感值都会增加 $1$。即能从 $X$ 出发仅经过一条道路到达的村庄好感值会增加 $1$。因为小 S 已经在村庄 $X$ 待过一天了，所以这一天结束后村庄 $X$ 的好感值并不会增加。\n\n现在小 S 想要知道经过 $M$ 天的旅行后好感值最高的村庄。\n\n如果有多个好感值最高的村庄，输出编号最小的。", "inputFormat": "**本题单个测试点包含多组测试数据**。        \n第一行一个正整数 $T$ 表示数据组数。      \n对于每组数据：      \n第一行包括两个正整数 $N,M$，表示村庄个数和旅行天数。     \n接下来一行 $N$ 个整数，第 $i$ 个整数表示第 $i$ 座村庄的好感值 $A_i$。        \n接下来 $N-1$ 行。每行两个整数 $x,y$ 表示村庄 $x$ 和村庄 $y$ 之间有一条双向通行的道路。", "outputFormat": "一个整数表示 $M$ 天结束后好感值最高的村庄的编号。如果有多个好感值最高的村庄，输出编号最小的。", "hint": "#### 样例说明\n\n对于第一组数据，小 S 在 $2$ 号村庄旅行了 $3$ 天，结束时村庄 $1,2$ 的好感值分别为 $5,6$。所以答案输出 $2$。\n\n对于第二组数据，结束时三个村庄的好感值分别为 $3,7,8$，所以答案输出 $3$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le N\\le 2\\times10^6$，$1 \\le M\\le10^{18}$，$1 \\le A_i\\le2^{31}-1$，$1 \\le T\\le10$。\n\n| 测试点编号 | $A_i\\le$ | $\\sum N \\le$ | $M \\le $ | 测试点分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $\\rm 1$ | $10$ | $20$ | $10$ | $5$ |\n| $\\rm 2$ | $10^2$ | $2 \\times 10^2$ | $10^2$ | $10$ |\n| $\\rm 3$ | $10^3$ | $2 \\times 10^3$ | $10^3$ | $15$ |\n| $\\rm 4$ | $10^5$ | $2 \\times 10^5$ | $10^5$ | $25$ |\n| $\\rm 5$ |  | $2 \\times 10^6$ |  | $45$ |\n\n#### 提示\n\n**本题输入量较大，请使用较快的读入方式。**", "locale": "zh-CN"}}}
{"pid": "P7044", "type": "P", "difficulty": 5, "samples": [["3 1\n(()", "6"], ["3 2\n(()", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化", "组合数学", "洛谷月赛"], "title": "「MCOI-03」括号", "background": "MCOI q 群的日常 ……\n\n> 一只书虫仔：挖不到钻石，我要哭了（笑）     \n> WAPER420：我们分明次次挖到钻石啊（疑惑）   \n> 一只书虫仔：（友善的笑容）     \n> 7KByte：为什么你们都喜欢加括号啊（呆呆地望着）      \n> 一只书虫仔：（笑）  \n> WAPER420：（笑）     \n> 鏡音リン：（笑）     \n> 7KByte：（笑）\n\n---\n\n本题中 **合法括号串** 的定义如下：\n\n1. 空串是合法括号串。\n2. 如果 ```A``` 是合法括号串，则 ```(A)``` 是合法括号串。\n3. 如果 ```A```，```B``` 是合法括号串，则 ```AB``` 是合法括号串。\n\n本题中 **子串** 的定义如下：\n\n字符串 $S$ 的子串是 $S$ 中连续的任意个字符组成的字符串。$S$ 的子串可用起始位置 $l$ 与终止位置 $r$ 来表示，记为 $S(l,r)$（$1 \\leq l \\leq r \\leq |S|$，$|S |$ 表示 ```S``` 的长度）。", "description": "定义一个括号串的 $0$ 级偏值为将该括号串修改为 **合法括号串** 需要的最小操作数。一次操作你可以在一个位置 **添加** 一个括号或者 **删除** 一个位置的括号。\n\n定义一个括号串的 $i\\ (i>0)$ 级偏值为该串 **所有子串** 的 $i-1$ 级偏值之和。\n\n现在你需要求出一个长度为 $N$ 的括号串 $S$ 的 $K$ 级偏值。答案可能很大，输出对 $998244353$ 取模后的结果。", "inputFormat": "第一行包括两个整数 $N,K$。\n\n第二行一个字符串代表括号序列 $S$。", "outputFormat": "一行一个整数代表答案对 $998244353$ 取模的结果。", "hint": "#### 样例说明\n\n对于样例 $1$，$S$ 的所有子串的 $0$ 级代价为：\n\n- $\\texttt{(}$，代价为 $1$\n- $\\texttt{(}$，代价为 $1$\n- $\\texttt{)}$，代价为 $1$\n- $\\texttt{((}$，代价为 $2$\n- $\\texttt{()}$，代价为 $0$\n- $\\texttt{(()}$，代价为 $1$\n\n总和为 $1+1+1+2+0+1=6$。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $N\\le$ | $K\\le$ | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $5$ | $5$ | $3$ |\n| $2$ | $5\\times 10^3$ | $1$ | $10$ |\n| $3$ | $10^6$ | $1$ | $12$ |\n| $4$ | $10^2$ | $10^2$ | $10$ |\n| $5$ | $5\\times10^3$ | $5\\times 10^3$ | $20$ |\n| $6$ | $10^6$ | $10^6$ | $45$ |\n\n\n对于 $100\\%$ 的数据，$1 \\le N,K \\le  10^6$。\n\n---\n\n原 idea：WAPER420", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MCOI-03」括号", "background": "MCOI q 群的日常 ……\n\n> 一只书虫仔：挖不到钻石，我要哭了（笑）     \n> WAPER420：我们分明次次挖到钻石啊（疑惑）   \n> 一只书虫仔：（友善的笑容）     \n> 7KByte：为什么你们都喜欢加括号啊（呆呆地望着）      \n> 一只书虫仔：（笑）  \n> WAPER420：（笑）     \n> 鏡音リン：（笑）     \n> 7KByte：（笑）\n\n---\n\n本题中 **合法括号串** 的定义如下：\n\n1. 空串是合法括号串。\n2. 如果 ```A``` 是合法括号串，则 ```(A)``` 是合法括号串。\n3. 如果 ```A```，```B``` 是合法括号串，则 ```AB``` 是合法括号串。\n\n本题中 **子串** 的定义如下：\n\n字符串 $S$ 的子串是 $S$ 中连续的任意个字符组成的字符串。$S$ 的子串可用起始位置 $l$ 与终止位置 $r$ 来表示，记为 $S(l,r)$（$1 \\leq l \\leq r \\leq |S|$，$|S |$ 表示 ```S``` 的长度）。", "description": "定义一个括号串的 $0$ 级偏值为将该括号串修改为 **合法括号串** 需要的最小操作数。一次操作你可以在一个位置 **添加** 一个括号或者 **删除** 一个位置的括号。\n\n定义一个括号串的 $i\\ (i>0)$ 级偏值为该串 **所有子串** 的 $i-1$ 级偏值之和。\n\n现在你需要求出一个长度为 $N$ 的括号串 $S$ 的 $K$ 级偏值。答案可能很大，输出对 $998244353$ 取模后的结果。", "inputFormat": "第一行包括两个整数 $N,K$。\n\n第二行一个字符串代表括号序列 $S$。", "outputFormat": "一行一个整数代表答案对 $998244353$ 取模的结果。", "hint": "#### 样例说明\n\n对于样例 $1$，$S$ 的所有子串的 $0$ 级代价为：\n\n- $\\texttt{(}$，代价为 $1$\n- $\\texttt{(}$，代价为 $1$\n- $\\texttt{)}$，代价为 $1$\n- $\\texttt{((}$，代价为 $2$\n- $\\texttt{()}$，代价为 $0$\n- $\\texttt{(()}$，代价为 $1$\n\n总和为 $1+1+1+2+0+1=6$。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $N\\le$ | $K\\le$ | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $5$ | $5$ | $3$ |\n| $2$ | $5\\times 10^3$ | $1$ | $10$ |\n| $3$ | $10^6$ | $1$ | $12$ |\n| $4$ | $10^2$ | $10^2$ | $10$ |\n| $5$ | $5\\times10^3$ | $5\\times 10^3$ | $20$ |\n| $6$ | $10^6$ | $10^6$ | $45$ |\n\n\n对于 $100\\%$ 的数据，$1 \\le N,K \\le  10^6$。\n\n---\n\n原 idea：WAPER420", "locale": "zh-CN"}}}
{"pid": "P7045", "type": "P", "difficulty": 6, "samples": [["2\n3 100\n\n1\n\n1\n\n1\n\n\n2 100\n\n0", "\n\n0 1\n\n0 2\n\n1 2\n\n3\n0 1 2\n\n0 1\n\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["交互题", "Special Judge", "O2优化", "构造", "洛谷月赛"], "title": "「MCOI-03」金牌", "background": "**这是一道交互题**。\n\n书虫有很多块金牌！", "description": "书虫正在整理他的 $n$ 块金牌，他发现所有金牌都是有磁性的！形式地说，每块金牌属于一种磁极，**磁极有很多种**。两块相邻的金牌磁极相同则相互排斥，不同则相互吸引。\n\n书虫不知道每块金牌的磁极，他只能通过把两块金牌靠近的方式得知它们是相同磁极还是不同磁极。换句话说，你可以进行不超过 $Q$ 次交互，每次向交互库询问两个数 $x,y$，交互库会返回第 $x$ 块金牌和第 $y$ 块金牌是排斥还是吸引。金牌从 $0$ 到 $n-1$ 编号。\n\n书虫希望把他的金牌排成一个排列，满足任意两块相邻的金牌都相吸引，请你帮他排出 **任意一个** 合法的排列，或者告诉他无解。\n\n### 交互格式\n\n**本题包含多组数据**。输入的第一行包含一个整数 $T$, 代表数据组数。\n\n对于每一组数据，第一行读入两个整数 $n,Q$，代表金牌的数量和交互次数上限。\n\n如果你需要向交互库发起询问，请向标准输出中输出一行以空格隔开的两个整数 $x,y$ 并 **清空缓冲区**。关于如何清空缓冲区，在下面的提示中有说明。接下来，从标准输入中读入一个整数 $ret$。如果 $ret=1$ 表示第 $x$ 块金牌和第 $y$ 块金牌吸引，如果 $ret=0$ 表示它们排斥。\n\n如果你已经确定无解，请输出一行一个整数 $-1$ 并 **清空缓冲区**。然后本组数据结束，你应该接下来处理下一组数据。\n\n如果你已经确定有解，请先输出一行一个整数 $n$，接下来一行输出 **任意一组** 合法的金牌排列，并 **清空缓冲区**。然后本组数据结束，你应该接下来处理下一组数据。\n\n$T$ 组数据处理完之后你应该立即结束程序，多余的输出可能导致 RE。", "inputFormat": "见「交互格式」。", "outputFormat": "见「交互格式」。", "hint": "### 样例 1 解释\n\n样例中有两组数据。对于第一组数据，共有三块金牌，通过三次交互得知，它们的磁极都互不相同，那么任意一种排列都是正确的。\n\n对于第二组数据，两块金牌的磁极相同，所以无解。\n\n### 数据规模与约定\n\n**本题使用捆绑测试**，数据范围如下表：\n\n| 测试点编号 | $Q=$ | 特殊性质 | 得分 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\frac{n(n-1)}{2}$ | $n\\ge 4$ | $10$ |\n| $2$ | $2n-2$ | 一种磁极最多只有 $2$ 块金牌 | $20$ |\n| $3$ | $2n-2$ | 磁极的种类不超过 $3$ 种 | $20$ |\n| $4$ | $3n$ | 无 | $20$ |\n| $5$ | $2n-2$ | 无 | $30$ |\n\n对于全部数据，$2\\le n\\le5\\times10^4$，$1\\le T\\le 5\\times 10^4$，$\\sum Q\\le 10^5$。\n\n### 提示\n\n你可以使用如下语句来清空缓冲区：\n\n- 对于 C/C++：```fflush(stdout);```\n- 对于 C++：```std::cout << std::flush;```\n- 对于 Java：```System.out.flush();```\n- 对于 Python：```stdout.flush();```\n- 对于 Pascal：```flush(output);```\n- 对于其他语言，请自行查阅对应语言的帮助文档。\n- 特别的，对于 C++ 语言，在输出换行时使用 ```std::endl ``` 而不是 ```'\\n'```，也可以自动刷新缓冲区。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MCOI-03」金牌", "background": "**这是一道交互题**。\n\n书虫有很多块金牌！", "description": "书虫正在整理他的 $n$ 块金牌，他发现所有金牌都是有磁性的！形式地说，每块金牌属于一种磁极，**磁极有很多种**。两块相邻的金牌磁极相同则相互排斥，不同则相互吸引。\n\n书虫不知道每块金牌的磁极，他只能通过把两块金牌靠近的方式得知它们是相同磁极还是不同磁极。换句话说，你可以进行不超过 $Q$ 次交互，每次向交互库询问两个数 $x,y$，交互库会返回第 $x$ 块金牌和第 $y$ 块金牌是排斥还是吸引。金牌从 $0$ 到 $n-1$ 编号。\n\n书虫希望把他的金牌排成一个排列，满足任意两块相邻的金牌都相吸引，请你帮他排出 **任意一个** 合法的排列，或者告诉他无解。\n\n### 交互格式\n\n**本题包含多组数据**。输入的第一行包含一个整数 $T$, 代表数据组数。\n\n对于每一组数据，第一行读入两个整数 $n,Q$，代表金牌的数量和交互次数上限。\n\n如果你需要向交互库发起询问，请向标准输出中输出一行以空格隔开的两个整数 $x,y$ 并 **清空缓冲区**。关于如何清空缓冲区，在下面的提示中有说明。接下来，从标准输入中读入一个整数 $ret$。如果 $ret=1$ 表示第 $x$ 块金牌和第 $y$ 块金牌吸引，如果 $ret=0$ 表示它们排斥。\n\n如果你已经确定无解，请输出一行一个整数 $-1$ 并 **清空缓冲区**。然后本组数据结束，你应该接下来处理下一组数据。\n\n如果你已经确定有解，请先输出一行一个整数 $n$，接下来一行输出 **任意一组** 合法的金牌排列，并 **清空缓冲区**。然后本组数据结束，你应该接下来处理下一组数据。\n\n$T$ 组数据处理完之后你应该立即结束程序，多余的输出可能导致 RE。", "inputFormat": "见「交互格式」。", "outputFormat": "见「交互格式」。", "hint": "### 样例 1 解释\n\n样例中有两组数据。对于第一组数据，共有三块金牌，通过三次交互得知，它们的磁极都互不相同，那么任意一种排列都是正确的。\n\n对于第二组数据，两块金牌的磁极相同，所以无解。\n\n### 数据规模与约定\n\n**本题使用捆绑测试**，数据范围如下表：\n\n| 测试点编号 | $Q=$ | 特殊性质 | 得分 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\frac{n(n-1)}{2}$ | $n\\ge 4$ | $10$ |\n| $2$ | $2n-2$ | 一种磁极最多只有 $2$ 块金牌 | $20$ |\n| $3$ | $2n-2$ | 磁极的种类不超过 $3$ 种 | $20$ |\n| $4$ | $3n$ | 无 | $20$ |\n| $5$ | $2n-2$ | 无 | $30$ |\n\n对于全部数据，$2\\le n\\le5\\times10^4$，$1\\le T\\le 5\\times 10^4$，$\\sum Q\\le 10^5$。\n\n### 提示\n\n你可以使用如下语句来清空缓冲区：\n\n- 对于 C/C++：```fflush(stdout);```\n- 对于 C++：```std::cout << std::flush;```\n- 对于 Java：```System.out.flush();```\n- 对于 Python：```stdout.flush();```\n- 对于 Pascal：```flush(output);```\n- 对于其他语言，请自行查阅对应语言的帮助文档。\n- 特别的，对于 C++ 语言，在输出换行时使用 ```std::endl ``` 而不是 ```'\\n'```，也可以自动刷新缓冲区。", "locale": "zh-CN"}}}
{"pid": "P7046", "type": "P", "difficulty": 6, "samples": [["5 5 1\nababa\n1 2\n2 3\n1 3\n1 4\n2 5", "0 0\n1 0\n3 2\n5 2\n6 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 2333, 2333, 2333, 2333, 2333, 2333, 2333, 2333, 2333, 2333], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化", "洛谷月赛"], "title": "「MCOI-03」诗韵", "background": "$\\texttt{And the game was over and the player woke up from the dream. }$\n\n游戏结束了，玩家从梦中醒来。\n\n$\\texttt{And the player began a new dream. }$\n\n并开始了新的梦境。\n\n$\\texttt{And the player dreamed again, dreamed better.}$\n\n并再次沉入梦境中，沉入更好的梦。\n\n$\\texttt{And the player was the universe. And the player was love.}$\n\n而玩家就是宇宙。而玩家就是爱。\n\n$\\texttt{You are the player.}$\n\n你就是那个玩家。\n\n\n$\\texttt{Wake up.}$\n\n\n该醒了。", "description": "小 C 想要写首诗文，但是写诗需要押韵。\n\n一首诗文是由需多句子组成，这些句子需要押韵。\n\n但押韵也有优劣。小 C 对押韵有一个评分。评分定义为这些句子的最长公共后缀长度，而韵脚被定义为这些句子的公共后缀。韵脚可以为空串，一个集合的韵脚可以有多个。\n\n最开始，小 C 一个句子也没有写出来。即最开始的记忆集合为空。\n\n小 C 会思考 $M$ 个时刻。每个时刻，他会想出一个句子。即向记忆集合中加入一个新的句子。\n\n小 C 可能会加入多个相同的句子，请只保留一个。因为他的记忆力很好，所以他想到的句子不会被遗忘。\n\n但是他不想花太多心思去造句，所以他认为，只要有 **大于** $K$ 个句子，就能写成一首诗。所以每想出一个句子后，他会向你询问集合所有的元素个数 $>K$ 的子集的评分的最大值，和集合所有元素个数 $>K$ 的子集的韵脚的种类。注意：如果有多个不同的满足条件的集合韵脚相同，则这个韵脚只能计算一次。\n\n由于小 C 很强，所以他造的所有句子的总长度可能非常大。为了方便告诉你这些句子，他造的每一个句子都是长度为 $N$ 的母串 $T$ 的子串。\n\n**注意**：集合是满足特异性的，即集合中的元素应该互不相同，如果有相同元素仅保留一个。", "inputFormat": "第一行包括三个整数 $N,M,K$。\n\n\n第二行包括一个长度为 $N$ 的字符串，即母串 $T$。   \n\n\n接下来 $M$ 行，每行两个整数 $l,r$，表示当前时刻 小C 想起的句子是母串的 $[l,r]$ 子串。", "outputFormat": "$M$ 行每行两个整数。第一个整数指不同的韵脚个数，第二个整数指评分的最大值。", "hint": "#### 样例解释\n\n第一个时刻后，记忆集合为 $\\{\\texttt{\"ab\"}\\}$。没有子集满足条件，输出 $0\\ 0$。\n\n第二个时刻后，记忆集合为 $\\{\\texttt{\"ab\",\"ba\"}\\}$。能得到的韵脚只有空串。\n\n第三个时刻后，记忆集合为 $\\{\\texttt{\"ab\",\"ba\",\"aba\"}\\}$。能得到的韵脚有空串，$\\texttt{\"a\"}$，$\\texttt{\"ba\"}$。\n\n第四个时刻后，记忆集合为 $\\{\\texttt{\"ab\",\"ba\",\"aba\",\"abab\"}\\}$。能得到的韵脚有空串，$\\texttt{\"a\"}$，$\\texttt{\"ba\"}$，$\\texttt{\"b\"}$，$\\texttt{\"ab\"}$。\n\n第五个时刻后，记忆集合为 $\\{\\texttt{\"ab\",\"ba\",\"aba\",\"abab\",\"baba\"}\\}$。能得到的韵脚有空串，$\\texttt{\"a\"}$，$\\texttt{\"ba\"}$，$\\texttt{\"b\"}$，$\\texttt{\"ab\"}$，$\\texttt{\"aba\"}$。\n\n#### 数据规模和约定\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $N\\le$ | $M\\le$ |  时限 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $10$ | $\\rm1s$ | $15$ |\n| $2$ | $ 10^3$ | $10^3$  | $\\rm 1s$ | $20$ |\n| $3$ | $10^5$ | $10^5$  | $\\rm 1s$ | $25$ |\n| $4$ | $ 5\\times 10^5$ | $5\\times 10^5$ | $\\rm 2.33s$ | $40$ |\n\n对于 $100\\%$ 的数据，$1 \\le N\\le 5\\times 10^5$，$1 \\le M\\le   5 \\times 10^5，0\\le K \\le M$。仅包含小写字母。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MCOI-03」诗韵", "background": "$\\texttt{And the game was over and the player woke up from the dream. }$\n\n游戏结束了，玩家从梦中醒来。\n\n$\\texttt{And the player began a new dream. }$\n\n并开始了新的梦境。\n\n$\\texttt{And the player dreamed again, dreamed better.}$\n\n并再次沉入梦境中，沉入更好的梦。\n\n$\\texttt{And the player was the universe. And the player was love.}$\n\n而玩家就是宇宙。而玩家就是爱。\n\n$\\texttt{You are the player.}$\n\n你就是那个玩家。\n\n\n$\\texttt{Wake up.}$\n\n\n该醒了。", "description": "小 C 想要写首诗文，但是写诗需要押韵。\n\n一首诗文是由需多句子组成，这些句子需要押韵。\n\n但押韵也有优劣。小 C 对押韵有一个评分。评分定义为这些句子的最长公共后缀长度，而韵脚被定义为这些句子的公共后缀。韵脚可以为空串，一个集合的韵脚可以有多个。\n\n最开始，小 C 一个句子也没有写出来。即最开始的记忆集合为空。\n\n小 C 会思考 $M$ 个时刻。每个时刻，他会想出一个句子。即向记忆集合中加入一个新的句子。\n\n小 C 可能会加入多个相同的句子，请只保留一个。因为他的记忆力很好，所以他想到的句子不会被遗忘。\n\n但是他不想花太多心思去造句，所以他认为，只要有 **大于** $K$ 个句子，就能写成一首诗。所以每想出一个句子后，他会向你询问集合所有的元素个数 $>K$ 的子集的评分的最大值，和集合所有元素个数 $>K$ 的子集的韵脚的种类。注意：如果有多个不同的满足条件的集合韵脚相同，则这个韵脚只能计算一次。\n\n由于小 C 很强，所以他造的所有句子的总长度可能非常大。为了方便告诉你这些句子，他造的每一个句子都是长度为 $N$ 的母串 $T$ 的子串。\n\n**注意**：集合是满足特异性的，即集合中的元素应该互不相同，如果有相同元素仅保留一个。", "inputFormat": "第一行包括三个整数 $N,M,K$。\n\n\n第二行包括一个长度为 $N$ 的字符串，即母串 $T$。   \n\n\n接下来 $M$ 行，每行两个整数 $l,r$，表示当前时刻 小C 想起的句子是母串的 $[l,r]$ 子串。", "outputFormat": "$M$ 行每行两个整数。第一个整数指不同的韵脚个数，第二个整数指评分的最大值。", "hint": "#### 样例解释\n\n第一个时刻后，记忆集合为 $\\{\\texttt{\"ab\"}\\}$。没有子集满足条件，输出 $0\\ 0$。\n\n第二个时刻后，记忆集合为 $\\{\\texttt{\"ab\",\"ba\"}\\}$。能得到的韵脚只有空串。\n\n第三个时刻后，记忆集合为 $\\{\\texttt{\"ab\",\"ba\",\"aba\"}\\}$。能得到的韵脚有空串，$\\texttt{\"a\"}$，$\\texttt{\"ba\"}$。\n\n第四个时刻后，记忆集合为 $\\{\\texttt{\"ab\",\"ba\",\"aba\",\"abab\"}\\}$。能得到的韵脚有空串，$\\texttt{\"a\"}$，$\\texttt{\"ba\"}$，$\\texttt{\"b\"}$，$\\texttt{\"ab\"}$。\n\n第五个时刻后，记忆集合为 $\\{\\texttt{\"ab\",\"ba\",\"aba\",\"abab\",\"baba\"}\\}$。能得到的韵脚有空串，$\\texttt{\"a\"}$，$\\texttt{\"ba\"}$，$\\texttt{\"b\"}$，$\\texttt{\"ab\"}$，$\\texttt{\"aba\"}$。\n\n#### 数据规模和约定\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $N\\le$ | $M\\le$ |  时限 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $10$ | $\\rm1s$ | $15$ |\n| $2$ | $ 10^3$ | $10^3$  | $\\rm 1s$ | $20$ |\n| $3$ | $10^5$ | $10^5$  | $\\rm 1s$ | $25$ |\n| $4$ | $ 5\\times 10^5$ | $5\\times 10^5$ | $\\rm 2.33s$ | $40$ |\n\n对于 $100\\%$ 的数据，$1 \\le N\\le 5\\times 10^5$，$1 \\le M\\le   5 \\times 10^5，0\\le K \\le M$。仅包含小写字母。\n", "locale": "zh-CN"}}}
{"pid": "P7047", "type": "P", "difficulty": 7, "samples": [["10", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "高精度", "O2优化", "剪枝", "洛谷月赛"], "title": "「MCOI-03」数据", "background": "Rin 正在给 MCOI Round 998244353 的题目出数据。\n\n但是她太菜了，把数据生成器写出锅了，于是数据只生成了一半然后生成器就 RE 了。\n\n现在她想请你用这一半的数据恢复出完整的数据。", "description": "以下是一些常见的定义，如果你很熟悉它们你也可以不看。\n\n01 串是指仅包含 ```0``` 和 ```1``` 两种字符的字符串，仅包含其中一种也是可以的。\n\n一个字符串取出其连续的一段称为子串。容易发现一个长度为 $2n$ 的字符串有 $n+1$ 个长度为 $n$ 的子串。\n\n一组实数 $A$ 的平均值 $\\overline{A}=\\frac{\\sum_{x\\in A}x}{|A|}$，即所有元素的和除以元素的个数。\n\n在此基础上，$A$ 的方差 $S^2=\\frac{\\sum_{x\\in A}(x-\\overline{A})^2}{|A|}$，即所有元素与平均值的差的平方和除以元素的个数。\n\n一个长度为 $n$ 的 01 串 $S$ 的二进制值等于 $\\sum_{i=1}^nS_i2^{n-i}$，其中 $S_i$ 是 $S$ 从左向右第 $i$ 个字符上的数字。\n\n在本题中，给出如下定义：\n\n一组数据是一个长度为 $2n$ 的 01 串。\n\n一组数据的毒瘤度定义为，其所有长度为 $n$ 的子串的二进制值的方差。\n\n现在，给定一组数据的前 $n$ 个字符。你需要找到使得这组数据的毒瘤度 **最小** 的后 $n$ 个字符。如果有多解，请按照这后 $n$ 个字符构成的子串的二进制值从小到大排序输出。\n\n", "inputFormat": "输入数据共一行，包含一个长度为 $n$ 的 01 串，表示一组数据的前 $n$ 个字符。", "outputFormat": "输出若干行，每一行一个长度为 $n$ 的 01 串，表示一组毒瘤度最小的数据的后 $n$ 个字符，按照其二进制值从小到大排序输出。", "hint": "#### 样例一解释\n\n在本例中 $n=2$，存在四组满足要求的数据分别是 ```1000```，```1001```，```1010```，```1011```。\n\n```1010``` 有三个长度为 $2$ 的子串，分别为 ```10```，```01```，```10```。它们的二进制值分别为 $2,1,2$。${2,1,2}$ 的平均值为 $\\frac{5}{3}$，方差为 $\\frac{2}{9}$。故 ```1010``` 的毒瘤度为 $\\frac{2}{9}$。\n\n可以计算出这四组数据的毒瘤度分别为 $\\frac{8}{9},\\frac{2}{3},\\frac{2}{9},\\frac{2}{3}$。其中 ```1010``` 是唯一毒瘤度最小的，故程序输出其后 $2$ 个字符 ```10```。\n\n#### 数据范围与提示\n\n保证所有数据随机生成。对于 01 串的每一位，其为 ```1``` 的概率都是 $\\frac{1}{2}$ 且不同位相互独立。\n\n本题不采用捆绑测试，按点给分。测试点 $1$ 计 $1$ 分，其他测试点每个计 $3$ 分。\n\n每个测试点 $n$ 的规模如下表：\n\n| 测试点编号 | $1$ | $2\\sim 7$ | $8\\sim 13$ | $14\\sim 16$ | \n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $n$ | $\\le 3$ | $\\le20$ | $=26$ | $=56$ | \n|**测试点编号**|$17\\sim 20$ | $21\\sim 24$ | $25\\sim 28$ | $29\\sim 34$ |\n|$n$|$=200$ | $=500$ | $\\le1000$ | $\\le 1500$ |\n\n提示：在 C++ 中您可以使用 $128$ 位整数```__int128```。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MCOI-03」数据", "background": "Rin 正在给 MCOI Round 998244353 的题目出数据。\n\n但是她太菜了，把数据生成器写出锅了，于是数据只生成了一半然后生成器就 RE 了。\n\n现在她想请你用这一半的数据恢复出完整的数据。", "description": "以下是一些常见的定义，如果你很熟悉它们你也可以不看。\n\n01 串是指仅包含 ```0``` 和 ```1``` 两种字符的字符串，仅包含其中一种也是可以的。\n\n一个字符串取出其连续的一段称为子串。容易发现一个长度为 $2n$ 的字符串有 $n+1$ 个长度为 $n$ 的子串。\n\n一组实数 $A$ 的平均值 $\\overline{A}=\\frac{\\sum_{x\\in A}x}{|A|}$，即所有元素的和除以元素的个数。\n\n在此基础上，$A$ 的方差 $S^2=\\frac{\\sum_{x\\in A}(x-\\overline{A})^2}{|A|}$，即所有元素与平均值的差的平方和除以元素的个数。\n\n一个长度为 $n$ 的 01 串 $S$ 的二进制值等于 $\\sum_{i=1}^nS_i2^{n-i}$，其中 $S_i$ 是 $S$ 从左向右第 $i$ 个字符上的数字。\n\n在本题中，给出如下定义：\n\n一组数据是一个长度为 $2n$ 的 01 串。\n\n一组数据的毒瘤度定义为，其所有长度为 $n$ 的子串的二进制值的方差。\n\n现在，给定一组数据的前 $n$ 个字符。你需要找到使得这组数据的毒瘤度 **最小** 的后 $n$ 个字符。如果有多解，请按照这后 $n$ 个字符构成的子串的二进制值从小到大排序输出。\n\n", "inputFormat": "输入数据共一行，包含一个长度为 $n$ 的 01 串，表示一组数据的前 $n$ 个字符。", "outputFormat": "输出若干行，每一行一个长度为 $n$ 的 01 串，表示一组毒瘤度最小的数据的后 $n$ 个字符，按照其二进制值从小到大排序输出。", "hint": "#### 样例一解释\n\n在本例中 $n=2$，存在四组满足要求的数据分别是 ```1000```，```1001```，```1010```，```1011```。\n\n```1010``` 有三个长度为 $2$ 的子串，分别为 ```10```，```01```，```10```。它们的二进制值分别为 $2,1,2$。${2,1,2}$ 的平均值为 $\\frac{5}{3}$，方差为 $\\frac{2}{9}$。故 ```1010``` 的毒瘤度为 $\\frac{2}{9}$。\n\n可以计算出这四组数据的毒瘤度分别为 $\\frac{8}{9},\\frac{2}{3},\\frac{2}{9},\\frac{2}{3}$。其中 ```1010``` 是唯一毒瘤度最小的，故程序输出其后 $2$ 个字符 ```10```。\n\n#### 数据范围与提示\n\n保证所有数据随机生成。对于 01 串的每一位，其为 ```1``` 的概率都是 $\\frac{1}{2}$ 且不同位相互独立。\n\n本题不采用捆绑测试，按点给分。测试点 $1$ 计 $1$ 分，其他测试点每个计 $3$ 分。\n\n每个测试点 $n$ 的规模如下表：\n\n| 测试点编号 | $1$ | $2\\sim 7$ | $8\\sim 13$ | $14\\sim 16$ | \n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $n$ | $\\le 3$ | $\\le20$ | $=26$ | $=56$ | \n|**测试点编号**|$17\\sim 20$ | $21\\sim 24$ | $25\\sim 28$ | $29\\sim 34$ |\n|$n$|$=200$ | $=500$ | $\\le1000$ | $\\le 1500$ |\n\n提示：在 C++ 中您可以使用 $128$ 位整数```__int128```。", "locale": "zh-CN"}}}
{"pid": "P7048", "type": "P", "difficulty": 2, "samples": [["210 297\n", "105.0\n"], ["250 100\n", "83.333333\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Alex Origami Squares", "background": "", "description": "\n\nAlex is fond of origami -- Japanese art of paper folding. Most origami designs start with a square sheet of paper. Alex is going to make a present for his mother. Present's design requires three equal square sheets of paper, but Alex has only one rectangular sheet. He is able to cut out squares of this sheet, but their sides should be parallel to the sides of the sheet. Help Alex to determine the maximum possible size of the paper squares he is able to cut out.\n\n", "inputFormat": "\n\nThe single line of the input file contains two integers $h$ and $w$ -- the height and the width of the sheet of paper $(1 \\le h , w \\le 1000)$ .\n\n", "outputFormat": "\n\nOutput a single real number -- the maximum possible length of the square side. It should be possible to cut out three such squares of $h \\times w$ sheet of paper, so that their sides are parallel to the sides of the sheet.\n\nYour answer should be precise up to three digits after the decimal point.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Alex Origami Squares", "background": "", "description": "\n\nAlex is fond of origami -- Japanese art of paper folding. Most origami designs start with a square sheet of paper. Alex is going to make a present for his mother. Present's design requires three equal square sheets of paper, but Alex has only one rectangular sheet. He is able to cut out squares of this sheet, but their sides should be parallel to the sides of the sheet. Help Alex to determine the maximum possible size of the paper squares he is able to cut out.\n\n", "inputFormat": "\n\nThe single line of the input file contains two integers $h$ and $w$ -- the height and the width of the sheet of paper $(1 \\le h , w \\le 1000)$ .\n\n", "outputFormat": "\n\nOutput a single real number -- the maximum possible length of the square side. It should be possible to cut out three such squares of $h \\times w$ sheet of paper, so that their sides are parallel to the sides of the sheet.\n\nYour answer should be precise up to three digits after the decimal point.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Alex Origami Squares", "background": "", "description": "有一张矩形纸，要求将其裁成三个全等的正方形，且每一个正方形的侧面都与纸张的侧面平行，问裁成的小正方形边长最大是多少。", "inputFormat": "一行两个整数 $h$ 和 $w$ $(1\\le h,w\\le 10^3)$ 表示矩形纸张的长和宽。", "outputFormat": "输出一行一个实数，表示正方形边长的最大可能值。\n\n你的答案与标准答案的相对及绝对误差不应超过 $10^{-3}$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7049", "type": "P", "difficulty": 4, "samples": [["2 3\n", "6 7\n@@@@@@@\n@.@@@@@\n@@...@@\n@@@@@@@\n.......\n@@@@@@@\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Black and White", "background": "", "description": "\n\nThe jury has a great artistic idea -- to create a rectangular panel out of a huge pile of black and white squares of the same size. The panel should have exactly $b 4-connected$ areas made of black tiles, and $w 4-connected$ areas made of white tiles.\n\nRemember, a $4-connected$ area of some color is a maximal set of the panel tiles such that:\n\nany two tiles of the area share the same color;\n\nfor any two tiles of the area there is a tile sequence connecting them, such that any two consecutive tiles of the sequence share a common side.\n\nIn addition to the artistic idea, the jury has already developed a program that produces design of the panel. But since this problem is about art, any new solution is extremely important for the jury.\n\n", "inputFormat": "\n\nThe only line of the input file contains two integers $b$ and $w$ -- number of black and white areas $(1 \\le b , w \\le 1000)$ .\n\n", "outputFormat": "\n\nThe first line of the output file should contain the picture sizes $r$ and $c$ -- the number of rows and columns $(1 \\le r , c \\le 100 000)$ . This line should be followed by $r$ lines of $c$ symbols each. Each symbol should be either $‘@'$ (for black tile) or $‘. '$ (for white one). There should be no more than $100 000$ tiles in the panel.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Black and White", "background": "", "description": "\n\nThe jury has a great artistic idea -- to create a rectangular panel out of a huge pile of black and white squares of the same size. The panel should have exactly $b 4-connected$ areas made of black tiles, and $w 4-connected$ areas made of white tiles.\n\nRemember, a $4-connected$ area of some color is a maximal set of the panel tiles such that:\n\nany two tiles of the area share the same color;\n\nfor any two tiles of the area there is a tile sequence connecting them, such that any two consecutive tiles of the sequence share a common side.\n\nIn addition to the artistic idea, the jury has already developed a program that produces design of the panel. But since this problem is about art, any new solution is extremely important for the jury.\n\n", "inputFormat": "\n\nThe only line of the input file contains two integers $b$ and $w$ -- number of black and white areas $(1 \\le b , w \\le 1000)$ .\n\n", "outputFormat": "\n\nThe first line of the output file should contain the picture sizes $r$ and $c$ -- the number of rows and columns $(1 \\le r , c \\le 100 000)$ . This line should be followed by $r$ lines of $c$ symbols each. Each symbol should be either $‘@'$ (for black tile) or $‘. '$ (for white one). There should be no more than $100 000$ tiles in the panel.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Black and White", "background": "", "description": "陪审团有一个很棒的艺术创意——用一大堆相同大小的黑白方块创建一个矩形面板。面板应该有恰好 $b$ 个 4-连通的黑色区域和 $w$ 个 4-连通的白色区域。\n\n请记住，一个颜色的 4-连通区域是面板方块的一个极大集合，使得：\n\n任何两个区域的方块颜色相同；\n\n对于区域的任何两个方块，都存在一个连接它们的方块序列，使得序列中的任何两个连续方块共享一个公共边。\n\n除了这个艺术创意，陪审团已经开发了一个程序来生成面板的设计。但由于这个问题涉及艺术，任何新的解决方案对陪审团来说都极其重要。", "inputFormat": "输入文件的唯一一行包含两个整数 $b$ 和 $w$——黑色和白色区域的数量 $(1 \\le b , w \\le 1000)$。", "outputFormat": "输出文件的第一行应包含图片的尺寸 $r$ 和 $c$——行数和列数 $(1 \\le r , c \\le 100 000)$。接下来的 $r$ 行中，每行应包含 $c$ 个符号。每个符号应为 ‘@’（表示黑色方块）或 ‘.’（表示白色方块）。面板中的方块数量不应超过 $100 000$。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7050", "type": "P", "difficulty": 3, "samples": [["cat\ndog\n", "9\n"], ["tree\nheap\n", "14\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Concatenation", "background": "", "description": "\n\nFamous programmer Gennady likes to create new words. One way to do it is to concatenate existing words. That means writing one word after another. For example, if he has words `cat` and `dog`, he would get a word `catdog`, that could mean something like the name of a creature with two heads: one cat head and one dog head.\n\nGennady is a bit bored of this way of creating new words, so he has invented another method. He takes a non-empty prefix of the first word, a non-empty suffix of the second word, and concatenates them. For example, if he has words `tree` and `heap`, he can get such words as `treap`, `tap`, or `theap`. Who knows what they could mean?\n\nGennady chooses two words and wants to know how many different words he can create using his new method. Of course, being a famous programmer, he has already calculated the answer. Can you do the same?\n\n", "inputFormat": "\n\nTwo lines of the input file contain words chosen by Gennady. They have lengths between $1$ and $100 000$ characters and consist of lowercase English letters only.\n\n", "outputFormat": "\n\nOutput one integer -- the number of different words Gennady can create out of words given in the input file.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Concatenation", "background": "", "description": "\n\nFamous programmer Gennady likes to create new words. One way to do it is to concatenate existing words. That means writing one word after another. For example, if he has words `cat` and `dog`, he would get a word `catdog`, that could mean something like the name of a creature with two heads: one cat head and one dog head.\n\nGennady is a bit bored of this way of creating new words, so he has invented another method. He takes a non-empty prefix of the first word, a non-empty suffix of the second word, and concatenates them. For example, if he has words `tree` and `heap`, he can get such words as `treap`, `tap`, or `theap`. Who knows what they could mean?\n\nGennady chooses two words and wants to know how many different words he can create using his new method. Of course, being a famous programmer, he has already calculated the answer. Can you do the same?\n\n", "inputFormat": "\n\nTwo lines of the input file contain words chosen by Gennady. They have lengths between $1$ and $100 000$ characters and consist of lowercase English letters only.\n\n", "outputFormat": "\n\nOutput one integer -- the number of different words Gennady can create out of words given in the input file.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Concatenation", "background": "", "description": "著名的程序员 Gennady 喜欢创造新单词。其中一种方法是连接现有单词。\n\n举个例子：如果 Gennady 有 `cat` 和 `dog` 两个词，那么他会得到一个新词： `catdog`，这可能意味着带有两个头的生物的名字：一个猫头和一个狗头。\n\nGennady 觉得这种创建新单词的方式有点无聊，因此他发明了另一种方法：使用第一个单词的非空前缀，第二个单词的非空后缀，并将它们连接起来。例如，如果他有单词 `tree` 和 `heap` ，则可以得到诸如 `treap`，`tap` 或 `theap` 之类的单词。\n\nGennady 选择了两个单词，并想知道他可以使用新方法创建多少个不同的单词。当然，作为著名的程序员，他已经计算出了答案。他突然想考考你，那么你能编写一个程序把答案计算出来吗？", "inputFormat": "两行，每行有一个 Gennady 选择的单词 $s_i$ （$1\\leq |s_i| \\leq 100000$，$s_i$ 仅由小写英文字母组成）。", "outputFormat": "输出一个整数，这个整数表示 Gennady 可以从这两个给定的单词中创建不同单词的数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7051", "type": "P", "difficulty": 3, "samples": [["4\n1\n2\n3\n10\n", "1\n1\n1\n2\n1\n3\n2\n4 6\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Distribution in Metagonia", "background": "", "description": "\n\nThere are one hundred noble families in the country of Metagonia, and each year some of these families receive several ritual cubes from the Seer of the One. The One has several rules about cube distribution: if a family receives at least one cube, every prime divisor of the number of cubes received should be either $2$ or $3$ , moreover if one family receives a $> 0$ cubes and another family in the same year receives $b > 0$ cubes then a should not be divisible by $b$ and vice versa.\n\nYou are the Seer of the One. You know in advance how many cubes would be available for distribution for the next $t$ years. You want to find any valid distribution of cubes for each of these years. Each year you have to distribute all cubes available for that year.\n\n", "inputFormat": "\n\nThe first line of input file contains a single integer $t$ -- the number of years to come $(1 \\le t \\le 1000)$ . Each of the following $t$ lines contains a single integer $n_{i}$ -- the number of cubes to distribute in i-th year $(1 \\le n_{i} \\le 10^{18}).$\n\n", "outputFormat": "\n\nFor each year $i$ output two lines. The first line should contain $m_{i}$ -- the number of families that would receive at least one cube in i-th year $(1 \\le m_{i} \\le 100)$ . The second line should contain $m_{i}$ integers -- the number of cubes received by each family. The sum of these numbers should be equal to $n_{i}.$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Distribution in Metagonia", "background": "", "description": "\n\nThere are one hundred noble families in the country of Metagonia, and each year some of these families receive several ritual cubes from the Seer of the One. The One has several rules about cube distribution: if a family receives at least one cube, every prime divisor of the number of cubes received should be either $2$ or $3$ , moreover if one family receives a $> 0$ cubes and another family in the same year receives $b > 0$ cubes then a should not be divisible by $b$ and vice versa.\n\nYou are the Seer of the One. You know in advance how many cubes would be available for distribution for the next $t$ years. You want to find any valid distribution of cubes for each of these years. Each year you have to distribute all cubes available for that year.\n\n", "inputFormat": "\n\nThe first line of input file contains a single integer $t$ -- the number of years to come $(1 \\le t \\le 1000)$ . Each of the following $t$ lines contains a single integer $n_{i}$ -- the number of cubes to distribute in i-th year $(1 \\le n_{i} \\le 10^{18}).$\n\n", "outputFormat": "\n\nFor each year $i$ output two lines. The first line should contain $m_{i}$ -- the number of families that would receive at least one cube in i-th year $(1 \\le m_{i} \\le 100)$ . The second line should contain $m_{i}$ integers -- the number of cubes received by each family. The sum of these numbers should be equal to $n_{i}.$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Distribution in Metagonia", "background": "", "description": "在梅塔戈尼亚国有一百个贵族家庭，每年这些家庭中的一些会从“唯一者”的先知那里收到几个仪式立方体。“唯一者”对立方体的分配有几个规则：如果一个家庭收到至少一个立方体，那么收到的立方体数量的所有质因数应该是 $2$ 或 $3$。此外，如果一个家庭收到 $a > 0$ 个立方体，而同一年另一个家庭收到 $b > 0$ 个立方体，那么 $a$ 不应该能被 $b$ 整除，反之亦然。\n\n你是“唯一者”的先知。你提前知道未来 $t$ 年将有多少立方体可供分配。你想为这些年中的每一年找到任何有效的立方体分配方案。每年你必须分配掉该年所有可用的立方体。", "inputFormat": "输入文件的第一行包含一个整数 $t$ —— 即将到来的年份数 $(1 \\le t \\le 1000)$。接下来的 $t$ 行中的每一行包含一个整数 $n_{i}$ —— 在第 $i$ 年要分配的立方体数量 $(1 \\le n_{i} \\le 10^{18})$。", "outputFormat": "对于每一年 $i$ 输出两行。第一行应包含 $m_{i}$ —— 在第 $i$ 年至少收到一个立方体的家庭数量 $(1 \\le m_{i} \\le 100)$。第二行应包含 $m_{i}$ 个整数 —— 每个家庭收到的立方体数量。这些数字的总和应等于 $n_{i}$。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7052", "type": "P", "difficulty": 2, "samples": [["10+20-30\n", "10+20-3+0\n"], ["-3-4-1\n", "-3-4-1\n"], ["+10\n", "+10\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["字符串", "2015", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Easy Arithmetic", "background": "", "description": "\n\nEva is a third-grade elementary school student. She has just learned how to perform addition and subtraction of arbitrary-precision integers. Her homework is to evaluate some expressions. It is boring, so she decided to add a little trick to the homework. Eva wants to add some plus and minus signs to the expression to make its value as large as possible.\n\n", "inputFormat": "\n\nThe single line of the input file contains the original arithmetic expression. It contains only digits, plus $(‘+')$ and minus $(‘-')$ signs.\n\nThe original expression is correct, that is:\n\nnumbers have no leading zeroes;\n\nthere are no two consecutive signs;\n\nthe last character of the expression is a digit.\n\nThe length of the original expression does not exceed $1000$ characters.\n\n", "outputFormat": "\n\nOutput a single line -- the original expression with some plus and minus signs added. Output expression must satisfy the same correctness constraints as the original one. Its value must be as large as possible.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Easy Arithmetic", "background": "", "description": "\n\nEva is a third-grade elementary school student. She has just learned how to perform addition and subtraction of arbitrary-precision integers. Her homework is to evaluate some expressions. It is boring, so she decided to add a little trick to the homework. Eva wants to add some plus and minus signs to the expression to make its value as large as possible.\n\n", "inputFormat": "\n\nThe single line of the input file contains the original arithmetic expression. It contains only digits, plus $(‘+')$ and minus $(‘-')$ signs.\n\nThe original expression is correct, that is:\n\nnumbers have no leading zeroes;\n\nthere are no two consecutive signs;\n\nthe last character of the expression is a digit.\n\nThe length of the original expression does not exceed $1000$ characters.\n\n", "outputFormat": "\n\nOutput a single line -- the original expression with some plus and minus signs added. Output expression must satisfy the same correctness constraints as the original one. Its value must be as large as possible.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Easy Arithmetic", "background": "", "description": "Eva 是一名三年级的小学生。她刚刚学会了如何进行任意精度整数的加减法。她的作业是计算一些表达式。这很无聊，所以她决定在作业中增加一点小技巧。Eva 想在表达式中添加一些加号和减号，使其值尽可能大。", "inputFormat": "输入文件的单行包含原始算术表达式。它只包含数字、加号（‘+’）和减号（‘-’）符号。\n\n原始表达式是正确的，即：\n\n数字没有前导零；\n\n没有两个连续的符号；\n\n表达式的最后一个字符是数字。\n\n原始表达式的长度不超过 1000 个字符。", "outputFormat": "输出一行——在原始表达式中添加了一些加号和减号。输出的表达式必须满足与原始表达式相同的正确性约束。其值必须尽可能大。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7053", "type": "P", "difficulty": 5, "samples": [["for i in range(n):\n    for j in range(i):\n        lag\nfor x in range(5):\n    for y in range(n):\n        for z in range(n):\n            lag\n    lag\n", "1/2 * n * (n-1) + 5 * (n*n + 1)\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Fygon", "background": "", "description": "\n\nFrederick is a young programmer. He participates in all programming contests he can find and always uses his favorite programming language Fygon. Unfortunately, he often receives Time Limit Exceeded outcome, even when his algorithm is asymptotically optimal. That's because the Fygon interpreter is very slow. Nevertheless, Frederick likes Fygon so much, that he uses non-asymptotical optimizations to fit the solution into time limit. To make it easier, he asks you to write a program, which will be able to estimate the exact number of operations that his Fygon program makes.\n\nFor simplicity, we will assume that Fygon has only two statements. The first statement is lag. It substitutes almost any other statement. The second statement is a for loop:\n\nfor in range $():$\n\nThis means that iterates over values from $0$ to $−1$ . In Fygon is a lowercase letter from a to $z$ , and is either already defined or a positive integer constant. The of the loop is indented by four spaces and contains at least one statement.\n\nThe program receives the input in the variable $n$ . This variable has special meaning and cannot be used as a loop variable.\n\nYour task is to find the formula that calculates the number of performed lag operations by the given Fygon program, depending on the value of the variable $n$ .\n\n", "inputFormat": "\n\nThe input file contains the Fygon program. No two loops use the same variable as iterators. Each variable used inside a range is either $n$ or declared in some outer loop.\n\nThe program has at most $20$ statements and at most $6$ of them are loops. All integer constants are from $1$ to $9$ . Outpu\n\n", "outputFormat": "\n\nOutput the formula for the number of performed lag operations depending on $n$ . The length of the formula should be at most $100$ characters (excluding spaces). The formula should correspond to the following grammar:\n\n$〈Expressio_n〉 ::= 〈Product〉 ( (‘+' | ‘-') 〈Product〉) ^{ \\times }$\n\n$〈Product〉 ::= 〈Value〉 (‘ \\times '〈Value〉) ^{ \\times }$\n\n$〈Value〉 ::= ‘n' | 〈Number〉 | ‘-'〈Value〉 | ‘('〈Expressio_n〉‘)'$\n\n$〈Number〉 ::= [‘0' \\cdots ‘9'] ^{+} (‘/' [‘0' \\cdots ‘9'] ^{+}) ^{?}$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Fygon", "background": "", "description": "\n\nFrederick is a young programmer. He participates in all programming contests he can find and always uses his favorite programming language Fygon. Unfortunately, he often receives Time Limit Exceeded outcome, even when his algorithm is asymptotically optimal. That's because the Fygon interpreter is very slow. Nevertheless, Frederick likes Fygon so much, that he uses non-asymptotical optimizations to fit the solution into time limit. To make it easier, he asks you to write a program, which will be able to estimate the exact number of operations that his Fygon program makes.\n\nFor simplicity, we will assume that Fygon has only two statements. The first statement is lag. It substitutes almost any other statement. The second statement is a for loop:\n\nfor in range $():$\n\nThis means that iterates over values from $0$ to $−1$ . In Fygon is a lowercase letter from a to $z$ , and is either already defined or a positive integer constant. The of the loop is indented by four spaces and contains at least one statement.\n\nThe program receives the input in the variable $n$ . This variable has special meaning and cannot be used as a loop variable.\n\nYour task is to find the formula that calculates the number of performed lag operations by the given Fygon program, depending on the value of the variable $n$ .\n\n", "inputFormat": "\n\nThe input file contains the Fygon program. No two loops use the same variable as iterators. Each variable used inside a range is either $n$ or declared in some outer loop.\n\nThe program has at most $20$ statements and at most $6$ of them are loops. All integer constants are from $1$ to $9$ . Outpu\n\n", "outputFormat": "\n\nOutput the formula for the number of performed lag operations depending on $n$ . The length of the formula should be at most $100$ characters (excluding spaces). The formula should correspond to the following grammar:\n\n$〈Expressio_n〉 ::= 〈Product〉 ( (‘+' | ‘-') 〈Product〉) ^{ \\times }$\n\n$〈Product〉 ::= 〈Value〉 (‘ \\times '〈Value〉) ^{ \\times }$\n\n$〈Value〉 ::= ‘n' | 〈Number〉 | ‘-'〈Value〉 | ‘('〈Expressio_n〉‘)'$\n\n$〈Number〉 ::= [‘0' \\cdots ‘9'] ^{+} (‘/' [‘0' \\cdots ‘9'] ^{+}) ^{?}$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Fygon", "background": "", "description": "# [NWRRC2015] Fygon 翻译\n\n\n弗雷德里克是一名年轻的程序员。他参加了所有能找到的编程比赛，并总是使用他最喜欢的编程语言 Fygon。不幸的是，他经常收到 \"超过时间限制 \"的结果，即使他的算法是渐近最优的。这是因为 Fygon 解释器非常慢。尽管如此，弗雷德里克还是非常喜欢 Fygon，所以他使用了非渐进优化的方法来使求解符合时间限制。为了方便起见，他要求你写一个程序，能够估算出他的 Fygon 程序所做的确切操作次数。\n\n为了简单起见，我们假设 Fygon 只有两条语句。第一条语句是滞后的。它几乎可以替代任何其他语句。第二条语句是 for 循环：\n\nfor in range $():$\n\n这意味着遍历从 $0$ 到 $-1$ 的值。 在 Fygon 中是从 $a$ 到 $z$ 的小写字母，并且要么是已经定义的，要么是正整数常数。循环语句缩进四个空格，至少包含一条语句。\n\n程序接收变量 $n$ 的输入。该变量具有特殊含义，不能用作循环变量。您的任务是根据变量 $n$ 的值，找出计算 Fygon 程序执行滞后操作次数的公式。", "inputFormat": "输入文件包含 Fygon 程序。没有两个循环使用相同的变量作为迭代器。范围内使用的每个变量要么是 $n$，要么是在某个外循环中声明的。\n\n程序最多有 $20$ 语句，其中最多有 $6$ 是循环。所有整数常量从 $1$ 到 $9$ 不等。", "outputFormat": "根据 $n$ 输出已执行滞后运算次数的公式。公式长度最多为 $100$ 字符（不包括空格）。公式应符合以下语法：\n\n$〈表达式〉 ::= 〈产物〉 ( (‘+' | ‘-') 〈产物〉) ^{ \\times }$\n\n$〈产物〉 ::= 〈价值〉 (‘ \\times '〈价值〉) ^{ \\times }$\n\n$〈价值〉 ::= ‘n' | 〈数〉 | ‘-'〈价值〉 | ‘('〈表达式〉‘)'$\n\n$〈数〉 ::= [‘0' \\cdots ‘9'] ^{+} (‘/' [‘0' \\cdots ‘9'] ^{+}) ^{?}$\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\nfor i in range(n):\n    for j in range(i):\n        lag\nfor x in range(5):\n    for y in range(n):\n        for z in range(n):\n            lag\n    lag\n```\n\n### 样例输出 #1\n\n```\n1/2 * n * (n-1) + 5 * (n*n + 1)\n```", "hint": "时间限制：2 秒，内存限制：256 MB。", "locale": "zh-CN"}}}
{"pid": "P7054", "type": "P", "difficulty": 7, "samples": [["5 3 2\n1 4\n4 2\n1 3\n", "5 1 4 2 3\n2\n4 3\n5 1\n"], ["2 2 20\n1 2\n1 2\n", "1 2\n1\n1 2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "堆", "Special Judge", "拓扑排序", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Graph", "background": "", "description": "\n\nThe sequence $a_{1}, a_{2},$ . . . , $a_{n}$ is called a permutation, if it contains every integer from $1$ to $n$ .\n\nThe permutation of vertices $a_{1}, a_{2},$ . . . , $a_{n}$ is a topological sort of a directed graph, if for every directed edge from $u$ to $v$ , vertex $u$ comes before $v$ in this permutation.\n\nThe permutation $a_{1}, a_{2},$ . . . , $a_{n}$ is lexicographically smaller than the permutation $b_{1}, b_{2},$ . . . , $b_{n},$ if there exists $m$ such that $a_{i} = b_{i}$ for every $1 \\le i < m$ and $a_{m} < b_{m}.$\n\nGiven a directed acyclic graph, add at most $k$ directed edges to it in such a way, that the resulting graph still has no cycles and the lexicographically minimal topological sort of the graph is maximum possible.\n\n", "inputFormat": "\n\nThe first line of the input file contains three integers $n , m$ and $k$ -- the number of vertices and directed edges in the original graph, and the number of directed edges, that you are allowed to add $(1 \\le n \\le 100 000$ ; $0 \\le m , k \\le 100 000)$ .\n\nEach of the following $m$ lines contains two integers $u_{i}, v_{i},$ describing directed edge from $u_{i}$ to $v_{i} (1 \\le u_{i}, v_{i} \\le n)$ .\n\nThe graph has no cycles.\n\n", "outputFormat": "\n\nThe first line of the output file should contain $n$ integers -- the lexicographically minimal topological sort of the modified graph. The second line should contain a single integer $x (0 \\le x \\le k)$ -- the number of directed edges to add. The following $x$ lines of the output should contain description of added directed edges in the same format as in the input file.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Graph", "background": "", "description": "\n\nThe sequence $a_{1}, a_{2},$ . . . , $a_{n}$ is called a permutation, if it contains every integer from $1$ to $n$ .\n\nThe permutation of vertices $a_{1}, a_{2},$ . . . , $a_{n}$ is a topological sort of a directed graph, if for every directed edge from $u$ to $v$ , vertex $u$ comes before $v$ in this permutation.\n\nThe permutation $a_{1}, a_{2},$ . . . , $a_{n}$ is lexicographically smaller than the permutation $b_{1}, b_{2},$ . . . , $b_{n},$ if there exists $m$ such that $a_{i} = b_{i}$ for every $1 \\le i < m$ and $a_{m} < b_{m}.$\n\nGiven a directed acyclic graph, add at most $k$ directed edges to it in such a way, that the resulting graph still has no cycles and the lexicographically minimal topological sort of the graph is maximum possible.\n\n", "inputFormat": "\n\nThe first line of the input file contains three integers $n , m$ and $k$ -- the number of vertices and directed edges in the original graph, and the number of directed edges, that you are allowed to add $(1 \\le n \\le 100 000$ ; $0 \\le m , k \\le 100 000)$ .\n\nEach of the following $m$ lines contains two integers $u_{i}, v_{i},$ describing directed edge from $u_{i}$ to $v_{i} (1 \\le u_{i}, v_{i} \\le n)$ .\n\nThe graph has no cycles.\n\n", "outputFormat": "\n\nThe first line of the output file should contain $n$ integers -- the lexicographically minimal topological sort of the modified graph. The second line should contain a single integer $x (0 \\le x \\le k)$ -- the number of directed edges to add. The following $x$ lines of the output should contain description of added directed edges in the same format as in the input file.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Graph", "background": "", "description": "序列 $a_{1}, a_{2}, \\ldots, a_{n}$ 被称为一个排列，如果它包含从 $1$ 到 $n$ 的每一个整数。\n\n如果顶点的排列 $a_{1}, a_{2}, \\ldots, a_{n}$ 是一个有向图的拓扑排序，那么对于每一条从 $u$ 到 $v$ 的有向边，顶点 $u$ 在这个排列中出现在 $v$ 之前。\n\n排列 $a_{1}, a_{2}, \\ldots, a_{n}$ 在字典序上小于排列 $b_{1}, b_{2}, \\ldots, b_{n}$，如果存在某个 $m$ 使得对于每一个 $1 \\le i < m$，都有 $a_{i} = b_{i}$，并且 $a_{m} < b_{m}$。\n\n给定一个有向无环图，最多添加 $k$ 条有向边，使得结果图仍然没有环，并且图的字典序最小的拓扑排序尽可能大。", "inputFormat": "输入文件的第一行包含三个整数 $n, m$ 和 $k$ —— 原始图中的顶点数和有向边数，以及允许添加的有向边数 $(1 \\le n \\le 100 000; 0 \\le m, k \\le 100 000)$。\n\n接下来的 $m$ 行中的每一行包含两个整数 $u_{i}, v_{i}$，描述从 $u_{i}$ 到 $v_{i}$ 的有向边 $(1 \\le u_{i}, v_{i} \\le n)$。\n\n图中没有环。", "outputFormat": "输出文件的第一行应包含 $n$ 个整数 —— 修改后的图的字典序最小的拓扑排序。第二行应包含一个整数 $x (0 \\le x \\le k)$ —— 添加的有向边的数量。接下来的 $x$ 行应包含添加的有向边的描述，格式与输入文件相同。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7055", "type": "P", "difficulty": 2, "samples": [["4\n", "edHs\nmENAGeS\nfEHs\nedIT\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["字符串", "2015", "Special Judge", "哈希 hashing", "构造", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Hash Code Hacker", "background": "", "description": "\n\nAccording to Java standard library documentation, the hash code of String is computed as\n\n$s[0] \\times 31 ^ {n -1} + s[1] \\times 31 ^ {n -2} + \\cdots + s[n -1]$\n\nHere $s[i]$ is the i-th character of the string, $n$ is the length of the string, and $^$ indicates exponentiation. Computation uses signed $32-bit$ integers in two's complement form.\n\nHeather is going to hack the servers of Not Entirely Evil Recording Company $(NEERC).$ To perform an attack she needs $k$ distinct query strings that have equal hash codes. Unfortunately, NEERC servers accept query string containing lower- and uppercase English letters only.\n\nHeather hired you to write a program that generates such query strings for her.\n\n", "inputFormat": "\n\nThe single line of the input file contains integer $k$ -- the number of required query strings to generate $(2 \\le k \\le 1000)$ .\n\n", "outputFormat": "\n\nOutput $k$ lines. Each line should contain a single query string. Each query string should be non-empty and its length should not exceed $1000$ characters. Query string should contain only lower- and uppercase English letters. All query strings should be distinct and should have equal hash codes.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Hash Code Hacker", "background": "", "description": "\n\nAccording to Java standard library documentation, the hash code of String is computed as\n\n$s[0] \\times 31 ^ {n -1} + s[1] \\times 31 ^ {n -2} + \\cdots + s[n -1]$\n\nHere $s[i]$ is the i-th character of the string, $n$ is the length of the string, and $^$ indicates exponentiation. Computation uses signed $32-bit$ integers in two's complement form.\n\nHeather is going to hack the servers of Not Entirely Evil Recording Company $(NEERC).$ To perform an attack she needs $k$ distinct query strings that have equal hash codes. Unfortunately, NEERC servers accept query string containing lower- and uppercase English letters only.\n\nHeather hired you to write a program that generates such query strings for her.\n\n", "inputFormat": "\n\nThe single line of the input file contains integer $k$ -- the number of required query strings to generate $(2 \\le k \\le 1000)$ .\n\n", "outputFormat": "\n\nOutput $k$ lines. Each line should contain a single query string. Each query string should be non-empty and its length should not exceed $1000$ characters. Query string should contain only lower- and uppercase English letters. All query strings should be distinct and should have equal hash codes.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Hash Code Hacker", "background": null, "description": "根据 Java 标准库文档，字符串的哈希码计算如下：\n\n$$s[0] \\times 31 ^ {n -1} + s[1] \\times 31 ^ {n -2} + \\cdots + s[n -1]$$\n\n其中 $s[i]$ 是字符串的第 $i$ 个字符，$n$ 是字符串的长度，`^` 表示指数运算。计算使用的是二进制补码形式的有符号 $32$ 位整数。\n\nHeather 准备入侵 Not Entirely Evil Recording Company (NEERC) 的服务器。为了进行攻击，她需要 $k$ 个具有相同哈希码的不同查询字符串。不幸的是，NEERC 服务器只接受包含大小写英文字符的查询字符串。\n\nHeather 雇佣你编写一个程序，为她生成这样的查询字符串。", "inputFormat": "输入文件的单行包含整数 $k$ —— 需要生成的查询字符串数量 $(2 \\le k \\le 1000)$。", "outputFormat": "输出 $k$ 行。每行应包含一个查询字符串。每个查询字符串应为非空，且长度不超过 $1000$ 个字符。查询字符串应仅包含大小写英文字符。所有查询字符串应不同且具有相同的哈希码。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7056", "type": "P", "difficulty": 7, "samples": [["4 3\n1 2 3\n1 2 3\n1 4 3\n", "4 3 2 1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Insider's Information", "background": "", "description": "\n\nIan works for a rating agency that publishes ratings of the best universities. Irene is a journalist who plans to write a scandalous article about the upcoming rating.\n\nUsing various social engineering techniques (let's not get into more details), Irene received some insider's information from Ian.\n\nSpecifically, Irene received several triples $(a_{i}, b_{i}, c_{i}),$ meaning that in the upcoming rating, university $b_{i}$ stands between universities $a_{i}$ and $c_{i}.$ That is, either $a_{i}$ comes before $b_{i}$ which comes before $c_{i},$ or the opposite. All triples told by Ian are consistent -- let's say that actual rating satisfies them all.\n\nTo start working on the first draft of the future article, Irene needs to see at least some approximation to the actual rating. She asked you to find a proposal of a rating in which at least half of the triples known by Irene are satisfied.\n\n", "inputFormat": "\n\nThe first line contains integers $n$ and $m$ , the number of rated universities, and the number of triples given to Irene by Ian $(3 \\le n \\le 100 000$ ; $1 \\le m \\le 100 000)$ .\n\nEach of the next $m$ lines contains three distinct integers $a_{i}, b_{i}, c_{i}$ -- the universities making a triple $(1 \\le a_{i}, b_{i}, c_{i} \\le n)$ .\n\n", "outputFormat": "\n\nOutput the proposal of a rating from the first university to the last one. The proposal rating should satisfy at least $m/2$ triples. If there are many such proposals, output any one of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Insider's Information", "background": "", "description": "\n\nIan works for a rating agency that publishes ratings of the best universities. Irene is a journalist who plans to write a scandalous article about the upcoming rating.\n\nUsing various social engineering techniques (let's not get into more details), Irene received some insider's information from Ian.\n\nSpecifically, Irene received several triples $(a_{i}, b_{i}, c_{i}),$ meaning that in the upcoming rating, university $b_{i}$ stands between universities $a_{i}$ and $c_{i}.$ That is, either $a_{i}$ comes before $b_{i}$ which comes before $c_{i},$ or the opposite. All triples told by Ian are consistent -- let's say that actual rating satisfies them all.\n\nTo start working on the first draft of the future article, Irene needs to see at least some approximation to the actual rating. She asked you to find a proposal of a rating in which at least half of the triples known by Irene are satisfied.\n\n", "inputFormat": "\n\nThe first line contains integers $n$ and $m$ , the number of rated universities, and the number of triples given to Irene by Ian $(3 \\le n \\le 100 000$ ; $1 \\le m \\le 100 000)$ .\n\nEach of the next $m$ lines contains three distinct integers $a_{i}, b_{i}, c_{i}$ -- the universities making a triple $(1 \\le a_{i}, b_{i}, c_{i} \\le n)$ .\n\n", "outputFormat": "\n\nOutput the proposal of a rating from the first university to the last one. The proposal rating should satisfy at least $m/2$ triples. If there are many such proposals, output any one of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Insider's Information", "background": "", "description": "伊恩在一家评级机构工作，该机构发布最佳大学的评级。艾琳是一名记者，计划撰写一篇关于即将发布的评级的轰动性文章。\n\n通过各种社会工程技术（我们不深入细节），艾琳从伊恩那里获得了一些内部信息。\n\n具体来说，艾琳收到了几个三元组 $(a_{i}, b_{i}, c_{i})$，这意味着在即将发布的评级中，大学 $b_{i}$ 位于大学 $a_{i}$ 和 $c_{i}$ 之间。也就是说，要么 $a_{i}$ 在 $b_{i}$ 之前，$b_{i}$ 在 $c_{i}$ 之前，要么相反。伊恩提供的所有三元组都是一致的——假设实际评级满足它们。\n\n为了开始撰写未来文章的初稿，艾琳需要看到至少某种对实际评级的近似。她要求你找到一个评级提案，其中至少有一半的艾琳已知的三元组得到满足。", "inputFormat": "第一行包含整数 $n$ 和 $m$，分别表示被评级的大学数量和伊恩给艾琳的三元组数量 $(3 \\le n \\le 100 000$；$1 \\le m \\le 100 000)$。\n\n接下来的 $m$ 行中的每一行包含三个不同的整数 $a_{i}, b_{i}, c_{i}$——构成一个三元组的大学 $(1 \\le a_{i}, b_{i}, c_{i} \\le n)$。", "outputFormat": "输出从第一所大学到最后一所大学的评级提案。该提案评级应满足至少 $m/2$ 个三元组。如果有多个这样的提案，输出其中任意一个。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7057", "type": "P", "difficulty": 4, "samples": [["4 4\n1 2 3\n1 4\n", "2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2015", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Journey to the “The World’s Start”", "background": "", "description": "\n\nJerry Prince is the fourth grade student and he goes to New-Lodnon to visit the most popular amusement park `The World's Start`.\n\nAn airport he arrives at is next to the first stop of the metro line. This line has $n$ stops and `The World's Start` is on the last of them. The metro of New-Lodnon is pretty fast so you may assume that you can get from a stop to the next one in just one minute.\n\nJerry needs a travel card to use the metro. Each travel card has a range $r$ and a price $p$ . With a travel card of range $r$ Jerry may travel no more than $r$ stops at once. Therefore, if Jerry enters metro at the stop $i$ he should exit on one of the stops from $i − r$ to $i + r$ inclusive. It takes $d_{i}$ minutes to exit and reenter metro at i-th stop. There is no time required to enter the first stop or exit the last one.\n\nJerry is not very rich but he has some spare time, so he decided to buy the cheapest travel card that will allow him to travel from the first metro stop to the last one in no more than $t$ minutes.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $t$ -- the number of stops and the maximum possible time $(2 \\le n \\le 50 000$ ; $n - 1 \\le t \\le 10^{9}).$\n\nThe second line contains $n - 1$ integers $p_{r}$ -- the prices of travel cards with range $r = 1$ . . . $n − 1 (1 \\le p_{r} \\le 100 000)$\n\nThe third line contains $n - 2$ integers $d_{i}$ -- the number of minutes required to reenter metro at stop $i = 2$ . . . $n - 1 (1 \\le d_{i} \\le 10^{5}).$\n\n", "outputFormat": "\n\nOutput a single integer $p$ -- the lowest possible price of one travel card that allows Jerry to travel from the first to the last stop in no more than $t$ minutes.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Journey to the “The World’s Start”", "background": "", "description": "\n\nJerry Prince is the fourth grade student and he goes to New-Lodnon to visit the most popular amusement park `The World's Start`.\n\nAn airport he arrives at is next to the first stop of the metro line. This line has $n$ stops and `The World's Start` is on the last of them. The metro of New-Lodnon is pretty fast so you may assume that you can get from a stop to the next one in just one minute.\n\nJerry needs a travel card to use the metro. Each travel card has a range $r$ and a price $p$ . With a travel card of range $r$ Jerry may travel no more than $r$ stops at once. Therefore, if Jerry enters metro at the stop $i$ he should exit on one of the stops from $i − r$ to $i + r$ inclusive. It takes $d_{i}$ minutes to exit and reenter metro at i-th stop. There is no time required to enter the first stop or exit the last one.\n\nJerry is not very rich but he has some spare time, so he decided to buy the cheapest travel card that will allow him to travel from the first metro stop to the last one in no more than $t$ minutes.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $t$ -- the number of stops and the maximum possible time $(2 \\le n \\le 50 000$ ; $n - 1 \\le t \\le 10^{9}).$\n\nThe second line contains $n - 1$ integers $p_{r}$ -- the prices of travel cards with range $r = 1$ . . . $n − 1 (1 \\le p_{r} \\le 100 000)$\n\nThe third line contains $n - 2$ integers $d_{i}$ -- the number of minutes required to reenter metro at stop $i = 2$ . . . $n - 1 (1 \\le d_{i} \\le 10^{5}).$\n\n", "outputFormat": "\n\nOutput a single integer $p$ -- the lowest possible price of one travel card that allows Jerry to travel from the first to the last stop in no more than $t$ minutes.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Journey to the “The World’s Start”", "background": null, "description": "Jerry Prince 是一名四年级学生，他去 New-Lodnon 参观最受欢迎的游乐园 \"The World's Start\"。\n\n他到达的机场就在地铁线的第一站旁边。这条地铁线有 $n$ 个站点，\"The World's Start\" 位于最后一个站点。New-Lodnon 的地铁非常快，所以你可以假设从一个站到下一个站只需要一分钟。\n\nJerry 需要一张地铁通行卡才能使用地铁。每张通行卡都有一个范围 $r$ 和一个价格 $p$。使用范围为 $r$ 的通行卡，Jerry 一次最多可以旅行 $r$ 个站。因此，如果 Jerry 在第 $i$ 个站进入地铁，他应该在从 $i - r$ 到 $i + r$ 的某个站点下车。需要 $d_{i}$ 分钟才能在第 $i$ 个站点下车并重新进入地铁。在第一站进入或最后一站下车不需要时间。\n\nJerry 不是很富有，但他有一些空闲时间，所以他决定购买最便宜的通行卡，使他能够在不超过 $t$ 分钟的时间内从第一站旅行到最后一站。", "inputFormat": "输入文件的第一行包含两个整数 $n$ 和 $t$ —— 站点的数量和最大可能的时间 $(2 \\le n \\le 50 000$ ; $n - 1 \\le t \\le 10^{9})$。\n\n第二行包含 $n - 1$ 个整数 $p_{r}$ —— 范围为 $r = 1$ 到 $n - 1$ 的通行卡的价格 $(1 \\le p_{r} \\le 100 000)$。\n\n第三行包含 $n - 2$ 个整数 $d_{i}$ —— 在第 $i = 2$ 到 $n - 1$ 站点重新进入地铁所需的分钟数 $(1 \\le d_{i} \\le 10^{5})$。", "outputFormat": "输出一个整数 $p$ —— 允许 Jerry 在不超过 $t$ 分钟内从第一站到最后一站的最便宜的通行卡的价格。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7058", "type": "P", "difficulty": 7, "samples": [["5 2\n2 6\n8 2\n14 2\n12 9\n13 8\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Kingdom Trip", "background": "", "description": "\n\nOnce upon a time, there was a kingdom ruled by a wise king. After forty three years of his reign, by means of successful military actions and skillful diplomacy, the kingdom became an infinite flat two-dimensional surface. This form of the kingdom greatly simplified travelling, as there were no borders.\n\nA big holiday was planned in the kingdom. There were $n$ locations for people to gather. As the king wanted to have a closer look at his people, he ordered to make a trip through these locations. He wanted to give a speech in each of these locations. Initially his trip was designed as a polygonal chain $p$ : $p_{1} \\to p_{2} \\to $ . . . $ \\to p_{n}.$\n\nNot only the king was wise, but he was old, too. Therefore, his assistants came up with an idea to skip some locations, to make the king to give as few speeches as possible. The new plan of the trip has to be a polygonal chain consisting of some subsequence of $p$ : starting at $p_{1}$ and ending at $p_{n},$ formally, $p_{i_{1}} \\to p_{i_{2}} \\to · · · \\to p_{i_{m}},$ where $1 = i_{1} < i_{2} < · · · < i_{m} = n$ . Assistants know that the king wouldn't allow to skip location $j$ , if the distance from $p_{j}$ to segment $p_{i_{k}} \\to p_{i_{k+1}}$ exceeds $d$ , for such $k$ , that $i_{k} < j < i_{k+1}.$\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11476/1.png)\n\nOriginal route\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11476/2.png)\n\nNew route\n\nHelp the assistants to find the new route that contains the minimum possible number of locations.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $d$ -- the number of locations in the initial plan of the trip and the maximum allowed distance to skipped locations $(2 \\le n \\le 2000$ ; $1 \\le d \\le 10^{6}).$\n\nThe following $n$ lines describe the trip. The i-th of these lines contains two integers $x_{i}$ and $y_{i}$ -- coordinates of point $p_{i}.$ The absolute value of coordinates does not exceed $10^{6}.$ No two points coincide.\n\n", "outputFormat": "\n\nOutput the minimum number of locations the king will visit. It is guaranteed that the answer is the same for $d ± 10^{−4}.$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Kingdom Trip", "background": "", "description": "\n\nOnce upon a time, there was a kingdom ruled by a wise king. After forty three years of his reign, by means of successful military actions and skillful diplomacy, the kingdom became an infinite flat two-dimensional surface. This form of the kingdom greatly simplified travelling, as there were no borders.\n\nA big holiday was planned in the kingdom. There were $n$ locations for people to gather. As the king wanted to have a closer look at his people, he ordered to make a trip through these locations. He wanted to give a speech in each of these locations. Initially his trip was designed as a polygonal chain $p$ : $p_{1} \\to p_{2} \\to $ . . . $ \\to p_{n}.$\n\nNot only the king was wise, but he was old, too. Therefore, his assistants came up with an idea to skip some locations, to make the king to give as few speeches as possible. The new plan of the trip has to be a polygonal chain consisting of some subsequence of $p$ : starting at $p_{1}$ and ending at $p_{n},$ formally, $p_{i_{1}} \\to p_{i_{2}} \\to · · · \\to p_{i_{m}},$ where $1 = i_{1} < i_{2} < · · · < i_{m} = n$ . Assistants know that the king wouldn't allow to skip location $j$ , if the distance from $p_{j}$ to segment $p_{i_{k}} \\to p_{i_{k+1}}$ exceeds $d$ , for such $k$ , that $i_{k} < j < i_{k+1}.$\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11476/1.png)\n\nOriginal route\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11476/2.png)\n\nNew route\n\nHelp the assistants to find the new route that contains the minimum possible number of locations.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $d$ -- the number of locations in the initial plan of the trip and the maximum allowed distance to skipped locations $(2 \\le n \\le 2000$ ; $1 \\le d \\le 10^{6}).$\n\nThe following $n$ lines describe the trip. The i-th of these lines contains two integers $x_{i}$ and $y_{i}$ -- coordinates of point $p_{i}.$ The absolute value of coordinates does not exceed $10^{6}.$ No two points coincide.\n\n", "outputFormat": "\n\nOutput the minimum number of locations the king will visit. It is guaranteed that the answer is the same for $d ± 10^{−4}.$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Kingdom Trip", "background": "", "description": "从前有一个王国，由一位聪明的国王统治。在他统治的四十三年间，通过成功的军事行动和娴熟的外交手段，王国变成了一个无限平坦的二维平面。这样的形式极大地简化了旅行，因为没有边界。\n\n王国计划举办一个盛大的节日。有 $n$ 个地点供人们聚集。国王希望能更近距离地观察他的子民，因此他下令在这些地点之间进行旅行。他希望在每个地点发表演讲。最初，他的旅行被设计为一个多边形链 $p$：$p_{1} \\to p_{2} \\to \\ldots \\to p_{n}$。\n\n国王不仅聪明，而且年事已高。因此，他的助手们想出了一个主意，跳过一些地点，以便让国王尽可能少地发表演讲。新的旅行计划必须是由 $p$ 的某个子序列组成的多边形链：从 $p_{1}$ 开始，到 $p_{n}$ 结束，形式上为 $p_{i_{1}} \\to p_{i_{2}} \\to \\cdots \\to p_{i_{m}}$，其中 $1 = i_{1} < i_{2} < \\cdots < i_{m} = n$。助手们知道，如果从 $p_{j}$ 到线段 $p_{i_{k}} \\to p_{i_{k+1}}$ 的距离超过 $d$，对于这样的 $k$，即 $i_{k} < j < i_{k+1}$，国王不会允许跳过地点 $j$。\n\n帮助助手们找到包含最少可能地点的新路线。", "inputFormat": "输入文件的第一行包含两个整数 $n$ 和 $d$——旅行初始计划中的地点数和允许跳过地点的最大距离 $(2 \\le n \\le 2000$；$1 \\le d \\le 10^{6})$。\n\n接下来的 $n$ 行描述了旅行。第 $i$ 行包含两个整数 $x_{i}$ 和 $y_{i}$——点 $p_{i}$ 的坐标。坐标的绝对值不超过 $10^{6}$。没有两个点重合。", "outputFormat": "输出国王将访问的最少地点数。保证对于 $d \\pm 10^{-4}$，答案是相同的。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7059", "type": "P", "difficulty": 2, "samples": [["3 4\n5 3 9 10\n1 8 8 2\n4 3 4 3\n", "25\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Lucky Chances", "background": "", "description": "\n\nLucky Chances is a lottery game. Each lottery ticket has a play field and a scratch area. The play field is a rectangular $r \\times c$ field filled with numbers. The scratch area hides row and column numbers that specify the bet cell.\n\nThere are four possible winning directions: up, down, left and right. You win a direction if all numbers in this direction from the bet cell are strictly less than a number in the bet cell. And if the bet cell is on the edge of the grid, you win the corresponding direction automatically!\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11477/1.png)\n\nUnscratched ticket\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11477/2.png)\n\nScratched ticket $1$\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11477/3.png)\n\nScratched ticket $2$\n\nLarry wants to choose the ticket that has maximum total number of winning directions for all possible bet cells. Write a program that determines this number for the given grid.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $r$ and $c$ -- the number of rows and columns in the grid $(1 \\le r , c \\le 100)$ .\n\nThe following $r$ lines contain $c$ integers each -- the numbers printed on the grid. Each number is positive and does not exceed $1000$ .\n\n", "outputFormat": "\n\nOutput a single integer $w$ -- the total number of winning directions for the given grid.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Lucky Chances", "background": "", "description": "\n\nLucky Chances is a lottery game. Each lottery ticket has a play field and a scratch area. The play field is a rectangular $r \\times c$ field filled with numbers. The scratch area hides row and column numbers that specify the bet cell.\n\nThere are four possible winning directions: up, down, left and right. You win a direction if all numbers in this direction from the bet cell are strictly less than a number in the bet cell. And if the bet cell is on the edge of the grid, you win the corresponding direction automatically!\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11477/1.png)\n\nUnscratched ticket\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11477/2.png)\n\nScratched ticket $1$\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11477/3.png)\n\nScratched ticket $2$\n\nLarry wants to choose the ticket that has maximum total number of winning directions for all possible bet cells. Write a program that determines this number for the given grid.\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $r$ and $c$ -- the number of rows and columns in the grid $(1 \\le r , c \\le 100)$ .\n\nThe following $r$ lines contain $c$ integers each -- the numbers printed on the grid. Each number is positive and does not exceed $1000$ .\n\n", "outputFormat": "\n\nOutput a single integer $w$ -- the total number of winning directions for the given grid.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Lucky Chances", "background": "", "description": "幸运机会是一种彩票游戏。每张彩票都有一个游戏区域和一个刮刮区。游戏区域是一个 $r \\times c$ 的矩形区域，填满了数字。刮刮区隐藏了指定投注单元格的行号和列号。\n\n有四种可能的获胜方向：上、下、左和右。如果从投注单元格开始的某个方向上的所有数字都严格小于投注单元格中的数字，那么你就赢得了这个方向。如果投注单元格位于网格的边缘，你将自动赢得相应的方向！\n\n未刮开的票\n\n刮开的票 1\n\n刮开的票 2\n\n拉里想选择一张在所有可能的投注单元格中获胜方向总数最多的票。编写一个程序来确定给定网格的这个数字。", "inputFormat": "输入文件的第一行包含两个整数 $r$ 和 $c$ —— 网格中的行数和列数 $(1 \\le r , c \\le 100)$。\n\n接下来的 $r$ 行每行包含 $c$ 个整数 —— 网格上打印的数字。每个数字都是正数且不超过 $1000$。", "outputFormat": "输出一个整数 $w$ —— 给定网格的获胜方向总数。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7060", "type": "P", "difficulty": 2, "samples": [["23\n", "09:30\n"], ["28\n", "Impossible\n"], ["2\n", "Impossible\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Alarm Clock", "background": "", "description": "\n\nAlice likes her digital alarm clock. She sets them up every evening. Last night Alice had a dream about her clock. Unfortunately, the only thing she is able to remember is the number of highlighted segments of the clock. Alice wonders what time was set on the clock in her dream.\n\nAlice's clock have four digits: two for hours and two for minutes. For example, the clock below shows $9:30$ (note the leading zero).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6dl4fhwk.png)\n\nThe clock uses following digit representation.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/igdzsez5.png)\n\n", "inputFormat": "\n\nThe only line of the input file contains single integer $n$ — the number of highlighted segments of the clock in Alice's dream $(0 \\le n \\le 30)$ .\n\n", "outputFormat": "\n\nOutput five characters in $\\text{hh:mm}$ format — the time shown on the clock in Alice's dream. The time must be correct: $0 \\le \\text{hh} < 24$ and $0 \\le \\text{mm} < 60$ . If there are many possible correct times, output any of them. If there is none, output `Impossible`.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\nspj provider: @[rzh123](user/237530)", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Alarm Clock", "background": "", "description": "\n\nAlice likes her digital alarm clock. She sets them up every evening. Last night Alice had a dream about her clock. Unfortunately, the only thing she is able to remember is the number of highlighted segments of the clock. Alice wonders what time was set on the clock in her dream.\n\nAlice's clock have four digits: two for hours and two for minutes. For example, the clock below shows $9:30$ (note the leading zero).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6dl4fhwk.png)\n\nThe clock uses following digit representation.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/igdzsez5.png)\n\n", "inputFormat": "\n\nThe only line of the input file contains single integer $n$ — the number of highlighted segments of the clock in Alice's dream $(0 \\le n \\le 30)$ .\n\n", "outputFormat": "\n\nOutput five characters in $\\text{hh:mm}$ format — the time shown on the clock in Alice's dream. The time must be correct: $0 \\le \\text{hh} < 24$ and $0 \\le \\text{mm} < 60$ . If there are many possible correct times, output any of them. If there is none, output `Impossible`.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\nspj provider: @[rzh123](user/237530)", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Alarm Clock", "background": "", "description": "Alice 喜欢她的数字闹钟。她每天晚上都会设置好闹钟。昨晚 Alice 做了一个关于她闹钟的梦。不幸的是，她唯一能记得的是闹钟上高亮显示的段数。Alice 想知道她梦中闹钟上设置的时间。\n\nAlice 的闹钟有四位数字：两个表示小时，两个表示分钟。例如，下面的闹钟显示的是 $9:30$（注意前导零）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6dl4fhwk.png)\n\n闹钟使用以下数字表示法。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/igdzsez5.png)", "inputFormat": "输入文件的唯一一行包含一个整数 $n$ — Alice 梦中闹钟上高亮显示的段数 $(0 \\le n \\le 30)$。", "outputFormat": "输出五个字符，格式为 $\\\\text{hh:mm}$ — Alice 梦中闹钟上显示的时间。时间必须是正确的：$0 \\le \\\\text{hh} < 24$ 且 $0 \\le \\\\text{mm} < 60$。如果有多个可能的正确时间，输出其中任何一个。如果没有，输出 `Impossible`。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\nspj 提供者：@[rzh123](user/237530)\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7061", "type": "P", "difficulty": 0, "samples": [["70 3 2 2\n40 30\n50 40\n", "2 1\n2 1\n1\n"], ["1 2 3 4\n6 6 5\n8 10 7 9\n", "2 0\n1 2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Buffcraft", "background": "", "description": "\n\nBrenda enjoys a new role-playing game Buffcraft. Shields, swords, books and other carry-on items do not affects character stats in Buffcraft. The only way to increase the stats of your character is to buff her.\n\nThere are two types of buffs in Buffcraft. Direct buffs increase a base value of the stat, while percentage buffs increase stats by the fraction of the base value. To be precise, if unbuffed base value of your character stat is $b$ , you have buffed her using $n$ direct buffs of strength $d_1 , d_2 , \\cdots d_n$ and $m$ percentage buffs of strength $p_{1}, p_{2}, \\cdots , p_{m},$ the resulting stat will be equal to $(b + d_{1} + d_{2} + · · · + d_{n})(100 + p_{1} + p_{2} + · · · + p_{m})/100$ . Note that the resulting stat may be fractional.\n\nUnfortunately, your character has only $k$ buff slots and if you apply more than $k$ buffs on her, only the last $k$ buffs remains active. Thus, there is no reason to apply more than $k$ buffs simultaneously. You cannot apply the same buff more than once.\n\nBrenda is going to send his character to raid and wants to buff her health to maximal possible value. She has some direct and some percentage buffs at her disposal and needs your help to select the set of buffs that leads to maximal possible total health.\n\n", "inputFormat": "\n\nThe first line of the input file contains four integers $b , k , c_{d}$ and $c_{p}$ — the base health of the character, the number of buff slots, the number of available directs buffs, and the number of available percentage buffs.\n\nThe following line contains $c_{d}$ integers $d_{i}$ — strengths of direct buffs.\n\nThe last line of the input file contains $c_{p}$ integer numbers $p_{i}$ — strengths of percentage buffs.\n\nAll numbers in the input file are greater than or equal to zero, and less than or equal to fifty thousand.\n\n", "outputFormat": "\n\nThe first line of the output file must contain two integers $n$ and $m$ — the number of direct and percentage buffs to use $(0 \\le n \\le c_{d}; 0 \\le m \\le c_{p}; 0 \\le n + m \\le k)$ .\n\nThe following line must contain $n$ different numbers — indices of direct buffs to apply (buffs are numbered from one).\n\nThe last line of the output must contain $m$ different numbers — indices of percentage buffs to apply (also numbered from one).\n\nThe resulting total health after application of all $n + m$ buffs must be maximal possible.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Buffcraft", "background": "", "description": "\n\nBrenda enjoys a new role-playing game Buffcraft. Shields, swords, books and other carry-on items do not affects character stats in Buffcraft. The only way to increase the stats of your character is to buff her.\n\nThere are two types of buffs in Buffcraft. Direct buffs increase a base value of the stat, while percentage buffs increase stats by the fraction of the base value. To be precise, if unbuffed base value of your character stat is $b$ , you have buffed her using $n$ direct buffs of strength $d_1 , d_2 , \\cdots d_n$ and $m$ percentage buffs of strength $p_{1}, p_{2}, \\cdots , p_{m},$ the resulting stat will be equal to $(b + d_{1} + d_{2} + · · · + d_{n})(100 + p_{1} + p_{2} + · · · + p_{m})/100$ . Note that the resulting stat may be fractional.\n\nUnfortunately, your character has only $k$ buff slots and if you apply more than $k$ buffs on her, only the last $k$ buffs remains active. Thus, there is no reason to apply more than $k$ buffs simultaneously. You cannot apply the same buff more than once.\n\nBrenda is going to send his character to raid and wants to buff her health to maximal possible value. She has some direct and some percentage buffs at her disposal and needs your help to select the set of buffs that leads to maximal possible total health.\n\n", "inputFormat": "\n\nThe first line of the input file contains four integers $b , k , c_{d}$ and $c_{p}$ — the base health of the character, the number of buff slots, the number of available directs buffs, and the number of available percentage buffs.\n\nThe following line contains $c_{d}$ integers $d_{i}$ — strengths of direct buffs.\n\nThe last line of the input file contains $c_{p}$ integer numbers $p_{i}$ — strengths of percentage buffs.\n\nAll numbers in the input file are greater than or equal to zero, and less than or equal to fifty thousand.\n\n", "outputFormat": "\n\nThe first line of the output file must contain two integers $n$ and $m$ — the number of direct and percentage buffs to use $(0 \\le n \\le c_{d}; 0 \\le m \\le c_{p}; 0 \\le n + m \\le k)$ .\n\nThe following line must contain $n$ different numbers — indices of direct buffs to apply (buffs are numbered from one).\n\nThe last line of the output must contain $m$ different numbers — indices of percentage buffs to apply (also numbered from one).\n\nThe resulting total health after application of all $n + m$ buffs must be maximal possible.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Buffcraft", "background": "", "description": "Brenda喜欢一款新的游戏Buffcraft。没有任何物品可以影响Buffcraft中的角色属性。增加你角色属性的唯一方法就是给予它buff。\n\nBuffcraft中有两种类型的buff。  \n1.直接增加buff的值;  \n2.百分比增加buff的值;  \n如果你的角色buff初始值是$b$，那么你使用$n$个增益分别为$d_1,d_2,\\cdots,d_n$的第一种buff和$m$个增益分别为$p_{1},p_{2}\\cdots,p_{m}$的第二种buff，得到的结果将等于$(b+d_{1}+d_{2}+··+d_{n})(100+p_{1}+p_{2}-··+p_{m})/100$。请注意，这个结果可能不是整数。\n\n不幸的是，你的角色只有$k$个buff槽，如果你在她身上应用了$k$个以上的buff，那么只有最后的$k$个buff有效。因此，你不能同时拥有$k$个以上buff。当然，一个buff不能被多次使用。\n\nBrenda将派她的角色去战斗，并希望将角色的buff值提升到最大。有一些第一种buff和一些第二种buff可供她使用。她需要你的帮助来选择一种buff的搭配方式，以获得最大可能的总buff值。", "inputFormat": "第一行包含四个整数$b,k,n,m$；分别代表角色的基础buff值、buff槽数、第一种buff的数量与第二种buff的数量。     \n第二行包含$n$个整数$d_{i}$，代表每个第一种buff的增益量。   \n第三行包含$m$个整数$p_{i}$，代表每个第二种buff的增益量。", "outputFormat": "第一行是两个整数$x,y$代表用了多少第一种buff和用了多少第二种buff。$(0 \\le x \\le n; 0 \\le y \\le m; 0 \\le x + y \\le k)$ .\n  \n第二行是$x$个数字-要应用的每一个第一种buff的索引。  \n第二行是$y$个数字-要应用的每一个第二种buff的索引。\n你的方案要让所有buff应用后产生的总buff值尽可能最大。\n\n## 输入输出样例\n\n### 样例输入#1\n```\n70 3 2 2\n40 30\n50 40\n```\n### 样例输出#1\n```\n2 1\n2 1\n1\n```\n### 样例输入#2\n```\n1 2 3 4\n6 6 5\n8 10 7 9\n```\n### 样例输出#2\n```\n2 0\n1 2\n```", "hint": "$0 \\le b,k,n,m,d_{i},p_{i} \\le 50000$  \n数组的索引从1开始  \n时间限制:2s;空间限制:256MB。", "locale": "zh-CN"}}}
{"pid": "P7062", "type": "P", "difficulty": 6, "samples": [["C(K(II)(IC))\n", "2\n"], ["CIBI\n", "3\n"], ["BBBBBCCCCCKKKKKIIIII\n", "15\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Combinator Expression", "background": "", "description": "Combinatory logic may be thought as one of computational models allowing to express any computable function as a composition of functions from a small finite basis. In this problem we consider a restricted variant of BCKW basis, BCKI.\n\nCombinator expression in BCKI basis is a string, corresponding to the following grammar:\n\n```plain\n⟨Expression⟩ ::= ⟨Expression⟩ ⟨Term⟩ | ⟨Term⟩\n⟨Term⟩ ::= ‘(’⟨Expression⟩‘)’ | ‘B’ | ‘C’ | ‘K’ | ‘I’\n```\n\nAs we can see from the grammar, the expression is a tree of applications where leafs are combinators $B, C, K$ and $I$. The application is left-associative. For example $BIC$ is equivalent to $(BI)C,$ but not to $B(IC)$.\n\nFor the sake of the explanation we will use lowercase English letters $(a \\cdots z)$ to represent sub-expressions. These lowercase letters will not appear in real data. For example, $BIC$ can be represented by $BxC$ (that is, $B\\underbrace { I }_{ x }C)$, $x(\\underbrace {BIC}_{ x })$, $xy(\\underbrace {BI}_{ x } \\underbrace { C }_{ y })$, $Bxy (B\\underbrace { I }_{ x }\\underbrace { C }_{ y })$, but not by $Bx$.\n\nWe say that in expression $pq$ we apply $p$ to $q$. We can employ our intuition by saying that $p$ is a function and $q$ is its parameter. However, the evaluation process is quite different from traditional computation — instead of passing values over fixed expression tree, we evaluate by altering that tree so that the result is also some combinator expression.\n\nTo evaluate an expression, we need to select some sub-expression, corresponding to one of the patterns specified in the table below — that is, there should exist such $x$ (and maybe $y$ and $z$) that the pattern from the table becomes equal to the sub-expression. Then we need to replace the sub-expression with the reduction result from the table.\n\n| Pattern | Reduction result |                   Description                   |\n| :-----: | :--------------: | :---------------------------------------------: |\n| $Bxyz$  |     $x(yz)$      | Composition function (Zusammensetzungsfunktion) |\n| $Cxyz$  |     $(xz)y$      |    Exchange function (Vertauschungsfunktion)    |\n|  $Kxy$  |       $x$        |      Constant function (Konstanzfunktion)       |\n|  $Ix$   |       $x$        |     Identity function (Identitätsfunktion)      |\n\nAfter the replacement took place we must repeat the process, until there remains no suitable subexpressions. This final expression is normal form of the original one. For example, in expression $CIC(CB)I$ we can make the following letter assignment\n\n$$\\underbrace { C }_{ C }\\underbrace { I }_{ x }\\underbrace { C }_{ y }\\underbrace {(CB)}_{ z }I$$\n\nand see that $CIC(CB)I ≡ (((CI)C)(CB))I ≡ (((Cx)y)z)I$ contains $C$ combinator pattern and thus reduces to $((xz)y)I ≡ I(CB)CI:$\n\n$$(\\underbrace { C }_{ C }\\underbrace { I }_{ x }\\underbrace { C }_{ y }\\underbrace { (CB) }_{ Z })I \\rightarrow (\\underbrace { I }_{ x } \\underbrace {(CB)}_{ z }\\underbrace { C }_{ y })I$$\n\nOne more example: $B((CK)I)IC$ expression. Let us first reduce combinator $B:$\n\n$$(\\underbrace { B }_{ B }\\underbrace { ((CK)I) }_{ x }\\underbrace { I }_{ y }\\underbrace { C }_{ z } \\rightarrow \\underbrace { ((CK)I) }_{ x } (\\underbrace { I }_{ y }\\underbrace { C }_{ z })$$\n\nNow, let's reduce the last $I:$\n\n$$((CK)I)(\\underbrace { I }_{ I } \\underbrace { C }_{ x }) \\rightarrow ((CK)I)C$$\n\nAnd now we finish evaluation with two more reductions:\n\n$$((\\underbrace { C }_{ C }\\underbrace { K }_{ x }) \\underbrace { I }_{ y }) \\underbrace { C }_{ z } \\rightarrow (\\underbrace { K }_{ K }\\underbrace { C }_{ x }) \\underbrace { I }_{ y } \\rightarrow C$$\n\nIt is possible to show that the normal form remains the same irrespectable to the order of evaluation. For example, the following evaluation order:\n\n$$C(K(II)(\\underbrace { I }_{ I }\\underbrace { C }_{ x })) \\rightarrow C(K(\\underbrace { I }_{ I }\\underbrace {  I}_{ x })(C)) \\rightarrow C((\\underbrace { K }_{ K }\\underbrace { I }_{ x }) \\underbrace { C }_{ y }) \\rightarrow CI$$\n\nleads to the same result as \n\n$$C(K(\\underbrace {I}_{ I }\\underbrace { I }_{ x })(IC)) \\rightarrow C((\\underbrace { K }_{ K }\\underbrace { I }_{ x })\\underbrace { (IC)}_{ y }) \\rightarrow CI$$\n\nHowever, as you see, the number of reductions is different: $3$ in the first case and $2$ in the second. This poses an interesting problem -- to find an evaluation order with the minimal number of reductions for a given formula.\n\nYour task is to write a program which finds the minimal number of reductions required for a given combinator expression to be evaluated to its normal form.", "inputFormat": "\n\nThe only line of the input file contains a combinator expression corresponding to the grammar above. The length of the expression does not exceed $30 000$ . The expression contains no whitespaces or symbols not specified in the grammar.\n\n", "outputFormat": "\n\nOutput a single integer — the minimal number of reductions required for the given formula to evaluate it to normal form.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Combinator Expression", "background": "", "description": "Combinatory logic may be thought as one of computational models allowing to express any computable function as a composition of functions from a small finite basis. In this problem we consider a restricted variant of BCKW basis, BCKI.\n\nCombinator expression in BCKI basis is a string, corresponding to the following grammar:\n\n```plain\n⟨Expression⟩ ::= ⟨Expression⟩ ⟨Term⟩ | ⟨Term⟩\n⟨Term⟩ ::= ‘(’⟨Expression⟩‘)’ | ‘B’ | ‘C’ | ‘K’ | ‘I’\n```\n\nAs we can see from the grammar, the expression is a tree of applications where leafs are combinators $B, C, K$ and $I$. The application is left-associative. For example $BIC$ is equivalent to $(BI)C,$ but not to $B(IC)$.\n\nFor the sake of the explanation we will use lowercase English letters $(a \\cdots z)$ to represent sub-expressions. These lowercase letters will not appear in real data. For example, $BIC$ can be represented by $BxC$ (that is, $B\\underbrace { I }_{ x }C)$, $x(\\underbrace {BIC}_{ x })$, $xy(\\underbrace {BI}_{ x } \\underbrace { C }_{ y })$, $Bxy (B\\underbrace { I }_{ x }\\underbrace { C }_{ y })$, but not by $Bx$.\n\nWe say that in expression $pq$ we apply $p$ to $q$. We can employ our intuition by saying that $p$ is a function and $q$ is its parameter. However, the evaluation process is quite different from traditional computation — instead of passing values over fixed expression tree, we evaluate by altering that tree so that the result is also some combinator expression.\n\nTo evaluate an expression, we need to select some sub-expression, corresponding to one of the patterns specified in the table below — that is, there should exist such $x$ (and maybe $y$ and $z$) that the pattern from the table becomes equal to the sub-expression. Then we need to replace the sub-expression with the reduction result from the table.\n\n| Pattern | Reduction result |                   Description                   |\n| :-----: | :--------------: | :---------------------------------------------: |\n| $Bxyz$  |     $x(yz)$      | Composition function (Zusammensetzungsfunktion) |\n| $Cxyz$  |     $(xz)y$      |    Exchange function (Vertauschungsfunktion)    |\n|  $Kxy$  |       $x$        |      Constant function (Konstanzfunktion)       |\n|  $Ix$   |       $x$        |     Identity function (Identitätsfunktion)      |\n\nAfter the replacement took place we must repeat the process, until there remains no suitable subexpressions. This final expression is normal form of the original one. For example, in expression $CIC(CB)I$ we can make the following letter assignment\n\n$$\\underbrace { C }_{ C }\\underbrace { I }_{ x }\\underbrace { C }_{ y }\\underbrace {(CB)}_{ z }I$$\n\nand see that $CIC(CB)I ≡ (((CI)C)(CB))I ≡ (((Cx)y)z)I$ contains $C$ combinator pattern and thus reduces to $((xz)y)I ≡ I(CB)CI:$\n\n$$(\\underbrace { C }_{ C }\\underbrace { I }_{ x }\\underbrace { C }_{ y }\\underbrace { (CB) }_{ Z })I \\rightarrow (\\underbrace { I }_{ x } \\underbrace {(CB)}_{ z }\\underbrace { C }_{ y })I$$\n\nOne more example: $B((CK)I)IC$ expression. Let us first reduce combinator $B:$\n\n$$(\\underbrace { B }_{ B }\\underbrace { ((CK)I) }_{ x }\\underbrace { I }_{ y }\\underbrace { C }_{ z } \\rightarrow \\underbrace { ((CK)I) }_{ x } (\\underbrace { I }_{ y }\\underbrace { C }_{ z })$$\n\nNow, let's reduce the last $I:$\n\n$$((CK)I)(\\underbrace { I }_{ I } \\underbrace { C }_{ x }) \\rightarrow ((CK)I)C$$\n\nAnd now we finish evaluation with two more reductions:\n\n$$((\\underbrace { C }_{ C }\\underbrace { K }_{ x }) \\underbrace { I }_{ y }) \\underbrace { C }_{ z } \\rightarrow (\\underbrace { K }_{ K }\\underbrace { C }_{ x }) \\underbrace { I }_{ y } \\rightarrow C$$\n\nIt is possible to show that the normal form remains the same irrespectable to the order of evaluation. For example, the following evaluation order:\n\n$$C(K(II)(\\underbrace { I }_{ I }\\underbrace { C }_{ x })) \\rightarrow C(K(\\underbrace { I }_{ I }\\underbrace {  I}_{ x })(C)) \\rightarrow C((\\underbrace { K }_{ K }\\underbrace { I }_{ x }) \\underbrace { C }_{ y }) \\rightarrow CI$$\n\nleads to the same result as \n\n$$C(K(\\underbrace {I}_{ I }\\underbrace { I }_{ x })(IC)) \\rightarrow C((\\underbrace { K }_{ K }\\underbrace { I }_{ x })\\underbrace { (IC)}_{ y }) \\rightarrow CI$$\n\nHowever, as you see, the number of reductions is different: $3$ in the first case and $2$ in the second. This poses an interesting problem -- to find an evaluation order with the minimal number of reductions for a given formula.\n\nYour task is to write a program which finds the minimal number of reductions required for a given combinator expression to be evaluated to its normal form.", "inputFormat": "\n\nThe only line of the input file contains a combinator expression corresponding to the grammar above. The length of the expression does not exceed $30 000$ . The expression contains no whitespaces or symbols not specified in the grammar.\n\n", "outputFormat": "\n\nOutput a single integer — the minimal number of reductions required for the given formula to evaluate it to normal form.\n\n", "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Combinator Expression", "background": "", "description": "## 题目背景\n\n组合逻辑可以看作是一种计算模型，允许将任何可计算函数表示为从小的有限基底中选取的函数的组合。在这个问题中，我们考虑 BCKW 基底的一个受限变体，即 BCKI。\n\nBCKI 基底中的组合表达式是一个字符串，对应于以下文法：\n\n```plain\n⟨表达式⟩ ::= ⟨表达式⟩ ⟨项⟩ | ⟨项⟩\n⟨项⟩ ::= ‘(’⟨表达式⟩‘)’ | ‘B’ | ‘C’ | ‘K’ | ‘I’\n```\n\n从文法可以看出，表达式是应用树，叶子是组合子 $B, C, K$ 和 $I$。应用是左结合的。例如，$BIC$ 等价于 $(BI)C$，但不等价于 $B(IC)$。\n\n为了便于解释，我们将使用小写英文字母 $(a \\cdots z)$ 来表示子表达式。这些小写字母不会出现在实际数据中。例如，$BIC$ 可以表示为 $BxC$（即 $B\\underbrace { I }_{ x }C$），$x(\\underbrace {BIC}_{ x })$，$xy(\\underbrace {BI}_{ x } \\underbrace { C }_{ y })$，$Bxy (B\\underbrace { I }_{ x }\\underbrace { C }_{ y })$，但不能表示为 $Bx$。\n\n在表达式 $pq$ 中，我们说将 $p$ 应用于 $q$。我们可以用直觉来理解，$p$ 是一个函数，而 $q$ 是它的参数。然而，求值过程与传统的计算非常不同——不是通过固定表达式树传递值，而是通过改变树结构，使得结果也是一个组合表达式。\n\n为了求值一个表达式，我们需要选择一个子表达式，该子表达式应符合下表中的某个模式——也就是说，应该存在这样的 $x$（可能还有 $y$ 和 $z$），使得表中的模式与子表达式相等。然后我们需要将子表达式替换为表中的简化结果。\n\n| 模式  | 简化结果 | 描述                           |\n| :---: | :-------: | :-----------------------------: |\n| $Bxyz$ | $x(yz)$  | 组合函数（Zusammensetzungsfunktion） |\n| $Cxyz$ | $(xz)y$  | 交换函数（Vertauschungsfunktion）   |\n| $Kxy$  | $x$      | 常数函数（Konstanzfunktion）       |\n| $Ix$   | $x$      | 恒等函数（Identitätsfunktion）     |\n\n替换完成后，我们必须重复这个过程，直到没有合适的子表达式为止。这个最终表达式就是原始表达式的规范形式。例如，在表达式 $CIC(CB)I$ 中，我们可以进行如下字母分配\n\n$$\\underbrace { C }_{ C }\\underbrace { I }_{ x }\\underbrace { C }_{ y }\\underbrace {(CB)}_{ z }I$$\n\n并看到 $CIC(CB)I ≡ (((CI)C)(CB))I ≡ (((Cx)y)z)I$ 包含了 $C$ 组合子模式，因此简化为 $((xz)y)I ≡ I(CB)CI:$\n\n$$(\\underbrace { C }_{ C }\\underbrace { I }_{ x }\\underbrace { C }_{ y }\\underbrace { (CB) }_{ Z })I \\rightarrow (\\underbrace { I }_{ x } \\underbrace {(CB)}_{ z }\\underbrace { C }_{ y })I$$\n\n另一个例子：$B((CK)I)IC$ 表达式。让我们先简化组合子 $B:$\n\n$$(\\underbrace { B }_{ B }\\underbrace { ((CK)I) }_{ x }\\underbrace { I }_{ y }\\underbrace { C }_{ z } \\rightarrow \\underbrace { ((CK)I) }_{ x } (\\underbrace { I }_{ y }\\underbrace { C }_{ z }))$$\n\n现在，让我们简化最后一个 $I:$\n\n$$((CK)I)(\\underbrace { I }_{ I } \\underbrace { C }_{ x }) \\rightarrow ((CK)I)C$$\n\n最后，我们通过两次更多的简化完成求值：\n\n$$((\\underbrace { C }_{ C }\\underbrace { K }_{ x }) \\underbrace { I }_{ y }) \\underbrace { C }_{ z } \\rightarrow (\\underbrace { K }_{ K }\\underbrace { C }_{ x }) \\underbrace { I }_{ y } \\rightarrow C$$\n\n可以证明，无论求值顺序如何，规范形式都是一样的。例如，以下求值顺序：\n\n$$C(K(II)(\\underbrace { I }_{ I }\\underbrace { C }_{ x })) \\rightarrow C(K(\\underbrace { I }_{ I }\\underbrace {  I}_{ x })(C)) \\rightarrow C((\\underbrace { K }_{ K }\\underbrace { I }_{ x }) \\underbrace { C }_{ y }) \\rightarrow CI$$\n\n和\n\n$$C(K(\\underbrace {I}_{ I }\\underbrace { I }_{ x })(IC)) \\rightarrow C((\\underbrace { K }_{ K }\\underbrace { I }_{ x })\\underbrace { (IC)}_{ y }) \\rightarrow CI$$\n\n得到的结果相同。然而，如你所见，简化的次数不同：第一个情况下为 $3$ 次，第二个情况下为 $2$ 次。这提出了一个有趣的问题——找到一个给定公式所需的最小简化次数。\n\n你的任务是编写一个程序，找到给定组合表达式求值到其规范形式所需的最小简化次数。", "inputFormat": "输入文件只有一行，包含一个符合上述文法的组合表达式。表达式的长度不超过 $30 000$。表达式中不含空格或文法未指定的符号。", "outputFormat": "输出一个整数——给定公式求值到规范形式所需的最小简化次数。", "hint": "时间限制：1 秒，内存限制：256 MB。", "locale": "zh-CN"}}}
{"pid": "P7063", "type": "P", "difficulty": 1, "samples": [["2\n", "11\n"], ["3\n", "33\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "2014", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Digits", "background": "", "description": "\n\nLittle Petya likes integers. Recently he has learned about different properties of sums of number's digits. For example, if the sum of number's digits is divisible by $9$ , then the number itself is divisible by $9$ as well.\n\nNow little Petya is interested in numbers with equal sum of digits. He asks his older brother Dima to find $n$ positive integers with equal sum of digits and minimal possible total sum. Dima has other important things to do, so he asked you to write a program that solves this problem for him.\n\n", "inputFormat": "\n\nInput file contains a single integer $n (1 \\le n \\le 5000)$ .\n\n", "outputFormat": "\n\nOutput the minimal possible sum of $n$ positive integers, that all have same sum of digits.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Digits", "background": "", "description": "\n\nLittle Petya likes integers. Recently he has learned about different properties of sums of number's digits. For example, if the sum of number's digits is divisible by $9$ , then the number itself is divisible by $9$ as well.\n\nNow little Petya is interested in numbers with equal sum of digits. He asks his older brother Dima to find $n$ positive integers with equal sum of digits and minimal possible total sum. Dima has other important things to do, so he asked you to write a program that solves this problem for him.\n\n", "inputFormat": "\n\nInput file contains a single integer $n (1 \\le n \\le 5000)$ .\n\n", "outputFormat": "\n\nOutput the minimal possible sum of $n$ positive integers, that all have same sum of digits.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Digits", "background": "", "description": "小 Petya 喜欢整数。最近他了解到数字和的不同性质。例如，如果一个数字的各位数字之和可以被 $9$ 整除，那么这个数字本身也可以被 $9$ 整除。\n\n现在小 Petya 对具有相同数字和的数字感兴趣。他请求他的哥哥 Dima 找出 $n$ 个具有相同数字和且总和最小的正整数。Dima 有其他重要的事情要做，所以他请你为他编写一个程序来解决这个问题。", "inputFormat": "输入文件包含一个整数 $n (1 \\le n \\le 5000)$。", "outputFormat": "输出 $n$ 个正整数的最小可能总和，这些整数的数字和相同。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7064", "type": "P", "difficulty": 7, "samples": [["a.*b\nbab\n", "abab\n"], ["(ab)*\nbb\n", "NO\n"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Expression", "background": "", "description": "\n\nIn computing, regular expressions is a powerful tool for text search and string matching. In this problem a simplified version of regular expressions is used:\n\n- An empty string ` ` is a regular expression, only the empty string matches it.\n\n- A single lowercase letter `c` is a regular expression, a string consisting of a single letter $c$ matches it.\n\n- A dot `.` is a regular expression, a string consisting of any single letter matches it.\n\n- Alternation: if $α$ and $β$ are regular expressions then `(α|β)` is a regular expression, a string $s$ matches it only if $s$ matches $α$ or $s$ matches $β$.\n\n- Concatenation: if $α$ and $β$ are regular expressions then `(αβ)` is a regular expression, a string $s$ matches it only if $s =$ `xy`, $x$ matches $α$ and $y$ matches $β$.\n\n- Kleene star: if $α$ is regular expression then `(α∗)` is a regular expression, a string $s$ matches it only if $s$ is empty or $s =$ `xy`, $x$ is nonempty and matches $α$ and $y$ matches $(α∗).$ In other words, $s$ consists of zero or more strings, each of them matches $α.$\n\nParentheses can be omitted, in this problem Kleene star has the highest priority, concatenation has medium priority and alternation has lowest priority. Thus `abc*|de` means `(ab(c*))|(de)`.\n\nFor example, string `abcabcab` matches `a(bc|a)*ab`, but string `abcbab` does not.\n\nYour task is to find the shortest string that matches the given regular expression $E$ and contains the given substring $S$ .\n\n", "inputFormat": "\n\nThe first line of the input file contains the regular expression $E$ . The second line of the input file contains the substring $S (1 \\le |E| , |S| \\le 10 000)$ .\n\nString $S$ consists of lowercase English letters. Expression $E$ consists of lowercase English letters and special characters: dots (`.`), parentheses (`(`) and (`)`), pipes (`|`), and asterisks (`*`).\n\n", "outputFormat": "\n\nOutput the shortest possible string $T$ that both matches $E$ and contains $S$ as substring. If there are no such strings, output `NO`.\n\nThe string $T$ should contain only lowercase English letters.\n\n", "hint": "Time limit: 10 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Expression", "background": "", "description": "\n\nIn computing, regular expressions is a powerful tool for text search and string matching. In this problem a simplified version of regular expressions is used:\n\n- An empty string ` ` is a regular expression, only the empty string matches it.\n\n- A single lowercase letter `c` is a regular expression, a string consisting of a single letter $c$ matches it.\n\n- A dot `.` is a regular expression, a string consisting of any single letter matches it.\n\n- Alternation: if $α$ and $β$ are regular expressions then `(α|β)` is a regular expression, a string $s$ matches it only if $s$ matches $α$ or $s$ matches $β$.\n\n- Concatenation: if $α$ and $β$ are regular expressions then `(αβ)` is a regular expression, a string $s$ matches it only if $s =$ `xy`, $x$ matches $α$ and $y$ matches $β$.\n\n- Kleene star: if $α$ is regular expression then `(α∗)` is a regular expression, a string $s$ matches it only if $s$ is empty or $s =$ `xy`, $x$ is nonempty and matches $α$ and $y$ matches $(α∗).$ In other words, $s$ consists of zero or more strings, each of them matches $α.$\n\nParentheses can be omitted, in this problem Kleene star has the highest priority, concatenation has medium priority and alternation has lowest priority. Thus `abc*|de` means `(ab(c*))|(de)`.\n\nFor example, string `abcabcab` matches `a(bc|a)*ab`, but string `abcbab` does not.\n\nYour task is to find the shortest string that matches the given regular expression $E$ and contains the given substring $S$ .\n\n", "inputFormat": "\n\nThe first line of the input file contains the regular expression $E$ . The second line of the input file contains the substring $S (1 \\le |E| , |S| \\le 10 000)$ .\n\nString $S$ consists of lowercase English letters. Expression $E$ consists of lowercase English letters and special characters: dots (`.`), parentheses (`(`) and (`)`), pipes (`|`), and asterisks (`*`).\n\n", "outputFormat": "\n\nOutput the shortest possible string $T$ that both matches $E$ and contains $S$ as substring. If there are no such strings, output `NO`.\n\nThe string $T$ should contain only lowercase English letters.\n\n", "hint": "Time limit: 10 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Expression", "background": "", "description": "在计算机科学中，正则表达式是一种用于文本搜索和字符串匹配的强大工具。在这个问题中，使用了简化版的正则表达式：\n\n- 空字符串 ` ` 是一个正则表达式，只有空字符串匹配它。\n\n- 单个小写字母 `c` 是一个正则表达式，由单个字母 $c$ 组成的字符串匹配它。\n\n- 点号 `.` 是一个正则表达式，由任意单个字母组成的字符串匹配它。\n\n- 或运算：如果 $\\alpha$ 和 $\\beta$ 是正则表达式，那么 `(\\alpha|\\beta)` 是一个正则表达式，只有当字符串 $s$ 匹配 $\\alpha$ 或 $s$ 匹配 $\\beta$ 时，$s$ 才匹配它。\n\n- 连接运算：如果 $\\alpha$ 和 $\\beta$ 是正则表达式，那么 `(\\alpha\\beta)` 是一个正则表达式，只有当字符串 $s = xy$，$x$ 匹配 $\\alpha$ 且 $y$ 匹配 $\\beta$ 时，$s$ 才匹配它。\n\n- Kleene 星号：如果 $\\alpha$ 是正则表达式，那么 `(\\alpha*)` 是一个正则表达式，只有当字符串 $s$ 是空的或 $s = xy$，$x$ 非空且匹配 $\\alpha$ 且 $y$ 匹配 $(\\alpha*)$ 时，$s$ 才匹配它。换句话说，$s$ 由零个或多个字符串组成，每个字符串都匹配 $\\alpha$。\n\n括号可以省略，在这个问题中，Kleene 星号具有最高优先级，连接运算具有中等优先级，或运算具有最低优先级。因此 `abc*|de` 表示 `(ab(c*))|(de)`。\n\n例如，字符串 `abcabcab` 匹配 `a(bc|a)*ab`，但字符串 `abcbab` 不匹配。\n\n你的任务是找到匹配给定正则表达式 $E$ 并包含给定子串 $S$ 的最短字符串。", "inputFormat": "输入文件的第一行包含正则表达式 $E$。输入文件的第二行包含子串 $S$（$1 \\le |E|, |S| \\le 10\\,000$）。\n\n字符串 $S$ 由小写英文字母组成。表达式 $E$ 由小写英文字母和特殊字符组成：点号 (`.`)、括号 (`(` 和 `)`)、管道符号 (`|`) 和星号 (`*`)。", "outputFormat": "输出同时匹配 $E$ 并包含 $S$ 作为子串的最短可能字符串 $T$。如果没有这样的字符串，输出 `NO`。\n\n字符串 $T$ 只能包含小写英文字母。", "hint": "时间限制：10 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7065", "type": "P", "difficulty": 6, "samples": [["7\n2 3 1 1 2 2 1\n", "3\n2 4 1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Fragmentation", "background": "", "description": "\n\nFelix is working on a startup project in his garage. He has already found a great name for his project: SuperFastZilla. By now he is not sure what SuperFastZilla should do, but he is pretty sure it should do it fast, super fast.\n\nOnce he noticed that SuperFastZilla is working too slow, inspite of the fast algorithms used in it. Felix thinks that the problem may be caused by storage fragmentation.\n\nThe storage used by SuperFastZilla consists of $n$ blocks of memory. SuperFastZilla performs some operations on this storage. Each block is used in one operation only, the i-th block is used in the $a_{i}$-th operation.\n\nFelix wants to sort these blocks by the index of the operation they are used. To make it faster, Felix wants to split the storage into minimal number of segments of consecutive blocks, and then rearrange these segments to get the sorted array of blocks. After this rearrangement the order of block's indices of operations must be non-decreasing.\n\nHelp Felix to find the way to split the storage that minimizes the number of segments.\n\nFor example, if $a = [2 , 3 , 1 , 1 , 2 , 2 , 1],$ it can be split into three parts: $[2 , 3], [1 , 1 , 2 , 2]$ and $[1].$ These parts can be rearranged to make the sorted array: $[1], [1 , 1 , 2 , 2], [2 , 3].$\n\n", "inputFormat": "\n\nThe first line of input file contains an integer $n (1 \\le n \\le 10^{5}).$ The next line contains $n$ integers $a_{i} (1 \\le a_{i} \\le 10^{5}).$\n\n", "outputFormat": "\n\nThe first line of the output file must contain an integer number $m$ — the minimal number of segments.\n\nThe next line must contains $m$ integers, the lengths of the segments, from left to right.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Fragmentation", "background": "", "description": "\n\nFelix is working on a startup project in his garage. He has already found a great name for his project: SuperFastZilla. By now he is not sure what SuperFastZilla should do, but he is pretty sure it should do it fast, super fast.\n\nOnce he noticed that SuperFastZilla is working too slow, inspite of the fast algorithms used in it. Felix thinks that the problem may be caused by storage fragmentation.\n\nThe storage used by SuperFastZilla consists of $n$ blocks of memory. SuperFastZilla performs some operations on this storage. Each block is used in one operation only, the i-th block is used in the $a_{i}$-th operation.\n\nFelix wants to sort these blocks by the index of the operation they are used. To make it faster, Felix wants to split the storage into minimal number of segments of consecutive blocks, and then rearrange these segments to get the sorted array of blocks. After this rearrangement the order of block's indices of operations must be non-decreasing.\n\nHelp Felix to find the way to split the storage that minimizes the number of segments.\n\nFor example, if $a = [2 , 3 , 1 , 1 , 2 , 2 , 1],$ it can be split into three parts: $[2 , 3], [1 , 1 , 2 , 2]$ and $[1].$ These parts can be rearranged to make the sorted array: $[1], [1 , 1 , 2 , 2], [2 , 3].$\n\n", "inputFormat": "\n\nThe first line of input file contains an integer $n (1 \\le n \\le 10^{5}).$ The next line contains $n$ integers $a_{i} (1 \\le a_{i} \\le 10^{5}).$\n\n", "outputFormat": "\n\nThe first line of the output file must contain an integer number $m$ — the minimal number of segments.\n\nThe next line must contains $m$ integers, the lengths of the segments, from left to right.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Fragmentation", "background": "", "description": "Felix 正在他的车库里进行一个创业项目。他已经为他的项目找到了一个很棒的名字：SuperFastZilla。目前他还不确定 SuperFastZilla 应该做什么，但他非常确定它应该做得很快，超级快。\n\n有一次他注意到 SuperFastZilla 的运行速度太慢，尽管它使用了快速算法。Felix 认为问题可能是由存储碎片引起的。\n\nSuperFastZilla 使用的存储由 $n$ 个内存块组成。SuperFastZilla 在这个存储上执行一些操作。每个块只在一个操作中使用，第 $i$ 个块在第 $a_{i}$ 个操作中使用。\n\nFelix 想按它们使用的操作索引对这些块进行排序。为了加快速度，Felix 想将存储分成最少数量的连续块段，然后重新排列这些段以获得排序后的块数组。重新排列后，块的操作索引顺序必须是非递减的。\n\n帮助 Felix 找到一种分割存储的方法，以最小化段的数量。\n\n例如，如果 $a = [2 , 3 , 1 , 1 , 2 , 2 , 1]$，它可以分成三部分：$[2 , 3], [1 , 1 , 2 , 2]$ 和 $[1]$。这些部分可以重新排列以形成排序后的数组：$[1], [1 , 1 , 2 , 2], [2 , 3]$。", "inputFormat": "输入文件的第一行包含一个整数 $n (1 \\le n \\le 10^{5})$。下一行包含 $n$ 个整数 $a_{i} (1 \\le a_{i} \\le 10^{5})$。", "outputFormat": "输出文件的第一行必须包含一个整数 $m$ — 最小的段数。\n\n下一行必须包含 $m$ 个整数，表示从左到右的段的长度。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7066", "type": "P", "difficulty": 1, "samples": [["1 1 11 8\n2 3 8 6\n3 2\n", "Yes\n"], ["1 1 11 8\n2 3 8 6\n4 3\n", "No\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Grave", "background": "", "description": "\n\nGerard develops a Halloween computer game. The game is played on a rectangular graveyard with a rectangular chapel in it. During the game, the player places new rectangular graves on the graveyard. The grave should completely fit inside graveyard territory and should not overlap with the chapel. The grave may touch borders of the graveyard or the chapel.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qktc13ls.png)\n\nGerard asked you to write a program that determines whether it is possible to place a new grave of given size or there is no enough space for it.\n\n", "inputFormat": "\n\nThe first line of the input file contains two pairs of integers: $x_{1}, y_{1}, x_{2}, y_{2} (−10^{9} \\le x_{1} < x_{2} \\le 10^{9}; −10^{9} \\le y_{1} < y_{2} \\le 10^{9})$ — coordinates of bottom left and top right corners of the graveyard. The second line also contains two pairs of integers $x_{3}, y_{3}, x_{4}, y_{4} (x_{1} < x_{3} < x_{4} < x_{2}; y_{1} < y_{3} < y_{4} < y_{2})$ — coordinates of bottom left and top right corners of the chapel.\n\nThe third line contains two integers $w , h$ — width and height of the new grave $(1 \\le w , h \\le 10^{9}).$ Side with length $w$ should be placed along OX axis, side with length $h$ — along OY axis.\n\n", "outputFormat": "\n\nThe only line of the output file should contain single word: `Yes`, if it is possible to place the new grave, or `No`, if there is not enough space for it.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Grave", "background": "", "description": "\n\nGerard develops a Halloween computer game. The game is played on a rectangular graveyard with a rectangular chapel in it. During the game, the player places new rectangular graves on the graveyard. The grave should completely fit inside graveyard territory and should not overlap with the chapel. The grave may touch borders of the graveyard or the chapel.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qktc13ls.png)\n\nGerard asked you to write a program that determines whether it is possible to place a new grave of given size or there is no enough space for it.\n\n", "inputFormat": "\n\nThe first line of the input file contains two pairs of integers: $x_{1}, y_{1}, x_{2}, y_{2} (−10^{9} \\le x_{1} < x_{2} \\le 10^{9}; −10^{9} \\le y_{1} < y_{2} \\le 10^{9})$ — coordinates of bottom left and top right corners of the graveyard. The second line also contains two pairs of integers $x_{3}, y_{3}, x_{4}, y_{4} (x_{1} < x_{3} < x_{4} < x_{2}; y_{1} < y_{3} < y_{4} < y_{2})$ — coordinates of bottom left and top right corners of the chapel.\n\nThe third line contains two integers $w , h$ — width and height of the new grave $(1 \\le w , h \\le 10^{9}).$ Side with length $w$ should be placed along OX axis, side with length $h$ — along OY axis.\n\n", "outputFormat": "\n\nThe only line of the output file should contain single word: `Yes`, if it is possible to place the new grave, or `No`, if there is not enough space for it.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Grave", "background": "", "description": "Gerard 开发了一款万圣节电脑游戏。游戏在一个矩形墓地上进行，墓地中有一个矩形教堂。在游戏中，玩家需要在墓地上放置新的矩形墓碑。墓碑必须完全放置在墓地范围内，并且不能与教堂重叠。墓碑可以接触墓地或教堂的边界。\n\nGerard 要求你编写一个程序，判断是否可以放置给定大小的新墓碑，或者是否没有足够的空间。", "inputFormat": "输入文件的第一行包含两对整数：$x_{1}, y_{1}, x_{2}, y_{2} (-10^{9} \\le x_{1} < x_{2} \\le 10^{9}; -10^{9} \\le y_{1} < y_{2} \\le 10^{9})$——墓地左下角和右上角的坐标。第二行也包含两对整数 $x_{3}, y_{3}, x_{4}, y_{4} (x_{1} < x_{3} < x_{4} < x_{2}; y_{1} < y_{3} < y_{4} < y_{2})$——教堂左下角和右上角的坐标。\n\n第三行包含两个整数 $w , h$——新墓碑的宽度和高度 $(1 \\le w , h \\le 10^{9})$。长度为 $w$ 的边应沿 OX 轴放置，长度为 $h$ 的边应沿 OY 轴放置。", "outputFormat": "输出文件的唯一一行应包含一个单词：如果可以放置新墓碑，则为 `Yes`，如果没有足够的空间，则为 `No`。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7067", "type": "P", "difficulty": 5, "samples": [["8\n1000000 0 0 1000000 1000000 150000 600000 600000 400000\n0 1000000 0 600000 600000 400000 600000 1000000 300000\n0 1000000 0 400000 300000 150000 600000 600000 400000\n400000 0 200000 1000000 0 0 400000 300000 150000\n400000 300000 150000 1000000 0 0 600000 600000 400000\n600000 600000 400000 1000000 1000000 150000 600000 1000000 300000\n0 0 0 400000 0 200000 400000 300000 150000\n0 1000000 0 0 0 0 400000 300000 150000\n100000 700000 37500\n900000 400000 137500\n", "4\n100000 700000 37500\n400000 300000 150000\n900000 150000 100000\n900000 400000 137500\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Hiking in the Hills", "background": "", "description": "\n\nHelen is hiking with her friends in a highland. Their plan is to hike from their camp $A$ to a beautiful showplace $B$ .\n\nUnfortunately, Helen started feeling dizzy due to altitude sickness. Help her group find a route such that the topmost height on that route is as small as possible.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o2199eky.png)\n", "inputFormat": "\n\nThe input file contains full information about the landscape of a square region $10^{6} \\times 10^{6}$ in the following format. The first line contains integer $n$ — the number of triangles in the landscape $(2 \\le n \\le 2000)$ . Each of following $n$ lines contains nine integers $x_{i_1}, y_{i_1}, z_{i_1}, x_{i_2}, y_{i_2}, z_{i_2}, x_{i3}, y_{i3}, z_{i3}$ — coordinates of a triangle. All coordinates belong to the closed interval $[0 , 10^{6}]$. The two last lines contain three integers each: $x_{A}, y_{A}, z_{A}$ and $x_{B}, y_{B}, z_{B}$ — coordinates of the camp A and the showplace $B$ .\n\nThe given triangles are guaranteed to describe a consistent continuous landscape. Projections of triangles onto $XY$ plane are non-degenerate and fill the square without overlapping. A vertex of one triangle never lays inside an edge of another triangle. Points $A$ and $B$ belong to the landscape surface and are different.\n\n", "outputFormat": "\n\nOutput a polyline route from $A$ to $B$ with the smallest possible topmost height. The first line should contain $m$ , the number of vertices in this polyline. Each of following $m$ lines should contain three integer coordinates of a polyline vertex: $x_{i}, y_{i},$ and $z_{i}.$ Vertices must be listed along the polyline, from $A$ to $B$ (including these two endpoints).\n\nAll coordinates of polyline vertices should be integer. Each polyline edge must belong to some triangle from the input file (possibly, to its edge). The number of vertices in the polyline must not exceed $5n$.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Hiking in the Hills", "background": "", "description": "\n\nHelen is hiking with her friends in a highland. Their plan is to hike from their camp $A$ to a beautiful showplace $B$ .\n\nUnfortunately, Helen started feeling dizzy due to altitude sickness. Help her group find a route such that the topmost height on that route is as small as possible.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o2199eky.png)\n", "inputFormat": "\n\nThe input file contains full information about the landscape of a square region $10^{6} \\times 10^{6}$ in the following format. The first line contains integer $n$ — the number of triangles in the landscape $(2 \\le n \\le 2000)$ . Each of following $n$ lines contains nine integers $x_{i_1}, y_{i_1}, z_{i_1}, x_{i_2}, y_{i_2}, z_{i_2}, x_{i3}, y_{i3}, z_{i3}$ — coordinates of a triangle. All coordinates belong to the closed interval $[0 , 10^{6}]$. The two last lines contain three integers each: $x_{A}, y_{A}, z_{A}$ and $x_{B}, y_{B}, z_{B}$ — coordinates of the camp A and the showplace $B$ .\n\nThe given triangles are guaranteed to describe a consistent continuous landscape. Projections of triangles onto $XY$ plane are non-degenerate and fill the square without overlapping. A vertex of one triangle never lays inside an edge of another triangle. Points $A$ and $B$ belong to the landscape surface and are different.\n\n", "outputFormat": "\n\nOutput a polyline route from $A$ to $B$ with the smallest possible topmost height. The first line should contain $m$ , the number of vertices in this polyline. Each of following $m$ lines should contain three integer coordinates of a polyline vertex: $x_{i}, y_{i},$ and $z_{i}.$ Vertices must be listed along the polyline, from $A$ to $B$ (including these two endpoints).\n\nAll coordinates of polyline vertices should be integer. Each polyline edge must belong to some triangle from the input file (possibly, to its edge). The number of vertices in the polyline must not exceed $5n$.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Hiking in the Hills", "background": "", "description": "H正在和她的朋友在高原徒步，他们计划着从他们的营地A徒步到一个风景名胜B。\n\n可惜的是，H有了点高原反应。请你帮助他们找到一条路线，使该路线的最高高度尽可能小。\n![](https://cdn.luogu.com.cn/upload/image_hosting/o2199eky.png)（$1:10^5$）", "inputFormat": "输入数据包含整个$10^6 \\times 10^6$的的完整信息，格式如下：\n\n第一行包含了一个整数$n$，表示着这个空间内的三角形的数量。接下来的$n$行，每行包含九个整数，分别是\n$x_{i_1},y_{i_1},z_{i_1},x_{i_2},y_{i_2},z_{i_2},x_{i_3},y_{i_3},z_{i_3}$\n，是一个三角形的坐标。每个三角形的坐标都在区间[$0, 10^6$]之间。最后两行分别包含了A处的坐标和B处的坐标。\n\n给定的三角形保证在一个一致的坐标系。三角形在XY平面上的投影是非简并的，并且填充正方形而不重叠。一个三角形的顶点永远不会位于另一个三角形的边内。A点和B点属于同一个坐标系，且两者不同位置。", "outputFormat": "输出从A到B的路线，其最高高度可能最小。第一行应包含m，即此多段线中的顶点数。下面的每m条线都应该包含多段线顶点的三个整数坐标。\n\n顶点必须沿路线列出，从A到B（包括这两个端点）。\n路线顶点的所有坐标都应为整数。每个多段线边必须属于输入文件（可能是其边）中的某个三角形。路线的拐点数不能超过5n。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7068", "type": "P", "difficulty": 0, "samples": [["7\ns 0\ns 1\ns 1\np 2 a\np 2 b\np 3 c\np 3 d\n5\n0 a\n1 c\n3 b\n4 a\n5 d\n", "6\n1 2\n1 4\n2 4\n2 6\n1 6\n3 7\n"], ["5\ns 0\np 1 y\ns 1\np 3 z\np 3 x\n3\n7 y\n8 y\n15 y\n", "0\n"], ["3\ns 0\np 1 y\np 1 z\n3\n7 y\n8 y\n10 y\n", "5\n1 1\n1 2\n1 2\n1 3\n1 200\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Instruction", "background": "", "description": "\n\nIngrid is a head of a big railway station and, among other duties, is responsible for routing trains to the right platforms. The station has one entrance, and there are many switches that direct trains to other switches and platforms.\n\nEach switch has one inbound track and two outbound tracks, platforms have one inbound track, and station entrance has one outbound track. Each outbound track is connected to one inbound track and vice versa. Every switch and platform is reachable from station entrance.\n\nPlatforms have a rail dead ends and you may assume that trains disappear from the platform immediately after arriving to it.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i6zwkhqd.png)\n\nEach morning Ingrid looks at the timetable and writes switch toggling instruction: when and which switch to toggle. She would like to automate this process to save a lot of time.\n\n", "inputFormat": "\n\nThe first line of the input file contains a single integer $n$ — the total number of switches and platforms on the station $(3 \\le n \\le 51)$ .\n\nThe i-th of the following $n$ lines describes a switch or a platform with an index $i$ . Description starts with a character `p` for a platform or `s` for a switch. Next number $q_{i}$ indicates the number of the switch the inbound track is connected to or $0$ if it is connected to station entrance $(0 \\le q_{i} < i)$ . Description of the platform also contains a unique lowercase English letter — the platform identifier.\n\nTrains spend exactly one minute to move between two connected switches or a switch and a platform. In the morning, each switch is toggled in a way that a train would pass to the one of the two outbound tracks connected to the switch/platform with the lower number.\n\nNext line of the input file contains a single integer $m (1 \\le m \\le 1000)$ — the number of trains in timetable.\n\nEach of the following $m$ lines contains integer $a_{i} (0 \\le a_{i} \\le 10 000$ ; $a_{i} > a_{i−1})$ — the time in minutes when a train arrives to the station entrance, and the letter $p_{i}$ — identifier of the destination platform for this train.\n\n", "outputFormat": "\n\nIn the first line output integer $c$ — the number of commands in the switch toggling instruction. For each command, output two integers $s_{i}$ and $t_{i} (1 \\le s_{i} \\le n$ ; $0 \\le t_{i} \\le 10^{9})$ — the number of the switch and the time to toggle it. Assume that the switch is toggled between minutes $t_{i} − 1$ and $t_{i}.$\n\nOutput commands in order of non-decreasing time. The number of commands should not exceed $100 000$ .\n\n", "hint": "Below is the time trace for the first example.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j38jeq0g.png)\n\nTime limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Instruction", "background": "", "description": "\n\nIngrid is a head of a big railway station and, among other duties, is responsible for routing trains to the right platforms. The station has one entrance, and there are many switches that direct trains to other switches and platforms.\n\nEach switch has one inbound track and two outbound tracks, platforms have one inbound track, and station entrance has one outbound track. Each outbound track is connected to one inbound track and vice versa. Every switch and platform is reachable from station entrance.\n\nPlatforms have a rail dead ends and you may assume that trains disappear from the platform immediately after arriving to it.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i6zwkhqd.png)\n\nEach morning Ingrid looks at the timetable and writes switch toggling instruction: when and which switch to toggle. She would like to automate this process to save a lot of time.\n\n", "inputFormat": "\n\nThe first line of the input file contains a single integer $n$ — the total number of switches and platforms on the station $(3 \\le n \\le 51)$ .\n\nThe i-th of the following $n$ lines describes a switch or a platform with an index $i$ . Description starts with a character `p` for a platform or `s` for a switch. Next number $q_{i}$ indicates the number of the switch the inbound track is connected to or $0$ if it is connected to station entrance $(0 \\le q_{i} < i)$ . Description of the platform also contains a unique lowercase English letter — the platform identifier.\n\nTrains spend exactly one minute to move between two connected switches or a switch and a platform. In the morning, each switch is toggled in a way that a train would pass to the one of the two outbound tracks connected to the switch/platform with the lower number.\n\nNext line of the input file contains a single integer $m (1 \\le m \\le 1000)$ — the number of trains in timetable.\n\nEach of the following $m$ lines contains integer $a_{i} (0 \\le a_{i} \\le 10 000$ ; $a_{i} > a_{i−1})$ — the time in minutes when a train arrives to the station entrance, and the letter $p_{i}$ — identifier of the destination platform for this train.\n\n", "outputFormat": "\n\nIn the first line output integer $c$ — the number of commands in the switch toggling instruction. For each command, output two integers $s_{i}$ and $t_{i} (1 \\le s_{i} \\le n$ ; $0 \\le t_{i} \\le 10^{9})$ — the number of the switch and the time to toggle it. Assume that the switch is toggled between minutes $t_{i} − 1$ and $t_{i}.$\n\nOutput commands in order of non-decreasing time. The number of commands should not exceed $100 000$ .\n\n", "hint": "Below is the time trace for the first example.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j38jeq0g.png)\n\nTime limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Instruction", "background": "", "description": "英格丽德是一家大型火车站的站长，除其他职责外，还负责将火车开到正确的站台。车站有一个入口，有许多道岔将列车引导至其他道岔和站台。\n\n每个道岔有一条入站轨道和两条出站轨道，站台有一条入站轨道，车站入口有一条出站轨道。每个出站磁道连接到一个入站磁道，反之亦然。每个道岔和站台都可以从车站入口到达。\n\n月台有一个铁路死胡同，你可以假设火车到达月台后立即从月台上消失。\n\n每天早上，英格丽德都会查看时间表，并编写切换指令：何时以及切换哪个开关。她希望将此过程自动化以节省大量时间。", "inputFormat": "输入文件的第一行包含一个整数n—站点上交换机和平台的总数\n\n以下n行的第i行描述了具有索引i的交换机或平台。说明以字符p开头表示平台，以字符s开头表示交换机。下一个数字q`i`表示入站轨道连接到的道岔的编号，如果连接到车站入口，则表示0(0≤q$i$≤i)平台说明还包含一个唯一的小写英文字母 -- 平台标识符。\n\n列车在两个相连的道岔或道岔与站台之间移动只需一分钟。早上，每一个道岔都会以一种方式进行切换，列车将通过连接到道岔/站台的两条出站轨道中编号较低的一条。\n输入文件的下一行包含一个整数m(0≤m≤1000) -- 时刻表上的列车数量。\n\n以下m行中的每一行都包含整数a*i* (0≤a$i$ ≤10000;a$i$>a$i-1$) -- 列车到达车站入口的时间（以分钟为单位），以及字母p*i* -- 列车目的站台的标识符。", "outputFormat": "在第一行输出整数c中，开关切换指令中的命令数。对于每个命令，输出两个整数 s`i`和 t$i$ (1≤s$i$ ≤n;0≤ t$i$ ≤10^9) -- 开关的编号和切换开关的时间。假设开关在分钟之间切换 t$i$-1 和 `t`。\n\n按非递减时间顺序输出命令。命令的数量不应超过100000。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7069", "type": "P", "difficulty": 4, "samples": [["1 1 7 4\n2 3 10\n0 1 2\n2 2 0", "Yes\n3 2.5\n5 2.5\n7 4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Joy of Flight", "background": "", "description": "Jacob likes to play with his radio-controlled aircraft. The weather today is pretty windy and Jacob has to plan flight carefully. He has a weather forecast — the speed and direction of the wind for every second of the planned flight.\n\nThe plane may have airspeed up to $v_{\\max}$ units per second in any direction. The wind blows away plane in the following way: if airspeed speed of the plane is $(v_x, v_y)$ and the wind speed is $(w_x, w_y)$, the plane moves by $(v_x+w_x, v_y+w_y)$ each second.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2uyb1zpd.png)\n\nJacob has a fuel for exactly $k$ seconds, and he wants to learn, whether the plane is able to fly from start to finish in this time. If it is possible he needs to know the flight plan: the position of the plane after every second of flight.", "inputFormat": "The first line of the input file contains four integers $S_x, S_y, F_x, F_y$ — coordinates of start and finish ($−10 000 ≤ S_x, S_y, F_x, F_y ≤ 10 000$).\n\nThe second line contains three integers $n, k$ and $v_{\\max}$ — the number of wind condition changes, duration of Jacob’s flight in seconds and maximum aircraft speed ($1 ≤ n, k, v_{\\max} ≤ 10 000$).\n\nThe following $n$ lines contain the wind conditions description. The $i$-th of these lines contains integers $t_i, w_{x_i}$ and $w_{y_i}$ — starting at time $t_i$ the wind will blow by vector $(w_{x_i}, w_{y_i})$ each second ($0 = t_1 < ··· < t_i < t_{i+1} < ··· < k; \\sqrt{w_{x_i}^2 + w_{y_i}^2} ≤ v_{\\max}$).", "outputFormat": "The first line must contain `Yes` if Jacob’s plane is able to fly from start to finish in k seconds, and `No` otherwise.\n\nIf it can to do that, the following $k$ lines must contain the flight plan. The $i$-th of these lines must contain two floating point numbers $x$ and $y$ — the coordinates of the position ($P_i$) of the plane after $i$-th second of the flight.\n\nThe plan is correct if for every $1 ≤ i ≤ k$ it is possible to fly in one second from $P_{i−1}$ to some point $Q_i$, such that distance between $Q_i$ and $P_i$ doesn’t exceed $10^{−5}$, where $P_0 = S$. Moreover the distance between $P_k$ and $F$ should not exceed $10^{-5}$ as well.", "hint": "Time limit: 2 s, Memory limit: 256 MB.", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Joy of Flight", "background": "", "description": "Jacob likes to play with his radio-controlled aircraft. The weather today is pretty windy and Jacob has to plan flight carefully. He has a weather forecast — the speed and direction of the wind for every second of the planned flight.\n\nThe plane may have airspeed up to $v_{\\max}$ units per second in any direction. The wind blows away plane in the following way: if airspeed speed of the plane is $(v_x, v_y)$ and the wind speed is $(w_x, w_y)$, the plane moves by $(v_x+w_x, v_y+w_y)$ each second.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2uyb1zpd.png)\n\nJacob has a fuel for exactly $k$ seconds, and he wants to learn, whether the plane is able to fly from start to finish in this time. If it is possible he needs to know the flight plan: the position of the plane after every second of flight.", "inputFormat": "The first line of the input file contains four integers $S_x, S_y, F_x, F_y$ — coordinates of start and finish ($−10 000 ≤ S_x, S_y, F_x, F_y ≤ 10 000$).\n\nThe second line contains three integers $n, k$ and $v_{\\max}$ — the number of wind condition changes, duration of Jacob’s flight in seconds and maximum aircraft speed ($1 ≤ n, k, v_{\\max} ≤ 10 000$).\n\nThe following $n$ lines contain the wind conditions description. The $i$-th of these lines contains integers $t_i, w_{x_i}$ and $w_{y_i}$ — starting at time $t_i$ the wind will blow by vector $(w_{x_i}, w_{y_i})$ each second ($0 = t_1 < ··· < t_i < t_{i+1} < ··· < k; \\sqrt{w_{x_i}^2 + w_{y_i}^2} ≤ v_{\\max}$).", "outputFormat": "The first line must contain `Yes` if Jacob’s plane is able to fly from start to finish in k seconds, and `No` otherwise.\n\nIf it can to do that, the following $k$ lines must contain the flight plan. The $i$-th of these lines must contain two floating point numbers $x$ and $y$ — the coordinates of the position ($P_i$) of the plane after $i$-th second of the flight.\n\nThe plan is correct if for every $1 ≤ i ≤ k$ it is possible to fly in one second from $P_{i−1}$ to some point $Q_i$, such that distance between $Q_i$ and $P_i$ doesn’t exceed $10^{−5}$, where $P_0 = S$. Moreover the distance between $P_k$ and $F$ should not exceed $10^{-5}$ as well.", "hint": "Time limit: 2 s, Memory limit: 256 MB.", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Joy of Flight", "background": "", "description": "大意就是一架飞机要从起点飞到终点，飞机有最大空速，飞行最大时间，给出风速的变化和风如何影响飞机飞行，求出飞机是否能到达终点，如果能就输出飞机的位置变化。\n\n\n雅各布（Jacob）喜欢玩他的无线电摇制飞机。今天的风很大，雅各布必须小心地计划飞行。他有一个天气预报——飞行计划中每秒钟的风速和风向。\n\n飞机每秒在任何方向的空速最大都可以达到 $v_{max}$ 。风吹动飞机的方式如下：如果飞机的空速是 $(v_x,v_y)$ 并且风速是 $(w_x,w_y)$ ，那么飞机每秒将移动 $(v_x+w_x,v_y+w_y)$ 。\n\n![P7069-1](https://cdn.luogu.com.cn/upload/image_hosting/2uyb1zpd.png)\n\n雅各布（Jacob）有一种刚好能使用$k$秒的燃料，他想知道，飞机是否能在这段时间内从起点飞到终点。如果可能的话，他需要知道飞行计划：每飞行一秒后飞机的位置。", "inputFormat": "输入文件的第一行有四个整数 $S_x,S_y,F_x,F_y$ ，代表起始位置 $(-10000 \\le S_x,S_y,F_x,F_y \\le 10000)$ 。\n\n第二行有三个整数 $n,k 和 v_{max}$ ——风况变化的次数，雅各布（Jacob）飞行持续的时间（以秒为单位）和飞机最大空速。\n\n剩下的 $n$ 行是对风向的描述，第 $i$ 行有三个整数 $t_i,w_{xi} 和 w_{yi}$ ——从时间 $t_i$ 开始，风速为每秒 $(w_{xi},w_{yi})$ （一个向量） $(0=t_1< \\cdots <t_i<t_{i+1}< \\cdots <k; \\sqrt{{w^2_{xi}}+{w^2_{yi}}} \\le v_{max})$ 。", "outputFormat": "如果 $k$ 秒内雅各布（Jacob）的飞机能从起点飞到终点则应输出 `Yes` ，否则输出 `No` 。\n\n如果它能飞到，接下来的 $k$ 行必须包括飞行计划。第 $i$ 行必须包括两个浮点数 $x$ 和 $y$ （保留几位貌似没说）——飞行了第 $i$ 秒的平面位置 $(P_i)$ 。\n\n如果对于每个 $1 \\le i \\le k$ 都能在一秒内从点 $P_{i-1}$ 飞到某个点 $Q_i$ ，使得 $Q_i$ 和 $P_i$ 间距离不超过 $10^{-5}$ ，其中 $P_0=S$ ，那么这个计划就是正确的。此外 $P_k$ 和 $F$ 间的距离也应不超过 $10^{-5}$ 。", "hint": "时间限制： $2s$ ；内存限制： $256MB$ \n\nby XYY1411\n\n2020/12/08", "locale": "zh-CN"}}}
