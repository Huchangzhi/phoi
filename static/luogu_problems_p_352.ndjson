{"pid": "P8132", "type": "P", "difficulty": 0, "samples": [["20 13\nH 12 13\nD 5 18\nR 13 14\nR 8 16\nH 2 3\nV 10 19\nV 3 13\nR 8 13\nV 3 10\nD 5 18\nV 11 12\nR 1 6\nR 14 19", "1\n2\n0\n-3\n-7\n-9\n-11\n-9\n-7\n-6\n-6\n-5\n-3\n-4\n-5\n-4\n-4\n-3\n0\n0"], ["7 1\nH 1 6", "1\n2\n3\n3\n2\n1\n0"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "O2优化", "ICPC", "WF"], "title": "[ICPC 2020 WF] Landscape Generator", "background": "ICPC2020 WF E", "description": "Interactive Creative Players Collective (ICPC) is working on a new computer game for which they want to generate realistic landscapes.\nOne of the ICPC engineers proposed an algorithm inspired by geological processes.\nThe algorithm starts with a flat landscape and repeatedly modifies it by lifting or lowering continuous blocks, thus forming *horsts* (lifted blocks) and *grabens* (lowered blocks).\nThe blocks to be lifted or lowered are selected at random.\nICPC hopes to obtain realistic landscapes this way.\n\nYour task is to interpret any sequence of such modifications and output the resulting landscape.\nThe landscape is represented by a sequence of $n$ integer height values, one for each integer point from $1$ to $n$ on the $x$-axis.\nFigure E.1 illustrates an example by connecting the height values with line segments.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t8catonw.png)\n\nInitially the height is $0$ at all $n$ points.\nThis flat shape is subjected to a sequence of modifications.\nEach modification applies one of the following four operations with two integer parameters $x_1 \\leq x_2$:\n\n- $\\texttt{R}$: Raise -- increase the height by $1$ at all points between $x_1$ and $x_2$ inclusive.\n- $\\texttt{D}$: Depress -- decrease the height by $1$ at all points between $x_1$ and $x_2$ inclusive.\n- $\\texttt{H}$: Hill -- add a new linearly shaped hill between $x_1$ and $x_2$.\n- $\\texttt{V}$: Valley -- add a new linearly shaped valley between $x_1$ and $x_2$.\n\nAdding a hill to the current landscape works as follows.\nThe heights at points $x_1$ and $x_2$ are increased by $1$.\nIf $x_2 - x_1 > 1$, the heights at points $x_1 + 1$ and $x_2 - 1$ are increased by $2$.\nIf $x_2 - x_1 > 3$, the heights at points $x_1 + 2$ and $x_2 - 2$ are increased by $3$, and so on.\nFigure E.2 shows an example.\nAdding a valley works in the same way except the heights are decreased instead.\nThe maximal change of height happens in the middle between $x_1$ and $x_2$.\nIf $x_2 - x_1$ is odd, there will be two neighboring points with maximal change, otherwise just one.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rl890ge2.png)", "inputFormat": "The first line of input contains two integers $n$ and $k$, where $n$ ($1 \\leq n \\leq 200\\,000$) is the number of points, and $k$ ($0 \\leq k \\leq 200\\,000$) is the number of modifications.\nThe $n$ points along the $x$-axis are numbered from $1$ to $n$.\nThe next $k$ lines describe the modifications.\nEach line contains one character $c$ and two integers $x_1$ and $x_2$, where $c$ (one of $\\texttt{R}$, $\\texttt{D}$, $\\texttt{H}$ or $\\texttt{V}$) designates the operation and $x_1$ and $x_2$ ($1 \\leq x_1 \\leq x_2 \\leq n$) specify its parameters.\n", "outputFormat": "Output $n$ lines, where the $i^{\\text{th}}$ line contains the height at point $i$ after applying all modifications in the given order.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 WF] Landscape Generator", "background": "ICPC2020 WF E", "description": "Interactive Creative Players Collective (ICPC) is working on a new computer game for which they want to generate realistic landscapes.\nOne of the ICPC engineers proposed an algorithm inspired by geological processes.\nThe algorithm starts with a flat landscape and repeatedly modifies it by lifting or lowering continuous blocks, thus forming *horsts* (lifted blocks) and *grabens* (lowered blocks).\nThe blocks to be lifted or lowered are selected at random.\nICPC hopes to obtain realistic landscapes this way.\n\nYour task is to interpret any sequence of such modifications and output the resulting landscape.\nThe landscape is represented by a sequence of $n$ integer height values, one for each integer point from $1$ to $n$ on the $x$-axis.\nFigure E.1 illustrates an example by connecting the height values with line segments.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t8catonw.png)\n\nInitially the height is $0$ at all $n$ points.\nThis flat shape is subjected to a sequence of modifications.\nEach modification applies one of the following four operations with two integer parameters $x_1 \\leq x_2$:\n\n- $\\texttt{R}$: Raise -- increase the height by $1$ at all points between $x_1$ and $x_2$ inclusive.\n- $\\texttt{D}$: Depress -- decrease the height by $1$ at all points between $x_1$ and $x_2$ inclusive.\n- $\\texttt{H}$: Hill -- add a new linearly shaped hill between $x_1$ and $x_2$.\n- $\\texttt{V}$: Valley -- add a new linearly shaped valley between $x_1$ and $x_2$.\n\nAdding a hill to the current landscape works as follows.\nThe heights at points $x_1$ and $x_2$ are increased by $1$.\nIf $x_2 - x_1 > 1$, the heights at points $x_1 + 1$ and $x_2 - 1$ are increased by $2$.\nIf $x_2 - x_1 > 3$, the heights at points $x_1 + 2$ and $x_2 - 2$ are increased by $3$, and so on.\nFigure E.2 shows an example.\nAdding a valley works in the same way except the heights are decreased instead.\nThe maximal change of height happens in the middle between $x_1$ and $x_2$.\nIf $x_2 - x_1$ is odd, there will be two neighboring points with maximal change, otherwise just one.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rl890ge2.png)", "inputFormat": "The first line of input contains two integers $n$ and $k$, where $n$ ($1 \\leq n \\leq 200\\,000$) is the number of points, and $k$ ($0 \\leq k \\leq 200\\,000$) is the number of modifications.\nThe $n$ points along the $x$-axis are numbered from $1$ to $n$.\nThe next $k$ lines describe the modifications.\nEach line contains one character $c$ and two integers $x_1$ and $x_2$, where $c$ (one of $\\texttt{R}$, $\\texttt{D}$, $\\texttt{H}$ or $\\texttt{V}$) designates the operation and $x_1$ and $x_2$ ($1 \\leq x_1 \\leq x_2 \\leq n$) specify its parameters.\n", "outputFormat": "Output $n$ lines, where the $i^{\\text{th}}$ line contains the height at point $i$ after applying all modifications in the given order.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 WF] Landscape Generator", "background": "", "description": "### 题目背景\nICPC2020 WF E\nInteractive Creative Players Collective (ICPC)正在创作一款游戏，他们想为它生成真实的地形。一位ICPC工程师受地质过程启发，提出了一种算法，该算法从一个平地开始，重复地通过上升或下降一些连续的区块来改变地形，这样就会形成地垒（即上升的区块）和地堑（即下降的区块）。上升或下降的区块是随机选择的。ICPC希望通过这种方法获得真实的地形。\n\n你的任务是根据所有的更改地形指令输出得到的地形，地形可表示为一个由$n$个整数组成的数组，每个整数代表$x$轴上的点$1$到$n$的海拔高度值。图表E.1是将这些值用折线连接起来的一个例子。\n\n![图表E.1：由样例输入#1生成的地形](https://cdn.luogu.com.cn/upload/image_hosting/t8catonw.png)\n\n最初，这$n$个点的海拔都是0，接下来这个图形会受到一系列的修改，每条修改指令是以下四条之一，并且有两个参数$x_1 \\le x_2$ ：\n\n- $\\texttt{R}$: Raise（上升）——将$x_1$到$x_2$的所有点的海拔均增加$1$。\n- $\\texttt{D}$: Depress（下降）——将$x_1$到$x_2$的所有点的海拔均减少$1$。\n- $\\texttt{H}$: Hill（山丘）——在$x_1$到$x_2$之间形成一座“山丘”。\n- $\\texttt{V}$: Valley（峡谷）——在$x_1$到$x_2$之间形成一条“峡谷”。\n\n向现有地形添加一座“山丘”的原理如下：点$x_1$和$x_2$的海拔增加1；如果$x_2-x_1>1$，那么点$x_1+1$和$x_2-1$的海拔增加2；如果$x_2-x_1>3$，那么点$x_1+2$和$x_2-2$的海拔增加3；以此类推。图表E.2是一个例子。添加一条“峡谷”与上述原理相同，只是海拔是减少而非增加。海拔改变最大的点在$x_1$和$x_2$的中间，如果$x_2-x_1$是偶数，就会有两个相邻的点海拔改变最大，否则只有一个点。\n\n![图表E.2：样例输入#2生成的地形](https://cdn.luogu.com.cn/upload/image_hosting/rl890ge2.png)", "inputFormat": "输入的第一行包含两个整数$n$和$k$，其中$n$ ($1 \\le n \\le 2\\times10^5$)代表点的数量，$k$ ($0 \\le k \\le 2\\times10^5$)代表修改指令的数量。$x$轴上的$n$个点被编号为$1$到$n$。\n\n接下来的$k$行描述修改。每行包含一个字符$c$和两个整数$x_1$和$x_2$，其中$c$ (为$\\texttt{R}$, $\\texttt{D}$, $\\texttt{H}$, $\\texttt{V}$之一)代表操作种类，$x_1$和$x_2$ ($1 \\le x_1 \\le x_2 \\le n$)是具体参数。", "outputFormat": "输出共$n$行，其中第$i$行为所有修改完成后点$i$的海拔。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P8133", "type": "P", "difficulty": 6, "samples": [["4 2\n0 0\n2 4\n4 9\n3 1", "3"], ["3 1\n0 10\n2000 10\n1000 12", "2"]], "limits": {"time": [15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "O2优化", "ICPC", "WF"], "title": "[ICPC 2020 WF] Ley Lines", "background": "ICPC2020 WF F", "description": "In 1921, the amateur archaeologist Alfred Watkins coined the term\n\"ley lines\" to refer to straight lines between numerous places of\ngeographical and historical interest. These lines have often been\nassociated with mysterious and mystical theories, many of which still\npersist.\n\nOne of the common criticisms of ley lines is that lines one draws on a\nmap are actually of non-zero width, and finding \"lines\" that connect\nmultiple places is trivial, given a sufficient density of points and a\nsufficiently thick pencil. In this problem you will explore that\ncriticism.\n\nFor simplicity, we will ignore the curvature of the earth, and just assume\nwe are dealing with a set of points on a plane, each of which has a\nunique $(x, y)$ coordinate, and no three of which lie on a single\nstraight line. Given such a set, and the thickness of your pencil,\nwhat is the largest number of points through which you can draw a\nsingle line?", "inputFormat": "The first line of input consists of two integers $n$ and $t$, where\n$n$ ($3 \\le n \\le 3\\,000$) is the number of points in the set\nand $t$ ($0 \\le t \\le 10^9$) is the thickness of the pencil.\nThen follow $n$ lines,\neach containing two integers $x$ and $y$ ($-10^9 \\le x, y \\le 10^9$),\nindicating the coordinates of a point in the set.\n\nYou may assume that the input is such that the answer would not change\nif the thickness $t$ was increased or decreased by $10^{-2}$, and that no\nthree input points are collinear.", "outputFormat": "Output the maximum number of points that lie on a single \"line\" of\nthickness $t$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 WF] Ley Lines", "background": "ICPC2020 WF F", "description": "In 1921, the amateur archaeologist Alfred Watkins coined the term\n\"ley lines\" to refer to straight lines between numerous places of\ngeographical and historical interest. These lines have often been\nassociated with mysterious and mystical theories, many of which still\npersist.\n\nOne of the common criticisms of ley lines is that lines one draws on a\nmap are actually of non-zero width, and finding \"lines\" that connect\nmultiple places is trivial, given a sufficient density of points and a\nsufficiently thick pencil. In this problem you will explore that\ncriticism.\n\nFor simplicity, we will ignore the curvature of the earth, and just assume\nwe are dealing with a set of points on a plane, each of which has a\nunique $(x, y)$ coordinate, and no three of which lie on a single\nstraight line. Given such a set, and the thickness of your pencil,\nwhat is the largest number of points through which you can draw a\nsingle line?", "inputFormat": "The first line of input consists of two integers $n$ and $t$, where\n$n$ ($3 \\le n \\le 3\\,000$) is the number of points in the set\nand $t$ ($0 \\le t \\le 10^9$) is the thickness of the pencil.\nThen follow $n$ lines,\neach containing two integers $x$ and $y$ ($-10^9 \\le x, y \\le 10^9$),\nindicating the coordinates of a point in the set.\n\nYou may assume that the input is such that the answer would not change\nif the thickness $t$ was increased or decreased by $10^{-2}$, and that no\nthree input points are collinear.", "outputFormat": "Output the maximum number of points that lie on a single \"line\" of\nthickness $t$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 WF] Ley Lines", "background": "", "description": "1921 年，业余考古学家阿尔弗雷德·沃特金斯创造了“能量线”一词，用来指代连接多个地理和历史兴趣点的直线。这些线常常与神秘和神秘的理论联系在一起，其中许多理论至今仍然存在。\n\n关于能量线的一个常见批评是，人们在地图上画的线实际上是有非零宽度的，给定足够密集的点和足够粗的铅笔，找到连接多个地方的“线”是微不足道的。在这个问题中，你将探讨这一批评。\n\n为简单起见，我们将忽略地球的曲率，只假设我们处理的是平面上的一组点，每个点都有唯一的 $(x, y)$ 坐标，并且没有三个点在同一条直线上。给定这样的一组点和铅笔的厚度，你可以通过多少个点画出一条线？", "inputFormat": "输入的第一行由两个整数 $n$ 和 $t$ 组成，其中 $n$ ($3 \\le n \\le 3,000$) 是集合中点的数量，$t$ ($0 \\le t \\le 10^9$) 是铅笔的厚度。接下来是 $n$ 行，每行包含两个整数 $x$ 和 $y$ ($-10^9 \\le x, y \\le 10^9$)，表示集合中一个点的坐标。\n\n你可以假设输入是这样的：如果铅笔的厚度 $t$ 增加或减少 $10^{-2}$，答案不会改变，并且没有三个输入点共线。", "outputFormat": "输出位于厚度为 $t$ 的单条“线”上的最大点数。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P8134", "type": "P", "difficulty": 4, "samples": [["4\n20 5 5\n5 20 5\n5 5 20\n10 10 10", "10 4\n"], ["4\n15 15 5\n5 15 15\n15 5 15\n10 10 10", "10 1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "O2优化", "ICPC", "WF"], "title": "[ICPC 2020 WF] Opportunity Cost", "background": "ICPC2020 WF G", "description": "As with most types of products, buying a new phone can be difficult.\nOne of the main challenges is that there are a lot of different\naspects of the phone that you might care about, such as its price, its\nperformance, and how user-friendly the phone is.\nTypically, there will be no single phone that is simultaneously the\nbest at all of these things: the cheapest phone, the most powerful\nphone, and the most user-friendly phone will likely be different phones.\n\nThus when buying a phone, you are forced to make some sacrifices by\nbalancing the different aspects you care about against each other and\nchoosing the phone that achieves the best compromise (where \"best\"\nof course depends on what your priorities happen to be).  One way of\nmeasuring this sacrifice is known as the *opportunity cost*,\nwhich (for the purposes of this problem) we define as follows.\n\nSuppose that you have bought a phone with price $x$, performance $y$,\nand user-friendliness $z$. For simplicity, we assume that these three\nvalues are measured on a comparable numeric scale where higher is\nbetter. If there are $n$ available phones, and the values\n$(x_i,y_i,z_i)$ represent the (price, performance, user-friendliness)\nof the $i^{\\text{th}}$ phone, then the opportunity cost of your phone\nis defined as\n\n$$\\max _{1 \\leq i \\leq n}\\left(\\max \\left(x_{i}-x, 0\\right)+\\max \\left(y_{i}-y, 0\\right)+\\max \\left(z_{i}-z, 0\\right)\\right)$$\n\n\nWrite a program that, given the list of available phones, finds a\nphone with the minimum opportunity cost.", "inputFormat": "The first line of input contains an integer $n$ ($2 \\leq n \\leq\n200\\,000$), the number of phones considered. Following that are $n$ lines.\nThe $i^{\\text{th}}$ of these lines contains three integers $x_i$, $y_i$, and $z_i$,\nwhere $x_i$ is the price, $y_i$ is the performance, and $z_i$ is the\nuser-friendliness of the $i^{\\text{th}}$ phone ($1 \\leq x_i, y_i, z_i \\leq\n10^9$).", "outputFormat": "Output a single line containing two integers: the smallest possible\nopportunity cost and an integer between $1$ and $n$ indicating the\nphone achieving that opportunity cost. If there are multiple such\nphones, output the one with the smallest index.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 WF] Opportunity Cost", "background": "ICPC2020 WF G", "description": "As with most types of products, buying a new phone can be difficult.\nOne of the main challenges is that there are a lot of different\naspects of the phone that you might care about, such as its price, its\nperformance, and how user-friendly the phone is.\nTypically, there will be no single phone that is simultaneously the\nbest at all of these things: the cheapest phone, the most powerful\nphone, and the most user-friendly phone will likely be different phones.\n\nThus when buying a phone, you are forced to make some sacrifices by\nbalancing the different aspects you care about against each other and\nchoosing the phone that achieves the best compromise (where \"best\"\nof course depends on what your priorities happen to be).  One way of\nmeasuring this sacrifice is known as the *opportunity cost*,\nwhich (for the purposes of this problem) we define as follows.\n\nSuppose that you have bought a phone with price $x$, performance $y$,\nand user-friendliness $z$. For simplicity, we assume that these three\nvalues are measured on a comparable numeric scale where higher is\nbetter. If there are $n$ available phones, and the values\n$(x_i,y_i,z_i)$ represent the (price, performance, user-friendliness)\nof the $i^{\\text{th}}$ phone, then the opportunity cost of your phone\nis defined as\n\n$$\\max _{1 \\leq i \\leq n}\\left(\\max \\left(x_{i}-x, 0\\right)+\\max \\left(y_{i}-y, 0\\right)+\\max \\left(z_{i}-z, 0\\right)\\right)$$\n\n\nWrite a program that, given the list of available phones, finds a\nphone with the minimum opportunity cost.", "inputFormat": "The first line of input contains an integer $n$ ($2 \\leq n \\leq\n200\\,000$), the number of phones considered. Following that are $n$ lines.\nThe $i^{\\text{th}}$ of these lines contains three integers $x_i$, $y_i$, and $z_i$,\nwhere $x_i$ is the price, $y_i$ is the performance, and $z_i$ is the\nuser-friendliness of the $i^{\\text{th}}$ phone ($1 \\leq x_i, y_i, z_i \\leq\n10^9$).", "outputFormat": "Output a single line containing two integers: the smallest possible\nopportunity cost and an integer between $1$ and $n$ indicating the\nphone achieving that opportunity cost. If there are multiple such\nphones, output the one with the smallest index.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 WF] Opportunity Cost", "background": "", "description": "正如大多数类型的产品一样，购买新手机可能是困难的。主要的挑战之一是手机有很多不同的方面可能会影响你的选择，比如价格、性能和用户友好性。通常情况下，不会有一款手机在所有这些方面都是最好的：最便宜的手机、最强大的手机和最用户友好的手机可能是不同的手机。\n\n因此，在购买手机时，你必须在你关心的不同方面之间做出一些妥协，选择一款在这些方面达到最佳平衡的手机（当然，“最佳”取决于你的优先级是什么）。衡量这种妥协的一种方法被称为*机会成本*，在这个问题中，我们将其定义如下。\n\n假设你购买了一款价格为 $x$、性能为 $y$、用户友好性为 $z$ 的手机。为了简化问题，我们假设这三个值是在一个可比较的数值尺度上测量的，数值越高越好。如果有 $n$ 款可用的手机，并且 $(x_i, y_i, z_i)$ 表示第 $i$ 款手机的（价格、性能、用户友好性），那么你手机的机会成本定义为\n\n$$\\max _{1 \\leq i \\leq n}\\left(\\max \\left(x_{i}-x, 0\\right)+\\max \\left(y_{i}-y, 0\\right)+\\max \\left(z_{i}-z, 0\\right)\\right)$$\n\n编写一个程序，给定可用手机的列表，找到机会成本最小的手机。", "inputFormat": "输入的第一行包含一个整数 $n$ ($2 \\leq n \\leq 200,000$)，表示考虑的手机数量。接下来的 $n$ 行中，第 $i$ 行包含三个整数 $x_i$、$y_i$ 和 $z_i$，其中 $x_i$ 是价格，$y_i$ 是性能，$z_i$ 是第 $i$ 款手机的用户友好性（$1 \\leq x_i, y_i, z_i \\leq 10^9$）。", "outputFormat": "输出一行，包含两个整数：最小可能的机会成本和一个介于 $1$ 到 $n$ 之间的整数，表示实现该机会成本的手机。如果有多部这样的手机，输出索引最小的那一部。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P8135", "type": "P", "difficulty": 7, "samples": [["1\n5\n10101\n01110\n10101\n10101\n10101\n", "test 5 4 2 1 3\ntest 4 5 1 3 2\ntest 2 3 4 5 1\ntest 3 1 5 2 4\nanswer 10101"], ["2\n4\n1111\n7\n0001100\n----11-", "test 2 3 4 1\nanswer 1111\ntest 2 3 4 5 6 7 1\ntest 0 0 0 0 2 4 0\nanswer 0101110"]], "limits": {"time": [9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "交互题", "Special Judge", "O2优化", "ICPC", "WF"], "title": "[ICPC 2020 WF] QC QC", "background": "ICPC2020 WF H", "description": "\nInnovative Computable Quality Control (ICQC) has developed a ground-breaking\nnew machine for performing, well, quality control. Thanks to\nits novel Deep Intelligence technology, an ICQC quality control (QC)\nmachine can automatically, with $100\\%$ accuracy, detect manufacturing\nerrors in any machine in existence, whether it is a coffee machine, an\nintergalactic space ship, or a quantum computer.\n\nICQC is now setting up its factory for producing these QC\nmachines. Like any other manufacturing process, some fraction of\nthe produced machines will suffer from malfunctions and these need to\nbe found and discarded. Fortunately, ICQC has just the product\nfor detecting malfunctioning machines!\n\nObviously, ICQC should not simply use a QC machine on itself, since\na malfunctioning machine might incorrectly classify itself as working\ncorrectly. Instead, ICQC will take each batch of $n$ machines\nproduced during a day and have them test each other overnight.\nIn particular, during every hour of the night, each of the $n$ QC\nmachines can run a check on one of the other QC machines, and\nsimultaneously be checked by one other QC machine.\n\nIf the machine running the check is correct, it will correctly report\nwhether the tested machine is correct or malfunctioning, but if the\nmachine running the check is malfunctioning, it may report either result.\nIf a machine A is used to test a machine B multiple times it will return the same result every time, even if machine A is malfunctioning.\nThe exact testing schedule does not have to be fixed in advance,\nso the choice of which machines should check which other machines during\nthe second hour of the night may be based on the result of the tests\nfrom the first hour, and so on.\n\nICQC are $100\\%$ confident that strictly more than a half of the $n$ QC\nmachines in each batch are working correctly, but the night is only $12$\nhours long, so there is only time to do a small number of test rounds.\nCan you help ICQC determine which QC machines are malfunctioning?\n\nFor example, consider Sample Interaction 1 below. After the fourth hour,\nevery machine has tested every other machine. For machine $1$,\nonly one other machine claimed that it was malfunctioning, and if it\nwas truly malfunctioning then at least $3$ of the other machines would\nclaim this. For machine $4$, only one other machine claims that it\nis working, which implies that machine $2$ must be malfunctioning since\nmore than half of the machines are supposed to be working. Note that\neven though machine $4$ is malfunctioning, it still happened to produce\nthe correct responses in these specific test rounds.\n\n\n\n", "inputFormat": "## Interaction\n\n\nThe first line of input contains a single integer $b$ ($1 \\le b \\le 500$),\nthe number of batches to follow. Each batch is independent.\nYou should process each batch\ninteractively, which means the input you receive\nwill depend on the previous output of your program.\n\nThe first line of input for each batch contains a single integer $n$\n($1 \\le n \\le 100$), the number of QC machines in the batch.\nThe interaction then proceeds in rounds. In each round, your program can\nschedule tests for the next hour, by writing a line of\nthe form\n\"$\\texttt{test}$ $\\ x_1\\ x_2\\ \\ldots\\ x_n$\"\nindicating that each machine $i$ should run a test on machine $x_i$.\nIf $x_i=0$, then machine $i$ is idle in that round and performs no test.\nAll positive numbers in the sequence must be distinct.\n\nAfter writing this line, there will be a result to read from the\ninput. The result is one line containing a string of length\n$n$, having a '$\\texttt{1}$' in position $i$ if machine $i$ says that machine $x_i$\nis working correctly, '$\\texttt{0}$' if machine $i$ says that machine $x_i$ is\nmalfunctioning, and '$\\texttt{-}$' (dash) if machine $i$ was idle in the round.\n\nWhen your program has determined which machines are malfunctioning,\nbut no later than after $12$ rounds of tests,\nit must write a line of the form\n\"$\\texttt{answer}$ $S$\"\nwhere $S$ is a binary string of length $n$, having a '$\\texttt{1}$' in position $i$\nif machine $i$ is working correctly, and a '$\\texttt{0}$' if it is malfunctioning.\n\nAfter writing the answer line, your program should start processing\nthe next batch by reading its number $n$. When all $b$ batches have been\nprocessed, the interaction ends and your program should exit.\n\n\n*Notes on interactive judging:*\n\n- *The evaluation is non-adversarial, meaning that the result of each\nmachine testing each other machine is chosen in advance rather than in\nresponse to your queries.*\n- *Do not forget to flush output buffers after writing. See the Addendum to Judging Notes for details.*\n- *You are provided with a command-line tool for local testing, together with input files\ncorresponding to the sample interactions.\nThe tool has comments at the top to explain its use.*\n\n\n", "outputFormat": "", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 WF] QC QC", "background": "ICPC2020 WF H", "description": "\nInnovative Computable Quality Control (ICQC) has developed a ground-breaking\nnew machine for performing, well, quality control. Thanks to\nits novel Deep Intelligence technology, an ICQC quality control (QC)\nmachine can automatically, with $100\\%$ accuracy, detect manufacturing\nerrors in any machine in existence, whether it is a coffee machine, an\nintergalactic space ship, or a quantum computer.\n\nICQC is now setting up its factory for producing these QC\nmachines. Like any other manufacturing process, some fraction of\nthe produced machines will suffer from malfunctions and these need to\nbe found and discarded. Fortunately, ICQC has just the product\nfor detecting malfunctioning machines!\n\nObviously, ICQC should not simply use a QC machine on itself, since\na malfunctioning machine might incorrectly classify itself as working\ncorrectly. Instead, ICQC will take each batch of $n$ machines\nproduced during a day and have them test each other overnight.\nIn particular, during every hour of the night, each of the $n$ QC\nmachines can run a check on one of the other QC machines, and\nsimultaneously be checked by one other QC machine.\n\nIf the machine running the check is correct, it will correctly report\nwhether the tested machine is correct or malfunctioning, but if the\nmachine running the check is malfunctioning, it may report either result.\nIf a machine A is used to test a machine B multiple times it will return the same result every time, even if machine A is malfunctioning.\nThe exact testing schedule does not have to be fixed in advance,\nso the choice of which machines should check which other machines during\nthe second hour of the night may be based on the result of the tests\nfrom the first hour, and so on.\n\nICQC are $100\\%$ confident that strictly more than a half of the $n$ QC\nmachines in each batch are working correctly, but the night is only $12$\nhours long, so there is only time to do a small number of test rounds.\nCan you help ICQC determine which QC machines are malfunctioning?\n\nFor example, consider Sample Interaction 1 below. After the fourth hour,\nevery machine has tested every other machine. For machine $1$,\nonly one other machine claimed that it was malfunctioning, and if it\nwas truly malfunctioning then at least $3$ of the other machines would\nclaim this. For machine $4$, only one other machine claims that it\nis working, which implies that machine $2$ must be malfunctioning since\nmore than half of the machines are supposed to be working. Note that\neven though machine $4$ is malfunctioning, it still happened to produce\nthe correct responses in these specific test rounds.\n\n\n\n", "inputFormat": "## Interaction\n\n\nThe first line of input contains a single integer $b$ ($1 \\le b \\le 500$),\nthe number of batches to follow. Each batch is independent.\nYou should process each batch\ninteractively, which means the input you receive\nwill depend on the previous output of your program.\n\nThe first line of input for each batch contains a single integer $n$\n($1 \\le n \\le 100$), the number of QC machines in the batch.\nThe interaction then proceeds in rounds. In each round, your program can\nschedule tests for the next hour, by writing a line of\nthe form\n\"$\\texttt{test}$ $\\ x_1\\ x_2\\ \\ldots\\ x_n$\"\nindicating that each machine $i$ should run a test on machine $x_i$.\nIf $x_i=0$, then machine $i$ is idle in that round and performs no test.\nAll positive numbers in the sequence must be distinct.\n\nAfter writing this line, there will be a result to read from the\ninput. The result is one line containing a string of length\n$n$, having a '$\\texttt{1}$' in position $i$ if machine $i$ says that machine $x_i$\nis working correctly, '$\\texttt{0}$' if machine $i$ says that machine $x_i$ is\nmalfunctioning, and '$\\texttt{-}$' (dash) if machine $i$ was idle in the round.\n\nWhen your program has determined which machines are malfunctioning,\nbut no later than after $12$ rounds of tests,\nit must write a line of the form\n\"$\\texttt{answer}$ $S$\"\nwhere $S$ is a binary string of length $n$, having a '$\\texttt{1}$' in position $i$\nif machine $i$ is working correctly, and a '$\\texttt{0}$' if it is malfunctioning.\n\nAfter writing the answer line, your program should start processing\nthe next batch by reading its number $n$. When all $b$ batches have been\nprocessed, the interaction ends and your program should exit.\n\n\n*Notes on interactive judging:*\n\n- *The evaluation is non-adversarial, meaning that the result of each\nmachine testing each other machine is chosen in advance rather than in\nresponse to your queries.*\n- *Do not forget to flush output buffers after writing. See the Addendum to Judging Notes for details.*\n- *You are provided with a command-line tool for local testing, together with input files\ncorresponding to the sample interactions.\nThe tool has comments at the top to explain its use.*\n\n\n", "outputFormat": "", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 WF] QC QC", "background": "", "description": "创新可计算质量控制（ICQC）开发了一种突破性的机器，用于执行质量控制。得益于其新颖的深度智能技术，ICQC 质量控制（QC）机器可以以 $100\\%$ 的准确率自动检测任何现有机器的制造错误，无论是咖啡机、星际飞船还是量子计算机。\n\nICQC 现在正在建立其工厂以生产这些 QC 机器。与任何其他制造过程一样，生产的机器中会有一部分出现故障，这些需要被发现并丢弃。幸运的是，ICQC 恰好有产品可以检测故障机器！\n\n显然，ICQC 不应该简单地让 QC 机器自检，因为故障机器可能会错误地将自己分类为正常工作。相反，ICQC 将在夜间让每天生产的 $n$ 台机器相互测试。特别是，在夜间的每个小时，每台 QC 机器可以检查另一台 QC 机器，同时被另一台 QC 机器检查。\n\n如果执行检查的机器是正常的，它将正确报告被测试机器是正常还是故障，但如果执行检查的机器是故障的，它可能报告任一结果。如果机器 A 多次用于测试机器 B，它每次都会返回相同的结果，即使机器 A 是故障的。具体的测试计划不需要提前固定，因此第二小时夜间的机器检查安排可以基于第一小时测试的结果进行。\n\nICQC 确信每批 $n$ 台 QC 机器中有严格超过一半的机器正常工作，但夜晚只有 $12$ 小时，因此只能进行少量的测试轮次。你能帮助 ICQC 确定哪些 QC 机器出现故障吗？\n\n例如，考虑下面的示例交互 1。在第四个小时后，每台机器都测试了其他所有机器。对于机器 $1$，只有一台其他机器声称它故障，如果它真的故障，那么至少有 $3$ 台其他机器会声称这一点。对于机器 $4$，只有一台其他机器声称它正常，这意味着机器 $2$ 必定是故障的，因为应该有超过一半的机器正常工作。注意，即使机器 $4$ 是故障的，它在这些特定的测试轮次中仍然恰好产生了正确的响应。", "inputFormat": "## 交互\n\n输入的第一行包含一个整数 $b$ ($1 \\le b \\le 500$)，表示接下来的批次数量。每批是独立的。你应该以交互方式处理每批，这意味着你收到的输入将取决于程序的先前输出。\n\n每批的输入第一行包含一个整数 $n$ ($1 \\le n \\le 100$)，表示该批中的 QC 机器数量。然后交互以轮次进行。在每轮中，你的程序可以通过写一行形式为“$\\texttt{test}$ $x_1\\ x_2\\ \\ldots\\ x_n$”来安排下一小时的测试，表示每台机器 $i$ 应该对机器 $x_i$ 进行测试。如果 $x_i=0$，则机器 $i$ 在该轮中闲置，不执行测试。序列中的所有正数必须是不同的。\n\n写完这一行后，将有一个结果从输入中读取。结果是一行，包含一个长度为 $n$ 的字符串，在位置 $i$ 上有一个 '$\\texttt{1}$' 表示机器 $i$ 认为机器 $x_i$ 正常工作，'$0$' 表示机器 $i$ 认为机器 $x_i$ 故障，和 '-'（破折号）表示机器 $i$ 在该轮中闲置。\n\n当你的程序确定哪些机器故障时，但不晚于 $12$ 轮测试后，它必须写一行形式为“$\\texttt{answer}$ $S$”，其中 $S$ 是一个长度为 $n$ 的二进制字符串，位置 $i$ 上有一个 '$\\texttt{1}$' 表示机器 $i$ 正常工作，'$0$' 表示它故障。\n\n写完答案行后，你的程序应开始处理下一批，读取其数量 $n$。当所有 $b$ 批次处理完毕后，交互结束，程序应退出。\n\n*交互评估注意事项：*\n\n- *评估是非对抗性的，这意味着每台机器测试其他机器的结果是预先选择的，而不是响应你的查询。*\n- *写完后不要忘记刷新输出缓冲区。有关详细信息，请参阅评估说明附录。*\n- *为本地测试提供了一个命令行工具，以及对应于示例交互的输入文件。该工具顶部有注释以解释其使用。*", "outputFormat": "", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P8136", "type": "P", "difficulty": 6, "samples": [["3 10 2\n15 1\n2 2\n9 1", "43"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "O2优化", "背包 DP", "ICPC", "bitset", "WF"], "title": "[ICPC 2020 WF] Quests", "background": "ICPC2020 WF I", "description": "To relax before competing in the ICPC World Finals, you have decided to play a\ncomputer game called *Quests*. You have played it a\nnumber of times already, and now you want to achieve a perfect\nplaythrough---to prepare for your perfect playthrough of the finals!\n\nIn the game, you have to complete a number\nof quests, and you earn experience points (XPs) for completing each one. The\ntotal number of XPs you have earned at any time determines your current level. You\nreach a new level for every $v$ XPs that you earn. Formally, your level at\nany time is the largest integer $L$ such that you have at least $L \\cdot v$\nXPs.\n\nEach quest is assigned a number $x$ of XPs and a target\ndifficulty level $d$. If you complete the quest when your level is at least\n$d$, you earn $x$ XPs. However, if you complete the quest when your level is\nless than $d$, you will earn $c \\cdot x$ XPs. The constant  $c$ is an XP multiplier\nthat results in a bonus for completing a\nquest when you are at a lower level than the recommended level $d$.\n\nYou know all the $n$ quests and their respective $x$ and $d$ numbers by heart\n(and you know the numbers $v$ and $c$ as well---you have played this game a lot).\nYou are also skilled enough to\ncomplete any quest, regardless of its target difficulty level and your level.\nYou want to complete all the quests in an order that will allow you\nto earn the largest possible number of XPs.\n\nFor example in the sample input, the maximum XPs you can earn is 43, which\nis done as follows. First complete the second quest (you earn $4$ XPs,\nbecause you are at level $0$, and you completed a quest with target difficulty\nlevel $2$). Then complete the first quest (you earn $30$ XPs, because you are\nstill at level $0$, and the target difficulty level is $1$). With $34$ XPs, you\nare now level $3$. Finally, complete the third quest (for which you earn $9$\nXPs, without the multiplier, since you are already at level $3$).", "inputFormat": "The first line of input contains three integers $n$, $v$, and $c$, where\n$n$ $(1 \\leq n \\leq 2\\,000)$ is the number of quests in the game, $v$\n$(1 \\leq v \\leq 2\\,000)$ is the number of XPs required to reach each level,\nand $c$ $(2 \\leq c \\leq 2\\,000)$ is the XP multiplier for completing a quest\nbefore reaching its target difficulty level.\n\nFollowing that are $n$ lines, each of which contains two integers $x$ and $d$\ndescribing one quest, where $x$ $(1 \\leq x \\leq 2\\,000)$ is the number of XPs\nyou earn for completing that quest if you are at or above its target difficulty\nlevel and $d$ $(1 \\leq d_i \\leq 10^6)$ is the target difficulty level for that\nquest.", "outputFormat": "Output the maximum possible number of XPs you could earn by finishing all the\nquests.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 WF] Quests", "background": "ICPC2020 WF I", "description": "To relax before competing in the ICPC World Finals, you have decided to play a\ncomputer game called *Quests*. You have played it a\nnumber of times already, and now you want to achieve a perfect\nplaythrough---to prepare for your perfect playthrough of the finals!\n\nIn the game, you have to complete a number\nof quests, and you earn experience points (XPs) for completing each one. The\ntotal number of XPs you have earned at any time determines your current level. You\nreach a new level for every $v$ XPs that you earn. Formally, your level at\nany time is the largest integer $L$ such that you have at least $L \\cdot v$\nXPs.\n\nEach quest is assigned a number $x$ of XPs and a target\ndifficulty level $d$. If you complete the quest when your level is at least\n$d$, you earn $x$ XPs. However, if you complete the quest when your level is\nless than $d$, you will earn $c \\cdot x$ XPs. The constant  $c$ is an XP multiplier\nthat results in a bonus for completing a\nquest when you are at a lower level than the recommended level $d$.\n\nYou know all the $n$ quests and their respective $x$ and $d$ numbers by heart\n(and you know the numbers $v$ and $c$ as well---you have played this game a lot).\nYou are also skilled enough to\ncomplete any quest, regardless of its target difficulty level and your level.\nYou want to complete all the quests in an order that will allow you\nto earn the largest possible number of XPs.\n\nFor example in the sample input, the maximum XPs you can earn is 43, which\nis done as follows. First complete the second quest (you earn $4$ XPs,\nbecause you are at level $0$, and you completed a quest with target difficulty\nlevel $2$). Then complete the first quest (you earn $30$ XPs, because you are\nstill at level $0$, and the target difficulty level is $1$). With $34$ XPs, you\nare now level $3$. Finally, complete the third quest (for which you earn $9$\nXPs, without the multiplier, since you are already at level $3$).", "inputFormat": "The first line of input contains three integers $n$, $v$, and $c$, where\n$n$ $(1 \\leq n \\leq 2\\,000)$ is the number of quests in the game, $v$\n$(1 \\leq v \\leq 2\\,000)$ is the number of XPs required to reach each level,\nand $c$ $(2 \\leq c \\leq 2\\,000)$ is the XP multiplier for completing a quest\nbefore reaching its target difficulty level.\n\nFollowing that are $n$ lines, each of which contains two integers $x$ and $d$\ndescribing one quest, where $x$ $(1 \\leq x \\leq 2\\,000)$ is the number of XPs\nyou earn for completing that quest if you are at or above its target difficulty\nlevel and $d$ $(1 \\leq d_i \\leq 10^6)$ is the target difficulty level for that\nquest.", "outputFormat": "Output the maximum possible number of XPs you could earn by finishing all the\nquests.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 WF] Quests", "background": "", "description": "为了在参加 ICPC 世界总决赛前放松一下，你决定玩一款名为 *Quests* 的电脑游戏。你已经玩过很多次了，现在你想要实现完美通关——为总决赛的完美表现做准备！\n\n在游戏中，你需要完成多个任务，并且每完成一个任务都会获得经验值（XP）。你在任何时候获得的总 XP 数量决定了你的当前等级。每当你获得 $v$ 个 XP 时，你就能达到一个新的等级。正式地说，你在任何时候的等级是最大的整数 $L$，使得你至少有 $L \\cdot v$ 个 XP。\n\n每个任务都有一个 XP 数量 $x$ 和一个目标难度等级 $d$。如果你在等级至少为 $d$ 时完成任务，你将获得 $x$ 个 XP。然而，如果你在等级低于 $d$ 时完成任务，你将获得 $c \\cdot x$ 个 XP。常数 $c$ 是一个 XP 倍增器，当你在低于推荐等级 $d$ 时完成任务时会获得奖励。\n\n你已经熟记所有 $n$ 个任务及其各自的 $x$ 和 $d$ 数字（你也知道数字 $v$ 和 $c$——你玩这个游戏很多次了）。你也有足够的技巧来完成任何任务，无论其目标难度等级和你的等级如何。你想要以一种能让你获得最大可能 XP 的顺序完成所有任务。\n\n例如，在示例输入中，你能获得的最大 XP 是 43，具体如下。首先完成第二个任务（你获得 4 个 XP，因为你在等级 0 时完成了一个目标难度等级为 2 的任务）。然后完成第一个任务（你获得 30 个 XP，因为你仍然在等级 0，目标难度等级为 1）。有了 34 个 XP，你现在是等级 3。最后，完成第三个任务（你获得 9 个 XP，没有倍增器，因为你已经在等级 3）。", "inputFormat": "输入的第一行包含三个整数 $n$、$v$ 和 $c$，其中 $n$ $(1 \\leq n \\leq 2\\,000)$ 是游戏中的任务数量，$v$ $(1 \\leq v \\leq 2\\,000)$ 是达到每个等级所需的 XP 数量，$c$ $(2 \\leq c \\leq 2\\,000)$ 是在达到目标难度等级之前完成任务的 XP 倍增器。\n\n接下来是 $n$ 行，每行包含两个整数 $x$ 和 $d$ 描述一个任务，其中 $x$ $(1 \\leq x \\leq 2\\,000)$ 是如果你在或高于其目标难度等级时完成该任务所获得的 XP 数量，$d$ $(1 \\leq d_i \\leq 10^6)$ 是该任务的目标难度等级。", "outputFormat": "输出通过完成所有任务可以获得的最大可能 XP 数量。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P8137", "type": "P", "difficulty": 5, "samples": [["7\n1 4 2\n2 4 3\n3 4 1\n4 5 1\n5 6 2\n5 7 4", "15"], ["4\n1 2 1\n2 3 2\n3 4 3", "6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "O2优化", "ICPC", "WF"], "title": "[ICPC 2020 WF] 'S No Problem", "background": "ICPC2020 WF J", "description": "The Yllihc Engineering and Technological Institute (YETI),\nlocated in upper northern Snowblovia, has two problems: snow\nand money. Specifically, they have too much of the former and not\nenough of the latter. Every winter (and fall and spring for that matter)\nthe campus is covered with blankets of snow. The maintenance staff\nmust clear all the sidewalks connecting the campus buildings, but they\nhave only two snow blowers and have been told in no uncertain\nterms that they cannot expect to obtain any more in the near future.\n\nTo preserve the longevity of these two precious machines,\nthe staff has decided on the following snow removal procedure.\nEach machine is assigned a fixed route connecting two of the\nbuildings on campus. Whenever snow must be removed, each snow blower\nis taken from the building at one end of its route and used to clear snow,\nending up in the building at the other end of its route, where it is\nstored until the next snowfall.\nThe reverse movement will occur during the next snow removal event---each\nmachine will trace its assigned route in the opposite direction.\nThis process cycles throughout the eleven-month snow season.\nNote that a route might involve doubling back over sidewalks that\nhave already been cleared. Also, it is\npossible that the same building might be an endpoint for both\nsnow blower routes.\n\nThe campus sidewalks are laid out in the form of a tree.\nTo run the machines as little as possible, the staff wants\nto minimize the total distance\nthat the snow blowers must travel as they are guided along their routes.\nFigure J.1 shows an optimal\nsolution for the sidewalk layout of the first sample input.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xu2fv7az.png)\n\nThe YETI maintenance crew would ask the Computer Science Department\nat YETI to figure this out, but they were wiped out in the Great\nBlizzard of '$06$, so they have come to you for help.", "inputFormat": "The first line of input contains an integer $n$ ($4\\leq n\\leq 100\\,000$),\nthe number of buildings on the YETI campus. Buildings are numbered from $1$\nto $n$.\nEach of the remaining $n-1$ lines contains three integers\n$a$, $b$, and $d$\nindicating that a two-way sidewalk exists between buildings $a$ and $b$\n($1 \\leq a, b \\leq n$; $a\\ne b$) of length $d$ ($1\\leq d\\leq 500$).", "outputFormat": "Output the minimum total distance the two machines must travel in\nany snow removal event.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 WF] 'S No Problem", "background": "ICPC2020 WF J", "description": "The Yllihc Engineering and Technological Institute (YETI),\nlocated in upper northern Snowblovia, has two problems: snow\nand money. Specifically, they have too much of the former and not\nenough of the latter. Every winter (and fall and spring for that matter)\nthe campus is covered with blankets of snow. The maintenance staff\nmust clear all the sidewalks connecting the campus buildings, but they\nhave only two snow blowers and have been told in no uncertain\nterms that they cannot expect to obtain any more in the near future.\n\nTo preserve the longevity of these two precious machines,\nthe staff has decided on the following snow removal procedure.\nEach machine is assigned a fixed route connecting two of the\nbuildings on campus. Whenever snow must be removed, each snow blower\nis taken from the building at one end of its route and used to clear snow,\nending up in the building at the other end of its route, where it is\nstored until the next snowfall.\nThe reverse movement will occur during the next snow removal event---each\nmachine will trace its assigned route in the opposite direction.\nThis process cycles throughout the eleven-month snow season.\nNote that a route might involve doubling back over sidewalks that\nhave already been cleared. Also, it is\npossible that the same building might be an endpoint for both\nsnow blower routes.\n\nThe campus sidewalks are laid out in the form of a tree.\nTo run the machines as little as possible, the staff wants\nto minimize the total distance\nthat the snow blowers must travel as they are guided along their routes.\nFigure J.1 shows an optimal\nsolution for the sidewalk layout of the first sample input.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xu2fv7az.png)\n\nThe YETI maintenance crew would ask the Computer Science Department\nat YETI to figure this out, but they were wiped out in the Great\nBlizzard of '$06$, so they have come to you for help.", "inputFormat": "The first line of input contains an integer $n$ ($4\\leq n\\leq 100\\,000$),\nthe number of buildings on the YETI campus. Buildings are numbered from $1$\nto $n$.\nEach of the remaining $n-1$ lines contains three integers\n$a$, $b$, and $d$\nindicating that a two-way sidewalk exists between buildings $a$ and $b$\n($1 \\leq a, b \\leq n$; $a\\ne b$) of length $d$ ($1\\leq d\\leq 500$).", "outputFormat": "Output the minimum total distance the two machines must travel in\nany snow removal event.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 WF] 'S No Problem", "background": "", "description": "位于斯诺布洛维亚北部的 某·工程技术学院 (YETI) 面临两个问题：雪和金钱。具体来说，他们有太多的前者而没有足够的后者。每年冬天（以及秋天和春天），校园都覆盖着雪毯。维护人员必须清理连接校园建筑的所有人行道，但他们只有两台吹雪机，并且已经明确告知他们在不久的将来不能再获得更多。\n\n为了保持这两台珍贵机器的使用寿命，工作人员决定采用以下除雪程序。每台机器都被分配了一条连接校园内两座建筑物的固定路线。每当必须除雪时，每台吹雪机都会从其路线一端的建筑物中取出并用于清除积雪，最终进入其路线另一端的建筑物中，并存放在那里直到下一次降雪。在下一次除雪活动期间将发生反向运动——每台机器将沿相反方向追踪其分配的路线。这个过程在整个 1 个月的雪季循环。请注意，路线可能涉及翻过已清理的人行道。此外，同一建筑物可能是两条吹雪机路线的终点。\n\n校园人行道以树的形式布置。为了尽可能少地运行机器，工作人员希望尽量减少吹雪机在沿路线引导时必须行驶的总距离。图 J.1 显示了第一个样本输入的人行道布局的最佳解决方案。\n\nYETI 维护人员会要求 YETI 的计算机科学系解决这个问题，但他们在 06 年的大暴雪中失败了，所以他们来找你帮忙。", "inputFormat": "输入的第一行包含一个整数 n(4≤n≤100000)，即 YETI 校园内的建筑物数量。 建筑物的编号从 1 到 n。其余n−1 行中的每一行包含三个整数 a、b和d，表示建筑物 a和 b之间存在双向人行道 (1≤a,b≤n) 长度为 d(1≤d≤500)。", "outputFormat": "输出两台机器在任何除雪事件中必须行驶的最小总距离。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P8138", "type": "P", "difficulty": 7, "samples": [["9 2\n1 1 1 7 7 7\n0 0 0 3 3 3\n5 0 0 8 3 3\n0 5 0 3 8 3\n0 0 5 3 3 8\n5 5 0 8 8 3\n5 0 5 8 3 8\n0 5 5 3 8 8\n5 5 5 8 8 8\n0 1 0 z- x+\n3 5 1 z- y+", "44"], ["1 3\n0 0 0 1 1 1\n0 0 0 x+ z+\n0 0 0 y+ x+\n0 0 0 z- y+", "ok"], ["1 2\n0 0 0 2 1 1\n0 0 0 y+ x+\n1 0 0 y+ x-", "0"]], "limits": {"time": [14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500, 14500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "O2优化", "ICPC", "WF"], "title": "[ICPC 2020 WF] Space Walls", "background": "ICPC2020 WF K", "description": "Place-Y Technology Corp. plans to launch a new space station soon. The company\nCEO is known for being obsessed with perfection. For example, he insists that all\nthe outer surfaces of the space station are regularly polished and cleaned of\nwhat he calls ``space debris,'' mainly for the station to appear good in photos.\nThe engineering team tried but failed to convince the CEO that this was not needed. So instead they\ndeveloped an innovative technology to maintain the surfaces while minimizing human\noperations outside the station. The maintenance is performed by several\nsmall robots moving over the space station surface, just like robotic\nvacuum cleaners. Before their first flight, Place-Y needs to assess the risks of\ncollision during the operation of the robots. And this is exactly where you step\nin.\n\nFor the purposes of this problem, we model the space station as a collection of\naxis-aligned unit cubes (not necessarily connected). Each robot starts at time $t=0$ in the center of an exposed face\nof one of the station's unit cubes (that is, a face which is not shared by a second station\ncube). The robot is oriented in one of the four directions parallel to an edge of the cube face.\nEvery time unit, the robot moves straight ahead to another cube face, possibly\npivoting $90$ degrees across the space station edges so that it always maintains\ncontact with the station.  Note that if two cubes share an edge, the robot cannot\nslip between them (there is no gap).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sh28cno8.png)\n\nGiven the layout of the station and starting\npositions of all the cleaning robots, determine the time of the earliest collision (if any).  The time a collision occurs is either the time unit when two or more robots are on the interior of the same cube\nface or the time unit when two robots attempt to swap locations (see Sample Input 3 for the\nlatter case).", "inputFormat": "The first line of input contains two integers $n$ and $k$, where $n$\n($1 \\le n \\le 100$) is the number of regions describing the space station shape,\nand $k$ ($0 \\le k \\le 100$) is the number of robots on the surface.\n\nEach of the following $n$ lines contains six integer coordinates $x_1$, $y_1$, $z_1$,\n$x_2$, $y_2$, and $z_2$ ($0 \\le x_1 < x_2 \\le 10^6$, $0 \\le y_1 < y_2 \\le 10^6$,\n$0 \\le z_1 < z_2 \\le 10^6$) describing one region and denoting that all the points\n$x,y,z$ satisfying $x_1 \\le x \\le x_2$, $y_1 \\le y \\le y_2$,\n$z_1 \\le z \\le z_2$ are part of the space station. Note that some\nunit cubes may be included in more than one region.\n\nThen follow $k$ lines, each describing the starting position of one robot.  Such\na line contains three coordinates $x$, $y$, and $z$, and two directions $\\vec{f}$\nand $\\vec{d}$. The coordinates specify that the robot starts at a face of the\nunit cube $(x,y,z) - (x+1,y+1,z+1)$. The particular face is determined by\n$\\vec{f}$ and the initial direction of movement is determined by $\\vec{d}$.\nBoth $\\vec{f}$ and $\\vec{d}$ are specified by one of the six strings $\\tt x+$, $\\tt x-$, $\\tt y+$,\n$\\tt y-$, $\\tt z+$, or $\\tt z-$, where $\\tt x+$ designates the positive direction\nof the x-axis $(1,0,0)$, and so on. The axis letter in $\\vec{f}$ will be different\nfrom the axis letter in $\\vec{d}$. It is guaranteed that the starting cube\nbelongs to the space station and the given face is an exposed face.", "outputFormat": "Output the time of the first collision. If there will never be a collision,\noutput $\\tt ok$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 WF] Space Walls", "background": "ICPC2020 WF K", "description": "Place-Y Technology Corp. plans to launch a new space station soon. The company\nCEO is known for being obsessed with perfection. For example, he insists that all\nthe outer surfaces of the space station are regularly polished and cleaned of\nwhat he calls ``space debris,'' mainly for the station to appear good in photos.\nThe engineering team tried but failed to convince the CEO that this was not needed. So instead they\ndeveloped an innovative technology to maintain the surfaces while minimizing human\noperations outside the station. The maintenance is performed by several\nsmall robots moving over the space station surface, just like robotic\nvacuum cleaners. Before their first flight, Place-Y needs to assess the risks of\ncollision during the operation of the robots. And this is exactly where you step\nin.\n\nFor the purposes of this problem, we model the space station as a collection of\naxis-aligned unit cubes (not necessarily connected). Each robot starts at time $t=0$ in the center of an exposed face\nof one of the station's unit cubes (that is, a face which is not shared by a second station\ncube). The robot is oriented in one of the four directions parallel to an edge of the cube face.\nEvery time unit, the robot moves straight ahead to another cube face, possibly\npivoting $90$ degrees across the space station edges so that it always maintains\ncontact with the station.  Note that if two cubes share an edge, the robot cannot\nslip between them (there is no gap).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sh28cno8.png)\n\nGiven the layout of the station and starting\npositions of all the cleaning robots, determine the time of the earliest collision (if any).  The time a collision occurs is either the time unit when two or more robots are on the interior of the same cube\nface or the time unit when two robots attempt to swap locations (see Sample Input 3 for the\nlatter case).", "inputFormat": "The first line of input contains two integers $n$ and $k$, where $n$\n($1 \\le n \\le 100$) is the number of regions describing the space station shape,\nand $k$ ($0 \\le k \\le 100$) is the number of robots on the surface.\n\nEach of the following $n$ lines contains six integer coordinates $x_1$, $y_1$, $z_1$,\n$x_2$, $y_2$, and $z_2$ ($0 \\le x_1 < x_2 \\le 10^6$, $0 \\le y_1 < y_2 \\le 10^6$,\n$0 \\le z_1 < z_2 \\le 10^6$) describing one region and denoting that all the points\n$x,y,z$ satisfying $x_1 \\le x \\le x_2$, $y_1 \\le y \\le y_2$,\n$z_1 \\le z \\le z_2$ are part of the space station. Note that some\nunit cubes may be included in more than one region.\n\nThen follow $k$ lines, each describing the starting position of one robot.  Such\na line contains three coordinates $x$, $y$, and $z$, and two directions $\\vec{f}$\nand $\\vec{d}$. The coordinates specify that the robot starts at a face of the\nunit cube $(x,y,z) - (x+1,y+1,z+1)$. The particular face is determined by\n$\\vec{f}$ and the initial direction of movement is determined by $\\vec{d}$.\nBoth $\\vec{f}$ and $\\vec{d}$ are specified by one of the six strings $\\tt x+$, $\\tt x-$, $\\tt y+$,\n$\\tt y-$, $\\tt z+$, or $\\tt z-$, where $\\tt x+$ designates the positive direction\nof the x-axis $(1,0,0)$, and so on. The axis letter in $\\vec{f}$ will be different\nfrom the axis letter in $\\vec{d}$. It is guaranteed that the starting cube\nbelongs to the space station and the given face is an exposed face.", "outputFormat": "Output the time of the first collision. If there will never be a collision,\noutput $\\tt ok$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 WF] Space Walls", "background": "", "description": "", "inputFormat": "每个机器人每次启动一开始t=0\n每次机器人到另一个面，可能会旋转90°两个立方体共享一条边时，机器人无法在之间走动。\n\n第一行输入n,k,n是空间站形状的区域数,k是机器人的数量。\n\n接下来n行6个数据分别是：($0 \\le x_1 < x_2 \\le 10^6$, $0 \\le y_1 < y_2 \\le 10^6$,\n$0 \\le z_1 < z_2 \\le 10^6$) \n\n是一个区域中的所有点。满足$x_1 \\le x \\le x_2$, $y_1 \\le y \\le y_2$,\n$z_1 \\le z \\le z_2$\n请注意，一些立方体可能包含在多个区域中。\n\n接下来k行，每一行代表机器人的位置。有x,y,z以及两个方向f,d,指定面由f确定,初始移动方向由d确定.六种操作x+,x-,y+,y-,z+,z-.\nx+表示（1,0,0）的方向，依此类推。f不等于d.\n\n保证起始立方体属于空间站，并且给定的初始面是外面。", "outputFormat": "输出第一次碰撞的时间。如果永远不会发生冲突，则输出ok", "hint": "", "locale": "zh-CN"}}}
{"pid": "P8139", "type": "P", "difficulty": 7, "samples": [["2 2 1 2\n0.05 0.05\n0.05 0.05\n1 1 1\n2 2 1 1 2", "0.75 0.25\n0.5 0.5 0"], ["3 4 3 4\n0.02 0.04 0.06\n0.005 0.07 0.035 0.09\n1 3 2\n3 1 4 2 4 3 4\n4 1 2 2 3 3 1 1 4\n8 1 1 1 2 1 3 2 1 2 3 3 1 3 2 3 3", "0.649469772 0.350530228\n0.219607636 0.527423751 0.237646792 0.015321822\n0.267615440 0.516222318 0.201611812 0.014550429 0\n0.054047935 0.364731941 0.461044157 0.120175967 0 0 0 0 0"]], "limits": {"time": [12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "Special Judge", "O2优化", "ICPC", "WF"], "title": "[ICPC 2020 WF] Sweep Stakes", "background": "ICPC2020 WF L", "description": "You may have already won! In fact, you did already win! You won your very own\nisland, in the deepest reaches of the unexplored ocean! Well, mostly unexplored.\nAs it happens, there was a small military base there before you, and when they\npacked up and flew out they left behind an assortment of scraps, munitions,\ntunnels, $\\ldots$ and unexploded defensive ordnance. That's right: You now possess\nyour very own minefield.\n\nThe minefield consists of an $m\\times n$ grid, with any square of the grid holding\n0 or 1 mines. Fortunately, you were able to recover the engineers' plans from when\nthey deployed the mines. Unfortunately, the exact locations of the mines were never\nwritten down: the engineers had a preselected independent probability of deploying\na mine in each square. However, you do know how many mines were placed in total.\n\nYou would like to estimate how safe various parts of your island are. Write a\nprogram to compute the probability of mine counts over various subsets of the\nminefield.", "inputFormat": "The first line of input contains four integers $m$, $n$, $t$, and $q$, where $m$\nand $n$ ($1 \\leq m,n \\leq 500$) are the dimensions of the minefield, $t$ \n($0 \\leq t \\leq mn$) is the total number of mines, and $q$ ($0 \\leq q \\leq 500$)\nis the number of queries. The second line contains $m$ real numbers \n$p_1, p_2, \\ldots, p_m$ ($0 \\leq p_i \\leq 0.1$ for all $i$, with at most six digits\nafter the decimal point specified), and the third line\ncontains $n$ real numbers $q_1, q_2, \\ldots, q_n$ ($0 \\leq q_j \\leq 0.1$ for all\n$j$, with at most six digits after the decimal point specified).\nThe preselected probability of the engineers placing a mine on square $(i, j)$\nis $p_i + q_j$. All choices of whether to place a mine on a given square were made\nindependently, and the value of $t$ is chosen so that the probability of deploying\nexactly $t$ mines is at least $10^{-5}$. \n\nEach of the remaining $q$ lines describes a single query. Each of those lines\nbegins with an integer $s$ ($0 \\leq s \\leq 500$), followed by $s$ pairs of integers\n$i$ and $j$ ($1 \\leq i \\leq m$, $1 \\leq j \\leq n$), which are the coordinates of $s$\ndistinct squares in the grid.", "outputFormat": "For each query with $s$ squares, output $s+1$ real numbers, which are the\nprobabilities of the $s$ given squares containing $0, 1, \\ldots, s$ mines. Your\nanswer should have an absolute error of at most $10^{-6}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 WF] Sweep Stakes", "background": "ICPC2020 WF L", "description": "You may have already won! In fact, you did already win! You won your very own\nisland, in the deepest reaches of the unexplored ocean! Well, mostly unexplored.\nAs it happens, there was a small military base there before you, and when they\npacked up and flew out they left behind an assortment of scraps, munitions,\ntunnels, $\\ldots$ and unexploded defensive ordnance. That's right: You now possess\nyour very own minefield.\n\nThe minefield consists of an $m\\times n$ grid, with any square of the grid holding\n0 or 1 mines. Fortunately, you were able to recover the engineers' plans from when\nthey deployed the mines. Unfortunately, the exact locations of the mines were never\nwritten down: the engineers had a preselected independent probability of deploying\na mine in each square. However, you do know how many mines were placed in total.\n\nYou would like to estimate how safe various parts of your island are. Write a\nprogram to compute the probability of mine counts over various subsets of the\nminefield.", "inputFormat": "The first line of input contains four integers $m$, $n$, $t$, and $q$, where $m$\nand $n$ ($1 \\leq m,n \\leq 500$) are the dimensions of the minefield, $t$ \n($0 \\leq t \\leq mn$) is the total number of mines, and $q$ ($0 \\leq q \\leq 500$)\nis the number of queries. The second line contains $m$ real numbers \n$p_1, p_2, \\ldots, p_m$ ($0 \\leq p_i \\leq 0.1$ for all $i$, with at most six digits\nafter the decimal point specified), and the third line\ncontains $n$ real numbers $q_1, q_2, \\ldots, q_n$ ($0 \\leq q_j \\leq 0.1$ for all\n$j$, with at most six digits after the decimal point specified).\nThe preselected probability of the engineers placing a mine on square $(i, j)$\nis $p_i + q_j$. All choices of whether to place a mine on a given square were made\nindependently, and the value of $t$ is chosen so that the probability of deploying\nexactly $t$ mines is at least $10^{-5}$. \n\nEach of the remaining $q$ lines describes a single query. Each of those lines\nbegins with an integer $s$ ($0 \\leq s \\leq 500$), followed by $s$ pairs of integers\n$i$ and $j$ ($1 \\leq i \\leq m$, $1 \\leq j \\leq n$), which are the coordinates of $s$\ndistinct squares in the grid.", "outputFormat": "For each query with $s$ squares, output $s+1$ real numbers, which are the\nprobabilities of the $s$ given squares containing $0, 1, \\ldots, s$ mines. Your\nanswer should have an absolute error of at most $10^{-6}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 WF] Sweep Stakes", "background": "", "description": "你可能已经赢了！事实上，你确实赢了！你赢得了属于你自己的岛屿，位于未被探索的海洋最深处！嗯，几乎未被探索。事实是，在你之前那里有一个小型军事基地，当他们打包飞走时，留下了一些废料、弹药、隧道，等等，当然还有未爆炸的防御军火。没错：你现在拥有了你自己的雷区。\n\n雷区由一个 $m \\times n$ 的网格组成，网格的任意方格上可能有 0 或 1 个地雷。幸运的是，你找到了工程师们布雷时的计划。不幸的是，地雷的具体位置从未被记录下来：工程师们在每个方格上布雷的概率是预先独立选择的。然而，你知道总共放置了多少个地雷。\n\n你想估计你岛屿各个部分的安全性。编写一个程序来计算雷区各个子集上的地雷数量的概率。", "inputFormat": "输入的第一行包含四个整数 $m$、$n$、$t$ 和 $q$，其中 $m$ 和 $n$（$1 \\leq m,n \\leq 500$）是雷区的维度，$t$（$0 \\leq t \\leq mn$）是地雷的总数，$q$（$0 \\leq q \\leq 500$）是查询的数量。第二行包含 $m$ 个实数 $p_1, p_2, \\ldots, p_m$（对于所有 $i$，$0 \\leq p_i \\leq 0.1$，小数点后最多六位），第三行包含 $n$ 个实数 $q_1, q_2, \\ldots, q_n$（对于所有 $j$，$0 \\leq q_j \\leq 0.1$，小数点后最多六位）。工程师在方格 $(i, j)$ 上放置地雷的预选概率是 $p_i + q_j$。是否在给定方格上放置地雷的选择是独立进行的，并且 $t$ 的值是选择的，使得恰好布置 $t$ 个地雷的概率至少为 $10^{-5}$。\n\n接下来的每一行描述一个查询。每行以一个整数 $s$（$0 \\leq s \\leq 500$）开始，后面是 $s$ 对整数 $i$ 和 $j$（$1 \\leq i \\leq m$，$1 \\leq j \\leq n$），它们是网格中 $s$ 个不同方格的坐标。", "outputFormat": "对于每个包含 $s$ 个方格的查询，输出 $s+1$ 个实数，表示 $s$ 个给定方格中包含 $0, 1, \\ldots, s$ 个地雷的概率。你的答案的绝对误差应不超过 $10^{-6}$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P8140", "type": "P", "difficulty": 6, "samples": [["57 9 1000", "2"], ["57 4 40000", "3"], ["57 4 39000", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "O2优化", "ICPC", "WF"], "title": "[ICPC 2020 WF] Trailing Digits", "background": "ICPC2020 WF M", "description": "A large shipment of doodads has just arrived, and each doodad has a suggested retail price of $b$ cents. You've noticed that consumers are much more likely to purchase goods when most of the trailing digits are the same. For example, items are more likely to be priced at $99$ cents rather than $57$ cents. So to make your goods more appealing, you've decided to sell your goods in bundles. To make a bundle, you choose a positive integer $k$, and sell $k$ doodads for $k \\times b$ cents. With an appropriate choice of $k$ you can have a more pleasing price. For example, selling $57$-cent doodads in bundles of size $7$ means that each bundle sells for $399$ cents, which has two trailing $9$s, rather than no trailing $9$s of $57$. This idea of trailing $9$s can be generalized to any other trailing digit: bundles of $692$ $57$-cent doodads sell for $39\\,444$ cents (three trailing $4$s) and bundles of one million doodads sell for $57\\,000\\,000$ cents (six trailing $0$s).\n\nAfter a little thought, you realize that you do not want to make your bundles too large---not only can the price be excessive, but who really needs several million doodads? For any type of doodad, your marketing department has a maximum bundle price of $a$.\n\nGiven the price of a doodad, the desired trailing digit, and the maximum price of a bundle, write a program that optimizes the trailing digits.", "inputFormat": "Input consists of a single line containing three integers $b$, $d$, and $a$, where $b$ ($1 \\leq b < 10^{6}$) is the price of a doodad in cents, $d$ ($0 \\leq d \\leq 9$) is the desired trailing digit, and $a$ ($b \\leq a < 10^{10\\,000}$) is the maximum price of a bundle.", "outputFormat": "Output the maximum number of consecutive occurrences of $d$ that can appear at the end of a bundle price, given that the price of the bundle cannot exceed $a$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 WF] Trailing Digits", "background": "ICPC2020 WF M", "description": "A large shipment of doodads has just arrived, and each doodad has a suggested retail price of $b$ cents. You've noticed that consumers are much more likely to purchase goods when most of the trailing digits are the same. For example, items are more likely to be priced at $99$ cents rather than $57$ cents. So to make your goods more appealing, you've decided to sell your goods in bundles. To make a bundle, you choose a positive integer $k$, and sell $k$ doodads for $k \\times b$ cents. With an appropriate choice of $k$ you can have a more pleasing price. For example, selling $57$-cent doodads in bundles of size $7$ means that each bundle sells for $399$ cents, which has two trailing $9$s, rather than no trailing $9$s of $57$. This idea of trailing $9$s can be generalized to any other trailing digit: bundles of $692$ $57$-cent doodads sell for $39\\,444$ cents (three trailing $4$s) and bundles of one million doodads sell for $57\\,000\\,000$ cents (six trailing $0$s).\n\nAfter a little thought, you realize that you do not want to make your bundles too large---not only can the price be excessive, but who really needs several million doodads? For any type of doodad, your marketing department has a maximum bundle price of $a$.\n\nGiven the price of a doodad, the desired trailing digit, and the maximum price of a bundle, write a program that optimizes the trailing digits.", "inputFormat": "Input consists of a single line containing three integers $b$, $d$, and $a$, where $b$ ($1 \\leq b < 10^{6}$) is the price of a doodad in cents, $d$ ($0 \\leq d \\leq 9$) is the desired trailing digit, and $a$ ($b \\leq a < 10^{10\\,000}$) is the maximum price of a bundle.", "outputFormat": "Output the maximum number of consecutive occurrences of $d$ that can appear at the end of a bundle price, given that the price of the bundle cannot exceed $a$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 WF] Trailing Digits", "background": "", "description": "有一批货，每个价值 $b$ 元，可以把 $n$ 个货打包出售，价格是 $b \\times n$ 元（前提是$b \\times n\\le a$），使末尾含有尽可能多的数字 $d$ ，求最多的 $d$ 数量。", "inputFormat": "一行三个整数，$b$ , $d$ 和 $a$。", "outputFormat": "一个整数，最多的 $d$ 数量。", "hint": "对于全部数据，有 $1 \\le b < 10^6$ , $0 \\le d \\le 9$ , $b \\le a < 10^{10000}$", "locale": "zh-CN"}}}
{"pid": "P8141", "type": "P", "difficulty": 7, "samples": [["2 3\n0 0 2.5\n3 0 2.5\n1.5 0.5 2.5", "1.5 -2"], ["2 2\n0 0 2\n4 -4 6", "1.414213562373 1.414213562373"], ["4 3\n0 1 2 3 2\n1 2 -1 7 5\n1 0.3 3.4 1.2 3.3", "1 2 3 4"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "Special Judge", "O2优化", "线性代数", "ICPC", "WF"], "title": "[ICPC 2020 WF] What's Our Vector, Victor?", "background": "ICPC2020 WF N", "description": "Vector embeddings are a common tool in machine learning systems.\nComplex real-world concepts (for instance, words in a dictionary) are mapped onto vectors of real numbers.\nIf embeddings are trained properly, related concepts remain close together in the vector space, so questions like \"are these two words synonyms?\" can be reduced to straightforward mathematical tests.\n\nYou have been hired by Ye Olde Ice Cream Shoppe to create an embedding model for flavors, so that when they are out of an ice cream flavor they can recommend related flavors to customers.\nAfter training your embedding on six cloud datacenters for four months, you finally had the perfect flavor model!\nYou were ready to revolutionize the ice cream industry on your street and, dare we say it, your neighborhood!\nWell, until you accidentally dripped some free ice cream on your keyboard and deleted half the data.\nThe Shoppe cannot afford the 30 billion rubles needed to retrain the model, so you are in trouble.\n\nFortunately, you still have various training results lying around.\nFor a given deleted vector, the training data tells you how close it was to some known flavor vectors.\nThe closeness of vectors $A$ and $B$ is just the standard Euclidean distance metric (that is, the length of the vector $A - B$).\nWrite a tool that reconstructs embeddings which are consistent with the training results.", "inputFormat": "The first line contains two integers $d$ and $n$, where $d$ ($1 \\leq d \\leq 500$) is the number of dimensions of the\nvectors, and $n$ ($1 \\leq n \\leq 500$) is the number of training results for a deleted embedding vector you want to reconstruct.\nEach of the next $n$ lines describes a training result using $d + 1$ numbers $x_1, \\dots, x_d$ and $e$.\nIn a training result, $x_1, \\dots, x_d$ ($-100 \\leq x_i \\leq 100$) are the coordinates of a known vector, and \n$e$ ($0 \\leq e \\leq 5\\,000$) is the Euclidean distance from that vector to the deleted one.\n\nYour submission will be tested only with the sample inputs given below and inputs generated according to the following procedure.\nFirst, $d$ and $n$ are chosen.\nThen, $n$ input vectors and $1$ output vector, each with dimension $d$, are chosen at random.\nThe $d \\cdot (n + 1)$ coordinates are independent and uniformly distributed in the interval $[-100,100]$.\nNext, the Euclidean distance from each input vector to the output vector is computed.\nFinally, the output vector is discarded.\nCalculations use double-precision floating-point numbers.\nNumbers obtained using this procedure appear in the input with $17$ digits after the decimal point.", "outputFormat": "Output $d$ values, the coordinates of any vector that has the given distance to each training vector with an absolute or relative error of at most $10^{-5}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 WF] What's Our Vector, Victor?", "background": "ICPC2020 WF N", "description": "Vector embeddings are a common tool in machine learning systems.\nComplex real-world concepts (for instance, words in a dictionary) are mapped onto vectors of real numbers.\nIf embeddings are trained properly, related concepts remain close together in the vector space, so questions like \"are these two words synonyms?\" can be reduced to straightforward mathematical tests.\n\nYou have been hired by Ye Olde Ice Cream Shoppe to create an embedding model for flavors, so that when they are out of an ice cream flavor they can recommend related flavors to customers.\nAfter training your embedding on six cloud datacenters for four months, you finally had the perfect flavor model!\nYou were ready to revolutionize the ice cream industry on your street and, dare we say it, your neighborhood!\nWell, until you accidentally dripped some free ice cream on your keyboard and deleted half the data.\nThe Shoppe cannot afford the 30 billion rubles needed to retrain the model, so you are in trouble.\n\nFortunately, you still have various training results lying around.\nFor a given deleted vector, the training data tells you how close it was to some known flavor vectors.\nThe closeness of vectors $A$ and $B$ is just the standard Euclidean distance metric (that is, the length of the vector $A - B$).\nWrite a tool that reconstructs embeddings which are consistent with the training results.", "inputFormat": "The first line contains two integers $d$ and $n$, where $d$ ($1 \\leq d \\leq 500$) is the number of dimensions of the\nvectors, and $n$ ($1 \\leq n \\leq 500$) is the number of training results for a deleted embedding vector you want to reconstruct.\nEach of the next $n$ lines describes a training result using $d + 1$ numbers $x_1, \\dots, x_d$ and $e$.\nIn a training result, $x_1, \\dots, x_d$ ($-100 \\leq x_i \\leq 100$) are the coordinates of a known vector, and \n$e$ ($0 \\leq e \\leq 5\\,000$) is the Euclidean distance from that vector to the deleted one.\n\nYour submission will be tested only with the sample inputs given below and inputs generated according to the following procedure.\nFirst, $d$ and $n$ are chosen.\nThen, $n$ input vectors and $1$ output vector, each with dimension $d$, are chosen at random.\nThe $d \\cdot (n + 1)$ coordinates are independent and uniformly distributed in the interval $[-100,100]$.\nNext, the Euclidean distance from each input vector to the output vector is computed.\nFinally, the output vector is discarded.\nCalculations use double-precision floating-point numbers.\nNumbers obtained using this procedure appear in the input with $17$ digits after the decimal point.", "outputFormat": "Output $d$ values, the coordinates of any vector that has the given distance to each training vector with an absolute or relative error of at most $10^{-5}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 WF] What's Our Vector, Victor?", "background": "", "description": "向量嵌入是机器学习系统中的一种常用工具。现实世界中的某些复杂的概念（例如词典中的单词）通过这种方法可以映射到一个实向量上。如果能让机器正确地训练向量嵌入，由于相关概念在向量空间中保持着紧密的联系，因此像“这两个单词是同义词吗？”这种问题可以简化为简单的数学测试了。\n\n你最近被 Ye Olde 冰淇淋专柜受雇，专门负责为冰淇淋口味创建一个向量嵌入式模型，这样当一种口味的冰淇淋卖完以后，这个嵌入式模型就可以像顾客推荐其它味道相近的冰淇淋。在六个云数据中心里训练了四个月以后，你终于拥有了一个完美的模型，正准备好改变你所在街区的冰淇淋行业，乃至整个街区时，你不小心把一些免费的冰淇淋滴到了键盘上，导致一半的数据被删除。重新训练模型需要花费 300 亿卢布，而专柜显然承受不了这么高的价格，因此你陷入了巨大的麻烦之中。幸运的是，你可以通过剩下的数据来还原出被删除的向量。具体地，对于一个给定的被删除的向量，数据会告诉你它与某些已知的味道向量的接近程度。两个向量 $A,B$ 的接近程度即为这两个向量之间的标准欧几里得距离（即向量 $A-B$ 的长度）。\n\n现在，给定向量所处的空间维度 $d$ 和已知向量个数 $n$，并给定所有 $n$ 个向量的坐标 $(x_{i,1},x_{i,2},\\cdots,x_{i,d})$ 和到同一个被删除的向量的标准欧几里得距离 $e_i$，请你编写一个程序，求出被删除的向量的坐标。", "inputFormat": "第一行输入两个整数 $d,n$，分别表示向量空间的维度和向量个数。  \n随后 $n$ 行，每行 $d+1$ 个实数 $x_{i,1},x_{i,2},\\cdots,x_{i,d},e_i$，其中前 $d$ 个实数描述了第 $i$ 个向量的坐标，第 $d+1$ 个实数则表示第 $i$ 个向量与被删除的向量之间的标准欧几里得距离。\n\n你提交的代码只会在样例输入数据和按以下方式生成的输入数据上进行测试：\n\n- 在区间 $[1,500]$ 中选出两个整数作为 $d,n$。\n- 随机生成 $n$ 个 $d$ 维输入向量和一个 $d$ 维输出向量。这 $d\\cdot(n+1)$ 个坐标在区间 $[-100,100]$ 中独立且均匀地生成。\n- 对于每个输入向量，计算其与输出向量之间的标准欧几里得距离。\n- 忽略输出向量。\n\n所有在上述过程中的计算使用双精度浮点数，用这种方式生成的所有实数均保留到小数点后 $17$ 位。", "outputFormat": "输出 $d$ 个整数，描述被删除向量的坐标。你需要保证你输出的答案和标准答案之间的误差不会超过 $10^{-5}$。\n\n**【样例】**\n\n见『输入输出样例』部分。", "hint": "对于所有数据：\n\n- $1\\leqslant d,n\\leqslant 500$。\n- $-100\\leqslant x_{i,j}\\leqslant 100$。\n- $0\\leqslant e_i\\leqslant 5000$。\n\nTranslated by Eason_AC", "locale": "zh-CN"}}}
{"pid": "P8142", "type": "P", "difficulty": 5, "samples": [["4\n0.0000 0.0000\n30.0000 90.0000\n-45.0000 -30.0000\n30.0000 60.0000\n30.0000 150.0000\n30.0000 120.0000\n0.0000 60.0000\n-45.0000 30.0000", "Same"], ["3\n0.0000 0.0000\n30.0000 0.0000\n30.0000 90.0000\n0.0000 0.0000\n30.0000 0.0000\n30.0000 -90.0000", "Different"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "O2优化", "ICPC", "WF"], "title": "[ICPC 2020 WF] Which Planet is This?!", "background": "ICPC2020 WF O", "description": "It's the year 2521, and interstellar probes have reached planets in distant\nsolar systems. The Interstellar Consortium of Planet Cartographers (ICPC) has\ncreated detailed maps of these planets, and they seem to indicate the\nexistence of alien life! On each map, the ICPC has recorded the locations of\nwhat appear to be alien dwellings.\n\nThe ICPC was planning to release this exciting news to the public, but at the\nlast moment, disaster struck. One of the ICPC's interns deleted all\nmeta-data associated with the maps. So while the maps themselves are safe, the\nICPC does not know which maps belong to which planets. For this, they have come back\nin time to ask for your help. Given two maps, can you determine whether they describe the same planet?\nHopefully, a 500-year head start will be enough time to solve this important\nproblem!\n\nThe planetary maps consist of sets of points on the (spherical) planet\nsurface. They are specified in terms of latitude (the angle north or south of\nthe equator) and longitude (the angle west or east of the noon meridian, which\nis the location of the sun when the map's data was collected). Two maps for\nthe same planet always agree on the latitudes of the points, since the\nplanet's axis does not change. However, the longitudes of the points might\ndiffer, because the planet rotates between measurements.", "inputFormat": "The first line of input contains an integer $n$ ($1 \\le n \\le 400\\,000$), the\nnumber of points in each of the two maps to be compared. Then follow $n$ lines\ndescribing the first map. Each of these lines contains two real numbers $a$\nand $b$, where $a$ ($-90 < a < 90$) is the latitude and $b$ ($-180 < b \\le\n180$) is the longitude. Coordinates are expressed in degrees and have at most\nfour digits after the decimal point. No two points on the map will\nhave the same coordinates. The remaining $n$ lines describe the second map in the same format as the\nfirst.", "outputFormat": "Output $\\texttt{Same}$ if there is a rotation around the planet's axis that transforms one map into\nthe other. Otherwise, output $\\texttt{Different}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 WF] Which Planet is This?!", "background": "ICPC2020 WF O", "description": "It's the year 2521, and interstellar probes have reached planets in distant\nsolar systems. The Interstellar Consortium of Planet Cartographers (ICPC) has\ncreated detailed maps of these planets, and they seem to indicate the\nexistence of alien life! On each map, the ICPC has recorded the locations of\nwhat appear to be alien dwellings.\n\nThe ICPC was planning to release this exciting news to the public, but at the\nlast moment, disaster struck. One of the ICPC's interns deleted all\nmeta-data associated with the maps. So while the maps themselves are safe, the\nICPC does not know which maps belong to which planets. For this, they have come back\nin time to ask for your help. Given two maps, can you determine whether they describe the same planet?\nHopefully, a 500-year head start will be enough time to solve this important\nproblem!\n\nThe planetary maps consist of sets of points on the (spherical) planet\nsurface. They are specified in terms of latitude (the angle north or south of\nthe equator) and longitude (the angle west or east of the noon meridian, which\nis the location of the sun when the map's data was collected). Two maps for\nthe same planet always agree on the latitudes of the points, since the\nplanet's axis does not change. However, the longitudes of the points might\ndiffer, because the planet rotates between measurements.", "inputFormat": "The first line of input contains an integer $n$ ($1 \\le n \\le 400\\,000$), the\nnumber of points in each of the two maps to be compared. Then follow $n$ lines\ndescribing the first map. Each of these lines contains two real numbers $a$\nand $b$, where $a$ ($-90 < a < 90$) is the latitude and $b$ ($-180 < b \\le\n180$) is the longitude. Coordinates are expressed in degrees and have at most\nfour digits after the decimal point. No two points on the map will\nhave the same coordinates. The remaining $n$ lines describe the second map in the same format as the\nfirst.", "outputFormat": "Output $\\texttt{Same}$ if there is a rotation around the planet's axis that transforms one map into\nthe other. Otherwise, output $\\texttt{Different}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 WF] Which Planet is This?!", "background": "", "description": "这是2521年，星际探测器已经到达了遥远的太阳系的行星。星际行星制图者联盟(ICPC)已经绘制了这些行星的详细地图，它们似乎表明外星生命的存在!ICPC在每张地图上都记录了疑似外星人住所的位置。\n\nICPC本打算向公众公布这一激动人心的消息，但在最后一刻，灾难发生了。ICPC的一名实习生删除了所有与地图相关的元数据。因此，虽然地图本身是安全的，但ICPC并不知道哪些地图属于哪些行星。为此，他们及时回来请求您的帮助。给定两幅地图，你能确定它们是否描述的是同一颗行星吗?希望领先500年的时间足以解决这个重要的问题!\n\n行星图由(球面)行星表面的点集组成。它们是根据纬度(赤道南北的夹角)和经度(正午子午线的西半球或东半球的夹角，这是地图数据采集时太阳的位置)来指定的。同一颗行星的两幅地图在纬度上总是一致的，因为行星的轴是不变的。然而，这两个点的经度可能不同，因为行星在两次测量之间会旋转。", "inputFormat": "输入的第一行包含一个整数$n$ ($1 \\le n \\le 400000=4\\times10^5$)，这是要比较的两个地图射中每个地图中的点数。然后跟随描述第一张地图的$n$条线。每条线包含两个实数$a$和$b$，其中$a$($-90<a<90$)是纬度，$b$($-180<a<180$)是经度。坐标以度表示，小数点后最多有四位数字。地图上没有两个点的坐标是相同的。其余的$n$行以与第一个相同的格式描述第二个映射。", "outputFormat": "如果有一种围绕行星轴旋转的方式使得地图1和地图2相同，输出`Same`，否则输出`Different`", "hint": "", "locale": "zh-CN"}}}
{"pid": "P8143", "type": "P", "difficulty": 3, "samples": [["3", "3"], ["114514", "430461019"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2022", "洛谷原创"], "title": "[JRKSJ R4] Stirling", "background": "可能对您无用的提示：\n\n$$f(n)=\\sum_{i=0}^n \\begin{Bmatrix} n\\\\i\\end{Bmatrix}g(i) \\leftrightarrow g(n)=\\sum_{i=0}^n (-1)^{n-i} \\begin{bmatrix} n\\\\i\\end{bmatrix} f(i)$$", "description": "对于 $[1,n]$ 的排列 $p$，定义其“生成图”为：该图有 $n$ 个点，且 $\\forall 1\\le i\\le n$，无向边 $(i,p_i)$ 存在且仅存在这些边。\n\n给定 $n$，求有多少个 $[1,n]$ 的排列满足其生成图恰有偶数个环（自环同样计入）。", "inputFormat": "一个整数 $n$。", "outputFormat": "一个整数，表示答案。答案对 $998244353$ 取模。", "hint": "### 样例 $1$ 解释\n\n这些排列满足条件：\n\n$$\\{1,3,2\\}$$\n$$\\{2,1,3\\}$$\n$$\\{3,2,1\\}$$\n\n### 数据规模\n\n对于 $20\\%$ 的数据，$n\\le 10$。\\\n对于 $50\\%$ 的数据，$n\\le 500$。\\\n对于 $100\\%$ 的数据，$1\\le n\\le 10^6$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JRKSJ R4] Stirling", "background": "可能对您无用的提示：\n\n$$f(n)=\\sum_{i=0}^n \\begin{Bmatrix} n\\\\i\\end{Bmatrix}g(i) \\leftrightarrow g(n)=\\sum_{i=0}^n (-1)^{n-i} \\begin{bmatrix} n\\\\i\\end{bmatrix} f(i)$$", "description": "对于 $[1,n]$ 的排列 $p$，定义其“生成图”为：该图有 $n$ 个点，且 $\\forall 1\\le i\\le n$，无向边 $(i,p_i)$ 存在且仅存在这些边。\n\n给定 $n$，求有多少个 $[1,n]$ 的排列满足其生成图恰有偶数个环（自环同样计入）。", "inputFormat": "一个整数 $n$。", "outputFormat": "一个整数，表示答案。答案对 $998244353$ 取模。", "hint": "### 样例 $1$ 解释\n\n这些排列满足条件：\n\n$$\\{1,3,2\\}$$\n$$\\{2,1,3\\}$$\n$$\\{3,2,1\\}$$\n\n### 数据规模\n\n对于 $20\\%$ 的数据，$n\\le 10$。\\\n对于 $50\\%$ 的数据，$n\\le 500$。\\\n对于 $100\\%$ 的数据，$1\\le n\\le 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P8144", "type": "P", "difficulty": 4, "samples": [["2\nB 1 3 4 6 8 9\nW 1 3 4 6 8 9", "No\nYes"]], "limits": {"time": [1000, 1000], "memory": [131072, 131072]}, "tags": ["博弈论", "2022", "洛谷原创"], "title": "[JRKSJ R4] BBWWBB", "background": "", "description": "数轴上有 $6$ 个棋子。初始，第 $i$ 个棋子摆在 $a_i$，$a$ 单调递增。\n\n其中第 $1,2,5,6$ 个棋子是黑色的，第 $3,4$ 个棋子是白色的。\n\n游戏过程中，同一个位置上可以同时存在任意个同样颜色的棋子。\n\n有两方：黑方和白方。两方轮流进行操作：\n\n* 选择己方颜色的棋子，向左或向右移动一步。\n* 若准备移动到的位置上存在另一方的棋子且仅存在 $1$ 个，那么可以移动同时将该棋子移除。\n* 若准备移动到的位置上存在多个另一方的棋子，那么不可以移动到这个位置。\n* 当一方不存在可以移动的棋子，该方被判输，游戏结束。\n\n两方的目标都是在己方不输的前提下，尽可能的令对方输。两方均采取最优策略。\n\n给定一方作为先手和每个棋子的位置，请判断，游戏是否会无限进行下去。", "inputFormat": "**本题多组数据。**\n\n第一行一个整数 $T$ 表示数据组数。\n\n下面 $T$ 行，每行一组数据。\n\n每组数据首先一个字符 $c$，为 $\\texttt B$ 或者 $\\texttt W$。$c=\\texttt B$ 表示黑方先手，$c=\\texttt W$ 表示白方先手。然后 $6$ 个整数表示 $a_{1\\dots 6}$。", "outputFormat": "对于每组询问，每行回答一个 `Yes` 或 `No`。`Yes` 表示游戏会无限进行下去，`No` 反之。", "hint": "### 数据规模\n\n对于 $15\\%$ 的数据，$c=\\texttt B$。\\\n对于 $100\\%$ 的数据，$T\\le10^5$，$|a_i| \\le 10^9$，$c\\in\\{\\texttt B,\\texttt W\\}$。保证 $a$ 单调递增。\n\n### 样例解释\n\n对于第 $1$ 组数据，其中一种局面变化如下：\n\n```cpp\nB:\n1 4 6 8 9\nB B W B B\nW:\n1 4 5 8 9\nB B W B B\nB:\n1 5 8 9\nB B B B\n```\n对于第 $2$ 组数据，其中一种局面变化如下：\n\n```cpp\nW:\n1 3 6 8 9\nB W W B B\nB:\n1 3 6 8 8\nB W W B B\nW:\n1 3 5 8 8\nB W W B B\nB:\n1 3 5 7 8\nB W W B B\nW:\n1 3 4 7 8\nB W W B B\nB:\n1 3 4 7 7\nB W W B B\nW:\n1 3 3 7 7\nB W W B B\nB:\n1 3 3 6 7\nB W W B B\nW:\n1 2 3 6 7\nB W W B B\nB:\n2 3 6 7\nB W B B\nW:\n2 6 7\nW B B\n```\n此后白方每一步均控制 `W` 往左边走一步。无论黑方如何操作，游戏均可以无限进行下去。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JRKSJ R4] BBWWBB", "background": "", "description": "数轴上有 $6$ 个棋子。初始，第 $i$ 个棋子摆在 $a_i$，$a$ 单调递增。\n\n其中第 $1,2,5,6$ 个棋子是黑色的，第 $3,4$ 个棋子是白色的。\n\n游戏过程中，同一个位置上可以同时存在任意个同样颜色的棋子。\n\n有两方：黑方和白方。两方轮流进行操作：\n\n* 选择己方颜色的棋子，向左或向右移动一步。\n* 若准备移动到的位置上存在另一方的棋子且仅存在 $1$ 个，那么可以移动同时将该棋子移除。\n* 若准备移动到的位置上存在多个另一方的棋子，那么不可以移动到这个位置。\n* 当一方不存在可以移动的棋子，该方被判输，游戏结束。\n\n两方的目标都是在己方不输的前提下，尽可能的令对方输。两方均采取最优策略。\n\n给定一方作为先手和每个棋子的位置，请判断，游戏是否会无限进行下去。", "inputFormat": "**本题多组数据。**\n\n第一行一个整数 $T$ 表示数据组数。\n\n下面 $T$ 行，每行一组数据。\n\n每组数据首先一个字符 $c$，为 $\\texttt B$ 或者 $\\texttt W$。$c=\\texttt B$ 表示黑方先手，$c=\\texttt W$ 表示白方先手。然后 $6$ 个整数表示 $a_{1\\dots 6}$。", "outputFormat": "对于每组询问，每行回答一个 `Yes` 或 `No`。`Yes` 表示游戏会无限进行下去，`No` 反之。", "hint": "### 数据规模\n\n对于 $15\\%$ 的数据，$c=\\texttt B$。\\\n对于 $100\\%$ 的数据，$T\\le10^5$，$|a_i| \\le 10^9$，$c\\in\\{\\texttt B,\\texttt W\\}$。保证 $a$ 单调递增。\n\n### 样例解释\n\n对于第 $1$ 组数据，其中一种局面变化如下：\n\n```cpp\nB:\n1 4 6 8 9\nB B W B B\nW:\n1 4 5 8 9\nB B W B B\nB:\n1 5 8 9\nB B B B\n```\n对于第 $2$ 组数据，其中一种局面变化如下：\n\n```cpp\nW:\n1 3 6 8 9\nB W W B B\nB:\n1 3 6 8 8\nB W W B B\nW:\n1 3 5 8 8\nB W W B B\nB:\n1 3 5 7 8\nB W W B B\nW:\n1 3 4 7 8\nB W W B B\nB:\n1 3 4 7 7\nB W W B B\nW:\n1 3 3 7 7\nB W W B B\nB:\n1 3 3 6 7\nB W W B B\nW:\n1 2 3 6 7\nB W W B B\nB:\n2 3 6 7\nB W B B\nW:\n2 6 7\nW B B\n```\n此后白方每一步均控制 `W` 往左边走一步。无论黑方如何操作，游戏均可以无限进行下去。", "locale": "zh-CN"}}}
{"pid": "P8145", "type": "P", "difficulty": 6, "samples": [["10 6 3\n5 7 4 3 6 2 10 8 9 1", "38"], ["2 5 2\n1 2", "8"], ["2 114514 1\n2 1", "171771"], ["3 1000000000000000000 3\n2 1 3", "2065039361"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2022", "洛谷原创", "动态规划优化"], "title": "[JRKSJ R4] kth", "background": "> 时刻记住自己是人类，不是动物。\n\n在吃玉米番茄炖山羊肉之前，你需要回答一个问题。", "description": "给定 $n,m$，称一个“合法”的整数序列为（设该序列为 $s$）：\n\n* $s$ 长度为 $m$。\n* $\\forall i\\in[1,m],s_i\\in[1,n]$。\n* $\\forall i\\in[2,m],|s_i-s_{i-1}|=1$。\n\n给定一个 $[1,n]$ 的排列 $p$，并定义一个整数序列 $s$ 的“对应序列” $s'$：$s'$ 的长度和 $s$ 相同；设其长度为 $l$，那么 $\\forall i\\in [1,l],s'_i=p_{s_i}$。\n\n再给定 $k$，求所有不同的合法的整数序列的对应序列中，字典序第 $k$ 小的对应序列中所有元素的和对 $2^{32}$ 取模的值。\n\n若不存在第 $k$ 小的对应序列，输出 $-1$。", "inputFormat": "第一行三个整数 $n,m,k$。\\\n第二行 $n$ 个整数表示 $p$。", "outputFormat": "一个整数，表示答案。", "hint": "**本题输入文件较大，请使用恰当的读入方式。**\n\n### 样例解释\n对于样例 $1$，所有不同的合法的整数序列的对应序列中，字典序前三小的分别是：\n\n$$\\{1,9,1,9,1,9\\}$$\n$$\\{1,9,1,9,8,9\\}$$\n$$\\{1,9,1,9,8,10\\}$$\n\n所以答案为 $1+9+1+9+8+10=38$。\n\n对于样例 $2$，所有不同的合法的整数序列的对应序列中，字典序前二小的分别是：\n\n$$\\{1,2,1,2,1\\}$$\n$$\\{2,1,2,1,2\\}$$\n\n所以答案为 $2+1+2+1+2=8$。\n### 数据规模\n| $\\text{Subtask}$ | $n\\le$ | $m\\le$ | $k\\le$ | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $20$ | $10$ | $10^{18}$ | $5$ |\n| $2$ | $70$ | $70$ | $10^{18}$ | $15$ |\n| $3$ | $100$ | $300$ | $10^{18}$ | $20$ |\n| $4$ | $10^4$ | $10^4$ | $10^{18}$ | $15$ |\n| $5$ | $10^4$ | $10^{18}$ | $10^{18}$ | $10$ |\n| $6$ | $10^6$ | $10^{18}$ | $1$ | $5$ |\n| $7$ |$2\\times10^7$| $10^{18}$ | $10^{18}$ | $30$ |\n\n\n对于 $100\\%$ 的数据，$1\\le n\\le 2\\times10^7$，$2\\le m\\le 10^{18}$，$1\\le k\\le 10^{18}$。\n### 特殊计分方式\n本题开启子任务依赖，具体如下：\n- 对于子任务 $i\\in\\{1,6\\}$，您只需答对子任务 $i$ 即可获得子任务 $i$ 的分数。\n- 对于子任务 $i\\in\\{2,3,4,5,7\\}$，您需要答对所有 $j\\in[1,i]$ 的子任务 $j$ 才能获得子任务 $i$ 的分数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JRKSJ R4] kth", "background": "> 时刻记住自己是人类，不是动物。\n\n在吃玉米番茄炖山羊肉之前，你需要回答一个问题。", "description": "给定 $n,m$，称一个“合法”的整数序列为（设该序列为 $s$）：\n\n* $s$ 长度为 $m$。\n* $\\forall i\\in[1,m],s_i\\in[1,n]$。\n* $\\forall i\\in[2,m],|s_i-s_{i-1}|=1$。\n\n给定一个 $[1,n]$ 的排列 $p$，并定义一个整数序列 $s$ 的“对应序列” $s'$：$s'$ 的长度和 $s$ 相同；设其长度为 $l$，那么 $\\forall i\\in [1,l],s'_i=p_{s_i}$。\n\n再给定 $k$，求所有不同的合法的整数序列的对应序列中，字典序第 $k$ 小的对应序列中所有元素的和对 $2^{32}$ 取模的值。\n\n若不存在第 $k$ 小的对应序列，输出 $-1$。", "inputFormat": "第一行三个整数 $n,m,k$。\\\n第二行 $n$ 个整数表示 $p$。", "outputFormat": "一个整数，表示答案。", "hint": "**本题输入文件较大，请使用恰当的读入方式。**\n\n### 样例解释\n对于样例 $1$，所有不同的合法的整数序列的对应序列中，字典序前三小的分别是：\n\n$$\\{1,9,1,9,1,9\\}$$\n$$\\{1,9,1,9,8,9\\}$$\n$$\\{1,9,1,9,8,10\\}$$\n\n所以答案为 $1+9+1+9+8+10=38$。\n\n对于样例 $2$，所有不同的合法的整数序列的对应序列中，字典序前二小的分别是：\n\n$$\\{1,2,1,2,1\\}$$\n$$\\{2,1,2,1,2\\}$$\n\n所以答案为 $2+1+2+1+2=8$。\n### 数据规模\n| $\\text{Subtask}$ | $n\\le$ | $m\\le$ | $k\\le$ | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $20$ | $10$ | $10^{18}$ | $5$ |\n| $2$ | $70$ | $70$ | $10^{18}$ | $15$ |\n| $3$ | $100$ | $300$ | $10^{18}$ | $20$ |\n| $4$ | $10^4$ | $10^4$ | $10^{18}$ | $15$ |\n| $5$ | $10^4$ | $10^{18}$ | $10^{18}$ | $10$ |\n| $6$ | $10^6$ | $10^{18}$ | $1$ | $5$ |\n| $7$ |$2\\times10^7$| $10^{18}$ | $10^{18}$ | $30$ |\n\n\n对于 $100\\%$ 的数据，$1\\le n\\le 2\\times10^7$，$2\\le m\\le 10^{18}$，$1\\le k\\le 10^{18}$。\n### 特殊计分方式\n本题开启子任务依赖，具体如下：\n- 对于子任务 $i\\in\\{1,6\\}$，您只需答对子任务 $i$ 即可获得子任务 $i$ 的分数。\n- 对于子任务 $i\\in\\{2,3,4,5,7\\}$，您需要答对所有 $j\\in[1,i]$ 的子任务 $j$ 才能获得子任务 $i$ 的分数。", "locale": "zh-CN"}}}
{"pid": "P8146", "type": "P", "difficulty": 6, "samples": [["5 10 2\n5 4 3 2 1\n2 1 5 1\n2 1 5 2\n1 2 3 1\n1 2 3 2\n2 1 4 1\n2 1 4 2\n1 1 4 1\n1 1 4 2\n2 1 5 1\n2 3 5 2", "0\n0\n2\n2\n4\n3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2022", "颜色段均摊（珂朵莉树 ODT）", "洛谷原创", "O2优化", "分块", "扫描线", "根号分治"], "title": "[JRKSJ R4] risrqnis", "background": "", "description": "给你一个长度为 $n$ 的序列 $a_{1\\sim n}$，有 $q$ 次操作，初始有 $m$ 个空集 $S_{1\\sim m}$，共有两种操作，如下：\n\n- `1 l r k`，将 $l\\sim r$ 加入集合 $S_k$，即 $S_k\\gets S_k\\cup\\{x|x\\in[l,r]\\cap \\N\\}$；\n- `2 l r k`，查询对于所有 $l\\le i\\le r$ 的 $a_i$ 中有多少个在集合 $S_k$ 中，即查询 $\\displaystyle\\sum_{i=l}^r[a_i\\in S_k]$。", "inputFormat": "输入均为非负整数。\n\n第一行 $3$ 个数 $n,q,m$。\\\n第二行 $n$ 个数，其中第 $i$ 个数表示 $a_i$。\\\n接下来 $q$ 行，每行 $4$ 个数表示一次操作。", "outputFormat": "输出均为非负整数。\n\n对于每个 `2` 操作，输出一行表示答案。", "hint": "### 数据规模\n| $\\text{Subtask}$ | $n,q\\le$ | $m\\le$ | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10^6$ | $1$ | $30$ |\n| $2$ | $5\\times 10^3$ | $3\\times 10^5$ | $15$ |\n| $3$ | $10^5$ | $10^5$ | $15$ |\n| $4$ | $3\\times 10^5$ | $10^9$ | $40$ |\n\n对于 $100\\%$ 的数据，$1\\le n,q\\le 10^6$，$1\\le m\\le 10^9$，$1\\le a_i\\le 10^9$。\n\n操作 $1$ 中 $1\\le l\\le r\\le 10^9$，操作 $2$ 中 $1\\le l\\le r\\le n$。所有操作中 $1\\le k\\le m$。\n\n**没有一个 $\\text{Subtask}$ 取到所有数据范围的最大值，各个 $\\text{Subtask}$ 都有自己的限制。请阅读数据范围表。**\n\n**本题输入文件较大，请使用恰当的读入方式。**\n****\n\n深夜，上条当麻的手机响起了收信声。随即，他来到了邮件所写的地方。第七学区的铁桥。\n\n上条到达的时候，发信人早已经等在那了。\n\n「御坂吗……？」\n\n「你忘记的东西。」\n\n她说着丢了什么过来。上条单手接住，发现那是个青娃的手机挂件。他沉入北水洋的时候这东西就应该不见了啊。它用来系到手机上的挂绳当初都粉碎了，现在却换成了其他颜色的绳子。\n\n「好不容易找回来的，别再弄丢了哦。」\n\n「不好意思。」\n\n上条道了声谢，将它再次系到了手机上。\n\n见状，美琴微微一笑。\n\n那是似乎终于把什么东西回归原状而松了一口气的表情。\n\n「我想你这个家伙应该不会一直呆在一个地方的吧…接下来该不会你又要去哪？」 \n\n「算是吧。」\n\n上条叹了口气。\n\n「老实说虽然我一副淡定的表情，但实际上我也对究竟发生了什么一头雾水，只知道元凶的名字而已。不过这场骚动已经波及到了学园都市，而正在追查学园都市的我也被卷入其中，被我追查的学园都市同样被卷入……所以我也没办法置之不理了。」\n\n美琴找他似乎就只是为了送挂饰而已。上条将手机放进了口袋。\n\n既然没有了话题，那也只能分别了。\n\n「再见了。」上条说道。\n\n转身背对着美琴，准备离开铁桥，\n\n准备离开这个由科学常识构筑的学园都市，大步迈向外面的领域，而少年的手，却被美琴抓住了。 \n\n确确实实地，紧紧拉住想要飘然离开的少年。\n\n在静止的上条耳边，传来了美琴的声音。\n\n「但，这次你不会是一个人了。」 \n\n![114514](https://cdn.luogu.com.cn/upload/image_hosting/0rezlv6r.png?x-oss-process=image/resize,m_lfit,h_510,w_675)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JRKSJ R4] risrqnis", "background": "", "description": "给你一个长度为 $n$ 的序列 $a_{1\\sim n}$，有 $q$ 次操作，初始有 $m$ 个空集 $S_{1\\sim m}$，共有两种操作，如下：\n\n- `1 l r k`，将 $l\\sim r$ 加入集合 $S_k$，即 $S_k\\gets S_k\\cup\\{x|x\\in[l,r]\\cap \\N\\}$；\n- `2 l r k`，查询对于所有 $l\\le i\\le r$ 的 $a_i$ 中有多少个在集合 $S_k$ 中，即查询 $\\displaystyle\\sum_{i=l}^r[a_i\\in S_k]$。", "inputFormat": "输入均为非负整数。\n\n第一行 $3$ 个数 $n,q,m$。\\\n第二行 $n$ 个数，其中第 $i$ 个数表示 $a_i$。\\\n接下来 $q$ 行，每行 $4$ 个数表示一次操作。", "outputFormat": "输出均为非负整数。\n\n对于每个 `2` 操作，输出一行表示答案。", "hint": "### 数据规模\n| $\\text{Subtask}$ | $n,q\\le$ | $m\\le$ | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10^6$ | $1$ | $30$ |\n| $2$ | $5\\times 10^3$ | $3\\times 10^5$ | $15$ |\n| $3$ | $10^5$ | $10^5$ | $15$ |\n| $4$ | $3\\times 10^5$ | $10^9$ | $40$ |\n\n对于 $100\\%$ 的数据，$1\\le n,q\\le 10^6$，$1\\le m\\le 10^9$，$1\\le a_i\\le 10^9$。\n\n操作 $1$ 中 $1\\le l\\le r\\le 10^9$，操作 $2$ 中 $1\\le l\\le r\\le n$。所有操作中 $1\\le k\\le m$。\n\n**没有一个 $\\text{Subtask}$ 取到所有数据范围的最大值，各个 $\\text{Subtask}$ 都有自己的限制。请阅读数据范围表。**\n\n**本题输入文件较大，请使用恰当的读入方式。**\n****\n\n深夜，上条当麻的手机响起了收信声。随即，他来到了邮件所写的地方。第七学区的铁桥。\n\n上条到达的时候，发信人早已经等在那了。\n\n「御坂吗……？」\n\n「你忘记的东西。」\n\n她说着丢了什么过来。上条单手接住，发现那是个青娃的手机挂件。他沉入北水洋的时候这东西就应该不见了啊。它用来系到手机上的挂绳当初都粉碎了，现在却换成了其他颜色的绳子。\n\n「好不容易找回来的，别再弄丢了哦。」\n\n「不好意思。」\n\n上条道了声谢，将它再次系到了手机上。\n\n见状，美琴微微一笑。\n\n那是似乎终于把什么东西回归原状而松了一口气的表情。\n\n「我想你这个家伙应该不会一直呆在一个地方的吧…接下来该不会你又要去哪？」 \n\n「算是吧。」\n\n上条叹了口气。\n\n「老实说虽然我一副淡定的表情，但实际上我也对究竟发生了什么一头雾水，只知道元凶的名字而已。不过这场骚动已经波及到了学园都市，而正在追查学园都市的我也被卷入其中，被我追查的学园都市同样被卷入……所以我也没办法置之不理了。」\n\n美琴找他似乎就只是为了送挂饰而已。上条将手机放进了口袋。\n\n既然没有了话题，那也只能分别了。\n\n「再见了。」上条说道。\n\n转身背对着美琴，准备离开铁桥，\n\n准备离开这个由科学常识构筑的学园都市，大步迈向外面的领域，而少年的手，却被美琴抓住了。 \n\n确确实实地，紧紧拉住想要飘然离开的少年。\n\n在静止的上条耳边，传来了美琴的声音。\n\n「但，这次你不会是一个人了。」 \n\n![114514](https://cdn.luogu.com.cn/upload/image_hosting/0rezlv6r.png?x-oss-process=image/resize,m_lfit,h_510,w_675)", "locale": "zh-CN"}}}
{"pid": "P8147", "type": "P", "difficulty": 7, "samples": [["4 2\nab 2\na 2\nba 2\nb 1\nbbaba 2\naab 1", "4\n4"], ["15 4\nba 18\ncbc 74\naac 54\nba 77\na 66\nc 96\ncdb 47\ndc 45\ncb 62\ndb 88\ndda 93\ndb 34\nb 81\nacd 100\nda 80\nbcaacbbdcbabcda 4\nbccac 3\nabdbaca 5\ncbdaaaacaaca 3", "124\n66\n77\n108"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["二分", "2022", "洛谷原创", "O2优化", "可持久化线段树", "虚树", "AC 自动机"], "title": "[JRKSJ R4] Salieri", "background": "![a358071f95cad1c8ccd29cc83a3e6709c83d518e.jpg](https://s2.loli.net/2021/12/24/Oi251TnFP7SflQp.jpg)  \n\n~~【记得到番里面去把“萨列里谱不出莫扎特的曲子”这句话找到】~~ 最终还是没能找到，哪位看过《命运石之门0》的兄弟能帮我找找？", "description": "Salieri 发现了 $n$ 种制作音乐的模式，他将第 $i$ 种模式表示为一个字符串 $s_i$，这种模式所带来的初始优美度为 $v_i$。  \nSalieri 现在想制作 $m$ 首乐曲，每次他的灵感可以被表示成一个字符串 $S$。设 $cnt_i$ 为 $s_i$ 在 $S$ 中的出现次数，则采用 $i$ 模式制作的乐曲最终的优美度 $w_i=cnt_i\\times v_i$。  \nSalieri 当然希望制作出来的乐曲最终优美度越大越好，但是他发现此灵感下前 $k-1$ 优美的乐曲已经被 Mozart 制作过了，他只能制作第 $k$ 优美的乐曲。请你求出这个最终优美度。  \n\n形式化题意：给出 $n$ 个字符串 $s_i$，每个字符串有一个权值 $v_i$。$m$ 次询问每次给出一个字符串 $S$ 和一个常数 $k$。设 $cnt_i$ 为 $s_i$ 在 $S$ 中的出现次数，求 $cnt_i\\times v_i$ 第 $k$ 大的值。", "inputFormat": "第一行两个数，$n,m$。  \n接下来 $n$ 行每行一个字符串 $s_i$ 和一个数 $v_i$。  \n接下来 $m$ 行每行一个字符串 $S$ 和一个数 $k$。", "outputFormat": "每行一个数，代表答案。", "hint": "设 $L$ 为 $s$ 长度总和。\n\n| $\\text{Subtask}$|$n,m\\le$|$L\\le$|特殊性质| 分值 |\n|:-:|:-:|:-:|:-:| :-: |\n|$1$|$10^3$|$5\\times10^3$|无| $10$ |\n|$2$|$10^3$|$10^5$|无| $20$ |\n|$3$|$10^5$|$5\\times10^5$|$k=1$| $10$ |\n|$4$|$3\\times10^4$|$2\\times10^5$|$k\\le5$| $20$ |\n|$5$|$3\\times10^4$|$2\\times10^5$|无|  $20$ | \n|$6$|$10^5$|$5\\times10^5$|无|  $20$ |\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le10^5$，$L\\le5\\times10^5$。\n\n无论何时 $\\sum |S|$ 与 $L$ 同阶，$s$ 和 $S$ 中只会出现 $\\texttt a,\\texttt b,\\texttt c,\\texttt d$ 四种字符，$v_i\\le10^3$，$k\\le n$。\n\n\n![QQ截图20220128131353.png](https://s2.loli.net/2022/01/28/MJchEuxsF1QI46V.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JRKSJ R4] Salieri", "background": "![a358071f95cad1c8ccd29cc83a3e6709c83d518e.jpg](https://s2.loli.net/2021/12/24/Oi251TnFP7SflQp.jpg)  \n\n~~【记得到番里面去把“萨列里谱不出莫扎特的曲子”这句话找到】~~ 最终还是没能找到，哪位看过《命运石之门0》的兄弟能帮我找找？", "description": "Salieri 发现了 $n$ 种制作音乐的模式，他将第 $i$ 种模式表示为一个字符串 $s_i$，这种模式所带来的初始优美度为 $v_i$。  \nSalieri 现在想制作 $m$ 首乐曲，每次他的灵感可以被表示成一个字符串 $S$。设 $cnt_i$ 为 $s_i$ 在 $S$ 中的出现次数，则采用 $i$ 模式制作的乐曲最终的优美度 $w_i=cnt_i\\times v_i$。  \nSalieri 当然希望制作出来的乐曲最终优美度越大越好，但是他发现此灵感下前 $k-1$ 优美的乐曲已经被 Mozart 制作过了，他只能制作第 $k$ 优美的乐曲。请你求出这个最终优美度。  \n\n形式化题意：给出 $n$ 个字符串 $s_i$，每个字符串有一个权值 $v_i$。$m$ 次询问每次给出一个字符串 $S$ 和一个常数 $k$。设 $cnt_i$ 为 $s_i$ 在 $S$ 中的出现次数，求 $cnt_i\\times v_i$ 第 $k$ 大的值。", "inputFormat": "第一行两个数，$n,m$。  \n接下来 $n$ 行每行一个字符串 $s_i$ 和一个数 $v_i$。  \n接下来 $m$ 行每行一个字符串 $S$ 和一个数 $k$。", "outputFormat": "每行一个数，代表答案。", "hint": "设 $L$ 为 $s$ 长度总和。\n\n| $\\text{Subtask}$|$n,m\\le$|$L\\le$|特殊性质| 分值 |\n|:-:|:-:|:-:|:-:| :-: |\n|$1$|$10^3$|$5\\times10^3$|无| $10$ |\n|$2$|$10^3$|$10^5$|无| $20$ |\n|$3$|$10^5$|$5\\times10^5$|$k=1$| $10$ |\n|$4$|$3\\times10^4$|$2\\times10^5$|$k\\le5$| $20$ |\n|$5$|$3\\times10^4$|$2\\times10^5$|无|  $20$ | \n|$6$|$10^5$|$5\\times10^5$|无|  $20$ |\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le10^5$，$L\\le5\\times10^5$。\n\n无论何时 $\\sum |S|$ 与 $L$ 同阶，$s$ 和 $S$ 中只会出现 $\\texttt a,\\texttt b,\\texttt c,\\texttt d$ 四种字符，$v_i\\le10^3$，$k\\le n$。\n\n\n![QQ截图20220128131353.png](https://s2.loli.net/2022/01/28/MJchEuxsF1QI46V.png)", "locale": "zh-CN"}}}
{"pid": "P8148", "type": "P", "difficulty": 4, "samples": [["3\n1 2 3 4 6 7", "1 2 4"], ["5\n1 3 4 7 8 9 10 11 15 17 18 19 24 27 28", "1 3 7 8 9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2022", "O2优化", "排序"], "title": "声海 | Sea of Voices", "background": "「真是，如梦似幻呢。」\n\n“怎么？”\n\n「我看见你从开始到现在的一切记忆；看见你，从一次次或欢喜或失落中走来。那些场景在我眼前浮现，像梦，却又那么模糊——我只听见那些声音，只感到那片声音的海洋将我环围… 你听得见吗？」\n\n“当然。毕竟，它们是我的记忆啊。”\n\n「或许，一次生命，便是一场发声的历程吧。我们诞生时的啼哭，便在向世界发出宣告降临的声音；在一次次挑战的过程中，我们向一切阻碍我们的事物唱出不屈的战歌；在日常的点滴中，我们向所珍视之人倾诉内心深处的话语… 这样的声音，这样的感情，是不是就是我们所生存世界的本质呢？」\n\n“或许就是这样吧。纵使一路走来，我们看见了无尽的景色，但只有那些与我们内心共鸣的声音——或来自于自然、或来自于他人的灵魂——才会真正地改变我们自己。”\n\n「是啊… 但愿，在这片声音的海洋里，你不会迷失你的方向。我期许着听见更多，关于你的声音。怀揣着这种信念，向前走下去吧。」\n\n“你也一样。”\n\n> We'll see creation come undone\n>\n> 我们会见证自己存在的印记被世界拂去\n>\n> These bones that bound us will be gone\n>\n> 而那些既有的束缚将不再留存\n>\n> We'll stir our spirits till we're one\n>\n> 我们会洗涤自己的灵魂直至合为一体\n>\n> Then soft as shadows we'll become\n>\n> 然后成为掠影，散失在虚无之中", "description": "“但是… 曾有一些人，在我的生命里留下了重要的声音，我却无法回忆起了…”\n\n「为什么呢？」\n\n“不妨让我们把问题变得形式化一点。我想回忆起的声音有 $n$ 个，它们的共鸣度——非负整数 $a_i$，是单调不降的。最初它们互不干涉，但随着时间的推移，多个相邻的声音会交织在一起形成新的声音——也就是说，对于任意的 $1\\le l\\le r\\le n$，第 $l$ 一直到第 $r$ 个声音会交织在一起形成新的声音，而这个声音的共鸣度便是这些声音共鸣度的总和。”\n\n「也就是说，例如 $n=3$，$a=[1,2,4]$，那么最终 $\\dfrac{3\\times(3+1)}2=6$ 个声音的共鸣度分别是 $1,2,4,3,6,7$？」\n\n“没错。现在我把最终所有声音的共鸣度无序地告诉你，你能帮我还原最开始 $n$ 个声音的共鸣度吗？”\n\n「乐意之至。」\n\n### 简要题意\n\n$a$ 为长度为 $n$ 的非负整数序列，满足 $\\forall 1<i\\le n,a_{i-1}\\le a_i$。现 **无序** 地给出 **可重集** $S=\\left\\{\\sum_{k=l}^r a_k|1\\le l\\le r\\le n\\right\\}$，试还原 $a$。", "inputFormat": "第一行一个正整数 $n$，代表最初声音的个数。\n\n接下来一行 $\\dfrac{n\\times(n+1)}2$ 个非负整数，表示现在所有声音的共鸣度（输入无序）。", "outputFormat": "一行 $n$ 个非负整数，表示最初 $n$ 个声音共鸣度 $a_i$。", "hint": "对于全部数据，有 $1\\le n\\le 2000$，$0\\le a_i\\le 10^5$。\n\nSubtask 1（5 pts）：保证 $n=2$。\n\nSubtask 2（15 pts）：保证 $n=3$。\n\nSubtask 3（30 pts）：保证 $n\\le 100$。\n\nSubtask 4（50 pts）：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "声海 | Sea of Voices", "background": "「真是，如梦似幻呢。」\n\n“怎么？”\n\n「我看见你从开始到现在的一切记忆；看见你，从一次次或欢喜或失落中走来。那些场景在我眼前浮现，像梦，却又那么模糊——我只听见那些声音，只感到那片声音的海洋将我环围… 你听得见吗？」\n\n“当然。毕竟，它们是我的记忆啊。”\n\n「或许，一次生命，便是一场发声的历程吧。我们诞生时的啼哭，便在向世界发出宣告降临的声音；在一次次挑战的过程中，我们向一切阻碍我们的事物唱出不屈的战歌；在日常的点滴中，我们向所珍视之人倾诉内心深处的话语… 这样的声音，这样的感情，是不是就是我们所生存世界的本质呢？」\n\n“或许就是这样吧。纵使一路走来，我们看见了无尽的景色，但只有那些与我们内心共鸣的声音——或来自于自然、或来自于他人的灵魂——才会真正地改变我们自己。”\n\n「是啊… 但愿，在这片声音的海洋里，你不会迷失你的方向。我期许着听见更多，关于你的声音。怀揣着这种信念，向前走下去吧。」\n\n“你也一样。”\n\n> We'll see creation come undone\n>\n> 我们会见证自己存在的印记被世界拂去\n>\n> These bones that bound us will be gone\n>\n> 而那些既有的束缚将不再留存\n>\n> We'll stir our spirits till we're one\n>\n> 我们会洗涤自己的灵魂直至合为一体\n>\n> Then soft as shadows we'll become\n>\n> 然后成为掠影，散失在虚无之中", "description": "“但是… 曾有一些人，在我的生命里留下了重要的声音，我却无法回忆起了…”\n\n「为什么呢？」\n\n“不妨让我们把问题变得形式化一点。我想回忆起的声音有 $n$ 个，它们的共鸣度——非负整数 $a_i$，是单调不降的。最初它们互不干涉，但随着时间的推移，多个相邻的声音会交织在一起形成新的声音——也就是说，对于任意的 $1\\le l\\le r\\le n$，第 $l$ 一直到第 $r$ 个声音会交织在一起形成新的声音，而这个声音的共鸣度便是这些声音共鸣度的总和。”\n\n「也就是说，例如 $n=3$，$a=[1,2,4]$，那么最终 $\\dfrac{3\\times(3+1)}2=6$ 个声音的共鸣度分别是 $1,2,4,3,6,7$？」\n\n“没错。现在我把最终所有声音的共鸣度无序地告诉你，你能帮我还原最开始 $n$ 个声音的共鸣度吗？”\n\n「乐意之至。」\n\n### 简要题意\n\n$a$ 为长度为 $n$ 的非负整数序列，满足 $\\forall 1<i\\le n,a_{i-1}\\le a_i$。现 **无序** 地给出 **可重集** $S=\\left\\{\\sum_{k=l}^r a_k|1\\le l\\le r\\le n\\right\\}$，试还原 $a$。", "inputFormat": "第一行一个正整数 $n$，代表最初声音的个数。\n\n接下来一行 $\\dfrac{n\\times(n+1)}2$ 个非负整数，表示现在所有声音的共鸣度（输入无序）。", "outputFormat": "一行 $n$ 个非负整数，表示最初 $n$ 个声音共鸣度 $a_i$。", "hint": "对于全部数据，有 $1\\le n\\le 2000$，$0\\le a_i\\le 10^5$。\n\nSubtask 1（5 pts）：保证 $n=2$。\n\nSubtask 2（15 pts）：保证 $n=3$。\n\nSubtask 3（30 pts）：保证 $n\\le 100$。\n\nSubtask 4（50 pts）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P8149", "type": "P", "difficulty": 5, "samples": [["2 2\n2 1 2\n3 1 2", "entangled"], ["5 7\n1 1 2 3 4\n3 1 2\n2 1 2\n3 1 2\n3 3 4\n4 1\n4 2", "separate\nentangled\nentangled\n2\n2"], ["7 6\n1 1 2 3 4\n1 3 5 6 7\n2 4 5\n3 6 7\n2 1 2\n3 6 7", "separate\nentangled"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["并查集", "2022", "O2优化"], "title": "泪光 | Tears", "background": "「为什么哭呢？」\n\n“因为自己的期许和现实相去甚远。”\n\n「哭能改变什么呢？」\n\n“什么都不能。正如同既成事实的过去一样。”\n\n「那么为何不抹去泪水向前迈进呢？」\n\n“… 我在等我的灵魂追上时间。”\n\n> After night\n>\n> 长夜之后\n>\n> In boundless light\n>\n> 无垠光中\n>\n> He calls my name\n>\n> 他呼唤着我\n>\n> I do the same\n>\n> 我望向彼方，回应", "description": "「不想回忆的事，就别再去想了吧。为了分散你的注意力，正好我有一道与人的感情相关的题目，你看看怎么样？」\n\n“… 真是令人想吐槽呢。怎么，又是那个人在支配吗？”\n\n「什么嘛，令人不快… 你以前对这种事不是有很大的热情吗？」\n\n“… 说不准。”\n\n「咳咳… 那么听好了。现在共有 $n$ 个人，每个人都有一个情绪值：用 **实数** $v_i$ 表示。现在由于一些特殊的变化，使得这些人的情感发生了纠缠…」\n\n“嗯哼？”\n\n「第一种纠缠有四个参数 $a,b,c,d$，表示：现在已知存在无穷个 $f:\\R\\rightarrow\\R$，使得 $\\frac{f(v_a)}{f(v_b)}=\\frac{v_c}{v_d}$。」\n\n“等等等等一下！这数学公式是怎么说出来的啊？！还有什么 $f:\\R\\rightarrow\\R$ 是什么意思啊！”\n\n「你瞧，你不也说出来了吗？」\n\n“… 可恶，果然是你吗，那个人…”\n\n「简单来说，$f:\\R\\rightarrow\\R$ 就是代表一个定义域和值域都是实数的函数。如果这都不能理解的话，我要开始怀疑你作为高中生的身份了哦…」\n\n“好吧… 继续吧。”\n\n「第二种纠缠有两个参数 $a,b$，表示：现在已知存在有穷个 $f:\\R\\rightarrow\\R$，使得 $f(v_a)\\ne f(v_b)$。」\n\n“什么叫‘有穷个’？”\n\n「就是有一个确切的数目啦… 只要有一个自然数 $k$ 能表示这样函数的数目，那么就叫‘存在有穷个函数’哦？」\n\n“嗯…”\n\n「接下来，在纠缠不断增加的过程中，你也需要回答一些问题。第一种是，给出 $a,b$，你需要判断 $v_a$ 是否总是等于 $v_b$；第二种是，给出 $a$，你需要计算有多少个 $b$（$1\\le b\\le n$，$b$ 可以等于 $a$）使得 $v_a=v_b$ 恒成立。」\n\n“… 题目我明白了，但是这跟人的情感有什么关系吗？”\n\n「哈哈… 就是想逗你开心嘛，别那么严肃。」\n\n“… 无聊。”\n\n### 简要题意\n\n有 $n$ 个 **正实数** 变量 $v_1,\\dots,v_n$。你需要根据当前已知的条件作出判断。每次给出两种条件之一：\n\n- 给出常数 $a,b,c,d$：表示现在已知存在无穷个 $f:\\R\\rightarrow\\R$，使得 $\\frac{f(v_a)}{f(v_b)}=\\frac{v_c}{v_d}$。\n\n- 给出常数 $a,b$：表示现在已知存在有穷个 $f:\\R\\rightarrow\\R$，使得 $f(v_a)\\ne f(v_b)$。\n\n或者两种询问之一：\n\n- 给出常数 $a,b$：询问 $v_a=v_b$ 是否恒成立。\n\n- 给出常数 $a$：询问有多少个 $b$（$1\\le b\\le n$，$b$ 可以等于 $a$）使得 $v_a=v_b$ 恒成立。", "inputFormat": "第一行两个正整数 $n,m$，分别表示变量的数量和操作的次数。\n\n接下来 $m$ 行，每行表示一次操作，有四种可能：\n\n- `1 a b c d`：表示现在已知存在无穷个 $f:\\R\\rightarrow\\R$，使得 $\\frac{f(v_a)}{f(v_b)}=\\frac{v_c}{v_d}$。\n\n- `2 a b`：表示现在已知存在有穷个 $f:\\R\\rightarrow\\R$，使得 $f(v_a)\\ne f(v_b)$。\n\n- `3 a b`：询问 $v_a=v_b$ 是否恒成立。\n\n- `4 a`：询问有多少个 $b$（$1\\le b\\le n$，$b$ 可以等于 $a$）使得 $v_a=v_b$ 恒成立。", "outputFormat": "对于每次操作三，输出一行字符串 `entangled` 表示 $v_a=v_b$ 恒成立；反之输出一行字符串 `separate`。\n\n对于每次操作四，输出一行一个整数表示符合条件的 $b$ 的数目。", "hint": "对于全部数据，有 $1\\le n,m\\le 6\\times 10^5$。保证操作一中 $a\\ne b,c\\ne d$，操作二中 $a\\ne b$，操作三中 $a\\ne b$。\n\nSubtask 1（5 pts）：保证不出现操作一和操作二。\n\nSubtask 2（10 pts）：保证不出现操作一。\n\nSubtask 3（35 pts）：保证 $n\\le 5000$。\n\nSubtask 4（50 pts）：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "泪光 | Tears", "background": "「为什么哭呢？」\n\n“因为自己的期许和现实相去甚远。”\n\n「哭能改变什么呢？」\n\n“什么都不能。正如同既成事实的过去一样。”\n\n「那么为何不抹去泪水向前迈进呢？」\n\n“… 我在等我的灵魂追上时间。”\n\n> After night\n>\n> 长夜之后\n>\n> In boundless light\n>\n> 无垠光中\n>\n> He calls my name\n>\n> 他呼唤着我\n>\n> I do the same\n>\n> 我望向彼方，回应", "description": "「不想回忆的事，就别再去想了吧。为了分散你的注意力，正好我有一道与人的感情相关的题目，你看看怎么样？」\n\n“… 真是令人想吐槽呢。怎么，又是那个人在支配吗？”\n\n「什么嘛，令人不快… 你以前对这种事不是有很大的热情吗？」\n\n“… 说不准。”\n\n「咳咳… 那么听好了。现在共有 $n$ 个人，每个人都有一个情绪值：用 **实数** $v_i$ 表示。现在由于一些特殊的变化，使得这些人的情感发生了纠缠…」\n\n“嗯哼？”\n\n「第一种纠缠有四个参数 $a,b,c,d$，表示：现在已知存在无穷个 $f:\\R\\rightarrow\\R$，使得 $\\frac{f(v_a)}{f(v_b)}=\\frac{v_c}{v_d}$。」\n\n“等等等等一下！这数学公式是怎么说出来的啊？！还有什么 $f:\\R\\rightarrow\\R$ 是什么意思啊！”\n\n「你瞧，你不也说出来了吗？」\n\n“… 可恶，果然是你吗，那个人…”\n\n「简单来说，$f:\\R\\rightarrow\\R$ 就是代表一个定义域和值域都是实数的函数。如果这都不能理解的话，我要开始怀疑你作为高中生的身份了哦…」\n\n“好吧… 继续吧。”\n\n「第二种纠缠有两个参数 $a,b$，表示：现在已知存在有穷个 $f:\\R\\rightarrow\\R$，使得 $f(v_a)\\ne f(v_b)$。」\n\n“什么叫‘有穷个’？”\n\n「就是有一个确切的数目啦… 只要有一个自然数 $k$ 能表示这样函数的数目，那么就叫‘存在有穷个函数’哦？」\n\n“嗯…”\n\n「接下来，在纠缠不断增加的过程中，你也需要回答一些问题。第一种是，给出 $a,b$，你需要判断 $v_a$ 是否总是等于 $v_b$；第二种是，给出 $a$，你需要计算有多少个 $b$（$1\\le b\\le n$，$b$ 可以等于 $a$）使得 $v_a=v_b$ 恒成立。」\n\n“… 题目我明白了，但是这跟人的情感有什么关系吗？”\n\n「哈哈… 就是想逗你开心嘛，别那么严肃。」\n\n“… 无聊。”\n\n### 简要题意\n\n有 $n$ 个 **正实数** 变量 $v_1,\\dots,v_n$。你需要根据当前已知的条件作出判断。每次给出两种条件之一：\n\n- 给出常数 $a,b,c,d$：表示现在已知存在无穷个 $f:\\R\\rightarrow\\R$，使得 $\\frac{f(v_a)}{f(v_b)}=\\frac{v_c}{v_d}$。\n\n- 给出常数 $a,b$：表示现在已知存在有穷个 $f:\\R\\rightarrow\\R$，使得 $f(v_a)\\ne f(v_b)$。\n\n或者两种询问之一：\n\n- 给出常数 $a,b$：询问 $v_a=v_b$ 是否恒成立。\n\n- 给出常数 $a$：询问有多少个 $b$（$1\\le b\\le n$，$b$ 可以等于 $a$）使得 $v_a=v_b$ 恒成立。", "inputFormat": "第一行两个正整数 $n,m$，分别表示变量的数量和操作的次数。\n\n接下来 $m$ 行，每行表示一次操作，有四种可能：\n\n- `1 a b c d`：表示现在已知存在无穷个 $f:\\R\\rightarrow\\R$，使得 $\\frac{f(v_a)}{f(v_b)}=\\frac{v_c}{v_d}$。\n\n- `2 a b`：表示现在已知存在有穷个 $f:\\R\\rightarrow\\R$，使得 $f(v_a)\\ne f(v_b)$。\n\n- `3 a b`：询问 $v_a=v_b$ 是否恒成立。\n\n- `4 a`：询问有多少个 $b$（$1\\le b\\le n$，$b$ 可以等于 $a$）使得 $v_a=v_b$ 恒成立。", "outputFormat": "对于每次操作三，输出一行字符串 `entangled` 表示 $v_a=v_b$ 恒成立；反之输出一行字符串 `separate`。\n\n对于每次操作四，输出一行一个整数表示符合条件的 $b$ 的数目。", "hint": "对于全部数据，有 $1\\le n,m\\le 6\\times 10^5$。保证操作一中 $a\\ne b,c\\ne d$，操作二中 $a\\ne b$，操作三中 $a\\ne b$。\n\nSubtask 1（5 pts）：保证不出现操作一和操作二。\n\nSubtask 2（10 pts）：保证不出现操作一。\n\nSubtask 3（35 pts）：保证 $n\\le 5000$。\n\nSubtask 4（50 pts）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P8150", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2022", "交互题", "Special Judge"], "title": "再会 | Sayounara", "background": "「过去的都已经无所谓了吗？」\n\n“还没有达到那种地步。”\n\n「想做的事都已经完成了吗？」\n\n“如今的自己，也好像只能在取舍中前行。”\n\n「道过再会了吗？」\n\n“… 还没有，但我正尝试着。”\n\n> I have\n>\n> 我仍有\n>\n> plenty want to say\n>\n> 无数未道尽的言语\n>\n> Before\n>\n> 在离开之前\n>\n> I leave this world\n>\n> 在再会之前", "description": "「这是…？」\n\n“啊… 我自己写的日记管理程序。”\n\n「噗… ‘正常人谁写日记啊’，平时的你应该会这样说吧？」\n\n“… 别拿我说笑。”\n\n「好吧好吧。不过看上去你不记得密码了呢？」\n\n“…… 我自有手段。”\n\n「咦…？这什么，恢复软件吗？」\n\n“嗯… 密码可以被表示为一个长为 $n$ 的非负整数序列，**其中每个元素都互不相同** 。这个软件可以执行两种操作：一是，询问一个连续区间的总和减去这个区间最小值的结果；二是，询问一个位置的值。现在我需要找回密码的话…”\n\n「欸？为什么不直接用 $n$ 次第二种操作呢？」\n\n“这是试用版… 所以第二种操作只有两次使用的体验权限… 而且第一种操作似乎也有一定的限制，所以…”\n\n「这… 话说为什么恢复个密码这么麻烦啊？不应该会有‘找回密码’之类方便的机制吗？」\n\n“… 多半还是那个人的安排吧。”\n\n### 简要题意\n\n有一个元素互不相同的非负整数序列 $a$，其长度为 $n$。你可以多次进行以下两种询问之一：\n\n- 给出 $l,r$，得到 $\\left(\\sum_{k=l}^r a_k\\right)-\\left(\\min_{k=l}^r a_k\\right)$。\n\n- 给出 $k$，得到 $a_k$ 的值。这种询问最多只能进行两次。\n\n你需要在尽可能少的询问次数内推断出该序列的内容。\n\n**本题询问均以 $1$ 为初始下标，但你返回答案时需要返回以 $0$ 为初始下标的 `vector`，请留意。**\n\n### 交互说明\n\n本题仅限 C++11 / C++17 提交。你需要实现以下的函数：\n\n```cpp\n#include <cstdint>\n#include <vector>\n\nstd::vector<uint32_t> recover(int n);\n```\n\n该函数接收密码长度 $n$，返回还原的密码（返回值应该是一个大小为 $n$ 的 `vector`）。你可以使用以下两个函数\n\n```cpp\n#include <cstdint>\n\nuint64_t query(int l, int r);\nuint32_t get(int x);\n```\n\n其中 `query` 对应题目中的第一种操作，`get` 对应题目中的第二种操作。\n\n下面是一个示例程序（仅演示交互库操作）：\n\n```cpp\n#include <cstdint>\n#include <vector>\n\nuint64_t query(int l, int r);\nuint32_t get(int x);\n\nstd::vector<uint32_t> recover(int n) {\n\tstd::vector<uint32_t> ans(n);\n\tint what = query(1, n), hey = get(1);\n\tfor (int i = 0; i < n; ++i) ans[i] = i + 1;\n\treturn ans;\n}\n```\n\n题目提供了示例交互库 `lib.cpp`（并非交互库真实实现）。你可以在本地使用命令 `g++ -o code code.cpp lib.cpp` 来编译运行。", "inputFormat": "**这是交互库的输入格式，选手不需要，也无法从标准输入中读取任何信息。**\n\n第一行，一个正整数 $n$ 表示密码长度。\n\n第二行，$n$ 个非负整数表示密码。", "outputFormat": "**这是交互库的输出格式，选手不需要，也无法向标准输出中写入任何信息。**\n\n输出有四种：\n\n- `0 A B`：选手答案正确。其中 `A` 代表操作一的使用次数，`B` 代表操作二的使用次数。\n\n- `-1`：选手函数成功执行，但答案不正确。\n\n- `-2`：选手在调用操作一时传入的 $l,r$ 不满足要求。\n\n- `-3`：选手调用了超过 $2n$ 次操作一。\n\n- `-4`：选手调用了超过两次操作二。", "hint": "### 得分细则\n\n本题没有子任务。所有测试点保证 $n=10^6$。\n\n如果你在任何一个测试点中答案错误或超出询问限制，则本题你会得到 0 分的好成绩。\n\n如果你成功通过了所有测试点，记你在所有数据中调用操作一最多一次的次数为 $x$，则你本题的分数为：\n\n$$\n\\begin{cases}\n\\frac{60}{e^7-1}\\left(e^{10-\\max\\left\\{\\frac{x-10^6}{100},3\\right\\}}-1\\right)+40,&x\\le 1001000\\\\\n25,&\\mathrm{otherwise.}\n\\end{cases}\n$$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "再会 | Sayounara", "background": "「过去的都已经无所谓了吗？」\n\n“还没有达到那种地步。”\n\n「想做的事都已经完成了吗？」\n\n“如今的自己，也好像只能在取舍中前行。”\n\n「道过再会了吗？」\n\n“… 还没有，但我正尝试着。”\n\n> I have\n>\n> 我仍有\n>\n> plenty want to say\n>\n> 无数未道尽的言语\n>\n> Before\n>\n> 在离开之前\n>\n> I leave this world\n>\n> 在再会之前", "description": "「这是…？」\n\n“啊… 我自己写的日记管理程序。”\n\n「噗… ‘正常人谁写日记啊’，平时的你应该会这样说吧？」\n\n“… 别拿我说笑。”\n\n「好吧好吧。不过看上去你不记得密码了呢？」\n\n“…… 我自有手段。”\n\n「咦…？这什么，恢复软件吗？」\n\n“嗯… 密码可以被表示为一个长为 $n$ 的非负整数序列，**其中每个元素都互不相同** 。这个软件可以执行两种操作：一是，询问一个连续区间的总和减去这个区间最小值的结果；二是，询问一个位置的值。现在我需要找回密码的话…”\n\n「欸？为什么不直接用 $n$ 次第二种操作呢？」\n\n“这是试用版… 所以第二种操作只有两次使用的体验权限… 而且第一种操作似乎也有一定的限制，所以…”\n\n「这… 话说为什么恢复个密码这么麻烦啊？不应该会有‘找回密码’之类方便的机制吗？」\n\n“… 多半还是那个人的安排吧。”\n\n### 简要题意\n\n有一个元素互不相同的非负整数序列 $a$，其长度为 $n$。你可以多次进行以下两种询问之一：\n\n- 给出 $l,r$，得到 $\\left(\\sum_{k=l}^r a_k\\right)-\\left(\\min_{k=l}^r a_k\\right)$。\n\n- 给出 $k$，得到 $a_k$ 的值。这种询问最多只能进行两次。\n\n你需要在尽可能少的询问次数内推断出该序列的内容。\n\n**本题询问均以 $1$ 为初始下标，但你返回答案时需要返回以 $0$ 为初始下标的 `vector`，请留意。**\n\n### 交互说明\n\n本题仅限 C++11 / C++17 提交。你需要实现以下的函数：\n\n```cpp\n#include <cstdint>\n#include <vector>\n\nstd::vector<uint32_t> recover(int n);\n```\n\n该函数接收密码长度 $n$，返回还原的密码（返回值应该是一个大小为 $n$ 的 `vector`）。你可以使用以下两个函数\n\n```cpp\n#include <cstdint>\n\nuint64_t query(int l, int r);\nuint32_t get(int x);\n```\n\n其中 `query` 对应题目中的第一种操作，`get` 对应题目中的第二种操作。\n\n下面是一个示例程序（仅演示交互库操作）：\n\n```cpp\n#include <cstdint>\n#include <vector>\n\nuint64_t query(int l, int r);\nuint32_t get(int x);\n\nstd::vector<uint32_t> recover(int n) {\n\tstd::vector<uint32_t> ans(n);\n\tint what = query(1, n), hey = get(1);\n\tfor (int i = 0; i < n; ++i) ans[i] = i + 1;\n\treturn ans;\n}\n```\n\n题目提供了示例交互库 `lib.cpp`（并非交互库真实实现）。你可以在本地使用命令 `g++ -o code code.cpp lib.cpp` 来编译运行。", "inputFormat": "**这是交互库的输入格式，选手不需要，也无法从标准输入中读取任何信息。**\n\n第一行，一个正整数 $n$ 表示密码长度。\n\n第二行，$n$ 个非负整数表示密码。", "outputFormat": "**这是交互库的输出格式，选手不需要，也无法向标准输出中写入任何信息。**\n\n输出有四种：\n\n- `0 A B`：选手答案正确。其中 `A` 代表操作一的使用次数，`B` 代表操作二的使用次数。\n\n- `-1`：选手函数成功执行，但答案不正确。\n\n- `-2`：选手在调用操作一时传入的 $l,r$ 不满足要求。\n\n- `-3`：选手调用了超过 $2n$ 次操作一。\n\n- `-4`：选手调用了超过两次操作二。", "hint": "### 得分细则\n\n本题没有子任务。所有测试点保证 $n=10^6$。\n\n如果你在任何一个测试点中答案错误或超出询问限制，则本题你会得到 0 分的好成绩。\n\n如果你成功通过了所有测试点，记你在所有数据中调用操作一最多一次的次数为 $x$，则你本题的分数为：\n\n$$\n\\begin{cases}\n\\frac{60}{e^7-1}\\left(e^{10-\\max\\left\\{\\frac{x-10^6}{100},3\\right\\}}-1\\right)+40,&x\\le 1001000\\\\\n25,&\\mathrm{otherwise.}\n\\end{cases}\n$$", "locale": "zh-CN"}}}
{"pid": "P8151", "type": "P", "difficulty": 7, "samples": [["2 2", "4"], ["3 4", "26"], ["10 20", "2096384"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2022", "O2优化"], "title": "彼岸 | To See the Next Part of the Dream", "background": "「“看见梦境的下一个部分”…？」\n\n“是啊… ‘尽管身体已是成年人，但内心却依旧是那个不切实际的小孩，依旧是那个相信自己有着无尽可能的小孩——即使是在认清了现实和理想的鸿沟后，还仍是如此。年少时那个成为摇滚巨星的梦，如今已显得分外不可及，只能在一次次前行中看见梦的下一个部分’… 不觉得作者和我很像吗？”\n\n“曾经年少的自己对一切的未知都怀揣着好奇与欣喜，但如今仿佛只是在如同抓住救命稻草一般抓住自己背离现实的梦想，然后在生活的洋流中逐渐看见梦的下一个部分… 明知自己的失败，却仍在仿佛为了看见什么、达成什么一样向上登攀，这样一来，和作者所描述的‘active loser’也没什么两样吧…”\n\n「所以，你所期望看见的、期望达成的，究竟是什么呢？」\n\n“…”\n\n“现在的我，已经不知道了。”\n\n> 나의 어리고 멍청했던 날들은 사라져줬으면\n>\n> 如果那些年少无知的日子消失掉就好了\n>\n> 나의 소중한 인연들 이제는 추억속으로만\n>\n> 珍贵的感情 现在仅仅存在于在记忆中\n>\n> 만약 이 세상이 전부 누군가의 또다른 꿈이었다면\n>\n> 如果这个世界 只是别人的梦\n>\n> 언젠가 깨어나게 될때 나는 지금과는 달라져있을까\n>\n> 某天醒来时 我会变得不一样吗", "description": "「那么，你相信宿命吗？」\n\n“那种东西，顶多只是什么励志故事里的抒情工具吧。”\n\n「是吗… 那么要玩玩塔罗牌吗？」\n\n“谁会对那种事情感兴趣…”\n\n「真是的，你要再一副对什么事情都漠不关心的态度我要生气了…！」\n\n“好好好… 所以呢？塔罗牌呢？”\n\n「这个嘛… 嘿嘿，自己想象咯～」\n\n“什么毛病…”\n\n「现在有 $n$ 叠塔罗牌放在桌上，每一叠都有 $2^n$ 张，从桌面向上分别是 $1$ 号、$2$ 号… $n$ 号。现在作为宿命的管理者的我们——要洗一遍这些塔罗牌！」\n\n“怎么… 中二病开始传染了吗…”\n\n「那么，洗牌的过程是，将牌均匀地分成两半，下面一半和上面一半分别放在左右手；接着，右手从底部放下一张牌，左手从底部放下一张牌，右手又从底部放下一张牌… 这样交错重复，于是一次洗牌就完成了！」\n\n“例如 $n=2$ 时，假设原来的牌从下往上看是 $[1,2,3,4]$，洗一次牌后就会变成 $[3,1,4,2]$——是这样吗？”\n\n「是的！然后对于这 $n$ 叠初始时都按顺序从下到上摆放的塔罗牌，我会不操作第一叠牌，然后洗一次第二叠牌，洗两次第三叠牌… 洗 $n-1$ 次第 $n$ 叠牌。接下来，我会把这 $n$ 叠牌都从下到上地发给 $2^n$ 个人——也就是说第一个人会拿到每叠牌的第一张，第二个人会拿到每叠牌的第二张… 每一个人都恰好会拿到 $n$ 张牌。」\n\n「现在，定义一个人拿到和自己号码相同的牌的张数为这个人的幸运值。你能算出这 $n$ 个人幸运值的总和是多少吗？」\n\n“嗯… 撇开你粗制滥造的题面不谈，这个题目还是很有趣的。”\n\n「适可而止啊喂！」\n\n“… 我想了想，好像还挺简单的。不妨让我们记 $n=k$ 的时候的幸运值总和为 $f(k)$。现在你需要对 $l\\le k\\le r$ 的 $f(k)$ 求和，你看怎么样？”\n\n「… 不是很会了…」\n\n### 简要题意\n\n对于长度为 $2k$ 的序列 $a$，定义函数 $S_q(a)$，其中\n\n$$\nS_q(a)=\n\\begin{cases}\na,&q=0\\\\\n[a_{k+1},a_1,a_{k+2},a_2,\\dots,a_{2k},a_k],&q=1\\\\\nS_{q-1}(S_1(a)),&\\text{otherwise.}\n\\end{cases}\n$$\n\n现在给定正整数 $l,r$，求 $\\sum_{k=l}^r f(k)$，其中\n\n$$\nf(n)=\\sum_{q=0}^{n-1}\\sum_{k=1}^{2^n}\\left[S_q([1,2,3,\\dots,2^n])_k=k\\right]\n$$", "inputFormat": "一行两个正整数 $l,r$，代表求和的起始和终点。", "outputFormat": "输出一行一个正整数，代表 $\\sum_{k=l}^rf(k)$。答案对 $998244353$ 取模。", "hint": "### 样例解释\n\n以样例一中计算 $f(2)$ 为例。最初有 $2$ 叠牌，从下到上的牌都是 $[1,2,3,4]$。然后现在对第一叠牌不操作，第二叠牌洗一次，于是第二叠牌从下到上变成了 $[3,1,4,2]$。现在把两叠牌发给 $4$ 个人。第一个人拿到 $[1,3]$，第二个人拿到 $[2,1]$，第三个人拿到 $[3,4]$，第四个人拿到 $[4,2]$。发现每个人的幸运值都为 $1$（都恰好拿到了一张和自己号码相同的牌），于是幸运值总和就是 $4$，继而 $f(2)=4$。\n\n### 数据范围\n\n对于全部数据，有 $1\\le l\\le r\\le 10^{10}$。\n\nSubtask 1（10 pts）：保证 $l=r$ 且 $r\\le 12$。\n\nSubtask 2（35 pts）：保证 $l=r$。\n\nSubtask 3（15 pts）：保证 $1\\le l\\le r\\le 10^6$。\n\nSubtask 4（40 pts）：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "彼岸 | To See the Next Part of the Dream", "background": "「“看见梦境的下一个部分”…？」\n\n“是啊… ‘尽管身体已是成年人，但内心却依旧是那个不切实际的小孩，依旧是那个相信自己有着无尽可能的小孩——即使是在认清了现实和理想的鸿沟后，还仍是如此。年少时那个成为摇滚巨星的梦，如今已显得分外不可及，只能在一次次前行中看见梦的下一个部分’… 不觉得作者和我很像吗？”\n\n“曾经年少的自己对一切的未知都怀揣着好奇与欣喜，但如今仿佛只是在如同抓住救命稻草一般抓住自己背离现实的梦想，然后在生活的洋流中逐渐看见梦的下一个部分… 明知自己的失败，却仍在仿佛为了看见什么、达成什么一样向上登攀，这样一来，和作者所描述的‘active loser’也没什么两样吧…”\n\n「所以，你所期望看见的、期望达成的，究竟是什么呢？」\n\n“…”\n\n“现在的我，已经不知道了。”\n\n> 나의 어리고 멍청했던 날들은 사라져줬으면\n>\n> 如果那些年少无知的日子消失掉就好了\n>\n> 나의 소중한 인연들 이제는 추억속으로만\n>\n> 珍贵的感情 现在仅仅存在于在记忆中\n>\n> 만약 이 세상이 전부 누군가의 또다른 꿈이었다면\n>\n> 如果这个世界 只是别人的梦\n>\n> 언젠가 깨어나게 될때 나는 지금과는 달라져있을까\n>\n> 某天醒来时 我会变得不一样吗", "description": "「那么，你相信宿命吗？」\n\n“那种东西，顶多只是什么励志故事里的抒情工具吧。”\n\n「是吗… 那么要玩玩塔罗牌吗？」\n\n“谁会对那种事情感兴趣…”\n\n「真是的，你要再一副对什么事情都漠不关心的态度我要生气了…！」\n\n“好好好… 所以呢？塔罗牌呢？”\n\n「这个嘛… 嘿嘿，自己想象咯～」\n\n“什么毛病…”\n\n「现在有 $n$ 叠塔罗牌放在桌上，每一叠都有 $2^n$ 张，从桌面向上分别是 $1$ 号、$2$ 号… $n$ 号。现在作为宿命的管理者的我们——要洗一遍这些塔罗牌！」\n\n“怎么… 中二病开始传染了吗…”\n\n「那么，洗牌的过程是，将牌均匀地分成两半，下面一半和上面一半分别放在左右手；接着，右手从底部放下一张牌，左手从底部放下一张牌，右手又从底部放下一张牌… 这样交错重复，于是一次洗牌就完成了！」\n\n“例如 $n=2$ 时，假设原来的牌从下往上看是 $[1,2,3,4]$，洗一次牌后就会变成 $[3,1,4,2]$——是这样吗？”\n\n「是的！然后对于这 $n$ 叠初始时都按顺序从下到上摆放的塔罗牌，我会不操作第一叠牌，然后洗一次第二叠牌，洗两次第三叠牌… 洗 $n-1$ 次第 $n$ 叠牌。接下来，我会把这 $n$ 叠牌都从下到上地发给 $2^n$ 个人——也就是说第一个人会拿到每叠牌的第一张，第二个人会拿到每叠牌的第二张… 每一个人都恰好会拿到 $n$ 张牌。」\n\n「现在，定义一个人拿到和自己号码相同的牌的张数为这个人的幸运值。你能算出这 $n$ 个人幸运值的总和是多少吗？」\n\n“嗯… 撇开你粗制滥造的题面不谈，这个题目还是很有趣的。”\n\n「适可而止啊喂！」\n\n“… 我想了想，好像还挺简单的。不妨让我们记 $n=k$ 的时候的幸运值总和为 $f(k)$。现在你需要对 $l\\le k\\le r$ 的 $f(k)$ 求和，你看怎么样？”\n\n「… 不是很会了…」\n\n### 简要题意\n\n对于长度为 $2k$ 的序列 $a$，定义函数 $S_q(a)$，其中\n\n$$\nS_q(a)=\n\\begin{cases}\na,&q=0\\\\\n[a_{k+1},a_1,a_{k+2},a_2,\\dots,a_{2k},a_k],&q=1\\\\\nS_{q-1}(S_1(a)),&\\text{otherwise.}\n\\end{cases}\n$$\n\n现在给定正整数 $l,r$，求 $\\sum_{k=l}^r f(k)$，其中\n\n$$\nf(n)=\\sum_{q=0}^{n-1}\\sum_{k=1}^{2^n}\\left[S_q([1,2,3,\\dots,2^n])_k=k\\right]\n$$", "inputFormat": "一行两个正整数 $l,r$，代表求和的起始和终点。", "outputFormat": "输出一行一个正整数，代表 $\\sum_{k=l}^rf(k)$。答案对 $998244353$ 取模。", "hint": "### 样例解释\n\n以样例一中计算 $f(2)$ 为例。最初有 $2$ 叠牌，从下到上的牌都是 $[1,2,3,4]$。然后现在对第一叠牌不操作，第二叠牌洗一次，于是第二叠牌从下到上变成了 $[3,1,4,2]$。现在把两叠牌发给 $4$ 个人。第一个人拿到 $[1,3]$，第二个人拿到 $[2,1]$，第三个人拿到 $[3,4]$，第四个人拿到 $[4,2]$。发现每个人的幸运值都为 $1$（都恰好拿到了一张和自己号码相同的牌），于是幸运值总和就是 $4$，继而 $f(2)=4$。\n\n### 数据范围\n\n对于全部数据，有 $1\\le l\\le r\\le 10^{10}$。\n\nSubtask 1（10 pts）：保证 $l=r$ 且 $r\\le 12$。\n\nSubtask 2（35 pts）：保证 $l=r$。\n\nSubtask 3（15 pts）：保证 $1\\le l\\le r\\le 10^6$。\n\nSubtask 4（40 pts）：无特殊限制。", "locale": "zh-CN"}}}
