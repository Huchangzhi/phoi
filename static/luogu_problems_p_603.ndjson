{"pid": "P13235", "type": "P", "difficulty": 6, "samples": [["5\n12 0.666667\n001001010111\n11 0.400000\n10000100011\n9 0.000000\n111110111\n5 1.000000\n00000\n15 0.333333\n000000000011000", "Case #1: 5\nCase #2: 5\nCase #3: 5\nCase #4: 0\nCase #5: 6"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2015", "排序", "Google Code Jam"], "title": "[GCJ 2015 Finals] Pretty Good Proportion", "background": "", "description": "I have a sequence of $\\mathbf{N}$ binary digits. I am looking for a substring with just the right proportion of 0s and 1s, but it may not exist, so I will settle for something that's just pretty good.\n\nCan you find a substring where the fraction of 1s is as close as possible to the given fraction $\\mathbf{F}$? Output the earliest possible index at which such a substring starts.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each one starts with a line containing $\\mathbf{N}$ and $\\mathbf{F}$. $\\mathbf{F}$ will be a decimal fraction between 0 and 1 inclusive, with exactly 6 digits after the decimal point. The next line contains $\\mathbf{N}$ digits, each being either 0 or 1.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the 0-based index of the start of the substring with the fraction of 1s that is as close as possible to $\\mathbf{F}$. If there are multiple possible answers, output the smallest correct value.", "hint": "**Sample Explanation**\n\nIn Case #1, there is no substring that has exactly a $1$-proportion of exactly $666667/1000000$. The closest we can get is $2/3$. The input string has 5 substrings that achieve it -- $3$ substrings of length 3 that start at indices $5, 7,$ and $8$ ($101, 101,$ and $011$); as well as two substrings of length $6$ that start at indices $5$ and $6$ ($101011$ and $010111$). The smallest of these indices is $5$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{F} \\leq 1$\n- $\\mathbf{F}$ will have exactly 6 digits after the decimal point.\n\n**Small dataset**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 1000$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{N} \\leq 500,000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 Finals] Pretty Good Proportion", "background": "", "description": "I have a sequence of $\\mathbf{N}$ binary digits. I am looking for a substring with just the right proportion of 0s and 1s, but it may not exist, so I will settle for something that's just pretty good.\n\nCan you find a substring where the fraction of 1s is as close as possible to the given fraction $\\mathbf{F}$? Output the earliest possible index at which such a substring starts.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each one starts with a line containing $\\mathbf{N}$ and $\\mathbf{F}$. $\\mathbf{F}$ will be a decimal fraction between 0 and 1 inclusive, with exactly 6 digits after the decimal point. The next line contains $\\mathbf{N}$ digits, each being either 0 or 1.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the 0-based index of the start of the substring with the fraction of 1s that is as close as possible to $\\mathbf{F}$. If there are multiple possible answers, output the smallest correct value.", "hint": "**Sample Explanation**\n\nIn Case #1, there is no substring that has exactly a $1$-proportion of exactly $666667/1000000$. The closest we can get is $2/3$. The input string has 5 substrings that achieve it -- $3$ substrings of length 3 that start at indices $5, 7,$ and $8$ ($101, 101,$ and $011$); as well as two substrings of length $6$ that start at indices $5$ and $6$ ($101011$ and $010111$). The smallest of these indices is $5$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{F} \\leq 1$\n- $\\mathbf{F}$ will have exactly 6 digits after the decimal point.\n\n**Small dataset**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 1000$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{N} \\leq 500,000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 Finals] Pretty Good Proportion", "background": null, "description": "我有一个长度为 $N$ 的二进制数字序列。我正在寻找一个子串，使得其中 $1$ 的比例恰好等于给定的分数 $F$，但这样的子串可能不存在，所以我会选择一个比例最接近 $F$ 的子串。\n\n你能找到一个子串，使得其中 $1$ 的比例尽可能接近给定的分数 $F$ 吗？请输出这样一个子串最早出现的起始下标。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为 $N$ 和 $F$。$F$ 是一个介于 $0$ 和 $1$ 之间的十进制小数，且小数点后恰好有 $6$ 位。下一行为 $N$ 个数字，每个数字为 $0$ 或 $1$。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #x: y\"，其中 $x$ 表示测试用例编号（从 $1$ 开始），$y$ 表示满足条件的子串的最小起始下标（从 $0$ 开始）。如果有多个答案，输出最小的下标。", "hint": "**样例解释**\n\n在第 1 组测试数据中，没有子串的 $1$ 比例恰好等于 $666667/1000000$。最接近的比例是 $2/3$。输入字符串中有 $5$ 个子串达到了这个比例——长度为 $3$ 的子串有 $3$ 个，分别从下标 $5, 7, 8$ 开始（$101, 101, 011$）；长度为 $6$ 的子串有 $2$ 个，分别从下标 $5, 6$ 开始（$101011, 010111$）。这些下标中最小的是 $5$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $0 \\leq F \\leq 1$。\n- $F$ 恰好有 $6$ 位小数。\n\n**小数据范围**\n\n- 时间限制：5 秒。\n- $1 \\leq N \\leq 1000$。\n\n**大数据范围**\n\n- 时间限制：10 秒。\n- $1 \\leq N \\leq 500,\\!000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13236", "type": "P", "difficulty": 7, "samples": [["5\n3 2 1\n0 1\n1 2\n3 2 2\n0 1\n1 2\n3 2 3\n0 1\n1 2\n4 4 2\n0 1\n0 2\n1 3\n2 3\n7 11 3\n0 1\n0 2\n0 3\n1 4\n1 5\n2 4\n2 5\n3 4\n3 5\n4 6\n5 6", "Case #1: 3\nCase #2: 4\nCase #3: 4\nCase #4: 3\nCase #5: 5"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["图论", "2015", "二分", "网络流", "图论建模", "Google Code Jam"], "title": "[GCJ 2015 Finals] Taking Over The World", "background": "", "description": "You and your friend Pinky have a plan to take over the world. But first you need to disable a certain secret weapon.\n\nIt is hidden inside a twisted maze of passages (a graph) with one entrance. Pinky is going to be at the vertex with the secret weapon, disabling it. Meanwhile, a security team at the graph entrance will be alerted, and will run through the graph to try to get to Pinky in time to stop him. You are going to be slowing down the security team to give Pinky as much time as possible. It takes one unit of time to traverse any edge of the graph, but you can additionally \"obstruct\" up to $\\mathbf{K}$ vertices. It takes one additional unit of time to traverse an obstructed vertex. You will choose to obstruct a set of vertices that slows down the security team by as much as possible.\n\nIf the security team will be starting at the graph entrance and is trying to get to the secret weapon vertex, how much time will it take them to get there? Note that you have to commit all your obstructions before the security guards start their journey, and the security guards will know which vertices you have obstructed and will choose an optimal path based on that information.\n\nObstructing the secret weapon vertex is not useful because that will not delay the guards any further after they have already caught Pinky. Obstructing the entrance, on the other hand, is obviously a good idea.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each one starts with a line containing $\\mathbf{N}, \\mathbf{M}$, and $\\mathbf{K}$. The next $\\mathbf{M}$ lines each contain a pair of vertices connected by an edge. Vertices are numbered from 0 (the entrance) to $\\mathbf{N}-1$ (the secret weapon room). The first vertex will always be smaller than the second vertex, and no pair of vertices will appear more than once in the same test case. Edges are bi-directional -- the guards can travel along any edge in either direction.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the time it will take the security guards to get from the entrance to the secret weapon room.", "hint": "**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 100$.\n- $1 \\leq \\mathbf{M} \\leq \\mathbf{N} \\times (\\mathbf{N} - 1) / 2$.\n- $1 \\leq \\mathbf{K} \\leq \\mathbf{N}$.\n- There will always be a path from room 0 to room $\\mathbf{N} - 1$.\n\n**Small dataset(7 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- It will not be possible to delay the guards by more than 2 time units, compared to the shortest unobstructed path length (using the given $\\mathbf{K}$).\n\n**Large dataset(29 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- No extra restrictions.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 Finals] Taking Over The World", "background": "", "description": "You and your friend Pinky have a plan to take over the world. But first you need to disable a certain secret weapon.\n\nIt is hidden inside a twisted maze of passages (a graph) with one entrance. Pinky is going to be at the vertex with the secret weapon, disabling it. Meanwhile, a security team at the graph entrance will be alerted, and will run through the graph to try to get to Pinky in time to stop him. You are going to be slowing down the security team to give Pinky as much time as possible. It takes one unit of time to traverse any edge of the graph, but you can additionally \"obstruct\" up to $\\mathbf{K}$ vertices. It takes one additional unit of time to traverse an obstructed vertex. You will choose to obstruct a set of vertices that slows down the security team by as much as possible.\n\nIf the security team will be starting at the graph entrance and is trying to get to the secret weapon vertex, how much time will it take them to get there? Note that you have to commit all your obstructions before the security guards start their journey, and the security guards will know which vertices you have obstructed and will choose an optimal path based on that information.\n\nObstructing the secret weapon vertex is not useful because that will not delay the guards any further after they have already caught Pinky. Obstructing the entrance, on the other hand, is obviously a good idea.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each one starts with a line containing $\\mathbf{N}, \\mathbf{M}$, and $\\mathbf{K}$. The next $\\mathbf{M}$ lines each contain a pair of vertices connected by an edge. Vertices are numbered from 0 (the entrance) to $\\mathbf{N}-1$ (the secret weapon room). The first vertex will always be smaller than the second vertex, and no pair of vertices will appear more than once in the same test case. Edges are bi-directional -- the guards can travel along any edge in either direction.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the time it will take the security guards to get from the entrance to the secret weapon room.", "hint": "**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 100$.\n- $1 \\leq \\mathbf{M} \\leq \\mathbf{N} \\times (\\mathbf{N} - 1) / 2$.\n- $1 \\leq \\mathbf{K} \\leq \\mathbf{N}$.\n- There will always be a path from room 0 to room $\\mathbf{N} - 1$.\n\n**Small dataset(7 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- It will not be possible to delay the guards by more than 2 time units, compared to the shortest unobstructed path length (using the given $\\mathbf{K}$).\n\n**Large dataset(29 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- No extra restrictions.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 Finals] Taking Over The World", "background": null, "description": "你和你的朋友 Pinky 有一个征服世界的计划。但首先，你们需要关闭一个秘密武器。\n\n这个武器被藏在一个错综复杂的迷宫（一个图）中，只有一个入口。Pinky 将会在有秘密武器的房间（顶点）里关闭它。与此同时，安全小队会在图的入口处被警报唤醒，并试图穿过图去阻止 Pinky。你要尽可能拖慢安全小队的速度，为 Pinky 争取时间。通过任意一条边都需要 1 个时间单位，但你还可以“阻碍”最多 $K$ 个顶点。每经过一个被阻碍的顶点，需要额外花费 1 个时间单位。你需要选择一组顶点进行阻碍，使得安全小队到达秘密武器房间所需的时间尽可能长。\n\n安全小队会从图的入口出发，目标是到达秘密武器房间。你需要在安全小队开始行动前就决定所有要阻碍的顶点，且安全小队会知道你阻碍了哪些顶点，并会选择最优路径。\n\n阻碍秘密武器房间没有意义，因为当安全小队到达那里时，Pinky 已经被抓住，无法再拖延时间。另一方面，阻碍入口显然是一个好主意。", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为 $N, M, K$。接下来的 $M$ 行，每行包含一对顶点，表示一条边。顶点编号从 $0$（入口）到 $N-1$（秘密武器房间）。每对顶点中，第一个编号总是小于第二个编号，并且同一组测试数据中不会有重复的边。所有边都是双向的——安全小队可以沿任意方向通过。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #x: y\"，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是安全小队从入口到秘密武器房间所需的时间。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq N \\leq 100$。\n- $1 \\leq M \\leq N \\times (N - 1) / 2$。\n- $1 \\leq K \\leq N$。\n- 保证从房间 0 到房间 $N-1$ 总是存在一条路径。\n\n**小数据集（7 分）**\n\n- 时间限制：5 秒。\n- 使用给定的 $K$，安全小队最多只能被延迟 2 个时间单位（相较于最短未阻碍路径）。\n\n**大数据集（29 分）**\n\n- 时间限制：10 秒。\n- 无额外限制。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13237", "type": "P", "difficulty": 6, "samples": [["2\n3 1\n1\n0\n-1\n3 3\n-7 5 0\n10 10 0\n3 -20 2", "Case #1: 1\nCase #2: 27"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["2015", "枚举", "Google Code Jam"], "title": "[GCJ 2015 Finals] Merlin QA", "background": "", "description": "Edythe is a young sorceress working in the quality assurance department of Merlin, Inc. -- a magic spell factory. Her job is to test the magic spells that Merlin himself invents. Each spell requires precise amounts of certain ingredients and transforms them into other amounts of other ingredients. Edythe's job is to cast each spell exactly once in order to verify that the spell works correctly.\n\nShe can cast a spell only if she has the required amount of each ingredient. If she has already created ingredients of the right type from previous spells, Edythe must use those first. However, if she still needs more ingredients, she is allowed to take them from Merlin's storehouse. She has no ingredients to start with, but at the end, she gets to keep all the extra ingredients that she created and didn't use.\n\nEdythe wants to make as much profit as possible from her apprenticeship! She has to cast each of the $\\mathrm{N}$ given spells exactly once, but she is free to do so in any order. Assuming that each spell works as expected, which ordering lets her earn the most money in the end?\n\nFor example, imagine that the test plan contains the following 3 spells:\n\n1. Inputs: \\$ $7$ worth of gold. Outputs: \\$ $5$ worth of sulfur.\n2. Inputs: nothing. Outputs: \\$ $10$ worth of gold, \\$ $10$ worth of sulfur.\n3. Inputs: \\$ $3$ worth of gold, \\$ $20$ worth of sulfur. Outputs: \\$ $2$ worth of toads.\n\nNote that the first spell converts gold into sulfur, the second spell conjures up gold and sulfur from nothing, and the third spell converts gold and sulfur into toads.\n\nIf Edythe were to cast these spells in the order 1, 2, 3, then she would start by fetching \\$ $7$ worth of gold from the storehouse for spell #1. That would let her cast spells #1 and #2, giving her \\$ $10$ worth of gold and \\$ $15$ worth of sulfur. For the final spell, she would need \\$ $3$ worth of gold and \\$ $20$ worth of sulfur. She would have to use all of the sulfur she created so far, \\$ $3$ worth of gold, and \\$ $5$ more worth of sulfur that she fetched from the storehouse. This would leave her with \\$ $9$ worth of ingredients at the end (\\$ $7$ worth of gold and \\$ $2$ worth of toads).\n\nBut there is a better plan. If she cast the spells in the order 3, 1, 2, she would have \\$ $27$ worth of ingredients at the end (\\$ $10$ worth of gold, \\$ $15$ worth of sulfur, and \\$ $2$ worth of toads).\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each one starts with a line containing $\\mathbf{N}$ and $\\mathbf{M}$. $\\mathbf{M}$ is the number of kinds of ingredients in the world. Each of the next $\\mathbf{N}$ lines contains $\\mathbf{M}$ integers describing a spell. Each integer is the value (or cost) of the corresponding ingredient. Negative integers are the dollar costs of the input ingredients; positive integers are the dollar values of the output ingredients; and zeros denote ingredients that are neither produced nor consumed by the spell. This also implies that no spell can simultaneously consume and produce the same ingredient.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the largest value of ingredients Edythe can have at the end.\n", "hint": "**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{N} \\leq 100$.\n- $-100 \\leq$ Each integer in each spell $\\leq 100$.\n\n**Small dataset(8 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathbf{M} \\leq 2$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{M} \\leq 8$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 Finals] Merlin QA", "background": "", "description": "Edythe is a young sorceress working in the quality assurance department of Merlin, Inc. -- a magic spell factory. Her job is to test the magic spells that Merlin himself invents. Each spell requires precise amounts of certain ingredients and transforms them into other amounts of other ingredients. Edythe's job is to cast each spell exactly once in order to verify that the spell works correctly.\n\nShe can cast a spell only if she has the required amount of each ingredient. If she has already created ingredients of the right type from previous spells, Edythe must use those first. However, if she still needs more ingredients, she is allowed to take them from Merlin's storehouse. She has no ingredients to start with, but at the end, she gets to keep all the extra ingredients that she created and didn't use.\n\nEdythe wants to make as much profit as possible from her apprenticeship! She has to cast each of the $\\mathrm{N}$ given spells exactly once, but she is free to do so in any order. Assuming that each spell works as expected, which ordering lets her earn the most money in the end?\n\nFor example, imagine that the test plan contains the following 3 spells:\n\n1. Inputs: \\$ $7$ worth of gold. Outputs: \\$ $5$ worth of sulfur.\n2. Inputs: nothing. Outputs: \\$ $10$ worth of gold, \\$ $10$ worth of sulfur.\n3. Inputs: \\$ $3$ worth of gold, \\$ $20$ worth of sulfur. Outputs: \\$ $2$ worth of toads.\n\nNote that the first spell converts gold into sulfur, the second spell conjures up gold and sulfur from nothing, and the third spell converts gold and sulfur into toads.\n\nIf Edythe were to cast these spells in the order 1, 2, 3, then she would start by fetching \\$ $7$ worth of gold from the storehouse for spell #1. That would let her cast spells #1 and #2, giving her \\$ $10$ worth of gold and \\$ $15$ worth of sulfur. For the final spell, she would need \\$ $3$ worth of gold and \\$ $20$ worth of sulfur. She would have to use all of the sulfur she created so far, \\$ $3$ worth of gold, and \\$ $5$ more worth of sulfur that she fetched from the storehouse. This would leave her with \\$ $9$ worth of ingredients at the end (\\$ $7$ worth of gold and \\$ $2$ worth of toads).\n\nBut there is a better plan. If she cast the spells in the order 3, 1, 2, she would have \\$ $27$ worth of ingredients at the end (\\$ $10$ worth of gold, \\$ $15$ worth of sulfur, and \\$ $2$ worth of toads).\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each one starts with a line containing $\\mathbf{N}$ and $\\mathbf{M}$. $\\mathbf{M}$ is the number of kinds of ingredients in the world. Each of the next $\\mathbf{N}$ lines contains $\\mathbf{M}$ integers describing a spell. Each integer is the value (or cost) of the corresponding ingredient. Negative integers are the dollar costs of the input ingredients; positive integers are the dollar values of the output ingredients; and zeros denote ingredients that are neither produced nor consumed by the spell. This also implies that no spell can simultaneously consume and produce the same ingredient.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the largest value of ingredients Edythe can have at the end.\n", "hint": "**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{N} \\leq 100$.\n- $-100 \\leq$ Each integer in each spell $\\leq 100$.\n\n**Small dataset(8 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathbf{M} \\leq 2$.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{M} \\leq 8$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 Finals] Merlin QA", "background": null, "description": "Edythe 是一名年轻的女巫师，在 Merlin, Inc. 的质量保证部门工作——这是一家魔法咒语工厂。她的工作是测试 Merlin 本人发明的魔法咒语。每个咒语都需要精确数量的某些原材料，并将它们转化为其它数量的其他原材料。Edythe 的任务是每个咒语都恰好施放一次，以验证咒语是否正确。\n\n她只有在拥有每种原材料所需数量时才能施放咒语。如果她已经通过之前的咒语创造出了所需类型的原材料，Edythe 必须优先使用这些原材料。然而，如果她仍然需要更多的原材料，她可以从 Merlin 的仓库中取用。她一开始没有任何原材料，但在最后，她可以保留所有自己创造且未使用的多余原材料。\n\nEdythe 希望能通过学徒期赚取尽可能多的利润！她必须恰好施放给定的 $\\mathrm{N}$ 个咒语各一次，但可以以任意顺序进行。假设每个咒语都如预期般工作，哪种施放顺序能让她最终获得最多的金钱呢？\n\n例如，假设测试计划包含以下 3 个咒语：\n\n1. 输入：价值 \\$ $7$ 的黄金。输出：价值 \\$ $5$ 的硫磺。\n2. 输入：无。输出：价值 \\$ $10$ 的黄金，价值 \\$ $10$ 的硫磺。\n3. 输入：价值 \\$ $3$ 的黄金，价值 \\$ $20$ 的硫磺。输出：价值 \\$ $2$ 的蟾蜍。\n\n注意，第一个咒语将黄金转化为硫磺，第二个咒语凭空创造黄金和硫磺，第三个咒语将黄金和硫磺转化为蟾蜍。\n\n如果 Edythe 按顺序 1、2、3 施放这些咒语，她会先为第 1 个咒语从仓库取出价值 \\$ $7$ 的黄金。这样她就可以施放第 1 和第 2 个咒语，得到价值 \\$ $10$ 的黄金和 \\$ $15$ 的硫磺。对于最后一个咒语，她需要 \\$ $3$ 的黄金和 \\$ $20$ 的硫磺。她必须用掉迄今为止创造的所有硫磺、\\$ $3$ 的黄金，以及再从仓库取 \\$ $5$ 的硫磺。最终她会剩下价值 \\$ $9$ 的原材料（\\$ $7$ 的黄金和 \\$ $2$ 的蟾蜍）。\n\n但还有更好的方案。如果她按顺序 3、1、2 施放咒语，最终她会剩下价值 \\$ $27$ 的原材料（\\$ $10$ 的黄金、\\$ $15$ 的硫磺和 \\$ $2$ 的蟾蜍）。", "inputFormat": "输入的第一行给出测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例的第一行包含 $\\mathbf{N}$ 和 $\\mathbf{M}$。$\\mathbf{M}$ 是世界中原材料的种类数。接下来的 $\\mathbf{N}$ 行，每行包含 $\\mathbf{M}$ 个整数，描述一个咒语。每个整数表示对应原材料的价值（或成本）。负整数表示输入原材料的美元成本；正整数表示输出原材料的美元价值；零表示该咒语既不产生也不消耗该原材料。这也意味着没有任何咒语会同时消耗和产生同一种原材料。", "outputFormat": "对于每个测试用例，输出一行，格式为 “Case #x: y”，其中 $\\mathrm{x}$ 是测试用例编号（从 1 开始），$\\mathrm{y}$ 是 Edythe 最终能拥有的最大原材料价值。", "hint": "**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{N} \\leq 100$。\n- 每个咒语中的每个整数 $-100 \\leq \\text{值} \\leq 100$。\n\n**小数据集（8 分）**\n\n- 时间限制：~~240~~ 5 秒。\n- $1 \\leq \\mathbf{M} \\leq 2$。\n\n**大数据集**\n\n- 时间限制：~~480~~ 10 秒。\n- $1 \\leq \\mathbf{M} \\leq 8$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13238", "type": "P", "difficulty": 7, "samples": [["4\nufffdddbbbdd\ndddd(fdbu)fff\ndddd(fdddddbu)f(fdddddbu)\nbf", "Case #1: 6\nCase #2: 11\nCase #3: 49\nCase #4: 2"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2015", "Google Code Jam"], "title": "[GCJ 2015 Finals] Crane Truck", "background": "", "description": "You are in a large storage facility, with $2^{40}$ storage locations arranged in a circle.\n\nA truck with a crane on it moves along the circle of storage locations, picking up or putting down crates according to a program. (The truck has an unlimited supply of crates on board, so it can always put more crates down.)\n\nThe program consists of a sequence of these instructions:\n\n* b: move back one location\n* f: move forward one location\n* u: pick up one crate at the current location\n* d: put down one crate at the current location\n* (: do nothing\n* ): if there is more than one crate at the current location, move back to the most recent ( in the sequence of instructions, and continue the program from there. (This doesn't move the truck.)\n\n( and ) instructions in the program will always come in pairs: a ( will be followed later by a matching ). There will be at most two such pairs in the program, and if there are two pairs, they will not be nested – that is, there will be either:\n\n* no ( or ) instructions;\n* one ( instruction somewhere in the program, followed later by one ) instruction;\n* a ( instruction, followed later by a ) instruction, followed later by another (, and again later by another ).\n\nThe sample cases contain examples of each of these.\n\nEach storage location begins with one crate, before the crane truck starts running its program.\n\nMysteriously, if the truck picks up the last crate at a location, another truck instantly comes along and puts down 256 crates there! Similarly, if the truck puts down a crate at a location, and that location then has 257 crates, another truck instantly drives past and picks up 256 of the crates, leaving one behind! So every location always has between 1 and 256 crates.\n\nHow many times will the truck move forward or backward before reaching the end of its program?", "inputFormat": "One line containing an integer $T$, the number of test cases in the program.\n\n$T$ lines, each containing a crane truck program with up to 2000 characters.", "outputFormat": "$T$ lines, one for each test case, containing \"Case #$X$: $Y$\" where $X$ is the test case number, and $Y$ is the number of times the truck moves.\n", "hint": "**Limits**\n\n- $1 \\leq T \\leq 20$.\n- $1 \\leq$ the length of the program $\\leq 2000$.\n- The program is guaranteed to terminate.\n\n**Small dataset**\n\n- Time limit: ~~240~~ 5 seconds.\n- The program will contain at most one pair of ( and ) instructions.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- The program will contain at most two pairs of ( and ) instructions.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 Finals] Crane Truck", "background": "", "description": "You are in a large storage facility, with $2^{40}$ storage locations arranged in a circle.\n\nA truck with a crane on it moves along the circle of storage locations, picking up or putting down crates according to a program. (The truck has an unlimited supply of crates on board, so it can always put more crates down.)\n\nThe program consists of a sequence of these instructions:\n\n* b: move back one location\n* f: move forward one location\n* u: pick up one crate at the current location\n* d: put down one crate at the current location\n* (: do nothing\n* ): if there is more than one crate at the current location, move back to the most recent ( in the sequence of instructions, and continue the program from there. (This doesn't move the truck.)\n\n( and ) instructions in the program will always come in pairs: a ( will be followed later by a matching ). There will be at most two such pairs in the program, and if there are two pairs, they will not be nested – that is, there will be either:\n\n* no ( or ) instructions;\n* one ( instruction somewhere in the program, followed later by one ) instruction;\n* a ( instruction, followed later by a ) instruction, followed later by another (, and again later by another ).\n\nThe sample cases contain examples of each of these.\n\nEach storage location begins with one crate, before the crane truck starts running its program.\n\nMysteriously, if the truck picks up the last crate at a location, another truck instantly comes along and puts down 256 crates there! Similarly, if the truck puts down a crate at a location, and that location then has 257 crates, another truck instantly drives past and picks up 256 of the crates, leaving one behind! So every location always has between 1 and 256 crates.\n\nHow many times will the truck move forward or backward before reaching the end of its program?", "inputFormat": "One line containing an integer $T$, the number of test cases in the program.\n\n$T$ lines, each containing a crane truck program with up to 2000 characters.", "outputFormat": "$T$ lines, one for each test case, containing \"Case #$X$: $Y$\" where $X$ is the test case number, and $Y$ is the number of times the truck moves.\n", "hint": "**Limits**\n\n- $1 \\leq T \\leq 20$.\n- $1 \\leq$ the length of the program $\\leq 2000$.\n- The program is guaranteed to terminate.\n\n**Small dataset**\n\n- Time limit: ~~240~~ 5 seconds.\n- The program will contain at most one pair of ( and ) instructions.\n\n**Large dataset**\n\n- Time limit: ~~480~~ 10 seconds.\n- The program will contain at most two pairs of ( and ) instructions.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 Finals] Crane Truck", "background": null, "description": "你现在处于一个巨大的仓库中，仓库有 $2^{40}$ 个储存位置，这些位置以环形排列。\n\n一辆带有起重机的卡车沿着这些储存位置的环形轨道移动，根据一段程序来搬运箱子（卡车上有无限数量的箱子，因此可以随时放下更多箱子）。\n\n程序由以下指令序列组成：\n\n- b：向后移动一个位置\n- f：向前移动一个位置\n- u：在当前位置取走一个箱子\n- d：在当前位置放下一个箱子\n- (：什么都不做\n- )：如果当前位置的箱子数量大于 1，则回到指令序列中最近的 ( 处，并从那里继续执行程序（卡车不会移动）。\n\n程序中的 ( 和 ) 指令总是成对出现：一个 ( 之后总会有一个匹配的 )。程序中最多只会有两对这样的括号，并且如果有两对括号，它们不会嵌套——也就是说，可能有以下三种情况：\n\n- 程序中没有 ( 或 ) 指令；\n- 程序中有一个 (，之后有一个匹配的 )；\n- 程序中有一个 (，之后有一个 )，再之后有另一个 (，最后还有一个 )。\n\n样例中包含了每种情况的例子。\n\n在起重机卡车开始执行程序前，每个储存位置初始都有一个箱子。\n\n神奇的是，如果卡车在某个位置取走了最后一个箱子，另一辆卡车会立刻过来并在该位置放下 256 个箱子！同样地，如果卡车在某个位置放下一个箱子，导致该位置箱子数达到 257，另一辆卡车会立刻过来取走 256 个箱子，只留下一个！因此，每个位置的箱子数始终保持在 1 到 256 之间。\n\n卡车在到达程序末尾前，前进或后退了多少次？", "inputFormat": "第一行包含一个整数 $T$，表示测试用例的数量。\n\n接下来的 $T$ 行，每行包含一条起重机卡车的程序，长度不超过 2000 个字符。", "outputFormat": "共 $T$ 行，每行输出 \"Case #$X$: $Y$\"，其中 $X$ 是测试用例编号，$Y$ 是卡车移动的次数。", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 20$。\n- 程序长度 $1 \\leq \\text{length} \\leq 2000$。\n- 保证程序一定会终止。\n\n**小数据集**\n\n- 时间限制：5 秒。\n- 程序中最多只会有一对括号指令。\n\n**大数据集**\n\n- 时间限制：10 秒。\n- 程序中最多只会有两对括号指令。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13239", "type": "P", "difficulty": 3, "samples": [["3\n1 7 3 8 9 4\n1665 5 8888 3 4 27\n1 1 2", "21 34\n11 10558"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "堆"], "title": "「2.48sOI R1」化妆品", "background": "本月 $30$ 日即将迎来埃尔萨纳城的第 $17367$ 次名媛聚会。Misserina 和 ShenTianYi_ 正在为此做准备，她们在商场购买化妆品。", "description": "商场里面有 $2n$ 个化妆品，每一个都能提供时尚值和美丽值。任意两个化妆品提供的时尚值互不相同，且美丽值也互不相同。\n\nMisserina 和 ShenTianYi_ 要选择 $n$ 次心仪的化妆品，每一次 Misserina 先选，ShenTianYi_ 后选。Misserina 是个性格多变的人，她时而希望自己更加时尚，时而希望自己更加美丽，会选择剩余的化妆品中该值最大的那一个；而 ShenTianYi_ 则是淑女中的淑女，每一次 Misserina 选择她想要的之后她都会选择 Misserina 最不想要的那个，也就是对应时尚值或美丽值最小的那个。\n\n她们想知道，按照这个规则选完所有化妆品之后，两人的时尚值和美丽值分别为多少。请帮她们解答这个问题。", "inputFormat": "第一行：一个整数 $n$，含义如题干所示。\n\n第二行：$2n$ 个整数 $F_1,F_2,\\dots,F_{2n}$，表示每一个化妆品提供的时尚值。\n\n第三行：$2n$ 个整数 $B_1,B_2,\\dots,B_{2n}$，表示每一个化妆品提供的美丽值。\n\n第四行：$n$ 个整数 $Q_1,Q_2,\\dots,Q_n$，表示 Misserina 每次希望购买时尚值最高的（用 `1` 表示）还是美丽值最高的（用 `2` 表示）。", "outputFormat": "第一行两个整数，分别表示最终 Misserina 的时尚值和美丽值。\n\n第二行两个整数，分别表示最终 ShenTianYi_ 的时尚值和美丽值。", "hint": "第一次选择：\n\nMisserina 选择时尚值最高的即第 $5$ 种化妆品，ShenTianYi_ 选择时尚值最低的即第 $1$ 种化妆品。\n\n第二次选择：\n\nMisserina 选择剩下的时尚值最高的即第 $4$ 种化妆品，ShenTianYi_ 选择剩下的时尚值最低的第 $3$ 种化妆品。\n\n第三次选择：\n\nMisserina 选择剩下的美丽值最高的第 $6$ 种化妆品，ShenTianYi_ 选择剩下的美丽值最低的第 $2$ 种化妆品。\n\n最终 Misserina 的时尚值为 $8+9+4=21$，美丽值为 $3+4+27=34$；ShenTianYi_ 的时尚值为 $1+7+3=11$，美丽值为 $1665+5+8888=10558$。\n\n对于 $100\\%$ 数据：\n- $1 \\le n \\le 5 \\times 10^5$；\n- $1 \\le F_i,B_i \\le 10^9$；\n- $Q_i \\in \\{1,2\\}$；\n- $\\forall\\: i \\ne j$，$F_i \\ne F_j$，$B_i \\ne B_j$。\n\n**本题采取捆绑测试。**\n\n- Subtask 0（9 pts）：$1 \\le n \\le 1000$，$1 \\le F_i,B_i \\le 2000$，$Q_i$ 均为 `1` 或均为 `2`；\n- Subtask 1（11 pts）：$1 \\le n \\le 1000$，$1 \\le F_i,B_i \\le 2000$；\n- Subtask 2（20 pts）：$1 \\le n \\le 1000$，$1 \\le F_i,B_i \\le 10^9$；\n- Subtask 3（26 pts）：$1 \\le n \\le 5 \\times 10^5$，$1 \\le F_i,B_i \\le 10^9$，$Q_i$ 均为 `1` 或均为 `2`；\n- Subtask 4（34 pts）：$1 \\le n \\le 5 \\times 10^5$，$1 \\le F_i,B_i \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「2.48sOI R1」化妆品", "background": "本月 $30$ 日即将迎来埃尔萨纳城的第 $17367$ 次名媛聚会。Misserina 和 ShenTianYi_ 正在为此做准备，她们在商场购买化妆品。", "description": "商场里面有 $2n$ 个化妆品，每一个都能提供时尚值和美丽值。任意两个化妆品提供的时尚值互不相同，且美丽值也互不相同。\n\nMisserina 和 ShenTianYi_ 要选择 $n$ 次心仪的化妆品，每一次 Misserina 先选，ShenTianYi_ 后选。Misserina 是个性格多变的人，她时而希望自己更加时尚，时而希望自己更加美丽，会选择剩余的化妆品中该值最大的那一个；而 ShenTianYi_ 则是淑女中的淑女，每一次 Misserina 选择她想要的之后她都会选择 Misserina 最不想要的那个，也就是对应时尚值或美丽值最小的那个。\n\n她们想知道，按照这个规则选完所有化妆品之后，两人的时尚值和美丽值分别为多少。请帮她们解答这个问题。", "inputFormat": "第一行：一个整数 $n$，含义如题干所示。\n\n第二行：$2n$ 个整数 $F_1,F_2,\\dots,F_{2n}$，表示每一个化妆品提供的时尚值。\n\n第三行：$2n$ 个整数 $B_1,B_2,\\dots,B_{2n}$，表示每一个化妆品提供的美丽值。\n\n第四行：$n$ 个整数 $Q_1,Q_2,\\dots,Q_n$，表示 Misserina 每次希望购买时尚值最高的（用 `1` 表示）还是美丽值最高的（用 `2` 表示）。", "outputFormat": "第一行两个整数，分别表示最终 Misserina 的时尚值和美丽值。\n\n第二行两个整数，分别表示最终 ShenTianYi_ 的时尚值和美丽值。", "hint": "第一次选择：\n\nMisserina 选择时尚值最高的即第 $5$ 种化妆品，ShenTianYi_ 选择时尚值最低的即第 $1$ 种化妆品。\n\n第二次选择：\n\nMisserina 选择剩下的时尚值最高的即第 $4$ 种化妆品，ShenTianYi_ 选择剩下的时尚值最低的第 $3$ 种化妆品。\n\n第三次选择：\n\nMisserina 选择剩下的美丽值最高的第 $6$ 种化妆品，ShenTianYi_ 选择剩下的美丽值最低的第 $2$ 种化妆品。\n\n最终 Misserina 的时尚值为 $8+9+4=21$，美丽值为 $3+4+27=34$；ShenTianYi_ 的时尚值为 $1+7+3=11$，美丽值为 $1665+5+8888=10558$。\n\n对于 $100\\%$ 数据：\n- $1 \\le n \\le 5 \\times 10^5$；\n- $1 \\le F_i,B_i \\le 10^9$；\n- $Q_i \\in \\{1,2\\}$；\n- $\\forall\\: i \\ne j$，$F_i \\ne F_j$，$B_i \\ne B_j$。\n\n**本题采取捆绑测试。**\n\n- Subtask 0（9 pts）：$1 \\le n \\le 1000$，$1 \\le F_i,B_i \\le 2000$，$Q_i$ 均为 `1` 或均为 `2`；\n- Subtask 1（11 pts）：$1 \\le n \\le 1000$，$1 \\le F_i,B_i \\le 2000$；\n- Subtask 2（20 pts）：$1 \\le n \\le 1000$，$1 \\le F_i,B_i \\le 10^9$；\n- Subtask 3（26 pts）：$1 \\le n \\le 5 \\times 10^5$，$1 \\le F_i,B_i \\le 10^9$，$Q_i$ 均为 `1` 或均为 `2`；\n- Subtask 4（34 pts）：$1 \\le n \\le 5 \\times 10^5$，$1 \\le F_i,B_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P13240", "type": "P", "difficulty": 4, "samples": [["3\n2\n8\n29", "2\n6720\n195120252"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["组合数学", "逆元"], "title": "「2.48sOI R1」猜数", "background": "", "description": "Misserina 有一个小于 $n$ 的自然数 $x$，而 lizihan250 并不知道 $x$ 的值。\n\n现在，lizihan250 准备了 $m$ 张卡片，每张卡片上都写有一些互不相同的**小于 $n$ 的**数字。接着，Misserina 会告诉 lizihan250 $x$ 在哪些卡片上出现，而另外的卡片上 $x$ 未出现。lizihan250 需要根据 Misserina 提供的信息，猜出 $x$ 的值。\n\n如果每次都用一套卡片，这个游戏将变得很枯燥。因此，lizihan250 想知道，在保证根据 Misserina 提供的信息一定能猜出唯一确定的 $x$，且 $m$ 最小的情况下，有多少种不同的在卡片上写数字的方式？两种方式相同，当且仅当它们使用的卡片数相同，且交换一种方式中卡片的前后顺序可以得到另外一种方式。答案对 $10^9+7$ 取模。\n\n### 形式化题意\n\n一个集合 $A$ 是“好的集合”，当且仅当集合 $A$ 包含若干个由一些自然数组成的集合，且对于 $\\forall 0 \\le i < j < n (i,j \\in \\mathbb{N})$，$A$ 中至少存在一个集合 $B$，使得 $i \\in B$ 且 $j \\notin B$，或 $i \\notin B$ 且 $j \\in B$。\n\n令“好的集合”$A$ 的元素数量最小值为 $m$，试求出满足 $|A| = m$ 的“好的集合”$A$ 的数量，并对 $10^9+7$ 取模。", "inputFormat": "**一个测试点中含有多个互相独立的测试数据。**\n\n第一行，一个正整数 $t$，表示测试数据的数量。\n\n接下来 $t$ 行，每行一个正整数 $n$。", "outputFormat": "共 $t$ 行，每行一个整数，第 $i$ 行的数表示第 $i$ 组测试数据的答案数对 $10^9+7$ 取模的值。", "hint": "### 样例解释\n\n对于样例一，最少应当使用 $1$ 张卡片，有如下两种方案：\n\n1. 在这张卡片上只写下一个 $0$。此时，若 Misserina 回答“在这张卡片上存在 $x$”，则 $x=0$，否则 $x=1$。\n2. 在这张卡片上只写下一个 $1$，跟上一种情况相反。\n\n对于样例二，最少应当使用 $3$ 张卡片，一种方案为三张卡片分别包含 $\\{1,2,3,7\\},\\{1,2,5,6\\}$ 和 $\\{1,3,4,5\\}$。\n\n### 数据规模与约束\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，有 $1 \\le n \\le 10^6$。\n\n| Subtask 编号 | 分值 | $t$ | $n$ | 特殊性质 |\n| :----------: | :--: | :-: | :-: | :------: |\n| $0$ | $23$ | $\\le 10$ | $\\le 8$ | 不符合 |\n| $1$ | $12$ | $\\le 1000$ | $\\le 1000$ | 符合 |\n| $2$ | $15$ | $\\le 10^5$ | $\\le 10^6$ | 符合 |\n| $3$ | $28$ | $\\le 1000$ | $\\le 1000$ | 不符合 |\n| $4$ | $22$ | $\\le 10^5$ | $\\le 10^6$ | 不符合 |\n\n对于符合特殊性质的测试点，保证存在整数 $k$，使得 $2^k = n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「2.48sOI R1」猜数", "background": "", "description": "Misserina 有一个小于 $n$ 的自然数 $x$，而 lizihan250 并不知道 $x$ 的值。\n\n现在，lizihan250 准备了 $m$ 张卡片，每张卡片上都写有一些互不相同的**小于 $n$ 的**数字。接着，Misserina 会告诉 lizihan250 $x$ 在哪些卡片上出现，而另外的卡片上 $x$ 未出现。lizihan250 需要根据 Misserina 提供的信息，猜出 $x$ 的值。\n\n如果每次都用一套卡片，这个游戏将变得很枯燥。因此，lizihan250 想知道，在保证根据 Misserina 提供的信息一定能猜出唯一确定的 $x$，且 $m$ 最小的情况下，有多少种不同的在卡片上写数字的方式？两种方式相同，当且仅当它们使用的卡片数相同，且交换一种方式中卡片的前后顺序可以得到另外一种方式。答案对 $10^9+7$ 取模。\n\n### 形式化题意\n\n一个集合 $A$ 是“好的集合”，当且仅当集合 $A$ 包含若干个由一些自然数组成的集合，且对于 $\\forall 0 \\le i < j < n (i,j \\in \\mathbb{N})$，$A$ 中至少存在一个集合 $B$，使得 $i \\in B$ 且 $j \\notin B$，或 $i \\notin B$ 且 $j \\in B$。\n\n令“好的集合”$A$ 的元素数量最小值为 $m$，试求出满足 $|A| = m$ 的“好的集合”$A$ 的数量，并对 $10^9+7$ 取模。", "inputFormat": "**一个测试点中含有多个互相独立的测试数据。**\n\n第一行，一个正整数 $t$，表示测试数据的数量。\n\n接下来 $t$ 行，每行一个正整数 $n$。", "outputFormat": "共 $t$ 行，每行一个整数，第 $i$ 行的数表示第 $i$ 组测试数据的答案数对 $10^9+7$ 取模的值。", "hint": "### 样例解释\n\n对于样例一，最少应当使用 $1$ 张卡片，有如下两种方案：\n\n1. 在这张卡片上只写下一个 $0$。此时，若 Misserina 回答“在这张卡片上存在 $x$”，则 $x=0$，否则 $x=1$。\n2. 在这张卡片上只写下一个 $1$，跟上一种情况相反。\n\n对于样例二，最少应当使用 $3$ 张卡片，一种方案为三张卡片分别包含 $\\{1,2,3,7\\},\\{1,2,5,6\\}$ 和 $\\{1,3,4,5\\}$。\n\n### 数据规模与约束\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，有 $1 \\le n \\le 10^6$。\n\n| Subtask 编号 | 分值 | $t$ | $n$ | 特殊性质 |\n| :----------: | :--: | :-: | :-: | :------: |\n| $0$ | $23$ | $\\le 10$ | $\\le 8$ | 不符合 |\n| $1$ | $12$ | $\\le 1000$ | $\\le 1000$ | 符合 |\n| $2$ | $15$ | $\\le 10^5$ | $\\le 10^6$ | 符合 |\n| $3$ | $28$ | $\\le 1000$ | $\\le 1000$ | 不符合 |\n| $4$ | $22$ | $\\le 10^5$ | $\\le 10^6$ | 不符合 |\n\n对于符合特殊性质的测试点，保证存在整数 $k$，使得 $2^k = n$。", "locale": "zh-CN"}}}
{"pid": "P13241", "type": "P", "difficulty": 6, "samples": [["6\n1 2\n2 3\n2 4\n4 5\n1 6\n3 1\n2\n3 1\n6 0\n1\n1 0\n3\n2 1\n4 0\n5 1", "12\n32\n0"], ["6\n1 2\n2 3\n2 4\n4 5\n1 6\n3 2\n2\n3 1\n6 0\n1\n1 0\n3\n2 1\n4 0\n5 1", "44"], ["7\n1 2\n1 3\n3 4\n4 5\n5 6\n5 7\n4 1\n1\n4 0\n1\n4 1\n1\n6 0\n1\n6 1", "64\n48\n48\n36"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["虚树"], "title": "「2.48sOI R1」格律树", "background": "平平仄仄平平仄，仄仄平平仄仄平。", "description": "来自 CodeForces 的 Che960 想学习如何作近体诗。为此，他咨询了来自洛谷的 lizihan250。lizihan250 告诉他，诗句中的每个字都可以根据发音分为“平声”或“仄声”。除首句外，每一联的上句必须以“平声”收尾，下句必须以“仄声”收尾。每一句内应避免“孤平”。本题中，我们认为，若一句诗句中存在连续的三个字依次为“仄声”、“平声”、“仄声”，我们就认为，这句诗句出现了“孤平”。本题不考虑对仗、押韵等其他要求。\n\nChe960 为了练习平仄的运用，构造了一棵以 $1$ 号节点为根的格律树，树上的每个节点都代表“平声”或“仄声”中的一种。Che960 会进行多次练习，每次练习时，Che960 会在树上选出一些“关键点”，并指定了这些“关键点”代表的是“平声”还是“仄声”。Che960 的任务就是给定一种方案，给树上所有非关键节点指定其代表的是“平声”还是“仄声”，使得从根节点到任意一个“关键点”的简单路径上的所有节点依次排列成的诗句不出现“孤平”。\n\nlizihan250 看到了这个练习之后，想到了这样一个问题：对于 Che960 的每次练习，他最多能给出多少种不同的方案？两种方案不同，当且仅当存在至少一个节点，在两种方案中分别被指定为“平声”与“仄声”。答案对 $10^9+7$ 取模。\n\n### 形式化题意\n\n我们用 $0$ 指代上文的“平声”，用 $1$ 指代上文的“仄声”。\n\n给定一棵树，每个节点有 $01$ 点权。进行多次询问，每次询问选择若干个节点，指定它们的点权。求：若剩下的点的点权可以任意指定，则有多少种指定点权的方法，使得任意一个指定点到根节点的路径上，不存在连续的三个节点的点权依次为 $1$，$0$ 和 $1$。", "inputFormat": "第一行，一个正整数 $n$，表示树的节点总数。\n\n接下来 $n-1$ 行，每行两个正整数 $u,v$，表示树上编号为 $u,v$ 的两点之间连有一条边。\n\n接下来两个正整数 $t,q$，分别表示 Che960 的练习次数与输出参数。输出参数的作用会在“输出格式”部分给出。\n\n接下来 $t$ 组数据，第 $i$ 组数据中，第一行一个正整数 $k_i$，表示这轮联系中共有 $k_i$ 个“关键点”。接下来 $k_i$ 行，第 $j$ 行两个正整数 $p_{i,j},s_{i,j}$，表示编号为 $p_{i,j}$ 的节点被指定为 $s_{i,j}$。其中，若 $s_{i,j}=0$，则该节点被指定为“平声”，否则，该节点被指定为“仄声”。", "outputFormat": "共 $\\left\\lfloor\\dfrac{t}{q}\\right\\rfloor$ 行，每行一个整数，第 $i$ 行表示 Che960 第 $(i-1) \\times q + 1$ 次至第 $i \\times q$ 次练习的方案数对 $10^9+7$ 取模的异或和的值。", "hint": "### 样例解释\n\n对于样例一，样例中呈现的树的形态如下图所示：\n\n![样例一图](https://cdn.luogu.com.cn/upload/image_hosting/vqvdk2aw.png)\n\n第一次练习选取 $3$ 号节点、$6$ 号节点作为“关键点”，分别指定为“仄声”，“平声”。共 $12$ 种方案，如下表所示（标红的为“关键点”的声调）：\n\n| 方案编号 | $1$ 号节点 | $2$ 号节点 | $3$ 号节点 | $4$ 号节点 | $5$ 号节点 | $6$ 号节点 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | 平 | 平 | $\\color{red}\\text{仄}$ | 平 | 平 | $\\color{red}\\text{平}$ |\n| $2$ | 平 | 平 | $\\color{red}\\text{仄}$ | 平 | 仄 | $\\color{red}\\text{平}$ |\n| $3$ | 平 | 平 | $\\color{red}\\text{仄}$ | 仄 | 平 | $\\color{red}\\text{平}$ |\n| $4$ | 平 | 平 | $\\color{red}\\text{仄}$ | 仄 | 仄 | $\\color{red}\\text{平}$ |\n| $5$ | 平 | 仄 | $\\color{red}\\text{仄}$ | 平 | 平 | $\\color{red}\\text{平}$ |\n| $6$ | 平 | 仄 | $\\color{red}\\text{仄}$ | 平 | 仄 | $\\color{red}\\text{平}$ |\n| $7$ | 平 | 仄 | $\\color{red}\\text{仄}$ | 仄 | 平 | $\\color{red}\\text{平}$ |\n| $8$ | 平 | 仄 | $\\color{red}\\text{仄}$ | 仄 | 仄 | $\\color{red}\\text{平}$ |\n| $9$ | 仄 | 仄 | $\\color{red}\\text{仄}$ | 平 | 平 | $\\color{red}\\text{平}$ |\n| $10$ | 仄 | 仄 | $\\color{red}\\text{仄}$ | 平 | 仄 | $\\color{red}\\text{平}$ |\n| $11$ | 仄 | 仄 | $\\color{red}\\text{仄}$ | 仄 | 平 | $\\color{red}\\text{平}$ |\n| $12$ | 仄 | 仄 | $\\color{red}\\text{仄}$ | 仄 | 仄 | $\\color{red}\\text{平}$ |\n\n所有指定节点 $1$ 为“仄声”，指定节点 $2$ 为“平声”的方案均不符合题意，因为这会使从根节点到节点 $3$ 的简单路径上依次经过的节点 $1$、节点 $2$、节点 $3$ 构成“孤平”。\n\n需要注意的是，本题中，我们不关心不在根节点到“关键点”路径上的点的平仄使用情况是否符合题意。例如，方案 $6$ 的节点 $2$、节点 $4$、节点 $5$ 依次被指定为“仄声”、“平声”、“仄声”，会构成“孤平”，但由于不存在一条从根节点到一“关键点”的简单路径同时包含这三个节点，因此，这个方案也符合题意。\n\n第二次练习只选取节点 $1$ 为“关键点”，指定为“平声”。此时，剩余五个节点的平仄都可以任意指定。故此次练习共有 $2^5 = 32$ 种方案。\n\n第三次练习选取节点 $2$、节点 $4$、节点 $5$ 为“关键点”，分别指定为“仄声”、“平声”、“仄声”。此时，无论如何指定剩余节点的平仄，在根节点到节点 $5$ 的路径上总会依次经过节点 $2$、节点 $4$、节点 $5$ 构成“孤平”。故此次练习不存在任何方案。\n\n对于样例二，除输出参数外与样例一没有任何区别。此时应输出 $\\left\\lfloor\\dfrac{3}{2}\\right\\rfloor = 1$ 行，这一行应输出第一次与第二次练习的方案数的异或和，故输出 $12 \\otimes 32 = 44$。\n### 数据规模与约束\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，有 $1 \\le n \\le 5 \\times 10^5$，$1 \\le t,q \\le 5 \\times 10^5$，$\\left\\lfloor\\dfrac{t}{q}\\right\\rfloor \\le 5 \\times 10^4$。对于 $\\forall 1 \\le i \\le t$，有 $1 \\le k_i \\le n$，且 $\\sum\\limits_{i=1}^t k_i \\le 5 \\times 10^5$。对于 $\\forall 1\\le j \\le k_i$，有 $1 \\le p_{i,j} \\le n$，$s_{i,j} \\in \\{0,1\\}$，同一次练习中所有的 $p_{i,j}$ 互不相同。保证给出的是一棵树。\n\n| Subtask 编号 | 分值 | $t$ | $n$ | $\\sum k$ |特殊性质 |\n| :----------: | :--: | :-: | :-: | :-: |:------: |\n| $0$ | $8$ | $\\le 20$ | $\\le 20$ | $\\le 200$ | 不符合 |\n| $1$ | $16$ | $\\le 200$ | $\\le 10^5$ | $\\le 200$ | 符合 |\n| $2$ | $16$ | $\\le 10^5$ | $\\le 5 \\times 10^5$ | $\\le 10^5$ | 符合 |\n| $3$ | $8$ | $\\le 5 \\times 10^5$ | $\\le 5 \\times 10^5$ | $\\le 5 \\times 10^5$ | 符合 |\n| $4$ | $20$ | $\\le 200$ | $\\le 10^5$ | $\\le 10^5$ | 不符合 |\n| $5$ | $24$ | $\\le 10^5$ | $\\le 5 \\times 10^5$ | $\\le 10^5$ | 不符合 |\n| $6$ | $8$ | $\\le 5 \\times 10^5$ | $\\le 5 \\times 10^5$ | $\\le 5 \\times 10^5$ | 不符合 |\n\n对于符合特殊性质的测试点，保证 $\\forall 1 \\le i \\le t$，有 $k_i = 1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「2.48sOI R1」格律树", "background": "平平仄仄平平仄，仄仄平平仄仄平。", "description": "来自 CodeForces 的 Che960 想学习如何作近体诗。为此，他咨询了来自洛谷的 lizihan250。lizihan250 告诉他，诗句中的每个字都可以根据发音分为“平声”或“仄声”。除首句外，每一联的上句必须以“平声”收尾，下句必须以“仄声”收尾。每一句内应避免“孤平”。本题中，我们认为，若一句诗句中存在连续的三个字依次为“仄声”、“平声”、“仄声”，我们就认为，这句诗句出现了“孤平”。本题不考虑对仗、押韵等其他要求。\n\nChe960 为了练习平仄的运用，构造了一棵以 $1$ 号节点为根的格律树，树上的每个节点都代表“平声”或“仄声”中的一种。Che960 会进行多次练习，每次练习时，Che960 会在树上选出一些“关键点”，并指定了这些“关键点”代表的是“平声”还是“仄声”。Che960 的任务就是给定一种方案，给树上所有非关键节点指定其代表的是“平声”还是“仄声”，使得从根节点到任意一个“关键点”的简单路径上的所有节点依次排列成的诗句不出现“孤平”。\n\nlizihan250 看到了这个练习之后，想到了这样一个问题：对于 Che960 的每次练习，他最多能给出多少种不同的方案？两种方案不同，当且仅当存在至少一个节点，在两种方案中分别被指定为“平声”与“仄声”。答案对 $10^9+7$ 取模。\n\n### 形式化题意\n\n我们用 $0$ 指代上文的“平声”，用 $1$ 指代上文的“仄声”。\n\n给定一棵树，每个节点有 $01$ 点权。进行多次询问，每次询问选择若干个节点，指定它们的点权。求：若剩下的点的点权可以任意指定，则有多少种指定点权的方法，使得任意一个指定点到根节点的路径上，不存在连续的三个节点的点权依次为 $1$，$0$ 和 $1$。", "inputFormat": "第一行，一个正整数 $n$，表示树的节点总数。\n\n接下来 $n-1$ 行，每行两个正整数 $u,v$，表示树上编号为 $u,v$ 的两点之间连有一条边。\n\n接下来两个正整数 $t,q$，分别表示 Che960 的练习次数与输出参数。输出参数的作用会在“输出格式”部分给出。\n\n接下来 $t$ 组数据，第 $i$ 组数据中，第一行一个正整数 $k_i$，表示这轮联系中共有 $k_i$ 个“关键点”。接下来 $k_i$ 行，第 $j$ 行两个正整数 $p_{i,j},s_{i,j}$，表示编号为 $p_{i,j}$ 的节点被指定为 $s_{i,j}$。其中，若 $s_{i,j}=0$，则该节点被指定为“平声”，否则，该节点被指定为“仄声”。", "outputFormat": "共 $\\left\\lfloor\\dfrac{t}{q}\\right\\rfloor$ 行，每行一个整数，第 $i$ 行表示 Che960 第 $(i-1) \\times q + 1$ 次至第 $i \\times q$ 次练习的方案数对 $10^9+7$ 取模的异或和的值。", "hint": "### 样例解释\n\n对于样例一，样例中呈现的树的形态如下图所示：\n\n![样例一图](https://cdn.luogu.com.cn/upload/image_hosting/vqvdk2aw.png)\n\n第一次练习选取 $3$ 号节点、$6$ 号节点作为“关键点”，分别指定为“仄声”，“平声”。共 $12$ 种方案，如下表所示（标红的为“关键点”的声调）：\n\n| 方案编号 | $1$ 号节点 | $2$ 号节点 | $3$ 号节点 | $4$ 号节点 | $5$ 号节点 | $6$ 号节点 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | 平 | 平 | $\\color{red}\\text{仄}$ | 平 | 平 | $\\color{red}\\text{平}$ |\n| $2$ | 平 | 平 | $\\color{red}\\text{仄}$ | 平 | 仄 | $\\color{red}\\text{平}$ |\n| $3$ | 平 | 平 | $\\color{red}\\text{仄}$ | 仄 | 平 | $\\color{red}\\text{平}$ |\n| $4$ | 平 | 平 | $\\color{red}\\text{仄}$ | 仄 | 仄 | $\\color{red}\\text{平}$ |\n| $5$ | 平 | 仄 | $\\color{red}\\text{仄}$ | 平 | 平 | $\\color{red}\\text{平}$ |\n| $6$ | 平 | 仄 | $\\color{red}\\text{仄}$ | 平 | 仄 | $\\color{red}\\text{平}$ |\n| $7$ | 平 | 仄 | $\\color{red}\\text{仄}$ | 仄 | 平 | $\\color{red}\\text{平}$ |\n| $8$ | 平 | 仄 | $\\color{red}\\text{仄}$ | 仄 | 仄 | $\\color{red}\\text{平}$ |\n| $9$ | 仄 | 仄 | $\\color{red}\\text{仄}$ | 平 | 平 | $\\color{red}\\text{平}$ |\n| $10$ | 仄 | 仄 | $\\color{red}\\text{仄}$ | 平 | 仄 | $\\color{red}\\text{平}$ |\n| $11$ | 仄 | 仄 | $\\color{red}\\text{仄}$ | 仄 | 平 | $\\color{red}\\text{平}$ |\n| $12$ | 仄 | 仄 | $\\color{red}\\text{仄}$ | 仄 | 仄 | $\\color{red}\\text{平}$ |\n\n所有指定节点 $1$ 为“仄声”，指定节点 $2$ 为“平声”的方案均不符合题意，因为这会使从根节点到节点 $3$ 的简单路径上依次经过的节点 $1$、节点 $2$、节点 $3$ 构成“孤平”。\n\n需要注意的是，本题中，我们不关心不在根节点到“关键点”路径上的点的平仄使用情况是否符合题意。例如，方案 $6$ 的节点 $2$、节点 $4$、节点 $5$ 依次被指定为“仄声”、“平声”、“仄声”，会构成“孤平”，但由于不存在一条从根节点到一“关键点”的简单路径同时包含这三个节点，因此，这个方案也符合题意。\n\n第二次练习只选取节点 $1$ 为“关键点”，指定为“平声”。此时，剩余五个节点的平仄都可以任意指定。故此次练习共有 $2^5 = 32$ 种方案。\n\n第三次练习选取节点 $2$、节点 $4$、节点 $5$ 为“关键点”，分别指定为“仄声”、“平声”、“仄声”。此时，无论如何指定剩余节点的平仄，在根节点到节点 $5$ 的路径上总会依次经过节点 $2$、节点 $4$、节点 $5$ 构成“孤平”。故此次练习不存在任何方案。\n\n对于样例二，除输出参数外与样例一没有任何区别。此时应输出 $\\left\\lfloor\\dfrac{3}{2}\\right\\rfloor = 1$ 行，这一行应输出第一次与第二次练习的方案数的异或和，故输出 $12 \\otimes 32 = 44$。\n### 数据规模与约束\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，有 $1 \\le n \\le 5 \\times 10^5$，$1 \\le t,q \\le 5 \\times 10^5$，$\\left\\lfloor\\dfrac{t}{q}\\right\\rfloor \\le 5 \\times 10^4$。对于 $\\forall 1 \\le i \\le t$，有 $1 \\le k_i \\le n$，且 $\\sum\\limits_{i=1}^t k_i \\le 5 \\times 10^5$。对于 $\\forall 1\\le j \\le k_i$，有 $1 \\le p_{i,j} \\le n$，$s_{i,j} \\in \\{0,1\\}$，同一次练习中所有的 $p_{i,j}$ 互不相同。保证给出的是一棵树。\n\n| Subtask 编号 | 分值 | $t$ | $n$ | $\\sum k$ |特殊性质 |\n| :----------: | :--: | :-: | :-: | :-: |:------: |\n| $0$ | $8$ | $\\le 20$ | $\\le 20$ | $\\le 200$ | 不符合 |\n| $1$ | $16$ | $\\le 200$ | $\\le 10^5$ | $\\le 200$ | 符合 |\n| $2$ | $16$ | $\\le 10^5$ | $\\le 5 \\times 10^5$ | $\\le 10^5$ | 符合 |\n| $3$ | $8$ | $\\le 5 \\times 10^5$ | $\\le 5 \\times 10^5$ | $\\le 5 \\times 10^5$ | 符合 |\n| $4$ | $20$ | $\\le 200$ | $\\le 10^5$ | $\\le 10^5$ | 不符合 |\n| $5$ | $24$ | $\\le 10^5$ | $\\le 5 \\times 10^5$ | $\\le 10^5$ | 不符合 |\n| $6$ | $8$ | $\\le 5 \\times 10^5$ | $\\le 5 \\times 10^5$ | $\\le 5 \\times 10^5$ | 不符合 |\n\n对于符合特殊性质的测试点，保证 $\\forall 1 \\le i \\le t$，有 $k_i = 1$。", "locale": "zh-CN"}}}
{"pid": "P13242", "type": "P", "difficulty": 7, "samples": [["0 6 6 0 -1 -1\naaaaabababaabab\nbaaabaabababaabba\naabababbaabaabab\nabaababababaabaaaba\nbaabababababaaababa\nbababaababababaabab\nbaababababaaaaababbbaaababaabababaabb\n114 51 41 91 98 10\n1 6 16 18\n2 5 11 12\n3 4 1 2\n1 5 4 6\n3 5 3 4\n1 5 7 12", "955\n614\n492\n895\n820\n247"], ["0 6 6 1 -1 -1\naaaaabababaabab\nbaaabaabababaabba\naabababbaabaabab\nabaababababaabaaaba\nbaabababababaaababa\nbababaababababaabab\nbaababababaaaaababbbaaababaabababaabb\n114 51 41 91 98 10\n1 6 16 18\n2 5 11 12\n3 4 1 2\n1 5 4 6\n3 5 3 4\n1 5 7 12", "955\n900\n287\n1344\n820\n41\n"], ["0 6 6 1 1 -1\naaaaabababaabab\nbaaabaabababaabba\naabababbaabaabab\nabaababababaabaaaba\nbaabababababaaababa\nbababaababababaabab\nbaababababaaaaababbbaaababaabababaabb\n114 51 41 91 98 10\n1 6 16 18\n2 5 11 12\n3 4 1 2\n1 5 4 6\n3 5 3 4\n1 5 7 12", "955\n1662\n1358\n824\n1184\n165\n"], ["0 6 6 1 -1 6\naaaaabababaabab\nbaaabaabababaabba\naabababbaabaabab\nabaababababaabaaaba\nbaabababababaaababa\nbababaababababaabab\nbaababababaaaaababbbaaababaabababaabb\n114 51 41 91 98 10\n1 6 16 18\n2 5 11 12\n3 4 1 2\n1 5 4 6\n3 5 3 4\n1 5 7 12", "955\n900\n430\n348\n41\n0\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864]}, "tags": ["可持久化线段树", "分块", "后缀数组 SA"], "title": "「2.48sOI R1」你的名字", "background": "\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/km729lc0.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)\n\n", "description": "由于你不会交换身体，所以需要解决一道题目。\n\n记 $\\operatorname{occ}(u,v)$ 为**字符串 $\\boldsymbol v$** 在**字符串 $\\boldsymbol u$ 中**的出现次数。并记 $t[l,r]$ 表示字符串 $t$ 由第 $l$ 到第 $r$ 个字符组成的子串。\n\n给定字符串序列 $(s_1,\\dots,s_n)$ 和正整数序列 $(a_1,\\dots,a_n)$ 以及字符串 $t$，有 $q$ 次询问，每次询问有四个参数 $l_1,r_1,l_2,r_2$，求：\n\n$$\\sum\\limits_{i=l_1}^{r_1}\\left(\\operatorname{occ}(s_i,t[l_2,r_2])\\times\\min\\limits_{j=l_1}^{i}a_j\\right)$$\n\n对于 $o=1$ 的子任务，你需要支持在线询问。", "inputFormat": "共 $n+q+3$ 行。\n\n- 第一行六个正整数 $\\text{sid},n,q,o,L,R$。其中 $\\text{sid}$ 表示测试点所在 Subtask 编号。特别地，对于样例，$\\text{sid}=0$。其余量意义如题所示。\n\n- 第 $2\\sim n+1$ 行 $n$ 个字符串 $(s_1,\\dots,s_n)$。\n- 第 $n+2$ 行一个字符串 $t$。\n- 第 $n+3$ 行 $n$ 个正整数 $(a_1,\\dots,a_n)$。\n- 第 $n+4\\sim n+q+3$ 行每行四个正整数 $L_1,R_1,L_2,R_2$，描述一个询问。\n\n对于第 $i$ 个询问，记第 $i-1$ 个询问的答案为 $\\text{lst}$（若 $i=1$ 则 $\\text{lst}=0$），则 $l_1,l_2,r_1,r_2$ 为：\n\n- $l_1=(L_1+o\\times\\text{lst}-1)\\bmod n+1$。\n- $r_1=(R_1+o\\times\\text{lst}-1)\\bmod n+1$。\n- $l_2=(L_2+o\\times\\text{lst}-1)\\bmod |t|+1$。\n- $r_2=(R_2+o\\times\\text{lst}-1)\\bmod |t|+1$。\n\n若 $l_1>r_1$，则交换 $l_1,r_1$。对于 $l_2,r_2$ 同理。\n\n当 $L$ 不为 $-1$ 时，你需要将所有 $l_1$ 改为 $L$；当 $R$ 不为 $-1$ 时，你需要将所有 $r_1$ 改为 $R$（若初始的 $l_1>r_1$，本操作在交换 $l_1,r_1$ 之后进行）。", "outputFormat": "共 $q$ 行，第 $i$ 行表示第 $i$ 场梦境的⌈结⌋，即形式化题意中第 $i$ 个询问的答案。", "hint": "**【样例解释 #1】**\n\n以最后一组询问为例，$t[7,12] = \\texttt{ababaa}$。给出要用的 $\\text{occ}$ 数据：\n\n- $\\text{occ}(s_1,t[7,12])=\\text{occ}(s_2,t[7,12])=\\text{occ}(s_4,t[7,12])=\\text{occ}(s_5,t[7,12])=1$。\n\n- $\\text{occ}(s_3,t[7,12])=0$。\n\n答案为 $114\\times 1+51\\times 1+41\\times 0 + 41\\times 1 + 41\\times 1 = 247$。\n\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n记 $m=\\sum\\limits_{i=1}^n\\lvert s_i\\rvert$。\n\n| $\\text{sid}=$ | $n,m,\\lvert t\\rvert\\le$ | $q\\le$ | $a_i\\le$ | $o=$ |特殊性质| 分值 | 子任务依赖 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $100$ | $100$ | $10^9$ | $0$ |  | $5$|  |\n| $2$ | $2\\times 10^5$ | $2\\times 10^5$ | $10^9$ | $1$ | $\\text{A}$ |$10$ |  |\n| $3$ | $2\\times 10^5$ | $2\\times 10^5$ | $1$ | $1$ |  |$15$ |  |\n| $4$ | $10^4$ | $10^4$ | $10^9$ | $0$ |  |$15$| $1$ |\n| $5$ | $2\\times 10^5$ | $2\\times 10^5$ | $10^9$ | $0$ |  |$20$| $4$ |\n| $6$ | $2\\times 10^5$ | $2\\times 10^5$ | $10^9$ | $1$ | $\\text{B}$ |$5$|\n| $7$ | $2\\times 10^5$ | $2\\times 10^5$ | $10^9$ | $1$ | $\\text{C}$ |$20$|\n| $8$ | $2\\times 10^5$ | $2\\times 10^5$ | $10^9$ | $1$  |  |$10$ | $2,3,5,6,7$ |\n\n特殊性质 $\\text{A}$：$s_i$ 与 $t$ 均为 `a`。\n\n特殊性质 $\\text{B}$：$L=1$。\n\n特殊性质 $\\text{C}$：$R=n$。\n\n对于 $100\\%$ 的数据，$1\\le n,m,\\lvert t\\rvert\\le 2\\times 10^5$，$1\\le q\\le 2\\times 10^5$，$1\\le a_i\\le 10^9$，$o\\in\\{0,1\\}$，$0\\le \\text{sid}\\le 8$，$1\\le L,R\\le n$ 或 $L,R=-1$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「2.48sOI R1」你的名字", "background": "\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/km729lc0.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)\n\n", "description": "由于你不会交换身体，所以需要解决一道题目。\n\n记 $\\operatorname{occ}(u,v)$ 为**字符串 $\\boldsymbol v$** 在**字符串 $\\boldsymbol u$ 中**的出现次数。并记 $t[l,r]$ 表示字符串 $t$ 由第 $l$ 到第 $r$ 个字符组成的子串。\n\n给定字符串序列 $(s_1,\\dots,s_n)$ 和正整数序列 $(a_1,\\dots,a_n)$ 以及字符串 $t$，有 $q$ 次询问，每次询问有四个参数 $l_1,r_1,l_2,r_2$，求：\n\n$$\\sum\\limits_{i=l_1}^{r_1}\\left(\\operatorname{occ}(s_i,t[l_2,r_2])\\times\\min\\limits_{j=l_1}^{i}a_j\\right)$$\n\n对于 $o=1$ 的子任务，你需要支持在线询问。", "inputFormat": "共 $n+q+3$ 行。\n\n- 第一行六个正整数 $\\text{sid},n,q,o,L,R$。其中 $\\text{sid}$ 表示测试点所在 Subtask 编号。特别地，对于样例，$\\text{sid}=0$。其余量意义如题所示。\n\n- 第 $2\\sim n+1$ 行 $n$ 个字符串 $(s_1,\\dots,s_n)$。\n- 第 $n+2$ 行一个字符串 $t$。\n- 第 $n+3$ 行 $n$ 个正整数 $(a_1,\\dots,a_n)$。\n- 第 $n+4\\sim n+q+3$ 行每行四个正整数 $L_1,R_1,L_2,R_2$，描述一个询问。\n\n对于第 $i$ 个询问，记第 $i-1$ 个询问的答案为 $\\text{lst}$（若 $i=1$ 则 $\\text{lst}=0$），则 $l_1,l_2,r_1,r_2$ 为：\n\n- $l_1=(L_1+o\\times\\text{lst}-1)\\bmod n+1$。\n- $r_1=(R_1+o\\times\\text{lst}-1)\\bmod n+1$。\n- $l_2=(L_2+o\\times\\text{lst}-1)\\bmod |t|+1$。\n- $r_2=(R_2+o\\times\\text{lst}-1)\\bmod |t|+1$。\n\n若 $l_1>r_1$，则交换 $l_1,r_1$。对于 $l_2,r_2$ 同理。\n\n当 $L$ 不为 $-1$ 时，你需要将所有 $l_1$ 改为 $L$；当 $R$ 不为 $-1$ 时，你需要将所有 $r_1$ 改为 $R$（若初始的 $l_1>r_1$，本操作在交换 $l_1,r_1$ 之后进行）。", "outputFormat": "共 $q$ 行，第 $i$ 行表示第 $i$ 场梦境的⌈结⌋，即形式化题意中第 $i$ 个询问的答案。", "hint": "**【样例解释 #1】**\n\n以最后一组询问为例，$t[7,12] = \\texttt{ababaa}$。给出要用的 $\\text{occ}$ 数据：\n\n- $\\text{occ}(s_1,t[7,12])=\\text{occ}(s_2,t[7,12])=\\text{occ}(s_4,t[7,12])=\\text{occ}(s_5,t[7,12])=1$。\n\n- $\\text{occ}(s_3,t[7,12])=0$。\n\n答案为 $114\\times 1+51\\times 1+41\\times 0 + 41\\times 1 + 41\\times 1 = 247$。\n\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n记 $m=\\sum\\limits_{i=1}^n\\lvert s_i\\rvert$。\n\n| $\\text{sid}=$ | $n,m,\\lvert t\\rvert\\le$ | $q\\le$ | $a_i\\le$ | $o=$ |特殊性质| 分值 | 子任务依赖 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $100$ | $100$ | $10^9$ | $0$ |  | $5$|  |\n| $2$ | $2\\times 10^5$ | $2\\times 10^5$ | $10^9$ | $1$ | $\\text{A}$ |$10$ |  |\n| $3$ | $2\\times 10^5$ | $2\\times 10^5$ | $1$ | $1$ |  |$15$ |  |\n| $4$ | $10^4$ | $10^4$ | $10^9$ | $0$ |  |$15$| $1$ |\n| $5$ | $2\\times 10^5$ | $2\\times 10^5$ | $10^9$ | $0$ |  |$20$| $4$ |\n| $6$ | $2\\times 10^5$ | $2\\times 10^5$ | $10^9$ | $1$ | $\\text{B}$ |$5$|\n| $7$ | $2\\times 10^5$ | $2\\times 10^5$ | $10^9$ | $1$ | $\\text{C}$ |$20$|\n| $8$ | $2\\times 10^5$ | $2\\times 10^5$ | $10^9$ | $1$  |  |$10$ | $2,3,5,6,7$ |\n\n特殊性质 $\\text{A}$：$s_i$ 与 $t$ 均为 `a`。\n\n特殊性质 $\\text{B}$：$L=1$。\n\n特殊性质 $\\text{C}$：$R=n$。\n\n对于 $100\\%$ 的数据，$1\\le n,m,\\lvert t\\rvert\\le 2\\times 10^5$，$1\\le q\\le 2\\times 10^5$，$1\\le a_i\\le 10^9$，$o\\in\\{0,1\\}$，$0\\le \\text{sid}\\le 8$，$1\\le L,R\\le n$ 或 $L,R=-1$。\n", "locale": "zh-CN"}}}
{"pid": "P13243", "type": "P", "difficulty": 2, "samples": [["3\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n3\n1 2 5 4\n3 11 6 15\n9 10 7 12\n13 14 8 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n3\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16", "Case #1: 7\nCase #2: Bad magician!\nCase #3: Volunteer cheated!"]], "limits": {"time": [3000], "memory": [1048576]}, "tags": ["模拟", "2014", "Google Code Jam"], "title": "[GCJ 2014 Qualification] Magic Trick", "background": "**Note:** To advance to the next rounds, you will need to score 25 points. Solving just this problem will not give you enough points.", "description": "Recently you went to a magic show. You were very impressed by one of the tricks, so you decided to try to figure out the secret behind it!\n\nThe magician starts by arranging $16$ cards in a square grid: $4$ rows of cards, with $4$ cards in each row. Each card has a different number from $1$ to $16$ written on the side that is showing. Next, the magician asks a volunteer to choose a card, and to tell him which row that card is in.\n\nFinally, the magician arranges the $16$ cards in a square grid again, possibly in a different order. Once again, he asks the volunteer which row her card is in. With only the answers to these two questions, the magician then correctly determines which card the volunteer chose. Amazing, right?\n\nYou decide to write a program to help you understand the magician's technique. The program will be given the two arrangements of the cards, and the volunteer's answers to the two questions: the row number of the selected card in the first arrangement, and the row number of the selected card in the second arrangement. The rows are numbered $1$ to $4$ from top to bottom.\n\nYour program should determine which card the volunteer chose; or if there is more than one card the volunteer might have chosen (the magician did a bad job); or if there's no card consistent with the volunteer's answers (the volunteer cheated).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing an integer: the answer to the first question. The next $4$ lines represent the first arrangement of the cards: each contains $4$ integers, separated by a single space. The next line contains the answer to the second question, and the following four lines contain the second arrangement in the same format.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$).\n\nIf there is a single card the volunteer could have chosen, $y$ should be the number on the card. If there are multiple cards the volunteer could have chosen, $y$ should be \"Bad magician!\", without the quotes. If there are no cards consistent with the volunteer's answers, $y$ should be \"Volunteer cheated!\", without the quotes. The text needs to be exactly right, so consider copying/pasting it from here.", "hint": "**Limits(6 Pts)**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq \\text{both answers} \\leq 4$.\n- Each number from $1$ to $16$ will appear exactly once in each arrangement.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 Qualification] Magic Trick", "background": "**Note:** To advance to the next rounds, you will need to score 25 points. Solving just this problem will not give you enough points.", "description": "Recently you went to a magic show. You were very impressed by one of the tricks, so you decided to try to figure out the secret behind it!\n\nThe magician starts by arranging $16$ cards in a square grid: $4$ rows of cards, with $4$ cards in each row. Each card has a different number from $1$ to $16$ written on the side that is showing. Next, the magician asks a volunteer to choose a card, and to tell him which row that card is in.\n\nFinally, the magician arranges the $16$ cards in a square grid again, possibly in a different order. Once again, he asks the volunteer which row her card is in. With only the answers to these two questions, the magician then correctly determines which card the volunteer chose. Amazing, right?\n\nYou decide to write a program to help you understand the magician's technique. The program will be given the two arrangements of the cards, and the volunteer's answers to the two questions: the row number of the selected card in the first arrangement, and the row number of the selected card in the second arrangement. The rows are numbered $1$ to $4$ from top to bottom.\n\nYour program should determine which card the volunteer chose; or if there is more than one card the volunteer might have chosen (the magician did a bad job); or if there's no card consistent with the volunteer's answers (the volunteer cheated).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing an integer: the answer to the first question. The next $4$ lines represent the first arrangement of the cards: each contains $4$ integers, separated by a single space. The next line contains the answer to the second question, and the following four lines contain the second arrangement in the same format.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$).\n\nIf there is a single card the volunteer could have chosen, $y$ should be the number on the card. If there are multiple cards the volunteer could have chosen, $y$ should be \"Bad magician!\", without the quotes. If there are no cards consistent with the volunteer's answers, $y$ should be \"Volunteer cheated!\", without the quotes. The text needs to be exactly right, so consider copying/pasting it from here.", "hint": "**Limits(6 Pts)**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq \\text{both answers} \\leq 4$.\n- Each number from $1$ to $16$ will appear exactly once in each arrangement.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 Qualification] Magic Trick", "background": "**注意：** 要晋级下一轮，你需要获得 25 分。仅解决本题无法获得足够的分数。\n", "description": "最近你去看了一场魔术表演。你对其中的一个戏法印象深刻，因此你决定尝试揭开其中的秘密！\n\n魔术师首先将 $16$ 张牌摆成一个正方形：共 $4$ 行，每行 $4$ 张牌。每张牌正面都写有 $1$ 到 $16$ 中的一个不同的数字。接着，魔术师请一位观众选择一张牌，并告诉他这张牌所在的行号。\n\n然后，魔术师可能以不同的顺序再次将 $16$ 张牌摆成一个正方形。魔术师再次询问观众她的牌现在在第几行。仅凭观众对这两个问题的回答，魔术师就能准确地说出观众选的是哪张牌。不可思议，对吧？\n\n你决定写一个程序来帮助你理解魔术师的技巧。程序将获得两次牌面布局，以及观众对于两个问题的回答：第一次布局所选牌的行号，以及第二次布局所选牌的行号。行号从上到下编号为 $1$ 到 $4$。\n\n你的程序应当判断观众选的是哪张牌；或者如果有多种可能的牌（即魔术师失误），输出“Bad magician!”；或者如果没有任何牌符合观众的答案（即观众作弊），输出“Volunteer cheated!”。\n", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例的第一行为一个整数，表示第一次提问的答案。接下来的 $4$ 行为第一次的牌面布局，每行 $4$ 个整数，空格分隔。再下一行为第二次提问的答案，接着的 $4$ 行为第二次的牌面布局，格式同上。\n", "outputFormat": "对于每组测试用例，输出一行 \"Case #$x$: $y$\"，其中 $x$ 为测试用例编号（从 $1$ 开始）。\n\n- 如果只有一张牌符合观众的选择，$y$ 应为该牌上的数字。\n- 如果有多张牌符合观众的选择，$y$ 应为 \"Bad magician!\"（不含引号）。\n- 如果没有任何牌符合观众的答案，$y$ 应为 \"Volunteer cheated!\"（不含引号）。\n- 输出内容必须完全一致，建议直接复制粘贴上述文本。", "hint": "**数据范围（6 分）**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq$ 两次回答 $\\leq 4$。\n- $1$ 到 $16$ 的每个数字在每次布局中恰好出现一次。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13244", "type": "P", "difficulty": 3, "samples": [["4\n30.0 1.0 2.0\n30.0 2.0 100.0\n30.50000 3.14159 1999.19990\n500.0 4.0 2000.0", "Case #1: 1.0000000\nCase #2: 39.1666667\nCase #3: 63.9680013\nCase #4: 526.1904762"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "贪心", "2014", "Special Judge", "Google Code Jam"], "title": "[GCJ 2014 Qualification] Cookie Clicker Alpha", "background": "Cookie Clicker is a Javascript game by Orteil, where players click on a picture of a giant cookie. Clicking on the giant cookie gives them cookies. They can spend those cookies to buy buildings. Those buildings help them get even more cookies. Like this problem, the game is very cookie-focused. This problem has a similar idea, but it does not assume you have played Cookie Clicker. Please don't go play it now: it might be a long time before you come back.\n\nCookie Clicker was created by Orteil. Orteil does not endorse and has no involvement with Google Code Jam.", "description": "In this problem, you start with $0$ cookies. You gain cookies at a rate of $2$ cookies per second, by clicking on a giant cookie. Any time you have at least $C$ cookies, you can buy a cookie farm. Every time you buy a cookie farm, it costs you $C$ cookies and gives you an extra $F$ cookies per second.\n\nOnce you have $X$ cookies that you haven't spent on farms, you win! Figure out how long it will take you to win if you use the best possible strategy.\n\nSuppose $C = 500.0$, $F = 4.0$ and $X = 2000.0$. Here's how the best possible strategy plays out:\n\n1. You start with $0$ cookies, but producing $2$ cookies per second.\n2. After $250$ seconds, you will have $C = 500$ cookies and can buy a farm that produces $F = 4$ cookies per second.\n3. After buying the farm, you have $0$ cookies, and your total cookie production is $6$ cookies per second.\n4. The next farm will cost $500$ cookies, which you can buy after about $83.3333333$ seconds.\n5. After buying your second farm, you have $0$ cookies, and your total cookie production is $10$ cookies per second.\n6. Another farm will cost $500$ cookies, which you can buy after $50$ seconds.\n7. After buying your third farm, you have $0$ cookies, and your total cookie production is $14$ cookies per second.\n8. Another farm would cost $500$ cookies, but it actually makes sense not to buy it: instead you can just wait until you have $X = 2000$ cookies, which takes about $142.8571429$ seconds.\n\nTotal time: $250 + 83.3333333 + 50 + 142.8571429 = 526.1904762$ seconds.\n\nNotice that you get cookies continuously: so $0.1$ seconds after the game starts you'll have $0.2$ cookies, and $\\pi$ seconds after the game starts you'll have $2\\pi$ cookies.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each line contains three space-separated real-valued numbers: $C$, $F$ and $X$, whose meanings are described earlier in the problem statement.\n\n$C$, $F$ and $X$ will each consist of at least $1$ digit followed by $1$ decimal point followed by from $1$ to $5$ digits. There will be no leading zeroes.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is the minimum number of seconds it takes before you can have $X$ delicious cookies.\n\nWe recommend outputting $y$ to $7$ decimal places, but it is not required. $y$ will be considered correct if it is close enough to the correct number: within an absolute or relative error of $10^{-6}$.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Small dataset(8 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq C \\leq 500$.\n- $1 \\leq F \\leq 4$.\n- $1 \\leq X \\leq 2000$.\n\n**Large dataset(11 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq C \\leq 10000$.\n- $1 \\leq F \\leq 100$.\n- $1 \\leq X \\leq 100000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 Qualification] Cookie Clicker Alpha", "background": "Cookie Clicker is a Javascript game by Orteil, where players click on a picture of a giant cookie. Clicking on the giant cookie gives them cookies. They can spend those cookies to buy buildings. Those buildings help them get even more cookies. Like this problem, the game is very cookie-focused. This problem has a similar idea, but it does not assume you have played Cookie Clicker. Please don't go play it now: it might be a long time before you come back.\n\nCookie Clicker was created by Orteil. Orteil does not endorse and has no involvement with Google Code Jam.", "description": "In this problem, you start with $0$ cookies. You gain cookies at a rate of $2$ cookies per second, by clicking on a giant cookie. Any time you have at least $C$ cookies, you can buy a cookie farm. Every time you buy a cookie farm, it costs you $C$ cookies and gives you an extra $F$ cookies per second.\n\nOnce you have $X$ cookies that you haven't spent on farms, you win! Figure out how long it will take you to win if you use the best possible strategy.\n\nSuppose $C = 500.0$, $F = 4.0$ and $X = 2000.0$. Here's how the best possible strategy plays out:\n\n1. You start with $0$ cookies, but producing $2$ cookies per second.\n2. After $250$ seconds, you will have $C = 500$ cookies and can buy a farm that produces $F = 4$ cookies per second.\n3. After buying the farm, you have $0$ cookies, and your total cookie production is $6$ cookies per second.\n4. The next farm will cost $500$ cookies, which you can buy after about $83.3333333$ seconds.\n5. After buying your second farm, you have $0$ cookies, and your total cookie production is $10$ cookies per second.\n6. Another farm will cost $500$ cookies, which you can buy after $50$ seconds.\n7. After buying your third farm, you have $0$ cookies, and your total cookie production is $14$ cookies per second.\n8. Another farm would cost $500$ cookies, but it actually makes sense not to buy it: instead you can just wait until you have $X = 2000$ cookies, which takes about $142.8571429$ seconds.\n\nTotal time: $250 + 83.3333333 + 50 + 142.8571429 = 526.1904762$ seconds.\n\nNotice that you get cookies continuously: so $0.1$ seconds after the game starts you'll have $0.2$ cookies, and $\\pi$ seconds after the game starts you'll have $2\\pi$ cookies.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each line contains three space-separated real-valued numbers: $C$, $F$ and $X$, whose meanings are described earlier in the problem statement.\n\n$C$, $F$ and $X$ will each consist of at least $1$ digit followed by $1$ decimal point followed by from $1$ to $5$ digits. There will be no leading zeroes.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is the minimum number of seconds it takes before you can have $X$ delicious cookies.\n\nWe recommend outputting $y$ to $7$ decimal places, but it is not required. $y$ will be considered correct if it is close enough to the correct number: within an absolute or relative error of $10^{-6}$.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Small dataset(8 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq C \\leq 500$.\n- $1 \\leq F \\leq 4$.\n- $1 \\leq X \\leq 2000$.\n\n**Large dataset(11 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq C \\leq 10000$.\n- $1 \\leq F \\leq 100$.\n- $1 \\leq X \\leq 100000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 Qualification] Cookie Clicker Alpha", "background": "Cookie Clicker 是 Orteil 开发的一款 Javascript 游戏，玩家通过点击一个巨大的曲奇图案来获得曲奇。点击巨型曲奇会获得曲奇，可以用这些曲奇购买建筑物，而这些建筑物又会帮助玩家获得更多曲奇。和本题一样，这款游戏非常专注于曲奇。不过本题只是借鉴了类似的思路，不要求你玩过 Cookie Clicker。请现在不要去玩这款游戏：否则你可能很久都回不来。\n\nCookie Clicker 由 Orteil 创作。Orteil 并未参与 Google Code Jam，也未对其进行背书。", "description": "在本题中，你一开始拥有 $0$ 个曲奇。你以每秒 $2$ 个曲奇的速度获得曲奇，方式是点击巨型曲奇。只要你拥有至少 $C$ 个曲奇，就可以购买一个曲奇农场。每次购买曲奇农场时，你需要花费 $C$ 个曲奇，并且你的曲奇产量每秒提升 $F$ 个曲奇。\n\n一旦你拥有 $X$ 个未用于购买农场的曲奇，你就算获胜！请计算在最优策略下，你需要多长时间才能获胜。\n\n假设 $C = 500.0$，$F = 4.0$，$X = 2000.0$。最优策略如下：\n\n1. 你从 $0$ 个曲奇开始，产量为每秒 $2$ 个曲奇。\n2. $250$ 秒后，你将拥有 $C = 500$ 个曲奇，可以购买一个产量为 $F = 4$ 曲奇/秒的农场。\n3. 购买农场后，你的曲奇数变为 $0$，总产量变为每秒 $6$ 个曲奇。\n4. 下一个农场需要 $500$ 个曲奇，你大约在 $83.3333333$ 秒后可以购买。\n5. 购买第二个农场后，你的曲奇数归零，总产量变为每秒 $10$ 个曲奇。\n6. 再买一个农场需要 $500$ 个曲奇，你在 $50$ 秒后可以购买。\n7. 购买第三个农场后，你的曲奇数归零，总产量变为每秒 $14$ 个曲奇。\n8. 再买一个农场仍需 $500$ 曲奇，但其实此时不买更优：直接等待直到拥有 $X = 2000$ 个曲奇，这需要大约 $142.8571429$ 秒。\n\n总耗时：$250 + 83.3333333 + 50 + 142.8571429 = 526.1904762$ 秒。\n\n注意你获得曲奇是连续的：比如游戏开始 $0.1$ 秒后你有 $0.2$ 个曲奇，$\\pi$ 秒后你有 $2\\pi$ 个曲奇。", "inputFormat": "输入的第一行包含一个整数 $T$，表示测试用例数量。接下来 $T$ 行，每行包含三个用空格分隔的实数：$C$、$F$ 和 $X$，含义如上文所述。\n\n$C$、$F$ 和 $X$ 都至少有一位整数，后跟小数点和 $1$ 到 $5$ 位小数。不会有前导零。", "outputFormat": "对于每组测试用例，输出一行 \"Case #$x$: $y$\"，其中 $x$ 为测试用例编号（从 $1$ 开始），$y$ 为获得 $X$ 个美味曲奇所需的最短秒数。\n\n建议将 $y$ 输出到 $7$ 位小数，但不是强制要求。如果 $y$ 的绝对误差或相对误差在 $10^{-6}$ 以内，则视为正确。\n", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 100$。\n\n**小数据集（8 分）**\n\n- 时间限制：~~60~~ 3 秒。\n- $1 \\leq C \\leq 500$。\n- $1 \\leq F \\leq 4$。\n- $1 \\leq X \\leq 2000$。\n\n**大数据集（11 分）**\n\n- 时间限制：~~120~~ 5 秒。\n- $1 \\leq C \\leq 10000$。\n- $1 \\leq F \\leq 100$。\n- $1 \\leq X \\leq 100000$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13245", "type": "P", "difficulty": 4, "samples": [["5\n5 5 23\n3 1 1\n2 2 1\n4 7 3\n10 10 82", "Case #1:\nImpossible\nCase #2:\nc\n.\n*\nCase #3:\nImpossible\nCase #4:\n......*\n.c....*\n.......\n..*....\nCase #5:\n**********\n**********\n**********\n****....**\n***.....**\n***.c...**\n***....***\n**********\n**********\n**********"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["搜索", "2014", "Special Judge", "枚举", "深度优先搜索 DFS", "Google Code Jam"], "title": "[GCJ 2014 Qualification] Minesweeper Master", "background": "", "description": "Minesweeper is a computer game that became popular in the 1980s, and is still included in some versions of the Microsoft Windows operating system. This problem has a similar idea, but it does not assume you have played Minesweeper.\n\nIn this problem, you are playing a game on a grid of identical cells. The content of each cell is initially hidden. There are $M$ mines hidden in $M$ different cells of the grid. No other cells contain mines. You may click on any cell to reveal it. If the revealed cell contains a mine, then the game is over, and you lose. Otherwise, the revealed cell will contain a digit between $0$ and $8$, inclusive, which corresponds to the number of neighboring cells that contain mines. Two cells are neighbors if they share a corner or an edge. Additionally, if the revealed cell contains a $0$, then all of the neighbors of the revealed cell are automatically revealed as well, recursively. When all the cells that don't contain mines have been revealed, the game ends, and you win.\n\nFor example, an initial configuration of the board may look like this ('*' denotes a mine, and 'c' is the first clicked cell):\n\n```\n*..*...**.\n....*.....\n..c..*....\n........*.\n..........\n```\n\nThere are no mines adjacent to the clicked cell, so when it is revealed, it becomes a 0, and its 8 adjacent cells are revealed as well. This process continues, resulting in the following board:\n\n```\n*..*...**.\n1112*.....\n00012*....\n00001111*.\n00000001..\n```\n\nAt this point, there are still un-revealed cells that do not contain mines (denoted by '.' characters), so the player has to click again in order to continue the game.\n\nYou want to win the game as quickly as possible. There is nothing quicker than winning in one click. Given the size of the board ($R \\times C$) and the number of hidden mines $M$, is it possible (however unlikely) to win in one click? You may choose where you click. If it is possible, then print any valid mine configuration and the coordinates of your click, following the specifications in the Output section. Otherwise, print \"Impossible\".", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each line contains three space-separated integers: $R$, $C$, and $M$.", "outputFormat": "For each test case, output a line containing \"Case #$x$:\", where $x$ is the test case number (starting from $1$). On the following $R$ lines, output the board configuration with $C$ characters per line, using '.' to represent an empty cell, '*' to represent a cell that contains a mine, and 'c' to represent the clicked cell.\n\nIf there is no possible configuration, then instead of the grid, output a line with \"Impossible\" instead. If there are multiple possible configurations, output any one of them.", "hint": "**Limits**\n\n$0 \\leq M < R \\times C$.\n\n**Small dataset(11 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq T \\leq 230$.\n- $1 \\leq R, C \\leq 5$.\n\n**Large dataset(24 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq T \\leq 140$.\n- $1 \\leq R, C \\leq 50$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 Qualification] Minesweeper Master", "background": "", "description": "Minesweeper is a computer game that became popular in the 1980s, and is still included in some versions of the Microsoft Windows operating system. This problem has a similar idea, but it does not assume you have played Minesweeper.\n\nIn this problem, you are playing a game on a grid of identical cells. The content of each cell is initially hidden. There are $M$ mines hidden in $M$ different cells of the grid. No other cells contain mines. You may click on any cell to reveal it. If the revealed cell contains a mine, then the game is over, and you lose. Otherwise, the revealed cell will contain a digit between $0$ and $8$, inclusive, which corresponds to the number of neighboring cells that contain mines. Two cells are neighbors if they share a corner or an edge. Additionally, if the revealed cell contains a $0$, then all of the neighbors of the revealed cell are automatically revealed as well, recursively. When all the cells that don't contain mines have been revealed, the game ends, and you win.\n\nFor example, an initial configuration of the board may look like this ('*' denotes a mine, and 'c' is the first clicked cell):\n\n```\n*..*...**.\n....*.....\n..c..*....\n........*.\n..........\n```\n\nThere are no mines adjacent to the clicked cell, so when it is revealed, it becomes a 0, and its 8 adjacent cells are revealed as well. This process continues, resulting in the following board:\n\n```\n*..*...**.\n1112*.....\n00012*....\n00001111*.\n00000001..\n```\n\nAt this point, there are still un-revealed cells that do not contain mines (denoted by '.' characters), so the player has to click again in order to continue the game.\n\nYou want to win the game as quickly as possible. There is nothing quicker than winning in one click. Given the size of the board ($R \\times C$) and the number of hidden mines $M$, is it possible (however unlikely) to win in one click? You may choose where you click. If it is possible, then print any valid mine configuration and the coordinates of your click, following the specifications in the Output section. Otherwise, print \"Impossible\".", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each line contains three space-separated integers: $R$, $C$, and $M$.", "outputFormat": "For each test case, output a line containing \"Case #$x$:\", where $x$ is the test case number (starting from $1$). On the following $R$ lines, output the board configuration with $C$ characters per line, using '.' to represent an empty cell, '*' to represent a cell that contains a mine, and 'c' to represent the clicked cell.\n\nIf there is no possible configuration, then instead of the grid, output a line with \"Impossible\" instead. If there are multiple possible configurations, output any one of them.", "hint": "**Limits**\n\n$0 \\leq M < R \\times C$.\n\n**Small dataset(11 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq T \\leq 230$.\n- $1 \\leq R, C \\leq 5$.\n\n**Large dataset(24 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq T \\leq 140$.\n- $1 \\leq R, C \\leq 50$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 Qualification] Minesweeper Master", "background": null, "description": "**Minesweeper**（扫雷）是一款在 20 世纪 80 年代流行起来的电脑游戏，至今仍被包含在某些版本的 Microsoft Windows 操作系统中。本题的设定与该游戏类似，但不要求你玩过扫雷。\n\n在本题中，你将在一个由若干相同方格组成的网格上进行游戏。每个格子中的内容在初始时是隐藏的。共有 $M$ 枚地雷被隐藏在 $M$ 个不同的格子中，其他格子中不含地雷。你可以点击任意一个格子来揭示其内容。如果你点开的格子中有地雷，游戏立刻结束，你失败。否则，该格子将显示一个介于 $0$ 到 $8$ 之间的数字，表示与该格子相邻的格子中包含地雷的数量。两个格子被认为是相邻的，当且仅当它们共享一个边或一个角。\n\n此外，如果你揭示的格子显示的是 $0$，则其所有相邻格子也会被自动揭示，并递归地继续这个过程。当所有不含地雷的格子都被揭示时，游戏结束，你获胜。\n\n例如，一个初始的棋盘配置可能如下所示（`*` 表示地雷，`c` 表示首次点击的格子）：\n\n```\n*..*...**.\n....*.....\n..c..*....\n........*.\n..........\n```\n\n点击的格子周围没有地雷，因此被揭示后显示为 $0$，并触发其 8 个相邻格子的自动揭示。这个过程继续进行，最终得到如下棋盘：\n\n```\n*..*...**.\n1112*.....\n00012*....\n00001111*.\n00000001..\n```\n\n此时，仍有一些未被揭示的、且不含地雷的格子（用 `.` 表示），因此玩家必须再次点击以继续游戏。\n\n你希望尽可能快地赢得游戏。最快的方式自然是**只点击一次就获胜**。给定棋盘的大小（$R \\times C$）以及隐藏的地雷数 $M$，请判断是否存在一种（哪怕极不可能）配置，使得玩家只需点击一次就能赢得游戏？你可以自由选择点击的位置。如果存在这样的配置，请输出任意一种符合要求的地雷布置及点击坐标，具体格式见输出说明；如果不存在，则输出 **\"Impossible\"**。", "inputFormat": "输入的第一行是测试用例的数量 $T$。接下来的 $T$ 行，每行包含三个用空格分隔的整数：$R$、$C$ 和 $M$。", "outputFormat": "对于每个测试用例，输出一行 `\"Case #x:\"`，其中 $x$ 是当前测试用例的编号（从 $1$ 开始）。随后输出 $R$ 行，每行包含 $C$ 个字符，表示棋盘的布置。使用 `.` 表示空格，`*` 表示含有地雷的格子，`c` 表示被点击的格子。\n\n如果不存在符合要求的棋盘配置，则在 `\"Case #x:\"` 之后输出一行 **\"Impossible\"**，而非棋盘内容。若存在多种可能的配置，输出其中任意一种即可。", "hint": "**限制条件**\n\n$0 \\leq M < R \\times C$。\n\n**小数据集（11 分）**\n\n- 时间限制：~~60~~ 3 秒。\n- $1 \\leq T \\leq 230$。\n- $1 \\leq R, C \\leq 5$。\n\n**大数据集（24 分）**\n\n- 时间限制：~~120~~ 5 秒。\n- $1 \\leq T \\leq 140$。\n- $1 \\leq R, C \\leq 50$。\n\n翻译由 ChatGPT-4o 完成。", "locale": "zh-CN"}}}
{"pid": "P13246", "type": "P", "difficulty": 4, "samples": [["4\n1\n0.5\n0.6\n2\n0.7 0.2\n0.8 0.3\n3\n0.5 0.1 0.9\n0.6 0.4 0.3\n9\n0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458", "Case #1: 0 0\nCase #2: 1 0\nCase #3: 2 1\nCase #4: 8 4"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["贪心", "博弈论", "2014", "Google Code Jam"], "title": "[GCJ 2014 Qualification] Deceitful War", "background": "This problem is the hardest problem to understand in this round. If you are new to Code Jam, you should probably try to solve the other problems first.", "description": "Naomi and Ken sometimes play games together. Before they play, each of them gets $N$ identical-looking blocks of wood with masses between $0.0\\, \\text{kg}$ and $1.0\\, \\text{kg}$ (exclusive). All of the blocks have different weights. There are lots of games they could play with those blocks, but they usually play something they call War. Here is how War works:\n\n1. Each player weighs each of his or her own blocks, so each player knows the weights of all of his or her own blocks, but not the weights of the other player's blocks.\n2. They repeat the following process $N$ times:\n    1. Naomi chooses one of her own blocks, with mass $\\text{chosen}_{\\text{Naomi}}$.\n    2. Naomi tells Ken the mass of the block she chose.\n    3. Ken chooses one of his own blocks, with mass $\\text{chosen}_{\\text{Ken}}$.\n    4. They each put their block on one side of a balance scale, and the person whose block is heavier gets one point.\n    5. Both blocks are destroyed in a fire.\n\nNaomi has realized three things about War. First, she has realized that she loses a lot. Second, she has realized that there is a unique strategy that Ken can follow to maximize his points without assuming anything about Naomi's strategy, and that Ken always uses it. Third, she has realized that she hates to lose. Naomi has decided that instead of playing War, she will play a game she calls Deceitful War. The great thing about Deceitful War is that Ken will think they're playing War!\n\nHere is how Deceitful War works, with differences between Deceitful War and War in bold:\n\n1. Each player weighs each of his or her own blocks. **Naomi also weighs Ken's blocks while he isn't looking, so Naomi knows the weights of all blocks and Ken only knows the weights of his own blocks.**\n2. They repeat the following process $N$ times:\n    1. Naomi chooses one of her own blocks, with mass $\\text{chosen}_{\\text{Naomi}}$.\n    2. **Naomi tells Ken a number, $\\text{Told}_{\\text{Naomi}}$, between $0.0\\, \\text{kg}$ and $1.0\\, \\text{kg}$ exclusive. Ken, who thinks they're playing War, thinks the number Naomi just told him is $\\text{chosen}_{\\text{Naomi}}$.**\n    3. Ken chooses one of his own blocks, with mass $\\text{chosen}_{\\text{Ken}}$.\n    4. They each put their block on one side of a balance scale, and the person whose block is heavier gets one point.\n    5. Both blocks are destroyed in a fire.\n\nNaomi doesn't want Ken to know that she isn't playing War; so when she is choosing which block to play, and what mass to tell Ken, she must make sure that the balance scale won't reveal that $\\text{Chosen}_{\\text{Naomi}} \\neq \\text{Told}_{\\text{Naomi}}$. In other words, she must make decisions so that:\n\n* $\\text{Chosen}_{\\text{Naomi}} > \\text{Chosen}_{\\text{Ken}}$ if, and only if, $\\text{Told}_{\\text{Naomi}} > \\text{Chosen}_{\\text{Ken}}$, and\n* $\\text{Told}_{\\text{Naomi}}$ is not equal to the mass of any of Ken's blocks, because he knows that isn't possible.\n\nIt might seem like Naomi won't win any extra points by being deceitful, because Ken might discover that she wasn't playing War; but Naomi knows Ken thinks both players are playing War, and she knows what he knows, and she knows Ken will always follow his unique optimal strategy for War, so she can always predict what he will play.\n\nYou'll be given the masses of the blocks Naomi and Ken started with. Naomi will play Deceitful War optimally to gain the maximum number of points. Ken will play War optimally to gain the maximum number of points assuming that both players are playing War. What will Naomi's score be? What would it have been if she had played War optimally instead?\n\n**Examples**\n\nIf each player has a single block left, where Naomi has $0.5\\, \\text{kg}$ and Ken has $0.6\\, \\text{kg}$, then Ken is guaranteed to score the point. Naomi can't say her number is $\\geq 0.6\\, \\text{kg}$, or Ken will know she isn't playing War when the balance scale shows his block was heavier.\n\nIf each player has two blocks left, where Naomi has $[0.7\\, \\text{kg}, 0.2\\, \\text{kg}]$ and Ken has $[0.8\\, \\text{kg}, 0.3\\, \\text{kg}]$, then Naomi could choose her $0.2\\, \\text{kg}$ block, and deceive Ken by telling him that she chose a block that was $0.6\\, \\text{kg}$. Ken assumes Naomi is telling the truth (as in how the War game works) and will play his $0.8\\, \\text{kg}$ block to score a point. Ken was just deceived, but he will never realize it because the balance scale shows that his $0.8\\, \\text{kg}$ block is, like he expected, heavier than the block Naomi played. Now Naomi can play her $0.7\\, \\text{kg}$ block, tell Ken it is $0.7\\, \\text{kg}$, and score a point. If Naomi had played War instead of Deceitful War, then Ken would have scored two points and Naomi would have scored zero.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line containing a single integer $N$, the number of blocks each player has. Next follows a line containing $N$ space-separated real numbers: the masses of Naomi's blocks, in kg. Finally there will be a line containing $N$ space-separated real numbers: the masses of Ken's blocks, in kg.\n\nEach of the masses given to Ken and Naomi will be represented as a $0$, followed by a decimal point, followed by $1$-$5$ digits. Even though all the numbers in the input have $1$-$5$ digits after the decimal point, Ken and Naomi don't know that; so Naomi can still tell Ken that she played a block with mass $0.5000001\\, \\text{kg}$, and Ken has no reason not to believe her.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$ $z$\", where $x$ is the test case number (starting from $1$), $y$ is the number of points Naomi will score if she plays Deceitful War optimally, and $z$ is the number of points Naomi will score if she plays War optimally.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50$.\n- All the masses given to Ken and Naomi are distinct, and between $0.0$ and $1.0$ exclusive.\n\n**Small dataset**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq N \\leq 10$.\n\n**Large dataset**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq N \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 Qualification] Deceitful War", "background": "This problem is the hardest problem to understand in this round. If you are new to Code Jam, you should probably try to solve the other problems first.", "description": "Naomi and Ken sometimes play games together. Before they play, each of them gets $N$ identical-looking blocks of wood with masses between $0.0\\, \\text{kg}$ and $1.0\\, \\text{kg}$ (exclusive). All of the blocks have different weights. There are lots of games they could play with those blocks, but they usually play something they call War. Here is how War works:\n\n1. Each player weighs each of his or her own blocks, so each player knows the weights of all of his or her own blocks, but not the weights of the other player's blocks.\n2. They repeat the following process $N$ times:\n    1. Naomi chooses one of her own blocks, with mass $\\text{chosen}_{\\text{Naomi}}$.\n    2. Naomi tells Ken the mass of the block she chose.\n    3. Ken chooses one of his own blocks, with mass $\\text{chosen}_{\\text{Ken}}$.\n    4. They each put their block on one side of a balance scale, and the person whose block is heavier gets one point.\n    5. Both blocks are destroyed in a fire.\n\nNaomi has realized three things about War. First, she has realized that she loses a lot. Second, she has realized that there is a unique strategy that Ken can follow to maximize his points without assuming anything about Naomi's strategy, and that Ken always uses it. Third, she has realized that she hates to lose. Naomi has decided that instead of playing War, she will play a game she calls Deceitful War. The great thing about Deceitful War is that Ken will think they're playing War!\n\nHere is how Deceitful War works, with differences between Deceitful War and War in bold:\n\n1. Each player weighs each of his or her own blocks. **Naomi also weighs Ken's blocks while he isn't looking, so Naomi knows the weights of all blocks and Ken only knows the weights of his own blocks.**\n2. They repeat the following process $N$ times:\n    1. Naomi chooses one of her own blocks, with mass $\\text{chosen}_{\\text{Naomi}}$.\n    2. **Naomi tells Ken a number, $\\text{Told}_{\\text{Naomi}}$, between $0.0\\, \\text{kg}$ and $1.0\\, \\text{kg}$ exclusive. Ken, who thinks they're playing War, thinks the number Naomi just told him is $\\text{chosen}_{\\text{Naomi}}$.**\n    3. Ken chooses one of his own blocks, with mass $\\text{chosen}_{\\text{Ken}}$.\n    4. They each put their block on one side of a balance scale, and the person whose block is heavier gets one point.\n    5. Both blocks are destroyed in a fire.\n\nNaomi doesn't want Ken to know that she isn't playing War; so when she is choosing which block to play, and what mass to tell Ken, she must make sure that the balance scale won't reveal that $\\text{Chosen}_{\\text{Naomi}} \\neq \\text{Told}_{\\text{Naomi}}$. In other words, she must make decisions so that:\n\n* $\\text{Chosen}_{\\text{Naomi}} > \\text{Chosen}_{\\text{Ken}}$ if, and only if, $\\text{Told}_{\\text{Naomi}} > \\text{Chosen}_{\\text{Ken}}$, and\n* $\\text{Told}_{\\text{Naomi}}$ is not equal to the mass of any of Ken's blocks, because he knows that isn't possible.\n\nIt might seem like Naomi won't win any extra points by being deceitful, because Ken might discover that she wasn't playing War; but Naomi knows Ken thinks both players are playing War, and she knows what he knows, and she knows Ken will always follow his unique optimal strategy for War, so she can always predict what he will play.\n\nYou'll be given the masses of the blocks Naomi and Ken started with. Naomi will play Deceitful War optimally to gain the maximum number of points. Ken will play War optimally to gain the maximum number of points assuming that both players are playing War. What will Naomi's score be? What would it have been if she had played War optimally instead?\n\n**Examples**\n\nIf each player has a single block left, where Naomi has $0.5\\, \\text{kg}$ and Ken has $0.6\\, \\text{kg}$, then Ken is guaranteed to score the point. Naomi can't say her number is $\\geq 0.6\\, \\text{kg}$, or Ken will know she isn't playing War when the balance scale shows his block was heavier.\n\nIf each player has two blocks left, where Naomi has $[0.7\\, \\text{kg}, 0.2\\, \\text{kg}]$ and Ken has $[0.8\\, \\text{kg}, 0.3\\, \\text{kg}]$, then Naomi could choose her $0.2\\, \\text{kg}$ block, and deceive Ken by telling him that she chose a block that was $0.6\\, \\text{kg}$. Ken assumes Naomi is telling the truth (as in how the War game works) and will play his $0.8\\, \\text{kg}$ block to score a point. Ken was just deceived, but he will never realize it because the balance scale shows that his $0.8\\, \\text{kg}$ block is, like he expected, heavier than the block Naomi played. Now Naomi can play her $0.7\\, \\text{kg}$ block, tell Ken it is $0.7\\, \\text{kg}$, and score a point. If Naomi had played War instead of Deceitful War, then Ken would have scored two points and Naomi would have scored zero.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line containing a single integer $N$, the number of blocks each player has. Next follows a line containing $N$ space-separated real numbers: the masses of Naomi's blocks, in kg. Finally there will be a line containing $N$ space-separated real numbers: the masses of Ken's blocks, in kg.\n\nEach of the masses given to Ken and Naomi will be represented as a $0$, followed by a decimal point, followed by $1$-$5$ digits. Even though all the numbers in the input have $1$-$5$ digits after the decimal point, Ken and Naomi don't know that; so Naomi can still tell Ken that she played a block with mass $0.5000001\\, \\text{kg}$, and Ken has no reason not to believe her.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$ $z$\", where $x$ is the test case number (starting from $1$), $y$ is the number of points Naomi will score if she plays Deceitful War optimally, and $z$ is the number of points Naomi will score if she plays War optimally.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50$.\n- All the masses given to Ken and Naomi are distinct, and between $0.0$ and $1.0$ exclusive.\n\n**Small dataset**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq N \\leq 10$.\n\n**Large dataset**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq N \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 Qualification] Deceitful War", "background": "这是本轮比赛中最难理解的一道题。如果你是 Code Jam 的新手，建议先尝试解决其他题目。", "description": "Naomi 和 Ken 有时会一起玩游戏。在每局游戏开始前，他们每人会获得 $N$ 块看起来完全一样的木块，质量在 $0.0\\,\\text{kg}$ 到 $1.0\\,\\text{kg}$ 之间（不包括端点）。所有木块的质量彼此不同。他们可以用这些木块玩许多种游戏，但他们通常玩的游戏叫作 **War**（战争）。War 的规则如下：\n\n1. 每位玩家会称量自己所有木块的质量，因此他们都知道自己所有木块的重量，但不知道对方木块的重量。\n2. 他们会重复进行以下过程共 $N$ 次：\n    1. Naomi 选择她的一块木块，质量为 $\\text{chosen}_{\\text{Naomi}}$。\n    2. Naomi 将这块木块的质量告诉 Ken。\n    3. Ken 选择他的一块木块，质量为 $\\text{chosen}_{\\text{Ken}}$。\n    4. 他们分别将自己的木块放在天平的两边，质量较大的那一方获得一分。\n    5. 两块木块随后一同被焚毁。\n\nNaomi 意识到了关于 War 的三件事。首先，她意识到自己经常输。其次，她意识到 Ken 有一个**唯一的**策略，可以在不假设 Naomi 策略的前提下最大化自己的得分，而 Ken 总是采用该策略。第三，她意识到自己讨厌输。因此 Naomi 决定不再玩 War，而是玩她自创的游戏，称为 **Deceitful War（欺诈战争）**。这个游戏的妙处在于，Ken 仍然以为他们在玩 War！\n\nDeceitful War 的规则如下，区别于 War 的部分用**粗体**标出：\n\n1. 每位玩家称量自己所有木块的质量。**Naomi 还会在 Ken 不注意时称量他的木块，因此 Naomi 知道所有木块的质量，而 Ken 只知道自己木块的质量。**\n2. 他们会重复以下过程共 $N$ 次：\n    1. Naomi 选择她的一块木块，质量为 $\\text{chosen}_{\\text{Naomi}}$。\n    2. **Naomi 向 Ken 报出一个数 $\\text{Told}_{\\text{Naomi}}$，其值在 $0.0\\,\\text{kg}$ 到 $1.0\\,\\text{kg}$ 之间（不包括端点）。Ken 认为他们在玩 War，因此他会以为 Naomi 报的这个数就是她选择的木块的质量，即 $\\text{chosen}_{\\text{Naomi}}$。**\n    3. Ken 选择他的一块木块，质量为 $\\text{chosen}_{\\text{Ken}}$。\n    4. 他们将各自的木块放在天平两侧，质量较大的一方获得一分。\n    5. 两块木块随后一同被焚毁。\n\nNaomi 不希望 Ken 发现她实际上并没有在玩 War。因此，在选择要使用的木块及要告知 Ken 的质量时，她必须确保天平不会揭示出 $\\text{Chosen}_{\\text{Naomi}} \\neq \\text{Told}_{\\text{Naomi}}$。换句话说，她的决策必须满足以下条件：\n\n- 当且仅当 $\\text{Chosen}_{\\text{Naomi}} > \\text{Chosen}_{\\text{Ken}}$ 时，才有 $\\text{Told}_{\\text{Naomi}} > \\text{Chosen}_{\\text{Ken}}$；\n- $\\text{Told}_{\\text{Naomi}}$ 不得与 Ken 的任意一块木块的质量相等，因为他知道那是不可能的。\n\n你可能会觉得 Naomi 通过欺骗并不能获得更多分数，因为 Ken 可能会发现她不是在玩 War；但 Naomi 知道 Ken 相信双方都在玩 War，而她也知道 Ken 会始终采用他在 War 中的最优策略，因此 Naomi 能预测 Ken 的每一步行动。\n\n你将获得 Naomi 和 Ken 最初的木块质量数据。Naomi 将使用 Deceitful War 的最优策略来获得尽可能多的分数；Ken 将使用 War 的最优策略（假设双方都在玩 War）来获得尽可能多的分数。你的任务是计算：\n\n- 如果 Naomi 玩的是 Deceitful War，她最多能获得多少分？\n- 如果 Naomi 玩的是 War，采用最优策略，她最多能获得多少分？\n\n**示例说明**\n\n如果每位玩家只剩下一块木块，Naomi 的质量是 $0.5\\,\\text{kg}$，Ken 的质量是 $0.6\\,\\text{kg}$，那么 Ken 保证得分。Naomi 无法声称她的木块质量是 $\\geq 0.6\\,\\text{kg}$，否则当天平显示 Ken 的木块更重时，Ken 会发现她没有在玩 War。\n\n如果每位玩家还剩两块木块，Naomi 拥有 $[0.7\\,\\text{kg}, 0.2\\,\\text{kg}]$，Ken 拥有 $[0.8\\,\\text{kg}, 0.3\\,\\text{kg}]$，那么 Naomi 可以选择她的 $0.2\\,\\text{kg}$ 木块，并对 Ken 谎称其质量是 $0.6\\,\\text{kg}$。Ken 会误以为 Naomi 说的是真话（因为他以为他们在玩 War），于是他会选择他的 $0.8\\,\\text{kg}$ 木块来争取得分。Ken 的确得了一分，却没有意识到自己被骗了，因为天平确实显示他的木块更重。接下来 Naomi 可以使用她的 $0.7\\,\\text{kg}$ 木块，并如实告诉 Ken，它的质量是 $0.7\\,\\text{kg}$，从而赢得该轮得分。\n\n若 Naomi 此前没有欺骗，而是一直玩 War，那么 Ken 会赢得两分，Naomi 将一分未得。", "inputFormat": "输入的第一行是测试用例数量 $T$。接下来的 $T$ 组测试数据中，每组测试数据的第一行是一个整数 $N$，表示每位玩家拥有的木块数量。第二行是 $N$ 个用空格分隔的实数，表示 Naomi 拥有的木块质量（单位为 kg）。第三行是 $N$ 个用空格分隔的实数，表示 Ken 拥有的木块质量（单位为 kg）。\n\n所有 Naomi 和 Ken 的木块质量都以 $0$ 开头的小数形式给出，且具有 $1$ 到 $5$ 位小数。尽管输入中的质量数值都保留了 $1$ 到 $5$ 位小数，Naomi 和 Ken 并不知道这一点；因此 Naomi 仍然可以向 Ken 报一个例如 $0.5000001\\,\\text{kg}$ 的质量值，而 Ken 不会怀疑她。\n", "outputFormat": "对于每组测试数据，输出一行 `\"Case #x: y z\"`，其中 $x$ 是当前测试用例的编号（从 $1$ 开始），$y$ 是 Naomi 采用 Deceitful War 最优策略时的得分，$z$ 是她采用 War 最优策略时的得分。\n", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 50$；\n- 所有 Naomi 和 Ken 的木块质量彼此不同，且位于 $0.0$ 与 $1.0$ 之间（不包括端点）。\n\n**小数据集**\n\n- 时间限制：~~60~~ 3 秒；\n- $1 \\leq N \\leq 10$。\n\n**大数据集**\n\n- 时间限制：~~120~~ 5 秒；\n- $1 \\leq N \\leq 1000$。\n\n翻译由 ChatGPT-4o 完成。", "locale": "zh-CN"}}}
{"pid": "P13247", "type": "P", "difficulty": 3, "samples": [["3\n3 2\n01 11 10\n11 00 10\n2 3\n101 111\n010 001\n2 2\n01 10\n10 01", "Case #1: 1\nCase #2: NOT POSSIBLE\nCase #3: 0"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["2014", "位运算", "Google Code Jam"], "title": "[GCJ 2014 #1A] Charging Chaos", "background": "", "description": "Shota the farmer has a problem. He has just moved into his newly built farmhouse, but it turns out that the outlets haven't been configured correctly for all of his devices. Being a modern farmer, Shota owns a large number of smartphones and laptops, and even owns a tablet for his favorite cow Wagyu to use. In total, he owns $N$ different devices.\n\nAs these devices have different specifications and are made by a variety of companies, they each require a different electric flow to charge. Similarly, each outlet in the house outputs a specific electric flow. An electric flow can be represented by a string of 0s and 1s of length $L$.\n\nShota would like to be able to charge all $N$ of his devices at the same time. Coincidentally, there are exactly $N$ outlets in his new house. In order to configure the electric flow from the outlets, there is a master control panel with $L$ switches. The $i^{\\text{th}}$ switch flips the $i^{\\text{th}}$ bit of the electric flow from each outlet in the house. For example, if the electric flow from the outlets is:\n\n```\nOutlet 0: 10\nOutlet 1: 01\nOutlet 2: 11\n```\n\nThen flipping the second switch will reconfigure the electric flow to:\n\n```\nOutlet 0: 11\nOutlet 1: 00\nOutlet 2: 10\n```\n\nIf Shota has a smartphone that needs flow \"11\" to charge, a tablet that needs flow \"10\" to charge, and a laptop that needs flow \"00\" to charge, then flipping the second switch will make him very happy!\n\nMisaki has been hired by Shota to help him solve this problem. She has measured the electric flows from the outlets in the house, and noticed that they are all different. Decide if it is possible for Shota to charge all of his devices at the same time, and if it is possible, figure out the minimum number of switches that needs to be flipped, because the switches are big and heavy and Misaki doesn't want to flip more than what she needs to.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of three lines. The first line contains two space-separated integers $N$ and $L$. The second line contains $N$ space-separated strings of length $L$, representing the initial electric flow from the outlets. The third line also contains $N$ space-separated strings of length $L$, representing the electric flow required by Shota's devices.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the minimum number of switches to be flipped in order for Shota to charge all his devices. If it is impossible, $y$ should be the string \"NOT POSSIBLE\" (without the quotes). Please note that our judge is not case-sensitive, but it is strict in other ways: so although \"not possible\" will be judged correct, any misspelling will be judged wrong. We suggest copying/pasting the string NOT POSSIBLE into your code.", "hint": "**Sample Explanation**\n\nIn the first example case, Misaki can flip the second switch once. The electric flow from the outlets becomes:\n```\nOutlet 0: 00\nOutlet 1: 10\nOutlet 2: 11\n```\nThen Shota can use the outlet 0 to charge device 1, the outlet 1 to charge device 2, outlet 2 to charge device 0. This is also a solution that requires the minimum amount number of switches to be flipped.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- No two outlets will be producing the same electric flow, initially.\n- No two devices will require the same electric flow.\n\n**Small dataset**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq N \\leq 10$.\n- $2 \\leq L \\leq 10$.\n\n**Large dataset**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq N \\leq 150$.\n- $10 \\leq L \\leq 40$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 #1A] Charging Chaos", "background": "", "description": "Shota the farmer has a problem. He has just moved into his newly built farmhouse, but it turns out that the outlets haven't been configured correctly for all of his devices. Being a modern farmer, Shota owns a large number of smartphones and laptops, and even owns a tablet for his favorite cow Wagyu to use. In total, he owns $N$ different devices.\n\nAs these devices have different specifications and are made by a variety of companies, they each require a different electric flow to charge. Similarly, each outlet in the house outputs a specific electric flow. An electric flow can be represented by a string of 0s and 1s of length $L$.\n\nShota would like to be able to charge all $N$ of his devices at the same time. Coincidentally, there are exactly $N$ outlets in his new house. In order to configure the electric flow from the outlets, there is a master control panel with $L$ switches. The $i^{\\text{th}}$ switch flips the $i^{\\text{th}}$ bit of the electric flow from each outlet in the house. For example, if the electric flow from the outlets is:\n\n```\nOutlet 0: 10\nOutlet 1: 01\nOutlet 2: 11\n```\n\nThen flipping the second switch will reconfigure the electric flow to:\n\n```\nOutlet 0: 11\nOutlet 1: 00\nOutlet 2: 10\n```\n\nIf Shota has a smartphone that needs flow \"11\" to charge, a tablet that needs flow \"10\" to charge, and a laptop that needs flow \"00\" to charge, then flipping the second switch will make him very happy!\n\nMisaki has been hired by Shota to help him solve this problem. She has measured the electric flows from the outlets in the house, and noticed that they are all different. Decide if it is possible for Shota to charge all of his devices at the same time, and if it is possible, figure out the minimum number of switches that needs to be flipped, because the switches are big and heavy and Misaki doesn't want to flip more than what she needs to.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of three lines. The first line contains two space-separated integers $N$ and $L$. The second line contains $N$ space-separated strings of length $L$, representing the initial electric flow from the outlets. The third line also contains $N$ space-separated strings of length $L$, representing the electric flow required by Shota's devices.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the minimum number of switches to be flipped in order for Shota to charge all his devices. If it is impossible, $y$ should be the string \"NOT POSSIBLE\" (without the quotes). Please note that our judge is not case-sensitive, but it is strict in other ways: so although \"not possible\" will be judged correct, any misspelling will be judged wrong. We suggest copying/pasting the string NOT POSSIBLE into your code.", "hint": "**Sample Explanation**\n\nIn the first example case, Misaki can flip the second switch once. The electric flow from the outlets becomes:\n```\nOutlet 0: 00\nOutlet 1: 10\nOutlet 2: 11\n```\nThen Shota can use the outlet 0 to charge device 1, the outlet 1 to charge device 2, outlet 2 to charge device 0. This is also a solution that requires the minimum amount number of switches to be flipped.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- No two outlets will be producing the same electric flow, initially.\n- No two devices will require the same electric flow.\n\n**Small dataset**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq N \\leq 10$.\n- $2 \\leq L \\leq 10$.\n\n**Large dataset**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq N \\leq 150$.\n- $10 \\leq L \\leq 40$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 #1A] Charging Chaos", "background": "", "description": "农夫 Shota 遇到了一点麻烦。他刚刚搬进自己新建的农舍，却发现房子的插座无法正确为他所有的设备充电。作为一位现代农夫，Shota 拥有大量的智能手机和笔记本电脑，甚至还为他最喜爱的奶牛 Wagyu 准备了一台平板电脑。总共，他拥有 $N$ 个不同的设备。\n\n由于这些设备由不同厂商制造，规格也各不相同，因此每个设备都需要不同的电流格式来进行充电。同样地，房子中的每个插座也输出特定格式的电流。一个电流格式可以用一个长度为 $L$ 的仅包含 $0$ 和 $1$ 的字符串来表示。\n\nShota 希望能够同时为他所有的 $N$ 个设备充电。恰好，他新家的插座数量也正好是 $N$ 个。为了配置插座的电流格式，房子里设有一个总控制面板，带有 $L$ 个开关。第 $i$ 个开关用于**翻转每个插座输出电流格式中的第 $i$ 位**。例如，如果初始插座的电流格式如下：\n\n```\n插座 0：10\n插座 1：01\n插座 2：11\n```\n\n那么翻转第 2 个开关之后，插座的电流格式将变为：\n\n```\n插座 0：11\n插座 1：00\n插座 2：10\n```\n\n如果 Shota 的智能手机需要电流格式 `\"11\"` 充电，平板电脑需要 `\"10\"`，笔记本电脑需要 `\"00\"`，那么只需翻转第二个开关，他就可以非常开心地同时为所有设备充电了！\n\n为了解决这个问题，Shota 雇佣了 Misaki 来帮忙。Misaki 测量了所有插座的电流格式，并发现它们都是不同的。现在你的任务是判断 Shota 是否可能通过翻转一些开关来让所有设备都能充电。如果可能，请计算出**所需翻转的最少开关数**，因为这些开关又大又重，Misaki 不想做无用功。\n", "inputFormat": "输入的第一行是测试用例的数量 $T$。接下来是 $T$ 个测试用例。每个测试用例包括三行：\n\n- 第一行包含两个用空格分隔的整数 $N$ 和 $L$。\n- 第二行包含 $N$ 个长度为 $L$ 的字符串，表示初始插座的电流格式。\n- 第三行也包含 $N$ 个长度为 $L$ 的字符串，表示 Shota 的每个设备所需的电流格式。", "outputFormat": "对于每个测试用例，输出一行 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是使所有设备可以充电所需翻转的最少开关数量。如果无法做到，请输出字符串 **\"NOT POSSIBLE\"**（不含引号）。请注意，评测系统对大小写不敏感，但对拼写和其他格式非常严格；因此，虽然 `\"not possible\"` 会被判定为正确，但任何拼写错误的字符串都会被判定为错误。我们建议你直接复制粘贴字符串 **\"NOT POSSIBLE\"** 使用。\n", "hint": "**样例说明**\n\n在第一个测试用例中，Misaki 只需翻转第二个开关一次，插座电流格式变为：\n\n```\n插座 0：00\n插座 1：10\n插座 2：11\n```\n\n此时 Shota 可以使用插座 0 给设备 1 充电，插座 1 给设备 2 充电，插座 2 给设备 0 充电。这是所需翻转开关次数最少的一个解决方案。\n\n## 限制条件\n\n- $1 \\leq T \\leq 100$\n- 初始状态下，任意两个插座的电流格式都不同\n- 任意两个设备所需的电流格式也都不同\n\n**小数据集**\n\n- 时间限制：~~60~~ 3 秒\n- $1 \\leq N \\leq 10$\n- $2 \\leq L \\leq 10$\n\n**大数据集**\n\n- 时间限制：~~120~~ 5 秒\n- $1 \\leq N \\leq 150$\n- $10 \\leq L \\leq 40$\n\n翻译由 ChatGPT-4o 完成。", "locale": "zh-CN"}}}
{"pid": "P13248", "type": "P", "difficulty": 4, "samples": [["3\n3\n2 1\n1 3\n7\n4 5\n4 2\n1 2\n3 1\n6 4\n3 7\n4\n1 2\n2 3\n3 4", "Case #1: 0\nCase #2: 2\nCase #3: 1"]], "limits": {"time": [3000, 10000], "memory": [1048576, 1048576]}, "tags": ["2014", "树形 DP", "Google Code Jam"], "title": "[GCJ 2014 #1A] Full Binary Tree", "background": "", "description": "A tree is a connected graph with no cycles.\n\nA rooted tree is a tree in which one special vertex is called the root. If there is an edge between $X$ and $Y$ in a rooted tree, we say that $Y$ is a child of $X$ if $X$ is closer to the root than $Y$ (in other words, the shortest path from the root to $X$ is shorter than the shortest path from the root to $Y$).\n\nA full binary tree is a rooted tree where every node has either exactly $2$ children or $0$ children.\n\nYou are given a tree $G$ with $N$ nodes (numbered from $1$ to $N$). You are allowed to delete some of the nodes. When a node is deleted, the edges connected to the deleted node are also deleted. Your task is to delete as few nodes as possible so that the remaining nodes form a full binary tree for some choice of the root from the remaining nodes.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. The first line of each test case contains a single integer $N$, the number of nodes in the tree. The following $N-1$ lines each one will contain two space-separated integers: $X_i\\ Y_i$, indicating that G contains an undirected edge between $X_i$ and $Y_i$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is the minimum number of nodes to delete from $G$ to make a full binary tree.", "hint": "**Sample Explanation**\n\nIn the first case, G is already a full binary tree (if we consider node $1$ as the root), so we don't need to do anything.\n\nIn the second case, we may delete nodes $3$ and $7$; then $2$ can be the root of a full binary tree.\n\nIn the third case, we may delete node $1$; then $3$ will become the root of a full binary tree (we could also have deleted node $4$; then we could have made $2$ the root).\n\n**Limits**\n\n- $1 \\leqslant T \\leqslant 100$.\n- $1 \\leqslant X_i, Y_i \\leqslant N$\n- Each test case will form a valid connected tree.\n\n**Small Dataset(9 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $2 \\leqslant N \\leqslant 15$.\n\n**Large dataset(21 Pts)**\n\n- Time limit: ~~120~~ 10 seconds.\n- $2 \\leqslant N \\leqslant 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 #1A] Full Binary Tree", "background": "", "description": "A tree is a connected graph with no cycles.\n\nA rooted tree is a tree in which one special vertex is called the root. If there is an edge between $X$ and $Y$ in a rooted tree, we say that $Y$ is a child of $X$ if $X$ is closer to the root than $Y$ (in other words, the shortest path from the root to $X$ is shorter than the shortest path from the root to $Y$).\n\nA full binary tree is a rooted tree where every node has either exactly $2$ children or $0$ children.\n\nYou are given a tree $G$ with $N$ nodes (numbered from $1$ to $N$). You are allowed to delete some of the nodes. When a node is deleted, the edges connected to the deleted node are also deleted. Your task is to delete as few nodes as possible so that the remaining nodes form a full binary tree for some choice of the root from the remaining nodes.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. The first line of each test case contains a single integer $N$, the number of nodes in the tree. The following $N-1$ lines each one will contain two space-separated integers: $X_i\\ Y_i$, indicating that G contains an undirected edge between $X_i$ and $Y_i$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is the minimum number of nodes to delete from $G$ to make a full binary tree.", "hint": "**Sample Explanation**\n\nIn the first case, G is already a full binary tree (if we consider node $1$ as the root), so we don't need to do anything.\n\nIn the second case, we may delete nodes $3$ and $7$; then $2$ can be the root of a full binary tree.\n\nIn the third case, we may delete node $1$; then $3$ will become the root of a full binary tree (we could also have deleted node $4$; then we could have made $2$ the root).\n\n**Limits**\n\n- $1 \\leqslant T \\leqslant 100$.\n- $1 \\leqslant X_i, Y_i \\leqslant N$\n- Each test case will form a valid connected tree.\n\n**Small Dataset(9 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $2 \\leqslant N \\leqslant 15$.\n\n**Large dataset(21 Pts)**\n\n- Time limit: ~~120~~ 10 seconds.\n- $2 \\leqslant N \\leqslant 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 #1A] Full Binary Tree", "background": "", "description": "树是一种**连通且无环**的图。\n\n**有根树**是一种特殊的树，它指定了一个特殊的点作为根。在有根树中，如果存在一条边连接 $X$ 和 $Y$，且 $X$ 到根节点的最短路径长度小于 $Y$ 到根节点的最短路径长度，那么我们称 $Y$ 是 $X$ 的**子节点**。\n\n**满二叉树**是一种有根树，其中每个节点要么恰好有 $2$ 个子节点，要么没有子节点。\n\n你将获得一棵含有 $N$ 个节点的树 $G$（节点编号为 $1$ 到 $N$）。你可以**删除任意数量的节点**，每当你删除一个节点，与其相连的边也会一并删除。你的目标是：通过删除尽可能少的节点，使得剩下的节点可以构成一棵**满二叉树**（以剩余节点中的某个点作为根）。\n", "inputFormat": "输入的第一行是测试用例的数量 $T$。接下来是 $T$ 个测试用例。每个测试用例的第一行是一个整数 $N$，表示树中节点的数量。接下来的 $N - 1$ 行，每行包含两个用空格分隔的整数 $X_i$ 和 $Y_i$，表示树 $G$ 中存在一条无向边连接 $X_i$ 和 $Y_i$。\n", "outputFormat": "对于每个测试用例，输出一行 `\"Case #x: y\"`，其中 $x$ 是当前测试用例的编号（从 $1$ 开始），$y$ 是为了将 $G$ 转换为一棵满二叉树所需删除的最少节点数。\n", "hint": "**样例说明**\n\n- 在第一个样例中，如果将节点 $1$ 作为根，那么 $G$ 已经是一棵满二叉树，因此不需要做任何操作。\n\n- 在第二个样例中，可以删除节点 $3$ 和 $7$，然后以节点 $2$ 为根，就能形成一棵满二叉树。\n\n- 在第三个样例中，可以删除节点 $1$，然后以节点 $3$ 为根，构成一棵满二叉树（也可以选择删除节点 $4$，并将 $2$ 作为根，同样成立）。\n\n## 限制条件\n\n- $1 \\leq T \\leq 100$\n- $1 \\leq X_i, Y_i \\leq N$\n- 每个测试用例保证输入构成一棵合法的连通树\n\n**小数据集（9 分）**\n\n- 时间限制：~~60~~ 3 秒\n- $2 \\leq N \\leq 15$\n\n**大数据集（21 分）**\n\n- 时间限制：~~120~~ 10 秒\n- $2 \\leq N \\leq 1000$\n\n翻译由 ChatGPT-4o 完成。", "locale": "zh-CN"}}}
{"pid": "P13249", "type": "P", "difficulty": 5, "samples": [["2\n3\n0 1 2\n3\n2 0 1", "Case #1: BAD\nCase #2: GOOD"]], "limits": {"time": [3000], "memory": [1048576]}, "tags": ["2014", "Special Judge", "概率论", "Google Code Jam"], "title": "[GCJ 2014 #1A] Proper Shuffle", "background": "", "description": "A permutation of size $N$ is a sequence of $N$ numbers, each between $0$ and $N-1$, where each number appears exactly once. They may appear in any order.\n\nThere are many ($N$ factorial, to be precise, but it doesn't matter in this problem) permutations of size $N$. Sometimes we just want to pick one at random, and of course we want to pick one at random uniformly: each permutation of size $N$ should have the same probability of being chosen.\n\nHere's the pseudocode for one of the possible algorithms to achieve that goal (we'll call it the good algorithm below):\n\n```\nfor k in 0 .. N-1:\n  a[k] = k\nfor k in 0 .. N-1:\n  p = randint(k .. N-1)\n  swap(a[k], a[p])\n```\n\nIn the above code, `randint(a .. b)` returns a uniform random integer between $a$ and $b$, inclusive.\n\nHere's the same algorithm in words. We start with the identity permutation: all numbers from $0$ to $N-1$ written in increasing order. Then, for each $k$ between $0$ and $N-1$, inclusive, we pick an independent uniform random integer $p_k$ between $k$ and $N-1$, inclusive, and swap the element at position $k$ (0-based) in our permutation with the element at position $p_k$.\n\nHere's an example for $N=4$. We start with the identity permutation:\n\n$$0 \\ 1 \\ 2 \\ 3$$\n\nNow $k=0$, and we pick a random $p_0$ between $0$ and $3$, inclusive. Let's say we picked $2$. We swap the 0th and 2nd elements, and our permutation becomes:\n\n$$2 \\ 1 \\ 0 \\ 3$$\n\nNow $k=1$, and we pick a random $p_1$ between $1$ and $3$, inclusive. Let's say we picked $2$ again. We swap the 1st and 2nd elements, and our permutation becomes:\n\n$$2 \\ 0 \\ 1 \\ 3$$\n\nNow $k=2$, and we pick a random $p_2$ between $2$ and $3$, inclusive. Let's say we picked $3$. We swap the 2nd and 3rd elements, and our permutation becomes:\n\n$$2 \\ 0 \\ 3 \\ 1$$\n\nNow $k=3$, and we pick a random $p_3$ between $3$ and $3$, inclusive. The only choice is $3$. We swap the 3rd and 3rd elements, which means that the permutation doesn't change:\n\n$$2 \\ 0 \\ 3 \\ 1$$\n\nThe process ends now, and this is our random permutation.\n\nThere are many other algorithms that produce a random permutation uniformly. However, there are also many algorithms to generate a random permutation that look very similar to this algorithm, but are not uniform — some permutations are more likely to be produced by those algorithms than others.\n\nHere's one bad algorithm of this type. Take the good algorithm above, but at each step, instead of picking $p_k$ randomly between $k$ and $N-1$, inclusive, let's pick it randomly between $0$ and $N-1$, inclusive. This is such a small change, but now some permutations are more likely to appear than others!\n\nHere's the pseudocode for this algorithm (we'll call it the bad algorithm below):\n\n```\nfor k in 0 .. N-1:\n  a[k] = k\nfor k in 0 .. N-1:\n  p = randint(0 .. N-1)\n  swap(a[k], a[p])\n```\n\nIn each test case, you will be given a permutation that was generated in the following way: first, we choose either the good or the bad algorithm described above, each with probability 50%. Then, we generate a permutation using the chosen algorithm. Can you guess which algorithm was chosen just by looking at the permutation?\n\nThis problem is a bit unusual for Code Jam. You will be given $T = 120$ permutations of $N = 1000$ numbers each, and should print an answer for each permutation – this part is as usual. However, you don't need to get all of the answers correct! Your solution will be considered correct if your answers for at least $G = 109$ cases are correct. However, you must follow the output format, even for cases in which your answer doesn't turn out to be correct. The only thing that can be wrong on any case, yet still allow you to be judged correct, is swapping GOOD for BAD or vice versa; but you should still print either GOOD or BAD for each case.\n\nIt is guaranteed that the permutations given to you were generated according to the method above, and that they were generated independently of each other.\n\nThis problem involves randomness, and thus it might happen that even the best possible solution doesn't make 109 correct guesses for a certain input, as both the good and the bad algorithms can generate any permutation. Because of that, this problem doesn't have a Large input, and has just the Small input which you can try again if you think you got unlucky. Note that there is the usual 4-minute penalty for incorrect submissions if you later solve that input, even if the only reason you got it wrong was chance.\n\nIn our experience with this problem, that did happen (getting wrong answer just because of chance); so if you are confident that your solution should be working, but it failed, it might be a reasonable strategy to try again with the same solution which failed.\n\nGood luck!", "inputFormat": "The first line of the input gives the number of test cases, $T$ (which will always be $120$). Each test case contains two lines: the first line contains the single integer $N$ (which will always be $1000$), and the next line contains $N$ space-separated integers - the permutation that was generated using one of the two algorithms.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is either \"GOOD\" or \"BAD\" (without the quotes). You should output \"GOOD\" if you guess that the permutation was generated by the first algorithm described in the problem statement, and \"BAD\" if you guess that the permutation was generated by the second algorithm described in the problem statement.", "hint": "**Sample Explanation**\n\nThe sample input doesn't follow the limitations from the problem statement - the real input will be much bigger.\n\n**Limits(45 Pts)**\n\n- $T = 120$\n- $G = 109$\n- $N = 1000$\n- Each number in the permutation will be between $0$ and $N-1$ (inclusive), and each number from $0$ to $N-1$ will appear exactly once in the permutation.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 #1A] Proper Shuffle", "background": "", "description": "A permutation of size $N$ is a sequence of $N$ numbers, each between $0$ and $N-1$, where each number appears exactly once. They may appear in any order.\n\nThere are many ($N$ factorial, to be precise, but it doesn't matter in this problem) permutations of size $N$. Sometimes we just want to pick one at random, and of course we want to pick one at random uniformly: each permutation of size $N$ should have the same probability of being chosen.\n\nHere's the pseudocode for one of the possible algorithms to achieve that goal (we'll call it the good algorithm below):\n\n```\nfor k in 0 .. N-1:\n  a[k] = k\nfor k in 0 .. N-1:\n  p = randint(k .. N-1)\n  swap(a[k], a[p])\n```\n\nIn the above code, `randint(a .. b)` returns a uniform random integer between $a$ and $b$, inclusive.\n\nHere's the same algorithm in words. We start with the identity permutation: all numbers from $0$ to $N-1$ written in increasing order. Then, for each $k$ between $0$ and $N-1$, inclusive, we pick an independent uniform random integer $p_k$ between $k$ and $N-1$, inclusive, and swap the element at position $k$ (0-based) in our permutation with the element at position $p_k$.\n\nHere's an example for $N=4$. We start with the identity permutation:\n\n$$0 \\ 1 \\ 2 \\ 3$$\n\nNow $k=0$, and we pick a random $p_0$ between $0$ and $3$, inclusive. Let's say we picked $2$. We swap the 0th and 2nd elements, and our permutation becomes:\n\n$$2 \\ 1 \\ 0 \\ 3$$\n\nNow $k=1$, and we pick a random $p_1$ between $1$ and $3$, inclusive. Let's say we picked $2$ again. We swap the 1st and 2nd elements, and our permutation becomes:\n\n$$2 \\ 0 \\ 1 \\ 3$$\n\nNow $k=2$, and we pick a random $p_2$ between $2$ and $3$, inclusive. Let's say we picked $3$. We swap the 2nd and 3rd elements, and our permutation becomes:\n\n$$2 \\ 0 \\ 3 \\ 1$$\n\nNow $k=3$, and we pick a random $p_3$ between $3$ and $3$, inclusive. The only choice is $3$. We swap the 3rd and 3rd elements, which means that the permutation doesn't change:\n\n$$2 \\ 0 \\ 3 \\ 1$$\n\nThe process ends now, and this is our random permutation.\n\nThere are many other algorithms that produce a random permutation uniformly. However, there are also many algorithms to generate a random permutation that look very similar to this algorithm, but are not uniform — some permutations are more likely to be produced by those algorithms than others.\n\nHere's one bad algorithm of this type. Take the good algorithm above, but at each step, instead of picking $p_k$ randomly between $k$ and $N-1$, inclusive, let's pick it randomly between $0$ and $N-1$, inclusive. This is such a small change, but now some permutations are more likely to appear than others!\n\nHere's the pseudocode for this algorithm (we'll call it the bad algorithm below):\n\n```\nfor k in 0 .. N-1:\n  a[k] = k\nfor k in 0 .. N-1:\n  p = randint(0 .. N-1)\n  swap(a[k], a[p])\n```\n\nIn each test case, you will be given a permutation that was generated in the following way: first, we choose either the good or the bad algorithm described above, each with probability 50%. Then, we generate a permutation using the chosen algorithm. Can you guess which algorithm was chosen just by looking at the permutation?\n\nThis problem is a bit unusual for Code Jam. You will be given $T = 120$ permutations of $N = 1000$ numbers each, and should print an answer for each permutation – this part is as usual. However, you don't need to get all of the answers correct! Your solution will be considered correct if your answers for at least $G = 109$ cases are correct. However, you must follow the output format, even for cases in which your answer doesn't turn out to be correct. The only thing that can be wrong on any case, yet still allow you to be judged correct, is swapping GOOD for BAD or vice versa; but you should still print either GOOD or BAD for each case.\n\nIt is guaranteed that the permutations given to you were generated according to the method above, and that they were generated independently of each other.\n\nThis problem involves randomness, and thus it might happen that even the best possible solution doesn't make 109 correct guesses for a certain input, as both the good and the bad algorithms can generate any permutation. Because of that, this problem doesn't have a Large input, and has just the Small input which you can try again if you think you got unlucky. Note that there is the usual 4-minute penalty for incorrect submissions if you later solve that input, even if the only reason you got it wrong was chance.\n\nIn our experience with this problem, that did happen (getting wrong answer just because of chance); so if you are confident that your solution should be working, but it failed, it might be a reasonable strategy to try again with the same solution which failed.\n\nGood luck!", "inputFormat": "The first line of the input gives the number of test cases, $T$ (which will always be $120$). Each test case contains two lines: the first line contains the single integer $N$ (which will always be $1000$), and the next line contains $N$ space-separated integers - the permutation that was generated using one of the two algorithms.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is either \"GOOD\" or \"BAD\" (without the quotes). You should output \"GOOD\" if you guess that the permutation was generated by the first algorithm described in the problem statement, and \"BAD\" if you guess that the permutation was generated by the second algorithm described in the problem statement.", "hint": "**Sample Explanation**\n\nThe sample input doesn't follow the limitations from the problem statement - the real input will be much bigger.\n\n**Limits(45 Pts)**\n\n- $T = 120$\n- $G = 109$\n- $N = 1000$\n- Each number in the permutation will be between $0$ and $N-1$ (inclusive), and each number from $0$ to $N-1$ will appear exactly once in the permutation.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 #1A] Proper Shuffle", "background": "", "description": "一个大小为 $N$ 的排列是一个长度为 $N$ 的序列，其中每个数字都在 $0$ 到 $N-1$ 之间，且每个数字恰好出现一次。它们可以以任意顺序排列。\n\n一共有很多（准确来说是 $N!$ 个，但在本题中这并不重要）大小为 $N$ 的排列。有时候我们希望**均匀随机**地选出一个排列：即每个排列被选中的概率完全相同。\n\n下面是一个能达到这一目标的算法伪代码（我们在后文称之为 **GOOD** 算法）：\n\n```\nfor k in 0 .. N-1:\n  a[k] = k\nfor k in 0 .. N-1:\n  p = randint(k .. N-1)\n  swap(a[k], a[p])\n```\n\n在上面的代码中，`randint(a .. b)` 表示在 $a$ 到 $b$（包括两端）之间均匀随机地选取一个整数。\n\n用文字描述这个算法：我们从一个初始排列开始，即 $0$ 到 $N-1$ 按升序排列。接着，对于每一个 $k$ 从 $0$ 到 $N-1$，我们在区间 $[k, N-1]$ 中随机选择一个整数 $p_k$，然后交换排列中第 $k$ 个位置（从 $0$ 开始编号）和第 $p_k$ 个位置上的元素。\n\n来看一个 $N=4$ 的例子。初始排列为：\n\n$$0 \\ 1 \\ 2 \\ 3$$\n\n当 $k=0$ 时，我们在 $0$ 到 $3$ 之间随机选择 $p_0$，假设选中 $2$。交换第 $0$ 个和第 $2$ 个元素，排列变为：\n\n$$2 \\ 1 \\ 0 \\ 3$$\n\n接着 $k=1$，在 $1$ 到 $3$ 之间随机选择 $p_1$，假设选中 $2$。交换第 $1$ 个和第 $2$ 个元素，排列变为：\n\n$$2 \\ 0 \\ 1 \\ 3$$\n\n当 $k=2$ 时，在 $2$ 到 $3$ 之间随机选择 $p_2$，假设选中 $3$。交换第 $2$ 个和第 $3$ 个元素，排列变为：\n\n$$2 \\ 0 \\ 3 \\ 1$$\n\n当 $k=3$ 时，只能选 $3$，交换第 $3$ 个和第 $3$ 个元素，排列不变：\n\n$$2 \\ 0 \\ 3 \\ 1$$\n\n至此，生成的随机排列结束。\n\n还有许多其他算法可以生成均匀随机的排列。然而，也存在很多与上面算法看似相似，但并不均匀的算法——这些算法生成某些排列的概率会比其他排列高。\n\n下面给出一个此类「坏」算法（我们在后文称之为 **BAD** 算法）。它与 **GOOD** 算法非常相似，但在每一步中，$p_k$ 不再从 $[k, N-1]$ 区间中选择，而是从 $[0, N-1]$ 区间中随机选择。这看似是一个小改动，但结果是某些排列会更容易被生成！\n\n下面是该算法的伪代码：\n\n```\nfor k in 0 .. N-1:\n  a[k] = k\nfor k in 0 .. N-1:\n  p = randint(0 .. N-1)\n  swap(a[k], a[p])\n```\n\n在每个测试用例中，你会获得一个由以下方式生成的排列：首先，我们以 $50\\%$ 的概率选择 **GOOD** 算法或 **BAD** 算法，然后使用选中的算法生成一个排列。你需要根据给定的排列，猜测它是由哪个算法生成的。\n\n这道题在 Code Jam 中比较特别。你将会得到 $T = 120$ 个大小为 $N = 1000$ 的排列，并需要为每个排列输出一个答案——这部分流程是常规的。然而，你并不需要全部答对！只要你猜对至少 $G = 109$ 个测试用例，整体答案就会被判定为正确。但无论是否正确，你仍需按照格式输出所有答案。如果出错，唯一允许的错误是把 **GOOD** 错猜成 **BAD** 或反之；但是对于每个测试用例，你都必须打印 \"GOOD\" 或 \"BAD\"。\n\n保证给出的每个排列都严格按照上述方法独立生成。\n\n这道题涉及随机性，因此即使是最优策略，也有可能在某次提交中因为概率原因导致答对数不足 $109$ 个而失败。如果发生这种情况，可以再次提交相同的策略尝试，因为每次重新提交可能运气不同。不过注意，若因为错误提交而重新提交，即使仅仅是运气导致错误，也会产生常规的 4 分钟罚时。\n\n在我们的经验中，确实出现过由于概率原因导致答案错误的情况；因此，如果你确信自己的方案正确，但未通过，合理的策略是再次尝试相同方案。\n\n祝你好运！\n", "inputFormat": "输入的第一行是测试用例数 $T$（始终为 $120$）。每个测试用例包含两行：第一行是单个整数 $N$（始终为 $1000$），第二行是 $N$ 个用空格分隔的整数，表示一个由两种算法之一生成的排列。\n", "outputFormat": "对于每个测试用例，输出一行 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是 \"GOOD\" 或 \"BAD\"（不包含引号）。若你猜测该排列由题目中第一个描述的算法（**GOOD** 算法）生成，则输出 \"GOOD\"；否则输出 \"BAD\"。\n", "hint": "**样例说明**\n\n示例输入不符合题面中的大小限制——实际测试输入会更大。\n\n## 限制条件（45 分）\n\n- $T = 120$\n- $G = 109$\n- $N = 1000$\n- 每个排列中的数字都在 $0$ 到 $N-1$ 之间，且 $0$ 到 $N-1$ 每个数字恰好出现一次。\n\n翻译由 ChatGPT-4o 完成。", "locale": "zh-CN"}}}
{"pid": "P13250", "type": "P", "difficulty": 3, "samples": [["5\n2\nmmaw\nmaw\n2\ngcj\ncj\n3\naaabbb\nab\naabb\n2\nabc\nabc\n3\naabc\nabbc\nabcc", "Case #1: 1\nCase #2: Fegla Won\nCase #3: 4\nCase #4: 0\nCase #5: 3"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["字符串", "贪心", "2014", "Google Code Jam"], "title": "[GCJ 2014 #1B] The Repeater", "background": "", "description": "Fegla and Omar like to play games every day. But now they are bored of all games, and they would like to play a new game. So they decided to invent their own game called \"The Repeater\".\n\nThey invented a $2$ player game. Fegla writes down $N$ strings. Omar's task is to make all the strings identical, if possible, using the minimum number of actions (possibly $0$ actions) of the following two types:\n\n- Select any character in any of the strings and repeat it (add another instance of this character exactly after it). For example, in a single move Omar can change \"abc\" to \"abbc\" (by repeating the character 'b').\n- Select any two adjacent and identical characters in any of the strings, and delete one of them. For example, in a single move Omar can change \"abbc\" to \"abc\" (delete one of the 'b' characters), but can't convert it to \"bbc\".\n\nThe $2$ actions are independent; it's not necessary that an action of the first type should be followed by an action of the second type (or vice versa).\n\nHelp Omar to win this game by writing a program to find if it is possible to make the given strings identical, and to find the minimum number of moves if it is possible.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line containing an integer $N$ which is the number of strings. Followed by $N$ lines, each line contains a non-empty string (each string will consist of lower case English characters only, from 'a' to 'z').", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is the minimum number of moves to make the strings identical. If there is no possible way to make all strings identical, print \"Fegla Won\" (quotes for clarity).", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq \\text{length of each string} \\leq 100$.\n\n**Small dataset(10 Pts)**\n\n- Time limit: $60$ seconds.\n- $N = 2$.\n\n**Large dataset(13 Pts)**\n\n- Time limit: $120$ seconds.\n- $2 \\leq N \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 #1B] The Repeater", "background": "", "description": "Fegla and Omar like to play games every day. But now they are bored of all games, and they would like to play a new game. So they decided to invent their own game called \"The Repeater\".\n\nThey invented a $2$ player game. Fegla writes down $N$ strings. Omar's task is to make all the strings identical, if possible, using the minimum number of actions (possibly $0$ actions) of the following two types:\n\n- Select any character in any of the strings and repeat it (add another instance of this character exactly after it). For example, in a single move Omar can change \"abc\" to \"abbc\" (by repeating the character 'b').\n- Select any two adjacent and identical characters in any of the strings, and delete one of them. For example, in a single move Omar can change \"abbc\" to \"abc\" (delete one of the 'b' characters), but can't convert it to \"bbc\".\n\nThe $2$ actions are independent; it's not necessary that an action of the first type should be followed by an action of the second type (or vice versa).\n\nHelp Omar to win this game by writing a program to find if it is possible to make the given strings identical, and to find the minimum number of moves if it is possible.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line containing an integer $N$ which is the number of strings. Followed by $N$ lines, each line contains a non-empty string (each string will consist of lower case English characters only, from 'a' to 'z').", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is the minimum number of moves to make the strings identical. If there is no possible way to make all strings identical, print \"Fegla Won\" (quotes for clarity).", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq \\text{length of each string} \\leq 100$.\n\n**Small dataset(10 Pts)**\n\n- Time limit: $60$ seconds.\n- $N = 2$.\n\n**Large dataset(13 Pts)**\n\n- Time limit: $120$ seconds.\n- $2 \\leq N \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 #1B] The Repeater", "background": "", "description": "Fegla 和 Omar 每天都喜欢玩游戏。但现在他们已经玩腻了所有的游戏，于是决定自己发明一个新游戏，叫作 **\"The Repeater\"**（重复者）。\n\n这是一个两人游戏。Fegla 写下 $N$ 个字符串，Omar 的任务是**将所有字符串变得完全相同**（如果可能），并且在此过程中所使用的操作次数要尽量少（也可以为 $0$ 次）。允许的操作有以下两种：\n\n- 从任意一个字符串中，**选择一个字符，并重复它一次**（即在它后面再加上一个相同的字符）。例如，Omar 可以用一次操作把 `\"abc\"` 变成 `\"abbc\"`（重复字符 `'b'`）。\n- 从任意一个字符串中，**选择两个相邻且相同的字符，并删除其中一个**。例如，Omar 可以用一次操作将 `\"abbc\"` 变成 `\"abc\"`（删除一个 `'b'`），但不能将其变成 `\"bbc\"`。\n\n这两种操作是独立的，没有顺序要求，既不需要操作一之后紧跟操作二，也不要求操作二只能跟在操作一之后。\n\n你的任务是帮助 Omar 胜利：判断是否有可能将这 $N$ 个字符串通过若干次操作变得完全一样；如果可以，求出最少的操作次数。\n", "inputFormat": "输入的第一行是测试用例的数量 $T$。接下来的 $T$ 个测试用例中，每个测试用例以一行整数 $N$ 开始，表示字符串的数量。之后的 $N$ 行，每行包含一个非空字符串（所有字符串只由小写英文字母 `'a'` 到 `'z'` 组成）。\n", "outputFormat": "对于每个测试用例，输出一行 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是使所有字符串相同所需的最小操作次数。如果无法将所有字符串变得相同，则输出 `\"Fegla Won\"`（不含引号）。\n", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 100$\n- 每个字符串的长度不超过 $100$\n\n**小数据集（10 分）**\n\n- 时间限制：$60$ 秒\n- $N = 2$\n\n**大数据集（13 分）**\n\n- 时间限制：$120$ 秒\n- $2 \\leq N \\leq 100$\n\n翻译由 ChatGPT-4o 完成。", "locale": "zh-CN"}}}
{"pid": "P13251", "type": "P", "difficulty": 5, "samples": [["5\n3 4 2\n4 5 2\n7 8 5\n45 56 35\n103 143 88", "Case #1: 10\nCase #2: 16\nCase #3: 52\nCase #4: 2411\nCase #5: 14377"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["2014", "分治", "记忆化搜索", "数位 DP", "位运算", "Google Code Jam"], "title": "[GCJ 2014 #1B] New Lottery Game", "background": "", "description": "The Lottery is changing! The Lottery used to have a machine to generate a random winning number. But due to cheating problems, the Lottery has decided to add another machine. The new winning number will be the result of the bitwise-AND operation between the two random numbers generated by the two machines.\n\nTo find the bitwise-AND of $X$ and $Y$, write them both in binary; then a bit in the result in binary has a $1$ if the corresponding bits of $X$ and $Y$ were both $1$, and a $0$ otherwise. In most programming languages, the bitwise-AND of $X$ and $Y$ is written $X \\& Y$.\n\nFor example:\n- The old machine generates the number $7 = 0111$.\n- The new machine generates the number $11 = 1011$.\n- The winning number will be $(7 \\text{ AND } 11) = (0111 \\text{ AND } 1011) = 0011 = 3$.\n\nWith this measure, the Lottery expects to reduce the cases of fraudulent claims, but unfortunately an employee from the Lottery company has leaked the following information: the old machine will always generate a non-negative integer less than $A$ and the new one will always generate a non-negative integer less than $B$.\n\nCatalina wants to win this lottery and to give it a try she decided to buy all non-negative integers less than $K$.\n\nGiven $A$, $B$ and $K$, Catalina would like to know in how many different ways the machines can generate a pair of numbers that will make her a winner.\n\nCould you help her?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow, each line with three numbers $A$ $B$ $K$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is the number of possible pairs that the machines can generate to make Catalina a winner.", "hint": "**Sample Explanation**\n\nIn the first test case, these are the 10 possible pairs generated by the old and new machine respectively that will make her a winner: $\\langle 0,0\\rangle, \\langle 0,1\\rangle, \\langle 0,2\\rangle, \\langle 0,3\\rangle, \\langle 1,0\\rangle$, $\\langle 1,1\\rangle, \\langle 1,2\\rangle, \\langle 1,3\\rangle, \\langle 2,0\\rangle$ and $\\langle 2,1\\rangle$. Notice that $\\langle 0,1\\rangle$ is not the same as $\\langle 1,0\\rangle$. Also, although the pair $\\langle 2, 2\\rangle$ could be generated by the machines it wouldn't make Catalina win since $(2 \\text{ AND } 2) = 2$ and she only bought the numbers $0$ and $1$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Small dataset(8 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq A \\leq 1000$.\n- $1 \\leq B \\leq 1000$.\n- $1 \\leq K \\leq 1000$.\n\n**Large dataset(24 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq A \\leq 10^9$.\n- $1 \\leq B \\leq 10^9$.\n- $1 \\leq K \\leq 10^9$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 #1B] New Lottery Game", "background": "", "description": "The Lottery is changing! The Lottery used to have a machine to generate a random winning number. But due to cheating problems, the Lottery has decided to add another machine. The new winning number will be the result of the bitwise-AND operation between the two random numbers generated by the two machines.\n\nTo find the bitwise-AND of $X$ and $Y$, write them both in binary; then a bit in the result in binary has a $1$ if the corresponding bits of $X$ and $Y$ were both $1$, and a $0$ otherwise. In most programming languages, the bitwise-AND of $X$ and $Y$ is written $X \\& Y$.\n\nFor example:\n- The old machine generates the number $7 = 0111$.\n- The new machine generates the number $11 = 1011$.\n- The winning number will be $(7 \\text{ AND } 11) = (0111 \\text{ AND } 1011) = 0011 = 3$.\n\nWith this measure, the Lottery expects to reduce the cases of fraudulent claims, but unfortunately an employee from the Lottery company has leaked the following information: the old machine will always generate a non-negative integer less than $A$ and the new one will always generate a non-negative integer less than $B$.\n\nCatalina wants to win this lottery and to give it a try she decided to buy all non-negative integers less than $K$.\n\nGiven $A$, $B$ and $K$, Catalina would like to know in how many different ways the machines can generate a pair of numbers that will make her a winner.\n\nCould you help her?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow, each line with three numbers $A$ $B$ $K$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is the number of possible pairs that the machines can generate to make Catalina a winner.", "hint": "**Sample Explanation**\n\nIn the first test case, these are the 10 possible pairs generated by the old and new machine respectively that will make her a winner: $\\langle 0,0\\rangle, \\langle 0,1\\rangle, \\langle 0,2\\rangle, \\langle 0,3\\rangle, \\langle 1,0\\rangle$, $\\langle 1,1\\rangle, \\langle 1,2\\rangle, \\langle 1,3\\rangle, \\langle 2,0\\rangle$ and $\\langle 2,1\\rangle$. Notice that $\\langle 0,1\\rangle$ is not the same as $\\langle 1,0\\rangle$. Also, although the pair $\\langle 2, 2\\rangle$ could be generated by the machines it wouldn't make Catalina win since $(2 \\text{ AND } 2) = 2$ and she only bought the numbers $0$ and $1$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Small dataset(8 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq A \\leq 1000$.\n- $1 \\leq B \\leq 1000$.\n- $1 \\leq K \\leq 1000$.\n\n**Large dataset(24 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq A \\leq 10^9$.\n- $1 \\leq B \\leq 10^9$.\n- $1 \\leq K \\leq 10^9$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 #1B] New Lottery Game", "background": "", "description": "彩票系统正在改革！过去的彩票系统使用一台机器生成一个随机中奖号码。但由于作弊问题频发，如今彩票系统决定增加第二台机器。新的中奖号码将由这两台机器各自生成的随机数，进行按位与（bitwise AND）运算后得到。\n\n要计算 $X$ 和 $Y$ 的按位与操作，将它们都转换为二进制表示；结果中每一位是 $1$ 的前提是，$X$ 和 $Y$ 的对应位都为 $1$，否则为 $0$。在大多数编程语言中，$X$ 和 $Y$ 的按位与操作写作 $X \\& Y$。\n\n例如：\n\n- 旧机器生成的数字是 $7 = 0111$；\n- 新机器生成的数字是 $11 = 1011$；\n- 则中奖号码为 $(7 \\text{ AND } 11) = (0111 \\text{ AND } 1011) = 0011 = 3$。\n\n通过这一改革，彩票公司期望能够减少虚假兑奖的情况。但不幸的是，该公司的一名员工泄露了以下信息：旧机器生成的随机数始终小于 $A$，而新机器生成的随机数始终小于 $B$。\n\nCatalina 想赢得这次彩票。她打算购买所有小于 $K$ 的非负整数。\n\n现在，给定 $A$、$B$ 和 $K$，Catalina 想知道共有多少种不同的方式，两台机器生成的数对能够使她中奖。\n\n你能帮助她计算出这个数量吗？", "inputFormat": "输入的第一行是测试用例的数量 $T$。接下来 $T$ 行，每行包含三个整数 $A$、$B$ 和 $K$。\n", "outputFormat": "对于每个测试用例，输出一行 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是两台机器能生成使 Catalina 获胜的数对总数。\n", "hint": "**样例解释**\n\n以第一个测试用例为例，以下是可能由两台机器生成的、使 Catalina 获胜的 10 个数对（分别由旧机器和新机器生成）：\n\n$\\langle 0,0\\rangle,\\ \\langle 0,1\\rangle,\\ \\langle 0,2\\rangle,\\ \\langle 0,3\\rangle,\\ \\langle 1,0\\rangle,$  \n$\\langle 1,1\\rangle,\\ \\langle 1,2\\rangle,\\ \\langle 1,3\\rangle,\\ \\langle 2,0\\rangle,\\ \\langle 2,1\\rangle$\n\n请注意，$\\langle 0,1\\rangle$ 与 $\\langle 1,0\\rangle$ 是不同的数对。\n\n另外，虽然机器可能生成 $\\langle 2,2\\rangle$，但该数对不会使 Catalina 获胜，因为 $(2 \\text{ AND } 2) = 2$，而她只购买了 $0$ 和 $1$。\n\n## 限制条件\n\n- $1 \\leq T \\leq 100$\n\n**小数据集（8 分）**\n\n- 时间限制：~~60~~ 3 秒 \n- $1 \\leq A \\leq 1000$\n- $1 \\leq B \\leq 1000$\n- $1 \\leq K \\leq 1000$\n\n**大数据集（24 分）**\n\n- 时间限制：~~120~~ 5 秒\n- $1 \\leq A \\leq 10^9$\n- $1 \\leq B \\leq 10^9$\n- $1 \\leq K \\leq 10^9$\n\n翻译由 ChatGPT-4o 完成。", "locale": "zh-CN"}}}
{"pid": "P13252", "type": "P", "difficulty": 6, "samples": [["4\n3 2\n10001\n20000\n10000\n1 2\n2 3\n5 4\n36642\n28444\n50012\n29651\n10953\n1 4\n2 3\n2 5\n4 5\n5 5\n36642\n28444\n50012\n29651\n10953\n1 2\n1 4\n2 3\n2 5\n4 5\n6 6\n10001\n10002\n10003\n10004\n10005\n10006\n1 2\n1 6\n2 3\n2 4\n3 5\n4 5", "Case #1: 100002000010001\nCase #2: 1095328444500122965136642\nCase #3: 1095328444366422965150012\nCase #4: 100011000210003100041000510006"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["图论", "贪心", "2014", "Google Code Jam"], "title": "[GCJ 2014 #1B] The Bored Traveling Salesman", "background": "", "description": "Your boss is sending you out on an international sales trip. What joy!\n\nYou have $N$ cities (numbered from $1$ to $N$) to visit and can get to them using a set of bidirectional flights that go between the cities.\n\nAll of the cities must be visited at least once. To do this you can book any number of tickets, subject to the following conditions:\n\n* Each ticket consists of $2$ flights, one from a specific city $X$ to another specific city $Y$ (this is called the **outbound** flight), and the other one from city $Y$ to city $X$ (this is called the **return** flight).\n* You must use the outbound flight before the corresponding return flight (you can use other flights in between).\n* At most $1$ outbound flight going to each city, although there is no limit on the return flights (multiple return flights can go to the same city).\n* You must use all flights which belong to the tickets you booked.\n* You can otherwise visit the cities in any order you like.\n* You can start your trip from any city you choose. You may not take an outbound flight to your starting city.\n\nNow you could try to minimize the total distance travelled, but you did that last time, so that would be boring. Instead you noticed that each city has a distinct $5$ digit ZIP (postal) code. When you visit a city for the first time (this includes the city which you start from) you write down the zip code and concatenate these into one large number (concatenate them in the order which you visited each city for the first time). What is the smallest number you can achieve?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow.\n\nEach test case starts with a single line containing two integers: the number of cities $N$ and the number of possible bidirectional flights $M$.\n\n$N$ lines then follow, with the $i$-th line containing the $5$-digit zip code of the $i$-th city. No ZIP code will have leading zeros and all ZIP codes in each test case will be distinct.\n\n$M$ lines then follow, each containing two integers $i$ and $j$ ($1 \\leq i < j \\leq N$) indicating that a bidirectional flight exists between the $i$-th city and the $j$-th city. All flights will be distinct within each test case.\n\nIt is guaranteed that you can visit every city following the rules above.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is the smallest number you can achieve by concatenating the ZIP codes along your trip.", "hint": "**Sample Explanation**\n\nIn the last sample test case, the following is the sequence of what you should do to achieve the smallest number:\n\n1. Start from city $1$, write $10001$.\n2. Outbound flight from $1$ to $2$, write $10002$.\n3. Outbound flight from $2$ to $3$, write $10003$.\n4. Return flight from $3$ to $2$.\n5. Outbound flight from $2$ to $4$, write $10004$.\n6. Outbound flight from $4$ to $5$, write $10005$.\n7. Return flight from $5$ to $4$.\n8. Return flight from $4$ to $2$.\n9. Return flight from $2$ to $1$.\n10. Outbound flight from $1$ to $6$, write $10006$.\n11. Return flight from $6$ to $1$.\n\n**Limits**\n\n- $1 \\leq \\text{T} \\leq 100$.\n- $0 \\leq \\text{M} \\leq \\text{N} \\times (\\text{N} - 1) / 2$.\n\n**Small dataset(15 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq \\text{N} \\leq 8$.\n\n**Large dataset(30 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq \\text{N} \\leq 50$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 #1B] The Bored Traveling Salesman", "background": "", "description": "Your boss is sending you out on an international sales trip. What joy!\n\nYou have $N$ cities (numbered from $1$ to $N$) to visit and can get to them using a set of bidirectional flights that go between the cities.\n\nAll of the cities must be visited at least once. To do this you can book any number of tickets, subject to the following conditions:\n\n* Each ticket consists of $2$ flights, one from a specific city $X$ to another specific city $Y$ (this is called the **outbound** flight), and the other one from city $Y$ to city $X$ (this is called the **return** flight).\n* You must use the outbound flight before the corresponding return flight (you can use other flights in between).\n* At most $1$ outbound flight going to each city, although there is no limit on the return flights (multiple return flights can go to the same city).\n* You must use all flights which belong to the tickets you booked.\n* You can otherwise visit the cities in any order you like.\n* You can start your trip from any city you choose. You may not take an outbound flight to your starting city.\n\nNow you could try to minimize the total distance travelled, but you did that last time, so that would be boring. Instead you noticed that each city has a distinct $5$ digit ZIP (postal) code. When you visit a city for the first time (this includes the city which you start from) you write down the zip code and concatenate these into one large number (concatenate them in the order which you visited each city for the first time). What is the smallest number you can achieve?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow.\n\nEach test case starts with a single line containing two integers: the number of cities $N$ and the number of possible bidirectional flights $M$.\n\n$N$ lines then follow, with the $i$-th line containing the $5$-digit zip code of the $i$-th city. No ZIP code will have leading zeros and all ZIP codes in each test case will be distinct.\n\n$M$ lines then follow, each containing two integers $i$ and $j$ ($1 \\leq i < j \\leq N$) indicating that a bidirectional flight exists between the $i$-th city and the $j$-th city. All flights will be distinct within each test case.\n\nIt is guaranteed that you can visit every city following the rules above.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from $1$) and $y$ is the smallest number you can achieve by concatenating the ZIP codes along your trip.", "hint": "**Sample Explanation**\n\nIn the last sample test case, the following is the sequence of what you should do to achieve the smallest number:\n\n1. Start from city $1$, write $10001$.\n2. Outbound flight from $1$ to $2$, write $10002$.\n3. Outbound flight from $2$ to $3$, write $10003$.\n4. Return flight from $3$ to $2$.\n5. Outbound flight from $2$ to $4$, write $10004$.\n6. Outbound flight from $4$ to $5$, write $10005$.\n7. Return flight from $5$ to $4$.\n8. Return flight from $4$ to $2$.\n9. Return flight from $2$ to $1$.\n10. Outbound flight from $1$ to $6$, write $10006$.\n11. Return flight from $6$ to $1$.\n\n**Limits**\n\n- $1 \\leq \\text{T} \\leq 100$.\n- $0 \\leq \\text{M} \\leq \\text{N} \\times (\\text{N} - 1) / 2$.\n\n**Small dataset(15 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq \\text{N} \\leq 8$.\n\n**Large dataset(30 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq \\text{N} \\leq 50$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 #1B] The Bored Traveling Salesman", "background": null, "description": "你的老板派你出差去进行国际销售。多么令人激动的事情啊！\n\n你需要拜访 $N$ 座城市（编号从 $1$ 到 $N$），这些城市之间有若干双向航班可供选择。\n\n你必须至少访问每座城市一次。为此，你可以预订任意数量的机票，但需要满足以下规则：\n\n- 每张机票包含两段航班：一段是从某个特定城市 $X$ 飞往另一个特定城市 $Y$（称为**去程航班**），另一段是从城市 $Y$ 返回城市 $X$（称为**返程航班**）。\n- 你必须先使用某张机票的去程航班，之后才能使用其返程航班（中间可以穿插其他航班）。\n- 每个城市最多只能作为去程航班的目的地一次，但返程航班的目的地没有限制（同一城市可以接收多个返程航班）。\n- 所有你购买的机票中的航班必须全部使用。\n- 除此之外，你可以按任意顺序访问城市。\n- 你可以从任意一座城市开始旅程。但注意，不能乘坐任何一张机票的去程航班抵达起始城市。\n\n这一次你不再尝试最小化旅行总距离，那太无聊了。相反，你注意到每座城市都有一个独特的 $5$ 位数邮政编码（ZIP code）。你会在**首次访问某座城市**时（包括起始城市）将其 ZIP code 记录下来，并按访问顺序将这些 ZIP code 串接成一个大数字。\n\n你的目标是：通过选择航线和访问顺序，使这个最终拼接出的数字尽可能小。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来是 $T$ 个测试用例。\n\n每个测试用例的第一行包含两个整数：城市数 $N$ 和可用的双向航班数 $M$。\n\n接下来的 $N$ 行，第 $i$ 行是第 $i$ 个城市的 $5$ 位邮政编码。所有 ZIP code 在每个测试用例中均不重复，且不会有前导零。\n\n接下来 $M$ 行，每行包含两个整数 $i$ 和 $j$（$1 \\leq i < j \\leq N$），表示存在一条从城市 $i$ 到城市 $j$ 的双向航班。每个测试用例中的所有航班均不重复。\n\n保证在遵守规则的前提下，你可以访问到所有城市。", "outputFormat": "对于每个测试用例，输出一行 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是你能通过合理选择航线与访问顺序拼接出的最小数字。", "hint": "**样例说明**\n\n以最后一个测试用例为例，以下是使最终拼接数字最小的一种访问顺序与航线选择方式：\n\n1. 从城市 $1$ 出发，记录 $10001$。\n2. 乘坐从 $1$ 到 $2$ 的去程航班，记录 $10002$。\n3. 乘坐从 $2$ 到 $3$ 的去程航班，记录 $10003$。\n4. 乘坐从 $3$ 返回 $2$ 的返程航班。\n5. 乘坐从 $2$ 到 $4$ 的去程航班，记录 $10004$。\n6. 乘坐从 $4$ 到 $5$ 的去程航班，记录 $10005$。\n7. 乘坐从 $5$ 返回 $4$ 的返程航班。\n8. 乘坐从 $4$ 返回 $2$ 的返程航班。\n9. 乘坐从 $2$ 返回 $1$ 的返程航班。\n10. 乘坐从 $1$ 到 $6$ 的去程航班，记录 $10006$。\n11. 乘坐从 $6$ 返回 $1$ 的返程航班。\n\n## 限制条件\n\n- $1 \\leq T \\leq 100$\n\n- $0\\le M\\le \\frac{N\\times(N-1)}{2}$\n\n### Small 数据集（15 分）\n\n- 时间限制：~~60~~ 3 秒\n- $1 \\leq N \\leq 8$\n\n### Large 数据集（30 分）\n\n- 时间限制：~~120~~ 5 秒\n- $1 \\leq N \\leq 50$\n\n翻译由 ChatGPT-4o 完成。", "locale": "zh-CN"}}}
{"pid": "P13253", "type": "P", "difficulty": 3, "samples": [["5\n1/2\n3/4\n1/4\n2/23\n123/31488", "Case #1: 1\nCase #2: 1\nCase #3: 2\nCase #4: impossible\nCase #5: 8"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "2014", "数论", "Google Code Jam"], "title": "[GCJ 2014 #1C] Part Elf", "background": "", "description": "Vida says she's part Elf: that at least one of her ancestors was an Elf. But she doesn't know if it was a parent (1 generation ago), a grandparent (2 generations ago), or someone from even more generations ago. Help her out!\n\nBeing part Elf works the way you probably expect. People who are Elves, Humans and part-Elves are all created in the same way: two parents get together and have a baby. If one parent is $\\frac{A}{B}$ Elf, and the other parent is $\\frac{C}{D}$ Elf, then their baby will be $\\frac{(A/B + C/D)}{2}$ Elf. For example, if someone who is $\\frac{0}{1}$ Elf and someone who is $\\frac{1}{2}$ Elf have a baby, that baby will be $\\frac{1}{4}$ Elf.\n\nVida is certain about one thing: 40 generations ago, she had $2^{40}$ different ancestors, and each one of them was $\\frac{1}{1}$ Elf or $\\frac{0}{1}$ Elf.\n\nVida says she's $\\frac{P}{Q}$ Elf. Tell her what is the minimum number of generations ago that there could have been a $\\frac{1}{1}$ Elf in her family. If it is not possible for her to be $\\frac{P}{Q}$ Elf, tell her that she must be wrong!", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each contains a fraction of the form $\\frac{P}{Q}$, where $P$ and $Q$ are integers.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from 1) and $y$ is the minimum number of generations ago a $\\frac{1}{1}$ Elf in her family could have been if she is $\\frac{P}{Q}$ Elf. If it's impossible that Vida could be $\\frac{P}{Q}$ Elf, $y$ should be the string \"impossible\" (without the quotes).", "hint": "Note that the fifth sample case does not meet the limits for the Small input. Even if you don't solve it correctly, you might still have solved the Small input correctly.\n\n**Explanation of sample cases**\n\nIn the first sample case, Vida could have a $\\frac{1}{1}$ Elf parent and a $\\frac{0}{1}$ Elf parent. That means she could have had a $\\frac{1}{1}$ Elf one generation ago, so the answer is $1$.\n\nIn the second sample case, Vida could have had a $\\frac{1}{1}$ Elf parent and a $\\frac{1}{2}$ Elf parent. That means she could have had a $\\frac{1}{1}$ Elf one generation ago, so the answer is $1$.\n\nIn the third sample case, Vida could have had a $\\frac{0}{1}$ Elf parent and a $\\frac{1}{2}$ Elf parent. The $\\frac{1}{2}$ Elf parent could have had a $\\frac{1}{1}$ Elf parent and a $\\frac{0}{1}$ Elf parent. That means she could have had a $\\frac{1}{1}$ Elf two generations ago, so the answer is $2$.\n\nIn the fourth sample case, it's impossible to be exactly $\\frac{2}{23}$ Elf if your ancestors 40 generations ago were all $\\frac{0}{1}$ Elf or $\\frac{1}{1}$ Elf.\n\n**Note**\n\nYes, Vida has a lot of ancestors. If that is the part of the problem that seems the most unrealistic to you, please re-read the part about Elves.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Small dataset(8 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq P < Q \\leq 1000$.\n- $P$ and $Q$ have no common factors. That means $P/Q$ is a fraction in lowest terms.\n\n**Large dataset(12 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq P < Q \\leq 10^{12}$.\n- $P$ and $Q$ may have common factors. $P/Q$ is not guaranteed to be a fraction in lowest terms.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 #1C] Part Elf", "background": "", "description": "Vida says she's part Elf: that at least one of her ancestors was an Elf. But she doesn't know if it was a parent (1 generation ago), a grandparent (2 generations ago), or someone from even more generations ago. Help her out!\n\nBeing part Elf works the way you probably expect. People who are Elves, Humans and part-Elves are all created in the same way: two parents get together and have a baby. If one parent is $\\frac{A}{B}$ Elf, and the other parent is $\\frac{C}{D}$ Elf, then their baby will be $\\frac{(A/B + C/D)}{2}$ Elf. For example, if someone who is $\\frac{0}{1}$ Elf and someone who is $\\frac{1}{2}$ Elf have a baby, that baby will be $\\frac{1}{4}$ Elf.\n\nVida is certain about one thing: 40 generations ago, she had $2^{40}$ different ancestors, and each one of them was $\\frac{1}{1}$ Elf or $\\frac{0}{1}$ Elf.\n\nVida says she's $\\frac{P}{Q}$ Elf. Tell her what is the minimum number of generations ago that there could have been a $\\frac{1}{1}$ Elf in her family. If it is not possible for her to be $\\frac{P}{Q}$ Elf, tell her that she must be wrong!", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each contains a fraction of the form $\\frac{P}{Q}$, where $P$ and $Q$ are integers.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the test case number (starting from 1) and $y$ is the minimum number of generations ago a $\\frac{1}{1}$ Elf in her family could have been if she is $\\frac{P}{Q}$ Elf. If it's impossible that Vida could be $\\frac{P}{Q}$ Elf, $y$ should be the string \"impossible\" (without the quotes).", "hint": "Note that the fifth sample case does not meet the limits for the Small input. Even if you don't solve it correctly, you might still have solved the Small input correctly.\n\n**Explanation of sample cases**\n\nIn the first sample case, Vida could have a $\\frac{1}{1}$ Elf parent and a $\\frac{0}{1}$ Elf parent. That means she could have had a $\\frac{1}{1}$ Elf one generation ago, so the answer is $1$.\n\nIn the second sample case, Vida could have had a $\\frac{1}{1}$ Elf parent and a $\\frac{1}{2}$ Elf parent. That means she could have had a $\\frac{1}{1}$ Elf one generation ago, so the answer is $1$.\n\nIn the third sample case, Vida could have had a $\\frac{0}{1}$ Elf parent and a $\\frac{1}{2}$ Elf parent. The $\\frac{1}{2}$ Elf parent could have had a $\\frac{1}{1}$ Elf parent and a $\\frac{0}{1}$ Elf parent. That means she could have had a $\\frac{1}{1}$ Elf two generations ago, so the answer is $2$.\n\nIn the fourth sample case, it's impossible to be exactly $\\frac{2}{23}$ Elf if your ancestors 40 generations ago were all $\\frac{0}{1}$ Elf or $\\frac{1}{1}$ Elf.\n\n**Note**\n\nYes, Vida has a lot of ancestors. If that is the part of the problem that seems the most unrealistic to you, please re-read the part about Elves.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Small dataset(8 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq P < Q \\leq 1000$.\n- $P$ and $Q$ have no common factors. That means $P/Q$ is a fraction in lowest terms.\n\n**Large dataset(12 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq P < Q \\leq 10^{12}$.\n- $P$ and $Q$ may have common factors. $P/Q$ is not guaranteed to be a fraction in lowest terms.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 #1C] Part Elf", "background": "", "description": "Vida 说她是半精灵：她的祖先中至少有一个是精灵。但她不知道这个精灵是她的父母（1 代之前）、祖父母（2 代之前），还是更久远的祖先。帮她找找看吧！\n\n成为半精灵的方式大致与你想象的一样。精灵、人类以及半精灵的孩子都是通过两个父母结合而诞生的。如果一位父母的精灵血统是 $\\frac{A}{B}$，另一位是 $\\frac{C}{D}$，那么他们的孩子的精灵血统将是 $\\frac{(A/B + C/D)}{2}$。例如，如果一个精灵血统是 $\\frac{0}{1}$ 的人与一个精灵血统是 $\\frac{1}{2}$ 的人生了孩子，那么这个孩子的精灵血统将是 $\\frac{1}{4}$。\n\nVida 确信一点：在 40 代之前，她有 $2^{40}$ 位不同的祖先，而且每一位的精灵血统都是 $\\frac{1}{1}$ 或 $\\frac{0}{1}$。\n\nVida 说她的精灵血统是 $\\frac{P}{Q}$。请告诉她，若她的精灵血统真的是 $\\frac{P}{Q}$，那么她家族中最少多少代之前可能出现过一位 $\\frac{1}{1}$ 的纯精灵祖先。如果不可能拥有精确为 $\\frac{P}{Q}$ 的精灵血统，请告诉她这是不可能的！\n", "inputFormat": "输入的第一行是测试用例数量 $T$。接下来的 $T$ 行中，每行包含一个分数，格式为 $\\frac{P}{Q}$，其中 $P$ 和 $Q$ 均为整数。\n", "outputFormat": "对于每个测试用例，输出一行，格式为 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 Vida 家族中最少多少代之前可能出现过一位 $\\frac{1}{1}$ 的纯精灵祖先。如果 Vida 不可能拥有 $\\frac{P}{Q}$ 的精灵血统，则 $y$ 应为字符串 `\"impossible\"`（不带引号）。\n", "hint": "请注意，第五个样例数据并不满足 Small 数据集的限制。即使你未能正确解出它，也可能已经正确解决了 Small 数据集。\n\n**样例解释**\n\n在第一个样例中，Vida 可以拥有一位 $\\frac{1}{1}$ 的父母和一位 $\\frac{0}{1}$ 的父母。也就是说，她的家族中 1 代之前就可能有一位纯精灵祖先，因此答案是 $1$。\n\n在第二个样例中，Vida 的父母可以是一个 $\\frac{1}{1}$ 的精灵和一个 $\\frac{1}{2}$ 的精灵。那么她的家族中也可以在 1 代之前出现纯精灵祖先，因此答案是 $1$。\n\n在第三个样例中，Vida 的父母可以是一个 $\\frac{0}{1}$ 的人类和一个 $\\frac{1}{2}$ 的精灵。而这个 $\\frac{1}{2}$ 的精灵父母可以是一个 $\\frac{1}{1}$ 的精灵和一个 $\\frac{0}{1}$ 的人类。那么家族中可能在 2 代之前出现纯精灵祖先，因此答案是 $2$。\n\n在第四个样例中，如果你的 40 代祖先都只可能是 $\\frac{0}{1}$ 或 $\\frac{1}{1}$ 的精灵，那么精确拥有 $\\frac{2}{23}$ 的精灵血统是不可能的。\n\n**注意**\n\n是的，Vida 的祖先非常之多。如果你觉得这个设定最不现实，请重新阅读有关精灵的部分。\n\n## 限制条件\n\n- $1 \\leq T \\leq 100$。\n\n### Small 数据集（8 分）\n\n- 时间限制：~~60~~ 3 秒。\n- $1 \\leq P < Q \\leq 1000$。\n- $P$ 与 $Q$ 互质，即 $\\frac{P}{Q}$ 是最简分数。\n\n### Large 数据集（12 分）\n\n- 时间限制：~~120~~ 5 秒。\n- $1 \\leq P < Q \\leq 10^{12}$。\n- $P$ 与 $Q$ 不一定互质，即 $\\frac{P}{Q}$ 不一定是最简分数。\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P13254", "type": "P", "difficulty": 4, "samples": [["3\n3\nab bbbc cd\n4\naa aa bc c\n2\nabc bcd", "Case #1: 1\nCase #2: 4\nCase #3: 0"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["2014", "组合数学", "Google Code Jam"], "title": "[GCJ 2014 #1C] Reordering Train Cars", "background": "", "description": "Yahya is a brilliant kid, so his mind raises a lot of interesting questions when he plays with his toys. Today's problem came about when his father brought him a set of $\\text{train cars}$, where each car has a lowercase letter written on one side of the car.\n\nWhen he first saw the gift, he was happy and started playing with them, connecting cars together without any particular goal. But after a while he got bored (as usual) from playing without having any goal. So, he decided to define a new interesting problem.\n\nThe problem is that he currently has $N$ sets of connected cars. He can represent each set of connected cars as a string of lowercase letters. He wants to count the number of ways he can connect all $N$ sets of cars to form one valid train. A train is valid if all occurrences of the same character are adjacent to each other.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y5i5dzbq.png)\n\nThe previous figure is one way Yahya could connect the cars \"ab\", \"bc\" and \"cd\" to make a valid train: \"ab bc cd\". If he had connected them in the order \"cd ab bc\", that would have been invalid: the \"c\" characters would not have been adjacent to each other.\n\nYou've surely noticed that this is not an easy problem for Yahya to solve, so he needs your help (and he is sure that you will give it!). That's it; go and help Yahya!\n\n**Note:** letters are written only on one side of the cars, so you can not reverse them. For example, if a car has \"ab\" written on it, it could not be changed to read \"ba\".", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. The first line of each test case contains a single integer $N$, the number of sets of connected cars. The following line contains $N$ strings separated by a single space. Every given string represents a set of connected cars and is composed of lowercase English letters only.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the test case number (starting from 1) and $y$ is the number of different ways of obtaining a valid train. As this number may be very big, output the number of ways modulo $1,000,000,007$.", "hint": "**Sample Explanation**\n\nIn the first case, there is only one way to form a valid train by joining string \"ab\" to \"bbbc\" to \"cd\" in this order.\n\nWhile in the second case, there are $4$ possible ways to form a valid train. Notice that there are two different sets of connected cars represented by the string \"aa\", so there are two different ways to order these two strings and to group them to be one set of connected cars \"aaaa\". Also there is only one way to order set of cars \"bc\" with \"c\" in only one way to be \"bcc\". After that you can order \"aaaa\" and \"bcc\" in two different ways. So totally there are $2\\times 2 = 4$ ways to form a valid train.\n\nIn the third sample case, there is no possible way to form a valid train, as if joined in any of the two ways \"abc\"+\"bcd\" or \"bcd\"+\"abc\", there will be two letters of \"b\" and \"c\" not consecutive.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq \\text{Set of connected Cars' lengths} \\leq 100$.\n\n**Small dataset(10 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq N \\leq 10$.\n\n**Large dataset(25 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq N \\leq 100$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2014 #1C] Reordering Train Cars", "background": "", "description": "Yahya is a brilliant kid, so his mind raises a lot of interesting questions when he plays with his toys. Today's problem came about when his father brought him a set of $\\text{train cars}$, where each car has a lowercase letter written on one side of the car.\n\nWhen he first saw the gift, he was happy and started playing with them, connecting cars together without any particular goal. But after a while he got bored (as usual) from playing without having any goal. So, he decided to define a new interesting problem.\n\nThe problem is that he currently has $N$ sets of connected cars. He can represent each set of connected cars as a string of lowercase letters. He wants to count the number of ways he can connect all $N$ sets of cars to form one valid train. A train is valid if all occurrences of the same character are adjacent to each other.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y5i5dzbq.png)\n\nThe previous figure is one way Yahya could connect the cars \"ab\", \"bc\" and \"cd\" to make a valid train: \"ab bc cd\". If he had connected them in the order \"cd ab bc\", that would have been invalid: the \"c\" characters would not have been adjacent to each other.\n\nYou've surely noticed that this is not an easy problem for Yahya to solve, so he needs your help (and he is sure that you will give it!). That's it; go and help Yahya!\n\n**Note:** letters are written only on one side of the cars, so you can not reverse them. For example, if a car has \"ab\" written on it, it could not be changed to read \"ba\".", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. The first line of each test case contains a single integer $N$, the number of sets of connected cars. The following line contains $N$ strings separated by a single space. Every given string represents a set of connected cars and is composed of lowercase English letters only.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the test case number (starting from 1) and $y$ is the number of different ways of obtaining a valid train. As this number may be very big, output the number of ways modulo $1,000,000,007$.", "hint": "**Sample Explanation**\n\nIn the first case, there is only one way to form a valid train by joining string \"ab\" to \"bbbc\" to \"cd\" in this order.\n\nWhile in the second case, there are $4$ possible ways to form a valid train. Notice that there are two different sets of connected cars represented by the string \"aa\", so there are two different ways to order these two strings and to group them to be one set of connected cars \"aaaa\". Also there is only one way to order set of cars \"bc\" with \"c\" in only one way to be \"bcc\". After that you can order \"aaaa\" and \"bcc\" in two different ways. So totally there are $2\\times 2 = 4$ ways to form a valid train.\n\nIn the third sample case, there is no possible way to form a valid train, as if joined in any of the two ways \"abc\"+\"bcd\" or \"bcd\"+\"abc\", there will be two letters of \"b\" and \"c\" not consecutive.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq \\text{Set of connected Cars' lengths} \\leq 100$.\n\n**Small dataset(10 Pts)**\n\n- Time limit: ~~60~~ 3 seconds.\n- $1 \\leq N \\leq 10$.\n\n**Large dataset(25 Pts)**\n\n- Time limit: ~~120~~ 5 seconds.\n- $1 \\leq N \\leq 100$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2014 #1C] Reordering Train Cars", "background": "", "description": "Yahya 是一个聪明的孩子，所以在玩玩具的时候，他总会想到很多有趣的问题。今天的问题来源于他爸爸送给他的一组**火车车厢**，每节车厢的一侧都写有一个小写英文字母。\n\n刚看到礼物时，Yahya 十分高兴，开始随意地把车厢连接起来玩。但没玩多久，他就像往常一样感到无聊——因为这个游戏没有目标。所以他决定自己定义一个有趣的问题。\n\n这个问题是：他现在有 $N$ 组已经连接好的车厢。每组连接好的车厢可以用一个小写字母组成的字符串表示。他想要计算有多少种不同的方式可以把这 $N$ 组车厢连接成一列**合法的火车**。所谓**合法的火车**，是指每个字母在整列车厢中出现时，必须是连在一起的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y5i5dzbq.png)\n\n上图是 Yahya 连接 \"ab\"、\"bbbc\" 和 \"cd\" 成为一列合法火车的一种方式：即 \"ab bbbc cd\"。如果他用 \"cd ab bbbc\" 的顺序连接它们，则是不合法的，因为字母 \"c\" 的出现不连续。\n\n你肯定已经注意到了，这个问题对 Yahya 来说并不容易，所以他需要你的帮助（而他相信你一定能帮上忙）！就是这样——去帮帮 Yahya 吧！\n\n**注意：** 字母只写在车厢的一侧，因此不能翻转它们。比如，一个车厢写着 \"ab\"，就不能改为 \"ba\"。", "inputFormat": "输入的第一行是测试用例的数量 $T$。接下来有 $T$ 个测试用例。每个测试用例的第一行是一个整数 $N$，表示连接好的车厢组数。下一行包含 $N$ 个用空格分隔的字符串。每个字符串表示一组已经连接好的车厢，仅由小写英文字母组成。", "outputFormat": "对于每个测试用例，输出一行，格式为 `\"Case #x: y\"`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是将所有车厢组连接成一列合法火车的不同方式数。由于这个数可能非常大，请输出其对 $1,\\!000,\\!000,\\!007$ 取模的结果。\n", "hint": "**样例解释**\n\n在第一个样例中，只有一种方式可以将车厢组合成合法火车，即按顺序连接字符串 \"ab\"、\"bbbc\"、\"cd\"。\n\n而在第二个样例中，有 $4$ 种不同方式可以构成合法火车。注意，\"aa\" 这个字符串出现了两次，代表有两组车厢完全一样，因此它们的顺序可以互换并合并为一组 \"aaaa\"。而 \"bc\" 和 \"c\" 也可以以唯一的一种方式合并成 \"bcc\"。最后，你可以将 \"aaaa\" 和 \"bcc\" 有两种不同的顺序组合，因此总共有 $2 \\times 2 = 4$ 种方式。\n\n在第三个样例中，不存在任何方式可以组成合法火车。不论是按 \"abc\"+\"bcd\" 还是 \"bcd\"+\"abc\" 的顺序连接，字母 \"b\" 和 \"c\" 都会出现不连续的情况，因此都不合法。\n\n## 限制条件\n\n- $1 \\leq T \\leq 100$。\n- 每组连接车厢的字符串长度 $\\leq 100$。\n\n### Small 数据集（10 分）\n\n- 时间限制：~~60~~ 3 秒。\n- $1 \\leq N \\leq 10$。\n\n### Large 数据集（25 分）\n\n- 时间限制：~~120~~ 5 秒。\n- $1 \\leq N \\leq 100$。\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
