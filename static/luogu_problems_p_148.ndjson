{"pid": "P3998", "type": "P", "difficulty": 4, "samples": [["2 8\n! 1\n! 2\n+ 1 2\n! 1\n! 2\n- 1 2\n! 1\n! 2", "1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2013", "各省省选", "上海", "O2优化"], "title": "[SHOI2013] 发微博", "background": "", "description": "刚开通的 SH 微博共有 $n$ 个用户（$1\\sim n$ 标号），在这短短一个月的时间内，用户们活动频繁，共有 $m$ 条按时间顺序的记录：\n\n```plain\n! x 表示用户 x 发了一条微博；\n+ x y 表示用户 x 和用户 y 成为了好友\n− x y 表示用户 x 和用户 y 解除了好友关系\n```\n当一个用户发微博的时候，所有他的好友（直接关系）都会看到他的消息。\n\n假设最开始所有人之间都不是好友关系，记录也都是合法的（即 `+ x y` 时 $x$ 和 $y$ 一定不是好友，而 `− x y` 时 $x$ 和 $y$ 一定是好友）。\n\n问这 $m$ 条记录发生之后，每个用户分别看到了多少条消息。\n", "inputFormat": "第 $1$ 行两个整数 $n$, $m$。\n\n接下来 $m$ 行，按时间顺序读入 $m$ 条记录，每条记录的格式如题目所述，用空格隔开。", "outputFormat": "输出一行 $n$ 个用空格隔开的数（行末无空格），第 $i$ 个数表示用户 $i$ 最后看到了几条消息。\n", "hint": "对于 $100\\%$ 的数据，$n\\leq 200000$, $m\\leq 500000$", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2013] Posting Weibo", "background": "", "description": "The newly launched SH Weibo has $n$ users (labeled $1\\sim n$). During this brief month, users were very active, and there are $m$ records in chronological order:\n\n```plain\n! x 表示用户 x 发了一条微博；\n+ x y 表示用户 x 和用户 y 成为了好友\n− x y 表示用户 x 和用户 y 解除了好友关系\n```\nWhen a user posts a Weibo, all of their friends (direct connections) will see the message.\n\nAssume that initially no one is friends with anyone else, and all records are valid (i.e., when `+ x y` occurs, $x$ and $y$ are not friends; when `− x y` occurs, $x$ and $y$ are friends).\n\nAfter these $m$ records, determine how many messages each user has seen.", "inputFormat": "The first line contains two integers $n$, $m$.\n\nThe next $m$ lines contain the records in chronological order, each formatted as described above and separated by spaces.", "outputFormat": "Output one line with $n$ space-separated integers (no trailing space). The $i$-th number denotes the number of messages seen by user $i$.", "hint": "For $100\\%$ of the testdata, $n \\leq 200000$, $m \\leq 500000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2013] 发微博", "background": "", "description": "刚开通的 SH 微博共有 $n$ 个用户（$1\\sim n$ 标号），在这短短一个月的时间内，用户们活动频繁，共有 $m$ 条按时间顺序的记录：\n\n```plain\n! x 表示用户 x 发了一条微博；\n+ x y 表示用户 x 和用户 y 成为了好友\n− x y 表示用户 x 和用户 y 解除了好友关系\n```\n当一个用户发微博的时候，所有他的好友（直接关系）都会看到他的消息。\n\n假设最开始所有人之间都不是好友关系，记录也都是合法的（即 `+ x y` 时 $x$ 和 $y$ 一定不是好友，而 `− x y` 时 $x$ 和 $y$ 一定是好友）。\n\n问这 $m$ 条记录发生之后，每个用户分别看到了多少条消息。\n", "inputFormat": "第 $1$ 行两个整数 $n$, $m$。\n\n接下来 $m$ 行，按时间顺序读入 $m$ 条记录，每条记录的格式如题目所述，用空格隔开。", "outputFormat": "输出一行 $n$ 个用空格隔开的数（行末无空格），第 $i$ 个数表示用户 $i$ 最后看到了几条消息。\n", "hint": "对于 $100\\%$ 的数据，$n\\leq 200000$, $m\\leq 500000$", "locale": "zh-CN"}}}
{"pid": "P3999", "type": "P", "difficulty": 5, "samples": [["4 10\n1132411235", "168"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2013", "各省省选", "上海", "O2优化", "枚举", "进制", "状压 DP"], "title": "[SHOI2013] 二重镇", "background": null, "description": "这是一个充满爱的村子，它的名字叫二重镇。在这个爱意浓浓的村子里，居民们的生活快乐又安宁。二重镇呈长条形状，可分为排成一行的 $N$ 个方格。每个格子可能是空地，也可能是小草、灌木、大树、房屋或城堡中的一种物品。每种物品都有一个等级，小草的等级是 $1$，灌木的等级是 $2$，依此类推。\n\n你是这个村庄的建造者。你会陆续获得 $D$ 件物品，你要将它们合理地放置在村庄的空地上。你的目标是要让村子的总人气尽可能大。人气的获得规则在后面说明。关于放置的规则有以下几条：\n\n* 第一，每件物品都必须放在一个地方，不可丢弃，如果没有空地了，游戏直接结束；\n\n* 第二，物品可以放在一格空地上，或者临时放在仓库里。仓库同时最多只能放一件物品，它一开始是空的。只存在一个仓库；\n\n* 第三，一旦物品放在某个空格上，只要符合条件，系统就会自动将一些物品合成一个大的物品，这是强制被动的，也是瞬间的。直到合成结束后，才能放置下一个物品。\n\n* 第四，存放在仓库中的物品，随时可以取出放到空地上（但注意不能在合成的过程中放置），也可以一直留在仓库里。\n\n* 第五，除非利用仓库，不然不能更改物品的放置顺序；\n\n总结起来，这个游戏的流程就是获得一个新物品，决定是否将这个物品存入仓库，再决定将仓库中的物品或新物品放到哪个空地上，系统自动判定合成，获得人气，直到所有物品都被放置完毕，或空地用完为止。\n\n最后是关于合成的规则。合成是自动完成的，也是强制性的。如果有连续两个或以上相邻的格子里有相同等级的物品，它们会自动合体成一个新的物品，新物品的等级比之前高一个级别。合体分三步：\n\n* 第一步，确定有多少物品参与合成，这些物品的位置必须连在一起，等级相同。参与合体的物品会全部消失，对应的格子变成空地；\n\n* 第二步，假设有 $A$ 个 $K$ 级物品参与合体，那么将获得 $A\\times 2^K$ 点人气。例如有一次五棵小草进行了合体，那么总人气就会增加 $5 \\times 2^1=10$；\n\n* 第三步，一个 $K+1$ 等级的物品会出现在一个格子里。如果 $K+1$ 大于 $5$，则跳过这步，但第二步中的人气仍然要算，第一步中的旧物品也会被清除。这个高等级的物品只会出现在参与合体的格子上。每个格子会记录最后一次被放置物品的时间，新的物品会出现在该时间最晚的那个格子里，形象地说，就是出现在最近被放置过东西的格子；\n\n最后，请注意合成是会触发多次的，比如两个小草合成一个灌木，如果这棵灌木旁边还有其他灌木，合体将继续发生下去。\n\n现在，给出 $N$ 和获得物品的顺序及等级，请你要合理地将这些物品放置在一个初始全是空地的村子里，使得村子最终的人气值尽可能高。当所有物品都被放置，或者某一刻村子里没空地了，你都会结束村子的建设，而此时村子里累计人气值就是你的最终成果。", "inputFormat": "第一行给出两个整数 $N$ 和 $D$，用空格隔开。$N$ 表示村庄大小，$D$ 表示建设村庄的天数。\n\n第二行为一个字符串，每个字符为 $1 \\ldots 5$ 之间的一个字符，表示每天你可以放置的物品的等级。", "outputFormat": "输出一个整数，表示你能得到的最大的人气值。", "hint": "对于 $30\\%$ 的数据，$N=3$, $D\\leq 10$。\n\n对于 $60\\%$ 的数据，$N\\leq 4$, $D\\leq 30$。\n\n对于 $100\\%$ 的数据，$N\\leq 6$, $D\\leq 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2013] Double Town", "background": "", "description": "This is a village full of love, called Double Town. In this affectionate village, the residents live happily and peacefully. Double Town is long and narrow and can be divided into a row of $N$ cells. Each cell may be empty, or contain exactly one of the following: grass, shrub, tree, house, or castle. Each type has a level: grass has level $1$, shrub has level $2$, and so on.\n\nYou are the builder of this village. You will receive $D$ items one after another, and you must place them properly on empty cells. Your goal is to maximize the village’s total popularity. The rules for gaining popularity are explained later. The placement rules are as follows:\n\n* First, every item must be placed somewhere and cannot be discarded. If there is no empty cell, the game ends immediately.\n* Second, an item can be placed on one empty cell, or temporarily stored in the warehouse. The warehouse can hold at most one item at a time, and it is initially empty. There is only one warehouse.\n* Third, once an item is placed on a cell, as long as conditions are met, the system will automatically merge some items into a larger item. This is mandatory, passive, and instantaneous. Only after merging finishes can you place the next item.\n* Fourth, an item stored in the warehouse can be taken out and placed on an empty cell at any time (but not during a merge), or it may remain in the warehouse.\n* Fifth, unless you use the warehouse, you cannot change the order in which items are placed.\n\nIn summary, the process is: when you receive a new item, decide whether to store it in the warehouse, then decide where to place either the warehouse item or the new item on an empty cell, the system automatically performs merges and awards popularity, and you continue until all items have been placed or there are no empty cells left.\n\nFinally, here are the merge rules. Merging is automatic and mandatory. If two or more consecutive adjacent cells contain items of the same level, they will automatically merge into a new item whose level is one higher. A merge proceeds in three steps:\n\n* Step 1: Determine how many items participate in the merge; these items must be contiguous and of the same level. All participating items disappear, and their cells become empty.\n* Step 2: Suppose $A$ items of level $K$ merge. You gain $A\\times 2^K$ popularity. For example, if five grasses merge once, the total popularity increases by $5 \\times 2^1=10$.\n* Step 3: One item of level $K+1$ appears in one cell. If $K+1$ is greater than $5$, skip this step, but you still gain the popularity from Step 2, and the old items from Step 1 are still removed. The higher-level item appears only on one of the participating cells. Each cell records the time when an item was last placed on it; the new item appears on the cell with the latest such time—in other words, on the cell most recently placed upon.\n\nFinally, note that merges may be triggered multiple times. For example, two grasses may merge into a shrub; if that shrub is adjacent to other shrubs, merging continues.\n\nGiven $N$ and the sequence and levels of the items you receive, arrange them on an initially all-empty village to maximize the final total popularity. When all items have been placed, or at any moment when there are no empty cells, construction ends, and the accumulated popularity at that time is your final score.", "inputFormat": "The first line contains two integers $N$ and $D$, separated by a space. $N$ is the village size, and $D$ is the number of days.\n\nThe second line is a string, each character between $1 \\ldots 5$, indicating the level of the item you can place each day.", "outputFormat": "Output a single integer, the maximum popularity you can obtain.", "hint": "For $30\\%$ of the testdata, $N=3$, $D\\leq 10$.\n\nFor $60\\%$ of the testdata, $N\\leq 4$, $D\\leq 30$.\n\nFor $100\\%$ of the testdata, $N\\leq 6$, $D\\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2013] 二重镇", "background": null, "description": "这是一个充满爱的村子，它的名字叫二重镇。在这个爱意浓浓的村子里，居民们的生活快乐又安宁。二重镇呈长条形状，可分为排成一行的 $N$ 个方格。每个格子可能是空地，也可能是小草、灌木、大树、房屋或城堡中的一种物品。每种物品都有一个等级，小草的等级是 $1$，灌木的等级是 $2$，依此类推。\n\n你是这个村庄的建造者。你会陆续获得 $D$ 件物品，你要将它们合理地放置在村庄的空地上。你的目标是要让村子的总人气尽可能大。人气的获得规则在后面说明。关于放置的规则有以下几条：\n\n* 第一，每件物品都必须放在一个地方，不可丢弃，如果没有空地了，游戏直接结束；\n\n* 第二，物品可以放在一格空地上，或者临时放在仓库里。仓库同时最多只能放一件物品，它一开始是空的。只存在一个仓库；\n\n* 第三，一旦物品放在某个空格上，只要符合条件，系统就会自动将一些物品合成一个大的物品，这是强制被动的，也是瞬间的。直到合成结束后，才能放置下一个物品。\n\n* 第四，存放在仓库中的物品，随时可以取出放到空地上（但注意不能在合成的过程中放置），也可以一直留在仓库里。\n\n* 第五，除非利用仓库，不然不能更改物品的放置顺序；\n\n总结起来，这个游戏的流程就是获得一个新物品，决定是否将这个物品存入仓库，再决定将仓库中的物品或新物品放到哪个空地上，系统自动判定合成，获得人气，直到所有物品都被放置完毕，或空地用完为止。\n\n最后是关于合成的规则。合成是自动完成的，也是强制性的。如果有连续两个或以上相邻的格子里有相同等级的物品，它们会自动合体成一个新的物品，新物品的等级比之前高一个级别。合体分三步：\n\n* 第一步，确定有多少物品参与合成，这些物品的位置必须连在一起，等级相同。参与合体的物品会全部消失，对应的格子变成空地；\n\n* 第二步，假设有 $A$ 个 $K$ 级物品参与合体，那么将获得 $A\\times 2^K$ 点人气。例如有一次五棵小草进行了合体，那么总人气就会增加 $5 \\times 2^1=10$；\n\n* 第三步，一个 $K+1$ 等级的物品会出现在一个格子里。如果 $K+1$ 大于 $5$，则跳过这步，但第二步中的人气仍然要算，第一步中的旧物品也会被清除。这个高等级的物品只会出现在参与合体的格子上。每个格子会记录最后一次被放置物品的时间，新的物品会出现在该时间最晚的那个格子里，形象地说，就是出现在最近被放置过东西的格子；\n\n最后，请注意合成是会触发多次的，比如两个小草合成一个灌木，如果这棵灌木旁边还有其他灌木，合体将继续发生下去。\n\n现在，给出 $N$ 和获得物品的顺序及等级，请你要合理地将这些物品放置在一个初始全是空地的村子里，使得村子最终的人气值尽可能高。当所有物品都被放置，或者某一刻村子里没空地了，你都会结束村子的建设，而此时村子里累计人气值就是你的最终成果。", "inputFormat": "第一行给出两个整数 $N$ 和 $D$，用空格隔开。$N$ 表示村庄大小，$D$ 表示建设村庄的天数。\n\n第二行为一个字符串，每个字符为 $1 \\ldots 5$ 之间的一个字符，表示每天你可以放置的物品的等级。", "outputFormat": "输出一个整数，表示你能得到的最大的人气值。", "hint": "对于 $30\\%$ 的数据，$N=3$, $D\\leq 10$。\n\n对于 $60\\%$ 的数据，$N\\leq 4$, $D\\leq 30$。\n\n对于 $100\\%$ 的数据，$N\\leq 6$, $D\\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P4000", "type": "P", "difficulty": 6, "samples": [["5\n1000000007", "5"], ["10\n1000000007", "55"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["字符串", "数学", "O2优化", "素数判断,质数,筛法", "Fibonacci 数列"], "title": "斐波那契数列", "background": null, "description": "大家都知道，斐波那契数列是满足如下性质的一个数列：\n\n- $f_0 = 0$\n- $f_1 = 1$\n- $f_n = f_{n-1} + f_{n-2}$（$n \\geq 2$ 且 $n$ 为整数）\n\n请你求出 $f_n \\bmod p$ 的值。", "inputFormat": "- 第 1 行：一个整数 $n$。\n- 第 2 行：一个整数 $p$。", "outputFormat": "- 第 1 行：$f_n \\bmod p$ 的值。", "hint": "对于 $100\\%$ 的数据，$0 \\leq n \\leq 10^{30000000}$，$1 \\leq p<2^{31}$。", "locale": "zh-CN", "translations": {"en": {"title": "Fibonacci Sequence", "background": "", "description": "Everyone knows the Fibonacci sequence is defined by the following properties:\n- $f_0 = 0$.\n- $f_1 = 1$.\n- $f_n = f_{n-1} + f_{n-2}$ ($n \\geq 2$ and $n$ is an integer).\n\nPlease compute the value of $f_n \\bmod p$.", "inputFormat": "- Line 1: An integer $n$.\n- Line 2: An integer $p$.", "outputFormat": "- Line 1: The value of $f_n \\bmod p$.", "hint": "For $100\\%$ of the testdata, $0 \\leq n \\leq 10^{30000000}$, $1 \\leq p < 2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "斐波那契数列", "background": null, "description": "大家都知道，斐波那契数列是满足如下性质的一个数列：\n\n- $f_0 = 0$\n- $f_1 = 1$\n- $f_n = f_{n-1} + f_{n-2}$（$n \\geq 2$ 且 $n$ 为整数）\n\n请你求出 $f_n \\bmod p$ 的值。", "inputFormat": "- 第 1 行：一个整数 $n$。\n- 第 2 行：一个整数 $p$。", "outputFormat": "- 第 1 行：$f_n \\bmod p$ 的值。", "hint": "对于 $100\\%$ 的数据，$0 \\leq n \\leq 10^{30000000}$，$1 \\leq p<2^{31}$。", "locale": "zh-CN"}}}
{"pid": "P4001", "type": "P", "difficulty": 6, "samples": [["3 4\n5 6 4\n4 3 1\n7 5 3\n5 6 7 8\n8 7 6 5\n5 5 5\n6 6 6", "14"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000]}, "tags": ["2006", "网络流", "北京", "图论建模", "最短路", "平面图", "最小割", "ICPC"], "title": "[ICPC-Beijing 2006] 狼抓兔子", "background": "", "description": "现在小朋友们最喜欢的\"喜羊羊与灰太狼\"。话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形：\n\n ![](https://cdn.luogu.com.cn/upload/pic/11942.png) \n\n左上角点为 $(1,1)$，右下角点为 $(N,M)$（上图中 $N=3$，$M=4$）。有以下三种类型的道路：\n\n1. $(x,y)\\rightleftharpoons(x+1,y)$\n\n2. $(x,y)\\rightleftharpoons(x,y+1)$\n\n3. $(x,y)\\rightleftharpoons(x+1,y+1)$\n\n道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的。左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角 $(1,1)$ 的窝里，现在它们要跑到右下角 $(N,M)$ 的窝中去，狼王开始伏击这些兔子。当然为了保险起见，如果一条道路上最多通过的兔子数为 $K$，狼王需要安排同样数量的 $K$ 只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦。\n", "inputFormat": "第一行两个整数 $N,M$，表示网格的大小。\n\n接下来分三部分。\n\n第一部分共 $N$ 行，每行 $M-1$ 个数，表示横向道路的权值。\n\n第二部分共 $N-1$ 行，每行 $M$ 个数，表示纵向道路的权值。\n\n第三部分共 $N-1$ 行，每行 $M-1$ 个数，表示斜向道路的权值。", "outputFormat": "输出一个整数，表示参与伏击的狼的最小数量。\n", "hint": "### 数据规模与约定\n\n对于全部的测试点，保证 $3 \\leq N,M \\leq 1000$，所有道路的权值均为不超过 $10^6$ 的正整数。", "locale": "zh-CN", "translations": {"en": {"title": "[ICPC-Beijing 2006] Wolf Catches Rabbits", "background": "", "description": "Kids now love \"Pleasant Goat and Big Big Wolf\" (Xi Yangyang yu Hui Tailang). Although Big Big Wolf fails to catch goats, he is quite good at catching rabbits. The rabbits here are rather slow-witted and have only two burrows. As the Wolf King, you face a terrain shaped like a grid:\n\n![](https://cdn.luogu.com.cn/upload/pic/11942.png)\n\nThe upper-left point is $(1,1)$, and the lower-right point is $(N,M)$ (in the figure, $N=3$, $M=4$). There are three types of roads:\n\n1. $(x,y)\\rightleftharpoons(x+1,y)$\n2. $(x,y)\\rightleftharpoons(x,y+1)$\n3. $(x,y)\\rightleftharpoons(x+1,y+1)$\n\nThe weight on a road indicates the maximum number of rabbits that can pass through that road; roads are undirected. The upper-left and lower-right corners are the two burrows of the rabbits. Initially, all rabbits gather in the upper-left burrow at $(1,1)$, and now they want to run to the lower-right burrow at $(N,M)$. The Wolf King starts to ambush these rabbits. To be safe, if the maximum number of rabbits that can pass through a road is $K$, the Wolf King needs to assign the same number of $K$ wolves to completely block this road. You need to help the Wolf King plan an ambush so that, while ensuring all rabbits are captured, the number of participating wolves is minimized, since the wolves still need to trouble Pleasant Goat later.", "inputFormat": "The first line contains two integers $N, M$, indicating the size of the grid.\n\nThen the input consists of three parts.\n\n- Part 1: $N$ lines, each containing $M-1$ numbers, representing the weights of horizontal roads.\n- Part 2: $N-1$ lines, each containing $M$ numbers, representing the weights of vertical roads.\n- Part 3: $N-1$ lines, each containing $M-1$ numbers, representing the weights of diagonal roads.", "outputFormat": "Output a single integer, the minimum number of wolves needed for the ambush.", "hint": "Constraints\n\nFor all test points, it is guaranteed that $3 \\leq N, M \\leq 1000$, and all road weights are positive integers not exceeding $10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ICPC-Beijing 2006] 狼抓兔子", "background": "", "description": "现在小朋友们最喜欢的\"喜羊羊与灰太狼\"。话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形：\n\n ![](https://cdn.luogu.com.cn/upload/pic/11942.png) \n\n左上角点为 $(1,1)$，右下角点为 $(N,M)$（上图中 $N=3$，$M=4$）。有以下三种类型的道路：\n\n1. $(x,y)\\rightleftharpoons(x+1,y)$\n\n2. $(x,y)\\rightleftharpoons(x,y+1)$\n\n3. $(x,y)\\rightleftharpoons(x+1,y+1)$\n\n道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的。左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角 $(1,1)$ 的窝里，现在它们要跑到右下角 $(N,M)$ 的窝中去，狼王开始伏击这些兔子。当然为了保险起见，如果一条道路上最多通过的兔子数为 $K$，狼王需要安排同样数量的 $K$ 只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦。\n", "inputFormat": "第一行两个整数 $N,M$，表示网格的大小。\n\n接下来分三部分。\n\n第一部分共 $N$ 行，每行 $M-1$ 个数，表示横向道路的权值。\n\n第二部分共 $N-1$ 行，每行 $M$ 个数，表示纵向道路的权值。\n\n第三部分共 $N-1$ 行，每行 $M-1$ 个数，表示斜向道路的权值。", "outputFormat": "输出一个整数，表示参与伏击的狼的最小数量。\n", "hint": "### 数据规模与约定\n\n对于全部的测试点，保证 $3 \\leq N,M \\leq 1000$，所有道路的权值均为不超过 $10^6$ 的正整数。", "locale": "zh-CN"}}}
{"pid": "P4002", "type": "P", "difficulty": 7, "samples": [["3 1\n2 3 4", "1728"], ["233 10\n604230822 258609018 347836125 103063600 545593375 983656639 636383432 149579311 37952830 782185282 792399760 556879020 19276539 821164472 992758005 635410231 174811932 967712405 76287574 877354238 403371989 131233662 90928781 909518950 816498283 460305280 688669184 272529638 706529895 931734844 376928193 161521421 41104566 573769373 264585020 586697940 408186715 749973507 585282307 446139544 533914437 228442770 4774211 553190975 51362889 997532216 39361909 75179876 816005324 115649482 801539169 70138016 95888199 892467950 979656965 761391537 354528877 519086852 35676822 910063828 301582400 261610070 73340896 342686965 835379442 186930971 778389960 245321804 936904477 365427914 691461347 321579617 593870684 545240614 874770591 494238628 393533533 914132499 418423560 211294504 878787036 221718376 281432519 823680290 115941973 111850187 435832530 319475906 630937038 471509352 80300437 932519437 733119421 153641332 125967105 419259567 340572302 904357065 664581370 128237482 120545682 206803421 449817099 563421421 752044034 175348393 59415697 147333214 91236540 326844312 207632773 819028631 548562687 338070347 493469625 513509716 449920533 929302154 681990677 929862626 251572209 762291113 713142767 833696686 915932444 839109871 254711900 107265449 594227639 768298325 235502930 563778377 975101745 685320028 128955445 577906482 860668421 37376197 574244751 800910016 364220508 630882579 470699350 761788251 968952925 813174030 126058670 269634161 593236888 808049346 201252435 844809096 572096106 914395201 529266485 338789253 604265775 783978384 295059757 49254118 403037413 530562686 613032494 228899861 66643418 590992994 806806343 776316894 628369191 231811797 427987613 841594754 862694376 898686962 605138652 682408004 562621696 731197321 952042165 157614231 390007370 4055303 851428382 962103475 918450503 382450515 151653431 373476981 17189602 446713187 271736154 420227014 826280929 884768647 649126875 892924346 326522345 306693921 520001943 954891535 387510773 947989555 647246992 100965852 697437220 103146348 783373856 261814563 834343668 737171668 268433849 75111742 741226970 121617879 38970864 510438176 353073449 39629351 732920212 370263050 335347593 6412014 639495120 163384169 740185716 139382698 905313570 68463708 446076618 427071160 872360298 833587390 225821418\n", "521800668\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2017", "O2优化", "生成函数", "快速傅里叶变换 FFT", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] 生成树计数", "background": "", "description": "在一个 $s$ 个点的图中，存在 $s-n$ 条边，使图中形成了 $n$ 个连通块，第 $i$ 个连通块中有 $a_i$ 个点。\n\n现在我们需要再连接 $n-1$ 条边，使该图变成一棵树。对一种连边方案，设原图中第 $i$ 个连通块连出了 $d_i$ 条边，那么这棵树 $T$ 的价值为：\n\n$$ \\mathrm{val}(T) = \\left(\\prod_{i=1}^{n} {d_i}^m\\right)\\left(\\sum_{i=1}^{n} {d_i}^m\\right) $$\n\n你的任务是求出所有可能的生成树的价值之和，对 $998244353$ 取模。\n", "inputFormat": "输入的第一行包含两个整数 $n,m$，意义见题目描述。\n\n接下来一行有 $n$ 个整数，第 $i$ 个整数表示 $a_i$ $(1\\le a_i< 998244353)$。\n\n* 你可以由 $a_i$ 计算出图的总点数 $s$，所以在输入中不再给出 $s$ 的值。", "outputFormat": "输出包含一行一个整数，表示答案。", "hint": "令 $i$ 表示大小为 $i$ 的原连通块，我们在连通块之间的连边有以下三种可能:\n- $2-3-4$\n- $3-2-4$\n- $2-4-3$\n\n价值和为:\n$$(2×3^2 ×4×2+3×2^2 ×4×2+2×4^2 ×3×2)×(1+2+1)=1728$$\n\n\n---\n\n本题共有 $20$ 个测试点，每个测试点 $5$ 分。 \n\n- $20\\%$ 的数据中，$n\\le500$。\n\n- 另外 $20\\%$ 的数据中，$n \\le 3000$。\n\n- 另外 $10\\%$ 的数据中，$n \\le 10010, m = 1$。 \n\n- 另外 $10\\%$的数据中，$n \\le 10015,m = 2$。 \n\n- 另外 $20\\%$ 的数据中，所有 $a_i$ 相等。\n\n- $100\\%$ 的数据中，$n \\le 3\\times 10^4,m \\le 30$。  \n\n其中，每一个部分分的测试点均有一定梯度。", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training 2017] Counting Spanning Trees", "background": "", "description": "In a graph with $s$ vertices, there are $s-n$ edges, making the graph consist of $n$ connected components. The $i$-th connected component contains $a_i$ vertices.\n\nWe now need to add $n-1$ edges to make the graph a tree. For a particular way of adding edges, let the $i$-th original connected component have $d_i$ edges going out. Then the value of this tree $T$ is:\n$$ \\mathrm{val}(T) = \\left(\\prod_{i=1}^{n} {d_i}^m\\right)\\left(\\sum_{i=1}^{n} {d_i}^m\\right). $$\n\nYour task is to compute the sum of the values of all possible spanning trees, modulo $998244353$.", "inputFormat": "The first line contains two integers $n, m$, as described above.\n\nThe second line contains $n$ integers, where the $i$-th integer denotes $a_i$ $(1 \\le a_i < 998244353)$.\n\nYou can compute the total number of vertices $s$ from the $a_i$, so the value of $s$ is not given separately in the input.", "outputFormat": "Output a single line containing one integer, the answer.", "hint": "Let $i$ denote an original connected component of size $i$. The edges added between components can be in the following three orders:\n- $2-3-4$\n- $3-2-4$\n- $2-4-3$\n\nThe sum of values is:\n$$ (2 \\times 3^2 \\times 4 \\times 2 + 3 \\times 2^2 \\times 4 \\times 2 + 2 \\times 4^2 \\times 3 \\times 2) \\times (1+2+1) = 1728. $$\n\n---\n\nThis problem has $20$ test points, $5$ points each.\n\n- In $20\\%$ of the testdata, $n \\le 500$.\n- In another $20\\%$ of the testdata, $n \\le 3000$.\n- In another $10\\%$ of the testdata, $n \\le 10010, m = 1$.\n- In another $10\\%$ of the testdata, $n \\le 10015, m = 2$.\n- In another $20\\%$ of the testdata, all $a_i$ are equal.\n- For $100\\%$ of the testdata, $n \\le 3\\times 10^4, m \\le 30$.\n\nEach group of test points for a partial score has a certain gradient.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] 生成树计数", "background": "", "description": "在一个 $s$ 个点的图中，存在 $s-n$ 条边，使图中形成了 $n$ 个连通块，第 $i$ 个连通块中有 $a_i$ 个点。\n\n现在我们需要再连接 $n-1$ 条边，使该图变成一棵树。对一种连边方案，设原图中第 $i$ 个连通块连出了 $d_i$ 条边，那么这棵树 $T$ 的价值为：\n\n$$ \\mathrm{val}(T) = \\left(\\prod_{i=1}^{n} {d_i}^m\\right)\\left(\\sum_{i=1}^{n} {d_i}^m\\right) $$\n\n你的任务是求出所有可能的生成树的价值之和，对 $998244353$ 取模。\n", "inputFormat": "输入的第一行包含两个整数 $n,m$，意义见题目描述。\n\n接下来一行有 $n$ 个整数，第 $i$ 个整数表示 $a_i$ $(1\\le a_i< 998244353)$。\n\n* 你可以由 $a_i$ 计算出图的总点数 $s$，所以在输入中不再给出 $s$ 的值。", "outputFormat": "输出包含一行一个整数，表示答案。", "hint": "令 $i$ 表示大小为 $i$ 的原连通块，我们在连通块之间的连边有以下三种可能:\n- $2-3-4$\n- $3-2-4$\n- $2-4-3$\n\n价值和为:\n$$(2×3^2 ×4×2+3×2^2 ×4×2+2×4^2 ×3×2)×(1+2+1)=1728$$\n\n\n---\n\n本题共有 $20$ 个测试点，每个测试点 $5$ 分。 \n\n- $20\\%$ 的数据中，$n\\le500$。\n\n- 另外 $20\\%$ 的数据中，$n \\le 3000$。\n\n- 另外 $10\\%$ 的数据中，$n \\le 10010, m = 1$。 \n\n- 另外 $10\\%$的数据中，$n \\le 10015,m = 2$。 \n\n- 另外 $20\\%$ 的数据中，所有 $a_i$ 相等。\n\n- $100\\%$ 的数据中，$n \\le 3\\times 10^4,m \\le 30$。  \n\n其中，每一个部分分的测试点均有一定梯度。", "locale": "zh-CN"}}}
{"pid": "P4003", "type": "P", "difficulty": 7, "samples": [["2 3\n3 14 12\n3 11 12", "2"], ["3 2\n1 8\n5 10\n2 4", "-1"], ["3 3\n9 11 3\n13 15 7\n12 14 6", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "网络流", "费用流", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] 无限之环", "background": null, "description": "曾经有一款流行的游戏，叫做 Infinity Loop，先来简单的介绍一下这个游戏：\n\n游戏在一个 $n \\times m$ 的网格状棋盘上进行，其中有些小方格中会有水管，水管可能在格某些方向的边界的中点有接口，所有水管的粗细都相同，所以如果两个相邻方格的共边界的中点都有接头，那么可以看作这两个接头互相连接。水管有以下 $15$ 种形状：\n\n ![](https://cdn.luogu.com.cn/upload/pic/12049.png) \n\n游戏开始时，棋盘中水管可能存在漏水的地方。\n\n形式化地：如果存在某个接头，没有和其它接头相连接，那么它就是一个漏水的地方。\n\n玩家可以进行一种操作：选定一个含有**非直线型**水管的方格，将其中的水管绕方格中心顺时针或逆时针旋转 $90$ 度。\n\n直线型水管是指左图里中间一行的两种水管。\n\n现给出一个初始局面，请问最少进行多少次操作可以使棋盘上不存在漏水的地方。", "inputFormat": "第一行两个正整数 $n$, $m$, 代表网格的大小。\n\n接下来 $n$ 行每行 $m$ 个数，每个数是 $[0,15]$ 中的一个，你可以将其看作一个 $4$ 位的二进制数，从低到高每一位分别代表初始局面中这个格子上、右、下、左方向上是否有水管接头。\n\n特别地，如果这个数是 $0$ ，则意味着这个位置没有水管。\n\n比如 $3(0011_{(2)})$ 代表上和右有接头，也就是一个 $L$ 型，而 $12(1100_{(2)})$ 代表下和左有接头，也就是将 $L$ 型旋转 $180$ 度。", "outputFormat": "输出共一行，表示最少操作次数。如果无法达成目标，输出 $-1$。", "hint": "【样例 1 解释】\n\n样例 1 棋盘如下:\n\n旋转方法很显然，先将左上角虚线方格内的水管顺时针转 $90$ 度\n\n ![](https://cdn.luogu.com.cn/upload/pic/12050.png) \n\n然后右下角虚线方格内的水管逆时针旋转 $90$ 度，这样就使得水管封闭了\n\n【样例 2 解释】\n\n样例 2 为题目描述中的第一张图片，无法达成目标。\n\n【样例 3 解释】\n\n样例 3 为题目描述中的第二张图片，将除了中心方格以外的每个方格内的水管都转 $180$ 度即可。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/12051.png)", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training Camp 2017] Infinity Loop", "background": "", "description": "There was once a popular game called Infinity Loop. Here is a brief introduction to the game:\n\nThe game is played on an $n \\times m$ grid board. Some cells contain pipes. A pipe may have joints at the midpoints of the cell’s edges in certain directions. All pipes have the same thickness, so if two adjacent cells both have a joint at the midpoint of their shared edge, those two joints are considered connected. Pipes come in the following $15$ shapes:\n\n ![](https://cdn.luogu.com.cn/upload/pic/12049.png) \n\nAt the start of the game, there may be leaks on the board.\n\nFormally: if there exists a joint that is not connected to any other joint, then it is a leak.\n\nThe player can perform the following operation: choose a cell containing a non-straight pipe and rotate the pipe by $90$ degrees clockwise or counterclockwise about the center of the cell.\n\nA straight pipe refers to the two shapes in the middle row of the figure on the left.\n\nGiven an initial configuration, find the minimum number of operations needed so that there are no leaks on the board.", "inputFormat": "The first line contains two positive integers $n$, $m$, representing the size of the grid.\n\nEach of the next $n$ lines contains $m$ numbers, each in $[0,15]$. You may regard each number as a $4$-bit binary number. From low to high bit, the bits indicate whether in the initial configuration the cell has a joint in the up, right, down, and left directions, respectively.\n\nIn particular, if the number is $0$, it means there is no pipe in this cell.\n\nFor example, $3(0011_{(2)})$ means there are joints up and right, i.e., an $L$ shape; and $12(1100_{(2)})$ means there are joints down and left, i.e., the $L$ shape rotated by $180$ degrees.", "outputFormat": "Output a single line with the minimum number of operations. If it is impossible to achieve the goal, output $-1$.", "hint": "[Sample 1 explanation]\n\nThe board is as follows:\n\nThe rotation method is straightforward: first rotate the pipe in the dashed cell at the top-left clockwise by $90$ degrees.\n\n ![](https://cdn.luogu.com.cn/upload/pic/12050.png) \n\nThen rotate the pipe in the dashed cell at the bottom-right counterclockwise by $90$ degrees. This closes the loop.\n\n[Sample 2 explanation]\n\nSample 2 corresponds to the first picture in the problem description and is impossible to solve.\n\n[Sample 3 explanation]\n\nSample 3 corresponds to the second picture in the problem description. Rotate the pipe in every cell except the center cell by $180$ degrees.\n\n ![](https://cdn.luogu.com.cn/upload/pic/12051.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] 无限之环", "background": null, "description": "曾经有一款流行的游戏，叫做 Infinity Loop，先来简单的介绍一下这个游戏：\n\n游戏在一个 $n \\times m$ 的网格状棋盘上进行，其中有些小方格中会有水管，水管可能在格某些方向的边界的中点有接口，所有水管的粗细都相同，所以如果两个相邻方格的共边界的中点都有接头，那么可以看作这两个接头互相连接。水管有以下 $15$ 种形状：\n\n ![](https://cdn.luogu.com.cn/upload/pic/12049.png) \n\n游戏开始时，棋盘中水管可能存在漏水的地方。\n\n形式化地：如果存在某个接头，没有和其它接头相连接，那么它就是一个漏水的地方。\n\n玩家可以进行一种操作：选定一个含有**非直线型**水管的方格，将其中的水管绕方格中心顺时针或逆时针旋转 $90$ 度。\n\n直线型水管是指左图里中间一行的两种水管。\n\n现给出一个初始局面，请问最少进行多少次操作可以使棋盘上不存在漏水的地方。", "inputFormat": "第一行两个正整数 $n$, $m$, 代表网格的大小。\n\n接下来 $n$ 行每行 $m$ 个数，每个数是 $[0,15]$ 中的一个，你可以将其看作一个 $4$ 位的二进制数，从低到高每一位分别代表初始局面中这个格子上、右、下、左方向上是否有水管接头。\n\n特别地，如果这个数是 $0$ ，则意味着这个位置没有水管。\n\n比如 $3(0011_{(2)})$ 代表上和右有接头，也就是一个 $L$ 型，而 $12(1100_{(2)})$ 代表下和左有接头，也就是将 $L$ 型旋转 $180$ 度。", "outputFormat": "输出共一行，表示最少操作次数。如果无法达成目标，输出 $-1$。", "hint": "【样例 1 解释】\n\n样例 1 棋盘如下:\n\n旋转方法很显然，先将左上角虚线方格内的水管顺时针转 $90$ 度\n\n ![](https://cdn.luogu.com.cn/upload/pic/12050.png) \n\n然后右下角虚线方格内的水管逆时针旋转 $90$ 度，这样就使得水管封闭了\n\n【样例 2 解释】\n\n样例 2 为题目描述中的第一张图片，无法达成目标。\n\n【样例 3 解释】\n\n样例 3 为题目描述中的第二张图片，将除了中心方格以外的每个方格内的水管都转 $180$ 度即可。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/12051.png)", "locale": "zh-CN"}}}
{"pid": "P4004", "type": "P", "difficulty": 6, "samples": [["5\n1 2 3 4 5\n1 2\n2 3\n3 4\n2 5\n5\n1 1 4 1\n1 1 4 2\n0 1 5 2\n1 2 4 5\n1 1 5 1", "10\n8 6 5"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "O2优化", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] Hello world!", "background": "不远的一年前，小 V 还是一名清华集训的选手，坐在机房里为他已如风中残烛的OI 生涯做最后的挣扎。而如今，他已成为了一名光荣的出题人。他感到非常激动，不禁感叹道： “Hello world!”。", "description": "小 V 有 $n$ 道题，他的题都非常毒瘤，所以关爱选手的 ufozgg 打算削弱这些题。为了逃避削弱，小 V 把他的毒瘤题都藏到了一棵 $n$ 个节点的树里（节点编号从 $1$ 至 $n$），这棵树上的所有节点与小 V 的所有题一一对应。小 V 的每一道题都有一个毒瘤值，节点 $i$ （表示标号为 $i$ 的树上节点，下同）对应的题的毒瘤值为 $a_i$。\n\n魔法师小 V 为了保护他的题目，对这棵树施了魔法，这样一来，任何人想要一探这棵树的究竟，都必须在上面做跳跃操作。每一次跳跃操作包含一个起点 $s$ 、一个终点 $t$ 和一个步频 $k$ ，这表示跳跃者会从 $s$ 出发，在树上沿着简单路径多次跳跃到达 $t$ ，每次跳跃，如果从当前点到 $t$ 的最短路长度不超过 $k$ ，那么跳跃者就会直接跳到 $t$ ，否则跳跃者就会沿着最短路跳过恰好 $k$ 条边。\n\n既然小 V 把题藏在了树里， ufozgg 就不能直接削弱题目了。他就必须在树上跳跃，边跳跃边削弱题目。 ufozgg 每次跳跃经过一个节点（包括起点 $s$ ，当 $s = t$ 的时候也是如此），就会把该节点上的题目的毒瘤值开根并向下取整：即如果他经过了节点 $i$，他就会使 $a_i = \\lfloor \\sqrt{a_i} \\rfloor$。这种操作我们称为削弱操作。\n\nufozgg 还会不时地希望知道他对题目的削弱程度。因此，他在一些跳跃操作中会放弃对题目的削弱，转而统计该次跳跃经过节点的题目毒瘤值总和。这种操作我们称为统计操作。\n\n吃瓜群众绿绿对小 V 的毒瘤题和 ufozgg 的削弱计划常感兴趣。他现在想知道ufozgg 每次做统计操作时得到的结果。你能帮帮他吗？\n\n![](https://cdn.luogu.com.cn/upload/pic/12052.png)", "inputFormat": "输入的第一行一个正整数 $n$ ，表示树的节点数。\n\n接下来一行 $n$ 个用空格隔开的正整数 $a_1, a_2, \\ldots, a_n$，依次描述每个节点上题目的毒瘤值。\n\n接下来 $n − 1$ 行，描述这棵树。每行 $2$ 个正整数 $u, v$ ，描述一条树上的边 $(u, v)$ 。（保证 $1 \\leq u, v \\leq n$ ，保证这 $n − 1$ 条边构成了一棵树）\n\n接下来一行一个正整数 $Q$ ，表示 ufozgg 的操作总数。\n\n接下来 $Q$ 行按 ufozgg 执行操作的先后顺序依次描述每个操作，每行 $4$ 个用空格隔开的整数 $op, s, t, k$ ，表示 ufozgg 此次跳跃的起点为 $s$ ，终点为 $t$ ，步频为 $k$ 。如果 $op = 0$ ，表示这是一次削弱操作；如果 $op = 1$ ，表示这是一次统计操作。", "outputFormat": "对于每个统计操作，输出一行一个整数，表示此次统计操作统计到的所有题的毒瘤值总和。", "hint": "对于 $100\\%$ 的数据，$n≤50000$, $Q≤400000$, $1\\leq ai\\leq 10^{13}$。\n\n对于所有的操作保证 $0\\leq op\\leq 1$，$1\\leq s,t,k\\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training 2017] Hello world!", "background": "About a year ago, Xiao V was still a participant in the Tsinghua training camp, sitting in the computer room making a final effort for his OI career that was like a candle in the wind. Now, he has become a proud problem setter. He felt very excited and couldn’t help but exclaim: “Hello world!”.", "description": "Xiao V has $n$ problems. His problems are very tricky, so the caring contestant ufozgg plans to weaken them. To avoid being weakened, Xiao V hides all his tricky problems in a tree with $n$ nodes (nodes are numbered from $1$ to $n$). Every node on the tree corresponds one-to-one with one of Xiao V’s problems. Each problem has a “trickiness value.” The problem corresponding to node $i$ (meaning the node labeled $i$ in the tree, same below) has trickiness value $a_i$.\n\nTo protect his problems, the magician Xiao V cast a spell on the tree. From then on, anyone who wants to explore the tree must perform jump operations on it. Each jump operation includes a start $s$, an end $t$, and a step size $k$. This means the jumper will start from $s$ and reach $t$ by jumping along the simple path on the tree. In each jump, if the shortest path distance from the current node to $t$ is no more than $k$, the jumper jumps directly to $t$; otherwise, the jumper advances exactly $k$ edges along the shortest path toward $t$.\n\nSince Xiao V hid the problems in the tree, ufozgg cannot weaken them directly. He must jump on the tree and weaken problems along the way. Every time ufozgg passes through a node (including the start $s$, even when $s=t$), he will take the square root of that node’s problem’s trickiness value and round it down: that is, if he passes node $i$, he sets $a_i = \\lfloor \\sqrt{a_i} \\rfloor$. We call this a weaken operation.\n\nFrom time to time, ufozgg also wants to know how much he has weakened the problems. Therefore, in some jump operations he gives up weakening and instead computes the sum of trickiness values of the nodes visited in that jump. We call this a query operation.\n\nThe onlooker Lülü is very interested in Xiao V’s tricky problems and ufozgg’s weakening plan. He now wants to know the result ufozgg gets for each query operation. Can you help him?\n\n![](https://cdn.luogu.com.cn/upload/pic/12052.png)", "inputFormat": "The first line contains a positive integer $n$, the number of nodes in the tree.\n\nThe next line contains $n$ space-separated positive integers $a_1, a_2, \\ldots, a_n$, describing the trickiness value on each node.\n\nThe next $n-1$ lines describe the tree. Each line contains two positive integers $u, v$, describing an edge $(u, v)$. It is guaranteed that $1 \\le u, v \\le n$, and that these $n-1$ edges form a tree.\n\nThe next line contains a positive integer $Q$, the total number of operations performed by ufozgg.\n\nThe next $Q$ lines describe each operation in the order they are performed. Each line contains four space-separated integers $op, s, t, k$, meaning the jump starts at $s$, ends at $t$, with step size $k$. If $op = 0$, it is a weaken operation; if $op = 1$, it is a query operation.", "outputFormat": "For each query operation, output a single line with one integer, the sum of the trickiness values of all problems counted in that operation.", "hint": "For $100\\%$ of the testdata, $n \\le 50000$, $Q \\le 400000$, $1 \\le a_i \\le 10^{13}$.\n\nFor all operations, it is guaranteed that $0 \\le op \\le 1$ and $1 \\le s, t, k \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] Hello world!", "background": "不远的一年前，小 V 还是一名清华集训的选手，坐在机房里为他已如风中残烛的OI 生涯做最后的挣扎。而如今，他已成为了一名光荣的出题人。他感到非常激动，不禁感叹道： “Hello world!”。", "description": "小 V 有 $n$ 道题，他的题都非常毒瘤，所以关爱选手的 ufozgg 打算削弱这些题。为了逃避削弱，小 V 把他的毒瘤题都藏到了一棵 $n$ 个节点的树里（节点编号从 $1$ 至 $n$），这棵树上的所有节点与小 V 的所有题一一对应。小 V 的每一道题都有一个毒瘤值，节点 $i$ （表示标号为 $i$ 的树上节点，下同）对应的题的毒瘤值为 $a_i$。\n\n魔法师小 V 为了保护他的题目，对这棵树施了魔法，这样一来，任何人想要一探这棵树的究竟，都必须在上面做跳跃操作。每一次跳跃操作包含一个起点 $s$ 、一个终点 $t$ 和一个步频 $k$ ，这表示跳跃者会从 $s$ 出发，在树上沿着简单路径多次跳跃到达 $t$ ，每次跳跃，如果从当前点到 $t$ 的最短路长度不超过 $k$ ，那么跳跃者就会直接跳到 $t$ ，否则跳跃者就会沿着最短路跳过恰好 $k$ 条边。\n\n既然小 V 把题藏在了树里， ufozgg 就不能直接削弱题目了。他就必须在树上跳跃，边跳跃边削弱题目。 ufozgg 每次跳跃经过一个节点（包括起点 $s$ ，当 $s = t$ 的时候也是如此），就会把该节点上的题目的毒瘤值开根并向下取整：即如果他经过了节点 $i$，他就会使 $a_i = \\lfloor \\sqrt{a_i} \\rfloor$。这种操作我们称为削弱操作。\n\nufozgg 还会不时地希望知道他对题目的削弱程度。因此，他在一些跳跃操作中会放弃对题目的削弱，转而统计该次跳跃经过节点的题目毒瘤值总和。这种操作我们称为统计操作。\n\n吃瓜群众绿绿对小 V 的毒瘤题和 ufozgg 的削弱计划常感兴趣。他现在想知道ufozgg 每次做统计操作时得到的结果。你能帮帮他吗？\n\n![](https://cdn.luogu.com.cn/upload/pic/12052.png)", "inputFormat": "输入的第一行一个正整数 $n$ ，表示树的节点数。\n\n接下来一行 $n$ 个用空格隔开的正整数 $a_1, a_2, \\ldots, a_n$，依次描述每个节点上题目的毒瘤值。\n\n接下来 $n − 1$ 行，描述这棵树。每行 $2$ 个正整数 $u, v$ ，描述一条树上的边 $(u, v)$ 。（保证 $1 \\leq u, v \\leq n$ ，保证这 $n − 1$ 条边构成了一棵树）\n\n接下来一行一个正整数 $Q$ ，表示 ufozgg 的操作总数。\n\n接下来 $Q$ 行按 ufozgg 执行操作的先后顺序依次描述每个操作，每行 $4$ 个用空格隔开的整数 $op, s, t, k$ ，表示 ufozgg 此次跳跃的起点为 $s$ ，终点为 $t$ ，步频为 $k$ 。如果 $op = 0$ ，表示这是一次削弱操作；如果 $op = 1$ ，表示这是一次统计操作。", "outputFormat": "对于每个统计操作，输出一行一个整数，表示此次统计操作统计到的所有题的毒瘤值总和。", "hint": "对于 $100\\%$ 的数据，$n≤50000$, $Q≤400000$, $1\\leq ai\\leq 10^{13}$。\n\n对于所有的操作保证 $0\\leq op\\leq 1$，$1\\leq s,t,k\\leq n$。", "locale": "zh-CN"}}}
{"pid": "P4005", "type": "P", "difficulty": 6, "samples": [["4 4\n1 2 1 2\n8\n1 2 3 4 1 2 3 4\n5\n5 4 3 3 5\n8\n1 2 3 4 1 3 2 4", "0 \n0 \n0 \n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["模拟", "搜索", "2017", "树状数组", "O2优化", "枚举", "模拟退火", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] 小 Y 和地铁", "background": null, "description": "小 Y 是一个爱好旅行的 OIer。一天，她来到了一个新的城市。由于不熟悉那里的交通系统，她选择了坐地铁。\n\n她发现每条地铁线路可以看成平面上的一条曲线，不同线路的交点处一定会设有换乘站 。通过调查得知，没有线路是环线，也没有线路与自身相交。任意两条不同的线路只会在若干个点上相交，没有重合的部分，且没有三线共点的情况。即，如图所示的情况都是不存在的：\n\n ![](https://cdn.luogu.com.cn/upload/pic/12055.png) \n\n小 Y 坐着地铁 $0$ 号线，路上依次经过了 $n$ 个换乘站。她记下了每个换乘站可以换乘的线路编号，发现每条线路与她所乘坐的线路最多只有 $2$ 个换乘站。现在小 Y 想知道，除掉她经过的换乘站以外，这个城市里最少有几个换乘站。只有你告诉她正确的答案，她才会答应下次带你去玩呢。", "inputFormat": "**请注意本题有多组输入数据。**\n\n输入数据的第一行是一个整数 $T$，表示输入数据的组数。接下来依次给出每组数据。\n\n对于每组数据，第一行是一个整数 $n$，表示小 Y 经过的换乘站的数目。第二行为 $n$ 个用空格隔开的整数，依次表示每个换乘站的可以换乘的线路编号。这些编号都在 $1\\sim n$ 之内。", "outputFormat": "对于每组输入数据，输出一行一个整数，表示除掉这 $n$ 个换乘站之外，最少有几个换乘站。", "hint": "【样例 1 解释】\n\n对于样例的前两组数据，一种可能的最优答案如下图所示。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12053.png) \n\n【子任务】\n\n一共有 $50$ 个测试点，每个测试点 $2$ 分。你只有在答案完全正确时才能得到该测试点的全部分数，否则不得分。\n\n对于所有测试点，以及对于样例， $1 \\leq T \\leq 100$, $1 \\leq n \\leq 44$。对于每个测试点， $n$ 的范围如下表：\n\n![](https://cdn.luogu.com.cn/upload/pic/12054.png)", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training 2017] Xiao Y and the Subway", "background": "", "description": "Xiao Y is an OIer who loves traveling. One day, she arrives in a new city. Since she is not familiar with the transportation system there, she chooses to take the subway.\n\nShe discovers that each subway line can be regarded as a curve on the plane, and every intersection between different lines must have a transfer station. From her investigation, she learns that no line is a loop, and no line intersects itself. Any two distinct lines intersect only at finitely many points, have no overlapping segments, and no three lines pass through the same point. That is, the situations shown in the figure do not occur:\n\n![](https://cdn.luogu.com.cn/upload/pic/12055.png)\n\nXiao Y is riding subway line $0$, and along the way she passes $n$ transfer stations in order. She notes the line number available for transfer at each transfer station, and finds that every line shares at most $2$ transfer stations with the line she is on. Now Xiao Y wants to know, excluding the transfer stations she passed, what is the minimum possible number of other transfer stations in the city. Only if you give the correct answer will she agree to take you out next time.", "inputFormat": "Please note that this problem contains multiple test cases.\n\nThe first line of the input data is an integer $T$, indicating the number of test cases. The test cases follow.\n\nFor each test case, the first line is an integer $n$, representing the number of transfer stations Xiao Y passed. The second line contains $n$ space-separated integers, in order, each indicating the line number available for transfer at that transfer station. These indices are all within $1\\sim n$.", "outputFormat": "For each test case, output a single integer on one line, representing the minimum number of transfer stations other than these $n$.", "hint": "[Explanation for Sample 1]\n\nFor the first two test cases in the sample, one possible optimal configuration is shown below.\n\n![](https://cdn.luogu.com.cn/upload/pic/12053.png)\n\n[Subtasks]\n\nThere are $50$ test points, each worth $2$ points. You can only get full points for a test point if your answer is completely correct; otherwise, you get no points.\n\nFor all test points and for the samples, $1 \\leq T \\leq 100$, $1 \\leq n \\leq 44$. For each test point, the range of $n$ is given in the following table:\n\n![](https://cdn.luogu.com.cn/upload/pic/12054.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] 小 Y 和地铁", "background": null, "description": "小 Y 是一个爱好旅行的 OIer。一天，她来到了一个新的城市。由于不熟悉那里的交通系统，她选择了坐地铁。\n\n她发现每条地铁线路可以看成平面上的一条曲线，不同线路的交点处一定会设有换乘站 。通过调查得知，没有线路是环线，也没有线路与自身相交。任意两条不同的线路只会在若干个点上相交，没有重合的部分，且没有三线共点的情况。即，如图所示的情况都是不存在的：\n\n ![](https://cdn.luogu.com.cn/upload/pic/12055.png) \n\n小 Y 坐着地铁 $0$ 号线，路上依次经过了 $n$ 个换乘站。她记下了每个换乘站可以换乘的线路编号，发现每条线路与她所乘坐的线路最多只有 $2$ 个换乘站。现在小 Y 想知道，除掉她经过的换乘站以外，这个城市里最少有几个换乘站。只有你告诉她正确的答案，她才会答应下次带你去玩呢。", "inputFormat": "**请注意本题有多组输入数据。**\n\n输入数据的第一行是一个整数 $T$，表示输入数据的组数。接下来依次给出每组数据。\n\n对于每组数据，第一行是一个整数 $n$，表示小 Y 经过的换乘站的数目。第二行为 $n$ 个用空格隔开的整数，依次表示每个换乘站的可以换乘的线路编号。这些编号都在 $1\\sim n$ 之内。", "outputFormat": "对于每组输入数据，输出一行一个整数，表示除掉这 $n$ 个换乘站之外，最少有几个换乘站。", "hint": "【样例 1 解释】\n\n对于样例的前两组数据，一种可能的最优答案如下图所示。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12053.png) \n\n【子任务】\n\n一共有 $50$ 个测试点，每个测试点 $2$ 分。你只有在答案完全正确时才能得到该测试点的全部分数，否则不得分。\n\n对于所有测试点，以及对于样例， $1 \\leq T \\leq 100$, $1 \\leq n \\leq 44$。对于每个测试点， $n$ 的范围如下表：\n\n![](https://cdn.luogu.com.cn/upload/pic/12054.png)", "locale": "zh-CN"}}}
{"pid": "P4006", "type": "P", "difficulty": 5, "samples": [["4\n3 2 3 4\n1 1\n1 1\n1 1", "2 1 3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "O2优化", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] 小 Y 和二叉树", "background": null, "description": "小 Y 是一个心灵手巧的 OIer，她有许多二叉树模型。\n\n小 Y 的二叉树模型中，每个结点都具有一个编号，小 Y 把她最喜欢的一个二叉树模型挂在了墙上，树根在最上面，左右子树分别在树根的左下方与右下方，且他们也都满足这样的悬挂规则。为了让这个模型更加美观，小 Y 选择了一种让这棵二叉树的中序遍历序列最小的悬挂方法。所谓中序遍历最小，就是指中序遍历的结点编号序列的字典序最小。\n\n一天，这个模型不小心被掉在了地上，幸运的是，所有结点和边都没摔坏，但是她想不起这个模型原来是怎么悬挂的了，也就是说：她想不起来树根节点的编号了。\n\n小 Y 最近忙于准备清华集训，所以没太多时间处理别的事情，她只好找到同样心灵手巧的你帮忙复原她的二叉树模型。", "inputFormat": "第一行为一个正整数 $n$ ，表示点的个数。\n\n后接 $n$ 行，每行若干个整数：\n\n第 $i + 1$ 行的第一个整数为 $k_i$ ，表示编号为 $i$ 的结点的度数，后接 $k_i$ 个整数 $a_{i, j}$ ，表示编号为 $i$ 的结点与编号为 $a_{i, j}$ 的结点之间有一条边。\n\n同一行输入的相邻两个元素之间，用恰好一个空格隔开。", "outputFormat": "输出共一行， $n$ 个整数，表示字典序最小的中序遍历。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/12056.png) \n\n【子任务】\n\n ![](https://cdn.luogu.com.cn/upload/pic/12057.png) \n\n本题共 $20$ 个测试点，每个测试点 $5$ 分。各个测试点的数据范围如下：\n\n随机数据的生成方式如下：对于第 $13$ 个测试点，从一棵两个结点的树开始，每次随机一个树上的度数为 $1$ 的结点（即叶结点），并生成两个与之直接相连的结点，直到这棵树上有 $n$ 个结点。显然，在这个测试点中， $n$ 是一个偶数。对于第 $15$ 和第 $16$ 个测试点，从一棵一个结点的树开始，每次随机一个树上的度数不超过 $2$ 的结点，并生成一个与之直接相连的结点，直到这棵树上有 $n$ 个结点。\n\n【提示】\n\n我们提供了一个只包含输入和输出功能的程序 `binary\\_sample.cpp`。关于该程序的说明，见 `readme.txt`。你可以在答题时使用该程序的代码，也可以不使用，这将与你的得分无关。", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training 2017] Xiao Y and the Binary Tree", "background": "", "description": "Xiao Y is a handy OIer who owns many binary tree models.\n\nIn Xiao Y’s binary tree model, each node has an id. She hung her favorite binary tree model on the wall, with the root at the top, and the left and right subtrees placed at the lower-left and lower-right of the root, respectively; they all follow the same hanging rule recursively. To make the model more elegant, Xiao Y chose a hanging orientation that makes the inorder traversal sequence of this binary tree lexicographically smallest. “Lexicographically smallest” means the sequence of node ids visited by an inorder traversal is lexicographically minimal.\n\nOne day, the model accidentally fell to the ground. Fortunately, none of the nodes or edges were damaged, but she could no longer recall how the model had been hung; in other words, she forgot the id of the root node.\n\nRecently, Xiao Y has been busy preparing for the Tsinghua training, so she doesn’t have much time for other things. She turns to you for help to restore her binary tree model.", "inputFormat": "The first line contains a positive integer $n$, the number of nodes.\n\nThen follow $n$ lines, each containing several integers:\n\nIn the $(i + 1)$-th line, the first integer is $k_i$, the degree of node $i$, followed by $k_i$ integers $a_{i, j}$, indicating that there is an edge between node $i$ and node $a_{i, j}$.\n\nAdjacent elements on the same line are separated by exactly one space.", "outputFormat": "Output a single line with $n$ integers: the lexicographically smallest inorder traversal.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/12056.png)\n\nSubtasks\n\n![](https://cdn.luogu.com.cn/upload/pic/12057.png)\n\nThis problem has $20$ test points, each worth $5$ points. Constraints for each test point are as follows:\n\nThe random testdata are generated as follows: For the $13$-th test point, start from a tree with two nodes. Each time, pick a node of degree $1$ (i.e., a leaf) uniformly at random and attach two new nodes to it, until the tree has $n$ nodes. Clearly, in this test point, $n$ is even. For the $15$-th and $16$-th test points, start from a tree with one node. Each time, pick a node whose degree does not exceed $2$ uniformly at random and attach one new node to it, until the tree has $n$ nodes.\n\nHint\n\nWe provide a program binary_sample.cpp that only handles input and output. See readme.txt for details. You may use the code of this program when solving the problem, or not; this will not affect your score.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] 小 Y 和二叉树", "background": null, "description": "小 Y 是一个心灵手巧的 OIer，她有许多二叉树模型。\n\n小 Y 的二叉树模型中，每个结点都具有一个编号，小 Y 把她最喜欢的一个二叉树模型挂在了墙上，树根在最上面，左右子树分别在树根的左下方与右下方，且他们也都满足这样的悬挂规则。为了让这个模型更加美观，小 Y 选择了一种让这棵二叉树的中序遍历序列最小的悬挂方法。所谓中序遍历最小，就是指中序遍历的结点编号序列的字典序最小。\n\n一天，这个模型不小心被掉在了地上，幸运的是，所有结点和边都没摔坏，但是她想不起这个模型原来是怎么悬挂的了，也就是说：她想不起来树根节点的编号了。\n\n小 Y 最近忙于准备清华集训，所以没太多时间处理别的事情，她只好找到同样心灵手巧的你帮忙复原她的二叉树模型。", "inputFormat": "第一行为一个正整数 $n$ ，表示点的个数。\n\n后接 $n$ 行，每行若干个整数：\n\n第 $i + 1$ 行的第一个整数为 $k_i$ ，表示编号为 $i$ 的结点的度数，后接 $k_i$ 个整数 $a_{i, j}$ ，表示编号为 $i$ 的结点与编号为 $a_{i, j}$ 的结点之间有一条边。\n\n同一行输入的相邻两个元素之间，用恰好一个空格隔开。", "outputFormat": "输出共一行， $n$ 个整数，表示字典序最小的中序遍历。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/12056.png) \n\n【子任务】\n\n ![](https://cdn.luogu.com.cn/upload/pic/12057.png) \n\n本题共 $20$ 个测试点，每个测试点 $5$ 分。各个测试点的数据范围如下：\n\n随机数据的生成方式如下：对于第 $13$ 个测试点，从一棵两个结点的树开始，每次随机一个树上的度数为 $1$ 的结点（即叶结点），并生成两个与之直接相连的结点，直到这棵树上有 $n$ 个结点。显然，在这个测试点中， $n$ 是一个偶数。对于第 $15$ 和第 $16$ 个测试点，从一棵一个结点的树开始，每次随机一个树上的度数不超过 $2$ 的结点，并生成一个与之直接相连的结点，直到这棵树上有 $n$ 个结点。\n\n【提示】\n\n我们提供了一个只包含输入和输出功能的程序 `binary\\_sample.cpp`。关于该程序的说明，见 `readme.txt`。你可以在答题时使用该程序的代码，也可以不使用，这将与你的得分无关。", "locale": "zh-CN"}}}
{"pid": "P4007", "type": "P", "difficulty": 6, "samples": [["3 2 6\n1\n2\n3", "499122177\n415935148\n471393168"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "O2优化", "矩阵加速", "概率论", "期望", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] 小 Y 和恐怖的奴隶主", "background": "“A fight? Count me in!” 要打架了，算我一个。\n\n“Everyone, get in here!” 所有人，都过来！", "description": "小 Y 是一个喜欢玩游戏的 OIer。一天，她正在玩一款游戏，要打一个 Boss。\n\n虽然这个 Boss 有 $10^{100}$ 点生命值，但它只带了一个随从——一个只有 $m$ 点生命值的“恐怖的奴隶主”。\n\n这个“恐怖的奴隶主”有一个特殊的技能：每当它被扣减生命值但没有死亡（死亡即生命值 $\\leq 0$），且 Boss 的随从数量小于上限 $k$，便会召唤一个新的具有 $m$ 点生命值的“恐怖的奴隶主”。\n\n现在小 Y 可以进行 $n$ 次攻击，每次攻击时，会从 Boss 以及 Boss 的所有随从中的等概率随机选择一个，并扣减 $1$ 点生命值，她想知道进行 $n$ 次攻击后扣减 Boss 的生命值点数的期望。为了避免精度误差，你的答案需要对 $998244353$ 取模。", "inputFormat": "输入第一行包含三个正整数 $T, m, k$，$T$ 表示询问组数，$m, k$ 的含义见题目描述。\n\n接下来 $T$ 行，每行包含一个正整数 $n$，表示询问进行 $n$ 次攻击后扣减Boss的生命值点数的期望。", "outputFormat": "输出共 $T$ 行，对于每个询问输出一行一个非负整数，表示该询问的答案对 $998244353$ 取模的结果。\n\n可以证明，所求期望一定是一个有理数，设其为 $p / q$ $(\\mathrm{gcd}(p,q) = 1)$，那么你输出的数 $x$ 要满足 $p \\equiv qx \\pmod{998244353}$。", "hint": "【样例 $1$ 解释】\n\n对于第一次询问，第一次攻击有 $\\frac{1}{2}$ 的概率扣减 Boss 的生命值，有 $\\frac{1}{2}$ 的概率扣减随从的生命值，所以答案为 $\\frac{1}{2}$。$1 \\equiv 2 \\times 499122177 \\pmod{998244353}$。\n\n对于第二次询问，如果第一次攻击扣减了 Boss 的生命值，那么有 $\\frac{1}{2}$ 的概率第二次攻击仍扣减 Boss 的生命值，有 $\\frac{1}{2}$ 的概率第二次攻击扣减随从的生命值；如果第一次攻击扣减了随从的生命值，那么现在又新召唤了一个随从（“恐怖的奴隶主”），于是有 $\\frac{1}{3}$ 的概率第二次攻击扣减 Boss 的生命值，有 $\\frac{2}{3}$ 的概率第二次攻击扣减随从的生命值。所以答案为 $\\frac{1}{2}\\times\\frac{1}{2}\\times2+\\frac{1}{2}\\times\\frac{1}{2}\\times1+\\frac{1}{2}\\times\\frac{1}{3}\\times1+\\frac{1}{2}\\times\\frac{2}{3}\\times0 = \\frac{11}{12}$。 $11 \\equiv 12 \\times 415935148\\pmod{998244353}$。\n\n【提示】\n\n题目顺序可能与难度无关。\n\n【子任务】\n\n在所有测试点中，$1 \\leq T \\leq 1000, 1 \\leq n \\leq {10}^{18}, 1 \\leq m \\leq 3, 1 \\leq k \\leq 8$。\n\n各个测试点的分值和数据范围如下：\n\n![12058](https://cdn.luogu.com.cn/upload/pic/12058.png)", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training 2017] Xiao Y and the \"Terrifying Slave Owner\"", "background": "“A fight? Count me in!” Count me in for a fight.\n\n“Everyone, get in here!” Everyone, come here!", "description": "Xiao Y is an OIer who likes playing games. One day, she is playing a game and needs to fight a Boss.\n\nAlthough this Boss has $10^{100}$ HP, it only brings one minion — a \"Terrifying Slave Owner\" with exactly $m$ HP.\n\nThis \"Terrifying Slave Owner\" has a special skill: whenever it takes damage but does not die (death means HP $ \\leq 0$), and the number of the Boss's minions is less than the cap $k$, it summons a new \"Terrifying Slave Owner\" with $m$ HP.\n\nNow Xiao Y can make $n$ attacks. Each time she attacks, she chooses uniformly at random one target from the set consisting of the Boss and all of the Boss's minions, and reduces that target's HP by $1$. She wants to know the expected total HP deducted from the Boss after $n$ attacks. To avoid precision issues, your answer should be taken modulo $998244353$.", "inputFormat": "The first line contains three positive integers $T, m, k$, where $T$ is the number of queries, and $m, k$ are as defined in the statement.\n\nThen follow $T$ lines. Each line contains a positive integer $n$, representing a query asking for the expected HP deducted from the Boss after $n$ attacks.", "outputFormat": "Output $T$ lines. For each query, output a non-negative integer — the answer modulo $998244353$.\n\nIt can be proven that the desired expectation is a rational number. Suppose it equals $p / q$ $(\\mathrm{gcd}(p,q) = 1)$. Then the number $x$ you output should satisfy $p \\equiv qx \\pmod{998244353}$.", "hint": "[Sample 1 Explanation]\n\nFor the first query, the first attack has probability $\\frac{1}{2}$ to hit the Boss and probability $\\frac{1}{2}$ to hit the minion, so the answer is $\\frac{1}{2}$. $1 \\equiv 2 \\times 499122177 \\pmod{998244353}$.\n\nFor the second query: if the first attack hits the Boss, then there is probability $\\frac{1}{2}$ that the second attack still hits the Boss and probability $\\frac{1}{2}$ that it hits the minion; if the first attack hits the minion, then a new minion (the \"Terrifying Slave Owner\") is summoned, so there is probability $\\frac{1}{3}$ that the second attack hits the Boss and probability $\\frac{2}{3}$ that it hits a minion. Therefore the answer is $\\frac{1}{2}\\times\\frac{1}{2}\\times2+\\frac{1}{2}\\times\\frac{1}{2}\\times1+\\frac{1}{2}\\times\\frac{1}{3}\\times1+\\frac{1}{2}\\times\\frac{2}{3}\\times0 = \\frac{11}{12}$. $11 \\equiv 12 \\times 415935148\\pmod{998244353}$.\n\n[Tips]\n\nThe order of problems may not correspond to difficulty.\n\n[Subtasks]\n\nAcross all test points, $1 \\leq T \\leq 1000, 1 \\leq n \\leq {10}^{18}, 1 \\leq m \\leq 3, 1 \\leq k \\leq 8$.\n\nThe scores and Constraints for each test point are as follows:\n\n![12058](https://cdn.luogu.com.cn/upload/pic/12058.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] 小 Y 和恐怖的奴隶主", "background": "“A fight? Count me in!” 要打架了，算我一个。\n\n“Everyone, get in here!” 所有人，都过来！", "description": "小 Y 是一个喜欢玩游戏的 OIer。一天，她正在玩一款游戏，要打一个 Boss。\n\n虽然这个 Boss 有 $10^{100}$ 点生命值，但它只带了一个随从——一个只有 $m$ 点生命值的“恐怖的奴隶主”。\n\n这个“恐怖的奴隶主”有一个特殊的技能：每当它被扣减生命值但没有死亡（死亡即生命值 $\\leq 0$），且 Boss 的随从数量小于上限 $k$，便会召唤一个新的具有 $m$ 点生命值的“恐怖的奴隶主”。\n\n现在小 Y 可以进行 $n$ 次攻击，每次攻击时，会从 Boss 以及 Boss 的所有随从中的等概率随机选择一个，并扣减 $1$ 点生命值，她想知道进行 $n$ 次攻击后扣减 Boss 的生命值点数的期望。为了避免精度误差，你的答案需要对 $998244353$ 取模。", "inputFormat": "输入第一行包含三个正整数 $T, m, k$，$T$ 表示询问组数，$m, k$ 的含义见题目描述。\n\n接下来 $T$ 行，每行包含一个正整数 $n$，表示询问进行 $n$ 次攻击后扣减Boss的生命值点数的期望。", "outputFormat": "输出共 $T$ 行，对于每个询问输出一行一个非负整数，表示该询问的答案对 $998244353$ 取模的结果。\n\n可以证明，所求期望一定是一个有理数，设其为 $p / q$ $(\\mathrm{gcd}(p,q) = 1)$，那么你输出的数 $x$ 要满足 $p \\equiv qx \\pmod{998244353}$。", "hint": "【样例 $1$ 解释】\n\n对于第一次询问，第一次攻击有 $\\frac{1}{2}$ 的概率扣减 Boss 的生命值，有 $\\frac{1}{2}$ 的概率扣减随从的生命值，所以答案为 $\\frac{1}{2}$。$1 \\equiv 2 \\times 499122177 \\pmod{998244353}$。\n\n对于第二次询问，如果第一次攻击扣减了 Boss 的生命值，那么有 $\\frac{1}{2}$ 的概率第二次攻击仍扣减 Boss 的生命值，有 $\\frac{1}{2}$ 的概率第二次攻击扣减随从的生命值；如果第一次攻击扣减了随从的生命值，那么现在又新召唤了一个随从（“恐怖的奴隶主”），于是有 $\\frac{1}{3}$ 的概率第二次攻击扣减 Boss 的生命值，有 $\\frac{2}{3}$ 的概率第二次攻击扣减随从的生命值。所以答案为 $\\frac{1}{2}\\times\\frac{1}{2}\\times2+\\frac{1}{2}\\times\\frac{1}{2}\\times1+\\frac{1}{2}\\times\\frac{1}{3}\\times1+\\frac{1}{2}\\times\\frac{2}{3}\\times0 = \\frac{11}{12}$。 $11 \\equiv 12 \\times 415935148\\pmod{998244353}$。\n\n【提示】\n\n题目顺序可能与难度无关。\n\n【子任务】\n\n在所有测试点中，$1 \\leq T \\leq 1000, 1 \\leq n \\leq {10}^{18}, 1 \\leq m \\leq 3, 1 \\leq k \\leq 8$。\n\n各个测试点的分值和数据范围如下：\n\n![12058](https://cdn.luogu.com.cn/upload/pic/12058.png)", "locale": "zh-CN"}}}
{"pid": "P4008", "type": "P", "difficulty": 6, "samples": [["15\nInsert 26\nabcdefghijklmnop\nqrstuv wxy\nMove 15\nDelete 11\nMove 5\nInsert 1\n^\nNext\nInsert 1\n_\nNext\nNext\nInsert 4\n.\\/.\nGet 4\nPrev\nInsert 1\n^\nMove 0\nGet 22\n\n", ".\\/.\nabcde^_^f.\\/.ghijklmno\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "2003", "平衡树", "递归", "NOI", "分块"], "title": "[NOI2003] 文本编辑器", "background": null, "description": "很久很久以前，DOS 3.x 的程序员们开始对 `EDLIN` 感到厌倦。于是，人们开始纷纷改用自己写的文本编辑器⋯⋯\n\n多年之后，出于偶然的机会，小明找到了当时的一个编辑软件。进行了一些简单的测试后，小明惊奇地发现：那个软件每秒能够进行上万次编辑操作（当然，你不能手工进行这样的测试）！于是，小明废寝忘食地想做一个同样的东西出来。你能帮助他吗？\n\n为了明确目标，小明对“文本编辑器”做了一个抽象的定义：\n\n文本：由 $0$ 个或多个 ASCII 码在闭区间 $\\left[32,126\\right]$ 内的字符构成的序列。\n\n光标：在一段文本中用于指示位置的标记，可以位于文本首部，文本尾部或文本的某两个字符之间。\n\n文本编辑器：由一段文本和该文本中的一个光标组成的，支持如下操作的数据结构。如果这段文本为空，我们就说这个文本编辑器是空的。\n\n| 操作名称                 | 输入文件中的格式   | 功能                                         |\n| :------------------- | :--------- | :----------------------------------------- |\n| $\\text{Move}(k)$     | Move k     | 将光标移动到第 $k$ 个字符之后，如果 $k=0$，将光标移到文本开头。      |\n| $\\text{Insert}(n,s)$ | Insert n s | 在光标处插入长度为 $n$ 的字符串 $s$，光标位置不变 保证 $n\\geq1$。 |\n| $\\text{Delete}(n)$   | Delete n   | 删除光标后的 $n$ 个字符，光标位置不变，保证 $n \\geq 1$。       |\n| $\\text{Get}(n)$      | Get n      | 输出光标后的 $n$ 个字符，光标位置不变，保证 $n \\geq 1$。       |\n| $\\text{Prev}()$      | Prev       | 光标前移一个字符。                                  |\n| $\\text{Next}()$      | Next       | 光标后移一个字符。                                  |\n\n你的任务是：\n\n- 建立一个空的文本编辑器。\n\n- 从输入文件中读入一些操作并执行。\n\n- 对所有执行过的 `GET` 操作，将指定的内容写入输出文件。", "inputFormat": "输入文件 `editor.in` 的第一行是指令条数 $t$，以下是需要执行的 $t$ 个操作。其中：\n\n为了使输入文件便于阅读，`Insert` 操作的字符串中可能会插入一些回车符，请忽略掉它们（如果难以理解这句话，可以参照样例）。\n\n除了回车符之外，输入文件的所有字符的 ASCII 码都在闭区间 $\\left[32,126\\right]$ 内。行尾没有空格。\n\n这里我们有如下假定：\n\n- `Move` 操作不超过 $5 \\times 10^4$ 个，`Insert` 和 `Delete` 操作的总个数不超过 $4 \\times 10^3$，`Prev` 和 `Next` 操作的总个数不超过 $2 \\times 10^5$。\n\n- 所有 `INSERT` 插入的字符数之和不超过 $2$ MB（$1$ MB = $1024\\times 1024$ 字节），正确的输出文件长度不超过 $3$ MB。\n\n- `Delete` 操作和 `Get` 操作执行时光标后必然有足够的字符。`Move`、`Prev`、`Next` 操作必然不会试图把光标移动到非法位置。\n\n- 输入文件没有错误。\n\n对 C++ 选手的提示：经测试，最大的测试数据使用 `fstream` 进行输入有可能会比使用 `stdio` 慢约 $1$ 秒。", "outputFormat": "输出文件 `editor.out` 的每行依次对应输入文件中每条 `Get` 指令的输出。", "hint": ":::info[关于样例输出]\n第一个操作插入 `abcdefghijklmnopqrstuv wxy`，完成后文本变为 `abcdefghijklmnopqrstuv wxy`。\n\n第三个操作在第 $15$ 个字符后面删除 $11$ 个字符，完成后文本变为 `abcdefghijklmno`。\n\n第五个操作在第 $5$ 个字符后面插入 `^`，第七个操作在第 $6$ 个字符后面插入 `_`，完成后文本变为 `abcde^_fghijklmno`。\n\n第十个操作在第 $8$ 个字符后面插入 `.\\/.`，完成后文本变为 `abcde^_f.\\/.ghijklmno`。\n\n第十一个操作获取第 $8$ 个字符后面的 $4$ 个字符，输出 `.\\/.`。\n\n第十三个操作在第 $7$ 个字符后面插入 `^`，完成后文本变为 `abcde^_^f.\\/.ghijklmno`。\n\n第十五个操作获取开头后面的 $22$ 个字符，输出 `abcde^_^f.\\/.ghijklmno`。\n:::", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2003] Text Editor", "background": "", "description": "A long time ago, programmers using DOS 3.x grew tired of `EDLIN`. So, people started switching to their own text editors...\n\nMany years later, by chance, Xiaoming found one of those editors. After running some simple tests, he was surprised to find that the software could perform over ten thousand editing operations per second (of course, you cannot perform such a test by hand). Xiaoming became determined to build something similar. Can you help him?\n\nTo clarify the goal, Xiaoming gives an abstract definition of a \"text editor\":\n\nText: A sequence consisting of $0$ or more characters whose ASCII codes lie in the closed interval $\\left[32,126\\right]$.\n\nCursor: A marker indicating a position within a text. It can be at the beginning of the text, at the end of the text, or between any two characters.\n\nText editor: A data structure composed of a piece of text and a cursor within the text, supporting the following operations. If the text is empty, we say the text editor is empty.\n\n| Operation name            | Format in input file | Function                                                                 |\n| :------------------------ | :------------------- | :------------------------------------------------------------------------ |\n| $\\text{Move}(k)$          | Move k               | Move the cursor to the position after the $k$-th character; if $k = 0$, move the cursor to the beginning of the text. |\n| $\\text{Insert}(n,s)$      | Insert n s           | Insert the string $s$ of length $n$ at the cursor. The cursor position does not change. Guarantee that $n \\geq 1$. |\n| $\\text{Delete}(n)$        | Delete n             | Delete the $n$ characters after the cursor. The cursor position does not change. Guarantee that $n \\geq 1$. |\n| $\\text{Get}(n)$           | Get n                | Output the $n$ characters after the cursor. The cursor position does not change. Guarantee that $n \\geq 1$. |\n| $\\text{Prev}()$           | Prev                 | Move the cursor one character to the left.                                |\n| $\\text{Next}()$           | Next                 | Move the cursor one character to the right.                               |\n\nYour task is:\n\n- Build an empty text editor.\n- Read a sequence of operations from the input file and execute them.\n- For every executed `GET` operation, write the specified content to the output file.", "inputFormat": "The first line of the input file `editor.in` contains the number of commands $t$. Then follow the $t$ operations to perform.\n\nTo make the input file easier to read, newline characters may be inserted into the string of an `Insert` operation; please ignore them (if this is unclear, refer to the sample).\n\nExcept for newline characters, the ASCII codes of all characters in the input file lie in the closed interval $\\left[32,126\\right]$. There are no trailing spaces at the ends of lines.\n\nWe make the following assumptions:\n\n- The number of `Move` operations does not exceed $5 \\times 10^4$, the total number of `Insert` and `Delete` operations does not exceed $4 \\times 10^3$, and the total number of `Prev` and `Next` operations does not exceed $2 \\times 10^5$.\n- The total number of characters inserted by all `INSERT` operations does not exceed $2$ MB ($1$ MB = $1024 \\times 1024$ bytes), and the length of the correct output file does not exceed $3$ MB.\n- When executing `Delete` and `Get`, there are always enough characters after the cursor. `Move`, `Prev`, and `Next` will never attempt to move the cursor to an invalid position.\n- The input file contains no errors.\n\nHint for C++ contestants: As tested, on the largest testdata, using `fstream` for input may be about $1$ second slower than using `stdio`.", "outputFormat": "Each line of the output file `editor.out` corresponds, in order, to the output of each `Get` command in the input file.", "hint": ":::info[About the sample output]\nThe first operation inserts `abcdefghijklmnopqrstuv wxy`, resulting in the text `abcdefghijklmnopqrstuv wxy`.\n\nThe third operation deletes $11$ characters after the $15$-th character, resulting in the text `abcdefghijklmno`.\n\nThe fifth operation inserts `^` after the $5$-th character, and the seventh operation inserts `_` after the $6$-th character, resulting in the text `abcde^_fghijklmno`.\n\nThe tenth operation inserts `.\\/.` after the $8$-th character, resulting in the text `abcde^_f.\\/.ghijklmno`.\n\nThe eleventh operation gets the $4$ characters after the $8$-th character and outputs `.\\/.`.\n\nThe thirteenth operation inserts `^` after the $7$-th character, resulting in the text `abcde^_^f.\\/.ghijklmno`.\n\nThe fifteenth operation gets the $22$ characters after the beginning and outputs `abcde^_^f.\\/.ghijklmno`.\n:::\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2003] 文本编辑器", "background": null, "description": "很久很久以前，DOS 3.x 的程序员们开始对 `EDLIN` 感到厌倦。于是，人们开始纷纷改用自己写的文本编辑器⋯⋯\n\n多年之后，出于偶然的机会，小明找到了当时的一个编辑软件。进行了一些简单的测试后，小明惊奇地发现：那个软件每秒能够进行上万次编辑操作（当然，你不能手工进行这样的测试）！于是，小明废寝忘食地想做一个同样的东西出来。你能帮助他吗？\n\n为了明确目标，小明对“文本编辑器”做了一个抽象的定义：\n\n文本：由 $0$ 个或多个 ASCII 码在闭区间 $\\left[32,126\\right]$ 内的字符构成的序列。\n\n光标：在一段文本中用于指示位置的标记，可以位于文本首部，文本尾部或文本的某两个字符之间。\n\n文本编辑器：由一段文本和该文本中的一个光标组成的，支持如下操作的数据结构。如果这段文本为空，我们就说这个文本编辑器是空的。\n\n| 操作名称                 | 输入文件中的格式   | 功能                                         |\n| :------------------- | :--------- | :----------------------------------------- |\n| $\\text{Move}(k)$     | Move k     | 将光标移动到第 $k$ 个字符之后，如果 $k=0$，将光标移到文本开头。      |\n| $\\text{Insert}(n,s)$ | Insert n s | 在光标处插入长度为 $n$ 的字符串 $s$，光标位置不变 保证 $n\\geq1$。 |\n| $\\text{Delete}(n)$   | Delete n   | 删除光标后的 $n$ 个字符，光标位置不变，保证 $n \\geq 1$。       |\n| $\\text{Get}(n)$      | Get n      | 输出光标后的 $n$ 个字符，光标位置不变，保证 $n \\geq 1$。       |\n| $\\text{Prev}()$      | Prev       | 光标前移一个字符。                                  |\n| $\\text{Next}()$      | Next       | 光标后移一个字符。                                  |\n\n你的任务是：\n\n- 建立一个空的文本编辑器。\n\n- 从输入文件中读入一些操作并执行。\n\n- 对所有执行过的 `GET` 操作，将指定的内容写入输出文件。", "inputFormat": "输入文件 `editor.in` 的第一行是指令条数 $t$，以下是需要执行的 $t$ 个操作。其中：\n\n为了使输入文件便于阅读，`Insert` 操作的字符串中可能会插入一些回车符，请忽略掉它们（如果难以理解这句话，可以参照样例）。\n\n除了回车符之外，输入文件的所有字符的 ASCII 码都在闭区间 $\\left[32,126\\right]$ 内。行尾没有空格。\n\n这里我们有如下假定：\n\n- `Move` 操作不超过 $5 \\times 10^4$ 个，`Insert` 和 `Delete` 操作的总个数不超过 $4 \\times 10^3$，`Prev` 和 `Next` 操作的总个数不超过 $2 \\times 10^5$。\n\n- 所有 `INSERT` 插入的字符数之和不超过 $2$ MB（$1$ MB = $1024\\times 1024$ 字节），正确的输出文件长度不超过 $3$ MB。\n\n- `Delete` 操作和 `Get` 操作执行时光标后必然有足够的字符。`Move`、`Prev`、`Next` 操作必然不会试图把光标移动到非法位置。\n\n- 输入文件没有错误。\n\n对 C++ 选手的提示：经测试，最大的测试数据使用 `fstream` 进行输入有可能会比使用 `stdio` 慢约 $1$ 秒。", "outputFormat": "输出文件 `editor.out` 的每行依次对应输入文件中每条 `Get` 指令的输出。", "hint": ":::info[关于样例输出]\n第一个操作插入 `abcdefghijklmnopqrstuv wxy`，完成后文本变为 `abcdefghijklmnopqrstuv wxy`。\n\n第三个操作在第 $15$ 个字符后面删除 $11$ 个字符，完成后文本变为 `abcdefghijklmno`。\n\n第五个操作在第 $5$ 个字符后面插入 `^`，第七个操作在第 $6$ 个字符后面插入 `_`，完成后文本变为 `abcde^_fghijklmno`。\n\n第十个操作在第 $8$ 个字符后面插入 `.\\/.`，完成后文本变为 `abcde^_f.\\/.ghijklmno`。\n\n第十一个操作获取第 $8$ 个字符后面的 $4$ 个字符，输出 `.\\/.`。\n\n第十三个操作在第 $7$ 个字符后面插入 `^`，完成后文本变为 `abcde^_^f.\\/.ghijklmno`。\n\n第十五个操作获取开头后面的 $22$ 个字符，输出 `abcde^_^f.\\/.ghijklmno`。\n:::", "locale": "zh-CN"}}}
{"pid": "P4009", "type": "P", "difficulty": 5, "samples": [["9 3 2 3 6\n0 0 0 0 1 0 0 0 0\n0 0 0 1 0 1 1 0 0\n1 0 1 0 0 0 0 1 0\n0 0 0 0 0 1 0 0 1\n1 0 0 1 0 0 1 0 0\n0 1 0 0 0 0 0 1 0\n0 0 0 0 1 0 0 0 1\n1 0 0 1 0 0 0 1 0\n0 1 0 0 0 0 0 0 0", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["O2优化", "图论建模", "最短路", "费用流", "网络流与线性规划 24 题"], "title": "汽车加油行驶问题", "background": null, "description": "给定一个 $N \\times N$ 的方形网格，设其左上角为起点◎，坐标$(1,1)$，$X$ 轴向右为正，$Y$ 轴向下为正，每个方格边长为 $1$，如图所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/12156.png)\n\n一辆汽车从起点◎出发驶向右下角终点▲，其坐标为 $(N,N)$。\n\n在若干个网格交叉点处，设置了油库，可供汽车在行驶途中加油。汽车在行驶过程中应遵守如下规则：\n\n1. 汽车只能沿网格边行驶，装满油后能行驶 $K$ 条网格边。出发时汽车已装满油，在起点与终点处不设油库。\n\n1. 汽车经过一条网格边时，若其 $X$ 坐标或 $Y$ 坐标减小，则应付费用 $B$ ，否则免付费用。\n\n1. 汽车在行驶过程中遇油库则应加满油并付加油费用 $A$。\n\n1. 在需要时可在网格点处增设油库，并付增设油库费用 $C$（不含加油费用$A$）。\n\n1. $N,K,A,B,C$ 均为正整数，且满足约束：$2\\leq N\\leq 100,2 \\leq K \\leq 10$。\n\n设计一个算法，求出汽车从起点出发到达终点所付的最小费用。", "inputFormat": "文件的第一行是 $N,K,A,B,C$ 的值。\n\n第二行起是一个 $N\\times N$ 的 $0-1$ 方阵，每行 $N$ 个值，至 $N+1$ 行结束。\n\n方阵的第 $i$ 行第 $j$ 列处的值为 $1$ 表示在网格交叉点 $(i,j)$ 处设置了一个油库，为 $0$ 时表示未设油库。各行相邻两个数以空格分隔。", "outputFormat": "程序运行结束时，输出最小费用。", "hint": "$2 \\leq n \\leq 100,2 \\leq k \\leq 10$。", "locale": "zh-CN", "translations": {"en": {"title": "Car Refueling on a Grid", "background": "", "description": "Given an $N \\times N$ square grid with the top-left corner as the start point ◎ at coordinates $(1, 1)$, where the $X$-axis increases to the right and the $Y$-axis increases downward, and each grid cell has side length $1$, as shown in the figure.\n\n![](https://cdn.luogu.com.cn/upload/pic/12156.png)\n\nA car starts from ◎ and drives to the bottom-right corner ▲ at coordinates $(N, N)$.\n\nFuel depots are set at some grid intersections, where the car can refuel during the trip. The car must follow these rules:\n\n1. The car can move only along grid edges, and with a full tank it can travel $K$ grid edges. The car starts with a full tank. There are no depots at the start or end points.\n2. When the car traverses a grid edge, if its $X$-coordinate or $Y$-coordinate decreases, it must pay a fee of $B$; otherwise, there is no fee.\n3. When the car encounters a depot during the trip, it must refuel to full and pay a refueling cost of $A$.\n4. When needed, a new depot may be added at a grid point by paying an installation cost of $C$ (this does not include the refueling cost $A$).\n5. $N, K, A, B, C$ are all positive integers and satisfy the constraints $2 \\leq N \\leq 100, 2 \\leq K \\leq 10$.\n\nDesign an algorithm to compute the minimum total cost for the car to travel from the start to the destination.", "inputFormat": "The first line contains the values of $N, K, A, B, C$.\n\nStarting from the second line, an $N \\times N$ binary matrix is given, ending at line $N + 1$, with $N$ values per row.\n\nIf the value at row $i$, column $j$ is $1$, it means a fuel depot is set at the grid intersection $(i, j)$; if it is $0$, no depot is set there. Adjacent numbers in the same row are separated by spaces.", "outputFormat": "Output the minimum total cost at the end of the program.", "hint": "Constraints: $2 \\leq N \\leq 100, 2 \\leq K \\leq 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "汽车加油行驶问题", "background": null, "description": "给定一个 $N \\times N$ 的方形网格，设其左上角为起点◎，坐标$(1,1)$，$X$ 轴向右为正，$Y$ 轴向下为正，每个方格边长为 $1$，如图所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/12156.png)\n\n一辆汽车从起点◎出发驶向右下角终点▲，其坐标为 $(N,N)$。\n\n在若干个网格交叉点处，设置了油库，可供汽车在行驶途中加油。汽车在行驶过程中应遵守如下规则：\n\n1. 汽车只能沿网格边行驶，装满油后能行驶 $K$ 条网格边。出发时汽车已装满油，在起点与终点处不设油库。\n\n1. 汽车经过一条网格边时，若其 $X$ 坐标或 $Y$ 坐标减小，则应付费用 $B$ ，否则免付费用。\n\n1. 汽车在行驶过程中遇油库则应加满油并付加油费用 $A$。\n\n1. 在需要时可在网格点处增设油库，并付增设油库费用 $C$（不含加油费用$A$）。\n\n1. $N,K,A,B,C$ 均为正整数，且满足约束：$2\\leq N\\leq 100,2 \\leq K \\leq 10$。\n\n设计一个算法，求出汽车从起点出发到达终点所付的最小费用。", "inputFormat": "文件的第一行是 $N,K,A,B,C$ 的值。\n\n第二行起是一个 $N\\times N$ 的 $0-1$ 方阵，每行 $N$ 个值，至 $N+1$ 行结束。\n\n方阵的第 $i$ 行第 $j$ 列处的值为 $1$ 表示在网格交叉点 $(i,j)$ 处设置了一个油库，为 $0$ 时表示未设油库。各行相邻两个数以空格分隔。", "outputFormat": "程序运行结束时，输出最小费用。", "hint": "$2 \\leq n \\leq 100,2 \\leq k \\leq 10$。", "locale": "zh-CN"}}}
{"pid": "P4010", "type": "P", "difficulty": 6, "samples": [["5\n2 1\n2 2\n2 3\n2 4\n3 1\n1 1\n1 2\n1 3\n3 2", "42/43"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "O2优化", "CTSC/CTS"], "title": "[CTSC2012] 梭哈游戏", "background": "", "description": "小 Y 和小 Z 最近迷上了一种叫梭哈的扑克游戏。梭哈又称沙蟹，是英文 Show Hand 的音译，是一种使用黑桃、红心、梅花、方片的 A 到 K 共 $52$ 张牌(没有大小王）来进行的扑克牌游戏。\n\n和其他扑克游戏一样，梭哈的目的是得到最大的牌型并赢得牌局：每名玩家首先需要下基本的注额，之后将获得一张底牌，这张牌只有自己知道。普通梭哈游戏的规则是，在发完底牌后的第一轮时，每个玩家都将得到一张明牌（明牌是摆在台面上的，所有人都能看见），拥有最大明牌的玩家首先发言，他可以下注、不下注（让牌）或盖牌（放弃）也可以全压（梭哈），其他玩家可以跟注（有玩家全压时必须全压）、加注或盖牌（放弃），放弃的玩家将无法继续游戏，并且之\n\n前押的筹码无法取回。而全压之后将直接把每个人的手牌补充至 $5$ 张进行最后的判定；第二圈、第三圈和第四圈的进程与第一圈是类似的。最后，每位玩家要比牌型的大小以确定赢家。牌最大的玩家赢得牌局。\n\n所有五张牌的组合，按以下秩序， 由大至小 排行分为不同牌型：\n\n1、同花顺（`Straight Flush`）：同一花色，顺序的牌。 例： $Q♦ J♦ 10♦ 9♦ 8♦$；\n\n2、四条（`Four of a Kind`）：有四张同一点数的牌。 例： $10♣ 10♦ 10♥ 10♠ 9♥$；\n\n3、满堂红（`Full House`）：三张同一点数的牌，加一对其他点数的牌。 例： $8♣ 8♦ 8♠ K♥ K♠$；\n\n4、同花（`Flush`）：五张同一花色的牌。 例： $A♠ K♠ 10♠ 9♠ 8♠$；\n\n5、顺子（`Straight`）：五张顺连的牌。 例： $K♦ Q♥ J♠ 10♦ 9♦$；\n\n6、三条（`Three of a kind`）：有三张同一点数的牌。 例： $J♣ J♥ J♠ K♦ 9♠$；\n\n7、两对（`Two Pairs`）：两张相同点数的牌，加另外两张相同点数的牌。 例： $A♣ A♦ 8♥ 8♠ Q♠$；\n\n8、一对（`One Pair`）：两张相同点数的牌。 例： $9♥ 9♠ A♣ J♠ 8♥$；\n\n9、无对（`Zilch`）：不能排成以上组合的牌，以点数决定大小。例： $A♦ Q♦ J♠ 9♣ 8♣$。\n\n若牌型一样则 利用 点数 和花色决定胜负 。（点数 优先）\n\n点数 的顺序（ 从 大至小） 为：$A>K>Q>J>10>9>8>7>6>5>4>3>2$。（注：当 $5$ 张手牌是 $5, 4, 3, 2, A$ 的时候，$A$ 可以看作最小的牌，此时的牌型仍然为顺子，是顺子里面最小的一个）。\n\n花色的顺序（大至小） 为：黑桃(♠)$>$红心(♥)$>$梅花(♣)$>$方块(♦)。\n\n举例说明：\n\n1、$Q♦ J♦ 10♦ 9♦ 8♦ > 8♣ 8♥ 8♠ K♥ K♠$ （前者牌型为同花顺，比后者大）；\n\n2、$9♣ 9♦ 9♠ Q♥ Q♠ > 8♣ 8♦ 8♠ K♥ K♠$ （两者牌型均为满堂红，比较牌型中三张同一点数的牌 $9$ 比 $8$ 大）；\n\n3、$A♣ A♦ 8♥ 8♠ Q♠ > A♠ A♥ 7♥ 7♠ K♠$ （两者牌型均为两对，且最大的对子相同，此时比较次大的对子，$8$ 比 $7$ 大）；\n\n4、$A♠ Q♠ J♥ 9♥ 8♥ > A♦ Q♦ J♠ 9♣ 8♣$ （两者牌型均为无对，所有数码均相同，此时比较最大牌的花色，$A♠$ > $A♦$）。\n\n5、$4♠ 4♥ A♦ Q♦ 5♦ > 4♣ 4♦ A♠ Q♠ 5♠$ （两者牌型均为一对，所有数码均相同，此时对 4 为牌型里最大的部分，因此比较 $4♠ > 4♣$）\n\n在小 Y 和小 Z 玩梭哈的过程中，小 Y 总希望能够实时了解目前的形势，即根据自己手上的牌算出自己的胜率。但是他的编程能力有限，你能帮他完成这个任务么？\n", "inputFormat": "第一行包含 $1$ 个正整数 $N$，表示小 Y 自己手上牌的数量。\n\n接下来 $N$ 行每行用两个整数描述一张小 Y 手上的牌：第一个数表示牌的数码（$1$ 表示 $A$，$13$ 表示 $K$，$12$ 表示 $Q$，$11$ 表示 $J$），第二个数表示牌的花色（$1$ 表示黑桃，$2$ 表示红心，$3$ 表示梅花，$4$ 表示方块）。\n\n接下来 $N – 1$ 行每行用两个整数描述一张小 Z 手上的明牌：第一个数表示牌的数码（$1$ 表示 $A$，$13$ 表示 $K$，$12$ 表示 $Q$，$11$ 表示 $J$），第二个数表示牌的花色（$1$ 表示黑桃，$2$ 表示红心，$3$ 表示梅花，$4$ 表示方块）。\n", "outputFormat": "输出仅包含一行，格式为 `A/B` 形式。$A$, $B$ 为两个互质的自然数，`A/B` 表示了小 Y 当前局面下的获胜可能性。特别的，若 $A$ 为 $0$，则应输出 `0/1`。\n", "hint": "【样例说明】\n\n小 Y 手上牌的型是 $4$ 条，小 Z 若底牌是方块 $A$ 则也能构成 $4$ 条，并通过数码大获胜 。其他情况下都是小 Y 获胜。\n\n【数据规模和约定】\n\n对于 $10\\%$ 的数据，$N = 5$;\n\n对于 $30\\%$ 的数据，$3 \\leq N \\leq 5$;\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2012] Show Hand Game", "background": "", "description": "Xiao Y and Xiao Z have recently become obsessed with a poker game called Show Hand. Show Hand (Chinese: 梭哈, also called 沙蟹) is a poker game played with $52$ cards from $A$ to $K$ in spades, hearts, clubs, and diamonds (no jokers).\n\nAs with other poker games, the goal in Show Hand is to obtain the highest-ranking hand and win the pot. Each player first places an ante, then receives one hole card, which only the player can see. In the first round after the hole card is dealt, each player receives one upcard (face-up on the table, visible to everyone). The player with the highest upcard acts first and may bet, check, fold, or go all-in (“Show Hand”). Other players may call (if someone has gone all-in, they must also go all-in to call), raise, or fold. A player who folds cannot continue in the game, and the chips they have already bet cannot be retrieved. After an all-in, all players’ hands are immediately filled to $5$ cards for the final showdown. The second, third, and fourth rounds proceed in a similar way. Finally, each player compares hand ranks to determine the winner. The player with the highest hand wins.\n\nAll $5$-card combinations are ranked from highest to lowest as follows:\n\n1. Straight Flush: five consecutive cards of the same suit. Example: $Q♦ J♦ 10♦ 9♦ 8♦$.\n\n2. Four of a Kind: four cards of the same rank. Example: $10♣ 10♦ 10♥ 10♠ 9♥$.\n\n3. Full House: three cards of one rank plus a pair of another rank. Example: $8♣ 8♦ 8♠ K♥ K♠$.\n\n4. Flush: five cards of the same suit. Example: $A♠ K♠ 10♠ 9♠ 8♠$.\n\n5. Straight: five consecutive ranks. Example: $K♦ Q♥ J♠ 10♦ 9♦$.\n\n6. Three of a Kind: three cards of the same rank. Example: $J♣ J♥ J♠ K♦ 9♠$.\n\n7. Two Pairs: two cards of one rank plus two cards of another rank. Example: $A♣ A♦ 8♥ 8♠ Q♠$.\n\n8. One Pair: two cards of the same rank. Example: $9♥ 9♠ A♣ J♠ 8♥$.\n\n9. Zilch: none of the above; compare ranks to decide. Example: $A♦ Q♦ J♠ 9♣ 8♣$.\n\nIf the hand types are the same, use ranks and then suits to break ties (ranks have priority).\n\nThe order of ranks (from high to low) is $A > K > Q > J > 10 > 9 > 8 > 7 > 6 > 5 > 4 > 3 > 2$. Note: when the $5$ cards are $5, 4, 3, 2, A$, the $A$ can be treated as the lowest rank. In this case it is still a straight, which is the lowest straight.\n\nThe order of suits (from high to low) is spades (♠) > hearts (♥) > clubs (♣) > diamonds (♦).\n\nExamples:\n\n1. $Q♦ J♦ 10♦ 9♦ 8♦ > 8♣ 8♥ 8♠ K♥ K♠$ (the former is a Straight Flush, which is higher).\n\n2. $9♣ 9♦ 9♠ Q♥ Q♠ > 8♣ 8♦ 8♠ K♥ K♠$ (both are Full Houses; compare the triplets, $9$ beats $8$).\n\n3. $A♣ A♦ 8♥ 8♠ Q♠ > A♠ A♥ 7♥ 7♠ K♠$ (both are Two Pairs and the higher pair is the same; compare the lower pair, $8$ beats $7$).\n\n4. $A♠ Q♠ J♥ 9♥ 8♥ > A♦ Q♦ J♠ 9♣ 8♣$ (both are Zilch with exactly the same ranks; compare the highest card’s suit, $A♠ > A♦$).\n\n5. $4♠ 4♥ A♦ Q♦ 5♦ > 4♣ 4♦ A♠ Q♠ 5♠$ (both are One Pair with identical ranks; the pair of $4$s is the most significant component, so compare $4♠ > 4♣$).\n\nDuring their game, Xiao Y wants to know the current situation in real time—namely, to compute his winning probability based on his current cards. However, his programming skills are limited. Can you help him?", "inputFormat": "The first line contains $1$ positive integer $N$, the number of cards currently in Xiao Y’s hand.\n\nEach of the next $N$ lines contains two integers describing one card in Xiao Y’s hand: the first is the rank ($1$ denotes $A$, $13$ denotes $K$, $12$ denotes $Q$, $11$ denotes $J$), and the second is the suit ($1$ denotes spades, $2$ denotes hearts, $3$ denotes clubs, $4$ denotes diamonds).\n\nEach of the next $N - 1$ lines contains two integers describing one upcard in Xiao Z’s hand: the first is the rank ($1$ denotes $A$, $13$ denotes $K$, $12$ denotes $Q$, $11$ denotes $J$), and the second is the suit ($1$ denotes spades, $2$ denotes hearts, $3$ denotes clubs, $4$ denotes diamonds).", "outputFormat": "Output exactly one line in the form `A/B`. Here $A$ and $B$ are two coprime natural numbers, and `A/B` is Xiao Y’s probability of winning in the current situation. In particular, if $A$ is $0$, output `0/1`.", "hint": "Sample Explanation:\n\nXiao Y’s current hand type is Four of a Kind. If Xiao Z’s hole card is $A♦$, he can also make Four of a Kind and win by rank. In all other cases, Xiao Y wins.\n\nConstraints:\n\n- For $10\\%$ of the testdata, $N = 5$.\n- For $30\\%$ of the testdata, $3 \\leq N \\leq 5$.\n- For $100\\%$ of the testdata, $1 \\leq N \\leq 5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2012] 梭哈游戏", "background": "", "description": "小 Y 和小 Z 最近迷上了一种叫梭哈的扑克游戏。梭哈又称沙蟹，是英文 Show Hand 的音译，是一种使用黑桃、红心、梅花、方片的 A 到 K 共 $52$ 张牌(没有大小王）来进行的扑克牌游戏。\n\n和其他扑克游戏一样，梭哈的目的是得到最大的牌型并赢得牌局：每名玩家首先需要下基本的注额，之后将获得一张底牌，这张牌只有自己知道。普通梭哈游戏的规则是，在发完底牌后的第一轮时，每个玩家都将得到一张明牌（明牌是摆在台面上的，所有人都能看见），拥有最大明牌的玩家首先发言，他可以下注、不下注（让牌）或盖牌（放弃）也可以全压（梭哈），其他玩家可以跟注（有玩家全压时必须全压）、加注或盖牌（放弃），放弃的玩家将无法继续游戏，并且之\n\n前押的筹码无法取回。而全压之后将直接把每个人的手牌补充至 $5$ 张进行最后的判定；第二圈、第三圈和第四圈的进程与第一圈是类似的。最后，每位玩家要比牌型的大小以确定赢家。牌最大的玩家赢得牌局。\n\n所有五张牌的组合，按以下秩序， 由大至小 排行分为不同牌型：\n\n1、同花顺（`Straight Flush`）：同一花色，顺序的牌。 例： $Q♦ J♦ 10♦ 9♦ 8♦$；\n\n2、四条（`Four of a Kind`）：有四张同一点数的牌。 例： $10♣ 10♦ 10♥ 10♠ 9♥$；\n\n3、满堂红（`Full House`）：三张同一点数的牌，加一对其他点数的牌。 例： $8♣ 8♦ 8♠ K♥ K♠$；\n\n4、同花（`Flush`）：五张同一花色的牌。 例： $A♠ K♠ 10♠ 9♠ 8♠$；\n\n5、顺子（`Straight`）：五张顺连的牌。 例： $K♦ Q♥ J♠ 10♦ 9♦$；\n\n6、三条（`Three of a kind`）：有三张同一点数的牌。 例： $J♣ J♥ J♠ K♦ 9♠$；\n\n7、两对（`Two Pairs`）：两张相同点数的牌，加另外两张相同点数的牌。 例： $A♣ A♦ 8♥ 8♠ Q♠$；\n\n8、一对（`One Pair`）：两张相同点数的牌。 例： $9♥ 9♠ A♣ J♠ 8♥$；\n\n9、无对（`Zilch`）：不能排成以上组合的牌，以点数决定大小。例： $A♦ Q♦ J♠ 9♣ 8♣$。\n\n若牌型一样则 利用 点数 和花色决定胜负 。（点数 优先）\n\n点数 的顺序（ 从 大至小） 为：$A>K>Q>J>10>9>8>7>6>5>4>3>2$。（注：当 $5$ 张手牌是 $5, 4, 3, 2, A$ 的时候，$A$ 可以看作最小的牌，此时的牌型仍然为顺子，是顺子里面最小的一个）。\n\n花色的顺序（大至小） 为：黑桃(♠)$>$红心(♥)$>$梅花(♣)$>$方块(♦)。\n\n举例说明：\n\n1、$Q♦ J♦ 10♦ 9♦ 8♦ > 8♣ 8♥ 8♠ K♥ K♠$ （前者牌型为同花顺，比后者大）；\n\n2、$9♣ 9♦ 9♠ Q♥ Q♠ > 8♣ 8♦ 8♠ K♥ K♠$ （两者牌型均为满堂红，比较牌型中三张同一点数的牌 $9$ 比 $8$ 大）；\n\n3、$A♣ A♦ 8♥ 8♠ Q♠ > A♠ A♥ 7♥ 7♠ K♠$ （两者牌型均为两对，且最大的对子相同，此时比较次大的对子，$8$ 比 $7$ 大）；\n\n4、$A♠ Q♠ J♥ 9♥ 8♥ > A♦ Q♦ J♠ 9♣ 8♣$ （两者牌型均为无对，所有数码均相同，此时比较最大牌的花色，$A♠$ > $A♦$）。\n\n5、$4♠ 4♥ A♦ Q♦ 5♦ > 4♣ 4♦ A♠ Q♠ 5♠$ （两者牌型均为一对，所有数码均相同，此时对 4 为牌型里最大的部分，因此比较 $4♠ > 4♣$）\n\n在小 Y 和小 Z 玩梭哈的过程中，小 Y 总希望能够实时了解目前的形势，即根据自己手上的牌算出自己的胜率。但是他的编程能力有限，你能帮他完成这个任务么？\n", "inputFormat": "第一行包含 $1$ 个正整数 $N$，表示小 Y 自己手上牌的数量。\n\n接下来 $N$ 行每行用两个整数描述一张小 Y 手上的牌：第一个数表示牌的数码（$1$ 表示 $A$，$13$ 表示 $K$，$12$ 表示 $Q$，$11$ 表示 $J$），第二个数表示牌的花色（$1$ 表示黑桃，$2$ 表示红心，$3$ 表示梅花，$4$ 表示方块）。\n\n接下来 $N – 1$ 行每行用两个整数描述一张小 Z 手上的明牌：第一个数表示牌的数码（$1$ 表示 $A$，$13$ 表示 $K$，$12$ 表示 $Q$，$11$ 表示 $J$），第二个数表示牌的花色（$1$ 表示黑桃，$2$ 表示红心，$3$ 表示梅花，$4$ 表示方块）。\n", "outputFormat": "输出仅包含一行，格式为 `A/B` 形式。$A$, $B$ 为两个互质的自然数，`A/B` 表示了小 Y 当前局面下的获胜可能性。特别的，若 $A$ 为 $0$，则应输出 `0/1`。\n", "hint": "【样例说明】\n\n小 Y 手上牌的型是 $4$ 条，小 Z 若底牌是方块 $A$ 则也能构成 $4$ 条，并通过数码大获胜 。其他情况下都是小 Y 获胜。\n\n【数据规模和约定】\n\n对于 $10\\%$ 的数据，$N = 5$;\n\n对于 $30\\%$ 的数据，$3 \\leq N \\leq 5$;\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 5$。\n", "locale": "zh-CN"}}}
{"pid": "P4011", "type": "P", "difficulty": 5, "samples": [["4 4 9\n9\n1 2 1 3 2\n1 2 2 2 0\n2 1 2 2 0\n2 1 3 1 0\n2 3 3 3 0\n2 4 3 4 1\n3 2 3 3 0\n3 3 4 3 0\n4 3 4 4 0\n2\n2 1 2\n4 2 1", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["O2优化", "广度优先搜索 BFS", "图论建模", "进制", "网络流与线性规划 24 题", "状压 DP"], "title": "孤岛营救问题", "background": "", "description": "$1944$ 年，特种兵麦克接到国防部的命令，要求立即赶赴太平洋上的一个孤岛，营救被敌军俘虏的大兵瑞恩。瑞恩被关押在一个迷宫里，迷宫地形复杂，但幸好麦克得到了迷宫的地形图。迷宫的外形是一个长方形，其南北方向被划分为 $N$ 行，东西方向被划分为 $M$ 列，于是整个迷宫被划分为 $N\\times M$ 个单元。每一个单元的位置可用一个有序数对(单元的行号，单元的列号)来表示。南北或东西方向相邻的 $2$ 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。迷宫中有一些单元存放着钥匙，并且所有的门被分成$P$ 类，打开同一类的门的钥匙相同，不同类门的钥匙不同。\n\n\n大兵瑞恩被关押在迷宫的东南角，即 $(N,M)$ 单元里，并已经昏迷。迷宫只有一个入口，在西北角。也就是说，麦克可以直接进入 $(1,1)$ 单元。另外，麦克从一个单元移动到另一个相邻单元的时间为 $1$，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。\n\n\n试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。\n", "inputFormat": "第 $1$ 行有 $3$ 个整数，分别表示 $N,M,P$ 的值。\n\n第 $2$ 行是 $1$ 个整数 $K$，表示迷宫中门和墙的总数。\n\n第 $I+2$ 行$(1\\leq I\\leq K)$，有 $5$ 个整数，依次为$X_{i1},Y_{i1},X_{i2},Y_{i2},G_i$：\n\n- 当 $G_i \\geq 1$ 时，表示 $(X_{i1},Y_{i1})$ 单元与 $(X_{i2},Y_{i2})$ 单元之间有一扇第 $G_i$ 类的门\n\n- 当 $G_i=0$ 时，表示 $(X_{i1},Y_{i1})$ 单元与 $(X_{i2},Y_{i2})$ 单元之间有一堵不可逾越的墙（其中，$|X_{i1}-X_{i2}|+|Y_{i1}-Y_{i2}|=1$，$0\\leq G_i\\leq P$）。\n\n第 $K+3$ 行是一个整数 $S$，表示迷宫中存放的钥匙总数。\n\n第 $K+3+J$  行$(1\\leq J\\leq S)$，有 $3$ 个整数，依次为 $X_{i1},Y_{i1},Q_i$：表示第 $J$ 把钥匙存放在 $(X_{i1},Y_{i1})$单元里，并且第 $J$ 把钥匙是用来开启第 $Q_i$ 类门的。（其中$1\\leq Q_i\\leq P$）。\n\n输入数据中同一行各相邻整数之间用一个空格分隔。\n", "outputFormat": "将麦克营救到大兵瑞恩的最短时间的值输出。如果问题无解，则输出 $-1$。\n", "hint": "$|X_{i1}-X_{i2}|+|Y_{i1}-Y_{i2}|=1,0\\leq G_i\\leq P$\n\n$1\\leq Q_i\\leq P$\n\n\n$N,M,P\\leq10, K<150,S\\leq 14$\n", "locale": "zh-CN", "translations": {"en": {"title": "Isolated Island Rescue Problem", "background": "", "description": "In the year $1944$, special forces soldier Mike received an order from the Ministry of Defense to rush to a deserted island in the Pacific to rescue Private Ryan, who had been captured by the enemy. Ryan is imprisoned in a maze. The maze is complex, but fortunately Mike has obtained a map of it. The maze is rectangular, divided into $N$ rows from north to south and $M$ columns from west to east, so the entire maze consists of $N \\times M$ cells. The position of each cell is represented by an ordered pair (row, column). Two adjacent cells in the north-south or east-west direction may be connected, or there may be a locked door between them, or an impassable wall. Some cells contain keys. All doors are divided into $P$ classes; keys that open doors of the same class are identical, and keys for different classes are different.\n\nPrivate Ryan is held in the southeast corner of the maze, i.e., in cell $(N, M)$, and is unconscious. The maze has only one entrance at the northwest corner. That is, Mike can directly enter cell $(1, 1)$. The time for Mike to move from one cell to an adjacent cell is $1$. The time to pick up a key in the current cell and to unlock a door is negligible.\n\nDesign an algorithm to help Mike reach the cell where Ryan is as quickly as possible and rescue him.", "inputFormat": "- The first line contains $3$ integers, representing the values of $N$, $M$, and $P$.\n- The second line contains $1$ integer $K$, the total number of doors and walls in the maze.\n- The $I+2$-th line ($1 \\leq I \\leq K$) contains $5$ integers, in order $X_{i1}, Y_{i1}, X_{i2}, Y_{i2}, G_i$:\n  - When $G_i \\geq 1$, there is a class-$G_i$ door between cells $(X_{i1}, Y_{i1})$ and $(X_{i2}, Y_{i2})$.\n  - When $G_i = 0$, there is an impassable wall between cells $(X_{i1}, Y_{i1})$ and $(X_{i2}, Y_{i2})$ (where $|X_{i1} - X_{i2}| + |Y_{i1} - Y_{i2}| = 1$, $0 \\leq G_i \\leq P$).\n- The $K+3$-th line contains an integer $S$, the total number of keys in the maze.\n- The $K+3+J$-th line ($1 \\leq J \\leq S$) contains $3$ integers, in order $X_{j}, Y_{j}, Q_j$: the $J$-th key is placed in cell $(X_{j}, Y_{j})$, and it opens doors of class $Q_j$ (where $1 \\leq Q_j \\leq P$).\n\nAdjacent integers on the same line in the input are separated by a single space.", "outputFormat": "Output the minimum time for Mike to rescue Private Ryan. If the problem has no solution, output $-1$.", "hint": "$|X_{i1} - X_{i2}| + |Y_{i1} - Y_{i2}| = 1$, $0 \\leq G_i \\leq P$.\n\n$1 \\leq Q_j \\leq P$.\n\nConstraints: $N, M, P \\leq 10$, $K < 150$, $S \\leq 14$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "孤岛营救问题", "background": "", "description": "$1944$ 年，特种兵麦克接到国防部的命令，要求立即赶赴太平洋上的一个孤岛，营救被敌军俘虏的大兵瑞恩。瑞恩被关押在一个迷宫里，迷宫地形复杂，但幸好麦克得到了迷宫的地形图。迷宫的外形是一个长方形，其南北方向被划分为 $N$ 行，东西方向被划分为 $M$ 列，于是整个迷宫被划分为 $N\\times M$ 个单元。每一个单元的位置可用一个有序数对(单元的行号，单元的列号)来表示。南北或东西方向相邻的 $2$ 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。迷宫中有一些单元存放着钥匙，并且所有的门被分成$P$ 类，打开同一类的门的钥匙相同，不同类门的钥匙不同。\n\n\n大兵瑞恩被关押在迷宫的东南角，即 $(N,M)$ 单元里，并已经昏迷。迷宫只有一个入口，在西北角。也就是说，麦克可以直接进入 $(1,1)$ 单元。另外，麦克从一个单元移动到另一个相邻单元的时间为 $1$，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。\n\n\n试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。\n", "inputFormat": "第 $1$ 行有 $3$ 个整数，分别表示 $N,M,P$ 的值。\n\n第 $2$ 行是 $1$ 个整数 $K$，表示迷宫中门和墙的总数。\n\n第 $I+2$ 行$(1\\leq I\\leq K)$，有 $5$ 个整数，依次为$X_{i1},Y_{i1},X_{i2},Y_{i2},G_i$：\n\n- 当 $G_i \\geq 1$ 时，表示 $(X_{i1},Y_{i1})$ 单元与 $(X_{i2},Y_{i2})$ 单元之间有一扇第 $G_i$ 类的门\n\n- 当 $G_i=0$ 时，表示 $(X_{i1},Y_{i1})$ 单元与 $(X_{i2},Y_{i2})$ 单元之间有一堵不可逾越的墙（其中，$|X_{i1}-X_{i2}|+|Y_{i1}-Y_{i2}|=1$，$0\\leq G_i\\leq P$）。\n\n第 $K+3$ 行是一个整数 $S$，表示迷宫中存放的钥匙总数。\n\n第 $K+3+J$  行$(1\\leq J\\leq S)$，有 $3$ 个整数，依次为 $X_{i1},Y_{i1},Q_i$：表示第 $J$ 把钥匙存放在 $(X_{i1},Y_{i1})$单元里，并且第 $J$ 把钥匙是用来开启第 $Q_i$ 类门的。（其中$1\\leq Q_i\\leq P$）。\n\n输入数据中同一行各相邻整数之间用一个空格分隔。\n", "outputFormat": "将麦克营救到大兵瑞恩的最短时间的值输出。如果问题无解，则输出 $-1$。\n", "hint": "$|X_{i1}-X_{i2}|+|Y_{i1}-Y_{i2}|=1,0\\leq G_i\\leq P$\n\n$1\\leq Q_i\\leq P$\n\n\n$N,M,P\\leq10, K<150,S\\leq 14$\n", "locale": "zh-CN"}}}
{"pid": "P4012", "type": "P", "difficulty": 6, "samples": [["1 1\n2 2\n1 2\n3 4\n5 6\n7 2\n8 10\n9 3\n2 0 0\n2 2 2", "42"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["图论建模", "费用流", "网络流与线性规划 24 题"], "title": "深海机器人问题", "background": null, "description": "深海资源考察探险队的潜艇将到达深海的海底进行科学考察。\n\n\n潜艇内有多个深海机器人。潜艇到达深海海底后，深海机器人将离开潜艇向预定目标移动。\n\n\n深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。\n\n\n每条预定路径上的生物标本的价值是已知的，而且生物标本只能被采集一次。\n\n\n本题限定深海机器人只能从其出发位置沿着向北或向东的方向移动，而且多个深海机器人可以在同一时间占据同一位置。\n\n\n用一个 $P\\times Q$ 网格表示深海机器人的可移动位置。西南角的坐标为 $(0,0)$，东北角的坐标为 $(Q,P)$ 。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/12215.png) \n\n给定每个深海机器人的出发位置和目标位置，以及每条网格边上生物标本的价值。\n\n\n计算深海机器人的最优移动方案， 使深海机器人到达目的地后，采集到的生物标本的总价值最高。", "inputFormat": "文件的第 $1$ 行为深海机器人的出发位置数 $a$,和目的地数 $b$ 。\n\n\n第 $2$ 行为 $P$ 和 $Q$ 的值。\n\n\n接下来的 $P+1$ 行,每行有 $Q$ 个正整数，其中第 $i$ 行（从 0 开始计数）的第 $j$ 个（从 0 开始计数）正整数表示点 $(i,j)$ 到点 $(i,j+1)$ 的路径上生物标本的价值。\n\n\n再接下来的 $Q+1$ 行,每行有 $P$ 个正整数，其中第 $i$ 行（从 0 开始计数）的第 $j$ 个（从 0 开始计数）正整数表示点 $(j,i)$ 到点 $(j+1,i)$ 的路径上生物标本的价值。\n\n\n接下来的 $a$ 行，每行有三个正整数 $k,x,y$,表示有 $k$ 个深海机器人从 $(x,y)$ 位置坐标出发。\n\n\n再接下来的 $b$ 行，每行有三个正整数 $r,x,y$ ,表示有 $r$ 个深海机器人可选择 $(x,y)$ 位置坐标作为目的地。", "outputFormat": "输出采集到的生物标本的最高总价值.", "hint": "$1\\leq P,Q\\leq15$\n\n\n$1\\leq a\\leq 4$\n\n\n$1\\leq b\\leq 6$", "locale": "zh-CN", "translations": {"en": {"title": "Deep-Sea Robot Problem", "background": "", "description": "The submarine of a deep-sea resource exploration team will arrive at the ocean floor for scientific investigation.\n\nThere are multiple deep-sea robots inside the submarine. After reaching the seafloor, the robots will leave the submarine and move toward their predetermined targets.\n\nWhile moving, the robots must collect biological specimens along the way. Each specimen along the route is collected by the first robot that encounters it.\n\nThe value of specimens on each prescribed path (i.e., each grid edge) is known, and each specimen can be collected at most once.\n\nIn this problem, each robot may move only to the north or to the east from its current position. Multiple robots may occupy the same position at the same time.\n\nThe movable positions of the robots are represented by a $P \\times Q$ grid. The southwest corner has coordinates $(0,0)$, and the northeast corner has coordinates $(Q,P)$.\n\n![](https://cdn.luogu.com.cn/upload/pic/12215.png)\n\nGiven the starting positions and destination positions of each robot, as well as the specimen values on each grid edge, compute the optimal movement plan that maximizes the total value of collected specimens after all robots reach their destinations.", "inputFormat": "The first line contains the number of starting locations $a$ and the number of destination locations $b$.\n\nThe second line contains the values of $P$ and $Q$.\n\nThe next $P+1$ lines each contain $Q$ positive integers. In the $i$-th line (0-indexed), the $j$-th (0-indexed) integer gives the specimen value on the edge from $(i,j)$ to $(i,j+1)$.\n\nThe next $Q+1$ lines each contain $P$ positive integers. In the $i$-th line (0-indexed), the $j$-th (0-indexed) integer gives the specimen value on the edge from $(j,i)$ to $(j+1,i)$.\n\nThe next $a$ lines each contain three positive integers $k, x, y$, indicating that there are $k$ robots starting from position $(x,y)$.\n\nThe next $b$ lines each contain three positive integers $r, x, y$, indicating that there are $r$ robots that may choose position $(x,y)$ as a destination.", "outputFormat": "Output the maximum total value of collected specimens.", "hint": "$1 \\leq P, Q \\leq 15$.\n\n$1 \\leq a \\leq 4$.\n\n$1 \\leq b \\leq 6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "深海机器人问题", "background": null, "description": "深海资源考察探险队的潜艇将到达深海的海底进行科学考察。\n\n\n潜艇内有多个深海机器人。潜艇到达深海海底后，深海机器人将离开潜艇向预定目标移动。\n\n\n深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。\n\n\n每条预定路径上的生物标本的价值是已知的，而且生物标本只能被采集一次。\n\n\n本题限定深海机器人只能从其出发位置沿着向北或向东的方向移动，而且多个深海机器人可以在同一时间占据同一位置。\n\n\n用一个 $P\\times Q$ 网格表示深海机器人的可移动位置。西南角的坐标为 $(0,0)$，东北角的坐标为 $(Q,P)$ 。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/12215.png) \n\n给定每个深海机器人的出发位置和目标位置，以及每条网格边上生物标本的价值。\n\n\n计算深海机器人的最优移动方案， 使深海机器人到达目的地后，采集到的生物标本的总价值最高。", "inputFormat": "文件的第 $1$ 行为深海机器人的出发位置数 $a$,和目的地数 $b$ 。\n\n\n第 $2$ 行为 $P$ 和 $Q$ 的值。\n\n\n接下来的 $P+1$ 行,每行有 $Q$ 个正整数，其中第 $i$ 行（从 0 开始计数）的第 $j$ 个（从 0 开始计数）正整数表示点 $(i,j)$ 到点 $(i,j+1)$ 的路径上生物标本的价值。\n\n\n再接下来的 $Q+1$ 行,每行有 $P$ 个正整数，其中第 $i$ 行（从 0 开始计数）的第 $j$ 个（从 0 开始计数）正整数表示点 $(j,i)$ 到点 $(j+1,i)$ 的路径上生物标本的价值。\n\n\n接下来的 $a$ 行，每行有三个正整数 $k,x,y$,表示有 $k$ 个深海机器人从 $(x,y)$ 位置坐标出发。\n\n\n再接下来的 $b$ 行，每行有三个正整数 $r,x,y$ ,表示有 $r$ 个深海机器人可选择 $(x,y)$ 位置坐标作为目的地。", "outputFormat": "输出采集到的生物标本的最高总价值.", "hint": "$1\\leq P,Q\\leq15$\n\n\n$1\\leq a\\leq 4$\n\n\n$1\\leq b\\leq 6$", "locale": "zh-CN"}}}
{"pid": "P4013", "type": "P", "difficulty": 6, "samples": [["2 5\n2 3\n3 4 5\n9 10 9 1\n1 1 10 1 1\n1 1 10 12 1 1", "66\n75\n77"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["O2优化", "图论建模", "费用流", "网络流与线性规划 24 题"], "title": "数字梯形问题", "background": "", "description": "给定一个由 $n$ 行数字组成的数字梯形如下图所示。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/12216.png) \n\n梯形的第一行有 $m$ 个数字。从梯形的顶部的 $m$ 个数字开始，在每个数字处可以沿左下或右下方向移动，形成一条从梯形的顶至底的路径。\n\n\n分别遵守以下规则：\n\n\n1. 从梯形的顶至底的 $m$ 条路径互不相交；\n\n1. 从梯形的顶至底的 $m$ 条路径仅在数字结点处相交；\n\n1. 从梯形的顶至底的 $m$  条路径允许在数字结点相交或边相交。\n", "inputFormat": "第 $1$ 行中有 $2$ 个正整数 $m$ 和 $n$，分别表示数字梯形的第一行有 $m$ 个数字，共有 $n$ 行。接下来的 $n$ 行是数字梯形中各行的数字。\n\n第 $1$ 行有 $m$ 个数字，第 $2$ 行有 $m+1$ 个数字，以此类推。\n", "outputFormat": "将按照规则 $1$，规则 $2$，和规则 $3$ 计算出的最大数字总和并输出，每行一个最大总和。\n", "hint": "$1\\leq m,n \\leq 20$\n", "locale": "zh-CN", "translations": {"en": {"title": "Number Trapezoid Problem", "background": "", "description": "Given a number trapezoid with $n$ rows as shown in the figure.\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/12216.png) \n\nThe first row of the trapezoid contains $m$ numbers. Starting from each of the $m$ numbers in the top row, you may move at each step to the lower-left or lower-right adjacent number, forming a path from the top to the bottom of the trapezoid.\n\nRespect the following rules respectively:\n\n1. The $m$ top-to-bottom paths are pairwise disjoint (no common nodes or edges).\n2. The $m$ top-to-bottom paths may intersect only at numeric nodes (shared nodes allowed, shared edges not allowed).\n3. The $m$ top-to-bottom paths may intersect at numeric nodes or along edges (both nodes and edges may be shared).", "inputFormat": "The first line contains two positive integers $m$ and $n$, denoting that the first row of the number trapezoid has $m$ numbers and there are $n$ rows in total. The next $n$ lines give the numbers in each row of the trapezoid.\n\nRow $1$ has $m$ numbers, row $2$ has $m+1$ numbers, and so on.", "outputFormat": "Output the maximum total sum computed under Rule $1$, Rule $2$, and Rule $3$, respectively, one maximum sum per line.", "hint": "$1 \\leq m,n \\leq 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数字梯形问题", "background": "", "description": "给定一个由 $n$ 行数字组成的数字梯形如下图所示。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/12216.png) \n\n梯形的第一行有 $m$ 个数字。从梯形的顶部的 $m$ 个数字开始，在每个数字处可以沿左下或右下方向移动，形成一条从梯形的顶至底的路径。\n\n\n分别遵守以下规则：\n\n\n1. 从梯形的顶至底的 $m$ 条路径互不相交；\n\n1. 从梯形的顶至底的 $m$ 条路径仅在数字结点处相交；\n\n1. 从梯形的顶至底的 $m$  条路径允许在数字结点相交或边相交。\n", "inputFormat": "第 $1$ 行中有 $2$ 个正整数 $m$ 和 $n$，分别表示数字梯形的第一行有 $m$ 个数字，共有 $n$ 行。接下来的 $n$ 行是数字梯形中各行的数字。\n\n第 $1$ 行有 $m$ 个数字，第 $2$ 行有 $m+1$ 个数字，以此类推。\n", "outputFormat": "将按照规则 $1$，规则 $2$，和规则 $3$ 计算出的最大数字总和并输出，每行一个最大总和。\n", "hint": "$1\\leq m,n \\leq 20$\n", "locale": "zh-CN"}}}
{"pid": "P4014", "type": "P", "difficulty": 5, "samples": [["5\n2 2 2 1 2\n2 3 1 2 4\n2 0 1 1 1\n2 3 4 3 3\n3 2 1 2 1", "5\n14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["深度优先搜索 DFS", "二分图", "费用流", "网络流与线性规划 24 题"], "title": "分配问题", "background": "", "description": "有 $n$ 件工作要分配给 $n$ 个人做。第 $i$ 个人做第 $j$ 件工作产生的效益为 $c_{ij}$ 。试设计一个将 $n$ 件工作分配给 $n$ 个人做的分配方案，使产生的总效益最小或最大。\n", "inputFormat": "文件的第一行有 $1$ 个正整数 $n$，表示有 $n$ 件工作要分配给 $n$ 个人做。\n\n接下来的 $n$ 行中，每行有 $n$ 个整数 $c_{i,j}$，表示第 $i$ 个人做第 $j$ 件工作产生的效益为 $c_{i,j}$。\n", "outputFormat": "两行分别输出最小总效益和最大总效益。\n", "hint": "$1 \\leq n \\leq 50, 0 \\le c _ {i, j} \\le 100$。\n\n一个人只能修一个工件。", "locale": "zh-CN", "translations": {"en": {"title": "Assignment Problem", "background": "", "description": "There are $n$ jobs to be assigned to $n$ people. When person $i$ does job $j$, the benefit is $c_{ij}$. Design an assignment that assigns $n$ jobs to $n$ people so that the total benefit is minimized or maximized.", "inputFormat": "The first line contains one positive integer $n$, indicating there are $n$ jobs to be assigned to $n$ people.\nIn the next $n$ lines, each line contains $n$ integers $c_{i,j}$, where $c_{i,j}$ is the benefit when person $i$ does job $j$.", "outputFormat": "Output two lines: the minimum total benefit and the maximum total benefit, respectively.", "hint": "$1 \\leq n \\leq 50, 0 \\le c _ {i, j} \\le 100$.\n\nEach person can do only one job.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "分配问题", "background": "", "description": "有 $n$ 件工作要分配给 $n$ 个人做。第 $i$ 个人做第 $j$ 件工作产生的效益为 $c_{ij}$ 。试设计一个将 $n$ 件工作分配给 $n$ 个人做的分配方案，使产生的总效益最小或最大。\n", "inputFormat": "文件的第一行有 $1$ 个正整数 $n$，表示有 $n$ 件工作要分配给 $n$ 个人做。\n\n接下来的 $n$ 行中，每行有 $n$ 个整数 $c_{i,j}$，表示第 $i$ 个人做第 $j$ 件工作产生的效益为 $c_{i,j}$。\n", "outputFormat": "两行分别输出最小总效益和最大总效益。\n", "hint": "$1 \\leq n \\leq 50, 0 \\le c _ {i, j} \\le 100$。\n\n一个人只能修一个工件。", "locale": "zh-CN"}}}
{"pid": "P4015", "type": "P", "difficulty": 5, "samples": [["2 3\n220 280\n170 120 210\n77 39 105\n150 186 122", "48500\n69140"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["O2优化", "费用流", "网络流与线性规划 24 题"], "title": "运输问题", "background": null, "description": "$W$ 公司有 $m$ 个仓库和 $n$ 个零售商店。第 $i$ 个仓库有 $a_i$ 个单位的货物；第 $j$ 个零售商店需要 $b_j$ 个单位的货物。\n\n\n货物供需平衡，即$\\sum\\limits_{i=1}^{m}a_i=\\sum\\limits_{j=1}^{n}b_j$。\n\n\n从第 $i$ 个仓库运送每单位货物到第 $j$ 个零售商店的费用为 $c_{i,j}$ 。\n\n\n试设计一个将仓库中所有货物运送到零售商店的运输方案，使总运输费用最少。", "inputFormat": "第 $1$ 行有 $2$ 个正整数 $m$ 和 $n$，分别表示仓库数和零售商店数。\n\n\n接下来的一行中有 $m$ 个正整数 $a_i$，表示第 $i$ 个仓库有 $a_i$个单位的货物。\n\n\n再接下来的一行中有 $n$ 个正整数 $b_j$，表示第 $j$ 个零售商店需要 $b_j$ 个单位的货物。\n\n\n接下来的 $m$ 行，每行有 $n$ 个整数，表示从第 $i$ 个仓库运送每单位货物到第 $j$ 个零售商店的费用 $c_{i,j}$。", "outputFormat": "两行分别输出最小运输费用和最大运输费用。", "hint": "$1 \\leq n, m \\leq 100$", "locale": "zh-CN", "translations": {"en": {"title": "Transportation Problem", "background": "", "description": "Company $W$ has $m$ warehouses and $n$ retail stores. The $i$-th warehouse has $a_i$ units of goods; the $j$-th retail store needs $b_j$ units of goods.\n\nThe supply and demand are balanced, i.e., $\\sum\\limits_{i=1}^{m}a_i=\\sum\\limits_{j=1}^{n}b_j$.\n\nThe cost to transport each unit of goods from the $i$-th warehouse to the $j$-th retail store is $c_{i,j}$.\n\nDesign a transportation plan to ship all goods from the warehouses to the retail stores so that the total transportation cost is minimized.", "inputFormat": "Line 1 contains 2 positive integers $m$ and $n$, representing the number of warehouses and retail stores, respectively.\n\nThe next line contains $m$ positive integers $a_i$, where the $i$-th warehouse has $a_i$ units of goods.\n\nThe following line contains $n$ positive integers $b_j$, where the $j$-th retail store requires $b_j$ units of goods.\n\nThe next $m$ lines each contain $n$ integers, representing the per-unit transportation cost $c_{i,j}$ from the $i$-th warehouse to the $j$-th retail store.", "outputFormat": "Output two lines: the minimum total transportation cost and the maximum total transportation cost.", "hint": "$1 \\leq n, m \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "运输问题", "background": null, "description": "$W$ 公司有 $m$ 个仓库和 $n$ 个零售商店。第 $i$ 个仓库有 $a_i$ 个单位的货物；第 $j$ 个零售商店需要 $b_j$ 个单位的货物。\n\n\n货物供需平衡，即$\\sum\\limits_{i=1}^{m}a_i=\\sum\\limits_{j=1}^{n}b_j$。\n\n\n从第 $i$ 个仓库运送每单位货物到第 $j$ 个零售商店的费用为 $c_{i,j}$ 。\n\n\n试设计一个将仓库中所有货物运送到零售商店的运输方案，使总运输费用最少。", "inputFormat": "第 $1$ 行有 $2$ 个正整数 $m$ 和 $n$，分别表示仓库数和零售商店数。\n\n\n接下来的一行中有 $m$ 个正整数 $a_i$，表示第 $i$ 个仓库有 $a_i$个单位的货物。\n\n\n再接下来的一行中有 $n$ 个正整数 $b_j$，表示第 $j$ 个零售商店需要 $b_j$ 个单位的货物。\n\n\n接下来的 $m$ 行，每行有 $n$ 个整数，表示从第 $i$ 个仓库运送每单位货物到第 $j$ 个零售商店的费用 $c_{i,j}$。", "outputFormat": "两行分别输出最小运输费用和最大运输费用。", "hint": "$1 \\leq n, m \\leq 100$", "locale": "zh-CN"}}}
{"pid": "P4016", "type": "P", "difficulty": 4, "samples": [["5\n17 9 14 16 4", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "贪心", "网络流", "O2优化", "费用流", "网络流与线性规划 24 题"], "title": "负载平衡问题", "background": null, "description": "G 公司有 $n$ 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 $n$ 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。", "inputFormat": "第一行一个正整数 $n$，表示有 $n$ 个仓库。\n\n第二行 $n$ 个正整数，表示 $n$ 个仓库的库存量。", "outputFormat": "一行一个非负整数，输出最少搬运量。", "hint": "$1 \\leq n \\leq 100,1\\leq a_i\\leq 100$，保证 $\\sum a_i$ 是 $n$ 的倍数。", "locale": "zh-CN", "translations": {"en": {"title": "Load Balancing Problem", "background": "", "description": "Company G has $n$ warehouses arranged in a ring along a railway transport line. The amount of goods stored in each warehouse is not necessarily the same. What is the minimum total amount of goods that must be moved to make the inventories of the $n$ warehouses equal? When moving goods, you may only transfer goods between adjacent warehouses.", "inputFormat": "The first line contains a positive integer $n$, denoting there are $n$ warehouses.\nThe second line contains $n$ positive integers, denoting the inventory of the $n$ warehouses.", "outputFormat": "Output a single non-negative integer on one line, the minimum total amount of goods to move.", "hint": "$1 \\leq n \\leq 100, 1 \\leq a_i \\leq 100$, and it is guaranteed that $\\sum a_i$ is a multiple of $n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "负载平衡问题", "background": null, "description": "G 公司有 $n$ 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 $n$ 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。", "inputFormat": "第一行一个正整数 $n$，表示有 $n$ 个仓库。\n\n第二行 $n$ 个正整数，表示 $n$ 个仓库的库存量。", "outputFormat": "一行一个非负整数，输出最少搬运量。", "hint": "$1 \\leq n \\leq 100,1\\leq a_i\\leq 100$，保证 $\\sum a_i$ 是 $n$ 的倍数。", "locale": "zh-CN"}}}
{"pid": "P4017", "type": "P", "difficulty": 3, "samples": [["5 7\n1 2\n1 3\n2 3\n3 5\n2 5\n4 5\n3 4", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "图论", "排序", "深度优先搜索 DFS", "拓扑排序"], "title": "最大食物链计数", "background": "你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。", "description": "给你一个食物网，你要求出这个食物网中最大食物链的数量。\n\n（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）\n\nDelia 非常急，所以你只有 $1$ 秒的时间。\n\n由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。", "inputFormat": "第一行，两个正整数 $n$、$m$，表示生物种类 $n$ 和吃与被吃的关系数 $m$。\n\n接下来 $m$ 行，每行两个正整数，表示被吃的生物 A 和吃 A 的生物 B。", "outputFormat": "一行一个整数，为最大食物链数量模上 $80112002$ 的结果。", "hint": "各测试点满足以下约定：\n\n|测试点编号|$n$|$m$|\n|:-:|:-:|:-:|\n|$1,2$|$\\le 40$|$\\le 400$|\n|$3,4$|$\\le 100$|$\\le 2\\times 10^3$|\n|$5,6$|$\\le 10^3$|$\\le 6\\times 10^4$|\n|$7,8$|$\\le 2\\times 10^3$|$\\le 2\\times 10^5$|\n|$9,10$|$\\le 5\\times 10^3$|$\\le 5\\times 10^5$|\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 5\\times 10^3,1\\le m \\le 5\\times 10^5$\n\n【补充说明】\n\n数据中不会出现环，满足生物学的要求。（感谢 @AKEE）", "locale": "zh-CN", "translations": {"en": {"title": "Maximal Food Chain Count", "background": "Do you know about food chains? During Delia's biology exam, she got all the questions about counting food chains wrong because she kept double-counting or missing some. So she came to ask you for help, but you don’t know either. Write a program to help her.", "description": "Given a food web, you are to compute the number of maximal food chains in this food web.\n\n(Here, a \"maximal food chain\" refers to a food chain in the biological sense: the leftmost end is a producer that does not prey on any other species, and the rightmost end is a consumer that is not preyed upon by any other species.)\n\nDelia is in a hurry, so you have only $1$ second.\n\nSince the result may be large, you only need to output the total modulo $80112002$.", "inputFormat": "The first line contains two positive integers $n$, $m$, denoting the number of species $n$ and the number of predator-prey relations $m$.\n\nThen $m$ lines follow. Each line contains two positive integers, denoting a species $A$ that is eaten and a species $B$ that eats $A$.", "outputFormat": "Output a single integer on one line: the number of maximal food chains modulo $80112002$.", "hint": "Each test point satisfies the following constraints:\n\n| Test point ID | $n$ | $m$ |\n|:-:|:-:|:-:|\n| $1,2$ | $\\le 40$ | $\\le 400$ |\n| $3,4$ | $\\le 100$ | $\\le 2\\times 10^3$ |\n| $5,6$ | $\\le 10^3$ | $\\le 6\\times 10^4$ |\n| $7,8$ | $\\le 2\\times 10^3$ | $\\le 2\\times 10^5$ |\n| $9,10$ | $\\le 5\\times 10^3$ | $\\le 5\\times 10^5$ |\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 5\\times 10^3, 1 \\le m \\le 5\\times 10^5$.\n\nAdditional note: The data contains no cycles, in line with biological requirements. (Thanks to @AKEE.)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最大食物链计数", "background": "你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。", "description": "给你一个食物网，你要求出这个食物网中最大食物链的数量。\n\n（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）\n\nDelia 非常急，所以你只有 $1$ 秒的时间。\n\n由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。", "inputFormat": "第一行，两个正整数 $n$、$m$，表示生物种类 $n$ 和吃与被吃的关系数 $m$。\n\n接下来 $m$ 行，每行两个正整数，表示被吃的生物 A 和吃 A 的生物 B。", "outputFormat": "一行一个整数，为最大食物链数量模上 $80112002$ 的结果。", "hint": "各测试点满足以下约定：\n\n|测试点编号|$n$|$m$|\n|:-:|:-:|:-:|\n|$1,2$|$\\le 40$|$\\le 400$|\n|$3,4$|$\\le 100$|$\\le 2\\times 10^3$|\n|$5,6$|$\\le 10^3$|$\\le 6\\times 10^4$|\n|$7,8$|$\\le 2\\times 10^3$|$\\le 2\\times 10^5$|\n|$9,10$|$\\le 5\\times 10^3$|$\\le 5\\times 10^5$|\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 5\\times 10^3,1\\le m \\le 5\\times 10^5$\n\n【补充说明】\n\n数据中不会出现环，满足生物学的要求。（感谢 @AKEE）", "locale": "zh-CN"}}}
