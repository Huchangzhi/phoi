{"pid": "P4761", "type": "P", "difficulty": 6, "samples": [["3\n?heoret?cal\nc?mputer\n?cience\njagiellonian\n?niversity\nkra?ow\n?\nb\nc", "42562\n52\n1"]], "limits": {"time": [2000, 1000, 1000], "memory": [128000, 128000, 128000]}, "tags": ["2014", "ICPC", "CERC"], "title": "[CERC2014] Vocabulary", "background": "", "description": "According to a popular belief, computer programmers drink a lot of coffee and know only a few words. The vocabulary of a typical programmer consists of just three words. Besides, he rarely knows how to spell them. To help programmers with their spelling mistakes, we published a book titled $The \\ Dictionary \\ of \\ the \\ Three \\ Words \\ Every \\ Typical \\ Programmer \\ Should \\ Know$.\n\nYou got a copy of the book but, soon after that, you spilled your coffee over it.\n\nNow, youcannot read some of the characters. Fortunately, the three words were, as usually in dictionaries,distinct and printed in lexicographical order.\nBefore you attempt to use that fact to recover the missing characters, you want to know in how many different ways you can do it. Since you expect this number might be large, you want to know it modulo $10^9 + 9$.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case consists of three lines, each containing a single nonempty word – in the order they appear in the dictionary. Words consist of small letters of the English alphabet and question marks, the latter denoting missing characters. Each word is at most $1 000 000$ characters long.\n", "outputFormat": "For each test case, output one line containing the number of different ways you can substitute each question mark with one of the $26$ letters from ``a`` to ``z`` in such a way that the three words are distinct and in lexicographical order. The number should be printed modulo $10^9 + 9$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Vocabulary", "background": "", "description": "According to a popular belief, computer programmers drink a lot of coffee and know only a few words. The vocabulary of a typical programmer consists of just three words. Besides, he rarely knows how to spell them. To help programmers with their spelling mistakes, we published a book titled $The \\ Dictionary \\ of \\ the \\ Three \\ Words \\ Every \\ Typical \\ Programmer \\ Should \\ Know$.\n\nYou got a copy of the book but, soon after that, you spilled your coffee over it.\n\nNow, youcannot read some of the characters. Fortunately, the three words were, as usually in dictionaries,distinct and printed in lexicographical order.\nBefore you attempt to use that fact to recover the missing characters, you want to know in how many different ways you can do it. Since you expect this number might be large, you want to know it modulo $10^9 + 9$.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case consists of three lines, each containing a single nonempty word – in the order they appear in the dictionary. Words consist of small letters of the English alphabet and question marks, the latter denoting missing characters. Each word is at most $1 000 000$ characters long.\n", "outputFormat": "For each test case, output one line containing the number of different ways you can substitute each question mark with one of the $26$ letters from ``a`` to ``z`` in such a way that the three words are distinct and in lexicographical order. The number should be printed modulo $10^9 + 9$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Vocabulary", "background": "", "description": "根据一种流行的说法，计算机程序员喝很多咖啡，并且只知道几个单词。一个典型程序员的词汇量只有三个单词。此外，他很少知道如何拼写它们。为了帮助程序员纠正拼写错误，我们出版了一本名为《每个典型程序员应该知道的三个单词词典》的书。\n\n你得到了一本书的副本，但不久之后，你把咖啡洒在了上面。\n\n现在，你无法阅读其中的一些字符。幸运的是，这三个单词在字典中是不同的，并按字典顺序排列。在你尝试利用这一事实来恢复缺失的字符之前，你想知道有多少种不同的方法可以做到这一点。由于你预计这个数字可能很大，你想知道它对 $10^9 + 9$ 取模的结果。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来的描述是测试用例：\n\n每个测试用例由三行组成，每行包含一个非空单词——按它们在字典中出现的顺序。单词由小写英文字母和问号组成，问号表示缺失的字符。每个单词最多有 $1,000,000$ 个字符。", "outputFormat": "对于每个测试用例，输出一行，包含将每个问号替换为从 “a” 到 “z” 的 $26$ 个字母之一的不同方法数，使得三个单词不同且按字典顺序排列。结果应对 $10^9 + 9$ 取模。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4762", "type": "P", "difficulty": 6, "samples": [["4\nAAAA\nAGCTTGCA\nAAGGGGAAGGGGAA\nAAACAGTCCTGACAAAAAAAAAAAAC", "3\n8\n6\n18"]], "limits": {"time": [10000, 10000, 1000, 10000], "memory": [128000, 128000, 128000, 128000]}, "tags": ["2014", "O2优化", "回文自动机 PAM", "ICPC", "CERC"], "title": "[CERC2014] Virus synthesis", "background": "", "description": "Viruses are usually bad for your health. How about fighting them with... other viruses? In this problem, you need to find out how to synthesize such good viruses.\n\nWe have prepared for you a set of strings of the letters $A, G, T$ and $C$. They correspond to the DNA nucleotide sequences of viruses that we want to synthesize, using the following operations:\n\n   - Adding a nucleotide either to the beginning or the end of the existing sequence.\n   - Replicating the sequence, reversing the copied piece, and gluing it either to the beginning or to the end of the original (so that e.g., $AGTC$ can become $AGTCCTGA$ or $CTGAAGTC$).\n\nWe’re concerned about efficiency, since we have very many such sequences, some of them very long. Find a way to synthesize them in a minimum number of operations.\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case consists of a single line containing a non-empty string. The string uses only the capital letters $A, C, G$ and $T$ and is not longer than $100 000$ characters.\n", "outputFormat": "For each test case, output a single line containing the minimum total number of operations necessary to construct the given sequence.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Virus synthesis", "background": "", "description": "Viruses are usually bad for your health. How about fighting them with... other viruses? In this problem, you need to find out how to synthesize such good viruses.\n\nWe have prepared for you a set of strings of the letters $A, G, T$ and $C$. They correspond to the DNA nucleotide sequences of viruses that we want to synthesize, using the following operations:\n\n   - Adding a nucleotide either to the beginning or the end of the existing sequence.\n   - Replicating the sequence, reversing the copied piece, and gluing it either to the beginning or to the end of the original (so that e.g., $AGTC$ can become $AGTCCTGA$ or $CTGAAGTC$).\n\nWe’re concerned about efficiency, since we have very many such sequences, some of them very long. Find a way to synthesize them in a minimum number of operations.\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case consists of a single line containing a non-empty string. The string uses only the capital letters $A, C, G$ and $T$ and is not longer than $100 000$ characters.\n", "outputFormat": "For each test case, output a single line containing the minimum total number of operations necessary to construct the given sequence.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Virus synthesis", "background": "", "description": "病毒通常对健康有害。那么用……其他病毒来对抗它们怎么样？在这个问题中，你需要找出如何合成这样的好病毒。\n\n我们为你准备了一组由字母 $A, G, T$ 和 $C$ 组成的字符串。它们对应于我们想要合成的病毒的 DNA 核苷酸序列，可以使用以下操作：\n\n- 在现有序列的开头或结尾添加一个核苷酸。\n- 复制序列，反转复制的片段，并将其粘贴到原序列的开头或结尾（例如，$AGTC$ 可以变成 $AGTCCTGA$ 或 $CTGAAGTC$）。\n\n由于我们有很多这样的序列，其中一些非常长，我们关心效率。找出一种方法，以最少的操作次数合成它们。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。测试用例的描述如下：\n\n每个测试用例由一行组成，包含一个非空字符串。该字符串仅使用大写字母 $A, C, G$ 和 $T$，且长度不超过 $100000$ 个字符。", "outputFormat": "对于每个测试用例，输出一行，包含构建给定序列所需的最小操作总数。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4763", "type": "P", "difficulty": 4, "samples": [["3\n3\n1 B\n3 W\n2 B\n4\n3 W\n3 B\n9 W\n1 B\n2\n2 W\n3 W", "2\n3\n5"]], "limits": {"time": [4000, 4000], "memory": [128000, 128000]}, "tags": ["2014", "ICPC", "CERC"], "title": "[CERC2014] Bricks", "background": "", "description": "You are given a sequence of white $(W)$ and black $(B)$ bricks. The goal is to partition it into some number of non-empty, contiguous blocks, each one having the same ratio of white and black bricks.\n\nOf course one can always “partition” the sequence into one single block (which is not very interesting). We want, however, to have as many blocks as possible. Consider for example the following sequences and its partitions:\n\n   - $BWWWBB = BW + WWBB$ (ratio 1:1),\n   - $WWWBBBWWWWWWWWWB = WWWB + BBWWWWWW + WWWB$ (ratio 3:1).\n\nNote that both of these partitions are optimal with respect to the number of blocks.\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case starts with one line containing an integer $n(1 \\le n \\le 10^5)$ which is the length of the description of a sequence. Each of the following $n$ lines consists of an integer $k(1 \\le k \\le 10^9)$ and one of the characters $W$ or $B$, meaning that $k$ bricks of the given color follow next in the sequence. It is guaranteed that the total length of the brick sequence does not exceed $10^9$.", "outputFormat": "For each test case, output a single line containing the largest possible number of blocks.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Bricks", "background": "", "description": "You are given a sequence of white $(W)$ and black $(B)$ bricks. The goal is to partition it into some number of non-empty, contiguous blocks, each one having the same ratio of white and black bricks.\n\nOf course one can always “partition” the sequence into one single block (which is not very interesting). We want, however, to have as many blocks as possible. Consider for example the following sequences and its partitions:\n\n   - $BWWWBB = BW + WWBB$ (ratio 1:1),\n   - $WWWBBBWWWWWWWWWB = WWWB + BBWWWWWW + WWWB$ (ratio 3:1).\n\nNote that both of these partitions are optimal with respect to the number of blocks.\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case starts with one line containing an integer $n(1 \\le n \\le 10^5)$ which is the length of the description of a sequence. Each of the following $n$ lines consists of an integer $k(1 \\le k \\le 10^9)$ and one of the characters $W$ or $B$, meaning that $k$ bricks of the given color follow next in the sequence. It is guaranteed that the total length of the brick sequence does not exceed $10^9$.", "outputFormat": "For each test case, output a single line containing the largest possible number of blocks.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Bricks", "background": null, "description": "给你一个由 'B' 和 'W' 组成的序列，将其按分成最多的区间且每个区间的 'B':'W' 的值相等。", "inputFormat": "多组数据，第一行一个整数 $T$ 表示数据组数。\n每组数据的第一行为一个整数 $n$，接下来 $n$ 行，每行一个整数 $k$ 和一个字符（'B' 或 'W'）表示在上一个序列后有一个长度为 $k$ 的 'B' 或 'W' 的序列，序列的总长度不超过 $10^9$。", "outputFormat": "共 $T$ 行，每行一个整数，表示能分成的最多的区间数。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4764", "type": "P", "difficulty": 7, "samples": [["1\n5 7\n1 2 2\n2 3 4\n3 4 3\n4 5 1\n5 1 3\n2 5 4\n1 4 5\n5\n1 2\n4 7\n11 12\n11 13\n18 19\n", "3\n9\n8\n14\n13"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "O2优化", "ICPC", "CERC"], "title": "[CERC2014] Pork barrel", "background": "", "description": "Winning the election was simpler than you expected: it was enough to promise to finally build a good quality, country-wide road infrastructure, of course without crippling the budget... Your happiness did not last long, however: it seems, that the citizens have found a way to actually hold you accountable for your promise!\n\nThere are $n$ major cities in your country. The Ministry of Transport has prepared a detailed map, outlining $m$ possible highway connections, together with their costs. The Quality Assurance Committee will not let you build a highway cheaper than $l$, and the National Spendings Regulatory Committee will not let you build a highway more expensive than $h$. To claim a “country-wide” network, you have to connect (possibly indirectly) as many pairs of cities, as it is possible within these two constraints. You have to find the cheapest way to do it, and you have to find it quickly! Of all networks that meet the constraints and connect the most pairs of cities,compute the cost of the cheapest one.\n\nTo make things worse, both committees are heavily influenced by your angry competitors:each time you publish your hard-prepared plan, they immediately change their rulings $l$ and $h$,and you are forced to start from scratch.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe first line of each test case contains integers $n$ and $m(1 \\le n \\le 1000, 0 \\le m \\le 100 000)$ – the number of cities in the country, and of possible direct connections, respectively.\n\nEach of the following $m$ lines contains three integers $x, y, w (1 \\le x ≠ y \\le n, 1 \\le w \\le 1 000 000)$, denoting that the cities $x$ and $y$ can be connected by a bidirectional highway at cost $w$. There might be many ways to connect a single pair of cities.\n\nThe following line contains an integer $q(1 \\le q \\le 1 000 000)$ – the number of rulings of the committees. Each of the following $q$ lines contains two integers. The first of the lines contains the initial rulings $l_1, h_1$, given directly. The rest of the rulings are encoded. The numbers in the $j-th$ of the lines for $j > 1$ are $l_j + c_{j -1}$ and $h_j + c_{j-1}$, where $l_j$ and $h_j$ are the actual rulings and $c_{j-1}$ is the correct answer for the preceding rulings $l_{j-1}$ and $h_{j-1}$.\n\nAll rulings satisfy $1 \\le l_j \\le h_j \\le 1 000 000$.\n", "outputFormat": "For each test case, output $q$ lines, one for each ruling. In the $j-th$ of them,output the minimal cost $c_j$ of building a highway network which adheres to the committees’ constraints, and creates the maximum number of connected pairs of cities.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Pork barrel", "background": "", "description": "Winning the election was simpler than you expected: it was enough to promise to finally build a good quality, country-wide road infrastructure, of course without crippling the budget... Your happiness did not last long, however: it seems, that the citizens have found a way to actually hold you accountable for your promise!\n\nThere are $n$ major cities in your country. The Ministry of Transport has prepared a detailed map, outlining $m$ possible highway connections, together with their costs. The Quality Assurance Committee will not let you build a highway cheaper than $l$, and the National Spendings Regulatory Committee will not let you build a highway more expensive than $h$. To claim a “country-wide” network, you have to connect (possibly indirectly) as many pairs of cities, as it is possible within these two constraints. You have to find the cheapest way to do it, and you have to find it quickly! Of all networks that meet the constraints and connect the most pairs of cities,compute the cost of the cheapest one.\n\nTo make things worse, both committees are heavily influenced by your angry competitors:each time you publish your hard-prepared plan, they immediately change their rulings $l$ and $h$,and you are forced to start from scratch.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe first line of each test case contains integers $n$ and $m(1 \\le n \\le 1000, 0 \\le m \\le 100 000)$ – the number of cities in the country, and of possible direct connections, respectively.\n\nEach of the following $m$ lines contains three integers $x, y, w (1 \\le x ≠ y \\le n, 1 \\le w \\le 1 000 000)$, denoting that the cities $x$ and $y$ can be connected by a bidirectional highway at cost $w$. There might be many ways to connect a single pair of cities.\n\nThe following line contains an integer $q(1 \\le q \\le 1 000 000)$ – the number of rulings of the committees. Each of the following $q$ lines contains two integers. The first of the lines contains the initial rulings $l_1, h_1$, given directly. The rest of the rulings are encoded. The numbers in the $j-th$ of the lines for $j > 1$ are $l_j + c_{j -1}$ and $h_j + c_{j-1}$, where $l_j$ and $h_j$ are the actual rulings and $c_{j-1}$ is the correct answer for the preceding rulings $l_{j-1}$ and $h_{j-1}$.\n\nAll rulings satisfy $1 \\le l_j \\le h_j \\le 1 000 000$.\n", "outputFormat": "For each test case, output $q$ lines, one for each ruling. In the $j-th$ of them,output the minimal cost $c_j$ of building a highway network which adheres to the committees’ constraints, and creates the maximum number of connected pairs of cities.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Pork barrel", "background": "", "description": "赢得选举比你预期的要简单：只需承诺最终建立一个高质量的全国性道路基础设施，当然不能让预算瘫痪……然而你的快乐并没有持续多久：似乎市民们找到了一个方法，实际上让你对你的承诺负责！\n\n在你的国家有 $n$ 个主要城市。交通部准备了一份详细的地图，列出了 $m$ 条可能的高速公路连接及其成本。质量保证委员会不会让你修建成本低于 $l$ 的高速公路，而国家支出监管委员会不会让你修建成本高于 $h$ 的高速公路。为了声称拥有一个“全国性”的网络，你必须在这两个限制内尽可能多地连接（可能是间接地）城市对。你必须找到最便宜的方法来做到这一点，而且必须快速找到！在所有满足限制并连接最多城市对的网络中，计算出最便宜的一个的成本。\n\n更糟糕的是，这两个委员会都受到你愤怒的竞争对手的强烈影响：每次你公布你精心准备的计划时，他们立即改变他们的裁决 $l$ 和 $h$，你被迫从头开始。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来的描述是测试用例的内容：\n\n每个测试用例的第一行包含整数 $n$ 和 $m(1 \\le n \\le 1000, 0 \\le m \\le 100 000)$——国家中的城市数量和可能的直接连接数量。\n\n接下来的 $m$ 行中的每一行包含三个整数 $x, y, w (1 \\le x \neq y \\le n, 1 \\le w \\le 1 000 000)$，表示城市 $x$ 和 $y$ 可以通过成本为 $w$ 的双向高速公路连接。可能有多种方式连接单对城市。\n\n接下来的行包含一个整数 $q(1 \\le q \\le 1 000 000)$——委员会的裁决数量。接下来的 $q$ 行中的第一行直接给出初始裁决 $l_1, h_1$。其余的裁决是编码的。对于 $j > 1$ 的行中的数字是 $l_j + c_{j -1}$ 和 $h_j + c_{j-1}$，其中 $l_j$ 和 $h_j$ 是实际的裁决，$c_{j-1}$ 是前一个裁决 $l_{j-1}$ 和 $h_{j-1}$ 的正确答案。\n\n所有裁决满足 $1 \\le l_j \\le h_j \\le 1 000 000$。", "outputFormat": "对于每个测试用例，输出 $q$ 行，每个裁决一行。在第 $j$ 行中，输出符合委员会限制并创建最大数量连接城市对的高速公路网络的最小成本 $c_j$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4765", "type": "P", "difficulty": 6, "samples": [["1\n3 1\n10 5\n8 1\n20 12", "7"]], "limits": {"time": [3000, 3000], "memory": [128000, 128000]}, "tags": ["2014", "O2优化", "ICPC", "CERC"], "title": "[CERC2014] The Imp", "background": "", "description": "You arrive in Ye Olde Magic Shoppe with some hard-earned gold to purchase wondrous and unique magic items. There are $n$ such items in the shop, each of them locked in a special magic box. The $i-th$ box costs $c_i$ gold pieces to buy, and contains an item worth $v_i$ gold pieces. The costs and item values are known to you, as you have previously read, mastered, and memorized Ye Olde Magic Catalogue.\n\nA mortal, such as you, can safely carry only one magic item. You therefore aim to get the most precious one. And obtain it you would, if not for a malicious, magical creature, known as The Imp.\n\nThe Imp can cast a mischievous spell, which transforms the content of any magic box into worthless dust. Of course, he will use the spell just after you buy a box, to make you pay for the item and not get it. You are thus forced to buy another box, and then the next one...\n\nThe Imp has enough magic to cast the spell at most $k$ times. He can, of course, refrain from using it, allowing you to keep an item. You can walk away at any time, empty-handed (though it would surely be a disgrace). However, if you get an item, you must keep it and leave the shop.\n\nYou aim to maximize your gain (the value of the acquired item minus all the expenses paid previously), while The Imp wants to minimize it. If both you and the creature use the optimal strategy, how much gold will you earn?", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of\nthe test cases follow:\n\nEach test case starts with a line containing the number of items $n(1 \\le n \\le 150 000)$ and the the maximum number of The Imp’s spells $k(0 \\le k \\le 9)$. \n\nThe next $n$ lines contain the items’values and costs, the $i-th$ line containing the numbers $v_i$ and $c_i$, in that order $(0 \\le v_i, c_i \\le 10^6)$.\n", "outputFormat": "For each test case, output one line containing your gain.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] The Imp", "background": "", "description": "You arrive in Ye Olde Magic Shoppe with some hard-earned gold to purchase wondrous and unique magic items. There are $n$ such items in the shop, each of them locked in a special magic box. The $i-th$ box costs $c_i$ gold pieces to buy, and contains an item worth $v_i$ gold pieces. The costs and item values are known to you, as you have previously read, mastered, and memorized Ye Olde Magic Catalogue.\n\nA mortal, such as you, can safely carry only one magic item. You therefore aim to get the most precious one. And obtain it you would, if not for a malicious, magical creature, known as The Imp.\n\nThe Imp can cast a mischievous spell, which transforms the content of any magic box into worthless dust. Of course, he will use the spell just after you buy a box, to make you pay for the item and not get it. You are thus forced to buy another box, and then the next one...\n\nThe Imp has enough magic to cast the spell at most $k$ times. He can, of course, refrain from using it, allowing you to keep an item. You can walk away at any time, empty-handed (though it would surely be a disgrace). However, if you get an item, you must keep it and leave the shop.\n\nYou aim to maximize your gain (the value of the acquired item minus all the expenses paid previously), while The Imp wants to minimize it. If both you and the creature use the optimal strategy, how much gold will you earn?", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of\nthe test cases follow:\n\nEach test case starts with a line containing the number of items $n(1 \\le n \\le 150 000)$ and the the maximum number of The Imp’s spells $k(0 \\le k \\le 9)$. \n\nThe next $n$ lines contain the items’values and costs, the $i-th$ line containing the numbers $v_i$ and $c_i$, in that order $(0 \\le v_i, c_i \\le 10^6)$.\n", "outputFormat": "For each test case, output one line containing your gain.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] The Imp", "background": null, "description": "你带着一些来之不易的金币来到了 Ye Olde 魔法商店，想要购买一些妙不可言的魔术物品。商店里有 $n$ 个魔术实体，每个实体都锁在一个特殊的魔术宝箱中。第 $i$ 个宝箱（和其中的实体）的售价为 $c_i$个金币，而其中实体的价值相当于 $v_i$ 个金币。你作为曾经完整钻研了《Ye Olde 魔法目录》的顶级做题家，当然毫无疑问地记住了每个盒子和其中实体的售价和价值。\n\n然而像你这样的凡人，只能安全地携带一件魔法实体。因此，你想要得到最宝贵的一个。你本可以直接得到它的——如果不是因为调皮而又神奇的小恶魔的话。\n\n小恶魔可以使用魔法，从而将某一个魔术宝箱内的实体转化为毫无价值的灰尘。当然，他会在你购买一个魔术宝箱后立即对其使用该魔法，这样你就为这个宝箱付了钱而没能得到里面的实体。因此，你被迫另买一个，再买一个……\n\n小恶魔拥的魔力最多可以用来使用 $k$ 次魔法。当然，他可以不用完这 $k$ 次魔法，而你也可以随时空手走开（尽管这是一个奇耻大辱）。但是，如果你成功地买到了到一个实体（而没有被变成灰尘），则你必须保留该实体并离开商店。\n\n你的目标是最大化你的收益（所购实体的价值减去支付的所有费用（包括购买当前实体和之前的灰尘）），而小恶魔则希望将其最小化。如果你和小恶魔都使用最佳策略，那么你的收益将会相当于多少金币？", "inputFormat": "**本题每个测试点包含多组数据。**\n\n第一行包含一个正整数 $T$ 表示测试数据组数。  \n每组数据的第一行包括两个数 $n$ 和 $k$ ，分别表示魔术实体个数和小恶魔使用魔法的最大次数。  \n接下来 $n$ 行，每行包括两个数 $v_i$ 和 $c_i$，分别表示第 $i$ 个盒子和其中实体的价值和售价。", "outputFormat": "对于每组数据，输出一行一个数表示答案。", "hint": "$1\\le n\\le1.5\\times10^5,0\\le k\\le9,0\\le v_i,c_i\\le10^6$。", "locale": "zh-CN"}}}
{"pid": "P4766", "type": "P", "difficulty": 5, "samples": [["1\n3\n1 4 4\n4 7 5\n3 4 7\n", "7"]], "limits": {"time": [2000, 2000, 2000], "memory": [128000, 128000, 128000]}, "tags": ["动态规划 DP", "2014", "离散化", "O2优化", "区间 DP", "ICPC", "CERC"], "title": "[CERC2014] Outer space invaders", "background": "", "description": "The aliens from outer space have (finally!) invaded Earth. Defend yourself, or be disintegrated!\n\nOr assimilated. Or eaten. We are not yet sure.\n\nThe aliens follow a known attack pattern. There are $n$ attackers, the $i-th$ one appears at time $a_i$, at distance $d_i$ from you. He must be destroyed no later than at time $b_i$, or else he will fire his weapon, which will definitely end the fight.\n\nYour weapon is an area-blaster, which can be set to any given power. If fired with power $R$,it momentarily destroys all aliens at distance $R$ or smaller. It also consumes $R$ fuel cells.\n\nDetermine the minimal cost (measured in fuel cells) of destroying all the aliens, without being killed.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case starts with a line containing the number of aliens $n(1 \\le n \\le 300)$. Of the next $n$ lines, the $i-th$ one contains three integers $a_i, b_i, d_i, (1 \\le a_i < b_i \\le 10 000, 1 \\le d_i \\le 10 000)$.\n\nThe $i-th$ alien appears at time $a_i$, is idle until $b_i$, and his distance from you is $d_i$.\n", "outputFormat": "For each test case, output one line containing the minimum number of cells needed to destroy all the aliens.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Outer space invaders", "background": "", "description": "The aliens from outer space have (finally!) invaded Earth. Defend yourself, or be disintegrated!\n\nOr assimilated. Or eaten. We are not yet sure.\n\nThe aliens follow a known attack pattern. There are $n$ attackers, the $i-th$ one appears at time $a_i$, at distance $d_i$ from you. He must be destroyed no later than at time $b_i$, or else he will fire his weapon, which will definitely end the fight.\n\nYour weapon is an area-blaster, which can be set to any given power. If fired with power $R$,it momentarily destroys all aliens at distance $R$ or smaller. It also consumes $R$ fuel cells.\n\nDetermine the minimal cost (measured in fuel cells) of destroying all the aliens, without being killed.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case starts with a line containing the number of aliens $n(1 \\le n \\le 300)$. Of the next $n$ lines, the $i-th$ one contains three integers $a_i, b_i, d_i, (1 \\le a_i < b_i \\le 10 000, 1 \\le d_i \\le 10 000)$.\n\nThe $i-th$ alien appears at time $a_i$, is idle until $b_i$, and his distance from you is $d_i$.\n", "outputFormat": "For each test case, output one line containing the minimum number of cells needed to destroy all the aliens.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Outer space invaders", "background": null, "description": "来自外太空的外星人（最终）入侵了地球。保卫自己，或者解体，被他们同化，或者成为食物。迄今为止，我们无法确定。\n\n外星人遵循已知的攻击模式。有 $N$ 个外星人进攻，第 $i$ 个进攻的外星人会在时间 $a_i$ 出现，距离你的距离为 $d_i$，它必须在时间 $b_i$ 及以前被消灭，否则被消灭的会是你。\n\n你的武器是一个区域冲击波器，可以设置任何给定的功率。如果被设置了功率 $R$，它会瞬间摧毁与你的距离在 $R$ 以内的所有外星人（可以等于），同时它也会消耗 $R$ 单位的燃料电池。\n\n求摧毁所有外星人的最低成本（消耗多少燃料电池），同时保证自己的生命安全。", "inputFormat": "第一行输入一个数 $T$,表示有 $T$ 组数据。\n\n每组数据的第一行为外星人的数量 $n$（$1\\leq n\\leq 300$）。\n\n接下来 $n$ 行，每行有三个数 $a_i,b_i,d_i$ ，表示这个外星人在时间 $a_i$ 出现，距离你 $d_i$，在 $b_i$ 前时刻死亡。其中 $1 \\le a_i \\le b_i \\le 10000,1 \\le d_i \\le 10000$。", "outputFormat": "共 $T$ 行，每行输出摧毁所有外星人的最低成本。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4767", "type": "P", "difficulty": 6, "samples": [["10 5 \n1 2 3 6 7 9 11 22 44 50", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2000", "IOI", "枚举", "区间 DP", "四边形不等式"], "title": "[IOI 2000] 邮局 加强版", "background": null, "description": "高速公路旁边有一些村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标表示。没有两个在同样地方的村庄。两个位置之间的距离是其整数坐标差的绝对值。\n\n邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。\n\n你要编写一个程序，已知村庄的位置和邮局的数量，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。", "inputFormat": "第一行包含两个整数：第一个是村庄 $V$ 的数量，第二个是邮局的数量 $P$。\n\n第二行包含 $V$ 个整数。这些整数是村庄的位置。", "outputFormat": "第一行包含一个整数 $S$，它是每个村庄与其最近的邮局之间的所有距离的总和。", "hint": "对于 $40\\%$ 的数据，$V \\leq 300$。\n\n对于 $100\\%$ 的数据，$1 \\leq P \\leq 300$，$P \\leq V  \\leq 3000$，$1 \\leq $ 村庄位置 $\\leq 10000$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2000] Post Office (Enhanced Version)", "background": "", "description": "There are some villages along a highway. The highway is represented as the integer number line, and the position of each village is given by a single integer coordinate. No two villages are at the same position. The distance between two positions is the absolute value of the difference of their integer coordinates.\n\nPost offices will be built in some, but not necessarily all, villages. To build the post offices, you should choose their locations so that the sum of distances from each village to its nearest post office is minimized.\n\nYou need to write a program that, given the positions of the villages and the number of post offices, computes the minimum possible total sum of distances from each village to its nearest post office.", "inputFormat": "The first line contains two integers: the first is the number of villages $V$, and the second is the number of post offices $P$.\n\nThe second line contains $V$ integers. These integers are the positions of the villages.", "outputFormat": "The first line contains one integer $S$, which is the total sum of distances from each village to its nearest post office.", "hint": "For $40\\%$ of the testdata, $V \\leq 300$.\n\nFor $100\\%$ of the testdata, $1 \\leq P \\leq 300$, $P \\leq V \\leq 3000$, and $1 \\leq$ village positions $\\leq 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2000] 邮局 加强版", "background": null, "description": "高速公路旁边有一些村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标表示。没有两个在同样地方的村庄。两个位置之间的距离是其整数坐标差的绝对值。\n\n邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。\n\n你要编写一个程序，已知村庄的位置和邮局的数量，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。", "inputFormat": "第一行包含两个整数：第一个是村庄 $V$ 的数量，第二个是邮局的数量 $P$。\n\n第二行包含 $V$ 个整数。这些整数是村庄的位置。", "outputFormat": "第一行包含一个整数 $S$，它是每个村庄与其最近的邮局之间的所有距离的总和。", "hint": "对于 $40\\%$ 的数据，$V \\leq 300$。\n\n对于 $100\\%$ 的数据，$1 \\leq P \\leq 300$，$P \\leq V  \\leq 3000$，$1 \\leq $ 村庄位置 $\\leq 10000$。", "locale": "zh-CN"}}}
{"pid": "P4768", "type": "P", "difficulty": 6, "samples": [["1\n4 3\n1 2 50 1\n2 3 100 2\n3 4 50 1\n5 0 2\n3 0\n2 1\n4 1\n3 1\n3 2", "0\n50\n200\n50\n150"], ["1\n5 5\n1 2 1 2\n2 3 1 2\n4 3 1 2\n5 3 1 2\n1 5 2 1\n4 1 3\n5 1\n5 2\n2 0\n4 0", "0\n2\n3\n1"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "并查集", "Kruskal 重构树", "NOI", "O2优化", "最短路", "可持久化"], "title": "[NOI2018] 归程", "background": null, "description": "本题的故事发生在魔力之都，在这里我们将为你介绍一些必要的设定。\n\n魔力之都可以抽象成一个 $n$ 个节点、$m$ 条边的无向连通图（节点的编号从 $1$ 至 $n$）。我们依次用 $l,a$ 描述一条边的**长度、海拔**。\n\n作为季风气候的代表城市，魔力之都时常有雨水相伴，因此道路积水总是不可避免的。由于整个城市的排水系统连通，因此**有积水的边一定是海拔相对最低的一些边**。我们用**水位线**来描述降雨的程度，它的意义是：所有海拔**不超过**水位线的边都是**有积水**的。\n\nYazid 是一名来自魔力之都的 OIer，刚参加完 ION2018 的他将踏上归程，回到他温暖的家。Yazid 的家恰好在魔力之都的 $1$ 号节点。对于接下来 $Q$ 天，每一天 Yazid 都会告诉你他的出发点 $v$，以及当天的水位线 $p$。\n\n每一天，Yazid 在出发点都拥有一辆车。这辆车由于一些故障不能经过有积水的边。Yazid 可以在任意节点下车，这样接下来他就可以步行经过有积水的边。但车会被留在他下车的节点并不会再被使用。\n需要特殊说明的是，第二天车会被重置，这意味着：\n\n- 车会在新的出发点被准备好。\n- Yazid 不能利用之前在某处停放的车。\n\nYazid 非常讨厌在雨天步行，因此他希望在完成回家这一目标的同时，最小化他**步行经过的边**的总长度。请你帮助 Yazid 进行计算。\n\n本题的部分测试点将强制在线，具体细节请见【输入格式】和【子任务】。", "inputFormat": "单个测试点中包含多组数据。输入的第一行为一个非负整数 $T$，表示数据的组数。\n\n接下来依次描述每组数据，对于每组数据：\n\n第一行 $2$ 个非负整数 $n,m$，分别表示节点数、边数。\n\n接下来 $m$ 行，每行 $4$ 个正整数 $u, v, l, a$，描述一条连接节点 $u, v$ 的、长度为 $l$、海拔为 $a$ 的边。\n在这里，我们保证 $1 \\leq u,v \\leq n$。\n\n接下来一行 $3$ 个非负数 $Q, K, S$，其中 $Q$ 表示总天数，$K \\in {0,1}$ 是一个会在下面被用到的系数，$S$ 表示的是可能的最高水位线。\n\n接下来 $Q$ 行依次描述每天的状况。每行 $2$ 个整数 $v_0, p_0$ 描述一天：\n\n- 这一天的出发节点为 $v = (v_0 + K \\times \\mathrm{lastans} - 1) \\bmod n + 1$。\n- 这一天的水位线为 $p = (p_0 + K \\times \\mathrm{lastans}) \\bmod (S + 1)$。\n\n其中 $\\mathrm{lastans}$ 表示上一天的答案（最小步行总路程）。特别地，我们规定第 $1$ 天时 $\\mathrm{lastans} = 0$。\n在这里，我们保证 $1 \\leq v_0 \\leq n$，$0 \\leq p_0 \\leq S$。\n\n对于输入中的每一行，如果该行包含多个数，则用单个空格将它们隔开。", "outputFormat": "依次输出各组数据的答案。对于每组数据：\n\n- 输出 $Q$ 行每行一个整数，依次表示每天的最小步行总路程。", "hint": "### 更多样例\n\n更多样例请在附加文件中下载。\n\n#### 样例 3\n\n见附加文件中的 `return3.in` 与 `return3.ans`。\n\n该样例满足海拔为一种，且不强制在线。\n\n#### 样例 4\n\n见附加文件中的 `return4.in` 与 `return4.ans`。\n\n该样例满足图形态为一条链，且强制在线。\n\n#### 样例 5\n\n见附加文件中的 `return5.in` 与 `return5.ans`。\n\n该样例满足不强制在线。\n\n### 样例 1 解释\n\n第一天没有降水，Yazid 可以坐车直接回到家中。\n\n第二天、第三天、第四天的积水情况相同，均为连接 1，2 号节点的边、连接 3，4 号点的边有积水。\n\n对于第二天，Yazid 从 2 号点出发坐车只能去往 3 号节点，对回家没有帮助。因此 Yazid 只能纯靠徒步回家。\n\n对于第三天，从 4 号节点出发的唯一一条边是有积水的，车也就变得无用了。Yazid 只能纯靠徒步回家。\n\n对于第四天，Yazid 可以坐车先到达 2 号节点，再步行回家。\n\n第五天所有的边都积水了，因此 Yazid 只能纯靠徒步回家。\n\n### 样例 2 解释\n\n本组数据强制在线。\n\n第一天的答案是 $0$，因此第二天的 $v=\\left( 5+0-1\\right)\\bmod 5+1=5$，$p=\\left(2+0\\right)\\bmod\\left(3+1\\right)=2$。\n\n第二天的答案是 $2$，因此第三天的 $v=\\left( 2+2-1\\right)\\bmod 5+1=4$，$p=\\left(0+2\\right)\\bmod\\left(3+1\\right)=2$。\n\n第三天的答案是 $3$，因此第四天的 $v=\\left( 4+3-1\\right)\\bmod 5+1=2$，$p=\\left(0+3\\right)\\bmod\\left(3+1\\right)=3$。\n\n### 数据范围与约定\n\n所有测试点均保证 $T\\leq 3$，所有测试点中的所有数据均满足如下限制：\n\n- $n\\leq 2\\times 10^5$，$m\\leq 4\\times 10^5$，$Q\\leq 4\\times 10^5$，$K\\in\\left\\{0,1\\right\\}$，$1\\leq S\\leq 10^9$。\n- 对于所有边：$l\\leq 10^4$，$a\\leq 10^9$。\n- 任意两点之间都直接或间接通过边相连。\n\n**为了方便你快速理解，我们在表格中使用了一些简单易懂的表述。在此，我们对这些内容作形式化的说明：**\n\n- 图形态：对于表格中该项为“一棵树”或“一条链”的测试点，保证 $m = n-1$。除此之外，这两类测试点分别满足如下限制：\n  - 一棵树：保证输入的图是一棵树，即保证边不会构成回路。\n  - 一条链：保证所有边满足 $u + 1 = v$。\n- 海拔：对于表格中该项为“一种”的测试点，保证对于所有边有 $a = 1$。\n- 强制在线：对于表格中该项为“是”的测试点，保证 $K = 1$；如果该项为“否”，则有 $K = 0$。\n- 对于所有测试点，如果上述对应项为“不保证”，则对该项内容不作任何保证。\n\n| $n$              | $m$              | $Q$        | 测试点 | 形态      | 海拔      | 强制在线 |\n|------------------|------------------|------------|--------|-----------|-----------|----------|\n| $\\leq 1$         | $\\leq 0$         | $0$        | 1      | 不保证    | 一种      | 否        |\n| $\\leq 6$         | $\\leq 10$        | $10$       | 2      | ^         | ^         | ^         |\n| $\\leq 50$        | $\\leq 150$       | $100$      | 3      | ^         | ^         | ^         |\n| $\\leq 100$       | $\\leq 300$       | $200$      | 4      | ^         | ^         | ^         |\n| $\\leq 1500$      | $\\leq 4000$      | $2000$     | 5      | ^         | ^         | ^         |\n| $\\leq 200000$    | $\\leq 400000$    | $100000$   | 6      | ^         | ^         | ^         |\n| $\\leq 1500$      | $=n-1$           | $2000$     | 7      | 一条链    | 不保证    | ^         |\n| ^                | ^                | ^          | 8      | ^         | ^         | ^         |\n| ^                | ^                | ^          | 9      | ^         | ^         | ^         |\n| $\\leq 200000$    | ^                | $100000$   | 10     | 一棵树    | ^         | ^         |\n| ^                | ^                | ^          | 11     | ^         | ^         | 是        |\n| ^                | $\\leq 400000$    | ^          | 12     | 不保证    | ^         | 否        |\n| ^                | ^                | ^          | 13     | ^         | ^         | ^         |\n| ^                | ^                | ^          | 14     | ^         | ^         | ^         |\n| $\\leq 1500$      | $\\leq 4000$      | $2000$     | 15     | ^         | ^         | 是        |\n| ^                | ^                | ^          | 16     | ^         | ^         | ^         |\n| $\\leq 200000$    | $\\leq 400000$    | $100000$   | 17     | ^         | ^         | ^         |\n| ^                | ^                | ^          | 18     | ^         | ^         | ^         |\n| ^                | ^                | $400000$   | 19     | ^         | ^         | ^         |\n| ^                | ^                | ^          | 20     | ^         | ^         | ^         |", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2018] Return Journey", "background": "", "description": "The story of this problem takes place in the City of Magic. Here we introduce some necessary settings.\n\nThe City of Magic can be abstracted as a connected undirected graph with $n$ nodes and $m$ edges (the nodes are numbered from $1$ to $n$). For each edge, we use $l, a$ to describe its **length** and **altitude**.\n\nAs a typical monsoon-climate city, the City of Magic often has rain, so water on roads is unavoidable. Since the drainage system of the whole city is connected, **the flooded edges must be those with relatively low altitude**. We use the **water level** to describe the amount of rain. Its meaning is: all edges whose altitude is **not greater than** the water level are **flooded**.\n\nYazid is an OIer from the City of Magic. After just finishing ION2018, he is going to start his return journey to his warm home. Yazid’s home happens to be at node $1$ of the City of Magic. For the next $Q$ days, each day Yazid will tell you his starting point $v$ and the water level $p$ of that day.\n\nEach day, Yazid has a car at the starting point. Because of some malfunctions, this car cannot pass through flooded edges. Yazid may get out of the car at any node; after that he can walk through flooded edges. However, the car will be left at the node where he gets out and will not be used again.\nNote in particular that the car will be reset on the next day, which means:\n\n- The car will be prepared at the new starting point.\n- Yazid cannot use a car parked somewhere previously.\n\nYazid really dislikes walking on rainy days, so while still getting home, he wants to minimize the total length of the **edges he walks through**. Please help Yazid compute this.\n\nSome test points of this problem are forced online. For details, see **Input Format** and **Subtasks**.", "inputFormat": "A single test file contains multiple test cases. The first line is a non-negative integer $T$, indicating the number of test cases.\n\nThen each test case is described as follows:\n\nThe first line contains two non-negative integers $n, m$, representing the number of nodes and edges.\n\nThe next $m$ lines each contain four positive integers $u, v, l, a$, describing an edge connecting nodes $u, v$ with length $l$ and altitude $a$.\nHere we guarantee $1 \\leq u,v \\leq n$.\n\nThe next line contains three non-negative integers $Q, K, S$, where $Q$ is the total number of days, $K \\in {0,1}$ is a coefficient used below, and $S$ is the maximum possible water level.\n\nThe next $Q$ lines describe the situation for each day. Each line contains two integers $v_0, p_0$:\n\n- The starting node is $v = (v_0 + K \\times \\mathrm{lastans} - 1) \\bmod n + 1$.\n- The water level is $p = (p_0 + K \\times \\mathrm{lastans}) \\bmod (S + 1)$.\n\nHere $\\mathrm{lastans}$ is the answer of the previous day (the minimum total walking distance). In particular, we define $\\mathrm{lastans} = 0$ on day $1$.\nWe guarantee $1 \\leq v_0 \\leq n$, $0 \\leq p_0 \\leq S$.\n\nFor each line of the input, if it contains multiple numbers, they are separated by a single space.", "outputFormat": "Output the answers for each test case in order. For each test case:\n\n- Output $Q$ lines, each containing one integer, representing the minimum total walking distance for each day.", "hint": "### More Samples\n\nMore samples can be downloaded from the additional files.\n\n#### Sample 3\n\nSee `return3.in` and `return3.ans` in the additional files.\n\nThis sample satisfies that there is only one altitude value, and it is not forced online.\n\n#### Sample 4\n\nSee `return4.in` and `return4.ans` in the additional files.\n\nThis sample satisfies that the graph is a chain, and it is forced online.\n\n#### Sample 5\n\nSee `return5.in` and `return5.ans` in the additional files.\n\nThis sample is not forced online.\n\n### Explanation of Sample 1\n\nOn the first day there is no rainfall, so Yazid can drive directly home.\n\nOn the second, third, and fourth days, the flooded situation is the same: the edge connecting nodes 1 and 2, and the edge connecting nodes 3 and 4 are flooded.\n\nOn the second day, Yazid starts from node 2. By car he can only go to node 3, which does not help him get home. Therefore, Yazid can only walk all the way home.\n\nOn the third day, the only edge from node 4 is flooded, so the car becomes useless. Yazid can only walk all the way home.\n\nOn the fourth day, Yazid can drive to node 2 first, then walk home.\n\nOn the fifth day, all edges are flooded, so Yazid can only walk all the way home.\n\n### Explanation of Sample 2\n\nThis test case is forced online.\n\nThe answer on day 1 is $0$, so on day 2, $v=\\left( 5+0-1\\right)\\bmod 5+1=5$, $p=\\left(2+0\\right)\\bmod\\left(3+1\\right)=2$.\n\nThe answer on day 2 is $2$, so on day 3, $v=\\left( 2+2-1\\right)\\bmod 5+1=4$, $p=\\left(0+2\\right)\\bmod\\left(3+1\\right)=2$.\n\nThe answer on day 3 is $3$, so on day 4, $v=\\left( 4+3-1\\right)\\bmod 5+1=2$, $p=\\left(0+3\\right)\\bmod\\left(3+1\\right)=3$.\n\n### Constraints and Conventions\n\nAll test points guarantee $T\\leq 3$. All data in all test points satisfy the following limits:\n\n- $n\\leq 2\\times 10^5$, $m\\leq 4\\times 10^5$, $Q\\leq 4\\times 10^5$, $K\\in\\left\\{0,1\\right\\}$, $1\\leq S\\leq 10^9$.\n- For all edges: $l\\leq 10^4$, $a\\leq 10^9$.\n- Any two nodes are connected directly or indirectly by edges.\n\n**To help you understand quickly, we use some easy expressions in the table. Here we give formal explanations:**\n\n- Graph shape: for test points where this item is “a tree” or “a chain”, it is guaranteed that $m = n-1$. In addition, these two types satisfy:\n  - A tree: the input graph is a tree, i.e. edges do not form cycles.\n  - A chain: all edges satisfy $u + 1 = v$.\n- Altitude: for test points where this item is “one value”, it is guaranteed that for all edges $a = 1$.\n- Forced online: for test points where this item is “yes”, it is guaranteed that $K = 1$; if it is “no”, then $K = 0$.\n- For all test points, if the corresponding item is “not guaranteed”, then no guarantee is made for that item.\n\n| $n$              | $m$              | $Q$        | Test point | Shape           | Altitude          | Forced online |\n|------------------|------------------|------------|------------|-----------------|-------------------|--------------|\n| $\\leq 1$         | $\\leq 0$         | $0$        | 1          | Not guaranteed  | One value         | No           |\n| $\\leq 6$         | $\\leq 10$        | $10$       | 2          | ^               | ^                 | ^            |\n| $\\leq 50$        | $\\leq 150$       | $100$      | 3          | ^               | ^                 | ^            |\n| $\\leq 100$       | $\\leq 300$       | $200$      | 4          | ^               | ^                 | ^            |\n| $\\leq 1500$      | $\\leq 4000$      | $2000$     | 5          | ^               | ^                 | ^            |\n| $\\leq 200000$    | $\\leq 400000$    | $100000$   | 6          | ^               | ^                 | ^            |\n| $\\leq 1500$      | $=n-1$           | $2000$     | 7          | A chain         | Not guaranteed    | ^            |\n| ^                | ^                | ^          | 8          | ^               | ^                 | ^            |\n| ^                | ^                | ^          | 9          | ^               | ^                 | ^            |\n| $\\leq 200000$    | ^                | $100000$   | 10         | A tree          | ^                 | ^            |\n| ^                | ^                | ^          | 11         | ^               | ^                 | Yes          |\n| ^                | $\\leq 400000$    | ^          | 12         | Not guaranteed  | ^                 | No           |\n| ^                | ^                | ^          | 13         | ^               | ^                 | ^            |\n| ^                | ^                | ^          | 14         | ^               | ^                 | ^            |\n| $\\leq 1500$      | $\\leq 4000$      | $2000$     | 15         | ^               | ^                 | Yes          |\n| ^                | ^                | ^          | 16         | ^               | ^                 | ^            |\n| $\\leq 200000$    | $\\leq 400000$    | $100000$   | 17         | ^               | ^                 | ^            |\n| ^                | ^                | ^          | 18         | ^               | ^                 | ^            |\n| ^                | ^                | $400000$   | 19         | ^               | ^                 | ^            |\n| ^                | ^                | ^          | 20         | ^               | ^                 | ^            |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2018] 归程", "background": null, "description": "本题的故事发生在魔力之都，在这里我们将为你介绍一些必要的设定。\n\n魔力之都可以抽象成一个 $n$ 个节点、$m$ 条边的无向连通图（节点的编号从 $1$ 至 $n$）。我们依次用 $l,a$ 描述一条边的**长度、海拔**。\n\n作为季风气候的代表城市，魔力之都时常有雨水相伴，因此道路积水总是不可避免的。由于整个城市的排水系统连通，因此**有积水的边一定是海拔相对最低的一些边**。我们用**水位线**来描述降雨的程度，它的意义是：所有海拔**不超过**水位线的边都是**有积水**的。\n\nYazid 是一名来自魔力之都的 OIer，刚参加完 ION2018 的他将踏上归程，回到他温暖的家。Yazid 的家恰好在魔力之都的 $1$ 号节点。对于接下来 $Q$ 天，每一天 Yazid 都会告诉你他的出发点 $v$，以及当天的水位线 $p$。\n\n每一天，Yazid 在出发点都拥有一辆车。这辆车由于一些故障不能经过有积水的边。Yazid 可以在任意节点下车，这样接下来他就可以步行经过有积水的边。但车会被留在他下车的节点并不会再被使用。\n需要特殊说明的是，第二天车会被重置，这意味着：\n\n- 车会在新的出发点被准备好。\n- Yazid 不能利用之前在某处停放的车。\n\nYazid 非常讨厌在雨天步行，因此他希望在完成回家这一目标的同时，最小化他**步行经过的边**的总长度。请你帮助 Yazid 进行计算。\n\n本题的部分测试点将强制在线，具体细节请见【输入格式】和【子任务】。", "inputFormat": "单个测试点中包含多组数据。输入的第一行为一个非负整数 $T$，表示数据的组数。\n\n接下来依次描述每组数据，对于每组数据：\n\n第一行 $2$ 个非负整数 $n,m$，分别表示节点数、边数。\n\n接下来 $m$ 行，每行 $4$ 个正整数 $u, v, l, a$，描述一条连接节点 $u, v$ 的、长度为 $l$、海拔为 $a$ 的边。\n在这里，我们保证 $1 \\leq u,v \\leq n$。\n\n接下来一行 $3$ 个非负数 $Q, K, S$，其中 $Q$ 表示总天数，$K \\in {0,1}$ 是一个会在下面被用到的系数，$S$ 表示的是可能的最高水位线。\n\n接下来 $Q$ 行依次描述每天的状况。每行 $2$ 个整数 $v_0, p_0$ 描述一天：\n\n- 这一天的出发节点为 $v = (v_0 + K \\times \\mathrm{lastans} - 1) \\bmod n + 1$。\n- 这一天的水位线为 $p = (p_0 + K \\times \\mathrm{lastans}) \\bmod (S + 1)$。\n\n其中 $\\mathrm{lastans}$ 表示上一天的答案（最小步行总路程）。特别地，我们规定第 $1$ 天时 $\\mathrm{lastans} = 0$。\n在这里，我们保证 $1 \\leq v_0 \\leq n$，$0 \\leq p_0 \\leq S$。\n\n对于输入中的每一行，如果该行包含多个数，则用单个空格将它们隔开。", "outputFormat": "依次输出各组数据的答案。对于每组数据：\n\n- 输出 $Q$ 行每行一个整数，依次表示每天的最小步行总路程。", "hint": "### 更多样例\n\n更多样例请在附加文件中下载。\n\n#### 样例 3\n\n见附加文件中的 `return3.in` 与 `return3.ans`。\n\n该样例满足海拔为一种，且不强制在线。\n\n#### 样例 4\n\n见附加文件中的 `return4.in` 与 `return4.ans`。\n\n该样例满足图形态为一条链，且强制在线。\n\n#### 样例 5\n\n见附加文件中的 `return5.in` 与 `return5.ans`。\n\n该样例满足不强制在线。\n\n### 样例 1 解释\n\n第一天没有降水，Yazid 可以坐车直接回到家中。\n\n第二天、第三天、第四天的积水情况相同，均为连接 1，2 号节点的边、连接 3，4 号点的边有积水。\n\n对于第二天，Yazid 从 2 号点出发坐车只能去往 3 号节点，对回家没有帮助。因此 Yazid 只能纯靠徒步回家。\n\n对于第三天，从 4 号节点出发的唯一一条边是有积水的，车也就变得无用了。Yazid 只能纯靠徒步回家。\n\n对于第四天，Yazid 可以坐车先到达 2 号节点，再步行回家。\n\n第五天所有的边都积水了，因此 Yazid 只能纯靠徒步回家。\n\n### 样例 2 解释\n\n本组数据强制在线。\n\n第一天的答案是 $0$，因此第二天的 $v=\\left( 5+0-1\\right)\\bmod 5+1=5$，$p=\\left(2+0\\right)\\bmod\\left(3+1\\right)=2$。\n\n第二天的答案是 $2$，因此第三天的 $v=\\left( 2+2-1\\right)\\bmod 5+1=4$，$p=\\left(0+2\\right)\\bmod\\left(3+1\\right)=2$。\n\n第三天的答案是 $3$，因此第四天的 $v=\\left( 4+3-1\\right)\\bmod 5+1=2$，$p=\\left(0+3\\right)\\bmod\\left(3+1\\right)=3$。\n\n### 数据范围与约定\n\n所有测试点均保证 $T\\leq 3$，所有测试点中的所有数据均满足如下限制：\n\n- $n\\leq 2\\times 10^5$，$m\\leq 4\\times 10^5$，$Q\\leq 4\\times 10^5$，$K\\in\\left\\{0,1\\right\\}$，$1\\leq S\\leq 10^9$。\n- 对于所有边：$l\\leq 10^4$，$a\\leq 10^9$。\n- 任意两点之间都直接或间接通过边相连。\n\n**为了方便你快速理解，我们在表格中使用了一些简单易懂的表述。在此，我们对这些内容作形式化的说明：**\n\n- 图形态：对于表格中该项为“一棵树”或“一条链”的测试点，保证 $m = n-1$。除此之外，这两类测试点分别满足如下限制：\n  - 一棵树：保证输入的图是一棵树，即保证边不会构成回路。\n  - 一条链：保证所有边满足 $u + 1 = v$。\n- 海拔：对于表格中该项为“一种”的测试点，保证对于所有边有 $a = 1$。\n- 强制在线：对于表格中该项为“是”的测试点，保证 $K = 1$；如果该项为“否”，则有 $K = 0$。\n- 对于所有测试点，如果上述对应项为“不保证”，则对该项内容不作任何保证。\n\n| $n$              | $m$              | $Q$        | 测试点 | 形态      | 海拔      | 强制在线 |\n|------------------|------------------|------------|--------|-----------|-----------|----------|\n| $\\leq 1$         | $\\leq 0$         | $0$        | 1      | 不保证    | 一种      | 否        |\n| $\\leq 6$         | $\\leq 10$        | $10$       | 2      | ^         | ^         | ^         |\n| $\\leq 50$        | $\\leq 150$       | $100$      | 3      | ^         | ^         | ^         |\n| $\\leq 100$       | $\\leq 300$       | $200$      | 4      | ^         | ^         | ^         |\n| $\\leq 1500$      | $\\leq 4000$      | $2000$     | 5      | ^         | ^         | ^         |\n| $\\leq 200000$    | $\\leq 400000$    | $100000$   | 6      | ^         | ^         | ^         |\n| $\\leq 1500$      | $=n-1$           | $2000$     | 7      | 一条链    | 不保证    | ^         |\n| ^                | ^                | ^          | 8      | ^         | ^         | ^         |\n| ^                | ^                | ^          | 9      | ^         | ^         | ^         |\n| $\\leq 200000$    | ^                | $100000$   | 10     | 一棵树    | ^         | ^         |\n| ^                | ^                | ^          | 11     | ^         | ^         | 是        |\n| ^                | $\\leq 400000$    | ^          | 12     | 不保证    | ^         | 否        |\n| ^                | ^                | ^          | 13     | ^         | ^         | ^         |\n| ^                | ^                | ^          | 14     | ^         | ^         | ^         |\n| $\\leq 1500$      | $\\leq 4000$      | $2000$     | 15     | ^         | ^         | 是        |\n| ^                | ^                | ^          | 16     | ^         | ^         | ^         |\n| $\\leq 200000$    | $\\leq 400000$    | $100000$   | 17     | ^         | ^         | ^         |\n| ^                | ^                | ^          | 18     | ^         | ^         | ^         |\n| ^                | ^                | $400000$   | 19     | ^         | ^         | ^         |\n| ^                | ^                | ^          | 20     | ^         | ^         | ^         |", "locale": "zh-CN"}}}
{"pid": "P4769", "type": "P", "difficulty": 7, "samples": [["1\n3\n1 3 2", "3"], ["1\n4\n1 4 2 3", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "树状数组", "NOI", "O2优化", "Catalan 数", "栈"], "title": "[NOI2018] 冒泡排序", "background": "请注意，题目中存在 $n=0$ 的数据。", "description": "最近，小 S 对冒泡排序产生了浓厚的兴趣。为了问题简单，小 S 只研究对 **$1$ 到 $n$ 的排列**的冒泡排序。\n\n下面是对冒泡排序的算法描述。\n\n```plain\n输入：一个长度为 n 的排列 p[1...n]\n输出：p 排序后的结果。\nfor i = 1 to n do\n\tfor j = 1 to n - 1 do\n\t\tif(p[j] > p[j + 1])\n\t\t\t交换 p[j] 与 p[j + 1] 的值\n```\n\n冒泡排序的交换次数被定义为交换过程的执行次数。可以证明交换次数的一个下界是 $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$，其中 $p_i$ 是排列 $p$ 中第 $i$ 个位置的数字。如果你对证明感兴趣，可以看提示。\n\n小 S 开始专注于研究长度为 $n$ 的排列中，满足交换次数 $= \\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ 的排列（在后文中，为了方便，我们把所有这样的排列叫「好」的排列）。他进一步想，这样的排列到底多不多？它们分布的密不密集？\n\n小 S 想要对于一个给定的长度为 $n$ 的排列 $q$，计算字典序严格大于 $q$ 的“好”的排列个数。但是他不会做，于是求助于你，希望你帮他解决这个问题，考虑到答案可能会很大，因此只需输出答案对 $998244353$ 取模的结果。", "inputFormat": "输入第一行包含一个正整数 $T$，表示数据组数。\n\n对于每组数据，第一行有一个正整数 $n$，保证 $n \\leq 6 \\times 10^5$。\n\n接下来一行会输入 $n$ 个正整数，对应于题目描述中的 $q_i$，保证输入的是一个 $1$ 到 $n$ 的排列。", "outputFormat": "输出共 $T$ 行，每行一个整数。\n\n对于每组数据，输出一个整数，表示字典序严格大于 $q$ 的「好」的排列个数对 $998244353$ 取模的结果。", "hint": "### 更多样例\n\n更多样例请在附加文件中下载。\n\n#### 样例 3\n\n见附加文件中的 `inverse3.in` 与 `inverse3.ans`。\n\n### 样例 1 解释\n\n字典序比 $1 \\ 3 \\ 2$ 大的排列中，除了 $3 \\ 2 \\ 1$ 以外都是「好」的排列，故答案为 $3$。\n\n### 数据范围\n\n下面是对本题每个测试点的输入规模的说明。\n\n对于所有数据，均满足 $T = 5$（样例可能不满足）。\n\n记 $n_\\mathrm{max}$ 表示每组数据中 $n$ 的最大值，$\\sum n$ 表示所有数据的 $n$ 的和。\n\n::cute-table{tuack}\n\n| 测试点 | $n_\\mathrm{max} =$ | $\\sum n \\leq$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|\n| $1$ | $8$ | $5 \\ n_\\mathrm{max}$ | 无 |\n| $2$ | $9$ | ^ | ^ |\n| $3$ | $10$ | ^ | ^ |\n| $4$ | $12$ | ^ | ^ |\n| $5$ | $13$ | ^ | ^ |\n| $6$ | $14$ | ^ | ^ |\n| $7$ | $16$ | ^ | ^ |\n| $8$ | $16$ | ^ | ^ |\n| $9$ | $17$ | ^ | ^ |\n| $10$ | $18$ | ^ | ^ |\n| $11$ | $18$ | ^ | ^ |\n| $12$ | $122$ | $700$ | $\\forall i \\enspace q_i = i$ |\n| $13$ | $144$ | ^ | 无 |\n| $14$ | $166$ | ^ | ^ |\n| $15$ | $200$ | ^ | ^ |\n| $16$ | $233$ | ^ | ^ |\n| $17$ | $777$ | $4000$ | $\\forall i \\enspace q_i = i$ |\n| $18$ | $888$ | ^ | 无 |\n| $19$ | $933$ | ^ | ^ |\n| $20$ | $1000$ | ^ | ^ |\n| $21$ | $266666$ | $2000000$ | $\\forall i \\enspace q_i = i$ |\n| $22$ | $333333$ | ^ | 无 |\n| $23$ | $444444$ | ^ | ^ |\n| $24$ | $555555$ | ^ | ^ |\n| $25$ | $600000$ | ^ | ^ |\n\n### 提示\n\n下面是对交换次数下界是 $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ 的证明。\n\n排序本质上就是数字的移动，因此排序的交换次数应当可以用数字移动的总距离来描述。对于第 $i$ 个位置，假设在初始排列中，这个位置上的数字是 $p_i$，那么我们需要将这个数字移动到第 $p_i$ 个位置上，移动的距离是 $\\lvert i - p_i \\rvert$。从而移动的总距离就是 $\\sum_{i=1}^n \\lvert i - p_i \\rvert$，而冒泡排序每次会交换两个相邻的数字，每次交换可以使移动的总距离至多减少 $2$。因此 $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ 是冒泡排序的交换次数的下界。\n\n并不是所有的排列都达到了下界，比如在 $n = 3$ 的时候，考虑排列 $3 \\ 2 \\ 1$，这个排列进行冒泡排序以后的交换次数是 $3$，但是 $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ 只有 $2$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2018] Bubble Sort.", "background": "Please note that the testdata includes cases with $n = 0$.", "description": "Recently, Xiao S has become very interested in bubble sort. To simplify the problem, Xiao S only studies bubble sorting permutations of $1$ to $n$.\n\nBelow is the algorithm description of bubble sort.\n\n```plain\nInput: a permutation p[1...n] of length n\nOutput: the sorted result of p.\nfor i = 1 to n do\n\tfor j = 1 to n - 1 do\n\t\tif(p[j] > p[j + 1])\n\t\t\tswap the values of p[j] and p[j + 1]\n```\n\nThe number of swaps in bubble sort is defined as the number of times the swap operation is executed. It can be proven that a lower bound of the swap count is $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$, where $p_i$ is the number at position $i$ in the permutation $p$. If you are interested in the proof, you can read the hint.\n\nXiao S starts focusing on permutations of length $n$ that satisfy swap count $= \\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ (later, for convenience, we call all such permutations “good” permutations). He further wonders: are there many such permutations? Are they dense?\n\nFor a given permutation $q$ of length $n$, Xiao S wants to compute the number of “good” permutations that are strictly greater than $q$ in lexicographical order. However, he cannot do it, so he asks you for help. Since the answer may be very large, you only need to output the result modulo $998244353$.", "inputFormat": "The first line contains a positive integer $T$, indicating the number of test cases.\n\nFor each test case, the first line contains a positive integer $n$, with $n \\leq 6 \\times 10^5$.\n\nThe next line contains $n$ positive integers, corresponding to $q_i$ in the statement, and it is guaranteed that the input is a permutation of $1$ to $n$.", "outputFormat": "Output $T$ lines, each containing one integer.\n\nFor each test case, output one integer: the number of “good” permutations that are strictly greater than $q$ in lexicographical order, modulo $998244353$.", "hint": "### More Samples\n\nPlease download more samples from the attachment.\n\n#### Sample 3\n\nSee `inverse3.in` and `inverse3.ans` in the attachment.\n\n### Explanation for Sample 1\n\nAmong the permutations that are lexicographically greater than $1 \\ 3 \\ 2$, all of them are “good” except $3 \\ 2 \\ 1$, so the answer is $3$.\n\n### Constraints\n\nBelow is a description of the input size for each test point.\n\nFor all testdata, it holds that $T = 5$ (samples may not satisfy this).\n\nLet $n_\\mathrm{max}$ be the maximum $n$ among the test cases, and let $\\sum n$ be the sum of $n$ over all test cases.\n\n::cute-table{tuack}\n\n| Test Point | $n_\\mathrm{max} =$ | $\\sum n \\leq$ | Special Properties |\n|:-:|:-:|:-:|:-:|\n| $1$ | $8$ | $5 \\ n_\\mathrm{max}$ | None |\n| $2$ | $9$ | ^ | ^ |\n| $3$ | $10$ | ^ | ^ |\n| $4$ | $12$ | ^ | ^ |\n| $5$ | $13$ | ^ | ^ |\n| $6$ | $14$ | ^ | ^ |\n| $7$ | $16$ | ^ | ^ |\n| $8$ | $16$ | ^ | ^ |\n| $9$ | $17$ | ^ | ^ |\n| $10$ | $18$ | ^ | ^ |\n| $11$ | $18$ | ^ | ^ |\n| $12$ | $122$ | $700$ | $\\forall i \\enspace q_i = i$ |\n| $13$ | $144$ | ^ | None |\n| $14$ | $166$ | ^ | ^ |\n| $15$ | $200$ | ^ | ^ |\n| $16$ | $233$ | ^ | ^ |\n| $17$ | $777$ | $4000$ | $\\forall i \\enspace q_i = i$ |\n| $18$ | $888$ | ^ | None |\n| $19$ | $933$ | ^ | ^ |\n| $20$ | $1000$ | ^ | ^ |\n| $21$ | $266666$ | $2000000$ | $\\forall i \\enspace q_i = i$ |\n| $22$ | $333333$ | ^ | None |\n| $23$ | $444444$ | ^ | ^ |\n| $24$ | $555555$ | ^ | ^ |\n| $25$ | $600000$ | ^ | ^ |\n\n### Hint\n\nBelow is the proof that a lower bound of the swap count is $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$.\n\nSorting is essentially moving numbers, so the number of swaps in sorting can be described by the total distance that numbers move. For position $i$, suppose the number at this position in the initial permutation is $p_i$. Then we need to move this number to position $p_i$, and the moving distance is $\\lvert i - p_i \\rvert$. Therefore, the total moving distance is $\\sum_{i=1}^n \\lvert i - p_i \\rvert$. Each step of bubble sort swaps two adjacent numbers, and each swap can reduce the total moving distance by at most $2$. Hence, $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ is a lower bound of the swap count in bubble sort.\n\nNot all permutations reach this lower bound. For example, when $n = 3$, consider the permutation $3 \\ 2 \\ 1$. The number of swaps after bubble sorting this permutation is $3$, but $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ is only $2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2018] 冒泡排序", "background": "请注意，题目中存在 $n=0$ 的数据。", "description": "最近，小 S 对冒泡排序产生了浓厚的兴趣。为了问题简单，小 S 只研究对 **$1$ 到 $n$ 的排列**的冒泡排序。\n\n下面是对冒泡排序的算法描述。\n\n```plain\n输入：一个长度为 n 的排列 p[1...n]\n输出：p 排序后的结果。\nfor i = 1 to n do\n\tfor j = 1 to n - 1 do\n\t\tif(p[j] > p[j + 1])\n\t\t\t交换 p[j] 与 p[j + 1] 的值\n```\n\n冒泡排序的交换次数被定义为交换过程的执行次数。可以证明交换次数的一个下界是 $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$，其中 $p_i$ 是排列 $p$ 中第 $i$ 个位置的数字。如果你对证明感兴趣，可以看提示。\n\n小 S 开始专注于研究长度为 $n$ 的排列中，满足交换次数 $= \\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ 的排列（在后文中，为了方便，我们把所有这样的排列叫「好」的排列）。他进一步想，这样的排列到底多不多？它们分布的密不密集？\n\n小 S 想要对于一个给定的长度为 $n$ 的排列 $q$，计算字典序严格大于 $q$ 的“好”的排列个数。但是他不会做，于是求助于你，希望你帮他解决这个问题，考虑到答案可能会很大，因此只需输出答案对 $998244353$ 取模的结果。", "inputFormat": "输入第一行包含一个正整数 $T$，表示数据组数。\n\n对于每组数据，第一行有一个正整数 $n$，保证 $n \\leq 6 \\times 10^5$。\n\n接下来一行会输入 $n$ 个正整数，对应于题目描述中的 $q_i$，保证输入的是一个 $1$ 到 $n$ 的排列。", "outputFormat": "输出共 $T$ 行，每行一个整数。\n\n对于每组数据，输出一个整数，表示字典序严格大于 $q$ 的「好」的排列个数对 $998244353$ 取模的结果。", "hint": "### 更多样例\n\n更多样例请在附加文件中下载。\n\n#### 样例 3\n\n见附加文件中的 `inverse3.in` 与 `inverse3.ans`。\n\n### 样例 1 解释\n\n字典序比 $1 \\ 3 \\ 2$ 大的排列中，除了 $3 \\ 2 \\ 1$ 以外都是「好」的排列，故答案为 $3$。\n\n### 数据范围\n\n下面是对本题每个测试点的输入规模的说明。\n\n对于所有数据，均满足 $T = 5$（样例可能不满足）。\n\n记 $n_\\mathrm{max}$ 表示每组数据中 $n$ 的最大值，$\\sum n$ 表示所有数据的 $n$ 的和。\n\n::cute-table{tuack}\n\n| 测试点 | $n_\\mathrm{max} =$ | $\\sum n \\leq$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|\n| $1$ | $8$ | $5 \\ n_\\mathrm{max}$ | 无 |\n| $2$ | $9$ | ^ | ^ |\n| $3$ | $10$ | ^ | ^ |\n| $4$ | $12$ | ^ | ^ |\n| $5$ | $13$ | ^ | ^ |\n| $6$ | $14$ | ^ | ^ |\n| $7$ | $16$ | ^ | ^ |\n| $8$ | $16$ | ^ | ^ |\n| $9$ | $17$ | ^ | ^ |\n| $10$ | $18$ | ^ | ^ |\n| $11$ | $18$ | ^ | ^ |\n| $12$ | $122$ | $700$ | $\\forall i \\enspace q_i = i$ |\n| $13$ | $144$ | ^ | 无 |\n| $14$ | $166$ | ^ | ^ |\n| $15$ | $200$ | ^ | ^ |\n| $16$ | $233$ | ^ | ^ |\n| $17$ | $777$ | $4000$ | $\\forall i \\enspace q_i = i$ |\n| $18$ | $888$ | ^ | 无 |\n| $19$ | $933$ | ^ | ^ |\n| $20$ | $1000$ | ^ | ^ |\n| $21$ | $266666$ | $2000000$ | $\\forall i \\enspace q_i = i$ |\n| $22$ | $333333$ | ^ | 无 |\n| $23$ | $444444$ | ^ | ^ |\n| $24$ | $555555$ | ^ | ^ |\n| $25$ | $600000$ | ^ | ^ |\n\n### 提示\n\n下面是对交换次数下界是 $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ 的证明。\n\n排序本质上就是数字的移动，因此排序的交换次数应当可以用数字移动的总距离来描述。对于第 $i$ 个位置，假设在初始排列中，这个位置上的数字是 $p_i$，那么我们需要将这个数字移动到第 $p_i$ 个位置上，移动的距离是 $\\lvert i - p_i \\rvert$。从而移动的总距离就是 $\\sum_{i=1}^n \\lvert i - p_i \\rvert$，而冒泡排序每次会交换两个相邻的数字，每次交换可以使移动的总距离至多减少 $2$。因此 $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ 是冒泡排序的交换次数的下界。\n\n并不是所有的排列都达到了下界，比如在 $n = 3$ 的时候，考虑排列 $3 \\ 2 \\ 1$，这个排列进行冒泡排序以后的交换次数是 $3$，但是 $\\frac 1 2 \\sum_{i=1}^n \\lvert i - p_i \\rvert$ 只有 $2$。", "locale": "zh-CN"}}}
{"pid": "P4770", "type": "P", "difficulty": 7, "samples": [["scbamgepe\n3\nsmape 2 7\nsbape 3 8\nsgepe 1 9", "12\n10\n4"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "线段树", "NOI", "后缀自动机 SAM", "O2优化", "可持久化线段树", "后缀数组 SA", "线段树合并"], "title": "[NOI2018] 你的名字", "background": "实力强大的小 A 被选为了 ION2018 的出题人，现在他需要解决题目的命名问题。", "description": "小 A 被选为了 ION2018 的出题人，他精心准备了一道质量十分高的题目，且已经把除了题目命名以外的工作都做好了。\n\n由于 ION 已经举办了很多届，所以在题目命名上也是有规定的，ION 命题手册规定：每年由命题委员会规定一个小写字母字符串，我们称之为那一年的命名串，要求每道题的名字必须是那一年的命名串的一个非空连续子串，且不能和前一年的任何一道题目的名字相同。\n\n由于一些特殊的原因，小 A 不知道 ION2017 每道题的名字，但是他通过一些特殊手段得到了 ION2017 的命名串，现在小 A 有 $Q$ 次询问：每次给定 ION2017 的命名串和 ION2018 的命名串，求有几种题目的命名，使得这个名字一定满足命题委员会的规定，即是 ION2018 的命名串的一个非空连续子串且一定不会和 ION2017 的任何一道题目的名字相同。\n\n由于一些特殊原因，所有询问给出的 ION2017 的命名串都是某个串的连续子串，详细可见输入格式。", "inputFormat": "第一行一个字符串 $S$ ，之后询问给出的 ION2017 的命名串都是 $S$ 的连续子串。\n第二行一个正整数 $Q$，表示询问次数。\n接下来 $Q$ 行，每行有一个字符串 $T$ 和两个正整数$l,r$，表示询问如果 ION2017 的命名串是 $S_{l\\ldots r}$，ION2018 的命名串是 $T$ 的话，有几种命名方式一定满足规定。", "outputFormat": "输出 $Q$ 行，第 $i$ 行一个非负整数表示第 $i$ 个询问的答案。", "hint": "### 更多样例\n\n更多样例请在附加文件中下载。\n\n#### 样例 2\n\n见附加文件中的 `name2.in` 与 `name2.ans`。\n\n### 数据范围\n\n::cute-table{tuack}\n\n|测试点|$\\vert S\\vert \\leq$　|$Q\\leq $　|$\\sum \\vert T\\vert \\leq $ |询问限制　|其他限制|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|$1$|$200$|$200$|$40000$|对于所有询问有 $l = 1, r=\\vert S\\vert$|$T\\leq 200$|\n|$2$|$1000$|^|^|^|^|\n|$3$|^|^|^|^|^|\n|$4$|^|^|$5 \\times 10^5$|^|无|\n|$5$|^|^|^|^|^|\n|$6$|$5 \\times 10^5$|$1$|^|^|^|\n|$7$|^|^|^|^|^|\n|$8$|$10^5$|$10^5$|$2 \\times 10^5$|^|^|\n|$9$|^|^|^|^|字符串随机|\n|$10$|$2 \\times 10^5$|^|$4 \\times 10^5$|^|无|\n|$11$|^|^|^|^|字符串随机|\n|$12$|$3 \\times 10^5$|^|$6 \\times 10^5$|^|无|\n|$13$|^|^|^|^|字符串随机|\n|$14$|$4 \\times 10^5$|^|$8 \\times 10^5$|^|无|\n|$15$|^|^|^|^|字符串随机|\n|$16$|$5 \\times 10^5$|^|$10^6$|^|无|\n|$17$|^|^|^|^|字符串随机|\n|$18$|$2 \\times 10^5$|^|^|无|无|\n|$19$|$3 \\times 10^5$|^|^|^|^|\n|$20$|$4 \\times 10^5$|^|^|^|^|\n|$21$|$5 \\times 10^5$|^|^|^|^|\n|$22$|^|^|^|^|^|\n|$23$|^|^|^|^|^|\n|$24$|^|^|^|^|^|\n|$25$|^|^|^|^|^|\n\n对于所有数据，保证 $1\\leq l \\leq r \\leq |S|$，$1\\leq |T|\\leq 5 \\times 10^5$\n\n感谢 @Wen_kr 提供的一组 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2018] Your Name", "background": "The very capable Little A was chosen as the problem setter for ION2018, and now he needs to solve the problem of naming the tasks.", "description": "Little A was chosen as the problem setter for ION2018. He carefully prepared a very high-quality problem, and has already finished all the work except naming the problem.\n\nSince ION has been held for many years, there are also rules for naming problems. The ION problem-setting manual states: every year, the problem committee specifies a lowercase-letter string, which we call that year's naming string. The name of each problem must be a non-empty contiguous substring of that year's naming string, and it must not be the same as the name of any problem in the previous year.\n\nFor some special reasons, Little A does not know the names of each problem in ION2017, but through some special means he obtained the ION2017 naming string. Now Little A has $Q$ queries: each time, given the ION2017 naming string and the ION2018 naming string, find how many possible problem names are guaranteed to satisfy the committee's rules, that is, the name is a non-empty contiguous substring of the ION2018 naming string and is guaranteed not to be the same as the name of any problem in ION2017.\n\nFor some special reasons, in all queries, the given ION2017 naming strings are contiguous substrings of some string. See the input format for details.", "inputFormat": "The first line contains a string $S$. In the queries below, the given ION2017 naming string is always a contiguous substring of $S$.\nThe second line contains a positive integer $Q$, indicating the number of queries.\nThe next $Q$ lines each contain a string $T$ and two positive integers $l, r$, meaning: if the ION2017 naming string is $S_{l\\ldots r}$ and the ION2018 naming string is $T$, then how many naming choices are guaranteed to satisfy the rules.", "outputFormat": "Output $Q$ lines. The $i$-th line contains a non-negative integer, representing the answer to the $i$-th query.", "hint": "### More Samples\n\nPlease download more samples from the additional files.\n\n#### Sample 2\n\nSee `name2.in` and `name2.ans` in the additional files.\n\n### Constraints\n\n::cute-table{tuack}\n\n|Test Point|$\\vert S\\vert \\leq$　|$Q\\leq $　|$\\sum \\vert T\\vert \\leq $ |Query Restrictions　|Other Restrictions|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|$1$|$200$|$200$|$40000$|For all queries, $l = 1, r=\\vert S\\vert$|$T\\leq 200$|\n|$2$|$1000$|^|^|^|^|\n|$3$|^|^|^|^|^|\n|$4$|^|^|$5 \\times 10^5$|^|None|\n|$5$|^|^|^|^|^|\n|$6$|$5 \\times 10^5$|$1$|^|^|^|\n|$7$|^|^|^|^|^|\n|$8$|$10^5$|$10^5$|$2 \\times 10^5$|^|^|\n|$9$|^|^|^|^|Random strings|\n|$10$|$2 \\times 10^5$|^|$4 \\times 10^5$|^|None|\n|$11$|^|^|^|^|Random strings|\n|$12$|$3 \\times 10^5$|^|$6 \\times 10^5$|^|None|\n|$13$|^|^|^|^|Random strings|\n|$14$|$4 \\times 10^5$|^|$8 \\times 10^5$|^|None|\n|$15$|^|^|^|^|Random strings|\n|$16$|$5 \\times 10^5$|^|$10^6$|^|None|\n|$17$|^|^|^|^|Random strings|\n|$18$|$2 \\times 10^5$|^|^|None|None|\n|$19$|$3 \\times 10^5$|^|^|^|^|\n|$20$|$4 \\times 10^5$|^|^|^|^|\n|$21$|$5 \\times 10^5$|^|^|^|^|\n|$22$|^|^|^|^|^|\n|$23$|^|^|^|^|^|\n|$24$|^|^|^|^|^|\n|$25$|^|^|^|^|^|\n\nFor all data, it is guaranteed that $1\\leq l \\leq r \\leq |S|$, $1\\leq |T|\\leq 5 \\times 10^5$.\n\nThanks to @Wen_kr for providing a set of hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2018] 你的名字", "background": "实力强大的小 A 被选为了 ION2018 的出题人，现在他需要解决题目的命名问题。", "description": "小 A 被选为了 ION2018 的出题人，他精心准备了一道质量十分高的题目，且已经把除了题目命名以外的工作都做好了。\n\n由于 ION 已经举办了很多届，所以在题目命名上也是有规定的，ION 命题手册规定：每年由命题委员会规定一个小写字母字符串，我们称之为那一年的命名串，要求每道题的名字必须是那一年的命名串的一个非空连续子串，且不能和前一年的任何一道题目的名字相同。\n\n由于一些特殊的原因，小 A 不知道 ION2017 每道题的名字，但是他通过一些特殊手段得到了 ION2017 的命名串，现在小 A 有 $Q$ 次询问：每次给定 ION2017 的命名串和 ION2018 的命名串，求有几种题目的命名，使得这个名字一定满足命题委员会的规定，即是 ION2018 的命名串的一个非空连续子串且一定不会和 ION2017 的任何一道题目的名字相同。\n\n由于一些特殊原因，所有询问给出的 ION2017 的命名串都是某个串的连续子串，详细可见输入格式。", "inputFormat": "第一行一个字符串 $S$ ，之后询问给出的 ION2017 的命名串都是 $S$ 的连续子串。\n第二行一个正整数 $Q$，表示询问次数。\n接下来 $Q$ 行，每行有一个字符串 $T$ 和两个正整数$l,r$，表示询问如果 ION2017 的命名串是 $S_{l\\ldots r}$，ION2018 的命名串是 $T$ 的话，有几种命名方式一定满足规定。", "outputFormat": "输出 $Q$ 行，第 $i$ 行一个非负整数表示第 $i$ 个询问的答案。", "hint": "### 更多样例\n\n更多样例请在附加文件中下载。\n\n#### 样例 2\n\n见附加文件中的 `name2.in` 与 `name2.ans`。\n\n### 数据范围\n\n::cute-table{tuack}\n\n|测试点|$\\vert S\\vert \\leq$　|$Q\\leq $　|$\\sum \\vert T\\vert \\leq $ |询问限制　|其他限制|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|$1$|$200$|$200$|$40000$|对于所有询问有 $l = 1, r=\\vert S\\vert$|$T\\leq 200$|\n|$2$|$1000$|^|^|^|^|\n|$3$|^|^|^|^|^|\n|$4$|^|^|$5 \\times 10^5$|^|无|\n|$5$|^|^|^|^|^|\n|$6$|$5 \\times 10^5$|$1$|^|^|^|\n|$7$|^|^|^|^|^|\n|$8$|$10^5$|$10^5$|$2 \\times 10^5$|^|^|\n|$9$|^|^|^|^|字符串随机|\n|$10$|$2 \\times 10^5$|^|$4 \\times 10^5$|^|无|\n|$11$|^|^|^|^|字符串随机|\n|$12$|$3 \\times 10^5$|^|$6 \\times 10^5$|^|无|\n|$13$|^|^|^|^|字符串随机|\n|$14$|$4 \\times 10^5$|^|$8 \\times 10^5$|^|无|\n|$15$|^|^|^|^|字符串随机|\n|$16$|$5 \\times 10^5$|^|$10^6$|^|无|\n|$17$|^|^|^|^|字符串随机|\n|$18$|$2 \\times 10^5$|^|^|无|无|\n|$19$|$3 \\times 10^5$|^|^|^|^|\n|$20$|$4 \\times 10^5$|^|^|^|^|\n|$21$|$5 \\times 10^5$|^|^|^|^|\n|$22$|^|^|^|^|^|\n|$23$|^|^|^|^|^|\n|$24$|^|^|^|^|^|\n|$25$|^|^|^|^|^|\n\n对于所有数据，保证 $1\\leq l \\leq r \\leq |S|$，$1\\leq |T|\\leq 5 \\times 10^5$\n\n感谢 @Wen_kr 提供的一组 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P4771", "type": "P", "difficulty": 2, "samples": [["5 5 5\n1 2 3 4 5\n2 3 4 5 1\n3 4 5 1 2\n4 5 1 2 3\n5 1 2 3 4\n1 2\n2 3\n3 4\n4 5\n5 1\n", "Pool Babingbaboom!\nPool Babingbaboom!\n1\n2\n0"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["二分", "枚举", "前缀和"], "title": "八百标兵奔北坡", "background": "baingbaboom 正在往北边跑！！！", "description": "现在在一张 $N*M$ 的地图上有 $K$ 只 babingbaboom ！！！对于一张地图上的点都有一个 $ h_{i,j} $ 来表示这个地方的高度。现在这些 babingbaboom 都想要跑到北边的一个山坡上。求出离每一个 babingbaboom 最近的靠北的山。\n\n补充定义：\n\n山：山的周围没有比它更高的地方（四连通）。\n\n在北边：令 Babingbaboom 的坐标为 $A(a,b)$，山的坐标为 $B(x,y)$，山在 Babingbaboom 的北边当且仅当 $dis_{A,B}=a-x$。\n\n切比雪夫距离：\n\n$A(x_1,y_1) B(x_2,y_2):dis_{A,B}=\\max(|x_1 - x_2|, |y_1 - y_2|)$", "inputFormat": "第 $1$ 行三个正整数 $N,M,K$。\n\n第 $3-N$ 行每行有 $M$ 个正整数 $h_{i,j}$。\n\n第 $K+3$ 行每行有两个正整数 $X_i,Y_i$，表示每一个 babingbaboom 的坐标。", "outputFormat": "共 $K$ 行。如果对于每一个 babingbaboom 存在这样的最近的山（切比雪夫距离），就输出这个 babingbaboom 到山的切比雪夫距离；否则输出“Pool Babingbaboom!”。", "hint": "保证 $ 1 \\leqslant  N,M \\leqslant 10^3$，$1 \\leqslant  K \\leqslant 10^5 $，$ 1 \\leqslant  h_{i,j} \\leqslant 10^9 $。\n\n数据有梯度！\n\n样例图片（星代表一个 Babingbaboom，红色代表一个山）：\n![](https://cdn.luogu.com.cn/upload/pic/22827.png)\n\n（竖的是 $x$，横的是 $y$。画的时候没注意，很抱歉。）", "locale": "zh-CN", "translations": {"en": {"title": "Eight Hundred Soldiers Rush to the Northern Slope", "background": "baingbaboom is running north!!!", "description": "Now on an $N*M$ map, there are $K$ babingbabooms!!! For each point on the map, there is a $h_{i,j}$ representing the height of that location. Now these babingbabooms all want to run to a mountain slope in the north. Find the nearest mountain to the north for each babingbaboom.\n\nAdditional definitions:\n\nMountain: a point whose surrounding area has no place higher than it (4-connected).\n\nIn the north: Let the babingbaboom's coordinate be $A(a,b)$ and the mountain's coordinate be $B(x,y)$. The mountain is to the north of the babingbaboom if and only if $dis_{A,B}=a-x$.\n\nChebyshev distance:\n\n$A(x_1,y_1) B(x_2,y_2):dis_{A,B}=\\max(|x_1 - x_2|, |y_1 - y_2|)$", "inputFormat": "Line $1$ contains three positive integers $N,M,K$.\n\nLines $2$ to $N+1$ each contain $M$ positive integers $h_{i,j}$.\n\nLines $N+2$ to $N+K+1$ each contain two positive integers $X_i,Y_i$, indicating the coordinate of each babingbaboom.", "outputFormat": "Output $K$ lines in total. If for a babingbaboom there exists such a nearest mountain (by Chebyshev distance), output the Chebyshev distance from this babingbaboom to that mountain. Otherwise, output \"Pool Babingbaboom!\".", "hint": "Constraints: $1 \\leqslant N,M \\leqslant 10^3$, $1 \\leqslant K \\leqslant 10^5$, $1 \\leqslant h_{i,j} \\leqslant 10^9$.\n\nThe testdata has gradients.\n\nSample image (stars represent babingbabooms, red represents mountains):\n![](https://cdn.luogu.com.cn/upload/pic/22827.png)\n\n(The vertical axis is $x$, and the horizontal axis is $y$. I did not pay attention when drawing it, sorry.)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "八百标兵奔北坡", "background": "baingbaboom 正在往北边跑！！！", "description": "现在在一张 $N*M$ 的地图上有 $K$ 只 babingbaboom ！！！对于一张地图上的点都有一个 $ h_{i,j} $ 来表示这个地方的高度。现在这些 babingbaboom 都想要跑到北边的一个山坡上。求出离每一个 babingbaboom 最近的靠北的山。\n\n补充定义：\n\n山：山的周围没有比它更高的地方（四连通）。\n\n在北边：令 Babingbaboom 的坐标为 $A(a,b)$，山的坐标为 $B(x,y)$，山在 Babingbaboom 的北边当且仅当 $dis_{A,B}=a-x$。\n\n切比雪夫距离：\n\n$A(x_1,y_1) B(x_2,y_2):dis_{A,B}=\\max(|x_1 - x_2|, |y_1 - y_2|)$", "inputFormat": "第 $1$ 行三个正整数 $N,M,K$。\n\n第 $3-N$ 行每行有 $M$ 个正整数 $h_{i,j}$。\n\n第 $K+3$ 行每行有两个正整数 $X_i,Y_i$，表示每一个 babingbaboom 的坐标。", "outputFormat": "共 $K$ 行。如果对于每一个 babingbaboom 存在这样的最近的山（切比雪夫距离），就输出这个 babingbaboom 到山的切比雪夫距离；否则输出“Pool Babingbaboom!”。", "hint": "保证 $ 1 \\leqslant  N,M \\leqslant 10^3$，$1 \\leqslant  K \\leqslant 10^5 $，$ 1 \\leqslant  h_{i,j} \\leqslant 10^9 $。\n\n数据有梯度！\n\n样例图片（星代表一个 Babingbaboom，红色代表一个山）：\n![](https://cdn.luogu.com.cn/upload/pic/22827.png)\n\n（竖的是 $x$，横的是 $y$。画的时候没注意，很抱歉。）", "locale": "zh-CN"}}}
{"pid": "P4772", "type": "P", "difficulty": 5, "samples": [["5 5 3\nA.**C\n*....\nB*...\n.**..\n.....", "16\nACB"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["广度优先搜索 BFS", "最短路", "状压 DP"], "title": "灰化肥，会挥发", "background": "Farmer Justin 有一大堆会发黑和挥发的灰化肥呢！！！", "description": "在 Farmer Justin 的农场中有许多灰化肥，它们都堆积在A仓库里。为了方便施肥，Farmer Justin 需要修一些公路使得他能用拖拉机把这些灰化肥拉到其他仓库里。由于 Farmer Justin 及其懒惰，所以他只想一次拉完所有的灰化肥送到其他仓库里。但是灰化肥见光易挥发，所以 Farmer Justin 需要尽快把这些灰化肥拉完。现在告诉你Farmer Justin农场的构成地图，请你帮帮他计划一条**从 A 仓库出发**走完所有仓库的方案吧！由于Farmer Justin 非常的讨厌浪费时间，所以你只需要告诉他最短的距离和走过所有农场的顺序。（注意：拖拉机走的时候是四联通的。）", "inputFormat": "第一行三个正整数 $R,C,N$ 分别表示地图大小和仓库数量。\n下面给出一个 $R$ 行 $C$ 列的地图，其中 `.` 表示空地，可以修建公路；`*` 表示是 Farmer Justin 的农业区，不可以修建公路；用大写字母表示仓库编号。", "outputFormat": "\n第一行一个正整数表示最短的距离。\n\n第二行表示拖拉机走过仓库的方案（由仓库编号组成的字符串）。若有多种方案，输出字典序最小的方案。\n\n数据保证有解。", "hint": "对于全部数据，$ 1 \\leqslant R,C \\leqslant 500 $，$ 1 \\leqslant N \\leqslant 16 $。", "locale": "zh-CN", "translations": {"en": {"title": "Ash Fertilizer Turns Black, and It Evaporates.", "background": "Farmer Justin has a huge pile of ash fertilizer that can turn black and evaporate!!!", "description": "On Farmer Justin's farm, there is a lot of ash fertilizer, and all of it is stored in warehouse A. To make fertilizing easier, Farmer Justin needs to build some roads so that he can use a tractor to transport the ash fertilizer to the other warehouses. Since Farmer Justin is very lazy, he only wants to move all the ash fertilizer at once and deliver it to the other warehouses. However, ash fertilizer evaporates easily when exposed to light, so Farmer Justin needs to finish transporting it as quickly as possible.\n\nNow you are given the map of Farmer Justin's farm. Please help him plan a route that **starts from warehouse A** and visits all warehouses. Since Farmer Justin really hates wasting time, you only need to tell him the shortest total distance and the order in which he visits all warehouses. (Note: the tractor moves in 4 directions, i.e., 4-connected.)", "inputFormat": "The first line contains three positive integers $R, C, N$, representing the map size and the number of warehouses.  \nThen an $R$ by $C$ map is given, where `.` means empty land where roads can be built, `*` means Farmer Justin's farmland area where roads cannot be built, and capital letters represent warehouse labels.", "outputFormat": "The first line contains one positive integer, the shortest distance.\n\nThe second line describes the tractor's visiting plan for the warehouses (a string consisting of warehouse labels). If there are multiple plans, output the lexicographically smallest one.\n\nIt is guaranteed that a solution exists.", "hint": "For all testdata, $1 \\leqslant R, C \\leqslant 500$, $1 \\leqslant N \\leqslant 16$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "灰化肥，会挥发", "background": "Farmer Justin 有一大堆会发黑和挥发的灰化肥呢！！！", "description": "在 Farmer Justin 的农场中有许多灰化肥，它们都堆积在A仓库里。为了方便施肥，Farmer Justin 需要修一些公路使得他能用拖拉机把这些灰化肥拉到其他仓库里。由于 Farmer Justin 及其懒惰，所以他只想一次拉完所有的灰化肥送到其他仓库里。但是灰化肥见光易挥发，所以 Farmer Justin 需要尽快把这些灰化肥拉完。现在告诉你Farmer Justin农场的构成地图，请你帮帮他计划一条**从 A 仓库出发**走完所有仓库的方案吧！由于Farmer Justin 非常的讨厌浪费时间，所以你只需要告诉他最短的距离和走过所有农场的顺序。（注意：拖拉机走的时候是四联通的。）", "inputFormat": "第一行三个正整数 $R,C,N$ 分别表示地图大小和仓库数量。\n下面给出一个 $R$ 行 $C$ 列的地图，其中 `.` 表示空地，可以修建公路；`*` 表示是 Farmer Justin 的农业区，不可以修建公路；用大写字母表示仓库编号。", "outputFormat": "\n第一行一个正整数表示最短的距离。\n\n第二行表示拖拉机走过仓库的方案（由仓库编号组成的字符串）。若有多种方案，输出字典序最小的方案。\n\n数据保证有解。", "hint": "对于全部数据，$ 1 \\leqslant R,C \\leqslant 500 $，$ 1 \\leqslant N \\leqslant 16 $。", "locale": "zh-CN"}}}
{"pid": "P4773", "type": "P", "difficulty": 5, "samples": [["1 1", "499122454"], ["1 2", "45"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["数学", "高精度", "最大公约数 gcd"], "title": "红鲤鱼与绿鲤鱼", "background": "JerryC 家里除了有驴之外，还有一个有着红鲤鱼和绿鲤鱼的鱼缸。", "description": "在 JerryC 家里的鱼缸里，有一些红鲤鱼和绿鲤鱼（鱼缸里没有驴！）。这天晚上 23:05 的时候，JerryC 闲的无聊，于是打开了某神秘 OJ 开始爆肝。\n\n作为一名膜$%$法师，JerryC 可以通过预言术得知下一次自己的提交是对是错。当然，预言术使用的工具就是眼前的鱼缸了。每当 JerryC 的预言术指示一只红鲤鱼的时候，就说明这次提交会 WA，同时会增加 5min 的罚时；如果是绿鲤鱼就会 AC。(当然，由于 JerryC 的膜$%$法，JerryC 是不会番薯田扛把子的。JerryC 第一次提交会在第 5min，而且不幸的是 JerryC 的膜$%$法有 5min 的冷却时间）并且 JerryC 在每一次预言后就会把预言到的那一只鲤鱼取出来，以便比赛完毕后给鱼缸换水（~~给自己换换口味~~）。\n\n现在 JerryC 告诉你他家里有多少条红鲤鱼和绿鲤鱼，请你告诉他他这场比赛的罚时期望是多少。当然，JerryC 会按顺序做题，并且罚时只会记录 AC 的题目，算罚时的时候需要加上 AC 的时间，并且所有的鲤鱼用完后还会提交一次，而且这一次 JerryC 并不会预测并且必定 AC。\n\n由于 JerryC 脾气比较犟，所以他不会因为 WA 掉一道题而换一道题去做，除非 AC。", "inputFormat": "一行，两个正整数 $A, B$，分别表示有多少条红鲤鱼和绿鲤鱼。", "outputFormat": "一行，一个正整数，表示罚时的期望模 $998244853$ 的结果。如果结果除不尽时，若结果可以表示为 $\\frac{P}{Q}$，则需要输出 $P \\times Q^{mod-2} \\bmod mod$  。", "hint": "### 样例解释 \\#1\n\n有两种可能： \n1. AC WA AC；\n2. WA AC AC。\n \n第一个情况的罚时是 $5$（第 5 分钟 AC）$\\!+ \\ 5$（WA 一次罚时 5 分钟）$\\!+ \\ 15$（第 15 分钟 AC）$= 25$。 \n\n第二个情况的罚时是 $5$（WA 一次罚时 5 分钟）$\\!+ \\ 10$（第 10 分钟 AC）$\\!+ \\ 15$（第 15 分钟 AC ）$=30$。 \n\n所以期望罚时为 $ \\frac{25+30}{2} = \\frac{55}{2} $ 需要对分数取模，所以最后答案为 $499122454$。\n\n### 数据规模与约定\n\n- 10 pts：$1 \\le A + B \\le 5$；\n- 30 pts：$1 \\le A + B \\le 20$；\n- 70 pts：$1 \\le A + B \\le 3000$；\n- 100 pts：$1 \\le A \\le 10 ^ {18}$，$1 \\le B \\le 10 ^ 7$。\n\n最后六个点时限 2400ms，其他点时限 400ms。\n\n$$\\color{white}{\\text{温馨提示:注意模数}}$$", "locale": "zh-CN", "translations": {"en": {"title": "Red Carp and Green Carp", "background": "In JerryC’s home, besides a donkey, there is also a fish tank with red carp and green carp.", "description": "In JerryC’s fish tank, there are some red carp and green carp (there is no donkey in the fish tank!). At 23:05 tonight, JerryC was bored, so he opened some mysterious OJ and started grinding hard.\n\nAs a “mo$%$” mage, JerryC can know in advance whether his next submission will be correct or wrong through divination. Of course, the tool for divination is the fish tank in front of him. Whenever JerryC’s divination points to a red carp, it means this submission will be WA, and 5 min of penalty time will be added; if it points to a green carp, it will be AC. (Of course, due to JerryC’s “mo$%$” magic, JerryC will not be “番薯田扛把子” (fan shu tian kang ba zi). JerryC’s first submission will be at the 5th min, and unfortunately, JerryC’s “mo$%$” magic has a 5 min cooldown.) Also, after each divination, JerryC will take the carp he divined out of the tank, so that after the contest he can change the water (~~change his taste~~).\n\nNow JerryC tells you how many red carp and green carp he has at home. Please tell him the expected total penalty time for this contest. JerryC will solve problems in order, and penalty time is recorded only for problems that are AC. When calculating penalty time, you need to add the time of AC, and after all carp are used up, he will submit once more. For this last submission, JerryC will not do any prediction and it will definitely be AC.\n\nBecause JerryC is quite stubborn, he will not switch to another problem after getting WA on a problem, unless he gets AC.", "inputFormat": "One line with two positive integers $A, B$, representing the number of red carp and green carp, respectively.", "outputFormat": "One line with one positive integer, representing the expected penalty time modulo $998244853$. If the result is not an integer, and it can be written as $\\frac{P}{Q}$, then output $P \\times Q^{mod-2} \\bmod mod$.", "hint": "### Sample Explanation \\#1\n\nThere are two possibilities:  \n1. AC WA AC;  \n2. WA AC AC.\n\nIn the first case, the penalty time is $5$ (AC at the 5th minute) $\\!+ \\ 5$ (one WA adds 5 minutes of penalty) $\\!+ \\ 15$ (AC at the 15th minute) $= 25$.\n\nIn the second case, the penalty time is $5$ (one WA adds 5 minutes of penalty) $\\!+ \\ 10$ (AC at the 10th minute) $\\!+ \\ 15$ (AC at the 15th minute) $= 30$.\n\nSo the expected penalty time is $ \\frac{25+30}{2} = \\frac{55}{2} $. We need to take the fraction modulo, so the final answer is $499122454$.\n\n### Constraints\n\n- 10 pts: $1 \\le A + B \\le 5$;\n- 30 pts: $1 \\le A + B \\le 20$;\n- 70 pts: $1 \\le A + B \\le 3000$;\n- 100 pts: $1 \\le A \\le 10 ^ {18}$, $1 \\le B \\le 10 ^ 7$.\n\nThe time limit for the last six subtasks is 2400 ms, and for the other subtasks it is 400 ms.\n\n$$\\color{white}{\\text{Warm reminder: pay attention to the modulus}}$$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "红鲤鱼与绿鲤鱼", "background": "JerryC 家里除了有驴之外，还有一个有着红鲤鱼和绿鲤鱼的鱼缸。", "description": "在 JerryC 家里的鱼缸里，有一些红鲤鱼和绿鲤鱼（鱼缸里没有驴！）。这天晚上 23:05 的时候，JerryC 闲的无聊，于是打开了某神秘 OJ 开始爆肝。\n\n作为一名膜$%$法师，JerryC 可以通过预言术得知下一次自己的提交是对是错。当然，预言术使用的工具就是眼前的鱼缸了。每当 JerryC 的预言术指示一只红鲤鱼的时候，就说明这次提交会 WA，同时会增加 5min 的罚时；如果是绿鲤鱼就会 AC。(当然，由于 JerryC 的膜$%$法，JerryC 是不会番薯田扛把子的。JerryC 第一次提交会在第 5min，而且不幸的是 JerryC 的膜$%$法有 5min 的冷却时间）并且 JerryC 在每一次预言后就会把预言到的那一只鲤鱼取出来，以便比赛完毕后给鱼缸换水（~~给自己换换口味~~）。\n\n现在 JerryC 告诉你他家里有多少条红鲤鱼和绿鲤鱼，请你告诉他他这场比赛的罚时期望是多少。当然，JerryC 会按顺序做题，并且罚时只会记录 AC 的题目，算罚时的时候需要加上 AC 的时间，并且所有的鲤鱼用完后还会提交一次，而且这一次 JerryC 并不会预测并且必定 AC。\n\n由于 JerryC 脾气比较犟，所以他不会因为 WA 掉一道题而换一道题去做，除非 AC。", "inputFormat": "一行，两个正整数 $A, B$，分别表示有多少条红鲤鱼和绿鲤鱼。", "outputFormat": "一行，一个正整数，表示罚时的期望模 $998244853$ 的结果。如果结果除不尽时，若结果可以表示为 $\\frac{P}{Q}$，则需要输出 $P \\times Q^{mod-2} \\bmod mod$  。", "hint": "### 样例解释 \\#1\n\n有两种可能： \n1. AC WA AC；\n2. WA AC AC。\n \n第一个情况的罚时是 $5$（第 5 分钟 AC）$\\!+ \\ 5$（WA 一次罚时 5 分钟）$\\!+ \\ 15$（第 15 分钟 AC）$= 25$。 \n\n第二个情况的罚时是 $5$（WA 一次罚时 5 分钟）$\\!+ \\ 10$（第 10 分钟 AC）$\\!+ \\ 15$（第 15 分钟 AC ）$=30$。 \n\n所以期望罚时为 $ \\frac{25+30}{2} = \\frac{55}{2} $ 需要对分数取模，所以最后答案为 $499122454$。\n\n### 数据规模与约定\n\n- 10 pts：$1 \\le A + B \\le 5$；\n- 30 pts：$1 \\le A + B \\le 20$；\n- 70 pts：$1 \\le A + B \\le 3000$；\n- 100 pts：$1 \\le A \\le 10 ^ {18}$，$1 \\le B \\le 10 ^ 7$。\n\n最后六个点时限 2400ms，其他点时限 400ms。\n\n$$\\color{white}{\\text{温馨提示:注意模数}}$$", "locale": "zh-CN"}}}
{"pid": "P4774", "type": "P", "difficulty": 6, "samples": [["2\n3 3\n3 5 7\n4 6 10\n7 3 9\n1 9 1000\n3 2\n3 5 6\n4 8 7\n1 1 1\n1 1", "59\n-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "NOI", "O2优化", "不定方程", "中国剩余定理 CRT", "逆元"], "title": "[NOI2018] 屠龙勇士", "background": "", "description": "小 D 最近在网上发现了一款小游戏。游戏的规则如下：\n\n- 游戏的目标是按照编号 $1 \\rightarrow n$ 顺序杀掉 $n$ 条巨龙，每条巨龙拥有一个初始的生命值 $a_i$ 。同时每条巨龙拥有恢复能力，当其使用恢复能力时，它的生命值就会每次增加 $p_i$ ，直至生命值非负。只有在攻击结束后且当生命值 **恰好** 为 $0$ 时它才会死去。\n- 游戏开始时玩家拥有 $m$ 把攻击力已知的剑，每次面对巨龙时，玩家只能选择一把剑，当杀死巨龙后这把剑就会消失，但作为奖励，玩家会获得全新的一把剑。\n\n小 D 觉得这款游戏十分无聊，但最快通关的玩家可以获得 ION2018 的参赛资格，于是小 D 决定写一个笨笨的机器人帮她通关这款游戏，她写的机器人遵循以下规则：\n\n- 每次面对巨龙时，机器人会选择当前拥有的，攻击力不高于巨龙初始生命值中攻击力最大的一把剑作为武器。如果没有这样的剑，则选择 **攻击力最低** 的一把剑作为武器。\n- 机器人面对每条巨龙，它都会使用上一步中选择的剑攻击巨龙固定的 $x$ 次，使巨龙的生命值减少 $x \\times ATK$ 。\n- 之后，巨龙会不断使用恢复能力，每次恢复 $p_i$ 生命值。若在使用恢复能力前或某一次恢复后其生命值为 $0$ ，则巨龙死亡，玩家通过本关。\n\n那么显然机器人的攻击次数是决定能否最快通关这款游戏的关键。小 D 现在得知了每条巨龙的所有属性，她想考考你，你知道应该将机器人的攻击次数 $x$ 设置为多少，才能用最少的攻击次数通关游戏吗？\n\n当然如果无论设置成多少都无法通关游戏，输出 $-1$ 即可。", "inputFormat": "第一行一个整数 $T$，代表数据组数。\n\n接下来 $T$ 组数据，每组数据包含 $5$ 行。\n\n- 每组数据的第一行包含两个整数，$n$ 和 $m$ ，代表巨龙的数量和初始剑的数量；\n- 接下来一行包含 $n$ 个正整数，第 $i$ 个数表示第 $i$ 条巨龙的初始生命值 $a_i$；\n- 接下来一行包含 $n$ 个正整数，第 $i$ 个数表示第 $i$ 条巨龙的恢复能力 $p_i$；\n- 接下来一行包含 $n$ 个正整数，第 $i$ 个数表示杀死第 $i$ 条巨龙后奖励的剑的攻击力；\n- 接下来一行包含 $m$ 个正整数，表示初始拥有的 $m$ 把剑的攻击力。", "outputFormat": "一共 $T$ 行。\n\n第 $i$ 行一个整数，表示对于第 $i$ 组数据，能够使得机器人通关游戏的最小攻击次数 $x$ ，如果答案不存在，输出 $-1$。", "hint": "### 更多样例\n\n更多样例请在附加文件中下载。\n\n### 样例 2\n\n见附加文件中的 `dragon2.in` 与 `dragon2.ans`。\n\n### 样例 1 解释\n\n第一组数据：\n- 开始时拥有的剑的攻击力为 $\\{1,9,1000\\}$，第 $1$ 条龙生命值为 $3$，故选择攻击力为 $1$ 的剑，攻击 $59$ 次，造成 $59$ 点伤害，此时龙的生命值为 $-56$，恢复 14 次后生命值恰好为 $0$，死亡。\n\n- 攻击力为 $1$ 的剑消失，拾取一把攻击力为 $7$ 的剑，此时拥有的剑的攻击力为\n$\\{7,9,1000\\}$，第 2 条龙生命值为 $5$，故选择攻击力为 $7$ 的剑，攻击 $59$ 次，造成 $413$ 点伤害，此时龙的生命值为 $-408$，恢复 $68$ 次后生命值恰好为 $0$，死亡。\n\n- 此时拥有的剑的攻击力为 $\\{3,9,1000\\}$，第 $3$ 条龙生命值为 $7$，故选择攻击力为 $3$ 的剑，攻击 $59$ 次，造成 $177$ 点伤害，此时龙的生命值为 $-170$，恢复 $17$ 次后生命值恰好为 0，死亡。\n\n- 没有比 $59$ 次更少的通关方法，故答案为 $59$。\n\n第二组数据：\n不存在既能杀死第一条龙又能杀死第二条龙的方法，故无法通关，输出 $-1$。\n\n### 子任务\n\n::cute-table{tuack}\n\n测试点编号 | $n$ | $m$ | $p_i$ | $a_i$ | 攻击力 | 其他限制\n:-:|:-:|:-:|:-:|:-:|:-:|:-:\n1|$\\le 10^5$|$=1$|$=1$|$\\le 10^5$|$=1$| 无\n2|^|^|^|^|^| ^\n3|^|^|^|^|$\\le 10^5$| ^\n4|^|^|^|^|^| ^\n5|$\\le 10^3$|$\\le 10^3$|$\\le 10^5$|^|^| 特性 1、特性 2\n6|^|^|^|^|^| ^\n7|^|^|^|^|^| ^\n8|$=1$|$=1$|$\\le 10^8$|$\\le 10^8$|$\\le 10^6$| 特性 1\n9|^|^|^|^|^| ^\n10|^|^|^|^|^| ^\n11|^|^|^|^|^| ^\n12|^|^|^|^|^| ^\n13|^|^|^|^|^| ^\n14|$=10^5$|$=10^5$|$=1$|^|^| 无特殊限制\n15|^|^|^|^|^| ^\n16|$\\le 10^5$|^| 所有 $p_i$ 是质数 |$\\le 10^{12}$|^| 特性 1\n17|^|^| ^ |^|^| ^\n18|^|^| 无特殊限制 | ^| ^ | ^\n19|^|^| ^ | ^| ^ | ^\n20|^|^| ^ | ^| ^ | ^\n\n特性 1 是指：对于任意的 $i$，$a_i \\le p_i$。\n\n特性 2 是指：$\\operatorname{lcm}(p_i) \\le 10^6$，即所有 $p_i$ 的 **最小公倍数** 不大于 $10^6$。\n\n对于所有的测试点，$T \\le 5$，所有武器的攻击力 $\\le 10^6$，所有 $p_i$ 的最小公倍数 $\\le 10^{12}$。\n\n保证 $ T, n, m $ 均为正整数。\n\n### 提示\n\n你所用到的中间结果可能很大，注意保存中间结果的变量类型。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2018] Dragon Slayer", "background": "", "description": "Xiao D recently found a mini game online. The rules are as follows:\n\n- The goal of the game is to kill $n$ dragons in order $1 \\rightarrow n$. Each dragon has an initial health value $a_i$. At the same time, each dragon has a recovery ability: when it uses recovery, its health increases by $p_i$ each time until its health becomes non-negative. The dragon will only die when the attack ends and its health is **exactly** $0$.\n- At the start of the game, the player has $m$ swords with known attack power. Each time facing a dragon, the player can only choose one sword. After killing the dragon, that sword disappears, but as a reward, the player obtains a brand-new sword.\n\nXiao D thinks this game is very boring, but the fastest player to clear it can get a qualification for ION2018, so Xiao D decides to write a simple robot to help her clear the game. Her robot follows these rules:\n\n- Each time it faces a dragon, the robot chooses, among the swords it currently has, the one with the maximum attack power that does not exceed the dragon’s initial health as its weapon. If there is no such sword, it chooses the sword with the **minimum attack power** as its weapon.\n- For each dragon, the robot uses the sword chosen in the previous step to attack the dragon a fixed $x$ times, reducing the dragon’s health by $x \\times ATK$.\n- Then, the dragon will keep using its recovery ability, recovering $p_i$ health each time. If before using recovery, or after some recovery, its health becomes $0$, then the dragon dies and the player clears this stage.\n\nSo obviously, the number of attacks is the key to whether the game can be cleared as fast as possible. Xiao D now knows all attributes of each dragon and wants to test you: what value should the robot’s attack count $x$ be set to, so that the game can be cleared with the minimum number of attacks?\n\nOf course, if the game cannot be cleared no matter what it is set to, output $-1$.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nThen there are $T$ test cases, each containing $5$ lines.\n\n- The first line of each test case contains two integers $n$ and $m$, representing the number of dragons and the number of initial swords;\n- The next line contains $n$ positive integers; the $i$-th number is the initial health $a_i$ of the $i$-th dragon;\n- The next line contains $n$ positive integers; the $i$-th number is the recovery value $p_i$ of the $i$-th dragon;\n- The next line contains $n$ positive integers; the $i$-th number is the attack power of the sword rewarded after killing the $i$-th dragon;\n- The next line contains $m$ positive integers, the attack powers of the $m$ initial swords.", "outputFormat": "Output $T$ lines in total.\n\nThe $i$-th line contains one integer, indicating for the $i$-th test case the minimum attack count $x$ that allows the robot to clear the game. If no such answer exists, output $-1$.", "hint": "### More Samples\n\nPlease download more samples in the attached file.\n\n### Sample 2\n\nSee `dragon2.in` and `dragon2.ans` in the attached file.\n\n### Explanation for Sample 1\n\nTest case 1:\n- The initial sword attack powers are $\\{1,9,1000\\}$. The health of dragon $1$ is $3$, so the sword with attack power $1$ is chosen. Attack $59$ times, dealing $59$ damage. The dragon’s health becomes $-56$. After recovering $14$ times, its health becomes exactly $0$, so it dies.\n\n- The sword with attack power $1$ disappears, and a sword with attack power $7$ is picked up. Now the sword attack powers are $\\{7,9,1000\\}$. The health of dragon $2$ is $5$, so the sword with attack power $7$ is chosen. Attack $59$ times, dealing $413$ damage. The dragon’s health becomes $-408$. After recovering $68$ times, its health becomes exactly $0$, so it dies.\n\n- Now the sword attack powers are $\\{3,9,1000\\}$. The health of dragon $3$ is $7$, so the sword with attack power $3$ is chosen. Attack $59$ times, dealing $177$ damage. The dragon’s health becomes $-170$. After recovering $17$ times, its health becomes exactly $0$, so it dies.\n\n- There is no way to clear the game with fewer than $59$ attacks, so the answer is $59$.\n\nTest case 2:\nThere is no method that can kill both the first dragon and the second dragon, so the game cannot be cleared. Output $-1$.\n\n### Subtasks\n\n::cute-table{tuack}\n\nTest Point ID | $n$ | $m$ | $p_i$ | $a_i$ | Attack Power | Other Restrictions\n:-:|:-:|:-:|:-:|:-:|:-:|:-:\n1|$\\le 10^5$|$=1$|$=1$|$\\le 10^5$|$=1$| None\n2|^|^|^|^|^| ^\n3|^|^|^|^|$\\le 10^5$| ^\n4|^|^|^|^|^| ^\n5|$\\le 10^3$|$\\le 10^3$|$\\le 10^5$|^|^| Property 1, Property 2\n6|^|^|^|^|^| ^\n7|^|^|^|^|^| ^\n8|$=1$|$=1$|$\\le 10^8$|$\\le 10^8$|$\\le 10^6$| Property 1\n9|^|^|^|^|^| ^\n10|^|^|^|^|^| ^\n11|^|^|^|^|^| ^\n12|^|^|^|^|^| ^\n13|^|^|^|^|^| ^\n14|$=10^5$|$=10^5$|$=1$|^|^| No special restrictions\n15|^|^|^|^|^| ^\n16|$\\le 10^5$|^| All $p_i$ are primes |$\\le 10^{12}$|^| Property 1\n17|^|^| ^ |^|^| ^\n18|^|^| No special restrictions | ^| ^ | ^\n19|^|^| ^ | ^| ^ | ^\n20|^|^| ^ | ^| ^ | ^\n\nProperty 1 means: for any $i$, $a_i \\le p_i$.\n\nProperty 2 means: $\\operatorname{lcm}(p_i) \\le 10^6$, i.e. the **least common multiple** of all $p_i$ is at most $10^6$.\n\nFor all test points, $T \\le 5$, all weapon attack powers $\\le 10^6$, and the least common multiple of all $p_i$ is $\\le 10^{12}$.\n\nIt is guaranteed that $T$, $n$, and $m$ are all positive integers.\n\n### Notes\n\nThe intermediate results you use may be very large, so pay attention to the variable types used to store them.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2018] 屠龙勇士", "background": "", "description": "小 D 最近在网上发现了一款小游戏。游戏的规则如下：\n\n- 游戏的目标是按照编号 $1 \\rightarrow n$ 顺序杀掉 $n$ 条巨龙，每条巨龙拥有一个初始的生命值 $a_i$ 。同时每条巨龙拥有恢复能力，当其使用恢复能力时，它的生命值就会每次增加 $p_i$ ，直至生命值非负。只有在攻击结束后且当生命值 **恰好** 为 $0$ 时它才会死去。\n- 游戏开始时玩家拥有 $m$ 把攻击力已知的剑，每次面对巨龙时，玩家只能选择一把剑，当杀死巨龙后这把剑就会消失，但作为奖励，玩家会获得全新的一把剑。\n\n小 D 觉得这款游戏十分无聊，但最快通关的玩家可以获得 ION2018 的参赛资格，于是小 D 决定写一个笨笨的机器人帮她通关这款游戏，她写的机器人遵循以下规则：\n\n- 每次面对巨龙时，机器人会选择当前拥有的，攻击力不高于巨龙初始生命值中攻击力最大的一把剑作为武器。如果没有这样的剑，则选择 **攻击力最低** 的一把剑作为武器。\n- 机器人面对每条巨龙，它都会使用上一步中选择的剑攻击巨龙固定的 $x$ 次，使巨龙的生命值减少 $x \\times ATK$ 。\n- 之后，巨龙会不断使用恢复能力，每次恢复 $p_i$ 生命值。若在使用恢复能力前或某一次恢复后其生命值为 $0$ ，则巨龙死亡，玩家通过本关。\n\n那么显然机器人的攻击次数是决定能否最快通关这款游戏的关键。小 D 现在得知了每条巨龙的所有属性，她想考考你，你知道应该将机器人的攻击次数 $x$ 设置为多少，才能用最少的攻击次数通关游戏吗？\n\n当然如果无论设置成多少都无法通关游戏，输出 $-1$ 即可。", "inputFormat": "第一行一个整数 $T$，代表数据组数。\n\n接下来 $T$ 组数据，每组数据包含 $5$ 行。\n\n- 每组数据的第一行包含两个整数，$n$ 和 $m$ ，代表巨龙的数量和初始剑的数量；\n- 接下来一行包含 $n$ 个正整数，第 $i$ 个数表示第 $i$ 条巨龙的初始生命值 $a_i$；\n- 接下来一行包含 $n$ 个正整数，第 $i$ 个数表示第 $i$ 条巨龙的恢复能力 $p_i$；\n- 接下来一行包含 $n$ 个正整数，第 $i$ 个数表示杀死第 $i$ 条巨龙后奖励的剑的攻击力；\n- 接下来一行包含 $m$ 个正整数，表示初始拥有的 $m$ 把剑的攻击力。", "outputFormat": "一共 $T$ 行。\n\n第 $i$ 行一个整数，表示对于第 $i$ 组数据，能够使得机器人通关游戏的最小攻击次数 $x$ ，如果答案不存在，输出 $-1$。", "hint": "### 更多样例\n\n更多样例请在附加文件中下载。\n\n### 样例 2\n\n见附加文件中的 `dragon2.in` 与 `dragon2.ans`。\n\n### 样例 1 解释\n\n第一组数据：\n- 开始时拥有的剑的攻击力为 $\\{1,9,1000\\}$，第 $1$ 条龙生命值为 $3$，故选择攻击力为 $1$ 的剑，攻击 $59$ 次，造成 $59$ 点伤害，此时龙的生命值为 $-56$，恢复 14 次后生命值恰好为 $0$，死亡。\n\n- 攻击力为 $1$ 的剑消失，拾取一把攻击力为 $7$ 的剑，此时拥有的剑的攻击力为\n$\\{7,9,1000\\}$，第 2 条龙生命值为 $5$，故选择攻击力为 $7$ 的剑，攻击 $59$ 次，造成 $413$ 点伤害，此时龙的生命值为 $-408$，恢复 $68$ 次后生命值恰好为 $0$，死亡。\n\n- 此时拥有的剑的攻击力为 $\\{3,9,1000\\}$，第 $3$ 条龙生命值为 $7$，故选择攻击力为 $3$ 的剑，攻击 $59$ 次，造成 $177$ 点伤害，此时龙的生命值为 $-170$，恢复 $17$ 次后生命值恰好为 0，死亡。\n\n- 没有比 $59$ 次更少的通关方法，故答案为 $59$。\n\n第二组数据：\n不存在既能杀死第一条龙又能杀死第二条龙的方法，故无法通关，输出 $-1$。\n\n### 子任务\n\n::cute-table{tuack}\n\n测试点编号 | $n$ | $m$ | $p_i$ | $a_i$ | 攻击力 | 其他限制\n:-:|:-:|:-:|:-:|:-:|:-:|:-:\n1|$\\le 10^5$|$=1$|$=1$|$\\le 10^5$|$=1$| 无\n2|^|^|^|^|^| ^\n3|^|^|^|^|$\\le 10^5$| ^\n4|^|^|^|^|^| ^\n5|$\\le 10^3$|$\\le 10^3$|$\\le 10^5$|^|^| 特性 1、特性 2\n6|^|^|^|^|^| ^\n7|^|^|^|^|^| ^\n8|$=1$|$=1$|$\\le 10^8$|$\\le 10^8$|$\\le 10^6$| 特性 1\n9|^|^|^|^|^| ^\n10|^|^|^|^|^| ^\n11|^|^|^|^|^| ^\n12|^|^|^|^|^| ^\n13|^|^|^|^|^| ^\n14|$=10^5$|$=10^5$|$=1$|^|^| 无特殊限制\n15|^|^|^|^|^| ^\n16|$\\le 10^5$|^| 所有 $p_i$ 是质数 |$\\le 10^{12}$|^| 特性 1\n17|^|^| ^ |^|^| ^\n18|^|^| 无特殊限制 | ^| ^ | ^\n19|^|^| ^ | ^| ^ | ^\n20|^|^| ^ | ^| ^ | ^\n\n特性 1 是指：对于任意的 $i$，$a_i \\le p_i$。\n\n特性 2 是指：$\\operatorname{lcm}(p_i) \\le 10^6$，即所有 $p_i$ 的 **最小公倍数** 不大于 $10^6$。\n\n对于所有的测试点，$T \\le 5$，所有武器的攻击力 $\\le 10^6$，所有 $p_i$ 的最小公倍数 $\\le 10^{12}$。\n\n保证 $ T, n, m $ 均为正整数。\n\n### 提示\n\n你所用到的中间结果可能很大，注意保存中间结果的变量类型。", "locale": "zh-CN"}}}
{"pid": "P4775", "type": "P", "difficulty": 7, "samples": [["2\n5\n1 2 1\n2 3 3\n3 4 2\n1 5 8\n2\n1 4 5\n3 5 8\n5\n1 2 1\n2 3 3\n3 4 3\n1 5 9\n2\n1 5 5\n2 3 8", "1\nF"], ["1\n11\n1 2 2\n1 3 0\n2 4 1\n3 5 7\n1 6 0\n1 7 1\n1 8 1\n6 9 3\n4 10 2\n4 11 8\n10\n7 10 2\n10 7 0\n2 11 1\n8 6 7\n7 7 0\n10 1 1\n8 2 1\n7 8 3\n7 7 3\n3 9 9\n", "13\n"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "线段树", "NOI", "O2优化", "最近公共祖先 LCA"], "title": "[NOI2018] 情报中心", "background": "", "description": "C 国和 D 国近年来战火纷飞。\n\n最近，C 国成功地渗透进入了 D 国的一个城市。这个城市可以抽象成一张有 $n$ 个节点，节点之间由 $n − 1$ 条双向的边连接的无向图，使得任意两个点之间可以互相到达。也就是说，这张无向图实际上是一棵树。\n\n经过侦查，C 国情报部部长 GGB 惊讶地发现，这座看起来不起眼的城市竟然是 D 国的军事中心。因此 GGB 决定在这个城市内设立情报机构。情报专家 TAC 在侦查后，安排了 $m$ 种设立情报机构的方案。这些方案中，第 $i$ 种方案是在节点 $x_i$ 到节点 $y_i$ 的最短路径的所有边上安排情报人员收集情报，这种方案需要花费 $v_i$ 元的代价。\n\n但是，由于人手不足，GGB 只能安排上述 $m$ 种方案中的两种进行实施。同时 TAC 指出，为了让这两个情报机构可以更好的合作，它们收集情报的范围应**至少有一条公共的边**。为了评估一种方案的性能，GGB 和 TAC 对所有的边进行了勘察，给每一条边制定了一个情报价值 $c_i$，表示收集这条边上的情报能够带来 $c_i$ 元的收益。注意，情报是唯一的，因此当一条边的情报被两个情报机构收集时，也同样只会有 $c_i$ 的收益。\n\n现在，请你帮 GGB 选出两种合法的设立情报机构的方案进行实施，使得这两种方案收集情报的范围至少有一条公共的边，并且在此基础上**总收益减去总代价的差**最大。\n\n注意，这个值可能是负的，但仍然是合法的。如果无法找到这样的两种方案，请输出 `F`。\n", "inputFormat": "从文件 `center.in` 中读入数据。\n\n本题包含多组测试数据。\n\n输入文件的第一行包含一个整数 $T$，表示数据组数；\n\n每组数据包含 $(n + m + 1)$ 行：\n\n第 $1$ 行包含一个整数 $n$，表示城市的点数；\n\n第 $2$ 到第 $n$ 行中，第 $(i + 1)$ 行包含三个整数 $a_i$，$b_i$，$c_i$，表示城市中一条连接节点 $a_i$ 和 $b_i$、情报价值为 $c_i$ 的双向边，保证 $a_i < b_i$ 且 $b_i$ 互不相同；\n\n第 $(n + 1)$ 行包含一个整数 $m$，表示 TAC 设立的 $m$ 种设立情报机构的方案；\n\n第 $(n + 2)$ 到 $(n + m + 1)$ 行中，第 $(n + i + 1)$ 行包含三个整数 $x_i$，$y_i$，$v_i$，表示第 $i$ 种设立情报机构的方案是在节点 $x_i$ 到节点 $y_i$ 的最短路径上的所有边上安排情报人员收集情报，并且需要花费 $v_i$ 元的代价。", "outputFormat": "输出到文件 `center.out` 中。\n\n输出文件包含 $T$ 行；\n\n对于每组数据，输出一行：如果存在合法的方案，则输出一个整数表示最大的总收益减去总代价的差；否则输出 `F`。\n", "hint": "### 样例 1 解释\n\n这个样例中包含两组数据。这两组数据的城市相同，只是在情报的价值和情报机构的方案上有所不同。城市地图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mfs5k9ob.png)\n\n* 对于第一组数据，方案一中的节点 $1$ 到节点 $4$ 的最短路径为 $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4$，方案二中的节点 $3$ 到节点 $5$ 的最短路径为 $3 \\rightarrow 2 \\rightarrow 1 \\rightarrow 5$。选择这两种方案需要花费 $5 + 8 = 13$ 的代价，并且每一条边的情报都被收集从而得到 $1 + 3 + 2 + 8 = 14$ 的收益，因此总收益减去总代价为 $14 − 13 = 1$。\n* 对于第二组数据，方案一中的节点 $1$ 到节点 $5$ 的最短路径为 $1 \\rightarrow 5$，方案二中的节点 $2$ 到节点 $3$ 的最短路径为 $2 \\rightarrow 3$。这两种方案收集情报的范围没有公共的边，因此非法，所以这组数据不存在合法方案，应输出 `F`。\n\n### 样例 2 解释\n\n见附加文件中的 `center2.in` 与 `center2.ans`。\n\n这个样例只包含一组数据。这一数据中，最优方案为选择第 $2$ 种和第 $3$ 种方案。\n\n这组数据的城市地图如下，其中**加粗**的边表示被情报中心收集情报的边，红色的边表示只被第 $2$ 种方案的情报中心收集情报的边，蓝色的边表示只被第 $3$ 种方案的情报中心收集情报的边，紫色的边表示同时被两个情报中心收集情报的边。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s9blcjri.png)\n\n### 样例 3\n\n见附加文件中的 `center3.in` 与 `center3.ans`。\n\n这个样例和第 $4$ 个测试点的性质相同。每个测试点的性质见下文的表格。\n\n### 样例 4\n\n见附加文件中的 `center4.in` 与 `center4.ans`。\n\n这个样例，无疑是善良的出题人无私的馈赠。大量精心构造的 $n\\le 100,m\\le 200$ 的测试数据，涵盖了测试点中所有出现性质的组合。你可以利用这个测试点，对自己的程序进行全面的检查。足量的数据组数、不大的数据范围和多种多样的数据类型，能让程序中的错误无处遁形。出题人相信，这个美妙的样例，可以给拼搏于 AC 这道题的逐梦之路上的你，提供一个有力的援助。\n\n### 数据范围\n\n各测试点的数据规模和性质如下表：\n\n::cute-table{tuack}\n\n| 测试点 | $n \\le$ | $m \\le$ | $T \\le 50$ | 特殊性质 |\n| :-: | :-: | :-: | :-: | :-: |\n| 1 | $2$ | $3$ | 保证 | 无 |\n| 2 | $10$ | $30$ | ^ | ^ |\n| 3 | $200$ | $300$ | ^ | ^ |\n| 4 | $10^3$ | $2,000$ | ^ | $a_i = b_i - 1$ |\n| 5 | $10^4$ | $3 \\times 10^4$ | ^ | ^ |\n| 6 | $5 \\times 10^4$ | $10^5$ | ^ | ^ |\n| 7 | $10^4$ | $3 \\times 10^4$ | ^ | $c_i=0$ |\n| 8 | $5 \\times 10^4$ | $10^5$ | ^ | ^ |\n| 9 | ^ | ^ | ^ | ^ |\n| 10 | $10^4$ | $n$ | ^ | $S_1$ |\n| 11 | $5 \\times 10^4$ | ^ | 不保证 | ^ |\n| 12 | ^ | ^ | ^ | ^ |\n| 13 | $10^4$ | $3 \\times 10^4$ | 保证 | $S_2$ |\n| 14 | ^ | ^ | ^ | ^ |\n| 15 | $5 \\times 10^4$ | $10^5$ | 不保证 | ^ |\n| 16 | ^ | ^ | ^ | ^ |\n| 17 | $10^4$ | $3 \\times 10^4$ | 保证 | 无 |\n| 18 | $5 \\times 10^4$ | $ 10^5$ | ^ | ^ |\n| 19 | ^ | ^ | 不保证 | ^ |\n| 20 | ^ | ^ | ^ | ^ |\n\n表格中的特殊性质如下：\n* 特殊性质 $S_1$：对于任意 $i, j$，保证 $x_i$ 到 $y_i$ 的最短路径所经过的编号最小的节点不同于 $x_j$ 到 $y_j$ 的最短路径所经过的编号最小的节点；\n\n* 特殊性质 $S_2$：对于任意 $i$，保证 $x_i$ 到 $y_i$ 的最短路径所经过的编号最小的节点为节点 $1$。\n\n对于所有的数据，$1 \\le n \\le 5 \\times 10^4$，$0 \\le m \\le 10^5$，$0 \\le c_i \\le 10^9$，$0 \\le v_i \\le 10^{10} \\times n$。每个测试点中，所有 $n$ 的和不会超过 $1\\,000\\,233$，所有 $m$ 的和不会超过 $2\\,000\\,233$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2018] Intelligence Center", "background": "", "description": "In recent years, Country C and Country D have been at war.\n\nRecently, Country C successfully infiltrated a city in Country D. This city can be modeled as an undirected graph with $n$ nodes, connected by $n - 1$ bidirectional edges, such that any two nodes are reachable from each other. In other words, this undirected graph is actually a tree.\n\nAfter investigation, the minister of intelligence of Country C, GGB, was surprised to find that this seemingly ordinary city is actually the military center of Country D. Therefore, GGB decided to set up intelligence agencies in this city. After reconnaissance, the intelligence expert TAC prepared $m$ possible plans to set up intelligence agencies. In the $i$-th plan, intelligence personnel are deployed on all edges along the shortest path from node $x_i$ to node $y_i$ to collect intelligence, and this plan costs $v_i$ yuan.\n\nHowever, due to lack of manpower, GGB can only implement two of the above $m$ plans. Meanwhile, TAC pointed out that, for these two intelligence agencies to cooperate better, the ranges of intelligence they collect must share **at least one common edge**. To evaluate a plan, GGB and TAC surveyed all edges and assigned each edge an intelligence value $c_i$, meaning that collecting intelligence on this edge brings a profit of $c_i$ yuan. Note that intelligence is unique, so even if an edge’s intelligence is collected by both agencies, the profit is still only $c_i$.\n\nNow, please help GGB choose two legal plans to implement, such that the ranges of intelligence collected by these two plans share at least one common edge, and on this basis, the **difference between total profit and total cost** is maximized.\n\nNote that this value may be negative, but it is still valid. If no such two plans can be found, output `F`.", "inputFormat": "Read input from file `center.in`.\n\nThis problem contains multiple test cases.\n\nThe first line of the input file contains an integer $T$, indicating the number of test cases.\n\nEach test case contains $(n + m + 1)$ lines:\n\nLine $1$ contains an integer $n$, the number of nodes in the city.\n\nLines $2$ to $n$ (i.e., line $(i + 1)$) each contain three integers $a_i$, $b_i$, $c_i$, describing a bidirectional edge connecting nodes $a_i$ and $b_i$ with intelligence value $c_i$. It is guaranteed that $a_i < b_i$ and all $b_i$ are distinct.\n\nLine $(n + 1)$ contains an integer $m$, the number of plans proposed by TAC.\n\nLines $(n + 2)$ to $(n + m + 1)$ (i.e., line $(n + i + 1)$) each contain three integers $x_i$, $y_i$, $v_i$, meaning that the $i$-th plan deploys intelligence personnel on all edges along the shortest path from node $x_i$ to node $y_i$, and costs $v_i$ yuan.", "outputFormat": "Write output to file `center.out`.\n\nThe output file contains $T$ lines.\n\nFor each test case, output one line: if there exists a legal choice, output an integer representing the maximum value of (total profit minus total cost); otherwise output `F`.", "hint": "### Sample 1 Explanation\n\nThis sample contains two test cases. The cities (trees) are the same in both cases; only the intelligence values and the plans differ. The city map is as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mfs5k9ob.png)\n\n* For the first test case, the shortest path from node $1$ to node $4$ in plan 1 is $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4$, and the shortest path from node $3$ to node $5$ in plan 2 is $3 \\rightarrow 2 \\rightarrow 1 \\rightarrow 5$. Choosing these two plans costs $5 + 8 = 13$, and intelligence on every edge is collected, yielding a profit of $1 + 3 + 2 + 8 = 14$, so (total profit minus total cost) is $14 − 13 = 1$.\n* For the second test case, the shortest path from node $1$ to node $5$ in plan 1 is $1 \\rightarrow 5$, and the shortest path from node $2$ to node $3$ in plan 2 is $2 \\rightarrow 3$. The ranges of intelligence collected by these two plans have no common edge, so this is illegal. Therefore, there is no legal choice for this test case, and you should output `F`.\n\n### Sample 2 Explanation\n\nSee the attached files `center2.in` and `center2.ans`.\n\nThis sample contains only one test case. In this test case, the optimal choice is to select plan $2$ and plan $3$.\n\nThe city map for this test case is as follows. The **bold** edges are those whose intelligence is collected by the intelligence centers; red edges are collected only by the intelligence center in plan $2$; blue edges are collected only by the intelligence center in plan $3$; and purple edges are collected by both intelligence centers.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s9blcjri.png)\n\n### Sample 3\n\nSee the attached files `center3.in` and `center3.ans`.\n\nThis sample has the same properties as test point $4$. The properties of each test point are shown in the table below.\n\n### Sample 4\n\nSee the attached files `center4.in` and `center4.ans`.\n\nThis sample is undoubtedly a generous gift from the kind problem setter. It contains a large number of carefully constructed test cases with $n\\le 100,m\\le 200$, covering all combinations of properties that appear among the test points. You can use this test point to thoroughly check your program. With enough test cases, small constraints, and diverse data types, bugs in your program will have nowhere to hide. The problem setter believes that this wonderful sample can provide strong support on your journey toward AC on this problem.\n\n### Constraints\n\nThe sizes and properties of the test points are shown in the table below:\n\n::cute-table{tuack}\n\n| Test Point | $n \\le$ | $m \\le$ | $T \\le 50$ | Special Property |\n| :-: | :-: | :-: | :-: | :-: |\n| 1 | $2$ | $3$ | Guaranteed | None |\n| 2 | $10$ | $30$ | ^ | ^ |\n| 3 | $200$ | $300$ | ^ | ^ |\n| 4 | $10^3$ | $2,000$ | ^ | $a_i = b_i - 1$ |\n| 5 | $10^4$ | $3 \\times 10^4$ | ^ | ^ |\n| 6 | $5 \\times 10^4$ | $10^5$ | ^ | ^ |\n| 7 | $10^4$ | $3 \\times 10^4$ | ^ | $c_i=0$ |\n| 8 | $5 \\times 10^4$ | $10^5$ | ^ | ^ |\n| 9 | ^ | ^ | ^ | ^ |\n| 10 | $10^4$ | $n$ | ^ | $S_1$ |\n| 11 | $5 \\times 10^4$ | ^ | Not guaranteed | ^ |\n| 12 | ^ | ^ | ^ | ^ |\n| 13 | $10^4$ | $3 \\times 10^4$ | Guaranteed | $S_2$ |\n| 14 | ^ | ^ | ^ | ^ |\n| 15 | $5 \\times 10^4$ | $10^5$ | Not guaranteed | ^ |\n| 16 | ^ | ^ | ^ | ^ |\n| 17 | $10^4$ | $3 \\times 10^4$ | Guaranteed | None |\n| 18 | $5 \\times 10^4$ | $ 10^5$ | ^ | ^ |\n| 19 | ^ | ^ | Not guaranteed | ^ |\n| 20 | ^ | ^ | ^ | ^ |\n\nThe special properties in the table are:\n\n* Special property $S_1$: For any $i, j$, it is guaranteed that the smallest-indexed node on the shortest path from $x_i$ to $y_i$ is different from the smallest-indexed node on the shortest path from $x_j$ to $y_j$.\n\n* Special property $S_2$: For any $i$, it is guaranteed that the smallest-indexed node on the shortest path from $x_i$ to $y_i$ is node $1$.\n\nFor all testdata, $1 \\le n \\le 5 \\times 10^4$, $0 \\le m \\le 10^5$, $0 \\le c_i \\le 10^9$, $0 \\le v_i \\le 10^{10} \\times n$. In each test point, the sum of all $n$ does not exceed $1\\,000\\,233$, and the sum of all $m$ does not exceed $2\\,000\\,233$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2018] 情报中心", "background": "", "description": "C 国和 D 国近年来战火纷飞。\n\n最近，C 国成功地渗透进入了 D 国的一个城市。这个城市可以抽象成一张有 $n$ 个节点，节点之间由 $n − 1$ 条双向的边连接的无向图，使得任意两个点之间可以互相到达。也就是说，这张无向图实际上是一棵树。\n\n经过侦查，C 国情报部部长 GGB 惊讶地发现，这座看起来不起眼的城市竟然是 D 国的军事中心。因此 GGB 决定在这个城市内设立情报机构。情报专家 TAC 在侦查后，安排了 $m$ 种设立情报机构的方案。这些方案中，第 $i$ 种方案是在节点 $x_i$ 到节点 $y_i$ 的最短路径的所有边上安排情报人员收集情报，这种方案需要花费 $v_i$ 元的代价。\n\n但是，由于人手不足，GGB 只能安排上述 $m$ 种方案中的两种进行实施。同时 TAC 指出，为了让这两个情报机构可以更好的合作，它们收集情报的范围应**至少有一条公共的边**。为了评估一种方案的性能，GGB 和 TAC 对所有的边进行了勘察，给每一条边制定了一个情报价值 $c_i$，表示收集这条边上的情报能够带来 $c_i$ 元的收益。注意，情报是唯一的，因此当一条边的情报被两个情报机构收集时，也同样只会有 $c_i$ 的收益。\n\n现在，请你帮 GGB 选出两种合法的设立情报机构的方案进行实施，使得这两种方案收集情报的范围至少有一条公共的边，并且在此基础上**总收益减去总代价的差**最大。\n\n注意，这个值可能是负的，但仍然是合法的。如果无法找到这样的两种方案，请输出 `F`。\n", "inputFormat": "从文件 `center.in` 中读入数据。\n\n本题包含多组测试数据。\n\n输入文件的第一行包含一个整数 $T$，表示数据组数；\n\n每组数据包含 $(n + m + 1)$ 行：\n\n第 $1$ 行包含一个整数 $n$，表示城市的点数；\n\n第 $2$ 到第 $n$ 行中，第 $(i + 1)$ 行包含三个整数 $a_i$，$b_i$，$c_i$，表示城市中一条连接节点 $a_i$ 和 $b_i$、情报价值为 $c_i$ 的双向边，保证 $a_i < b_i$ 且 $b_i$ 互不相同；\n\n第 $(n + 1)$ 行包含一个整数 $m$，表示 TAC 设立的 $m$ 种设立情报机构的方案；\n\n第 $(n + 2)$ 到 $(n + m + 1)$ 行中，第 $(n + i + 1)$ 行包含三个整数 $x_i$，$y_i$，$v_i$，表示第 $i$ 种设立情报机构的方案是在节点 $x_i$ 到节点 $y_i$ 的最短路径上的所有边上安排情报人员收集情报，并且需要花费 $v_i$ 元的代价。", "outputFormat": "输出到文件 `center.out` 中。\n\n输出文件包含 $T$ 行；\n\n对于每组数据，输出一行：如果存在合法的方案，则输出一个整数表示最大的总收益减去总代价的差；否则输出 `F`。\n", "hint": "### 样例 1 解释\n\n这个样例中包含两组数据。这两组数据的城市相同，只是在情报的价值和情报机构的方案上有所不同。城市地图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mfs5k9ob.png)\n\n* 对于第一组数据，方案一中的节点 $1$ 到节点 $4$ 的最短路径为 $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4$，方案二中的节点 $3$ 到节点 $5$ 的最短路径为 $3 \\rightarrow 2 \\rightarrow 1 \\rightarrow 5$。选择这两种方案需要花费 $5 + 8 = 13$ 的代价，并且每一条边的情报都被收集从而得到 $1 + 3 + 2 + 8 = 14$ 的收益，因此总收益减去总代价为 $14 − 13 = 1$。\n* 对于第二组数据，方案一中的节点 $1$ 到节点 $5$ 的最短路径为 $1 \\rightarrow 5$，方案二中的节点 $2$ 到节点 $3$ 的最短路径为 $2 \\rightarrow 3$。这两种方案收集情报的范围没有公共的边，因此非法，所以这组数据不存在合法方案，应输出 `F`。\n\n### 样例 2 解释\n\n见附加文件中的 `center2.in` 与 `center2.ans`。\n\n这个样例只包含一组数据。这一数据中，最优方案为选择第 $2$ 种和第 $3$ 种方案。\n\n这组数据的城市地图如下，其中**加粗**的边表示被情报中心收集情报的边，红色的边表示只被第 $2$ 种方案的情报中心收集情报的边，蓝色的边表示只被第 $3$ 种方案的情报中心收集情报的边，紫色的边表示同时被两个情报中心收集情报的边。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s9blcjri.png)\n\n### 样例 3\n\n见附加文件中的 `center3.in` 与 `center3.ans`。\n\n这个样例和第 $4$ 个测试点的性质相同。每个测试点的性质见下文的表格。\n\n### 样例 4\n\n见附加文件中的 `center4.in` 与 `center4.ans`。\n\n这个样例，无疑是善良的出题人无私的馈赠。大量精心构造的 $n\\le 100,m\\le 200$ 的测试数据，涵盖了测试点中所有出现性质的组合。你可以利用这个测试点，对自己的程序进行全面的检查。足量的数据组数、不大的数据范围和多种多样的数据类型，能让程序中的错误无处遁形。出题人相信，这个美妙的样例，可以给拼搏于 AC 这道题的逐梦之路上的你，提供一个有力的援助。\n\n### 数据范围\n\n各测试点的数据规模和性质如下表：\n\n::cute-table{tuack}\n\n| 测试点 | $n \\le$ | $m \\le$ | $T \\le 50$ | 特殊性质 |\n| :-: | :-: | :-: | :-: | :-: |\n| 1 | $2$ | $3$ | 保证 | 无 |\n| 2 | $10$ | $30$ | ^ | ^ |\n| 3 | $200$ | $300$ | ^ | ^ |\n| 4 | $10^3$ | $2,000$ | ^ | $a_i = b_i - 1$ |\n| 5 | $10^4$ | $3 \\times 10^4$ | ^ | ^ |\n| 6 | $5 \\times 10^4$ | $10^5$ | ^ | ^ |\n| 7 | $10^4$ | $3 \\times 10^4$ | ^ | $c_i=0$ |\n| 8 | $5 \\times 10^4$ | $10^5$ | ^ | ^ |\n| 9 | ^ | ^ | ^ | ^ |\n| 10 | $10^4$ | $n$ | ^ | $S_1$ |\n| 11 | $5 \\times 10^4$ | ^ | 不保证 | ^ |\n| 12 | ^ | ^ | ^ | ^ |\n| 13 | $10^4$ | $3 \\times 10^4$ | 保证 | $S_2$ |\n| 14 | ^ | ^ | ^ | ^ |\n| 15 | $5 \\times 10^4$ | $10^5$ | 不保证 | ^ |\n| 16 | ^ | ^ | ^ | ^ |\n| 17 | $10^4$ | $3 \\times 10^4$ | 保证 | 无 |\n| 18 | $5 \\times 10^4$ | $ 10^5$ | ^ | ^ |\n| 19 | ^ | ^ | 不保证 | ^ |\n| 20 | ^ | ^ | ^ | ^ |\n\n表格中的特殊性质如下：\n* 特殊性质 $S_1$：对于任意 $i, j$，保证 $x_i$ 到 $y_i$ 的最短路径所经过的编号最小的节点不同于 $x_j$ 到 $y_j$ 的最短路径所经过的编号最小的节点；\n\n* 特殊性质 $S_2$：对于任意 $i$，保证 $x_i$ 到 $y_i$ 的最短路径所经过的编号最小的节点为节点 $1$。\n\n对于所有的数据，$1 \\le n \\le 5 \\times 10^4$，$0 \\le m \\le 10^5$，$0 \\le c_i \\le 10^9$，$0 \\le v_i \\le 10^{10} \\times n$。每个测试点中，所有 $n$ 的和不会超过 $1\\,000\\,233$，所有 $m$ 的和不会超过 $2\\,000\\,233$。\n", "locale": "zh-CN"}}}
{"pid": "P4776", "type": "P", "difficulty": 7, "samples": [["5 1\n1 1 2 2", "2"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "NOI", "O2优化"], "title": "[NOI2018] 多边形", "background": "", "description": "久莲是一个喜欢出题的女孩子。\n\n在今年的 World Final 结束以后，久莲特别喜欢计算几何，于是她打算在 NOI 的考场上也出一个计算几何：这是一道只有题目名字和计算几何相关的题目。\n\n首先，久莲给出了一棵 $n\\ (n \\ge 2)$ 个节点的有根树 $T$，根节点编号为 $1$。定义叶子节点为除了根以外所有度数恰好为 $1$ 的节点。下图是一个树 $T$ 的例子，其中叶子节点集合为 $\\{3, 4, 5\\}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9k8ckocd.png)\n\n接着通过这棵树，久莲构造了一个序列 $A$：\n- 从根节点开始深度优先遍历整棵树，遍历时按照编号从小到大的顺序来访问孩子，这样可以得到一个树 $T$ 的 DFS 序。\n- 接着按照在 DFS 序中的出现顺序从前往后，久莲把所有叶子节点排成一排得到了一个序列 $A$。\n\n更进一步地，通过序列 $A$，久莲定义了两个叶子节点 $u, v$ 的距离 $d(u, v)$：假设 $u$ 在 $A$ 中是第 $i$ 个元素，$v$ 是第 $j$ 个元素，则 $d(u, v) = \\min(|i − j|, |A| − |i − j|)$。其中 $|A|$ 为序列的长度，即 $T$ 的叶子个数，$i, j$ 指的是出现的位置，从 $1$ 开始计数。\n\n上面的例子中，序列 $A$ 为 $\\{4, 5, 3\\}$，其中 $d(3, 5) = d(3, 4) = d(4, 5) = 1$，$3, 4, 5$ 的出现位置分别为 $3, 1, 2$。\n\n最后，久莲给出了一个参数 $K$，利用这棵有根树 $T$ 和序列 $A$，我们可以构造一张 $n$ 个点的**无重边无自环**的无向图 $G$：两个不同的点 $u, v$ 之间有边当且仅当它们满足下列条件中的至少一个：\n- 在树 $T$ 中存在连接 $u, v$ 的边。\n- 在树 $T$ 中 $u, v$ 都是叶子节点且 $d(u, v) \\le K$。\n\n当 $K = 1$ 或 $2$ 时，上面的例子得到的图 $G$ 都如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zsq6qywg.png)\n\n现在久莲想让你来计算一下 $G$ 中不同的哈密尔顿回路数量有多少条，答案可能很大，请对 $998244353$ 取模后输出。\n\n下面是一些补充定义：\n- 无重边无自环的无向图 $G$ 的一条哈密尔顿回路 $H$ 是 $G$ 中边的一个子集，其中每一个点恰好有两条不同的相邻边在 $H$ 中，且任意两个点都可以通过 $H$ 中的边直接或间接到达。\n- 无重边无自环的无向图 $G$ 的两条哈密尔顿回路 $H_1, H_2$ 是不同的当且仅当存在一条边 $e$ 使得 $e$ 在 $H_1$ 中且不在 $H_2$ 中。", "inputFormat": "从文件 `polygon.in` 中读入数据。\n\n第一行输入两个整数 $n, K$，表示树 $T$ 的点数以及久莲选定的参数 $K$。\n\n第二行输入 $n - 1$ 个整数 $f_i\\ (1 \\le f_i \\le i)$，其中 $f_i$ 表示树 $T$ 上存在边 $( f_i, i + 1)$。", "outputFormat": "输出到文件 `polygon.out` 中。\n\n输出一行一个整数，表示哈密尔顿回路数量对 $998244353$ 取模后的结果。", "hint": "### 样例解释\n\n该样例和题面中的例子完全相同。两条哈密尔顿回路经过节点的顺序分别为 $(1, 2, 4, 5, 3)$ 和 $(1, 2, 5, 4, 3)$。\n\n### 子任务\n\n::cute-table{tuack=4}\n\n编号|$n$|$K$|特殊性质|编号|$n$|$K$|特殊性质\n:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:\n$1$|$\\le 5$|$\\le 3$|无|$11$|$\\le 1000$|$\\le 2$|A\n$2$|$\\le 10$|^|^|$12$|^|^|^\n$3$|$\\le 15$|^|^|$13$|^|^|^\n$4$|$\\le 20$|^|^|$14$|^|^|无\n$5$|$\\le 1000$|$=1$|A|$15$|^|^|^\n$6$|^|$=1$|^|$16$|^|^|^\n$7$|^|^|^|$17$|^|$\\le 3$|A\n$8$|^|^|无|$18$|^|^|^\n$9$|^|^|^|$19$|^|^|无\n$10$|^|^|^|$20$|^|^|^\n\n其中性质 A 为保证树上所有节点至多有两个孩子。\n\n对于所有的数据，保证 $1 \\leq f_i \\leq i$，$2 \\leq n \\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2018] Polygon", "background": "", "description": "Jiulian is a girl who likes to create problems.\n\nAfter this year’s World Final ended, Jiulian became very interested in computational geometry, so she decided to set a computational geometry problem in the NOI contest. This is a problem whose only relation to computational geometry is its title.\n\nFirst, Jiulian gives a rooted tree $T$ with $n\\ (n \\ge 2)$ nodes, where the root is node $1$. A leaf node is defined as any node whose degree is exactly $1$, excluding the root. The figure below shows an example of a tree $T$, where the set of leaf nodes is $\\{3, 4, 5\\}$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9k8ckocd.png)\n\nNext, using this tree, Jiulian constructs a sequence $A$:\n- Starting from the root, perform a depth-first traversal of the whole tree. During the traversal, visit children in increasing order of their labels. This yields a DFS order of the tree $T$.\n- Then, according to their order of appearance in the DFS order from front to back, Jiulian lines up all leaf nodes to obtain a sequence $A$.\n\nFurthermore, based on the sequence $A$, Jiulian defines the distance $d(u, v)$ between two leaf nodes $u, v$: suppose $u$ is the $i$-th element in $A$ and $v$ is the $j$-th element, then $d(u, v) = \\min(|i − j|, |A| − |i − j|)$. Here $|A|$ is the length of the sequence, i.e. the number of leaves of $T$, and $i, j$ are their positions, counted starting from $1$.\n\nIn the example above, the sequence $A$ is $\\{4, 5, 3\\}$, where $d(3, 5) = d(3, 4) = d(4, 5) = 1$, and the positions of $3, 4, 5$ are $3, 1, 2$ respectively.\n\nFinally, Jiulian gives a parameter $K$. Using the rooted tree $T$ and the sequence $A$, we can construct an undirected graph $G$ with $n$ vertices, **without multiple edges and without self-loops**. There is an edge between two distinct vertices $u, v$ if and only if they satisfy at least one of the following conditions:\n- There is an edge connecting $u$ and $v$ in the tree $T$.\n- In the tree $T$, both $u$ and $v$ are leaf nodes, and $d(u, v) \\le K$.\n\nWhen $K = 1$ or $2$, the graph $G$ obtained from the example above is as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zsq6qywg.png)\n\nNow Jiulian wants you to compute the number of distinct Hamiltonian cycles in $G$. The answer may be large, so output it modulo $998244353$.\n\nHere are some additional definitions:\n- A Hamiltonian cycle $H$ of an undirected graph $G$ without multiple edges and self-loops is a subset of edges of $G$ such that for every vertex, there are exactly two distinct incident edges in $H$, and any two vertices can be connected directly or indirectly using edges in $H$.\n- Two Hamiltonian cycles $H_1, H_2$ of an undirected graph $G$ without multiple edges and self-loops are different if and only if there exists an edge $e$ such that $e$ is in $H_1$ but not in $H_2$.", "inputFormat": "Read input from file `polygon.in`.\n\nThe first line contains two integers $n, K$, representing the number of nodes in the tree $T$ and the parameter $K$ chosen by Jiulian.\n\nThe second line contains $n - 1$ integers $f_i\\ (1 \\le f_i \\le i)$, where $f_i$ means that there is an edge $( f_i, i + 1)$ in the tree $T$.", "outputFormat": "Write output to file `polygon.out`.\n\nOutput one line with one integer, representing the number of Hamiltonian cycles modulo $998244353$.", "hint": "### Sample Explanation\n\nThis sample is exactly the same as the example in the statement. The orders of nodes visited by the two Hamiltonian cycles are $(1, 2, 4, 5, 3)$ and $(1, 2, 5, 4, 3)$, respectively.\n\n### Subtasks\n\n::cute-table{tuack=4}\n\nID|$n$|$K$|Special Property|ID|$n$|$K$|Special Property\n:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:\n$1$|$\\le 5$|$\\le 3$|None|$11$|$\\le 1000$|$\\le 2$|A\n$2$|$\\le 10$|^|^|$12$|^|^|^\n$3$|$\\le 15$|^|^|$13$|^|^|^\n$4$|$\\le 20$|^|^|$14$|^|^|None\n$5$|$\\le 1000$|$=1$|A|$15$|^|^|^\n$6$|^|$=1$|^|$16$|^|^|^\n$7$|^|^|^|$17$|^|$\\le 3$|A\n$8$|^|^|None|$18$|^|^|^\n$9$|^|^|^|$19$|^|^|None\n$10$|^|^|^|$20$|^|^|^\n\nProperty A means that every node in the tree has at most two children.\n\nFor all testdata, it is guaranteed that $1 \\leq f_i \\leq i$, $2 \\leq n \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2018] 多边形", "background": "", "description": "久莲是一个喜欢出题的女孩子。\n\n在今年的 World Final 结束以后，久莲特别喜欢计算几何，于是她打算在 NOI 的考场上也出一个计算几何：这是一道只有题目名字和计算几何相关的题目。\n\n首先，久莲给出了一棵 $n\\ (n \\ge 2)$ 个节点的有根树 $T$，根节点编号为 $1$。定义叶子节点为除了根以外所有度数恰好为 $1$ 的节点。下图是一个树 $T$ 的例子，其中叶子节点集合为 $\\{3, 4, 5\\}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9k8ckocd.png)\n\n接着通过这棵树，久莲构造了一个序列 $A$：\n- 从根节点开始深度优先遍历整棵树，遍历时按照编号从小到大的顺序来访问孩子，这样可以得到一个树 $T$ 的 DFS 序。\n- 接着按照在 DFS 序中的出现顺序从前往后，久莲把所有叶子节点排成一排得到了一个序列 $A$。\n\n更进一步地，通过序列 $A$，久莲定义了两个叶子节点 $u, v$ 的距离 $d(u, v)$：假设 $u$ 在 $A$ 中是第 $i$ 个元素，$v$ 是第 $j$ 个元素，则 $d(u, v) = \\min(|i − j|, |A| − |i − j|)$。其中 $|A|$ 为序列的长度，即 $T$ 的叶子个数，$i, j$ 指的是出现的位置，从 $1$ 开始计数。\n\n上面的例子中，序列 $A$ 为 $\\{4, 5, 3\\}$，其中 $d(3, 5) = d(3, 4) = d(4, 5) = 1$，$3, 4, 5$ 的出现位置分别为 $3, 1, 2$。\n\n最后，久莲给出了一个参数 $K$，利用这棵有根树 $T$ 和序列 $A$，我们可以构造一张 $n$ 个点的**无重边无自环**的无向图 $G$：两个不同的点 $u, v$ 之间有边当且仅当它们满足下列条件中的至少一个：\n- 在树 $T$ 中存在连接 $u, v$ 的边。\n- 在树 $T$ 中 $u, v$ 都是叶子节点且 $d(u, v) \\le K$。\n\n当 $K = 1$ 或 $2$ 时，上面的例子得到的图 $G$ 都如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zsq6qywg.png)\n\n现在久莲想让你来计算一下 $G$ 中不同的哈密尔顿回路数量有多少条，答案可能很大，请对 $998244353$ 取模后输出。\n\n下面是一些补充定义：\n- 无重边无自环的无向图 $G$ 的一条哈密尔顿回路 $H$ 是 $G$ 中边的一个子集，其中每一个点恰好有两条不同的相邻边在 $H$ 中，且任意两个点都可以通过 $H$ 中的边直接或间接到达。\n- 无重边无自环的无向图 $G$ 的两条哈密尔顿回路 $H_1, H_2$ 是不同的当且仅当存在一条边 $e$ 使得 $e$ 在 $H_1$ 中且不在 $H_2$ 中。", "inputFormat": "从文件 `polygon.in` 中读入数据。\n\n第一行输入两个整数 $n, K$，表示树 $T$ 的点数以及久莲选定的参数 $K$。\n\n第二行输入 $n - 1$ 个整数 $f_i\\ (1 \\le f_i \\le i)$，其中 $f_i$ 表示树 $T$ 上存在边 $( f_i, i + 1)$。", "outputFormat": "输出到文件 `polygon.out` 中。\n\n输出一行一个整数，表示哈密尔顿回路数量对 $998244353$ 取模后的结果。", "hint": "### 样例解释\n\n该样例和题面中的例子完全相同。两条哈密尔顿回路经过节点的顺序分别为 $(1, 2, 4, 5, 3)$ 和 $(1, 2, 5, 4, 3)$。\n\n### 子任务\n\n::cute-table{tuack=4}\n\n编号|$n$|$K$|特殊性质|编号|$n$|$K$|特殊性质\n:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:\n$1$|$\\le 5$|$\\le 3$|无|$11$|$\\le 1000$|$\\le 2$|A\n$2$|$\\le 10$|^|^|$12$|^|^|^\n$3$|$\\le 15$|^|^|$13$|^|^|^\n$4$|$\\le 20$|^|^|$14$|^|^|无\n$5$|$\\le 1000$|$=1$|A|$15$|^|^|^\n$6$|^|$=1$|^|$16$|^|^|^\n$7$|^|^|^|$17$|^|$\\le 3$|A\n$8$|^|^|无|$18$|^|^|^\n$9$|^|^|^|$19$|^|^|无\n$10$|^|^|^|$20$|^|^|^\n\n其中性质 A 为保证树上所有节点至多有两个孩子。\n\n对于所有的数据，保证 $1 \\leq f_i \\leq i$，$2 \\leq n \\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P4777", "type": "P", "difficulty": 6, "samples": [["3\n11 6\n25 9\n33 17\n", "809"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "最大公约数 gcd", "中国剩余定理 CRT", "模板题"], "title": "【模板】扩展中国剩余定理（EXCRT）", "background": "", "description": "给定 $n$ 组非负整数 $a_i, b_i$ ，求解关于 $x$ 的方程组的最小非负整数解。\n$$\\begin{cases}x\\equiv b_1\\pmod{a_1}\\\\x\\equiv b_2\\pmod{a_2}\\\\\\dots\\\\x\\equiv b_n\\pmod{a_n}\\end{cases}$$", "inputFormat": "输入第一行包含整数 $n$。\n\n接下来 $n$ 行，每行两个非负整数 $a_i, b_i$。", "outputFormat": "输出一行，为满足条件的最小非负整数 $x$。", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le {10}^5$，$1 \\le a_i \\le {10}^{12}$，$0\\leq b_i \\leq 10^{12}$，保证所有 $a_i$ 的最小公倍数不超过 ${10}^{18}$。\n\n**请注意程序运行过程中进行乘法运算时结果可能有溢出的风险。**\n\n数据保证有解。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Extended Chinese Remainder Theorem (EXCRT).", "background": "", "description": "Given $n$ pairs of non-negative integers $a_i, b_i$, find the smallest non-negative integer solution to the system of equations in $x$.\n$$\\begin{cases}x\\equiv b_1\\pmod{a_1}\\\\x\\equiv b_2\\pmod{a_2}\\\\\\dots\\\\x\\equiv b_n\\pmod{a_n}\\end{cases}$$", "inputFormat": "The first line contains an integer $n$.\n\nThe next $n$ lines each contain two non-negative integers $a_i, b_i$.", "outputFormat": "Output one line: the smallest non-negative integer $x$ that satisfies the conditions.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le {10}^5$, $1 \\le a_i \\le {10}^{12}$, $0\\leq b_i \\leq 10^{12}$. It is guaranteed that the least common multiple of all $a_i$ does not exceed ${10}^{18}$.\n\n**Please note that during the execution of the program, multiplication operations may overflow.**\n\nIt is guaranteed that a solution exists.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】扩展中国剩余定理（EXCRT）", "background": "", "description": "给定 $n$ 组非负整数 $a_i, b_i$ ，求解关于 $x$ 的方程组的最小非负整数解。\n$$\\begin{cases}x\\equiv b_1\\pmod{a_1}\\\\x\\equiv b_2\\pmod{a_2}\\\\\\dots\\\\x\\equiv b_n\\pmod{a_n}\\end{cases}$$", "inputFormat": "输入第一行包含整数 $n$。\n\n接下来 $n$ 行，每行两个非负整数 $a_i, b_i$。", "outputFormat": "输出一行，为满足条件的最小非负整数 $x$。", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le {10}^5$，$1 \\le a_i \\le {10}^{12}$，$0\\leq b_i \\leq 10^{12}$，保证所有 $a_i$ 的最小公倍数不超过 ${10}^{18}$。\n\n**请注意程序运行过程中进行乘法运算时结果可能有溢出的风险。**\n\n数据保证有解。", "locale": "zh-CN"}}}
{"pid": "P4778", "type": "P", "difficulty": 6, "samples": [["3\n\n3\n2 3 1\n\n4\n2 1 4 3\n\n2\n1 2", "3\n2\n1"]], "limits": {"time": [1000, 1000], "memory": [32000, 32000]}, "tags": [], "title": "Counting swaps", "background": "Just like yesterday (in problem U of the practice session), Bob is busy, so Alice keeps on playing some single-player games and puzzles. In her newest puzzle she has a permutation of numbers from 1 to n. The goal of the puzzle is to sort the permutation using the smallest possible number of swaps.    \n\nInstead of simply solving the puzzle, Alice is wondering about the probability of winning it just by playing at random. In order to answer this question, she needs to know the number of optimal solutions to her puzzle.", "description": "You are given a permutation $p_1,\\cdots, p_n$ of the numbers $1$ through $n$. In each step you can choose two numbers $x < y$ and swap $p_x$ with $p_y$.\n\nLet $m$ be the minimum number of such swaps needed to sort the given permutation. Compute the number of different sequences of exactly $m$ swaps that sort the given permutation. Since this number may be large, compute it modulo $10^9 + 9$.", "inputFormat": "The first line of the input file contains an integer t specifying the number of test cases. Each test case is preceded by a blank line.\n\nEach test case consists of two lines. The first line contains the integer n. The second line contains the sequence $p_1,\\cdots, p_n$: a permutation of $1,\\cdots, n$.\n\nIn the easy subproblem C1, $1 \\leq n \\leq 10$.\n\nIn the hard subproblem C2, $1 \\leq n \\leq 10^5$.", "outputFormat": "For each test case, output a single line with a single integer: $x \\bmod 10^9+9$, where x is the number of ways to sort the given sequence using as few swaps as possible.", "hint": "In the first test case, we can sort the permutation in two swaps. We can make the first swap arbitrarily; for each of them, there's exactly one optimal second swap. For example, one of the three shortest solutions is “swap $p_1$ with $p_2$ and then swap $p_1$ with $p_3$”.  \n\nIn the second test case, the optimal solution involves swapping $p_1$ with $p_2$ and swapping $p_3$ with $p_4$. We can do these two swaps in either order.  \n\nThe third sequence is already sorted. The optimal number of swaps is $0$, and thus the only optimal solution is an empty sequence of swaps.  \n题目来源：[IPSC2016](https://ipsc.ksp.sk/2016/real/problems/c.html)", "locale": "en", "translations": {"en": {"title": "Counting swaps", "background": "Just like yesterday (in problem U of the practice session), Bob is busy, so Alice keeps on playing some single-player games and puzzles. In her newest puzzle she has a permutation of numbers from 1 to n. The goal of the puzzle is to sort the permutation using the smallest possible number of swaps.    \n\nInstead of simply solving the puzzle, Alice is wondering about the probability of winning it just by playing at random. In order to answer this question, she needs to know the number of optimal solutions to her puzzle.", "description": "You are given a permutation $p_1,\\cdots, p_n$ of the numbers $1$ through $n$. In each step you can choose two numbers $x < y$ and swap $p_x$ with $p_y$.\n\nLet $m$ be the minimum number of such swaps needed to sort the given permutation. Compute the number of different sequences of exactly $m$ swaps that sort the given permutation. Since this number may be large, compute it modulo $10^9 + 9$.", "inputFormat": "The first line of the input file contains an integer t specifying the number of test cases. Each test case is preceded by a blank line.\n\nEach test case consists of two lines. The first line contains the integer n. The second line contains the sequence $p_1,\\cdots, p_n$: a permutation of $1,\\cdots, n$.\n\nIn the easy subproblem C1, $1 \\leq n \\leq 10$.\n\nIn the hard subproblem C2, $1 \\leq n \\leq 10^5$.", "outputFormat": "For each test case, output a single line with a single integer: $x \\bmod 10^9+9$, where x is the number of ways to sort the given sequence using as few swaps as possible.", "hint": "In the first test case, we can sort the permutation in two swaps. We can make the first swap arbitrarily; for each of them, there's exactly one optimal second swap. For example, one of the three shortest solutions is “swap $p_1$ with $p_2$ and then swap $p_1$ with $p_3$”.  \n\nIn the second test case, the optimal solution involves swapping $p_1$ with $p_2$ and swapping $p_3$ with $p_4$. We can do these two swaps in either order.  \n\nThe third sequence is already sorted. The optimal number of swaps is $0$, and thus the only optimal solution is an empty sequence of swaps.  \n题目来源：[IPSC2016](https://ipsc.ksp.sk/2016/real/problems/c.html)", "locale": "en"}, "zh-CN": {"title": "Counting swaps", "background": null, "description": "给定一个排列 $p_1, \\ldots, p_n$，它是数字 $1$ 到 $n$ 的一个排列。在每一步中，你可以选择两个数字 $x < y$ 并交换 $p_x$ 和 $p_y$。\n\n设 $m$ 为将给定排列排序所需的最小交换次数。计算恰好用 $m$ 次交换来排序给定排列的不同序列的数量。由于这个数量可能很大，计算它对 $10^9 + 9$ 取模的结果。", "inputFormat": "输入文件的第一行包含一个整数 $t$，表示测试用例的数量。每个测试用例前有一个空行。\n\n每个测试用例由两行组成。第一行包含整数 $n$。第二行包含序列 $p_1, \\ldots, p_n$：这是 $1, \\ldots, n$ 的一个排列。\n\n在简单子问题 C1 中，$1 \\leq n \\leq 10$。\n\n在困难子问题 C2 中，$1 \\leq n \\leq 10^5$。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数：$x \\bmod 10^9 + 9$，其中 $x$ 是用尽可能少的交换次数来排序给定序列的方法数。", "hint": "在第一个测试用例中，我们可以通过两次交换来排序排列。我们可以任意进行第一次交换；对于每种情况，恰好有一种最佳的第二次交换。例如，三个最短解之一是“交换 $p_1$ 和 $p_2$，然后交换 $p_1$ 和 $p_3$”。\n\n在第二个测试用例中，最佳解涉及交换 $p_1$ 和 $p_2$，以及交换 $p_3$ 和 $p_4$。我们可以以任意顺序进行这两次交换。\n\n第三个序列已经排序。最佳交换次数为 $0$，因此唯一的最佳解是空的交换序列。\n\n题目来源：[IPSC2016](https://ipsc.ksp.sk/2016/real/problems/c.html)\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4779", "type": "P", "difficulty": 3, "samples": [["4 6 1\n1 2 2\n2 3 2\n2 4 1\n1 3 5\n3 4 3\n1 4 4", "0 2 4 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "优先队列", "最短路", "模板题"], "title": "【模板】单源最短路径（标准版）", "background": "2018 年 7 月 19 日，某位同学在 [NOI Day 1 T1 归程](https://www.luogu.com.cn/problem/P4768) 一题里非常熟练地使用了一个广为人知的算法求最短路。\n\n然后呢？\n\n$100 \\rightarrow 60$；\n\n$\\text{Ag} \\rightarrow \\text{Cu}$；\n\n最终，他因此没能与理想的大学达成契约。\n\n小 F 衷心祝愿大家不再重蹈覆辙。", "description": "给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。\n\n数据保证你能从 $s$ 出发到任意点。", "inputFormat": "第一行为三个正整数 $n, m, s$。\n第二行起 $m$ 行，每行三个非负整数 $u_i, v_i, w_i$，表示从 $u_i$ 到 $v_i$ 有一条权值为 $w_i$ 的有向边。", "outputFormat": "输出一行 $n$ 个空格分隔的非负整数，表示 $s$ 到每个点的距离。", "hint": "样例解释请参考 [数据随机的模板题](https://www.luogu.com.cn/problem/P3371)。\n\n$1 \\leq n \\leq 10^5$；\n\n$1 \\leq m \\leq 2\\times 10^5$；\n\n$s = 1$；\n\n$1 \\leq u_i, v_i\\leq n$；\n\n$0 \\leq w_i \\leq 10 ^ 9$,\n\n$0 \\leq \\sum w_i \\leq 10 ^ 9$。\n\n本题数据可能会持续更新，但不会重测，望周知。\n\n2018.09.04 数据更新 from @zzq", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Single-Source Shortest Path (Standard Version).", "background": "On July 19, 2018, a student used a well-known algorithm very skillfully to find shortest paths in the problem [NOI Day 1 T1 Return Trip](https://www.luogu.org/problemnew/show/P4768).\n\nThen what?\n\n$100 \\rightarrow 60$;\n\n$\\text{Ag} \\rightarrow \\text{Cu}$;\n\nIn the end, because of this, he failed to make a contract with his ideal university.\n\nLittle F sincerely hopes that everyone will not make the same mistake again.", "description": "Given a directed graph with $n$ nodes and $m$ directed edges with non-negative weights, please compute the distance from $s$ to every node.\n\nThe testdata guarantees that you can reach every node starting from $s$.", "inputFormat": "The first line contains three positive integers $n, m, s$.\nStarting from the second line, there are $m$ lines. Each line contains three non-negative integers $u_i, v_i, w_i$, meaning there is a directed edge from $u_i$ to $v_i$ with weight $w_i$.", "outputFormat": "Output one line with $n$ space-separated non-negative integers, representing the distance from $s$ to each node.", "hint": "For the sample explanation, please refer to [Template Problem with Random Data](https://www.luogu.com.cn/problem/P3371).\n\nConstraints:\n\n$1 \\leq n \\leq 10^5$;\n\n$1 \\leq m \\leq 2\\times 10^5$;\n\n$s = 1$;\n\n$1 \\leq u_i, v_i\\leq n$;\n\n$0 \\leq w_i \\leq 10 ^ 9$,\n\n$0 \\leq \\sum w_i \\leq 10 ^ 9$。\n\nThe testdata of this problem may continue to be updated, but it will not be rejudged. Please be informed.\n\n2018.09.04 Data update from @zzq.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】单源最短路径（标准版）", "background": "2018 年 7 月 19 日，某位同学在 [NOI Day 1 T1 归程](https://www.luogu.com.cn/problem/P4768) 一题里非常熟练地使用了一个广为人知的算法求最短路。\n\n然后呢？\n\n$100 \\rightarrow 60$；\n\n$\\text{Ag} \\rightarrow \\text{Cu}$；\n\n最终，他因此没能与理想的大学达成契约。\n\n小 F 衷心祝愿大家不再重蹈覆辙。", "description": "给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。\n\n数据保证你能从 $s$ 出发到任意点。", "inputFormat": "第一行为三个正整数 $n, m, s$。\n第二行起 $m$ 行，每行三个非负整数 $u_i, v_i, w_i$，表示从 $u_i$ 到 $v_i$ 有一条权值为 $w_i$ 的有向边。", "outputFormat": "输出一行 $n$ 个空格分隔的非负整数，表示 $s$ 到每个点的距离。", "hint": "样例解释请参考 [数据随机的模板题](https://www.luogu.com.cn/problem/P3371)。\n\n$1 \\leq n \\leq 10^5$；\n\n$1 \\leq m \\leq 2\\times 10^5$；\n\n$s = 1$；\n\n$1 \\leq u_i, v_i\\leq n$；\n\n$0 \\leq w_i \\leq 10 ^ 9$,\n\n$0 \\leq \\sum w_i \\leq 10 ^ 9$。\n\n本题数据可能会持续更新，但不会重测，望周知。\n\n2018.09.04 数据更新 from @zzq", "locale": "zh-CN"}}}
{"pid": "P4780", "type": "P", "difficulty": 5, "samples": [["4", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "枚举", "素数判断,质数,筛法"], "title": "Phi 的反函数", "background": null, "description": "求最小的正整数 $x$，使得 $\\varphi(x)=n$。", "inputFormat": "输入正整数 $n$（$n<2^{31}$）。", "outputFormat": "输出 $x$，如果 $x>2^{31}$ 或者不存在，则输出 $-1$。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Inverse Function of Phi.", "background": "", "description": "Find the smallest positive integer $x$ such that $\\varphi(x)=n$.", "inputFormat": "Input a positive integer $n$ ($n<2^{31}$).", "outputFormat": "Output $x$. If $x>2^{31}$ or it does not exist, output $-1$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Phi 的反函数", "background": null, "description": "求最小的正整数 $x$，使得 $\\varphi(x)=n$。", "inputFormat": "输入正整数 $n$（$n<2^{31}$）。", "outputFormat": "输出 $x$，如果 $x>2^{31}$ 或者不存在，则输出 $-1$。", "hint": null, "locale": "zh-CN"}}}
