{"pid": "P8858", "type": "P", "difficulty": 4, "samples": [["3\n4\n1 1\n1 2\n4 1\n4 2\n6\n1 2\n1 3\n2 1\n2 2\n2 3\n3 2\n12\n1 3\n2 2\n2 3\n2 4\n3 1\n3 2\n3 4\n3 5\n4 2\n4 3\n4 4\n5 3\n", "2\n3\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "O2优化", "洛谷月赛", "双指针 two-pointer"], "title": "折线", "background": "", "description": "平面直角坐标系的第一象限内有一块左下角为 $(0,0)$ 右上角为 $(10^{100},10^{100})$ 的矩形区域，区域内有**正偶数**个整点，试求出这样一条从 $(0,0)$ 出发，到 $(10^{100},10^{100})$ 的在区域内部的折线：\n\n- 折线的每一部分都平行于 $x$ 轴或 $y$ 轴。\n- 折线不能经过给定的整点。\n- 折线将整块区域分成包含给定整点个数相等的两块。\n- 折线拥有尽可能少的折点。\n\n可以证明一定存在一条满足限制的折线，你只需要输出满足限制的折线的折点数即可。\n\n注意折点的坐标可以不是整数。", "inputFormat": "输入第一行一个正整数 $T$，表示数据组数。\n\n接下来的每组数据中，第一行一个**正偶数** $n$，表示给定的整点个数。\n\n接下来 $n$ 行，第 $i$ 行两个正整数 $x_i,y_i$，表示给定的第 $i$ 个整点的坐标为 $(x_i,y_i)$。", "outputFormat": "输出 $T$ 行，每行一个正整数，表示满足限制的折线的折点数。", "hint": "#### 【样例解释】\n\n对于第一组数据，一条合法的折线为：$(0,0) \\to (2.5,0) \\to (2.5,10^{100}) \\to (10^{100},10^{100})$，它有 $(2.5,0)$ 和 $(2.5,10^{100})$ 两个折点。\n\n#### 【数据范围】\n\n|  测试点编号 | $n \\leq$ |      特殊限制      |\n|:-----------:|:--------:|:------------------:|\n|  $1 \\sim 2$ |    $4$   |         无         |\n|  $3 \\sim 4$ |   $10$   |         无         |\n|  $5 \\sim 6$ |   $50$  |         无         |\n|  $7 \\sim 8$ |  $10^5$  | 保证答案不大于 $3$ |\n| $9 \\sim 10$ | $10^5$   | 无                 |\n\n对于所有数据，$1 \\leq T \\leq 10^4, 1 \\leq \\sum n \\leq 5 \\times 10^5, 1 \\leq x_i,y_i \\leq n$，保证 $n$ 为正偶数，每组数据中不存在两个坐标相同的整点。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "折线", "background": "", "description": "平面直角坐标系的第一象限内有一块左下角为 $(0,0)$ 右上角为 $(10^{100},10^{100})$ 的矩形区域，区域内有**正偶数**个整点，试求出这样一条从 $(0,0)$ 出发，到 $(10^{100},10^{100})$ 的在区域内部的折线：\n\n- 折线的每一部分都平行于 $x$ 轴或 $y$ 轴。\n- 折线不能经过给定的整点。\n- 折线将整块区域分成包含给定整点个数相等的两块。\n- 折线拥有尽可能少的折点。\n\n可以证明一定存在一条满足限制的折线，你只需要输出满足限制的折线的折点数即可。\n\n注意折点的坐标可以不是整数。", "inputFormat": "输入第一行一个正整数 $T$，表示数据组数。\n\n接下来的每组数据中，第一行一个**正偶数** $n$，表示给定的整点个数。\n\n接下来 $n$ 行，第 $i$ 行两个正整数 $x_i,y_i$，表示给定的第 $i$ 个整点的坐标为 $(x_i,y_i)$。", "outputFormat": "输出 $T$ 行，每行一个正整数，表示满足限制的折线的折点数。", "hint": "#### 【样例解释】\n\n对于第一组数据，一条合法的折线为：$(0,0) \\to (2.5,0) \\to (2.5,10^{100}) \\to (10^{100},10^{100})$，它有 $(2.5,0)$ 和 $(2.5,10^{100})$ 两个折点。\n\n#### 【数据范围】\n\n|  测试点编号 | $n \\leq$ |      特殊限制      |\n|:-----------:|:--------:|:------------------:|\n|  $1 \\sim 2$ |    $4$   |         无         |\n|  $3 \\sim 4$ |   $10$   |         无         |\n|  $5 \\sim 6$ |   $50$  |         无         |\n|  $7 \\sim 8$ |  $10^5$  | 保证答案不大于 $3$ |\n| $9 \\sim 10$ | $10^5$   | 无                 |\n\n对于所有数据，$1 \\leq T \\leq 10^4, 1 \\leq \\sum n \\leq 5 \\times 10^5, 1 \\leq x_i,y_i \\leq n$，保证 $n$ 为正偶数，每组数据中不存在两个坐标相同的整点。", "locale": "zh-CN"}}}
{"pid": "P8859", "type": "P", "difficulty": 6, "samples": [["4 2 1", "11"], ["5 2 2", "14"], ["50 10 1", "808620624"], ["50 10 2", "578144115"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "贪心", "洛谷原创", "O2优化", "组合数学", "洛谷月赛"], "title": "冒泡排序", "background": "", "description": "有一个值域下标均为 $1\\sim n$ 的排列或圆排列 $A$，定义 $f(A)$ 为将 $A$ 升序排序所需的最小操作次数。\n\n每次操作中，你可以选择一个元素并向前**冒泡**若干次，一次**冒泡**定义为：若这个元素小于前一个元素，则可以交换它与前一个元素。当某次无法**冒泡**时，这次操作立即停止。否则可以连续**冒泡**任意次。\n\n比如有排列 $[3,5,2,1,4]$，一次操作可以选择元素 $1$ ，得到排列 $[3,5,1,2,4],[3,1,5,2,4]$ 或 $[1,3,5,2,4]$ 。\n\n若有圆排列 $[2,1,4,3]$，选择元素 $1$ 后可以得到圆排列 $[1,2,4,3],[3,2,4,1]$ 或 $[3,2,1,4]$ 。注意到圆排列中第 $1$ 个元素的前一个元素为第 $n$ 个元素。\n\n排列或圆排列被升序排序，当且仅当对于所有 $\\space 2 \\leq i \\leq n$，元素 $i$ 的前一个元素为元素 $i-1$。\n\n给定 $n,k,type$，你需要：\n- 在 $type=1$ 时求有多少长为 $n$ 的排列 $A$ 满足 $f(A)=k$ 。\n- 在 $type=2$ 时求有多少长为 $n$ 的圆排列 $A$ 满足 $f(A)=k$ 。\n\n答案对 $10^9+7$ 取模。", "inputFormat": "输入一行三个正整数 $n,k,type$，具体含义见题目描述。", "outputFormat": "输出一行一个整数，表示答案对 $10^9+7$ 取模后的结果。", "hint": "#### 【样例解释 #1】\n\n有如下合法排列：\n\n1. $[1,4,2,3]$\n2. $[1,4,3,2]$\n3. $[2,1,4,3]$\n4. $[2,4,1,3]$\n5. $[2,4,3,1]$\n6. $[3,1,2,4]$\n7. $[3,1,4,2]$\n8. $[3,2,1,4]$\n9. $[3,2,4,1]$\n10. $[3,4,1,2]$\n11. $[3,4,2,1]$\n\n#### 【样例解释 #2】\n\n有如下合法圆排列：\n\n1. $[1,2,5,3,4]$\n2. $[1,2,5,4,3]$\n3. $[1,3,2,5,4]$\n4. $[1,3,5,2,4]$\n5. $[1,3,5,4,2]$\n6. $[1,4,2,3,5]$\n7. $[1,4,2,5,3]$\n8. $[1,4,3,2,5]$\n9. $[1,4,3,5,2]$\n10. $[1,4,5,3,2]$\n11. $[1,5,2,4,3]$\n12. $[1,5,3,2,4]$\n13. $[1,5,3,4,2]$\n14. $[1,5,4,2,3]$\n\n需要注意的是，我们认为 $[1,2,5,3,4]$ 和 $[2,5,3,4,1]$ 等是同一个圆排列。\n\n也就是我们认为两个圆排列不同，当且仅当存在一个 $2 \\leq i \\leq n$，满足两个圆排列中元素 $i$ 的前一个元素不同。\n\n#### 【数据范围】\n\n|   测试点编号 | $n \\leq$ | $k \\leq$ | $type=$ |\n|:------------:|:--------:|:--------:|:-------:|\n|  $1 \\sim 2$  |    $7$   |    $7$   |   $1$   |\n|  $3 \\sim 4$  |    $7$   |    $7$   |   $2$   |\n|  $5 \\sim 6$  |   $15$   |   $15$   |   $1$   |\n|  $7 \\sim 8$  |   $15$   |   $15$   |   $2$   |\n|  $9 \\sim 12$ |   $50$   |   $50$   |   $1$   |\n| $13 \\sim 16$ |   $50$   |   $50$   |   $2$   |\n|     $17$     |   $500$  |    $10$   |   $1$   |\n|     $18$     |   $500$  |    $10$   |   $2$   |\n|     $19$     |   $500$  |   $500$  |   $1$   |\n|     $20$     |   $500$  |   $500$  |   $2$   |\n\n对于所有数据，$1 \\leq k < n \\leq 500$，$1 \\leq type \\leq 2$。  ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "冒泡排序", "background": "", "description": "有一个值域下标均为 $1\\sim n$ 的排列或圆排列 $A$，定义 $f(A)$ 为将 $A$ 升序排序所需的最小操作次数。\n\n每次操作中，你可以选择一个元素并向前**冒泡**若干次，一次**冒泡**定义为：若这个元素小于前一个元素，则可以交换它与前一个元素。当某次无法**冒泡**时，这次操作立即停止。否则可以连续**冒泡**任意次。\n\n比如有排列 $[3,5,2,1,4]$，一次操作可以选择元素 $1$ ，得到排列 $[3,5,1,2,4],[3,1,5,2,4]$ 或 $[1,3,5,2,4]$ 。\n\n若有圆排列 $[2,1,4,3]$，选择元素 $1$ 后可以得到圆排列 $[1,2,4,3],[3,2,4,1]$ 或 $[3,2,1,4]$ 。注意到圆排列中第 $1$ 个元素的前一个元素为第 $n$ 个元素。\n\n排列或圆排列被升序排序，当且仅当对于所有 $\\space 2 \\leq i \\leq n$，元素 $i$ 的前一个元素为元素 $i-1$。\n\n给定 $n,k,type$，你需要：\n- 在 $type=1$ 时求有多少长为 $n$ 的排列 $A$ 满足 $f(A)=k$ 。\n- 在 $type=2$ 时求有多少长为 $n$ 的圆排列 $A$ 满足 $f(A)=k$ 。\n\n答案对 $10^9+7$ 取模。", "inputFormat": "输入一行三个正整数 $n,k,type$，具体含义见题目描述。", "outputFormat": "输出一行一个整数，表示答案对 $10^9+7$ 取模后的结果。", "hint": "#### 【样例解释 #1】\n\n有如下合法排列：\n\n1. $[1,4,2,3]$\n2. $[1,4,3,2]$\n3. $[2,1,4,3]$\n4. $[2,4,1,3]$\n5. $[2,4,3,1]$\n6. $[3,1,2,4]$\n7. $[3,1,4,2]$\n8. $[3,2,1,4]$\n9. $[3,2,4,1]$\n10. $[3,4,1,2]$\n11. $[3,4,2,1]$\n\n#### 【样例解释 #2】\n\n有如下合法圆排列：\n\n1. $[1,2,5,3,4]$\n2. $[1,2,5,4,3]$\n3. $[1,3,2,5,4]$\n4. $[1,3,5,2,4]$\n5. $[1,3,5,4,2]$\n6. $[1,4,2,3,5]$\n7. $[1,4,2,5,3]$\n8. $[1,4,3,2,5]$\n9. $[1,4,3,5,2]$\n10. $[1,4,5,3,2]$\n11. $[1,5,2,4,3]$\n12. $[1,5,3,2,4]$\n13. $[1,5,3,4,2]$\n14. $[1,5,4,2,3]$\n\n需要注意的是，我们认为 $[1,2,5,3,4]$ 和 $[2,5,3,4,1]$ 等是同一个圆排列。\n\n也就是我们认为两个圆排列不同，当且仅当存在一个 $2 \\leq i \\leq n$，满足两个圆排列中元素 $i$ 的前一个元素不同。\n\n#### 【数据范围】\n\n|   测试点编号 | $n \\leq$ | $k \\leq$ | $type=$ |\n|:------------:|:--------:|:--------:|:-------:|\n|  $1 \\sim 2$  |    $7$   |    $7$   |   $1$   |\n|  $3 \\sim 4$  |    $7$   |    $7$   |   $2$   |\n|  $5 \\sim 6$  |   $15$   |   $15$   |   $1$   |\n|  $7 \\sim 8$  |   $15$   |   $15$   |   $2$   |\n|  $9 \\sim 12$ |   $50$   |   $50$   |   $1$   |\n| $13 \\sim 16$ |   $50$   |   $50$   |   $2$   |\n|     $17$     |   $500$  |    $10$   |   $1$   |\n|     $18$     |   $500$  |    $10$   |   $2$   |\n|     $19$     |   $500$  |   $500$  |   $1$   |\n|     $20$     |   $500$  |   $500$  |   $2$   |\n\n对于所有数据，$1 \\leq k < n \\leq 500$，$1 \\leq type \\leq 2$。  ", "locale": "zh-CN"}}}
{"pid": "P8860", "type": "P", "difficulty": 6, "samples": [["5 6 5\n1 2\n2 3\n3 5\n2 4\n4 5\n5 1\n1\n2\n3\n4\n5", "0\n1\n1\n0\n0\n"], ["10 11 8\n1 2\n2 7\n2 5\n1 4\n4 5\n4 8\n8 9\n9 5\n3 2\n3 6\n5 10\n10\n5\n11\n10\n3\n7\n1\n4\n", "1\n1\n0\n0\n1\n0\n1\n0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "倍增", "洛谷原创", "O2优化", "最短路", "可持久化线段树", "洛谷月赛"], "title": "动态图连通性", "background": "", "description": "给定一张 $n$ 点 $m$ 边的**有向图**，初始时存在一条从 $1$ 到 $n$ 的路径。  \n\n你需要处理 $q$ 组询问，每组询问给定一个 $[1,m]$ 中的正整数 $x$，如果原图中的第 $x$ 条边仍存在且当前的图中删去原图中的第 $x$ 条边后仍有一条从 $1$ 到 $n$ 的路径，则删除原图中的第 $x$ 条边。  \n\n你需要报告每组询问中是否删去了第 $x$ 条边。 \n\n**请注意：一组询问中删除某条边后，这条边会被永远删除。也就是询问之间会相互影响。**", "inputFormat": "输入第一行三个正整数 $n,m,q$，分别表示有向图的点数，边数以及询问个数。   \n\n接下来 $m$ 行，第 $i$ 行两个正整数 $u_i,v_i$，表示第 $i$ 条边由 $u_i$ 连向 $v_i$。  \n\n接下来 $q$ 行，每行一个正整数 $x$，具体含义同题目描述。", "outputFormat": "输出共 $q$ 行，每行一个正整数 $0$ 或 $1$。 \n\n如果在这组询问中删去了第 $x$ 条边，输出 $1$，否则输出 $0$。", "hint": "#### 【样例解释】\n\n在第一组样例中：\n\n初始时，图中边集为 $\\{ (1,2),(2,3),(3,5),(2,4),(4,5),(5,1) \\}$。\n\n若删去原图中的第 $1$ 条边 $(1,2)$，图中就没有 $1$ 到 $n$ 的路径，所以不能删除第 $1$ 条边。\n\n若删去原图中的第 $2$ 条边 $(2,3)$，图中存在路径 $1 \\to 2 \\to 4 \\to 5$，所以可以删去第 $2$ 条边，图中边集变为 $\\{ (1,2),(3,5),(2,4),(4,5),(5,1) \\}$。\n\n若删去原图中的第 $3$ 条边 $(3,5)$，图中存在路径 $1 \\to 2 \\to 4 \\to 5$，所以可以删去第 $3$ 条边，图中边集变为 $\\{ (1,2),(2,4),(4,5),(5,1) \\}$。\n\n若删去原图中的第 $4$ 条边 $(2,4)$，图中就没有 $1$ 到 $n$ 的路径，所以不能删除第 $4$ 条边。\n\n若删去原图中的第 $5$ 条边 $(4,5)$，图中就没有 $1$ 到 $n$ 的路径，所以不能删除第 $5$ 条边。\n\n#### 【数据范围】\n\n|  测试点编号  |    $n,m \\leq$   |     $q \\leq$    |            特殊限制           |\n|:------------:|:---------------:|:---------------:|:-------------------------------:|\n|  $1 \\sim 2$  |      $1000$     |      $1000$     |                无               |\n|  $3 \\sim 6$  |      $5000$     | $2 \\times 10^5$ |                无               |\n|  $7 \\sim 8$  | $2 \\times 10^5$ | $2 \\times 10^5$ | 保证所有询问中最多有 $1$ 条边没有被删除 |\n| $9 \\sim 12$ | $2 \\times 10^5$ | $2 \\times 10^5$ | 保证所有询问中最多有 $5$ 条边没有被删除 |\n| $13 \\sim 16$ | $2 \\times 10^5$ | $2 \\times 10^5$ |         将有向图视作无向图仍能得到正确答案        |\n| $17 \\sim 20$ | $2 \\times 10^5$ | $2 \\times 10^5$ |                无               |\n\n对于所有数据，$1 \\leq n,m,q \\leq 2 \\times 10^5$，给定的图无重边、自环，且存在一条 $1$ 到 $n$ 的路径。\n\n**给出的两组大样例分别满足测试点 1 和测试点 13 的限制。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "动态图连通性", "background": "", "description": "给定一张 $n$ 点 $m$ 边的**有向图**，初始时存在一条从 $1$ 到 $n$ 的路径。  \n\n你需要处理 $q$ 组询问，每组询问给定一个 $[1,m]$ 中的正整数 $x$，如果原图中的第 $x$ 条边仍存在且当前的图中删去原图中的第 $x$ 条边后仍有一条从 $1$ 到 $n$ 的路径，则删除原图中的第 $x$ 条边。  \n\n你需要报告每组询问中是否删去了第 $x$ 条边。 \n\n**请注意：一组询问中删除某条边后，这条边会被永远删除。也就是询问之间会相互影响。**", "inputFormat": "输入第一行三个正整数 $n,m,q$，分别表示有向图的点数，边数以及询问个数。   \n\n接下来 $m$ 行，第 $i$ 行两个正整数 $u_i,v_i$，表示第 $i$ 条边由 $u_i$ 连向 $v_i$。  \n\n接下来 $q$ 行，每行一个正整数 $x$，具体含义同题目描述。", "outputFormat": "输出共 $q$ 行，每行一个正整数 $0$ 或 $1$。 \n\n如果在这组询问中删去了第 $x$ 条边，输出 $1$，否则输出 $0$。", "hint": "#### 【样例解释】\n\n在第一组样例中：\n\n初始时，图中边集为 $\\{ (1,2),(2,3),(3,5),(2,4),(4,5),(5,1) \\}$。\n\n若删去原图中的第 $1$ 条边 $(1,2)$，图中就没有 $1$ 到 $n$ 的路径，所以不能删除第 $1$ 条边。\n\n若删去原图中的第 $2$ 条边 $(2,3)$，图中存在路径 $1 \\to 2 \\to 4 \\to 5$，所以可以删去第 $2$ 条边，图中边集变为 $\\{ (1,2),(3,5),(2,4),(4,5),(5,1) \\}$。\n\n若删去原图中的第 $3$ 条边 $(3,5)$，图中存在路径 $1 \\to 2 \\to 4 \\to 5$，所以可以删去第 $3$ 条边，图中边集变为 $\\{ (1,2),(2,4),(4,5),(5,1) \\}$。\n\n若删去原图中的第 $4$ 条边 $(2,4)$，图中就没有 $1$ 到 $n$ 的路径，所以不能删除第 $4$ 条边。\n\n若删去原图中的第 $5$ 条边 $(4,5)$，图中就没有 $1$ 到 $n$ 的路径，所以不能删除第 $5$ 条边。\n\n#### 【数据范围】\n\n|  测试点编号  |    $n,m \\leq$   |     $q \\leq$    |            特殊限制           |\n|:------------:|:---------------:|:---------------:|:-------------------------------:|\n|  $1 \\sim 2$  |      $1000$     |      $1000$     |                无               |\n|  $3 \\sim 6$  |      $5000$     | $2 \\times 10^5$ |                无               |\n|  $7 \\sim 8$  | $2 \\times 10^5$ | $2 \\times 10^5$ | 保证所有询问中最多有 $1$ 条边没有被删除 |\n| $9 \\sim 12$ | $2 \\times 10^5$ | $2 \\times 10^5$ | 保证所有询问中最多有 $5$ 条边没有被删除 |\n| $13 \\sim 16$ | $2 \\times 10^5$ | $2 \\times 10^5$ |         将有向图视作无向图仍能得到正确答案        |\n| $17 \\sim 20$ | $2 \\times 10^5$ | $2 \\times 10^5$ |                无               |\n\n对于所有数据，$1 \\leq n,m,q \\leq 2 \\times 10^5$，给定的图无重边、自环，且存在一条 $1$ 到 $n$ 的路径。\n\n**给出的两组大样例分别满足测试点 1 和测试点 13 的限制。**", "locale": "zh-CN"}}}
{"pid": "P8861", "type": "P", "difficulty": 7, "samples": [["9 0\n1 1 5\n1 6 8\n1 2 3\n3 3 8\n2 4 6\n1 5 9\n2 2 7\n3 2 7\n3 3 6\n", "4\n4\n2\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "堆", "洛谷原创", "O2优化", "分治", "洛谷月赛"], "title": "线段", "background": "", "description": "有一个初始为空的线段集，你需要处理 $q$ 组询问，每组询问的格式为如下三种之一：\n\n1. 加入一条新线段 $[l_i,r_i]$。\n2. 将线段集里所有与 $[l_i,r_i]$ 相交的线段修改为其与 $[l_i,r_i]$ 的交。\n3. 求出线段集里所有与 $[l_i,r_i]$ 相交的线段与 $[l_i,r_i]$ 的交的长度和。\n\n两条线段 $[a,b],[c,d]$ 相交，当且仅当 $\\max\\{a,c\\} \\leq \\min\\{b,d\\}$，它们的交为 $[\\max\\{a,c\\},\\min\\{b,d\\}]$。\n\n一条线段 $[a,b]$ 的长度为 $b-a$。\n\n在部分测试点中，你需要**在线地**进行这些操作。\n\n**注意：在本题中，线段可能退化为单点。**", "inputFormat": "第一行两个正整数 $q$ 和 $type$，分别表示操作次数和强制在线参数。\n\n接下来 $q$ 行，每行三个正整数 $opt,l_i',r_i'$，其中 $opt$ 表示操作类型。\n\n我们记 $last$ 表示上一次 $3$ 询问的答案（$last$ 初始为 $0$），则真实的 $l_i = ( l_i' + type \\times last ) \\bmod ( 2 \\times 10^5 + 1 ), r_i = ( r_i' + type \\times last ) \\bmod ( 2 \\times 10^5 + 1 )$。\n\n数据保证 $1 \\leq l_i \\leq r_i \\leq 2 \\times 10^5$。", "outputFormat": "对于每个 $3$ 询问，输出一行表示答案。", "hint": "#### 【样例解释】\n\n每次操作后的线段集：\n\n- 第一次后：$\\{ [1,5] \\}$\n- 第二次后：$\\{ [1,5],[6,8] \\}$\n- 第三次后：$\\{ [1,5],[6,8],[2,3] \\}$\n- 第五次后：$\\{ [4,5],[6,6],[2,3] \\}$\n- 第六次后：$\\{ [4,5],[6,6],[2,3],[5,9] \\}$\n- 第七次后：$\\{ [4,5],[6,6],[2,3],[5,7] \\}$\n\n#### 【数据范围】\n\n记 $k_1,k_2,k_3$ 分别为 $opt=1,2,3$ 的询问个数。\n\n|    测试点编号    |    $k_1 \\leq$    |    $k_2 \\leq$    |    $k_3 \\leq$    | $type=$ |             特殊性质             |\n|:----------------:|:---------------:|:---------------:|:---------------:|:-------:|:--------------------------------:|\n|      $1 \\sim 2$  |      $100$      |      $100$      |      $100$      |   $=0$  |                无                |\n|      $3 \\sim 5$  |      $10^5$     |       $5$       | $3 \\times 10^5$ |   $=0$  |                无                |\n|      $6 \\sim 8$  |      $10^5$     |      $10^5$     |        $1$        |   $=0$  | 所有 $2$ 操作在所有 $1$ 操作之后 |\n|      $9 \\sim 12$ |      $10^5$     |      $10^5$     | $3 \\times 10^5$ |   $=0$  | 所有 $2$ 操作在所有 $1$ 操作之后 |\n|     $13 \\sim 17$ |      $10^5$     |      $10^5$     | $3 \\times 10^5$ |   $=0$  |     $l_i \\leq 10^5 \\leq r_i$     |\n|     $18 \\sim 20$ | $5 \\times 10^4$ | $5 \\times 10^4$ | $3 \\times 10^5$ |   $=0$  |                无                |\n|     $21 \\sim 25$ |      $10^5$     |      $10^5$     | $3 \\times 10^5$ |   $=1$  |                无                |\n\n对于所有数据，$1 \\leq q \\leq 5 \\times 10^5$, $k_3 \\geq 1$, $0 \\leq l_i',r_i' \\leq 2 \\times 10^5$, $1 \\leq l_i \\leq r_i \\leq 2 \\times 10^5$，$0 \\leq type \\leq1$，$1 \\leq opt \\leq 3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "线段", "background": "", "description": "有一个初始为空的线段集，你需要处理 $q$ 组询问，每组询问的格式为如下三种之一：\n\n1. 加入一条新线段 $[l_i,r_i]$。\n2. 将线段集里所有与 $[l_i,r_i]$ 相交的线段修改为其与 $[l_i,r_i]$ 的交。\n3. 求出线段集里所有与 $[l_i,r_i]$ 相交的线段与 $[l_i,r_i]$ 的交的长度和。\n\n两条线段 $[a,b],[c,d]$ 相交，当且仅当 $\\max\\{a,c\\} \\leq \\min\\{b,d\\}$，它们的交为 $[\\max\\{a,c\\},\\min\\{b,d\\}]$。\n\n一条线段 $[a,b]$ 的长度为 $b-a$。\n\n在部分测试点中，你需要**在线地**进行这些操作。\n\n**注意：在本题中，线段可能退化为单点。**", "inputFormat": "第一行两个正整数 $q$ 和 $type$，分别表示操作次数和强制在线参数。\n\n接下来 $q$ 行，每行三个正整数 $opt,l_i',r_i'$，其中 $opt$ 表示操作类型。\n\n我们记 $last$ 表示上一次 $3$ 询问的答案（$last$ 初始为 $0$），则真实的 $l_i = ( l_i' + type \\times last ) \\bmod ( 2 \\times 10^5 + 1 ), r_i = ( r_i' + type \\times last ) \\bmod ( 2 \\times 10^5 + 1 )$。\n\n数据保证 $1 \\leq l_i \\leq r_i \\leq 2 \\times 10^5$。", "outputFormat": "对于每个 $3$ 询问，输出一行表示答案。", "hint": "#### 【样例解释】\n\n每次操作后的线段集：\n\n- 第一次后：$\\{ [1,5] \\}$\n- 第二次后：$\\{ [1,5],[6,8] \\}$\n- 第三次后：$\\{ [1,5],[6,8],[2,3] \\}$\n- 第五次后：$\\{ [4,5],[6,6],[2,3] \\}$\n- 第六次后：$\\{ [4,5],[6,6],[2,3],[5,9] \\}$\n- 第七次后：$\\{ [4,5],[6,6],[2,3],[5,7] \\}$\n\n#### 【数据范围】\n\n记 $k_1,k_2,k_3$ 分别为 $opt=1,2,3$ 的询问个数。\n\n|    测试点编号    |    $k_1 \\leq$    |    $k_2 \\leq$    |    $k_3 \\leq$    | $type=$ |             特殊性质             |\n|:----------------:|:---------------:|:---------------:|:---------------:|:-------:|:--------------------------------:|\n|      $1 \\sim 2$  |      $100$      |      $100$      |      $100$      |   $=0$  |                无                |\n|      $3 \\sim 5$  |      $10^5$     |       $5$       | $3 \\times 10^5$ |   $=0$  |                无                |\n|      $6 \\sim 8$  |      $10^5$     |      $10^5$     |        $1$        |   $=0$  | 所有 $2$ 操作在所有 $1$ 操作之后 |\n|      $9 \\sim 12$ |      $10^5$     |      $10^5$     | $3 \\times 10^5$ |   $=0$  | 所有 $2$ 操作在所有 $1$ 操作之后 |\n|     $13 \\sim 17$ |      $10^5$     |      $10^5$     | $3 \\times 10^5$ |   $=0$  |     $l_i \\leq 10^5 \\leq r_i$     |\n|     $18 \\sim 20$ | $5 \\times 10^4$ | $5 \\times 10^4$ | $3 \\times 10^5$ |   $=0$  |                无                |\n|     $21 \\sim 25$ |      $10^5$     |      $10^5$     | $3 \\times 10^5$ |   $=1$  |                无                |\n\n对于所有数据，$1 \\leq q \\leq 5 \\times 10^5$, $k_3 \\geq 1$, $0 \\leq l_i',r_i' \\leq 2 \\times 10^5$, $1 \\leq l_i \\leq r_i \\leq 2 \\times 10^5$，$0 \\leq type \\leq1$，$1 \\leq opt \\leq 3$。", "locale": "zh-CN"}}}
{"pid": "P8862", "type": "P", "difficulty": 5, "samples": [["1\n5 3\n1 2 3 4 5\n2 3 5\n1 3 4 2\n2 1 1\n20 2 5 6 5\n", "3 20"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "2022", "洛谷原创", "Special Judge", "O2优化", "构造"], "title": "「KDOI-03」还原数据", "background": "", "description": "小 E 正在做一道经典题：\n\n给定一个长度为 $n$ 的序列 $a$ 和 $q$ 个操作，操作共有 $2$ 种类型：\n\n+ $\\tt{1~l~r~x}$：对于所有 $l\\le i\\le r$，$a_i\\leftarrow a_i+x$。\n+ $\\tt{2~l~r~x}$：对于所有 $l\\le i\\le r$，$a_i\\leftarrow \\max(a_i,x)$。\n\n题目要求输出所有操作结束后的最终序列 $a'$。\n\n小 E 迅速写了一份代码提交，但是发现，由于宇宙射线的影响，输入数据出现了一些小问题。具体地，对于所有 $2$ 操作，操作中给出的 $x$ 均被丢失了，也就是说，输入数据中的 $2$ 操作只剩下了 $\\tt{2~l~r}$。输出数据则没有问题。小 E 现在想要通过剩余的数据恢复原来的输入数据，请你帮助他完成这个任务。\n\n当然，可能会有多种合法的输入数据，你需要找到其中任意一种。数据保证有解。", "inputFormat": "从标准输入读入数据。\n\n**本题有多组测试数据。**\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组测试数据，第一行两个非负整数 $n,q$。\n\n第二行 $n$ 个整数，表示初始序列 $a_1,a_2,\\ldots,a_n$。\n\n接下来 $q$ 行，每行一次操作，形如 $\\tt{1~l~r~x}$ 或 $\\tt{2~l~r}$。\n\n接下来一行 $n$ 个整数，表示最终序列 $a_1',a_2',\\ldots,a_n'$。", "outputFormat": "输出到标准输出。\n\n**本题开启自定义校验器（Special Judge）。**\n\n对于每组测试数据，设共有 $q_2$ 个 $2$ 操作，输出一行 $q_2$ 个整数，第 $i$ 个整数表示第 $i$ 次 $2$ 操作中所给出的 $x$ 的值。\n\n你需要保证 $-10^{15}\\le x\\le 10^{15}$。", "hint": "**【样例 1 解释】**\n\n所有合法输出需要满足：第 $1$ 个数 $\\le3$，第 $2$ 个数恰好为 $20$。\n\n**【样例 2】**\n\n见选手文件中的 `restore/restore2.in` 与 `restore/restore2.ans`。\n\n**【样例 3】**\n\n见选手文件中的 `restore/restore3.in` 与 `restore/restore3.ans`。\n\n\n***\n\n**【数据范围】**\n\n记 $q_2$ 为单组数据内 $2$ 操作的个数，$\\sum n$ 为单个测试点内所有 $n$ 的和，$\\sum q$ 为单个测试点内所有 $q$ 的和。\n\n对于 $20\\%$ 的数据，保证 $n,q\\le50$，$\\sum n,\\sum q\\le1~000$。\n\n对于 $40\\%$ 的数据，保证 $n,q\\le1~000$，$\\sum n,\\sum q\\le10^5$。\n\n对于另外 $20\\%$ 的数据，保证 $l=1,r=n$。\n\n对于另外 $20\\%$ 的数据，保证 $q_2\\le100$。\n\n对于 $100\\%$ 的数据，保证 $1\\le T\\le 100$，$1\\le n,q\\le 10^5$，$1\\le\\sum n,\\sum q\\le 3\\times10^5$，$-10^9\\le a_i,x\\le 10^9$，$-10^{15}\\le a_i'\\le10^{15}$， $q_2\\ge1$。\n\n\n***\n\n**【校验器】**\n\n\n本题样例文件较大，无法在附件中下载，请在选手文件中查看。\n\n为了方便测试，在 $\\texttt{restore}$ 目录下我们下发了 $\\texttt{checker.cpp}$ 文件。你可以编译该文件，并使用它校验自己的输出文件。请注意它与最终评测时所用的校验器并不完全一致，你不需要也不应该关心其代码的具体内容。\n\n编译命令为：\n\n```plain\ng++ checker.cpp -o checker -std=c++14\n```\n\n使用方式为：\n\n```\n./checker <inputfile> <outputfile> <answerfile>\n```\n\n校验器可能会返回以下状态中的其中一种：\n\n+ $\\tt{Accepted}$：表示你的输出完全正确。\n+ $\\tt{Wrong~answer~at~testcase~ x}$：表示你的输出在第 $x$ 个测试数据出错。\n\n***\n\n**【提示】**\n\n本题输入输出量较大，推荐使用较快的输入输出方式。\n\nKDOI 出题组温馨提示：**多测不清空，爆零两行泪。**\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KDOI-03」还原数据", "background": "", "description": "小 E 正在做一道经典题：\n\n给定一个长度为 $n$ 的序列 $a$ 和 $q$ 个操作，操作共有 $2$ 种类型：\n\n+ $\\tt{1~l~r~x}$：对于所有 $l\\le i\\le r$，$a_i\\leftarrow a_i+x$。\n+ $\\tt{2~l~r~x}$：对于所有 $l\\le i\\le r$，$a_i\\leftarrow \\max(a_i,x)$。\n\n题目要求输出所有操作结束后的最终序列 $a'$。\n\n小 E 迅速写了一份代码提交，但是发现，由于宇宙射线的影响，输入数据出现了一些小问题。具体地，对于所有 $2$ 操作，操作中给出的 $x$ 均被丢失了，也就是说，输入数据中的 $2$ 操作只剩下了 $\\tt{2~l~r}$。输出数据则没有问题。小 E 现在想要通过剩余的数据恢复原来的输入数据，请你帮助他完成这个任务。\n\n当然，可能会有多种合法的输入数据，你需要找到其中任意一种。数据保证有解。", "inputFormat": "从标准输入读入数据。\n\n**本题有多组测试数据。**\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组测试数据，第一行两个非负整数 $n,q$。\n\n第二行 $n$ 个整数，表示初始序列 $a_1,a_2,\\ldots,a_n$。\n\n接下来 $q$ 行，每行一次操作，形如 $\\tt{1~l~r~x}$ 或 $\\tt{2~l~r}$。\n\n接下来一行 $n$ 个整数，表示最终序列 $a_1',a_2',\\ldots,a_n'$。", "outputFormat": "输出到标准输出。\n\n**本题开启自定义校验器（Special Judge）。**\n\n对于每组测试数据，设共有 $q_2$ 个 $2$ 操作，输出一行 $q_2$ 个整数，第 $i$ 个整数表示第 $i$ 次 $2$ 操作中所给出的 $x$ 的值。\n\n你需要保证 $-10^{15}\\le x\\le 10^{15}$。", "hint": "**【样例 1 解释】**\n\n所有合法输出需要满足：第 $1$ 个数 $\\le3$，第 $2$ 个数恰好为 $20$。\n\n**【样例 2】**\n\n见选手文件中的 `restore/restore2.in` 与 `restore/restore2.ans`。\n\n**【样例 3】**\n\n见选手文件中的 `restore/restore3.in` 与 `restore/restore3.ans`。\n\n\n***\n\n**【数据范围】**\n\n记 $q_2$ 为单组数据内 $2$ 操作的个数，$\\sum n$ 为单个测试点内所有 $n$ 的和，$\\sum q$ 为单个测试点内所有 $q$ 的和。\n\n对于 $20\\%$ 的数据，保证 $n,q\\le50$，$\\sum n,\\sum q\\le1~000$。\n\n对于 $40\\%$ 的数据，保证 $n,q\\le1~000$，$\\sum n,\\sum q\\le10^5$。\n\n对于另外 $20\\%$ 的数据，保证 $l=1,r=n$。\n\n对于另外 $20\\%$ 的数据，保证 $q_2\\le100$。\n\n对于 $100\\%$ 的数据，保证 $1\\le T\\le 100$，$1\\le n,q\\le 10^5$，$1\\le\\sum n,\\sum q\\le 3\\times10^5$，$-10^9\\le a_i,x\\le 10^9$，$-10^{15}\\le a_i'\\le10^{15}$， $q_2\\ge1$。\n\n\n***\n\n**【校验器】**\n\n\n本题样例文件较大，无法在附件中下载，请在选手文件中查看。\n\n为了方便测试，在 $\\texttt{restore}$ 目录下我们下发了 $\\texttt{checker.cpp}$ 文件。你可以编译该文件，并使用它校验自己的输出文件。请注意它与最终评测时所用的校验器并不完全一致，你不需要也不应该关心其代码的具体内容。\n\n编译命令为：\n\n```plain\ng++ checker.cpp -o checker -std=c++14\n```\n\n使用方式为：\n\n```\n./checker <inputfile> <outputfile> <answerfile>\n```\n\n校验器可能会返回以下状态中的其中一种：\n\n+ $\\tt{Accepted}$：表示你的输出完全正确。\n+ $\\tt{Wrong~answer~at~testcase~ x}$：表示你的输出在第 $x$ 个测试数据出错。\n\n***\n\n**【提示】**\n\n本题输入输出量较大，推荐使用较快的输入输出方式。\n\nKDOI 出题组温馨提示：**多测不清空，爆零两行泪。**\n", "locale": "zh-CN"}}}
{"pid": "P8863", "type": "P", "difficulty": 6, "samples": [["4\n2 2 2 2", "90"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2022", "洛谷原创", "O2优化", "动态规划优化", "组合数学"], "title": "「KDOI-03」构造数组", "background": null, "description": "你现在有一个长度为 $n$ 的数组 $a$。一开始，所有 $a_i$ 均为 $0$。给出一个同样长度为 $n$ 的目标数组 $b$。求有多少种方案，使得通过若干次以下操作，可以让 $a$ 数组变成 $b$。\n\n* 选出两个**不同的**下标 $1\\leq i<j\\leq n$，并将 $a_i$ 和 $a_j$ 同时增加 $1$。\n\n两种方案被称之为不同的，当且仅当存在一个 $x$ 使得一种方案中第 $x$ 次操作选择的两个下标 $(i,j)$ 与另一种方案中的不同。\n\n**答案对 $\\bm{998244353}$ 取模。**", "inputFormat": "从标准输入读入数据。\n\n输入数据一共包含两行。\n\n第一行包含一个正整数 $n$。\n\n第二行包含 $n$ 个正整数，表示 $b_1,b_2,\\ldots,b_n$。", "outputFormat": "输出到标准输出。\n\n输出一行一个正整数，表示将 $a$ 数组通过若干次操作变成 $b$ 数组的方案数对 $998244353$ 取模后的结果。", "hint": "**【样例 1 解释】**\n\n| 种类编号 | 第一组 | 第二组 | 第三组 | 第四组 | 方案数 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | `1<->2` | `1<->2` | `3<->4` | `3<->4` | $\\binom{4}{2}=6$ |\n| $2$ | `1<->3` | `1<->3` | `2<->4` | `2<->4` | $\\binom{4}{2}=6$ |\n| $3$ | `1<->4` | `1<->4` | `2<->3` | `2<->3` | $\\binom{4}{2}=6$ |\n| $4$ | `1<->2` | `1<->4` | `2<->3` | `3<->4` | $4!=24$ |\n| $5$ | `1<->2` | `1<->3` | `2<->4` | `3<->4` | $4!=24$ |\n| $6$ | `1<->3` | `1<->4` | `2<->3` | `2<->4` | $4!=24$ |\n\n总方案数是 $6\\times3+24\\times3=90$。\n\n**【样例 2】**\n\n见选手文件中的 `array/array2.in` 与 `array/array2.ans`。\n\n此样例满足测试点 $6\\sim8$ 的限制。\n\n**【样例 3】**\n\n见选手文件中的 `array/array3.in` 与 `array/array3.ans`。\n\n此样例满足测试点 $12\\sim14$ 的限制。\n\n**【样例 4】**\n\n见选手文件中的 `array/array4.in` 与 `array/array4.ans`。\n\n此样例满足测试点 $15\\sim18$ 的限制。\n\n**【样例 5】**\n\n见选手文件中的 `array/array5.in` 与 `array/array5.ans`。\n\n此样例满足测试点 $19\\sim20$ 的限制。\n\n**【样例 6】**\n\n见选手文件中的 `array/array6.in` 与 `array/array6.ans`。\n\n此样例满足测试点 $21\\sim22$ 的限制。\n\n**【样例 7】**\n\n见选手文件中的 `array/array7.in` 与 `array/array7.ans`。\n\n此样例满足测试点 $23\\sim25$ 的限制。\n\n***\n\n**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le n\\le5~000$，$1\\leq b_i\\le3 \\times 10^4$，$\\sum b_i\\le3 \\times 10^4$。\n\n| 测试点编号 | $n$ | $\\sum b_i$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $\\leq5~000$ | $\\equiv 1\\pmod 2$ |\n| $2\\sim3$ | $=1$ | $\\leq3 \\times 10^4$ |\n| $4\\sim5$ | $=2$ | $\\leq3 \\times 10^4$ |\n| $6\\sim8$ | $\\leq5$ | $\\leq8$ |\n| $9\\sim11$ | $\\leq20$ | $=n$ |\n| $12\\sim14$ | $\\leq 5~000$ | $=n$ |\n| $15\\sim18$ | $\\leq16$ | $\\leq16$ |\n| $19\\sim20$ | $\\le 700$ | $\\le700$ |\n| $21\\sim22$ | $\\le 5~000$ | $\\le5~000$ |\n| $23\\sim25$ | $\\le5~000$ | $\\le3 \\times 10^4$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KDOI-03」构造数组", "background": null, "description": "你现在有一个长度为 $n$ 的数组 $a$。一开始，所有 $a_i$ 均为 $0$。给出一个同样长度为 $n$ 的目标数组 $b$。求有多少种方案，使得通过若干次以下操作，可以让 $a$ 数组变成 $b$。\n\n* 选出两个**不同的**下标 $1\\leq i<j\\leq n$，并将 $a_i$ 和 $a_j$ 同时增加 $1$。\n\n两种方案被称之为不同的，当且仅当存在一个 $x$ 使得一种方案中第 $x$ 次操作选择的两个下标 $(i,j)$ 与另一种方案中的不同。\n\n**答案对 $\\bm{998244353}$ 取模。**", "inputFormat": "从标准输入读入数据。\n\n输入数据一共包含两行。\n\n第一行包含一个正整数 $n$。\n\n第二行包含 $n$ 个正整数，表示 $b_1,b_2,\\ldots,b_n$。", "outputFormat": "输出到标准输出。\n\n输出一行一个正整数，表示将 $a$ 数组通过若干次操作变成 $b$ 数组的方案数对 $998244353$ 取模后的结果。", "hint": "**【样例 1 解释】**\n\n| 种类编号 | 第一组 | 第二组 | 第三组 | 第四组 | 方案数 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | `1<->2` | `1<->2` | `3<->4` | `3<->4` | $\\binom{4}{2}=6$ |\n| $2$ | `1<->3` | `1<->3` | `2<->4` | `2<->4` | $\\binom{4}{2}=6$ |\n| $3$ | `1<->4` | `1<->4` | `2<->3` | `2<->3` | $\\binom{4}{2}=6$ |\n| $4$ | `1<->2` | `1<->4` | `2<->3` | `3<->4` | $4!=24$ |\n| $5$ | `1<->2` | `1<->3` | `2<->4` | `3<->4` | $4!=24$ |\n| $6$ | `1<->3` | `1<->4` | `2<->3` | `2<->4` | $4!=24$ |\n\n总方案数是 $6\\times3+24\\times3=90$。\n\n**【样例 2】**\n\n见选手文件中的 `array/array2.in` 与 `array/array2.ans`。\n\n此样例满足测试点 $6\\sim8$ 的限制。\n\n**【样例 3】**\n\n见选手文件中的 `array/array3.in` 与 `array/array3.ans`。\n\n此样例满足测试点 $12\\sim14$ 的限制。\n\n**【样例 4】**\n\n见选手文件中的 `array/array4.in` 与 `array/array4.ans`。\n\n此样例满足测试点 $15\\sim18$ 的限制。\n\n**【样例 5】**\n\n见选手文件中的 `array/array5.in` 与 `array/array5.ans`。\n\n此样例满足测试点 $19\\sim20$ 的限制。\n\n**【样例 6】**\n\n见选手文件中的 `array/array6.in` 与 `array/array6.ans`。\n\n此样例满足测试点 $21\\sim22$ 的限制。\n\n**【样例 7】**\n\n见选手文件中的 `array/array7.in` 与 `array/array7.ans`。\n\n此样例满足测试点 $23\\sim25$ 的限制。\n\n***\n\n**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le n\\le5~000$，$1\\leq b_i\\le3 \\times 10^4$，$\\sum b_i\\le3 \\times 10^4$。\n\n| 测试点编号 | $n$ | $\\sum b_i$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $\\leq5~000$ | $\\equiv 1\\pmod 2$ |\n| $2\\sim3$ | $=1$ | $\\leq3 \\times 10^4$ |\n| $4\\sim5$ | $=2$ | $\\leq3 \\times 10^4$ |\n| $6\\sim8$ | $\\leq5$ | $\\leq8$ |\n| $9\\sim11$ | $\\leq20$ | $=n$ |\n| $12\\sim14$ | $\\leq 5~000$ | $=n$ |\n| $15\\sim18$ | $\\leq16$ | $\\leq16$ |\n| $19\\sim20$ | $\\le 700$ | $\\le700$ |\n| $21\\sim22$ | $\\le 5~000$ | $\\le5~000$ |\n| $23\\sim25$ | $\\le5~000$ | $\\le3 \\times 10^4$ |", "locale": "zh-CN"}}}
{"pid": "P8864", "type": "P", "difficulty": 7, "samples": [["5 1 2\n1 1 1 0 1\n2 3\n1 3", "1\n1"], ["20 3 22\n0 0 1 1 1 1 1 0 0 0 0 0 1 0 1 0 0 1 0 1 \n12 15\n1 6\n5 10\n2 5\n9 18\n6 17\n2 13\n4 16\n2 8\n9 19\n10 15\n7 15\n1 3\n14 18\n6 17\n12 14\n7 16\n14 18\n11 12\n3 5\n3 6\n3 15\n", "0\n1\n0\n0\n0\n6\n3\n5\n1\n0\n0\n0\n0\n0\n6\n0\n0\n0\n0\n0\n1\n3\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2022", "洛谷原创", "O2优化", "动态规划优化", "矩阵加速", "四边形不等式"], "title": "「KDOI-03」序列变换", "background": "", "description": "给定一个长度为 $n$ 的 $\\tt01$ 序列 $a$ 和 $q$ 次询问，询问参数 $k$。\n\n每次询问给定 $L,R$，其中 $1\\leq L\\leq R\\leq n$，你可以进行如下操作：\n\n+ 选择一个下标 $L<i\\le R$；\n+ 将 $a_{i-1}$ 赋值为 $a_{i-1}\\oplus a_i$，$a_{i+1}$  赋值为 $a_{i+1}\\oplus a_i$。如果 $i=n$，则不对 $a_{i+1}$ 作出改变。其中 $\\oplus$ 表示按位异或运算。\n\n求使得 $[L,R]$ 区间内**至多**有 $k$ 个 $\\tt1$ 的最小操作次数。询问之间相互独立，也就是说，每次询问后重置为初始序列。", "inputFormat": "从标准输入读入数据。\n\n第一行包含三个正整数 $n,k,q$。\n\n第二行包含 $n$ 个非负整数 $a_1,a_2,\\cdots,a_n$。\n\n接下来 $q$ 行，每行包含两个正整数 $L,R$，表示一次询问。", "outputFormat": "输出到标准输出。\n\n输出共 $q$ 行，每行包含一个整数，表示答案。", "hint": "**【样例 1 解释】**\n\n如图，用绿色代表 $\\tt0$，红色代表 $\\tt1$，初始序列如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hxw9knxu.png)\n\n对于第 $1$ 次询问，选择 $i=3$，则序列变为下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zvb2lfi8.png)\n\n对于第 $2$ 次询问，选择 $i=2$，则序列变为下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wubvxvaa.png)\n\n**【样例 2 解释】**\n\n对于第 $1$ 次询问，由于 $a_{12},a_{13},a_{14},a_{15}$ 中只有 $2$ 个 $\\tt1$，所以不需要进行任何操作。\n\n对于第 $6$ 次询问，可以依次选择 $i=\\{7,8,9,10,11,12\\}$。\n\n**【样例 3】**\n\n见选手文件中的 `control/control3.in` 与 `control/control3.ans`。\n\n此样例满足测试点 $7\\sim10$ 的限制。\n\n**【样例 4】**\n\n见选手文件中的 `control/control4.in` 与 `control/control4.ans`。\n\n此样例满足测试点 $15\\sim17$ 的限制。\n\n**【样例 5】**\n\n见选手文件中的 `control/control5.in` 与 `control/control5.ans`。\n\n此样例满足测试点 $18\\sim21$ 的限制。\n\n***\n\n**【数据范围】**\n\n对于 $100\\%$ 的数据， $2\\le n\\le 3~000$，$1\\le k\\le \n\\min(n,1~000)$，$1\\le q\\le 5\\times10^5$，$0\\le a_i\\le 1$。\n\n\n|测试点编号|$n\\le$|$k\\le$|$q\\le$|特殊性质|\n|:--:|:--:|:--:|:--:|:--:|\n|$1\\sim3$|$80$|$50$|$2~000$|无|\n|$4\\sim6$|$400$|$300$|$1$|$k$ 是偶数|\n|$7\\sim10$|$400$|$2$|$10~000$|无|\n|$11\\sim14$|$400$|$300$|$10~000$|无|\n|$15\\sim17$|$3~000$|$10$|$5\\times10^5$|无|\n|$18\\sim21$|$3~000$|$1~000$|$5\\times10^5$|$k$ 是偶数|\n|$22\\sim25$|$3~000$|$1~000$|$5\\times10^5$|无|\n\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KDOI-03」序列变换", "background": "", "description": "给定一个长度为 $n$ 的 $\\tt01$ 序列 $a$ 和 $q$ 次询问，询问参数 $k$。\n\n每次询问给定 $L,R$，其中 $1\\leq L\\leq R\\leq n$，你可以进行如下操作：\n\n+ 选择一个下标 $L<i\\le R$；\n+ 将 $a_{i-1}$ 赋值为 $a_{i-1}\\oplus a_i$，$a_{i+1}$  赋值为 $a_{i+1}\\oplus a_i$。如果 $i=n$，则不对 $a_{i+1}$ 作出改变。其中 $\\oplus$ 表示按位异或运算。\n\n求使得 $[L,R]$ 区间内**至多**有 $k$ 个 $\\tt1$ 的最小操作次数。询问之间相互独立，也就是说，每次询问后重置为初始序列。", "inputFormat": "从标准输入读入数据。\n\n第一行包含三个正整数 $n,k,q$。\n\n第二行包含 $n$ 个非负整数 $a_1,a_2,\\cdots,a_n$。\n\n接下来 $q$ 行，每行包含两个正整数 $L,R$，表示一次询问。", "outputFormat": "输出到标准输出。\n\n输出共 $q$ 行，每行包含一个整数，表示答案。", "hint": "**【样例 1 解释】**\n\n如图，用绿色代表 $\\tt0$，红色代表 $\\tt1$，初始序列如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hxw9knxu.png)\n\n对于第 $1$ 次询问，选择 $i=3$，则序列变为下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zvb2lfi8.png)\n\n对于第 $2$ 次询问，选择 $i=2$，则序列变为下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wubvxvaa.png)\n\n**【样例 2 解释】**\n\n对于第 $1$ 次询问，由于 $a_{12},a_{13},a_{14},a_{15}$ 中只有 $2$ 个 $\\tt1$，所以不需要进行任何操作。\n\n对于第 $6$ 次询问，可以依次选择 $i=\\{7,8,9,10,11,12\\}$。\n\n**【样例 3】**\n\n见选手文件中的 `control/control3.in` 与 `control/control3.ans`。\n\n此样例满足测试点 $7\\sim10$ 的限制。\n\n**【样例 4】**\n\n见选手文件中的 `control/control4.in` 与 `control/control4.ans`。\n\n此样例满足测试点 $15\\sim17$ 的限制。\n\n**【样例 5】**\n\n见选手文件中的 `control/control5.in` 与 `control/control5.ans`。\n\n此样例满足测试点 $18\\sim21$ 的限制。\n\n***\n\n**【数据范围】**\n\n对于 $100\\%$ 的数据， $2\\le n\\le 3~000$，$1\\le k\\le \n\\min(n,1~000)$，$1\\le q\\le 5\\times10^5$，$0\\le a_i\\le 1$。\n\n\n|测试点编号|$n\\le$|$k\\le$|$q\\le$|特殊性质|\n|:--:|:--:|:--:|:--:|:--:|\n|$1\\sim3$|$80$|$50$|$2~000$|无|\n|$4\\sim6$|$400$|$300$|$1$|$k$ 是偶数|\n|$7\\sim10$|$400$|$2$|$10~000$|无|\n|$11\\sim14$|$400$|$300$|$10~000$|无|\n|$15\\sim17$|$3~000$|$10$|$5\\times10^5$|无|\n|$18\\sim21$|$3~000$|$1~000$|$5\\times10^5$|$k$ 是偶数|\n|$22\\sim25$|$3~000$|$1~000$|$5\\times10^5$|无|\n\n\n", "locale": "zh-CN"}}}
{"pid": "P8865", "type": "P", "difficulty": 4, "samples": [["1 0\n4 3 1 1\n001\n010\n000\n000", "4 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2022", "NOIP 提高组", "O2优化", "枚举", "组合数学", "前缀和"], "title": "[NOIP2022] 种花", "background": "", "description": "小 C 决定在他的花园里种出 $\\texttt{CCF}$ 字样的图案，因此他想知道 $\\texttt C$ 和 $\\texttt F$ 两个字母各自有多少种种花的方案；不幸的是，花园中有一些土坑，这些位置无法种花，因此他希望你能帮助他解决这个问题。\n\n花园可以看作有 $n\\times m$ 个位置的网格图，从上到下分别为第 $1$ 到第 $n$ 行，从左到右分别为第 $1$ 列到第 $m$ 列，其中每个位置有可能是土坑，也有可能不是，可以用 $a_{i,j} = 1$ 表示第 $i$ 行第 $j$ 列这个位置有土坑，否则用 $a_{i,j} = 0$ 表示这个位置没土坑。\n\n一种种花方案被称为 $\\texttt{C-}$ **形**的，如果存在 $x_1, x_2 \\in [1, n]$，以及 $y_0, y_1, y_2 \\in [1, m]$，满足 $x_1 + 1 < x_2$，并且 $y_0 < y_1, y_2 \\leq m$，使得第 $x_1$ **行**的第 $y_0$ 到第 $y_1$ **列**、第 $x_2$ **行**的第 $y_0$ 到第 $y_2$ **列**以及第 $y_0$ **列**的第 $x_1$ 到第 $x_2$ **行**都**不为土坑**，且只在上述这些位置上种花。\n\n一种种花方案被称为 $\\texttt{F-}$ **形**的，如果存在 $x_1, x_2, x_3 \\in [1, n]$，以及 $y_0, y_1, y_2 \\in [1, m]$，满足 $x_1 + 1 < x_2 < x_3$，并且 $y_0 < y_1, y_2 \\leq m$，使得第 $x_1$ **行**的第 $y_0$ 到第 $y_1$ **列**、第 $x_2$ **行**的第 $y_0$ 到第 $y_2$ **列**以及第 $y_0$ **列**的第 $x_1$ 到第 $x_3$ **行**都**不为土坑**，且只在上述这些位置上种花。\n\n样例一解释中给出了 $\\texttt{C-}$ 形和 $\\texttt{F-}$ 形种花方案的图案示例。\n\n现在小 C 想知道，给定 $n, m$ 以及表示每个位置是否为土坑的值 $\\{a_{i,j}\\}$，$\\texttt{C-}$ 形和 $\\texttt{F-}$ 形种花方案分别有多少种可能？由于答案可能非常之大，你只需要输出其对 $998244353$ 取模的结果即可，具体输出结果请看输出格式部分。", "inputFormat": "第一行包含两个整数 $T, id$，分别表示数据组数和测试点编号。如果数据为样例则保证 $id = 0$。\n\n接下来一共 $T$ 组数据，在每组数据中：\n\n第一行包含四个整数 $n, m, c, f$，其中 $n, m$ 分别表示花园的行数、列数，对于 $c, f$ 的含义见输出格式部分。\n\n接下来 $n$ 行，每行包含一个长度为 $m$ 且仅包含 $0$ 和 $1$ 的字符串，其中第 $i$ 个串的第 $j$ 个字符表示 $a_{i,j}$，即花园里的第 $i$ 行第 $j$ 列是不是一个土坑。", "outputFormat": "设花园中 $\\texttt{C-}$ 形和 $\\texttt{F-}$ 形的种花方案分别有 $V_C$ 和 $V_F$ 种，则你需要对每一组数据输出一行用一个空格隔开的两个非负整数，分别表示 $(c \\times V_C) \\bmod 998244353$，$(f \\times V_F ) \\bmod 998244353$ ，其中 $a \\bmod P$ 表示 $a$ 对 $P$ 取模后的结果。", "hint": "**【样例 1 解释】**\n\n四个 $\\texttt{C-}$ 形种花方案为：\n\n```plain\n**1 **1 **1 **1\n*10 *10 *10 *10\n**0 *** *00 *00\n000 000 **0 ***\n```\n\n其中 $\\texttt*$ 表示在这个位置种花。注意 $\\texttt C$ 的两横可以不一样长。\n\n类似的，两个 $\\texttt{F-}$ 形种花方案为：\n\n```plain\n**1 **1\n*10 *10\n**0 ***\n*00 *00\n```\n\n**【样例 2】**\n\n见附件下的 $\\texttt{plant/plant2.in}$ 与 $\\texttt{plant/plant2.ans}$。\n\n**【样例 3】**\n\n见附件下的 $\\texttt{plant/plant3.in}$ 与 $\\texttt{plant/plant3.ans}$。\n\n**【数据范围】**\n\n对于所有数据，保证：$1 \\leq T \\leq 5$，$1 \\leq n, m \\leq 10^3$，$0 \\leq c, f \\leq 1$，$a_{i,j} \\in \\{0, 1\\}$。\n\n| 测试点编号 | $n$ | $m$ | $c=$ | $f=$ | 特殊性质 | 测试点分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\leq 1000$ | $\\leq 1000$ | $0$ | $0$ | 无 | $1$ |\n| $2$ | $=3$ | $=2$ | $1$ | $1$ | 无 | $2$ |\n| $3$ | $=4$ | $=2$ | $1$ | $1$ | 无 | $3$ |\n| $4$ | $\\leq 1000$ | $=2$ | $1$ | $1$ | 无 | $4$ |\n| $5$ | $\\leq 1000$ | $\\leq 1000$ | $1$ | $1$ | A | $4$ |\n| $6$ | $\\leq 1000$ | $\\leq 1000$ | $1$ | $1$ | B | $6$ |\n| $7$ | $\\leq 10$ | $\\leq 10$ | $1$ | $1$ | 无 | $10$ |\n| $8$ | $\\leq 20$ | $\\leq 20$ | $1$ | $1$ | 无 | $6$ |\n| $9$ | $\\leq 30$ | $\\leq 30$ | $1$ | $1$ | 无 | $6$ |\n| $10$ | $\\leq 50$ | $\\leq 50$ | $1$ | $1$ | 无 | $8$ |\n| $11$ | $\\leq 100$ | $\\leq 100$ | $1$ | $1$ | 无 | $10$ |\n| $12$ | $\\leq 200$ | $\\leq 200$ | $1$ | $1$ | 无 | $6$ |\n| $13$ | $\\leq 300$ | $\\leq 300$ | $1$ | $1$ | 无 | $6$ |\n| $14$ | $\\leq 500$ | $\\leq 500$ | $1$ | $1$ | 无 | $8$ |\n| $15$ | $\\leq 1000$ | $\\leq 1000$ | $1$ | $0$ | 无 | $6$ |\n| $16$ | $\\leq 1000$ | $\\leq 1000$ | $1$ | $1$ | 无 | $14$ |\n\n特殊性质 A：$\\forall 1 \\leq i \\leq n, 1 \\leq j \\leq \\left\\lfloor \\frac{m}{3} \\right\\rfloor$，$a_{i, 3 j} = 1$；\n\n特殊性质 B：$\\forall 1 \\leq i \\leq \\left\\lfloor \\frac{n}{4} \\right\\rfloor, 1 \\leq j \\leq m$，$a_{4 i, j} = 1$；", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP2022] Planting Flowers", "background": "", "description": "Xiao C decides to plant a pattern of the letters $\\texttt{CCF}$ in his garden, so he wants to know how many planting schemes there are for the letters $\\texttt C$ and $\\texttt F$ respectively. Unfortunately, there are some pits in the garden where flowers cannot be planted, so he hopes you can help solve this problem.\n\nThe garden can be viewed as a grid with $n \\times m$ positions, with rows numbered $1$ to $n$ from top to bottom, and columns numbered $1$ to $m$ from left to right. Each position may be a pit or not. Use $a_{i,j} = 1$ to indicate that there is a pit at row $i$, column $j$, and use $a_{i,j} = 0$ otherwise.\n\nA planting scheme is called $\\texttt{C-}$ shaped if there exist $x_1, x_2 \\in [1, n]$ and $y_0, y_1, y_2 \\in [1, m]$, satisfying $x_1 + 1 < x_2$ and $y_0 < y_1, y_2 \\leq m$, such that the segments from columns $y_0$ to $y_1$ on row $x_1$, from columns $y_0$ to $y_2$ on row $x_2$, and from rows $x_1$ to $x_2$ on column $y_0$ are all not pits, and flowers are planted only on these positions.\n\nA planting scheme is called $\\texttt{F-}$ shaped if there exist $x_1, x_2, x_3 \\in [1, n]$ and $y_0, y_1, y_2 \\in [1, m]$, satisfying $x_1 + 1 < x_2 < x_3$ and $y_0 < y_1, y_2 \\leq m$, such that the segments from columns $y_0$ to $y_1$ on row $x_1$, from columns $y_0$ to $y_2$ on row $x_2$, and from rows $x_1$ to $x_3$ on column $y_0$ are all not pits, and flowers are planted only on these positions.\n\nExamples of $\\texttt{C-}$ shaped and $\\texttt{F-}$ shaped planting schemes are shown in the explanation of Sample 1.\n\nNow Xiao C wants to know, given $n$, $m$, and the values $\\{a_{i,j}\\}$ indicating whether each position is a pit, how many possible $\\texttt{C-}$ shaped and $\\texttt{F-}$ shaped planting schemes there are, respectively. Since the answer may be very large, you only need to output the result modulo $998244353$. See the output format section for details.", "inputFormat": "The first line contains two integers $T, id$, denoting the number of test cases and the test point ID, respectively. If the input is a sample, it is guaranteed that $id = 0$.\n\nThen there are $T$ test cases. In each test case:\n\n- The first line contains four integers $n, m, c, f$, where $n$ and $m$ denote the number of rows and columns of the garden, respectively. The meanings of $c$ and $f$ are described in the output format section.\n- The next $n$ lines each contain a string of length $m$ consisting only of $0$ and $1$. The $j$-th character of the $i$-th string denotes $a_{i,j}$, i.e., whether the cell at row $i$, column $j$ in the garden is a pit.", "outputFormat": "Let the numbers of $\\texttt{C-}$ shaped and $\\texttt{F-}$ shaped planting schemes in the garden be $V_C$ and $V_F$, respectively. For each test case, output one line with two non-negative integers separated by a space, representing $(c \\times V_C) \\bmod 998244353$ and $(f \\times V_F ) \\bmod 998244353$, respectively, where $a \\bmod P$ denotes $a$ modulo $P$.", "hint": "【Explanation of Sample 1】\n\nThe four $\\texttt{C-}$ shaped planting schemes are:\n\n```plain\n**1 **1 **1 **1\n*10 *10 *10 *10\n**0 *** *00 *00\n000 000 **0 ***\n```\n\nHere $\\texttt*$ denotes planting a flower at that position. Note that the two horizontal strokes of $\\texttt C$ do not need to have the same length.\n\nSimilarly, the two $\\texttt{F-}$ shaped planting schemes are:\n\n```plain\n**1 **1\n*10 *10\n**0 ***\n*00 *00\n```\n\n【Sample 2】\n\nSee the attachments $\\texttt{plant/plant2.in}$ and $\\texttt{plant/plant2.ans}$.\n\n【Sample 3】\n\nSee the attachments $\\texttt{plant/plant3.in}$ and $\\texttt{plant/plant3.ans}$.\n\n【Constraints】\n\nFor all test cases, it is guaranteed that $1 \\leq T \\leq 5$, $1 \\leq n, m \\leq 10^3$, $0 \\leq c, f \\leq 1$, and $a_{i,j} \\in \\{0, 1\\}$.\n\n| Test point ID | $n$ | $m$ | $c=$ | $f=$ | Special property | Score |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\leq 1000$ | $\\leq 1000$ | $0$ | $0$ | None | $1$ |\n| $2$ | $=3$ | $=2$ | $1$ | $1$ | None | $2$ |\n| $3$ | $=4$ | $=2$ | $1$ | $1$ | None | $3$ |\n| $4$ | $\\leq 1000$ | $=2$ | $1$ | $1$ | None | $4$ |\n| $5$ | $\\leq 1000$ | $\\leq 1000$ | $1$ | $1$ | A | $4$ |\n| $6$ | $\\leq 1000$ | $\\leq 1000$ | $1$ | $1$ | B | $6$ |\n| $7$ | $\\leq 10$ | $\\leq 10$ | $1$ | $1$ | None | $10$ |\n| $8$ | $\\leq 20$ | $\\leq 20$ | $1$ | $1$ | None | $6$ |\n| $9$ | $\\leq 30$ | $\\leq 30$ | $1$ | $1$ | None | $6$ |\n| $10$ | $\\leq 50$ | $\\leq 50$ | $1$ | $1$ | None | $8$ |\n| $11$ | $\\leq 100$ | $\\leq 100$ | $1$ | $1$ | None | $10$ |\n| $12$ | $\\leq 200$ | $\\leq 200$ | $1$ | $1$ | None | $6$ |\n| $13$ | $\\leq 300$ | $\\leq 300$ | $1$ | $1$ | None | $6$ |\n| $14$ | $\\leq 500$ | $\\leq 500$ | $1$ | $1$ | None | $8$ |\n| $15$ | $\\leq 1000$ | $\\leq 1000$ | $1$ | $0$ | None | $6$ |\n| $16$ | $\\leq 1000$ | $\\leq 1000$ | $1$ | $1$ | None | $14$ |\n\nSpecial property A: $\\forall 1 \\leq i \\leq n, 1 \\leq j \\leq \\left\\lfloor \\frac{m}{3} \\right\\rfloor$, $a_{i, 3 j} = 1$.\n\nSpecial property B: $\\forall 1 \\leq i \\leq \\left\\lfloor \\frac{n}{4} \\right\\rfloor, 1 \\leq j \\leq m$, $a_{4 i, j} = 1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP2022] 种花", "background": "", "description": "小 C 决定在他的花园里种出 $\\texttt{CCF}$ 字样的图案，因此他想知道 $\\texttt C$ 和 $\\texttt F$ 两个字母各自有多少种种花的方案；不幸的是，花园中有一些土坑，这些位置无法种花，因此他希望你能帮助他解决这个问题。\n\n花园可以看作有 $n\\times m$ 个位置的网格图，从上到下分别为第 $1$ 到第 $n$ 行，从左到右分别为第 $1$ 列到第 $m$ 列，其中每个位置有可能是土坑，也有可能不是，可以用 $a_{i,j} = 1$ 表示第 $i$ 行第 $j$ 列这个位置有土坑，否则用 $a_{i,j} = 0$ 表示这个位置没土坑。\n\n一种种花方案被称为 $\\texttt{C-}$ **形**的，如果存在 $x_1, x_2 \\in [1, n]$，以及 $y_0, y_1, y_2 \\in [1, m]$，满足 $x_1 + 1 < x_2$，并且 $y_0 < y_1, y_2 \\leq m$，使得第 $x_1$ **行**的第 $y_0$ 到第 $y_1$ **列**、第 $x_2$ **行**的第 $y_0$ 到第 $y_2$ **列**以及第 $y_0$ **列**的第 $x_1$ 到第 $x_2$ **行**都**不为土坑**，且只在上述这些位置上种花。\n\n一种种花方案被称为 $\\texttt{F-}$ **形**的，如果存在 $x_1, x_2, x_3 \\in [1, n]$，以及 $y_0, y_1, y_2 \\in [1, m]$，满足 $x_1 + 1 < x_2 < x_3$，并且 $y_0 < y_1, y_2 \\leq m$，使得第 $x_1$ **行**的第 $y_0$ 到第 $y_1$ **列**、第 $x_2$ **行**的第 $y_0$ 到第 $y_2$ **列**以及第 $y_0$ **列**的第 $x_1$ 到第 $x_3$ **行**都**不为土坑**，且只在上述这些位置上种花。\n\n样例一解释中给出了 $\\texttt{C-}$ 形和 $\\texttt{F-}$ 形种花方案的图案示例。\n\n现在小 C 想知道，给定 $n, m$ 以及表示每个位置是否为土坑的值 $\\{a_{i,j}\\}$，$\\texttt{C-}$ 形和 $\\texttt{F-}$ 形种花方案分别有多少种可能？由于答案可能非常之大，你只需要输出其对 $998244353$ 取模的结果即可，具体输出结果请看输出格式部分。", "inputFormat": "第一行包含两个整数 $T, id$，分别表示数据组数和测试点编号。如果数据为样例则保证 $id = 0$。\n\n接下来一共 $T$ 组数据，在每组数据中：\n\n第一行包含四个整数 $n, m, c, f$，其中 $n, m$ 分别表示花园的行数、列数，对于 $c, f$ 的含义见输出格式部分。\n\n接下来 $n$ 行，每行包含一个长度为 $m$ 且仅包含 $0$ 和 $1$ 的字符串，其中第 $i$ 个串的第 $j$ 个字符表示 $a_{i,j}$，即花园里的第 $i$ 行第 $j$ 列是不是一个土坑。", "outputFormat": "设花园中 $\\texttt{C-}$ 形和 $\\texttt{F-}$ 形的种花方案分别有 $V_C$ 和 $V_F$ 种，则你需要对每一组数据输出一行用一个空格隔开的两个非负整数，分别表示 $(c \\times V_C) \\bmod 998244353$，$(f \\times V_F ) \\bmod 998244353$ ，其中 $a \\bmod P$ 表示 $a$ 对 $P$ 取模后的结果。", "hint": "**【样例 1 解释】**\n\n四个 $\\texttt{C-}$ 形种花方案为：\n\n```plain\n**1 **1 **1 **1\n*10 *10 *10 *10\n**0 *** *00 *00\n000 000 **0 ***\n```\n\n其中 $\\texttt*$ 表示在这个位置种花。注意 $\\texttt C$ 的两横可以不一样长。\n\n类似的，两个 $\\texttt{F-}$ 形种花方案为：\n\n```plain\n**1 **1\n*10 *10\n**0 ***\n*00 *00\n```\n\n**【样例 2】**\n\n见附件下的 $\\texttt{plant/plant2.in}$ 与 $\\texttt{plant/plant2.ans}$。\n\n**【样例 3】**\n\n见附件下的 $\\texttt{plant/plant3.in}$ 与 $\\texttt{plant/plant3.ans}$。\n\n**【数据范围】**\n\n对于所有数据，保证：$1 \\leq T \\leq 5$，$1 \\leq n, m \\leq 10^3$，$0 \\leq c, f \\leq 1$，$a_{i,j} \\in \\{0, 1\\}$。\n\n| 测试点编号 | $n$ | $m$ | $c=$ | $f=$ | 特殊性质 | 测试点分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\leq 1000$ | $\\leq 1000$ | $0$ | $0$ | 无 | $1$ |\n| $2$ | $=3$ | $=2$ | $1$ | $1$ | 无 | $2$ |\n| $3$ | $=4$ | $=2$ | $1$ | $1$ | 无 | $3$ |\n| $4$ | $\\leq 1000$ | $=2$ | $1$ | $1$ | 无 | $4$ |\n| $5$ | $\\leq 1000$ | $\\leq 1000$ | $1$ | $1$ | A | $4$ |\n| $6$ | $\\leq 1000$ | $\\leq 1000$ | $1$ | $1$ | B | $6$ |\n| $7$ | $\\leq 10$ | $\\leq 10$ | $1$ | $1$ | 无 | $10$ |\n| $8$ | $\\leq 20$ | $\\leq 20$ | $1$ | $1$ | 无 | $6$ |\n| $9$ | $\\leq 30$ | $\\leq 30$ | $1$ | $1$ | 无 | $6$ |\n| $10$ | $\\leq 50$ | $\\leq 50$ | $1$ | $1$ | 无 | $8$ |\n| $11$ | $\\leq 100$ | $\\leq 100$ | $1$ | $1$ | 无 | $10$ |\n| $12$ | $\\leq 200$ | $\\leq 200$ | $1$ | $1$ | 无 | $6$ |\n| $13$ | $\\leq 300$ | $\\leq 300$ | $1$ | $1$ | 无 | $6$ |\n| $14$ | $\\leq 500$ | $\\leq 500$ | $1$ | $1$ | 无 | $8$ |\n| $15$ | $\\leq 1000$ | $\\leq 1000$ | $1$ | $0$ | 无 | $6$ |\n| $16$ | $\\leq 1000$ | $\\leq 1000$ | $1$ | $1$ | 无 | $14$ |\n\n特殊性质 A：$\\forall 1 \\leq i \\leq n, 1 \\leq j \\leq \\left\\lfloor \\frac{m}{3} \\right\\rfloor$，$a_{i, 3 j} = 1$；\n\n特殊性质 B：$\\forall 1 \\leq i \\leq \\left\\lfloor \\frac{n}{4} \\right\\rfloor, 1 \\leq j \\leq m$，$a_{4 i, j} = 1$；", "locale": "zh-CN"}}}
{"pid": "P8866", "type": "P", "difficulty": 6, "samples": [["1\n2 4 2\n1 2 1 2", "5\n1 1\n1 1\n1 2\n2 1 2\n1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2022", "NOIP 提高组", "Special Judge", "O2优化", "构造", "Ad-hoc"], "title": "[NOIP2022] 喵了个喵", "background": "", "description": "小 E 喜欢上了一款叫做《喵了个喵》的游戏。这个游戏有一个牌堆和 $n$ 个可以从栈底删除元素的栈，任务是要通过游戏规则将所有的卡牌消去。开始时牌堆中有 $m$ 张卡牌，从上到下的图案分别是 $a_1, a_2,\\dots, a_m$。所有的卡牌一共有 $k$ 种图案，从 $1$ 到 $k$ 编号。牌堆中每一种图案的卡牌都有偶数张。开始时所有的栈都是空的。这个游戏有两种操作：\n\n- 选择一个栈，将牌堆顶上的卡牌放入栈的顶部。如果这么操作后，这个栈最上方的两张牌有相同的图案，则会自动将这两张牌消去。\n- 选择两个不同的栈，如果这两个栈栈**底**的卡牌有相同的图案，则可以将这两张牌消去，原来在栈底上方的卡牌会成为新的栈底。如果不同，则什么也不会做。\n\n这个游戏一共有 $T$ 关，小 E 一直无法通关。请你帮小 E 设计一下游戏方案，即对于游戏的每一关，给出相应的操作序列使得小 E 可以把所有的卡牌消去。", "inputFormat": "第一行包含一个正整数 $T$，表示数据组数。\n\n接下来一共 $T$ 组数据，在每组数据中：\n\n第一行包含三个正整数 $n, m, k$，分别表示栈的个数、卡牌的个数、卡牌上图案的种类。\n\n第二行包含 $m$ 个正整数，分别表示 $a_1, a_2,\\dots, a_m$，分别从上到下表示牌堆中卡牌的图案。\n\n输入数据保证有解。", "outputFormat": "对于每一组数据，输出若干行。\n\n其中第一行包含一个正整数 $\\mathrm{op}$，表示操作的次数。你需要保证 $m \\leq \\mathrm{op} \\leq 2\\times m$。\n\n接下来 $\\mathrm{op}$ 行，每行包含两个或三个正整数，整数之间用一个空格隔开。\n\n若为两个整数 $\\texttt{1 s}$，则进行一次第一个操作并选择栈 $s$。\n\n若为三个整数 $\\texttt{2 s1 s2}$，则进行一次第二个操作并选择栈 $s_1$ 和 $s_2$。\n\n你需要保证 $1 \\leq s, s_1, s_2 \\leq n$，且 $s_1 \\neq s_2$。", "hint": "**【样例 1 解释】**\n\n下图是初始状态。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iidvwekz.png)\n\n下图是前两次操作之后的结果。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hrcdl51d.png)\n\n下图是第三次和第四次操作之后的结果。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ju6b9dep.png)\n\n下图是第五次操作之后的结果。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/djpqtzfr.png)\n\n**【样例 2】**\n\n见选手目录下的 $\\texttt{meow/meow2.in}$ 与 $\\texttt{meow/meow2.ans}$。\n\n**【数据范围】**\n\n设 $S$ 为所有 $T$ 组数据中 $m$ 的总和。\n\n对于所有数据，保证 $S \\leq 2 \\times 10^6$，$1 \\leq n  \\leq 300$，$1 \\leq a_i \\leq k$。\n\n::cute-table{tuack}\n\n| 测试点 | $T=$ | $n$ | $k=$ | $m \\leq$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1\\sim 3$ | $1001$ | $\\leq 300$ | $2n-2$ | 无限制 |\n| $4\\sim 6$ | $1002$ | $=2$ | $2n-1$ | ^ |\n| $7\\sim 10$ | $3$ | $=3$ | ^ | $14$ |\n| $11\\sim 14$ | $1004$ | ^ | ^ | 无限制 |\n| $15\\sim 20$ | $1005$ | $\\leq 300$ | ^ | ^ |\n\n\n**【评分方式】**\n\n对于每一组数据，若在按顺序进行所有操作后，牌堆为空且所有的栈均为空，则认为你的答案正确。\n\n**【提示】**\n\n你可以通过 $T$ 的个位数来判断这个测试点是属于哪一类数据。\n\n你的输出不需要与样例输出一致，输出任意一个合法解即可得分。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP2022] Meow Meow", "background": "", "description": "Xiao E likes a game called \"Meow Meow.\" The game has a deck and $n$ stacks from which elements can be removed from the bottom. The task is to eliminate all cards according to the game rules. Initially, the deck contains $m$ cards whose patterns from top to bottom are $a_1, a_2, \\dots, a_m$. There are $k$ types of patterns, numbered from $1$ to $k$. Each pattern appears an even number of times in the deck. All stacks are initially empty. The game allows two operations:\n\n- Choose a stack and place the top card of the deck onto the top of that stack. After doing so, if the top two cards of this stack have the same pattern, they will be automatically removed.\n- Choose two different stacks. If the cards at the bottoms of these two stacks have the same pattern, you may remove these two cards, and the cards that were originally just above the bottoms become the new bottoms. If the patterns are different, nothing happens.\n\nThere are $T$ levels in total. Xiao E cannot clear them. Please design a plan for each level: for every level, output an operation sequence that eliminates all the cards.", "inputFormat": "The first line contains a positive integer $T$, the number of test cases.\n\nThen for each of the $T$ test cases:\n\n- The first line contains three positive integers $n, m, k$, denoting the number of stacks, the number of cards, and the number of pattern types on the cards.\n- The second line contains $m$ positive integers $a_1, a_2, \\dots, a_m$, representing the patterns of the cards in the deck from top to bottom.\n\nThe testdata guarantees that there is a solution.", "outputFormat": "For each test case, output several lines.\n\nThe first line contains a positive integer $\\mathrm{op}$, the number of operations. You must ensure $m \\leq \\mathrm{op} \\leq 2 \\times m$.\n\nThen output $\\mathrm{op}$ lines. Each line contains two or three positive integers separated by a single space.\n\n- If the line has two integers $\\texttt{1 s}$, perform the first operation on stack $s$.\n- If the line has three integers $\\texttt{2 s1 s2}$, perform the second operation on stacks $s_1$ and $s_2$.\n\nYou must ensure $1 \\leq s, s_1, s_2 \\leq n$ and $s_1 \\neq s_2$.", "hint": "- Sample 1 Explanation.\n\nThe figure below shows the initial state.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iidvwekz.png)\n\nThe figure below shows the state after the first two operations.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hrcdl51d.png)\n\nThe figure below shows the state after the third and fourth operations.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ju6b9dep.png)\n\nThe figure below shows the state after the fifth operation.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/djpqtzfr.png)\n\n- Sample 2.\n\nSee the files $\\texttt{meow/meow2.in}$ and $\\texttt{meow/meow2.ans}$ in the contestants' directory.\n\n- Constraints.\n\nLet $S$ be the sum of $m$ over all $T$ test cases.\n\nFor all testdata, it is guaranteed that $S \\leq 2 \\times 10^6$, $1 \\leq n \\leq 300$, and $1 \\leq a_i \\leq k$.\n\n::cute-table{tuack}\n| Test Point | $T=$ | $n$ | $k=$ | $m \\leq$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1\\sim 3$ | $1001$ | $\\leq 300$ | $2n-2$ | No limit |\n| $4\\sim 6$ | $1002$ | $=2$ | $2n-1$ | ^ |\n| $7\\sim 10$ | $3$ | $=3$ | ^ | $14$ |\n| $11\\sim 14$ | $1004$ | ^ | ^ | No limit |\n| $15\\sim 20$ | $1005$ | $\\leq 300$ | ^ | ^ |\n::cute-table{tuack}\n\n- Scoring.\n\nFor each test case, your answer is considered correct if, after performing all operations in order, the deck is empty and all stacks are empty.\n\n- Additional Hint.\n\nYou can determine which category a test point belongs to by the ones digit of $T$. Your output does not need to match the sample output; any valid solution earns points.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP2022] 喵了个喵", "background": "", "description": "小 E 喜欢上了一款叫做《喵了个喵》的游戏。这个游戏有一个牌堆和 $n$ 个可以从栈底删除元素的栈，任务是要通过游戏规则将所有的卡牌消去。开始时牌堆中有 $m$ 张卡牌，从上到下的图案分别是 $a_1, a_2,\\dots, a_m$。所有的卡牌一共有 $k$ 种图案，从 $1$ 到 $k$ 编号。牌堆中每一种图案的卡牌都有偶数张。开始时所有的栈都是空的。这个游戏有两种操作：\n\n- 选择一个栈，将牌堆顶上的卡牌放入栈的顶部。如果这么操作后，这个栈最上方的两张牌有相同的图案，则会自动将这两张牌消去。\n- 选择两个不同的栈，如果这两个栈栈**底**的卡牌有相同的图案，则可以将这两张牌消去，原来在栈底上方的卡牌会成为新的栈底。如果不同，则什么也不会做。\n\n这个游戏一共有 $T$ 关，小 E 一直无法通关。请你帮小 E 设计一下游戏方案，即对于游戏的每一关，给出相应的操作序列使得小 E 可以把所有的卡牌消去。", "inputFormat": "第一行包含一个正整数 $T$，表示数据组数。\n\n接下来一共 $T$ 组数据，在每组数据中：\n\n第一行包含三个正整数 $n, m, k$，分别表示栈的个数、卡牌的个数、卡牌上图案的种类。\n\n第二行包含 $m$ 个正整数，分别表示 $a_1, a_2,\\dots, a_m$，分别从上到下表示牌堆中卡牌的图案。\n\n输入数据保证有解。", "outputFormat": "对于每一组数据，输出若干行。\n\n其中第一行包含一个正整数 $\\mathrm{op}$，表示操作的次数。你需要保证 $m \\leq \\mathrm{op} \\leq 2\\times m$。\n\n接下来 $\\mathrm{op}$ 行，每行包含两个或三个正整数，整数之间用一个空格隔开。\n\n若为两个整数 $\\texttt{1 s}$，则进行一次第一个操作并选择栈 $s$。\n\n若为三个整数 $\\texttt{2 s1 s2}$，则进行一次第二个操作并选择栈 $s_1$ 和 $s_2$。\n\n你需要保证 $1 \\leq s, s_1, s_2 \\leq n$，且 $s_1 \\neq s_2$。", "hint": "**【样例 1 解释】**\n\n下图是初始状态。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iidvwekz.png)\n\n下图是前两次操作之后的结果。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hrcdl51d.png)\n\n下图是第三次和第四次操作之后的结果。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ju6b9dep.png)\n\n下图是第五次操作之后的结果。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/djpqtzfr.png)\n\n**【样例 2】**\n\n见选手目录下的 $\\texttt{meow/meow2.in}$ 与 $\\texttt{meow/meow2.ans}$。\n\n**【数据范围】**\n\n设 $S$ 为所有 $T$ 组数据中 $m$ 的总和。\n\n对于所有数据，保证 $S \\leq 2 \\times 10^6$，$1 \\leq n  \\leq 300$，$1 \\leq a_i \\leq k$。\n\n::cute-table{tuack}\n\n| 测试点 | $T=$ | $n$ | $k=$ | $m \\leq$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1\\sim 3$ | $1001$ | $\\leq 300$ | $2n-2$ | 无限制 |\n| $4\\sim 6$ | $1002$ | $=2$ | $2n-1$ | ^ |\n| $7\\sim 10$ | $3$ | $=3$ | ^ | $14$ |\n| $11\\sim 14$ | $1004$ | ^ | ^ | 无限制 |\n| $15\\sim 20$ | $1005$ | $\\leq 300$ | ^ | ^ |\n\n\n**【评分方式】**\n\n对于每一组数据，若在按顺序进行所有操作后，牌堆为空且所有的栈均为空，则认为你的答案正确。\n\n**【提示】**\n\n你可以通过 $T$ 的个位数来判断这个测试点是属于哪一类数据。\n\n你的输出不需要与样例输出一致，输出任意一个合法解即可得分。", "locale": "zh-CN"}}}
{"pid": "P8867", "type": "P", "difficulty": 6, "samples": [["2 1\n1 2", "5"], ["4 4\n1 2\n2 3\n3 1\n1 4", "184"], ["见附加文件里的 barrack/barrack3.in", "见附加文件里的 barrack/barrack3.ans"], ["见附加文件里的 barrack/barrack4.in", "见附加文件里的 barrack/barrack4.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "NOIP 提高组", "O2优化", "树形 DP", "Tarjan", "双连通分量", "容斥原理"], "title": "[NOIP2022] 建造军营", "background": "", "description": "A 国与 B 国正在激烈交战中，A 国打算在自己的国土上建造一些军营。\n\nA 国的国土由 $n$ 座城市组成，$m$ 条双向道路连接这些城市，使得**任意两座城市均可通过道路直接或间接到达**。A 国打算选择一座或多座城市（**至少一座**），并在这些城市上各建造一座军营。\n\n众所周知，军营之间的联络是十分重要的。然而此时 A 国接到情报，B 国将会于不久后袭击 A 国的一条道路，但具体的袭击目标却无从得知。如果 B 国袭击成功，这条道路将被切断，可能会造成 A 国某两个军营无法互相到达，这是 A 国极力避免的。因此 A 国决定派兵看守若干条道路（**可以是一条或多条，也可以一条也不看守**），A 国有信心保证被派兵看守的道路能够抵御 B 国的袭击而不被切断。\n\nA 国希望制定一个建造军营和看守道路的方案，使得 B 国袭击的无论是 A 国的哪条道路，都不会造成某两座军营无法互相到达。现在，请你帮 A 国计算一下可能的建造军营和看守道路的方案数共有多少。由于方案数可能会很多，你只需要输出其对 $1,000,000,007\\left(10^{9}+7\\right)$ 取模的值即可。两个方案被认为是不同的，当且仅当存在至少一座城市在一个方案中建造了军营而在另一个方案中没有，或者存在至少一条道路在一个方案中被派兵看守而在另一个方案中没有。", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示城市的个数和双向道路的数量。\n\n接下来 $m$ 行，每行包含两个正整数 $u_{i},v_{i}$，描述一条连接 $u_{i}$ 和 $v_{i}$ 的双向道路。保证没有重边和自环。", "outputFormat": "输出一行包含一个整数，表示建造军营和看守道路的方案数对 $1,000,000,007\\left(10^{9}+ 7\\right)$ 取模的结果。", "hint": "### 样例 1 解释\n\n样例中，A 国共有两座城市，有 $1$ 条道路连接他们。\n\n所有可能的方案如下：\n\n- 在城市 $1$ 建军营，不看守这条道路；\n- 在城市 $1$ 建军营，看守这条道路；\n- 在城市 $2$ 建军营，不看守这条道路；\n- 在城市 $2$ 建军营，看守这条道路；\n- 在城市 $1,2$ 建军营，看守这条道路。\n\n### 数据规模与约定\n\n对于所有数据，保证 $1 \\leq n \\leq 5 \\times 10^5$，$n - 1 \\leq m \\leq 10^6$，$1 \\leq u_i, v_i \\leq n$，$u_i \\neq v_i$。\n\n::cute-table{tuack}\n\n|测试点编号 | $n \\leq $ | $m \\leq $| 特殊条件 |\n| :-: | :-: | :-: | :-: |\n| $1 \\sim 3$ | $8$ | $10$ | 无 |\n| $4 \\sim 7$ | $16$ | $25$ | ^ |\n| $8 \\sim 9$ | $3000$ | $5000$ | ^ |\n| $10 \\sim 11$ | $5 \\times 10^5$ | $10^6$ | 特殊性质 $\\mathrm{A}$ |\n| $12 \\sim 14$ | ^ | ^ | $m = n - 1$ |\n| $15 \\sim 16$ | ^ | ^ | $m = n$ |\n| $17 \\sim 20$ | ^ | ^ | 无 |\n\n特殊性质 $\\mathrm{A}$：保证 $m=n-1$ 且第 $i$ 条道路连接城市 $i$ 与 $i+1$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP2022] Building Military Camps", "background": "", "description": "Countries A and B are at war, and country A plans to build some military camps on its own territory.\n\nCountry A’s territory consists of $n$ cities, connected by $m$ bidirectional roads, such that any two cities are directly or indirectly reachable through the roads. Country A will choose one or more cities (at least one) and build exactly one military camp in each chosen city.\n\nIt is well known that communication between camps is crucial. However, country A has received intelligence that country B will soon attack one of A’s roads, but the exact target is unknown. If B’s attack succeeds, that road will be cut, which may cause some two camps in A to be unable to reach each other, something A is keen to avoid. Therefore, A decides to station troops to guard some roads (it could be one or more, or possibly none). Country A is confident that any guarded road can withstand B’s attack and will not be cut.\n\nCountry A wants to design a plan for building camps and guarding roads such that, no matter which road in A is attacked by B, it will not cause any two camps to be unable to reach each other. Please help country A calculate how many possible plans there are for building camps and guarding roads. Since the number of plans may be large, output the value modulo $1,000,000,007\\left(10^{9}+7\\right)$. Two plans are considered different if and only if there exists at least one city that has a camp in one plan but not in the other, or there exists at least one road that is guarded in one plan but not in the other.", "inputFormat": "The first line contains two positive integers $n, m$, denoting the number of cities and the number of bidirectional roads, respectively.\n\nThe next $m$ lines each contain two positive integers $u_i, v_i$, describing a bidirectional road connecting $u_i$ and $v_i$. There are no multiple edges or self-loops.", "outputFormat": "Output one line containing an integer, the number of valid plans for building camps and guarding roads, modulo $1,000,000,007\\left(10^{9}+ 7\\right)$.", "hint": "### Sample 1 Explanation\n\nIn the sample, country A has two cities, with $1$ road connecting them.\n\nAll possible plans are as follows:\n- Build a camp in city $1$, do not guard the road.\n- Build a camp in city $1$, guard the road.\n- Build a camp in city $2$, do not guard the road.\n- Build a camp in city $2$, guard the road.\n- Build camps in cities $1, 2$, guard the road.\n\n### Constraints\n\nFor all testdata, it is guaranteed that $1 \\leq n \\leq 5 \\times 10^5$, $n - 1 \\leq m \\leq 10^6$, $1 \\leq u_i, v_i \\leq n$, $u_i \\neq v_i$.\n\n| Test point ID | $n \\leq$ | $m \\leq$ | Special condition |\n| :-: | :-: | :-: | :-: |\n| $1 \\sim 3$ | $8$ | $10$ | None |\n| $4 \\sim 7$ | $16$ | $25$ | ^ |\n| $8 \\sim 9$ | $3000$ | $5000$ | ^ |\n| $10 \\sim 11$ | $5 \\times 10^5$ | $10^6$ | Special property $\\mathrm{A}$ |\n| $12 \\sim 14$ | ^ | ^ | $m = n - 1$ |\n| $15 \\sim 16$ | ^ | ^ | $m = n$ |\n| $17 \\sim 20$ | ^ | ^ | None |\n\nSpecial property $\\mathrm{A}$: guarantee $m = n - 1$ and the $i$-th road connects city $i$ and $i + 1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP2022] 建造军营", "background": "", "description": "A 国与 B 国正在激烈交战中，A 国打算在自己的国土上建造一些军营。\n\nA 国的国土由 $n$ 座城市组成，$m$ 条双向道路连接这些城市，使得**任意两座城市均可通过道路直接或间接到达**。A 国打算选择一座或多座城市（**至少一座**），并在这些城市上各建造一座军营。\n\n众所周知，军营之间的联络是十分重要的。然而此时 A 国接到情报，B 国将会于不久后袭击 A 国的一条道路，但具体的袭击目标却无从得知。如果 B 国袭击成功，这条道路将被切断，可能会造成 A 国某两个军营无法互相到达，这是 A 国极力避免的。因此 A 国决定派兵看守若干条道路（**可以是一条或多条，也可以一条也不看守**），A 国有信心保证被派兵看守的道路能够抵御 B 国的袭击而不被切断。\n\nA 国希望制定一个建造军营和看守道路的方案，使得 B 国袭击的无论是 A 国的哪条道路，都不会造成某两座军营无法互相到达。现在，请你帮 A 国计算一下可能的建造军营和看守道路的方案数共有多少。由于方案数可能会很多，你只需要输出其对 $1,000,000,007\\left(10^{9}+7\\right)$ 取模的值即可。两个方案被认为是不同的，当且仅当存在至少一座城市在一个方案中建造了军营而在另一个方案中没有，或者存在至少一条道路在一个方案中被派兵看守而在另一个方案中没有。", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示城市的个数和双向道路的数量。\n\n接下来 $m$ 行，每行包含两个正整数 $u_{i},v_{i}$，描述一条连接 $u_{i}$ 和 $v_{i}$ 的双向道路。保证没有重边和自环。", "outputFormat": "输出一行包含一个整数，表示建造军营和看守道路的方案数对 $1,000,000,007\\left(10^{9}+ 7\\right)$ 取模的结果。", "hint": "### 样例 1 解释\n\n样例中，A 国共有两座城市，有 $1$ 条道路连接他们。\n\n所有可能的方案如下：\n\n- 在城市 $1$ 建军营，不看守这条道路；\n- 在城市 $1$ 建军营，看守这条道路；\n- 在城市 $2$ 建军营，不看守这条道路；\n- 在城市 $2$ 建军营，看守这条道路；\n- 在城市 $1,2$ 建军营，看守这条道路。\n\n### 数据规模与约定\n\n对于所有数据，保证 $1 \\leq n \\leq 5 \\times 10^5$，$n - 1 \\leq m \\leq 10^6$，$1 \\leq u_i, v_i \\leq n$，$u_i \\neq v_i$。\n\n::cute-table{tuack}\n\n|测试点编号 | $n \\leq $ | $m \\leq $| 特殊条件 |\n| :-: | :-: | :-: | :-: |\n| $1 \\sim 3$ | $8$ | $10$ | 无 |\n| $4 \\sim 7$ | $16$ | $25$ | ^ |\n| $8 \\sim 9$ | $3000$ | $5000$ | ^ |\n| $10 \\sim 11$ | $5 \\times 10^5$ | $10^6$ | 特殊性质 $\\mathrm{A}$ |\n| $12 \\sim 14$ | ^ | ^ | $m = n - 1$ |\n| $15 \\sim 16$ | ^ | ^ | $m = n$ |\n| $17 \\sim 20$ | ^ | ^ | 无 |\n\n特殊性质 $\\mathrm{A}$：保证 $m=n-1$ 且第 $i$ 条道路连接城市 $i$ 与 $i+1$。", "locale": "zh-CN"}}}
{"pid": "P8868", "type": "P", "difficulty": 6, "samples": [["0 2\n2 1\n1 2\n1\n1 2", "8"], ["见附件下的 match/match2.in。", "见附件下的 match/match2.ans。"], ["见附件下的 match/match3.in。", "见附件下的 match/match3.ans。"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "2022", "NOIP 提高组", "O2优化"], "title": "[NOIP2022] 比赛", "background": "", "description": "小 N 和小 O 会在 2022 年 11 月参加一场盛大的程序设计大赛 NOIP！小 P 会作为裁判主持竞赛。小 N 和小 O 各自率领了一支 $n$ 个人的队伍，选手在每支队伍内都是从 $1$ 到 $n$ 编号。每一个选手都有相应的程序设计水平。具体的，小 N 率领的队伍中，编号为 $i$（$1 \\leq i \\leq n$）的选手的程序设计水平为 $a _ i$；小 O 率领的队伍中，编号为 $i$（$1 \\leq i \\leq n$）的选手的程序设计水平为 $b _ i$。特别地，$\\{a _ i\\}$ 和 $\\{b _ i\\}$ 还分别构成了从 $1$ 到 $n$ 的排列。\n\n每场比赛前，考虑到路途距离，选手连续参加比赛等因素，小 P 会选择两个参数 $l, r$（$1 \\leq l \\leq r \\leq n$），表示这一场比赛会邀请两队中编号属于 $[l, r]$ 的所有选手来到现场准备比赛。在比赛现场，小 N 和小 O 会以掷骰子的方式挑选出参数 $p, q$（$l \\leq p \\leq q \\leq r$），只有编号属于 $[p, q]$ 的选手才能参赛。为了给观众以最精彩的比赛，两队都会派出编号在 $[p, q]$ 内的、程序设计水平值最大的选手参加比赛。假定小 N 派出的选手水平为 $m _ a$，小 O 派出的选手水平为 $m _ b$，则比赛的精彩程度为 $m _ a \\times m _ b$。\n\nNOIP 总共有 $Q$ 场比赛，每场比赛的参数 $l, r$ 都已经确定，但是 $p, q$ 还没有抽取。小 P 想知道，对于每一场比赛，在其所有可能的 $p, q$（$l \\leq p \\leq q \\leq r$）参数下的比赛的精彩程度之和。由于答案可能非常之大，你只需要对每一场答案输出结果对 $2 ^ {64}$ 取模的结果即可。", "inputFormat": "第一行包含两个正整数 $T, n$，分别表示测试点编号和参赛人数。如果数据为样例则保证 $T = 0$。\n\n第二行包含 $n$ 个正整数，第 $i$ 个正整数为 $a _ i$，表示小 N 队伍中编号为 $i$ 的选手的程序设计水平。\n\n第三行包含 $n$ 个正整数，第 $i$ 个正整数为 $b _ i$，表示小 O 队伍中编号为 $i$ 的选手的程序设计水平。\n\n第四行包含一个正整数 $Q$，表示比赛场数。\n\n接下来的 $Q$ 行，第 $i$ 行包含两个正整数 $l _ i, r _ i$，表示第 $i$ 场比赛的参数 $l, r$。", "outputFormat": "输出 $Q$ 行，第 $i$ 行包含一个非负整数，表示第 $i$ 场比赛中所有可能的比赛的精彩程度之和对 $2 ^ {64}$ 取模的结果。", "hint": "**【样例 1 解释】**\n\n当 $p = 1, q = 2$ 的时候，小 N 会派出 $1$ 号选手，小 O 会派出 $2$ 号选手，比赛精彩程度为 $2 \\times 2 = 4$。\n\n当 $p = 1, q = 1$ 的时候，小 N 会派出 $1$ 号选手，小 O 会派出 $1$ 号选手，比赛精彩程度为 $2 \\times 1 = 2$。\n\n当 $p = 2, q = 2$ 的时候，小 N 会派出 $2$ 号选手，小 O 会派出 $2$ 号选手，比赛精彩程度为 $1 \\times 2 = 2$。\n\n**【样例 2】**\n\n该样例满足测试点 $1 \\sim 2$ 的限制。\n\n**【样例 3】**\n\n该样例满足测试点 $3 \\sim 5$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，保证：$1 \\leq n, Q \\leq 2.5 \\times 10 ^ 5$，$1 \\leq l _ i \\leq r _ i \\leq n$，$1 \\leq a _ i, b _ i \\leq n$ 且 $\\{a _ i\\}$ 和 $\\{b _ i\\}$ 分别构成了从 $1$ 到 $n$ 的排列。\n\n::cute-table{tuack}\n\n| 测试点 | $n$ | $Q$ | 特殊性质 A | 特殊性质 B |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1, 2$ | $\\leq 30$ | $\\leq 30$ | 是 | 是 |\n| $3, 4, 5$ | $\\leq 3,000$ | $\\leq 3,000$ | ^ | ^ |\n| $6, 7$ | $\\leq 10 ^ 5$ | $\\leq 5$ | ^ | ^ |\n| $8, 9$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ | ^ |\n| $10, 11$ | $\\leq 10 ^ 5$ | ^ | 否 | 否 |\n| $12, 13$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ | ^ |\n| $14, 15$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | 是 | 是 |\n| $16, 17$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n| $18, 19$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | ^ | 否 |\n| $20, 21$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n| $22, 23$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | 否 | ^ |\n| $24, 25$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n\n特殊性质 A：保证 $a$ 是均匀随机生成的 $1 \\sim n$ 的排列。\n\n特殊性质 B：保证 $b$ 是均匀随机生成的 $1 \\sim n$ 的排列。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP2022] Competition", "background": "", "description": "Xiao N and Xiao O will take part in the grand programming contest NOIP in November 2022, and Xiao P will serve as the judge. Xiao N and Xiao O each lead a team of $n$ people, and players in each team are numbered from $1$ to $n$. Every player has a programming skill level. Specifically, in Xiao N's team, the player with index $i$ ($1 \\leq i \\leq n$) has skill level $a _ i$; in Xiao O's team, the player with index $i$ ($1 \\leq i \\leq n$) has skill level $b _ i$. In particular, $\\{a _ i\\}$ and $\\{b _ i\\}$ each form a permutation of $1$ to $n$.\n\nBefore each match, considering factors such as travel distance and players competing in consecutive matches, Xiao P chooses two parameters $l, r$ ($1 \\leq l \\leq r \\leq n$), meaning that for this match all players whose indices are in $[l, r]$ from both teams will come to the venue to get ready. At the venue, Xiao N and Xiao O will pick parameters $p, q$ by rolling dice ($l \\leq p \\leq q \\leq r$), and only players with indices in $[p, q]$ are eligible to compete. To deliver the most exciting match to the audience, both teams will send the player with the maximum programming skill value whose index lies in $[p, q]$. Suppose Xiao N sends a player with skill $m _ a$, and Xiao O sends a player with skill $m _ b$; then the excitement of the match is $m _ a \\times m _ b$.\n\nThere are $Q$ matches in total in NOIP. For each match, the parameters $l, r$ are fixed, but $p, q$ have not yet been drawn. Xiao P wants to know, for each match, the sum of the excitement values over all possible choices of $p, q$ ($l \\leq p \\leq q \\leq r$). Since the answer can be very large, for each match you only need to output the result modulo $2 ^ {64}$.", "inputFormat": "The first line contains two positive integers $T, n$, denoting the test point id and the number of participants, respectively. If the input is a sample, it is guaranteed that $T = 0$.\n\nThe second line contains $n$ positive integers; the $i$-th integer is $a _ i$, the programming skill level of the player with index $i$ in Xiao N's team.\n\nThe third line contains $n$ positive integers; the $i$-th integer is $b _ i$, the programming skill level of the player with index $i$ in Xiao O's team.\n\nThe fourth line contains a positive integer $Q$, the number of matches.\n\nEach of the next $Q$ lines contains two positive integers $l _ i, r _ i$, the parameters $l, r$ for the $i$-th match.", "outputFormat": "Output $Q$ lines. The $i$-th line should contain a non-negative integer, which is the sum of the excitement values over all possible matches for the $i$-th query, modulo $2 ^ {64}$.", "hint": "【Sample 1 Explanation】\n\nWhen $p = 1, q = 2$, Xiao N will send player $1$, and Xiao O will send player $2$, so the excitement is $2 \\times 2 = 4$.\n\nWhen $p = 1, q = 1$, Xiao N will send player $1$, and Xiao O will send player $1$, so the excitement is $2 \\times 1 = 2$.\n\nWhen $p = 2, q = 2$, Xiao N will send player $2$, and Xiao O will send player $2$, so the excitement is $1 \\times 2 = 2$.\n\n【Sample 2】\n\nThis sample satisfies the constraints of test points $1 \\sim 2$.\n\n【Sample 3】\n\nThis sample satisfies the constraints of test points $3 \\sim 5$.\n\n【Constraints】\n\nFor all testdata, it is guaranteed that: $1 \\leq n, Q \\leq 2.5 \\times 10 ^ 5$, $1 \\leq l _ i \\leq r _ i \\leq n$, $1 \\leq a _ i, b _ i \\leq n$, and $\\{a _ i\\}$ and $\\{b _ i\\}$ each form a permutation of $1$ to $n$.\n\n::cute-table{tuack}\n| Test points | $n$ | $Q$ | Special property A | Special property B |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1, 2$ | $\\leq 30$ | $\\leq 30$ | Yes | Yes |\n| $3, 4, 5$ | $\\leq 3,000$ | $\\leq 3,000$ | ^ | ^ |\n| $6, 7$ | $\\leq 10 ^ 5$ | $\\leq 5$ | ^ | ^ |\n| $8, 9$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ | ^ |\n| $10, 11$ | $\\leq 10 ^ 5$ | ^ | No | No |\n| $12, 13$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ | ^ |\n| $14, 15$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | Yes | Yes |\n| $16, 17$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n| $18, 19$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | ^ | No |\n| $20, 21$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n| $22, 23$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | No | ^ |\n| $24, 25$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n\nSpecial property A: It is guaranteed that $a$ is a uniformly random permutation of $1 \\sim n$.\n\nSpecial property B: It is guaranteed that $b$ is a uniformly random permutation of $1 \\sim n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP2022] 比赛", "background": "", "description": "小 N 和小 O 会在 2022 年 11 月参加一场盛大的程序设计大赛 NOIP！小 P 会作为裁判主持竞赛。小 N 和小 O 各自率领了一支 $n$ 个人的队伍，选手在每支队伍内都是从 $1$ 到 $n$ 编号。每一个选手都有相应的程序设计水平。具体的，小 N 率领的队伍中，编号为 $i$（$1 \\leq i \\leq n$）的选手的程序设计水平为 $a _ i$；小 O 率领的队伍中，编号为 $i$（$1 \\leq i \\leq n$）的选手的程序设计水平为 $b _ i$。特别地，$\\{a _ i\\}$ 和 $\\{b _ i\\}$ 还分别构成了从 $1$ 到 $n$ 的排列。\n\n每场比赛前，考虑到路途距离，选手连续参加比赛等因素，小 P 会选择两个参数 $l, r$（$1 \\leq l \\leq r \\leq n$），表示这一场比赛会邀请两队中编号属于 $[l, r]$ 的所有选手来到现场准备比赛。在比赛现场，小 N 和小 O 会以掷骰子的方式挑选出参数 $p, q$（$l \\leq p \\leq q \\leq r$），只有编号属于 $[p, q]$ 的选手才能参赛。为了给观众以最精彩的比赛，两队都会派出编号在 $[p, q]$ 内的、程序设计水平值最大的选手参加比赛。假定小 N 派出的选手水平为 $m _ a$，小 O 派出的选手水平为 $m _ b$，则比赛的精彩程度为 $m _ a \\times m _ b$。\n\nNOIP 总共有 $Q$ 场比赛，每场比赛的参数 $l, r$ 都已经确定，但是 $p, q$ 还没有抽取。小 P 想知道，对于每一场比赛，在其所有可能的 $p, q$（$l \\leq p \\leq q \\leq r$）参数下的比赛的精彩程度之和。由于答案可能非常之大，你只需要对每一场答案输出结果对 $2 ^ {64}$ 取模的结果即可。", "inputFormat": "第一行包含两个正整数 $T, n$，分别表示测试点编号和参赛人数。如果数据为样例则保证 $T = 0$。\n\n第二行包含 $n$ 个正整数，第 $i$ 个正整数为 $a _ i$，表示小 N 队伍中编号为 $i$ 的选手的程序设计水平。\n\n第三行包含 $n$ 个正整数，第 $i$ 个正整数为 $b _ i$，表示小 O 队伍中编号为 $i$ 的选手的程序设计水平。\n\n第四行包含一个正整数 $Q$，表示比赛场数。\n\n接下来的 $Q$ 行，第 $i$ 行包含两个正整数 $l _ i, r _ i$，表示第 $i$ 场比赛的参数 $l, r$。", "outputFormat": "输出 $Q$ 行，第 $i$ 行包含一个非负整数，表示第 $i$ 场比赛中所有可能的比赛的精彩程度之和对 $2 ^ {64}$ 取模的结果。", "hint": "**【样例 1 解释】**\n\n当 $p = 1, q = 2$ 的时候，小 N 会派出 $1$ 号选手，小 O 会派出 $2$ 号选手，比赛精彩程度为 $2 \\times 2 = 4$。\n\n当 $p = 1, q = 1$ 的时候，小 N 会派出 $1$ 号选手，小 O 会派出 $1$ 号选手，比赛精彩程度为 $2 \\times 1 = 2$。\n\n当 $p = 2, q = 2$ 的时候，小 N 会派出 $2$ 号选手，小 O 会派出 $2$ 号选手，比赛精彩程度为 $1 \\times 2 = 2$。\n\n**【样例 2】**\n\n该样例满足测试点 $1 \\sim 2$ 的限制。\n\n**【样例 3】**\n\n该样例满足测试点 $3 \\sim 5$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，保证：$1 \\leq n, Q \\leq 2.5 \\times 10 ^ 5$，$1 \\leq l _ i \\leq r _ i \\leq n$，$1 \\leq a _ i, b _ i \\leq n$ 且 $\\{a _ i\\}$ 和 $\\{b _ i\\}$ 分别构成了从 $1$ 到 $n$ 的排列。\n\n::cute-table{tuack}\n\n| 测试点 | $n$ | $Q$ | 特殊性质 A | 特殊性质 B |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1, 2$ | $\\leq 30$ | $\\leq 30$ | 是 | 是 |\n| $3, 4, 5$ | $\\leq 3,000$ | $\\leq 3,000$ | ^ | ^ |\n| $6, 7$ | $\\leq 10 ^ 5$ | $\\leq 5$ | ^ | ^ |\n| $8, 9$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ | ^ |\n| $10, 11$ | $\\leq 10 ^ 5$ | ^ | 否 | 否 |\n| $12, 13$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ | ^ |\n| $14, 15$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | 是 | 是 |\n| $16, 17$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n| $18, 19$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | ^ | 否 |\n| $20, 21$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n| $22, 23$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | 否 | ^ |\n| $24, 25$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n\n特殊性质 A：保证 $a$ 是均匀随机生成的 $1 \\sim n$ 的排列。\n\n特殊性质 B：保证 $b$ 是均匀随机生成的 $1 \\sim n$ 的排列。", "locale": "zh-CN"}}}
{"pid": "P8869", "type": "P", "difficulty": 1, "samples": [["-1 2", "1"], ["0 -4", "0"], ["-12345 -54321", "-12345"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "传智杯"], "title": "[传智杯 #5 初赛] A-莲子的软件工程学", "background": "在宇宙射线的轰击下，莲子电脑里的一些她自己预定义的函数被损坏了。\n\n对于一名理科生来说，各种软件在学习和研究中是非常重要的。为了尽快恢复她电脑上的软件的正常使用，她需要尽快地重新编写这么一些函数。", "description": "具体而言，给定两个整数 $a,b$，保证 $b\\neq 0$。莲子要实现这样一个函数 $\\operatorname{fun}(a,b)$ 来将 $b$ 的符号转移到 $a$ 上。\n\n具体而言，$\\operatorname{fun}(a,b)=\\operatorname{sgn}(b)\\times |a|$。其中，$\\operatorname{sgn}(b)=\\begin{cases}1&b>0\\\\-1&b<0\\end{cases}$\n\n换而言之：\n\n- 如果 $b$ 是正数，那么 $\\operatorname{fun}(a,b)=+|a|=|a|$；\n- 如果 $b$ 是负数，那么 $\\operatorname{fun}(a,b)=-|a|$。\n", "inputFormat": "- 共一行两个整数 $a,b$。", "outputFormat": "- 共一行一个整数 $\\operatorname{fun}(a,b)$ 的值。", "hint": "对于全部数据，保证 $a,b$ 在 $32$ 位有符号整型范围内，并且 $b \\neq 0$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] A-莲子的软件工程学", "background": "在宇宙射线的轰击下，莲子电脑里的一些她自己预定义的函数被损坏了。\n\n对于一名理科生来说，各种软件在学习和研究中是非常重要的。为了尽快恢复她电脑上的软件的正常使用，她需要尽快地重新编写这么一些函数。", "description": "具体而言，给定两个整数 $a,b$，保证 $b\\neq 0$。莲子要实现这样一个函数 $\\operatorname{fun}(a,b)$ 来将 $b$ 的符号转移到 $a$ 上。\n\n具体而言，$\\operatorname{fun}(a,b)=\\operatorname{sgn}(b)\\times |a|$。其中，$\\operatorname{sgn}(b)=\\begin{cases}1&b>0\\\\-1&b<0\\end{cases}$\n\n换而言之：\n\n- 如果 $b$ 是正数，那么 $\\operatorname{fun}(a,b)=+|a|=|a|$；\n- 如果 $b$ 是负数，那么 $\\operatorname{fun}(a,b)=-|a|$。\n", "inputFormat": "- 共一行两个整数 $a,b$。", "outputFormat": "- 共一行一个整数 $\\operatorname{fun}(a,b)$ 的值。", "hint": "对于全部数据，保证 $a,b$ 在 $32$ 位有符号整型范围内，并且 $b \\neq 0$。", "locale": "zh-CN"}}}
{"pid": "P8870", "type": "P", "difficulty": 2, "samples": [["5 4\n3 3 2 1 1\n3 2 2 1", "4 2 1 1 0\n"], ["10 1\n10 9 8 7 6 5 4 3 2 1\n0\n", "10 9 8 7 6 5 4 3 2 1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "传智杯"], "title": "[传智杯 #5 初赛] B-莲子的机械动力学", "background": "**【题目背景和题目描述的两个题面是完全等价的，您可以选择阅读其中一部分。】**\n\n专攻超统一物理学的莲子，对机械结构的运动颇有了解。如下图所示，是一个三进制加法计算器的（超简化）示意图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l6gm0j36.png)\n\n一个四位的三进制整数，从低到高位，标为 $x_1,x_2,x_3,x_4$。换言之，这个数可以写成 $\\overline{x_4x_3x_2x_1}_{(3)}$。把它放在这四个齿轮里，对应箭头指向的数字就是现在这位的数值。\n\n在这种机械式计算机里，我们通过齿轮的啮合来实现数位间的连接。通过不同齿轮半径的比例来确定进制。图中所有浅灰色的小齿轮的半径，比上使用皮带相接的较大齿轮的半径，都是 $1:3$。那么小齿轮每转动一圈，大齿轮就转动 $\\dfrac{1}{3}$ 圈，也就是刚好一个数码的角度。\n\n于是，我们通过控制齿轮的半径实现了 $3$ 进制的进位。\n\n如果需要实现三进制加法，则只需要在对应数位拨动对应的数码长度即可。\n\n如下是个例子，实现 $\\overline{1021}_{(3)}+\\overline{0021}_{(3)}=\\overline{1112}_{(3)}$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4kcgnp7j.png)\n\n初始时齿轮的状态如上。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dcd66l5v.png)\n\n把第一个齿轮拨动一个单位长度，变为如上图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oiexg3yw.png)\n\n把第二个齿轮拨动两个单位长度，变为如上图所示。读数，得到结果 $\\overline{1112}_{(3)}$。\n\n---\n\n现在莲子设计了如下图所示的机械结构。对于从左往右数的第 $i$ 枚齿轮，它上面的浅色小齿轮与第 $i+1$ 枚齿轮上的深色小齿轮的半径之比为 $1:(i+2)$。也就是说，第 $i$ 枚齿轮每转动 $1$ 圈，第 $i+1$ 枚齿轮转过的角度恰好为它上面的一个数码。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zi1d0qnn.png)\n\n莲子想要知道，在这样的特别的进制表示下，给定 $a,b$，那么计算出的 $a+b$ 的结果是多少。\n", "description": "题目背景的问题可以转化为如下描述：\n\n给定两个长度分别为 $n,m$ 的整数 $a,b$，计算它们的和。\n\n但是要注意的是，这里的 $a,b$ 采用了某种特殊的进制表示法。最终的结果也会采用该种表示法。具体而言，从低位往高位数起，第 $i$ 位采用的是 $i+1$ 进制。换言之，相较于十进制下每一位的「逢 $10$ 进 $1$」，该种进制下第 $i$ 位是「逢 $i+1$ 进 $1$」。\n\n下图所示，左边是十进制的竖式加法；右边是这种特殊进制的竖式加法。图中的红色加号表示上一位发生了进位。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/px92d6yd.png)", "inputFormat": "- 第一行有两个整数 $n,m$，分别表示 $a$ 和 $b$ 的位数。\n- 第二行有 $n$ 个整数，中间用空格隔开，**从高到低位**描述 $a$ 的每个数码。\n- 第三行有 $m$ 个整数，中间用空格隔开，**从高到低位**描述 $b$ 的每个数码。", "outputFormat": "- 输出有若干个整数，从高到低位输出 $a+b$ 在这种特殊表示法下的结果。", "hint": "对于全部数据，保证 $1\\le n,m\\le 2\\times 10^5$，从低位往高位数起有 $a_i\\in[0,i]$，$b_i\\in[0,i]$。请使用 Java 或 Python 语言作答的选手注意输入输出时的效率。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] B-莲子的机械动力学", "background": "**【题目背景和题目描述的两个题面是完全等价的，您可以选择阅读其中一部分。】**\n\n专攻超统一物理学的莲子，对机械结构的运动颇有了解。如下图所示，是一个三进制加法计算器的（超简化）示意图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l6gm0j36.png)\n\n一个四位的三进制整数，从低到高位，标为 $x_1,x_2,x_3,x_4$。换言之，这个数可以写成 $\\overline{x_4x_3x_2x_1}_{(3)}$。把它放在这四个齿轮里，对应箭头指向的数字就是现在这位的数值。\n\n在这种机械式计算机里，我们通过齿轮的啮合来实现数位间的连接。通过不同齿轮半径的比例来确定进制。图中所有浅灰色的小齿轮的半径，比上使用皮带相接的较大齿轮的半径，都是 $1:3$。那么小齿轮每转动一圈，大齿轮就转动 $\\dfrac{1}{3}$ 圈，也就是刚好一个数码的角度。\n\n于是，我们通过控制齿轮的半径实现了 $3$ 进制的进位。\n\n如果需要实现三进制加法，则只需要在对应数位拨动对应的数码长度即可。\n\n如下是个例子，实现 $\\overline{1021}_{(3)}+\\overline{0021}_{(3)}=\\overline{1112}_{(3)}$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4kcgnp7j.png)\n\n初始时齿轮的状态如上。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dcd66l5v.png)\n\n把第一个齿轮拨动一个单位长度，变为如上图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oiexg3yw.png)\n\n把第二个齿轮拨动两个单位长度，变为如上图所示。读数，得到结果 $\\overline{1112}_{(3)}$。\n\n---\n\n现在莲子设计了如下图所示的机械结构。对于从左往右数的第 $i$ 枚齿轮，它上面的浅色小齿轮与第 $i+1$ 枚齿轮上的深色小齿轮的半径之比为 $1:(i+2)$。也就是说，第 $i$ 枚齿轮每转动 $1$ 圈，第 $i+1$ 枚齿轮转过的角度恰好为它上面的一个数码。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zi1d0qnn.png)\n\n莲子想要知道，在这样的特别的进制表示下，给定 $a,b$，那么计算出的 $a+b$ 的结果是多少。\n", "description": "题目背景的问题可以转化为如下描述：\n\n给定两个长度分别为 $n,m$ 的整数 $a,b$，计算它们的和。\n\n但是要注意的是，这里的 $a,b$ 采用了某种特殊的进制表示法。最终的结果也会采用该种表示法。具体而言，从低位往高位数起，第 $i$ 位采用的是 $i+1$ 进制。换言之，相较于十进制下每一位的「逢 $10$ 进 $1$」，该种进制下第 $i$ 位是「逢 $i+1$ 进 $1$」。\n\n下图所示，左边是十进制的竖式加法；右边是这种特殊进制的竖式加法。图中的红色加号表示上一位发生了进位。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/px92d6yd.png)", "inputFormat": "- 第一行有两个整数 $n,m$，分别表示 $a$ 和 $b$ 的位数。\n- 第二行有 $n$ 个整数，中间用空格隔开，**从高到低位**描述 $a$ 的每个数码。\n- 第三行有 $m$ 个整数，中间用空格隔开，**从高到低位**描述 $b$ 的每个数码。", "outputFormat": "- 输出有若干个整数，从高到低位输出 $a+b$ 在这种特殊表示法下的结果。", "hint": "对于全部数据，保证 $1\\le n,m\\le 2\\times 10^5$，从低位往高位数起有 $a_i\\in[0,i]$，$b_i\\in[0,i]$。请使用 Java 或 Python 语言作答的选手注意输入输出时的效率。", "locale": "zh-CN"}}}
{"pid": "P8871", "type": "P", "difficulty": 2, "samples": [["#include<iostream>\nusing namespace std;\nint main(){\n    int a, b;\n    cin >> a >> b;\n    cout << a + b << endl;\n    cout << a - b << endl;\n    cout << a * b << endl;\n    cout << a / b << endl;\n    return 0;\n}\n", " 1 #include<iostream>\n 2 using namespace std;\n 3 int main(){\n 4     int a, b;\n 5     cin >> a >> b;\n 6     cout << a + b << endl;\n 7     cout << a - b << endl;\n 8     cout << a * b << endl;\n 9     cout << a / b << endl;\n10     return 0;\n11 }\n"], ["public class Main {\n    public static void main(String[] args) throws Exception {\n        int b = 0, c = 0;\n        for (int a = 123; a < 333; a++) {\n            int[] array = new int[10];\n            Boolean flag = true;\n            b = a * 2;\n            c = a * 3;\n            array[a / 100] = 1;\n            array[a / 10 % 10] = 1;\n            array[a % 10] = 1;\n\n            array[b / 100] = 1;\n            array[b / 10 % 10] = 1;\n            array[b % 10] = 1;\n\n            array[c / 100] = 1;\n            array[c / 10 % 10] = 1;\n            array[c % 10] = 1;\n            for (int i = 1; i < array.length; i++) {\n                if (array[i] != 1) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag)\n                System.out.println(a + \" \" + b + \" \" + c);\n        }\n    }\n}", " 1 public class Main {\n 2     public static void main(String[] args) throws Exception {\n 3         int b = 0, c = 0;\n 4         for (int a = 123; a < 333; a++) {\n 5             int[] array = new int[10];\n 6             Boolean flag = true;\n 7             b = a * 2;\n 8             c = a * 3;\n 9             array[a / 100] = 1;\n10             array[a / 10 % 10] = 1;\n11             array[a % 10] = 1;\n12 \n13             array[b / 100] = 1;\n14             array[b / 10 % 10] = 1;\n15             array[b % 10] = 1;\n16 \n17             array[c / 100] = 1;\n18             array[c / 10 % 10] = 1;\n19             array[c % 10] = 1;\n20             for (int i = 1; i < array.length; i++) {\n21                 if (array[i] != 1) {\n22                     flag = false;\n23                     break;\n24                 }\n25             }\n26             if (flag)\n27                 System.out.println(a + \" \" + b + \" \" + c);\n28         }\n29     }\n30 }\n"], ["Tao hua kai yo li hua kai, jie jie mei mei dong qi lai;\nTao hua kai yo li hua kai, jie jie mei mei tiao qi lai.\n    Gei ni zi ji, chun yi mai huai (yi ya yo);\n    Gei xin shang ren, chun se man kai.\nTao hua kai yo li hua kai, jie jie mei mei dong qi lai; \nTao hua kai yo li hua kai, jie jie mei mei tiao qi lai.\n    Gei tong bao men, chun yi man huai, hai hai yo;\n    Gei zhe da di, chun se quan kai!!!\nCong na nu jiang nan, dao mo he bei,\n    Dao chu dou you hua rong ming mei.\nLai hui hui shou, zai diao ge tou,\n    Wu xian chun guang zai wo xiong.\nCong jing cheng, dao yuan ye,\n    Dao chu dou you sheng de xi yue.\nLai hui hui shou, zai yan ran huang ge tou,\n    Wu xian CHUN GUANG XIAN ZU GUO!!!\nTao hua kai yo li hua kai, Jiong xian mei mei dong qi lai;\nTao hua kai yo li hua kai, Jie jie mei mei tiao qi lai.\n    Gei ni zi ji, chun yi mai huai chun yi man huai yi ya yo;\n    Gei xin shang ren, chun se man kai chun se man kai.\nTao hua kai yo li hua kai, Jie jie mei mei dong qi lai;\nTao hua kai yo li hua kai, Jie jie mei mei tiao qi lai.\n    Gei tong bao men, chun yi man huai, hai hai yo;\n    Gei zhe da di, chun se quan kai!!!\nCong na nu jiang nan, dao mo he bei,\n    Dao chu dou you hua rong ming mei.\nLai hui hui shou, zai diao ge tou,\n    Wu xian chun guang zai wo xiong.\nCong jing cheng, dao yuan ye,\n    Dao chu dou you sheng de xi yue.\nLai hui hui shou, zai yan ran huang ge tou,\n    Wu xian CHUN GUANG XIAN ZU GUO!!!\nLai hui hui shou, zai yan ran huang ge tou,\n    Wu xian CHUN GUANG XIAN ZU GUO!!!\n", " 1 Tao hua kai yo li hua kai, jie jie mei mei dong qi lai;\n 2 Tao hua kai yo li hua kai, jie jie mei mei tiao qi lai.\n 3     Gei ni zi ji, chun yi mai huai (yi ya yo);\n 4     Gei xin shang ren, chun se man kai.\n 5 Tao hua kai yo li hua kai, jie jie mei mei dong qi lai; \n 6 Tao hua kai yo li hua kai, jie jie mei mei tiao qi lai.\n 7     Gei tong bao men, chun yi man huai, hai hai yo;\n 8     Gei zhe da di, chun se quan kai!!!\n 9 Cong na nu jiang nan, dao mo he bei,\n10     Dao chu dou you hua rong ming mei.\n11 Lai hui hui shou, zai diao ge tou,\n12     Wu xian chun guang zai wo xiong.\n13 Cong jing cheng, dao yuan ye,\n14     Dao chu dou you sheng de xi yue.\n15 Lai hui hui shou, zai yan ran huang ge tou,\n16     Wu xian CHUN GUANG XIAN ZU GUO!!!\n17 Tao hua kai yo li hua kai, Jiong xian mei mei dong qi lai;\n18 Tao hua kai yo li hua kai, Jie jie mei mei tiao qi lai.\n19     Gei ni zi ji, chun yi mai huai chun yi man huai yi ya yo;\n20     Gei xin shang ren, chun se man kai chun se man kai.\n21 Tao hua kai yo li hua kai, Jie jie mei mei dong qi lai;\n22 Tao hua kai yo li hua kai, Jie jie mei mei tiao qi lai.\n23     Gei tong bao men, chun yi man huai, hai hai yo;\n24     Gei zhe da di, chun se quan kai!!!\n25 Cong na nu jiang nan, dao mo he bei,\n26     Dao chu dou you hua rong ming mei.\n27 Lai hui hui shou, zai diao ge tou,\n28     Wu xian chun guang zai wo xiong.\n29 Cong jing cheng, dao yuan ye,\n30     Dao chu dou you sheng de xi yue.\n31 Lai hui hui shou, zai yan ran huang ge tou,\n32     Wu xian CHUN GUANG XIAN ZU GUO!!!\n33 Lai hui hui shou, zai yan ran huang ge tou,\n34     Wu xian CHUN GUANG XIAN ZU GUO!!!\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "传智杯"], "title": "[传智杯 #5 初赛] C-莲子的排版设计学", "background": "> 你现在不能休息，周围有 deadline 在游荡。\n\n莲子正在赶自己的程序设计作业。除了完成程序代码的编写，对提交上去的作业进行排版以对助教留下良好印象同样重要。\n\n而众所周知，文章里面的代码和一些特殊性质的文本是要附上行号的，然而它们的篇幅往往都很长，手动去加容易出现失误。因此，莲子决定自力更生造轮子，写一个行号生成器。", "description": "莲子希望实现这样一个功能：输入一份文本文件，并给该文件加上行号。\n\n以下是本题中三个基本概念的定义：\n\n- **文本字符**由 $\\textsf{ASCII}$ 中所有的可视字符，以及空格（$\\textsf{ASCII}=32$）组成。\n- **一行字符**由若干个（可以为 $0$ 个）文本字符，以及在末尾**恰好一个**换行符（$\\textsf{ASCII}=10$）组成。\n- **文本文件**由若干个（至少为 $1$ 个）一行字符组成。文本文件的行数就是组成它的行的数量。\n\n以下是本题中添加行号的方法：\n\n- 设该文本文件一共有 $m$ 行。设正整数 $m$ 的字宽为 $s$。那么，在每一行的开头会有 $s+1$ 的长度用来显示行号。\n- 对于第 $i$ 行，假设 $i$ 的字宽为 $t$，那么这一行行号将会显示为 $\\underbrace{\\texttt{␣␣...␣}}_{s-t\\text{ 个}}\\ i\\ \\texttt{␣}$，其中 $\\texttt{␣}$ 表示空格。\n\n以下是一个例子：\n\n\n$$\\boxed{\\begin{aligned}\n&\\verb!#include<iostream>!\\\\\n&\\verb!using namespace std;!\\\\\n&\\verb!int main(){!\\\\\n&\\verb!    int a, b;!\\\\\n&\\verb!    cin >> a >> b;!\\\\\n&\\verb!    cout << a + b << endl;!\\\\\n&\\verb!    cout << a - b << endl;!\\\\\n&\\verb!    cout << a * b << endl;!\\\\\n&\\verb!    cout << a / b << endl;!\\\\\n&\\verb!    return 0;!\\\\\n&\\verb!}!\n\\end{aligned}} \\Rightarrow\n\\boxed{\\begin{aligned}\n&\\verb! 1 #include<iostream>!\\\\\n&\\verb! 2 using namespace std;!\\\\\n&\\verb! 3 int main(){!\\\\\n&\\verb! 4     int a, b;!\\\\\n&\\verb! 5     cin >> a >> b;!\\\\\n&\\verb! 6     cout << a + b << endl;!\\\\\n&\\verb! 7     cout << a - b << endl;!\\\\\n&\\verb! 8     cout << a * b << endl;!\\\\\n&\\verb! 9     cout << a / b << endl;!\\\\\n&\\verb!10     return 0;!\\\\\n&\\verb!11 }!\n\\end{aligned}}\n$$\n\n为了便于读者观察，这里将所有的空格换成用来表示空格的 $\\verb!␣!$ 字符。\n\n$$\\boxed{\\begin{aligned}\n&\\verb!#include<iostream>!\\\\\n&\\verb!using␣namespace␣std;!\\\\\n&\\verb!int␣main(){!\\\\\n&\\verb!␣␣␣␣int␣a,␣b;!\\\\\n&\\verb!␣␣␣␣cin␣>>␣a␣>>␣b;!\\\\\n&\\verb!␣␣␣␣cout␣<<␣a␣+␣b␣<<␣endl;!\\\\\n&\\verb!␣␣␣␣cout␣<<␣a␣-␣b␣<<␣endl;!\\\\\n&\\verb!␣␣␣␣cout␣<<␣a␣*␣b␣<<␣endl;!\\\\\n&\\verb!␣␣␣␣cout␣<<␣a␣/␣b␣<<␣endl;!\\\\\n&\\verb!␣␣␣␣return␣0;!\\\\\n&\\verb!}!\n\\end{aligned}} \\Rightarrow\n\\boxed{\\begin{aligned}\n&\\verb!␣1␣#include<iostream>!\\\\\n&\\verb!␣2␣using␣namespace␣std;!\\\\\n&\\verb!␣3␣int␣main(){!\\\\\n&\\verb!␣4␣␣␣␣␣int␣a,␣b;!\\\\\n&\\verb!␣5␣␣␣␣␣cin␣>>␣a␣>>␣b;!\\\\\n&\\verb!␣6␣␣␣␣␣cout␣<<␣a␣+␣b␣<<␣endl;!\\\\\n&\\verb!␣7␣␣␣␣␣cout␣<<␣a␣-␣b␣<<␣endl;!\\\\\n&\\verb!␣8␣␣␣␣␣cout␣<<␣a␣*␣b␣<<␣endl;!\\\\\n&\\verb!␣9␣␣␣␣␣cout␣<<␣a␣/␣b␣<<␣endl;!\\\\\n&\\verb!10␣␣␣␣␣return␣0;!\\\\\n&\\verb!11␣}!\n\\end{aligned}}\n$$", "inputFormat": "输入包含若干行，为原始的文本文件。", "outputFormat": "输出包含若干行，为加上行号后的文本文件。", "hint": "### 数据范围及约定\n\n对于全部数据，保证输入的文本文件的字符总数（包括换行符在内），不超过 $2\\times 10^4$。同时，保证输入数据合法。\n\n评测时，会忽略选手输出文件的行末空格与文末换行。因此选手可以自行决定行尾是否要输出多余空格。请使用 Java 或 Python 语言作答的选手注意输入输出时的效率。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] C-莲子的排版设计学", "background": "> 你现在不能休息，周围有 deadline 在游荡。\n\n莲子正在赶自己的程序设计作业。除了完成程序代码的编写，对提交上去的作业进行排版以对助教留下良好印象同样重要。\n\n而众所周知，文章里面的代码和一些特殊性质的文本是要附上行号的，然而它们的篇幅往往都很长，手动去加容易出现失误。因此，莲子决定自力更生造轮子，写一个行号生成器。", "description": "莲子希望实现这样一个功能：输入一份文本文件，并给该文件加上行号。\n\n以下是本题中三个基本概念的定义：\n\n- **文本字符**由 $\\textsf{ASCII}$ 中所有的可视字符，以及空格（$\\textsf{ASCII}=32$）组成。\n- **一行字符**由若干个（可以为 $0$ 个）文本字符，以及在末尾**恰好一个**换行符（$\\textsf{ASCII}=10$）组成。\n- **文本文件**由若干个（至少为 $1$ 个）一行字符组成。文本文件的行数就是组成它的行的数量。\n\n以下是本题中添加行号的方法：\n\n- 设该文本文件一共有 $m$ 行。设正整数 $m$ 的字宽为 $s$。那么，在每一行的开头会有 $s+1$ 的长度用来显示行号。\n- 对于第 $i$ 行，假设 $i$ 的字宽为 $t$，那么这一行行号将会显示为 $\\underbrace{\\texttt{␣␣...␣}}_{s-t\\text{ 个}}\\ i\\ \\texttt{␣}$，其中 $\\texttt{␣}$ 表示空格。\n\n以下是一个例子：\n\n\n$$\\boxed{\\begin{aligned}\n&\\verb!#include<iostream>!\\\\\n&\\verb!using namespace std;!\\\\\n&\\verb!int main(){!\\\\\n&\\verb!    int a, b;!\\\\\n&\\verb!    cin >> a >> b;!\\\\\n&\\verb!    cout << a + b << endl;!\\\\\n&\\verb!    cout << a - b << endl;!\\\\\n&\\verb!    cout << a * b << endl;!\\\\\n&\\verb!    cout << a / b << endl;!\\\\\n&\\verb!    return 0;!\\\\\n&\\verb!}!\n\\end{aligned}} \\Rightarrow\n\\boxed{\\begin{aligned}\n&\\verb! 1 #include<iostream>!\\\\\n&\\verb! 2 using namespace std;!\\\\\n&\\verb! 3 int main(){!\\\\\n&\\verb! 4     int a, b;!\\\\\n&\\verb! 5     cin >> a >> b;!\\\\\n&\\verb! 6     cout << a + b << endl;!\\\\\n&\\verb! 7     cout << a - b << endl;!\\\\\n&\\verb! 8     cout << a * b << endl;!\\\\\n&\\verb! 9     cout << a / b << endl;!\\\\\n&\\verb!10     return 0;!\\\\\n&\\verb!11 }!\n\\end{aligned}}\n$$\n\n为了便于读者观察，这里将所有的空格换成用来表示空格的 $\\verb!␣!$ 字符。\n\n$$\\boxed{\\begin{aligned}\n&\\verb!#include<iostream>!\\\\\n&\\verb!using␣namespace␣std;!\\\\\n&\\verb!int␣main(){!\\\\\n&\\verb!␣␣␣␣int␣a,␣b;!\\\\\n&\\verb!␣␣␣␣cin␣>>␣a␣>>␣b;!\\\\\n&\\verb!␣␣␣␣cout␣<<␣a␣+␣b␣<<␣endl;!\\\\\n&\\verb!␣␣␣␣cout␣<<␣a␣-␣b␣<<␣endl;!\\\\\n&\\verb!␣␣␣␣cout␣<<␣a␣*␣b␣<<␣endl;!\\\\\n&\\verb!␣␣␣␣cout␣<<␣a␣/␣b␣<<␣endl;!\\\\\n&\\verb!␣␣␣␣return␣0;!\\\\\n&\\verb!}!\n\\end{aligned}} \\Rightarrow\n\\boxed{\\begin{aligned}\n&\\verb!␣1␣#include<iostream>!\\\\\n&\\verb!␣2␣using␣namespace␣std;!\\\\\n&\\verb!␣3␣int␣main(){!\\\\\n&\\verb!␣4␣␣␣␣␣int␣a,␣b;!\\\\\n&\\verb!␣5␣␣␣␣␣cin␣>>␣a␣>>␣b;!\\\\\n&\\verb!␣6␣␣␣␣␣cout␣<<␣a␣+␣b␣<<␣endl;!\\\\\n&\\verb!␣7␣␣␣␣␣cout␣<<␣a␣-␣b␣<<␣endl;!\\\\\n&\\verb!␣8␣␣␣␣␣cout␣<<␣a␣*␣b␣<<␣endl;!\\\\\n&\\verb!␣9␣␣␣␣␣cout␣<<␣a␣/␣b␣<<␣endl;!\\\\\n&\\verb!10␣␣␣␣␣return␣0;!\\\\\n&\\verb!11␣}!\n\\end{aligned}}\n$$", "inputFormat": "输入包含若干行，为原始的文本文件。", "outputFormat": "输出包含若干行，为加上行号后的文本文件。", "hint": "### 数据范围及约定\n\n对于全部数据，保证输入的文本文件的字符总数（包括换行符在内），不超过 $2\\times 10^4$。同时，保证输入数据合法。\n\n评测时，会忽略选手输出文件的行末空格与文末换行。因此选手可以自行决定行尾是否要输出多余空格。请使用 Java 或 Python 语言作答的选手注意输入输出时的效率。", "locale": "zh-CN"}}}
{"pid": "P8872", "type": "P", "difficulty": 3, "samples": [["3 2\n5 1 4", "0"], ["8 0\n1 2 3 4 5 6 7 8", "7\n"], ["8 3\n1 5 5 5 6 6 9 10\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "传智杯"], "title": "[传智杯 #5 初赛] D-莲子的物理热力学", "background": "莲子正在研究分子的运动。\n\n每个分子都有一个速度，约定正方向为正，负方向为负。分子的数量极多，速度又并不一致，看上去杂乱无章。于是莲子希望调整部分分子的速度，使得最终分子们看上去整齐。", "description": "莲子给定了 $n$ 个整数 $a_1,a_2,\\cdots a_n$，描述每个分子。现在她可以进行**至多** $m$ 次操作（也可以一次也不进行），每次操作可以执行以下两条之一：\n\n- 选择 $i$，满足 $a_i=\\min_j\\{a_j\\}$，然后将 $a_i$ 变为 $\\max_j\\{a_j\\}$。\n- 选择 $i$，满足 $a_i=\\max_j\\{a_j\\}$，然后将 $a_i$ 变为 $\\min_j\\{a_j\\}$。\n\n现在莲子希望需要最小化最终序列的极差（最大值减去最小值的差）。请求出最小的极差。\n\n---\n\n例如，对于序列 $a=\\{5,1,4\\}$，可以进行如下几次操作：\n\n- 选择 $i=1$，满足 $a_1=5$ 是当前的最大值 $5$，可以将 $a_1$ 修改成当前的最小值 $1$，此时序列变成 $\\{1,1,4\\}$；\n- 再选 $i=2$，满足 $a_2=1$ 是当前的最小值 $1$，可以将 $a_2$ 修改成当前的最大值 $4$，此时序列变成 $\\{1,4,4\\}$。 \n\n这两次操作后得到的序列为 $\\{1,4,4\\}$。最大值减去最小值的差为 $|4-1|=3$。\n\n当然，这种操作方式得到的极差并非最小。最优策略是，先将最大值 $a_1=5$ 变成目前的最小值 $1$，再把此时的最大值 $a_3=4$ 变成目前的最小值 $1$。此时序列为 $\\{1,1,1\\}$，得到的极差 $|1-1|=0$ 是所有策略中最小的。\n\n", "inputFormat": "- 第一行有两个正整数 $n,m$，分别表示序列的长度和你最多可以进行的操作次数。\n- 第二行有 $n$ 个整数 $a$，描述给定的序列。", "outputFormat": "- 输出共一行一个整数，表示最优策略下能得到的最小极差。", "hint": "### 样例解释\n\n样例 $1$：$\\{5,1,4\\}\\to\\{1,1,4\\}\\to\\{1,1,1\\}$，极差为 $0$。  \n样例 $2$：$\\{1,2,3,4,5,6,7,8\\}$，什么也做不了，极差为 $7$。  \n样例 $3$：$\\{1,5,5,5,6,6,9,10\\}\\to\\{10,5,5,5,6,6,9,10\\}\\to\\{5,5,5,5,6,6,9,10\\}\\to\\{5,5,5,5,6,6,9,5\\}$，极差为 $4$。\n\n### 数据范围及约定\n\n对于全部数据，保证 $1\\le n \\le 10^5$，$0\\le m\\le10^9$，$|a_i|\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] D-莲子的物理热力学", "background": "莲子正在研究分子的运动。\n\n每个分子都有一个速度，约定正方向为正，负方向为负。分子的数量极多，速度又并不一致，看上去杂乱无章。于是莲子希望调整部分分子的速度，使得最终分子们看上去整齐。", "description": "莲子给定了 $n$ 个整数 $a_1,a_2,\\cdots a_n$，描述每个分子。现在她可以进行**至多** $m$ 次操作（也可以一次也不进行），每次操作可以执行以下两条之一：\n\n- 选择 $i$，满足 $a_i=\\min_j\\{a_j\\}$，然后将 $a_i$ 变为 $\\max_j\\{a_j\\}$。\n- 选择 $i$，满足 $a_i=\\max_j\\{a_j\\}$，然后将 $a_i$ 变为 $\\min_j\\{a_j\\}$。\n\n现在莲子希望需要最小化最终序列的极差（最大值减去最小值的差）。请求出最小的极差。\n\n---\n\n例如，对于序列 $a=\\{5,1,4\\}$，可以进行如下几次操作：\n\n- 选择 $i=1$，满足 $a_1=5$ 是当前的最大值 $5$，可以将 $a_1$ 修改成当前的最小值 $1$，此时序列变成 $\\{1,1,4\\}$；\n- 再选 $i=2$，满足 $a_2=1$ 是当前的最小值 $1$，可以将 $a_2$ 修改成当前的最大值 $4$，此时序列变成 $\\{1,4,4\\}$。 \n\n这两次操作后得到的序列为 $\\{1,4,4\\}$。最大值减去最小值的差为 $|4-1|=3$。\n\n当然，这种操作方式得到的极差并非最小。最优策略是，先将最大值 $a_1=5$ 变成目前的最小值 $1$，再把此时的最大值 $a_3=4$ 变成目前的最小值 $1$。此时序列为 $\\{1,1,1\\}$，得到的极差 $|1-1|=0$ 是所有策略中最小的。\n\n", "inputFormat": "- 第一行有两个正整数 $n,m$，分别表示序列的长度和你最多可以进行的操作次数。\n- 第二行有 $n$ 个整数 $a$，描述给定的序列。", "outputFormat": "- 输出共一行一个整数，表示最优策略下能得到的最小极差。", "hint": "### 样例解释\n\n样例 $1$：$\\{5,1,4\\}\\to\\{1,1,4\\}\\to\\{1,1,1\\}$，极差为 $0$。  \n样例 $2$：$\\{1,2,3,4,5,6,7,8\\}$，什么也做不了，极差为 $7$。  \n样例 $3$：$\\{1,5,5,5,6,6,9,10\\}\\to\\{10,5,5,5,6,6,9,10\\}\\to\\{5,5,5,5,6,6,9,10\\}\\to\\{5,5,5,5,6,6,9,5\\}$，极差为 $4$。\n\n### 数据范围及约定\n\n对于全部数据，保证 $1\\le n \\le 10^5$，$0\\le m\\le10^9$，$|a_i|\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P8873", "type": "P", "difficulty": 3, "samples": [["9\n1\n10\n100\n1000\n10000\n100000\n1000000\n10000000\n100000000", "0\n1\n6\n-9\n-11\n-128\n406\n1629\n5154"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "二分", "传智杯"], "title": "[传智杯 #5 初赛] E-梅莉的市场经济学", "background": "梅莉这个学期选修了经济学。但是主修心理学的她实在不擅长经济领域的分析，为此她时常抱怨自己学不会，想退课。\n\n但是如果现在退掉的话这学期的学分就不够啦，因此她根据“梦中”的经历，“胡诌”了一个简单到不现实的市场模型，并依据这个模型编起了 essay。为了方便地编出图表，她需要写一个程序来查询每个时刻的市场贸易差。", "description": "市场每一天的贸易差可以视为一个有周期性规律的数列 $a$：$\\color{red}[0],\\color{blue}[0,\\allowbreak 1,\\allowbreak 0,\\allowbreak -1,\\allowbreak 0],\\color{red}[0,\\allowbreak 1,\\allowbreak 2,\\allowbreak 1,\\allowbreak 0,\\allowbreak -1,\\allowbreak -2,\\allowbreak -1,\\allowbreak 0],\\allowbreak \\color{blue}[0,\\allowbreak 1,\\allowbreak 2,\\allowbreak 3,\\allowbreak 2,\\allowbreak 1,\\allowbreak 0,\\allowbreak -1,\\allowbreak -2,\\allowbreak -3,\\allowbreak -2,\\allowbreak -1,\\allowbreak 0]\\dots$ 具体而言，$a$ 可以被分为无穷段，第 $i$ 段的内容为 $\\{0,\\allowbreak 1,\\allowbreak \\cdots,\\allowbreak i,\\allowbreak i-1,\\allowbreak \\cdots,0,\\allowbreak -1,\\allowbreak \\cdots,\\allowbreak -i,\\allowbreak -i+1,\\allowbreak \\cdots 0\\}$。如下图所示，是将 $a$ 数列内的前一些点绘制在坐标轴上的情况：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wrl89jka.png)\n\n现在梅莉对市场发起了 $q$ 次询问，每次她会给定一个 $k$，希望求出 $a_k$ 是多少。", "inputFormat": "- 第一行有一个正整数 $q$，表示询问次数。\n- 接下来 $q$ 行，每行一个正整数 $k$，描述每次询问。", "outputFormat": "- 输出共 $q$ 行。对于每次询问，输出对应的结果。", "hint": "对于所有数据，$1 \\leq q \\leq 10^5$，$1 \\leq k \\leq 4\\times 10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] E-梅莉的市场经济学", "background": "梅莉这个学期选修了经济学。但是主修心理学的她实在不擅长经济领域的分析，为此她时常抱怨自己学不会，想退课。\n\n但是如果现在退掉的话这学期的学分就不够啦，因此她根据“梦中”的经历，“胡诌”了一个简单到不现实的市场模型，并依据这个模型编起了 essay。为了方便地编出图表，她需要写一个程序来查询每个时刻的市场贸易差。", "description": "市场每一天的贸易差可以视为一个有周期性规律的数列 $a$：$\\color{red}[0],\\color{blue}[0,\\allowbreak 1,\\allowbreak 0,\\allowbreak -1,\\allowbreak 0],\\color{red}[0,\\allowbreak 1,\\allowbreak 2,\\allowbreak 1,\\allowbreak 0,\\allowbreak -1,\\allowbreak -2,\\allowbreak -1,\\allowbreak 0],\\allowbreak \\color{blue}[0,\\allowbreak 1,\\allowbreak 2,\\allowbreak 3,\\allowbreak 2,\\allowbreak 1,\\allowbreak 0,\\allowbreak -1,\\allowbreak -2,\\allowbreak -3,\\allowbreak -2,\\allowbreak -1,\\allowbreak 0]\\dots$ 具体而言，$a$ 可以被分为无穷段，第 $i$ 段的内容为 $\\{0,\\allowbreak 1,\\allowbreak \\cdots,\\allowbreak i,\\allowbreak i-1,\\allowbreak \\cdots,0,\\allowbreak -1,\\allowbreak \\cdots,\\allowbreak -i,\\allowbreak -i+1,\\allowbreak \\cdots 0\\}$。如下图所示，是将 $a$ 数列内的前一些点绘制在坐标轴上的情况：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wrl89jka.png)\n\n现在梅莉对市场发起了 $q$ 次询问，每次她会给定一个 $k$，希望求出 $a_k$ 是多少。", "inputFormat": "- 第一行有一个正整数 $q$，表示询问次数。\n- 接下来 $q$ 行，每行一个正整数 $k$，描述每次询问。", "outputFormat": "- 输出共 $q$ 行。对于每次询问，输出对应的结果。", "hint": "对于所有数据，$1 \\leq q \\leq 10^5$，$1 \\leq k \\leq 4\\times 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P8874", "type": "P", "difficulty": 3, "samples": [["6 40 5 3\n10 20 30\n15 25 35\n6 8 12\n6 12 18\n8 16 24\n8 12 40\n1 2 3 4 5 6\n1 4\n2 3\n1 2\n2 5\n1 3\n1 2\n2 1\n1 5\n2 3\n1 3\n2 4\n1 4\n1 6\n2 2\n1 3\n2 1\n1 3\n2 1", "Merry"], ["6 9961 5 3\n10 20 30\n15 25 35\n6 8 12\n6 12 18\n8 16 24\n8 12 40\n1 2 3 4 5 6\n1 4\n2 3\n1 2\n2 5\n1 3\n1 2\n2 1\n1 5\n2 3\n1 3\n2 4\n1 4\n1 6\n2 2\n1 3\n2 1\n1 3\n2 1", "10099 9946"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "传智杯"], "title": "[传智杯 #5 初赛] F-二人的大富翁游戏", "background": "作为大学生，莲子和梅莉有着比高中时更为闲暇的课余时光。在没有课的时候，她们喜欢玩大富翁这一游戏，在游玩过程中交流自己的喜怒哀乐。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/u7z3486k.png)\n\n如图所示，是一个 $n=10$ 的大富翁地图。玩家在圆格子上行动。而方格子则可以建造建筑物。每个圆格子唯一对应一个方格子。\n\n**（友情提示：赌博是不对的）**", "description": "莲子和梅莉在玩大富翁游戏。这个大富翁游戏是由传智播客定制的，**与一般的大富翁游戏在玩法上有略微区别**，因此也被称为传智大富翁。\n\n大富翁游戏是由 $n$ 个格子组成，编号逆时针地从 $1,2,\\dots,n$，构成了一个环。莲子和梅莉起始在编号为 $1$ 的格子。莲子和梅莉最开始都有 $m$ 元资金。每一个回合，莲子先投掷骰子，再是梅莉投掷骰子。每一方行动时，设骰子最上面的数字为 $k$，则行动方逆时针移动 $k$ 步。在移动的过程中，行动者所经过的每一个格子应当都分为两种情况：\n\n- 如果当前格子（假设编号为 $i$）上有建筑物，而且建筑物是自己的，则行动方可以获得额外的 $a_i$ 元资金。\n- 如果当前格子上有建筑物，但是建筑物是对方的，则行动方要将自己的 $a_i$ 元资金转移给对方。\n\n在行动结束后亦有两种情况：\n\n- 如果当前格子（设编号为 $i$）上没有建筑物，则行动方可以选择花费 $C_{i,0}$ 元资金（前提要求行动者当前的资金大于等于 $C_{i,0}$）搭建建筑物，此时 $a_i$ 被初始化为 $C_{i,0}$。\n- 如果当前格子的建筑物是行动方的，假设当前是一座 $j$ 等级的建筑物，那么行动方可以选择用 $C_{i,j}$ 元为建筑物升级，功效是使得 $a_i \\gets a_i+C_{i,j}$。这里，$C_{i,j}$ 表示将第 $i$ 个格子上的第 $j$ 等级的建筑物升级到第 $j+1$ 等级的建筑物所需花费的资金。同一回合内可以多次升级建筑。特别地，建筑物的等级上限为 $L$。如果当前建筑物等级已经到达上限则无法升级。\n- 在所有建筑操作结束后，操作权转移给另一方。\n\n两人都操作完一轮回合后，圆环上的每个建筑物都会提供给拥有者资金，具体来说，第 $i$ 格上的建筑物会给其拥有者提供 $d_i$ 的资金。游戏结束当且仅当存在一个人在它行动过程中或者结束时的资金为负数。此时这个人成为输家（换而言之，允许中途过程资金为 $0$）。\n\n给定莲子和梅莉的 $q$ 个回合的每次操作，请问谁会是输家呢？", "inputFormat": "第一行输入四个正整数 $n,m,q,L$，表示格子数、初始资金、回合次数和建筑物等级上限。\n\n第二行开始，往下 $n$ 行，每行输入 $L$ 个正整数，表示 $C_{i,j}$，其中 $j$ 是从 $0$ 到 $L-1$。\n\n第 $(n+2)$ 行输入 $n$ 个正整数表示 $d_i$。\n\n第 $(n+3)$ 行开始，往下若干行，每行只会有两种可能的情况：\n\n- $\\texttt{1 k}$，表示当前行动方投掷了骰子，最上面的点数是 $k$。之后行动者会逆时针移动 $k$ 步。\n- $\\texttt{2 k}$，表示当前行动方在当前位置**建造或者升级**了建筑物共 $k$ 次。\n  - 在此过程中，当前位置已经有了对方建筑物则忽略此操作；\n  - 如果资金不够升级 $k$ 次，则只升级到资金允许范围内的最高等级；\n  - 在此过程中，如果进行下一次升级，建筑物等级超过 $L$，则后续的所有升级忽略处理。\n\n特别地，规定除了第一次外，每次 $\\texttt{1 k}$ 操作出现时意味着行动者的切换。也就是说，第一次输入 $\\texttt{1 k}$ 操作时，行动方是莲子，第二次是梅莉，第三次是莲子……以此类推。值得注意的是，$\\texttt{2 k}$ 操作出现**并不会**切换行动者。\n\n此外，**保证每个 $\\bm 1$ 操作后面最多跟随 $\\bm 1$ 个 $\\bm 2$ 操作**。", "outputFormat": "如果已经分出了输赢，则输出谁是输家（如果莲子输，则输出 $\\texttt{Renko}$；如果梅莉输，则输出 $\\texttt{Merry}$）；\n\n如果没有分出输赢，则按照先莲子，后梅莉的顺序输出她们现在有的资金数。", "hint": "**【样例解释 1】**\n\n第一回合，莲子首先走 $4$ 步，到达编号为 $5$ 的格子，同时尝试建造与升级 $3$ 次第五个格子的建筑物，但是 $C_{5,0}+C_{5,1}+C_{5,2}=48$，所以只能把建筑物造到 $2$ 级。此时莲子手上还有 $16$ 元。    \n接着梅莉走了两步，到达编号为 $3$ 的格子，同时尝试建造与升级 $5$ 次第三个格子的建筑物，$C_{3,0}+C_{3,1}+C_{3,2}=26$，而造五次会超过等级上限 $L$，因此只能升到 $3$ 次，此时梅莉手上还有 $14$ 元。    \n回合结束后每个建筑物都会提供给拥有者 $d_i$ 的资金，也就是说莲子此时手上有 $21$ 元，梅莉手上有 $17$ 元。    \n第二回合，莲子首先走 $3$ 步，到达编号为 $2$ 的格子。梅莉接着走 $2$ 步，到达编号为 $5$ 的格子，收取 $a_i$ 元。而 $a_i=24$，因此梅莉的资金被扣成了负数，从而输出 $\\texttt{Merry}$。\n\n**【样例解释 2】**\n\n仅在初始资金与第一组样例有一定变化，因此在这些回合中无法决出胜负，因此输出两人手上现有的资金。\n\n**【数据范围】**\n\n对于所有数据，保证 $1 \\leq n,L\\leq 100$，$1 \\leq q \\leq 10^4$，$1 \\leq m,C_{i,j},d_i \\leq 10^6$，$1 \\leq k \\leq 10^3$（你可以不必在意怎么获得一个 $k$ 面的骰子）。数据保证 $1$ 操作次数恰好为 $2\\times q$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] F-二人的大富翁游戏", "background": "作为大学生，莲子和梅莉有着比高中时更为闲暇的课余时光。在没有课的时候，她们喜欢玩大富翁这一游戏，在游玩过程中交流自己的喜怒哀乐。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/u7z3486k.png)\n\n如图所示，是一个 $n=10$ 的大富翁地图。玩家在圆格子上行动。而方格子则可以建造建筑物。每个圆格子唯一对应一个方格子。\n\n**（友情提示：赌博是不对的）**", "description": "莲子和梅莉在玩大富翁游戏。这个大富翁游戏是由传智播客定制的，**与一般的大富翁游戏在玩法上有略微区别**，因此也被称为传智大富翁。\n\n大富翁游戏是由 $n$ 个格子组成，编号逆时针地从 $1,2,\\dots,n$，构成了一个环。莲子和梅莉起始在编号为 $1$ 的格子。莲子和梅莉最开始都有 $m$ 元资金。每一个回合，莲子先投掷骰子，再是梅莉投掷骰子。每一方行动时，设骰子最上面的数字为 $k$，则行动方逆时针移动 $k$ 步。在移动的过程中，行动者所经过的每一个格子应当都分为两种情况：\n\n- 如果当前格子（假设编号为 $i$）上有建筑物，而且建筑物是自己的，则行动方可以获得额外的 $a_i$ 元资金。\n- 如果当前格子上有建筑物，但是建筑物是对方的，则行动方要将自己的 $a_i$ 元资金转移给对方。\n\n在行动结束后亦有两种情况：\n\n- 如果当前格子（设编号为 $i$）上没有建筑物，则行动方可以选择花费 $C_{i,0}$ 元资金（前提要求行动者当前的资金大于等于 $C_{i,0}$）搭建建筑物，此时 $a_i$ 被初始化为 $C_{i,0}$。\n- 如果当前格子的建筑物是行动方的，假设当前是一座 $j$ 等级的建筑物，那么行动方可以选择用 $C_{i,j}$ 元为建筑物升级，功效是使得 $a_i \\gets a_i+C_{i,j}$。这里，$C_{i,j}$ 表示将第 $i$ 个格子上的第 $j$ 等级的建筑物升级到第 $j+1$ 等级的建筑物所需花费的资金。同一回合内可以多次升级建筑。特别地，建筑物的等级上限为 $L$。如果当前建筑物等级已经到达上限则无法升级。\n- 在所有建筑操作结束后，操作权转移给另一方。\n\n两人都操作完一轮回合后，圆环上的每个建筑物都会提供给拥有者资金，具体来说，第 $i$ 格上的建筑物会给其拥有者提供 $d_i$ 的资金。游戏结束当且仅当存在一个人在它行动过程中或者结束时的资金为负数。此时这个人成为输家（换而言之，允许中途过程资金为 $0$）。\n\n给定莲子和梅莉的 $q$ 个回合的每次操作，请问谁会是输家呢？", "inputFormat": "第一行输入四个正整数 $n,m,q,L$，表示格子数、初始资金、回合次数和建筑物等级上限。\n\n第二行开始，往下 $n$ 行，每行输入 $L$ 个正整数，表示 $C_{i,j}$，其中 $j$ 是从 $0$ 到 $L-1$。\n\n第 $(n+2)$ 行输入 $n$ 个正整数表示 $d_i$。\n\n第 $(n+3)$ 行开始，往下若干行，每行只会有两种可能的情况：\n\n- $\\texttt{1 k}$，表示当前行动方投掷了骰子，最上面的点数是 $k$。之后行动者会逆时针移动 $k$ 步。\n- $\\texttt{2 k}$，表示当前行动方在当前位置**建造或者升级**了建筑物共 $k$ 次。\n  - 在此过程中，当前位置已经有了对方建筑物则忽略此操作；\n  - 如果资金不够升级 $k$ 次，则只升级到资金允许范围内的最高等级；\n  - 在此过程中，如果进行下一次升级，建筑物等级超过 $L$，则后续的所有升级忽略处理。\n\n特别地，规定除了第一次外，每次 $\\texttt{1 k}$ 操作出现时意味着行动者的切换。也就是说，第一次输入 $\\texttt{1 k}$ 操作时，行动方是莲子，第二次是梅莉，第三次是莲子……以此类推。值得注意的是，$\\texttt{2 k}$ 操作出现**并不会**切换行动者。\n\n此外，**保证每个 $\\bm 1$ 操作后面最多跟随 $\\bm 1$ 个 $\\bm 2$ 操作**。", "outputFormat": "如果已经分出了输赢，则输出谁是输家（如果莲子输，则输出 $\\texttt{Renko}$；如果梅莉输，则输出 $\\texttt{Merry}$）；\n\n如果没有分出输赢，则按照先莲子，后梅莉的顺序输出她们现在有的资金数。", "hint": "**【样例解释 1】**\n\n第一回合，莲子首先走 $4$ 步，到达编号为 $5$ 的格子，同时尝试建造与升级 $3$ 次第五个格子的建筑物，但是 $C_{5,0}+C_{5,1}+C_{5,2}=48$，所以只能把建筑物造到 $2$ 级。此时莲子手上还有 $16$ 元。    \n接着梅莉走了两步，到达编号为 $3$ 的格子，同时尝试建造与升级 $5$ 次第三个格子的建筑物，$C_{3,0}+C_{3,1}+C_{3,2}=26$，而造五次会超过等级上限 $L$，因此只能升到 $3$ 次，此时梅莉手上还有 $14$ 元。    \n回合结束后每个建筑物都会提供给拥有者 $d_i$ 的资金，也就是说莲子此时手上有 $21$ 元，梅莉手上有 $17$ 元。    \n第二回合，莲子首先走 $3$ 步，到达编号为 $2$ 的格子。梅莉接着走 $2$ 步，到达编号为 $5$ 的格子，收取 $a_i$ 元。而 $a_i=24$，因此梅莉的资金被扣成了负数，从而输出 $\\texttt{Merry}$。\n\n**【样例解释 2】**\n\n仅在初始资金与第一组样例有一定变化，因此在这些回合中无法决出胜负，因此输出两人手上现有的资金。\n\n**【数据范围】**\n\n对于所有数据，保证 $1 \\leq n,L\\leq 100$，$1 \\leq q \\leq 10^4$，$1 \\leq m,C_{i,j},d_i \\leq 10^6$，$1 \\leq k \\leq 10^3$（你可以不必在意怎么获得一个 $k$ 面的骰子）。数据保证 $1$ 操作次数恰好为 $2\\times q$。", "locale": "zh-CN"}}}
{"pid": "P8875", "type": "P", "difficulty": 4, "samples": [["3 4\n1 2 3 4\n5 6 7 8\n9 10 11 12\n2 2\n1 0\n0 1\n2\n1 1 3 4\n1 2 3 3\n", "40\n20\n"], ["4 4\n1 3 2 4\n5 4 2 3\n4 1 2 3\n3 4 4 3\n1 3\n1 0 0\n3\n1 1 3 4\n2 2 4 4\n1 2 3 2\n", "14\n17\n0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["前缀和", "差分", "传智杯"], "title": "[传智杯 #5 初赛] G-二人的花纹纸游戏", "background": "梅莉买到了一张特殊的带有花纹的纸。整张纸的图案可以视为，由一个较小的图案，沿着横向与纵向无限循环而成。同时，这个基本图案部分透明，部分不透明。\n\n于是，如果将这张纸覆盖在书本上，那么一些字可以被看见，另一些字看不见。\n\n莲子突发奇想：假使她制作一张很大很大的数表，将花纹纸覆盖在上面，那么就会有很多数字被遮挡。那些没有被遮挡的数字的和是多少呢？", "description": "事实上，二人的问题可以转化成如下描述：给定一个 $n$ 行 $m$ 列的普通矩阵 $A$，以及一个 $r$ 行 $c$ 列的 $01$ 矩阵 $B$。$B$ 中为 $1$ 的格子是黑色，不透明；为 $0$ 的格子是透明的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6z0uo690.png)\n\n使用 $B$ 矩阵，循环生成一个**无穷大**的矩阵 $M$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/laycum3q.png)\n\n现在有 $q$ 次询问。每次将 $M$ 矩阵左上角和 $(x_1,y_1)$ 对齐，此时此时会有一些 $A$ 中的元素被遮挡，另一些元素可以被看见。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dtpe8m5u.png)\n\n求出此时，$A$ 当中以 $(x_1,y_1)$ 作为左上角，$(x_2,y_2)$ 作为右下角的子矩阵中，可以被看见的元素之和。结果对 $998{,}244{,}353$ 取模。\n\n在上面的例子里，$(x_1,y_1)=(2,3)$，$(x_2,y_2)=(4,7)$。可以被看见的元素之和为 $a_{2,3}+a_{2,5}+a_{2,6}+a_{3,5}+a_{4,3}+a_{4,5}+a_{4,6}$。\n\n### 形式化题面\n\n给定一个 $n$ 行 $m$ 列的普通矩阵 $A$，以及一个 $r$ 行 $c$ 列的 $01$ 矩阵 $B$。使用 $B$ 矩阵，生成一个**无穷大**的矩阵 $M$：\n\n$$M=\n\\begin{pmatrix}\nB & B & B  &\\cdots \\\\\nB & B & B  &\\cdots \\\\\nB & B & B  &\\cdots \\\\\n\\vdots &\\vdots &\\vdots &\n\\end{pmatrix}\n=\\begin{pmatrix}\nb_{1,1} & b_{1,2} & \\cdots & b_{1,c} & b_{1,1} & b_{1,2} & \\cdots & b_{1,c} & b_{1,1} & \\cdots \\\\\nb_{2,1} & b_{2,2} & \\cdots & b_{2,c} & b_{2,1} & b_{2,2} & \\cdots & b_{2,c} & b_{2,1} & \\cdots \\\\\n\\vdots & \\vdots & & \\vdots & \\vdots & \\vdots & & \\vdots & \\vdots &  \\\\\nb_{r,1} & b_{r,2} & \\cdots & b_{r,c} & b_{r,1} & b_{r,2} & \\cdots & b_{r,c} & b_{r,1} & \\cdots \\\\\nb_{1,1} & b_{1,2} & \\cdots & b_{1,c} & b_{1,1} & b_{1,2} & \\cdots & b_{1,c} & b_{1,1} & \\cdots \\\\\nb_{2,1} & b_{2,2} & \\cdots & b_{2,c} & b_{2,1} & b_{2,2} & \\cdots & b_{2,c} & b_{2,1} & \\cdots \\\\\n\\vdots & \\vdots & & \\vdots & \\vdots & \\vdots & & \\vdots & \\vdots &  \\\\\nb_{r,1} & b_{r,2} & \\cdots & b_{r,c} & b_{r,1} & b_{r,2} & \\cdots & b_{r,c} & b_{r,1} & \\cdots \\\\\n\\vdots & \\vdots & & \\vdots & \\vdots & \\vdots & & \\vdots & \\vdots &  \\\\\n\\end{pmatrix}$$\n\n现在有 $q$ 次询问，每次给出一个子矩阵的左上角坐标 $(x_1,y_1)$ 和右下角坐标 $(x_2,y_2)$，你需要求出：\n\n$$S=\\left(\\sum_{i=x_1}^{x_2}\\sum_{j=y_1}^{y_2}a_{i,j}\\times [M_{i-x_1+1,j-y_1+1}=0] \\right)\\bmod 998{,}244{,}353$$\n\n其中 $[P]$ 表示艾弗森括号。若 $P$ 为真，则 $[P]=1$，否则 $[P]=0$。", "inputFormat": "- 第一行有两个正整数 $n,m$，描述矩阵 $A$ 的大小。\n- 接下来 $n$ 行 $m$ 列，每行一个非负整数，描述 $A$ 中的元素 $a_{i,j}$。\n- 下一行有两个正整数 $r,c$，描述矩阵 $B$ 的大小。\n- 接下来 $r$ 行 $c$ 列，每行一个非负整数，描述 $B$ 中的元素 $b_{i,j}$。\n- 下一行有一个正整数 $q$，表示询问的次数。\n- 接下来 $q$ 行，每行有四个正整数 $x_1,y_1,x_2,y_2$，描述一组询问。保证 $x_1\\le x_2$，$y_1\\le y_2$。", "outputFormat": "- 输出共 $q$ 行。每行输出该次询问的答案。", "hint": "### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z7yeiipu.png)\n\n- 对于第一次询问，结果为 $2+4+5+7+10+12=40$；\n- 对于第二次询问，结果为 $3+6+11=20$。\n\n### 数据范围及约定\n\n对于全部数据，保证 $1\\le n,m\\le 10^3$，$1\\le q\\le 10^4$，$1\\le r,c\\le 50$，$0\\le a_{i,j}<998{,}244{,}353$，$b_{i,j}\\in\\{0,1\\}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] G-二人的花纹纸游戏", "background": "梅莉买到了一张特殊的带有花纹的纸。整张纸的图案可以视为，由一个较小的图案，沿着横向与纵向无限循环而成。同时，这个基本图案部分透明，部分不透明。\n\n于是，如果将这张纸覆盖在书本上，那么一些字可以被看见，另一些字看不见。\n\n莲子突发奇想：假使她制作一张很大很大的数表，将花纹纸覆盖在上面，那么就会有很多数字被遮挡。那些没有被遮挡的数字的和是多少呢？", "description": "事实上，二人的问题可以转化成如下描述：给定一个 $n$ 行 $m$ 列的普通矩阵 $A$，以及一个 $r$ 行 $c$ 列的 $01$ 矩阵 $B$。$B$ 中为 $1$ 的格子是黑色，不透明；为 $0$ 的格子是透明的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6z0uo690.png)\n\n使用 $B$ 矩阵，循环生成一个**无穷大**的矩阵 $M$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/laycum3q.png)\n\n现在有 $q$ 次询问。每次将 $M$ 矩阵左上角和 $(x_1,y_1)$ 对齐，此时此时会有一些 $A$ 中的元素被遮挡，另一些元素可以被看见。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dtpe8m5u.png)\n\n求出此时，$A$ 当中以 $(x_1,y_1)$ 作为左上角，$(x_2,y_2)$ 作为右下角的子矩阵中，可以被看见的元素之和。结果对 $998{,}244{,}353$ 取模。\n\n在上面的例子里，$(x_1,y_1)=(2,3)$，$(x_2,y_2)=(4,7)$。可以被看见的元素之和为 $a_{2,3}+a_{2,5}+a_{2,6}+a_{3,5}+a_{4,3}+a_{4,5}+a_{4,6}$。\n\n### 形式化题面\n\n给定一个 $n$ 行 $m$ 列的普通矩阵 $A$，以及一个 $r$ 行 $c$ 列的 $01$ 矩阵 $B$。使用 $B$ 矩阵，生成一个**无穷大**的矩阵 $M$：\n\n$$M=\n\\begin{pmatrix}\nB & B & B  &\\cdots \\\\\nB & B & B  &\\cdots \\\\\nB & B & B  &\\cdots \\\\\n\\vdots &\\vdots &\\vdots &\n\\end{pmatrix}\n=\\begin{pmatrix}\nb_{1,1} & b_{1,2} & \\cdots & b_{1,c} & b_{1,1} & b_{1,2} & \\cdots & b_{1,c} & b_{1,1} & \\cdots \\\\\nb_{2,1} & b_{2,2} & \\cdots & b_{2,c} & b_{2,1} & b_{2,2} & \\cdots & b_{2,c} & b_{2,1} & \\cdots \\\\\n\\vdots & \\vdots & & \\vdots & \\vdots & \\vdots & & \\vdots & \\vdots &  \\\\\nb_{r,1} & b_{r,2} & \\cdots & b_{r,c} & b_{r,1} & b_{r,2} & \\cdots & b_{r,c} & b_{r,1} & \\cdots \\\\\nb_{1,1} & b_{1,2} & \\cdots & b_{1,c} & b_{1,1} & b_{1,2} & \\cdots & b_{1,c} & b_{1,1} & \\cdots \\\\\nb_{2,1} & b_{2,2} & \\cdots & b_{2,c} & b_{2,1} & b_{2,2} & \\cdots & b_{2,c} & b_{2,1} & \\cdots \\\\\n\\vdots & \\vdots & & \\vdots & \\vdots & \\vdots & & \\vdots & \\vdots &  \\\\\nb_{r,1} & b_{r,2} & \\cdots & b_{r,c} & b_{r,1} & b_{r,2} & \\cdots & b_{r,c} & b_{r,1} & \\cdots \\\\\n\\vdots & \\vdots & & \\vdots & \\vdots & \\vdots & & \\vdots & \\vdots &  \\\\\n\\end{pmatrix}$$\n\n现在有 $q$ 次询问，每次给出一个子矩阵的左上角坐标 $(x_1,y_1)$ 和右下角坐标 $(x_2,y_2)$，你需要求出：\n\n$$S=\\left(\\sum_{i=x_1}^{x_2}\\sum_{j=y_1}^{y_2}a_{i,j}\\times [M_{i-x_1+1,j-y_1+1}=0] \\right)\\bmod 998{,}244{,}353$$\n\n其中 $[P]$ 表示艾弗森括号。若 $P$ 为真，则 $[P]=1$，否则 $[P]=0$。", "inputFormat": "- 第一行有两个正整数 $n,m$，描述矩阵 $A$ 的大小。\n- 接下来 $n$ 行 $m$ 列，每行一个非负整数，描述 $A$ 中的元素 $a_{i,j}$。\n- 下一行有两个正整数 $r,c$，描述矩阵 $B$ 的大小。\n- 接下来 $r$ 行 $c$ 列，每行一个非负整数，描述 $B$ 中的元素 $b_{i,j}$。\n- 下一行有一个正整数 $q$，表示询问的次数。\n- 接下来 $q$ 行，每行有四个正整数 $x_1,y_1,x_2,y_2$，描述一组询问。保证 $x_1\\le x_2$，$y_1\\le y_2$。", "outputFormat": "- 输出共 $q$ 行。每行输出该次询问的答案。", "hint": "### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z7yeiipu.png)\n\n- 对于第一次询问，结果为 $2+4+5+7+10+12=40$；\n- 对于第二次询问，结果为 $3+6+11=20$。\n\n### 数据范围及约定\n\n对于全部数据，保证 $1\\le n,m\\le 10^3$，$1\\le q\\le 10^4$，$1\\le r,c\\le 50$，$0\\le a_{i,j}<998{,}244{,}353$，$b_{i,j}\\in\\{0,1\\}$。", "locale": "zh-CN"}}}
{"pid": "P8876", "type": "P", "difficulty": 5, "samples": [["8 3 3 4\n4 3 1\n4 4 1\n3 3 2\n3 4 2\n4 5 2\n5 4 2\n2 4 3\n4 1 4\n", "3\n"], ["8 2 3 4\n4 3 1\n4 4 1\n3 3 2\n3 4 2\n4 5 2\n5 4 2\n2 4 3\n4 1 4\n", "1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["搜索", "广度优先搜索 BFS", "传智杯"], "title": "[传智杯 #5 初赛] H-二人的世界", "background": "莲子设计了一个三维立体空间软件。这个软件可以模拟真实的物理引擎，包括实体方块和水流方块。然而，同时计算大量水流会对软件造成不小的负荷。\n\n于是，莲子希望找到这样一种算法，快速计算这些水流模拟后的结果。", "description": "莲子设计的水流模型是这样的：\n\n考虑一个三维空间。这个空间内有 $n$ 个正方体。我们使用坐标 $(x_i,y_i,h_i)$ 描述每个正方体的位置。这些正方体，可以被称作**实体方块**。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sotibgh2.png)\n\n现在将会在这张图中模拟一种水流机制。具体而言，我们会定义**水方块**。水方块会有一个强度 $s$，范围是 $[1,k]$。\n\n### 运行逻辑\n\n- 假定 $(x,y,h)$ 处有强度为 $s$ 的水方块，且 $(x,y,h-1)$ 位置没有实体方块，那么下一时刻 $(x,y,h-1)$ 位置会生成强度为 $k$ 的水方块。**注意**：无论此时 $s$ 的值是多少，在 $(x,y,h-1)$ 位置生成的水方块的强度都是 $k$。\n- 假定 $(x,y,h)$ 处有强度为 $s$ 的水方块，且 $s>1$，且 $(x,y,h-1)$ 位置有实体方块，那么会进行**扩散操作**。\n- 如果下一时刻，某个位置 $(x,y,h)$ 同时有多个水方块会生成，那么最终生成的水方块的强度，是这些可能生成的水方块里，最大的强度。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mn8iqp4l.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/suq9jiqx.png)\n\n### 扩散操作\n\n**考虑到扩散操作比较抽象，建议结合图示理解**。\n\n对于水方块 $(x,y,h)$，它会在高度 $h$ 的平面上进行寻路。为了考虑这个过程，我们考虑这个高度为 $h$ 的平面：\n\n- 如果空间里 $(x,y,h)$ 位置有实体方块存在，那么平面上 $(x,y)$ 处**不可经过**。否则，如果没有实体方块，那么 $(x,y)$ 处**可以经过**。\n- 在 $(x,y)$ **可以经过**的情况下，如果空间里 $(x,y,h-1)$ 位置没有实体方块存在，那么平面上 $(x,y)$ 位置称为**目标位置**。目标位置可以不止一个。\n\n根据扩散的前提条件，可知平面上 $(x,y)$ 位置可以经过，但不是目标位置。\n\n从平面上 $(x,y)$ 处出发，进行路径的搜索。每次在 $(a,b)$ 位置会向 $(a+1,b),(a-1,b),(a,b+1),(a,b-1)$ 位置扩展。搜索过程会找到距离 $(x,y)$ 位置**最近**的，且距离不超过 $s-1$ 的**所有**目标位置，或者找不到这样的目标位置。\n\n- 如果存在这样的目标位置，那么在到达目标位置的最短路的方向上，下一时刻会生成一个强度为 $s-1$ 的水方块。\n- 如果不存在这样的目标位置，那么下一时刻，会向 $(x+1,y),(x-1,y),(x,y+1),(x,y-1)$ 位置都生成强度为 $s-1$ 的水方块（如果这个位置可以到达的话）。\n\n请结合图示理解扩散过程。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9sw2uf0u.png)\n\n如图所示。$S$ 处是平面上该水方块所在的位置。白色的方块是目标位置，打 $\\times$ 的方块是不可经过的位置。我们计算出 $S$ 到达最近的目标位置的最小值 $d_{\\min}=5$，图中标出来的**红色路径**就是三条可能的最短路。\n\n如果 $s>5$，那么下一时刻，在**蓝色箭头**处会有强度为 $s-1$ 的水方块生成。否则，若 $5\\ge s>1$，那么下一时刻除了蓝色箭头外，灰色路径对应的方向**也会生成**强度为 $s-1$ 的水方块。\n\n---\n\n为了检验水流模型的合理性以及其运行效率，莲子提出了这个问题：在 $(x_0,y_0,10^9+1)$ 处，有一个强度为 $k$ 的水方块。询问：在经过充分长的时间后（比如经过了 $10^{9961^{9961}}$ 时刻），有多少个点对 $(a,b)$，满足在 $(a,b,-1)$ 位置，会有水方块生成过。", "inputFormat": "- 第一行有两个正整数 $n,k$ 和两个整数 $x_0,y_0$，描述实体方块的个数、水方块最大强度，以及初始水方块的位置。\n- 接下来 $n$ 行，每行三个整数 $x_i,y_i,h_i$，描述每个实体方块的位置。保证不存在两个位置完全相同的实体方块。", "outputFormat": "- 输出共一行一个整数，表示有多少个点对 $(a,b)$，使得充分长时间后 $(a,b,-1)$ 位置有水方块生成过。", "hint": "### 样例 1 解释\n\n（图片实在太难画啦，将就一下吧。）为了防止方块阻挡导致看不见，方块全部换成了透明的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i94wjdgb.png)\n\n初始状态下一根水流柱从高空落下，落在了方块 $(3,4,2)$ 上，进行了扩散。水方块的坐标为 $(3,4,3)$，强度为 $3$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e8d9vtl8.png)\n\n- 如图 $3$，根据寻路机制，它会在 $(3,5,3)$ 和 $(4,4,3)$ 上生成强度为 $2$ 的水方块。\n- 如图 $4$，生成的两个支流下方都没有方块，于是在 $(3,5,2)$ 和 $(4,4,2)$ 上生成强度为 $3$ 的水方块。\n- 如图 $5$，水方块 $(3,5,2)$ 下方依旧没有实体方块，于是在 $(3,5,1)$ 生成了强度为 $3$ 的水方块，一直流到 $(3,5,-1)$；水方块 $(4,4,2)$ 下方有实体方块，于是在 $(4,3,2)$ 生成了强度为 $2$ 的水方块。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g5n7min2.png)\n\n下面只关心水方块 $(4,3,2)$。它下面有实体方块 $(4,3,1)$，于是它向两边扩散，生成强度均为 $1$ 的两个水方块。这两个方块下面都不再有实体方块，于是**一直往下流**到 $(4,2,-1)$ 和 $(5,3,-1)$。\n\n因此，最终一共会有三个位置 $(3,5,-1)$、$(4,2,-1)$、$(5,3,-1)$ 有水方块经过。\n\n### 数据范围及约定\n\n对于所有数据，$1\\le n\\le 10^5$，$1\\le k\\le 10^9$，$0\\le |x_i|,|y_i|\\le 10^9$，$0\\le h_i\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] H-二人的世界", "background": "莲子设计了一个三维立体空间软件。这个软件可以模拟真实的物理引擎，包括实体方块和水流方块。然而，同时计算大量水流会对软件造成不小的负荷。\n\n于是，莲子希望找到这样一种算法，快速计算这些水流模拟后的结果。", "description": "莲子设计的水流模型是这样的：\n\n考虑一个三维空间。这个空间内有 $n$ 个正方体。我们使用坐标 $(x_i,y_i,h_i)$ 描述每个正方体的位置。这些正方体，可以被称作**实体方块**。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sotibgh2.png)\n\n现在将会在这张图中模拟一种水流机制。具体而言，我们会定义**水方块**。水方块会有一个强度 $s$，范围是 $[1,k]$。\n\n### 运行逻辑\n\n- 假定 $(x,y,h)$ 处有强度为 $s$ 的水方块，且 $(x,y,h-1)$ 位置没有实体方块，那么下一时刻 $(x,y,h-1)$ 位置会生成强度为 $k$ 的水方块。**注意**：无论此时 $s$ 的值是多少，在 $(x,y,h-1)$ 位置生成的水方块的强度都是 $k$。\n- 假定 $(x,y,h)$ 处有强度为 $s$ 的水方块，且 $s>1$，且 $(x,y,h-1)$ 位置有实体方块，那么会进行**扩散操作**。\n- 如果下一时刻，某个位置 $(x,y,h)$ 同时有多个水方块会生成，那么最终生成的水方块的强度，是这些可能生成的水方块里，最大的强度。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mn8iqp4l.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/suq9jiqx.png)\n\n### 扩散操作\n\n**考虑到扩散操作比较抽象，建议结合图示理解**。\n\n对于水方块 $(x,y,h)$，它会在高度 $h$ 的平面上进行寻路。为了考虑这个过程，我们考虑这个高度为 $h$ 的平面：\n\n- 如果空间里 $(x,y,h)$ 位置有实体方块存在，那么平面上 $(x,y)$ 处**不可经过**。否则，如果没有实体方块，那么 $(x,y)$ 处**可以经过**。\n- 在 $(x,y)$ **可以经过**的情况下，如果空间里 $(x,y,h-1)$ 位置没有实体方块存在，那么平面上 $(x,y)$ 位置称为**目标位置**。目标位置可以不止一个。\n\n根据扩散的前提条件，可知平面上 $(x,y)$ 位置可以经过，但不是目标位置。\n\n从平面上 $(x,y)$ 处出发，进行路径的搜索。每次在 $(a,b)$ 位置会向 $(a+1,b),(a-1,b),(a,b+1),(a,b-1)$ 位置扩展。搜索过程会找到距离 $(x,y)$ 位置**最近**的，且距离不超过 $s-1$ 的**所有**目标位置，或者找不到这样的目标位置。\n\n- 如果存在这样的目标位置，那么在到达目标位置的最短路的方向上，下一时刻会生成一个强度为 $s-1$ 的水方块。\n- 如果不存在这样的目标位置，那么下一时刻，会向 $(x+1,y),(x-1,y),(x,y+1),(x,y-1)$ 位置都生成强度为 $s-1$ 的水方块（如果这个位置可以到达的话）。\n\n请结合图示理解扩散过程。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9sw2uf0u.png)\n\n如图所示。$S$ 处是平面上该水方块所在的位置。白色的方块是目标位置，打 $\\times$ 的方块是不可经过的位置。我们计算出 $S$ 到达最近的目标位置的最小值 $d_{\\min}=5$，图中标出来的**红色路径**就是三条可能的最短路。\n\n如果 $s>5$，那么下一时刻，在**蓝色箭头**处会有强度为 $s-1$ 的水方块生成。否则，若 $5\\ge s>1$，那么下一时刻除了蓝色箭头外，灰色路径对应的方向**也会生成**强度为 $s-1$ 的水方块。\n\n---\n\n为了检验水流模型的合理性以及其运行效率，莲子提出了这个问题：在 $(x_0,y_0,10^9+1)$ 处，有一个强度为 $k$ 的水方块。询问：在经过充分长的时间后（比如经过了 $10^{9961^{9961}}$ 时刻），有多少个点对 $(a,b)$，满足在 $(a,b,-1)$ 位置，会有水方块生成过。", "inputFormat": "- 第一行有两个正整数 $n,k$ 和两个整数 $x_0,y_0$，描述实体方块的个数、水方块最大强度，以及初始水方块的位置。\n- 接下来 $n$ 行，每行三个整数 $x_i,y_i,h_i$，描述每个实体方块的位置。保证不存在两个位置完全相同的实体方块。", "outputFormat": "- 输出共一行一个整数，表示有多少个点对 $(a,b)$，使得充分长时间后 $(a,b,-1)$ 位置有水方块生成过。", "hint": "### 样例 1 解释\n\n（图片实在太难画啦，将就一下吧。）为了防止方块阻挡导致看不见，方块全部换成了透明的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i94wjdgb.png)\n\n初始状态下一根水流柱从高空落下，落在了方块 $(3,4,2)$ 上，进行了扩散。水方块的坐标为 $(3,4,3)$，强度为 $3$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e8d9vtl8.png)\n\n- 如图 $3$，根据寻路机制，它会在 $(3,5,3)$ 和 $(4,4,3)$ 上生成强度为 $2$ 的水方块。\n- 如图 $4$，生成的两个支流下方都没有方块，于是在 $(3,5,2)$ 和 $(4,4,2)$ 上生成强度为 $3$ 的水方块。\n- 如图 $5$，水方块 $(3,5,2)$ 下方依旧没有实体方块，于是在 $(3,5,1)$ 生成了强度为 $3$ 的水方块，一直流到 $(3,5,-1)$；水方块 $(4,4,2)$ 下方有实体方块，于是在 $(4,3,2)$ 生成了强度为 $2$ 的水方块。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g5n7min2.png)\n\n下面只关心水方块 $(4,3,2)$。它下面有实体方块 $(4,3,1)$，于是它向两边扩散，生成强度均为 $1$ 的两个水方块。这两个方块下面都不再有实体方块，于是**一直往下流**到 $(4,2,-1)$ 和 $(5,3,-1)$。\n\n因此，最终一共会有三个位置 $(3,5,-1)$、$(4,2,-1)$、$(5,3,-1)$ 有水方块经过。\n\n### 数据范围及约定\n\n对于所有数据，$1\\le n\\le 10^5$，$1\\le k\\le 10^9$，$0\\le |x_i|,|y_i|\\le 10^9$，$0\\le h_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P8877", "type": "P", "difficulty": 6, "samples": [["8\n1 1 0 1 0 0 0 1\n0 0 1 0 1 1 0 0\n1 1 3 2 2 1 4", "14\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["树形 DP", "虚树", "传智杯"], "title": "[传智杯 #5 初赛] I-不散的宴会", "background": "学校正在组织宴会。\n\n莲子和梅莉发现，学校的结构十分复杂。学生之间存在着部门与上司的关系。每一个部门内部，都呈现出连成一条线的上司关系。一个部门内等级最高的学生，又可能受限于另外某个部门内的某个学生。\n\n莲子和梅莉同样参加了宴会。但是她们对参加学生有自己的评判。例如，她对某些部门比较喜欢，对另一些部门则不感兴趣。同时对位居不同等级的学生同样有着不同的看法。\n\n正如某个经典问题所描述的一样，每个学生都不希望与自己的直接上司共同参加宴会。\n\n梅莉想要知道，最好情况下，有多少个参加宴会的学生是她喜欢的。", "description": "学生社会可以被看作一个排列成等腰直角三角形的节点阵列。该节点阵列共有 $n$ 行，第 $i$ 行共有 $i$ 个节点。我们将第 $i$ 行第 $j$ 列的节点，标号为 $(i,j)$。\n\n- 这些节点具有权值。具体而言，节点 $(i,j)$ 的权值为 $r_i\\oplus c_j$，其中 $r$ 和 $c$ 是给定的 $01$ 序列，$\\oplus$ 是**二进制异或**操作。\n- 这些节点有边相连。具体而言，对于 $1\\le i< n$，$1\\le j\\le i$，会有一条边连接 $(i,j)$ 和 $(i+1,j)$。此外，对于 $2\\le i\\le n$，还会有边连接 $(i,i)$ 和 $(i-1,a_i)$。其中 $a$ 是给定的序列。\n\n现在你需要从这些节点中，选出一些节点，使得这些节点间**两两不存在边相连**，最大化选出来的节点的**权值之和**。\n\n如下图所示，是 $n=8$ 的一个例子。黑色节点权值为 $1$，白色节点权值为 $0$。\n\n**注**：图片中只象征性地给出了部分 $r_i$ 和 $c_i$ 的值。该图片上实际 $\\def\\t{,\\allowbreak}r=\\{1\\t 1\\t 0\\t 1\\t 0\\t 0\\t 0\\t 1\\}\\t c=\\{0\\t 0\\t 1\\t 0\\t 1\\t 1\\t 0\\t 0\\}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/582ii4nj.png)", "inputFormat": "- 第一行有一个正整数 $n$，描述节点阵列的大小。\n- 第二行有 $n$ 个整数 $0$ 或者 $1$，描述 $r_i$ 的值。\n- 第三行有 $n$ 个整数 $0$ 或者 $1$，描述 $c_i$ 的值。\n- 第四行有 $n-1$ 个正整数，其中第 $i$ 个数描述 $a_{i+1}$ 的值。", "outputFormat": "- 输出共一行一个整数，描述选出的节点的权值之和的最大值。", "hint": "### 样例解释\n\n一种可能的选择方案如下图所示。橘红色方块表示选中的节点。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gpwn8ekv.png)\n\n### 数据范围及约定\n\n对于全部数据，保证 $1\\le n\\le 10^6$，$r_i\\in\\{0,1\\}$，$c_i\\in\\{0,1\\}$，$1\\le a_i<i$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] I-不散的宴会", "background": "学校正在组织宴会。\n\n莲子和梅莉发现，学校的结构十分复杂。学生之间存在着部门与上司的关系。每一个部门内部，都呈现出连成一条线的上司关系。一个部门内等级最高的学生，又可能受限于另外某个部门内的某个学生。\n\n莲子和梅莉同样参加了宴会。但是她们对参加学生有自己的评判。例如，她对某些部门比较喜欢，对另一些部门则不感兴趣。同时对位居不同等级的学生同样有着不同的看法。\n\n正如某个经典问题所描述的一样，每个学生都不希望与自己的直接上司共同参加宴会。\n\n梅莉想要知道，最好情况下，有多少个参加宴会的学生是她喜欢的。", "description": "学生社会可以被看作一个排列成等腰直角三角形的节点阵列。该节点阵列共有 $n$ 行，第 $i$ 行共有 $i$ 个节点。我们将第 $i$ 行第 $j$ 列的节点，标号为 $(i,j)$。\n\n- 这些节点具有权值。具体而言，节点 $(i,j)$ 的权值为 $r_i\\oplus c_j$，其中 $r$ 和 $c$ 是给定的 $01$ 序列，$\\oplus$ 是**二进制异或**操作。\n- 这些节点有边相连。具体而言，对于 $1\\le i< n$，$1\\le j\\le i$，会有一条边连接 $(i,j)$ 和 $(i+1,j)$。此外，对于 $2\\le i\\le n$，还会有边连接 $(i,i)$ 和 $(i-1,a_i)$。其中 $a$ 是给定的序列。\n\n现在你需要从这些节点中，选出一些节点，使得这些节点间**两两不存在边相连**，最大化选出来的节点的**权值之和**。\n\n如下图所示，是 $n=8$ 的一个例子。黑色节点权值为 $1$，白色节点权值为 $0$。\n\n**注**：图片中只象征性地给出了部分 $r_i$ 和 $c_i$ 的值。该图片上实际 $\\def\\t{,\\allowbreak}r=\\{1\\t 1\\t 0\\t 1\\t 0\\t 0\\t 0\\t 1\\}\\t c=\\{0\\t 0\\t 1\\t 0\\t 1\\t 1\\t 0\\t 0\\}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/582ii4nj.png)", "inputFormat": "- 第一行有一个正整数 $n$，描述节点阵列的大小。\n- 第二行有 $n$ 个整数 $0$ 或者 $1$，描述 $r_i$ 的值。\n- 第三行有 $n$ 个整数 $0$ 或者 $1$，描述 $c_i$ 的值。\n- 第四行有 $n-1$ 个正整数，其中第 $i$ 个数描述 $a_{i+1}$ 的值。", "outputFormat": "- 输出共一行一个整数，描述选出的节点的权值之和的最大值。", "hint": "### 样例解释\n\n一种可能的选择方案如下图所示。橘红色方块表示选中的节点。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gpwn8ekv.png)\n\n### 数据范围及约定\n\n对于全部数据，保证 $1\\le n\\le 10^6$，$r_i\\in\\{0,1\\}$，$c_i\\in\\{0,1\\}$，$1\\le a_i<i$。", "locale": "zh-CN"}}}
{"pid": "P8878", "type": "P", "difficulty": 5, "samples": [["6 2\n1 1 4 5 1 4\n2 4 2 100 3\n3 5 1 97 5", "1 4 52 44 6 4"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["线段树", "O2优化", "置换"], "title": "『STA - R1』好吃的智慧果子", "background": "在上古时代，$-(2077^{-1}\\ \\ (mod=2035))$ 年，$\\mathfrak{Morlin}$ 种下了一棵非常珍贵的$\\colorbox{black}{\\textcolor{red}{\\textbf{智♂慧♂树♂}}}$，被 $\\mathfrak{char\\_phi}$ 看见了。\n\n过了 $114810$ 年，树上结出了 $\\colorbox{black}{\\textcolor{blue}{\\textbf{智♂慧♂果♂子♂}}}$。  \n又过了 $1919514$ 年，果子成熟了，$\\mathfrak{char\\_phi}$ 非常馋。\n\n$\\mathfrak{char\\_phi}$ 十分想吃果子，但是~~神机妙算的~~ $\\mathfrak{Morlin}$ 早就知道 $\\mathfrak{char\\_phi}$ 想要吃他的果子，所以把每个果子都装进了密码箱。\n\n现在，$\\mathfrak{char\\_phi}$ 把偷果子这项重任托付给了你。  ", "description": "**形式化题面**\n\n维护一个序列 $\\{a_n\\}$，每次操作给五个非负整数 $l, r, k, p, c$，对于所有 $i\\in[l,r]$，将 $a_i\\gets (f_{a_i}^k+c)\\bmod p$。\n\n其中 $f$ 是 Fibonacci 数列，定义为：\n$$f_n=\\begin{cases}n&n\\leqslant 1\\\\f_{n-1}+f_{n-2}&n>1\\end{cases}$$\n***\n\n**原题面**\n\n~~神机妙算的~~ $\\mathfrak{Morlin}$ 早就知道 $\\mathfrak{char\\_phi}$ 很聪明，所以他会不定时改密码。\n\n每个密码箱上有一个数字，组成了数列 $\\{a_n\\}$。\n\n关于密码有 $m$ 次操作，每次操作给定五个整数 $l, r, k, p, c$，表示将满足 $l \\leqslant i \\leqslant r$ 将 $a_i$ 变成 $(f_{a_i}^k+c) \\bmod p$（$f_i$ 代表斐波那契数列的第 $i$ 项；保证 $l \\leqslant r$）。\n\n$\\mathfrak{char\\_phi}$ 搞了一个记录器记录下了 $\\mathfrak{Morlin}$ 的操作。现在，他把记录器给了你，希望你能在 $\\mathfrak{Morlin}$ 操作完后搞出所有密码箱的密码。", "inputFormat": "第一行，两个整数 $n, m$，表示果子的数量和操作次数。\n\n第二行，$n$ 个整数为数列 $a$，表示每个密码箱上的数字。\n\n接下来 $m$ 行，表示 $\\mathfrak{Morlin}$ 的操作 $l, r, k, p, c$。", "outputFormat": "一行，表示所有密码箱的密码，每个密码间使用空格隔开。", "hint": "**【数据范围】**\n\n**本题采用捆绑测试。**\n\n| Subtask | $\\bm{n,m\\leqslant}$ | 分值 | 特殊性质 |\n| :--: | :--: | :--: | :--: |\n| $1$ | $10^3$ | $10$ | 无 |\n| $2$ | $10^5$ | $10$ | $p \\leqslant 2$ |\n| $3$ | $10^5$ | $20$ | $p \\leqslant 3$ |\n| $4$ | $10^5$ | $60$ | 无 |\n\n对于 $100\\%$ 的数据，$1 \\leqslant n, m \\leqslant 10^5$，$1 \\leqslant a_i, p, k \\leqslant 100$，$0 \\leqslant c \\leqslant 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『STA - R1』好吃的智慧果子", "background": "在上古时代，$-(2077^{-1}\\ \\ (mod=2035))$ 年，$\\mathfrak{Morlin}$ 种下了一棵非常珍贵的$\\colorbox{black}{\\textcolor{red}{\\textbf{智♂慧♂树♂}}}$，被 $\\mathfrak{char\\_phi}$ 看见了。\n\n过了 $114810$ 年，树上结出了 $\\colorbox{black}{\\textcolor{blue}{\\textbf{智♂慧♂果♂子♂}}}$。  \n又过了 $1919514$ 年，果子成熟了，$\\mathfrak{char\\_phi}$ 非常馋。\n\n$\\mathfrak{char\\_phi}$ 十分想吃果子，但是~~神机妙算的~~ $\\mathfrak{Morlin}$ 早就知道 $\\mathfrak{char\\_phi}$ 想要吃他的果子，所以把每个果子都装进了密码箱。\n\n现在，$\\mathfrak{char\\_phi}$ 把偷果子这项重任托付给了你。  ", "description": "**形式化题面**\n\n维护一个序列 $\\{a_n\\}$，每次操作给五个非负整数 $l, r, k, p, c$，对于所有 $i\\in[l,r]$，将 $a_i\\gets (f_{a_i}^k+c)\\bmod p$。\n\n其中 $f$ 是 Fibonacci 数列，定义为：\n$$f_n=\\begin{cases}n&n\\leqslant 1\\\\f_{n-1}+f_{n-2}&n>1\\end{cases}$$\n***\n\n**原题面**\n\n~~神机妙算的~~ $\\mathfrak{Morlin}$ 早就知道 $\\mathfrak{char\\_phi}$ 很聪明，所以他会不定时改密码。\n\n每个密码箱上有一个数字，组成了数列 $\\{a_n\\}$。\n\n关于密码有 $m$ 次操作，每次操作给定五个整数 $l, r, k, p, c$，表示将满足 $l \\leqslant i \\leqslant r$ 将 $a_i$ 变成 $(f_{a_i}^k+c) \\bmod p$（$f_i$ 代表斐波那契数列的第 $i$ 项；保证 $l \\leqslant r$）。\n\n$\\mathfrak{char\\_phi}$ 搞了一个记录器记录下了 $\\mathfrak{Morlin}$ 的操作。现在，他把记录器给了你，希望你能在 $\\mathfrak{Morlin}$ 操作完后搞出所有密码箱的密码。", "inputFormat": "第一行，两个整数 $n, m$，表示果子的数量和操作次数。\n\n第二行，$n$ 个整数为数列 $a$，表示每个密码箱上的数字。\n\n接下来 $m$ 行，表示 $\\mathfrak{Morlin}$ 的操作 $l, r, k, p, c$。", "outputFormat": "一行，表示所有密码箱的密码，每个密码间使用空格隔开。", "hint": "**【数据范围】**\n\n**本题采用捆绑测试。**\n\n| Subtask | $\\bm{n,m\\leqslant}$ | 分值 | 特殊性质 |\n| :--: | :--: | :--: | :--: |\n| $1$ | $10^3$ | $10$ | 无 |\n| $2$ | $10^5$ | $10$ | $p \\leqslant 2$ |\n| $3$ | $10^5$ | $20$ | $p \\leqslant 3$ |\n| $4$ | $10^5$ | $60$ | 无 |\n\n对于 $100\\%$ 的数据，$1 \\leqslant n, m \\leqslant 10^5$，$1 \\leqslant a_i, p, k \\leqslant 100$，$0 \\leqslant c \\leqslant 10^9$。", "locale": "zh-CN"}}}
{"pid": "P8879", "type": "P", "difficulty": 6, "samples": [["5\n1 2 3 4 5", "-13.7500000"], ["10\n1000 1 2 8 9 5 4 1000 -40 1000", "-403015.7500000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["Special Judge", "单调栈", "保序回归"], "title": "『STA - R1』Crossnews", "background": "Informational problems make us better.", "description": "定义两个序列 $\\{a_n\\}$，$\\{b_n\\}$ 的联合权值为\n$$\\operatorname{unval}(a,b)=\\sum_{i=1}^nb_i(b_i-a_i)$$\n\n现给定一个序列 $\\{a_n\\}$，求满足 $\\operatorname{unval}(a,b)$ 最小的单调不减序列 $\\{b\\}$，只需输出 $\\operatorname{unval}(a,b)$ 的值即可。\n\n注意，$\\{b\\}$ 中的元素不一定要为整数。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个整数表示 $a_i$。", "outputFormat": "一行一个答案。", "hint": "提示：如果你不会做这道题，可以问问 [APJifengc](/user/279652)。\n***\n\n样例 1 解释：使得联合权值取到最小值的 $\\{b\\}$ 为 `0.5 1 1.5 2 2.5`。\n\n***\n数据范围和约定：\n$$\n\\newcommand{\\arraystretch}{1.5}\n\\begin{array}{c|c|c|c}\\hline\\hline\n\\textbf{Subtask} & \\bm{n}\\le & \\textbf{分值} & \\textbf{特殊性质}\\\\\\hline\n\\textsf{1} & 100 & 10 & \\textbf{无} \\\\\\hline\n\\textsf{2} & 10^6 & 5 & \\{a\\}\\textbf{ 全部相等} \\\\\\hline\n\\textsf{3} & 10^6 & 5 & \\{a\\}\\textbf{ 单调不减} \\\\\\hline\n\\textsf{4} & 10^4 & 30 & \\textbf{无} \\\\\\hline\n\\textsf{5} & 10^6 & 50 & \\textbf{无}\n\\\\\\hline\\hline\n\\end{array}\n$$\n\n对于全部数据，有 $1\\le n\\le 10^6$，$|a_i|\\le 10^3$。\n\n***\n\n评分规则：\n\n本题使用 Special Judge，如果你的答案是 $pans$，标准答案是 $cans$，则你将获得\n$$\\min\\Bigg\\{100,\\Bigg\\lfloor\\dfrac{0.1}{\\min\\Big\\{|pans-cans|,\\Big|\\dfrac{|pans-cans|}{cans}\\Big|\\Big\\}}\\Bigg\\rfloor\\Bigg\\}$$\n分。\n\n**每个 Subtask 内捆绑测试**。即取 Subtask 内得分最小的作为 Subtask 得分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『STA - R1』Crossnews", "background": "Informational problems make us better.", "description": "定义两个序列 $\\{a_n\\}$，$\\{b_n\\}$ 的联合权值为\n$$\\operatorname{unval}(a,b)=\\sum_{i=1}^nb_i(b_i-a_i)$$\n\n现给定一个序列 $\\{a_n\\}$，求满足 $\\operatorname{unval}(a,b)$ 最小的单调不减序列 $\\{b\\}$，只需输出 $\\operatorname{unval}(a,b)$ 的值即可。\n\n注意，$\\{b\\}$ 中的元素不一定要为整数。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个整数表示 $a_i$。", "outputFormat": "一行一个答案。", "hint": "提示：如果你不会做这道题，可以问问 [APJifengc](/user/279652)。\n***\n\n样例 1 解释：使得联合权值取到最小值的 $\\{b\\}$ 为 `0.5 1 1.5 2 2.5`。\n\n***\n数据范围和约定：\n$$\n\\newcommand{\\arraystretch}{1.5}\n\\begin{array}{c|c|c|c}\\hline\\hline\n\\textbf{Subtask} & \\bm{n}\\le & \\textbf{分值} & \\textbf{特殊性质}\\\\\\hline\n\\textsf{1} & 100 & 10 & \\textbf{无} \\\\\\hline\n\\textsf{2} & 10^6 & 5 & \\{a\\}\\textbf{ 全部相等} \\\\\\hline\n\\textsf{3} & 10^6 & 5 & \\{a\\}\\textbf{ 单调不减} \\\\\\hline\n\\textsf{4} & 10^4 & 30 & \\textbf{无} \\\\\\hline\n\\textsf{5} & 10^6 & 50 & \\textbf{无}\n\\\\\\hline\\hline\n\\end{array}\n$$\n\n对于全部数据，有 $1\\le n\\le 10^6$，$|a_i|\\le 10^3$。\n\n***\n\n评分规则：\n\n本题使用 Special Judge，如果你的答案是 $pans$，标准答案是 $cans$，则你将获得\n$$\\min\\Bigg\\{100,\\Bigg\\lfloor\\dfrac{0.1}{\\min\\Big\\{|pans-cans|,\\Big|\\dfrac{|pans-cans|}{cans}\\Big|\\Big\\}}\\Bigg\\rfloor\\Bigg\\}$$\n分。\n\n**每个 Subtask 内捆绑测试**。即取 Subtask 内得分最小的作为 Subtask 得分。", "locale": "zh-CN"}}}
{"pid": "P8880", "type": "P", "difficulty": 3, "samples": [["3\n2 1 0", "2 0 1\n0 1 2"], ["4\n1 3 0 2", "-1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["Special Judge", "O2优化"], "title": "无知时诋毁原神", "background": "纳西妲很喜欢排列。\n\n![](https://img2.huashi6.com/images/resource/thumbnail/2022/07/28/14225_32552389084.jpg?imageMogr2/quality/100/interlace/1/thumbnail/700x)\n\n画师 pid：72405030", "description": "纳西妲有一个 $0\\sim n-1$ 的排列 $c$。她希望你构造两个同样为 $0\\sim n-1$ 的排列的 $a,b$，满足 $\\forall i\\in[1,n],c_i=(a_i+b_i)\\bmod n$。如果纳西妲的要求无法被满足，请输出 $-1$。", "inputFormat": "第一行，一个整数 $n$。\n\n第二行，$n$ 个整数，表示排列 $c$。", "outputFormat": "如果不存在满足要求的构造，输出一行 $-1$。\n\n否则，输出两行，每行 $n$ 个整数，第一行为 $a_i$，第二行为 $b_i$。", "hint": "### 数据范围\n\n- $\\text{Subtask 1(30 pts)}$：$n\\le 10$。\n- $\\text{Subtask 2(20 pts)}$：保证有解。\n- $\\text{Subtask 3(50 pts)}$：无特殊性质。\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 10^5$，$c$ 构成一个排列。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "无知时诋毁原神", "background": "纳西妲很喜欢排列。\n\n![](https://img2.huashi6.com/images/resource/thumbnail/2022/07/28/14225_32552389084.jpg?imageMogr2/quality/100/interlace/1/thumbnail/700x)\n\n画师 pid：72405030", "description": "纳西妲有一个 $0\\sim n-1$ 的排列 $c$。她希望你构造两个同样为 $0\\sim n-1$ 的排列的 $a,b$，满足 $\\forall i\\in[1,n],c_i=(a_i+b_i)\\bmod n$。如果纳西妲的要求无法被满足，请输出 $-1$。", "inputFormat": "第一行，一个整数 $n$。\n\n第二行，$n$ 个整数，表示排列 $c$。", "outputFormat": "如果不存在满足要求的构造，输出一行 $-1$。\n\n否则，输出两行，每行 $n$ 个整数，第一行为 $a_i$，第二行为 $b_i$。", "hint": "### 数据范围\n\n- $\\text{Subtask 1(30 pts)}$：$n\\le 10$。\n- $\\text{Subtask 2(20 pts)}$：保证有解。\n- $\\text{Subtask 3(50 pts)}$：无特殊性质。\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 10^5$，$c$ 构成一个排列。", "locale": "zh-CN"}}}
{"pid": "P8881", "type": "P", "difficulty": 3, "samples": [["1\n5 4\n1 3\n1 2\n3 4\n2 5", "1.000"], ["1\n4 4\n1 2\n2 3\n3 1\n4 3", "0.000"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "O2优化"], "title": "懂事时理解原神", "background": "胡桃喜欢用 dfs 求最短路，尽管这有可能会得到错误的答案。\n\n![](https://img2.huashi6.com/images/resource/2021/03/01/8812956h7p1.jpg?imageMogr2/quality/100/interlace/1/thumbnail/700x)\n\n画师 pid：6657532", "description": "具体地，给定一个有 $n$ 个点和 $m$ 条边的无向无权图。则 dfs 求最短路的算法伪代码具体如下：\n\n```\nvis[], dis[]\ndfs(u):\n\tvis[u] = 1\n\t记所有满足 u,v 之间有边且 !vis[v] 的点 v 构成的序列为 S\n\t以随机的顺序遍历 S: \n\t\tdis[v] = dis[u] + 1\n\t\tdfs(v)\nsolve():\n\tfor i in [1, n]: \n    \tdis[i] = -1;\n        vis[i] = 0\n\tdis[1] = 0\n\tdfs(1)\n```\n\n其中，```以随机的顺序遍历 S``` 可以被理解为随机打乱 $S$，得到每一种结果的概率均为 $\\frac{1}{|S|!}$，并按照打乱后的顺序遍历。\n\n现在，胡桃想要知道，如果她调用函数 ```solve()```，得到的最短路数组 ```dis[]``` 完全正确的概率有多大。```dis[]``` 被认为完全正确，当且仅当 $\\forall i\\in[1,n]$，```dis[i]``` 的值均等于从 $1$ 到 $i$ 的最短路长度（特别地，若 $1$ 无法走到 $i$，则认为 $1$ 到 $i$ 的最短路长度为 $-1$）。", "inputFormat": "**本题多组询问。** 第一行输入一个数 $T$，表示询问组数。\n\n对于每组询问：\n\n第一行，两个整数 $n,m$。\n\n第二行至第 $m+1$ 行，每行两个整数 $u,v$，表示 $u,v$ 之间有一条边。", "outputFormat": "对于每组询问，输出一个实数，为 ```dis[]``` 数组完全正确的概率。**你需要输出答案保留三位小数（四舍五入）后的结果。**", "hint": "- 对于 $20\\%$ 的数据，$n,m\\le 10$。\n- 对于 $50\\%$ 的数据，$n,m\\le 1000$。\n- 对于另外 $30\\%$ 的数据，保证所给出的图为一仙人掌（任意一条边至多只出现在一条环上）。\n- 对于 $100\\%$ 的数据，$1\\le n,m\\le 50000，1\\le T\\le 10$，保证所输入的图无重边、自环。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "懂事时理解原神", "background": "胡桃喜欢用 dfs 求最短路，尽管这有可能会得到错误的答案。\n\n![](https://img2.huashi6.com/images/resource/2021/03/01/8812956h7p1.jpg?imageMogr2/quality/100/interlace/1/thumbnail/700x)\n\n画师 pid：6657532", "description": "具体地，给定一个有 $n$ 个点和 $m$ 条边的无向无权图。则 dfs 求最短路的算法伪代码具体如下：\n\n```\nvis[], dis[]\ndfs(u):\n\tvis[u] = 1\n\t记所有满足 u,v 之间有边且 !vis[v] 的点 v 构成的序列为 S\n\t以随机的顺序遍历 S: \n\t\tdis[v] = dis[u] + 1\n\t\tdfs(v)\nsolve():\n\tfor i in [1, n]: \n    \tdis[i] = -1;\n        vis[i] = 0\n\tdis[1] = 0\n\tdfs(1)\n```\n\n其中，```以随机的顺序遍历 S``` 可以被理解为随机打乱 $S$，得到每一种结果的概率均为 $\\frac{1}{|S|!}$，并按照打乱后的顺序遍历。\n\n现在，胡桃想要知道，如果她调用函数 ```solve()```，得到的最短路数组 ```dis[]``` 完全正确的概率有多大。```dis[]``` 被认为完全正确，当且仅当 $\\forall i\\in[1,n]$，```dis[i]``` 的值均等于从 $1$ 到 $i$ 的最短路长度（特别地，若 $1$ 无法走到 $i$，则认为 $1$ 到 $i$ 的最短路长度为 $-1$）。", "inputFormat": "**本题多组询问。** 第一行输入一个数 $T$，表示询问组数。\n\n对于每组询问：\n\n第一行，两个整数 $n,m$。\n\n第二行至第 $m+1$ 行，每行两个整数 $u,v$，表示 $u,v$ 之间有一条边。", "outputFormat": "对于每组询问，输出一个实数，为 ```dis[]``` 数组完全正确的概率。**你需要输出答案保留三位小数（四舍五入）后的结果。**", "hint": "- 对于 $20\\%$ 的数据，$n,m\\le 10$。\n- 对于 $50\\%$ 的数据，$n,m\\le 1000$。\n- 对于另外 $30\\%$ 的数据，保证所给出的图为一仙人掌（任意一条边至多只出现在一条环上）。\n- 对于 $100\\%$ 的数据，$1\\le n,m\\le 50000，1\\le T\\le 10$，保证所输入的图无重边、自环。", "locale": "zh-CN"}}}
{"pid": "P8882", "type": "P", "difficulty": 4, "samples": [["2\n1\n4\nAdd 1\nUpd 2\nDel 3\nDel 1", "1\n2\n1\n1\n1\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化"], "title": "成熟时追随原神", "background": "可莉喜欢生活在树上。\n\n![](https://img2.huashi6.com/images/resource/2021/04/29/8945867h9p0.jpg?imageMogr2/quality/100/interlace/1/thumbnail/700x)\n\n画师 pid：4787895", "description": "可莉生活在一颗有根树上，初始节点从 $1$ 到 $n$ 编号。为了方便可莉的出行，蒙德人决定从每个非叶子节点出发，修建一条新道路。具体而言，对与每个非叶子节点 $u$，蒙德人会从其子节点中均匀随机选取一个点 $v$，并在 $u$ 和 $v$ 之间修建一条新道路。显然，这些新修建的道路连成了许多的连通块。为了帮助他们的修建，你需要告诉蒙德人，连通块个数的期望是多少。\n\n可莉听说这个任务后，认为它对于你而言太简单了。因此，她决定添加一些对于树的修改操作：\n\n- $\\text{Add}\\ u$：在节点 $u$ 下添加一子结点，编号为 $n+i$，其中 $i$ 为操作编号。保证操作前结点 $u$ 存在。\n- $\\text{Del}\\ u$：删除结点 $u$。保证操作前结点 $u$ 存在且为叶子结点。\n- $\\text{Upd}\\ u$：将树根变为 $u$。保证操作前结点 $u$ 存在。\n\n同时，对于任意时刻，保证树不会被删空。\n\n对于初始的树和每次修改之后所得的树，你都需要回答一遍上述的问题。注意，$m$ 次修改之间不独立，但是蒙德人每次修建的新道路不受上一次结果的影响。", "inputFormat": "第一行，一个整数 $n$，表示初始树的大小。\n\n第二行至第 $n$ 行，每行输入一个整数，第 $i$ 行将给出 $f_i$，即初始树中 $i$ 的父节点。初始时，节点 $1$ 为树根。\n\n第 $n+1$ 行，一个整数 $m$，表示修改操作个数。\n\n第 $n+2$ 行至第 $n+m+1$ 行，每行输入一个修改操作，形式见 **题目描述**。", "outputFormat": "输出共 $m+1$ 行。\n\n第 $1$ 行，为初始时的答案。\n\n第 $2$ 行至第 $m+1$ 行，第 $i$ 行应输出第 $i-1$ 次修改操作后的答案。\n\n所有输出均对 $998244353$ 取模。具体而言，如果答案为 $\\frac{p}{q}$，你应当输出一个满足 $xq\\equiv p\\pmod {998244353}$ 的 $x$。", "hint": "$$\n\\begin{array}{|c|c|c|c|}\\hline\n\\textbf{测试点编号}& { n\\le} & {m\\le} & \\textbf{特殊性质} \\cr\\hline\n1\\sim 3 & 5 & 5 & - \\cr\\hline\n4\\sim 7 & 1000 & 1000 &- \\cr\\hline\n8\\sim 10 & 10^5 & 0 & - \\cr\\hline\n11\\sim 13 & 10^5 & 2\\times 10^5 & \\textbf{AB}\\cr\\hline\n14\\sim 16 & 2\\times 10^5 & 5\\times 10^4 & \\textbf{A} \\cr\\hline\n17\\sim 20 & 2\\times 10^5 & 2\\times 10^5 & - \\cr\\hline\n\\end{array}\n$$\n\n- 特殊性质 $\\textbf{A}$：保证不存在 $\\text{Upd}$ 操作。\n- 特殊性质 $\\textbf{B}$：保证不存在 $\\text{Del}$ 操作。\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 2\\times 10^5$。保证 $1\\le f_i<i$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "成熟时追随原神", "background": "可莉喜欢生活在树上。\n\n![](https://img2.huashi6.com/images/resource/2021/04/29/8945867h9p0.jpg?imageMogr2/quality/100/interlace/1/thumbnail/700x)\n\n画师 pid：4787895", "description": "可莉生活在一颗有根树上，初始节点从 $1$ 到 $n$ 编号。为了方便可莉的出行，蒙德人决定从每个非叶子节点出发，修建一条新道路。具体而言，对与每个非叶子节点 $u$，蒙德人会从其子节点中均匀随机选取一个点 $v$，并在 $u$ 和 $v$ 之间修建一条新道路。显然，这些新修建的道路连成了许多的连通块。为了帮助他们的修建，你需要告诉蒙德人，连通块个数的期望是多少。\n\n可莉听说这个任务后，认为它对于你而言太简单了。因此，她决定添加一些对于树的修改操作：\n\n- $\\text{Add}\\ u$：在节点 $u$ 下添加一子结点，编号为 $n+i$，其中 $i$ 为操作编号。保证操作前结点 $u$ 存在。\n- $\\text{Del}\\ u$：删除结点 $u$。保证操作前结点 $u$ 存在且为叶子结点。\n- $\\text{Upd}\\ u$：将树根变为 $u$。保证操作前结点 $u$ 存在。\n\n同时，对于任意时刻，保证树不会被删空。\n\n对于初始的树和每次修改之后所得的树，你都需要回答一遍上述的问题。注意，$m$ 次修改之间不独立，但是蒙德人每次修建的新道路不受上一次结果的影响。", "inputFormat": "第一行，一个整数 $n$，表示初始树的大小。\n\n第二行至第 $n$ 行，每行输入一个整数，第 $i$ 行将给出 $f_i$，即初始树中 $i$ 的父节点。初始时，节点 $1$ 为树根。\n\n第 $n+1$ 行，一个整数 $m$，表示修改操作个数。\n\n第 $n+2$ 行至第 $n+m+1$ 行，每行输入一个修改操作，形式见 **题目描述**。", "outputFormat": "输出共 $m+1$ 行。\n\n第 $1$ 行，为初始时的答案。\n\n第 $2$ 行至第 $m+1$ 行，第 $i$ 行应输出第 $i-1$ 次修改操作后的答案。\n\n所有输出均对 $998244353$ 取模。具体而言，如果答案为 $\\frac{p}{q}$，你应当输出一个满足 $xq\\equiv p\\pmod {998244353}$ 的 $x$。", "hint": "$$\n\\begin{array}{|c|c|c|c|}\\hline\n\\textbf{测试点编号}& { n\\le} & {m\\le} & \\textbf{特殊性质} \\cr\\hline\n1\\sim 3 & 5 & 5 & - \\cr\\hline\n4\\sim 7 & 1000 & 1000 &- \\cr\\hline\n8\\sim 10 & 10^5 & 0 & - \\cr\\hline\n11\\sim 13 & 10^5 & 2\\times 10^5 & \\textbf{AB}\\cr\\hline\n14\\sim 16 & 2\\times 10^5 & 5\\times 10^4 & \\textbf{A} \\cr\\hline\n17\\sim 20 & 2\\times 10^5 & 2\\times 10^5 & - \\cr\\hline\n\\end{array}\n$$\n\n- 特殊性质 $\\textbf{A}$：保证不存在 $\\text{Upd}$ 操作。\n- 特殊性质 $\\textbf{B}$：保证不存在 $\\text{Del}$ 操作。\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 2\\times 10^5$。保证 $1\\le f_i<i$。", "locale": "zh-CN"}}}
{"pid": "P8883", "type": "P", "difficulty": 5, "samples": [["3\n10\n32678\n9686985\n", "3\n12814\n3797988"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "Special Judge", "O2优化"], "title": "幻想中成为原神", "background": "钟离很喜欢数学题。", "description": "其中一个问题是这样的：定义一个丘丘人是可以被击杀的，当且仅当存在一个大于 $1$ 的完全平方数能够整除它的编号。比如，$12$ 号丘丘人就是可以被击杀的，因为它能够被 $4$ 整除；$15$ 号丘丘人则不能被击杀。请计算编号为 $1\\sim n$ 中的丘丘人中能够被击杀的个数。由于钟离秉承着“差不多得了”的做事理念，因此，他允许你的答案与真正的答案有着不超过 $2\\times10^4$ 的绝对误差。", "inputFormat": "**本题多组询问**。第一行输入一个数 $T$，表示询问组数。\n\n每组询问输入一行，一个正整数 $n$。", "outputFormat": "对于每组询问，输出一行一个整数，表示编号为 $1\\sim n$ 中的丘丘人中能够被击杀的个数。", "hint": "#### 样例解释\n\n$1\\sim 10$ 中，只有 $4,8,9$ 这 $3$ 个丘丘人可以被击杀，因此答案为 $3$。\n\n需要注意的是，由于你的答案被允许与标准答案有 $2\\times 10^4$ 的绝对误差，因此 $-2,3,20003$ 等输出都将被认为是正确的。\n\n#### 数据范围\n\n- $\\text{Subtask 1(10 pts)}$：$n\\le 10^5$。\n- $\\text{Subtask 2(20 pts)}$：$n\\le 10^7$。\n- $\\text{Subtask 3(20 pts)}$：$n\\le 10^9$。\n- $\\text{Subtask 4(20 pts)}$：$T=1$。\n- $\\text{Subtask 5(30 pts)}$：无特殊性质。\n\n对于 $100\\%$ 数据，满足 $1\\le n\\le 10^{18}$，$1\\le T\\le 10^4$，保证 $n$ 在范围内随机得到。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "幻想中成为原神", "background": "钟离很喜欢数学题。", "description": "其中一个问题是这样的：定义一个丘丘人是可以被击杀的，当且仅当存在一个大于 $1$ 的完全平方数能够整除它的编号。比如，$12$ 号丘丘人就是可以被击杀的，因为它能够被 $4$ 整除；$15$ 号丘丘人则不能被击杀。请计算编号为 $1\\sim n$ 中的丘丘人中能够被击杀的个数。由于钟离秉承着“差不多得了”的做事理念，因此，他允许你的答案与真正的答案有着不超过 $2\\times10^4$ 的绝对误差。", "inputFormat": "**本题多组询问**。第一行输入一个数 $T$，表示询问组数。\n\n每组询问输入一行，一个正整数 $n$。", "outputFormat": "对于每组询问，输出一行一个整数，表示编号为 $1\\sim n$ 中的丘丘人中能够被击杀的个数。", "hint": "#### 样例解释\n\n$1\\sim 10$ 中，只有 $4,8,9$ 这 $3$ 个丘丘人可以被击杀，因此答案为 $3$。\n\n需要注意的是，由于你的答案被允许与标准答案有 $2\\times 10^4$ 的绝对误差，因此 $-2,3,20003$ 等输出都将被认为是正确的。\n\n#### 数据范围\n\n- $\\text{Subtask 1(10 pts)}$：$n\\le 10^5$。\n- $\\text{Subtask 2(20 pts)}$：$n\\le 10^7$。\n- $\\text{Subtask 3(20 pts)}$：$n\\le 10^9$。\n- $\\text{Subtask 4(20 pts)}$：$T=1$。\n- $\\text{Subtask 5(30 pts)}$：无特殊性质。\n\n对于 $100\\%$ 数据，满足 $1\\le n\\le 10^{18}$，$1\\le T\\le 10^4$，保证 $n$ 在范围内随机得到。", "locale": "zh-CN"}}}
{"pid": "P8884", "type": "P", "difficulty": 3, "samples": [["3 3 5\n1 2\n1 3\n2 1\n3 2\n3 3\n3\n1 2 2 3 0\n1 2 3 3 4\n1 2\n1 3\n2 3\n3 3\n1 1 2 3 2\n1 3\n2 2", "NO\nYES\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化"], "title": "「JEOI-R1」棋", "background": "| 出题 | 标程 | 数据 | 验题 | 题解 |\n| -----------: | -----------: | -----------: | -----------: | -----------: |\n | [RedNebula](/user/478829) | [RedNebula](/user/478829) | [RedNebula](/user/478829) and [gyyyyx](/user/554574) | [gyyyyx](/user/554574) | [RedNebula](/user/478829) |\n \n[RedNebula](/user/478829) 和 [_JF_](/user/361141) 在下一盘棋，然后……", "description": "现在有一个 $n\\times m$ 的棋盘，从上到下依次是 $1\\sim n$ 行，从左到右依次是 $1\\sim m$ 列，一个位于第 $x$ 行第 $y$ 列的位置被标记为 $(x,y)$。共有 $c$ 个棋子，**不重叠**地摆放在棋盘的某些位置上。一个位于 $(x,y)$ 的棋子可以走向 $(x-1,y-1),(x-1,y+1),(x+1,y-1),(x+1,y+1)$（如果这些位置**存在**且其上**没有棋子**）。\n\n现有若干询问，每次询问给定 $x_1,y_1,x_2,y_2,p$，然后给定 $p$ 个位置，表示一个子矩阵的左上角位置为 $(x_1,y_1)$，右下角位置为 $(x_2,y_2)$，问是否可以移动棋子（无次数限制）使得矩阵内**有且仅有**给定的 $p$ 个位置上有棋子。**询问之间相互独立。**\n\n为了减少程序时间复杂度的常数影响，**建议使用更快的读入方式。**", "inputFormat": "第一行三个正整数 $n,m,c$，表示棋盘的列数、行数和已有的棋子数。\n\n接下来 $c$ 行，一行两个整数 $a_i,b_i$，表示有一个棋子位于 $a_i$ 行 $b_i$ 列处。\n\n接下来一行一个正整数 $q$。\n\n接下来 $q$ 组询问。每一组询问第一行是五个正整数 $x_1,y_1,x_2,y_2,p$，接下来 $p$ 行每行两个正整数 $c_i,d_i$，表示只希望矩阵内有棋子的位置。", "outputFormat": "对于每个询问，如果可以移动棋子（无次数限制）使得矩阵内有且仅有给定的位置上有棋子，输出 `YES`，否则输出 `NO`。", "hint": "**【样例解释 \\#1】**\n\n解释以 `0` 代表空位，`1` 代表放置了棋子的位置。\n\n初始状态：\n\n```plain\n011\n100\n011\n```\n\n对于第一个询问，可以证明 $(1,2)$ 处的棋子无法移出 $(1,2)$ 到 $(2,3)$ 的矩阵。\n\n对于第二个询问，考虑把 $(3,2)$ 处的棋子移到 $(2,3)$，得：\n\n```plain\n011\n101\n001\n```\n\n满足询问要求。移动方式不唯一。\n\n对于第三个询问，可以证明 $(2,1)$ 处的棋子无法移出 $(1,1)$ 到 $(2,3)$ 的矩阵。\n\n**【数据范围】**\n\n对于 $25\\%$ 的数据，$n,m,q\\le 10$，$c\\le 20$。\n\n对于另外 $25\\%$ 的数据，保证 $a_i+b_i\\equiv 0 \\pmod 2$，$c_i+d_i\\equiv 0 \\pmod 2$。\n\n对于另外 $25\\%$ 的数据，保证 $n\\cdot m-c\\le(x_2-x_1+1)\\cdot (y_2-y_1+1)-p$。\n\n对于 $100\\%$ 的数据，$2\\le n,m\\le 10^5$，$1\\le c,q\\le 10^5$，$c\\le n\\cdot m$，$1\\le a_i\\le n$，$1\\le b_i\\le m$，$\\sum p\\le 2\\times 10^5$。对于每个询问，$1\\le p\\le (x_2-x_1+1)\\cdot (y_2-y_1+1)$，$x_1\\le c_i\\le x_2$，$y_1\\le d_i\\le y_2$。\n\n**【提示与说明】**\n\n提供一种较快的读入一个 `int` 类型非负整数的方式。调用下文中的 `read()`，其作用是返回输入中的一个非负整数，同时读取其后的一个字符。\n\n```cpp\nint read() {\n  int x(0);\n  char c(getchar());\n  while (c < '0' || c > '9') c = getchar();\n  while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n  return x;\n}\n```", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「JEOI-R1」棋", "background": "| 出题 | 标程 | 数据 | 验题 | 题解 |\n| -----------: | -----------: | -----------: | -----------: | -----------: |\n | [RedNebula](/user/478829) | [RedNebula](/user/478829) | [RedNebula](/user/478829) and [gyyyyx](/user/554574) | [gyyyyx](/user/554574) | [RedNebula](/user/478829) |\n \n[RedNebula](/user/478829) 和 [_JF_](/user/361141) 在下一盘棋，然后……", "description": "现在有一个 $n\\times m$ 的棋盘，从上到下依次是 $1\\sim n$ 行，从左到右依次是 $1\\sim m$ 列，一个位于第 $x$ 行第 $y$ 列的位置被标记为 $(x,y)$。共有 $c$ 个棋子，**不重叠**地摆放在棋盘的某些位置上。一个位于 $(x,y)$ 的棋子可以走向 $(x-1,y-1),(x-1,y+1),(x+1,y-1),(x+1,y+1)$（如果这些位置**存在**且其上**没有棋子**）。\n\n现有若干询问，每次询问给定 $x_1,y_1,x_2,y_2,p$，然后给定 $p$ 个位置，表示一个子矩阵的左上角位置为 $(x_1,y_1)$，右下角位置为 $(x_2,y_2)$，问是否可以移动棋子（无次数限制）使得矩阵内**有且仅有**给定的 $p$ 个位置上有棋子。**询问之间相互独立。**\n\n为了减少程序时间复杂度的常数影响，**建议使用更快的读入方式。**", "inputFormat": "第一行三个正整数 $n,m,c$，表示棋盘的列数、行数和已有的棋子数。\n\n接下来 $c$ 行，一行两个整数 $a_i,b_i$，表示有一个棋子位于 $a_i$ 行 $b_i$ 列处。\n\n接下来一行一个正整数 $q$。\n\n接下来 $q$ 组询问。每一组询问第一行是五个正整数 $x_1,y_1,x_2,y_2,p$，接下来 $p$ 行每行两个正整数 $c_i,d_i$，表示只希望矩阵内有棋子的位置。", "outputFormat": "对于每个询问，如果可以移动棋子（无次数限制）使得矩阵内有且仅有给定的位置上有棋子，输出 `YES`，否则输出 `NO`。", "hint": "**【样例解释 \\#1】**\n\n解释以 `0` 代表空位，`1` 代表放置了棋子的位置。\n\n初始状态：\n\n```plain\n011\n100\n011\n```\n\n对于第一个询问，可以证明 $(1,2)$ 处的棋子无法移出 $(1,2)$ 到 $(2,3)$ 的矩阵。\n\n对于第二个询问，考虑把 $(3,2)$ 处的棋子移到 $(2,3)$，得：\n\n```plain\n011\n101\n001\n```\n\n满足询问要求。移动方式不唯一。\n\n对于第三个询问，可以证明 $(2,1)$ 处的棋子无法移出 $(1,1)$ 到 $(2,3)$ 的矩阵。\n\n**【数据范围】**\n\n对于 $25\\%$ 的数据，$n,m,q\\le 10$，$c\\le 20$。\n\n对于另外 $25\\%$ 的数据，保证 $a_i+b_i\\equiv 0 \\pmod 2$，$c_i+d_i\\equiv 0 \\pmod 2$。\n\n对于另外 $25\\%$ 的数据，保证 $n\\cdot m-c\\le(x_2-x_1+1)\\cdot (y_2-y_1+1)-p$。\n\n对于 $100\\%$ 的数据，$2\\le n,m\\le 10^5$，$1\\le c,q\\le 10^5$，$c\\le n\\cdot m$，$1\\le a_i\\le n$，$1\\le b_i\\le m$，$\\sum p\\le 2\\times 10^5$。对于每个询问，$1\\le p\\le (x_2-x_1+1)\\cdot (y_2-y_1+1)$，$x_1\\le c_i\\le x_2$，$y_1\\le d_i\\le y_2$。\n\n**【提示与说明】**\n\n提供一种较快的读入一个 `int` 类型非负整数的方式。调用下文中的 `read()`，其作用是返回输入中的一个非负整数，同时读取其后的一个字符。\n\n```cpp\nint read() {\n  int x(0);\n  char c(getchar());\n  while (c < '0' || c > '9') c = getchar();\n  while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n  return x;\n}\n```", "locale": "zh-CN"}}}
{"pid": "P8885", "type": "P", "difficulty": 6, "samples": [["5\n100?1\n5\n1 5\n1 4\n2 5\n3 4\n1 3", "1\n0\n1\n1\n1"], ["20\n1110??01001010?1?110\n20\n1 20\n5 16\n11 16\n10 13\n5 14\n13 17\n1 18\n1 7\n6 9\n15 19\n12 17\n17 18\n4 11\n3 13\n13 15\n18 19\n2 8\n7 13\n4 15\n9 18", "3\n2\n2\n0\n4\n2\n13\n3\n0\n1\n3\n1\n2\n2\n2\n1\n2\n1\n1\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP"], "title": "「JEOI-R1」子序列", "background": "| 出题 | 标程 | 数据 | 验题 | 题解 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| [Pekemetier](/user/146070) | [Pekemetier](/user/146070) | [Pekemetier](/user/146070) | [cq_zry](https://www.luogu.com.cn/user/734533) & [lOlAKME](/user/768786) | [Pekemetier](/user/146070) |\n", "description": "给定一个仅包含 `0`、`1` 和 `?` 的字符串，你需要将字符串中的每个 `?` 分别替换成 `0` 或 `1` 之一。也就是说替换成一个 $01$ 字符串。求有多少种替换方案，使得替换后的字符串满足：恰好拥有奇数个**不同的**子序列（包含空串）的非空子串的个数为奇数。特别地，如果字符串中不包含 `?`，应将其自身视为唯一的替换方案。\n\n每个数据点会给定一个字符串 $s$ ，然后每次对 $s$ 的一个子串进行询问，答案对 $998244353$ 取模。", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个长为 $n$ 的字符串 $s$，仅包含 `0`、`1` 和 `?`。\n\n第三行一个整数 $m$ 表示询问次数。\n\n接下来 $m$ 行，每行两个整数 $l,r$ 表示对子串 $s_{l,r}$ 进行一次询问。", "outputFormat": "输出 $m$ 行，每行一个整数表示答案，对 $998244353$ 取模。\n\n不存在合法方案则输出 `0`。", "hint": "**【样例解释】**\n\n对于【样例\\#1】的第一个询问 `1 5`，有 $2$ 种替换方案，分别为字符串 `10001` 和 `10011`。\n\n其中 `10001` 有 $3$ 个子串满足不同的子序列的个数为奇数：`10001`，拥有 $15$ 个不同的子序列；$s'_ {2,3}$ 和 $s'_ {3,4}$ 均为 `00`，都拥有 $3$ 个不同的子序列。\n\n而 `10011` 则拥有 $4$ 个子串满足不同的子序列的个数为奇数，分别为 `1001`、`00`、`0011`、`11`。\n\n`10001` 有奇数个子串满足子序列个数为奇数，因此计入答案；而 `10011` 有偶数个，因此不计入答案。\n\n对于【样例#2】的第一个询问 `1 20`，$s_{1,20}$ 有 $4$ 个 `?`，因此有 $2^4=16$ 种替换方案。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $n\\leq$ | $m\\leq$ | 特殊性质 | $\\text{Score}$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $10$ |  | $10$ |\n| $2$ | $100$ | $100$ | $s$ 不包含 `?` | $10$ |\n| $3$ | $500$ | $500$ | $s$ 不包含 `?` | $20$ |\n| $4$ | $1000$ | $1000$ |  | $20$ |\n| $5$ | $5000$ | $5000$ |  | $10$ |\n| $6$ | $5000$ | $10^5$ |  | $10$ |\n| $7$ | $5\\times10^4$ | $3\\times 10^5$ |  | $20$ |\n\n对于 $100\\%$ 的数据，满足 $1\\leq n\\leq 5\\times10^4$，$1\\leq m\\leq 3\\times10^5$，$s$ 仅包含 `0`、`1` 和 `?`。\n\n---\n\n**【提示与说明】**\n\n子串：在原来的字符串中选出一段连续字符组成的字符串。一个长为 $n$ 的字符串有 $\\frac{n(n+1)}{2}$ 个子串。例如字符串 `121` 共有 $6$ 个子串，分别为 `1`、`2`、`1`、`12`、`21`、`121`。注意在本题中，空串不算一个子串。\n\n子序列：在原来的字符串中任意删去若干个字符（也可以不删）形成的的字符串。例如字符串 `0110` 拥有 $11$ 个不同的子序列，分别为空串、`0`、`1`、`00`、`01`、`10`、`11`、`010`、`011`、`110`、`0110`。注意在本题中，空串也算一个子序列。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「JEOI-R1」子序列", "background": "| 出题 | 标程 | 数据 | 验题 | 题解 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| [Pekemetier](/user/146070) | [Pekemetier](/user/146070) | [Pekemetier](/user/146070) | [cq_zry](https://www.luogu.com.cn/user/734533) & [lOlAKME](/user/768786) | [Pekemetier](/user/146070) |\n", "description": "给定一个仅包含 `0`、`1` 和 `?` 的字符串，你需要将字符串中的每个 `?` 分别替换成 `0` 或 `1` 之一。也就是说替换成一个 $01$ 字符串。求有多少种替换方案，使得替换后的字符串满足：恰好拥有奇数个**不同的**子序列（包含空串）的非空子串的个数为奇数。特别地，如果字符串中不包含 `?`，应将其自身视为唯一的替换方案。\n\n每个数据点会给定一个字符串 $s$ ，然后每次对 $s$ 的一个子串进行询问，答案对 $998244353$ 取模。", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个长为 $n$ 的字符串 $s$，仅包含 `0`、`1` 和 `?`。\n\n第三行一个整数 $m$ 表示询问次数。\n\n接下来 $m$ 行，每行两个整数 $l,r$ 表示对子串 $s_{l,r}$ 进行一次询问。", "outputFormat": "输出 $m$ 行，每行一个整数表示答案，对 $998244353$ 取模。\n\n不存在合法方案则输出 `0`。", "hint": "**【样例解释】**\n\n对于【样例\\#1】的第一个询问 `1 5`，有 $2$ 种替换方案，分别为字符串 `10001` 和 `10011`。\n\n其中 `10001` 有 $3$ 个子串满足不同的子序列的个数为奇数：`10001`，拥有 $15$ 个不同的子序列；$s'_ {2,3}$ 和 $s'_ {3,4}$ 均为 `00`，都拥有 $3$ 个不同的子序列。\n\n而 `10011` 则拥有 $4$ 个子串满足不同的子序列的个数为奇数，分别为 `1001`、`00`、`0011`、`11`。\n\n`10001` 有奇数个子串满足子序列个数为奇数，因此计入答案；而 `10011` 有偶数个，因此不计入答案。\n\n对于【样例#2】的第一个询问 `1 20`，$s_{1,20}$ 有 $4$ 个 `?`，因此有 $2^4=16$ 种替换方案。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $n\\leq$ | $m\\leq$ | 特殊性质 | $\\text{Score}$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $10$ |  | $10$ |\n| $2$ | $100$ | $100$ | $s$ 不包含 `?` | $10$ |\n| $3$ | $500$ | $500$ | $s$ 不包含 `?` | $20$ |\n| $4$ | $1000$ | $1000$ |  | $20$ |\n| $5$ | $5000$ | $5000$ |  | $10$ |\n| $6$ | $5000$ | $10^5$ |  | $10$ |\n| $7$ | $5\\times10^4$ | $3\\times 10^5$ |  | $20$ |\n\n对于 $100\\%$ 的数据，满足 $1\\leq n\\leq 5\\times10^4$，$1\\leq m\\leq 3\\times10^5$，$s$ 仅包含 `0`、`1` 和 `?`。\n\n---\n\n**【提示与说明】**\n\n子串：在原来的字符串中选出一段连续字符组成的字符串。一个长为 $n$ 的字符串有 $\\frac{n(n+1)}{2}$ 个子串。例如字符串 `121` 共有 $6$ 个子串，分别为 `1`、`2`、`1`、`12`、`21`、`121`。注意在本题中，空串不算一个子串。\n\n子序列：在原来的字符串中任意删去若干个字符（也可以不删）形成的的字符串。例如字符串 `0110` 拥有 $11$ 个不同的子序列，分别为空串、`0`、`1`、`00`、`01`、`10`、`11`、`010`、`011`、`110`、`0110`。注意在本题中，空串也算一个子序列。", "locale": "zh-CN"}}}
{"pid": "P8886", "type": "P", "difficulty": 4, "samples": [["2\n5\n..###\n#.#.#\n#..##\n...#.\n.###.\n5\n..#..\n##..#\n#.#..\n..#..\n.#...", "2\n2"], ["4\n5\n...*.\n*##*.\n#..*.\n#*###\n.....\n5\n.#*..\n.**.#\n###.*\n***.*\n**...\n5\n.**..\n***.#\n###.*\n***.*\n*****\n5\n.**..\n***.#\n###..\n***.*\n***..", "4\n2\n"], ["见下发文件portal1.in", "见下发文件portal1.ans"], ["见下发文件portal2.in", "见下发文件portal2.ans"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "O2优化", "图论建模", "最短路"], "title": "[DMOI-R1] Portal", "background": "出题人正在玩一款叫 Portal 的游戏。但由于他太菜了，于是找来了你，让你帮他过几个他过不去的关卡。\n\n什么？你说你不会玩？\n\n玩家需要通过传送门枪到达出口。利用传送门枪射击可开出两种门，分别是橙色门和蓝色门，两面都可作入口及出口。在创造门的时候，另一道同样颜色的门会消失，即是说同时间不可能存在两道同色的门，最多只可同时存在一道蓝色及一道橙色的门。\n\n两道传送门在三维空间之中的两个地点创造出视觉上及物理上的连系，传送门的立点只限于平面，玩家从门出来时会自动配合地心吸力调整身体水平。\n\n出题人把所有希望都寄托于你身上了哟。哦，对了，因为出题人是个白嫖党，因此他拥有的是盗版 Portal。", "description": "在一个 $n \\times n$ 的二维平面图上，用 $(x,y)$ 表示地图第 $x$ 行第 $y$ 列。每个点都是墙、虚空和地面中的一种，分别用 `#`，`*`，`.` 表示。玩家只能站在地面上。**地图之外都是墙。**\n\n你手里有一个传送门枪，可以发射蓝色和橙色的传送门，只能朝上下左右四个方向使用。\n\n在选定一个方向和颜色后，将会在该方向上第一个碰到的墙的墙面上建造选定颜色的传送门，并摧毁之前建造的这种颜色的传送门。两种颜色的传送门不能被建立在同一墙面。\n\n玩家可以朝上下左右四个方向的空地移动。玩家还可以在不同色传送门之间穿梭。假如玩家朝一堵墙移动并且墙面上有传送门，并且当前已经建立了两个传送门，那么会从另一个传送门出来（必须保证出来也站在陆地上）。\n\n出来的时候，玩家会站在另一个门外的空地上，**四个方向都可以。**\n\n一开始玩家站在 $(1,1)$，目的地是 $(n,n)$。求最少使用多少次传送门枪才能到达目的地。\n\n**注意哦，这里的使用指的是穿过多少面传送门。**", "inputFormat": "第一行一个正整数 $T$ 表示数据组数。\n\n每组数据第一行一个正整数 $n$ 表示平面图的行数和列数。\n\n接下来 $n$ 行每行 $n$ 个字符只包含 `#`，`*`，`.` 三种字符表示地图。", "outputFormat": "对于每组数据输出一个数表示最少需要使用传送门枪的次数。无法到达输出 `-1`。如果起点或终点不为陆地，那么直接结束程序。", "hint": "### 样例1解释\n\n我们用白色格子表示空地，黑色格子表示墙，蓝色格子表示蓝色传送门，橙色格子表示橙色传送门，可以画出第一局的如下地图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s16tq3vq.png)\n\n走到橙色传送门处，从橙色传送门进入，蓝色传送门出即可。\n\n而第二局地图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v7q0izdk.png)\n\n\n走到蓝色传送门处，从蓝色传送门进入，橙色传送门出即可。\n\n### 数据范围\n\n对于 $20\\%$ 的数据，$n \\le 10$。\n\n对于 $60\\%$ 的数据，$n \\le 100$。\n\n对于另外 $10\\%$ 的数据，$T=1$ 且不存在虚空。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 500$，$1 \\le T \\le 10$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[DMOI-R1] Portal", "background": "出题人正在玩一款叫 Portal 的游戏。但由于他太菜了，于是找来了你，让你帮他过几个他过不去的关卡。\n\n什么？你说你不会玩？\n\n玩家需要通过传送门枪到达出口。利用传送门枪射击可开出两种门，分别是橙色门和蓝色门，两面都可作入口及出口。在创造门的时候，另一道同样颜色的门会消失，即是说同时间不可能存在两道同色的门，最多只可同时存在一道蓝色及一道橙色的门。\n\n两道传送门在三维空间之中的两个地点创造出视觉上及物理上的连系，传送门的立点只限于平面，玩家从门出来时会自动配合地心吸力调整身体水平。\n\n出题人把所有希望都寄托于你身上了哟。哦，对了，因为出题人是个白嫖党，因此他拥有的是盗版 Portal。", "description": "在一个 $n \\times n$ 的二维平面图上，用 $(x,y)$ 表示地图第 $x$ 行第 $y$ 列。每个点都是墙、虚空和地面中的一种，分别用 `#`，`*`，`.` 表示。玩家只能站在地面上。**地图之外都是墙。**\n\n你手里有一个传送门枪，可以发射蓝色和橙色的传送门，只能朝上下左右四个方向使用。\n\n在选定一个方向和颜色后，将会在该方向上第一个碰到的墙的墙面上建造选定颜色的传送门，并摧毁之前建造的这种颜色的传送门。两种颜色的传送门不能被建立在同一墙面。\n\n玩家可以朝上下左右四个方向的空地移动。玩家还可以在不同色传送门之间穿梭。假如玩家朝一堵墙移动并且墙面上有传送门，并且当前已经建立了两个传送门，那么会从另一个传送门出来（必须保证出来也站在陆地上）。\n\n出来的时候，玩家会站在另一个门外的空地上，**四个方向都可以。**\n\n一开始玩家站在 $(1,1)$，目的地是 $(n,n)$。求最少使用多少次传送门枪才能到达目的地。\n\n**注意哦，这里的使用指的是穿过多少面传送门。**", "inputFormat": "第一行一个正整数 $T$ 表示数据组数。\n\n每组数据第一行一个正整数 $n$ 表示平面图的行数和列数。\n\n接下来 $n$ 行每行 $n$ 个字符只包含 `#`，`*`，`.` 三种字符表示地图。", "outputFormat": "对于每组数据输出一个数表示最少需要使用传送门枪的次数。无法到达输出 `-1`。如果起点或终点不为陆地，那么直接结束程序。", "hint": "### 样例1解释\n\n我们用白色格子表示空地，黑色格子表示墙，蓝色格子表示蓝色传送门，橙色格子表示橙色传送门，可以画出第一局的如下地图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s16tq3vq.png)\n\n走到橙色传送门处，从橙色传送门进入，蓝色传送门出即可。\n\n而第二局地图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v7q0izdk.png)\n\n\n走到蓝色传送门处，从蓝色传送门进入，橙色传送门出即可。\n\n### 数据范围\n\n对于 $20\\%$ 的数据，$n \\le 10$。\n\n对于 $60\\%$ 的数据，$n \\le 100$。\n\n对于另外 $10\\%$ 的数据，$T=1$ 且不存在虚空。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 500$，$1 \\le T \\le 10$。", "locale": "zh-CN"}}}
{"pid": "P8887", "type": "P", "difficulty": 3, "samples": [["3\n2 5 493\n3 8 3219\n8 4 1294", "B won\nA won\nB won"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "博弈论", "洛谷原创", "O2优化"], "title": "[DMOI-R1] 柯基棋", "background": "小 A 和小 B 都是爱狗人士，且绝顶聪明，尤其喜爱柯基，于是他们发明了“柯基棋”。", "description": "小 A 和小 B 在一个 $n \\times n$ 的棋盘内轮流下棋。小 A 先手，小 B 后手。设当前有一只“柯基”被下在了棋盘的 $(x,y)$ 处，那么棋盘内的 $(x-1,y-1)$，$(x-1,y+1)$，$(x+1,y-1)$，$(x+1,y+1)$ 处都会变为这只“柯基”的地盘，也就不能再放一只“柯基”。当一个人不能再放下一只“柯基”时，他就输了。\n\n可惜，小 C 却不怎么喜欢柯基，所以他很反对小 A 和小 B 玩“柯基”棋，于是他非常喜欢捣乱棋局。当小 A 和小 B 一共下了 $x_i$ 只“柯基”时，小 C 就会以当前 $w \\times w$ 棋盘的中心为中心，扩大棋盘为 $(w+2) \\times (w+2)$，他一共会捣乱 $q$ 次。\n\n而你的任务是要判断这局棋是小 A 赢还是小 B 赢，如果小 A  赢，输出 `A won`，否则输出 `B won`。\n\n由于他们两个人比较贪玩，所以他们一共会玩 $T$ 局。\n\n**注意**：\n\n1. 当小 A 和小 B 已经将原来的棋盘下到不能再下时，他们会直接跳转到小 C 下一次的捣乱（如果有）。\n\n2. 小 A 和小 B 知道小 C 会捣乱，且会按照自己的最优策略走。\n\n由于数据过大，$x_i$ 由数据随机生成器给出。", "inputFormat": "第一行一个正整数 $T$，表示 $T$ 组数据。\n\n每组数据一行三个正整数 $n,q,seed$，其中 $seed$ 的作用见提示说明。", "outputFormat": "共 $T$ 行，每一行输出一个字符串 `A won` 或 `B won`。", "hint": "### 随机数据生成器\n\n每一轮游戏的 $x_i$ 由下方的生成器给出：\n\n```cpp\nunsigned long long x[10000005];\nunsigned long long xor_shift(unsigned long long &seed){\n  return seed^=seed>>12, seed^=seed<<25, seed^=seed>>27, seed*0x2545F4914F6CDD1D;\n}\nint main(){\n  //your code here\n  int n,q;\n  unsigned long long seed;\n  cin>>n>>q>>seed;\n  for(int i=1;i<=q;i++){\n\tx[i]=x[i-1]+((xor_shift(seed)%(unsigned long long)(2*2)+1))*2;\n  }\n  //your code here\n  return 0;\n}\n```\n\n### 样例解释\n\n对于第一局游戏，$x_i$ 数组如下：`6 8 16 18 22`。\n\n对于第二局游戏，$x_i$ 数组如下：`8 14 16 24 32 36 38 40`。\n\n对于第三局游戏，$x_i$ 数组如下：`4 8 10 16`。\n\n### 数据范围\n\n对于 $20\\%$ 的数据，$n,q\\leq100$。\n\n对于 $50\\%$ 的数据，$n,q\\leq10000$。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 10,2\\leq n,q,\\sum q \\leq 10^7$，$x_i \\equiv 0 \\pmod 2\\ (i\\in[1,q]),0 \\le seed \\le 10^7$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[DMOI-R1] 柯基棋", "background": "小 A 和小 B 都是爱狗人士，且绝顶聪明，尤其喜爱柯基，于是他们发明了“柯基棋”。", "description": "小 A 和小 B 在一个 $n \\times n$ 的棋盘内轮流下棋。小 A 先手，小 B 后手。设当前有一只“柯基”被下在了棋盘的 $(x,y)$ 处，那么棋盘内的 $(x-1,y-1)$，$(x-1,y+1)$，$(x+1,y-1)$，$(x+1,y+1)$ 处都会变为这只“柯基”的地盘，也就不能再放一只“柯基”。当一个人不能再放下一只“柯基”时，他就输了。\n\n可惜，小 C 却不怎么喜欢柯基，所以他很反对小 A 和小 B 玩“柯基”棋，于是他非常喜欢捣乱棋局。当小 A 和小 B 一共下了 $x_i$ 只“柯基”时，小 C 就会以当前 $w \\times w$ 棋盘的中心为中心，扩大棋盘为 $(w+2) \\times (w+2)$，他一共会捣乱 $q$ 次。\n\n而你的任务是要判断这局棋是小 A 赢还是小 B 赢，如果小 A  赢，输出 `A won`，否则输出 `B won`。\n\n由于他们两个人比较贪玩，所以他们一共会玩 $T$ 局。\n\n**注意**：\n\n1. 当小 A 和小 B 已经将原来的棋盘下到不能再下时，他们会直接跳转到小 C 下一次的捣乱（如果有）。\n\n2. 小 A 和小 B 知道小 C 会捣乱，且会按照自己的最优策略走。\n\n由于数据过大，$x_i$ 由数据随机生成器给出。", "inputFormat": "第一行一个正整数 $T$，表示 $T$ 组数据。\n\n每组数据一行三个正整数 $n,q,seed$，其中 $seed$ 的作用见提示说明。", "outputFormat": "共 $T$ 行，每一行输出一个字符串 `A won` 或 `B won`。", "hint": "### 随机数据生成器\n\n每一轮游戏的 $x_i$ 由下方的生成器给出：\n\n```cpp\nunsigned long long x[10000005];\nunsigned long long xor_shift(unsigned long long &seed){\n  return seed^=seed>>12, seed^=seed<<25, seed^=seed>>27, seed*0x2545F4914F6CDD1D;\n}\nint main(){\n  //your code here\n  int n,q;\n  unsigned long long seed;\n  cin>>n>>q>>seed;\n  for(int i=1;i<=q;i++){\n\tx[i]=x[i-1]+((xor_shift(seed)%(unsigned long long)(2*2)+1))*2;\n  }\n  //your code here\n  return 0;\n}\n```\n\n### 样例解释\n\n对于第一局游戏，$x_i$ 数组如下：`6 8 16 18 22`。\n\n对于第二局游戏，$x_i$ 数组如下：`8 14 16 24 32 36 38 40`。\n\n对于第三局游戏，$x_i$ 数组如下：`4 8 10 16`。\n\n### 数据范围\n\n对于 $20\\%$ 的数据，$n,q\\leq100$。\n\n对于 $50\\%$ 的数据，$n,q\\leq10000$。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 10,2\\leq n,q,\\sum q \\leq 10^7$，$x_i \\equiv 0 \\pmod 2\\ (i\\in[1,q]),0 \\le seed \\le 10^7$。\n", "locale": "zh-CN"}}}
{"pid": "P8888", "type": "P", "difficulty": 5, "samples": [["7 6\n1 9 1 9 8 1 0\n1 1 4 5 1 4\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n1 0 1 0", "45"], ["4 4\n-2 -2 -2 -2\n2 3 4 9\n4 -2 0 4\n0 0 0 0\n-1 0 1 0\n0 0 2 0\n1 2 1 0", "15"]], "limits": {"time": [1200, 1200, 1200, 1200, 1200, 1200, 1200], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "O2优化"], "title": "[DMOI-R1] 实验基地", "background": "小 A 和小 B 用实验基地全新的装备进行了一场世纪蒟蒻之战。", "description": "众所周知，实验基地的武器都是一次性的。现在，小 A 选取了 $n$ 把不同的武器，小 B 也获取了 $m$ 把不同武器。每个人的武器都可以用编号 $1$ 到编号 $n$ 或 $m$ 依次表示，他们将会按此顺序逐个使用武器。\n\n实验仓库记录了所有武器的火力。小 A 的第 $k$ 把武器能爆发出 $a_k$ 的能量，而小 B 的第 $k$ 把武器能爆发出 $b_k$ 的能量。特别的，当小 A 的第 $i$ 把武器与小 B 的第 $j$ 把武器同时使用，会释放 $d_{i,j}$ 的能量。由于某些不可描述的组合的奇效，$a,b,d$ **都可能小于** $0$。\n\n当某人第一个使用了武器，战斗就正式开始，记为第 $1$ 秒，直至某人使用完武器后再无人使用武器，记此时为第 $t$ 秒（$t$ **不为输入数据**）。也就是说，**在第 $1$ 秒和第 $t$ 秒必须有人使用武器，而在 $1$ 至 $t$ 秒内在符合其他条件下，每一秒双方可以选择按顺序使用武器或不使用**。\n\n为了避免打死对方，**双方都不一定使用完武器**。\n\n由于实验基地有发电装置，如果小 A 没有连续使用武器释放能量，而是休息了 $x$ 秒，那么祂将会吸收掉 $Ax+B\\ (A,B \\in \\mathbb{N})$ 的能量。同样，小 B 间隔 $y$ 秒将吸收 $Cy+D\\ (C,D \\in \\mathbb{N})$ 的能量。连续两秒都释放武器间隔时间为 $0$ 秒，以此类推。\n\n为了防止基地被核爆，你需要算出战斗结束后可能释放的最大总能量（可能为负数）。\n\n**若对题目细节有疑惑请先读提示内的额外解释。**", "inputFormat": "第一行有两个数 $n$ 和 $m$。\n\n第二行有 $n$ 个数，第 $k$ 个数字即 $a_k$。\n\n第三行有 $m$ 个数，第 $k$ 个数字即 $b_k$。\n\n接下来 $n$ 行，每行 $m$ 个数字，其中第 $i$ 行第 $j$ 列表示的是 $d_{i,j}$。\n\n最后一行有四个非负整数 $A,B,C,D$。", "outputFormat": "只有一行，输出一个数字，即最大可能能量。", "hint": "1. 战斗的开始时间（第 $1$ 秒）为双方某人最先释放出第一个技能的时间，战斗结束时间为双方某人释放出最后一个技能的时间。**结束时间不定**。\n\n2. 技能必须按顺序释放，但**不一定需要在战斗中释放完**。\n\n3. $a,b,d$ 可以为负数，总计能量可能为负，“吸收能量”指总能量减少 $Ax+B$ 或 $Cy+D$，也就是**间隔时总能量一定减少**，而且时间越长减少越多。\n\n4. 本题 IO 量较大，建议使用合适的读入方式。\n\n### 样例解释：\n\n样例 1：每个人在 $1$ 到 $6$ 秒依次使用自己的编号为 $1$ 到 $6$  的武器即可取到最大值。\n\n样例 2：小 B 在 $1$ 到 $4$ 秒依次使用自己的编号为 $1$ 到 $4$ 的武器，小 A 在第 $4$ 秒使用自己的 $1$ 号武器可以取到最大值。其中单个武器释放的能量为 $(-2)+(2+3+4+9) = 16$，武器碰撞释放 $d_{1,4} = 4$ 单位的能量，小 A 在前 $3$ 秒吸收了 $A \\times 3 + B = 5$ 单位的能量。\n\n### 数据范围：\n\n|Subtask|$n\\leq$|$m\\leq$|分值|\n|-|-|-|-|\n|$1$|$10$|$10$|$20$|\n|$2$|$500$|$500$|$30$|\n|$3$|$3000$|$3000$|$50$|\n\n**本题采用捆绑测试**，您只有通过了一个 Subtask 中的所有测试点才能得到这个 Subtask 的分数。\n\n对于 $100\\%$ 的数据：$0 \\le |a_k|,|b_k|,|d_{i,j}|,A,B,C,D \\leq 1000$, $1\\leq n, m\\leq 3000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[DMOI-R1] 实验基地", "background": "小 A 和小 B 用实验基地全新的装备进行了一场世纪蒟蒻之战。", "description": "众所周知，实验基地的武器都是一次性的。现在，小 A 选取了 $n$ 把不同的武器，小 B 也获取了 $m$ 把不同武器。每个人的武器都可以用编号 $1$ 到编号 $n$ 或 $m$ 依次表示，他们将会按此顺序逐个使用武器。\n\n实验仓库记录了所有武器的火力。小 A 的第 $k$ 把武器能爆发出 $a_k$ 的能量，而小 B 的第 $k$ 把武器能爆发出 $b_k$ 的能量。特别的，当小 A 的第 $i$ 把武器与小 B 的第 $j$ 把武器同时使用，会释放 $d_{i,j}$ 的能量。由于某些不可描述的组合的奇效，$a,b,d$ **都可能小于** $0$。\n\n当某人第一个使用了武器，战斗就正式开始，记为第 $1$ 秒，直至某人使用完武器后再无人使用武器，记此时为第 $t$ 秒（$t$ **不为输入数据**）。也就是说，**在第 $1$ 秒和第 $t$ 秒必须有人使用武器，而在 $1$ 至 $t$ 秒内在符合其他条件下，每一秒双方可以选择按顺序使用武器或不使用**。\n\n为了避免打死对方，**双方都不一定使用完武器**。\n\n由于实验基地有发电装置，如果小 A 没有连续使用武器释放能量，而是休息了 $x$ 秒，那么祂将会吸收掉 $Ax+B\\ (A,B \\in \\mathbb{N})$ 的能量。同样，小 B 间隔 $y$ 秒将吸收 $Cy+D\\ (C,D \\in \\mathbb{N})$ 的能量。连续两秒都释放武器间隔时间为 $0$ 秒，以此类推。\n\n为了防止基地被核爆，你需要算出战斗结束后可能释放的最大总能量（可能为负数）。\n\n**若对题目细节有疑惑请先读提示内的额外解释。**", "inputFormat": "第一行有两个数 $n$ 和 $m$。\n\n第二行有 $n$ 个数，第 $k$ 个数字即 $a_k$。\n\n第三行有 $m$ 个数，第 $k$ 个数字即 $b_k$。\n\n接下来 $n$ 行，每行 $m$ 个数字，其中第 $i$ 行第 $j$ 列表示的是 $d_{i,j}$。\n\n最后一行有四个非负整数 $A,B,C,D$。", "outputFormat": "只有一行，输出一个数字，即最大可能能量。", "hint": "1. 战斗的开始时间（第 $1$ 秒）为双方某人最先释放出第一个技能的时间，战斗结束时间为双方某人释放出最后一个技能的时间。**结束时间不定**。\n\n2. 技能必须按顺序释放，但**不一定需要在战斗中释放完**。\n\n3. $a,b,d$ 可以为负数，总计能量可能为负，“吸收能量”指总能量减少 $Ax+B$ 或 $Cy+D$，也就是**间隔时总能量一定减少**，而且时间越长减少越多。\n\n4. 本题 IO 量较大，建议使用合适的读入方式。\n\n### 样例解释：\n\n样例 1：每个人在 $1$ 到 $6$ 秒依次使用自己的编号为 $1$ 到 $6$  的武器即可取到最大值。\n\n样例 2：小 B 在 $1$ 到 $4$ 秒依次使用自己的编号为 $1$ 到 $4$ 的武器，小 A 在第 $4$ 秒使用自己的 $1$ 号武器可以取到最大值。其中单个武器释放的能量为 $(-2)+(2+3+4+9) = 16$，武器碰撞释放 $d_{1,4} = 4$ 单位的能量，小 A 在前 $3$ 秒吸收了 $A \\times 3 + B = 5$ 单位的能量。\n\n### 数据范围：\n\n|Subtask|$n\\leq$|$m\\leq$|分值|\n|-|-|-|-|\n|$1$|$10$|$10$|$20$|\n|$2$|$500$|$500$|$30$|\n|$3$|$3000$|$3000$|$50$|\n\n**本题采用捆绑测试**，您只有通过了一个 Subtask 中的所有测试点才能得到这个 Subtask 的分数。\n\n对于 $100\\%$ 的数据：$0 \\le |a_k|,|b_k|,|d_{i,j}|,A,B,C,D \\leq 1000$, $1\\leq n, m\\leq 3000$。", "locale": "zh-CN"}}}
{"pid": "P8889", "type": "P", "difficulty": 2, "samples": [["6 2\n3 4 3 5 2 6\n5 4", "3"], ["6 3\n3 4 3 5 2 6\n3 5 6", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["二分", "2022", "O2优化", "排序", "双指针 two-pointer", "语言月赛"], "title": "[入门赛 #7] 狠狠地切割 (Hard Version)", "background": "**本题与 H1 的题意完全一致，区别仅在数据范围。在语言月赛中不存在 H2 题目，本题仅用于增加公开赛的区分度，并不严格遵循比赛考察范围，请酌情完成。**", "description": "现给你一个长度为 $n$ 的序列 $a _ 1, \\cdots, a _ n$ 和 $m$ 个互不相同的整数 $b _ 1, \\cdots, b _ m$。你需要按照这 $m$ 个数对序列 $a$ 进行**狠狠地切割**。\n\n具体的，对于一个数字 $i \\in [1, n]$，如果存在一个整数 $j \\in [1, m]$，使得 $a _ i = b _ j$，则将位置 $i$ 称为一个**切割点**。对序列 $a$ 中的每一个切割点，我们在这个位置进行一次**狠狠地切割**。方法是，将该位置的数字去除，然后在这个位置将其左右的**序列/片段**一分两半。\n\n如果对**狠狠地切割**的定义有疑问，可以参照「样例 #1」及「样例解释 #1」进行理解。\n\n你需要计算，在进行了所有可能的**狠狠地切割**后，序列被切割为了多少**片段**。\n\n特别的，如果在切割后，某一段内没有数组，那这一段不可被叫做**片段**。同样的，如果 $1$ 或 $n$ 为切割点，其与开头和结尾之间也不存在片段。\n\n如果对**片段**的概念有疑问，可以参照「样例 #2」及「样例解释 #2」进行理解。", "inputFormat": "第一行为两个整数，依次表示序列 $a$ 的长度 $n$ 和序列 $b$ 的长度 $m$。  \n第二行有 $n$ 个整数，第 $i$ 个整数表示 $a_i$。  \n第三行有 $m$ 个整数，第 $i$ 个整数表示 $b_i$。", "outputFormat": "\n输出一个整数，代表**狠狠地切割**后的**片段**的个数。", "hint": "### 样例 1 解释\n\n在**狠狠地切割**前，序列 $a$ 如下所示：\n\n$$\\begin{matrix} 3 & 4 & 3 & 5 & 2 & 6 \\end{matrix}$$\n\n容易知道，第二个位置和第四个位置为切割点，我们使用 `|` 对其进行替换，代表去除工作：\n\n$$\\begin{matrix} 3 & | & 3 & | & 2 & 6 \\end{matrix}$$\n\n我们将片段进行简单的标记：\n\n$$\\begin{matrix} \\overbrace{3} ^ \\text{片段 1} & | & \\overbrace{3} ^ \\text{片段 2} & | & \\overbrace{2 \\quad 6} ^ \\text{片段 3} \\end{matrix}$$\n\n共计 $3$ 个片段。\n\n### 样例 2 解释\n\n以下我们展示去除之后的序列：\n\n$$\\begin{matrix} | & 4 & | & | & 2 & | \\end{matrix}$$\n\n我们将片段进行简单的标记：\n\n$$\\begin{matrix} \\overbrace{\\vphantom{0}} ^ \\text{\\color{red}这个不是片段} | & \\overbrace{4} ^ \\text{片段 1} & | & \\overbrace{\\vphantom{0}} ^ \\text{\\color{red}这个不是片段} & | & \\overbrace{2} ^ \\text{片段 2} & | \\overbrace{\\vphantom{0}} ^ \\text{\\color{red}这个不是片段}\\end{matrix}$$\n\n共计 $2$ 个片段。\n\n### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $a$ 序列中没有任何元素在 $b$ 中出现过。形式化的，$\\forall i \\in [1, n], \\forall j \\in [1, m], a _ i \\neq b _ j$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n, m \\leq 5 \\times 10 ^ 5$，$- 10 ^ {18} \\leq a _ i, b_i \\leq 10 ^ {18}$，序列 $b$ 中的元素两两不同。\n\n### 提示\n本题输入规模较大，建议考虑使用较快的读入读出方式。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[入门赛 #7] 狠狠地切割 (Hard Version)", "background": "**本题与 H1 的题意完全一致，区别仅在数据范围。在语言月赛中不存在 H2 题目，本题仅用于增加公开赛的区分度，并不严格遵循比赛考察范围，请酌情完成。**", "description": "现给你一个长度为 $n$ 的序列 $a _ 1, \\cdots, a _ n$ 和 $m$ 个互不相同的整数 $b _ 1, \\cdots, b _ m$。你需要按照这 $m$ 个数对序列 $a$ 进行**狠狠地切割**。\n\n具体的，对于一个数字 $i \\in [1, n]$，如果存在一个整数 $j \\in [1, m]$，使得 $a _ i = b _ j$，则将位置 $i$ 称为一个**切割点**。对序列 $a$ 中的每一个切割点，我们在这个位置进行一次**狠狠地切割**。方法是，将该位置的数字去除，然后在这个位置将其左右的**序列/片段**一分两半。\n\n如果对**狠狠地切割**的定义有疑问，可以参照「样例 #1」及「样例解释 #1」进行理解。\n\n你需要计算，在进行了所有可能的**狠狠地切割**后，序列被切割为了多少**片段**。\n\n特别的，如果在切割后，某一段内没有数组，那这一段不可被叫做**片段**。同样的，如果 $1$ 或 $n$ 为切割点，其与开头和结尾之间也不存在片段。\n\n如果对**片段**的概念有疑问，可以参照「样例 #2」及「样例解释 #2」进行理解。", "inputFormat": "第一行为两个整数，依次表示序列 $a$ 的长度 $n$ 和序列 $b$ 的长度 $m$。  \n第二行有 $n$ 个整数，第 $i$ 个整数表示 $a_i$。  \n第三行有 $m$ 个整数，第 $i$ 个整数表示 $b_i$。", "outputFormat": "\n输出一个整数，代表**狠狠地切割**后的**片段**的个数。", "hint": "### 样例 1 解释\n\n在**狠狠地切割**前，序列 $a$ 如下所示：\n\n$$\\begin{matrix} 3 & 4 & 3 & 5 & 2 & 6 \\end{matrix}$$\n\n容易知道，第二个位置和第四个位置为切割点，我们使用 `|` 对其进行替换，代表去除工作：\n\n$$\\begin{matrix} 3 & | & 3 & | & 2 & 6 \\end{matrix}$$\n\n我们将片段进行简单的标记：\n\n$$\\begin{matrix} \\overbrace{3} ^ \\text{片段 1} & | & \\overbrace{3} ^ \\text{片段 2} & | & \\overbrace{2 \\quad 6} ^ \\text{片段 3} \\end{matrix}$$\n\n共计 $3$ 个片段。\n\n### 样例 2 解释\n\n以下我们展示去除之后的序列：\n\n$$\\begin{matrix} | & 4 & | & | & 2 & | \\end{matrix}$$\n\n我们将片段进行简单的标记：\n\n$$\\begin{matrix} \\overbrace{\\vphantom{0}} ^ \\text{\\color{red}这个不是片段} | & \\overbrace{4} ^ \\text{片段 1} & | & \\overbrace{\\vphantom{0}} ^ \\text{\\color{red}这个不是片段} & | & \\overbrace{2} ^ \\text{片段 2} & | \\overbrace{\\vphantom{0}} ^ \\text{\\color{red}这个不是片段}\\end{matrix}$$\n\n共计 $2$ 个片段。\n\n### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $a$ 序列中没有任何元素在 $b$ 中出现过。形式化的，$\\forall i \\in [1, n], \\forall j \\in [1, m], a _ i \\neq b _ j$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n, m \\leq 5 \\times 10 ^ 5$，$- 10 ^ {18} \\leq a _ i, b_i \\leq 10 ^ {18}$，序列 $b$ 中的元素两两不同。\n\n### 提示\n本题输入规模较大，建议考虑使用较快的读入读出方式。", "locale": "zh-CN"}}}
{"pid": "P8890", "type": "P", "difficulty": 4, "samples": [["2 2 4\n0:00:01 A abc Wrong Answer\n0:00:02 A abc Accepted\n0:19:38 A bcd Accepted\n4:18:22 B abc Accepted", "abc\nbcd\nabc\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["模拟", "2022", "O2优化", "结构体", "语言月赛"], "title": "[入门赛 #7] 打 ACM 最快乐的就是滚榜读队名了 (Hard Version)", "background": "**本题的题意与 [I1](https://www.luogu.com.cn/problem/B3692) 完全相同，区别仅在 $m$ 和 $K$ 的范围。**\n\n在刚刚结束的 ICPC 杭州赛站上，某 E 经历了刺激的滚榜。她发现打 ACM 最快乐的就是滚榜读队名了。", "description": "一场 ICPC 正式赛共 $5$ 小时。\n\n队伍的排名由通过题数与罚时决定。通过题数更多的队伍排名更靠前，若通过题数相同，则罚时更小的队伍排名更靠前。通过题数与罚时均相同的队伍排名相同。本题中可能出现队伍排名相同的情况，此时，认为先出现在提交记录中的队伍排名靠前。\n\n罚时是由通过题目的时间和未通过提交的次数决定的。罚时为每一道题通过时比赛开始的分钟数之和，加上该题之前未通过提交的次数乘 $20$ 分钟得到的。例如，某队在比赛进行 $1:28:35$ 时通过了 G 题，在此之前共有 $3$ 次未通过的提交，则 G 题对罚时的总贡献为 $88+3 \\times 20=148$ 分钟。\n\n**需要注意的是，仅有通过的试题的未通过提交会被计算罚时**。例如，某队在 I 题共有 $14$ 次未通过的提交，但到比赛结束，该队都没有通过 I 题，则这 $14$ 次未通过的提交不会被计算罚时。**在某一题通过后，该队对这一题的任何提交（无论是否能够通过）都不会影响本题通过的结果和本题的罚时。**\n\n选手在比赛过程中可以随时提交某一道试题的代码，代码将被立即评测并返回结果（$\\texttt{Accepted}$，$\\texttt{Time Limit Exceeded}$，$\\texttt{Memory Limit Exceeded}$，$\\texttt{Presentation Error}$，$\\texttt{Wrong Answer}$，$\\texttt{Runtime Error}$）。其中，评测结果 $\\texttt{Accepted}$ 为通过，其他评测结果均为不通过。\n\n在比赛进行的前四小时（$0:00:00 \\sim 4:00:00$），每支队伍的提交均会在排行榜上反映出来。比赛的最后一小时（$4:00:01 \\sim 5:00:00$），排行榜将被冻结（封榜），所有的提交在排行榜对应队伍对应试题上均显示为待判题（提交的队伍知道评测结果）。\n\n在比赛结束后，会进行紧张刺激的滚榜环节。滚榜嘉宾将按照封榜时的排行榜，依照从最后一名到第一名，**先读出队伍队名**，再按照从 A 题依次到最后一题的顺序，公布排行榜上该队“待判题”状态试题最终是否通过。\n\n如果通过，所有队伍的排名将立即重新计算，显然，已经滚榜完成（被滚榜嘉宾念过队名，且所有待判题状态的结果都已经揭晓）的队伍排名不会有影响。若该队伍排名上升，则滚榜嘉宾立即开始下一支队伍的滚榜。因此，一支队伍的队名可能被滚榜嘉宾多次读出。\n\n例如，某队队名为“囤题”，在前四小时没有通过任何一题，封榜时排在最后一名。在封榜后，该队连续通过全部十三道题目。那么滚榜嘉宾有可能读到该队队名七八次。当然，当该队上升到第一名后，其排名不会再发生变化，即使揭晓的判题结果为通过，但其排名没有发生变化，滚榜嘉宾不会再次读出其队名。\n\n现在给出某场 ICPC 完整的提交记录，请你依次输出滚榜嘉宾念出的队名。\n\n**一次提交记录都没有的队伍不会在排行榜上出现，也不会在滚榜中被念到队名。**", "inputFormat": "输入的第一行为三个整数 $n,m,K$，依次为该场 ICPC 试题数、该场 ICPC 队伍数、该场 ICPC 提交记录数。\n\n接下来 $K$ 行，每行为四个空格分隔的字符串，表达一条提交记录。第一个形如 $x:yy:zz$，代表该记录在比赛开始 $x$ 小时 $yy$ 分钟 $zz$ 秒时提交。第二个字符串为一个大写英文字母，代表试题的编号（$\\texttt{A,B,} \\cdots$）。第三个字符串为队名，保证队名不含空格。第四个字符串（可能含有空格，但为仅出现「题目描述」中的六种评测结果）为该评测记录的评测结果，具体字符串的含义见试题描述部分。", "outputFormat": "输出若干行，为该滚榜嘉宾依次读到的队名。", "hint": "### 样例解释\n\n在封榜前，队伍 $\\texttt{abc}$ 仅通过 $\\texttt{A}$ 题，且在第二秒的第一次正确提交之前有一次错误提交，因此罚时为 $20$ 分钟；队伍 $\\texttt{bcd}$ 同样仅通过 $\\texttt{A}$ 题，且在 $0:19:38$ 的第一次正确提交之前没有错误提交，因此罚时为 $19$ 分钟。\n\n在封榜后，队伍 $\\texttt{abc}$ 通过了 $\\texttt{B}$ 题。\n\n在滚榜环节开始，由于封榜后的提交未被揭晓，因此暂时认为队伍 $\\texttt{abc}$ 与 $\\texttt{bcd}$ 均只通过一题，且前者罚时较大，排名靠后。\n\n依照从最后一名到第一名的原则，队伍 $\\texttt{abc}$ 的名字先被念到，并揭晓其在封榜后的提交的结果。其通过了 $\\texttt{B}$ 题，因此其通过题数被更新为 $2$，罚时同样被更新。同时，所有队伍的排名立即被重新计算。由于此时 $\\texttt{abc}$ 通过题目数量大于 $\\texttt{bcd}$，因此其排名重新计算为第一名，而 $\\texttt{bcd}$ 成为最后一名第二名。\n\n这之后，队伍 $\\texttt{bcd}$ 的名字被念到，由于其在封榜后没有提交，因此这时所有队伍的排名没有变化，滚榜嘉宾会进行其上一名队伍的滚榜。\n\n最后，队伍 $\\texttt{abc}$ 的名字被念到，滚榜结束。\n\n需要注意的是，在滚榜过程中是逐题揭晓提交。也就是说，如果一支队伍封榜后通过了多道题，在其进行滚榜过程中，只要按照从 $\\texttt{A}$ 题依次到最后一题的顺序，该队第一个“待判题”状态试题通过，后面的“待判题”同样暂时不会揭晓，而是立刻进行排名更新过程以及可能存在的更换另一支队伍进行滚榜的过程。\n\n### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 20$，$1 \\le m \\le 2 \\times 10^5$，$1 \\le K \\le 2 \\times 10^6$，$0 \\leq x \\leq 5$，$00 \\leq yy < 60$，$00 \\leq zz < 60$，且当 $x = 5$ 时保证 $yy = zz = 00$。\n\n保证提交记录按照提交时间不降序给出，即先给出的提交记录提交时间不会晚于后给出的提交记录的提交时间，试题名称为大写字母 $\\texttt{A} \\sim \\texttt{Z}$，队名均为长度不超过 $50$ 的由小写字母组成的字符串，评测状态为试题中所给的 $6$ 种之一。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[入门赛 #7] 打 ACM 最快乐的就是滚榜读队名了 (Hard Version)", "background": "**本题的题意与 [I1](https://www.luogu.com.cn/problem/B3692) 完全相同，区别仅在 $m$ 和 $K$ 的范围。**\n\n在刚刚结束的 ICPC 杭州赛站上，某 E 经历了刺激的滚榜。她发现打 ACM 最快乐的就是滚榜读队名了。", "description": "一场 ICPC 正式赛共 $5$ 小时。\n\n队伍的排名由通过题数与罚时决定。通过题数更多的队伍排名更靠前，若通过题数相同，则罚时更小的队伍排名更靠前。通过题数与罚时均相同的队伍排名相同。本题中可能出现队伍排名相同的情况，此时，认为先出现在提交记录中的队伍排名靠前。\n\n罚时是由通过题目的时间和未通过提交的次数决定的。罚时为每一道题通过时比赛开始的分钟数之和，加上该题之前未通过提交的次数乘 $20$ 分钟得到的。例如，某队在比赛进行 $1:28:35$ 时通过了 G 题，在此之前共有 $3$ 次未通过的提交，则 G 题对罚时的总贡献为 $88+3 \\times 20=148$ 分钟。\n\n**需要注意的是，仅有通过的试题的未通过提交会被计算罚时**。例如，某队在 I 题共有 $14$ 次未通过的提交，但到比赛结束，该队都没有通过 I 题，则这 $14$ 次未通过的提交不会被计算罚时。**在某一题通过后，该队对这一题的任何提交（无论是否能够通过）都不会影响本题通过的结果和本题的罚时。**\n\n选手在比赛过程中可以随时提交某一道试题的代码，代码将被立即评测并返回结果（$\\texttt{Accepted}$，$\\texttt{Time Limit Exceeded}$，$\\texttt{Memory Limit Exceeded}$，$\\texttt{Presentation Error}$，$\\texttt{Wrong Answer}$，$\\texttt{Runtime Error}$）。其中，评测结果 $\\texttt{Accepted}$ 为通过，其他评测结果均为不通过。\n\n在比赛进行的前四小时（$0:00:00 \\sim 4:00:00$），每支队伍的提交均会在排行榜上反映出来。比赛的最后一小时（$4:00:01 \\sim 5:00:00$），排行榜将被冻结（封榜），所有的提交在排行榜对应队伍对应试题上均显示为待判题（提交的队伍知道评测结果）。\n\n在比赛结束后，会进行紧张刺激的滚榜环节。滚榜嘉宾将按照封榜时的排行榜，依照从最后一名到第一名，**先读出队伍队名**，再按照从 A 题依次到最后一题的顺序，公布排行榜上该队“待判题”状态试题最终是否通过。\n\n如果通过，所有队伍的排名将立即重新计算，显然，已经滚榜完成（被滚榜嘉宾念过队名，且所有待判题状态的结果都已经揭晓）的队伍排名不会有影响。若该队伍排名上升，则滚榜嘉宾立即开始下一支队伍的滚榜。因此，一支队伍的队名可能被滚榜嘉宾多次读出。\n\n例如，某队队名为“囤题”，在前四小时没有通过任何一题，封榜时排在最后一名。在封榜后，该队连续通过全部十三道题目。那么滚榜嘉宾有可能读到该队队名七八次。当然，当该队上升到第一名后，其排名不会再发生变化，即使揭晓的判题结果为通过，但其排名没有发生变化，滚榜嘉宾不会再次读出其队名。\n\n现在给出某场 ICPC 完整的提交记录，请你依次输出滚榜嘉宾念出的队名。\n\n**一次提交记录都没有的队伍不会在排行榜上出现，也不会在滚榜中被念到队名。**", "inputFormat": "输入的第一行为三个整数 $n,m,K$，依次为该场 ICPC 试题数、该场 ICPC 队伍数、该场 ICPC 提交记录数。\n\n接下来 $K$ 行，每行为四个空格分隔的字符串，表达一条提交记录。第一个形如 $x:yy:zz$，代表该记录在比赛开始 $x$ 小时 $yy$ 分钟 $zz$ 秒时提交。第二个字符串为一个大写英文字母，代表试题的编号（$\\texttt{A,B,} \\cdots$）。第三个字符串为队名，保证队名不含空格。第四个字符串（可能含有空格，但为仅出现「题目描述」中的六种评测结果）为该评测记录的评测结果，具体字符串的含义见试题描述部分。", "outputFormat": "输出若干行，为该滚榜嘉宾依次读到的队名。", "hint": "### 样例解释\n\n在封榜前，队伍 $\\texttt{abc}$ 仅通过 $\\texttt{A}$ 题，且在第二秒的第一次正确提交之前有一次错误提交，因此罚时为 $20$ 分钟；队伍 $\\texttt{bcd}$ 同样仅通过 $\\texttt{A}$ 题，且在 $0:19:38$ 的第一次正确提交之前没有错误提交，因此罚时为 $19$ 分钟。\n\n在封榜后，队伍 $\\texttt{abc}$ 通过了 $\\texttt{B}$ 题。\n\n在滚榜环节开始，由于封榜后的提交未被揭晓，因此暂时认为队伍 $\\texttt{abc}$ 与 $\\texttt{bcd}$ 均只通过一题，且前者罚时较大，排名靠后。\n\n依照从最后一名到第一名的原则，队伍 $\\texttt{abc}$ 的名字先被念到，并揭晓其在封榜后的提交的结果。其通过了 $\\texttt{B}$ 题，因此其通过题数被更新为 $2$，罚时同样被更新。同时，所有队伍的排名立即被重新计算。由于此时 $\\texttt{abc}$ 通过题目数量大于 $\\texttt{bcd}$，因此其排名重新计算为第一名，而 $\\texttt{bcd}$ 成为最后一名第二名。\n\n这之后，队伍 $\\texttt{bcd}$ 的名字被念到，由于其在封榜后没有提交，因此这时所有队伍的排名没有变化，滚榜嘉宾会进行其上一名队伍的滚榜。\n\n最后，队伍 $\\texttt{abc}$ 的名字被念到，滚榜结束。\n\n需要注意的是，在滚榜过程中是逐题揭晓提交。也就是说，如果一支队伍封榜后通过了多道题，在其进行滚榜过程中，只要按照从 $\\texttt{A}$ 题依次到最后一题的顺序，该队第一个“待判题”状态试题通过，后面的“待判题”同样暂时不会揭晓，而是立刻进行排名更新过程以及可能存在的更换另一支队伍进行滚榜的过程。\n\n### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 20$，$1 \\le m \\le 2 \\times 10^5$，$1 \\le K \\le 2 \\times 10^6$，$0 \\leq x \\leq 5$，$00 \\leq yy < 60$，$00 \\leq zz < 60$，且当 $x = 5$ 时保证 $yy = zz = 00$。\n\n保证提交记录按照提交时间不降序给出，即先给出的提交记录提交时间不会晚于后给出的提交记录的提交时间，试题名称为大写字母 $\\texttt{A} \\sim \\texttt{Z}$，队名均为长度不超过 $50$ 的由小写字母组成的字符串，评测状态为试题中所给的 $6$ 种之一。", "locale": "zh-CN"}}}
{"pid": "P8891", "type": "P", "difficulty": 1, "samples": [["6 1\n1 1 4 5 1 1\n0 7", "1 1 4 5 1 1"], ["3 1\n0 3 9\n1 2", "-2 3 9"], ["见文件附件的 queries3.in", "见文件附件的 queries3.ans"], ["见文件附件的 queries4.in", "见文件附件的 queries4.ans"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "O2优化"], "title": "「UOI-R1」询问", "background": "ZSS 有一个序列，但他实在不太聪明，以至于一个操作问题都要来问你了。", "description": "给定 $n$ 个数的整数序列 $a_1, a_2, \\cdots, a_n$，有 $m$ 次操作，每次操作给定 $x, y$，你需要找到所有 $i$，满足 $i \\oplus x = 0$，然后 $a_i \\gets a_i - y$。如果没有任何一个这样的 $i$，则序列什么也不会更改。这里的 $\\oplus$ 为按位异或操作。\n\n操作结束后，你需要输出这个序列。", "inputFormat": "第一行，两个正整数 $n,m$，表示序列长度和操作次数。\n\n接下来一行，表示初始序列。\n\n接下来 $m$ 行，每行两个数 $x,y$，意思如题面所示。", "outputFormat": "输出一行，$n$ 个数，表示操作结束后的序列。", "hint": "对于 $20\\%$ 的数据，保证 $1 \\leq n, m \\leq 10^3$。\n\n对于另外 $20\\%$ 的数据，保证 $x=0$。\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n, m \\leq 10^6$，$-10^8 \\leq y, a_i \\leq 10^{8}$，$0 \\leq x \\leq n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「UOI-R1」询问", "background": "ZSS 有一个序列，但他实在不太聪明，以至于一个操作问题都要来问你了。", "description": "给定 $n$ 个数的整数序列 $a_1, a_2, \\cdots, a_n$，有 $m$ 次操作，每次操作给定 $x, y$，你需要找到所有 $i$，满足 $i \\oplus x = 0$，然后 $a_i \\gets a_i - y$。如果没有任何一个这样的 $i$，则序列什么也不会更改。这里的 $\\oplus$ 为按位异或操作。\n\n操作结束后，你需要输出这个序列。", "inputFormat": "第一行，两个正整数 $n,m$，表示序列长度和操作次数。\n\n接下来一行，表示初始序列。\n\n接下来 $m$ 行，每行两个数 $x,y$，意思如题面所示。", "outputFormat": "输出一行，$n$ 个数，表示操作结束后的序列。", "hint": "对于 $20\\%$ 的数据，保证 $1 \\leq n, m \\leq 10^3$。\n\n对于另外 $20\\%$ 的数据，保证 $x=0$。\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n, m \\leq 10^6$，$-10^8 \\leq y, a_i \\leq 10^{8}$，$0 \\leq x \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P8892", "type": "P", "difficulty": 2, "samples": [["1\n12341234\n1234", "Y"], ["1\n6012739810910020338452\n12345678", "Y"], ["1\n123456789\n465", "N"], ["见文件附件的 magnets4.in", "见文件附件的 magnets4.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "O2优化"], "title": "「UOI-R1」磁铁", "background": "", "description": "有两串磁铁 $a,b$，均可以看作由一些小写或大写字符或数字组成的。\n\n你可以对磁铁 $a$ 进行**无限次**操作，每次操作可以是以下两个中的一个：\n\n1. 将前若干个字符删除，例如删除 $\\texttt{91987}$ 的前 $3$ 个字符后字符串将会变成 $\\texttt{87}$。\n2. 将后若干个字符移至前面去，例如将 $\\texttt{91987}$ 的后 $3$ 个字符移至前面去后字符串会变成 $\\texttt{98791}$。\n\n问经过操作后，能否使磁铁 $a$ 和 $b$ 相等，$a$ 和 $b$ 相等当且仅当 $a$ 和 $b$ 长度相等且每个字符都相同。\n\n为了防止 ````不可以，总司令```` 的情况发生，你需要回答多次。", "inputFormat": "第一行，数据组数 $t$。\n\n接下来 $t$ 组数据，每组两行字符串，表示磁铁串 $a, b$。", "outputFormat": "输出 $t$ 行，每行输出 `Y` 或 `N` 表示操作后可以或不可以使得 $a$ 和 $b$ 相等。", "hint": "**【样例解释 #1】** \n\n$$\n\\texttt{12341234}\\\\ \\to \\texttt{1234}\\\\ = \\texttt{1234}\n$$\n\n**【样例解释 #2】** \n\n$$\n\\texttt{6012739810910020338452}\\\\\n\\to \\texttt{2601273981091002033845}\\\\\n\\to \\texttt{601273981091002033845}\\\\\n\\to \\texttt{384560127398109100203}\\\\\n\\to \\texttt{4560127398109100203}\\\\\n\\to \\texttt{0345601273981091002}\\\\\n\\to \\texttt{345601273981091002}\\\\\n\\to \\texttt{091002345601273981}\\\\\n\\to \\texttt{2345601273981}\\\\\n\\to \\texttt{3981234560127}\\\\\n\\to \\texttt{81234560127}\\\\\n\\to \\texttt{01278123456}\\\\\n\\to \\texttt{78123456}\\\\\n\\to \\texttt{12345678} \\\\\n=\\texttt{12345678}\n$$\n\n**【数据范围】**\n\n以下记 $ \\left| a \\right|$ 表示每组数据磁铁 $a$ 的长度，$\\left| b \\right|$ 表示每组数据磁铁 $b$ 的长度。\n\n对于 $20\\%$ 的数据，保证 $\\left| a \\right| = 1$。\n\n对于另外 $20\\%$ 的数据，保证 $\\left| b \\right| = 1$。\n\n对于 $100\\%$，保证 $1 \\leq \\left| a \\right|, \\left| b \\right| \\leq 1000$，$1 \\leq t \\leq 10$。\n\n保证 $a$ 和 $b$ 非空且只包含大小写英文字母或数字。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「UOI-R1」磁铁", "background": "", "description": "有两串磁铁 $a,b$，均可以看作由一些小写或大写字符或数字组成的。\n\n你可以对磁铁 $a$ 进行**无限次**操作，每次操作可以是以下两个中的一个：\n\n1. 将前若干个字符删除，例如删除 $\\texttt{91987}$ 的前 $3$ 个字符后字符串将会变成 $\\texttt{87}$。\n2. 将后若干个字符移至前面去，例如将 $\\texttt{91987}$ 的后 $3$ 个字符移至前面去后字符串会变成 $\\texttt{98791}$。\n\n问经过操作后，能否使磁铁 $a$ 和 $b$ 相等，$a$ 和 $b$ 相等当且仅当 $a$ 和 $b$ 长度相等且每个字符都相同。\n\n为了防止 ````不可以，总司令```` 的情况发生，你需要回答多次。", "inputFormat": "第一行，数据组数 $t$。\n\n接下来 $t$ 组数据，每组两行字符串，表示磁铁串 $a, b$。", "outputFormat": "输出 $t$ 行，每行输出 `Y` 或 `N` 表示操作后可以或不可以使得 $a$ 和 $b$ 相等。", "hint": "**【样例解释 #1】** \n\n$$\n\\texttt{12341234}\\\\ \\to \\texttt{1234}\\\\ = \\texttt{1234}\n$$\n\n**【样例解释 #2】** \n\n$$\n\\texttt{6012739810910020338452}\\\\\n\\to \\texttt{2601273981091002033845}\\\\\n\\to \\texttt{601273981091002033845}\\\\\n\\to \\texttt{384560127398109100203}\\\\\n\\to \\texttt{4560127398109100203}\\\\\n\\to \\texttt{0345601273981091002}\\\\\n\\to \\texttt{345601273981091002}\\\\\n\\to \\texttt{091002345601273981}\\\\\n\\to \\texttt{2345601273981}\\\\\n\\to \\texttt{3981234560127}\\\\\n\\to \\texttt{81234560127}\\\\\n\\to \\texttt{01278123456}\\\\\n\\to \\texttt{78123456}\\\\\n\\to \\texttt{12345678} \\\\\n=\\texttt{12345678}\n$$\n\n**【数据范围】**\n\n以下记 $ \\left| a \\right|$ 表示每组数据磁铁 $a$ 的长度，$\\left| b \\right|$ 表示每组数据磁铁 $b$ 的长度。\n\n对于 $20\\%$ 的数据，保证 $\\left| a \\right| = 1$。\n\n对于另外 $20\\%$ 的数据，保证 $\\left| b \\right| = 1$。\n\n对于 $100\\%$，保证 $1 \\leq \\left| a \\right|, \\left| b \\right| \\leq 1000$，$1 \\leq t \\leq 10$。\n\n保证 $a$ 和 $b$ 非空且只包含大小写英文字母或数字。\n\n", "locale": "zh-CN"}}}
{"pid": "P8893", "type": "P", "difficulty": 3, "samples": [["5 5 2\n1 2\n3\n3 2 1 2\n4 3 1 2 3\n5 3 1 3 4", "3"], ["1 1 1\n1\n0", "0"], ["7 7 2\n1 2\n2\n3 2 1 2\n6 2 1 2", "-1"], ["见文件附件的 rec4.in", "见文件附件的 rec4.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化", "拓扑排序"], "title": "「UOI-R1」智能推荐", "background": "数据已加强。", "description": "现在有 $N$ 道题。\n\n天数的编号从 $0$ 开始，每一天你可以做若干道题，你只能做以前推荐过的或者当天推荐的题（每道题只可以做一次）。第一天，智能推荐会推荐 $p$ 道题。\n\n推荐规则如下：\n\n对于第 $i$ 道题，如果有可能被推荐的话，就会有一个题目集合 $s_i$。当且仅当你把 $s_i$ 中每一道题都做出来并且其中有一道题是当天做的，那么下一天就会推荐第 $i$ 题。\n\n你想做完第 $K$ 道题，问至少第几天你才能满足愿望？\n", "inputFormat": "第一行三个整数 $N,K,p$，含义如题目所述。\n\n第二行 $p$ 个整数，表示第一天推荐的题的题号。\n\n第三行一个整数 $R$，表示有 $R$ 条推荐规则。\n\n接下来 $R$ 行，每行包含一条规则，每行格式如下：\n\n一个整数 $v_i$，表示要推荐的题的题号。接着一个整数 $s_i$，表示要使得这道题被推荐，一共要做的题目数量。接下来 $s_i$ 个整数 $p_i$，表示要做的每道题。\n", "outputFormat": "一个整数表示最少第几天才能满足愿望。\n\n如无论如何，第 $K$ 题都无法完成，则输出 `-1`。\n", "hint": "**【样例解释 #1】**\n\n第 $0$ 天推了第 $1,2$ 题，都做了。\n\n第 $1$ 推了第 $3$ 题，做了。\n\n第 $2$ 推了第 $4$ 题，做了。\n\n第 $3$ 推了第 $5$ 题，也就是第 $K$ 题，做了。\n\n第 $3$ 天即可做完第 $K$ 题目。\n\n**【样例解释 #2】**\n\n第 $0$ 天推了第 $1$ 题，也就是第 $K$ 题，做了。\n第 $0$ 天就做完了。\n\n**【数据范围】**\n\n以下记 $\\left| s_i \\right|$ 表示推荐规则中第 $i$ 条规则中，如果 $v_i$ 被推荐，要做的所有题。\n\n对于 $30\\%$ 的数据，保证 $1 \\leq N \\leq 100$。\n\n对于 $50\\%$ 的数据，保证没有环。\n\n对于 $100\\%$ 的数据，保证 $1 \\le K,s_i,p_i,v_i \\le N \\le 5\\times 10^3$，$0 \\leq R \\leq 5 \\times 10^3$。$|s_i|$ 互不相同，且对于每一个 $|s_i|$ 都有 $p_i$ 互不相同，$v_i$ 互不相同。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「UOI-R1」智能推荐", "background": "数据已加强。", "description": "现在有 $N$ 道题。\n\n天数的编号从 $0$ 开始，每一天你可以做若干道题，你只能做以前推荐过的或者当天推荐的题（每道题只可以做一次）。第一天，智能推荐会推荐 $p$ 道题。\n\n推荐规则如下：\n\n对于第 $i$ 道题，如果有可能被推荐的话，就会有一个题目集合 $s_i$。当且仅当你把 $s_i$ 中每一道题都做出来并且其中有一道题是当天做的，那么下一天就会推荐第 $i$ 题。\n\n你想做完第 $K$ 道题，问至少第几天你才能满足愿望？\n", "inputFormat": "第一行三个整数 $N,K,p$，含义如题目所述。\n\n第二行 $p$ 个整数，表示第一天推荐的题的题号。\n\n第三行一个整数 $R$，表示有 $R$ 条推荐规则。\n\n接下来 $R$ 行，每行包含一条规则，每行格式如下：\n\n一个整数 $v_i$，表示要推荐的题的题号。接着一个整数 $s_i$，表示要使得这道题被推荐，一共要做的题目数量。接下来 $s_i$ 个整数 $p_i$，表示要做的每道题。\n", "outputFormat": "一个整数表示最少第几天才能满足愿望。\n\n如无论如何，第 $K$ 题都无法完成，则输出 `-1`。\n", "hint": "**【样例解释 #1】**\n\n第 $0$ 天推了第 $1,2$ 题，都做了。\n\n第 $1$ 推了第 $3$ 题，做了。\n\n第 $2$ 推了第 $4$ 题，做了。\n\n第 $3$ 推了第 $5$ 题，也就是第 $K$ 题，做了。\n\n第 $3$ 天即可做完第 $K$ 题目。\n\n**【样例解释 #2】**\n\n第 $0$ 天推了第 $1$ 题，也就是第 $K$ 题，做了。\n第 $0$ 天就做完了。\n\n**【数据范围】**\n\n以下记 $\\left| s_i \\right|$ 表示推荐规则中第 $i$ 条规则中，如果 $v_i$ 被推荐，要做的所有题。\n\n对于 $30\\%$ 的数据，保证 $1 \\leq N \\leq 100$。\n\n对于 $50\\%$ 的数据，保证没有环。\n\n对于 $100\\%$ 的数据，保证 $1 \\le K,s_i,p_i,v_i \\le N \\le 5\\times 10^3$，$0 \\leq R \\leq 5 \\times 10^3$。$|s_i|$ 互不相同，且对于每一个 $|s_i|$ 都有 $p_i$ 互不相同，$v_i$ 互不相同。\n", "locale": "zh-CN"}}}
{"pid": "P8894", "type": "P", "difficulty": 3, "samples": [["2\n1 4\n2 3", "24"], ["见文件附件的 sum2.in", "见文件附件的 sum2.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "O2优化"], "title": "「UOI-R1」求和", "background": "", "description": "给定 $n$ 个区间 $p_i, q_i$。\n\n求$\\sum\\limits_{s_1={p_1}}^{q_1}\\sum\\limits_{s_2={p_2}}^{q_2}\\sum\\limits_{s_3={p_3}}^{q_3} \\cdots\\sum\\limits_{s_n={p_n}}^{q_n}\\max\\limits_{i=1}^ns_i$ 对 $998244353$ 取余的值。", "inputFormat": "第 $1$ 行，一个整数 $n$，表示区间数量。\n\n第 $2$ 至 $(n+1)$ 行，每行两个整数 $p_i,q_i$。", "outputFormat": "一个整数，表示答案。你需要将答案取余 $998244353$ 后输出。", "hint": "### 样例解释\n\n取 $s = \\{1, 2\\}, \\max\\limits_{i=1}^ns_i=2$。\n\n取 $s = \\{2, 2\\}, \\max\\limits_{i=1}^ns_i = 2$。\n\n取 $s = \\{3, 2\\}, \\max\\limits_{i=1}^ns_i = 3$。\n\n取 $s = \\{4, 2\\}, \\max\\limits_{i=1}^ns_i= 4$。\n\n取 $s = \\{1, 3\\}, \\max\\limits_{i=1}^ns_i=3$。\n\n取 $s = \\{2, 3\\}, \\max\\limits_{i=1}^ns_i = 3$。\n\n取 $s = \\{3, 3\\}, \\max\\limits_{i=1}^ns_i = 3$。\n\n取 $s = \\{4, 3\\}, \\max\\limits_{i=1}^ns_i= 4$。\n\n$2+2+3+4+3+3+3+4 = 24$。\n\n### 数据范围\n\n对于 $30\\%$ 的数据，保证 $n \\leq 8$，$p_i, q_i \\leq 10$。\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 5 \\times 10^3$，$1 \\leq p_i \\leq q_i \\leq 5 \\times 10^3$。有区间可能相同。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「UOI-R1」求和", "background": "", "description": "给定 $n$ 个区间 $p_i, q_i$。\n\n求$\\sum\\limits_{s_1={p_1}}^{q_1}\\sum\\limits_{s_2={p_2}}^{q_2}\\sum\\limits_{s_3={p_3}}^{q_3} \\cdots\\sum\\limits_{s_n={p_n}}^{q_n}\\max\\limits_{i=1}^ns_i$ 对 $998244353$ 取余的值。", "inputFormat": "第 $1$ 行，一个整数 $n$，表示区间数量。\n\n第 $2$ 至 $(n+1)$ 行，每行两个整数 $p_i,q_i$。", "outputFormat": "一个整数，表示答案。你需要将答案取余 $998244353$ 后输出。", "hint": "### 样例解释\n\n取 $s = \\{1, 2\\}, \\max\\limits_{i=1}^ns_i=2$。\n\n取 $s = \\{2, 2\\}, \\max\\limits_{i=1}^ns_i = 2$。\n\n取 $s = \\{3, 2\\}, \\max\\limits_{i=1}^ns_i = 3$。\n\n取 $s = \\{4, 2\\}, \\max\\limits_{i=1}^ns_i= 4$。\n\n取 $s = \\{1, 3\\}, \\max\\limits_{i=1}^ns_i=3$。\n\n取 $s = \\{2, 3\\}, \\max\\limits_{i=1}^ns_i = 3$。\n\n取 $s = \\{3, 3\\}, \\max\\limits_{i=1}^ns_i = 3$。\n\n取 $s = \\{4, 3\\}, \\max\\limits_{i=1}^ns_i= 4$。\n\n$2+2+3+4+3+3+3+4 = 24$。\n\n### 数据范围\n\n对于 $30\\%$ 的数据，保证 $n \\leq 8$，$p_i, q_i \\leq 10$。\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 5 \\times 10^3$，$1 \\leq p_i \\leq q_i \\leq 5 \\times 10^3$。有区间可能相同。\n", "locale": "zh-CN"}}}
{"pid": "P8895", "type": "P", "difficulty": 3, "samples": [["4 1 998244353\n1 2 2 3\n3 4", "2\n8"], ["见下发文件 sequence2.in", "见下发文件 sequence2.out"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "平衡树", "2022", "洛谷原创", "O2优化"], "title": "「DPOI-1」优美的序列", "background": "#### Update on 2022.12.18：新增一组针对 @[zhuoxingmu](https://www.luogu.com.cn/user/421155) 的 Hack 数据，放置于 #21，分值为 $5$ 分。\n#### Update on 2022.12.18：新增一组针对 @[大眼仔Happy](https://www.luogu.com.cn/user/537046) 的 Hack 数据，放置于 #22，分值为 $5$ 分。\n#### Update on 2025.7.7：新增两组 hack 数据，来自工单 <https://www.luogu.com.cn/ticket/XQCA458514>，放置于 #23、#24。#21~#24 全部改为 $0$ 分。\n------------\n不可以，总司令。", "description": "总司令给你一个长为 $n$ 的序列 $a$。\n\n他认为这个 $a$ 现在也许不够优美，他希望将其重排为一个 $a'$，使之变得优美。\n\n我们称一个长为 $n$ 的序列 $a$ 优美，当且仅当 $\\exists i \\in [1,n]$，满足：\n\n- $\\forall j \\in [1, i)$，$a_j > a_{j + 1}$。\n- $\\forall j \\in (i, n]$，$a_j > a_{j - 1}$。\n\n他命令你求出 $a$ 经过重排可以得到多少个不同的 $a'$。由于结果可能很大，你只需要求出结果对 $p$ 取模的值。\n\n由于一个固定的 $a$ 太无趣了，于是他给你 $m$ 次修改，每次修改形如 `x k`，表示令 $a_x \\leftarrow k$。你需要在每次修改后求出当前的答案。", "inputFormat": "第一行，三个整数 $n, m, p$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$；\n\n接下来 $m$ 行，每行两个整数 $x, k$，表示一次修改操作。", "outputFormat": "共 $m + 1$ 行，每行一个整数，表示初始状态下及每次修改后所求的值。", "hint": "#### 样例 #1 解释\n对于初始状态，满足条件的 $a'$ 有 $[2, 1, 2, 3], [3, 2, 1, 2]$，共 $2$ 个。\n\n对于第一次修改后的 $a = [1, 2, 4, 3]$，满足条件的 $a'$ 有 $[1, 2, 3, 4], [2, 1, 3, 4], [3, 1, 2, 4], [4, 1, 2, 3], [3, 2, 1, 4], [4, 2, 1, 3], [4, 3, 1, 2], [4, 3, 2, 1]$，共 $8$ 个。\n#### 样例 #2 解释\n该样例满足测试点 $15 \\sim 20$ 的限制。\n#### 数据范围\n| 测试点编号 | $n \\leq$ | $m \\leq$ | 特殊条件 |\n| :------: | :------: | :------: | :------: |\n| $1 \\sim 2$ | $10$ | $10$ | 无 |\n| $3 \\sim 4$ | $100$ | $100$ | 无 |\n| $5 \\sim 6$ | $10^3$ | $10^3$ | 无 |\n| $7 \\sim 10$ | $10^5$ | $10^5$ | 无 |\n| $11 \\sim 12$ | $5 \\times 10^5$ | $0$ | $a$ 为一个**排列** |\n| $13 \\sim 14$ | $5 \\times 10^5$ | $0$ | 无 |\n| $15 \\sim 20$ | $5 \\times 10^5$ | $5\\times 10^5$ | 无 |\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^5$，$0 \\leq m \\leq 5 \\times 10^5$，$2 \\leq p \\leq 10^9$，$1 \\leq a_i, k, x \\leq n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「DPOI-1」优美的序列", "background": "#### Update on 2022.12.18：新增一组针对 @[zhuoxingmu](https://www.luogu.com.cn/user/421155) 的 Hack 数据，放置于 #21，分值为 $5$ 分。\n#### Update on 2022.12.18：新增一组针对 @[大眼仔Happy](https://www.luogu.com.cn/user/537046) 的 Hack 数据，放置于 #22，分值为 $5$ 分。\n#### Update on 2025.7.7：新增两组 hack 数据，来自工单 <https://www.luogu.com.cn/ticket/XQCA458514>，放置于 #23、#24。#21~#24 全部改为 $0$ 分。\n------------\n不可以，总司令。", "description": "总司令给你一个长为 $n$ 的序列 $a$。\n\n他认为这个 $a$ 现在也许不够优美，他希望将其重排为一个 $a'$，使之变得优美。\n\n我们称一个长为 $n$ 的序列 $a$ 优美，当且仅当 $\\exists i \\in [1,n]$，满足：\n\n- $\\forall j \\in [1, i)$，$a_j > a_{j + 1}$。\n- $\\forall j \\in (i, n]$，$a_j > a_{j - 1}$。\n\n他命令你求出 $a$ 经过重排可以得到多少个不同的 $a'$。由于结果可能很大，你只需要求出结果对 $p$ 取模的值。\n\n由于一个固定的 $a$ 太无趣了，于是他给你 $m$ 次修改，每次修改形如 `x k`，表示令 $a_x \\leftarrow k$。你需要在每次修改后求出当前的答案。", "inputFormat": "第一行，三个整数 $n, m, p$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$；\n\n接下来 $m$ 行，每行两个整数 $x, k$，表示一次修改操作。", "outputFormat": "共 $m + 1$ 行，每行一个整数，表示初始状态下及每次修改后所求的值。", "hint": "#### 样例 #1 解释\n对于初始状态，满足条件的 $a'$ 有 $[2, 1, 2, 3], [3, 2, 1, 2]$，共 $2$ 个。\n\n对于第一次修改后的 $a = [1, 2, 4, 3]$，满足条件的 $a'$ 有 $[1, 2, 3, 4], [2, 1, 3, 4], [3, 1, 2, 4], [4, 1, 2, 3], [3, 2, 1, 4], [4, 2, 1, 3], [4, 3, 1, 2], [4, 3, 2, 1]$，共 $8$ 个。\n#### 样例 #2 解释\n该样例满足测试点 $15 \\sim 20$ 的限制。\n#### 数据范围\n| 测试点编号 | $n \\leq$ | $m \\leq$ | 特殊条件 |\n| :------: | :------: | :------: | :------: |\n| $1 \\sim 2$ | $10$ | $10$ | 无 |\n| $3 \\sim 4$ | $100$ | $100$ | 无 |\n| $5 \\sim 6$ | $10^3$ | $10^3$ | 无 |\n| $7 \\sim 10$ | $10^5$ | $10^5$ | 无 |\n| $11 \\sim 12$ | $5 \\times 10^5$ | $0$ | $a$ 为一个**排列** |\n| $13 \\sim 14$ | $5 \\times 10^5$ | $0$ | 无 |\n| $15 \\sim 20$ | $5 \\times 10^5$ | $5\\times 10^5$ | 无 |\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^5$，$0 \\leq m \\leq 5 \\times 10^5$，$2 \\leq p \\leq 10^9$，$1 \\leq a_i, k, x \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P8896", "type": "P", "difficulty": 4, "samples": [["2\n5\n0 1 4 0 0\n3 4 4 1 3\n3\n1 2 2\n2 2 2", "YES\nNO"], ["见下发文件 road2.in", "见下发文件 road2.out"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2022", "洛谷原创", "O2优化", "优先队列", "构造"], "title": "「DPOI-1」道路规划", "background": "不可以，总司令。", "description": "战场上有 $n$ 个据点，从 $1\\sim n$ 编号。**每两个据点**之间**都**有一条双向道路。\n\n一天，总司令来战区巡视，走着走着迷路了，于是愤怒地下达命令，让你把每一条双向道路变成单向的，使得这些道路**不包含环**（否则总司令会迷路）。但由于每个据点的规模互不相同，总司令从第 $i$ 个据点出发沿着单向道路能**直接到达**的据点数量需要在 $[l_i,r_i]$ 之间。换言之，第 $i$ 个点的出度需要在 $[l_i,r_i]$ 之间。你需要告诉总司令有没有可能满足他的需求。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行，一个整数 $n$，表示据点数量；\n\n第二行，$n$ 个整数 $l_1, l_2, \\dots, l_n$；\n\n第三行，$n$ 个整数 $r_1, r_2, \\dots, r_n$。", "outputFormat": "对于每组数据：\n\n一行，一个字符串。若可以满足总司令的需求，一行 `YES`；否则，一行 `NO`。", "hint": "#### 样例 #1 解释\n下面是第 $1$ 组数据中一种可行的方案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2uvwlydw.png)\n\n#### 样例 #2 解释\n该样例满足测试点 $3 \\sim 6$ 的限制。\n#### 数据范围\n**本题测试点分数不等分。**\n\n|  测试点编号  | $n \\le$ | 特殊条件 |每个测试点分数|\n| :----------: | :-----------: | :------: | :----: |\n|     $1\\sim 2$      |     $10$     |   无   |$5$|\n|     $3\\sim 6$      |     $1000$     |    无     |$5$|\n|     $7\\sim 8$      |     $10^5$     |    所有 $l_i = i-1$ 或所有 $l_i \\geq \\min (i, n - 1)$    |$5$|\n| $9 \\sim 10$  | $10^5$ | $l_i=0$ 或 $r_i=n-1$ |$5$|\n| $11 \\sim 15$ | $10^5$ | 无 |$10$|\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$，$0 \\leq l_i \\leq r_i < n$，$1 \\leq T \\leq 10$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「DPOI-1」道路规划", "background": "不可以，总司令。", "description": "战场上有 $n$ 个据点，从 $1\\sim n$ 编号。**每两个据点**之间**都**有一条双向道路。\n\n一天，总司令来战区巡视，走着走着迷路了，于是愤怒地下达命令，让你把每一条双向道路变成单向的，使得这些道路**不包含环**（否则总司令会迷路）。但由于每个据点的规模互不相同，总司令从第 $i$ 个据点出发沿着单向道路能**直接到达**的据点数量需要在 $[l_i,r_i]$ 之间。换言之，第 $i$ 个点的出度需要在 $[l_i,r_i]$ 之间。你需要告诉总司令有没有可能满足他的需求。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行，一个整数 $n$，表示据点数量；\n\n第二行，$n$ 个整数 $l_1, l_2, \\dots, l_n$；\n\n第三行，$n$ 个整数 $r_1, r_2, \\dots, r_n$。", "outputFormat": "对于每组数据：\n\n一行，一个字符串。若可以满足总司令的需求，一行 `YES`；否则，一行 `NO`。", "hint": "#### 样例 #1 解释\n下面是第 $1$ 组数据中一种可行的方案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2uvwlydw.png)\n\n#### 样例 #2 解释\n该样例满足测试点 $3 \\sim 6$ 的限制。\n#### 数据范围\n**本题测试点分数不等分。**\n\n|  测试点编号  | $n \\le$ | 特殊条件 |每个测试点分数|\n| :----------: | :-----------: | :------: | :----: |\n|     $1\\sim 2$      |     $10$     |   无   |$5$|\n|     $3\\sim 6$      |     $1000$     |    无     |$5$|\n|     $7\\sim 8$      |     $10^5$     |    所有 $l_i = i-1$ 或所有 $l_i \\geq \\min (i, n - 1)$    |$5$|\n| $9 \\sim 10$  | $10^5$ | $l_i=0$ 或 $r_i=n-1$ |$5$|\n| $11 \\sim 15$ | $10^5$ | 无 |$10$|\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$，$0 \\leq l_i \\leq r_i < n$，$1 \\leq T \\leq 10$。", "locale": "zh-CN"}}}
{"pid": "P8897", "type": "P", "difficulty": 2, "samples": [["4\n1 6 4 6", "12 4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "USACO", "2022", "排序"], "title": "[USACO22DEC] Cow College B", "background": "", "description": "Farmer John 计划为奶牛们新开办一所大学！ \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wiy5l6d6.png)\n\n有 $N(1 \\le N \\le 10^5)$ 头奶牛可能会入学。每头奶牛最多愿意支付 $c_i$ 的学费 $(1 \\le c_i \\le 10^6)$。 Farmer John 可以设定所有奶牛入学需要支付的学费。如果这笔学费大于一头奶牛愿意支付的最高金额，那么这头奶牛就不会入学。Farmer John 想赚尽可能多的钱，从而可以给他的讲师提供一笔可观的工资。请求出他能赚到的钱的数量，以及此时应当收取多少学费。 ", "inputFormat": "输入的第一行包含 $N$。\n\n第二行包含 $N$ 个整数 $c_1,c_2, \\cdots,c_N$，其中 $c_i$ 是奶牛 $i$ 愿意支付的最高学费金额。 ", "outputFormat": "输出 Farmer John 可以赚到的最大金额以及最优情况下他应该收取的学费。如果有多个解，输出收取学费最小的解。 \n \n**注意这个问题涉及到的整数可能需要使用 64 位整数型（例如，Java 中的 \"long\"，C/C++ 中的 \"long long\"）。**", "hint": "### 样例 1 解释\n\n如果 Farmer John 收费 $4$，那么 $3$ 头奶牛将会入学，从而使他赚取 $3 \\times 4=12$ 的金额。\n\n### 测试点性质\n\n- 测试点 $2-4$ 满足 $c_i \\le 1000$。\n- 测试点 $5-8$ 满足 $N \\le 5000$。\n- 测试点 $9-12$ 没有额外限制。 ", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Cow College B", "background": "", "description": "Farmer John plans to open a new college for his cows!\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wiy5l6d6.png)\n\nThere are $N(1 \\le N \\le 10^5)$ cows that might enroll. Each cow is willing to pay at most $c_i$ in tuition $(1 \\le c_i \\le 10^6)$. Farmer John can set a single tuition that all cows must pay to enroll. If this tuition is greater than a cow’s maximum willingness to pay, then that cow will not enroll. Farmer John wants to earn as much money as possible so he can pay his instructors well. Compute how much money he can earn and the tuition he should charge to achieve that.", "inputFormat": "The first line contains $N$.\n\nThe second line contains $N$ integers $c_1,c_2, \\cdots,c_N$, where $c_i$ is the maximum tuition cow $i$ is willing to pay.", "outputFormat": "Output the maximum amount Farmer John can earn and the tuition he should charge in the optimal case. If there are multiple answers, output the one with the smallest tuition.\n \nNote that the integers involved may require 64-bit integer types (e.g., long in Java, long long in C/C++).", "hint": "### Sample 1 Explanation\n\nIf Farmer John charges $4$, then $3$ cows will enroll, earning him $3 \\times 4=12$.\n\n### Testpoint Properties\n\n- Testpoints $2-4$ satisfy $c_i \\le 1000$.\n- Testpoints $5-8$ satisfy $N \\le 5000$.\n- Testpoints $9-12$ have no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Cow College B", "background": "", "description": "Farmer John 计划为奶牛们新开办一所大学！ \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wiy5l6d6.png)\n\n有 $N(1 \\le N \\le 10^5)$ 头奶牛可能会入学。每头奶牛最多愿意支付 $c_i$ 的学费 $(1 \\le c_i \\le 10^6)$。 Farmer John 可以设定所有奶牛入学需要支付的学费。如果这笔学费大于一头奶牛愿意支付的最高金额，那么这头奶牛就不会入学。Farmer John 想赚尽可能多的钱，从而可以给他的讲师提供一笔可观的工资。请求出他能赚到的钱的数量，以及此时应当收取多少学费。 ", "inputFormat": "输入的第一行包含 $N$。\n\n第二行包含 $N$ 个整数 $c_1,c_2, \\cdots,c_N$，其中 $c_i$ 是奶牛 $i$ 愿意支付的最高学费金额。 ", "outputFormat": "输出 Farmer John 可以赚到的最大金额以及最优情况下他应该收取的学费。如果有多个解，输出收取学费最小的解。 \n \n**注意这个问题涉及到的整数可能需要使用 64 位整数型（例如，Java 中的 \"long\"，C/C++ 中的 \"long long\"）。**", "hint": "### 样例 1 解释\n\n如果 Farmer John 收费 $4$，那么 $3$ 头奶牛将会入学，从而使他赚取 $3 \\times 4=12$ 的金额。\n\n### 测试点性质\n\n- 测试点 $2-4$ 满足 $c_i \\le 1000$。\n- 测试点 $5-8$ 满足 $N \\le 5000$。\n- 测试点 $9-12$ 没有额外限制。 ", "locale": "zh-CN"}}}
{"pid": "P8898", "type": "P", "difficulty": 3, "samples": [["6\n5 0\nGHHGG\n5 1\nGHHGG\n5 2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH", "5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "USACO", "2022", "Special Judge"], "title": "[USACO22DEC] Feeding the Cows B", "background": "", "description": "Farmer John 有 $N(1 \\le N \\le 10^5)$ 头奶牛，每头奶牛的品种是更赛牛（Guernsey）或荷斯坦牛（Holstein）之一。她们沿水平方向排成一行，奶牛们占据的位置编号为 $1 \\cdots N$。\n\n由于奶牛们都饿了，FJ 决定在 $1 \\cdots N$ 中的某些位置上种植草地。更赛牛和荷斯坦牛喜欢不同类型的草，所以如果 Farmer John 决定在某个位置种草，他必须选择种植更赛牛喜欢的草或荷斯坦牛喜欢的草——他不能在同一个位置同时种两种草。种植的每一片草地都可以喂饱数量不限的相应品种的奶牛。 \n\n每头奶牛愿意移动至多 $K(0 \\le K \\le N-1)$ 个位置以前往一个草地。求出喂饱所有奶牛所需种植的最小草地数量。此外，输出一种使用最小草地数量喂饱所有奶牛的种植方案。任何满足上述条件的方案均视为正确。 ", "inputFormat": "每个测试用例包含 $T$ 个子测试用例，为一种奶牛的排列。输入的第一行包含 $T(1 \\le T \\le 10)$。以下是 $T$ 个子测试用例。\n\n每个子测试用例的第一行包含 $N$ 和 $K$。第二行包含一个长度为 $N$ 的字符串，其中第 $i$ 个字符表示第 $i$ 头奶牛的品种（G 表示更赛牛，H 表示荷斯坦牛）。", "outputFormat": "对于 $T$ 个子测试用例中的每一个，输出两行。第一行输出喂饱所有奶牛所需的最小草地数量。第二行输出一个长度为 $N$ 的字符串，表示一种使用最小草地数量喂饱所有奶牛的种植方案。第 $i$ 个字符表示第 $i$ 个位置，若不种草则为 $\\texttt{.}$，若种植喂饱更赛牛的草则为 $\\texttt{G}$，若种植喂饱荷斯坦牛的草则为 $\\texttt{H}$。任何合法的方案均可通过。 ", "hint": "### 样例 1 解释\n\n注意对于某些子测试用例，存在多种可通过的方案使用最小数量的草地。例如，在第四个子测试用例中，以下是另一个可以通过的答案：\n\n$$\\texttt{.GH..}$$\n\n这个方案在第二个位置种植一块喂饱更赛牛的草地以及在第三个位置种植一块喂饱荷斯坦牛的草地。这使用了最小数量的草地并确保了所有奶牛都在她们喜欢的草地的 $3$ 个位置以内。\n\n### 测试点性质\n\n- 测试点 $2-4$ 满足 $N \\le 10$。\n- 测试点 $5-8$ 满足 $N \\le 40$。\n- 测试点 $9-12$ 满足 $N \\le 10^5$。 ", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Feeding the Cows B", "background": "", "description": "Farmer John has $N (1 \\le N \\le 10^5)$ cows, each of which is either Guernsey or Holstein. They stand in a row along a horizontal line, occupying positions $1 \\cdots N$.\n\nSince the cows are hungry, FJ decides to plant grass patches at some positions among $1 \\cdots N$. Guernseys and Holsteins prefer different types of grass, so if Farmer John decides to plant grass at a position, he must choose either the type preferred by Guernseys or the type preferred by Holsteins—he cannot plant both types at the same position. Each planted grass patch can feed an unlimited number of cows of the corresponding breed.\n\nEach cow is willing to move at most $K (0 \\le K \\le N - 1)$ positions to reach a grass patch. Determine the minimum number of grass patches needed to feed all cows. In addition, output one planting plan that feeds all cows using the minimum number of patches. Any plan that satisfies the conditions is considered correct.", "inputFormat": "Each input contains $T$ test cases, each describing an arrangement of cows. The first line contains $T (1 \\le T \\le 10)$. Then $T$ test cases follow.\n\nFor each test case, the first line contains $N$ and $K$. The second line contains a string of length $N$, where the $i$-th character indicates the breed of the $i$-th cow ($\\texttt{G}$ for Guernsey, $\\texttt{H}$ for Holstein).", "outputFormat": "For each of the $T$ test cases, output two lines. The first line should contain the minimum number of grass patches needed to feed all cows. The second line should contain a string of length $N$ representing one optimal planting plan. The $i$-th character corresponds to position $i$: output $\\texttt{.}$ if no grass is planted, $\\texttt{G}$ if grass for Guernseys is planted, and $\\texttt{H}$ if grass for Holsteins is planted. Any valid plan will be accepted.", "hint": "### Explanation for Sample 1\n\nNote that for some test cases, there are multiple optimal planting plans using the minimum number of patches. For example, in the fourth test case, the following is another acceptable answer:\n\n$$\\texttt{.GH..}$$\n\nThis plan plants a Guernsey-feeding patch at position $2$ and a Holstein-feeding patch at position $3$. This uses the minimum number of patches and ensures that all cows are within $3$ positions of their preferred grass.\n\n### Testdata Properties\n\n- Testdata $2$–$4$ satisfies $N \\le 10$.\n- Testdata $5$–$8$ satisfies $N \\le 40$.\n- Testdata $9$–$12$ satisfies $N \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Feeding the Cows B", "background": "", "description": "Farmer John 有 $N(1 \\le N \\le 10^5)$ 头奶牛，每头奶牛的品种是更赛牛（Guernsey）或荷斯坦牛（Holstein）之一。她们沿水平方向排成一行，奶牛们占据的位置编号为 $1 \\cdots N$。\n\n由于奶牛们都饿了，FJ 决定在 $1 \\cdots N$ 中的某些位置上种植草地。更赛牛和荷斯坦牛喜欢不同类型的草，所以如果 Farmer John 决定在某个位置种草，他必须选择种植更赛牛喜欢的草或荷斯坦牛喜欢的草——他不能在同一个位置同时种两种草。种植的每一片草地都可以喂饱数量不限的相应品种的奶牛。 \n\n每头奶牛愿意移动至多 $K(0 \\le K \\le N-1)$ 个位置以前往一个草地。求出喂饱所有奶牛所需种植的最小草地数量。此外，输出一种使用最小草地数量喂饱所有奶牛的种植方案。任何满足上述条件的方案均视为正确。 ", "inputFormat": "每个测试用例包含 $T$ 个子测试用例，为一种奶牛的排列。输入的第一行包含 $T(1 \\le T \\le 10)$。以下是 $T$ 个子测试用例。\n\n每个子测试用例的第一行包含 $N$ 和 $K$。第二行包含一个长度为 $N$ 的字符串，其中第 $i$ 个字符表示第 $i$ 头奶牛的品种（G 表示更赛牛，H 表示荷斯坦牛）。", "outputFormat": "对于 $T$ 个子测试用例中的每一个，输出两行。第一行输出喂饱所有奶牛所需的最小草地数量。第二行输出一个长度为 $N$ 的字符串，表示一种使用最小草地数量喂饱所有奶牛的种植方案。第 $i$ 个字符表示第 $i$ 个位置，若不种草则为 $\\texttt{.}$，若种植喂饱更赛牛的草则为 $\\texttt{G}$，若种植喂饱荷斯坦牛的草则为 $\\texttt{H}$。任何合法的方案均可通过。 ", "hint": "### 样例 1 解释\n\n注意对于某些子测试用例，存在多种可通过的方案使用最小数量的草地。例如，在第四个子测试用例中，以下是另一个可以通过的答案：\n\n$$\\texttt{.GH..}$$\n\n这个方案在第二个位置种植一块喂饱更赛牛的草地以及在第三个位置种植一块喂饱荷斯坦牛的草地。这使用了最小数量的草地并确保了所有奶牛都在她们喜欢的草地的 $3$ 个位置以内。\n\n### 测试点性质\n\n- 测试点 $2-4$ 满足 $N \\le 10$。\n- 测试点 $5-8$ 满足 $N \\le 40$。\n- 测试点 $9-12$ 满足 $N \\le 10^5$。 ", "locale": "zh-CN"}}}
{"pid": "P8899", "type": "P", "difficulty": 3, "samples": [["4\n\n1 3\n0 0\n0 0\n1 1\n\n2 4\n00 0\n01 1\n10 1\n11 1\n\n1 2\n0 1\n0 0\n\n2 4\n00 0\n01 1\n10 1\n11 0", "OK\nOK\nLIE\nLIE"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "贪心", "USACO", "2022"], "title": "[USACO22DEC] Reverse Engineering B", "background": "", "description": "Elsie 有一个程序，接受一个 $N(1 \\le N \\le 100)$ 个变量的数组 $b[0], \\cdots ,b[N−1]$ 作为输入，其中每个变量等于 $0$ 或 $1$，并且返回对输入数组应用一系列 `if / else if / else` 语句的结果。每个语句检查至多一个输入变量的值，并返回 $0$ 或 $1$。这类程序的一个例子是：\n\n```cpp\nif (b[1] == 1) return 1;\nelse if (b[0] == 0) return 0;\nelse return 1;\n```\n\n例如，如果上方程序的输入是 \"10\"（即 $b[0]=1$ 及 $b[1]=0$），那么输出应当为 $1$。 \n\nElsie 告诉了 Bessie 对于 $M(1 \\le M \\le 100)$ 个不同输入的正确输出。Bessie 现在正试图对 Elsie 的程序进行逆向工程。不幸的是，Elsie 可能说了谎；可能不存在上述形式的程序行为与 Elsie 所说的均一致。 \n\n对于 $T(1 \\le T \\le 10)$ 个子测试用例中的每一个，判断 Elsie 是否一定在说谎。", "inputFormat": "输入的第一行包含 $T$，为子测试用例的数量。\n\n每一个子测试用例的第一行包含两个整数 $N$ 和 $M$，以下 $M$ 行，每行包含一个由 $N$ 个 $0$ 或 $1$ 组成的字符串，表示一个输入（即 $b[0] \\cdots b[N−1]$ 的值），以及另一个字符（$0$ 或 $1$）表示输出。相邻的子测试用例之间用空行分隔。 ", "outputFormat": "对于每一个子测试用例，输出一行，包含 $\\texttt{OK}$ 或 $\\texttt{LIE}$，分别表示 Elsie 可能没有说谎或是一定在说谎。 ", "hint": "### 样例 1 解释\n\n以下是第一个子测试用例的一个合法的程序：\n\n```cpp\nif (b[0] == 0) return 0;\nelse return 1;\n```\n\n以下是第一个子测试用例的另一个合法的程序：\n\n```cpp\nif (b[0] == 1) return 1;\nelse return 0;\n```\n\n以下是第二个子测试用例的一个合法的程序：\n\n```cpp\nif (b[1] == 1) return 1;\nelse if (b[0] == 0) return 0;\nelse return 1;\n```\n\n显然，对于第三个子测试用例不存在对应的合法的程序，因为 Elsie 的程序一定始终对相同的输入产生相同的输出。\n\n可以证明对于最后一个子测试用例不存在对应的合法的程序。 \n\n### 测试点性质\n\n- 测试点 $2-3$ 满足 $N=2$。\n- 测试点 $4-5$ 满足 $M=2$。\n- 测试点 $6-12$ 没有额外限制。 ", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Reverse Engineering B", "background": "", "description": "Elsie has a program that takes as input an array of $N$ variables ($1 \\le N \\le 100$), $b[0], \\cdots, b[N-1]$, where each variable equals $0$ or $1$, and returns the result of applying a sequence of `if / else if / else` statements to the input. Each branch checks at most one input variable and returns $0$ or $1$. An example of such a program is:\n\n```cpp\nif (b[1] == 1) return 1;\nelse if (b[0] == 0) return 0;\nelse return 1;\n```\n\nFor example, if the input to the program above is \"10\" (i.e., $b[0] = 1$ and $b[1] = 0$), then the output should be $1$.\n\nElsie told Bessie the correct outputs for $M$ different inputs ($1 \\le M \\le 100$). Bessie is now trying to reverse engineer Elsie’s program. Unfortunately, Elsie may have lied; there might be no program of the above form whose behavior matches everything Elsie said.\n\nFor each of $T$ test cases ($1 \\le T \\le 10$), determine whether Elsie is certainly lying.", "inputFormat": "The first line contains $T$, the number of test cases.\n\nFor each test case, the first line contains two integers $N$ and $M$. Each of the following $M$ lines contains a string of $N$ characters, each $0$ or $1$, representing an input (the values of $b[0] \\cdots b[N-1]$), followed by another character ($0$ or $1$) representing the output. Consecutive test cases are separated by a blank line.", "outputFormat": "For each test case, output a single line containing $\\texttt{OK}$ or $\\texttt{LIE}$, indicating respectively that Elsie might not be lying or is certainly lying.", "hint": "### Explanation for Sample 1\n\nHere is one valid program for the first test case:\n\n```cpp\nif (b[0] == 0) return 0;\nelse return 1;\n```\n\nHere is another valid program for the first test case:\n\n```cpp\nif (b[0] == 1) return 1;\nelse return 0;\n```\n\nHere is one valid program for the second test case:\n\n```cpp\nif (b[1] == 1) return 1;\nelse if (b[0] == 0) return 0;\nelse return 1;\n```\n\nClearly, no valid program exists for the third test case, since Elsie’s program must always produce the same output for the same input.\n\nIt can be proven that no valid program exists for the last test case.\n\n### Properties of test points\n\n- Test points $2$–$3$ satisfy $N = 2$.\n- Test points $4$–$5$ satisfy $M = 2$.\n- Test points $6$–$12$ have no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Reverse Engineering B", "background": "", "description": "Elsie 有一个程序，接受一个 $N(1 \\le N \\le 100)$ 个变量的数组 $b[0], \\cdots ,b[N−1]$ 作为输入，其中每个变量等于 $0$ 或 $1$，并且返回对输入数组应用一系列 `if / else if / else` 语句的结果。每个语句检查至多一个输入变量的值，并返回 $0$ 或 $1$。这类程序的一个例子是：\n\n```cpp\nif (b[1] == 1) return 1;\nelse if (b[0] == 0) return 0;\nelse return 1;\n```\n\n例如，如果上方程序的输入是 \"10\"（即 $b[0]=1$ 及 $b[1]=0$），那么输出应当为 $1$。 \n\nElsie 告诉了 Bessie 对于 $M(1 \\le M \\le 100)$ 个不同输入的正确输出。Bessie 现在正试图对 Elsie 的程序进行逆向工程。不幸的是，Elsie 可能说了谎；可能不存在上述形式的程序行为与 Elsie 所说的均一致。 \n\n对于 $T(1 \\le T \\le 10)$ 个子测试用例中的每一个，判断 Elsie 是否一定在说谎。", "inputFormat": "输入的第一行包含 $T$，为子测试用例的数量。\n\n每一个子测试用例的第一行包含两个整数 $N$ 和 $M$，以下 $M$ 行，每行包含一个由 $N$ 个 $0$ 或 $1$ 组成的字符串，表示一个输入（即 $b[0] \\cdots b[N−1]$ 的值），以及另一个字符（$0$ 或 $1$）表示输出。相邻的子测试用例之间用空行分隔。 ", "outputFormat": "对于每一个子测试用例，输出一行，包含 $\\texttt{OK}$ 或 $\\texttt{LIE}$，分别表示 Elsie 可能没有说谎或是一定在说谎。 ", "hint": "### 样例 1 解释\n\n以下是第一个子测试用例的一个合法的程序：\n\n```cpp\nif (b[0] == 0) return 0;\nelse return 1;\n```\n\n以下是第一个子测试用例的另一个合法的程序：\n\n```cpp\nif (b[0] == 1) return 1;\nelse return 0;\n```\n\n以下是第二个子测试用例的一个合法的程序：\n\n```cpp\nif (b[1] == 1) return 1;\nelse if (b[0] == 0) return 0;\nelse return 1;\n```\n\n显然，对于第三个子测试用例不存在对应的合法的程序，因为 Elsie 的程序一定始终对相同的输入产生相同的输出。\n\n可以证明对于最后一个子测试用例不存在对应的合法的程序。 \n\n### 测试点性质\n\n- 测试点 $2-3$ 满足 $N=2$。\n- 测试点 $4-5$ 满足 $M=2$。\n- 测试点 $6-12$ 没有额外限制。 ", "locale": "zh-CN"}}}
{"pid": "P8900", "type": "P", "difficulty": 4, "samples": [["4\n2 1 4 5\n1 2\n2 3\n2 4", "3\n3 2 1\n4 2 2\n2 1 1"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "USACO", "2022", "Special Judge", "构造"], "title": "[USACO22DEC] Barn Tree S", "background": "", "description": "Farmer John 的农场有 $N$ 个牛棚 $(2 \\le N \\le 2 \\times 10^5)$，编号为 $1 \\cdots N$。有 $N−1$ 条道路，每条道路连接两个牛棚，并且从任一牛棚均可通过一些道路到达任一其他牛棚。目前，第 $j$ 个牛棚中有 $h_j$ 个干草捆 $(1 \\le h_j \\le 10^9)$。 \n\n为使他的奶牛们满意，Farmer John 想移动这些干草，使得每个牛棚都有相同数量的干草捆。他可以选择任何一对由一条道路连接的牛棚，并命令他的农场工人将不超过第一个牛棚中干草捆数量的任意正整数个干草捆从第一个牛棚移动到第二个牛棚。 \n\n请求出一个 Farmer John 可以发出的命令序列，以尽可能少的命令数完成这一任务。输入保证存在符合要求的命令序列。 ", "inputFormat": "输入的第一行包含整数 $N$。\n\n第二行包含空格分隔的整数 $h_j$，其中 $j=1\\cdots N$。\n\n最后 $N−1$ 行每行包含两个空格分隔的牛棚编号 $u_i,v_i$，表示有一条双向道路连接 $u_i$ 和 $v_i$。", "outputFormat": "输出命令的最小数量，然后输出该数量的命令序列，每行输出一条命令。\n\n每条命令的格式应为三个空格分隔的正整数：出发牛棚，目标牛棚，以及从出发牛棚移动到目标牛棚的干草捆数量。\n\n如果有多组解，输出任意一组。 ", "hint": "### 样例 1 解释\n\n在这个例子中，共有十二个干草捆和四个牛棚，这意味着每个牛棚最后必须有三个干草捆。输出样例中的命令顺序可以用以下的自然语言表述： \n\n1. 从牛棚 $3$ 到牛棚 $2$，移动 $1$ 个干草捆。\n2. 从牛棚 $4$ 到牛棚 $2$，移动 $2$ 个干草捆。\n3. 从牛棚 $2$ 到牛棚 $1$，移动 $1$ 个干草捆。\n\n### 测试点性质\n\n- 测试点 $2-8$ 满足 $N \\le 5000$。\n- 测试点 $7-10$ 满足 $v_i=u_i+1$。\n- 测试点 $11-16$ 没有额外限制。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Barn Tree S", "background": "", "description": "Farmer John’s farm has $N$ barns $(2 \\le N \\le 2 \\times 10^5)$, labeled $1 \\cdots N$. There are $N−1$ roads, each connecting two barns, and from any barn it is possible to reach any other barn via some roads. Currently, barn $j$ contains $h_j$ haybales $(1 \\le h_j \\le 10^9)$.\n\nTo keep his cows happy, Farmer John wants to move the hay so that every barn has the same number of haybales. He may choose any pair of barns connected by a single road and instruct his farmhands to move any positive integer number of haybales, up to the amount in the first barn, from the first barn to the second barn.\n\nFind a sequence of commands that Farmer John can issue to complete this task using as few commands as possible. The input guarantees that such a sequence exists.", "inputFormat": "The first line contains the integer $N$.\n\nThe second line contains space-separated integers $h_j$ for $j=1 \\cdots N$.\n\nEach of the last $N−1$ lines contains two space-separated barn indices $u_i, v_i$, indicating there is a bidirectional road between $u_i$ and $v_i$.", "outputFormat": "Output the minimum number of commands, then output a sequence of that many commands, one per line.\n\nEach command should be three space-separated positive integers: the source barn, the destination barn, and the number of haybales moved from the source to the destination.\n\nIf there are multiple solutions, output any of them.", "hint": "### Sample 1 Explanation\n\nIn this example, there are twelve haybales and four barns, which means each barn must end up with three haybales. The sequence in the sample output can be described in natural language as follows:\n\n1. From barn $3$ to barn $2$, move $1$ haybale.\n2. From barn $4$ to barn $2$, move $2$ haybales.\n3. From barn $2$ to barn $1$, move $1$ haybale.\n\n### Testpoint Properties\n\n- Testpoints $2-8$ satisfy $N \\le 5000$.\n- Testpoints $7-10$ satisfy $v_i=u_i+1$.\n- Testpoints $11-16$ have no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Barn Tree S", "background": "", "description": "Farmer John 的农场有 $N$ 个牛棚 $(2 \\le N \\le 2 \\times 10^5)$，编号为 $1 \\cdots N$。有 $N−1$ 条道路，每条道路连接两个牛棚，并且从任一牛棚均可通过一些道路到达任一其他牛棚。目前，第 $j$ 个牛棚中有 $h_j$ 个干草捆 $(1 \\le h_j \\le 10^9)$。 \n\n为使他的奶牛们满意，Farmer John 想移动这些干草，使得每个牛棚都有相同数量的干草捆。他可以选择任何一对由一条道路连接的牛棚，并命令他的农场工人将不超过第一个牛棚中干草捆数量的任意正整数个干草捆从第一个牛棚移动到第二个牛棚。 \n\n请求出一个 Farmer John 可以发出的命令序列，以尽可能少的命令数完成这一任务。输入保证存在符合要求的命令序列。 ", "inputFormat": "输入的第一行包含整数 $N$。\n\n第二行包含空格分隔的整数 $h_j$，其中 $j=1\\cdots N$。\n\n最后 $N−1$ 行每行包含两个空格分隔的牛棚编号 $u_i,v_i$，表示有一条双向道路连接 $u_i$ 和 $v_i$。", "outputFormat": "输出命令的最小数量，然后输出该数量的命令序列，每行输出一条命令。\n\n每条命令的格式应为三个空格分隔的正整数：出发牛棚，目标牛棚，以及从出发牛棚移动到目标牛棚的干草捆数量。\n\n如果有多组解，输出任意一组。 ", "hint": "### 样例 1 解释\n\n在这个例子中，共有十二个干草捆和四个牛棚，这意味着每个牛棚最后必须有三个干草捆。输出样例中的命令顺序可以用以下的自然语言表述： \n\n1. 从牛棚 $3$ 到牛棚 $2$，移动 $1$ 个干草捆。\n2. 从牛棚 $4$ 到牛棚 $2$，移动 $2$ 个干草捆。\n3. 从牛棚 $2$ 到牛棚 $1$，移动 $1$ 个干草捆。\n\n### 测试点性质\n\n- 测试点 $2-8$ 满足 $N \\le 5000$。\n- 测试点 $7-10$ 满足 $v_i=u_i+1$。\n- 测试点 $11-16$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P8901", "type": "P", "difficulty": 4, "samples": [["5\n1\n4\n1\n9\n2\n2 3\n2\n7 10\n3\n4 9 4", "Farmer Nhoj\nFarmer John\nFarmer John\nFarmer John\nFarmer Nhoj"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["博弈论", "USACO", "2022", "素数判断,质数,筛法"], "title": "[USACO22DEC] Circular Barn S", "background": "", "description": "Farmer John 和他的死对头 Farmer Nhoj 在一个环形牛棚内玩游戏。牛棚内有 $N(1 \\le N \\le 10^5)$ 个房间，第 $i$ 个房间初始时内有 $a_i$ 头奶牛 $(1 \\le a_i \\le 5 \\times 10^6)$。游戏玩法如下：\n\n- 两位农夫将总是在同一个房间里。进入一个房间后，每位农夫各执行一次行动，Farmer John 在先。两位农夫在游戏开始时进入房间 $1$。\n- 如果当前房间中的奶牛数量为零，则此时执行行动的农夫即失败。否则，执行行动的农夫选择一个整数 $P$，其中 $P$ 为 $1$ 或一个不超过当前房间中奶牛的数量的质数，并从当前房间中移除 $P$ 头奶牛。\n- 两位农夫均完成行动之后，两位农夫移动到环形牛棚的下一间房间。也就是说，如果农夫们在房间 $i$，那么他们会移动到房间 $i+1$，除非他们在房间 $N$，在这种情况下他们会移动到房间 $1$。\n\n当两位农夫均采用最优策略时，求获胜的农夫。 ", "inputFormat": "输入包含 $T$ 个子测试用例。输入的第一行包含 $T(1 \\le T \\le 1000)$。下面是 $T$ 个子测试用例。\n\n每个子测试用例的第一行包含 $N$，第二行包含 $a_1, \\cdots ,a_N$。\n\n输入保证所有 $N$ 之和不超过 $2 \\times 10^5$。 ", "outputFormat": " 对于每一个子测试用例，输出获胜的农夫，为 `Farmer John` 或 `Farmer Nhoj` 之一。", "hint": "### 样例 1 解释\n\n对于第一个子测试用例，Farmer John 可以从第一个房间中移除 $1$、$2$ 或 $3$ 头奶牛。无论他移除多少头奶牛，Nhoj 都可以移除剩余的奶牛，迫使 FJ 在他们绕回第一个房间时失败。\n\n对于第二个子测试用例，FJ 可以移除 $5$ 头奶牛，迫使 Nhoj 面对剩下的 $4$ 头奶牛。现在，Nhoj 可以移除 $1$、$2$ 或 $3$ 奶牛。现在的情况类似于第一个子测试用例。\n\n对于第三个和第四个子测试用例，FJ 可以立即移除第一个房间的所有奶牛，使 Nhoj 失败。\n\n对于第五个子测试用例，FJ 可以从第一个房间中移除 $1$\n、$2$ 或 $3$ 奶牛，然后 Nhoj 可以随后移除余下的奶牛。当他们绕回第一个房间时，FJ 将会失败。 \n\n### 测试点性质\n\n- 测试点 $2-4$ 满足 $N=1$。\n- 测试点 $1,2,5-7$ 满足 $a_i \\le 1000$。\n- 测试点 $8-20$ 没有额外限制。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Circular Barn S", "background": "", "description": "Farmer John and his archrival Farmer Nhoj play a game in a circular barn. The barn has $N$ rooms $(1 \\le N \\le 10^5)$, and the $i$-th room initially contains $a_i$ cows $(1 \\le a_i \\le 5 \\times 10^6)$. The game proceeds as follows:\n\n- The two farmers are always in the same room. Upon entering a room, each farmer takes one move, with Farmer John moving first. At the start of the game, they enter room $1$.\n- If the current room has zero cows, then the farmer whose turn it is loses. Otherwise, the farmer whose turn it is chooses an integer $P$, where $P$ is $1$ or a prime number not exceeding the number of cows in the current room, and removes $P$ cows from the current room.\n- After both farmers have completed their moves, they move to the next room in the circular barn. That is, if they are in room $i$, they move to room $i+1$, unless they are in room $N$, in which case they move to room $1$.\n\nDetermine the winner when both farmers play optimally.", "inputFormat": "The input contains $T$ subtest cases. The first line contains $T$ $(1 \\le T \\le 1000)$. Then follow $T$ subtest cases.\n\nFor each subtest case, the first line contains $N$, and the second line contains $a_1, \\cdots, a_N$.\n\nIt is guaranteed that the sum of all $N$ does not exceed $2 \\times 10^5$.", "outputFormat": "For each subtest case, output the winner, either `Farmer John` or `Farmer Nhoj`.", "hint": "### Sample 1 Explanation\n\nFor the first subtest case, Farmer John can remove $1$, $2$, or $3$ cows from the first room. No matter how many he removes, Nhoj can remove the remaining cows, forcing FJ to lose when they loop back to the first room.\n\nFor the second subtest case, FJ can remove $5$ cows, forcing Nhoj to face the remaining $4$ cows. Now Nhoj can remove $1$, $2$, or $3$ cows. The situation is now similar to the first subtest case.\n\nFor the third and fourth subtest cases, FJ can immediately remove all cows from the first room, causing Nhoj to lose.\n\nFor the fifth subtest case, FJ can remove $1$, $2$, or $3$ cows from the first room, and then Nhoj can remove the remaining cows afterward. When they loop back to the first room, FJ will lose.\n\n### Test Point Properties\n\n- Test points $2$–$4$ satisfy $N=1$.\n- Test points $1,2,5$–$7$ satisfy $a_i \\le 1000$.\n- Test points $8$–$20$ have no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Circular Barn S", "background": "", "description": "Farmer John 和他的死对头 Farmer Nhoj 在一个环形牛棚内玩游戏。牛棚内有 $N(1 \\le N \\le 10^5)$ 个房间，第 $i$ 个房间初始时内有 $a_i$ 头奶牛 $(1 \\le a_i \\le 5 \\times 10^6)$。游戏玩法如下：\n\n- 两位农夫将总是在同一个房间里。进入一个房间后，每位农夫各执行一次行动，Farmer John 在先。两位农夫在游戏开始时进入房间 $1$。\n- 如果当前房间中的奶牛数量为零，则此时执行行动的农夫即失败。否则，执行行动的农夫选择一个整数 $P$，其中 $P$ 为 $1$ 或一个不超过当前房间中奶牛的数量的质数，并从当前房间中移除 $P$ 头奶牛。\n- 两位农夫均完成行动之后，两位农夫移动到环形牛棚的下一间房间。也就是说，如果农夫们在房间 $i$，那么他们会移动到房间 $i+1$，除非他们在房间 $N$，在这种情况下他们会移动到房间 $1$。\n\n当两位农夫均采用最优策略时，求获胜的农夫。 ", "inputFormat": "输入包含 $T$ 个子测试用例。输入的第一行包含 $T(1 \\le T \\le 1000)$。下面是 $T$ 个子测试用例。\n\n每个子测试用例的第一行包含 $N$，第二行包含 $a_1, \\cdots ,a_N$。\n\n输入保证所有 $N$ 之和不超过 $2 \\times 10^5$。 ", "outputFormat": " 对于每一个子测试用例，输出获胜的农夫，为 `Farmer John` 或 `Farmer Nhoj` 之一。", "hint": "### 样例 1 解释\n\n对于第一个子测试用例，Farmer John 可以从第一个房间中移除 $1$、$2$ 或 $3$ 头奶牛。无论他移除多少头奶牛，Nhoj 都可以移除剩余的奶牛，迫使 FJ 在他们绕回第一个房间时失败。\n\n对于第二个子测试用例，FJ 可以移除 $5$ 头奶牛，迫使 Nhoj 面对剩下的 $4$ 头奶牛。现在，Nhoj 可以移除 $1$、$2$ 或 $3$ 奶牛。现在的情况类似于第一个子测试用例。\n\n对于第三个和第四个子测试用例，FJ 可以立即移除第一个房间的所有奶牛，使 Nhoj 失败。\n\n对于第五个子测试用例，FJ 可以从第一个房间中移除 $1$\n、$2$ 或 $3$ 奶牛，然后 Nhoj 可以随后移除余下的奶牛。当他们绕回第一个房间时，FJ 将会失败。 \n\n### 测试点性质\n\n- 测试点 $2-4$ 满足 $N=1$。\n- 测试点 $1,2,5-7$ 满足 $a_i \\le 1000$。\n- 测试点 $8-20$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P8902", "type": "P", "difficulty": 4, "samples": [["3\n0 2 2\n0 1\n0", "1 3 2"], ["3\n0 1 1\n0 0\n0", "0 1 1"], ["4\n0 1 2 2\n0 1 1\n0 1\n0", "1 2 3 2"], ["4\n0 1 1 2\n0 0 2\n0 2\n0", "1 2 2 0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["USACO", "2022", "Special Judge", "构造"], "title": "[USACO22DEC] Range Reconstruction S", "background": "", "description": "Bessie 有一个数组 $a_1, \\cdots, a_N$，其中 $1 \\le N \\le 300$ 并对于所有 $i$ 有 $0 \\le a_i \\le 10^9$。她不会告诉你数组 $a$ 本身，但她会告诉你 $a$ 的每个子数组的全距。也就是说，对于每对索引 $i \\le j$，Bessie 告诉你 $r_{i,j}= \\max a[i \\cdots j]− \\min a[i \\cdots j]$。给定这些 $r$ 的值，构造一个可以作为 Bessie 的原始数组的数组。你的数组中的数值应在 $[−10^9,10^9]$ 范围内。 ", "inputFormat": "输入的第一行包含 $N$。\n\n以下 $N$ 行，第 $i$ 行包含整数 $r_{i,i},r_{i,i+1}, \\cdots ,r_{i,N}$。\n\n输入保证存在某个数组 $a$，其中的数值在 $[0,10^9]$ 范围内，满足对于所有的 $i \\le j$，有 $r_{i,j}= \\max a[i \\cdots j]−\\min a[i\\cdots j]$。 ", "outputFormat": "输出一行，包含 $N$ 个整数 $b_1,b_2, \\cdots ,b_N$，在 $[−10^9,10^9]$ 范围内，表示你的数组。这些数需要满足对于所有的 $i \\le j$ 有 $r_{i,j}= \\max a[i \\cdots j]−\\min a[i\\cdots j]$。 ", "hint": "### 样例 1 解释\n\n例如，$r_{1,3}=\\max a[1 \\cdots 3]−\\min a[1\\cdots 3]=3−1=2$。\n\n### 样例 2 解释\n\n这个样例满足子任务 $1$ 的限制。\n\n### 样例 3 解释\n\n这个样例满足子任务 2 的限制。 \n\n### 测试点性质\n\n- 测试点 $5$ 满足 $r_{1,N} \\le 1$。\n- 测试点 $6-8$ 满足对于所有 $1 \\le i<N$ 均有 $r_{i,i+1}=1$。\n- 测试点 $9-14$ 没有额外限制。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Range Reconstruction S", "background": "", "description": "Bessie has an array $a_1, \\cdots, a_N$, where $1 \\le N \\le 300$ and for all $i$ we have $0 \\le a_i \\le 10^9$. She will not tell you the array $a$ itself, but she will tell you the range of every subarray of $a$. That is, for every pair of indices $i \\le j$, Bessie tells you $r_{i,j}= \\max a[i \\cdots j]− \\min a[i \\cdots j]$. Given these $r$ values, construct an array that could be Bessie's original array. The values in your array must be in the range $[−10^9,10^9]$.", "inputFormat": "The first line contains $N$.\n\nThe next $N$ lines: line $i$ contains the integers $r_{i,i},r_{i,i+1}, \\cdots ,r_{i,N}$.\n\nIt is guaranteed that there exists some array $a$, with values in the range $[0,10^9]$, such that for all $i \\le j$, $r_{i,j}= \\max a[i \\cdots j]−\\min a[i\\cdots j]$.", "outputFormat": "Output one line containing $N$ integers $b_1,b_2, \\cdots ,b_N$ in the range $[−10^9,10^9]$, representing your array. These numbers must satisfy that for all $i \\le j$, $r_{i,j}= \\max a[i \\cdots j]−\\min a[i\\cdots j]$.", "hint": "Sample 1 Explanation\n\nFor example, $r_{1,3}=\\max a[1 \\cdots 3]−\\min a[1\\cdots 3]=3−1=2$.\n\nSample 2 Explanation\n\nThis sample satisfies the constraints of subtask 1.\n\nSample 3 Explanation\n\nThis sample satisfies the constraints of subtask 2.\n\nProperties of test points\n\n- Test point $5$ satisfies $r_{1,N} \\le 1$.\n- Test points $6-8$ satisfy that for all $1 \\le i<N$ we have $r_{i,i+1}=1$.\n- Test points $9-14$ have no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Range Reconstruction S", "background": "", "description": "Bessie 有一个数组 $a_1, \\cdots, a_N$，其中 $1 \\le N \\le 300$ 并对于所有 $i$ 有 $0 \\le a_i \\le 10^9$。她不会告诉你数组 $a$ 本身，但她会告诉你 $a$ 的每个子数组的全距。也就是说，对于每对索引 $i \\le j$，Bessie 告诉你 $r_{i,j}= \\max a[i \\cdots j]− \\min a[i \\cdots j]$。给定这些 $r$ 的值，构造一个可以作为 Bessie 的原始数组的数组。你的数组中的数值应在 $[−10^9,10^9]$ 范围内。 ", "inputFormat": "输入的第一行包含 $N$。\n\n以下 $N$ 行，第 $i$ 行包含整数 $r_{i,i},r_{i,i+1}, \\cdots ,r_{i,N}$。\n\n输入保证存在某个数组 $a$，其中的数值在 $[0,10^9]$ 范围内，满足对于所有的 $i \\le j$，有 $r_{i,j}= \\max a[i \\cdots j]−\\min a[i\\cdots j]$。 ", "outputFormat": "输出一行，包含 $N$ 个整数 $b_1,b_2, \\cdots ,b_N$，在 $[−10^9,10^9]$ 范围内，表示你的数组。这些数需要满足对于所有的 $i \\le j$ 有 $r_{i,j}= \\max a[i \\cdots j]−\\min a[i\\cdots j]$。 ", "hint": "### 样例 1 解释\n\n例如，$r_{1,3}=\\max a[1 \\cdots 3]−\\min a[1\\cdots 3]=3−1=2$。\n\n### 样例 2 解释\n\n这个样例满足子任务 $1$ 的限制。\n\n### 样例 3 解释\n\n这个样例满足子任务 2 的限制。 \n\n### 测试点性质\n\n- 测试点 $5$ 满足 $r_{1,N} \\le 1$。\n- 测试点 $6-8$ 满足对于所有 $1 \\le i<N$ 均有 $r_{i,i+1}=1$。\n- 测试点 $9-14$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P8903", "type": "P", "difficulty": 5, "samples": [["3 10 8\n5 5 4\n6 7 3\n10 6 3", "15"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "USACO", "2022", "背包 DP"], "title": "[USACO22DEC] Bribing Friends G", "background": "", "description": "Bessie 想要观看纪录片：奶牛基因组学，但她不想一个人去。不幸的是，她的朋友们没有足够的热情和她一起去！于是，Bessie 需要贿赂她的朋友们陪她去电影院。她的贿赂武器库中有两种工具：**哞尼**和**冰激凌甜筒**。\n\nBessie 有 $N(1 \\le N \\le 2000)$ 个朋友。然而，并非所有的朋友都是生而平等的！朋友 $i$ 有受欢迎度 $P_i(1 \\le P_i \\le 2000)$，Bessie 想最大化陪她的朋友们的受欢迎度之和。朋友 $i$ 只有当 Bessie 给了她 $C_i(1 \\le C_i \\le 2000)$ 哞尼才愿意陪她。如果 Bessie 给她 $X_i(1 \\le X_i \\le 2000)$ 个冰激凌甜筒，她还可以给 Bessie $1$ 哞尼的折扣。Bessie 可以从朋友那里得到任意整数数量的折扣，只要这些折扣不会使得朋友倒给她哞尼。 \n\nBessie 有 $A$ 哞尼和 $B$ 个冰激凌甜筒可供使用（$0 \\le A,B \\le 2000$）。请帮助她求出如果她以最优方案花费她的哞尼和冰激凌甜筒，她可以达到的最大受欢迎度之和。 ", "inputFormat": "输入的第 1 行包含三个整数 $N$，$A$ 和 $B$，分别表示 Bessie 拥有的朋友的数量，哞尼的数量和冰激凌甜筒的数量。\n\n以下 $N$ 行每行包含三个整数 $P_i$，$C_i$ 和 $X_i$，表示受欢迎度（$P_i$），贿赂朋友 $i$ 陪 Bessie 所需要的哞尼（$C_i$），以及从朋友 $i$ 处获得 $1$ 哞尼的折扣所需要的冰激凌甜筒的数量（$X_i$）。", "outputFormat": "输出陪 Bessie 的朋友们的最大受欢迎度之和，假设她以最优方案花费她的哞尼和冰激凌甜筒。 ", "hint": "### 样例 1 解释\n\nBessie 可以将 $4$ 哞尼和 $4$ 个冰激凌甜筒给奶牛 $1$，将 $6$ 哞尼和 $3$ 个冰激凌甜筒给奶牛 $3$，这样奶牛 $1$ 和 $3$ 就可以陪她，得到 $5+10=15$ 的受欢迎度。\n\n### 测试点性质\n\n - 测试点 $2-4$ 满足 $N \\le 5$ 以及 $C_i=1$。\n - 测试点 $5-7$ 满足 $B=0$。\n - 测试点 $8-10$ 满足 $N,A,B,P_i,C_i,X_i \\le 50$。\n - 测试点 $11-15$ 满足 $N,A,B,P_i,C_i,X_i \\le 200$。\n - 测试点 $16-20$ 没有额外限制。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Bribing Friends G", "background": "", "description": "Bessie wants to watch the documentary: Cow Genomics, but she does not want to go alone. Unfortunately, her friends are not enthusiastic enough to go with her. So Bessie needs to bribe her friends to accompany her to the movie theater. She has two tools in her bribery arsenal: **Moonies** and **ice cream cones**.\n\nBessie has $N(1 \\le N \\le 2000)$ friends. However, not all friends are created equal. Friend $i$ has popularity $P_i(1 \\le P_i \\le 2000)$, and Bessie wants to maximize the sum of popularities of the friends who go with her. Friend $i$ will go with Bessie only if Bessie gives her $C_i(1 \\le C_i \\le 2000)$ Moonies. If Bessie gives her $X_i(1 \\le X_i \\le 2000)$ ice cream cones, then the friend can also give Bessie a discount of $1$ Moony. Bessie can obtain any integer number of discounts from a friend, as long as these discounts do not make the friend give Moonies back to her.\n\nBessie has $A$ Moonies and $B$ ice cream cones available ($0 \\le A,B \\le 2000$). Please help her find the maximum possible total popularity she can achieve if she spends her Moonies and ice cream cones in the best way.", "inputFormat": "The first line contains three integers $N$, $A$, and $B$, representing the number of friends Bessie has, the number of Moonies, and the number of ice cream cones.\n\nThe next $N$ lines each contain three integers $P_i$, $C_i$, and $X_i$, representing the popularity ($P_i$), the number of Moonies needed to bribe friend $i$ to accompany Bessie ($C_i$), and the number of ice cream cones needed to get a discount of $1$ Moony from friend $i$ ($X_i$).", "outputFormat": "Output the maximum total popularity of the friends who accompany Bessie, assuming she spends her Moonies and ice cream cones in the best way.", "hint": "### Explanation for Sample 1\n\nBessie can give $4$ Moonies and $4$ ice cream cones to cow $1$, and give $6$ Moonies and $3$ ice cream cones to cow $3$. Then cows $1$ and $3$ can accompany her, obtaining popularity $5+10=15$.\n\n### Test Point Properties\n\n- Test points $2-4$ satisfy $N \\le 5$ and $C_i=1$.\n- Test points $5-7$ satisfy $B=0$.\n- Test points $8-10$ satisfy $N,A,B,P_i,C_i,X_i \\le 50$.\n- Test points $11-15$ satisfy $N,A,B,P_i,C_i,X_i \\le 200$.\n- Test points $16-20$ have no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Bribing Friends G", "background": "", "description": "Bessie 想要观看纪录片：奶牛基因组学，但她不想一个人去。不幸的是，她的朋友们没有足够的热情和她一起去！于是，Bessie 需要贿赂她的朋友们陪她去电影院。她的贿赂武器库中有两种工具：**哞尼**和**冰激凌甜筒**。\n\nBessie 有 $N(1 \\le N \\le 2000)$ 个朋友。然而，并非所有的朋友都是生而平等的！朋友 $i$ 有受欢迎度 $P_i(1 \\le P_i \\le 2000)$，Bessie 想最大化陪她的朋友们的受欢迎度之和。朋友 $i$ 只有当 Bessie 给了她 $C_i(1 \\le C_i \\le 2000)$ 哞尼才愿意陪她。如果 Bessie 给她 $X_i(1 \\le X_i \\le 2000)$ 个冰激凌甜筒，她还可以给 Bessie $1$ 哞尼的折扣。Bessie 可以从朋友那里得到任意整数数量的折扣，只要这些折扣不会使得朋友倒给她哞尼。 \n\nBessie 有 $A$ 哞尼和 $B$ 个冰激凌甜筒可供使用（$0 \\le A,B \\le 2000$）。请帮助她求出如果她以最优方案花费她的哞尼和冰激凌甜筒，她可以达到的最大受欢迎度之和。 ", "inputFormat": "输入的第 1 行包含三个整数 $N$，$A$ 和 $B$，分别表示 Bessie 拥有的朋友的数量，哞尼的数量和冰激凌甜筒的数量。\n\n以下 $N$ 行每行包含三个整数 $P_i$，$C_i$ 和 $X_i$，表示受欢迎度（$P_i$），贿赂朋友 $i$ 陪 Bessie 所需要的哞尼（$C_i$），以及从朋友 $i$ 处获得 $1$ 哞尼的折扣所需要的冰激凌甜筒的数量（$X_i$）。", "outputFormat": "输出陪 Bessie 的朋友们的最大受欢迎度之和，假设她以最优方案花费她的哞尼和冰激凌甜筒。 ", "hint": "### 样例 1 解释\n\nBessie 可以将 $4$ 哞尼和 $4$ 个冰激凌甜筒给奶牛 $1$，将 $6$ 哞尼和 $3$ 个冰激凌甜筒给奶牛 $3$，这样奶牛 $1$ 和 $3$ 就可以陪她，得到 $5+10=15$ 的受欢迎度。\n\n### 测试点性质\n\n - 测试点 $2-4$ 满足 $N \\le 5$ 以及 $C_i=1$。\n - 测试点 $5-7$ 满足 $B=0$。\n - 测试点 $8-10$ 满足 $N,A,B,P_i,C_i,X_i \\le 50$。\n - 测试点 $11-15$ 满足 $N,A,B,P_i,C_i,X_i \\le 200$。\n - 测试点 $16-20$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P8904", "type": "P", "difficulty": 5, "samples": [["5\n2 4 3 1 5\n3\n4 3\n1 3\n3 2", "7\n10\n7"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "数学", "线段树", "USACO", "2022"], "title": "[USACO22DEC] Mountains G", "background": "", "description": "沿着 Farmer John 的农场边缘有 $N(1 \\le N \\le 2000)$ 座排成一行等间隔分布的山。这些山可以用一个高度数组 $h_1,h_2, \\cdots ,h_N$ 表示。对于山 $i$，如果没有一座山严格高于连接山 $j$ 和 $i$ 山顶的视线，则可以看到山 $j$。形式化地说，对于两座山 $i<j$，如果不存在 $k$ 使得 $i<k<j$ 并且 $(k,h_k)$ 高于连接 $(i,h_i)$ 和 $(j,h_j)$ 的线段，则这两座山之间互相可以看到对方。给定 $Q(1 \\le Q \\le 2000)$ 次更新操作，每次更新增加一座山的高度。求每次更新后可以互相看到的山的无序对数。 ", "inputFormat": "输入的第一行包含 $N$。\n\n第 $2$ 行包含 $N$ 个高度 $h_1,h_2,\\cdots,h_N$（对每一个 $i$，有 $0 \\le h_i \\le 10^9$）。\n\n第 $3$ 行包含 $Q$。\n\n第 $4$ 到 $3+Q$ 行每行包含 $x,y(1 \\le x \\le N,1 \\le y)$，其中 $x$ 为山的编号，$y$ 是山增加的高度。输入保证这座山更新后的高度不超过 $10^9$。 ", "outputFormat": "输出 $Q$ 行，包含每次更新后可以互相看到的山的无序对数。 ", "hint": "### 样例 1 解释\n\n初始时，以下的山之间可以互相看到：$(1,2)$，$(2,3)$，$(2,5)$，$(3,4)$，$(3,5)$，$(4,5)$，共 $6$ 对。\n\n第一次更新后，山 $4$ 的高度为 $4$，这不会阻挡现有的可见性，但使得山 $4$ 现在可以看到山 $2$，从而使得答案变为 $7$。\n\n第二次更新后，山 $1$ 的高度为 $5$，这不会阻挡现有的可见性，但使得山 $1$ 现在可以看到山 $3$，$4$ 和 $5$，从而使得答案变为 $10$。\n\n第三次更新后，山 $3$ 的高度为 $5$，阻挡了山 $1$ 看到山 $4$，阻挡了山 $2$ 看到山 $4$ 和 $5$，同时由于该山本就可以看到其他所有山，所以并没有使得该山看到更多的山，从而使得答案变为 $7$。\n\n### 测试点性质\n\n - 测试点 $2-5$ 满足 $N,Q \\le 100$。\n - 测试点 $6-11$ 满足 $Q \\le 10$。\n - 测试点 $12-21$ 没有额外性质。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Mountains G", "background": "", "description": "Along the edge of Farmer John’s farm, there are $N(1 \\le N \\le 2000)$ mountains arranged in a line at equal spacing. These mountains can be represented by a height array $h_1,h_2,\\cdots,h_N$. For mountain $i$, mountain $j$ is visible if there is no mountain strictly higher than the line of sight connecting the peaks of mountains $j$ and $i$. Formally, for two mountains $i<j$, if there does not exist $k$ such that $i<k<j$ and the point $(k,h_k)$ is above the line segment connecting $(i,h_i)$ and $(j,h_j)$, then these two mountains can see each other.  \n\nYou are given $Q(1 \\le Q \\le 2000)$ update operations, each of which increases the height of one mountain. After each update, output the number of unordered pairs of mountains that can see each other.", "inputFormat": "The first line contains $N$.\n\nThe second line contains $N$ heights $h_1,h_2,\\cdots,h_N$ (for each $i$, $0 \\le h_i \\le 10^9$).\n\nThe third line contains $Q$.\n\nLines $4$ to $3+Q$ each contain $x,y(1 \\le x \\le N,1 \\le y)$, where $x$ is the index of the mountain and $y$ is the amount by which its height increases. The input guarantees that the height of this mountain after the update does not exceed $10^9$.", "outputFormat": "Output $Q$ lines, each containing the number of unordered pairs of mountains that can see each other after the corresponding update.", "hint": "### Sample 1 Explanation\n\nInitially, the following pairs of mountains can see each other: $(1,2)$, $(2,3)$, $(2,5)$, $(3,4)$, $(3,5)$, $(4,5)$, for a total of $6$ pairs.\n\nAfter the first update, the height of mountain $4$ becomes $4$. This does not block any existing visibility, but it makes mountain $4$ able to see mountain $2$, so the answer becomes $7$.\n\nAfter the second update, the height of mountain $1$ becomes $5$. This does not block any existing visibility, but it makes mountain $1$ able to see mountains $3$, $4$, and $5$, so the answer becomes $10$.\n\nAfter the third update, the height of mountain $3$ becomes $5$. This blocks mountain $1$ from seeing mountain $4$, and blocks mountain $2$ from seeing mountains $4$ and $5$. At the same time, since this mountain could already see all other mountains, it does not make it see more mountains, so the answer becomes $7$.\n\n### Test Point Properties\n\n- Test points $2-5$ satisfy $N,Q \\le 100$.\n- Test points $6-11$ satisfy $Q \\le 10$.\n- Test points $12-21$ have no additional properties.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Mountains G", "background": "", "description": "沿着 Farmer John 的农场边缘有 $N(1 \\le N \\le 2000)$ 座排成一行等间隔分布的山。这些山可以用一个高度数组 $h_1,h_2, \\cdots ,h_N$ 表示。对于山 $i$，如果没有一座山严格高于连接山 $j$ 和 $i$ 山顶的视线，则可以看到山 $j$。形式化地说，对于两座山 $i<j$，如果不存在 $k$ 使得 $i<k<j$ 并且 $(k,h_k)$ 高于连接 $(i,h_i)$ 和 $(j,h_j)$ 的线段，则这两座山之间互相可以看到对方。给定 $Q(1 \\le Q \\le 2000)$ 次更新操作，每次更新增加一座山的高度。求每次更新后可以互相看到的山的无序对数。 ", "inputFormat": "输入的第一行包含 $N$。\n\n第 $2$ 行包含 $N$ 个高度 $h_1,h_2,\\cdots,h_N$（对每一个 $i$，有 $0 \\le h_i \\le 10^9$）。\n\n第 $3$ 行包含 $Q$。\n\n第 $4$ 到 $3+Q$ 行每行包含 $x,y(1 \\le x \\le N,1 \\le y)$，其中 $x$ 为山的编号，$y$ 是山增加的高度。输入保证这座山更新后的高度不超过 $10^9$。 ", "outputFormat": "输出 $Q$ 行，包含每次更新后可以互相看到的山的无序对数。 ", "hint": "### 样例 1 解释\n\n初始时，以下的山之间可以互相看到：$(1,2)$，$(2,3)$，$(2,5)$，$(3,4)$，$(3,5)$，$(4,5)$，共 $6$ 对。\n\n第一次更新后，山 $4$ 的高度为 $4$，这不会阻挡现有的可见性，但使得山 $4$ 现在可以看到山 $2$，从而使得答案变为 $7$。\n\n第二次更新后，山 $1$ 的高度为 $5$，这不会阻挡现有的可见性，但使得山 $1$ 现在可以看到山 $3$，$4$ 和 $5$，从而使得答案变为 $10$。\n\n第三次更新后，山 $3$ 的高度为 $5$，阻挡了山 $1$ 看到山 $4$，阻挡了山 $2$ 看到山 $4$ 和 $5$，同时由于该山本就可以看到其他所有山，所以并没有使得该山看到更多的山，从而使得答案变为 $7$。\n\n### 测试点性质\n\n - 测试点 $2-5$ 满足 $N,Q \\le 100$。\n - 测试点 $6-11$ 满足 $Q \\le 10$。\n - 测试点 $12-21$ 没有额外性质。", "locale": "zh-CN"}}}
{"pid": "P8905", "type": "P", "difficulty": 5, "samples": [["8 10\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n1 5\n2 6\n3 7\n4 8", "12"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["USACO", "并查集", "2022", "枚举", "连通块"], "title": "[USACO22DEC] Strongest Friendship Group G", "background": "", "description": "Farmer John 有 $N$ 头奶牛（$2 \\le N \\le 10^5$），编号为 $1\\cdots N$。这些奶牛中有 $M(1 \\le M \\le 2\\times 10^5)$ 对朋友。\n\n一组奶牛被称为是「小团体」，如果该组中的每头奶牛都可以从该组中的每头其他奶牛出发通过完全位于该组内的一系列朋友关系到达（连接到组外奶牛的朋友关系无效）。小团体的「强度」是组内奶牛的最小组内朋友数乘以组内奶牛的数量（同样，注意连接到组外奶牛的朋友关系不计入此定义）。\n\n求所有小团体的最大强度。 ", "inputFormat": "输入的第一行包含 $N$ 和 $M$。\n\n以下 $M$ 行每行包含两个整数 $u_i$ 和 $v_i$，表示奶牛 $u_i$ 和 $v_i$ 是朋友（$1 \\le u_i,v_i \\le N,u_i\\neq v_i$）。每个奶牛无序对至多出现一次。 ", "outputFormat": " 输出一行，包含所有小团体的最大强度。 ", "hint": "### 样例 1 解释\n\n可以观察到最大强度来自编号为 $1,2,3,4$ 的奶牛组。该组内奶牛的最小朋友数为 $3$，故答案为 $4 \\times 3=12$。\n\n### 测试点性质\n\n - 对于 $1 \\le T \\le 3$，测试点 $T$ 满足 $N \\le 16$。\n - 对于 $4 \\le T \\le 9$，测试点 $T$ 满足 $N \\le 1000$。\n- 对于 $10 \\le T \\le 20$，测试点 $T$ 没有额外限制。 ", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Strongest Friendship Group G", "background": "", "description": "Farmer John has $N$ cows ($2 \\le N \\le 10^5$), numbered $1 \\cdots N$. Among these cows, there are $M$ ($1 \\le M \\le 2 \\times 10^5$) pairs of friends.\n\nA group of cows is called a \"friend group\" if, for every cow in the group, it can reach every other cow in the group by following a sequence of friendships that stays entirely within the group (friendships that connect to cows outside the group are invalid). The \"strength\" of a friend group is defined as:\n\n(the minimum number of in-group friends among cows in the group) $\\times$ (the number of cows in the group)\n\n(again, note that friendships connecting to cows outside the group are not counted in this definition).\n\nFind the maximum strength among all friend groups.", "inputFormat": "The first line contains $N$ and $M$.\n\nThe next $M$ lines each contain two integers $u_i$ and $v_i$, indicating that cows $u_i$ and $v_i$ are friends ($1 \\le u_i, v_i \\le N$, $u_i \\neq v_i$). Each unordered pair of cows appears at most once.", "outputFormat": "Output one line containing the maximum strength among all friend groups.", "hint": "### Explanation for Sample 1\n\nIt can be seen that the maximum strength comes from the group of cows numbered $1, 2, 3, 4$. In this group, the minimum number of friends is $3$, so the answer is $4 \\times 3 = 12$.\n\n### Test Point Properties\n\n- For $1 \\le T \\le 3$, test point $T$ satisfies $N \\le 16$.\n- For $4 \\le T \\le 9$, test point $T$ satisfies $N \\le 1000$.\n- For $10 \\le T \\le 20$, test point $T$ has no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Strongest Friendship Group G", "background": "", "description": "Farmer John 有 $N$ 头奶牛（$2 \\le N \\le 10^5$），编号为 $1\\cdots N$。这些奶牛中有 $M(1 \\le M \\le 2\\times 10^5)$ 对朋友。\n\n一组奶牛被称为是「小团体」，如果该组中的每头奶牛都可以从该组中的每头其他奶牛出发通过完全位于该组内的一系列朋友关系到达（连接到组外奶牛的朋友关系无效）。小团体的「强度」是组内奶牛的最小组内朋友数乘以组内奶牛的数量（同样，注意连接到组外奶牛的朋友关系不计入此定义）。\n\n求所有小团体的最大强度。 ", "inputFormat": "输入的第一行包含 $N$ 和 $M$。\n\n以下 $M$ 行每行包含两个整数 $u_i$ 和 $v_i$，表示奶牛 $u_i$ 和 $v_i$ 是朋友（$1 \\le u_i,v_i \\le N,u_i\\neq v_i$）。每个奶牛无序对至多出现一次。 ", "outputFormat": " 输出一行，包含所有小团体的最大强度。 ", "hint": "### 样例 1 解释\n\n可以观察到最大强度来自编号为 $1,2,3,4$ 的奶牛组。该组内奶牛的最小朋友数为 $3$，故答案为 $4 \\times 3=12$。\n\n### 测试点性质\n\n - 对于 $1 \\le T \\le 3$，测试点 $T$ 满足 $N \\le 16$。\n - 对于 $4 \\le T \\le 9$，测试点 $T$ 满足 $N \\le 1000$。\n- 对于 $10 \\le T \\le 20$，测试点 $T$ 没有额外限制。 ", "locale": "zh-CN"}}}
{"pid": "P8906", "type": "P", "difficulty": 6, "samples": [["3 4\n10 4 4\n9 5 3\n2 1 6\n3 1\n2 3\n2 1\n3 2\n2 2\n1 3\n3 3\n1 1\n1 2", "11\n18\n22\n22\n22\n-1\n-1\n-1\n-1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["USACO", "2022", "最短路", "均摊分析", "折半搜索 meet in the middle"], "title": "[USACO22DEC] Breakdown P", "background": "", "description": "Farmer John 的农场可以用一个带权有向图表示，道路（边）连接不同的结点，每条边的权值是通过道路所需的时间。每天，Bessie 喜欢从牛棚（位于结点 $1$）经过恰好 $K$ 条道路前往草地（位于结点 $N$），并希望在此限制下尽快到达草地。然而，在某些时候，道路停止维护，一条一条地开始破损，变得无法通行。帮助 Bessie 求出每一时刻从牛棚到草地的最短路径！\n\n形式化地说，我们从一个 $N$ 个结点（$1 \\le N \\le 300$）和 $N^2$ 条边的带权有向完全图开始：对于 $1 \\le i,j \\le N$ 的每一对 $(i,j)$ 存在一条边（注意存在 $N$ 个自环）。每次移除一条边后，输出从 $1$ 到 $N$ 的所有路径中经过恰好 $K$ 条边（不一定各不相同）的路径的最小权值（$2 \\le K \\le 8$）。注意在第 $i$ 次移除后，该图还剩下 $N^2-i$ 条边。\n\n路径的权值定义为路径上所有边的权值之和。注意一条路径可以包含同一条边多次或同一个结点多次，包括结点 $1$\n和 $N$。", "inputFormat": "输入的第一行包含 $N$ 和 $K$。\n\n以下 $N$ 行每行包含 $N$ 个整数。第 $i$ 行的第 $j$ 个整数为 $w_{ij}(1 \\le w_{ij} \\le 10^8)$。\n\n以下 $N^2$ 行，每行包含两个整数 $i$ 和 $j$（$1 \\le i,j \\le N$）。每对整数出现恰好一次。 ", "outputFormat": "输出 $N^2$ 行，为每一次移除后经过 $K$ 条边的路径的最小权值。如果不存在经过 $K$ 条边的路径则输出 $-1$。 ", "hint": "### 样例 1 解释\n\n第一次移除后，最短的经过 $4$ 条边的路径为：\n\n$$1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 2 \\rightarrow 3$$\n\n第二次移除后，最短的经过 $4$ 条边的路径为：\n\n$$1 \\rightarrow 3 \\rightarrow 2 \\rightarrow 1 \\rightarrow 3$$\n\n第三次移除后，最短的经过 $4$ 条边的路径为：\n\n$$1 \\rightarrow 3 \\rightarrow 3 \\rightarrow 3 \\rightarrow 3$$\n\n六次移除后，不再存在经过 $4$ 条边的路径。 \n\n### 测试点性质\n\n - 对于 $2 \\le T \\le 14$，测试点 $T$ 满足 $K=\\lfloor \\dfrac{T+3}{2} \\rfloor$。 ", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Breakdown P", "background": "", "description": "Farmer John’s farm can be represented as a weighted directed graph. Roads (edges) connect different nodes, and the weight of each edge is the time needed to travel along that road. Every day, Bessie likes to go from the barn (located at node $1$) to the pasture (located at node $N$) using exactly $K$ roads, and she wants to arrive as quickly as possible under this restriction. However, at certain times, roads stop being maintained and begin to break down one by one, becoming impassable. Help Bessie find the shortest path from the barn to the pasture at every moment.\n\nFormally, we start with a weighted directed complete graph with $N$ nodes ($1 \\le N \\le 300$) and $N^2$ edges: for every pair $(i,j)$ with $1 \\le i,j \\le N$, there is an edge (note that there are $N$ self-loops). After each removal of one edge, output the minimum total weight among all paths from $1$ to $N$ that use exactly $K$ edges (edges on the path do not have to be distinct) ($2 \\le K \\le 8$). Note that after the $i$-th removal, the graph has $N^2-i$ edges remaining.\n\nThe weight of a path is defined as the sum of the weights of all edges on the path. Note that a path may contain the same edge multiple times or visit the same node multiple times, including nodes $1$ and $N$.", "inputFormat": "The first line contains $N$ and $K$.\n\nThe next $N$ lines each contain $N$ integers. The $j$-th integer in the $i$-th line is $w_{ij}(1 \\le w_{ij} \\le 10^8)$.\n\nThe following $N^2$ lines each contain two integers $i$ and $j$ ($1 \\le i,j \\le N$). Each pair of integers appears exactly once.", "outputFormat": "Output $N^2$ lines. For each edge removal, output the minimum total weight of a path that uses exactly $K$ edges. If no such path exists, output $-1$.", "hint": "### Sample 1 Explanation\n\nAfter the first removal, the shortest path that uses exactly $4$ edges is:\n\n$$1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 2 \\rightarrow 3$$\n\nAfter the second removal, the shortest path that uses exactly $4$ edges is:\n\n$$1 \\rightarrow 3 \\rightarrow 2 \\rightarrow 1 \\rightarrow 3$$\n\nAfter the third removal, the shortest path that uses exactly $4$ edges is:\n\n$$1 \\rightarrow 3 \\rightarrow 3 \\rightarrow 3 \\rightarrow 3$$\n\nAfter the sixth removal, there is no longer any path that uses exactly $4$ edges.\n\n### Testdata Properties\n\n- For $2 \\le T \\le 14$, testdata $T$ satisfies $K=\\lfloor \\dfrac{T+3}{2} \\rfloor$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Breakdown P", "background": "", "description": "Farmer John 的农场可以用一个带权有向图表示，道路（边）连接不同的结点，每条边的权值是通过道路所需的时间。每天，Bessie 喜欢从牛棚（位于结点 $1$）经过恰好 $K$ 条道路前往草地（位于结点 $N$），并希望在此限制下尽快到达草地。然而，在某些时候，道路停止维护，一条一条地开始破损，变得无法通行。帮助 Bessie 求出每一时刻从牛棚到草地的最短路径！\n\n形式化地说，我们从一个 $N$ 个结点（$1 \\le N \\le 300$）和 $N^2$ 条边的带权有向完全图开始：对于 $1 \\le i,j \\le N$ 的每一对 $(i,j)$ 存在一条边（注意存在 $N$ 个自环）。每次移除一条边后，输出从 $1$ 到 $N$ 的所有路径中经过恰好 $K$ 条边（不一定各不相同）的路径的最小权值（$2 \\le K \\le 8$）。注意在第 $i$ 次移除后，该图还剩下 $N^2-i$ 条边。\n\n路径的权值定义为路径上所有边的权值之和。注意一条路径可以包含同一条边多次或同一个结点多次，包括结点 $1$\n和 $N$。", "inputFormat": "输入的第一行包含 $N$ 和 $K$。\n\n以下 $N$ 行每行包含 $N$ 个整数。第 $i$ 行的第 $j$ 个整数为 $w_{ij}(1 \\le w_{ij} \\le 10^8)$。\n\n以下 $N^2$ 行，每行包含两个整数 $i$ 和 $j$（$1 \\le i,j \\le N$）。每对整数出现恰好一次。 ", "outputFormat": "输出 $N^2$ 行，为每一次移除后经过 $K$ 条边的路径的最小权值。如果不存在经过 $K$ 条边的路径则输出 $-1$。 ", "hint": "### 样例 1 解释\n\n第一次移除后，最短的经过 $4$ 条边的路径为：\n\n$$1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 2 \\rightarrow 3$$\n\n第二次移除后，最短的经过 $4$ 条边的路径为：\n\n$$1 \\rightarrow 3 \\rightarrow 2 \\rightarrow 1 \\rightarrow 3$$\n\n第三次移除后，最短的经过 $4$ 条边的路径为：\n\n$$1 \\rightarrow 3 \\rightarrow 3 \\rightarrow 3 \\rightarrow 3$$\n\n六次移除后，不再存在经过 $4$ 条边的路径。 \n\n### 测试点性质\n\n - 对于 $2 \\le T \\le 14$，测试点 $T$ 满足 $K=\\lfloor \\dfrac{T+3}{2} \\rfloor$。 ", "locale": "zh-CN"}}}
{"pid": "P8907", "type": "P", "difficulty": 5, "samples": [["7 6\n1 3\n1 4\n7 1\n2 3\n2 4\n3 5", "5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["USACO", "2022", "启发式合并"], "title": "[USACO22DEC] Making Friends P", "background": "", "description": "FJ 的 $N(2 \\le N \\le 2 \\times 10^5)$ 头编号为 $1 \\cdots N$ 的奶牛之中初始时有 $M(1 \\le M \\le 2 \\times 10^5)$ 对朋友。奶牛们一头一头地离开农场去度假。第 $i$ 天，第 $i$ 头奶牛离开了农场，同时第 $i$ 头奶牛的所有仍在农场的朋友互相都成为了朋友。问总共建立了多少新的朋友关系？\n\n", "inputFormat": "输入的第一行包含 $N$ 和 $M$。\n\n以下 $M$ 行每行包含两个整数 $u_i$ 和 $v_i$，表示奶牛 $u_i$ 和 $v_i$ 是朋友（$1 \\le u_i,v_i \\le N,u_i \\neq v_i$）。每个奶牛无序对至多出现一次。 \n\n", "outputFormat": " 输出一行，包含形成的新的朋友关系的总数。不要计入初始时已经是朋友的奶牛对。 ", "hint": "### 样例 1 解释\n\n第 $1$ 天，三个新的朋友关系被建立：$(3,4)$，$(3,7)$ 和 $(4,7)$。\n\n第 $3$ 天，两个新的朋友关系被建立：$(4,5)$ 和 $(5,7)$。\n\n### 测试点性质\n\n - 测试点 $2-3$ 满足 $N \\le 500$。\n - 测试点 $4-7$ 满足 $N \\le 10^4$。\n - 测试点 $8-17$ 没有额外限制。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Making Friends P", "background": "", "description": "Among FJ's $N(2 \\le N \\le 2 \\times 10^5)$ cows numbered $1 \\cdots N$, there are initially $M(1 \\le M \\le 2 \\times 10^5)$ pairs of friends. The cows leave the farm one by one to go on vacation. On day $i$, cow $i$ leaves the farm, and at the same time, all of cow $i$'s friends that are still on the farm become friends with each other. How many new friendship relationships are created in total?", "inputFormat": "The first line contains $N$ and $M$.\n\nThe next $M$ lines each contain two integers $u_i$ and $v_i$, meaning cows $u_i$ and $v_i$ are friends ($1 \\le u_i,v_i \\le N, u_i \\neq v_i$). Each unordered pair of cows appears at most once.", "outputFormat": "Output one line containing the total number of new friendship relationships formed. Do not count pairs of cows that were already friends initially.", "hint": "### Explanation for Sample 1\n\nOn day $1$, three new friendship relationships are created: $(3,4)$, $(3,7)$, and $(4,7)$.\n\nOn day $3$, two new friendship relationships are created: $(4,5)$ and $(5,7)$.\n\n### Test Point Properties\n\n- Test points $2-3$ satisfy $N \\le 500$.\n- Test points $4-7$ satisfy $N \\le 10^4$.\n- Test points $8-17$ have no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Making Friends P", "background": "", "description": "FJ 的 $N(2 \\le N \\le 2 \\times 10^5)$ 头编号为 $1 \\cdots N$ 的奶牛之中初始时有 $M(1 \\le M \\le 2 \\times 10^5)$ 对朋友。奶牛们一头一头地离开农场去度假。第 $i$ 天，第 $i$ 头奶牛离开了农场，同时第 $i$ 头奶牛的所有仍在农场的朋友互相都成为了朋友。问总共建立了多少新的朋友关系？\n\n", "inputFormat": "输入的第一行包含 $N$ 和 $M$。\n\n以下 $M$ 行每行包含两个整数 $u_i$ 和 $v_i$，表示奶牛 $u_i$ 和 $v_i$ 是朋友（$1 \\le u_i,v_i \\le N,u_i \\neq v_i$）。每个奶牛无序对至多出现一次。 \n\n", "outputFormat": " 输出一行，包含形成的新的朋友关系的总数。不要计入初始时已经是朋友的奶牛对。 ", "hint": "### 样例 1 解释\n\n第 $1$ 天，三个新的朋友关系被建立：$(3,4)$，$(3,7)$ 和 $(4,7)$。\n\n第 $3$ 天，两个新的朋友关系被建立：$(4,5)$ 和 $(5,7)$。\n\n### 测试点性质\n\n - 测试点 $2-3$ 满足 $N \\le 500$。\n - 测试点 $4-7$ 满足 $N \\le 10^4$。\n - 测试点 $8-17$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P8908", "type": "P", "difficulty": 6, "samples": [["GHHGGHHGH", "12"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "USACO", "树状数组", "2022", "均摊分析"], "title": "[USACO22DEC] Palindromes P", "background": "", "description": "农夫约翰合牛国（The United Cows of Farmer John，UCFJ）正在参加一年一度的蹄球锦标赛！UCFJ 队的 $N(1 \\le N \\le 7500)$ 头奶牛以微弱优势击败了 Farmer Nhoj 的队伍，赢得了蹄球比赛的金牌。\n\n奶牛们已经为颁奖典礼排好了队。她们希望 FJ 拍摄 $\\dfrac{N(N+1)}{2}$ 张合影，为队伍的每个连续子段拍摄一张。\n\n然而，FJ，作为球队的主帅，对于奶牛们应该如何列队十分讲究。具体地说，他拒绝为一个子段拍照，除非它形成一个**回文串**，即对于所有不超过子段长度的正整数 $i$，从子段左端开始的第 $i$ 头奶牛的品种必须与从子段右端开始的第 $i$ \n头奶牛的品种相同。每头奶牛的品种是更赛牛（Guernsey）或荷斯坦牛（Holstein）之一。\n\n对于队伍的 $\\dfrac{N(N+1)}{2}$ 个连续子段的每一个，计算将该子段重新排列成回文串所需的最小换位次数（如果不可能这样做则为 $−1$）。单次换位是在子序列中取两头相邻的奶牛并交换。输出所有这些次数之和。\n\n注意对每个连续子段所需的换位次数是独立计算的（奶牛们会在照片拍摄之间返回她们的起始位置）。 ", "inputFormat": "输入队伍，用一个长为 $N$ 的字符 $\\texttt{G}$ 和 $\\texttt{H}$ 组成的字符串表示。 ", "outputFormat": "输出队伍的所有 $\\dfrac{N(N+1)}{2}$ 个连续子段的前述数量之和。 ", "hint": "### 样例 1 解释\n\n前四个连续子段是 $\\texttt{G}$，$\\texttt{GH}$，$\\texttt{GHH}$ 和 $\\texttt{GHHG}$。$\\texttt{G}$ 和 $\\texttt{GHHG}$ 都已经是回文串，因此它们对总和的贡献为 $0$。$\\texttt{GHH}$ 可以使用一次换位重新排列成回文串，因此它对总和的贡献为 $1$。$\\texttt{GH}$ 不能使用任意次数的换位重新排列成回文串，因此它对总和的贡献为 $−1$。\n\n$\\texttt{HHGG}$ 是另一个对总和有贡献的连续子段。这个子段可以使用两次换位重新排列成回文串。 \n\n### 测试点性质\n\n除样例外有十五个测试点，满足 $N \\in \\{ 100,200,500,1000,2000,5000,5000,5000,5000,5000,7500,7500,7500,7500,7500\\}$ 各一。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Palindromes P", "background": "", "description": "Farmer John’s United Cows of Farmer John (UCFJ) are competing in the annual hoofball tournament. UCFJ’s team of $N(1 \\le N \\le 7500)$ cows narrowly defeated Farmer Nhoj’s team and won the gold medal.\n\nThe cows have lined up for the award ceremony. They want FJ to take $\\dfrac{N(N+1)}{2}$ group photos, one for every contiguous subsegment of the team.\n\nHowever, as the coach, FJ is very picky about how the cows line up. In particular, he refuses to take a photo of a subsegment unless it forms a **palindrome**, meaning that for every positive integer $i$ not exceeding the length of the subsegment, the breed of the $i$-th cow from the left end must be the same as the breed of the $i$-th cow from the right end. Each cow’s breed is either Guernsey or Holstein.\n\nFor each of the team’s $\\dfrac{N(N+1)}{2}$ contiguous subsegments, compute the minimum number of swaps needed to rearrange that subsegment into a palindrome (or $-1$ if it is impossible). A single swap consists of taking two adjacent cows in the subsequence and swapping them. Output the sum of these values over all subsegments.\n\nNote that the number of swaps needed for each contiguous subsegment is computed independently (the cows return to their original positions between photos).", "inputFormat": "Input the team as a string of length $N$ consisting of the characters $\\texttt{G}$ and $\\texttt{H}$.", "outputFormat": "Output the sum of the quantities described above over all $\\dfrac{N(N+1)}{2}$ contiguous subsegments.", "hint": "### Sample 1 Explanation\n\nThe first four contiguous subsegments are $\\texttt{G}$, $\\texttt{GH}$, $\\texttt{GHH}$, and $\\texttt{GHHG}$. $\\texttt{G}$ and $\\texttt{GHHG}$ are already palindromes, so their contribution to the total is $0$. $\\texttt{GHH}$ can be rearranged into a palindrome using one swap, so its contribution to the total is $1$. $\\texttt{GH}$ cannot be rearranged into a palindrome using any number of swaps, so its contribution to the total is $-1$.\n\n$\\texttt{HHGG}$ is another contiguous subsegment that contributes to the total. This subsegment can be rearranged into a palindrome using two swaps.\n\n### Test Case Properties\n\nBesides the sample, there are fifteen test cases, one each with $N \\in \\{ 100,200,500,1000,2000,5000,5000,5000,5000,5000,7500,7500,7500,7500,7500\\}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Palindromes P", "background": "", "description": "农夫约翰合牛国（The United Cows of Farmer John，UCFJ）正在参加一年一度的蹄球锦标赛！UCFJ 队的 $N(1 \\le N \\le 7500)$ 头奶牛以微弱优势击败了 Farmer Nhoj 的队伍，赢得了蹄球比赛的金牌。\n\n奶牛们已经为颁奖典礼排好了队。她们希望 FJ 拍摄 $\\dfrac{N(N+1)}{2}$ 张合影，为队伍的每个连续子段拍摄一张。\n\n然而，FJ，作为球队的主帅，对于奶牛们应该如何列队十分讲究。具体地说，他拒绝为一个子段拍照，除非它形成一个**回文串**，即对于所有不超过子段长度的正整数 $i$，从子段左端开始的第 $i$ 头奶牛的品种必须与从子段右端开始的第 $i$ \n头奶牛的品种相同。每头奶牛的品种是更赛牛（Guernsey）或荷斯坦牛（Holstein）之一。\n\n对于队伍的 $\\dfrac{N(N+1)}{2}$ 个连续子段的每一个，计算将该子段重新排列成回文串所需的最小换位次数（如果不可能这样做则为 $−1$）。单次换位是在子序列中取两头相邻的奶牛并交换。输出所有这些次数之和。\n\n注意对每个连续子段所需的换位次数是独立计算的（奶牛们会在照片拍摄之间返回她们的起始位置）。 ", "inputFormat": "输入队伍，用一个长为 $N$ 的字符 $\\texttt{G}$ 和 $\\texttt{H}$ 组成的字符串表示。 ", "outputFormat": "输出队伍的所有 $\\dfrac{N(N+1)}{2}$ 个连续子段的前述数量之和。 ", "hint": "### 样例 1 解释\n\n前四个连续子段是 $\\texttt{G}$，$\\texttt{GH}$，$\\texttt{GHH}$ 和 $\\texttt{GHHG}$。$\\texttt{G}$ 和 $\\texttt{GHHG}$ 都已经是回文串，因此它们对总和的贡献为 $0$。$\\texttt{GHH}$ 可以使用一次换位重新排列成回文串，因此它对总和的贡献为 $1$。$\\texttt{GH}$ 不能使用任意次数的换位重新排列成回文串，因此它对总和的贡献为 $−1$。\n\n$\\texttt{HHGG}$ 是另一个对总和有贡献的连续子段。这个子段可以使用两次换位重新排列成回文串。 \n\n### 测试点性质\n\n除样例外有十五个测试点，满足 $N \\in \\{ 100,200,500,1000,2000,5000,5000,5000,5000,5000,7500,7500,7500,7500,7500\\}$ 各一。", "locale": "zh-CN"}}}
{"pid": "P8909", "type": "P", "difficulty": 3, "samples": [["5 1000000\n1 2 3 4 5", "0 266666 333335 266665 116668 16666"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化"], "title": "[RC-06] Multiples", "background": "", "description": "给出 $n$，以及一个长度为 $n$ 的数组 $a$，$a_1\\sim a_n$ 都是正整数，且 $a_i$ 在 $[1,10^9]$ 均匀随机生成。\n\n对每个 $0\\le k\\le n$ 计算 $[1,m]$ 中有几个正整数 $x$ 恰好是 $k$ 个 $a_i$ 的倍数（也就是恰好存在 $k$ 个 $1\\le i\\le n$，$a_i\\mid x$）。", "inputFormat": "第一行两个正整数 $n,m$。\n\n接下来一行 $n$ 个正整数 $a_1\\sim a_n$。", "outputFormat": "输出一行 $n+1$ 个整数，第 $i$ 个是 $k=i-1$ 的答案。", "hint": "本题没有部分分，只有 AC 才能得分。\n\n所有数据均满足：$1\\le n\\le 2500$，$1\\le m\\le 10^9$，$1\\le a_i\\le 10^9$，且 $a_i$ 在 $[1,10^9]$ 中均匀随机生成。\n\n**本题有 $6$ 组数据满足 $n=2500$，$2$ 组数据满足 $n\\le 10$，共 $8$ 组数据。**\n\n**所有数据都是如下方式生成：运行以下伪代码恰好一次生成，将其输出作为你的输入。**\n\n```\nfunction rnd(int l,int r):\n\nreturn [l,r] 之内的随机整数\n\nfunction main():\n\n输入本组数据的 n,m\n输出 n,m\n输出 n 个正整数，都是 rnd(1,10^9) 的返回值\n```\n\n如果你不理解上面的生成方式，也可以阅读对应的 C++ 代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n\tfreopen(\"in.txt\",\"w\",stdout);\n\tint n,m;\n\tcin>>n>>m;\n\tcout<<n<<' '<<m<<'\\n';\n\tmt19937_64 rng(time(0));\n\tconst int M=1e9;\n\tfor(int i=1;i<=n;i++)cout<<rng()%M+1<<' ';\n}\n```\n\n样例不满足 $a_i$ 在 $[1,10^9]$ 均匀随机生成，因此样例不是合法的输入数据。测试数据中不包含样例。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RC-06] Multiples", "background": "", "description": "给出 $n$，以及一个长度为 $n$ 的数组 $a$，$a_1\\sim a_n$ 都是正整数，且 $a_i$ 在 $[1,10^9]$ 均匀随机生成。\n\n对每个 $0\\le k\\le n$ 计算 $[1,m]$ 中有几个正整数 $x$ 恰好是 $k$ 个 $a_i$ 的倍数（也就是恰好存在 $k$ 个 $1\\le i\\le n$，$a_i\\mid x$）。", "inputFormat": "第一行两个正整数 $n,m$。\n\n接下来一行 $n$ 个正整数 $a_1\\sim a_n$。", "outputFormat": "输出一行 $n+1$ 个整数，第 $i$ 个是 $k=i-1$ 的答案。", "hint": "本题没有部分分，只有 AC 才能得分。\n\n所有数据均满足：$1\\le n\\le 2500$，$1\\le m\\le 10^9$，$1\\le a_i\\le 10^9$，且 $a_i$ 在 $[1,10^9]$ 中均匀随机生成。\n\n**本题有 $6$ 组数据满足 $n=2500$，$2$ 组数据满足 $n\\le 10$，共 $8$ 组数据。**\n\n**所有数据都是如下方式生成：运行以下伪代码恰好一次生成，将其输出作为你的输入。**\n\n```\nfunction rnd(int l,int r):\n\nreturn [l,r] 之内的随机整数\n\nfunction main():\n\n输入本组数据的 n,m\n输出 n,m\n输出 n 个正整数，都是 rnd(1,10^9) 的返回值\n```\n\n如果你不理解上面的生成方式，也可以阅读对应的 C++ 代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n\tfreopen(\"in.txt\",\"w\",stdout);\n\tint n,m;\n\tcin>>n>>m;\n\tcout<<n<<' '<<m<<'\\n';\n\tmt19937_64 rng(time(0));\n\tconst int M=1e9;\n\tfor(int i=1;i<=n;i++)cout<<rng()%M+1<<' ';\n}\n```\n\n样例不满足 $a_i$ 在 $[1,10^9]$ 均匀随机生成，因此样例不是合法的输入数据。测试数据中不包含样例。", "locale": "zh-CN"}}}
{"pid": "P8910", "type": "P", "difficulty": 3, "samples": [["2\n3 0\n2 1", "0\n3\n3 1\n1 2\n2 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["Special Judge", "O2优化"], "title": "[RC-06] Operation Sequence", "background": "", "description": "给出 $n$，以及一个长度为 $n+1$ 的数组 $[a_1,a_2,\\dots,a_{n+1}]$，初始时 $a_i=i\\ (1\\le i\\le n)$，$a_{n+1}=0$。\n\n你只能进行以下一种操作，通过输出特定字符串完成操作：\n\n- 输出 `i j` ：其中 $i,j$ 为正整数，要求 $1\\le i,j\\le n+1$，表示把 $a_i$ 赋值为 $a_j$。\n\n请把 $a$ 数组**的前 $n$ 位**向**右**循环移位 $K$ 位；即，在执行完毕你输出的所有操作后，要求 $a$ 数组第 $i\\ (1\\le i\\le K)$ 位等于 $n-K+i$；第 $i\\ (K+1\\le i\\le n)$ 位等于 $i-K$，第 $n+1$ 位任意。你只能进行至多 $T=\\lfloor1.5n\\rfloor$ 次赋值操作。\n\n如果你进行的操作数多于 $T$ 也可以获得部分分，具体地，设你的操作次数为 $S$：\n\n- 如果 $S\\le T$，得 $100$ 分。\n- 如果 $T<S\\le 4T$，得 $50$ 分。\n- 如果 $S>4T$，得 $0$ 分。\n\n你在本题的得分是所有测试点中所有数据里得分的最小值。", "inputFormat": "本题单个测试点内有多组数据。\n\n第一行是数据组数 $T$。\n\n对于每组数据：\n\n第一行两个正整数 $n,K$。", "outputFormat": "对于每组数据：\n\n在第一行输出操作数 $k\\ (0\\le k\\le 4T)$。**请注意，不需要最小化 $k$。**\n\n接下来 $k$ 行，每行输出两个正整数 $i,j$，表示一次操作。$(1\\le i,j\\le n+1)$", "hint": "所有数据均满足：$1\\le T\\le 10^4$，$1\\le n\\le 10^5$，$0\\le K\\le n-1$。保证同一个测试点中所有 $n$ 的和不超过 $5\\times 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RC-06] Operation Sequence", "background": "", "description": "给出 $n$，以及一个长度为 $n+1$ 的数组 $[a_1,a_2,\\dots,a_{n+1}]$，初始时 $a_i=i\\ (1\\le i\\le n)$，$a_{n+1}=0$。\n\n你只能进行以下一种操作，通过输出特定字符串完成操作：\n\n- 输出 `i j` ：其中 $i,j$ 为正整数，要求 $1\\le i,j\\le n+1$，表示把 $a_i$ 赋值为 $a_j$。\n\n请把 $a$ 数组**的前 $n$ 位**向**右**循环移位 $K$ 位；即，在执行完毕你输出的所有操作后，要求 $a$ 数组第 $i\\ (1\\le i\\le K)$ 位等于 $n-K+i$；第 $i\\ (K+1\\le i\\le n)$ 位等于 $i-K$，第 $n+1$ 位任意。你只能进行至多 $T=\\lfloor1.5n\\rfloor$ 次赋值操作。\n\n如果你进行的操作数多于 $T$ 也可以获得部分分，具体地，设你的操作次数为 $S$：\n\n- 如果 $S\\le T$，得 $100$ 分。\n- 如果 $T<S\\le 4T$，得 $50$ 分。\n- 如果 $S>4T$，得 $0$ 分。\n\n你在本题的得分是所有测试点中所有数据里得分的最小值。", "inputFormat": "本题单个测试点内有多组数据。\n\n第一行是数据组数 $T$。\n\n对于每组数据：\n\n第一行两个正整数 $n,K$。", "outputFormat": "对于每组数据：\n\n在第一行输出操作数 $k\\ (0\\le k\\le 4T)$。**请注意，不需要最小化 $k$。**\n\n接下来 $k$ 行，每行输出两个正整数 $i,j$，表示一次操作。$(1\\le i,j\\le n+1)$", "hint": "所有数据均满足：$1\\le T\\le 10^4$，$1\\le n\\le 10^5$，$0\\le K\\le n-1$。保证同一个测试点中所有 $n$ 的和不超过 $5\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P8911", "type": "P", "difficulty": 4, "samples": [["5 5\n2 4 1 3 5\n1 5 1145141919810", "24"], ["10 20000000\n1 3 4 10 5 5 2 7 10 7\n1 10 23333333333333333", "548722417"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化"], "title": "[RC-06] Minimum and Maximum", "background": "受洛谷限制，本题数据有所删减。评测全套数据请到 [InfOJ](http://119.27.163.117/contest/7/)。", "description": "给定长度为 $n$ 的序列 $[a_1,a_2,\\dots ,a_n]$。\n\n$m$ 次询问，每次给出四个正整数 $L_1,R_1,L_2,R_2\\ (1\\le L_1\\le R_1\\le 4000,1\\le L_2\\le R_2\\le 4000)$，问有多少个区间 $[l,r]\\ (1\\le l\\le r\\le n)$ 满足 $a_l,a_{l+1},\\dots,a_r$ 中的最大值属于 $[L_1,R_1]$、最小值属于 $[L_2,R_2]$。\n\n询问次数很大，所以询问是在程序内生成的。请自行阅读提示说明一栏的代码。", "inputFormat": "第一行两个正整数 $n,m$。\n\n接下来一行 $n$ 个正整数 $a_1\\sim a_n$。\n\n接下来一行三个正整数 $p,q,seed$，为数据生成器的参数。你不需要理解数据生成器具体的运行过程，你只需要知道，如果正确生成了询问的话，一定有 $L_1,R_1,L_2,R_2\\in [p,q]$。", "outputFormat": "设第 $i$ 个询问的答案为 $ans_i$。输出一行一个整数，为 $\\operatorname{xor}_{i=1}^m \n(i\\times ans_i)$ 的值。", "hint": "**样例 1 解释**\n\n五次询问的 $(L_1,R_1,L_2,R_2)$ 分别为 $(1,5,1,5),(1,2,2,4),(3,4,2,2),(2,4,2,2),(2,5,2,5)$，答案分别为 $15,1,1,2,6$。\n\n输出 $(1\\times 15)\\ \\mathrm{xor}\\ (2\\times 1)\\ \\mathrm{xor}\\ (3\\times 1)\\ \\mathrm{xor}\\ (4\\times 2)\\ \\mathrm{xor}\\ (5\\times 6)=24$。\n\n**样例程序**\n\n下面是我们提供的样例程序，你可以直接以其为基础编写你的程序。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nnamespace Generator{\ntypedef unsigned long long ull;\ntypedef __uint128_t L;\null seed;\nint p,q;\nstruct FastMod {\n    ull b, m;\n    FastMod(ull b) : b(b), m(ull((L(1) << 64) / b)) {}\n    ull reduce(ull a) {\n        ull q = (ull)((L(m) * a) >> 64);\n        ull r = a - q * b; // can be proven that 0 <= r < 2*b\n        return r >= b ? r - b : r;\n    }\n}F(2);\nvoid init(){\n\tcin>>p>>q>>seed;//读入 p,q,seed \n\tassert(p!=q);\n\tF=FastMod(q-p+1);\n}\nunsigned long long rd () {\n\tseed ^= (seed << 13);\n\tseed ^= (seed >> 7);\n\tseed ^= (seed << 17);\n\treturn seed;\n}\nvoid getlr(int &l1,int &r1,int &l2,int &r2){\n\t//将 l1,r1,l2,r2 作为参数传入，即可得到一组询问 \n\tl1=F.reduce(rd())+p;\n\tr1=F.reduce(rd())+p;\n\tl2=F.reduce(rd())+p;\n\tr2=F.reduce(rd())+p;\n\tif(l1>r1)swap(l1,r1);\n\tif(l2>r2)swap(l2,r2);\n}\n\n}\nint n,m,a[100005];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tGenerator::init();\n\tlong long xorsum=0;\n\tfor(int i=1,l1,r1,l2,r2;i<=m;i++){\n\t\tGenerator::getlr(l1,r1,l2,r2);\n\t\tlong long ans=/*ans保存你的答案*/;\n\t\txorsum^=ans*i;\n\t}\n\tcout<<xorsum;\n}\n```\n\n**数据范围**\n\n本题有四个子任务。子任务一时间限制 $0.5$ 秒，其它子任务时间限制 $5$ 秒。\n\n所有数据均满足：$1\\le n\\le 10^5$，$1\\le m\\le 2\\times 10^7$，$1\\le a_i\\le 4000$，$1\\le p\\lt q\\le 4000$，$0\\le seed\\lt 2^{64}$。\n\n- 子任务 $1$（$5$ 分）：$n,m,a_i,q\\le 10$。\n- 子任务 $2$（$20$ 分）：$n\\le 10^4$。\n- 子任务 $3$（$20$ 分）：$a_i,q\\le 10$。\n- 子任务 $4$（$55$ 分）：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RC-06] Minimum and Maximum", "background": "受洛谷限制，本题数据有所删减。评测全套数据请到 [InfOJ](http://119.27.163.117/contest/7/)。", "description": "给定长度为 $n$ 的序列 $[a_1,a_2,\\dots ,a_n]$。\n\n$m$ 次询问，每次给出四个正整数 $L_1,R_1,L_2,R_2\\ (1\\le L_1\\le R_1\\le 4000,1\\le L_2\\le R_2\\le 4000)$，问有多少个区间 $[l,r]\\ (1\\le l\\le r\\le n)$ 满足 $a_l,a_{l+1},\\dots,a_r$ 中的最大值属于 $[L_1,R_1]$、最小值属于 $[L_2,R_2]$。\n\n询问次数很大，所以询问是在程序内生成的。请自行阅读提示说明一栏的代码。", "inputFormat": "第一行两个正整数 $n,m$。\n\n接下来一行 $n$ 个正整数 $a_1\\sim a_n$。\n\n接下来一行三个正整数 $p,q,seed$，为数据生成器的参数。你不需要理解数据生成器具体的运行过程，你只需要知道，如果正确生成了询问的话，一定有 $L_1,R_1,L_2,R_2\\in [p,q]$。", "outputFormat": "设第 $i$ 个询问的答案为 $ans_i$。输出一行一个整数，为 $\\operatorname{xor}_{i=1}^m \n(i\\times ans_i)$ 的值。", "hint": "**样例 1 解释**\n\n五次询问的 $(L_1,R_1,L_2,R_2)$ 分别为 $(1,5,1,5),(1,2,2,4),(3,4,2,2),(2,4,2,2),(2,5,2,5)$，答案分别为 $15,1,1,2,6$。\n\n输出 $(1\\times 15)\\ \\mathrm{xor}\\ (2\\times 1)\\ \\mathrm{xor}\\ (3\\times 1)\\ \\mathrm{xor}\\ (4\\times 2)\\ \\mathrm{xor}\\ (5\\times 6)=24$。\n\n**样例程序**\n\n下面是我们提供的样例程序，你可以直接以其为基础编写你的程序。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nnamespace Generator{\ntypedef unsigned long long ull;\ntypedef __uint128_t L;\null seed;\nint p,q;\nstruct FastMod {\n    ull b, m;\n    FastMod(ull b) : b(b), m(ull((L(1) << 64) / b)) {}\n    ull reduce(ull a) {\n        ull q = (ull)((L(m) * a) >> 64);\n        ull r = a - q * b; // can be proven that 0 <= r < 2*b\n        return r >= b ? r - b : r;\n    }\n}F(2);\nvoid init(){\n\tcin>>p>>q>>seed;//读入 p,q,seed \n\tassert(p!=q);\n\tF=FastMod(q-p+1);\n}\nunsigned long long rd () {\n\tseed ^= (seed << 13);\n\tseed ^= (seed >> 7);\n\tseed ^= (seed << 17);\n\treturn seed;\n}\nvoid getlr(int &l1,int &r1,int &l2,int &r2){\n\t//将 l1,r1,l2,r2 作为参数传入，即可得到一组询问 \n\tl1=F.reduce(rd())+p;\n\tr1=F.reduce(rd())+p;\n\tl2=F.reduce(rd())+p;\n\tr2=F.reduce(rd())+p;\n\tif(l1>r1)swap(l1,r1);\n\tif(l2>r2)swap(l2,r2);\n}\n\n}\nint n,m,a[100005];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tGenerator::init();\n\tlong long xorsum=0;\n\tfor(int i=1,l1,r1,l2,r2;i<=m;i++){\n\t\tGenerator::getlr(l1,r1,l2,r2);\n\t\tlong long ans=/*ans保存你的答案*/;\n\t\txorsum^=ans*i;\n\t}\n\tcout<<xorsum;\n}\n```\n\n**数据范围**\n\n本题有四个子任务。子任务一时间限制 $0.5$ 秒，其它子任务时间限制 $5$ 秒。\n\n所有数据均满足：$1\\le n\\le 10^5$，$1\\le m\\le 2\\times 10^7$，$1\\le a_i\\le 4000$，$1\\le p\\lt q\\le 4000$，$0\\le seed\\lt 2^{64}$。\n\n- 子任务 $1$（$5$ 分）：$n,m,a_i,q\\le 10$。\n- 子任务 $2$（$20$ 分）：$n\\le 10^4$。\n- 子任务 $3$（$20$ 分）：$a_i,q\\le 10$。\n- 子任务 $4$（$55$ 分）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P8912", "type": "P", "difficulty": 4, "samples": [["5\n2 3 3 4 5", "3"], ["10\n1 1 2 2 3 3 4 4 5 8", "25"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化"], "title": "[RC-06] ijk", "background": "", "description": "给定一个序列 $[a_1,a_2,a_3,\\dots,a_n]$，保证 $\\forall i\\in [2,n], a_i\\ge a_{i-1}$。\n\n计算有多少整数三元组 $(i,j,k)$ 满足：\n\n- $1\\le i,j,k\\le n$。\n- $a_i\\times j\\times a_k=i+a_j+k$。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个正整数 $a_1,a_2,\\dots,a_n$。保证 $a_i\\ge a_{i-1}$。", "outputFormat": "输出一行一个非负整数，为答案。", "hint": "本题有三个子任务。\n\n所有数据均满足：$1\\le n\\le 10^6$，$1\\le a_i\\le 10^6$，$a_i\\ge a_{i-1}$。\n\n- 子任务 $1$（$5$ 分）：$n\\le 500$。\n- 子任务 $2$（$5$ 分）：$a_i\\le 10 $。\n- 子任务 $3$（$90$ 分）：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RC-06] ijk", "background": "", "description": "给定一个序列 $[a_1,a_2,a_3,\\dots,a_n]$，保证 $\\forall i\\in [2,n], a_i\\ge a_{i-1}$。\n\n计算有多少整数三元组 $(i,j,k)$ 满足：\n\n- $1\\le i,j,k\\le n$。\n- $a_i\\times j\\times a_k=i+a_j+k$。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个正整数 $a_1,a_2,\\dots,a_n$。保证 $a_i\\ge a_{i-1}$。", "outputFormat": "输出一行一个非负整数，为答案。", "hint": "本题有三个子任务。\n\n所有数据均满足：$1\\le n\\le 10^6$，$1\\le a_i\\le 10^6$，$a_i\\ge a_{i-1}$。\n\n- 子任务 $1$（$5$ 分）：$n\\le 500$。\n- 子任务 $2$（$5$ 分）：$a_i\\le 10 $。\n- 子任务 $3$（$90$ 分）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P8913", "type": "P", "difficulty": 4, "samples": [["6 3\n2\n4\n6", "8\n1 1 1 1 1 1 1 1\n++-+-++-\n++-++++-\n++-+++++"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288]}, "tags": ["Special Judge", "O2优化"], "title": "[RC-06] Remake", "background": "", "description": "请你构造 $n$ 个正整数 $a_1\\sim a_n$ 满足：\n\n- $\\forall X\\in [L,R]$ 且 $X$ 是偶数，$\\exists b_1\\sim b_n$，使得 $\\forall 1\\le i\\le n,b_i\\in \\{-1,1\\}$ 且 $\\sum _{1\\le i\\le n} a_ib_i=X$。$L,R$ 的值见数据范围。\n- 设 $cnt_i$ 为满足 $a_j=i$ 的 $j$ 的个数，则 $cnt_i$ 要么等于 $0$，要么大于等于 $2$。\n- $1\\le n\\le 40$。\n\n为了验证你的 $a_i$ 确实满足条件，会给出 $Q$ 组询问，每次询问偶数 $X \\in [L,R]$，请你输出一组合法的 $b_i$。", "inputFormat": "第一行两个正整数 $M,Q$，$M$ 表示 $X$ 的上界。在测试数据中，保证 $M=10^9$。\n\n接下来 $Q$ 行，每行一个正偶数 $X$。保证 $X\\in [L,R]$。\n\n注意 $L,R$ 并不会在输入中给出，你可以认为 $L=\\min X,R=\\max X$。", "outputFormat": "第一行输出你构造的正整数个数 $n$。$(1\\le n\\le 40)$\n\n接下来一行 $n$ 个正整数 $a_1\\sim a_n$。$(1\\le a_i\\le 10^9)$\n\n接下来 $Q$ 行，每行 $n$ 个字符，每个字符是 `+` 或 `-`。设第 $i$ 个字符为 $s_i$，设本次询问的值为 $X$，则需要满足 $\\sum _{1\\le i\\le n} a_i([s_i=$ `+` $]-[s_i=$ `-` $])=X$，其中 $[P]$ 在 $P$ 成立时等于 $1$，否则等于 $0$。\n\n你输出的 $a_i$ 需要满足题面中的要求。", "hint": "本题有三个子任务。\n\n所有数据均满足：$2\\le M\\le 10^9$，$1\\le Q\\le 10^5$，$X\\in [L,R]$。\n\n- 子任务 $1$（$25$ 分）：$L=2$，$R=2\\times 10^5$。\n- 子任务 $2$（$5$ 分）：$L=10^9-2\\times 10^5+2$，$R=10^9$。\n- 子任务 $3$（$70$ 分）：$L=2$，$R=M$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RC-06] Remake", "background": "", "description": "请你构造 $n$ 个正整数 $a_1\\sim a_n$ 满足：\n\n- $\\forall X\\in [L,R]$ 且 $X$ 是偶数，$\\exists b_1\\sim b_n$，使得 $\\forall 1\\le i\\le n,b_i\\in \\{-1,1\\}$ 且 $\\sum _{1\\le i\\le n} a_ib_i=X$。$L,R$ 的值见数据范围。\n- 设 $cnt_i$ 为满足 $a_j=i$ 的 $j$ 的个数，则 $cnt_i$ 要么等于 $0$，要么大于等于 $2$。\n- $1\\le n\\le 40$。\n\n为了验证你的 $a_i$ 确实满足条件，会给出 $Q$ 组询问，每次询问偶数 $X \\in [L,R]$，请你输出一组合法的 $b_i$。", "inputFormat": "第一行两个正整数 $M,Q$，$M$ 表示 $X$ 的上界。在测试数据中，保证 $M=10^9$。\n\n接下来 $Q$ 行，每行一个正偶数 $X$。保证 $X\\in [L,R]$。\n\n注意 $L,R$ 并不会在输入中给出，你可以认为 $L=\\min X,R=\\max X$。", "outputFormat": "第一行输出你构造的正整数个数 $n$。$(1\\le n\\le 40)$\n\n接下来一行 $n$ 个正整数 $a_1\\sim a_n$。$(1\\le a_i\\le 10^9)$\n\n接下来 $Q$ 行，每行 $n$ 个字符，每个字符是 `+` 或 `-`。设第 $i$ 个字符为 $s_i$，设本次询问的值为 $X$，则需要满足 $\\sum _{1\\le i\\le n} a_i([s_i=$ `+` $]-[s_i=$ `-` $])=X$，其中 $[P]$ 在 $P$ 成立时等于 $1$，否则等于 $0$。\n\n你输出的 $a_i$ 需要满足题面中的要求。", "hint": "本题有三个子任务。\n\n所有数据均满足：$2\\le M\\le 10^9$，$1\\le Q\\le 10^5$，$X\\in [L,R]$。\n\n- 子任务 $1$（$25$ 分）：$L=2$，$R=2\\times 10^5$。\n- 子任务 $2$（$5$ 分）：$L=10^9-2\\times 10^5+2$，$R=10^9$。\n- 子任务 $3$（$70$ 分）：$L=2$，$R=M$。", "locale": "zh-CN"}}}
{"pid": "P8914", "type": "P", "difficulty": 4, "samples": [["4 3 1 2 3\n1 3 1\n2 4 2\n4 3 1", "YES\n1.5"], ["4 3 1 2 3\n1 3 2\n2 4 2\n4 3 1", "NO\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "最短路"], "title": "[DMOI-R2] 梦境", "background": "小 A 做噩梦了。", "description": "小 A 的梦境可以看做有 $n$ 个点，$m$ 条边的无向图。小 A 在图上的点 $S$，有一个怪物在点 $B$，安全屋在点 $F$。\n\n怪物正在追杀小 A，现在小 A 需要逃到安全屋。小 A 意识到这是在自己的梦境里，所以他在一定程度上操控了梦境。他把怪物的移动速度设置成了 $3$，但代价是自己的移动速度被设置成 $2$。\n\n小 A 始终会沿着到 $F$ 的最短路走，如果有多条最短路，则小 A 会选择使得**经过点的编号所顺次构成序列的字典序最小**的那条最短路，因为他觉得这样走最不容易被怪物抓到。\n\n而怪物在梦境中游荡，会随机向自身周围的点移动，且怪物已经访问过的点不会重复访问。\n\n现在小 A 需要知道**在最坏情况下**他能否安全到达安全屋，或者何时被怪物抓住。", "inputFormat": "第一行五个整数 $n,m,S,B,F$。\n\n接下来 $m$ 行，第 $i$ 行三个整数 $u_i,v_i,w_i$，代表 $u_i,v_i$ 之间有一条长度为 $w_i$ 的无向边。", "outputFormat": "两行。\n\n如果小 A **在最坏情况下**能够安全到达安全屋，输出 `YES`，接下来一行输出小 A 到达安全屋后怪物到安全屋的距离。\n\n如果小 A **在最坏情况下**不能安全到达安全屋，输出 `NO`，接下来一行输出小 A 在何时被怪物抓到。\n\n若第二行的答案为整数则输出整数，**否则输出小数**。", "hint": "**关于最坏情况的解释**：怪物的走法可能有多种。也就是说，你需要同时考虑怪物的每种走法，只要怪物的某种最短路走法可以抓到小 A 时答案即为 `NO`。而最坏情况是指怪物的走法在所有走法中能够最快抓到（或接近）小 A 的情况。\n\n另外本题没有 special judge，也就是说如果答案是整数，你需要严格输出整数答案，不带小数点。同时数据保证不存在小数位数超过两位的答案。\n\n### 数据范围\n\n本题采用捆绑测试。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{c|c|c|c|c}\\hline \n\\textbf{~~Subtask~~}&\\bm{~~n \\le ~~}&\\bm{~~~~m \\le~~~~}& ~\\textbf{~~特殊性质~~}~&\\textbf{~~分值~~}\\cr\\hline \n0\t&10\t\t\t&20\t\t\t&\t\t&10\\cr\\hline \n1\t&500\t\t&1000\t\t&\t\t&10\\cr\\hline \n2\t&800 \t\t&2000\t\t&\t\t&10\\cr\\hline \n3\t&2\\times10^5&  \t\t\t&\\text{A+B}&15\t\\cr\\hline \n4\t&2\\times10^5& \t\t\t&\\text{A}&15\t\\cr\\hline\n5\t&10^5\t\t&2\\times10^5&\t\t&20\\cr\\hline\n6\t&2\\times10^5&2\\times10^5&\t\t&20\n\\end{array}\n$$\n\n特殊性质 $\\text{A}$：$m=n-1$。\n\n特殊性质 $\\text{B}$：对于给定的每个 $v_i$，满足 $v_i=u_i+1$。\n\n对于 $100\\%$ 的数据，保证 $S \\ne B \\ne F$ 且 $1 \\le S,B,F \\le n$，$1 \\le w_i \\le 10^3$，图连通且不存在重边。\n\n### 特殊评分方式\n本题开启子任务依赖，具体如下：\n- 对于子任务 $i\\in\\{0,3\\}$，您只需答对子任务 $i$ 即可获得子任务 $i$ 的分数。\n- 对于子任务 $4$，您需要答对子任务 $3$ 才能获得子任务 $4$ 的分数。\n- 对于子任务 $i\\in\\{1,2,5,6\\}$，您需要答对子任务 $0$ 才能获得子任务 $i$ 的分数。\n\n### 附件说明\n对于赛时许多选手卡在了 sub3，此处提供一组 sub3 内的数据用于检查并改正代码。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[DMOI-R2] 梦境", "background": "小 A 做噩梦了。", "description": "小 A 的梦境可以看做有 $n$ 个点，$m$ 条边的无向图。小 A 在图上的点 $S$，有一个怪物在点 $B$，安全屋在点 $F$。\n\n怪物正在追杀小 A，现在小 A 需要逃到安全屋。小 A 意识到这是在自己的梦境里，所以他在一定程度上操控了梦境。他把怪物的移动速度设置成了 $3$，但代价是自己的移动速度被设置成 $2$。\n\n小 A 始终会沿着到 $F$ 的最短路走，如果有多条最短路，则小 A 会选择使得**经过点的编号所顺次构成序列的字典序最小**的那条最短路，因为他觉得这样走最不容易被怪物抓到。\n\n而怪物在梦境中游荡，会随机向自身周围的点移动，且怪物已经访问过的点不会重复访问。\n\n现在小 A 需要知道**在最坏情况下**他能否安全到达安全屋，或者何时被怪物抓住。", "inputFormat": "第一行五个整数 $n,m,S,B,F$。\n\n接下来 $m$ 行，第 $i$ 行三个整数 $u_i,v_i,w_i$，代表 $u_i,v_i$ 之间有一条长度为 $w_i$ 的无向边。", "outputFormat": "两行。\n\n如果小 A **在最坏情况下**能够安全到达安全屋，输出 `YES`，接下来一行输出小 A 到达安全屋后怪物到安全屋的距离。\n\n如果小 A **在最坏情况下**不能安全到达安全屋，输出 `NO`，接下来一行输出小 A 在何时被怪物抓到。\n\n若第二行的答案为整数则输出整数，**否则输出小数**。", "hint": "**关于最坏情况的解释**：怪物的走法可能有多种。也就是说，你需要同时考虑怪物的每种走法，只要怪物的某种最短路走法可以抓到小 A 时答案即为 `NO`。而最坏情况是指怪物的走法在所有走法中能够最快抓到（或接近）小 A 的情况。\n\n另外本题没有 special judge，也就是说如果答案是整数，你需要严格输出整数答案，不带小数点。同时数据保证不存在小数位数超过两位的答案。\n\n### 数据范围\n\n本题采用捆绑测试。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{c|c|c|c|c}\\hline \n\\textbf{~~Subtask~~}&\\bm{~~n \\le ~~}&\\bm{~~~~m \\le~~~~}& ~\\textbf{~~特殊性质~~}~&\\textbf{~~分值~~}\\cr\\hline \n0\t&10\t\t\t&20\t\t\t&\t\t&10\\cr\\hline \n1\t&500\t\t&1000\t\t&\t\t&10\\cr\\hline \n2\t&800 \t\t&2000\t\t&\t\t&10\\cr\\hline \n3\t&2\\times10^5&  \t\t\t&\\text{A+B}&15\t\\cr\\hline \n4\t&2\\times10^5& \t\t\t&\\text{A}&15\t\\cr\\hline\n5\t&10^5\t\t&2\\times10^5&\t\t&20\\cr\\hline\n6\t&2\\times10^5&2\\times10^5&\t\t&20\n\\end{array}\n$$\n\n特殊性质 $\\text{A}$：$m=n-1$。\n\n特殊性质 $\\text{B}$：对于给定的每个 $v_i$，满足 $v_i=u_i+1$。\n\n对于 $100\\%$ 的数据，保证 $S \\ne B \\ne F$ 且 $1 \\le S,B,F \\le n$，$1 \\le w_i \\le 10^3$，图连通且不存在重边。\n\n### 特殊评分方式\n本题开启子任务依赖，具体如下：\n- 对于子任务 $i\\in\\{0,3\\}$，您只需答对子任务 $i$ 即可获得子任务 $i$ 的分数。\n- 对于子任务 $4$，您需要答对子任务 $3$ 才能获得子任务 $4$ 的分数。\n- 对于子任务 $i\\in\\{1,2,5,6\\}$，您需要答对子任务 $0$ 才能获得子任务 $i$ 的分数。\n\n### 附件说明\n对于赛时许多选手卡在了 sub3，此处提供一组 sub3 内的数据用于检查并改正代码。", "locale": "zh-CN"}}}
{"pid": "P8915", "type": "P", "difficulty": 6, "samples": [["5\n4 3 2 0\n5 7 3 0\n2 2 3 0\n1 8 2 0\n19 13 3 0", "49\n4773\n0\n21\n2369219"], ["10\n4329 12935 3 0\n125891 5949823 2 0\n95023489 15327384 3 0\n28592394 32891538 2 0\n5894392 52374853 2 0\n58963495 32591238 3 0\n438291538 42819324 3 0\n58493683 234728 2 0\n284952 823499 3 0\n528394298 25892948 3 0", "468372138\n510295355\n536959469\n56564283\n462091483\n842203294\n778629925\n806214146\n91259493\n793676806"], ["10\n55888076 506356561 3 3\n48940088 192152177\n33004718 365781091\n45088097 31400730\n65004621 206038505 2 3\n50919157 24882066\n50919158 24882064\n50919156 24882067\n249418509 7616530 2 1\n205309921 4639136\n164784593 419325145 3 4\n105814446 200482317\n105814449 200482315\n105814443 200482315\n79723922 206425705\n477366546 180501076 3 4\n39819749 14485585\n39819746 14485582\n39819743 14485588\n39819748 14485585\n84215455 29656489 3 0\n524291275 23244413 3 4\n8149961 10903189\n8149958 10903192\n8149958 10903193\n8149961 10903191\n584987873 823324694 3 1\n540008401 27919189\n25681672 419244427 2 4\n4753299 108169462\n4753301 108169463\n4753298 108169462\n4753298 108169464\n313195991 98402123 3 3\n7016773 83186671\n7016770 83186674\n7016767 83186675", "580170965\n521412840\n890711205\n353426094\n41995284\n193113183\n352219667\n748854206\n767819374\n351309432"], ["10\n2 4 2 4\n1 1\n1 3\n2 1\n2 4\n2 4 3 3\n1 2\n2 3\n1 4\n1 1 3 0\n3 4 2 0\n3 2 2 1\n1 2\n4 2 3 0\n2 3 2 0\n5 4 3 3\n2 4\n1 3\n1 1\n4 5 2 2\n1 4\n2 1\n3 1 2 0", "4\n5\n0\n49\n5\n12\n8\n385\n128\n1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["O2优化", "组合数学", "容斥原理"], "title": "[DMOI-R2] 回到过去", "background": " > 想回到过去\\\n试着抱你在怀里\\\n羞怯的脸带有一点稚气\\\n想看你看的世界\\\n想在你梦的画面\\\n只要靠在一起就能感觉甜蜜\\\n想回到过去\\\n试着让故事继续\\\n至少不再让你离我而去\\\n分散时间的注意\\\n这次会抱得更紧\\\n这样挽留不知还来不来得及\\\n想回到过去\\\n沉默支撑跃过陌生\\\n静静看着凌晨黄昏\\\n你的身影 失去平衡\\\n慢慢下沉\\\n想回到过去\\\n—— 周杰伦《[回到过去](https://www.bilibili.com/video/BV1fx411N7bU?p=32&vd_source=2f4592e5507d6452d7d44dc098844d6b)》\n>\n\n什么阻碍着两颗心的碰面？什么阻碍着两个人的相见？\n\n或许是令人捉摸不透的时间吧。", "description": "给出 $n,m,t$ 以及 $t$ 个障碍物坐标，求在 $n$ 行 $m$ 列的矩阵中的非障碍位置上放置 $k$ 个两两之间没有公共边的方格的方案有多少种，答案对 $10^9+7$ 取模。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示测试点数量。\n\n接下来 $T$ 个测试点，每个测试点的第一行四个整数 $n,m,k,t$。接下来 $t$ 行，每行两个整数 $x_i,y_i$，表示第 $i$ 个障碍物的坐标（保证不重叠）。", "outputFormat": "共 $T$ 行，每行一个整数表示当前询问的答案。", "hint": "#### 【样例解释 #4】\n\n对于测试点 1，可以画出如下的图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9ld7rcxr.png)\n\n其中用黑色格子表示障碍物，可发现只有 $\\{(1,2)(1,4)\\}\\{(1,2)(2,3)\\}\\{(2,2)(1,4)\\}\\{(2,3)(1,4)\\}$ 四种方案满足题意。\n\n对于测试点 2，可以画出如下的图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/74rbxvs6.png)\n\n可发现只有 $\\{(1,1)(1,3)(2,2)\\}\\{(1,1)(1,3)(2,4)\\}\\{(1,1)(2,2)(2,4)\\}\\{(1,3)(2,1)(2,4)\\}\\{(1,3)(2,2)(2,4)\\}$ 五种情况符合题意。\n\n### 数据点约定\n\n|  数据点编号  |    $n$     |    $m$     |       $k$       |         $t$         |\n| :----------: | :--------: | :--------: | :-------------: | :-----------------: |\n|     $1$      |    $=1$    | $\\le 10^9$ |      $=2$       |        $=0$         |\n|     $2$      |    $=1$    | $\\le 10^9$ |      $=3$       |        $=0$         |\n|     $3$      |  $\\le 20$  |  $\\le 20$  |      $=2$       |        $=0$         |\n|     $4$      |  $\\le 20$  |  $\\le 20$  |      $=3$       |        $=0$         |\n|     $5$      |  $\\le 20$  |  $\\le 20$  |      $=2$       |      $\\le 400$      |\n|     $6$      |  $\\le 20$  |  $\\le 20$  |      $=3$       |      $\\le 400$      |\n|    $7,8$     | $\\le 1000$ | $\\le 1000$ |      $=2$       |        $=0$         |\n|    $9,10$    | $\\le 1000$ | $\\le 1000$ |      $=3$       |        $=0$         |\n|     $11$     | $\\le 1000$ | $\\le 1000$ |      $=2$       |      $\\le 10$       |\n|     $12$     | $\\le 1000$ | $\\le 1000$ |      $=3$       |      $\\le 10$       |\n|   $13,14$    | $\\le 10^9$ |    $=n$    |      $=2$       |        $=0$         |\n|   $15,16$    | $\\le 10^9$ |    $=n$    |      $=3$       |        $=0$         |\n|   $17,18$    | $\\le 10^9$ | $\\le 10^9$ |      $=2$       |        $=0$         |\n|   $19,20$    | $\\le 10^9$ | $\\le 10^9$ |      $=3$       |        $=0$         |\n|   $21,22$    | $\\le 10^9$ | $\\le 10^9$ |      $=2$       | $\\le 2 \\times 10^4$ |\n|   $23,24$    | $\\le 10^9$ | $\\le 10^9$ |      $=3$       | $\\le 2 \\times 10^4$ |\n| $25$ | $\\le 10^9$ | $\\le 10^9$ | $2 \\le k \\le 3$ | $\\le 2 \\times 10^4$ |\n\n对于 $100\\%$ 的数据，$1 \\le n,m \\le 10^9$，$2 \\le k \\le 3$，$0 \\le t \\le \\min(n\\cdot m,2 \\times 10^4)$，$1 \\le x_i \\le n$，$1 \\le y_i \\le m$，$1 \\le T \\le 10$。每个数据点等分值。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[DMOI-R2] 回到过去", "background": " > 想回到过去\\\n试着抱你在怀里\\\n羞怯的脸带有一点稚气\\\n想看你看的世界\\\n想在你梦的画面\\\n只要靠在一起就能感觉甜蜜\\\n想回到过去\\\n试着让故事继续\\\n至少不再让你离我而去\\\n分散时间的注意\\\n这次会抱得更紧\\\n这样挽留不知还来不来得及\\\n想回到过去\\\n沉默支撑跃过陌生\\\n静静看着凌晨黄昏\\\n你的身影 失去平衡\\\n慢慢下沉\\\n想回到过去\\\n—— 周杰伦《[回到过去](https://www.bilibili.com/video/BV1fx411N7bU?p=32&vd_source=2f4592e5507d6452d7d44dc098844d6b)》\n>\n\n什么阻碍着两颗心的碰面？什么阻碍着两个人的相见？\n\n或许是令人捉摸不透的时间吧。", "description": "给出 $n,m,t$ 以及 $t$ 个障碍物坐标，求在 $n$ 行 $m$ 列的矩阵中的非障碍位置上放置 $k$ 个两两之间没有公共边的方格的方案有多少种，答案对 $10^9+7$ 取模。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示测试点数量。\n\n接下来 $T$ 个测试点，每个测试点的第一行四个整数 $n,m,k,t$。接下来 $t$ 行，每行两个整数 $x_i,y_i$，表示第 $i$ 个障碍物的坐标（保证不重叠）。", "outputFormat": "共 $T$ 行，每行一个整数表示当前询问的答案。", "hint": "#### 【样例解释 #4】\n\n对于测试点 1，可以画出如下的图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9ld7rcxr.png)\n\n其中用黑色格子表示障碍物，可发现只有 $\\{(1,2)(1,4)\\}\\{(1,2)(2,3)\\}\\{(2,2)(1,4)\\}\\{(2,3)(1,4)\\}$ 四种方案满足题意。\n\n对于测试点 2，可以画出如下的图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/74rbxvs6.png)\n\n可发现只有 $\\{(1,1)(1,3)(2,2)\\}\\{(1,1)(1,3)(2,4)\\}\\{(1,1)(2,2)(2,4)\\}\\{(1,3)(2,1)(2,4)\\}\\{(1,3)(2,2)(2,4)\\}$ 五种情况符合题意。\n\n### 数据点约定\n\n|  数据点编号  |    $n$     |    $m$     |       $k$       |         $t$         |\n| :----------: | :--------: | :--------: | :-------------: | :-----------------: |\n|     $1$      |    $=1$    | $\\le 10^9$ |      $=2$       |        $=0$         |\n|     $2$      |    $=1$    | $\\le 10^9$ |      $=3$       |        $=0$         |\n|     $3$      |  $\\le 20$  |  $\\le 20$  |      $=2$       |        $=0$         |\n|     $4$      |  $\\le 20$  |  $\\le 20$  |      $=3$       |        $=0$         |\n|     $5$      |  $\\le 20$  |  $\\le 20$  |      $=2$       |      $\\le 400$      |\n|     $6$      |  $\\le 20$  |  $\\le 20$  |      $=3$       |      $\\le 400$      |\n|    $7,8$     | $\\le 1000$ | $\\le 1000$ |      $=2$       |        $=0$         |\n|    $9,10$    | $\\le 1000$ | $\\le 1000$ |      $=3$       |        $=0$         |\n|     $11$     | $\\le 1000$ | $\\le 1000$ |      $=2$       |      $\\le 10$       |\n|     $12$     | $\\le 1000$ | $\\le 1000$ |      $=3$       |      $\\le 10$       |\n|   $13,14$    | $\\le 10^9$ |    $=n$    |      $=2$       |        $=0$         |\n|   $15,16$    | $\\le 10^9$ |    $=n$    |      $=3$       |        $=0$         |\n|   $17,18$    | $\\le 10^9$ | $\\le 10^9$ |      $=2$       |        $=0$         |\n|   $19,20$    | $\\le 10^9$ | $\\le 10^9$ |      $=3$       |        $=0$         |\n|   $21,22$    | $\\le 10^9$ | $\\le 10^9$ |      $=2$       | $\\le 2 \\times 10^4$ |\n|   $23,24$    | $\\le 10^9$ | $\\le 10^9$ |      $=3$       | $\\le 2 \\times 10^4$ |\n| $25$ | $\\le 10^9$ | $\\le 10^9$ | $2 \\le k \\le 3$ | $\\le 2 \\times 10^4$ |\n\n对于 $100\\%$ 的数据，$1 \\le n,m \\le 10^9$，$2 \\le k \\le 3$，$0 \\le t \\le \\min(n\\cdot m,2 \\times 10^4)$，$1 \\le x_i \\le n$，$1 \\le y_i \\le m$，$1 \\le T \\le 10$。每个数据点等分值。", "locale": "zh-CN"}}}
{"pid": "P8916", "type": "P", "difficulty": 4, "samples": [["4\n1 2 \n1 3 \n2 4 \n6 -2 4 -7 ", "5"], ["10\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n4 8\n4 9\n4 10\n-3 9 4 -3 -2 5 -1 -3 -9 7", "42"], ["20\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n4 8\n4 9\n4 10\n6 11\n6 12\n7 13\n7 14\n7 15\n7 16\n8 17\n9 18\n11 19\n15 20\n1 2 -1 -4 9 -3 -5 8 9 -10 -13 15 11 -6 17 -1 -19 20 -5 -9", "266"], ["6\n1 2\n1 3\n1 4\n2 5\n2 6\n-1 5 -3 -4 -5 -7", "-10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2022", "洛谷原创", "树形 DP"], "title": "[DMOI-R2] 暗号", "background": "> 有太多人太多事 夹在我们之间咆哮  \n> 杂讯太多讯号弱 就连风吹都要干扰  \n> 可是你不想 一直走在黑暗地下道  \n> 想吹风想自由 想要一起手牵手 去看海绕世界流浪  \n> ——《[暗号](https://www.bilibili.com/video/BV1p24y1f7zM)》\n\n书接上回，每个军队都拿到了补给。但是要上战场，准备还不是很充分。JF 只有军队组成了一个集团军。才有可能形成一股强大的战斗力，才可以在军阀混战中取得胜利。", "description": "已知 JF 有 $n$ 支军队，他们分别由 $n-1$ 条边连接。$1$ 号军队为根。每支军队有自己的或黑或白的 **“暗号”**，方便相互联系，以及他的战力值和士气值。**初始的时候，军队的士气值等于战力值**。我们从深度最深的军队开始改变士气值，对于当前的军队 $u$ 来说，在与他直接相连的军队且深度比 $u$ 深的军队中，如果有军队 $v$ 和他的暗号相同，$u$ 就可以联系上 $v$，然后 $u$ 的士气值 **就必须全部加上**  $v$ 的子树内和 $v$ 颜色相同的点的战力值。（可以理解为，在 $u$ 的士气更新完毕时，$u$ 的子树的士气也更新完毕了。）  \n\n现在，你可以任意修改这些军队的暗号。要你求出所有**军队士气值的和的最大值**是多少。", "inputFormat": "\n第一行一个整数 $n$，如题所示。\n\n第二行至第 $n$ 行每行有两个数，表示 $u$ 和 $v$ 之间有连边。\n\n第 $n+1$ 行有 $n$ 个数，第 $i$ 个数表示第 $i$ 支军队一开始的战力值 $w_i$。\n", "outputFormat": "一行一个整数，表示士气值之和的最大值。", "hint": "#### 【样例解释 #1】\n\n我们将军队 $1,3,4$ 的暗号改为黑色，军队 $2$ 的暗号改成白色。这样，军队 $1,2,3,4$ 的最终士气值变为 $10,-2,4,-7$，总和为 $5$。可以证明不存在使得最终士气值和更大的方案。\n\n#### 【样例解释 #2】\n\n我们用 $1$ 表示黑色暗号，用 $2$ 表示白色暗号，那么 $n$ 支军队的暗号颜色分别如下：`1 1 1 1 2 1 2 2 2 1`。这样整支军队的士气值和为 $42$，可以证明不存在士气值和更大的方案。\n\n#### 【数据范围与约定】\n\n| 测试点编号 | $n \\le$ | 特殊条件 |\n| :----------: | :----------: | :----------: |\n| $1\\sim2$ | $20$ | 无 |\n| $3 \\sim 6$ | $50$ | 无 |\n| $7 \\sim 10$ | $300$ | $v=u+1$ |\n| $11\\sim12$ | $300$ | $1 \\le w_i \\le 1000$ |\n| $13\\sim14$ | $300$ | $u=1$ |\n| $15 \\sim 20$ | $300$ | 无 |\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 300$，$-1000 \\le w_i \\le 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[DMOI-R2] 暗号", "background": "> 有太多人太多事 夹在我们之间咆哮  \n> 杂讯太多讯号弱 就连风吹都要干扰  \n> 可是你不想 一直走在黑暗地下道  \n> 想吹风想自由 想要一起手牵手 去看海绕世界流浪  \n> ——《[暗号](https://www.bilibili.com/video/BV1p24y1f7zM)》\n\n书接上回，每个军队都拿到了补给。但是要上战场，准备还不是很充分。JF 只有军队组成了一个集团军。才有可能形成一股强大的战斗力，才可以在军阀混战中取得胜利。", "description": "已知 JF 有 $n$ 支军队，他们分别由 $n-1$ 条边连接。$1$ 号军队为根。每支军队有自己的或黑或白的 **“暗号”**，方便相互联系，以及他的战力值和士气值。**初始的时候，军队的士气值等于战力值**。我们从深度最深的军队开始改变士气值，对于当前的军队 $u$ 来说，在与他直接相连的军队且深度比 $u$ 深的军队中，如果有军队 $v$ 和他的暗号相同，$u$ 就可以联系上 $v$，然后 $u$ 的士气值 **就必须全部加上**  $v$ 的子树内和 $v$ 颜色相同的点的战力值。（可以理解为，在 $u$ 的士气更新完毕时，$u$ 的子树的士气也更新完毕了。）  \n\n现在，你可以任意修改这些军队的暗号。要你求出所有**军队士气值的和的最大值**是多少。", "inputFormat": "\n第一行一个整数 $n$，如题所示。\n\n第二行至第 $n$ 行每行有两个数，表示 $u$ 和 $v$ 之间有连边。\n\n第 $n+1$ 行有 $n$ 个数，第 $i$ 个数表示第 $i$ 支军队一开始的战力值 $w_i$。\n", "outputFormat": "一行一个整数，表示士气值之和的最大值。", "hint": "#### 【样例解释 #1】\n\n我们将军队 $1,3,4$ 的暗号改为黑色，军队 $2$ 的暗号改成白色。这样，军队 $1,2,3,4$ 的最终士气值变为 $10,-2,4,-7$，总和为 $5$。可以证明不存在使得最终士气值和更大的方案。\n\n#### 【样例解释 #2】\n\n我们用 $1$ 表示黑色暗号，用 $2$ 表示白色暗号，那么 $n$ 支军队的暗号颜色分别如下：`1 1 1 1 2 1 2 2 2 1`。这样整支军队的士气值和为 $42$，可以证明不存在士气值和更大的方案。\n\n#### 【数据范围与约定】\n\n| 测试点编号 | $n \\le$ | 特殊条件 |\n| :----------: | :----------: | :----------: |\n| $1\\sim2$ | $20$ | 无 |\n| $3 \\sim 6$ | $50$ | 无 |\n| $7 \\sim 10$ | $300$ | $v=u+1$ |\n| $11\\sim12$ | $300$ | $1 \\le w_i \\le 1000$ |\n| $13\\sim14$ | $300$ | $u=1$ |\n| $15 \\sim 20$ | $300$ | 无 |\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 300$，$-1000 \\le w_i \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P8917", "type": "P", "difficulty": 6, "samples": [["8 3 1 6\n1 2\n1 3\n1 6\n2 4\n2 5\n3 7\n3 8\n6 7 8\n1\n3\n5\n6\n7\n8", "0\n1\n1\n2\n2\n3"], ["8 3 2 6\n1 2\n1 3\n1 6\n2 4\n2 5\n3 7\n3 8\n6 7 8\n1\n3\n5\n6\n7\n8", "0\n1\n2\n2\n3\n3"]], "limits": {"time": [350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "树形 DP"], "title": "[DMOI-R2] 风神瞳（Anemoculus）", "background": "![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi1.hdslb.com%2Fbfs%2Farchive%2F778e646138c05348a05fc8a5d646201c0be048b0.jpg&refer=http%3A%2F%2Fi1.hdslb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1665222406&t=01eff8edc99fbecc5e2e94e6e4b8fd01)\n\n$$\\pmb{\\color{Aquamarine}『传说，飞鸟啄去了神像的眼瞳，然后散落到世界各地』}$$\n\n$$\\pmb{\\color{Aquamarine}『当然了，这只是传说而已』}$$\n\n$$\\pmb{\\color{Aquamarine}『不过，据说把散失的神瞳献给神像，会有好事发生呢』}$$", "description": "风起地有一颗大树，它有 $n$ 个节点，以 $1$ 号节点为根。\n\n树上有 $m$ 个风神瞳，第 $i$ 个风神瞳位于节点 $a_i$ 上。\n\n你想要收集这些风神瞳。于是请来了~~在大树旁边摸鱼的~~温迪帮忙。\n\n一开始，你在树的根部的节点，也就是 $1$ 号节点上，每一秒钟，你可以从当前节点走到相邻的节点。或者，你可以请温迪帮忙，他会生成一个风场，你可以通过这个风场直接一次性向上走正好 $k$ 步（我们定义根节点到叶子结点的方向为『上』，即从深度较小的节点到深度较大的节点，换句话说，你可以从当前节点朝着深度更大的节点连续走 $k$ 步）。当你到达某个有风神瞳的节点上时，你就可以收集那个节点的风神瞳，收集不耗费时间。由于从树上跳下来会摔伤，你最后必须回到根节点。现在你有 $q$ 个问题，第 $i$ 个问题是你在 $t_i$ 秒内你最多可以收集到几个风神瞳。", "inputFormat": "第一行四个正整数 $n,m,k,q$，含义如题目描述中所述。\n\n接下来 $n - 1$ 行，每行两个正整数 $u,v$，表示结点 $u$ 和结点 $v$ 是相邻的。\n\n接下来一行 $m$ 个互不相同的正整数，第 $i$ 个数表示 $a_i$，含义如题目描述中所述。\n\n接下来 $q$ 行，其中第 $i$ 行有一个正整数 $t_i$，含义如题目描述中所述。\n", "outputFormat": "对于 $q$ 次询问，每次询问输出一行，表示最多可以收集到几个风神瞳。", "hint": "---\n### 样例解释\n#### 样例一\n![](https://cdn.luogu.com.cn/upload/image_hosting/mz5mcnuo.png)\n\n如图，其中加粗的点是有风神瞳的点。温迪~~很懒~~有事所以不准备帮你。\n#### 样例二\n这个样例除了温迪能让你一次性向上走两步和样例一没有区别。\n\n---\n### 数据范围\n\n本题采用捆绑测试。\n\n对于 $5\\%$ 的数据，$m = 10$。\n\n对于另外 $15\\%$ 的数据，$m = 17$。\n\n对于另外 $20\\%$ 的数据，$k=1$。\n\n对于 $100\\%$ 的数据，$n \\leq 2000$，$m \\leq 500$，$q \\le 1000$，$1\\leq t_i \\leq 2\\times n$，$1\\le a_i,u,v \\le n$，$1 \\leq k\\le \\min(dep-1,100)$，其中 $dep$ 表示树的深度，定义根节点的深度为 $1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[DMOI-R2] 风神瞳（Anemoculus）", "background": "![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi1.hdslb.com%2Fbfs%2Farchive%2F778e646138c05348a05fc8a5d646201c0be048b0.jpg&refer=http%3A%2F%2Fi1.hdslb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1665222406&t=01eff8edc99fbecc5e2e94e6e4b8fd01)\n\n$$\\pmb{\\color{Aquamarine}『传说，飞鸟啄去了神像的眼瞳，然后散落到世界各地』}$$\n\n$$\\pmb{\\color{Aquamarine}『当然了，这只是传说而已』}$$\n\n$$\\pmb{\\color{Aquamarine}『不过，据说把散失的神瞳献给神像，会有好事发生呢』}$$", "description": "风起地有一颗大树，它有 $n$ 个节点，以 $1$ 号节点为根。\n\n树上有 $m$ 个风神瞳，第 $i$ 个风神瞳位于节点 $a_i$ 上。\n\n你想要收集这些风神瞳。于是请来了~~在大树旁边摸鱼的~~温迪帮忙。\n\n一开始，你在树的根部的节点，也就是 $1$ 号节点上，每一秒钟，你可以从当前节点走到相邻的节点。或者，你可以请温迪帮忙，他会生成一个风场，你可以通过这个风场直接一次性向上走正好 $k$ 步（我们定义根节点到叶子结点的方向为『上』，即从深度较小的节点到深度较大的节点，换句话说，你可以从当前节点朝着深度更大的节点连续走 $k$ 步）。当你到达某个有风神瞳的节点上时，你就可以收集那个节点的风神瞳，收集不耗费时间。由于从树上跳下来会摔伤，你最后必须回到根节点。现在你有 $q$ 个问题，第 $i$ 个问题是你在 $t_i$ 秒内你最多可以收集到几个风神瞳。", "inputFormat": "第一行四个正整数 $n,m,k,q$，含义如题目描述中所述。\n\n接下来 $n - 1$ 行，每行两个正整数 $u,v$，表示结点 $u$ 和结点 $v$ 是相邻的。\n\n接下来一行 $m$ 个互不相同的正整数，第 $i$ 个数表示 $a_i$，含义如题目描述中所述。\n\n接下来 $q$ 行，其中第 $i$ 行有一个正整数 $t_i$，含义如题目描述中所述。\n", "outputFormat": "对于 $q$ 次询问，每次询问输出一行，表示最多可以收集到几个风神瞳。", "hint": "---\n### 样例解释\n#### 样例一\n![](https://cdn.luogu.com.cn/upload/image_hosting/mz5mcnuo.png)\n\n如图，其中加粗的点是有风神瞳的点。温迪~~很懒~~有事所以不准备帮你。\n#### 样例二\n这个样例除了温迪能让你一次性向上走两步和样例一没有区别。\n\n---\n### 数据范围\n\n本题采用捆绑测试。\n\n对于 $5\\%$ 的数据，$m = 10$。\n\n对于另外 $15\\%$ 的数据，$m = 17$。\n\n对于另外 $20\\%$ 的数据，$k=1$。\n\n对于 $100\\%$ 的数据，$n \\leq 2000$，$m \\leq 500$，$q \\le 1000$，$1\\leq t_i \\leq 2\\times n$，$1\\le a_i,u,v \\le n$，$1 \\leq k\\le \\min(dep-1,100)$，其中 $dep$ 表示树的深度，定义根节点的深度为 $1$。", "locale": "zh-CN"}}}
{"pid": "P8918", "type": "P", "difficulty": 2, "samples": [["10\n1\n2\n7\n8\n9\n10\n11\n935\n101\n2023", "1\n-1\n3\n-1\n4\n-1\n4\n10\n7\n11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "洛谷原创", "O2优化", "位运算", "洛谷月赛"], "title": "『MdOI R5』Jump", "background": "", "description": "数轴上有一个人，设他所在的位置为 $x$，初始时 $x=0$。第 $i$ 秒中他可以选择往左或往右跳 $2^{i-1}$ 单位长度，即将 $x$ 增大或减小 $2^{i-1}$。问他至少需要多少秒才能到达 $n$，即在某一秒结束的时刻使得 $x=n$。如果永远都不可能到达 $n$，那么输出 $-1$。\n\n**本题每个测试点中有多组数据。**", "inputFormat": "第一行，一个整数，表示数据组数 $T$。\n\n接下来 $T$ 行，每行一个整数，表示一组测试数据中的 $n$。", "outputFormat": "共 $T$ 行，每行一个数，依次表示每组数据的答案。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 10^3$，$1\\le n\\le 10^9$。\n\n$\\operatorname{Subtask} 1(30\\%)$：$n\\le 100$。\n\n$\\operatorname{Subtask} 2(40\\%)$：$n=2^k$，其中 $k$ 是一个非负整数。\n\n$\\operatorname{Subtask} 3(30\\%)$：无特殊限制。\n\n#### 样例说明 1\n\n$n=1$ 时只需要在第一秒中往右跳即可。\n\n$n=2$ 时可以证明永远都不可能到达 $n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『MdOI R5』Jump", "background": "", "description": "数轴上有一个人，设他所在的位置为 $x$，初始时 $x=0$。第 $i$ 秒中他可以选择往左或往右跳 $2^{i-1}$ 单位长度，即将 $x$ 增大或减小 $2^{i-1}$。问他至少需要多少秒才能到达 $n$，即在某一秒结束的时刻使得 $x=n$。如果永远都不可能到达 $n$，那么输出 $-1$。\n\n**本题每个测试点中有多组数据。**", "inputFormat": "第一行，一个整数，表示数据组数 $T$。\n\n接下来 $T$ 行，每行一个整数，表示一组测试数据中的 $n$。", "outputFormat": "共 $T$ 行，每行一个数，依次表示每组数据的答案。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 10^3$，$1\\le n\\le 10^9$。\n\n$\\operatorname{Subtask} 1(30\\%)$：$n\\le 100$。\n\n$\\operatorname{Subtask} 2(40\\%)$：$n=2^k$，其中 $k$ 是一个非负整数。\n\n$\\operatorname{Subtask} 3(30\\%)$：无特殊限制。\n\n#### 样例说明 1\n\n$n=1$ 时只需要在第一秒中往右跳即可。\n\n$n=2$ 时可以证明永远都不可能到达 $n$。", "locale": "zh-CN"}}}
{"pid": "P8919", "type": "P", "difficulty": 3, "samples": [["4 11\n01101010001\n2 6 8 11\n", "2\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "洛谷原创", "O2优化", "洛谷月赛"], "title": "『MdOI R5』Message", "background": "", "description": "小 A 有一个群。这个群正在玩一个小游戏：给出一个函数 $f$，从某一个时间点起，发送第 $x$ 条消息，而 $f(x)=1$ 的群友会受到一个小惩罚。当群内消息总数达到 $m$ 时游戏结束。\n\n但小 A 是个话痨，这段时间他在这个群发了 $n$ 条消息，他发的第 $i$ 条消息在整个消息记录里是第 $a_i$ 条消息。\n\n但是小 A 不想受到惩罚，而小 A 恰好是管理员，他可以撤回**任何时刻、任何群成员发的任何消息**，注意这会导致这条消息之后的消息排名改变。\n\n但是撤回消息太多容易被当成暴政，因此他要尽可能减少撤回信息次数，不管是自己的还是别人的。\n\n接下来你也猜到你要干什么了：假如其他群成员不操作，给出 $n$、函数 $f$ 和 $a_i$，求出他至少要撤回几条消息。", "inputFormat": "输入的第一行有两个正整数 $n,m$，表示他的消息数量以及群内消息数量总数。\n\n第二行是一个长为 $m$ 的 **01 串** $f$，其第 $i$ 项 $f(i)$ 表示发第 $i$ 条消息的群成员是否要受到惩罚。\n\n第三行有 $n$ 个正整数 $a_1,a_2,\\ldots,a_n$，表示每条消息的初始排名。保证数列 $a$ 严格递增，且 $1\\le a_i\\le m$。", "outputFormat": "输出一行一个整数 $ans$ 表示至少撤回几条消息才能让小 A 不被惩罚。", "hint": "【样例解释】\n\n下面给出一种可能的方式：\n- 小 A 先撤回第 $1$ 条消息（群友发的），他的四条消息在消息记录里现在是第 $1,5,7,10$ 条。\n- 然后撤回第 $5$ 条消息（他自己发的），剩下三条消息在消息记录里现在是第 $1,6,9$ 条。\n\n此时三条消息满足 $f(1)=f(6)=f(9)=0$，符合题意。\n\n可以证明无法仅撤回一条消息达成要求。\n\n【数据范围】\n\n|Subtask|$n\\le$|$m\\le$|特殊性质|分值|\n|:-:|:-:|:-:|:-:|:-:|\n|1|$17$|$17$||$15$|\n|2|$17$|$100$||$15$|\n|3|$10^3$|$10^4$||$20$|\n|4||$10^5$|$n=m$|$8$|\n|5|$10^5$|$10^6$|A|$12$|\n|6|$10^5$|$10^6$||$30$|\n\n- 特殊性质 A：小 A 没有连发两条消息。\n\n对于全部数据，$1\\le n\\le 10^5$，$1\\le a_i\\le m\\le 10^6$，$a_i$ 严格递增，$f(i)\\in \\{0,1\\}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『MdOI R5』Message", "background": "", "description": "小 A 有一个群。这个群正在玩一个小游戏：给出一个函数 $f$，从某一个时间点起，发送第 $x$ 条消息，而 $f(x)=1$ 的群友会受到一个小惩罚。当群内消息总数达到 $m$ 时游戏结束。\n\n但小 A 是个话痨，这段时间他在这个群发了 $n$ 条消息，他发的第 $i$ 条消息在整个消息记录里是第 $a_i$ 条消息。\n\n但是小 A 不想受到惩罚，而小 A 恰好是管理员，他可以撤回**任何时刻、任何群成员发的任何消息**，注意这会导致这条消息之后的消息排名改变。\n\n但是撤回消息太多容易被当成暴政，因此他要尽可能减少撤回信息次数，不管是自己的还是别人的。\n\n接下来你也猜到你要干什么了：假如其他群成员不操作，给出 $n$、函数 $f$ 和 $a_i$，求出他至少要撤回几条消息。", "inputFormat": "输入的第一行有两个正整数 $n,m$，表示他的消息数量以及群内消息数量总数。\n\n第二行是一个长为 $m$ 的 **01 串** $f$，其第 $i$ 项 $f(i)$ 表示发第 $i$ 条消息的群成员是否要受到惩罚。\n\n第三行有 $n$ 个正整数 $a_1,a_2,\\ldots,a_n$，表示每条消息的初始排名。保证数列 $a$ 严格递增，且 $1\\le a_i\\le m$。", "outputFormat": "输出一行一个整数 $ans$ 表示至少撤回几条消息才能让小 A 不被惩罚。", "hint": "【样例解释】\n\n下面给出一种可能的方式：\n- 小 A 先撤回第 $1$ 条消息（群友发的），他的四条消息在消息记录里现在是第 $1,5,7,10$ 条。\n- 然后撤回第 $5$ 条消息（他自己发的），剩下三条消息在消息记录里现在是第 $1,6,9$ 条。\n\n此时三条消息满足 $f(1)=f(6)=f(9)=0$，符合题意。\n\n可以证明无法仅撤回一条消息达成要求。\n\n【数据范围】\n\n|Subtask|$n\\le$|$m\\le$|特殊性质|分值|\n|:-:|:-:|:-:|:-:|:-:|\n|1|$17$|$17$||$15$|\n|2|$17$|$100$||$15$|\n|3|$10^3$|$10^4$||$20$|\n|4||$10^5$|$n=m$|$8$|\n|5|$10^5$|$10^6$|A|$12$|\n|6|$10^5$|$10^6$||$30$|\n\n- 特殊性质 A：小 A 没有连发两条消息。\n\n对于全部数据，$1\\le n\\le 10^5$，$1\\le a_i\\le m\\le 10^6$，$a_i$ 严格递增，$f(i)\\in \\{0,1\\}$。", "locale": "zh-CN"}}}
{"pid": "P8920", "type": "P", "difficulty": 4, "samples": [["2\n1 10\n1 10", "81"], ["3\n1 2 3\n3 4 5", "26"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "洛谷原创", "O2优化", "洛谷月赛"], "title": "『MdOI R5』Variance", "background": "Subtask 1~5 为原数据，Subtask 6 为 hack 数据。", "description": "给定两个长度为 $n$ 的整数序列 $a,b$，满足：\n- $\\forall i\\in [1,n),a_i\\le a_{i+1},b_i\\le b_{i+1}$。\n\n- $\\forall i\\in [1,n],a_i\\le b_i$。\n\n有一个长度为 $n$ 的实数序列 $c$，满足 $c_i\\in [a_i,b_i]$，求 $c$ 的方差的最大值。\n\n你只需要输出答案乘上 $n^2$ 之后的结果。容易证明这是一个整数。\n\n### 提示\n\n一个长度为 $n$ 的序列 $a$ 的方差为：$\\dfrac{1}{n}\\sum\\limits_{i=1}^n (a_i-\\overline{a})^2$。其中 $\\overline{a}=\\dfrac{1}{n}\\sum\\limits_{i=1}^n a_i$。\n\n本题的计算过程中可能会涉及到超过 `long long` 范围的数，此时可能需要用到 `__int128` 进行处理。\n\n我们提供了以下代码，它可以用于输出一个 `__int128` 类型的数：\n\n``` cpp\nvoid print(__int128 x)\n{\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tif(x<10)\n\t{\n\t\tputchar(x+48);\n\t\treturn;\n\t}\n\tprint(x/10);\n\tputchar(x%10+48);\n}\n```", "inputFormat": "第一行，一个整数，表示 $n$。\n\n第二行，$n$ 个整数，表示 $a_1,a_2,\\dots,a_n$。\n\n第三行，$n$ 个整数，表示 $b_1,b_2,\\dots,b_n$。", "outputFormat": "共一行，一个整数，表示答案。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le a_i,b_i\\le 10^9$。\n\n$\\operatorname{Subtask} 1(10\\%)$：$n\\le 2\\times 10^3$，$a_i=b_i\\le 10^5$。\n\n$\\operatorname{Subtask} 2(20\\%)$：$n\\le 10$，$a_i,b_i\\le 5$。\n\n$\\operatorname{Subtask} 3(20\\%)$：$n\\le 2\\times 10^3$，$a_i,b_i\\le 10^5$。\n\n$\\operatorname{Subtask} 4(20\\%)$：$n\\le 10^5$，$a_i,b_i\\le 2\\times 10^3$。\n\n$\\operatorname{Subtask} 5(30\\%)$：无特殊限制。\n\n#### 样例说明 1\n\n$c$ 只可能为 $(1,10)$。\n\n#### 样例说明 2\n\n一种最优的 $c$ 为 $(1,2,5)$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『MdOI R5』Variance", "background": "Subtask 1~5 为原数据，Subtask 6 为 hack 数据。", "description": "给定两个长度为 $n$ 的整数序列 $a,b$，满足：\n- $\\forall i\\in [1,n),a_i\\le a_{i+1},b_i\\le b_{i+1}$。\n\n- $\\forall i\\in [1,n],a_i\\le b_i$。\n\n有一个长度为 $n$ 的实数序列 $c$，满足 $c_i\\in [a_i,b_i]$，求 $c$ 的方差的最大值。\n\n你只需要输出答案乘上 $n^2$ 之后的结果。容易证明这是一个整数。\n\n### 提示\n\n一个长度为 $n$ 的序列 $a$ 的方差为：$\\dfrac{1}{n}\\sum\\limits_{i=1}^n (a_i-\\overline{a})^2$。其中 $\\overline{a}=\\dfrac{1}{n}\\sum\\limits_{i=1}^n a_i$。\n\n本题的计算过程中可能会涉及到超过 `long long` 范围的数，此时可能需要用到 `__int128` 进行处理。\n\n我们提供了以下代码，它可以用于输出一个 `__int128` 类型的数：\n\n``` cpp\nvoid print(__int128 x)\n{\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tif(x<10)\n\t{\n\t\tputchar(x+48);\n\t\treturn;\n\t}\n\tprint(x/10);\n\tputchar(x%10+48);\n}\n```", "inputFormat": "第一行，一个整数，表示 $n$。\n\n第二行，$n$ 个整数，表示 $a_1,a_2,\\dots,a_n$。\n\n第三行，$n$ 个整数，表示 $b_1,b_2,\\dots,b_n$。", "outputFormat": "共一行，一个整数，表示答案。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le a_i,b_i\\le 10^9$。\n\n$\\operatorname{Subtask} 1(10\\%)$：$n\\le 2\\times 10^3$，$a_i=b_i\\le 10^5$。\n\n$\\operatorname{Subtask} 2(20\\%)$：$n\\le 10$，$a_i,b_i\\le 5$。\n\n$\\operatorname{Subtask} 3(20\\%)$：$n\\le 2\\times 10^3$，$a_i,b_i\\le 10^5$。\n\n$\\operatorname{Subtask} 4(20\\%)$：$n\\le 10^5$，$a_i,b_i\\le 2\\times 10^3$。\n\n$\\operatorname{Subtask} 5(30\\%)$：无特殊限制。\n\n#### 样例说明 1\n\n$c$ 只可能为 $(1,10)$。\n\n#### 样例说明 2\n\n一种最优的 $c$ 为 $(1,2,5)$。", "locale": "zh-CN"}}}
{"pid": "P8921", "type": "P", "difficulty": 5, "samples": [["5\n1 3\n1 4", "-1"], ["8\n6 8\n5 8\n2 4\n2 5\n1 5", "3 2\n2 4\n7 8\n6 8\n2 1\n1 5\n8 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "Special Judge", "O2优化", "洛谷月赛"], "title": "『MdOI R5』Triangulation", "background": "", "description": "有一个正 $n$ 边形，顶点按顺时针方向从 $1$ 到 $n$ 依次标号。给定这个多边形的 $n-3$ 条**互不相同**的对角线，满足它们**互相之间只可能在顶点处相交**。这样我们得到了一张 $n$ 个点，$2n-3$ 条边的无向图。\n\n凸多边形的对角线指的是连接两个**不相同**且**不在多边形上相邻**的顶点的一条线段。\n\n实际上，这个无向图可以是任意一个凸 $n$ 边形的三角剖分图。\n\n你需要构造这个无向图的一棵生成树，使得每个点的度数都是**奇数**，或报告无解。", "inputFormat": "第一行，一个整数，表示 $n$。\n\n接下来 $n-3$ 行，每行两个整数 $u,v$ 表示一条给定的对角线 $(u,v)$。", "outputFormat": "如果无解，那么输出一行一个整数 $-1$。\n\n如果有解，那么输出 $n-1$ 行，每行两个数 $u,v$ 表示你所构造的答案中的一条边 $(u,v)$。", "hint": "对于 $100\\%$ 的数据，$3\\le n\\le 3\\times 10^5$。\n\n$\\operatorname{Subtask} 1(9\\%)$：$n\\le 10$。\n\n$\\operatorname{Subtask} 2(1\\%)$：$n$ 为奇数。\n\n$\\operatorname{Subtask} 3(10\\%)$：$u=1$。\n\n$\\operatorname{Subtask} 4(30\\%)$：$n\\le 100$。\n\n$\\operatorname{Subtask} 5(30\\%)$：$n\\le 5\\times 10^3$。\n\n$\\operatorname{Subtask} 6(20\\%)$：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『MdOI R5』Triangulation", "background": "", "description": "有一个正 $n$ 边形，顶点按顺时针方向从 $1$ 到 $n$ 依次标号。给定这个多边形的 $n-3$ 条**互不相同**的对角线，满足它们**互相之间只可能在顶点处相交**。这样我们得到了一张 $n$ 个点，$2n-3$ 条边的无向图。\n\n凸多边形的对角线指的是连接两个**不相同**且**不在多边形上相邻**的顶点的一条线段。\n\n实际上，这个无向图可以是任意一个凸 $n$ 边形的三角剖分图。\n\n你需要构造这个无向图的一棵生成树，使得每个点的度数都是**奇数**，或报告无解。", "inputFormat": "第一行，一个整数，表示 $n$。\n\n接下来 $n-3$ 行，每行两个整数 $u,v$ 表示一条给定的对角线 $(u,v)$。", "outputFormat": "如果无解，那么输出一行一个整数 $-1$。\n\n如果有解，那么输出 $n-1$ 行，每行两个数 $u,v$ 表示你所构造的答案中的一条边 $(u,v)$。", "hint": "对于 $100\\%$ 的数据，$3\\le n\\le 3\\times 10^5$。\n\n$\\operatorname{Subtask} 1(9\\%)$：$n\\le 10$。\n\n$\\operatorname{Subtask} 2(1\\%)$：$n$ 为奇数。\n\n$\\operatorname{Subtask} 3(10\\%)$：$u=1$。\n\n$\\operatorname{Subtask} 4(30\\%)$：$n\\le 100$。\n\n$\\operatorname{Subtask} 5(30\\%)$：$n\\le 5\\times 10^3$。\n\n$\\operatorname{Subtask} 6(20\\%)$：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P8922", "type": "P", "difficulty": 7, "samples": [["4 2\n1 0\n0 3\n4 1\n3 4\n2 2\n5 5", "4\n-1"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["洛谷原创", "O2优化", "洛谷月赛"], "title": "『MdOI R5』Squares", "background": "本题不是数据结构题，建议先做 F。\n\n[![1.gif](https://i.postimg.cc/7ZV6xBX6/1.gif)](https://postimg.cc/HrrHz9qD)", "description": "给定平面上的 $n$ 个点，定义平面上的一个区域是好的当且仅当它是一个**边与坐标轴平行的正方形**并且不存在任何一个给定的点被它**严格包含**。再给定 $m$ 次询问，每次给出一个点 $(x,y)$，求出**严格包含** $(x,y)$ 的最大的好区域的边长。如果可以无限大则输出 $-1$。\n\n点 $A$ 被区域 $B$ **严格包含**当且仅当 $A$ 在 $B$ 的内部且不在边界上。\n\n为了减少奇奇怪怪的细节，我们保证所有的 $n+m$ 个点都满足横坐标互不相同，纵坐标互不相同。", "inputFormat": "第一行，两个正整数 $n,m$。\n\n接下来 $n$ 行，每行两个整数 $x,y$，表示一个给定的点 $(x,y)$。\n\n接下来 $m$ 行，每行两个整数 $x,y$，表示一组询问中给定的点 $(x,y)$。", "outputFormat": "共 $m$ 行，每行一个整数，第 $i$ 行的数表示第 $i$ 组询问的答案。", "hint": "对于 $100\\%$ 的数据，$1\\le n,m\\le 3\\times 10^5$，$0\\le x,y\\le 10^8$。\n\n$\\operatorname{Subtask} 1(10\\%)$：$n,m\\le 10$。\n\n$\\operatorname{Subtask} 2(10\\%)$：$n,m\\le 100$。\n\n$\\operatorname{Subtask} 3(20\\%)$：$n,m\\le 10^3$。\n\n$\\operatorname{Subtask} 4(20\\%)$：$n,m\\le 5\\times 10^4$。\n\n$\\operatorname{Subtask} 5(20\\%)$：$n,m\\le 10^5$。\n\n$\\operatorname{Subtask} 6(20\\%)$：无特殊限制。\n\n#### 样例说明 1\n\n对于第一组询问，左下角为 $(0,0)$，边长为 $4$ 的正方形是严格包含 $(2,2)$ 的好区域中边长最大的。\n\n对于第二组询问，左下角为 $(4,4)$，边长为 $+\\infty$ 的正方形是严格包含 $(5,5)$ 的好区域中边长最大的。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『MdOI R5』Squares", "background": "本题不是数据结构题，建议先做 F。\n\n[![1.gif](https://i.postimg.cc/7ZV6xBX6/1.gif)](https://postimg.cc/HrrHz9qD)", "description": "给定平面上的 $n$ 个点，定义平面上的一个区域是好的当且仅当它是一个**边与坐标轴平行的正方形**并且不存在任何一个给定的点被它**严格包含**。再给定 $m$ 次询问，每次给出一个点 $(x,y)$，求出**严格包含** $(x,y)$ 的最大的好区域的边长。如果可以无限大则输出 $-1$。\n\n点 $A$ 被区域 $B$ **严格包含**当且仅当 $A$ 在 $B$ 的内部且不在边界上。\n\n为了减少奇奇怪怪的细节，我们保证所有的 $n+m$ 个点都满足横坐标互不相同，纵坐标互不相同。", "inputFormat": "第一行，两个正整数 $n,m$。\n\n接下来 $n$ 行，每行两个整数 $x,y$，表示一个给定的点 $(x,y)$。\n\n接下来 $m$ 行，每行两个整数 $x,y$，表示一组询问中给定的点 $(x,y)$。", "outputFormat": "共 $m$ 行，每行一个整数，第 $i$ 行的数表示第 $i$ 组询问的答案。", "hint": "对于 $100\\%$ 的数据，$1\\le n,m\\le 3\\times 10^5$，$0\\le x,y\\le 10^8$。\n\n$\\operatorname{Subtask} 1(10\\%)$：$n,m\\le 10$。\n\n$\\operatorname{Subtask} 2(10\\%)$：$n,m\\le 100$。\n\n$\\operatorname{Subtask} 3(20\\%)$：$n,m\\le 10^3$。\n\n$\\operatorname{Subtask} 4(20\\%)$：$n,m\\le 5\\times 10^4$。\n\n$\\operatorname{Subtask} 5(20\\%)$：$n,m\\le 10^5$。\n\n$\\operatorname{Subtask} 6(20\\%)$：无特殊限制。\n\n#### 样例说明 1\n\n对于第一组询问，左下角为 $(0,0)$，边长为 $4$ 的正方形是严格包含 $(2,2)$ 的好区域中边长最大的。\n\n对于第二组询问，左下角为 $(4,4)$，边长为 $+\\infty$ 的正方形是严格包含 $(5,5)$ 的好区域中边长最大的。", "locale": "zh-CN"}}}
{"pid": "P8923", "type": "P", "difficulty": 7, "samples": [["3 2 1000000007", "4"], ["5 5 1000000007", "11040"], ["50 50 1000000009", "875463033"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "O2优化", "洛谷月赛"], "title": "『MdOI R5』Many Minimizations", "background": "本题不是多项式题，建议先做 E。\n\n[![2.gif](https://i.postimg.cc/3JN9j60M/2.gif)](https://postimg.cc/xcrKn6Pg)", "description": "小 L 遇到了一个经典题：给定一个长度为 $n$ 的**整数**序列 $a$，你需要在所有**单调不降**的**实数**序列中选出一个作为 $b$，最小化 $\\sum\\limits_{i=1}^n |a_i-b_i|$。可以证明答案是整数。\n\n他一眼就秒了这个题：这不是保序回归板子吗！\n\n他觉得这题太水了，于是决定加强一下：\n\n对于所有长度为 $n$ 的且满足 $\\forall i\\in[1,n],a_i\\in[1,m]$ 的**整数**序列 $a$，求出上面这个问题的答案的总和对**质数** $p$ 取模后的结果。其中 $n,m,p$ 是给定的常数。\n\n这下小 L 不会了。为了不让你看出来他根本就不会，他随便写了一个数据范围就把这题扔给你做了。\n\n现在压力来到了你这边，你能否顺利切掉这个题呢？", "inputFormat": "共一行，三个整数，依次表示 $n,m,p$。", "outputFormat": "共一行，一个整数，表示答案。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 5\\times 10^3$，$1\\le m\\le 10^9$，$10^9<p\\le 1.01\\times 10^9$，保证 $p$ 是质数。\n\n$\\operatorname{Subtask} 1(10\\%)$：$n,m\\le 7$。\n\n$\\operatorname{Subtask} 2(10\\%)$：$m\\le 2$。\n\n$\\operatorname{Subtask} 3(10\\%)$：$n,m\\le 50$。\n\n$\\operatorname{Subtask} 4(10\\%)$：$n\\le 50$。\n\n$\\operatorname{Subtask} 5(10\\%)$：$n,m\\le 500$。\n\n$\\operatorname{Subtask} 6(10\\%)$：$n\\le 500$。\n\n$\\operatorname{Subtask} 7(10\\%)$：$m\\le 5\\times 10^3$。\n\n$\\operatorname{Subtask} 8(30\\%)$：无特殊限制。\n\n#### 样例说明 1\n\n有以下 $8$ 种可能的情况：\n\n$a=(1,1,1),b=(1,1,1),ans=0$。\n\n$a=(1,1,2),b=(1,1,2),ans=0$。\n\n$a=(1,2,1),b=(1,1,1),ans=1$。\n\n$a=(1,2,2),b=(1,2,2),ans=0$。\n\n$a=(2,1,1),b=(1,1,1),ans=1$。\n\n$a=(2,1,2),b=(1,1,2),ans=1$。\n\n$a=(2,2,1),b=(2,2,2),ans=1$。\n\n$a=(2,2,2),b=(2,2,2),ans=0$。\n\n因此答案为 $0+0+1+0+1+1+1+0=4$。\n\n注意，对于一个固定的 $a$，最优的 $b$ 不一定唯一。上面只给出了一种可能的解。\n\n$\\operatorname{Bonus}$：在 $p$ 为 NTT 模数的情况下做到 $O(n\\log n)$。实际上在本题正解的基础上这一部分并不困难。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『MdOI R5』Many Minimizations", "background": "本题不是多项式题，建议先做 E。\n\n[![2.gif](https://i.postimg.cc/3JN9j60M/2.gif)](https://postimg.cc/xcrKn6Pg)", "description": "小 L 遇到了一个经典题：给定一个长度为 $n$ 的**整数**序列 $a$，你需要在所有**单调不降**的**实数**序列中选出一个作为 $b$，最小化 $\\sum\\limits_{i=1}^n |a_i-b_i|$。可以证明答案是整数。\n\n他一眼就秒了这个题：这不是保序回归板子吗！\n\n他觉得这题太水了，于是决定加强一下：\n\n对于所有长度为 $n$ 的且满足 $\\forall i\\in[1,n],a_i\\in[1,m]$ 的**整数**序列 $a$，求出上面这个问题的答案的总和对**质数** $p$ 取模后的结果。其中 $n,m,p$ 是给定的常数。\n\n这下小 L 不会了。为了不让你看出来他根本就不会，他随便写了一个数据范围就把这题扔给你做了。\n\n现在压力来到了你这边，你能否顺利切掉这个题呢？", "inputFormat": "共一行，三个整数，依次表示 $n,m,p$。", "outputFormat": "共一行，一个整数，表示答案。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 5\\times 10^3$，$1\\le m\\le 10^9$，$10^9<p\\le 1.01\\times 10^9$，保证 $p$ 是质数。\n\n$\\operatorname{Subtask} 1(10\\%)$：$n,m\\le 7$。\n\n$\\operatorname{Subtask} 2(10\\%)$：$m\\le 2$。\n\n$\\operatorname{Subtask} 3(10\\%)$：$n,m\\le 50$。\n\n$\\operatorname{Subtask} 4(10\\%)$：$n\\le 50$。\n\n$\\operatorname{Subtask} 5(10\\%)$：$n,m\\le 500$。\n\n$\\operatorname{Subtask} 6(10\\%)$：$n\\le 500$。\n\n$\\operatorname{Subtask} 7(10\\%)$：$m\\le 5\\times 10^3$。\n\n$\\operatorname{Subtask} 8(30\\%)$：无特殊限制。\n\n#### 样例说明 1\n\n有以下 $8$ 种可能的情况：\n\n$a=(1,1,1),b=(1,1,1),ans=0$。\n\n$a=(1,1,2),b=(1,1,2),ans=0$。\n\n$a=(1,2,1),b=(1,1,1),ans=1$。\n\n$a=(1,2,2),b=(1,2,2),ans=0$。\n\n$a=(2,1,1),b=(1,1,1),ans=1$。\n\n$a=(2,1,2),b=(1,1,2),ans=1$。\n\n$a=(2,2,1),b=(2,2,2),ans=1$。\n\n$a=(2,2,2),b=(2,2,2),ans=0$。\n\n因此答案为 $0+0+1+0+1+1+1+0=4$。\n\n注意，对于一个固定的 $a$，最优的 $b$ 不一定唯一。上面只给出了一种可能的解。\n\n$\\operatorname{Bonus}$：在 $p$ 为 NTT 模数的情况下做到 $O(n\\log n)$。实际上在本题正解的基础上这一部分并不困难。", "locale": "zh-CN"}}}
{"pid": "P8924", "type": "P", "difficulty": 2, "samples": [["5 5 1\n0 1\n", "....*\n...*.\n..*..\n.*...\n*...."], ["8 8 1\n0 2\n", "........\n...*....\n........\n..*.....\n........\n.*......\n........\n*.......\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "O2优化"], "title": "「GMOI R1-T1」Perfect Math Class", "background": "", "description": "Index 给了你一个函数如下：\n\n$$f(x)=a_kx^k+a_{k-1}x^{k-1}+\\cdots+a_1x^1+a_0$$\n\n画出它的函数图像（`*` 表示经过该点，`.` 表示不经过该点），大小为 $n\\times m$，其中 $x$ 的范围是 $[0,n-1]$，$f(x)$ 的范围是 $[0,m-1]$。\n\n具体的，你需要输出一个 $n\\times m$ 的字符矩阵，若该函数经过整点 $(x,y)$，则**从左往右**第 $x+1$ 列，**从下往上**第 $y+1$ 行输出 `*`，否则为 `.`。", "inputFormat": "第一行三个整数 $n,m,k$。\n\n第二行 $k+1$ 个整数，其中第 $i$ 个整数表示 $a_{i-1}$。", "outputFormat": "输出共 $m$ 行，每行 $n$ 个字符，即输出该函数的函数图像。具体的，仅当函数经过 $(x,y)$ 时，**从左往右**第 $x+1$ 列，**从下往上**第 $y+1$ 行输出 `*`，否则为 `.`。", "hint": "样例 $1$ 解释：\n\n该函数为 $f(x)=x$，显然在 $x\\in[0,4], f(x)\\in[0,4]$ 时穿过 $(0,0),(1,1),(2,2),(3,3),(4,4)$ 这些整点。\n\n对于 $100\\%$ 的数据，$-12\\le a_i\\le 12\n$，$n=m$。每个测试点等分。\n\n| 测试点 | $n\\le$ | $m\\le$ | $k\\le$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $1$ | $1$ | $0$ | $-$ |\n| $2$ | $5$ | $5$ | $0$ | $-$ |\n| $3$ | $5$ | $5$ | $1$ | $a_1=1$ |\n| $4$ | $5$ | $5$ | $1$ | $a_0+a_1\\le 2$ |\n| $5$ | $10$ | $10$ | $1$ | $-$ |\n| $6$ | $10$ | $10$ | $2$ | $a_0=a_1=0,a_2\\ge n$ |\n| $7$ | $100$ | $100$ | $2$ | $-$ |\n| $8$ | $100$ | $100$ | $3$ | $-$ |\n| $9$ | $100$ | $100$ | $5$ | $-$ |\n| $10$ | $100$ | $100$ | $7$ | $-$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「GMOI R1-T1」Perfect Math Class", "background": "", "description": "Index 给了你一个函数如下：\n\n$$f(x)=a_kx^k+a_{k-1}x^{k-1}+\\cdots+a_1x^1+a_0$$\n\n画出它的函数图像（`*` 表示经过该点，`.` 表示不经过该点），大小为 $n\\times m$，其中 $x$ 的范围是 $[0,n-1]$，$f(x)$ 的范围是 $[0,m-1]$。\n\n具体的，你需要输出一个 $n\\times m$ 的字符矩阵，若该函数经过整点 $(x,y)$，则**从左往右**第 $x+1$ 列，**从下往上**第 $y+1$ 行输出 `*`，否则为 `.`。", "inputFormat": "第一行三个整数 $n,m,k$。\n\n第二行 $k+1$ 个整数，其中第 $i$ 个整数表示 $a_{i-1}$。", "outputFormat": "输出共 $m$ 行，每行 $n$ 个字符，即输出该函数的函数图像。具体的，仅当函数经过 $(x,y)$ 时，**从左往右**第 $x+1$ 列，**从下往上**第 $y+1$ 行输出 `*`，否则为 `.`。", "hint": "样例 $1$ 解释：\n\n该函数为 $f(x)=x$，显然在 $x\\in[0,4], f(x)\\in[0,4]$ 时穿过 $(0,0),(1,1),(2,2),(3,3),(4,4)$ 这些整点。\n\n对于 $100\\%$ 的数据，$-12\\le a_i\\le 12\n$，$n=m$。每个测试点等分。\n\n| 测试点 | $n\\le$ | $m\\le$ | $k\\le$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $1$ | $1$ | $0$ | $-$ |\n| $2$ | $5$ | $5$ | $0$ | $-$ |\n| $3$ | $5$ | $5$ | $1$ | $a_1=1$ |\n| $4$ | $5$ | $5$ | $1$ | $a_0+a_1\\le 2$ |\n| $5$ | $10$ | $10$ | $1$ | $-$ |\n| $6$ | $10$ | $10$ | $2$ | $a_0=a_1=0,a_2\\ge n$ |\n| $7$ | $100$ | $100$ | $2$ | $-$ |\n| $8$ | $100$ | $100$ | $3$ | $-$ |\n| $9$ | $100$ | $100$ | $5$ | $-$ |\n| $10$ | $100$ | $100$ | $7$ | $-$ |", "locale": "zh-CN"}}}
{"pid": "P8925", "type": "P", "difficulty": 2, "samples": [["2\n3 5\nL 1\nR 1", "-6\n10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "O2优化"], "title": "「GMOI R1-T2」Light", "background": "前置芝士：平面镜成像原理。\n\n因为百度的不太清楚，所以大家有不懂的可以自行搜索，也可以看本题的样例解释。", "description": "通道可以认为是一个无限长的坐标轴，在原点 $O$ 上有一盏灯，在坐标为 $-L$ 和 $R$ 的地方分别有两面镜子，这两个镜子构成了无尽的灯廊。\n\n为什么说无尽呢？是因为这两面镜子上理论上能呈现无穷个灯的像。现在，请你求出这盏灯左边或右边第 $x$ 个像的坐标。", "inputFormat": "第一行一个整数 $T$，代表询问个数。\n\n第二行两个整数 $L,R$，意思如题意中所描述。\n\n接下来 $T$ 行，每行先输入一个字符，再输入一个数 $x$。其中如果输入的字符是 `L` 表示左侧，如果是 `R` 表示右侧。请求出左侧或右侧第 $x$ 个像的坐标。\n\n保证字符是 `L` 或 `R` 中的一个。", "outputFormat": "$T$ 行，每行一个整数，为坐标值。", "hint": "[样例 $1$ 解释](https://www.luogu.com.cn/paste/4g9o1uzz)\n\n对于 $100\\%$ 的数据 $1\\le T\\le 5\\times 10^5$，$1\\le L,R \\le 10^7$，$1\\le x \\le 10^{10}$。\n\n| 测试点 | $T$ | $L,R$ | $x$ | 分数 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1\\sim3$ | $T=1$ | $1 \\le L,R \\le 10$ | $1 \\le x \\le 10$ | $15$ |\n| $4\\sim6$ | $T=1$ | $1 \\le L,R \\le 1000$ | $1 \\le x \\le 1000$ | $15$ |\n| $7\\sim11$ | $T \\le 1000$ | $1 \\le L,R \\le 10^7$ | $1 \\le x \\le 10^4 $ | $25$ |\n| $12\\sim16$ | $T \\le 10^5$ | $1 \\le L,R \\le 10^7$ | $1 \\le x \\le 10^9$ | $25$ |\n| $17\\sim20$ | $T \\le 5 \\times 10^5$ | $1 \\le L,R \\le 10^7$ | $1\\le x \\le 10^{10}$ | $20$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「GMOI R1-T2」Light", "background": "前置芝士：平面镜成像原理。\n\n因为百度的不太清楚，所以大家有不懂的可以自行搜索，也可以看本题的样例解释。", "description": "通道可以认为是一个无限长的坐标轴，在原点 $O$ 上有一盏灯，在坐标为 $-L$ 和 $R$ 的地方分别有两面镜子，这两个镜子构成了无尽的灯廊。\n\n为什么说无尽呢？是因为这两面镜子上理论上能呈现无穷个灯的像。现在，请你求出这盏灯左边或右边第 $x$ 个像的坐标。", "inputFormat": "第一行一个整数 $T$，代表询问个数。\n\n第二行两个整数 $L,R$，意思如题意中所描述。\n\n接下来 $T$ 行，每行先输入一个字符，再输入一个数 $x$。其中如果输入的字符是 `L` 表示左侧，如果是 `R` 表示右侧。请求出左侧或右侧第 $x$ 个像的坐标。\n\n保证字符是 `L` 或 `R` 中的一个。", "outputFormat": "$T$ 行，每行一个整数，为坐标值。", "hint": "[样例 $1$ 解释](https://www.luogu.com.cn/paste/4g9o1uzz)\n\n对于 $100\\%$ 的数据 $1\\le T\\le 5\\times 10^5$，$1\\le L,R \\le 10^7$，$1\\le x \\le 10^{10}$。\n\n| 测试点 | $T$ | $L,R$ | $x$ | 分数 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1\\sim3$ | $T=1$ | $1 \\le L,R \\le 10$ | $1 \\le x \\le 10$ | $15$ |\n| $4\\sim6$ | $T=1$ | $1 \\le L,R \\le 1000$ | $1 \\le x \\le 1000$ | $15$ |\n| $7\\sim11$ | $T \\le 1000$ | $1 \\le L,R \\le 10^7$ | $1 \\le x \\le 10^4 $ | $25$ |\n| $12\\sim16$ | $T \\le 10^5$ | $1 \\le L,R \\le 10^7$ | $1 \\le x \\le 10^9$ | $25$ |\n| $17\\sim20$ | $T \\le 5 \\times 10^5$ | $1 \\le L,R \\le 10^7$ | $1\\le x \\le 10^{10}$ | $20$ |", "locale": "zh-CN"}}}
{"pid": "P8926", "type": "P", "difficulty": 4, "samples": [["5\n10 1 3\n30 1 5\n997 24 35\n34 39 99\n210 1000 1001", "12\n40\n24\n244\n32"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "数论", "O2优化", "最大公约数 gcd"], "title": "「GMOI R1-T3」Number Pair", "background": "", "description": "我们定义满足如下条件的数对 $(x,y)$ 叫做奇妙数对：\n\n$k \\times \\gcd(x,y)=\\operatorname{lcm}(x,y)$ 并且 $P \\le \\gcd(x,y) \\le Q$（保证 $P \\le Q$）。\n\n有 $T$ 组数据，对于每一组数据，给定 $k,P,Q$ 三个数，求符合条件的数对 $(x,y)$ 的对数。\n\n**答案对 $10^9+7$ 取模。**", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据数量。\n\n接下来 $T$ 行，每行三个整数 $k,P,Q$。", "outputFormat": "对于每一组数据，给出对应答案，每组数据一行。\n\n", "hint": "**注意并不寻常的时间限制。**\n\n对于 $100\\%$ 的数据 $1 \\le k \\le 10^{16}$，$1 \\le T \\le 50$，$1 \\le P \\le Q \\le 2\\times 10^9$。\n\n| 测试点 | $k$ | $T$ | $P$ | $Q$ | 总分 |\n| :----------: | :----------: | :----------: | :-------------: | :----------: | :----------: |\n| $1\\sim 3$ | $k \\le 3$ | $T=1$ | $P=1$ | $Q=1$ | $15$ |\n| $4\\sim 8$ | $k \\le 100$ | $T \\le 8$ | $P \\le 30$ |  $Q \\le 30$ |$15$ |\n| $9\\sim 13$ | $k \\le 10^3$ | $T \\le 50$ | $P \\le 500$ | $Q \\le 500$ | $25$ |\n| $14\\sim 18$ | $k \\le 10^{12}$ | $T \\le 50$ | $P \\le 10^4$ | $Q \\le 10^4$ | $15$ |\n| $19\\sim 22$ | $k \\le 10^{13}$ | $T \\le 50$ | $P \\le 10^6$ | $Q \\le 10^6$ | $12$ |\n| $23\\sim 28$ | $k \\le 10^{16}$ | $T \\le 50$ | $P \\le 2\\times10^9$ | $Q \\le 2\\times10^9$ | $18$ |\n\n**本题保证 $k$ 随机生成，并不存在极限卡人数据，时限已经开到 std 两倍，请各位选手放心。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「GMOI R1-T3」Number Pair", "background": "", "description": "我们定义满足如下条件的数对 $(x,y)$ 叫做奇妙数对：\n\n$k \\times \\gcd(x,y)=\\operatorname{lcm}(x,y)$ 并且 $P \\le \\gcd(x,y) \\le Q$（保证 $P \\le Q$）。\n\n有 $T$ 组数据，对于每一组数据，给定 $k,P,Q$ 三个数，求符合条件的数对 $(x,y)$ 的对数。\n\n**答案对 $10^9+7$ 取模。**", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据数量。\n\n接下来 $T$ 行，每行三个整数 $k,P,Q$。", "outputFormat": "对于每一组数据，给出对应答案，每组数据一行。\n\n", "hint": "**注意并不寻常的时间限制。**\n\n对于 $100\\%$ 的数据 $1 \\le k \\le 10^{16}$，$1 \\le T \\le 50$，$1 \\le P \\le Q \\le 2\\times 10^9$。\n\n| 测试点 | $k$ | $T$ | $P$ | $Q$ | 总分 |\n| :----------: | :----------: | :----------: | :-------------: | :----------: | :----------: |\n| $1\\sim 3$ | $k \\le 3$ | $T=1$ | $P=1$ | $Q=1$ | $15$ |\n| $4\\sim 8$ | $k \\le 100$ | $T \\le 8$ | $P \\le 30$ |  $Q \\le 30$ |$15$ |\n| $9\\sim 13$ | $k \\le 10^3$ | $T \\le 50$ | $P \\le 500$ | $Q \\le 500$ | $25$ |\n| $14\\sim 18$ | $k \\le 10^{12}$ | $T \\le 50$ | $P \\le 10^4$ | $Q \\le 10^4$ | $15$ |\n| $19\\sim 22$ | $k \\le 10^{13}$ | $T \\le 50$ | $P \\le 10^6$ | $Q \\le 10^6$ | $12$ |\n| $23\\sim 28$ | $k \\le 10^{16}$ | $T \\le 50$ | $P \\le 2\\times10^9$ | $Q \\le 2\\times10^9$ | $18$ |\n\n**本题保证 $k$ 随机生成，并不存在极限卡人数据，时限已经开到 std 两倍，请各位选手放心。**", "locale": "zh-CN"}}}
{"pid": "P8927", "type": "P", "difficulty": 4, "samples": [["10\n2 3\n1 2 3 4 5 6 7 8 9 10", "131\n5 6 7 1 8 2 9 3 10 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "数学", "Special Judge", "O2优化"], "title": "「GMOI R1-T4」Rain", "background": "> **求雨**\n>\n>玉皇爷爷也姓张，\n>\n>为啥为难俺张*昌？\n>\n>三天之内不下雨，\n>\n>先扒龙皇庙，\n>\n>__再用大炮轰你娘。__\n\n如果再不下雨，张大帅就会轰掉全亚洲所有的宗教场所！\n\n博丽神社因为可以在外界被看到，自然也无法幸免于难，灵梦十分着急，准备使用祖传秘法求雨……", "description": "为了防止神社被“大炮开兮轰他娘”，灵梦需要求雨。\n\n求雨需要在一条笔直的路上建 $n$ 个法阵，编号为 $1,2,\\cdots,n$。\n\n给定一个长度为 $n$ 的数组 $a$，表示在 $a_1$ 到 $a_n$ 的位置建法阵，你要干的是给法阵编号。\n\n灵梦需要来检测法阵效果，她会从 $1$ 号法阵走到 $2$ 号，从 $2$ 号再走到 $3$ 号，直到走到 $n$ 号，再从 $n$ 号走回 $1$ 号。\n\n由于法阵的特殊效果，从 $i$ 个走到 $i+1$ 个的距离是 $\\left|a_i\\times p-a_{i+1}\\times q\\right|$。特别的，从 $n$ 号走回到 $1$ 号的距离是 $\\left|a_n\\times p-a_1\\times q\\right|$。$p,q$ 是给定的两个常数，$a_i,a_{i+1}$ 是两个法阵的位置。\n\n灵梦希望你来求一下最大的行走距离，并输出对应法阵从 $1$ 号到 $n$ 号的位置排列。（多个只需输出一个即可）", "inputFormat": "第一行一个整数 $n$，表示法阵数量。\n\n第二行两个整数 $p,q$，表示法阵的倍率常量。\n\n第三行 $n$ 个整数，表示数组 $a$。", "outputFormat": "第一行一个整数，表示答案。\n\n第二行 $n$ 个整数，表示对应位置 $a$ 的排列，按照编号从 $1$ 到 $n$ 输出。", "hint": "**本题开启 SPJ。**\n\n**本题读入量较大，建议使用较快的读入方式。**\n\n对于 $100\\%$ 的数据满足 $10\\le n\\le 10^6$，$1\\le p,q \\le 10^{5}$，$1\\le a_i\\le 10^{5}$。\n\n| 编号 | $n$ | $p,q$ | $a_i$ | 分数 |\n| :----------: | :----------: | :----------: | :----------:  | :----------: |\n| $1$ | $n=10$ | $p,q\\le 10^{3}$ | $a_i\\le 10^{3}$ | $4$ |\n| $2$ | $n=10$ | $p,q\\le 10^{3}$ | $a_i\\le 10^{3}$ | $5$ |\n| $3$ | $n=10$ | $p,q\\le 10^{3}$ | $a_i\\le 10^{3}$ | $5$ |\n| $4\\sim 6$  | $n=19$ | $p,q\\le 10^{5}$ | $a_i\\le 10^{5}$ | $10$ |\n| $7$ | $n\\le 10^{4}$ | $p,q\\le 10^{5}$ | $a_i\\le 10^{5}$ | $8$ |\n| $8$ | $n\\le 10^{4}$ | $p,q\\le 10^{5}$ | $a_i\\le 10^{5}$ | $9$ |\n| $9$ | $n\\le 10^{4}$ | $p,q\\le 10^{5}$ | $a_i\\le 10^{5}$ | $9$ |\n| $10\\sim 12$ | $n\\le 10^{6}$ | $p,q\\le 10^{5}$ | $a_i\\le 10^{5}$ | $10$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「GMOI R1-T4」Rain", "background": "> **求雨**\n>\n>玉皇爷爷也姓张，\n>\n>为啥为难俺张*昌？\n>\n>三天之内不下雨，\n>\n>先扒龙皇庙，\n>\n>__再用大炮轰你娘。__\n\n如果再不下雨，张大帅就会轰掉全亚洲所有的宗教场所！\n\n博丽神社因为可以在外界被看到，自然也无法幸免于难，灵梦十分着急，准备使用祖传秘法求雨……", "description": "为了防止神社被“大炮开兮轰他娘”，灵梦需要求雨。\n\n求雨需要在一条笔直的路上建 $n$ 个法阵，编号为 $1,2,\\cdots,n$。\n\n给定一个长度为 $n$ 的数组 $a$，表示在 $a_1$ 到 $a_n$ 的位置建法阵，你要干的是给法阵编号。\n\n灵梦需要来检测法阵效果，她会从 $1$ 号法阵走到 $2$ 号，从 $2$ 号再走到 $3$ 号，直到走到 $n$ 号，再从 $n$ 号走回 $1$ 号。\n\n由于法阵的特殊效果，从 $i$ 个走到 $i+1$ 个的距离是 $\\left|a_i\\times p-a_{i+1}\\times q\\right|$。特别的，从 $n$ 号走回到 $1$ 号的距离是 $\\left|a_n\\times p-a_1\\times q\\right|$。$p,q$ 是给定的两个常数，$a_i,a_{i+1}$ 是两个法阵的位置。\n\n灵梦希望你来求一下最大的行走距离，并输出对应法阵从 $1$ 号到 $n$ 号的位置排列。（多个只需输出一个即可）", "inputFormat": "第一行一个整数 $n$，表示法阵数量。\n\n第二行两个整数 $p,q$，表示法阵的倍率常量。\n\n第三行 $n$ 个整数，表示数组 $a$。", "outputFormat": "第一行一个整数，表示答案。\n\n第二行 $n$ 个整数，表示对应位置 $a$ 的排列，按照编号从 $1$ 到 $n$ 输出。", "hint": "**本题开启 SPJ。**\n\n**本题读入量较大，建议使用较快的读入方式。**\n\n对于 $100\\%$ 的数据满足 $10\\le n\\le 10^6$，$1\\le p,q \\le 10^{5}$，$1\\le a_i\\le 10^{5}$。\n\n| 编号 | $n$ | $p,q$ | $a_i$ | 分数 |\n| :----------: | :----------: | :----------: | :----------:  | :----------: |\n| $1$ | $n=10$ | $p,q\\le 10^{3}$ | $a_i\\le 10^{3}$ | $4$ |\n| $2$ | $n=10$ | $p,q\\le 10^{3}$ | $a_i\\le 10^{3}$ | $5$ |\n| $3$ | $n=10$ | $p,q\\le 10^{3}$ | $a_i\\le 10^{3}$ | $5$ |\n| $4\\sim 6$  | $n=19$ | $p,q\\le 10^{5}$ | $a_i\\le 10^{5}$ | $10$ |\n| $7$ | $n\\le 10^{4}$ | $p,q\\le 10^{5}$ | $a_i\\le 10^{5}$ | $8$ |\n| $8$ | $n\\le 10^{4}$ | $p,q\\le 10^{5}$ | $a_i\\le 10^{5}$ | $9$ |\n| $9$ | $n\\le 10^{4}$ | $p,q\\le 10^{5}$ | $a_i\\le 10^{5}$ | $9$ |\n| $10\\sim 12$ | $n\\le 10^{6}$ | $p,q\\le 10^{5}$ | $a_i\\le 10^{5}$ | $10$ |\n", "locale": "zh-CN"}}}
{"pid": "P8928", "type": "P", "difficulty": 2, "samples": [["3 3 10", "36"], ["114514 1919810 233", "696303234"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学"], "title": "「TERRA-OI R1」你不是神，但你的灵魂依然是我的盛宴", "background": "踏在这木质的平台上，嘎吱嘎吱作响，你从包里掏出了各式各样的药水，逐一饮下后一股暖意从心底升腾起来，你拿出了精心准备的诱饵，那是用三位仆从的精华凝聚而成，你将其高举头顶，想要引出那位噬神者。天空开始弥漫着蓝紫色的迷雾，这种氛围压得你喘不过气，恍惚间，你面前的空间开始撕裂出一条裂缝，一条身披紫色外壳的巨蟒从中钻出，你拿起了手上的巨剑，听着一声又一声的嘶吼，你知道这将是一场恶战......", "description": "请求出：\n\n$\\sum_{i=1}^{n} \\sum_{j=1}^{m}(i\\times j \\bmod p)$ \n\n的值，其中 $n,m,p$ 为给定的值。", "inputFormat": "一行三个用空格分隔的正整数 $n,m,p$，含义见题目描述。", "outputFormat": "一行一个整数表示答案，由于这个结果可能很大，请输出其对 $10^9+7$ 取模的结果。", "hint": "#### 【样例解释 #1】\n\n很显然 $i\\times j$ 只有 $[1,2,3,2,4,6,3,6,9]$ 这几种情况，这些情况的和为 $36$。\n\n------------\n\n#### 【数据范围】\n\n**本题采用捆绑测试。**\n\n| Subtask | Score | $n,m\\le$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $20$ | $10^3$ |\n| $2$ | $30$ | $10^6$ |\n| $3$ | $50$ | $10^{12}$ |\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m\\le10^{12}$，$1\\le p\\le10^3$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「TERRA-OI R1」你不是神，但你的灵魂依然是我的盛宴", "background": "踏在这木质的平台上，嘎吱嘎吱作响，你从包里掏出了各式各样的药水，逐一饮下后一股暖意从心底升腾起来，你拿出了精心准备的诱饵，那是用三位仆从的精华凝聚而成，你将其高举头顶，想要引出那位噬神者。天空开始弥漫着蓝紫色的迷雾，这种氛围压得你喘不过气，恍惚间，你面前的空间开始撕裂出一条裂缝，一条身披紫色外壳的巨蟒从中钻出，你拿起了手上的巨剑，听着一声又一声的嘶吼，你知道这将是一场恶战......", "description": "请求出：\n\n$\\sum_{i=1}^{n} \\sum_{j=1}^{m}(i\\times j \\bmod p)$ \n\n的值，其中 $n,m,p$ 为给定的值。", "inputFormat": "一行三个用空格分隔的正整数 $n,m,p$，含义见题目描述。", "outputFormat": "一行一个整数表示答案，由于这个结果可能很大，请输出其对 $10^9+7$ 取模的结果。", "hint": "#### 【样例解释 #1】\n\n很显然 $i\\times j$ 只有 $[1,2,3,2,4,6,3,6,9]$ 这几种情况，这些情况的和为 $36$。\n\n------------\n\n#### 【数据范围】\n\n**本题采用捆绑测试。**\n\n| Subtask | Score | $n,m\\le$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $20$ | $10^3$ |\n| $2$ | $30$ | $10^6$ |\n| $3$ | $50$ | $10^{12}$ |\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m\\le10^{12}$，$1\\le p\\le10^3$。\n", "locale": "zh-CN"}}}
{"pid": "P8929", "type": "P", "difficulty": 4, "samples": [["3 4\n0 3 1 1 2\n3 6 2 1 -2 1\n6 10 1 1 0\n1 4\n2 5\n2 114514\n2 2", "9\n2\n0\n0"], ["6 8\n0 4 2 1 -4 0 \n4 6 1 2 -10 \n6 11 1 1 -19 \n11 19 2 -1 -30 559 \n19 29 1 1 -58 \n29 38 1 1 -68 \n1 11\n2 4\n2 -1\n1 21\n2 -5\n2 2\n1 34\n2 1\n", "-8\n1\n4\n-37\n1\n2\n-34\n2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "二分", "O2优化", "差分"], "title": "「TERRA-OI R1」别得意，小子", "background": "战至中途，蓝紫色天空瞬间变为黑压压一片，噬神者身上一些紫色外壳开始脱落，化为更小的蟒蛇，这些小家伙从出现开始便不要命的向你冲过来，刚清理掉这些小家伙，迷雾中忽然涌现出一张血盆大口，噬神者正向你冲击而来......", "description": "现给定一个有 $n$ 段的分段函数，每一段可能是一个一次函数或者一个二次函数，并有 $q$ 次询问，每次询问 $x=k$ 时 $y$ 的取值或是 $y=k$ 与函数有多少个交点。\n\n", "inputFormat": "第一行两个用空格分隔的整数 $n,q$，表示函数段数与询问次数。\n\n从第 $2$ 行到 $n+1$ 行，先给出 $l_i$ $r_i$，表示这个分段函数对应的取值范围为 $(l_i,r_i]$（保证 $l_1=0$，$\\forall i\\in [1,n-1],r_i=l_{i+1}$）。然后读入有以下两种情况：\n\n- $1$ $k$ $b$，表示这个区间内是 $y=kx+b$ 的一个一次函数（保证 $k\\ne 0$）。\n- $2$ $a$ $b$ $c$，表示这个区间内是 $y=ax^2+bx+c$ 的二次函数（保证 $a\\ne 0$）。\n\n从第 $n+2$ 行到第 $n+q+1$ 行，每行两个用空格分隔的整数 $op,k$：\n\n- 若 $op=1$ ，表示求出当 $x=k$ 时 $y$ 的值（保证 $k\\in (0,r_n]$）。\n- 若 $op=2$ ，表示求出直线 $y=k$ 在 $(0,r_n]$ 范围内与整个分段函数有几个交点。", "outputFormat": "一共 $q$ 行，每行一个整数表示对于每个询问的答案。", "hint": "#### 【样例解释 #1】\n\n三段函数分别为 $y=x+2$，$y=x^2-2x+1$，$y=x$。\n\n对于当 $x=4$ 时套入第二段函数可以得到结果为 $9$。\n\n而直线 $y=5$ 只与第一段与第二段函数相交，并且各只有一个交点，所以结果为 $2$。\n\n显而易见，第三个询问对应的直线不与函数相交。\n\n第四个询问虽然与第一段函数交于 $x=0$ 的位置，但 $0$ 不在该函数区间内，故舍去。\n\n------------\n\n#### 【数据范围】\n\n**本题采用捆绑测试。**\n\n| Subtask | Score | $n,q\\le$ | limit |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $100$ | 无 |\n| $2$ | $15$ | $10^3$ | $r_n\\le 5\\times 10^3$ |\n| $3$ | $20$ | $2\\times 10^5$ | 不存在询问 $2$ |\n| $4$ | $25$ | $2\\times 10^5$ | 不存在二次函数 |\n| $5$ | $30$ | $2\\times 10^5$ | 无 |\n\n对于 $100\\%$ 的数据，$1\\le n,q\\le 2\\times 10^5$，$0\\le l_i,r_i\\le10^9$，$\\forall i\\in [1,n],r_i>l_i$ 。\n\n所有的函数系数均在 **$64$ 位有符号整型变量**存储范围内，并且运算结果与每个函数式中任何一项的最大值与最小值不会超过 **$64$ 位有符号整型变量**存储范围。所有询问参数均在 **$32$ 位有符号整型变量**范围内。\n\n（即 $-4\\times 10^{18}\\le k,a,b,c\\le 4\\times 10^{18}$，$-10^9\\le x\\le 10^9$）\n\n------------\n#### 【提示】\n\n采用浮点数据时建议使用 long double，避免产生精度问题。\n\nupd：添加一组 hack 数据，未通过会显示为“Unaccepted 100pts”。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「TERRA-OI R1」别得意，小子", "background": "战至中途，蓝紫色天空瞬间变为黑压压一片，噬神者身上一些紫色外壳开始脱落，化为更小的蟒蛇，这些小家伙从出现开始便不要命的向你冲过来，刚清理掉这些小家伙，迷雾中忽然涌现出一张血盆大口，噬神者正向你冲击而来......", "description": "现给定一个有 $n$ 段的分段函数，每一段可能是一个一次函数或者一个二次函数，并有 $q$ 次询问，每次询问 $x=k$ 时 $y$ 的取值或是 $y=k$ 与函数有多少个交点。\n\n", "inputFormat": "第一行两个用空格分隔的整数 $n,q$，表示函数段数与询问次数。\n\n从第 $2$ 行到 $n+1$ 行，先给出 $l_i$ $r_i$，表示这个分段函数对应的取值范围为 $(l_i,r_i]$（保证 $l_1=0$，$\\forall i\\in [1,n-1],r_i=l_{i+1}$）。然后读入有以下两种情况：\n\n- $1$ $k$ $b$，表示这个区间内是 $y=kx+b$ 的一个一次函数（保证 $k\\ne 0$）。\n- $2$ $a$ $b$ $c$，表示这个区间内是 $y=ax^2+bx+c$ 的二次函数（保证 $a\\ne 0$）。\n\n从第 $n+2$ 行到第 $n+q+1$ 行，每行两个用空格分隔的整数 $op,k$：\n\n- 若 $op=1$ ，表示求出当 $x=k$ 时 $y$ 的值（保证 $k\\in (0,r_n]$）。\n- 若 $op=2$ ，表示求出直线 $y=k$ 在 $(0,r_n]$ 范围内与整个分段函数有几个交点。", "outputFormat": "一共 $q$ 行，每行一个整数表示对于每个询问的答案。", "hint": "#### 【样例解释 #1】\n\n三段函数分别为 $y=x+2$，$y=x^2-2x+1$，$y=x$。\n\n对于当 $x=4$ 时套入第二段函数可以得到结果为 $9$。\n\n而直线 $y=5$ 只与第一段与第二段函数相交，并且各只有一个交点，所以结果为 $2$。\n\n显而易见，第三个询问对应的直线不与函数相交。\n\n第四个询问虽然与第一段函数交于 $x=0$ 的位置，但 $0$ 不在该函数区间内，故舍去。\n\n------------\n\n#### 【数据范围】\n\n**本题采用捆绑测试。**\n\n| Subtask | Score | $n,q\\le$ | limit |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $100$ | 无 |\n| $2$ | $15$ | $10^3$ | $r_n\\le 5\\times 10^3$ |\n| $3$ | $20$ | $2\\times 10^5$ | 不存在询问 $2$ |\n| $4$ | $25$ | $2\\times 10^5$ | 不存在二次函数 |\n| $5$ | $30$ | $2\\times 10^5$ | 无 |\n\n对于 $100\\%$ 的数据，$1\\le n,q\\le 2\\times 10^5$，$0\\le l_i,r_i\\le10^9$，$\\forall i\\in [1,n],r_i>l_i$ 。\n\n所有的函数系数均在 **$64$ 位有符号整型变量**存储范围内，并且运算结果与每个函数式中任何一项的最大值与最小值不会超过 **$64$ 位有符号整型变量**存储范围。所有询问参数均在 **$32$ 位有符号整型变量**范围内。\n\n（即 $-4\\times 10^{18}\\le k,a,b,c\\le 4\\times 10^{18}$，$-10^9\\le x\\le 10^9$）\n\n------------\n#### 【提示】\n\n采用浮点数据时建议使用 long double，避免产生精度问题。\n\nupd：添加一组 hack 数据，未通过会显示为“Unaccepted 100pts”。", "locale": "zh-CN"}}}
{"pid": "P8930", "type": "P", "difficulty": 6, "samples": [["6 5\n1 1 4 5 1 4\n2 1 6 1 5\n2 1 4 1 4\n1 1 1\n2 1 4 1 4\n2 2 6 1 5", "5\n4\n-1\n4"], ["12 12\n10 2 8 12 12 3 3 12 1 10 7 2\n2 3 4 1 11\n2 3 4 5 12\n2 1 3 1 3\n2 2 10 2 10\n2 8 10 5 10\n2 5 5 8 11\n2 10 12 7 10\n2 1 5 4 9\n1 12 6\n1 1 -6\n2 5 8 5 12\n2 5 8 2 12", "-1\n-1\n-1\n8\n-1\n-1\n-1\n-1\n-1\n12"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["莫队", "O2优化", "分块"], "title": "「TERRA-OI R1」神，不惧死亡", "background": "战斗已经到了白热化阶段，你已经精疲力竭，手臂因承受不住手中巨剑重量不住地发抖，噬神者的紫色外壳已经脱落大半，似乎再承受几次重击就会碎落一地。天空中紫色的迷雾开始变得暗淡，空间由于被不断撕裂而逐渐扭曲。在你的身前，噬神者最后一次撕开裂缝，用最原始的方式向你发起最后一击。你握紧手中的巨剑，准备迎接这最后一击，即使你清楚这是神明吞噬者最后的倔强，可你依然不敢放松一分一毫。最后一击过后，远处响起了钟声，战斗终将落下帷幕......", "description": "李子要在一个长度为 $n$ 的序列 $a$ 上玩游戏，他每次会把下标在 $[l,r]$ 范围内，且取值在 $[p,q]$ 范围内的所有数全部找出来，每次他可以选择其中两个相同的值，并进行**抵消**操作，将这两个数从数列中删除。当且仅当一个原本存在的值被消除掉后，所有值小于这个数的每个值全部要被删除一次（例如数列中原本有三个 $2$，进行一次删除后将会仅剩两个 $2$），并且这个游戏将会立即停止。\n\n李子会不止一次的玩这个游戏，并且每次取的区间都不相同，而且，为了加大游戏难度，李子会时不时的修改序列中某个数的值。\n\n现在李子想让剩下的数列中的最小值尽可能大，需要请你针对每次游戏，输出这个最大的最小值。特别地，如果这个游戏无法停止或者存在一种方案可以消除整个数列，输出 $-1$。", "inputFormat": "第一行两个用空格分隔的正整数 $n,m$，含义见题目描述。\n\n第二行 $n$ 个用空格分隔的正整数，表示对应 $a$ 序列。\n\n第三行到第 $m+2$ 行，每行有以下两种情况：\n\n- $1$ $p$ $x$ 表示给 $a_p$ 的值加上 $x$。\n- $2$ $l$ $r$ $p$ $q$ 表示询问将下标属于 $[l,r]$，取值属于 $[p,q]$ 的数列取出进行游戏的结果。", "outputFormat": "针对每个询问 $2$，输出一行一个整数表示答案。", "hint": "#### 【样例解释 #1】\n\n第一个询问对应的数列为 $[1,1,4,5,1,4]$，我们将两个 $1$ 先抵消，再抵消两个 $4$，此时比 $4$ 小的 $1$ 将会删除一次，整个序列只剩一个 $5$。\n\n第二个询问针对前 $4$ 个数，且由于 $5$ 不属于 $[1,4]$ 值域范围，所以数列为 $[1,1,4]$，将两个 $1$ 抵消后游戏直接结束，答案为 $4$。\n\n第三次修改将 $a_1$ 加 $1$，修改后数列为 $[2,1,4,5,1,4]$。\n\n第四次询问对应的数列为 $[2,1,4]$，所有数据都只出现一次，没办法进行抵消操作，游戏无法停止所以输出 $-1$。\n\n第五次询问的数列为 $[1,4,5,1,4]$，我们选择将两个 $1$ 抵消，由于数列中不再有 $1$，游戏结束，最小为 $4$。你也可以抵消两个 $4$，但这样答案为 $1$，比 $4$ 要小。\n\n\n------------\n\n#### 【数据范围】\n\n**本题采用捆绑测试。**\n\n| Subtask | Score | $n,m\\le$ | limit |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $10^3$ | 无 |\n| $2$ | $20$ | $10^5$ | 保证不存在操作 $1$ |\n| $3$ | $30$ | $10^5$ | 保证对于每个操作 $2$ ，$p=1,q=n$ |\n| $4$ | $40$ | $10^5$ | 无 |\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le10^5$，对于任何时刻 $\\forall i,a_i\\in[1,n]$。\n\n对于每个操作 $1$，$1\\le p\\le n$，$-n+1\\le x\\le n-1$ 并且 $-a_p<x\\le n-a_p$。\n\n对于每个询问 $2$，$1\\le l \\le r \\le n$，$1\\le p \\le q \\le n$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「TERRA-OI R1」神，不惧死亡", "background": "战斗已经到了白热化阶段，你已经精疲力竭，手臂因承受不住手中巨剑重量不住地发抖，噬神者的紫色外壳已经脱落大半，似乎再承受几次重击就会碎落一地。天空中紫色的迷雾开始变得暗淡，空间由于被不断撕裂而逐渐扭曲。在你的身前，噬神者最后一次撕开裂缝，用最原始的方式向你发起最后一击。你握紧手中的巨剑，准备迎接这最后一击，即使你清楚这是神明吞噬者最后的倔强，可你依然不敢放松一分一毫。最后一击过后，远处响起了钟声，战斗终将落下帷幕......", "description": "李子要在一个长度为 $n$ 的序列 $a$ 上玩游戏，他每次会把下标在 $[l,r]$ 范围内，且取值在 $[p,q]$ 范围内的所有数全部找出来，每次他可以选择其中两个相同的值，并进行**抵消**操作，将这两个数从数列中删除。当且仅当一个原本存在的值被消除掉后，所有值小于这个数的每个值全部要被删除一次（例如数列中原本有三个 $2$，进行一次删除后将会仅剩两个 $2$），并且这个游戏将会立即停止。\n\n李子会不止一次的玩这个游戏，并且每次取的区间都不相同，而且，为了加大游戏难度，李子会时不时的修改序列中某个数的值。\n\n现在李子想让剩下的数列中的最小值尽可能大，需要请你针对每次游戏，输出这个最大的最小值。特别地，如果这个游戏无法停止或者存在一种方案可以消除整个数列，输出 $-1$。", "inputFormat": "第一行两个用空格分隔的正整数 $n,m$，含义见题目描述。\n\n第二行 $n$ 个用空格分隔的正整数，表示对应 $a$ 序列。\n\n第三行到第 $m+2$ 行，每行有以下两种情况：\n\n- $1$ $p$ $x$ 表示给 $a_p$ 的值加上 $x$。\n- $2$ $l$ $r$ $p$ $q$ 表示询问将下标属于 $[l,r]$，取值属于 $[p,q]$ 的数列取出进行游戏的结果。", "outputFormat": "针对每个询问 $2$，输出一行一个整数表示答案。", "hint": "#### 【样例解释 #1】\n\n第一个询问对应的数列为 $[1,1,4,5,1,4]$，我们将两个 $1$ 先抵消，再抵消两个 $4$，此时比 $4$ 小的 $1$ 将会删除一次，整个序列只剩一个 $5$。\n\n第二个询问针对前 $4$ 个数，且由于 $5$ 不属于 $[1,4]$ 值域范围，所以数列为 $[1,1,4]$，将两个 $1$ 抵消后游戏直接结束，答案为 $4$。\n\n第三次修改将 $a_1$ 加 $1$，修改后数列为 $[2,1,4,5,1,4]$。\n\n第四次询问对应的数列为 $[2,1,4]$，所有数据都只出现一次，没办法进行抵消操作，游戏无法停止所以输出 $-1$。\n\n第五次询问的数列为 $[1,4,5,1,4]$，我们选择将两个 $1$ 抵消，由于数列中不再有 $1$，游戏结束，最小为 $4$。你也可以抵消两个 $4$，但这样答案为 $1$，比 $4$ 要小。\n\n\n------------\n\n#### 【数据范围】\n\n**本题采用捆绑测试。**\n\n| Subtask | Score | $n,m\\le$ | limit |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $10^3$ | 无 |\n| $2$ | $20$ | $10^5$ | 保证不存在操作 $1$ |\n| $3$ | $30$ | $10^5$ | 保证对于每个操作 $2$ ，$p=1,q=n$ |\n| $4$ | $40$ | $10^5$ | 无 |\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le10^5$，对于任何时刻 $\\forall i,a_i\\in[1,n]$。\n\n对于每个操作 $1$，$1\\le p\\le n$，$-n+1\\le x\\le n-1$ 并且 $-a_p<x\\le n-a_p$。\n\n对于每个询问 $2$，$1\\le l \\le r \\le n$，$1\\le p \\le q \\le n$。\n", "locale": "zh-CN"}}}
{"pid": "P8931", "type": "P", "difficulty": 2, "samples": [["3 4", "12"], ["2\n3 3\n5 7 9\n7 7 7\n3 3\n1 2 3\n2 2 2", "2 2 2 \n2 2 2 \n"], ["2\n3 3\n4 4 5\n4 5 6\n3 3\n1 1 3\n1 2 3\n", "2 3 3\n2 2 3\n"]], "limits": {"time": [1000, 1000, 1000], "memory": [524288, 524288, 524288]}, "tags": ["2023", "提交答案", "Special Judge", "O2优化", "语言月赛"], "title": "[入门赛 #10] Hack Problem P", "background": "这是一道 **hack 题**。在此类型的题目中，你将得到若干个问题和若干个解决对应问题的代码，但是给出的代码不能对于某些输入给出正确的输出。不能给出正确的输出的情况包括：\n\n1. 输出错误的结果。\n2. 运行超时。\n3. 产生一些运行时未定义行为。目前技术可检测的未定义行为仅包括数组越界。\n\n对于每个问题，你需要提交一份符合要求的输入数据，使得给定的代码不能给出正确的输出。你可以直接使用『提交答案』功能，也可以提交一份以任何语言写成的数据生成器。\n\n---\n**提示：如果你使用提交答案功能，请在提交其他题目时记得将语言改回你所使用的语言**", "description": "以下给出三个问题的题目描述：\n\n#### 问题 1\n\n给出两个正整数 $x, y$，保证它们的最小公倍数（$\\mathrm{lcm}$）不大于 $10^9$。求它们的最小公倍数。\n\n#### 问题 2\n\n**多组数据**，给定一个长度为 $n$ 的数组 $[a_1, a_2, \\dots a_n]$，保证数组单调递增。有 $q$ 次询问，每次给出一个整数 $x$，求数组中有多少数小于等于 $x$。\n\n#### 问题 3\n\n**多组数据**，给定一个长度为 $n$ 的数组 $[a_1, a_2, \\dots a_n]$，有 $q$ 次询问，每次给出一个整数 $x$，求数组中有多少数小于等于 $x$。\n\n注：问题 $2$ 和问题 $3$ 除了在是否保证数组递增上有差异外，在数据范围上也有区别，见下。", "inputFormat": "#### 问题 1\n\n输入只有一行两个整数，依次表示 $x$ 和 $y$。\n\n#### 问题 2\n\n第一行是一个整数 $T$，表示测试数据组数。  \n接下来按顺序给出每组数据的输入。  \n每组数据第一行是两个整数，依次表示数组 $a$ 的长度 $n$ 和询问次数 $q$。  \n每组数据第二行有 $n$ 个整数，依次表示 $a_1, a_2, \\dots a_n$。  \n每组数据第三行有 $q$ 个整数，依次表示 $q$ 次询问给出的 $x$。\n\n#### 问题 3\n\n第一行是一个整数 $T$，表示测试数据组数。  \n接下来按顺序给出每组数据的输入。  \n每组数据第一行是两个整数，依次表示数组 $a$ 的长度 $n$ 和询问次数 $q$。  \n每组数据第二行有 $n$ 个整数，依次表示 $a_1, a_2, \\dots a_n$。  \n每组数据第三行有 $q$ 个整数，依次表示 $q$ 次询问给出的 $x$。", "outputFormat": "#### 问题 1\n\n输出只有一行一个整数，表示两数的最小公倍数。\n\n#### 问题 2\n\n对每组数据，输出一行 $q$ 个整数，依次表示每次询问的答案。\n\n#### 问题 3\n\n对每组数据，输出一行 $q$ 个整数，依次表示每次询问的答案。", "hint": "### 样例组与实际输入的说明\n\n三个样例分别对应三个问题的样例输入输出。\n\n如果你直接采用『提交答案』的方式，请分别将三个输入数据命名为 `1.in`、`2.in`、`3.in`，并打成 zip 压缩包进行提交；\n\n如果你采用提交数据生成器的方式，你的生成器可以从标准输入读入一个整数 $x$，满足 $1 \\leq x \\leq 3$，表示该测试点对应的问题编号，然后**输出对应的输入数据**。\n\n显然，你的程序不应该读入『输入格式』里提到的任何内容（而应该构造它们），也不应该输出『样例输出』里提到的任何内容（而是只输出你构造的输入数据）。你不应该使用样例测试你的程序，这只是对三个问题的样例说明。\n\n### 数据规模要求\n\n你给出的数据必须满足如下要求：\n\n1. 完全符合『输入格式』的规定，不能有多余的输入，但是可以有行末空格和文末回车。\n2. 数据中所有的数字都应为整数。\n3. 对于问题 1，$1 \\leq x, y \\leq 10^9$，且你**必须保证**两数的最小公倍数也不超过 $10^9$。\n4. 对于问题 2，$1 \\leq T \\leq 3$，$1 \\leq n,q \\leq 10^5$，$1 \\leq a_i, x \\leq 10^9$。\n5. 对于问题 3，$1 \\leq T \\leq 3$，$1 \\leq n, q, a_i, x \\leq 10^6$。\n\n### 目标代码\n\n你需要 hack 如下的代码：\n\n#### 问题 1\n\n```cpp\n#include <iostream>\n#include <algorithm>\n\nint main() {\n  int x, y;\n  std::cin >> x >> y;\n  int ans = x * y / std::__gcd(x, y);\n  std::cout << ans << std::endl;\n}\n```\n\n#### 问题 2\n\n```cpp\n#include <iostream>\n#include <algorithm>\n\nconst int maxn = 1000003;\n\nint T;\nint n, q;\nint a[maxn], b[maxn];\n\nint find(int x) {\n  int l = 1, r = n;\n  int ans = 0;\n  while (l < r) {\n    int mid = (l + r) >> 1;\n    if (a[mid] <= x) {\n      ans = mid;\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  return ans;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  for (std::cin >> T; T; --T) {\n    std::cin >> n >> q;\n    for (int i = 1; i <= n; ++i) {\n      std::cin >> a[i];\n    }\n    for (int x; q; --q) {\n      std::cin >> x;\n      std::cout << find(x) << \" \";\n    }\n    std::cout << std::endl;\n  }\n}\n```\n\n#### 问题 3\n\n```cpp\n#include <iostream>\n\nconst int maxn = 1000003;\n\nint T;\nint n, q;\nint a[maxn], b[maxn];\n\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  for (std::cin >> T; T; --T) {\n    std::cin >> n >> q;\n    for (int i = 1; i <= n; ++i) {\n      std::cin >> a[i];\n    }\n    for (int i = 1; i <= n; ++i) {\n      b[a[i]]++;\n    }\n    for (int i = 1; i < maxn; ++i) b[i] += b[i - 1];\n    for (int x; q; --q) {\n      std::cin >> x;\n      std::cout << b[x] << \" \\n\"[q == 1];\n    }\n  }\n}\n```\n\n目标代码的编译选项为 `-std=c++14 -fno-asm -O2`。编译器为洛谷提供的 g++。你可以在『在线 IDE』中选择 C++14 语言来获得完全相同的编译环境。\n\n### 判分说明\n\n本题共三个测试点，分别对应三个问题，每个问题 hack 成功则对应测试点返回 accepted。\n\n#### 数据判定\n\n你给出的数据必须完全符合『数据规模要求』，否则将得到 Unaccepted 的结果。\n\n#### 超时判定\n\n程序每执行若干条指令，我们会检测一遍程序的运行时间。我们保证两次检测之间的指令条数是一个输入规模无关的量，也即每执行 $O(1)$ 条指令会进行一次检测。且两次检测之间的指令条数不会太多，一般不超过 $100$ 条 C++ 语句。\n\n如果程序的运行时间超过 $500 \\text{ms}$，则判定为程序运行超时，返回 accepted 结果。\n\n#### 结果错误判定\n\n如果程序在规定的时间内结束且给出了一个输出，我们会比较这个输出和**完全正确的输出**，如果二者不同，则判定为 hack 成功，返回 accepted 结果。\n\n#### 未定义行为判定\n\n我们会在每次**显式**的调用数组元素前判断数组下标是否超过数组范围，如果超过，则判定为 hack 成功，返回 accepted 结果。\n\n这就是说，如果你希望通过未定义行为进行 hack，只能对显式的调用数组元素的行为进行 hack。\n\n### 样例程序\n\n这是一份可以帮你理解你需要输出的内容的样例程序，**但它不能给出正确的 hack 数据**。直接提交此程序不会得分。\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n  int taskId;\n  cin >> taskId;\n  if (taskId == 1) {\n    cout << \"\" <<endl;\n  } else if (taskId == 2) {\n    cout << \"\" << endl;\n  } else if (taskId == 3) {\n    cout << \"\" << endl;\n  } else { // 这个 else 不会被执行\n    cout << \"QiHai Nanami\" << endl;\n  }\n}\n```\n\n如果你使用『提交答案』功能，请务必保证打开压缩包后能且仅能**直接**看到三个 `.in` 文件。这就是说，文件结构必须是：\n\n```plain\nans.zip\n |---1.in\n |---2.in\n |---3.in\n```\n\n三个文件不应该被额外的文件夹包含，即文件结构不能是：\n\n```plain\nans.zip\n |---ans(folder)\n      |---1.in\n      |---2.in\n      |---3.in\n```\n\n### 关于评测信息的说明\n\n如果 hack 成功，对应测试点的信息为 accepted。如果返回其他信息，说明程序本身有误。\n\n例如，如果返回 TLE，不代表成功的将对应程序 hack 至超时，而是表示数据生成器本身运行超时，测试点不得分。\n\n特别的，返回 UKE 结果可能是数据不合法（有多余内容、缺少内容或数据范围不符合要求）。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[入门赛 #10] Hack Problem P", "background": "这是一道 **hack 题**。在此类型的题目中，你将得到若干个问题和若干个解决对应问题的代码，但是给出的代码不能对于某些输入给出正确的输出。不能给出正确的输出的情况包括：\n\n1. 输出错误的结果。\n2. 运行超时。\n3. 产生一些运行时未定义行为。目前技术可检测的未定义行为仅包括数组越界。\n\n对于每个问题，你需要提交一份符合要求的输入数据，使得给定的代码不能给出正确的输出。你可以直接使用『提交答案』功能，也可以提交一份以任何语言写成的数据生成器。\n\n---\n**提示：如果你使用提交答案功能，请在提交其他题目时记得将语言改回你所使用的语言**", "description": "以下给出三个问题的题目描述：\n\n#### 问题 1\n\n给出两个正整数 $x, y$，保证它们的最小公倍数（$\\mathrm{lcm}$）不大于 $10^9$。求它们的最小公倍数。\n\n#### 问题 2\n\n**多组数据**，给定一个长度为 $n$ 的数组 $[a_1, a_2, \\dots a_n]$，保证数组单调递增。有 $q$ 次询问，每次给出一个整数 $x$，求数组中有多少数小于等于 $x$。\n\n#### 问题 3\n\n**多组数据**，给定一个长度为 $n$ 的数组 $[a_1, a_2, \\dots a_n]$，有 $q$ 次询问，每次给出一个整数 $x$，求数组中有多少数小于等于 $x$。\n\n注：问题 $2$ 和问题 $3$ 除了在是否保证数组递增上有差异外，在数据范围上也有区别，见下。", "inputFormat": "#### 问题 1\n\n输入只有一行两个整数，依次表示 $x$ 和 $y$。\n\n#### 问题 2\n\n第一行是一个整数 $T$，表示测试数据组数。  \n接下来按顺序给出每组数据的输入。  \n每组数据第一行是两个整数，依次表示数组 $a$ 的长度 $n$ 和询问次数 $q$。  \n每组数据第二行有 $n$ 个整数，依次表示 $a_1, a_2, \\dots a_n$。  \n每组数据第三行有 $q$ 个整数，依次表示 $q$ 次询问给出的 $x$。\n\n#### 问题 3\n\n第一行是一个整数 $T$，表示测试数据组数。  \n接下来按顺序给出每组数据的输入。  \n每组数据第一行是两个整数，依次表示数组 $a$ 的长度 $n$ 和询问次数 $q$。  \n每组数据第二行有 $n$ 个整数，依次表示 $a_1, a_2, \\dots a_n$。  \n每组数据第三行有 $q$ 个整数，依次表示 $q$ 次询问给出的 $x$。", "outputFormat": "#### 问题 1\n\n输出只有一行一个整数，表示两数的最小公倍数。\n\n#### 问题 2\n\n对每组数据，输出一行 $q$ 个整数，依次表示每次询问的答案。\n\n#### 问题 3\n\n对每组数据，输出一行 $q$ 个整数，依次表示每次询问的答案。", "hint": "### 样例组与实际输入的说明\n\n三个样例分别对应三个问题的样例输入输出。\n\n如果你直接采用『提交答案』的方式，请分别将三个输入数据命名为 `1.in`、`2.in`、`3.in`，并打成 zip 压缩包进行提交；\n\n如果你采用提交数据生成器的方式，你的生成器可以从标准输入读入一个整数 $x$，满足 $1 \\leq x \\leq 3$，表示该测试点对应的问题编号，然后**输出对应的输入数据**。\n\n显然，你的程序不应该读入『输入格式』里提到的任何内容（而应该构造它们），也不应该输出『样例输出』里提到的任何内容（而是只输出你构造的输入数据）。你不应该使用样例测试你的程序，这只是对三个问题的样例说明。\n\n### 数据规模要求\n\n你给出的数据必须满足如下要求：\n\n1. 完全符合『输入格式』的规定，不能有多余的输入，但是可以有行末空格和文末回车。\n2. 数据中所有的数字都应为整数。\n3. 对于问题 1，$1 \\leq x, y \\leq 10^9$，且你**必须保证**两数的最小公倍数也不超过 $10^9$。\n4. 对于问题 2，$1 \\leq T \\leq 3$，$1 \\leq n,q \\leq 10^5$，$1 \\leq a_i, x \\leq 10^9$。\n5. 对于问题 3，$1 \\leq T \\leq 3$，$1 \\leq n, q, a_i, x \\leq 10^6$。\n\n### 目标代码\n\n你需要 hack 如下的代码：\n\n#### 问题 1\n\n```cpp\n#include <iostream>\n#include <algorithm>\n\nint main() {\n  int x, y;\n  std::cin >> x >> y;\n  int ans = x * y / std::__gcd(x, y);\n  std::cout << ans << std::endl;\n}\n```\n\n#### 问题 2\n\n```cpp\n#include <iostream>\n#include <algorithm>\n\nconst int maxn = 1000003;\n\nint T;\nint n, q;\nint a[maxn], b[maxn];\n\nint find(int x) {\n  int l = 1, r = n;\n  int ans = 0;\n  while (l < r) {\n    int mid = (l + r) >> 1;\n    if (a[mid] <= x) {\n      ans = mid;\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  return ans;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  for (std::cin >> T; T; --T) {\n    std::cin >> n >> q;\n    for (int i = 1; i <= n; ++i) {\n      std::cin >> a[i];\n    }\n    for (int x; q; --q) {\n      std::cin >> x;\n      std::cout << find(x) << \" \";\n    }\n    std::cout << std::endl;\n  }\n}\n```\n\n#### 问题 3\n\n```cpp\n#include <iostream>\n\nconst int maxn = 1000003;\n\nint T;\nint n, q;\nint a[maxn], b[maxn];\n\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  for (std::cin >> T; T; --T) {\n    std::cin >> n >> q;\n    for (int i = 1; i <= n; ++i) {\n      std::cin >> a[i];\n    }\n    for (int i = 1; i <= n; ++i) {\n      b[a[i]]++;\n    }\n    for (int i = 1; i < maxn; ++i) b[i] += b[i - 1];\n    for (int x; q; --q) {\n      std::cin >> x;\n      std::cout << b[x] << \" \\n\"[q == 1];\n    }\n  }\n}\n```\n\n目标代码的编译选项为 `-std=c++14 -fno-asm -O2`。编译器为洛谷提供的 g++。你可以在『在线 IDE』中选择 C++14 语言来获得完全相同的编译环境。\n\n### 判分说明\n\n本题共三个测试点，分别对应三个问题，每个问题 hack 成功则对应测试点返回 accepted。\n\n#### 数据判定\n\n你给出的数据必须完全符合『数据规模要求』，否则将得到 Unaccepted 的结果。\n\n#### 超时判定\n\n程序每执行若干条指令，我们会检测一遍程序的运行时间。我们保证两次检测之间的指令条数是一个输入规模无关的量，也即每执行 $O(1)$ 条指令会进行一次检测。且两次检测之间的指令条数不会太多，一般不超过 $100$ 条 C++ 语句。\n\n如果程序的运行时间超过 $500 \\text{ms}$，则判定为程序运行超时，返回 accepted 结果。\n\n#### 结果错误判定\n\n如果程序在规定的时间内结束且给出了一个输出，我们会比较这个输出和**完全正确的输出**，如果二者不同，则判定为 hack 成功，返回 accepted 结果。\n\n#### 未定义行为判定\n\n我们会在每次**显式**的调用数组元素前判断数组下标是否超过数组范围，如果超过，则判定为 hack 成功，返回 accepted 结果。\n\n这就是说，如果你希望通过未定义行为进行 hack，只能对显式的调用数组元素的行为进行 hack。\n\n### 样例程序\n\n这是一份可以帮你理解你需要输出的内容的样例程序，**但它不能给出正确的 hack 数据**。直接提交此程序不会得分。\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n  int taskId;\n  cin >> taskId;\n  if (taskId == 1) {\n    cout << \"\" <<endl;\n  } else if (taskId == 2) {\n    cout << \"\" << endl;\n  } else if (taskId == 3) {\n    cout << \"\" << endl;\n  } else { // 这个 else 不会被执行\n    cout << \"QiHai Nanami\" << endl;\n  }\n}\n```\n\n如果你使用『提交答案』功能，请务必保证打开压缩包后能且仅能**直接**看到三个 `.in` 文件。这就是说，文件结构必须是：\n\n```plain\nans.zip\n |---1.in\n |---2.in\n |---3.in\n```\n\n三个文件不应该被额外的文件夹包含，即文件结构不能是：\n\n```plain\nans.zip\n |---ans(folder)\n      |---1.in\n      |---2.in\n      |---3.in\n```\n\n### 关于评测信息的说明\n\n如果 hack 成功，对应测试点的信息为 accepted。如果返回其他信息，说明程序本身有误。\n\n例如，如果返回 TLE，不代表成功的将对应程序 hack 至超时，而是表示数据生成器本身运行超时，测试点不得分。\n\n特别的，返回 UKE 结果可能是数据不合法（有多余内容、缺少内容或数据范围不符合要求）。", "locale": "zh-CN"}}}
{"pid": "P8932", "type": "P", "difficulty": 3, "samples": [["2\naabc\n2 b\n4 b", "2\n2\n1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["模拟", "2023", "洛谷原创"], "title": "[JRKSJ R7] Clock Paradox", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/47sjcgd5.png)\n\n一分钟后的出题人阻止了这个时刻的出题人写一个有趣的题目背景。\n\n（题目背景图片来自 Phigros 曲绘，如有侵权，请告知出题人。）", "description": "给你一个字符串 $S$，设 $S=\\overline{s_1s_2\\dots s_n}$。\n\n有一个字符串 $T$，初始时 $T=S$，你可以进行若干次操作，每次操作可以选取 $S$ 一个子串并插入到 $T$ 的任意位置。\n\n你希望经过若干次操作后，$T=\\overline{s_1s_1s_2s_2\\dots s_ns_n}$，定义 $f(S)$ 为满足此条件所需的最少的操作次数。\n\n此外，字符串 $S$ 还会发生一些改变。具体地，有 $q$ 次修改操作，每次修改操作会给出 $p$ 和 $\\texttt{c}$，表示令 $s_p\\gets \\texttt{c}$。$\\texttt{c}$ 表示任意一个小写字母，而并非 ASCII 为 $99$ 的字符。\n\n你需要在最开始和每次修改后求出 $f(S)$ 的值。", "inputFormat": "第一行一个整数 $q$ 表示修改次数。\\\n第二行仅由小写字母构成的字符串 $S$。\\\n接下来 $q$ 行，每行一个整数 $p$ 和一个小写字母 $\\texttt{c}$ 表示一次修改。", "outputFormat": "共有 $q+1$ 行，每行一个整数表示答案。", "hint": "Idea：cyffff，Solution：cyffff，Code：cyffff，Data：cyffff\n\n**Clock Paradox - WyvernP (Insane12.6)**\n\n**本题输入输出文件较大，请使用恰当的输入输出方式。**  \n\n### 提示\n\n称字符串 $A$ 是字符串 $S$ 的子串当且仅当存在 $1\\le l\\le r\\le |S|$ 使得 $A=\\overline{s_ls_{l+1}\\dots s_{r}}$。\n\n### 样例解释\n所有修改前，$f(S)$ 的计算方法如下：\n\n初始时，$S=T=\\texttt{aabc}$。\n\n第一次操作，选取 $S$ 的子串 $\\texttt{aa}$，插入到 $T$ 的最前端，操作后 $T=\\texttt{aaaabc}$。\n\n第二次操作，选取 $S$ 的子串 $\\texttt{bc}$，插入到 $T$ 的第 $5$ 个字符后，操作后 $T=\\texttt{aaaabbcc}$，符合要求。\n\n经过一次修改、两次修改后的 $S$ 分别等于 $\\texttt{abbc}$ 和 $\\texttt{abbb}$，这两次修改后 $f(S)$ 分别是 $2$ 和 $1$。\n### 数据规模\n\n本题采用捆绑测试。\n| $\\text{Subtask}$ | $\\vert S\\vert\\le$ | $q\\le$ | $\\text{Score}$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $5$ | $0$ | $10$ |\n| $2$ | $10^4$ | $10^4$ | $20$ |\n| $3$ | $5\\times10^5$ | $0$ | $20$ |\n| $4$ | $5\\times10^5$ | $5\\times 10^5$ | $20$ |\n| $5$ | $3\\times10^6$ | $3\\times 10^6$ | $30$ |\n\n对于 $100\\%$ 的数据，$1\\le|S|\\le3\\times10^6$，$0\\le q\\le 3\\times10^6$，保证 $S$ 仅由小写字母构成，保证 $\\texttt{c}$ 为单个小写字母。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JRKSJ R7] Clock Paradox", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/47sjcgd5.png)\n\n一分钟后的出题人阻止了这个时刻的出题人写一个有趣的题目背景。\n\n（题目背景图片来自 Phigros 曲绘，如有侵权，请告知出题人。）", "description": "给你一个字符串 $S$，设 $S=\\overline{s_1s_2\\dots s_n}$。\n\n有一个字符串 $T$，初始时 $T=S$，你可以进行若干次操作，每次操作可以选取 $S$ 一个子串并插入到 $T$ 的任意位置。\n\n你希望经过若干次操作后，$T=\\overline{s_1s_1s_2s_2\\dots s_ns_n}$，定义 $f(S)$ 为满足此条件所需的最少的操作次数。\n\n此外，字符串 $S$ 还会发生一些改变。具体地，有 $q$ 次修改操作，每次修改操作会给出 $p$ 和 $\\texttt{c}$，表示令 $s_p\\gets \\texttt{c}$。$\\texttt{c}$ 表示任意一个小写字母，而并非 ASCII 为 $99$ 的字符。\n\n你需要在最开始和每次修改后求出 $f(S)$ 的值。", "inputFormat": "第一行一个整数 $q$ 表示修改次数。\\\n第二行仅由小写字母构成的字符串 $S$。\\\n接下来 $q$ 行，每行一个整数 $p$ 和一个小写字母 $\\texttt{c}$ 表示一次修改。", "outputFormat": "共有 $q+1$ 行，每行一个整数表示答案。", "hint": "Idea：cyffff，Solution：cyffff，Code：cyffff，Data：cyffff\n\n**Clock Paradox - WyvernP (Insane12.6)**\n\n**本题输入输出文件较大，请使用恰当的输入输出方式。**  \n\n### 提示\n\n称字符串 $A$ 是字符串 $S$ 的子串当且仅当存在 $1\\le l\\le r\\le |S|$ 使得 $A=\\overline{s_ls_{l+1}\\dots s_{r}}$。\n\n### 样例解释\n所有修改前，$f(S)$ 的计算方法如下：\n\n初始时，$S=T=\\texttt{aabc}$。\n\n第一次操作，选取 $S$ 的子串 $\\texttt{aa}$，插入到 $T$ 的最前端，操作后 $T=\\texttt{aaaabc}$。\n\n第二次操作，选取 $S$ 的子串 $\\texttt{bc}$，插入到 $T$ 的第 $5$ 个字符后，操作后 $T=\\texttt{aaaabbcc}$，符合要求。\n\n经过一次修改、两次修改后的 $S$ 分别等于 $\\texttt{abbc}$ 和 $\\texttt{abbb}$，这两次修改后 $f(S)$ 分别是 $2$ 和 $1$。\n### 数据规模\n\n本题采用捆绑测试。\n| $\\text{Subtask}$ | $\\vert S\\vert\\le$ | $q\\le$ | $\\text{Score}$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $5$ | $0$ | $10$ |\n| $2$ | $10^4$ | $10^4$ | $20$ |\n| $3$ | $5\\times10^5$ | $0$ | $20$ |\n| $4$ | $5\\times10^5$ | $5\\times 10^5$ | $20$ |\n| $5$ | $3\\times10^6$ | $3\\times 10^6$ | $30$ |\n\n对于 $100\\%$ 的数据，$1\\le|S|\\le3\\times10^6$，$0\\le q\\le 3\\times10^6$，保证 $S$ 仅由小写字母构成，保证 $\\texttt{c}$ 为单个小写字母。", "locale": "zh-CN"}}}
{"pid": "P8933", "type": "P", "difficulty": 4, "samples": [["1\n2 2", "16"], ["1\n3 3", "32"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["2023", "洛谷原创", "深度优先搜索 DFS"], "title": "[JRKSJ R7] 技巧性的块速递推", "background": "充分必要，切比雪夫。\n\n原来还是，不需要了。", "description": "一个 $n\\times m$ 的棋盘，对每个格子染上黑白两色之一。\n\n询问有多少种染色方式，使得不存在横、竖、斜连续四个格子中存在至少三个相同颜色的格子，并且不存在横、竖、斜连续三个格子的颜色相同。\n\n若设棋盘的左上角为 $(1,1)$，右下角为 $(n,m)$，则称 $\\{(x,y),(x+1,y),(x+2,y)\\}$ 为横的连续三个格子，$\\{(x,y),(x,y+1),(x,y+2)\\}$ 为竖的连续三个格子、$\\{(x,y),(x+1,y+1),(x+2,y+2)\\}$ 和 $\\{(x,y),(x+1,y-1),(x+2,y-2)\\}$ 为斜的连续三个格子（以上格子均在棋盘内）。\n\n连续四个格子同理。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$ 表示数据组数。\\\n接下来 $T$ 行，每行两个整数 $n,m$ 表示一次询问。", "outputFormat": "共 $T$ 行，每行一个整数表示答案。答案对 $998244353$ 取模。", "hint": "### 样例解释\n\n样例 $1$：显然任意染色均合法，答案为 $2^4=16$。\n\n样例 $2$：\n\n```\n101\n110\n010\n```\n\n这是合法方案之一。\n\n```\n111\n110\n011\n```\n\n这是不合法方案之一，因为 $\\{(1,1),(1,2),(1,3)\\}$、$\\{(1,2),(2,2),(3,2)\\}$ 和 $\\{(1,1),(2,2),(3,3)\\}$ 均不满足条件。\n\n### 数据规模\n\n本题采用捆绑测试。\n| $\\text{Subtask}$ | $n,m\\le$ | $\\text{Score}$ |\n| :----------: | :----------: | :----------: | \n| $1$ | $30$ | $40$ |\n| $2$ | $10^9$ | $60$ |\n\n对于 $100\\%$ 的数据，$1\\le T\\le 10^5$，$1\\le n,m\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JRKSJ R7] 技巧性的块速递推", "background": "充分必要，切比雪夫。\n\n原来还是，不需要了。", "description": "一个 $n\\times m$ 的棋盘，对每个格子染上黑白两色之一。\n\n询问有多少种染色方式，使得不存在横、竖、斜连续四个格子中存在至少三个相同颜色的格子，并且不存在横、竖、斜连续三个格子的颜色相同。\n\n若设棋盘的左上角为 $(1,1)$，右下角为 $(n,m)$，则称 $\\{(x,y),(x+1,y),(x+2,y)\\}$ 为横的连续三个格子，$\\{(x,y),(x,y+1),(x,y+2)\\}$ 为竖的连续三个格子、$\\{(x,y),(x+1,y+1),(x+2,y+2)\\}$ 和 $\\{(x,y),(x+1,y-1),(x+2,y-2)\\}$ 为斜的连续三个格子（以上格子均在棋盘内）。\n\n连续四个格子同理。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$ 表示数据组数。\\\n接下来 $T$ 行，每行两个整数 $n,m$ 表示一次询问。", "outputFormat": "共 $T$ 行，每行一个整数表示答案。答案对 $998244353$ 取模。", "hint": "### 样例解释\n\n样例 $1$：显然任意染色均合法，答案为 $2^4=16$。\n\n样例 $2$：\n\n```\n101\n110\n010\n```\n\n这是合法方案之一。\n\n```\n111\n110\n011\n```\n\n这是不合法方案之一，因为 $\\{(1,1),(1,2),(1,3)\\}$、$\\{(1,2),(2,2),(3,2)\\}$ 和 $\\{(1,1),(2,2),(3,3)\\}$ 均不满足条件。\n\n### 数据规模\n\n本题采用捆绑测试。\n| $\\text{Subtask}$ | $n,m\\le$ | $\\text{Score}$ |\n| :----------: | :----------: | :----------: | \n| $1$ | $30$ | $40$ |\n| $2$ | $10^9$ | $60$ |\n\n对于 $100\\%$ 的数据，$1\\le T\\le 10^5$，$1\\le n,m\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P8934", "type": "P", "difficulty": 6, "samples": [["3 3\n1 1\n2 2", "13"], ["10 2\n1 7\n1 2\n1 5\n4 5\n2 1\n3 9\n2 9\n4 4\n9 4", "736"], ["4 1\n1 1\n2 1\n3 1", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "2023", "洛谷原创", "O2优化", "树的直径"], "title": "[JRKSJ R7] TSM eerT", "background": "", "description": "对于一个 $n$ 个结点的带边权的树 $T$，定义 $dis(x,y)$ 为 $T$ 中 $x\\to y$ 路径上的边权和。再定义一个 $n$ 个结点的无向完全图 $p(T)=G$，其中 $\\forall x,y\\in [1,n]$，$G$ 中边 $(x,y)$ 的边权为 $dis(x,y)$。\n\n定义 $f(T)$ 为 $p(T)$ 的最大生成树。特别的，若 $p(T)$ 的最大生成树不唯一，请立刻判断出并报告。\n\n给定树 $T_0$ 和整数 $k$，求 $f^k(T_0)$。其定义将在下文给出。", "inputFormat": "第一行两个整数 $n,k$。\\\n下面第 $2\\sim n$ 行，第 $i$ 行两个整数 $i-f_i,v_i$ 表示 $T_0$ 的一条边 $(i,f_i)$，边权为 $v_i$。**也就是说，这一行输入了两个整数 $f'_i,v_i$，真实的 $f_i=i-f'_i$。**", "outputFormat": "输出仅有一个整数表示答案。\n\n若 $\\exists x\\in[0,k-1]$ 使得 $p(f^x(T_0))$ 的最大生成树不唯一，输出 $-1$。否则，输出 $f^k(T_0)$ 的所有边权和对 $2^{32}$ 取模的结果。", "hint": "### 定义\n\n$f^k(T)$ 的定义为：\n$$f^k(T)=\\begin{cases}T&k=0\\\\f(f^{k-1}(T))&k>0\\end{cases}$$\n\n### 样例 $1$ 解释\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fpcq3bmt.png)\n\n分别是 $T_0,f(T_0),f^2(T_0),f^3(T_0)$。\n\n以计算 $f(T_0)$ 的过程为例，生成的 $p(T_0)=G$ 为\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3st5aet7.png)\n\n最大生成树上的边为 $(1,3),(2,3)$。\n\n### 数据规模\n\n本题采用捆绑测试。\n| $\\text{Subtask}$ | $n\\le$ |  $k\\le$ | $\\text{Score}$ | \n| :----------: | :----------: | :----------: | :----------: | \n| $1$ | $10^3$ | $1$ | $10$ | \n| $2$ | $10^5$ | $1$ |$20$ |\n| $3$ | $10^6$ | $1$ |$30$ |\n| $4$ | $10^6$ | $10^7$ |$40$ |\n\n对于 $100\\%$ 的数据，$2\\le n\\le 10^6$，$1\\le k\\le 10^7$，$1\\le f_i<i$，$1\\le v_i\\le10^9$。\n\n### 特殊评分方式\n本题开启子任务依赖，具体如下：\n- 对于子任务 $i$，您需要答对所有 $j\\in[1,i]$ 的子任务 $j$ 才能获得子任务 $i$ 的分数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JRKSJ R7] TSM eerT", "background": "", "description": "对于一个 $n$ 个结点的带边权的树 $T$，定义 $dis(x,y)$ 为 $T$ 中 $x\\to y$ 路径上的边权和。再定义一个 $n$ 个结点的无向完全图 $p(T)=G$，其中 $\\forall x,y\\in [1,n]$，$G$ 中边 $(x,y)$ 的边权为 $dis(x,y)$。\n\n定义 $f(T)$ 为 $p(T)$ 的最大生成树。特别的，若 $p(T)$ 的最大生成树不唯一，请立刻判断出并报告。\n\n给定树 $T_0$ 和整数 $k$，求 $f^k(T_0)$。其定义将在下文给出。", "inputFormat": "第一行两个整数 $n,k$。\\\n下面第 $2\\sim n$ 行，第 $i$ 行两个整数 $i-f_i,v_i$ 表示 $T_0$ 的一条边 $(i,f_i)$，边权为 $v_i$。**也就是说，这一行输入了两个整数 $f'_i,v_i$，真实的 $f_i=i-f'_i$。**", "outputFormat": "输出仅有一个整数表示答案。\n\n若 $\\exists x\\in[0,k-1]$ 使得 $p(f^x(T_0))$ 的最大生成树不唯一，输出 $-1$。否则，输出 $f^k(T_0)$ 的所有边权和对 $2^{32}$ 取模的结果。", "hint": "### 定义\n\n$f^k(T)$ 的定义为：\n$$f^k(T)=\\begin{cases}T&k=0\\\\f(f^{k-1}(T))&k>0\\end{cases}$$\n\n### 样例 $1$ 解释\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fpcq3bmt.png)\n\n分别是 $T_0,f(T_0),f^2(T_0),f^3(T_0)$。\n\n以计算 $f(T_0)$ 的过程为例，生成的 $p(T_0)=G$ 为\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3st5aet7.png)\n\n最大生成树上的边为 $(1,3),(2,3)$。\n\n### 数据规模\n\n本题采用捆绑测试。\n| $\\text{Subtask}$ | $n\\le$ |  $k\\le$ | $\\text{Score}$ | \n| :----------: | :----------: | :----------: | :----------: | \n| $1$ | $10^3$ | $1$ | $10$ | \n| $2$ | $10^5$ | $1$ |$20$ |\n| $3$ | $10^6$ | $1$ |$30$ |\n| $4$ | $10^6$ | $10^7$ |$40$ |\n\n对于 $100\\%$ 的数据，$2\\le n\\le 10^6$，$1\\le k\\le 10^7$，$1\\le f_i<i$，$1\\le v_i\\le10^9$。\n\n### 特殊评分方式\n本题开启子任务依赖，具体如下：\n- 对于子任务 $i$，您需要答对所有 $j\\in[1,i]$ 的子任务 $j$ 才能获得子任务 $i$ 的分数。", "locale": "zh-CN"}}}
{"pid": "P8935", "type": "P", "difficulty": 6, "samples": [["3 2 2\n1 2\n1 3", "1"], ["5 2 4\n1 2\n1 3\n2 4\n2 5", "9"], ["5 1 4\n1 2\n1 3\n2 4\n2 5", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2023", "洛谷原创", "O2优化", "背包 DP", "树形 DP"], "title": "[JRKSJ R7] 茎", "background": "", "description": "你有一棵 $n$ 个点的根节点为 $1$ 的有根树，现在你要对这棵树进行剪枝，每次你可以选择一个还未被剪掉的节点 $u$ 进行操作，然后剪掉 $u$ 的子树所有点（包括 $u$）。当且仅当你剪掉 $1$ 时，操作停止。  \n\n你知道 $1$ 到 $x$ 这条路径是这棵树的茎，需要特殊处理。所以你需要在第 $k$ 次剪枝时对 $x$ 进行操作，而非仅仅将其剪掉，即你不能在第 $k$ 次及以前对其祖先进行操作使其被连带剪掉。 \n\n求有多少种不同的操作序列，两个操作序列不同当且仅当长度不同或存在一次操作 $i$ 使得两操作序列在第 $i$ 次时选择的 $u$ 不同。输出答案模 $10^9+7$。", "inputFormat": "第一行三个数 $n,k,x$。  \n接下来 $n-1$ 行每行两个数 $u,v$，代表树上的一条边 $(u,v)$。", "outputFormat": "一个数表示答案对 $10^9+7$ 取模的结果。", "hint": "### 样例解释\n\n对于样例 $1$，只有一种操作方法满足条件，第一次操作 $3$，第二次操作 $2$，第三次操作 $1$。  \n\n对于样例 $2$，满足条件的操作序列：$\\{3,4,1\\},\\{3,4,2,1\\},\\{3,4,5,1\\},\\{3,4,5,2,1\\},\\\\ \\{5,4,1\\},\\{5,4,2,1\\},\\{5,4,2,3,1\\},\\{5,4,3,1\\},\\{5,4,3,2,1\\}$。\n\n### 数据规模\n本题采用捆绑测试。\n\n|$\\text{Subtask}$|$n\\le$|特殊性质|$\\text{Score}$|\n|:-:|:-:|:-:|:-:|\n|$1$|$7$|无|$5$|\n|$2$|$17$|无|$10$|\n|$3$|$50$|$\\text A$|$5$|\n|$4$|$50$|无|$15$|\n|$5$|$500$|$\\text A$|$5$|\n|$6$|$500$|$\\text B$|$5$|\n|$7$|$500$|$\\text C$|$10$|\n|$8$|$500$|无|$45$|\n\n特殊性质 $\\text A$：保证 $k=1$。\\\n特殊性质 $\\text B$：保证 $x=1$。\\\n特殊性质 $\\text C$：保证 $\\forall i\\in[1,n-1],i$ 与 $i+1$ 有边。\n\n对于 $100\\%$ 的数据，$1\\le k,x\\le n\\le 500$。  \n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JRKSJ R7] 茎", "background": "", "description": "你有一棵 $n$ 个点的根节点为 $1$ 的有根树，现在你要对这棵树进行剪枝，每次你可以选择一个还未被剪掉的节点 $u$ 进行操作，然后剪掉 $u$ 的子树所有点（包括 $u$）。当且仅当你剪掉 $1$ 时，操作停止。  \n\n你知道 $1$ 到 $x$ 这条路径是这棵树的茎，需要特殊处理。所以你需要在第 $k$ 次剪枝时对 $x$ 进行操作，而非仅仅将其剪掉，即你不能在第 $k$ 次及以前对其祖先进行操作使其被连带剪掉。 \n\n求有多少种不同的操作序列，两个操作序列不同当且仅当长度不同或存在一次操作 $i$ 使得两操作序列在第 $i$ 次时选择的 $u$ 不同。输出答案模 $10^9+7$。", "inputFormat": "第一行三个数 $n,k,x$。  \n接下来 $n-1$ 行每行两个数 $u,v$，代表树上的一条边 $(u,v)$。", "outputFormat": "一个数表示答案对 $10^9+7$ 取模的结果。", "hint": "### 样例解释\n\n对于样例 $1$，只有一种操作方法满足条件，第一次操作 $3$，第二次操作 $2$，第三次操作 $1$。  \n\n对于样例 $2$，满足条件的操作序列：$\\{3,4,1\\},\\{3,4,2,1\\},\\{3,4,5,1\\},\\{3,4,5,2,1\\},\\\\ \\{5,4,1\\},\\{5,4,2,1\\},\\{5,4,2,3,1\\},\\{5,4,3,1\\},\\{5,4,3,2,1\\}$。\n\n### 数据规模\n本题采用捆绑测试。\n\n|$\\text{Subtask}$|$n\\le$|特殊性质|$\\text{Score}$|\n|:-:|:-:|:-:|:-:|\n|$1$|$7$|无|$5$|\n|$2$|$17$|无|$10$|\n|$3$|$50$|$\\text A$|$5$|\n|$4$|$50$|无|$15$|\n|$5$|$500$|$\\text A$|$5$|\n|$6$|$500$|$\\text B$|$5$|\n|$7$|$500$|$\\text C$|$10$|\n|$8$|$500$|无|$45$|\n\n特殊性质 $\\text A$：保证 $k=1$。\\\n特殊性质 $\\text B$：保证 $x=1$。\\\n特殊性质 $\\text C$：保证 $\\forall i\\in[1,n-1],i$ 与 $i+1$ 有边。\n\n对于 $100\\%$ 的数据，$1\\le k,x\\le n\\le 500$。  \n", "locale": "zh-CN"}}}
{"pid": "P8936", "type": "P", "difficulty": 6, "samples": [["5 5\n1 3 1\n2 4 1\n2 3 1\n1 3 1\n1 4 1\n", "9 2 20"], ["3 5\n1 3 2\n1 1 1\n2 2 2\n3 3 3\n1 3 2\n", "5 7 11"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["线段树", "并查集", "2023", "颜色段均摊（珂朵莉树 ODT）", "洛谷原创", "O2优化"], "title": "[JRKSJ R7] 月下缭乱", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/xkd5zhgk.png?x-oss-process=image)\n\n轻快的音乐声坚定了你做一道简单题的决心。\n\n（题目背景图片来自 Phigros 曲绘，如有侵权，请告知出题人。）", "description": "你有一个长度为 $n$，初值全为 $0$ 的序列 $a$。\n\n你有长为 $m$ 的操作序列，其中第 $i$ 次有三个参数 $l_i,r_i,x_i$，表示令 $\\forall j\\in[l_i,r_i] ,a_j\\gets\\max(a_j,x_i)$。\n\n令 $\\text{sol}(l,r)$ 表示依次操作第 $l$ 至第 $r$ 个操作后的 $a$ 序列。\n\n你需要回答有多少对 $(l,r)$ 满足 $1\\le l\\le r\\le m$ 且 $\\text{sol}(l,r)=\\text{sol}(1,m)$。\n\n记 $f_i$ 为有多少 $i\\le k\\le m$ 满足 $\\text{sol}(i,k)=\\text{sol}(1,m)$，你还需要输出 $\\displaystyle\\bigoplus_{i=1}^m f_i\\times i$ 与 $\\displaystyle\\sum_{i=1}^m f_i\\times i$ 的值。\n\n所有答案都需要对 $2^{32}$ 取模后输出。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $m$ 行，每行三个整数 $l_i,r_i,x_i$，表示第 $i$ 个操作。", "outputFormat": "一行三个整数表示答案，对 $2^{32}$ 取模。", "hint": "Idea：cyffff，Solution：Ntokisq / abruce，Code：cyffff，Data：cyffff\n\n**月下缭乱 - 月見静華 vs. LUNARiUM (Insane14.8)**\n\n**本题输入输出文件较大，请使用恰当的输入输出方式。**\n\n### 样例解释\n\n对于样例 $2$，最终 $a$ 序列的值为 $\\{2,2,3\\}$。不难发现，进行 $[1,4],[1,5],[2,5],[3,5],[4,5]$ 内的操作都可以使得 $a$ 与进行所有操作后 $a$ 序列的值相同。答案为 $5$。$f$ 序列的值为 $\\{2,1,1,1,0\\}$。\n\n### 数据规模\n本题采用捆绑测试。\n\n::cute-table\n| $\\text{Subtask}$ | $n,m\\le$ | 特殊限制 | $\\text{Score}$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $100$ | 无 | $10$ |\n| $2$ | $10^4$ | ^ | $20$ |\n| $3$ | $3\\times10^5$ | 保证 $l_i=r_i$ | $10$ |\n| $4$ | ^ | 保证 $x_i=1$ | $10$ |\n| $5$ | ^ | 无 | $20$ |\n| $6$ | $10^6$ | ^ | $30$ |\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le10^6$，$1\\le l_i\\le r_i\\le n$，$1\\le x_i\\le m$。\n### 特殊评分方式\n本题开启子任务依赖，具体如下：\n- 对于子任务 $i\\in\\{1,3,4\\}$，您只需答对子任务 $i$ 即可获得子任务 $i$ 的分数。\n- 对于子任务 $i\\in\\{2,5,6\\}$，您需要答对所有 $j\\in[1,i]$ 的子任务 $j$ 才能获得子任务 $i$ 的分数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JRKSJ R7] 月下缭乱", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/xkd5zhgk.png?x-oss-process=image)\n\n轻快的音乐声坚定了你做一道简单题的决心。\n\n（题目背景图片来自 Phigros 曲绘，如有侵权，请告知出题人。）", "description": "你有一个长度为 $n$，初值全为 $0$ 的序列 $a$。\n\n你有长为 $m$ 的操作序列，其中第 $i$ 次有三个参数 $l_i,r_i,x_i$，表示令 $\\forall j\\in[l_i,r_i] ,a_j\\gets\\max(a_j,x_i)$。\n\n令 $\\text{sol}(l,r)$ 表示依次操作第 $l$ 至第 $r$ 个操作后的 $a$ 序列。\n\n你需要回答有多少对 $(l,r)$ 满足 $1\\le l\\le r\\le m$ 且 $\\text{sol}(l,r)=\\text{sol}(1,m)$。\n\n记 $f_i$ 为有多少 $i\\le k\\le m$ 满足 $\\text{sol}(i,k)=\\text{sol}(1,m)$，你还需要输出 $\\displaystyle\\bigoplus_{i=1}^m f_i\\times i$ 与 $\\displaystyle\\sum_{i=1}^m f_i\\times i$ 的值。\n\n所有答案都需要对 $2^{32}$ 取模后输出。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $m$ 行，每行三个整数 $l_i,r_i,x_i$，表示第 $i$ 个操作。", "outputFormat": "一行三个整数表示答案，对 $2^{32}$ 取模。", "hint": "Idea：cyffff，Solution：Ntokisq / abruce，Code：cyffff，Data：cyffff\n\n**月下缭乱 - 月見静華 vs. LUNARiUM (Insane14.8)**\n\n**本题输入输出文件较大，请使用恰当的输入输出方式。**\n\n### 样例解释\n\n对于样例 $2$，最终 $a$ 序列的值为 $\\{2,2,3\\}$。不难发现，进行 $[1,4],[1,5],[2,5],[3,5],[4,5]$ 内的操作都可以使得 $a$ 与进行所有操作后 $a$ 序列的值相同。答案为 $5$。$f$ 序列的值为 $\\{2,1,1,1,0\\}$。\n\n### 数据规模\n本题采用捆绑测试。\n\n::cute-table\n| $\\text{Subtask}$ | $n,m\\le$ | 特殊限制 | $\\text{Score}$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $100$ | 无 | $10$ |\n| $2$ | $10^4$ | ^ | $20$ |\n| $3$ | $3\\times10^5$ | 保证 $l_i=r_i$ | $10$ |\n| $4$ | ^ | 保证 $x_i=1$ | $10$ |\n| $5$ | ^ | 无 | $20$ |\n| $6$ | $10^6$ | ^ | $30$ |\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le10^6$，$1\\le l_i\\le r_i\\le n$，$1\\le x_i\\le m$。\n### 特殊评分方式\n本题开启子任务依赖，具体如下：\n- 对于子任务 $i\\in\\{1,3,4\\}$，您只需答对子任务 $i$ 即可获得子任务 $i$ 的分数。\n- 对于子任务 $i\\in\\{2,5,6\\}$，您需要答对所有 $j\\in[1,i]$ 的子任务 $j$ 才能获得子任务 $i$ 的分数。", "locale": "zh-CN"}}}
{"pid": "P8937", "type": "P", "difficulty": 7, "samples": [["10 10\n20 10 20 14 4 15 11 20 2 13 \n2 5 9 1\n1 7 8 2\n1 2 3 8\n1 4 6 12\n2 1 7 9\n2 2 7 20\n2 3 9 4\n2 8 9 7\n1 3 10 0\n2 8 9 7", "0\n5\n6\n2\n1\n1"], ["5 5\n6 10 3 4 7 \n1 1 3 3\n1 3 4 3\n2 3 5 3\n1 1 3 11\n2 2 3 5", "2\n2"]], "limits": {"time": [1000, 5000, 5000, 5000, 20000, 20000, 20000, 20000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "洛谷原创", "O2优化"], "title": "[JRKSJ R7] 五彩斑斓的曙光", "background": "题目名称由 fjy666 提供，背景 TBD.", "description": "给您一个长度为 $n$ 的序列 $a$，请您支持 $m$ 次操作：\n\n1. 将 $[l,r]$ 区间中 $> x$ 的数减去 $x$。\n2. 求 $[l,r]$ 区间中 $\\le x$ 的数的个数。", "inputFormat": "**本题强制在线。**\n\n第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数表示 $a$。\n\n下面 $m$ 行，每行四个整数 $opt,l,r,x'$，$opt$ 表示操作编号，$x'$ 异或上次操作 $2$ 答案得到真实的 $x$。若此前没有操作 $2$，则不需要进行异或操作，真实的 $x$ 即为 $x'$。", "outputFormat": "对于所有操作 $2$，每行输出一个整数表示答案。", "hint": "Idea：Ntokisq&nzhtl1477，Solution：Ntokisq，Code：Ntokisq，Data：Ntokisq\n\n### 样例解释\n\n样例 $1$ 未加密前：\n\n```cpp\n10 10\n20 10 20 14 4 15 11 20 2 13\n2 5 9 1\n1 7 8 2\n1 2 3 8\n1 4 6 12\n2 1 7 9\n2 2 7 17\n2 3 9 2\n2 8 9 5\n1 3 10 1\n2 8 9 6\n```\n样例 $2$ 未加密前：\n\n```cpp\n5 5\n6 10 3 4 7\n1 1 3 3\n1 3 4 3\n2 3 5 3\n1 1 3 9\n2 2 3 7\n```\n\n\n\n### 数据规模\n\n本题采用捆绑测试。\n| $\\text{Subtask}$ | $n\\le$ | $m\\le$ | $\\text{Score}$ | 时间限制 |\n| :----------: | :----------: | :----------: | :----------: |  :----------: | \n| $1$ | $10^4$ | $10^4$ | $10$ | $\\text{1s}$ |\n| $2$ | $3\\times 10^5$ | $3\\times 10^5$ | $30$ | $\\text{5s}$ |\n| $3$ | $7\\times 10^5$ | $5\\times 10^5$ | $60$ | $\\text{20s}$ |\n\n对于 $100\\%$ 的数据，$1\\le n \\le 7\\times 10^5$，$1\\le m\\le  5\\times 10^5$，$1\\le a_i,x\\le 10^9$，$1\\le l\\le r\\le n$。\n\n### 提示\n\n如果您认为您的算法时间复杂度正确但常数过大，您可以使用同样思路但时间复杂度略高、常数小的算法。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JRKSJ R7] 五彩斑斓的曙光", "background": "题目名称由 fjy666 提供，背景 TBD.", "description": "给您一个长度为 $n$ 的序列 $a$，请您支持 $m$ 次操作：\n\n1. 将 $[l,r]$ 区间中 $> x$ 的数减去 $x$。\n2. 求 $[l,r]$ 区间中 $\\le x$ 的数的个数。", "inputFormat": "**本题强制在线。**\n\n第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数表示 $a$。\n\n下面 $m$ 行，每行四个整数 $opt,l,r,x'$，$opt$ 表示操作编号，$x'$ 异或上次操作 $2$ 答案得到真实的 $x$。若此前没有操作 $2$，则不需要进行异或操作，真实的 $x$ 即为 $x'$。", "outputFormat": "对于所有操作 $2$，每行输出一个整数表示答案。", "hint": "Idea：Ntokisq&nzhtl1477，Solution：Ntokisq，Code：Ntokisq，Data：Ntokisq\n\n### 样例解释\n\n样例 $1$ 未加密前：\n\n```cpp\n10 10\n20 10 20 14 4 15 11 20 2 13\n2 5 9 1\n1 7 8 2\n1 2 3 8\n1 4 6 12\n2 1 7 9\n2 2 7 17\n2 3 9 2\n2 8 9 5\n1 3 10 1\n2 8 9 6\n```\n样例 $2$ 未加密前：\n\n```cpp\n5 5\n6 10 3 4 7\n1 1 3 3\n1 3 4 3\n2 3 5 3\n1 1 3 9\n2 2 3 7\n```\n\n\n\n### 数据规模\n\n本题采用捆绑测试。\n| $\\text{Subtask}$ | $n\\le$ | $m\\le$ | $\\text{Score}$ | 时间限制 |\n| :----------: | :----------: | :----------: | :----------: |  :----------: | \n| $1$ | $10^4$ | $10^4$ | $10$ | $\\text{1s}$ |\n| $2$ | $3\\times 10^5$ | $3\\times 10^5$ | $30$ | $\\text{5s}$ |\n| $3$ | $7\\times 10^5$ | $5\\times 10^5$ | $60$ | $\\text{20s}$ |\n\n对于 $100\\%$ 的数据，$1\\le n \\le 7\\times 10^5$，$1\\le m\\le  5\\times 10^5$，$1\\le a_i,x\\le 10^9$，$1\\le l\\le r\\le n$。\n\n### 提示\n\n如果您认为您的算法时间复杂度正确但常数过大，您可以使用同样思路但时间复杂度略高、常数小的算法。", "locale": "zh-CN"}}}
{"pid": "P8938", "type": "P", "difficulty": 2, "samples": [["3 3\n3 2 1", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["洛谷原创", "O2优化", "洛谷月赛"], "title": "[DTOI 2023] A. 小狗哥哥", "background": "luanmenglei 有一个辉煌的现在：他们班的女同学都叫他易酱。\n\n但谁能想到 luanmenglei 有一个悲伤的过去，他五岁的弟弟叫他小狗哥哥。", "description": "下文的所有参数均默认为整数。\n\n作为一位（7k7k 小游戏的）游戏开发者，你设计了如下（简陋的不如小狗哥哥幼儿园大班的毕业设计的）游戏，存在两个要素：\n1. 一个敌对生物，其血量为 $m$。\n2. 主角的武器，分为 $n$ 级，第 $i$ 级的伤害是 $i\\times p$。\n\n游戏的平衡性需要提前规划，所以你还有一个序列 $\\{a_n\\}$，其含义如下：\n\n- $a_i$ 表示敌对生物被第 $i$ 级武器恰好攻击 $a_i$ 下会死。\n\n可惜你忘记了 $p$ 具体是多少，所以你需要求出所有可能的 $p$ 的个数。\n\n如果可能有无数个 $p$，那么请输出 `xiaogougege`。\n\n", "inputFormat": "第一行两个正整数 $n,m$。\n\n第二行 $n$ 个正整数，表示序列 $\\{a_n\\}$。", "outputFormat": "一行一个整数，表示可能的 $p$ 的个数，或字符串 `xiaogougege`，其具体含义见题目描述。", "hint": "#### 【样例 1 解释】\n\n当武器为 $1$ 级时，分析可以发现 $p$ 要满足 $1 \\leq p < \\frac{3}{2}$。  \n当武器为 $2$ 级时，分析可以发现 $p$ 要满足 $\\frac{3}{4} \\leq p < \\frac{3}{2}$。  \n当武器为 $3$ 级时，分析可以发现 $p$ 要满足 $1 \\leq p$。 \n\n又 $p$ 是整数。综上，只有当 $p = 1$ 时满足题目所述条件。\n\n#### 【样例 2】\n\n见附加文件中的 `game/game2.in` 与 `game/game2.out`。\n\n该样例满足测试点 $13\\sim 20$ 的限制。\n\n#### 【数据范围与提示】\n\n对于所有测试数据，保证 $1\\leq n \\leq 10^5$，$1\\leq a_i,m\\leq 10^9$。\n\n每个测试点的具体限制见下表：\n\n|  测试点编号  |      $n\\leq$ | $m,a_i\\leq $ | 特殊性质 |\n| :-: | :-: |:-:|:-:|\n| $1\\sim 9$ | $10^5$ | $10^9$ | 数据纯随机 |\n|  $10 \\sim 12$  |       $3$       |$5$| 无 |\n| $13 \\sim 20$ | $10^5$ |$10^9$| 无 |\n\n你需要注意，上文纯随机数据的具体生成程序代码如下：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, w;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint rand(int l, int r) {\n  assert(l <= r);\n  return uniform_int_distribution<>(l, r)(rng);\n} \n\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &w);\n  printf(\"%d %d\\n\", n, m);\n  for (int i = 1; i <= n; i ++) printf(\"%d%c\", rand(1, w), \" \\n\"[i == n]);\n  return 0;\n}\n```\n\n通俗的说，就是对于给定的 $n,m,w(w\\le 10^9)$，数据生成器会随机生成 $n$ 个值域在 $[1,w]$ 内的数，作为 $\\{a_n\\}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[DTOI 2023] A. 小狗哥哥", "background": "luanmenglei 有一个辉煌的现在：他们班的女同学都叫他易酱。\n\n但谁能想到 luanmenglei 有一个悲伤的过去，他五岁的弟弟叫他小狗哥哥。", "description": "下文的所有参数均默认为整数。\n\n作为一位（7k7k 小游戏的）游戏开发者，你设计了如下（简陋的不如小狗哥哥幼儿园大班的毕业设计的）游戏，存在两个要素：\n1. 一个敌对生物，其血量为 $m$。\n2. 主角的武器，分为 $n$ 级，第 $i$ 级的伤害是 $i\\times p$。\n\n游戏的平衡性需要提前规划，所以你还有一个序列 $\\{a_n\\}$，其含义如下：\n\n- $a_i$ 表示敌对生物被第 $i$ 级武器恰好攻击 $a_i$ 下会死。\n\n可惜你忘记了 $p$ 具体是多少，所以你需要求出所有可能的 $p$ 的个数。\n\n如果可能有无数个 $p$，那么请输出 `xiaogougege`。\n\n", "inputFormat": "第一行两个正整数 $n,m$。\n\n第二行 $n$ 个正整数，表示序列 $\\{a_n\\}$。", "outputFormat": "一行一个整数，表示可能的 $p$ 的个数，或字符串 `xiaogougege`，其具体含义见题目描述。", "hint": "#### 【样例 1 解释】\n\n当武器为 $1$ 级时，分析可以发现 $p$ 要满足 $1 \\leq p < \\frac{3}{2}$。  \n当武器为 $2$ 级时，分析可以发现 $p$ 要满足 $\\frac{3}{4} \\leq p < \\frac{3}{2}$。  \n当武器为 $3$ 级时，分析可以发现 $p$ 要满足 $1 \\leq p$。 \n\n又 $p$ 是整数。综上，只有当 $p = 1$ 时满足题目所述条件。\n\n#### 【样例 2】\n\n见附加文件中的 `game/game2.in` 与 `game/game2.out`。\n\n该样例满足测试点 $13\\sim 20$ 的限制。\n\n#### 【数据范围与提示】\n\n对于所有测试数据，保证 $1\\leq n \\leq 10^5$，$1\\leq a_i,m\\leq 10^9$。\n\n每个测试点的具体限制见下表：\n\n|  测试点编号  |      $n\\leq$ | $m,a_i\\leq $ | 特殊性质 |\n| :-: | :-: |:-:|:-:|\n| $1\\sim 9$ | $10^5$ | $10^9$ | 数据纯随机 |\n|  $10 \\sim 12$  |       $3$       |$5$| 无 |\n| $13 \\sim 20$ | $10^5$ |$10^9$| 无 |\n\n你需要注意，上文纯随机数据的具体生成程序代码如下：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, w;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint rand(int l, int r) {\n  assert(l <= r);\n  return uniform_int_distribution<>(l, r)(rng);\n} \n\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &w);\n  printf(\"%d %d\\n\", n, m);\n  for (int i = 1; i <= n; i ++) printf(\"%d%c\", rand(1, w), \" \\n\"[i == n]);\n  return 0;\n}\n```\n\n通俗的说，就是对于给定的 $n,m,w(w\\le 10^9)$，数据生成器会随机生成 $n$ 个值域在 $[1,w]$ 内的数，作为 $\\{a_n\\}$。", "locale": "zh-CN"}}}
{"pid": "P8939", "type": "P", "difficulty": 3, "samples": [["5 3\n1 2 3 4 10\n1 4\n1 10\n2 9", "18\n4\n16"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["洛谷原创", "O2优化", "洛谷月赛"], "title": "[DTOI 2023] B. 去年 11 月卵梦蕾简易钨丝", "background": "# 大样例已修复\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4il8fn7w.png)", "description": "给定序列 $\\{a_n\\}$，支持两种形如 `opt x` 操作：\n\n1. `1 x`：删除一个数 $x$，若序列中没有 $x$，则输出 $-1$ 并跳过本次操作，**若有多个 $x$，则仅删除一个**。\n\n2. `2 x`：向序列中插入一个数 $x$。\n\n**对于每个未被跳过的操作**，试求出 $a$ 的一个排列 $p$，最小化 $\\sum \\limits_{i=1}^{n} \\lvert p_{i+1}-p_i\\rvert$ 的值，即最小化 $\\lvert p_2-p_1\\rvert+\\lvert p_3-p_2\\rvert+\\dots+\\lvert p_{n+1}-p_n\\rvert$ 的值，其中 $p_{n+1}=p_1$。\n\n**保证任意时刻序列内至少有 $1$ 个数。**\n\n---\n$p$ 是 $a$ 的排列当且仅当对于 $\\forall x$，$\\sum [p_i=x]=\\sum [a_i=x]$。\n\n简而言之，$p$ 是 $a$ 经过某种方式重排后的结果。 \n\n例如 $\\{1,1,4,5,1,4\\}$ 是 $\\{1,5,4,1,4,1\\}$ 的一个排列，但是 $\\{1,5,4,1,4,7\\}$ 不是。", "inputFormat": "输入共 $q + 2$ 行。\n\n第 $1$ 行两个正整数 $n, q$。\n\n第 $2$ 行 $n$ 个非负整数 $a_1, a_2, \\dots, a_n$，代表初始的序列。\n\t\t\n第 $3 \\sim q + 2$ 行，每行两个数 $opt, x$ ， 代表一个询问。 ", "outputFormat": "输出有多行。\n\n每行输出 $1$ 个数，代表一个未被忽略的询问的答案，否则输出 `-1`。\n\t", "hint": "#### 【样例 1 解释】\n对于第一个询问，删除了序列中的数 $4$，则当前序列为$ 1, 2, 3, 10 $， 可以证明 $18$ 为当前序列的最小答案。\n\t\n对于第二个询问，删除了序列中的数 $10$，则当前序列为$ 1, 2, 3 $， 可以证明 $4$ 为当前序列的最小答案。\n\t\n对于第三个询问，向序列中添加了一个数 $9$，则当前序列为$ 1, 2, 3, 9 $， 可以证明 $16$ 为当前序列的最小答案。\n\n#### 【样例 2】\n\n见附加文件中的 `abs/abs2.in` 与 `abs/abs2.out`。\n\n该样例满足测试点 $1\\sim 4$ 的限制。\n\n#### 【样例 3】\n\n见附加文件中的 `abs/abs3.in` 与 `abs/abs3.out`。\n\n该样例满足测试点 $7\\sim 10$ 的限制。\n\n#### 【数据范围与提示】\n记 $w$ 为值域大小，对于所有测试数据，保证 $n,q\\leq 10^6$，$0\\leq w\\leq 10^6$。\n\t\n每个测试点的具体限制见下表：\n\n| 测试点编号 | $n,q\\leq$ | $w$ |\n| :----------: | :----------: | :----------: |\n| $1\\sim 4$ | $100$ | $10$ |\n| $5\\sim 6$ | $10^3$ | $10^3$ |\n| $7\\sim 10$ | $10^6$ | $10^6$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[DTOI 2023] B. 去年 11 月卵梦蕾简易钨丝", "background": "# 大样例已修复\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4il8fn7w.png)", "description": "给定序列 $\\{a_n\\}$，支持两种形如 `opt x` 操作：\n\n1. `1 x`：删除一个数 $x$，若序列中没有 $x$，则输出 $-1$ 并跳过本次操作，**若有多个 $x$，则仅删除一个**。\n\n2. `2 x`：向序列中插入一个数 $x$。\n\n**对于每个未被跳过的操作**，试求出 $a$ 的一个排列 $p$，最小化 $\\sum \\limits_{i=1}^{n} \\lvert p_{i+1}-p_i\\rvert$ 的值，即最小化 $\\lvert p_2-p_1\\rvert+\\lvert p_3-p_2\\rvert+\\dots+\\lvert p_{n+1}-p_n\\rvert$ 的值，其中 $p_{n+1}=p_1$。\n\n**保证任意时刻序列内至少有 $1$ 个数。**\n\n---\n$p$ 是 $a$ 的排列当且仅当对于 $\\forall x$，$\\sum [p_i=x]=\\sum [a_i=x]$。\n\n简而言之，$p$ 是 $a$ 经过某种方式重排后的结果。 \n\n例如 $\\{1,1,4,5,1,4\\}$ 是 $\\{1,5,4,1,4,1\\}$ 的一个排列，但是 $\\{1,5,4,1,4,7\\}$ 不是。", "inputFormat": "输入共 $q + 2$ 行。\n\n第 $1$ 行两个正整数 $n, q$。\n\n第 $2$ 行 $n$ 个非负整数 $a_1, a_2, \\dots, a_n$，代表初始的序列。\n\t\t\n第 $3 \\sim q + 2$ 行，每行两个数 $opt, x$ ， 代表一个询问。 ", "outputFormat": "输出有多行。\n\n每行输出 $1$ 个数，代表一个未被忽略的询问的答案，否则输出 `-1`。\n\t", "hint": "#### 【样例 1 解释】\n对于第一个询问，删除了序列中的数 $4$，则当前序列为$ 1, 2, 3, 10 $， 可以证明 $18$ 为当前序列的最小答案。\n\t\n对于第二个询问，删除了序列中的数 $10$，则当前序列为$ 1, 2, 3 $， 可以证明 $4$ 为当前序列的最小答案。\n\t\n对于第三个询问，向序列中添加了一个数 $9$，则当前序列为$ 1, 2, 3, 9 $， 可以证明 $16$ 为当前序列的最小答案。\n\n#### 【样例 2】\n\n见附加文件中的 `abs/abs2.in` 与 `abs/abs2.out`。\n\n该样例满足测试点 $1\\sim 4$ 的限制。\n\n#### 【样例 3】\n\n见附加文件中的 `abs/abs3.in` 与 `abs/abs3.out`。\n\n该样例满足测试点 $7\\sim 10$ 的限制。\n\n#### 【数据范围与提示】\n记 $w$ 为值域大小，对于所有测试数据，保证 $n,q\\leq 10^6$，$0\\leq w\\leq 10^6$。\n\t\n每个测试点的具体限制见下表：\n\n| 测试点编号 | $n,q\\leq$ | $w$ |\n| :----------: | :----------: | :----------: |\n| $1\\sim 4$ | $100$ | $10$ |\n| $5\\sim 6$ | $10^3$ | $10^3$ |\n| $7\\sim 10$ | $10^6$ | $10^6$ |\n", "locale": "zh-CN"}}}
{"pid": "P8940", "type": "P", "difficulty": 5, "samples": [["10 3\n2 2 2 1 2 2 2 1 2 2 \n", "13"], ["10 0\n2 2 2 1 2 2 2 1 2 3 \n", "9"], ["11 0\n2 2 2 1 2 2 2 1 1 3 3 ", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["洛谷原创", "O2优化", "洛谷月赛"], "title": "[DTOI 2023] C. 不见故人", "background": "虽然 luanmenglei 已经是成熟的高中生了，但每次提起 luanmenglei 八年级的女朋友时，luanmenglei 都会沉浸在美好的回忆中，不可自拔。", "description": "给定 $n, k$ 和序列 $\\{a_n\\}$，你同时有一个临时变量 $x$，你可以进行以下操作若干次（也可以是 $0$ 次），一次操作的流程是：\n1. 选定一个区间 $[l,r]$，$\\forall i\\in[l,r]$，$x\\leftarrow \\gcd(a_l,a_{l+1},\\cdots,a_r)$。\n2. $\\forall i\\in[l,r]$，$a_i\\leftarrow x$。\n\n简而言之，你每次可以选定一个区间并将其中每个数变成这个区间的 $\\gcd$。\n\n一次操作的代价是 $r-l+1+k$，现在你希望把这个序列的每个数都变成相等的，求最小代价和。\n\n----\n如果您不了解 $\\gcd$ 或者多元 $\\gcd$ 的含义，可以参照如下定义：\n- $\\gcd(a_1,a_2,\\dots, a_k)$ 表示 $a_1,a_2,\\dots, a_k$ 的最大公约数，即最大的能同时整除 $a_1,a_2,\\dots, a_k$ 的正整数。\n", "inputFormat": "第一行两个非负整数 $n,k$。\n\n第二行 $n$ 个数，表示 $\\{a_n\\}$。", "outputFormat": "一行一个数，表示答案。", "hint": "#### 【样例 1 解释】\n\n操作一次，选择区间 $[1,10]$。\n\n#### 【样例 4】\n\n见附加文件中的 `old/old4.in` 与 `old/old4.out`。\n\n该样例满足测试点 $9\\sim 12$ 的限制。\n\n#### 【样例 5】\n\n见附加文件中的 `old/old5.in` 与 `old/old5.out`。\n\n该样例满足测试点 $13\\sim 16$ 的限制。\n\n#### 【数据范围与提示】\n\n对于所有数据，保证 $1\\leq n\\leq 4\\times 10^6$，$0\\leq k\\leq 10^9$，$1\\leq a_i\\leq 10^9$。\n\n每个测试点的具体限制见下表：\n\n| 测试点编号 | $n\\leq$ | $k,a_i\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10^6$ | $10^9$ | 所有数都相等 |\n| $2\\sim 4$ | $4$ | $10^9$ | 无 |\n| $5\\sim 8$ | $100$ | $10^9$ | 无 |\n| $9\\sim 12$ | $1000$ | $10^9$ | 无 |\n| $13\\sim 16$ | $10^6$ | $10^9$ | 无 |\n| $17\\sim 20$ | $4\\times 10^6$ | $10^9$ | 无 |\n\n本题的读入量较大，请选择较快的读入方式，下面提供一种读入策略：\n\n请在代码的开头加入此行：`std::ios::sync_with_stdio(false);std::cin.tie(0);`。\n\n请注意，加入本行后 `cin/cout` 的效率将大幅提高，保证其能在 `250 ms` 内读入所有数据，**但使用后你仅能使用 `cin/cout` 流读入数据。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[DTOI 2023] C. 不见故人", "background": "虽然 luanmenglei 已经是成熟的高中生了，但每次提起 luanmenglei 八年级的女朋友时，luanmenglei 都会沉浸在美好的回忆中，不可自拔。", "description": "给定 $n, k$ 和序列 $\\{a_n\\}$，你同时有一个临时变量 $x$，你可以进行以下操作若干次（也可以是 $0$ 次），一次操作的流程是：\n1. 选定一个区间 $[l,r]$，$\\forall i\\in[l,r]$，$x\\leftarrow \\gcd(a_l,a_{l+1},\\cdots,a_r)$。\n2. $\\forall i\\in[l,r]$，$a_i\\leftarrow x$。\n\n简而言之，你每次可以选定一个区间并将其中每个数变成这个区间的 $\\gcd$。\n\n一次操作的代价是 $r-l+1+k$，现在你希望把这个序列的每个数都变成相等的，求最小代价和。\n\n----\n如果您不了解 $\\gcd$ 或者多元 $\\gcd$ 的含义，可以参照如下定义：\n- $\\gcd(a_1,a_2,\\dots, a_k)$ 表示 $a_1,a_2,\\dots, a_k$ 的最大公约数，即最大的能同时整除 $a_1,a_2,\\dots, a_k$ 的正整数。\n", "inputFormat": "第一行两个非负整数 $n,k$。\n\n第二行 $n$ 个数，表示 $\\{a_n\\}$。", "outputFormat": "一行一个数，表示答案。", "hint": "#### 【样例 1 解释】\n\n操作一次，选择区间 $[1,10]$。\n\n#### 【样例 4】\n\n见附加文件中的 `old/old4.in` 与 `old/old4.out`。\n\n该样例满足测试点 $9\\sim 12$ 的限制。\n\n#### 【样例 5】\n\n见附加文件中的 `old/old5.in` 与 `old/old5.out`。\n\n该样例满足测试点 $13\\sim 16$ 的限制。\n\n#### 【数据范围与提示】\n\n对于所有数据，保证 $1\\leq n\\leq 4\\times 10^6$，$0\\leq k\\leq 10^9$，$1\\leq a_i\\leq 10^9$。\n\n每个测试点的具体限制见下表：\n\n| 测试点编号 | $n\\leq$ | $k,a_i\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10^6$ | $10^9$ | 所有数都相等 |\n| $2\\sim 4$ | $4$ | $10^9$ | 无 |\n| $5\\sim 8$ | $100$ | $10^9$ | 无 |\n| $9\\sim 12$ | $1000$ | $10^9$ | 无 |\n| $13\\sim 16$ | $10^6$ | $10^9$ | 无 |\n| $17\\sim 20$ | $4\\times 10^6$ | $10^9$ | 无 |\n\n本题的读入量较大，请选择较快的读入方式，下面提供一种读入策略：\n\n请在代码的开头加入此行：`std::ios::sync_with_stdio(false);std::cin.tie(0);`。\n\n请注意，加入本行后 `cin/cout` 的效率将大幅提高，保证其能在 `250 ms` 内读入所有数据，**但使用后你仅能使用 `cin/cout` 流读入数据。**", "locale": "zh-CN"}}}
{"pid": "P8941", "type": "P", "difficulty": 5, "samples": [["5 1 2", "8"], ["6 1 3", "12"], ["7 1 4", "48"], ["8 3 5", "6"], ["9 2 5", "72"], ["114 3 3", "106624"], ["514 3 4", "296097032"], ["1000 7 5", "569405945"], ["1000 7 1", "1000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["洛谷原创", "O2优化", "洛谷月赛"], "title": "[DTOI 2023] D. Goodbye 2022", "background": "> 我用烟花宣告，用挥手告别，用鞠躬感谢，过去的都已经过去，接下来的路我要悠闲地走，愉悦地走，脚步如同时间不会停止，下一年，我们还会再会。\n", "description": "这次的题目背景和 luanmenglei 没有一点关系。\n\n给定 $n,k,p$，求有多少有序 $p$ 元组 $(a_1,a_2,\\cdots,a_p)$ 满足\n\n- $\\forall i \\in [1,p]$，$a_i\\in [1,n]$。\n\n- $\\forall i\\in [1,p)$，$\\operatorname{popcount}(a_i\\oplus a_{i+1})=k$。\n\n- $\\forall i,j\\in[1,p],i\\neq j$，$a_i\\neq a_j$。\n\n答案对 $998244353$ 取模。\n\n---\n\n- 其中 $\\operatorname{popcount}(x)$ 表示 $x$ 在二进制表达下 $1$ 的个数。\n- $\\oplus$ 表示按位异或操作。\n- 两个有序 $p$ 元组 $(a_1,a_2,\\dots,a_p)$，$(b_1,b_2,\\dots,b_p)$ 不同当且仅当存在 $i\\in[1,p]$ 使得 $a_i\\neq b_i$。\n", "inputFormat": "一行三个正整数 $n,k,p$。", "outputFormat": "一行一个数，表示答案。", "hint": "对于所有测试数据，保证 $1\\leq n \\leq 1000$，$1\\leq k\\leq \\lfloor \\log_2 n\\rfloor$，$1 \\leq p \\leq 5$。\n\n每个测试点的具体限制见下表：\n\n|  测试点编号  |      $n\\leq$ | $p =$ |\n| :-: | :-: |:-:|\n| $1$ | $1000$ | $1$ |\n|  $2 \\sim 3$  |       $1000$       |$2$|\n| $4 \\sim 5$ | $300$ |$3$|\n|  $6 \\sim 12$  |      $1000$      |$3$|\n| $13 \\sim 15$ | $1000$ |$4$|\n| $16 \\sim 21$ | $300$ |$5$|\n| $22 \\sim 25$ | $1000$ |$5$|\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[DTOI 2023] D. Goodbye 2022", "background": "> 我用烟花宣告，用挥手告别，用鞠躬感谢，过去的都已经过去，接下来的路我要悠闲地走，愉悦地走，脚步如同时间不会停止，下一年，我们还会再会。\n", "description": "这次的题目背景和 luanmenglei 没有一点关系。\n\n给定 $n,k,p$，求有多少有序 $p$ 元组 $(a_1,a_2,\\cdots,a_p)$ 满足\n\n- $\\forall i \\in [1,p]$，$a_i\\in [1,n]$。\n\n- $\\forall i\\in [1,p)$，$\\operatorname{popcount}(a_i\\oplus a_{i+1})=k$。\n\n- $\\forall i,j\\in[1,p],i\\neq j$，$a_i\\neq a_j$。\n\n答案对 $998244353$ 取模。\n\n---\n\n- 其中 $\\operatorname{popcount}(x)$ 表示 $x$ 在二进制表达下 $1$ 的个数。\n- $\\oplus$ 表示按位异或操作。\n- 两个有序 $p$ 元组 $(a_1,a_2,\\dots,a_p)$，$(b_1,b_2,\\dots,b_p)$ 不同当且仅当存在 $i\\in[1,p]$ 使得 $a_i\\neq b_i$。\n", "inputFormat": "一行三个正整数 $n,k,p$。", "outputFormat": "一行一个数，表示答案。", "hint": "对于所有测试数据，保证 $1\\leq n \\leq 1000$，$1\\leq k\\leq \\lfloor \\log_2 n\\rfloor$，$1 \\leq p \\leq 5$。\n\n每个测试点的具体限制见下表：\n\n|  测试点编号  |      $n\\leq$ | $p =$ |\n| :-: | :-: |:-:|\n| $1$ | $1000$ | $1$ |\n|  $2 \\sim 3$  |       $1000$       |$2$|\n| $4 \\sim 5$ | $300$ |$3$|\n|  $6 \\sim 12$  |      $1000$      |$3$|\n| $13 \\sim 15$ | $1000$ |$4$|\n| $16 \\sim 21$ | $300$ |$5$|\n| $22 \\sim 25$ | $1000$ |$5$|\n", "locale": "zh-CN"}}}
{"pid": "P8942", "type": "P", "difficulty": 2, "samples": [["2\n4 20\n1919 114514\n", "Yes\n1 6 8 16\nNo\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2023", "洛谷原创", "Special Judge", "O2优化", "构造", "Ad-hoc"], "title": "Digital Fortress", "background": "布林克霍夫大声喊道：“这当然是密码！这不是密码，还能是什么？还有什么原因能让友加送掉这枚戒指？到底是谁在戒指上刻一大串杂乱无章的字母？”\n\n方丹愤怒地等了布林克霍夫一眼，使他安静了下来。\n\n“啊……伙计们？”贝克插了一句话，似乎很不情愿卷进来一样，“你们一直说这些是杂乱无章的字母。我想我应该让你们知道……这枚戒指上刻的字母并不是杂乱无章。如果你近距离看一下，就会明白，实际上，这些字母……这个……这个是拉丁文。”\n\n指挥台上的所有人都看向了那枚戒指。上面写道：\n\n> Quis custodiet ipsos custiodies.  \n谁来监视这些监视者……", "description": "致命的变异串已经穿过了 X-11 过滤器，深入了国安局数据库。苏珊与贝克需要即时破解出密码，以关闭蠕虫病毒。\n\n在蠕虫的文件中，他们找到了密码的一个特点：\n\n- 共有 $n$ 位，每个数都在 $[1,m]$ 之间，并且单调不减。\n- 如算出前缀异或和，那么前缀异或和也单调不减。\n- 如算出后缀异或和，那么后缀异或和仍然单调不减。\n\n除此之外，他们也找到了 $n,m$ 的值。现在，他们需要构造出一组密码，以满足所有特征。\n***\n\n#### 【形式化题意】\n\n求是否存在长度为 $n$，所有元素都在 $[1,m]$ 范围内的单调不减正整数序列 $a$，满足：\n\n- $\\forall1<i\\le n,a_1\\ \\text{xor}\\ a_2\\ \\text{xor}\\ \\cdots\\ \\text{xor}\\ a_{i-1}\\le a_1\\ \\text{xor}\\ a_2\\ \\text{xor}\\ \\cdots\\ \\text{xor}\\ a_{i}$\n- $\\forall1\\le i<n,a_n\\ \\text{xor}\\ a_{n-1}\\ \\text{xor}\\ \\cdots\\ \\text{xor}\\ a_{i+1}\\le a_n\\ \\text{xor}\\ a_{n-1}\\ \\text{xor}\\ \\cdots\\ \\text{xor}\\ a_{i}$\n\n如存在，输出一组合法解。多组数据。", "inputFormat": "第一行一个正整数 $t$，表示数据组数。\n\n对于每组数据，输入两个正整数 $n,m$。", "outputFormat": "对于每组数据，如不存在满足要求的密码，输出 `No`。否则，输出 `Yes`，并在下一行输出一种合法方案。", "hint": "#### 【样例解释】\n\n对于第一组数据，密码的前缀异或和为 $\\{1,7,15,31\\}$，后缀异或和为 $\\{16,24,30,31\\}$，均为递增序列，满足题意。\n\n对于第二组数据，不存在任何合法方案。\n\n#### 【数据范围】\n\n**本题开启捆绑测试。**\n\n|$\\text{Subtask}$|分值|$n\\le$|$m\\le$|\n|:-:|:-:|:-:|:-:|\n|$0$|$10$|$5$|$200$|\n|$1$|$30$|$20$|$10^6$|\n|$2$|$60$|$10^5$|$2^{63}-1$|\n\n对于 $100\\%$ 的数据，$1\\le n\\le10^5$，$1\\le m\\le2^{63}-1$，$1\\le t\\le50$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Digital Fortress", "background": "布林克霍夫大声喊道：“这当然是密码！这不是密码，还能是什么？还有什么原因能让友加送掉这枚戒指？到底是谁在戒指上刻一大串杂乱无章的字母？”\n\n方丹愤怒地等了布林克霍夫一眼，使他安静了下来。\n\n“啊……伙计们？”贝克插了一句话，似乎很不情愿卷进来一样，“你们一直说这些是杂乱无章的字母。我想我应该让你们知道……这枚戒指上刻的字母并不是杂乱无章。如果你近距离看一下，就会明白，实际上，这些字母……这个……这个是拉丁文。”\n\n指挥台上的所有人都看向了那枚戒指。上面写道：\n\n> Quis custodiet ipsos custiodies.  \n谁来监视这些监视者……", "description": "致命的变异串已经穿过了 X-11 过滤器，深入了国安局数据库。苏珊与贝克需要即时破解出密码，以关闭蠕虫病毒。\n\n在蠕虫的文件中，他们找到了密码的一个特点：\n\n- 共有 $n$ 位，每个数都在 $[1,m]$ 之间，并且单调不减。\n- 如算出前缀异或和，那么前缀异或和也单调不减。\n- 如算出后缀异或和，那么后缀异或和仍然单调不减。\n\n除此之外，他们也找到了 $n,m$ 的值。现在，他们需要构造出一组密码，以满足所有特征。\n***\n\n#### 【形式化题意】\n\n求是否存在长度为 $n$，所有元素都在 $[1,m]$ 范围内的单调不减正整数序列 $a$，满足：\n\n- $\\forall1<i\\le n,a_1\\ \\text{xor}\\ a_2\\ \\text{xor}\\ \\cdots\\ \\text{xor}\\ a_{i-1}\\le a_1\\ \\text{xor}\\ a_2\\ \\text{xor}\\ \\cdots\\ \\text{xor}\\ a_{i}$\n- $\\forall1\\le i<n,a_n\\ \\text{xor}\\ a_{n-1}\\ \\text{xor}\\ \\cdots\\ \\text{xor}\\ a_{i+1}\\le a_n\\ \\text{xor}\\ a_{n-1}\\ \\text{xor}\\ \\cdots\\ \\text{xor}\\ a_{i}$\n\n如存在，输出一组合法解。多组数据。", "inputFormat": "第一行一个正整数 $t$，表示数据组数。\n\n对于每组数据，输入两个正整数 $n,m$。", "outputFormat": "对于每组数据，如不存在满足要求的密码，输出 `No`。否则，输出 `Yes`，并在下一行输出一种合法方案。", "hint": "#### 【样例解释】\n\n对于第一组数据，密码的前缀异或和为 $\\{1,7,15,31\\}$，后缀异或和为 $\\{16,24,30,31\\}$，均为递增序列，满足题意。\n\n对于第二组数据，不存在任何合法方案。\n\n#### 【数据范围】\n\n**本题开启捆绑测试。**\n\n|$\\text{Subtask}$|分值|$n\\le$|$m\\le$|\n|:-:|:-:|:-:|:-:|\n|$0$|$10$|$5$|$200$|\n|$1$|$30$|$20$|$10^6$|\n|$2$|$60$|$10^5$|$2^{63}-1$|\n\n对于 $100\\%$ 的数据，$1\\le n\\le10^5$，$1\\le m\\le2^{63}-1$，$1\\le t\\le50$。", "locale": "zh-CN"}}}
{"pid": "P8943", "type": "P", "difficulty": 3, "samples": [["8 3\n2 1\n3 1 \n4 2 \n5 3\n6 2\n7 5\n8 4\n5 6\n7 8\n8 6\n3 6", "Survive\nDeception\nSurvive\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2023", "洛谷原创", "O2优化", "最短路", "基环树"], "title": "Deception Point", "background": "“防空火网已启用。”三角洲二号喊道，他坐在“基奥瓦”武装直升机舱门边的武器控制椅里，竖起了大拇指，“火力网\n、调制噪声、掩护脉冲全都激活并锁定。”\n\n三角洲一号心领神会，驾驶着飞机猛地向右一个侧弯飞机又驶上了一条前往“戈雅”的直线路径。这一招能躲过“戈雅”的雷达监控。\n\n“锡箔包确定！”三角洲二号喊道。\n\n> 绝对的孤立，\n\n三角洲一号想。\n\n> 他们毫无抵抗力。\n\n他们的目标幸运且狡猾地从米尔恩冰架上逃脱了，但这回他们不会再得逞了。雷切尔 · 塞克斯顿和迈克尔 · 托兰选择弃岸上船，真是糟糕的选择。不过，这将是他们所做的最后一个坏决定了。", "description": "雷切尔与迈克尔被困在了“戈雅”号上，而三角洲二号正在顺着雷达追杀二人。幸运的是，雷切尔也有一副雷达，因此双方都能知道对方的位置。\n\n船舱内部共有 $n$ 个舱室，其中有 $n$ 条走廊连接这些舱室。$n$ 个舱室是互相连通的。由于船上空间拥挤，船舱内不会出现小于等于四条走廊组成的环。每过一分钟，雷切尔与三角洲二号都会同时从一个舱室跑到另一个舱室。\n\n如果雷切尔在舱室内或者过道上碰到了三角洲，那么就意味着大限将至。雷切尔总共有 $q$ 个问题：当她在舱室 $x$，且三角洲二号在舱室 $y$ 时，她是否可以存活下来？\n\n---\n\n#### **【形式化题意】**\n\n给定一张 $n$ 个点 $n$ 条边的无向连通图，图内不存在四元（及以下）环。$q$ 次询问 $x,y$，分别在图上 $x,y$ 点上放上棋子 $\\rm A, B$。\n\n每次两人同时操作棋子沿图边移动一步，若两棋子同时走到了同一个点上或者同时走过了相同的边，则 $\\rm B$ 胜利。如果在 $10^{10^{9961}}$ 次操作后 $\\rm B$ 还未胜利，则 $\\rm A$ 胜利。\n\n$\\rm A,B$ 都是绝顶聪明的，他们不会做出对自己不利的决策。请你求出每次游戏的游戏结果。若 $\\rm A$ 获胜，输出 `Survive`；否则输出 `Deception`。\n\n**若对题意有疑问，请移步样例解释与数据范围部分。**", "inputFormat": "第一行两个整数 $n,q$。  \n接下来 $n$ 行，每行两个整数 $u_i,v_i$，表示舱室 $u_i$ 与 $v_i$ 之间有一条过道。\n之后 $q$ 行，每行两个整数 $x_i,y_i$，表示一次询问。", "outputFormat": "共 $q$ 行。对于每个询问，如果雷切尔可以存活，那么输出 `Survive`，否则输出 `Deception`。", "hint": "#### 【样例解释】\n\n船舱结构图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tlsqnsia.png)\n\n在第二组询问中，三角洲可以先走一步到达结点 $2$，此时雷切尔到达结点 $4$。随后可以证明，不存在一种方案使得雷切尔不碰到三角洲。\n\n#### 【数据范围】\n\n**本题开启捆绑测试。**\n\n| $\\text{Subtask}$ | 分值 | $n\\le$ | $q\\le$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $0$ | $5$ | $2\\times10^5$ | $1$ | 无 |\n| $1$ | $5$ | $10$ | $2\\times10^5$ | 无 |\n| $2$ | $5$ | $2\\times 10^5$ | $2\\times10^5$ | $\\forall 1\\le i\\le n, u_i=i,v_i=(i\\bmod n) + 1$ |\n| $3$ | $15$ | $200$ | $2\\times 10^5$ | 无 |\n| $4$ | $20$ | $2\\times 10^3$ | $2\\times 10^5$ | 无 |\n| $5$ | $50$ | $2\\times 10^5$ | $2\\times 10^5$ | 无 |\n\n对于 $100\\%$ 的数据，$3\\le n\\le 2\\times10^5$，$1\\le q\\le2\\times10^5$，$u_i\\neq v_i$，$x_i\\neq y_i$。不存在四（及以下）元环。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Deception Point", "background": "“防空火网已启用。”三角洲二号喊道，他坐在“基奥瓦”武装直升机舱门边的武器控制椅里，竖起了大拇指，“火力网\n、调制噪声、掩护脉冲全都激活并锁定。”\n\n三角洲一号心领神会，驾驶着飞机猛地向右一个侧弯飞机又驶上了一条前往“戈雅”的直线路径。这一招能躲过“戈雅”的雷达监控。\n\n“锡箔包确定！”三角洲二号喊道。\n\n> 绝对的孤立，\n\n三角洲一号想。\n\n> 他们毫无抵抗力。\n\n他们的目标幸运且狡猾地从米尔恩冰架上逃脱了，但这回他们不会再得逞了。雷切尔 · 塞克斯顿和迈克尔 · 托兰选择弃岸上船，真是糟糕的选择。不过，这将是他们所做的最后一个坏决定了。", "description": "雷切尔与迈克尔被困在了“戈雅”号上，而三角洲二号正在顺着雷达追杀二人。幸运的是，雷切尔也有一副雷达，因此双方都能知道对方的位置。\n\n船舱内部共有 $n$ 个舱室，其中有 $n$ 条走廊连接这些舱室。$n$ 个舱室是互相连通的。由于船上空间拥挤，船舱内不会出现小于等于四条走廊组成的环。每过一分钟，雷切尔与三角洲二号都会同时从一个舱室跑到另一个舱室。\n\n如果雷切尔在舱室内或者过道上碰到了三角洲，那么就意味着大限将至。雷切尔总共有 $q$ 个问题：当她在舱室 $x$，且三角洲二号在舱室 $y$ 时，她是否可以存活下来？\n\n---\n\n#### **【形式化题意】**\n\n给定一张 $n$ 个点 $n$ 条边的无向连通图，图内不存在四元（及以下）环。$q$ 次询问 $x,y$，分别在图上 $x,y$ 点上放上棋子 $\\rm A, B$。\n\n每次两人同时操作棋子沿图边移动一步，若两棋子同时走到了同一个点上或者同时走过了相同的边，则 $\\rm B$ 胜利。如果在 $10^{10^{9961}}$ 次操作后 $\\rm B$ 还未胜利，则 $\\rm A$ 胜利。\n\n$\\rm A,B$ 都是绝顶聪明的，他们不会做出对自己不利的决策。请你求出每次游戏的游戏结果。若 $\\rm A$ 获胜，输出 `Survive`；否则输出 `Deception`。\n\n**若对题意有疑问，请移步样例解释与数据范围部分。**", "inputFormat": "第一行两个整数 $n,q$。  \n接下来 $n$ 行，每行两个整数 $u_i,v_i$，表示舱室 $u_i$ 与 $v_i$ 之间有一条过道。\n之后 $q$ 行，每行两个整数 $x_i,y_i$，表示一次询问。", "outputFormat": "共 $q$ 行。对于每个询问，如果雷切尔可以存活，那么输出 `Survive`，否则输出 `Deception`。", "hint": "#### 【样例解释】\n\n船舱结构图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tlsqnsia.png)\n\n在第二组询问中，三角洲可以先走一步到达结点 $2$，此时雷切尔到达结点 $4$。随后可以证明，不存在一种方案使得雷切尔不碰到三角洲。\n\n#### 【数据范围】\n\n**本题开启捆绑测试。**\n\n| $\\text{Subtask}$ | 分值 | $n\\le$ | $q\\le$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $0$ | $5$ | $2\\times10^5$ | $1$ | 无 |\n| $1$ | $5$ | $10$ | $2\\times10^5$ | 无 |\n| $2$ | $5$ | $2\\times 10^5$ | $2\\times10^5$ | $\\forall 1\\le i\\le n, u_i=i,v_i=(i\\bmod n) + 1$ |\n| $3$ | $15$ | $200$ | $2\\times 10^5$ | 无 |\n| $4$ | $20$ | $2\\times 10^3$ | $2\\times 10^5$ | 无 |\n| $5$ | $50$ | $2\\times 10^5$ | $2\\times 10^5$ | 无 |\n\n对于 $100\\%$ 的数据，$3\\le n\\le 2\\times10^5$，$1\\le q\\le2\\times10^5$，$u_i\\neq v_i$，$x_i\\neq y_i$。不存在四（及以下）元环。", "locale": "zh-CN"}}}
{"pid": "P8944", "type": "P", "difficulty": 4, "samples": [["2 9 998244353\n", "2684354563\n"], ["7 3 123456789\n", "24313281849\n"], ["10 9000000000000000000 1000000000000000000\n", "20026214895\n"], ["4 0 123456789\n", "12357556560\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "数学", "2023", "洛谷原创", "O2优化", "矩阵加速"], "title": "The Da Vinci Code", "background": "> 圣杯在罗斯琳教堂下静待。  \n> 大师杰作掩映中相拥入眠。  \n> 剑刃圣杯守护着她的门宅。  \n> 星空下她可安息无碍。\n\n好的题目不需要花里胡哨的背景。", "description": "给定一个长度为 $n$ 的数列 $a$，初始情况下 $a_i=i$。\n\n另有一个取值在 $[1,n]$ 内的随机的整数 $x$，它取 $i$ 的概率为 $b_i$。\n\n接下来进行 $k$ 次操作，每次**均匀随机**地选两个 $[1,n]$ 中的整数 $i,j$（允许 $i=j$），交换 $a_i,a_j$ 的值（如果 $i=j$ 则什么也不干）。问最后 $x$ 在位置 $i$ 上的概率，你需要对所有 $1\\leq i\\leq n$ 求出答案。你需要输出答案模 $3221225473$ 的值。\n\n我们定义 $x$ 在位置 $i$ 上指 $a_i=x$。", "inputFormat": "一行三个整数 $n,k,seed$。接下来使用如下代码生成 $b_i$：\n\n```cpp\n#include <cstdio>\n\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst uint mod = 3221225473u;\nconst int N = 20000010;\n\null seed;\n\null getnext() {\n\tseed ^= seed << 13;\n\tseed ^= seed >> 17;\n\tseed ^= seed << 5;\n\treturn seed;\n}\n\nuint rd(uint l, uint r) {\n\treturn getnext() % (r - l + 1) + l;\n}\n\nint n;\null k;\nuint b[N];\n\nint main() {\n\tscanf(\"%d%llu%llu\", &n, &k, &seed);\n\tull sum = 0;\n\tfor (int i = 1; i < n; ++ i) b[i] = rd(2u, mod - 1), (sum += b[i]) %= mod;\n\tb[n] = mod + 1 - sum;\n}\n```\n", "outputFormat": "设 $ans_i$ 表示 $x$ 在位置 $i$ 上的概率模 $3221225473$，则输出 $ans_i\\times i$ 的异或和。", "hint": "#### 【样例解释】\n\n对于样例 #1：\n\n$b$ 数组为 $\\{2134949164 ,1086276310\\}$，操作 $9$ 次后 $x$ 在两个位置的概率均为 $\\dfrac12$。\n\n对于样例 #2：\n\n$b$ 数组为 $\\{1863763622,1043615898,1055155266,1556793106,1763540175,1239801170,1141007183\\}$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据：\n\n* $2\\leq n\\leq2\\times10^7$，$0\\leq k,seed<2^{64}$。\n* $1<b_i<3221225473$，$\\sum\\limits_{i=1}^n b_i\\equiv 1\\pmod{3221225473}$。\n* 数据保证 $1<b_n<3221225473$ 且 $3221225473$ 是质数。\n\n---\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ |$n\\le$|$k\\le$|分值|\n|:-:|:-:|:-:|:-:|\n|$0$|$2$|$2^{64}-1$|$1$|\n|$1$|$5$|$5$|$4$|\n|$2$|$200$|$200$|$6$|\n|$3$|$200$|$2^{64}-1$|$9$|\n|$4$|$2000$|$2000$|$7$|\n|$5$|$2\\times10^7$|$1$|$5$|\n|$6$|$10^6$|$10^6$|$8$|\n|$7$|$2\\times10^7$|$10^7$|$10$|\n|$8$|$10^6$|$2^{64}-1$|$15$|\n|$9$|$2\\times10^7$|$2^{64}-1$|$35$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "The Da Vinci Code", "background": "> 圣杯在罗斯琳教堂下静待。  \n> 大师杰作掩映中相拥入眠。  \n> 剑刃圣杯守护着她的门宅。  \n> 星空下她可安息无碍。\n\n好的题目不需要花里胡哨的背景。", "description": "给定一个长度为 $n$ 的数列 $a$，初始情况下 $a_i=i$。\n\n另有一个取值在 $[1,n]$ 内的随机的整数 $x$，它取 $i$ 的概率为 $b_i$。\n\n接下来进行 $k$ 次操作，每次**均匀随机**地选两个 $[1,n]$ 中的整数 $i,j$（允许 $i=j$），交换 $a_i,a_j$ 的值（如果 $i=j$ 则什么也不干）。问最后 $x$ 在位置 $i$ 上的概率，你需要对所有 $1\\leq i\\leq n$ 求出答案。你需要输出答案模 $3221225473$ 的值。\n\n我们定义 $x$ 在位置 $i$ 上指 $a_i=x$。", "inputFormat": "一行三个整数 $n,k,seed$。接下来使用如下代码生成 $b_i$：\n\n```cpp\n#include <cstdio>\n\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst uint mod = 3221225473u;\nconst int N = 20000010;\n\null seed;\n\null getnext() {\n\tseed ^= seed << 13;\n\tseed ^= seed >> 17;\n\tseed ^= seed << 5;\n\treturn seed;\n}\n\nuint rd(uint l, uint r) {\n\treturn getnext() % (r - l + 1) + l;\n}\n\nint n;\null k;\nuint b[N];\n\nint main() {\n\tscanf(\"%d%llu%llu\", &n, &k, &seed);\n\tull sum = 0;\n\tfor (int i = 1; i < n; ++ i) b[i] = rd(2u, mod - 1), (sum += b[i]) %= mod;\n\tb[n] = mod + 1 - sum;\n}\n```\n", "outputFormat": "设 $ans_i$ 表示 $x$ 在位置 $i$ 上的概率模 $3221225473$，则输出 $ans_i\\times i$ 的异或和。", "hint": "#### 【样例解释】\n\n对于样例 #1：\n\n$b$ 数组为 $\\{2134949164 ,1086276310\\}$，操作 $9$ 次后 $x$ 在两个位置的概率均为 $\\dfrac12$。\n\n对于样例 #2：\n\n$b$ 数组为 $\\{1863763622,1043615898,1055155266,1556793106,1763540175,1239801170,1141007183\\}$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据：\n\n* $2\\leq n\\leq2\\times10^7$，$0\\leq k,seed<2^{64}$。\n* $1<b_i<3221225473$，$\\sum\\limits_{i=1}^n b_i\\equiv 1\\pmod{3221225473}$。\n* 数据保证 $1<b_n<3221225473$ 且 $3221225473$ 是质数。\n\n---\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ |$n\\le$|$k\\le$|分值|\n|:-:|:-:|:-:|:-:|\n|$0$|$2$|$2^{64}-1$|$1$|\n|$1$|$5$|$5$|$4$|\n|$2$|$200$|$200$|$6$|\n|$3$|$200$|$2^{64}-1$|$9$|\n|$4$|$2000$|$2000$|$7$|\n|$5$|$2\\times10^7$|$1$|$5$|\n|$6$|$10^6$|$10^6$|$8$|\n|$7$|$2\\times10^7$|$10^7$|$10$|\n|$8$|$10^6$|$2^{64}-1$|$15$|\n|$9$|$2\\times10^7$|$2^{64}-1$|$35$|", "locale": "zh-CN"}}}
{"pid": "P8945", "type": "P", "difficulty": 5, "samples": [["5 2\n1 0 -1 0 0", "2"]], "limits": {"time": [777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "单调队列", "2023", "洛谷原创", "O2优化", "前缀和"], "title": "Inferno", "background": "> 我是幽灵。  \n> 穿过悲惨之城，我落荒而逃。  \n> 穿过永世凄苦，我远走高飞。\n\n沿着阿尔诺河的堤岸，我夺路狂奔，气喘吁吁……左转上了卡斯特拉尼大街，一直朝北而行，始终隐蔽在乌菲兹美术馆的阴影之下。\n\n但他们还是穷追不舍。\n\n他们的脚步声越来越响，这些追捕者冷酷无情，不达目的绝不善罢甘休。\n\n这么多年来，他们一直尾随着我。他们锲而不舍，是的我只能活在地下……被迫呆在炼狱之中……就像冥府的恶魔，时刻忍受地狱的煎熬。\n\n> 我是幽灵。\n\n如今浮生尘世，我举目北望，却看不到通往救赎的捷径——那高耸的亚平宁山脉挡住了黎明的第一缕阳光。", "description": "罗伯特 · 兰登在洗下但丁死亡面具上的丙烯石膏后，在背面发现了一行字：\n\n> 哦，有着稳固智慧的人啊，  \n> 请注意这里的含义  \n> 就藏在晦涩的序列面纱之下。\n\n下面有一行由 $1,-1$ 组成的长度为 $n$ 的序列。面具经受了岁月的侵蚀，序列中有一些数已经模糊不清。幸运的是，面具下面有给出两条线索：\n\n> 你只得往空缺的位置填 $k$ 个 $1$，其余填入 $-1$，需要最大化这个序列的最大子段和。\n\n > > **一个序列的最大子段和定义为，其在一段连续长度的区间内的最大和。形式化地，一个序列 $a$ 的最大子段和即为 $\\max\\limits_{l=1}^n\\max\\limits_{r=l}^n\\left(\\sum\\limits_{i=l}^r a_i\\right)$。**\n\n罗伯特 · 兰登希望在瘟疫扩散之前找到有关的线索。于是他找到了你。\n\n- - -\n\n#### 【形式化题意】\n\n给定一个只包含 $-1,0,1$ 的序列，求出往 $0$ 的位置上填 $k$ 个 $1$，其余填 $-1$ 后最大子段和的最大值。", "inputFormat": "第一行两个正整数 $n,k$。\n\n接下来一行 $n$ 个整数 $a_i\\in\\{-1,0,1\\}$，其中 $0$ 表示数字模糊不清。", "outputFormat": "一行一个正整数，表示可能的最大子段和。", "hint": "#### 【样例解释】\n\n一种可行的方案是填入 $\\{1,1,-1\\}$，最大子段和为 $2$。\n\n#### 【数据范围】\n\n\n**本题开启捆绑测试。**\n\n| $\\text{SubTask}$ | 分值 | $n,k\\le $ |\n| :----------: | :----------: | :----------: |\n| $0$ | $4$ | $20$ | \n| $1$ | $6$ | $200$ | \n| $2$ | $10$ | $5\\times 10^3$ | \n| $3$ | $30$ | $5\\times 10^5$ | \n| $4$ | $50$ | $10^7$ | \n\n\n对于 $100\\%$ 的数据，$1\\le n,k\\le10^7$，$a_i\\in \\{-1,0,1\\}$。保证 $k\\le$ 序列中 $0$ 的个数。\n\n**本题标程使用优化后的输入输出，在 O2 优化下最大点用时约 $350$ ms，足以通过此题。如果您自认为您的程序复杂度正确，却超出时间限制，请使用更优的输入输出方式，或者优化常数。**\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Inferno", "background": "> 我是幽灵。  \n> 穿过悲惨之城，我落荒而逃。  \n> 穿过永世凄苦，我远走高飞。\n\n沿着阿尔诺河的堤岸，我夺路狂奔，气喘吁吁……左转上了卡斯特拉尼大街，一直朝北而行，始终隐蔽在乌菲兹美术馆的阴影之下。\n\n但他们还是穷追不舍。\n\n他们的脚步声越来越响，这些追捕者冷酷无情，不达目的绝不善罢甘休。\n\n这么多年来，他们一直尾随着我。他们锲而不舍，是的我只能活在地下……被迫呆在炼狱之中……就像冥府的恶魔，时刻忍受地狱的煎熬。\n\n> 我是幽灵。\n\n如今浮生尘世，我举目北望，却看不到通往救赎的捷径——那高耸的亚平宁山脉挡住了黎明的第一缕阳光。", "description": "罗伯特 · 兰登在洗下但丁死亡面具上的丙烯石膏后，在背面发现了一行字：\n\n> 哦，有着稳固智慧的人啊，  \n> 请注意这里的含义  \n> 就藏在晦涩的序列面纱之下。\n\n下面有一行由 $1,-1$ 组成的长度为 $n$ 的序列。面具经受了岁月的侵蚀，序列中有一些数已经模糊不清。幸运的是，面具下面有给出两条线索：\n\n> 你只得往空缺的位置填 $k$ 个 $1$，其余填入 $-1$，需要最大化这个序列的最大子段和。\n\n > > **一个序列的最大子段和定义为，其在一段连续长度的区间内的最大和。形式化地，一个序列 $a$ 的最大子段和即为 $\\max\\limits_{l=1}^n\\max\\limits_{r=l}^n\\left(\\sum\\limits_{i=l}^r a_i\\right)$。**\n\n罗伯特 · 兰登希望在瘟疫扩散之前找到有关的线索。于是他找到了你。\n\n- - -\n\n#### 【形式化题意】\n\n给定一个只包含 $-1,0,1$ 的序列，求出往 $0$ 的位置上填 $k$ 个 $1$，其余填 $-1$ 后最大子段和的最大值。", "inputFormat": "第一行两个正整数 $n,k$。\n\n接下来一行 $n$ 个整数 $a_i\\in\\{-1,0,1\\}$，其中 $0$ 表示数字模糊不清。", "outputFormat": "一行一个正整数，表示可能的最大子段和。", "hint": "#### 【样例解释】\n\n一种可行的方案是填入 $\\{1,1,-1\\}$，最大子段和为 $2$。\n\n#### 【数据范围】\n\n\n**本题开启捆绑测试。**\n\n| $\\text{SubTask}$ | 分值 | $n,k\\le $ |\n| :----------: | :----------: | :----------: |\n| $0$ | $4$ | $20$ | \n| $1$ | $6$ | $200$ | \n| $2$ | $10$ | $5\\times 10^3$ | \n| $3$ | $30$ | $5\\times 10^5$ | \n| $4$ | $50$ | $10^7$ | \n\n\n对于 $100\\%$ 的数据，$1\\le n,k\\le10^7$，$a_i\\in \\{-1,0,1\\}$。保证 $k\\le$ 序列中 $0$ 的个数。\n\n**本题标程使用优化后的输入输出，在 O2 优化下最大点用时约 $350$ ms，足以通过此题。如果您自认为您的程序复杂度正确，却超出时间限制，请使用更优的输入输出方式，或者优化常数。**\n", "locale": "zh-CN"}}}
{"pid": "P8946", "type": "P", "difficulty": 7, "samples": [["2 2\nC", "4"], ["2 2\nA", "5"], ["8 8\nCCACAAC", "399968"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "洛谷原创", "O2优化"], "title": "The Lost Symbol", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/g4ofcg40.png)", "description": "设二元运算符 $k\\operatorname A n$ 为排列数 ${\\rm A}_n^k$，$k \\operatorname C n$ 为组合数 ${\\rm C}_n^k$，定义 $k>n$ 时两者的值都为 $0$。\n\n给定 $n,m$ 和一个长度为 $n-1$ 的仅包含 $\\textrm A,\\textrm C$ 的序列 ${\\rm opt}_{[1,n-1]}$，对所有长度为 $n$，且每一个数都是 $[1,m]$ 中的整数的序列 $a_{[1,n]}$ 求 $(\\cdots(((a_1\\operatorname{opt}_1 a_2)\\operatorname{opt}_2 a_3)\\operatorname{opt}_3 a_4)\\cdots\\operatorname{opt}_{n-2}a_{n-1})\\operatorname{opt}_{n-1}a_n$ 的和。\n\n答案对质数 $11417603$ 取模。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来一行一个长度为 $n-1$ 的字符串表示 $\\text{opt}$。", "outputFormat": "一行一个整数表示答案。", "hint": "#### 【样例解释】\n对于样例 #1：\n\n$1\\operatorname C 1=1$，$1\\operatorname C 2=2$，$2\\operatorname C 1=0$，$2\\operatorname C 2=1$，求和为 $4$。\n\n对于样例 #2：\n\n$1\\operatorname A 1=1$，$1\\operatorname A 2=2$，$2\\operatorname A 1=0$，$2\\operatorname A 2=2$，求和为 $5$。\n\n#### 【数据范围】\n\n不开启捆绑测试，按点给分。\n\n对于 $100\\%$ 的数据，$2\\leq n,m\\leq 10^5$，${\\rm opt}$ 仅包含 $\\textrm A,\\textrm C$。\n\n| 测试点编号 | $n\\leq$ | $m\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1\\sim3$ | $8$ | $8$ | 无 | \n| $4\\sim6$ | $314$ | $159$ | 无 | \n| $7\\sim10$ | $2718$ | $2818$ | 无 | \n| $11\\sim13$ | $10^5$ | $10^5$ | $\\rm opt$ 仅由 $\\rm A$ 构成 |\n| $14\\sim16$ | $10^5$ | $10^5$ | $\\rm opt$ 仅由 $\\rm C$ 构成 |\n| $17\\sim20$ | $10^5$ | $10^5$ | $\\rm opt$ 由不超过 $10$ 段连续的 $\\rm A$ 和连续的 $\\rm C$ 拼接而成 |\n| $21,22$ | $8492$ | $10^5$ | 无 |\n| $23\\sim25$ | $10^5$ | $10^5$ | 无 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "The Lost Symbol", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/g4ofcg40.png)", "description": "设二元运算符 $k\\operatorname A n$ 为排列数 ${\\rm A}_n^k$，$k \\operatorname C n$ 为组合数 ${\\rm C}_n^k$，定义 $k>n$ 时两者的值都为 $0$。\n\n给定 $n,m$ 和一个长度为 $n-1$ 的仅包含 $\\textrm A,\\textrm C$ 的序列 ${\\rm opt}_{[1,n-1]}$，对所有长度为 $n$，且每一个数都是 $[1,m]$ 中的整数的序列 $a_{[1,n]}$ 求 $(\\cdots(((a_1\\operatorname{opt}_1 a_2)\\operatorname{opt}_2 a_3)\\operatorname{opt}_3 a_4)\\cdots\\operatorname{opt}_{n-2}a_{n-1})\\operatorname{opt}_{n-1}a_n$ 的和。\n\n答案对质数 $11417603$ 取模。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来一行一个长度为 $n-1$ 的字符串表示 $\\text{opt}$。", "outputFormat": "一行一个整数表示答案。", "hint": "#### 【样例解释】\n对于样例 #1：\n\n$1\\operatorname C 1=1$，$1\\operatorname C 2=2$，$2\\operatorname C 1=0$，$2\\operatorname C 2=1$，求和为 $4$。\n\n对于样例 #2：\n\n$1\\operatorname A 1=1$，$1\\operatorname A 2=2$，$2\\operatorname A 1=0$，$2\\operatorname A 2=2$，求和为 $5$。\n\n#### 【数据范围】\n\n不开启捆绑测试，按点给分。\n\n对于 $100\\%$ 的数据，$2\\leq n,m\\leq 10^5$，${\\rm opt}$ 仅包含 $\\textrm A,\\textrm C$。\n\n| 测试点编号 | $n\\leq$ | $m\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1\\sim3$ | $8$ | $8$ | 无 | \n| $4\\sim6$ | $314$ | $159$ | 无 | \n| $7\\sim10$ | $2718$ | $2818$ | 无 | \n| $11\\sim13$ | $10^5$ | $10^5$ | $\\rm opt$ 仅由 $\\rm A$ 构成 |\n| $14\\sim16$ | $10^5$ | $10^5$ | $\\rm opt$ 仅由 $\\rm C$ 构成 |\n| $17\\sim20$ | $10^5$ | $10^5$ | $\\rm opt$ 由不超过 $10$ 段连续的 $\\rm A$ 和连续的 $\\rm C$ 拼接而成 |\n| $21,22$ | $8492$ | $10^5$ | 无 |\n| $23\\sim25$ | $10^5$ | $10^5$ | 无 |", "locale": "zh-CN"}}}
{"pid": "P8947", "type": "P", "difficulty": 7, "samples": [["5 11 0\nabb\naab\nbaab\nbbaa\naabbb\n1 ab\n2 1 1 3\n2 2 2 3\n1 ba\n2 3 1 2\n2 4 1 2\n2 4 2 3\n1 abb\n2 5 2 4\n2 1 1 3\n2 1 1 2\n", "0\n1\n1\n0\n1\n1\n1\n2\n"], ["5 11 1\n114 514 1919810\nabb\naab\nbaab\nbbaa\naabbb\n1 ab\n2 1 1 3\n2 2 2 3\n1 ba\n2 3 1 2\n2 4 1 2\n2 4 2 3\n1 abb\n2 5 2 4\n2 1 1 3\n2 1 1 2\n", "0\n0\n1\n0\n0\n1\n1\n0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2023", "洛谷原创", "后缀自动机 SAM", "O2优化"], "title": "Angels & Demons", "background": "教皇内侍已经感觉到了身体上的疼痛。疼痛迅速传遍了全身，让他想抓想挠。\n\n>不要忘记耶稣所遭受的痛苦。\n\n他感觉喉咙中有种火烧火燎般的疼痛，就连吗啡都无法将之化解。\n\n>我在这里的事情已经做完了。\n\n他激起了人们的敬畏之心，人们又有了希望。\n\n在帕利恩凹室里的时候，教皇内侍遵从上帝的教诲，举行了涂油仪式。他的身体上，发须上，面颊上，麻布长袍上，全身都涂满了灯油。他这会儿像是浸泡在神圣的绿色灯油中一样，气味芬芳，如母亲的体香，可却易燃烧。他将会幸运地升天。那是个充满奇迹而又迅速的过程。他留给世人的不再是丑闻……而是一股新的力量和奇迹。\n\n他的手滑入长袍的口袋，摸出从帕利恩凹室里拿来的小小的金色打火机。\n\n他低声说出了上帝在最后审判时说过的一句话。\n\n>熊熊烈焰直冲云霄，上帝的天使也会在火焰中升天。\n\n他的大拇指按在了打火机上。\n\n人们还在圣彼得广场上唱着颂歌……", "description": "给定 $n$ 个由小写字母组成的模板串 $S_{1...n}$，$q$ 组询问，询问分为以下两种类型：\n\n1. `1 T`：给定一个由小写字母组成的询问串 $T$。\n2. `2 p l r`：设 $num(p,l,r)$ 表示 $S_p$ 的 $[l,r]$ 子串是多少个询问串的子串，求 $\\max\\limits_{i=1}^{l}(num(p,i,r))$。", "inputFormat": "第一行，两个数 $n,q,w_0$，其中 $w_0$ 表示数据类型。\n\n* $w_0=0$：\n  \n  第 $2\\sim n+1$ 行，每行一个字符串，第 $i+1$ 行表示 $S_i$。\n  \n  接下来 $q$ 行，每行一组询问，格式如题。\n* $w_0=1$：\n  \n  第二行，输入三个整数 $A,B,C$。\n  \n  接下来 $n$ 行，每行一个字符串，表示一个模板串。\n  \n  接下来，询问按照如下代码生成（代码中的 ```lst``` 表示上一次询问 $2$ 的答案，初始时为 $0$，```le[i]``` 表示模板串 $i$ 的长度，```s``` 是 char 数组）：\n  \n```cpp\nwhile (q--) {\n\tint op;\n\tscanf(\"%d\", &op);\n\tif (op == 1) {\n\t\tscanf(\"%s\", s + 1);\n\t\tint x((1ll * A * lst + B) % C), l(strlen(s + 1));\n\t\tfor (int i(1); i <= l; ++i) {\n\t\t\tswap(s[i], s[x % l + 1]);\n\t\t\tx = (1ll * A * x + B) % C;\n\t\t}\n\t} else {\n\t\tint p, l, r;\n\t\tscanf(\"%d%d%d\", &p, &l, &r);\n\t\tint x((1ll * A * lst + B) % C);\n\t\tp = (p + x) % n + 1;\n\t\tx = (1ll * A * x + B) % C;\n\t\tl = (l + x) % le[p] + 1;\n\t\tx = (1ll * A * x + B) % C;\n\t\tr = (r + x) % le[p] + 1;\n\t\tif (l > r) swap(l, r);\n\t\t// 此处更新 lst\n\t}\n}\n```\n", "outputFormat": "对于每个询问 $2$，输出一行一个整数表示答案。", "hint": "对于 $100\\%$ 数据：$1\\le n,q\\le 10^5$，$\\sum\\limits_{i=1}^{n}|S_i|\\le5\\times10^5$，$\\sum|T|\\le5\\times10^5$，$1\\le p\\le n$，$w_0\\in\\{0,1\\}$，$1\\le A,B<C\\le10^9$。\n\n|测试点|分值|$n\\le$|$\\sum\\limits_{i=1}^{n}\\|S_i\\|\\le$|$q\\leq $|$\\sum \\| T\\| \\leq $|$w_0=$|其他限制|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|$1$|$3$|$20$|$200$|$200$|$5000$|$0$|无|\n|$2$|$3$|$200$|$2000$|$200$|$5000$|$0$|无|\n|$3$|$3$|$200$|$2000$|$200$|$5000$|$0$|无|\n|$4$|$3$|$200$|$2000$|$200$|$5\\times10^5$|$0$|无|\n|$5$|$3$|$200$|$2000$|$200$|$5\\times10^5$|$0$|无|\n|$6$|$3$|$1$|$5\\times10^5$|$2$|$5\\times10^5$|$0$|无|\n|$7$|$3$|$1$|$5\\times10^5$|$2$|$5\\times10^5$|$0$|无|\n|$8$|$4$|$10^5$|$10^5$|$10^5$|$10^5$|$0$|无|\n|$9$|$3$|$10^5$|$10^5$|$10^5$|$10^5$|$0$|字符串随机|\n|$10$|$4$|$10^5$|$2 \\times 10^5$|$10^5$|$2 \\times 10^5$|$0$|无|\n|$11$|$3$|$10^5$|$2 \\times 10^5$|$10^5$|$2 \\times 10^5$|$0$|字符串随机|\n|$12$|$4$|$10^5$|$3 \\times 10^5$|$10^5$|$3 \\times 10^5$|$0$|无|\n|$13$|$3$|$10^5$|$3 \\times 10^5$|$10^5$|$3 \\times 10^5$|$0$|字符串随机|\n|$14$|$4$|$10^5$|$4 \\times 10^5$|$10^5$|$4 \\times 10^5$|$0$|无|\n|$15$|$3$|$10^5$|$4 \\times 10^5$|$10^5$|$4 \\times 10^5$|$0$|字符串随机|\n|$16$|$4$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$0$|无|\n|$17$|$3$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$0$|字符串随机|\n|$18$|$3$|$10^5$|$2 \\times 10^5$|$10^5$|$5\\times10^5$|$0$|无|\n|$19$|$3$|$10^5$|$3 \\times 10^5$|$10^5$|$5\\times10^5$|$0$|无|\n|$20$|$3$|$10^5$|$4 \\times 10^5$|$10^5$|$5\\times10^5$|$0$|无|\n|$21$|$3$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$0$|字符串随机|\n|$22$|$3$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$0$|无|\n|$23$|$3$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$0$|无|\n|$24$|$3$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$0$|无|\n|$25$|$3$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$0$|无|\n|$26$|$4$|$10^5$|$3\\times10^5$|$10^5$|$5\\times10^5$|$1$|无|\n|$27$|$4$|$10^5$|$4\\times10^5$|$10^5$|$5\\times10^5$|$1$|无|\n|$28$|$4$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$1$|无|\n|$29$|$4$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$1$|无|\n|$30$|$4$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$1$|无|\n\n**测试点 $8\\sim 17$ 保证对于所有询问 $2$，$l=1$。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Angels & Demons", "background": "教皇内侍已经感觉到了身体上的疼痛。疼痛迅速传遍了全身，让他想抓想挠。\n\n>不要忘记耶稣所遭受的痛苦。\n\n他感觉喉咙中有种火烧火燎般的疼痛，就连吗啡都无法将之化解。\n\n>我在这里的事情已经做完了。\n\n他激起了人们的敬畏之心，人们又有了希望。\n\n在帕利恩凹室里的时候，教皇内侍遵从上帝的教诲，举行了涂油仪式。他的身体上，发须上，面颊上，麻布长袍上，全身都涂满了灯油。他这会儿像是浸泡在神圣的绿色灯油中一样，气味芬芳，如母亲的体香，可却易燃烧。他将会幸运地升天。那是个充满奇迹而又迅速的过程。他留给世人的不再是丑闻……而是一股新的力量和奇迹。\n\n他的手滑入长袍的口袋，摸出从帕利恩凹室里拿来的小小的金色打火机。\n\n他低声说出了上帝在最后审判时说过的一句话。\n\n>熊熊烈焰直冲云霄，上帝的天使也会在火焰中升天。\n\n他的大拇指按在了打火机上。\n\n人们还在圣彼得广场上唱着颂歌……", "description": "给定 $n$ 个由小写字母组成的模板串 $S_{1...n}$，$q$ 组询问，询问分为以下两种类型：\n\n1. `1 T`：给定一个由小写字母组成的询问串 $T$。\n2. `2 p l r`：设 $num(p,l,r)$ 表示 $S_p$ 的 $[l,r]$ 子串是多少个询问串的子串，求 $\\max\\limits_{i=1}^{l}(num(p,i,r))$。", "inputFormat": "第一行，两个数 $n,q,w_0$，其中 $w_0$ 表示数据类型。\n\n* $w_0=0$：\n  \n  第 $2\\sim n+1$ 行，每行一个字符串，第 $i+1$ 行表示 $S_i$。\n  \n  接下来 $q$ 行，每行一组询问，格式如题。\n* $w_0=1$：\n  \n  第二行，输入三个整数 $A,B,C$。\n  \n  接下来 $n$ 行，每行一个字符串，表示一个模板串。\n  \n  接下来，询问按照如下代码生成（代码中的 ```lst``` 表示上一次询问 $2$ 的答案，初始时为 $0$，```le[i]``` 表示模板串 $i$ 的长度，```s``` 是 char 数组）：\n  \n```cpp\nwhile (q--) {\n\tint op;\n\tscanf(\"%d\", &op);\n\tif (op == 1) {\n\t\tscanf(\"%s\", s + 1);\n\t\tint x((1ll * A * lst + B) % C), l(strlen(s + 1));\n\t\tfor (int i(1); i <= l; ++i) {\n\t\t\tswap(s[i], s[x % l + 1]);\n\t\t\tx = (1ll * A * x + B) % C;\n\t\t}\n\t} else {\n\t\tint p, l, r;\n\t\tscanf(\"%d%d%d\", &p, &l, &r);\n\t\tint x((1ll * A * lst + B) % C);\n\t\tp = (p + x) % n + 1;\n\t\tx = (1ll * A * x + B) % C;\n\t\tl = (l + x) % le[p] + 1;\n\t\tx = (1ll * A * x + B) % C;\n\t\tr = (r + x) % le[p] + 1;\n\t\tif (l > r) swap(l, r);\n\t\t// 此处更新 lst\n\t}\n}\n```\n", "outputFormat": "对于每个询问 $2$，输出一行一个整数表示答案。", "hint": "对于 $100\\%$ 数据：$1\\le n,q\\le 10^5$，$\\sum\\limits_{i=1}^{n}|S_i|\\le5\\times10^5$，$\\sum|T|\\le5\\times10^5$，$1\\le p\\le n$，$w_0\\in\\{0,1\\}$，$1\\le A,B<C\\le10^9$。\n\n|测试点|分值|$n\\le$|$\\sum\\limits_{i=1}^{n}\\|S_i\\|\\le$|$q\\leq $|$\\sum \\| T\\| \\leq $|$w_0=$|其他限制|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|$1$|$3$|$20$|$200$|$200$|$5000$|$0$|无|\n|$2$|$3$|$200$|$2000$|$200$|$5000$|$0$|无|\n|$3$|$3$|$200$|$2000$|$200$|$5000$|$0$|无|\n|$4$|$3$|$200$|$2000$|$200$|$5\\times10^5$|$0$|无|\n|$5$|$3$|$200$|$2000$|$200$|$5\\times10^5$|$0$|无|\n|$6$|$3$|$1$|$5\\times10^5$|$2$|$5\\times10^5$|$0$|无|\n|$7$|$3$|$1$|$5\\times10^5$|$2$|$5\\times10^5$|$0$|无|\n|$8$|$4$|$10^5$|$10^5$|$10^5$|$10^5$|$0$|无|\n|$9$|$3$|$10^5$|$10^5$|$10^5$|$10^5$|$0$|字符串随机|\n|$10$|$4$|$10^5$|$2 \\times 10^5$|$10^5$|$2 \\times 10^5$|$0$|无|\n|$11$|$3$|$10^5$|$2 \\times 10^5$|$10^5$|$2 \\times 10^5$|$0$|字符串随机|\n|$12$|$4$|$10^5$|$3 \\times 10^5$|$10^5$|$3 \\times 10^5$|$0$|无|\n|$13$|$3$|$10^5$|$3 \\times 10^5$|$10^5$|$3 \\times 10^5$|$0$|字符串随机|\n|$14$|$4$|$10^5$|$4 \\times 10^5$|$10^5$|$4 \\times 10^5$|$0$|无|\n|$15$|$3$|$10^5$|$4 \\times 10^5$|$10^5$|$4 \\times 10^5$|$0$|字符串随机|\n|$16$|$4$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$0$|无|\n|$17$|$3$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$0$|字符串随机|\n|$18$|$3$|$10^5$|$2 \\times 10^5$|$10^5$|$5\\times10^5$|$0$|无|\n|$19$|$3$|$10^5$|$3 \\times 10^5$|$10^5$|$5\\times10^5$|$0$|无|\n|$20$|$3$|$10^5$|$4 \\times 10^5$|$10^5$|$5\\times10^5$|$0$|无|\n|$21$|$3$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$0$|字符串随机|\n|$22$|$3$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$0$|无|\n|$23$|$3$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$0$|无|\n|$24$|$3$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$0$|无|\n|$25$|$3$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$0$|无|\n|$26$|$4$|$10^5$|$3\\times10^5$|$10^5$|$5\\times10^5$|$1$|无|\n|$27$|$4$|$10^5$|$4\\times10^5$|$10^5$|$5\\times10^5$|$1$|无|\n|$28$|$4$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$1$|无|\n|$29$|$4$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$1$|无|\n|$30$|$4$|$10^5$|$5\\times10^5$|$10^5$|$5\\times10^5$|$1$|无|\n\n**测试点 $8\\sim 17$ 保证对于所有询问 $2$，$l=1$。**", "locale": "zh-CN"}}}
{"pid": "P8948", "type": "P", "difficulty": 3, "samples": [["4\n2000\n1319\n1476\n996", "233 525\n147 361\n200 324\n0 523"], ["4\n2000\n1704\n1658\n1542", "400 454\n352 374\n352 353\n320 337"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["洛谷原创", "Special Judge"], "title": "[YsOI2022] NOIp 和省选", "background": "Ysuperman 为了检验他的教学水平，决定给幼儿园的小朋友们来两场摸底考试！", "description": "其中一场考试有四道题目，满分 $400$；另一场考试有六道题目，满分 $600$。每个人每场考试得分都是一个 $0$ 到满分间的一个**非负整数**（可以为 $0$ 或者满分）。\n\n有 $n$ 名同学参加了这两场考试，其中第 $i$ 名同学第一场得分 $a_i$，第二场得分 $b_i$，Ysuperman 通过以下规则计算第 $i$ 名同学的**标准得分** $c_i$：\n\n1. 分别统计两场比赛的最高分 $A,B$，有 $A\\ne 0$，$B\\ne 0$。\n2. 令 $c_i=1000(\\frac{a_i}{A}+\\frac{b_i}{B})$，其中 $c_i$ **四舍五入保留到整数**。\n\n在算出了每位同学的标准得分后，Ysuperman 粗心地弄丢了每位同学的原始分，你能帮 TA 找到任意一组可能的原始分吗？\n\n简单来说，已知 $n$ 和每位同学的**标准得分** $c_{1\\sim n}$，Ysuperman 希望你找到一组合法的 $a_{1\\sim n}$，$b_{1\\sim n}$ 满足上述要求。\n\n特别的，有个十分强的小朋友 Qiu 在两场考试中都拿到了**最高分**，也就是保证 $c_1=2000$。另外其他小朋友水平都差不多，所以保证有 $\\forall i>1,c_i\\in [10,1990]$。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来 $n$ 行，第 $i$ 行一个正整数 $c_i$。", "outputFormat": "输出共 $n$ 行，第 $i$ 行两个非负整数 $a_i,b_i$，由题意可知你需要保证 $a_i\\in [0,400]$，$b_i\\in [0,600]$ 并且 $\\max a_i>0$，$\\max b_i>0$。", "hint": "样例一中构造的 $a,b$ 合法，理由如下：\n\n两场比赛最高得分分别为 $233$ 和 $525$。\n\n$1000\\times (233\\div 233 + 525\\div 525)=2000$。\n\n$1000\\times (147\\div 233 + 361\\div 525) \\approx 1318.520\\approx 1319$。\n\n$1000\\times (200\\div 233 + 324\\div 525)\\approx 1475.512\\approx 1476$。\n\n$1000\\times (0\\div 233 + 523\\div 525)\\approx 996.190\\approx 996$。\n\n前 $20\\%$ 的数据保证 $n\\le 20$。\n\n另外 $20\\%$ 的数据保证 $c_i$ 是 $10$ 的倍数。\n\n另外 $20\\%$ 的数据保证 $c_i$ 是 $5$ 的倍数。\n\n另外 $20\\%$ 的数据保证 $c_i$ 是 $2$ 的倍数。\n\n对于 $100\\%$ 的数据，满足 $1\\le n\\le 10^4$，$c_1=2000$，$\\forall i>1,c_i\\in[10,1990]$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[YsOI2022] NOIp 和省选", "background": "Ysuperman 为了检验他的教学水平，决定给幼儿园的小朋友们来两场摸底考试！", "description": "其中一场考试有四道题目，满分 $400$；另一场考试有六道题目，满分 $600$。每个人每场考试得分都是一个 $0$ 到满分间的一个**非负整数**（可以为 $0$ 或者满分）。\n\n有 $n$ 名同学参加了这两场考试，其中第 $i$ 名同学第一场得分 $a_i$，第二场得分 $b_i$，Ysuperman 通过以下规则计算第 $i$ 名同学的**标准得分** $c_i$：\n\n1. 分别统计两场比赛的最高分 $A,B$，有 $A\\ne 0$，$B\\ne 0$。\n2. 令 $c_i=1000(\\frac{a_i}{A}+\\frac{b_i}{B})$，其中 $c_i$ **四舍五入保留到整数**。\n\n在算出了每位同学的标准得分后，Ysuperman 粗心地弄丢了每位同学的原始分，你能帮 TA 找到任意一组可能的原始分吗？\n\n简单来说，已知 $n$ 和每位同学的**标准得分** $c_{1\\sim n}$，Ysuperman 希望你找到一组合法的 $a_{1\\sim n}$，$b_{1\\sim n}$ 满足上述要求。\n\n特别的，有个十分强的小朋友 Qiu 在两场考试中都拿到了**最高分**，也就是保证 $c_1=2000$。另外其他小朋友水平都差不多，所以保证有 $\\forall i>1,c_i\\in [10,1990]$。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来 $n$ 行，第 $i$ 行一个正整数 $c_i$。", "outputFormat": "输出共 $n$ 行，第 $i$ 行两个非负整数 $a_i,b_i$，由题意可知你需要保证 $a_i\\in [0,400]$，$b_i\\in [0,600]$ 并且 $\\max a_i>0$，$\\max b_i>0$。", "hint": "样例一中构造的 $a,b$ 合法，理由如下：\n\n两场比赛最高得分分别为 $233$ 和 $525$。\n\n$1000\\times (233\\div 233 + 525\\div 525)=2000$。\n\n$1000\\times (147\\div 233 + 361\\div 525) \\approx 1318.520\\approx 1319$。\n\n$1000\\times (200\\div 233 + 324\\div 525)\\approx 1475.512\\approx 1476$。\n\n$1000\\times (0\\div 233 + 523\\div 525)\\approx 996.190\\approx 996$。\n\n前 $20\\%$ 的数据保证 $n\\le 20$。\n\n另外 $20\\%$ 的数据保证 $c_i$ 是 $10$ 的倍数。\n\n另外 $20\\%$ 的数据保证 $c_i$ 是 $5$ 的倍数。\n\n另外 $20\\%$ 的数据保证 $c_i$ 是 $2$ 的倍数。\n\n对于 $100\\%$ 的数据，满足 $1\\le n\\le 10^4$，$c_1=2000$，$\\forall i>1,c_i\\in[10,1990]$。", "locale": "zh-CN"}}}
{"pid": "P8949", "type": "P", "difficulty": 7, "samples": [["5 3\n1 2\n1 3\n3 4\n3 5\n3 2\n3 4\n3 5\n1 2", "1\n2 3 0 3 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["点分治", "洛谷原创", "Special Judge", "构造"], "title": "[YsOI2022] 淀粉树", "background": "Ysuperman 教大家淀粉质和淀粉树。", "description": "Ysuperman 定义一棵**有根树** $S$ 是树 $T$ 的一棵淀粉树当且仅当 $S$ 满足如下两个条件（记 $s_i$ 表示 $S$ 中以 $i$ 为根的子树中所有点构成的点集）：\n\n1. $S$ 与 $T$ 点数相同（不妨设为 $n$）且编号为 $1\\sim n$。\n1. 对于 $S$ 中任意一个有儿子的点 $i$，对于其任意一个儿子 $j$，满足在 $T$ 中 $i$ 与 $s_j$ 中至少一个点有直接连边。\n\n容易发现一棵树 $T$ 的淀粉树可能有很多棵。\n\nYsuperman 现在给定 $n$ 以及两棵点编号 $1\\sim n$ 的树 $T$ 和树 $S$，设树 $S$ 中度数最大的点的度数为 $d$，TA 需要你进行至少一次且不超过 $d$ 次操作，每次操作把 $T$ 替换成它的任意一棵淀粉树，使得最终 $T$ 变成 $S$。\n\n请注意，这里给定的 $S$ 是没有给定根的，你只需要满足最后 $T$ 的连边情况和 $S$ 相同我们就认为 $T$ 变成了 $S$。\n\n输入保证存在至少一组解。", "inputFormat": "第一行两个数 $n,d$，保证 $d$ 等于 $S$ 中度数最大的点的度数。\n\n接下来 $n-1$ 行每行两个数 $u,v$ 表示 $T$ 中 $u,v$ 有连边。保证形成一棵树。\n\n接下来 $n-1$ 行每行两个数 $u,v$ 表示 $S$ 中 $u,v$ 有连边。保证形成一棵树。", "outputFormat": "为了方便检验，Ysuperman 需要你按照有根树的形式输出答案。\n\n答案第一行一个正整数 $k(1\\le k\\le d)$ 表示你进行的操作数。\n\n接下来 $k$ 行第 $i$ 行 $n$ 个整数表示你进行第 $i$ 次操作后 $T$ 变成的有根树中 $1\\sim n$ 各个点的父亲编号，根的父亲编号规定为 $0$，**请保证你输出树的根是淀粉树的根**。", "hint": "#### 样例 1 解释\n\n这是 $T$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5qlv4q4t.png)\n\n这是 $S$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xoyaon7y.png)\n\n该输出仅对 $T$ 进行了一次操作，即将 $T$ 变成了下面这棵有根树：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0kozi468.png)\n\n这棵有根树是 $T$ 的一棵淀粉树，理由如下：\n\n1. 对于 $2$ 的儿子 $1$，在 $T$ 中 $2$ 与 $s_1=\\{1\\}$ 中的 $1$ 有直接连边。\n2. 对于 $3$ 的儿子 $2$，在 $T$ 中 $3$ 与 $s_2=\\{1,2\\}$ 中的 $1$ 有直接连边。\n3. 对于 $3$ 的儿子 $4$，在 $T$ 中 $3$ 与 $s_4=\\{4\\}$ 中的 $4$ 有直接连边。\n4. 对于 $3$ 的儿子 $5$，在 $T$ 中 $3$ 与 $s_5=\\{5\\}$ 中的 $5$ 有直接连边。\n\n最终得到的有根树和 $S$ 的连边情况相同，所以这份输出将被判定为正确。\n\n#### 数据范围\n\n子任务 $1$（$20$ 分），满足 $n\\le 6$。\n\n子任务 $2$（$20$ 分），满足 $d=2$。\n\n子任务 $3$（$20$ 分），满足 $T$ 可以只进行一次操作即可变成 $S$ 且 $n\\le 447$。\n\n子任务 $4$（$20$ 分），满足 $n\\le 2000$。\n\n子任务 $5$（$20$ 分），无特殊限制。\n\n对于所有数据，满足 $2\\le n\\le 10^5$，$d\\times n\\le 2\\times 10^5$。\n\n#### 提示\n\n附件下发了本题 checker。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[YsOI2022] 淀粉树", "background": "Ysuperman 教大家淀粉质和淀粉树。", "description": "Ysuperman 定义一棵**有根树** $S$ 是树 $T$ 的一棵淀粉树当且仅当 $S$ 满足如下两个条件（记 $s_i$ 表示 $S$ 中以 $i$ 为根的子树中所有点构成的点集）：\n\n1. $S$ 与 $T$ 点数相同（不妨设为 $n$）且编号为 $1\\sim n$。\n1. 对于 $S$ 中任意一个有儿子的点 $i$，对于其任意一个儿子 $j$，满足在 $T$ 中 $i$ 与 $s_j$ 中至少一个点有直接连边。\n\n容易发现一棵树 $T$ 的淀粉树可能有很多棵。\n\nYsuperman 现在给定 $n$ 以及两棵点编号 $1\\sim n$ 的树 $T$ 和树 $S$，设树 $S$ 中度数最大的点的度数为 $d$，TA 需要你进行至少一次且不超过 $d$ 次操作，每次操作把 $T$ 替换成它的任意一棵淀粉树，使得最终 $T$ 变成 $S$。\n\n请注意，这里给定的 $S$ 是没有给定根的，你只需要满足最后 $T$ 的连边情况和 $S$ 相同我们就认为 $T$ 变成了 $S$。\n\n输入保证存在至少一组解。", "inputFormat": "第一行两个数 $n,d$，保证 $d$ 等于 $S$ 中度数最大的点的度数。\n\n接下来 $n-1$ 行每行两个数 $u,v$ 表示 $T$ 中 $u,v$ 有连边。保证形成一棵树。\n\n接下来 $n-1$ 行每行两个数 $u,v$ 表示 $S$ 中 $u,v$ 有连边。保证形成一棵树。", "outputFormat": "为了方便检验，Ysuperman 需要你按照有根树的形式输出答案。\n\n答案第一行一个正整数 $k(1\\le k\\le d)$ 表示你进行的操作数。\n\n接下来 $k$ 行第 $i$ 行 $n$ 个整数表示你进行第 $i$ 次操作后 $T$ 变成的有根树中 $1\\sim n$ 各个点的父亲编号，根的父亲编号规定为 $0$，**请保证你输出树的根是淀粉树的根**。", "hint": "#### 样例 1 解释\n\n这是 $T$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5qlv4q4t.png)\n\n这是 $S$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xoyaon7y.png)\n\n该输出仅对 $T$ 进行了一次操作，即将 $T$ 变成了下面这棵有根树：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0kozi468.png)\n\n这棵有根树是 $T$ 的一棵淀粉树，理由如下：\n\n1. 对于 $2$ 的儿子 $1$，在 $T$ 中 $2$ 与 $s_1=\\{1\\}$ 中的 $1$ 有直接连边。\n2. 对于 $3$ 的儿子 $2$，在 $T$ 中 $3$ 与 $s_2=\\{1,2\\}$ 中的 $1$ 有直接连边。\n3. 对于 $3$ 的儿子 $4$，在 $T$ 中 $3$ 与 $s_4=\\{4\\}$ 中的 $4$ 有直接连边。\n4. 对于 $3$ 的儿子 $5$，在 $T$ 中 $3$ 与 $s_5=\\{5\\}$ 中的 $5$ 有直接连边。\n\n最终得到的有根树和 $S$ 的连边情况相同，所以这份输出将被判定为正确。\n\n#### 数据范围\n\n子任务 $1$（$20$ 分），满足 $n\\le 6$。\n\n子任务 $2$（$20$ 分），满足 $d=2$。\n\n子任务 $3$（$20$ 分），满足 $T$ 可以只进行一次操作即可变成 $S$ 且 $n\\le 447$。\n\n子任务 $4$（$20$ 分），满足 $n\\le 2000$。\n\n子任务 $5$（$20$ 分），无特殊限制。\n\n对于所有数据，满足 $2\\le n\\le 10^5$，$d\\times n\\le 2\\times 10^5$。\n\n#### 提示\n\n附件下发了本题 checker。", "locale": "zh-CN"}}}
{"pid": "P8950", "type": "P", "difficulty": 6, "samples": [["3 4 1\n1 2 1\n2 1 2\n2 3 3\n3 1 4", "5"], ["4 6 2\n1 2 1\n1 3 3\n2 3 2\n3 4 5\n4 1 4\n4 2 6", "6"], ["8 16 3\n5 6 7\n7 2 10\n4 6 4\n5 7 5\n8 4 12\n1 3 8\n2 3 6\n4 1 8\n1 7 2\n8 3 1\n2 5 3\n6 4 11\n7 3 14\n3 8 9\n8 1 13\n6 7 16", "160432162"], ["4 1 3\n2 4 1", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["堆", "洛谷原创", "生成树", "可并堆"], "title": "[YsOI2022] 道路修建", "background": "Ysuperman 正在给他幼儿园里的小朋友们准备一场模板测试，下面是一道模板题，他希望你可以帮他验一下题目。", "description": "某地新建了 $n$ 座城市，拟定建造 $m$ 条**单向**道路，其中第 $i$ 条道路起点为 $u_i$，终点为 $v_i$，建造费用为正整数 $w_i$。\n\n然而在道路开始修建之前突发紧急情况，需要马上选择这些道路中的一些来修建使得所有城市的人都可以走到某 $k$ 座城市中（也就是说，所有城市的人都可以走到这 $k$ 座城市中的**至少一座**城市中），你想要知道，如果这 $k$ 座城市是等概率随机在 $n$ 座城市中的选定的，那么期望的最小修建费用是多少。\n\n为了避免分数输入输出，你只需要输出答案对 $998244353$ 取模的结果。", "inputFormat": "第一行三个非负整数 $n,m,k$ 表示城市数量、拟定建造公路数量以及待选定的城市数量。\n\n接下来 $m$ 行，每行三个正整数 $u_i,v_i,w_i$ 描述一条拟定建造的单向公路。", "outputFormat": "特别的，如果存在一种选定 $k$ 座城市的方式使得无论如何修建道路都总存在某座城市无法到达这 $k$ 座城市中的任意一座，请输出 `-1`。\n\n否则输出一行一个整数表示答案对 $998244353$ 取模的结果。", "hint": "#### 样例 1 解释\n\n总共有三种选定集合城市的方案：\n\n1. 选定集合在城市 $1$，那么选择建造 $2\\to 1,3\\to 1$ 两条道路花费最少，为 $2+4=6$。\n\n2. 选定集合在城市 $2$，那么选择建造 $1\\to 2,3\\to 1$ 两条道路花费最少，为 $1+4=5$。\n\n3. 选定集合在城市 $3$，那么选择建造 $1\\to 2,2\\to 3$ 两条道路花费最少，为 $1+3=4$。\n\n所以期望最小花费为 $(6+5+4)/3=5$。\n\n#### 样例 2 解释\n\n有 $6$ 种选择集合城市的方法：\n\n1. 选城市 $1,2$，最小花费 $9$。\n\n2. 选城市 $1,3$，最小花费 $6$。\n\n3. 选城市 $1,4$，最小花费 $7$。\n\n4. 选城市 $2,3$，最小花费 $5$。\n\n5. 选城市 $2,4$，最小花费 $6$。\n\n6. 选城市 $3,4$，最小花费 $3$。\n\n所以期望最小花费为 $(9+6+7+5+6+3)\\div 6=6$。\n\n#### 样例 3 解释\n\n这里太小写不下，只配个图算了：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cdnuoook.png)\n\n#### 样例 4 解释\n\n当集合城市选在 $1,2,3$ 时，城市 $4$ 无论如何都无法达到 $1,2,3$ 中的任意一个，所以答案为 $-1$。\n\n#### 数据范围\n\n对于 $10\\%$ 的数据，满足 $n\\le 15$，$m\\le 30$。\n\n对于 $30\\%$ 的数据，满足 $n\\le 20$，$m\\le 50$。\n\n另有 $5\\%$ 的数据，满足所有 $w_i$ 相等。\n\n另有 $5\\%$ 的数据，满足 $k=n$。\n\n另有 $5\\%$ 的数据，满足 $k=n-1$。\n\n另有 $10\\%$ 的数据，满足 $m=n$。\n\n另有 $20\\%$ 的数据，满足 $k=1$。\n\n对于 $100\\%$ 的数据，满足 $2\\le n\\le 10^5$，$1\\le m\\le 2\\times 10^5$，$1\\le k\\le n$，$1\\le u_i,v_i\\le n$，$0\\le w_i\\le 998244352$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[YsOI2022] 道路修建", "background": "Ysuperman 正在给他幼儿园里的小朋友们准备一场模板测试，下面是一道模板题，他希望你可以帮他验一下题目。", "description": "某地新建了 $n$ 座城市，拟定建造 $m$ 条**单向**道路，其中第 $i$ 条道路起点为 $u_i$，终点为 $v_i$，建造费用为正整数 $w_i$。\n\n然而在道路开始修建之前突发紧急情况，需要马上选择这些道路中的一些来修建使得所有城市的人都可以走到某 $k$ 座城市中（也就是说，所有城市的人都可以走到这 $k$ 座城市中的**至少一座**城市中），你想要知道，如果这 $k$ 座城市是等概率随机在 $n$ 座城市中的选定的，那么期望的最小修建费用是多少。\n\n为了避免分数输入输出，你只需要输出答案对 $998244353$ 取模的结果。", "inputFormat": "第一行三个非负整数 $n,m,k$ 表示城市数量、拟定建造公路数量以及待选定的城市数量。\n\n接下来 $m$ 行，每行三个正整数 $u_i,v_i,w_i$ 描述一条拟定建造的单向公路。", "outputFormat": "特别的，如果存在一种选定 $k$ 座城市的方式使得无论如何修建道路都总存在某座城市无法到达这 $k$ 座城市中的任意一座，请输出 `-1`。\n\n否则输出一行一个整数表示答案对 $998244353$ 取模的结果。", "hint": "#### 样例 1 解释\n\n总共有三种选定集合城市的方案：\n\n1. 选定集合在城市 $1$，那么选择建造 $2\\to 1,3\\to 1$ 两条道路花费最少，为 $2+4=6$。\n\n2. 选定集合在城市 $2$，那么选择建造 $1\\to 2,3\\to 1$ 两条道路花费最少，为 $1+4=5$。\n\n3. 选定集合在城市 $3$，那么选择建造 $1\\to 2,2\\to 3$ 两条道路花费最少，为 $1+3=4$。\n\n所以期望最小花费为 $(6+5+4)/3=5$。\n\n#### 样例 2 解释\n\n有 $6$ 种选择集合城市的方法：\n\n1. 选城市 $1,2$，最小花费 $9$。\n\n2. 选城市 $1,3$，最小花费 $6$。\n\n3. 选城市 $1,4$，最小花费 $7$。\n\n4. 选城市 $2,3$，最小花费 $5$。\n\n5. 选城市 $2,4$，最小花费 $6$。\n\n6. 选城市 $3,4$，最小花费 $3$。\n\n所以期望最小花费为 $(9+6+7+5+6+3)\\div 6=6$。\n\n#### 样例 3 解释\n\n这里太小写不下，只配个图算了：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cdnuoook.png)\n\n#### 样例 4 解释\n\n当集合城市选在 $1,2,3$ 时，城市 $4$ 无论如何都无法达到 $1,2,3$ 中的任意一个，所以答案为 $-1$。\n\n#### 数据范围\n\n对于 $10\\%$ 的数据，满足 $n\\le 15$，$m\\le 30$。\n\n对于 $30\\%$ 的数据，满足 $n\\le 20$，$m\\le 50$。\n\n另有 $5\\%$ 的数据，满足所有 $w_i$ 相等。\n\n另有 $5\\%$ 的数据，满足 $k=n$。\n\n另有 $5\\%$ 的数据，满足 $k=n-1$。\n\n另有 $10\\%$ 的数据，满足 $m=n$。\n\n另有 $20\\%$ 的数据，满足 $k=1$。\n\n对于 $100\\%$ 的数据，满足 $2\\le n\\le 10^5$，$1\\le m\\le 2\\times 10^5$，$1\\le k\\le n$，$1\\le u_i,v_i\\le n$，$0\\le w_i\\le 998244352$。", "locale": "zh-CN"}}}
{"pid": "P8954", "type": "P", "difficulty": 5, "samples": [["30 6\n1 6\n1 4\n2 9\n1 3\n2 2\n1 16", "1\n4\n2\n2"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "并查集", "深度优先搜索 DFS"], "title": "「VUSC」Math Game", "background": "**upd 2023.1.22**：新增一组 Hack 数据 by @[MCRS_lizi](https://www.luogu.com.cn/user/585805)。\n\n远在哞利坚的 Bessie 也要在新春之际走亲访友！为了打发时间，她常和 Farmer John 玩一个有趣的数字游戏。", "description": "Farmer John 有一个集合 $S$，集合初始为 $\\{2,3,4,...,N\\}$。\n\n对于两个**在集合 $S$ 内的**正整数 $p,q$，我们称它们为「一对好数」当且仅当 $p^k=q(k\\ge 2\\land k\\in\\N)$。\n\n我们将每个 $S$ 中的数看成一张**无向图**中的节点，对于每一对「好数」，我们在这两个数间连一条无向边。\n\nFarmer John 会进行 $Q$ 次操作，操作有以下两种：\n\n1. 给出 $x$，询问结点 $x$ 所在的连通块大小。\n2. 给出 $x$，从 $S$ 中移除 $x$。**与此同时，无向图中的结点 $x$ 也被移除。**\n\n由于 Bessie 的速度太慢了，她想要你来帮忙。", "inputFormat": "第 $1$ 行 $2$ 个正整数，$N,Q$。\n\n接下来 $Q$ 行，每行一个正整数，$op_i,x_i$。\n其中，$op_i$ 表示操作的序号。\n\n**数据保证 $x_i$ 在集合 $S$ 中**。", "outputFormat": "对于操作 $1$，每行输出一个正整数，表示询问的答案。", "hint": "#### 【样例解释】\n\n这是原始无向图（上面一排都是孤点）：\n![](https://cdn.luogu.com.cn/upload/image_hosting/utsz04dt.png)\n\n这是进行第一次操作 $2$ 后的无向图（删除了结点 $9$）：\n![](https://cdn.luogu.com.cn/upload/image_hosting/wmexc9ks.png)\n\n这是进行第二次操作 $2$ 后的无向图（删除了结点 $2$）：\n![](https://cdn.luogu.com.cn/upload/image_hosting/9mi0l18p.png)\n\n---\n\n#### 【数据范围】\n\n全部数据满足：\n- $2\\le N \\le 10^{18}$\n- $1\\le Q \\le 10^6$\n- $x_i\\in S$\n- $op_i \\in \\{1,2\\}$\n\n测试点 $1\\sim2$ 另外满足 $2\\le N \\le 10^5$，$1\\le Q \\le 10^4$。\n\n测试点 $3\\sim4$ 另外满足所有 $x_i=m^{p_i}$，其中 $m$ 为一满足 $m\\ge 2 \\land m\\in \\N$ 的**常数**。\n\n测试点 $5\\sim10$ 没有额外限制。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「VUSC」Math Game", "background": "**upd 2023.1.22**：新增一组 Hack 数据 by @[MCRS_lizi](https://www.luogu.com.cn/user/585805)。\n\n远在哞利坚的 Bessie 也要在新春之际走亲访友！为了打发时间，她常和 Farmer John 玩一个有趣的数字游戏。", "description": "Farmer John 有一个集合 $S$，集合初始为 $\\{2,3,4,...,N\\}$。\n\n对于两个**在集合 $S$ 内的**正整数 $p,q$，我们称它们为「一对好数」当且仅当 $p^k=q(k\\ge 2\\land k\\in\\N)$。\n\n我们将每个 $S$ 中的数看成一张**无向图**中的节点，对于每一对「好数」，我们在这两个数间连一条无向边。\n\nFarmer John 会进行 $Q$ 次操作，操作有以下两种：\n\n1. 给出 $x$，询问结点 $x$ 所在的连通块大小。\n2. 给出 $x$，从 $S$ 中移除 $x$。**与此同时，无向图中的结点 $x$ 也被移除。**\n\n由于 Bessie 的速度太慢了，她想要你来帮忙。", "inputFormat": "第 $1$ 行 $2$ 个正整数，$N,Q$。\n\n接下来 $Q$ 行，每行一个正整数，$op_i,x_i$。\n其中，$op_i$ 表示操作的序号。\n\n**数据保证 $x_i$ 在集合 $S$ 中**。", "outputFormat": "对于操作 $1$，每行输出一个正整数，表示询问的答案。", "hint": "#### 【样例解释】\n\n这是原始无向图（上面一排都是孤点）：\n![](https://cdn.luogu.com.cn/upload/image_hosting/utsz04dt.png)\n\n这是进行第一次操作 $2$ 后的无向图（删除了结点 $9$）：\n![](https://cdn.luogu.com.cn/upload/image_hosting/wmexc9ks.png)\n\n这是进行第二次操作 $2$ 后的无向图（删除了结点 $2$）：\n![](https://cdn.luogu.com.cn/upload/image_hosting/9mi0l18p.png)\n\n---\n\n#### 【数据范围】\n\n全部数据满足：\n- $2\\le N \\le 10^{18}$\n- $1\\le Q \\le 10^6$\n- $x_i\\in S$\n- $op_i \\in \\{1,2\\}$\n\n测试点 $1\\sim2$ 另外满足 $2\\le N \\le 10^5$，$1\\le Q \\le 10^4$。\n\n测试点 $3\\sim4$ 另外满足所有 $x_i=m^{p_i}$，其中 $m$ 为一满足 $m\\ge 2 \\land m\\in \\N$ 的**常数**。\n\n测试点 $5\\sim10$ 没有额外限制。\n", "locale": "zh-CN"}}}
{"pid": "P8955", "type": "P", "difficulty": 5, "samples": [["5 7 10\n1 2 3 4 5\n1 1 1\n1 1 10\n2 5 4\n2 3 8\n5 5 2\n5 5 1\n5 5 16", "2 4 4 -1 7"], ["10 10 86\n26 27 33 1 21 31 9 22 17 14\n6 10 76\n5 8 85\n4 5 89\n3 9 87\n2 9 100\n7 10 83\n1 6 75\n1 4 66\n3 10 68\n3 4 72", "7 5 4 3 3 1 2 1 1 6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400]}, "tags": ["线段树", "二分", "整体二分"], "title": "「VUSC」Card Tricks", "background": "**upd 2023.1.17 数据已加强。** \n\n**upd 2023.10.18 空间限制调整为 100 MiB。**\n\nBessie 正在玩一场卡牌游戏！\n\n这个游戏有一些~~神秘的~~规则。Bessie 需要用一些编程技巧，加快计算。", "description": "牌堆可以看成一个长度为 $N$ 的数列，下标为 $i$ 的位置值为 $a_i$。$(1\\le i\\le N)$\n\n有 $Q$ 次操作，每次操作给定 $l_i,r_i,v_i$，$\\forall l_i\\le j \\le r_i,a_j\\gets a_j \\lor v_i$。\n\n其中 $\\lor$ 表示按位或操作，即 C++ 中的 `|`。\n\n对于 $i=1,2,\\dots,N$，求出在哪一次操作后，$a_i$ **首次严格大于** $P$，其中 $P$ 为一给定常数。\n\n数据保证在初始情况下，$P\\ge\\max\\{a_i\\}$。", "inputFormat": "第一行三个整数 $N,Q,P$。\n\n第二行 $N$ 个整数，第 $i$ 个数为 $a_i$ 的初始值。\n\n接下来 $Q$ 行，每行三个整数，$l_i,r_i,v_i$。", "outputFormat": "输出 $N$ 个数 $id_1,id_2,\\dots,id_N$，第 $i$ 个数表示在第 $id_i$ 次操作后，$a_i$ 首次严格大于 $P$。\n\n**如果 $a_i$ 始终小于等于 $P$，请在这一位输出 $-1$。**", "hint": "#### 样例 #1 解释\n\n第一次操作后的数列为 $1,2,3,4,5$。\n\n第二次操作后的数列为 $11,2,3,4,5$。\n\n第三次操作后的数列为 $11,6,7,4,5$。\n\n……\n\n最终的数列为 $11,14,15,4,23$。\n\n---\n\n#### 数据范围\n全部数据满足：$1\\le N,Q \\le 10^6$，$1\\le l_i\\le r_i \\le N$，$1\\le a_i,v_i,P\\le 10^9$。\n\n测试点 $1\\sim2$ 另满足 $1\\le N,Q\\le 10^3$。\n\n测试点 $3$ 另满足 $l_i=r_i$。\n\n测试点 $4$ 另满足 $l_i=1,r_i=N$。\n\n测试点 $5\\sim10$ 无额外限制。\n\n**本题数据规模较大，请注意常数优化。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「VUSC」Card Tricks", "background": "**upd 2023.1.17 数据已加强。** \n\n**upd 2023.10.18 空间限制调整为 100 MiB。**\n\nBessie 正在玩一场卡牌游戏！\n\n这个游戏有一些~~神秘的~~规则。Bessie 需要用一些编程技巧，加快计算。", "description": "牌堆可以看成一个长度为 $N$ 的数列，下标为 $i$ 的位置值为 $a_i$。$(1\\le i\\le N)$\n\n有 $Q$ 次操作，每次操作给定 $l_i,r_i,v_i$，$\\forall l_i\\le j \\le r_i,a_j\\gets a_j \\lor v_i$。\n\n其中 $\\lor$ 表示按位或操作，即 C++ 中的 `|`。\n\n对于 $i=1,2,\\dots,N$，求出在哪一次操作后，$a_i$ **首次严格大于** $P$，其中 $P$ 为一给定常数。\n\n数据保证在初始情况下，$P\\ge\\max\\{a_i\\}$。", "inputFormat": "第一行三个整数 $N,Q,P$。\n\n第二行 $N$ 个整数，第 $i$ 个数为 $a_i$ 的初始值。\n\n接下来 $Q$ 行，每行三个整数，$l_i,r_i,v_i$。", "outputFormat": "输出 $N$ 个数 $id_1,id_2,\\dots,id_N$，第 $i$ 个数表示在第 $id_i$ 次操作后，$a_i$ 首次严格大于 $P$。\n\n**如果 $a_i$ 始终小于等于 $P$，请在这一位输出 $-1$。**", "hint": "#### 样例 #1 解释\n\n第一次操作后的数列为 $1,2,3,4,5$。\n\n第二次操作后的数列为 $11,2,3,4,5$。\n\n第三次操作后的数列为 $11,6,7,4,5$。\n\n……\n\n最终的数列为 $11,14,15,4,23$。\n\n---\n\n#### 数据范围\n全部数据满足：$1\\le N,Q \\le 10^6$，$1\\le l_i\\le r_i \\le N$，$1\\le a_i,v_i,P\\le 10^9$。\n\n测试点 $1\\sim2$ 另满足 $1\\le N,Q\\le 10^3$。\n\n测试点 $3$ 另满足 $l_i=r_i$。\n\n测试点 $4$ 另满足 $l_i=1,r_i=N$。\n\n测试点 $5\\sim10$ 无额外限制。\n\n**本题数据规模较大，请注意常数优化。**", "locale": "zh-CN"}}}
{"pid": "P8956", "type": "P", "difficulty": 3, "samples": [["4\n5 2 10 1 8\n11 4 5 1 4\n19 1 9 8 10\n114 51 4 1919 810", "998244317\n998242817\n939523984\n604148977"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["洛谷原创"], "title": "「CGOI-3」招魂术", "background": "墓园的骷髅海！\n\n要塞的禁魔球！\n\n塔楼的三后排！\n\n据点的破甲比蒙！\n\n地下城的满魔抗黑龙！\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j0kff14j.png)\n\n###### 塔楼↑\n\n-----\n燊队来打英雄无敌 3 了。", "description": "招魂术是墓园阵营的核心法术。\n\n拥有招魂术的英雄，在每场战争结束后，能根据消灭的敌军数目来获得一定数量的骷髅。我们可以用整数 $A,B$ 来描述招魂术。设 $F_{A,B}(i)$ 表示消灭 $i$ 个敌人所能获得的骷髅数量，有：\n\n$$F_{A,B}(1)=A,F_{A,B}(2)=B,F_{A,B}(x)=\\lfloor \\sqrt{F_{A,B}(x-2)F_{A,B}(x-1)}\\rfloor+1\\;(x \\ge 3)$$\n\n现在燊队要在酒馆招募一个英雄，英雄甲招魂术的属性为 $A,B$，英雄乙招魂术的属性为 $X,Y$。为了比较两个英雄招魂术的强弱，请你计算以下式子的值：\n\n$$\\prod_{i=1}^nF_{X,Y}(i)-F_{A,B}(i)$$\n\n燊队当然知道怎么做，但他想考考你。", "inputFormat": "第一行一个整数 $T$，表示询问组数。\n\n接下来 $T$ 行，每行五个整数 $n,A,B,X,Y$。", "outputFormat": "输出为 $T$ 行，即每组询问答案对 $998244353$ 取模的结果。\n\n建议使用 `sqrtl` 和 `long double` 进行开平方。", "hint": "#### 样例说明\n\n在样例说明中，设 $F_{A,B}$ 为 $f$，$F_{X,Y}$ 为 $g$。\n\n对于第一组询问：\n\n- $f$ 的前 $n$ 位为 $f=\\{2,10,5,8,7\\}$。\n\n- $g$ 的前 $n$ 位为 $g=\\{1,8,3,5,4\\}$。\n\n所以最终的答案为 $(1-2)\\times(8-10)\\times(3-5)\\times(5-8)\\times(4-7)=-36$，对 $998244353$ 取模后的结果是 $998244317$。\n\n---\n\n#### 数据范围\n\n对于 $40\\%$ 的数据，$n \\le 100$。\n\n对于另外 $10\\%$ 的数据，每组询问满足 $A=B,X=Y$。\n\n对于另外 $10\\%$ 的数据，$T=1$。\n\n对于 $100\\%$ 的数据，$1 \\le A,B,X,Y,n \\le 10^9$，$1 \\le T \\le 5\\times 10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「CGOI-3」招魂术", "background": "墓园的骷髅海！\n\n要塞的禁魔球！\n\n塔楼的三后排！\n\n据点的破甲比蒙！\n\n地下城的满魔抗黑龙！\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j0kff14j.png)\n\n###### 塔楼↑\n\n-----\n燊队来打英雄无敌 3 了。", "description": "招魂术是墓园阵营的核心法术。\n\n拥有招魂术的英雄，在每场战争结束后，能根据消灭的敌军数目来获得一定数量的骷髅。我们可以用整数 $A,B$ 来描述招魂术。设 $F_{A,B}(i)$ 表示消灭 $i$ 个敌人所能获得的骷髅数量，有：\n\n$$F_{A,B}(1)=A,F_{A,B}(2)=B,F_{A,B}(x)=\\lfloor \\sqrt{F_{A,B}(x-2)F_{A,B}(x-1)}\\rfloor+1\\;(x \\ge 3)$$\n\n现在燊队要在酒馆招募一个英雄，英雄甲招魂术的属性为 $A,B$，英雄乙招魂术的属性为 $X,Y$。为了比较两个英雄招魂术的强弱，请你计算以下式子的值：\n\n$$\\prod_{i=1}^nF_{X,Y}(i)-F_{A,B}(i)$$\n\n燊队当然知道怎么做，但他想考考你。", "inputFormat": "第一行一个整数 $T$，表示询问组数。\n\n接下来 $T$ 行，每行五个整数 $n,A,B,X,Y$。", "outputFormat": "输出为 $T$ 行，即每组询问答案对 $998244353$ 取模的结果。\n\n建议使用 `sqrtl` 和 `long double` 进行开平方。", "hint": "#### 样例说明\n\n在样例说明中，设 $F_{A,B}$ 为 $f$，$F_{X,Y}$ 为 $g$。\n\n对于第一组询问：\n\n- $f$ 的前 $n$ 位为 $f=\\{2,10,5,8,7\\}$。\n\n- $g$ 的前 $n$ 位为 $g=\\{1,8,3,5,4\\}$。\n\n所以最终的答案为 $(1-2)\\times(8-10)\\times(3-5)\\times(5-8)\\times(4-7)=-36$，对 $998244353$ 取模后的结果是 $998244317$。\n\n---\n\n#### 数据范围\n\n对于 $40\\%$ 的数据，$n \\le 100$。\n\n对于另外 $10\\%$ 的数据，每组询问满足 $A=B,X=Y$。\n\n对于另外 $10\\%$ 的数据，$T=1$。\n\n对于 $100\\%$ 的数据，$1 \\le A,B,X,Y,n \\le 10^9$，$1 \\le T \\le 5\\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P8957", "type": "P", "difficulty": 4, "samples": [["3\n1 2 1\n3 2 3", "9\n1 2\n1 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "Special Judge", "O2优化", "构造", "Ad-hoc"], "title": "「CGOI-3」巫泡弹弹乐", "background": "mc 正在挑战弹弹乐。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yaye0cgu.png)", "description": "弹弹乐由 $n$ 个弹力菇组成，每个弹力菇有 $a,b$ 两个属性。\n\n对于弹力菇 $i$ 会向弹力菇 $j$ 连一条边权为 $\\max(a_i,a_j)+\\max(b_i,b_j)$ 的双向弹力通道。现在 mc 想知道弹力菇组成的图的最小生成树，以便他打破记录。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数，第 $i$ 个数表示 $a_i$。\n\n第三行 $n$ 个整数，第 $i$ 个数表示 $b_i$。", "outputFormat": "第一行输出这个最小生成树的边权和。\n\n接下来 $n-1$ 行，每行输出两个整数表示一条树边。你可以输出任意一种合法方案。", "hint": "#### 数据范围\n\n**「本题采用捆绑测试」**\n\n$$\\def\\arraystretch{1.5}\\begin{array}{|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\bm{n} & \\textbf{特殊性质} & \\textbf{分值}\\cr\\hline\n1 & n\\le 500 & \\text{无} & 20 \\cr\\hline\n2 & n\\le 5\\times 10^4 & \\text{无} & 20\\cr\\hline\n3 & \\text{无特殊限制} & \\text{数据随机} & 20\\cr\\hline\n4 & \\text{无特殊限制} & \\text{无} & 40 \\cr\\hline\n\\end{array}$$\n\n- 对于 $100\\%$ 的数据，满足：$1\\le n\\le 10^6$，$1\\le a_i,b_i\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「CGOI-3」巫泡弹弹乐", "background": "mc 正在挑战弹弹乐。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yaye0cgu.png)", "description": "弹弹乐由 $n$ 个弹力菇组成，每个弹力菇有 $a,b$ 两个属性。\n\n对于弹力菇 $i$ 会向弹力菇 $j$ 连一条边权为 $\\max(a_i,a_j)+\\max(b_i,b_j)$ 的双向弹力通道。现在 mc 想知道弹力菇组成的图的最小生成树，以便他打破记录。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数，第 $i$ 个数表示 $a_i$。\n\n第三行 $n$ 个整数，第 $i$ 个数表示 $b_i$。", "outputFormat": "第一行输出这个最小生成树的边权和。\n\n接下来 $n-1$ 行，每行输出两个整数表示一条树边。你可以输出任意一种合法方案。", "hint": "#### 数据范围\n\n**「本题采用捆绑测试」**\n\n$$\\def\\arraystretch{1.5}\\begin{array}{|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\bm{n} & \\textbf{特殊性质} & \\textbf{分值}\\cr\\hline\n1 & n\\le 500 & \\text{无} & 20 \\cr\\hline\n2 & n\\le 5\\times 10^4 & \\text{无} & 20\\cr\\hline\n3 & \\text{无特殊限制} & \\text{数据随机} & 20\\cr\\hline\n4 & \\text{无特殊限制} & \\text{无} & 40 \\cr\\hline\n\\end{array}$$\n\n- 对于 $100\\%$ 的数据，满足：$1\\le n\\le 10^6$，$1\\le a_i,b_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P8958", "type": "P", "difficulty": 6, "samples": [["2\n114 514 1919 810", "2691692"], ["3\n1 1 4 5 1 4", "98"], ["8\n275272885 418731188 289662326 114331587 192436268 885936831 877490593 508774565 633402863 149033362 995239139 494498006 168828873 138947653 983144753 844326228", "349824160"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["洛谷原创", "O2优化", "Catalan 数", "快速傅里叶变换 FFT", "快速数论变换 NTT"], "title": "「CGOI-3」残暴圣所", "background": "终于打过春二心门的 ac 来到了春三，并决定预测一下残暴圣所（Ferocious Sanctuary）的难度。\n\n[![](https://cdn.luogu.com.cn/upload/image_hosting/xolrra48.png?x-oss-process=image/resize,m_lfit,h_340,w_450)](//www.bilibili.com/video/BV1Cg411v7Ji)", "description": "为了通关残暴圣所，ac 需要在接下来的 $2n$ 个时刻进行 $n$ 次操作。第 $i$ 次操作需要在时刻 $l_i$ 按下某个按键，此后一直按住这个按键，直到时刻 $r_i$ 松开它（$l_i<r_i$）。在每个时刻，ac 要么按下一个按键，要么松开一个按键，但是可以同时按住多个按键。\n\n第 $i$ 次操作形成了一个操作区间 $[l_i,r_i]$，满足 $l_i$ 严格递增。并且，由于残暴圣所的关卡设计，任意两个操作形成的操作区间之间，要么不交，要么包含。\n\nac 设计了 $2n$ 个难度系数 $a_1,a_2,\\dots,a_{2n}$。第 $i$ 次操作的难度可以用 $a_{l_i}\\times a_{r_i}$ 来评估，而通关残暴圣所的难度即为所有操作的难度之和。\n\n然而，由于 ac 卡在了残暴圣所的第一面，所以他并不知道每个操作的操作区间。在给定 $n$ 和 $\\{a\\}$ 的前提下，请你计算对于所有可能的情况，通关残暴圣所的难度之和，对 $998244353$ 取模。\n\n#### 形式化题意：\n\n给定一个长为 $2n$ 的数列 $a_1,a_2,\\dots,a_{2n}$。\n\n定义“区间组”由 $n$ 个区间组成，第 $i$ 个区间为 $[l_i,r_i]\\ (1\\le l_i<r_i\\le2n)$，求所有满足下列条件的区间组的 $\\sum_{i=1}^na_{l_i}\\times a_{r_i}$ 之和对 $998244353$ 取模：\n\n1. $l_1,r_1,l_2,r_2,\\dots,l_n,r_n$ 是 $1,2,\\dots,2n$ 的一个排列。\n2. $\\forall 1\\le i<n$，$l_i<l_{i+1}$。\n3. $\\forall i,j$，$[l_i,r_i]\\cap[l_j,r_j]=\\varnothing$ 或 $[l_i,r_i]\\sube[l_j,r_j]$ 或 $[l_j,r_j]\\sube[l_i,r_i]$。\n", "inputFormat": "第一行一个整数 $n$，表示区间数。\n\n第二行 $2n$ 个整数 $a_i$，含义如上所述。", "outputFormat": "一行一个整数，表示答案对 $998244353$ 取模的值。", "hint": "#### 样例说明\n\n对于样例 1，可能的两个操作区间只有两种情况：\n\n1. $[1,2],[3,4]$，通关难度为 $a_1a_2+a_3a_4=1612986$。\n2. $[1,4],[2,3]$，通关难度为 $a_1a_4+a_2a_3=1078706$。\n\n难度之和为 $1612986+1078706=2691692$，对 $998244353$ 取模后仍为 $2691692$。\n\n以下几种情况是不合法的：\n\n1. $[3,4],[1,2]$，因为要求 $l_i$ 严格递增，而 $l_1\\ge l_2$。\n2. $[1,1],[2,4]$，因为要求 $l_i<r_i$，而 $l_1\\ge r_1$。\n3. $[1,3],[2,3]$，因为要求在每个时刻，要么按下一个按键，要么松开一个按键，而第三个时刻松开了两个按键，第四个时刻没有按下或松开任何一个按键。\n4. $[1,3],[2,4]$，因为要求任意两个操作区间不交或包含，而这两个区间之间有交，并且没有包含关系。\n\n---\n\n#### 数据范围\n\n对于 $10\\%$ 的数据，$n\\le15$。\n\n对于 $30\\%$ 的数据，$n\\le200$。\n\n对于 $50\\%$ 的数据，$n\\le3000$。\n\n对于另 $5\\%$ 的数据，$a_i=1$。\n\n对于 $100\\%$ 的数据，$1\\le n\\le5\\times10^5$，$0\\le a_i<998244353$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「CGOI-3」残暴圣所", "background": "终于打过春二心门的 ac 来到了春三，并决定预测一下残暴圣所（Ferocious Sanctuary）的难度。\n\n[![](https://cdn.luogu.com.cn/upload/image_hosting/xolrra48.png?x-oss-process=image/resize,m_lfit,h_340,w_450)](//www.bilibili.com/video/BV1Cg411v7Ji)", "description": "为了通关残暴圣所，ac 需要在接下来的 $2n$ 个时刻进行 $n$ 次操作。第 $i$ 次操作需要在时刻 $l_i$ 按下某个按键，此后一直按住这个按键，直到时刻 $r_i$ 松开它（$l_i<r_i$）。在每个时刻，ac 要么按下一个按键，要么松开一个按键，但是可以同时按住多个按键。\n\n第 $i$ 次操作形成了一个操作区间 $[l_i,r_i]$，满足 $l_i$ 严格递增。并且，由于残暴圣所的关卡设计，任意两个操作形成的操作区间之间，要么不交，要么包含。\n\nac 设计了 $2n$ 个难度系数 $a_1,a_2,\\dots,a_{2n}$。第 $i$ 次操作的难度可以用 $a_{l_i}\\times a_{r_i}$ 来评估，而通关残暴圣所的难度即为所有操作的难度之和。\n\n然而，由于 ac 卡在了残暴圣所的第一面，所以他并不知道每个操作的操作区间。在给定 $n$ 和 $\\{a\\}$ 的前提下，请你计算对于所有可能的情况，通关残暴圣所的难度之和，对 $998244353$ 取模。\n\n#### 形式化题意：\n\n给定一个长为 $2n$ 的数列 $a_1,a_2,\\dots,a_{2n}$。\n\n定义“区间组”由 $n$ 个区间组成，第 $i$ 个区间为 $[l_i,r_i]\\ (1\\le l_i<r_i\\le2n)$，求所有满足下列条件的区间组的 $\\sum_{i=1}^na_{l_i}\\times a_{r_i}$ 之和对 $998244353$ 取模：\n\n1. $l_1,r_1,l_2,r_2,\\dots,l_n,r_n$ 是 $1,2,\\dots,2n$ 的一个排列。\n2. $\\forall 1\\le i<n$，$l_i<l_{i+1}$。\n3. $\\forall i,j$，$[l_i,r_i]\\cap[l_j,r_j]=\\varnothing$ 或 $[l_i,r_i]\\sube[l_j,r_j]$ 或 $[l_j,r_j]\\sube[l_i,r_i]$。\n", "inputFormat": "第一行一个整数 $n$，表示区间数。\n\n第二行 $2n$ 个整数 $a_i$，含义如上所述。", "outputFormat": "一行一个整数，表示答案对 $998244353$ 取模的值。", "hint": "#### 样例说明\n\n对于样例 1，可能的两个操作区间只有两种情况：\n\n1. $[1,2],[3,4]$，通关难度为 $a_1a_2+a_3a_4=1612986$。\n2. $[1,4],[2,3]$，通关难度为 $a_1a_4+a_2a_3=1078706$。\n\n难度之和为 $1612986+1078706=2691692$，对 $998244353$ 取模后仍为 $2691692$。\n\n以下几种情况是不合法的：\n\n1. $[3,4],[1,2]$，因为要求 $l_i$ 严格递增，而 $l_1\\ge l_2$。\n2. $[1,1],[2,4]$，因为要求 $l_i<r_i$，而 $l_1\\ge r_1$。\n3. $[1,3],[2,3]$，因为要求在每个时刻，要么按下一个按键，要么松开一个按键，而第三个时刻松开了两个按键，第四个时刻没有按下或松开任何一个按键。\n4. $[1,3],[2,4]$，因为要求任意两个操作区间不交或包含，而这两个区间之间有交，并且没有包含关系。\n\n---\n\n#### 数据范围\n\n对于 $10\\%$ 的数据，$n\\le15$。\n\n对于 $30\\%$ 的数据，$n\\le200$。\n\n对于 $50\\%$ 的数据，$n\\le3000$。\n\n对于另 $5\\%$ 的数据，$a_i=1$。\n\n对于 $100\\%$ 的数据，$1\\le n\\le5\\times10^5$，$0\\le a_i<998244353$。", "locale": "zh-CN"}}}
{"pid": "P8959", "type": "P", "difficulty": 7, "samples": [["5 7\n1 2 3 4 5\n1 2\n3 1\n4 3\n3 5\n1 4\n3 1\n2 4\n1 3\n1 5\n3 1\n3 5", "4\n4\n8"], ["8 7\n4 1 3 5 8 6 2 9\n1 2\n3 1\n4 2\n5 1\n5 6\n7 5\n6 8\n1 1\n1 5\n3 7\n3 1\n1 2\n2 5\n3 5\n", "0\n12\n8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "树链剖分", "线段树合并"], "title": "「CGOI-3」灵气", "background": ">「地牢中回荡着尖叫声...」\n\n打完世花的 ac 进入地牢刷灵气……\n\n花后地牢十分险恶，ac 想在地牢里搭满单向门。\n\n[![](https://cdn.luogu.com.cn/upload/image_hosting/a1ewte9n.png)](https://www.bilibili.com/video/BV1jf4y1Z7RB)", "description": "ac 世界里的地牢有 $n$ 个小房间，恰好存在 $n-1$ 条过道，并且每个小房间连通。第 $i$ 个小房间生成的怪在一个时刻**最多只会存在一个**，且**伤害为 $a_i$**。\n\n为了方便刷灵气，ac 在每个过道上建了一个单向门。\n\n每一秒会发生以下几个事件之一：\n\n1. 第 $x$ 个房间生成了一个怪。怪**不会穿墙**，只会顺着单向门方向移动。\n\n2. 第 $x$ 个房间生成的怪被 ac 的仆从干掉了。\n\n3. ac 想要挂机刷怪，于是他希望知道，如果从时刻 1 开始站在房间 $x$ 一直到当前时刻，受到伤害最多的一个时刻所受伤害是多少。\n\n这里定义一个时刻受到伤害为可以走到 ac 所在房间的怪的伤害值总和，“可以走到”定义为可以穿过若干条单向门到达 ac 的房间（若干可以为 $0$）。ac 非常强大，不会中途被怪打死。\n\n当然，ac 所在的位置**不会改变怪的刷新**和**仆从的行为**。\n\n#### 简化版题面\n\n一棵树，每个点有个点权，每条边有个方向。\n\n有个集合，一开始为空，三个操作：\n\n1. 在集合中加入一个点。\n2. 删除集合中的一个点。\n3. 给出一个点 $x$，询问集合中满足可以走到 $x$ 的点的点权之和的历史最大值。", "inputFormat": "第一行，两个整数 $n,m$，分别表示房间个数和事件个数。\n\n接下来一行，共 $n$ 个整数，第 $i$ 个数表示 $i$ 房间中怪的伤害 $a_i$。\n\n接下来 $n-1$ 行，每行两个整数 $x,y$，表示 $x$ 与 $y$ 有一条过道，单向门方向为 $x\\rightarrow y$ 。\n\n接下来 $m$ 行，第 $i$ 行两个整数 $fl,x$，表示第 $x$ 号房间发生了 $fl$ 号事件。\n\n对于 $fl=1$ 的操作，保证 $x$ 号房间没有怪。\n\n对于 $fl=2$ 的操作，保证 $x$ 号房间有怪。", "outputFormat": "对每一个 $fl=3$ 的事件，输出一个整数表示答案，并用换行隔开。", "hint": "#### 样例一说明\n第一个询问中，时刻 $1$ 存在怪的房间为 $\\{4\\}$，$4$ 号房间的怪可以走到 $1$ 号房间，因此答案为 $a_4=4$。\n\n第二个询问中，受到伤害最大的时刻为时刻 $1$，答案为 $a_4=4$。其中时刻 $5$ 存在怪的房间为 $\\{3,5\\}$，而 $5$ 号房间的怪走不到 $1$ 号房间，因此此时刻受到伤害为 $a_3=3<4$，不是最大值。\n\n第三个询问中，受到伤害最大的时刻为时刻 $5$，$3,5$ 号房间的怪均可走到 $5$，因此答案为 $a_3+a_5=8$。\n\n---\n\n#### 数据范围\n**「本题采用捆绑测试」**\n\n对于 $10\\%$ 的数据，$n,m \\leq 2000$。\n\n对于另 $10\\%$ 的数据，过道 $(x,y)$ 单向门满足 $x<y$。\n\n对于另 $30\\%$ 的数据，不存在 2 事件。\n\n对于 $100\\%$ 的数据，$1\\leq n,m \\leq 2\\times 10^5$，$1\\leq a_i\\leq10^4$。\n\n~~但是地牢幽魂就是穿墙怪（）（）（）~~\n\n~~不会真的有人会在地牢里搭满单向门吧。~~\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「CGOI-3」灵气", "background": ">「地牢中回荡着尖叫声...」\n\n打完世花的 ac 进入地牢刷灵气……\n\n花后地牢十分险恶，ac 想在地牢里搭满单向门。\n\n[![](https://cdn.luogu.com.cn/upload/image_hosting/a1ewte9n.png)](https://www.bilibili.com/video/BV1jf4y1Z7RB)", "description": "ac 世界里的地牢有 $n$ 个小房间，恰好存在 $n-1$ 条过道，并且每个小房间连通。第 $i$ 个小房间生成的怪在一个时刻**最多只会存在一个**，且**伤害为 $a_i$**。\n\n为了方便刷灵气，ac 在每个过道上建了一个单向门。\n\n每一秒会发生以下几个事件之一：\n\n1. 第 $x$ 个房间生成了一个怪。怪**不会穿墙**，只会顺着单向门方向移动。\n\n2. 第 $x$ 个房间生成的怪被 ac 的仆从干掉了。\n\n3. ac 想要挂机刷怪，于是他希望知道，如果从时刻 1 开始站在房间 $x$ 一直到当前时刻，受到伤害最多的一个时刻所受伤害是多少。\n\n这里定义一个时刻受到伤害为可以走到 ac 所在房间的怪的伤害值总和，“可以走到”定义为可以穿过若干条单向门到达 ac 的房间（若干可以为 $0$）。ac 非常强大，不会中途被怪打死。\n\n当然，ac 所在的位置**不会改变怪的刷新**和**仆从的行为**。\n\n#### 简化版题面\n\n一棵树，每个点有个点权，每条边有个方向。\n\n有个集合，一开始为空，三个操作：\n\n1. 在集合中加入一个点。\n2. 删除集合中的一个点。\n3. 给出一个点 $x$，询问集合中满足可以走到 $x$ 的点的点权之和的历史最大值。", "inputFormat": "第一行，两个整数 $n,m$，分别表示房间个数和事件个数。\n\n接下来一行，共 $n$ 个整数，第 $i$ 个数表示 $i$ 房间中怪的伤害 $a_i$。\n\n接下来 $n-1$ 行，每行两个整数 $x,y$，表示 $x$ 与 $y$ 有一条过道，单向门方向为 $x\\rightarrow y$ 。\n\n接下来 $m$ 行，第 $i$ 行两个整数 $fl,x$，表示第 $x$ 号房间发生了 $fl$ 号事件。\n\n对于 $fl=1$ 的操作，保证 $x$ 号房间没有怪。\n\n对于 $fl=2$ 的操作，保证 $x$ 号房间有怪。", "outputFormat": "对每一个 $fl=3$ 的事件，输出一个整数表示答案，并用换行隔开。", "hint": "#### 样例一说明\n第一个询问中，时刻 $1$ 存在怪的房间为 $\\{4\\}$，$4$ 号房间的怪可以走到 $1$ 号房间，因此答案为 $a_4=4$。\n\n第二个询问中，受到伤害最大的时刻为时刻 $1$，答案为 $a_4=4$。其中时刻 $5$ 存在怪的房间为 $\\{3,5\\}$，而 $5$ 号房间的怪走不到 $1$ 号房间，因此此时刻受到伤害为 $a_3=3<4$，不是最大值。\n\n第三个询问中，受到伤害最大的时刻为时刻 $5$，$3,5$ 号房间的怪均可走到 $5$，因此答案为 $a_3+a_5=8$。\n\n---\n\n#### 数据范围\n**「本题采用捆绑测试」**\n\n对于 $10\\%$ 的数据，$n,m \\leq 2000$。\n\n对于另 $10\\%$ 的数据，过道 $(x,y)$ 单向门满足 $x<y$。\n\n对于另 $30\\%$ 的数据，不存在 2 事件。\n\n对于 $100\\%$ 的数据，$1\\leq n,m \\leq 2\\times 10^5$，$1\\leq a_i\\leq10^4$。\n\n~~但是地牢幽魂就是穿墙怪（）（）（）~~\n\n~~不会真的有人会在地牢里搭满单向门吧。~~\n", "locale": "zh-CN"}}}
{"pid": "P8960", "type": "P", "difficulty": 3, "samples": [["7\n3 1\n010\n3 2\n010\n3 3\n010\n3 4\n010\n3 5\n010\n3 6\n010\n3 7\n010", "Down\nUp\nUp\nDown\nDown\nDown\nUp"], ["7\n3 1\n011\n3 2\n011\n3 3\n011\n3 4\n011\n3 5\n011\n3 6\n011\n3 7\n011", "Down\nUp\nUp\nDown\nDown\nDown\nUp\n"], ["2\n13 114\n1101101111010\n13 514\n1101101111010", "Up\nUp"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "O2优化", "进制"], "title": "「WHOI-4」折纸", "background": "吉尼斯记录：一张纸（如果接近 $4$ 公里的卫生纸可以算作一张纸）最多可以对折 $13$ 次。小 X 吹牛说打破了这个记录，但是吹太大了。", "description": "小 X 向吉尼斯世界纪录组织申请了这个记录，但是他正好隔离在家，无法证明。他只好允许他们问 $t$ 个问题，确认他确实打破了记录。\n\n他们每个问题可以要求小 X 把一张纸按照一个给定 $01$ 串 $s$ 的规则对折 $n$ 次后展开。对于第 $i$ 次折叠，如果 $s_i=0$，将纸从左到右对折，使左边对齐右边；如果 $s_i=1$，将纸从右到左对折，使右边对齐左边。对折全部是从上方翻。**接下来将会展开，展开后纸片在原位，只是保留了折痕。看看自己是否实现了这一点。**\n\n他们想要知道，从左往右数第 $k$ 个折痕是峰折（向上突起的折痕）还是谷折（向下凹陷的折痕）。如果该询问的答案是峰折，输出 `Up`；否则输出 `Down`。请你帮帮可怜的小 X。\n\n峰折，谷折的图示见样例解释。", "inputFormat": "**本题采用多测。**\n\n第一行一行一个正整数 $t$，代表数据组数。\n\n接下来 $2t$ 行，每两行是一组数据。每组数据，第一行两个正整数 $n,k$。接下来一行一个长度为 $n$ 的 $01$ 串，代表 $s$。", "outputFormat": "$t$ 行，每行一个字符串，代表该组数据的答案。\n", "hint": "**样例解释**\n\n样例 #1 解释：\n\n动态地址：[here](http://img-blog.csdnimg.cn/c68f2ba917504417b109eb1606f4a3a5.gif)。不知道为什么洛谷显示不了了。\n\n由于技术原因，动图帧数略低。\n\n样例 #2 请手动模拟。\n\n**数据范围**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（$20$ pts）：$t=10$，$1\\le n\\le5$；\n- Subtask 2（$80$ pts）：$t=10^5$。\n\n对于 $100\\%$ 的数据，有 $1\\le t\\le 10^5$，$1\\le n\\le60$，$1\\le k<2^n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「WHOI-4」折纸", "background": "吉尼斯记录：一张纸（如果接近 $4$ 公里的卫生纸可以算作一张纸）最多可以对折 $13$ 次。小 X 吹牛说打破了这个记录，但是吹太大了。", "description": "小 X 向吉尼斯世界纪录组织申请了这个记录，但是他正好隔离在家，无法证明。他只好允许他们问 $t$ 个问题，确认他确实打破了记录。\n\n他们每个问题可以要求小 X 把一张纸按照一个给定 $01$ 串 $s$ 的规则对折 $n$ 次后展开。对于第 $i$ 次折叠，如果 $s_i=0$，将纸从左到右对折，使左边对齐右边；如果 $s_i=1$，将纸从右到左对折，使右边对齐左边。对折全部是从上方翻。**接下来将会展开，展开后纸片在原位，只是保留了折痕。看看自己是否实现了这一点。**\n\n他们想要知道，从左往右数第 $k$ 个折痕是峰折（向上突起的折痕）还是谷折（向下凹陷的折痕）。如果该询问的答案是峰折，输出 `Up`；否则输出 `Down`。请你帮帮可怜的小 X。\n\n峰折，谷折的图示见样例解释。", "inputFormat": "**本题采用多测。**\n\n第一行一行一个正整数 $t$，代表数据组数。\n\n接下来 $2t$ 行，每两行是一组数据。每组数据，第一行两个正整数 $n,k$。接下来一行一个长度为 $n$ 的 $01$ 串，代表 $s$。", "outputFormat": "$t$ 行，每行一个字符串，代表该组数据的答案。\n", "hint": "**样例解释**\n\n样例 #1 解释：\n\n动态地址：[here](http://img-blog.csdnimg.cn/c68f2ba917504417b109eb1606f4a3a5.gif)。不知道为什么洛谷显示不了了。\n\n由于技术原因，动图帧数略低。\n\n样例 #2 请手动模拟。\n\n**数据范围**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（$20$ pts）：$t=10$，$1\\le n\\le5$；\n- Subtask 2（$80$ pts）：$t=10^5$。\n\n对于 $100\\%$ 的数据，有 $1\\le t\\le 10^5$，$1\\le n\\le60$，$1\\le k<2^n$。", "locale": "zh-CN"}}}
{"pid": "P8961", "type": "P", "difficulty": 5, "samples": [["1 10\n4", "6\n-6"], ["1 10\n7", "7\n7"], ["2 9\n3 3", "6\n12 -6"], ["10 7\n1 2 3 4 5 6 0 1 2 3", "6\n36 30 24 18 12 6 42 -6 30 24"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数论", "Special Judge", "O2优化", "素数判断,质数,筛法", "中国剩余定理 CRT"], "title": "「WHOI-4」ggcd", "background": "如何输入输出 `__int128`：\n\n```cpp\n__int128 read() {\n  char c = getchar();\n  __int128 x = 0;\n  bool f = 0;\n  for (; !isdigit(c); c = getchar()) f ^= !(c ^ 45);\n  for (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);\n  if (f) x = -x;\n  return x;\n}\nvoid write(__int128 x, char c = '\\0') {\n  if (x < 0) putchar('-'), x = -x;\n  if (x > 9) write(x / 10);\n  putchar(x % 10 + '0');\n  if (c != '\\0') putchar(c);\n}\n```", "description": "**本题已新增一组样例，请注意查看。**\n\n小 Y 给了你长度为 $n$ 的数组 $y$ 以及一个正整数 $m$，保证 $0\\le y_i<m$，请你构造一个同样长为 $n$ 的数组 $x$，使得：\n\n1. $x_i$ 在 `__int128` 范围内；\n2. $x_i\\bmod m=y_i$；\n3. $\\gcd(|x_1|,\\cdots,|x_n|)\\bmod m$ 最大。\n\n注意，$x_i$ **可以为负**，此时 $m\\mid (x_i-y_i)$ 且 $0\\le y_i<m$。 ", "inputFormat": "第一行两个正整数 $n,m$。\n\n接下来一行 $n$ 个非负整数，代表 $x_i \\bmod m$ 的值。", "outputFormat": "第一行一个非负整数 $g$，代表 $\\gcd(|x_1|,|x_2|,\\cdots,|x_n|)\\mod m$ 的可能最大值。\n\n接下来一行 $n$ 个整数，代表 $x_i$。", "hint": "**数据范围**\n\n**本题采用捆绑测试。**\n\nSubtask 1（$30$ pts）：$m$ 是素数。\n\nSubtask 2（$70$ pts）：无特殊限制。\n\n对于所有数据，保证 $2\\le m \\le10^9$，$1\\le n\\le10^6$。\n\n**关于 Special Judge**\n\n对于每个测试点：\n\n如果你输出的格式不正确，你将会获得 $0$ 分。\n\n如果你输出的数中有不在 `__int128` 范围的数，可能导致溢出所以你可能无法获得预期的分数。\n\n如果你的数列 $x$ 不符合题目给定的 $y$，你将会获得 $0$ 分。\n\n如果你的数列 $x$ 不符合你输出的 $g$，你将会获得 $0$ 分。\n\n如果你的 $g$ 不为最大，你将会获得 $0$ 分。\n\n否则你将获得该测试点的所有分数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「WHOI-4」ggcd", "background": "如何输入输出 `__int128`：\n\n```cpp\n__int128 read() {\n  char c = getchar();\n  __int128 x = 0;\n  bool f = 0;\n  for (; !isdigit(c); c = getchar()) f ^= !(c ^ 45);\n  for (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);\n  if (f) x = -x;\n  return x;\n}\nvoid write(__int128 x, char c = '\\0') {\n  if (x < 0) putchar('-'), x = -x;\n  if (x > 9) write(x / 10);\n  putchar(x % 10 + '0');\n  if (c != '\\0') putchar(c);\n}\n```", "description": "**本题已新增一组样例，请注意查看。**\n\n小 Y 给了你长度为 $n$ 的数组 $y$ 以及一个正整数 $m$，保证 $0\\le y_i<m$，请你构造一个同样长为 $n$ 的数组 $x$，使得：\n\n1. $x_i$ 在 `__int128` 范围内；\n2. $x_i\\bmod m=y_i$；\n3. $\\gcd(|x_1|,\\cdots,|x_n|)\\bmod m$ 最大。\n\n注意，$x_i$ **可以为负**，此时 $m\\mid (x_i-y_i)$ 且 $0\\le y_i<m$。 ", "inputFormat": "第一行两个正整数 $n,m$。\n\n接下来一行 $n$ 个非负整数，代表 $x_i \\bmod m$ 的值。", "outputFormat": "第一行一个非负整数 $g$，代表 $\\gcd(|x_1|,|x_2|,\\cdots,|x_n|)\\mod m$ 的可能最大值。\n\n接下来一行 $n$ 个整数，代表 $x_i$。", "hint": "**数据范围**\n\n**本题采用捆绑测试。**\n\nSubtask 1（$30$ pts）：$m$ 是素数。\n\nSubtask 2（$70$ pts）：无特殊限制。\n\n对于所有数据，保证 $2\\le m \\le10^9$，$1\\le n\\le10^6$。\n\n**关于 Special Judge**\n\n对于每个测试点：\n\n如果你输出的格式不正确，你将会获得 $0$ 分。\n\n如果你输出的数中有不在 `__int128` 范围的数，可能导致溢出所以你可能无法获得预期的分数。\n\n如果你的数列 $x$ 不符合题目给定的 $y$，你将会获得 $0$ 分。\n\n如果你的数列 $x$ 不符合你输出的 $g$，你将会获得 $0$ 分。\n\n如果你的 $g$ 不为最大，你将会获得 $0$ 分。\n\n否则你将获得该测试点的所有分数。", "locale": "zh-CN"}}}
{"pid": "P8962", "type": "P", "difficulty": 4, "samples": [["998244353 5\n", "1\n1 2\n4 4 4\n12 12 14 18\n48 54 60 66 72"]], "limits": {"time": [1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "二分", "O2优化"], "title": "「WHOI-4」yadiw. Slua, gassp, lhtubs.", "background": "> If you know at least 3 of these things and you are not red — you are doing it wrong. Stop learning useless algorithms, go and solve some problems, learn how to use binary search.\n", "description": "小 F 有一个奇妙的数组 $a$，$a$ 中没有重复的元素，长度为 $n$，他使用`std::sort`将他排序了，认为它是有序的，所以他正在使用这样的方法进行二分查找。显然，能否查到只和数列的离散化结果有关，所以你可以直接把 $a$ 看作 $1\\sim n$ 的一个排列。\n\n```cpp\nint search(int key) {\n  int l = 1, r = n;\n  while (l <= r) {\n    int mid = (l + r) / 2;\n    if (a[mid] < key)\n      l = mid + 1;\n    else if (a[mid] == key)\n      return mid;\n    else\n      r = mid - 1;\n  }\n  return -1;\n}\n```\n\n不幸的是，小 W 为了让他戒掉万能头，在`bits/stdc++.h`中写了`#define sort random_shuffle`，这意味着 $a$ 实际是一个随机的排列。\n\n现在，对于所有在 $1$ 到 $N$ 范围内的 $n$，以及所有在 $1$ 到 $n$ 范围内的 $k$，在 $a$ 数列的所有排列中，有几个可以正确地找到第 $k$ 小的元素 $key$（即返回值非 $-1$）？由于答案可能过大，请输出它对给定模数 $p$ 取模的结果。", "inputFormat": "一行两个正整数 $p,N$。", "outputFormat": "$N$ 行，第 $n$ 行 $n$ 个正整数，代表在 $n$ 个元素中找 $k$ 能找到的方案数。", "hint": "**数据范围**\n\n**本题采用 Subtask 评测。**\n\n- Subtask 1（$10$ pts）：$N=10$，$ p\\ge998244352$；\n- Subtask 2（$25$ pts）：$N=100$，$p\\ge1009$ **且为素数**；\n- Subtask 3（$25$ pts）：$N=400$，$p\\ge1009$ **且为素数**；\n- Subtask 4（$40$ pts）：$N=400$。\n\n对于所有数据，$10\\le N\\le 400$，$ 2\\le p\\le998244353$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「WHOI-4」yadiw. Slua, gassp, lhtubs.", "background": "> If you know at least 3 of these things and you are not red — you are doing it wrong. Stop learning useless algorithms, go and solve some problems, learn how to use binary search.\n", "description": "小 F 有一个奇妙的数组 $a$，$a$ 中没有重复的元素，长度为 $n$，他使用`std::sort`将他排序了，认为它是有序的，所以他正在使用这样的方法进行二分查找。显然，能否查到只和数列的离散化结果有关，所以你可以直接把 $a$ 看作 $1\\sim n$ 的一个排列。\n\n```cpp\nint search(int key) {\n  int l = 1, r = n;\n  while (l <= r) {\n    int mid = (l + r) / 2;\n    if (a[mid] < key)\n      l = mid + 1;\n    else if (a[mid] == key)\n      return mid;\n    else\n      r = mid - 1;\n  }\n  return -1;\n}\n```\n\n不幸的是，小 W 为了让他戒掉万能头，在`bits/stdc++.h`中写了`#define sort random_shuffle`，这意味着 $a$ 实际是一个随机的排列。\n\n现在，对于所有在 $1$ 到 $N$ 范围内的 $n$，以及所有在 $1$ 到 $n$ 范围内的 $k$，在 $a$ 数列的所有排列中，有几个可以正确地找到第 $k$ 小的元素 $key$（即返回值非 $-1$）？由于答案可能过大，请输出它对给定模数 $p$ 取模的结果。", "inputFormat": "一行两个正整数 $p,N$。", "outputFormat": "$N$ 行，第 $n$ 行 $n$ 个正整数，代表在 $n$ 个元素中找 $k$ 能找到的方案数。", "hint": "**数据范围**\n\n**本题采用 Subtask 评测。**\n\n- Subtask 1（$10$ pts）：$N=10$，$ p\\ge998244352$；\n- Subtask 2（$25$ pts）：$N=100$，$p\\ge1009$ **且为素数**；\n- Subtask 3（$25$ pts）：$N=400$，$p\\ge1009$ **且为素数**；\n- Subtask 4（$40$ pts）：$N=400$。\n\n对于所有数据，$10\\le N\\le 400$，$ 2\\le p\\le998244353$。", "locale": "zh-CN"}}}
{"pid": "P8963", "type": "P", "difficulty": 5, "samples": [["5 10\n2 3 8 5 4", "-1 6\n2 3 4 5 6"], ["7 100\n11 45 14 19 19 8 10", "-17 51\n16 15 14 13 12 11 10"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "Special Judge", "O2优化"], "title": "「WHOI-4」加减法构造", "background": "", "description": "小 W 给了你一个长度为 $n$ 的**整数**数组 $x$。你需要构造一个长度也为 $n$ 的**整数**数组 $y$，并满足：\n\n1. $\\forall 1\\le i,j,i+j\\le n,y_{i+j}=y_i+y_j+k$，$k$ 是一个你需要钦定的整数。\n3. $d(x,y)=\\sum\\limits_{i=1}^n|x_i-y_i|$ 最小。\n3. $-V\\le y_i\\le V$，$V$ 是输入中给定的数。 ", "inputFormat": "第一行两个整数 $n,V$。\n\n接下来一行 $n$ 个整数，第 $i$ 个代表 $x_i$。", "outputFormat": "第一行两个整数 $k,d$，代表你钦定的值和你的答案。\n\n接下来一行 $n$ 个整数，第 $i$ 个代表 $y_i$。\n\n题目保证 $d$ 的最小值在 `long long` 范围内。", "hint": "**数据范围**\n\n- Subtask 1（$20$ pts）：$n\\le10$，$ V\\le10$，$ |x_i|\\le10$；\n- Subtask 2（$20$ pts）：$n\\le100$，$ |x_i|\\le100$，$V\\le1000$；\n- Subtask 3（$20$ pts）：$n\\le10^6$，$ |x_i|\\le10^6$，$V=10^{12}$；\n- Subtask 4（$20$ pts）：$n\\le10^7$，$|x_i|\\le10^7$，$V\\le10^7$;\n- Subtask 5（$20$ pts）：$n\\le10^7$，$|x_i|\\le10^7$，$V\\le 10^{12}$。\n\n对于所有数据，保证 $1\\le n\\le 10^7$，$|x_i|\\le10^7$，$1\\le V\\le10^{12}$。\n\n**关于 Special Judge 的说明**\n\n对于每个测试点：\n\n如果你输出的格式不正确，你将会获得 $0$ 分。\n\n如果你输出的数中有不在 $[-V,V]$ 范围的数，你将会获得 $0$ 分。\n\n如果你的数列 $y$ 不符合你输出的 $k$，你将会获得 $0$ 分。\n\n如果你的数列 $y$ 不符合你输出的 $d$，你将会获得 $0$ 分。\n\n否则你将会获得的分数为该测试点总分的百分之 $\\max\\{0,\\min\\{100,10100-\\frac{10000d}{d'}\\}\\}$，$d'$ 是答案的 $d$ 值。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「WHOI-4」加减法构造", "background": "", "description": "小 W 给了你一个长度为 $n$ 的**整数**数组 $x$。你需要构造一个长度也为 $n$ 的**整数**数组 $y$，并满足：\n\n1. $\\forall 1\\le i,j,i+j\\le n,y_{i+j}=y_i+y_j+k$，$k$ 是一个你需要钦定的整数。\n3. $d(x,y)=\\sum\\limits_{i=1}^n|x_i-y_i|$ 最小。\n3. $-V\\le y_i\\le V$，$V$ 是输入中给定的数。 ", "inputFormat": "第一行两个整数 $n,V$。\n\n接下来一行 $n$ 个整数，第 $i$ 个代表 $x_i$。", "outputFormat": "第一行两个整数 $k,d$，代表你钦定的值和你的答案。\n\n接下来一行 $n$ 个整数，第 $i$ 个代表 $y_i$。\n\n题目保证 $d$ 的最小值在 `long long` 范围内。", "hint": "**数据范围**\n\n- Subtask 1（$20$ pts）：$n\\le10$，$ V\\le10$，$ |x_i|\\le10$；\n- Subtask 2（$20$ pts）：$n\\le100$，$ |x_i|\\le100$，$V\\le1000$；\n- Subtask 3（$20$ pts）：$n\\le10^6$，$ |x_i|\\le10^6$，$V=10^{12}$；\n- Subtask 4（$20$ pts）：$n\\le10^7$，$|x_i|\\le10^7$，$V\\le10^7$;\n- Subtask 5（$20$ pts）：$n\\le10^7$，$|x_i|\\le10^7$，$V\\le 10^{12}$。\n\n对于所有数据，保证 $1\\le n\\le 10^7$，$|x_i|\\le10^7$，$1\\le V\\le10^{12}$。\n\n**关于 Special Judge 的说明**\n\n对于每个测试点：\n\n如果你输出的格式不正确，你将会获得 $0$ 分。\n\n如果你输出的数中有不在 $[-V,V]$ 范围的数，你将会获得 $0$ 分。\n\n如果你的数列 $y$ 不符合你输出的 $k$，你将会获得 $0$ 分。\n\n如果你的数列 $y$ 不符合你输出的 $d$，你将会获得 $0$ 分。\n\n否则你将会获得的分数为该测试点总分的百分之 $\\max\\{0,\\min\\{100,10100-\\frac{10000d}{d'}\\}\\}$，$d'$ 是答案的 $d$ 值。", "locale": "zh-CN"}}}
{"pid": "P8964", "type": "P", "difficulty": 2, "samples": [["3\n4 4\ntnalp\nwoem\nkcarrab\nhctam\n\nfreopen(\"tnalp.in\",\"r\",stdin);\nfreopen(\"tnalp.out\",\"w\",stdout);\nfreopen(\"woem.in\",\"r\",stdin);\nfreopen(\"woem.out\",\"w\",stdout);\nfreopen(\"kcarrab.in\",\"r\",stdin);\nfreopen(\"kcarrab.out\",\"w\",stdout);\nfreopen(\"hctam.in\",\"r\",stdin);\nfreopen(\"hctam.out\",\"w\",stdout);\n\nfreopen(\"tnalp.in\",\"r\",stdin);\nfreopen(\"tnalp.out\",\"w\",stdout);\n//freopen(\"woem.in\",\"r\",stdin);\nfreopen(\"woem.out\",\"w\",stdout);\nfreopen(\"kcarrab.in\",\"r\",stdin);\n//I_AK_IOI!!!\nfreopen(\"hctam.in\",\"r\",stdin);\nfreopen(\"hctam.out\",\"w\",stdout);\n\nfreopen(\"tnalp.in\",\"r\",stdin);\nfreopen(\"tnalp.out\",\"w\",stdout)\nfreopen(\"owem.in\",\"r\",stdin);\nfreopen(\"woem.out\",\"w\",stdout);\nfreopen(\"kcarrab.in\",\"r\",stdout);\nfreopen(\"kcarrab.out\",\"w\",stdin);\nfreopen(\"hctam.out\",\"w\",stdout);\nfreopen(\"hctam.in\",\"r\",stdin);\n\nfreopen(\"tnalp.in\",\"r\",stdin);//I_LOVE_CCF\nfreopen(\"tnalp.out\",\"w\",stdout);\nfreopen(\"woem.in\",\"r\",stdin);//I_HATE_THIS\nfreopen(\"woem.out\",\"w\",stdout);\nfreopen(\"kcarrab.in\"/*I_FORGET_HOW_TO_FIND_BRIDGES!!!!!!*/,\"r\",stdin);\nfreopen(\"kcarrab.out\",\"w\",stdout);\nfreopen(\"hctam.in\",\"r\",stdin);//I_CAN_GET_ONLY_8PTSqwq\nfreopen(\"hctam.out\",\"w\",stdout);\n", "PION2202 RP++.\nWrong file operation takes you to your ancestors along with your 3 years' efforts on OI.\nGood luck and have fun.\nGood luck and have fun.\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "字符串", "洛谷原创", "O2优化", "洛谷月赛"], "title": "梦幻 | Reopening of  Dream", "background": "_望你没有因此而功亏一篑过_\n\n花开不是为了花落，而是为了更加灿烂。\n\n最初拥有的只是理想和自信，但所有的一切都从这里交错着生长，在努力与汗水铺成的路上走下去不会是错误的选择——至少你为此喜怒哀乐过。\n\n**祝每一位有理想的参赛者都能取得理想的成绩！**\n", "description": "PION2202 的选手代码公布了。作为一个~~连续编写了十年迷惑行为大赏~~的人，你当然是要抢先把代码中的各种事迹发出来啦。\n\n首先关注的肯定是大家的文件输入输出有没写对。你已经让小 E 把每道题的题目名称和每位选手的 `freopen` 语句整理出来了。\n\nPION2202 一共有 $m$ 道题，有 $n$ 位选手参与。你决定把选手分成三类：\n\n1. 普通人：最正常不过的 `freopen` 语句；\n2. 见祖宗人：被注释的 `freopen` 语句；\n3. 乐子人：其他形式的 `freopen` 语句。\n\n形式化地，普通人的所有题目的 `freopen` 语句都应该恰好是\n\n```cpp\nfreopen(\"<title>.in\",\"r\",stdin);\nfreopen(\"<title>.out\",\"w\",stdout);\n```\n\n其中的 `<title>` 应替换成对应的题目名称。\n\n见祖宗人的 `freopen` 语句中存在至少一道题的至少一行语句以 `//freopen(` 开头，以 `);` 结尾。\n\n如果一位选手的 `freopen` 语句不满足上面两种情况，则称这位选手为乐子人。\n\n你需要判断每位选手是普通人，见祖宗人还是乐子人。", "inputFormat": "第一行一个正整数 $T$，表示子任务编号。\n\n第二行两个正整数 $n,m$，分别表示选手数和题目数。\n\n接下来 $m$ 行，每行包含一个仅由小写字母构成的字符串，其中第 $i$ 行表示第 $i$ 道题目的题目名称。保证题目名称的长度在 $1$ 到 $10$ 之间。\n\n接下来 $n\\times(2m+1)$ 行，在每 $2m+1$ 行中，第一行为空行，后 $2m$ 行表示一位选手的所有题目的 `freopen` 语句，按照题目顺序给出。前两行为第一题的 `freopen` 语句，依次类推，最后两行为最后一题的 `freopen` 语句。\n\n保证所有的 `freopen` 语句的每个字符的 ASCII 码均在 $33$ 到 $126$ 之间，即不含空格等不可见字符。\n\n保证每一行 `freopen` 语句的长度在 $1$ 到 $100$ 之间。", "outputFormat": "输出 $n$ 行，其中第 $i$ 行表示第 $i$ 位选手的分类。\n\n如果是普通人，就要祝他 RP++，所以就输出一行 `PION2202 RP++.`。\n\n如果是见祖宗人，那就只好输出一行 `Wrong file operation takes you to your ancestors along with your 3 years' efforts on OI.`。\n\n如果是乐子人，就祝他在玩得开心的同时注意不要弄错了，于是输出一行 `Good luck and have fun.`。", "hint": "**【样例解释】**\n\n第一位选手所有的 `freopen` 语句都很正常，所以是普通人。\n\n第二位选手注释了题目 `woem` 的输入文件语句，所以是见祖宗人。虽然该选手在题目 `kcarrab` 中有乐子行为但由于已经满足了见祖宗人的条件，所以该选手被分类为见祖宗人。\n\n第三位选手四道题的 `freopen` 语句都不是正常的。`tnalp` 的输出文件语句少了分号；`woem` 被打成了 `owem`；打反了 `kcarrab` 一题中的 `stdin` 和 `stdout`；交换了 `hctam` 的两个语句的顺序。在本题中算作乐子人。\n\n第四位选手的 `freopen` 语句虽然能够正常工作，但是因为与正常的 `freopen` 语句不同而在本题中被算作乐子人。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n子任务 1（30 分）：$T = 1$。$m = 1$ 且题目名称为 `yxalag`。但是，如果你输出 `No, general!` 是不能得到分数的。  \n子任务 2（30 分）：$T = 2$。保证没有见祖宗人。  \n子任务 3（40 分）：$T = 3$。无特殊性质。\n\n对于 $100\\%$ 的数据：\n\n- 保证 $1\\le T \\le 3$。\n- 保证 $1\\le n\\le 1000$。\n- 保证 $1\\le m \\le 4$。\n- 保证题目名称的长度在 $1$ 到 $10$ 之间。\n- 保证每一行 `freopen` 语句的长度在 $1$ 到 $100$ 之间。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "梦幻 | Reopening of  Dream", "background": "_望你没有因此而功亏一篑过_\n\n花开不是为了花落，而是为了更加灿烂。\n\n最初拥有的只是理想和自信，但所有的一切都从这里交错着生长，在努力与汗水铺成的路上走下去不会是错误的选择——至少你为此喜怒哀乐过。\n\n**祝每一位有理想的参赛者都能取得理想的成绩！**\n", "description": "PION2202 的选手代码公布了。作为一个~~连续编写了十年迷惑行为大赏~~的人，你当然是要抢先把代码中的各种事迹发出来啦。\n\n首先关注的肯定是大家的文件输入输出有没写对。你已经让小 E 把每道题的题目名称和每位选手的 `freopen` 语句整理出来了。\n\nPION2202 一共有 $m$ 道题，有 $n$ 位选手参与。你决定把选手分成三类：\n\n1. 普通人：最正常不过的 `freopen` 语句；\n2. 见祖宗人：被注释的 `freopen` 语句；\n3. 乐子人：其他形式的 `freopen` 语句。\n\n形式化地，普通人的所有题目的 `freopen` 语句都应该恰好是\n\n```cpp\nfreopen(\"<title>.in\",\"r\",stdin);\nfreopen(\"<title>.out\",\"w\",stdout);\n```\n\n其中的 `<title>` 应替换成对应的题目名称。\n\n见祖宗人的 `freopen` 语句中存在至少一道题的至少一行语句以 `//freopen(` 开头，以 `);` 结尾。\n\n如果一位选手的 `freopen` 语句不满足上面两种情况，则称这位选手为乐子人。\n\n你需要判断每位选手是普通人，见祖宗人还是乐子人。", "inputFormat": "第一行一个正整数 $T$，表示子任务编号。\n\n第二行两个正整数 $n,m$，分别表示选手数和题目数。\n\n接下来 $m$ 行，每行包含一个仅由小写字母构成的字符串，其中第 $i$ 行表示第 $i$ 道题目的题目名称。保证题目名称的长度在 $1$ 到 $10$ 之间。\n\n接下来 $n\\times(2m+1)$ 行，在每 $2m+1$ 行中，第一行为空行，后 $2m$ 行表示一位选手的所有题目的 `freopen` 语句，按照题目顺序给出。前两行为第一题的 `freopen` 语句，依次类推，最后两行为最后一题的 `freopen` 语句。\n\n保证所有的 `freopen` 语句的每个字符的 ASCII 码均在 $33$ 到 $126$ 之间，即不含空格等不可见字符。\n\n保证每一行 `freopen` 语句的长度在 $1$ 到 $100$ 之间。", "outputFormat": "输出 $n$ 行，其中第 $i$ 行表示第 $i$ 位选手的分类。\n\n如果是普通人，就要祝他 RP++，所以就输出一行 `PION2202 RP++.`。\n\n如果是见祖宗人，那就只好输出一行 `Wrong file operation takes you to your ancestors along with your 3 years' efforts on OI.`。\n\n如果是乐子人，就祝他在玩得开心的同时注意不要弄错了，于是输出一行 `Good luck and have fun.`。", "hint": "**【样例解释】**\n\n第一位选手所有的 `freopen` 语句都很正常，所以是普通人。\n\n第二位选手注释了题目 `woem` 的输入文件语句，所以是见祖宗人。虽然该选手在题目 `kcarrab` 中有乐子行为但由于已经满足了见祖宗人的条件，所以该选手被分类为见祖宗人。\n\n第三位选手四道题的 `freopen` 语句都不是正常的。`tnalp` 的输出文件语句少了分号；`woem` 被打成了 `owem`；打反了 `kcarrab` 一题中的 `stdin` 和 `stdout`；交换了 `hctam` 的两个语句的顺序。在本题中算作乐子人。\n\n第四位选手的 `freopen` 语句虽然能够正常工作，但是因为与正常的 `freopen` 语句不同而在本题中被算作乐子人。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n子任务 1（30 分）：$T = 1$。$m = 1$ 且题目名称为 `yxalag`。但是，如果你输出 `No, general!` 是不能得到分数的。  \n子任务 2（30 分）：$T = 2$。保证没有见祖宗人。  \n子任务 3（40 分）：$T = 3$。无特殊性质。\n\n对于 $100\\%$ 的数据：\n\n- 保证 $1\\le T \\le 3$。\n- 保证 $1\\le n\\le 1000$。\n- 保证 $1\\le m \\le 4$。\n- 保证题目名称的长度在 $1$ 到 $10$ 之间。\n- 保证每一行 `freopen` 语句的长度在 $1$ 到 $100$ 之间。", "locale": "zh-CN"}}}
{"pid": "P8965", "type": "P", "difficulty": 3, "samples": [["3 2\n1 2 1\n2 3 1\n1 2 1 3\n2 3 2 3\n", "1\n0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "O2优化", "前缀和", "洛谷月赛"], "title": "坠梦 | Falling into Dream", "background": "神明愚弄凡间，所谓命运，不过是神明掷出的一颗骰子而已。\n\n花朵等不到的蝴蝶，终究成了一分蹊跷的梦，一轮轮再次重启。\n\n神明的提线木偶一次又一次的被扼住脖颈, 以爱的名义，消逝在时间的花海里。\n\n无数的执念背后，都有一个被扭曲的“真理”。\n \n 你所承诺的没有出现，彻夜无眠，或许我只是自作主张的，替你爱了一次人间\n\n“最虔诚者只祝祷，不虔诚者才有所求。”\n\n没有过信仰，因为舍命救了一个人，有幸来到了天堂。\n ", "description": "给定一棵 $n$ 个结点的无根树，每条边有非负整数边权。结点由 $1 \\sim n$ 编号。\n\n对于每一个点对 $(x, y)$，定义 $(x, y)$ 的距离 $\\operatorname{dis}(x, y)$ 为 $x,y$ 两点之间唯一简单路径上边权的异或和。\n\n给定两个结点 $x, y$，定义点 $i$ 的价值 $\\operatorname{val}_{x, y}(i)$ 为 $(x, i)$ 与 $(y, i)$ 的距离的异或和，即\n\n$$ \\operatorname{val}_{x, y}(i) = \\operatorname{dis}(x, i) \\oplus \\operatorname{dis}(y, i) \\textsf{。} $$\n\n现在有 $q$ 次询问，每次询问给出四个整数 $x, y, l, r$，求 $\\displaystyle \\bigoplus_{i = l}^{r} \\operatorname{val}_{x, y}(i)$ 的值，即求\n\n$$ \\operatorname{val}_{x, y}(l) \\oplus \\operatorname{val}_{x, y}(l + 1) \\oplus \\cdots \\oplus \\operatorname{val}_{x, y}(r - 1) \\oplus \\operatorname{val}_{x, y}(r) \\textsf{。} $$\n\n上述公式中，$\\oplus$ 表示二进制按位异或。", "inputFormat": "第一行，两个整数 $n, q$。\n\n接下来 $n - 1$ 行，每行三个整数 $u, v, w$，表示 $u, v$ 之间有一条权值为 $w$ 的边。\n\n接下来 $q$ 行，每行四个整数 $x,y,l,r$，表示一次询问。", "outputFormat": "输出 $q$ 行，每行一个整数，为每次询问的答案。", "hint": "**【样例解释】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oew00pa7.png)\n\n输入给出的树如上图所示。对于点对的距离，有\n\n- $\\operatorname{dis}(1, 1) = \\operatorname{dis}(1, 3) = \\operatorname{dis}(2, 2) = \\operatorname{dis}(3, 1) = \\operatorname{dis}(3, 3) = 0$ 以及\n- $\\operatorname{dis}(1, 2) = \\operatorname{dis}(2, 1) = \\operatorname{dis}(2, 3) = \\operatorname{dis}(3, 2) = 1$。\n\n第 $1$ 问：$\\operatorname{val}_{1, 2}(1) \\oplus \\operatorname{val}_{1, 2}(2) \\oplus \\operatorname{val}_{1, 2}(3) = (0 \\oplus 1) \\oplus (1 \\oplus 0) \\oplus (0 \\oplus 1) = 1 \\oplus 1 \\oplus 1 = 1$。\n\n第 $2$ 问：$\\operatorname{val}_{2, 3}(2) \\oplus \\operatorname{val}_{2, 3}(3) = (0 \\oplus 1) \\oplus (1 \\oplus 0) = 1 \\oplus 1 = 0$。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $n \\le$ | $q \\le$ | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| 1 | $100$ | $10$ | 24 |\n| 2 | $10^6$ | $10$ | 14 |\n| 3 | $100$ | $10^6$ | 14 |\n| 4 | $10^6$ | $10^6$ | 48 |\n\n对于 $100\\%$ 的数据，保证 $1 \\le n, q \\le {10}^6$，$1 \\le u, v, x, y \\le n$，$1 \\le l \\le r \\le n$，$0 \\le w < 2^{31}$。\n\n---\n\n**【提示】**\n\n本题最大 I/O 量达到 60 MiB，请注意 I/O 效率。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "坠梦 | Falling into Dream", "background": "神明愚弄凡间，所谓命运，不过是神明掷出的一颗骰子而已。\n\n花朵等不到的蝴蝶，终究成了一分蹊跷的梦，一轮轮再次重启。\n\n神明的提线木偶一次又一次的被扼住脖颈, 以爱的名义，消逝在时间的花海里。\n\n无数的执念背后，都有一个被扭曲的“真理”。\n \n 你所承诺的没有出现，彻夜无眠，或许我只是自作主张的，替你爱了一次人间\n\n“最虔诚者只祝祷，不虔诚者才有所求。”\n\n没有过信仰，因为舍命救了一个人，有幸来到了天堂。\n ", "description": "给定一棵 $n$ 个结点的无根树，每条边有非负整数边权。结点由 $1 \\sim n$ 编号。\n\n对于每一个点对 $(x, y)$，定义 $(x, y)$ 的距离 $\\operatorname{dis}(x, y)$ 为 $x,y$ 两点之间唯一简单路径上边权的异或和。\n\n给定两个结点 $x, y$，定义点 $i$ 的价值 $\\operatorname{val}_{x, y}(i)$ 为 $(x, i)$ 与 $(y, i)$ 的距离的异或和，即\n\n$$ \\operatorname{val}_{x, y}(i) = \\operatorname{dis}(x, i) \\oplus \\operatorname{dis}(y, i) \\textsf{。} $$\n\n现在有 $q$ 次询问，每次询问给出四个整数 $x, y, l, r$，求 $\\displaystyle \\bigoplus_{i = l}^{r} \\operatorname{val}_{x, y}(i)$ 的值，即求\n\n$$ \\operatorname{val}_{x, y}(l) \\oplus \\operatorname{val}_{x, y}(l + 1) \\oplus \\cdots \\oplus \\operatorname{val}_{x, y}(r - 1) \\oplus \\operatorname{val}_{x, y}(r) \\textsf{。} $$\n\n上述公式中，$\\oplus$ 表示二进制按位异或。", "inputFormat": "第一行，两个整数 $n, q$。\n\n接下来 $n - 1$ 行，每行三个整数 $u, v, w$，表示 $u, v$ 之间有一条权值为 $w$ 的边。\n\n接下来 $q$ 行，每行四个整数 $x,y,l,r$，表示一次询问。", "outputFormat": "输出 $q$ 行，每行一个整数，为每次询问的答案。", "hint": "**【样例解释】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oew00pa7.png)\n\n输入给出的树如上图所示。对于点对的距离，有\n\n- $\\operatorname{dis}(1, 1) = \\operatorname{dis}(1, 3) = \\operatorname{dis}(2, 2) = \\operatorname{dis}(3, 1) = \\operatorname{dis}(3, 3) = 0$ 以及\n- $\\operatorname{dis}(1, 2) = \\operatorname{dis}(2, 1) = \\operatorname{dis}(2, 3) = \\operatorname{dis}(3, 2) = 1$。\n\n第 $1$ 问：$\\operatorname{val}_{1, 2}(1) \\oplus \\operatorname{val}_{1, 2}(2) \\oplus \\operatorname{val}_{1, 2}(3) = (0 \\oplus 1) \\oplus (1 \\oplus 0) \\oplus (0 \\oplus 1) = 1 \\oplus 1 \\oplus 1 = 1$。\n\n第 $2$ 问：$\\operatorname{val}_{2, 3}(2) \\oplus \\operatorname{val}_{2, 3}(3) = (0 \\oplus 1) \\oplus (1 \\oplus 0) = 1 \\oplus 1 = 0$。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $n \\le$ | $q \\le$ | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| 1 | $100$ | $10$ | 24 |\n| 2 | $10^6$ | $10$ | 14 |\n| 3 | $100$ | $10^6$ | 14 |\n| 4 | $10^6$ | $10^6$ | 48 |\n\n对于 $100\\%$ 的数据，保证 $1 \\le n, q \\le {10}^6$，$1 \\le u, v, x, y \\le n$，$1 \\le l \\le r \\le n$，$0 \\le w < 2^{31}$。\n\n---\n\n**【提示】**\n\n本题最大 I/O 量达到 60 MiB，请注意 I/O 效率。", "locale": "zh-CN"}}}
{"pid": "P8966", "type": "P", "difficulty": 4, "samples": [["5\n1 1 2 2\n1 1 1 1 1\n", "5 4 2 3 3"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["博弈论", "洛谷原创", "O2优化", "洛谷月赛"], "title": "觅光 | Searching for Hope (easy ver.)", "background": "**这是本题的简单版本。两个版本在 $\\bm{100 \\%}$ 数据范围的唯一区别是关于 $\\bm{n}$ 的限制。此版本中 $\\bm{n \\le 1000}$。**\n\n---\n\n有梦中所向往的地方，也有现实中可望不可触及的远方。\n\n我们正等待无数次的希望，新的纪元，生命不曾奏响终章。\n\n顷刻间颠覆中的一切，天空坠落到海底，死死卡住呼吸者的全部。羽翼裹满刺骨的海水，悲伤到从此遗忘呼吸的意义。\n\n明明与空气只隔着毫厘，却不想再尝试去呼吸。我开始明白，悲伤到了极点，也许不会流泪\n\n神明借着生的名义，捏造出灰暗的真理。\n\n\n\n泪水模糊眼眶，身躯坠进天空，泛白的天光，不得已照亮这一日的希望。", "description": "现在有一棵 $n$ 个节点的有根二叉树。\n\n凡人与神明在这棵树上进行一个游戏。凡人需要从根投下若干个球，每个球带 $1$ 单位正电荷或带 $1$ 单位负电荷。\n\n树上每一个点有容量，第 $i$ 个点可以容纳 $c_i$ 个球。初始每一个点容纳的球数为 $0$。我们称一个点被充满当且仅当它容纳的球的个数等于它的容量。\n\n每一次一个球下落到一个点时：\n\n- 如果该点没有孩子节点或者所有孩子节点上都已经充满球，则停止，该点容纳的球的个数 $+1$；\n- 如果该点恰有一个孩子节点未充满，则向那个孩子下落；\n- 如果有 $2$ 个孩子节点均未充满：\n\t- 如果左侧子树中所有球的电荷代数和大于右侧子树所有球的电荷代数和，则如果当前球带正电则向右下落，否则向左下落；\n   - 如果左侧子树中所有球的电荷代数和小于右侧子树所有球的电荷代数和，则如果当前球带正电则向左下落，否则向右下落；\n   - 如果左侧子树中所有球的电荷代数和等于右侧子树所有球的电荷代数和，则由神明决定向哪个方向下落。\n   \n其中，电荷代数和指的是正电荷的数量减去负电荷的数量。\n   \n在游戏开始前，双方约定目标点 $u$。在一个回合中，凡人选择这次投下的球的电性，神明按上述规则控制球的下落过程。当 $u$ 被充满时，游戏结束。\n\n凡人希望游戏回合数尽量少，神明希望游戏回合数尽量多。假设双方足够聪明。\n\n对所有：$1\\leq u\\leq n$，求游戏轮数 $r_u$。", "inputFormat": "第一行，一个正整数 $n$。\n\n第二行，$n-1$ 个整数 $f_2, f_3, \\ldots, f_n$，其中 $f_i$ 代表 $i$ 的父亲的编号。\n\n第三行，$n$ 个整数 $c_1, c_2, \\ldots, c_n$。", "outputFormat": "输出一行，$n$ 个整数 $r_1, r_2, \\ldots, r_n$。", "hint": "**【数据范围】**\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $n \\le$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |:-:|\n| 1 | $1000$ | A | 11 |\n| 2 | $10$ | B | 27 |\n| 3 | $1000$ | | 62 |\n\n- 特殊性质 A：树退化成一条以 $1$ 为一端的链。\n- 特殊性质 B：$c_i = 1$。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 1000$，满足树是以 $1$ 为根的二叉树，$1 \\le f_i < i$，$1 \\le c_i \\le {10}^{12}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "觅光 | Searching for Hope (easy ver.)", "background": "**这是本题的简单版本。两个版本在 $\\bm{100 \\%}$ 数据范围的唯一区别是关于 $\\bm{n}$ 的限制。此版本中 $\\bm{n \\le 1000}$。**\n\n---\n\n有梦中所向往的地方，也有现实中可望不可触及的远方。\n\n我们正等待无数次的希望，新的纪元，生命不曾奏响终章。\n\n顷刻间颠覆中的一切，天空坠落到海底，死死卡住呼吸者的全部。羽翼裹满刺骨的海水，悲伤到从此遗忘呼吸的意义。\n\n明明与空气只隔着毫厘，却不想再尝试去呼吸。我开始明白，悲伤到了极点，也许不会流泪\n\n神明借着生的名义，捏造出灰暗的真理。\n\n\n\n泪水模糊眼眶，身躯坠进天空，泛白的天光，不得已照亮这一日的希望。", "description": "现在有一棵 $n$ 个节点的有根二叉树。\n\n凡人与神明在这棵树上进行一个游戏。凡人需要从根投下若干个球，每个球带 $1$ 单位正电荷或带 $1$ 单位负电荷。\n\n树上每一个点有容量，第 $i$ 个点可以容纳 $c_i$ 个球。初始每一个点容纳的球数为 $0$。我们称一个点被充满当且仅当它容纳的球的个数等于它的容量。\n\n每一次一个球下落到一个点时：\n\n- 如果该点没有孩子节点或者所有孩子节点上都已经充满球，则停止，该点容纳的球的个数 $+1$；\n- 如果该点恰有一个孩子节点未充满，则向那个孩子下落；\n- 如果有 $2$ 个孩子节点均未充满：\n\t- 如果左侧子树中所有球的电荷代数和大于右侧子树所有球的电荷代数和，则如果当前球带正电则向右下落，否则向左下落；\n   - 如果左侧子树中所有球的电荷代数和小于右侧子树所有球的电荷代数和，则如果当前球带正电则向左下落，否则向右下落；\n   - 如果左侧子树中所有球的电荷代数和等于右侧子树所有球的电荷代数和，则由神明决定向哪个方向下落。\n   \n其中，电荷代数和指的是正电荷的数量减去负电荷的数量。\n   \n在游戏开始前，双方约定目标点 $u$。在一个回合中，凡人选择这次投下的球的电性，神明按上述规则控制球的下落过程。当 $u$ 被充满时，游戏结束。\n\n凡人希望游戏回合数尽量少，神明希望游戏回合数尽量多。假设双方足够聪明。\n\n对所有：$1\\leq u\\leq n$，求游戏轮数 $r_u$。", "inputFormat": "第一行，一个正整数 $n$。\n\n第二行，$n-1$ 个整数 $f_2, f_3, \\ldots, f_n$，其中 $f_i$ 代表 $i$ 的父亲的编号。\n\n第三行，$n$ 个整数 $c_1, c_2, \\ldots, c_n$。", "outputFormat": "输出一行，$n$ 个整数 $r_1, r_2, \\ldots, r_n$。", "hint": "**【数据范围】**\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $n \\le$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |:-:|\n| 1 | $1000$ | A | 11 |\n| 2 | $10$ | B | 27 |\n| 3 | $1000$ | | 62 |\n\n- 特殊性质 A：树退化成一条以 $1$ 为一端的链。\n- 特殊性质 B：$c_i = 1$。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 1000$，满足树是以 $1$ 为根的二叉树，$1 \\le f_i < i$，$1 \\le c_i \\le {10}^{12}$。", "locale": "zh-CN"}}}
{"pid": "P8967", "type": "P", "difficulty": 6, "samples": [["2 1\n1 1\n0 0 50000000\n", "14\n"], ["2 1\n1 2\n0 0 20000000\n", "291154624\n"], ["3 3\n2 3 4\n2 1 0 30000000\n1 2 3 19000000\n2 3 4 1000000\n", "430536142\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "洛谷原创", "O2优化", "排列组合", "期望", "高斯消元", "洛谷月赛"], "title": "追寻 | Pursuit of Dream", "background": "“遇到自己喜欢的人或事情的时候，千万不要放弃”\n\n“要一直追寻下去…”\n\n“因为即使成功希望渺茫，也有可能”\n\n有谁和我说过这句话，脑海中忽然闪过一下，被当做无用的激励一同忘却了。现在想要回忆，却总也记不起来。\n\n好不容易来人间一趟，那就别留下遗憾。\n\n房檐落下的雨滴有规律的敲着石砖，那夜的雨声中，却也悄无声息了。\n\n逆着风吹干眼泪，说不出口的痛越藏越多，腐烂在肚子里，却又不知道彼此心知且肚明，所以无法孕育出美好的结局，只会是恋者相残的戏码不停上演。\n\n---\n\n 看见了漫天星野坠落在你的眼底，从此甘愿在那海底般低压的梦境中堕落。\n\n三千尺星空的光辉映照不出那人的身影，璀璨中徒留神明思故人；那人却散入了或许碎散的星辰大海，让神明寻觅了一生。\n\n那些无法兑现的渴望，会日渐荒芜，然后梦境会失去生机，裂缝中会蔓出黑暗，泪无葬身之地。\n\n是神明告诉我的，可是我不信，因为没有时间还等着我空想了。\n\n神明还说，人死了以后，提前离开的亲人都会在另外一个世界等你。\n\n其实，我也会想，这一定就是另外一个世界。", "description": "在 $n$ 维空间中有一个梦想。这梦想坐落在 $(d_1, d_2, \\ldots, d_n)$ 的地方。而你从 $(0, 0, \\ldots, 0)$ 开始，开启寻梦的旅程。\n\n你的步伐轻缓，每一步只能走一个单位长度。你并不知道你的梦想位于哪里，所以你只能随机选择 $n$ 个正方向中的一个，然后向这个方向走一步。也就是说，在 $[1, n]$ 中均匀随机选择一个正整数 $h$，然后，使你在第 $h$ 维的坐标变成原来的坐标加一。\n\n然而，天有不测风云。在你走每一步的过程中，你会有 $p = \\sum_{i = 1}^k p_i$ 的概率散入天际，并开始一段新的旅程。你会在 $k$ 个地点中的一个重新开始这段旅程，其中第 $i$ 个地点的坐标是 $(a_{i,1}, a_{i,2}, \\ldots, a_{i,n})$，从这里重新开始的概率为 $p_i$。\n\n那么，期望下，你离到达这个梦想还需要多少步呢？", "inputFormat": "第一行，两个正整数 $n,k$。\n\n第二行，$n$ 个非负整数 $d_1, d_2, \\ldots, d_n$。\n\n接下来 $k$ 行，第 $i$ 行 $n + 1$ 个整数 $a_{i, 1}, a_{i, 2}, \\ldots, a_{i, n}, x_i$，每行最后一个整数 $x_i$ 表示 $p_i=x_i\\times 10^{-8}$。\n\n输入的 $x_i$ 保证了 $p_i > 0$ 且 $p < 1$。\n\n保证每个 $x_i$ 在所有可能的组合中等概率随机生成。", "outputFormat": "一行，一个整数，表示答案对 $998244353$ 取模的结果。\n\n如果你不知道如何进行实数取模：可以说明答案一定是有限的，且是有理数，设它的最简分数形式为 $\\frac{p}{q}$。如果存在一个整数 $x$ 满足 $x \\cdot q \\equiv p \\pmod{998244353}$ 且 $0 \\le x < 998244353$，那么你只需输出 $x$ 的值即可。\n\n由于保证了 $x_i$ 是随机生成的，可以说明以接近 $1$ 的概率答案在模意义下存在。事实上，一个当 $x_i$ 尚不确定时以合理地高的概率给出正确答案的算法足以通过本题，考察复杂的模意义下的有理数的处理不是我们的本意。", "hint": "**【样例解释 \\#1】**\n\n这是你的一种追寻梦想的方式：\n\n你从 $(0,0)$ 出发，走一步到 $(1,0)$，再走一步到 $(2,0)$，再走一步到 $(3,0)$，但是在路上散入天际，从 $(0,0)$ 重新开始旅程。\n\n然后继续从 $(0,0)$ 出发，走一步到 $(0,1)$，再走一步到 $(1,1)$，但是在路上散入天际，从 $(0,0)$ 重新开始旅程。\n\n接着从 $(0,0)$ 出发，走一步到 $(1,0)$，再走一步到 $(1,1)$，找到了你的梦想。\n\n在这种情况下，你需要 $7$ 步到达这个梦想。发生这种情况的概率是 $4^{-7}$。\n\n---\n\n**【样例解释 \\#2】**\n\n答案为 $\\frac{505}{24} \\approx 21.041667$。  \n不难验证 $291154624 \\times 24 \\equiv 505 \\pmod{998244353}$，故应输出 $291154624$。\n\n---\n\n**【样例解释 \\#3】**\n\n答案为 $\\frac{1399505}{21519} \\approx 65.035782$。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试且使用子任务依赖。**\n\n| 子任务编号 | 特殊限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 | $n=1$，$k=1$ | 11 |\n| 2 | $n=1$ | 12 |\n| 3 | $k=1$ | 12 |\n| 4 | $n=2$，$1 \\le d_1 \\cdot d_2 \\le 200$ | 13 |\n| 5 | $k \\le 200$ | 22 |\n| 6 | 无特殊限制 | 30 |\n\n对于 $100 \\%$ 的数据：\n\n- $1 \\le n \\le 100$，$1 \\le k \\le 10000$。\n- $d_i \\ge 0$，$\\sum_i d_i \\le 10^7$。\n- $0 \\le a_{i, j} \\le {10}^7$。\n- $x_i \\ge 1$，$\\sum_i x_i < {10}^8$。此即保证了 $p_i > 0$ 和 $p < 1$。\n- 保证存在一个 $i \\in [1, k]$ 使得对于每个 $j \\in [1, n]$ 均有 $a_{i,j} \\le d_j$。\n- 保证每个 $(a_{i, 1}, a_{i, 2}, \\ldots, a_{i, n})$ 作为空间中的点互不相同。\n- 保证每个 $x_i$ 在所有可能的组合中等概率随机生成。\n\n---\n\n**【提示】**\n\n由于保证了 $x_i$ 是随机生成的，可以说明以接近 $1$ 的概率答案在模意义下存在。事实上，一个当 $x_i$ 尚不确定时以合理地高的概率给出正确答案的算法足以通过本题，考察复杂的模意义下的有理数的处理不是我们的本意。\n\n样例中的 $x_i$ 不是随机生成的，仅为理解题意所用。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "追寻 | Pursuit of Dream", "background": "“遇到自己喜欢的人或事情的时候，千万不要放弃”\n\n“要一直追寻下去…”\n\n“因为即使成功希望渺茫，也有可能”\n\n有谁和我说过这句话，脑海中忽然闪过一下，被当做无用的激励一同忘却了。现在想要回忆，却总也记不起来。\n\n好不容易来人间一趟，那就别留下遗憾。\n\n房檐落下的雨滴有规律的敲着石砖，那夜的雨声中，却也悄无声息了。\n\n逆着风吹干眼泪，说不出口的痛越藏越多，腐烂在肚子里，却又不知道彼此心知且肚明，所以无法孕育出美好的结局，只会是恋者相残的戏码不停上演。\n\n---\n\n 看见了漫天星野坠落在你的眼底，从此甘愿在那海底般低压的梦境中堕落。\n\n三千尺星空的光辉映照不出那人的身影，璀璨中徒留神明思故人；那人却散入了或许碎散的星辰大海，让神明寻觅了一生。\n\n那些无法兑现的渴望，会日渐荒芜，然后梦境会失去生机，裂缝中会蔓出黑暗，泪无葬身之地。\n\n是神明告诉我的，可是我不信，因为没有时间还等着我空想了。\n\n神明还说，人死了以后，提前离开的亲人都会在另外一个世界等你。\n\n其实，我也会想，这一定就是另外一个世界。", "description": "在 $n$ 维空间中有一个梦想。这梦想坐落在 $(d_1, d_2, \\ldots, d_n)$ 的地方。而你从 $(0, 0, \\ldots, 0)$ 开始，开启寻梦的旅程。\n\n你的步伐轻缓，每一步只能走一个单位长度。你并不知道你的梦想位于哪里，所以你只能随机选择 $n$ 个正方向中的一个，然后向这个方向走一步。也就是说，在 $[1, n]$ 中均匀随机选择一个正整数 $h$，然后，使你在第 $h$ 维的坐标变成原来的坐标加一。\n\n然而，天有不测风云。在你走每一步的过程中，你会有 $p = \\sum_{i = 1}^k p_i$ 的概率散入天际，并开始一段新的旅程。你会在 $k$ 个地点中的一个重新开始这段旅程，其中第 $i$ 个地点的坐标是 $(a_{i,1}, a_{i,2}, \\ldots, a_{i,n})$，从这里重新开始的概率为 $p_i$。\n\n那么，期望下，你离到达这个梦想还需要多少步呢？", "inputFormat": "第一行，两个正整数 $n,k$。\n\n第二行，$n$ 个非负整数 $d_1, d_2, \\ldots, d_n$。\n\n接下来 $k$ 行，第 $i$ 行 $n + 1$ 个整数 $a_{i, 1}, a_{i, 2}, \\ldots, a_{i, n}, x_i$，每行最后一个整数 $x_i$ 表示 $p_i=x_i\\times 10^{-8}$。\n\n输入的 $x_i$ 保证了 $p_i > 0$ 且 $p < 1$。\n\n保证每个 $x_i$ 在所有可能的组合中等概率随机生成。", "outputFormat": "一行，一个整数，表示答案对 $998244353$ 取模的结果。\n\n如果你不知道如何进行实数取模：可以说明答案一定是有限的，且是有理数，设它的最简分数形式为 $\\frac{p}{q}$。如果存在一个整数 $x$ 满足 $x \\cdot q \\equiv p \\pmod{998244353}$ 且 $0 \\le x < 998244353$，那么你只需输出 $x$ 的值即可。\n\n由于保证了 $x_i$ 是随机生成的，可以说明以接近 $1$ 的概率答案在模意义下存在。事实上，一个当 $x_i$ 尚不确定时以合理地高的概率给出正确答案的算法足以通过本题，考察复杂的模意义下的有理数的处理不是我们的本意。", "hint": "**【样例解释 \\#1】**\n\n这是你的一种追寻梦想的方式：\n\n你从 $(0,0)$ 出发，走一步到 $(1,0)$，再走一步到 $(2,0)$，再走一步到 $(3,0)$，但是在路上散入天际，从 $(0,0)$ 重新开始旅程。\n\n然后继续从 $(0,0)$ 出发，走一步到 $(0,1)$，再走一步到 $(1,1)$，但是在路上散入天际，从 $(0,0)$ 重新开始旅程。\n\n接着从 $(0,0)$ 出发，走一步到 $(1,0)$，再走一步到 $(1,1)$，找到了你的梦想。\n\n在这种情况下，你需要 $7$ 步到达这个梦想。发生这种情况的概率是 $4^{-7}$。\n\n---\n\n**【样例解释 \\#2】**\n\n答案为 $\\frac{505}{24} \\approx 21.041667$。  \n不难验证 $291154624 \\times 24 \\equiv 505 \\pmod{998244353}$，故应输出 $291154624$。\n\n---\n\n**【样例解释 \\#3】**\n\n答案为 $\\frac{1399505}{21519} \\approx 65.035782$。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试且使用子任务依赖。**\n\n| 子任务编号 | 特殊限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 | $n=1$，$k=1$ | 11 |\n| 2 | $n=1$ | 12 |\n| 3 | $k=1$ | 12 |\n| 4 | $n=2$，$1 \\le d_1 \\cdot d_2 \\le 200$ | 13 |\n| 5 | $k \\le 200$ | 22 |\n| 6 | 无特殊限制 | 30 |\n\n对于 $100 \\%$ 的数据：\n\n- $1 \\le n \\le 100$，$1 \\le k \\le 10000$。\n- $d_i \\ge 0$，$\\sum_i d_i \\le 10^7$。\n- $0 \\le a_{i, j} \\le {10}^7$。\n- $x_i \\ge 1$，$\\sum_i x_i < {10}^8$。此即保证了 $p_i > 0$ 和 $p < 1$。\n- 保证存在一个 $i \\in [1, k]$ 使得对于每个 $j \\in [1, n]$ 均有 $a_{i,j} \\le d_j$。\n- 保证每个 $(a_{i, 1}, a_{i, 2}, \\ldots, a_{i, n})$ 作为空间中的点互不相同。\n- 保证每个 $x_i$ 在所有可能的组合中等概率随机生成。\n\n---\n\n**【提示】**\n\n由于保证了 $x_i$ 是随机生成的，可以说明以接近 $1$ 的概率答案在模意义下存在。事实上，一个当 $x_i$ 尚不确定时以合理地高的概率给出正确答案的算法足以通过本题，考察复杂的模意义下的有理数的处理不是我们的本意。\n\n样例中的 $x_i$ 不是随机生成的，仅为理解题意所用。", "locale": "zh-CN"}}}
{"pid": "P8968", "type": "P", "difficulty": 6, "samples": [["5\n1 1 2 2\n1 1 1 1 1\n", "5 4 2 3 3"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["暴力数据结构", "博弈论", "洛谷原创", "O2优化", "洛谷月赛"], "title": "觅光 | Searching for Hope (hard ver.)", "background": "**这是本题的困难版本。两个版本在 $\\bm{100 \\%}$ 数据范围的唯一区别是关于 $\\bm{n}$ 的限制。此版本中 $\\bm{n \\le {10}^6}$。**\n\n---\n\n有梦中所向往的地方，也有现实中可望不可触及的远方。\n\n我们正等待无数次的希望，新的纪元，生命不曾奏响终章。\n\n顷刻间颠覆中的一切，天空坠落到海底，死死卡住呼吸者的全部。羽翼裹满刺骨的海水，悲伤到从此遗忘呼吸的意义。\n\n明明与空气只隔着毫厘，却不想再尝试去呼吸。我开始明白，悲伤到了极点，也许不会流泪\n\n神明借着生的名义，捏造出灰暗的真理。\n\n\n\n泪水模糊眼眶，身躯坠进天空，泛白的天光，不得已照亮这一日的希望。", "description": "现在有一棵 $n$ 个节点的有根二叉树。\n\n凡人与神明在这棵树上进行一个游戏。凡人需要从根投下若干个球，每个球带 $1$ 单位正电荷或带 $1$ 单位负电荷。\n\n树上每一个点有容量，第 $i$ 个点可以容纳 $c_i$ 个球。初始每一个点容纳的球数为 $0$。我们称一个点被充满当且仅当它容纳的球的个数等于它的容量。\n\n每一次一个球下落到一个点时：\n\n- 如果该点没有孩子节点或者所有孩子节点上都已经充满球，则停止，该点容纳的球的个数 $+1$；\n- 如果该点恰有一个孩子节点未充满，则向那个孩子下落；\n- 如果有 $2$ 个孩子节点均未充满：\n\t- 如果左侧子树中所有球的电荷代数和大于右侧子树所有球的电荷代数和，则如果当前球带正电则向右下落，否则向左下落；\n   - 如果左侧子树中所有球的电荷代数和小于右侧子树所有球的电荷代数和，则如果当前球带正电则向左下落，否则向右下落；\n   - 如果左侧子树中所有球的电荷代数和等于右侧子树所有球的电荷代数和，则由神明决定向哪个方向下落。\n\n其中，电荷代数和指的是正电荷的数量减去负电荷的数量。\n\n在游戏开始前，双方约定目标点 $u$。在一个回合中，凡人选择这次投下的球的电性，神明按上述规则控制球的下落过程。当 $u$ 被充满时，游戏结束。\n\n凡人希望游戏回合数尽量少，神明希望游戏回合数尽量多。假设双方足够聪明。\n\n对所有：$1\\leq u\\leq n$，求游戏轮数 $r_u$。", "inputFormat": "第一行，一个正整数 $n$。\n\n第二行，$n-1$ 个整数 $f_2, f_3, \\ldots, f_n$，其中 $f_i$ 代表 $i$ 的父亲的编号。\n\n第三行，$n$ 个整数 $c_1, c_2, \\ldots, c_n$。", "outputFormat": "输出一行，$n$ 个整数 $r_1, r_2, \\ldots, r_n$。", "hint": "**【数据范围】**\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $n \\le$ | 分值 |\n| :----------: | :----------: | :----------: |\n| 4 | ${10}^5$ | 33 |\n| 5 | ${10}^6$ | 67 |\n\n对于 $100\\%$ 的数据，$2 \\le n \\le {10}^6$，满足树是以 $1$ 为根的二叉树，$1 \\le f_i < i$，$1 \\le c_i \\le {10}^{12}$。\n\n---\n\n**【提示】**\n\n本题最大 I/O 量达到 20 MiB，请注意 I/O 效率。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "觅光 | Searching for Hope (hard ver.)", "background": "**这是本题的困难版本。两个版本在 $\\bm{100 \\%}$ 数据范围的唯一区别是关于 $\\bm{n}$ 的限制。此版本中 $\\bm{n \\le {10}^6}$。**\n\n---\n\n有梦中所向往的地方，也有现实中可望不可触及的远方。\n\n我们正等待无数次的希望，新的纪元，生命不曾奏响终章。\n\n顷刻间颠覆中的一切，天空坠落到海底，死死卡住呼吸者的全部。羽翼裹满刺骨的海水，悲伤到从此遗忘呼吸的意义。\n\n明明与空气只隔着毫厘，却不想再尝试去呼吸。我开始明白，悲伤到了极点，也许不会流泪\n\n神明借着生的名义，捏造出灰暗的真理。\n\n\n\n泪水模糊眼眶，身躯坠进天空，泛白的天光，不得已照亮这一日的希望。", "description": "现在有一棵 $n$ 个节点的有根二叉树。\n\n凡人与神明在这棵树上进行一个游戏。凡人需要从根投下若干个球，每个球带 $1$ 单位正电荷或带 $1$ 单位负电荷。\n\n树上每一个点有容量，第 $i$ 个点可以容纳 $c_i$ 个球。初始每一个点容纳的球数为 $0$。我们称一个点被充满当且仅当它容纳的球的个数等于它的容量。\n\n每一次一个球下落到一个点时：\n\n- 如果该点没有孩子节点或者所有孩子节点上都已经充满球，则停止，该点容纳的球的个数 $+1$；\n- 如果该点恰有一个孩子节点未充满，则向那个孩子下落；\n- 如果有 $2$ 个孩子节点均未充满：\n\t- 如果左侧子树中所有球的电荷代数和大于右侧子树所有球的电荷代数和，则如果当前球带正电则向右下落，否则向左下落；\n   - 如果左侧子树中所有球的电荷代数和小于右侧子树所有球的电荷代数和，则如果当前球带正电则向左下落，否则向右下落；\n   - 如果左侧子树中所有球的电荷代数和等于右侧子树所有球的电荷代数和，则由神明决定向哪个方向下落。\n\n其中，电荷代数和指的是正电荷的数量减去负电荷的数量。\n\n在游戏开始前，双方约定目标点 $u$。在一个回合中，凡人选择这次投下的球的电性，神明按上述规则控制球的下落过程。当 $u$ 被充满时，游戏结束。\n\n凡人希望游戏回合数尽量少，神明希望游戏回合数尽量多。假设双方足够聪明。\n\n对所有：$1\\leq u\\leq n$，求游戏轮数 $r_u$。", "inputFormat": "第一行，一个正整数 $n$。\n\n第二行，$n-1$ 个整数 $f_2, f_3, \\ldots, f_n$，其中 $f_i$ 代表 $i$ 的父亲的编号。\n\n第三行，$n$ 个整数 $c_1, c_2, \\ldots, c_n$。", "outputFormat": "输出一行，$n$ 个整数 $r_1, r_2, \\ldots, r_n$。", "hint": "**【数据范围】**\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $n \\le$ | 分值 |\n| :----------: | :----------: | :----------: |\n| 4 | ${10}^5$ | 33 |\n| 5 | ${10}^6$ | 67 |\n\n对于 $100\\%$ 的数据，$2 \\le n \\le {10}^6$，满足树是以 $1$ 为根的二叉树，$1 \\le f_i < i$，$1 \\le c_i \\le {10}^{12}$。\n\n---\n\n**【提示】**\n\n本题最大 I/O 量达到 20 MiB，请注意 I/O 效率。", "locale": "zh-CN"}}}
{"pid": "P8969", "type": "P", "difficulty": 6, "samples": [["5 5\n1 2 3 4 5\nJ 2\nA 2 4 3\nJ 4\nP 1 4\nJ 3\n", "2\n7\n2\n"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "洛谷原创", "O2优化", "洛谷月赛", "均摊分析", "线段树合并"], "title": "幻梦 | Dream with Dynamic", "background": "“那以后见到她，会不会笑出来啊？”\n\n“哈，一时半会见不到她的。”\n\n小时候说要一起去看尘寰间的人间烟火，有人欣然接受，长大了说遗忘过去，那人也没有反驳。\n\n其实吧，她们彼此明白，小时候在意的不是什么人间烟火，而是一起。\n\n黑夜里，没有早晨的绯红，也褪去了天边的白光，留下的是她心头的散不去的灰暗。没有星光璀璨，没有满天繁星，她不在乎。她在乎的是那个人心中闪烁的星辰大海。\n\n----\n\n察觉所谓规则秘密，不过取悦于创世神明，早已知晓光明同黑暗般腥风血雨\n\n", "description": "有一个长度为 $n$ 的序列，开始时第 $i$ 位为 $a_i$。你需要完成 $q$ 次操作：\n\n- `A l r x`，对于所有的 $l\\le i\\le r$，令 $a_i\\gets a_i+x$。\n- `P l r`，对于所有的 $l\\le i\\le r$，令 $a_i\\gets\\operatorname{popcount}(a_i)$。\n- `J p`，查询 $a_p$ 的值。\n\n注：$\\operatorname{popcount}(x)$ 为 $x$ 的二进制表示中 $1$ 的个数。", "inputFormat": "第一行两个正整数 $n,q$。\n\n第二行 $n$ 个正整数 $a_1, a_2, \\ldots, a_n$。\n\n接下来 $q$ 行，每行描述一个操作，形如以下三种中的一种：\n\n- `A l r x`\n- `P l r`\n- `J p`", "outputFormat": "对于每个 `J` 操作，输出一行，一个整数，表示答案。", "hint": "**【样例解释】**\n\n- 开始时，$a = [1, 2, 3, 4, 5]$。\n- 对询问 `J 2`，应回答 $a_2 = 2$。\n- 操作 `A 2 4 3` 后，$a = [1, 5, 6, 7, 5]$。\n- 对询问 `J 4`，应回答 $a_4 = 7$。\n- 操作 `P 1 4` 后，$a = [1, 2, 2, 3, 5]$。\n- 对询问 `J 3`，应回答 $a_3 = 2$。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | 特殊限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 |$n,q\\le 2000$| 3 |\n| 2 |没有 `P` 操作| 7 |\n| 3 |没有 `A` 操作| 15 |\n| 4 |数据随机生成| 15 |\n| 5 |无特殊限制| 60 |\n\n对于全部数据，保证 $1\\leq n\\leq 3\\times 10^5$，$1 \\le q \\le 10^6$，$1 \\le l \\le r \\le n$，$1 \\le p \\le n$，$1\\le a_i, x\\le 10^9$。\n\n子任务 4 的随机方式：\n\n- 取 $n=3\\times 10^5$，$q=10^6$；\n- $a_i$ 从 $[1,10^9]$ 均匀随机选取；\n- 对于每一个操作：\n\t- 从 3 种操作中均匀随机选取一个；\n   - 如果是 `A` 操作，均匀随机从 $[1,n]$ 中选取 2 个整数，将较小的作为区间左端点，较大的作为区间右端点，再从 $[1,10^9]$ 中选取一个整数作为参数 `x`；\n   - 如果是 `P` 操作，均匀随机从 $[1,n]$ 中选取 2 个整数，将较小的作为区间左端点，较大的作为区间右端点；\n   - 如果是 `J` 操作，均匀随机从 $[1,n]$ 中选取一个整数作为参数 `p`。\n\n---\n\n**【提示】**\n\n本题最大 I/O 量达到 30 MiB，请注意 I/O 效率。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "幻梦 | Dream with Dynamic", "background": "“那以后见到她，会不会笑出来啊？”\n\n“哈，一时半会见不到她的。”\n\n小时候说要一起去看尘寰间的人间烟火，有人欣然接受，长大了说遗忘过去，那人也没有反驳。\n\n其实吧，她们彼此明白，小时候在意的不是什么人间烟火，而是一起。\n\n黑夜里，没有早晨的绯红，也褪去了天边的白光，留下的是她心头的散不去的灰暗。没有星光璀璨，没有满天繁星，她不在乎。她在乎的是那个人心中闪烁的星辰大海。\n\n----\n\n察觉所谓规则秘密，不过取悦于创世神明，早已知晓光明同黑暗般腥风血雨\n\n", "description": "有一个长度为 $n$ 的序列，开始时第 $i$ 位为 $a_i$。你需要完成 $q$ 次操作：\n\n- `A l r x`，对于所有的 $l\\le i\\le r$，令 $a_i\\gets a_i+x$。\n- `P l r`，对于所有的 $l\\le i\\le r$，令 $a_i\\gets\\operatorname{popcount}(a_i)$。\n- `J p`，查询 $a_p$ 的值。\n\n注：$\\operatorname{popcount}(x)$ 为 $x$ 的二进制表示中 $1$ 的个数。", "inputFormat": "第一行两个正整数 $n,q$。\n\n第二行 $n$ 个正整数 $a_1, a_2, \\ldots, a_n$。\n\n接下来 $q$ 行，每行描述一个操作，形如以下三种中的一种：\n\n- `A l r x`\n- `P l r`\n- `J p`", "outputFormat": "对于每个 `J` 操作，输出一行，一个整数，表示答案。", "hint": "**【样例解释】**\n\n- 开始时，$a = [1, 2, 3, 4, 5]$。\n- 对询问 `J 2`，应回答 $a_2 = 2$。\n- 操作 `A 2 4 3` 后，$a = [1, 5, 6, 7, 5]$。\n- 对询问 `J 4`，应回答 $a_4 = 7$。\n- 操作 `P 1 4` 后，$a = [1, 2, 2, 3, 5]$。\n- 对询问 `J 3`，应回答 $a_3 = 2$。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | 特殊限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 |$n,q\\le 2000$| 3 |\n| 2 |没有 `P` 操作| 7 |\n| 3 |没有 `A` 操作| 15 |\n| 4 |数据随机生成| 15 |\n| 5 |无特殊限制| 60 |\n\n对于全部数据，保证 $1\\leq n\\leq 3\\times 10^5$，$1 \\le q \\le 10^6$，$1 \\le l \\le r \\le n$，$1 \\le p \\le n$，$1\\le a_i, x\\le 10^9$。\n\n子任务 4 的随机方式：\n\n- 取 $n=3\\times 10^5$，$q=10^6$；\n- $a_i$ 从 $[1,10^9]$ 均匀随机选取；\n- 对于每一个操作：\n\t- 从 3 种操作中均匀随机选取一个；\n   - 如果是 `A` 操作，均匀随机从 $[1,n]$ 中选取 2 个整数，将较小的作为区间左端点，较大的作为区间右端点，再从 $[1,10^9]$ 中选取一个整数作为参数 `x`；\n   - 如果是 `P` 操作，均匀随机从 $[1,n]$ 中选取 2 个整数，将较小的作为区间左端点，较大的作为区间右端点；\n   - 如果是 `J` 操作，均匀随机从 $[1,n]$ 中选取一个整数作为参数 `p`。\n\n---\n\n**【提示】**\n\n本题最大 I/O 量达到 30 MiB，请注意 I/O 效率。", "locale": "zh-CN"}}}
{"pid": "P8970", "type": "P", "difficulty": 7, "samples": [["1 1\n1 1\n", "1\n"], ["3 2\n1 2\n1 3\n2 1\n111111 1111111\n3 45\n", "2\n"], ["4 2\n1 2\n1 3\n2 4\n3 1\n2 1\n1 1\n1 2\n", "2\n"]], "limits": {"time": [600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "O2优化", "分治", "树形 DP", "洛谷月赛", "状压 DP"], "title": "宿命 | Regulation of Destiny", "background": "压抑是有实质的，从躯壳到内脏，密不透风地包裹，药物仅仅像缝隙里挤进去的一滴水，浇不灭深幽的火焰。\n\n时间治愈不了一切，它只把泥泞日复一日地堆积。她的眼睛没有焦点，偶尔仿佛睡梦中惊醒，喊我的名字。\n\n街道乱糟糟，各家店铺放着音乐，公交车轮胎碾过柏油路，小孩打闹，玻璃瓶砸碎，电瓶车相撞……但我清楚地听见自己的呼吸声。后视镜里，我又一次看到她没有焦点的眼神，裹住眼球的眼泪，水的表面张力“嗒”的一声失效。\n\n\n撕开雨天，潜入他乡，所向往的尽头是天堂。\n\n浅蓝天光，云层泛紫，微弱的灯光嵌进夕阳。\n \n----\n \n \n “…你知道吗，所谓的力量，其实，就是心中的执念。”\n \n “执念？”\n \n “是啊…就是，必须要做的事，必须守护的人，必须…”\n \n “实现的心愿。”\n \n “那么…你心中有这样的执念吗？”\n \n “呃……有啊！我的执念，就是保护姐姐！”\n \n “傻小子，想保护你姐，等下辈子再说吧”\n \n", "description": "A 国为了防御 B 国的进攻，准备兴建一系列防御措施。\n\nA 国有 $n$ 艘恒星级战舰，这些战舰无论如何都是要被保护的。为了节省材料，总司令用了 $n-1$ 条双向加速通道将这些战舰连接了起来。每个战舰有两个属性 $a_i,b_i$，分别代表战舰的人口数，科技程度。\n\n在每艘战舰上有两种防御措施可以选择。你可以选择建设其中的一种，也可以选择不建设，但不能两种都建设。\n\n在 $i$ 号战舰上建设 I 类防御措施需要 $a_i$ 的金钱，可以保护 $i$ 号战舰本身和与其直接相连的战舰。\n\n在 $i$ 号战舰上建设 II 类防御措施需要 $b_i$ 的金钱，可以保护 $i$ 号战舰本身以及所有与 $i$ 号战舰的距离**恰好**为 $r$ 的战舰。\n\n定义战舰 $u$ 和战舰 $v$ 的距离为从 $u$ 到 $v$ 需要经过最少多少条加速通道。\n\n现在，请你求出保护所有战舰需要的最少金钱。", "inputFormat": "第一行，两个正整数 $n, r$。\n\n接下来 $n-1$ 行，每行两个正整数 $u, v$，代表一条通道所连接的两艘战舰编号为 $u, v$。\n\n接下来 $n$ 行，第 $i$ 行两个正整数 $a_i, b_i$，分别表示在 $i$ 号战舰上建设 I 类和 II 类防御措施所需要的金钱。", "outputFormat": "一行，一个整数，表示保护所有战舰需要的最少金钱。", "hint": "**【样例解释 \\#1】**\n\n在 $1$ 号战舰上建设任意一种防御措施，所花金钱为 $1$。\n\n---\n\n**【样例解释 \\#2】**\n\n在 $1$ 号战舰上建设 I 类防御措施，所花金钱为 $2$。\n\n---\n\n**【样例解释 \\#3】**\n\n在 $1,2$ 号战舰上各建设一个 II 类防御措施，所花金钱为 $2$。\n\n------------\n\n**【数据范围】**\n\n**本题采用捆绑测试且使用子任务依赖。**\n\n| 子任务编号 | $n \\le$ | $r \\le$ | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| 1 | $10$ | $5$ | 5 |\n| 2 | $200$ | $1$ | 5 |\n| 3 | $20$ | $7$ | 10 |\n| 4 | $100$ | $2$ | 8 |\n| 5 | $100$ | $4$ | 11 |\n| 6 | $100$ | $5$ | 8 |\n| 7 | $200$ | $6$ | 34 |\n| 8 | $200$ | $7$ | 19 |\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 200$，$1 \\le r \\le 7$，$1 \\le a_i, b_i \\le {10}^9$，$1 \\le u, v \\le n$，保证任意两艘战舰可以通过若干条加速通道到达。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "宿命 | Regulation of Destiny", "background": "压抑是有实质的，从躯壳到内脏，密不透风地包裹，药物仅仅像缝隙里挤进去的一滴水，浇不灭深幽的火焰。\n\n时间治愈不了一切，它只把泥泞日复一日地堆积。她的眼睛没有焦点，偶尔仿佛睡梦中惊醒，喊我的名字。\n\n街道乱糟糟，各家店铺放着音乐，公交车轮胎碾过柏油路，小孩打闹，玻璃瓶砸碎，电瓶车相撞……但我清楚地听见自己的呼吸声。后视镜里，我又一次看到她没有焦点的眼神，裹住眼球的眼泪，水的表面张力“嗒”的一声失效。\n\n\n撕开雨天，潜入他乡，所向往的尽头是天堂。\n\n浅蓝天光，云层泛紫，微弱的灯光嵌进夕阳。\n \n----\n \n \n “…你知道吗，所谓的力量，其实，就是心中的执念。”\n \n “执念？”\n \n “是啊…就是，必须要做的事，必须守护的人，必须…”\n \n “实现的心愿。”\n \n “那么…你心中有这样的执念吗？”\n \n “呃……有啊！我的执念，就是保护姐姐！”\n \n “傻小子，想保护你姐，等下辈子再说吧”\n \n", "description": "A 国为了防御 B 国的进攻，准备兴建一系列防御措施。\n\nA 国有 $n$ 艘恒星级战舰，这些战舰无论如何都是要被保护的。为了节省材料，总司令用了 $n-1$ 条双向加速通道将这些战舰连接了起来。每个战舰有两个属性 $a_i,b_i$，分别代表战舰的人口数，科技程度。\n\n在每艘战舰上有两种防御措施可以选择。你可以选择建设其中的一种，也可以选择不建设，但不能两种都建设。\n\n在 $i$ 号战舰上建设 I 类防御措施需要 $a_i$ 的金钱，可以保护 $i$ 号战舰本身和与其直接相连的战舰。\n\n在 $i$ 号战舰上建设 II 类防御措施需要 $b_i$ 的金钱，可以保护 $i$ 号战舰本身以及所有与 $i$ 号战舰的距离**恰好**为 $r$ 的战舰。\n\n定义战舰 $u$ 和战舰 $v$ 的距离为从 $u$ 到 $v$ 需要经过最少多少条加速通道。\n\n现在，请你求出保护所有战舰需要的最少金钱。", "inputFormat": "第一行，两个正整数 $n, r$。\n\n接下来 $n-1$ 行，每行两个正整数 $u, v$，代表一条通道所连接的两艘战舰编号为 $u, v$。\n\n接下来 $n$ 行，第 $i$ 行两个正整数 $a_i, b_i$，分别表示在 $i$ 号战舰上建设 I 类和 II 类防御措施所需要的金钱。", "outputFormat": "一行，一个整数，表示保护所有战舰需要的最少金钱。", "hint": "**【样例解释 \\#1】**\n\n在 $1$ 号战舰上建设任意一种防御措施，所花金钱为 $1$。\n\n---\n\n**【样例解释 \\#2】**\n\n在 $1$ 号战舰上建设 I 类防御措施，所花金钱为 $2$。\n\n---\n\n**【样例解释 \\#3】**\n\n在 $1,2$ 号战舰上各建设一个 II 类防御措施，所花金钱为 $2$。\n\n------------\n\n**【数据范围】**\n\n**本题采用捆绑测试且使用子任务依赖。**\n\n| 子任务编号 | $n \\le$ | $r \\le$ | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| 1 | $10$ | $5$ | 5 |\n| 2 | $200$ | $1$ | 5 |\n| 3 | $20$ | $7$ | 10 |\n| 4 | $100$ | $2$ | 8 |\n| 5 | $100$ | $4$ | 11 |\n| 6 | $100$ | $5$ | 8 |\n| 7 | $200$ | $6$ | 34 |\n| 8 | $200$ | $7$ | 19 |\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 200$，$1 \\le r \\le 7$，$1 \\le a_i, b_i \\le {10}^9$，$1 \\le u, v \\le n$，保证任意两艘战舰可以通过若干条加速通道到达。", "locale": "zh-CN"}}}
{"pid": "P8971", "type": "P", "difficulty": 4, "samples": [["2\n6 0 4\n1 1 2 2\n1 2 3 4\n1 3 4 2\n0 2 5\n1 4 6 3\n\n6 -1 4\n1 1 2 4\n0 2 3\n0 3 4\n0 2 5\n0 4 6", "5\n6480"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "O2优化", "图遍历"], "title": "『GROI-R1』 虹色的彼岸花", "background": "少年身着春季校服的深灰色外套与黑色短裤，外套内是白净的衬衫。\n\n他的右手不知为何缠着绷带，右眼用头发挡得严严实实，扑面而来的是一种神秘感。\n\n一瓣鲜红的彼岸花，在教室上空无人在意之处打旋。\n\n玘的身世，总是一个谜题吧。\n\n「所以你到底是什么人，又为什么要来这里！」\n\n可是彼岸花显然不想让你知道这些。", "description": "玘给了寒一棵编号为 $1\\sim n$ 的树，这棵树上每个点都有一个点权，同时有些边有边权，有些边没有边权。可是玘把每一个点的点权删除了。寒只知道****点权都是整数，而且在 $l$ 和 $r$ 之间（包含端点）****。而且，点权和边权有着下面的特殊关系：\n\n- 对于****有边权****的边，要求****连接的两个点的点权和为边权****。\n\n- 对于****没有边权的边****，****无限制****。\n\n玘问寒这棵树****有多少种不同的点权填写方式****。两种填写方式不同，当且仅当至少存在一个点的点权不同。可是寒不会做这个题。\n\n寒请你解决这个问题。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $T$，代表测试数据组数。\n\n对于每一组测试数据：\n\n第一行三个整数 $n,l,r$，代表树上点的个数是 $n$，点权的范围是 $[l,r]$。\n \n接下来 $n-1$ 行，每行先输入一个整数 $op$，$op=0$ 表示这条边没有边权，$op=1$ 表示这条边有边权。\n\n+ 如果 $op=0$，再输入两个整数 $u,v$，表示这条边连接 $u,v$ 两个点。\n\n+ 如果 $op=1$，再输入三个整数 $u,v,w$，表示有一条权值为 $w$ 的边连接 $u,v$ 两个点。", "outputFormat": "对于每个测试点，输出一行一个整数，代表点权填写方式的个数。答案对 $10^9+7$ 取模。", "hint": "**样例解释**\n\n对于样例的第一组测试数据，可以得到下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/91vlqt5k.png)\n\n$5$ 种填写方式分别为：\n\n$\\{0,2,2,0,0,3\\}\\\\\\{0,2,2,0,1,3\\}\\\\\\{0,2,2,0,2,3\\}\\\\\\{0,2,2,0,3,3\\}\\\\\\{0,2,2,0,4,3\\}$\n\n可以证明，不存在别的填写方式。\n\n样例输入中，为了直观，添加了空行。实际数据中不存在多余空行。\n\n**数据范围**\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | 数据范围 | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $\\text{Subtask1}$ | $1\\le n\\le 10$，$0\\le l,r\\le5$ |  | $15$ |\n| $\\text{Subtask2}$ | $1\\le n\\le 2\\times 10^5$，$0\\le l,r\\le5$ |  | $20$ |\n| $\\text{Subtask3}$ | $1\\le n\\le 10$，$-10^9\\le l,r\\le 10^9$ |  | $15$ |\n| $\\text{Subtask4}$ | $1\\le n\\le 2\\times10^5$，$-10^9\\le l,r\\le 10^9$ | 有 | $10$ |\n| $\\text{Subtask5}$ | $1\\le n\\le 2\\times10^5$，$-10^9\\le l,r\\le 10^9$ |  | $40$ |\n\n特殊性质：保证每条边都无边权。\n\n对于 $100\\%$ 的数据，保证 $1\\le T \\le 5$，$1\\le n\\le 2\\times10^5$，$1\\le \\sum n\\le 10^6$，$-10^9\\le l\\le r \\le 10^9$，$-10^9\\le w\\le 10^9$，$op\\in\\{0,1\\}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『GROI-R1』 虹色的彼岸花", "background": "少年身着春季校服的深灰色外套与黑色短裤，外套内是白净的衬衫。\n\n他的右手不知为何缠着绷带，右眼用头发挡得严严实实，扑面而来的是一种神秘感。\n\n一瓣鲜红的彼岸花，在教室上空无人在意之处打旋。\n\n玘的身世，总是一个谜题吧。\n\n「所以你到底是什么人，又为什么要来这里！」\n\n可是彼岸花显然不想让你知道这些。", "description": "玘给了寒一棵编号为 $1\\sim n$ 的树，这棵树上每个点都有一个点权，同时有些边有边权，有些边没有边权。可是玘把每一个点的点权删除了。寒只知道****点权都是整数，而且在 $l$ 和 $r$ 之间（包含端点）****。而且，点权和边权有着下面的特殊关系：\n\n- 对于****有边权****的边，要求****连接的两个点的点权和为边权****。\n\n- 对于****没有边权的边****，****无限制****。\n\n玘问寒这棵树****有多少种不同的点权填写方式****。两种填写方式不同，当且仅当至少存在一个点的点权不同。可是寒不会做这个题。\n\n寒请你解决这个问题。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $T$，代表测试数据组数。\n\n对于每一组测试数据：\n\n第一行三个整数 $n,l,r$，代表树上点的个数是 $n$，点权的范围是 $[l,r]$。\n \n接下来 $n-1$ 行，每行先输入一个整数 $op$，$op=0$ 表示这条边没有边权，$op=1$ 表示这条边有边权。\n\n+ 如果 $op=0$，再输入两个整数 $u,v$，表示这条边连接 $u,v$ 两个点。\n\n+ 如果 $op=1$，再输入三个整数 $u,v,w$，表示有一条权值为 $w$ 的边连接 $u,v$ 两个点。", "outputFormat": "对于每个测试点，输出一行一个整数，代表点权填写方式的个数。答案对 $10^9+7$ 取模。", "hint": "**样例解释**\n\n对于样例的第一组测试数据，可以得到下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/91vlqt5k.png)\n\n$5$ 种填写方式分别为：\n\n$\\{0,2,2,0,0,3\\}\\\\\\{0,2,2,0,1,3\\}\\\\\\{0,2,2,0,2,3\\}\\\\\\{0,2,2,0,3,3\\}\\\\\\{0,2,2,0,4,3\\}$\n\n可以证明，不存在别的填写方式。\n\n样例输入中，为了直观，添加了空行。实际数据中不存在多余空行。\n\n**数据范围**\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | 数据范围 | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $\\text{Subtask1}$ | $1\\le n\\le 10$，$0\\le l,r\\le5$ |  | $15$ |\n| $\\text{Subtask2}$ | $1\\le n\\le 2\\times 10^5$，$0\\le l,r\\le5$ |  | $20$ |\n| $\\text{Subtask3}$ | $1\\le n\\le 10$，$-10^9\\le l,r\\le 10^9$ |  | $15$ |\n| $\\text{Subtask4}$ | $1\\le n\\le 2\\times10^5$，$-10^9\\le l,r\\le 10^9$ | 有 | $10$ |\n| $\\text{Subtask5}$ | $1\\le n\\le 2\\times10^5$，$-10^9\\le l,r\\le 10^9$ |  | $40$ |\n\n特殊性质：保证每条边都无边权。\n\n对于 $100\\%$ 的数据，保证 $1\\le T \\le 5$，$1\\le n\\le 2\\times10^5$，$1\\le \\sum n\\le 10^6$，$-10^9\\le l\\le r \\le 10^9$，$-10^9\\le w\\le 10^9$，$op\\in\\{0,1\\}$。", "locale": "zh-CN"}}}
{"pid": "P8972", "type": "P", "difficulty": 4, "samples": [["5 3\n1 2 3 4 5\n1 2 0.1\n2 3 0.20\n3 4 0.5\n2 5 0.99\n1 5\n1 4\n4 3", "No\nNo\nYes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "O2优化", "最近公共祖先 LCA"], "title": "『GROI-R1』 一切都已过去", "background": "悦关上窗，拉上帘布。\n\n果然还是想不起来啊。\n\n隐约记得曾和什么人一起做过这样的事。\n\n仰面躺下，手执一只木笺。\n\n「究竟如何，才能拥有“过去”啊……」\n\n她闭上双眼。\n\n「6 岁前的记忆……究竟如何才能寻回？」", "description": "悦正在寻找她的记忆。忽然，她来到了有 $n$ 个节点的一棵树上。树上每一条边都有各自边权，每一个点都有各自的点权。\n\n「把经历都聚拢起来，能完整地复原吗……」\n\n悦从树上的一个点，慢慢地走到了另一个点，可是她什么也没找到。但是，她不知道，玘一直在远处望着她走过的道路。\n\n玘发现，悦全程****没有走回头路****。他想把悦****走过的每一条边的边权乘起来****，可惜他发现他遇到了一个这一生未曾见到过的数字。\n\n「为什么会这样呢？」\n\n玘想到悦是突然出现在树上的，最初的点一定有蹊跷！他****把最初那个点的点权乘上****……\n\n突然，一束彼岸花的红光亮起！世界重新安静了下来。\n\n悦看到了玘留下的字样，可惜她不能从中看出任何过去的记忆。现在，你要帮她判断：把经历都聚拢起来，****能完整地复原过去吗****？我们称悦的一条路径能“复原过去”，当且仅当玘****留下的乘积是一个整数****。\n\n**形式化题面**\n\n给定一棵 $n$ 个节点的树和 $q$ 次询问。每次询问给出两个整数 $x,y$，表示询问树上以 $x$ 和 $y$ 为端点的简单路径上边权乘积与点 $x$ 的点权相乘是否为整数。", "inputFormat": "第一行两个正整数 $n$ 和 $q$，表示树上有 $n$ 个节点编号为 $1\\sim n$，悦在树上走了 $q$ 条路径。\n\n接下来一行 $n$ 个非负整数表示每个点的点权 $a_i$。\n\n接下来 $n-1$ 行每行两个正整数 $u,v$ 和一个非负实数 $w$ 表示 $u,v$ 间有一条边权为 $w$ 的边。\n\n接下来 $q$ 行，每行两个正整数 $x,y$，表示悦从点 $x$ 开始走到了点 $y$。", "outputFormat": "对于悦的每一次询问，你需要输出一行一个字符串。如果悦能够成功复原她的过去，请输出 `Yes`，否则请输出 `No`。", "hint": "**样例解释**\n\n根据输入可以得到下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3e4jqu6f.png)\n\n对于第一个询问 $(1,5)$ 可以发现悦经过的边的边权分别是 $0.1$ 和 $0.99$，她出发的 $1$ 号点的点权为 $1$。$1\\times0.1\\times0.99=0.099$ 不是整数。所以输出 `No`。\n\n对于后面两次询问同理。\n\n**数据范围**\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | 数据范围 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| $\\text{Subtask1}$ | $n,q\\le3\\times 10^3$ |  | $15$ |\n| $\\text{Subtask2}$ | $n\\le500$，$q\\le10^5$ |  | $10$ |\n| $\\text{Subtask3}$ | $n,q\\le10^5$ | $\\text{BE}$ | $10$ |\n| $\\text{Subtask4}$ | $n,q\\le10^5$ | $\\text{A}$ | $5$ |\n| $\\text{Subtask5}$ | $n,q\\le10^5$ | $\\text{B}$ | $10$ |\n| $\\text{Subtask6}$ | $n,q\\le10^5$ | $\\text{C}$ | $5$ |\n| $\\text{Subtask7}$ | $n,q\\le10^5$ | $\\text{D}$ | $10$ |\n| $\\text{Subtask8}$ | $n,q\\le2×10^5$ |  | $35$ |\n\n特殊性质 $\\text{A}$：保证树退化成一条链。\n\n特殊性质 $\\text{B}$：保证树随机生成（即对于每一个节点随机选择它的父亲节点）。\n\n特殊性质 $\\text{C}$：保证 $w\\in\\{0.1,0.3,0.5,0.7,0.9\\}$。\n\n特殊性质 $\\text{D}$：保证 $w\\in\\{0.1,0.2,0.3,0.4,0.6,0.7,0.8,0.9\\}$。\n\n特殊性质 $\\text{E}$：保证 $w\\le2$ 且 $w$ 小数位数不超过 $1$ 位。\n\n对于 $100\\%$ 的数据满足 $1\\le n,q\\le2\\times10^5$，$0\\le a_i\\le10^9$，$0\\le w\\le10^4$，$1\\le u,v,x,y\\le n$，$x\\ne y$，$w$ 小数位数不超过 $4$ 位。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『GROI-R1』 一切都已过去", "background": "悦关上窗，拉上帘布。\n\n果然还是想不起来啊。\n\n隐约记得曾和什么人一起做过这样的事。\n\n仰面躺下，手执一只木笺。\n\n「究竟如何，才能拥有“过去”啊……」\n\n她闭上双眼。\n\n「6 岁前的记忆……究竟如何才能寻回？」", "description": "悦正在寻找她的记忆。忽然，她来到了有 $n$ 个节点的一棵树上。树上每一条边都有各自边权，每一个点都有各自的点权。\n\n「把经历都聚拢起来，能完整地复原吗……」\n\n悦从树上的一个点，慢慢地走到了另一个点，可是她什么也没找到。但是，她不知道，玘一直在远处望着她走过的道路。\n\n玘发现，悦全程****没有走回头路****。他想把悦****走过的每一条边的边权乘起来****，可惜他发现他遇到了一个这一生未曾见到过的数字。\n\n「为什么会这样呢？」\n\n玘想到悦是突然出现在树上的，最初的点一定有蹊跷！他****把最初那个点的点权乘上****……\n\n突然，一束彼岸花的红光亮起！世界重新安静了下来。\n\n悦看到了玘留下的字样，可惜她不能从中看出任何过去的记忆。现在，你要帮她判断：把经历都聚拢起来，****能完整地复原过去吗****？我们称悦的一条路径能“复原过去”，当且仅当玘****留下的乘积是一个整数****。\n\n**形式化题面**\n\n给定一棵 $n$ 个节点的树和 $q$ 次询问。每次询问给出两个整数 $x,y$，表示询问树上以 $x$ 和 $y$ 为端点的简单路径上边权乘积与点 $x$ 的点权相乘是否为整数。", "inputFormat": "第一行两个正整数 $n$ 和 $q$，表示树上有 $n$ 个节点编号为 $1\\sim n$，悦在树上走了 $q$ 条路径。\n\n接下来一行 $n$ 个非负整数表示每个点的点权 $a_i$。\n\n接下来 $n-1$ 行每行两个正整数 $u,v$ 和一个非负实数 $w$ 表示 $u,v$ 间有一条边权为 $w$ 的边。\n\n接下来 $q$ 行，每行两个正整数 $x,y$，表示悦从点 $x$ 开始走到了点 $y$。", "outputFormat": "对于悦的每一次询问，你需要输出一行一个字符串。如果悦能够成功复原她的过去，请输出 `Yes`，否则请输出 `No`。", "hint": "**样例解释**\n\n根据输入可以得到下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3e4jqu6f.png)\n\n对于第一个询问 $(1,5)$ 可以发现悦经过的边的边权分别是 $0.1$ 和 $0.99$，她出发的 $1$ 号点的点权为 $1$。$1\\times0.1\\times0.99=0.099$ 不是整数。所以输出 `No`。\n\n对于后面两次询问同理。\n\n**数据范围**\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | 数据范围 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| $\\text{Subtask1}$ | $n,q\\le3\\times 10^3$ |  | $15$ |\n| $\\text{Subtask2}$ | $n\\le500$，$q\\le10^5$ |  | $10$ |\n| $\\text{Subtask3}$ | $n,q\\le10^5$ | $\\text{BE}$ | $10$ |\n| $\\text{Subtask4}$ | $n,q\\le10^5$ | $\\text{A}$ | $5$ |\n| $\\text{Subtask5}$ | $n,q\\le10^5$ | $\\text{B}$ | $10$ |\n| $\\text{Subtask6}$ | $n,q\\le10^5$ | $\\text{C}$ | $5$ |\n| $\\text{Subtask7}$ | $n,q\\le10^5$ | $\\text{D}$ | $10$ |\n| $\\text{Subtask8}$ | $n,q\\le2×10^5$ |  | $35$ |\n\n特殊性质 $\\text{A}$：保证树退化成一条链。\n\n特殊性质 $\\text{B}$：保证树随机生成（即对于每一个节点随机选择它的父亲节点）。\n\n特殊性质 $\\text{C}$：保证 $w\\in\\{0.1,0.3,0.5,0.7,0.9\\}$。\n\n特殊性质 $\\text{D}$：保证 $w\\in\\{0.1,0.2,0.3,0.4,0.6,0.7,0.8,0.9\\}$。\n\n特殊性质 $\\text{E}$：保证 $w\\le2$ 且 $w$ 小数位数不超过 $1$ 位。\n\n对于 $100\\%$ 的数据满足 $1\\le n,q\\le2\\times10^5$，$0\\le a_i\\le10^9$，$0\\le w\\le10^4$，$1\\le u,v,x,y\\le n$，$x\\ne y$，$w$ 小数位数不超过 $4$ 位。", "locale": "zh-CN"}}}
{"pid": "P8973", "type": "P", "difficulty": 5, "samples": [["4\n1 2\n2 3\n2 4", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "数学", "图论", "线段树", "点分治", "O2优化", "树形 DP"], "title": "『GROI-R1』 继续深潜，为了同一个梦想", "background": "玘正在折叠床脚几件刚洗净的白衬衫，他注意到身后的声响，向右后转头看去。\n\n以为是“外面的家伙”的他并没有刻意去遮掩自己的右眼——毕竟学院里的人不可能进来。\n\n他看见了那个紫眸的少年；当然寒也看见了那一瞬间的鲜红。\n\n「你什么都没看见。」\n\n玘装作欣赏窗外的晚霞。", "description": "「世上没有无价的情报，」玘露出一丝满意的微笑。\n\n「你懂我的意思吧？」\n\n寒收回手。\n\n玘给出了他留给寒的题。\n\n> 既然紫堇和彼岸花给予了我们异色的瞳孔，我们理所应当是连接在一起的。我称**一棵树上的一个点集是“连接的”**，当且仅当**树上存在一条链能够覆盖这个点集并且这个集合大小不小于 $2$**。我们是独一无二的，可是你知道，一棵树，总是连起来的啊。\n\n「然后呢？」\n\n「现在，你需要告诉我每个点被多少个这样的点集所包含。」\n\n\n玘飘然而去。\n\n湖底之城那封存已久的记忆，被彼岸花和紫堇的力量，揭开了封印的一角。", "inputFormat": "第一行一个正整数 $n$ 表示这棵树有 $n$ 个点编号为 $1\\sim n$。\n\n接下来 $n-1$ 行，每行两个正整数 $u,v$ 描述一条边。", "outputFormat": "为了防止输出量过大，本题采用以下的输出方式。\n\n设 $ans_i$ 为包含 $i$ 号节点的连接的集合的个数对 $10^9+7$ 取模得到的值，你需要输出 $\\operatorname{xor}_{i=1}^n ans_i\\times i$ 的值。注意这里没有取模运算。", "hint": "**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rl9wkbww.png)\n\n**连接**的集合有以下一些：\n- $\\{1,2\\}$\n- $\\{1,3\\}$\n- $\\{1,4\\}$\n- $\\{2,3\\}$\n- $\\{2,4\\}$\n- $\\{3,4\\}$\n- $\\{1,2,3\\}$\n- $\\{1,2,4\\}$\n- $\\{2,3,4\\}$\n\n如 $\\{1,3,4\\}$ 就不是一个连接的集合，因为你找不出一条链使得 $\\{1,3,4\\}$ 为它的子集。\n\n其中 $1,2,3,4$ 号节点分别在 $5,6,5,5$ 个集合中出现。通过计算可得 $\\operatorname{xor}_{i=1}^n ans_i\\times i=18$。\n\n**数据范围**\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | 数据范围 | 特殊性质 | 分值 | 时间限制 |\n| :----------: | :----------: | :----------: | :----------: | :-: |\n| $\\text{Subtask1}$ | $n\\le20$ | | $15$ | $\\text{1s}$ |\n| $\\text{Subtask2}$ | $n\\le100$ | | $15$  | $\\text{1s}$ |\n| $\\text{Subtask3}$ | $n\\le3\\times 10^3$ | | $20$ | $\\text{1s}$ |\n| $\\text{Subtask4}$ | $n\\le5\\times10^5$ | $\\text{A}$ | $15$ | $\\text{2s}$ |\n| $\\text{Subtask5}$ | $n\\le5\\times10^5$ | | $35$ | $\\text{2s}$ |\n\n特殊性质 $\\text{A}$：保证树退化成一条链。\n\n\n对于 $100\\%$ 的数据 $1\\le u,v\\le n\\le5\\times10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『GROI-R1』 继续深潜，为了同一个梦想", "background": "玘正在折叠床脚几件刚洗净的白衬衫，他注意到身后的声响，向右后转头看去。\n\n以为是“外面的家伙”的他并没有刻意去遮掩自己的右眼——毕竟学院里的人不可能进来。\n\n他看见了那个紫眸的少年；当然寒也看见了那一瞬间的鲜红。\n\n「你什么都没看见。」\n\n玘装作欣赏窗外的晚霞。", "description": "「世上没有无价的情报，」玘露出一丝满意的微笑。\n\n「你懂我的意思吧？」\n\n寒收回手。\n\n玘给出了他留给寒的题。\n\n> 既然紫堇和彼岸花给予了我们异色的瞳孔，我们理所应当是连接在一起的。我称**一棵树上的一个点集是“连接的”**，当且仅当**树上存在一条链能够覆盖这个点集并且这个集合大小不小于 $2$**。我们是独一无二的，可是你知道，一棵树，总是连起来的啊。\n\n「然后呢？」\n\n「现在，你需要告诉我每个点被多少个这样的点集所包含。」\n\n\n玘飘然而去。\n\n湖底之城那封存已久的记忆，被彼岸花和紫堇的力量，揭开了封印的一角。", "inputFormat": "第一行一个正整数 $n$ 表示这棵树有 $n$ 个点编号为 $1\\sim n$。\n\n接下来 $n-1$ 行，每行两个正整数 $u,v$ 描述一条边。", "outputFormat": "为了防止输出量过大，本题采用以下的输出方式。\n\n设 $ans_i$ 为包含 $i$ 号节点的连接的集合的个数对 $10^9+7$ 取模得到的值，你需要输出 $\\operatorname{xor}_{i=1}^n ans_i\\times i$ 的值。注意这里没有取模运算。", "hint": "**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rl9wkbww.png)\n\n**连接**的集合有以下一些：\n- $\\{1,2\\}$\n- $\\{1,3\\}$\n- $\\{1,4\\}$\n- $\\{2,3\\}$\n- $\\{2,4\\}$\n- $\\{3,4\\}$\n- $\\{1,2,3\\}$\n- $\\{1,2,4\\}$\n- $\\{2,3,4\\}$\n\n如 $\\{1,3,4\\}$ 就不是一个连接的集合，因为你找不出一条链使得 $\\{1,3,4\\}$ 为它的子集。\n\n其中 $1,2,3,4$ 号节点分别在 $5,6,5,5$ 个集合中出现。通过计算可得 $\\operatorname{xor}_{i=1}^n ans_i\\times i=18$。\n\n**数据范围**\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | 数据范围 | 特殊性质 | 分值 | 时间限制 |\n| :----------: | :----------: | :----------: | :----------: | :-: |\n| $\\text{Subtask1}$ | $n\\le20$ | | $15$ | $\\text{1s}$ |\n| $\\text{Subtask2}$ | $n\\le100$ | | $15$  | $\\text{1s}$ |\n| $\\text{Subtask3}$ | $n\\le3\\times 10^3$ | | $20$ | $\\text{1s}$ |\n| $\\text{Subtask4}$ | $n\\le5\\times10^5$ | $\\text{A}$ | $15$ | $\\text{2s}$ |\n| $\\text{Subtask5}$ | $n\\le5\\times10^5$ | | $35$ | $\\text{2s}$ |\n\n特殊性质 $\\text{A}$：保证树退化成一条链。\n\n\n对于 $100\\%$ 的数据 $1\\le u,v\\le n\\le5\\times10^5$。", "locale": "zh-CN"}}}
{"pid": "P8974", "type": "P", "difficulty": 6, "samples": [["4 2\n1 2\n1 3\n1 4\n2 3\n1 4", "4\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "图论", "O2优化", "最近公共祖先 LCA", "基环树"], "title": "『GROI-R1』 古朴而优雅", "background": "\n会馆内忽地安静了下来。\n\n「敝姓言，名杉。」\n\n他的声音沉稳而凝重，略带沙哑，却不失力度，极具穿透力。每个字都重重地打在耳畔，渗进头脑里，让人想不认真听都难。\n\n「这所学院的院长。」", "description": "杉虽然年事已高，但是还是保持与时俱进。他学习了深度优先遍历算法，觉得这种新潮的东西在一所古朴而优雅的学院里会很受欢迎。所以，他找到了在走廊里晃荡的寒，向他提出了一个问题：\n\n「我们知道，对一棵树进行深度优先遍历可以用下面的伪代码很好地解决。」\n\n$$\n\\begin{array}{l}\n\\text{DFS-TREE}(u)\\\\\n\\begin{array}{ll}\n1 & p\\gets p+1\\\\\n2 & t_p\\gets u\\\\\n3 & vis_u\\gets 1\\\\\n4 & \\textbf{for }\\text{each edge }(u,v)\\in E \\\\\n5 & \\qquad \\textbf{if }vis_v=0\\\\\n6 & \\qquad \\qquad \\text{DFS-TREE}(v)\\\\\n7 & p\\gets p+1\\\\\n8 & t_p\\gets u\\\\\n\\end{array}\n\\end{array}\n$$\n\n起初，所有变量或数组的值均为 $0$。\n\n「我们把调用 $\\text{DFS-TREE}(1)$ 在遍历过程中得到的数组 $t$ 称为这棵树的**遍历顺序**。」\n\n「你看这段代码的第 $4$ 行，这句话**遍历每一条边的顺序是不固定的**。」\n\n寒素来最讨厌不确定的东西，可是碍于院长的颜面，还是继续听下去。\n\n「你能数出这段代码**会生成多少种不同的遍历顺序**吗？」\n\n寒发现他曾经做过这个题，很快地报出了解法。本以为就结束了，可是杉继续说：\n\n「如果我**在树上增加一条边**，你还会做吗？」\n\n寒发现他的那点水平完全不够了，于是他去请教玘。玘却认为这道题目依然很简单，他告诉了寒这道题的做法。可是寒找不到杉了。\n\n这个世界到底怎么了呢？", "inputFormat": "第一行，两个整数 $n$ 和 $q$，表示树上有 $n$ 个结点，编号为 $1\\sim n$，有 $q$ 次询问。\n\n接下来 $n-1$ 行，每行两个整数 $u,v$，描述这棵树上的一条边。\n\n接下来 $q$ 行，每行两个整数 $x,y$，表示在树上添加连接 $x$ 和 $y$ 的一条边，询问有多少种可能的遍历顺序。注意：每次询问是**互相独立的**，也就是说，上一次询问添加的边不会保留到下一次询问。", "outputFormat": "共 $q$ 行，每行一个整数表示这次询问的答案对 $10^9+7$ 取模后得到的值。", "hint": "**样例解释**\n\n对于第一次询问可以得到如图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ojeiswc8.png)\n\n能得到的遍历顺序有：\n\n- $\\{1,2,3,3,2,4,4,1\\}$\n- $\\{1,4,4,2,3,3,2,1\\}$\n- $\\{1,3,2,2,3,4,4,1\\}$\n- $\\{1,4,4,3,2,2,3,1\\}$\n\n对于第二次询问可以得到如图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6dut5s4r.png)\n\n能得到的遍历顺序有：\n\n- $\\{1,2,2,3,3,4,4,1\\}$\n- $\\{1,2,2,4,4,3,3,1\\}$\n- $\\{1,3,3,2,2,4,4,1\\}$\n- $\\{1,3,3,4,4,2,2,1\\}$\n- $\\{1,4,4,2,2,3,3,1\\}$\n- $\\{1,4,4,3,3,2,2,1\\}$\n\n**数据范围**\n\n**本题采用捆绑测试。**\n\n| 测试点编号 | 数据范围 | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $\\text{Subtask1}$ | $n,q\\le8$ |  | $5$ |\n| $\\text{Subtask2}$ | $n,q\\le20$ |  | $10$ |\n| $\\text{Subtask3}$ | $n,q\\le500$ |  | $10$ |\n| $\\text{Subtask4}$ | $n,q\\le3000$ |  | $15$ |\n| $\\text{Subtask5}$ | $n,q\\le2\\times10^5$ | $\\text{A}$ | $15$ |\n| $\\text{Subtask6}$ | $n,q\\le2\\times10^5$ | $\\text{B}$ | $10$ |\n| $\\text{Subtask7}$ | $n,q\\le2\\times10^5$ |  | $35$ |\n\n特殊性质 $\\text{A}$：保证每一次询问的边 $(x,y)\\in E$。\n\n特殊性质 $\\text{B}$：保证树退化成一条链。\n\n对于 $100\\%$ 的数据保证 $1\\le n,q\\le2\\times10^5$，$1\\le u,v,x,y\\le n$，$x\\ne y$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『GROI-R1』 古朴而优雅", "background": "\n会馆内忽地安静了下来。\n\n「敝姓言，名杉。」\n\n他的声音沉稳而凝重，略带沙哑，却不失力度，极具穿透力。每个字都重重地打在耳畔，渗进头脑里，让人想不认真听都难。\n\n「这所学院的院长。」", "description": "杉虽然年事已高，但是还是保持与时俱进。他学习了深度优先遍历算法，觉得这种新潮的东西在一所古朴而优雅的学院里会很受欢迎。所以，他找到了在走廊里晃荡的寒，向他提出了一个问题：\n\n「我们知道，对一棵树进行深度优先遍历可以用下面的伪代码很好地解决。」\n\n$$\n\\begin{array}{l}\n\\text{DFS-TREE}(u)\\\\\n\\begin{array}{ll}\n1 & p\\gets p+1\\\\\n2 & t_p\\gets u\\\\\n3 & vis_u\\gets 1\\\\\n4 & \\textbf{for }\\text{each edge }(u,v)\\in E \\\\\n5 & \\qquad \\textbf{if }vis_v=0\\\\\n6 & \\qquad \\qquad \\text{DFS-TREE}(v)\\\\\n7 & p\\gets p+1\\\\\n8 & t_p\\gets u\\\\\n\\end{array}\n\\end{array}\n$$\n\n起初，所有变量或数组的值均为 $0$。\n\n「我们把调用 $\\text{DFS-TREE}(1)$ 在遍历过程中得到的数组 $t$ 称为这棵树的**遍历顺序**。」\n\n「你看这段代码的第 $4$ 行，这句话**遍历每一条边的顺序是不固定的**。」\n\n寒素来最讨厌不确定的东西，可是碍于院长的颜面，还是继续听下去。\n\n「你能数出这段代码**会生成多少种不同的遍历顺序**吗？」\n\n寒发现他曾经做过这个题，很快地报出了解法。本以为就结束了，可是杉继续说：\n\n「如果我**在树上增加一条边**，你还会做吗？」\n\n寒发现他的那点水平完全不够了，于是他去请教玘。玘却认为这道题目依然很简单，他告诉了寒这道题的做法。可是寒找不到杉了。\n\n这个世界到底怎么了呢？", "inputFormat": "第一行，两个整数 $n$ 和 $q$，表示树上有 $n$ 个结点，编号为 $1\\sim n$，有 $q$ 次询问。\n\n接下来 $n-1$ 行，每行两个整数 $u,v$，描述这棵树上的一条边。\n\n接下来 $q$ 行，每行两个整数 $x,y$，表示在树上添加连接 $x$ 和 $y$ 的一条边，询问有多少种可能的遍历顺序。注意：每次询问是**互相独立的**，也就是说，上一次询问添加的边不会保留到下一次询问。", "outputFormat": "共 $q$ 行，每行一个整数表示这次询问的答案对 $10^9+7$ 取模后得到的值。", "hint": "**样例解释**\n\n对于第一次询问可以得到如图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ojeiswc8.png)\n\n能得到的遍历顺序有：\n\n- $\\{1,2,3,3,2,4,4,1\\}$\n- $\\{1,4,4,2,3,3,2,1\\}$\n- $\\{1,3,2,2,3,4,4,1\\}$\n- $\\{1,4,4,3,2,2,3,1\\}$\n\n对于第二次询问可以得到如图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6dut5s4r.png)\n\n能得到的遍历顺序有：\n\n- $\\{1,2,2,3,3,4,4,1\\}$\n- $\\{1,2,2,4,4,3,3,1\\}$\n- $\\{1,3,3,2,2,4,4,1\\}$\n- $\\{1,3,3,4,4,2,2,1\\}$\n- $\\{1,4,4,2,2,3,3,1\\}$\n- $\\{1,4,4,3,3,2,2,1\\}$\n\n**数据范围**\n\n**本题采用捆绑测试。**\n\n| 测试点编号 | 数据范围 | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $\\text{Subtask1}$ | $n,q\\le8$ |  | $5$ |\n| $\\text{Subtask2}$ | $n,q\\le20$ |  | $10$ |\n| $\\text{Subtask3}$ | $n,q\\le500$ |  | $10$ |\n| $\\text{Subtask4}$ | $n,q\\le3000$ |  | $15$ |\n| $\\text{Subtask5}$ | $n,q\\le2\\times10^5$ | $\\text{A}$ | $15$ |\n| $\\text{Subtask6}$ | $n,q\\le2\\times10^5$ | $\\text{B}$ | $10$ |\n| $\\text{Subtask7}$ | $n,q\\le2\\times10^5$ |  | $35$ |\n\n特殊性质 $\\text{A}$：保证每一次询问的边 $(x,y)\\in E$。\n\n特殊性质 $\\text{B}$：保证树退化成一条链。\n\n对于 $100\\%$ 的数据保证 $1\\le n,q\\le2\\times10^5$，$1\\le u,v,x,y\\le n$，$x\\ne y$。", "locale": "zh-CN"}}}
{"pid": "P8975", "type": "P", "difficulty": 6, "samples": [["6 2 2\n1 2 -2\n1 3 1\n1 4 2\n2 5 -3\n2 6 10\n1 5\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "图论", "O2优化", "树形 DP"], "title": "『GROI-R1』 湖底之城", "background": "那年你我仍是无瑕的少年\n\n在夜晚安逸的后院无所顾忌地笑谈人生\n\n——怀念这样毫无猜忌的时光", "description": "悦，玲和荧三个人在湖底之城闲游。湖底之城的道路错综复杂，形成了一棵有 $n$ 个节点的树。\n\n她们三人的手上都有一个计数器，初始都为 $0$。她们每走到一个点的时候，**悦和荧**手上的计数器会自动加上刚刚经过的**这条边的边权**，同时**玲**的计数器会恰好**增加 $1$**。同时，她们整个过程中**没有经过某个点超过一次**。\n\n由于她们的计数器不能存储很大的值，所以，当**玲**的计数器上的值是「湖之数」$p$ 的**倍数**时，**悦可以**将她的计数器上的值减去**荧**的计数器上的值，接下来，**玲和荧**的计数器都会立刻**归零**。\n\n玘现在不知道她们闲游的起点和终点，所以天生计算能力很好的玘对于每一对起点和终点，计算出了悦手上计数器在终点时可能出现的最小值。玘把这个值记作 $f(u,v)$，意思是她们从点 $u$ 走到了点 $v$。可是，玘认为，没有红色彼岸花的寒，一定是算不出来这些答案的。所以，他让寒做一道更简单的题。玘给寒一个长度为 $m$ 的序列 $s$，让寒对于每一个点为 $u$ 时计算 $\\min\\limits_{i=1}^m\\{f(s_i,u)\\}$。\n\n**形式化题面**\n\n给定一个 $n$ 个点的树 $(V,E)$ 和一个正整数 $p$，每一条边有一个整数边权 $w_i$。\n\n我们定义 $f(s,v)$ 表示为对 $u,a,b,c$ 进行若干次**拓展**后可以得到的当 $u=v$ 时的 $a$ 的最小值，其中最开始 $u\\gets s$ 同时 $a,b,c\\gets0$。\n\n**拓展**的定义为依次进行如下操作：\n\n- 选择任意一条边 $(u',v,w)\\in E$ 满足 $u=u'$，令 $u\\gets v,a\\gets a+w,b\\gets b+1,c\\gets c+w$；\n\n- 如果 $p\\mid b$，你****可以****令 $a\\gets a-c,b\\gets 0,c\\gets0$。\n\n特别地，对于每一次**拓展**，你**不能**取一个之前取过的点。\n\n给定序列 $\\{s_m\\}$，对于每个点 $u$ 求 $\\min\\limits_{i=1}^m\\{f(s_i,u)\\}$。\n\n", "inputFormat": "第一行三个整数 $n,m,p$，表示树的节点数为 $n$，编号分别为 $1\\sim n$，「湖之数」为 $p$，序列 $s$ 的长度为 $m$。\n\n接下来 $n-1$ 行每行三个整数 $u,v,w$ 表示存在一条连接 $u,v$ 两个点，边权为 $w$ 的边。\n\n接下来一行 $m$ 个整数表示 $s_{1\\sim m}$ 即 $m$ 个起点。", "outputFormat": "设 $ans_u=\\min\\limits_{i=1}^m\\{f(s_i,u)\\}$，那么你需要输出 $\\text{xor}_{i=1}^n |ans_i|$。其中 $|a|$ 表示 $a$ 的绝对值。", "hint": "**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xo9b4yyn.png)\n\n - 如果她们从 $1$ 号点出发，首先有 $f(1,1)=0$。走到点 $2,3,4$ 时悦的计数器上的值分别为 $-2,1,2$，所以 $f(1,2)=-2,f(1,3)=1,f(1,4)=2$。她们走到点 $5,6$ 时，悦的计数器上的值分别为 $-5,8$。由于这时玲的计数器上的值等于 $2$，是 $p$ 的倍数，所以悦**可以**选择让她手上的计数器的值减去荧的计数器的值，不难得出 $f(1,5)=-5,f(1,6)=0$。\n \n- 如果她们从 $5$ 号点出发，同理可得 $f(5,5)=0,f(5,2)=-3,f(5,6)=0,f(5,1)=-5,f(5,4)=-3,f(5,3)=-4$。\n\n综上的 $\\{ans_n\\}=\\{-5,-3,-4,-3,-5,0\\}$。计算可得 $\\text{xor}_{i=1}^n |ans_i|=4$。\n\n**数据范围**\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | 数据范围 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| $\\text{Subtask1}$ | $m\\le n\\le100$，$p\\le20$ |  | $10$ |\n| $\\text{Subtask2}$ | $m\\le n\\le10^3$，$p\\le100$ |  | $15$ |\n| $\\text{Subtask3}$ | $n\\le10^5$，$p\\le100$，$m=1$ |  | $10$ |\n| $\\text{Subtask4}$ | $m\\le n\\le10^5$，$p=1$ |  | $20$ |\n| $\\text{Subtask5}$ | $m\\le n\\le10^5$，$p\\le100$ | 有 | $10$ |\n| $\\text{Subtask6}$ | $m\\le n\\le10^5$，$p\\le100$ |  | $35$ |\n\n特殊性质：保证树退化成一条链。\n\n对于 $100\\%$ 的数据 $1\\le m\\le n\\le10^5$，$1\\le p\\le100$，$-10^4\\le w\\le10^4$，$1\\le u,v,s_i\\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『GROI-R1』 湖底之城", "background": "那年你我仍是无瑕的少年\n\n在夜晚安逸的后院无所顾忌地笑谈人生\n\n——怀念这样毫无猜忌的时光", "description": "悦，玲和荧三个人在湖底之城闲游。湖底之城的道路错综复杂，形成了一棵有 $n$ 个节点的树。\n\n她们三人的手上都有一个计数器，初始都为 $0$。她们每走到一个点的时候，**悦和荧**手上的计数器会自动加上刚刚经过的**这条边的边权**，同时**玲**的计数器会恰好**增加 $1$**。同时，她们整个过程中**没有经过某个点超过一次**。\n\n由于她们的计数器不能存储很大的值，所以，当**玲**的计数器上的值是「湖之数」$p$ 的**倍数**时，**悦可以**将她的计数器上的值减去**荧**的计数器上的值，接下来，**玲和荧**的计数器都会立刻**归零**。\n\n玘现在不知道她们闲游的起点和终点，所以天生计算能力很好的玘对于每一对起点和终点，计算出了悦手上计数器在终点时可能出现的最小值。玘把这个值记作 $f(u,v)$，意思是她们从点 $u$ 走到了点 $v$。可是，玘认为，没有红色彼岸花的寒，一定是算不出来这些答案的。所以，他让寒做一道更简单的题。玘给寒一个长度为 $m$ 的序列 $s$，让寒对于每一个点为 $u$ 时计算 $\\min\\limits_{i=1}^m\\{f(s_i,u)\\}$。\n\n**形式化题面**\n\n给定一个 $n$ 个点的树 $(V,E)$ 和一个正整数 $p$，每一条边有一个整数边权 $w_i$。\n\n我们定义 $f(s,v)$ 表示为对 $u,a,b,c$ 进行若干次**拓展**后可以得到的当 $u=v$ 时的 $a$ 的最小值，其中最开始 $u\\gets s$ 同时 $a,b,c\\gets0$。\n\n**拓展**的定义为依次进行如下操作：\n\n- 选择任意一条边 $(u',v,w)\\in E$ 满足 $u=u'$，令 $u\\gets v,a\\gets a+w,b\\gets b+1,c\\gets c+w$；\n\n- 如果 $p\\mid b$，你****可以****令 $a\\gets a-c,b\\gets 0,c\\gets0$。\n\n特别地，对于每一次**拓展**，你**不能**取一个之前取过的点。\n\n给定序列 $\\{s_m\\}$，对于每个点 $u$ 求 $\\min\\limits_{i=1}^m\\{f(s_i,u)\\}$。\n\n", "inputFormat": "第一行三个整数 $n,m,p$，表示树的节点数为 $n$，编号分别为 $1\\sim n$，「湖之数」为 $p$，序列 $s$ 的长度为 $m$。\n\n接下来 $n-1$ 行每行三个整数 $u,v,w$ 表示存在一条连接 $u,v$ 两个点，边权为 $w$ 的边。\n\n接下来一行 $m$ 个整数表示 $s_{1\\sim m}$ 即 $m$ 个起点。", "outputFormat": "设 $ans_u=\\min\\limits_{i=1}^m\\{f(s_i,u)\\}$，那么你需要输出 $\\text{xor}_{i=1}^n |ans_i|$。其中 $|a|$ 表示 $a$ 的绝对值。", "hint": "**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xo9b4yyn.png)\n\n - 如果她们从 $1$ 号点出发，首先有 $f(1,1)=0$。走到点 $2,3,4$ 时悦的计数器上的值分别为 $-2,1,2$，所以 $f(1,2)=-2,f(1,3)=1,f(1,4)=2$。她们走到点 $5,6$ 时，悦的计数器上的值分别为 $-5,8$。由于这时玲的计数器上的值等于 $2$，是 $p$ 的倍数，所以悦**可以**选择让她手上的计数器的值减去荧的计数器的值，不难得出 $f(1,5)=-5,f(1,6)=0$。\n \n- 如果她们从 $5$ 号点出发，同理可得 $f(5,5)=0,f(5,2)=-3,f(5,6)=0,f(5,1)=-5,f(5,4)=-3,f(5,3)=-4$。\n\n综上的 $\\{ans_n\\}=\\{-5,-3,-4,-3,-5,0\\}$。计算可得 $\\text{xor}_{i=1}^n |ans_i|=4$。\n\n**数据范围**\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | 数据范围 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| $\\text{Subtask1}$ | $m\\le n\\le100$，$p\\le20$ |  | $10$ |\n| $\\text{Subtask2}$ | $m\\le n\\le10^3$，$p\\le100$ |  | $15$ |\n| $\\text{Subtask3}$ | $n\\le10^5$，$p\\le100$，$m=1$ |  | $10$ |\n| $\\text{Subtask4}$ | $m\\le n\\le10^5$，$p=1$ |  | $20$ |\n| $\\text{Subtask5}$ | $m\\le n\\le10^5$，$p\\le100$ | 有 | $10$ |\n| $\\text{Subtask6}$ | $m\\le n\\le10^5$，$p\\le100$ |  | $35$ |\n\n特殊性质：保证树退化成一条链。\n\n对于 $100\\%$ 的数据 $1\\le m\\le n\\le10^5$，$1\\le p\\le100$，$-10^4\\le w\\le10^4$，$1\\le u,v,s_i\\le n$。", "locale": "zh-CN"}}}
{"pid": "P8976", "type": "P", "difficulty": 4, "samples": [["2\n6 6 12\n6 8 14", "1 6 2 5 3 4\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2023", "洛谷原创", "Special Judge", "构造"], "title": "「DTOI-4」排列", "background": "**Update on 2023.2.1：新增一组针对 @[yuanjiabao](https://www.luogu.com.cn/user/455558) 的 Hack 数据，放置于 #21。**\n\n**Update on 2023.2.2：新增一组针对 @[CourtesyWei](https://www.luogu.com.cn/user/664070) 和 @[bizhidaojiaosha](https://www.luogu.com.cn/user/613616) 的 Hack 数据，放置于 #22。**\n\n------------\n\n~~构造一个排列 $p$，使得~~$\\small\\color{white}{下标为奇数的项之和 \\geq a 且下标为偶数的项之和 \\geq b。}$", "description": "小 L 给你一个**偶数** $n$ 和两个整数 $a, b$，请你构造一个长为 $n$ 的排列 $p$，使得其满足 $\\displaystyle\\sum_{i = 1}^{\\frac{n}{2}} p_i \\geq a$ 且 $\\displaystyle\\sum_{i = \\frac{n}{2} + 1}^{n} p_i \\geq b$。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n一行，三个整数 $n, a, b$。", "outputFormat": "对于每组数据，如果无解，输出 $-1$；否则，输出一行，$n$ 个整数，表示你构造出的排列 $p$。\n\n**如有多解，输出任意一组均可。**", "hint": "**本题开启 Special Judge。**\n\n| $\\textbf{Subtask}$ | $n$ | $a, b$ | 分值 |\n| :------: | :------: | :------: | :------: |\n| $1$ | $2 \\leq n \\leq 10$ | 无特殊限制 | $20 \\operatorname{pts}$ |\n| $2$ | 无特殊限制 | $a = b = 0$ | $10 \\operatorname{pts}$ |\n| $3$ | 同上 | $a = 0$ 或 $b = 0$ | $10 \\operatorname{pts}$ |\n| $4$ | 同上 | 无特殊限制 | $60 \\operatorname{pts}$ |\n\n对于 $100\\%$ 的数据，$2 \\leq n, \\sum n \\leq 10^5$，$0 \\leq a, b \\leq \\frac{n(n + 1)}{2}$，$1 \\leq T \\leq 10$，$n$ 为**偶数**。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「DTOI-4」排列", "background": "**Update on 2023.2.1：新增一组针对 @[yuanjiabao](https://www.luogu.com.cn/user/455558) 的 Hack 数据，放置于 #21。**\n\n**Update on 2023.2.2：新增一组针对 @[CourtesyWei](https://www.luogu.com.cn/user/664070) 和 @[bizhidaojiaosha](https://www.luogu.com.cn/user/613616) 的 Hack 数据，放置于 #22。**\n\n------------\n\n~~构造一个排列 $p$，使得~~$\\small\\color{white}{下标为奇数的项之和 \\geq a 且下标为偶数的项之和 \\geq b。}$", "description": "小 L 给你一个**偶数** $n$ 和两个整数 $a, b$，请你构造一个长为 $n$ 的排列 $p$，使得其满足 $\\displaystyle\\sum_{i = 1}^{\\frac{n}{2}} p_i \\geq a$ 且 $\\displaystyle\\sum_{i = \\frac{n}{2} + 1}^{n} p_i \\geq b$。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n一行，三个整数 $n, a, b$。", "outputFormat": "对于每组数据，如果无解，输出 $-1$；否则，输出一行，$n$ 个整数，表示你构造出的排列 $p$。\n\n**如有多解，输出任意一组均可。**", "hint": "**本题开启 Special Judge。**\n\n| $\\textbf{Subtask}$ | $n$ | $a, b$ | 分值 |\n| :------: | :------: | :------: | :------: |\n| $1$ | $2 \\leq n \\leq 10$ | 无特殊限制 | $20 \\operatorname{pts}$ |\n| $2$ | 无特殊限制 | $a = b = 0$ | $10 \\operatorname{pts}$ |\n| $3$ | 同上 | $a = 0$ 或 $b = 0$ | $10 \\operatorname{pts}$ |\n| $4$ | 同上 | 无特殊限制 | $60 \\operatorname{pts}$ |\n\n对于 $100\\%$ 的数据，$2 \\leq n, \\sum n \\leq 10^5$，$0 \\leq a, b \\leq \\frac{n(n + 1)}{2}$，$1 \\leq T \\leq 10$，$n$ 为**偶数**。", "locale": "zh-CN"}}}
{"pid": "P8977", "type": "P", "difficulty": 4, "samples": [["5\n1 0 -1 1 -1\n1 2\n2 3\n2 4\n1 5", "1 2 4"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "贪心", "2023", "洛谷原创", "O2优化", "深度优先搜索 DFS"], "title": "「DTOI-4」行走", "background": "小 L 感到无聊，于是希望在树上行走。", "description": "小 L 有一棵 $n$ 个点的树，树上点有点权，其中第 $i$ 个点权值为 $a_i$。\n\n他不喜欢奇奇怪怪的权值，于是他保证 $a_i$ 一定是 $-1, 0, 1$ 之一。\n\n他认为在树上行走是有趣的，于是他想要在这棵树上走出一条路径 $P$，其需要满足以下条件：\n\n- $P$ 是一条**可以为空**的**简单有向路径**。\n- 设 $P$ 中依次经过的点为 $P_1, P_2, \\cdots, P_{|P|}$，则你求出的 $P$ 需要满足 $P_1 = 1$。\n- 设 $f(P) = \\displaystyle\\sum_{i = 1}^{|P|} \\frac{a_{P_i}}{2^{i - 1}}$，则你求出的 $P$ 需要满足 $f(P)$ 最大。\n- 在 $f(P)$ 最大的前提下，你求出的 $P$ 还需要满足 $P$ 的字典序最小。\n\n请你求出符合上述条件的路径 $P$。 \n\n------------\n\n关于本题中字典序的定义：\n\n设有两条待比较的路径 $P \\neq Q$。\n\n- 若存在 $1 \\leq i \\leq \\min(|P|, |Q|)$，使得 $\\forall 1 \\leq j < i, P_j = Q_j$ 且 $P_i < Q_i$，则我们称 $P$ 的字典序小于 $Q$。\n- 若存在 $1 \\leq i \\leq \\min(|P|, |Q|)$，使得 $\\forall 1 \\leq j < i, P_j = Q_j$ 且 $P_i > Q_i$，则我们称 $P$ 的字典序大于 $Q$。\n- 若 $\\forall 1 \\leq i \\leq \\min(|P|, |Q|), P_i = Q_i$ 且 $|P| < |Q|$，则我们称 $P$ 的字典序小于 $Q$。\n- 若 $\\forall 1 \\leq i \\leq \\min(|P|, |Q|), P_i = Q_i$ 且 $|P| > |Q|$，则我们称 $P$ 的字典序大于 $Q$。", "inputFormat": "第一行，一个整数 $n$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$；\n\n接下来 $n - 1$ 行，每行两个整数 $u, v$，表示树上的一条边。", "outputFormat": "一行，$|P|$ 个整数，表示你求出的路径 $P$ 中依次经过的点。\n\n**特别的，若 $P$ 为空路径，请不要进行任何输出操作。**", "hint": "#### 样例 #1 解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/c7n2n6i0.png)\n\n$P = [1, 2, 4]$ 时 $f(P) = 1 + 0 + \\frac{1}{4} = \\frac{5}{4}$。可以证明不存在更优的 $P$。\n#### 数据范围\n| $\\textbf{Subtask}$ | $n$ | $a_i$ | 依赖 | 分值 |\n| :------: | :------: | :------: | :------: | :------: |\n| $1$ | $1 \\leq n \\leq 50$ | 无特殊限制 | 无 | $10 \\operatorname{pts}$ |\n| $2$ | $1 \\leq n \\leq 500$ | 同上 | $1$ | $10 \\operatorname{pts}$ |\n| $3$ | $1 \\leq n \\leq 5 \\times 10^3$ | 同上 | $1, 2$ | $10 \\operatorname{pts}$ |\n| $4$ | $1 \\leq n \\leq 10^5$ | 同上 | $1 \\sim 3$ | $20 \\operatorname{pts}$ |\n| $5$ | 无特殊限制 | $a_i \\in \\{-1, 1\\}$ | 无 | $20 \\operatorname{pts}$ |\n| $6$ | 同上 | 无特殊限制 | $1 \\sim 5$ | $30 \\operatorname{pts}$ |\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^5$，$a_i \\in \\{-1, 0, 1\\}$，$1 \\leq u, v \\leq n$，保证给出的边可以构成一棵**无根树**。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「DTOI-4」行走", "background": "小 L 感到无聊，于是希望在树上行走。", "description": "小 L 有一棵 $n$ 个点的树，树上点有点权，其中第 $i$ 个点权值为 $a_i$。\n\n他不喜欢奇奇怪怪的权值，于是他保证 $a_i$ 一定是 $-1, 0, 1$ 之一。\n\n他认为在树上行走是有趣的，于是他想要在这棵树上走出一条路径 $P$，其需要满足以下条件：\n\n- $P$ 是一条**可以为空**的**简单有向路径**。\n- 设 $P$ 中依次经过的点为 $P_1, P_2, \\cdots, P_{|P|}$，则你求出的 $P$ 需要满足 $P_1 = 1$。\n- 设 $f(P) = \\displaystyle\\sum_{i = 1}^{|P|} \\frac{a_{P_i}}{2^{i - 1}}$，则你求出的 $P$ 需要满足 $f(P)$ 最大。\n- 在 $f(P)$ 最大的前提下，你求出的 $P$ 还需要满足 $P$ 的字典序最小。\n\n请你求出符合上述条件的路径 $P$。 \n\n------------\n\n关于本题中字典序的定义：\n\n设有两条待比较的路径 $P \\neq Q$。\n\n- 若存在 $1 \\leq i \\leq \\min(|P|, |Q|)$，使得 $\\forall 1 \\leq j < i, P_j = Q_j$ 且 $P_i < Q_i$，则我们称 $P$ 的字典序小于 $Q$。\n- 若存在 $1 \\leq i \\leq \\min(|P|, |Q|)$，使得 $\\forall 1 \\leq j < i, P_j = Q_j$ 且 $P_i > Q_i$，则我们称 $P$ 的字典序大于 $Q$。\n- 若 $\\forall 1 \\leq i \\leq \\min(|P|, |Q|), P_i = Q_i$ 且 $|P| < |Q|$，则我们称 $P$ 的字典序小于 $Q$。\n- 若 $\\forall 1 \\leq i \\leq \\min(|P|, |Q|), P_i = Q_i$ 且 $|P| > |Q|$，则我们称 $P$ 的字典序大于 $Q$。", "inputFormat": "第一行，一个整数 $n$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$；\n\n接下来 $n - 1$ 行，每行两个整数 $u, v$，表示树上的一条边。", "outputFormat": "一行，$|P|$ 个整数，表示你求出的路径 $P$ 中依次经过的点。\n\n**特别的，若 $P$ 为空路径，请不要进行任何输出操作。**", "hint": "#### 样例 #1 解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/c7n2n6i0.png)\n\n$P = [1, 2, 4]$ 时 $f(P) = 1 + 0 + \\frac{1}{4} = \\frac{5}{4}$。可以证明不存在更优的 $P$。\n#### 数据范围\n| $\\textbf{Subtask}$ | $n$ | $a_i$ | 依赖 | 分值 |\n| :------: | :------: | :------: | :------: | :------: |\n| $1$ | $1 \\leq n \\leq 50$ | 无特殊限制 | 无 | $10 \\operatorname{pts}$ |\n| $2$ | $1 \\leq n \\leq 500$ | 同上 | $1$ | $10 \\operatorname{pts}$ |\n| $3$ | $1 \\leq n \\leq 5 \\times 10^3$ | 同上 | $1, 2$ | $10 \\operatorname{pts}$ |\n| $4$ | $1 \\leq n \\leq 10^5$ | 同上 | $1 \\sim 3$ | $20 \\operatorname{pts}$ |\n| $5$ | 无特殊限制 | $a_i \\in \\{-1, 1\\}$ | 无 | $20 \\operatorname{pts}$ |\n| $6$ | 同上 | 无特殊限制 | $1 \\sim 5$ | $30 \\operatorname{pts}$ |\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^5$，$a_i \\in \\{-1, 0, 1\\}$，$1 \\leq u, v \\leq n$，保证给出的边可以构成一棵**无根树**。", "locale": "zh-CN"}}}
{"pid": "P8978", "type": "P", "difficulty": 7, "samples": [["10 2\n2 8 3 2 5 7 10 4 9 7", "7"], ["30 3\n1 0 1 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0", "0"], ["31 3\n1 0 1 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 1", "1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "二分", "单调队列", "2023", "洛谷原创", "O2优化"], "title": "「DTOI-4」中位数", "background": "", "description": "给定一个长度为 $n$ 的整数序列 $a$，你可以进行以下操作不超过 $k$ 次：\n\n- 选择一个区间 $[l, r]$ 满足 $1 \\leq l \\leq r \\leq n$，并将 $[l, r]$ 中的所有数替换为这个区间的中位数。\n\n你要使得操作后 $a$ 的**最小值最大**。\n\n关于此处中位数的定义：对于一个长度为 $len$ 的序列，其中位数定义为该序列中第 $\\lceil \\frac{len}{2} \\rceil$ 小的数。", "inputFormat": "第一行，两个整数 $n, k$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$。", "outputFormat": "一行，表示经过不超过 $k$ 次操作后序列最小值的最大值。", "hint": "| $\\textbf{Subtask}$ | $n$ | 分值 |\n| :------: | :------: | :------: |\n| $1$ | $1 \\leq n \\leq 10$ | $10 \\operatorname{pts}$ |\n| $2$ | $1 \\leq n \\leq 100$ | $10 \\operatorname{pts}$ |\n| $3$ | $1 \\leq n \\leq 10^3$ | $10 \\operatorname{pts}$ |\n| $4$ | $1 \\leq n \\leq 10^4$ | $20 \\operatorname{pts}$ |\n| $5$ | $1 \\leq n \\leq 10^5$ | $20 \\operatorname{pts}$ |\n| $6$ | 无特殊限制 | $30 \\operatorname{pts}$ |\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 4 \\times 10^5$，$0 \\leq k \\leq n$，$0 \\leq a_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「DTOI-4」中位数", "background": "", "description": "给定一个长度为 $n$ 的整数序列 $a$，你可以进行以下操作不超过 $k$ 次：\n\n- 选择一个区间 $[l, r]$ 满足 $1 \\leq l \\leq r \\leq n$，并将 $[l, r]$ 中的所有数替换为这个区间的中位数。\n\n你要使得操作后 $a$ 的**最小值最大**。\n\n关于此处中位数的定义：对于一个长度为 $len$ 的序列，其中位数定义为该序列中第 $\\lceil \\frac{len}{2} \\rceil$ 小的数。", "inputFormat": "第一行，两个整数 $n, k$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$。", "outputFormat": "一行，表示经过不超过 $k$ 次操作后序列最小值的最大值。", "hint": "| $\\textbf{Subtask}$ | $n$ | 分值 |\n| :------: | :------: | :------: |\n| $1$ | $1 \\leq n \\leq 10$ | $10 \\operatorname{pts}$ |\n| $2$ | $1 \\leq n \\leq 100$ | $10 \\operatorname{pts}$ |\n| $3$ | $1 \\leq n \\leq 10^3$ | $10 \\operatorname{pts}$ |\n| $4$ | $1 \\leq n \\leq 10^4$ | $20 \\operatorname{pts}$ |\n| $5$ | $1 \\leq n \\leq 10^5$ | $20 \\operatorname{pts}$ |\n| $6$ | 无特殊限制 | $30 \\operatorname{pts}$ |\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 4 \\times 10^5$，$0 \\leq k \\leq n$，$0 \\leq a_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P8979", "type": "P", "difficulty": 7, "samples": [["10 25\n-5 -73 -95 64 15\n-80 -31 -58 15 95 -1 14 -30 31 ", "998096342"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2023", "多项式", "洛谷原创", "O2优化", "线性递推"], "title": "「DTOI-4」白的 Fibonacci", "background": "", "description": "定义 $F(k, n)$ 如下：\n\n$$\nF(k,n) = \n\\left \\{\n\\begin{aligned}\n&st_0\\ && k = 1\\ \\land\\ n = 0 \\\\\n&st_1\\ && k = 1\\ \\land\\ n = 1 \\\\\n&0\\ && k > 1 \\ \\land \\ n < 0 \\\\\n&a \\times F(k, n - 1) + b \\times F(k, n - 2)\\ && k = 1 \\ \\land\\ n > 1 \\\\\n&t_k \\times F(k, n - 1) + s^n \\times F(k - 1, n)\\ && \\text{otherwise}\n\\end{aligned}\n\\right.\n$$\n\n给定 $F$ 递推式的各项系数和 $k, n$，请你求出 $F(k, n) \\bmod 998244353$ 的值。", "inputFormat": "第一行，两个整数 $k, n$；\n\n第二行，五个整数 $st_0, st_1, a, b, s$；\n\n第三行，$k - 1$ 个整数 $t_2, t_3, \\cdots, t_k$。", "outputFormat": "一行一个整数表示答案。", "hint": "| $\\textbf{Subtask}$ | $k \\leq$ | $n \\leq$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $100$ | $100$ | 无 | $5$ |\n| $2$ | $100$ | $2^{63}$ | 无 | $25$ |\n| $3$ | $5000$ | $2^{63}$ | $s = 1, \\forall 2 \\leq i \\leq k, t_i = 1$ | $10$ |\n| $4$ | $5000$ | $2^{63}$ | 无 | $60$ |\n\n对于 $100\\%$ 的数据，$1 \\leq k \\leq 5 \\times 10^3$，$0 \\leq n \\le 2^{63}$，$-998244352 \\leq st_0, st_1, a, b, s, t_i \\leq 998244352$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「DTOI-4」白的 Fibonacci", "background": "", "description": "定义 $F(k, n)$ 如下：\n\n$$\nF(k,n) = \n\\left \\{\n\\begin{aligned}\n&st_0\\ && k = 1\\ \\land\\ n = 0 \\\\\n&st_1\\ && k = 1\\ \\land\\ n = 1 \\\\\n&0\\ && k > 1 \\ \\land \\ n < 0 \\\\\n&a \\times F(k, n - 1) + b \\times F(k, n - 2)\\ && k = 1 \\ \\land\\ n > 1 \\\\\n&t_k \\times F(k, n - 1) + s^n \\times F(k - 1, n)\\ && \\text{otherwise}\n\\end{aligned}\n\\right.\n$$\n\n给定 $F$ 递推式的各项系数和 $k, n$，请你求出 $F(k, n) \\bmod 998244353$ 的值。", "inputFormat": "第一行，两个整数 $k, n$；\n\n第二行，五个整数 $st_0, st_1, a, b, s$；\n\n第三行，$k - 1$ 个整数 $t_2, t_3, \\cdots, t_k$。", "outputFormat": "一行一个整数表示答案。", "hint": "| $\\textbf{Subtask}$ | $k \\leq$ | $n \\leq$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $100$ | $100$ | 无 | $5$ |\n| $2$ | $100$ | $2^{63}$ | 无 | $25$ |\n| $3$ | $5000$ | $2^{63}$ | $s = 1, \\forall 2 \\leq i \\leq k, t_i = 1$ | $10$ |\n| $4$ | $5000$ | $2^{63}$ | 无 | $60$ |\n\n对于 $100\\%$ 的数据，$1 \\leq k \\leq 5 \\times 10^3$，$0 \\leq n \\le 2^{63}$，$-998244352 \\leq st_0, st_1, a, b, s, t_i \\leq 998244352$。", "locale": "zh-CN"}}}
{"pid": "P8980", "type": "P", "difficulty": 5, "samples": [["1\n11 3\n8 9 5", "game won't stop"], ["2\n8 5\n8 2 3 5 7 \n24 16\n3 17 18 5 19 4 16 23 7 11 13 18 6 21 22 2\n", "5\n11\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 2000, 2000, 2000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "洛谷原创", "O2优化", "素数判断,质数,筛法"], "title": "「DROI」Round 1 游戏", "background": "人生，又何尝不是一场游戏呢？", "description": "你将和一名小朋友进行 $T$ 次游戏，每一次游戏的规则如下：\n\n1. 首先，你需要在 $[1,n]$ 中选择一个正整数 $x$。\n\n2. 接下来，小朋友会有 $Q$ 次询问，对于每次询问，他会给出一个 $a_i$（保证 $a_i \\in [1,n]$），你需要回答他 $\\gcd(x,a_i)$ 的值。\n\n3. 当某一轮小朋友得到答案后，如果他能唯一确定你选择的数，那么本次游戏结束。\n\n现在**你提前知道了**小朋友每次询问的 $a_i$，你需要找到一个 $x$，使得游戏持续的轮数最长。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示进行游戏的次数。\n\n对于每次游戏：\n\n第一行两个整数，分别为 $n$ 和 $Q$。\n\n第二行 $Q$ 个整数，其中第 $i$ 个整数表示 $a_i$。", "outputFormat": "对于每次游戏，请输出游戏能持续的最长轮数，如果存在一个 $x$ 使得小朋友在 $Q$ 轮之后也无法唯一确定其值，则输出`game won't stop`。", "hint": "#### 样例解释#1\n\n选取 $11$ 作为 $x$，显然小朋友到游戏结束也无法唯一确定。\n\n------------\n\n#### 样例解释#2\n\n对于第一组数据：选取 $1$ 作为 $x$，小朋友在第五轮结束后可以唯一确定 $x$，可以证明不存在更优的 $x$。\n\n对于第二组数据：同理，选取 $1$ 作为 $x$ 即可。\n\n------------\n\n#### 数据范围\n\n**「本题采用捆绑测试」** \n\n- $\\operatorname{Subtask} 1(20\\%)$：$n,Q\\leq 500$。\n\n- $\\operatorname{Subtask} 2(20\\%)$：$n,Q \\leq 5 \\times 10^4$。\n\n- $\\operatorname{Subtask} 3(30\\%)$：$Q \\leq 10^5$。\n\n- $\\operatorname{Subtask} 4(30\\%)$：无特殊限制。\n\n对于 $100\\%$ 的数据：$T \\leq 10$，$1 \\leq a_i \\leq n \\leq 10^{18}$，$1 \\leq Q \\leq 2\\times 10^{6}$，$\\sum Q \\leq 6\\times 10^{6}$。\n\n**本题输入量较大，请用较快的输入方法。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「DROI」Round 1 游戏", "background": "人生，又何尝不是一场游戏呢？", "description": "你将和一名小朋友进行 $T$ 次游戏，每一次游戏的规则如下：\n\n1. 首先，你需要在 $[1,n]$ 中选择一个正整数 $x$。\n\n2. 接下来，小朋友会有 $Q$ 次询问，对于每次询问，他会给出一个 $a_i$（保证 $a_i \\in [1,n]$），你需要回答他 $\\gcd(x,a_i)$ 的值。\n\n3. 当某一轮小朋友得到答案后，如果他能唯一确定你选择的数，那么本次游戏结束。\n\n现在**你提前知道了**小朋友每次询问的 $a_i$，你需要找到一个 $x$，使得游戏持续的轮数最长。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示进行游戏的次数。\n\n对于每次游戏：\n\n第一行两个整数，分别为 $n$ 和 $Q$。\n\n第二行 $Q$ 个整数，其中第 $i$ 个整数表示 $a_i$。", "outputFormat": "对于每次游戏，请输出游戏能持续的最长轮数，如果存在一个 $x$ 使得小朋友在 $Q$ 轮之后也无法唯一确定其值，则输出`game won't stop`。", "hint": "#### 样例解释#1\n\n选取 $11$ 作为 $x$，显然小朋友到游戏结束也无法唯一确定。\n\n------------\n\n#### 样例解释#2\n\n对于第一组数据：选取 $1$ 作为 $x$，小朋友在第五轮结束后可以唯一确定 $x$，可以证明不存在更优的 $x$。\n\n对于第二组数据：同理，选取 $1$ 作为 $x$ 即可。\n\n------------\n\n#### 数据范围\n\n**「本题采用捆绑测试」** \n\n- $\\operatorname{Subtask} 1(20\\%)$：$n,Q\\leq 500$。\n\n- $\\operatorname{Subtask} 2(20\\%)$：$n,Q \\leq 5 \\times 10^4$。\n\n- $\\operatorname{Subtask} 3(30\\%)$：$Q \\leq 10^5$。\n\n- $\\operatorname{Subtask} 4(30\\%)$：无特殊限制。\n\n对于 $100\\%$ 的数据：$T \\leq 10$，$1 \\leq a_i \\leq n \\leq 10^{18}$，$1 \\leq Q \\leq 2\\times 10^{6}$，$\\sum Q \\leq 6\\times 10^{6}$。\n\n**本题输入量较大，请用较快的输入方法。**", "locale": "zh-CN"}}}
{"pid": "P8981", "type": "P", "difficulty": 5, "samples": [["2 1\n1 2\n", "2"], ["5 2\n1 2\n1 3\n4 1\n5 1\n", "72"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["树形数据结构", "洛谷原创", "O2优化", "树形 DP", "树的直径"], "title": "「DROI」Round 1 距离", "background": "没有什么距离是无法跨越的。", "description": "定义一棵树 $G$ 上两点 $u,v$ 之间的距离 $\\operatorname{dis}(u,v)$ 为两点之间点的数量。\n\n若对于树上两点 $u,v$，满足 $\\forall x \\in G,\\operatorname{dis}(u,x) \\leq \\operatorname{dis}(u,v)$ **且** $\\operatorname{dis}(v,x) \\leq \\operatorname{dis}(u,v)$，那么我们称无序点对 $(u,v)$ 为**极远点对**。\n\n同时，树 $G$ 上一点 $x$ 的权值 $v_x$ 定义为：满足两点间最短路径经过 $x$ 的极远点对的数量。\n\n现给定树 $G$，求 $\\sum\\limits_{x \\in G}{v_x^k}$ 对 $998244353$ 取模的值，其中 $k$ 是给定的常数，且 $k \\in [1,2]$。", "inputFormat": "第一行两个数 $n,k$，分别表示树 $G$ 的点数以及给定的常数。\n\n接下来 $n-1$ 行每行两个整数 $u,v$，表示点 $u$ 和点 $v$ 之间有一条边。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "#### 样例解释 #1\n\n$(1,2)$ 为极远点对，所以 $1$ 号和 $2$ 号点点权均为 $1$，$1^1 + 1^1 =2$。\n\n------------\n\n#### 样例解释 #2\n\n极远点对有 $(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)$，故答案为 $4 \\times 3^2 + 6^2 = 72$。\n\n------------\n\n#### 数据范围\n\n| 测试点编号 | $1$ | $2$ | $3$ | $4 \\sim 5$ | $6$ | $7$ | $8 \\sim 9$ | $10$ |\n| :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |\n| $n$ | $300$ | $300$ | $2000$ | $2000$ | $10^5$ | $5 \\times 10^6$ | $10^5$ |  $5 \\times 10^6$|\n| $k$ | $1$ | $2$ | $1$ | $2$ | $1$ | $1$ | $2$ | $2$ |\n\n对于 $100\\%$ 的数据，满足 $n \\leq 5 \\times 10^6$，$1 \\leq  k \\leq 2$。\n\n**本题输入量较大，请用较快的输入方法。**\n\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「DROI」Round 1 距离", "background": "没有什么距离是无法跨越的。", "description": "定义一棵树 $G$ 上两点 $u,v$ 之间的距离 $\\operatorname{dis}(u,v)$ 为两点之间点的数量。\n\n若对于树上两点 $u,v$，满足 $\\forall x \\in G,\\operatorname{dis}(u,x) \\leq \\operatorname{dis}(u,v)$ **且** $\\operatorname{dis}(v,x) \\leq \\operatorname{dis}(u,v)$，那么我们称无序点对 $(u,v)$ 为**极远点对**。\n\n同时，树 $G$ 上一点 $x$ 的权值 $v_x$ 定义为：满足两点间最短路径经过 $x$ 的极远点对的数量。\n\n现给定树 $G$，求 $\\sum\\limits_{x \\in G}{v_x^k}$ 对 $998244353$ 取模的值，其中 $k$ 是给定的常数，且 $k \\in [1,2]$。", "inputFormat": "第一行两个数 $n,k$，分别表示树 $G$ 的点数以及给定的常数。\n\n接下来 $n-1$ 行每行两个整数 $u,v$，表示点 $u$ 和点 $v$ 之间有一条边。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "#### 样例解释 #1\n\n$(1,2)$ 为极远点对，所以 $1$ 号和 $2$ 号点点权均为 $1$，$1^1 + 1^1 =2$。\n\n------------\n\n#### 样例解释 #2\n\n极远点对有 $(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)$，故答案为 $4 \\times 3^2 + 6^2 = 72$。\n\n------------\n\n#### 数据范围\n\n| 测试点编号 | $1$ | $2$ | $3$ | $4 \\sim 5$ | $6$ | $7$ | $8 \\sim 9$ | $10$ |\n| :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |\n| $n$ | $300$ | $300$ | $2000$ | $2000$ | $10^5$ | $5 \\times 10^6$ | $10^5$ |  $5 \\times 10^6$|\n| $k$ | $1$ | $2$ | $1$ | $2$ | $1$ | $1$ | $2$ | $2$ |\n\n对于 $100\\%$ 的数据，满足 $n \\leq 5 \\times 10^6$，$1 \\leq  k \\leq 2$。\n\n**本题输入量较大，请用较快的输入方法。**\n\n\n", "locale": "zh-CN"}}}
{"pid": "P8982", "type": "P", "difficulty": 5, "samples": [["3\n1 2 3", "1 2 3"], ["3\n9 14 46666666", "9 18 -1"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "洛谷原创", "O2优化"], "title": "「DROI」Round 1 下坠", "background": "下坠是有终点的吗？", "description": "$f$ 是定义在 $\\mathbb{N^+}$ 上的函数。\n\n我们令 $a_i$ 表示 $x$ 从低到高第 $i$ 位，那么 $f(x)= \\prod_{i=1}^{len} (a_i+1)$（$len$ 表示 $x$ 的位数）。\n\n如果对于一个数 $x$，存在 $y$ 使得 $f(y)=x$，那我们称 $x$ 是下坠数。\n\n现在有 $Q$ 次询问，每次询问会给出一个正整数 $k$。\n\n令 $x$ 表示所有下坠数中第 $k$ 小的下坠数，那么请你找到一个**最小的** $y$，使得 $f(y)=x$。若不存在一个 $y \\in [1,10^{18}]$ 满足条件，则输出 $-1$。", "inputFormat": "第一行输入一个整数 $Q$，表示询问次数。\n\n接下输入一行 $Q$ 个数，第 $i$ 个数表示第 $i$ 次询问的 $k$。", "outputFormat": "输出一行 $Q$ 个数，第 $i$ 个数表示第 $i$ 次询问你找到的答案。", "hint": "#### 样例解释 #1\n\n注意到 $f$ 的定义域是 $\\mathbb{N^+}$，所以 $1$ 不是下坠数。则前三个下坠数分别为 $2,3,4$，对应的 $y$ 值则为 $1,2,3$。\n\n------------\n\n#### 样例解释 #2\n\n第 $9$ 和 $14$ 个下坠数分别为 $10$ 和 $18$，其对应的 $y$ 值则为 $9$ 和 $18$。可以证明，第 $46666666$ 个下坠数对应的 $y > 10^{18}$。\n\n------------\n\n#### 数据范围\n\n对于 $100\\%$ 的数据满足：$Q \\leq 10^5$，$k \\leq 5 \\times 10^7$。\n\n其中对于 $10\\%$ 的数据满足：$k \\leq 100$。\n\n对于 $30\\%$ 的数据满足：$k \\leq 5 \\times 10^3$。\n\n对于另外 $20\\%$ 的数据满足：对于所有被询问到的下坠数 $x$，都有 $\\vert x-y \\vert \\leq 100$ 或者 $y > 10^{18}$。\n\n**请注意不同寻常的时间限制。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「DROI」Round 1 下坠", "background": "下坠是有终点的吗？", "description": "$f$ 是定义在 $\\mathbb{N^+}$ 上的函数。\n\n我们令 $a_i$ 表示 $x$ 从低到高第 $i$ 位，那么 $f(x)= \\prod_{i=1}^{len} (a_i+1)$（$len$ 表示 $x$ 的位数）。\n\n如果对于一个数 $x$，存在 $y$ 使得 $f(y)=x$，那我们称 $x$ 是下坠数。\n\n现在有 $Q$ 次询问，每次询问会给出一个正整数 $k$。\n\n令 $x$ 表示所有下坠数中第 $k$ 小的下坠数，那么请你找到一个**最小的** $y$，使得 $f(y)=x$。若不存在一个 $y \\in [1,10^{18}]$ 满足条件，则输出 $-1$。", "inputFormat": "第一行输入一个整数 $Q$，表示询问次数。\n\n接下输入一行 $Q$ 个数，第 $i$ 个数表示第 $i$ 次询问的 $k$。", "outputFormat": "输出一行 $Q$ 个数，第 $i$ 个数表示第 $i$ 次询问你找到的答案。", "hint": "#### 样例解释 #1\n\n注意到 $f$ 的定义域是 $\\mathbb{N^+}$，所以 $1$ 不是下坠数。则前三个下坠数分别为 $2,3,4$，对应的 $y$ 值则为 $1,2,3$。\n\n------------\n\n#### 样例解释 #2\n\n第 $9$ 和 $14$ 个下坠数分别为 $10$ 和 $18$，其对应的 $y$ 值则为 $9$ 和 $18$。可以证明，第 $46666666$ 个下坠数对应的 $y > 10^{18}$。\n\n------------\n\n#### 数据范围\n\n对于 $100\\%$ 的数据满足：$Q \\leq 10^5$，$k \\leq 5 \\times 10^7$。\n\n其中对于 $10\\%$ 的数据满足：$k \\leq 100$。\n\n对于 $30\\%$ 的数据满足：$k \\leq 5 \\times 10^3$。\n\n对于另外 $20\\%$ 的数据满足：对于所有被询问到的下坠数 $x$，都有 $\\vert x-y \\vert \\leq 100$ 或者 $y > 10^{18}$。\n\n**请注意不同寻常的时间限制。**", "locale": "zh-CN"}}}
{"pid": "P8983", "type": "P", "difficulty": 6, "samples": [["3 3 5 10\n1 2 6\n7 3 11\n9 44 5\n2 3 1\n1 3 2\n5 10 15 20 25\n6 6 6 6 6", "0"], ["8 8 8 28\n49 11 44 31 25 37 41 1 \n29 38 46 21 21 17 45 47 \n1 37 11 31 8 15 15 47 \n21 47 15 6 11 9 40 28 \n21 29 1 11 39 15 21 35 \n26 20 3 38 1 41 27 21 \n41 41 31 16 11 1 24 3 \n33 15 23 26 7 47 49 8 \n3 8 2 4 6 5 1 7 \n7 5 8 3 6 1 4 2 \n36 13 12 3 38 49 22 55 \n20 24 2 30 26 25 17 25 ", "32"]], "limits": {"time": [800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "洛谷原创", "O2优化", "动态规划优化"], "title": "「DROI」Round 1 失控", "background": "失控的，或许反而是理智的。", "description": "给定一个 $n \\times m$ 的矩阵 $G$ 和两个长度为 $m$ 的排列 $p,q$。\n\n我们称元素 $G_{i,j}$ 是**失控的**，当且仅当 $\\vert G_{i,j} - G_{i-1,p_j} \\vert > C$ **且** $\\vert G_{i,j} - G_{i+1,q_j} \\vert > C$，其中 $C$ 是给定的常数。特殊地，我们规定无论如何第 $1$ 行和第 $n$ 行的元素都不是失控的。\n\n此时再给定两个长度为 $k$ 的序列 $A$ 和 $B$。\n\n你将有 $k$ 种操作：其中第 $i$ 种操作是将某一行所有元素增加 $A_i$，这将会花费 $B_i$ 的代价。**每种操作可以使用的次数不限，但对于每一行，你只可以进行这些操作中的一种或不操作。并且，你必须保证任意相邻两行最多有一行进行操作。**\n\n请问要使得矩阵 $G$ 中所有元素均不失控，至少要花费的代价是多少（数据保证有解）？", "inputFormat": "第一行四个整数，分别为 $n,m,k,C$。\n\n接下来 $n+4$ 行，前 $n$ 行每行 $m$ 个数，表示矩阵 $G$，第 $n+1$ 和 $n+2$ 行每行 $m$ 个数，分别表示排列 $p$ 和 $q$，最后两行每行 $k$ 个数，分别表示序列 $A$ 和 $B$。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "#### 样例解释 #1\n\n显然对于样例一，不用进行任何操作就能保证所有元素均不失控。\n\n------------\n\n#### 样例解释 #2\n\n对第三行使用 $3$ 操作，对第七行使用 $4$ 操作即可。可以证明不存在更优的方案。\n\n------------\n\n#### 数据范围\n\n**「本题采用捆绑测试」** \n\n- $\\operatorname{Subtask} 1(10\\%)$：$n,m,k \\leq 8$。\n\n- $\\operatorname{Subtask} 2(30\\%)$：$m\\leq 50,k\\leq 100$。\n\n- $\\operatorname{Subtask} 3(20\\%)$：$m\\leq 50,k\\leq 1000$。\n\n- $\\operatorname{Subtask} 4(40\\%)$：无特殊限制。\n\n对于 $100\\%$ 的数据满足：$3 \\leq n\\leq 50$，$1 \\leq m \\leq 300$，$0 \\leq k \\leq 2000$，$C,G_{i,j},A_i,B_i \\leq 10^6$。\n\n**本题输入量较大，请用较快的输入方法。**\n\n------------\n\n#### 提示\n\n- 本题不卡常，如果你认为自己的算法差一点就能跑过下一个 Subtask 却没有跑过，那么请不要纠结于无意义的卡常，因为差的这一点可能需要更优秀的算法来弥补。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「DROI」Round 1 失控", "background": "失控的，或许反而是理智的。", "description": "给定一个 $n \\times m$ 的矩阵 $G$ 和两个长度为 $m$ 的排列 $p,q$。\n\n我们称元素 $G_{i,j}$ 是**失控的**，当且仅当 $\\vert G_{i,j} - G_{i-1,p_j} \\vert > C$ **且** $\\vert G_{i,j} - G_{i+1,q_j} \\vert > C$，其中 $C$ 是给定的常数。特殊地，我们规定无论如何第 $1$ 行和第 $n$ 行的元素都不是失控的。\n\n此时再给定两个长度为 $k$ 的序列 $A$ 和 $B$。\n\n你将有 $k$ 种操作：其中第 $i$ 种操作是将某一行所有元素增加 $A_i$，这将会花费 $B_i$ 的代价。**每种操作可以使用的次数不限，但对于每一行，你只可以进行这些操作中的一种或不操作。并且，你必须保证任意相邻两行最多有一行进行操作。**\n\n请问要使得矩阵 $G$ 中所有元素均不失控，至少要花费的代价是多少（数据保证有解）？", "inputFormat": "第一行四个整数，分别为 $n,m,k,C$。\n\n接下来 $n+4$ 行，前 $n$ 行每行 $m$ 个数，表示矩阵 $G$，第 $n+1$ 和 $n+2$ 行每行 $m$ 个数，分别表示排列 $p$ 和 $q$，最后两行每行 $k$ 个数，分别表示序列 $A$ 和 $B$。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "#### 样例解释 #1\n\n显然对于样例一，不用进行任何操作就能保证所有元素均不失控。\n\n------------\n\n#### 样例解释 #2\n\n对第三行使用 $3$ 操作，对第七行使用 $4$ 操作即可。可以证明不存在更优的方案。\n\n------------\n\n#### 数据范围\n\n**「本题采用捆绑测试」** \n\n- $\\operatorname{Subtask} 1(10\\%)$：$n,m,k \\leq 8$。\n\n- $\\operatorname{Subtask} 2(30\\%)$：$m\\leq 50,k\\leq 100$。\n\n- $\\operatorname{Subtask} 3(20\\%)$：$m\\leq 50,k\\leq 1000$。\n\n- $\\operatorname{Subtask} 4(40\\%)$：无特殊限制。\n\n对于 $100\\%$ 的数据满足：$3 \\leq n\\leq 50$，$1 \\leq m \\leq 300$，$0 \\leq k \\leq 2000$，$C,G_{i,j},A_i,B_i \\leq 10^6$。\n\n**本题输入量较大，请用较快的输入方法。**\n\n------------\n\n#### 提示\n\n- 本题不卡常，如果你认为自己的算法差一点就能跑过下一个 Subtask 却没有跑过，那么请不要纠结于无意义的卡常，因为差的这一点可能需要更优秀的算法来弥补。", "locale": "zh-CN"}}}
{"pid": "P8984", "type": "P", "difficulty": 7, "samples": [["3 2", "1\n0 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "Special Judge", "O2优化", "CTT（清华集训/北大集训）"], "title": "[北大集训 2021] 末日魔法少女计划", "background": "CTT2021 D1T1", "description": "对于给定的 $n,k$，你需要构造一个只含 $0,1$ 的矩阵 $A_{i,j}$，$0\\le i,j\\le n$，满足：\n\n1. $A_{i,i}=1$；\n2. $A_{i,i+1}=1$；\n3. 对 $i>j$ 有 $A_{i,j}=0$；\n4. 若 $A_{i,j}=1$，$j-i>1$，则存在 $i<t<j$，满足 $A_{i,t}=A_{t,j}=1$；\n5. 对 $i\\le j$ 有 $(A^k)_{i,j}>0$。\n\n你需要输出满足 $A_{i,j}=1$ 且 $j-i>1$ 的每个 $(i,j)$，设这样的 $(i,j)$ 共有 $m$ 个。\n\n若输出不满足要求，则不能得到该测试点的任何分数。若输出满足要求，则根据 $m$ 进行评分。\n", "inputFormat": "一行，两个整数 $n,k$。\n", "outputFormat": "第一行一个整数 $m$，接下来 $m$ 行，每行两个整数 $i,j$，依次表示每个满足 $A_{i,j}=1$ 且 $j-i>1$ 的二元组 $(i,j)$。", "hint": "- $1900\\le n\\le 2000$；\n- $2\\le k\\le 15$。\n\n| $k$  |  $f(k)$  | $s(k)$ |\n| :--: | :------: | :----: |\n| $2$  | $7.9870$ |  $22$  |\n| $3$  | $3.8085$ |  $14$  |\n| $4$  | $2.3960$ |  $11$  |\n| $5$  | $1.9610$ |  $9$   |\n| $6$  | $1.6065$ |  $7$   |\n| $7$  | $1.4515$ |  $6$   |\n| $8$  | $1.2540$ |  $5$   |\n| $9$  | $1.1980$ |  $5 $   |\n| $10$ | $1.0995$ |  $4$   |\n| $11$ | $1.0705$ |  $4 $   |\n| $12$ | $1.0345$ |  $4$   |\n| $13$ | $1.0120$ |  $3$   |\n| $14$ | $1.0015$ |  $3 $   |\n| $15$ | $0.9940$ |  $3$   |\n\n\n\n每个 $2\\le k\\le 15$ 对应一个总分为 $s(k)$ 的子任务，每个子任务的得分是子任务中每个测试点的得分的最小值。\n\n每个测试点的得分为所在子任务的总分的 $\\max\\left(0,1-\\sqrt{\\max\\left(0,\\frac{m}{n\\cdot f(k)}-1\\right)}\\right)$ 倍。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[北大集训 2021] 末日魔法少女计划", "background": "CTT2021 D1T1", "description": "对于给定的 $n,k$，你需要构造一个只含 $0,1$ 的矩阵 $A_{i,j}$，$0\\le i,j\\le n$，满足：\n\n1. $A_{i,i}=1$；\n2. $A_{i,i+1}=1$；\n3. 对 $i>j$ 有 $A_{i,j}=0$；\n4. 若 $A_{i,j}=1$，$j-i>1$，则存在 $i<t<j$，满足 $A_{i,t}=A_{t,j}=1$；\n5. 对 $i\\le j$ 有 $(A^k)_{i,j}>0$。\n\n你需要输出满足 $A_{i,j}=1$ 且 $j-i>1$ 的每个 $(i,j)$，设这样的 $(i,j)$ 共有 $m$ 个。\n\n若输出不满足要求，则不能得到该测试点的任何分数。若输出满足要求，则根据 $m$ 进行评分。\n", "inputFormat": "一行，两个整数 $n,k$。\n", "outputFormat": "第一行一个整数 $m$，接下来 $m$ 行，每行两个整数 $i,j$，依次表示每个满足 $A_{i,j}=1$ 且 $j-i>1$ 的二元组 $(i,j)$。", "hint": "- $1900\\le n\\le 2000$；\n- $2\\le k\\le 15$。\n\n| $k$  |  $f(k)$  | $s(k)$ |\n| :--: | :------: | :----: |\n| $2$  | $7.9870$ |  $22$  |\n| $3$  | $3.8085$ |  $14$  |\n| $4$  | $2.3960$ |  $11$  |\n| $5$  | $1.9610$ |  $9$   |\n| $6$  | $1.6065$ |  $7$   |\n| $7$  | $1.4515$ |  $6$   |\n| $8$  | $1.2540$ |  $5$   |\n| $9$  | $1.1980$ |  $5 $   |\n| $10$ | $1.0995$ |  $4$   |\n| $11$ | $1.0705$ |  $4 $   |\n| $12$ | $1.0345$ |  $4$   |\n| $13$ | $1.0120$ |  $3$   |\n| $14$ | $1.0015$ |  $3 $   |\n| $15$ | $0.9940$ |  $3$   |\n\n\n\n每个 $2\\le k\\le 15$ 对应一个总分为 $s(k)$ 的子任务，每个子任务的得分是子任务中每个测试点的得分的最小值。\n\n每个测试点的得分为所在子任务的总分的 $\\max\\left(0,1-\\sqrt{\\max\\left(0,\\frac{m}{n\\cdot f(k)}-1\\right)}\\right)$ 倍。\n", "locale": "zh-CN"}}}
{"pid": "P8985", "type": "P", "difficulty": 7, "samples": [["10\n+ 2 1 1 3 4\n+ 1 2 2 2 5\n? 2 2 2\n+ 1 1 1 8 2\n? 2 2 1\n? 1 2 2\n- 1\n? 2 2 2\n- 3\n? 1 2 2\n", "2\n7\n5\n5\n2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "O2优化", "CTT（清华集训/北大集训）"], "title": "[北大集训 2021] 魔塔 OL", "background": "CTT2021 D1T2", "description": "比特游戏公司最近发布了一款新游戏《魔塔 Online》，玩家可以操控勇士在游戏世界中与怪物进行搏斗。在游戏发布之初，魔塔里没有任何怪物，接下来将依次发生 $q$ 个事件，每个事件是以下三种之一：\n\n* `+ x y z a b`：表示游戏发布了新版本，在游戏中新增了一只怪物。如果这是第一只新增的怪物，那么它的编号为 $1$；否则它的编号为最后一只新增的怪物的编号 $+1$。这只怪物位于魔塔的第 $x$ 层，它的等级为 $y$ 级，它的难度为 $z$。如果玩家选择击杀这只怪物，那么需要消耗 $a$ 点血量，在击杀成功后，玩家将得到一支可以恢复 $b$ 点血量的药剂并立即使用。\n* `- k`：表示游戏发布了新版本，编号为 $k$ 的怪物由于平衡性问题下架，它将不会出现在魔塔中。请注意：下架的怪物**仍然保留它们的编号**，未来新增的怪物**不会复用**被下架怪物的编号。\n* `? g l d`：表示一个询问。某玩家希望击杀魔塔前 $g$ 层中**所有**等级**不超过** $l$ 且难度**不超过** $d$ 的怪物。玩家可以按照**任意顺序**去击杀这些怪物，登上新的一层**不需要杀光**当前层的所有怪物，且作战过程中不会受到别的怪物的干扰。你的任务是帮助该玩家计算出征前勇士的血量**最少**是多少。如果某个时刻勇士的血量是**负数**，那么游戏结束，你一定要防止这种情况的发生。\n\n请写一个程序，依次回答每个询问。注意：每个询问只是玩家的一个思考，**不会真正击杀**任何一只怪物。", "inputFormat": "输入的第一行包含一个整数 $q$，表示事件数。\n\n接下来 $q$ 行，每行开头一个字符，随后是几个整数，依次描述每个事件。\n\n输入数据保证 $1\\leq q\\leq 150\\,000$，怪物总数不超过 $50\\,000$，询问数量不超过 $50\\,000$。\n\n对于新增怪物操作，保证 $1\\leq x,y,z\\leq 10\\,000$，且 $0\\leq a,b\\leq 10^9$。\n\n对于下架怪物操作，保证操作合法，且每只怪物不会被重复下架。\n\n对于询问，保证 $1\\leq g,l,d\\leq 10\\,000$。", "outputFormat": "对于每个询问，输出一行一个整数，即出征前勇士的血量的最小值。", "hint": "1. （3 分）怪物总数不超过 $8$，询问数量不超过 $8$。\n2. （7 分）怪物总数不超过 $5\\,000$，询问数量不超过 $5\\,000$。\n3. （10 分）药剂不会回血，且所有怪物的难度都是 $1$。即 $b=0$，且 $z=d=1$。\n4. （17 分）$1\\leq x,y,z,g,l,d\\leq 5$。\n5. （30 分）所有怪物的等级和难度都是 $1$。即 $y=z=l=d=1$。\n6. （33 分）无其他限制。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[北大集训 2021] 魔塔 OL", "background": "CTT2021 D1T2", "description": "比特游戏公司最近发布了一款新游戏《魔塔 Online》，玩家可以操控勇士在游戏世界中与怪物进行搏斗。在游戏发布之初，魔塔里没有任何怪物，接下来将依次发生 $q$ 个事件，每个事件是以下三种之一：\n\n* `+ x y z a b`：表示游戏发布了新版本，在游戏中新增了一只怪物。如果这是第一只新增的怪物，那么它的编号为 $1$；否则它的编号为最后一只新增的怪物的编号 $+1$。这只怪物位于魔塔的第 $x$ 层，它的等级为 $y$ 级，它的难度为 $z$。如果玩家选择击杀这只怪物，那么需要消耗 $a$ 点血量，在击杀成功后，玩家将得到一支可以恢复 $b$ 点血量的药剂并立即使用。\n* `- k`：表示游戏发布了新版本，编号为 $k$ 的怪物由于平衡性问题下架，它将不会出现在魔塔中。请注意：下架的怪物**仍然保留它们的编号**，未来新增的怪物**不会复用**被下架怪物的编号。\n* `? g l d`：表示一个询问。某玩家希望击杀魔塔前 $g$ 层中**所有**等级**不超过** $l$ 且难度**不超过** $d$ 的怪物。玩家可以按照**任意顺序**去击杀这些怪物，登上新的一层**不需要杀光**当前层的所有怪物，且作战过程中不会受到别的怪物的干扰。你的任务是帮助该玩家计算出征前勇士的血量**最少**是多少。如果某个时刻勇士的血量是**负数**，那么游戏结束，你一定要防止这种情况的发生。\n\n请写一个程序，依次回答每个询问。注意：每个询问只是玩家的一个思考，**不会真正击杀**任何一只怪物。", "inputFormat": "输入的第一行包含一个整数 $q$，表示事件数。\n\n接下来 $q$ 行，每行开头一个字符，随后是几个整数，依次描述每个事件。\n\n输入数据保证 $1\\leq q\\leq 150\\,000$，怪物总数不超过 $50\\,000$，询问数量不超过 $50\\,000$。\n\n对于新增怪物操作，保证 $1\\leq x,y,z\\leq 10\\,000$，且 $0\\leq a,b\\leq 10^9$。\n\n对于下架怪物操作，保证操作合法，且每只怪物不会被重复下架。\n\n对于询问，保证 $1\\leq g,l,d\\leq 10\\,000$。", "outputFormat": "对于每个询问，输出一行一个整数，即出征前勇士的血量的最小值。", "hint": "1. （3 分）怪物总数不超过 $8$，询问数量不超过 $8$。\n2. （7 分）怪物总数不超过 $5\\,000$，询问数量不超过 $5\\,000$。\n3. （10 分）药剂不会回血，且所有怪物的难度都是 $1$。即 $b=0$，且 $z=d=1$。\n4. （17 分）$1\\leq x,y,z,g,l,d\\leq 5$。\n5. （30 分）所有怪物的等级和难度都是 $1$。即 $y=z=l=d=1$。\n6. （33 分）无其他限制。\n", "locale": "zh-CN"}}}
{"pid": "P8986", "type": "P", "difficulty": 5, "samples": [["10 4 6\n2 1 4 7 4 8 3 6 4 8\n", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "二分", "2021", "O2优化", "CTT（清华集训/北大集训）", "双指针 two-pointer"], "title": "[北大集训 2021] 基因编辑", "background": "CTT2021 D1T3", "description": "人类目前已经研究出了多种基因编辑技术，其中最传统的一种技术需要用到“限制性核酸内切酶”（简称限制酶）。这种酶能够识别特定的核苷酸序列，并在指定的位点上切割连接相邻核苷酸的磷酸二酯键，产生被称为“末端”的序列切口。只有相匹配的末端才能用 DNA 连接酶进行连接。\n\n假设现在要用基因片段 $A$ 去替换某一载体 $V$ 上的基因片段 $B$。在使用限制酶的编辑技术中，通常需要进行以下操作：\n\n1. 在基因 $A$ 的两端各选择一种限制酶识别位点。这两处识别位点在基因 $B$ 的两端也应当相应存在。\n2. 用所选择的识别位点对应的限制酶对基因 $A$ 进行处理，使得其两端产生相应的末端。将处理后的基因 $A$ 提纯。\n3. 用同样的限制酶切断载体 $V$ 上的识别位点，使得基因 $B$ 与载体 $V$ 断开。纯化出去除了基因 $B$ 的载体 $V'$。\n4. 将载体 $V'$ 与基因 $A$ 混合，并在 DNA 连接酶的帮助下将断开的磷酸二酯键重新接上。\n\n值得一提的是，如果两处识别位点断开后产生了相同的末端，那么在第 4 步中载体 $V'$ 有可能单独连接起来，产生了不包含基因 $A$ 或 $B$ 的载体；也有可能基因 $A$ 反向接入 $V'$，同样产生错误的载体。因此，在实际运用中，通常选取产生不同末端的限制酶对基因 $A$ 和载体 $V$ 进行处理。\n\n公元 3032 年，人类发现了一种掌握了基因编辑技术的外星文明 HD1048576d。当然，这种基因编辑的技术仅限于居住在 HD1048576d 这颗行星上的外星生物的基因。我们人类掌握的基因编辑技术可识别的最小单位是 DNA 序列上的单个碱基，而外星文明的基因编辑技术可识别的最小单位是其基因序列上的单个 noicleobase。出于方便起见，我们可以将单个 noicleobase 用从 $1$ 开始的正整数表示，那么一段外星生命的基因序列就可以被表示成相应的正整数序列。\n\n对于一段长度为 $n$ 的外星生命的基因序列（不妨记其正整数表示为 $s_1, s_2, \\cdots, s_n$），外星文明 HD1048576d 的基因编辑过程如下：\n\n1. 选择一段要编辑的区域 $[l, r]$，即原位替换原序列中 $s_l, s_{l+1}, \\cdots, s_r$ 这部分子序列；\n2. 挑选一对跨过待替换区域的下标 $(i, j)$（即 $1\\le i<l$ 且 $r<j\\le n$），批量生产出 $s_i, \\cdots, s_j$ 这段子序列在编辑后对应的新序列 $s_i, \\cdots, s_{l-1}, t_1, \\cdots, t_k, s_{r+1}, \\cdots, s_j$；\n3. 通过对应的特异性识别工具，将 $s_i, \\cdots, s_j$ 这段子序列从原序列中断开，并将 $s_i, \\cdots, s_{l-1}, t_1, \\cdots, t_k, s_{r+1}, \\cdots, s_j$ 接到序列中，即可得到目标基因序列。\n\n需要注意的是，在步骤 2 中，挑选的这对下标必须对应唯一的 noicleobase 组合。也就是说，能够满足 $s_{i'}=s_i, s_{j'} = s_j$ 且 $i<j$ 的有序对 $\\left(i', j'\\right)$ 必须是唯一的（即为 $(i, j)$），否则特异性识别工具可能切割下其它区段的基因序列；另外，$s_i\\ne s_j$，否则特异性识别工具可能只切割下单个 noicleobase。\n\n另外，由于替换时需要生产新的基因序列，而生产这样的序列需要不小的开销，所以外星文明希望能够最小化需要生产的基因序列长度。显然，最小化这一长度等价于最小化被切割下来的基因子序列的长度，所以实践中一般是通过最小化被切割下来的基因子序列长度来计算最优解的。\n\n现在，他们想考考人类文明的智力水平，于是你被他们从众多高中生中挑选出来解决这一问题。", "inputFormat": "输入的第一行包含三个正整数 $n, l, r$，表示待编辑的基因序列的长度，需要编辑的区域的左端点，和需要编辑的区域的右端点。保证 $3\\le n\\le 10^6$ 且 $1<l\\le r < n$。\n\n输入的第二行包含 $n$ 个正整数 $s_1, \\cdots, s_n$，表示用正整数表示的待编辑的基因序列。保证每个 noicleobase 的编号 $s_i$ 都在 $[1, 10^6]$ 中。", "outputFormat": "如果存在满足外星文明的基因编辑技术限制的基因序列切割方案，则输出一个正整数，表示输出所有方案中，被切割下来的基因子序列的最小值。否则，输出 `-1`，表示不存在满足限制的切割方案。\n", "hint": "最优方案为切割 `1 4 7 4 8 3`。可以证明，没有比这更优秀的满足技术限制的切割方案。\n\n一种比该方案切割长度更短的方案是 `4 7 4 8 3`，但是在这种方案中特异性识别工具可能会断开 `4 8 3`，从而导致产生的目标基因序列出现意外的突变，因此这种切割方案不满足技术限制。\n\n---\n\n对于 $100\\%$ 的数据，保证 $3\\le n \\le 10^6$，$\\forall 1\\le i\\le n, 1\\le s_i\\le 10^6$，且 $1<l\\le r<n$。\n\n本题共有 5 个子任务，你需要通过一个子任务中的所有测试点才能获得该子任务的相应分数。下表为各子任务的数据规模及性质。\n\n| 子任务编号 | 对应分数 | $n\\le$ | $s_i\\le$ | 特殊性质 |\n| :--------: | :------: | :----: | :------: | :------: |\n|    $1$     |   $5$    | $1000$ |  $1000$  | $\\times$ |\n|    $2$     |   $10$   | $1000$ |  $10^6$  | $\\times$ |\n|    $3$     |   $25$   | $10^6$ |  $1000$  | $\\times$ |\n|    $4$     |   $30$   | $10^6$ |  $10^6$  | $\\surd$  |\n|    $5$     |   $30 $   | $10^6$ |  $10^6$  | $\\times$ |\n\n\n\n上表中的“特殊性质”为：$s_1, \\cdots, s_{l - 1}$ 各不相同，且 $s_{r + 1}, \\cdots, s_n$ 各不相同。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[北大集训 2021] 基因编辑", "background": "CTT2021 D1T3", "description": "人类目前已经研究出了多种基因编辑技术，其中最传统的一种技术需要用到“限制性核酸内切酶”（简称限制酶）。这种酶能够识别特定的核苷酸序列，并在指定的位点上切割连接相邻核苷酸的磷酸二酯键，产生被称为“末端”的序列切口。只有相匹配的末端才能用 DNA 连接酶进行连接。\n\n假设现在要用基因片段 $A$ 去替换某一载体 $V$ 上的基因片段 $B$。在使用限制酶的编辑技术中，通常需要进行以下操作：\n\n1. 在基因 $A$ 的两端各选择一种限制酶识别位点。这两处识别位点在基因 $B$ 的两端也应当相应存在。\n2. 用所选择的识别位点对应的限制酶对基因 $A$ 进行处理，使得其两端产生相应的末端。将处理后的基因 $A$ 提纯。\n3. 用同样的限制酶切断载体 $V$ 上的识别位点，使得基因 $B$ 与载体 $V$ 断开。纯化出去除了基因 $B$ 的载体 $V'$。\n4. 将载体 $V'$ 与基因 $A$ 混合，并在 DNA 连接酶的帮助下将断开的磷酸二酯键重新接上。\n\n值得一提的是，如果两处识别位点断开后产生了相同的末端，那么在第 4 步中载体 $V'$ 有可能单独连接起来，产生了不包含基因 $A$ 或 $B$ 的载体；也有可能基因 $A$ 反向接入 $V'$，同样产生错误的载体。因此，在实际运用中，通常选取产生不同末端的限制酶对基因 $A$ 和载体 $V$ 进行处理。\n\n公元 3032 年，人类发现了一种掌握了基因编辑技术的外星文明 HD1048576d。当然，这种基因编辑的技术仅限于居住在 HD1048576d 这颗行星上的外星生物的基因。我们人类掌握的基因编辑技术可识别的最小单位是 DNA 序列上的单个碱基，而外星文明的基因编辑技术可识别的最小单位是其基因序列上的单个 noicleobase。出于方便起见，我们可以将单个 noicleobase 用从 $1$ 开始的正整数表示，那么一段外星生命的基因序列就可以被表示成相应的正整数序列。\n\n对于一段长度为 $n$ 的外星生命的基因序列（不妨记其正整数表示为 $s_1, s_2, \\cdots, s_n$），外星文明 HD1048576d 的基因编辑过程如下：\n\n1. 选择一段要编辑的区域 $[l, r]$，即原位替换原序列中 $s_l, s_{l+1}, \\cdots, s_r$ 这部分子序列；\n2. 挑选一对跨过待替换区域的下标 $(i, j)$（即 $1\\le i<l$ 且 $r<j\\le n$），批量生产出 $s_i, \\cdots, s_j$ 这段子序列在编辑后对应的新序列 $s_i, \\cdots, s_{l-1}, t_1, \\cdots, t_k, s_{r+1}, \\cdots, s_j$；\n3. 通过对应的特异性识别工具，将 $s_i, \\cdots, s_j$ 这段子序列从原序列中断开，并将 $s_i, \\cdots, s_{l-1}, t_1, \\cdots, t_k, s_{r+1}, \\cdots, s_j$ 接到序列中，即可得到目标基因序列。\n\n需要注意的是，在步骤 2 中，挑选的这对下标必须对应唯一的 noicleobase 组合。也就是说，能够满足 $s_{i'}=s_i, s_{j'} = s_j$ 且 $i<j$ 的有序对 $\\left(i', j'\\right)$ 必须是唯一的（即为 $(i, j)$），否则特异性识别工具可能切割下其它区段的基因序列；另外，$s_i\\ne s_j$，否则特异性识别工具可能只切割下单个 noicleobase。\n\n另外，由于替换时需要生产新的基因序列，而生产这样的序列需要不小的开销，所以外星文明希望能够最小化需要生产的基因序列长度。显然，最小化这一长度等价于最小化被切割下来的基因子序列的长度，所以实践中一般是通过最小化被切割下来的基因子序列长度来计算最优解的。\n\n现在，他们想考考人类文明的智力水平，于是你被他们从众多高中生中挑选出来解决这一问题。", "inputFormat": "输入的第一行包含三个正整数 $n, l, r$，表示待编辑的基因序列的长度，需要编辑的区域的左端点，和需要编辑的区域的右端点。保证 $3\\le n\\le 10^6$ 且 $1<l\\le r < n$。\n\n输入的第二行包含 $n$ 个正整数 $s_1, \\cdots, s_n$，表示用正整数表示的待编辑的基因序列。保证每个 noicleobase 的编号 $s_i$ 都在 $[1, 10^6]$ 中。", "outputFormat": "如果存在满足外星文明的基因编辑技术限制的基因序列切割方案，则输出一个正整数，表示输出所有方案中，被切割下来的基因子序列的最小值。否则，输出 `-1`，表示不存在满足限制的切割方案。\n", "hint": "最优方案为切割 `1 4 7 4 8 3`。可以证明，没有比这更优秀的满足技术限制的切割方案。\n\n一种比该方案切割长度更短的方案是 `4 7 4 8 3`，但是在这种方案中特异性识别工具可能会断开 `4 8 3`，从而导致产生的目标基因序列出现意外的突变，因此这种切割方案不满足技术限制。\n\n---\n\n对于 $100\\%$ 的数据，保证 $3\\le n \\le 10^6$，$\\forall 1\\le i\\le n, 1\\le s_i\\le 10^6$，且 $1<l\\le r<n$。\n\n本题共有 5 个子任务，你需要通过一个子任务中的所有测试点才能获得该子任务的相应分数。下表为各子任务的数据规模及性质。\n\n| 子任务编号 | 对应分数 | $n\\le$ | $s_i\\le$ | 特殊性质 |\n| :--------: | :------: | :----: | :------: | :------: |\n|    $1$     |   $5$    | $1000$ |  $1000$  | $\\times$ |\n|    $2$     |   $10$   | $1000$ |  $10^6$  | $\\times$ |\n|    $3$     |   $25$   | $10^6$ |  $1000$  | $\\times$ |\n|    $4$     |   $30$   | $10^6$ |  $10^6$  | $\\surd$  |\n|    $5$     |   $30 $   | $10^6$ |  $10^6$  | $\\times$ |\n\n\n\n上表中的“特殊性质”为：$s_1, \\cdots, s_{l - 1}$ 各不相同，且 $s_{r + 1}, \\cdots, s_n$ 各不相同。", "locale": "zh-CN"}}}
{"pid": "P8987", "type": "P", "difficulty": 7, "samples": [["15 15\n6 14 14 6 3 6 4 13 10 3 12 5 11 9 6\n1 9\n1 2\n2\n2\n2\n1 11\n3 4 6\n2\n1 6\n2\n1 9\n1 11\n1 11\n3 4 4\n3 2 13", "33\n9\n107\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "O2优化", "CTT（清华集训/北大集训）"], "title": "[北大集训 2021] 简单数据结构", "background": "CTT2021 D2T1", "description": "小 D 是一位数据结构大师，他特别喜欢研究形式简单的数据结构，今天他想到了这样一道题目：\n\n你有一个长度为 $n$ 的序列 $a$，下面你要进行 $q$ 次修改或询问。\n\n1. 给定 $v$，将所有 $a_i$ 变为 $\\min(a_i, v)$。\n2. 将所有 $a_i$ 变为 $a_i + i$。\n3. 给定 $l, r$，询问 $\\sum_{i=l}^r a_i$。\n\n顶级数据结构大师小 D 轻松的解决了这个问题，现在他打算来考考即将参加 IOI2022 的你，相信你也可以轻松解决这个问题。", "inputFormat": "第一行两个正整数 $n, q$，表示序列的长度与修改/询问的个数。\n\n下面一行 $n$ 个整数 $a_i$，表示初始序列 $a$。\n\n下面 $q$ 行，每行第一个正整数 $op_i$ 表示第 $i$ 次修改/询问的类型。\n\n若 $op_i = 1$，则下面紧跟一个整数 $v_i$，表示进行一次修改 1。\n\n若 $op_i = 2$，则表示进行一次修改 2。\n\n若 $op_i = 3$，则下面紧跟两个正整数 $l_i, r_i$，表示进行一次询问 3。\n", "outputFormat": "若干行，每行一个整数表示答案。", "hint": "| 子任务编号 | 子任务分值 |  $n,q$   |   特殊性质   |\n| :--------: | :--------: | :------: | :----------: |\n|    $1$     |    $10$    |  $5000$  |              |\n|    $2$     |    $20$    | $200000$ |      A       |\n|    $3$     |    $15$    | $200000$ | $op_i\\neq 2$ |\n|    $4$     |    $55$    | $200000$ |              |\n\n\n\n\n$1 \\leq n, q \\leq 2 \\times 10^5$，$0 \\leq a_i, v_i \\leq 10^{12}$。\n\n性质 A 为：$a_i, v_i$ 在 $[0, 10^{12}]$ 随机生成，$op_i$ 在 $[1, 3]$ 随机生成，$[l_i, r_i]$ 在所有可行区间随机生成。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[北大集训 2021] 简单数据结构", "background": "CTT2021 D2T1", "description": "小 D 是一位数据结构大师，他特别喜欢研究形式简单的数据结构，今天他想到了这样一道题目：\n\n你有一个长度为 $n$ 的序列 $a$，下面你要进行 $q$ 次修改或询问。\n\n1. 给定 $v$，将所有 $a_i$ 变为 $\\min(a_i, v)$。\n2. 将所有 $a_i$ 变为 $a_i + i$。\n3. 给定 $l, r$，询问 $\\sum_{i=l}^r a_i$。\n\n顶级数据结构大师小 D 轻松的解决了这个问题，现在他打算来考考即将参加 IOI2022 的你，相信你也可以轻松解决这个问题。", "inputFormat": "第一行两个正整数 $n, q$，表示序列的长度与修改/询问的个数。\n\n下面一行 $n$ 个整数 $a_i$，表示初始序列 $a$。\n\n下面 $q$ 行，每行第一个正整数 $op_i$ 表示第 $i$ 次修改/询问的类型。\n\n若 $op_i = 1$，则下面紧跟一个整数 $v_i$，表示进行一次修改 1。\n\n若 $op_i = 2$，则表示进行一次修改 2。\n\n若 $op_i = 3$，则下面紧跟两个正整数 $l_i, r_i$，表示进行一次询问 3。\n", "outputFormat": "若干行，每行一个整数表示答案。", "hint": "| 子任务编号 | 子任务分值 |  $n,q$   |   特殊性质   |\n| :--------: | :--------: | :------: | :----------: |\n|    $1$     |    $10$    |  $5000$  |              |\n|    $2$     |    $20$    | $200000$ |      A       |\n|    $3$     |    $15$    | $200000$ | $op_i\\neq 2$ |\n|    $4$     |    $55$    | $200000$ |              |\n\n\n\n\n$1 \\leq n, q \\leq 2 \\times 10^5$，$0 \\leq a_i, v_i \\leq 10^{12}$。\n\n性质 A 为：$a_i, v_i$ 在 $[0, 10^{12}]$ 随机生成，$op_i$ 在 $[1, 3]$ 随机生成，$[l_i, r_i]$ 在所有可行区间随机生成。\n", "locale": "zh-CN"}}}
{"pid": "P8988", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "交互题", "Special Judge", "O2优化", "CTT（清华集训/北大集训）"], "title": "[北大集训 2021] Datalab", "background": "CTT2021 D2T2\n\n**特别提醒，由于洛谷交互机制的特殊性，你不能在程序中引用 `datalab.h`，而需要把 `datalab.h` 中的内容加入文件的开头。即，在程序中 `solve` 函数的前面加入以下几行语句：**\n\n```cpp\n#include<bitset>\n#include<vector>\ntypedef std::bitset<8192> Bitset;\nBitset Add(Bitset A,Bitset B);\nstd::vector<int> solve(int k,int LIMIT);\n```", "description": "**这是一道交互题。**\n\n在 AutoLab 平台上有一台奇怪的 $k$ 位计算机，其中 $k$ 是一个固定的常数 $8192 = 2^{13}$。这台计算机的字长恰好为 $\\frac{k}{8} = 1024 = 2^{10}$，且其存储整数的方式如下：\n\n每个整数会存储在连续的 $k$ 个 bit 中。假设将这 $k$ 个连续 bit 的值按照下标从小到大顺次排列后得到的长度为 $k$ 的 01 字符串为 $S$。假设 $S$ 的下标从 $0$ 开始，则这个字符串 $S$ 对应的整数值为 $f(S) = \\sum \\limits_{i=0}^{k-1} [S_i=1] sgn_i 2^i$，其中 $sgn$ 是一个小 W 预先定义的长度为 $k$ 的数组，其下标从 $0$ 开始且 $\\forall 0 \\le i < k,sgn_i \\in \\{-1,1\\}$。出于某些特殊的原因，这台计算机上保证了 $sgn_{k-1} = 1$，$sgn_{k-2} = -1$。而你不知道 $sgn_0,sgn_1,\\cdots,sgn_{k-3}$ 的值。\n\n假设 $L = \\sum \\limits_{i=0}^{k-1} \\min\\{0,sgn_i\\} 2^i$，$R = \\sum \\limits_{i=0}^{k-1} \\max\\{0,sgn_i\\} 2^i$，则发现 $\\forall L \\le x \\le R$，恰好有一个长度为 $k$ 的 01 字符串 $f(T)$，使得 $f(T) = x$（证明略去）。不妨设所有 $[L,R]$ 内的整数构成的集合为 $S$，则 $f$ 是一个从 $\\{0,1\\}^n$ 到 $S$ 的双射。据此我们可以设 $f(x)$ 的反函数 $g(x)$ 存在，且其满足 $\\forall x \\in S,f(g(x)) = x$。\n\n假设存在 $x,y \\in S$ ，则在该计算机上两个整数之间的加法 $\\oplus$ 被定义为 $x \\oplus y \\overset{def}{=} (x + y - L + 2^k) \\bmod 2^k + L$。不难发现 $\\forall x,y \\in S,x \\oplus y \\in S$。因而在这台计算机上加法满足封闭性。同时按照如上规则定义的加法也满足交换律，结合律等性质。这些性质的证明也同样略去。\n\n学生可以通过有限次的询问获得和 $sgn_i$ 相关的信息。每次询问你可以给计算机两个长度为 $k$ 的仅包含 $0,1$ 的字符串 $x,y$，而计算机会返回 $g(f(x) \\oplus f(y))$ 的值。本次的作业要求是在不超过 $m$ 次的询问中求出 $sgn_0,sgn_1,\\cdots,sgn_{k-3}$ 的准确值。\n\n小 Z 是一名聪明绝顶的学生，因而他尝试使用他的 $10^3 \\mathrm{Hz}$ 的超强大脑来手算出每次交互的值。但是他发现给他的处理速度还是跟不上庞大的数据规模。因而它请你帮忙写一个程序，帮助他更快速的完成本次的作业。\n\n---\n\n### 任务\n\n你不需要，也不应该实现主函数，你只需要实现如下一个函数：\n\n1. `std::vector<int> solve(int k,int m)`：\n\n\t- 传入数字的是计算机的字长 $k$ 和询问次数限制 $\\mathrm{m}$。\n\t- 你需要返回一个大小为 $k$ 的 `vector`，其第 $i$ 个元素代表你确定的 $sgn_i$ 的值。\n\n你可以通过如下函数调用 Autolab 上的加法操作。\n\n1. `std::bitset<8192> Add(std::bitset<8192> x,std::bitset<8192> y)`：\n\t- 给定两个大小为 $k$ 的 bitset, 每个 bitset 自低位向高位阅读的结果代表了一个长度为 $k$ 的仅包含 01 的字符串。\n\t- 返回一个大小为 $k$ 的 bitset, 表示 $g(f(x) \\oplus f(y))$ 的值。返回的格式和输入的格式相同。\n\n根据题目要求，你至多只能询问 $\\mathrm{m}$ 次两个整数在这台计算机上的加法结果。也就是说你至多只能调用 $\\mathrm{m}$ 次 `Add` 函数。\n\n评测时，交互库会**恰好**调用 `solve` 一次。\n\n**本题保证所使用的数组 `sgn` 在开始之前已经完全确定，不会根据和你的程序的交互过程动态构造，因此题目中的交互操作都是确定性的，你不需要关心这些操作在交互库中的具体实现。**\n\n**数据保证在调用次数限制下，交互库运行所需的时间不超过 1s；交互库使用的内存大小固定，且不超过 128MB。**\n\n---\n\n### 如何测试你的程序\n\n**试题目录下的 `grader.cpp` 是我们提供的交互库参考实现，最终测试时所用的交互库实现与该参考实现有所不同，因此选手的解法不应该依赖交互库实现。**\n\n1. 你需要在本题目录下使用如下命令编译得到可执行程序：\n   - `g++ grader.cpp sample.cpp -o sample -O2 -lm`\n\n2. 对于编译得到的可执行程序：\n   - 可执行文件将从**标准输入**读入以下格式的数据：\n     - 第一行包含两个整数 $k,\\mathrm{m}$。\n     - 接下来一行 $k$ 个整数，第 $i$ 个数字表示 $sgn_i$。\n   - 读入完成之后，交互库将调用恰好一次函数 $\\texttt{solve}$ 你的函数正确返回后，交互库会判断你的计算是否正确，若正确则会输出 `Correct` 和交互函数调用次数相关信息，否则会输出相应的错误信息。\n\n试题目录下有出题人提供的一份参考代码 `sample.cpp`，注意这份代码 **不保证可以通过所有的测试用例**。\n\n---\n\n### 样例一、二\n\n见附件下载。\n\n这两个样例满足可执行程序的输入格式，因而可以直接输入到可执行程序中。", "inputFormat": "", "outputFormat": "", "hint": "### 评分方式\n\n| subtask | $k$ | $m$ |\n| :----------: | :----------: | :----------: |\n| 1 | $=8192=2^{13}$ | $=8200$ |\n| 2 | $=8192=2^{13}$ | $=5550$ |\n| 3 | $=8192=2^{13}$ | $=4096=2^{12}$ |\n\n对于任意一个子任务中的数据，如果在某一个数据上选手返回了错误的答案，或者是超出了询问次数限制，得分为 $0$。\n\n否则假设在子任务内所有测试点中，询问次数的最大值为 $a$，则对于每个子任务，选手得分为：\n\n- Subtask $1$: $10$\n- Subtask $2$: $15$\n- Subtask $3$: $\\min \\{75,\\lfloor \\frac{13800}{\\max\\{a,1\\}} \\rfloor \\}$\n\n换而言之，当且仅当 $a \\le 184$ 的时候，Subtask $3$ 可以获得满分。\n\n选手在本题为本题三个子任务的得分之和。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[北大集训 2021] Datalab", "background": "CTT2021 D2T2\n\n**特别提醒，由于洛谷交互机制的特殊性，你不能在程序中引用 `datalab.h`，而需要把 `datalab.h` 中的内容加入文件的开头。即，在程序中 `solve` 函数的前面加入以下几行语句：**\n\n```cpp\n#include<bitset>\n#include<vector>\ntypedef std::bitset<8192> Bitset;\nBitset Add(Bitset A,Bitset B);\nstd::vector<int> solve(int k,int LIMIT);\n```", "description": "**这是一道交互题。**\n\n在 AutoLab 平台上有一台奇怪的 $k$ 位计算机，其中 $k$ 是一个固定的常数 $8192 = 2^{13}$。这台计算机的字长恰好为 $\\frac{k}{8} = 1024 = 2^{10}$，且其存储整数的方式如下：\n\n每个整数会存储在连续的 $k$ 个 bit 中。假设将这 $k$ 个连续 bit 的值按照下标从小到大顺次排列后得到的长度为 $k$ 的 01 字符串为 $S$。假设 $S$ 的下标从 $0$ 开始，则这个字符串 $S$ 对应的整数值为 $f(S) = \\sum \\limits_{i=0}^{k-1} [S_i=1] sgn_i 2^i$，其中 $sgn$ 是一个小 W 预先定义的长度为 $k$ 的数组，其下标从 $0$ 开始且 $\\forall 0 \\le i < k,sgn_i \\in \\{-1,1\\}$。出于某些特殊的原因，这台计算机上保证了 $sgn_{k-1} = 1$，$sgn_{k-2} = -1$。而你不知道 $sgn_0,sgn_1,\\cdots,sgn_{k-3}$ 的值。\n\n假设 $L = \\sum \\limits_{i=0}^{k-1} \\min\\{0,sgn_i\\} 2^i$，$R = \\sum \\limits_{i=0}^{k-1} \\max\\{0,sgn_i\\} 2^i$，则发现 $\\forall L \\le x \\le R$，恰好有一个长度为 $k$ 的 01 字符串 $f(T)$，使得 $f(T) = x$（证明略去）。不妨设所有 $[L,R]$ 内的整数构成的集合为 $S$，则 $f$ 是一个从 $\\{0,1\\}^n$ 到 $S$ 的双射。据此我们可以设 $f(x)$ 的反函数 $g(x)$ 存在，且其满足 $\\forall x \\in S,f(g(x)) = x$。\n\n假设存在 $x,y \\in S$ ，则在该计算机上两个整数之间的加法 $\\oplus$ 被定义为 $x \\oplus y \\overset{def}{=} (x + y - L + 2^k) \\bmod 2^k + L$。不难发现 $\\forall x,y \\in S,x \\oplus y \\in S$。因而在这台计算机上加法满足封闭性。同时按照如上规则定义的加法也满足交换律，结合律等性质。这些性质的证明也同样略去。\n\n学生可以通过有限次的询问获得和 $sgn_i$ 相关的信息。每次询问你可以给计算机两个长度为 $k$ 的仅包含 $0,1$ 的字符串 $x,y$，而计算机会返回 $g(f(x) \\oplus f(y))$ 的值。本次的作业要求是在不超过 $m$ 次的询问中求出 $sgn_0,sgn_1,\\cdots,sgn_{k-3}$ 的准确值。\n\n小 Z 是一名聪明绝顶的学生，因而他尝试使用他的 $10^3 \\mathrm{Hz}$ 的超强大脑来手算出每次交互的值。但是他发现给他的处理速度还是跟不上庞大的数据规模。因而它请你帮忙写一个程序，帮助他更快速的完成本次的作业。\n\n---\n\n### 任务\n\n你不需要，也不应该实现主函数，你只需要实现如下一个函数：\n\n1. `std::vector<int> solve(int k,int m)`：\n\n\t- 传入数字的是计算机的字长 $k$ 和询问次数限制 $\\mathrm{m}$。\n\t- 你需要返回一个大小为 $k$ 的 `vector`，其第 $i$ 个元素代表你确定的 $sgn_i$ 的值。\n\n你可以通过如下函数调用 Autolab 上的加法操作。\n\n1. `std::bitset<8192> Add(std::bitset<8192> x,std::bitset<8192> y)`：\n\t- 给定两个大小为 $k$ 的 bitset, 每个 bitset 自低位向高位阅读的结果代表了一个长度为 $k$ 的仅包含 01 的字符串。\n\t- 返回一个大小为 $k$ 的 bitset, 表示 $g(f(x) \\oplus f(y))$ 的值。返回的格式和输入的格式相同。\n\n根据题目要求，你至多只能询问 $\\mathrm{m}$ 次两个整数在这台计算机上的加法结果。也就是说你至多只能调用 $\\mathrm{m}$ 次 `Add` 函数。\n\n评测时，交互库会**恰好**调用 `solve` 一次。\n\n**本题保证所使用的数组 `sgn` 在开始之前已经完全确定，不会根据和你的程序的交互过程动态构造，因此题目中的交互操作都是确定性的，你不需要关心这些操作在交互库中的具体实现。**\n\n**数据保证在调用次数限制下，交互库运行所需的时间不超过 1s；交互库使用的内存大小固定，且不超过 128MB。**\n\n---\n\n### 如何测试你的程序\n\n**试题目录下的 `grader.cpp` 是我们提供的交互库参考实现，最终测试时所用的交互库实现与该参考实现有所不同，因此选手的解法不应该依赖交互库实现。**\n\n1. 你需要在本题目录下使用如下命令编译得到可执行程序：\n   - `g++ grader.cpp sample.cpp -o sample -O2 -lm`\n\n2. 对于编译得到的可执行程序：\n   - 可执行文件将从**标准输入**读入以下格式的数据：\n     - 第一行包含两个整数 $k,\\mathrm{m}$。\n     - 接下来一行 $k$ 个整数，第 $i$ 个数字表示 $sgn_i$。\n   - 读入完成之后，交互库将调用恰好一次函数 $\\texttt{solve}$ 你的函数正确返回后，交互库会判断你的计算是否正确，若正确则会输出 `Correct` 和交互函数调用次数相关信息，否则会输出相应的错误信息。\n\n试题目录下有出题人提供的一份参考代码 `sample.cpp`，注意这份代码 **不保证可以通过所有的测试用例**。\n\n---\n\n### 样例一、二\n\n见附件下载。\n\n这两个样例满足可执行程序的输入格式，因而可以直接输入到可执行程序中。", "inputFormat": "", "outputFormat": "", "hint": "### 评分方式\n\n| subtask | $k$ | $m$ |\n| :----------: | :----------: | :----------: |\n| 1 | $=8192=2^{13}$ | $=8200$ |\n| 2 | $=8192=2^{13}$ | $=5550$ |\n| 3 | $=8192=2^{13}$ | $=4096=2^{12}$ |\n\n对于任意一个子任务中的数据，如果在某一个数据上选手返回了错误的答案，或者是超出了询问次数限制，得分为 $0$。\n\n否则假设在子任务内所有测试点中，询问次数的最大值为 $a$，则对于每个子任务，选手得分为：\n\n- Subtask $1$: $10$\n- Subtask $2$: $15$\n- Subtask $3$: $\\min \\{75,\\lfloor \\frac{13800}{\\max\\{a,1\\}} \\rfloor \\}$\n\n换而言之，当且仅当 $a \\le 184$ 的时候，Subtask $3$ 可以获得满分。\n\n选手在本题为本题三个子任务的得分之和。", "locale": "zh-CN"}}}
{"pid": "P8989", "type": "P", "difficulty": 6, "samples": [["4\n3 2 97\n10 25 233\n6 12345 2333\n1000000000 1000000000000000000 1000000007 \n", "6\n131\n1206\n161905971\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "O2优化", "CTT（清华集训/北大集训）"], "title": "[北大集训 2021] 随机游走", "background": "CTT2021 D2T3", "description": "给定一张 $n$ 个点的有向图，点标号为 $1,2,\\dots,n$，初始时对 $\\forall i\\in\\{1,2,\\dots,n-1\\}$，从 $i$ 到 $i+1$ 有一条有向边。\n\n你可以在其中再加入 $m$ 条有向边（起点终点任意），允许有重边和自环。\n\n小 A 会从 $1$ 出发，以随机游走的形式行动，直到抵达 $n$。你希望最大化小 A 从 $1$ 移动到 $n$ 的期望步数。\n\n定义随机游走是这样的一种移动方式：设小 A 当前在点 $x$，$x$ 有 $d$ 条出边，则小 A 会从这 $d$ 条出边中**等概率**随机选择一条走过去。", "inputFormat": "输入的第一行包含一个正整数 $T$，表示数据组数，保证 $T \\le 10^5$。\n\n接下来 $T$ 行，每行包含三个整数 $n,m,p$，分别表示有向图的点数、你添加的边数以及答案的模数，保证 $1 \\leq n \\leq 10^9$，$0 \\leq m \\leq 10^{18}$，$2\\leq p\\leq 10^9+7$ 且 $p$ 是质数。\n", "outputFormat": "输出 $T$ 行，第 $i$ 行一个整数 $ans$ 表示第 $i$ 组数据中最大的期望步数对 $p$ 取模后的值（可以证明答案是有理数，设其用最简分数表示为 $\\frac{a}{b}$，则你需要满足 $ans \\cdot b \\bmod p=a$，保证这样的 $ans$ 存在）。", "hint": "| 测试包编号 | $n\\le$ |  $m\\le$   | $T\\le$ | 特殊性质 | 分数 |\n| :--------: | :----: | :-------: | :----: | :------: | :--: |\n|    $1$     |  $5$   |    $5$    |  $10$  |    无    | $10$ |\n|    $2$     |  $5$   |  $10^2$   |  $10$  |    无    | $10 $ |\n|    $3$     | $10^8$ |  $10^2$   | $10^2$ |    无    | $20$ |\n|    $4$     |  $50$  |  $3,000$  |  $3$   |    无    | $20 $ |\n|    $5$     | $10^9$ |  $10^9$   | $10^5$ | $m<n-1$  | $10$ |\n|    $6$     | $10^9$ | $10^{18}$ | $10^5$ |    无    | $30$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[北大集训 2021] 随机游走", "background": "CTT2021 D2T3", "description": "给定一张 $n$ 个点的有向图，点标号为 $1,2,\\dots,n$，初始时对 $\\forall i\\in\\{1,2,\\dots,n-1\\}$，从 $i$ 到 $i+1$ 有一条有向边。\n\n你可以在其中再加入 $m$ 条有向边（起点终点任意），允许有重边和自环。\n\n小 A 会从 $1$ 出发，以随机游走的形式行动，直到抵达 $n$。你希望最大化小 A 从 $1$ 移动到 $n$ 的期望步数。\n\n定义随机游走是这样的一种移动方式：设小 A 当前在点 $x$，$x$ 有 $d$ 条出边，则小 A 会从这 $d$ 条出边中**等概率**随机选择一条走过去。", "inputFormat": "输入的第一行包含一个正整数 $T$，表示数据组数，保证 $T \\le 10^5$。\n\n接下来 $T$ 行，每行包含三个整数 $n,m,p$，分别表示有向图的点数、你添加的边数以及答案的模数，保证 $1 \\leq n \\leq 10^9$，$0 \\leq m \\leq 10^{18}$，$2\\leq p\\leq 10^9+7$ 且 $p$ 是质数。\n", "outputFormat": "输出 $T$ 行，第 $i$ 行一个整数 $ans$ 表示第 $i$ 组数据中最大的期望步数对 $p$ 取模后的值（可以证明答案是有理数，设其用最简分数表示为 $\\frac{a}{b}$，则你需要满足 $ans \\cdot b \\bmod p=a$，保证这样的 $ans$ 存在）。", "hint": "| 测试包编号 | $n\\le$ |  $m\\le$   | $T\\le$ | 特殊性质 | 分数 |\n| :--------: | :----: | :-------: | :----: | :------: | :--: |\n|    $1$     |  $5$   |    $5$    |  $10$  |    无    | $10$ |\n|    $2$     |  $5$   |  $10^2$   |  $10$  |    无    | $10 $ |\n|    $3$     | $10^8$ |  $10^2$   | $10^2$ |    无    | $20$ |\n|    $4$     |  $50$  |  $3,000$  |  $3$   |    无    | $20 $ |\n|    $5$     | $10^9$ |  $10^9$   | $10^5$ | $m<n-1$  | $10$ |\n|    $6$     | $10^9$ | $10^{18}$ | $10^5$ |    无    | $30$ |\n", "locale": "zh-CN"}}}
{"pid": "P8990", "type": "P", "difficulty": 7, "samples": [["10 10\n2 1\n3 1\n4 2\n5 1\n6 4\n7 6\n8 5\n9 4\n10 1\n6 4 2 7 8 9 10 3 5\n6 7 10 7\n1 5 8 9\n1 2 10 8\n10 8 7 6\n2 4 2 9\n8 9 1 5\n5 8 8 2\n2 9 10 8\n10 7 4 10\n10 8 8 9\n", "13\n15\n4\n6\n2\n2\n10\n7\n8\n8\n7\n"], ["10 10\n2 1\n3 2\n4 3\n5 4\n6 2\n7 5\n8 7\n9 1\n10 8\n6 8 3 9 2 5 7 10 4 \n1 9 3 9\n4 5 2 7\n2 7 6 7\n8 10 10 1\n6 7 8 1\n3 9 9 8\n1 2 7 3\n2 3 2 9\n8 1 1 7\n2 9 2 8\n", "3\n2\n2\n1\n2\n4\n4\n3\n3\n3\n3\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "O2优化", "CTT（清华集训/北大集训）"], "title": "[北大集训 2021] 小明的树", "background": "CTT2021 D3T1", "description": "小明有一棵以 $1$ 为根的 $n$ 个节点的树，树上每一个非根节点上有一盏灯，他有一个 $2 \\thicksim n$ 的排列 $a_1,a_2,\\dots,a_{n-1}$。他还有一个计数器，初始为 $0$。\n\n他会按照排列依次点亮这 $n-1$ 盏灯，每进行一次点灯操作后，他会检查整个树是否是美丽的，如果是美丽的，计数器会加上此时点灯的节点形成的连通块的个数。\n\n$n-1$ 次点灯后计数器的值，记为这棵树的答案。\n\t\t\t\t\n\n一个树是美丽的当前仅当对于每一个被点亮的节点，这个节点子树内的节点都是点亮的。\n\n小明认为这个问题太简单了，他觉得应该让树动起来。\n\n在初始查询后，他会删掉树中一条边并加上一条边，保证修改后还是一棵树，他想知道每一次修改后将计数器清零后重新点灯并计数，这棵树的答案是多少。", "inputFormat": "第一行两个数 $n,m$ ,表示树的节点数为 $n$，有 $m$ 次修改。\n\n接下来 $n-1$ 行，每行 $2$ 个数，表示一条边。\n\n下一行 $n-1$ 个数 $a_i$，表示一个 $2 \\thicksim n$ 的排列。\n\n接下来 $m$ 行每行四个数，$x_1,y_1,x_2,y_2$ 表示断开 $x_1,y_1$ 间的边并连接 $x_2,y_2$，保证数据合法。", "outputFormat": "共 $m+1$ 行，第一行表示初始树的答案。\n\n接下来 $m$ 行，表示每次修改后树的答案。", "hint": "- 子任务 $1$（$10$ 分）：保证满足 $2 \\leq n \\leq 500000$，$m = 0$。\n\n- 子任务 $2$（$20$ 分）：保证满足 $2 \\leq n \\leq 8000$，$0 \\leq m \\leq 8000$。\n\n- 子任务 $3$（$70$ 分）：保证满足 $2 \\leq n \\leq 500000$，$0\\leq m \\leq 500000$。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[北大集训 2021] 小明的树", "background": "CTT2021 D3T1", "description": "小明有一棵以 $1$ 为根的 $n$ 个节点的树，树上每一个非根节点上有一盏灯，他有一个 $2 \\thicksim n$ 的排列 $a_1,a_2,\\dots,a_{n-1}$。他还有一个计数器，初始为 $0$。\n\n他会按照排列依次点亮这 $n-1$ 盏灯，每进行一次点灯操作后，他会检查整个树是否是美丽的，如果是美丽的，计数器会加上此时点灯的节点形成的连通块的个数。\n\n$n-1$ 次点灯后计数器的值，记为这棵树的答案。\n\t\t\t\t\n\n一个树是美丽的当前仅当对于每一个被点亮的节点，这个节点子树内的节点都是点亮的。\n\n小明认为这个问题太简单了，他觉得应该让树动起来。\n\n在初始查询后，他会删掉树中一条边并加上一条边，保证修改后还是一棵树，他想知道每一次修改后将计数器清零后重新点灯并计数，这棵树的答案是多少。", "inputFormat": "第一行两个数 $n,m$ ,表示树的节点数为 $n$，有 $m$ 次修改。\n\n接下来 $n-1$ 行，每行 $2$ 个数，表示一条边。\n\n下一行 $n-1$ 个数 $a_i$，表示一个 $2 \\thicksim n$ 的排列。\n\n接下来 $m$ 行每行四个数，$x_1,y_1,x_2,y_2$ 表示断开 $x_1,y_1$ 间的边并连接 $x_2,y_2$，保证数据合法。", "outputFormat": "共 $m+1$ 行，第一行表示初始树的答案。\n\n接下来 $m$ 行，表示每次修改后树的答案。", "hint": "- 子任务 $1$（$10$ 分）：保证满足 $2 \\leq n \\leq 500000$，$m = 0$。\n\n- 子任务 $2$（$20$ 分）：保证满足 $2 \\leq n \\leq 8000$，$0 \\leq m \\leq 8000$。\n\n- 子任务 $3$（$70$ 分）：保证满足 $2 \\leq n \\leq 500000$，$0\\leq m \\leq 500000$。\n\n", "locale": "zh-CN"}}}
{"pid": "P8991", "type": "P", "difficulty": 6, "samples": [["5\n-962 -445 -613 -9 920\n3\n1 5\n3 5\n1 3\n", "4080400 3\n846400 1\n4080400 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "O2优化", "CTT（清华集训/北大集训）"], "title": "[北大集训 2021] 出题高手", "background": "CTT2021 D3T2", "description": "Alice 是一个出题高手。\n\nAlice 每天都会出一道题，这样 $n$ 天过去，她就出了 $n$ 道题了。\n\n第 $n+1$ 天，Alice 没有出题，她打算从之前的 $n$ 道题中选择若干道组成一个比赛。方便起见，她决定这些选择的题目得是**连续**的一个时间段出的，也就是这些题目必须形如：第 $l$ 天到第 $r$ 天出的所有题目（$1\\le l \\le r \\le n$）。\n\nAlice 还给每个题目一个评分，第 $i$ 个题目的评分为 $a_i(-1000 \\le a_i \\le 1001)$ ，评分越高代表这道题越偏智商，评分越低说明这道题越偏码力。\n\nAlice 希望组成的比赛具备特色，也即整体偏向代码或者整体偏向智商。一场以 Alice 第 $l$ 天到第 $r$ 天出的题目组成的比赛的特色程度定义为 $\\Large \\frac{(\\sum_l^r a_i)^2}{r-l+1}$ ，Alice 想要**最大化**这个特色程度。\n\n现在，对于 $m$ 个形如 $ql_i,qr_i$ 的询问，你需要回答如果将 Alice  能选择的题目限定在第 $ql_i$ 到 $qr_i$ 天出的题，Alice 能组成的特色程度最大的比赛的特色程度是多少，你需要以分数的形式输出这个特色程度。\n\n由于 Alice 出题的水平过于高超，你可以认为每道题的评分是**随机生成**的。\n", "inputFormat": "\n输入的第一行包含一个正整数 $n$。\n\n输入的第二行包含 $n$ 个整数 $a_1 \\dots a_n$，代表 Alice 对第 $i$ 天所出的题的评分。\n\n输入的第三行包含一个正整数 $m$。\n\n接下来 $m$ 行，每行输入两个正整数 $ql_i,qr_i$，表示询问。\n", "outputFormat": "共 $m$ 行，每行两个整数 $p_i,q_i$，满足 $\\gcd(p_i,q_i)=1$，表示答案为 $\\frac{p_i}{q_i}$，若答案为 $0$，则 $p_i=0$，$q_i=1$。", "hint": "| 子任务 |   $n=$   |   $m=$   | 分值 |\n| :----: | :------: | :------: | :--: |\n|  $1$   |  $2000$  | $100000$ | $5$  |\n|  $2$   | $100000$ |   $1$    | $15$ |\n|  $3$   | $500000$ |   $1$    | $30$ |\n|  $4$   | $100000$ |  $5000$  | $15$ |\n|  $5$   | $100000$ | $300000$ | $35$ |\n\n\n\n对于 第 $2$ 个和第 $3$ 个子任务，保证所有询问满足 $ql_i = 1$，$qr_i = n$。\n\n所有的 $a_i$ 保证满足 $-1000 \\le a_i \\le 1001$。且对于 $a_i$ ，数据生成方式为每次独立地从 $[-1000,1001]$ 中等概率随机选取一个整数。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[北大集训 2021] 出题高手", "background": "CTT2021 D3T2", "description": "Alice 是一个出题高手。\n\nAlice 每天都会出一道题，这样 $n$ 天过去，她就出了 $n$ 道题了。\n\n第 $n+1$ 天，Alice 没有出题，她打算从之前的 $n$ 道题中选择若干道组成一个比赛。方便起见，她决定这些选择的题目得是**连续**的一个时间段出的，也就是这些题目必须形如：第 $l$ 天到第 $r$ 天出的所有题目（$1\\le l \\le r \\le n$）。\n\nAlice 还给每个题目一个评分，第 $i$ 个题目的评分为 $a_i(-1000 \\le a_i \\le 1001)$ ，评分越高代表这道题越偏智商，评分越低说明这道题越偏码力。\n\nAlice 希望组成的比赛具备特色，也即整体偏向代码或者整体偏向智商。一场以 Alice 第 $l$ 天到第 $r$ 天出的题目组成的比赛的特色程度定义为 $\\Large \\frac{(\\sum_l^r a_i)^2}{r-l+1}$ ，Alice 想要**最大化**这个特色程度。\n\n现在，对于 $m$ 个形如 $ql_i,qr_i$ 的询问，你需要回答如果将 Alice  能选择的题目限定在第 $ql_i$ 到 $qr_i$ 天出的题，Alice 能组成的特色程度最大的比赛的特色程度是多少，你需要以分数的形式输出这个特色程度。\n\n由于 Alice 出题的水平过于高超，你可以认为每道题的评分是**随机生成**的。\n", "inputFormat": "\n输入的第一行包含一个正整数 $n$。\n\n输入的第二行包含 $n$ 个整数 $a_1 \\dots a_n$，代表 Alice 对第 $i$ 天所出的题的评分。\n\n输入的第三行包含一个正整数 $m$。\n\n接下来 $m$ 行，每行输入两个正整数 $ql_i,qr_i$，表示询问。\n", "outputFormat": "共 $m$ 行，每行两个整数 $p_i,q_i$，满足 $\\gcd(p_i,q_i)=1$，表示答案为 $\\frac{p_i}{q_i}$，若答案为 $0$，则 $p_i=0$，$q_i=1$。", "hint": "| 子任务 |   $n=$   |   $m=$   | 分值 |\n| :----: | :------: | :------: | :--: |\n|  $1$   |  $2000$  | $100000$ | $5$  |\n|  $2$   | $100000$ |   $1$    | $15$ |\n|  $3$   | $500000$ |   $1$    | $30$ |\n|  $4$   | $100000$ |  $5000$  | $15$ |\n|  $5$   | $100000$ | $300000$ | $35$ |\n\n\n\n对于 第 $2$ 个和第 $3$ 个子任务，保证所有询问满足 $ql_i = 1$，$qr_i = n$。\n\n所有的 $a_i$ 保证满足 $-1000 \\le a_i \\le 1001$。且对于 $a_i$ ，数据生成方式为每次独立地从 $[-1000,1001]$ 中等概率随机选取一个整数。\n", "locale": "zh-CN"}}}
{"pid": "P8992", "type": "P", "difficulty": 7, "samples": [["abbab\n5 0\n1 3\n2 4\n3 5\n1 4\n2 5\n", "4\n7\n6\n2\n8\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2021", "O2优化", "CTT（清华集训/北大集训）"], "title": "[北大集训 2021] 扑克比大小", "background": "CTT2021 D3T3", "description": "小 $Z$ 和小 $A$ 在玩扑克比大小。\n\n他们玩的扑克比大小规则如下：\n\n- 在游戏开始前，系统会给小 $Z$ 和小 $A$ 各发一堆手牌（两堆牌数量可能不相同），其中每张牌上写有一个小写字母。\n\n- 在游戏的每一轮，小 $Z$ 和小 $A$ 同时翻开**牌堆顶**的第一张牌，若两人翻开的牌不同，则牌上对应小写字母**更小**的那一方获胜；若两人翻开的牌相同，则他们会将翻开的牌塞入**牌堆底**，继续游戏，直到某方获胜为止。\n\n而系统实际上是从一个巨大的牌库里面发牌的，具体来说，假设牌库共有 $n$ 张牌，分别是 $a_1,a_2,\\cdots,a_n$，则系统会随机选择第 $l$ 张到第 $r$ 张牌发给玩家，换言之，玩家**从牌堆顶到牌堆底**的牌分别是 $a_l,a_{l+1},\\cdots,a_r$。\n\n现在小 $Z$ 和小 $A$ 一共要进行 $q$ 轮游戏，并且小 $Z$ 通过某种方式得知了系统在第 $i$ 轮发给小 $A$ 的牌为 $a_{l_i},a_{l_i+1},\\cdots,a_{r_i}$，小 $Z$ 想知道他一共有多少种可能的手牌能赢小 $A$。两堆手牌视为不同当且仅当两堆手牌数量不同，或存在一个位置 $d$ 使得两堆手牌中距离堆顶为 $d$ 的牌不同。\n", "inputFormat": "输入的第一行包含一个只包含小写字母的字符串 $a$ 。\n\n输入的第二行包含一个正整数 $q$ 和一个整数 $type$，其中 $type$ 表示数据类型。\n\n接下来 $q$ 行，第 $i$ 行包含两个整数 $l_i$ 和 $r_i$。\n", "outputFormat": "输出 $q$ 行，每行一个整数表示小 $Z$ 有多少种可能的手牌能赢小 $A$。\n", "hint": "对于所有数据，满足 $1\\le l_i\\le r_i\\le |a| \\le 5\\times 10^5$，$1\\le q \\le 5\\times 10^5$。\n\n| 子任务 | 得分  |     $n\\le$     |     $q\\le$     | $type$ |\n| :----: | :---: | :------------: | :------------: | :----: |\n|  $1$   |  $3$  |     $10^2$     |     $10^2$     |  $0$   |\n|  $2$   |  $3 $  |     $500$      |    $2,000$     |  $0$   |\n|  $3$   |  $4$  |    $2,000$     |    $2,000$     |  $0$   |\n|  $4$   |  $5$  | $2\\times 10^4$ |    $2,000$     |  $0$   |\n|  $5$   | $13$  |     $10^5$     |     $10^5$     |  $3$   |\n|  $6$   | $17$  |     $10^5$     |     $10^5$     |  $0$   |\n|  $7$   | $15$  | $5\\times 10^5$ | $5\\times 10^5$ |  $1$   |\n|  $8$   | $15 $ | $5\\times 10^5$ | $5\\times 10^5$ |  $2$   |\n|  $9$   | $25$  | $5\\times 10^5$ | $5\\times 10^5$ |  $0$   |\n\n\n\n\n数据类型 $type$ 的含义为：\n\n- $type=0$，数据无特殊限制。\n\n- $type=1$，保证 $\\exists 1\\le l'\\le r'\\le |a|$，$a_{l_i,r_i}+a_{l_i,r_i}=a_{l',r'}$。\n\n- $type=2$，保证 $\\forall r'-l'=r_i-l_i+1$，若 $a_{l',r'-1}=a_{l_i,r_i}$，则必有 $a_{r'}\\neq a_{l_i}$。\n\n- $type=3$，保证 $\\sum r_i-l_i \\le 10^5$。\n\n其中 $a_{l,r}$ 表示字符串 $a_la_{l+1}\\cdots a_r$；两个字符串 $a+b$ 的结果为 $a$ 和 $b$ 按顺序拼接的字符串。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[北大集训 2021] 扑克比大小", "background": "CTT2021 D3T3", "description": "小 $Z$ 和小 $A$ 在玩扑克比大小。\n\n他们玩的扑克比大小规则如下：\n\n- 在游戏开始前，系统会给小 $Z$ 和小 $A$ 各发一堆手牌（两堆牌数量可能不相同），其中每张牌上写有一个小写字母。\n\n- 在游戏的每一轮，小 $Z$ 和小 $A$ 同时翻开**牌堆顶**的第一张牌，若两人翻开的牌不同，则牌上对应小写字母**更小**的那一方获胜；若两人翻开的牌相同，则他们会将翻开的牌塞入**牌堆底**，继续游戏，直到某方获胜为止。\n\n而系统实际上是从一个巨大的牌库里面发牌的，具体来说，假设牌库共有 $n$ 张牌，分别是 $a_1,a_2,\\cdots,a_n$，则系统会随机选择第 $l$ 张到第 $r$ 张牌发给玩家，换言之，玩家**从牌堆顶到牌堆底**的牌分别是 $a_l,a_{l+1},\\cdots,a_r$。\n\n现在小 $Z$ 和小 $A$ 一共要进行 $q$ 轮游戏，并且小 $Z$ 通过某种方式得知了系统在第 $i$ 轮发给小 $A$ 的牌为 $a_{l_i},a_{l_i+1},\\cdots,a_{r_i}$，小 $Z$ 想知道他一共有多少种可能的手牌能赢小 $A$。两堆手牌视为不同当且仅当两堆手牌数量不同，或存在一个位置 $d$ 使得两堆手牌中距离堆顶为 $d$ 的牌不同。\n", "inputFormat": "输入的第一行包含一个只包含小写字母的字符串 $a$ 。\n\n输入的第二行包含一个正整数 $q$ 和一个整数 $type$，其中 $type$ 表示数据类型。\n\n接下来 $q$ 行，第 $i$ 行包含两个整数 $l_i$ 和 $r_i$。\n", "outputFormat": "输出 $q$ 行，每行一个整数表示小 $Z$ 有多少种可能的手牌能赢小 $A$。\n", "hint": "对于所有数据，满足 $1\\le l_i\\le r_i\\le |a| \\le 5\\times 10^5$，$1\\le q \\le 5\\times 10^5$。\n\n| 子任务 | 得分  |     $n\\le$     |     $q\\le$     | $type$ |\n| :----: | :---: | :------------: | :------------: | :----: |\n|  $1$   |  $3$  |     $10^2$     |     $10^2$     |  $0$   |\n|  $2$   |  $3 $  |     $500$      |    $2,000$     |  $0$   |\n|  $3$   |  $4$  |    $2,000$     |    $2,000$     |  $0$   |\n|  $4$   |  $5$  | $2\\times 10^4$ |    $2,000$     |  $0$   |\n|  $5$   | $13$  |     $10^5$     |     $10^5$     |  $3$   |\n|  $6$   | $17$  |     $10^5$     |     $10^5$     |  $0$   |\n|  $7$   | $15$  | $5\\times 10^5$ | $5\\times 10^5$ |  $1$   |\n|  $8$   | $15 $ | $5\\times 10^5$ | $5\\times 10^5$ |  $2$   |\n|  $9$   | $25$  | $5\\times 10^5$ | $5\\times 10^5$ |  $0$   |\n\n\n\n\n数据类型 $type$ 的含义为：\n\n- $type=0$，数据无特殊限制。\n\n- $type=1$，保证 $\\exists 1\\le l'\\le r'\\le |a|$，$a_{l_i,r_i}+a_{l_i,r_i}=a_{l',r'}$。\n\n- $type=2$，保证 $\\forall r'-l'=r_i-l_i+1$，若 $a_{l',r'-1}=a_{l_i,r_i}$，则必有 $a_{r'}\\neq a_{l_i}$。\n\n- $type=3$，保证 $\\sum r_i-l_i \\le 10^5$。\n\n其中 $a_{l,r}$ 表示字符串 $a_la_{l+1}\\cdots a_r$；两个字符串 $a+b$ 的结果为 $a$ 和 $b$ 按顺序拼接的字符串。", "locale": "zh-CN"}}}
{"pid": "P8993", "type": "P", "difficulty": 6, "samples": [["2 9\n14\n16", "2\n-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "O2优化", "CTT（清华集训/北大集训）"], "title": "[北大集训 2021] 算术", "background": "CTT2021 D4T1", "description": "今天，生活在 14 进制世界的小 Q 学习了一种判断给定的大数是否是 9 的倍数的方法。我们以 $(1BB40)_{14} = (70812)_{10}$ 作为例子描述该方法，下面设 $b=14$，$p=9$，下面的方法中所有的运算在 $b$ 进制下进行。\n\n1. 从低位往高位，将每个连续的 $k=2$ 位划分为一段。例子中，$(1BB40)_{b}$ 被划分为 $1 \\mid BB \\mid 40$ 三段。\n2. 从低位往高位从 $0$ 开始给每一段编号。例子中，第 $0$ 段为 $40$，第 $1$ 段为 $BB$，第 $2$ 段为 $1$。\n3. 对于第 $i$ 段计算出值 $b_i$：设第 $i$ 段在 $b$ 进制下的值为 $a_i$，如果 $i$ 为奇数则 $b_i$ 为满足 $(a_i+b_i) \\equiv 0 \\pmod p$ 的最小非负整数 $b_i$，如果 $i$ 为偶数则 $b_i$ 为满足 $(a_i-b_i) \\equiv 0 \\pmod p$ 的最小非负整数 $b_i$。例子中有 $b_0=2$，$b_1=6$，$b_2=1$。\n4. 将 $b_i$ 按照**下标大的在低位，下标小的在高位**的顺序顺次拼接，形成一个 $b$ 进制数并输出。例子中输出结果为 $(261)_{b} = (477)_{10}$。容易验证 $477$ 和 $70812$ 都是 $p$ 的倍数。\n\n可以证明上述方法输入和输出的数要么同时是 $p$ 的倍数，要么同时不是 $p$ 的倍数。而且数字的位数变少了，所以多做几次就可以得到一个很小的数，然后就可以简单地判断了。\n\n小 Q 深深地被这个算法吸引了，所以他想给出一个 $b,p$ 不同于 $14,9$ 时的通用方法。但是他发现，当上面的方法中 $b,p$ 的取值变化时，$k$ 不一定等于 $2$：有时会是 $1$，有时会大于 $2$，有时甚至不存在满足条件的 $k$。所以对于给定的 $b, p$，小 Q 想知道在 $b$ 进制下上述方法的第一步中**正整数** $k$ 的最小值，使得无论输入如何，输入和对应的输出要么同时是 $p$ 的倍数，要么同时不是 $p$ 的倍数，或者报告这样的 $k$ 不存在。\n\n注意 $p$ 不一定是质数。\n", "inputFormat": "**测试点有多组测试数据，保证同一测试点下的 $p$ 相同**。输入的第一行包含两个正整数 $T,p$，保证 $1 \\le T \\le 10^5$，$2 \\leq p \\le 10^{15}$，分别表示该组测试点的测试数据组数与方法的 $p$ 参数。\n\n接下来 $T$ 行每行输入一行一个整数 $b$ 表示每组测试数据的进制。保证 $2 \\leq p < b \\leq 10 \\times p$。\n\n**输入中的所有数字按照十进制给出。**\n", "outputFormat": "对于每组数据输出一行，若不存在合法的 $k$ 输出 `-1`，否则输出最小的满足条件的**正整数** $k$。\n", "hint": "| 子任务编号 | $2\\leq p\\leq$ | $1\\leq T\\leq$ | 分值 |\n| :--------: | :-----------: | :-----------: | :--: |\n|    $1$     |      $3$      |     $10$      | $5$  |\n|    $2$     |     $10$      |     $10$      | $5 $  |\n|    $3$     |    $10^2$     |    $10^2$     | $5$  |\n|    $4$     |    $10^4$     |    $10^2$     | $11$ |\n|    $5$     |    $10^6$     |    $10^2$     | $11 $ |\n|    $6$     |    $10^8$     |    $10^3$     | $11$ |\n|    $7$     |   $10^{10}$   |    $10^3$     | $11 $ |\n|    $8$     |   $10^{12}$   |    $10^3$     | $7$  |\n|    $9$     |   $10^{14}$   |    $10^4$     | $17$ |\n|    $10$    |   $10^{15}$   |    $10^5$     | $17 $ |\n\n\n\n\n\n为了选手们的身心健康，下发文件中的 `down.cpp` 中实现了大整数取模乘法函数 `mul(A, B, P)`，你需要保证 $A,B \\in [0,P-1]$，函数会返回 $(A \\times B) \\bmod P$。你可以自由选择使用或者不使用这份代码。**其中需要保证你调用时 $A,B,P$ 均不超过 $10^{15}$。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[北大集训 2021] 算术", "background": "CTT2021 D4T1", "description": "今天，生活在 14 进制世界的小 Q 学习了一种判断给定的大数是否是 9 的倍数的方法。我们以 $(1BB40)_{14} = (70812)_{10}$ 作为例子描述该方法，下面设 $b=14$，$p=9$，下面的方法中所有的运算在 $b$ 进制下进行。\n\n1. 从低位往高位，将每个连续的 $k=2$ 位划分为一段。例子中，$(1BB40)_{b}$ 被划分为 $1 \\mid BB \\mid 40$ 三段。\n2. 从低位往高位从 $0$ 开始给每一段编号。例子中，第 $0$ 段为 $40$，第 $1$ 段为 $BB$，第 $2$ 段为 $1$。\n3. 对于第 $i$ 段计算出值 $b_i$：设第 $i$ 段在 $b$ 进制下的值为 $a_i$，如果 $i$ 为奇数则 $b_i$ 为满足 $(a_i+b_i) \\equiv 0 \\pmod p$ 的最小非负整数 $b_i$，如果 $i$ 为偶数则 $b_i$ 为满足 $(a_i-b_i) \\equiv 0 \\pmod p$ 的最小非负整数 $b_i$。例子中有 $b_0=2$，$b_1=6$，$b_2=1$。\n4. 将 $b_i$ 按照**下标大的在低位，下标小的在高位**的顺序顺次拼接，形成一个 $b$ 进制数并输出。例子中输出结果为 $(261)_{b} = (477)_{10}$。容易验证 $477$ 和 $70812$ 都是 $p$ 的倍数。\n\n可以证明上述方法输入和输出的数要么同时是 $p$ 的倍数，要么同时不是 $p$ 的倍数。而且数字的位数变少了，所以多做几次就可以得到一个很小的数，然后就可以简单地判断了。\n\n小 Q 深深地被这个算法吸引了，所以他想给出一个 $b,p$ 不同于 $14,9$ 时的通用方法。但是他发现，当上面的方法中 $b,p$ 的取值变化时，$k$ 不一定等于 $2$：有时会是 $1$，有时会大于 $2$，有时甚至不存在满足条件的 $k$。所以对于给定的 $b, p$，小 Q 想知道在 $b$ 进制下上述方法的第一步中**正整数** $k$ 的最小值，使得无论输入如何，输入和对应的输出要么同时是 $p$ 的倍数，要么同时不是 $p$ 的倍数，或者报告这样的 $k$ 不存在。\n\n注意 $p$ 不一定是质数。\n", "inputFormat": "**测试点有多组测试数据，保证同一测试点下的 $p$ 相同**。输入的第一行包含两个正整数 $T,p$，保证 $1 \\le T \\le 10^5$，$2 \\leq p \\le 10^{15}$，分别表示该组测试点的测试数据组数与方法的 $p$ 参数。\n\n接下来 $T$ 行每行输入一行一个整数 $b$ 表示每组测试数据的进制。保证 $2 \\leq p < b \\leq 10 \\times p$。\n\n**输入中的所有数字按照十进制给出。**\n", "outputFormat": "对于每组数据输出一行，若不存在合法的 $k$ 输出 `-1`，否则输出最小的满足条件的**正整数** $k$。\n", "hint": "| 子任务编号 | $2\\leq p\\leq$ | $1\\leq T\\leq$ | 分值 |\n| :--------: | :-----------: | :-----------: | :--: |\n|    $1$     |      $3$      |     $10$      | $5$  |\n|    $2$     |     $10$      |     $10$      | $5 $  |\n|    $3$     |    $10^2$     |    $10^2$     | $5$  |\n|    $4$     |    $10^4$     |    $10^2$     | $11$ |\n|    $5$     |    $10^6$     |    $10^2$     | $11 $ |\n|    $6$     |    $10^8$     |    $10^3$     | $11$ |\n|    $7$     |   $10^{10}$   |    $10^3$     | $11 $ |\n|    $8$     |   $10^{12}$   |    $10^3$     | $7$  |\n|    $9$     |   $10^{14}$   |    $10^4$     | $17$ |\n|    $10$    |   $10^{15}$   |    $10^5$     | $17 $ |\n\n\n\n\n\n为了选手们的身心健康，下发文件中的 `down.cpp` 中实现了大整数取模乘法函数 `mul(A, B, P)`，你需要保证 $A,B \\in [0,P-1]$，函数会返回 $(A \\times B) \\bmod P$。你可以自由选择使用或者不使用这份代码。**其中需要保证你调用时 $A,B,P$ 均不超过 $10^{15}$。**", "locale": "zh-CN"}}}
{"pid": "P8994", "type": "P", "difficulty": 6, "samples": [["0\n5 2\n1 2\n1 3\n2 4\n2 5\n1 0 1 0 1\n2 2\n4 4", "2\n1\n"], ["0\n10 10\n6 3\n7 4\n8 2\n2 1\n9 1\n1 3\n3 4\n4 5\n5 10\n0 0 1 1 1 0 1 1 0 0 \n8 3\n2 3\n7 10\n7 3\n6 7\n8 5\n9 8\n2 10\n5 4\n3 9\n", "1\n1\n0\n1\n1\n1\n0\n0\n2\n1\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "O2优化", "CTT（清华集训/北大集训）"], "title": "[北大集训 2021] 经典游戏", "background": "CTT2021 D4T2", "description": "某天，`C` 和 `K` 觉得很无聊，于是决定玩一个经典小游戏：\n\n在一棵有 $n$ 个结点的有根树上，标号为 $i$ 的节点上有 $a_i$ 个棋子。游戏时玩家轮流操作，每次可以将任意一个节点 $u$ 上的一个棋子放置到任意一个点 $v \\in U(u)$上，其中 $U(u)=subtree\\{u\\}\\setminus\\{u\\}$ ，表示 $u$ 的子树内（不包含 $u$ 本身）的点组成的集合。不能进行操作者失败。\n\n而 `C` 和 `K` 作为 `P**` 和 `T**` 的在读学生，这种一眼就能找出必胜策略的游戏实在是索然无味，于是两人觉得，每个人给自己一个特殊能力可能会比较有趣：\n\n`C` 在开始游戏之前，**可以选择**将当前树的树根 $R$ 换到与 $R$ 相邻的任意一个点 $R^{\\prime}$ 上。定义两个点相邻当且仅当这两个点有边直接相连。\n\n`K` 在开始游戏之前，**必须选择**树上的一个节点，在上面加上一颗棋子。\n\n`C` 和 `K` 决定玩 $m$ 局游戏。每局游戏的流程如下：\n\n1. 游戏开始前，`C` 和 `K` 会商量好，先在标号为 $x$ 的节点上放上一个棋子，然后将树根设为 $y$。\n2. 之后 `C` 可以选择是否发动特殊能力，`C` 决策完之后 `K` 可以选择是否发动特殊能力。\n3. 特殊能力的决策结束后，会在这棵树上进行一局 `C` 先手、`K` 后手的游戏。游戏完成后会将树上棋子的状态**还原到流程 `1` 结束后的状态**。\n\n`C` 觉得这个游戏可以出成一个简单题，于是他决定考考你：`C` 在每局游戏的第二步的时候，有多少种决策方式使得不管 `K` 如何进行特殊能力的操作，开始游戏时都存在**必胜策略**？两种决策方式不同，**当且仅当**两种决策**更换的树根** $R^{\\prime}$ **不同**，或者**两者中仅有一个没有发动特殊能力**。\n", "inputFormat": "第一行包括一个整数，表示该测试点所在的子任务的分数。你可以使用这个信息判断该测试点满足的特殊性质。特别的，下发样例中此行使用 $0$ 代替。\n\n第二行包含两个用空格隔开的正整数 $n, m$，表示树的节点数目以及游戏的轮数。树上的节点从 $1$ 到 $n$ 编号。\n\n接下来 $n-1$ 行，每行包含两个用空格隔开的正整数 $u_i,v_i$，满足 $1 \\le u_i,v_i \\le n$，表示编号为 $u_i$ 和 $v_i$ 的节点之间有边直接相连。\n\n接下来一行包含 $n$ 个用空格隔开的整数 $a_1,a_2,\\ldots,a_n$，满足 $0 \\leq a_1,a_2,\\ldots,a_n \\leq 10^9$。\n\n接下来 $m$ 行，每行包含两个用空格隔开的正整数 $x, y$ 描述一局游戏，满足 $1 \\le x,y \\le n$。\n", "outputFormat": "\n你需要输出 $m$ 行，其中第 $i$ 行应当包含一个非负整数 $x$ 表示第 $i$ 局游戏中，`C` 存在多少种使用特殊能力的决策方案，使得 `C` 在这局游戏中存在必胜策略。注意，**不使用特殊能力**也是一种**可能可行**的决策方案。\n", "hint": "| 子任务分数 | $1\\le n,m\\le$ | $\\max\\{a_1,a_2,\\dots,a_n\\}\\le$ |              特殊性质              |\n| :--------: | :-----------: | :----------------------------: | :--------------------------------: |\n|    $16$    |      $5$      |              $1$               |                 无                 |\n|    $15$    |     $300$     |              $1$               |                 无                 |\n|    $14$    |    $5000$     |             $10^9$             |                 无                 |\n|    $13$    |   $100000$    |             $10^9$             |        保证给出的树是一条链        |\n|    $12$    |   $100000$    |             $10^9$             | 保证给出的树存在一个点度数为 $n-1$ |\n|    $11$    |   $100000$    |             $10^9$             |   保证 $m$ 次游戏初始给定根一致    |\n|    $10$    |   $500000$    |             $10^9$             |                 无                 |\n|    $9$     |   $1000000$   |             $10^9$             |                 无                 |\n\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[北大集训 2021] 经典游戏", "background": "CTT2021 D4T2", "description": "某天，`C` 和 `K` 觉得很无聊，于是决定玩一个经典小游戏：\n\n在一棵有 $n$ 个结点的有根树上，标号为 $i$ 的节点上有 $a_i$ 个棋子。游戏时玩家轮流操作，每次可以将任意一个节点 $u$ 上的一个棋子放置到任意一个点 $v \\in U(u)$上，其中 $U(u)=subtree\\{u\\}\\setminus\\{u\\}$ ，表示 $u$ 的子树内（不包含 $u$ 本身）的点组成的集合。不能进行操作者失败。\n\n而 `C` 和 `K` 作为 `P**` 和 `T**` 的在读学生，这种一眼就能找出必胜策略的游戏实在是索然无味，于是两人觉得，每个人给自己一个特殊能力可能会比较有趣：\n\n`C` 在开始游戏之前，**可以选择**将当前树的树根 $R$ 换到与 $R$ 相邻的任意一个点 $R^{\\prime}$ 上。定义两个点相邻当且仅当这两个点有边直接相连。\n\n`K` 在开始游戏之前，**必须选择**树上的一个节点，在上面加上一颗棋子。\n\n`C` 和 `K` 决定玩 $m$ 局游戏。每局游戏的流程如下：\n\n1. 游戏开始前，`C` 和 `K` 会商量好，先在标号为 $x$ 的节点上放上一个棋子，然后将树根设为 $y$。\n2. 之后 `C` 可以选择是否发动特殊能力，`C` 决策完之后 `K` 可以选择是否发动特殊能力。\n3. 特殊能力的决策结束后，会在这棵树上进行一局 `C` 先手、`K` 后手的游戏。游戏完成后会将树上棋子的状态**还原到流程 `1` 结束后的状态**。\n\n`C` 觉得这个游戏可以出成一个简单题，于是他决定考考你：`C` 在每局游戏的第二步的时候，有多少种决策方式使得不管 `K` 如何进行特殊能力的操作，开始游戏时都存在**必胜策略**？两种决策方式不同，**当且仅当**两种决策**更换的树根** $R^{\\prime}$ **不同**，或者**两者中仅有一个没有发动特殊能力**。\n", "inputFormat": "第一行包括一个整数，表示该测试点所在的子任务的分数。你可以使用这个信息判断该测试点满足的特殊性质。特别的，下发样例中此行使用 $0$ 代替。\n\n第二行包含两个用空格隔开的正整数 $n, m$，表示树的节点数目以及游戏的轮数。树上的节点从 $1$ 到 $n$ 编号。\n\n接下来 $n-1$ 行，每行包含两个用空格隔开的正整数 $u_i,v_i$，满足 $1 \\le u_i,v_i \\le n$，表示编号为 $u_i$ 和 $v_i$ 的节点之间有边直接相连。\n\n接下来一行包含 $n$ 个用空格隔开的整数 $a_1,a_2,\\ldots,a_n$，满足 $0 \\leq a_1,a_2,\\ldots,a_n \\leq 10^9$。\n\n接下来 $m$ 行，每行包含两个用空格隔开的正整数 $x, y$ 描述一局游戏，满足 $1 \\le x,y \\le n$。\n", "outputFormat": "\n你需要输出 $m$ 行，其中第 $i$ 行应当包含一个非负整数 $x$ 表示第 $i$ 局游戏中，`C` 存在多少种使用特殊能力的决策方案，使得 `C` 在这局游戏中存在必胜策略。注意，**不使用特殊能力**也是一种**可能可行**的决策方案。\n", "hint": "| 子任务分数 | $1\\le n,m\\le$ | $\\max\\{a_1,a_2,\\dots,a_n\\}\\le$ |              特殊性质              |\n| :--------: | :-----------: | :----------------------------: | :--------------------------------: |\n|    $16$    |      $5$      |              $1$               |                 无                 |\n|    $15$    |     $300$     |              $1$               |                 无                 |\n|    $14$    |    $5000$     |             $10^9$             |                 无                 |\n|    $13$    |   $100000$    |             $10^9$             |        保证给出的树是一条链        |\n|    $12$    |   $100000$    |             $10^9$             | 保证给出的树存在一个点度数为 $n-1$ |\n|    $11$    |   $100000$    |             $10^9$             |   保证 $m$ 次游戏初始给定根一致    |\n|    $10$    |   $500000$    |             $10^9$             |                 无                 |\n|    $9$     |   $1000000$   |             $10^9$             |                 无                 |\n\n\n", "locale": "zh-CN"}}}
{"pid": "P8995", "type": "P", "difficulty": 7, "samples": [["5 2 3 2\n1 3 2\n1\n1\n", "3\n4\n"], ["10 4 5 5\n40 355 190 215 161\n3\n4\n0\n3\n4\n", "581\n460\n420\n541\n702\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "O2优化", "CTT（清华集训/北大集训）"], "title": "[北大集训 2021] 随机数据", "background": "CTT2021 D4T3", "description": "有 $n$ 件物品，用 $0, \\cdots, n-1$ 对它们编号，规定物品 $i$ 的价值为 $v_i$。\n\nA 和 B 正在轮流玩一个游戏，该游戏会进行多轮。\n\n每轮开始时，如果所有可用的物品都已经被取走，游戏将立刻结束。否则，A 必须选择一件未被取走的物品，将其取走。\n\n假设 A 取走的物品编号为 $i$。接下来，B 可以选择从物品 $(i - d + n) \\bmod n$ 和物品 $(i + d) \\bmod n$ 中选取一件未被取走的物品，将其取走；或者他可以选择跳过本次操作。随后游戏进入到下一轮。特别地，如果这两件物品都已经被取走了，B 只能选择跳过本次操作。\n\nA 和 B 都想最大化自己取走的物品的价值之和，我们假定 A 与 B 都采取了最优策略。\n\n此外，在游戏开始前，有一些物品可能是不可用的。在游戏过程中，不可用的物品将会被忽略，即：A 和 B 都不能取走不可用的物品；当所有可用的物品都已经被取走时，游戏立刻结束。\n\n初始时，所有物品都是可用的。你的程序需要支持 $q$ 次操作，每次操作的内容为：给定一个 $x$，如果物品 $x$ 是不可用的，它将变为可用的；如果它是可用的，它将变为不可用的。每次操作后，你需要回答：假设从当前状态开始游戏，游戏结束时 B 取走的物品的价值之和。\n\n不幸的是，这是一道 IO 题，**物品的数量可能会达到 $10^{16}$**。身为一个 OIer，你无法处理如此大规模的数据，因此 $v_i$ 将会用一种**特殊的方法**生成：给定一个长度为 $m$ 的数组 $w$，$v_i = w_{i \\bmod m}$。\n", "inputFormat": "输入的第一行包含四个**正整数** $n, d, m, q$，保证 $1 < n \\le 10^{16}, 1\\le d < n, 1 \\le m \\le 2\\times 10^4, q \\le 10^5$。\n\n输入的第二行包含 $m$ 个整数，第 $i$ 个整数表示 $w_{i-1}$ 的值，保证 $1 \\le w_i \\le 400$。\n\n接下来的 $q$ 行，每行包含一个整数 $x$，表示一次对物品 $x$ 的操作。保证 $0 \\le x < n$。\n", "outputFormat": "输出 $q$ 行，每行一个整数，对应一次操作之后的答案。\n", "hint": "Subtask 1 (5 pts) : $n \\le 20, q = 1$\n\nSubtask 2 (10 pts) : $n \\le 10^5, q = 1$\n\nSubtask 3 (15 pts) : $n, q \\le 10^5$\n\nSubtask 4 (30 pts) : $q = 1$\n\nSubtask 5 (40 pts) : 无特殊限制。\n\n如有需要，可以使用 `__int128` 处理 `long long` 乘法取模，下面是一个使用 `__int128` 计算 $a \\times b \\bmod m$ 的例子：\n\n```cpp\nlong long a = 1e15;\nlong long b = 1e15;\nlong long m = 12345678910;\nlong long c = ((__int128) a * b) % m;\n```\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[北大集训 2021] 随机数据", "background": "CTT2021 D4T3", "description": "有 $n$ 件物品，用 $0, \\cdots, n-1$ 对它们编号，规定物品 $i$ 的价值为 $v_i$。\n\nA 和 B 正在轮流玩一个游戏，该游戏会进行多轮。\n\n每轮开始时，如果所有可用的物品都已经被取走，游戏将立刻结束。否则，A 必须选择一件未被取走的物品，将其取走。\n\n假设 A 取走的物品编号为 $i$。接下来，B 可以选择从物品 $(i - d + n) \\bmod n$ 和物品 $(i + d) \\bmod n$ 中选取一件未被取走的物品，将其取走；或者他可以选择跳过本次操作。随后游戏进入到下一轮。特别地，如果这两件物品都已经被取走了，B 只能选择跳过本次操作。\n\nA 和 B 都想最大化自己取走的物品的价值之和，我们假定 A 与 B 都采取了最优策略。\n\n此外，在游戏开始前，有一些物品可能是不可用的。在游戏过程中，不可用的物品将会被忽略，即：A 和 B 都不能取走不可用的物品；当所有可用的物品都已经被取走时，游戏立刻结束。\n\n初始时，所有物品都是可用的。你的程序需要支持 $q$ 次操作，每次操作的内容为：给定一个 $x$，如果物品 $x$ 是不可用的，它将变为可用的；如果它是可用的，它将变为不可用的。每次操作后，你需要回答：假设从当前状态开始游戏，游戏结束时 B 取走的物品的价值之和。\n\n不幸的是，这是一道 IO 题，**物品的数量可能会达到 $10^{16}$**。身为一个 OIer，你无法处理如此大规模的数据，因此 $v_i$ 将会用一种**特殊的方法**生成：给定一个长度为 $m$ 的数组 $w$，$v_i = w_{i \\bmod m}$。\n", "inputFormat": "输入的第一行包含四个**正整数** $n, d, m, q$，保证 $1 < n \\le 10^{16}, 1\\le d < n, 1 \\le m \\le 2\\times 10^4, q \\le 10^5$。\n\n输入的第二行包含 $m$ 个整数，第 $i$ 个整数表示 $w_{i-1}$ 的值，保证 $1 \\le w_i \\le 400$。\n\n接下来的 $q$ 行，每行包含一个整数 $x$，表示一次对物品 $x$ 的操作。保证 $0 \\le x < n$。\n", "outputFormat": "输出 $q$ 行，每行一个整数，对应一次操作之后的答案。\n", "hint": "Subtask 1 (5 pts) : $n \\le 20, q = 1$\n\nSubtask 2 (10 pts) : $n \\le 10^5, q = 1$\n\nSubtask 3 (15 pts) : $n, q \\le 10^5$\n\nSubtask 4 (30 pts) : $q = 1$\n\nSubtask 5 (40 pts) : 无特殊限制。\n\n如有需要，可以使用 `__int128` 处理 `long long` 乘法取模，下面是一个使用 `__int128` 计算 $a \\times b \\bmod m$ 的例子：\n\n```cpp\nlong long a = 1e15;\nlong long b = 1e15;\nlong long m = 12345678910;\nlong long c = ((__int128) a * b) % m;\n```\n", "locale": "zh-CN"}}}
{"pid": "P8996", "type": "P", "difficulty": 6, "samples": [["6 3\n1 5 6 2 3 4\n1 2\n0 4\n1 5", "2\n2\n5"], ["6 6\n2 1 5 4 6 3\n0 1\n1 1\n0 3\n1 3\n0 6\n10 6", "2\n2\n5\n4\n3\n3"], ["10 10\n7 5 2 9 10 8 4 3 6 1\n3 1\n3 2\n3 3\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10", "2\n3\n6\n1\n7\n5\n8\n4\n9\n10"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "平衡树", "树状数组", "2022", "CEOI（中欧）"], "title": "[CEOI 2022] Abracadabra", "background": "", "description": "Tin 是一位著名的魔术师，他的一个经典魔术与洗牌有关。\n\nTin 会准备一套牌，总共 $n$ 张（保证 $n$ 为偶数），各编号为 $1\\sim n$，一开始的时候牌是乱的且倒扣在桌子上。紧接着他开始表演洗牌，在洗牌的任意时刻，观众都可以向 Tin 询问从底往上数第 $t$ 张牌是什么牌，很显然 Tin 一定会立即回答出正确答案。\n\n事实上，Tin 采用如下方式来完成这个魔术，首先他记下了一开始的 $n$ 张牌的顺序，接着采用如下技巧洗牌：\n\n1. 拿起自顶向下 $\\frac{n}{2}$ 张牌放在右手，自底向上 $\\frac{n}{2}$ 张牌放在左手，牌的正面对着桌子。\n1. 借助他的记忆，将左右手最底下的牌进行比较，将编号较小的那张牌放下，重复这个操作直到左右手一边为空。\n1. 将还有牌的那只手上的所有牌放下。\n\n请你写一个程序模拟 Tin 的魔术。", "inputFormat": "第一行两个整数 $N,Q$。\n\n接下来一行 $N$ 个整数 $p_i$，从底向上描述了整个牌堆。\n\n接下来 $Q$ 行，一行一个询问 $t,i$，表示询问 $t$ 次洗牌后自底向上第 $i$ 张牌编号是多少。", "outputFormat": "对于每一个询问，输出你的答案。", "hint": "### 样例 3 解释\n\n| 洗牌次数 |          自底向上的牌堆           |\n| :------: | :-----------------------------: |\n|   $0$    | $7\\ 5\\ 2\\ 9\\ 10\\ 8\\ 4\\ 3\\ 6\\ 1$ |\n|   $1$    | $7\\ 5\\ 2\\ 8\\ 4\\ 3\\ 6\\ 1\\ 9\\ 10$ |\n|   $2$    | $3\\ 6\\ 1\\ 7\\ 5\\ 2\\ 8\\ 4\\ 9\\ 10$ |\n|   $3$    | $2\\ 3\\ 6\\ 1\\ 7\\ 5\\ 8\\ 4\\ 9\\ 10$ |\n\n### 数据规模与约定\n\n对于全部数据，满足 $1\\le N\\le 2\\times 10^5$，$N$ 为偶数，$1\\le Q\\le 10^6$，$0\\le t\\le 10^9$，$p$ 为 $1\\sim n$ 的排列，$1\\le i\\le N$。\n\n| Subtask 编号 |       特殊限制        |   分数   |\n| :----------: | :------------------: | :------: |\n|   $1$\t    |   $N\\le 10^3$\t    |   $10$   |\n|   $2$\t    | 每一个询问的 $t$ 相同 | \t$40$ |\n|   $3$\t    |   $N,Q\\le 10^5$\t   |   $25$   |\n|   $4$\t    |      无特殊限制\t      |   $25$   |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2022] Abracadabra", "background": "", "description": "Tin 是一位著名的魔术师，他的一个经典魔术与洗牌有关。\n\nTin 会准备一套牌，总共 $n$ 张（保证 $n$ 为偶数），各编号为 $1\\sim n$，一开始的时候牌是乱的且倒扣在桌子上。紧接着他开始表演洗牌，在洗牌的任意时刻，观众都可以向 Tin 询问从底往上数第 $t$ 张牌是什么牌，很显然 Tin 一定会立即回答出正确答案。\n\n事实上，Tin 采用如下方式来完成这个魔术，首先他记下了一开始的 $n$ 张牌的顺序，接着采用如下技巧洗牌：\n\n1. 拿起自顶向下 $\\frac{n}{2}$ 张牌放在右手，自底向上 $\\frac{n}{2}$ 张牌放在左手，牌的正面对着桌子。\n1. 借助他的记忆，将左右手最底下的牌进行比较，将编号较小的那张牌放下，重复这个操作直到左右手一边为空。\n1. 将还有牌的那只手上的所有牌放下。\n\n请你写一个程序模拟 Tin 的魔术。", "inputFormat": "第一行两个整数 $N,Q$。\n\n接下来一行 $N$ 个整数 $p_i$，从底向上描述了整个牌堆。\n\n接下来 $Q$ 行，一行一个询问 $t,i$，表示询问 $t$ 次洗牌后自底向上第 $i$ 张牌编号是多少。", "outputFormat": "对于每一个询问，输出你的答案。", "hint": "### 样例 3 解释\n\n| 洗牌次数 |          自底向上的牌堆           |\n| :------: | :-----------------------------: |\n|   $0$    | $7\\ 5\\ 2\\ 9\\ 10\\ 8\\ 4\\ 3\\ 6\\ 1$ |\n|   $1$    | $7\\ 5\\ 2\\ 8\\ 4\\ 3\\ 6\\ 1\\ 9\\ 10$ |\n|   $2$    | $3\\ 6\\ 1\\ 7\\ 5\\ 2\\ 8\\ 4\\ 9\\ 10$ |\n|   $3$    | $2\\ 3\\ 6\\ 1\\ 7\\ 5\\ 8\\ 4\\ 9\\ 10$ |\n\n### 数据规模与约定\n\n对于全部数据，满足 $1\\le N\\le 2\\times 10^5$，$N$ 为偶数，$1\\le Q\\le 10^6$，$0\\le t\\le 10^9$，$p$ 为 $1\\sim n$ 的排列，$1\\le i\\le N$。\n\n| Subtask 编号 |       特殊限制        |   分数   |\n| :----------: | :------------------: | :------: |\n|   $1$\t    |   $N\\le 10^3$\t    |   $10$   |\n|   $2$\t    | 每一个询问的 $t$ 相同 | \t$40$ |\n|   $3$\t    |   $N,Q\\le 10^5$\t   |   $25$   |\n|   $4$\t    |      无特殊限制\t      |   $25$   |", "locale": "zh-CN"}}}
{"pid": "P8997", "type": "P", "difficulty": 5, "samples": [["min(min(?,?),min(?,?))", "1"], ["max(?,max(?,min(?,?)))", "2"], ["min(max(?,?),min(?,max(?,?)))", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "贪心", "递归", "2022", "CEOI（中欧）", "树的遍历"], "title": "[CEOI 2022] Homework", "background": null, "description": "这是 Helena 的数学作业中的一道题：\n\n我们定义合法表达式如下：\n\n- `?` 是合法表达式，这表示一个未知数。\n- 如果 $A,B$ 均为合法表达式，那么 $\\texttt{min(}A\\texttt{,}B\\texttt{)}$ 和 $\\texttt{max(}A\\texttt{,}B\\texttt{)}$ 均为合法表达式，这分别表示取左右两边的最大值/最小值。\n\n设 `?` 的个数为 $N$，现在给出一个合法表达式，将每一个问号替换为 $1\\sim N$ 中的任意一个数并且每一个数不能使用多次，可以得到多少种不同的答案？\n\n可怜的 Helena 并不会做，请你帮帮她。", "inputFormat": "仅一行一个字符串表示给出的合法表达式。", "outputFormat": "输出一个整数，表示不同答案的个数。", "hint": "### 样例 1 解释\n\n无论权值如何选择，最后的答案都会是 $\\min\\{1,2,3,4\\}$，也就是 $1$。\n\n### 样例 2 解释\n\n答案为 $4$ 的方案是： `4=max(4,max(3,min(2,1)))`，答案为 $3$ 的方案是 `3=max(3,max(2,min(1,4)))`，可以证明答案不可能为 $1$ 或 $2$。\n\n### 数据规模与约定\n\n对于全部数据，$2\\le N\\le 10^6$。\n\n| Subtask 编号 |                                   特殊限制                                   | 得分 |\n| :----------: | :--------------------------------------------------------------------------: | :--: |\n|     $1$      |                                   $N\\le 9$                                   | $10$ |\n|     $2$      |                                  $N\\le 16$                                   | $13$ |\n|     $3$      | 对于任意 $\\texttt{min(}A\\texttt{,}B\\texttt{)}$ 与 $\\texttt{max(}A\\texttt{,}B\\texttt{)}$，$A$ 和 $B$ 中有一个为 `?`。 | $13$ |\n|     $4$      |                                 $N\\le 10^3$                                  | $30$ |\n|     $5$      |                                  无特殊限制                                   | $34$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2022] Homework", "background": null, "description": "这是 Helena 的数学作业中的一道题：\n\n我们定义合法表达式如下：\n\n- `?` 是合法表达式，这表示一个未知数。\n- 如果 $A,B$ 均为合法表达式，那么 $\\texttt{min(}A\\texttt{,}B\\texttt{)}$ 和 $\\texttt{max(}A\\texttt{,}B\\texttt{)}$ 均为合法表达式，这分别表示取左右两边的最大值/最小值。\n\n设 `?` 的个数为 $N$，现在给出一个合法表达式，将每一个问号替换为 $1\\sim N$ 中的任意一个数并且每一个数不能使用多次，可以得到多少种不同的答案？\n\n可怜的 Helena 并不会做，请你帮帮她。", "inputFormat": "仅一行一个字符串表示给出的合法表达式。", "outputFormat": "输出一个整数，表示不同答案的个数。", "hint": "### 样例 1 解释\n\n无论权值如何选择，最后的答案都会是 $\\min\\{1,2,3,4\\}$，也就是 $1$。\n\n### 样例 2 解释\n\n答案为 $4$ 的方案是： `4=max(4,max(3,min(2,1)))`，答案为 $3$ 的方案是 `3=max(3,max(2,min(1,4)))`，可以证明答案不可能为 $1$ 或 $2$。\n\n### 数据规模与约定\n\n对于全部数据，$2\\le N\\le 10^6$。\n\n| Subtask 编号 |                                   特殊限制                                   | 得分 |\n| :----------: | :--------------------------------------------------------------------------: | :--: |\n|     $1$      |                                   $N\\le 9$                                   | $10$ |\n|     $2$      |                                  $N\\le 16$                                   | $13$ |\n|     $3$      | 对于任意 $\\texttt{min(}A\\texttt{,}B\\texttt{)}$ 与 $\\texttt{max(}A\\texttt{,}B\\texttt{)}$，$A$ 和 $B$ 中有一个为 `?`。 | $13$ |\n|     $4$      |                                 $N\\le 10^3$                                  | $30$ |\n|     $5$      |                                  无特殊限制                                   | $34$ |", "locale": "zh-CN"}}}
{"pid": "P8999", "type": "P", "difficulty": 7, "samples": [["3\n1 2\n2 3\n10 10\n10 20\n20 10", "1 2 3"], ["5\n1 2\n1 3\n1 4\n4 5\n10 10\n10 30\n30 10\n30 30\n20 25", "5 4 2 3 1"], ["6\n1 2\n2 3\n1 4\n4 5\n4 6\n10 60\n10 40\n40 50\n40 30\n70 30\n70 10", "6 5 4 1 2 3"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "Special Judge", "CEOI（中欧）"], "title": "[CEOI 2022] Drawing", "background": "", "description": "给定平面上的 $N$ 个点，和一棵大小为 $N$ 的树 $T$，保证这棵树上每个点的度数至多为 $3$，树上节点按 $1\\sim N$ 编号。\n\n你需要为平面上的点使用 $1\\sim N$ 的编号重编号之后，对于所有树上的边 $e=(u,v)$，将平面上的点 $u$ 和平面上的点 $v$ 用线段连接后，任意两条线段除了在端点上相交没有其他的相交点。\n\n试构造一组方案，保证一定有解。", "inputFormat": "第一行一个整数 $N$。\n\n接下来 $N-1$ 行，一行两个整数 $a,b$，表示有一条从 $a$ 连向 $b$ 的边。\n\n接下来 $N$ 行，一行两个整数 $x,y$，表示一个点的横纵坐标为 $(x,y)$。保证这 $N$ 个点两两不同，且没有任意三点共线。", "outputFormat": "输出一行 $N$ 个整数，第 $i$ 个数应为原本的第 $i$ 个点的标号。", "hint": "### 样例 3 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1sz6z9sk.png)\n\n蓝色数字表示所分配的编号，黑色数字表示原本的编号。\n\n### 数据规模与约定\n\n对于所有数据，保证 $0\\le x,y\\le 10^9$。\n\n| Subtask 编号 |                 特殊限制                  | 分数 |\n| :----------: | :--------------------------------------: | :--: |\n|     $1$      | $3\\le N\\le 2\\times 10^5$，所有点均在凸包上 | $10$ |\n|     $2$      |             $1\\le N\\le 4000$             | $15$ |\n|     $3$      |             $1\\le N\\le 10^4$             | $15$ |\n|     $4$      |         $1\\le N\\le 8\\times 10^4$         | $35$ |\n|     $5$      |         $1\\le N\\le 2\\times 10^5$         | $25$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2022] Drawing", "background": "", "description": "给定平面上的 $N$ 个点，和一棵大小为 $N$ 的树 $T$，保证这棵树上每个点的度数至多为 $3$，树上节点按 $1\\sim N$ 编号。\n\n你需要为平面上的点使用 $1\\sim N$ 的编号重编号之后，对于所有树上的边 $e=(u,v)$，将平面上的点 $u$ 和平面上的点 $v$ 用线段连接后，任意两条线段除了在端点上相交没有其他的相交点。\n\n试构造一组方案，保证一定有解。", "inputFormat": "第一行一个整数 $N$。\n\n接下来 $N-1$ 行，一行两个整数 $a,b$，表示有一条从 $a$ 连向 $b$ 的边。\n\n接下来 $N$ 行，一行两个整数 $x,y$，表示一个点的横纵坐标为 $(x,y)$。保证这 $N$ 个点两两不同，且没有任意三点共线。", "outputFormat": "输出一行 $N$ 个整数，第 $i$ 个数应为原本的第 $i$ 个点的标号。", "hint": "### 样例 3 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1sz6z9sk.png)\n\n蓝色数字表示所分配的编号，黑色数字表示原本的编号。\n\n### 数据规模与约定\n\n对于所有数据，保证 $0\\le x,y\\le 10^9$。\n\n| Subtask 编号 |                 特殊限制                  | 分数 |\n| :----------: | :--------------------------------------: | :--: |\n|     $1$      | $3\\le N\\le 2\\times 10^5$，所有点均在凸包上 | $10$ |\n|     $2$      |             $1\\le N\\le 4000$             | $15$ |\n|     $3$      |             $1\\le N\\le 10^4$             | $15$ |\n|     $4$      |         $1\\le N\\le 8\\times 10^4$         | $35$ |\n|     $5$      |         $1\\le N\\le 2\\times 10^5$         | $25$ |", "locale": "zh-CN"}}}
{"pid": "P9000", "type": "P", "difficulty": 5, "samples": [["2 1 2\n1 3\n2", "1"], ["0 5 3\n\n1 2 3 4 5", "0 1 2 3 4"], ["3 3 3\n3 3 3\n3 3 3", "4.5 6 7.5"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "2022", "CEOI（中欧）"], "title": "[CEOI 2022] Measures", "background": null, "description": "有 $N$ 个站在数轴上的人，他们的初始位置分别为 $a_1,a_2,\\ldots,a_N$，他们可以以 $1$ 个单位长度每秒的速度移动。\n\n因为众所周知的原因，他们需要保持社交距离，也就是说在任两个人之间距离至少为 $D$。\n\nAlenka 设计了一个 app 来快速求出这 $N$ 个人通过移动来保持社交距离的最小时间，现在她想要添加一个新功能：支持动态加入一个位置为 $b_i$ 的人。\n\n你需要实现一个程序完成这个功能。", "inputFormat": "第一行三个整数 $N,M,D$。\n\n接下来一行 $N$ 个整数 $a_1,\\ldots,a_N$，表示初始的 $N$ 个人。\n\n接下来一行 $M$ 个整数 $b_1,\\ldots,b_M$，表示顺次加入的 $M$ 个人。", "outputFormat": "输出一行 $M$ 个数，第 $i$ 个数表示加入第 $i$ 个人之后所花费的最小时间，你需要输出这个时间的精确值，不含末尾多余的 $0$。", "hint": "### 样例 2 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f3fmckzt.png)\n\n### 数据规模与约定\n\n对于全部数据，$1\\le D,a_1,\\ldots,a_N,b_1,\\ldots,b_M\\le 10^9$。\n\n| Subtask 编号 |                         特殊限制                         | 分数 |\n| :----------: | :-----------------------------------------------------: | :--: |\n|     $1$      |            $0\\le N\\le 2000$，$1\\le M\\le 10$             | $10$ |\n|     $2$      |        $0\\le N\\le 2\\times 10^5$，$1\\le M\\le 10$         | $14$ |\n|     $3$      | $N=0$，$1\\le M\\le 2\\times 10^5$，$b_1\\le \\cdots\\le b_M$ | $35$ |\n|     $4$      |             $N=0$，$1\\le M\\le 2\\times 10^5$             | $41$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2022] Measures", "background": null, "description": "有 $N$ 个站在数轴上的人，他们的初始位置分别为 $a_1,a_2,\\ldots,a_N$，他们可以以 $1$ 个单位长度每秒的速度移动。\n\n因为众所周知的原因，他们需要保持社交距离，也就是说在任两个人之间距离至少为 $D$。\n\nAlenka 设计了一个 app 来快速求出这 $N$ 个人通过移动来保持社交距离的最小时间，现在她想要添加一个新功能：支持动态加入一个位置为 $b_i$ 的人。\n\n你需要实现一个程序完成这个功能。", "inputFormat": "第一行三个整数 $N,M,D$。\n\n接下来一行 $N$ 个整数 $a_1,\\ldots,a_N$，表示初始的 $N$ 个人。\n\n接下来一行 $M$ 个整数 $b_1,\\ldots,b_M$，表示顺次加入的 $M$ 个人。", "outputFormat": "输出一行 $M$ 个数，第 $i$ 个数表示加入第 $i$ 个人之后所花费的最小时间，你需要输出这个时间的精确值，不含末尾多余的 $0$。", "hint": "### 样例 2 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f3fmckzt.png)\n\n### 数据规模与约定\n\n对于全部数据，$1\\le D,a_1,\\ldots,a_N,b_1,\\ldots,b_M\\le 10^9$。\n\n| Subtask 编号 |                         特殊限制                         | 分数 |\n| :----------: | :-----------------------------------------------------: | :--: |\n|     $1$      |            $0\\le N\\le 2000$，$1\\le M\\le 10$             | $10$ |\n|     $2$      |        $0\\le N\\le 2\\times 10^5$，$1\\le M\\le 10$         | $14$ |\n|     $3$      | $N=0$，$1\\le M\\le 2\\times 10^5$，$b_1\\le \\cdots\\le b_M$ | $35$ |\n|     $4$      |             $N=0$，$1\\le M\\le 2\\times 10^5$             | $41$ |", "locale": "zh-CN"}}}
{"pid": "P9001", "type": "P", "difficulty": 6, "samples": [["4 5\n1 0\n2 0\n1 3\n4 4\n3 2", "3\n5 2\n3 5\n3 1"], ["4 5\n0 0\n2 1\n3 1\n3 4\n2 4", "-1"], ["5 7\n1 0\n2 1\n2 3\n4 3\n5 4\n5 0\n0 0", "6\n2 1\n3 7\n4 7\n2 3\n5 4\n5 6"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2022", "Special Judge", "CEOI（中欧）", "图论建模", "栈"], "title": "[CEOI 2022] Parking", "background": "", "description": "Valerija 在一家饭店的停车场工作，她负责礼貌地接待重要的客人，保管他们的车钥匙并帮助他们停车。\n\n一个晚上，她发现她管理的停车场中恰好有 $2N$ 辆车，它们共有 $N$ 种不同的颜色，每种颜色恰有两辆车。我们将颜色按 $1$ 到 $N$ 编号。\n\n停车场共有 $M$ 个车位，按 $1$ 到 $M$ 编号，每一个车位可以停下两辆车，一个车位只有一个入口，我们称靠近入口的为「顶上的车」，远离入口的为「底下的车」，一辆车可以从入口开出当且仅当没有车挡着它。Valerija 在停车的时候，保证每个车位要么空，要么停满两辆车，要么只有一辆底下的车。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q0r8s8f5.png)\n\n这张图描述的是第一个样例，同时呈现了唯一的第一次驾驶。\n\nValerija 想要重新停放车使得每一对相同颜色的车都在一个车位里。我们并不关心车位对应什么颜色以及哪辆车在顶上哪辆车在底下。Valerija 将执行如下操作：\n\n- 驾驶一辆可以驶出车位的车，将车开到另一个车位，满足：\n    - 这个车位是空的，并把车停在底下的车位，或者，\n    - 这个车位有且只有一辆与当前驾驶的车颜色相同的车。\n    \nValerija 想知道最少的操作次数与操作方案，请你解决这个问题。", "inputFormat": "第一行两个整数 $N,M$。\n\n接下来 $M$ 行，一行两个整数 $b_i,t_i$，$b_i$ 表示停在这个车位底下的车的颜色，$t_i$ 表示停在这个车位顶上的车的颜色，如为 $0$，则表示这个车位底下/顶上的位置没有车。", "outputFormat": "如果没有办法完成要求，输出一行一个整数 $-1$。\n\n否则，第一行一个整数 $K$，表示最少的操作次数。\n\n接下来 $K$ 行，一行两个整数 $x_i,y_i$，表示第 $i$ 次操作将车位 $x_i$ 中可以驶出车位的车开到车位 $y_i$。\n\n注意到最短解可能不唯一，你只需要输出任意一种即可。", "hint": "### 样例 1 解释\n\n由题目描述中的图可以看出，这个样例只有唯一解。\n\n### 数据规模与约定\n\n对于全部数据，$1\\le N\\le M\\le 2\\times 10^5$。\n\n如果你的程序正确求出了最少的操作次数，但是方案构造错误，你将会获得对应点 $20\\%$ 的分数。\n\n| Subtask 编号 |                 特殊限制                  | 分数 |\n| :----------: | :--------------------------------------: | :--: |\n|     $1$      |                 $M\\le 4$                 | $10$ |\n|     $2$      |                $2N\\le M$                 | $10$ |\n|     $3$      | $N\\le 1000$，每个车位要么是空的要么是满的。 | $25$ |\n|     $4$      |       每个车位要么是空的要么是满的。        | $15$ |\n|     $5$      |               $N\\le 1000$                | $25$ |\n|     $6$      |                无特殊限制                 | $15$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2022] Parking", "background": "", "description": "Valerija 在一家饭店的停车场工作，她负责礼貌地接待重要的客人，保管他们的车钥匙并帮助他们停车。\n\n一个晚上，她发现她管理的停车场中恰好有 $2N$ 辆车，它们共有 $N$ 种不同的颜色，每种颜色恰有两辆车。我们将颜色按 $1$ 到 $N$ 编号。\n\n停车场共有 $M$ 个车位，按 $1$ 到 $M$ 编号，每一个车位可以停下两辆车，一个车位只有一个入口，我们称靠近入口的为「顶上的车」，远离入口的为「底下的车」，一辆车可以从入口开出当且仅当没有车挡着它。Valerija 在停车的时候，保证每个车位要么空，要么停满两辆车，要么只有一辆底下的车。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q0r8s8f5.png)\n\n这张图描述的是第一个样例，同时呈现了唯一的第一次驾驶。\n\nValerija 想要重新停放车使得每一对相同颜色的车都在一个车位里。我们并不关心车位对应什么颜色以及哪辆车在顶上哪辆车在底下。Valerija 将执行如下操作：\n\n- 驾驶一辆可以驶出车位的车，将车开到另一个车位，满足：\n    - 这个车位是空的，并把车停在底下的车位，或者，\n    - 这个车位有且只有一辆与当前驾驶的车颜色相同的车。\n    \nValerija 想知道最少的操作次数与操作方案，请你解决这个问题。", "inputFormat": "第一行两个整数 $N,M$。\n\n接下来 $M$ 行，一行两个整数 $b_i,t_i$，$b_i$ 表示停在这个车位底下的车的颜色，$t_i$ 表示停在这个车位顶上的车的颜色，如为 $0$，则表示这个车位底下/顶上的位置没有车。", "outputFormat": "如果没有办法完成要求，输出一行一个整数 $-1$。\n\n否则，第一行一个整数 $K$，表示最少的操作次数。\n\n接下来 $K$ 行，一行两个整数 $x_i,y_i$，表示第 $i$ 次操作将车位 $x_i$ 中可以驶出车位的车开到车位 $y_i$。\n\n注意到最短解可能不唯一，你只需要输出任意一种即可。", "hint": "### 样例 1 解释\n\n由题目描述中的图可以看出，这个样例只有唯一解。\n\n### 数据规模与约定\n\n对于全部数据，$1\\le N\\le M\\le 2\\times 10^5$。\n\n如果你的程序正确求出了最少的操作次数，但是方案构造错误，你将会获得对应点 $20\\%$ 的分数。\n\n| Subtask 编号 |                 特殊限制                  | 分数 |\n| :----------: | :--------------------------------------: | :--: |\n|     $1$      |                 $M\\le 4$                 | $10$ |\n|     $2$      |                $2N\\le M$                 | $10$ |\n|     $3$      | $N\\le 1000$，每个车位要么是空的要么是满的。 | $25$ |\n|     $4$      |       每个车位要么是空的要么是满的。        | $15$ |\n|     $5$      |               $N\\le 1000$                | $25$ |\n|     $6$      |                无特殊限制                 | $15$ |", "locale": "zh-CN"}}}
{"pid": "P9002", "type": "P", "difficulty": 4, "samples": [["6\n4 2\n9 3\n1000 2\n1000 20\n28238934 154154154154154\n23389348458425 5", "3\n6\n49\n60\n28238934\n760"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "数位 DP", "进制"], "title": "[RC-07] 心跳", "background": "", "description": "对正整数 $x$，设 $f(x,B)$ 表示 $x$ 在 $B$ 进制下的数位和。说一个正整数 $p$ 是 $B$-好的，当且仅当对于任意正整数 $q<p$ 都有 $f(p,B)\\ge f(q,B)$。\n\n给定正整数 $n$ 和 $B$，计算有多少个 $\\le n$ 的正整数是 $B$-好的。", "inputFormat": "本题单个测试点内有多组数据。\n\n\n\n第一行是数据组数 $T$。\n\n接下来 $T$ 行，每行两个正整数 $n,B$。", "outputFormat": "输出 $T$ 行，每行一个非负整数，为答案。", "hint": "**样例解释**\n\n这里只解释第二组询问的输出。三进制下，$1,2,3,4,5,6,7,8,9$ 的数位和分别为 $1,2,1,2,3,2,3,4,1$，据此容易看出只有 $1,2,4,5,7,8$ 是 $3$-好的，所以输出 $6$。\n\n**数据范围**\n\n所有数据均满足：$1\\le T\\le 10^5$，$1\\le n\\le 10^{18}$，$2\\le B\\le 10^{18}$。\n\n- 子任务 $1$（$50$ 分）：$T\\le 10^4$，$n,B\\le 100$。\n- 子任务 $2$（$30$ 分）：$B=2$。\n- 子任务 $3$（$20$ 分）：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RC-07] 心跳", "background": "", "description": "对正整数 $x$，设 $f(x,B)$ 表示 $x$ 在 $B$ 进制下的数位和。说一个正整数 $p$ 是 $B$-好的，当且仅当对于任意正整数 $q<p$ 都有 $f(p,B)\\ge f(q,B)$。\n\n给定正整数 $n$ 和 $B$，计算有多少个 $\\le n$ 的正整数是 $B$-好的。", "inputFormat": "本题单个测试点内有多组数据。\n\n\n\n第一行是数据组数 $T$。\n\n接下来 $T$ 行，每行两个正整数 $n,B$。", "outputFormat": "输出 $T$ 行，每行一个非负整数，为答案。", "hint": "**样例解释**\n\n这里只解释第二组询问的输出。三进制下，$1,2,3,4,5,6,7,8,9$ 的数位和分别为 $1,2,1,2,3,2,3,4,1$，据此容易看出只有 $1,2,4,5,7,8$ 是 $3$-好的，所以输出 $6$。\n\n**数据范围**\n\n所有数据均满足：$1\\le T\\le 10^5$，$1\\le n\\le 10^{18}$，$2\\le B\\le 10^{18}$。\n\n- 子任务 $1$（$50$ 分）：$T\\le 10^4$，$n,B\\le 100$。\n- 子任务 $2$（$30$ 分）：$B=2$。\n- 子任务 $3$（$20$ 分）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P9003", "type": "P", "difficulty": 6, "samples": [["3\n4 2\n1 3\n4 4\n1 2 3 4\n10 4\n1 3 7 8", "NIT\nTIN\nNIT"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化"], "title": "[RC-07] Game Theory", "background": "", "description": "给出长度为 $n$ 的 `01` 序列 $a_{1\\sim n}$，**序列中有偶数个 `1`**。NIT 和 TIN 轮流做以下操作，NIT 先手：\n\n- 选择位置 $i\\ (1\\le i\\le n)$，满足区间 $[1,i]$ 中有奇数个 `1`。再选择位置 $j\\ (i<j\\le n)$。将 $a_i,a_j$ 都取反（即，`0` 变 `1`，`1` 变 `0`）\n\n当整个序列中的所有元素都变为 `0` 时，当前轮到的人就无法操作，他就输了。假设 NIT 和 TIN 都*绝顶*聪明，谁会赢？可以证明，游戏总会结束。\n\n$n$ 可能很大，但序列中 $1$ 的个数不超过 $2\\times 10^5$。", "inputFormat": "**本题有多组数据。**\n\n输入的第一行是数据组数 $T$。\n\n接下来是每组数据的描述。每组数据的第一行是两个正整数 $n,m$，$m$ 为序列中 `1` 的个数，保证 $m$ 是偶数。\n\n接下来一行 $m$ 个**递增**的正整数，描述这些 `1` 的下标，下标从 $1$ 开始。", "outputFormat": "对每组数据，输出一行一个字符串 `NIT` 或 `TIN`，表示赢家的名字。", "hint": "**样例解释**\n\n第一组数据中，NIT 选择 $i=1,j=3$ 就能把全部位置都变成 0，使得 TIN 无法操作。\n\n第二组数据中，无论 NIT 先手怎么操作，都会剩下恰好两个 1 的位置。TIN 只需要选择这两个剩下的位置，就可以把全部位置都变成 0。\n\n第三组数据中，一种可能的游戏进程如下（注意该进程里，每一步不一定是最优的）：\n\n- NIT 选择 $i=2,j=3$ 并将这两个位置取反。现在 \n`1` 的位置在 $1,2,7,8$。\n- TIN 选择 $i=7,j=9$ 并将这两个位置取反。现在 \n`1` 的位置在 $1,2,8,9$。\n- NIT 选择 $i=1,j=5$ 并将这两个位置取反。现在 \n`1` 的位置在 $2,5,8,9$。\n- TIN 选择 $i=3,j=4$ 并将这两个位置取反。现在 \n`1` 的位置在 $2,3,4,5,8,9$。\n- NIT 选择 $i=4,j=5$ 并将这两个位置取反。现在 \n`1` 的位置在 $2,3,8,9$。\n- TIN 选择 $i=2,j=9$ 并将这两个位置取反。现在 \n`1` 的位置在 $3,8$。\n- NIT 选择 $i=3,j=8$ 并将这两个位置取反。现在序列里没有 `1` 了。\n- TIN 无法操作，NIT 获胜。\n\n**数据范围**\n\n对于所有数据，$1\\le T\\le 10^4$，$1\\le n\\le 10^{18}$，$2\\le m\\le 2\\times 10^5$，$\\sum m\\le 10^6$。保证 $m$ 是偶数，保证为 `1` 的下标是递增顺序给出的。\n\n- 子任务 1（$1$ 分）$T\\le 10^3$，$n\\le 10$。\n- 子任务 2（$9$ 分）序列中全是 `1`。\n- 子任务 3（$40$ 分）$T\\le 100$，$n\\le 100$。\n- 子任务 4（$10$ 分）$\\sum n\\le 10^6$。\n- 子任务 5（$40$ 分）没有任何附加限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RC-07] Game Theory", "background": "", "description": "给出长度为 $n$ 的 `01` 序列 $a_{1\\sim n}$，**序列中有偶数个 `1`**。NIT 和 TIN 轮流做以下操作，NIT 先手：\n\n- 选择位置 $i\\ (1\\le i\\le n)$，满足区间 $[1,i]$ 中有奇数个 `1`。再选择位置 $j\\ (i<j\\le n)$。将 $a_i,a_j$ 都取反（即，`0` 变 `1`，`1` 变 `0`）\n\n当整个序列中的所有元素都变为 `0` 时，当前轮到的人就无法操作，他就输了。假设 NIT 和 TIN 都*绝顶*聪明，谁会赢？可以证明，游戏总会结束。\n\n$n$ 可能很大，但序列中 $1$ 的个数不超过 $2\\times 10^5$。", "inputFormat": "**本题有多组数据。**\n\n输入的第一行是数据组数 $T$。\n\n接下来是每组数据的描述。每组数据的第一行是两个正整数 $n,m$，$m$ 为序列中 `1` 的个数，保证 $m$ 是偶数。\n\n接下来一行 $m$ 个**递增**的正整数，描述这些 `1` 的下标，下标从 $1$ 开始。", "outputFormat": "对每组数据，输出一行一个字符串 `NIT` 或 `TIN`，表示赢家的名字。", "hint": "**样例解释**\n\n第一组数据中，NIT 选择 $i=1,j=3$ 就能把全部位置都变成 0，使得 TIN 无法操作。\n\n第二组数据中，无论 NIT 先手怎么操作，都会剩下恰好两个 1 的位置。TIN 只需要选择这两个剩下的位置，就可以把全部位置都变成 0。\n\n第三组数据中，一种可能的游戏进程如下（注意该进程里，每一步不一定是最优的）：\n\n- NIT 选择 $i=2,j=3$ 并将这两个位置取反。现在 \n`1` 的位置在 $1,2,7,8$。\n- TIN 选择 $i=7,j=9$ 并将这两个位置取反。现在 \n`1` 的位置在 $1,2,8,9$。\n- NIT 选择 $i=1,j=5$ 并将这两个位置取反。现在 \n`1` 的位置在 $2,5,8,9$。\n- TIN 选择 $i=3,j=4$ 并将这两个位置取反。现在 \n`1` 的位置在 $2,3,4,5,8,9$。\n- NIT 选择 $i=4,j=5$ 并将这两个位置取反。现在 \n`1` 的位置在 $2,3,8,9$。\n- TIN 选择 $i=2,j=9$ 并将这两个位置取反。现在 \n`1` 的位置在 $3,8$。\n- NIT 选择 $i=3,j=8$ 并将这两个位置取反。现在序列里没有 `1` 了。\n- TIN 无法操作，NIT 获胜。\n\n**数据范围**\n\n对于所有数据，$1\\le T\\le 10^4$，$1\\le n\\le 10^{18}$，$2\\le m\\le 2\\times 10^5$，$\\sum m\\le 10^6$。保证 $m$ 是偶数，保证为 `1` 的下标是递增顺序给出的。\n\n- 子任务 1（$1$ 分）$T\\le 10^3$，$n\\le 10$。\n- 子任务 2（$9$ 分）序列中全是 `1`。\n- 子任务 3（$40$ 分）$T\\le 100$，$n\\le 100$。\n- 子任务 4（$10$ 分）$\\sum n\\le 10^6$。\n- 子任务 5（$40$ 分）没有任何附加限制。", "locale": "zh-CN"}}}
{"pid": "P9004", "type": "P", "difficulty": 6, "samples": [["5 3 23333", "1 0 0\n2 0 0\n6 0 0\n24 17 0\n120 904 1226"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化"], "title": "[RC-07] Abnormal Permutation Tuples", "background": "", "description": "给出三个正整数 $n,m$ 和 $mod$。\n\n有多少个 $1\\sim n$ 的排列构成的有序 $m$ 元组，$(p_1,p_2,\\dots,p_m)$，满足：\n\n- 字典序：$p_1\\lt p_2\\lt \\dots\\lt p_m$\n- 逆序对数：$p_1\\gt p_2\\gt \\dots\\gt p_m$\n\n设 $f(n,m)$ 为答案模 $mod$ 的值。对于所有 $1\\le i\\le n,1\\le j\\le m$，请你输出 $f(i,j)$。\n", "inputFormat": "输入包含一行三个正整数 $n,m,mod$。", "outputFormat": "输出一个 $n\\times m$ 的矩阵，第 $i$ 行第 $j$ 列为 $f(i,j)$。", "hint": "保证 $2\\le mod\\le 10^9$，$1\\le n\\le 15$，$1\\le m\\le 30$。**注意，$n,m$ 不会同时取到 $15$ 和 $30$。**\n\n$n,m$ 的范围如下：\n \n- 子任务 1（$20$ 分）$n=7$，$m=30$。\n- 子任务 2（$10$ 分）$n=10$，$m=10$。\n- 子任务 3（$20$ 分）$n=11$，$m=10$。\n- 子任务 4（$10$ 分）$n=12$，$m=8$。\n- 子任务 5（$20$ 分）$n=13$，$m=15$。\n- 子任务 6（$10$ 分）$n=14$，$m=30$。\n- 子任务 7（$10$ 分）$n=15$，$m=20$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RC-07] Abnormal Permutation Tuples", "background": "", "description": "给出三个正整数 $n,m$ 和 $mod$。\n\n有多少个 $1\\sim n$ 的排列构成的有序 $m$ 元组，$(p_1,p_2,\\dots,p_m)$，满足：\n\n- 字典序：$p_1\\lt p_2\\lt \\dots\\lt p_m$\n- 逆序对数：$p_1\\gt p_2\\gt \\dots\\gt p_m$\n\n设 $f(n,m)$ 为答案模 $mod$ 的值。对于所有 $1\\le i\\le n,1\\le j\\le m$，请你输出 $f(i,j)$。\n", "inputFormat": "输入包含一行三个正整数 $n,m,mod$。", "outputFormat": "输出一个 $n\\times m$ 的矩阵，第 $i$ 行第 $j$ 列为 $f(i,j)$。", "hint": "保证 $2\\le mod\\le 10^9$，$1\\le n\\le 15$，$1\\le m\\le 30$。**注意，$n,m$ 不会同时取到 $15$ 和 $30$。**\n\n$n,m$ 的范围如下：\n \n- 子任务 1（$20$ 分）$n=7$，$m=30$。\n- 子任务 2（$10$ 分）$n=10$，$m=10$。\n- 子任务 3（$20$ 分）$n=11$，$m=10$。\n- 子任务 4（$10$ 分）$n=12$，$m=8$。\n- 子任务 5（$20$ 分）$n=13$，$m=15$。\n- 子任务 6（$10$ 分）$n=14$，$m=30$。\n- 子任务 7（$10$ 分）$n=15$，$m=20$。", "locale": "zh-CN"}}}
{"pid": "P9005", "type": "P", "difficulty": 6, "samples": [["1\n5", "125"], ["5\n2 3 4 5 6", "676736091"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化"], "title": "[RC-07] 超超立方体", "background": "", "description": "有一个 $n$ 维 $(a_1-1)\\times (a_2-1)\\times \\dots \\times (a_n-1)$ 超立方体。左下角坐标为 $(1,1,\\dots,1)$，右上角坐标为 $(a_1,a_2,\\dots,a_n)$。\n\n考虑一个无向图，有 $a_1\\times a_2\\times \\dots \\times a_n$ 个有标号的结点。结点的标号分别为 $(x_1,\\dots,x_n)\\ (1\\le x_i\\le a_i)$，每个节点对应超立方体内部或者边界上一个整点。对于一对图上的顶点 $(U,V)\\ (U=(x_1,\\dots,x_n),V=(y_1,\\dots,y_n))$，它们之间有边相连当且仅当 $UV$ 平行于超立方体的一条棱。换句话说，也就是 $\\sum_{1\\le i\\le n}[x_i=y_i]=n-1$。\n\n计算该图生成树个数对 $998244353$ 取模的结果。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来一行 $n$ 个正整数 $a_1,a_2,\\dots,a_n$。", "outputFormat": "输出答案对 $998244353$ 取模的结果。", "hint": "所有数据均满足：$1\\le n\\le 100$，$2\\le a_i\\le 5000$。\n\n- 子任务 $1$（$5$ 分）：$n=1$。\n- 子任务 $2$（$5$ 分）：$n\\le 3,\\prod a_i\\le 500$。\n- 子任务 $3$（$10$ 分）：$n=2$。\n- 子任务 $4$（$80$ 分）：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RC-07] 超超立方体", "background": "", "description": "有一个 $n$ 维 $(a_1-1)\\times (a_2-1)\\times \\dots \\times (a_n-1)$ 超立方体。左下角坐标为 $(1,1,\\dots,1)$，右上角坐标为 $(a_1,a_2,\\dots,a_n)$。\n\n考虑一个无向图，有 $a_1\\times a_2\\times \\dots \\times a_n$ 个有标号的结点。结点的标号分别为 $(x_1,\\dots,x_n)\\ (1\\le x_i\\le a_i)$，每个节点对应超立方体内部或者边界上一个整点。对于一对图上的顶点 $(U,V)\\ (U=(x_1,\\dots,x_n),V=(y_1,\\dots,y_n))$，它们之间有边相连当且仅当 $UV$ 平行于超立方体的一条棱。换句话说，也就是 $\\sum_{1\\le i\\le n}[x_i=y_i]=n-1$。\n\n计算该图生成树个数对 $998244353$ 取模的结果。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来一行 $n$ 个正整数 $a_1,a_2,\\dots,a_n$。", "outputFormat": "输出答案对 $998244353$ 取模的结果。", "hint": "所有数据均满足：$1\\le n\\le 100$，$2\\le a_i\\le 5000$。\n\n- 子任务 $1$（$5$ 分）：$n=1$。\n- 子任务 $2$（$5$ 分）：$n\\le 3,\\prod a_i\\le 500$。\n- 子任务 $3$（$10$ 分）：$n=2$。\n- 子任务 $4$（$80$ 分）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P9006", "type": "P", "difficulty": 3, "samples": [["3 10", "90 90 90 90 90 90 90 90 90 90\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "O2优化", "语言月赛"], "title": "[入门赛 #9] 神树大人挥动魔杖 (Hard Version)", "background": "**本题与 Easy Version 题意完全相同，仅有 $n,k$ 的数据范围有所不同。**", "description": "神树大人挥动魔杖，召唤出了 $9 \\times 10^{n-1}$ 只家养小精灵。每只家养小精灵都有一个互不相同的 $n$ 位数编号 $a_i$。\n\n神树大人希望将这些家养小精灵分为 $k$ 组。第 $p$ 组的所有家养小精灵满足编号 $a_i$ 对 $k$ 取模余 $p-1$，即 $a_i \\equiv p-1 \\pmod k$。\n\n神树大人想要知道，每一组小精灵分别有多少只。由于答案可能很大，你只需要输出答案对 $100,000,007$ 取模的结果", "inputFormat": "输入共一行两个整数，依次为 $n,k$。", "outputFormat": "输出一行 $k$ 个整数，由空格分隔。第 $i$ 个整数代表第 $i$ 组小精灵的个数。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 5000$，$1 \\le k \\le 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[入门赛 #9] 神树大人挥动魔杖 (Hard Version)", "background": "**本题与 Easy Version 题意完全相同，仅有 $n,k$ 的数据范围有所不同。**", "description": "神树大人挥动魔杖，召唤出了 $9 \\times 10^{n-1}$ 只家养小精灵。每只家养小精灵都有一个互不相同的 $n$ 位数编号 $a_i$。\n\n神树大人希望将这些家养小精灵分为 $k$ 组。第 $p$ 组的所有家养小精灵满足编号 $a_i$ 对 $k$ 取模余 $p-1$，即 $a_i \\equiv p-1 \\pmod k$。\n\n神树大人想要知道，每一组小精灵分别有多少只。由于答案可能很大，你只需要输出答案对 $100,000,007$ 取模的结果", "inputFormat": "输入共一行两个整数，依次为 $n,k$。", "outputFormat": "输出一行 $k$ 个整数，由空格分隔。第 $i$ 个整数代表第 $i$ 组小精灵的个数。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 5000$，$1 \\le k \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P9007", "type": "P", "difficulty": 5, "samples": [["3\n2\n3\n4", "1\n3\n6"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2023", "数论", "O2优化", "素数判断,质数,筛法", "逆元", "语言月赛"], "title": "[入门赛 #9] 最澄澈的空与海 (Hard Version)", "background": "材料 1：\n\n> 请小心地计算下面的算式：$138 - 108 \\div 6 = ?$  \n> 你大概难以置信，这个算式的计算结果竟然是 $5!$\n\n材料 2：\n\n> 对于一个正整数 $x$，$x! = 1 \\times 2 \\times \\cdots \\times (x - 1) \\times x$。我们称 $x!$ 为 $x$ 的阶乘。  \n> 特别的，$0! = 1$。\n\n显然，「$138 - 108 \\div 6 = 5$」是错误的，而「$(138 - 108) \\div 6 = 5$」是正确的，所以对材料 1 中的内容，部分读者会认为「作者没有搞清加减乘除的运算优先级关系而犯错」。\n\n然而，材料 1 最后一行的叹号并不是标点符号，而是材料 2 提到的「阶乘」。\n\n考虑到这一点，「$138 - 108 \\div 6 = 5! = 1 \\times 2 \\times \\cdots \\times 5 = 120$」显然就是正确的了。", "description": "然而，此题可能与上面的题目背景关系不是很大。\n\n我们会给你 $T$ 组数据，每组数据包括一个正整数 $n$。\n\n对于每组数据，请你帮助求出满足以下条件的整数三元组 $(x, y, z)$ 的组数：\n\n1. $x \\geq 0$，$z \\geq 1$。\n2. $x - y \\div z = n!$ 且 $(x - y) \\div z = \\dfrac{n!}{n}$。\n\n由于答案可能过大，因此你需要输出答案对 $998244353$ 取模后的结果。\n\n不难注意到答案有可能为 $\\infty$，这时请按照「输出格式」要求进行处理。\n\n**请注意此处应满足 $(x - y) \\div z = \\dfrac{n!}{n}$ 而不是 $= n$。**\n\n请注意这里的 $\\div$ 不是向下取整的整除，这显然意味着你需要保证 $y \\div z$ 和 $(x - y) \\div z$ 为整数。", "inputFormat": "输入共 $T + 1$ 行。\n\n第一行为一个整数 $T$。\n\n接下来 $T$ 行，每行一个整数 $n$。", "outputFormat": "输出共 $T$ 行，每行一个整数或一个字符串。\n\n对第 $i$ 行，如果对于输入数据中第 $i + 1$ 行的 $n$，满足 $x - y \\div z = n!$ 且 $(x - y) \\div z = \\dfrac{n!}{n}$ 的整数三元组 $(x, y, z)$ 有无限个，则输出一行 `inf`，否则输出满足条件的三元组的数量对 $998244353$ 取模后的结果。", "hint": "### 样例 1 解释\n\n样例中的具体三元组如下：\n\n| $n$ | 所有可能的三元组 |\n| :----------: | :----------: |\n| $2$ | $(2, 0, 2)$ |\n| $3$ | $\\begin{matrix}(8, 4, 2) & (5, -5, 5) & (6, 0, 3)\\end{matrix}$ |\n| $4$ | $\\begin{matrix}(19, -95, 19) & (21, -21, 7) & (24, 0, 4) \\\\ (27, 9, 3) & (20, -40, 10) & (36, 24, 2)\\end{matrix}$ |\n\n### 数据规模与约定\n\n对于前 $20\\%$ 的数据，保证 $T \\leq 10$，$n \\leq 10$。\n\n对于前 $40\\%$ 的数据，保证 $n \\leq 10 ^ 3$。\n\n对于另外 $20\\%$ 的数据，保证 $T = 1$。\n\n对于 $100\\%$ 的数据，保证 $1 \\leq T \\leq 10 ^ 5$，$1 \\leq n \\leq 10 ^ 6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[入门赛 #9] 最澄澈的空与海 (Hard Version)", "background": "材料 1：\n\n> 请小心地计算下面的算式：$138 - 108 \\div 6 = ?$  \n> 你大概难以置信，这个算式的计算结果竟然是 $5!$\n\n材料 2：\n\n> 对于一个正整数 $x$，$x! = 1 \\times 2 \\times \\cdots \\times (x - 1) \\times x$。我们称 $x!$ 为 $x$ 的阶乘。  \n> 特别的，$0! = 1$。\n\n显然，「$138 - 108 \\div 6 = 5$」是错误的，而「$(138 - 108) \\div 6 = 5$」是正确的，所以对材料 1 中的内容，部分读者会认为「作者没有搞清加减乘除的运算优先级关系而犯错」。\n\n然而，材料 1 最后一行的叹号并不是标点符号，而是材料 2 提到的「阶乘」。\n\n考虑到这一点，「$138 - 108 \\div 6 = 5! = 1 \\times 2 \\times \\cdots \\times 5 = 120$」显然就是正确的了。", "description": "然而，此题可能与上面的题目背景关系不是很大。\n\n我们会给你 $T$ 组数据，每组数据包括一个正整数 $n$。\n\n对于每组数据，请你帮助求出满足以下条件的整数三元组 $(x, y, z)$ 的组数：\n\n1. $x \\geq 0$，$z \\geq 1$。\n2. $x - y \\div z = n!$ 且 $(x - y) \\div z = \\dfrac{n!}{n}$。\n\n由于答案可能过大，因此你需要输出答案对 $998244353$ 取模后的结果。\n\n不难注意到答案有可能为 $\\infty$，这时请按照「输出格式」要求进行处理。\n\n**请注意此处应满足 $(x - y) \\div z = \\dfrac{n!}{n}$ 而不是 $= n$。**\n\n请注意这里的 $\\div$ 不是向下取整的整除，这显然意味着你需要保证 $y \\div z$ 和 $(x - y) \\div z$ 为整数。", "inputFormat": "输入共 $T + 1$ 行。\n\n第一行为一个整数 $T$。\n\n接下来 $T$ 行，每行一个整数 $n$。", "outputFormat": "输出共 $T$ 行，每行一个整数或一个字符串。\n\n对第 $i$ 行，如果对于输入数据中第 $i + 1$ 行的 $n$，满足 $x - y \\div z = n!$ 且 $(x - y) \\div z = \\dfrac{n!}{n}$ 的整数三元组 $(x, y, z)$ 有无限个，则输出一行 `inf`，否则输出满足条件的三元组的数量对 $998244353$ 取模后的结果。", "hint": "### 样例 1 解释\n\n样例中的具体三元组如下：\n\n| $n$ | 所有可能的三元组 |\n| :----------: | :----------: |\n| $2$ | $(2, 0, 2)$ |\n| $3$ | $\\begin{matrix}(8, 4, 2) & (5, -5, 5) & (6, 0, 3)\\end{matrix}$ |\n| $4$ | $\\begin{matrix}(19, -95, 19) & (21, -21, 7) & (24, 0, 4) \\\\ (27, 9, 3) & (20, -40, 10) & (36, 24, 2)\\end{matrix}$ |\n\n### 数据规模与约定\n\n对于前 $20\\%$ 的数据，保证 $T \\leq 10$，$n \\leq 10$。\n\n对于前 $40\\%$ 的数据，保证 $n \\leq 10 ^ 3$。\n\n对于另外 $20\\%$ 的数据，保证 $T = 1$。\n\n对于 $100\\%$ 的数据，保证 $1 \\leq T \\leq 10 ^ 5$，$1 \\leq n \\leq 10 ^ 6$。", "locale": "zh-CN"}}}
{"pid": "P9008", "type": "P", "difficulty": 3, "samples": [["4 2 2\n1 2\n2 3\n1 4\n1 3", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "O2优化", "语言月赛"], "title": "[入门赛 #9] 大碗宽面 (Hard Version)", "background": "\n**本题与 Easy Version 题意完全相同，仅有 $n$ 的数据范围和空间限制不同**。\n\n扶苏和她的朋友们在 Impart 酒店开派对。", "description": "算上扶苏，本次派对共有 $n$ 个人。但是，并不是任何两个人都互相认识，并且互相认识的人关系也未必好。\n\n具体而言，任意两个人可能是如下三种关系之一：\n1. 敌人\n2. 朋友\n3. 陌生人\n\n派对的一大重要活动是相互握手。对任意两个人 $u,v$，他们之间的握手情况遵循下面的规则：\n1. 如果 $u$ 和 $v$ 是朋友关系，那么他们一定握手一次。\n2. 如果 $u$ 和 $v$ 是敌人关系，那么他们一定**不**握手。\n3. 如果 $u$ 和 $v$ 是陌生人关系，且存在一个人 $w$，使得 $w$ 是 $u$ 和 $v$ 之一的朋友，同时是 $u,v$ 中另一人的敌人，则 $u$ 和 $v$ **不会**握手，否则 $u$ 和 $v$ 一定握手一次。\n\n对第三条规则，简单的说法是：一对陌生人之间，如果某一方的朋友是另一方的敌人，则不握手，否则握手。\n\n已知共有 $p$ 对人是朋友关系，$q$ 对人是敌人关系。除了这 $p + q$ 对人，其他每对人均为陌生人关系。\n\n请你求出本次派对一共握手了多少次。", "inputFormat": "第一行是三个整数，依次表示参加派对的人数 $n$，朋友关系的条数 $p$ 和敌人关系的条数 $q$。  \n接下来 $p$ 行，每行两个整数 $u,v$，表示 $u$ 和 $v$ 是朋友关系。  \n接下来 $q$ 行，每行两个整数 $u, v$，表示 $u$ 和 $v$ 是敌人关系。", "outputFormat": "输出一行一个整数，表示本次派对的握手次数。", "hint": "### 样例 1 解释\n\n共有 $(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)$ $6$ 对人。\n- $(1,2)$ 是朋友，握手。\n- $(1,3)$ 是敌人，不握手。\n- $(1,4)$ 是敌人，不握手。\n- $(2,3)$ 是朋友，握手。\n- $(2,4)$ 是陌生人，但是 $1$ 是 $2$ 的朋友，也是 $4$ 的敌人，所以不握手。\n- $(3,4)$ 是陌生人，但是不存在任何一个人既是 $3$ 和 $4$ 之一的敌人也是另一个人的朋友，故握手。\n\n综上，一共握手 $3$ 次。\n\n### 数据规模与约定\n\n以下设 $m = p + q$，即 $m$ 是朋友和敌人关系条数之和。\n\n- 对 $100\\%$ 的数据，保证 $2 \\leq n \\leq 10^6$，$1 \\leq u, v \\leq n$，$0 \\leq p,q \\leq m \\leq 10^3$，$u \\neq v$。同一对敌人或朋友关系不会出现两次，不会有一对人同时是敌人或朋友关系。\n\nBy 一扶苏一", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[入门赛 #9] 大碗宽面 (Hard Version)", "background": "\n**本题与 Easy Version 题意完全相同，仅有 $n$ 的数据范围和空间限制不同**。\n\n扶苏和她的朋友们在 Impart 酒店开派对。", "description": "算上扶苏，本次派对共有 $n$ 个人。但是，并不是任何两个人都互相认识，并且互相认识的人关系也未必好。\n\n具体而言，任意两个人可能是如下三种关系之一：\n1. 敌人\n2. 朋友\n3. 陌生人\n\n派对的一大重要活动是相互握手。对任意两个人 $u,v$，他们之间的握手情况遵循下面的规则：\n1. 如果 $u$ 和 $v$ 是朋友关系，那么他们一定握手一次。\n2. 如果 $u$ 和 $v$ 是敌人关系，那么他们一定**不**握手。\n3. 如果 $u$ 和 $v$ 是陌生人关系，且存在一个人 $w$，使得 $w$ 是 $u$ 和 $v$ 之一的朋友，同时是 $u,v$ 中另一人的敌人，则 $u$ 和 $v$ **不会**握手，否则 $u$ 和 $v$ 一定握手一次。\n\n对第三条规则，简单的说法是：一对陌生人之间，如果某一方的朋友是另一方的敌人，则不握手，否则握手。\n\n已知共有 $p$ 对人是朋友关系，$q$ 对人是敌人关系。除了这 $p + q$ 对人，其他每对人均为陌生人关系。\n\n请你求出本次派对一共握手了多少次。", "inputFormat": "第一行是三个整数，依次表示参加派对的人数 $n$，朋友关系的条数 $p$ 和敌人关系的条数 $q$。  \n接下来 $p$ 行，每行两个整数 $u,v$，表示 $u$ 和 $v$ 是朋友关系。  \n接下来 $q$ 行，每行两个整数 $u, v$，表示 $u$ 和 $v$ 是敌人关系。", "outputFormat": "输出一行一个整数，表示本次派对的握手次数。", "hint": "### 样例 1 解释\n\n共有 $(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)$ $6$ 对人。\n- $(1,2)$ 是朋友，握手。\n- $(1,3)$ 是敌人，不握手。\n- $(1,4)$ 是敌人，不握手。\n- $(2,3)$ 是朋友，握手。\n- $(2,4)$ 是陌生人，但是 $1$ 是 $2$ 的朋友，也是 $4$ 的敌人，所以不握手。\n- $(3,4)$ 是陌生人，但是不存在任何一个人既是 $3$ 和 $4$ 之一的敌人也是另一个人的朋友，故握手。\n\n综上，一共握手 $3$ 次。\n\n### 数据规模与约定\n\n以下设 $m = p + q$，即 $m$ 是朋友和敌人关系条数之和。\n\n- 对 $100\\%$ 的数据，保证 $2 \\leq n \\leq 10^6$，$1 \\leq u, v \\leq n$，$0 \\leq p,q \\leq m \\leq 10^3$，$u \\neq v$。同一对敌人或朋友关系不会出现两次，不会有一对人同时是敌人或朋友关系。\n\nBy 一扶苏一", "locale": "zh-CN"}}}
{"pid": "P9009", "type": "P", "difficulty": 2, "samples": [["3\n1 2 3", "2"], ["2", "Yes"], ["4\n1 2 3 4", "3"]], "limits": {"time": [1000, 1000, 1000], "memory": [524288, 524288, 524288]}, "tags": ["2023", "提交答案", "Special Judge", "O2优化", "语言月赛"], "title": "[入门赛 #9] 牵连的世界 (Hard Version)", "background": "\n这是一道 **hack 题**。在此类型的题目中，你将得到若干个问题和若干个解决对应问题的代码，但是给出的代码不能对于某些输入给出正确的输出。不能给出正确的输出的情况包括：\n\n1. 输出错误的结果。\n2. 运行超时。\n3. 产生一些运行时未定义行为。目前技术可检测的未定义行为仅包括数组越界。\n\n对于每个问题，你需要提交一份符合要求的输入数据，使得给定的代码不能给出正确的输出。你可以直接使用『提交答案』功能，也可以提交一份以任何语言写成的数据生成器。\n\n---\n**提示：如果你使用提交答案功能，请在提交其他题目时记得将语言改回你所使用的语言**", "description": "以下给出三个问题的题目描述：\n\n#### 问题 1\n\n给出 $n$ 个整数，求其中奇数的个数。\n\n#### 问题 2\n\n判定 $p$ 是否为质数。\n\n#### 问题 3\n\n给出 $n$ 个整数，第 $i$ 个为 $a_i$。找到最大的数 $p$，使得满足 $a_i \\ge p$ 的 $i$ 个数不小于 $\\lfloor \\dfrac{n}{2} \\rfloor$。", "inputFormat": "#### 问题 1\n\n输入包含两行。  \n第一行是一个整数，表示数列长度 $n$。  \n第二行有 $n$ 个以单个空格隔开的整数，依次表示 $a_1, a_2, \\dots a_n$。\n\n#### 问题 2\n\n输入包含一行一个整数 $p$。\n\n#### 问题 3\n\n输入包含两行。  \n第一行是一个整数，表示数列长度 $n$。  \n第二行有 $n$ 个以单个空格隔开的整数，依次表示 $a_1, a_2, \\dots a_n$。", "outputFormat": "#### 问题 1\n\n输出一行一个整数表示答案。\n\n#### 问题 2\n\n输出一行，若 $p$ 为质数，输出 `Yes`；否则输出 `No`。\n\n#### 问题 3\n\n输出一行一个整数表示答案。", "hint": "### 样例组与实际输入的说明\n\n三个样例分别对应三个问题的样例输入输出。\n\n如果你直接采用『提交答案』的方式，请分别将三个输入数据命名为 `1.in`、`2.in`、`3.in`，并打成 zip 压缩包进行提交；\n\n如果你采用提交数据生成器的方式，你的生成器可以从标准输入读入一个整数 $x$，满足 $1 \\leq x \\leq 3$，表示该测试点对应的问题编号，然后**输出对应的输入数据**。\n\n显然，你的程序不应该读入『输入格式』里提到的任何内容（而应该构造它们），也不应该输出『样例输出』里提到的任何内容（而是只输出你构造的输入数据）。你不应该使用样例测试你的程序，这只是对三个问题的样例说明。\n\n### 数据规模要求\n\n你给出的数据必须满足如下要求：\n\n1. 完全符合『输入格式』的规定，不能有多余的输入，但是可以有行末空格和文末回车。\n2. 数据中所有的数字都应为整数。\n3. 对于问题 1，$1 \\leq n \\leq 1000, -2 \\times 10^9 \\le a_i \\le 2 \\times 10^9$。\n4. 对于问题 2，$1 \\le p \\le 10^{12}$。\n5. 对于问题 3，$2 \\leq n \\leq 100$，$1 \\leq a_i \\leq 2 \\times 10^9$。\n\n### 目标代码\n\n你需要 hack 如下的代码：\n\n#### 问题 1\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n, ans = 0;\n  cin >> n;\n  for(int i = 1, x; i <= n; i++) {\n    cin >> x;\n    if(x % 2 == 1) ++ans;\n  }\n  cout << ans << endl;\n}\n```\n\n#### 问题 2\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nbool isprime(long long x) {\n    if(x == 1) return false;\n    for(int i = 2; i * i <= x; i++) {\n        if(x % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    long long p;\n    cin >> p;\n    if(isprime(p)) cout << \"Yes\" << endl;\n    else cout << \"No\";\n    return 0;\n}\n```\n\n#### 问题 3\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1000 + 7;\n\nint n, a[MAXN];\n\nbool check(int x) {\n    int tot = 0;\n    for(int i = 1; i <= n; i++) {\n        if(a[i] >= x) ++tot;\n    }\n    return (tot >= (n / 2));\n}\n\nint main() {\n    cin >> n;\n    for(int i = 1; i <= n; i++) cin >> a[i];\n    int L = 1, R = 2000000000, ans;\n    while(L <= R) {\n        int mid = (L + R) / 2;\n        if(check(mid)) ans = mid, L = mid + 1;\n        else R = mid - 1;\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n目标代码的编译选项为 `-std=c++14 -fno-asm -O2`。编译器为洛谷提供的 g++。你可以在『在线 IDE』中选择 C++14 语言来获得完全相同的编译环境。\n\n### 判分说明\n\n本题共三个测试点，分别对应三个问题，测试点分值依次为 $30$分、$30$ 分、$40$ 分。\n\n#### 数据判定\n\n你给出的数据必须完全符合『数据规模要求』，否则将得到 Unaccepted 的结果。\n\n#### 超时判定\n\n程序每执行若干条指令，我们会检测一遍程序的运行时间。我们保证两次检测之间的指令条数是一个输入规模无关的量，也即每执行 $O(1)$ 条指令会进行一次检测。且两次检测之间的指令条数不会太多，一般不超过 $100$ 条 C++ 语句。\n\n如果程序的运行时间超过 $500 \\text{ms}$，则判定为程序运行超时，返回 accepted 结果。\n\n#### 结果错误判定\n\n如果程序在规定的时间内结束且给出了一个输出，我们会比较这个输出和**完全正确的输出**，如果二者不同，则判定为 hack 成功，返回 accepted 结果。\n\n#### 未定义行为判定\n\n我们会在每次**显式**的调用数组元素前判断数组下标是否超过数组范围，如果超过，则判定为 hack 成功，返回 accepted 结果。\n\n这就是说，如果你希望通过未定义行为进行 hack，只能对显式的调用数组元素的行为进行 hack。\n\n### 样例程序\n\n这是一份可以帮你理解你需要输出的内容的样例程序，**但它不能给出正确的 hack 数据**。直接提交此程序不会得分。\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n  int taskId;\n  cin >> taskId;\n  if (taskId == 1) {\n    cout << \"\" <<endl;\n  } else if (taskId == 2) {\n    cout << \"\" << endl;\n  } else if (taskId == 3) {\n    cout << \"\" << endl;\n  } else { // 这个 else 不会被执行\n    cout << \"QiHai Nanami\" << endl;\n  }\n}\n```\n\n如果你使用『提交答案』功能，请务必保证打开压缩包后能且仅能**直接**看到三个 `.in` 文件。这就是说，文件结构必须是：\n\n```plain\nans.zip\n |---1.in\n |---2.in\n |---3.in\n```\n\n三个文件不应该被额外的文件夹包含，即文件结构不能是：\n\n```plain\nans.zip\n |---ans(folder)\n      |---1.in\n      |---2.in\n      |---3.in\n```\n\n### 关于评测信息的说明\n\n如果 hack 成功，对应测试点的信息为 accepted。如果返回其他信息，说明程序本身有误。\n\n例如，如果返回 TLE，不代表成功的将对应程序 hack 至超时，而是表示数据生成器本身运行超时，测试点不得分。\n\n特别的，返回 UKE 结果可能是数据不合法（有多余内容、缺少内容或数据范围不符合要求）。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[入门赛 #9] 牵连的世界 (Hard Version)", "background": "\n这是一道 **hack 题**。在此类型的题目中，你将得到若干个问题和若干个解决对应问题的代码，但是给出的代码不能对于某些输入给出正确的输出。不能给出正确的输出的情况包括：\n\n1. 输出错误的结果。\n2. 运行超时。\n3. 产生一些运行时未定义行为。目前技术可检测的未定义行为仅包括数组越界。\n\n对于每个问题，你需要提交一份符合要求的输入数据，使得给定的代码不能给出正确的输出。你可以直接使用『提交答案』功能，也可以提交一份以任何语言写成的数据生成器。\n\n---\n**提示：如果你使用提交答案功能，请在提交其他题目时记得将语言改回你所使用的语言**", "description": "以下给出三个问题的题目描述：\n\n#### 问题 1\n\n给出 $n$ 个整数，求其中奇数的个数。\n\n#### 问题 2\n\n判定 $p$ 是否为质数。\n\n#### 问题 3\n\n给出 $n$ 个整数，第 $i$ 个为 $a_i$。找到最大的数 $p$，使得满足 $a_i \\ge p$ 的 $i$ 个数不小于 $\\lfloor \\dfrac{n}{2} \\rfloor$。", "inputFormat": "#### 问题 1\n\n输入包含两行。  \n第一行是一个整数，表示数列长度 $n$。  \n第二行有 $n$ 个以单个空格隔开的整数，依次表示 $a_1, a_2, \\dots a_n$。\n\n#### 问题 2\n\n输入包含一行一个整数 $p$。\n\n#### 问题 3\n\n输入包含两行。  \n第一行是一个整数，表示数列长度 $n$。  \n第二行有 $n$ 个以单个空格隔开的整数，依次表示 $a_1, a_2, \\dots a_n$。", "outputFormat": "#### 问题 1\n\n输出一行一个整数表示答案。\n\n#### 问题 2\n\n输出一行，若 $p$ 为质数，输出 `Yes`；否则输出 `No`。\n\n#### 问题 3\n\n输出一行一个整数表示答案。", "hint": "### 样例组与实际输入的说明\n\n三个样例分别对应三个问题的样例输入输出。\n\n如果你直接采用『提交答案』的方式，请分别将三个输入数据命名为 `1.in`、`2.in`、`3.in`，并打成 zip 压缩包进行提交；\n\n如果你采用提交数据生成器的方式，你的生成器可以从标准输入读入一个整数 $x$，满足 $1 \\leq x \\leq 3$，表示该测试点对应的问题编号，然后**输出对应的输入数据**。\n\n显然，你的程序不应该读入『输入格式』里提到的任何内容（而应该构造它们），也不应该输出『样例输出』里提到的任何内容（而是只输出你构造的输入数据）。你不应该使用样例测试你的程序，这只是对三个问题的样例说明。\n\n### 数据规模要求\n\n你给出的数据必须满足如下要求：\n\n1. 完全符合『输入格式』的规定，不能有多余的输入，但是可以有行末空格和文末回车。\n2. 数据中所有的数字都应为整数。\n3. 对于问题 1，$1 \\leq n \\leq 1000, -2 \\times 10^9 \\le a_i \\le 2 \\times 10^9$。\n4. 对于问题 2，$1 \\le p \\le 10^{12}$。\n5. 对于问题 3，$2 \\leq n \\leq 100$，$1 \\leq a_i \\leq 2 \\times 10^9$。\n\n### 目标代码\n\n你需要 hack 如下的代码：\n\n#### 问题 1\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n, ans = 0;\n  cin >> n;\n  for(int i = 1, x; i <= n; i++) {\n    cin >> x;\n    if(x % 2 == 1) ++ans;\n  }\n  cout << ans << endl;\n}\n```\n\n#### 问题 2\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nbool isprime(long long x) {\n    if(x == 1) return false;\n    for(int i = 2; i * i <= x; i++) {\n        if(x % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    long long p;\n    cin >> p;\n    if(isprime(p)) cout << \"Yes\" << endl;\n    else cout << \"No\";\n    return 0;\n}\n```\n\n#### 问题 3\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1000 + 7;\n\nint n, a[MAXN];\n\nbool check(int x) {\n    int tot = 0;\n    for(int i = 1; i <= n; i++) {\n        if(a[i] >= x) ++tot;\n    }\n    return (tot >= (n / 2));\n}\n\nint main() {\n    cin >> n;\n    for(int i = 1; i <= n; i++) cin >> a[i];\n    int L = 1, R = 2000000000, ans;\n    while(L <= R) {\n        int mid = (L + R) / 2;\n        if(check(mid)) ans = mid, L = mid + 1;\n        else R = mid - 1;\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n目标代码的编译选项为 `-std=c++14 -fno-asm -O2`。编译器为洛谷提供的 g++。你可以在『在线 IDE』中选择 C++14 语言来获得完全相同的编译环境。\n\n### 判分说明\n\n本题共三个测试点，分别对应三个问题，测试点分值依次为 $30$分、$30$ 分、$40$ 分。\n\n#### 数据判定\n\n你给出的数据必须完全符合『数据规模要求』，否则将得到 Unaccepted 的结果。\n\n#### 超时判定\n\n程序每执行若干条指令，我们会检测一遍程序的运行时间。我们保证两次检测之间的指令条数是一个输入规模无关的量，也即每执行 $O(1)$ 条指令会进行一次检测。且两次检测之间的指令条数不会太多，一般不超过 $100$ 条 C++ 语句。\n\n如果程序的运行时间超过 $500 \\text{ms}$，则判定为程序运行超时，返回 accepted 结果。\n\n#### 结果错误判定\n\n如果程序在规定的时间内结束且给出了一个输出，我们会比较这个输出和**完全正确的输出**，如果二者不同，则判定为 hack 成功，返回 accepted 结果。\n\n#### 未定义行为判定\n\n我们会在每次**显式**的调用数组元素前判断数组下标是否超过数组范围，如果超过，则判定为 hack 成功，返回 accepted 结果。\n\n这就是说，如果你希望通过未定义行为进行 hack，只能对显式的调用数组元素的行为进行 hack。\n\n### 样例程序\n\n这是一份可以帮你理解你需要输出的内容的样例程序，**但它不能给出正确的 hack 数据**。直接提交此程序不会得分。\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n  int taskId;\n  cin >> taskId;\n  if (taskId == 1) {\n    cout << \"\" <<endl;\n  } else if (taskId == 2) {\n    cout << \"\" << endl;\n  } else if (taskId == 3) {\n    cout << \"\" << endl;\n  } else { // 这个 else 不会被执行\n    cout << \"QiHai Nanami\" << endl;\n  }\n}\n```\n\n如果你使用『提交答案』功能，请务必保证打开压缩包后能且仅能**直接**看到三个 `.in` 文件。这就是说，文件结构必须是：\n\n```plain\nans.zip\n |---1.in\n |---2.in\n |---3.in\n```\n\n三个文件不应该被额外的文件夹包含，即文件结构不能是：\n\n```plain\nans.zip\n |---ans(folder)\n      |---1.in\n      |---2.in\n      |---3.in\n```\n\n### 关于评测信息的说明\n\n如果 hack 成功，对应测试点的信息为 accepted。如果返回其他信息，说明程序本身有误。\n\n例如，如果返回 TLE，不代表成功的将对应程序 hack 至超时，而是表示数据生成器本身运行超时，测试点不得分。\n\n特别的，返回 UKE 结果可能是数据不合法（有多余内容、缺少内容或数据范围不符合要求）。", "locale": "zh-CN"}}}
{"pid": "P9010", "type": "P", "difficulty": 2, "samples": [["4\nGHHG\n2 4 3 4", "1"], ["3\nGGH\n2 3 3", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "USACO", "2023"], "title": "[USACO23JAN] Leaders B", "background": "", "description": "Farmer John has $N$ cows $(2 \\le N \\le 10^5)$. Each cow has a breed that is either Guernsey or Holstein. As is often the case, the cows are standing in a line, numbered $1 \\cdots N$ in this order.\n\nOver the course of the day, each cow writes down a list of cows. Specifically, cow $i$\n's list contains the range of cows starting with herself (cow $i$) up to and including cow $E_i(i \\le E_i \\le N)$.\n\nFJ has recently discovered that each breed of cow has exactly one distinct leader. FJ does not know who the leaders are, but he knows that each leader must have a list that includes all the cows of their breed, or the other breed's leader (or both).\n\nHelp FJ count the number of pairs of cows that could be leaders. It is guaranteed that there is at least one possible pair. ", "inputFormat": "The first line contains $N$.\n\nThe second line contains a string of length $N$\n, with the ith character denoting the breed of the $i$-th cow (G meaning Guernsey and H meaning Holstein). It is guaranteed that there is at least one Guernsey and one Holstein.\n\nThe third line contains $E_1 \\cdots E_N$. ", "outputFormat": "Output the number of possible pairs of leaders. ", "hint": "### Explanation for Sample 1\n\nThe only valid leader pair is $(1,2)$. Cow $1$'s list contains the other breed's leader (cow $2$). Cow $2$'s list contains all cows of her breed (Holstein).\n\nNo other pairs are valid. For example, $(2,4)$\nis invalid since cow $4$'s list does not contain the other breed's leader, and it also does not contain all cows of her breed.\n\n### Explanation for Sample 2\n\nThere are two valid leader pairs, $(1,3)$ and $(2,3)$.\n\n### Scoring\n\n - Inputs $3-5$: $N \\le 100$  \n - Inputs $6-10$: $N \\le 3000$\n - Inputs $11-17$: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23JAN] Leaders B", "background": "", "description": "Farmer John has $N$ cows $(2 \\le N \\le 10^5)$. Each cow has a breed that is either Guernsey or Holstein. As is often the case, the cows are standing in a line, numbered $1 \\cdots N$ in this order.\n\nOver the course of the day, each cow writes down a list of cows. Specifically, cow $i$\n's list contains the range of cows starting with herself (cow $i$) up to and including cow $E_i(i \\le E_i \\le N)$.\n\nFJ has recently discovered that each breed of cow has exactly one distinct leader. FJ does not know who the leaders are, but he knows that each leader must have a list that includes all the cows of their breed, or the other breed's leader (or both).\n\nHelp FJ count the number of pairs of cows that could be leaders. It is guaranteed that there is at least one possible pair. ", "inputFormat": "The first line contains $N$.\n\nThe second line contains a string of length $N$\n, with the ith character denoting the breed of the $i$-th cow (G meaning Guernsey and H meaning Holstein). It is guaranteed that there is at least one Guernsey and one Holstein.\n\nThe third line contains $E_1 \\cdots E_N$. ", "outputFormat": "Output the number of possible pairs of leaders. ", "hint": "### Explanation for Sample 1\n\nThe only valid leader pair is $(1,2)$. Cow $1$'s list contains the other breed's leader (cow $2$). Cow $2$'s list contains all cows of her breed (Holstein).\n\nNo other pairs are valid. For example, $(2,4)$\nis invalid since cow $4$'s list does not contain the other breed's leader, and it also does not contain all cows of her breed.\n\n### Explanation for Sample 2\n\nThere are two valid leader pairs, $(1,3)$ and $(2,3)$.\n\n### Scoring\n\n - Inputs $3-5$: $N \\le 100$  \n - Inputs $6-10$: $N \\le 3000$\n - Inputs $11-17$: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23JAN] Leaders B", "background": "", "description": "农夫约翰有 $N$ 头牛 $(2 \\le N \\le 10^5)$。每头牛的品种要么是 Guernsey，要么是 Holstein。通常情况下，牛站成一排，按顺序编号为 $1 \\cdots N$。\n\n在一天的过程中，每头牛都会写下一个牛的列表。具体来说，第 $i$ 头牛的列表包含从她自己（第 $i$ 头牛）开始到包括第 $E_i(i \\le E_i \\le N)$ 头牛的范围。\n\nFJ 最近发现，每种牛的品种都有一个独特的领导者。FJ 不知道领导者是谁，但他知道每个领导者的列表必须包括其品种的所有牛，或者其他品种的领导者（或两者）。\n\n帮助 FJ 计算可能成为领导者的牛对数。保证至少有一对可能的领导者。", "inputFormat": "第一行包含 $N$。\n\n第二行包含一个长度为 $N$ 的字符串，其中第 $i$ 个字符表示第 $i$ 头牛的品种（G 表示 Guernsey，H 表示 Holstein）。保证至少有一个 Guernsey 和一个 Holstein。\n\n第三行包含 $E_1 \\cdots E_N$。", "outputFormat": "输出可能的领导者对数。", "hint": "### 样例 1 的解释\n\n唯一有效的领导者对是 $(1,2)$。第 1 头牛的列表包含其他品种的领导者（第 2 头牛）。第 2 头牛的列表包含她品种的所有牛（Holstein）。\n\n没有其他对是有效的。例如，$(2,4)$ 是无效的，因为第 4 头牛的列表不包含其他品种的领导者，也不包含她品种的所有牛。\n\n### 样例 2 的解释\n\n有两个有效的领导者对，$(1,3)$ 和 $(2,3)$。\n\n### 评分\n\n- 输入 $3-5$：$N \\le 100$\n- 输入 $6-10$：$N \\le 3000$\n- 输入 $11-17$：没有额外的限制。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9011", "type": "P", "difficulty": 2, "samples": [["2 4\n1 5 2\n7 9 3\n2 9 2 3\n1 6 2 8\n1 2 4 2\n6 9 1 5", "10"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["USACO", "2023", "深度优先搜索 DFS", "差分"], "title": "[USACO23JAN] Air Cownditioning II B", "background": "", "description": "With the hottest recorded summer ever at Farmer John's farm, he needs a way to cool down his cows. Thus, he decides to invest in some air conditioners.\n\nFarmer John's $N$ cows $(1 \\le N \\le 20)$ live in a barn that contains a sequence of stalls in a row, numbered $1 \\cdots 100$. Cow $i$ occupies a range of these stalls, starting from stall $s_i$ and ending with stall $t_i$. The ranges of stalls occupied by different cows are all disjoint from each-other. Cows have different cooling requirements. Cow $i$ must be cooled by an amount $c_i$, meaning every stall occupied by cow $i$ must have its temperature reduced by at least $c_i$ units.\n\nThe barn contains $M$ air conditioners, labeled $1 \\cdots M (1 \\le M \\le 10)$. The $i$-th air conditioner costs $m_i$ units of money to operate $(1 \\le m_i \\le 1000)$ and cools the range of stalls starting from stall $a_i$ and ending with stall $b_i$. If running, the $i$-th air conditioner reduces the temperature of all the stalls in this range by $p_i (1 \\le p_i \\le 10^6)$. Ranges of stalls covered by air conditioners may potentially overlap.\n\nRunning a farm is no easy business, so FJ has a tight budget. Please determine the minimum amount of money he needs to spend to keep all of his cows comfortable. It is guaranteed that if FJ uses all of his conditioners, then all cows will be comfortable. ", "inputFormat": "The first line of input contains $N$ and $M$.\n\nThe next $N$ lines describe cows. The ith of these lines contains $s_i, t_i$, and $c_i$.\n\nThe next $M$ lines describe air conditioners. The ith of these lines contains $a_i, b_i, p_i$, and $m_i$.\n\nFor every input other than the sample, you can assume that $M=10$. ", "outputFormat": "Output a single integer telling the minimum amount of money FJ needs to spend to operate enough air conditioners to satisfy all his cows (with the conditions listed above). ", "hint": "### Explanation for Sample 1\n\nOne possible solution that results in the least amount of money spent is to select those that cool the intervals $[2,9], [1,2]$, and $[6,9]$, for a cost of $3+2+5=10$. ", "locale": "en", "translations": {"en": {"title": "[USACO23JAN] Air Cownditioning II B", "background": "", "description": "With the hottest recorded summer ever at Farmer John's farm, he needs a way to cool down his cows. Thus, he decides to invest in some air conditioners.\n\nFarmer John's $N$ cows $(1 \\le N \\le 20)$ live in a barn that contains a sequence of stalls in a row, numbered $1 \\cdots 100$. Cow $i$ occupies a range of these stalls, starting from stall $s_i$ and ending with stall $t_i$. The ranges of stalls occupied by different cows are all disjoint from each-other. Cows have different cooling requirements. Cow $i$ must be cooled by an amount $c_i$, meaning every stall occupied by cow $i$ must have its temperature reduced by at least $c_i$ units.\n\nThe barn contains $M$ air conditioners, labeled $1 \\cdots M (1 \\le M \\le 10)$. The $i$-th air conditioner costs $m_i$ units of money to operate $(1 \\le m_i \\le 1000)$ and cools the range of stalls starting from stall $a_i$ and ending with stall $b_i$. If running, the $i$-th air conditioner reduces the temperature of all the stalls in this range by $p_i (1 \\le p_i \\le 10^6)$. Ranges of stalls covered by air conditioners may potentially overlap.\n\nRunning a farm is no easy business, so FJ has a tight budget. Please determine the minimum amount of money he needs to spend to keep all of his cows comfortable. It is guaranteed that if FJ uses all of his conditioners, then all cows will be comfortable. ", "inputFormat": "The first line of input contains $N$ and $M$.\n\nThe next $N$ lines describe cows. The ith of these lines contains $s_i, t_i$, and $c_i$.\n\nThe next $M$ lines describe air conditioners. The ith of these lines contains $a_i, b_i, p_i$, and $m_i$.\n\nFor every input other than the sample, you can assume that $M=10$. ", "outputFormat": "Output a single integer telling the minimum amount of money FJ needs to spend to operate enough air conditioners to satisfy all his cows (with the conditions listed above). ", "hint": "### Explanation for Sample 1\n\nOne possible solution that results in the least amount of money spent is to select those that cool the intervals $[2,9], [1,2]$, and $[6,9]$, for a cost of $3+2+5=10$. ", "locale": "en"}, "zh-CN": {"title": "[USACO23JAN] Air Cownditioning II B", "background": "", "description": "农夫约翰的 $N$ 头奶牛 $(1≤N≤20)$ 住在一个谷仓里，谷仓里有连续的牛栏，编号为 $1-100$ 。 奶牛 $i$ 占据了编号 $[s_i,t_i]$ 的牛栏。 不同奶牛占据的牛栏范围是互不相交的。 奶牛有不同的冷却要求，奶牛 $i$ 占用的每个牛栏的温度必须至少降低 $c_i$ 单位。\n\n谷仓包含 $M$ 台空调，标记为 $1-M$ $(1\\le M\\le10)$。第 $i$ 台空调需要花费 $m_i$ 单位的金钱来运行 $(1\\le m_i \\le 1000)$ ，如果运行，第 $i$ 台空调将牛栏 $[a_i,b_i]$ 所有牛栏的温度降低 $p_i$（$1\\le p_i\\le10^6）$。 空调覆盖的牛栏范围可能会重叠。\n\n请帮助农夫约翰求出满足所有奶牛需求要花费的最少金钱。", "inputFormat": "第一行两个整数，分别为 $N$ 和 $M$。\n\n第 $2$ 至 $(N+1)$ 行，每行三个整数，分别为 $s_i$、$t_i$ 和 $c_i$ 。\n\n第 $(N+2)$ 至 $(M+N+1)$ 行，每行四个整数， 分别为 $a_i$、$b_i$、$p_i$ 和 $m_i$。", "outputFormat": "一个整数，表示最少花费的金钱。", "hint": "### 样例解释 1\n\n一种花费最少的可能解决方案是选择那些冷却区间为 $[2,9]$ 、$[1,2]$ 和 $[6,9]$ 的空调，成本为 $ 3+2+5=10$ .\n\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 20$， $1 \\le M \\le 10$, $ 1 \\le a_i, b_i, s_i, t_i \\le 100$, $1 \\le c_i, p_i \\le 10^6$， $1 \\le m_i \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P9012", "type": "P", "difficulty": 2, "samples": [["3\nMOMMOM\nMMO\nMOO", "4\n-1\n0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "USACO", "2023", "分类讨论"], "title": "[USACO23JAN] Moo Operations B", "background": "", "description": "Because Bessie is bored of playing with her usual text string where the only characters are `C`, `O`, and `W`, Farmer John gave her $Q$ new strings $(1 \\le Q \\le 100)$, where the only characters are `M` and `O`. Bessie's favorite word out of the characters `M` and `O` is obviously `MOO`, so she wants to turn each of the $Q$ strings into `MOO` using the following operations:\n\n1. Replace either the first or last character with its opposite (so that 'M' becomes 'O' and 'O' becomes 'M').\n2. Delete either the first or last character. \n\nUnfortunately, Bessie is lazy and does not want to perform more operations than absolutely necessary. For each string, please help her determine the minimum number of operations necessary to form `MOO` or output $−1$ if this is impossible. ", "inputFormat": "The first line of input contains the value of $Q$.\n\nThe next $Q$ lines of input each consist of a string, each of its characters either `M` or `O`. Each string has at least $1$ and at most $100$ characters. ", "outputFormat": "Output the answer for each input string on a separate line. ", "hint": "### Explanation for Sample 1\n\nA sequence of $4$ operations transforming the first string into `MOO` is as follows:\n\nReplace the last character with `O` (operation 1)  \nDelete the first character (operation 2)  \nDelete the first character (operation 2)  \nDelete the first character (operation 2)  \n\nThe second string cannot be transformed into `MOO`. The third string is already `MOO`, so no operations need to be performed. \n\n### Scoring\n\n - Inputs $2-4$: Every string has length at most $3$.\n - Inputs $5-11$: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23JAN] Moo Operations B", "background": "", "description": "Because Bessie is bored of playing with her usual text string where the only characters are `C`, `O`, and `W`, Farmer John gave her $Q$ new strings $(1 \\le Q \\le 100)$, where the only characters are `M` and `O`. Bessie's favorite word out of the characters `M` and `O` is obviously `MOO`, so she wants to turn each of the $Q$ strings into `MOO` using the following operations:\n\n1. Replace either the first or last character with its opposite (so that 'M' becomes 'O' and 'O' becomes 'M').\n2. Delete either the first or last character. \n\nUnfortunately, Bessie is lazy and does not want to perform more operations than absolutely necessary. For each string, please help her determine the minimum number of operations necessary to form `MOO` or output $−1$ if this is impossible. ", "inputFormat": "The first line of input contains the value of $Q$.\n\nThe next $Q$ lines of input each consist of a string, each of its characters either `M` or `O`. Each string has at least $1$ and at most $100$ characters. ", "outputFormat": "Output the answer for each input string on a separate line. ", "hint": "### Explanation for Sample 1\n\nA sequence of $4$ operations transforming the first string into `MOO` is as follows:\n\nReplace the last character with `O` (operation 1)  \nDelete the first character (operation 2)  \nDelete the first character (operation 2)  \nDelete the first character (operation 2)  \n\nThe second string cannot be transformed into `MOO`. The third string is already `MOO`, so no operations need to be performed. \n\n### Scoring\n\n - Inputs $2-4$: Every string has length at most $3$.\n - Inputs $5-11$: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23JAN] Moo Operations B", "background": "", "description": "农夫约翰给了奶牛贝西 $Q$ 个新字符串 $(1\\le Q\\le100)$ ，其中只有字符 `M` 和 `O` ，她想将 $Q$ 个字符串都变成 `MOO`。\n\n贝西可以用如下的方式改变字符串：\n- 用相反的字符替换第一个或最后一个字符（将 `M` 变成 `O` ，将 `O` 变成 `M` ）。\n- 删除第一个或最后一个字符。\n\n贝西只想用最少的次数完成改变。请你帮她找到需要的最小改变次数。如果不可能在有限的步数中完成这个任务，请输出 `-1` 。", "inputFormat": "输入数据的第一行是一个正整数 $Q$ 。\n\n接下来的 $Q$ 行中，每行一个只包含大写字母 `M` 或 `O` 的字符串 $S$ ，保证 $ 1\\le |S| \\le 100$ 。", "outputFormat": "输出 $Q$ 行，每行为该测试点最小操作次数，如果不可能在有限的步数中完成这个任务，请输出 `-1` 。", "hint": "### 样例解释 1\n将第一个字符串转换为 `MOO`的 $4$ 个操作序列如下：\n- 用O替换最后一个字符（操作1）\n- 删除第一个字符（操作2）\n- 删除第一个字符（操作2）\n- 删除第一个字符（操作2）\n\n可以证明，第二个字符串无法转换为 `MOO`。 \n\n第三个字符串已经是 `MOO`，因此无需执行任何操作。\n\n对于 $100\\%$ 的测试点，保证 $1 \\le Q \\le 100$, $ 1\\le |S| \\le 100$ 。", "locale": "zh-CN"}}}
{"pid": "P9013", "type": "P", "difficulty": 5, "samples": [["4\nabc\nabc\nBBC\nABC\nabc\nbbc\nABCD\nBACD", "0\n-1\n1\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["USACO", "2023", "图论建模", "基环树"], "title": "[USACO23JAN] Find and Replace S", "background": "", "description": "Bessie is using the latest and greatest innovation in text-editing software, miV! She starts with an input string consisting solely of upper and lowercase English letters and wishes to transform it into some output string. With just one keystroke, miV allows her to replace all occurrences of one English letter $c_1$ in the string with another English letter $c_2$. For example, given the string `aAbBa`, if Bessie selects $c_1$ as `a` and $c_2$ as `B`, the given string transforms into `BAbBB`.\n\nBessie is a busy cow, so for each of $T\n(1 \\le T \\le 10)$ independent test cases, output the minimum number of keystrokes required to transform her input string into her desired output string. ", "inputFormat": "The first line contains $T$, the number of independent test cases.\n\nThe following $T$ pairs of lines contain an input and output string of equal length. All characters are upper or lowercase English letters (either `A` through `Z` or `a` through `z`). The sum of the lengths of all strings does not exceed $10^5$. ", "outputFormat": "For each test case, output the minimum number of keystrokes required to change the input string into the output string, or $−1$ if it is impossible to do so. ", "hint": "### Explanation for Sample 1\n\nThe first input string is the same as its output string, so no keystrokes are required.\n\nThe second input string cannot be changed into its output string because Bessie cannot change one `B`' to `A` while keeping the other as `B`.\n\nThe third input string can be changed into its output string by changing `a` to `b`.\n\nThe last input string can be changed into its output string like so: $\\texttt{ABCD} \\rightarrow \\texttt{EBCD} \\rightarrow \\texttt{EACD} \\rightarrow \\texttt{BACD}$.\n\n### Scoring\n\n - Inputs $2-6$: Every string has a length at most $50$.\n - Inputs $7-9$: All strings consist only of lowercase letters `a` through `e`\n - Inputs $10-15$: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23JAN] Find and Replace S", "background": "", "description": "Bessie is using the latest and greatest innovation in text-editing software, miV! She starts with an input string consisting solely of upper and lowercase English letters and wishes to transform it into some output string. With just one keystroke, miV allows her to replace all occurrences of one English letter $c_1$ in the string with another English letter $c_2$. For example, given the string `aAbBa`, if Bessie selects $c_1$ as `a` and $c_2$ as `B`, the given string transforms into `BAbBB`.\n\nBessie is a busy cow, so for each of $T\n(1 \\le T \\le 10)$ independent test cases, output the minimum number of keystrokes required to transform her input string into her desired output string. ", "inputFormat": "The first line contains $T$, the number of independent test cases.\n\nThe following $T$ pairs of lines contain an input and output string of equal length. All characters are upper or lowercase English letters (either `A` through `Z` or `a` through `z`). The sum of the lengths of all strings does not exceed $10^5$. ", "outputFormat": "For each test case, output the minimum number of keystrokes required to change the input string into the output string, or $−1$ if it is impossible to do so. ", "hint": "### Explanation for Sample 1\n\nThe first input string is the same as its output string, so no keystrokes are required.\n\nThe second input string cannot be changed into its output string because Bessie cannot change one `B`' to `A` while keeping the other as `B`.\n\nThe third input string can be changed into its output string by changing `a` to `b`.\n\nThe last input string can be changed into its output string like so: $\\texttt{ABCD} \\rightarrow \\texttt{EBCD} \\rightarrow \\texttt{EACD} \\rightarrow \\texttt{BACD}$.\n\n### Scoring\n\n - Inputs $2-6$: Every string has a length at most $50$.\n - Inputs $7-9$: All strings consist only of lowercase letters `a` through `e`\n - Inputs $10-15$: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23JAN] Find and Replace S", "background": null, "description": "Bessie 正在使用世界上最先进最伟大的文本编辑器：miV！她想将一个仅由大写和小写英文字母组成的字符串转换为一个新的字符串。每一次操作，miV 可以将字符串中所有的字母  $c_1$ 替换成另一种字母 $c_2$。例：对于字符串`aAbBa`，如果将其中的 `a` 替换成 `B`，那么字符串会变为`BAbBB`。\n\nBessie 非常地忙碌，所以对于给出的 $T\n(1 \\le T \\le 10)$ 组测试数据，请输出她至少需要多少次操作才能把原字符串转换为新字符串。", "inputFormat": "第一行是一个整数 $T$，表示测试数据的数量。\n\n接下来有 $T$ 对长度相等的字符串。字符串中所有的字符都是大写或小写的字母。字符串的长度不会超过 $10^5$。", "outputFormat": "对于每组测试数据，输出转换字符串需要的最小操作数。\n\n如果这不可能做到，输出 $-1$。\n\n### 样例 1 解释\n\n第一组数据：两个字符串相等，所以不需要任何操作。\n\n第二组数据：你不可能在把其中一个 `B` 转换为 `A`的同时保持剩下一个 `B` 不变。\n\n第三组数据：你可以把字符串中所有的 `a` 转换为 `b`。\n\n第四组数据：你可以按 $\\texttt{ABCD} \\rightarrow \\texttt{EBCD} \\rightarrow \\texttt{EACD} \\rightarrow \\texttt{BACD}$ 的方式转换。", "hint": "- 对于 $ 40 \\% $ 的数据，字符串的长度不超过 $50$。\n - 对于另外 $ 20\\% $ 的数据，所有的字符串仅包含从 `a` 到 `e` 的小写字母。\n - 对于 $ 100\\% $ 的数据，字符串的长度不超过 $10^5$，$1 \\le T \\le 10$。", "locale": "zh-CN"}}}
{"pid": "P9014", "type": "P", "difficulty": 3, "samples": [["2\nRR 1\nDD 10\n100 500\n4\n1 1\n1 1\n1 1\n2 1", "602\n701\n602\n701\n1501"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "动态规划 DP", "搜索", "USACO", "2023", "深度优先搜索 DFS"], "title": "[USACO23JAN] Following Directions S", "background": "", "description": "**Note: The time limit for this problem is 8s, four times the default.** \n\nFarmer John has a big square field split up into an $(N+1) \\times (N+1) (1 \\le N \\le 1500)$ grid of cells. Let cell $(i,j)$ denote the cell in the $i$-th row from the top and $j$-th column from the left. There is one cow living in every cell $(i,j)$ such that $1 \\le i,j \\le N$, and each such cell also contains a signpost pointing either to the right or downward. Also, every cell $(i,j)$ such that either $i=N+1$ or $j=N+1$, except for $(N+1,N+1)$, contains a vat of cow feed. Each vat contains cow feed of varying price; the vat at $(i,j)$ costs $c_{i,j} (1 \\le c_{i,j} \\le 500)$ to feed each cow.\n\nEvery day at dinner time, Farmer John rings the dinner bell, and each cow keeps following the directions of the signposts until it reaches a vat, and is then fed from that vat. Then the cows all return to their original positions for the next day.\n\nTo maintain his budget, Farmer John wants to know the total cost to feed all the cows each day. However, during every day, before dinner, the cow in in some cell $(i,j)$ flips the direction of its signpost (from right to down or vice versa). The signpost remains in this direction for the following days as well, unless it is flipped back later.\n\nGiven the coordinates of the signpost that is flipped on each day, output the cost for every day (with $Q$ days in total, $1 \\le Q \\le 1500$). ", "inputFormat": "The first line contains $N (1 \\le N \\le 1500)$.\n\nThe next $N+1$ lines contain the rows of the grid from top to bottom, containing the initial directions of the signposts and the costs ci,j of each vat. The first $N$ of these lines contain a string of $N$ directions `R` or `D` (representing signposts pointing right or down, respectively), followed by the cost $c_{i,N+1}$. The $(N+1)$-th line contains $N$ costs $c_{N+1,j}$.\n\nThe next line contains $Q(1 \\le Q \\le 1500)$.\n\nThen follow $Q$ additional lines, each consisting of two integers $i$ and $j (1 \\le i,j \\le N)$, which are the coordinates of the cell whose signpost is flipped on the corresponding day. ", "outputFormat": "$Q+1$ lines: the original value of the total cost, followed by the value of the total cost after each flip. ", "hint": "### Explanation for Sample 1\n\nBefore the first flip, the cows at $(1,1)$ and $(1,2)$ cost $1$ to feed, the cow at $(2,1)$ costs $100$ to feed, and the cow at $(2,2)$ costs $500$ to feed, for a total cost of $602$. After the first flip, the direction of the signpost at $(1,1)$ changes from `R` to `D`, and the cow at $(1,1)$ now costs $100$ to feed (while the others remain unchanged), so the total cost is now $701$. The second and third flips switch the same sign back and forth. After the fourth flip, the cows at $(1,1)$ and $(2,1)$ now cost $500$ to feed, for a total cost of $1501$.\n\n### Scoring\n\n - Inputs $2-4$: $1 \\le N,Q \\le 50$\n - Inputs $5-7$: $1 \\le N,Q \\le 250$\n - Inputs $2-10$: The initial direction in each cell, as well as the queries, are uniformly randomly generated.\n - Inputs $11-15$: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23JAN] Following Directions S", "background": "", "description": "**Note: The time limit for this problem is 8s, four times the default.** \n\nFarmer John has a big square field split up into an $(N+1) \\times (N+1) (1 \\le N \\le 1500)$ grid of cells. Let cell $(i,j)$ denote the cell in the $i$-th row from the top and $j$-th column from the left. There is one cow living in every cell $(i,j)$ such that $1 \\le i,j \\le N$, and each such cell also contains a signpost pointing either to the right or downward. Also, every cell $(i,j)$ such that either $i=N+1$ or $j=N+1$, except for $(N+1,N+1)$, contains a vat of cow feed. Each vat contains cow feed of varying price; the vat at $(i,j)$ costs $c_{i,j} (1 \\le c_{i,j} \\le 500)$ to feed each cow.\n\nEvery day at dinner time, Farmer John rings the dinner bell, and each cow keeps following the directions of the signposts until it reaches a vat, and is then fed from that vat. Then the cows all return to their original positions for the next day.\n\nTo maintain his budget, Farmer John wants to know the total cost to feed all the cows each day. However, during every day, before dinner, the cow in in some cell $(i,j)$ flips the direction of its signpost (from right to down or vice versa). The signpost remains in this direction for the following days as well, unless it is flipped back later.\n\nGiven the coordinates of the signpost that is flipped on each day, output the cost for every day (with $Q$ days in total, $1 \\le Q \\le 1500$). ", "inputFormat": "The first line contains $N (1 \\le N \\le 1500)$.\n\nThe next $N+1$ lines contain the rows of the grid from top to bottom, containing the initial directions of the signposts and the costs ci,j of each vat. The first $N$ of these lines contain a string of $N$ directions `R` or `D` (representing signposts pointing right or down, respectively), followed by the cost $c_{i,N+1}$. The $(N+1)$-th line contains $N$ costs $c_{N+1,j}$.\n\nThe next line contains $Q(1 \\le Q \\le 1500)$.\n\nThen follow $Q$ additional lines, each consisting of two integers $i$ and $j (1 \\le i,j \\le N)$, which are the coordinates of the cell whose signpost is flipped on the corresponding day. ", "outputFormat": "$Q+1$ lines: the original value of the total cost, followed by the value of the total cost after each flip. ", "hint": "### Explanation for Sample 1\n\nBefore the first flip, the cows at $(1,1)$ and $(1,2)$ cost $1$ to feed, the cow at $(2,1)$ costs $100$ to feed, and the cow at $(2,2)$ costs $500$ to feed, for a total cost of $602$. After the first flip, the direction of the signpost at $(1,1)$ changes from `R` to `D`, and the cow at $(1,1)$ now costs $100$ to feed (while the others remain unchanged), so the total cost is now $701$. The second and third flips switch the same sign back and forth. After the fourth flip, the cows at $(1,1)$ and $(2,1)$ now cost $500$ to feed, for a total cost of $1501$.\n\n### Scoring\n\n - Inputs $2-4$: $1 \\le N,Q \\le 50$\n - Inputs $5-7$: $1 \\le N,Q \\le 250$\n - Inputs $2-10$: The initial direction in each cell, as well as the queries, are uniformly randomly generated.\n - Inputs $11-15$: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23JAN] Following Directions S", "background": "", "description": "**注：本题时限为 8s，是默认时限的四倍。**\n\nFarmer John 有一个正方形的草地，草地被划分为了 $(N + 1) \\times (N + 1)(1 \\leq N \\leq 1500)$ 的格子。设 $(i, j)$ 为从上到下、从左到右第 $i$ 行，第 $j$ 列的格子。每个满足 $1 \\leq i, j \\leq n$ 的格子 $(i, j)$ 之中都住着一头牛，而且每个这样的格子上都有一个路标指向右或下。除此之外，所有满足 $i = N + 1$ 或 $j = N + 1$ 的格子，除了 $(N + 1, N + 1)$ 都会有一个饲料桶。牛在每个饲料桶进食需要的价格不同；位置 $(i, j)$ 上的桶喂饱一只牛需要价格 $c_{i, j}(1 \\leq c_{i, j} \\leq 500)$。\n\n每天晚饭时间，Farmer John 摇响晚餐铃时，所有牛都沿着路标的指向前进，直到它们遇到了饲料桶，之后它们会在它们自己遇到的饲料桶那里进食。第二天，所有牛又会回到自己原来的位置。\n\n为了维持预算，Farmer John 想要知道每天喂食需要的价钱。然而，每天晚饭之前，总会有一头牛 $(i, j)$ 翻转它那里的路标（原来向下则变成向右，反之亦然）。被翻转的路标指向将在后面的日子里保持不变，除非它又被进行了翻转。\n\n给出每天被翻转的路标的坐标，请输出每天喂食需要的价格（总共有 $Q$ 天，$1 \\leq Q \\leq 1500$）。", "inputFormat": "第一行为 $N(1 \\leq N \\leq 1500)$\n\n接下来的 $N + 1$ 行从上到下输入初始的路标朝向和每个饲料桶的价格 $c_{i, j}$。前 $N$ 行每行包含一个长度为 $N$ 的字符串，其中每个字符只能是 `R` 或 `D`（`R` 表示向右，`D` 表示向下），之后是一个数，表示价格 $c_{i, N + 1}$，第 $(N + 1)$ 行包含 $N$ 个数，依次表示价格 $c_{N + 1, j}$。\n\n接下来的一行为 $Q(1 \\leq Q \\leq 1500)$。\n\n之后的 $Q$ 行，每行有两个整数 $i$ 和 $j(1 \\leq i, j \\leq N$，表示每天被翻转的路标的坐标。", "outputFormat": "共 $Q + 1$ 行：第一行是初始的总价格，之后 $Q$ 行依次是每次被翻转后的总价格。", "hint": "### 样例 1 解释\n\n在第一次翻转之前，喂养在位置 $(1, 1)$ 和 $(1, 2)$ 的牛需要的价格都为 $1$，喂养在 $(2, 1)$ 的牛需要的价格为 $100$，喂养在 $(2, 2)$ 的牛需要的价格为 $500$。总价格为 $602$。第一次翻转后，在 $(1, 1)$ 处的路标由 `R` 变为 `D`，此时在位置 $(1, 1)$ 的牛喂养的价格变为 $100$（其它牛的价格没有变化），所以总价为 $701$。第二次和第三次翻转都在来回翻转同一个路标。第四次翻转后，在位置 $(1, 1)$ 和位置 $(2, 1)$ 的牛喂养的价格变为 $500$，总价变为 $1501$。\n\n\n- 测试点 $2 - 4$ 中：$1 \\leq N, Q \\leq 50$。\n\n- 测试点 $5 - 7$ 中：$1 \\leq N, Q \\leq 250$。\n\n- 测试点 $2 - 10$ 中：每个路标初始朝向以及被翻转的路标为随机生成。\n\n- 测试点 $11 - 15$ 中：无特殊条件。", "locale": "zh-CN"}}}
{"pid": "P9015", "type": "P", "difficulty": 3, "samples": [["2\n2 4", "RRLRLL"], ["3\n2 4 4", "RRRLLRRLLL"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "USACO", "2023", "Special Judge", "构造"], "title": "[USACO23JAN] Moo Route S", "background": "", "description": "Farmer Nhoj dropped Bessie in the middle of nowhere! At time $t=0$, Bessie is located at $x=0$ on an infinite number line. She frantically searches for an exit by moving left or right by $1$ unit each second. However, there actually is no exit and after $T$ seconds, Bessie is back at $x=0$, tired and resigned.\n\nFarmer Nhoj tries to track Bessie but only knows how many times Bessie crosses $x=0.5,1.5,2.5, \\cdots ,(N−1).5$, given by an array $A_0,A_1, \\cdots ,A_{N−1} (1 \\le N \\le 10^5, 1 \\le A_i \\le 10^6, \\sum A_i \\le 10^6)$. Bessie never reaches $x>N$ nor $x<0$.\n\nIn particular, Bessie's route can be represented by a string of $T= \\sum\\limits_{i=0}^{N-1}A_i$\n$L$s and $R$s where the $i$-th character represents the direction Bessie moves in during the ith second. The number of direction changes is defined as the number of occurrences of $LR$s plus the number of occurrences of $RL$s.\n\nPlease help Farmer Nhoj find any route Bessie could have taken that is consistent with A\nand minimizes the number of direction changes. It is guaranteed that there is at least one valid route. ", "inputFormat": "The first line contains $N$. The second line contains $A_0,A_1,\\cdots ,A_{N−1}$. ", "outputFormat": "Output a string $S$ of length $T=\\sum\\limits_{i=0}^{N-1}A_i$ where $S_i$ is `L` or `R`, indicating the direction Bessie travels in during second $i$. If there are multiple routes minimizing the number of direction changes, output any. ", "hint": "### Explanation for Sample 1\n\nThere is only $1$ valid route, corresponding to the route $0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 1 \\rightarrow 2 \\rightarrow 1 \\rightarrow 0$. Since this is the only possible route, it also has the minimum number of direction changes. \n\n### Explanation for Sample 2\n\nThere are $3$ possible routes:\n\nRRLRRLRLLL  \nRRRLRLLRLL  \nRRRLLRRLLL  \n\nThe first two routes have $5$ direction changes, while the last one has only $3$. Thus the last route is the only correct output.\n\n### Scoring\n\n - Inputs $3-5$: $N \\le 2$\n - Inputs $3-10$: $T=A_0+A_1+ \\cdots +A_{N−1} \\le 5000$\n - Inputs $11-20$: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23JAN] Moo Route S", "background": "", "description": "Farmer Nhoj dropped Bessie in the middle of nowhere! At time $t=0$, Bessie is located at $x=0$ on an infinite number line. She frantically searches for an exit by moving left or right by $1$ unit each second. However, there actually is no exit and after $T$ seconds, Bessie is back at $x=0$, tired and resigned.\n\nFarmer Nhoj tries to track Bessie but only knows how many times Bessie crosses $x=0.5,1.5,2.5, \\cdots ,(N−1).5$, given by an array $A_0,A_1, \\cdots ,A_{N−1} (1 \\le N \\le 10^5, 1 \\le A_i \\le 10^6, \\sum A_i \\le 10^6)$. Bessie never reaches $x>N$ nor $x<0$.\n\nIn particular, Bessie's route can be represented by a string of $T= \\sum\\limits_{i=0}^{N-1}A_i$\n$L$s and $R$s where the $i$-th character represents the direction Bessie moves in during the ith second. The number of direction changes is defined as the number of occurrences of $LR$s plus the number of occurrences of $RL$s.\n\nPlease help Farmer Nhoj find any route Bessie could have taken that is consistent with A\nand minimizes the number of direction changes. It is guaranteed that there is at least one valid route. ", "inputFormat": "The first line contains $N$. The second line contains $A_0,A_1,\\cdots ,A_{N−1}$. ", "outputFormat": "Output a string $S$ of length $T=\\sum\\limits_{i=0}^{N-1}A_i$ where $S_i$ is `L` or `R`, indicating the direction Bessie travels in during second $i$. If there are multiple routes minimizing the number of direction changes, output any. ", "hint": "### Explanation for Sample 1\n\nThere is only $1$ valid route, corresponding to the route $0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 1 \\rightarrow 2 \\rightarrow 1 \\rightarrow 0$. Since this is the only possible route, it also has the minimum number of direction changes. \n\n### Explanation for Sample 2\n\nThere are $3$ possible routes:\n\nRRLRRLRLLL  \nRRRLRLLRLL  \nRRRLLRRLLL  \n\nThe first two routes have $5$ direction changes, while the last one has only $3$. Thus the last route is the only correct output.\n\n### Scoring\n\n - Inputs $3-5$: $N \\le 2$\n - Inputs $3-10$: $T=A_0+A_1+ \\cdots +A_{N−1} \\le 5000$\n - Inputs $11-20$: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23JAN] Moo Route S", "background": "", "description": "农夫 Nhoj 把 Bessie 丢在了一个荒无人烟的地方！在时间 $t=0$ 时，Bessie 位于无限数轴的 $x=0$ 处。她疯狂地寻找出口，每秒向左或向右移动 1 个单位。然而，实际上并没有出口，在 $T$ 秒后，Bessie 回到了 $x=0$，疲惫且无奈。\n\n农夫 Nhoj 试图追踪 Bessie，但他只知道 Bessie 穿过 $x=0.5,1.5,2.5, \\cdots ,(N-1).5$ 的次数，由数组 $A_0,A_1, \\cdots ,A_{N-1}$ 给出（$1 \\le N \\le 10^5, 1 \\le A_i \\le 10^6, \\sum A_i \\le 10^6$）。Bessie 从未到达 $x>N$ 或 $x<0$。\n\n特别地，Bessie 的路线可以用一个长度为 $T= \\sum\\limits_{i=0}^{N-1}A_i$ 的 $L$ 和 $R$ 字符串表示，其中第 $i$ 个字符表示 Bessie 在第 $i$ 秒移动的方向。方向变化的次数定义为 $LR$ 出现的次数加上 $RL$ 出现的次数。\n\n请帮助农夫 Nhoj 找到任何一个与 $A$ 一致且方向变化次数最少的 Bessie 的路线。保证至少存在一条有效路线。", "inputFormat": "第一行包含 $N$。第二行包含 $A_0,A_1,\\cdots ,A_{N-1}$。", "outputFormat": "输出一个长度为 $T=\\sum\\limits_{i=0}^{N-1}A_i$ 的字符串 $S$，其中 $S_i$ 是 `L` 或 `R`，表示 Bessie 在第 $i$ 秒的移动方向。如果有多条路线能使方向变化次数最少，输出任意一条。", "hint": "### 示例 1 的解释\n\n只有 1 条有效路线，对应的路线是 $0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 1 \\rightarrow 2 \\rightarrow 1 \\rightarrow 0$。由于这是唯一可能的路线，因此它也具有最少的方向变化次数。\n\n### 示例 2 的解释\n\n有 3 条可能的路线：\n\nRRLRRLRLLL  \nRRRLRLLRLL  \nRRRLLRRLLL  \n\n前两条路线有 5 次方向变化，而最后一条只有 3 次。因此最后一条路线是唯一正确的输出。\n\n### 评分\n\n- 输入 $3-5$：$N \\le 2$\n- 输入 $3-10$：$T=A_0+A_1+ \\cdots +A_{N-1} \\le 5000$\n- 输入 $11-20$：无额外约束。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9016", "type": "P", "difficulty": 5, "samples": [["3 8 4\na ab\na bc\nc de\nb bbb", "bdebbb"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["字符串", "搜索", "USACO", "递归", "2023"], "title": "[USACO23JAN] Find and Replace G", "background": "", "description": "Bessie is using the latest and greatest innovation in text-editing software, miV! Its powerful find-and-replace feature allows her to find all occurrences of a lowercase English letter $c$ and replace each with a nonempty string of lowercase letters $s$. For example, given the string `ball`, if Bessie selects $c$ to be `l` and $s$ to be `na`, the given string transforms into `banana`.\n\nBessie starts with the string `a` and transforms it using a number of these find-and-replace operations, resulting in a final string $S$. Since $S$ could be massive, she wants to know, given $l$ and $r$ with $1 \\le l \\le r \\min(|S|,10^{18})$, what $S_{l\\cdots r}$ (the substring of $S$ from the $l$-th to the $r$-th character inclusive) is.\n\nIt is guaranteed that the sum of $|s|$\nover all operations is at most $2 \\cdot 10^5$, and that $r−l+1 \\le 2 \\cdot 10^5$. ", "inputFormat": "The first line contains $l, r$, and the number of operations.\n\nEach subsequent line describes one operation and contains $c$ and $s$ for that operation. All characters are in the range `a` through `z`.\n\n", "outputFormat": "Output the string $S_{l \\cdots r}$ on a single line. ", "hint": "### Explanation for Sample 1\n\nThe string is transformed as follows:\n\n$$ \\texttt{a} \\rightarrow \\texttt{ab} \\rightarrow\\texttt{bcb}\\rightarrow \\texttt{bdeb}\\rightarrow \\texttt{bbbdebbb} $$\n\n### Scoring\n\n - Inputs $2-7$: $\\sum |s|,r−l+1 \\le 2000$\n - Inputs $8-15$: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23JAN] Find and Replace G", "background": "", "description": "Bessie is using the latest and greatest innovation in text-editing software, miV! Its powerful find-and-replace feature allows her to find all occurrences of a lowercase English letter $c$ and replace each with a nonempty string of lowercase letters $s$. For example, given the string `ball`, if Bessie selects $c$ to be `l` and $s$ to be `na`, the given string transforms into `banana`.\n\nBessie starts with the string `a` and transforms it using a number of these find-and-replace operations, resulting in a final string $S$. Since $S$ could be massive, she wants to know, given $l$ and $r$ with $1 \\le l \\le r \\min(|S|,10^{18})$, what $S_{l\\cdots r}$ (the substring of $S$ from the $l$-th to the $r$-th character inclusive) is.\n\nIt is guaranteed that the sum of $|s|$\nover all operations is at most $2 \\cdot 10^5$, and that $r−l+1 \\le 2 \\cdot 10^5$. ", "inputFormat": "The first line contains $l, r$, and the number of operations.\n\nEach subsequent line describes one operation and contains $c$ and $s$ for that operation. All characters are in the range `a` through `z`.\n\n", "outputFormat": "Output the string $S_{l \\cdots r}$ on a single line. ", "hint": "### Explanation for Sample 1\n\nThe string is transformed as follows:\n\n$$ \\texttt{a} \\rightarrow \\texttt{ab} \\rightarrow\\texttt{bcb}\\rightarrow \\texttt{bdeb}\\rightarrow \\texttt{bbbdebbb} $$\n\n### Scoring\n\n - Inputs $2-7$: $\\sum |s|,r−l+1 \\le 2000$\n - Inputs $8-15$: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23JAN] Find and Replace G", "background": null, "description": "你有一个字符串 $S$，最开始里面只有一个字符 $\\text{a}$，之后你要对这个字符串进行若干次操作，每次将其中每一个字符 $c$ 替换成某个字符串 $s$（例如对于字符串 $\\text{ball}$，将其中的 $\\text{l}$ 替换为 $\\text{na}$ 后将会变为 $\\text{banana}$）。现在给定 $l,r$，你需要输出 $S_{l\\ldots r}$（也就是 $S$ 的第 $l$ 个字符到第 $r$ 个字符对应的子串）是什么。", "inputFormat": "第一行三个整数，分别表示 $l,r$ 和操作次数。\n\n接下来的每一行包含一个字符 $c$ 和字符串 $s$ 表示一个操作。", "outputFormat": "一行，表示对应的子串。", "hint": "**【样例解释】**\n\n在第一个测试样例中，字符串变化如下：\n\n$$ \\texttt{a} \\rightarrow \\texttt{ab} \\rightarrow\\texttt{bcb}\\rightarrow \\texttt{bdeb}\\rightarrow \\texttt{bbbdebbb} $$\n\n**【数据范围】**\n\n$l,r\\le\\min(\\left | S \\right |,10^{18})$；\n\n$r-l+1\\le2\\times10^5$；\n\n$\\sum\\left | s \\right | \\le 2\\times 10^5$。\n\n所有的字符串都只包含小写字母 $\\text{a}-\\text{z}$。\n\n其中对于测试点 $2-7$，满足：\n\n$r-l+1\\le2000$，$\\sum\\left | s \\right | \\le 2000$。", "locale": "zh-CN"}}}
{"pid": "P9017", "type": "P", "difficulty": 5, "samples": [["4 3\n000 101\n101 100\n110 000\n111 000", "0\n1\n3\n2"], ["1 10\n1100010000 1000011000", "2"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["USACO", "2023", "状压 DP"], "title": "[USACO23JAN] Lights Off G", "background": "", "description": "**Note: The time limit for this problem is 4s, twice the default.**\n\nBessie wants to go to sleep, but the farm's lights are keeping her awake. How can she turn them off?\n\nBessie has two bit strings of length $N\n(2 \\le N \\le 20)$, representing a sequence of lights and a sequence of switches, respectively. Each light is either on (1) or off (0). Each switch is either active (1) or inactive (0).\n\nA **move** consists of the following sequence of operations: \n\n1. Toggle exactly one switch (set it to active if it is inactive, or vice versa).\n2. For each active switch, toggle the state of the corresponding light (turn it off if it is on, or vice versa).\n3. Cyclically rotate the switches to the right by one. Specifically, if the bit string corresponding to the switches is initially $s_0s_1\\cdots s_{N−1}$ then it becomes $s_{N−1}s_0s_1 \\cdots s_{N−2}$.\n\nFor $T (1 \\le T \\le 2 \\cdot 10^5)$ instances of the problem above, count the minimum number of moves required to turn all the lights off. ", "inputFormat": "First line contains $T$ and $N$.\n\nNext $T$ lines each contain a pair of length-$N$ bit strings. ", "outputFormat": " For each pair, the minimum number of moves required to turn all the lights off. ", "hint": "### Explanation for Sample 1\n\n - First test case: the lights are already all off.\n - Second test case: We flip the third switch on the first move.\n - Third test case: we flip the first switch on the first move, the second switch on the second move, and the second switch again on the third move.\n - Fourth test case: we flip the first switch on the first move and the third switch on the second move. \n \nIt can be shown that in each case this is the minimal number of moves necessary. \n\n### Explanation for Sample 2\n\nIt can be shown that $2$ moves are required to turn all lights off.\n\n - We flip the seventh switch on the first move and then again on the second move. \n \n### Scoring\n\n - Inputs $3-5$: $N \\le 8$\n - Inputs $6-13$: $N \\le 18$\n - Inputs $14-20$: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23JAN] Lights Off G", "background": "", "description": "**Note: The time limit for this problem is 4s, twice the default.**\n\nBessie wants to go to sleep, but the farm's lights are keeping her awake. How can she turn them off?\n\nBessie has two bit strings of length $N\n(2 \\le N \\le 20)$, representing a sequence of lights and a sequence of switches, respectively. Each light is either on (1) or off (0). Each switch is either active (1) or inactive (0).\n\nA **move** consists of the following sequence of operations: \n\n1. Toggle exactly one switch (set it to active if it is inactive, or vice versa).\n2. For each active switch, toggle the state of the corresponding light (turn it off if it is on, or vice versa).\n3. Cyclically rotate the switches to the right by one. Specifically, if the bit string corresponding to the switches is initially $s_0s_1\\cdots s_{N−1}$ then it becomes $s_{N−1}s_0s_1 \\cdots s_{N−2}$.\n\nFor $T (1 \\le T \\le 2 \\cdot 10^5)$ instances of the problem above, count the minimum number of moves required to turn all the lights off. ", "inputFormat": "First line contains $T$ and $N$.\n\nNext $T$ lines each contain a pair of length-$N$ bit strings. ", "outputFormat": " For each pair, the minimum number of moves required to turn all the lights off. ", "hint": "### Explanation for Sample 1\n\n - First test case: the lights are already all off.\n - Second test case: We flip the third switch on the first move.\n - Third test case: we flip the first switch on the first move, the second switch on the second move, and the second switch again on the third move.\n - Fourth test case: we flip the first switch on the first move and the third switch on the second move. \n \nIt can be shown that in each case this is the minimal number of moves necessary. \n\n### Explanation for Sample 2\n\nIt can be shown that $2$ moves are required to turn all lights off.\n\n - We flip the seventh switch on the first move and then again on the second move. \n \n### Scoring\n\n - Inputs $3-5$: $N \\le 8$\n - Inputs $6-13$: $N \\le 18$\n - Inputs $14-20$: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23JAN] Lights Off G", "background": null, "description": "给定正整数 $N$，和两个长为 $N$ 的 $01$ 序列 $a$ 和 $b$。定义一次操作为：\n\n1. 将 $b$ 序列中的一个值翻转（即 $0$ 变成 $1$，$1$ 变成 $0$，下同）。\n2. 对于 $b$ 序列中每个值为 $1$ 的位置，将 $a$ 序列中对应位置的值翻转。\n3. 将 $b$ 序列向右循环移位 $1$ 位。即若当前 $b$ 序列为 $b_1b_2\\cdots b_{n}$，则接下来变为 $b_{n}b_1b_2\\cdots b_{n-1}$。\n\n有 $T$ 次询问，对每一次询问，你需要回答出至少需要几次操作，才能使 $a$ 序列中每一个位置的值都变为 $0$。", "inputFormat": "第一行为两个正整数 $T,N\\;(1\\leq T\\leq 2\\times10^5,2\\leq N\\leq 20)$。\n\n接下来 $T$ 行，每行为两个长为 $N$ 的 $01$ 序列 $a$ 和 $b$，表示一组询问。", "outputFormat": "共 $T$ 行，每行一个正整数，表示最少的操作次数。", "hint": "### 样例一解释\n\n- 第一个测试用例：灯已经全部熄灭。\n- 第二个测试用例：我们在第一步中打开第三个开关。\n- 第三个测试用例：我们在第一次移动时翻转第一个开关，在第二次移动时扳动第二个开关，然后在第三次移动时再次翻转第二个。\n- 第四个测试用例：我们在第一次移动时打开第一个开关，在第二次移动时关闭第三个开关。\n可以证明，在每种情况下，这都是所需的最小移动次数。\n\n### 样例二解释\n\n可以看出，需要2次移动才能关闭所有灯。\n- 我们在第一步中打开第七个开关，然后在第二步中再次打开。\n\n数据范围：\n\n- 数据点 $3−5$：$N \\le 8$\n- 数据点 $6−13$：$N \\le 18$\n- 数据点 $14−20$：无额外约束。", "locale": "zh-CN"}}}
{"pid": "P9018", "type": "P", "difficulty": 5, "samples": [["2\n4 6", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["USACO", "2023", "组合数学", "排列组合"], "title": "[USACO23JAN] Moo Route G", "background": "", "description": "Farmer Nhoj dropped Bessie in the middle of nowhere! At time $t=0$, Bessie is located at $x=0$ on an infinite number line. She frantically searches for an exit by moving left or right by $1$ unit each second. However, there actually is no exit and after $T$ seconds, Bessie is back at $x=0$, tired and resigned.\n\nFarmer Nhoj tries to track Bessie but only knows how many times Bessie crosses $x=0.5,1.5,2.5,\\cdots,(N−1).5$\n, given by an array $A_0,A_1, \\cdots ,A_{N−1} (1 \\le N \\le 10^5, 1 \\le A_i \\le 10^6)$. Bessie never reaches $x>N$ nor $x<0$.\n\nIn particular, Bessie's route can be represented by a string of $T=\\sum\\limits_{i=0}^{N-1}A_i$\nLs and Rs where the ith character represents the direction Bessie moves in during the ith second. The number of direction changes is defined as the number of occurrences of $LR$s plus the number of occurrences of $RL$s.\n\nPlease help Farmer Nhoj count the number of routes Bessie could have taken that are consistent with $A$\nand minimize the number of direction changes. It is guaranteed that there is at least one valid route. ", "inputFormat": "The first line contains $N$. The second line contains $A_0,A_1, \\cdots ,A_{N−1}$. ", "outputFormat": "The number of routes Bessie could have taken, modulo $10^9+7$. ", "hint": "### Explanation for Sample 1\n\nBessie must change direction at least 5 times. There are two routes corresponding to Bessie changing direction exactly 5 times: \n\n$\\texttt{RRLRLLRRLL}$  \n$\\texttt{RRLLRRLRLL}$\n\n### Scoring\n\n - Inputs $2-4$: $N \\le 2$ and $\\max(A_i) \\le 10^3$\n - Inputs $5-7$: $N \\le 2$\n - Inputs $8-11$: $\\max(A_i) \\le 10^3$\n - Inputs $12-21$: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23JAN] Moo Route G", "background": "", "description": "Farmer Nhoj dropped Bessie in the middle of nowhere! At time $t=0$, Bessie is located at $x=0$ on an infinite number line. She frantically searches for an exit by moving left or right by $1$ unit each second. However, there actually is no exit and after $T$ seconds, Bessie is back at $x=0$, tired and resigned.\n\nFarmer Nhoj tries to track Bessie but only knows how many times Bessie crosses $x=0.5,1.5,2.5,\\cdots,(N−1).5$\n, given by an array $A_0,A_1, \\cdots ,A_{N−1} (1 \\le N \\le 10^5, 1 \\le A_i \\le 10^6)$. Bessie never reaches $x>N$ nor $x<0$.\n\nIn particular, Bessie's route can be represented by a string of $T=\\sum\\limits_{i=0}^{N-1}A_i$\nLs and Rs where the ith character represents the direction Bessie moves in during the ith second. The number of direction changes is defined as the number of occurrences of $LR$s plus the number of occurrences of $RL$s.\n\nPlease help Farmer Nhoj count the number of routes Bessie could have taken that are consistent with $A$\nand minimize the number of direction changes. It is guaranteed that there is at least one valid route. ", "inputFormat": "The first line contains $N$. The second line contains $A_0,A_1, \\cdots ,A_{N−1}$. ", "outputFormat": "The number of routes Bessie could have taken, modulo $10^9+7$. ", "hint": "### Explanation for Sample 1\n\nBessie must change direction at least 5 times. There are two routes corresponding to Bessie changing direction exactly 5 times: \n\n$\\texttt{RRLRLLRRLL}$  \n$\\texttt{RRLLRRLRLL}$\n\n### Scoring\n\n - Inputs $2-4$: $N \\le 2$ and $\\max(A_i) \\le 10^3$\n - Inputs $5-7$: $N \\le 2$\n - Inputs $8-11$: $\\max(A_i) \\le 10^3$\n - Inputs $12-21$: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23JAN] Moo Route G", "background": "", "description": "现在有一条数轴，$t$ 表示当前时刻。在 $t=0$ 时 Bessie 恰好处在 $x=0$ 的位置。\n\n接下来，每秒钟 Bessie 会向左或者向右移动一个单位距离，我们保证 Bessie 是在 $0-N$ 的位置之间移动并最终停在 $x=0$ 的位置。同时，我们有一个 $A_0,A_1,A_2\\ldots A_{N-1}$ 的数列，分别表示 Bessie 经过 $0.5,1.5,2.5\\ldots (N-1).5$ 这些点的次数。我们可以用一个由 $\\text{L}$ 和 $\\text{R}$ 组成的序列来表示 Bessie 的路径，我们称 Bessie 改变了一次方向为在序列中的相邻两个字符不同。现在我们不知道具体的移动序列是什么，但我们知道 Bessie 采用了让她改变方向次数最少的走法。现在请问 Bessie 的路径有多少种不同的可能情况？（我们称两条路径不同当且仅当这条路径对应序列中的某一位不同）", "inputFormat": "第一行一个正整数表示 $N$。\n\n接下来一行有 $N$ 个用空格分隔的正整数表示 $A_0,A_1,A_2\\ldots A_{N-1}$。", "outputFormat": "一行一个整数表示结果总数。由于这个值可能很大，请输出其对 $10^9+7$ 取模的结果。", "hint": "$N\\le10^5,\\max(A_i)\\le10^6$。\n\n对于测试点 $2-4$，满足 $N\\le2,\\max(A_i)\\le10^3$。\n\n对于测试点 $5-7$，满足 $N\\le2$。\n\n对于测试点 $8-11$，满足 $\\max(A_i)\\le10^3$。", "locale": "zh-CN"}}}
{"pid": "P9019", "type": "P", "difficulty": 6, "samples": [["8 10\nLLLLRLLLLRRRRRRR\n11011010\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n2 3\n2 4\n2 5", "1 2\n1 1\n1 2\n2 4\n2 3\n2 4\n2 3\n1 1\n1 2\n1 2"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "倍增", "USACO", "2023", "最短路"], "title": "[USACO23JAN] Tractor Paths P", "background": "", "description": "**Note: The time limit for this problem is 4s, twice the default. The memory limit for this problem is 512MB, twice the default.**\n\nFarmer John has $N\n(2 \\le N \\le 2 \\cdot 10^5)$ tractors, where the $i$-th tractor can only be used within the inclusive interval $[l_i,r_i]$. The tractor intervals have left endpoints $l_1<l_2<\\cdots <l_N$ and right endpoints $r_1<r_2< \\cdots <r_N$. Some of the tractors are special.\n\nTwo tractors $i$ and $j$ are said to be adjacent if $[l_i,r_i]$ and $[l_j,r_j]$ intersect. Farmer John can transfer from one tractor to any adjacent tractor. A path between two tractors $a$ and $b$ consists of a sequence of transfers such that the first tractor in the sequence is $a$, the last tractor in the sequence is $b$, and every two consecutive tractors in the sequence are adjacent. It is guaranteed that there is a path between tractor $1$ and tractor $N$. The length of a path is the number of transfers (or equivalently, the number of tractors within it minus one). \n\nYou are given $Q (1 \\le Q \\le 2 \\cdot 10^5)$ queries, each specifying a pair of tractors $a$ and $b (1 \\le a<b \\le N)$. For each query, output two integers: \n\n - The length of any shortest path between tractor $a$ to tractor $b$.\n - The number of special tractors such that there exists at least one shortest path from tractor $a$ to tractor $b$ containing it. ", "inputFormat": "The first line contains $N$ and $Q$.\n\nThe next line contains a string of length $2N$ consisting of Ls and Rs, representing the left and right endpoints in sorted order. It is guaranteed that for each proper prefix of this string, the number of Ls exceeds the number of Rs.\n\nThe next line contains a bit string of length $N$, representing for each tractor whether it is special or not.\n\nThe next $Q$ lines each contain two integers $a$ and $b$, specifying a query. ", "outputFormat": " For each query, the two quantities separated by spaces. ", "hint": "### Explanation for Sample 1\n\nThe $8$ tractor intervals, in order, are $[1,5],[2,10],[3,11],[4,12],[6,13],[7,14],[8,15],[9,16]$.\n\nFor the 4th query, there are three shortest paths between the 1st and 5th tractor: $1$ to $2$ to $5$, $1$ to $3$ to $5$, and $1$ to $4$ to $5$. These shortest paths all have length $2$.\n\nAdditionally, every tractor $1,2,3,4,5$\nis part of one of the three shortest paths mentioned earlier, and since $1,2,4,5$ are special, there are $4$ special tractors such that there exists at least one shortest path from tractor $1$ to $5$ containing it. \n\n### Scoring\n\n - Inputs $2-3$: $N,Q \\le 5000$\n - Inputs $4-7$: There are at most $10$ special tractors.\n - Inputs $8-16$: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23JAN] Tractor Paths P", "background": "", "description": "**Note: The time limit for this problem is 4s, twice the default. The memory limit for this problem is 512MB, twice the default.**\n\nFarmer John has $N\n(2 \\le N \\le 2 \\cdot 10^5)$ tractors, where the $i$-th tractor can only be used within the inclusive interval $[l_i,r_i]$. The tractor intervals have left endpoints $l_1<l_2<\\cdots <l_N$ and right endpoints $r_1<r_2< \\cdots <r_N$. Some of the tractors are special.\n\nTwo tractors $i$ and $j$ are said to be adjacent if $[l_i,r_i]$ and $[l_j,r_j]$ intersect. Farmer John can transfer from one tractor to any adjacent tractor. A path between two tractors $a$ and $b$ consists of a sequence of transfers such that the first tractor in the sequence is $a$, the last tractor in the sequence is $b$, and every two consecutive tractors in the sequence are adjacent. It is guaranteed that there is a path between tractor $1$ and tractor $N$. The length of a path is the number of transfers (or equivalently, the number of tractors within it minus one). \n\nYou are given $Q (1 \\le Q \\le 2 \\cdot 10^5)$ queries, each specifying a pair of tractors $a$ and $b (1 \\le a<b \\le N)$. For each query, output two integers: \n\n - The length of any shortest path between tractor $a$ to tractor $b$.\n - The number of special tractors such that there exists at least one shortest path from tractor $a$ to tractor $b$ containing it. ", "inputFormat": "The first line contains $N$ and $Q$.\n\nThe next line contains a string of length $2N$ consisting of Ls and Rs, representing the left and right endpoints in sorted order. It is guaranteed that for each proper prefix of this string, the number of Ls exceeds the number of Rs.\n\nThe next line contains a bit string of length $N$, representing for each tractor whether it is special or not.\n\nThe next $Q$ lines each contain two integers $a$ and $b$, specifying a query. ", "outputFormat": " For each query, the two quantities separated by spaces. ", "hint": "### Explanation for Sample 1\n\nThe $8$ tractor intervals, in order, are $[1,5],[2,10],[3,11],[4,12],[6,13],[7,14],[8,15],[9,16]$.\n\nFor the 4th query, there are three shortest paths between the 1st and 5th tractor: $1$ to $2$ to $5$, $1$ to $3$ to $5$, and $1$ to $4$ to $5$. These shortest paths all have length $2$.\n\nAdditionally, every tractor $1,2,3,4,5$\nis part of one of the three shortest paths mentioned earlier, and since $1,2,4,5$ are special, there are $4$ special tractors such that there exists at least one shortest path from tractor $1$ to $5$ containing it. \n\n### Scoring\n\n - Inputs $2-3$: $N,Q \\le 5000$\n - Inputs $4-7$: There are at most $10$ special tractors.\n - Inputs $8-16$: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23JAN] Tractor Paths P", "background": null, "description": "**注意：这个问题的时间限制是4秒，内存限制是512MB，是默认值的两倍。**\n\n农民约翰有 $N\n(2 \\le N \\le 2 \\cdot 10^5)$ 台拖拉机, 其中第 $i$ 台拖拉机只能在序列 $[l_i,r_i]$ 内使用。拖拉机有左端点 $l_1<l_2<\\cdots <l_N$ 和右端点 $r_1<r_2< \\cdots <r_N$. 有一些拖拉机是特别的。\n\n如果 $[l_i,r_i]$ 和 $[l_j,r_j]$ 相交，则两台拖拉机 $i$ 和 $j$ 是相邻的。 约翰可以从一辆拖拉机转移到任何相邻的拖拉机上。两台拖拉机 $a$ 和 $b$ 之间的路径由一个传输序列组成，这样序列中的第一个拖拉机是 $a$，序列中的最后一个拖拉机是 $b$，并且序列中的每两个连续的拖拉机相邻。 保证拖拉机 $1$ 和 拖拉机 $N$ 之间有一条路径。路径的长度是转移的数量 (或等价地，其中拖拉机的数量减去 $1$)。\n\n给定 $Q (1 \\le Q \\le 2 \\cdot 10^5)$ 组询问，每次给定 $a$ 和 $b (1 \\le a<b \\le N)$。 对于每组询问，你需要回答两个问题：\n\n - $a$ 到 $b$ 的最短路径。\n - 在保证传送次数的最少的情况下，有多少个特殊拖拉机的区间可能被某条最短路经过。", "inputFormat": "第一行输入两个整数 $N$ 和 $Q$，表示有 $N$ 台拖拉机和 $Q$ 次询问。\n\n第二行输入一个长度为 $2N$ 的字符串，由大写字母 `L` 和 `R` 组成，其中第 $i$ 个 `L` 或 `R` 的位置表示 $l_i,r_i$ ，保证这个字符串的每个前缀中 `L` 的数量大于 `R` 的数量。\n\n第三行输入一个长度为 $N$ 的字符串, 表示每个拖拉机是否特殊。\n\n接下来 $Q$ 行输入两个整数 $a$ 和 $b$, 表示一次查询。", "outputFormat": "对于每一组数据，一行两个数，表示答案。", "hint": "### 样例 $1$ 解释\n\n$8$ 个拖拉机的时间间隔，按顺序，是 $[1,5],[2,10],[3,11],[4,12],[6,13],[7,14],[8,15],[9,16]$。\n\n对于第四个查询, 第 $1$ 台和第 $5$ 台拖拉机之间有三条最短路径: $1 \\rightarrow 2 \\rightarrow 5$, $1 \\rightarrow 3 \\rightarrow 5$, 和 $1 \\rightarrow 4 \\rightarrow 5$。这些最短路径的长度都为 $2$。\n\n另外, 拖拉机 $1,2,3,4,5$\n都是前面提到的三条最短路径之一的一部分, 由于 $1,2,4,5$ 是特殊的，因此有 $4$ 台特殊拖拉机，这样存在至少一条包含拖拉机 $1$ 到 $5$ 的最短路径。\n\n\n - 数据点 $2-3$： $N,Q \\le 5000$\n - 数据点 $4-7$： 最多 $10$ 台特别的拖拉机。\n - 数据点 $8-16$： 没有额外的约束。\n \n 翻译提供者：[shuqiang](https://www.luogu.com.cn/user/685964)", "locale": "zh-CN"}}}
{"pid": "P9020", "type": "P", "difficulty": 6, "samples": [["2 1\n1 10\n1 2 10\n4\n5 1\n5 2\n100 1\n100 2", "5\n50\n100\n1090"], ["4 8\n50000000 100000000 20000000 70000000\n1 2 20\n2 1 50\n2 3 90\n1 3 40\n3 1 10\n4 1 25\n1 4 5\n4 3 70\n3\n8 3\n1000000000 1\n500000 4", "160000000\n239999988050000000\n119992550000000"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["USACO", "2023", "凸包", "李超线段树", "状压 DP"], "title": "[USACO23JAN] Mana Collection P", "background": "", "description": "**Note: The time limit for this problem is 5s, 2.5 times the default. The memory limit for this problem is 512MB, twice the default.**\n\nBessie has recently taken an interest in magic and needs to collect mana for a very important spell. Bessie has $N(1 \\le N \\le 18)$ mana pools, the ith of which accumulates $m_i$ mana per second $(1 \\le m_i \\le 10^8)$. The pools are linked by a collection of $M (0 \\le M \\le N(N−1))$ directed edges $(a_i,b_i,t_i)$, meaning that she can travel from $a_i$ to $b_i$ in $t_i$ seconds $(1 \\le a_i,b_i \\le N, a_i \\neq b_i, 1 \\le t_i \\le 10^9)$. Whenever Bessie is present at a pool, she can collect all the mana stored at that location, emptying it. At time $0$, all mana pools are empty, and Bessie can select any pool to start at.\n\nAnswer $Q(1 \\le Q \\le 2 \\cdot 10^5)$ queries, each specified by two integers $s$ and $e (1 \\le s \\le 10^9, 1 \\le e \\le N)$. For each query, determine the maximum amount of mana Bessie can collect in s seconds if she must be at mana pool $e$ at the end of the $s$-th second. ", "inputFormat": "First line contains $N$ and $M$.\n\nNext line contains $m_1,m2, \\cdots ,m_N$.\n\nNext $M$ lines contain $a_i,b_i,t_i$. No ordered pair $(a_i,b_i)$ appears more than once in the input.\n\nNext line contains $Q$.\n\nNext $Q$ lines contain two integers $s$ and $e$. ", "outputFormat": "$Q$ lines, one for each query. ", "hint": "### Explanation for Sample 1\n\nFirst query: Bessie takes $5$ mana from pool $1$ after $5$ seconds.\n\nSecond query: Bessie takes $50$ mana from pool $2$ after $5$ seconds.\n\nThird query: Bessie takes $100$ mana from pool $1$ after $100$ seconds.\n\nFourth query: Bessie takes $90$ mana from pool $1$ after $90$ seconds and $1000$ mana from pool $2$ after $100$ seconds. \n\n### Explanation for Sample 2\n\nAn example where Bessie is able to collect much larger amounts of mana. \n\n### Scoring\n\n - Inputs $3-4$: $N \\le 10$,$Q \\le 100$\n - Inputs $5-9$: $N \\le 10$\n - Inputs $10-14$: $Q \\le 100$\n - Inputs $15-17$: $N=16$\n - Inputs $18-20$: $N=17$\n - Inputs $21-24$: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23JAN] Mana Collection P", "background": "", "description": "**Note: The time limit for this problem is 5s, 2.5 times the default. The memory limit for this problem is 512MB, twice the default.**\n\nBessie has recently taken an interest in magic and needs to collect mana for a very important spell. Bessie has $N(1 \\le N \\le 18)$ mana pools, the ith of which accumulates $m_i$ mana per second $(1 \\le m_i \\le 10^8)$. The pools are linked by a collection of $M (0 \\le M \\le N(N−1))$ directed edges $(a_i,b_i,t_i)$, meaning that she can travel from $a_i$ to $b_i$ in $t_i$ seconds $(1 \\le a_i,b_i \\le N, a_i \\neq b_i, 1 \\le t_i \\le 10^9)$. Whenever Bessie is present at a pool, she can collect all the mana stored at that location, emptying it. At time $0$, all mana pools are empty, and Bessie can select any pool to start at.\n\nAnswer $Q(1 \\le Q \\le 2 \\cdot 10^5)$ queries, each specified by two integers $s$ and $e (1 \\le s \\le 10^9, 1 \\le e \\le N)$. For each query, determine the maximum amount of mana Bessie can collect in s seconds if she must be at mana pool $e$ at the end of the $s$-th second. ", "inputFormat": "First line contains $N$ and $M$.\n\nNext line contains $m_1,m2, \\cdots ,m_N$.\n\nNext $M$ lines contain $a_i,b_i,t_i$. No ordered pair $(a_i,b_i)$ appears more than once in the input.\n\nNext line contains $Q$.\n\nNext $Q$ lines contain two integers $s$ and $e$. ", "outputFormat": "$Q$ lines, one for each query. ", "hint": "### Explanation for Sample 1\n\nFirst query: Bessie takes $5$ mana from pool $1$ after $5$ seconds.\n\nSecond query: Bessie takes $50$ mana from pool $2$ after $5$ seconds.\n\nThird query: Bessie takes $100$ mana from pool $1$ after $100$ seconds.\n\nFourth query: Bessie takes $90$ mana from pool $1$ after $90$ seconds and $1000$ mana from pool $2$ after $100$ seconds. \n\n### Explanation for Sample 2\n\nAn example where Bessie is able to collect much larger amounts of mana. \n\n### Scoring\n\n - Inputs $3-4$: $N \\le 10$,$Q \\le 100$\n - Inputs $5-9$: $N \\le 10$\n - Inputs $10-14$: $Q \\le 100$\n - Inputs $15-17$: $N=16$\n - Inputs $18-20$: $N=17$\n - Inputs $21-24$: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23JAN] Mana Collection P", "background": "", "description": "## 题目背景\n\n**注意：这个问题的时间限制是5秒，是默认的2.5倍。这个问题的内存限制是512MB，是默认值的两倍。**\n\n\n贝西需要为一个非常重要的法术收集法力。贝西有 $N$  $(1\\le N\\le 18)$ 个法力池，其中第 $i$ 个法力池每秒可积累 $m_i$ 法力 $(1\\le m_i\\le 10^8)$ 。这些池子由 $M$ $(0\\le M\\le N \\cdot (N-1))$  条有向边 $(a_i,b_i,t_i)$ 连接，这意味着她可以在 $t_i$ 秒内从 $a_i$ 移动到 $b_i$ $(1\\le a_i, b_i\\le N$, $a_i\\neq b_i$, $1\\le t_i\\le 10^9)$ 。每当贝西出现在一个池子里，她就可以收集储存在那个地方的所有法力，把它清空。在 $0$ 的时候，所有的法力池都是空的，贝西可以选择任何一个池子来开始收集。\n\n回答 $Q$ $(1\\le Q\\le 2\\cdot 10^5)$ 个查询，每个查询由两个整数 $s$ 和 $e$ 指定 $(1\\le s\\le 10^9$，$1\\le e\\le N)$ 。对于每个查询，如果贝西在第 $s$ 秒结束时必须在法力池 $e$ 处，请确定她在 $s$ 秒内能收集的最大法力值。", "inputFormat": "第一行包含 $N$ 和 $M$ 。\n\n下一行包含 $m_1,m_2,\\dots, m_N$ 。\n\n接下来的 $M$ 行每行包含 $a_i,b_i,t_i$ 。在输入中没有一对有序的 $(a_i,b_i)$ 出现超过一次。\n\n下一行包含 $Q$ 。\n\n接下来的 $Q$ 行每行包含两个整数 $s$ 和 $e$ 。", "outputFormat": "输出 $Q$ 行，每个查询所对应的答案。", "hint": "对于第一个样例：\n\n第一次询问。贝西在 $5$ 秒后从水池 $1$ 中取出 $5$ 个法力值。\n\n第二次查询。 $5$ 秒后，贝西从水池 $2$ 中获取 $50$ 点法力。\n\n第三次查询。 $100$ 秒后，贝西从水池 $1$ 中获取 $100$ 法力值。\n\n第四次查询。 $90$ 秒后贝西从水池 $1$ 中获得 $90$ 法力， $100$ 秒后从水池 $2$ 中获得 $1000$ 法力。\n\n测试点 $3-4$: $N\\le 10, Q\\le 100$ 。\n\n测试点 $5-9$: $N\\le 10$ 。\n\n测试点 $10-14$: $Q\\le 100$ 。\n\n测试点 $15-17$: $N = 16$ 。\n\n测试点 $18-20$: $N = 17$ 。\n\n测试点 $21-24$：没有其他约束条件 。", "locale": "zh-CN"}}}
{"pid": "P9021", "type": "P", "difficulty": 6, "samples": [["3\n1 1", "6"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["USACO", "2023", "树形 DP"], "title": "[USACO23JAN] Subtree Activation P", "background": "", "description": "For the New Year celebration, Bessie and her friends have constructed a giant tree with many glowing ornaments. Bessie has the ability to turn the ornaments on and off through remote control. Before the sun rises, she wants to toggle some of the ornaments in some order (possibly toggling an ornament more than once) such that the tree starts and ends with no ornaments on. Bessie thinks the tree looks cool if the set of activated ornaments is exactly a subtree rooted at some vertex. She wants the order of ornaments she toggles to satisfy the property that, for every subtree, at some point in time it was exactly the set of all turned on ornaments. Additionally, it takes energy to switch on and off ornaments, and Bessie does not want to waste energy, so she wants to find the minimum number of toggles she can perform. \n\nFormally, you have a tree with vertices labeled $1 \\cdots N (2 \\le N \\le 2 \\cdot 10^5)$ rooted at $1$. Each vertex is initially inactive. In one operation, you can toggle the state of a single vertex from inactive to active or vice versa. Output the minimum possible length of a sequence of operations satisfying both of the following conditions: \n\n - Define the subtree rooted at a vertex $r$ to consist of all vertices $v$ such that $r$ lies on the path from $1$ to $v$ inclusive. For every one of the $N$ subtrees of the tree, there is a moment in time when the set of active vertices is precisely those in that subtree. \n - Every vertex is inactive after the entire sequence of operations.", "inputFormat": "The first line contains $N$.\n\nThe second line contains $p_2 \\cdots p_N\n(1 \\le p_i<i)$, where $p_i$ denotes the parent of vertex $i$ in the tree. ", "outputFormat": "Output the minimum possible length. ", "hint": "### Explanation for Sample 1\n\nThere are three subtrees, corresponding to $\\{1,2,3\\}$, $\\{2\\}$, and $\\{3\\}$. Here is one sequence of operations of the minimum possible length:\n\nactivate 2  \n(activated vertices form the subtree rooted at 2)  \nactivate 1  \nactivate 3  \n(activated vertices form the subtree rooted at 1)  \ndeactivate 1  \ndeactivate 2  \n(activated vertices form the subtree rooted at 3)  \ndeactivate 3\n\n### Scoring\n\n - Inputs $2-3$: $N \\le 8$\n - Inputs $4-9$: $N \\le 40$\n - Inputs $10-15$: $N \\le 5000$\n - Inputs $16-21$: No additional constraints.\n", "locale": "en", "translations": {"en": {"title": "[USACO23JAN] Subtree Activation P", "background": "", "description": "For the New Year celebration, Bessie and her friends have constructed a giant tree with many glowing ornaments. Bessie has the ability to turn the ornaments on and off through remote control. Before the sun rises, she wants to toggle some of the ornaments in some order (possibly toggling an ornament more than once) such that the tree starts and ends with no ornaments on. Bessie thinks the tree looks cool if the set of activated ornaments is exactly a subtree rooted at some vertex. She wants the order of ornaments she toggles to satisfy the property that, for every subtree, at some point in time it was exactly the set of all turned on ornaments. Additionally, it takes energy to switch on and off ornaments, and Bessie does not want to waste energy, so she wants to find the minimum number of toggles she can perform. \n\nFormally, you have a tree with vertices labeled $1 \\cdots N (2 \\le N \\le 2 \\cdot 10^5)$ rooted at $1$. Each vertex is initially inactive. In one operation, you can toggle the state of a single vertex from inactive to active or vice versa. Output the minimum possible length of a sequence of operations satisfying both of the following conditions: \n\n - Define the subtree rooted at a vertex $r$ to consist of all vertices $v$ such that $r$ lies on the path from $1$ to $v$ inclusive. For every one of the $N$ subtrees of the tree, there is a moment in time when the set of active vertices is precisely those in that subtree. \n - Every vertex is inactive after the entire sequence of operations.", "inputFormat": "The first line contains $N$.\n\nThe second line contains $p_2 \\cdots p_N\n(1 \\le p_i<i)$, where $p_i$ denotes the parent of vertex $i$ in the tree. ", "outputFormat": "Output the minimum possible length. ", "hint": "### Explanation for Sample 1\n\nThere are three subtrees, corresponding to $\\{1,2,3\\}$, $\\{2\\}$, and $\\{3\\}$. Here is one sequence of operations of the minimum possible length:\n\nactivate 2  \n(activated vertices form the subtree rooted at 2)  \nactivate 1  \nactivate 3  \n(activated vertices form the subtree rooted at 1)  \ndeactivate 1  \ndeactivate 2  \n(activated vertices form the subtree rooted at 3)  \ndeactivate 3\n\n### Scoring\n\n - Inputs $2-3$: $N \\le 8$\n - Inputs $4-9$: $N \\le 40$\n - Inputs $10-15$: $N \\le 5000$\n - Inputs $16-21$: No additional constraints.\n", "locale": "en"}, "zh-CN": {"title": "[USACO23JAN] Subtree Activation P", "background": "", "description": "你有一棵根为 $1$ 的树，顶点标记为 $1 \\dots N$ $(2 \\le N \\le 2 \\cdot 10^5)$ 。每个顶点最初都是关闭的。在一次操作中，你可以将一个顶点的状态从关闭状态切换到开启状态，反之亦然。输出一个满足以下两个条件的操作序列的最小可能长度。\n\n- 定义以顶点 $r$ 为根的子树由所有满足 $r$ 位于从 $1$ 到 $v$ 的路径上 $($包括 $v)$ , 的顶点 $v$ 组成。每一个顶点的子树，都有一个时刻，开启状态顶点的集合恰好是该子树中的顶点。\n- 在整个操作序列之后，每个顶点都是关闭的。", "inputFormat": "第一行包含 $N$ 。\n\n第二行包含 $p_2 \\dots p_N$ ， $p_i$ 是结点 $i$ 的父亲 $(1\\le p_i < i)$ 。", "outputFormat": "输出可能的最小长度。", "hint": "有三个子树，分别对应 $\\{1,2,3\\}、\\{2\\}、\\{3\\}$ 。下面是最小可能长度的一个操作序列。\n\n- 开启 $2$ (激活的顶点形成以 $2$ 为根的子树) 。\n- 开启 $1$ 。\n- 开启 $3$ (激活的顶点形成以 $1$ 为根的子树) 。\n- 关闭 $1$ 。\n- 关闭 $2$ (激活的顶点形成以 $3$ 为根的子树) 。\n- 关闭 $3$ 。\n\n子任务：\n- 测试点 $2-3$ : $N \\le 8$\n- 测试点 $4-9$ : $N \\le 40$\n- 测试点 $10-15$ : $N \\le 5000$\n- 测试点 $16-21$ ：没有额外的限制。", "locale": "zh-CN"}}}
{"pid": "P9022", "type": "P", "difficulty": 1, "samples": [["57234\n00907\n34100\n99999\n", "right 234\nright 907\nleft 100\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "2021", "﻿基础算法", "CCC（加拿大）"], "title": "[CCC 2021 J3] Secret Instructions", "background": "", "description": "多组数据。\n\n对于每组数据读入 $5$ 个数字字符。\n\n- 如果前两个之和为奇数，输出 `left`；\n- 如果前两个之和为非零偶数，输出 `right`；\n- 如果前两个之和为零，输出 `left` 或 `right` 取决于上组数据。\n\n然后输出一个空格与后三个数字字符。", "inputFormat": "多组数据。\n\n每行 $5$ 个数字字符。\n\n读入直到 `99999`。", "outputFormat": "每行一个字符串与 $3$ 个数字字符，空格隔开。", "hint": "读入的第三个字符不会为 $0$。\n\n第一组数据不会以 $00$ 开头。\n\n译自 [CCC2021 J3](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2021/ccc/juniorEF.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCC 2021 J3] Secret Instructions", "background": "", "description": "多组数据。\n\n对于每组数据读入 $5$ 个数字字符。\n\n- 如果前两个之和为奇数，输出 `left`；\n- 如果前两个之和为非零偶数，输出 `right`；\n- 如果前两个之和为零，输出 `left` 或 `right` 取决于上组数据。\n\n然后输出一个空格与后三个数字字符。", "inputFormat": "多组数据。\n\n每行 $5$ 个数字字符。\n\n读入直到 `99999`。", "outputFormat": "每行一个字符串与 $3$ 个数字字符，空格隔开。", "hint": "读入的第三个字符不会为 $0$。\n\n第一组数据不会以 $00$ 开头。\n\n译自 [CCC2021 J3](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2021/ccc/juniorEF.pdf)。", "locale": "zh-CN"}}}
{"pid": "P9023", "type": "P", "difficulty": 2, "samples": [["3\n3\n2\nR 1\nC 1\n", "4"], ["4\n5\n7\nR 3\nC 1\nC 2\nR 2\nR 2\nC 1\nR 4\n", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "2021", "﻿基础算法", "CCC（加拿大）"], "title": "[CCC 2021 J5/S2] Modern Art", "background": null, "description": "维护一个 $01$ 矩阵，初始矩阵全为 $0$。\n\n每次操作会将一行或一列反转（$0$ 变成 $1$，$1$ 变成 $0$）。\n\n输出最后有多少个 $1$。", "inputFormat": "第一行 $M$，表示矩阵行数。\n\n第二行 $N$，表示矩阵列数。\n\n第三行 $K$，表示操作个数。\n\n接下来 $K$ 行，每行一个字符与一个数字。字符为 `R` 则表示操作某一行，`C` 表示一列。数字表示哪一行或哪一列。", "outputFormat": "一行一个数字，表示最终 $1$ 的个数。", "hint": "样例解释：\n\n```\n011           01000\n100           01000\n100           10111\n              10111\n```\n\n$$1 \\leq M\\times N\\leq 5000000,1 \\leq K\\leq 1000000$$\n\n译自 [CCC2021 J5/S2](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2021/ccc/juniorEF.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCC 2021 J5/S2] Modern Art", "background": null, "description": "维护一个 $01$ 矩阵，初始矩阵全为 $0$。\n\n每次操作会将一行或一列反转（$0$ 变成 $1$，$1$ 变成 $0$）。\n\n输出最后有多少个 $1$。", "inputFormat": "第一行 $M$，表示矩阵行数。\n\n第二行 $N$，表示矩阵列数。\n\n第三行 $K$，表示操作个数。\n\n接下来 $K$ 行，每行一个字符与一个数字。字符为 `R` 则表示操作某一行，`C` 表示一列。数字表示哪一行或哪一列。", "outputFormat": "一行一个数字，表示最终 $1$ 的个数。", "hint": "样例解释：\n\n```\n011           01000\n100           01000\n100           10111\n              10111\n```\n\n$$1 \\leq M\\times N\\leq 5000000,1 \\leq K\\leq 1000000$$\n\n译自 [CCC2021 J5/S2](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2021/ccc/juniorEF.pdf)。", "locale": "zh-CN"}}}
{"pid": "P9024", "type": "P", "difficulty": 2, "samples": [["3\n2 3 6 2\n4 1 1\n", "18.5"], ["4\n6 4 9 7 3\n5 2 4 1\n", "75.0"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "数学", "2021", "CCC（加拿大）"], "title": "[CCC 2021 S1] Crazy Fencing", "background": "", "description": "栅栏由 $N$ 块木板组成。\n\n因为是栅栏，所以第 $i$ 块的右边界与第 $i+1$ 块的左边界的高度一样。\n\n告诉你这些木板的边界的高度与这些木板的宽度，输出这些木板的总面积。", "inputFormat": "第一行一个整数 $N$。\n\n第二行 $N+1$ 个整数，表示每个边界的高度。\n\n第三行 $N$ 个整数，表示每块木板的宽度。", "outputFormat": "一行一个保留一位小数的实数，总面积。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/doy8i2lm.png)![](https://cdn.luogu.com.cn/upload/image_hosting/3q9oe7v5.png)\n\n$N\\leq 10000$，高度和宽度 $\\leq 100$。\n\n译自 [CCC2021 S2](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2021/ccc/seniorEF.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCC 2021 S1] Crazy Fencing", "background": "", "description": "栅栏由 $N$ 块木板组成。\n\n因为是栅栏，所以第 $i$ 块的右边界与第 $i+1$ 块的左边界的高度一样。\n\n告诉你这些木板的边界的高度与这些木板的宽度，输出这些木板的总面积。", "inputFormat": "第一行一个整数 $N$。\n\n第二行 $N+1$ 个整数，表示每个边界的高度。\n\n第三行 $N$ 个整数，表示每块木板的宽度。", "outputFormat": "一行一个保留一位小数的实数，总面积。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/doy8i2lm.png)![](https://cdn.luogu.com.cn/upload/image_hosting/3q9oe7v5.png)\n\n$N\\leq 10000$，高度和宽度 $\\leq 100$。\n\n译自 [CCC2021 S2](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2021/ccc/seniorEF.pdf)。", "locale": "zh-CN"}}}
{"pid": "P9025", "type": "P", "difficulty": 3, "samples": [["1\n0 1000 0\n", "0"], ["2\n10 4 3\n20 4 2\n", "20"], ["3\n6 8 3\n1 4 1\n14 5 2\n", "43"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2021", "三分", "离散化", "CCC（加拿大）"], "title": "[CCC 2021 S3] Lunch Concert", "background": "", "description": "有 $N$ 个人，第 $i$ 个人的速度为 $W_i$ **秒每米**，听力为 $D_i$，即能听见距离他不超过 $D_i$ 米处的音乐，初始在 $P_i$ 位置。\n\n你要在 $c$ 位置处开音乐会，这个 $c$ 由你决定且为整数。这 $N$ 个人都会靠近你直到能听到你。你要最小化每个人移动的时间之和。", "inputFormat": "第一行：$N$。\n\n接下来的 $N$ 行，每行依次包含 $P_i,W_i,D_i$。", "outputFormat": "一个整数：每个人移动的时间之和的最小值。（注意：答案可能超过 $2^{32}$）", "hint": "$$1\\leq N\\leq 200000,0\\leq P_i\\leq 10^9,1\\leq W_i\\leq 1000,0\\leq D_i\\leq 10^9$$\n\n译自 [CCC2021 S3](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2021/ccc/seniorEF.pdf)。\n\n###### 2023.8.10 新增一组 hack 数据。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCC 2021 S3] Lunch Concert", "background": "", "description": "有 $N$ 个人，第 $i$ 个人的速度为 $W_i$ **秒每米**，听力为 $D_i$，即能听见距离他不超过 $D_i$ 米处的音乐，初始在 $P_i$ 位置。\n\n你要在 $c$ 位置处开音乐会，这个 $c$ 由你决定且为整数。这 $N$ 个人都会靠近你直到能听到你。你要最小化每个人移动的时间之和。", "inputFormat": "第一行：$N$。\n\n接下来的 $N$ 行，每行依次包含 $P_i,W_i,D_i$。", "outputFormat": "一个整数：每个人移动的时间之和的最小值。（注意：答案可能超过 $2^{32}$）", "hint": "$$1\\leq N\\leq 200000,0\\leq P_i\\leq 10^9,1\\leq W_i\\leq 1000,0\\leq D_i\\leq 10^9$$\n\n译自 [CCC2021 S3](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2021/ccc/seniorEF.pdf)。\n\n###### 2023.8.10 新增一组 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P9026", "type": "P", "difficulty": 4, "samples": [["4 3 3\n1 2\n3 4\n4 1\n1 4 3 2\n3 4\n4 2\n3 2\n", "1\n2\n3\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "2021", "CCC（加拿大）", "最短路"], "title": "[CCC 2021 S4] Daily Commute", "background": "", "description": "已知有 $N$ 个地铁站，你家在 $1$，学校在 $N$。\n\n有 $W$ 条单向人行道。经过需要一分钟。\n\n此外还有一条环形地铁线路，依次经过 $S_1,S_2,\\cdots,S_N$，且保证 $S_1=1$。每天**有且仅有**一辆地铁在 $0$ 时刻从 $S_1$ 出发，并且恰好在第 $i$ 分钟到达 $S_i$。\n\n在接下来 $D$ 天中：\n\n- 交换 $S_{X_i}$ 和 $S_{Y_i}$。注意修改是永久的。\n- 查询从 $1$ 到 $N$ 的最短用时。你出发时地铁在 $1$。", "inputFormat": "第一行：$N,W,D$。\n\n接下来 $W$ 行：$A_i,B_i$ 表示单向人行道。\n\n接下来一行 $N$ 个数：$S$。\n\n接下来 $D$ 行：$X_i,Y_i$，保证 $2\\leq X_i,Y_i\\leq N,X_i\\neq Y_i$。", "outputFormat": "$D$ 行，每天的答案。", "hint": "$$3\\leq N\\leq 200000,0\\leq W\\leq 200000,1\\leq D\\leq 200000$$\n\n译自 [CCC2021 S4](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2021/ccc/seniorEF.pdf)。\n\n请注意常数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCC 2021 S4] Daily Commute", "background": "", "description": "已知有 $N$ 个地铁站，你家在 $1$，学校在 $N$。\n\n有 $W$ 条单向人行道。经过需要一分钟。\n\n此外还有一条环形地铁线路，依次经过 $S_1,S_2,\\cdots,S_N$，且保证 $S_1=1$。每天**有且仅有**一辆地铁在 $0$ 时刻从 $S_1$ 出发，并且恰好在第 $i$ 分钟到达 $S_i$。\n\n在接下来 $D$ 天中：\n\n- 交换 $S_{X_i}$ 和 $S_{Y_i}$。注意修改是永久的。\n- 查询从 $1$ 到 $N$ 的最短用时。你出发时地铁在 $1$。", "inputFormat": "第一行：$N,W,D$。\n\n接下来 $W$ 行：$A_i,B_i$ 表示单向人行道。\n\n接下来一行 $N$ 个数：$S$。\n\n接下来 $D$ 行：$X_i,Y_i$，保证 $2\\leq X_i,Y_i\\leq N,X_i\\neq Y_i$。", "outputFormat": "$D$ 行，每天的答案。", "hint": "$$3\\leq N\\leq 200000,0\\leq W\\leq 200000,1\\leq D\\leq 200000$$\n\n译自 [CCC2021 S4](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2021/ccc/seniorEF.pdf)。\n\n请注意常数。", "locale": "zh-CN"}}}
{"pid": "P9027", "type": "P", "difficulty": 4, "samples": [["2 2\n1 2 2\n2 2 6\n", "4 6"], ["2 2\n1 2 2\n2 2 5\n", "Impossible"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["线段树", "2021", "Special Judge", "CCC（加拿大）", "ST 表", "构造", "差分"], "title": "[CCC 2021 S5]  Math Homework", "background": "", "description": "构造一个长度为 $N$ 的整数序列 $A$，使得：\n\n1. $\\forall i=1,2,\\cdots,N,1\\leq A_i\\leq 10^9$；\n2. $\\forall i=1,2,\\cdots,M,\\gcd(A_{X_i},A_{X_i+1},\\cdots,A_{Y_i})=Z_i$。\n\n或者报告无解。", "inputFormat": "第一行，$N,M$。\n\n接下来 $M$ 行，每行有 $X_i,Y_i,Z_i$，描述一个限制 2.", "outputFormat": "一行，序列 $A$，或者 `Impossible`。", "hint": "$$1\\leq N\\leq 150000,1\\leq M\\leq 150000,1\\leq Z_i\\leq 16$$\n\n译自 [CCC2021 S5](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2021/ccc/seniorEF.pdf)。\n\nspj 在附件里，发现锅了请联系[我](/user/90693)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCC 2021 S5]  Math Homework", "background": "", "description": "构造一个长度为 $N$ 的整数序列 $A$，使得：\n\n1. $\\forall i=1,2,\\cdots,N,1\\leq A_i\\leq 10^9$；\n2. $\\forall i=1,2,\\cdots,M,\\gcd(A_{X_i},A_{X_i+1},\\cdots,A_{Y_i})=Z_i$。\n\n或者报告无解。", "inputFormat": "第一行，$N,M$。\n\n接下来 $M$ 行，每行有 $X_i,Y_i,Z_i$，描述一个限制 2.", "outputFormat": "一行，序列 $A$，或者 `Impossible`。", "hint": "$$1\\leq N\\leq 150000,1\\leq M\\leq 150000,1\\leq Z_i\\leq 16$$\n\n译自 [CCC2021 S5](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2021/ccc/seniorEF.pdf)。\n\nspj 在附件里，发现锅了请联系[我](/user/90693)。", "locale": "zh-CN"}}}
{"pid": "P9028", "type": "P", "difficulty": 1, "samples": [["4 2 2\n##\n..\n..\n##\n#.\n.#\n.#\n#.", "0\n0\n1\n1"], ["1 5 8\n.....#.#\n...#..#.\n..#.#...\n.#......\n#.......", "4"], ["2 3 3\n...\n##.\n..#\n.#.\n#..\n..#", "1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #1] Desni klik", "background": "NFP 即未来！当谈到金融话题时，Noa 的朋友们都希望听到他说这句话。", "description": "NFP 是一种加密货币。一枚 NFP 在 $s$ 天内的价值可以用一个仅包含字符``.``与``#``的 $r$ 行 $s$ 列字符矩阵表示。第 $i$ 列中自底向上第 $j$ 行的``#``表示第 $i$ 天该 NFP 的价值为 $j$。\n\nNFP 的“不安全度”定义为在 $s$ 天之内其价值到达的最大值与最小值之差。\n\n```\n....##.\n#..#...\n.##....\n......#\n```\n如上，这枚 NFP 在 $7$ 天内的价值依次为：$3,2,2,3,4,4,1$。它的“不安全度”是3。\n\n现在 Noa 想让你帮他确定他手中 $n$ 枚 NFP 的不安全度。", "inputFormat": "第一行包含三个整数 $n,r,s$，分别表示 NFP 的数量，矩阵的行数和列数。\n\n接下来 $n$ 个 $r$ 行 $s$ 列的矩阵，描述每枚 NFP 的在 $s$ 天内的价值。\n\n保证每枚 NFP 的价值矩阵的每一列都包含且仅包含一个字符``#``。", "outputFormat": "输出 $n$ 行，表示每枚 NFP 的不安全度。", "hint": "| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $5$ | $r=s=2$ |\n| $2$ | $15$ | $n=1$ |\n| $3$ | $30$ | 无特殊性质 |\n\n\n对于 $100\\%$ 的数据，$1\\leq n \\leq 20,2\\leq r,s \\leq50$。\n\n本题满分 $50$ 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #1] Desni klik", "background": "NFP 即未来！当谈到金融话题时，Noa 的朋友们都希望听到他说这句话。", "description": "NFP 是一种加密货币。一枚 NFP 在 $s$ 天内的价值可以用一个仅包含字符``.``与``#``的 $r$ 行 $s$ 列字符矩阵表示。第 $i$ 列中自底向上第 $j$ 行的``#``表示第 $i$ 天该 NFP 的价值为 $j$。\n\nNFP 的“不安全度”定义为在 $s$ 天之内其价值到达的最大值与最小值之差。\n\n```\n....##.\n#..#...\n.##....\n......#\n```\n如上，这枚 NFP 在 $7$ 天内的价值依次为：$3,2,2,3,4,4,1$。它的“不安全度”是3。\n\n现在 Noa 想让你帮他确定他手中 $n$ 枚 NFP 的不安全度。", "inputFormat": "第一行包含三个整数 $n,r,s$，分别表示 NFP 的数量，矩阵的行数和列数。\n\n接下来 $n$ 个 $r$ 行 $s$ 列的矩阵，描述每枚 NFP 的在 $s$ 天内的价值。\n\n保证每枚 NFP 的价值矩阵的每一列都包含且仅包含一个字符``#``。", "outputFormat": "输出 $n$ 行，表示每枚 NFP 的不安全度。", "hint": "| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $5$ | $r=s=2$ |\n| $2$ | $15$ | $n=1$ |\n| $3$ | $30$ | 无特殊性质 |\n\n\n对于 $100\\%$ 的数据，$1\\leq n \\leq 20,2\\leq r,s \\leq50$。\n\n本题满分 $50$ 分。", "locale": "zh-CN"}}}
{"pid": "P9029", "type": "P", "difficulty": 4, "samples": [["5 2\n1 9 22 10 19\n18 4\n5 2", "34\n-21"], ["7 4\n1 5 4 3 7 11 9\n5 4\n5 7\n7 3\n4 5", "4\n16\n7\n1"], ["3 3\n5 6 7\n10 1\n5 3\n3 3", "5\n12\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #1]  Čokolade", "background": "Lana 和 Fran 正在参观一家巧克力工厂，现在他们想买些巧克力。", "description": "巧克力工厂里有 $n$ 块不同的巧克力，其中第 $i$ 块的价格为 $c_i$。Lana 和 Fran 想买 $m$ 块巧克力。\n\nFran 有一个消费方案：\n\n•如果巧克力价格低于 $k$ 元，这块巧克力的费用将全部由 Lana 支付。\n\n•否则，Lana 将支付 $k$ 元，而 Fran 将支付其余的部分，即 $c_i−k$ 元。\n\nLana 对 Fran 的方案不满意，想要报复 Fran。设 $l$ 为 Lana 需要支付的金额，$f$ 为 Fran 需要支付的金额。Lana 将选择使 $l−f$ 的值最小的购买方案。\n\n由于 Fran 还在犹豫，不知道要买多少巧克力，所以 Lana 想知道对于给出的 $q$ 种不同的购买方案 $k_i$ 和 $m_i$，每种方案 $l−f$ 的最小值。", "inputFormat": "第一行包含两个整数 $n$ 和 $q$，分别表示巧克力的数量和询问数量。\n\n第二行包含 $n$ 个整数 $c_i$，依次表示每块巧克力的价格。\n\n接下来 $q$ 行，每行包含两个整数 $k_i$ 和 $m_i$，分别表示 Fran 的付款阈值和购买的巧克力总数量。", "outputFormat": "输出 $q$ 行，每行一个整数表示 Lana 询问的答案。", "hint": "| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $15$ | $n,q \\leq 1000,c_i,k_i\\leq 10^6$ |\n| $2$ | $20$ | 所有询问的 $k$ 都相等 |\n| $3$ | $35$ | 无特殊性质 |\n\n对于 $100\\%$ 的数据，$1\\leq m_i\\leq n,q\\leq 10^5,1\\leq c_i,k_i \\leq 10^9$。\n\n本题满分 $70$ 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #1]  Čokolade", "background": "Lana 和 Fran 正在参观一家巧克力工厂，现在他们想买些巧克力。", "description": "巧克力工厂里有 $n$ 块不同的巧克力，其中第 $i$ 块的价格为 $c_i$。Lana 和 Fran 想买 $m$ 块巧克力。\n\nFran 有一个消费方案：\n\n•如果巧克力价格低于 $k$ 元，这块巧克力的费用将全部由 Lana 支付。\n\n•否则，Lana 将支付 $k$ 元，而 Fran 将支付其余的部分，即 $c_i−k$ 元。\n\nLana 对 Fran 的方案不满意，想要报复 Fran。设 $l$ 为 Lana 需要支付的金额，$f$ 为 Fran 需要支付的金额。Lana 将选择使 $l−f$ 的值最小的购买方案。\n\n由于 Fran 还在犹豫，不知道要买多少巧克力，所以 Lana 想知道对于给出的 $q$ 种不同的购买方案 $k_i$ 和 $m_i$，每种方案 $l−f$ 的最小值。", "inputFormat": "第一行包含两个整数 $n$ 和 $q$，分别表示巧克力的数量和询问数量。\n\n第二行包含 $n$ 个整数 $c_i$，依次表示每块巧克力的价格。\n\n接下来 $q$ 行，每行包含两个整数 $k_i$ 和 $m_i$，分别表示 Fran 的付款阈值和购买的巧克力总数量。", "outputFormat": "输出 $q$ 行，每行一个整数表示 Lana 询问的答案。", "hint": "| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $15$ | $n,q \\leq 1000,c_i,k_i\\leq 10^6$ |\n| $2$ | $20$ | 所有询问的 $k$ 都相等 |\n| $3$ | $35$ | 无特殊性质 |\n\n对于 $100\\%$ 的数据，$1\\leq m_i\\leq n,q\\leq 10^5,1\\leq c_i,k_i \\leq 10^9$。\n\n本题满分 $70$ 分。", "locale": "zh-CN"}}}
{"pid": "P9030", "type": "P", "difficulty": 6, "samples": [["3 3\n0.0000000000 0.0000000000\n0.0000000000 2.0000000000\n2.0000000000 0.0000000000\n1 2\n2 3\n3 1", "DA\n0.585786\n1.414214\n1.414214"], ["5 4\n-0.4585133080 0.2893567973\n9.9368007273 7.1806641913\n-8.4621834970 -2.8309311865\n0.0122121945 -2.8309311865\n2.3991780589 -8.8626906628\n2 1\n3 2\n4 3\n5 1", "DA\n0.000000\n12.472076\n8.474396\n0.000000\n9.587824"], ["5 5\n0.0000000000 0.0000000000\n1.0000000000 2.0000000000\n2.0000000000 4.0000000000\n3.0000000000 6.0000000000\n4.0000000000 8.0000000000\n1 2\n2 3\n3 4\n4 5\n5 1", "NE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "Special Judge", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #1] Berilij", "background": "小羊 Berilij 被外星人绑架了。她需要帮助外星人解决一个问题。", "description": "就在 COCI 比赛当天，外星人计划乘 $n$ 艘宇宙飞船访问地球，授予参赛者丰厚的奖励。他们的宇宙飞船都是完美的圆形。\n\n出于安全考虑，他们选择了 $m$ 对在着陆时外部必须相接触的飞船。外星人已经确定了每艘飞船的着陆点坐标，而 Berilij 的任务是确定每艘飞船的半径，以确保所有飞船都能安全着陆。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/frerrx7n.png)\n\n如图，左右两对飞船均不满足外部接触的条件。只有中间的一对飞船满足外部接触的条件。换句话说，“外部接触”定义为当且仅当两艘飞船对应的圆形**外切**时，这两艘飞船的外部相接触。\n\n宇宙飞船造价昂贵，它们的成本等于它们的面积，所以外星人希望宇宙飞船成本尽可能小。由于外星人科技非常先进，因此外星人的宇宙飞船可以重叠，直径也可以为 $0$。\n\n如果 Berilij 不能解决这个问题，外星人将会吃掉她！请你帮帮小羊 Berilij。", "inputFormat": "第一行包含两个整数 $n,m$，分别表示外星人的飞船数量以及需要接触的飞船的对数。\n\n接下来 $n$ 行每行两个实数 $x_i,y_i$，表示第 $i$ 艘飞船着陆点的坐标。给出的坐标均精确到小数点后十位。\n\n下面的 $m$ 行包含两个整数 $a_i$ 和 $b_i$，表示第 $a_i$ 号和第 $b_i$ 号飞船在着陆后必须外部接触。数据保证无序对 $(a_i,b_i)$ 不重复。", "outputFormat": "如果无解，输出一行```NE```。\n\n否则第一行输出```DA```，接下来 $n$ 行输出成本最小的方案下每艘飞船的半径。", "hint": "当你的答案与正确答案误差不大于 $10^{-4}$ 时，答案被视为正确的。\n\n| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $15$ | $n$ 为奇数且所有飞船都恰好与两艘飞船接触 |\n| $2$ | $25$ | 数据保证有解 |\n| $3$ | $30$ | 对于任何一对飞船 $(a,b)$ 都有且仅有一个飞船序列满足其起始于 $a$ 结束于 $b$ 且此序列内任意相邻的两艘飞船都彼此接触 |\n| $4$ | $40$ | 无特殊性质 |\n\n对于 $100\\%$ 的数据，$1\\leq n,m \\leq 10^5,-10^4\\leq x_i,y_i \\leq 10^4,1\\leq a_i,b_i \\leq n$ 且 $a_i \\neq b_i$。\n\n本题满分 $110$ 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #1] Berilij", "background": "小羊 Berilij 被外星人绑架了。她需要帮助外星人解决一个问题。", "description": "就在 COCI 比赛当天，外星人计划乘 $n$ 艘宇宙飞船访问地球，授予参赛者丰厚的奖励。他们的宇宙飞船都是完美的圆形。\n\n出于安全考虑，他们选择了 $m$ 对在着陆时外部必须相接触的飞船。外星人已经确定了每艘飞船的着陆点坐标，而 Berilij 的任务是确定每艘飞船的半径，以确保所有飞船都能安全着陆。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/frerrx7n.png)\n\n如图，左右两对飞船均不满足外部接触的条件。只有中间的一对飞船满足外部接触的条件。换句话说，“外部接触”定义为当且仅当两艘飞船对应的圆形**外切**时，这两艘飞船的外部相接触。\n\n宇宙飞船造价昂贵，它们的成本等于它们的面积，所以外星人希望宇宙飞船成本尽可能小。由于外星人科技非常先进，因此外星人的宇宙飞船可以重叠，直径也可以为 $0$。\n\n如果 Berilij 不能解决这个问题，外星人将会吃掉她！请你帮帮小羊 Berilij。", "inputFormat": "第一行包含两个整数 $n,m$，分别表示外星人的飞船数量以及需要接触的飞船的对数。\n\n接下来 $n$ 行每行两个实数 $x_i,y_i$，表示第 $i$ 艘飞船着陆点的坐标。给出的坐标均精确到小数点后十位。\n\n下面的 $m$ 行包含两个整数 $a_i$ 和 $b_i$，表示第 $a_i$ 号和第 $b_i$ 号飞船在着陆后必须外部接触。数据保证无序对 $(a_i,b_i)$ 不重复。", "outputFormat": "如果无解，输出一行```NE```。\n\n否则第一行输出```DA```，接下来 $n$ 行输出成本最小的方案下每艘飞船的半径。", "hint": "当你的答案与正确答案误差不大于 $10^{-4}$ 时，答案被视为正确的。\n\n| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $15$ | $n$ 为奇数且所有飞船都恰好与两艘飞船接触 |\n| $2$ | $25$ | 数据保证有解 |\n| $3$ | $30$ | 对于任何一对飞船 $(a,b)$ 都有且仅有一个飞船序列满足其起始于 $a$ 结束于 $b$ 且此序列内任意相邻的两艘飞船都彼此接触 |\n| $4$ | $40$ | 无特殊性质 |\n\n对于 $100\\%$ 的数据，$1\\leq n,m \\leq 10^5,-10^4\\leq x_i,y_i \\leq 10^4,1\\leq a_i,b_i \\leq n$ 且 $a_i \\neq b_i$。\n\n本题满分 $110$ 分。", "locale": "zh-CN"}}}
{"pid": "P9031", "type": "P", "difficulty": 5, "samples": [["3\n1 4\n0 0\n0 9", "1\n0\n3"], ["3\n5 1\n4 3\n2 4", "0\n1\n1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #1] Iksevi", "background": "写了十年的代码后，Vinko 决定转行做一名陶艺家。他在新工作的第一天就接到了一项艰巨的任务。", "description": "Vinko 需要使用正方形瓷砖铺满音乐厅的地板。他不会让瓷砖的边与墙壁平行；相反，他选择让瓷砖的对角线与墙壁平行。\n\nVinko 还没有决定他将使用的瓷砖大小，但他知道所有瓷砖必须大小相同，而且对角线的长度必须是一个正偶数。\n\nVinko 铺下的第一块瓷砖的角将与左侧和后方的墙接触。此后他铺下的每一块瓷砖都与至少一块已铺好的瓷砖有一条边重合。他将重复这以一过程，直到铺满整个 $10^7 \\times 10^7$ 平方毫米的地面。\n\n除了程序员和陶艺家，Vinko 也是一个优秀的音乐家。正因为如此，他知道地板上有 $n$ 个点对大厅的音响效果至关重要。如果瓷砖的角落位于 $n$ 个点中的一个，大厅的声学效果将显著改善。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o4bbstj2.png)\n\n如图，左图为瓷砖对角线长度为 $4$ 的铺装，在此条件下，点 $(2,4)$ 在瓷砖的角落上，此时它满足条件，使得音响效果大为改善，但点 $(4,3)$ 和 $(5,1)$ 不满足条件。右图则为瓷砖对角线长度为 $2$ 的铺装，此时点 $(4,3)$ 在四块瓷砖的角落，而点 $(2,4)$ 和 $(5,1)$ 不在。\n\n帮助 Vinko 确定对于 $n$ 个点中的每个点，有多少种瓷砖尺寸可以使铺满地面后第 $i$ 个点位于瓷砖的角落上。", "inputFormat": "第一行包含一个整数 $n$，即声学关键点的数目。\n\n接下来 $n$ 行，每行两个整数 $x_i,y_i$，表示第 $i$ 个声学关键点与左侧墙壁与后方墙壁的距离。", "outputFormat": "输出 $n$ 行，每行一个整数。\n\n第 $i$ 行表示能使 $i$ 号声学关键点位于瓷砖角落的瓷砖尺寸数。", "hint": "| 子任务 | 分值 | 数据范围 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | $15$ | $1\\leq n \\leq 10^4,0\\leq x_i,y_i \\leq 100$ |\n| $2$ | $55$ | $1\\leq n \\leq 10^4,0\\leq x_i,y_i \\leq 10^7$ |\n| $3$ | $40$ | $1\\leq n \\leq 10^6,0\\leq x_i,y_i \\leq 10^7$ |\n\n本题满分 $110$ 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #1] Iksevi", "background": "写了十年的代码后，Vinko 决定转行做一名陶艺家。他在新工作的第一天就接到了一项艰巨的任务。", "description": "Vinko 需要使用正方形瓷砖铺满音乐厅的地板。他不会让瓷砖的边与墙壁平行；相反，他选择让瓷砖的对角线与墙壁平行。\n\nVinko 还没有决定他将使用的瓷砖大小，但他知道所有瓷砖必须大小相同，而且对角线的长度必须是一个正偶数。\n\nVinko 铺下的第一块瓷砖的角将与左侧和后方的墙接触。此后他铺下的每一块瓷砖都与至少一块已铺好的瓷砖有一条边重合。他将重复这以一过程，直到铺满整个 $10^7 \\times 10^7$ 平方毫米的地面。\n\n除了程序员和陶艺家，Vinko 也是一个优秀的音乐家。正因为如此，他知道地板上有 $n$ 个点对大厅的音响效果至关重要。如果瓷砖的角落位于 $n$ 个点中的一个，大厅的声学效果将显著改善。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o4bbstj2.png)\n\n如图，左图为瓷砖对角线长度为 $4$ 的铺装，在此条件下，点 $(2,4)$ 在瓷砖的角落上，此时它满足条件，使得音响效果大为改善，但点 $(4,3)$ 和 $(5,1)$ 不满足条件。右图则为瓷砖对角线长度为 $2$ 的铺装，此时点 $(4,3)$ 在四块瓷砖的角落，而点 $(2,4)$ 和 $(5,1)$ 不在。\n\n帮助 Vinko 确定对于 $n$ 个点中的每个点，有多少种瓷砖尺寸可以使铺满地面后第 $i$ 个点位于瓷砖的角落上。", "inputFormat": "第一行包含一个整数 $n$，即声学关键点的数目。\n\n接下来 $n$ 行，每行两个整数 $x_i,y_i$，表示第 $i$ 个声学关键点与左侧墙壁与后方墙壁的距离。", "outputFormat": "输出 $n$ 行，每行一个整数。\n\n第 $i$ 行表示能使 $i$ 号声学关键点位于瓷砖角落的瓷砖尺寸数。", "hint": "| 子任务 | 分值 | 数据范围 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | $15$ | $1\\leq n \\leq 10^4,0\\leq x_i,y_i \\leq 100$ |\n| $2$ | $55$ | $1\\leq n \\leq 10^4,0\\leq x_i,y_i \\leq 10^7$ |\n| $3$ | $40$ | $1\\leq n \\leq 10^6,0\\leq x_i,y_i \\leq 10^7$ |\n\n本题满分 $110$ 分。", "locale": "zh-CN"}}}
{"pid": "P9032", "type": "P", "difficulty": 5, "samples": [["6 2\n2 1 4 4 4 2", "48"], ["4 1\n7 3 9 4", "81"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2022", "数论", "ST 表", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #1] Neboderi", "background": "Domagoj 来到了伦敦这个大城市！现在有一排高摩天大楼在他面前，他想拍张照片来纪念这一时刻。", "description": "这排摩天大楼共有 $n$ 座，它们可以被视作序列 $h_1,h_2,...h_n$，其中 $h_i$ 为第 $i$ 栋楼的高度。Domagoj 将会拍下这排大楼的一个子区间。为了更好地捕捉城市之美，他想拍摄至少 $k$ 座摩天大楼。\n\nDomagoj 有着奇怪的审美：他认为照片中有高大的摩天大楼是美的；但如果照片中所有的摩天大楼的高度有着很大的公因数，他会认为更美。\n\n如果一张照片拍下的大楼区间为 $[l,r]$，且这段区间内所有大楼高度的 $\\gcd$ 为 $g$，则 Domagoj 定义这张照片的“美丽度”为 $g \\times \\sum_{i=l}^r h_i$。\n\n帮助 Domagoj 算出他能拍到的最美照片的美丽度吧！", "inputFormat": "第一行包含两个整数 $n,k$，分别表示大楼总数和 Domagoj 至少拍到的大楼数。\n\n第二行包含 $n$ 个整数 $h_i$，依次表示每座大楼的高度。", "outputFormat": "一行一个整数，即最大美丽值。", "hint": "| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $11$ | $n,k \\leq 100$ |\n| $2$ | $22$ | $n,k \\leq 5000$ |\n| $3$ | $27$ | $k \\leq 100$ |\n| $4$ | $18$ | $n,k \\leq 5\\times 10^4$ |\n| $5$ | $32$ | 无特殊性质 |\n\n对于 $100\\%$ 的数据，满足 $1\\leq k \\leq n \\leq 10^6,1\\leq h_i \\leq 10^6$。\n\n本题满分 $110$ 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #1] Neboderi", "background": "Domagoj 来到了伦敦这个大城市！现在有一排高摩天大楼在他面前，他想拍张照片来纪念这一时刻。", "description": "这排摩天大楼共有 $n$ 座，它们可以被视作序列 $h_1,h_2,...h_n$，其中 $h_i$ 为第 $i$ 栋楼的高度。Domagoj 将会拍下这排大楼的一个子区间。为了更好地捕捉城市之美，他想拍摄至少 $k$ 座摩天大楼。\n\nDomagoj 有着奇怪的审美：他认为照片中有高大的摩天大楼是美的；但如果照片中所有的摩天大楼的高度有着很大的公因数，他会认为更美。\n\n如果一张照片拍下的大楼区间为 $[l,r]$，且这段区间内所有大楼高度的 $\\gcd$ 为 $g$，则 Domagoj 定义这张照片的“美丽度”为 $g \\times \\sum_{i=l}^r h_i$。\n\n帮助 Domagoj 算出他能拍到的最美照片的美丽度吧！", "inputFormat": "第一行包含两个整数 $n,k$，分别表示大楼总数和 Domagoj 至少拍到的大楼数。\n\n第二行包含 $n$ 个整数 $h_i$，依次表示每座大楼的高度。", "outputFormat": "一行一个整数，即最大美丽值。", "hint": "| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $11$ | $n,k \\leq 100$ |\n| $2$ | $22$ | $n,k \\leq 5000$ |\n| $3$ | $27$ | $k \\leq 100$ |\n| $4$ | $18$ | $n,k \\leq 5\\times 10^4$ |\n| $5$ | $32$ | 无特殊性质 |\n\n对于 $100\\%$ 的数据，满足 $1\\leq k \\leq n \\leq 10^6,1\\leq h_i \\leq 10^6$。\n\n本题满分 $110$ 分。", "locale": "zh-CN"}}}
{"pid": "P9033", "type": "P", "difficulty": 2, "samples": [["5\n1 2 2\n2 3 10\n2 11 8\n20 200000 99999\n11 191 9810", "2 \n4 7 \n8 3 \n-1\n191 191 191 191 191 191 191 191 191 191 191 "]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "Special Judge", "O2优化", "构造", "洛谷月赛"], "title": "「KDOI-04」XOR Sum", "background": "凯文一眼秒了这题。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lh1xvu75.png)", "description": "给定一个正整数 $n$，请构造一个长度为 $n$ 的**非负整数**序列 $a_1,a_2,\\dots,a_n$，满足：\n\n+ 对于所有 $1\\le i\\le n$，都有 $0\\le a_i\\le m$。\n+ $a_1\\oplus a_2\\oplus\\dots\\oplus a_n=k$。其中 $\\oplus$ 表示[按位异或](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677)运算。\n\n或者判断不存在这样的序列。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示测试数据组数。\n\n对于每组测试数据，输入包含一行三个非负整数 $n,k,m$。", "outputFormat": "对于每组测试数据，输出一行一个 $-1$ 表示没有这样的序列存在。\n\n否则，输出 $n$ 个用空格分隔的**非负整数**，表示你所构造的序列。如果有多个合法的答案，你只需要输出其中任意一种。", "hint": "**【样例解释】**\n\n对于第 $1$ 组测试数据，有且仅有一个序列满足条件。\n\n对于第 $2$ 组测试数据，由于 $4\\oplus 7=3$ 且 $4,7\\le10$，所以这是一个合法的答案。同样地，序列 $(2,1)$ 也是一个合法的答案。\n\n对于第 $4$ 组测试数据，可以证明不存在满足要求的序列。\n\n**【数据范围】**\n\n记 $\\sum n$ 为单个测试点中所有 $n$ 的值之和。\n\n对于所有测试数据，保证 $1\\le T\\le 1~000$，$1\\le n\\le 2\\cdot10^5$，$0\\le m,k\\le 10^8$，$\\sum n\\le 2\\cdot10^5$。\n\n**【子任务】**\n\n**本题开启捆绑测试。**\n\n+ Subtask 1 (18 pts)：$k\\le m$。\n+ Subtask 2 (82 pts)：没有额外的约束条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KDOI-04」XOR Sum", "background": "凯文一眼秒了这题。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lh1xvu75.png)", "description": "给定一个正整数 $n$，请构造一个长度为 $n$ 的**非负整数**序列 $a_1,a_2,\\dots,a_n$，满足：\n\n+ 对于所有 $1\\le i\\le n$，都有 $0\\le a_i\\le m$。\n+ $a_1\\oplus a_2\\oplus\\dots\\oplus a_n=k$。其中 $\\oplus$ 表示[按位异或](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677)运算。\n\n或者判断不存在这样的序列。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示测试数据组数。\n\n对于每组测试数据，输入包含一行三个非负整数 $n,k,m$。", "outputFormat": "对于每组测试数据，输出一行一个 $-1$ 表示没有这样的序列存在。\n\n否则，输出 $n$ 个用空格分隔的**非负整数**，表示你所构造的序列。如果有多个合法的答案，你只需要输出其中任意一种。", "hint": "**【样例解释】**\n\n对于第 $1$ 组测试数据，有且仅有一个序列满足条件。\n\n对于第 $2$ 组测试数据，由于 $4\\oplus 7=3$ 且 $4,7\\le10$，所以这是一个合法的答案。同样地，序列 $(2,1)$ 也是一个合法的答案。\n\n对于第 $4$ 组测试数据，可以证明不存在满足要求的序列。\n\n**【数据范围】**\n\n记 $\\sum n$ 为单个测试点中所有 $n$ 的值之和。\n\n对于所有测试数据，保证 $1\\le T\\le 1~000$，$1\\le n\\le 2\\cdot10^5$，$0\\le m,k\\le 10^8$，$\\sum n\\le 2\\cdot10^5$。\n\n**【子任务】**\n\n**本题开启捆绑测试。**\n\n+ Subtask 1 (18 pts)：$k\\le m$。\n+ Subtask 2 (82 pts)：没有额外的约束条件。", "locale": "zh-CN"}}}
{"pid": "P9034", "type": "P", "difficulty": 4, "samples": [["7\n1 4\n2 4\n5 3\n2 100\n3 8\n20 50\n499122178 4", "1\n2\n0\n3\n5\n39\n998244353\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2023", "洛谷原创", "O2优化", "枚举", "洛谷月赛", "分类讨论"], "title": "「KDOI-04」Again Counting Set", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/s502kfip.png)", "description": "小 S 不喜欢集合，不喜欢自然数，不喜欢求和，不喜欢求积，不喜欢最小值，不喜欢最大值，不喜欢 $\\operatorname{mex}$，所以有了这题。\n\n给出 $n,k$，求有多少个可重**整数**集合 $S$ 满足：\n\n* $|S|=k$；\n* 对于任意 $x\\in S$，$0\\le x\\le n$；\n* $\\displaystyle{\\prod_{x\\in S} x=\\min_{x\\in S} x}$；\n* $\\displaystyle{\\sum_{x\\in S} x=\\min_{x\\in S} x+\\max_{x\\in S}x+{\\operatorname{mex}}(S)}$。\n\n**注： $\\bf{mex}$ 指集合中没有出现过的最小的自然数。**", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示测试数据组数。\n\n对于每组测试数据，输入包含一行两个正整数 $n,k$。", "outputFormat": "对于每组测试数据，输出一行一个整数表示答案。", "hint": "**【补充说明】**\n\n为了更好的让选手理解题面，给出若干合法/不合法集合例子：\n\n+ $\\{0,1,2,2\\}$。\n\n该集合是一个符合要求的集合，因为 $0\\times 1\\times 2\\times 2=0=\\min\\{0,1,2,2\\}$，$0+1+2+2=5,\\min\\{0,1,2,2\\}+\\max\\{0,1,2,2\\}+\\operatorname{mex}\\{0,1,2,2\\}=0+2+3=5$。\n\n+ $\\{3,5\\}$\n\n该集合不是一个符合要求的集合，因为虽然 $3+5=8,\\min\\{3,5\\}+\\max\\{3,5\\}+\\operatorname{mex}\\{3,5\\}=3+5+0=8$，但是 $3\\times 5\\not=\\min\\{3,5\\}$。\n\n+ $\\{1,9,1,9,8,1,0\\}$。\n\n该集合不是一个符合要求的集合，因为虽然 $1\\times 9\\times 1\\times 9\\times 8\\times 1\\times 0=0=\\min\\{1,9,1,9,8,1,0\\}$，但是其和为 $29$ 而并非 $\\min+\\max+\\operatorname{mex}=0+9+2=11$。\n\n**【数据范围】**  \n\n对于 $100\\%$ 的数据，保证 $1\\le T\\le10^6$，$1\\le n,k\\le10^{18}$。\n\n|测试点编号|分值|$T\\le$|$k\\le$|$n$|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$10$|$5$|$5$|$\\le5$|\n|$2$|$10$|$10^5$|$10^{18}$|$=1$|\n|$3$|$10$|$10^5$|$10^{18}$|$=2$|\n|$4$|$10$|$10^5$|$10^{18}$|$=3$|\n|$5$|$10$|$10^5$|$10^{18}$|$=4$|\n|$6$|$10$|$10^5$|$10^{18}$|$=5$|\n|$7$|$10$|$10^5$|$10$|$\\le10$|\n|$8$|$10$|$10^5$|$10^3$|$\\le10^3$|\n|$9$|$10$|$10^6$|$10^{18}$|$\\le10^{8}$|\n|$10$|$10$|$10^6$|$10^{18}$|$\\le10^{18}$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KDOI-04」Again Counting Set", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/s502kfip.png)", "description": "小 S 不喜欢集合，不喜欢自然数，不喜欢求和，不喜欢求积，不喜欢最小值，不喜欢最大值，不喜欢 $\\operatorname{mex}$，所以有了这题。\n\n给出 $n,k$，求有多少个可重**整数**集合 $S$ 满足：\n\n* $|S|=k$；\n* 对于任意 $x\\in S$，$0\\le x\\le n$；\n* $\\displaystyle{\\prod_{x\\in S} x=\\min_{x\\in S} x}$；\n* $\\displaystyle{\\sum_{x\\in S} x=\\min_{x\\in S} x+\\max_{x\\in S}x+{\\operatorname{mex}}(S)}$。\n\n**注： $\\bf{mex}$ 指集合中没有出现过的最小的自然数。**", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示测试数据组数。\n\n对于每组测试数据，输入包含一行两个正整数 $n,k$。", "outputFormat": "对于每组测试数据，输出一行一个整数表示答案。", "hint": "**【补充说明】**\n\n为了更好的让选手理解题面，给出若干合法/不合法集合例子：\n\n+ $\\{0,1,2,2\\}$。\n\n该集合是一个符合要求的集合，因为 $0\\times 1\\times 2\\times 2=0=\\min\\{0,1,2,2\\}$，$0+1+2+2=5,\\min\\{0,1,2,2\\}+\\max\\{0,1,2,2\\}+\\operatorname{mex}\\{0,1,2,2\\}=0+2+3=5$。\n\n+ $\\{3,5\\}$\n\n该集合不是一个符合要求的集合，因为虽然 $3+5=8,\\min\\{3,5\\}+\\max\\{3,5\\}+\\operatorname{mex}\\{3,5\\}=3+5+0=8$，但是 $3\\times 5\\not=\\min\\{3,5\\}$。\n\n+ $\\{1,9,1,9,8,1,0\\}$。\n\n该集合不是一个符合要求的集合，因为虽然 $1\\times 9\\times 1\\times 9\\times 8\\times 1\\times 0=0=\\min\\{1,9,1,9,8,1,0\\}$，但是其和为 $29$ 而并非 $\\min+\\max+\\operatorname{mex}=0+9+2=11$。\n\n**【数据范围】**  \n\n对于 $100\\%$ 的数据，保证 $1\\le T\\le10^6$，$1\\le n,k\\le10^{18}$。\n\n|测试点编号|分值|$T\\le$|$k\\le$|$n$|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$10$|$5$|$5$|$\\le5$|\n|$2$|$10$|$10^5$|$10^{18}$|$=1$|\n|$3$|$10$|$10^5$|$10^{18}$|$=2$|\n|$4$|$10$|$10^5$|$10^{18}$|$=3$|\n|$5$|$10$|$10^5$|$10^{18}$|$=4$|\n|$6$|$10$|$10^5$|$10^{18}$|$=5$|\n|$7$|$10$|$10^5$|$10$|$\\le10$|\n|$8$|$10$|$10^5$|$10^3$|$\\le10^3$|\n|$9$|$10$|$10^6$|$10^{18}$|$\\le10^{8}$|\n|$10$|$10$|$10^6$|$10^{18}$|$\\le10^{18}$|", "locale": "zh-CN"}}}
{"pid": "P9035", "type": "P", "difficulty": 5, "samples": [["5\n2 2\n1 3\n4 5\n4030 218\n1145 1419\n", "2\n3\n20\n571656908\n172735629\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "洛谷原创", "O2优化", "组合数学", "洛谷月赛"], "title": "「KDOI-04」Pont des souvenirs", "background": "虽然这是一个 C，但是\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dzj8va56.png)", "description": "给定正整数 $n,k$，求有多少个长度为 $n$ 的正整数序列 $a$ 满足：\n\n* $0<a_1\\le a_2\\le a_3\\le\\cdots\\le a_n\\le k$；\n* $\\forall\\ i\\not=j$，$a_i+a_j\\le k+1$。\n\n答案对 $10^9+7$ 取模。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示测试数据组数。\n\n对于每组测试数据，输入包含一行两个正整数 $n,k$。", "outputFormat": "对于每组测试数据，输出一行一个整数表示答案。", "hint": "**【样例解释】**\n\n对于第 $1$ 组测试数据，所有满足要求的序列为 $(1,1)$ 和 $(1,2)$。\n\n对于第 $2$ 组测试数据，所有满足要求的序列为 $(1)$，$(2)$ 和 $(3)$。\n\n**【数据范围】**\n\n对于 $100\\%$ 的数据，保证 $1\\le T\\le2\\times10^5$，$1\\le n,k\\le10^7$。\n\n**本题开启捆绑测试。**\n\n|子任务编号|分值|$T\\le$|$n\\le$|$k$|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$8$|$5$|$5$|$\\le5$|\n|$2$|$3$|$10^5$|$10^7$|$=1$|\n|$3$|$3$|$10^5$|$10^7$|$=2$|\n|$4$|$8$|$10^5$|$10^7$|$=3$|\n|$5$|$16$|$10$|$200$|$\\le200$|\n|$6$|$16$|$10$|$3000$|$\\le3000$|\n|$7$|$8$|$10^4$|$10^7$|$\\le5$|\n|$8$|$8$|$100$|$10^7$|$\\le10^5$|\n|$9$|$30$|$2\\times10^5$|$10^7$|$\\le10^7$|\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KDOI-04」Pont des souvenirs", "background": "虽然这是一个 C，但是\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dzj8va56.png)", "description": "给定正整数 $n,k$，求有多少个长度为 $n$ 的正整数序列 $a$ 满足：\n\n* $0<a_1\\le a_2\\le a_3\\le\\cdots\\le a_n\\le k$；\n* $\\forall\\ i\\not=j$，$a_i+a_j\\le k+1$。\n\n答案对 $10^9+7$ 取模。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示测试数据组数。\n\n对于每组测试数据，输入包含一行两个正整数 $n,k$。", "outputFormat": "对于每组测试数据，输出一行一个整数表示答案。", "hint": "**【样例解释】**\n\n对于第 $1$ 组测试数据，所有满足要求的序列为 $(1,1)$ 和 $(1,2)$。\n\n对于第 $2$ 组测试数据，所有满足要求的序列为 $(1)$，$(2)$ 和 $(3)$。\n\n**【数据范围】**\n\n对于 $100\\%$ 的数据，保证 $1\\le T\\le2\\times10^5$，$1\\le n,k\\le10^7$。\n\n**本题开启捆绑测试。**\n\n|子任务编号|分值|$T\\le$|$n\\le$|$k$|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$8$|$5$|$5$|$\\le5$|\n|$2$|$3$|$10^5$|$10^7$|$=1$|\n|$3$|$3$|$10^5$|$10^7$|$=2$|\n|$4$|$8$|$10^5$|$10^7$|$=3$|\n|$5$|$16$|$10$|$200$|$\\le200$|\n|$6$|$16$|$10$|$3000$|$\\le3000$|\n|$7$|$8$|$10^4$|$10^7$|$\\le5$|\n|$8$|$8$|$100$|$10^7$|$\\le10^5$|\n|$9$|$30$|$2\\times10^5$|$10^7$|$\\le10^7$|\n", "locale": "zh-CN"}}}
{"pid": "P9036", "type": "P", "difficulty": 6, "samples": [["3\n4 6 1\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n4 6 3\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n8 13 5\n1 2\n7 8\n1 3 \n2 5\n3 8\n6 8\n4 7\n5 6\n5 7\n5 8\n6 7\n1 8\n3 5", "0\n4\n8"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "图论", "贪心", "2023", "洛谷原创", "O2优化", "枚举", "深度优先搜索 DFS", "剪枝", "组合数学", "洛谷月赛", "状压 DP"], "title": "「KDOI-04」挑战 NPC Ⅲ", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/zn5t5x28.png)", "description": "小 S 有一个伟大的梦想：证明 $\\text{P}=\\text{NP}$。\n\n有一天，他得知一般图最大独立集是 NPC 问题后，决定解决他。\n\n当然小 S 太菜了，解决不了，于是求助于你：\n\n> 给出一个含有 $n$ 个顶点，$m$ 条边的无向图 $G$，求 $G$ 中大小恰好为 $n-k$ 的独立集的数量。由于答案可能很大，请将其对 $998~244~353$ 取模。\n\n小 S 不喜欢多测，因为他在 NOIp 中因为多测挂分，所以本题包含多组测试数据。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行一个正整数 $T$，表示测试数据组数。\n\n对于每组测试数据，第一行三个正整数 $n,m,k$。\n\n接下来 $m$ 行，每行两个正整数 $u,v$ 表示一条边。\n\n保证图中不存在自环，但**可能存在重边**。", "outputFormat": "对于每组测试数据，输出一行一个正整数，表示符合要求的独立集数量。答案对 $998~244~353$ 取模。", "hint": "**【样例解释】**\n\n对于第 $1,2$ 组测试数据，图是完全图，容易发现，完全图的最大独立集为 $1$，并且每一个顶点都单独构成一个独立集。因此第 $1$ 组测试数据的答案为 $0$，第 $2$ 组测试数据的答案为 $4$。\n\n对于第 $3$ 组测试数据，该组数据中给出的无向图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/abt8ho3b.png)\n\n其中，所有大小为 $3$ 的独立集为：\n\n+ $\\{2,4,8\\}$；\n+ $\\{2,3,7\\}$；\n+ $\\{3,4,6\\}$；\n+ $\\{2,4,6\\}$；\n+ $\\{1,4,6\\}$；\n+ $\\{2,3,6\\}$；\n+ $\\{1,4,5\\}$；\n+ $\\{2,3,4\\}$。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n![数据范围](https://cdn.luogu.com.cn/upload/image_hosting/p3jwdqp3.png)\n\n对于 $100\\%$ 的数据，保证 $1\\leq n\\leq10^5$，$0\\le m\\le 10^5$，$0\\leq k\\leq \\min(n-1,18)$，$1\\leq T\\leq 10^{4}$，$\\sum n,\\sum m\\leq10^6$。\n\n并且对于每个测试点保证：\n\n设 $K=\\max k$，即该测试点中所有 $k$ 的最大值，\n\n+ 若 $K\\ge 17$，则 $T=1$；\n+ 若 $K\\ge 15$，则 $T\\le 3$；\n+ 若 $K\\ge 10$，则 $T\\le 5$；\n+ 若 $K\\ge 5$，则 $T\\le 300$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KDOI-04」挑战 NPC Ⅲ", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/zn5t5x28.png)", "description": "小 S 有一个伟大的梦想：证明 $\\text{P}=\\text{NP}$。\n\n有一天，他得知一般图最大独立集是 NPC 问题后，决定解决他。\n\n当然小 S 太菜了，解决不了，于是求助于你：\n\n> 给出一个含有 $n$ 个顶点，$m$ 条边的无向图 $G$，求 $G$ 中大小恰好为 $n-k$ 的独立集的数量。由于答案可能很大，请将其对 $998~244~353$ 取模。\n\n小 S 不喜欢多测，因为他在 NOIp 中因为多测挂分，所以本题包含多组测试数据。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行一个正整数 $T$，表示测试数据组数。\n\n对于每组测试数据，第一行三个正整数 $n,m,k$。\n\n接下来 $m$ 行，每行两个正整数 $u,v$ 表示一条边。\n\n保证图中不存在自环，但**可能存在重边**。", "outputFormat": "对于每组测试数据，输出一行一个正整数，表示符合要求的独立集数量。答案对 $998~244~353$ 取模。", "hint": "**【样例解释】**\n\n对于第 $1,2$ 组测试数据，图是完全图，容易发现，完全图的最大独立集为 $1$，并且每一个顶点都单独构成一个独立集。因此第 $1$ 组测试数据的答案为 $0$，第 $2$ 组测试数据的答案为 $4$。\n\n对于第 $3$ 组测试数据，该组数据中给出的无向图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/abt8ho3b.png)\n\n其中，所有大小为 $3$ 的独立集为：\n\n+ $\\{2,4,8\\}$；\n+ $\\{2,3,7\\}$；\n+ $\\{3,4,6\\}$；\n+ $\\{2,4,6\\}$；\n+ $\\{1,4,6\\}$；\n+ $\\{2,3,6\\}$；\n+ $\\{1,4,5\\}$；\n+ $\\{2,3,4\\}$。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n![数据范围](https://cdn.luogu.com.cn/upload/image_hosting/p3jwdqp3.png)\n\n对于 $100\\%$ 的数据，保证 $1\\leq n\\leq10^5$，$0\\le m\\le 10^5$，$0\\leq k\\leq \\min(n-1,18)$，$1\\leq T\\leq 10^{4}$，$\\sum n,\\sum m\\leq10^6$。\n\n并且对于每个测试点保证：\n\n设 $K=\\max k$，即该测试点中所有 $k$ 的最大值，\n\n+ 若 $K\\ge 17$，则 $T=1$；\n+ 若 $K\\ge 15$，则 $T\\le 3$；\n+ 若 $K\\ge 10$，则 $T\\le 5$；\n+ 若 $K\\ge 5$，则 $T\\le 300$。\n", "locale": "zh-CN"}}}
{"pid": "P9037", "type": "P", "difficulty": 7, "samples": [["5 60 15 10 9\n.#...\n..#.#\n###..", "0.644444444444444"], ["6 140 120 115 110\n.##...\n......\n#.#.#.", "0.166666666666667"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "Special Judge", "PA（波兰）"], "title": "[PA 2021] Autostrada", "background": "", "description": "特工 Karol 正在一条三车道的高速公路上驾驶他的红色汽车。在他前面有一些车，并且他们都在以一个取决于车道的固定速度向前行驶：第 $i$ 条车道的速度为 $v_i$ 且 $v_1 > v_2 > v_3$。其他车都不会变换车道和速度，但是 Karol 可以迅速变换车道，也可以迅速改变自己的车速到不超过 $v_0$ 的任意实数速度。他不能掉头，所以他的车的时速在区间 $[0, v_0]$ 中。\n\n包括 Karol 在内，每辆车的长度都是 $1$。车之间可能会互相碰撞，但是 Karol 不能让这些车相撞。即：有正数长度的相交区间。形式化地，定义一辆车的位置为车头与高速路起点（即，Karol 的车刚开始的位置）之间的距离。相同车道的两辆车的位置差不能小于 $1$。\n\n入口处有一段长为 $L$ 的公路，Karol 目前在第三车道的起点处。高速路无限延伸，并且在描述路段之外高速路上没有车。\n\n请计算 Karol 最快多久后能超过所有车。换句话说，计算所有其他的车在最少多长时间后可以完全落后于 Karol 的车尾。\n\n**注意：Karol 可能会在非整数时间内改变他的车道和速度，汽车的位置也可能是非整数的。**", "inputFormat": "第一行，五个整数 $L, v_0, v_1, v_2, v_3$；\n\n接下来三行，其中第 $i$ 行有一个长为 $L$ 的字符串 $s_i$，描述第 $i$ 条车道，如果字符串 $s_i$ 的第 $j$ 个字符为 `#`，则表示那个位置有一辆车；如果为 `.`，则表示那个位置没有车。保证 $s_1$ 和 $s_2$ 的第一个字符都是 `.`，$s_3$ 的第一个字符为 `#`，表示 Karol 的车。输入中至少有两个 `#`。", "outputFormat": "一行，一个实数，表示 Karol 超过所有车所用的最短时间。\n\n与标准答案的绝对误差或相对误差在 $10^{-9}$ 之内的输出均可被接受。也就是说，你的答案为 $x$，如果标准答案是 $x_0$，若 $\\frac{|x - x_0|}{\\max(x_0, 1)} \\leq 10^{-9}$ 则你的输出就会被判为正确。", "hint": "对于 $100\\%$ 的数据，$2 \\leq L \\leq 2 \\times 10^5$，$1 \\leq v_3 < v_2 < v_1 < v_0 \\leq 140$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Autostrada", "background": "", "description": "特工 Karol 正在一条三车道的高速公路上驾驶他的红色汽车。在他前面有一些车，并且他们都在以一个取决于车道的固定速度向前行驶：第 $i$ 条车道的速度为 $v_i$ 且 $v_1 > v_2 > v_3$。其他车都不会变换车道和速度，但是 Karol 可以迅速变换车道，也可以迅速改变自己的车速到不超过 $v_0$ 的任意实数速度。他不能掉头，所以他的车的时速在区间 $[0, v_0]$ 中。\n\n包括 Karol 在内，每辆车的长度都是 $1$。车之间可能会互相碰撞，但是 Karol 不能让这些车相撞。即：有正数长度的相交区间。形式化地，定义一辆车的位置为车头与高速路起点（即，Karol 的车刚开始的位置）之间的距离。相同车道的两辆车的位置差不能小于 $1$。\n\n入口处有一段长为 $L$ 的公路，Karol 目前在第三车道的起点处。高速路无限延伸，并且在描述路段之外高速路上没有车。\n\n请计算 Karol 最快多久后能超过所有车。换句话说，计算所有其他的车在最少多长时间后可以完全落后于 Karol 的车尾。\n\n**注意：Karol 可能会在非整数时间内改变他的车道和速度，汽车的位置也可能是非整数的。**", "inputFormat": "第一行，五个整数 $L, v_0, v_1, v_2, v_3$；\n\n接下来三行，其中第 $i$ 行有一个长为 $L$ 的字符串 $s_i$，描述第 $i$ 条车道，如果字符串 $s_i$ 的第 $j$ 个字符为 `#`，则表示那个位置有一辆车；如果为 `.`，则表示那个位置没有车。保证 $s_1$ 和 $s_2$ 的第一个字符都是 `.`，$s_3$ 的第一个字符为 `#`，表示 Karol 的车。输入中至少有两个 `#`。", "outputFormat": "一行，一个实数，表示 Karol 超过所有车所用的最短时间。\n\n与标准答案的绝对误差或相对误差在 $10^{-9}$ 之内的输出均可被接受。也就是说，你的答案为 $x$，如果标准答案是 $x_0$，若 $\\frac{|x - x_0|}{\\max(x_0, 1)} \\leq 10^{-9}$ 则你的输出就会被判为正确。", "hint": "对于 $100\\%$ 的数据，$2 \\leq L \\leq 2 \\times 10^5$，$1 \\leq v_3 < v_2 < v_1 < v_0 \\leq 140$。", "locale": "zh-CN"}}}
{"pid": "P9038", "type": "P", "difficulty": 4, "samples": [["2 7 9\n1 3 6", "1 0 1 0 1 1 0 1 2 1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "PA（波兰）"], "title": "[PA 2021] Butelki", "background": "", "description": "Byteasar 有三瓶橙汁。他现在想通过把橙汁从一个瓶子倒入另一个瓶子的方式，让其中一个瓶子恰好装有 $k$ 升橙汁。因为他家里没有量筒，所以唯一允许的操作是在两个瓶子之间转移橙汁——要么把一个瓶子倒空，要么把一个瓶子倒满。橙汁不能撒到地上，也不能在这三个瓶子之外添加橙汁。\n\nByteasar 现在想知道，对于每一个 $k$，最少需要转移多少次橙汁才能让三个瓶子中的一个装有恰好 $k$ 升橙汁。他希望你帮帮他。", "inputFormat": "第一行，三个整数 $A, B, C$，表示第一、二、三个瓶子的容积；\n\n第二行，三个整数 $a, b, c$，表示第一、二、三个瓶子中最初装的橙汁体积。", "outputFormat": "一行，$C + 1$ 个整数，其中第 $i$ 个整数在存在一种操作方式使得让三个瓶子中的一个装有 $i - 1$ 升橙汁时为最小操作次数，否则为 $-1$。", "hint": "对于 $100\\%$ 的数据，$1 \\leq A \\leq B \\leq C \\leq 10^5$，$0 \\leq a \\leq A$，$0 \\leq b \\leq B$，$0 \\leq c \\leq C$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Butelki", "background": "", "description": "Byteasar 有三瓶橙汁。他现在想通过把橙汁从一个瓶子倒入另一个瓶子的方式，让其中一个瓶子恰好装有 $k$ 升橙汁。因为他家里没有量筒，所以唯一允许的操作是在两个瓶子之间转移橙汁——要么把一个瓶子倒空，要么把一个瓶子倒满。橙汁不能撒到地上，也不能在这三个瓶子之外添加橙汁。\n\nByteasar 现在想知道，对于每一个 $k$，最少需要转移多少次橙汁才能让三个瓶子中的一个装有恰好 $k$ 升橙汁。他希望你帮帮他。", "inputFormat": "第一行，三个整数 $A, B, C$，表示第一、二、三个瓶子的容积；\n\n第二行，三个整数 $a, b, c$，表示第一、二、三个瓶子中最初装的橙汁体积。", "outputFormat": "一行，$C + 1$ 个整数，其中第 $i$ 个整数在存在一种操作方式使得让三个瓶子中的一个装有 $i - 1$ 升橙汁时为最小操作次数，否则为 $-1$。", "hint": "对于 $100\\%$ 的数据，$1 \\leq A \\leq B \\leq C \\leq 10^5$，$0 \\leq a \\leq A$，$0 \\leq b \\leq B$，$0 \\leq c \\leq C$。", "locale": "zh-CN"}}}
{"pid": "P9039", "type": "P", "difficulty": 6, "samples": [["3\n4\n1011\n1100\n1 2\n2 3\n2 4\n2\n10\n10\n1 2\n2\n10\n01\n1 2", "TAK\nTAK\nNIE"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "PA（波兰）"], "title": "[PA 2021] Drzewo czerwono-czarne", "background": "", "description": "你熟悉红黑树这种数据结构吗？在本题我们将考虑一种节点颜色为红色或黑色的树，但请放心，如果你听说过刚才提到的数据结构的话，最好迅速忘掉它。\n\n给定一棵树（即，一个无环的无向连通图），每个节点被涂成红或黑两种颜色之一。你可以选择被一条边相连的两个节点 $v$ 和 $u$，并把 $v$ 重新涂成和 $u$ 一样的颜色。\n\n你的任务是确定经过一系列操作（**有可能不进行任何操作**）之后，一种最初的涂色情况能否变为最终给定的涂色情况。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行，一个整数 $n$，表示树的节点数；\n\n第二行，$n$ 个字符，每个字符是 $0$ 或 $1$，如果第 $i$ 个字符是 $0$，则初始时第 $i$ 个节点被涂成红色。如果第 $i$ 个字符是 $1$，则初始时第 $i$ 个节点被涂成黑色；\n\n第三行，$n$ 个字符，每个字符是 $0$ 或 $1$，如果第 $i$ 个字符是 $0$，则最后第 $i$ 个节点必须被涂成红色。如果第 $i$ 个字符是 $1$，则最后第 $i$ 个节点必须被涂成黑色；\n\n接下来 $n - 1$ 行，其中第 $i$ 行有两个整数 $a_i, b_i$，表示树上的一条边；", "outputFormat": "对于每组数据：\n\n一行，一个字符串。如果存在一个操作序列能使涂色情况变为最终给定的情况，输出 `TAK`，否则输出 `NIE`。", "hint": "对于 $100\\%$ 的数据，$1 \\leq T, n \\leq 10^5$，$1 \\leq \\sum n \\leq 10^6$，$1 \\leq a_i, b_i \\leq n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Drzewo czerwono-czarne", "background": "", "description": "你熟悉红黑树这种数据结构吗？在本题我们将考虑一种节点颜色为红色或黑色的树，但请放心，如果你听说过刚才提到的数据结构的话，最好迅速忘掉它。\n\n给定一棵树（即，一个无环的无向连通图），每个节点被涂成红或黑两种颜色之一。你可以选择被一条边相连的两个节点 $v$ 和 $u$，并把 $v$ 重新涂成和 $u$ 一样的颜色。\n\n你的任务是确定经过一系列操作（**有可能不进行任何操作**）之后，一种最初的涂色情况能否变为最终给定的涂色情况。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行，一个整数 $n$，表示树的节点数；\n\n第二行，$n$ 个字符，每个字符是 $0$ 或 $1$，如果第 $i$ 个字符是 $0$，则初始时第 $i$ 个节点被涂成红色。如果第 $i$ 个字符是 $1$，则初始时第 $i$ 个节点被涂成黑色；\n\n第三行，$n$ 个字符，每个字符是 $0$ 或 $1$，如果第 $i$ 个字符是 $0$，则最后第 $i$ 个节点必须被涂成红色。如果第 $i$ 个字符是 $1$，则最后第 $i$ 个节点必须被涂成黑色；\n\n接下来 $n - 1$ 行，其中第 $i$ 行有两个整数 $a_i, b_i$，表示树上的一条边；", "outputFormat": "对于每组数据：\n\n一行，一个字符串。如果存在一个操作序列能使涂色情况变为最终给定的情况，输出 `TAK`，否则输出 `NIE`。", "hint": "对于 $100\\%$ 的数据，$1 \\leq T, n \\leq 10^5$，$1 \\leq \\sum n \\leq 10^6$，$1 \\leq a_i, b_i \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P9040", "type": "P", "difficulty": 7, "samples": [["8 3 7\n3 -1 10 0 10 -1 1 -1\n1 8\n3 5\n6 8\n1 2\n1 7\n2 8\n1 6", "22\n20\n0\n0\n22\n20\n21"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "分治", "动态规划优化", "PA（波兰）"], "title": "[PA 2021] Desant 2", "background": "", "description": "Byteotia 准备再次袭击 Bitotia！在敌人的领土上登陆是一个真正硬汉的任务，因此，Byteotia 最好的特种部队的士兵——Byteburg——将参与其中。\n\nBytchak 将军让 $n$ 名士兵集合。他们立即排成一排，并从左到右依次用 $1$ 到 $n$ 的整数编号。将军希望选择一定数量的部队重新部署到 Bitotia 境内。作为一个熟练的战略家，他知道他的部下排队顺序不是随意的，而是与他们之间的友好关系有关，所以他选择的每支部队必须恰好由 $k$ 个连续的士兵组成。通过这种方式，他可以确保组成小队的士兵能够很好地合作。当然，每个士兵最多属于一个小队，将军对小队的数量没有偏好——特别是，他可以不选择任何小队而放弃对 Bitotia 的攻击（至少暂时如此）。\n\nBytchak 将军知道每一个士兵的技能——他可以用一个整数 $a_i$ 来描述他们每个人。技能值越高，这个士兵在战斗中的效率就越高。这个值也可以是负数，意味着这个士兵可能只会阻碍行动。\n\n将军希望将所有将被派去登陆的士兵的 $a_i$ 值之和最大化。然而，有一个问题。可能他要派一定数量的排头兵去与 Intotia 作战的前线，而派一定数量的排尾兵在 Longlongotia 进行情报行动。那么他将不得不只从位置号在 $[l_i, r_i]$ 范围内的士兵中选择部队。\n\n请你帮助将军考虑不同的情况，并为每一种情况计算派去登陆的士兵的最大可能的 $a_i$ 值之和。", "inputFormat": "第一行，三个整数 $n, k, q$，分别表示士兵总数、每支队伍中士兵人数和将军考虑的情况数；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$，表示每个士兵的技能值；\n\n接下来 $q$ 行，其中第 $i$ 行有两个整数 $l_i, r_i$，表示第 $i$ 种情况，即只有编号在 $[l_i, r_i]$ 范围内的士兵参与对 Bitotia 的作战。", "outputFormat": "$q$ 行，其中第 $i$ 行一个整数，表示在第 $i$ 种情况下参与作战的士兵最大的技能值之和。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n, q \\leq 3 \\times 10^5$，$1 \\leq k \\leq n$，$-10^9 \\leq a_i \\leq 10^9$，$1 \\leq l_i \\leq r_i \\leq n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Desant 2", "background": "", "description": "Byteotia 准备再次袭击 Bitotia！在敌人的领土上登陆是一个真正硬汉的任务，因此，Byteotia 最好的特种部队的士兵——Byteburg——将参与其中。\n\nBytchak 将军让 $n$ 名士兵集合。他们立即排成一排，并从左到右依次用 $1$ 到 $n$ 的整数编号。将军希望选择一定数量的部队重新部署到 Bitotia 境内。作为一个熟练的战略家，他知道他的部下排队顺序不是随意的，而是与他们之间的友好关系有关，所以他选择的每支部队必须恰好由 $k$ 个连续的士兵组成。通过这种方式，他可以确保组成小队的士兵能够很好地合作。当然，每个士兵最多属于一个小队，将军对小队的数量没有偏好——特别是，他可以不选择任何小队而放弃对 Bitotia 的攻击（至少暂时如此）。\n\nBytchak 将军知道每一个士兵的技能——他可以用一个整数 $a_i$ 来描述他们每个人。技能值越高，这个士兵在战斗中的效率就越高。这个值也可以是负数，意味着这个士兵可能只会阻碍行动。\n\n将军希望将所有将被派去登陆的士兵的 $a_i$ 值之和最大化。然而，有一个问题。可能他要派一定数量的排头兵去与 Intotia 作战的前线，而派一定数量的排尾兵在 Longlongotia 进行情报行动。那么他将不得不只从位置号在 $[l_i, r_i]$ 范围内的士兵中选择部队。\n\n请你帮助将军考虑不同的情况，并为每一种情况计算派去登陆的士兵的最大可能的 $a_i$ 值之和。", "inputFormat": "第一行，三个整数 $n, k, q$，分别表示士兵总数、每支队伍中士兵人数和将军考虑的情况数；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$，表示每个士兵的技能值；\n\n接下来 $q$ 行，其中第 $i$ 行有两个整数 $l_i, r_i$，表示第 $i$ 种情况，即只有编号在 $[l_i, r_i]$ 范围内的士兵参与对 Bitotia 的作战。", "outputFormat": "$q$ 行，其中第 $i$ 行一个整数，表示在第 $i$ 种情况下参与作战的士兵最大的技能值之和。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n, q \\leq 3 \\times 10^5$，$1 \\leq k \\leq n$，$-10^9 \\leq a_i \\leq 10^9$，$1 \\leq l_i \\leq r_i \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P9041", "type": "P", "difficulty": 7, "samples": [["9 10 2\n1 3\n1 5\n2 5\n5 4\n5 6\n2 6\n2 9\n2 8\n1 5\n1 9", "1\n9\n18"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "LGV 引理", "线性基", "PA（波兰）"], "title": "[PA 2021] Fiolki 2", "background": "", "description": "Byteasar 是一名化学家。你可能还记得，许多年前他因一项实验而闻名，该实验产生了一种特定的物质 X。由于上述物质根本没有解决人类的所有问题，这次他没有试图生产这种物质或找寻任何其他具体的解决方案——他只是在进行实验和评估其结果。\n\nByteasar 的实验室里有 $n$ 个样品瓶，用 $1$ 到 $n$ 的整数编号，这些样品瓶用 $m$ 根导管连接，物质可以从导管中流过。所有的样品瓶都处于两两不同的高度，液体只能通过导管往低处流。每根导管都有两端——第 $i$ 根导管的一端与编号为 $a_i$ 的样品瓶相连，另一端与编号为 $b_i$ 的样品瓶相连，我们知道编号 $a_i$ 的样品瓶比 $b_i$ 的样品瓶高。此外，每根导管都被一个导管夹夹住，以阻止物质的流动。Byteasar 可以在任何时候选择任何导管夹并打开它，让物质从样品瓶 $a_i$ 自由地流向样品瓶 $b_i$，在所有物质从一个样品瓶流向另一个样品瓶后，再夹住它。由于导管夹是机械式卡箍，保持其打开需要用力，因此在任何时候都只能打开一个导管夹。\n\n编号为 $1$ 至 $k$ 的样品瓶含有危险化学品。这些样品瓶中的每一个都包含一种不同的物质。编号大于 $k$ 的样品瓶最初都是空的。\n\n化学品是非常危险的，在任何情况下都不允许不同的物质混合在一起——这种混合的后果可能是灾难性的。由于流动的物质会留下微小的沉淀物，所以甚至不能让一种物质倒入以前装有任何其他物质的样品瓶中。\n\nByteasar 唯一能做的就是在样品瓶之间移动这些物质，确保没有两个物质混合。这并不是毫无意义的——通过以安全的方式运输物质，他可以把这些物质移到其他样品瓶中，这样更方便他研究它们的特性。\n\nByteasar 现在想选择一个区间 $[l, r]$，满足 $k < l \\leq r \\leq n$，然后他会将尽可能多的物质转移到该区间的任何编号的样品瓶中并继续测试那些方便放置的化学品。由于他不能决定哪个区间对他来说是最方便的，对于每个可能的区间 $[l, r]$，他想知道他能最多将多少种不同的物质转移到编号在区间 $[l, r]$ 的样品瓶中。我们用 $f(l, r)$ 来表示这个值。\n\n请你帮 Byteasar 写一个程序，根据他的描述，计算对于区间 $[0, k]$ 中的每个 $x$，有多少个区间 $[l, r]$ 满足 $f(l,r) = x$。", "inputFormat": "第一行，三个整数 $n, m, k$，表示样品瓶的数量、连接样品瓶的导管数量和最初装有 Byteasar 正在测试的物质的样品瓶数量。\n\n接下来 $m$ 行，每行两个整数 $a_i, b_i$，表示样品瓶 $a_i$ 和 $b_i$ 之间有导管，样品瓶 $a_i$ 中的物质可以转移到样品瓶 $b_i$ 中。\n\n我们保证对实验室的描述是合法的，即如果我们把样品瓶当作一个图的顶点，把导管当作这个图的有向边，那么输入就描述了一个**有向无环图**。\n\n请注意，输入中没有指出样品瓶所处的高度。然而，对于每一对由导管直接连接的样品瓶，可以知道哪一个样品瓶的位置更高。", "outputFormat": "$k + 1$ 行，其中第 $i$ 行包含一个整数，表示满足 $k < l \\leq r \\leq n$ 且 $f(l, r) = i - 1$ 的区间 $[l, r]$ 的数量。", "hint": "对于 $100\\%$ 的数据，$2 \\leq n \\leq 10^5$，$1 \\leq m \\leq 10^6$，$1 \\leq k \\leq \\min(n - 1, 50)$，$1 \\leq a_i \\leq n$，$k < b_i \\leq n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Fiolki 2", "background": "", "description": "Byteasar 是一名化学家。你可能还记得，许多年前他因一项实验而闻名，该实验产生了一种特定的物质 X。由于上述物质根本没有解决人类的所有问题，这次他没有试图生产这种物质或找寻任何其他具体的解决方案——他只是在进行实验和评估其结果。\n\nByteasar 的实验室里有 $n$ 个样品瓶，用 $1$ 到 $n$ 的整数编号，这些样品瓶用 $m$ 根导管连接，物质可以从导管中流过。所有的样品瓶都处于两两不同的高度，液体只能通过导管往低处流。每根导管都有两端——第 $i$ 根导管的一端与编号为 $a_i$ 的样品瓶相连，另一端与编号为 $b_i$ 的样品瓶相连，我们知道编号 $a_i$ 的样品瓶比 $b_i$ 的样品瓶高。此外，每根导管都被一个导管夹夹住，以阻止物质的流动。Byteasar 可以在任何时候选择任何导管夹并打开它，让物质从样品瓶 $a_i$ 自由地流向样品瓶 $b_i$，在所有物质从一个样品瓶流向另一个样品瓶后，再夹住它。由于导管夹是机械式卡箍，保持其打开需要用力，因此在任何时候都只能打开一个导管夹。\n\n编号为 $1$ 至 $k$ 的样品瓶含有危险化学品。这些样品瓶中的每一个都包含一种不同的物质。编号大于 $k$ 的样品瓶最初都是空的。\n\n化学品是非常危险的，在任何情况下都不允许不同的物质混合在一起——这种混合的后果可能是灾难性的。由于流动的物质会留下微小的沉淀物，所以甚至不能让一种物质倒入以前装有任何其他物质的样品瓶中。\n\nByteasar 唯一能做的就是在样品瓶之间移动这些物质，确保没有两个物质混合。这并不是毫无意义的——通过以安全的方式运输物质，他可以把这些物质移到其他样品瓶中，这样更方便他研究它们的特性。\n\nByteasar 现在想选择一个区间 $[l, r]$，满足 $k < l \\leq r \\leq n$，然后他会将尽可能多的物质转移到该区间的任何编号的样品瓶中并继续测试那些方便放置的化学品。由于他不能决定哪个区间对他来说是最方便的，对于每个可能的区间 $[l, r]$，他想知道他能最多将多少种不同的物质转移到编号在区间 $[l, r]$ 的样品瓶中。我们用 $f(l, r)$ 来表示这个值。\n\n请你帮 Byteasar 写一个程序，根据他的描述，计算对于区间 $[0, k]$ 中的每个 $x$，有多少个区间 $[l, r]$ 满足 $f(l,r) = x$。", "inputFormat": "第一行，三个整数 $n, m, k$，表示样品瓶的数量、连接样品瓶的导管数量和最初装有 Byteasar 正在测试的物质的样品瓶数量。\n\n接下来 $m$ 行，每行两个整数 $a_i, b_i$，表示样品瓶 $a_i$ 和 $b_i$ 之间有导管，样品瓶 $a_i$ 中的物质可以转移到样品瓶 $b_i$ 中。\n\n我们保证对实验室的描述是合法的，即如果我们把样品瓶当作一个图的顶点，把导管当作这个图的有向边，那么输入就描述了一个**有向无环图**。\n\n请注意，输入中没有指出样品瓶所处的高度。然而，对于每一对由导管直接连接的样品瓶，可以知道哪一个样品瓶的位置更高。", "outputFormat": "$k + 1$ 行，其中第 $i$ 行包含一个整数，表示满足 $k < l \\leq r \\leq n$ 且 $f(l, r) = i - 1$ 的区间 $[l, r]$ 的数量。", "hint": "对于 $100\\%$ 的数据，$2 \\leq n \\leq 10^5$，$1 \\leq m \\leq 10^6$，$1 \\leq k \\leq \\min(n - 1, 50)$，$1 \\leq a_i \\leq n$，$k < b_i \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P9042", "type": "P", "difficulty": 7, "samples": [["1 3 1", "9"], ["1 3 2", "149"]], "limits": {"time": [45000, 45000, 45000, 45000, 45000, 45000, 45000, 45000, 45000, 45000, 45000, 45000, 45000, 45000, 45000, 45000, 45000, 45000, 45000, 45000, 45000, 45000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "PA（波兰）"], "title": "[PA 2021] Zbiory niezależne", "background": "", "description": "树 $T = (V, E)$ 是一个无向连通且无环的简单图。在本题中，我们考虑 $c$ 色树，即树上每个节点有 $c$ 种颜色之一的树。\n\n两棵有色树 $T_1 = (V_1, E_1), T_2 = (V_2, E_2)$ 相等，当且仅当：\n\n- 存在双射 $\\pi : V_1 \\to V_2$，满足对于任意节点对 $(u, v) \\in V_1$，满足 $\\{u,v\\} \\in E_1$ 当且仅当 $\\{\\pi(u), \\pi(v)\\} \\in E_2$。\n- 对于任意节点 $v \\in V_1$，$T_1$ 中 $v$ 节点的颜色和 $T_2$ 中 $\\pi(v)$ 节点的颜色相同。\n\n我们称一棵树 $T = (V, E)$ 的一个独立集为任意节点的子集 $S \\subseteq V$，满足 $S$ 中没有两不同节点被一条边相连。独立集 $S$ 的大小等于属于 $S$ 集合的节点个数。\n\n给定三个整数 $l, r, c$，求问有多少不同的 $c$ 色树满足其最大独立集的大小在 $[l, r]$ 中？由于答案可能会非常大，所以请求出它对 $998244353$ 取模后的值。", "inputFormat": "一行，三个整数 $l, r, c$。", "outputFormat": "一行，一个整数，表示所求的值。", "hint": "对于 $100\\%$ 的数据，$1 \\leq l \\leq r \\leq 5 \\times 10^5$，$1 \\leq c \\leq 998244352$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Zbiory niezależne", "background": "", "description": "树 $T = (V, E)$ 是一个无向连通且无环的简单图。在本题中，我们考虑 $c$ 色树，即树上每个节点有 $c$ 种颜色之一的树。\n\n两棵有色树 $T_1 = (V_1, E_1), T_2 = (V_2, E_2)$ 相等，当且仅当：\n\n- 存在双射 $\\pi : V_1 \\to V_2$，满足对于任意节点对 $(u, v) \\in V_1$，满足 $\\{u,v\\} \\in E_1$ 当且仅当 $\\{\\pi(u), \\pi(v)\\} \\in E_2$。\n- 对于任意节点 $v \\in V_1$，$T_1$ 中 $v$ 节点的颜色和 $T_2$ 中 $\\pi(v)$ 节点的颜色相同。\n\n我们称一棵树 $T = (V, E)$ 的一个独立集为任意节点的子集 $S \\subseteq V$，满足 $S$ 中没有两不同节点被一条边相连。独立集 $S$ 的大小等于属于 $S$ 集合的节点个数。\n\n给定三个整数 $l, r, c$，求问有多少不同的 $c$ 色树满足其最大独立集的大小在 $[l, r]$ 中？由于答案可能会非常大，所以请求出它对 $998244353$ 取模后的值。", "inputFormat": "一行，三个整数 $l, r, c$。", "outputFormat": "一行，一个整数，表示所求的值。", "hint": "对于 $100\\%$ 的数据，$1 \\leq l \\leq r \\leq 5 \\times 10^5$，$1 \\leq c \\leq 998244352$。", "locale": "zh-CN"}}}
{"pid": "P9043", "type": "P", "difficulty": 4, "samples": [["aabbabcccba", "28"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "PA（波兰）"], "title": "[PA 2021] Zbalansowane słowa", "background": "", "description": "定义一个字符串 $s$ 是好的，当且仅当它包含的所有字符出现次数相同。\n\n好的字符串例如：`mama`、`aabbcbcccbaa`。\n\n不好的字符串例如：`ovo`。\n\n给定一个字符串 $s$，求出 $s$ 好的**子串**数量。", "inputFormat": "一行，一个字符串 $s$。", "outputFormat": "一行，一个整数，表示所求的值。", "hint": "对于 $100\\%$ 的数据，$1 \\leq |s| \\leq 3 \\times 10^5$，$s$ 中只含 `a`、`b`、`c` 三个小写字母。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Zbalansowane słowa", "background": "", "description": "定义一个字符串 $s$ 是好的，当且仅当它包含的所有字符出现次数相同。\n\n好的字符串例如：`mama`、`aabbcbcccbaa`。\n\n不好的字符串例如：`ovo`。\n\n给定一个字符串 $s$，求出 $s$ 好的**子串**数量。", "inputFormat": "一行，一个字符串 $s$。", "outputFormat": "一行，一个整数，表示所求的值。", "hint": "对于 $100\\%$ 的数据，$1 \\leq |s| \\leq 3 \\times 10^5$，$s$ 中只含 `a`、`b`、`c` 三个小写字母。", "locale": "zh-CN"}}}
{"pid": "P9044", "type": "P", "difficulty": 1, "samples": [["5 3\n75 90 120 75 40", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "贪心", "2021", "PA（波兰）"], "title": "[PA 2021] Koszulki", "background": "", "description": "$n$ 个人参加一场比赛，其中第 $i$ 个人的得分为 $a_i$。\n\n主办方决定至少颁发 $k$ 件礼物。\n\n但是，若 $\\exist 1 \\leq x, y \\leq n, a_x \\geq a_y$ 且 $x$ 未拿到礼物但 $y$ 拿到礼物，$x$ 会不满意。\n\n主办方希望每个人都满意，求颁发的礼物数量的最小值。", "inputFormat": "第一行，两个整数 $n, k$。\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$。", "outputFormat": "一行，一个整数，表示所求的值。", "hint": "#### 样例 #1 解释\n最优方案为除了最后一人以外全部送礼物。\n#### 数据范围\n对于 $100\\%$ 的数据，$1 \\leq k \\leq n \\leq 2 \\times 10^3$，$1 \\leq a_i \\leq 120$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Koszulki", "background": "", "description": "$n$ 个人参加一场比赛，其中第 $i$ 个人的得分为 $a_i$。\n\n主办方决定至少颁发 $k$ 件礼物。\n\n但是，若 $\\exist 1 \\leq x, y \\leq n, a_x \\geq a_y$ 且 $x$ 未拿到礼物但 $y$ 拿到礼物，$x$ 会不满意。\n\n主办方希望每个人都满意，求颁发的礼物数量的最小值。", "inputFormat": "第一行，两个整数 $n, k$。\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$。", "outputFormat": "一行，一个整数，表示所求的值。", "hint": "#### 样例 #1 解释\n最优方案为除了最后一人以外全部送礼物。\n#### 数据范围\n对于 $100\\%$ 的数据，$1 \\leq k \\leq n \\leq 2 \\times 10^3$，$1 \\leq a_i \\leq 120$。", "locale": "zh-CN"}}}
{"pid": "P9045", "type": "P", "difficulty": 1, "samples": [["5 3\n3 3 3 1 2", "4"], ["3 2\n1 1 1", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "贪心", "2021", "PA（波兰）"], "title": "[PA 2021] Oranżada", "background": "", "description": "有一排共 $n$ 瓶橙汁，其中第 $i$ 瓶的品牌为 $a_i$。\n\n你可以花费 $1$ 个单位的的代价交换两瓶相邻的橙汁。\n\n求最小代价使得最左边 $k$ 瓶橙汁品牌两两不同。", "inputFormat": "第一行，两个整数 $n, k$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$。", "outputFormat": "一行，一个整数，若有解，输出最小代价；否则，输出 $-1$。", "hint": "#### 样例 #1 解释\n最优方案为先交换位置 $3$ 和 $4$ 的瓶子、再交换位置 $4$ 和 $5$ 的瓶子，接着交换位置 $2$ 和 $3$ 的瓶子，最后交换位置 $3$ 和 $4$ 的瓶子，共 $4$ 次操作。\n#### 样例 #2 解释\n显然无解。\n#### 数据范围\n对于 $100\\%$ 的数据，$1 \\leq k, a_i \\leq n \\leq 5 \\times 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Oranżada", "background": "", "description": "有一排共 $n$ 瓶橙汁，其中第 $i$ 瓶的品牌为 $a_i$。\n\n你可以花费 $1$ 个单位的的代价交换两瓶相邻的橙汁。\n\n求最小代价使得最左边 $k$ 瓶橙汁品牌两两不同。", "inputFormat": "第一行，两个整数 $n, k$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$。", "outputFormat": "一行，一个整数，若有解，输出最小代价；否则，输出 $-1$。", "hint": "#### 样例 #1 解释\n最优方案为先交换位置 $3$ 和 $4$ 的瓶子、再交换位置 $4$ 和 $5$ 的瓶子，接着交换位置 $2$ 和 $3$ 的瓶子，最后交换位置 $3$ 和 $4$ 的瓶子，共 $4$ 次操作。\n#### 样例 #2 解释\n显然无解。\n#### 数据范围\n对于 $100\\%$ 的数据，$1 \\leq k, a_i \\leq n \\leq 5 \\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P9046", "type": "P", "difficulty": 3, "samples": [["3\n8\n00110100\n10\n1001000010\n4\n0000", "5\n7\n0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "PA（波兰）"], "title": "[PA 2021] Pandemia", "background": "", "description": "某国有 $n$ 座城市，其中 $\\forall 1 \\leq i < n$，城市 $i$ 与城市 $i + 1$ 有**双向**道路相连。\n\n该国发生了疫情，一个城市要么无人感染，要么全体感染。具体地，一个城市初始时被感染当且仅当 $s_i = 1$。\n\n疫情会扩散，每一天上午，你可以为一个未感染的城市的居民接种疫苗，下午，每个被感染的城市会向相邻的城市扩散，如果相邻的城市未接种疫苗，它将立即全员感染。\n\n你作为城市管理者，想要知道执行最优策略的情况下，最少会有几个城市的所有人都被感染。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行，一个整数 $n$；\n\n第二行，一个长度为 $n$ 的字符串 $s$。", "outputFormat": "对于每组数据：\n\n一行，一个整数，表示所求的值。", "hint": "#### 样例 #1 解释\n测试点一：第一天接种城市 $7$，第二天接种城市 $1$。\n\n测试点二：第一天接种城市 $5$，第二天接种城市 $7$。\n\n测试点三：初始不存在疫情，因此不需要接种。\n#### 数据范围\n对于 $100\\%$ 的数据，$1 \\leq n, T \\leq 10^5$，$1 \\leq \\sum n \\leq 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Pandemia", "background": "", "description": "某国有 $n$ 座城市，其中 $\\forall 1 \\leq i < n$，城市 $i$ 与城市 $i + 1$ 有**双向**道路相连。\n\n该国发生了疫情，一个城市要么无人感染，要么全体感染。具体地，一个城市初始时被感染当且仅当 $s_i = 1$。\n\n疫情会扩散，每一天上午，你可以为一个未感染的城市的居民接种疫苗，下午，每个被感染的城市会向相邻的城市扩散，如果相邻的城市未接种疫苗，它将立即全员感染。\n\n你作为城市管理者，想要知道执行最优策略的情况下，最少会有几个城市的所有人都被感染。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行，一个整数 $n$；\n\n第二行，一个长度为 $n$ 的字符串 $s$。", "outputFormat": "对于每组数据：\n\n一行，一个整数，表示所求的值。", "hint": "#### 样例 #1 解释\n测试点一：第一天接种城市 $7$，第二天接种城市 $1$。\n\n测试点二：第一天接种城市 $5$，第二天接种城市 $7$。\n\n测试点三：初始不存在疫情，因此不需要接种。\n#### 数据范围\n对于 $100\\%$ 的数据，$1 \\leq n, T \\leq 10^5$，$1 \\leq \\sum n \\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P9047", "type": "P", "difficulty": 6, "samples": [["19\n1 2 1\n2 3 2\n3 4 -1\n4 5 -1\n5 6 2\n6 7 11\n7 8 12\n8 9 13\n9 10 14\n11 12 3\n12 13 0\n13 14 0\n14 15 0\n15 16 1\n16 4 0\n4 17 0\n17 18 0\n18 19 2", "57"], ["6\n1 2 2\n2 3 -1\n3 4 -1\n4 5 -1\n5 6 2", "0"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2021", "分治", "剪枝", "背包 DP", "动态规划优化", "树形 DP", "凸完全单调性（wqs 二分）", "随机化", "PA（波兰）"], "title": "[PA 2021] Poborcy podatkowi", "background": null, "description": "给定一棵 $n$ 个点的树，你可以选择若干条长度为 $4$（指 $4$ 条边） 的不相交链（**可以不选**）。\n\n每个选链的方案的收益为所选链的并集的边权和，求最大收益。", "inputFormat": "第一行，一个整数 $n$；\n\n接下来 $n - 1$ 行，每行三个整数 $u, v, w$，表示树上的一条边 $(u, v)$，其边权为 $w$。", "outputFormat": "一行，一个整数，表示所求的值。", "hint": "#### 样例 #1 解释\n给出一种最优方案：选择链 $2 \\to 6$，$6 \\to 10$，$11 \\to 15$，$16 \\to 19$。\n#### 样例 #2 解释\n由于每一条长度为 $4$ 的链权值均为负数，所以不选最优。\n#### 数据范围\n对于 $100\\%$ 的数据，$2 \\leq n \\leq 2 \\times 10^5$，$-10^9 \\leq w_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Poborcy podatkowi", "background": null, "description": "给定一棵 $n$ 个点的树，你可以选择若干条长度为 $4$（指 $4$ 条边） 的不相交链（**可以不选**）。\n\n每个选链的方案的收益为所选链的并集的边权和，求最大收益。", "inputFormat": "第一行，一个整数 $n$；\n\n接下来 $n - 1$ 行，每行三个整数 $u, v, w$，表示树上的一条边 $(u, v)$，其边权为 $w$。", "outputFormat": "一行，一个整数，表示所求的值。", "hint": "#### 样例 #1 解释\n给出一种最优方案：选择链 $2 \\to 6$，$6 \\to 10$，$11 \\to 15$，$16 \\to 19$。\n#### 样例 #2 解释\n由于每一条长度为 $4$ 的链权值均为负数，所以不选最优。\n#### 数据范围\n对于 $100\\%$ 的数据，$2 \\leq n \\leq 2 \\times 10^5$，$-10^9 \\leq w_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P9048", "type": "P", "difficulty": 2, "samples": [["2\n1100000011110111", "ao"], ["8\n1011111010101100011011011010001010100011111111110001001001011010\n", "potyczki"], ["1\n00011000", "NIE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "贪心", "2021", "Special Judge", "构造", "PA（波兰）"], "title": "[PA 2021] Zakłócenia", "background": "", "description": "定义一种小写字母到 $8$ 位 01 串的映射：\n\n- 将小写字符的 ASCII 码转为 $8$ 位二进制数，如：$a \\rightarrow 97 \\rightarrow 01100001$。\n\n现在小 A 有一个长度为 $n$ 的只含小写字母的字符串 $s$，他将这个字符串映射到了一个长为 $8n$ 的 01 字符串 $t$。\n\n他打乱了 01 串 $t$ 得到 01 串 $t'$，请你根据打乱后的结果还原出一个 $s$。", "inputFormat": "第一行，一个整数 $n$；\n\n第二行，一个长为 $8n$ 的 01 串 $t'$。", "outputFormat": "如果有解，输出一行，一个长度为 $n$ 的只含小写字母的字符串 $s$；否则，输出 `NIE`。\n\n**如有多解，输出任意一组均可。**", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Zakłócenia", "background": "", "description": "定义一种小写字母到 $8$ 位 01 串的映射：\n\n- 将小写字符的 ASCII 码转为 $8$ 位二进制数，如：$a \\rightarrow 97 \\rightarrow 01100001$。\n\n现在小 A 有一个长度为 $n$ 的只含小写字母的字符串 $s$，他将这个字符串映射到了一个长为 $8n$ 的 01 字符串 $t$。\n\n他打乱了 01 串 $t$ 得到 01 串 $t'$，请你根据打乱后的结果还原出一个 $s$。", "inputFormat": "第一行，一个整数 $n$；\n\n第二行，一个长为 $8n$ 的 01 串 $t'$。", "outputFormat": "如果有解，输出一行，一个长度为 $n$ 的只含小写字母的字符串 $s$；否则，输出 `NIE`。\n\n**如有多解，输出任意一组均可。**", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P9049", "type": "P", "difficulty": 4, "samples": [["4\n1000000006 1 5 1000000004", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "PA（波兰）"], "title": "[PA 2021] Mopadulo", "background": "", "description": "给定一个长度为 $n$ 的序列 $a$，求有多少种方案可以将 $a$ 划分成若干个区间，使得每段区间所有数的和模 $10^9 + 7$ 的结果为偶数。\n\n由于结果可能很大，你只需要求出结果对 $10^9 + 7$ 取模的值。", "inputFormat": "第一行，一个整数 $n$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$。", "outputFormat": "一行，一个整数，表示所求的值。", "hint": "#### 样例 #1 解释\n三种划分方式如下：\n\n- $[1, 4]$\n- $[1, 2], [3, 4]$\n- $[1], [2, 3], [4]$\n#### 数据范围\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 3 \\times 10^5$，$0 \\leq a_i < 10^9 + 7$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Mopadulo", "background": "", "description": "给定一个长度为 $n$ 的序列 $a$，求有多少种方案可以将 $a$ 划分成若干个区间，使得每段区间所有数的和模 $10^9 + 7$ 的结果为偶数。\n\n由于结果可能很大，你只需要求出结果对 $10^9 + 7$ 取模的值。", "inputFormat": "第一行，一个整数 $n$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$。", "outputFormat": "一行，一个整数，表示所求的值。", "hint": "#### 样例 #1 解释\n三种划分方式如下：\n\n- $[1, 4]$\n- $[1, 2], [3, 4]$\n- $[1], [2, 3], [4]$\n#### 数据范围\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 3 \\times 10^5$，$0 \\leq a_i < 10^9 + 7$。", "locale": "zh-CN"}}}
{"pid": "P9050", "type": "P", "difficulty": 3, "samples": [["6\n2 7 1 8 2 8", "NTNTNT"], ["3\n5 4 4", "TNN"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "二分", "2021", "排序", "前缀和", "PA（波兰）"], "title": "[PA 2021] Sumy", "background": "", "description": "有 $n$ 条鱼，其中第 $i$ 条的质量为 $a_i$ 克。\n\n$x$ 能吃掉 $y$ 当且仅当 $a_x > a_y$。\n\n若 $x$ 吃了 $y$，$y$ 会消失，$a_x$ 会变为 $a_x + a_y$。\n\n你可以随意指定吃鱼的顺序，直至留下一条鱼为止。\n\n求每一条鱼是否可能被作为最后**唯一**的鱼留下。**若最终无法只剩下一条鱼，则每条鱼均不满足此条件。**", "inputFormat": "第一行，一个整数 $n$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$。", "outputFormat": "一行，一个长度为 $n$ 的字符串 $s$，其中 $s_i = \\text{T}$ 表示第 $i$ 条鱼满足上述条件，$s_i = \\text{N}$ 表示第 $i$ 条鱼不满足上述条件。", "hint": "#### 样例 #1 解释\n下面用 $x \\rightarrow y$ 表示 $x$ 吃 $y$。\n\n留下 $2$ 号鱼的一种方案如下：$2 \\rightarrow 1, 2 \\rightarrow 3, 2 \\rightarrow 4, 2 \\rightarrow 5, 2 \\rightarrow 6$。\n#### 数据范围\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^5$，$1 \\leq a_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Sumy", "background": "", "description": "有 $n$ 条鱼，其中第 $i$ 条的质量为 $a_i$ 克。\n\n$x$ 能吃掉 $y$ 当且仅当 $a_x > a_y$。\n\n若 $x$ 吃了 $y$，$y$ 会消失，$a_x$ 会变为 $a_x + a_y$。\n\n你可以随意指定吃鱼的顺序，直至留下一条鱼为止。\n\n求每一条鱼是否可能被作为最后**唯一**的鱼留下。**若最终无法只剩下一条鱼，则每条鱼均不满足此条件。**", "inputFormat": "第一行，一个整数 $n$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$。", "outputFormat": "一行，一个长度为 $n$ 的字符串 $s$，其中 $s_i = \\text{T}$ 表示第 $i$ 条鱼满足上述条件，$s_i = \\text{N}$ 表示第 $i$ 条鱼不满足上述条件。", "hint": "#### 样例 #1 解释\n下面用 $x \\rightarrow y$ 表示 $x$ 吃 $y$。\n\n留下 $2$ 号鱼的一种方案如下：$2 \\rightarrow 1, 2 \\rightarrow 3, 2 \\rightarrow 4, 2 \\rightarrow 5, 2 \\rightarrow 6$。\n#### 数据范围\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^5$，$1 \\leq a_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P9051", "type": "P", "difficulty": 6, "samples": [["6 2\n-1 7 0 2 -5 0\n3 1 4 -3 -3 12", "4\nBBABBA"], ["3 2\n-1 -4 -1\n-4 -2 -1", "0\nAAB"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "贪心", "二分", "平衡树", "2021", "Special Judge", "PA（波兰）"], "title": "[PA 2021] Wystawa", "background": "", "description": "给定长度为 $n$ 的序列 $a, b$。\n\n你需要构造一个序列 $c$，构造方法为：\n\n- 选择 $k$ 个 $i$，令 $c_i \\leftarrow a_i$。\n- 对于其他 $i$，令 $c_i \\leftarrow b_i$。\n\n求序列 $c$ 的最大子段和的最小值，并给出一种方案。", "inputFormat": "第一行，两个整数 $n, k$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$；\n\n第三行，$n$ 个整数 $b_1, b_2, \\cdots, b_n$。", "outputFormat": "第一行，一个整数，表示序列 $c$ 的最大子段和的最小值；\n\n第二行，一个长为 $n$ 的字符串 $s$，若令 $c_i \\leftarrow a_i$，$s_i = \\text{A}$；否则，$s_i = \\text{B}$。\n\n**如有多解，输出任意一组均可。**", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$，$0 \\leq k \\leq n$，$-10^9 \\leq a_i, b_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Wystawa", "background": "", "description": "给定长度为 $n$ 的序列 $a, b$。\n\n你需要构造一个序列 $c$，构造方法为：\n\n- 选择 $k$ 个 $i$，令 $c_i \\leftarrow a_i$。\n- 对于其他 $i$，令 $c_i \\leftarrow b_i$。\n\n求序列 $c$ 的最大子段和的最小值，并给出一种方案。", "inputFormat": "第一行，两个整数 $n, k$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$；\n\n第三行，$n$ 个整数 $b_1, b_2, \\cdots, b_n$。", "outputFormat": "第一行，一个整数，表示序列 $c$ 的最大子段和的最小值；\n\n第二行，一个长为 $n$ 的字符串 $s$，若令 $c_i \\leftarrow a_i$，$s_i = \\text{A}$；否则，$s_i = \\text{B}$。\n\n**如有多解，输出任意一组均可。**", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$，$0 \\leq k \\leq n$，$-10^9 \\leq a_i, b_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P9052", "type": "P", "difficulty": 7, "samples": [["9\n2 2 3\n1 1\n1 2\n1 5\n3 5 8 9\n1 5\n2 6 4\n2 5 9\n3 5 8 5", "0 1 4 4 5 6 7 7 7"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "PA（波兰）"], "title": "[PA 2021] Areny", "background": null, "description": "Bajtek 在圣诞节收到了父母送的最新电脑游戏 Byte Defence 4。他兴致勃勃地打开游戏开始玩。游戏里操控的角色叫 Bajtonator，需要通过打怪、完成任务和升级装备来变强。地图上有 $n$ 个特殊的竞技场，里面有很稀有的掉落品。但有 $n$ 种通行证，想进某个竞技场必须持有对应的通行证。\n\n这个游戏的规则如下：\n\n1. 如果你有某个竞技场的通行证，就可以进入该竞技场与怪物战斗。进入竞技场不会消耗通行证，怪物会在你离开后复活，所以同一张通行证可以反复使用，反复挑战同一竞技场。\n2. 每个竞技场都有一个事先公开、固定不变的通行证池，池里的通行证不会被移出或改变。击败竞技场里的怪物后，除了可能掉落稀有物品外，还会从该竞技场的通行证池里随机抽取一张通行证，复制一份交给你。所以你可能在多次胜利后拥有相同类型的多张通行证副本。\n\n看了攻略后，Bajtek 得知竞技场编号越大越难。他的实力可以用一个整数 $k$ 来表示：他一定能在编号小于等于 $k$ 的竞技场获胜，而对编号大于 $k$ 的竞技场他一定无法获胜。\n\n开始时他没有任何通行证，只能花钱买**一张**。买哪一张最划算呢？\n\n他认为，如果买了竞技场 $A$ 的通行证，凭借这个起始通行证和之后的战斗所得通行证，**无论如何**他最终都能进入竞技场 $B$ 并获胜，那这张通行证就是值得买的。\n\n所以他想知道，对于某个固定的 $k$，有多少有序竞技场对 $(A,B)$ 满足：\n\n1. $A\\neq B$。\n2. 如果只买了竞技场 $A$ 的通行证，凭借这个起始通行证和之后的战斗所得通行证，无论如何他最终都能进入竞技场 $B$ 并获胜。\n\n你需要对于 $k=1,2,\\cdots,n$ 计算这样的有序对 $(A,B)$ 的个数。", "inputFormat": "第一行，一个整数 $n\\;(2\\le n\\le 2\\cdot 10^5)$，表示竞技场的数量。\n\n接下来 $n$ 行，其中第 $i$ 行先是一个整数 $l_i\\;(1\\le l_i)$，表示第 $i$ 个竞技场的通行证池大小。随后给出 $l_i$ 个整数，表示该池中每种通行证能进入的竞技场编号。所有 $l_i$ 的总和不超过 $5\\cdot10^5$。", "outputFormat": "一行，$n$ 个整数，其中第 $i$ 个整数表示 $k = i$ 时的答案。", "hint": null, "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Areny", "background": null, "description": "Bajtek 在圣诞节收到了父母送的最新电脑游戏 Byte Defence 4。他兴致勃勃地打开游戏开始玩。游戏里操控的角色叫 Bajtonator，需要通过打怪、完成任务和升级装备来变强。地图上有 $n$ 个特殊的竞技场，里面有很稀有的掉落品。但有 $n$ 种通行证，想进某个竞技场必须持有对应的通行证。\n\n这个游戏的规则如下：\n\n1. 如果你有某个竞技场的通行证，就可以进入该竞技场与怪物战斗。进入竞技场不会消耗通行证，怪物会在你离开后复活，所以同一张通行证可以反复使用，反复挑战同一竞技场。\n2. 每个竞技场都有一个事先公开、固定不变的通行证池，池里的通行证不会被移出或改变。击败竞技场里的怪物后，除了可能掉落稀有物品外，还会从该竞技场的通行证池里随机抽取一张通行证，复制一份交给你。所以你可能在多次胜利后拥有相同类型的多张通行证副本。\n\n看了攻略后，Bajtek 得知竞技场编号越大越难。他的实力可以用一个整数 $k$ 来表示：他一定能在编号小于等于 $k$ 的竞技场获胜，而对编号大于 $k$ 的竞技场他一定无法获胜。\n\n开始时他没有任何通行证，只能花钱买**一张**。买哪一张最划算呢？\n\n他认为，如果买了竞技场 $A$ 的通行证，凭借这个起始通行证和之后的战斗所得通行证，**无论如何**他最终都能进入竞技场 $B$ 并获胜，那这张通行证就是值得买的。\n\n所以他想知道，对于某个固定的 $k$，有多少有序竞技场对 $(A,B)$ 满足：\n\n1. $A\\neq B$。\n2. 如果只买了竞技场 $A$ 的通行证，凭借这个起始通行证和之后的战斗所得通行证，无论如何他最终都能进入竞技场 $B$ 并获胜。\n\n你需要对于 $k=1,2,\\cdots,n$ 计算这样的有序对 $(A,B)$ 的个数。", "inputFormat": "第一行，一个整数 $n\\;(2\\le n\\le 2\\cdot 10^5)$，表示竞技场的数量。\n\n接下来 $n$ 行，其中第 $i$ 行先是一个整数 $l_i\\;(1\\le l_i)$，表示第 $i$ 个竞技场的通行证池大小。随后给出 $l_i$ 个整数，表示该池中每种通行证能进入的竞技场编号。所有 $l_i$ 的总和不超过 $5\\cdot10^5$。", "outputFormat": "一行，$n$ 个整数，其中第 $i$ 个整数表示 $k = i$ 时的答案。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P9053", "type": "P", "difficulty": 4, "samples": [["5\n1 4 3 5 2", "11 5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "PA（波兰）"], "title": "[PA 2021] Ranking sklepów internetowych", "background": "", "description": "给定长为 $n$ 的**排列** $a$。\n\n定义区间 $[l, r]$ 的权值如下：将区间内的数从小到大排序，设 $x$ 为区间长度（即 $r - l + 1$），$y$ 为区间中位数，则该区间的权值为 $x + 2y$。\n\n求所有 $\\frac{n(n + 1)}{2}$ 个区间中权值的最大值和最大值的个数。\n\n------------\n\n中位数的定义：\n\n以一个长为 $n$ 的**单调递增**的序列 $a$ 为例。\n\n- 当 $n$ 为奇数，中位数为 $a_{\\frac{n + 1}{2}}$。\n- 当 $n$ 为偶数，中位数为 $\\frac{a_{\\frac{n}{2}} + a_{\\frac{n}{2} + 1}}{2}$。", "inputFormat": "第一行，一个整数 $n$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$。", "outputFormat": "一行，两个整数，表示权值的最大值和最大值的个数。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^6$，$1 \\leq a_i \\leq n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Ranking sklepów internetowych", "background": "", "description": "给定长为 $n$ 的**排列** $a$。\n\n定义区间 $[l, r]$ 的权值如下：将区间内的数从小到大排序，设 $x$ 为区间长度（即 $r - l + 1$），$y$ 为区间中位数，则该区间的权值为 $x + 2y$。\n\n求所有 $\\frac{n(n + 1)}{2}$ 个区间中权值的最大值和最大值的个数。\n\n------------\n\n中位数的定义：\n\n以一个长为 $n$ 的**单调递增**的序列 $a$ 为例。\n\n- 当 $n$ 为奇数，中位数为 $a_{\\frac{n + 1}{2}}$。\n- 当 $n$ 为偶数，中位数为 $\\frac{a_{\\frac{n}{2}} + a_{\\frac{n}{2} + 1}}{2}$。", "inputFormat": "第一行，一个整数 $n$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$。", "outputFormat": "一行，两个整数，表示权值的最大值和最大值的个数。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^6$，$1 \\leq a_i \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P9054", "type": "P", "difficulty": 7, "samples": [["9 11\n4\n2 2 1 1\n4\n2 2 2 2\n4\n2 1 1 2\n7\n5 5 4 4 4 5 5\n7\n1 3 2 2 2 2 4\n7\n3 3 2 4 4 5 3\n8\n2 2 3 5 3 3 3 4\n8\n5 4 4 4 4 6 6 5\n8\n4 4 4 2 4 4 2 3\n9\n4 7 5 5 5 5 3 4 4\n9\n3 4 4 4 4 4 4 4 6", "1 2 4 3\n2 1 4 3\n1 3 2 4\n3 1 7 2 6 4 5\n3 1 6 4 2 5 7\n2 3 1 6 4 7 5\n5 6 3 1 7 4 2 8\n1 8 2 7 3 5 6 4\n6 3 2 7 4 5 1 8\n5 8 6 3 7 1 9 2 4\n2 9 3 1 8 5 7 6 4"], ["5 1\n4\n2 2 1 1\n1011\n0111\n1011\n1001\n1010", "1 2 4 3"], ["6 1\n4\n2 2 1 1\n1011", "1 2 4 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["动态规划 DP", "贪心", "集训队互测", "2022", "Special Judge", "O2优化", "构造", "Ad-hoc", "分类讨论"], "title": "[集训队互测 2022] 心跳排列图", "background": "下发文件见附件。", "description": "注：本题中所有序列下标均从 1 开始。\n\n机器人心脏的跳动，排列成图是什么样的？\n\n你有一个算法竞赛机器人，每分钟心跳 $n$ 次，第 $i$ 次心跳的强度为 $a_i$。这里，$a_1\\sim a_n$ 恰为 $1\\sim n$ 的一个排列。\n\n设 $A_i$ 为序列 $a$ 删除第 $i$ 个元素后得到的序列，即 $A_i=[a_1,\\dots,a_{i-1},a_{i+1},\\dots,a_n]$。\n\n对于元素互不相同的序列 $p$，设 $G(p)$ 为一个无向图，有 $|p|$ 个点，编号为 $1\\sim |p|$。对于每对正整数 $1\\le i\\lt j\\le |p|$，若 $\\forall k\\in [i,j]\\cap \\mathbb{Z}$，都有 $p_k\\in [\\min(p_i,p_j),\\max(p_i,p_j)]$，则 $G(p)$ 中 $i$ 号点和 $j$ 号点有一条边。设 $F(p)$ 为 $G(p)$ 中 $1$ 号点到 $|p|$ 号点的最短路长度，这里一条路径长度定义为其边数。\n\n设 $f(a)=[F(A_1),F(A_2),\\dots,F(A_n)]$。\n\n给定长度为 $n$ 的序列 $[b_1,\\dots,b_n]$，请你求出任意一个 $1\\sim n$ 的排列 $a$，使得 $f(a)=b$。**保证有解。**\n\n在某些子任务中，算法竞赛机器人小 G 会给你一些“提示”：设 $G_0=G(a)$，设 $path_0$ 为 $G_0$ 中某条 $1$ 到 $n$ 的最短路经过的点构成的集合，设 $path_j$ 为 $G(A_j)$ 中某条起始点到结束点的最短路经过的点构成的集合（注意，为了方便，这里给出的 $path_j$ 中点的编号仍然沿用原图中点的编号，参见样例 2）。则小 G 有可能会额外告诉你所有 $path_j$（包括 $path_0$），也有可能只告诉你 $path_0$，也有可能不给你提示，详见输入格式。\n\n保证给出的提示是正确的，也即一定存在一个满足所有提示的排列。\n\n下发文件中有 `checker.cpp`，你可以用它来检查自己的输出是否正确。用法是 `./checker input output output`，`input` 和 `output` 分别为输入文件和你的输出。同时还下发了 `testlib.h`，请将其和 checker 置于同一目录下来编译 checker。", "inputFormat": "第一行两个正整数，为子任务编号 $S$ 以及数据组数 $T$。\n\n接下来 $T$ 组数据，每组数据格式为：第一行一个正整数 $n$，第二行 $n$ 个正整数 $b_1,\\dots,b_n$。\n\n**特别地，**\n\n1. 若 $S=5$，每组数据还会输入 $n+1$ 行，这 $n+1$ 行里第 $i$ 行是一个长度为 $n$ 的 01 串 $c_i$，$c_{i,j}=[j\\in path_{i-1}]$。\n2. 若 $S=6$，每组数据还会输入第三行，包含一个长度为 $n$ 的 01 串 $c$，$c_i=[i\\in path_0]$。\n\n注意：\n\n1. 即使你的程序不需要用到提示，在 $S=5$ 或 $S=6$ 时你仍然需要读入数组 $c$。\n2. 对于一种输入的 $b$，符合条件的 $a$ 可能不唯一，进而 $c$ 可能也不唯一。**不要求**你的输出符合我们给出的 $c$ 的限制，只要符合 $b$ 的限制即视为正确。\n\n同一行输入的不同变量用一个空格隔开。", "outputFormat": "对于每组数据输出一行 $n$ 个正整数，为你求出的排列 $a$。", "hint": "**样例 1 解释**\n\n考虑样例中的第一组数据。一组解是 $a=[1,2,4,3]$。$A_1,A_2,A_3,A_4$ 分别为 $[2,4,3],[1,4,3],[1,2,3],[1,2,4]$。$G(A_1),G(A_2),G(A_3),G(A_4)$ 四个图中的边分别为：\n\n- $G(A_1)$：$(1,2),(2,3)$。因此 $F(A_1)=2$。\n- $G(A_2)$：$(1,2),(2,3)$。因此 $F(A_2)=2$。\n- $G(A_3)$：$(1,2),(1,3),(2,3)$。因此 $F(A_3)=1$。\n- $G(A_4)$：$(1,2),(1,3),(2,3)$。因此 $F(A_4)=1$。\n\n所以 $f(a)=[2,2,1,1]$，符合输入。\n\n符合输入的 $a$ 不唯一，比如 $a=[4,3,1,2]$ 也是正确的。\n\n**样例 2 解释**\n\n该样例的排列和第一个样例中第一组数据是相同的，但本样例存在子任务 5 的提示。注意在给出 $path_j$ 时仍然沿用原编号，例如删去 $1$ 后，新的最短路经过的点编号为 $2\\to 3\\to 4$。\n\n**样例 3 解释**\n\n该样例的排列和第一个样例中第一组数据是相同的，但本样例存在子任务 6 的提示。\n\n**数据范围**\n\n对于所有数据：$1\\le T\\le 4\\times 10^4,4\\le n\\le 10^5,\\sum n\\le 5\\times 10^5$。\n\n- 子任务 1（$7$ 分）$T\\le 250,n\\le 7$。\n- 子任务 2（$5$ 分）$b_i=1$。\n- 子任务 3（$10$ 分）$n\\ge 90000$，保证存在一组解满足 $a_1=1,a_n=n$。\n- 子任务 4（$7$ 分）$n\\ge 90000$，保证存在一组解满足 $a_2=1,a_{n-1}=n$。\n- 子任务 5（$15$ 分）$n\\le 100,\\sum n^3\\le 3\\times 10^6$，存在所有 $path_j$ 的提示。\n- 子任务 6（$15$ 分）$n\\le 100,\\sum n^3\\le 3\\times 10^6$，存在 $path_0$ 的提示。\n- 子任务 7（$15$ 分）$n=100,T=3$，共 5 个测试点，输入生成方式是随机一个 $a$ 再求出 $f(a)$ 作为输入。\n- 子任务 8（$25$ 分）$n\\le 100,\\sum n^3\\le 3\\times 10^6$。\n- 子任务 9（$1$ 分）无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2022] 心跳排列图", "background": "下发文件见附件。", "description": "注：本题中所有序列下标均从 1 开始。\n\n机器人心脏的跳动，排列成图是什么样的？\n\n你有一个算法竞赛机器人，每分钟心跳 $n$ 次，第 $i$ 次心跳的强度为 $a_i$。这里，$a_1\\sim a_n$ 恰为 $1\\sim n$ 的一个排列。\n\n设 $A_i$ 为序列 $a$ 删除第 $i$ 个元素后得到的序列，即 $A_i=[a_1,\\dots,a_{i-1},a_{i+1},\\dots,a_n]$。\n\n对于元素互不相同的序列 $p$，设 $G(p)$ 为一个无向图，有 $|p|$ 个点，编号为 $1\\sim |p|$。对于每对正整数 $1\\le i\\lt j\\le |p|$，若 $\\forall k\\in [i,j]\\cap \\mathbb{Z}$，都有 $p_k\\in [\\min(p_i,p_j),\\max(p_i,p_j)]$，则 $G(p)$ 中 $i$ 号点和 $j$ 号点有一条边。设 $F(p)$ 为 $G(p)$ 中 $1$ 号点到 $|p|$ 号点的最短路长度，这里一条路径长度定义为其边数。\n\n设 $f(a)=[F(A_1),F(A_2),\\dots,F(A_n)]$。\n\n给定长度为 $n$ 的序列 $[b_1,\\dots,b_n]$，请你求出任意一个 $1\\sim n$ 的排列 $a$，使得 $f(a)=b$。**保证有解。**\n\n在某些子任务中，算法竞赛机器人小 G 会给你一些“提示”：设 $G_0=G(a)$，设 $path_0$ 为 $G_0$ 中某条 $1$ 到 $n$ 的最短路经过的点构成的集合，设 $path_j$ 为 $G(A_j)$ 中某条起始点到结束点的最短路经过的点构成的集合（注意，为了方便，这里给出的 $path_j$ 中点的编号仍然沿用原图中点的编号，参见样例 2）。则小 G 有可能会额外告诉你所有 $path_j$（包括 $path_0$），也有可能只告诉你 $path_0$，也有可能不给你提示，详见输入格式。\n\n保证给出的提示是正确的，也即一定存在一个满足所有提示的排列。\n\n下发文件中有 `checker.cpp`，你可以用它来检查自己的输出是否正确。用法是 `./checker input output output`，`input` 和 `output` 分别为输入文件和你的输出。同时还下发了 `testlib.h`，请将其和 checker 置于同一目录下来编译 checker。", "inputFormat": "第一行两个正整数，为子任务编号 $S$ 以及数据组数 $T$。\n\n接下来 $T$ 组数据，每组数据格式为：第一行一个正整数 $n$，第二行 $n$ 个正整数 $b_1,\\dots,b_n$。\n\n**特别地，**\n\n1. 若 $S=5$，每组数据还会输入 $n+1$ 行，这 $n+1$ 行里第 $i$ 行是一个长度为 $n$ 的 01 串 $c_i$，$c_{i,j}=[j\\in path_{i-1}]$。\n2. 若 $S=6$，每组数据还会输入第三行，包含一个长度为 $n$ 的 01 串 $c$，$c_i=[i\\in path_0]$。\n\n注意：\n\n1. 即使你的程序不需要用到提示，在 $S=5$ 或 $S=6$ 时你仍然需要读入数组 $c$。\n2. 对于一种输入的 $b$，符合条件的 $a$ 可能不唯一，进而 $c$ 可能也不唯一。**不要求**你的输出符合我们给出的 $c$ 的限制，只要符合 $b$ 的限制即视为正确。\n\n同一行输入的不同变量用一个空格隔开。", "outputFormat": "对于每组数据输出一行 $n$ 个正整数，为你求出的排列 $a$。", "hint": "**样例 1 解释**\n\n考虑样例中的第一组数据。一组解是 $a=[1,2,4,3]$。$A_1,A_2,A_3,A_4$ 分别为 $[2,4,3],[1,4,3],[1,2,3],[1,2,4]$。$G(A_1),G(A_2),G(A_3),G(A_4)$ 四个图中的边分别为：\n\n- $G(A_1)$：$(1,2),(2,3)$。因此 $F(A_1)=2$。\n- $G(A_2)$：$(1,2),(2,3)$。因此 $F(A_2)=2$。\n- $G(A_3)$：$(1,2),(1,3),(2,3)$。因此 $F(A_3)=1$。\n- $G(A_4)$：$(1,2),(1,3),(2,3)$。因此 $F(A_4)=1$。\n\n所以 $f(a)=[2,2,1,1]$，符合输入。\n\n符合输入的 $a$ 不唯一，比如 $a=[4,3,1,2]$ 也是正确的。\n\n**样例 2 解释**\n\n该样例的排列和第一个样例中第一组数据是相同的，但本样例存在子任务 5 的提示。注意在给出 $path_j$ 时仍然沿用原编号，例如删去 $1$ 后，新的最短路经过的点编号为 $2\\to 3\\to 4$。\n\n**样例 3 解释**\n\n该样例的排列和第一个样例中第一组数据是相同的，但本样例存在子任务 6 的提示。\n\n**数据范围**\n\n对于所有数据：$1\\le T\\le 4\\times 10^4,4\\le n\\le 10^5,\\sum n\\le 5\\times 10^5$。\n\n- 子任务 1（$7$ 分）$T\\le 250,n\\le 7$。\n- 子任务 2（$5$ 分）$b_i=1$。\n- 子任务 3（$10$ 分）$n\\ge 90000$，保证存在一组解满足 $a_1=1,a_n=n$。\n- 子任务 4（$7$ 分）$n\\ge 90000$，保证存在一组解满足 $a_2=1,a_{n-1}=n$。\n- 子任务 5（$15$ 分）$n\\le 100,\\sum n^3\\le 3\\times 10^6$，存在所有 $path_j$ 的提示。\n- 子任务 6（$15$ 分）$n\\le 100,\\sum n^3\\le 3\\times 10^6$，存在 $path_0$ 的提示。\n- 子任务 7（$15$ 分）$n=100,T=3$，共 5 个测试点，输入生成方式是随机一个 $a$ 再求出 $f(a)$ 作为输入。\n- 子任务 8（$25$ 分）$n\\le 100,\\sum n^3\\le 3\\times 10^6$。\n- 子任务 9（$1$ 分）无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P9055", "type": "P", "difficulty": 6, "samples": [["2 0 1 2\n10", "3034"], ["14 1 14 13\n10110101110101", "379883349"]], "limits": {"time": [600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "集训队互测", "2021", "O2优化", "组合数学", "构造", "分类讨论"], "title": "[集训队互测 2021] 数列重排", "background": "dottle bot。", "description": "定义一个数列区间的 $\\textrm{mex}$ 为区间中最小的没有出现过的自然数，定义一个数列的价值为其中 $\\textrm{mex}\\geq k$ 的区间数量。\n\n给定 $n$ 个小于 $m$ 的自然数和一个区间 $[l,r]$，令 $f(k)$ 表示 $n$ 个数构成的数列所有重排列中数列价值的最大值，对于每一个 $k\\in [l,r]$，求出 $f(k)$。\n\n令 $a_i$ 表示数字 $i$ 出现的次数，保证存在正整数 $X$，使得  $\\forall i\\le m-1,a_i\\in \\{X,X+1\\}$。", "inputFormat": "由于 $n$ 可能很大，将采取如下方式减少读入量：\n\n第一行四个整数 $m,l,r,X$。\n\n第二行一个长度为 $m$ 的 $01$ 串，若其中第 $i$ 个位置为 $1$ 则数字 $i-1$ 的出现次数为 $X+1$，否则出现次数为 $X$。\n\n根据输入可以推出 $n=mX+S$，其中 $S$ 为 $01$ 串中 $1$ 的数量。", "outputFormat": "为了减少输出量，令 $ans=\\displaystyle{\\bigoplus_{i=l}^r}  (233^if(i)\\bmod 998244353)$，其中 $\\displaystyle\\bigoplus$ 表示二进制下的按位异或，输出一行一个整数 $ans$。", "hint": "#### 样例 1 解释\n\n在样例给出的数列中，有 $3$ 个 $0$ 和 $2$ 个 $1$，任意排列 $f(0)$ 均为 $15$，排列为 $\\textrm{01010}$ 时 $f(1)$ 有最大值 $13$，答案为：\n$$\n\\displaystyle (233^0\\times 15\\bmod 998244353)\\oplus(233^1\\times 13\\bmod 998244353)=3034\n$$\n\n#### 数据范围\n\n- Subtask 1（5 points）：$n,m\\leq 9$。\n- Subtask 2（15 points）：$n,m\\leq 200$。\n- Subtask 3（15 points）：$n,m\\leq 5\\times 10^3$。\n- Subtask 4（5 points）：$m\\leq 2$，$l=0$，$r=1$。\n- Subtask 5（10 points）：$m\\leq 10^6$，$l=m$，$r=m$。 \n- Subtask 6（10 points）：$m\\leq 10^6$，$X=1$，$s_i=0$。\n- Subtask 7（15 points）：$m\\leq 10^6$，$r-l+1\\leq 10^4$。\n- Subtask 8（15 points）：$m\\leq 2\\times 10^6$。\n- Subtask 9（10 points）：无特殊限制。\n\n对于所有数据，满足 $n\\leq 10^9$，$m\\leq 10^7$，$0\\leq l\\leq r\\leq m$，$X\\geq 1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2021] 数列重排", "background": "dottle bot。", "description": "定义一个数列区间的 $\\textrm{mex}$ 为区间中最小的没有出现过的自然数，定义一个数列的价值为其中 $\\textrm{mex}\\geq k$ 的区间数量。\n\n给定 $n$ 个小于 $m$ 的自然数和一个区间 $[l,r]$，令 $f(k)$ 表示 $n$ 个数构成的数列所有重排列中数列价值的最大值，对于每一个 $k\\in [l,r]$，求出 $f(k)$。\n\n令 $a_i$ 表示数字 $i$ 出现的次数，保证存在正整数 $X$，使得  $\\forall i\\le m-1,a_i\\in \\{X,X+1\\}$。", "inputFormat": "由于 $n$ 可能很大，将采取如下方式减少读入量：\n\n第一行四个整数 $m,l,r,X$。\n\n第二行一个长度为 $m$ 的 $01$ 串，若其中第 $i$ 个位置为 $1$ 则数字 $i-1$ 的出现次数为 $X+1$，否则出现次数为 $X$。\n\n根据输入可以推出 $n=mX+S$，其中 $S$ 为 $01$ 串中 $1$ 的数量。", "outputFormat": "为了减少输出量，令 $ans=\\displaystyle{\\bigoplus_{i=l}^r}  (233^if(i)\\bmod 998244353)$，其中 $\\displaystyle\\bigoplus$ 表示二进制下的按位异或，输出一行一个整数 $ans$。", "hint": "#### 样例 1 解释\n\n在样例给出的数列中，有 $3$ 个 $0$ 和 $2$ 个 $1$，任意排列 $f(0)$ 均为 $15$，排列为 $\\textrm{01010}$ 时 $f(1)$ 有最大值 $13$，答案为：\n$$\n\\displaystyle (233^0\\times 15\\bmod 998244353)\\oplus(233^1\\times 13\\bmod 998244353)=3034\n$$\n\n#### 数据范围\n\n- Subtask 1（5 points）：$n,m\\leq 9$。\n- Subtask 2（15 points）：$n,m\\leq 200$。\n- Subtask 3（15 points）：$n,m\\leq 5\\times 10^3$。\n- Subtask 4（5 points）：$m\\leq 2$，$l=0$，$r=1$。\n- Subtask 5（10 points）：$m\\leq 10^6$，$l=m$，$r=m$。 \n- Subtask 6（10 points）：$m\\leq 10^6$，$X=1$，$s_i=0$。\n- Subtask 7（15 points）：$m\\leq 10^6$，$r-l+1\\leq 10^4$。\n- Subtask 8（15 points）：$m\\leq 2\\times 10^6$。\n- Subtask 9（10 points）：无特殊限制。\n\n对于所有数据，满足 $n\\leq 10^9$，$m\\leq 10^7$，$0\\leq l\\leq r\\leq m$，$X\\geq 1$。", "locale": "zh-CN"}}}
{"pid": "P9056", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 3000, 3000, 3000, 3000, 3000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["集训队互测", "2022", "交互题", "Special Judge", "O2优化", "树论", "随机化"], "title": "[集训队互测 2022] 在路上", "background": "滥用本题评测者封号。\n\ndottle bot。", "description": "**这是一道交互题，仅支持 C++ 提交**。\n\n有一棵未知的树，**保证树的大小为奇数，你需要找到这棵树重心的编号**。\n\n你可以进行询问，每次询问你可以询问三个点 $(x,y,z)$，若不存在一条简单路径同时经过三个点，则交互器会返回 $0$，否则若存在，那么交互器会返回三个点在路径上相对顺序中间的一个点。\n\n令 $dis(a,b)$ 表示 $a,b$ 两点在树上最短路径经过的边数，你也可以理解为:\n\n若 $dis(x,y)+dis(x,z)=dis(y,z)$，则交互器会返回 $x$。\n\n否则若 $dis(y,x)+dis(y,z)=dis(x,z)$，交互器会返回 $y$。\n\n否则若 $dis(z,x)+dis(z,y)=dis(x,y)$，交互器会返回 $z$。\n\n否则交互器会返回 $0$。\n\n在最终的测试中，每个测试点会包含 $T$ 组测试数据，和一个常数 $M$，表示你在所有测试数据中询问次数总和的上限，具体细则见 输入格式 以及 数据范围。\n\n#### 实现细节\n\n~~你需要引用 `path.h` 头文件。~~ 本题中你只需要把 `path.h` 头文件的内容粘贴到程序开头即可，不要引用 `path.h` 头文件。\n\n你需要实现下面的函数：\n\n```\nint centroid(int id,int N,int M);\n```\n\n其中 $id$ 为当前子任务的编号，$N$ 为当前询问树的大小，$M$ 为当前测试点剩余的询问次数，函数的返回值为当前树的重心编号。\n\n具体的，在第一次调用时 $M$ 为当前测试点的询问次数上限，每次调用结束之后 $M$ 会减去当前测试点使用的询问次数。\n\n你可以调用下面的函数：\n\n```\nint ask(int x,int y,int z);\n```\n\n表示你进行了一次询问，交互器会返回当前询问的答案，特别的，若询问次数已经超过了上限，交互器会返回 $-1$。\n\n注意同一个测试点中 `centroid` 函数可能会被多次调用，请注意数组清空等情况。\n\n**下发文件中有样例交互库，该交互库的实现与评测时的交互库几乎一致，如果对交互方式有不理解可以参照交互库的代码理解**。\n", "inputFormat": "样例评测库将读入如下格式的输入数据：\n\n第一行三个整数 $id,T,M$，表示当前的子任务编号以及测试数据的数量，以及询问次数的上界。\n\n对于每一组测试数据，第一行一个正整数 $n$，表示当前测试数据中树的大小。\n\n之后一行 $n-1$ 个正整数，第 $i$ 个数表示 $i+1$ 在以 $1$ 为根意义下的父亲节点。\n\n数据的答案将在交互库内部计算。", "outputFormat": "具体信息见交互库。", "hint": "#### 数据范围\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f3d6b2zv.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)\n\n特殊性质 $A$：保证树的形态为一条链，即每个点的度数均不超过 $2$。\n\n保证每个 Subtask 里的测试数据数量均不超过 $20$。**请仔细阅读每一档子任务及其限制**。\n\n#### 时空限制\n\nSubtask 5 时限为 3s。\n\nSubtask 7,8 时限为 4s。\n\n其余 Subtask 时限为 1s。\n\n空间限制：512MB。\n\n保证最终交互库的时间使用不超过  2s，空间使用不超过 64MB。\n\n#### 下发文件\n\n下发文件中有一个样例交互库，提供的交互头文件，一份示例代码，以及一个满足子任务 $4$ 性质的样例，选手也可以按照题目的输入格式构造其他样例。\n\n另外也有一份洛谷样式的交互库。\n\n保证下发的交互库和最终使用的交互库除反作弊之外没有区别，你可以使用这个交互库输出调试信息。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2022] 在路上", "background": "滥用本题评测者封号。\n\ndottle bot。", "description": "**这是一道交互题，仅支持 C++ 提交**。\n\n有一棵未知的树，**保证树的大小为奇数，你需要找到这棵树重心的编号**。\n\n你可以进行询问，每次询问你可以询问三个点 $(x,y,z)$，若不存在一条简单路径同时经过三个点，则交互器会返回 $0$，否则若存在，那么交互器会返回三个点在路径上相对顺序中间的一个点。\n\n令 $dis(a,b)$ 表示 $a,b$ 两点在树上最短路径经过的边数，你也可以理解为:\n\n若 $dis(x,y)+dis(x,z)=dis(y,z)$，则交互器会返回 $x$。\n\n否则若 $dis(y,x)+dis(y,z)=dis(x,z)$，交互器会返回 $y$。\n\n否则若 $dis(z,x)+dis(z,y)=dis(x,y)$，交互器会返回 $z$。\n\n否则交互器会返回 $0$。\n\n在最终的测试中，每个测试点会包含 $T$ 组测试数据，和一个常数 $M$，表示你在所有测试数据中询问次数总和的上限，具体细则见 输入格式 以及 数据范围。\n\n#### 实现细节\n\n~~你需要引用 `path.h` 头文件。~~ 本题中你只需要把 `path.h` 头文件的内容粘贴到程序开头即可，不要引用 `path.h` 头文件。\n\n你需要实现下面的函数：\n\n```\nint centroid(int id,int N,int M);\n```\n\n其中 $id$ 为当前子任务的编号，$N$ 为当前询问树的大小，$M$ 为当前测试点剩余的询问次数，函数的返回值为当前树的重心编号。\n\n具体的，在第一次调用时 $M$ 为当前测试点的询问次数上限，每次调用结束之后 $M$ 会减去当前测试点使用的询问次数。\n\n你可以调用下面的函数：\n\n```\nint ask(int x,int y,int z);\n```\n\n表示你进行了一次询问，交互器会返回当前询问的答案，特别的，若询问次数已经超过了上限，交互器会返回 $-1$。\n\n注意同一个测试点中 `centroid` 函数可能会被多次调用，请注意数组清空等情况。\n\n**下发文件中有样例交互库，该交互库的实现与评测时的交互库几乎一致，如果对交互方式有不理解可以参照交互库的代码理解**。\n", "inputFormat": "样例评测库将读入如下格式的输入数据：\n\n第一行三个整数 $id,T,M$，表示当前的子任务编号以及测试数据的数量，以及询问次数的上界。\n\n对于每一组测试数据，第一行一个正整数 $n$，表示当前测试数据中树的大小。\n\n之后一行 $n-1$ 个正整数，第 $i$ 个数表示 $i+1$ 在以 $1$ 为根意义下的父亲节点。\n\n数据的答案将在交互库内部计算。", "outputFormat": "具体信息见交互库。", "hint": "#### 数据范围\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f3d6b2zv.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)\n\n特殊性质 $A$：保证树的形态为一条链，即每个点的度数均不超过 $2$。\n\n保证每个 Subtask 里的测试数据数量均不超过 $20$。**请仔细阅读每一档子任务及其限制**。\n\n#### 时空限制\n\nSubtask 5 时限为 3s。\n\nSubtask 7,8 时限为 4s。\n\n其余 Subtask 时限为 1s。\n\n空间限制：512MB。\n\n保证最终交互库的时间使用不超过  2s，空间使用不超过 64MB。\n\n#### 下发文件\n\n下发文件中有一个样例交互库，提供的交互头文件，一份示例代码，以及一个满足子任务 $4$ 性质的样例，选手也可以按照题目的输入格式构造其他样例。\n\n另外也有一份洛谷样式的交互库。\n\n保证下发的交互库和最终使用的交互库除反作弊之外没有区别，你可以使用这个交互库输出调试信息。", "locale": "zh-CN"}}}
{"pid": "P9057", "type": "P", "difficulty": 7, "samples": [["5 20 10\n1 4 4 166348285\n2 2 5\n2 1 5\n1 1 2 10\n1 4 4 3\n1 4 5 6\n2 5 5\n1 5 5 1\n1 2 3 1\n2 5 5\n2 5 5\n2 3 4\n2 3 3\n2 4 5\n2 4 4\n1 2 5 5\n1 5 5 9\n1 1 4 5\n2 5 5\n2 1 4", "4\n5\n2\n3\n3\n4\n2\n5\n2\n2\n8"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2004", "O2优化", "Ynoi"], "title": "[Ynoi2004] rpfrdtzls", "background": "", "description": "给定 $n,m,A$，维护由序列构成的序列 $a_1,\\dots,a_n$，初始 $a_i$ 包含一个元素 $A+1$；\n\n共 $m$ 次操作：\n\n修改操作：给定 $l,r,x$，对 $l\\le i\\le r$，在序列 $a_i$ 前面插入元素 $x$\n\n查询操作：给定 $l,r$，查询 $\\sum\\limits_{i=l}^r F(a_i,A)$\n\n其中 $F((x_1,\\dots,x_n),0)=0$\n\n对 $k>0$，$F((x_1,\\dots,x_n),k)=F((x_2,\\dots,x_n),\\lfloor \\frac{k}{x_1} \\rfloor)+1$\n\n### ", "inputFormat": "第一行三个整数 $n,m,A$；\n\n接下来 $m$ 行，每行 $1,l,r,x$ 表示一个修改操作，或 $2,l,r$ 表示一个查询操作；", "outputFormat": "对每个查询操作，输出一行，表示答案。", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m\\le 5\\times 10^5$，$1\\le A,x\\le 10^9$，$1\\le l\\le r\\le n$。\n\n对于 $25\\%$ 的数据，满足 $n,m\\le 100$。\n\n对于 $50\\%$ 的数据，满足 $n,m\\le 10^5$。\n\n对于另外 $25\\%$ 的数据，满足 $x\\ne 1$。\n\n对于另外 $25\\%$ 的数据，无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2004] rpfrdtzls", "background": "", "description": "给定 $n,m,A$，维护由序列构成的序列 $a_1,\\dots,a_n$，初始 $a_i$ 包含一个元素 $A+1$；\n\n共 $m$ 次操作：\n\n修改操作：给定 $l,r,x$，对 $l\\le i\\le r$，在序列 $a_i$ 前面插入元素 $x$\n\n查询操作：给定 $l,r$，查询 $\\sum\\limits_{i=l}^r F(a_i,A)$\n\n其中 $F((x_1,\\dots,x_n),0)=0$\n\n对 $k>0$，$F((x_1,\\dots,x_n),k)=F((x_2,\\dots,x_n),\\lfloor \\frac{k}{x_1} \\rfloor)+1$\n\n### ", "inputFormat": "第一行三个整数 $n,m,A$；\n\n接下来 $m$ 行，每行 $1,l,r,x$ 表示一个修改操作，或 $2,l,r$ 表示一个查询操作；", "outputFormat": "对每个查询操作，输出一行，表示答案。", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m\\le 5\\times 10^5$，$1\\le A,x\\le 10^9$，$1\\le l\\le r\\le n$。\n\n对于 $25\\%$ 的数据，满足 $n,m\\le 100$。\n\n对于 $50\\%$ 的数据，满足 $n,m\\le 10^5$。\n\n对于另外 $25\\%$ 的数据，满足 $x\\ne 1$。\n\n对于另外 $25\\%$ 的数据，无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P9058", "type": "P", "difficulty": 7, "samples": [["5\n1 2 5\n1 3 3\n1 4 4\n3 5 2\n5\n1 1\n1 4\n2 4\n3 4\n2 5", "-1\n3\n7\n7\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2004", "O2优化", "Ynoi"], "title": "[Ynoi2004] rpmtdq", "background": "", "description": "给定一棵有边权的无根树，需要回答一些询问。\n\n定义 $\\texttt{dist(i,j)}$ 代表树上点 $i$ 和点 $j$ 之间的距离。\n\n对于每一组询问，会给出 $l,r$，你需要输出 $\\min(\\texttt{dist(i,j)})$ 其中 $l\\leq i < j \\leq r$。", "inputFormat": "第一行一个整数 $n$，表示树的节点个数。\n\n接下来 $n-1$ 行，每行三个整数 $x,y,z$ 表示一条连接 $x,y$ 边权为 $z$ 的树边，输入保证构成一棵树。\n\n之后一行一个数 $q$，表示询问个数。\n\n之后 $q$ 行，每行两个整数 $l,r$ 表示一组询问，如果对于一组询问，找不到任何二元组 $(i,j)$ 满足 $l\\le i<j\\le r$，则输出 $-1$。", "outputFormat": "输出 $q$ 行，每行一个整数，表示这组询问的答案。", "hint": "Idea：nzhtl1477，Solution：Kubic&ccz181078，Code：Kubic，Data：Kubic\n\n对于$100\\%$的数据，满足 $n\\leq2\\times 10^5$，$q\\leq 10^6$，$1\\le z\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2004] rpmtdq", "background": "", "description": "给定一棵有边权的无根树，需要回答一些询问。\n\n定义 $\\texttt{dist(i,j)}$ 代表树上点 $i$ 和点 $j$ 之间的距离。\n\n对于每一组询问，会给出 $l,r$，你需要输出 $\\min(\\texttt{dist(i,j)})$ 其中 $l\\leq i < j \\leq r$。", "inputFormat": "第一行一个整数 $n$，表示树的节点个数。\n\n接下来 $n-1$ 行，每行三个整数 $x,y,z$ 表示一条连接 $x,y$ 边权为 $z$ 的树边，输入保证构成一棵树。\n\n之后一行一个数 $q$，表示询问个数。\n\n之后 $q$ 行，每行两个整数 $l,r$ 表示一组询问，如果对于一组询问，找不到任何二元组 $(i,j)$ 满足 $l\\le i<j\\le r$，则输出 $-1$。", "outputFormat": "输出 $q$ 行，每行一个整数，表示这组询问的答案。", "hint": "Idea：nzhtl1477，Solution：Kubic&ccz181078，Code：Kubic，Data：Kubic\n\n对于$100\\%$的数据，满足 $n\\leq2\\times 10^5$，$q\\leq 10^6$，$1\\le z\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P9060", "type": "P", "difficulty": 6, "samples": [["5 3\n2 6 3 15 5\n4 4\n1 3\n2 5", "15\n216\n546750"], ["6 6\n3332 411 6666 6291 415 7180\n4 6\n1 5\n5 6\n4 4\n1 2\n1 3", "889738671\n989336054\n14898500\n6291\n1369452\n867407130"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2002", "O2优化", "Ynoi"], "title": "[Ynoi2002] Goedel Machine", "background": "# 1.前言\n\n哥德尔机 [1] 是由 LSTM 之父 Jürgen Schmidhuber 提出的一种可学习的通用问题求解器。本文将对该模型进行描述与讨论，并且说明这个模型拥有许多重要的性质，这些性质是我们认为通用人工智能所必需的。\n\n# 2.相关概念\n\n## 学习\n\n学习指模型对模型自身的参数（同一个模型在参数不同时有不同的行为）进行修改。用于对自己进行修改的方法叫做学习算法。\n\n## 元学习\n\n元学习指模型拥有通过学习修改自己的学习算法的能力。有大量证据指示人类拥有比较强的元学习的能力。\n\n### 元学习分层\n\n不可学习的方法没有学习能力，比如解决 OI 题的程序，坦克世界的固定线路看到人就停车的脚本等。\n\n常见的机器学习方法，比如朴素的神经网络方法没有元学习能力，因为学习算法是不可学习的梯度下降算法。支持向量机没有元学习能力，因为学习算法是确定的，等。\n\n专门设计了元学习特性的神经网络有元学习能力，但是没有元元学习能力，也就是说不能对学习自己学习算法的算法进行学习。\n\n假设你想设计一种学习算法：\n\n初始时，你想让你的算法可学习，于是设计了初始的学习算法。\n\n然后你想让你的初始学习算法可学习，于是设计了元学习算法。\n\n然后你想让你的元学习算法可学习，于是设计了元元学习算法。\n\n这样每一步你都必须设计新的学习算法，用于之前的学习算法的学习。设计第 $i$ 层的学习算法时，这个学习算法可以优化前 $i-1$ 层，但是对第 $i$ 层的优化需要第 $i+1$ 层后的方法。分层不是必需的，这里分层是人为设计的，因为你人为设计了分层结构，所以你需要设计无限层的元学习算法。\n\n一直这样递归下去可以发现现有机器学习方法的一个问题：因为不能人工设计无限层的元学习算法，所以在某一层之后一定不可学习。这样会导致人工设计可以一直让模型变强，因为设计了第 $i$ 层元学习的模型不会比只设计了前 $i-1$ 层元学习的模型弱，但是这个过程永不收敛。这样的模型不具备一种**不可改进性**，即在给定足量的计算资源下，这个模型是最优的。\n\n哥德尔机以及类似的构造尝试将所有层级的元学习用同一个东西去泛化，将任意层的元学习问题变成一层普通的学习问题。要实现这样的功能，我们需要一个足够强的优化器。弱的优化器，比如梯度下降的神经网络，面临的问题是无法使用梯度下降去优化模型梯度下降的过程，也就是说无法直接用学习算法去处理元学习层面的优化。于是元学习特性需要人为设计，也就是说需要设计优化元学习任务的优化器，而这样会导致该优化器无法用已设计好的方法优化，需要继续设计新的对应的优化算法。这样分层的元学习需要无限的设计，是神经网络方法最大的问题之一。\n\n### 不分层元学习/无限层元学习\n\n哥德尔机没有元学习分层的设计，因为其架构会将所有优化问题用同样的方法优化，并且该优化方法可以优化自身，所以哥德尔机拥有不分层的元学习能力，或者可以叫做无限层元学习的能力。在给定足量的计算资源下，哥德尔机不弱于任何其它可计算的机器学习模型。\n\n实际上存在一些元学习算法是递归的，即存在一种元学习算法，第 $i$ 层可以对前 $i-1$ 层进行优化，且对任意 $i$，这个算法都是相同的，所以只需要有限的人为设计。我们认为这类方法是有一些问题的，不如不分层的元学习算法，这里不展开讨论。\n\n元学习和学习实际上不可区分，这个会在后续进行讨论。\n\n## 强化学习\n\n模型与环境交互并优化由环境提供的奖励。\n\n### 马尔可夫决策过程\n\n时间被分为一些离散的时间步，模型每个时刻从环境中获取输入信息（包括环境提供的奖励），并能从有限种对环境的操作中选一部分执行，环境由这一时刻的状态以及模型采取的操作计算出环境下一时刻的状态。\n\n## 通用人工智能/完全人工智能/人工广义智能\n\n这些词语是 Artificial General Intelligence 的中文翻译，该词语代表一个可以在各个领域达到人类顶尖水平甚至超越的人工智能模型。\n\n通用人工智能**没有准确的定义**，不同人对通用人工智能应该有什么样的能力看法不同。\n\n## 自编程/自修改/自进步\n\n这三个词语指模型的一种能力，有这种能力的模型可以通过修改自己来提升自己的表现。一般提升表现指可以在监督学习任务中通过更多的数据，或在强化学习任务中获得更大的预期奖励。\n\n## 自指\n\n一个模型是完全自指的，表示某个模型可以在内部描述自己的所有性质。虽然人类不是一个完全自指的模型，但是人类可以描述关于自己的部分性质。\n\n自指常用于构建悖论，如：\n\n1. \"这句话是错的\" 是对的还是错的？\n\n2. 罗素悖论：一个理发师只给不理自己头发的人理发，那这个理发师是否给自己理发？\n\n3. 停机问题：一个图灵机如果判定出自己停机，则不停机。\n\n4. 哥德尔不完备性定理。\n\n哥德尔机是一个可以完全自指的模型。哥德尔机的作者认为 \"意识\" 的本质是自指，即模型可以意识到自己的存在。哥德尔机的学习算法可以完全自指，也就是说可以用学习算法处理学习算法的学习，甚至完全覆写掉初始的学习算法。\n\n## 可计算性\n\n程序在不限制空间并且不限制字长时，能在有限时间内完成处理的问题是可计算的问题所构成的集合。\n\n## 图灵机\n\n本文中我们直接把 图灵机 当成 C++ 语言写成的代码，不限制空间并且不限制字长。\n\n### 通用图灵机\n\n用 C++ 语言显然可以模拟执行 C++ 语言。假设我们写出了一份 C++ 语言代码 A，用于执行任何其它 C++ 语言写出的代码。则当我们想执行 C++ 代码 B 时，可以将 B 做为 A 的输入，并执行 A。这样的代码 A 叫做 通用图灵机。\n\n## 不可区分性\n\n有许多人类设计的分层结构是不可区分的，如：\n\n1. 数据与程序不可区分：这里我们顺便解释中文房间悖论。中文房间指给定一个黑箱，将一个不会中文的人和一个翻译器一起放入。在房间外的人向内部提供中文文章，内部的人将文章输入翻译器后直接得到翻译后的结果，并将结果输出，此时从外部看来，无法判定内部的人是否会中文。这个悖论实际上等价于：现在有一个通用图灵机，以及一份通用人工智能的代码。如果我们将通用图灵机看做模型（程序），将通用人工智能看做数据进行执行（对于通用图灵机而言，一个图灵机的程序可以是数据，并且做为数据的程序可以被执行），则这里可以认为这个通用图灵机在给定数据下是一个通用人工智能。也就是说我们可以将非平凡的部分：通用人工智能，在程序和数据两边任意转移，但必须在某一边解决这个本质问题。\n\n2. 监督学习的数据和模型的先验（初始引入的知识）不可区分，强化学习的人类知识和模型的 reward 不可区分：监督学习模型的 loss 函数可以内嵌任意复杂的信息，包括数据集中的所有信息，这种情况下模型的 loss 是模型的先验的一部分。强化学习模型 reward 函数可以内嵌任意复杂的信息，包括关于环境的先验，以及人类知识。如 AlphaGo 算法中使用了 MCTS 搜索算法做为探索先验，这样的先验（搜索）就是一种人类知识。\n\n3. 模型关于自己的先验与模型关于环境的先验不可区分：这个在后续会进行讨论。\n\n4. 学习和元学习不可区分：假设模型分为学习算法和模型主体部分，学习算法经过学习后被修改了，则这里可以看做是元学习。但如果将整个模型做为一个整体来看待，学习实际上改变了模型的一些参数，是普通的学习。从学习和元学习不可区分也可以看出对元学习人为分层是不自然的，应该将元学习的优化视为普通学习处理。\n\n由于不可区分性，一般来说我们用功能而不是具体的结构来衡量模型的能力。比如对于中文房间悖论，可以认为一个有翻译器的人类就是懂得中文的，因为和懂得中文的人表现一致，一个没有翻译器的人类是不懂得中文的。\n\n同理，由于不可区分性，对于“理解”和“意识”的讨论都是无意义的，因为我们用功能而不是具体的结构来衡量模型的能力。\n\n# 3.简介\n\n几乎所有已知的用于解决问题的算法（包括证明搜索器，监督学习，强化学习等）都在元学习方面有欠缺，理由在元学习分层中有描述。人类需要一直不断地设计新的更好的算法（有更多层元学习的算法），并且提供计算资源对这些算法进行测试。\n\n如何才能消除人类的必要性？为了方便描述，我们定义了学习，学习指模型对模型自身的参数进行修改。对自己进行修改的方法叫做学习算法。最简单的想法就是让机器可以进行任意复杂的学习，也就是说学习方法需要足够强，比如从所有可计算的程序中选出一个最高效的学习算法，利用这个学习算法修改自己。\n\n为了解决这个问题，作者设计了一类最优的，完全自指的，通用的问题求解器——哥德尔机。哥德尔机与一个部分可观测的环境交互，并且原则上可以无限制地修改自身（学习），唯一的限制是哥德尔机自己的可计算性。哥德尔机的初始算法有能力完全重写自己，这样的重写能力保证哥德尔机是全局最优的。\n\n## 哥德尔机的结构\n\n哥德尔机主要包含公理系统、证明搜索程序、行为程序、目标函数。\n\n# 4.环境和形式化目标\n\n模型的环境处在一个人为设计的硬件中，该硬件可以是通用图灵机，空间有限的图灵机，或抽象的电子计算机。模型是单例的，只有唯一一个同时存在。模型的生命包含一些离散的时间步：$1,2,\\dots$，模型的生命在 $T$ 时刻结束，这个时刻可能对模型而言不可见。任何一个时变的变量 $Q$ 在 $t$ 时刻的值可以记作 $Q(t)$。\n\n每一步时间我们的硬件执行一个基本操作，改变硬件的状态 $s$，为不失一般性，$s\\in \\mathcal S \\in B^*$，$B^*$ 表示所有可能的二进制串。每一步时间环境状态可能发生变化，环境状态用 $Env$ 表示，$Env\\in \\mathcal E$，$\\mathcal E$ 表示考虑的环境的集合，这个会在后续进行讨论。硬件有硬编码的转移方程：$F:\\mathcal S\\times \\mathcal E \\rightarrow \\mathcal S$。对任何 $t>1$，$s(t)=F(s(t-1),Env(t-1))$ 表示当前 $t-1$ 个时刻都结束后，$t$ 时刻还没开始时硬件的状态。\n$Env(t)$ 表示 $t$ 时刻的环境，由 $s(t-1)$ 中描述环境变化的变量与环境交互得到，如果环境是随机的，则这里按对应概率进行采样。\n\n定义四个特殊的变量：$time,x,y,p$：\n\n1. $time$ 表示当前时刻。\n2. $x$ 表示环境对哥德尔机的输入，对任意 $t>1$，$x(t)\\neq x(t-1)$ 可能发生当且仅当哥德尔机输出了一个特定字符串，表示向环境请求输入。这样就可以避免每个时刻只有常数的计算资源，导致不能对输入完全观测（比如复制整个输入所需的计算资源比每个时刻的计算资源多）。\n3. $y$ 表示哥德尔机对环境的输出，$y(t)$ 表示一个二进制串。输出可能对环境产生影响，比如输出一个控制指令，指令操作环境中的一个机器人，或者指令打开电视机。\n4. $p(1)$ 表示最初哥德尔机的软件，也就是根据环境输入计算出对环境输出的计算过程。初始的 $p(1)$ 可以用一个图灵机表示，所以不是最优的。\n\n每一个时刻 $1\\le t\\le T$ 模型的目标是最大化预期回报。对于一个确定的 $s$ 和 $Env$，奖励函数可以写做：$u(s,Env):\\mathcal S\\times \\mathcal E\\rightarrow \\mathcal R$，$u(s,Env)=E_{\\mu} \\bigg [\\sum _{\\tau=time} ^T  r(\\tau)\\bigg | s,Env \\bigg ]$，其中 $\\mathcal R$ 表示实数，$r(t)$ 表示 $t$ 时刻获得的实数表示的奖励。$E_{\\mu}\\big(\\cdot \\big|\\cdot\\big)$ 表示条件期望，其中 $\\mu$ 表示所有可能的环境。\n\n这里需要注意到 $s$ 表示的也是模型的内环境，因为硬件行为完全由模型决定，$Env$ 表示外部环境，$time=time(s)$ 表示 $s$ 状态所在时刻。\n\n可以同时修改奖励函数使得模型倾向于选择更低方差的改进。绝大部分计算机科学的问题都可以用这个设计形式化。\n\n# 5.哥德尔机的基本思想\n\n为了让我们的硬件变成一个有自指能力的哥德尔机，需要设计对应的软件（也就是可运行代码） $p$，该软件需要有修改自己的能力。初始的代码 $p(1)$ 有一个目前不是最优的问题求解器 $e(1)$，用于和环境交互，这个问题求解器可以是任何传统的强化学习算法，同时还有一个通用的证明搜索器，证明搜索器持续地搜索二元组 (程序，证明） 直到对一个 程序 A，搜索到了一个 证明 B，表明：将搜索到的这个程序 A 直接用于修改 $p$ 后得到的程序的预期回报比修改前的 $p$ 更大。之后模型会使用 程序 A 对 $p$ 进行修改，这个修改不止对 $e$ 有效，同时可能影响到 $p$ 中的证明搜索器。\n\n## 自修改公理\n\n在 $t_1$ 时刻，我们使用搜索到的程序 A 来修改 $s(t_1)$ 当且仅当搜索到了证明 B，表示：$u[A(s(t_1)),Env(t_1)]>u[s(t_1),Env(t_1)]$。硬件状态 $s$ 包含了软件 $p$，用 $A(s(t_1))$ 表示用程序 A 对 $t_1$ 时刻的模型的软件进行学习。\n\n哥德尔机还需要引入大量其它的公理才能变得足够强，比如关于环境的公理，以及概率相关的公理。我们使用 $\\mathcal A$ 来表示一个足够强的哥德尔机的公理系统。\n\n## 哥德尔不完备定理\n\n我们说一个公理系统是一致的，当且仅当对任意命题 $P$，$P$ 和 非 $P$ 这两个命题不能同时在这个公理系统下被证明。\n\n哥德尔不完备定理指的是：任何一个公理系统，如果是一致的，并且能定义自然数，与自然数的加法，乘法和等于，则一定存在一个命题 $P$，$P$ 和 非 $P$ 在这个公理系统中不可证明。\n\n## 哥德尔机的局限性与优势\n\n哥德尔不完备性定理使得对任意一个足够强的公理系统，一定存在不可证的命题。哥德尔不完备定理不会导致哥德尔机弱，因为如果存在某个对哥德尔机有用的命题，但是这个命题在哥德尔机的公理系统下是不可证的，则对人而言，这个命题在同一个公理系统下也是不可证的，人也无法利用这个命题。\n\n哥德尔机更大的局限性在于，在现实环境中，时间和空间资源是有限的，如果哥德尔机的初始公理设计不够好，会导致即使其拥有极大量资源，也无法搜索出足量有效的自修改程序，导致花费了极大量的资源后还是一个低效的搜索器。\n\n哥德尔机需要引入大量的概率相关的公理，因为有限时间的观测只能产生有限的数据。有限的数据会导致任何证明都不能保证不会和后来的观测数据发生矛盾，所以只能给出证明的置信度，而不能保证证明一定正确。\n\n在一般的环境中，哥德尔机模型难以进行严格控制变量的实验，难以收集独立同分布的数据，难以短时间内发现环境在大时间尺度上的改变，这导致对概率的严格推断难以证明有用的结论，因此哥德尔机加入普通的概率公理可能也证明不出任何有用的东西。\n\n这样的问题导致哥德尔机不像是一个形式系统，不像一个证明搜索器，如果把初始的软件 $p$ 看做是一个模型初始的学习算法，自修改看做是学习，哥德尔机更像是一个程序搜索器。这种情况下，不一致或者过弱的公理系统对应一个不完备的初始学习算法，比如神经网络。\n\n哥德尔机的优势在于，哥德尔机可以对自己的初始算法进行任意的改动，并且现有的其它方法都无法做到这一点，比如神经网络无法学习自己的梯度下降学习法，有元学习的神经网络无法学习自己的元学习算法，搜索器无法学习自己的搜索策略等。这里的本质区别是哥德尔机的学习比这些模型强，强到可以完全复写掉初始的学习算法，而其它模型只能修改初始学习算法的一部分。\n\n# 6.全局最优性定理\n\n## 自修改公理与全局最优\n\n对任何形式化的奖励函数 $u$，假设哥德尔机公理 $\\mathcal A$ 是一致的，则任何自修改公理推出的自修改程序 $p$ 是全局最优的：在执行自修改 $p$ 之前哥德尔机的最大预期回报比执行 $p$ 之后的低。\n\n这里的自修改看上去像是一种贪心算法，每次贪心地向更优的方向改进，为什么是全局最优呢？我们可以证明满足自修改公理的程序 $p$ 是对当前哥德尔机的状态而言，所有可能的程序里最优的一个修改。\n\n证明的思路其实很简单，考虑搜索到 $p$ 后，哥德尔机可以采取的两种方案：\n\n1. 执行自修改程序 $p$。\n\n2. 不执行自修改程序 $p$，继续搜索其它程序执行。\n\n第二种方案考虑到了未来会搜索到的所有程序，而哥德尔机证明了第一种方案比第二种方案优，所以程序 $p$ 是在公理 $\\mathcal A$ 下，所有程序中最优的一个。\n\n在实践中，这里的最优性应该需要考虑搜索到每个程序的期望代价，比如存在一些自修改，效果比 $p$ 更好，但是搜索到这些自修改需要大量时间，或是执行了自修改 $p$ 后模型可以更快地搜索到其它自修改。也正是因为这些原因，所以哥德尔机证明了执行自修改 $p$ 后有更大的预期回报。\n\n## $O()$-最优性\n\n哥德尔机在任何任务上是 $O()$-最优 的，即与可以证明理论最优的解（如果存在）只在计算资源消耗上差常数倍。这是因为哥德尔机的初始算法即可保证搜索所有程序和证明是 $O()$-最优 的，哥德尔机是不可能比初始算法弱的，所以也是 $O()$-最优 的。\n\n$O()$-最优性 不是一个很强的性质，假设有一个问题，这个问题的最优解是 程序 A，则一个 $O()$-最优 的模型只需要花费常数的计算资源代价搜索到 程序 A，并且证明这个程序比之前模型给出的解优，就可以实现 $O()$-最优。比较两个证明搜索器时也是类似的，一个证明搜索器可以花费常数时间搜索到另一个并证明最优。\n\n$O()$-最优 的优化器需要一个极大的常数启动，这样的优化器最开始效果很差，需要搜索极长时间才可以变得足够强。我们认为这个过程和自然中的进化类似，并在后文讨论二者的相关性。\n\n# 7.bias-optimal searcher（给定先验下最优的搜索器）\n\nbias-optimal searcher（给定先验下最优的搜索器）的定义：\n\n给定先验概率 $P(p|r)$ 表示问题 $r$ 应该选取解 $p$ 的概率。\n\n黑盒函数可以在 $t(p,r)$ 的时间内判断问题 $r$ 是否有解 $p$。\n\nbias-optimal searcher 在有限时间 $T$ 内，对任意问题 $r$，如果有解 $p$ 满足 $t(p,r)\\le P(p|r)\\times T$ 则能求出问题的一个解。\n\nnear-bias-optimal searcher 则放宽条件到 $t(p,r)\\le P(p|r)\\times T/n$，$n>1$ 是近似比。bias-optimal searcher 有 Optimal Ordered Problem Solver 等已知的构造，这里不做相关解释。\n\n这里搜索器关心的是如何按给定先验分配计算资源，$p$ 可以是程序，$t$ 是程序运行用时。\n\n哥德尔机只需要使用一个 bias-optimal searcher 做为初始证明搜索器，则是 $O()$-最优 的，因为 bias-optimal searcher 是 $O()$-最优 的。\n\n# 8.哥德尔机的缺陷和相关讨论\n\n## 预测而不是证明\n\n考虑到有限的交互导致对环境认知的不确定性，从有限的与环境交互的历史中，不应该能证明无限长时间内可靠的环境性质。\n\n如果尝试构造一个比原有公理系统强的形式系统并用其进行证明，就无法证明新的形式系统的一致性，只能用有限的经验来支持这个新的形式系统是有用的（例如在发现矛盾前暂时正常使用）。\n\n如果尝试增加对环境的假设，那么加入这个假设可以得到新的形式系统，但这个假设不能用初始的公理系统证明，同上。\n\n从这个角度看，利用证明对环境进行推断，和一般的元学习是类似的。这里的证明其实不如说是一种基于已有数据对未来的预测。\n\n另一方面，形式系统可以证明一些关于无穷的命题，这些命题不能从有限的数据中得到，但可能产生可验证且有用的推论。\n\n如果这样的构造是有用的，初始学习算法应该能构造出这样的形式系统并用其进行证明，但不会认为形式系统是绝对可靠的。\n\n从这个角度看，形式系统和一般的程序是类似的。\n\n## 计算资源限制\n\n哥德尔机考虑的是理想环境，模型存活 $T$ 时间，最优化的是在存活的时间内奖励的和。\n\n### 有限存活时间\n\n有限存活时间会限制模型，导致模型无法到达全局最优。\n\n由于哥德尔机的低效性，从现实的角度看，我们认为目前可以提供的算力不够让哥德尔机优化到足够强，甚至无法搜索到任何一个可证明的改进。\n\n对于存活时间有限的情况，实际上哥德尔机很难在有限的数据下，给出对所有可能的环境在 $T$ 时刻内的收益期望，除非对环境有过强的假设。因为哥德尔机设计的最大预期回报需要对所有可能的环境，求出该环境出现的概率，并且加权计算出期望奖励。可能的环境有限显然是一个过强的假设，因为这会导致模型不图灵完备，退化成一个 DFA。而当可能的环境无限的情况下，无法在有限时间内计算这个期望。\n\n就算写出了满足文中描述特性的哥德尔机的代码，在对环境没有过强的假设下，因为预期回报不可计算，该哥德尔机在有限的计算资源下只会卡在第一步操作上，之后消耗光计算资源。或是有一些修改可以不需要计算预期回报，比如将 `a=a+1` 改写为 `++a`，但在对环境没有过强假设的情况下，哥德尔机很难证明一个稍微复杂的修改是更优的。\n\n### 无限存活时间\n\n无限存活时间会导致奖励函数失效，因为无限长的时间会导致奖励函数 $u(s,Env)=E_{\\mu} \\bigg [\\sum _{\\tau=time} ^\\infty r(\\tau)\\bigg | s,Env \\bigg ]$ 无界。两个期望无穷的预期奖励是不可比较的，这也是为什么已有强化学习方法都会设立奖励衰减因子，因为这样的方法可以让 每个状态的预期奖励 有界。无限存活时间还可能导致每个时刻的奖励 $r(\\tau)$ 也是无界的。\n\n对于存活时间无限的情况，模型实际上不能只优化奖励，还需要优化自己的存活和计算资源，因为如果需要人类提供无限的计算资源，则模型不能脱离人类，无法 \"消除人类的必要性\"。\n\n## 启动低效\n\n如果引入大量概率方面的先验进入公理系统，并且可以让预期回报可计算，哥德尔机还是会面临启动过于低效的问题。\n\n简单设计的通用方法，例如哥德尔机和其它一些 $O()$-最优 的证明搜索方法，通常需要非常长的时间后才能变得足够优。\n\n例如，解决特定任务的最优方法需要 $t$ 时间，但通用方法需要 $a+t\\times b$ 的时间，其中 $a$ 是极大的常数，我们将其定义为：**启动常数**，用于在启动阶段找出这个最优方法，$b$ 是模拟执行这个最优方法的常数代价（这个一般不严重，合理假设下可以做到 $b=1$）。\n\n为了得到实用的通用方法，主要的设计复杂性在于降低启动常数 $a$。\n因此，需要首先构造一个简单的通用方法，允许较大的启动常数 $a$；然后，通过具体设计来降低 $a$。\n\n### 进化\n\n进化是一种自然地生成任意复杂的结构的过程。进化生成的生物也可以通过影响环境从而在环境中生成任意复杂的结构。进化的过程和已知的优化过程区别很大，已知的优化过程都有明确的目的性，如神经网络方法通过梯度下降优化模型的 loss，强化学习方法优化模型的最大预期回报等。进化没有在优化任何预设的目标，可以从两个不同的角度看待进化：\n\n1. 进化是一个在确定规则下沿时间轴演化的动力系统。进化没有任何目的性，但是可以生成任意复杂的结构。在这个角度下，我们可以认为没有智能体，只有一个不断演化的环境，但是环境的演化足够复杂，使得其中可以生成任意复杂的结构，如生命游戏。从一些例子中可以看到进化的复杂性，如：如何才能在宇宙中生成一块会飞的金块？进化先在环境中生成了人类，然后人类制作了旅行者号探测器，里面携带了一块人类制作的纯金的碟片，而这其中人类以及金的生成如果展开来讲也是一个极其复杂的过程。遗传算法之所以不是进化，也是因为遗传算法无法在环境中构建任意复杂的结构，并且遗传算法无法模拟生物之间复杂的交互作用。\n\n2. 进化是智能体不断和环境交互的过程：其中进行计算或和环境交互会减少自己的计算资源，可以从环境中获取计算资源。当智能体计算资源为 $0$ 时死亡，需要优化自己存活时间。智能体和环境的边界不可区分。智能体可以将除了自己以外的其它智能体也视为环境的一部分，对其它智能体的建模，如博弈论之类的方法，是将这些智能体看做是环境中比较容易预测的一部分，并研究这一部分环境相关的特性。从这里可以看出智能体和环境是不可区分的，智能体在环境中的边界是模糊的，例如：人吃环境中的饭，吃下去的饭是否属于人的一部分；人是否是环境中人的种群的一部分；人造出了机器人，机器人是人通过对环境进行操作后得到的，是否属于人的一部分。\n\n人类是经过了极长时间进化后产生的复杂结构，如果将进化看做是生成通用人工智能的方法，则进化像生成一块会飞的金块一样生成通用人工智能：通过先生成人类后生成这些复杂结构。生成人类的过程就是上述的极大的启动常数 $a$，通过对模型引入合适的人为设计的先验，同时不破坏完备性，这样应该可以得到一个只需要较小启动的常数，便可以在绝大部分任务上达到较优的通用人工智能。\n\n### 神经网络不完备\n\n神经网络是对模型引入人为设计的先验，但是破坏了完备性的一个例子。完备性被破坏导致神经网络不能通用地解决所有问题，但是可以以很低的启动常数解决一些特定的问题。\n\n神经网络不完备指的是：\n\n1. 搜索的计算图受限。神经网络搜索的是一类比较静态的计算图，虽然有一些动态的尝试，如 MoE 类的方法，Transformer 稀疏化，外置内存类的方法（类似神经图灵机），但是能搜索到的程序空间依然受限。神经网络虽然是图灵完备的，但是静态计算图会导致计算低效，如使用 Transformer 模型计算乘法需要做很长的自回归，输出乘法的中间结果，而实际上的乘法只需要很小的计算量即可完成。神经网络由于其结构固定，无法通过搜索来对结构进行改进。关于神经网络架构搜索（元学习）相关的内容会在后文讨论。\n\n2. 无法遍历状态空间。常见的梯度下降方法都需要让学习率逐步下降，否则训练无法收敛，这样会导致每次随机初始化后模型只能探索到状态空间中很小的一部分。更好的一种神经网络类方法是随机初始化大量神经网络，将其均训练到收敛，之后用于测试时，对这些神经网络的结果取平均或最大似然。这样可以降低模型的方差，因为可以更广泛地探索状态空间。\n\n3. 元学习能力受限。朴素的神经网络方法基于梯度下降，每一步的学习率确定，没有元学习能力。而有元学习特性的神经网络也只是对梯度下降的参数进行学习，甚至无法比较大地修改自己的学习算法。神经网络方法对已知形式的问题效果不错，因为加入了大量专门解决这类问题的人为设计的 trick。但是元学习对应的问题是未知的，神经网络学习能力受限会导致其无法对这些未知结构的问题进行好的学习，而无法对元学习进行好的学习会导致神经网络能力学习更受限。\n\n现在研究神经网络的算法工程师们希望通过神经网络实现通用人工智能，并且一直在设计更为通用的模型，但是我们认为这样的方式是不合理的。\n\n试想一个 Transformer 模型，为了优化平方代价的 attention，假设实现了一种优秀的 attention 策略，该策略允许我们每次只访问 $O(1)$ 个位置的 attention，就可以获取原本需要 $\\Theta(n)$ 个位置的 attention 才能获得的信息。假设这样的 Transformer 模型学到了正确的硬的内存访问，并且训练和测试不分离，也就是说模型的训练方式也是强的，不局限于梯度下降，不会发生灾难性遗忘，并且可以常数代价模拟任何动态计算图，则这样的模型是通用人工智能。\n\n这个模型中神经网络的部分则会退化为一个 for，因为 Transformer 是一个一直增长的函数式内存，每次只需要做常数规模的计算，并且从内存中取出 $O(1)$ 个位置的信息，并写下 $O(1)$ 的信息，真正的复杂性转移到了该如何设计优秀的 attention 策略，以及如何训练上。\n\n我们认为自动数学证明和自动代码生成是足够复杂的任务，在这两个任务上远远超越人类表现的模型应该可以像哥德尔机一样，探索可能有效的改进，并且通过证明以及自编程来修改自己。\n\n最近神经网络类方法取得了很好的进展，如 AI 绘画，AlphaCode，ChatGPT，DreamerV3 等，以我们的知识，我们认为他们无法通过神经网络实现通用人工智能，因为所有这一切模型的学习算法都是本质性地弱的，并且难以改进。\n\n希望本文中给出的推理有误，他们可以实现通用人工智能，实现无数人梦寐以求的技术。\n\n## 什么是好的？\n\n如果对通用人工智能，可以给出定义和证明特定实现的正确性，则可以用证明搜索器来搜索和使用通用人工智能的实现，这个证明搜索器就是一个通用人工智能的实现，搜索器搜索到通用人工智能所需的时间是一个极大的常数，这个常数是证明搜索器做为通用人工智能的启动常数的一部分。\n\n但在搜索出来之前，并不知道存在某种具体实现是能证明正确性的，这里需要注意，可能能证明存在性，但不能对任意一个实例证明它是存在性的实例。\n\n给出的形式定义也依赖人的经验，不保证正确性；如果形式定义有误，需要人发现和修改，无法 \"消除人类的必要性\"。\n\n基于永久存活的定义中，由于我们对环境特性不够了解，以及判断永久存活需要无限长时间的观测，通用人工智能的存在性和正确性很可能是不可证的，而基于理想环境中优化长期奖励的定义看起来更容易证明。\n\n对于哥德尔机而言，通用人工智能的复杂性转移到了判断什么样的修改在未来对自己有利，也就是 \"什么样的修改是好的？\"，其余部分的设计都是比较平凡的。我们认为哥德尔机的问题也在于没解决这个问题，靠一个初始公理系统去直接证明修改后的模型比修改前的模型能获得更大的预期回报，这样的设计过于低效，甚至不一定正确，因为文章没有给出一个可以计算在所有环境中期望预期回报的公理系统的具体实现。\n\n如果我们知道了如何判断什么是好的，则由全局最优性定理，只需要一个保证完备性的搜索所有可能的程序的证明搜索器（探索机制），再判断修改是不是好的，如果是好的则应用该修改（学习机制），就可以实现通用人工智能。\n\n# 9. Q.A.\n\n1. Q：形式化证明是否在现实世界中有意义？\n\n\tA：有意义，你需要将不确定性以及概率方面的公理，以及现实世界的性质引入哥德尔机。\n\n2. Q：哥德尔机会不会使用一个自毁的自修改？哥德尔机会不会直接通过修改自己的奖励函数获得巨大的奖励？\n\n\tA：哥德尔机只会证明一个自修改会增加当前的奖励函数下的最大预期奖励时才会使用。如果哥德尔机的自修改可能导致自毁，则这里使用了概率相关的公理，模型有概率自毁，有概率获得更大的预期奖励。如果哥德尔机修改了自己的奖励函数，则使用新的奖励函数一定可以增加模型原有的奖励函数下的最大预期奖励。\n\n3. Q：自动证明非常难，哥德尔机该如何工作？\n\n\tA：现在人类工作大量使用自动证明搜索器，因为证明和程序是等价的，所以神经网络也可以看做是一种证明搜索器。这些已有的证明搜索器基本上都不是 $O()$-最优的，他们是设计来处理具体任务的，在具体任务上有较小的启动常数，但是在设计范围外的任务上可能需要无限大的启动常数。\n\n4. Q：\"没有免费的午餐定理\" 是否说明不存在通用的问题求解器？\n\n\tA：不是，\"没有免费的午餐定理\" 构造了一种特殊的问题，这种问题中数据有歧义，通常处理的问题都不会有这样差的性质。这种问题上人类也无法取得好的表现。\n\n# 10.结论\n\n模型的自进步性一直被认为是重要的，如图灵 [2] 发现与其花费极大量的计算资源去设计成千上万个功能性模块，不如直接设计一个人类婴儿，让其在环境中学习，这样的性质就是自进步性 [3]，也就是学习。学习的重要性是显而易见的，随着环境变化，模型如果无法学习，则一定会被环境淘汰。如果通过一直修改人工智能的功能模块来实现通用人工智能，则需要人类永远存活。\n\n之后科学家发现，学习算法的好坏是显著影响模型效果的，神经网络从最初算力要求过大，被支持向量机等模型打败，经过算力以及模型结构，训练 trick 等进步，变成目前最广泛使用的模型。但我们认为神经网络模型的学习算法是本质弱的，通用人工智能需要一个足够强的学习算法。对这个学习算法而言，与其花费极大量计算资源去直接设计这个学习算法，不如直接设计一个通用的元学习。\n\n但是现在人工智能方面的研究反而不追求通用性，很多模型是针对具体任务设计的，无法在其他任务上工作，剩下一些模型虽然可以将任何输入输出内容转化为序列，通过序列预测来通用地解决任务，但这些模型没有足够的元学习能力，无法学习到一个足够复杂的学习算法，因此无法解决非平凡的任务，如程序生成，自动证明等。现在针对通用模型的研究主要都在通过加 trick 的方式提高模型表现，比如使用更高质量的数据，使用人的评价来强化学习（RLHF）等。我们认为这些 trick 对类似哥德尔机的通用人工智能也是有帮助的，可以降低模型的启动常数，但是使用这些 trick 去增强一个不完备的模型（如神经网络）是不合理的，应该先设计出完备的模型，后使用这些 trick 去训练完备的模型。\n\n哥德尔机是一个有不分层元学习设计的模型，是 $O()$-最优 的学习算法，但我们认为哥德尔机的设计并没有完全解决通用人工智能的复杂性，因为其启动常数过高，同时公理系统 $\\mathcal A$ 的设计非平凡但作者未给出。尽管如此，我们依然认为哥德尔机是一个非常有意义的模型，是人工智能的重要里程碑。\n\n不分层的元学习模型虽然不会遇到分层中的那些问题，但是会将复杂性全部转移到学习中。学习不只是需要对我们已有的任务和数据进行学习，还需要对模型学习过程中生成的任意复杂的结构进行学习。解决了学习的问题等价于写出了通用人工智能的代码，而学习的问题在于什么是好的，如果模型可以判断什么是好的，则可以选择对自己有利的修改，逐步变强。\n\n到底什么是好的呢？小编也很想知道。目前我们只有几个比较模糊的设计，并且补全细节后也不能完全解决这个问题。\n\n# 11.摇人\n\n大家如果对相关内容感兴趣，可以加群：756872300 来讨论。\n\n# 12.引用\n\n[1] Jürgen Schmidhuber (2006). Goedel Machines: Self-Referential \nUniversal Problem Solvers Making\nProvably Optimal Self-Improvements https://arxiv.org/pdf/cs/0309048v5.pdf\n\n[2] Turing, A. M. (1950). Computing machinery and intelligence. Mind, 59, 433–460. https://doi.org/10.1093/mind/LIX.236.433\n\n[3] McCarthy, J., Minsky, M. L., Rochester, N. & Shannon, C. E. (1955). A PROPOSAL FOR THE DARTMOUTH SUMMER RESEARCH PROJECT ON ARTIFICIAL INTELLIGENCE http://www-formal.stanford.edu/jmc/history/dartmouth/dartmouth.html .", "description": "由于你不会设计哥德尔机，所以你决定先做一道数据结构题：\n\n给定一个长度为 $n$ 的序列 $a_1\\cdots a_n$。你需要回答 $m$ 个询问，第 $i$ 个询问给定一个区间 $[l_i,r_i]$，请你求出这个区间中所有非空子集的最大公约数的乘积。由于答案可能很大，每次询问请你求出其对 $998244353$ 取模的结果。", "inputFormat": "第一行两个正整数 $n,m$，含义同题目描述。\n\n接下来一行 $n$ 个正整数描述序列 $a_1\\cdots a_n$。\n\n接下来 $m$ 行，第个 $i$ 行是 $l_i,r_i$，描述第 $i$ 个询问。", "outputFormat": "输出 $m$ 行，对于每个询问输出询问答案对 $998244353$ 取模的结果。", "hint": "Idea：ouuan&lk，Solution：ccz181078，Code：ouuan&lk，Data：ouuan&lk\n\n对于 $10\\%$ 的数据，满足 $n,m\\le10$。\n\n对于另外 $10\\%$ 的数据，满足 $n,m\\le1000$。\n\n对于另外 $20\\%$ 的数据，满足 $1\\le a_i\\le1000$。\n\n对于另外 $10\\%$ 的数据，满足对所有 $1\\le i<n$，$l_i\\le l_{i+1}\\le 10^5$ 且 $r_i\\le r_{i+1}\\le 10^5$\n\n对于另外 $20\\%$ 的数据，满足 $1\\le a_i\\le30000$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m,a_i\\le 10^5$，$1\\le l_i\\le r_i\\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2002] Goedel Machine", "background": "# 1.前言\n\n哥德尔机 [1] 是由 LSTM 之父 Jürgen Schmidhuber 提出的一种可学习的通用问题求解器。本文将对该模型进行描述与讨论，并且说明这个模型拥有许多重要的性质，这些性质是我们认为通用人工智能所必需的。\n\n# 2.相关概念\n\n## 学习\n\n学习指模型对模型自身的参数（同一个模型在参数不同时有不同的行为）进行修改。用于对自己进行修改的方法叫做学习算法。\n\n## 元学习\n\n元学习指模型拥有通过学习修改自己的学习算法的能力。有大量证据指示人类拥有比较强的元学习的能力。\n\n### 元学习分层\n\n不可学习的方法没有学习能力，比如解决 OI 题的程序，坦克世界的固定线路看到人就停车的脚本等。\n\n常见的机器学习方法，比如朴素的神经网络方法没有元学习能力，因为学习算法是不可学习的梯度下降算法。支持向量机没有元学习能力，因为学习算法是确定的，等。\n\n专门设计了元学习特性的神经网络有元学习能力，但是没有元元学习能力，也就是说不能对学习自己学习算法的算法进行学习。\n\n假设你想设计一种学习算法：\n\n初始时，你想让你的算法可学习，于是设计了初始的学习算法。\n\n然后你想让你的初始学习算法可学习，于是设计了元学习算法。\n\n然后你想让你的元学习算法可学习，于是设计了元元学习算法。\n\n这样每一步你都必须设计新的学习算法，用于之前的学习算法的学习。设计第 $i$ 层的学习算法时，这个学习算法可以优化前 $i-1$ 层，但是对第 $i$ 层的优化需要第 $i+1$ 层后的方法。分层不是必需的，这里分层是人为设计的，因为你人为设计了分层结构，所以你需要设计无限层的元学习算法。\n\n一直这样递归下去可以发现现有机器学习方法的一个问题：因为不能人工设计无限层的元学习算法，所以在某一层之后一定不可学习。这样会导致人工设计可以一直让模型变强，因为设计了第 $i$ 层元学习的模型不会比只设计了前 $i-1$ 层元学习的模型弱，但是这个过程永不收敛。这样的模型不具备一种**不可改进性**，即在给定足量的计算资源下，这个模型是最优的。\n\n哥德尔机以及类似的构造尝试将所有层级的元学习用同一个东西去泛化，将任意层的元学习问题变成一层普通的学习问题。要实现这样的功能，我们需要一个足够强的优化器。弱的优化器，比如梯度下降的神经网络，面临的问题是无法使用梯度下降去优化模型梯度下降的过程，也就是说无法直接用学习算法去处理元学习层面的优化。于是元学习特性需要人为设计，也就是说需要设计优化元学习任务的优化器，而这样会导致该优化器无法用已设计好的方法优化，需要继续设计新的对应的优化算法。这样分层的元学习需要无限的设计，是神经网络方法最大的问题之一。\n\n### 不分层元学习/无限层元学习\n\n哥德尔机没有元学习分层的设计，因为其架构会将所有优化问题用同样的方法优化，并且该优化方法可以优化自身，所以哥德尔机拥有不分层的元学习能力，或者可以叫做无限层元学习的能力。在给定足量的计算资源下，哥德尔机不弱于任何其它可计算的机器学习模型。\n\n实际上存在一些元学习算法是递归的，即存在一种元学习算法，第 $i$ 层可以对前 $i-1$ 层进行优化，且对任意 $i$，这个算法都是相同的，所以只需要有限的人为设计。我们认为这类方法是有一些问题的，不如不分层的元学习算法，这里不展开讨论。\n\n元学习和学习实际上不可区分，这个会在后续进行讨论。\n\n## 强化学习\n\n模型与环境交互并优化由环境提供的奖励。\n\n### 马尔可夫决策过程\n\n时间被分为一些离散的时间步，模型每个时刻从环境中获取输入信息（包括环境提供的奖励），并能从有限种对环境的操作中选一部分执行，环境由这一时刻的状态以及模型采取的操作计算出环境下一时刻的状态。\n\n## 通用人工智能/完全人工智能/人工广义智能\n\n这些词语是 Artificial General Intelligence 的中文翻译，该词语代表一个可以在各个领域达到人类顶尖水平甚至超越的人工智能模型。\n\n通用人工智能**没有准确的定义**，不同人对通用人工智能应该有什么样的能力看法不同。\n\n## 自编程/自修改/自进步\n\n这三个词语指模型的一种能力，有这种能力的模型可以通过修改自己来提升自己的表现。一般提升表现指可以在监督学习任务中通过更多的数据，或在强化学习任务中获得更大的预期奖励。\n\n## 自指\n\n一个模型是完全自指的，表示某个模型可以在内部描述自己的所有性质。虽然人类不是一个完全自指的模型，但是人类可以描述关于自己的部分性质。\n\n自指常用于构建悖论，如：\n\n1. \"这句话是错的\" 是对的还是错的？\n\n2. 罗素悖论：一个理发师只给不理自己头发的人理发，那这个理发师是否给自己理发？\n\n3. 停机问题：一个图灵机如果判定出自己停机，则不停机。\n\n4. 哥德尔不完备性定理。\n\n哥德尔机是一个可以完全自指的模型。哥德尔机的作者认为 \"意识\" 的本质是自指，即模型可以意识到自己的存在。哥德尔机的学习算法可以完全自指，也就是说可以用学习算法处理学习算法的学习，甚至完全覆写掉初始的学习算法。\n\n## 可计算性\n\n程序在不限制空间并且不限制字长时，能在有限时间内完成处理的问题是可计算的问题所构成的集合。\n\n## 图灵机\n\n本文中我们直接把 图灵机 当成 C++ 语言写成的代码，不限制空间并且不限制字长。\n\n### 通用图灵机\n\n用 C++ 语言显然可以模拟执行 C++ 语言。假设我们写出了一份 C++ 语言代码 A，用于执行任何其它 C++ 语言写出的代码。则当我们想执行 C++ 代码 B 时，可以将 B 做为 A 的输入，并执行 A。这样的代码 A 叫做 通用图灵机。\n\n## 不可区分性\n\n有许多人类设计的分层结构是不可区分的，如：\n\n1. 数据与程序不可区分：这里我们顺便解释中文房间悖论。中文房间指给定一个黑箱，将一个不会中文的人和一个翻译器一起放入。在房间外的人向内部提供中文文章，内部的人将文章输入翻译器后直接得到翻译后的结果，并将结果输出，此时从外部看来，无法判定内部的人是否会中文。这个悖论实际上等价于：现在有一个通用图灵机，以及一份通用人工智能的代码。如果我们将通用图灵机看做模型（程序），将通用人工智能看做数据进行执行（对于通用图灵机而言，一个图灵机的程序可以是数据，并且做为数据的程序可以被执行），则这里可以认为这个通用图灵机在给定数据下是一个通用人工智能。也就是说我们可以将非平凡的部分：通用人工智能，在程序和数据两边任意转移，但必须在某一边解决这个本质问题。\n\n2. 监督学习的数据和模型的先验（初始引入的知识）不可区分，强化学习的人类知识和模型的 reward 不可区分：监督学习模型的 loss 函数可以内嵌任意复杂的信息，包括数据集中的所有信息，这种情况下模型的 loss 是模型的先验的一部分。强化学习模型 reward 函数可以内嵌任意复杂的信息，包括关于环境的先验，以及人类知识。如 AlphaGo 算法中使用了 MCTS 搜索算法做为探索先验，这样的先验（搜索）就是一种人类知识。\n\n3. 模型关于自己的先验与模型关于环境的先验不可区分：这个在后续会进行讨论。\n\n4. 学习和元学习不可区分：假设模型分为学习算法和模型主体部分，学习算法经过学习后被修改了，则这里可以看做是元学习。但如果将整个模型做为一个整体来看待，学习实际上改变了模型的一些参数，是普通的学习。从学习和元学习不可区分也可以看出对元学习人为分层是不自然的，应该将元学习的优化视为普通学习处理。\n\n由于不可区分性，一般来说我们用功能而不是具体的结构来衡量模型的能力。比如对于中文房间悖论，可以认为一个有翻译器的人类就是懂得中文的，因为和懂得中文的人表现一致，一个没有翻译器的人类是不懂得中文的。\n\n同理，由于不可区分性，对于“理解”和“意识”的讨论都是无意义的，因为我们用功能而不是具体的结构来衡量模型的能力。\n\n# 3.简介\n\n几乎所有已知的用于解决问题的算法（包括证明搜索器，监督学习，强化学习等）都在元学习方面有欠缺，理由在元学习分层中有描述。人类需要一直不断地设计新的更好的算法（有更多层元学习的算法），并且提供计算资源对这些算法进行测试。\n\n如何才能消除人类的必要性？为了方便描述，我们定义了学习，学习指模型对模型自身的参数进行修改。对自己进行修改的方法叫做学习算法。最简单的想法就是让机器可以进行任意复杂的学习，也就是说学习方法需要足够强，比如从所有可计算的程序中选出一个最高效的学习算法，利用这个学习算法修改自己。\n\n为了解决这个问题，作者设计了一类最优的，完全自指的，通用的问题求解器——哥德尔机。哥德尔机与一个部分可观测的环境交互，并且原则上可以无限制地修改自身（学习），唯一的限制是哥德尔机自己的可计算性。哥德尔机的初始算法有能力完全重写自己，这样的重写能力保证哥德尔机是全局最优的。\n\n## 哥德尔机的结构\n\n哥德尔机主要包含公理系统、证明搜索程序、行为程序、目标函数。\n\n# 4.环境和形式化目标\n\n模型的环境处在一个人为设计的硬件中，该硬件可以是通用图灵机，空间有限的图灵机，或抽象的电子计算机。模型是单例的，只有唯一一个同时存在。模型的生命包含一些离散的时间步：$1,2,\\dots$，模型的生命在 $T$ 时刻结束，这个时刻可能对模型而言不可见。任何一个时变的变量 $Q$ 在 $t$ 时刻的值可以记作 $Q(t)$。\n\n每一步时间我们的硬件执行一个基本操作，改变硬件的状态 $s$，为不失一般性，$s\\in \\mathcal S \\in B^*$，$B^*$ 表示所有可能的二进制串。每一步时间环境状态可能发生变化，环境状态用 $Env$ 表示，$Env\\in \\mathcal E$，$\\mathcal E$ 表示考虑的环境的集合，这个会在后续进行讨论。硬件有硬编码的转移方程：$F:\\mathcal S\\times \\mathcal E \\rightarrow \\mathcal S$。对任何 $t>1$，$s(t)=F(s(t-1),Env(t-1))$ 表示当前 $t-1$ 个时刻都结束后，$t$ 时刻还没开始时硬件的状态。\n$Env(t)$ 表示 $t$ 时刻的环境，由 $s(t-1)$ 中描述环境变化的变量与环境交互得到，如果环境是随机的，则这里按对应概率进行采样。\n\n定义四个特殊的变量：$time,x,y,p$：\n\n1. $time$ 表示当前时刻。\n2. $x$ 表示环境对哥德尔机的输入，对任意 $t>1$，$x(t)\\neq x(t-1)$ 可能发生当且仅当哥德尔机输出了一个特定字符串，表示向环境请求输入。这样就可以避免每个时刻只有常数的计算资源，导致不能对输入完全观测（比如复制整个输入所需的计算资源比每个时刻的计算资源多）。\n3. $y$ 表示哥德尔机对环境的输出，$y(t)$ 表示一个二进制串。输出可能对环境产生影响，比如输出一个控制指令，指令操作环境中的一个机器人，或者指令打开电视机。\n4. $p(1)$ 表示最初哥德尔机的软件，也就是根据环境输入计算出对环境输出的计算过程。初始的 $p(1)$ 可以用一个图灵机表示，所以不是最优的。\n\n每一个时刻 $1\\le t\\le T$ 模型的目标是最大化预期回报。对于一个确定的 $s$ 和 $Env$，奖励函数可以写做：$u(s,Env):\\mathcal S\\times \\mathcal E\\rightarrow \\mathcal R$，$u(s,Env)=E_{\\mu} \\bigg [\\sum _{\\tau=time} ^T  r(\\tau)\\bigg | s,Env \\bigg ]$，其中 $\\mathcal R$ 表示实数，$r(t)$ 表示 $t$ 时刻获得的实数表示的奖励。$E_{\\mu}\\big(\\cdot \\big|\\cdot\\big)$ 表示条件期望，其中 $\\mu$ 表示所有可能的环境。\n\n这里需要注意到 $s$ 表示的也是模型的内环境，因为硬件行为完全由模型决定，$Env$ 表示外部环境，$time=time(s)$ 表示 $s$ 状态所在时刻。\n\n可以同时修改奖励函数使得模型倾向于选择更低方差的改进。绝大部分计算机科学的问题都可以用这个设计形式化。\n\n# 5.哥德尔机的基本思想\n\n为了让我们的硬件变成一个有自指能力的哥德尔机，需要设计对应的软件（也就是可运行代码） $p$，该软件需要有修改自己的能力。初始的代码 $p(1)$ 有一个目前不是最优的问题求解器 $e(1)$，用于和环境交互，这个问题求解器可以是任何传统的强化学习算法，同时还有一个通用的证明搜索器，证明搜索器持续地搜索二元组 (程序，证明） 直到对一个 程序 A，搜索到了一个 证明 B，表明：将搜索到的这个程序 A 直接用于修改 $p$ 后得到的程序的预期回报比修改前的 $p$ 更大。之后模型会使用 程序 A 对 $p$ 进行修改，这个修改不止对 $e$ 有效，同时可能影响到 $p$ 中的证明搜索器。\n\n## 自修改公理\n\n在 $t_1$ 时刻，我们使用搜索到的程序 A 来修改 $s(t_1)$ 当且仅当搜索到了证明 B，表示：$u[A(s(t_1)),Env(t_1)]>u[s(t_1),Env(t_1)]$。硬件状态 $s$ 包含了软件 $p$，用 $A(s(t_1))$ 表示用程序 A 对 $t_1$ 时刻的模型的软件进行学习。\n\n哥德尔机还需要引入大量其它的公理才能变得足够强，比如关于环境的公理，以及概率相关的公理。我们使用 $\\mathcal A$ 来表示一个足够强的哥德尔机的公理系统。\n\n## 哥德尔不完备定理\n\n我们说一个公理系统是一致的，当且仅当对任意命题 $P$，$P$ 和 非 $P$ 这两个命题不能同时在这个公理系统下被证明。\n\n哥德尔不完备定理指的是：任何一个公理系统，如果是一致的，并且能定义自然数，与自然数的加法，乘法和等于，则一定存在一个命题 $P$，$P$ 和 非 $P$ 在这个公理系统中不可证明。\n\n## 哥德尔机的局限性与优势\n\n哥德尔不完备性定理使得对任意一个足够强的公理系统，一定存在不可证的命题。哥德尔不完备定理不会导致哥德尔机弱，因为如果存在某个对哥德尔机有用的命题，但是这个命题在哥德尔机的公理系统下是不可证的，则对人而言，这个命题在同一个公理系统下也是不可证的，人也无法利用这个命题。\n\n哥德尔机更大的局限性在于，在现实环境中，时间和空间资源是有限的，如果哥德尔机的初始公理设计不够好，会导致即使其拥有极大量资源，也无法搜索出足量有效的自修改程序，导致花费了极大量的资源后还是一个低效的搜索器。\n\n哥德尔机需要引入大量的概率相关的公理，因为有限时间的观测只能产生有限的数据。有限的数据会导致任何证明都不能保证不会和后来的观测数据发生矛盾，所以只能给出证明的置信度，而不能保证证明一定正确。\n\n在一般的环境中，哥德尔机模型难以进行严格控制变量的实验，难以收集独立同分布的数据，难以短时间内发现环境在大时间尺度上的改变，这导致对概率的严格推断难以证明有用的结论，因此哥德尔机加入普通的概率公理可能也证明不出任何有用的东西。\n\n这样的问题导致哥德尔机不像是一个形式系统，不像一个证明搜索器，如果把初始的软件 $p$ 看做是一个模型初始的学习算法，自修改看做是学习，哥德尔机更像是一个程序搜索器。这种情况下，不一致或者过弱的公理系统对应一个不完备的初始学习算法，比如神经网络。\n\n哥德尔机的优势在于，哥德尔机可以对自己的初始算法进行任意的改动，并且现有的其它方法都无法做到这一点，比如神经网络无法学习自己的梯度下降学习法，有元学习的神经网络无法学习自己的元学习算法，搜索器无法学习自己的搜索策略等。这里的本质区别是哥德尔机的学习比这些模型强，强到可以完全复写掉初始的学习算法，而其它模型只能修改初始学习算法的一部分。\n\n# 6.全局最优性定理\n\n## 自修改公理与全局最优\n\n对任何形式化的奖励函数 $u$，假设哥德尔机公理 $\\mathcal A$ 是一致的，则任何自修改公理推出的自修改程序 $p$ 是全局最优的：在执行自修改 $p$ 之前哥德尔机的最大预期回报比执行 $p$ 之后的低。\n\n这里的自修改看上去像是一种贪心算法，每次贪心地向更优的方向改进，为什么是全局最优呢？我们可以证明满足自修改公理的程序 $p$ 是对当前哥德尔机的状态而言，所有可能的程序里最优的一个修改。\n\n证明的思路其实很简单，考虑搜索到 $p$ 后，哥德尔机可以采取的两种方案：\n\n1. 执行自修改程序 $p$。\n\n2. 不执行自修改程序 $p$，继续搜索其它程序执行。\n\n第二种方案考虑到了未来会搜索到的所有程序，而哥德尔机证明了第一种方案比第二种方案优，所以程序 $p$ 是在公理 $\\mathcal A$ 下，所有程序中最优的一个。\n\n在实践中，这里的最优性应该需要考虑搜索到每个程序的期望代价，比如存在一些自修改，效果比 $p$ 更好，但是搜索到这些自修改需要大量时间，或是执行了自修改 $p$ 后模型可以更快地搜索到其它自修改。也正是因为这些原因，所以哥德尔机证明了执行自修改 $p$ 后有更大的预期回报。\n\n## $O()$-最优性\n\n哥德尔机在任何任务上是 $O()$-最优 的，即与可以证明理论最优的解（如果存在）只在计算资源消耗上差常数倍。这是因为哥德尔机的初始算法即可保证搜索所有程序和证明是 $O()$-最优 的，哥德尔机是不可能比初始算法弱的，所以也是 $O()$-最优 的。\n\n$O()$-最优性 不是一个很强的性质，假设有一个问题，这个问题的最优解是 程序 A，则一个 $O()$-最优 的模型只需要花费常数的计算资源代价搜索到 程序 A，并且证明这个程序比之前模型给出的解优，就可以实现 $O()$-最优。比较两个证明搜索器时也是类似的，一个证明搜索器可以花费常数时间搜索到另一个并证明最优。\n\n$O()$-最优 的优化器需要一个极大的常数启动，这样的优化器最开始效果很差，需要搜索极长时间才可以变得足够强。我们认为这个过程和自然中的进化类似，并在后文讨论二者的相关性。\n\n# 7.bias-optimal searcher（给定先验下最优的搜索器）\n\nbias-optimal searcher（给定先验下最优的搜索器）的定义：\n\n给定先验概率 $P(p|r)$ 表示问题 $r$ 应该选取解 $p$ 的概率。\n\n黑盒函数可以在 $t(p,r)$ 的时间内判断问题 $r$ 是否有解 $p$。\n\nbias-optimal searcher 在有限时间 $T$ 内，对任意问题 $r$，如果有解 $p$ 满足 $t(p,r)\\le P(p|r)\\times T$ 则能求出问题的一个解。\n\nnear-bias-optimal searcher 则放宽条件到 $t(p,r)\\le P(p|r)\\times T/n$，$n>1$ 是近似比。bias-optimal searcher 有 Optimal Ordered Problem Solver 等已知的构造，这里不做相关解释。\n\n这里搜索器关心的是如何按给定先验分配计算资源，$p$ 可以是程序，$t$ 是程序运行用时。\n\n哥德尔机只需要使用一个 bias-optimal searcher 做为初始证明搜索器，则是 $O()$-最优 的，因为 bias-optimal searcher 是 $O()$-最优 的。\n\n# 8.哥德尔机的缺陷和相关讨论\n\n## 预测而不是证明\n\n考虑到有限的交互导致对环境认知的不确定性，从有限的与环境交互的历史中，不应该能证明无限长时间内可靠的环境性质。\n\n如果尝试构造一个比原有公理系统强的形式系统并用其进行证明，就无法证明新的形式系统的一致性，只能用有限的经验来支持这个新的形式系统是有用的（例如在发现矛盾前暂时正常使用）。\n\n如果尝试增加对环境的假设，那么加入这个假设可以得到新的形式系统，但这个假设不能用初始的公理系统证明，同上。\n\n从这个角度看，利用证明对环境进行推断，和一般的元学习是类似的。这里的证明其实不如说是一种基于已有数据对未来的预测。\n\n另一方面，形式系统可以证明一些关于无穷的命题，这些命题不能从有限的数据中得到，但可能产生可验证且有用的推论。\n\n如果这样的构造是有用的，初始学习算法应该能构造出这样的形式系统并用其进行证明，但不会认为形式系统是绝对可靠的。\n\n从这个角度看，形式系统和一般的程序是类似的。\n\n## 计算资源限制\n\n哥德尔机考虑的是理想环境，模型存活 $T$ 时间，最优化的是在存活的时间内奖励的和。\n\n### 有限存活时间\n\n有限存活时间会限制模型，导致模型无法到达全局最优。\n\n由于哥德尔机的低效性，从现实的角度看，我们认为目前可以提供的算力不够让哥德尔机优化到足够强，甚至无法搜索到任何一个可证明的改进。\n\n对于存活时间有限的情况，实际上哥德尔机很难在有限的数据下，给出对所有可能的环境在 $T$ 时刻内的收益期望，除非对环境有过强的假设。因为哥德尔机设计的最大预期回报需要对所有可能的环境，求出该环境出现的概率，并且加权计算出期望奖励。可能的环境有限显然是一个过强的假设，因为这会导致模型不图灵完备，退化成一个 DFA。而当可能的环境无限的情况下，无法在有限时间内计算这个期望。\n\n就算写出了满足文中描述特性的哥德尔机的代码，在对环境没有过强的假设下，因为预期回报不可计算，该哥德尔机在有限的计算资源下只会卡在第一步操作上，之后消耗光计算资源。或是有一些修改可以不需要计算预期回报，比如将 `a=a+1` 改写为 `++a`，但在对环境没有过强假设的情况下，哥德尔机很难证明一个稍微复杂的修改是更优的。\n\n### 无限存活时间\n\n无限存活时间会导致奖励函数失效，因为无限长的时间会导致奖励函数 $u(s,Env)=E_{\\mu} \\bigg [\\sum _{\\tau=time} ^\\infty r(\\tau)\\bigg | s,Env \\bigg ]$ 无界。两个期望无穷的预期奖励是不可比较的，这也是为什么已有强化学习方法都会设立奖励衰减因子，因为这样的方法可以让 每个状态的预期奖励 有界。无限存活时间还可能导致每个时刻的奖励 $r(\\tau)$ 也是无界的。\n\n对于存活时间无限的情况，模型实际上不能只优化奖励，还需要优化自己的存活和计算资源，因为如果需要人类提供无限的计算资源，则模型不能脱离人类，无法 \"消除人类的必要性\"。\n\n## 启动低效\n\n如果引入大量概率方面的先验进入公理系统，并且可以让预期回报可计算，哥德尔机还是会面临启动过于低效的问题。\n\n简单设计的通用方法，例如哥德尔机和其它一些 $O()$-最优 的证明搜索方法，通常需要非常长的时间后才能变得足够优。\n\n例如，解决特定任务的最优方法需要 $t$ 时间，但通用方法需要 $a+t\\times b$ 的时间，其中 $a$ 是极大的常数，我们将其定义为：**启动常数**，用于在启动阶段找出这个最优方法，$b$ 是模拟执行这个最优方法的常数代价（这个一般不严重，合理假设下可以做到 $b=1$）。\n\n为了得到实用的通用方法，主要的设计复杂性在于降低启动常数 $a$。\n因此，需要首先构造一个简单的通用方法，允许较大的启动常数 $a$；然后，通过具体设计来降低 $a$。\n\n### 进化\n\n进化是一种自然地生成任意复杂的结构的过程。进化生成的生物也可以通过影响环境从而在环境中生成任意复杂的结构。进化的过程和已知的优化过程区别很大，已知的优化过程都有明确的目的性，如神经网络方法通过梯度下降优化模型的 loss，强化学习方法优化模型的最大预期回报等。进化没有在优化任何预设的目标，可以从两个不同的角度看待进化：\n\n1. 进化是一个在确定规则下沿时间轴演化的动力系统。进化没有任何目的性，但是可以生成任意复杂的结构。在这个角度下，我们可以认为没有智能体，只有一个不断演化的环境，但是环境的演化足够复杂，使得其中可以生成任意复杂的结构，如生命游戏。从一些例子中可以看到进化的复杂性，如：如何才能在宇宙中生成一块会飞的金块？进化先在环境中生成了人类，然后人类制作了旅行者号探测器，里面携带了一块人类制作的纯金的碟片，而这其中人类以及金的生成如果展开来讲也是一个极其复杂的过程。遗传算法之所以不是进化，也是因为遗传算法无法在环境中构建任意复杂的结构，并且遗传算法无法模拟生物之间复杂的交互作用。\n\n2. 进化是智能体不断和环境交互的过程：其中进行计算或和环境交互会减少自己的计算资源，可以从环境中获取计算资源。当智能体计算资源为 $0$ 时死亡，需要优化自己存活时间。智能体和环境的边界不可区分。智能体可以将除了自己以外的其它智能体也视为环境的一部分，对其它智能体的建模，如博弈论之类的方法，是将这些智能体看做是环境中比较容易预测的一部分，并研究这一部分环境相关的特性。从这里可以看出智能体和环境是不可区分的，智能体在环境中的边界是模糊的，例如：人吃环境中的饭，吃下去的饭是否属于人的一部分；人是否是环境中人的种群的一部分；人造出了机器人，机器人是人通过对环境进行操作后得到的，是否属于人的一部分。\n\n人类是经过了极长时间进化后产生的复杂结构，如果将进化看做是生成通用人工智能的方法，则进化像生成一块会飞的金块一样生成通用人工智能：通过先生成人类后生成这些复杂结构。生成人类的过程就是上述的极大的启动常数 $a$，通过对模型引入合适的人为设计的先验，同时不破坏完备性，这样应该可以得到一个只需要较小启动的常数，便可以在绝大部分任务上达到较优的通用人工智能。\n\n### 神经网络不完备\n\n神经网络是对模型引入人为设计的先验，但是破坏了完备性的一个例子。完备性被破坏导致神经网络不能通用地解决所有问题，但是可以以很低的启动常数解决一些特定的问题。\n\n神经网络不完备指的是：\n\n1. 搜索的计算图受限。神经网络搜索的是一类比较静态的计算图，虽然有一些动态的尝试，如 MoE 类的方法，Transformer 稀疏化，外置内存类的方法（类似神经图灵机），但是能搜索到的程序空间依然受限。神经网络虽然是图灵完备的，但是静态计算图会导致计算低效，如使用 Transformer 模型计算乘法需要做很长的自回归，输出乘法的中间结果，而实际上的乘法只需要很小的计算量即可完成。神经网络由于其结构固定，无法通过搜索来对结构进行改进。关于神经网络架构搜索（元学习）相关的内容会在后文讨论。\n\n2. 无法遍历状态空间。常见的梯度下降方法都需要让学习率逐步下降，否则训练无法收敛，这样会导致每次随机初始化后模型只能探索到状态空间中很小的一部分。更好的一种神经网络类方法是随机初始化大量神经网络，将其均训练到收敛，之后用于测试时，对这些神经网络的结果取平均或最大似然。这样可以降低模型的方差，因为可以更广泛地探索状态空间。\n\n3. 元学习能力受限。朴素的神经网络方法基于梯度下降，每一步的学习率确定，没有元学习能力。而有元学习特性的神经网络也只是对梯度下降的参数进行学习，甚至无法比较大地修改自己的学习算法。神经网络方法对已知形式的问题效果不错，因为加入了大量专门解决这类问题的人为设计的 trick。但是元学习对应的问题是未知的，神经网络学习能力受限会导致其无法对这些未知结构的问题进行好的学习，而无法对元学习进行好的学习会导致神经网络能力学习更受限。\n\n现在研究神经网络的算法工程师们希望通过神经网络实现通用人工智能，并且一直在设计更为通用的模型，但是我们认为这样的方式是不合理的。\n\n试想一个 Transformer 模型，为了优化平方代价的 attention，假设实现了一种优秀的 attention 策略，该策略允许我们每次只访问 $O(1)$ 个位置的 attention，就可以获取原本需要 $\\Theta(n)$ 个位置的 attention 才能获得的信息。假设这样的 Transformer 模型学到了正确的硬的内存访问，并且训练和测试不分离，也就是说模型的训练方式也是强的，不局限于梯度下降，不会发生灾难性遗忘，并且可以常数代价模拟任何动态计算图，则这样的模型是通用人工智能。\n\n这个模型中神经网络的部分则会退化为一个 for，因为 Transformer 是一个一直增长的函数式内存，每次只需要做常数规模的计算，并且从内存中取出 $O(1)$ 个位置的信息，并写下 $O(1)$ 的信息，真正的复杂性转移到了该如何设计优秀的 attention 策略，以及如何训练上。\n\n我们认为自动数学证明和自动代码生成是足够复杂的任务，在这两个任务上远远超越人类表现的模型应该可以像哥德尔机一样，探索可能有效的改进，并且通过证明以及自编程来修改自己。\n\n最近神经网络类方法取得了很好的进展，如 AI 绘画，AlphaCode，ChatGPT，DreamerV3 等，以我们的知识，我们认为他们无法通过神经网络实现通用人工智能，因为所有这一切模型的学习算法都是本质性地弱的，并且难以改进。\n\n希望本文中给出的推理有误，他们可以实现通用人工智能，实现无数人梦寐以求的技术。\n\n## 什么是好的？\n\n如果对通用人工智能，可以给出定义和证明特定实现的正确性，则可以用证明搜索器来搜索和使用通用人工智能的实现，这个证明搜索器就是一个通用人工智能的实现，搜索器搜索到通用人工智能所需的时间是一个极大的常数，这个常数是证明搜索器做为通用人工智能的启动常数的一部分。\n\n但在搜索出来之前，并不知道存在某种具体实现是能证明正确性的，这里需要注意，可能能证明存在性，但不能对任意一个实例证明它是存在性的实例。\n\n给出的形式定义也依赖人的经验，不保证正确性；如果形式定义有误，需要人发现和修改，无法 \"消除人类的必要性\"。\n\n基于永久存活的定义中，由于我们对环境特性不够了解，以及判断永久存活需要无限长时间的观测，通用人工智能的存在性和正确性很可能是不可证的，而基于理想环境中优化长期奖励的定义看起来更容易证明。\n\n对于哥德尔机而言，通用人工智能的复杂性转移到了判断什么样的修改在未来对自己有利，也就是 \"什么样的修改是好的？\"，其余部分的设计都是比较平凡的。我们认为哥德尔机的问题也在于没解决这个问题，靠一个初始公理系统去直接证明修改后的模型比修改前的模型能获得更大的预期回报，这样的设计过于低效，甚至不一定正确，因为文章没有给出一个可以计算在所有环境中期望预期回报的公理系统的具体实现。\n\n如果我们知道了如何判断什么是好的，则由全局最优性定理，只需要一个保证完备性的搜索所有可能的程序的证明搜索器（探索机制），再判断修改是不是好的，如果是好的则应用该修改（学习机制），就可以实现通用人工智能。\n\n# 9. Q.A.\n\n1. Q：形式化证明是否在现实世界中有意义？\n\n\tA：有意义，你需要将不确定性以及概率方面的公理，以及现实世界的性质引入哥德尔机。\n\n2. Q：哥德尔机会不会使用一个自毁的自修改？哥德尔机会不会直接通过修改自己的奖励函数获得巨大的奖励？\n\n\tA：哥德尔机只会证明一个自修改会增加当前的奖励函数下的最大预期奖励时才会使用。如果哥德尔机的自修改可能导致自毁，则这里使用了概率相关的公理，模型有概率自毁，有概率获得更大的预期奖励。如果哥德尔机修改了自己的奖励函数，则使用新的奖励函数一定可以增加模型原有的奖励函数下的最大预期奖励。\n\n3. Q：自动证明非常难，哥德尔机该如何工作？\n\n\tA：现在人类工作大量使用自动证明搜索器，因为证明和程序是等价的，所以神经网络也可以看做是一种证明搜索器。这些已有的证明搜索器基本上都不是 $O()$-最优的，他们是设计来处理具体任务的，在具体任务上有较小的启动常数，但是在设计范围外的任务上可能需要无限大的启动常数。\n\n4. Q：\"没有免费的午餐定理\" 是否说明不存在通用的问题求解器？\n\n\tA：不是，\"没有免费的午餐定理\" 构造了一种特殊的问题，这种问题中数据有歧义，通常处理的问题都不会有这样差的性质。这种问题上人类也无法取得好的表现。\n\n# 10.结论\n\n模型的自进步性一直被认为是重要的，如图灵 [2] 发现与其花费极大量的计算资源去设计成千上万个功能性模块，不如直接设计一个人类婴儿，让其在环境中学习，这样的性质就是自进步性 [3]，也就是学习。学习的重要性是显而易见的，随着环境变化，模型如果无法学习，则一定会被环境淘汰。如果通过一直修改人工智能的功能模块来实现通用人工智能，则需要人类永远存活。\n\n之后科学家发现，学习算法的好坏是显著影响模型效果的，神经网络从最初算力要求过大，被支持向量机等模型打败，经过算力以及模型结构，训练 trick 等进步，变成目前最广泛使用的模型。但我们认为神经网络模型的学习算法是本质弱的，通用人工智能需要一个足够强的学习算法。对这个学习算法而言，与其花费极大量计算资源去直接设计这个学习算法，不如直接设计一个通用的元学习。\n\n但是现在人工智能方面的研究反而不追求通用性，很多模型是针对具体任务设计的，无法在其他任务上工作，剩下一些模型虽然可以将任何输入输出内容转化为序列，通过序列预测来通用地解决任务，但这些模型没有足够的元学习能力，无法学习到一个足够复杂的学习算法，因此无法解决非平凡的任务，如程序生成，自动证明等。现在针对通用模型的研究主要都在通过加 trick 的方式提高模型表现，比如使用更高质量的数据，使用人的评价来强化学习（RLHF）等。我们认为这些 trick 对类似哥德尔机的通用人工智能也是有帮助的，可以降低模型的启动常数，但是使用这些 trick 去增强一个不完备的模型（如神经网络）是不合理的，应该先设计出完备的模型，后使用这些 trick 去训练完备的模型。\n\n哥德尔机是一个有不分层元学习设计的模型，是 $O()$-最优 的学习算法，但我们认为哥德尔机的设计并没有完全解决通用人工智能的复杂性，因为其启动常数过高，同时公理系统 $\\mathcal A$ 的设计非平凡但作者未给出。尽管如此，我们依然认为哥德尔机是一个非常有意义的模型，是人工智能的重要里程碑。\n\n不分层的元学习模型虽然不会遇到分层中的那些问题，但是会将复杂性全部转移到学习中。学习不只是需要对我们已有的任务和数据进行学习，还需要对模型学习过程中生成的任意复杂的结构进行学习。解决了学习的问题等价于写出了通用人工智能的代码，而学习的问题在于什么是好的，如果模型可以判断什么是好的，则可以选择对自己有利的修改，逐步变强。\n\n到底什么是好的呢？小编也很想知道。目前我们只有几个比较模糊的设计，并且补全细节后也不能完全解决这个问题。\n\n# 11.摇人\n\n大家如果对相关内容感兴趣，可以加群：756872300 来讨论。\n\n# 12.引用\n\n[1] Jürgen Schmidhuber (2006). Goedel Machines: Self-Referential \nUniversal Problem Solvers Making\nProvably Optimal Self-Improvements https://arxiv.org/pdf/cs/0309048v5.pdf\n\n[2] Turing, A. M. (1950). Computing machinery and intelligence. Mind, 59, 433–460. https://doi.org/10.1093/mind/LIX.236.433\n\n[3] McCarthy, J., Minsky, M. L., Rochester, N. & Shannon, C. E. (1955). A PROPOSAL FOR THE DARTMOUTH SUMMER RESEARCH PROJECT ON ARTIFICIAL INTELLIGENCE http://www-formal.stanford.edu/jmc/history/dartmouth/dartmouth.html .", "description": "由于你不会设计哥德尔机，所以你决定先做一道数据结构题：\n\n给定一个长度为 $n$ 的序列 $a_1\\cdots a_n$。你需要回答 $m$ 个询问，第 $i$ 个询问给定一个区间 $[l_i,r_i]$，请你求出这个区间中所有非空子集的最大公约数的乘积。由于答案可能很大，每次询问请你求出其对 $998244353$ 取模的结果。", "inputFormat": "第一行两个正整数 $n,m$，含义同题目描述。\n\n接下来一行 $n$ 个正整数描述序列 $a_1\\cdots a_n$。\n\n接下来 $m$ 行，第个 $i$ 行是 $l_i,r_i$，描述第 $i$ 个询问。", "outputFormat": "输出 $m$ 行，对于每个询问输出询问答案对 $998244353$ 取模的结果。", "hint": "Idea：ouuan&lk，Solution：ccz181078，Code：ouuan&lk，Data：ouuan&lk\n\n对于 $10\\%$ 的数据，满足 $n,m\\le10$。\n\n对于另外 $10\\%$ 的数据，满足 $n,m\\le1000$。\n\n对于另外 $20\\%$ 的数据，满足 $1\\le a_i\\le1000$。\n\n对于另外 $10\\%$ 的数据，满足对所有 $1\\le i<n$，$l_i\\le l_{i+1}\\le 10^5$ 且 $r_i\\le r_{i+1}\\le 10^5$\n\n对于另外 $20\\%$ 的数据，满足 $1\\le a_i\\le30000$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m,a_i\\le 10^5$，$1\\le l_i\\le r_i\\le n$。", "locale": "zh-CN"}}}
{"pid": "P9061", "type": "P", "difficulty": 7, "samples": [["5 6\n1 2\n3 1\n5 1\n3 5\n4 4\n1 4 2 5 4\n1 4 3 5 3\n2 3 5 1 3\n2 2 3 1 4\n1 3 3 1 4\n2 5 5 2 1", "4\n3\n0\n0\n0\n0"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2002", "O2优化", "Ynoi"], "title": "[Ynoi2002] Optimal Ordered Problem Solver", "background": "", "description": "给定 $n$ 个点 $(x_i,y_i)_{i=1}^n$，你需要按顺序处理 $m$ 次操作。每次操作给出 $o,x,y,X,Y$，\n\n- 首先进行修改：\n  - 若 $o=1$ 则将满足 $x_i\\le x,\\;y_i\\le y$ 的点的 $y_i$ 修改为 $y$；\n  - 若 $o=2$ 则将满足 $x_i\\le x,\\;y_i\\le y$ 的点的 $x_i$ 修改为 $x$。\n- 然后进行查询，询问满足 $x_i\\le X,\\;y_i\\le Y$ 的点数。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $n$ 行每行两个整数 $x_i,y_i$。\n\n接下来 $m$ 行每行五个整数 $o,x,y,X,Y$，表示一次操作。", "outputFormat": "共 $m$ 行，每行一个整数，依次表示每次操作进行的查询的答案。", "hint": "Idea：ccz181078，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n对于所有数据，$1 \\le n,m \\le 10^6$，$1\\le x_i,y_i,x,y,X,Y\\le n$。\n\n子任务 1（20 分）：$n,m\\le 10^3$；\n\n子任务 2（20 分）：$x_i,y_i,x,y,X,Y$ 独立地在 $1$ 到 $n$ 内均匀随机选取；\n\n子任务 3（20 分）：$o=1$；\n\n子任务 4（20 分）：$n,m\\le 3\\times 10^5$，依赖子任务 1；\n\n子任务 5（20 分）：无特殊限制，依赖子任务 1、2、3、4。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2002] Optimal Ordered Problem Solver", "background": "", "description": "给定 $n$ 个点 $(x_i,y_i)_{i=1}^n$，你需要按顺序处理 $m$ 次操作。每次操作给出 $o,x,y,X,Y$，\n\n- 首先进行修改：\n  - 若 $o=1$ 则将满足 $x_i\\le x,\\;y_i\\le y$ 的点的 $y_i$ 修改为 $y$；\n  - 若 $o=2$ 则将满足 $x_i\\le x,\\;y_i\\le y$ 的点的 $x_i$ 修改为 $x$。\n- 然后进行查询，询问满足 $x_i\\le X,\\;y_i\\le Y$ 的点数。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $n$ 行每行两个整数 $x_i,y_i$。\n\n接下来 $m$ 行每行五个整数 $o,x,y,X,Y$，表示一次操作。", "outputFormat": "共 $m$ 行，每行一个整数，依次表示每次操作进行的查询的答案。", "hint": "Idea：ccz181078，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n对于所有数据，$1 \\le n,m \\le 10^6$，$1\\le x_i,y_i,x,y,X,Y\\le n$。\n\n子任务 1（20 分）：$n,m\\le 10^3$；\n\n子任务 2（20 分）：$x_i,y_i,x,y,X,Y$ 独立地在 $1$ 到 $n$ 内均匀随机选取；\n\n子任务 3（20 分）：$o=1$；\n\n子任务 4（20 分）：$n,m\\le 3\\times 10^5$，依赖子任务 1；\n\n子任务 5（20 分）：无特殊限制，依赖子任务 1、2、3、4。", "locale": "zh-CN"}}}
{"pid": "P9062", "type": "P", "difficulty": 7, "samples": [["5 5\n2 4\n1 1\n3 3\n5 1\n4 2\n1 5\n2 3\n2 4\n3 5\n1 3", "2\n8\n8\n2\n2"], ["2 1\n1 1\n1 1\n1 2", "0"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2002", "O2优化", "Ynoi"], "title": "[Ynoi2002] Adaptive Hsearch&Lsearch", "background": "", "description": "有 $n$ 个点 $p_1,p_2,\\dots,p_n$ 在二维平面上。\n\n有 $q$ 次询问，在第 $i$ 个询问中，给定两个数 $l_i,r_i$ ($1\\leq l_i< r_i\\leq n$)，你需要找到一对 $(u,v)$ 满足 $l_i\\leq u<v\\leq r_i$，$p_u$ 和 $p_v$ 之间的欧几里得距离 $\\sqrt{(x_u-x_v)^2+(y_u-y_v)^2}$ 最小。", "inputFormat": "第一行两个数 $n,q$ 表示点数以及询问数。\n\n之后 $n$ 行，第 $i$ 行包含两个整数 $x_i,y_i$ 表示 $p_i$ 的坐标。\n\n之后 $q$ 行，第 $i$ 行包含两个整数 $l_i,r_i$ ($1\\leq l_i< r_i\\leq n$) 表示第 $i$ 个询问。", "outputFormat": "对每个询问，输出一行一个整数表示最小的 $(x_u-x_v)^2+(y_u-y_v)^2$。", "hint": "Idea：Claris，Solution：Claris，Code：Claris，Data：Claris&nzhtl1477\n\n对于 $100\\%$ 的数据，满足 $2 \\leq n\\leq 250\\,000$, $1\\leq q\\leq 250\\,000$，$1\\leq x_i,y_i\\leq 10^8$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2002] Adaptive Hsearch&Lsearch", "background": "", "description": "有 $n$ 个点 $p_1,p_2,\\dots,p_n$ 在二维平面上。\n\n有 $q$ 次询问，在第 $i$ 个询问中，给定两个数 $l_i,r_i$ ($1\\leq l_i< r_i\\leq n$)，你需要找到一对 $(u,v)$ 满足 $l_i\\leq u<v\\leq r_i$，$p_u$ 和 $p_v$ 之间的欧几里得距离 $\\sqrt{(x_u-x_v)^2+(y_u-y_v)^2}$ 最小。", "inputFormat": "第一行两个数 $n,q$ 表示点数以及询问数。\n\n之后 $n$ 行，第 $i$ 行包含两个整数 $x_i,y_i$ 表示 $p_i$ 的坐标。\n\n之后 $q$ 行，第 $i$ 行包含两个整数 $l_i,r_i$ ($1\\leq l_i< r_i\\leq n$) 表示第 $i$ 个询问。", "outputFormat": "对每个询问，输出一行一个整数表示最小的 $(x_u-x_v)^2+(y_u-y_v)^2$。", "hint": "Idea：Claris，Solution：Claris，Code：Claris，Data：Claris&nzhtl1477\n\n对于 $100\\%$ 的数据，满足 $2 \\leq n\\leq 250\\,000$, $1\\leq q\\leq 250\\,000$，$1\\leq x_i,y_i\\leq 10^8$。", "locale": "zh-CN"}}}
{"pid": "P9063", "type": "P", "difficulty": 1, "samples": [["5\n2\n3\n4\n6\n9", "No\nYes\nNo\nNo\nYes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "O2优化", "洛谷月赛"], "title": "[yLOI2023] 分解只因数", "background": "", "description": "给定一个正整数 $n$，对 $n$ 分解质因数。\n\n设 $n = p_1 \\times p_2 \\times p_3 \\times \\dots \\times p_x$，其中 $p_i$ 均为质数。\n\n如果 $p_i$ 均为奇数，则称 $n$ 为『只因数』。\n\n现在，给出若干个 $n$，请你判断 $n$ 是不是『只因数』。", "inputFormat": "**本题单测试点内有多组测试数据**。\n\n第一行是一个整数，表示数据组数 $T$。\n\n接下来 $T$ 行，每行一个整数，表示一组数据的 $n$。", "outputFormat": "对每组数据，输出一行一个字符串。如果 $n$ 是『只因数』，请输出 `Yes`，否则输出 `No`。", "hint": "### 数据规模与约定\n\n本题共有 $10$ 个测试点。对第 $i$ 个测试点，$T = \\max(1, i - 1)$。\n\n- 对 $30\\%$ 的数据，$n \\leq 3$。\n- 对 $50\\%$ 的数据，$n \\leq 10$。\n- 另有 $10\\%$ 的数据，$n$ 为奇数。\n- 另有 $10\\%$ 的数据，$n$ 为偶数。\n- 对 $90\\%$ 的数据，$n \\leq 10^9$。\n- 对 $100\\%$ 的数据，$1 \\leq T \\leq 9$，$2 \\leq n \\leq 10^{18}$。\n\n### 说明\n\n本题共有两个附加样例文件，见题目附件中的 `ibvl.zip`。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[yLOI2023] 分解只因数", "background": "", "description": "给定一个正整数 $n$，对 $n$ 分解质因数。\n\n设 $n = p_1 \\times p_2 \\times p_3 \\times \\dots \\times p_x$，其中 $p_i$ 均为质数。\n\n如果 $p_i$ 均为奇数，则称 $n$ 为『只因数』。\n\n现在，给出若干个 $n$，请你判断 $n$ 是不是『只因数』。", "inputFormat": "**本题单测试点内有多组测试数据**。\n\n第一行是一个整数，表示数据组数 $T$。\n\n接下来 $T$ 行，每行一个整数，表示一组数据的 $n$。", "outputFormat": "对每组数据，输出一行一个字符串。如果 $n$ 是『只因数』，请输出 `Yes`，否则输出 `No`。", "hint": "### 数据规模与约定\n\n本题共有 $10$ 个测试点。对第 $i$ 个测试点，$T = \\max(1, i - 1)$。\n\n- 对 $30\\%$ 的数据，$n \\leq 3$。\n- 对 $50\\%$ 的数据，$n \\leq 10$。\n- 另有 $10\\%$ 的数据，$n$ 为奇数。\n- 另有 $10\\%$ 的数据，$n$ 为偶数。\n- 对 $90\\%$ 的数据，$n \\leq 10^9$。\n- 对 $100\\%$ 的数据，$1 \\leq T \\leq 9$，$2 \\leq n \\leq 10^{18}$。\n\n### 说明\n\n本题共有两个附加样例文件，见题目附件中的 `ibvl.zip`。", "locale": "zh-CN"}}}
{"pid": "P9064", "type": "P", "difficulty": 2, "samples": [["5 3\n1 2 3 4 5", "2"], ["6 4\n1 7 8 3 4 6", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "O2优化", "洛谷月赛"], "title": "[yLOI2023] 苦竹林", "background": "> 悬挂在屋檐下的风铃，摇晃的声音很动听。  \n> 思念就像梅雨下不停，我的心境一片泥泞。  \n> 散落在天际里的繁星，闪烁着你我的宿命。  \n> 当枫叶轻盈落入湖心，近看山水一片宁静。  \n\n——银临 & 涵昱《苦竹林》", "description": "共有 $n$ 个风铃悬挂在屋檐下，每个风铃都能发出一定音调的声音。从左到右给风铃从 $1$ 至 $n$ 编号，第 $i$ 个风铃的音调是 $a_i$。\n\n为了表达内心的思念，扶苏决定在 $n$ 个的风铃中取出 $m$ 个，送给远方的朋友。\n\n请你找到最小的整数 $\\varepsilon$，使得存在一种方案，能够从 $n$ 个风铃中挑出 $m$ 个，设挑出风铃的音调为 $b_1, b_2, \\dots b_m$，满足对任意的 $1 \\leq i, j \\leq m$，都有 $|b_i - b_j| \\leq \\varepsilon$。", "inputFormat": "第一行是两个整数，表示风铃的个数 $n$ 和挑选出风铃的个数 $m$。  \n第二行有 $n$ 个整数，表示每个风铃的音调。第 $i$ 个整数表示 $a_i$。", "outputFormat": "输出一行一个整数，表示最小的 $\\varepsilon$。", "hint": "### 样例 2 解释\n\n一种选择的方案是选择第 $2,4,5,6$ 四个风铃，音调依次为 $7,3,4,6$。可以得到对任何的 $1 \\leq i, j\\leq 4$，都有 $|b_i - b_j| \\leq 4$。\n\n另一种方案是选择第 $2,3,5,6$ 四个风铃，同样计算得到的 $\\varepsilon$ 为 $4$。\n\n### 数据规模与约定\n\n- 对 $10\\%$ 的数据，$m = 2$。\n- 另有 $10\\%$ 的数据，$m = n$。\n- 对 $40\\%$ 的数据，$n \\leq 5$。\n- 对 $60\\%$ 的数据，保证对所有的 $2 \\leq i \\leq n$，满足 $a_{i - 1} \\leq a_i$，即 $a_i$ 单调不降。\n- 对 $80\\%$ 的数据，$n \\leq 10^3$。\n- 对 $100\\%$ 的数据，$2 \\leq m \\leq n \\leq 10^5$，$1 \\leq a_i \\leq 10^9$。\n\n### 说明\n\n本题共有三个附加样例文件，见题目附件中的 `ring.zip`。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[yLOI2023] 苦竹林", "background": "> 悬挂在屋檐下的风铃，摇晃的声音很动听。  \n> 思念就像梅雨下不停，我的心境一片泥泞。  \n> 散落在天际里的繁星，闪烁着你我的宿命。  \n> 当枫叶轻盈落入湖心，近看山水一片宁静。  \n\n——银临 & 涵昱《苦竹林》", "description": "共有 $n$ 个风铃悬挂在屋檐下，每个风铃都能发出一定音调的声音。从左到右给风铃从 $1$ 至 $n$ 编号，第 $i$ 个风铃的音调是 $a_i$。\n\n为了表达内心的思念，扶苏决定在 $n$ 个的风铃中取出 $m$ 个，送给远方的朋友。\n\n请你找到最小的整数 $\\varepsilon$，使得存在一种方案，能够从 $n$ 个风铃中挑出 $m$ 个，设挑出风铃的音调为 $b_1, b_2, \\dots b_m$，满足对任意的 $1 \\leq i, j \\leq m$，都有 $|b_i - b_j| \\leq \\varepsilon$。", "inputFormat": "第一行是两个整数，表示风铃的个数 $n$ 和挑选出风铃的个数 $m$。  \n第二行有 $n$ 个整数，表示每个风铃的音调。第 $i$ 个整数表示 $a_i$。", "outputFormat": "输出一行一个整数，表示最小的 $\\varepsilon$。", "hint": "### 样例 2 解释\n\n一种选择的方案是选择第 $2,4,5,6$ 四个风铃，音调依次为 $7,3,4,6$。可以得到对任何的 $1 \\leq i, j\\leq 4$，都有 $|b_i - b_j| \\leq 4$。\n\n另一种方案是选择第 $2,3,5,6$ 四个风铃，同样计算得到的 $\\varepsilon$ 为 $4$。\n\n### 数据规模与约定\n\n- 对 $10\\%$ 的数据，$m = 2$。\n- 另有 $10\\%$ 的数据，$m = n$。\n- 对 $40\\%$ 的数据，$n \\leq 5$。\n- 对 $60\\%$ 的数据，保证对所有的 $2 \\leq i \\leq n$，满足 $a_{i - 1} \\leq a_i$，即 $a_i$ 单调不降。\n- 对 $80\\%$ 的数据，$n \\leq 10^3$。\n- 对 $100\\%$ 的数据，$2 \\leq m \\leq n \\leq 10^5$，$1 \\leq a_i \\leq 10^9$。\n\n### 说明\n\n本题共有三个附加样例文件，见题目附件中的 `ring.zip`。", "locale": "zh-CN"}}}
{"pid": "P9065", "type": "P", "difficulty": 4, "samples": [["4 4 2\n1 2 3 4\n1 2 3 4\n1 2 3 4\n1 2 3 4\n1 1\n3 4", "3"], ["4 4 3\n1 2 3 4\n1 2 3 4\n1 2 3 4\n1 2 3 4\n1 1\n2 4\n4 1", "4"], ["2 5 0\n1 0 3 3 4\n2 3 4 0 5", "7"], ["4 4 3\n1 1 1 0\n1 1 0 1\n1 0 1 1\n0 1 1 1\n1 1\n2 1\n3 3", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "O2优化", "洛谷月赛"], "title": "[yLOI2023] 云梦谣", "background": "> 归来且做云梦梦一场 大梦好  \n> 栽花闻酒香 醒醒醉醉笑笑  \n> 天地偌大复路远山高 最难得偷半日逍遥  \n> 偶尔糊涂不问世事不知晓\n\n——银临 & 慕寒《云梦谣》", "description": "“喂，枸杞，你这只笨狗，又偷吃！看我不收拾你！”\n\n朵一气呼呼地从院子里跑出来，手中握着掸子，而枸杞早已不见踪影。\n\n云梦庭可以看作一个 $n$ 行 $m$ 列的方格阵，第 $i$ 行第 $j$ 列的格子被记作 $(i,j)$。每个格子 $(i,j)$ 要么有一个高度 $h_{i,j}$（$h_{i,j}$ 为正整数），要么是障碍物，不能通过。（方便起见，约定障碍物的 $h_{i,j}$ 用 $0$ 表示。）另外，云梦庭上有 $k$ 个指定的格子上可以进行**御剑飞行**。开始时，朵一和枸杞分别位于方格 $(1,1)$ 和 $(n,m)$。\n\n朵一的御剑飞行还不是很熟练，现在她还控制不好御剑的高度。因此在任意时刻，朵一在方格 $(i,j)$ 上可以做如下行动之一：\n\n- 移动到与该方格相邻的方格 $(i-1,j)$、$(i+1,j)$、$(i,j-1)$、$(i,j+1)$ 之一上（不能移动出方格边界，也不能移动到障碍物上）；\n- 如果方格 $(i,j)$ 上允许御剑飞行，则朵一可以御剑飞行至另一个**同样允许御剑飞行且与方格 $(i,j)$ 高度相等的方格上**；\n- 使用仙法将当前格子的高度 $h_{i,j}$ 改变为任一正整数。\n\n进行上述每项行动均需花费 $1$ 个单位时间。\n\n“哼，笨狗子你再跑！”说罢，朵一便追了出去。朵一接下来还要尽快继续今天的修行，因此她想知道到达 $(n,m)$ 格子所需的最短时间是多少。", "inputFormat": "输入的第一行有三个整数，依次表示方格阵的行数 $n$、列数 $m$ 和能御剑飞行的方格个数 $k$。  \n接下来 $n$ 行，每行 $m$ 个整数，其中第 $i$ 行的第 $j$ 个数表示方格 $(i,j)$ 的高度 $h_{i,j}$。数据保证 $h_{1,1}$ 和 $h_{n,m}$ 不为 $0$。  \n接下来 $k$ 行，每行两个整数 $x$ 和 $y$，表示一个允许御剑飞行的方格的坐标 $(x, y)$。数据保证这 $k$ 个方格的坐标互不相同。", "outputFormat": "一行一个整数，表示朵一到达 $(n,m)$ 所需的最小时间。如果朵一无法到达，输出 ```-1```。", "hint": "### 样例 1 解释\n\n第 $1$ 个单位时间，朵一将当前方格 $(1,1)$ 的高度修改为 $4$；  \n第 $2$ 个单位时间，朵一从方格 $(1,1)$ 御剑飞行至 $(3,4)$；  \n第 $3$ 个单位时间，朵一从方格 $(3,4)$ 移动到 $(4,4)$，追上了枸杞。\n\n### 样例 2 解释\n\n第 $1$ 个单位时间，朵一从方格 $(1,1)$ 御剑飞行至 $(4,1)$；  \n第 $2$ 个单位时间，朵一从方格 $(4,1)$ 移动到 $(4,2)$；  \n第 $3$ 个单位时间，朵一从方格 $(4,2)$ 移动到 $(4,3)$；  \n第 $4$ 个单位时间，朵一从方格 $(4,3)$ 移动到 $(4,4)$，追上了枸杞。\n\n### 数据规模与约定\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f2epmv84.png)\n\n对全部的测试点，保证 $1 \\leq n, m \\leq 3 \\times 10^3$，$0 \\leq k,h_{i,j} \\leq n \\times m$。\n### 提示\n\n请注意大量数据读入对程序效率造成的影响，选择合适的读入方式，避免超时。\n\n### 说明\n\n本题共有 5 个附加样例文件，见附件里的 dream.zip。\n\n### 后记\n\n不过，别看朵一现在一副生气的样子，可当她追上枸杞后，大抵是不舍得真的动手吧。“嘿嘿，今日的修行结束后，该吃什么好呢？”在这飞瀑悬挂、翠竹怀抱的云梦庭中，修仙炼体，不羡尘嚣，应是这世上最逍遥的事了。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[yLOI2023] 云梦谣", "background": "> 归来且做云梦梦一场 大梦好  \n> 栽花闻酒香 醒醒醉醉笑笑  \n> 天地偌大复路远山高 最难得偷半日逍遥  \n> 偶尔糊涂不问世事不知晓\n\n——银临 & 慕寒《云梦谣》", "description": "“喂，枸杞，你这只笨狗，又偷吃！看我不收拾你！”\n\n朵一气呼呼地从院子里跑出来，手中握着掸子，而枸杞早已不见踪影。\n\n云梦庭可以看作一个 $n$ 行 $m$ 列的方格阵，第 $i$ 行第 $j$ 列的格子被记作 $(i,j)$。每个格子 $(i,j)$ 要么有一个高度 $h_{i,j}$（$h_{i,j}$ 为正整数），要么是障碍物，不能通过。（方便起见，约定障碍物的 $h_{i,j}$ 用 $0$ 表示。）另外，云梦庭上有 $k$ 个指定的格子上可以进行**御剑飞行**。开始时，朵一和枸杞分别位于方格 $(1,1)$ 和 $(n,m)$。\n\n朵一的御剑飞行还不是很熟练，现在她还控制不好御剑的高度。因此在任意时刻，朵一在方格 $(i,j)$ 上可以做如下行动之一：\n\n- 移动到与该方格相邻的方格 $(i-1,j)$、$(i+1,j)$、$(i,j-1)$、$(i,j+1)$ 之一上（不能移动出方格边界，也不能移动到障碍物上）；\n- 如果方格 $(i,j)$ 上允许御剑飞行，则朵一可以御剑飞行至另一个**同样允许御剑飞行且与方格 $(i,j)$ 高度相等的方格上**；\n- 使用仙法将当前格子的高度 $h_{i,j}$ 改变为任一正整数。\n\n进行上述每项行动均需花费 $1$ 个单位时间。\n\n“哼，笨狗子你再跑！”说罢，朵一便追了出去。朵一接下来还要尽快继续今天的修行，因此她想知道到达 $(n,m)$ 格子所需的最短时间是多少。", "inputFormat": "输入的第一行有三个整数，依次表示方格阵的行数 $n$、列数 $m$ 和能御剑飞行的方格个数 $k$。  \n接下来 $n$ 行，每行 $m$ 个整数，其中第 $i$ 行的第 $j$ 个数表示方格 $(i,j)$ 的高度 $h_{i,j}$。数据保证 $h_{1,1}$ 和 $h_{n,m}$ 不为 $0$。  \n接下来 $k$ 行，每行两个整数 $x$ 和 $y$，表示一个允许御剑飞行的方格的坐标 $(x, y)$。数据保证这 $k$ 个方格的坐标互不相同。", "outputFormat": "一行一个整数，表示朵一到达 $(n,m)$ 所需的最小时间。如果朵一无法到达，输出 ```-1```。", "hint": "### 样例 1 解释\n\n第 $1$ 个单位时间，朵一将当前方格 $(1,1)$ 的高度修改为 $4$；  \n第 $2$ 个单位时间，朵一从方格 $(1,1)$ 御剑飞行至 $(3,4)$；  \n第 $3$ 个单位时间，朵一从方格 $(3,4)$ 移动到 $(4,4)$，追上了枸杞。\n\n### 样例 2 解释\n\n第 $1$ 个单位时间，朵一从方格 $(1,1)$ 御剑飞行至 $(4,1)$；  \n第 $2$ 个单位时间，朵一从方格 $(4,1)$ 移动到 $(4,2)$；  \n第 $3$ 个单位时间，朵一从方格 $(4,2)$ 移动到 $(4,3)$；  \n第 $4$ 个单位时间，朵一从方格 $(4,3)$ 移动到 $(4,4)$，追上了枸杞。\n\n### 数据规模与约定\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f2epmv84.png)\n\n对全部的测试点，保证 $1 \\leq n, m \\leq 3 \\times 10^3$，$0 \\leq k,h_{i,j} \\leq n \\times m$。\n### 提示\n\n请注意大量数据读入对程序效率造成的影响，选择合适的读入方式，避免超时。\n\n### 说明\n\n本题共有 5 个附加样例文件，见附件里的 dream.zip。\n\n### 后记\n\n不过，别看朵一现在一副生气的样子，可当她追上枸杞后，大抵是不舍得真的动手吧。“嘿嘿，今日的修行结束后，该吃什么好呢？”在这飞瀑悬挂、翠竹怀抱的云梦庭中，修仙炼体，不羡尘嚣，应是这世上最逍遥的事了。", "locale": "zh-CN"}}}
{"pid": "P9066", "type": "P", "difficulty": 5, "samples": [["4\n1 2 3 4\n2 3 1 4\n", "2 4 4 0"], ["5\n1 2 3 4 5\n5 3 2 1 4\n", "0 1 1 5 1"], ["5\n2 4 6 10 12\n5 3 1 4 2\n", "0 2 2 2 10"], ["7\n2 4 6 8 12 14 16\n5 3 2 6 1 4 7\n", "8 2 8 16 16 16 0"], ["7\n2 4 6 8 12 14 16\n7 1 6 3 5 4 2\n", "0 2 2 6 2 12 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "O2优化", "洛谷月赛"], "title": "[yLOI2023] 腐草为萤", "background": "> 于盛夏之末，入夜仍灼热。  \n> 又一场离合，开始凄恻。  \n> 是扇底闪躲，或雨水摧折。  \n> 哪里都值得，恋恋不舍。  \n\n——银临《腐草为萤》", "description": "夜幕降临，在树林中的一条平直的小径上，萤火虫们受到夜晚的呼唤，纷纷外出行动。\n\n将小径视作数轴，一开始，共计 $n$ 只萤火虫在数轴的一些整点上，从左到右依次标号为 $1 \\sim n$，第 $i$ 只萤火虫的初始坐标为 $x_i$。每个萤火虫有不同的亮度值，$i$ 号萤火虫的亮度为 $a_i$。\n\n在任意时刻，对任意存活的萤火虫 $i$，它会按如下规则飞行：\n\n- 在当前仍存活的萤火虫中，找到与 $i$ 相邻的萤火虫（可能是一只或两只）中亮度最大的一只，记其编号为 $j$。如果 $a_i < a_j$，则 $i$ 会朝着 $j$ 飞行，否则 $i$ 留在原地。\n- 这里两只萤火虫『相邻』的定义是：若两只萤火虫之间不存在任何仍存活的萤火虫，则它们相邻。\n- 萤火虫飞行的速度均为每秒一个单位长度。\n\n萤火虫生命短暂，当两只萤火虫相遇之时（即两个萤火虫的坐标相同时），亮度值较低的萤火虫将耗尽生命，在小径上消失。显然，最后只会剩余 $1$ 只萤火虫。对其余的每只萤火虫，请分别求出它们耗尽生命时的坐标。", "inputFormat": "第一行是一个整数，表示萤火虫数量 $n$。  \n第二行有 $n$ 个整数，第 $i$ 个整数表示标号为 $i$ 的萤火虫初始坐标 $x_i$。数据保证 $x_i$ 单调递增。  \n第三行有 $n$ 个整数，第 $i$ 个整数表示标号为 $i$ 的萤火虫的亮度值 $a_i$。数据保证亮度值互不相同。", "outputFormat": "输出一行 $n$ 个以单个空格隔开的整数，第 $i$ 个整数表示编号为 $i$ 的萤火虫生命耗尽时的坐标。如果 $i$ 号萤火虫最后存活下来了，则第 $i$ 个数输出 0。", "hint": "### 样例 1 解释\n\n- 在第一秒时，标号为 $1$ 的萤火虫向右移动，标号为 $2$ 的萤火虫位置不变，标号为 $3$ 的萤火虫向右移动，标号为 $4$ 的萤火虫位置不变。\n- 第二秒开始时，萤火虫 $1$ 遇到萤火虫 $2$，前者亮度更低，耗尽生命，此时其坐标为 $2$；萤火虫 $3$ 遇到萤火虫 $4$，前者亮度更低，耗尽生命，此时其坐标为 $4$。\n- 接下来，萤火虫 $2$ 向右移动，直到在坐标 $4$ 遇到萤火虫 $4$，耗尽生命。\n\n### 数据规模与约定\n\n- 对于 $5\\%$ 的数据，$n = 2$。\n- 对于 $30\\%$ 的数据，$n \\leq 100$，$x_i \\leq 200$。\n- 对于 $60\\%$ 的数据，$n \\leq 10^3$。\n- 另有 $5\\%$ 的数据，满足特殊约定 A。\n- 另有 $5\\%$ 的数据，满足特殊约定 B。\n- 对 $100\\%$ 的数据，保证 $2 \\leq n \\leq 5 \\times 10^5$，$1 \\leq x_i \\leq 10^9$，$1 \\leq a_i \\leq n$。且 $x_i < x_{i + 1}$，$a_i$ 是长度为 $n$ 的排列。\n\n其中：\n\n- 特殊约定 A：数列 $a$ 单调递增。  \n- 特殊约定 B：数列 $a$ 是单峰的，仅有一个极大值。即：存在 $p$ 满足 $1 \\leq p < n$，使得 $a_1 \\sim a_p$ 单调递增，$a_p \\sim a_n$ 单调递减.\n\n### 提示\n\n- **请注意大量数据的读入输出对程序效率造成的影响，选择合适的读入输出方式，避免超时**。\n- **请注意时间复杂度的常数因子对程序运行效率造成的影响**。\n\n### 说明\n\n本题共有 7 个附加样例文件，见题目附件中的 glowworm.zip。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[yLOI2023] 腐草为萤", "background": "> 于盛夏之末，入夜仍灼热。  \n> 又一场离合，开始凄恻。  \n> 是扇底闪躲，或雨水摧折。  \n> 哪里都值得，恋恋不舍。  \n\n——银临《腐草为萤》", "description": "夜幕降临，在树林中的一条平直的小径上，萤火虫们受到夜晚的呼唤，纷纷外出行动。\n\n将小径视作数轴，一开始，共计 $n$ 只萤火虫在数轴的一些整点上，从左到右依次标号为 $1 \\sim n$，第 $i$ 只萤火虫的初始坐标为 $x_i$。每个萤火虫有不同的亮度值，$i$ 号萤火虫的亮度为 $a_i$。\n\n在任意时刻，对任意存活的萤火虫 $i$，它会按如下规则飞行：\n\n- 在当前仍存活的萤火虫中，找到与 $i$ 相邻的萤火虫（可能是一只或两只）中亮度最大的一只，记其编号为 $j$。如果 $a_i < a_j$，则 $i$ 会朝着 $j$ 飞行，否则 $i$ 留在原地。\n- 这里两只萤火虫『相邻』的定义是：若两只萤火虫之间不存在任何仍存活的萤火虫，则它们相邻。\n- 萤火虫飞行的速度均为每秒一个单位长度。\n\n萤火虫生命短暂，当两只萤火虫相遇之时（即两个萤火虫的坐标相同时），亮度值较低的萤火虫将耗尽生命，在小径上消失。显然，最后只会剩余 $1$ 只萤火虫。对其余的每只萤火虫，请分别求出它们耗尽生命时的坐标。", "inputFormat": "第一行是一个整数，表示萤火虫数量 $n$。  \n第二行有 $n$ 个整数，第 $i$ 个整数表示标号为 $i$ 的萤火虫初始坐标 $x_i$。数据保证 $x_i$ 单调递增。  \n第三行有 $n$ 个整数，第 $i$ 个整数表示标号为 $i$ 的萤火虫的亮度值 $a_i$。数据保证亮度值互不相同。", "outputFormat": "输出一行 $n$ 个以单个空格隔开的整数，第 $i$ 个整数表示编号为 $i$ 的萤火虫生命耗尽时的坐标。如果 $i$ 号萤火虫最后存活下来了，则第 $i$ 个数输出 0。", "hint": "### 样例 1 解释\n\n- 在第一秒时，标号为 $1$ 的萤火虫向右移动，标号为 $2$ 的萤火虫位置不变，标号为 $3$ 的萤火虫向右移动，标号为 $4$ 的萤火虫位置不变。\n- 第二秒开始时，萤火虫 $1$ 遇到萤火虫 $2$，前者亮度更低，耗尽生命，此时其坐标为 $2$；萤火虫 $3$ 遇到萤火虫 $4$，前者亮度更低，耗尽生命，此时其坐标为 $4$。\n- 接下来，萤火虫 $2$ 向右移动，直到在坐标 $4$ 遇到萤火虫 $4$，耗尽生命。\n\n### 数据规模与约定\n\n- 对于 $5\\%$ 的数据，$n = 2$。\n- 对于 $30\\%$ 的数据，$n \\leq 100$，$x_i \\leq 200$。\n- 对于 $60\\%$ 的数据，$n \\leq 10^3$。\n- 另有 $5\\%$ 的数据，满足特殊约定 A。\n- 另有 $5\\%$ 的数据，满足特殊约定 B。\n- 对 $100\\%$ 的数据，保证 $2 \\leq n \\leq 5 \\times 10^5$，$1 \\leq x_i \\leq 10^9$，$1 \\leq a_i \\leq n$。且 $x_i < x_{i + 1}$，$a_i$ 是长度为 $n$ 的排列。\n\n其中：\n\n- 特殊约定 A：数列 $a$ 单调递增。  \n- 特殊约定 B：数列 $a$ 是单峰的，仅有一个极大值。即：存在 $p$ 满足 $1 \\leq p < n$，使得 $a_1 \\sim a_p$ 单调递增，$a_p \\sim a_n$ 单调递减.\n\n### 提示\n\n- **请注意大量数据的读入输出对程序效率造成的影响，选择合适的读入输出方式，避免超时**。\n- **请注意时间复杂度的常数因子对程序运行效率造成的影响**。\n\n### 说明\n\n本题共有 7 个附加样例文件，见题目附件中的 glowworm.zip。", "locale": "zh-CN"}}}
{"pid": "P9067", "type": "P", "difficulty": 6, "samples": [["4 5\n1 1 2\n3 1 1 1\n2 4\n1 1 1\n1 4 3\n2 4\n1 3 3", "2\n4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2022] 虚空处刑 TEST_105", "background": "我要对不死者先生你施展魔法，希望你能看到，更多美好的事物，希望你能见识到，更多我无法见识的事物，希望...你的心...不管几次都能苏——\n\n......\n\n你的魔法为时已晚了，和知道没有办法可以救你是一样的，仿佛就像是这什么都没有的天空一样啊——\n\n星星？\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1q0z7j3z.png)\n\n......\n\n星星呢？有个星形的星星飘在天上？\n\n像那种奇妙的东西啊，是超人机械的产物哦。\n\n......\n\n已不能，继续光顾着追求星星...\n\n不死者的本体的确不见得是在那颗星星上，我也知道他们大多是脱离常轨的危险任务，这些我都明白...\n\n但天上就是飘着那种星星啊，超人机械或许就在上面，史前的睿智肯定堆积如山。\n\n......\n\n星形的理由是个迷，也看不出任何工学上的必然性。但他若是以自然物为基础打造的，那这形状就说得通了。\n\n正确来说，我认为那是个群体，而不是单一生命体，且若它是生物，那就可预想它有着机械所没有的优点，像是自然修复损毁部位，透过增殖解决经年老化问题，甚至可能是以不需管理者为前提所打造的。\n\n目前我们还不理解它是用什么系统来维持飞行轨道，但高度应该是最佳环境不会错。\n\n连次元的墙壁都能跨越的超绝知性体，怎么可能将与自身相关的重要机构，放在区区三万六千公里高的天空上？\n\n你不觉得魔法是个很极端的东西吗？光用想的就能产生出热或质量，这实在太荒唐了，超越人智，犹如神般的存在姑且先不谈，一个小小的生命，人类的亚种，魔法使们怎么可能会有如此强大的力量？\n\n魔法使换句话说就是水龙头，水源则是另在别处。\n\n星星是超人机械所撒下的，供应魔力与抑制魔法的生命机器，除此以外可能什么都不是吧。\n\n......\n\n我们已经不做星星的梦了。\n\n魔法产生的原理，一旦被世人知道，就会引发末日战争。现在我们只能尽全力透过操控情报，让世人不对此事感兴趣。", "description": "给定一棵 $n$ 个节点的树，第 $i$ 个点有点权 $a_i$。\n\n定义一个点 $x$ 所在的极大同色连通块为一个**极大的**点集 $S$，满足 $x\\in S$，且对任意点集中的元素 $i,j$，可以找到一个节点序列 $p_1,p_2,...p_t$，满足 $p_1=i$，$p_t=j$，且对任意 $k$ 为 $[1,t)$ 中的整数，满足 $p_k$ 与 $p_{k+1}$ 在树上相邻，且 $a_{p_k}=a_{p_{k+1}}$，且 $p_k\\in S$。\n\n有 $m$ 次操作：\n\n`1 x y`：给出一个点 $x$ ，将其所在的极大同色连通块中每个点的点权修改为 $y$。\n\n`2 x`：给出一个点 $x$，查询其所在的极大同色连通块的大小。", "inputFormat": "第一行两个数 $n,m$。\n\n第二行 $n-1$ 个数，第 $i$ 个数表示树上第 $i+1$ 的节点的父亲节点的编号，保证父亲节点的编号比该节点小。\n\n第三行 $n$ 个数，第 $i$ 个数表示 $a_i$。\n\n之后 $m$ 行，每行形如 `1 x y` 或 `2 x`，意义如上述。", "outputFormat": "对每个 $2$ 操作，输出一行一个数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：ccz181078，Data：ccz181078\n\n对于 $20\\%$ 的数据，满足 $n,m\\leq2\\times 10^3$。\n\n对于 $40\\%$ 的数据，满足 $n,m\\leq2\\times 10^5$。\n\n对于另外 $30\\%$ 的数据，满足 $1\\le a_i,y\\le 2$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m,a_i,x,y\\le10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2022] 虚空处刑 TEST_105", "background": "我要对不死者先生你施展魔法，希望你能看到，更多美好的事物，希望你能见识到，更多我无法见识的事物，希望...你的心...不管几次都能苏——\n\n......\n\n你的魔法为时已晚了，和知道没有办法可以救你是一样的，仿佛就像是这什么都没有的天空一样啊——\n\n星星？\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1q0z7j3z.png)\n\n......\n\n星星呢？有个星形的星星飘在天上？\n\n像那种奇妙的东西啊，是超人机械的产物哦。\n\n......\n\n已不能，继续光顾着追求星星...\n\n不死者的本体的确不见得是在那颗星星上，我也知道他们大多是脱离常轨的危险任务，这些我都明白...\n\n但天上就是飘着那种星星啊，超人机械或许就在上面，史前的睿智肯定堆积如山。\n\n......\n\n星形的理由是个迷，也看不出任何工学上的必然性。但他若是以自然物为基础打造的，那这形状就说得通了。\n\n正确来说，我认为那是个群体，而不是单一生命体，且若它是生物，那就可预想它有着机械所没有的优点，像是自然修复损毁部位，透过增殖解决经年老化问题，甚至可能是以不需管理者为前提所打造的。\n\n目前我们还不理解它是用什么系统来维持飞行轨道，但高度应该是最佳环境不会错。\n\n连次元的墙壁都能跨越的超绝知性体，怎么可能将与自身相关的重要机构，放在区区三万六千公里高的天空上？\n\n你不觉得魔法是个很极端的东西吗？光用想的就能产生出热或质量，这实在太荒唐了，超越人智，犹如神般的存在姑且先不谈，一个小小的生命，人类的亚种，魔法使们怎么可能会有如此强大的力量？\n\n魔法使换句话说就是水龙头，水源则是另在别处。\n\n星星是超人机械所撒下的，供应魔力与抑制魔法的生命机器，除此以外可能什么都不是吧。\n\n......\n\n我们已经不做星星的梦了。\n\n魔法产生的原理，一旦被世人知道，就会引发末日战争。现在我们只能尽全力透过操控情报，让世人不对此事感兴趣。", "description": "给定一棵 $n$ 个节点的树，第 $i$ 个点有点权 $a_i$。\n\n定义一个点 $x$ 所在的极大同色连通块为一个**极大的**点集 $S$，满足 $x\\in S$，且对任意点集中的元素 $i,j$，可以找到一个节点序列 $p_1,p_2,...p_t$，满足 $p_1=i$，$p_t=j$，且对任意 $k$ 为 $[1,t)$ 中的整数，满足 $p_k$ 与 $p_{k+1}$ 在树上相邻，且 $a_{p_k}=a_{p_{k+1}}$，且 $p_k\\in S$。\n\n有 $m$ 次操作：\n\n`1 x y`：给出一个点 $x$ ，将其所在的极大同色连通块中每个点的点权修改为 $y$。\n\n`2 x`：给出一个点 $x$，查询其所在的极大同色连通块的大小。", "inputFormat": "第一行两个数 $n,m$。\n\n第二行 $n-1$ 个数，第 $i$ 个数表示树上第 $i+1$ 的节点的父亲节点的编号，保证父亲节点的编号比该节点小。\n\n第三行 $n$ 个数，第 $i$ 个数表示 $a_i$。\n\n之后 $m$ 行，每行形如 `1 x y` 或 `2 x`，意义如上述。", "outputFormat": "对每个 $2$ 操作，输出一行一个数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：ccz181078，Data：ccz181078\n\n对于 $20\\%$ 的数据，满足 $n,m\\leq2\\times 10^3$。\n\n对于 $40\\%$ 的数据，满足 $n,m\\leq2\\times 10^5$。\n\n对于另外 $30\\%$ 的数据，满足 $1\\le a_i,y\\le 2$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m,a_i,x,y\\le10^6$。", "locale": "zh-CN"}}}
{"pid": "P9068", "type": "P", "difficulty": 6, "samples": [["5\n3 1 2 1 5 \n1\n3 3", "3\n1"], ["6\n1 1 4 5 1 4\n3\n1 5\n1 1\n4 4", "3\n3\n3\n1"], ["15\n6 14 12 12 6 8 9 3 8 14 14 15 6 15 2 \n10\n12 13\n10 10\n14 9\n8 8\n11 11\n5 8\n1 6\n11 12\n2 13\n1 9", "23\n25\n29\n30\n24\n29\n29\n29\n24\n20\n20"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 51200, 51200, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 51200, 51200, 51200, 51200, 51200]}, "tags": ["2022", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2022] 超人机械 TEST_95", "background": "距今 300 年前，史前科学文明跨越了界限。出现了凌驾人类的人工智能，也就是超人机械。\n\n不为人知的诞生，等察觉到时，世界已经在【他】的手中了。\n\n究竟他身在何处，有什么样的外貌，虽然直到最后都没有人知道。但他好像可以出现在任何地方，化为任何样貌。\n\n既非敌对，也非压制，单纯只是力量上占上风而已。也不太常出手进行干涉。我想一定是人类对他来说无所谓吧。\n\n但即使如此，他还是会帮人实现愿望，魔人或魔龙，各式各样的不可思议，都是有人追求才被造出来的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qmrcnbwc.png)\n\n......\n\n然而在某一天，超人机械消失了。\n\n被腐铁菌干掉了，只是躲了起来，启程前往次元的另一端等，众说纷纭。留下的只有超人机械莫名其妙的发明品。和被世人自己弄得一团乱的世界。\n\n这座树海一定也是超人机械的产物。魔力会一下子增幅，一下子又消耗掉对吧？魔法是从异次元将力量取出的能力，是超出人类理解范围的技术。", "description": "给定一个序列 $a$ ，我们定义一个二元组 $(i,j)$ 为一个逆序对当且仅当 $i<j$ 且 $a_i>a_j$ 。定义两个逆序对 $(i_1,j_1),(i_2,j_2)$ **本质不同** 当且仅当 $a_{i_1}\\ne a_{i_2}$ 或 $a_{j_1}\\ne a_{j_2}$ 。\n\n现在给出 $a$ 序列，问本质不同逆序对个数。\n\n这还不够。\n\n现在有 $q$ 组修改，每一次修改形如 $x~y$ 表示修改 $a_x$ 为 $y$ ，每一次修改 **不互相独立** ，即这一次修改会影响到后面的所有修改。\n\n你需要对于每一次修改输出序列本质不同逆序对个数。\n\n为了体现本题的不同解法，本题不同测试点拥有不同的时空限制。", "inputFormat": "第一行一个整数 $n$ ，表示序列长度。\n\n第二行 $n$ 个整数 $a_i$ ，表示序列 $a$ 。\n\n第三行一个整数 $q$ ，表示询问组数。\n\n后面 $q$ 行每行两个整数表示一次修改。", "outputFormat": "一行一个整数，表示初始序列中本质不同逆序对个数。\n\n后面 $q$ 行每行一个整数，第 $i + 1$ 行表示第 $i$ 次修改后序列本质不同逆序对个数。", "hint": "Idea：DPair，Solution：DPair，Code：DPair，Data：DPair\n\n对于 $100\\%$ 的数据 $1\\le n \\le 10^5, 0\\le q \\le 10^5, 1\\le a_i, x, y \\le n$ 。\n\n以下为子任务：（留空部分表示无特殊限制）\n\n| 测试点编号 | $n$       | $q$       | $a_i,y$ | 特殊性质 | 时空限制 | 对应大样例 |\n| ---------- | --------- | --------- | ------- | -------- | -------- | ---------- |\n| 1-3        | $\\le2000$ | $\\le2000$ |         | A        | 1s/500MB | Sample1    |\n| 4-5        |           | $=0$      |         | A        | 1s/50MB  | Sample2    |\n| 6-10       |           |           |         | A        | 3s/500MB | Sample3    |\n| 11-15      |           |           |         |          | 3s/500MB |            |\n| 16-20      |           |           |         |          | 1s/50MB  |            |\n\n特殊性质 A：保证数据完全随机", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2022] 超人机械 TEST_95", "background": "距今 300 年前，史前科学文明跨越了界限。出现了凌驾人类的人工智能，也就是超人机械。\n\n不为人知的诞生，等察觉到时，世界已经在【他】的手中了。\n\n究竟他身在何处，有什么样的外貌，虽然直到最后都没有人知道。但他好像可以出现在任何地方，化为任何样貌。\n\n既非敌对，也非压制，单纯只是力量上占上风而已。也不太常出手进行干涉。我想一定是人类对他来说无所谓吧。\n\n但即使如此，他还是会帮人实现愿望，魔人或魔龙，各式各样的不可思议，都是有人追求才被造出来的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qmrcnbwc.png)\n\n......\n\n然而在某一天，超人机械消失了。\n\n被腐铁菌干掉了，只是躲了起来，启程前往次元的另一端等，众说纷纭。留下的只有超人机械莫名其妙的发明品。和被世人自己弄得一团乱的世界。\n\n这座树海一定也是超人机械的产物。魔力会一下子增幅，一下子又消耗掉对吧？魔法是从异次元将力量取出的能力，是超出人类理解范围的技术。", "description": "给定一个序列 $a$ ，我们定义一个二元组 $(i,j)$ 为一个逆序对当且仅当 $i<j$ 且 $a_i>a_j$ 。定义两个逆序对 $(i_1,j_1),(i_2,j_2)$ **本质不同** 当且仅当 $a_{i_1}\\ne a_{i_2}$ 或 $a_{j_1}\\ne a_{j_2}$ 。\n\n现在给出 $a$ 序列，问本质不同逆序对个数。\n\n这还不够。\n\n现在有 $q$ 组修改，每一次修改形如 $x~y$ 表示修改 $a_x$ 为 $y$ ，每一次修改 **不互相独立** ，即这一次修改会影响到后面的所有修改。\n\n你需要对于每一次修改输出序列本质不同逆序对个数。\n\n为了体现本题的不同解法，本题不同测试点拥有不同的时空限制。", "inputFormat": "第一行一个整数 $n$ ，表示序列长度。\n\n第二行 $n$ 个整数 $a_i$ ，表示序列 $a$ 。\n\n第三行一个整数 $q$ ，表示询问组数。\n\n后面 $q$ 行每行两个整数表示一次修改。", "outputFormat": "一行一个整数，表示初始序列中本质不同逆序对个数。\n\n后面 $q$ 行每行一个整数，第 $i + 1$ 行表示第 $i$ 次修改后序列本质不同逆序对个数。", "hint": "Idea：DPair，Solution：DPair，Code：DPair，Data：DPair\n\n对于 $100\\%$ 的数据 $1\\le n \\le 10^5, 0\\le q \\le 10^5, 1\\le a_i, x, y \\le n$ 。\n\n以下为子任务：（留空部分表示无特殊限制）\n\n| 测试点编号 | $n$       | $q$       | $a_i,y$ | 特殊性质 | 时空限制 | 对应大样例 |\n| ---------- | --------- | --------- | ------- | -------- | -------- | ---------- |\n| 1-3        | $\\le2000$ | $\\le2000$ |         | A        | 1s/500MB | Sample1    |\n| 4-5        |           | $=0$      |         | A        | 1s/50MB  | Sample2    |\n| 6-10       |           |           |         | A        | 3s/500MB | Sample3    |\n| 11-15      |           |           |         |          | 3s/500MB |            |\n| 16-20      |           |           |         |          | 1s/50MB  |            |\n\n特殊性质 A：保证数据完全随机", "locale": "zh-CN"}}}
{"pid": "P9069", "type": "P", "difficulty": 7, "samples": [["10 10\n0 1 2 3 4 5 6 7 8 9\n1 5 10 5\n2 1 10\n1 23 29 23\n2 21 19\n1 1048573 1048570 1048574\n2 1048573 1048566\n1 1048573 1048569 1048575\n2 1048575 1048564\n1 1048572 1048567 1048572\n2 1048572 1048567", "20\n18446744073709551615\n18446744073709551614\n18446744073709551613\n18446744073709551606"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2022] 堕天作战 TEST_98", "background": "明明超越人智，君临了至高点，却总是给些奇怪的奇迹。当然也会有不满的人出现，想要取回灵长的宝座。\n\n有许多的国家，组织，个人，用各种方法挑战超人机械。要让天上宛如神的他，堕落于地的众多手段——被称作是堕天作战。\n\n为了从超人机械手中抢夺神性而被用上的手段里，有一个天马行空的心理战。希望他能抛下机械的身份理解人类活着的美好——这样。\n\n那就像是狗在对着人类说当条狗吧，像那种狗我会嗤之以鼻的。但是没想到，他接受了那个邀约。不管是好奇心，打发时间，或是同情，总之他将降级为人类的分身送到这世上了。\n\n那时正逢地壳变动或是寒冷化之类的地球规模的异变，而魔人在此时趁机崛起，撒下了腐铁菌，让科学文明画下句点。而超人机械则是一副事不关己的样子。\n\n分身似乎不断地送了好几位来，但都死了，在那种世界里。不管试多少次都在途中倒下，还没体会到人类的美好就死了。\n\n于是出现了分身第二弹——不会死！本末倒置对吧，那已经不是人类了。\n\n......\n\n我想应该不是那样。\n\n超人机械是足以发明出魔法的存在吧？虽然我觉得不死者这种存在听起来很假。\n\n但这么厉害的机械，若真的想理解人类，只要随便抓个几十，几百人，当作零件装到自家身上，马上就能解决了吧？\n\n......\n\n该怎么说呢，我觉得...为了理解人类这个见解，有点牵强了呢？\n\n从包括人类在内更上一层楼的知性，是如何诞生的角度来思考的话。\n\n而且我认为，超人机械，是透过机械化——达成超越的人类。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t2yh2k2u.png)\n\n......\n\n宇宙是很严峻的，真空，极寒，辐射，我的魔力能否起作用，完全是未知数。\n\n就算是要打造火箭，也不知道要耗费多少资源才能连飞行员的生存设备也一并完善...\n\n但只要有不死者就能解决，不会错的。", "description": "给定一个长为 $n$ 的序列 $a$，有两种操作，共 $m$ 次：\n\n1. 给定 $l$ $r$ $x$，对于所有 $i$ 满足 $l\\le i\\le r$ 且 $a_i \\neq x$，$a_i\\leftarrow a_i-x$。\n2. 给定 $l$ $r$，求对于所有 $i$ 满足 $l\\le i\\le r$ 且 $a_i\\neq 0$，$a_i$ 的和。", "inputFormat": "第一行两个数 $n,m$。\n\n第二行 $n$ 个用空格隔开的数表示序列 $a$。\n\n之后 $m$ 行，每行三个或四个数：\n\n若输入为 `1 l r x`，则表示对区间 $[l,r]$ 进行一次 $1$ 操作，若输入为 `2 l r`，则表示对区间 $[l,r]$ 进行一次 $2$ 操作。\n\n本题强制在线，所有输入的 $l,r,x$ 均需要异或 $lastans$，其定义为上一次询问操作得到的答案对 $2^{20}$ 取模后的值，若之前没有询问操作，则为 $0$。", "outputFormat": "对每个 $2$ 操作，输出一行一个数表示答案对 $2^{64}$ 取模后的结果。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：w33z8kqrqk8zzzx33，Data：w33z8kqrqk8zzzx33\n\n对于 $5\\%$ 的数据，$n,m\\le 1000$。\n\n对于 $30\\%$ 的数据，$n,m\\le 5\\times10^4$。\n\n对于另外 $20\\%$ 的数据，$l=1,r=n$。\n\n对于另外 $20\\%$ 的数据，$x=1$。\n\n对于 $100\\%$ 的数据 $1\\le n,m \\le 5\\times10^5, 0\\le a_i, x \\le10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2022] 堕天作战 TEST_98", "background": "明明超越人智，君临了至高点，却总是给些奇怪的奇迹。当然也会有不满的人出现，想要取回灵长的宝座。\n\n有许多的国家，组织，个人，用各种方法挑战超人机械。要让天上宛如神的他，堕落于地的众多手段——被称作是堕天作战。\n\n为了从超人机械手中抢夺神性而被用上的手段里，有一个天马行空的心理战。希望他能抛下机械的身份理解人类活着的美好——这样。\n\n那就像是狗在对着人类说当条狗吧，像那种狗我会嗤之以鼻的。但是没想到，他接受了那个邀约。不管是好奇心，打发时间，或是同情，总之他将降级为人类的分身送到这世上了。\n\n那时正逢地壳变动或是寒冷化之类的地球规模的异变，而魔人在此时趁机崛起，撒下了腐铁菌，让科学文明画下句点。而超人机械则是一副事不关己的样子。\n\n分身似乎不断地送了好几位来，但都死了，在那种世界里。不管试多少次都在途中倒下，还没体会到人类的美好就死了。\n\n于是出现了分身第二弹——不会死！本末倒置对吧，那已经不是人类了。\n\n......\n\n我想应该不是那样。\n\n超人机械是足以发明出魔法的存在吧？虽然我觉得不死者这种存在听起来很假。\n\n但这么厉害的机械，若真的想理解人类，只要随便抓个几十，几百人，当作零件装到自家身上，马上就能解决了吧？\n\n......\n\n该怎么说呢，我觉得...为了理解人类这个见解，有点牵强了呢？\n\n从包括人类在内更上一层楼的知性，是如何诞生的角度来思考的话。\n\n而且我认为，超人机械，是透过机械化——达成超越的人类。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t2yh2k2u.png)\n\n......\n\n宇宙是很严峻的，真空，极寒，辐射，我的魔力能否起作用，完全是未知数。\n\n就算是要打造火箭，也不知道要耗费多少资源才能连飞行员的生存设备也一并完善...\n\n但只要有不死者就能解决，不会错的。", "description": "给定一个长为 $n$ 的序列 $a$，有两种操作，共 $m$ 次：\n\n1. 给定 $l$ $r$ $x$，对于所有 $i$ 满足 $l\\le i\\le r$ 且 $a_i \\neq x$，$a_i\\leftarrow a_i-x$。\n2. 给定 $l$ $r$，求对于所有 $i$ 满足 $l\\le i\\le r$ 且 $a_i\\neq 0$，$a_i$ 的和。", "inputFormat": "第一行两个数 $n,m$。\n\n第二行 $n$ 个用空格隔开的数表示序列 $a$。\n\n之后 $m$ 行，每行三个或四个数：\n\n若输入为 `1 l r x`，则表示对区间 $[l,r]$ 进行一次 $1$ 操作，若输入为 `2 l r`，则表示对区间 $[l,r]$ 进行一次 $2$ 操作。\n\n本题强制在线，所有输入的 $l,r,x$ 均需要异或 $lastans$，其定义为上一次询问操作得到的答案对 $2^{20}$ 取模后的值，若之前没有询问操作，则为 $0$。", "outputFormat": "对每个 $2$ 操作，输出一行一个数表示答案对 $2^{64}$ 取模后的结果。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：w33z8kqrqk8zzzx33，Data：w33z8kqrqk8zzzx33\n\n对于 $5\\%$ 的数据，$n,m\\le 1000$。\n\n对于 $30\\%$ 的数据，$n,m\\le 5\\times10^4$。\n\n对于另外 $20\\%$ 的数据，$l=1,r=n$。\n\n对于另外 $20\\%$ 的数据，$x=1$。\n\n对于 $100\\%$ 的数据 $1\\le n,m \\le 5\\times10^5, 0\\le a_i, x \\le10^9$。", "locale": "zh-CN"}}}
{"pid": "P9070", "type": "P", "difficulty": 7, "samples": [["2\n3\n1 2 2\n2 3 3\n3 1 1\n3\n1 2 3\n2 3 1\n3 2 1", "2\n1 3 3 1\n2 3 3 2\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "Special Judge", "CTSC/CTS"], "title": "[CTS2023] 琪露诺的符卡交换", "background": "", "description": "受异变的影响，琪露诺发现封印了自己能力的卡片正在幻想乡中流通。\n\n琪露诺调查之后，发现一共有 $n$ 种不同的卡片，每种卡片的数量总共恰好是 $n$ 张，有 $n$ 个人购买了这些卡片，每个人都恰好买了 $n$ 张卡片，并且可能会买到相同种类的卡片。\n\n但是琪露诺想要让每个人都正好持有 $n$ 种卡片，于是她把这 $n$ 个人聚集在一起，想要通过卡片交换的形式达成她的目的。\n\n琪露诺每次会选择两个人持有的某张卡片进行交换，直到每个人都正好持有 $n$ 种卡片为止。\n\n由于每次交换都会减少卡片上的魔力，所以琪露诺想要每张卡片最多被交换一次。\n\n但是她对如何进行交换犯了难，于是她转而寻求你的帮助。\n\n你需要告诉她交换的过程，或者告诉她不存在这样的方案。", "inputFormat": "第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据，第一行一个正整数 $n$，含义如题所示。\n\n接下来 $n$ 行，每行输入 $n$ 个正整数，其中第 $i$ 行的第 $j$ 个正整数表示第 $i$ 个人持有的第 $j$ 张卡片的种类。", "outputFormat": "对于每组数据，如果不存在能够让每个人都持有 $n$ 种卡片的方案，输出一行 $-1$。\n\n否则首先输出一行一个正整数 $m$，表示交换次数。\n\n接下来 $m$ 行，每行输出四个正整数 $a,b,c,d$，表示第 $a$ 个人的第 $b$ 张卡片，与第 $c$ 个人的第 $d$ 张卡片进行一次交换。\n\n注意你需要保证不存在某张卡片被交换了两次，并且交换结束后每个人都正好持有 $n$ 种卡片。", "hint": "**【样例解释】**\n\n第一组数据，我们第一次交换第一个人的第三张卡牌，和第三个人的第一张卡牌；\n\n第二次交换第二个人的第三张卡牌，和第三个人的第二张卡牌；\n\n一共交换两次，可以使得所有人都持有三种卡牌。\n\n输出其它方案也是被允许的。\n\n第二组数据，因为一开始所有人都持有了三种卡牌，所以无需交换，输出一行 $0$ 即可。\n\n**【数据范围】**\n\n子任务 $1$（$20$ 分）：每个人只持有一种卡片。\n\n子任务 $2$（$20$ 分）：每个人持有至少 $n-1$ 张同一种类的卡片。\n\n子任务 $3$（$60$ 分）：无特殊限制。\n\n对于所有数据，满足 $\\sum\\limits_{i=1}^{T}n_{i} \\leq 200$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CTS2023] 琪露诺的符卡交换", "background": "", "description": "受异变的影响，琪露诺发现封印了自己能力的卡片正在幻想乡中流通。\n\n琪露诺调查之后，发现一共有 $n$ 种不同的卡片，每种卡片的数量总共恰好是 $n$ 张，有 $n$ 个人购买了这些卡片，每个人都恰好买了 $n$ 张卡片，并且可能会买到相同种类的卡片。\n\n但是琪露诺想要让每个人都正好持有 $n$ 种卡片，于是她把这 $n$ 个人聚集在一起，想要通过卡片交换的形式达成她的目的。\n\n琪露诺每次会选择两个人持有的某张卡片进行交换，直到每个人都正好持有 $n$ 种卡片为止。\n\n由于每次交换都会减少卡片上的魔力，所以琪露诺想要每张卡片最多被交换一次。\n\n但是她对如何进行交换犯了难，于是她转而寻求你的帮助。\n\n你需要告诉她交换的过程，或者告诉她不存在这样的方案。", "inputFormat": "第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据，第一行一个正整数 $n$，含义如题所示。\n\n接下来 $n$ 行，每行输入 $n$ 个正整数，其中第 $i$ 行的第 $j$ 个正整数表示第 $i$ 个人持有的第 $j$ 张卡片的种类。", "outputFormat": "对于每组数据，如果不存在能够让每个人都持有 $n$ 种卡片的方案，输出一行 $-1$。\n\n否则首先输出一行一个正整数 $m$，表示交换次数。\n\n接下来 $m$ 行，每行输出四个正整数 $a,b,c,d$，表示第 $a$ 个人的第 $b$ 张卡片，与第 $c$ 个人的第 $d$ 张卡片进行一次交换。\n\n注意你需要保证不存在某张卡片被交换了两次，并且交换结束后每个人都正好持有 $n$ 种卡片。", "hint": "**【样例解释】**\n\n第一组数据，我们第一次交换第一个人的第三张卡牌，和第三个人的第一张卡牌；\n\n第二次交换第二个人的第三张卡牌，和第三个人的第二张卡牌；\n\n一共交换两次，可以使得所有人都持有三种卡牌。\n\n输出其它方案也是被允许的。\n\n第二组数据，因为一开始所有人都持有了三种卡牌，所以无需交换，输出一行 $0$ 即可。\n\n**【数据范围】**\n\n子任务 $1$（$20$ 分）：每个人只持有一种卡片。\n\n子任务 $2$（$20$ 分）：每个人持有至少 $n-1$ 张同一种类的卡片。\n\n子任务 $3$（$60$ 分）：无特殊限制。\n\n对于所有数据，满足 $\\sum\\limits_{i=1}^{T}n_{i} \\leq 200$。", "locale": "zh-CN"}}}
{"pid": "P9071", "type": "P", "difficulty": 7, "samples": [["0 6 1\n97429867398990605044182047185430790478", "Message:    97429867398990605044182047185430790478\nTaking off: 10101\nLanding:    10011\nReceived:   97429867398990605044182047185430790478\n\nAccepted using 5 pigeons."]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2023", "交互题", "Special Judge", "通信题", "CTSC/CTS"], "title": "[CTS2023] 鸽子（无防作弊）", "background": "\n\n小 E 和小 F 是一对好闺蜜。\n\n", "description": "这是一道**通信题**。\n\n小 E 有一些很重要的信息要传给小 F。信息的内容可以用一个不超过 $128$ 位的二进制整数来表示。\n\n但是小 E 现在只有鸽子。好多好多的鸽子。黑色和白色的鸽子。\n\n小 E 可以让不同颜色的鸽子按一定的顺序起飞，飞到小 F 那里，这样小 F 就可以根据降落的鸽子的颜色顺序来知道信息的具体内容了。当然鸽子的数量是需要约定好且固定的，不然小 F 可能会在看到所有鸽子之前误以为所有的鸽子都已经飞过来了。\n\n但是众所周知，“鸽子”一词总是和“时间”联系在一起。鸽子会放鸽子。不过小 E 的鸽子还算守时，起飞和降落的顺序之差不会超过一个正整数 $k$。形式化地，设起飞的第 $i$ 只鸽子是第 $p_i$ 个降落的，那么 $\\{p_i\\}$ 是一个排列且对于所有的 $i$，$\\left|i-p_i\\right|\\le k$。\n\n小 E 自然是考虑到了这些情况，并提前与小 F 约定好了。请问如果你是小 E 你要怎样做下约定以及发送信息呢？\n\n### 实现细节\n\n【备注】：提交此题需要在所有函数前加上 `extern \"C\"`。\n\n你不需要也不应该实现主函数。你需要实现三个函数 `pigeon_num`，`send` 和 `receive`。\n\n函数 `pigeon_num` 的接口如下：\n\n```cpp\nint pigeon_num(int Taskid, int k);\n```\n\n- 该函数传入子任务编号 `Taskid` 和题目中参数 `k` 的值。\n- 该函数需要返回小 E 需要放飞的鸽子数量 $n$。\n\n函数 `send` 的接口如下：\n\n```cpp\nstd::string send(int Taskid, int n, int k, __uint128_t msg);\n```\n\n- 该函数传入子任务编号 `Taskid`，`pigeon_num` 函数的返回值 `n`，题目中的参数 `k` 以及需要发送的信息 `msg`。\n- 该函数需要返回一个长度恰好为 $n$ 的字符串，其中下标为 $i(0\\le i\\lt n)$ 的位置表示小 E 放飞的第 $i+1$ 只鸽子的颜色，`0` 表示黑色，`1` 表示白色。\n\n函数 `receive` 的接口如下：\n\n```cpp\n__uint128_t receive(int Taskid, int k, const std::string &msg);\n```\n\n- 该函数传入子任务编号 `Taskid`，题目中的参数 `k` 以及小 F 看到的鸽子的降落顺序 `msg`。\n- `msg` 为一个长度为 $n$ 的字符串，其中下标为 $i(0\\le i\\lt n)$ 的位置表示小 F 看到的第 $i+1$ 只降落的鸽子的颜色，`0` 表示黑色，`1` 表示白色。`msg` 的值与某次调用 `send` 函数的返回值有着题目描述中所满足的关系。\n- 该函数需要正确返回小 E 发送的信息的内容。\n\n你可以参考下发的样例程序 `pigeon.cpp`，也可以从头开始写一个程序。\n\n在评测时，交互库会被运行**两次**，**两次运行独立计算时间和空间**。\n\n在第一次运行时，交互库会先调用一次 `pigeon_num` 函数，然后调用不超过 $1000$ 次 `send` 函数。\n\n在第二次运行时，交互库会调用不超过 $10000$ 次 `receive` 函数。\n\n保证在题目限制下，评测交互库的运行时间不超过 $1\\texttt{s}$，运行内存不超过 $512\\textrm{MB}$。也就是说，你实际可以利用的时间至少为 $2\\texttt{s}$，空间至少为 $1.5\\textrm{GB}$。\n\n**由于洛谷暂不支持通信题的评测，评测方式逻辑与下发交互库类似。这意味着可以轻松地作弊。E_Space 在这里不追究有关于此的作弊行为，但请不要写到题解中去。**\n\n### 测试程序方式\n\n将样例交互库 `grader.cpp` 和你的代码 `pigeon.cpp` 置于同一目录下并在终端中输入如下命令进行编译：\n\n```bash\ng++ pigeon.cpp grader.cpp -o grader -g -Wall --std=c++11\n```\n\n然后运行 `./grader` 即可。样例交互库使用标准输入和标准输出，**只需要运行一次**。\n\n注意下发的交互库与实际评测时使用的交互库的实现不同。比如在下发的交互库中，通过 `send` 函数修改的全局变量的值能够被 `receive` 函数查看。\n\n", "inputFormat": "第一行三个非负整数 $\\mathrm{Taskid}$，$k$，$T$。其中 $\\mathrm{Taskid}$ 表示子任务编号，$T$ 表示发送信息的数量。\n\n接下来 $T$ 行，每行一个非负 $128$ 位整数表示信息的内容。\n\n", "outputFormat": "如果你的程序在该测试点上是正确的，对于每一条信息，交互库会输出四行内容。\n\n- 第一行 `Message` 为小 E 想要发送的信息，即 `send` 函数中参数 `msg` 的内容。\n- 第二行 `Taking off` 为鸽子起飞的顺序，即 `send` 函数的返回值。\n- 第三行 `Landing` 为鸽子降落的顺序，即 `receive` 函数中参数 `msg` 的内容。\n- 第四行 `Received` 为小 F 解读出来的信息，即 `receive` 函数的返回值。\n- 最后一行输出 `Accepted using <num> pigeon(s).`，其中 `<num>` 是小 E 放飞的鸽子的数量，即 `pigeon_num` 函数的返回值。\n\n否则如果程序正常退出，交互库会输出以下内容之一：\n\n- `Invalid number of pigeons.`：输出这句话说明 `pigeon_num` 函数的返回值不在 $[1,4000]$ 之间。\n- `Invalid color of pigeon.`：输出这句话说明 `send` 函数的返回值中有非 `0` 或 `1` 的字符。\n- `Too few or too many pigeons taking off.`：输出这句话说明 `send` 函数的返回值的长度不等于 `pigeon_num` 函数的返回值。\n- `Received wrong message.`：输出这句话说明 `receive` 函数的返回值与 `send` 函数中的参数 `msg` 不相等。\n\n一旦交互库输出了报错语句，交互库程序就会立即停止运行。\n\n", "hint": "#### 样例解释\n\n这是样例交互库在下发样例程序 `pigeon.cpp` 在样例输入下的输出。\n\n对于小 E 来说，$97429867398990605044182047185430790478$ 是一个很有意义的数。所以只需要放飞少量鸽子就够了。\n\n### 子任务\n\n子任务 $0$（$0.01$ 分）：样例。保证信息对应的整数等于 $97429867398990605044182047185430790478$。下发的 `pigeon.cpp` 能够通过样例。该子任务的评测结果会显示在评测结果中。\n\n子任务 $1$（$3.99$ 分）：保证信息对应的整数小于 $1024$。 $k\\le 20$。\n\n子任务 $2$（$12$ 分）：$k=1$。保证信息对应的整数小于 $1048576$。\n\n子任务 $3\\sim 9$（每个子任务 $12$ 分，共 $84$ 分）：$k\\le 20$。\n\n**由于洛谷不支持小数得分，本题的得分显示将乘以 100 来表示保留两位小数之后的结果。**\n\n### 评分方式\n\n评测时，你只需在 OJ 上提交你的源程序，修改下发的其他文件不会对评测结果产生影响。\n\n本题首先会受到和传统题相同的限制，例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。\n\n对于每个子任务，如果你的程序有以下行为，将会被判为 $0$ 分：\n\n- `pigeon_num` 函数的返回值不在 $[1,4000]$ 之内；\n- `send` 函数的返回值的长度不等于 `pigeon_num` 函数的返回值；\n- `send` 函数的返回值的内容包含 `0` 或 `1` 之外的字符；\n- `receive` 函数没有正确地返回小 E 发送的信息内容。\n\n此外，对于每个子任务，你的得分与小 E 放飞的鸽子的数量，即 `pigeon_num` 函数的返回值有关。设这个值为 $n$。\n\n在子任务 $1 \\sim 2$ 中，如果 $n\\le 4000$，那么你就能得到该测试点的满分，否则得到零分。\n\n在子任务 $3\\sim 9$ 中，同一个子任务中所有测试点的 $k$ 的值相同，且编号越大的子任务中 $k$ 的值越大。设 $C(k)$ 为一个关于 $k$ 的函数，则\n\n- 如果 $n\\le C(k)$，那么你可以得到该测试点的满分。\n- 若 $n\\le C(k)+5$，那么在此范围内 $n$ 的值每多 $1$，你就会失去该测试点满分乘以 $2\\%$ 的分数。\n- 若 $C(k)+5 \\lt n\\le \\lfloor 1.1\\times C(k)\\rfloor$，那么在此范围内 $n$ 的值每多 $1$，你就会额外失去该测试点满分乘以 $400\\%/C(k)$ 的分数。\n- 若 $n\\gt \\lfloor 1.1\\times C(k)\\rfloor$，那么在此范围内 $n$ 的值每多 $1$，你就会额外失去该测试点满分乘以 $40\\%/C(k)$ 的分数。\n- 若你的答案正确，你至少可以得到 $1$ 分。\n\n换句话说，你在一个测试点的得分等于 $\\max(1, 12\\times \\min(1, f_k(n)))$，其中 $f_k(n)$ 是一个关于 $n$ 的分段线性函数，满足：\n\n- $f_k(C(k))=1$\n- 两个拐点的横坐标分别为 $C(k)+5$ 和 $\\lfloor 1.1\\times C(k)\\rfloor$。\n- 被两个拐点分割所形成的三段区间的斜率依次为 $-0.02$，$-4/C(k)$ 和 $-0.4/C(k)$。\n\n\n你的每个子任务的得分是子任务中所有测试点得分的最小值。\n\n$C(k)$ 的函数值由下表给出。在下表中未出现的 $k$ 值不会出现在子任务 $3\\sim 9$ 的测试数据中。\n\n| $k$ | $1$ | $2$ | $5$ | $7$ | $10$ | $14$ | $20$ |\n| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |\n| $C(k)$ | $206$ | $284$ | $485$ | $605$ | $773$ | $983$ | $1277$ |\n\n**通过访问输入输出文件、攻击评测系统或攻击评测库等方式得分属于作弊行为，所得分数无效。**\n\n**由于洛谷暂不支持通信题的评测，评测方式逻辑与下发交互库类似。这意味着可以轻松地作弊。E_Space 在这里不追究有关于此的作弊行为，但请不要写到题解中去。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CTS2023] 鸽子（无防作弊）", "background": "\n\n小 E 和小 F 是一对好闺蜜。\n\n", "description": "这是一道**通信题**。\n\n小 E 有一些很重要的信息要传给小 F。信息的内容可以用一个不超过 $128$ 位的二进制整数来表示。\n\n但是小 E 现在只有鸽子。好多好多的鸽子。黑色和白色的鸽子。\n\n小 E 可以让不同颜色的鸽子按一定的顺序起飞，飞到小 F 那里，这样小 F 就可以根据降落的鸽子的颜色顺序来知道信息的具体内容了。当然鸽子的数量是需要约定好且固定的，不然小 F 可能会在看到所有鸽子之前误以为所有的鸽子都已经飞过来了。\n\n但是众所周知，“鸽子”一词总是和“时间”联系在一起。鸽子会放鸽子。不过小 E 的鸽子还算守时，起飞和降落的顺序之差不会超过一个正整数 $k$。形式化地，设起飞的第 $i$ 只鸽子是第 $p_i$ 个降落的，那么 $\\{p_i\\}$ 是一个排列且对于所有的 $i$，$\\left|i-p_i\\right|\\le k$。\n\n小 E 自然是考虑到了这些情况，并提前与小 F 约定好了。请问如果你是小 E 你要怎样做下约定以及发送信息呢？\n\n### 实现细节\n\n【备注】：提交此题需要在所有函数前加上 `extern \"C\"`。\n\n你不需要也不应该实现主函数。你需要实现三个函数 `pigeon_num`，`send` 和 `receive`。\n\n函数 `pigeon_num` 的接口如下：\n\n```cpp\nint pigeon_num(int Taskid, int k);\n```\n\n- 该函数传入子任务编号 `Taskid` 和题目中参数 `k` 的值。\n- 该函数需要返回小 E 需要放飞的鸽子数量 $n$。\n\n函数 `send` 的接口如下：\n\n```cpp\nstd::string send(int Taskid, int n, int k, __uint128_t msg);\n```\n\n- 该函数传入子任务编号 `Taskid`，`pigeon_num` 函数的返回值 `n`，题目中的参数 `k` 以及需要发送的信息 `msg`。\n- 该函数需要返回一个长度恰好为 $n$ 的字符串，其中下标为 $i(0\\le i\\lt n)$ 的位置表示小 E 放飞的第 $i+1$ 只鸽子的颜色，`0` 表示黑色，`1` 表示白色。\n\n函数 `receive` 的接口如下：\n\n```cpp\n__uint128_t receive(int Taskid, int k, const std::string &msg);\n```\n\n- 该函数传入子任务编号 `Taskid`，题目中的参数 `k` 以及小 F 看到的鸽子的降落顺序 `msg`。\n- `msg` 为一个长度为 $n$ 的字符串，其中下标为 $i(0\\le i\\lt n)$ 的位置表示小 F 看到的第 $i+1$ 只降落的鸽子的颜色，`0` 表示黑色，`1` 表示白色。`msg` 的值与某次调用 `send` 函数的返回值有着题目描述中所满足的关系。\n- 该函数需要正确返回小 E 发送的信息的内容。\n\n你可以参考下发的样例程序 `pigeon.cpp`，也可以从头开始写一个程序。\n\n在评测时，交互库会被运行**两次**，**两次运行独立计算时间和空间**。\n\n在第一次运行时，交互库会先调用一次 `pigeon_num` 函数，然后调用不超过 $1000$ 次 `send` 函数。\n\n在第二次运行时，交互库会调用不超过 $10000$ 次 `receive` 函数。\n\n保证在题目限制下，评测交互库的运行时间不超过 $1\\texttt{s}$，运行内存不超过 $512\\textrm{MB}$。也就是说，你实际可以利用的时间至少为 $2\\texttt{s}$，空间至少为 $1.5\\textrm{GB}$。\n\n**由于洛谷暂不支持通信题的评测，评测方式逻辑与下发交互库类似。这意味着可以轻松地作弊。E_Space 在这里不追究有关于此的作弊行为，但请不要写到题解中去。**\n\n### 测试程序方式\n\n将样例交互库 `grader.cpp` 和你的代码 `pigeon.cpp` 置于同一目录下并在终端中输入如下命令进行编译：\n\n```bash\ng++ pigeon.cpp grader.cpp -o grader -g -Wall --std=c++11\n```\n\n然后运行 `./grader` 即可。样例交互库使用标准输入和标准输出，**只需要运行一次**。\n\n注意下发的交互库与实际评测时使用的交互库的实现不同。比如在下发的交互库中，通过 `send` 函数修改的全局变量的值能够被 `receive` 函数查看。\n\n", "inputFormat": "第一行三个非负整数 $\\mathrm{Taskid}$，$k$，$T$。其中 $\\mathrm{Taskid}$ 表示子任务编号，$T$ 表示发送信息的数量。\n\n接下来 $T$ 行，每行一个非负 $128$ 位整数表示信息的内容。\n\n", "outputFormat": "如果你的程序在该测试点上是正确的，对于每一条信息，交互库会输出四行内容。\n\n- 第一行 `Message` 为小 E 想要发送的信息，即 `send` 函数中参数 `msg` 的内容。\n- 第二行 `Taking off` 为鸽子起飞的顺序，即 `send` 函数的返回值。\n- 第三行 `Landing` 为鸽子降落的顺序，即 `receive` 函数中参数 `msg` 的内容。\n- 第四行 `Received` 为小 F 解读出来的信息，即 `receive` 函数的返回值。\n- 最后一行输出 `Accepted using <num> pigeon(s).`，其中 `<num>` 是小 E 放飞的鸽子的数量，即 `pigeon_num` 函数的返回值。\n\n否则如果程序正常退出，交互库会输出以下内容之一：\n\n- `Invalid number of pigeons.`：输出这句话说明 `pigeon_num` 函数的返回值不在 $[1,4000]$ 之间。\n- `Invalid color of pigeon.`：输出这句话说明 `send` 函数的返回值中有非 `0` 或 `1` 的字符。\n- `Too few or too many pigeons taking off.`：输出这句话说明 `send` 函数的返回值的长度不等于 `pigeon_num` 函数的返回值。\n- `Received wrong message.`：输出这句话说明 `receive` 函数的返回值与 `send` 函数中的参数 `msg` 不相等。\n\n一旦交互库输出了报错语句，交互库程序就会立即停止运行。\n\n", "hint": "#### 样例解释\n\n这是样例交互库在下发样例程序 `pigeon.cpp` 在样例输入下的输出。\n\n对于小 E 来说，$97429867398990605044182047185430790478$ 是一个很有意义的数。所以只需要放飞少量鸽子就够了。\n\n### 子任务\n\n子任务 $0$（$0.01$ 分）：样例。保证信息对应的整数等于 $97429867398990605044182047185430790478$。下发的 `pigeon.cpp` 能够通过样例。该子任务的评测结果会显示在评测结果中。\n\n子任务 $1$（$3.99$ 分）：保证信息对应的整数小于 $1024$。 $k\\le 20$。\n\n子任务 $2$（$12$ 分）：$k=1$。保证信息对应的整数小于 $1048576$。\n\n子任务 $3\\sim 9$（每个子任务 $12$ 分，共 $84$ 分）：$k\\le 20$。\n\n**由于洛谷不支持小数得分，本题的得分显示将乘以 100 来表示保留两位小数之后的结果。**\n\n### 评分方式\n\n评测时，你只需在 OJ 上提交你的源程序，修改下发的其他文件不会对评测结果产生影响。\n\n本题首先会受到和传统题相同的限制，例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。\n\n对于每个子任务，如果你的程序有以下行为，将会被判为 $0$ 分：\n\n- `pigeon_num` 函数的返回值不在 $[1,4000]$ 之内；\n- `send` 函数的返回值的长度不等于 `pigeon_num` 函数的返回值；\n- `send` 函数的返回值的内容包含 `0` 或 `1` 之外的字符；\n- `receive` 函数没有正确地返回小 E 发送的信息内容。\n\n此外，对于每个子任务，你的得分与小 E 放飞的鸽子的数量，即 `pigeon_num` 函数的返回值有关。设这个值为 $n$。\n\n在子任务 $1 \\sim 2$ 中，如果 $n\\le 4000$，那么你就能得到该测试点的满分，否则得到零分。\n\n在子任务 $3\\sim 9$ 中，同一个子任务中所有测试点的 $k$ 的值相同，且编号越大的子任务中 $k$ 的值越大。设 $C(k)$ 为一个关于 $k$ 的函数，则\n\n- 如果 $n\\le C(k)$，那么你可以得到该测试点的满分。\n- 若 $n\\le C(k)+5$，那么在此范围内 $n$ 的值每多 $1$，你就会失去该测试点满分乘以 $2\\%$ 的分数。\n- 若 $C(k)+5 \\lt n\\le \\lfloor 1.1\\times C(k)\\rfloor$，那么在此范围内 $n$ 的值每多 $1$，你就会额外失去该测试点满分乘以 $400\\%/C(k)$ 的分数。\n- 若 $n\\gt \\lfloor 1.1\\times C(k)\\rfloor$，那么在此范围内 $n$ 的值每多 $1$，你就会额外失去该测试点满分乘以 $40\\%/C(k)$ 的分数。\n- 若你的答案正确，你至少可以得到 $1$ 分。\n\n换句话说，你在一个测试点的得分等于 $\\max(1, 12\\times \\min(1, f_k(n)))$，其中 $f_k(n)$ 是一个关于 $n$ 的分段线性函数，满足：\n\n- $f_k(C(k))=1$\n- 两个拐点的横坐标分别为 $C(k)+5$ 和 $\\lfloor 1.1\\times C(k)\\rfloor$。\n- 被两个拐点分割所形成的三段区间的斜率依次为 $-0.02$，$-4/C(k)$ 和 $-0.4/C(k)$。\n\n\n你的每个子任务的得分是子任务中所有测试点得分的最小值。\n\n$C(k)$ 的函数值由下表给出。在下表中未出现的 $k$ 值不会出现在子任务 $3\\sim 9$ 的测试数据中。\n\n| $k$ | $1$ | $2$ | $5$ | $7$ | $10$ | $14$ | $20$ |\n| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |\n| $C(k)$ | $206$ | $284$ | $485$ | $605$ | $773$ | $983$ | $1277$ |\n\n**通过访问输入输出文件、攻击评测系统或攻击评测库等方式得分属于作弊行为，所得分数无效。**\n\n**由于洛谷暂不支持通信题的评测，评测方式逻辑与下发交互库类似。这意味着可以轻松地作弊。E_Space 在这里不追究有关于此的作弊行为，但请不要写到题解中去。**", "locale": "zh-CN"}}}
{"pid": "P9072", "type": "P", "difficulty": 7, "samples": [["1 4 2 2\n2 1", "7"], ["2 4 2 2\n1 2 2 1", "19"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "CTSC/CTS"], "title": "[CTS2023] 另一个欧拉数问题", "background": "你继续向前走，遇到了一个身着黑袍的老人，那边的门前放着一个巨大的沙盘，老人用手中的树枝在沙盘前画着奇怪的符号。\n\n老人告诉你，他从年轻开始便梦想一个问题，直到他垂垂老矣，似乎也只揭露了答案的一角。\n\n或许我该将它们交给你们了，老人说。\n\n别太担心，我不想太为难你，至少我已经把必要的工具给你准备好了。", "description": "对于正整数 $\\alpha$，考虑下述长为 $\\alpha n$ 的序列 $a$：\n\n- 对于每个 $k=1,\\dots, n$，序列 $a$ 中出现了恰好 $\\alpha$ 个 $k$。\n\n- 对于 $i < j$ 满足 $a_i = a_j$，那么对任意 $i < k < j$，有 $a_k \\geq a_i$。\n\n我们称满足上述要求的序列是一个 $(n,\\alpha)$ 阶排列。\n\n现在输入一个 $(n_0,\\alpha)$ 阶排列 $P$。又给定 $n$ 和 $m$，请你计算有多少 $(n,\\alpha)$ 阶排列包含子序列 $P$，并且满足：\n\n- 总共有 $m$ 个下标 $i$ 满足 $a_i > a_{i+1}$。\n\n你只需计算出这样的序列总数对 $998244353$ 取模的结果。", "inputFormat": "第一行输入四个整数 $\\alpha$，$n$，$m$，$n_0$。\n\n第二行输入 $\\alpha n_0$ 个正整数，保证构成一个 $(n_0,\\alpha)$ 阶排列。", "outputFormat": "输出一个整数，表示满足要求的序列的数量。", "hint": "**【数据范围】**\n\n子任务 $1$（$10$ 分）：保证 $n \\leq 2000$。\n\n子任务 $2$（$10$ 分）：保证 $\\alpha = 1$，$n_0=1$。\n\n子任务 $3$（$30$ 分）：保证 $\\alpha = 1$。\n\n子任务 $4$（$15$ 分）：保证 $\\alpha = 2$，$n_0=1$。\n\n子任务 $5$（$15$ 分）：保证 $\\alpha = 2$。\n\n子任务 $6$（$20$ 分）：无特殊限制。\n\n对于所有数据，保证 $1\\leq n \\leq 2\\times 10^5$，$0\\leq m < n$，$1\\leq n_0\\leq n$，$1\\leq \\alpha n_0 \\leq 2\\times 10^5$。\n\n**【提示】**\n\n为了方便选手处理形式幂级数的运算，我们提供了一个模板。选手可以根据自己的需要参考与使用该模板，也可以不使用该模板。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CTS2023] 另一个欧拉数问题", "background": "你继续向前走，遇到了一个身着黑袍的老人，那边的门前放着一个巨大的沙盘，老人用手中的树枝在沙盘前画着奇怪的符号。\n\n老人告诉你，他从年轻开始便梦想一个问题，直到他垂垂老矣，似乎也只揭露了答案的一角。\n\n或许我该将它们交给你们了，老人说。\n\n别太担心，我不想太为难你，至少我已经把必要的工具给你准备好了。", "description": "对于正整数 $\\alpha$，考虑下述长为 $\\alpha n$ 的序列 $a$：\n\n- 对于每个 $k=1,\\dots, n$，序列 $a$ 中出现了恰好 $\\alpha$ 个 $k$。\n\n- 对于 $i < j$ 满足 $a_i = a_j$，那么对任意 $i < k < j$，有 $a_k \\geq a_i$。\n\n我们称满足上述要求的序列是一个 $(n,\\alpha)$ 阶排列。\n\n现在输入一个 $(n_0,\\alpha)$ 阶排列 $P$。又给定 $n$ 和 $m$，请你计算有多少 $(n,\\alpha)$ 阶排列包含子序列 $P$，并且满足：\n\n- 总共有 $m$ 个下标 $i$ 满足 $a_i > a_{i+1}$。\n\n你只需计算出这样的序列总数对 $998244353$ 取模的结果。", "inputFormat": "第一行输入四个整数 $\\alpha$，$n$，$m$，$n_0$。\n\n第二行输入 $\\alpha n_0$ 个正整数，保证构成一个 $(n_0,\\alpha)$ 阶排列。", "outputFormat": "输出一个整数，表示满足要求的序列的数量。", "hint": "**【数据范围】**\n\n子任务 $1$（$10$ 分）：保证 $n \\leq 2000$。\n\n子任务 $2$（$10$ 分）：保证 $\\alpha = 1$，$n_0=1$。\n\n子任务 $3$（$30$ 分）：保证 $\\alpha = 1$。\n\n子任务 $4$（$15$ 分）：保证 $\\alpha = 2$，$n_0=1$。\n\n子任务 $5$（$15$ 分）：保证 $\\alpha = 2$。\n\n子任务 $6$（$20$ 分）：无特殊限制。\n\n对于所有数据，保证 $1\\leq n \\leq 2\\times 10^5$，$0\\leq m < n$，$1\\leq n_0\\leq n$，$1\\leq \\alpha n_0 \\leq 2\\times 10^5$。\n\n**【提示】**\n\n为了方便选手处理形式幂级数的运算，我们提供了一个模板。选手可以根据自己的需要参考与使用该模板，也可以不使用该模板。", "locale": "zh-CN"}}}
{"pid": "P9073", "type": "P", "difficulty": 7, "samples": [["18\n+ 5 1\n+ 2 1\n? 3\n+ 3 2\n? 4\n? 4\n+ 4 1\n? 3\nR 3\n- 2 2\n? 3\n- 1 1\n? 2\n? 4\n- 1 2\n? 1\n- 9 9\n? 1", "3 1\n1 3\n2 2\n2 4\n2 1\n1 2\n1 1\n1 1\n1 1"], ["见附件中的 stairs2.in", "见附件中的 stairs2.ans"], ["见附件中的 stairs3.in", "见附件中的 stairs3.ans"], ["见附件中的 stairs4.in", "见附件中的 stairs4.ans"], ["见附件中的 stairs5.in", "见附件中的 stairs5.ans"], ["见附件中的 stairs6.in", "见附件中的 stairs6.ans"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "Special Judge", "O2优化", "杨表", "WC", "CTSC/CTS"], "title": "[WC/CTS2023] 楼梯", "background": "长颈鹿累了，他开始做梦。\n\n在梦中他下坠。他穿过草地，穿过打着转的羊群。他穿过星海，穿过漫天的火羽。\n\n终于，他站在了一块屏幕前。屏幕上展示着某种类似楼梯的图样。", "description": "我们首先给出一些关于楼梯的形式定义。\n\n我们称一对正整数组成的二元组 $(x,y)$ 为**格子**，称格子构成的集合 $L$（可以为空）为**楼梯**当且仅当其满足下面两个条件：\n\n+ 若 $(x,y)\\in L$ 且 $x>1$，则 $(x-1,y)\\in L$。\n+ 若 $(x,y)\\in L$ 且 $y>1$，则 $(x,y-1)\\in L$。\n\n对于一个楼梯 $L$ 和 $(x,y)\\in L$，我们定义 $(x,y)$ 为**生成格**生成的**子楼梯**为\n\n$$\n\\{(a-x+1, b-y+1) \\mid (a,b) \\in L, a \\ge x, b \\ge y\\}\n$$\n\n容易证明这一集合仍然是一个楼梯。对于一个楼梯 $L$，我们定义**边界格数**为满足 $x=1$ 或 $y=1$ 的 $(x,y) \\in L$ 的数量。\n\n为了方便理解，我们接下来给出直观解释。我们在平面上可以将所有格子按从左到右 $y$ 坐标递增、从上到下 $x$ 坐标递增的顺序排列成网格，因此我们也称 $(x,y)$ 为第 $x$ 行第 $y$ 列的格子。\n\n在这一解释下，若一个格子属于某个楼梯，且它上方和左方不是边界，则对应格子也属于这个楼梯。子楼梯就是生成格右下方区域格子所构成的非空楼梯，一个楼梯的边界格数是上边界或左边界上的总格数。\n\n如下图，$(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(4,1),(5,1)$ 组成了一个合法的楼梯。这一楼梯的边界格数为 $8$，其中以 $(1,3)$ 作为生成格生成的子楼梯的边界格数为 $4$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/88e0br57.png)\n\n长颈鹿看到屏幕上的楼梯后很好奇。他首先计算出了这一楼梯的边界格数 $p$，并给定了 $p$ 的某一**正整数因子** $q$。他想要知道，给定的楼梯是否有子楼梯满足边界格数等于 $q$。如果是，他希望你给出**任一**这样的子楼梯的生成格。\n\n梦境时常变化，因此长颈鹿可能会有许多次这样的询问，楼梯也可能会发生变化。初始楼梯 $L$ 为空，对于 $i \\ge 1$ 记 $s_i$ 为最大的满足 $(i,s_i) \\in L$ 的正整数，若不存在则令其为 $0$，则有若干次三种之一的修改：\n\n- 给定正整数 $a$ 和 $b$，在前 $a$ 行的末尾插入 $b$ 格。形式化地，对于 $i=1, 2, \\dots, a$，将 $(i,s_i+1), (i,s_i+2),\\dots,(i,s_i+b)$ 加入 $L$。\n- 给定正整数 $a$ 和 $b$，在第 $a$ 行后（包含第 $a$ 行）的所有行行末尾删去 $b$ 格，若不足则删空。形式化地，对于 $i=a,a+1,a+2,\\dots,10^{100}$，将 $(i,s_i),(i,s_i−1),\\dots,(i,s_i−b+1)$ 从 $L$ 中移除（不存在的则忽略）。\n- 给定正整数 $u$，撤销之前的 $u$ 次操作，即将楼梯还原为 $u$ 次操作前的状态，**保证这 $u$ 次操作均为询问或在行末尾插入**。具体地，假设该操作为第 $t$ 次操作，我们一定有 $t>u$，且第 $t−1,t−2,\\dots,t−u$ 次操作均为询问或在行末尾插入（即上述的第一种修改）。你只需要将楼梯还原为第 $t−u$ 次操作前的状态即可（当然，你应该保留询问的输出）。\n\n可以证明每次修改之后得到的集合仍然是一个楼梯。", "inputFormat": "输入数据第一行包含一个正整数 $m$，表示操作总数。\n\n接下来 $m$ 行每行描述四种之一的操作，详细含义可参见题目描述一节。描述为由空格分隔的一个字符和一到两个正整数，具体地：\n\n- `+ a b`：在前 $a$ 行的末尾插入 $b$ 格。\n- `- a b`：在第 $a$ 行后（包括第 $a$ 行）的所有行行末尾删去 $b$ 格，若不足则删空。\n- `R u`：撤销之前的 $u$ 次操作，即将楼梯还原为 $u$ 次操作前的状态。**保证这 $u$ 次操作存在且均为询问或在行末尾插入**，即该行之前的 $u$ 行均以 `+` 或 `?` 开头。\n- `? q`：询问是否有边界格数等于 $q$ 的子楼梯，若有则给出任意合法生成格。**保证 $q$ 是当前楼梯边界格数的因子**。", "outputFormat": "对于每个询问（`?` 操作）输出一行。\n\n如果存在边界格数等于 $q$ 的子楼梯，输出一行两个用空格分隔的正整数 `x y`，表示一个合法生成格是 $(x,y)$。否则输出一行两个用空格分隔的 $-1$。", "hint": "**【样例解释 #1】**\n\n每次修改操作之后的楼梯如下图（排列方式同题目描述，省略了各格子的编号）。注意撤销操作实际只撤销了一个 `+` 操作。样例有多个合法解，给出的输出只是一种合法的输出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/milfbsr1.png)\n\n**【数据范围】**\n\n对于所有测试数据，$1 \\le m \\le 3 \\times 10^5$。\n\n+ 对于 `+` 和 `-` 操作，$1 \\le a, b \\le 10^9$。\n+ 对于 `R` 操作，保证之前紧邻的 $u$ 次操作存在且均为询问或在行末尾插入。\n+ 对于 `?` 操作，$1 \\le q \\le 10^{18}$ 且**保证为当前楼梯边界格数的因子**。\n\n记 $a_{\\max}$ 为所有 `+` 和 `-` 操作中 $a$ 的最大值，$b_{\\max}$ 为所有 `+` 和 `-` 操作中 $b$ 的最大值。\n\n| 测试点 | $m =$ | $a_{\\max} \\leq$ | $b_{\\max} \\leq$ | 特殊性质 |\n| :-: | :-: | :-: | :-: | :-: |\n| $1$ | $200$ | $50$ | $20$ | 无 |\n| $2$ | $400$ | $100$ | $100$ | AB |\n| $3$ | $600$ | $500$ | $500$ | A |\n| $4$ | $800$ | $500$ | $10^6$ | 无 |\n| $5$ | $10^3$ | $10^3$ | $10^6$ | 无 |\n| $6$ | $3000$ | $10^6$ | $10^6$ | B |\n| $7$ | $5000$ | $10^6$ | $10^6$ | AB |\n| $8$ | $10^4$ | $10^9$ | $10^9$ | 无 |\n| $9$ | $3 \\times 10^4$ | $10^9$ | $10^9$ | A |\n| $10$ | $5 \\times 10^4$ | $10^9$ | $10^9$ | 无 |\n| $11$ | $7 \\times 10^4$ | $10^9$ | $10^9$ | 无 |\n| $12$ | $10^5$ | $10^9$ | $10^9$ | B |\n| $13$ | $1.2 \\times 10^5$ | $10^9$ | $10^9$ | 无 |\n| $14$ | $1.4 \\times 10^5$ | $10^6$ | $10^6$ | 无 |\n| $15$ | $1.6 \\times 10^5$ | $10^6$ | $10^6$ | AB |\n| $16$ | $1.8 \\times 10^5$ | $10^9$ | $10^9$ | 无 |\n| $17$ | $2 \\times 10^5$ | $10^6$ | $10^6$ | B |\n| $18$ | $2.5 \\times 10^5$ | $10^6$ | $10^6$ | B |\n| $19$ | $2.7 \\times 10^5$ | $10^9$ | $10^9$ | 无 |\n| $20$ | $3 \\times 10^5$ | $10^9$ | $10^9$ | 无 |\n\n其中附加限制中的特殊性质如下所示：\n\n- 特殊性质 A：`?` 操作在所有 `+` 和 `-` 操作之后。没有 `R` 操作。\n- 特殊性质 B：没有 `-` 操作。\n\n**【提示】**\n\n请注意选用合适的数据类型存储各结果。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[WC/CTS2023] 楼梯", "background": "长颈鹿累了，他开始做梦。\n\n在梦中他下坠。他穿过草地，穿过打着转的羊群。他穿过星海，穿过漫天的火羽。\n\n终于，他站在了一块屏幕前。屏幕上展示着某种类似楼梯的图样。", "description": "我们首先给出一些关于楼梯的形式定义。\n\n我们称一对正整数组成的二元组 $(x,y)$ 为**格子**，称格子构成的集合 $L$（可以为空）为**楼梯**当且仅当其满足下面两个条件：\n\n+ 若 $(x,y)\\in L$ 且 $x>1$，则 $(x-1,y)\\in L$。\n+ 若 $(x,y)\\in L$ 且 $y>1$，则 $(x,y-1)\\in L$。\n\n对于一个楼梯 $L$ 和 $(x,y)\\in L$，我们定义 $(x,y)$ 为**生成格**生成的**子楼梯**为\n\n$$\n\\{(a-x+1, b-y+1) \\mid (a,b) \\in L, a \\ge x, b \\ge y\\}\n$$\n\n容易证明这一集合仍然是一个楼梯。对于一个楼梯 $L$，我们定义**边界格数**为满足 $x=1$ 或 $y=1$ 的 $(x,y) \\in L$ 的数量。\n\n为了方便理解，我们接下来给出直观解释。我们在平面上可以将所有格子按从左到右 $y$ 坐标递增、从上到下 $x$ 坐标递增的顺序排列成网格，因此我们也称 $(x,y)$ 为第 $x$ 行第 $y$ 列的格子。\n\n在这一解释下，若一个格子属于某个楼梯，且它上方和左方不是边界，则对应格子也属于这个楼梯。子楼梯就是生成格右下方区域格子所构成的非空楼梯，一个楼梯的边界格数是上边界或左边界上的总格数。\n\n如下图，$(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(4,1),(5,1)$ 组成了一个合法的楼梯。这一楼梯的边界格数为 $8$，其中以 $(1,3)$ 作为生成格生成的子楼梯的边界格数为 $4$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/88e0br57.png)\n\n长颈鹿看到屏幕上的楼梯后很好奇。他首先计算出了这一楼梯的边界格数 $p$，并给定了 $p$ 的某一**正整数因子** $q$。他想要知道，给定的楼梯是否有子楼梯满足边界格数等于 $q$。如果是，他希望你给出**任一**这样的子楼梯的生成格。\n\n梦境时常变化，因此长颈鹿可能会有许多次这样的询问，楼梯也可能会发生变化。初始楼梯 $L$ 为空，对于 $i \\ge 1$ 记 $s_i$ 为最大的满足 $(i,s_i) \\in L$ 的正整数，若不存在则令其为 $0$，则有若干次三种之一的修改：\n\n- 给定正整数 $a$ 和 $b$，在前 $a$ 行的末尾插入 $b$ 格。形式化地，对于 $i=1, 2, \\dots, a$，将 $(i,s_i+1), (i,s_i+2),\\dots,(i,s_i+b)$ 加入 $L$。\n- 给定正整数 $a$ 和 $b$，在第 $a$ 行后（包含第 $a$ 行）的所有行行末尾删去 $b$ 格，若不足则删空。形式化地，对于 $i=a,a+1,a+2,\\dots,10^{100}$，将 $(i,s_i),(i,s_i−1),\\dots,(i,s_i−b+1)$ 从 $L$ 中移除（不存在的则忽略）。\n- 给定正整数 $u$，撤销之前的 $u$ 次操作，即将楼梯还原为 $u$ 次操作前的状态，**保证这 $u$ 次操作均为询问或在行末尾插入**。具体地，假设该操作为第 $t$ 次操作，我们一定有 $t>u$，且第 $t−1,t−2,\\dots,t−u$ 次操作均为询问或在行末尾插入（即上述的第一种修改）。你只需要将楼梯还原为第 $t−u$ 次操作前的状态即可（当然，你应该保留询问的输出）。\n\n可以证明每次修改之后得到的集合仍然是一个楼梯。", "inputFormat": "输入数据第一行包含一个正整数 $m$，表示操作总数。\n\n接下来 $m$ 行每行描述四种之一的操作，详细含义可参见题目描述一节。描述为由空格分隔的一个字符和一到两个正整数，具体地：\n\n- `+ a b`：在前 $a$ 行的末尾插入 $b$ 格。\n- `- a b`：在第 $a$ 行后（包括第 $a$ 行）的所有行行末尾删去 $b$ 格，若不足则删空。\n- `R u`：撤销之前的 $u$ 次操作，即将楼梯还原为 $u$ 次操作前的状态。**保证这 $u$ 次操作存在且均为询问或在行末尾插入**，即该行之前的 $u$ 行均以 `+` 或 `?` 开头。\n- `? q`：询问是否有边界格数等于 $q$ 的子楼梯，若有则给出任意合法生成格。**保证 $q$ 是当前楼梯边界格数的因子**。", "outputFormat": "对于每个询问（`?` 操作）输出一行。\n\n如果存在边界格数等于 $q$ 的子楼梯，输出一行两个用空格分隔的正整数 `x y`，表示一个合法生成格是 $(x,y)$。否则输出一行两个用空格分隔的 $-1$。", "hint": "**【样例解释 #1】**\n\n每次修改操作之后的楼梯如下图（排列方式同题目描述，省略了各格子的编号）。注意撤销操作实际只撤销了一个 `+` 操作。样例有多个合法解，给出的输出只是一种合法的输出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/milfbsr1.png)\n\n**【数据范围】**\n\n对于所有测试数据，$1 \\le m \\le 3 \\times 10^5$。\n\n+ 对于 `+` 和 `-` 操作，$1 \\le a, b \\le 10^9$。\n+ 对于 `R` 操作，保证之前紧邻的 $u$ 次操作存在且均为询问或在行末尾插入。\n+ 对于 `?` 操作，$1 \\le q \\le 10^{18}$ 且**保证为当前楼梯边界格数的因子**。\n\n记 $a_{\\max}$ 为所有 `+` 和 `-` 操作中 $a$ 的最大值，$b_{\\max}$ 为所有 `+` 和 `-` 操作中 $b$ 的最大值。\n\n| 测试点 | $m =$ | $a_{\\max} \\leq$ | $b_{\\max} \\leq$ | 特殊性质 |\n| :-: | :-: | :-: | :-: | :-: |\n| $1$ | $200$ | $50$ | $20$ | 无 |\n| $2$ | $400$ | $100$ | $100$ | AB |\n| $3$ | $600$ | $500$ | $500$ | A |\n| $4$ | $800$ | $500$ | $10^6$ | 无 |\n| $5$ | $10^3$ | $10^3$ | $10^6$ | 无 |\n| $6$ | $3000$ | $10^6$ | $10^6$ | B |\n| $7$ | $5000$ | $10^6$ | $10^6$ | AB |\n| $8$ | $10^4$ | $10^9$ | $10^9$ | 无 |\n| $9$ | $3 \\times 10^4$ | $10^9$ | $10^9$ | A |\n| $10$ | $5 \\times 10^4$ | $10^9$ | $10^9$ | 无 |\n| $11$ | $7 \\times 10^4$ | $10^9$ | $10^9$ | 无 |\n| $12$ | $10^5$ | $10^9$ | $10^9$ | B |\n| $13$ | $1.2 \\times 10^5$ | $10^9$ | $10^9$ | 无 |\n| $14$ | $1.4 \\times 10^5$ | $10^6$ | $10^6$ | 无 |\n| $15$ | $1.6 \\times 10^5$ | $10^6$ | $10^6$ | AB |\n| $16$ | $1.8 \\times 10^5$ | $10^9$ | $10^9$ | 无 |\n| $17$ | $2 \\times 10^5$ | $10^6$ | $10^6$ | B |\n| $18$ | $2.5 \\times 10^5$ | $10^6$ | $10^6$ | B |\n| $19$ | $2.7 \\times 10^5$ | $10^9$ | $10^9$ | 无 |\n| $20$ | $3 \\times 10^5$ | $10^9$ | $10^9$ | 无 |\n\n其中附加限制中的特殊性质如下所示：\n\n- 特殊性质 A：`?` 操作在所有 `+` 和 `-` 操作之后。没有 `R` 操作。\n- 特殊性质 B：没有 `-` 操作。\n\n**【提示】**\n\n请注意选用合适的数据类型存储各结果。", "locale": "zh-CN"}}}
{"pid": "P9074", "type": "P", "difficulty": 7, "samples": [["4\n5 2\n3 1 2 3\n3 3 4 5\n7 7\n3 1 2 4\n3 2 3 5\n3 3 4 6\n3 4 5 7\n3 5 6 1\n3 6 7 2\n3 7 1 3\n8 2\n4 1 2 3 4\n4 5 6 7 8\n10 1\n10 1 2 3 4 5 6 7 8 9 10", "1 3 4 2 5\n1 2 3 4 5 6 7\n1 5 2 6 3 7 4 8\n-1"], ["见附件中的 contest2.in", "见附件中的 contest2.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "Special Judge", "O2优化", "WC", "CTSC/CTS"], "title": "[WC/CTS2023] 比赛", "background": "", "description": "有 $n$ 名学生，标号从 $1$ 到 $n$，他们一共加入了 $m$ 个社团。由于一些奇怪的原因，**任意两个社团至多只包含一名公共成员**。\n\n现在学校要组织一场比赛，想让这 $n$ 名学生围成一个圈。为了防止作弊，校长希望**圈上任意连续三个人不来自同一个社团**。\n\n校长找到了你，希望你给他一组圆排列学生的方案，或指出这样的方案并不存在。", "inputFormat": "第一行包含一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行包含两个非负整数 $n, m$，分别表示学生的数量和社团的数量。\n\n接下来 $m$ 行，其中的第 $i$ 行的第一个整数为 $k_i$，表示第 $i$ 个社团的人数，紧随着 $k_i$ 个不重复的整数 $a_{i,1}, a_{i,2}, \\dots, a_{i, k_i}$，表示第 $i$ 个社团的成员的标号。", "outputFormat": "对于每组数据，输出一行：\n\n如果存在满足条件的圆排列，则该行包含 $n$ 个整数，表示一个满足条件的圆排列。**如果有多个满足条件的圆排列，输出任意一组均可**。\n\n如果不存在满足条件的圆排列，则该行仅包含一个整数 $-1$。", "hint": "**【样例解释 #1】**\n\n在正式评测时，**任意一组满足条件的圆排列**都被视为正确，无论排列以谁开始，以哪个方向。\n\n**【样例解释 #2】**\n\n这个样例中前 $110$ 组数据满足 $n \\le 15$，后 $35$ 组数据满足 $n \\le 45$。\n\n**【数据范围】**\n\n对于所有的测试点，保证 $T \\ge 1$，$n \\ge 3$，$\\sum n \\le 2000$，$m \\ge 0$，$3 \\le k_i \\le n$，$1 \\le a_{i,j} \\le n$，$a_{i,1}, a_{i,2}, \\dots, a_{i,k_i}$ 互不相同，且满足题中所述性质（任意两个社团至多包含一名公共成员）。\n\n每个测试点的具体限制见下表：\n\n| 测试点编号 | $n$ | $m$ | 特殊性质 |\n| :-: | :-: | :-: | :-: |\n| $1 \\sim 2$ | $\\leq 9$ | 无 | 无 |\n| $3 \\sim 4$ | $\\leq 15$ | 无 | 无 |\n| $5 \\sim 6$ | $\\leq 45$ | 无 | 无 |\n| $7 \\sim 8$ | $\\leq 400$ | $= 1$ | 无 |\n| $9 \\sim 12$ | $\\leq 400$ | 无 | 保证 $a_{i,j+1} = a_{i,j} + 1$ |\n| $13 \\sim 16$ | $\\leq 400$ | 无 | 无 |\n| $17 \\sim 18$ | $\\leq 2000$ | $= 1$ | 无 |\n| $19 \\sim 21$ | $\\leq 2000$ | 无 | 保证 $a_{i,j+1} = a_{i,j} + 1$ |\n| $22 \\sim 25$ | $\\leq 2000$ | 无 | 无 |\n\n可以使用下发文件（题目附件）中的 `chk.cpp` 以检验你的输出的合法性，使用时先将其编译为可执行文件 `chk`。\n\n+ Linux 系统使用 `./chk <input‐file> <output‐file> <answer‐file>` 测试\n+ Windows 系统使用 `chk <input‐file> <output‐file> <answer‐file>` 测试。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[WC/CTS2023] 比赛", "background": "", "description": "有 $n$ 名学生，标号从 $1$ 到 $n$，他们一共加入了 $m$ 个社团。由于一些奇怪的原因，**任意两个社团至多只包含一名公共成员**。\n\n现在学校要组织一场比赛，想让这 $n$ 名学生围成一个圈。为了防止作弊，校长希望**圈上任意连续三个人不来自同一个社团**。\n\n校长找到了你，希望你给他一组圆排列学生的方案，或指出这样的方案并不存在。", "inputFormat": "第一行包含一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行包含两个非负整数 $n, m$，分别表示学生的数量和社团的数量。\n\n接下来 $m$ 行，其中的第 $i$ 行的第一个整数为 $k_i$，表示第 $i$ 个社团的人数，紧随着 $k_i$ 个不重复的整数 $a_{i,1}, a_{i,2}, \\dots, a_{i, k_i}$，表示第 $i$ 个社团的成员的标号。", "outputFormat": "对于每组数据，输出一行：\n\n如果存在满足条件的圆排列，则该行包含 $n$ 个整数，表示一个满足条件的圆排列。**如果有多个满足条件的圆排列，输出任意一组均可**。\n\n如果不存在满足条件的圆排列，则该行仅包含一个整数 $-1$。", "hint": "**【样例解释 #1】**\n\n在正式评测时，**任意一组满足条件的圆排列**都被视为正确，无论排列以谁开始，以哪个方向。\n\n**【样例解释 #2】**\n\n这个样例中前 $110$ 组数据满足 $n \\le 15$，后 $35$ 组数据满足 $n \\le 45$。\n\n**【数据范围】**\n\n对于所有的测试点，保证 $T \\ge 1$，$n \\ge 3$，$\\sum n \\le 2000$，$m \\ge 0$，$3 \\le k_i \\le n$，$1 \\le a_{i,j} \\le n$，$a_{i,1}, a_{i,2}, \\dots, a_{i,k_i}$ 互不相同，且满足题中所述性质（任意两个社团至多包含一名公共成员）。\n\n每个测试点的具体限制见下表：\n\n| 测试点编号 | $n$ | $m$ | 特殊性质 |\n| :-: | :-: | :-: | :-: |\n| $1 \\sim 2$ | $\\leq 9$ | 无 | 无 |\n| $3 \\sim 4$ | $\\leq 15$ | 无 | 无 |\n| $5 \\sim 6$ | $\\leq 45$ | 无 | 无 |\n| $7 \\sim 8$ | $\\leq 400$ | $= 1$ | 无 |\n| $9 \\sim 12$ | $\\leq 400$ | 无 | 保证 $a_{i,j+1} = a_{i,j} + 1$ |\n| $13 \\sim 16$ | $\\leq 400$ | 无 | 无 |\n| $17 \\sim 18$ | $\\leq 2000$ | $= 1$ | 无 |\n| $19 \\sim 21$ | $\\leq 2000$ | 无 | 保证 $a_{i,j+1} = a_{i,j} + 1$ |\n| $22 \\sim 25$ | $\\leq 2000$ | 无 | 无 |\n\n可以使用下发文件（题目附件）中的 `chk.cpp` 以检验你的输出的合法性，使用时先将其编译为可执行文件 `chk`。\n\n+ Linux 系统使用 `./chk <input‐file> <output‐file> <answer‐file>` 测试\n+ Windows 系统使用 `chk <input‐file> <output‐file> <answer‐file>` 测试。", "locale": "zh-CN"}}}
{"pid": "P9075", "type": "P", "difficulty": 7, "samples": [["3 100 100\n1 2\n2 1", "Right output! cnt1 = 2, cnt2 = 5."], ["见附件中的 ds2.in", "见附件中的 ds2.ans"], ["见附件中的 ds3.in", "见附件中的 ds3.ans"], ["见附件中的 ds4.in", "见附件中的 ds4.ans"], ["见附件中的 ds5.in", "见附件中的 ds5.ans"], ["见附件中的 ds6.in", "见附件中的 ds6.ans"], ["见附件中的 ds7.in", "见附件中的 ds7.ans"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "交互题", "O2优化", "WC", "CTSC/CTS"], "title": "[WC/CTS2023] 树据结构", "background": "**这是一道交互题。**\n\n**在提交本题前请务必仔细阅读以下内容。**\n\n本题只支持 C++ 语言提交（建议使用 C++14，请不要使用 C++14 (GCC9)）。\n\n由于洛谷特殊的交互机制，在提交本题时，请去掉代码中的 ```#include \"ds.h\"``` 语句，并将以下内容粘贴到代码最开头，然后提交：\n\n```cpp\n#include <vector>\nvoid exchange(int x, int y);\nint query(int u);\nvoid answer(std::vector<int> par, std::vector<int> val);\n```\n\n如果您在提交本题时出现了任何意外的情况，请咨询管理员。", "description": "作为一个熟练的 OI 选手，你对数据结构的各种题型早已轻车熟路，比赛中只要碰到数据结构题就能三下五除二轻松搞定。这一天，你翻开 OJ，看到了这道题：\n\n给定 $n$ 个点的有根树，点编号为 $1, 2, \\dots, n$，$1$ 为根。每条边上有一个 $1$ 至 $n - 1$ 的**两两不同**的权值。维护一个数据结构，支持交换**权值为 $x$ 和 $y$** 的边的权值，以及询问从根节点到 $u$ 号点的所有的边的权值最大值。\n\n这种简单而经典的树上问题，对你已经是不在话下。厌倦了维护修改，回答询问的你，打算换一个角色。这回，你才是那个提问题的人，你需要构造合适的操作来套取题的数据。\n\n具体地说，现在你并不知道树的结构，也不知道初始时树上每条边的权值，你需要通过如下两种操作得到树的结构和 **初始时** 树上每条边的权值：\n\n1. 给出正整数 $x, y$，其中 $1 \\le x, y < n$，$x \\neq y$，交换 **权值为 $x, y$** 的两条边的权值。\n2. 给出正整数 $u$，其中 $2 \\le u \\le n$，并得到从 $1$ 号点到 $u$ 号点的路径上所有边中权值的最大值。\n\n**题目保证树的形态和每条边的权值是预先给定的，不会根据你的操作而动态生成。**\n\n**【实现细节】**\n\n你需要引用头文件 `#include \"ds.h\"`。你可以调用以下函数与交互库进行交互：\n\n```cpp\nvoid exchange(int x, int y);\n```\n\n+ 这个函数对应操作 $1$，表示交换**权值为 $x, y$** 的两条边的权值。\n+ 你需要保证 $1 \\le x, y < n$，$x \\neq y$。\n\n```cpp\nint query(int u);\n```\n\n+ 这个函数对应操作 $2$，返回从 $1$ 号点到 $u$ 号点的路径上所有边的权值的最大值。\n+ 你需要保证 $2 \\le u \\le n$。\n\n```cpp\nvoid answer(std::vector<int> par, std::vector<int> val);\n```\n\n- 这个函数用来回答你所得到的答案，格式如下：\n  - `par` 是一个长度为 $n - 1$ 的数组，其中 `par[i]` 表示树上 $i + 2$ 号节点的父亲编号，其中 $0 \\le i \\le n - 2$。\n  - `val` 也是一个长度为 $n - 1$ 的数组，其中 `val[i]` 表示树上 $i + 2$ 号节点到它父亲的边的**初始权值**，其中 $0 \\le i \\le n - 2$。\n- **你需要调用该函数恰好一次！**\n\n你不需要，也不应该实现主函数。在本题中，你只需要实现如下函数：\n\n```cpp\nvoid solve(int n, int lim1, int lim2);\n```\n\n- 其中，$n$ 表示树的点数，$lim1$ 表示操作 $1$ 的次数限制，$lim2$ 表示操作 $2$ 的次数限制。\n- 最终测试时，对于每个测试点，交互库会调用**恰好一次** `solve` 函数，并根据调用 `answer` 函数的正误来评分。\n\n在题目附件中，我们提供了 `sample.cpp` 供你参考，你可以在此基础上实现你的程序。\n\n**【测试程序方式】**\n\n题目附件中提供了 `grader.cpp` 文件。最终测试的交互库与下发交互库有不同，因此你的实现不应依赖交互库实现。\n\n你需要将你的程序 `ds.cpp` 和 `grader.cpp`、`ds.h` 放置在同一目录下，并在该目录下使用如下编译命令得到可执行程序 `ds(.exe)`：\n\n```bash\ng++ -o ds ds.cpp grader.cpp -O2 -std=c++14 -lm\n```\n\n**题目附件还提供了 `compile.sh`，其内容为该编译命令。你可以运行它进行编译，也可以复制该文件中的编译命令进行编译。**\n\n可执行程序从标准输入读入以下格式的数据：\n\n- 第一行包含三个正整数 $n, lim1, lim2$，表示树的点数，操作 $1$ 的限制次数和操作 $2$ 的限制次数。交互库保证可以处理 $2 \\le n \\le 500000$ 的情况，对于 $n > 500000$ 的情况不做正确运行保证。\n- 第二行 $n - 1$ 个正整数 $p_2, p_3, \\dots, p_n$。其中 $p_i$ 表示 $i$ 号点的父亲的节点编号。**你需要保证 $1 \\le p_i \\le n$ 且输入给出了合法的树的结构。**\n- 第三行 $n - 1$ 个正整数 $v_2, v_3, \\dots, v_n$。其中 $v_i$ 表示 $i$ 连向 $p_i$ 的边的权值。**你需要保证 $v_2, v_3, \\dots, v_n$ 构成 $1$ 至 $n - 1$ 的一个排列。**\n- **在本地测试时，请务必保证你的输入格式符合要求，否则我们不保证交互库会正常运行。**\n\n如果你的输入合法且没有运行错误，下发的交互库将会根据你的调用输出如下信息：\n\n- 如果某次 `exchange` 函数的调用违反了 $1 \\le x, y < n$，$x \\neq y$ 的限制，输出错误信息：`Invalid call of exchange(x, y)!`。\n- 如果 `exchange` 函数调用次数超过 $lim1$，输出错误信息：`Too many exchanges!`。\n- 如果某次 `query` 函数的调用违反了 $2 \\le u \\le n$ 的限制，输出错误信息：`Invalid call of query(u)!`。\n- 如果 `query` 函数调用次数超过 $lim2$，输出错误信息：`Too many queries!`。\n- 在输出任何以上错误信息后，交互库立即终止。\n- 交互库会在你**每次**调用 `answer` 函数时输出提示信息：\n  - 如果 `par` 或 `val` 的长度不是 $n - 1$，则输出 `Invalid output!`。\n  - 如果 `par` 数组与树的形态不同，那么它会给出**第一个**错误的位置，并返回如下格式的错误信息：`The answer to p[i] is wrong! The right answer is j, but you output k.`。注意，这里 $2 \\le i \\le n$，$j = p_i$ 为 $i$ 号点的真正的父亲编号，$k = $ `par[i - 2]` 为你给出的位置编号。\n  - 如果 `par` 数组正确，但 `val` 数组与**初始时**树上边权值不同，那么它会给出你**第一个**错误的位置，并返回如下格式的错误信息：`The answer to v[i] is wrong! The right answer is j, but you output k.`。类似地，这里 $2 \\le i \\le n$，$j = v_i$ 为 $i$ 号点到它父亲的边的真正的初始权值，$k =$ `val[i - 2]` 为你给出的权值。\n  - 如果你给出的 `par` 和 `val` 数组正确，那么交互库会输出你调用 `exchange` 函数和 `query` 函数的次数。输出格式为：`Right output! cnt1 = A, cnt2= B.`，其中 $A$ 表示你调用 `exchange` 函数的次数，$B$ 表示你调用 `query` 函数的次数。\n- **使用下发的交互库时你可以通过调用多次 `answer` 函数对你的程序进行测试。但对于你提交的代码，如果调用 `answer` 函数超过 $1$ 次，便只能获得 $0$ 分。**\n\n**你的程序不应该操作标准输入输出，否则视为攻击交互库。**\n", "inputFormat": "见【测试程序方式】。", "outputFormat": "见【测试程序方式】。", "hint": "**【样例解释 #1】**\n\n一种可能的输入如下：\n\n+ $2$ 号点的父亲是 $1$，$1$ 到 $2$ 的边初始权值为 $2$。\n+ $3$ 号点的父亲是 $2$，$2$ 到 $3$ 的边初始权值为 $1$。\n\n一种可能的交互过程如下：\n\n+ 调用 `query(2)`，返回 $2$。\n+ 调用 `exchange(1, 2)`。此时，$1$ 到 $2$ 的边权值为 $1$，$2$ 到 $3$ 的边权值为 $2$。\n+ 调用 `query(2)`，返回 $1$。此时，我们可以知道 $1$ 与 $2$ 直接相连。\n+ 调用 `query(3)`，返回 $2$。\n+ 调用 `exchange(1, 2)`。\n+ 调用 `query(3)`，返回 $2$。此时，我们可以推出 $2$ 与 $3$ 直接相连。\n+ 调用 `query(2)`，返回 $2$。此时，我们可以推出在两次 `exchange` 操作之后，$1$ 到 $2$ 的边权值为 $2$，$2$ 到 $3$ 的边的权值为 $1$。\n+ 调用 `answer([1, 2], [2, 1])`，结束程序。\n\n**【样例解释 #2】**\n\n这个样例满足 $n \\le 50$ 和特殊性质 A 的条件。\n\n**【样例解释 #3】**\n\n这个样例满足 $n \\le 1000$。\n\n**【样例解释 #4】**\n\n这个样例满足 $n \\le 20000$ 和特殊性质 B 的条件。\n\n**【样例解释 #5】**\n\n这个样例满足 $n \\le 100000$ 和特殊性质 A 的条件。\n\n**【样例解释 #6】**\n\n这个样例满足 $n \\le 100000$。\n\n**【样例解释 #7】**\n\n这个样例满足 $n \\le 500000$。\n\n**【数据范围】**\n\n|测试点编号|$n=$|$lim1=$|$lim2=$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$10$|$1000001$|$1000001$|A|\n|$2$|$10$|$1000001$|$1000001$|A|\n|$3$|$50$|$1000002$|$1000002$|A|\n|$4$|$50$|$1000002$|$1000002$|A|\n|$5$|$600$|$3000003$|$3000003$|A|\n|$6$|$600$|$3000003$|$3000003$|A|\n|$7$|$1000$|$1100004$|$2200004$|A|\n|$8$|$1000$|$1100005$|$2200005$||\n|$9$|$1000$|$1100005$|$2200005$||\n|$10$|$20000$|$3000006$|$3000006$|B|\n|$11$|$20000$|$3000006$|$3000006$|B|\n|$12$|$20000$|$3000006$|$3000006$|B|\n|$13$|$100000$|$3000007$|$3000007$|A|\n|$14$|$100000$|$3000007$|$3000007$|A|\n|$15$|$100000$|$3000008$|$3000008$||\n|$16$|$100000$|$3000008$|$3000008$||\n|$17$|$100000$|$3000008$|$3000008$||\n|$18$|$500000$|$3500009$|$3500009$|A|\n|$19$|$500000$|$3500009$|$3500009$|A|\n|$20$|$500000$|$3500010$|$3500010$|B|\n|$21$|$500000$|$3500010$|$3500010$|B|\n|$22$|$500000$|$3500011$|$3500011$||\n|$23$|$500000$|$3500011$|$3500011$||\n|$24$|$500000$|$3500011$|$3500011$||\n|$25$|$500000$|$3500011$|$3500011$||\n\n特殊性质 A：\n\n+ 每个节点有不超过 $1$ 个儿子，即树的形态是一条链；\n+ 链的非根节点标号在所有可能的标号中等概率随机；\n+ 边的权值排列在所有 $(n - 1)!$ 种可能的排列中等概率随机。\n\n特殊性质 B：\n\n+ 树形态按如下方式随机生成：\n  - 先对每个 $2 \\le i \\le n$，令 $i$ 的父亲在 $[1, i - 1]$ 的整数之间等概率随机选取，\n  - **再等概率随机打乱非根节点的编号**，得到最终的带标号有根树的结构。\n+ 边的权值排列在所有 $(n - 1)!$ 种可能的排列中等概率随机。\n\n你可以根据 $lim1, lim2$ 的值来判断数据所满足的特殊性质。\n\n**【评分方式】**\n\n**本题首先会受到和传统题相同的限制**。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。\n\n在以上条件下，你能够拿到一个测试点的分数当且仅当你每次调用函数的参数格式正确，调用 `exchange` 函数的次数不超过 $lim1$ 次，调用 `query` 函数的次数不超过 $lim2$ 次，且**第一次**调用 `answer` 函数给出的 `par` 数组和 `val` 数组正确。\n\n保证在下发的交互库和最终评测的交互库中，`exchange` 和 `query` 函数的单次最坏复杂度是 $O(\\log n)$，在题目限制下使用时间不超过 $4$ 秒，最大空间占用不超过 $256$ MB。\n\n也就是说，你至少有 $4$ 秒的时间和 $768$ MB 的空间可以使用。\n\n**【提示】**\n\n我们再次提醒：**树的形态和每条边的权值是预先给定的，不会根据你的操作而动态生成。**\n\n你需要注意你的程序的时间开销和空间开销。\n\n**通过访问输入输出文件、攻击评测系统或攻击评测库等方式得分属于作弊行为，所得分数无效。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[WC/CTS2023] 树据结构", "background": "**这是一道交互题。**\n\n**在提交本题前请务必仔细阅读以下内容。**\n\n本题只支持 C++ 语言提交（建议使用 C++14，请不要使用 C++14 (GCC9)）。\n\n由于洛谷特殊的交互机制，在提交本题时，请去掉代码中的 ```#include \"ds.h\"``` 语句，并将以下内容粘贴到代码最开头，然后提交：\n\n```cpp\n#include <vector>\nvoid exchange(int x, int y);\nint query(int u);\nvoid answer(std::vector<int> par, std::vector<int> val);\n```\n\n如果您在提交本题时出现了任何意外的情况，请咨询管理员。", "description": "作为一个熟练的 OI 选手，你对数据结构的各种题型早已轻车熟路，比赛中只要碰到数据结构题就能三下五除二轻松搞定。这一天，你翻开 OJ，看到了这道题：\n\n给定 $n$ 个点的有根树，点编号为 $1, 2, \\dots, n$，$1$ 为根。每条边上有一个 $1$ 至 $n - 1$ 的**两两不同**的权值。维护一个数据结构，支持交换**权值为 $x$ 和 $y$** 的边的权值，以及询问从根节点到 $u$ 号点的所有的边的权值最大值。\n\n这种简单而经典的树上问题，对你已经是不在话下。厌倦了维护修改，回答询问的你，打算换一个角色。这回，你才是那个提问题的人，你需要构造合适的操作来套取题的数据。\n\n具体地说，现在你并不知道树的结构，也不知道初始时树上每条边的权值，你需要通过如下两种操作得到树的结构和 **初始时** 树上每条边的权值：\n\n1. 给出正整数 $x, y$，其中 $1 \\le x, y < n$，$x \\neq y$，交换 **权值为 $x, y$** 的两条边的权值。\n2. 给出正整数 $u$，其中 $2 \\le u \\le n$，并得到从 $1$ 号点到 $u$ 号点的路径上所有边中权值的最大值。\n\n**题目保证树的形态和每条边的权值是预先给定的，不会根据你的操作而动态生成。**\n\n**【实现细节】**\n\n你需要引用头文件 `#include \"ds.h\"`。你可以调用以下函数与交互库进行交互：\n\n```cpp\nvoid exchange(int x, int y);\n```\n\n+ 这个函数对应操作 $1$，表示交换**权值为 $x, y$** 的两条边的权值。\n+ 你需要保证 $1 \\le x, y < n$，$x \\neq y$。\n\n```cpp\nint query(int u);\n```\n\n+ 这个函数对应操作 $2$，返回从 $1$ 号点到 $u$ 号点的路径上所有边的权值的最大值。\n+ 你需要保证 $2 \\le u \\le n$。\n\n```cpp\nvoid answer(std::vector<int> par, std::vector<int> val);\n```\n\n- 这个函数用来回答你所得到的答案，格式如下：\n  - `par` 是一个长度为 $n - 1$ 的数组，其中 `par[i]` 表示树上 $i + 2$ 号节点的父亲编号，其中 $0 \\le i \\le n - 2$。\n  - `val` 也是一个长度为 $n - 1$ 的数组，其中 `val[i]` 表示树上 $i + 2$ 号节点到它父亲的边的**初始权值**，其中 $0 \\le i \\le n - 2$。\n- **你需要调用该函数恰好一次！**\n\n你不需要，也不应该实现主函数。在本题中，你只需要实现如下函数：\n\n```cpp\nvoid solve(int n, int lim1, int lim2);\n```\n\n- 其中，$n$ 表示树的点数，$lim1$ 表示操作 $1$ 的次数限制，$lim2$ 表示操作 $2$ 的次数限制。\n- 最终测试时，对于每个测试点，交互库会调用**恰好一次** `solve` 函数，并根据调用 `answer` 函数的正误来评分。\n\n在题目附件中，我们提供了 `sample.cpp` 供你参考，你可以在此基础上实现你的程序。\n\n**【测试程序方式】**\n\n题目附件中提供了 `grader.cpp` 文件。最终测试的交互库与下发交互库有不同，因此你的实现不应依赖交互库实现。\n\n你需要将你的程序 `ds.cpp` 和 `grader.cpp`、`ds.h` 放置在同一目录下，并在该目录下使用如下编译命令得到可执行程序 `ds(.exe)`：\n\n```bash\ng++ -o ds ds.cpp grader.cpp -O2 -std=c++14 -lm\n```\n\n**题目附件还提供了 `compile.sh`，其内容为该编译命令。你可以运行它进行编译，也可以复制该文件中的编译命令进行编译。**\n\n可执行程序从标准输入读入以下格式的数据：\n\n- 第一行包含三个正整数 $n, lim1, lim2$，表示树的点数，操作 $1$ 的限制次数和操作 $2$ 的限制次数。交互库保证可以处理 $2 \\le n \\le 500000$ 的情况，对于 $n > 500000$ 的情况不做正确运行保证。\n- 第二行 $n - 1$ 个正整数 $p_2, p_3, \\dots, p_n$。其中 $p_i$ 表示 $i$ 号点的父亲的节点编号。**你需要保证 $1 \\le p_i \\le n$ 且输入给出了合法的树的结构。**\n- 第三行 $n - 1$ 个正整数 $v_2, v_3, \\dots, v_n$。其中 $v_i$ 表示 $i$ 连向 $p_i$ 的边的权值。**你需要保证 $v_2, v_3, \\dots, v_n$ 构成 $1$ 至 $n - 1$ 的一个排列。**\n- **在本地测试时，请务必保证你的输入格式符合要求，否则我们不保证交互库会正常运行。**\n\n如果你的输入合法且没有运行错误，下发的交互库将会根据你的调用输出如下信息：\n\n- 如果某次 `exchange` 函数的调用违反了 $1 \\le x, y < n$，$x \\neq y$ 的限制，输出错误信息：`Invalid call of exchange(x, y)!`。\n- 如果 `exchange` 函数调用次数超过 $lim1$，输出错误信息：`Too many exchanges!`。\n- 如果某次 `query` 函数的调用违反了 $2 \\le u \\le n$ 的限制，输出错误信息：`Invalid call of query(u)!`。\n- 如果 `query` 函数调用次数超过 $lim2$，输出错误信息：`Too many queries!`。\n- 在输出任何以上错误信息后，交互库立即终止。\n- 交互库会在你**每次**调用 `answer` 函数时输出提示信息：\n  - 如果 `par` 或 `val` 的长度不是 $n - 1$，则输出 `Invalid output!`。\n  - 如果 `par` 数组与树的形态不同，那么它会给出**第一个**错误的位置，并返回如下格式的错误信息：`The answer to p[i] is wrong! The right answer is j, but you output k.`。注意，这里 $2 \\le i \\le n$，$j = p_i$ 为 $i$ 号点的真正的父亲编号，$k = $ `par[i - 2]` 为你给出的位置编号。\n  - 如果 `par` 数组正确，但 `val` 数组与**初始时**树上边权值不同，那么它会给出你**第一个**错误的位置，并返回如下格式的错误信息：`The answer to v[i] is wrong! The right answer is j, but you output k.`。类似地，这里 $2 \\le i \\le n$，$j = v_i$ 为 $i$ 号点到它父亲的边的真正的初始权值，$k =$ `val[i - 2]` 为你给出的权值。\n  - 如果你给出的 `par` 和 `val` 数组正确，那么交互库会输出你调用 `exchange` 函数和 `query` 函数的次数。输出格式为：`Right output! cnt1 = A, cnt2= B.`，其中 $A$ 表示你调用 `exchange` 函数的次数，$B$ 表示你调用 `query` 函数的次数。\n- **使用下发的交互库时你可以通过调用多次 `answer` 函数对你的程序进行测试。但对于你提交的代码，如果调用 `answer` 函数超过 $1$ 次，便只能获得 $0$ 分。**\n\n**你的程序不应该操作标准输入输出，否则视为攻击交互库。**\n", "inputFormat": "见【测试程序方式】。", "outputFormat": "见【测试程序方式】。", "hint": "**【样例解释 #1】**\n\n一种可能的输入如下：\n\n+ $2$ 号点的父亲是 $1$，$1$ 到 $2$ 的边初始权值为 $2$。\n+ $3$ 号点的父亲是 $2$，$2$ 到 $3$ 的边初始权值为 $1$。\n\n一种可能的交互过程如下：\n\n+ 调用 `query(2)`，返回 $2$。\n+ 调用 `exchange(1, 2)`。此时，$1$ 到 $2$ 的边权值为 $1$，$2$ 到 $3$ 的边权值为 $2$。\n+ 调用 `query(2)`，返回 $1$。此时，我们可以知道 $1$ 与 $2$ 直接相连。\n+ 调用 `query(3)`，返回 $2$。\n+ 调用 `exchange(1, 2)`。\n+ 调用 `query(3)`，返回 $2$。此时，我们可以推出 $2$ 与 $3$ 直接相连。\n+ 调用 `query(2)`，返回 $2$。此时，我们可以推出在两次 `exchange` 操作之后，$1$ 到 $2$ 的边权值为 $2$，$2$ 到 $3$ 的边的权值为 $1$。\n+ 调用 `answer([1, 2], [2, 1])`，结束程序。\n\n**【样例解释 #2】**\n\n这个样例满足 $n \\le 50$ 和特殊性质 A 的条件。\n\n**【样例解释 #3】**\n\n这个样例满足 $n \\le 1000$。\n\n**【样例解释 #4】**\n\n这个样例满足 $n \\le 20000$ 和特殊性质 B 的条件。\n\n**【样例解释 #5】**\n\n这个样例满足 $n \\le 100000$ 和特殊性质 A 的条件。\n\n**【样例解释 #6】**\n\n这个样例满足 $n \\le 100000$。\n\n**【样例解释 #7】**\n\n这个样例满足 $n \\le 500000$。\n\n**【数据范围】**\n\n|测试点编号|$n=$|$lim1=$|$lim2=$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$10$|$1000001$|$1000001$|A|\n|$2$|$10$|$1000001$|$1000001$|A|\n|$3$|$50$|$1000002$|$1000002$|A|\n|$4$|$50$|$1000002$|$1000002$|A|\n|$5$|$600$|$3000003$|$3000003$|A|\n|$6$|$600$|$3000003$|$3000003$|A|\n|$7$|$1000$|$1100004$|$2200004$|A|\n|$8$|$1000$|$1100005$|$2200005$||\n|$9$|$1000$|$1100005$|$2200005$||\n|$10$|$20000$|$3000006$|$3000006$|B|\n|$11$|$20000$|$3000006$|$3000006$|B|\n|$12$|$20000$|$3000006$|$3000006$|B|\n|$13$|$100000$|$3000007$|$3000007$|A|\n|$14$|$100000$|$3000007$|$3000007$|A|\n|$15$|$100000$|$3000008$|$3000008$||\n|$16$|$100000$|$3000008$|$3000008$||\n|$17$|$100000$|$3000008$|$3000008$||\n|$18$|$500000$|$3500009$|$3500009$|A|\n|$19$|$500000$|$3500009$|$3500009$|A|\n|$20$|$500000$|$3500010$|$3500010$|B|\n|$21$|$500000$|$3500010$|$3500010$|B|\n|$22$|$500000$|$3500011$|$3500011$||\n|$23$|$500000$|$3500011$|$3500011$||\n|$24$|$500000$|$3500011$|$3500011$||\n|$25$|$500000$|$3500011$|$3500011$||\n\n特殊性质 A：\n\n+ 每个节点有不超过 $1$ 个儿子，即树的形态是一条链；\n+ 链的非根节点标号在所有可能的标号中等概率随机；\n+ 边的权值排列在所有 $(n - 1)!$ 种可能的排列中等概率随机。\n\n特殊性质 B：\n\n+ 树形态按如下方式随机生成：\n  - 先对每个 $2 \\le i \\le n$，令 $i$ 的父亲在 $[1, i - 1]$ 的整数之间等概率随机选取，\n  - **再等概率随机打乱非根节点的编号**，得到最终的带标号有根树的结构。\n+ 边的权值排列在所有 $(n - 1)!$ 种可能的排列中等概率随机。\n\n你可以根据 $lim1, lim2$ 的值来判断数据所满足的特殊性质。\n\n**【评分方式】**\n\n**本题首先会受到和传统题相同的限制**。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。\n\n在以上条件下，你能够拿到一个测试点的分数当且仅当你每次调用函数的参数格式正确，调用 `exchange` 函数的次数不超过 $lim1$ 次，调用 `query` 函数的次数不超过 $lim2$ 次，且**第一次**调用 `answer` 函数给出的 `par` 数组和 `val` 数组正确。\n\n保证在下发的交互库和最终评测的交互库中，`exchange` 和 `query` 函数的单次最坏复杂度是 $O(\\log n)$，在题目限制下使用时间不超过 $4$ 秒，最大空间占用不超过 $256$ MB。\n\n也就是说，你至少有 $4$ 秒的时间和 $768$ MB 的空间可以使用。\n\n**【提示】**\n\n我们再次提醒：**树的形态和每条边的权值是预先给定的，不会根据你的操作而动态生成。**\n\n你需要注意你的程序的时间开销和空间开销。\n\n**通过访问输入输出文件、攻击评测系统或攻击评测库等方式得分属于作弊行为，所得分数无效。**", "locale": "zh-CN"}}}
{"pid": "P9076", "type": "P", "difficulty": 3, "samples": [["35", "2"]], "limits": {"time": [200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2018", "PA（波兰）"], "title": "[PA 2018] PIN", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda próbna [PIN](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/pin/)**\n\nBytie 忘记了手机密码。他记得它由三个不同的正整数 $a < b < c$ 组成。这些数字的总和是 $n$，此外每对数字（在 $(a, b)$，$(a,c)$ 和 $(b, c)$ 中）中，一个数字是另一个的倍数。\n\n帮助他计算需要检查的可能的三元组数目，以便他可以决定是否值得浪费在尝试密码上。", "inputFormat": "一行输入一个正整数 $n$。", "outputFormat": "输出一个整数，表示合法的三元组数目。", "hint": "#### 样例 1 解释\n\n有两个可行三元组：$(1,2,32)$，$(5,10,20)$。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] PIN", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda próbna [PIN](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/pin/)**\n\nBytie 忘记了手机密码。他记得它由三个不同的正整数 $a < b < c$ 组成。这些数字的总和是 $n$，此外每对数字（在 $(a, b)$，$(a,c)$ 和 $(b, c)$ 中）中，一个数字是另一个的倍数。\n\n帮助他计算需要检查的可能的三元组数目，以便他可以决定是否值得浪费在尝试密码上。", "inputFormat": "一行输入一个正整数 $n$。", "outputFormat": "输出一个整数，表示合法的三元组数目。", "hint": "#### 样例 1 解释\n\n有两个可行三元组：$(1,2,32)$，$(5,10,20)$。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P9077", "type": "P", "difficulty": 2, "samples": [["6\n2 1 5 3 1 1", "0\n5\n1 2\n2 3\n1 4\n1 5"], ["3\n1 2 2", "1\n3\n1 2\n2 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "Special Judge", "PA（波兰）"], "title": "[PA 2018] Poddrzewo", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 1 [Poddrzewo](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/pod/)**\n\n给定一个长度为 $n$ 的序列 $a$。\n\n构造一个结点数为 $k$ 的无根树，结点编号分别为 $1 \\cdots k$。该树第 $i$ 个结点的度数为 $a_i$。\n\n有可能无解，你可以进行如下操作来使其有解：\n\n1. 修改序列中第 $i$ 个数。\n1. 删除序列中第 $i$ 个数。\n1. 交换序列中第 $i,j$ 个数。\n\n可以证明，进行有限次操作后一定有解。\n\n你的任务是 **最小化操作 $1$ 使用的次数**。\n", "inputFormat": "一行一个整数 $n$，表示序列 $a$ 的长度。\n\n下一行有 $n$ 个整数，第 $i$ 个整数表示 $a_i$。\n", "outputFormat": "第一行一个整数 $x$ ，表示操作 $1$ 使用次数最小值。\n\n第二行一个整数 $k\\ (2 \\le k \\le n)$，表示你构造的树结点数目。\n\n接下来 $k-1$ 行，每行两个数 $u,v\\ (1 \\le u, v \\le k)$，表示连接第 $u,v$ 个结点。\n\n多解输出任意解。\n", "hint": "#### 样例 1 解释\n\n我们可以删除第 $3$ 个数字，然后更改元素的顺序。\n\n得到最后的序列为 $(3,2,1,1,1)$。\n\n这是构造的树的示意图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ptch7dx0.png)\n\n------------\n\n#### 样例 2 解释\n\n我们可以修改第 $3$ 个数字，得到最后的序列为 $(1,2,1)$。可以证明，操作 $1$ 至少需要使用 $1$ 次。\n\n这是构造的树的示意图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o6mhe76c.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据：\n\n- $2 \\le n \\le 10^6$\n- $1 \\le a_i \\le n-1$\n\n保证存在至少一个子任务，其中操作 $1$ 使用次数最小值为 $0$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Poddrzewo", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 1 [Poddrzewo](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/pod/)**\n\n给定一个长度为 $n$ 的序列 $a$。\n\n构造一个结点数为 $k$ 的无根树，结点编号分别为 $1 \\cdots k$。该树第 $i$ 个结点的度数为 $a_i$。\n\n有可能无解，你可以进行如下操作来使其有解：\n\n1. 修改序列中第 $i$ 个数。\n1. 删除序列中第 $i$ 个数。\n1. 交换序列中第 $i,j$ 个数。\n\n可以证明，进行有限次操作后一定有解。\n\n你的任务是 **最小化操作 $1$ 使用的次数**。\n", "inputFormat": "一行一个整数 $n$，表示序列 $a$ 的长度。\n\n下一行有 $n$ 个整数，第 $i$ 个整数表示 $a_i$。\n", "outputFormat": "第一行一个整数 $x$ ，表示操作 $1$ 使用次数最小值。\n\n第二行一个整数 $k\\ (2 \\le k \\le n)$，表示你构造的树结点数目。\n\n接下来 $k-1$ 行，每行两个数 $u,v\\ (1 \\le u, v \\le k)$，表示连接第 $u,v$ 个结点。\n\n多解输出任意解。\n", "hint": "#### 样例 1 解释\n\n我们可以删除第 $3$ 个数字，然后更改元素的顺序。\n\n得到最后的序列为 $(3,2,1,1,1)$。\n\n这是构造的树的示意图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ptch7dx0.png)\n\n------------\n\n#### 样例 2 解释\n\n我们可以修改第 $3$ 个数字，得到最后的序列为 $(1,2,1)$。可以证明，操作 $1$ 至少需要使用 $1$ 次。\n\n这是构造的树的示意图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o6mhe76c.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据：\n\n- $2 \\le n \\le 10^6$\n- $1 \\le a_i \\le n-1$\n\n保证存在至少一个子任务，其中操作 $1$ 使用次数最小值为 $0$。\n", "locale": "zh-CN"}}}
{"pid": "P9078", "type": "P", "difficulty": 1, "samples": [["kostka", "6"], ["aaaa", "3"]], "limits": {"time": [250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "PA（波兰）"], "title": "[PA 2018] Język polski", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 1 [Język polski](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/pol/)** 。\n\n给定一个字符串 $s$ ，求出该字符串中满足以下条件的子串的数量。\n\n- 该字符串中至少有一个长度为 $3$ 的子串仅由辅音字母或仅由元音字母构成。\n\n注意，**波兰语的元音字母与英语不同**。波兰语中元音字母有 $a,e,i,o,u,y$。\n\n不是元音字母的字母即为辅音字母。", "inputFormat": "一行仅包含小写字母的字符串 $s$。", "outputFormat": "一行一个整数，表示满足条件的子串数。", "hint": "#### 样例 1 解释\n\n所有满足条件的子串列举如下：$\\texttt{stk},\\texttt{ostk},\\texttt{kostk},\\texttt{stka},\\texttt{ostka},\\texttt{kostka}$。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n设字符串长度为 $\\mathrm{len}$ ，则 $\\mathrm{len} \\le 200000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Język polski", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 1 [Język polski](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/pol/)** 。\n\n给定一个字符串 $s$ ，求出该字符串中满足以下条件的子串的数量。\n\n- 该字符串中至少有一个长度为 $3$ 的子串仅由辅音字母或仅由元音字母构成。\n\n注意，**波兰语的元音字母与英语不同**。波兰语中元音字母有 $a,e,i,o,u,y$。\n\n不是元音字母的字母即为辅音字母。", "inputFormat": "一行仅包含小写字母的字符串 $s$。", "outputFormat": "一行一个整数，表示满足条件的子串数。", "hint": "#### 样例 1 解释\n\n所有满足条件的子串列举如下：$\\texttt{stk},\\texttt{ostk},\\texttt{kostk},\\texttt{stka},\\texttt{ostka},\\texttt{kostka}$。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n设字符串长度为 $\\mathrm{len}$ ，则 $\\mathrm{len} \\le 200000$。", "locale": "zh-CN"}}}
{"pid": "P9079", "type": "P", "difficulty": 0, "samples": [["6 5 1\n1 3\n2 3\n3 4\n4 5\n4 6", "2"], ["3 3 3\n1 2\n1 3\n2 3", "0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "PA（波兰）"], "title": "[PA 2018] Heros", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 2 [Heros](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/her/)**\n\n给定一个有向无环图，该图有 $n$ 个节点， $m$ 条有向边。\n\n你需要从中删除 $k$ 个点以及与其关联的边，使得图中的最长链最短。", "inputFormat": "第一行三个整数，分别表示 $n$ , $m$ , $k$。\n\n接下来 $m$ 行，每行两个整数 $x$ , $y$ ，表示从 $x$ 点到 $y$ 点有一条有向边。\n", "outputFormat": "一行一个整数，表示图中最长链的长度最小值。", "hint": "#### 样例 1 解释\n\n删除编号为 $4$ 的点后，图中的最长链长度为 $2$ 。即为我们可以得到的最长链长度的最小值。可以验证所有方案中图中最长链长度最小为 $2$ 。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6sgk5qmj.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le n \\le 300$\n- $0 \\le m \\le 400$\n- $0 \\le k \\le \\min(n,4)$\n- $1 \\le x < y \\le n$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Heros", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 2 [Heros](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/her/)**\n\n给定一个有向无环图，该图有 $n$ 个节点， $m$ 条有向边。\n\n你需要从中删除 $k$ 个点以及与其关联的边，使得图中的最长链最短。", "inputFormat": "第一行三个整数，分别表示 $n$ , $m$ , $k$。\n\n接下来 $m$ 行，每行两个整数 $x$ , $y$ ，表示从 $x$ 点到 $y$ 点有一条有向边。\n", "outputFormat": "一行一个整数，表示图中最长链的长度最小值。", "hint": "#### 样例 1 解释\n\n删除编号为 $4$ 的点后，图中的最长链长度为 $2$ 。即为我们可以得到的最长链长度的最小值。可以验证所有方案中图中最长链长度最小为 $2$ 。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6sgk5qmj.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le n \\le 300$\n- $0 \\le m \\le 400$\n- $0 \\le k \\le \\min(n,4)$\n- $1 \\le x < y \\le n$", "locale": "zh-CN"}}}
{"pid": "P9080", "type": "P", "difficulty": 0, "samples": [["3\n8\n5\n13", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "PA（波兰）"], "title": "[PA 2018] Nowy kontrakt", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 2 [Nowy kontrakt](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/kon/)** 。\n\n给定一个长度为 $N$ 的正整数序列 $a$ ，你需要对序列内数末尾添加数字的方法使序列**严格单调递增**，你的目标是最小化添加数字的次数。\n\n在数 $a$ 后添加数字 $t$ 即为：\n\n$a \\gets a \\times 10 + t$ ,其中 $t \\in \\{0,1,2,3,4,5,6,7,8,9\\}$\n\n", "inputFormat": "第一行一个整数 $N$ 表示序列长度。\n\n第 $2$ 行至 $N+1$ 行每行一个数，第 $i$ 行表示序列中第 $i-1$ 个数。", "outputFormat": "一行一个整数，表示最小操作次数。", "hint": "#### 样例 1 解释\n\n对第 $2$ 个数字和第 $3$ 个数字分别添加一个数字，即 $a_2 \\gets a_2 \\times 10 + 7$ ， $a_3 \\gets a_3 \\times 10 + 3$ 。 得到的新序列为 $(8,57,133)$ ，是一个严格单调递增序列。操作次数为 $2$ ，还有其他的操作次数为 $2$ 的方法，但是不存在操作次数为 $1$ 的方法。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le N \\le 200000$ \n- $1 \\le a_i \\le 10^9$ ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Nowy kontrakt", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 2 [Nowy kontrakt](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/kon/)** 。\n\n给定一个长度为 $N$ 的正整数序列 $a$ ，你需要对序列内数末尾添加数字的方法使序列**严格单调递增**，你的目标是最小化添加数字的次数。\n\n在数 $a$ 后添加数字 $t$ 即为：\n\n$a \\gets a \\times 10 + t$ ,其中 $t \\in \\{0,1,2,3,4,5,6,7,8,9\\}$\n\n", "inputFormat": "第一行一个整数 $N$ 表示序列长度。\n\n第 $2$ 行至 $N+1$ 行每行一个数，第 $i$ 行表示序列中第 $i-1$ 个数。", "outputFormat": "一行一个整数，表示最小操作次数。", "hint": "#### 样例 1 解释\n\n对第 $2$ 个数字和第 $3$ 个数字分别添加一个数字，即 $a_2 \\gets a_2 \\times 10 + 7$ ， $a_3 \\gets a_3 \\times 10 + 3$ 。 得到的新序列为 $(8,57,133)$ ，是一个严格单调递增序列。操作次数为 $2$ ，还有其他的操作次数为 $2$ 的方法，但是不存在操作次数为 $1$ 的方法。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le N \\le 200000$ \n- $1 \\le a_i \\le 10^9$ ", "locale": "zh-CN"}}}
{"pid": "P9081", "type": "P", "difficulty": 6, "samples": [["4\n0 0 0 -1\n-1 5 -2 2\n4 0 4 1\n2 2 6 6", "4.8000000000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "Special Judge", "PA（波兰）"], "title": "[PA 2018] Magiczne wieże", "background": "", "description": "**译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/)  Runda 3 [Magiczne wieże](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/mag/)**\n\n在一个王国中有 $n$ 个魔法师。每个魔法师有两座魔法塔。并且魔法师可以在自己的两座塔之间随意传送。\n\n出于某种原因，该国的居民只想居住在被魔法师环绕的区域。具体来说，如果一位居民从住所向任何方向移动，他都将接近其中一个魔法师（无论在哪个塔），他的住所就是安全的。\n\n依次连接所有的安全住所，它们围成了一个安全区域，请你求出这个区域的面积。", "inputFormat": "第一行一个整数 $n$，表示魔法师的数量。\n\n接下来的 $n$ 行，每行 $4$ 个整数 $ax_i,ay_i,bx_i,by_i$，表示第 $i$ 个魔法师所拥有的两座魔法塔 $a,b$。\n\n数据保证没有两座塔在同一位置上。", "outputFormat": "输出安全区域的面积。特殊地，如果没有安全点，那么区域的面积为 $0$。\n\n你的输出与标准答案的相对误差不能超过 $10^{-8}$。", "hint": "#### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yul09fhv.png)\n\n如图，黑色线段为一位魔法师的两座塔，灰色区域为安全区域。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，$3\\leq n\\leq 100$，$-500\\leq ax_i,ay_i,bx_i,by_i\\leq 500$。\n\n共 $10$ 个子任务，其中以下各个条件均至少有一个子任务满足：（每行为一个条件）\n\n- $n\\leq 10$，$-30\\leq ax_i,ay_i,bx_i,by_i\\leq 30$。\n\n- $n\\leq 10$。\n\n- $-30\\leq ax_i,ay_i,bx_i,by_i\\leq 30$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Magiczne wieże", "background": "", "description": "**译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/)  Runda 3 [Magiczne wieże](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/mag/)**\n\n在一个王国中有 $n$ 个魔法师。每个魔法师有两座魔法塔。并且魔法师可以在自己的两座塔之间随意传送。\n\n出于某种原因，该国的居民只想居住在被魔法师环绕的区域。具体来说，如果一位居民从住所向任何方向移动，他都将接近其中一个魔法师（无论在哪个塔），他的住所就是安全的。\n\n依次连接所有的安全住所，它们围成了一个安全区域，请你求出这个区域的面积。", "inputFormat": "第一行一个整数 $n$，表示魔法师的数量。\n\n接下来的 $n$ 行，每行 $4$ 个整数 $ax_i,ay_i,bx_i,by_i$，表示第 $i$ 个魔法师所拥有的两座魔法塔 $a,b$。\n\n数据保证没有两座塔在同一位置上。", "outputFormat": "输出安全区域的面积。特殊地，如果没有安全点，那么区域的面积为 $0$。\n\n你的输出与标准答案的相对误差不能超过 $10^{-8}$。", "hint": "#### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yul09fhv.png)\n\n如图，黑色线段为一位魔法师的两座塔，灰色区域为安全区域。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，$3\\leq n\\leq 100$，$-500\\leq ax_i,ay_i,bx_i,by_i\\leq 500$。\n\n共 $10$ 个子任务，其中以下各个条件均至少有一个子任务满足：（每行为一个条件）\n\n- $n\\leq 10$，$-30\\leq ax_i,ay_i,bx_i,by_i\\leq 30$。\n\n- $n\\leq 10$。\n\n- $-30\\leq ax_i,ay_i,bx_i,by_i\\leq 30$。", "locale": "zh-CN"}}}
{"pid": "P9082", "type": "P", "difficulty": 7, "samples": [["2 12\n3\n0 -8 -512\n-16 -1 -128\n8 -2 -512\n3\n0 64 -1\n64 -1 -1\n1 -1 -1", "R TANK\nM 0 0 1 0\n=\n=\nM 1 0 1 1\nR FARMER\nM 0 0 1 0\n=\nM 1 0 2 0\n=\nM 2 0 1 0\n=\nM 1 0 0 0\n=\n===\nR FARMER\nM 0 0 0 1\nR FARMER\nM 0 0 1 0\n=\n=\n=\n=\nM 0 1 0 0\n=\nM 0 0 0 1\n=\n=\nM 1 0 2 0\n=\nM 2 0 1 0\n=\nM 1 0 0 0\n=\nM 0 0 1 0\n=\nR FARMER\nM 1 0 2 0\nM 0 0 1 0\nM 0 1 0 0\n=\n==="]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "Special Judge", "PA（波兰）"], "title": "[PA 2018] Gra", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Gra](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/gra/)**\n\n现在已经是周末了！你终于可以放松一下，玩你最喜欢的策略游戏了。这个游戏的目标是收集地图上的所有金币并将它们运回基地，规则如下：\n\n- 地图由一个 $n\\times n$ 的网格构成。行从上到下编号为 $0$ 到 $n-1$，列从左到右编号为 $0$ 到 $n-1$。我们用 $(r,c)$ 表示第 $r$ 行第 $c$ 列的单元格。两单元格相邻当且仅当它们共享同一条边。\n- 你的基地位于单元格 $(0,0)$，它位于左上角。你可以在那里招募新的角色，并且你必须把收集到的金币带到那里。剩下的 $n^2-1$ 个格子中初始要么有一定数量的金币，要么有一定数量的石头。\n- 游戏中有两种可以在地图上移动的角色：**农民**可以收集金币，但不可以进入有石头的单元格，**坦克**可以清除石头，并且可以进入任何种类的单元格。\n- 游戏分轮次进行。每轮每个角色可以至多移动一次，移动到与它所在的单元格相邻的单元格中。两个角色不能在同一时间处于同一单元格中。所有移动都是瞬时的（移动花费的时间为零）。\n- 如果在一轮结束时，农民位于有金币的单元格中，他就会拿走 $10$ 枚金币并放到自己的背包里。如果单元格中的金币少于 $10$ 枚，他就会全部拿走。农民的背包容量无限。但农民无法进入石头量不为 $0$ 的单元格中。如果在一轮结束时农民回到了基地，他就会把背包里所有的金币放回基地。\n- 如果在一轮结束时，坦克位于有石头的单元格中，它就会清除单元格中的 $10$ 个石头（如果少于 $10$ 个则清除全部）。\n- 最初基地中有 $200$ 枚金币。每买一种角色——农民或者坦克——都要花费 $100$ 金币（买之前在基地中必须至少有这么多金币），买后角色即时出现。所以新角色可以在同一轮移动。\n\n你的任务是，对于每一个输入给定的地图（也就是对于每个测试点），找到一个操作序列，使得按这个操作序列进行游戏后，所有地图上的金币都被运回了基地（并且可能部分或全部花掉了）。换句话说，结束后的地图上，任何单元格中都没有金币，任何农民的背包里也没有金币。命令如下表所示：\n\n|                   命令                   |                           效果                           |\n| :--------------------------------------: | :------------------------------------------------------: |\n|           $\\texttt{R FARMER}$            |              买一个农民角色，并出生在基地中              |\n|            $\\texttt{R TANK}$             |              买一个坦克角色，并出生在基地中              |\n| $\\texttt{M}\\ \\ r_1\\ \\ c_1\\ \\ r_2\\ \\ c_2$ | 将一个角色从 $(r_1,c_1)$ 移动到相邻的格子 $(r_2,c_2)$ 中 |\n|               $\\texttt{=}$               |                         结束这轮                         |\n|              $\\texttt{===}$              |              结束游戏（即目前的这个测试点）              |\n\n你的程序会使用组织者准备的测试数据进行测试，每组测试数据由一定数量的地图——也就是测试点组成。每组测试数据都有一个限制 $k$（请参考「数据范围及限制」一节）。这是对于每组数据平均轮数的限制。换句话说，如果测试数据中有 $T$ 张地图，你的程序必须在最多 $T\\cdot k$ 轮结束所有游戏。我们定义每个测试点的轮数为使用命令 $\\texttt{=}$ 的次数加 $1$。\n\n错误的命令，超出轮数限制或没有达成目标，均会被判为 Wrong Answer。", "inputFormat": "第一行包含两个整数 $T,k$，表示测试点个数和平均轮数限制。除了样例外所有测试数据都有 $T=10$。\n\n对于每组数据，第一行一个正整数 $n$。除了样例外所有测试数据都有 $n=20$。\n\n接下来 $n$ 行，每行 $n$ 个整数。$0$ 表示基地（一定位于左上角）。正数 $a$ 意味着这个单元格有 $a$ 枚金币，负数 $a$ 意味着这个单元格有 $|a|$ 个石头。\n\n地图按如下方式生成：对于每组测试数据，组织者会选择一个常数 $p\\ (0\\le p<1)$，表示单元格中有石头的概率。对于每个除基地以外的单元格，随机选择一个在 $0$ 到 $9$ 范围内的整数 $x$，然后将 $a=2^x$ 赋给这个单元格。在此之后，以 $p$ 的概率给这个值乘以 $-1$。", "outputFormat": "对于每组测试点，输出操作序列。一条命令输出一行。最多输出 $2\\ 000\\ 000$ 条命令。", "hint": "#### 样例 1 解释\n\n对于第一个测试点，我们首先买了一辆坦克，并立即从 $(0,0)$ 移动到 $(1,0)$，这样在两轮中清除掉了所有石头。然后我们将坦克移动到 $(1,1)$，在基地中买一个农民，并将其送到 $(2,0)$ 收集金币。当金币收集完后，我们让农民返回金币并清空背包。我们可以在第一轮就购买一个农民，但他需要一直等到坦克清除石头后才能移动。\n\n第二个测试点展示了一种不是最优但正确的答案。注意农民可以在不收集全部金币的情况下离开这个单元格。招募前两个角色就会花掉所有初始金币（$200$），所以我们只能在农民向基地运回 $100$ 金币后买第三个角色。\n\n第一个测试点中使用了 $7$ 轮，第二个测试点使用了 $13$ 轮。平均是 $10$ 轮，没有超过给定 $k$ 的限制。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n共有十个子任务，每个子任务包含 $2$ 到 $5$ 个测试数据。确切的 $p$ 值和 $k$ 值如下表所示：\n\n| $\\text{id}$ |   1    |   2    |   3    |   4   |   5   |   6    |   7    |   8    |   9    |  10   |\n| :---------: | :----: | :----: | :----: | :---: | :---: | :----: | :----: | :----: | :----: | :---: |\n|     $p$     |  $0$   |  $0$   |  $0$   |  $0$  |  $0$  | $0.3$  | $0.4$  | $0.5$  | $0.6$  | $0.7$ |\n|     $k$     | $9000$ | $3500$ | $1500$ | $600$ | $370$ | $1000$ | $1500$ | $3500$ | $1200$ | $750$ |\n\n请注意样例和测试数据在地图大小和测试点个数上稍有不同。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Gra", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Gra](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/gra/)**\n\n现在已经是周末了！你终于可以放松一下，玩你最喜欢的策略游戏了。这个游戏的目标是收集地图上的所有金币并将它们运回基地，规则如下：\n\n- 地图由一个 $n\\times n$ 的网格构成。行从上到下编号为 $0$ 到 $n-1$，列从左到右编号为 $0$ 到 $n-1$。我们用 $(r,c)$ 表示第 $r$ 行第 $c$ 列的单元格。两单元格相邻当且仅当它们共享同一条边。\n- 你的基地位于单元格 $(0,0)$，它位于左上角。你可以在那里招募新的角色，并且你必须把收集到的金币带到那里。剩下的 $n^2-1$ 个格子中初始要么有一定数量的金币，要么有一定数量的石头。\n- 游戏中有两种可以在地图上移动的角色：**农民**可以收集金币，但不可以进入有石头的单元格，**坦克**可以清除石头，并且可以进入任何种类的单元格。\n- 游戏分轮次进行。每轮每个角色可以至多移动一次，移动到与它所在的单元格相邻的单元格中。两个角色不能在同一时间处于同一单元格中。所有移动都是瞬时的（移动花费的时间为零）。\n- 如果在一轮结束时，农民位于有金币的单元格中，他就会拿走 $10$ 枚金币并放到自己的背包里。如果单元格中的金币少于 $10$ 枚，他就会全部拿走。农民的背包容量无限。但农民无法进入石头量不为 $0$ 的单元格中。如果在一轮结束时农民回到了基地，他就会把背包里所有的金币放回基地。\n- 如果在一轮结束时，坦克位于有石头的单元格中，它就会清除单元格中的 $10$ 个石头（如果少于 $10$ 个则清除全部）。\n- 最初基地中有 $200$ 枚金币。每买一种角色——农民或者坦克——都要花费 $100$ 金币（买之前在基地中必须至少有这么多金币），买后角色即时出现。所以新角色可以在同一轮移动。\n\n你的任务是，对于每一个输入给定的地图（也就是对于每个测试点），找到一个操作序列，使得按这个操作序列进行游戏后，所有地图上的金币都被运回了基地（并且可能部分或全部花掉了）。换句话说，结束后的地图上，任何单元格中都没有金币，任何农民的背包里也没有金币。命令如下表所示：\n\n|                   命令                   |                           效果                           |\n| :--------------------------------------: | :------------------------------------------------------: |\n|           $\\texttt{R FARMER}$            |              买一个农民角色，并出生在基地中              |\n|            $\\texttt{R TANK}$             |              买一个坦克角色，并出生在基地中              |\n| $\\texttt{M}\\ \\ r_1\\ \\ c_1\\ \\ r_2\\ \\ c_2$ | 将一个角色从 $(r_1,c_1)$ 移动到相邻的格子 $(r_2,c_2)$ 中 |\n|               $\\texttt{=}$               |                         结束这轮                         |\n|              $\\texttt{===}$              |              结束游戏（即目前的这个测试点）              |\n\n你的程序会使用组织者准备的测试数据进行测试，每组测试数据由一定数量的地图——也就是测试点组成。每组测试数据都有一个限制 $k$（请参考「数据范围及限制」一节）。这是对于每组数据平均轮数的限制。换句话说，如果测试数据中有 $T$ 张地图，你的程序必须在最多 $T\\cdot k$ 轮结束所有游戏。我们定义每个测试点的轮数为使用命令 $\\texttt{=}$ 的次数加 $1$。\n\n错误的命令，超出轮数限制或没有达成目标，均会被判为 Wrong Answer。", "inputFormat": "第一行包含两个整数 $T,k$，表示测试点个数和平均轮数限制。除了样例外所有测试数据都有 $T=10$。\n\n对于每组数据，第一行一个正整数 $n$。除了样例外所有测试数据都有 $n=20$。\n\n接下来 $n$ 行，每行 $n$ 个整数。$0$ 表示基地（一定位于左上角）。正数 $a$ 意味着这个单元格有 $a$ 枚金币，负数 $a$ 意味着这个单元格有 $|a|$ 个石头。\n\n地图按如下方式生成：对于每组测试数据，组织者会选择一个常数 $p\\ (0\\le p<1)$，表示单元格中有石头的概率。对于每个除基地以外的单元格，随机选择一个在 $0$ 到 $9$ 范围内的整数 $x$，然后将 $a=2^x$ 赋给这个单元格。在此之后，以 $p$ 的概率给这个值乘以 $-1$。", "outputFormat": "对于每组测试点，输出操作序列。一条命令输出一行。最多输出 $2\\ 000\\ 000$ 条命令。", "hint": "#### 样例 1 解释\n\n对于第一个测试点，我们首先买了一辆坦克，并立即从 $(0,0)$ 移动到 $(1,0)$，这样在两轮中清除掉了所有石头。然后我们将坦克移动到 $(1,1)$，在基地中买一个农民，并将其送到 $(2,0)$ 收集金币。当金币收集完后，我们让农民返回金币并清空背包。我们可以在第一轮就购买一个农民，但他需要一直等到坦克清除石头后才能移动。\n\n第二个测试点展示了一种不是最优但正确的答案。注意农民可以在不收集全部金币的情况下离开这个单元格。招募前两个角色就会花掉所有初始金币（$200$），所以我们只能在农民向基地运回 $100$ 金币后买第三个角色。\n\n第一个测试点中使用了 $7$ 轮，第二个测试点使用了 $13$ 轮。平均是 $10$ 轮，没有超过给定 $k$ 的限制。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n共有十个子任务，每个子任务包含 $2$ 到 $5$ 个测试数据。确切的 $p$ 值和 $k$ 值如下表所示：\n\n| $\\text{id}$ |   1    |   2    |   3    |   4   |   5   |   6    |   7    |   8    |   9    |  10   |\n| :---------: | :----: | :----: | :----: | :---: | :---: | :----: | :----: | :----: | :----: | :---: |\n|     $p$     |  $0$   |  $0$   |  $0$   |  $0$  |  $0$  | $0.3$  | $0.4$  | $0.5$  | $0.6$  | $0.7$ |\n|     $k$     | $9000$ | $3500$ | $1500$ | $600$ | $370$ | $1000$ | $1500$ | $3500$ | $1200$ | $750$ |\n\n请注意样例和测试数据在地图大小和测试点个数上稍有不同。", "locale": "zh-CN"}}}
{"pid": "P9083", "type": "P", "difficulty": 7, "samples": [["4\n3 5\n2 1\n1 4\n2 1", "27\n24\n25\n35"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "PA（波兰）"], "title": "[PA 2018] Ryki", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Ryki](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/ryk/)**\n\nBerlandia 是一个由方格组成的无限大棋盘。行从下到上用递增的整数编号，列从左到右用递增的整数编号。令 $(r,c)$ 表示第 $r$ 行第 $c$ 列的方格。如果两个不同方格至少有一个角接触，我们就称这两个格子相邻。这意味着格子是八连通的。\n\n两个格子 $(R_A,C_A)$ 与 $(R_B,C_B)$ 之间的距离是欧几里得距离，也就是：\n$$\n\\sqrt{(R_A-R_B)^2+(C_A-C_B)^2}\n$$\nBerlandia 地区居住着 $n$ 只熊。第 $i$ 只熊居住在方格 $(r_i,c_i)$ 处。同一方格中可以居住多只熊。\n\n熊可以单独生活，但是有时也会相互靠近。当一只熊吼叫时，其他方格中所有的熊会立即移动到相邻的方格中离吼叫的熊最近的方格。可以证明有且仅有一个这样的方格（不会出现并列情况）。与吼叫的熊在同一方格的熊不会移动位置。\n\n例如，考虑一对熊，一只在方格 $(2,1)$，另一只在方格 $(4,8)$。方格 $(2,1)$ 中的熊吼叫会让另一只熊移向方格 $(3,7)$ ，这两只熊最后相距 $\\sqrt{(3-2)^2+(7-1)^2}=\\sqrt{37}$。\n\n这些熊会按第一只，第二只，……，最后一只的顺序依次吼叫。除了一只叫 Limak 的熊，他太冷了以至于吼不出来，并且他也不能离开他所在的方格，可怜的 Limak。\n\n但你不知道 Limak 是哪只熊，对于 $1$ 到 $n$ 的每一个 $k$，如果第 $k$ 只熊是 Limak，请找出所有熊的最终位置。对于每种可能，输出所有熊的横纵坐标乘积之和就可以了。也就是说，假设在 $n-1$ 次吼叫后，第 $i$ 只熊在 $(r_i',c_i')$，则输出：\n$$\n\\sum_{i=1}^n r_i'c_i'\n$$\n", "inputFormat": "输入第一行包括一个正整数 $n\\ (2\\le n\\le 250\\ 000)$，表示熊的数量。\n\n接下来 $n$ 行，每行两个整数 $r_i,c_i\\ (1\\le r_i,c_i\\le 10^6)$，第 $i$ 行表示第 $i$ 只熊的初始位置。", "outputFormat": "输出 $n$ 行，第 $k$ 行输出一个整数，表示假设 Limak 是第 $k$ 只熊的话，最终所有熊所在行列之积的和。", "hint": "#### 样例 1 解释\n\n下图展示了 $k=2$ 的情况，即熊的吼叫顺序为 $1,3,4$。红色圆圈表示吼叫的熊。最后乘积的和为 $2 \\cdot 4 + 2 \\cdot 1 + 2 \\cdot 4 + 2 \\cdot 3 = 24$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ri72cgjf.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n保证每组子任务中下述三种情况至少出现一种：\n\n- $n\\le 10^5$\n- 对于所有 $i$ 都有 $c_i=1$\n- 时间限制为 $8$ 秒\n\n注：由于未公布每个测试点的详细时间限制，因此本题所有测试点的时间限制均为 $4$ 秒。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Ryki", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Ryki](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/ryk/)**\n\nBerlandia 是一个由方格组成的无限大棋盘。行从下到上用递增的整数编号，列从左到右用递增的整数编号。令 $(r,c)$ 表示第 $r$ 行第 $c$ 列的方格。如果两个不同方格至少有一个角接触，我们就称这两个格子相邻。这意味着格子是八连通的。\n\n两个格子 $(R_A,C_A)$ 与 $(R_B,C_B)$ 之间的距离是欧几里得距离，也就是：\n$$\n\\sqrt{(R_A-R_B)^2+(C_A-C_B)^2}\n$$\nBerlandia 地区居住着 $n$ 只熊。第 $i$ 只熊居住在方格 $(r_i,c_i)$ 处。同一方格中可以居住多只熊。\n\n熊可以单独生活，但是有时也会相互靠近。当一只熊吼叫时，其他方格中所有的熊会立即移动到相邻的方格中离吼叫的熊最近的方格。可以证明有且仅有一个这样的方格（不会出现并列情况）。与吼叫的熊在同一方格的熊不会移动位置。\n\n例如，考虑一对熊，一只在方格 $(2,1)$，另一只在方格 $(4,8)$。方格 $(2,1)$ 中的熊吼叫会让另一只熊移向方格 $(3,7)$ ，这两只熊最后相距 $\\sqrt{(3-2)^2+(7-1)^2}=\\sqrt{37}$。\n\n这些熊会按第一只，第二只，……，最后一只的顺序依次吼叫。除了一只叫 Limak 的熊，他太冷了以至于吼不出来，并且他也不能离开他所在的方格，可怜的 Limak。\n\n但你不知道 Limak 是哪只熊，对于 $1$ 到 $n$ 的每一个 $k$，如果第 $k$ 只熊是 Limak，请找出所有熊的最终位置。对于每种可能，输出所有熊的横纵坐标乘积之和就可以了。也就是说，假设在 $n-1$ 次吼叫后，第 $i$ 只熊在 $(r_i',c_i')$，则输出：\n$$\n\\sum_{i=1}^n r_i'c_i'\n$$\n", "inputFormat": "输入第一行包括一个正整数 $n\\ (2\\le n\\le 250\\ 000)$，表示熊的数量。\n\n接下来 $n$ 行，每行两个整数 $r_i,c_i\\ (1\\le r_i,c_i\\le 10^6)$，第 $i$ 行表示第 $i$ 只熊的初始位置。", "outputFormat": "输出 $n$ 行，第 $k$ 行输出一个整数，表示假设 Limak 是第 $k$ 只熊的话，最终所有熊所在行列之积的和。", "hint": "#### 样例 1 解释\n\n下图展示了 $k=2$ 的情况，即熊的吼叫顺序为 $1,3,4$。红色圆圈表示吼叫的熊。最后乘积的和为 $2 \\cdot 4 + 2 \\cdot 1 + 2 \\cdot 4 + 2 \\cdot 3 = 24$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ri72cgjf.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n保证每组子任务中下述三种情况至少出现一种：\n\n- $n\\le 10^5$\n- 对于所有 $i$ 都有 $c_i=1$\n- 时间限制为 $8$ 秒\n\n注：由于未公布每个测试点的详细时间限制，因此本题所有测试点的时间限制均为 $4$ 秒。", "locale": "zh-CN"}}}
{"pid": "P9084", "type": "P", "difficulty": 6, "samples": [["5 3 100000007", "4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2018", "笛卡尔树", "PA（波兰）"], "title": "[PA 2018] Skwarki", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Skwarki](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/skw/)** 。\n\n求有多少种长度为 $ N $ 的满足以下条件的序列 ：\n\n* $ 1 \\sim N $ 这 $ N $ 个数在序列中各出现了一次；\n* 进行恰好 $K$ 次操作后，该序列才只含有 $1$ 个元素。\n\n下面对操作进行描述：\n\n设 $A_i$ 为序列中的第 $i$ 个元素（$1 < i < \\mathrm{len}$ ， $\\mathrm{len}$ 为序列长度），若 $A_{i-1} > A_{i}$ 或 $A_{i+1} > A_{i}$ 则标记 $A_i$ 。 若 $A_2 > A_1$ 则标记 $A_1$ ， 若 $A_{\\mathrm{len}-1} > A_{\\mathrm{len}}$ 则标记 $A_{\\mathrm{len}}$ 。\n\n然后，将有标记的元素从序列中删除。\n\n满足条件的序列可能很多，所以请将结果对 $P$ 取模。", "inputFormat": "输入仅一行，包含三个整数 $N,K,P$。", "outputFormat": "输出一行一个整数，表示满足条件的序列个数对 $P$ 取模的结果。", "hint": "#### 样例 1 解释\n\n所有满足条件的序列列举如下：\n\n- $(4,1,3,2,5)$\n- $(4,2,3,1,5)$\n- $(5,1,3,2,4)$\n- $(5,2,3,1,4)$\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1 \\le K,N \\le 1000$ , $N \\ge 2$ , $10^8 \\le P \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Skwarki", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Skwarki](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/skw/)** 。\n\n求有多少种长度为 $ N $ 的满足以下条件的序列 ：\n\n* $ 1 \\sim N $ 这 $ N $ 个数在序列中各出现了一次；\n* 进行恰好 $K$ 次操作后，该序列才只含有 $1$ 个元素。\n\n下面对操作进行描述：\n\n设 $A_i$ 为序列中的第 $i$ 个元素（$1 < i < \\mathrm{len}$ ， $\\mathrm{len}$ 为序列长度），若 $A_{i-1} > A_{i}$ 或 $A_{i+1} > A_{i}$ 则标记 $A_i$ 。 若 $A_2 > A_1$ 则标记 $A_1$ ， 若 $A_{\\mathrm{len}-1} > A_{\\mathrm{len}}$ 则标记 $A_{\\mathrm{len}}$ 。\n\n然后，将有标记的元素从序列中删除。\n\n满足条件的序列可能很多，所以请将结果对 $P$ 取模。", "inputFormat": "输入仅一行，包含三个整数 $N,K,P$。", "outputFormat": "输出一行一个整数，表示满足条件的序列个数对 $P$ 取模的结果。", "hint": "#### 样例 1 解释\n\n所有满足条件的序列列举如下：\n\n- $(4,1,3,2,5)$\n- $(4,2,3,1,5)$\n- $(5,1,3,2,4)$\n- $(5,2,3,1,4)$\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1 \\le K,N \\le 1000$ , $N \\ge 2$ , $10^8 \\le P \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P9085", "type": "P", "difficulty": 7, "samples": [["6 5 5", "42"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "PA（波兰）"], "title": "[PA 2018] Wielokąty", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Wielokąty](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/wie/)** 。\n\n请求出满足以下条件的多边形的个数：\n\n-  记该多边形的第 $i$ 个顶点为$(x_i,y_i)$ ，则 $x_i,y_i \\in \\mathbb{Z}$ 且 $1 \\le x_i \\le X$ , $1 \\le y_i \\le Y$ 。\n-  该多边形的任意一条边（不包含端点）不能经过格点（即横纵坐标都为整数的点）。\n-  该多边形的每一条边的长度都是不超过 $K$ 的整数。\n-  该多边形是一个凸多边形，而且不能退化（不能出现三点共线，自切，不小于 $180 ^{\\circ}$ 的角）。\n-  该多边形的每一条边都是线段。\n\n由于满足条件的多边形数量太大，你只需要输出其对 $2^{32}$ 取模后的值即可。 \n\n下图展示了三个不合法的多边形。第一个多边形的边经过了格点，第二个多边形退化了，第三个多边形不是凸的。而且第一，三个有的边长不是整数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/esporbly.png)\n\n我们将两个多边形看做不相同的多边形，当且仅当它们有至少一个顶点不相同。", "inputFormat": "输入只有一行，包含三个正整数 $X,Y,K$。", "outputFormat": "输出一行一个整数，即为满足条件的多边形的数量对 $2^{32}$ 取模后的值。\n", "hint": "#### 样例 1 解释\n\n下图展示了 $42$ 个合法多边形中的一个多边形。\n\n可以验证，该多边形满足每一个条件。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bs5qcmn5.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1 \\le X,Y \\le 10^9,1 \\le K \\le 250$ 。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Wielokąty", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Wielokąty](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/wie/)** 。\n\n请求出满足以下条件的多边形的个数：\n\n-  记该多边形的第 $i$ 个顶点为$(x_i,y_i)$ ，则 $x_i,y_i \\in \\mathbb{Z}$ 且 $1 \\le x_i \\le X$ , $1 \\le y_i \\le Y$ 。\n-  该多边形的任意一条边（不包含端点）不能经过格点（即横纵坐标都为整数的点）。\n-  该多边形的每一条边的长度都是不超过 $K$ 的整数。\n-  该多边形是一个凸多边形，而且不能退化（不能出现三点共线，自切，不小于 $180 ^{\\circ}$ 的角）。\n-  该多边形的每一条边都是线段。\n\n由于满足条件的多边形数量太大，你只需要输出其对 $2^{32}$ 取模后的值即可。 \n\n下图展示了三个不合法的多边形。第一个多边形的边经过了格点，第二个多边形退化了，第三个多边形不是凸的。而且第一，三个有的边长不是整数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/esporbly.png)\n\n我们将两个多边形看做不相同的多边形，当且仅当它们有至少一个顶点不相同。", "inputFormat": "输入只有一行，包含三个正整数 $X,Y,K$。", "outputFormat": "输出一行一个整数，即为满足条件的多边形的数量对 $2^{32}$ 取模后的值。\n", "hint": "#### 样例 1 解释\n\n下图展示了 $42$ 个合法多边形中的一个多边形。\n\n可以验证，该多边形满足每一个条件。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bs5qcmn5.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1 \\le X,Y \\le 10^9,1 \\le K \\le 250$ 。", "locale": "zh-CN"}}}
{"pid": "P9086", "type": "P", "difficulty": 2, "samples": [["1\n4\n1 2 3 4\n2 4 3 4", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「SvR-2」令人为难的区间操作问题", "background": "**Problem Number:** $\\textit{45}$\n\n众所周知，区间操作问题应该求出区间和、最大值等值。但今天小 F 有个不情之请。", "description": "小 F 正在研究[斐波那契数列](https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0)，他惊讶地发现，可以把这种数列 $F$ 的定义式略作修改，得到 $\\digamma$ 数列：\n\n$$\\digamma(x)=\\{1,1,-1,-1,1,1,-1,-1,1,\\ldots\\}$$\n\n注意到 $\\digamma$ 数列具有周期性，最小正周期 $T=4$。\n\n请注意这里 $\\digamma$ 数列与数学上用其表示的[双伽玛函数](https://zh.wikipedia.org/wiki/%E5%8F%8C%E4%BC%BD%E7%8E%9B%E5%87%BD%E6%95%B0)的区别。\n\n小 F 找到一个长度为 $n$ 的数列 $a$，他每次对其进行如下操作：\n\n- 选定两个整数 $l,r$，满足 $1\\le l\\le r\\le n$。\n- 对于每个满足 $l\\le i\\le r$ 的 $i$，将 $a_i$ 加上 $\\digamma(i-l+1)$。\n- 记录下本次操作（即第 $j$ 次操作）的选定区间的长度 $len_j=r-l+1$。\n\n他一共进行了 $m$ 次操作，操作后得到数列记作 $b$，同时记 $sum=\\sum_{i=1}^mlen_i$。\n\n不幸的是，小 F 把 $sum$ 和数列 $len$ 都弄丢了，他只记得 $n$ 和数列 $a,b$。\n\n现在，他想请你根据这些信息，求出 $sum$ 的**奇偶**，**即 $\\textbf{\\textit{sum}}$ 对 $\\textbf2$ 取模后的值**。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n接下来 $3\\cdot T$ 行，描述每组数据。对于每组数据：\n\n- 第一行一个整数 $n$。\n- 第二行 $n$ 个整数，描述数列 $a$。\n- 第三行 $n$ 个整数，描述数列 $b$。\n\n**数据保证数列 $a$ 一定可以经过若干操作变为数列 $b$。**", "outputFormat": "对于每组数据，输出仅一行一个数，即 $sum$ 对 $2$ 取模后的值。", "hint": "#### 样例 1 说明\n\n注意到可能进行的是如下操作：\n\n- 第 $1$ 次操作选定 $l=2,r=3$，则数列变成 $[1,{\\underline{\\color{red}\\textbf{3}}},{\\underline{\\color{red}\\textbf{4}}},4]$。此时 $len_1=2$。\n- 第 $2$ 次操作选定 $l=1,r=3$，则数列变成 $[{\\underline{\\color{red}\\textbf{2}}},{\\underline{\\color{red}\\textbf{4}}},{\\underline{\\color{red}\\textbf{3}}},4]$。此时 $len_2=3$。\n\n则 $sum=len_1+len_2=5$，是奇数。故 $sum\\bmod 2=1$。\n\n#### 数据规模与约定\n**本题采用捆绑测试**\n$$\n\\newcommand{\\arraystretch}{1.5}\n\\begin{array}{c|c|c|c}\\hline\\hline\n\\textbf{Subtask} & \\bm{\\sum n\\le} & \\textbf{特殊性质} & \\textbf{分值} \\\\\\hline\n\\textsf{1} & \\le 10 & a_i,b_i\\le 10^9 & 10 \\\\\\hline\n\\textsf{2} & \\le 10^3 & a_i,b_i\\le 10^9 & 20 \\\\\\hline\n\\textsf{3} & \\text{无特殊限制} & a_i,b_i\\le 10^9 & 20 \\\\\\hline\n\\textsf{4} & \\text{无特殊限制} & a_i\\le b_i & 20 \\\\\\hline\n\\textsf{5} & \\text{无特殊限制} & - & 30 \\\\\\hline\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，有 $1\\le T\\le 10^3$，$1\\le n\\le 10^5$，$1\\le a_i,b_i\\le 10^{18}$。\n\n单个测试点内保证 $\\sum n\\le 2\\times 10^5$。\n\n#### 说明\n\n$\\digamma$ 数列拥有如下的递推式：\n\n$$\n\\digamma(x)=\n\\begin{cases}\n1,&x\\le 2\\\\\n-1,&x=3\\\\\n\\digamma(x-1)-\\digamma(x-2)+\\digamma(x-3),&x>3.\n\\end{cases}\n$$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SvR-2」令人为难的区间操作问题", "background": "**Problem Number:** $\\textit{45}$\n\n众所周知，区间操作问题应该求出区间和、最大值等值。但今天小 F 有个不情之请。", "description": "小 F 正在研究[斐波那契数列](https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0)，他惊讶地发现，可以把这种数列 $F$ 的定义式略作修改，得到 $\\digamma$ 数列：\n\n$$\\digamma(x)=\\{1,1,-1,-1,1,1,-1,-1,1,\\ldots\\}$$\n\n注意到 $\\digamma$ 数列具有周期性，最小正周期 $T=4$。\n\n请注意这里 $\\digamma$ 数列与数学上用其表示的[双伽玛函数](https://zh.wikipedia.org/wiki/%E5%8F%8C%E4%BC%BD%E7%8E%9B%E5%87%BD%E6%95%B0)的区别。\n\n小 F 找到一个长度为 $n$ 的数列 $a$，他每次对其进行如下操作：\n\n- 选定两个整数 $l,r$，满足 $1\\le l\\le r\\le n$。\n- 对于每个满足 $l\\le i\\le r$ 的 $i$，将 $a_i$ 加上 $\\digamma(i-l+1)$。\n- 记录下本次操作（即第 $j$ 次操作）的选定区间的长度 $len_j=r-l+1$。\n\n他一共进行了 $m$ 次操作，操作后得到数列记作 $b$，同时记 $sum=\\sum_{i=1}^mlen_i$。\n\n不幸的是，小 F 把 $sum$ 和数列 $len$ 都弄丢了，他只记得 $n$ 和数列 $a,b$。\n\n现在，他想请你根据这些信息，求出 $sum$ 的**奇偶**，**即 $\\textbf{\\textit{sum}}$ 对 $\\textbf2$ 取模后的值**。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n接下来 $3\\cdot T$ 行，描述每组数据。对于每组数据：\n\n- 第一行一个整数 $n$。\n- 第二行 $n$ 个整数，描述数列 $a$。\n- 第三行 $n$ 个整数，描述数列 $b$。\n\n**数据保证数列 $a$ 一定可以经过若干操作变为数列 $b$。**", "outputFormat": "对于每组数据，输出仅一行一个数，即 $sum$ 对 $2$ 取模后的值。", "hint": "#### 样例 1 说明\n\n注意到可能进行的是如下操作：\n\n- 第 $1$ 次操作选定 $l=2,r=3$，则数列变成 $[1,{\\underline{\\color{red}\\textbf{3}}},{\\underline{\\color{red}\\textbf{4}}},4]$。此时 $len_1=2$。\n- 第 $2$ 次操作选定 $l=1,r=3$，则数列变成 $[{\\underline{\\color{red}\\textbf{2}}},{\\underline{\\color{red}\\textbf{4}}},{\\underline{\\color{red}\\textbf{3}}},4]$。此时 $len_2=3$。\n\n则 $sum=len_1+len_2=5$，是奇数。故 $sum\\bmod 2=1$。\n\n#### 数据规模与约定\n**本题采用捆绑测试**\n$$\n\\newcommand{\\arraystretch}{1.5}\n\\begin{array}{c|c|c|c}\\hline\\hline\n\\textbf{Subtask} & \\bm{\\sum n\\le} & \\textbf{特殊性质} & \\textbf{分值} \\\\\\hline\n\\textsf{1} & \\le 10 & a_i,b_i\\le 10^9 & 10 \\\\\\hline\n\\textsf{2} & \\le 10^3 & a_i,b_i\\le 10^9 & 20 \\\\\\hline\n\\textsf{3} & \\text{无特殊限制} & a_i,b_i\\le 10^9 & 20 \\\\\\hline\n\\textsf{4} & \\text{无特殊限制} & a_i\\le b_i & 20 \\\\\\hline\n\\textsf{5} & \\text{无特殊限制} & - & 30 \\\\\\hline\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，有 $1\\le T\\le 10^3$，$1\\le n\\le 10^5$，$1\\le a_i,b_i\\le 10^{18}$。\n\n单个测试点内保证 $\\sum n\\le 2\\times 10^5$。\n\n#### 说明\n\n$\\digamma$ 数列拥有如下的递推式：\n\n$$\n\\digamma(x)=\n\\begin{cases}\n1,&x\\le 2\\\\\n-1,&x=3\\\\\n\\digamma(x-1)-\\digamma(x-2)+\\digamma(x-3),&x>3.\n\\end{cases}\n$$", "locale": "zh-CN"}}}
{"pid": "P9087", "type": "P", "difficulty": 4, "samples": [["2\n4 5 2 2\n8 6 3 2", "0\nSept\n3\n2023yyds"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["洛谷原创", "Special Judge", "构造", "洛谷月赛"], "title": "「SvR-2」音符", "background": "", "description": ">本题中「子串」指：\n>\n>若字符串 $s$ 中有一段**连续的**字符构成字符串 $p$，则 $p$ 是 $s$ 的子串。\n\n我们用一个字符串代替一份乐谱，用字符代替每一个音符。\n\n我们定义「重音」表示乐谱中出现了两个**连续**的相同字符，如 $\\tt eeeee$ 中存在 $4$ 个「重音」。\n\n现在 Sept 准备写一份长度为 $n$ 的乐谱给 Tpes 看，他对乐谱的评价标准如下：\n\n- 乐谱中每出现一个「重音」，他的愤怒值就会增加 $a$。\n- 乐谱中每有一段长度为 $k$ 的**子串**中不存在「重音」，他的愤怒值就会增加 $b$。\n\n现在已知 $n,k,a,b$，请你帮 Sept 构造出一份乐谱，使得 Tpes 的愤怒值 $x$ **最小**。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行两个整数 $n,k,a,b$，意义如题目所述。", "outputFormat": "共 $2 \\cdot T$ 行，对于每组数据都输出两行：\n\n- 第 1 行表示 Tpes 最小的愤怒值 $x$。\n- 第 2 行表示你构造出的乐谱。", "hint": "#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n| $\\bf{Subtask}$ | $\\bm{n\\le}$ | $\\bm{\\sum n\\le}$ | $\\bm{T\\le}$ | $\\bf{Score}$ |\n| :-: | :-: | :-: | :-: | :-: |\n| $\\sf 1$ | $6$ | $10$ | $3$ | $\\tt 10$ |\n| $\\sf 2$ | $10^3$ | $2\\times 10^3$ | 无特殊限制 | $\\tt 30$ |\n| $\\sf 3$ | 无特殊限制 | 无特殊限制 | 无特殊限制 | $\\tt 60$ |\n\n对于 $100\\%$ 的数据，有 $2\\le T\\le 100$，$2\\le n,k\\le 10^5$，$1\\le a,b\\le 10^9$。单组数据内保证 $\\sum n\\le 2\\times 10^5$。\n\n#### 输出注意事项\n\n输出 $x$ 和构造乐谱可以看作是两个子问题，如果你只会完成其中的一个，请在另一个子问题对应的地方用**符合要求的字符或数字**占位。\n\n乐谱中你可以输出任意字符，包括数字、大小写字母等，但**不能出现空格**。\n\n#### Special Judge 返回信息说明\n\n本题采用 Special Judge 判断你的答案是否正确。\n\nchecker.cpp 将会以 $\\texttt{Score=}\\text A,\\texttt{Type=}\\text B$ 的方式返回信息。\n\n$\\tt Score$ 类表示你的得分情况，$\\text A$ 有以下取值：\n\n- $\\text A=1$，表示含义如下：\\\n  $\\text{Accepted.} \\texttt{ Your Ans and SM are both proper.}$\\\n  代表 $T$ 组答案全部符合要求。\n- $\\text A=2$，表示含义如下：\\\n  $\\text{Partially Correct.}\\texttt{ All Ans are right.}$\\\n  表示该测试点中你的回答中 $x$ 全部正确，你能得到该测试点 $20\\%$ 的分数。\n- $\\text A=3$，表示含义如下：\\\n  $\\text{Partially Correct.}\\texttt{ You pass 70\\% tests!}$\\\n  表示该测试点中你的回答正确的组数**不少于**$\\lfloor0.7\\times T\\rfloor$（$x$ 与乐谱均符合要求），你能得到该测试点 $10\\%$ 的分数。\n- $\\text A=4$，表示该测试点你只能拿到 $0$ 分。\n\n$\\tt Type$ 类表示你的得分情况，$\\text B$ 有以下取值：\n\n- $\\text B=0$，表示你的答案全部正确，与 $\\text A=1$ 配对。\n- $\\text B=1$，表示含义如下：\\\n  $\\text{Wrong Answer.}\\texttt{ The length of your SM is not right!}$\\\n  代表你在一组数据中构造的乐谱的长度不为 $n$。\n- $\\text B=2$，表示含义如下：\\\n  $\\text{Wrong Answer.}\\texttt{ Your Ans is not right!}$\\\n  代表你在一组数据中 $x$ 的值错误。\n- $\\text B=3$，表示含义如下：\\\n  $\\text{Wrong Answer.}\\texttt{ Your Ans and SM are not matched!}$\\\n  代表你在一组数据中构造的乐谱使 Tpes 产生的愤怒值不为 $x$。\n\n这里 $\\text{Ans, SM}$ 分别表示 Answer（$x$ 的值）和 Sheet Music（乐谱）。\n\n注意到 $\\tt Type$ 只会反映你在该测试点中**第一次错误**的类型。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SvR-2」音符", "background": "", "description": ">本题中「子串」指：\n>\n>若字符串 $s$ 中有一段**连续的**字符构成字符串 $p$，则 $p$ 是 $s$ 的子串。\n\n我们用一个字符串代替一份乐谱，用字符代替每一个音符。\n\n我们定义「重音」表示乐谱中出现了两个**连续**的相同字符，如 $\\tt eeeee$ 中存在 $4$ 个「重音」。\n\n现在 Sept 准备写一份长度为 $n$ 的乐谱给 Tpes 看，他对乐谱的评价标准如下：\n\n- 乐谱中每出现一个「重音」，他的愤怒值就会增加 $a$。\n- 乐谱中每有一段长度为 $k$ 的**子串**中不存在「重音」，他的愤怒值就会增加 $b$。\n\n现在已知 $n,k,a,b$，请你帮 Sept 构造出一份乐谱，使得 Tpes 的愤怒值 $x$ **最小**。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行两个整数 $n,k,a,b$，意义如题目所述。", "outputFormat": "共 $2 \\cdot T$ 行，对于每组数据都输出两行：\n\n- 第 1 行表示 Tpes 最小的愤怒值 $x$。\n- 第 2 行表示你构造出的乐谱。", "hint": "#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n| $\\bf{Subtask}$ | $\\bm{n\\le}$ | $\\bm{\\sum n\\le}$ | $\\bm{T\\le}$ | $\\bf{Score}$ |\n| :-: | :-: | :-: | :-: | :-: |\n| $\\sf 1$ | $6$ | $10$ | $3$ | $\\tt 10$ |\n| $\\sf 2$ | $10^3$ | $2\\times 10^3$ | 无特殊限制 | $\\tt 30$ |\n| $\\sf 3$ | 无特殊限制 | 无特殊限制 | 无特殊限制 | $\\tt 60$ |\n\n对于 $100\\%$ 的数据，有 $2\\le T\\le 100$，$2\\le n,k\\le 10^5$，$1\\le a,b\\le 10^9$。单组数据内保证 $\\sum n\\le 2\\times 10^5$。\n\n#### 输出注意事项\n\n输出 $x$ 和构造乐谱可以看作是两个子问题，如果你只会完成其中的一个，请在另一个子问题对应的地方用**符合要求的字符或数字**占位。\n\n乐谱中你可以输出任意字符，包括数字、大小写字母等，但**不能出现空格**。\n\n#### Special Judge 返回信息说明\n\n本题采用 Special Judge 判断你的答案是否正确。\n\nchecker.cpp 将会以 $\\texttt{Score=}\\text A,\\texttt{Type=}\\text B$ 的方式返回信息。\n\n$\\tt Score$ 类表示你的得分情况，$\\text A$ 有以下取值：\n\n- $\\text A=1$，表示含义如下：\\\n  $\\text{Accepted.} \\texttt{ Your Ans and SM are both proper.}$\\\n  代表 $T$ 组答案全部符合要求。\n- $\\text A=2$，表示含义如下：\\\n  $\\text{Partially Correct.}\\texttt{ All Ans are right.}$\\\n  表示该测试点中你的回答中 $x$ 全部正确，你能得到该测试点 $20\\%$ 的分数。\n- $\\text A=3$，表示含义如下：\\\n  $\\text{Partially Correct.}\\texttt{ You pass 70\\% tests!}$\\\n  表示该测试点中你的回答正确的组数**不少于**$\\lfloor0.7\\times T\\rfloor$（$x$ 与乐谱均符合要求），你能得到该测试点 $10\\%$ 的分数。\n- $\\text A=4$，表示该测试点你只能拿到 $0$ 分。\n\n$\\tt Type$ 类表示你的得分情况，$\\text B$ 有以下取值：\n\n- $\\text B=0$，表示你的答案全部正确，与 $\\text A=1$ 配对。\n- $\\text B=1$，表示含义如下：\\\n  $\\text{Wrong Answer.}\\texttt{ The length of your SM is not right!}$\\\n  代表你在一组数据中构造的乐谱的长度不为 $n$。\n- $\\text B=2$，表示含义如下：\\\n  $\\text{Wrong Answer.}\\texttt{ Your Ans is not right!}$\\\n  代表你在一组数据中 $x$ 的值错误。\n- $\\text B=3$，表示含义如下：\\\n  $\\text{Wrong Answer.}\\texttt{ Your Ans and SM are not matched!}$\\\n  代表你在一组数据中构造的乐谱使 Tpes 产生的愤怒值不为 $x$。\n\n这里 $\\text{Ans, SM}$ 分别表示 Answer（$x$ 的值）和 Sheet Music（乐谱）。\n\n注意到 $\\tt Type$ 只会反映你在该测试点中**第一次错误**的类型。", "locale": "zh-CN"}}}
{"pid": "P9088", "type": "P", "difficulty": 5, "samples": [["3\n4 1 3 4 7 7 9 10 3\n6 3 6 4 3 4 5 6 6\n6 10 7 1 4 2 6 4 2\n", "31\n23\n19\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2023", "网络流", "洛谷原创", "O2优化", "图论建模", "欧拉回路", "费用流", "洛谷月赛", "Ad-hoc"], "title": "「SvR-2」1+2=3", "background": null, "description": "你有一些木棒，每个木棒左边有一个数，右边有一个数，数只有 $0,1,2$，你要将所有木棒拼起来，使相邻的数和为 $3$ 的对数最大。\n\n例如，$1\\text{ - }2$ 和 $1\\text{ - }0$ 两个木棒，如果按 $1\\text{ - }0,1\\text{ - }2$ 这样拼，相邻的数和为 $3$ 的对数是 $0$；而按 $1\\text{ - }\\textcolor{red}{\\underline{\\textbf 2}},\\textcolor{red}{\\underline{\\textbf 1}}\\text{ - }0$ 这样拼相邻的数和为 $3$ 的对数是 $1$，因为 $2+1=3$。", "inputFormat": "**本题有多组数据。**\n\n输入的第一行一个正整数表示数据组数 $T$。\n\n对于每组数据，一行 $9$ 个非负整数，分别表示 $0\\text{ - }0,0\\text{ - }1,0\\text{ - }2,1\\text{ - }0,1\\text{ - }1,1\\text{ - }2,2\\text{ - }0,2\\text{ - }1,2\\text{ - }2$ 型木棒的个数。", "outputFormat": "$T$ 行，每行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部数据，保证 $1\\le T\\le 10^5$，记 $a_{i,j}$ 表示 $i\\text-j$ 木棒的个数，保证 $0\\le a_{i,j}\\le 10^9$。\n\n**本题自动开启捆绑测试和 O2 优化。**\n\n记 $sum$ 表示一个测试点中所有数据的所有 $a_{i,j}$ 之和。\n\n| Subtask | $T$ | $sum$ | 特殊性质 |分值 |\n| :------: | :------: | :------: | :------: | :------: |\n| $1$ | $1 \\leq T \\leq 10$ | $1\\le sum\\le 10$ |无| $10 \\operatorname{pts}$ |\n| $2$ | $1 \\leq T \\leq 50$ | $1\\le sum\\le 80$ | 无|$20 \\operatorname{pts}$ |\n| $3$ | 无特殊限制 | 无特殊限制 |A| $15\\operatorname{pts}$ |\n| $4$ | 无特殊限制 | 无特殊限制 |B| $20 \\operatorname{pts}$ |\n| $5$ | $1\\le T\\le 1000$ | 无特殊限制 |C| $20 \\operatorname{pts}$ |\n| $6$ | 无特殊限制 | 无特殊限制 |无| $15 \\operatorname{pts}$ |\n\n特殊性质 A：$a_{i,j}$ 在 $[0,10^9]$ 中均匀随机生成。\n\n特殊性质 B：所有 $a_{i,j}>0$。\n\n特殊性质 C：所有 $a_{i,j}\\le 100$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SvR-2」1+2=3", "background": null, "description": "你有一些木棒，每个木棒左边有一个数，右边有一个数，数只有 $0,1,2$，你要将所有木棒拼起来，使相邻的数和为 $3$ 的对数最大。\n\n例如，$1\\text{ - }2$ 和 $1\\text{ - }0$ 两个木棒，如果按 $1\\text{ - }0,1\\text{ - }2$ 这样拼，相邻的数和为 $3$ 的对数是 $0$；而按 $1\\text{ - }\\textcolor{red}{\\underline{\\textbf 2}},\\textcolor{red}{\\underline{\\textbf 1}}\\text{ - }0$ 这样拼相邻的数和为 $3$ 的对数是 $1$，因为 $2+1=3$。", "inputFormat": "**本题有多组数据。**\n\n输入的第一行一个正整数表示数据组数 $T$。\n\n对于每组数据，一行 $9$ 个非负整数，分别表示 $0\\text{ - }0,0\\text{ - }1,0\\text{ - }2,1\\text{ - }0,1\\text{ - }1,1\\text{ - }2,2\\text{ - }0,2\\text{ - }1,2\\text{ - }2$ 型木棒的个数。", "outputFormat": "$T$ 行，每行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部数据，保证 $1\\le T\\le 10^5$，记 $a_{i,j}$ 表示 $i\\text-j$ 木棒的个数，保证 $0\\le a_{i,j}\\le 10^9$。\n\n**本题自动开启捆绑测试和 O2 优化。**\n\n记 $sum$ 表示一个测试点中所有数据的所有 $a_{i,j}$ 之和。\n\n| Subtask | $T$ | $sum$ | 特殊性质 |分值 |\n| :------: | :------: | :------: | :------: | :------: |\n| $1$ | $1 \\leq T \\leq 10$ | $1\\le sum\\le 10$ |无| $10 \\operatorname{pts}$ |\n| $2$ | $1 \\leq T \\leq 50$ | $1\\le sum\\le 80$ | 无|$20 \\operatorname{pts}$ |\n| $3$ | 无特殊限制 | 无特殊限制 |A| $15\\operatorname{pts}$ |\n| $4$ | 无特殊限制 | 无特殊限制 |B| $20 \\operatorname{pts}$ |\n| $5$ | $1\\le T\\le 1000$ | 无特殊限制 |C| $20 \\operatorname{pts}$ |\n| $6$ | 无特殊限制 | 无特殊限制 |无| $15 \\operatorname{pts}$ |\n\n特殊性质 A：$a_{i,j}$ 在 $[0,10^9]$ 中均匀随机生成。\n\n特殊性质 B：所有 $a_{i,j}>0$。\n\n特殊性质 C：所有 $a_{i,j}\\le 100$。", "locale": "zh-CN"}}}
{"pid": "P9089", "type": "P", "difficulty": 5, "samples": [["4\nint\nprintf\nscanf\nntnt", "23"], ["4\nireallywanttobemissjiaransdog\nbutmissjiaransaidthatshelikedcatsandicried\niknowwhyicrywheniamneitheradognoracatbecauseimactuallyamouse\nineverexpectedmissjiarantolikeherselfiunderstandthatallpeopleliketounderstandthecutedogorcatthatyuyuusestomakemoneyandnoonelikesthemousewithwetandwetdiseases", "391"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "二分", "洛谷原创", "后缀自动机 SAM", "O2优化", "哈希 hashing", "AC 自动机", "洛谷月赛"], "title": "「SvR-2」Work", "background": null, "description": "给定 $n$ 个**由小写字母组成**的字符串，定义第 $i$ 个字符串的价值为其有意义的子串的数量（**如果有多个本质相同的子串也统计多次**），第 $i$ 个字符串的一个子串有意义，当且仅当这个子串能被分成若干个串，其中每个串都是这 $n$ 个字符串中任意一个字符串的任意一个后缀。\n\n这里有一个 $n=4$ 的例子：\n```plain\nint\nprintf\nscanf\nntnt\n```\n\n- 对于 `printf` 这个字符串而言，`intf` 是有意义的，因为可以表示成 `int` 和 `f` ，分别是 `int` 和 `scanf` 的后缀，而 `rint` 则不是。\n\n- 对于 `ntnt` 这个字符串而言，`ntnt` 也是有意义的，因为可以表示成 `nt` 和 `nt`，它们都是 `int` 同一个后缀，或者可以表示成 `ntnt`，是 `ntnt` 的一个后缀。\n\n现在，小 Z 想知道这 $n$ 个字符串价值之和。", "inputFormat": "第一行一个整数 $n$。\n\n之后 $n$ 行，每行一个字符串。", "outputFormat": "一行一个整数，表示价值之和。", "hint": "#### 数据规模与约定\n\n**本题开启捆绑测试和 O2 优化。**\n\n令 $s_i$ 表示第 $i$ 个字符串长度。\n| Subtask | 数据范围/特殊性质 | 分值 |\n| :------: | :------: | :------: |\n| $1$ |  $n\\le 3$，$\\sum\\limits \\lvert s_i\\rvert\\le10$| $5 \\operatorname{pts}$ |\n| $2$ | $n=26$，每种字符串均由一种字符组成 | $5 \\operatorname{pts}$ |\n| $3$ |$n=1$ | $15 \\operatorname{pts}$ |\n| $4$ | $\\sum\\limits \\lvert s_i \\rvert \\le 2000$ | $15 \\operatorname{pts}$ |\n| $5$ | $\\sum\\limits \\lvert s_i \\rvert \\le 2\\times10^5$ | $30 \\operatorname{pts}$ |\n| $6$ | $\\sum\\limits \\lvert s_i \\rvert \\le 10^6$ | $30 \\operatorname{pts}$ |\n\n对于 $100\\%$ 的数据，$1\\le n \\le 5\\times10^5$，$n\\le \\sum\\limits \\lvert s_i \\rvert \\le 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SvR-2」Work", "background": null, "description": "给定 $n$ 个**由小写字母组成**的字符串，定义第 $i$ 个字符串的价值为其有意义的子串的数量（**如果有多个本质相同的子串也统计多次**），第 $i$ 个字符串的一个子串有意义，当且仅当这个子串能被分成若干个串，其中每个串都是这 $n$ 个字符串中任意一个字符串的任意一个后缀。\n\n这里有一个 $n=4$ 的例子：\n```plain\nint\nprintf\nscanf\nntnt\n```\n\n- 对于 `printf` 这个字符串而言，`intf` 是有意义的，因为可以表示成 `int` 和 `f` ，分别是 `int` 和 `scanf` 的后缀，而 `rint` 则不是。\n\n- 对于 `ntnt` 这个字符串而言，`ntnt` 也是有意义的，因为可以表示成 `nt` 和 `nt`，它们都是 `int` 同一个后缀，或者可以表示成 `ntnt`，是 `ntnt` 的一个后缀。\n\n现在，小 Z 想知道这 $n$ 个字符串价值之和。", "inputFormat": "第一行一个整数 $n$。\n\n之后 $n$ 行，每行一个字符串。", "outputFormat": "一行一个整数，表示价值之和。", "hint": "#### 数据规模与约定\n\n**本题开启捆绑测试和 O2 优化。**\n\n令 $s_i$ 表示第 $i$ 个字符串长度。\n| Subtask | 数据范围/特殊性质 | 分值 |\n| :------: | :------: | :------: |\n| $1$ |  $n\\le 3$，$\\sum\\limits \\lvert s_i\\rvert\\le10$| $5 \\operatorname{pts}$ |\n| $2$ | $n=26$，每种字符串均由一种字符组成 | $5 \\operatorname{pts}$ |\n| $3$ |$n=1$ | $15 \\operatorname{pts}$ |\n| $4$ | $\\sum\\limits \\lvert s_i \\rvert \\le 2000$ | $15 \\operatorname{pts}$ |\n| $5$ | $\\sum\\limits \\lvert s_i \\rvert \\le 2\\times10^5$ | $30 \\operatorname{pts}$ |\n| $6$ | $\\sum\\limits \\lvert s_i \\rvert \\le 10^6$ | $30 \\operatorname{pts}$ |\n\n对于 $100\\%$ 的数据，$1\\le n \\le 5\\times10^5$，$n\\le \\sum\\limits \\lvert s_i \\rvert \\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P9090", "type": "P", "difficulty": 6, "samples": [["5 3\n2 3\n0 4\n5 0\n0 0 \n0 0\n2 5 \n2 1\n1 1", "5\n24\n6"], ["5 1\n2 3\n0 4\n5 0\n0 0 \n0 0\n64 1", "592424678"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "贪心", "洛谷原创", "O2优化", "矩阵加速", "洛谷月赛"], "title": "「SvR-2」G64", "background": "", "description": "定义对于两棵有根二叉树 $T_1,T_2$，$\\operatorname{merge}(T_1,T_2)$ 的结果是一棵二叉树，满足其根节点的左子树为 $T_1$，右子树为 $T_2$，显然 $\\operatorname{merge}(T_1,T_2)$ 的结果唯一且必然存在。\n\n定义对于一棵有根二叉树 $T$，有函数 $G_x(T)$。其中 $G_1(T)$ 表示沿着 $T$ 的根向右儿子走，直到走到某个不存在右儿子的节点，将其右子树变为 $T$，这棵新树即为 $G_1(T)$ ，而当 $x>1$ 时，$G_x(T)$ 满足如下关系：\n\n$$G_x(T)=G_1(\\operatorname{merge}(G_{x-1}(T),G_{x-1}(T)))$$\n\n给一棵 $n$ 个节点的以 $1$ 为根的有根二叉树，记以 $i$ 为根的子树为 $T_i$，$q$ 次询问，每次询问给定 $x,i$，求 $G_x(T_i)$ 的最大独立集。\n", "inputFormat": "第一行两个整数 $n,q$。\n\n之后 $n$ 行，每行两个整数 $ls_i,rs_i$ 表示其左儿子和右儿子，若为 $0$ 则说明没有对应儿子。\n\n之后 $q$ 行，每行两个整数 $x,i$ ，表示一次询问。", "outputFormat": "$q$ 行，每行一个数，表示这次询问的  $G_x(T_i)$ 的最大独立集大小对 $998244353$ 取模的结果。", "hint": "### 样例解释\n\n对于第一组样例，$G_2(T_5)$ 的结果如下图（忽略编号）：\n![](https://cdn.luogu.com.cn/upload/image_hosting/fcjnzc23.png) \n \n\n对于第二组样例，我有一个绝妙的解释，可惜 $G_{64}$ 太大了，这里写不下。\n\n#### 数据规模与约定\n\n**本题开启捆绑测试和 O2 优化。**\n\n| Subtask | 数据范围/特殊性质 | 分值 |\n| :------: | :------: | :------: |\n| $1$ |  $n,q,x\\le 10$| $10 \\operatorname{pts}$ |\n| $2$ | $x =1$ | $5 \\operatorname{pts}$ |\n| $3$ |$x\\le 3$ | $10 \\operatorname{pts}$ |\n| $4$ | $x\\le 10$ | $15 \\operatorname{pts}$ |\n| $5$ | 保证 $T_i$ 大小为 $1$ | $10 \\operatorname{pts}$ |\n| $6$ | 无特殊限制 | $50 \\operatorname{pts}$ |\n\n\n对于 $100\\%$ 的数据，\n$1\\le x\\le 10^9$，$1\\le n\\le 5\\times 10^5$，$1\\le q\\le 5\\times 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SvR-2」G64", "background": "", "description": "定义对于两棵有根二叉树 $T_1,T_2$，$\\operatorname{merge}(T_1,T_2)$ 的结果是一棵二叉树，满足其根节点的左子树为 $T_1$，右子树为 $T_2$，显然 $\\operatorname{merge}(T_1,T_2)$ 的结果唯一且必然存在。\n\n定义对于一棵有根二叉树 $T$，有函数 $G_x(T)$。其中 $G_1(T)$ 表示沿着 $T$ 的根向右儿子走，直到走到某个不存在右儿子的节点，将其右子树变为 $T$，这棵新树即为 $G_1(T)$ ，而当 $x>1$ 时，$G_x(T)$ 满足如下关系：\n\n$$G_x(T)=G_1(\\operatorname{merge}(G_{x-1}(T),G_{x-1}(T)))$$\n\n给一棵 $n$ 个节点的以 $1$ 为根的有根二叉树，记以 $i$ 为根的子树为 $T_i$，$q$ 次询问，每次询问给定 $x,i$，求 $G_x(T_i)$ 的最大独立集。\n", "inputFormat": "第一行两个整数 $n,q$。\n\n之后 $n$ 行，每行两个整数 $ls_i,rs_i$ 表示其左儿子和右儿子，若为 $0$ 则说明没有对应儿子。\n\n之后 $q$ 行，每行两个整数 $x,i$ ，表示一次询问。", "outputFormat": "$q$ 行，每行一个数，表示这次询问的  $G_x(T_i)$ 的最大独立集大小对 $998244353$ 取模的结果。", "hint": "### 样例解释\n\n对于第一组样例，$G_2(T_5)$ 的结果如下图（忽略编号）：\n![](https://cdn.luogu.com.cn/upload/image_hosting/fcjnzc23.png) \n \n\n对于第二组样例，我有一个绝妙的解释，可惜 $G_{64}$ 太大了，这里写不下。\n\n#### 数据规模与约定\n\n**本题开启捆绑测试和 O2 优化。**\n\n| Subtask | 数据范围/特殊性质 | 分值 |\n| :------: | :------: | :------: |\n| $1$ |  $n,q,x\\le 10$| $10 \\operatorname{pts}$ |\n| $2$ | $x =1$ | $5 \\operatorname{pts}$ |\n| $3$ |$x\\le 3$ | $10 \\operatorname{pts}$ |\n| $4$ | $x\\le 10$ | $15 \\operatorname{pts}$ |\n| $5$ | 保证 $T_i$ 大小为 $1$ | $10 \\operatorname{pts}$ |\n| $6$ | 无特殊限制 | $50 \\operatorname{pts}$ |\n\n\n对于 $100\\%$ 的数据，\n$1\\le x\\le 10^9$，$1\\le n\\le 5\\times 10^5$，$1\\le q\\le 5\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P9091", "type": "P", "difficulty": 7, "samples": [["4 2", "26"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["递推", "2023", "数论", "洛谷原创", "O2优化", "素数判断,质数,筛法", "排列组合", "容斥原理", "洛谷月赛", "根号分治"], "title": "「SvR-2」Let's Meet at a Higher Place", "background": "$$「有朝一日，让我们相逢在更高处！」$$", "description": "构造一个长为 $m$ 的整数序列 $a$，使 $\\forall 1 \\leq i \\leq m$，$a_i \\in [1, n]$。\n\n求出其前缀 $\\gcd$，记为整数序列 $b$。\n\n$f(n, m, k)$ 的值为可以通过如上方式构造出的 $b$ 序列中**相邻项相等的情况出现次数 $\\leq k$** 的**不同**的 $b$ 序列的个数。\n\n给定正整数 $n, m$，小 L 请你帮他求出 $\\displaystyle\\sum_{i = 1}^n \\sum_{j = 1}^m \\sum_{k = 0}^{j - 1} f(\\lfloor \\frac{n}{i} \\rfloor, j, k)$ 的值。\n\n由于结果可能很大，所以你只需要求出结果对 $2^{32}$ 取模的值。", "inputFormat": "一行，两个整数 $n, m$。", "outputFormat": "一行，一个整数，表示所求的值。", "hint": "| $\\bf{Subtask}$ | $n$ | $m$ | 分值 |\n| :------: | :------: | :------: | :------: |\n| $1$ | $1 \\leq n \\leq 10^4$ | 无特殊限制 | $10 \\operatorname{pts}$ |\n| $2$ | $1 \\leq n \\leq 10^6$ | 同上 | $20 \\operatorname{pts}$ |\n| $3$ | $1 \\leq n \\leq 10^9$ | 同上 | $20 \\operatorname{pts}$ |\n| $4$ | 无特殊限制 | $1 \\leq m \\leq 25$ | $20 \\operatorname{pts}$ |\n| $5$ | 同上 | 无特殊限制 | $30 \\operatorname{pts}$ |\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^{10}$，$1 \\leq m \\leq 34$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SvR-2」Let's Meet at a Higher Place", "background": "$$「有朝一日，让我们相逢在更高处！」$$", "description": "构造一个长为 $m$ 的整数序列 $a$，使 $\\forall 1 \\leq i \\leq m$，$a_i \\in [1, n]$。\n\n求出其前缀 $\\gcd$，记为整数序列 $b$。\n\n$f(n, m, k)$ 的值为可以通过如上方式构造出的 $b$ 序列中**相邻项相等的情况出现次数 $\\leq k$** 的**不同**的 $b$ 序列的个数。\n\n给定正整数 $n, m$，小 L 请你帮他求出 $\\displaystyle\\sum_{i = 1}^n \\sum_{j = 1}^m \\sum_{k = 0}^{j - 1} f(\\lfloor \\frac{n}{i} \\rfloor, j, k)$ 的值。\n\n由于结果可能很大，所以你只需要求出结果对 $2^{32}$ 取模的值。", "inputFormat": "一行，两个整数 $n, m$。", "outputFormat": "一行，一个整数，表示所求的值。", "hint": "| $\\bf{Subtask}$ | $n$ | $m$ | 分值 |\n| :------: | :------: | :------: | :------: |\n| $1$ | $1 \\leq n \\leq 10^4$ | 无特殊限制 | $10 \\operatorname{pts}$ |\n| $2$ | $1 \\leq n \\leq 10^6$ | 同上 | $20 \\operatorname{pts}$ |\n| $3$ | $1 \\leq n \\leq 10^9$ | 同上 | $20 \\operatorname{pts}$ |\n| $4$ | 无特殊限制 | $1 \\leq m \\leq 25$ | $20 \\operatorname{pts}$ |\n| $5$ | 同上 | 无特殊限制 | $30 \\operatorname{pts}$ |\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^{10}$，$1 \\leq m \\leq 34$。", "locale": "zh-CN"}}}
{"pid": "P9092", "type": "P", "difficulty": 5, "samples": [["1 100", "23"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "数位 DP", "PA（波兰）"], "title": "[PA 2020] Liczba Potyczkowa", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda próbna [Liczba Potyczkowa](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/lic/)。**\n\nBajtek 在数学史课上了到解了一位俄罗斯数学家弗拉基米尔·波季奇科夫（Vladimir Potyczkow）。这位科学家以对数字的研究而闻名，为了纪念他，今天我们将这些数称为 **Potyczkow 数**：是一个正整数，并且可以用其十进制表示中出现过的每个数字整除。特别地，这意味着十进制表示中不能有零。例如 $48$、$1$ 和 $112$ 是 Potyczkow 数，而 $23$、$10$ 和 $121$ 不是。Bajtek 想知道在 $[l, r]$ 范围内有多少这样的数，请帮助他数一数！", "inputFormat": "一行输入两个正整数 $l,r$。\n", "outputFormat": "输出一行一个整数，表示在 $[l, r]$ 范围内 Potyczkow 数的数量。", "hint": "#### 样例 1 解释\n\n不超过 $100$ 的 Potyczkow 数有 $1, 2, 3, 4, 5, 6, 7, 8, 9,11,12, 15, 22, 24, 33, 36, 44, 48, 55, 66, 77, 88$ 和 $99$。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于部分子任务，满足 $r-l\\le 10^6$。\n\n对于 $100\\%$ 的数据，保证 $1\\le l\\le r\\le 10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Liczba Potyczkowa", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda próbna [Liczba Potyczkowa](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/lic/)。**\n\nBajtek 在数学史课上了到解了一位俄罗斯数学家弗拉基米尔·波季奇科夫（Vladimir Potyczkow）。这位科学家以对数字的研究而闻名，为了纪念他，今天我们将这些数称为 **Potyczkow 数**：是一个正整数，并且可以用其十进制表示中出现过的每个数字整除。特别地，这意味着十进制表示中不能有零。例如 $48$、$1$ 和 $112$ 是 Potyczkow 数，而 $23$、$10$ 和 $121$ 不是。Bajtek 想知道在 $[l, r]$ 范围内有多少这样的数，请帮助他数一数！", "inputFormat": "一行输入两个正整数 $l,r$。\n", "outputFormat": "输出一行一个整数，表示在 $[l, r]$ 范围内 Potyczkow 数的数量。", "hint": "#### 样例 1 解释\n\n不超过 $100$ 的 Potyczkow 数有 $1, 2, 3, 4, 5, 6, 7, 8, 9,11,12, 15, 22, 24, 33, 36, 44, 48, 55, 66, 77, 88$ 和 $99$。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于部分子任务，满足 $r-l\\le 10^6$。\n\n对于 $100\\%$ 的数据，保证 $1\\le l\\le r\\le 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P9093", "type": "P", "difficulty": 3, "samples": [["4\n3 4 5 -1\n", "TAK\n9\n2 2 -7 0 3 -7 3 -1 3"], ["10\n3 1 4 1 5 9 2 6 5 3", "NIE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "Special Judge", "PA（波兰）"], "title": "[PA 2020] Punkty rankingowe", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 1 [Punkty rankingowe](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/ran/)。**\n\nBytie 决定认真准备今年的 PA。为了训练，他创建了一个 BitForces 账号，BitForces 是一个定期举办编程竞赛的平台。\n\nBytie 知道这个平台使用一种积分系统（也称为 rating），这个系统会让他知道自己的进步，也可以将自己的成绩与其他选手比较。选手的 rating 是一个整数（可能为负数）。在账号创建后，Bytie 的 rating 是 $0$，参加每场比赛后，他的 rating 都会加或减某一个整数。此外，在每场比赛后的 rating 变化历史是可以在平台上看到的。兴奋的 Bytie 开始分析这些数据。他在纸上写下了 $n$ 个连续的数字：\n\n- 在一场比赛之后的最大 rating 上升；\n- 在连续两场比赛之后的 rating 上升之和的最大值；\n- 在连续三场比赛之后的 rating 上升之和的最大值；\n- 以此类推，直到他写到在连续 $n$ 场比赛之后的 rating 上升之和的最大值；\n\n几天后 Bytie 想要回想起 rating 变化的序列。然而，此时 BitForces 正出现技术问题。请帮助 Bytie 还原一个合法的 rating 变化序列，使其长度至少为 $n$ 并且符合写在纸上的数据。", "inputFormat": "输入第一行包含一个整数 $n$，表示写在纸上的数字个数。\n\n第二行包含 $n$ 个整数 $a_1,a_2,\\cdots,a_n$。对于每个 $1\\le j\\le n$，连续 $j$ 场比赛的 rating 最大增幅恰好为 $a_j$。", "outputFormat": "如果存在一个 rating 变化序列满足所有题目描述中的条件，输出一行 `TAK`。之后输出一行一个整数 $k$。第三行输出找到的 rating 变化序列 $b_1,b_2,\\ldots,b_k$。如果有多种答案，输出任意一种均可。\n\n如果不存在这样的变化序列，输出一行 `NIE` 即可。\n\n可以证明对于输入如果存在一个 rating 变化序列，那么一定存在一个满足以上限制的序列。", "hint": "#### 样例 1 解释\n\n以下是一、二、三、四次连续比赛中名次增加最多的区间。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uvrbz3bh.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 300$，$-10^6\\le a_i\\le 10^6$，$n\\le k\\le 10^5$，$-10^{13}\\le b_k\\le 10^{13}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Punkty rankingowe", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 1 [Punkty rankingowe](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/ran/)。**\n\nBytie 决定认真准备今年的 PA。为了训练，他创建了一个 BitForces 账号，BitForces 是一个定期举办编程竞赛的平台。\n\nBytie 知道这个平台使用一种积分系统（也称为 rating），这个系统会让他知道自己的进步，也可以将自己的成绩与其他选手比较。选手的 rating 是一个整数（可能为负数）。在账号创建后，Bytie 的 rating 是 $0$，参加每场比赛后，他的 rating 都会加或减某一个整数。此外，在每场比赛后的 rating 变化历史是可以在平台上看到的。兴奋的 Bytie 开始分析这些数据。他在纸上写下了 $n$ 个连续的数字：\n\n- 在一场比赛之后的最大 rating 上升；\n- 在连续两场比赛之后的 rating 上升之和的最大值；\n- 在连续三场比赛之后的 rating 上升之和的最大值；\n- 以此类推，直到他写到在连续 $n$ 场比赛之后的 rating 上升之和的最大值；\n\n几天后 Bytie 想要回想起 rating 变化的序列。然而，此时 BitForces 正出现技术问题。请帮助 Bytie 还原一个合法的 rating 变化序列，使其长度至少为 $n$ 并且符合写在纸上的数据。", "inputFormat": "输入第一行包含一个整数 $n$，表示写在纸上的数字个数。\n\n第二行包含 $n$ 个整数 $a_1,a_2,\\cdots,a_n$。对于每个 $1\\le j\\le n$，连续 $j$ 场比赛的 rating 最大增幅恰好为 $a_j$。", "outputFormat": "如果存在一个 rating 变化序列满足所有题目描述中的条件，输出一行 `TAK`。之后输出一行一个整数 $k$。第三行输出找到的 rating 变化序列 $b_1,b_2,\\ldots,b_k$。如果有多种答案，输出任意一种均可。\n\n如果不存在这样的变化序列，输出一行 `NIE` 即可。\n\n可以证明对于输入如果存在一个 rating 变化序列，那么一定存在一个满足以上限制的序列。", "hint": "#### 样例 1 解释\n\n以下是一、二、三、四次连续比赛中名次增加最多的区间。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uvrbz3bh.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 300$，$-10^6\\le a_i\\le 10^6$，$n\\le k\\le 10^5$，$-10^{13}\\le b_k\\le 10^{13}$。", "locale": "zh-CN"}}}
{"pid": "P9094", "type": "P", "difficulty": 2, "samples": [["9 5\n2 8 1\n4 5 2\n6 7 3\n5 6 2\n1 2 2", "3"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "前缀和", "差分", "PA（波兰）"], "title": "[PA 2020] Mieszanie kolorów", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 1 [Mieszanie kolorów](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/kol/)**\n\nByteasar 正准备给栅栏涂漆。他已经准备了 $n$ 罐白色油漆，他把这些油漆排列成一排，从 $1$ 到 $n$ 编号。他想用这些油漆，但他不想把栅栏涂成白色。他委托了调色专家，调色专家有三种颜料：黄色、蓝色和红色。专家进行了 $m$ 次操作，其中第 $i$ 次操作是向编号在 $l_i$ 到 $r_i$ 之间（包括两端）的所有罐子中加入某种颜料。\n\n油漆的最终颜色取决于被添加到其中的颜料。添加的颜料按照下表和图示进行混合。\n\n|        颜料        | 颜色 |\n| :----------------: | :--: |\n|         无         | 白色 |\n|        黄色        | 黄色 |\n|        蓝色        | 蓝色 |\n|        红色        | 红色 |\n|    黄色 + 蓝色     | 绿色 |\n|    黄色 + 红色     | 橙色 |\n|    蓝色 + 红色     | 紫色 |\n| 黄色 + 蓝色 + 红色 | 棕色 |\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zow92g6w.png)\n\nByteasar 想要给栅栏涂成一种颜色。思来想去，他选择了绿色，因为绿色代表了你常会在算法竞赛中看到的 Accepted。他想知道现在有多少罐油漆是绿色的，请帮他数数。", "inputFormat": "第一行两个整数 $n,m$，分别表示油漆的罐数和专家进行的操作数。\n\n接下来 $m$ 行，每行三个整数 $l_i,r_i,k_i$，表示在第 $i$ 次操作中向编号在 $l_i$ 到 $r_i$ 之间（包括两端）的罐子中加入颜料。加入的颜料是黄色（$k_i=1$），蓝色（$k_i=2$）或红色（$k_i=3$）中的一种。", "outputFormat": "输出一行一个整数，表示在所有操作之后绿色油漆的罐数。", "hint": "#### 样例 1 解释\n\n操作结束后，这些油漆分别是蓝色、绿色、黄色、绿色、绿色、棕色、橙色、黄色和白色的。因此，只有三罐油漆是绿色。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n,m\\le 10^6$，$1\\le l_i\\le r_i\\le n$，$1\\le k_i\\le 3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Mieszanie kolorów", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 1 [Mieszanie kolorów](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/kol/)**\n\nByteasar 正准备给栅栏涂漆。他已经准备了 $n$ 罐白色油漆，他把这些油漆排列成一排，从 $1$ 到 $n$ 编号。他想用这些油漆，但他不想把栅栏涂成白色。他委托了调色专家，调色专家有三种颜料：黄色、蓝色和红色。专家进行了 $m$ 次操作，其中第 $i$ 次操作是向编号在 $l_i$ 到 $r_i$ 之间（包括两端）的所有罐子中加入某种颜料。\n\n油漆的最终颜色取决于被添加到其中的颜料。添加的颜料按照下表和图示进行混合。\n\n|        颜料        | 颜色 |\n| :----------------: | :--: |\n|         无         | 白色 |\n|        黄色        | 黄色 |\n|        蓝色        | 蓝色 |\n|        红色        | 红色 |\n|    黄色 + 蓝色     | 绿色 |\n|    黄色 + 红色     | 橙色 |\n|    蓝色 + 红色     | 紫色 |\n| 黄色 + 蓝色 + 红色 | 棕色 |\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zow92g6w.png)\n\nByteasar 想要给栅栏涂成一种颜色。思来想去，他选择了绿色，因为绿色代表了你常会在算法竞赛中看到的 Accepted。他想知道现在有多少罐油漆是绿色的，请帮他数数。", "inputFormat": "第一行两个整数 $n,m$，分别表示油漆的罐数和专家进行的操作数。\n\n接下来 $m$ 行，每行三个整数 $l_i,r_i,k_i$，表示在第 $i$ 次操作中向编号在 $l_i$ 到 $r_i$ 之间（包括两端）的罐子中加入颜料。加入的颜料是黄色（$k_i=1$），蓝色（$k_i=2$）或红色（$k_i=3$）中的一种。", "outputFormat": "输出一行一个整数，表示在所有操作之后绿色油漆的罐数。", "hint": "#### 样例 1 解释\n\n操作结束后，这些油漆分别是蓝色、绿色、黄色、绿色、绿色、棕色、橙色、黄色和白色的。因此，只有三罐油漆是绿色。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n,m\\le 10^6$，$1\\le l_i\\le r_i\\le n$，$1\\le k_i\\le 3$。", "locale": "zh-CN"}}}
{"pid": "P9095", "type": "P", "difficulty": 1, "samples": [["19\n3B 4B 5B 4C 5C 3C 1A 5A 5C 3A 5A 2C 1B 2A 5B 5C 2B 1C 4A", "TAK"], ["20\n2B 4B 4C 5A 5C 5C 4A 1B 3A 4A 2A 3B 1B 1C 1A 5A 2C 1B 5B 3C", "NIE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "PA（波兰）"], "title": "[PA 2020] Wybór zadań", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 1 [Wybór zadań](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/wyb/)**\n\n对 Matthew 来说，准备 PA 的线上比赛是一个相当大的挑战。在比赛期间，参赛者参加五轮比赛，编号从 $1$ 到 $5$。在每轮比赛中，参赛者需解决三个组别的任务，称为 A、B 和 C。在前四轮比赛中，每一组别都会有一道题，在最后的第五轮比赛中，每一组别都会有两道题。因此，必须一共造 $18$ 道题，并分配给 $15$ 个不同的位置，其中三个位置（5A、5B 和 5C）必须各分配两道题。我们这里所说的位置是指轮次和组别的组合。\n\nMatthew 知道不能只是随便出 $18$ 道题。题目的难度应该适合他们出现的轮次和组别。他在一整年中整理了 $n$ 道题的想法。对于这些想法，他都知道这道题会适合哪个位置（只会适合这一个位置，其他位置都不适合）。\n\nMatthew 想知道是否可以从他的想法中选出 $18$ 道题并正确地分配它们的位置。给定他的笔记记录，请帮他找出一种选择方案。", "inputFormat": "第一行包含一个整数 $n$，表示 Matthew 的想法总数。\n\n第二行有 $n$ 个字符串，表示 Matthew 的每个想法适合的题目位置。每个字符串由恰好两个字符组成，第一个字符是一个在集合 $\\{1,2,3,4,5\\}$ 的数字，第二个字符是一个在集合 $\\{\\texttt A,\\texttt B,\\texttt C\\}$ 的字母。", "outputFormat": "如果可以从 Matthew 的想法中组出一套 PA 题目，则输出 `TAK`，否则输出 `NIE`。", "hint": "#### 样例 1 解释\n\n在第一个样例中，Matthew 有三个符合 5C 位置的题目想法。删掉其中任何一个后，其余的想法就组成了一套合适的 PA 题目。\n\n------------\n\n#### 样例 2 解释\n\n在第二个例子测试中，Matthew 只有一道题与 5B 位置相匹配，所以他组不出一套 PA。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 100$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Wybór zadań", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 1 [Wybór zadań](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/wyb/)**\n\n对 Matthew 来说，准备 PA 的线上比赛是一个相当大的挑战。在比赛期间，参赛者参加五轮比赛，编号从 $1$ 到 $5$。在每轮比赛中，参赛者需解决三个组别的任务，称为 A、B 和 C。在前四轮比赛中，每一组别都会有一道题，在最后的第五轮比赛中，每一组别都会有两道题。因此，必须一共造 $18$ 道题，并分配给 $15$ 个不同的位置，其中三个位置（5A、5B 和 5C）必须各分配两道题。我们这里所说的位置是指轮次和组别的组合。\n\nMatthew 知道不能只是随便出 $18$ 道题。题目的难度应该适合他们出现的轮次和组别。他在一整年中整理了 $n$ 道题的想法。对于这些想法，他都知道这道题会适合哪个位置（只会适合这一个位置，其他位置都不适合）。\n\nMatthew 想知道是否可以从他的想法中选出 $18$ 道题并正确地分配它们的位置。给定他的笔记记录，请帮他找出一种选择方案。", "inputFormat": "第一行包含一个整数 $n$，表示 Matthew 的想法总数。\n\n第二行有 $n$ 个字符串，表示 Matthew 的每个想法适合的题目位置。每个字符串由恰好两个字符组成，第一个字符是一个在集合 $\\{1,2,3,4,5\\}$ 的数字，第二个字符是一个在集合 $\\{\\texttt A,\\texttt B,\\texttt C\\}$ 的字母。", "outputFormat": "如果可以从 Matthew 的想法中组出一套 PA 题目，则输出 `TAK`，否则输出 `NIE`。", "hint": "#### 样例 1 解释\n\n在第一个样例中，Matthew 有三个符合 5C 位置的题目想法。删掉其中任何一个后，其余的想法就组成了一套合适的 PA 题目。\n\n------------\n\n#### 样例 2 解释\n\n在第二个例子测试中，Matthew 只有一道题与 5B 位置相匹配，所以他组不出一套 PA。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 100$。", "locale": "zh-CN"}}}
{"pid": "P9096", "type": "P", "difficulty": 6, "samples": [["2\n7\n9 1 4 2 6 4 7\n1 7\n6 4\n2 3\n5 7\n3 4\n5 3\n5\n4 8 2 3 1\n4 3\n3 1\n4 2\n5 1", "1089 545 371 287 227 211 203\n324 164 114 102 94"]], "limits": {"time": [3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "PA（波兰）"], "title": "[PA 2020] Sen o podboju", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 2 [Sen o podboju](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/sen/)**\n\n国王 Byteur，Byteotia 的统治者，目前正梦想着征服 Bitotia。就像在现实世界中一样，在他的梦中他还远远没有打败敌人。因此，他想知道他能做些什么来削弱敌国的实力……\n\n在他的梦中，Bitotia 由 $n$ 个城市（编号从 $1$ 到 $n$）组成，由 $n-1$ 条双向道路连接，可以只用这些道路从任意一个城市到达任意其他城市。换句话说，Bitotia 的地图形成了一棵树。然而，Byteur 并不记得 Bitotia 的确切道路网络……所以他的脑内生成了一个**随机**的道路网络。\n\n国王得出的结论是，强行将 Bitotia 分割成 $k$ 个小国是个好主意。Byteur 所说的划分，是指秘密地破坏正好是 $k - 1$ 条道路，这将迫使 Bitotia 分解成 $k$ 个小国，这些小国是去除选定的边后形成的连通子图。\n\n然而，对于国王来说，摧毁任何 $k-1$ 条道路都是不够的。每个 Bitotia 的城市都有一个**军事系数** $a_i$，也是由 Byteur 脑内想出来的。Byteur 知道，一个小国的军事力量越强，对 Byteotia 的威胁就越大。更准确地说：如果在一个小国，其城市的军事系数之和等于 $S$，那么来自这个小国的威胁就等于 $S^2$。对 Byteotia 的总威胁等于这 $k$ 个小国所产生的威胁之和。\n\n现在 Byteur 求助于你——他的梦想（指的是字面意思！）程序员。请帮助他，计算出 Bitotia 分裂成各州后可能产生的最小总威胁。由于 Byteur 还没有决定参数 $k$ 的值，请计算 $k$ 取从 $1$ 到 $n$（包含两端）所有值的结果。", "inputFormat": "第一行包含一个整数 $t$，表示测试点总数 ~~Byteur 做的梦的个数~~。接下来描述每一组测试点，测试点的输入格式都相同。\n\n每个测试点第一行包含一个整数 $n$。\n\n第二行包含一个长度为 $n$ 的整数序列 $a_1,a_2,\\cdots ,a_n$。\n\n接下来 $n-1$ 行是 Bitotia 的路网描述，每行两个整数 $b_i,c_i$，表示城市 $b_i,c_i$ 被一条路相连。保证输入的图是一棵树。\n\nByteur 按如下方法生成数据。首先手动选取一个整数 $t$，一个整数区间 $[n_{\\min},n_{\\max}]$ 和 $a_{\\max}$ 的值。接下来按如下步骤独立生成每个测试点：\n\n- 城市个数 $n$ 的值从 $[n_{\\min},n_{\\max}]$ 区间内均匀随机选取。\n- 每个 $a_i$ 的值从 $[1,a_{\\max}]$ 区间内独立均匀随机选取。\n- 生成一个自然数序列 $(p_1,p_2,\\cdots ,p_{n-2})$。序列中的每一个元素都是从 $[1,n]$ 区间中独立均匀随机选取的。Byteur 将其作为路网的 [Prüfer 序列](https://en.wikipedia.org/wiki/Pr%C3%BCfer_sequence)，也就是测试点中给出的树的 Prüfer 序列是 $(p_1,p_2,\\cdots,p_{n-2})$。", "outputFormat": "输出 $t$ 行，描述每个测试点的答案。每行包含 $n$ 个整数（其中 $n$ 是输入中的城市数量）；第 $k$ 个整数表示 Bitotia 在被划分为 $k$ 个小国后所能造成的最小威胁。", "hint": "#### 样例 1 解释\n\n以上测试数据使用随机数种子为 $8\\ 122\\ 020$，$t=2,n_{\\min}=5,n_{\\max}=7,a_{\\max}=10$ 的参数生成。\n\n对于第一个测试案例，输出的第一个数字是 $(9+1+4+2+6+4+7)^2=1089$，代表未被分割的 Bitotia 所带来的总威胁。输出的第二个数字对应的是如果连接 $5$ 号和 $7$ 号城市的道路被摧毁的总威胁；在这种情况下，威胁将是 $(9+7)^2+(1+4+2+6+4)^2=545$。\n\n------------\n\n#### 数据生成\n\n本题的样例生成器在附件中给出。生成器将以下内容作为输入接受：生成器种子和数字 $t,n_{\\min},n_{\\max},a_{\\max}$。本题的所有测试数据都将用与之相当的生成器生成（即用不同的伪随机数库，与编译器的实现无关）。\n\n为了确保测试的随机性，每个测试点的 $t,n_{\\min},n_{\\max},a_{\\max}$ 的值都是手动选择的，生成器的种子是随机选择的。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le t\\le 10$，$2\\le n\\le 300$，$1\\le a_i\\le 10^6$，$1\\le b_i,c_i\\le n$，$2\\le n_{\\min}\\le n_{\\max}\\le 300$，$1\\le a_{\\max}\\le 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Sen o podboju", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 2 [Sen o podboju](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/sen/)**\n\n国王 Byteur，Byteotia 的统治者，目前正梦想着征服 Bitotia。就像在现实世界中一样，在他的梦中他还远远没有打败敌人。因此，他想知道他能做些什么来削弱敌国的实力……\n\n在他的梦中，Bitotia 由 $n$ 个城市（编号从 $1$ 到 $n$）组成，由 $n-1$ 条双向道路连接，可以只用这些道路从任意一个城市到达任意其他城市。换句话说，Bitotia 的地图形成了一棵树。然而，Byteur 并不记得 Bitotia 的确切道路网络……所以他的脑内生成了一个**随机**的道路网络。\n\n国王得出的结论是，强行将 Bitotia 分割成 $k$ 个小国是个好主意。Byteur 所说的划分，是指秘密地破坏正好是 $k - 1$ 条道路，这将迫使 Bitotia 分解成 $k$ 个小国，这些小国是去除选定的边后形成的连通子图。\n\n然而，对于国王来说，摧毁任何 $k-1$ 条道路都是不够的。每个 Bitotia 的城市都有一个**军事系数** $a_i$，也是由 Byteur 脑内想出来的。Byteur 知道，一个小国的军事力量越强，对 Byteotia 的威胁就越大。更准确地说：如果在一个小国，其城市的军事系数之和等于 $S$，那么来自这个小国的威胁就等于 $S^2$。对 Byteotia 的总威胁等于这 $k$ 个小国所产生的威胁之和。\n\n现在 Byteur 求助于你——他的梦想（指的是字面意思！）程序员。请帮助他，计算出 Bitotia 分裂成各州后可能产生的最小总威胁。由于 Byteur 还没有决定参数 $k$ 的值，请计算 $k$ 取从 $1$ 到 $n$（包含两端）所有值的结果。", "inputFormat": "第一行包含一个整数 $t$，表示测试点总数 ~~Byteur 做的梦的个数~~。接下来描述每一组测试点，测试点的输入格式都相同。\n\n每个测试点第一行包含一个整数 $n$。\n\n第二行包含一个长度为 $n$ 的整数序列 $a_1,a_2,\\cdots ,a_n$。\n\n接下来 $n-1$ 行是 Bitotia 的路网描述，每行两个整数 $b_i,c_i$，表示城市 $b_i,c_i$ 被一条路相连。保证输入的图是一棵树。\n\nByteur 按如下方法生成数据。首先手动选取一个整数 $t$，一个整数区间 $[n_{\\min},n_{\\max}]$ 和 $a_{\\max}$ 的值。接下来按如下步骤独立生成每个测试点：\n\n- 城市个数 $n$ 的值从 $[n_{\\min},n_{\\max}]$ 区间内均匀随机选取。\n- 每个 $a_i$ 的值从 $[1,a_{\\max}]$ 区间内独立均匀随机选取。\n- 生成一个自然数序列 $(p_1,p_2,\\cdots ,p_{n-2})$。序列中的每一个元素都是从 $[1,n]$ 区间中独立均匀随机选取的。Byteur 将其作为路网的 [Prüfer 序列](https://en.wikipedia.org/wiki/Pr%C3%BCfer_sequence)，也就是测试点中给出的树的 Prüfer 序列是 $(p_1,p_2,\\cdots,p_{n-2})$。", "outputFormat": "输出 $t$ 行，描述每个测试点的答案。每行包含 $n$ 个整数（其中 $n$ 是输入中的城市数量）；第 $k$ 个整数表示 Bitotia 在被划分为 $k$ 个小国后所能造成的最小威胁。", "hint": "#### 样例 1 解释\n\n以上测试数据使用随机数种子为 $8\\ 122\\ 020$，$t=2,n_{\\min}=5,n_{\\max}=7,a_{\\max}=10$ 的参数生成。\n\n对于第一个测试案例，输出的第一个数字是 $(9+1+4+2+6+4+7)^2=1089$，代表未被分割的 Bitotia 所带来的总威胁。输出的第二个数字对应的是如果连接 $5$ 号和 $7$ 号城市的道路被摧毁的总威胁；在这种情况下，威胁将是 $(9+7)^2+(1+4+2+6+4)^2=545$。\n\n------------\n\n#### 数据生成\n\n本题的样例生成器在附件中给出。生成器将以下内容作为输入接受：生成器种子和数字 $t,n_{\\min},n_{\\max},a_{\\max}$。本题的所有测试数据都将用与之相当的生成器生成（即用不同的伪随机数库，与编译器的实现无关）。\n\n为了确保测试的随机性，每个测试点的 $t,n_{\\min},n_{\\max},a_{\\max}$ 的值都是手动选择的，生成器的种子是随机选择的。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le t\\le 10$，$2\\le n\\le 300$，$1\\le a_i\\le 10^6$，$1\\le b_i,c_i\\le n$，$2\\le n_{\\min}\\le n_{\\max}\\le 300$，$1\\le a_{\\max}\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P9097", "type": "P", "difficulty": 5, "samples": [["17\n2 -5 0 2 0 0 0 4 0 0 -1 4 0 0 0 0 -3", "12"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2020", "线段树", "树状数组", "PA（波兰）"], "title": "[PA 2020] Elektrownie i fabryki", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 2 [Elektrownie i fabryki](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/ele/)**\n\n为了应对不断上升的失业率，Byteotia 政府决定创造新的就业机会。为此将建设现代化的工厂，还要建设为工厂供电的新发电厂。\n\n一条很长的高速公路穿过 Byteotia，沿途有 $n$ 个城市。为了简单起见，我们从 $1$ 到 $n$ 对城市进行编号。每两个相邻城市之间都相距一公里。\n\n目前已经决定一些城市建设工厂，另一些城市建设发电厂。对于第 $i$ 个城市有一个值 $a_i$。如果它是正数，则在第 $i$ 个城市将建造一个发电容量为 $a_i$ 兆瓦的发电厂，如果它是负数，则在该城市将建造一个消耗电能 $a_i$ 兆瓦的工厂。如果 $a_i=0$，则说明该城市没有建设计划。\n\n你的任务是设计一个电网，将电力从发电站输送到工厂。对于每一对相邻的城镇，你必须决定是否在它们之间建立一条输电线。如果这个城市被输电线直接或间接连接到某个有发电站的城市，电力就可以从发电站流向这个城市的工厂。如果每个工厂的电力需求都得到满足，那么电网的设计就是正确的。电网的成本与电网输电线的总长度（以公里计）成正比。\n\n写一个程序计算设计一个正确的电网最小成本是多少。", "inputFormat": "第一行一个整数 $n$，表示 Byteotia 的城市个数。\n\n第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$，表示每个城市电力的生产和消耗。", "outputFormat": "输出设计一个正确的电网的最小成本。如果不存在一个正确的电网，输出 $-1$。", "hint": "#### 样例 1 解释\n\n下面是一个包含 $n=17$ 个城市的样例，其中将建造三个工厂（白圈）和四个发电厂（黑圈）。$12$ 公里的正确电网用灰色部分标记。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2wee5eoz.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于一些子任务，满足 $n\\le 5\\times 10^3$。\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 5\\times 10^5$，$-10^9\\le a_i\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Elektrownie i fabryki", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 2 [Elektrownie i fabryki](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/ele/)**\n\n为了应对不断上升的失业率，Byteotia 政府决定创造新的就业机会。为此将建设现代化的工厂，还要建设为工厂供电的新发电厂。\n\n一条很长的高速公路穿过 Byteotia，沿途有 $n$ 个城市。为了简单起见，我们从 $1$ 到 $n$ 对城市进行编号。每两个相邻城市之间都相距一公里。\n\n目前已经决定一些城市建设工厂，另一些城市建设发电厂。对于第 $i$ 个城市有一个值 $a_i$。如果它是正数，则在第 $i$ 个城市将建造一个发电容量为 $a_i$ 兆瓦的发电厂，如果它是负数，则在该城市将建造一个消耗电能 $a_i$ 兆瓦的工厂。如果 $a_i=0$，则说明该城市没有建设计划。\n\n你的任务是设计一个电网，将电力从发电站输送到工厂。对于每一对相邻的城镇，你必须决定是否在它们之间建立一条输电线。如果这个城市被输电线直接或间接连接到某个有发电站的城市，电力就可以从发电站流向这个城市的工厂。如果每个工厂的电力需求都得到满足，那么电网的设计就是正确的。电网的成本与电网输电线的总长度（以公里计）成正比。\n\n写一个程序计算设计一个正确的电网最小成本是多少。", "inputFormat": "第一行一个整数 $n$，表示 Byteotia 的城市个数。\n\n第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$，表示每个城市电力的生产和消耗。", "outputFormat": "输出设计一个正确的电网的最小成本。如果不存在一个正确的电网，输出 $-1$。", "hint": "#### 样例 1 解释\n\n下面是一个包含 $n=17$ 个城市的样例，其中将建造三个工厂（白圈）和四个发电厂（黑圈）。$12$ 公里的正确电网用灰色部分标记。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2wee5eoz.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于一些子任务，满足 $n\\le 5\\times 10^3$。\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 5\\times 10^5$，$-10^9\\le a_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P9098", "type": "P", "difficulty": 2, "samples": [["7\nabcdefg\nedgbcfa", "TAK"], ["5\nabcde\nfghhh", "NIE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "PA（波兰）"], "title": "[PA 2020] Zabawki", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 2 [Zabawki](https://sio2.mimuw.edu.pl/c/pa-2020-1/zab/)**\n\n你可能不知道，Bitie 和 Bytie 兄弟有相当令人印象深刻的玩具收藏品！他们每个人都拥有 $n$ 个玩具，每个玩具都是 $26$ 种类型中的一种。为方便起见，兄弟俩给每种类型的玩具都贴上了从 $\\texttt a$ 到 $\\texttt z$ 的英文字母标签。\n\n在今天的游戏中，Bitie 拿出了他的玩具并按从左到右的顺序排列。因此，Bitie 可以用一个有 $n$ 个英文字母的序列来描述他的玩具的排列；这个序列的第 $i$ 个字符表示 Bitie 的序列中从左起的第 $i$ 个玩具。同时 Bytie 也拿出了他的玩具并按从左到右的顺序排列。现在 Bitie 想变得更像 Bytie——他想把自己的玩具按 Bytie 的玩具的顺序排列。\n\n在游戏过程中，Bitie 可以通过翻转来改变他的玩具的顺序，一次翻转可以取奇数个连续的玩具并颠倒其顺序。因此，如果字符串 $\\texttt{abcdea}$ 描述了 Bitie 的玩具顺序，那么在一次翻转中，Bitie 可以产生例如 $\\texttt{adcbea}$（通过颠倒从第二个到第四个玩具的顺序）或 $\\texttt{edcbaa}$（通过颠倒从第一个到第五个玩具的顺序）的序列。然而，他不能在一次翻转之后得到序列 $\\texttt{bacdea}$。\n\nBitie 能够通过翻转得到和 Bytie 的玩具序列一样的序列吗？", "inputFormat": "第一行一个整数 $n$，表示两人拥有的玩具数量。\n\n第二行一个长度为 $n$ 的字符串，表示 Bitie 的玩具序列。\n\n第三行一个长度为 $n$ 的字符串，表示 Bytie 的玩具序列。", "outputFormat": "如果 Bitie 可以通过翻转得到和 Bytie 一样的玩具序列，输出 `TAK`，否则输出 `NIE`。", "hint": "#### 样例 1 解释\n\n对于第一组样例，Bitie 可以通过三次翻转操作得到和 Bytie 一样的玩具序列。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vexaj3z8.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于一些子任务，满足如果这组数据的答案是 `TAK`，那么 Bitie 最多只需进行一次交换就可以得到和 Bytie 一样的序列。\n\n此外，大约一半的子任务满足 $n\\le 2\\times 10^3$。\n\n对于 $100\\%$ 的数据：\n\n- 保证 $1\\le n\\le 3\\times 10^5$。\n- 保证字符串中只出现小写英文字母（$\\texttt a$ 到 $\\texttt z$）。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Zabawki", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 2 [Zabawki](https://sio2.mimuw.edu.pl/c/pa-2020-1/zab/)**\n\n你可能不知道，Bitie 和 Bytie 兄弟有相当令人印象深刻的玩具收藏品！他们每个人都拥有 $n$ 个玩具，每个玩具都是 $26$ 种类型中的一种。为方便起见，兄弟俩给每种类型的玩具都贴上了从 $\\texttt a$ 到 $\\texttt z$ 的英文字母标签。\n\n在今天的游戏中，Bitie 拿出了他的玩具并按从左到右的顺序排列。因此，Bitie 可以用一个有 $n$ 个英文字母的序列来描述他的玩具的排列；这个序列的第 $i$ 个字符表示 Bitie 的序列中从左起的第 $i$ 个玩具。同时 Bytie 也拿出了他的玩具并按从左到右的顺序排列。现在 Bitie 想变得更像 Bytie——他想把自己的玩具按 Bytie 的玩具的顺序排列。\n\n在游戏过程中，Bitie 可以通过翻转来改变他的玩具的顺序，一次翻转可以取奇数个连续的玩具并颠倒其顺序。因此，如果字符串 $\\texttt{abcdea}$ 描述了 Bitie 的玩具顺序，那么在一次翻转中，Bitie 可以产生例如 $\\texttt{adcbea}$（通过颠倒从第二个到第四个玩具的顺序）或 $\\texttt{edcbaa}$（通过颠倒从第一个到第五个玩具的顺序）的序列。然而，他不能在一次翻转之后得到序列 $\\texttt{bacdea}$。\n\nBitie 能够通过翻转得到和 Bytie 的玩具序列一样的序列吗？", "inputFormat": "第一行一个整数 $n$，表示两人拥有的玩具数量。\n\n第二行一个长度为 $n$ 的字符串，表示 Bitie 的玩具序列。\n\n第三行一个长度为 $n$ 的字符串，表示 Bytie 的玩具序列。", "outputFormat": "如果 Bitie 可以通过翻转得到和 Bytie 一样的玩具序列，输出 `TAK`，否则输出 `NIE`。", "hint": "#### 样例 1 解释\n\n对于第一组样例，Bitie 可以通过三次翻转操作得到和 Bytie 一样的玩具序列。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vexaj3z8.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于一些子任务，满足如果这组数据的答案是 `TAK`，那么 Bitie 最多只需进行一次交换就可以得到和 Bytie 一样的序列。\n\n此外，大约一半的子任务满足 $n\\le 2\\times 10^3$。\n\n对于 $100\\%$ 的数据：\n\n- 保证 $1\\le n\\le 3\\times 10^5$。\n- 保证字符串中只出现小写英文字母（$\\texttt a$ 到 $\\texttt z$）。", "locale": "zh-CN"}}}
{"pid": "P9099", "type": "P", "difficulty": 7, "samples": [["3 3\n3 2\n3 2 1\n1 1 1\n2 3 2", "4\n1\n1000000003"]], "limits": {"time": [9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "PA（波兰）"], "title": "[PA 2020] Ogromne drzewo", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 3 [Ogromne drzewo](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/ogr/)**\n\nByteasar 为他的女朋友 Algolina 买了一棵巨大的圣诞树。这是一份十分不寻常的礼物，但 Byteasar 是一位算法师，Algolina 已经习惯了这种惊喜。\n\n正如你所猜到的，这棵树不是植物，而是一个无环连通图。它非常大，但可以用一种有组织的方式来描述。它的节点有 $n$ 层。第一层只包含一个节点，表示树的根。每个节点的子节点都只在其下一层，最后一层的节点除外，它们是叶子。对于区间 $[1, n - 1]$ 中的每一个 $i$，第 $i$ 层的每个节点都有 $a_i$ 个子节点。\n\nAlgolina 想让 Byteasar 知道她对他的礼物有多满意，因此决定和他玩一个游戏。Algolina 选择了树上的某个节点 $A$，Byteasar 选择了节点 $B$（可能与 Algolina 相同）。现在从 Algolina 开始，他们俩将轮流重新对树的节点涂色——Algolina 用红色，Byteasar 用蓝色。在游戏开始时，所有节点都是白色的。每个节点将恰好被重新涂色一次——由 Algolina 或由 Byteasar 涂色。在任何时候，涂色的人都可以用自己使用的颜色对任何白色节点涂色，包括节点 $A$ 和 $B$。\n\n一旦所有顶点都被重新涂色了，这两人将计算出他们的分数。Algolina 获得的分数（用 $S_A$ 表示）将是所有红色节点到节点 $A$ 的距离之和，而 Byteasar 获得的分数（用 $S_B$ 表示）将是所有蓝色节点到节点 $B$ 的距离之和。我们所说的两个节点之间的距离，是指它们之间最短路径上的边的数量。Algolina 的目标是得分以最大可能比 Byteasar 的大，即最大化 $S_A-S_B$ 的值，而 Byteasar 的目标是最小化它。\n\nByteasar 很快指出，这是一个完全信息有限游戏，假设他们都以最优策略进行游戏，就可以计算出最终得分的差值有多大。他希望你能帮他计算出这个值。由于这个值可能非常大，你需要计算它对 $10^9+7$ 取模后的值。\n\n此外，由于在一次比赛后忘记礼物是不愉快的，你需要计算多次选择节点 $A$ 和 $B$ 的情况下两人最终得分之差。", "inputFormat": "第一行两个整数 $n,q$，分别表示树的层数和询问次数。\n\n第二行 $n-1$ 个整数 $a_1,a_2,\\cdots,a_{n-1}$，意义如题目描述。\n\n接下来 $q$ 行，每行描述 $A,B$。可以发现最终结果只取决于节点 $A,B$ 和它们的最近公共祖先都在哪一层，因此每行给出三个整数 $W_A,W_B,W_{\\operatorname{lca}(A,B)}$。", "outputFormat": "输出 $q$ 行，第 $i$ 行包含对第 $i$ 个询问的回答，对 $10^9+7$ 取模。", "hint": "#### 样例 1 解释\n\n样例中的树有三层，第一层一个节点，第二层三个节点，第三层六个节点。\n\n对于第二个询问，Algolina 和 Byteasar 都选择了根节点。对于最优决策，他们应该按照非递增的层数顺序选择顶点，最后的结果是 $(2 + 2 + 2 + 1 + 1) - (2 + 2 + 2 + 1 + 0) = 1$。\n\n对于第三个询问，答案是 $-4$，但你应该输出 $-4\\bmod (10^9+7)=10^9+3$。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n- 对于一些子任务，满足树最多有 $3\\times 10^5$ 个节点，且 $q\\le 100$；\n- 对于另一些子任务，满足 $q\\le 100$。\n\n对于上述每种情况，至少有一个这样的子任务。\n\n对于 $100\\%$ 的数据，保证 $2\\le n\\le 3\\times 10^5$，$1\\le q\\le 3\\times 10^5$，$2\\le a_i\\le 3\\times 10^5$，$1\\le W_{\\operatorname{lca}(A,B)}\\le W_A,W_B\\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Ogromne drzewo", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 3 [Ogromne drzewo](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/ogr/)**\n\nByteasar 为他的女朋友 Algolina 买了一棵巨大的圣诞树。这是一份十分不寻常的礼物，但 Byteasar 是一位算法师，Algolina 已经习惯了这种惊喜。\n\n正如你所猜到的，这棵树不是植物，而是一个无环连通图。它非常大，但可以用一种有组织的方式来描述。它的节点有 $n$ 层。第一层只包含一个节点，表示树的根。每个节点的子节点都只在其下一层，最后一层的节点除外，它们是叶子。对于区间 $[1, n - 1]$ 中的每一个 $i$，第 $i$ 层的每个节点都有 $a_i$ 个子节点。\n\nAlgolina 想让 Byteasar 知道她对他的礼物有多满意，因此决定和他玩一个游戏。Algolina 选择了树上的某个节点 $A$，Byteasar 选择了节点 $B$（可能与 Algolina 相同）。现在从 Algolina 开始，他们俩将轮流重新对树的节点涂色——Algolina 用红色，Byteasar 用蓝色。在游戏开始时，所有节点都是白色的。每个节点将恰好被重新涂色一次——由 Algolina 或由 Byteasar 涂色。在任何时候，涂色的人都可以用自己使用的颜色对任何白色节点涂色，包括节点 $A$ 和 $B$。\n\n一旦所有顶点都被重新涂色了，这两人将计算出他们的分数。Algolina 获得的分数（用 $S_A$ 表示）将是所有红色节点到节点 $A$ 的距离之和，而 Byteasar 获得的分数（用 $S_B$ 表示）将是所有蓝色节点到节点 $B$ 的距离之和。我们所说的两个节点之间的距离，是指它们之间最短路径上的边的数量。Algolina 的目标是得分以最大可能比 Byteasar 的大，即最大化 $S_A-S_B$ 的值，而 Byteasar 的目标是最小化它。\n\nByteasar 很快指出，这是一个完全信息有限游戏，假设他们都以最优策略进行游戏，就可以计算出最终得分的差值有多大。他希望你能帮他计算出这个值。由于这个值可能非常大，你需要计算它对 $10^9+7$ 取模后的值。\n\n此外，由于在一次比赛后忘记礼物是不愉快的，你需要计算多次选择节点 $A$ 和 $B$ 的情况下两人最终得分之差。", "inputFormat": "第一行两个整数 $n,q$，分别表示树的层数和询问次数。\n\n第二行 $n-1$ 个整数 $a_1,a_2,\\cdots,a_{n-1}$，意义如题目描述。\n\n接下来 $q$ 行，每行描述 $A,B$。可以发现最终结果只取决于节点 $A,B$ 和它们的最近公共祖先都在哪一层，因此每行给出三个整数 $W_A,W_B,W_{\\operatorname{lca}(A,B)}$。", "outputFormat": "输出 $q$ 行，第 $i$ 行包含对第 $i$ 个询问的回答，对 $10^9+7$ 取模。", "hint": "#### 样例 1 解释\n\n样例中的树有三层，第一层一个节点，第二层三个节点，第三层六个节点。\n\n对于第二个询问，Algolina 和 Byteasar 都选择了根节点。对于最优决策，他们应该按照非递增的层数顺序选择顶点，最后的结果是 $(2 + 2 + 2 + 1 + 1) - (2 + 2 + 2 + 1 + 0) = 1$。\n\n对于第三个询问，答案是 $-4$，但你应该输出 $-4\\bmod (10^9+7)=10^9+3$。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n- 对于一些子任务，满足树最多有 $3\\times 10^5$ 个节点，且 $q\\le 100$；\n- 对于另一些子任务，满足 $q\\le 100$。\n\n对于上述每种情况，至少有一个这样的子任务。\n\n对于 $100\\%$ 的数据，保证 $2\\le n\\le 3\\times 10^5$，$1\\le q\\le 3\\times 10^5$，$2\\le a_i\\le 3\\times 10^5$，$1\\le W_{\\operatorname{lca}(A,B)}\\le W_A,W_B\\le n$。", "locale": "zh-CN"}}}
{"pid": "P9100", "type": "P", "difficulty": 5, "samples": [["4\n0 2\n2 0\n3 2\n7 4", "7"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2020", "分治", "单调栈", "PA（波兰）"], "title": "[PA 2020] Miny", "background": null, "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 3 [Miny](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/min/)**\n\n$n$ 枚地雷被运到 Bytau 的军事训练场，并沿一条直线埋设。每个地雷位于不同的地方，并且有自己的爆炸半径。当引爆时，地雷会自动引爆其爆炸半径内所有尚未爆炸的地雷。如果地雷 $a$ 和地雷 $b$ 之间的距离不超过地雷 $b$ 的爆炸半径，则我们称地雷 $a$ 在地雷 $b$ 的爆炸半径内。\n\nBytomir 中士想进行一项实验。他选择了一个任意的地雷子集（也许是空的），并让这个地雷子集内的所有地雷在同时手动引爆。实验的结果是一组已经爆炸的地雷——要么是手动引爆的引起的爆炸，要么是其他地雷爆炸导致的爆炸。\n\nBytomir 能得到多少种可能的实验结果？如果两个实验结果中爆炸的地雷相同，则这两个实验结果是相同的。由于结果可能很大，请输出它除以 $10^9+7$ 的余数。", "inputFormat": "输入第一行包含一个整数 $n$，表示地雷个数。\n\n接下来 $n$ 行，每行两个整数 $a_i,r_i$，分别表示地雷的位置和爆炸半径。你可以假设 $a_1<a_2<\\cdots<a_n$。", "outputFormat": "输出可能的实验结果总数对 $10^9+7$ 取模后的值。", "hint": "#### 样例 1 解释\n\n你可以得到 $7$ 种可能的实验结果：\n\n- $\\{\\}$（空集）：如果不引爆任何地雷；\n- $\\{1,2\\}$（地雷 $1,2$）：如果我们只引爆地雷 $1$；\n- $\\{1,2,3\\}$：如果我们引爆地雷 $1$ 和 $3$；\n- $\\{1,2,3,4\\}$：如果我们引爆地雷 $1$ 和 $4$；\n- $\\{2\\}$：如果我们只引爆地雷 $2$；\n- $\\{2,3\\}$：如果我们只引爆地雷 $3$；\n- $\\{2,3,4\\}$：如果我们只引爆地雷 $4$；\n\n请注意，可以通过不同的方式得到同一个实验结果——例如，如果我们引爆地雷 $1$ 和 $2$，也会得到 $\\{1, 2\\}$ 的结果。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 3\\times 10^5$，$0\\le a_i,r_i\\le 10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Miny", "background": null, "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 3 [Miny](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/min/)**\n\n$n$ 枚地雷被运到 Bytau 的军事训练场，并沿一条直线埋设。每个地雷位于不同的地方，并且有自己的爆炸半径。当引爆时，地雷会自动引爆其爆炸半径内所有尚未爆炸的地雷。如果地雷 $a$ 和地雷 $b$ 之间的距离不超过地雷 $b$ 的爆炸半径，则我们称地雷 $a$ 在地雷 $b$ 的爆炸半径内。\n\nBytomir 中士想进行一项实验。他选择了一个任意的地雷子集（也许是空的），并让这个地雷子集内的所有地雷在同时手动引爆。实验的结果是一组已经爆炸的地雷——要么是手动引爆的引起的爆炸，要么是其他地雷爆炸导致的爆炸。\n\nBytomir 能得到多少种可能的实验结果？如果两个实验结果中爆炸的地雷相同，则这两个实验结果是相同的。由于结果可能很大，请输出它除以 $10^9+7$ 的余数。", "inputFormat": "输入第一行包含一个整数 $n$，表示地雷个数。\n\n接下来 $n$ 行，每行两个整数 $a_i,r_i$，分别表示地雷的位置和爆炸半径。你可以假设 $a_1<a_2<\\cdots<a_n$。", "outputFormat": "输出可能的实验结果总数对 $10^9+7$ 取模后的值。", "hint": "#### 样例 1 解释\n\n你可以得到 $7$ 种可能的实验结果：\n\n- $\\{\\}$（空集）：如果不引爆任何地雷；\n- $\\{1,2\\}$（地雷 $1,2$）：如果我们只引爆地雷 $1$；\n- $\\{1,2,3\\}$：如果我们引爆地雷 $1$ 和 $3$；\n- $\\{1,2,3,4\\}$：如果我们引爆地雷 $1$ 和 $4$；\n- $\\{2\\}$：如果我们只引爆地雷 $2$；\n- $\\{2,3\\}$：如果我们只引爆地雷 $3$；\n- $\\{2,3,4\\}$：如果我们只引爆地雷 $4$；\n\n请注意，可以通过不同的方式得到同一个实验结果——例如，如果我们引爆地雷 $1$ 和 $2$，也会得到 $\\{1, 2\\}$ 的结果。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 3\\times 10^5$，$0\\le a_i,r_i\\le 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P9101", "type": "P", "difficulty": 3, "samples": [["3", "6\n3 5\n6 -1\n2 6\n2 6\n6 -1\n-1 -1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "Special Judge", "构造", "PA（波兰）"], "title": "[PA 2020] Skierowany graf acykliczny", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 5 [Skierowany graf acykliczny](https://sio2.mimuw.edu.pl/c/pa-2020-1/dag/)**\n\n正如名字所示，有向无环图（*Directed Acyclic Graph*，简称 DAG）是一个无环的有向图。\n\n如果我们在这样一个图中选择两个节点，我们可以计算出这些节点之间存在多少条不同的有向路径。如果其中一条路径包含一条边而另一条不包含这条边，我们就认为这两条路径是不同的。\n\n你的任务是构造一个 $n$ 个节点（编号从 $1$ 到 $n$）的有向无环图，其中从节点 $1$ 到节点 $n$ 正好有 $k$ 条路径。你的图最多可以有 $100$ 个节点，每个节点最多可以有两条出边，而且不能包含重边（即如果一个节点有两条出边，它们必须通向不同的节点）。可以证明，对于每一个满足输入中约束条件的 $k$，都可以构造一个满足条件的图。", "inputFormat": "一行一个整数 $k$。", "outputFormat": "第一行输出一个整数 $n$，表示你构造的图中节点的个数。\n\n接下来 $n$ 行，每行两个整数。第 $i$ 行表示以编号为 $i$ 的节点为起点的出边到达的节点编号。这两个数中任何一个都可以是 $-1$，表示不存在这条边。如果两个数都不是 $-1$，那这两个数不应该相等。\n\n如果有许多满足条件的图，你可以输出任何一个。注意你不需要最小化节点个数，且在限制之下图节点个数是足够的。", "hint": "#### 样例 1 解释\n\n下图展示了输出中 $6$ 个节点的有向无环图，从 $1$ 到 $6$ 有三条路径：$1\\to 3\\to 2\\to 6,1\\to 3\\to 6$ 和 $1\\to 5\\to 6$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hinzei5g.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le k\\le 10^9$，$2\\le n\\le 100$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Skierowany graf acykliczny", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 5 [Skierowany graf acykliczny](https://sio2.mimuw.edu.pl/c/pa-2020-1/dag/)**\n\n正如名字所示，有向无环图（*Directed Acyclic Graph*，简称 DAG）是一个无环的有向图。\n\n如果我们在这样一个图中选择两个节点，我们可以计算出这些节点之间存在多少条不同的有向路径。如果其中一条路径包含一条边而另一条不包含这条边，我们就认为这两条路径是不同的。\n\n你的任务是构造一个 $n$ 个节点（编号从 $1$ 到 $n$）的有向无环图，其中从节点 $1$ 到节点 $n$ 正好有 $k$ 条路径。你的图最多可以有 $100$ 个节点，每个节点最多可以有两条出边，而且不能包含重边（即如果一个节点有两条出边，它们必须通向不同的节点）。可以证明，对于每一个满足输入中约束条件的 $k$，都可以构造一个满足条件的图。", "inputFormat": "一行一个整数 $k$。", "outputFormat": "第一行输出一个整数 $n$，表示你构造的图中节点的个数。\n\n接下来 $n$ 行，每行两个整数。第 $i$ 行表示以编号为 $i$ 的节点为起点的出边到达的节点编号。这两个数中任何一个都可以是 $-1$，表示不存在这条边。如果两个数都不是 $-1$，那这两个数不应该相等。\n\n如果有许多满足条件的图，你可以输出任何一个。注意你不需要最小化节点个数，且在限制之下图节点个数是足够的。", "hint": "#### 样例 1 解释\n\n下图展示了输出中 $6$ 个节点的有向无环图，从 $1$ 到 $6$ 有三条路径：$1\\to 3\\to 2\\to 6,1\\to 3\\to 6$ 和 $1\\to 5\\to 6$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hinzei5g.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le k\\le 10^9$，$2\\le n\\le 100$。", "locale": "zh-CN"}}}
{"pid": "P9102", "type": "P", "difficulty": 4, "samples": [["5\n2 7 4 4 1", "8"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2020", "PA（波兰）"], "title": "[PA 2020] Cukierki", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 5 [Cukierki](https://sio2.mimuw.edu.pl/c/pa-2020-1/cuk/)**\n\nBytie 要去参加 Bitek 的生日聚会。他知道 Bitek 喜欢吃甜食，所以他想送他一些糖果作为礼物。他买了 $n$ 袋糖，其中第 $i$ 袋包含 $a_i$ 个糖果。\n\n然而，这些糖相当重，Bytie 想知道他是否需要把它们全都给 Bitek。他决定，他将选择一个非空的袋装糖果子集，把它们拿给 Bitek，并对他说：「我这里总共有 $x$ 颗糖果，你想要多少？」，其中 $x$ 将是带到派对上的包装里的糖果总数。Bitek 听到这个问题后，可能会选择区间 $[1, x]$ 中的任何整数 $y$。无论 Bitek 的回答如何，他都希望能够从带到派对上的糖中选择一部分（其余的留给自己），这样这些袋糖中的糖果总数正好等于 $y$。当然，不可以撕毁包装纸——给散装的糖果是不礼貌的。\n\n因此，Bytie 在想，他能给 Bitek 带去多少种非空的袋装糖果子集，以便在不考虑 Bitek 的选择的情况下，能够送给他所需数量的糖果。请帮助他计算一下吧！由于这种子集的数量可能非常大，请输出它对 $10^9+7$ 取模后的结果。", "inputFormat": "第一行一个整数 $n$，表示 Bytie 有的袋装糖果数量。\n\n第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$，表示每袋糖果中糖果的数量。", "outputFormat": "输出可能的袋装糖果子集种类数对 $10^9+7$ 取模后的值。", "hint": "#### 样例 1 解释\n\nBytie 可以带去 $8$ 种非空子集：$\\{5\\}, \\{1, 5\\}, \\{1, 3, 5\\}, \\{1, 4, 5\\}, \\{1, 3, 4, 5\\}, \\{1, 2, 3, 5\\}, \\{1, 2, 4, 5\\}$ 和 $\\{1, 2, 3, 4, 5\\}$。例如，Bytie 带去的子集是 $\\{1,2,4,5\\}$，Bitek 想要 $9$ 颗糖果时，Bytie 只能给他第 $1,2$ 包糖。Bytie 不可以带去 $\\{1,2,5\\}$ 子集，如果 Bitek 想要 $6$ 颗糖的话 Bytie 就犯难了。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 5\\times 10^3$，$1\\le a_i\\le 5\\times 10^3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Cukierki", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 5 [Cukierki](https://sio2.mimuw.edu.pl/c/pa-2020-1/cuk/)**\n\nBytie 要去参加 Bitek 的生日聚会。他知道 Bitek 喜欢吃甜食，所以他想送他一些糖果作为礼物。他买了 $n$ 袋糖，其中第 $i$ 袋包含 $a_i$ 个糖果。\n\n然而，这些糖相当重，Bytie 想知道他是否需要把它们全都给 Bitek。他决定，他将选择一个非空的袋装糖果子集，把它们拿给 Bitek，并对他说：「我这里总共有 $x$ 颗糖果，你想要多少？」，其中 $x$ 将是带到派对上的包装里的糖果总数。Bitek 听到这个问题后，可能会选择区间 $[1, x]$ 中的任何整数 $y$。无论 Bitek 的回答如何，他都希望能够从带到派对上的糖中选择一部分（其余的留给自己），这样这些袋糖中的糖果总数正好等于 $y$。当然，不可以撕毁包装纸——给散装的糖果是不礼貌的。\n\n因此，Bytie 在想，他能给 Bitek 带去多少种非空的袋装糖果子集，以便在不考虑 Bitek 的选择的情况下，能够送给他所需数量的糖果。请帮助他计算一下吧！由于这种子集的数量可能非常大，请输出它对 $10^9+7$ 取模后的结果。", "inputFormat": "第一行一个整数 $n$，表示 Bytie 有的袋装糖果数量。\n\n第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$，表示每袋糖果中糖果的数量。", "outputFormat": "输出可能的袋装糖果子集种类数对 $10^9+7$ 取模后的值。", "hint": "#### 样例 1 解释\n\nBytie 可以带去 $8$ 种非空子集：$\\{5\\}, \\{1, 5\\}, \\{1, 3, 5\\}, \\{1, 4, 5\\}, \\{1, 3, 4, 5\\}, \\{1, 2, 3, 5\\}, \\{1, 2, 4, 5\\}$ 和 $\\{1, 2, 3, 4, 5\\}$。例如，Bytie 带去的子集是 $\\{1,2,4,5\\}$，Bitek 想要 $9$ 颗糖果时，Bytie 只能给他第 $1,2$ 包糖。Bytie 不可以带去 $\\{1,2,5\\}$ 子集，如果 Bitek 想要 $6$ 颗糖的话 Bytie 就犯难了。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 5\\times 10^3$，$1\\le a_i\\le 5\\times 10^3$。", "locale": "zh-CN"}}}
{"pid": "P9103", "type": "P", "difficulty": 6, "samples": [["4\n3 1 -1 3\n2 -1 4 2", "3"], ["8\n2 4 2 7 4 5 -1 7\n2 3 6 5 3 -1 6 7", "7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2020", "笛卡尔树", "PA（波兰）"], "title": "[PA 2020] Bardzo skomplikowany test", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 5 [Bardzo skomplikowany test](https://sio2.mimuw.edu.pl/c/pa-2020-1/bst/)**\n\nBytie 刚刚参加了算法和数据结构这门课的面试。他没有为之学习太长时间，所以他做得不是太好。经过几分钟的交谈，这位心碎的主讲老师决定给这个男孩最后一次机会。\n\n- 「孩儿，你知道啥是 BST 不？」教授问\n\nBytie 听到这句话后内心狂喜，因为在他上课睡觉的时候记住了一些理论。\n\n- 「知道。大小为 $n$ 的 BST 是一棵有根树，其顶点用 $1$ 到 $n$ 的整数来编号。每个节点最多可以有两个子节点；它可以有一个最多一个左子节点和一个最多一个右子节点。此外，每个节点的编号必须大于其左子树中所有节点的编号，并小于其右子树中所有顶点的编号。」Bytie 回答说，他达到了他潜意识的深处。\n- 「很好。让我们看看你是否记住了如何对 BST 进行旋转。」一直坐在那里的教授回答说。他站起来，向黑板走去。\n\nBytie 被冷汗浸透了。他一时失去了信心，因为他记不起旋转的具体原理（可能在上这节课的时候，他正在另一边摸鱼，没听课）。考官在黑板上画了两棵同样大小的 BST 树，并让 Bytie 用正确的旋转将第一棵树转化为第二棵树。\n\nBytie 想了一会儿，认为左旋就是选择某个节点 $v$ 和它的右子节点 $w$，并让 $w$ 成为 $v$ 的父节点。Bytie 的直觉用以下伪代码描述。\n\n```\nif v.Parent != null then\n    if v.Parent.RightSon == v then\n        v.Parent.RightSon := w\n    else\n        v.Parent.LeftSon := w\nw.Parent := v.Parent\nv.Parent := w\nw.LeftSon := v\nv.RightSon := null\n```\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/shqgiur7.png)\n\n以此类推，Bytie 理解了右旋，其中 $w$ 是 $v$ 的左子节点。\n\n```\nif v.Parent != null then\n    if v.Parent.RightSon == v then\n        v.Parent.RightSon := w\n    else\n        v.Parent.LeftSon := w\nw.Parent := v.Parent\nv.Parent := w\nw.RightSon := v\nv.LeftSon := null\n```\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tpmzihlx.png)\n\n然而，Bytie 很快就注意到有些不对劲。如果节点 $w$ 在左旋时有左子树，它就会丢失！同样在右转过程中，节点 $w$ 的右子树也会丢失。\n\n- 「快点孩儿，你不是唯一一个想通过这次考试的人。」教授不耐烦地催促道。\n\n在没有太多时间考虑的情况下，Bytie 假设只有在这个有问题的子树是空的情况下才能执行旋转，也就是说，如果没有顶点丢失并且树保持一致的话才进行旋转。\n\n为了尽快结束他的煎熬，他决定进行最少次数的旋转，使他能够将第一棵树变成第二棵。请告诉他这是否可行，如果可行，他需要进行多少次轮换？由于这个数字可能相当大，请告诉他这个值对 $10^9+7$ 取模后的值。", "inputFormat": "第一行包含一个整数 $n$，表示这个 BST 的大小。\n\n接下来两行描述这两棵树。对于一棵树用一行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$ 描述。如果 $a_i\\ge 1$，表示 $i$ 节点的父节点；如果 $a_i=-1$，则表示这是树的根节点。\n\n你可以假设这两棵树都是合法的 BST，即树中没有环，恰好有一个根节点，每个节点最多只有一个比自己小的子节点和一个比自己大的子节点。", "outputFormat": "输出应该包含一个整数，表示用 Bytie 的方式把第一棵树转化为第二棵树所需最少旋转次数对 $10^9+7$ 取模后的值，如果不可能转化，输出 $-1$。", "hint": "#### 样例 1 解释\n\n下图展示了旋转最小次数所采取的旋转方式。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f1dblwez.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 5\\times 10^5$，$-1\\le a_i\\le n$，$a_i\\neq 0$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Bardzo skomplikowany test", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 5 [Bardzo skomplikowany test](https://sio2.mimuw.edu.pl/c/pa-2020-1/bst/)**\n\nBytie 刚刚参加了算法和数据结构这门课的面试。他没有为之学习太长时间，所以他做得不是太好。经过几分钟的交谈，这位心碎的主讲老师决定给这个男孩最后一次机会。\n\n- 「孩儿，你知道啥是 BST 不？」教授问\n\nBytie 听到这句话后内心狂喜，因为在他上课睡觉的时候记住了一些理论。\n\n- 「知道。大小为 $n$ 的 BST 是一棵有根树，其顶点用 $1$ 到 $n$ 的整数来编号。每个节点最多可以有两个子节点；它可以有一个最多一个左子节点和一个最多一个右子节点。此外，每个节点的编号必须大于其左子树中所有节点的编号，并小于其右子树中所有顶点的编号。」Bytie 回答说，他达到了他潜意识的深处。\n- 「很好。让我们看看你是否记住了如何对 BST 进行旋转。」一直坐在那里的教授回答说。他站起来，向黑板走去。\n\nBytie 被冷汗浸透了。他一时失去了信心，因为他记不起旋转的具体原理（可能在上这节课的时候，他正在另一边摸鱼，没听课）。考官在黑板上画了两棵同样大小的 BST 树，并让 Bytie 用正确的旋转将第一棵树转化为第二棵树。\n\nBytie 想了一会儿，认为左旋就是选择某个节点 $v$ 和它的右子节点 $w$，并让 $w$ 成为 $v$ 的父节点。Bytie 的直觉用以下伪代码描述。\n\n```\nif v.Parent != null then\n    if v.Parent.RightSon == v then\n        v.Parent.RightSon := w\n    else\n        v.Parent.LeftSon := w\nw.Parent := v.Parent\nv.Parent := w\nw.LeftSon := v\nv.RightSon := null\n```\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/shqgiur7.png)\n\n以此类推，Bytie 理解了右旋，其中 $w$ 是 $v$ 的左子节点。\n\n```\nif v.Parent != null then\n    if v.Parent.RightSon == v then\n        v.Parent.RightSon := w\n    else\n        v.Parent.LeftSon := w\nw.Parent := v.Parent\nv.Parent := w\nw.RightSon := v\nv.LeftSon := null\n```\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tpmzihlx.png)\n\n然而，Bytie 很快就注意到有些不对劲。如果节点 $w$ 在左旋时有左子树，它就会丢失！同样在右转过程中，节点 $w$ 的右子树也会丢失。\n\n- 「快点孩儿，你不是唯一一个想通过这次考试的人。」教授不耐烦地催促道。\n\n在没有太多时间考虑的情况下，Bytie 假设只有在这个有问题的子树是空的情况下才能执行旋转，也就是说，如果没有顶点丢失并且树保持一致的话才进行旋转。\n\n为了尽快结束他的煎熬，他决定进行最少次数的旋转，使他能够将第一棵树变成第二棵。请告诉他这是否可行，如果可行，他需要进行多少次轮换？由于这个数字可能相当大，请告诉他这个值对 $10^9+7$ 取模后的值。", "inputFormat": "第一行包含一个整数 $n$，表示这个 BST 的大小。\n\n接下来两行描述这两棵树。对于一棵树用一行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$ 描述。如果 $a_i\\ge 1$，表示 $i$ 节点的父节点；如果 $a_i=-1$，则表示这是树的根节点。\n\n你可以假设这两棵树都是合法的 BST，即树中没有环，恰好有一个根节点，每个节点最多只有一个比自己小的子节点和一个比自己大的子节点。", "outputFormat": "输出应该包含一个整数，表示用 Bytie 的方式把第一棵树转化为第二棵树所需最少旋转次数对 $10^9+7$ 取模后的值，如果不可能转化，输出 $-1$。", "hint": "#### 样例 1 解释\n\n下图展示了旋转最小次数所采取的旋转方式。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f1dblwez.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 5\\times 10^5$，$-1\\le a_i\\le n$，$a_i\\neq 0$。", "locale": "zh-CN"}}}
{"pid": "P9104", "type": "P", "difficulty": 6, "samples": [["4 3 4\n1 2 4 2\n3 1 3 4\n3 2 3 2\n4 4\n3 2\n4 3\n4 4", "6\n7\n7\n8\n7"], ["7 2 0\n1 1 6 6\n2 2 7 7", "22"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "PA（波兰）"], "title": "[PA 2020] Królewski bal", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 5 [Królewski bal](https://sio2.mimuw.edu.pl/c/pa-2020-1/bal/)**\n\n自古以来，Byteotia 的所有统治者都会举行奢华的舞会，Byteur 国王也不例外。然而，每当他组织一次，他就觉得少了点什么。因此，他决定在下一次舞会中加入一些艺术元素。\n\n为此，Byteur 国王委托他的首席顾问编排演出，不久之后，首席顾问向他提出了自己的设想。\n\n根据顾问的计划，$n^2$ 名马戏团演员将参加演出，其中 $n$ 是一个正整数。在演出的压轴部分，他们将排成 $n$ 行，每行恰好有 $n$ 个马戏团演员，从而形成一个 $n\\times n$ 大小的正方形。在压轴部分开始时，每个演员将带或不带燃烧的呼拉圈跳舞。在午夜时分，一些带着呼啦圈跳舞的马戏团演员可能会把呼啦圈扔给其他没有带呼啦圈跳舞的马戏团演员。每个演员最多允许扔给一个其他的演员。\n\n他们都会在同一时间进行投掷。他们是专业人士，所以他们的呼啦圈肯定不会在空中相撞，但这里有一个问题。**每次投掷必须在位于同一行或同一列的演员之间进行**。\n\n值得一提的是，Byteur 国王喜欢大规模的行动，所以马戏团演员的数量可能非常庞大。在制定计划时，他的顾问首先确定了数字 $n$，并假设所有马戏团的演员都会在没有燃烧呼拉圈的情况下开始最后的表演。然后，他会选择 $m$ 次一些特定的行列范围，画出一个矩形，并使得这个区域中的每个演员应该以不同的方式开始压轴表演。即，如果在之前的方案中他们拿着呼啦圈开始，则这版方案中他们就不拿呼啦圈开始，反之亦然。\n\nByteur 国王在得知顾问的计划后，立即明白，为了使演出尽可能地壮观，呼啦圈的抛掷次数应该尽可能地多。Byteur 国王想知道这个数字，但这并不容易，因为他不断修改计划。他的每项修改（他总共已经做了 $q$ 次修改）都涉及到挑选一个马戏团演员并改变他开始压轴表演的方式（即如果他之前拿着呼啦圈开始，那么他现在就不拿着呼啦圈开始，反之亦然）。国王的修改在方案上永久保留，也就是说，如果有任何适用于某个马戏团演员的修改，这个修改的效果一直保留到最后，除非国王再次修改他。\n\n因此，顾问的任务并不简单。帮助他，对于区间 $[0, q]$ 中的每个整数 $i$，在考虑国王的前 $i$ 次修改后，确定可能发生的最大投掷次数。", "inputFormat": "第一行三个整数 $n,m,q$。\n\n接下来 $m$ 行描述顾问的方案，每行包含四个整数 $x_1,y_1,x_2,y_2$，表示对行编号 $x_1$ 到 $x_2$（包含两端），列编号 $y_1$ 到 $y_2$（包含两端）的艺术家进行一次操作。行列编号均从 $1$ 到 $n$。\n\n接下来 $q$ 行描述国王的修改，第 $i$ 行包含两个数 $a_i,b_i$，表示国王修改第 $a_i$ 行第 $b_i$ 列的演员状态。", "outputFormat": "输出 $q+1$ 行，第 $i$ 行输出如果考虑国王的前 $i-1$ 次修改，可能发生的最大投掷次数。", "hint": "#### 样例 1 解释\n\n下图展示了国王进行了第一次修改后的情况。演出开始有呼啦圈的演员用加粗圆圈标出，箭头标明了可能发生的投掷。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/brbphngp.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n- 对于一些子任务，满足 $n\\le 50$，$m\\le 10^4$，$q=0$。\n- 对于一些其他的子任务，满足 $n\\le 200$，$m\\le 10^5$，$q\\le 10$。\n- 对于一些其他的子任务，满足 $n\\le 2\\times 10^3$，$m\\le 10^5$，$q\\le 5\\times 10^3$。\n- 对于一些其他的子任务，满足 $q=0$。\n\n对于上述情况，至少有一个子任务满足。\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 3\\times 10^5$，$0\\le m,q\\le 3\\times 10^5$，$1\\le x_1\\le x_2\\le n$，$1\\le y_1\\le y_2\\le n$，$1\\le a_i,b_i\\le n$。\n\n此外，对于每个子任务，至少满足以下条件中的一个：\n\n- $n\\le 2\\times 10^3$\n- 时间限制为 $12$ 秒\n\n由于未给出具体子任务时间限制，因此在洛谷上所有子任务的时间限制均为 $3$ 秒。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Królewski bal", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 5 [Królewski bal](https://sio2.mimuw.edu.pl/c/pa-2020-1/bal/)**\n\n自古以来，Byteotia 的所有统治者都会举行奢华的舞会，Byteur 国王也不例外。然而，每当他组织一次，他就觉得少了点什么。因此，他决定在下一次舞会中加入一些艺术元素。\n\n为此，Byteur 国王委托他的首席顾问编排演出，不久之后，首席顾问向他提出了自己的设想。\n\n根据顾问的计划，$n^2$ 名马戏团演员将参加演出，其中 $n$ 是一个正整数。在演出的压轴部分，他们将排成 $n$ 行，每行恰好有 $n$ 个马戏团演员，从而形成一个 $n\\times n$ 大小的正方形。在压轴部分开始时，每个演员将带或不带燃烧的呼拉圈跳舞。在午夜时分，一些带着呼啦圈跳舞的马戏团演员可能会把呼啦圈扔给其他没有带呼啦圈跳舞的马戏团演员。每个演员最多允许扔给一个其他的演员。\n\n他们都会在同一时间进行投掷。他们是专业人士，所以他们的呼啦圈肯定不会在空中相撞，但这里有一个问题。**每次投掷必须在位于同一行或同一列的演员之间进行**。\n\n值得一提的是，Byteur 国王喜欢大规模的行动，所以马戏团演员的数量可能非常庞大。在制定计划时，他的顾问首先确定了数字 $n$，并假设所有马戏团的演员都会在没有燃烧呼拉圈的情况下开始最后的表演。然后，他会选择 $m$ 次一些特定的行列范围，画出一个矩形，并使得这个区域中的每个演员应该以不同的方式开始压轴表演。即，如果在之前的方案中他们拿着呼啦圈开始，则这版方案中他们就不拿呼啦圈开始，反之亦然。\n\nByteur 国王在得知顾问的计划后，立即明白，为了使演出尽可能地壮观，呼啦圈的抛掷次数应该尽可能地多。Byteur 国王想知道这个数字，但这并不容易，因为他不断修改计划。他的每项修改（他总共已经做了 $q$ 次修改）都涉及到挑选一个马戏团演员并改变他开始压轴表演的方式（即如果他之前拿着呼啦圈开始，那么他现在就不拿着呼啦圈开始，反之亦然）。国王的修改在方案上永久保留，也就是说，如果有任何适用于某个马戏团演员的修改，这个修改的效果一直保留到最后，除非国王再次修改他。\n\n因此，顾问的任务并不简单。帮助他，对于区间 $[0, q]$ 中的每个整数 $i$，在考虑国王的前 $i$ 次修改后，确定可能发生的最大投掷次数。", "inputFormat": "第一行三个整数 $n,m,q$。\n\n接下来 $m$ 行描述顾问的方案，每行包含四个整数 $x_1,y_1,x_2,y_2$，表示对行编号 $x_1$ 到 $x_2$（包含两端），列编号 $y_1$ 到 $y_2$（包含两端）的艺术家进行一次操作。行列编号均从 $1$ 到 $n$。\n\n接下来 $q$ 行描述国王的修改，第 $i$ 行包含两个数 $a_i,b_i$，表示国王修改第 $a_i$ 行第 $b_i$ 列的演员状态。", "outputFormat": "输出 $q+1$ 行，第 $i$ 行输出如果考虑国王的前 $i-1$ 次修改，可能发生的最大投掷次数。", "hint": "#### 样例 1 解释\n\n下图展示了国王进行了第一次修改后的情况。演出开始有呼啦圈的演员用加粗圆圈标出，箭头标明了可能发生的投掷。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/brbphngp.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n- 对于一些子任务，满足 $n\\le 50$，$m\\le 10^4$，$q=0$。\n- 对于一些其他的子任务，满足 $n\\le 200$，$m\\le 10^5$，$q\\le 10$。\n- 对于一些其他的子任务，满足 $n\\le 2\\times 10^3$，$m\\le 10^5$，$q\\le 5\\times 10^3$。\n- 对于一些其他的子任务，满足 $q=0$。\n\n对于上述情况，至少有一个子任务满足。\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 3\\times 10^5$，$0\\le m,q\\le 3\\times 10^5$，$1\\le x_1\\le x_2\\le n$，$1\\le y_1\\le y_2\\le n$，$1\\le a_i,b_i\\le n$。\n\n此外，对于每个子任务，至少满足以下条件中的一个：\n\n- $n\\le 2\\times 10^3$\n- 时间限制为 $12$ 秒\n\n由于未给出具体子任务时间限制，因此在洛谷上所有子任务的时间限制均为 $3$ 秒。", "locale": "zh-CN"}}}
{"pid": "P9105", "type": "P", "difficulty": 7, "samples": [["8 11\n2 3\n4 5\n3 1\n3 2\n5 7\n3 6\n1 2\n3 4\n6 5\n8 7\n7 8", "103"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "PA（波兰）"], "title": "[PA 2020] Trzy drogi", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 5 [Trzy drogi](https://sio2.mimuw.edu.pl/c/pa-2020-1/trz/)**\n\nByteur 国王，Byteotia 的统治者，梦想着征服 Bitotia。梦见打败敌人是件令人愉快的事，然而生活不是一场梦，醒来后情况就有些不同。\n\nByteotia 由 $n$ 个城市（编号从 $1$ 到 $n$）组成，由 $m$ 条双向道路连接。每条路都连接着两个不同的城市，但也可能有多条道路连接着同一对城市的情况。从任何城市出发，经过一条或多条道路可以到达其他任意城市。\n\n国王想知道，如果 Bitotia 进攻 Byteotia，从现有的 $m$ 条道路中毁掉三条，会发生什么，将严重损害该国的通信的可能性有多大？你的任务是找出答案！数一数有多少条这样的三条路，在这些路被毁之后，至少有一对城市不可以通过剩余的道路互相到达对方。", "inputFormat": "第一行包含两个整数 $n,m$，分别表示 Byteotia 的城市个数和道路条数。\n\n接下来 $m$ 行，每行两个整数 $a_i,b_i$，表示城市 $a_i$ 和 $b_i$ 之间被一条道路连接。\n\n你可以假设从任何城市出发，经过一条或多条道路可以到达其他任意城市。", "outputFormat": "输出一行一个整数，表示移除这三条路，至少存在两个城市彼此不可达的无序三元组的个数。", "hint": "#### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ew3z3u7s.png)\n\n请注意，例如移除第 $3,5,7$ 条路后，Byteotia 会被分为多于两部分，但这样的三元组只能被计算一次。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $2\\le n\\le 2\\times 10^5$，$3\\le m\\le 5\\times 10^5$，$1\\le a_i,b_i\\le n$，$a_i\\neq b_i$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Trzy drogi", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 5 [Trzy drogi](https://sio2.mimuw.edu.pl/c/pa-2020-1/trz/)**\n\nByteur 国王，Byteotia 的统治者，梦想着征服 Bitotia。梦见打败敌人是件令人愉快的事，然而生活不是一场梦，醒来后情况就有些不同。\n\nByteotia 由 $n$ 个城市（编号从 $1$ 到 $n$）组成，由 $m$ 条双向道路连接。每条路都连接着两个不同的城市，但也可能有多条道路连接着同一对城市的情况。从任何城市出发，经过一条或多条道路可以到达其他任意城市。\n\n国王想知道，如果 Bitotia 进攻 Byteotia，从现有的 $m$ 条道路中毁掉三条，会发生什么，将严重损害该国的通信的可能性有多大？你的任务是找出答案！数一数有多少条这样的三条路，在这些路被毁之后，至少有一对城市不可以通过剩余的道路互相到达对方。", "inputFormat": "第一行包含两个整数 $n,m$，分别表示 Byteotia 的城市个数和道路条数。\n\n接下来 $m$ 行，每行两个整数 $a_i,b_i$，表示城市 $a_i$ 和 $b_i$ 之间被一条道路连接。\n\n你可以假设从任何城市出发，经过一条或多条道路可以到达其他任意城市。", "outputFormat": "输出一行一个整数，表示移除这三条路，至少存在两个城市彼此不可达的无序三元组的个数。", "hint": "#### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ew3z3u7s.png)\n\n请注意，例如移除第 $3,5,7$ 条路后，Byteotia 会被分为多于两部分，但这样的三元组只能被计算一次。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $2\\le n\\le 2\\times 10^5$，$3\\le m\\le 5\\times 10^5$，$1\\le a_i,b_i\\le n$，$a_i\\neq b_i$。", "locale": "zh-CN"}}}
{"pid": "P9106", "type": "P", "difficulty": 7, "samples": [["2\n2\n12\nW + 2 Z W + 2 Z W + 2 Z W + 2 Z\n12\nW + 3 Z W + 3 Z W + 3 Z W + 3 Z\n3\n3\nW W - 5\n5\n+ 9 Z + 1 Z W\n8\n+ 10 Z - 2 Z - 5 W - 1 Z", "5\n7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "PA（波兰）"], "title": "[PA 2020] Programowanie współbieżne", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 5 [Programowanie współbieżne](https://sio2.mimuw.edu.pl/c/pa-2020-1/pro/)**\n\n为了准备算法竞赛，Bytie 决定学习一些并发编程的知识。毕竟，即使是 PA，也曾经出过分布式题（参考 PA 2018 Runda 4）。\n\nBytie 从编写 $n$ 个非常简单的程序开始。所有程序共享一个全局整数型变量 $x$，此外，每个程序都有一个私有的计数器 $y$。每个程序都由一连串的指令组成，每个指令都属于以下四种类型之一：\n\n- $\\texttt W$：将全局变量的值 $x$ 载入私有计数器 $y$。\n- $\\texttt Z$：将私有计数器 $y$ 的值写入全局变量 $x$。\n- $\\texttt{+ }c$：将 $y$ 的值加一正常数 $c$。\n- $\\texttt{- }c$：将 $y$ 的值减一正常数 $c$。\n\nBytie 并行运行所有的程序。所有计数器 $y$ 和变量 $x$ 的初始值都是 $0$。这些程序的指令**交错**执行，即所有程序的所有指令都是一个接一个地执行，对于每个时刻，每个程序满足它的指令的一个前缀以一定顺序被执行。\n\n这种交错执行的方式结果是相当不幸的，变量 $x$ 的最终值是如此之小，以至于让 Bytie 非常惊讶。他甚至怀疑这是不可能的，是他的电脑骗了他。帮助 Bytie 验证他的疑惑，写一个验证器，对于给定的程序，计算所有程序并行执行后变量 $x$ 的最小可能值是多少。", "inputFormat": "第一行一个整数 $t$，表示一组测试数据中测试点个数。\n\n对于每个测试点，第一行一个整数 $n$，表示 Bytie 写的程序个数。\n\n接下来 $2n$ 行描述每个程序。对于每个程序的描述有两行，第一行一个整数 $l$，表示程序中指令个数。第二行包含对这 $l$ 个指令的描述，指令是如下四种类型之一：\n\n- 一个字符 $\\texttt W$：表示载入指令；\n- 一个字符 $\\texttt Z$：表示写入指令；\n- 一个字符 $\\texttt{+}$ 和一个数字 $c$：表示给私有计数器加 $c$；\n- 一个字符 $\\texttt{-}$ 和一个数字 $c$：表示给私有计数器减 $c$。\n\n对于一组数据中的所有测试点，$l$ 的总和不超过 $10^6$。", "outputFormat": "输出 $t$ 行，第 $i$ 行是对第 $i$ 个测试点的回答，表示在并行执行这些程序后 $x$ 可能的最小值。", "hint": "#### 样例 1 解释\n\n对于第一个测试点，得到最小的 $x$ 程序指令执行顺序如下表。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/llutmlbg.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le t\\le 10^5$，$1\\le n\\le 10^5$，$1\\le l\\le 10^5$，$\\sum{l}\\leq 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Programowanie współbieżne", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 5 [Programowanie współbieżne](https://sio2.mimuw.edu.pl/c/pa-2020-1/pro/)**\n\n为了准备算法竞赛，Bytie 决定学习一些并发编程的知识。毕竟，即使是 PA，也曾经出过分布式题（参考 PA 2018 Runda 4）。\n\nBytie 从编写 $n$ 个非常简单的程序开始。所有程序共享一个全局整数型变量 $x$，此外，每个程序都有一个私有的计数器 $y$。每个程序都由一连串的指令组成，每个指令都属于以下四种类型之一：\n\n- $\\texttt W$：将全局变量的值 $x$ 载入私有计数器 $y$。\n- $\\texttt Z$：将私有计数器 $y$ 的值写入全局变量 $x$。\n- $\\texttt{+ }c$：将 $y$ 的值加一正常数 $c$。\n- $\\texttt{- }c$：将 $y$ 的值减一正常数 $c$。\n\nBytie 并行运行所有的程序。所有计数器 $y$ 和变量 $x$ 的初始值都是 $0$。这些程序的指令**交错**执行，即所有程序的所有指令都是一个接一个地执行，对于每个时刻，每个程序满足它的指令的一个前缀以一定顺序被执行。\n\n这种交错执行的方式结果是相当不幸的，变量 $x$ 的最终值是如此之小，以至于让 Bytie 非常惊讶。他甚至怀疑这是不可能的，是他的电脑骗了他。帮助 Bytie 验证他的疑惑，写一个验证器，对于给定的程序，计算所有程序并行执行后变量 $x$ 的最小可能值是多少。", "inputFormat": "第一行一个整数 $t$，表示一组测试数据中测试点个数。\n\n对于每个测试点，第一行一个整数 $n$，表示 Bytie 写的程序个数。\n\n接下来 $2n$ 行描述每个程序。对于每个程序的描述有两行，第一行一个整数 $l$，表示程序中指令个数。第二行包含对这 $l$ 个指令的描述，指令是如下四种类型之一：\n\n- 一个字符 $\\texttt W$：表示载入指令；\n- 一个字符 $\\texttt Z$：表示写入指令；\n- 一个字符 $\\texttt{+}$ 和一个数字 $c$：表示给私有计数器加 $c$；\n- 一个字符 $\\texttt{-}$ 和一个数字 $c$：表示给私有计数器减 $c$。\n\n对于一组数据中的所有测试点，$l$ 的总和不超过 $10^6$。", "outputFormat": "输出 $t$ 行，第 $i$ 行是对第 $i$ 个测试点的回答，表示在并行执行这些程序后 $x$ 可能的最小值。", "hint": "#### 样例 1 解释\n\n对于第一个测试点，得到最小的 $x$ 程序指令执行顺序如下表。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/llutmlbg.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le t\\le 10^5$，$1\\le n\\le 10^5$，$1\\le l\\le 10^5$，$\\sum{l}\\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P9107", "type": "P", "difficulty": 3, "samples": [["5 7 1\n......X\nX.X..X.\n..X.X.X\n.X.X...\n.....X.\n2 1", "26 1"], ["2 5 4\n.X...\n...X.\n2 1\n2 2\n1 7\n2 1", "13 3"]], "limits": {"time": [3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "广度优先搜索 BFS", "PA（波兰）"], "title": "[PA 2020] Wycieczka górska", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 4 [Wycieczka górska](https://sio2.mimuw.edu.pl/c/pa-2020-1/wyc/)**\n\n一群 $k$ 个旅行者朋友去了 Byte 山。在最后一天，他们决定组织一场登山比赛，从他们所住的旅店到 Byte 山顶。\n\n每个旅行者都有一张区域地图，它是一个分为 $n$ 行 $m$ 列的矩形；因此地图一共包含 $n\\cdot m$ 个区域。旅店位于地图左上角的区域，而山顶则位于地图右下角的区域。Byte 山以其非常均匀而闻名——对于地图上的任何区域，在地图上与之相邻的右面或下面的区域海拔较高，而相邻的左边或上面区域海拔较低。但是，这座山也因潜伏着许多危险地区而闻名。有些地区在地图上标明是非常危险的，因为那里有野生动物居住——所以最好不要到那里去……\n\n你是 Byte 山山脚下的一个小屋的看守人。通过观察每一个旅行者，你已经为他们每个人分配了两个参数 $a_i$ 和 $b_i$，这些参数决定了他们在山坡上的运动速度。具体来说，如果第 $i$ 个旅行者向更高的区域移动，那么他需要 $a_i$ 分钟，如果旅行者向更低的区域移动，则需要 $b_i$ 分钟。你也知道，每个旅行者都会走对他们来说从小屋到山顶最快的路线，并且路线完全在地形图上，而且避开了所有的危险区域。\n\n你想知道最快的人需要多长时间才能到达山顶，有多少人将与最快的人同时爬到山顶。你可以假设，从小屋到山顶至少有一条安全的路线。", "inputFormat": "第一行三个整数 $n,m,k$，分别表示地图的大小和旅行者的数量。\n\n接下来 $n$ 行包含对地图的描述，每行由一个包含 $m$ 个字符的字符串组成，字符串中只包含 $\\texttt{.}$（点）和 $\\texttt X$，表示每个区域：\n\n- $\\texttt .$ 表示这是一个安全区域。\n- $\\texttt X$ 表示这个区域有野生动物定居，是危险的。\n\n接下来 $k$ 行描述每个旅行者。每行包含两个整数 $a_i,b_i$，分别表示第 $i$ 个旅行者向更高或更低区域移动所要花费的时间。\n\n旅店位于地图的左上角，在地图的第一行第一列。山顶在地图的右下角，在地图的第 $n$ 行第 $m$ 列。你可以假设包含旅店和山顶的区域是安全的，而且这些区域之间至少有一条只由安全区域组成的路径。", "outputFormat": "输出一行两个整数，分别表示最先到达山顶的旅行者的用时和用时等于最小用时的旅行者的数量。", "hint": "#### 样例 2 解释\n\n从旅店到山顶只有一条路径，这些旅行者的用时分别是 $13,14,13,13$。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于一些子任务满足 $k=1$。\n\n对于 $100\\%$ 的数据，保证 $2\\le n,m\\le 2\\times 10^3$，$1\\le k\\le 10^6$，$1\\le a_i,b_i\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Wycieczka górska", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 4 [Wycieczka górska](https://sio2.mimuw.edu.pl/c/pa-2020-1/wyc/)**\n\n一群 $k$ 个旅行者朋友去了 Byte 山。在最后一天，他们决定组织一场登山比赛，从他们所住的旅店到 Byte 山顶。\n\n每个旅行者都有一张区域地图，它是一个分为 $n$ 行 $m$ 列的矩形；因此地图一共包含 $n\\cdot m$ 个区域。旅店位于地图左上角的区域，而山顶则位于地图右下角的区域。Byte 山以其非常均匀而闻名——对于地图上的任何区域，在地图上与之相邻的右面或下面的区域海拔较高，而相邻的左边或上面区域海拔较低。但是，这座山也因潜伏着许多危险地区而闻名。有些地区在地图上标明是非常危险的，因为那里有野生动物居住——所以最好不要到那里去……\n\n你是 Byte 山山脚下的一个小屋的看守人。通过观察每一个旅行者，你已经为他们每个人分配了两个参数 $a_i$ 和 $b_i$，这些参数决定了他们在山坡上的运动速度。具体来说，如果第 $i$ 个旅行者向更高的区域移动，那么他需要 $a_i$ 分钟，如果旅行者向更低的区域移动，则需要 $b_i$ 分钟。你也知道，每个旅行者都会走对他们来说从小屋到山顶最快的路线，并且路线完全在地形图上，而且避开了所有的危险区域。\n\n你想知道最快的人需要多长时间才能到达山顶，有多少人将与最快的人同时爬到山顶。你可以假设，从小屋到山顶至少有一条安全的路线。", "inputFormat": "第一行三个整数 $n,m,k$，分别表示地图的大小和旅行者的数量。\n\n接下来 $n$ 行包含对地图的描述，每行由一个包含 $m$ 个字符的字符串组成，字符串中只包含 $\\texttt{.}$（点）和 $\\texttt X$，表示每个区域：\n\n- $\\texttt .$ 表示这是一个安全区域。\n- $\\texttt X$ 表示这个区域有野生动物定居，是危险的。\n\n接下来 $k$ 行描述每个旅行者。每行包含两个整数 $a_i,b_i$，分别表示第 $i$ 个旅行者向更高或更低区域移动所要花费的时间。\n\n旅店位于地图的左上角，在地图的第一行第一列。山顶在地图的右下角，在地图的第 $n$ 行第 $m$ 列。你可以假设包含旅店和山顶的区域是安全的，而且这些区域之间至少有一条只由安全区域组成的路径。", "outputFormat": "输出一行两个整数，分别表示最先到达山顶的旅行者的用时和用时等于最小用时的旅行者的数量。", "hint": "#### 样例 2 解释\n\n从旅店到山顶只有一条路径，这些旅行者的用时分别是 $13,14,13,13$。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于一些子任务满足 $k=1$。\n\n对于 $100\\%$ 的数据，保证 $2\\le n,m\\le 2\\times 10^3$，$1\\le k\\le 10^6$，$1\\le a_i,b_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P9108", "type": "P", "difficulty": 6, "samples": [["3 2 100000007", "17"], ["6 9 813443923", "57"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2020", "前缀和", "PA（波兰）"], "title": "[PA 2020] Malowanie płotu", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 4 [Malowanie płotu](https://sio2.mimuw.edu.pl/c/pa-2020-1/mal/)**\n\n今年的秋季天气已经完全破坏了 Potyczek 先生的围栏上的漆。围栏需要尽快用特殊的蓝色防水剂进行处理，以免即将到来的冬季对其造成不可弥补的破坏。Potyczek 先生请他邻居的勤劳儿子 Bytie 来做这件事。这个男孩今天早上完成了任务，但做得相当粗心，因为他急着参加下一轮 PA。\n\nPotyczek 先生的围栏由 $n$ 根木条组成，每根木条分为长度相等的 $m$ 段。Bytie 只把每根木条从上到下用防水剂涂了一遍，不幸的是，这可能还不足以把栅栏全部涂满。然而，在每根木条上涂防水剂的段都是连续的，每个段要么完全涂上，要么根本不涂。进一步看来，男孩所涂的那部分栅栏是一致的，即每两个连续的木条上所涂的段都存在一个非空的相交区间。\n\n例如，涂完的围栏可能如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2ov15dzh.png)\n\n由于以下三个原因，下图所示情况是不可能的。\n\n- 编号为 $1$ 的木条根本没涂防水剂。\n- 编号为 $3$ 的木条一致的段没有涂防水剂。\n- 编号 $5,6$ 的木条涂防水剂的部分相交区间为空。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9f315wbr.png)\n\n编写一个程序，计算 Bytie 按照上述规则可以用多少种不同的方式来涂围栏。如果有一段围栏在其中一种方式中被涂上了颜色，而在另一种方式中没有被涂上颜色，那么就称这两种方式是不同的。方法的数量可能相当多，所以只要输出它除以质数 $p$ 的余数就可以了。", "inputFormat": "输入一行三个整数 $n,m,p$。分别表示木条个数，每根木条上段的个数和质数 $p$。", "outputFormat": "输出一个整数表示 Bytie 按照上述规则给围栏涂色的方案数对 $p$ 取模后的值。", "hint": "#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\times m\\le 10^7$，$10^8\\le p\\le 10^9$，$p\\in \\mathbb{P}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Malowanie płotu", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 4 [Malowanie płotu](https://sio2.mimuw.edu.pl/c/pa-2020-1/mal/)**\n\n今年的秋季天气已经完全破坏了 Potyczek 先生的围栏上的漆。围栏需要尽快用特殊的蓝色防水剂进行处理，以免即将到来的冬季对其造成不可弥补的破坏。Potyczek 先生请他邻居的勤劳儿子 Bytie 来做这件事。这个男孩今天早上完成了任务，但做得相当粗心，因为他急着参加下一轮 PA。\n\nPotyczek 先生的围栏由 $n$ 根木条组成，每根木条分为长度相等的 $m$ 段。Bytie 只把每根木条从上到下用防水剂涂了一遍，不幸的是，这可能还不足以把栅栏全部涂满。然而，在每根木条上涂防水剂的段都是连续的，每个段要么完全涂上，要么根本不涂。进一步看来，男孩所涂的那部分栅栏是一致的，即每两个连续的木条上所涂的段都存在一个非空的相交区间。\n\n例如，涂完的围栏可能如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2ov15dzh.png)\n\n由于以下三个原因，下图所示情况是不可能的。\n\n- 编号为 $1$ 的木条根本没涂防水剂。\n- 编号为 $3$ 的木条一致的段没有涂防水剂。\n- 编号 $5,6$ 的木条涂防水剂的部分相交区间为空。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9f315wbr.png)\n\n编写一个程序，计算 Bytie 按照上述规则可以用多少种不同的方式来涂围栏。如果有一段围栏在其中一种方式中被涂上了颜色，而在另一种方式中没有被涂上颜色，那么就称这两种方式是不同的。方法的数量可能相当多，所以只要输出它除以质数 $p$ 的余数就可以了。", "inputFormat": "输入一行三个整数 $n,m,p$。分别表示木条个数，每根木条上段的个数和质数 $p$。", "outputFormat": "输出一个整数表示 Bytie 按照上述规则给围栏涂色的方案数对 $p$ 取模后的值。", "hint": "#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\times m\\le 10^7$，$10^8\\le p\\le 10^9$，$p\\in \\mathbb{P}$。", "locale": "zh-CN"}}}
{"pid": "P9109", "type": "P", "difficulty": 7, "samples": [["5 6 7\nabaab\nbabbaa\n1 5 1 6\n1 3 2 4\n2 5 2 5\n1 4 2 5\n2 5 3 6\n2 2 5 6\n3 4 2 2", "4\n2\n2\n3\n3\n0\n1"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "PA（波兰）"], "title": "[PA 2020] Tekstówka", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 4 [Tekstówka](https://sio2.mimuw.edu.pl/c/pa-2020-1/tek/)**\n\n在去年我们在某社交网络的粉丝页上进行的 PA 中，参与者大声地问我们：「题呢？」。今年，我们决定满足您的期望。\n\n给出了由英文小写字母组成的字符串 $s$ 和 $t$。令 $s_{i,j}\\ (1\\le i\\le j\\le |s|)$ 表示由 $s$ 的第 $i$ 个到第 $j$ 个（包含两端）字符依次组成的子串。我们也同样定义 $t_{i,j}$。\n\n你的任务是处理 $q$ 次查询。每次查询用四个整数 $i,j,k,l$ 表示，这里 $1\\le i\\le j\\le |s|,1\\le k\\le l\\le |t|$。对于每次查询，你需要输出子串 $s_{i,j}$ 和子串 $t_{k,l}$ 的最长公共子序列。\n\n注：一个字符串的子序列是指一个字符串通过删除一些（可能不删除）字符且不改变剩余字符顺序得到的串。例如，$\\texttt{potyczki}$ 的子串可以是 $\\texttt{tyki}$ 或 $\\texttt{pi}$，但不能是 $\\texttt{koty}$。\n\n我们称字符串 $a$ 和 $b$ 的公共子序列为既是 $a$ 的子序列，又是 $b$ 的子序列的子序列。\n\n我们称字符串 $a$ 和 $b$ 的最长公共子序列为 $a$ 和 $b$ 的子序列中最长的一个。", "inputFormat": "输入第一行包含三个整数 $n,m,q$，分别表示 $s$ 串和 $t$ 串的长度与询问次数。\n\n第二行包含一个由小写英文字母组成且长为 $n$ 的字符串 $s$。\n\n第三行包含一个由小写英文字母组成且长为 $m$ 的字符串 $t$。\n\n接下来 $q$ 行，每行四个整数 $i,j,k,l$，意义如题目描述。", "outputFormat": "输出 $q$ 行，每行一个整数，表示对询问的回答。", "hint": "#### 数据范围\n\n**本题采用捆绑测试**\n\n- 对于一些子任务，满足 $n,m,q\\le 600$；\n- 对于一些其他的子任务，满足 $n,m\\le 600$；\n- 对于一些其他的子任务，满足 $q\\le 5\\times 10^3$。\n\n对于上述情况，至少有一个子任务满足。\n\n对于 $100\\%$ 的数据，保证 $1\\le n,m\\le 3\\times 10^3$，$1\\le q\\le 10^5$，$1\\le i\\le j\\le n$，$1\\le k\\le l\\le m$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Tekstówka", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 4 [Tekstówka](https://sio2.mimuw.edu.pl/c/pa-2020-1/tek/)**\n\n在去年我们在某社交网络的粉丝页上进行的 PA 中，参与者大声地问我们：「题呢？」。今年，我们决定满足您的期望。\n\n给出了由英文小写字母组成的字符串 $s$ 和 $t$。令 $s_{i,j}\\ (1\\le i\\le j\\le |s|)$ 表示由 $s$ 的第 $i$ 个到第 $j$ 个（包含两端）字符依次组成的子串。我们也同样定义 $t_{i,j}$。\n\n你的任务是处理 $q$ 次查询。每次查询用四个整数 $i,j,k,l$ 表示，这里 $1\\le i\\le j\\le |s|,1\\le k\\le l\\le |t|$。对于每次查询，你需要输出子串 $s_{i,j}$ 和子串 $t_{k,l}$ 的最长公共子序列。\n\n注：一个字符串的子序列是指一个字符串通过删除一些（可能不删除）字符且不改变剩余字符顺序得到的串。例如，$\\texttt{potyczki}$ 的子串可以是 $\\texttt{tyki}$ 或 $\\texttt{pi}$，但不能是 $\\texttt{koty}$。\n\n我们称字符串 $a$ 和 $b$ 的公共子序列为既是 $a$ 的子序列，又是 $b$ 的子序列的子序列。\n\n我们称字符串 $a$ 和 $b$ 的最长公共子序列为 $a$ 和 $b$ 的子序列中最长的一个。", "inputFormat": "输入第一行包含三个整数 $n,m,q$，分别表示 $s$ 串和 $t$ 串的长度与询问次数。\n\n第二行包含一个由小写英文字母组成且长为 $n$ 的字符串 $s$。\n\n第三行包含一个由小写英文字母组成且长为 $m$ 的字符串 $t$。\n\n接下来 $q$ 行，每行四个整数 $i,j,k,l$，意义如题目描述。", "outputFormat": "输出 $q$ 行，每行一个整数，表示对询问的回答。", "hint": "#### 数据范围\n\n**本题采用捆绑测试**\n\n- 对于一些子任务，满足 $n,m,q\\le 600$；\n- 对于一些其他的子任务，满足 $n,m\\le 600$；\n- 对于一些其他的子任务，满足 $q\\le 5\\times 10^3$。\n\n对于上述情况，至少有一个子任务满足。\n\n对于 $100\\%$ 的数据，保证 $1\\le n,m\\le 3\\times 10^3$，$1\\le q\\le 10^5$，$1\\le i\\le j\\le n$，$1\\le k\\le l\\le m$。", "locale": "zh-CN"}}}
{"pid": "P9110", "type": "P", "difficulty": 2, "samples": [["4\n1 5 2\n2 3 0\n2 3 6\n1 7 4", "1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "PA（波兰）"], "title": "[PA 2020] Samochody dostawcze", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 3 [Samochody dostawcze](https://sio2.mimuw.edu.pl/c/pa-2020-1/sam/)**\n\nByteasar 是一家向商店运送物资的公司的后勤人员。在他公司所在的城市里，道路网由横向的街（从西到东）和纵向的道（从南到北）组成。每一对相邻的街和相邻的道都相距一公里。我们把街按从南到北的顺序编号，把道按从西到东的顺序编号。我们将第 $i$ 条道和第 $j$ 条街的交叉点记为 $(i,j)$。你可以假设，对于任何一个整数，都存在一条街的编号为 $j$ 和一条道的编号为 $i$。\n\nByteasar 明天安排了 $n$ 次送货；第 $i$ 次送货将由一辆货车在时刻 $t_i$ 离开车库，以每时间单位一公里的恒定速度沿街或道行驶。每次送货可以是两种类型中的一种：对于送货类型一，车库在路口 $(w_i,0)$，货车沿道 $w_i$ 向北行驶；对于送货类型二，车库在路口 $(0,w_i)$，货车沿街 $w_i$ 向东行驶。根据计划，每个车库在任何时刻最多只有一辆车离开。\n\n货车不必停下来——驶过收货地点时，司机只需放下要送的包裹。然而，有一个问题，如果两辆货车发现他们同一时刻在同一个十字路口，就很可能会发生碰撞。Byteasar 非常希望避免这种情况。不幸的是，他唯一能做的就是取消一些送货计划。因此，他希望取消尽可能少的送货计划，以便剩下的车中没有任何两辆车同一时刻在同一个十字路口。", "inputFormat": "第一行一个整数 $n$，表示送货计划个数。\n\n接下来 $n$ 行，每行三个整数 $r_i,w_i,t_i$，分别表示类型，车库位置和出发时间。", "outputFormat": "输出一个整数，表示最少取消的送货计划数。", "hint": "#### 样例 1 解释\n\n如果四份货物都送出，则第一和第二辆车会在时刻 $5$，在路口 $(5,3)$ 相撞。如果取消第一个送货计划，则第二和第四辆车会在时刻 $7$，在路口 $(7,3)$ 相撞。如果取消第二个送货计划，那么所有车都不会相撞了。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 5\\times 10^5$，$r_i\\in \\{1,2\\}$，$1\\le w_i\\le 10^6$，$0\\le t_i\\le 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Samochody dostawcze", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 3 [Samochody dostawcze](https://sio2.mimuw.edu.pl/c/pa-2020-1/sam/)**\n\nByteasar 是一家向商店运送物资的公司的后勤人员。在他公司所在的城市里，道路网由横向的街（从西到东）和纵向的道（从南到北）组成。每一对相邻的街和相邻的道都相距一公里。我们把街按从南到北的顺序编号，把道按从西到东的顺序编号。我们将第 $i$ 条道和第 $j$ 条街的交叉点记为 $(i,j)$。你可以假设，对于任何一个整数，都存在一条街的编号为 $j$ 和一条道的编号为 $i$。\n\nByteasar 明天安排了 $n$ 次送货；第 $i$ 次送货将由一辆货车在时刻 $t_i$ 离开车库，以每时间单位一公里的恒定速度沿街或道行驶。每次送货可以是两种类型中的一种：对于送货类型一，车库在路口 $(w_i,0)$，货车沿道 $w_i$ 向北行驶；对于送货类型二，车库在路口 $(0,w_i)$，货车沿街 $w_i$ 向东行驶。根据计划，每个车库在任何时刻最多只有一辆车离开。\n\n货车不必停下来——驶过收货地点时，司机只需放下要送的包裹。然而，有一个问题，如果两辆货车发现他们同一时刻在同一个十字路口，就很可能会发生碰撞。Byteasar 非常希望避免这种情况。不幸的是，他唯一能做的就是取消一些送货计划。因此，他希望取消尽可能少的送货计划，以便剩下的车中没有任何两辆车同一时刻在同一个十字路口。", "inputFormat": "第一行一个整数 $n$，表示送货计划个数。\n\n接下来 $n$ 行，每行三个整数 $r_i,w_i,t_i$，分别表示类型，车库位置和出发时间。", "outputFormat": "输出一个整数，表示最少取消的送货计划数。", "hint": "#### 样例 1 解释\n\n如果四份货物都送出，则第一和第二辆车会在时刻 $5$，在路口 $(5,3)$ 相撞。如果取消第一个送货计划，则第二和第四辆车会在时刻 $7$，在路口 $(7,3)$ 相撞。如果取消第二个送货计划，那么所有车都不会相撞了。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 5\\times 10^5$，$r_i\\in \\{1,2\\}$，$1\\le w_i\\le 10^6$，$0\\le t_i\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P9111", "type": "P", "difficulty": 6, "samples": [["4\n1 10 3 5\n1 2 3\n", "52\n"], ["4\n1 -2 5 5\n1 2 2\n", "27\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "福建", "O2优化", "背包 DP", "树形 DP"], "title": "[福建省队集训2019] 最大权独立集问题", "background": "", "description": "E.Space 喜欢出最大权独立集问题。\n\n接下来，他还想出 $n$ 道最大权独立集问题。\n\nE.Space 有 $n$ 个 AI，编号为 $1\\sim n$。\n\n开始第 $i$ 个 AI 里面存有一道 E.Space 事先出好的一道难度为 $d_i$ 的最大权独立集问题。\n\n有些 AI 之间可以互相通信，对于所有的 $2 \\le i \\le n$，第 $i$ 个 AI 可以和第 $c_i$ 个 AI 互相通信。此外，其他对 AI 不可以互相通信。\n\nE.Space 每次可以选择一个存有一道最大权独立集问题的 AI，把存在里面的题出出来，然后清除存在这个 AI 里的题。\n\n在 E.Space 出题之后清除题目之前，AI 会把这道题发给能和它通信的所有 AI。\n\n如果一个收到这道题的 AI 中已经存有一道最大权独立集问题，那么这个 AI 会把这个收到的题和原本存有的题结合起来，变成一道新的最大权独立集问题存起来。形式化地，如果这个 AI 原来存了一道难度为 $x$ 的最大权独立集问题，接着收到了一道难度为 $y$ 的最大权独立集问题，那么结合之后是一道难度为 $x+y$ 的最大权独立集问题。\n\n如果一个收到题的 AI 中未存有题，那么这个 AI 会销毁收到的这个信息。\n\n由于出题人的丧病心理，E.Space 想要出出来的 $n$ 道最大权独立集问题的难度之和尽量大。\n\n他想叫你帮他解决这个问题，还说如果你成功在这场训练中解决了这个问题，那么在出那 $n$ 道最大权独立集问题的时候，他会在训练结束前 10 分钟切换至你的账号然后提交一份标程代码。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个整数，第 $i$ 个表示 $d_i$。\n\n第三行 $n-1$ 个整数，第 $i$ 个表示 $c_{i+1}$。", "outputFormat": "一行一个整数，表示最大的难度之和。", "hint": "### 【样例解释 1】\n\n一种最优的出题方案如下：\n\n1. 出第 $2$ 个 AI 中的最大权独立集问题，此时该题难度为 $10$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $11,*,13,5$ ($*$ 表示该 AI 中没有最大权独立集问题，下同)。\n\n2. 出第 $3$ 个 AI 中的最大权独立集问题，此时该题难度为 $13$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $11,*,*,18$。\n\n3. 出第 $1$ 个 AI 中的最大权独立集问题，此时该题难度为 $11$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,18$。\n\n4. 出第 $4$ 个 AI 中的最大权独立集问题，此时该题难度为 $18$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,*$。\n\n所以 $4$ 道题的难度之和为 $10+13+11+18=52$。\n\n### 【样例解释 2】\n\n一种最优的出题方案如下：\n\n1. 出第 $3$ 个 AI 中的最大权独立集问题，此时该题难度为 $5$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $1,3,*,5$。\n\n2. 出第 $4$ 个 AI 中的最大权独立集问题，此时该题难度为 $5$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $1,8,*,*$。\n\n3. 出第 $2$ 个 AI 中的最大权独立集问题，此时该题难度为 $8$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $9,*,*,*$。\n\n4. 出第 $1$ 个 AI 中的最大权独立集问题，此时该题难度为 $9$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,*$。\n\n所以 $4$ 道题的难度之和为 $5+5+8+9=27$。\n\n### 【数据范围】\n\n保证 $\\left|d_i\\right| \\le 10^9$，$1 \\le c_i \\lt i$，$1\\le n \\le 400$。\n\n**本题采用捆绑测试。**\n\n对于编号为奇数的子任务，保证 $d_i \\ge 0$。\n\n子任务 $1,2$（$11 \\times 2 = 22$ 分）：\n$n \\le 9$。\n\n子任务 $3,4$（$10 \\times 2 = 20$ 分）：\n$n \\le 19$。\n\n子任务 $5,6$（$7 \\times 2 = 14$ 分）：\n$n \\le 50$，$c_i = i-1$。\n\n子任务 $7,8$（$10 \\times 2 = 20$ 分）：\n$c_i=i-1$。\n\n子任务 $9,10$（$5 \\times 2 = 10$ 分）：\n$n \\le 50$。\n\n子任务 $11,12$（$7 \\times 2 = 14$ 分）：\n无特殊限制。\n\n### 后记\n\n听说 E.Space 的最大权独立集问题的难度是取了对数的？\n\n听说 E.Space 要把这 $n$ 道题结合成一道题出出来？\n\n听说 E.Space 不会把这些题出在训练里面？\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[福建省队集训2019] 最大权独立集问题", "background": "", "description": "E.Space 喜欢出最大权独立集问题。\n\n接下来，他还想出 $n$ 道最大权独立集问题。\n\nE.Space 有 $n$ 个 AI，编号为 $1\\sim n$。\n\n开始第 $i$ 个 AI 里面存有一道 E.Space 事先出好的一道难度为 $d_i$ 的最大权独立集问题。\n\n有些 AI 之间可以互相通信，对于所有的 $2 \\le i \\le n$，第 $i$ 个 AI 可以和第 $c_i$ 个 AI 互相通信。此外，其他对 AI 不可以互相通信。\n\nE.Space 每次可以选择一个存有一道最大权独立集问题的 AI，把存在里面的题出出来，然后清除存在这个 AI 里的题。\n\n在 E.Space 出题之后清除题目之前，AI 会把这道题发给能和它通信的所有 AI。\n\n如果一个收到这道题的 AI 中已经存有一道最大权独立集问题，那么这个 AI 会把这个收到的题和原本存有的题结合起来，变成一道新的最大权独立集问题存起来。形式化地，如果这个 AI 原来存了一道难度为 $x$ 的最大权独立集问题，接着收到了一道难度为 $y$ 的最大权独立集问题，那么结合之后是一道难度为 $x+y$ 的最大权独立集问题。\n\n如果一个收到题的 AI 中未存有题，那么这个 AI 会销毁收到的这个信息。\n\n由于出题人的丧病心理，E.Space 想要出出来的 $n$ 道最大权独立集问题的难度之和尽量大。\n\n他想叫你帮他解决这个问题，还说如果你成功在这场训练中解决了这个问题，那么在出那 $n$ 道最大权独立集问题的时候，他会在训练结束前 10 分钟切换至你的账号然后提交一份标程代码。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个整数，第 $i$ 个表示 $d_i$。\n\n第三行 $n-1$ 个整数，第 $i$ 个表示 $c_{i+1}$。", "outputFormat": "一行一个整数，表示最大的难度之和。", "hint": "### 【样例解释 1】\n\n一种最优的出题方案如下：\n\n1. 出第 $2$ 个 AI 中的最大权独立集问题，此时该题难度为 $10$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $11,*,13,5$ ($*$ 表示该 AI 中没有最大权独立集问题，下同)。\n\n2. 出第 $3$ 个 AI 中的最大权独立集问题，此时该题难度为 $13$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $11,*,*,18$。\n\n3. 出第 $1$ 个 AI 中的最大权独立集问题，此时该题难度为 $11$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,18$。\n\n4. 出第 $4$ 个 AI 中的最大权独立集问题，此时该题难度为 $18$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,*$。\n\n所以 $4$ 道题的难度之和为 $10+13+11+18=52$。\n\n### 【样例解释 2】\n\n一种最优的出题方案如下：\n\n1. 出第 $3$ 个 AI 中的最大权独立集问题，此时该题难度为 $5$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $1,3,*,5$。\n\n2. 出第 $4$ 个 AI 中的最大权独立集问题，此时该题难度为 $5$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $1,8,*,*$。\n\n3. 出第 $2$ 个 AI 中的最大权独立集问题，此时该题难度为 $8$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $9,*,*,*$。\n\n4. 出第 $1$ 个 AI 中的最大权独立集问题，此时该题难度为 $9$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,*$。\n\n所以 $4$ 道题的难度之和为 $5+5+8+9=27$。\n\n### 【数据范围】\n\n保证 $\\left|d_i\\right| \\le 10^9$，$1 \\le c_i \\lt i$，$1\\le n \\le 400$。\n\n**本题采用捆绑测试。**\n\n对于编号为奇数的子任务，保证 $d_i \\ge 0$。\n\n子任务 $1,2$（$11 \\times 2 = 22$ 分）：\n$n \\le 9$。\n\n子任务 $3,4$（$10 \\times 2 = 20$ 分）：\n$n \\le 19$。\n\n子任务 $5,6$（$7 \\times 2 = 14$ 分）：\n$n \\le 50$，$c_i = i-1$。\n\n子任务 $7,8$（$10 \\times 2 = 20$ 分）：\n$c_i=i-1$。\n\n子任务 $9,10$（$5 \\times 2 = 10$ 分）：\n$n \\le 50$。\n\n子任务 $11,12$（$7 \\times 2 = 14$ 分）：\n无特殊限制。\n\n### 后记\n\n听说 E.Space 的最大权独立集问题的难度是取了对数的？\n\n听说 E.Space 要把这 $n$ 道题结合成一道题出出来？\n\n听说 E.Space 不会把这些题出在训练里面？\n\n", "locale": "zh-CN"}}}
{"pid": "P9112", "type": "P", "difficulty": 7, "samples": [["4 8\n7\n4\n2\n6\n5\n8\n1\n3\n", "3\n"], ["4 9\n2\n1\n5\n8\n3\n4\n7\n6\n", "2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2009", "IOI", "O2优化"], "title": "[IOI 2009] Archery", "background": "IOI2009 D1T1", "description": "一场箭术比赛正在举行。一条直线上排着 $N$ 个靶子，靶子从左到右依次标号为从 $1$ 到 $N$。有 $2N$ 个选手，在比赛的任何时刻，同一个靶位上都有两个选手。比赛的每一轮按照如下规则进行：\n\n- 在同一个靶位的两位选手比赛一场决出胜者，然后所有选手按照如下规则移动：\n\n  - 在 $2$ 到 $N$ 号靶位上的胜者移动到他们的左侧的靶位（即分别移动到 $1\\sim N - 1$ 号靶位）。\n  - 在 $2$ 到 $N$ 号靶位上的负者，以及 $1$ 号靶位上的胜者，停留在同一个靶位。\n  - $1$ 号靶位上的负者移动到 $N$ 号靶位。\n\n比赛一共持续 $R$ 轮，轮数至少为参赛选手的数量，即 $R\\geq 2N$。\n\n你是唯一一个准时到达的选手。其它 $2N - 1$ 个选手已经提前到达并站成了一排，你现在要做的就是插入这个队伍。在你进入队伍后，队列中前两个选手（最左侧的两个选手）将对应一号靶位，接下来两个选手将对应二号靶位，以此类推，最右侧的两个选手对应 $N$ 号靶位。\n\n所有 $2N$ 个选手（包括你）都用一个数值衡量技术水平，没有两个选手的技术水平相同。在同一个靶位上，数值较小的选手会成为胜者。\n\n在了解了所有选手的技术水平之后，你需要找到一个位置插入使得你最终对应的靶位序号尽量小，在此前提下，你希望你初始时对应的靶位序号尽量大。\n\n**任务**：编写一个程序，给定所有选手的技术水平（包括你自己）和你的对手们的排列顺序，计算出你的初始靶位编号，以满足你的上述目标。", "inputFormat": "第一行包含两个由空格隔开的整数 $N, R$，分别表示靶位数和比赛轮数。\n\n接下来 $2N$ 行给出选手的排列 $S_1, S_2, \\cdots,  S_{2N}$。$S_1$ 表示你的排名，$S_2, S_3, \\cdots, S_{2N}$ 表示其他选手的排名，依照他们已经排列好的顺序（由左至右）。$S_k$ 是 $1\\sim 2N$ 的整数，排名 $1$ 表示最好，排名 $2N$ 表示最差。没有两位选手的排名相同。", "outputFormat": "输出一个 $1\\sim N$ 的整数，表示开始的箭靶编号。", "hint": "### 样例解释\n\n- 样例 1：你是排名倒数第二的选手。如果你从靶 $1$ 开始比赛，接下来你将移动到靶 $4$ 而且一直留在靶 $4$ 直到最后。如果你从靶 $2$ 或靶 $4$ 开始，你将会一直留到最后。如果你从靶 $3$ 开始，你将会击败最差的选手，然后移到靶 $2$ 并留在那里。\n\n- 样例 2：你是排名第二的选手。排名第一的选手在靶 $1$ 并一直留在那里。因此，无论你从哪里出发，你永远会按 $4\\to 3\\to 2\\to 1\\to 4$ 的顺序循环移动。为了最终留在靶 $1$，你应该从靶 $2$ 开始。\n\n### 数据范围与约定\n\n- 对于 $20\\%$ 的数据，$N\\leq 200$。\n- 对于 $60\\%$ 的数据，$N\\leq 5000$。\n- 对于 $100\\%$ 的数据，$1\\leq N\\leq 2\\times 10 ^ 5$，$2N\\leq R\\leq 10 ^ 9$，$1\\leq S_k\\leq 2N$ 且 $S_k$ 互不相同。\n\n另有三组 @[asmend](https://www.luogu.com.cn/user/21658) 提供的 hack 数据，不计分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2009] Archery", "background": "IOI2009 D1T1", "description": "一场箭术比赛正在举行。一条直线上排着 $N$ 个靶子，靶子从左到右依次标号为从 $1$ 到 $N$。有 $2N$ 个选手，在比赛的任何时刻，同一个靶位上都有两个选手。比赛的每一轮按照如下规则进行：\n\n- 在同一个靶位的两位选手比赛一场决出胜者，然后所有选手按照如下规则移动：\n\n  - 在 $2$ 到 $N$ 号靶位上的胜者移动到他们的左侧的靶位（即分别移动到 $1\\sim N - 1$ 号靶位）。\n  - 在 $2$ 到 $N$ 号靶位上的负者，以及 $1$ 号靶位上的胜者，停留在同一个靶位。\n  - $1$ 号靶位上的负者移动到 $N$ 号靶位。\n\n比赛一共持续 $R$ 轮，轮数至少为参赛选手的数量，即 $R\\geq 2N$。\n\n你是唯一一个准时到达的选手。其它 $2N - 1$ 个选手已经提前到达并站成了一排，你现在要做的就是插入这个队伍。在你进入队伍后，队列中前两个选手（最左侧的两个选手）将对应一号靶位，接下来两个选手将对应二号靶位，以此类推，最右侧的两个选手对应 $N$ 号靶位。\n\n所有 $2N$ 个选手（包括你）都用一个数值衡量技术水平，没有两个选手的技术水平相同。在同一个靶位上，数值较小的选手会成为胜者。\n\n在了解了所有选手的技术水平之后，你需要找到一个位置插入使得你最终对应的靶位序号尽量小，在此前提下，你希望你初始时对应的靶位序号尽量大。\n\n**任务**：编写一个程序，给定所有选手的技术水平（包括你自己）和你的对手们的排列顺序，计算出你的初始靶位编号，以满足你的上述目标。", "inputFormat": "第一行包含两个由空格隔开的整数 $N, R$，分别表示靶位数和比赛轮数。\n\n接下来 $2N$ 行给出选手的排列 $S_1, S_2, \\cdots,  S_{2N}$。$S_1$ 表示你的排名，$S_2, S_3, \\cdots, S_{2N}$ 表示其他选手的排名，依照他们已经排列好的顺序（由左至右）。$S_k$ 是 $1\\sim 2N$ 的整数，排名 $1$ 表示最好，排名 $2N$ 表示最差。没有两位选手的排名相同。", "outputFormat": "输出一个 $1\\sim N$ 的整数，表示开始的箭靶编号。", "hint": "### 样例解释\n\n- 样例 1：你是排名倒数第二的选手。如果你从靶 $1$ 开始比赛，接下来你将移动到靶 $4$ 而且一直留在靶 $4$ 直到最后。如果你从靶 $2$ 或靶 $4$ 开始，你将会一直留到最后。如果你从靶 $3$ 开始，你将会击败最差的选手，然后移到靶 $2$ 并留在那里。\n\n- 样例 2：你是排名第二的选手。排名第一的选手在靶 $1$ 并一直留在那里。因此，无论你从哪里出发，你永远会按 $4\\to 3\\to 2\\to 1\\to 4$ 的顺序循环移动。为了最终留在靶 $1$，你应该从靶 $2$ 开始。\n\n### 数据范围与约定\n\n- 对于 $20\\%$ 的数据，$N\\leq 200$。\n- 对于 $60\\%$ 的数据，$N\\leq 5000$。\n- 对于 $100\\%$ 的数据，$1\\leq N\\leq 2\\times 10 ^ 5$，$2N\\leq R\\leq 10 ^ 9$，$1\\leq S_k\\leq 2N$ 且 $S_k$ 互不相同。\n\n另有三组 @[asmend](https://www.luogu.com.cn/user/21658) 提供的 hack 数据，不计分。", "locale": "zh-CN"}}}
