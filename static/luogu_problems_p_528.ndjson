{"pid": "P11718", "type": "P", "difficulty": 6, "samples": [["3\n3\n/user/:id/show\nuserShow\n/message/list\nmessageList\n/message/:id/show\nmessageShow\nid [0-9]{2,4}\n3\n/message/list\n/user/123/show?avatar=true\n/message/5312/show?page=1\n1\n/foo/:id/:bar/:bar\nfun\nid [0-9]{2,4}\nbar [a-z]{1,3}\n1\n/foo/777/az/bc?bar=xyz&bar=zzz\n2\n/user/:handle/show\nuserShow\n/user/:id/show\nuserShow\nid [0-9]{2,4}\nhandle ([a-z]|[A-Z])([a-z]|[A-Z]|[0-9]){4,10}\n4\n/user/259/show\n/user/wjmzbmr/show?like=true\n/user/0xxx/show\n/user/WJMZBMR/show?love=true", "Case #1:\nRequest matches action \"messageList\" with parameters {}\nRequest matches action \"userShow\" with parameters {\"avatar\":\"true\",\"id\":\"123\"}\nRequest matches action \"messageShow\" with parameters {\"id\":\"5312\",\"page\":\"1\"}\nCase #2:\nRequest matches action \"fun\" with parameters {\"bar\":[\"az\",\"bc\",\"xyz\",\"zzz\"],\"id\":\"777\"}\nCase #3:\nRequest matches action \"userShow\" with parameters {\"id\":\"259\"}\nRequest matches action \"userShow\" with parameters {\"handle\":\"wjmzbmr\",\"like\":\"true\"}\n404 Not Found\nRequest matches action \"userShow\" with parameters {\"handle\":\"WJMZBMR\",\"love\":\"true\"}"]], "limits": {"time": [20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "CTT（清华集训/北大集训）"], "title": "[清华集训 2014] Router", "background": null, "description": "在进行 Web 后端开发时，很重要的一个组件是 router。通常来说，后端的代码由许多 action 组成，router 的作用就是将发来的请求按照 URL 对应到相应的 action 上。\n\n请求到达后端 Web 服务器时，已经不需要考虑域名和端口了，因此一个请求有如下形式：\n\n`/{something_1}/{something_2}/.../{something_k}` 或 `/{something_1}/{something_2}/.../{something_k}?{parameter_list}`\n\n其中 parameter_list 的组成为：`{name_1}={value_1}&{name_2}={value_2}&...&{name_n}={value_n}`。（第一种情况中的 `parameter_list` 为空）\n\n例如 `/user/list/show?gender=male&birthyear=1990` 就是一个合法的请求，其中包含了两个参数 gender 和 birthyear，对应的 value 分别是 male 和 1990。\n\nrouter 由许多条 path 组成，每一个 path 会对应到一个 action 上。router 在匹配 URL 到 path 时只看 parameter_list 之前的部分，例如之前的请求就只看 `/user/list/show` 这部分。parameter_list 内的参数会被直接送到 action 中。因此一个 path 总是具有如下形式：\n\n`/{something_1}/{something_2}/.../{something_k}`\n\n为了使得 router 更灵活，每一段中的 something 除了可以用具体的字符串外，还可以用一个正则表达式去匹配，并且提取出这部分的内容作为参数送到 action 去。这种情况下，something 的内容为 `:{regexp_name}`，其中 regexp_name 对应一个正则表达式，会在后面给出具体的表达式。例如 router 中的一个 path 为 `/user/:handle/show`，其中`:handle` 对应了一个正则表达式，假设它可以匹配所有由小写英文字母组成的非空串。此时请求 `/user/testuser/show` 就能匹配这个 path，并且送往 action 多了一个 name 为 handle、value 为 testuser 的参数。再例如请求为 `/user/testuser/show?avatar=true&message=hello` 的话，不仅能匹配之前的 path，送到 action 的参数就会有三个：handle、avatar、message，对应的 value 分别为 testuser、true 和 hello。\n\n但是使用带正则表达式的 path 时也受到一些限制。具体来说，如果有 router 中有两个 path，他们前面 $i$ 个 something 段的内容完全相同（这 $i$ 段里面可以含正则表达式项，此时就要求是名称相同的正则表达式），然后第 $i+1$ 个 something 段的内容不同。下面分两种情况：\n\n1. 一个 path 这一段的内容是普通字符串，另一个 path 这一段的内容对应了正则表达式，那么这个正则表达式一定无法匹配前一个 path 第 $i+1$ 段的字符串。例如一个 path 是 `/foo/:tmp/bar/pop`，另一个 path 是 `/foo/:tmp/:exp/push`，那么 exp 对应的正则表达式一定不会匹配 bar。\n2. 两个 path 这一段的内容都是正则表达式，那么这两个正则表达式匹配的字符串一定没有交集。例如一个 path 是 `/foo/:tmp/:aaa/push`，另一个 path 是 `/foo/:tmp/:bbb/pop`，那么不存在一个字符串能同时被 aaa 对应的正则表达式和 bbb 对应的正则表达式匹配。\n\n最后介绍正则表达式。为了让情况简单一些，本题中的正则表达式规则相比于实际使用的有所简化。正则表达式的文法中有 Atom、Quantifier、Term、Alternative 这几个概念。用 Regexp 表示正则表达式，则每种概念具体为：\n\n1. Regexp 可以由单个 Alternative 组成，或者由一个 Alternative 和一个 Regexp 组成，中间用字符 `|` 连接。对于前一种情况，该正则表达式匹配所有 Alternative 能匹配的东西。对于后一种情况，一个字符串要能被该正则表达式匹配，要么能被 `|` 前面的 Alternative 能匹配，要么能被 `|` 后面的 Regexp 所匹配。\n2. Alternative 由单个 Term 或多个 Term 连接组成，它能匹配这些 Term 所匹配的字符串的连接。换言之，一个字符串要被这个 Alternative 匹配，这个字符串能够拆成若干段（段数和 Alternative 的 Term 个数一样多），每段依次被 Alternative 的每个 Term 匹配。\n3. Term 由一个 Atom 或一个 Atom 附带一个 Quantifier 组成。后面会了解到，Quantifier 对应了允许重复次数的区间。若 Term 由单个 Atom 组成，则 Term 能匹配的内容与 Atom 相同。如果 Atom 后带了 Quantifier，则如果一个字符串能划分为若干段（划分的段数在 Quantifier 指定的区间内），使得每段都能被 Atom 匹配，那么这个字符串就能被这个 Term 匹配。\n4. Quantifier 的形式为 `{lower_bound,upper_bound}`，其中 lower\\_bound 和 upper\\_bound 各对应一个不超过 $20$ 的非负整数，并且 $\\text{upper\\_bound} \\geq \\text{lower\\_bound}$，Quantifier 对应的区间为闭区间 $[\\text{lower\\_bound}, \\text{upper\\_bound}]$。注意 upper\\_bound 可以为空（此时中间的逗号还是有的），upper\\_bound 为空表示上界为无穷大。`{1,3}`, `{0,1}`, `{2,2}`, `{3,}` 均为合法的 Quantifier，但 `{3,2}`, `{,1}` 就不合法。\n5. Atom 有三种形式：第一种为单个字符，这里字符约定只能是英文字符（包括大写和小写）和数字，这种形式下的 Atom 所能匹配的内容就是该字符。第二种形式为字符区间，具体形式为 `[lower-upper]`，这里 lower 和 upper 各为单个字符，满足要么同时为小写英文字母、要么同时为大写字母、要么同时为数字，并且 lower 的ASCII码不小于 upper 的ASCII码，这种情况下的 Atom 所能匹配的内容就是这个区间内的字符（包括 lower 和 upper）。第三种形式是 `(Regexp)`，即一个合法的正则表达式套上一对括号，这种情况下该 Atom 能匹配的内容和括号内的正则表达式相同。\n\n根据以上文法，`[0-9]{1,3}` 为合法的正则表达式，它能匹配长度为 $1 \\sim 3$ 且由数字组成的字符串。`([a-z]|[0-9]){3,10}` 也为合法的正则表达式，它能匹配长度为 $3 \\sim 10$ 且由小写英文字母和数字组成的字符串。更复杂的一个例子为 `01[0-1]{0,}|10[0-1]{0,}`，它能匹配所有 `01` 或 `10` 开头的 `01` 字符串。", "inputFormat": "第一个一个正整数 $T$，表示数据的组数。下面依次给出每组数据。\n\n每组数据的第一行包含一个正整数 $N$，表示 router 中有 $N$ 个 path。下面 $2N$ 行，每两行描述一个 path，第一行为 path 匹配的 URL，形式为\n\n`/{something_1}/{something_2}/.../{something_k}`\n\n每段 something 要么为具体的字符串（由大写英文字母、小写英文字母和数字组成且长度在 $[1,50]$ 内），要么为 `:{regexp_name}`，其中 regexp_name 由大写和小写英文字母组成且长度不超过 $30$。具体的正则表达式会在之后的输入中给出。描述该 path 的第二行为对应的 action 名称（由大写和小写英文字母组成，长度在 $[1,30]$ 内）。\n\n下面若干行描述前面 path 中出现的所有正则表达式，每行描述一个正则表达式，每行内包含两个非空字符串（由一个空格隔开），前面的字符串表示 regexp_name，后面的字符串表示对应正则表达式（长度不超过 $50$）。注意同一个 regexp_name 可能在前面给出的 path 中出现多次（一个 path 中出现多次或在不同 path 中出现），这种情况下他们对应的正则表达式是相同的，并且输入中只会描述一次。数据同时保证这里给出的 regexp_name 都至少在一个 path 中出现过。\n\n下面一行包含一个正整数 $M$，表示有 $M$ 个请求发了过来。下面 $M$ 行，每行描述一个请求的 URL。URL 为 `/{something_1}/{something_2}/.../{something_k}` 或 `/{something_1}/{something_2}/.../{something_k}?{name_1}={value_1}&{name_2}={value_2}&...&{name_n}={value_n}` 的形式，其中所有 something 和 value 都由大写英文字母、小写英文字母和数字组成且长度在 $[1,50]$ 内，所有 name 都由大写和小写英文字母组成且长度在 $[1,30]$ 内。", "outputFormat": "对于每组数据，先单独一行输出 `Case #{case_no}:`（不含引号），其中 case_no 表示当前是第几组数据（从 $1$ 开始编号）。\n\n每行输出依次对应每个请求。如果没有 path 能够匹配该请求的 URL，输出 `404 Not Found`。\n\n如果有 path 能够匹配改请求，输出 `Request matches action \"{action_name}\" with parameters {parameter_list}`，其中 action_name 为匹配 path 对应 action 的名称，parameter_list 为所有的参数。\n\n* 其中 parameter_list 用一个字典的方式输出。例如有三个参数，他们的 name 为 avatar、message 和 page，对应的 value 分别为 true、hello 和 2，那么输出的 parameter_list 为 `{\"avatar\":\"true\",\"message\":\"hello\",\"page\":\"2\"}`（所有参数按照 name 的字典序排列）。\n* 注意一个请求中，拥有相同 name 的参数可能出现多次，例如请求的 URL 为 `/user/me/show?name=you&name=he”，匹配的 path 为 “/user/:name/show`，此时的 parameter_list 为 `{\"name\":[\"me\",\"you\",\"he\"]}`。方括号里面按照参数在请求 URL 中出现的次序给出。\n* 更多具体的例子请参考样例。数据能够保证一个请求不会被多个 path 匹配。", "hint": "对于 30% 的数据，path 中不会出现正则表达式；\n\n对于 100% 的数据，$N, M \\leq 20000$，$T \\leq 5$，输入文件大小不超过 $10\\texttt{MB}$。不同名称的正则表达式最多有 $50$ 个。\n\n**注意此题数据是良心数据。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2014] Router", "background": null, "description": "在进行 Web 后端开发时，很重要的一个组件是 router。通常来说，后端的代码由许多 action 组成，router 的作用就是将发来的请求按照 URL 对应到相应的 action 上。\n\n请求到达后端 Web 服务器时，已经不需要考虑域名和端口了，因此一个请求有如下形式：\n\n`/{something_1}/{something_2}/.../{something_k}` 或 `/{something_1}/{something_2}/.../{something_k}?{parameter_list}`\n\n其中 parameter_list 的组成为：`{name_1}={value_1}&{name_2}={value_2}&...&{name_n}={value_n}`。（第一种情况中的 `parameter_list` 为空）\n\n例如 `/user/list/show?gender=male&birthyear=1990` 就是一个合法的请求，其中包含了两个参数 gender 和 birthyear，对应的 value 分别是 male 和 1990。\n\nrouter 由许多条 path 组成，每一个 path 会对应到一个 action 上。router 在匹配 URL 到 path 时只看 parameter_list 之前的部分，例如之前的请求就只看 `/user/list/show` 这部分。parameter_list 内的参数会被直接送到 action 中。因此一个 path 总是具有如下形式：\n\n`/{something_1}/{something_2}/.../{something_k}`\n\n为了使得 router 更灵活，每一段中的 something 除了可以用具体的字符串外，还可以用一个正则表达式去匹配，并且提取出这部分的内容作为参数送到 action 去。这种情况下，something 的内容为 `:{regexp_name}`，其中 regexp_name 对应一个正则表达式，会在后面给出具体的表达式。例如 router 中的一个 path 为 `/user/:handle/show`，其中`:handle` 对应了一个正则表达式，假设它可以匹配所有由小写英文字母组成的非空串。此时请求 `/user/testuser/show` 就能匹配这个 path，并且送往 action 多了一个 name 为 handle、value 为 testuser 的参数。再例如请求为 `/user/testuser/show?avatar=true&message=hello` 的话，不仅能匹配之前的 path，送到 action 的参数就会有三个：handle、avatar、message，对应的 value 分别为 testuser、true 和 hello。\n\n但是使用带正则表达式的 path 时也受到一些限制。具体来说，如果有 router 中有两个 path，他们前面 $i$ 个 something 段的内容完全相同（这 $i$ 段里面可以含正则表达式项，此时就要求是名称相同的正则表达式），然后第 $i+1$ 个 something 段的内容不同。下面分两种情况：\n\n1. 一个 path 这一段的内容是普通字符串，另一个 path 这一段的内容对应了正则表达式，那么这个正则表达式一定无法匹配前一个 path 第 $i+1$ 段的字符串。例如一个 path 是 `/foo/:tmp/bar/pop`，另一个 path 是 `/foo/:tmp/:exp/push`，那么 exp 对应的正则表达式一定不会匹配 bar。\n2. 两个 path 这一段的内容都是正则表达式，那么这两个正则表达式匹配的字符串一定没有交集。例如一个 path 是 `/foo/:tmp/:aaa/push`，另一个 path 是 `/foo/:tmp/:bbb/pop`，那么不存在一个字符串能同时被 aaa 对应的正则表达式和 bbb 对应的正则表达式匹配。\n\n最后介绍正则表达式。为了让情况简单一些，本题中的正则表达式规则相比于实际使用的有所简化。正则表达式的文法中有 Atom、Quantifier、Term、Alternative 这几个概念。用 Regexp 表示正则表达式，则每种概念具体为：\n\n1. Regexp 可以由单个 Alternative 组成，或者由一个 Alternative 和一个 Regexp 组成，中间用字符 `|` 连接。对于前一种情况，该正则表达式匹配所有 Alternative 能匹配的东西。对于后一种情况，一个字符串要能被该正则表达式匹配，要么能被 `|` 前面的 Alternative 能匹配，要么能被 `|` 后面的 Regexp 所匹配。\n2. Alternative 由单个 Term 或多个 Term 连接组成，它能匹配这些 Term 所匹配的字符串的连接。换言之，一个字符串要被这个 Alternative 匹配，这个字符串能够拆成若干段（段数和 Alternative 的 Term 个数一样多），每段依次被 Alternative 的每个 Term 匹配。\n3. Term 由一个 Atom 或一个 Atom 附带一个 Quantifier 组成。后面会了解到，Quantifier 对应了允许重复次数的区间。若 Term 由单个 Atom 组成，则 Term 能匹配的内容与 Atom 相同。如果 Atom 后带了 Quantifier，则如果一个字符串能划分为若干段（划分的段数在 Quantifier 指定的区间内），使得每段都能被 Atom 匹配，那么这个字符串就能被这个 Term 匹配。\n4. Quantifier 的形式为 `{lower_bound,upper_bound}`，其中 lower\\_bound 和 upper\\_bound 各对应一个不超过 $20$ 的非负整数，并且 $\\text{upper\\_bound} \\geq \\text{lower\\_bound}$，Quantifier 对应的区间为闭区间 $[\\text{lower\\_bound}, \\text{upper\\_bound}]$。注意 upper\\_bound 可以为空（此时中间的逗号还是有的），upper\\_bound 为空表示上界为无穷大。`{1,3}`, `{0,1}`, `{2,2}`, `{3,}` 均为合法的 Quantifier，但 `{3,2}`, `{,1}` 就不合法。\n5. Atom 有三种形式：第一种为单个字符，这里字符约定只能是英文字符（包括大写和小写）和数字，这种形式下的 Atom 所能匹配的内容就是该字符。第二种形式为字符区间，具体形式为 `[lower-upper]`，这里 lower 和 upper 各为单个字符，满足要么同时为小写英文字母、要么同时为大写字母、要么同时为数字，并且 lower 的ASCII码不小于 upper 的ASCII码，这种情况下的 Atom 所能匹配的内容就是这个区间内的字符（包括 lower 和 upper）。第三种形式是 `(Regexp)`，即一个合法的正则表达式套上一对括号，这种情况下该 Atom 能匹配的内容和括号内的正则表达式相同。\n\n根据以上文法，`[0-9]{1,3}` 为合法的正则表达式，它能匹配长度为 $1 \\sim 3$ 且由数字组成的字符串。`([a-z]|[0-9]){3,10}` 也为合法的正则表达式，它能匹配长度为 $3 \\sim 10$ 且由小写英文字母和数字组成的字符串。更复杂的一个例子为 `01[0-1]{0,}|10[0-1]{0,}`，它能匹配所有 `01` 或 `10` 开头的 `01` 字符串。", "inputFormat": "第一个一个正整数 $T$，表示数据的组数。下面依次给出每组数据。\n\n每组数据的第一行包含一个正整数 $N$，表示 router 中有 $N$ 个 path。下面 $2N$ 行，每两行描述一个 path，第一行为 path 匹配的 URL，形式为\n\n`/{something_1}/{something_2}/.../{something_k}`\n\n每段 something 要么为具体的字符串（由大写英文字母、小写英文字母和数字组成且长度在 $[1,50]$ 内），要么为 `:{regexp_name}`，其中 regexp_name 由大写和小写英文字母组成且长度不超过 $30$。具体的正则表达式会在之后的输入中给出。描述该 path 的第二行为对应的 action 名称（由大写和小写英文字母组成，长度在 $[1,30]$ 内）。\n\n下面若干行描述前面 path 中出现的所有正则表达式，每行描述一个正则表达式，每行内包含两个非空字符串（由一个空格隔开），前面的字符串表示 regexp_name，后面的字符串表示对应正则表达式（长度不超过 $50$）。注意同一个 regexp_name 可能在前面给出的 path 中出现多次（一个 path 中出现多次或在不同 path 中出现），这种情况下他们对应的正则表达式是相同的，并且输入中只会描述一次。数据同时保证这里给出的 regexp_name 都至少在一个 path 中出现过。\n\n下面一行包含一个正整数 $M$，表示有 $M$ 个请求发了过来。下面 $M$ 行，每行描述一个请求的 URL。URL 为 `/{something_1}/{something_2}/.../{something_k}` 或 `/{something_1}/{something_2}/.../{something_k}?{name_1}={value_1}&{name_2}={value_2}&...&{name_n}={value_n}` 的形式，其中所有 something 和 value 都由大写英文字母、小写英文字母和数字组成且长度在 $[1,50]$ 内，所有 name 都由大写和小写英文字母组成且长度在 $[1,30]$ 内。", "outputFormat": "对于每组数据，先单独一行输出 `Case #{case_no}:`（不含引号），其中 case_no 表示当前是第几组数据（从 $1$ 开始编号）。\n\n每行输出依次对应每个请求。如果没有 path 能够匹配该请求的 URL，输出 `404 Not Found`。\n\n如果有 path 能够匹配改请求，输出 `Request matches action \"{action_name}\" with parameters {parameter_list}`，其中 action_name 为匹配 path 对应 action 的名称，parameter_list 为所有的参数。\n\n* 其中 parameter_list 用一个字典的方式输出。例如有三个参数，他们的 name 为 avatar、message 和 page，对应的 value 分别为 true、hello 和 2，那么输出的 parameter_list 为 `{\"avatar\":\"true\",\"message\":\"hello\",\"page\":\"2\"}`（所有参数按照 name 的字典序排列）。\n* 注意一个请求中，拥有相同 name 的参数可能出现多次，例如请求的 URL 为 `/user/me/show?name=you&name=he”，匹配的 path 为 “/user/:name/show`，此时的 parameter_list 为 `{\"name\":[\"me\",\"you\",\"he\"]}`。方括号里面按照参数在请求 URL 中出现的次序给出。\n* 更多具体的例子请参考样例。数据能够保证一个请求不会被多个 path 匹配。", "hint": "对于 30% 的数据，path 中不会出现正则表达式；\n\n对于 100% 的数据，$N, M \\leq 20000$，$T \\leq 5$，输入文件大小不超过 $10\\texttt{MB}$。不同名称的正则表达式最多有 $50$ 个。\n\n**注意此题数据是良心数据。**", "locale": "zh-CN"}}}
{"pid": "P11719", "type": "P", "difficulty": 7, "samples": [["4\n1 0 0 0\n0 1 0 0\n0 0 1 0\n0 0 0 1\n4\n1 1 2 3 4\n1 2 1 3 4\n2 1 1 1 1\n2 -1 -1 -1 -1", "Y\nY\nY\nN"], ["10\n0 0 0 1\n5289 1684 8075 24952\n2609 8084 4886 24421\n2737 7620 5520 24123\n6574 1863 7023 24540\n2510 5613 7631 24246\n5942 4118 6615 23325\n8861 907 4085 26147\n1691 4369 8607 25333\n7647 3553 4992 23808\n10\n2 119532316 -6307684 220972316 -99987684\n1 1294 4590 4116 30000\n2 1555221 -12364779 207395221 -39684779\n1 6135 4007 6803 23055\n1 8528 5185 615 25672\n1 1118 4295 9943 24644\n1 1691 4369 8607 25333\n2 -73813002 193626998 178226998 -111693002\n1 5941 4118 6615 23325\n2 127217853 112977853 87617853 -45302147", "N\nN\nY\nN\nN\nN\nY\nN\nY\nY"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "CTT（清华集训/北大集训）"], "title": "[清华集训 2014] Breaking Bomber", "background": "", "description": "药剂师 Luo 是液态爆炸物方面的专家，在他的实验室里有 $n$ 类液态药剂，每一类液态药剂都有很多副，这些药剂由四种化学元素组成, 这里依次称之为 alpha, beta, gamma, delta, 每一类药剂都只由这四种液态化学元素组成，这里我们认为第 $i$ 类药剂依次含有的这四种元素 $a_i, b_i, c_i, d_i$ 克.\n\n药剂师 Luo 经常收到两类客户要求:\n\n第一类是要求混合一副药剂, 依次含有 $A, B, C, D$ 克的 alpha, beta, gamma, delta 元素。\n\n第二类是要求配制出能在特定环境下爆炸的药剂，环境参数为 $A, B, C, D$，如果一副药剂含有 $a, b, c, d$ 克指定元素，那么当 $A \\cdot a + B \\cdot b + C \\cdot c + D \\cdot d \\geq 0$ 时，该药剂可以在此环境下引爆。\n\n当药剂师 Luo 在混合两副药剂的时候，他可以从两副药剂中称出任意克然后进行混合。\n\n显然有一些要求药剂师 Luo 是不可能完成的，Luo 需要你来帮忙计算这个要求是否可以完成。", "inputFormat": "第一行一个数 $N$, 表示 Luo 有的药剂种类。\n\n接下来 $N$ 行，每行 $4$ 个数 $a_i, b_i, c_i, d_i$，代表了这个药剂四种元素的含量。\n\n接下来一行一个数 $M$，代表客户请求数。\n\n接下来 $M$ 行每行五个数 $q, A, B, C, D$。", "outputFormat": "一共 $M$ 行，依次代表每个请求是否可以完成，如果可以完成则输出 $\\tt Y$，否则输出 $\\tt N$。", "hint": "### 数据范围\n\n- 对于 $20\\%$ 的数据，$N, M \\leq 200$；\n- 对于 $40\\%$ 的数据，$N, M \\leq 4000$；\n- 对于 $60\\%$ 的数据，$N \\leq 20000, M \\leq 40000$；\n- 对于 $100\\%$ 的数据，$4 \\leq N \\leq 50000, M \\leq 100000$。\n\n数据保证，$a_i, b_i, c_i, d_i, A, B, C, D$ 的绝对值小于 $10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2014] Breaking Bomber", "background": "", "description": "药剂师 Luo 是液态爆炸物方面的专家，在他的实验室里有 $n$ 类液态药剂，每一类液态药剂都有很多副，这些药剂由四种化学元素组成, 这里依次称之为 alpha, beta, gamma, delta, 每一类药剂都只由这四种液态化学元素组成，这里我们认为第 $i$ 类药剂依次含有的这四种元素 $a_i, b_i, c_i, d_i$ 克.\n\n药剂师 Luo 经常收到两类客户要求:\n\n第一类是要求混合一副药剂, 依次含有 $A, B, C, D$ 克的 alpha, beta, gamma, delta 元素。\n\n第二类是要求配制出能在特定环境下爆炸的药剂，环境参数为 $A, B, C, D$，如果一副药剂含有 $a, b, c, d$ 克指定元素，那么当 $A \\cdot a + B \\cdot b + C \\cdot c + D \\cdot d \\geq 0$ 时，该药剂可以在此环境下引爆。\n\n当药剂师 Luo 在混合两副药剂的时候，他可以从两副药剂中称出任意克然后进行混合。\n\n显然有一些要求药剂师 Luo 是不可能完成的，Luo 需要你来帮忙计算这个要求是否可以完成。", "inputFormat": "第一行一个数 $N$, 表示 Luo 有的药剂种类。\n\n接下来 $N$ 行，每行 $4$ 个数 $a_i, b_i, c_i, d_i$，代表了这个药剂四种元素的含量。\n\n接下来一行一个数 $M$，代表客户请求数。\n\n接下来 $M$ 行每行五个数 $q, A, B, C, D$。", "outputFormat": "一共 $M$ 行，依次代表每个请求是否可以完成，如果可以完成则输出 $\\tt Y$，否则输出 $\\tt N$。", "hint": "### 数据范围\n\n- 对于 $20\\%$ 的数据，$N, M \\leq 200$；\n- 对于 $40\\%$ 的数据，$N, M \\leq 4000$；\n- 对于 $60\\%$ 的数据，$N \\leq 20000, M \\leq 40000$；\n- 对于 $100\\%$ 的数据，$4 \\leq N \\leq 50000, M \\leq 100000$。\n\n数据保证，$a_i, b_i, c_i, d_i, A, B, C, D$ 的绝对值小于 $10^9$。", "locale": "zh-CN"}}}
{"pid": "P11720", "type": "P", "difficulty": 6, "samples": [["2 100 6\nH[P,86(^,<n&7X_Sg\"LY67m2H$n+5'!VHp5IA.@GM:4-NJsqsiG!H[P,7X_S86(^>aNQ22'B5'!V<FD!F!6xNJsq>!]dHp5I", "3\n4\n1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "CTT（清华集训/北大集训）"], "title": "[清华集训 2014] 虫逢", "background": "", "description": "小强和阿米巴是好朋友。\n\n阿米巴告诉小强，变形虫（又叫阿米巴虫）和绝大多数生物一样，也是有 DNA 的。并且，变形虫可以通过分裂的方式进行无性繁殖。\n\n我们把一个变形虫的基因组抽象成一个大小为 $L$ 的基因集合。每个基因都是一个 $4$ 位长的字符串（字符包括大小写字母、数字、符号 ~!@#%^&()[]`:;\"'<>,.?/|\\=-{}}）。现在，有 $N$ 个变形虫凑到了一起。由于他们是从天南海北过来的，我们可以认为，他们的基因组都是从一个大小为 $M$ 的“变形虫基因库“中独立的随机的选取 $L$ 个基因得到的。目前人类并不了解这个基因库里都有什么基因，但是我们知道它的大小是 $M$。\n\n这时，环境突然发生巨变。这 $N$ 个变形虫在外界的刺激下同时进行了一次分裂。每个变形虫分裂成了两个。分裂的过程中，原来的变形虫的基因组（基因的集合）被原样的复制成了两份，分别进入两个新的变形虫。两个新变形虫中的一只的基因组中有一半发生了突变，被替换为“变形虫基因库”中随机的其他的基因。如果两个变形虫是由原来的一个变形虫产生的，我们叫它们“同源”的。\n\n给出 $2N$ 个变形虫的基因组，请你找出每个变形虫同源的另一只虫是谁。", "inputFormat": "第一行三个整数 $N$、$M$、$L$。\n\n接下来一行 $2NL \\times 4$个字符，依次表示每个集合中的元素。集合内的元素之间的顺序是无关紧要的。", "outputFormat": "输出 $2N$ 行，每行一个整数表示第 $i$ 个变形虫（从 $1$ 开始标号）同源的另一只变形虫是谁。", "hint": "### 样例解释\n\n输入文件一共有两行。四个基因组分别是：\n\n`H[P,`，`86(^`，`,<n&`，`7X_S`，`g\"LY`，`67m2`\n\n`H$n+`，`5'!V`，`Hp5I`，`A.@G`，`M:4-`，`NJsq`\n\n`siG!`，`H[P,`，`7X_S`，`86(^`，`>aNQ`，`22'B`\n\n`5'!V`，`<FD!`，`F!6x`，`NJsq`，`>!]d`，`Hp5I`\n\n明显，$1,3$ 是同源的，$2,4$ 是同源的。\n\n### 数据范围\n\n一共有 $10$ 个测试点。数据均为按照题目中描述的方法随机生成的。对于非同源的两个变形虫，他们的基因组的交的大小均小于 $L/2$。对于同源的两个变形虫，他们的基因组的交的大小刚好是 $L/2$。\n\n| 测试点编号 | $N$ | $M$ | $L$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $400$ | $400$ | $20$ |\n| $2$ | $900$ | $900$ | $30$ |\n| $3$ | $1600$ | $1600$ | $40$ |\n| $4$ | $2500$ | $2500$ | $50$ |\n| $5$ | $3600$ | $3600$ | $60$ |\n| $6$ | $6400$ | $6400$ | $80$ |\n| $7$ | $10000$ | $10000$ | $100$ |\n| $8$ | $12100$ | $12100$ | $110$ |\n| $9$ | $14400$ | $14400$ | $120$ |\n| $10$ | $16900$ | $16900$ | $130$ |\n\n最大的一个测试数据的大小是 $17 \\text{MB}$ 左右（$2NL \\times 4=17576000$）。在测评系统上，由于磁盘缓存的存在，使用 scanf 将数据读入需要的时间小于 $0.1$ 秒。请不要使用 cin。经测试：\n\n* 一个实现良好的 $O(N^2L)$ 时间复杂度的算法能拿 30 分，\n* 一个实现良好的 $O(N^2 + N^2L^2 / M)$ 时间复杂度的算法能拿 50 分。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2014] 虫逢", "background": "", "description": "小强和阿米巴是好朋友。\n\n阿米巴告诉小强，变形虫（又叫阿米巴虫）和绝大多数生物一样，也是有 DNA 的。并且，变形虫可以通过分裂的方式进行无性繁殖。\n\n我们把一个变形虫的基因组抽象成一个大小为 $L$ 的基因集合。每个基因都是一个 $4$ 位长的字符串（字符包括大小写字母、数字、符号 ~!@#%^&()[]`:;\"'<>,.?/|\\=-{}}）。现在，有 $N$ 个变形虫凑到了一起。由于他们是从天南海北过来的，我们可以认为，他们的基因组都是从一个大小为 $M$ 的“变形虫基因库“中独立的随机的选取 $L$ 个基因得到的。目前人类并不了解这个基因库里都有什么基因，但是我们知道它的大小是 $M$。\n\n这时，环境突然发生巨变。这 $N$ 个变形虫在外界的刺激下同时进行了一次分裂。每个变形虫分裂成了两个。分裂的过程中，原来的变形虫的基因组（基因的集合）被原样的复制成了两份，分别进入两个新的变形虫。两个新变形虫中的一只的基因组中有一半发生了突变，被替换为“变形虫基因库”中随机的其他的基因。如果两个变形虫是由原来的一个变形虫产生的，我们叫它们“同源”的。\n\n给出 $2N$ 个变形虫的基因组，请你找出每个变形虫同源的另一只虫是谁。", "inputFormat": "第一行三个整数 $N$、$M$、$L$。\n\n接下来一行 $2NL \\times 4$个字符，依次表示每个集合中的元素。集合内的元素之间的顺序是无关紧要的。", "outputFormat": "输出 $2N$ 行，每行一个整数表示第 $i$ 个变形虫（从 $1$ 开始标号）同源的另一只变形虫是谁。", "hint": "### 样例解释\n\n输入文件一共有两行。四个基因组分别是：\n\n`H[P,`，`86(^`，`,<n&`，`7X_S`，`g\"LY`，`67m2`\n\n`H$n+`，`5'!V`，`Hp5I`，`A.@G`，`M:4-`，`NJsq`\n\n`siG!`，`H[P,`，`7X_S`，`86(^`，`>aNQ`，`22'B`\n\n`5'!V`，`<FD!`，`F!6x`，`NJsq`，`>!]d`，`Hp5I`\n\n明显，$1,3$ 是同源的，$2,4$ 是同源的。\n\n### 数据范围\n\n一共有 $10$ 个测试点。数据均为按照题目中描述的方法随机生成的。对于非同源的两个变形虫，他们的基因组的交的大小均小于 $L/2$。对于同源的两个变形虫，他们的基因组的交的大小刚好是 $L/2$。\n\n| 测试点编号 | $N$ | $M$ | $L$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $400$ | $400$ | $20$ |\n| $2$ | $900$ | $900$ | $30$ |\n| $3$ | $1600$ | $1600$ | $40$ |\n| $4$ | $2500$ | $2500$ | $50$ |\n| $5$ | $3600$ | $3600$ | $60$ |\n| $6$ | $6400$ | $6400$ | $80$ |\n| $7$ | $10000$ | $10000$ | $100$ |\n| $8$ | $12100$ | $12100$ | $110$ |\n| $9$ | $14400$ | $14400$ | $120$ |\n| $10$ | $16900$ | $16900$ | $130$ |\n\n最大的一个测试数据的大小是 $17 \\text{MB}$ 左右（$2NL \\times 4=17576000$）。在测评系统上，由于磁盘缓存的存在，使用 scanf 将数据读入需要的时间小于 $0.1$ 秒。请不要使用 cin。经测试：\n\n* 一个实现良好的 $O(N^2L)$ 时间复杂度的算法能拿 30 分，\n* 一个实现良好的 $O(N^2 + N^2L^2 / M)$ 时间复杂度的算法能拿 50 分。\n", "locale": "zh-CN"}}}
{"pid": "P11721", "type": "P", "difficulty": 7, "samples": [["24\n3 5\n1 2 3\n5\n1 1 2 3 2\n1 2 3 4 3\n2 1 1 3\n1 1 3 1 4\n2 1 3 2", "3\n4"], ["7\n3 5\n1 2 3\n5\n1 1 2 0 3\n1 2 3 4 0\n2 1 1 3\n1 2 0 2 0\n2 2 0 1", "3\n4"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432]}, "tags": ["2014", "CTT（清华集训/北大集训）"], "title": "[清华集训 2014] 玄学", "background": "", "description": "巨酱有 $n$ 副耳机，他把它们摆成了一列，并且由 $1$ 到 $n$ 依次编号。每个耳机有一个玄学值，反映了各自的一些不可名状的独特性能。玄学值都是 $0$ 到 $m - 1$ 间的整数。在外界的作用下（包括但不限于换线、上放、更换电源为核电、让 kAc 叔叔给它们讲故事），这些耳机的玄学值会发生改变。特别地，巨酱观察发现，每种作用 $o$ 对应了两个整数 $a_o$与 $b_o$，在这种作用之后，玄学值原本为 $x$ 的耳机，其玄学值恰会变成 $(a_ox + b_o) \\bmod m$。\n\n巨酱对他手头耳机的表现并不满意，遗憾的是，最近他并不有钱，无法任性，不能赶紧买买买以满足自己。手头紧张的他准备拟定一个相对经济的方案，通过各种作用来改善他手头玩具的性能。具体地说，为了尽快完成方案的制订，巨酱希望自己能高效地完成以下工作：\n\n1. 巨酱想到了一种操作，能让耳机的玄学值由 $x$ 变为 $(ax + b) \\bmod m$，并且他计划对编号为 $i$ 到 $j$ 的耳机执行这种操作。\n2. 巨酱想知道如果将（并且仅将）自己的第 $i$ 个到第 $j$ 个计划按顺序付诸行动，编号为 $k$ 的耳机的玄学值将会变成多少。\n\n出于著名算法竞赛选手的矜持，巨酱表示自己才不需要你的帮助。但是如果巨酱真的厌倦了自己的玩具，它们就会被 $50$ 包邮出给主席。为了不让后者白白捡到便宜，你考虑再三还是决定出手。", "inputFormat": "第 1 行只有一个整数，表示本组测试数据的特征。特征值为一个 $0 \\sim 31$ 的整数。我们把这个整数转换成一个五位的二进制数，最低位为第一位。\n\n如果第一位为 $1$，代表数据进行了加密，否则数据没有进行加密。对于已加密的数据，你需要把第一种操作中的 $i,j$ 以及第二种操作中的 $i,j,k$ 与上一次询问操作得到的答案 $\\text{lastans}$ 进行异或操作来得到正确的操作信息。$\\text{lastans}$ 的初始值视为 $0$。\n\n如果第二位为 $1$，代表修改操作会出现 $(0x+ b) \\bmod m$（$b$ 不为 $0$）的形式，否则一定不会出现这样的修改。\n\n如果第三位为 $1$，代表修改操作会出现 $(ax+ 0) \\bmod m$（$a$ 不为 $0$）的形式，否则一定不会出现这样的修改。\n\n如果第四位为 $1$，代表修改操作会出现 $(ax+b) \\bmod m$（$a,b$ 均不为 $0$）的形式，否则一定不会出现这样的修改。\n\n如果第五位为 $1$，则我们保证给出的 $m$ 是一个质数，否则不保证。\n\n第 2 行两个整数 $n$, $m$。\n\n第 3 行有 $n$ 个用空格隔开的整数$a_1,a_2,\\dots,a_n$，$0 \\leq a_i < m$，表示第 $i$ 副耳机原本的玄学值。\n\n第 4 行一个整数 $q$，表示巨酱的操作总数。\n\n接下来有 $q$ 行，每行 $4$ 个或 $5$ 个整数，第一个整数 cmd 是 $1$ 或 $2$，表示这个操作的种类。若 cmd 为 $1$，接下来还有 $4$ 个整数 $i,j,a,b$，表示巨酱增加一条计划，把耳机 $i \\dots j$ 的玄学值应用变换 $x \\mapsto (ax + b) \\bmod m$ （保证 $0 \\leq a, b < m$）。若 cmd 为 $2$，接下来还有 $3$ 个整数 $i,j,k$，表示巨酱询问如果自己只作用变换 $i \\dots j$，编号为 $k$ 的耳机玄学值最终会变成多少。保证两种操作的 $i,j$ 在解密后（如果数据是加密的）有 $i \\leq j$。", "outputFormat": "对每个第 2 类操作，输出独占一行的一个整数，表示那次询问的结果。", "hint": "| 测试点编号 | $n$ 不超过 | $q$ 不超过 | 特征值 |\n|:------------:|:----------:|:----------:|:--------:|\n| $1 \\sim 4$      | $20$       | $20$       | xxxxx  |\n| $5 \\sim 8$      | $100000$   | $100000$   | 0001x  |\n| $9 \\sim 12$     | $100000$   | $100000$   | 1110x  |\n| $13 \\sim 16$    | $100000$   | $100000$   | 1111x  |\n| $17 \\sim 20$    | $100000$   | $100000$   | 0010x  |\n| $21 \\sim 30$    | $100000$   | $100000$   | xxxxx  |\n| $31 \\sim 40$    | $100000$   | $600000$   | xxxxx  |\n\n其中 x 为 0 和 1 中的任意数，特征值最左边为最高位。我们保证，同类型的测试点中加密与不加密的数据点各占 50%，且修改操作数不超过 $100000$，所有数的都可以用 int 存下。\n\n由于本题数据量较大，请自行使用读入优化。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2014] 玄学", "background": "", "description": "巨酱有 $n$ 副耳机，他把它们摆成了一列，并且由 $1$ 到 $n$ 依次编号。每个耳机有一个玄学值，反映了各自的一些不可名状的独特性能。玄学值都是 $0$ 到 $m - 1$ 间的整数。在外界的作用下（包括但不限于换线、上放、更换电源为核电、让 kAc 叔叔给它们讲故事），这些耳机的玄学值会发生改变。特别地，巨酱观察发现，每种作用 $o$ 对应了两个整数 $a_o$与 $b_o$，在这种作用之后，玄学值原本为 $x$ 的耳机，其玄学值恰会变成 $(a_ox + b_o) \\bmod m$。\n\n巨酱对他手头耳机的表现并不满意，遗憾的是，最近他并不有钱，无法任性，不能赶紧买买买以满足自己。手头紧张的他准备拟定一个相对经济的方案，通过各种作用来改善他手头玩具的性能。具体地说，为了尽快完成方案的制订，巨酱希望自己能高效地完成以下工作：\n\n1. 巨酱想到了一种操作，能让耳机的玄学值由 $x$ 变为 $(ax + b) \\bmod m$，并且他计划对编号为 $i$ 到 $j$ 的耳机执行这种操作。\n2. 巨酱想知道如果将（并且仅将）自己的第 $i$ 个到第 $j$ 个计划按顺序付诸行动，编号为 $k$ 的耳机的玄学值将会变成多少。\n\n出于著名算法竞赛选手的矜持，巨酱表示自己才不需要你的帮助。但是如果巨酱真的厌倦了自己的玩具，它们就会被 $50$ 包邮出给主席。为了不让后者白白捡到便宜，你考虑再三还是决定出手。", "inputFormat": "第 1 行只有一个整数，表示本组测试数据的特征。特征值为一个 $0 \\sim 31$ 的整数。我们把这个整数转换成一个五位的二进制数，最低位为第一位。\n\n如果第一位为 $1$，代表数据进行了加密，否则数据没有进行加密。对于已加密的数据，你需要把第一种操作中的 $i,j$ 以及第二种操作中的 $i,j,k$ 与上一次询问操作得到的答案 $\\text{lastans}$ 进行异或操作来得到正确的操作信息。$\\text{lastans}$ 的初始值视为 $0$。\n\n如果第二位为 $1$，代表修改操作会出现 $(0x+ b) \\bmod m$（$b$ 不为 $0$）的形式，否则一定不会出现这样的修改。\n\n如果第三位为 $1$，代表修改操作会出现 $(ax+ 0) \\bmod m$（$a$ 不为 $0$）的形式，否则一定不会出现这样的修改。\n\n如果第四位为 $1$，代表修改操作会出现 $(ax+b) \\bmod m$（$a,b$ 均不为 $0$）的形式，否则一定不会出现这样的修改。\n\n如果第五位为 $1$，则我们保证给出的 $m$ 是一个质数，否则不保证。\n\n第 2 行两个整数 $n$, $m$。\n\n第 3 行有 $n$ 个用空格隔开的整数$a_1,a_2,\\dots,a_n$，$0 \\leq a_i < m$，表示第 $i$ 副耳机原本的玄学值。\n\n第 4 行一个整数 $q$，表示巨酱的操作总数。\n\n接下来有 $q$ 行，每行 $4$ 个或 $5$ 个整数，第一个整数 cmd 是 $1$ 或 $2$，表示这个操作的种类。若 cmd 为 $1$，接下来还有 $4$ 个整数 $i,j,a,b$，表示巨酱增加一条计划，把耳机 $i \\dots j$ 的玄学值应用变换 $x \\mapsto (ax + b) \\bmod m$ （保证 $0 \\leq a, b < m$）。若 cmd 为 $2$，接下来还有 $3$ 个整数 $i,j,k$，表示巨酱询问如果自己只作用变换 $i \\dots j$，编号为 $k$ 的耳机玄学值最终会变成多少。保证两种操作的 $i,j$ 在解密后（如果数据是加密的）有 $i \\leq j$。", "outputFormat": "对每个第 2 类操作，输出独占一行的一个整数，表示那次询问的结果。", "hint": "| 测试点编号 | $n$ 不超过 | $q$ 不超过 | 特征值 |\n|:------------:|:----------:|:----------:|:--------:|\n| $1 \\sim 4$      | $20$       | $20$       | xxxxx  |\n| $5 \\sim 8$      | $100000$   | $100000$   | 0001x  |\n| $9 \\sim 12$     | $100000$   | $100000$   | 1110x  |\n| $13 \\sim 16$    | $100000$   | $100000$   | 1111x  |\n| $17 \\sim 20$    | $100000$   | $100000$   | 0010x  |\n| $21 \\sim 30$    | $100000$   | $100000$   | xxxxx  |\n| $31 \\sim 40$    | $100000$   | $600000$   | xxxxx  |\n\n其中 x 为 0 和 1 中的任意数，特征值最左边为最高位。我们保证，同类型的测试点中加密与不加密的数据点各占 50%，且修改操作数不超过 $100000$，所有数的都可以用 int 存下。\n\n由于本题数据量较大，请自行使用读入优化。", "locale": "zh-CN"}}}
{"pid": "P11723", "type": "P", "difficulty": 2, "samples": [["5 5\n1 1 1 1 1", "5"], ["6 4\n1 2 1 1 2 2", "0"], ["7 3\n3 7 9 1 7 5 3", "23"], ["10 3\n23 19 21 20 22 18 22 22 24 27", "71"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "O2优化", "排序", "JOI（日本）"], "title": "[JOIG 2025] カードゲーム 4 / Card Game 4", "background": "", "description": "有 $N$ 张卡牌，编号为 $1$ 到 $N$，卡牌 $i(1\\le i\\le N)$ 上写有一个整数 $A_i$。\n\n现在需要从 $N$ 张卡牌中选择 $K$ 张；对于一种选择，你的得分按照如下的方式进行计算：\n\n- 如果选择的卡牌上写有的整数奇偶性两两相同，那么分数为你选择的所有卡牌上写有的整数之和；\n- 否则分数为 $0$。\n\n请求出你能获得的最大得分。", "inputFormat": "第一行输入两个整数 $N,K$。\n\n第二行输入 $N$ 个整数 $A_1,A_2,\\ldots,A_N$。", "outputFormat": "输出一行一个整数，表示最大得分。", "hint": "#### 【样例解释 #1】\n\n只有一种选择方案，即选择所有的卡牌；由于选择的卡牌上写有的整数均为奇数，故得分为 $1+1+1+1+1=5$。\n\n该样例满足所有子任务的限制。\n\n#### 【样例解释 #2】\n\n无论你如何选择 $K=4$ 张卡牌，你的得分都是 $0$。\n\n该样例满足子任务 $2,4$ 的限制。\n\n#### 【样例解释 #3】\n\n- 其中一种方案为选择卡牌 $1,2,6$，由于选择的卡牌上写有的整数均为奇数，得分为 $3+7+5=15$，但不是最优的；\n- 最优方案为选择卡牌 $2,3,5$，由于选择的卡牌上写有的整数均为奇数，得分为 $7+9+7=23$。\n\n该样例满足子任务 $3,4$ 的限制。\n\n#### 【样例解释 #4】\n\n该样例满足子任务 $4$ 的限制。\n\n#### 【数据范围】\n\n- $1\\le N\\le 10^5$；\n- $1\\le K\\le N$；\n- $1\\le A_i\\le 10^9(1\\le i\\le N)$。\n\n#### 【子任务】\n\n1. （$30$ 分）$N=K$；\n2. （$25$ 分）$A_i\\le 2(1\\le i\\le N)$；\n3. （$20$ 分）$A_i$ 均为奇数 $(1\\le i\\le N)$；\n4. （$25$ 分）无附加限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIG 2025] カードゲーム 4 / Card Game 4", "background": "", "description": "有 $N$ 张卡牌，编号为 $1$ 到 $N$，卡牌 $i(1\\le i\\le N)$ 上写有一个整数 $A_i$。\n\n现在需要从 $N$ 张卡牌中选择 $K$ 张；对于一种选择，你的得分按照如下的方式进行计算：\n\n- 如果选择的卡牌上写有的整数奇偶性两两相同，那么分数为你选择的所有卡牌上写有的整数之和；\n- 否则分数为 $0$。\n\n请求出你能获得的最大得分。", "inputFormat": "第一行输入两个整数 $N,K$。\n\n第二行输入 $N$ 个整数 $A_1,A_2,\\ldots,A_N$。", "outputFormat": "输出一行一个整数，表示最大得分。", "hint": "#### 【样例解释 #1】\n\n只有一种选择方案，即选择所有的卡牌；由于选择的卡牌上写有的整数均为奇数，故得分为 $1+1+1+1+1=5$。\n\n该样例满足所有子任务的限制。\n\n#### 【样例解释 #2】\n\n无论你如何选择 $K=4$ 张卡牌，你的得分都是 $0$。\n\n该样例满足子任务 $2,4$ 的限制。\n\n#### 【样例解释 #3】\n\n- 其中一种方案为选择卡牌 $1,2,6$，由于选择的卡牌上写有的整数均为奇数，得分为 $3+7+5=15$，但不是最优的；\n- 最优方案为选择卡牌 $2,3,5$，由于选择的卡牌上写有的整数均为奇数，得分为 $7+9+7=23$。\n\n该样例满足子任务 $3,4$ 的限制。\n\n#### 【样例解释 #4】\n\n该样例满足子任务 $4$ 的限制。\n\n#### 【数据范围】\n\n- $1\\le N\\le 10^5$；\n- $1\\le K\\le N$；\n- $1\\le A_i\\le 10^9(1\\le i\\le N)$。\n\n#### 【子任务】\n\n1. （$30$ 分）$N=K$；\n2. （$25$ 分）$A_i\\le 2(1\\le i\\le N)$；\n3. （$20$ 分）$A_i$ 均为奇数 $(1\\le i\\le N)$；\n4. （$25$ 分）无附加限制。", "locale": "zh-CN"}}}
{"pid": "P11724", "type": "P", "difficulty": 3, "samples": [["2 3\n1 2\n2 1", "1"], ["5 5\n1 1 1 2 2\n1 1 1 2 2\n3 3 1 2 2\n3 3 5 5 5\n3 3 5 5 5", "5"], ["5 1000000000\n104289385 946930886 881692778 914636916 257747795\n524238335 819885386 849760493 696516649 389641422\n225202363 550490028 883368690 302520060 344897765\n267513928 565180541 740383427 404089172 503455737\n135005211 621595368 394702567 926956430 436465782", "16"], ["3 3\n1 2 3\n2 2 2\n3 2 1", "2"], ["10 11\n2 2 1 3 4 3 4 3 3 5\n3 2 4 3 4 4 3 3 5 5\n3 4 2 2 5 5 5 5 5 5\n4 2 2 3 5 3 5 5 5 6\n2 2 3 5 5 5 6 6 7 5\n4 4 4 5 6 4 6 7 6 6\n3 3 5 4 6 6 6 5 6 8\n3 3 4 4 6 5 7 7 6 8\n4 4 4 6 7 5 5 8 8 7\n4 4 6 5 6 6 7 6 6 9", "39"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["模拟", "2025", "O2优化", "枚举", "JOI（日本）"], "title": "[JOIG 2025] ポスター 2 / Poster 2", "background": "", "description": "JOI 学院的理惠为三月举行的文化节制作了一张海报。海报可以视为一个 $N\\times N$ 的网格；有 $K$ 种颜色，编号分别为 $1$ 到 $K$，每个格子的颜色是 $K$ 种颜色之一；具体地，网格的颜色可以用一个矩阵 $A$ 来表示：记第 $i$ 行第 $j$ 列的格子为 $(i,j)(1\\le i,j\\le N)$，那么 $(i,j)$ 的颜色为 $A_{i,j}(1\\le A_{i,j}\\le K)$。\n\n学生希望海报的颜色可以丰富一点；他们定义一张海报的“鲜艳程度”为满足以下条件的 $(i,j)(1\\le i,j\\le N-1)$ 的个数：\n\n- $(i,j),(i+1,j),(i,j+1),(i+1,j+1)$ 中出现的颜色种类数不小于 $3$。\n\n即 $A$ 中出现元素种类数不小于 $3$ 的 $2\\times 2$ 子矩阵个数。\n\n例如，下图中的海报的鲜艳程度为 $2$，因为存在 $2$ 个满足上述条件的 $2\\times 2$ 子矩阵（已使用蓝框标出）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t5fmqlcc.png)\n\n由于时间紧迫，学生们希望通过恰好**一次**以下操作，或者**不进行操作**，来最大化海报的鲜艳程度：\n\n- 选择**恰好一个**格子 $(i,j)$ 和一个与该格子原先颜色不同的颜色 $c(1\\le c\\le K)$，将格子 $(i,j)$ 的颜色改为 $c$，即 $A_{i,j}\\gets c$。\n\n请求出最终能得到的海报的最大鲜艳程度。", "inputFormat": "第一行输入两个整数 $N,K$。\n\n接下来 $N$ 行，每行输入 $N$ 个整数 $A_{i,j}$。", "outputFormat": "输出一行一个整数，表示最终能得到的海报的最大鲜艳程度。", "hint": "#### 【样例解释 #1】\n\n如下图所示，将 $(2,2)$ 的颜色改为颜色 $3$，可以使得鲜艳程度为 $1$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/762orsul.png)\n\n可以证明不存在更优的方案。\n\n该样例满足子任务 $1,3,4,5$ 的限制。\n\n#### 【样例解释 #2】\n\n如下图所示，将 $(2,3)$ 的颜色改为颜色 $4$，可以使得鲜艳程度为 $5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wewhdqwb.png)\n\n可以证明不存在更优的方案。\n\n该样例满足子任务 $3,4,5$ 的限制。\n\n#### 【样例解释 #3】\n\n该样例满足子任务 $2,4,5$ 的限制。\n\n#### 【样例解释 #4】\n\n该样例满足子任务 $3,4,5$ 的限制。\n\n#### 【样例解释 #5】\n\n该样例满足子任务 $4,5$ 的限制。\n\n#### 【数据范围】\n\n- $2\\le N\\le 270$；\n- $3\\le K\\le 10^9$；\n- $1\\le A_{i,j}\\le K(1\\le i,j\\le N)$。\n\n#### 【子任务】\n\n1. （$9$ 分）$N=2,K=3$；\n2. （$6$ 分）$A_{i,j}(1\\le i,j\\le N)$ 两两不同；\n3. （$27$ 分）$N,K\\le 10$；\n4. （$26$ 分）$N\\le 10$；\n5. （$32$ 分）无附加限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIG 2025] ポスター 2 / Poster 2", "background": "", "description": "JOI 学院的理惠为三月举行的文化节制作了一张海报。海报可以视为一个 $N\\times N$ 的网格；有 $K$ 种颜色，编号分别为 $1$ 到 $K$，每个格子的颜色是 $K$ 种颜色之一；具体地，网格的颜色可以用一个矩阵 $A$ 来表示：记第 $i$ 行第 $j$ 列的格子为 $(i,j)(1\\le i,j\\le N)$，那么 $(i,j)$ 的颜色为 $A_{i,j}(1\\le A_{i,j}\\le K)$。\n\n学生希望海报的颜色可以丰富一点；他们定义一张海报的“鲜艳程度”为满足以下条件的 $(i,j)(1\\le i,j\\le N-1)$ 的个数：\n\n- $(i,j),(i+1,j),(i,j+1),(i+1,j+1)$ 中出现的颜色种类数不小于 $3$。\n\n即 $A$ 中出现元素种类数不小于 $3$ 的 $2\\times 2$ 子矩阵个数。\n\n例如，下图中的海报的鲜艳程度为 $2$，因为存在 $2$ 个满足上述条件的 $2\\times 2$ 子矩阵（已使用蓝框标出）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t5fmqlcc.png)\n\n由于时间紧迫，学生们希望通过恰好**一次**以下操作，或者**不进行操作**，来最大化海报的鲜艳程度：\n\n- 选择**恰好一个**格子 $(i,j)$ 和一个与该格子原先颜色不同的颜色 $c(1\\le c\\le K)$，将格子 $(i,j)$ 的颜色改为 $c$，即 $A_{i,j}\\gets c$。\n\n请求出最终能得到的海报的最大鲜艳程度。", "inputFormat": "第一行输入两个整数 $N,K$。\n\n接下来 $N$ 行，每行输入 $N$ 个整数 $A_{i,j}$。", "outputFormat": "输出一行一个整数，表示最终能得到的海报的最大鲜艳程度。", "hint": "#### 【样例解释 #1】\n\n如下图所示，将 $(2,2)$ 的颜色改为颜色 $3$，可以使得鲜艳程度为 $1$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/762orsul.png)\n\n可以证明不存在更优的方案。\n\n该样例满足子任务 $1,3,4,5$ 的限制。\n\n#### 【样例解释 #2】\n\n如下图所示，将 $(2,3)$ 的颜色改为颜色 $4$，可以使得鲜艳程度为 $5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wewhdqwb.png)\n\n可以证明不存在更优的方案。\n\n该样例满足子任务 $3,4,5$ 的限制。\n\n#### 【样例解释 #3】\n\n该样例满足子任务 $2,4,5$ 的限制。\n\n#### 【样例解释 #4】\n\n该样例满足子任务 $3,4,5$ 的限制。\n\n#### 【样例解释 #5】\n\n该样例满足子任务 $4,5$ 的限制。\n\n#### 【数据范围】\n\n- $2\\le N\\le 270$；\n- $3\\le K\\le 10^9$；\n- $1\\le A_{i,j}\\le K(1\\le i,j\\le N)$。\n\n#### 【子任务】\n\n1. （$9$ 分）$N=2,K=3$；\n2. （$6$ 分）$A_{i,j}(1\\le i,j\\le N)$ 两两不同；\n3. （$27$ 分）$N,K\\le 10$；\n4. （$26$ 分）$N\\le 10$；\n5. （$32$ 分）无附加限制。", "locale": "zh-CN"}}}
{"pid": "P11725", "type": "P", "difficulty": 4, "samples": [["2 3\nABABBAABB\n3\n8\n4", "B\nB\nA"], ["2 5\nAAAAAAAAA\n1\n2\n7\n8\n5", "A\nA\nA\nB\nB"], ["1 4\nAAB\n3\n1\n2\n3", "A\nA\nB\nB"], ["3 6\nAABABABBABAABABBBBBBAABABAA\n4\n1\n9\n3\n8\n9", "B\nB\nB\nB\nB\nA"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2025", "O2优化", "JOI（日本）"], "title": "[JOIG 2025] 修学旅行 / School Trip", "background": null, "description": "JOIG 高中有 $3^N$ 名学生，编号从 $1$ 到 $3^N$。\n\nJOIG 高中决定举行一场学校旅行，有两个可能的旅行目的地：阿拉斯加（记为“方案 $\\texttt{A}$”）和玻利维亚（记为“方案 $\\texttt{B}$”）。学生们决定使用以下的流程确定最终的旅行方案：\n\n- 考虑一个长度为 $3^N$ 的字符串 $S$：如果学生 $i\\left(1\\le i\\le 3^N\\right)$ 选择方案 $\\texttt{A}$，那么 $S_i$ 为 $\\texttt{A}$，否则为 $\\texttt{B}$；\n- 执行以下操作 $N$ 次：\n  - 假设当前 $S$ 的长度为 $X$，考虑一个长度为 $\\frac{X}{3}$ 的字符串 $S'$，满足 $S'_j\\left(1\\le j\\le\\frac{X}{3}\\right)$ 为 $S_{3j-2},S_{3j-1},S_{3j}$ 中出现次数较多的字符（$\\texttt{A}$ 或 $\\texttt{B}$）；接着将 $S$ 替换为 $S'$；\n- 所有操作结束之后，$S$ 将成为一个长度为 $1$ 的字符串（要么为 $\\texttt{A}$ 要么为 $\\texttt{B}$）；如果 $S$ 为 $\\texttt{A}$，那么学校最终选取方案 $\\texttt{A}$，否则选取方案 $\\texttt{B}$。\n\n初始时，我们使用一个字符串 $T$ 表示每名学生选择哪个方案：如果学生 $i\\left(1\\le i\\le 3^N\\right)$ 选择方案 $\\texttt{A}$，那么 $T_i$ 为 $\\texttt{A}$，否则为 $\\texttt{B}$。\n\n之后依次发生了 $Q$ 次事件，第 $k(1\\le k\\le Q)$ 次事件中，学生 $p_k\\left(1\\le p_k\\le 3^N\\right)$ 改变了其选择的方案，即若原来他 / 她选择方案 $\\texttt{A}$，那么现在他 / 她选择的方案变为 $\\texttt{B}$，反之亦然。\n\n对于 $k=1,2,\\ldots,Q$，求出第 $k$ 次事件发生后，按照上述流程，学校会选择哪个旅行方案。", "inputFormat": "第一行输入两个整数 $N,Q$。\n\n第二行输入一个字符串 $T$。\n\n接下来 $Q$ 行，每行一个整数 $p_k$。", "outputFormat": "输出 $Q$ 行，第 $k(1\\le k\\le Q)$ 行一个字符串表示第 $k$ 次事件过后学校选择的旅行方案：如果为 $\\texttt{A}$，那么学校选择方案 $\\texttt{A}$；如果为 $\\texttt{B}$，那么学校选择方案 $\\texttt{B}$。", "hint": "#### 【样例解释 #1】\n\n- 在第 $1$ 次事件发生后，确定方案流程中，$S$ 的变化为 $\\texttt{ABBBBAABB}\\to\\texttt{BBB}\\to\\texttt{B}$，最终选取方案 $\\texttt{B}$；\n- 在第 $2$ 次事件发生后，确定方案流程中，$S$ 的变化为 $\\texttt{ABBBBAAAB}\\to\\texttt{BBA}\\to\\texttt{B}$，最终选取方案 $\\texttt{B}$；\n- 在第 $3$ 次事件发生后，确定方案流程中，$S$ 的变化为 $\\texttt{ABBABAAAB}\\to\\texttt{BAA}\\to\\texttt{A}$，最终选取方案 $\\texttt{A}$。\n\n该样例满足子任务 $2,5$ 的限制。\n\n#### 【样例解释 #2】\n\n该样例满足子任务 $2,4,5$ 的限制。\n\n#### 【样例解释 #3】\n\n该样例满足子任务 $1,2,3,5$ 的限制。\n\n#### 【样例解释 #4】\n\n该样例满足子任务 $2,5$ 的限制。\n\n#### 【数据范围】\n\n- $1\\le N\\le 12$；\n- $1\\le Q\\le 2\\times 10^5$；\n- $T$ 是长度为 $3^N$ 且仅包含大写字母 $\\texttt{A}$ 和 $\\texttt{B}$ 的字符串；\n- $1\\le p_k\\le 3^N(1\\le k\\le Q)$。\n\n#### 【子任务】\n\n1. （$8$ 分）$N=1$；\n2. （$17$ 分）$Q\\le 10$；\n3. （$22$ 分）$p_k\\le 5(1\\le k\\le Q)$；\n4. （$28$ 分）$T$ 中所有字符均为 $\\texttt{A}$ 且之后的修改均满足 $p_k\\ne p_l(1\\le k<l\\le Q)$；\n5. （$25$ 分）无附加限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIG 2025] 修学旅行 / School Trip", "background": null, "description": "JOIG 高中有 $3^N$ 名学生，编号从 $1$ 到 $3^N$。\n\nJOIG 高中决定举行一场学校旅行，有两个可能的旅行目的地：阿拉斯加（记为“方案 $\\texttt{A}$”）和玻利维亚（记为“方案 $\\texttt{B}$”）。学生们决定使用以下的流程确定最终的旅行方案：\n\n- 考虑一个长度为 $3^N$ 的字符串 $S$：如果学生 $i\\left(1\\le i\\le 3^N\\right)$ 选择方案 $\\texttt{A}$，那么 $S_i$ 为 $\\texttt{A}$，否则为 $\\texttt{B}$；\n- 执行以下操作 $N$ 次：\n  - 假设当前 $S$ 的长度为 $X$，考虑一个长度为 $\\frac{X}{3}$ 的字符串 $S'$，满足 $S'_j\\left(1\\le j\\le\\frac{X}{3}\\right)$ 为 $S_{3j-2},S_{3j-1},S_{3j}$ 中出现次数较多的字符（$\\texttt{A}$ 或 $\\texttt{B}$）；接着将 $S$ 替换为 $S'$；\n- 所有操作结束之后，$S$ 将成为一个长度为 $1$ 的字符串（要么为 $\\texttt{A}$ 要么为 $\\texttt{B}$）；如果 $S$ 为 $\\texttt{A}$，那么学校最终选取方案 $\\texttt{A}$，否则选取方案 $\\texttt{B}$。\n\n初始时，我们使用一个字符串 $T$ 表示每名学生选择哪个方案：如果学生 $i\\left(1\\le i\\le 3^N\\right)$ 选择方案 $\\texttt{A}$，那么 $T_i$ 为 $\\texttt{A}$，否则为 $\\texttt{B}$。\n\n之后依次发生了 $Q$ 次事件，第 $k(1\\le k\\le Q)$ 次事件中，学生 $p_k\\left(1\\le p_k\\le 3^N\\right)$ 改变了其选择的方案，即若原来他 / 她选择方案 $\\texttt{A}$，那么现在他 / 她选择的方案变为 $\\texttt{B}$，反之亦然。\n\n对于 $k=1,2,\\ldots,Q$，求出第 $k$ 次事件发生后，按照上述流程，学校会选择哪个旅行方案。", "inputFormat": "第一行输入两个整数 $N,Q$。\n\n第二行输入一个字符串 $T$。\n\n接下来 $Q$ 行，每行一个整数 $p_k$。", "outputFormat": "输出 $Q$ 行，第 $k(1\\le k\\le Q)$ 行一个字符串表示第 $k$ 次事件过后学校选择的旅行方案：如果为 $\\texttt{A}$，那么学校选择方案 $\\texttt{A}$；如果为 $\\texttt{B}$，那么学校选择方案 $\\texttt{B}$。", "hint": "#### 【样例解释 #1】\n\n- 在第 $1$ 次事件发生后，确定方案流程中，$S$ 的变化为 $\\texttt{ABBBBAABB}\\to\\texttt{BBB}\\to\\texttt{B}$，最终选取方案 $\\texttt{B}$；\n- 在第 $2$ 次事件发生后，确定方案流程中，$S$ 的变化为 $\\texttt{ABBBBAAAB}\\to\\texttt{BBA}\\to\\texttt{B}$，最终选取方案 $\\texttt{B}$；\n- 在第 $3$ 次事件发生后，确定方案流程中，$S$ 的变化为 $\\texttt{ABBABAAAB}\\to\\texttt{BAA}\\to\\texttt{A}$，最终选取方案 $\\texttt{A}$。\n\n该样例满足子任务 $2,5$ 的限制。\n\n#### 【样例解释 #2】\n\n该样例满足子任务 $2,4,5$ 的限制。\n\n#### 【样例解释 #3】\n\n该样例满足子任务 $1,2,3,5$ 的限制。\n\n#### 【样例解释 #4】\n\n该样例满足子任务 $2,5$ 的限制。\n\n#### 【数据范围】\n\n- $1\\le N\\le 12$；\n- $1\\le Q\\le 2\\times 10^5$；\n- $T$ 是长度为 $3^N$ 且仅包含大写字母 $\\texttt{A}$ 和 $\\texttt{B}$ 的字符串；\n- $1\\le p_k\\le 3^N(1\\le k\\le Q)$。\n\n#### 【子任务】\n\n1. （$8$ 分）$N=1$；\n2. （$17$ 分）$Q\\le 10$；\n3. （$22$ 分）$p_k\\le 5(1\\le k\\le Q)$；\n4. （$28$ 分）$T$ 中所有字符均为 $\\texttt{A}$ 且之后的修改均满足 $p_k\\ne p_l(1\\le k<l\\le Q)$；\n5. （$25$ 分）无附加限制。", "locale": "zh-CN"}}}
{"pid": "P11726", "type": "P", "difficulty": 5, "samples": [["5 5\n1 2\n4 5\n3 4\n3 5\n1 4", "Yes\n2\n4\n1\n5\n3"], ["3 4\n1 3\n2 3\n1 3\n2 3", "No"], ["8 3\n1 8\n3 5\n4 7", "Yes\n1\n8\n2\n3\n5\n4\n7\n6"], ["6 5\n1 2\n1 3\n1 4\n1 5\n1 6", "Yes\n1\n6\n5\n4\n3\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["图论", "2025", "O2优化", "图论建模", "JOI（日本）", "链表", "启发式合并"], "title": "[JOIG 2025] 最悪の記者 5 / Worst Reporter 5", "background": "水獭乌苏太郎是一名报社记者，正在报道附近举行的一场大型马拉松比赛。", "description": "共有 $N$ 名运动员参加比赛，编号从 $1$ 到 $N$ 。乌苏太郎在报道比赛时，在笔记中记录了如下信息：\n\n- 比赛开始时，$N$ 名运动员位于不同的位置上；\n- 比赛过程中，排名变化恰好发生了 $M$ 次：在第 $i(1\\le i\\le M)$ 次排名变化中，运动员 $A_i$ 和 $B_i$ 交换位置，保证排名变化前两位运动员之间没有其他运动员；\n- 没有两个排名变化同时发生。\n\n乌苏太郎想在报纸上刊登一张排名表，表示比赛结束后运动员的排名：排名表是一个长度为 $N$ 的序列 $P$，其中 $P_j$ 代表排名为 $j$ 的运动员的编号。\n\n然而乌苏太郎并没有记录排名表，也没有记录每次排名变化时哪一方的排名上升（即不知道是 $A_i$ 超过了 $B_i$ 还是反之）。于是他想让你判断是否存在一个排名表，使得不与他记录的信息矛盾；如果存在，他想让你求出字典序最小的排名表。\n\n称一个长度为 $N$ 的排名表序列 $a$ 在字典序上小于另一个长度为 $N$ 的排名表序列 $b$，当且仅当存在一个 $k(1\\le k\\le N)$ 满足如下条件：\n\n- $a_l=b_l(1\\le l\\le k-1)$；\n- $a_k<b_k$。", "inputFormat": "第一行输入两个整数 $N,M$。\n\n接下来 $M$ 行，每行输入两个整数 $A_i,B_i$。", "outputFormat": "如果不存在满足条件的排名表，输出一行一个字符串 `No`。\n\n如果存在满足条件的排名表：\n\n- 第一行输出一个字符串 `Yes`；\n- 第 $j+1(1\\le j\\le N)$ 行输出一个整数 $P_j$，其中 $P$ 表示满足条件且字典序最小的排名表。", "hint": "#### 【样例解释 #1】\n\n假设比赛开始时，运动员排名为 $1,2,3,5,4$。\n\n比赛过程如下：\n\n- 在第 $1$ 次排名变化中，运动员 $1,2$ 交换位置，排名变为 $2,1,3,5,4$；\n- 在第 $2$ 次排名变化中，运动员 $4,5$ 交换位置，排名变为 $2,1,3,4,5$；\n- 在第 $3$ 次排名变化中，运动员 $3,4$ 交换位置，排名变为 $2,1,4,3,5$；\n- 在第 $4$ 次排名变化中，运动员 $3,5$ 交换位置，排名变为 $2,1,4,5,3$；\n- 在第 $5$ 次排名变化中，运动员 $1,4$ 交换位置，排名变为 $2,4,1,5,3$；\n\n最终的排名表 $P=\\{2,4,1,5,3\\}$。可以证明这是字典序最小的。\n\n该样例满足子任务 $1,3,5$ 的限制。\n\n#### 【样例解释 #2】\n\n不存在与给定信息不矛盾的排名表。\n\n该样例满足子任务 $1,3,5$ 的限制。\n\n#### 【样例解释 #3】\n\n该样例满足所有子任务的限制。\n\n#### 【样例解释 #4】\n\n该样例满足子任务 $1,3,4,5$ 的限制。\n\n#### 【数据范围】\n\n- $2\\le N\\le 5\\times 10^5$；\n- $1\\le M\\le 5\\times 10^5$；\n- $1\\le A_i<B_i\\le N(1\\le i\\le M)$。\n\n#### 【子任务】\n\n1. （$13$ 分）$N,M\\le 8$；\n2. （$16$ 分）$A_1,A_2,\\ldots,A_M,B_1,B_2,\\ldots,B_M$ 两两不同；\n3. （$29$ 分）$N,M\\le 1000$；\n4. （$23$ 分）在第 $i(2\\le i\\le M)$ 次排名变化中，$A_i$ 和 $B_i$ 中至少有一个值在 $A_1,A_2,\\ldots,A_{i-1},B_1,B_2,\\ldots,B_{i-1}$ 中没有出现；\n5. （$19$ 分）无附加限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIG 2025] 最悪の記者 5 / Worst Reporter 5", "background": "水獭乌苏太郎是一名报社记者，正在报道附近举行的一场大型马拉松比赛。", "description": "共有 $N$ 名运动员参加比赛，编号从 $1$ 到 $N$ 。乌苏太郎在报道比赛时，在笔记中记录了如下信息：\n\n- 比赛开始时，$N$ 名运动员位于不同的位置上；\n- 比赛过程中，排名变化恰好发生了 $M$ 次：在第 $i(1\\le i\\le M)$ 次排名变化中，运动员 $A_i$ 和 $B_i$ 交换位置，保证排名变化前两位运动员之间没有其他运动员；\n- 没有两个排名变化同时发生。\n\n乌苏太郎想在报纸上刊登一张排名表，表示比赛结束后运动员的排名：排名表是一个长度为 $N$ 的序列 $P$，其中 $P_j$ 代表排名为 $j$ 的运动员的编号。\n\n然而乌苏太郎并没有记录排名表，也没有记录每次排名变化时哪一方的排名上升（即不知道是 $A_i$ 超过了 $B_i$ 还是反之）。于是他想让你判断是否存在一个排名表，使得不与他记录的信息矛盾；如果存在，他想让你求出字典序最小的排名表。\n\n称一个长度为 $N$ 的排名表序列 $a$ 在字典序上小于另一个长度为 $N$ 的排名表序列 $b$，当且仅当存在一个 $k(1\\le k\\le N)$ 满足如下条件：\n\n- $a_l=b_l(1\\le l\\le k-1)$；\n- $a_k<b_k$。", "inputFormat": "第一行输入两个整数 $N,M$。\n\n接下来 $M$ 行，每行输入两个整数 $A_i,B_i$。", "outputFormat": "如果不存在满足条件的排名表，输出一行一个字符串 `No`。\n\n如果存在满足条件的排名表：\n\n- 第一行输出一个字符串 `Yes`；\n- 第 $j+1(1\\le j\\le N)$ 行输出一个整数 $P_j$，其中 $P$ 表示满足条件且字典序最小的排名表。", "hint": "#### 【样例解释 #1】\n\n假设比赛开始时，运动员排名为 $1,2,3,5,4$。\n\n比赛过程如下：\n\n- 在第 $1$ 次排名变化中，运动员 $1,2$ 交换位置，排名变为 $2,1,3,5,4$；\n- 在第 $2$ 次排名变化中，运动员 $4,5$ 交换位置，排名变为 $2,1,3,4,5$；\n- 在第 $3$ 次排名变化中，运动员 $3,4$ 交换位置，排名变为 $2,1,4,3,5$；\n- 在第 $4$ 次排名变化中，运动员 $3,5$ 交换位置，排名变为 $2,1,4,5,3$；\n- 在第 $5$ 次排名变化中，运动员 $1,4$ 交换位置，排名变为 $2,4,1,5,3$；\n\n最终的排名表 $P=\\{2,4,1,5,3\\}$。可以证明这是字典序最小的。\n\n该样例满足子任务 $1,3,5$ 的限制。\n\n#### 【样例解释 #2】\n\n不存在与给定信息不矛盾的排名表。\n\n该样例满足子任务 $1,3,5$ 的限制。\n\n#### 【样例解释 #3】\n\n该样例满足所有子任务的限制。\n\n#### 【样例解释 #4】\n\n该样例满足子任务 $1,3,4,5$ 的限制。\n\n#### 【数据范围】\n\n- $2\\le N\\le 5\\times 10^5$；\n- $1\\le M\\le 5\\times 10^5$；\n- $1\\le A_i<B_i\\le N(1\\le i\\le M)$。\n\n#### 【子任务】\n\n1. （$13$ 分）$N,M\\le 8$；\n2. （$16$ 分）$A_1,A_2,\\ldots,A_M,B_1,B_2,\\ldots,B_M$ 两两不同；\n3. （$29$ 分）$N,M\\le 1000$；\n4. （$23$ 分）在第 $i(2\\le i\\le M)$ 次排名变化中，$A_i$ 和 $B_i$ 中至少有一个值在 $A_1,A_2,\\ldots,A_{i-1},B_1,B_2,\\ldots,B_{i-1}$ 中没有出现；\n5. （$19$ 分）无附加限制。", "locale": "zh-CN"}}}
{"pid": "P11727", "type": "P", "difficulty": 5, "samples": [["3\n1 2 3 1 2 3\n5 2 8", "13"], ["4\n1 2 1 2 3 4 4 3\n39 62 55 21", "156"], ["10\n7 2 5 8 4 10 8 2 7 5 6 3 4 1 10 9 9 1 6 3\n185163245 734376902 849123714 97860221 844860642 689054872 471545587 607735137 664633003 831663829", "3117416130"], ["15\n4 3 8 3 10 15 14 1 12 4 13 1 6 7 10 15 2 8 12 2 9 11 11 13 5 9 14 5 6 7\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "线段树", "树状数组", "2025", "O2优化", "JOI（日本）"], "title": "[JOIG 2025] 神経衰弱 2 / Pair Matching 2", "background": "", "description": "有 $2N$ 张卡牌从左到右依次放在桌子上，编号为 $1,2,\\ldots,2N$，卡牌 $i$ 上写有整数 $A_i$。对于 $x=1,2,\\ldots,N$，存在恰好两张卡牌上写的整数为 $x$。\n\n海狸比太郎决定用这些卡牌玩一个叫做“神经衰弱”的游戏；该游戏的流程如下：\n\n- 依次考虑卡牌 $i=1,2,\\ldots,2N$：\n  1. 比太郎决定是否拿起这张卡牌：如果他决定拿起，那么依次进行以下的步骤 2 至步骤 5；如果他决定不拿起（跳过该卡牌），则跳过以下的步骤；\n  2. 如果比太郎的手中持有一张写有 $A_i$ 的卡牌，那么该卡牌和卡牌 $i$ 同时消失，他获得 $V_{A_i}$ 分；\n  3. 如果比太郎左手中有一张卡牌，那么他将其丢弃；\n  4. 如果比太郎右手中有一张卡牌，那么他将其转移到左手；\n  5. 如果卡牌 $i$ 没有在步骤 2 中消失，那么他将其放在右手中。\n  \n通过上面的流程，每次得到的分数之和即为比太郎的最终得分。\n\n请求出比太郎能获得的最大得分。", "inputFormat": "第一行输入一个整数 $N$。\n\n第二行输入 $2N$ 个整数 $A_1,A_2,\\ldots,A_{2N}$。\n\n第三行输入 $N$ 个整数 $V_1,V_2,\\ldots,V_N$。", "outputFormat": "输出一行一个整数，表示最大得分。", "hint": "#### 【样例解释 #1】\n\n比太郎可以通过以下流程获得分数 $13$：\n\n1. 拿起卡牌 $1$，该卡牌上面写着 $1$；由于比太郎没有其他写着 $1$ 的纸牌，所以他将其放在右手中；\n2. 跳过卡牌 $2$；\n3. 拿起卡牌 $3$，该卡牌上面写着 $3$；由于比太郎没有其他写着 $3$ 的纸牌，所以卡牌 $1$ 从右手转移到了左手，他将卡牌 $3$ 放在右手中；\n4. 拿起卡牌 $4$，该卡牌上面写着 $1$；由于卡牌 $1$ 上也写着 $1$，所以两张牌都消失了，他获得 $V_1=5$ 分，卡牌 $3$ 则从右手转移到了左手；\n5. 跳过卡牌 $5$；\n6. 拿起卡牌 $6$，该卡牌上面写着 $3$；由于卡牌 $3$ 上也写着 $3$，所以两张牌都消失了，他获得 $V_3=8$ 分，此时他两只手上都没有任何卡牌了。\n\n可以证明这是最优的。\n\n该样例满足子任务 $1,2,3,4,5,6,8,9$ 的限制。\n\n#### 【样例解释 #2】\n\n比太郎可以通过拿起卡牌 $1,2,3,4,5,6,8$ 来获得分数 $V_1+V_2+V_3=156$。可以证明这是最优的。\n\n该样例满足子任务 $3,4,5,6,8,9$ 的限制。\n\n#### 【样例解释 #3】\n\n该样例满足子任务 $4,5,6,8,9$ 的限制。\n\n#### 【样例解释 #4】\n\n该样例满足子任务 $4,5,6,7,8,9$ 的限制。\n\n#### 【数据范围】\n\n- $1\\le N\\le 4\\times 10^5$；\n- $A_1,A_2,\\ldots,A_{2N}$ 中，对于 $x=1,2,\\ldots,N$，$x$ 正好出现两次；\n- $1\\le V_k\\le 10^9$。\n\n#### 【子任务】\n\n1. （$8$ 分）$(A_1,A_2,\\ldots,A_N)=(1,2,\\ldots,N)$，$N\\le 5000$；\n2. （$12$ 分）$(A_1,A_2,\\ldots,A_N)=(1,2,\\ldots,N)$；\n3. （$6$ 分）$N\\le 9$；\n4. （$9$ 分）$N\\le 18$；\n5. （$16$ 分）$N\\le 300$\n6. （$18$ 分）$N\\le 3000$；\n7. （$18$ 分）$N\\le 1.5\\times 10^5$，$V_k\\le 1(1\\le k\\le N)$；\n8. （$8$ 分）$N\\le 1.5\\times 10^5$；\n9. （$5$ 分）无附加限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIG 2025] 神経衰弱 2 / Pair Matching 2", "background": "", "description": "有 $2N$ 张卡牌从左到右依次放在桌子上，编号为 $1,2,\\ldots,2N$，卡牌 $i$ 上写有整数 $A_i$。对于 $x=1,2,\\ldots,N$，存在恰好两张卡牌上写的整数为 $x$。\n\n海狸比太郎决定用这些卡牌玩一个叫做“神经衰弱”的游戏；该游戏的流程如下：\n\n- 依次考虑卡牌 $i=1,2,\\ldots,2N$：\n  1. 比太郎决定是否拿起这张卡牌：如果他决定拿起，那么依次进行以下的步骤 2 至步骤 5；如果他决定不拿起（跳过该卡牌），则跳过以下的步骤；\n  2. 如果比太郎的手中持有一张写有 $A_i$ 的卡牌，那么该卡牌和卡牌 $i$ 同时消失，他获得 $V_{A_i}$ 分；\n  3. 如果比太郎左手中有一张卡牌，那么他将其丢弃；\n  4. 如果比太郎右手中有一张卡牌，那么他将其转移到左手；\n  5. 如果卡牌 $i$ 没有在步骤 2 中消失，那么他将其放在右手中。\n  \n通过上面的流程，每次得到的分数之和即为比太郎的最终得分。\n\n请求出比太郎能获得的最大得分。", "inputFormat": "第一行输入一个整数 $N$。\n\n第二行输入 $2N$ 个整数 $A_1,A_2,\\ldots,A_{2N}$。\n\n第三行输入 $N$ 个整数 $V_1,V_2,\\ldots,V_N$。", "outputFormat": "输出一行一个整数，表示最大得分。", "hint": "#### 【样例解释 #1】\n\n比太郎可以通过以下流程获得分数 $13$：\n\n1. 拿起卡牌 $1$，该卡牌上面写着 $1$；由于比太郎没有其他写着 $1$ 的纸牌，所以他将其放在右手中；\n2. 跳过卡牌 $2$；\n3. 拿起卡牌 $3$，该卡牌上面写着 $3$；由于比太郎没有其他写着 $3$ 的纸牌，所以卡牌 $1$ 从右手转移到了左手，他将卡牌 $3$ 放在右手中；\n4. 拿起卡牌 $4$，该卡牌上面写着 $1$；由于卡牌 $1$ 上也写着 $1$，所以两张牌都消失了，他获得 $V_1=5$ 分，卡牌 $3$ 则从右手转移到了左手；\n5. 跳过卡牌 $5$；\n6. 拿起卡牌 $6$，该卡牌上面写着 $3$；由于卡牌 $3$ 上也写着 $3$，所以两张牌都消失了，他获得 $V_3=8$ 分，此时他两只手上都没有任何卡牌了。\n\n可以证明这是最优的。\n\n该样例满足子任务 $1,2,3,4,5,6,8,9$ 的限制。\n\n#### 【样例解释 #2】\n\n比太郎可以通过拿起卡牌 $1,2,3,4,5,6,8$ 来获得分数 $V_1+V_2+V_3=156$。可以证明这是最优的。\n\n该样例满足子任务 $3,4,5,6,8,9$ 的限制。\n\n#### 【样例解释 #3】\n\n该样例满足子任务 $4,5,6,8,9$ 的限制。\n\n#### 【样例解释 #4】\n\n该样例满足子任务 $4,5,6,7,8,9$ 的限制。\n\n#### 【数据范围】\n\n- $1\\le N\\le 4\\times 10^5$；\n- $A_1,A_2,\\ldots,A_{2N}$ 中，对于 $x=1,2,\\ldots,N$，$x$ 正好出现两次；\n- $1\\le V_k\\le 10^9$。\n\n#### 【子任务】\n\n1. （$8$ 分）$(A_1,A_2,\\ldots,A_N)=(1,2,\\ldots,N)$，$N\\le 5000$；\n2. （$12$ 分）$(A_1,A_2,\\ldots,A_N)=(1,2,\\ldots,N)$；\n3. （$6$ 分）$N\\le 9$；\n4. （$9$ 分）$N\\le 18$；\n5. （$16$ 分）$N\\le 300$\n6. （$18$ 分）$N\\le 3000$；\n7. （$18$ 分）$N\\le 1.5\\times 10^5$，$V_k\\le 1(1\\le k\\le N)$；\n8. （$8$ 分）$N\\le 1.5\\times 10^5$；\n9. （$5$ 分）无附加限制。", "locale": "zh-CN"}}}
{"pid": "P11728", "type": "P", "difficulty": 6, "samples": [["4 5\n-20 0 20 100\n10 command 1 10\n20 command 3 -10\n30 query\n40 command 1 -30\n50 query", "180\n280"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "集训队互测", "李超线段树"], "title": "[集训队互测 2015] Robot", "background": "", "description": "小 q 有 $n$ 只机器人，一开始他把机器人放在了一条数轴上，第 $i$ 只机器人在 $a_i$ 的位置上静止，而自己站在原点。\n\n在这之后小 q 会执行一些操作，他想要命令一个机器人向左或者向右移动 $x$ 格。但是机器人似乎听不清小 q 的命令，事实上它们会以每秒 $x$ 格的速度匀速移动。\n\n看着自己的机器人越走越远，小 q 很着急，他想知道当前离他（原点）最远的机器人有多远。\n\n具体的操作以及询问见输入格式。注意，不同的机器人之间互不影响，即不用考虑两个机器人撞在了一起的情况。", "inputFormat": "共有 $m$ 个事件，输入将会按事件的时间顺序给出。\n\n第一行两个正整数 $n,m$。\n\n接下来一行 $n$ 个整数，第 $i$ 个数是 $a_i$，表示第 $i$ 个机器人初始的位置（初始移动速度为 $0$）。\n\n接下来 $m$ 行，每行行首是一个非负整数 $t_i$，表示该事件点发生的时刻（以秒为单位）。第二个是一个字符串 $S$ ，代表操作的种类。数字与字符串之间用一个空格隔开。接下来的输入按 $S$ 的种类分类。\n\n1. 若 $S$ 是 `command`，则接下来两个整数 $k_i,x_i$，表示小 q 对第 $k_i$ 个机器人执行了操作，该机器人的速度将会被重置，变为向数轴正方向每秒移动 $x_i$ 格（若 $x_i$ 为负数就相当于向数轴负方向每秒移动 $\\lvert x_i \\rvert$ 格）。保证 $1 \\leq k_i \\leq n$。\n2. 若 $S$ 是 `query`，则你需要输出当前离原点最远的机器人有多远。\n\n保证 $t_1 \\leq t_2 \\leq t_2 \\leq \\dots \\leq t_m$。\n\n（注：若同一时间发生多次操作，则按读入顺序依次执行）", "outputFormat": "对于每个 `query` 询问，输出一行，包含一个整数表示正确的答案。\n\n**由于本题数据量较大，建议使用高效的的输入输出方式。**", "hint": "### 样例解释\n\n- 第一个命令执行时，各个机器人的位置为：$-20, 0, 20, 100$。\n- 第二个命令执行时，各个机器人的位置为：$80, 0, 20, 100$。\n- 第一个询问时，各个机器人的位置为：$180, 0, -80, 100$。\n- 第三个命令执行时，各个机器人的位置为：$280, 0, -180, 100$。\n- 第二个询问时，各个机器人的位置为：$-20, 0, -280, 100$。\n\n### 数据范围\n\n设 `command` 的个数为 $C$，`query` 的个数为 $Q$。（所以 $C + Q = m$）\n\n对于所有的事件满足 $0 \\leq t_i \\leq 10^9$，对于所有的 `command` 满足 $\\lvert x_i \\rvert \\leq 10^4$。\n\n对于所有的机器人满足 $\\lvert a_i \\rvert \\leq 10^9$。\n\n所有测试数据的范围和特点如下表所示：\n\n| 测试点编号 | 数据范围 | 特殊限制 |\n| :----------: | :----------: | :----------: |\n| $1$ | $n,m\\leq 2000$ | 无 |\n| $2$ | $n,m\\leq 2000$ | 无 |\n| $3$ | $n,m\\leq 10^5$ | $-1 \\leq x_i \\leq 1$ |\n| $4$ | $n,C\\leq 10^5$，$Q\\leq 5\\times 10^5$ | 两个机器人发生碰面或者超越另一个的次数 $\\leq 4\\times 10^5$ |\n| $5$ | $n,C\\leq 10^5$，$Q\\leq 5\\times 10^5$ | 两个机器人发生碰面或者超越另一个的次数 $\\leq 4\\times 10^5$ |\n| $6$ | $n,m\\leq 10^5$ | 不会在 $t_i>0$ 时出现 `command` 操作 |\n| $7$ | $n,m\\leq 10^5$ | 不会在 $t_i>0$ 时出现 `command` 操作 |\n| $8$ | $n,m\\leq 10^5$ | 无 |\n| $9$ | $n,C\\leq 10^5$，$Q\\leq 5\\times 10^5$ | 无 |\n| $10$ | $n,C\\leq 10^5$，$Q\\leq 5\\times 10^5$ | 无 |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2015] Robot", "background": "", "description": "小 q 有 $n$ 只机器人，一开始他把机器人放在了一条数轴上，第 $i$ 只机器人在 $a_i$ 的位置上静止，而自己站在原点。\n\n在这之后小 q 会执行一些操作，他想要命令一个机器人向左或者向右移动 $x$ 格。但是机器人似乎听不清小 q 的命令，事实上它们会以每秒 $x$ 格的速度匀速移动。\n\n看着自己的机器人越走越远，小 q 很着急，他想知道当前离他（原点）最远的机器人有多远。\n\n具体的操作以及询问见输入格式。注意，不同的机器人之间互不影响，即不用考虑两个机器人撞在了一起的情况。", "inputFormat": "共有 $m$ 个事件，输入将会按事件的时间顺序给出。\n\n第一行两个正整数 $n,m$。\n\n接下来一行 $n$ 个整数，第 $i$ 个数是 $a_i$，表示第 $i$ 个机器人初始的位置（初始移动速度为 $0$）。\n\n接下来 $m$ 行，每行行首是一个非负整数 $t_i$，表示该事件点发生的时刻（以秒为单位）。第二个是一个字符串 $S$ ，代表操作的种类。数字与字符串之间用一个空格隔开。接下来的输入按 $S$ 的种类分类。\n\n1. 若 $S$ 是 `command`，则接下来两个整数 $k_i,x_i$，表示小 q 对第 $k_i$ 个机器人执行了操作，该机器人的速度将会被重置，变为向数轴正方向每秒移动 $x_i$ 格（若 $x_i$ 为负数就相当于向数轴负方向每秒移动 $\\lvert x_i \\rvert$ 格）。保证 $1 \\leq k_i \\leq n$。\n2. 若 $S$ 是 `query`，则你需要输出当前离原点最远的机器人有多远。\n\n保证 $t_1 \\leq t_2 \\leq t_2 \\leq \\dots \\leq t_m$。\n\n（注：若同一时间发生多次操作，则按读入顺序依次执行）", "outputFormat": "对于每个 `query` 询问，输出一行，包含一个整数表示正确的答案。\n\n**由于本题数据量较大，建议使用高效的的输入输出方式。**", "hint": "### 样例解释\n\n- 第一个命令执行时，各个机器人的位置为：$-20, 0, 20, 100$。\n- 第二个命令执行时，各个机器人的位置为：$80, 0, 20, 100$。\n- 第一个询问时，各个机器人的位置为：$180, 0, -80, 100$。\n- 第三个命令执行时，各个机器人的位置为：$280, 0, -180, 100$。\n- 第二个询问时，各个机器人的位置为：$-20, 0, -280, 100$。\n\n### 数据范围\n\n设 `command` 的个数为 $C$，`query` 的个数为 $Q$。（所以 $C + Q = m$）\n\n对于所有的事件满足 $0 \\leq t_i \\leq 10^9$，对于所有的 `command` 满足 $\\lvert x_i \\rvert \\leq 10^4$。\n\n对于所有的机器人满足 $\\lvert a_i \\rvert \\leq 10^9$。\n\n所有测试数据的范围和特点如下表所示：\n\n| 测试点编号 | 数据范围 | 特殊限制 |\n| :----------: | :----------: | :----------: |\n| $1$ | $n,m\\leq 2000$ | 无 |\n| $2$ | $n,m\\leq 2000$ | 无 |\n| $3$ | $n,m\\leq 10^5$ | $-1 \\leq x_i \\leq 1$ |\n| $4$ | $n,C\\leq 10^5$，$Q\\leq 5\\times 10^5$ | 两个机器人发生碰面或者超越另一个的次数 $\\leq 4\\times 10^5$ |\n| $5$ | $n,C\\leq 10^5$，$Q\\leq 5\\times 10^5$ | 两个机器人发生碰面或者超越另一个的次数 $\\leq 4\\times 10^5$ |\n| $6$ | $n,m\\leq 10^5$ | 不会在 $t_i>0$ 时出现 `command` 操作 |\n| $7$ | $n,m\\leq 10^5$ | 不会在 $t_i>0$ 时出现 `command` 操作 |\n| $8$ | $n,m\\leq 10^5$ | 无 |\n| $9$ | $n,C\\leq 10^5$，$Q\\leq 5\\times 10^5$ | 无 |\n| $10$ | $n,C\\leq 10^5$，$Q\\leq 5\\times 10^5$ | 无 |\n", "locale": "zh-CN"}}}
{"pid": "P11729", "type": "P", "difficulty": 7, "samples": [["6 9 3 6\n3 1 5\n1 2 1\n1 3 2\n3 2 2\n2 4 5\n3 4 5\n3 5 2\n3 6 2\n6 4 4\n5 6 1", "4\n5\n5\n5\n5\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "集训队互测", "最短路"], "title": "[集训队互测 2015] Marketing network", "background": "", "description": "“世界充满着各种 if，我们存在着的这个世界也不过是为数众多的 if 的结果中的一个，而未来则更是由于无限的 if 而混沌流动着的世界。”\n\n在某一条世界线中，你可能正在经营一个跨国公司，想想是不是有点激动呢。在那一个世界中，你正被营销网络的设计问题所困扰。\n\n你的跨国公司在 $n$ 个国家设立了销售网点，国家由 $1$ 到 $n$ 编号，这 $n$ 个国家由 $m$ 条双向航线连接。如果把国家看作结点把航线看作边，可以抽象成一个无向图。\n\n你已经在其中的 $S$ 个国家设立了分公司。你会买下一些航线的 VIP 以加速你的商品运输。\n\n无论这条世界线出了什么偏差，你是 OIer 这个事实是不会改变的，所以你对 VIP 航线购买方案有着苛刻的要求：\n\n1. 以任意一个国家作为出发点，都无法只经过 VIP 航线且不经过重复的国家回到出发点。即购买的 VIP 航线形成原图的一个生成森林。\n2. 从任意一个分公司出发都可以只经过 VIP 航线到达另一个分公司。\n\n每条航线都有一个权值，表示购买该航线的 VIP 的费用。敏锐的你一定一眼发现了完成目标的最小总花费。但是这样不够任性不够土豪，这势必会影响公司未来的发展。于是机智的你决定求出总费用前 $k$ 小的 VIP 航线购买方案。\n\n两个 VIP 航线购买方案被认为是不同的，当且仅当存在至少一条航线只在其中一个购买方案中被买为 VIP。\n\n“if 只是单纯的 if 罢了。就算有这样一个存在着 good if 的平行世界，人类也不是能简单地跨过世界线，去到那里的。”\n\n但是小小地遐想一下还是很美好的，所以就请你解决这个问题吧。\n\n**简要题意：求出前 $k$ 小的生成森林，要求给定的 $S$ 个点在森林中两两可达。**", "inputFormat": "第一行，四个正整数 $n, m, S, k$。\n\n第二行，$S$ 个正整数，表示分公司所在的国家，保证读入的国家编号互不相同。\n\n接下来 $m$ 行，每行三个正整数 $u_i，v_i，c_i$，表示国家 $u_i$ 与 $v_i$ 之间有一条费用为 $c_i$ 的航线。保证 $1 \\leq u_i, v_i \\leq n$，且 $u_i \\neq v_i$。", "outputFormat": "输出 $k$ 行，每行一个正整数，第 $i$ 行的正整数表示总费用第 $i$ 小的 VIP 航线购买方案的总费用。", "hint": "### 数据范围\n\n除题面样例外的，航线和分公司所在国家均是在 $n, m, S$ 固定的情况下均匀随机生成的。对于所有航线，$c_i$ 是从 $1$ 到 $100$ 的整数中均匀随机选取的。\n\n保证一定存在至少 $k$ 种不同的 VIP 航线购买方案。\n\n（本题洛谷测试点编号较为混乱，下方表格仅作各个测试点范围的大致参考，实际评测中测试点编号与表格无关）\n\n| 测试点编号 | $n$ | $m$ | $S$ | $k$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1\\sim 5$ | $=10$ | $=20$ | $=4$ | $=10$ |\n| $6\\sim 10$ | $=50$ | $=100$ | $=10$ | $=1$ |\n| $11\\sim 15$ | $=50$ | $=100$ | $=10$ | $=1$ |\n| $16\\sim 20$ | $=50$ | $=100$ | $=5$ | $=20$ |\n| $21\\sim 25$ | $=50$ | $=100$ | $=7$ | $=50$ |\n| $26\\sim 30$ | $=50$ | $=100$ | $=9$ | $=50$ |\n| $31\\sim 35$ | $=50$ | $=100$ | $=10$ | $=50$ |\n| $36\\sim 40$ | $=50$ | $=100$ | $=11$ | $=50$ |\n| $41\\sim 45$ | $=50$ | $=100$ | $=13$ | $=50$ |\n| $46\\sim 50$ | $=50$ | $=100$ | $=15$ | $=50$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2015] Marketing network", "background": "", "description": "“世界充满着各种 if，我们存在着的这个世界也不过是为数众多的 if 的结果中的一个，而未来则更是由于无限的 if 而混沌流动着的世界。”\n\n在某一条世界线中，你可能正在经营一个跨国公司，想想是不是有点激动呢。在那一个世界中，你正被营销网络的设计问题所困扰。\n\n你的跨国公司在 $n$ 个国家设立了销售网点，国家由 $1$ 到 $n$ 编号，这 $n$ 个国家由 $m$ 条双向航线连接。如果把国家看作结点把航线看作边，可以抽象成一个无向图。\n\n你已经在其中的 $S$ 个国家设立了分公司。你会买下一些航线的 VIP 以加速你的商品运输。\n\n无论这条世界线出了什么偏差，你是 OIer 这个事实是不会改变的，所以你对 VIP 航线购买方案有着苛刻的要求：\n\n1. 以任意一个国家作为出发点，都无法只经过 VIP 航线且不经过重复的国家回到出发点。即购买的 VIP 航线形成原图的一个生成森林。\n2. 从任意一个分公司出发都可以只经过 VIP 航线到达另一个分公司。\n\n每条航线都有一个权值，表示购买该航线的 VIP 的费用。敏锐的你一定一眼发现了完成目标的最小总花费。但是这样不够任性不够土豪，这势必会影响公司未来的发展。于是机智的你决定求出总费用前 $k$ 小的 VIP 航线购买方案。\n\n两个 VIP 航线购买方案被认为是不同的，当且仅当存在至少一条航线只在其中一个购买方案中被买为 VIP。\n\n“if 只是单纯的 if 罢了。就算有这样一个存在着 good if 的平行世界，人类也不是能简单地跨过世界线，去到那里的。”\n\n但是小小地遐想一下还是很美好的，所以就请你解决这个问题吧。\n\n**简要题意：求出前 $k$ 小的生成森林，要求给定的 $S$ 个点在森林中两两可达。**", "inputFormat": "第一行，四个正整数 $n, m, S, k$。\n\n第二行，$S$ 个正整数，表示分公司所在的国家，保证读入的国家编号互不相同。\n\n接下来 $m$ 行，每行三个正整数 $u_i，v_i，c_i$，表示国家 $u_i$ 与 $v_i$ 之间有一条费用为 $c_i$ 的航线。保证 $1 \\leq u_i, v_i \\leq n$，且 $u_i \\neq v_i$。", "outputFormat": "输出 $k$ 行，每行一个正整数，第 $i$ 行的正整数表示总费用第 $i$ 小的 VIP 航线购买方案的总费用。", "hint": "### 数据范围\n\n除题面样例外的，航线和分公司所在国家均是在 $n, m, S$ 固定的情况下均匀随机生成的。对于所有航线，$c_i$ 是从 $1$ 到 $100$ 的整数中均匀随机选取的。\n\n保证一定存在至少 $k$ 种不同的 VIP 航线购买方案。\n\n（本题洛谷测试点编号较为混乱，下方表格仅作各个测试点范围的大致参考，实际评测中测试点编号与表格无关）\n\n| 测试点编号 | $n$ | $m$ | $S$ | $k$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1\\sim 5$ | $=10$ | $=20$ | $=4$ | $=10$ |\n| $6\\sim 10$ | $=50$ | $=100$ | $=10$ | $=1$ |\n| $11\\sim 15$ | $=50$ | $=100$ | $=10$ | $=1$ |\n| $16\\sim 20$ | $=50$ | $=100$ | $=5$ | $=20$ |\n| $21\\sim 25$ | $=50$ | $=100$ | $=7$ | $=50$ |\n| $26\\sim 30$ | $=50$ | $=100$ | $=9$ | $=50$ |\n| $31\\sim 35$ | $=50$ | $=100$ | $=10$ | $=50$ |\n| $36\\sim 40$ | $=50$ | $=100$ | $=11$ | $=50$ |\n| $41\\sim 45$ | $=50$ | $=100$ | $=13$ | $=50$ |\n| $46\\sim 50$ | $=50$ | $=100$ | $=15$ | $=50$ |\n", "locale": "zh-CN"}}}
{"pid": "P11730", "type": "P", "difficulty": 7, "samples": [["0\n10\n1 2 3 3 3 1 2 3 2 1\n3\n1 3 1\n10\n3 1 3\n4 3 3 2 2\n2 2 10\n1 3 2\n2 7 9\n2 7 10\n2 3 9\n2 2 8\n1 7 1\n1 4 2", "1\nyes\n1 2\n1 3\n0 3\n1 1\n1 1\n1 1\n2 1\n2 1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["字符串", "2015", "集训队互测"], "title": "[集训队互测 2015] Sone2", "background": "", "description": "Sone 有一只调皮的宠物 Jie。\n\n某天，Sone 在研究串匹配问题。\n\n在他出门的时候在桌子上放了两个字符串：一个长度为 $n$ 的字符串 $a$ 和一个长度为 $m$ 的字符串 $b$。设 $\\Sigma$ 为字符串的字符集大小，即字符串中每个字符都是 $1$ 到 $\\Sigma$ 之间的整数。\n\n在走之前，Sone 严肃地警告 Jie：你不准动 $b$ 串，那个串很重要！\n\n于是，Jie 就只能调戏 $a$ 串。\n\n设 $a[l:r]$ 表示 $a$ 串第 $l$ 个字符到第 $r$ 个字符之间的子串。特别地，当 $l>r$ 时，$a[l:r]$ 表示空串。\n\nJie 定义了一个关于 $s$ 串和 $t$ 串的函数：\n\n$$f(s,t)=\\max_{s[1:k]=t[1:k]}k$$\n\n即 $s$ 和 $t$ 的最长公共前缀的长度。\n\nJie 又定义了一个关于 $a$ 串和 $b$ 串的函数 $F(a,b)$。$F(a,b)$ 的值是一个二元组 $(x,y)$，其中 $x$ 为：\n\n$$x=\\max_{i=1}^{\\lvert a \\rvert} f(a[i:\\lvert a \\rvert],b)$$\n\n而 $y$ 表示满足 $f(a[i:\\lvert a \\rvert], b) = x$ 的 $i$ 的个数。\n\n本来问题很简单的，但由于 Jie 太调皮了，一共有 $q$ 个时刻，每个时刻他会有四种行为：\n\n1. 他会修改 $a$ 串的某一位，然后询问 $F(a,b)$。（操作后 $a$ 不会还原）\n2. 他会选择 $a$ 串中的一个子串 $c$，询问 $F(c,b)$。\n3. 他会选择 $b$ 串的两个后缀，并询问这两个后缀的最长公共前缀的长度。\n4. 他会选择 $b$ 串的两个子串 $s_1,s_2$，并询问把 $s_1$ 和 $s_2$ 串联起来得到的字符串是否是 $b$ 串的子串，是的话输出 `yes`，否则输出 `no`（不含引号）。\n\n于是，Jie 困扰了，希望聪明的你能解决这个问题。", "inputFormat": "设 $\\Sigma$ 为字符串的字符集大小，即字符串中每个字符都是 $1$ 到 $\\Sigma$ 之间的整数。\n\n第一行一个整数表示测试点编号。（样例和 Extra Test 中测试点编号为 $0$  到 $20$ 间的任意整数）\n\n第二行一个正整数表示 $a$ 串的长度 $n$。\n\n第三行 $n$ 个 $1$ 到 $\\Sigma$ 间的整数表示 $a$ 串。\n\n第四行一个正整数表示 $b$ 串的长度 $m$。\n\n第五行 $m$ 个 $1$ 到 $\\Sigma$ 间的整数表示 $b$ 串。\n\n第六行一个正整数表示询问个数 $q$。\n\n接下来 $q$ 行表示操作，每行包含若干个整数。第一个整数 $x$ 表示操作类型：\n\n\n1. 若 $x=1$ 则后面有两个整数 $y,z$，表示把 $a$ 串中的第 $y$ 位改成 $z$。$1 \\leq y \\leq n$，$1 \\leq z \\leq \\Sigma$。\n2. 若 $x=2$ 则后面有两个整数 $y,z$，表示询问的子串在 $a$ 串中的区间 $[y, z]$。$1 \\leq y \\leq z \\leq n$。\n3. 若 $x=3$ 则后面有两个整数 $y,z$，表示询问的两个后缀的第一个字符在 $b$ 串中的位置。$1 \\leq y, z \\leq m$。\n4. 若 $x=4$ 则后面有四个整数 $l_1,r_1,l_2,r_2$，表示询问的两个子串在 $b$ 串中的区间 $[l_1,r_1]$ 和 $[l_2,r_2]$。$1 \\leq l_1 \\leq r_1 \\leq m$，$1 \\leq l_2 \\leq r_2 \\leq m$。", "outputFormat": "有 $q$ 行，每行对应每种操作的答案。", "hint": "| 测试点编号 | $n$ | $m$ | $q$ | $\\Sigma$ | 备注 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1,2$ | $=10^3$ | $\\leq 100$ | $=1000$ | $\\leq 10^5$ | 无 |\n| $3,4$ | $=10^5$ | $\\leq 100$ | $=10^5$ | $\\leq 10^5$ | 无操作二 |\n| $5,6$ | $=10^5$ | $\\leq 30$ | $=10^5$ | $\\leq 10^5$ | 无 |\n| $7,8$ | $=10^5$ | $\\leq 10^5$| $=10^5$ | $\\leq 10^5$ | 只有操作三 |\n| $9,10$ | $=10^5$ | $\\leq 10^5$ | $=10^5$ | $\\leq 10^5$ | 只有操作四 |\n| $11\\sim 16$ | $=10^5$ | $\\leq 10^5$ | $=10^5$ | $\\leq 5$ | $b$ 串的生成方式是：人工确定每种字符出现的比例，然后均匀随机选取一个满足这一比例的字符串作为 $b$ |\n| $17\\sim 20$ | $=10^5$ | $\\leq 10^5$ | $=10^5$ | $\\leq 10^5$ | 无 |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2015] Sone2", "background": "", "description": "Sone 有一只调皮的宠物 Jie。\n\n某天，Sone 在研究串匹配问题。\n\n在他出门的时候在桌子上放了两个字符串：一个长度为 $n$ 的字符串 $a$ 和一个长度为 $m$ 的字符串 $b$。设 $\\Sigma$ 为字符串的字符集大小，即字符串中每个字符都是 $1$ 到 $\\Sigma$ 之间的整数。\n\n在走之前，Sone 严肃地警告 Jie：你不准动 $b$ 串，那个串很重要！\n\n于是，Jie 就只能调戏 $a$ 串。\n\n设 $a[l:r]$ 表示 $a$ 串第 $l$ 个字符到第 $r$ 个字符之间的子串。特别地，当 $l>r$ 时，$a[l:r]$ 表示空串。\n\nJie 定义了一个关于 $s$ 串和 $t$ 串的函数：\n\n$$f(s,t)=\\max_{s[1:k]=t[1:k]}k$$\n\n即 $s$ 和 $t$ 的最长公共前缀的长度。\n\nJie 又定义了一个关于 $a$ 串和 $b$ 串的函数 $F(a,b)$。$F(a,b)$ 的值是一个二元组 $(x,y)$，其中 $x$ 为：\n\n$$x=\\max_{i=1}^{\\lvert a \\rvert} f(a[i:\\lvert a \\rvert],b)$$\n\n而 $y$ 表示满足 $f(a[i:\\lvert a \\rvert], b) = x$ 的 $i$ 的个数。\n\n本来问题很简单的，但由于 Jie 太调皮了，一共有 $q$ 个时刻，每个时刻他会有四种行为：\n\n1. 他会修改 $a$ 串的某一位，然后询问 $F(a,b)$。（操作后 $a$ 不会还原）\n2. 他会选择 $a$ 串中的一个子串 $c$，询问 $F(c,b)$。\n3. 他会选择 $b$ 串的两个后缀，并询问这两个后缀的最长公共前缀的长度。\n4. 他会选择 $b$ 串的两个子串 $s_1,s_2$，并询问把 $s_1$ 和 $s_2$ 串联起来得到的字符串是否是 $b$ 串的子串，是的话输出 `yes`，否则输出 `no`（不含引号）。\n\n于是，Jie 困扰了，希望聪明的你能解决这个问题。", "inputFormat": "设 $\\Sigma$ 为字符串的字符集大小，即字符串中每个字符都是 $1$ 到 $\\Sigma$ 之间的整数。\n\n第一行一个整数表示测试点编号。（样例和 Extra Test 中测试点编号为 $0$  到 $20$ 间的任意整数）\n\n第二行一个正整数表示 $a$ 串的长度 $n$。\n\n第三行 $n$ 个 $1$ 到 $\\Sigma$ 间的整数表示 $a$ 串。\n\n第四行一个正整数表示 $b$ 串的长度 $m$。\n\n第五行 $m$ 个 $1$ 到 $\\Sigma$ 间的整数表示 $b$ 串。\n\n第六行一个正整数表示询问个数 $q$。\n\n接下来 $q$ 行表示操作，每行包含若干个整数。第一个整数 $x$ 表示操作类型：\n\n\n1. 若 $x=1$ 则后面有两个整数 $y,z$，表示把 $a$ 串中的第 $y$ 位改成 $z$。$1 \\leq y \\leq n$，$1 \\leq z \\leq \\Sigma$。\n2. 若 $x=2$ 则后面有两个整数 $y,z$，表示询问的子串在 $a$ 串中的区间 $[y, z]$。$1 \\leq y \\leq z \\leq n$。\n3. 若 $x=3$ 则后面有两个整数 $y,z$，表示询问的两个后缀的第一个字符在 $b$ 串中的位置。$1 \\leq y, z \\leq m$。\n4. 若 $x=4$ 则后面有四个整数 $l_1,r_1,l_2,r_2$，表示询问的两个子串在 $b$ 串中的区间 $[l_1,r_1]$ 和 $[l_2,r_2]$。$1 \\leq l_1 \\leq r_1 \\leq m$，$1 \\leq l_2 \\leq r_2 \\leq m$。", "outputFormat": "有 $q$ 行，每行对应每种操作的答案。", "hint": "| 测试点编号 | $n$ | $m$ | $q$ | $\\Sigma$ | 备注 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1,2$ | $=10^3$ | $\\leq 100$ | $=1000$ | $\\leq 10^5$ | 无 |\n| $3,4$ | $=10^5$ | $\\leq 100$ | $=10^5$ | $\\leq 10^5$ | 无操作二 |\n| $5,6$ | $=10^5$ | $\\leq 30$ | $=10^5$ | $\\leq 10^5$ | 无 |\n| $7,8$ | $=10^5$ | $\\leq 10^5$| $=10^5$ | $\\leq 10^5$ | 只有操作三 |\n| $9,10$ | $=10^5$ | $\\leq 10^5$ | $=10^5$ | $\\leq 10^5$ | 只有操作四 |\n| $11\\sim 16$ | $=10^5$ | $\\leq 10^5$ | $=10^5$ | $\\leq 5$ | $b$ 串的生成方式是：人工确定每种字符出现的比例，然后均匀随机选取一个满足这一比例的字符串作为 $b$ |\n| $17\\sim 20$ | $=10^5$ | $\\leq 10^5$ | $=10^5$ | $\\leq 10^5$ | 无 |\n", "locale": "zh-CN"}}}
{"pid": "P11731", "type": "P", "difficulty": 6, "samples": [["3 4 7\n0000\n0011\n0110\n3\n1 2 3 0010\n3\n2 1 2 0010\n3\n2 1 3 0000\n3", "0110\n0101\n0110\n0000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "集训队互测", "线性基"], "title": "[集训队互测 2015] 最大异或和", "background": "", "description": "我有一个数列 $a_1, a_2, \\dots, a_n$，每个 $a_i$ 都是小于 $2^m$ 的非负整数。\n\n现在请您实现三种操作，格式说明如下：\n\n* $1$ $x$ $y$ $w$：对于所有 $x \\leq i \\leq y$，将 $a_i$ 修改为 $a_i \\operatorname{xor} w$。其中 $w$ 是一个小于 $2^m$ 的非负整数。\n* $2$ $x$ $y$ $w$：对于所有 $x \\leq i \\leq y$，将 $a_i$ 修改为 $w$。其中 $w$ 是一个小于 $2^m$ 的非负整数。\n* $3$：从 $a_1, a_2, \\dots, a_n$ 中选出若干个数，使得选出的数异或和最大。请输出这个最大值。\n\n这里 $\\operatorname{xor}$ 表示按位异或运算，$x_1, x_2, \\dots, x_l$ 的异或和是指 $x_1 \\operatorname{xor} x_2 \\operatorname{xor} \\dots \\operatorname{xor} x_l$。", "inputFormat": "第一行三个正整数 $n,m,q$。\n\n接下来 $n$ 行为初始时 $a_1, a_2, \\dots, a_n$ 的值。\n\n接下来 $q$ 行，每行表示一个操作。操作的格式如前所述。保证 $1 \\leq x \\leq y \\leq n$。\n\n$a_1, \\dots, a_n$ 和 $w$ 均用恰好 $m$ 位的 01 串表示这个数的二进制表示。左边是最高位，右边是最低位，不足 $m$ 位的在左边补 $0$。", "outputFormat": "对于每个 $3$ 号操作，输出一个 $m$ 位 01 串表示答案的二进制表示。", "hint": "| 测试点编号 | $n$    | $m$    | $q$    | 特殊限制               |\n|:------------:|:--------:|:--------:|:--------:|:------------------------:|\n| $1$          | $= 10$   | $= 10$   | $= 1000$  | 无                    |\n| $2$          | $= 500$  | $= 500$  | $= 10$    | 无                    |\n| $3$          | $= 120$  | $= 120$  | $= 120$   | 无                    |\n| $4$          | $= 2000$ | $= 2000$ | $= 10$    | 无                    |\n| $5$          | $= 1800$ | $= 1800$ | $= 1800$  | $1, 2$ 操作中 $x = y$ |\n| $6$          | $= 1800$ | $= 1800$ | $= 1800$  | 只有 $1, 3$ 操作      |\n| $7$          | $= 1800$ | $= 1800$ | $= 1800$  | 只有 $2, 3$ 操作      |\n| $8$          | $= 1500$ | $= 1500$ | $= 1500$  | 无                    |\n| $9$          | $= 1800$ | $= 1800$ | $= 1800$  | 无                    |\n| $10$         | $= 2000$ | $= 2000$ | $= 2000$  | 无                    |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2015] 最大异或和", "background": "", "description": "我有一个数列 $a_1, a_2, \\dots, a_n$，每个 $a_i$ 都是小于 $2^m$ 的非负整数。\n\n现在请您实现三种操作，格式说明如下：\n\n* $1$ $x$ $y$ $w$：对于所有 $x \\leq i \\leq y$，将 $a_i$ 修改为 $a_i \\operatorname{xor} w$。其中 $w$ 是一个小于 $2^m$ 的非负整数。\n* $2$ $x$ $y$ $w$：对于所有 $x \\leq i \\leq y$，将 $a_i$ 修改为 $w$。其中 $w$ 是一个小于 $2^m$ 的非负整数。\n* $3$：从 $a_1, a_2, \\dots, a_n$ 中选出若干个数，使得选出的数异或和最大。请输出这个最大值。\n\n这里 $\\operatorname{xor}$ 表示按位异或运算，$x_1, x_2, \\dots, x_l$ 的异或和是指 $x_1 \\operatorname{xor} x_2 \\operatorname{xor} \\dots \\operatorname{xor} x_l$。", "inputFormat": "第一行三个正整数 $n,m,q$。\n\n接下来 $n$ 行为初始时 $a_1, a_2, \\dots, a_n$ 的值。\n\n接下来 $q$ 行，每行表示一个操作。操作的格式如前所述。保证 $1 \\leq x \\leq y \\leq n$。\n\n$a_1, \\dots, a_n$ 和 $w$ 均用恰好 $m$ 位的 01 串表示这个数的二进制表示。左边是最高位，右边是最低位，不足 $m$ 位的在左边补 $0$。", "outputFormat": "对于每个 $3$ 号操作，输出一个 $m$ 位 01 串表示答案的二进制表示。", "hint": "| 测试点编号 | $n$    | $m$    | $q$    | 特殊限制               |\n|:------------:|:--------:|:--------:|:--------:|:------------------------:|\n| $1$          | $= 10$   | $= 10$   | $= 1000$  | 无                    |\n| $2$          | $= 500$  | $= 500$  | $= 10$    | 无                    |\n| $3$          | $= 120$  | $= 120$  | $= 120$   | 无                    |\n| $4$          | $= 2000$ | $= 2000$ | $= 10$    | 无                    |\n| $5$          | $= 1800$ | $= 1800$ | $= 1800$  | $1, 2$ 操作中 $x = y$ |\n| $6$          | $= 1800$ | $= 1800$ | $= 1800$  | 只有 $1, 3$ 操作      |\n| $7$          | $= 1800$ | $= 1800$ | $= 1800$  | 只有 $2, 3$ 操作      |\n| $8$          | $= 1500$ | $= 1500$ | $= 1500$  | 无                    |\n| $9$          | $= 1800$ | $= 1800$ | $= 1800$  | 无                    |\n| $10$         | $= 2000$ | $= 2000$ | $= 2000$  | 无                    |\n", "locale": "zh-CN"}}}
{"pid": "P11732", "type": "P", "difficulty": 7, "samples": [["10 9 5\n2 1 9553\n3 2 8499\n4 3 5171\n5 1 7123\n6 3 1904\n7 5 5526\n8 7 5853\n9 6 6635\n10 8 7858\n6 4981\n7 14400\n3 21290\n4 9451\n10 16609", "15 19\n11 6\n11 3\n12 7\n12 5\n12 1\n12 8\n12 10\n13 3\n13 6\n13 9\n13 4\n13 2\n13 1\n14 4\n14 3\n14 6\n15 10\n15 8\n15 7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "点分治", "集训队互测", "Special Judge", "分治", "仙人掌"], "title": "[集训队互测 2015] Tree and Sets（暂无 Special Judge）", "background": "", "description": "wangyisong1996 有一棵小树苗，可惜由于土地沙漠化小树苗枯死了。正当 wangyisong1996 悲痛欲绝的时候，从沙子中长出了一棵仙人掌。\n\n如果一个无向连通图的任意一条边最多属于一个简单环，我们就称之为仙人掌。所谓简单环即不经过重复的结点的环。\n\n![](https://cdn.luogu.com.cn/upload/pic/4742.png)\n\n有一棵 $n$ 个结点的仙人掌，每条边有一个长度 $l$。（不同的边的长度不一定相同）\n\n有 $q$ 个点集，每个点集可以用两个整数 $u, d$ 来描述（$1 \\leq u \\leq n$），一个结点 $v$ 在这个点集中当且仅当结点 $v$ 与结点 $u$ 的距离不超过 $d$。两个结点之间的距离为它们之间的最短路径的长度。\n\n现在要求构造一个有向无环图（DAG），满足：\n\n1. 这个 DAG 至少有 $n+q$ 个结点，至多有 $1200000$ 个结点和 $2400000$ 条边。\n2. 对于每一条边，如果是从 $u$ 连向 $v$ 的，那么 $u > n$ 且 $u \\neq v$。\n3. 对于结点编号在第 $i$ 个点集（$1 \\leq i \\leq q$）的每一个结点 $x$，第 $n+i$ 个结点到第 $x$ 个结点有且仅有一条路径。\n4. 对于结点编号在 $\\{ 1, 2, \\dots, n\\}$ 中但不在第 $i$ 个点集（$1 \\leq i \\leq q$）的每一个结点 $x$，不存在第 $n+i$ 个结点到第 $x$ 个结点的路径。", "inputFormat": "第一行三个正整数 $n, m, q$，其中 $n, m$ 表示这棵仙人掌一共有 $n$ 个结点 $m$ 条边。\n\n接下来 $m$ 行，每行三个整数 $u,v,l$，表示 $u$ 和 $v$ 之间有一条长度为 $l$ 的无向边。保证 $1 \\leq u, v \\leq n$。\n\n接下来 $q$ 行，第 $i$ 行表示第 $i$ 个点集，用两个整数 $u, d$ 来描述，保证 $1 \\leq u \\leq n$。", "outputFormat": "第一行两个非负整数 $V,E$，表示你构造的 DAG 的点数和边数。\n\n接下来 $E$ 行，每行两个整数 $u,v$，表示 $u$ 到 $v$ 有一条有向边。你需要保证 $1 \\leq u, v \\leq V$。", "hint": "\n| 测试点编号 |    $n$    |         $m$         |    $q$    |\n|:--------:|:--------:|:----------------:|:--------:|\n|     1    |  $= 1000$  |  $m = n - 1$  |  $= 1000$  |\n|     2    |  $= 10000$  |  $m = n - 1$  | $= 10000$ |\n|     3    |  $= 10000$        |   $m = n - 1$       | $=10000$ |\n|     4    |  $= 9000$  |   $m = n - 1$       |  $= 9000$  |\n|     5    |  $= 10000$  |   $m = n - 1$       |  $= 10000$  |\n|     6    |  $= 1000$  |  $n - 1 \\leq m \\leq 2n - 2$  |  $= 1000$  |\n|     7    |  $= 10000$  |  $n - 1 \\leq m \\leq 2n - 2$  | $= 10000$ |\n|     8    |  $= 10000$        |  $n - 1 \\leq m \\leq 2n - 2$        |  $= 10000$ |\n|     9    |  $= 10000$       |  $n - 1 \\leq m \\leq 2n - 2$        | $= 10000$ |\n|    10    |  $= 10000$        |  $n - 1 \\leq m \\leq 2n - 2$        | $= 10000$ |\n\n第 2 个测试点的生成方式：\n```python\nfor i in range(2, 10001):\n\taddedge(i, i / 2)\n```\n\n第 3 个测试点的生成方式：\n```python\nfor i in range(2, 5000):\n\taddedge(i, i - 1)\nfor i in range(5000, 10001):\n\taddedge(i, randint(1, i - 1))\n```\n\n其中 `range(l,r)` 表示区间 $[l,r)$ 中的所有数，`randint(l,r)` 返回一个在 $[l,r]$ 内的随机整数。\n\n`addedge(u, v)` 表示在 $u$ 和 $v$ 间连一条边。（边的长度的生成方式，你以为我会告诉你吗？）", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2015] Tree and Sets（暂无 Special Judge）", "background": "", "description": "wangyisong1996 有一棵小树苗，可惜由于土地沙漠化小树苗枯死了。正当 wangyisong1996 悲痛欲绝的时候，从沙子中长出了一棵仙人掌。\n\n如果一个无向连通图的任意一条边最多属于一个简单环，我们就称之为仙人掌。所谓简单环即不经过重复的结点的环。\n\n![](https://cdn.luogu.com.cn/upload/pic/4742.png)\n\n有一棵 $n$ 个结点的仙人掌，每条边有一个长度 $l$。（不同的边的长度不一定相同）\n\n有 $q$ 个点集，每个点集可以用两个整数 $u, d$ 来描述（$1 \\leq u \\leq n$），一个结点 $v$ 在这个点集中当且仅当结点 $v$ 与结点 $u$ 的距离不超过 $d$。两个结点之间的距离为它们之间的最短路径的长度。\n\n现在要求构造一个有向无环图（DAG），满足：\n\n1. 这个 DAG 至少有 $n+q$ 个结点，至多有 $1200000$ 个结点和 $2400000$ 条边。\n2. 对于每一条边，如果是从 $u$ 连向 $v$ 的，那么 $u > n$ 且 $u \\neq v$。\n3. 对于结点编号在第 $i$ 个点集（$1 \\leq i \\leq q$）的每一个结点 $x$，第 $n+i$ 个结点到第 $x$ 个结点有且仅有一条路径。\n4. 对于结点编号在 $\\{ 1, 2, \\dots, n\\}$ 中但不在第 $i$ 个点集（$1 \\leq i \\leq q$）的每一个结点 $x$，不存在第 $n+i$ 个结点到第 $x$ 个结点的路径。", "inputFormat": "第一行三个正整数 $n, m, q$，其中 $n, m$ 表示这棵仙人掌一共有 $n$ 个结点 $m$ 条边。\n\n接下来 $m$ 行，每行三个整数 $u,v,l$，表示 $u$ 和 $v$ 之间有一条长度为 $l$ 的无向边。保证 $1 \\leq u, v \\leq n$。\n\n接下来 $q$ 行，第 $i$ 行表示第 $i$ 个点集，用两个整数 $u, d$ 来描述，保证 $1 \\leq u \\leq n$。", "outputFormat": "第一行两个非负整数 $V,E$，表示你构造的 DAG 的点数和边数。\n\n接下来 $E$ 行，每行两个整数 $u,v$，表示 $u$ 到 $v$ 有一条有向边。你需要保证 $1 \\leq u, v \\leq V$。", "hint": "\n| 测试点编号 |    $n$    |         $m$         |    $q$    |\n|:--------:|:--------:|:----------------:|:--------:|\n|     1    |  $= 1000$  |  $m = n - 1$  |  $= 1000$  |\n|     2    |  $= 10000$  |  $m = n - 1$  | $= 10000$ |\n|     3    |  $= 10000$        |   $m = n - 1$       | $=10000$ |\n|     4    |  $= 9000$  |   $m = n - 1$       |  $= 9000$  |\n|     5    |  $= 10000$  |   $m = n - 1$       |  $= 10000$  |\n|     6    |  $= 1000$  |  $n - 1 \\leq m \\leq 2n - 2$  |  $= 1000$  |\n|     7    |  $= 10000$  |  $n - 1 \\leq m \\leq 2n - 2$  | $= 10000$ |\n|     8    |  $= 10000$        |  $n - 1 \\leq m \\leq 2n - 2$        |  $= 10000$ |\n|     9    |  $= 10000$       |  $n - 1 \\leq m \\leq 2n - 2$        | $= 10000$ |\n|    10    |  $= 10000$        |  $n - 1 \\leq m \\leq 2n - 2$        | $= 10000$ |\n\n第 2 个测试点的生成方式：\n```python\nfor i in range(2, 10001):\n\taddedge(i, i / 2)\n```\n\n第 3 个测试点的生成方式：\n```python\nfor i in range(2, 5000):\n\taddedge(i, i - 1)\nfor i in range(5000, 10001):\n\taddedge(i, randint(1, i - 1))\n```\n\n其中 `range(l,r)` 表示区间 $[l,r)$ 中的所有数，`randint(l,r)` 返回一个在 $[l,r]$ 内的随机整数。\n\n`addedge(u, v)` 表示在 $u$ 和 $v$ 间连一条边。（边的长度的生成方式，你以为我会告诉你吗？）", "locale": "zh-CN"}}}
{"pid": "P11733", "type": "P", "difficulty": 6, "samples": [["3 5\n2 1 3\n2 6 7 5\n1 1 2 2\n3 1 3\n0 3 15\n3 1 3\n2 1 3 2", "5\n1\n2\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "线段树", "二分", "集训队互测"], "title": "[集训队互测 2015] 上帝之手", "background": "", "description": "上帝之手操纵着四维空间。假设四维空间中上帝关心的部分共 $n$ 天，定义第 $i$ 天结束时一个三维世界的混乱度为 $x_i$。由于一些自然的原因，第 $i$ 天该世界的混乱度会增加 $d_i$，但为了世界的平衡，每天该世界都有一个混乱度的上限值 $l_i$，即实际上 $x_i = \\min\\{x_{i-1}+d_i , l_i\\}$。\n\n上帝想对该四维空间作一系列测试，于是希望你帮忙建立一个模型。具体有以下三种测试：\n\n1. 给定 $a, b$ 和 $k$，对于所有的 $c$ 满足 $a \\leq c \\leq b$，让世界以 $l_{c-1}$ 的初始混乱度从第 $c$ 天开始发展，把第 $b$ 天的混乱度 $x_b$ 写在一张纸上。你只需告诉上帝纸上第 $k$ 大的 $x_b$ 即可。保证 $1 \\leq a \\leq b \\leq n$，且 $1 \\leq k \\leq b - a + 1$。\n2. 给定 $a, b$ 和 $x_0$，对于所有的 $c$ 满足 $a \\leq c \\leq b$，让世界以 $x_0$ 的初始混乱度从第 $c$ 天开始发展，把第 $b$ 天的混乱度 $x_b$ 写在一张纸上。你只需告诉上帝纸上最大的 $x_b$ 即可。（注意：$x_0$ 可能大于 $l_{c-1}$）。保证 $1 \\leq a \\leq b \\leq n$。\n3. 给定 $a$ 和 $b$，对于所有的 $c$ 满足 $a \\leq c \\leq b$，让世界以 $l_{c-1}$ 的初始混乱度从第 $c$ 天开始发展，把第 $b$ 天的混乱度 $x_b$ 写在一张纸上。你只需告诉上帝纸上有多少种不同的 $x_b$ 即可。保证 $1 \\leq a \\leq b \\leq n$。\n\n当然，上帝还会修改某些位置的 $l_i$。你能成功帮助上帝完成测试吗？", "inputFormat": "第一行包含两个正整数 $n$ 和 $m$，分别表示总天数和总操作（包含测试和修改）次数。\n\n第二行为 $n$ 个非负整数 $d_1, \\dots, d_n$。\n\n第三行为 $n+1$ 个非负整数 $l_0, \\dots, l_n$。含义见问题描述。\n\n第四行起的 $m$ 行，每行第一个整数 $\\mathrm{type}$ 表示操作种类。\n\n若 $\\mathrm{type}=0$，则后面跟有两个整数 $u$ 和 $x$，表示将 $l_u$ 改为 $x$。保证 $0 \\leq u \\leq n$。\n\n若 $\\mathrm{type}>0$，则 $\\mathrm{type}$ 等于题目描述中对应的测试种类编号。$\\mathrm{type} = 1$ 时后面跟有三个整数 $a, b$ 和 $k$；$\\mathrm{type} = 2$ 时后面跟有三个整数 $a, b$ 和 $x_0$；$\\mathrm{type} = 3$ 时后面跟有两个整数 $a$ 和 $b$。具体含义见问题描述。", "outputFormat": "对于每个测试输出一行，包含一个整数表示测试结果。", "hint": "- 对于前 $10\\%$ 的数据，$n, m \\leq 100$；\n- 对于前 $20\\%$ 的数据，$n, m \\leq 5000$；\n- 对于另 $10\\%$ 的数据，$\\mathrm{type} \\leq 1$；\n- 对于另 $20\\%$ 的数据，$\\mathrm{type} \\leq 2$；\n- 对于另 $15\\%$ 的数据，$\\mathrm{type} = 0$ 或 $3$；\n- 对于 $100\\%$ 的数据，$n \\leq 10^5$，$m \\leq 2 \\times 10^5$，$0 \\leq d_i \\leq 10^4$，$0 \\leq l_i \\leq 10^9$。第二类测试操作中 $0 \\leq x_0 \\leq 10^9$，修改操作中 $0 \\leq x \\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2015] 上帝之手", "background": "", "description": "上帝之手操纵着四维空间。假设四维空间中上帝关心的部分共 $n$ 天，定义第 $i$ 天结束时一个三维世界的混乱度为 $x_i$。由于一些自然的原因，第 $i$ 天该世界的混乱度会增加 $d_i$，但为了世界的平衡，每天该世界都有一个混乱度的上限值 $l_i$，即实际上 $x_i = \\min\\{x_{i-1}+d_i , l_i\\}$。\n\n上帝想对该四维空间作一系列测试，于是希望你帮忙建立一个模型。具体有以下三种测试：\n\n1. 给定 $a, b$ 和 $k$，对于所有的 $c$ 满足 $a \\leq c \\leq b$，让世界以 $l_{c-1}$ 的初始混乱度从第 $c$ 天开始发展，把第 $b$ 天的混乱度 $x_b$ 写在一张纸上。你只需告诉上帝纸上第 $k$ 大的 $x_b$ 即可。保证 $1 \\leq a \\leq b \\leq n$，且 $1 \\leq k \\leq b - a + 1$。\n2. 给定 $a, b$ 和 $x_0$，对于所有的 $c$ 满足 $a \\leq c \\leq b$，让世界以 $x_0$ 的初始混乱度从第 $c$ 天开始发展，把第 $b$ 天的混乱度 $x_b$ 写在一张纸上。你只需告诉上帝纸上最大的 $x_b$ 即可。（注意：$x_0$ 可能大于 $l_{c-1}$）。保证 $1 \\leq a \\leq b \\leq n$。\n3. 给定 $a$ 和 $b$，对于所有的 $c$ 满足 $a \\leq c \\leq b$，让世界以 $l_{c-1}$ 的初始混乱度从第 $c$ 天开始发展，把第 $b$ 天的混乱度 $x_b$ 写在一张纸上。你只需告诉上帝纸上有多少种不同的 $x_b$ 即可。保证 $1 \\leq a \\leq b \\leq n$。\n\n当然，上帝还会修改某些位置的 $l_i$。你能成功帮助上帝完成测试吗？", "inputFormat": "第一行包含两个正整数 $n$ 和 $m$，分别表示总天数和总操作（包含测试和修改）次数。\n\n第二行为 $n$ 个非负整数 $d_1, \\dots, d_n$。\n\n第三行为 $n+1$ 个非负整数 $l_0, \\dots, l_n$。含义见问题描述。\n\n第四行起的 $m$ 行，每行第一个整数 $\\mathrm{type}$ 表示操作种类。\n\n若 $\\mathrm{type}=0$，则后面跟有两个整数 $u$ 和 $x$，表示将 $l_u$ 改为 $x$。保证 $0 \\leq u \\leq n$。\n\n若 $\\mathrm{type}>0$，则 $\\mathrm{type}$ 等于题目描述中对应的测试种类编号。$\\mathrm{type} = 1$ 时后面跟有三个整数 $a, b$ 和 $k$；$\\mathrm{type} = 2$ 时后面跟有三个整数 $a, b$ 和 $x_0$；$\\mathrm{type} = 3$ 时后面跟有两个整数 $a$ 和 $b$。具体含义见问题描述。", "outputFormat": "对于每个测试输出一行，包含一个整数表示测试结果。", "hint": "- 对于前 $10\\%$ 的数据，$n, m \\leq 100$；\n- 对于前 $20\\%$ 的数据，$n, m \\leq 5000$；\n- 对于另 $10\\%$ 的数据，$\\mathrm{type} \\leq 1$；\n- 对于另 $20\\%$ 的数据，$\\mathrm{type} \\leq 2$；\n- 对于另 $15\\%$ 的数据，$\\mathrm{type} = 0$ 或 $3$；\n- 对于 $100\\%$ 的数据，$n \\leq 10^5$，$m \\leq 2 \\times 10^5$，$0 \\leq d_i \\leq 10^4$，$0 \\leq l_i \\leq 10^9$。第二类测试操作中 $0 \\leq x_0 \\leq 10^9$，修改操作中 $0 \\leq x \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P11734", "type": "P", "difficulty": 6, "samples": [["6 13\n1 2\n1 3\n2 3\n1 4\n4 2\n3 4\n5 2\n3 5\n5 4\n6 2\n6 3\n6 4\n6 5", "16974"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "集训队互测", "快速沃尔什变换 FWT", "集合幂级数，子集卷积"], "title": "[集训队互测 2015] 胡策的统计", "background": "", "description": "在 OI 界，有一位无人不知无人不晓，OI 水平前无古人后无来者的胡策，江湖人称一眼秒题胡大爷！\n\n今天胡策在研究无向图的连通性。对于一个无向图定义它的连通值为该图连通块数的阶乘。\n\n为了研究连通值的性质，胡策随手画了一个 $n$ 个结点的简单无向图 $G$，结点分别编号为 $1, \\dots, n$，他想统计出 $G$ 的所有生成子图的连通值之和。\n\n胡策当然会做啦！但是他想考考你。你只用输出结果对 $998244353$ （$7 \\times 17 \\times 2^{23} + 1$，一个质数） 取模后的结果。\n\n简单无向图即无重边无自环的无向图。生成子图即原图中删去若干条边（可以是 $0$ 条）后形成的图。", "inputFormat": "第一行两个整数 $n, m$，表示 $G$ 的结点数和边数。保证 $n \\geq 1，m \\geq 0$。\n\n接下来 $m$ 行，每行两个整数 $v, u$，表示 $v$ 号结点和 $u$ 号结点之间有一条无向边。保证 $1 \\leq v, u \\leq n$，保证没有重边和自环。", "outputFormat": "一行，一个整数表示答案。", "hint": "| 测试点编号 | $n \\leq$ | 特殊限制 |\n| :----------: | :----------: | :----------: |\n| $1$ | $6$ | 无 |\n| $2$ | $10$ | 无 |\n| $3$ | $10$ | 无 |\n| $4$ | $17$ | 无 |\n| $5$ | $17$ | 无 |\n| $6$ | $17$ | 无 |\n| $7$ | $20$ | $G$ 为完全图 |\n| $8$ | $20$ | 无 |\n| $9$ | $20$ | 无 |\n| $10$ | $20$ | 无 |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2015] 胡策的统计", "background": "", "description": "在 OI 界，有一位无人不知无人不晓，OI 水平前无古人后无来者的胡策，江湖人称一眼秒题胡大爷！\n\n今天胡策在研究无向图的连通性。对于一个无向图定义它的连通值为该图连通块数的阶乘。\n\n为了研究连通值的性质，胡策随手画了一个 $n$ 个结点的简单无向图 $G$，结点分别编号为 $1, \\dots, n$，他想统计出 $G$ 的所有生成子图的连通值之和。\n\n胡策当然会做啦！但是他想考考你。你只用输出结果对 $998244353$ （$7 \\times 17 \\times 2^{23} + 1$，一个质数） 取模后的结果。\n\n简单无向图即无重边无自环的无向图。生成子图即原图中删去若干条边（可以是 $0$ 条）后形成的图。", "inputFormat": "第一行两个整数 $n, m$，表示 $G$ 的结点数和边数。保证 $n \\geq 1，m \\geq 0$。\n\n接下来 $m$ 行，每行两个整数 $v, u$，表示 $v$ 号结点和 $u$ 号结点之间有一条无向边。保证 $1 \\leq v, u \\leq n$，保证没有重边和自环。", "outputFormat": "一行，一个整数表示答案。", "hint": "| 测试点编号 | $n \\leq$ | 特殊限制 |\n| :----------: | :----------: | :----------: |\n| $1$ | $6$ | 无 |\n| $2$ | $10$ | 无 |\n| $3$ | $10$ | 无 |\n| $4$ | $17$ | 无 |\n| $5$ | $17$ | 无 |\n| $6$ | $17$ | 无 |\n| $7$ | $20$ | $G$ 为完全图 |\n| $8$ | $20$ | 无 |\n| $9$ | $20$ | 无 |\n| $10$ | $20$ | 无 |\n", "locale": "zh-CN"}}}
{"pid": "P11735", "type": "P", "difficulty": 6, "samples": [["3 3\n1 1 3 2 3\n1 2 2 4 5\n2 1 3", "867840008"], ["1000000000 3\n1 1 12450 6666666 23333333\n1 6666 99999 2333 44444\n2 1 1000000000", "431287288"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2015", "平衡树", "集训队互测"], "title": "[集训队互测 2015] 胡策的数列", "background": "", "description": "在 OI 界，有一个无人不知无人不晓，OI 水平前无古人后无来者的胡策，江湖人称一眼秒题胡大爷！\n\n今天胡策正在研究一个远古传下来的数列：$a_0, a_1, a_2, \\dots$，数列的第 $k$ 项为 $a_k$。这个数列有特别的性质，对于 $i > 1$ 有：$25 a_i + 20 a_{i - 1} = 12 a_{i - 2}$。因为流传的时间太过久远，$a_0$ 和 $a_1$ 的值都已经看不清了，但是在最后还记载着，这个数列有一个特别的性质：对于任意的 $i \\geq 0$，都有  $a_i \\geq 0$。\n\n然而胡策已经看穿了一切：对于任意一个正数 $t$，满足 $a_0 = t$ 的数列 $a$ 是唯一的！但是，他想拿这个问题考一考拜胡策为师的你。\n\n具体来说，胡策会给你一个长度为 $n$ 的表格，一开始每个格子都写着 $0$。有时他会让你将 $a_0 = t$ 时的数列 $a$ 从第 $p$ 项到第 $p + r - l$ 项的值分别写入表格中第 $l$ 到第 $r$ 格（覆盖原有的值），有时他会询问表格中某一段连续的格子中的数的和。\n\n当然，作为胡策的弟子，你必须在胡策提出一个询问的时候马上作出回应。\n\n因为这是一个远古的问题，胡策只给了你一台远古的计算机，它只有 64MB 的内存。", "inputFormat": "第一行两个正整数 $n,m$。分别表示表格的长度和操作个数。\n\n接下来 $m$ 行，每行描述一个操作。每行的第一个整数 $\\mathrm{type}$ 描述了操作的类型，$\\mathrm{type} = 1$ 表示是修改操作，$\\mathrm{type} = 2$ 表示是询问操作。\n\n如果是修改操作，接下来有四个整数 $l,r,t,p$，意义如上所述。\n\n如果是询问操作，接下来有两个整数 $l,r$，意义如上所述。\n\n由于胡策需要确定你是在线回答他的问题，输入中的 $l, r$ 是加密了的。于是你需要把输入中的 $l, r$ 分别异或 $\\mathrm{lastans}$ 来得到实际的 $l, r$。$\\mathrm{lastans}$ 表示上一次询问操作的答案，初始为 $0$。保证实际的 $l, r$ 满足 $1 \\leq l \\leq r \\leq n$。", "outputFormat": "对每个询问操作输出一行，表示询问的答案。\n\n答案一定能写成 $\\frac{v}{u}$ 的形式，其中 $v, u$ 是互质的整数，且 $u > 0$。为了避免分数，你只用输出一个介于 $0$ 到 $10^9 + 8$ 之间的整数 $x$ 满足 $ux \\equiv v \\pmod{10^9 + 9}$ 来表示答案。显然在本题中，这样的 $x$ 是唯一的。", "hint": "### 数据范围\n\n- 对于 20% 的数据，$n,m \\leq 1000$。\n- 对于 50% 的数据，$n,m \\leq 30000$。\n- 对于 100% 的数据，$1 \\leq n \\leq 10^9$，$1 \\leq m \\leq 10^5$，$1 \\leq t \\leq 10^9$，$1 \\leq p \\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2015] 胡策的数列", "background": "", "description": "在 OI 界，有一个无人不知无人不晓，OI 水平前无古人后无来者的胡策，江湖人称一眼秒题胡大爷！\n\n今天胡策正在研究一个远古传下来的数列：$a_0, a_1, a_2, \\dots$，数列的第 $k$ 项为 $a_k$。这个数列有特别的性质，对于 $i > 1$ 有：$25 a_i + 20 a_{i - 1} = 12 a_{i - 2}$。因为流传的时间太过久远，$a_0$ 和 $a_1$ 的值都已经看不清了，但是在最后还记载着，这个数列有一个特别的性质：对于任意的 $i \\geq 0$，都有  $a_i \\geq 0$。\n\n然而胡策已经看穿了一切：对于任意一个正数 $t$，满足 $a_0 = t$ 的数列 $a$ 是唯一的！但是，他想拿这个问题考一考拜胡策为师的你。\n\n具体来说，胡策会给你一个长度为 $n$ 的表格，一开始每个格子都写着 $0$。有时他会让你将 $a_0 = t$ 时的数列 $a$ 从第 $p$ 项到第 $p + r - l$ 项的值分别写入表格中第 $l$ 到第 $r$ 格（覆盖原有的值），有时他会询问表格中某一段连续的格子中的数的和。\n\n当然，作为胡策的弟子，你必须在胡策提出一个询问的时候马上作出回应。\n\n因为这是一个远古的问题，胡策只给了你一台远古的计算机，它只有 64MB 的内存。", "inputFormat": "第一行两个正整数 $n,m$。分别表示表格的长度和操作个数。\n\n接下来 $m$ 行，每行描述一个操作。每行的第一个整数 $\\mathrm{type}$ 描述了操作的类型，$\\mathrm{type} = 1$ 表示是修改操作，$\\mathrm{type} = 2$ 表示是询问操作。\n\n如果是修改操作，接下来有四个整数 $l,r,t,p$，意义如上所述。\n\n如果是询问操作，接下来有两个整数 $l,r$，意义如上所述。\n\n由于胡策需要确定你是在线回答他的问题，输入中的 $l, r$ 是加密了的。于是你需要把输入中的 $l, r$ 分别异或 $\\mathrm{lastans}$ 来得到实际的 $l, r$。$\\mathrm{lastans}$ 表示上一次询问操作的答案，初始为 $0$。保证实际的 $l, r$ 满足 $1 \\leq l \\leq r \\leq n$。", "outputFormat": "对每个询问操作输出一行，表示询问的答案。\n\n答案一定能写成 $\\frac{v}{u}$ 的形式，其中 $v, u$ 是互质的整数，且 $u > 0$。为了避免分数，你只用输出一个介于 $0$ 到 $10^9 + 8$ 之间的整数 $x$ 满足 $ux \\equiv v \\pmod{10^9 + 9}$ 来表示答案。显然在本题中，这样的 $x$ 是唯一的。", "hint": "### 数据范围\n\n- 对于 20% 的数据，$n,m \\leq 1000$。\n- 对于 50% 的数据，$n,m \\leq 30000$。\n- 对于 100% 的数据，$1 \\leq n \\leq 10^9$，$1 \\leq m \\leq 10^5$，$1 \\leq t \\leq 10^9$，$1 \\leq p \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P11736", "type": "P", "difficulty": 7, "samples": [["3\n0 1 1\n0 1 2", "0.266666667"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "集训队互测", "Special Judge", "期望", "高斯消元"], "title": "[集训队互测 2015] 胡策的小树", "background": "", "description": "在 OI 界，有一位无人不知无人不晓，OI 水平前无古人后无来者的胡策，江湖人称一眼秒题胡大爷。\n\n胡策最近从一名自称是小 O 的神秘男子那里收到了一棵神奇的小树苗。\n\n这是一棵 $n$ 个节点的有根树，节点标号为 $1, \\dots, n$，其中 $1$ 号点为根。\n\n这棵有根树上每个点都有一个权值，点 $i$ 的权值为 $a_i$。$a_1, \\dots, a_n$ 构成了一个 $0\\sim n-1$ 的排列，且 $a_1=0$。\n\n胡策大爷十分喜欢猴子，他打算在这棵树上养 $n$ 只猴子。初始时，每个节点上将放着恰好一只猴子。猴子们十分好动，每过一秒，每只在 $i$ 节点的猴子会设法往 $i$ 的父亲节点上跳，有 $p(i)$ 的概率成功跳到父亲节点；否则跳跃失败，将等概率地随机落到子树 $i$ 里某个节点上（包括点 $i$）。\n\n因为根节点没有父亲，所以 $p(1)=0$。对于 $2\\leq i\\leq n$，有 $p(i)=\\frac{a_i}{n}$；\n\n在第 $i$ 秒，胡策会观察并记录这 $n$ 只猴子中成功跳上父亲结点的猴子所占的比例 $g_i$。胡策认为 $g_0, \\dots, g_T$ 的平均值就是这群猴子们生活的幸福指数，为保证准确，其中 $T$ 为很大很大的值，为 $(n+1)^{99999^{99999^{99999}}}$\n\n为了让猴子们的幸福指数的期望更大，胡策又从那名自称是小 O 的神秘男子那里买来了一袋叫“金坷垃”的肥料。如果给这棵有根树掺 $x$ 克的金坷垃，那么这棵树每个点 $i$ 的权值将变化成 $(a_i+x)\\bmod n$。因为胡策是土豪有钱任性，$x$ 可以取任意非负整数。\n\n请你告诉胡策，他该掺多少克的金坷垃，才能使猴子们幸福指数的期望最大呢？", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个用空格隔开的非负整数，第 $i$ 个为节点 $i$ 的父亲节点编号 $f_i$。（$f_1=0$，对于 $i>1$ 有 $1\\leq f_i< i$）\n\n第三行 $n$ 个用空格隔开的非负整数，为一个 $0\\sim n-1$ 的排列，第 $i$ 个表示 $a_i$。", "outputFormat": "一行一个实数，表示掺适量的金坷垃时的最大幸福指数期望。\n\n你的答案被认为是正确的当且仅当你的答案与标准答案的绝对误差或相对误差不超过 $10^{-9}$。", "hint": "- 对于 $10\\%$ 的数据：$n = 2$。\n- 对于 $20\\%$ 的数据：$n\\leq 5$。\n- 对于 $30\\%$ 的数据：$n\\leq 100$。\n- 对于 $50\\%$ 的数据：$n\\leq 2000$。\n- 对于 $70\\%$ 的数据：$n\\leq 100000$。\n- 对于 $100\\%$ 的数据：$2\\leq n\\leq 500000$。\n\n数据保证有一定梯度。\n\n数据都是随机生成的。即：节点 $i$ 的父亲是从 $1\\sim i-1$ 中随机选取的，$a_1 \\dots a_n$ 是一个 $0 \\sim n-1$ 的随机排列。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2015] 胡策的小树", "background": "", "description": "在 OI 界，有一位无人不知无人不晓，OI 水平前无古人后无来者的胡策，江湖人称一眼秒题胡大爷。\n\n胡策最近从一名自称是小 O 的神秘男子那里收到了一棵神奇的小树苗。\n\n这是一棵 $n$ 个节点的有根树，节点标号为 $1, \\dots, n$，其中 $1$ 号点为根。\n\n这棵有根树上每个点都有一个权值，点 $i$ 的权值为 $a_i$。$a_1, \\dots, a_n$ 构成了一个 $0\\sim n-1$ 的排列，且 $a_1=0$。\n\n胡策大爷十分喜欢猴子，他打算在这棵树上养 $n$ 只猴子。初始时，每个节点上将放着恰好一只猴子。猴子们十分好动，每过一秒，每只在 $i$ 节点的猴子会设法往 $i$ 的父亲节点上跳，有 $p(i)$ 的概率成功跳到父亲节点；否则跳跃失败，将等概率地随机落到子树 $i$ 里某个节点上（包括点 $i$）。\n\n因为根节点没有父亲，所以 $p(1)=0$。对于 $2\\leq i\\leq n$，有 $p(i)=\\frac{a_i}{n}$；\n\n在第 $i$ 秒，胡策会观察并记录这 $n$ 只猴子中成功跳上父亲结点的猴子所占的比例 $g_i$。胡策认为 $g_0, \\dots, g_T$ 的平均值就是这群猴子们生活的幸福指数，为保证准确，其中 $T$ 为很大很大的值，为 $(n+1)^{99999^{99999^{99999}}}$\n\n为了让猴子们的幸福指数的期望更大，胡策又从那名自称是小 O 的神秘男子那里买来了一袋叫“金坷垃”的肥料。如果给这棵有根树掺 $x$ 克的金坷垃，那么这棵树每个点 $i$ 的权值将变化成 $(a_i+x)\\bmod n$。因为胡策是土豪有钱任性，$x$ 可以取任意非负整数。\n\n请你告诉胡策，他该掺多少克的金坷垃，才能使猴子们幸福指数的期望最大呢？", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个用空格隔开的非负整数，第 $i$ 个为节点 $i$ 的父亲节点编号 $f_i$。（$f_1=0$，对于 $i>1$ 有 $1\\leq f_i< i$）\n\n第三行 $n$ 个用空格隔开的非负整数，为一个 $0\\sim n-1$ 的排列，第 $i$ 个表示 $a_i$。", "outputFormat": "一行一个实数，表示掺适量的金坷垃时的最大幸福指数期望。\n\n你的答案被认为是正确的当且仅当你的答案与标准答案的绝对误差或相对误差不超过 $10^{-9}$。", "hint": "- 对于 $10\\%$ 的数据：$n = 2$。\n- 对于 $20\\%$ 的数据：$n\\leq 5$。\n- 对于 $30\\%$ 的数据：$n\\leq 100$。\n- 对于 $50\\%$ 的数据：$n\\leq 2000$。\n- 对于 $70\\%$ 的数据：$n\\leq 100000$。\n- 对于 $100\\%$ 的数据：$2\\leq n\\leq 500000$。\n\n数据保证有一定梯度。\n\n数据都是随机生成的。即：节点 $i$ 的父亲是从 $1\\sim i-1$ 中随机选取的，$a_1 \\dots a_n$ 是一个 $0 \\sim n-1$ 的随机排列。", "locale": "zh-CN"}}}
{"pid": "P11737", "type": "P", "difficulty": 7, "samples": [["0 1 1\n2 3\n-1 0 1\n0 0 1\n0 0 0\n-1 0 0\n0 0 1000000000\n0 1000000000 0\n0 0 1000000000\n333333334 333333333 333333333\n0 0 1000000000\n0 1000000000 0\n0 0 1000000000\n333333334 333333333 333333333", "0.5000000000"], ["0 1 2\n2 3\n-1 0 1\n0 0 1\n0 0 0\n-1 0 0\n0 0 1000000000\n0 1000000000 0\n0 0 1000000000\n333333334 333333333 333333333", "0 0 1000000000\n0 1000000000 0\n0 0 1000000000\n333333334 333333333 333333333"], ["0 1 3\n2 3\n-1 0 1\n0 0 1\n0 0 0\n-1 0 0", "0 0 1000000000\n0 1000000000 0\n0 0 1000000000\n333333334 333333333 333333333"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "集训队互测", "Special Judge"], "title": "[集训队互测 2015] 最优决策（暂无 Special Judge）", "background": "", "description": "决策和计策是神犇。\n\n又到了吔饭的时间，可是决策和计策没有时间去吔饭，于是他们决定选出一个人去带饭。\n\n计策提议使用石头剪刀布决出胜负，但是决策觉得这样太没有技术含量，不能做出很有趣的决策，他提出了用这样一种小游戏决定胜负：\n\n1. 双方各有一个能量槽，可以存储至多 $n$ 点能量。\n2. 双方都有大技能，当能量槽满了的时候可以释放大技能，并消耗所有能量。\n3. 除了大技能之外有 $m$ 种小技能，编号为 $1, \\dots, m$，分为三类：\n\t1. 消耗型，消耗 $x$ 个能量，只有能量不小于 $x$ 时才能使用。\n    2. 免费型，不消耗能量，任何时候都可以使用。\n    3. 补给型，使用后能获得 $x$ 个能量，但是使用后总能量如果超过 $n$ 点那么多余部分会被浪费掉。任何时候都可以使用。\n4. 技能之间有一些相克的关系。大技能克所有小技能。游戏规定了小技能间有若干个相克关系，每个关系形如：$i$ 号小技能克 $j$ 号小技能。其它技能之间没有相克关系。\n5. 每回合每个人必须选择一种可使用的技能，然后同时亮出。假如一方出的技能克对方出的技能，那么游戏结束该方获胜。否则双方更新自己的能量槽然后继续游戏。当然，如果同时出大技能那么双方都会清空能量槽然后继续游戏。\n6. 如果游戏永远都不会结束那么算作双方各赢 $0.5$ 场。\n\n决策发现自己可以用 AI 跟计策打一局，这样就不用每次自己去花力气打了。\n\n决策还发现每个游戏局面的最优策略只跟双方的能量槽有关，所以自己只需要给程序一张策略表，上面记录了每个状态下出每种技能的概率分别是多少就行了。\n\n但是计策很有计策，决策知道计策会偷偷潜入他的电脑偷看他的程序和策略表。但是由于决策使用了当前系统时间作为随机种子，所以计策并不能知道这一次到底会出什么，只知道出每种技能的概率。\n\n现在决策找到了你，请你找出一种方案使得自己的胜率不低于 $50\\%$。\n\n但同时计策也找到了你，他给了你决策的策略表，请你找出一种方案使得胜率最大。\n\n与此同时鏼也找到了你，他给出了两个人的策略表，想请你算出每个人有多少的胜率。", "inputFormat": "多组数据。第一行为测试点编号，数据组数 $\\mathrm{Case}$ 和数据类型 $\\mathrm{type}$。\n\n对于每一组数据，第一行两个正整数分别表示能量槽上限 $n$ 和小技能种类数 $m$。\n\n若 $\\mathrm{type}=1$ 则你需要解决鏼的询问，若 $\\mathrm{type}=2$ 则你需要解决计策的询问，若 $\\mathrm{type}=3$ 则你需要解决决策的询问。\n\n接下来一行 $m$ 个整数 $v_1, \\dots, v_m$ 分别表示小技能对能量槽的改变量，即使用后使用者的能量会加上 $v_i$。$v_i \\lt 0$ 表示消耗型，$v_i = 0$ 表示免费型，$v_i>0$ 表示补给型。\n\n接下来 $m$ 行每行 $m$ 个数，第 $i$ 行第 $j$ 列如果为 $1$ 表示 $i$ 号小技能克 $j$ 号小技能，如果为 $-1$ 表示 $j$ 号小技能克 $i$ 号小技能，如果为 $0$ 表示没有相克关系。保证对角线上元素均为 $0$ 且第 $i$ 行第 $j$ 列的元素等于第 $j$ 行第 $i$ 列的元素的相反数。\n\n假如 $\\mathrm{type} \\neq 3$，接下来 $n^2$ 行为决策的策略表\n\n假如 $\\mathrm{type} = 1$，接下来 $n^2$ 行为计策的策略表。\n\n### 策略表的输入输出格式\n每个能量槽有 $n + 1$ 种状态，所以游戏局面共 $(n + 1)^2$ 种。很明显假如有人能量槽满了的话他一定会放大技能，所以策略表只用记录 $n^2$ 种局面的策略。\n\n共 $n^2$ 行，第 $i$ 行（从 $0$ 开始编号）表示己方能量为 $\\lfloor \\frac{i}{n} \\rfloor$，对方能量为 $i \\bmod n$ 时的策略。\n\n每个策略占一行，共 $m$ 个整数，分别表示使用小技能 $1, \\dots, m$ 的概率乘以 $10^9$ 后的结果。保证这些数加起来为 $10^9$，保证当前不可使用的小技能的使用概率为 $0$（即某些消耗型）。", "outputFormat": "如果 $\\mathrm{type} = 1$，输出一行一个浮点数表示决策的胜率，和标准答案的绝对误差在 $10^{-6}$ 之内均算作正确。\n\n如果 $\\mathrm{type} = 2$，输出一个策略表，设该策略表对决策的策略表的胜率为 $x$，我们提供的参考解胜率为 $y$，那么当 $x>y-10^{-6}$ 时算作正确。\n\n如果 $\\mathrm{type} = 3$，输出一个策略表，我们会生成一张策略表，设你的策略表对我们的策略表的胜率为 $x$，那么当 $x>0.5-10^{-6}$ 时算作正确。\n\n注：测评时为了防止精度误差，在假如某个状态只有低于 $10^{-8}$ 的概率转移出死循环时直接将该状态胜率置为 $0.5$。", "hint": "### 数据范围\n\n| 测试点编号 | $\\mathrm{Case}$ | $n$ | $m$ | $\\mathrm{type}$ | 备注 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $=1$ | $=5$ | $=30$ | $1$ | 输入见附件 jc1.in |\n| $2$ | $=100$ | $=5$ | $=30$ | $1$ | 无 |\n| $3$ | $=100$ | $=3$ | $=5$ | $2$ | 无 |\n| $4$ | $=30$ | $=5$ | $=30$ | $2$ | 无 |\n| $5$ | $=1$ | $=3$ | $=3$ | $3$ | 游戏局面与样例一相同 |\n| $6$ | $=1$ | $=5$ | $=3$ | $3$ | 游戏局面与样例一相同 |\n| $7$ | $=100$ | $=2$ | $=5$ | $3$ | 无 |\n| $8$ | $=100$ | $=5$ | $=5$ | $3$ | 无 |\n| $9$ | $=100$ | $=2$ | $=30$ | $3$ | 无 |\n| $10$ | $=10$ | $=5$ | $=30$ | $3$ | 无 |\n\n\n除了第 $5,6$ 两个点，其他点数据均为随机生成。\n\n随机生成方式：\n\n* 对于每个技能，有 $\\frac{1}{3}$ 的概率是免费型，$\\frac{1}{3}$ 是消耗型，$\\frac{1}{3}$ 是补给型，且消耗型和补给型的 $x$ 的绝对值不超过 $3$。\n* 保证三种技能至少都有一个。\n* 小技能的相克关系生成方式：\n    * 对于每一对技能，有 $20\\%$ 的概率有相克关系：\n        * 假如使用后能量损失相同则各有 $50\\%$ 概率克对方。\n        * 假如使用后不同则收益大的一方有 $20\\%$ 的概率克对方，收益小的一方有 $80\\%$ 的概率克对方。\n        * 保证每个补给型技能至少被一个技能克。\n    * 保证至少存在一个补给型技能使得只有消耗型技能才能克它。\n* 策略表生成方式：\n    * 对于一个状态，把可使用的小技能的使用概率置为均等。由于必须要是 $10^{-9}$ 的整数倍有可能无法均匀分配，保证任意两个可使用的小技能的使用概率之差的绝对值不超过 $10^{-9}$。\n    * 然后进行 $100$ 次操作，每次操作选择两个不同的可使用的小技能 $i, j$，产生一个 $10^{-9}$ 到 $i$ 技能的使用概率之间的均匀随机数 $\\delta$，且 $\\delta$ 为 $10^{-9}$ 的整数倍。将 $i$ 的概率减少 $\\delta$，将 $j$ 的概率加上 $\\delta$。\n\n如果不理解可以参考 $1$ 号点。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2015] 最优决策（暂无 Special Judge）", "background": "", "description": "决策和计策是神犇。\n\n又到了吔饭的时间，可是决策和计策没有时间去吔饭，于是他们决定选出一个人去带饭。\n\n计策提议使用石头剪刀布决出胜负，但是决策觉得这样太没有技术含量，不能做出很有趣的决策，他提出了用这样一种小游戏决定胜负：\n\n1. 双方各有一个能量槽，可以存储至多 $n$ 点能量。\n2. 双方都有大技能，当能量槽满了的时候可以释放大技能，并消耗所有能量。\n3. 除了大技能之外有 $m$ 种小技能，编号为 $1, \\dots, m$，分为三类：\n\t1. 消耗型，消耗 $x$ 个能量，只有能量不小于 $x$ 时才能使用。\n    2. 免费型，不消耗能量，任何时候都可以使用。\n    3. 补给型，使用后能获得 $x$ 个能量，但是使用后总能量如果超过 $n$ 点那么多余部分会被浪费掉。任何时候都可以使用。\n4. 技能之间有一些相克的关系。大技能克所有小技能。游戏规定了小技能间有若干个相克关系，每个关系形如：$i$ 号小技能克 $j$ 号小技能。其它技能之间没有相克关系。\n5. 每回合每个人必须选择一种可使用的技能，然后同时亮出。假如一方出的技能克对方出的技能，那么游戏结束该方获胜。否则双方更新自己的能量槽然后继续游戏。当然，如果同时出大技能那么双方都会清空能量槽然后继续游戏。\n6. 如果游戏永远都不会结束那么算作双方各赢 $0.5$ 场。\n\n决策发现自己可以用 AI 跟计策打一局，这样就不用每次自己去花力气打了。\n\n决策还发现每个游戏局面的最优策略只跟双方的能量槽有关，所以自己只需要给程序一张策略表，上面记录了每个状态下出每种技能的概率分别是多少就行了。\n\n但是计策很有计策，决策知道计策会偷偷潜入他的电脑偷看他的程序和策略表。但是由于决策使用了当前系统时间作为随机种子，所以计策并不能知道这一次到底会出什么，只知道出每种技能的概率。\n\n现在决策找到了你，请你找出一种方案使得自己的胜率不低于 $50\\%$。\n\n但同时计策也找到了你，他给了你决策的策略表，请你找出一种方案使得胜率最大。\n\n与此同时鏼也找到了你，他给出了两个人的策略表，想请你算出每个人有多少的胜率。", "inputFormat": "多组数据。第一行为测试点编号，数据组数 $\\mathrm{Case}$ 和数据类型 $\\mathrm{type}$。\n\n对于每一组数据，第一行两个正整数分别表示能量槽上限 $n$ 和小技能种类数 $m$。\n\n若 $\\mathrm{type}=1$ 则你需要解决鏼的询问，若 $\\mathrm{type}=2$ 则你需要解决计策的询问，若 $\\mathrm{type}=3$ 则你需要解决决策的询问。\n\n接下来一行 $m$ 个整数 $v_1, \\dots, v_m$ 分别表示小技能对能量槽的改变量，即使用后使用者的能量会加上 $v_i$。$v_i \\lt 0$ 表示消耗型，$v_i = 0$ 表示免费型，$v_i>0$ 表示补给型。\n\n接下来 $m$ 行每行 $m$ 个数，第 $i$ 行第 $j$ 列如果为 $1$ 表示 $i$ 号小技能克 $j$ 号小技能，如果为 $-1$ 表示 $j$ 号小技能克 $i$ 号小技能，如果为 $0$ 表示没有相克关系。保证对角线上元素均为 $0$ 且第 $i$ 行第 $j$ 列的元素等于第 $j$ 行第 $i$ 列的元素的相反数。\n\n假如 $\\mathrm{type} \\neq 3$，接下来 $n^2$ 行为决策的策略表\n\n假如 $\\mathrm{type} = 1$，接下来 $n^2$ 行为计策的策略表。\n\n### 策略表的输入输出格式\n每个能量槽有 $n + 1$ 种状态，所以游戏局面共 $(n + 1)^2$ 种。很明显假如有人能量槽满了的话他一定会放大技能，所以策略表只用记录 $n^2$ 种局面的策略。\n\n共 $n^2$ 行，第 $i$ 行（从 $0$ 开始编号）表示己方能量为 $\\lfloor \\frac{i}{n} \\rfloor$，对方能量为 $i \\bmod n$ 时的策略。\n\n每个策略占一行，共 $m$ 个整数，分别表示使用小技能 $1, \\dots, m$ 的概率乘以 $10^9$ 后的结果。保证这些数加起来为 $10^9$，保证当前不可使用的小技能的使用概率为 $0$（即某些消耗型）。", "outputFormat": "如果 $\\mathrm{type} = 1$，输出一行一个浮点数表示决策的胜率，和标准答案的绝对误差在 $10^{-6}$ 之内均算作正确。\n\n如果 $\\mathrm{type} = 2$，输出一个策略表，设该策略表对决策的策略表的胜率为 $x$，我们提供的参考解胜率为 $y$，那么当 $x>y-10^{-6}$ 时算作正确。\n\n如果 $\\mathrm{type} = 3$，输出一个策略表，我们会生成一张策略表，设你的策略表对我们的策略表的胜率为 $x$，那么当 $x>0.5-10^{-6}$ 时算作正确。\n\n注：测评时为了防止精度误差，在假如某个状态只有低于 $10^{-8}$ 的概率转移出死循环时直接将该状态胜率置为 $0.5$。", "hint": "### 数据范围\n\n| 测试点编号 | $\\mathrm{Case}$ | $n$ | $m$ | $\\mathrm{type}$ | 备注 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $=1$ | $=5$ | $=30$ | $1$ | 输入见附件 jc1.in |\n| $2$ | $=100$ | $=5$ | $=30$ | $1$ | 无 |\n| $3$ | $=100$ | $=3$ | $=5$ | $2$ | 无 |\n| $4$ | $=30$ | $=5$ | $=30$ | $2$ | 无 |\n| $5$ | $=1$ | $=3$ | $=3$ | $3$ | 游戏局面与样例一相同 |\n| $6$ | $=1$ | $=5$ | $=3$ | $3$ | 游戏局面与样例一相同 |\n| $7$ | $=100$ | $=2$ | $=5$ | $3$ | 无 |\n| $8$ | $=100$ | $=5$ | $=5$ | $3$ | 无 |\n| $9$ | $=100$ | $=2$ | $=30$ | $3$ | 无 |\n| $10$ | $=10$ | $=5$ | $=30$ | $3$ | 无 |\n\n\n除了第 $5,6$ 两个点，其他点数据均为随机生成。\n\n随机生成方式：\n\n* 对于每个技能，有 $\\frac{1}{3}$ 的概率是免费型，$\\frac{1}{3}$ 是消耗型，$\\frac{1}{3}$ 是补给型，且消耗型和补给型的 $x$ 的绝对值不超过 $3$。\n* 保证三种技能至少都有一个。\n* 小技能的相克关系生成方式：\n    * 对于每一对技能，有 $20\\%$ 的概率有相克关系：\n        * 假如使用后能量损失相同则各有 $50\\%$ 概率克对方。\n        * 假如使用后不同则收益大的一方有 $20\\%$ 的概率克对方，收益小的一方有 $80\\%$ 的概率克对方。\n        * 保证每个补给型技能至少被一个技能克。\n    * 保证至少存在一个补给型技能使得只有消耗型技能才能克它。\n* 策略表生成方式：\n    * 对于一个状态，把可使用的小技能的使用概率置为均等。由于必须要是 $10^{-9}$ 的整数倍有可能无法均匀分配，保证任意两个可使用的小技能的使用概率之差的绝对值不超过 $10^{-9}$。\n    * 然后进行 $100$ 次操作，每次操作选择两个不同的可使用的小技能 $i, j$，产生一个 $10^{-9}$ 到 $i$ 技能的使用概率之间的均匀随机数 $\\delta$，且 $\\delta$ 为 $10^{-9}$ 的整数倍。将 $i$ 的概率减少 $\\delta$，将 $j$ 的概率加上 $\\delta$。\n\n如果不理解可以参考 $1$ 号点。", "locale": "zh-CN"}}}
{"pid": "P11738", "type": "P", "difficulty": 7, "samples": [["2\n1 2\n#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{int a, b; cin >> a >> b; cout << a + b << endl;}", "3"], ["10\n9\n6 1 7 5 1 7 2 2 4\n#include<iostream>\n#include<cstdio>\nusing namespace std;\nint n, a[100];\n\n\nint main()\n{\n    cin >> n;\n    int i, j, this_VARIABLE_is_NOT_used;\n    for (i = 1; i <= n; i = i + 1) cin >> a[i];\n    for (i = 1; i <= n; i = i + 1)\n    for (j = i + 1; j <= n; j = j + 1)\n    if (a[i] > a[j])\n    {\n        int t;\n        t = a[i];\n        a[i] = a[j];\n        a[j] = t;\n    }\n    for (i = 1; i <= n; i = i + 1)\n    {\n        cout << a[i];\n        if (i == n) cout << endl; else putchar(32);\n    }\n    return 0;\n}", "1 1 2 2 4 5 6 7 7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "2015", "集训队互测"], "title": "[集训队互测 2015] 未来程序·改", "background": "洛谷可提交代码长度最长为 50KB。如果您的代码超过 50KB，请尝试压行、替换变量名等操作。", "description": "在 2111 年，第 128 届全国青少年信息学奥林匹克冬令营前夕，Z 君找到了 2015 年，第 32 届冬令营的题目来练习。\n\n他打开了第三题 “未来程序” 这道题目：\n\n“本题是一道提交答案题，一共 10 个测试点。\n\n对于每个测试点，你会得到一段程序的源代码和这段程序的输入。你要运行这个程序，并保存这个程序的输出。\n\n遗憾的是这些程序都效率极其低下，无法在比赛的 5 个小时内得到输出。”\n\nZ 君想了一下，决定用 2111 年的计算机来试着运行这个题目，但是问题来了，Z君已经找不到 96 年前的那次比赛的测试数据了……\n\n没有给出输入数据的提交答案题就不成其“提交答案题”之名，为了解决这个问题，Z君决定将这个题目改造成传统题。\n\nZ 君知道 96 年前的计算机的性能比现在差多了，所以这道题的测试数据中，输入数据的规模被设计成很小，从而，做这道题的选手只需要暴力模拟源代码的工作流程就可以通过它。\n\n现在这道题摆到了你的面前。\n\n本题是一道传统题，一共有 10 个测试点。\n\n对于每个测试点，你的程序会得到一段程序的源代码和这段程序的输入。你的程序需要运行这段程序，并输出这段程序的输出。\n\n### **关于给出的源代码的约定**  \n\nZ 君是一名 C++ 选手。为了简化这个问题，Z君在给出的源代码中去掉了 C++ 语言的大量特性。从而这个源代码具有以下特点：  \n\n\n- 第一行必定为 `#include<iostream>` （不含引号）  \n  - 这个库中只会调用到对象 `cin`，`cout`，`endl`，`cin` 的 `>>(int)` 函数和 `cout` 的 `<<(int)` 函数。这两个函数分别用于输入和输出一个整数，返回值分别 `cin` 和 `cout`。  \n- 第二行必定为 `#include<cstdio>` （不含引号）  \n  - 这个库中只会调用到 `putchar` 函数。`putchar(c)` 会输出 ASCII 码为 $c$ 的字符，并返回 $c$。  \n- 第三行必定为 `using namespace std;` （不含引号）  \n  - 对象 `cin` 的调用不再需要通过 `std::cin` 进行，`cout` 和 `endl` 同理。  \n- `int main()` 没有任何参数。  \n- 所有的变量都是 `int` 或 `int` 数组（含高维数组）类型。  \n  - 对象 `cin`, `cout`, `endl` 是例外，注意 `putchar` 的参数也是 `int` 类型的。我们保证在运行时这个参数的值在 $0 \\sim 127$ 中。  \n  - 在运行时，不会出现数组越界问题。  \n  - 没有维度的范围为 $1$。也即，不会出现 `int a[1][1][1][1][1];` 这样的情况。  \n  - 维度的范围直接由十进制常量给出。也即，不会出现 `int a[(100+100)*2];` 这样的情况。  \n- 所有的函数都是 `int` 类型，函数的参数只可能是 `int` 类型  \n  - 注意函数的返回值可以被丢弃。  \n  - 当没有显式地返回值时，返回 $0$。  \n- `bool` 型被认为是一种特殊的 `int` 型  \n  - `==` 在两个参数相同时返回 $1$，否则返回 $0$。  \n  - `!=` 在两个参数相同时返回 $0$，否则返回 $1$。  \n  - `<` 在第一个参数小于第二个参数时返回 $1$，否则返回 $0$。  \n  - `<=` 在第一个参数小于等于第二个参数时返回 $1$，否则返回 $0$。  \n  - `>` 在第一个参数大于第二个参数时返回 $1$，否则返回 $0$。  \n  - `>=` 在第一个参数大于等于第二个参数时返回 $1$，否则返回 $0$。  \n  - `&&` 在两个参数都不为 $0$ 时返回 $1$，否则返回 $0$。  \n  - `||` 在两个参数都为 $0$ 时返回 $0$，否则返回 $1$。  \n  - `^` 在两个参数中只有一个为 $0$ 时返回 $1$，其他时候返回 $0$。  \n  - `!` 在参数为 $0$ 时返回 $1$，否则返回 $0$。  \n  - 由于 `bool` 型被 `int` 型取代了，因此所有的表达式都应该被完全计算：例如在表达式 `(a && (b = c))` 中，即使 `a` 已经被确定是 $0$，仍然需要计算 `(b = c)` 的值，尽管无论 `(b = c)` 的值如何，整个表达式的值都是 $0$。  \n- 可能用到的运算符及其优先级如下：（从高到低排列）  \n  1. `()`, `[]`  \n  2. `!`, `+`（正号）, `-`（负号）  \n  3. `*`, `/`, `%`  \n  4. `+`（加法）, `-`（减法）  \n  5. `<=`, `>=`, `<`, `>`  \n  6. `==`, `!=`  \n  7. `^`  \n  8. `&&`  \n  9. `||`  \n  10. `=`  \n  11. `cout` 的 `<<` 与 `cin` 的 `>>`。  \n- 所有 `int` 常量以十进制形式给出  \n- Z 君没有对源代码进行混淆，所以源代码是可读的，你不必担心出现大量嵌套的花括号或此类的“垃圾代码”  \n- 运行时使用的变量占用的空间的峰值不超过 $8\\texttt{MB}$。也即，$2^{21}$ 个 `int`  \n- 调用函数的深度不会超过 $10^3$ 层  \n- 可能出现连续赋值，例如 `a = (b = (c = 3) + 2) % c`  \n  - 之前对 `c` 的赋值将会反映到之后对 `c` 的引用上  \n  - `=` 是右结合的，`a = b = c` 会被看作 `a = (b = c)`  \n  - 赋值的返回值为赋值以后的值  \n- 可能出现的程序流程控制语句：  \n  - `if (statement) statement [else statement]`  \n  - `while (statement) statement`  \n  - `for ([statement]; [statement]; [statement]) statement`  \n  - 那些作为条件的 `statement` 的返回值应当被视为 `bool` 型的。具体的来说，若返回值为 $0$，则为 `false`，若返回值非 $0$，则为 `true`。在 `for` 循环中，当第二个 `[statement]` 取空时，视为 `true`。  \n- 空白字符只有新行符（即 `\\n`）和空格。  \n- 声明变量时默认初始值为 $0$，声明变量的同时不会进行赋值。  \n- 没有注释  \n- 所有的右花括号后没有分号  \n- 没有用来连接语句的逗号  \n- 没有函数和变量重名", "inputFormat": "输入文件分为两个部分。\n\n第一行，有一个整数 $N$。它描述了源代码对应的输入文件  `program.in` 中包含的整数数目。\n\n以下 $N$ 个整数构成了源代码对应的输入文件  `program.in`。\n\n这之后的部分构成了源代码 `program.cpp`。", "outputFormat": "输出文件是将 `program.cpp` 编译后输入 `program.in` 后所得到的输出。", "hint": "### 限制与约定\n\n输入的所有 `program.cpp` 都是手打的，每个输入文件的大小不超过 $7\\texttt{KB}$。  \n\n- 测试点 #1 的 `program.cpp` 见样例数据及附加文件下载。  \n- 测试点 #2 到 #4 的 `program.cpp` 符合以下格式：  \n  ```cpp\n  #include<iostream>\n  #include<cstdio>\n  using namespace std;\n  int main()\n  {\n      cout << <1> << endl;\n  }\n  ```\n  在 #2 中：`<1>` 处是一个仅包含加、减、乘、除、模运算和自然数常数的没有括号的表达式。  \n  在 #3 和 #4 中：`<1>` 处是一个不保证以上性质的表达式。  \n- 测试点 #5 中：没有除 `main` 以外的函数，并且整个程序中只有顺序结构。  \n- 测试点 #6 和 #7 中：没有除 `main` 以外的函数。  \n- 测试点 #8 中：所有的变量都是全局变量。  \n- 测试点 #9 和 #10 不保证任何特别的性质。  \n\n所有 `program.cpp` 都可以用 MinGW GCC 4.7.2 编译运行。这就是说，所有的 `program.cpp` 中都没有语法错误。然而由于编译命令的不同，直接编译得到的 `program.exe` 在运行时有可能会因未为声明的变量和未设置返回值的函数设置 $0$ 的缺省值以及 `bool` 类型的处理方式不同而与标程产生不同的输出。  \n\n为了更准确地说明程序可能出现的要素，也作为提示，下面给出了一个上下文无关文法，其初始符号为 PROGRAM。保证每个 `program.cpp` 都可被下面的文法生成，但是并非每个可被生成的程序都是合法的程序。\n\n```\nPROGRAM ::= # include < iostream > # include < cstdio > using namespace std ; FUNC_AND_VAR\n\nFUNC_AND_VAR ::=\n| ε\n| int NAME ( OPTPARAMS ) { STATEMENTS } FUNC_AND_VAR\n| int DEFINEVAR DEFINEVARS ; FUNC_AND_VAR\n\nOPTPARAMS ::=\n| ε\n| int NAME PARAMS\n\nPARAMS ::=\n| ε\n| , int NAME PARAMS\n\nSTATEMENTS ::=\n| ε\n| STATEMENT STATEMENTS\n\nSTATEMENT ::=\n| EXPRESSION ;\n| { STATEMENTS }\n| int DEFINEVAR DEFINEVARS ;\n| if ( EXPRESSION ) STATEMENT\n| if ( EXPRESSION ) STATEMENT else STATEMENT\n| for ( STATEMENT_IN_FOR ; OPTEXPRESSION ; STATEMENT_IN_FOR ) STATEMENT\n| while ( EXPRESSION ) STATEMENT\n| return EXPRESSION ;\n\nSTATEMENT_IN_FOR ::=\n| OPTEXPRESSION\n| int DEFINEVAR DEFINEVARS\n\nOPTEXPRESSION ::=\n| ε\n| EXPRESSION\n\nEXPRESSION ::=\n| UNIT9\n| EXPRESSION << UNIT9\n| EXPRESSION >> UNIT9\n\nUNIT0 ::=\n| INT_CONSTANT\n| UNIT0 [ EXPRESSION ]\n| ( EXPRESSION )\n| NAME ( OPTARGUS )    // 注：此处的 NAME 是一个函数名\n| NAME    // 注：此处的 NAME 是一个变量名\n| cin\n| cout\n| endl\n\nUNIT1 ::=\n| UNIT0\n| + UNIT1\n| - UNIT1\n| ! UNIT1\n\nUNIT2 ::=\n| UNIT1\n| UNIT2 * UNIT1\n| UNIT2 / UNIT1\n| UNIT2 % UNIT1\n\nUNIT3 ::=\n| UNIT2\n| UNIT3 + UNIT2\n| UNIT3 - UNIT2\n\nUNIT4 ::=\n| UNIT3\n| UNIT4 < UNIT3\n| UNIT4 <= UNIT3\n| UNIT4 > UNIT3\n| UNIT4 >= UNIT3\n\nUNIT5 ::=\n| UNIT4\n| UNIT5 == UNIT4\n| UNIT5 != UNIT4\n\nUNIT6 ::=\n| UNIT5\n| UNIT6 ^ UNIT5\n\nUNIT7 ::=\n| UNIT6\n| UNIT7 && UNIT6\n\nUNIT8 ::=\n| UNIT7\n| UNIT8 || UNIT7\n\nUNIT9 ::=\n| UNIT8\n| UNIT8 = UNIT9\n\nOPTARGUS ::=\n| ε\n| EXPRESSION ARGUS\n\nARGUS ::=\n| ε\n| , EXPRESSION ARGUS\n\nDEFINEVARS ::=\n| ε\n| , DEFINEVAR DEFINEVARS\n\nDEFINEVAR ::=\n| NAME\n| DEFINEVAR [ INT_CONSTANT ]\n\nNAME ::= 仅包含大小写字母、数字、下划线的非空字符串，且不以数字开头。\n\nINT_CONSTANT ::= 仅包含数字的非空字符串，且不以0开头，或这个字符串就是0。\n```", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2015] 未来程序·改", "background": "洛谷可提交代码长度最长为 50KB。如果您的代码超过 50KB，请尝试压行、替换变量名等操作。", "description": "在 2111 年，第 128 届全国青少年信息学奥林匹克冬令营前夕，Z 君找到了 2015 年，第 32 届冬令营的题目来练习。\n\n他打开了第三题 “未来程序” 这道题目：\n\n“本题是一道提交答案题，一共 10 个测试点。\n\n对于每个测试点，你会得到一段程序的源代码和这段程序的输入。你要运行这个程序，并保存这个程序的输出。\n\n遗憾的是这些程序都效率极其低下，无法在比赛的 5 个小时内得到输出。”\n\nZ 君想了一下，决定用 2111 年的计算机来试着运行这个题目，但是问题来了，Z君已经找不到 96 年前的那次比赛的测试数据了……\n\n没有给出输入数据的提交答案题就不成其“提交答案题”之名，为了解决这个问题，Z君决定将这个题目改造成传统题。\n\nZ 君知道 96 年前的计算机的性能比现在差多了，所以这道题的测试数据中，输入数据的规模被设计成很小，从而，做这道题的选手只需要暴力模拟源代码的工作流程就可以通过它。\n\n现在这道题摆到了你的面前。\n\n本题是一道传统题，一共有 10 个测试点。\n\n对于每个测试点，你的程序会得到一段程序的源代码和这段程序的输入。你的程序需要运行这段程序，并输出这段程序的输出。\n\n### **关于给出的源代码的约定**  \n\nZ 君是一名 C++ 选手。为了简化这个问题，Z君在给出的源代码中去掉了 C++ 语言的大量特性。从而这个源代码具有以下特点：  \n\n\n- 第一行必定为 `#include<iostream>` （不含引号）  \n  - 这个库中只会调用到对象 `cin`，`cout`，`endl`，`cin` 的 `>>(int)` 函数和 `cout` 的 `<<(int)` 函数。这两个函数分别用于输入和输出一个整数，返回值分别 `cin` 和 `cout`。  \n- 第二行必定为 `#include<cstdio>` （不含引号）  \n  - 这个库中只会调用到 `putchar` 函数。`putchar(c)` 会输出 ASCII 码为 $c$ 的字符，并返回 $c$。  \n- 第三行必定为 `using namespace std;` （不含引号）  \n  - 对象 `cin` 的调用不再需要通过 `std::cin` 进行，`cout` 和 `endl` 同理。  \n- `int main()` 没有任何参数。  \n- 所有的变量都是 `int` 或 `int` 数组（含高维数组）类型。  \n  - 对象 `cin`, `cout`, `endl` 是例外，注意 `putchar` 的参数也是 `int` 类型的。我们保证在运行时这个参数的值在 $0 \\sim 127$ 中。  \n  - 在运行时，不会出现数组越界问题。  \n  - 没有维度的范围为 $1$。也即，不会出现 `int a[1][1][1][1][1];` 这样的情况。  \n  - 维度的范围直接由十进制常量给出。也即，不会出现 `int a[(100+100)*2];` 这样的情况。  \n- 所有的函数都是 `int` 类型，函数的参数只可能是 `int` 类型  \n  - 注意函数的返回值可以被丢弃。  \n  - 当没有显式地返回值时，返回 $0$。  \n- `bool` 型被认为是一种特殊的 `int` 型  \n  - `==` 在两个参数相同时返回 $1$，否则返回 $0$。  \n  - `!=` 在两个参数相同时返回 $0$，否则返回 $1$。  \n  - `<` 在第一个参数小于第二个参数时返回 $1$，否则返回 $0$。  \n  - `<=` 在第一个参数小于等于第二个参数时返回 $1$，否则返回 $0$。  \n  - `>` 在第一个参数大于第二个参数时返回 $1$，否则返回 $0$。  \n  - `>=` 在第一个参数大于等于第二个参数时返回 $1$，否则返回 $0$。  \n  - `&&` 在两个参数都不为 $0$ 时返回 $1$，否则返回 $0$。  \n  - `||` 在两个参数都为 $0$ 时返回 $0$，否则返回 $1$。  \n  - `^` 在两个参数中只有一个为 $0$ 时返回 $1$，其他时候返回 $0$。  \n  - `!` 在参数为 $0$ 时返回 $1$，否则返回 $0$。  \n  - 由于 `bool` 型被 `int` 型取代了，因此所有的表达式都应该被完全计算：例如在表达式 `(a && (b = c))` 中，即使 `a` 已经被确定是 $0$，仍然需要计算 `(b = c)` 的值，尽管无论 `(b = c)` 的值如何，整个表达式的值都是 $0$。  \n- 可能用到的运算符及其优先级如下：（从高到低排列）  \n  1. `()`, `[]`  \n  2. `!`, `+`（正号）, `-`（负号）  \n  3. `*`, `/`, `%`  \n  4. `+`（加法）, `-`（减法）  \n  5. `<=`, `>=`, `<`, `>`  \n  6. `==`, `!=`  \n  7. `^`  \n  8. `&&`  \n  9. `||`  \n  10. `=`  \n  11. `cout` 的 `<<` 与 `cin` 的 `>>`。  \n- 所有 `int` 常量以十进制形式给出  \n- Z 君没有对源代码进行混淆，所以源代码是可读的，你不必担心出现大量嵌套的花括号或此类的“垃圾代码”  \n- 运行时使用的变量占用的空间的峰值不超过 $8\\texttt{MB}$。也即，$2^{21}$ 个 `int`  \n- 调用函数的深度不会超过 $10^3$ 层  \n- 可能出现连续赋值，例如 `a = (b = (c = 3) + 2) % c`  \n  - 之前对 `c` 的赋值将会反映到之后对 `c` 的引用上  \n  - `=` 是右结合的，`a = b = c` 会被看作 `a = (b = c)`  \n  - 赋值的返回值为赋值以后的值  \n- 可能出现的程序流程控制语句：  \n  - `if (statement) statement [else statement]`  \n  - `while (statement) statement`  \n  - `for ([statement]; [statement]; [statement]) statement`  \n  - 那些作为条件的 `statement` 的返回值应当被视为 `bool` 型的。具体的来说，若返回值为 $0$，则为 `false`，若返回值非 $0$，则为 `true`。在 `for` 循环中，当第二个 `[statement]` 取空时，视为 `true`。  \n- 空白字符只有新行符（即 `\\n`）和空格。  \n- 声明变量时默认初始值为 $0$，声明变量的同时不会进行赋值。  \n- 没有注释  \n- 所有的右花括号后没有分号  \n- 没有用来连接语句的逗号  \n- 没有函数和变量重名", "inputFormat": "输入文件分为两个部分。\n\n第一行，有一个整数 $N$。它描述了源代码对应的输入文件  `program.in` 中包含的整数数目。\n\n以下 $N$ 个整数构成了源代码对应的输入文件  `program.in`。\n\n这之后的部分构成了源代码 `program.cpp`。", "outputFormat": "输出文件是将 `program.cpp` 编译后输入 `program.in` 后所得到的输出。", "hint": "### 限制与约定\n\n输入的所有 `program.cpp` 都是手打的，每个输入文件的大小不超过 $7\\texttt{KB}$。  \n\n- 测试点 #1 的 `program.cpp` 见样例数据及附加文件下载。  \n- 测试点 #2 到 #4 的 `program.cpp` 符合以下格式：  \n  ```cpp\n  #include<iostream>\n  #include<cstdio>\n  using namespace std;\n  int main()\n  {\n      cout << <1> << endl;\n  }\n  ```\n  在 #2 中：`<1>` 处是一个仅包含加、减、乘、除、模运算和自然数常数的没有括号的表达式。  \n  在 #3 和 #4 中：`<1>` 处是一个不保证以上性质的表达式。  \n- 测试点 #5 中：没有除 `main` 以外的函数，并且整个程序中只有顺序结构。  \n- 测试点 #6 和 #7 中：没有除 `main` 以外的函数。  \n- 测试点 #8 中：所有的变量都是全局变量。  \n- 测试点 #9 和 #10 不保证任何特别的性质。  \n\n所有 `program.cpp` 都可以用 MinGW GCC 4.7.2 编译运行。这就是说，所有的 `program.cpp` 中都没有语法错误。然而由于编译命令的不同，直接编译得到的 `program.exe` 在运行时有可能会因未为声明的变量和未设置返回值的函数设置 $0$ 的缺省值以及 `bool` 类型的处理方式不同而与标程产生不同的输出。  \n\n为了更准确地说明程序可能出现的要素，也作为提示，下面给出了一个上下文无关文法，其初始符号为 PROGRAM。保证每个 `program.cpp` 都可被下面的文法生成，但是并非每个可被生成的程序都是合法的程序。\n\n```\nPROGRAM ::= # include < iostream > # include < cstdio > using namespace std ; FUNC_AND_VAR\n\nFUNC_AND_VAR ::=\n| ε\n| int NAME ( OPTPARAMS ) { STATEMENTS } FUNC_AND_VAR\n| int DEFINEVAR DEFINEVARS ; FUNC_AND_VAR\n\nOPTPARAMS ::=\n| ε\n| int NAME PARAMS\n\nPARAMS ::=\n| ε\n| , int NAME PARAMS\n\nSTATEMENTS ::=\n| ε\n| STATEMENT STATEMENTS\n\nSTATEMENT ::=\n| EXPRESSION ;\n| { STATEMENTS }\n| int DEFINEVAR DEFINEVARS ;\n| if ( EXPRESSION ) STATEMENT\n| if ( EXPRESSION ) STATEMENT else STATEMENT\n| for ( STATEMENT_IN_FOR ; OPTEXPRESSION ; STATEMENT_IN_FOR ) STATEMENT\n| while ( EXPRESSION ) STATEMENT\n| return EXPRESSION ;\n\nSTATEMENT_IN_FOR ::=\n| OPTEXPRESSION\n| int DEFINEVAR DEFINEVARS\n\nOPTEXPRESSION ::=\n| ε\n| EXPRESSION\n\nEXPRESSION ::=\n| UNIT9\n| EXPRESSION << UNIT9\n| EXPRESSION >> UNIT9\n\nUNIT0 ::=\n| INT_CONSTANT\n| UNIT0 [ EXPRESSION ]\n| ( EXPRESSION )\n| NAME ( OPTARGUS )    // 注：此处的 NAME 是一个函数名\n| NAME    // 注：此处的 NAME 是一个变量名\n| cin\n| cout\n| endl\n\nUNIT1 ::=\n| UNIT0\n| + UNIT1\n| - UNIT1\n| ! UNIT1\n\nUNIT2 ::=\n| UNIT1\n| UNIT2 * UNIT1\n| UNIT2 / UNIT1\n| UNIT2 % UNIT1\n\nUNIT3 ::=\n| UNIT2\n| UNIT3 + UNIT2\n| UNIT3 - UNIT2\n\nUNIT4 ::=\n| UNIT3\n| UNIT4 < UNIT3\n| UNIT4 <= UNIT3\n| UNIT4 > UNIT3\n| UNIT4 >= UNIT3\n\nUNIT5 ::=\n| UNIT4\n| UNIT5 == UNIT4\n| UNIT5 != UNIT4\n\nUNIT6 ::=\n| UNIT5\n| UNIT6 ^ UNIT5\n\nUNIT7 ::=\n| UNIT6\n| UNIT7 && UNIT6\n\nUNIT8 ::=\n| UNIT7\n| UNIT8 || UNIT7\n\nUNIT9 ::=\n| UNIT8\n| UNIT8 = UNIT9\n\nOPTARGUS ::=\n| ε\n| EXPRESSION ARGUS\n\nARGUS ::=\n| ε\n| , EXPRESSION ARGUS\n\nDEFINEVARS ::=\n| ε\n| , DEFINEVAR DEFINEVARS\n\nDEFINEVAR ::=\n| NAME\n| DEFINEVAR [ INT_CONSTANT ]\n\nNAME ::= 仅包含大小写字母、数字、下划线的非空字符串，且不以数字开头。\n\nINT_CONSTANT ::= 仅包含数字的非空字符串，且不以0开头，或这个字符串就是0。\n```", "locale": "zh-CN"}}}
