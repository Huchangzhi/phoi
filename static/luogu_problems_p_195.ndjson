{"pid": "P4944", "type": "P", "difficulty": 5, "samples": [["5 7 6\n.&...&.\n..##@..\n.&...&.\n..##@..\n.&...&.\nDWAAAA\nWDDDDD", "5 1\n0 2\n7"], ["9 9 4\n.........\n.#######.\n.......#.\n.@#.&@.#.\n&.#.&&.#.\n&&######.\n.&.......\n..@####..\n.........\nASSD\nASDD\nWASD", "22 1\n4 2\n0 3\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "队列"], "title": "PION贪吃蛇", "background": "NOIP2018原创模拟题 T3\n\nNOIP DAY1 T3 or DAY 2 T2 难度\n\n贪吃蛇大家都玩过吧，当然不同版本有不同规则。下面介绍PION贪吃蛇。", "description": "![图A](https://cdn.luogu.com.cn/upload/pic/31298.png)\n\n***表示方法：***\n\n该题中贪吃蛇存在于一个n行m列的矩形中，用 ‘.’ 表示空地，用 '#’ 表示蛇身，用 ‘@’表示蛇头，用‘&’表示食物\n例如：图一表示 $5*6$ 的矩形，有一条蛇，蛇长度为 $7$，有两个食物\n\n***基本规则：***\n\n1.蛇头每一秒就会移动一格，身体自然会跟着移动，用W表示向上，S表示向下，A表示向左，D表示向右\n\n2.蛇每吃一个食物就长度就会加一，而增加的长度体现在食物所在的地方，你可以把吃食物理解成食物变成了蛇头，之前的蛇头变成了蛇身，这一秒不移动\n\n例如：图二的三幅图展示了第一秒，第二秒，和第三秒的情况\n\n3.蛇如果死亡，身体（包括头）一定会全部变成食物\n\n4.PION贪吃蛇的蛇头碰到自己或别的蛇的身体就会死亡\n\n例如：图三的三幅图展示了第二条蛇撞在别人身体上死亡的过程\n\n5.蛇头撞在边界上也会引起死亡，但蛇头刚好现在边界上不会\n\n例如：图四第二幅图虽然蛇头在边界上，但是只是刚好，如果此时进行D操作蛇就会死亡，如果进行W或S就不会\n\n6.如果有操作使蛇头向相反方向运动，之后如果与身体重合蛇也会死亡（比如：图二第一幅图使用A操作,蛇就会死亡，此时在原地成为三个食物，你也可以理解为蛇下一秒不行动而自杀了）\n\n7.两条蛇蛇头相撞，主动撞上的死亡\n\n8.蛇的移动按编号由小到大进行（编号的含义见下文）\n", "inputFormat": "第一行三个数 $n,m,k$ 表示 $n*m$ 的矩形，$k$ 表示操作次数\n\n接下来 $n$ 行每行 $m$ 个字符，表示地图\n\n再接下来 $c$ 行（注意：图中有几条蛇就有几行），每行 $k$ 个字符，表示有 $k$ 个操作（如果执行了某个操作蛇死了，就忽略后面的操作）\n\n我们将蛇编号：按每条蛇蛇头的坐标从小到大编号为 $1，2，...，c$（越靠近上边的坐标越小，如果相同越靠近左边的坐标越小）\n\n例如：图三第一幅图两条蛇的蛇头坐标分别为（$4,3）,（3,7）$所以较长的蛇编号为 $2$，较短的蛇编号为 $1$", "outputFormat": "$c+1$ 行，输出 $k$ 次操作后每一条蛇的长度，编号；每一行第一个为长度，第二个数为编号\n\n最后一行输出剩下食物的总个数\n\n注意：输出按长度由大到小排序（长度相同按编号由小到大排序），死亡的蛇长度为 $0$", "hint": "***样例说明：***\n\n![图B](https://cdn.luogu.com.cn/upload/pic/31357.png)\n\n图五，图六展示了从第 $0$ 秒开始之后每一秒地图的状态，请看图理解（样例二图四有点小错误）\n\n***数据范围：***\n\n$10\\%$ 数据满足 $n,m\\leq 5,c=1,k\\leq3$\n\n$30\\%$ 数据满足 $n,m\\leq 10,c\\leq 2,k\\leq 5$\n\n$50\\%$ 数据满足 $n,m\\leq 50,c\\leq 5,k\\leq 20$\n\n$70\\%$ 数据满足 $n,m\\leq 100,c\\leq 7,k\\leq 50$\n\n$100\\%$ 数据满足 $n,m\\leq 200,c\\leq 20,k\\leq 100$，且图中的蛇不会引起混淆（对于任意蛇头，最多只有一块蛇身于其相连，而蛇身最多为二连块）,且数据保证图中的蛇均可以判断身体与头的对应关系，不会造成蛇身形态多解", "locale": "zh-CN", "translations": {"en": {"title": "PION Snake", "background": "NOIP 2018 original mock problem T3.\n\nDifficulty similar to NOIP Day 1 T3 or Day 2 T2.\n\nEveryone has played Snake, right? Of course, different versions have different rules. Below is an introduction to PION Snake.", "description": "![Figure A](https://cdn.luogu.com.cn/upload/pic/31298.png)\n\n***Notation:***\n\nIn this problem, the snakes live in a rectangle with $n$ rows and $m$ columns. `.` represents empty ground, `#` represents the snake body, `@` represents the snake head, and `&` represents food.  \nFor example, Figure 1 shows a $5*6$ rectangle with one snake. The snake has length $7$, and there are two pieces of food.\n\n***Basic rules:***\n\n1. Each second, a snake head moves by one cell, and the body follows naturally. Use `W` for up, `S` for down, `A` for left, and `D` for right.\n\n2. Each time a snake eats one piece of food, its length increases by $1$. The increased length appears at the cell where the food was. You can understand “eating food” as: the food becomes the new head, the previous head becomes part of the body, and the snake does not move during this second.  \nFor example, the three sub-figures in Figure 2 show the situations at the first second, the second second, and the third second.\n\n3. If a snake dies, its entire body (including the head) will all turn into food.\n\n4. If a snake head touches its own body or another snake’s body, it dies.  \nFor example, the three sub-figures in Figure 3 show the process where the second snake crashes into another snake’s body and dies.\n\n5. If a snake head hits the boundary, it also dies, but merely being exactly on the boundary does not.  \nFor example, in the second sub-figure of Figure 4, although the head is on the boundary, it is only exactly on it. If you perform `D` at this time, the snake will die; if you perform `W` or `S`, it will not.\n\n6. If an operation makes the snake head move in the opposite direction, then later, if it overlaps with its body, the snake will also die (for example: if in the first sub-figure of Figure 2 you use operation `A`, the snake will die and become three pieces of food on the spot. You may also think of it as the snake not moving next second and committing suicide).\n\n7. If two snakes’ heads collide, the one that actively撞上 (runs into the other) dies.\n\n8. Snakes move in increasing order of their indices (the meaning of indices is explained below).", "inputFormat": "The first line contains three integers $n,m,k$, where $n*m$ is the rectangle, and $k$ is the number of operations.\n\nNext $n$ lines each contain $m$ characters, describing the map.\n\nThen follow $c$ lines (note: there are as many lines as there are snakes in the map). Each line contains $k$ characters, representing $k$ operations (if a snake dies after performing some operation, ignore the remaining operations).\n\nWe index the snakes as follows: sort all snakes by the coordinates of their heads from small to large, and assign indices $1,2,\\ldots,c$ (a smaller row coordinate means smaller; if rows are equal, a smaller column coordinate means smaller).\n\nFor example, in the first sub-figure of Figure 3, the head coordinates of the two snakes are $(4,3)$ and $(3,7)$, so the longer snake is indexed as $2$, and the shorter snake is indexed as $1$.", "outputFormat": "Output $c+1$ lines. After $k$ operations, output the length and the index of each snake. In each line, the first number is the length, and the second number is the index.\n\nIn the last line, output the total number of remaining pieces of food.\n\nNote: output should be sorted by length from large to small (if lengths are equal, sort by index from small to large). The length of a dead snake is $0$.", "hint": "***Sample explanation:***\n\n![Figure B](https://cdn.luogu.com.cn/upload/pic/31357.png)\n\nFigures 5 and 6 show the map state at each second starting from second $0$. Please read the figures to understand (there is a small mistake in Figure 4 of Sample 2).\n\n***Constraints:***\n\n$10\\%$ of the testdata satisfies $n,m\\leq 5,c=1,k\\leq3$.\n\n$30\\%$ of the testdata satisfies $n,m\\leq 10,c\\leq 2,k\\leq 5$.\n\n$50\\%$ of the testdata satisfies $n,m\\leq 50,c\\leq 5,k\\leq 20$.\n\n$70\\%$ of the testdata satisfies $n,m\\leq 100,c\\leq 7,k\\leq 50$.\n\n$100\\%$ of the testdata satisfies $n,m\\leq 200,c\\leq 20,k\\leq 100$, and the snakes in the figure will not cause ambiguity (for any snake head, at most one body block is connected to it, and each body block has at most two adjacent body blocks). The testdata also guarantees that the correspondence between each snake’s body and head can be determined, and the snake body shape will not have multiple valid interpretations.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "PION贪吃蛇", "background": "NOIP2018原创模拟题 T3\n\nNOIP DAY1 T3 or DAY 2 T2 难度\n\n贪吃蛇大家都玩过吧，当然不同版本有不同规则。下面介绍PION贪吃蛇。", "description": "![图A](https://cdn.luogu.com.cn/upload/pic/31298.png)\n\n***表示方法：***\n\n该题中贪吃蛇存在于一个n行m列的矩形中，用 ‘.’ 表示空地，用 '#’ 表示蛇身，用 ‘@’表示蛇头，用‘&’表示食物\n例如：图一表示 $5*6$ 的矩形，有一条蛇，蛇长度为 $7$，有两个食物\n\n***基本规则：***\n\n1.蛇头每一秒就会移动一格，身体自然会跟着移动，用W表示向上，S表示向下，A表示向左，D表示向右\n\n2.蛇每吃一个食物就长度就会加一，而增加的长度体现在食物所在的地方，你可以把吃食物理解成食物变成了蛇头，之前的蛇头变成了蛇身，这一秒不移动\n\n例如：图二的三幅图展示了第一秒，第二秒，和第三秒的情况\n\n3.蛇如果死亡，身体（包括头）一定会全部变成食物\n\n4.PION贪吃蛇的蛇头碰到自己或别的蛇的身体就会死亡\n\n例如：图三的三幅图展示了第二条蛇撞在别人身体上死亡的过程\n\n5.蛇头撞在边界上也会引起死亡，但蛇头刚好现在边界上不会\n\n例如：图四第二幅图虽然蛇头在边界上，但是只是刚好，如果此时进行D操作蛇就会死亡，如果进行W或S就不会\n\n6.如果有操作使蛇头向相反方向运动，之后如果与身体重合蛇也会死亡（比如：图二第一幅图使用A操作,蛇就会死亡，此时在原地成为三个食物，你也可以理解为蛇下一秒不行动而自杀了）\n\n7.两条蛇蛇头相撞，主动撞上的死亡\n\n8.蛇的移动按编号由小到大进行（编号的含义见下文）\n", "inputFormat": "第一行三个数 $n,m,k$ 表示 $n*m$ 的矩形，$k$ 表示操作次数\n\n接下来 $n$ 行每行 $m$ 个字符，表示地图\n\n再接下来 $c$ 行（注意：图中有几条蛇就有几行），每行 $k$ 个字符，表示有 $k$ 个操作（如果执行了某个操作蛇死了，就忽略后面的操作）\n\n我们将蛇编号：按每条蛇蛇头的坐标从小到大编号为 $1，2，...，c$（越靠近上边的坐标越小，如果相同越靠近左边的坐标越小）\n\n例如：图三第一幅图两条蛇的蛇头坐标分别为（$4,3）,（3,7）$所以较长的蛇编号为 $2$，较短的蛇编号为 $1$", "outputFormat": "$c+1$ 行，输出 $k$ 次操作后每一条蛇的长度，编号；每一行第一个为长度，第二个数为编号\n\n最后一行输出剩下食物的总个数\n\n注意：输出按长度由大到小排序（长度相同按编号由小到大排序），死亡的蛇长度为 $0$", "hint": "***样例说明：***\n\n![图B](https://cdn.luogu.com.cn/upload/pic/31357.png)\n\n图五，图六展示了从第 $0$ 秒开始之后每一秒地图的状态，请看图理解（样例二图四有点小错误）\n\n***数据范围：***\n\n$10\\%$ 数据满足 $n,m\\leq 5,c=1,k\\leq3$\n\n$30\\%$ 数据满足 $n,m\\leq 10,c\\leq 2,k\\leq 5$\n\n$50\\%$ 数据满足 $n,m\\leq 50,c\\leq 5,k\\leq 20$\n\n$70\\%$ 数据满足 $n,m\\leq 100,c\\leq 7,k\\leq 50$\n\n$100\\%$ 数据满足 $n,m\\leq 200,c\\leq 20,k\\leq 100$，且图中的蛇不会引起混淆（对于任意蛇头，最多只有一块蛇身于其相连，而蛇身最多为二连块）,且数据保证图中的蛇均可以判断身体与头的对应关系，不会造成蛇身形态多解", "locale": "zh-CN"}}}
{"pid": "P4945", "type": "P", "difficulty": 5, "samples": [["4 1\n1 2\n2 3\n1 2\n3 8\n3 2 1 3", "21"], ["8 3\n1 2\n2 5\n3 2\n2 3\n1 4\n1 6\n2 2\n3 3\n1 3 2 1 4 5 2 1", "57"], ["10 3\n9 9\n8 8\n5 7\n6 6\n5 5\n5 5\n3 3\n2 2\n1 1\n9 9\n1 2 3 5 5 5 6 7 8 9", "124"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "贪心", "离散化", "排序"], "title": "最后的战役", "background": "NOIP2018原创模拟题T5\n\nNOIP2018原创模拟赛DAY2 T1\n\nNOIP T1+ or T2-  难度\n\n题目背景改编自小说《哈利波特与死亡圣器》", "description": "**最后的战役打响了。**\n\n哈利被宣告“死亡”，伏地魔带着他的部下准备进攻霍格沃茨。但是霍格沃茨有古老的魔法保护，他们必须先摧毁这些保护。魔法保护一共有$n$层，每一层保护有两个参数：$k,p$。其中k表示魔法的类型，p表示能量的大小。\n\n伏地魔每秒都会穿过一层保护，他在第 $i$ 秒（到达了第 $i$ 层）他有以下选择：  \n\n\n1.收集 $[1,i]$ 层魔法中魔法类型为 $x_i$ 的魔法能量\n\n2.收集 $[1,i]$ 层中魔法能量最大那层的魔法能量\n\n3.使用加倍魔法\n\n对于上面三个选择，他每秒可以可以选择一个，并可能获得能量，对于不同的选择，获得的能量也不同：\n\n对于1.获得$[1,i]$层中**所有魔法类型为$x_i$的**魔法能量（请结合样例1理解）\n\n对于2.获得$[1,i]$中魔法能量最大的那一层的魔法能量\n\n对于3.这一秒总共收集的能量不变（也就是这一秒不收集新的能量），但是下一秒获得的能量翻倍。**但是他不能连续使用加倍魔法**，而且他最多只能使用$m$次，**对于每一层的能量他都可以重复获取**\n\n只有他通过了这$n$层保护，并获得了最大的魔法能量才有可能彻底摧毁霍格沃茨的魔法防御，可是巫师又是不擅长计算的。\n\n于是，伏地魔找到了你，而你，作为精通计算机技术的麻瓜程序员，现在需要做的就是设计一个程序帮助伏地魔计算出他可以获得的最大的魔法能量的值。\n\n最终的决战已经展开，魔法界的历史又翻过了一页……", "inputFormat": "第一行：两个数：$n,m$，意义见题目描述\n\n接下来$n$行，第$i+1$行表示$k_i,p_i$，意义见题目描述\n\n最后一行，共$n$个数，第$i$个数表示$x_i$，意义见题目描述", "outputFormat": "一个数，表示伏地魔可以获得的最大能量值", "hint": "**样例一解释：**\n\n第一秒最多可以获得2经验值，第二秒最多可以获得3经验值，**因为第三秒可以收集魔法类型为1的能量，所以最多可以获得4能量值**，第四秒最多可以获得8经验值，所以选择在第三秒使用加倍魔法，共可以获得：$2+3+0+2*8=21$能量值\n\n**数据范围：**\n\n30%数据满足：$n<=100,m<=10$\n\n50%数据满足：$n<=5,000,m<=20$\n\n70%数据满足：$n,m<=2\\times 10^4,m<=200$\n\n100%数据满足：$n<=5\\times 10^4,m<=500,0<p_i<=10^4,0<k_i<=10^9,0<x_i<=10^9$\n\n**特殊约定：**\n\n30%数据满足$m=0$", "locale": "zh-CN", "translations": {"en": {"title": "The Final Battle", "background": "NOIP 2018 original mock problem T5.\n\nNOIP 2018 original mock contest DAY 2 T1.\n\nNOIP T1+ or T2- difficulty.\n\nThe background is adapted from the novel *Harry Potter and the Deathly Hallows*.", "description": "**The final battle has begun.**\n\nHarry is declared “dead”, and Voldemort, together with his followers, is ready to attack Hogwarts. However, Hogwarts is protected by ancient magic, and they must destroy these protections first. There are a total of $n$ layers of magical protection. Each layer has two parameters: $k, p$. Here, $k$ represents the type of magic, and $p$ represents the amount of energy.\n\nVoldemort passes through one layer of protection per second. In the $i$-th second (when he reaches the $i$-th layer), he has the following choices:\n\n1. Collect the magic energy of type $x_i$ among layers $[1,i]$.\n2. Collect the magic energy of the layer with the maximum energy among layers $[1,i]$.\n3. Use the doubling spell.\n\nAmong the three choices above, he can choose one each second, and may gain energy. Different choices yield different energy:\n\n- For choice 1, he gains the magic energy of **all layers in $[1,i]$ whose magic type is $x_i$** (please refer to Sample 1 for understanding).\n- For choice 2, he gains the magic energy of the layer with the maximum energy in $[1,i]$.\n- For choice 3, the total energy collected in this second does not change (that is, he does not collect new energy in this second), but the energy gained in the next second is doubled. **However, he cannot use the doubling spell consecutively**, and he can use it at most $m$ times. **For the energy of each layer, he may collect it repeatedly.**\n\nOnly if he passes through all $n$ layers of protection and obtains the maximum possible magic energy can he completely destroy Hogwarts’ magical defenses, but wizards are not good at calculations.\n\nSo, Voldemort comes to you. As a Muggle programmer skilled in computer technology, you now need to design a program to help Voldemort compute the maximum magic energy he can obtain.\n\nThe final showdown has begun, and the history of the wizarding world has turned another page.", "inputFormat": "The first line contains two numbers: $n, m$, as described above.\n\nThe next $n$ lines: the $(i+1)$-th line contains $k_i, p_i$, as described above.\n\nThe last line contains $n$ numbers. The $i$-th number is $x_i$, as described above.", "outputFormat": "Output one number, representing the maximum energy value Voldemort can obtain.", "hint": "**Explanation of Sample 1:**\n\nIn the first second, he can obtain at most $2$ experience points. In the second second, he can obtain at most $3$ experience points. **Because in the third second he can collect energy of magic type $1$, he can obtain at most $4$ energy**. In the fourth second, he can obtain at most $8$ experience points. Therefore, choose to use the doubling spell in the third second, and the total energy obtained is $2+3+0+2*8=21$.\n\n**Constraints:**\n\nFor $30\\%$ of the testdata: $n<=100, m<=10$.\n\nFor $50\\%$ of the testdata: $n<=5,000, m<=20$.\n\nFor $70\\%$ of the testdata: $n, m<=2\\times 10^4, m<=200$.\n\nFor $100\\%$ of the testdata: $n<=5\\times 10^4, m<=500, 0<p_i<=10^4, 0<k_i<=10^9, 0<x_i<=10^9$.\n\n**Special Note:**\n\nFor $30\\%$ of the testdata: $m=0$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最后的战役", "background": "NOIP2018原创模拟题T5\n\nNOIP2018原创模拟赛DAY2 T1\n\nNOIP T1+ or T2-  难度\n\n题目背景改编自小说《哈利波特与死亡圣器》", "description": "**最后的战役打响了。**\n\n哈利被宣告“死亡”，伏地魔带着他的部下准备进攻霍格沃茨。但是霍格沃茨有古老的魔法保护，他们必须先摧毁这些保护。魔法保护一共有$n$层，每一层保护有两个参数：$k,p$。其中k表示魔法的类型，p表示能量的大小。\n\n伏地魔每秒都会穿过一层保护，他在第 $i$ 秒（到达了第 $i$ 层）他有以下选择：  \n\n\n1.收集 $[1,i]$ 层魔法中魔法类型为 $x_i$ 的魔法能量\n\n2.收集 $[1,i]$ 层中魔法能量最大那层的魔法能量\n\n3.使用加倍魔法\n\n对于上面三个选择，他每秒可以可以选择一个，并可能获得能量，对于不同的选择，获得的能量也不同：\n\n对于1.获得$[1,i]$层中**所有魔法类型为$x_i$的**魔法能量（请结合样例1理解）\n\n对于2.获得$[1,i]$中魔法能量最大的那一层的魔法能量\n\n对于3.这一秒总共收集的能量不变（也就是这一秒不收集新的能量），但是下一秒获得的能量翻倍。**但是他不能连续使用加倍魔法**，而且他最多只能使用$m$次，**对于每一层的能量他都可以重复获取**\n\n只有他通过了这$n$层保护，并获得了最大的魔法能量才有可能彻底摧毁霍格沃茨的魔法防御，可是巫师又是不擅长计算的。\n\n于是，伏地魔找到了你，而你，作为精通计算机技术的麻瓜程序员，现在需要做的就是设计一个程序帮助伏地魔计算出他可以获得的最大的魔法能量的值。\n\n最终的决战已经展开，魔法界的历史又翻过了一页……", "inputFormat": "第一行：两个数：$n,m$，意义见题目描述\n\n接下来$n$行，第$i+1$行表示$k_i,p_i$，意义见题目描述\n\n最后一行，共$n$个数，第$i$个数表示$x_i$，意义见题目描述", "outputFormat": "一个数，表示伏地魔可以获得的最大能量值", "hint": "**样例一解释：**\n\n第一秒最多可以获得2经验值，第二秒最多可以获得3经验值，**因为第三秒可以收集魔法类型为1的能量，所以最多可以获得4能量值**，第四秒最多可以获得8经验值，所以选择在第三秒使用加倍魔法，共可以获得：$2+3+0+2*8=21$能量值\n\n**数据范围：**\n\n30%数据满足：$n<=100,m<=10$\n\n50%数据满足：$n<=5,000,m<=20$\n\n70%数据满足：$n,m<=2\\times 10^4,m<=200$\n\n100%数据满足：$n<=5\\times 10^4,m<=500,0<p_i<=10^4,0<k_i<=10^9,0<x_i<=10^9$\n\n**特殊约定：**\n\n30%数据满足$m=0$", "locale": "zh-CN"}}}
{"pid": "P4946", "type": "P", "difficulty": 6, "samples": [["4 5\n1 2 P 6\n2 3 R 2\n3 4 R 1\n2 4 R 1\n1 3 R 1", "3.00\n1.50"], ["4 6\n1 3 P 6\n1 3 R 1\n1 2 R 1\n2 3 R 1\n1 4 R 1\n4 3 R 2", "11.00\n2.00"], ["16 21\n1 2 R 2\n2 3 R 1\n3 4 R 1\n2 5 R 1\n4 5 R 1\n4 6 R 1\n6 7 R 1\n7 8 R 2\n4 9 R 1\n8 9 R 1\n1 16 P 128\n10 8 R 7\n10 11 R 2\n11 10 R 1\n11 12 R 2\n12 15 R 1\n15 13 R 2\n11 13 R 1\n11 14 R 1\n14 15 R 2\n15 16 R 5", "7.11\n2.37"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["搜索", "数学", "图论"], "title": "流量计算", "background": "NOIP2018原创模拟题T7\n\nNOIP2018原创模拟赛DAY2 T2\n\nNOIP DAY1 T2 or DAY2 T2 难度\n\n相关电学知识请参考“说明”中的“背景知识”。", "description": "你看了复杂的电路图，发现在初高中学的电路元件数都目比较少，因此你希望设计一个程序来分析元件数目更多的电路图，并进行一些计算。\n\n经过苦苦思考，你终于找到了描述电路图的方法：\n\n1.电路图可以用$n$个节点，$m$条无向边的连通图来表示，其中$n$表示导线交汇点，$m$表示元件个数，且电路元件只有电源和电阻\n\n2.图中没有自环，但可能有重边\n\n3.电路图**最复杂的情况是并联中嵌套串联**，**不会出现更复杂的电路**，例如下面的情况都不会出现：\n\n![P1](https://cdn.luogu.com.cn/upload/pic/37113.png)\n\n比如样例一便是一个满足条件的电路图（图片见样例一解释）\n\n因为这是你第一次尝试，所以你决定电路中只包含电源与电阻，而且你决定计算电路中的最大电流与最小电流。\n\n在理清思路后你就决定开始尝试了。", "inputFormat": "共$m+1$行\n\n第一行两个数 $n,m$，表示电路图抽象为$n$个节点，$m$条边的无向图\n\n接下来$m$行，对于每一行：\n\n前两个数为$x,y$，表示$x,y$之间有一个元件\n\n接下来一个字符，如果为 $'P'$ 表示电源，且$x$方向为电源负极，$y$方向为电源正极，如果为 $'R'$ 表示电阻（均不含引号）\n\n再接下来一个数字，如果为电源，表示电压（单位：伏特），否则表示电阻（单位：欧姆）", "outputFormat": "两行\n\n第一行输出最大电流值，保留两位小数\n\n第二行输出最小电流值，保留两位小数", "hint": "**背景知识：**\n\n欧姆定理：$I=\\frac{U}{R}$，其中$I$为电流，$U$为电压，$R$为电阻\n\n串联：串联电路中电流相等，总电阻相当于电阻阻值之和\n\n并联：并联电路中电压相等\n\n串并联：即串联与并联结合\n\n![P3](https://cdn.luogu.com.cn/upload/pic/37135.png)\n\n**样例一解释：**\n\n![P4](https://cdn.luogu.com.cn/upload/pic/37121.png)\n\n如图，所有电阻等效电阻为$2Ω$，故最大电流为$\\frac{6V}{2Ω}=3A$，在支线$2-3$或$2-4-3$中电流为$1.5A$，为最小电流\n\n**样例二/三提示：**\n\n样例二中所有电阻的等效电阻阻值为$\\frac{6}{11}Ω$，且最小电流在支线$1-4-3$上，样例三中所有电阻的等效电阻阻值为$18Ω$\n\n**数据范围：**\n\n对于 30%数据，有：$n,m<=20$\n\n对于 50%数据，有：$n<=10^3,m<=4\\times 10^3$\n\n对于 70%数据，有：$n<=5000,m<=2\\times10^4$\n\n对于100%数据，有：\n\n1.$n<=2\\times10^4,m<=5\\times 10^4$，$0<=$电压$<=10^8$，$1<=$电阻$<=10^3$\n\n2.只有有一个电源，电路不会有不规范的地方\n\n3.最复杂的情况为并联中嵌套串联（如图A，当然支路可能更多，电阻串联数量有可能更多，但**支路不会出现并联**），保证**不会出现并联中再嵌套并联**（如图B的情况就不会出现）\n\n![P5](https://cdn.luogu.com.cn/upload/pic/37253.png)\n\n**特殊约定：**\n\n20%数据保证：电路为纯串联电路\n\n另外20%数据保证：电路为纯并联电路", "locale": "zh-CN", "translations": {"en": {"title": "Current Calculation", "background": "NOIP 2018 original mock problem T7.\n\nNOIP 2018 original mock contest DAY 2 T2.\n\nDifficulty: NOIP DAY 1 T2 or DAY 2 T2.\n\nFor related electrical knowledge, please refer to “Background Knowledge” in the “Hint” section.", "description": "After looking at a complex circuit diagram, you find that the number of circuit components studied in junior and senior high school is relatively small. Therefore, you want to design a program to analyze circuit diagrams with more components and perform some calculations.\n\nAfter long thinking, you finally found a way to describe a circuit diagram:\n\n1. A circuit diagram can be represented by a connected graph with $n$ nodes and $m$ undirected edges, where $n$ represents wire junctions, $m$ represents the number of components, and the circuit components are only power sources and resistors.\n\n2. The graph has no self-loops, but it may have multiple edges.\n\n3. The most complex case of the circuit is **series connections nested inside parallel connections**, and **no more complex circuits** will appear. For example, the following cases will not appear:\n\n![P1](https://cdn.luogu.com.cn/upload/pic/37113.png)\n\nFor example, Sample 1 is a circuit diagram that satisfies the conditions (see the picture in the explanation of Sample 1).\n\nSince this is your first attempt, you decide that the circuit contains only power sources and resistors, and you decide to compute the maximum current and the minimum current in the circuit.\n\nAfter sorting out your ideas, you decide to start trying.", "inputFormat": "There are $m+1$ lines in total.\n\nThe first line contains two numbers $n,m$, meaning the circuit diagram is abstracted as an undirected graph with $n$ nodes and $m$ edges.\n\nIn the next $m$ lines, for each line:\n\nThe first two numbers are $x,y$, meaning there is a component between $x$ and $y$.\n\nThen there is a character: if it is $'P'$ it means a power source, and the direction from $x$ to $y$ is from the negative terminal to the positive terminal; if it is $'R'$ it means a resistor (without quotes).\n\nThen there is a number: if it is a power source, it indicates the voltage (unit: volt); otherwise it indicates the resistance (unit: ohm).", "outputFormat": "Two lines.\n\nThe first line outputs the maximum current value, keeping two decimal places.\n\nThe second line outputs the minimum current value, keeping two decimal places.", "hint": "**Background Knowledge:**\n\nOhm’s law: $I=\\frac{U}{R}$, where $I$ is current, $U$ is voltage, and $R$ is resistance.\n\nSeries connection: in a series circuit, currents are equal, and the total resistance equals the sum of the resistances.\n\nParallel connection: in a parallel circuit, voltages are equal.\n\nSeries-parallel: a combination of series and parallel.\n\n![P3](https://cdn.luogu.com.cn/upload/pic/37135.png)\n\n**Explanation of Sample 1:**\n\n![P4](https://cdn.luogu.com.cn/upload/pic/37121.png)\n\nAs shown, the equivalent resistance of all resistors is $2Ω$, so the maximum current is $\\frac{6V}{2Ω}=3A$. In branch $2-3$ or $2-4-3$, the current is $1.5A$, which is the minimum current.\n\n**Hints for Sample 2/3:**\n\nIn Sample 2, the equivalent resistance of all resistors is $\\frac{6}{11}Ω$, and the minimum current is on branch $1-4-3$. In Sample 3, the equivalent resistance of all resistors is $18Ω$.\n\n**Constraints:**\n\nFor $30\\%$ of the testdata: $n,m<=20$.\n\nFor $50\\%$ of the testdata: $n<=10^3,m<=4\\times 10^3$.\n\nFor $70\\%$ of the testdata: $n<=5000,m<=2\\times10^4$.\n\nFor $100\\%$ of the testdata:\n\n1. $n<=2\\times10^4,m<=5\\times 10^4$, $0<=$ voltage $<=10^8$, $1<=$ resistance $<=10^3$.\n\n2. There is only one power source, and the circuit will not have any irregular parts.\n\n3. The most complex case is series connections nested inside parallel connections (like Figure A. Of course, there may be more branches, and the number of resistors in series may be larger, but **a branch will not contain parallel connections**). It is guaranteed that **there will not be parallel connections nested inside parallel connections** (cases like Figure B will not appear).\n\n![P5](https://cdn.luogu.com.cn/upload/pic/37253.png)\n\n**Special Notes:**\n\nFor $20\\%$ of the testdata, it is guaranteed that the circuit is a purely series circuit.\n\nFor another $20\\%$ of the testdata, it is guaranteed that the circuit is a purely parallel circuit.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "流量计算", "background": "NOIP2018原创模拟题T7\n\nNOIP2018原创模拟赛DAY2 T2\n\nNOIP DAY1 T2 or DAY2 T2 难度\n\n相关电学知识请参考“说明”中的“背景知识”。", "description": "你看了复杂的电路图，发现在初高中学的电路元件数都目比较少，因此你希望设计一个程序来分析元件数目更多的电路图，并进行一些计算。\n\n经过苦苦思考，你终于找到了描述电路图的方法：\n\n1.电路图可以用$n$个节点，$m$条无向边的连通图来表示，其中$n$表示导线交汇点，$m$表示元件个数，且电路元件只有电源和电阻\n\n2.图中没有自环，但可能有重边\n\n3.电路图**最复杂的情况是并联中嵌套串联**，**不会出现更复杂的电路**，例如下面的情况都不会出现：\n\n![P1](https://cdn.luogu.com.cn/upload/pic/37113.png)\n\n比如样例一便是一个满足条件的电路图（图片见样例一解释）\n\n因为这是你第一次尝试，所以你决定电路中只包含电源与电阻，而且你决定计算电路中的最大电流与最小电流。\n\n在理清思路后你就决定开始尝试了。", "inputFormat": "共$m+1$行\n\n第一行两个数 $n,m$，表示电路图抽象为$n$个节点，$m$条边的无向图\n\n接下来$m$行，对于每一行：\n\n前两个数为$x,y$，表示$x,y$之间有一个元件\n\n接下来一个字符，如果为 $'P'$ 表示电源，且$x$方向为电源负极，$y$方向为电源正极，如果为 $'R'$ 表示电阻（均不含引号）\n\n再接下来一个数字，如果为电源，表示电压（单位：伏特），否则表示电阻（单位：欧姆）", "outputFormat": "两行\n\n第一行输出最大电流值，保留两位小数\n\n第二行输出最小电流值，保留两位小数", "hint": "**背景知识：**\n\n欧姆定理：$I=\\frac{U}{R}$，其中$I$为电流，$U$为电压，$R$为电阻\n\n串联：串联电路中电流相等，总电阻相当于电阻阻值之和\n\n并联：并联电路中电压相等\n\n串并联：即串联与并联结合\n\n![P3](https://cdn.luogu.com.cn/upload/pic/37135.png)\n\n**样例一解释：**\n\n![P4](https://cdn.luogu.com.cn/upload/pic/37121.png)\n\n如图，所有电阻等效电阻为$2Ω$，故最大电流为$\\frac{6V}{2Ω}=3A$，在支线$2-3$或$2-4-3$中电流为$1.5A$，为最小电流\n\n**样例二/三提示：**\n\n样例二中所有电阻的等效电阻阻值为$\\frac{6}{11}Ω$，且最小电流在支线$1-4-3$上，样例三中所有电阻的等效电阻阻值为$18Ω$\n\n**数据范围：**\n\n对于 30%数据，有：$n,m<=20$\n\n对于 50%数据，有：$n<=10^3,m<=4\\times 10^3$\n\n对于 70%数据，有：$n<=5000,m<=2\\times10^4$\n\n对于100%数据，有：\n\n1.$n<=2\\times10^4,m<=5\\times 10^4$，$0<=$电压$<=10^8$，$1<=$电阻$<=10^3$\n\n2.只有有一个电源，电路不会有不规范的地方\n\n3.最复杂的情况为并联中嵌套串联（如图A，当然支路可能更多，电阻串联数量有可能更多，但**支路不会出现并联**），保证**不会出现并联中再嵌套并联**（如图B的情况就不会出现）\n\n![P5](https://cdn.luogu.com.cn/upload/pic/37253.png)\n\n**特殊约定：**\n\n20%数据保证：电路为纯串联电路\n\n另外20%数据保证：电路为纯并联电路", "locale": "zh-CN"}}}
{"pid": "P4947", "type": "P", "difficulty": 6, "samples": [["5 5\n1 2\n2 4\n2 5\n1 3\n2 cpp c\n3 pas txt txt\n2 vbs bat\n3 vbs cpp pas\n4 cpp c pas txt\nquery /e 1 5 *.txt\nquery /p 1 4\ndel /e 2 2 *.txt\nquery /e 1 5 *.txt\nquery /e 4 3 *.vbs", "3\n2\n2\n1\n2"], ["12 7\n1 2\n1 3\n1 4\n2 5\n2 6\n3 7\n7 12\n8 4\n8 9\n10 9\n11 9\n0\n2 c c\n3 zz c c\n0\n1 gif\n2 png bmp\n3 avl avl mpshi\n0\n4 cpp c pas js\n5 a b c d e\n0\n3 a b c\nquery /p 11 12\nquery /e 1 2 *.gif\nquery /e 6 10 *.c\ndel /e 2 9 *.c\ndel /e 3 12 *.c\nquery /e 5 6 *.gif\nquery /e 6 1 *.c", "7\n0\n4\n3\n3\n1\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["字符串", "二分", "树链剖分"], "title": "PION后缀自动机", "background": "NOIP2018原创模拟题T6\n\nNOIP2018原创模拟赛DAY2 T3\n\nNOIP DAY1 T3+ or DAY2 T3 难度\n\n鉴于 NOIP2017 DAY2 T3 的难度，就有了这道题。**然而这道题考察的知识并不是后缀自动机**", "description": "小P是一个技术高超的程序员，他开发了一套自己的操作系统，称为PION系统，该系统与Windows和Linux有很大不同，目前他正在测试该系统。\n\nPION系统与Windows系统最大的不同在于文件的储存与操作，POIN的文件夹没有父子之分。我们知道，在Windows系统中，可以在文件夹里新建子文件夹。但是，PION系统文件夹不分父子关系，**但是部分文件夹之间可以互相直接访问，我们称这种关系为互访关系，而且，对于一个有$n$个文件夹的系统来说，这种互访关系有$n-1$个，且保证所有文件夹均可以通过互访关系而互相访问。也就是说：我们可以把Windows中的文件夹的集合看作一棵有根树，而把PION系统中的文件夹集合看作为无根树。**\n\n在PION系统中，每个文件夹都可以储存文件，和Windows一样，文件名包含后缀名。\n\n现在小P正在构思一种可以对文件夹中文件后缀进行方便操作的交互式程序dmc，他也将其称为**PION后缀自动机**。由于他太忙了，所以他希望你帮他实现**部分功能**。\n\n他希望你帮他实现三个功能：\n\n1.计算两个文件夹之间的距离。我们定义：文件夹之间的距离为其中一个文件夹通过互访达到另一个文件夹最少互访次数。比如：同一个文件夹距离为0，两个有互访关系的文件夹距离为1。\n\n2.计算两个文件夹路径之间（包含这两个文件夹）的文件夹中的文件的后缀名为A的文件数量，**其中A是一个小写字符串。提示：我们可以把PION文件夹之间的路径理解为树中两节点之间的路径。**\n\n3.删除两个文件夹路径之间（包含这两个文件夹）的文件夹中的文件的后缀名为A的文件，并统计被删除文件的数量。\n\n由于dmc是一个交互系统，所以我们用tab语言描述这三个操作：\n\n```\nquery /p u v\n```\n\n表示操作一，其中 u,v 表示两文件夹的编号\n\n```\nquery /e u v *.A\n```\n\n表示操作二，其中 u,v 表示两文件夹的编号，$'*'$ 为通配符，$'.'$用于分隔文件名与后缀，**A是一个小写字符串**。\n\n```\ndel /e u v *.A\n```\n\n表示操作三， $u,v, *.A$ 意义与操作二相同。\n\n**如果没有看懂题目请结合样例及样例解释来理解。**\n\n最后，这个困难的任务就交给你了。", "inputFormat": "第一行两个数，$n,m$，$n$表示文件夹的数量（文件夹编号在$[1,n]$），$m$表示操作的数量\n\n接下来 $n-1$ 行，每行两个数 $u,v$，表示文件夹 $u,v$ 之间有互访关系\n\n接下来 $n$ 行，第$i$行第一个数为 $k$，表示第$i$个文件夹有$k$个文件，接下来为$k$个字符串，表示每个文件的后缀名\n\n再接下来$m$行，每行一串指令，格式见上文", "outputFormat": "对于每个指令，输出一个数，输出数的意义见上文", "hint": "**样例一解释：**\n\n![T6](https://cdn.luogu.com.cn/upload/pic/34166.png)\n\n如图为样例一大致结构，橙色方框为文件夹，灰色文字表示文件后缀名，红色线条表示文件互访关系。\n\n对于第一个操作：文件夹1到5之间txt文件有3个所以输出3  \n对于第二个操作：文件夹1与4距离为2  \n对于第三个操作：删除的为文件夹2的文件，txt文件有两个，所以输出2  \n对于第四个操作：由于文件夹2的txt文件被删除了，所以1到5之间txt文件只有1个  \n对于第五个操作：文件夹3到4之间vbs文件有2个所以输出2\n\n**数据范围：**\n\n30%数据满足：$n,m<=100,k<=3$\n\n50%数据满足：$n,m<=5000,k<=10$\n\n70%数据满足：$n,m<=2 \\times 10^4,k<=50$\n\n90%数据满足：$n,m<=5 \\times 10^4$\n\n100%数据满足：$n,m<=10^5$，文件总数小于$5 \\times 10^5$，文件后缀名为小写字符串且不超过6个字符\n\n其他说明：\n\n1.约50%的数据为完全随机生成\n\n2.数据弱化版：[PION后缀自动机（数据弱化版）](https://www.luogu.org/problemnew/show/U41487)", "locale": "zh-CN", "translations": {"en": {"title": "PION Suffix Automaton", "background": "NOIP2018 original mock problem T6.\n\nNOIP2018 original mock contest DAY2 T3.\n\nDifficulty: NOIP DAY1 T3+ or DAY2 T3.\n\nConsidering the difficulty of NOIP2017 DAY2 T3, this problem was created. **However, the knowledge tested in this problem is not the suffix automaton.**", "description": "Xiao P is a highly skilled programmer. He developed his own operating system called the PION system. This system is very different from Windows and Linux, and he is currently testing it.\n\nThe biggest difference between the PION system and Windows is how files are stored and managed. PION folders do not have a parent-child relationship. We know that in Windows, you can create subfolders inside a folder. However, in the PION system, folders have no parent-child relationship. **But some folders can directly access each other. We call this relationship a mutual-access relationship. For a system with $n$ folders, there are $n-1$ such mutual-access relationships, and it is guaranteed that all folders can reach each other through these relationships. That is, we can view the set of folders in Windows as a rooted tree, while the set of folders in the PION system can be viewed as an unrooted tree.**\n\nIn the PION system, each folder can store files. Like Windows, file names include extensions.\n\nNow Xiao P is designing an interactive program called dmc that can conveniently operate on file extensions inside folders, and he also calls it the **PION Suffix Automaton**. Since he is too busy, he wants you to implement **some of its functions**.\n\nYou need to implement three functions:\n\n1. Compute the distance between two folders. We define: the distance between two folders is the minimum number of mutual-access steps needed to go from one folder to the other. For example, the distance from a folder to itself is 0, and the distance between two folders with a mutual-access relationship is 1.\n\n2. Compute, on the path between two folders (including both folders), how many files in the folders along this path have extension A, **where A is a lowercase string**. Hint: we can understand the path between two PION folders as the path between two nodes in a tree.\n\n3. Delete, on the path between two folders (including both folders), all files in the folders along this path whose extension is A, and count how many files were deleted.\n\nSince dmc is an interactive system, we use the tab language to describe these three operations:\n\n```\nquery /p u v\n```\n\nRepresents operation 1, where $u,v$ are the IDs of the two folders.\n\n```\nquery /e u v *.A\n```\n\nRepresents operation 2, where $u,v$ are the IDs of the two folders, $'*'$ is a wildcard, and $'.'$ is used to separate the file name and the extension. **A is a lowercase string**.\n\n```\ndel /e u v *.A\n```\n\nRepresents operation 3. The meanings of $u,v, *.A$ are the same as in operation 2.\n\n**If you do not understand the statement, please combine the sample and the sample explanation to understand it.**\n\nFinally, this difficult task is left to you.", "inputFormat": "The first line contains two integers $n,m$. $n$ is the number of folders (folder IDs are in $[1,n]$), and $m$ is the number of operations.\n\nThe next $n-1$ lines each contain two integers $u,v$, indicating that folders $u$ and $v$ have a mutual-access relationship.\n\nThe next $n$ lines: on the $i$-th line, the first integer is $k$, meaning folder $i$ has $k$ files, followed by $k$ strings, each being a file extension.\n\nThen the next $m$ lines each contain one command string, whose format is shown above.", "outputFormat": "For each command, output one integer, whose meaning is described above.", "hint": "**Sample 1 explanation:**\n\n![T6](https://cdn.luogu.com.cn/upload/pic/34166.png)\n\nThe figure shows the approximate structure of sample 1. Orange boxes are folders, gray text indicates file extensions, and red lines indicate mutual-access relationships between folders.\n\nFor the first operation: there are 3 txt files between folders 1 and 5, so output 3.  \nFor the second operation: the distance between folders 1 and 4 is 2.  \nFor the third operation: the deleted files are in folder 2, and there are 2 txt files, so output 2.  \nFor the fourth operation: since the txt files in folder 2 were deleted, there is only 1 txt file between folders 1 and 5.  \nFor the fifth operation: there are 2 vbs files between folders 3 and 4, so output 2.\n\n**Constraints:**\n\nFor 30% of the testdata: $n,m<=100,k<=3$.\n\nFor 50% of the testdata: $n,m<=5000,k<=10$.\n\nFor 70% of the testdata: $n,m<=2 \\times 10^4,k<=50$.\n\nFor 90% of the testdata: $n,m<=5 \\times 10^4$.\n\nFor 100% of the testdata: $n,m<=10^5$, the total number of files is less than $5 \\times 10^5$, file extensions are lowercase strings and are no longer than 6 characters.\n\nOther notes:\n\n1. About 50% of the testdata is generated completely at random.\n\n2. Weakened version: [PION Suffix Automaton (Weakened Testdata Version)](https://www.luogu.org/problemnew/show/U41487).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "PION后缀自动机", "background": "NOIP2018原创模拟题T6\n\nNOIP2018原创模拟赛DAY2 T3\n\nNOIP DAY1 T3+ or DAY2 T3 难度\n\n鉴于 NOIP2017 DAY2 T3 的难度，就有了这道题。**然而这道题考察的知识并不是后缀自动机**", "description": "小P是一个技术高超的程序员，他开发了一套自己的操作系统，称为PION系统，该系统与Windows和Linux有很大不同，目前他正在测试该系统。\n\nPION系统与Windows系统最大的不同在于文件的储存与操作，POIN的文件夹没有父子之分。我们知道，在Windows系统中，可以在文件夹里新建子文件夹。但是，PION系统文件夹不分父子关系，**但是部分文件夹之间可以互相直接访问，我们称这种关系为互访关系，而且，对于一个有$n$个文件夹的系统来说，这种互访关系有$n-1$个，且保证所有文件夹均可以通过互访关系而互相访问。也就是说：我们可以把Windows中的文件夹的集合看作一棵有根树，而把PION系统中的文件夹集合看作为无根树。**\n\n在PION系统中，每个文件夹都可以储存文件，和Windows一样，文件名包含后缀名。\n\n现在小P正在构思一种可以对文件夹中文件后缀进行方便操作的交互式程序dmc，他也将其称为**PION后缀自动机**。由于他太忙了，所以他希望你帮他实现**部分功能**。\n\n他希望你帮他实现三个功能：\n\n1.计算两个文件夹之间的距离。我们定义：文件夹之间的距离为其中一个文件夹通过互访达到另一个文件夹最少互访次数。比如：同一个文件夹距离为0，两个有互访关系的文件夹距离为1。\n\n2.计算两个文件夹路径之间（包含这两个文件夹）的文件夹中的文件的后缀名为A的文件数量，**其中A是一个小写字符串。提示：我们可以把PION文件夹之间的路径理解为树中两节点之间的路径。**\n\n3.删除两个文件夹路径之间（包含这两个文件夹）的文件夹中的文件的后缀名为A的文件，并统计被删除文件的数量。\n\n由于dmc是一个交互系统，所以我们用tab语言描述这三个操作：\n\n```\nquery /p u v\n```\n\n表示操作一，其中 u,v 表示两文件夹的编号\n\n```\nquery /e u v *.A\n```\n\n表示操作二，其中 u,v 表示两文件夹的编号，$'*'$ 为通配符，$'.'$用于分隔文件名与后缀，**A是一个小写字符串**。\n\n```\ndel /e u v *.A\n```\n\n表示操作三， $u,v, *.A$ 意义与操作二相同。\n\n**如果没有看懂题目请结合样例及样例解释来理解。**\n\n最后，这个困难的任务就交给你了。", "inputFormat": "第一行两个数，$n,m$，$n$表示文件夹的数量（文件夹编号在$[1,n]$），$m$表示操作的数量\n\n接下来 $n-1$ 行，每行两个数 $u,v$，表示文件夹 $u,v$ 之间有互访关系\n\n接下来 $n$ 行，第$i$行第一个数为 $k$，表示第$i$个文件夹有$k$个文件，接下来为$k$个字符串，表示每个文件的后缀名\n\n再接下来$m$行，每行一串指令，格式见上文", "outputFormat": "对于每个指令，输出一个数，输出数的意义见上文", "hint": "**样例一解释：**\n\n![T6](https://cdn.luogu.com.cn/upload/pic/34166.png)\n\n如图为样例一大致结构，橙色方框为文件夹，灰色文字表示文件后缀名，红色线条表示文件互访关系。\n\n对于第一个操作：文件夹1到5之间txt文件有3个所以输出3  \n对于第二个操作：文件夹1与4距离为2  \n对于第三个操作：删除的为文件夹2的文件，txt文件有两个，所以输出2  \n对于第四个操作：由于文件夹2的txt文件被删除了，所以1到5之间txt文件只有1个  \n对于第五个操作：文件夹3到4之间vbs文件有2个所以输出2\n\n**数据范围：**\n\n30%数据满足：$n,m<=100,k<=3$\n\n50%数据满足：$n,m<=5000,k<=10$\n\n70%数据满足：$n,m<=2 \\times 10^4,k<=50$\n\n90%数据满足：$n,m<=5 \\times 10^4$\n\n100%数据满足：$n,m<=10^5$，文件总数小于$5 \\times 10^5$，文件后缀名为小写字符串且不超过6个字符\n\n其他说明：\n\n1.约50%的数据为完全随机生成\n\n2.数据弱化版：[PION后缀自动机（数据弱化版）](https://www.luogu.org/problemnew/show/U41487)", "locale": "zh-CN"}}}
{"pid": "P4948", "type": "P", "difficulty": 6, "samples": [["3 4 0", "84"], ["3 10 1", "3210"], ["3 9 2", "6894"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学"], "title": "数列求和", "background": "", "description": "给定 $n,a,k$，求：\n\n$$\\sum_{i=1}^n i^k a^i$$\n\n答案对 $10^9 + 7$ 取模。", "inputFormat": "输入一行三个非负整数 $n,a,k$。其中 $n, a \\ge 1$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "| 测试点编号 | $n=$ | $k=$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $10^6$ | $10^3$ |\n| $2$ | $10^6$ | $2\\times 10^3$ |\n| $3$ | $10^{18}$ |  $0$|\n| $4$ | $10^{18}$ |$1$  |\n| $5,6$ |  $10^{18}$| $2$ |\n| $7,8$ |  $10^{18}$|  $10^3$|\n| $9,10$ |$10^{18}$  |  $2\\times 10^3$|\n\n对于 $100\\%$ 的数据，$n\\le10^{18}$，$a\\le10^9$，$k\\le2000$。", "locale": "zh-CN", "translations": {"en": {"title": "Sequence Sum", "background": "", "description": "Given $n, a, k$, compute:\n\n$$\\sum_{i=1}^n i^k a^i$$\n\nOutput the answer modulo $10^9 + 7$.", "inputFormat": "Input one line with three non-negative integers $n, a, k$. Here $n, a \\ge 1$.", "outputFormat": "Output one line with one integer representing the answer.", "hint": "| Test Point ID | $n=$ | $k=$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $10^6$ | $10^3$ |\n| $2$ | $10^6$ | $2\\times 10^3$ |\n| $3$ | $10^{18}$ |  $0$|\n| $4$ | $10^{18}$ |$1$  |\n| $5,6$ |  $10^{18}$| $2$ |\n| $7,8$ |  $10^{18}$|  $10^3$|\n| $9,10$ |$10^{18}$  |  $2\\times 10^3$|\n\nFor $100\\%$ of the testdata, $n \\le 10^{18}$, $a \\le 10^9$, and $k \\le 2000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数列求和", "background": "", "description": "给定 $n,a,k$，求：\n\n$$\\sum_{i=1}^n i^k a^i$$\n\n答案对 $10^9 + 7$ 取模。", "inputFormat": "输入一行三个非负整数 $n,a,k$。其中 $n, a \\ge 1$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "| 测试点编号 | $n=$ | $k=$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $10^6$ | $10^3$ |\n| $2$ | $10^6$ | $2\\times 10^3$ |\n| $3$ | $10^{18}$ |  $0$|\n| $4$ | $10^{18}$ |$1$  |\n| $5,6$ |  $10^{18}$| $2$ |\n| $7,8$ |  $10^{18}$|  $10^3$|\n| $9,10$ |$10^{18}$  |  $2\\times 10^3$|\n\n对于 $100\\%$ 的数据，$n\\le10^{18}$，$a\\le10^9$，$k\\le2000$。", "locale": "zh-CN"}}}
{"pid": "P4949", "type": "P", "difficulty": 5, "samples": [["4 5\n1 2 11\n1 3 12\n2 3 13\n1 4 15\n2 2 3\n1 2 1\n2 2 3\n2 2 4\n2 3 4", "13\n12\n26\n16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["最近公共祖先 LCA", "树链剖分", "基环树"], "title": "最短距离", "background": null, "description": "给出一个 $n$ 个点 $n$ 条边的无向连通图。\n\n你需要支持两种操作：\n\n1. 修改 第 $x$  条边的长度为 $y$ ；\n\n2. 查询 点 $x$ 到点 $y$ 的最短距离。\n\n共有 $m$ 次操作。", "inputFormat": "输入共 $n+m+1$ 行：\n\n第 $1$ 行，包含两个正整数 $n,m$，表示点数即边数，操作次数。\n\n第 $2$ 行到第 $n+1$ 行，每行包含三个正整数 $x,y,z$，表示 $x$ 与 $y$ 间有一条长度为 $z$ 的边。\n\n第 $n+2$ 到 $n+m+1$ 行，每行包含三个正整数 $opt,x,y$，表示操作种类，操作的参数（含义见【题目描述】）。", "outputFormat": "对于每次操作 $2$ 输出查询的结果。", "hint": "![Luogu](https://cdn.luogu.com.cn/upload/pic/37934.png)  \n\n对于 $100\\%$ 的数据，保证 $z\\in [0,5000]$。", "locale": "zh-CN", "translations": {"en": {"title": "Shortest Distance.", "background": "", "description": "You are given an undirected connected graph with $n$ vertices and $n$ edges.\n\nYou need to support two types of operations:\n\n1. Modify the length of the $x$-th edge to $y$.\n2. Query the shortest distance from vertex $x$ to vertex $y$.\n\nThere are $m$ operations in total.", "inputFormat": "The input has a total of $n+m+1$ lines:\n\nLine $1$ contains two positive integers $n,m$, representing the number of vertices (which is also the number of edges) and the number of operations.\n\nLines $2$ to $n+1$ each contain three positive integers $x,y,z$, indicating that there is an edge of length $z$ between $x$ and $y$.\n\nLines $n+2$ to $n+m+1$ each contain three positive integers $opt,x,y$, representing the type of operation and its parameters (see the meaning in the “Description”).", "outputFormat": "For each operation of type $2$, output the query result.", "hint": "![Luogu](https://cdn.luogu.com.cn/upload/pic/37934.png)  \n\nFor $100\\%$ of the testdata, it is guaranteed that $z\\in [0,5000]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最短距离", "background": null, "description": "给出一个 $n$ 个点 $n$ 条边的无向连通图。\n\n你需要支持两种操作：\n\n1. 修改 第 $x$  条边的长度为 $y$ ；\n\n2. 查询 点 $x$ 到点 $y$ 的最短距离。\n\n共有 $m$ 次操作。", "inputFormat": "输入共 $n+m+1$ 行：\n\n第 $1$ 行，包含两个正整数 $n,m$，表示点数即边数，操作次数。\n\n第 $2$ 行到第 $n+1$ 行，每行包含三个正整数 $x,y,z$，表示 $x$ 与 $y$ 间有一条长度为 $z$ 的边。\n\n第 $n+2$ 到 $n+m+1$ 行，每行包含三个正整数 $opt,x,y$，表示操作种类，操作的参数（含义见【题目描述】）。", "outputFormat": "对于每次操作 $2$ 输出查询的结果。", "hint": "![Luogu](https://cdn.luogu.com.cn/upload/pic/37934.png)  \n\n对于 $100\\%$ 的数据，保证 $z\\in [0,5000]$。", "locale": "zh-CN"}}}
{"pid": "P4950", "type": "P", "difficulty": 6, "samples": [["3\n11 40\n1 3\n2 4 7\n2018 20170901\n1 4\n1 7\n19260817 998244353\n3 2 5 6\n4 0 7 8 9\n", "310\n52885750312822\n2039707997741122\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "完美数字", "background": null, "description": "给出两个数字集合 $S$ 和 $T$，其中元素均为 $0$ 到 $9$ 之间的整数。\n\n定义“完美数字”为数位中包含 $S$ 中所有的数且不包含 $T$ 中任意一个数的数字。\n\n例如，$S=\\{1,3,4\\}$，$T=\\{7,8\\}$，则 $1345$、$341166$、$4133129$ 都是完美数字，而 $13$、$8431$、$34171$ 都不是完美数字（因为 $13$ 数位中不包含 $4$，$8431$ 和 $34171$ 中虽然包含了 $1$、$3$、$4$ 这三个数但又包含 $8$ 和 $7$）。\n\n求 $[l,r]$ 中所有完美数字的和。", "inputFormat": "第一行一个正整数 $T$，表示数据组数。\n\n下面 $T$ 组数据：\n\n第一行两个正整数 $l,r$；\n\n第二行，先输入一个正整数 $n_S$ 表示 $S$ 中元素的个数；随后输入 $n_S$ 个整数，表示 $S$ 中的元素。\n\n第二行，先输入一个正整数 $n_T$ 表示 $T$ 中元素的个数；随后输入 $n_T$ 个整数，表示 $T$ 中的元素。", "outputFormat": "对于每组数据，输出一个整数，为 $[l,r]$ 中所有完美数字的和。", "hint": "### 样例解释\n\n对于第一组样例数据，完美数字为：\n\n$13$、$23$、$30$、$31$、$32$、$33$、$35$、$36$、$38$、$39$。\n\n所以总和为 $310$。\n\n### 数据范围\n\n对于 $30\\%$ 的数据，$1 \\le l \\le r \\le 10^4$。\n\n对于另外 $10\\%$ 的数据，$n_S=n_T=0$。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 2000$，$1 \\le l \\le r \\le 10^9$，$0 \\le n_S,n_T \\le 10$。保证 $S$ 和 $T$ 中的元素均为 $[0,9]$ 中的整数。", "locale": "zh-CN", "translations": {"en": {"title": "Perfect Numbers", "background": "", "description": "You are given two sets of digits $S$ and $T$, where all elements are integers between $0$ and $9$.\n\nA “perfect number” is a number whose digits contain all digits in $S$ and contain none of the digits in $T$.\n\nFor example, if $S=\\{1,3,4\\}$ and $T=\\{7,8\\}$, then $1345$, $341166$, and $4133129$ are perfect numbers, while $13$, $8431$, and $34171$ are not (because $13$ does not contain digit $4$, and although $8431$ and $34171$ contain digits $1$, $3$, and $4$, they also contain $8$ and $7$).\n\nFind the sum of all perfect numbers in $[l,r]$.", "inputFormat": "The first line contains a positive integer $T$, indicating the number of test cases.\n\nThen follow $T$ test cases:\n\nThe first line contains two positive integers $l,r$.\n\nThe second line: first input a positive integer $n_S$ representing the number of elements in $S$, followed by $n_S$ integers representing the elements of $S$.\n\nThe third line: first input a positive integer $n_T$ representing the number of elements in $T$, followed by $n_T$ integers representing the elements of $T$.", "outputFormat": "For each test case, output one integer: the sum of all perfect numbers in $[l,r]$.", "hint": "### Sample Explanation\n\nFor the first sample test case, the perfect numbers are:\n\n$13$, $23$, $30$, $31$, $32$, $33$, $35$, $36$, $38$, $39$.\n\nSo the total sum is $310$.\n\n### Constraints\n\nFor $30\\%$ of the testdata, $1 \\le l \\le r \\le 10^4$.\n\nFor another $10\\%$ of the testdata, $n_S=n_T=0$.\n\nFor $100\\%$ of the testdata, $1 \\le T \\le 2000$, $1 \\le l \\le r \\le 10^9$, $0 \\le n_S,n_T \\le 10$. It is guaranteed that all elements in $S$ and $T$ are integers in $[0,9]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "完美数字", "background": null, "description": "给出两个数字集合 $S$ 和 $T$，其中元素均为 $0$ 到 $9$ 之间的整数。\n\n定义“完美数字”为数位中包含 $S$ 中所有的数且不包含 $T$ 中任意一个数的数字。\n\n例如，$S=\\{1,3,4\\}$，$T=\\{7,8\\}$，则 $1345$、$341166$、$4133129$ 都是完美数字，而 $13$、$8431$、$34171$ 都不是完美数字（因为 $13$ 数位中不包含 $4$，$8431$ 和 $34171$ 中虽然包含了 $1$、$3$、$4$ 这三个数但又包含 $8$ 和 $7$）。\n\n求 $[l,r]$ 中所有完美数字的和。", "inputFormat": "第一行一个正整数 $T$，表示数据组数。\n\n下面 $T$ 组数据：\n\n第一行两个正整数 $l,r$；\n\n第二行，先输入一个正整数 $n_S$ 表示 $S$ 中元素的个数；随后输入 $n_S$ 个整数，表示 $S$ 中的元素。\n\n第二行，先输入一个正整数 $n_T$ 表示 $T$ 中元素的个数；随后输入 $n_T$ 个整数，表示 $T$ 中的元素。", "outputFormat": "对于每组数据，输出一个整数，为 $[l,r]$ 中所有完美数字的和。", "hint": "### 样例解释\n\n对于第一组样例数据，完美数字为：\n\n$13$、$23$、$30$、$31$、$32$、$33$、$35$、$36$、$38$、$39$。\n\n所以总和为 $310$。\n\n### 数据范围\n\n对于 $30\\%$ 的数据，$1 \\le l \\le r \\le 10^4$。\n\n对于另外 $10\\%$ 的数据，$n_S=n_T=0$。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 2000$，$1 \\le l \\le r \\le 10^9$，$0 \\le n_S,n_T \\le 10$。保证 $S$ 和 $T$ 中的元素均为 $[0,9]$ 中的整数。", "locale": "zh-CN"}}}
{"pid": "P4951", "type": "P", "difficulty": 5, "samples": [["5 5 100\n1 2 20 5\n1 3 20 5\n1 4 20 5\n1 5 20 5\n2 3 23 1", "1.0625"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2001", "二分", "USACO", "生成树", "分数规划"], "title": "[USACO01OPEN] Earthquake", "background": "", "description": "一场地震把约翰家的牧场摧毁了， 坚强的约翰决心重建家园。 约翰已经重建了 $n$ 个牧场，现在他希望能修建一些道路把它们连接起来。研究地形之后，约翰发现可供修建的道路有 $m$ 条。碰巧的是，奶牛们最近也成立一个工程队，专门从事修复道路。而然，奶牛们很有经济头脑，如果无利可图，它们是不会干的。\n\n奶牛们关注的是挣钱速度，即总利润和总施工时间的比值。约翰和奶牛达成了协议，奶牛负责修建道路，将所有牧场连通，而约翰需要支付 $f$ 元。每条道路都有自己的施工时间和建造成本。连接两个相同的牧场的道路可能有多条。保证所有的牧场必定是可连通的，不过也有可能一些道路的建造成本之和会超过 $f$。  \n\n请帮助奶牛们选择修复哪些道路，才能使单位时间的利润最大？\n", "inputFormat": "第一行三个整数 $n,m,f$。\n\n第二行到第 $m+1$ 行，第 $i+1$ 行表示第 $i$ 条道路的信息。每行有四个整数 $u_i,v_i,c_i,t_i$， $u_i$ 和 $v_i$ 表示这条道路连接的牧场编号，$c_i$ 表示修建道路的成本，$t_i$ 表示道路修建所需要的时间。", "outputFormat": "第一行，一个保留四位小数的浮点数，表示奶牛们能挣到的最大单位时间利润，如果奶牛们无钱可赚，则输出`0.0000`。", "hint": "#### 样例输入输出 1 解释\n\n奶牛们可以选择连通最后四条道路，则总时间为 $16$，总成本为 $83$，所以单位利润为 $\\dfrac{17}{16}=1.0625$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证\n- $1 \\leq n \\leq 400$，$1 \\leq m \\leq 10000$，$1 \\leq f \\leq 2 \\times 10^9$。\n- $1 \\leq u_i,v_i \\leq n$，$1 \\leq c_i,t_i \\leq 2 \\times 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO01OPEN] Earthquake", "background": "", "description": "An earthquake destroyed John’s farm. Tough John decides to rebuild his home. John has rebuilt $n$ pastures, and now he wants to build some roads to connect them. After studying the terrain, John found that there are $m$ possible roads that can be built. Coincidentally, the cows have recently formed an engineering team specialized in repairing roads. However, the cows are very business-minded: if there is no profit, they will not do the job.\n\nThe cows care about the speed of making money, that is, the ratio of total profit to total construction time. John and the cows reach an agreement: the cows will build roads to make all pastures connected, and John will pay $f$ dollars. Each road has its own construction time and building cost. There may be multiple roads connecting the same pair of pastures. It is guaranteed that all pastures can be connected, but it is also possible that the sum of building costs of some set of roads exceeds $f$.\n\nPlease help the cows choose which roads to repair so that the profit per unit time is maximized.", "inputFormat": "The first line contains three integers $n,m,f$.\n\nLines $2$ to $m+1$ describe the roads. The $(i+1)$-th line gives the information of the $i$-th road: four integers $u_i,v_i,c_i,t_i$, where $u_i$ and $v_i$ are the indices of the pastures this road connects, $c_i$ is the cost to build the road, and $t_i$ is the time required to build the road.", "outputFormat": "The first line contains a floating-point number rounded to four decimal places, representing the maximum profit per unit time the cows can earn. If the cows cannot make any profit, output `0.0000`.", "hint": "#### Explanation of Sample Input/Output 1\n\nThe cows can choose the last four roads to connect all pastures. Then the total time is $16$ and the total cost is $83$, so the profit per unit time is $\\dfrac{17}{16}=1.0625$.\n\n#### Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that:\n- $1 \\leq n \\leq 400$, $1 \\leq m \\leq 10000$, $1 \\leq f \\leq 2 \\times 10^9$.\n- $1 \\leq u_i,v_i \\leq n$, $1 \\leq c_i,t_i \\leq 2 \\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO01OPEN] Earthquake", "background": "", "description": "一场地震把约翰家的牧场摧毁了， 坚强的约翰决心重建家园。 约翰已经重建了 $n$ 个牧场，现在他希望能修建一些道路把它们连接起来。研究地形之后，约翰发现可供修建的道路有 $m$ 条。碰巧的是，奶牛们最近也成立一个工程队，专门从事修复道路。而然，奶牛们很有经济头脑，如果无利可图，它们是不会干的。\n\n奶牛们关注的是挣钱速度，即总利润和总施工时间的比值。约翰和奶牛达成了协议，奶牛负责修建道路，将所有牧场连通，而约翰需要支付 $f$ 元。每条道路都有自己的施工时间和建造成本。连接两个相同的牧场的道路可能有多条。保证所有的牧场必定是可连通的，不过也有可能一些道路的建造成本之和会超过 $f$。  \n\n请帮助奶牛们选择修复哪些道路，才能使单位时间的利润最大？\n", "inputFormat": "第一行三个整数 $n,m,f$。\n\n第二行到第 $m+1$ 行，第 $i+1$ 行表示第 $i$ 条道路的信息。每行有四个整数 $u_i,v_i,c_i,t_i$， $u_i$ 和 $v_i$ 表示这条道路连接的牧场编号，$c_i$ 表示修建道路的成本，$t_i$ 表示道路修建所需要的时间。", "outputFormat": "第一行，一个保留四位小数的浮点数，表示奶牛们能挣到的最大单位时间利润，如果奶牛们无钱可赚，则输出`0.0000`。", "hint": "#### 样例输入输出 1 解释\n\n奶牛们可以选择连通最后四条道路，则总时间为 $16$，总成本为 $83$，所以单位利润为 $\\dfrac{17}{16}=1.0625$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证\n- $1 \\leq n \\leq 400$，$1 \\leq m \\leq 10000$，$1 \\leq f \\leq 2 \\times 10^9$。\n- $1 \\leq u_i,v_i \\leq n$，$1 \\leq c_i,t_i \\leq 2 \\times 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4952", "type": "P", "difficulty": 5, "samples": [["3 5 70\n30 25\n50 21\n20 20\n5 18\n35 30", "35"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2004", "USACO"], "title": "[USACO04MAR] Financial Aid", "background": "", "description": "   人类可以选择很多大学，而奶牛们却没学可上。为解决这个问题，贝西和她的伙伴们创立了一所奶牛大学，取名为哞哞大学。\n\n   为了选拔优秀学生，她们发明了一种奶牛学术能力测试（简称 CSAT） ，这种测试的分数异常精确，每头奶牛的成绩可以用$0$到$2×10^9$之间的一个整数表示，而且可以保证每头奶牛的分数都不同。\n\n   哞哞大学的学费很贵，奶牛们表示负担不起，他们都各自申请了奖学金。政府并没有为奶牛准备奖学金，所有的预算都必须要从学校有限的助学基金中扣除（设基金总额为F)。\n\n   哞哞大学有N间宿舍，N是一个奇数，所以贝西只能接受N头奶牛的申请，她发誓不会让入学的奶牛少于N。此外，她希望新生的 CSAT 成绩表现优异，她以中位数来衡量新生的总体水平。所谓中位数，就是排序后处在最中间的分数，比如3,8,9,7,5的中位数是7。\n\n   今年，共有C头奶牛申请入学，给定每头奶牛的 CSAT 成绩和申请的奖学金数目，以及学校可赞助的总额，确定贝西接受哪些奶牛的申请才可以使成绩的中位数达到最大。", "inputFormat": "第一行：三个用空格分开的整数：$N$，$C$和$F$。$1 ≤ N ≤ 19999$，$N ≤ C ≤ 10^5$ ，$0 ≤ F ≤ 2 × 10^9$\n第二行到$C + 1$行：每行有两个用空格分开的整数。第一个数是这头奶牛的 CSAT 成绩，第二个数是这头奶牛需要的奖学金$Q_i$ ，$0 ≤ Q_i ≤ 10^5 $。", "outputFormat": "第一行：一个整数，表示贝西可以得到的最大中位数，如果现有基金不够资助任何N头奶牛，则输出-1。", "hint": "贝西接受 CSAT 分数为 5，35，50 的奶牛的申请，中位数为 35，需支付的奖学金总额为18 + 30 + 21 = 69", "locale": "zh-CN", "translations": {"en": {"title": "[USACO04MAR] Financial Aid", "background": "", "description": "Humans can choose from many colleges, but cows have nowhere to go to school. To solve this problem, Bessie and her friends founded a cow university called Moo Moo University.\n\nIn order to select outstanding students, they invented a Cow Scholastic Ability Test (CSAT). The scores of this test are extremely precise: each cow’s score can be represented by an integer between $0$ and $2×10^9$, and it is guaranteed that no two cows have the same score.\n\nTuition at Moo Moo University is very expensive, and the cows cannot afford it, so they each apply for financial aid. The government does not provide scholarships for cows; all funding must be paid from the school’s limited financial aid fund (let the total fund be $F$).\n\nMoo Moo University has $N$ dorm rooms. Since $N$ is an odd number, Bessie can accept applications from only $N$ cows, and she swears she will not admit fewer than $N$ cows. In addition, she wants the freshmen to have excellent CSAT performance, and she measures the overall level by the median. The median is the score in the exact middle after sorting. For example, the median of 3, 8, 9, 7, 5 is 7.\n\nThis year, a total of $C$ cows apply. Given each cow’s CSAT score and the amount of financial aid requested, as well as the total amount the school can sponsor, determine which cows Bessie should accept so that the median score is as large as possible.", "inputFormat": "Line 1: Three integers separated by spaces: $N$, $C$, and $F$. $1 ≤ N ≤ 19999$, $N ≤ C ≤ 10^5$, $0 ≤ F ≤ 2 × 10^9$.\n\nLines 2 to $C + 1$: Each line contains two integers separated by a space. The first number is the cow’s CSAT score, and the second number is the amount of financial aid this cow requires, $Q_i$. $0 ≤ Q_i ≤ 10^5$.", "outputFormat": "Line 1: One integer, the maximum median Bessie can achieve. If the current fund is not enough to support any $N$ cows, output $-1$.", "hint": "Bessie accepts cows with CSAT scores 5, 35, and 50. The median is 35, and the total financial aid required is $18 + 30 + 21 = 69$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO04MAR] Financial Aid", "background": "", "description": "   人类可以选择很多大学，而奶牛们却没学可上。为解决这个问题，贝西和她的伙伴们创立了一所奶牛大学，取名为哞哞大学。\n\n   为了选拔优秀学生，她们发明了一种奶牛学术能力测试（简称 CSAT） ，这种测试的分数异常精确，每头奶牛的成绩可以用$0$到$2×10^9$之间的一个整数表示，而且可以保证每头奶牛的分数都不同。\n\n   哞哞大学的学费很贵，奶牛们表示负担不起，他们都各自申请了奖学金。政府并没有为奶牛准备奖学金，所有的预算都必须要从学校有限的助学基金中扣除（设基金总额为F)。\n\n   哞哞大学有N间宿舍，N是一个奇数，所以贝西只能接受N头奶牛的申请，她发誓不会让入学的奶牛少于N。此外，她希望新生的 CSAT 成绩表现优异，她以中位数来衡量新生的总体水平。所谓中位数，就是排序后处在最中间的分数，比如3,8,9,7,5的中位数是7。\n\n   今年，共有C头奶牛申请入学，给定每头奶牛的 CSAT 成绩和申请的奖学金数目，以及学校可赞助的总额，确定贝西接受哪些奶牛的申请才可以使成绩的中位数达到最大。", "inputFormat": "第一行：三个用空格分开的整数：$N$，$C$和$F$。$1 ≤ N ≤ 19999$，$N ≤ C ≤ 10^5$ ，$0 ≤ F ≤ 2 × 10^9$\n第二行到$C + 1$行：每行有两个用空格分开的整数。第一个数是这头奶牛的 CSAT 成绩，第二个数是这头奶牛需要的奖学金$Q_i$ ，$0 ≤ Q_i ≤ 10^5 $。", "outputFormat": "第一行：一个整数，表示贝西可以得到的最大中位数，如果现有基金不够资助任何N头奶牛，则输出-1。", "hint": "贝西接受 CSAT 分数为 5，35，50 的奶牛的申请，中位数为 35，需支付的奖学金总额为18 + 30 + 21 = 69", "locale": "zh-CN"}}}
{"pid": "P4953", "type": "P", "difficulty": 4, "samples": [["3 30 20", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2002", "USACO"], "title": "[USACO02FEB] Cow Cycling", "background": "", "description": "奶牛自行车队由 $N$ 名队员组成，他们正准备参加一个比赛，这场比赛的路程共有 $D$ 圈。车队在比赛时会排成一条直线，由于存在空气阻力，当骑车速度达到每分钟 $x$ 圈时，领头的奶牛每分钟消耗的体力为 $x^2$，其它奶牛每分钟消耗的体力为 $x$。每头奶牛的初始体力值都是相同的，记作 $E$。如果有些奶牛在比赛过程中的体力不支，就会掉队，掉队的奶牛不能继续参加比赛。每支队伍最后只要有一头奶牛能到终点就可以了。\n\n比赛规定，最小的计时单位是分钟，在每分钟开始的时候，车队要哪头奶牛负责领头，领头奶牛不能在这分钟内掉队，每分钟骑过的圈数也必须是整数。\n\n请帮忙计划一下，采用什么样的策略才能让车队以最快的时间到达终点？", "inputFormat": "第一行：三个正整数：$N, E, D$。$1 \\leq N \\leq 20$，$1 \\leq E \\leq 100$，$1 \\leq D \\leq 100$。", "outputFormat": "第一行：单独一个整数，表示最早达到终点的时间，如果无法到达终点，输出 $0$。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/spwg7uf6.png)", "locale": "zh-CN", "translations": {"en": {"title": "[USACO02FEB] Cow Cycling", "background": "", "description": "A cow cycling team consists of $N$ riders, and they are preparing for a race whose total distance is $D$ laps. During the race, the team rides in a single line. Due to air resistance, when the riding speed is $x$ laps per minute, the leading cow consumes stamina at a rate of $x^2$ per minute, while every other cow consumes stamina at a rate of $x$ per minute. All cows start with the same initial stamina, denoted by $E$. If some cows run out of stamina during the race, they will drop out, and cows that drop out cannot continue the race. For each team, it is enough as long as at least one cow can reach the finish.\n\nThe race rules state that the smallest time unit is one minute. At the beginning of each minute, the team must decide which cow will be the leader. The leading cow cannot drop out during that minute, and the number of laps ridden in each minute must be an integer.\n\nPlease plan a strategy to allow the team to reach the finish in the shortest possible time.", "inputFormat": "The first line contains three positive integers: $N, E, D$. $1 \\leq N \\leq 20$, $1 \\leq E \\leq 100$, $1 \\leq D \\leq 100$.", "outputFormat": "The first line contains a single integer, the earliest time to reach the finish. If it is impossible to reach the finish, output $0$.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/spwg7uf6.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO02FEB] Cow Cycling", "background": "", "description": "奶牛自行车队由 $N$ 名队员组成，他们正准备参加一个比赛，这场比赛的路程共有 $D$ 圈。车队在比赛时会排成一条直线，由于存在空气阻力，当骑车速度达到每分钟 $x$ 圈时，领头的奶牛每分钟消耗的体力为 $x^2$，其它奶牛每分钟消耗的体力为 $x$。每头奶牛的初始体力值都是相同的，记作 $E$。如果有些奶牛在比赛过程中的体力不支，就会掉队，掉队的奶牛不能继续参加比赛。每支队伍最后只要有一头奶牛能到终点就可以了。\n\n比赛规定，最小的计时单位是分钟，在每分钟开始的时候，车队要哪头奶牛负责领头，领头奶牛不能在这分钟内掉队，每分钟骑过的圈数也必须是整数。\n\n请帮忙计划一下，采用什么样的策略才能让车队以最快的时间到达终点？", "inputFormat": "第一行：三个正整数：$N, E, D$。$1 \\leq N \\leq 20$，$1 \\leq E \\leq 100$，$1 \\leq D \\leq 100$。", "outputFormat": "第一行：单独一个整数，表示最早达到终点的时间，如果无法到达终点，输出 $0$。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/spwg7uf6.png)", "locale": "zh-CN"}}}
{"pid": "P4954", "type": "P", "difficulty": 6, "samples": [["3\n1\n2\n3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2009", "USACO", "单调队列", "动态规划优化", "线性 DP"], "title": "[USACO09OPEN] Tower of Hay G", "background": null, "description": "为了调整电灯亮度，贝西要用干草包堆出一座塔，然后爬到牛棚顶去把灯泡换掉。干草包会从传送带上运来，共会出现 $n$ 包干草，第 $i$ 包干草的宽度是 $W_i$，高度和长度统一为 $1$。干草塔要从底层开始铺建。贝西会选择最先送来的若干包干草，堆在地上作为第一层，然后再把紧接着送来的几包干草包放在第二层， 再铺建第三层……重复这个过程，一直到所有的干草全部用完。每层的干草包必须紧靠在一起，不出现缝隙，而且为了建筑稳定，上层干草的宽度不能超过下层的宽度。 按顺序运来的干草包一定要都用上，不能将其中几个干草包弃置不用。贝西的目标是建一座最高的塔，请你来帮助她完成这个任务吧。", "inputFormat": "第一行：一个整数 $n (1 \\le n \\le 100000)$。\n\n第二行到 $n + 1$ 行：第 $i + 1$ 行有一个整数 $W_i (1 \\le W_i \\le 10000)$。", "outputFormat": "第一行：单个整数，表示可以建立的最高高度。", "hint": "### 样例解释\n\n将 $1$ 和 $2$ 放在第一层，将 $3$ 放在第二层。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09OPEN] Tower of Hay G", "background": "", "description": "To adjust the brightness of a lamp, Bessie wants to stack hay bales into a tower, then climb onto the barn roof to replace the light bulb. Hay bales are delivered on a conveyor belt. There will be a total of $n$ bales. The $i$-th bale has width $W_i$, and both its height and length are $1$.\n\nThe hay tower must be built starting from the bottom layer. Bessie will take several of the earliest delivered bales and place them on the ground as the first layer, then place the next several bales as the second layer, then build the third layer, and so on. This process repeats until all hay bales are used up.\n\nIn each layer, the bales must be placed tightly together with no gaps. Also, for stability, the total width of an upper layer cannot exceed the total width of the layer directly below it. All bales delivered in order must be used; she cannot discard any bale.\n\nBessie's goal is to build the tallest possible tower. Please help her complete this task.", "inputFormat": "The first line contains an integer $n (1 \\le n \\le 100000)$.\n\nLines $2$ to $n + 1$: line $i + 1$ contains an integer $W_i (1 \\le W_i \\le 10000)$.", "outputFormat": "The first line contains a single integer, representing the maximum height that can be built.", "hint": "### Sample Explanation\n\nPut $1$ and $2$ on the first layer, and put $3$ on the second layer.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09OPEN] Tower of Hay G", "background": null, "description": "为了调整电灯亮度，贝西要用干草包堆出一座塔，然后爬到牛棚顶去把灯泡换掉。干草包会从传送带上运来，共会出现 $n$ 包干草，第 $i$ 包干草的宽度是 $W_i$，高度和长度统一为 $1$。干草塔要从底层开始铺建。贝西会选择最先送来的若干包干草，堆在地上作为第一层，然后再把紧接着送来的几包干草包放在第二层， 再铺建第三层……重复这个过程，一直到所有的干草全部用完。每层的干草包必须紧靠在一起，不出现缝隙，而且为了建筑稳定，上层干草的宽度不能超过下层的宽度。 按顺序运来的干草包一定要都用上，不能将其中几个干草包弃置不用。贝西的目标是建一座最高的塔，请你来帮助她完成这个任务吧。", "inputFormat": "第一行：一个整数 $n (1 \\le n \\le 100000)$。\n\n第二行到 $n + 1$ 行：第 $i + 1$ 行有一个整数 $W_i (1 \\le W_i \\le 10000)$。", "outputFormat": "第一行：单个整数，表示可以建立的最高高度。", "hint": "### 样例解释\n\n将 $1$ 和 $2$ 放在第一层，将 $3$ 放在第二层。", "locale": "zh-CN"}}}
{"pid": "P4955", "type": "P", "difficulty": 3, "samples": [["3 5\n20 21 18 99 5\n19 22 20 16 26\n18 17 40 60 80\n1 0 0 0 1\n0 0 0 0 0\n0 0 0 0 1", "21"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "二分", "USACO", "广度优先搜索 BFS"], "title": "[USACO14JAN] Cross Country Skiing S", "background": "", "description": "The cross-country skiing course at the winter Moolympics is described by an $M * N$ grid of elevations (1 <= M,N <= 500), each elevation being in the range 0 .. 1,000,000,000.  \n\nSome of the cells in this grid are designated as waypoints for the course.  The organizers of the Moolympics want to assign a difficulty rating $D$ to the entire course so that a cow can reach any waypoint from any other waypoint by repeatedly skiing from a cell to an adjacent cell with absolute elevation difference at most $D$.  Two cells are adjacent if one is directly north, south, east, or west of the other.  The difficulty rating of the course is the minimum value of $D$ such that all waypoints are mutually reachable in this fashion.", "inputFormat": "* Line 1: The integers $M$ and $N$.\n\n* Lines 2..1+M: Each of these $M$ lines contains $N$ integer elevations.\n\n* Lines 2+M..1+2M: Each of these $M$ lines contains $N$ values that are either $0$ or $1$, with $1$ indicating a cell that is a waypoint.", "outputFormat": "The ski course is described by a 3 x 5 grid of elevations.  The upper-left, upper-right, and lower-right cells are designated as waypoints.", "hint": "If D = 21, the three waypoints are reachable from each-other.  If D < 21, then the upper-right waypoint cannot be reached from the other two.", "locale": "en", "translations": {"en": {"title": "[USACO14JAN] Cross Country Skiing S", "background": "", "description": "The cross-country skiing course at the winter Moolympics is described by an $M * N$ grid of elevations (1 <= M,N <= 500), each elevation being in the range 0 .. 1,000,000,000.  \n\nSome of the cells in this grid are designated as waypoints for the course.  The organizers of the Moolympics want to assign a difficulty rating $D$ to the entire course so that a cow can reach any waypoint from any other waypoint by repeatedly skiing from a cell to an adjacent cell with absolute elevation difference at most $D$.  Two cells are adjacent if one is directly north, south, east, or west of the other.  The difficulty rating of the course is the minimum value of $D$ such that all waypoints are mutually reachable in this fashion.", "inputFormat": "* Line 1: The integers $M$ and $N$.\n\n* Lines 2..1+M: Each of these $M$ lines contains $N$ integer elevations.\n\n* Lines 2+M..1+2M: Each of these $M$ lines contains $N$ values that are either $0$ or $1$, with $1$ indicating a cell that is a waypoint.", "outputFormat": "The ski course is described by a 3 x 5 grid of elevations.  The upper-left, upper-right, and lower-right cells are designated as waypoints.", "hint": "If D = 21, the three waypoints are reachable from each-other.  If D < 21, then the upper-right waypoint cannot be reached from the other two.", "locale": "en"}, "zh-CN": {"title": "[USACO14JAN] Cross Country Skiing S", "background": "", "description": "冬季 Moolympics 的越野滑雪赛道由一个 $M \\times N$ 的高程网格描述（$1 \\leq M, N \\leq 500$），每个高程在 $0$ 到 $1,000,000,000$ 之间。网格中的某些单元被指定为赛道的航点。Moolympics 的组织者希望为整个赛道分配一个难度等级 $D$，以便奶牛可以通过从一个单元滑到相邻单元（绝对高程差最多为 $D$）的方式，从任何一个航点到达另一个航点。如果一个单元的正北、正南、正东或正西方向上有另一个单元，则这两个单元是相邻的。赛道的难度等级是 $D$ 的最小值，使得所有航点都可以通过这种方式相互到达。", "inputFormat": "* 第 1 行：整数 $M$ 和 $N$。\n\n* 第 2 行到第 $1+M$ 行：每一行包含 $N$ 个整数高程。\n\n* 第 $2+M$ 行到第 $1+2M$ 行：每一行包含 $N$ 个值，这些值要么是 $0$，要么是 $1$，其中 $1$ 表示该单元是一个航点。", "outputFormat": "滑雪赛道由一个 3 x 5 的高程网格描述。左上角、右上角和右下角的单元被指定为航点。", "hint": "如果 $D = 21$，三个航点可以相互到达。如果 $D < 21$，则右上角的航点无法从其他两个航点到达。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4956", "type": "P", "difficulty": 1, "samples": [["1456", "1\n1"], ["6188", "14\n1"], ["40404", "99\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2017", "不定方程", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #6] Davor", "background": null, "description": "After successfully conquering the South Pole, Davor is preparing for new challenges. Next up is the Arctic expedition to Siberia, Greenland and Norway. He begins his travels on 31 December 2018, and needs to collect $N$ kunas (Croatian currency) by then. In order to do this, he has decided to put away $X$ ($X \\le 100$) kunas every Monday to his travel fund, $X + K$ kunas every Tuesday, $X + 2\\times K$ every Wednesday, and so on until Sunday, when he will put away $X + 6\\times K$ kunas. This way, he will collect money for 52 weeks, starting with 1 January 2018 (Monday) until 30 December 2018 (Sunday).\n\nIf we know the amount of money $N$, output the values $X$ and $K$ so that it is possible to collect the **exact** money amount in the given timespan. The solution will always exist, and if there are multiple, output the one with the greatest $X$ and smallest $K$.", "inputFormat": "The first line of input contains the integer $N$ ($1456\\le N \\le 145600$), the number from the task.", "outputFormat": "The first line of output must contain the value of $X$ ($0 \\le X \\le 100$), and the second the value of $K$ ($K > 0$).", "hint": null, "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #6] Davor", "background": null, "description": "After successfully conquering the South Pole, Davor is preparing for new challenges. Next up is the Arctic expedition to Siberia, Greenland and Norway. He begins his travels on 31 December 2018, and needs to collect $N$ kunas (Croatian currency) by then. In order to do this, he has decided to put away $X$ ($X \\le 100$) kunas every Monday to his travel fund, $X + K$ kunas every Tuesday, $X + 2\\times K$ every Wednesday, and so on until Sunday, when he will put away $X + 6\\times K$ kunas. This way, he will collect money for 52 weeks, starting with 1 January 2018 (Monday) until 30 December 2018 (Sunday).\n\nIf we know the amount of money $N$, output the values $X$ and $K$ so that it is possible to collect the **exact** money amount in the given timespan. The solution will always exist, and if there are multiple, output the one with the greatest $X$ and smallest $K$.", "inputFormat": "The first line of input contains the integer $N$ ($1456\\le N \\le 145600$), the number from the task.", "outputFormat": "The first line of output must contain the value of $X$ ($0 \\le X \\le 100$), and the second the value of $K$ ($K > 0$).", "hint": null, "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #6] Davor", "background": null, "description": "成功征服南极后，Davor 正在为新的挑战做准备。接下来是前往西伯利亚、格陵兰和挪威的北极探险。他将于 2018 年 12 月 31 日开始旅行，并需要在此之前筹集 $N$ 库纳（克罗地亚货币）。为此，他决定每周一存入 $X(X ≤ 100)$ 库纳到他的旅行基金中，每周二存入 $X + K$ 库纳，每周三存入 $X + 2\\times K$ 库纳，依此类推，直到周日，他将存入 $X + 6\\times K$ 库纳。这样，他将在 52 周内筹集资金，从 2018 年 1 月 1 日（星期一）开始，直到 2018 年 12 月 30 日（星期日）为止。\n\n如果我们知道金额 $N$，输出值 $X$ 和 $K$，以便可以在给定的时间范围内收集到**准确**的金额。解决方案总是存在的，如果有多个，输出 $X$ 最大且 $K$ 最小的那个。", "inputFormat": "输入的第一行包含整数 $N(1456 \\le N \\le 145600)$，这是任务中的数字。", "outputFormat": "输出的第一行必须包含 $X$ 的值 $(0 < X \\le 100)$，第二行包含 $K$ 的值 $(K > 0)$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4957", "type": "P", "difficulty": 5, "samples": [["4 2\n1 2\n2\n2 1\n1 2\n3\n2 1\n1 3\n4\n", "4\n1 2 3 4"], ["6 3\n1 4 5\n3\n3 2\n2 3 4\n1 6\n1 3\n4\n1 5 6\n1 1\n6\n2\n", "5\n1 2 4 5 6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #6] Alkemija", "background": "", "description": "In ancient times, when alchemists were searching for gold, the world was familiar with a total\nof ​N distinct substances, denoted with 1 to ​N​. During many years of hard work, searching for\nthe secret formula, alchemists discovered a series of interesting regularities - ​alchemical\nreactions\n​. In one reaction, it’s possible to transform substance set {\n$X_1$​,$X_2$​, …, $X_L$​} to another\nsubstance set {$Y_1$​, $Y_2$​, …, ​$Y_R$​}. For example, the substance set {1, 4, 5} might react once and\ncreate the new substance set {2, 6}.\n\nJoško is a modern alchemist and has ​M distinct substances denoted with ​$A_1$​, $A_2$​, …, ​$A_M$​. He\nhas an unlimited quantity of each substance from that set. Joško wants to know which\nsubstances he can create using a list of reactions of ancient alchemists, so he’s asking you\nto help him solve this problem.", "inputFormat": "The first line of input contains two integers N and M (1 ≤ M ≤ N ≤ 100 000), the numbers from the task.\n\nThe second line of input contains M integers $A_i$ (1 ≤ $A_i$ ≤ N), labels of the substances Joško has in the beginning.\n\nThe third line of input contains the integer K (1 ≤ K ≤ 100 000), the number of known\nreactions.\n\nThe following 3·K lines contain a list of reactions. Each reaction is described with 3 lines in the following way:\n\n- The first line contains the integers L and R (1 ≤ L, R ≤ N).\n- The second line contains L distinct integers $X_i$ (1 ≤ $X_i$ ≤ N).\n- The third line contains R distinct integers $Y_i$ (1 ≤ $Y_i$ ≤ N).\n- This describes the reaction with which the substance set {$X_1$, $X_2$, …, $X_L$} transforms into substance set {$Y_1$, $Y_2$, …, $Y_R$}.\n\nThe sum of all L values won’t exceed 100 000.\n\nThe sum of all R values won’t exceed 100 000.", "outputFormat": "The first line of output must contain the integer X, the number of obtainable substances.\n\nThe second line of output must contain X distinct integers $B_i$, sorted ascendingly, that represent the labels of the obtainable substances.\n", "hint": "In test cases worth 60% of total points, it will hold:\n\n- N, K ≤ 500.\n- The sum of all L values and the sum of all R values won’t exceed 500.\n\n**Clarification of the first test case:**\n\nThere are 2 reactions.\n\nThe first reaction transforms substance set {1, 2} into substance set {3}.\n\nThe second reaction transforms substance set {1, 3} into substance set {4}.\n\nJoško initially has substances from the set {1, 2}.\n\nUsing the first reaction, Joško can obtain substance 3, after which he has substances from the set {1, 2, 3}.\n\nAfter that, using the second reaction, he can also obtain substance 4.\n\n**Clarification of the second test case:**\n\nJoško initially has substances from the set {1, 4, 5}.\n\nUsing the second reaction, it is possible to obtain substance 6, after which it is possible to apply the third reaction, giving substance 2.\n\nThe first reaction is impossible to apply because Joško doesn’t have substance 3.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #6] Alkemija", "background": "", "description": "In ancient times, when alchemists were searching for gold, the world was familiar with a total\nof ​N distinct substances, denoted with 1 to ​N​. During many years of hard work, searching for\nthe secret formula, alchemists discovered a series of interesting regularities - ​alchemical\nreactions\n​. In one reaction, it’s possible to transform substance set {\n$X_1$​,$X_2$​, …, $X_L$​} to another\nsubstance set {$Y_1$​, $Y_2$​, …, ​$Y_R$​}. For example, the substance set {1, 4, 5} might react once and\ncreate the new substance set {2, 6}.\n\nJoško is a modern alchemist and has ​M distinct substances denoted with ​$A_1$​, $A_2$​, …, ​$A_M$​. He\nhas an unlimited quantity of each substance from that set. Joško wants to know which\nsubstances he can create using a list of reactions of ancient alchemists, so he’s asking you\nto help him solve this problem.", "inputFormat": "The first line of input contains two integers N and M (1 ≤ M ≤ N ≤ 100 000), the numbers from the task.\n\nThe second line of input contains M integers $A_i$ (1 ≤ $A_i$ ≤ N), labels of the substances Joško has in the beginning.\n\nThe third line of input contains the integer K (1 ≤ K ≤ 100 000), the number of known\nreactions.\n\nThe following 3·K lines contain a list of reactions. Each reaction is described with 3 lines in the following way:\n\n- The first line contains the integers L and R (1 ≤ L, R ≤ N).\n- The second line contains L distinct integers $X_i$ (1 ≤ $X_i$ ≤ N).\n- The third line contains R distinct integers $Y_i$ (1 ≤ $Y_i$ ≤ N).\n- This describes the reaction with which the substance set {$X_1$, $X_2$, …, $X_L$} transforms into substance set {$Y_1$, $Y_2$, …, $Y_R$}.\n\nThe sum of all L values won’t exceed 100 000.\n\nThe sum of all R values won’t exceed 100 000.", "outputFormat": "The first line of output must contain the integer X, the number of obtainable substances.\n\nThe second line of output must contain X distinct integers $B_i$, sorted ascendingly, that represent the labels of the obtainable substances.\n", "hint": "In test cases worth 60% of total points, it will hold:\n\n- N, K ≤ 500.\n- The sum of all L values and the sum of all R values won’t exceed 500.\n\n**Clarification of the first test case:**\n\nThere are 2 reactions.\n\nThe first reaction transforms substance set {1, 2} into substance set {3}.\n\nThe second reaction transforms substance set {1, 3} into substance set {4}.\n\nJoško initially has substances from the set {1, 2}.\n\nUsing the first reaction, Joško can obtain substance 3, after which he has substances from the set {1, 2, 3}.\n\nAfter that, using the second reaction, he can also obtain substance 4.\n\n**Clarification of the second test case:**\n\nJoško initially has substances from the set {1, 4, 5}.\n\nUsing the second reaction, it is possible to obtain substance 6, after which it is possible to apply the third reaction, giving substance 2.\n\nThe first reaction is impossible to apply because Joško doesn’t have substance 3.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #6] Alkemija", "background": "", "description": "在古代，当炼金术士们在寻找黄金时，世界上已知共有 N 种不同的物质，用 1 到 N 表示。经过多年的努力，寻找秘密配方，炼金术士们发现了一系列有趣的规律——炼金反应。在一种反应中，可以将物质集合 $\\{X_1, X_2, \\ldots, X_L\\}$ 转化为另一种物质集合 $\\{Y_1, Y_2, \\ldots, Y_R\\}$。例如，物质集合 $\\{1, 4, 5\\}$ 可能反应一次并生成新的物质集合 $\\{2, 6\\}$。\n\nJoško 是一位现代炼金术士，他拥有 M 种不同的物质，用 $A_1, A_2, \\ldots, A_M$ 表示。他拥有这些物质的无限量。Joško 想知道他可以使用古代炼金术士的反应列表创造出哪些物质，所以他请你帮助他解决这个问题。", "inputFormat": "输入的第一行包含两个整数 N 和 M ($1 \\leq M \\leq N \\leq 100\\,000$)，即题目中的数字。\n\n输入的第二行包含 M 个整数 $A_i$ ($1 \\leq A_i \\leq N$)，表示 Joško 起初拥有的物质的标签。\n\n输入的第三行包含整数 K ($1 \\leq K \\leq 100\\,000$)，即已知反应的数量。\n\n接下来的 $3 \\cdot K$ 行包含反应列表。每个反应由以下 3 行描述：\n\n- 第一行包含整数 L 和 R ($1 \\leq L, R \\leq N$)。\n- 第二行包含 L 个不同的整数 $X_i$ ($1 \\leq X_i \\leq N$)。\n- 第三行包含 R 个不同的整数 $Y_i$ ($1 \\leq Y_i \\leq N$)。\n- 这描述了物质集合 $\\{X_1, X_2, \\ldots, X_L\\}$ 转化为物质集合 $\\{Y_1, Y_2, \\ldots, Y_R\\}$ 的反应。\n\n所有 L 值的总和不会超过 100\\,000。\n\n所有 R 值的总和不会超过 100\\,000。", "outputFormat": "输出的第一行必须包含整数 X，即可以获得的物质数量。\n\n输出的第二行必须包含 X 个不同的整数 $B_i$，按升序排列，表示可以获得的物质的标签。", "hint": "在总分值的 60% 的测试用例中，将满足：\n\n- $N, K \\leq 500$。\n- 所有 L 值的总和和所有 R 值的总和不会超过 500。\n\n**第一个测试用例的说明：**\n\n有 2 个反应。\n\n第一个反应将物质集合 $\\{1, 2\\}$ 转化为物质集合 $\\{3\\}$。\n\n第二个反应将物质集合 $\\{1, 3\\}$ 转化为物质集合 $\\{4\\}$。\n\nJoško 起初拥有物质集合 $\\{1, 2\\}$。\n\n使用第一个反应，Joško 可以获得物质 3，之后他拥有物质集合 $\\{1, 2, 3\\}$。\n\n之后，使用第二个反应，他还可以获得物质 4。\n\n**第二个测试用例的说明：**\n\nJoško 起初拥有物质集合 $\\{1, 4, 5\\}$。\n\n使用第二个反应，可以获得物质 6，之后可以应用第三个反应，得到物质 2。\n\n第一个反应无法应用，因为 Joško 没有物质 3。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4958", "type": "P", "difficulty": 4, "samples": [["banana\n3\n2 na\n3 ba\n4 nn", "3\n0\n1"], ["malimateodmameitate\n3\n10 ot\n7 aa\n3 me", "2\n464\n56"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #6] Mate", "background": "", "description": "Little Mate got an array of lowercase letters from the English alphabet as a present from his\nparents. In order to have at least some use of such a clever present, he decided to use it for\nfinding rhymes when writing his next song.\n\nTo find a specific rhyme, Mate wants to select a word of length D that ends with an array of\ncharacters XY, i.e. where the next to last letter is X, and the last Y. Mate’s process of\nselecting a word is by first crossing out some letters in a given sequence, and then merging\nthe letters he didn’t cross out into a single word. He wants to know in how many different\nways he can cross out the letters so that he meets the given conditions.\n\nThe selection of two words is considered distinct if the sets of positions of the crossed-out\nletters are different.\n", "inputFormat": "The first line of input contains an array of lowercase letters of the English alphabet S (2 ≤ |S|\n≤ 2000).\n\nThe second line of input contains the integer Q (1 ≤ Q ≤ 500 000), the number of different\nrhymes for which Mate needs to select words.\n\nEach of the following Q lines contains the integer D (2 ≤ D ≤ |S|) and an array of lowercase\nletters of the English alphabet XY from the task.", "outputFormat": "The $i^{th}$ out of Q lines must contain the required number of ways for the $i^{th}$ rhyme. Since that number can be quite large, output only the value **modulo 1 000 000 007​**.", "hint": "In test cases worth 40% of total points, it will hold |S| ≤ 50.\n\nIn test cases worth an additional 40% of total points, it will hold |S| ≤ 200.\n\n**Clarification of the first test case:**\n\nWord of length 2 that ends with “na” can be obtained in the following ways:\n\n~~b a n a~~$\\ $**n a**​, ~~b a~~$\\ $**n a**$\\ $~~​n a~~, ~~b a~~$\\ $**n**​ ~~a n~~$\\ $**a**", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #6] Mate", "background": "", "description": "Little Mate got an array of lowercase letters from the English alphabet as a present from his\nparents. In order to have at least some use of such a clever present, he decided to use it for\nfinding rhymes when writing his next song.\n\nTo find a specific rhyme, Mate wants to select a word of length D that ends with an array of\ncharacters XY, i.e. where the next to last letter is X, and the last Y. Mate’s process of\nselecting a word is by first crossing out some letters in a given sequence, and then merging\nthe letters he didn’t cross out into a single word. He wants to know in how many different\nways he can cross out the letters so that he meets the given conditions.\n\nThe selection of two words is considered distinct if the sets of positions of the crossed-out\nletters are different.\n", "inputFormat": "The first line of input contains an array of lowercase letters of the English alphabet S (2 ≤ |S|\n≤ 2000).\n\nThe second line of input contains the integer Q (1 ≤ Q ≤ 500 000), the number of different\nrhymes for which Mate needs to select words.\n\nEach of the following Q lines contains the integer D (2 ≤ D ≤ |S|) and an array of lowercase\nletters of the English alphabet XY from the task.", "outputFormat": "The $i^{th}$ out of Q lines must contain the required number of ways for the $i^{th}$ rhyme. Since that number can be quite large, output only the value **modulo 1 000 000 007​**.", "hint": "In test cases worth 40% of total points, it will hold |S| ≤ 50.\n\nIn test cases worth an additional 40% of total points, it will hold |S| ≤ 200.\n\n**Clarification of the first test case:**\n\nWord of length 2 that ends with “na” can be obtained in the following ways:\n\n~~b a n a~~$\\ $**n a**​, ~~b a~~$\\ $**n a**$\\ $~~​n a~~, ~~b a~~$\\ $**n**​ ~~a n~~$\\ $**a**", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #6] Mate", "background": "", "description": "小 Mate 收到了一个由小写英文字母组成的数组，作为他父母送的礼物。为了让这个聪明的礼物有些用处，他决定在写下一首歌时用它来寻找押韵。\n\n为了找到特定的韵脚，Mate 想要选择一个长度为 D 的单词，该单词以字符数组 XY 结尾，即倒数第二个字母是 X，最后一个字母是 Y。Mate 选择单词的过程是首先划掉给定序列中的一些字母，然后将未划掉的字母合并成一个单词。他想知道有多少种不同的方式可以划掉字母，以满足给定的条件。\n\n如果两个单词的划掉字母的位置集合不同，则认为这两个单词是不同的。", "inputFormat": "输入的第一行包含一个由小写英文字母组成的数组 S (2 ≤ |S| ≤ 2000)。\n\n输入的第二行包含整数 Q (1 ≤ Q ≤ 500 000)，表示 Mate 需要选择单词的不同韵脚的数量。\n\n接下来的 Q 行中的每一行包含一个整数 D (2 ≤ D ≤ |S|) 和一个由小写英文字母组成的字符数组 XY。", "outputFormat": "Q 行中的第 $i$ 行必须包含第 $i$ 个韵脚所需的方式数。由于该数字可能非常大，只输出值对 1 000 000 007 取模后的结果。", "hint": "在占总分 40% 的测试用例中，将满足 |S| ≤ 50。\n\n在额外占总分 40% 的测试用例中，将满足 |S| ≤ 200。\n\n**第一个测试用例的说明：**\n\n以“na”结尾的长度为 2 的单词可以通过以下方式获得：\n\n~~b a n a~~ **n a**，~~b a~~ **n a** ~~n a~~，~~b a~~ **n** ~~a n~~ **a**。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4959", "type": "P", "difficulty": 5, "samples": [["2\n1 1\n-1 -1", "4"], ["3\n-7 19\n9 -30\n25 10\n", "2080"], ["6\n1 20\n3 17\n5 15\n8 12\n9 11\n10 10", "760"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2017", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #6] Cover", "background": "", "description": "You are given N points in the coordinate system. They need to be covered with one or more\nrectangles, such that the following conditions are met:\n\n- The sides of each rectangle are parallel with the coordinate axes,\n- The center of each rectangle is in the origin, i.e. point (0, 0),\n- Each given point is located either inside of the rectangle or on its boundaries.\n\nOf course, it is possible to cover all the points using only one rectangle, but this rectangle\ncould have a very large surface area. Our goal is to find a selection of required rectangles\nsuch that the sum of their surface areas is minimal.", "inputFormat": "The first line of input contains the integer N (1 ≤ N ≤ 5000), the number of points.\n\nEach of the following N lines contains two integers X and Y (-50 000 000 ≤ X, Y ≤ 50 000\n000, XY ≠ 0), the coordinates of each point.\n", "outputFormat": "You must output the required minimal sum of surface areas of the rectangles.\n", "hint": "In test cases worth 40% of total points, it will hold N ≤ 20.\n\n**Clarification of the first test case:** ​We choose the rectangle whose opposite angles are the given\npoints, since it meets the conditions from the task.\n\n**Clarification of the second test case:** ​We choose two rectangles with their centers in the origin. The\nfirst is of dimensions 50 x 20 and covers point (25, 10). The second is of dimensions 18 x 60 and covers the first two points. If we wanted to cover all the points using one rectangle, it would be of\ndimensions 50 x 60.", "locale": "en", "translations": {"en": {"title": "[COCI 2017/2018 #6] Cover", "background": "", "description": "You are given N points in the coordinate system. They need to be covered with one or more\nrectangles, such that the following conditions are met:\n\n- The sides of each rectangle are parallel with the coordinate axes,\n- The center of each rectangle is in the origin, i.e. point (0, 0),\n- Each given point is located either inside of the rectangle or on its boundaries.\n\nOf course, it is possible to cover all the points using only one rectangle, but this rectangle\ncould have a very large surface area. Our goal is to find a selection of required rectangles\nsuch that the sum of their surface areas is minimal.", "inputFormat": "The first line of input contains the integer N (1 ≤ N ≤ 5000), the number of points.\n\nEach of the following N lines contains two integers X and Y (-50 000 000 ≤ X, Y ≤ 50 000\n000, XY ≠ 0), the coordinates of each point.\n", "outputFormat": "You must output the required minimal sum of surface areas of the rectangles.\n", "hint": "In test cases worth 40% of total points, it will hold N ≤ 20.\n\n**Clarification of the first test case:** ​We choose the rectangle whose opposite angles are the given\npoints, since it meets the conditions from the task.\n\n**Clarification of the second test case:** ​We choose two rectangles with their centers in the origin. The\nfirst is of dimensions 50 x 20 and covers point (25, 10). The second is of dimensions 18 x 60 and covers the first two points. If we wanted to cover all the points using one rectangle, it would be of\ndimensions 50 x 60.", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #6] Cover", "background": "", "description": "给定坐标系中的 N 个点。需要用一个或多个矩形覆盖这些点，使得满足以下条件：\n\n- 每个矩形的边平行于坐标轴，\n- 每个矩形的中心在原点，即点 (0, 0)，\n- 每个给定点要么在矩形内部，要么在其边界上。\n\n当然，可以用一个矩形覆盖所有的点，但这个矩形可能会有非常大的面积。我们的目标是找到所需矩形的选择，使得它们的面积总和最小。", "inputFormat": "输入的第一行包含整数 N (1 ≤ N ≤ 5000)，表示点的数量。\n\n接下来的 N 行中的每一行包含两个整数 X 和 Y (-50 000 000 ≤ X, Y ≤ 50 000 000, XY ≠ 0)，表示每个点的坐标。", "outputFormat": "你必须输出所需的矩形面积总和的最小值。", "hint": "在占总分 40% 的测试用例中，将满足 N ≤ 20。\n\n**第一个测试用例的说明：** 我们选择以给定点为对角的矩形，因为它满足题目中的条件。\n\n**第二个测试用例的说明：** 我们选择两个中心在原点的矩形。第一个矩形的尺寸为 50 x 20，覆盖点 (25, 10)。第二个矩形的尺寸为 18 x 60，覆盖前两个点。如果我们想用一个矩形覆盖所有点，它的尺寸将是 50 x 60。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4960", "type": "P", "difficulty": 3, "samples": [["7\n1 2 3 5 4 4 4", "3 2\n1 4\n5 3 1 2 4 5\n1 4"], ["3\n20181110 20181111 20181111", "2 1\n1 20181110\n2 20181111 20181111"], ["3\n20181110 20181111 20181111", "2 2\n2 20181110 20181111\n1 20181111"], ["5\n3 2 3 2 3", "2 1\n3 3 3 3\n2 2 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["Special Judge", "枚举", "排序"], "title": "血小板与凝血因子", "background": "为了尽快修复伤口，血小板们正在搬运凝血因子。它们（没毛病）正在讨论怎么分配，因为它们太可爱了，所以就让你来解决这个问题。\n\n![](https://i.loli.net/2018/10/05/5bb7372e781b1.jpg)", "description": "血小板们有两种不同的容器，第一种容器每个容器中只能装同一种凝血因子，第二种容器每个容器中每种凝血因子最多出现一次。为了方便，血小板们想用**同一种**容器装下所有的凝血因子。\n\n换句话说，把 $n$ 个正整数 $a_1$ ~ $a_n$ 分成一些不相交的集合 $S_1$ ~ $S_m$，满足以下两个条件**之一**： \n1. $\\forall a_i,\\ a_j\\in S_k,\\ k\\in [1,\\ m]$ 有 $a_i=a_j$\n2. $\\forall a_i,\\ a_j\\in S_k,\\ k\\in [1,\\ m],\\ i\\neq j$ 有 $a_i\\neq a_j$\n\n因为血小板的数量比较少，所以你要把所有的凝血因子装到尽量少的容器里。它们想知道，如何划分能使容器的总数最小。", "inputFormat": "第一行，一个正整数 $n$，表示凝血因子的个数。\n\n第二行，$n$ 个正整数 $a_i$，分别表示凝血因子的种类。", "outputFormat": "第一行，两个正整数，第一个正整数代表容器数的最小值 $m$，第二个正整数代表所用容器的种类（$1$ 或 $2$）。\n\n接下来的 $m$ 行，每行第一个正整数 $c_i$ 代表这个容器装的凝血因子个数，后面的 $c_i$ 个数代表这个容器中装的每个凝血因子的种类。\n\n输出任意一组合法的最优解即可，输出顺序不限。", "hint": "$1\\le n\\le 1000,\\ \\ 1\\le a_i\\le 10^9$。\n\n## 样例解释\n\n### 样例一：\n\n选用第二种容器，分别放入 $\\{4\\}$，$\\{3,1,2,4,5\\}$，$\\{4\\}$，这是一组可行的最优解，更改三个容器的顺序、容器 $2$ 中 $5$ 个凝血因子的顺序可以得到另外的最优解。\n\n### 样例二/三：\n\n这两组样例输入相同，既可以选用第一种容器，也可以选用第二种容器。\n\n两组样例的输出分别为一组可行的最优解，改变顺序可以得到另外的几组最优解。\n\n### 样例四：\n\n选用第一种容器，分别放入 $\\{3,3,3\\}$，$\\{2,2\\}$，这是一组可行的最优解，更改两个容器的顺序可以得到另一组最优解。", "locale": "zh-CN", "translations": {"en": {"title": "Platelets and Coagulation Factors", "background": "To repair the wound as soon as possible, the platelets are carrying coagulation factors. They (nothing wrong) are discussing how to distribute them. Since they are so cute, you are asked to solve this problem.\n\n![](https://i.loli.net/2018/10/05/5bb7372e781b1.jpg)", "description": "The platelets have two different types of containers. In the first type, each container can hold only one kind of coagulation factor. In the second type, in each container, each kind of coagulation factor can appear at most once. For convenience, the platelets want to use **only one** type of container to hold all coagulation factors.\n\nIn other words, partition $n$ positive integers $a_1$ ~ $a_n$ into some disjoint sets $S_1$ ~ $S_m$, satisfying **one** of the following two conditions:\n1. $\\forall a_i,\\ a_j\\in S_k,\\ k\\in [1,\\ m]$, we have $a_i=a_j$.\n2. $\\forall a_i,\\ a_j\\in S_k,\\ k\\in [1,\\ m],\\ i\\neq j$, we have $a_i\\neq a_j$.\n\nSince there are not many platelets, you need to put all coagulation factors into as few containers as possible. They want to know how to partition them so that the total number of containers is minimized.", "inputFormat": "The first line contains a positive integer $n$, the number of coagulation factors.\n\nThe second line contains $n$ positive integers $a_i$, each representing the type of a coagulation factor.", "outputFormat": "The first line contains two positive integers. The first is the minimum number of containers $m$, and the second is the type of container used ($1$ or $2$).\n\nIn the next $m$ lines, in each line, the first positive integer $c_i$ represents the number of coagulation factors in this container, followed by $c_i$ integers representing the type of each coagulation factor in this container.\n\nOutput any valid optimal solution. The output order does not matter.", "hint": "Constraints: $1\\le n\\le 1000,\\ \\ 1\\le a_i\\le 10^9$。\n\n# Input Format\n\n# Output Format\n\n# Hint\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "血小板与凝血因子", "background": "为了尽快修复伤口，血小板们正在搬运凝血因子。它们（没毛病）正在讨论怎么分配，因为它们太可爱了，所以就让你来解决这个问题。\n\n![](https://i.loli.net/2018/10/05/5bb7372e781b1.jpg)", "description": "血小板们有两种不同的容器，第一种容器每个容器中只能装同一种凝血因子，第二种容器每个容器中每种凝血因子最多出现一次。为了方便，血小板们想用**同一种**容器装下所有的凝血因子。\n\n换句话说，把 $n$ 个正整数 $a_1$ ~ $a_n$ 分成一些不相交的集合 $S_1$ ~ $S_m$，满足以下两个条件**之一**： \n1. $\\forall a_i,\\ a_j\\in S_k,\\ k\\in [1,\\ m]$ 有 $a_i=a_j$\n2. $\\forall a_i,\\ a_j\\in S_k,\\ k\\in [1,\\ m],\\ i\\neq j$ 有 $a_i\\neq a_j$\n\n因为血小板的数量比较少，所以你要把所有的凝血因子装到尽量少的容器里。它们想知道，如何划分能使容器的总数最小。", "inputFormat": "第一行，一个正整数 $n$，表示凝血因子的个数。\n\n第二行，$n$ 个正整数 $a_i$，分别表示凝血因子的种类。", "outputFormat": "第一行，两个正整数，第一个正整数代表容器数的最小值 $m$，第二个正整数代表所用容器的种类（$1$ 或 $2$）。\n\n接下来的 $m$ 行，每行第一个正整数 $c_i$ 代表这个容器装的凝血因子个数，后面的 $c_i$ 个数代表这个容器中装的每个凝血因子的种类。\n\n输出任意一组合法的最优解即可，输出顺序不限。", "hint": "$1\\le n\\le 1000,\\ \\ 1\\le a_i\\le 10^9$。\n\n## 样例解释\n\n### 样例一：\n\n选用第二种容器，分别放入 $\\{4\\}$，$\\{3,1,2,4,5\\}$，$\\{4\\}$，这是一组可行的最优解，更改三个容器的顺序、容器 $2$ 中 $5$ 个凝血因子的顺序可以得到另外的最优解。\n\n### 样例二/三：\n\n这两组样例输入相同，既可以选用第一种容器，也可以选用第二种容器。\n\n两组样例的输出分别为一组可行的最优解，改变顺序可以得到另外的几组最优解。\n\n### 样例四：\n\n选用第一种容器，分别放入 $\\{3,3,3\\}$，$\\{2,2\\}$，这是一组可行的最优解，更改两个容器的顺序可以得到另一组最优解。", "locale": "zh-CN"}}}
{"pid": "P4961", "type": "P", "difficulty": 2, "samples": [["8 8\n0 0 0 1 1 0 0 0 \n1 0 0 1 0 0 0 1 \n1 0 0 1 0 0 0 0 \n0 0 0 0 0 0 0 0 \n0 0 0 0 0 1 0 0 \n0 0 0 0 0 0 0 0 \n0 0 0 0 0 0 0 0 \n0 1 0 0 0 0 0 0 ", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["模拟", "深度优先搜索 DFS"], "title": "小埋与扫雷", "background": "小埋总是在家中打游戏，一天，她突然想玩Windows自带的扫雷，在一旁的哥哥看见了，想起了自己小时候信息课在机房玩扫雷的日子，便兴致勃勃地开始教小埋扫雷。然而，小埋还是不明白 $\\mathrm{3bv}$（Bechtel's Board Benchmark Value，每局将所有非雷的方块点开所需最少左键点击数，参见[扫雷网的教程](http://saolei.net/BBS/Title.asp?Id=227) ）怎么算，于是她找到了你。\n\n![](https://i.loli.net/2018/10/04/5bb5bd6aefb70.jpg)", "description": "小埋会告诉你一盘扫雷，用一个 $n\\times m$ 的矩阵表示，$1$ 是雷 ，$0$ 不是雷，请你告诉她这盘扫雷的 $\\mathrm{3bv}$ 。 \n\n周围八格没有“雷”且自身不是“雷”的方格称为“空格”，周围八格有“雷”且自身不是“雷”的方格称为“数字”，由“空格”组成的八连通块称为一个“空”。$\\mathrm{3bv}=\\ $周围八格没有“空格”的“数字”个数$+$“空\"的个数。\n\n如果看不懂上面的计算方式，可以看题目背景中给出的教程，或者看下面的样例解释。\n\n注：[八连通](https://baike.baidu.com/item/%E5%85%AB%E8%BF%9E%E9%80%9A)", "inputFormat": "第一行有两个整数 $n$ 和 $m$，代表这盘扫雷是一个 $n \\times m$ 的矩阵。\n\n后面的 $n$ 行每行有 $m$ 个整数，表示这个矩阵，每个数字为 $0$ 或 $1$，$1$ 代表是雷，$0$ 代表不是雷。", "outputFormat": "一个整数，代表这盘扫雷的 $\\mathrm{3bv}$ 。", "hint": "$1\\le n,\\ m\\le 1000$\n\n## 样例解释\n\n![](https://i.loli.net/2018/10/04/5bb5bc4644183.jpg)", "locale": "zh-CN", "translations": {"en": {"title": "Umaru and Minesweeper", "background": "Umaru is always playing games at home. One day, she suddenly wanted to play the Minesweeper that comes with Windows. Her older brother saw this and remembered the days when he played Minesweeper in the computer lab during IT class when he was young, so he happily started teaching Umaru how to play. However, Umaru still did not understand how to compute $\\mathrm{3bv}$ (Bechtel's Board Benchmark Value, the minimum number of left clicks needed to open all non-mine cells in one game; see the [tutorial on saolei.net](http://saolei.net/BBS/Title.asp?Id=227)), so she came to you.\n\n![](https://i.loli.net/2018/10/04/5bb5bd6aefb70.jpg)", "description": "Umaru will tell you a Minesweeper board, represented by an $n\\times m$ matrix, where $1$ means a mine and $0$ means not a mine. Please tell her the $\\mathrm{3bv}$ of this board.\n\nA cell that is not a mine and has no mines in the eight surrounding cells is called an \"empty cell\". A cell that is not a mine and has at least one mine in the eight surrounding cells is called a \"number cell\". An 8-connected component consisting of \"empty cells\" is called an \"empty area\". $\\mathrm{3bv}=$ (the number of \"number cells\" that have no \"empty cells\" in their eight surrounding cells) $+$ (the number of \"empty areas\").\n\nIf you cannot understand the computation above, you can read the tutorial given in the Background, or see the sample explanation below.\n\nNote: [8-connectivity](https://baike.baidu.com/item/%E5%85%AB%E8%BF%9E%E9%80%9A)", "inputFormat": "The first line contains two integers $n$ and $m$, meaning the Minesweeper board is an $n \\times m$ matrix.\n\nThe next $n$ lines each contain $m$ integers, describing the matrix. Each number is either $0$ or $1$. $1$ means the cell is a mine, and $0$ means it is not a mine.", "outputFormat": "Output one integer, representing the $\\mathrm{3bv}$ of this Minesweeper board.", "hint": "$1\\le n,\\ m\\le 1000$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小埋与扫雷", "background": "小埋总是在家中打游戏，一天，她突然想玩Windows自带的扫雷，在一旁的哥哥看见了，想起了自己小时候信息课在机房玩扫雷的日子，便兴致勃勃地开始教小埋扫雷。然而，小埋还是不明白 $\\mathrm{3bv}$（Bechtel's Board Benchmark Value，每局将所有非雷的方块点开所需最少左键点击数，参见[扫雷网的教程](http://saolei.net/BBS/Title.asp?Id=227) ）怎么算，于是她找到了你。\n\n![](https://i.loli.net/2018/10/04/5bb5bd6aefb70.jpg)", "description": "小埋会告诉你一盘扫雷，用一个 $n\\times m$ 的矩阵表示，$1$ 是雷 ，$0$ 不是雷，请你告诉她这盘扫雷的 $\\mathrm{3bv}$ 。 \n\n周围八格没有“雷”且自身不是“雷”的方格称为“空格”，周围八格有“雷”且自身不是“雷”的方格称为“数字”，由“空格”组成的八连通块称为一个“空”。$\\mathrm{3bv}=\\ $周围八格没有“空格”的“数字”个数$+$“空\"的个数。\n\n如果看不懂上面的计算方式，可以看题目背景中给出的教程，或者看下面的样例解释。\n\n注：[八连通](https://baike.baidu.com/item/%E5%85%AB%E8%BF%9E%E9%80%9A)", "inputFormat": "第一行有两个整数 $n$ 和 $m$，代表这盘扫雷是一个 $n \\times m$ 的矩阵。\n\n后面的 $n$ 行每行有 $m$ 个整数，表示这个矩阵，每个数字为 $0$ 或 $1$，$1$ 代表是雷，$0$ 代表不是雷。", "outputFormat": "一个整数，代表这盘扫雷的 $\\mathrm{3bv}$ 。", "hint": "$1\\le n,\\ m\\le 1000$\n\n## 样例解释\n\n![](https://i.loli.net/2018/10/04/5bb5bc4644183.jpg)", "locale": "zh-CN"}}}
{"pid": "P4962", "type": "P", "difficulty": 6, "samples": [["8 19 3\n1 2 0 1 1 1 2 0\n3 1 4\n3 2 2\n1 4 1\n7 4 10\n5 4 7\n4 2 5\n5 6 4\n4 7 3\n8 5 10\n3 6 8\n8 1 10\n5 2 10\n6 7 3\n4 3 9\n6 2 5\n4 8 10\n3 8 3\n1 7 8\n1 3 9", "11"], ["5 6 3\n0 1 1 2 2\n1 2 3\n2 3 2\n1 4 2\n5 2 1\n1 3 4\n5 4 1", "Ushio!"], ["6 13 3\n2 2 2 1 0 2\n1 4 4\n3 4 8\n5 3 2\n4 5 6\n2 3 2\n1 3 3\n1 2 4\n3 1 4\n6 3 6\n3 2 6\n2 1 6\n4 2 9\n5 2 1", "7"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["搜索", "剪枝", "记忆化搜索", "状压 DP"], "title": "朋也与光玉", "background": "> 一つ一つの光は小さくでも、たくさん集まればきっととても不思議な大きな力になるはず。 \n\n渚的离世、汐的离去...朋也的人生几乎陷入了一片黑暗。\n\n但是，这会是结束吗？\n\n![](https://i.loli.net/2018/10/04/5bb5f64297c70.jpg)", "description": "光坂小镇是一个由 $n$ 个点（编号为 $1$ ~ $n$），$m$ 条有向边构成的图，每个节点上都有一个光玉，光玉共有 $k$ 种，编号为 $0$ ~ $k-1$。\n\n为了使一切改变，朋也需要找齐全部的 $k$ 种光玉。他可以从任意一个节点出发，在图上任意行走，但不会经过同一个节点两次，每碰到一个光玉便会将其收集，收集到 $k$ 个光玉后，即经过了 $k$ 个节点后，便不会继续收集。请设计一种方案，使得朋也能够收集全部的 $k$ 种光玉，且走过的路径长度最短。\n\n换句话说，每个点一个颜色，找到一条最短的点数为 $k$ 、恰好经过全部 $k$ 种颜色的路径。你需要求出这条路径的长度。", "inputFormat": "第一行，三个正整数 $n,\\ m,\\ k$，分别代表节点个数、边的条数、光玉的种类数。\n\n第二行，共 $n$ 个正整数 $a_1$ ~ $a_n$，其中 $a_i$ 代表 $i$ 号节点的光玉种类编号。\n\n接下来 $m$ 行，每行三个正整数 $u_i,\\ v_i,\\ w_i$，表示 $u_i$ 到 $v_i$ 有一条长度为 $w_i$ 的有向边。", "outputFormat": "输出一行，若有解则输出一个正整数表示满足条件的最短路径的长度，若无解则输出\"Ushio!\"（不含引号）", "hint": "$2\\le n\\le 100$，$1\\le m\\le n(n-1)$，$2\\le k\\le 13$，$1\\le w_i\\le 10^7$\n\n保证图中没有重边、自环。\n\n## 样例解释\n\n样例一，$3\\rightarrow 6\\rightarrow 7$ 为一组最优解。\n\n样例二，无解。\n\n样例三，最优解为 $4\\rightarrow 5\\rightarrow 2$。", "locale": "zh-CN", "translations": {"en": {"title": "Tomoya and the Light Orbs", "background": "> Even if each light is small, if many gather together, it will surely become a very mysterious and great power.\n\nNagisa’s death, Ushio’s departure... Tomoya’s life has almost fallen into complete darkness.\n\nBut is this the end?\n\n![](https://i.loli.net/2018/10/04/5bb5f64297c70.jpg)", "description": "Hikarizaka Town is a directed graph with $n$ nodes (numbered $1$ to $n$) and $m$ directed edges. Each node has a light orb. There are $k$ types of light orbs, numbered $0$ to $k-1$.\n\nTo change everything, Tomoya needs to collect all $k$ types of light orbs. He may start from any node and walk freely in the graph, but he will not pass through the same node twice. Each time he encounters a light orb, he will collect it. After collecting $k$ light orbs, that is, after visiting $k$ nodes, he will stop collecting. Design a plan so that Tomoya can collect all $k$ types of light orbs, and the total path length is as short as possible.\n\nIn other words, each node has one color. Find a shortest path that visits exactly $k$ nodes and covers all $k$ colors exactly once. You need to output the length of this path.", "inputFormat": "The first line contains three positive integers $n,\\ m,\\ k$, representing the number of nodes, the number of edges, and the number of light orb types.\n\nThe second line contains $n$ positive integers $a_1$ to $a_n$, where $a_i$ is the type index of the light orb on node $i$.\n\nThe next $m$ lines each contain three positive integers $u_i,\\ v_i,\\ w_i$, indicating a directed edge from $u_i$ to $v_i$ with length $w_i$.", "outputFormat": "Output one line. If a solution exists, output a positive integer representing the length of the shortest path that satisfies the condition. If no solution exists, output `Ushio!` (without quotes).", "hint": "Constraints: $2\\le n\\le 100$，$1\\le m\\le n(n-1)$，$2\\le k\\le 13$，$1\\le w_i\\le 10^7$.\n\nIt is guaranteed that the graph has no multiple edges or self-loops.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "朋也与光玉", "background": "> 一つ一つの光は小さくでも、たくさん集まればきっととても不思議な大きな力になるはず。 \n\n渚的离世、汐的离去...朋也的人生几乎陷入了一片黑暗。\n\n但是，这会是结束吗？\n\n![](https://i.loli.net/2018/10/04/5bb5f64297c70.jpg)", "description": "光坂小镇是一个由 $n$ 个点（编号为 $1$ ~ $n$），$m$ 条有向边构成的图，每个节点上都有一个光玉，光玉共有 $k$ 种，编号为 $0$ ~ $k-1$。\n\n为了使一切改变，朋也需要找齐全部的 $k$ 种光玉。他可以从任意一个节点出发，在图上任意行走，但不会经过同一个节点两次，每碰到一个光玉便会将其收集，收集到 $k$ 个光玉后，即经过了 $k$ 个节点后，便不会继续收集。请设计一种方案，使得朋也能够收集全部的 $k$ 种光玉，且走过的路径长度最短。\n\n换句话说，每个点一个颜色，找到一条最短的点数为 $k$ 、恰好经过全部 $k$ 种颜色的路径。你需要求出这条路径的长度。", "inputFormat": "第一行，三个正整数 $n,\\ m,\\ k$，分别代表节点个数、边的条数、光玉的种类数。\n\n第二行，共 $n$ 个正整数 $a_1$ ~ $a_n$，其中 $a_i$ 代表 $i$ 号节点的光玉种类编号。\n\n接下来 $m$ 行，每行三个正整数 $u_i,\\ v_i,\\ w_i$，表示 $u_i$ 到 $v_i$ 有一条长度为 $w_i$ 的有向边。", "outputFormat": "输出一行，若有解则输出一个正整数表示满足条件的最短路径的长度，若无解则输出\"Ushio!\"（不含引号）", "hint": "$2\\le n\\le 100$，$1\\le m\\le n(n-1)$，$2\\le k\\le 13$，$1\\le w_i\\le 10^7$\n\n保证图中没有重边、自环。\n\n## 样例解释\n\n样例一，$3\\rightarrow 6\\rightarrow 7$ 为一组最优解。\n\n样例二，无解。\n\n样例三，最优解为 $4\\rightarrow 5\\rightarrow 2$。", "locale": "zh-CN"}}}
{"pid": "P4963", "type": "P", "difficulty": 6, "samples": [["7 4", "11"], ["15 3", "25"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["动态规划 DP", "数学", "枚举"], "title": "美樱的颜料", "background": "在春辉去美国留学之后，美樱时常感到寂寞。为了排解寂寞，她在画画时总是对颜料有着特殊的要求。\n\n![](https://i.loli.net/2018/10/10/5bbd8d3178ee9.jpg)", "description": "美樱共有 $n$ 种不同的颜料，编号依次为 $1$ ~ $n$，每种颜料只能使用一次。开始画一幅画时，美樱可以任意选择一种颜料使用。之后，美樱每次都会选择一种颜料 $i$ 使用，满足使用颜料 $i$ 后已经使用了的颜料的编号的 $gcd$（最大公约数）尽量大，即：\n\n> 设现在已经使用了的颜料编号构成的集合为 $A$，若$\\ \\exists\\ i,\\ j\\notin A,\\ i,\\ j\\in [1,\\ n],\\ gcd(A,\\ i)>gcd(A,\\ j)$，那么就不能选择颜料 $j$。\n\n如果有多种满足条件的颜料，美樱可以任意选择一种使用。每使用完一种颜料，美樱就会获得当前使用了的所有颜料的编号的 $gcd$ 的快乐值。\n\n现在美樱想画一幅使用 $m$ 种颜料的画，她能够获得的最大快乐值之和是多少？", "inputFormat": "共一行，两个正整数 $n,\\ m$，分别代表颜料的种类数和美樱要使用的颜料数。", "outputFormat": "一个正整数，美樱能获得的最大快乐值。", "hint": "$1\\le m\\le n\\le 10^7$\n\n## 样例解释\n\n样例一：`6 3 5 2`为一组最优解，每次获得的快乐值分别为`6 3 1 1`\n\n样例二：`15 10 5`为一组最优解，每次获得的快乐值分别为`15 5 5`", "locale": "zh-CN", "translations": {"en": {"title": "Miying’s Paints", "background": "After Chunhui went to the United States to study abroad, Miying often felt lonely. To ease her loneliness, she always has special requirements for paints when she draws.\n\n![](https://i.loli.net/2018/10/10/5bbd8d3178ee9.jpg)", "description": "Miying has $n$ different kinds of paints, numbered from $1$ to $n$. Each kind of paint can be used at most once. When she starts a painting, she may choose any one paint to use.\n\nAfter that, each time Miying chooses a paint $i$ to use such that, after using paint $i$, the $gcd$ (greatest common divisor) of the indices of all paints used so far is as large as possible, that is:\n\n> Let the set of indices of paints already used be $A$. If $\\ \\exists\\ i,\\ j\\notin A,\\ i,\\ j\\in [1,\\ n],\\ gcd(A,\\ i)>gcd(A,\\ j)$, then paint $j$ cannot be chosen.\n\nIf there are multiple paints that satisfy the condition, Miying may choose any one of them. After each paint is used, Miying gains a happiness value equal to the $gcd$ of the indices of all paints used so far.\n\nNow Miying wants to draw a painting using $m$ kinds of paints. What is the maximum possible sum of happiness values she can obtain?", "inputFormat": "A single line with two positive integers $n,\\ m$, representing the number of kinds of paints and the number of paints Miying will use.", "outputFormat": "Output one positive integer, the maximum happiness value Miying can obtain.", "hint": "$1\\le m\\le n\\le 10^7$.\n\n# Constraints\n\n# Sample Explanation\n\nSample 1: `6 3 5 2` is an optimal solution. The happiness values obtained each time are `6 3 1 1`.\n\nSample 2: `15 10 5` is an optimal solution. The happiness values obtained each time are `15 5 5`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "美樱的颜料", "background": "在春辉去美国留学之后，美樱时常感到寂寞。为了排解寂寞，她在画画时总是对颜料有着特殊的要求。\n\n![](https://i.loli.net/2018/10/10/5bbd8d3178ee9.jpg)", "description": "美樱共有 $n$ 种不同的颜料，编号依次为 $1$ ~ $n$，每种颜料只能使用一次。开始画一幅画时，美樱可以任意选择一种颜料使用。之后，美樱每次都会选择一种颜料 $i$ 使用，满足使用颜料 $i$ 后已经使用了的颜料的编号的 $gcd$（最大公约数）尽量大，即：\n\n> 设现在已经使用了的颜料编号构成的集合为 $A$，若$\\ \\exists\\ i,\\ j\\notin A,\\ i,\\ j\\in [1,\\ n],\\ gcd(A,\\ i)>gcd(A,\\ j)$，那么就不能选择颜料 $j$。\n\n如果有多种满足条件的颜料，美樱可以任意选择一种使用。每使用完一种颜料，美樱就会获得当前使用了的所有颜料的编号的 $gcd$ 的快乐值。\n\n现在美樱想画一幅使用 $m$ 种颜料的画，她能够获得的最大快乐值之和是多少？", "inputFormat": "共一行，两个正整数 $n,\\ m$，分别代表颜料的种类数和美樱要使用的颜料数。", "outputFormat": "一个正整数，美樱能获得的最大快乐值。", "hint": "$1\\le m\\le n\\le 10^7$\n\n## 样例解释\n\n样例一：`6 3 5 2`为一组最优解，每次获得的快乐值分别为`6 3 1 1`\n\n样例二：`15 10 5`为一组最优解，每次获得的快乐值分别为`15 5 5`", "locale": "zh-CN"}}}
