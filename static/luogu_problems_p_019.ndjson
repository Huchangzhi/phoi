{"pid": "P5802", "type": "P", "difficulty": 4, "samples": [["5 3 3\n111\n010\n010\n010\n010\n111\n100\n110\n100\n100", "14\n0 0 0\n0 0 1\n0 0 2\n0 1 0\n0 1 1\n0 1 2\n0 2 0\n0 2 1\n0 2 2\n1 1 0\n2 1 0\n2 1 1\n3 1 0\n4 1 0\n8\n0 0 0\n0 1 1\n0 2 2\n1 1 0\n2 1 0\n2 1 1\n3 1 0\n4 1 0"], ["2 2 2\n00\n00\n11\n11", "-1"], ["2 3 2\n101\n011\n10\n11", "6\n0 0 0\n0 2 0\n1 1 0\n1 1 1\n1 2 0\n1 2 1\n4\n0 0 0\n0 2 0\n1 1 0\n1 2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "ICPC", "SEERC"], "title": "[SEERC 2019] Projection", "background": "", "description": "![TensorFlow](https://cdn.luogu.com.cn/upload/image_hosting/gdl3vztm.png)\n\n你是一个 TensorFlow 的死忠粉，因此，你想要从两个投影图形来还原出 TensorFlow 的图标。\n\n假定你有一个 3D 空间，尺寸为 $n \\times m \\times h$，以及两个投影图形（一个 $n \\times m$ 的矩阵和一个 $n \\times h$ 的矩阵，矩阵里的元素都为 $0$ 或 $1$）。你需要计算出一些 $1 \\times 1 \\times 1$ 的小正方体的集合，使得这些正方体放入 3D 空间后构成的立体的正投影（光照立体正面在立体后侧形成的投影）和右投影（光照立体左面在立体右侧形成的投影）与题目给定的投影图形一致。如果无解，输出 $-1$。如果有解，你需要计算出两个满足条件的集合，一个包含的小正方体数量最少，另一个最多。假定正方体的摆放不受重力影响（即小正方体在 3D 空间中可以随意放置，悬空也不需要支撑）。规定矩阵中的 $1$ 代表有阴影遮住，$0$ 代表无阴影遮住。\n\n如果有多解，你需要输出字典序最小的解。一个解 $a$ 字典序比解 $b$ 小，当且仅当对于两个解中第一对不相同的数字，$a$ 中的数字小于 $b$ 中的。\n\n例如，解 $[(0, 0, 0), (1, 1, 1)]$ 比解 $[(1, 1, 1), (0, 0, 0)]$ 字典序更小。", "inputFormat": "第一行包含三个整数 $n, m, h \\ (1 \\leq n,m,h \\leq 100)$，代表 3D 空间的尺寸。\n\n接下来的 $n$ 行中，每一行包含 $m$ 个字符 $0$ 或 $1$，其中 $1$ 代表有阴影遮住，$0$ 代表无阴影遮住。这 $n \\times m$ 个字符描述了一个正投影。\n\n接下来的 $n$ 行中，每一行包含 $h$ 个字符，格式同上。这 $n \\times h$ 个字符描述了一个右投影。", "outputFormat": "如果无解，仅在第一行输出 $-1$ 即可。\n\n如果有解，第一行输出一个整数 $k_{max}$，代表满足题目要求的解中小正方体个数的最大值。\n\n接下来 $k_{max}$ 行中每行输出三个整数 $x, y, z \\ (0 \\leq x < n, 0 \\leq y < m, 0 \\leq z < h)$，代表小正方体最多的解中字典序最小的解的 $k_{max}$ 个小正方体的放置位置。\n\n接下来一行输出一个整数 $k_{min}$，代表满足题目要求的解中小正方体个数的最小值。\n\n接下来 $k_{min}$ 行中每行输出三个整数 $x, y, z \\ (0 \\leq x < n, 0 \\leq y < m, 0 \\leq z < h)$，代表小正方体最少的解中字典序最小的解的 $k_{min}$ 个小正方体的放置位置。", "hint": "一个放置在 $(x, y, z)$ 的小正方体会在正投影的 $(x, y)$ 位置产生一个有阴影遮住的区域，并在右投影的 $(x, z)$ 位置产生一个有阴影遮住的区域。\n\n坐标从 $0$ 开始编号。", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2019] Projection", "background": "", "description": "![TensorFlow](https://cdn.luogu.com.cn/upload/image_hosting/gdl3vztm.png)\n\nYou are a hardcore fan of TensorFlow, so you want to reconstruct the TensorFlow logo from two projection images.\n\nSuppose you have a 3D space of size $n \\times m \\times h$, and two projection images (an $n \\times m$ matrix and an $n \\times h$ matrix, with each entry being $0$ or $1$). You need to find a set of $1 \\times 1 \\times 1$ unit cubes such that, after placing these cubes into the 3D space, the front orthographic projection (the projection formed on the back side of the solid when light shines on the front face) and the right projection (the projection formed on the right side of the solid when light shines on the left face) are consistent with the given projection images. If there is no solution, output $-1$. If there is a solution, you need to compute two valid sets: one with the minimum number of unit cubes, and one with the maximum number. Assume gravity does not matter (i.e., unit cubes can be placed anywhere in the 3D space; they can float without support). In the matrices, $1$ means the position is covered by shadow, and $0$ means it is not covered by shadow.\n\nIf there are multiple solutions, you need to output the lexicographically smallest one. A solution $a$ is lexicographically smaller than a solution $b$ if and only if, at the first position where they differ, the number in $a$ is smaller than the corresponding number in $b$.\n\nFor example, the solution $[(0, 0, 0), (1, 1, 1)]$ is lexicographically smaller than $[(1, 1, 1), (0, 0, 0)]$.", "inputFormat": "The first line contains three integers $n, m, h \\ (1 \\leq n,m,h \\leq 100)$, representing the size of the 3D space.\n\nIn the next $n$ lines, each line contains $m$ characters $0$ or $1$. Here, $1$ means covered by shadow, and $0$ means not covered. These $n \\times m$ characters describe the front projection.\n\nIn the next $n$ lines, each line contains $h$ characters in the same format. These $n \\times h$ characters describe the right projection.", "outputFormat": "If there is no solution, output $-1$ on the first line only.\n\nIf there is a solution, output an integer $k_{max}$ on the first line, representing the maximum number of unit cubes among all valid solutions.\n\nIn the next $k_{max}$ lines, output three integers $x, y, z \\ (0 \\leq x < n, 0 \\leq y < m, 0 \\leq z < h)$ per line, representing the positions of the $k_{max}$ unit cubes in the lexicographically smallest solution among those with the maximum number of cubes.\n\nThen output an integer $k_{min}$ on the next line, representing the minimum number of unit cubes among all valid solutions.\n\nIn the next $k_{min}$ lines, output three integers $x, y, z \\ (0 \\leq x < n, 0 \\leq y < m, 0 \\leq z < h)$ per line, representing the positions of the $k_{min}$ unit cubes in the lexicographically smallest solution among those with the minimum number of cubes.", "hint": "A unit cube placed at $(x, y, z)$ will create a shadowed area at position $(x, y)$ in the front projection, and at position $(x, z)$ in the right projection.\n\nCoordinates are numbered starting from $0$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2019] Projection", "background": "", "description": "![TensorFlow](https://cdn.luogu.com.cn/upload/image_hosting/gdl3vztm.png)\n\n你是一个 TensorFlow 的死忠粉，因此，你想要从两个投影图形来还原出 TensorFlow 的图标。\n\n假定你有一个 3D 空间，尺寸为 $n \\times m \\times h$，以及两个投影图形（一个 $n \\times m$ 的矩阵和一个 $n \\times h$ 的矩阵，矩阵里的元素都为 $0$ 或 $1$）。你需要计算出一些 $1 \\times 1 \\times 1$ 的小正方体的集合，使得这些正方体放入 3D 空间后构成的立体的正投影（光照立体正面在立体后侧形成的投影）和右投影（光照立体左面在立体右侧形成的投影）与题目给定的投影图形一致。如果无解，输出 $-1$。如果有解，你需要计算出两个满足条件的集合，一个包含的小正方体数量最少，另一个最多。假定正方体的摆放不受重力影响（即小正方体在 3D 空间中可以随意放置，悬空也不需要支撑）。规定矩阵中的 $1$ 代表有阴影遮住，$0$ 代表无阴影遮住。\n\n如果有多解，你需要输出字典序最小的解。一个解 $a$ 字典序比解 $b$ 小，当且仅当对于两个解中第一对不相同的数字，$a$ 中的数字小于 $b$ 中的。\n\n例如，解 $[(0, 0, 0), (1, 1, 1)]$ 比解 $[(1, 1, 1), (0, 0, 0)]$ 字典序更小。", "inputFormat": "第一行包含三个整数 $n, m, h \\ (1 \\leq n,m,h \\leq 100)$，代表 3D 空间的尺寸。\n\n接下来的 $n$ 行中，每一行包含 $m$ 个字符 $0$ 或 $1$，其中 $1$ 代表有阴影遮住，$0$ 代表无阴影遮住。这 $n \\times m$ 个字符描述了一个正投影。\n\n接下来的 $n$ 行中，每一行包含 $h$ 个字符，格式同上。这 $n \\times h$ 个字符描述了一个右投影。", "outputFormat": "如果无解，仅在第一行输出 $-1$ 即可。\n\n如果有解，第一行输出一个整数 $k_{max}$，代表满足题目要求的解中小正方体个数的最大值。\n\n接下来 $k_{max}$ 行中每行输出三个整数 $x, y, z \\ (0 \\leq x < n, 0 \\leq y < m, 0 \\leq z < h)$，代表小正方体最多的解中字典序最小的解的 $k_{max}$ 个小正方体的放置位置。\n\n接下来一行输出一个整数 $k_{min}$，代表满足题目要求的解中小正方体个数的最小值。\n\n接下来 $k_{min}$ 行中每行输出三个整数 $x, y, z \\ (0 \\leq x < n, 0 \\leq y < m, 0 \\leq z < h)$，代表小正方体最少的解中字典序最小的解的 $k_{min}$ 个小正方体的放置位置。", "hint": "一个放置在 $(x, y, z)$ 的小正方体会在正投影的 $(x, y)$ 位置产生一个有阴影遮住的区域，并在右投影的 $(x, z)$ 位置产生一个有阴影遮住的区域。\n\n坐标从 $0$ 开始编号。", "locale": "zh-CN"}}}
{"pid": "P5803", "type": "P", "difficulty": 6, "samples": [["3\n1 1 2 2", "2 3"], ["3\n2 2 2 2", "-1 -1"], ["6\n1 4 5 4 4 4 3 4 4 2", "-1 -1 -1 17 20"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "SEERC"], "title": "[SEERC 2019] Tree Permutations", "background": "", "description": "有一天，Cool 先生建了一棵 $n$ 个点的树（没有环的无向连通图），他给任一编号 $i > 1$ 的点规定了两个值：$p_i < i$ 代表点 $i$ 的父节点，与 $w_i$ 代表 $i$ 与 $p_i$ 之间的边的边权。点 $1$ 是树根，所以它没有父节点。\n\n你想知道 Cool 先生建的树长啥样，但是 Cool 先生拒绝告诉你，但他给了你一些提示：\n\n他把所有的 $p_i$ 和 $w_i$ 值写成一列，得到了长为 $2 \\cdot n - 2$ 的数列 $b$。\n\n$$ b=[p_2, w_2, p_3, w_3, \\dots, p_{n-1}, w_{n-1}, p_n, w_n] $$\n\n然后他将其随机打乱，得到了数列 $a$，并将 $a$ 告诉你。\n\n然而只知道数列 $a$ 是无法还原那棵树的，你决定解决一个更难的问题。\n\n定义一个树是 *$k$ 长*的，当且仅当点 $1$ 到点 $n$ 的路径上有恰好 $k$ 条边。\n\n定义一个树是 *$k$ 完美*的，当且仅当这棵树是 *$k$ 长*的且点 $1$ 到点 $n$ 的路径上的边的边权之和是所有 *$k$ 长*的树中最大的。\n\n你的任务是计算出每个 $k$ 值对应的 *$k$ 完美*的树中，点 $1$ 到点 $n$ 的路径上的边的边权之和。如果某个 $k$ 值不存在 *$k$ 完美*的树，则在该位置输出 $-1$。", "inputFormat": "第一行包含一个整数 $n \\ (2 \\leq n \\leq 10^5)$，代表树上的节点数。\n\n第二行包含 $2 \\cdot n -2$ 个整数 $a_1, a_2, \\dots, a_{2n-2} \\ (1 \\leq a_i \\leq n-1)$，代表数列 $a$ 中的数字。", "outputFormat": "输出一行，共 $n-1$ 个空格隔开的整数 $w_1, w_2, w_3, \\dots, w_{n-1}$，其中 $w_k$ 代表 *$k$ 完美*的树中点 $1$ 到点 $n$ 的路径上的边的边权之和。如果不存在 *$i$ 长*的树，则 $w_i=-1$。", "hint": "第一个样例中，*$1$ 完美*的树由数列 $[1, 2, 1, 2]$ 构成（即，$p_2=1, w_2=2, p_3=1, w_3=2$），*$2$ 完美*的树由数列 $[1, 2, 2, 1]$ 构成（即，$p_2=1, w_2=2, p_3=2, w_3=1$）。以下是这两棵树的图形（点 $1$ 到点 $n$ 的路径上的边都为粗线）。\n\n![样例1](https://cdn.luogu.com.cn/upload/image_hosting/lgpg0jne.png)\n\n第二个样例中，不存在能通过重排 $a$ 构造出的 *$k$ 完美*的树。\n\n第三个样例中，只有 *$4$ 完美*的和 *$5$ 完美*的树可以被构造出。它们分别由数列 $[1, 4, 2, 4, 3, 4, 4, 4, 4, 5]$ 和 $[1, 4,2, 4, 3, 4, 4, 4, 5, 4]$ 构成。以下是这两棵树的图形。\n\n![样例3](https://cdn.luogu.com.cn/upload/image_hosting/rz04b4ro.png)", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2019] Tree Permutations", "background": "", "description": "One day, Mr. Cool built a tree with $n$ vertices (a connected undirected graph with no cycles). For each vertex $i > 1$, he specified two values: $p_i < i$, which represents the parent of vertex $i$, and $w_i$, which represents the weight of the edge between $i$ and $p_i$. Vertex $1$ is the root of the tree, so it has no parent.\n\nYou want to know what the tree Mr. Cool built looks like, but Mr. Cool refuses to tell you. However, he gave you some hints:\n\nHe wrote all the values $p_i$ and $w_i$ into a single list, obtaining an array $b$ of length $2 \\cdot n - 2$.\n\n$$ b=[p_2, w_2, p_3, w_3, \\dots, p_{n-1}, w_{n-1}, p_n, w_n] $$\n\nThen he randomly shuffled it, obtaining an array $a$, and told you $a$.\n\nHowever, knowing only the array $a$ is not enough to restore the tree, so you decide to solve a harder problem.\n\nA tree is called *$k$-long* if and only if the path from vertex $1$ to vertex $n$ contains exactly $k$ edges.\n\nA tree is called *$k$-perfect* if and only if it is *$k$-long*, and among all *$k$-long* trees, the sum of edge weights on the path from vertex $1$ to vertex $n$ is the maximum possible.\n\nYour task is to compute, for each $k$, the sum of edge weights on the path from vertex $1$ to vertex $n$ in a *$k$-perfect* tree. If no *$k$-perfect* tree exists for some $k$, output $-1$ at that position.", "inputFormat": "The first line contains an integer $n \\ (2 \\leq n \\leq 10^5)$, representing the number of vertices in the tree.\n\nThe second line contains $2 \\cdot n -2$ integers $a_1, a_2, \\dots, a_{2n-2} \\ (1 \\leq a_i \\leq n-1)$, representing the elements of array $a$.", "outputFormat": "Output one line with $n-1$ space-separated integers $w_1, w_2, w_3, \\dots, w_{n-1}$, where $w_k$ is the sum of edge weights on the path from vertex $1$ to vertex $n$ in a *$k$-perfect* tree. If no *$i$-long* tree exists, then $w_i=-1$.", "hint": "In the first sample, the *$1$-perfect* tree is formed by the list $[1, 2, 1, 2]$ (i.e., $p_2=1, w_2=2, p_3=1, w_3=2$), and the *$2$-perfect* tree is formed by the list $[1, 2, 2, 1]$ (i.e., $p_2=1, w_2=2, p_3=2, w_3=1$). The figures of these two trees are shown below (the edges on the path from vertex $1$ to vertex $n$ are drawn in bold).\n\n![Sample 1](https://cdn.luogu.com.cn/upload/image_hosting/lgpg0jne.png)\n\nIn the second sample, there is no *$k$-perfect* tree that can be constructed by rearranging $a$.\n\nIn the third sample, only the *$4$-perfect* and *$5$-perfect* trees can be constructed. They are formed by the lists $[1, 4, 2, 4, 3, 4, 4, 4, 4, 5]$ and $[1, 4,2, 4, 3, 4, 4, 4, 5, 4]$, respectively. The figures of these two trees are shown below.\n\n![Sample 3](https://cdn.luogu.com.cn/upload/image_hosting/rz04b4ro.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2019] Tree Permutations", "background": "", "description": "有一天，Cool 先生建了一棵 $n$ 个点的树（没有环的无向连通图），他给任一编号 $i > 1$ 的点规定了两个值：$p_i < i$ 代表点 $i$ 的父节点，与 $w_i$ 代表 $i$ 与 $p_i$ 之间的边的边权。点 $1$ 是树根，所以它没有父节点。\n\n你想知道 Cool 先生建的树长啥样，但是 Cool 先生拒绝告诉你，但他给了你一些提示：\n\n他把所有的 $p_i$ 和 $w_i$ 值写成一列，得到了长为 $2 \\cdot n - 2$ 的数列 $b$。\n\n$$ b=[p_2, w_2, p_3, w_3, \\dots, p_{n-1}, w_{n-1}, p_n, w_n] $$\n\n然后他将其随机打乱，得到了数列 $a$，并将 $a$ 告诉你。\n\n然而只知道数列 $a$ 是无法还原那棵树的，你决定解决一个更难的问题。\n\n定义一个树是 *$k$ 长*的，当且仅当点 $1$ 到点 $n$ 的路径上有恰好 $k$ 条边。\n\n定义一个树是 *$k$ 完美*的，当且仅当这棵树是 *$k$ 长*的且点 $1$ 到点 $n$ 的路径上的边的边权之和是所有 *$k$ 长*的树中最大的。\n\n你的任务是计算出每个 $k$ 值对应的 *$k$ 完美*的树中，点 $1$ 到点 $n$ 的路径上的边的边权之和。如果某个 $k$ 值不存在 *$k$ 完美*的树，则在该位置输出 $-1$。", "inputFormat": "第一行包含一个整数 $n \\ (2 \\leq n \\leq 10^5)$，代表树上的节点数。\n\n第二行包含 $2 \\cdot n -2$ 个整数 $a_1, a_2, \\dots, a_{2n-2} \\ (1 \\leq a_i \\leq n-1)$，代表数列 $a$ 中的数字。", "outputFormat": "输出一行，共 $n-1$ 个空格隔开的整数 $w_1, w_2, w_3, \\dots, w_{n-1}$，其中 $w_k$ 代表 *$k$ 完美*的树中点 $1$ 到点 $n$ 的路径上的边的边权之和。如果不存在 *$i$ 长*的树，则 $w_i=-1$。", "hint": "第一个样例中，*$1$ 完美*的树由数列 $[1, 2, 1, 2]$ 构成（即，$p_2=1, w_2=2, p_3=1, w_3=2$），*$2$ 完美*的树由数列 $[1, 2, 2, 1]$ 构成（即，$p_2=1, w_2=2, p_3=2, w_3=1$）。以下是这两棵树的图形（点 $1$ 到点 $n$ 的路径上的边都为粗线）。\n\n![样例1](https://cdn.luogu.com.cn/upload/image_hosting/lgpg0jne.png)\n\n第二个样例中，不存在能通过重排 $a$ 构造出的 *$k$ 完美*的树。\n\n第三个样例中，只有 *$4$ 完美*的和 *$5$ 完美*的树可以被构造出。它们分别由数列 $[1, 4, 2, 4, 3, 4, 4, 4, 4, 5]$ 和 $[1, 4,2, 4, 3, 4, 4, 4, 5, 4]$ 构成。以下是这两棵树的图形。\n\n![样例3](https://cdn.luogu.com.cn/upload/image_hosting/rz04b4ro.png)", "locale": "zh-CN"}}}
{"pid": "P5804", "type": "P", "difficulty": 3, "samples": [["4\n2 14 7 14\n5 10 9 22", "4"], ["1\n14\n42", "28"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "SEERC"], "title": "[SEERC 2019] Absolute Game", "background": "", "description": "Alice 和 Bob 在玩一个游戏。Alice 有一个包含 $n$ 个整数的数列 $a$，Bob 有一个包含 $n$ 个整数的数列 $b$。每一回合中，玩家需要从他的数列中删去一个数字。玩家轮流进行回合，Alice 先手。\n\n当两个数列中都只剩下一个数字的时候，游戏结束。令 Alice 的数列剩下的数字为 $x$，Bob 的数列剩下的数字为 $y$。Alice 想要最大化 $x$ 与 $y$ 之差的绝对值，而 Bob 想最小化这个值。两个玩家都以最优策略游戏。\n\n请算出游戏结束时的结果。", "inputFormat": "第一行包含一个整数 $n \\ (1 \\leq n \\leq 1 \\ 000)$，代表每个数列中的数字个数。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n \\ (1 \\leq a_i \\leq 10^9)$，代表 Alice 的数列中的数字。\n\n第三行包含 $n$ 个整数 $b_1, b_2, \\dots, b_n \\ (1 \\leq b_i \\leq 10^9)$，代表 Bob 的数列中的数字。", "outputFormat": "输出当两个玩家都以最优策略游戏时，$x$ 与 $y$ 之差的绝对值。", "hint": "第一个样例中，$x=14, y=10$，因此两个数之差为 $4$。\n\n第二个样例中，两个数列都只剩下一个数字了，因此 $x=14, y=42$。", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2019] Absolute Game", "background": "", "description": "Alice and Bob are playing a game. Alice has a sequence $a$ containing $n$ integers, and Bob has a sequence $b$ containing $n$ integers. In each round, the player must delete one number from their own sequence. The players take turns, and Alice moves first.\n\nWhen both sequences have only one number left, the game ends. Let the remaining number in Alice’s sequence be $x$, and the remaining number in Bob’s sequence be $y$. Alice wants to maximize the absolute value of the difference between $x$ and $y$, while Bob wants to minimize this value. Both players play optimally.\n\nCompute the result when the game ends.", "inputFormat": "The first line contains an integer $n \\ (1 \\leq n \\leq 1 \\ 000)$, representing the number of integers in each sequence.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n \\ (1 \\leq a_i \\leq 10^9)$, representing the numbers in Alice’s sequence.\n\nThe third line contains $n$ integers $b_1, b_2, \\dots, b_n \\ (1 \\leq b_i \\leq 10^9)$, representing the numbers in Bob’s sequence.", "outputFormat": "Output the absolute value of the difference between $x$ and $y$ when both players play optimally.", "hint": "In the first sample, $x=14$ and $y=10$, so the difference between the two numbers is $4$.\n\nIn the second sample, both sequences already have only one number left, so $x=14$ and $y=42$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2019] Absolute Game", "background": "", "description": "Alice 和 Bob 在玩一个游戏。Alice 有一个包含 $n$ 个整数的数列 $a$，Bob 有一个包含 $n$ 个整数的数列 $b$。每一回合中，玩家需要从他的数列中删去一个数字。玩家轮流进行回合，Alice 先手。\n\n当两个数列中都只剩下一个数字的时候，游戏结束。令 Alice 的数列剩下的数字为 $x$，Bob 的数列剩下的数字为 $y$。Alice 想要最大化 $x$ 与 $y$ 之差的绝对值，而 Bob 想最小化这个值。两个玩家都以最优策略游戏。\n\n请算出游戏结束时的结果。", "inputFormat": "第一行包含一个整数 $n \\ (1 \\leq n \\leq 1 \\ 000)$，代表每个数列中的数字个数。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n \\ (1 \\leq a_i \\leq 10^9)$，代表 Alice 的数列中的数字。\n\n第三行包含 $n$ 个整数 $b_1, b_2, \\dots, b_n \\ (1 \\leq b_i \\leq 10^9)$，代表 Bob 的数列中的数字。", "outputFormat": "输出当两个玩家都以最优策略游戏时，$x$ 与 $y$ 之差的绝对值。", "hint": "第一个样例中，$x=14, y=10$，因此两个数之差为 $4$。\n\n第二个样例中，两个数列都只剩下一个数字了，因此 $x=14, y=42$。", "locale": "zh-CN"}}}
{"pid": "P5805", "type": "P", "difficulty": 3, "samples": [["3\n1 2 1\n2 3 1\n3 1 1", "3"], ["5\n4 5 4\n1 3 4\n1 2 4\n3 2 3\n3 5 2\n1 4 3\n4 2 2\n1 5 4\n5 2 4\n3 4 2", "35"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "SEERC"], "title": "[SEERC 2019] Graph and Cycles", "background": "", "description": "有一个 $n$ 个点的无向有边权的完全图，其中 $n$ 是奇数。\n\n定义一个大小为 $k$ 的*环边组*为一个边构成的数组 $[e_1, e_2, \\dots, e_k]$，且具有以下性质：\n\n- $k$ 大于 $1$。\n- 对于任意 $[1, k]$ 中的整数 $i$，边 $e_i$ 与 $e_{i-1}$ 和 $e_{i+1}$ 都恰好有一个相同的端点（规定 $e_0=e_k, e_{k+1}=e_1$）。\n\n显然一个环边组中的边构成了图上的一个环。\n\n定义一个参数为两条边 $e_1, e_2$ 的函数 $f(e_1, e_2)$，其函数值为两条边中边权的较大值。\n\n定义一个环边组 $C=[e_1, e_2, \\dots, e_k]$ 的*价值*为对于任意 $[1, k]$ 中的整数 $i$，$f(e_i, e_{i+1})$ 的值之和（规定 $e_{k+1}=e_1$）。\n\n定义一个图的*环分割*为一组无交集的环边组，且这些环边组的并包含了图上所有的边。定义一个图的环分割的*价值*为其中所有环边组的价值之和。\n\n一个图可能存在多组环分割。给定一个图，你的任务是找到价值最小的环分割并输出该最小价值。", "inputFormat": "第一行包含一个整数 $n \\ (3 \\leq n \\leq 999, n \\bmod 2 = 1)$，代表图的点数。\n\n接下来的 $\\frac{n\\cdot (n-1)}{2}$ 行每行包含三个整数 $u, v$ 和 $w \\ (1 \\leq u, v \\leq n, u \\neq v, 1 \\leq w \\leq 10^9)$，代表点 $u$ 和点 $v$ 间有一条边权为 $w$ 的边。", "outputFormat": "输出一个整数，代表给定图的最小价值环分割的价值。", "hint": "以下样例解释中，边以输入顺序编号，$e_i$ 代表输入顺序中的第 $i$ 条边。\n\n第一个样例中，唯一的环分割为 $S=\\{ [e_1, e_2, e_3] \\}$。$f(e_1, e_2)+f(e_2,e_3)+f(e_3,e_1)=1+1+1=3$。\n\n第二个样例中，最优的环分割为 $S=\\{ [e_3, e_8, e_9], [e_2,e_4,e_7,e_{10},e_5,e_1,e_6] \\}$。环边组 $[e_3,e_8,e_9]$ 的价值为 $12$，$[e_2,e_4,e_7,e_{10},e_5,e_1,e_6]$ 的价值为 $23$，因此环分割的价值为 $35$。", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2019] Graph and Cycles", "background": "", "description": "There is an undirected complete graph with $n$ vertices and edge weights, where $n$ is odd.\n\nA *cycle edge group* of size $k$ is an array of edges $[e_1, e_2, \\dots, e_k]$ that satisfies:\n\n- $k$ is greater than $1$.\n- For any integer $i$ in $[1, k]$, the edge $e_i$ shares exactly one common endpoint with each of $e_{i-1}$ and $e_{i+1}$ (where $e_0 = e_k$ and $e_{k+1} = e_1$).\n\nObviously, the edges in a cycle edge group form a cycle in the graph.\n\nDefine a function $f(e_1, e_2)$ for two edges $e_1, e_2$ as the larger of their edge weights.\n\nDefine the *value* of a cycle edge group $C = [e_1, e_2, \\dots, e_k]$ as the sum of $f(e_i, e_{i+1})$ over all integers $i$ in $[1, k]$ (where $e_{k+1} = e_1$).\n\nDefine a *cycle decomposition* of a graph as a set of pairwise disjoint cycle edge groups whose union contains all edges of the graph. Define the *value* of a cycle decomposition as the sum of the values of all cycle edge groups in it.\n\nA graph may have multiple cycle decompositions. Given a graph, your task is to find the cycle decomposition with the minimum value and output this minimum value.", "inputFormat": "The first line contains an integer $n \\ (3 \\leq n \\leq 999, n \\bmod 2 = 1)$, representing the number of vertices in the graph.\n\nThe next $\\frac{n\\cdot (n-1)}{2}$ lines each contain three integers $u, v$ and $w \\ (1 \\leq u, v \\leq n, u \\neq v, 1 \\leq w \\leq 10^9)$, indicating that there is an edge of weight $w$ between vertex $u$ and vertex $v$.", "outputFormat": "Output one integer, representing the value of the minimum-value cycle decomposition of the given graph.", "hint": "In the following sample explanations, edges are numbered in input order, and $e_i$ denotes the $i$-th edge in the input order.\n\nIn the first sample, the only cycle decomposition is $S = \\{ [e_1, e_2, e_3] \\}$. $f(e_1, e_2) + f(e_2, e_3) + f(e_3, e_1) = 1 + 1 + 1 = 3$.\n\nIn the second sample, an optimal cycle decomposition is $S = \\{ [e_3, e_8, e_9], [e_2, e_4, e_7, e_{10}, e_5, e_1, e_6] \\}$. The value of the cycle edge group $[e_3, e_8, e_9]$ is $12$, and the value of $[e_2, e_4, e_7, e_{10}, e_5, e_1, e_6]$ is $23$, so the value of the cycle decomposition is $35$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2019] Graph and Cycles", "background": "", "description": "有一个 $n$ 个点的无向有边权的完全图，其中 $n$ 是奇数。\n\n定义一个大小为 $k$ 的*环边组*为一个边构成的数组 $[e_1, e_2, \\dots, e_k]$，且具有以下性质：\n\n- $k$ 大于 $1$。\n- 对于任意 $[1, k]$ 中的整数 $i$，边 $e_i$ 与 $e_{i-1}$ 和 $e_{i+1}$ 都恰好有一个相同的端点（规定 $e_0=e_k, e_{k+1}=e_1$）。\n\n显然一个环边组中的边构成了图上的一个环。\n\n定义一个参数为两条边 $e_1, e_2$ 的函数 $f(e_1, e_2)$，其函数值为两条边中边权的较大值。\n\n定义一个环边组 $C=[e_1, e_2, \\dots, e_k]$ 的*价值*为对于任意 $[1, k]$ 中的整数 $i$，$f(e_i, e_{i+1})$ 的值之和（规定 $e_{k+1}=e_1$）。\n\n定义一个图的*环分割*为一组无交集的环边组，且这些环边组的并包含了图上所有的边。定义一个图的环分割的*价值*为其中所有环边组的价值之和。\n\n一个图可能存在多组环分割。给定一个图，你的任务是找到价值最小的环分割并输出该最小价值。", "inputFormat": "第一行包含一个整数 $n \\ (3 \\leq n \\leq 999, n \\bmod 2 = 1)$，代表图的点数。\n\n接下来的 $\\frac{n\\cdot (n-1)}{2}$ 行每行包含三个整数 $u, v$ 和 $w \\ (1 \\leq u, v \\leq n, u \\neq v, 1 \\leq w \\leq 10^9)$，代表点 $u$ 和点 $v$ 间有一条边权为 $w$ 的边。", "outputFormat": "输出一个整数，代表给定图的最小价值环分割的价值。", "hint": "以下样例解释中，边以输入顺序编号，$e_i$ 代表输入顺序中的第 $i$ 条边。\n\n第一个样例中，唯一的环分割为 $S=\\{ [e_1, e_2, e_3] \\}$。$f(e_1, e_2)+f(e_2,e_3)+f(e_3,e_1)=1+1+1=3$。\n\n第二个样例中，最优的环分割为 $S=\\{ [e_3, e_8, e_9], [e_2,e_4,e_7,e_{10},e_5,e_1,e_6] \\}$。环边组 $[e_3,e_8,e_9]$ 的价值为 $12$，$[e_2,e_4,e_7,e_{10},e_5,e_1,e_6]$ 的价值为 $23$，因此环分割的价值为 $35$。", "locale": "zh-CN"}}}
{"pid": "P5806", "type": "P", "difficulty": 6, "samples": [["2 5 1\nR-\n*-\n*-\n*T\n**", "1"], ["3 2 1\nR-T\n***", "2"], ["3 3 1\n-R-\n-*-\n-T-", "-1"], ["5 4 2\n-R---\n-****\n-****\n-****\n-----\n-----\n*T---\n----*", "5"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 10000, 10000, 10000, 10000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "O2优化", "广度优先搜索 BFS", "ICPC", "SEERC"], "title": "[SEERC 2019] Stranded Robot", "background": "", "description": "在废弃宇宙飞船的残骸中，有一个机器人。残骸的某处有一个传送机，可以将这个可怜的机器人送至安全的地方。\n\n宇宙飞船不受控制地在各个方向上翻滚。一个邻近的恒星发出的光可以照到残骸上。飞船配备了人工重力发生器。人工重力总是向远离恒星的方向拉机器人，无论飞船的方向如何。\n\n机器人配备了太阳能电池板，必须依赖太阳能才能在残骸上移动。当残骸的一部分挡住了光照，机器人就无法移动了。然而，机器人总是会在移动后将自己固定住，以免被晃走或者掉入宇宙中。\n\n残骸和残骸周围的区域可以用一个大小为 $m \\times n \\times p$ 的三维坐标空间表示。每个空间中的小方格都可能是残骸的一部分或真空。飞船残骸可能不是连在一起的。\n\n机器人最开始固定在飞船的某一块上。机器人可以决定什么时候移动或什么时候等光照从合适的方向照过来。\n\n形式化地说，重力可以在六个方向上作用于机器人，包括三个坐标轴上各两个方向。当一个格子在重力的反方向上没有残骸遮挡时，这个格子就有光照。当进行移动时，起点和终点都必须同时有光照。\n\n以下是可用的移动方式：（光照从图片所示空间的上方照下；蓝色格子代表机器人；橙色格子代表可能的移动终点）\n\n1. **在平地移动**\n   假如机器人固定在某一块上，它可以移动到相邻的块上，这些块必须与起点同高。\n   机器人无法斜向移动。终点必须也有光照。\n   ![移动1](https://cdn.luogu.com.cn/upload/image_hosting/sf5pxkhr.png)\n2. **从高处跳下**\n   机器人可以从高处走出一步，然后落下。落下的高度没有限制。\n   机器人不能落入宇宙中，也不能落到没有光照的地方。\n   ![移动2](https://cdn.luogu.com.cn/upload/image_hosting/8jwv3v8y.png)\n3. **掉落**\n   假如机器人有光照且悬在空中，它可以掉落下来。这种情况可能会在重力的方向改变后产生。\n   机器人不能掉入宇宙中。\n   ![移动3](https://cdn.luogu.com.cn/upload/image_hosting/8ei3yfks.png)\n\n机器人的目标是到达传送机的所在地，如果有多种走法，则使用移动次数最少的走法。传送机工作要求机器人必须固定在飞船上。换句话说，机器人必须在某一次移动之后到达传送机的位置上，但掉落时经过它是无法工作的。传送机不会遮住光照或阻挡机器人的移动。", "inputFormat": "第一行包含三个整数 $m, n, p \\ (1 \\leq m, n, p \\leq 500)$。\n\n飞船和飞船周围的空间被描述为 $p$ 块。\n\n第 $k$ 块描述了高度为 $k$ 的格子。每块都包含 $n$ 行。\n\n第 $k$ 块的第 $i$ 行包含 $m$ 个字符，描述该格子的情况。令 $a_{ijk}$ 代表第 $j$ 个字符。\n\n- 如果 $a_{ijk}$ 是 `*`，则这个格子是残骸。\n- 如果 $a_{ijk}$ 是 `-`，则这个格子是真空。\n- 如果 $a_{ijk}$ 是 `R`，则这个格子是机器人。数据保证只有一个格子是机器人，且机器人被固定在一个残骸格子上。\n- 如果 $a_{ijk}$ 是 `T`，则这个格子是传送机。数据保证只有一个格子是传送机。", "outputFormat": "输出到达传送机处所需的最少移动数。如果无解，输出 $-1$。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2019] Stranded Robot", "background": "", "description": "In the wreckage of an abandoned spaceship, there is a robot. Somewhere in the wreckage there is a teleporter that can send this poor robot to a safe place.\n\nThe spaceship is uncontrollably tumbling in all directions. Light from a nearby star can shine onto the wreckage. The spaceship is equipped with an artificial gravity generator. Artificial gravity always pulls the robot in the direction away from the star, no matter how the ship is oriented.\n\nThe robot is equipped with solar panels and must rely on sunlight to move on the wreckage. When some part of the wreckage blocks the light, the robot cannot move. However, after moving, the robot always anchors itself so that it will not be shaken away or fall into space.\n\nThe wreckage and the area around it can be represented as a three-dimensional coordinate space of size $m \\times n \\times p$. Each small cell in the space may be part of the wreckage or vacuum. The spaceship wreckage may be disconnected.\n\nThe robot starts anchored on some piece of the ship. The robot can decide when to move or when to wait for light to shine from a suitable direction.\n\nFormally, gravity can act on the robot in six directions: two directions along each of the three coordinate axes. A cell is lit if there is no wreckage blocking it in the direction opposite to gravity. When making a move, both the starting cell and the destination cell must be lit at the same time.\n\nThe following moves are available (the light in the figures shines from above; the blue cell is the robot; orange cells are possible destinations):\n\n1. **Moving on flat ground**  \n   If the robot is anchored on a block, it can move to a neighboring block at the same height as the starting cell.  \n   The robot cannot move diagonally. The destination must also be lit.  \n   ![Move 1](https://cdn.luogu.com.cn/upload/image_hosting/sf5pxkhr.png)\n\n2. **Stepping off from a height**  \n   The robot can step out by one cell from a higher place and then fall down. There is no limit on the falling height.  \n   The robot must not fall into space, and it must not land on an unlit cell.  \n   ![Move 2](https://cdn.luogu.com.cn/upload/image_hosting/8jwv3v8y.png)\n\n3. **Falling**  \n   If the robot is lit and hanging in the air, it can fall down. This may happen after the direction of gravity changes.  \n   The robot must not fall into space.  \n   ![Move 3](https://cdn.luogu.com.cn/upload/image_hosting/8ei3yfks.png)\n\nThe robot’s goal is to reach the teleporter. If there are multiple ways, it should use the one with the fewest moves. The teleporter requires the robot to be anchored on the ship in order to work. In other words, the robot must arrive at the teleporter’s cell as the result of some move; merely passing through it while falling does not activate it. The teleporter does not block light and does not obstruct the robot’s movement.", "inputFormat": "The first line contains three integers $m, n, p \\ (1 \\leq m, n, p \\leq 500)$.\n\nThe spaceship and the surrounding space are described by $p$ layers.\n\nLayer $k$ describes the cells at height $k$. Each layer contains $n$ rows.\n\nIn layer $k$, row $i$ contains $m$ characters describing the cells. Let $a_{ijk}$ denote the $j$-th character.\n\n- If $a_{ijk}$ is `*`, the cell is wreckage.\n- If $a_{ijk}$ is `-`, the cell is vacuum.\n- If $a_{ijk}$ is `R`, the cell contains the robot. The testdata guarantees there is exactly one robot cell, and the robot is anchored on a wreckage cell.\n- If $a_{ijk}$ is `T`, the cell contains the teleporter. The testdata guarantees there is exactly one teleporter cell.", "outputFormat": "Output the minimum number of moves required to reach the teleporter. If it is impossible, output $-1$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2019] Stranded Robot", "background": "", "description": "在废弃宇宙飞船的残骸中，有一个机器人。残骸的某处有一个传送机，可以将这个可怜的机器人送至安全的地方。\n\n宇宙飞船不受控制地在各个方向上翻滚。一个邻近的恒星发出的光可以照到残骸上。飞船配备了人工重力发生器。人工重力总是向远离恒星的方向拉机器人，无论飞船的方向如何。\n\n机器人配备了太阳能电池板，必须依赖太阳能才能在残骸上移动。当残骸的一部分挡住了光照，机器人就无法移动了。然而，机器人总是会在移动后将自己固定住，以免被晃走或者掉入宇宙中。\n\n残骸和残骸周围的区域可以用一个大小为 $m \\times n \\times p$ 的三维坐标空间表示。每个空间中的小方格都可能是残骸的一部分或真空。飞船残骸可能不是连在一起的。\n\n机器人最开始固定在飞船的某一块上。机器人可以决定什么时候移动或什么时候等光照从合适的方向照过来。\n\n形式化地说，重力可以在六个方向上作用于机器人，包括三个坐标轴上各两个方向。当一个格子在重力的反方向上没有残骸遮挡时，这个格子就有光照。当进行移动时，起点和终点都必须同时有光照。\n\n以下是可用的移动方式：（光照从图片所示空间的上方照下；蓝色格子代表机器人；橙色格子代表可能的移动终点）\n\n1. **在平地移动**\n   假如机器人固定在某一块上，它可以移动到相邻的块上，这些块必须与起点同高。\n   机器人无法斜向移动。终点必须也有光照。\n   ![移动1](https://cdn.luogu.com.cn/upload/image_hosting/sf5pxkhr.png)\n2. **从高处跳下**\n   机器人可以从高处走出一步，然后落下。落下的高度没有限制。\n   机器人不能落入宇宙中，也不能落到没有光照的地方。\n   ![移动2](https://cdn.luogu.com.cn/upload/image_hosting/8jwv3v8y.png)\n3. **掉落**\n   假如机器人有光照且悬在空中，它可以掉落下来。这种情况可能会在重力的方向改变后产生。\n   机器人不能掉入宇宙中。\n   ![移动3](https://cdn.luogu.com.cn/upload/image_hosting/8ei3yfks.png)\n\n机器人的目标是到达传送机的所在地，如果有多种走法，则使用移动次数最少的走法。传送机工作要求机器人必须固定在飞船上。换句话说，机器人必须在某一次移动之后到达传送机的位置上，但掉落时经过它是无法工作的。传送机不会遮住光照或阻挡机器人的移动。", "inputFormat": "第一行包含三个整数 $m, n, p \\ (1 \\leq m, n, p \\leq 500)$。\n\n飞船和飞船周围的空间被描述为 $p$ 块。\n\n第 $k$ 块描述了高度为 $k$ 的格子。每块都包含 $n$ 行。\n\n第 $k$ 块的第 $i$ 行包含 $m$ 个字符，描述该格子的情况。令 $a_{ijk}$ 代表第 $j$ 个字符。\n\n- 如果 $a_{ijk}$ 是 `*`，则这个格子是残骸。\n- 如果 $a_{ijk}$ 是 `-`，则这个格子是真空。\n- 如果 $a_{ijk}$ 是 `R`，则这个格子是机器人。数据保证只有一个格子是机器人，且机器人被固定在一个残骸格子上。\n- 如果 $a_{ijk}$ 是 `T`，则这个格子是传送机。数据保证只有一个格子是传送机。", "outputFormat": "输出到达传送机处所需的最少移动数。如果无解，输出 $-1$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5807", "type": "P", "difficulty": 6, "samples": [["2\n1\n0\n2\n1 1\n1 2\n", "1\n0\n"], ["5\n3\n1 2\n1 3\n1 2\n3\n1 2\n1 1\n0\n3\n1 2\n1 1\n1 3\n3\n1 2\n1 3\n1 1\n3\n0\n0\n0", "0\n1\n0\n1\n1\n"], ["4\n6\n1 4 \n1 4 \n1 2 \n2 5 5 \n2 3 1 \n0 \n7\n2 6 5 \n3 3 6 1 \n4 4 2 4 5 \n3 3 7 2 \n4 6 3 1 6 \n4 4 2 5 5 \n1 3 \n10\n7 8 9 2 6 7 9 6 \n5 6 10 5 1 3 \n5 5 7 7 9 6 \n4 5 7 9 7 \n4 1 2 7 9 \n6 4 10 8 1 10 3 \n8 2 3 4 10 5 1 3 8 \n7 7 10 6 1 2 3 7 \n8 8 8 10 2 4 4 6 1 \n6 9 8 1 8 9 9 \n15\n11 10 10 10 11 2 13 10 8 14 9 14 \n9 5 3 10 1 15 11 8 13 11 \n7 1 15 13 7 15 8 5 \n7 8 14 7 1 2 3 8 \n3 11 4 10 \n7 7 12 7 4 12 11 12 \n10 10 12 3 13 15 1 2 8 11 12 \n12 9 4 13 10 2 6 13 10 7 6 7 11 \n6 4 1 2 8 12 1 \n15 1 11 9 9 7 7 6 6 2 8 12 2 8 12 2 \n10 12 10 6 10 3 1 6 3 9 4 \n12 15 14 10 14 14 9 8 7 7 11 13 4 \n7 12 3 10 6 1 1 4 \n6 12 5 8 3 8 12 \n5 10 10 1 11 2 \n", "2\n190080\n120594\n887148\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模板题"], "title": "【模板】BEST 定理 / Which Dreamed It", "background": "请注意本题与真正的 BEST 定理略有出入：BEST 定理没有从 $1$ 出发的限制，且回路的边序列是循环同构的。", "description": "有 $n$ 个房间，每个房间有若干把钥匙能够打开特定房间的门。\n\n最初你在房间 $1$。每当你到达一个房间，你可以选择该房间的一把钥匙，前往该钥匙对应的房间，并将该钥匙丢到垃圾桶中。\n\n你希望最终回到房间 $1$，且垃圾桶中有所有的钥匙。\n\n你需要求出方案数，答案对 $10^6 + 3$ 取模。两组方案不同，当且仅当使用钥匙的顺序不同。\n\n注意，每把钥匙都是不同的。\n\n原 BZOJ3659。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行一个整数 $n$。\n\n接下来 $n$ 行，第 $i$ 行描述房间 $i$：\n\n首先一个数 $s$，表示这个房间的钥匙数目，接下来 $s$ 个数，分别描述每把钥匙能够打开的房间的门。", "outputFormat": "对于每组数据，一行一个整数，表示答案对 $10^6+3$ 取模后的值。", "hint": "### 样例解释\n\n* 样例 $1$ 说明\n\n在第一组样例中，没有钥匙，则方案数为 $1$。\n\n在第二组样例中，你不可能使用第二个房间的钥匙，所以方案数为 $0$。\n\n* 样例 $2$ 说明\n\n只要使用完所有的钥匙即可，不一定要经过所有的房间。\n\n* 样例 $3$ 说明\n\n前三组数据在取模前的答案分别是 $2,190080,49476320425715737559040000000$。\n\n### 数据范围\n\n对于 $50\\%$ 的数据，$n \\le 4$，$\\sum s \\le 30$。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 15$，$1 \\le n \\le 100$，$0 \\le \\sum s \\le 3141592$。\n\n2021/5/14 加强 by [SSerxhs](https://www.luogu.com.cn/user/29826)&[滑大稽](https://www.luogu.com.cn/user/203743)", "locale": "zh-CN", "translations": {"en": {"title": "[Template] BEST Theorem / Which Dreamed It", "background": "Please note that this problem is slightly different from the real BEST Theorem: the BEST Theorem does not require starting from $1$, and the edge sequence of the circuit is considered up to cyclic isomorphism.", "description": "There are $n$ rooms, and each room has several keys that can open the door to a specific room.\n\nAt the beginning, you are in room $1$. Each time you arrive at a room, you may choose one key in that room, go to the room corresponding to that key, and throw that key into the trash bin.\n\nYou want to finally return to room $1$, and have all the keys in the trash bin.\n\nYou need to count the number of valid plans, modulo $10^6 + 3$. Two plans are different if and only if the order of using keys is different.\n\nNote that every key is distinct.\n\nOriginally BZOJ3659.", "inputFormat": "**This problem contains multiple test cases.**\n\nThe first line contains an integer $T$, the number of test cases.\n\nFor each test case:\n\nThe first line contains an integer $n$.\n\nThe next $n$ lines describe the rooms. Line $i$ describes room $i$:\n\nFirst a number $s$, the number of keys in this room, followed by $s$ numbers, each describing which room’s door that key can open.", "outputFormat": "For each test case, output one integer per line, the answer modulo $10^6 + 3$.", "hint": "### Sample Explanation\n\n* Sample $1$\n\nIn the first test case, there are no keys, so the number of plans is $1$.\n\nIn the second test case, you cannot use the key in the second room, so the number of plans is $0$.\n\n* Sample $2$\n\nIt is enough to use up all the keys; you do not necessarily need to visit all rooms.\n\n* Sample $3$\n\nBefore taking modulo, the answers for the first three test cases are $2,190080,49476320425715737559040000000$, respectively.\n\n### Constraints\n\nFor $50\\%$ of the testdata, $n \\le 4$, $\\sum s \\le 30$.\n\nFor $100\\%$ of the testdata, $1 \\le T \\le 15$, $1 \\le n \\le 100$, $0 \\le \\sum s \\le 3141592$.\n\nStrengthened on 2021/5/14 by [SSerxhs](https://www.luogu.com.cn/user/29826) & [滑大稽](https://www.luogu.com.cn/user/203743).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】BEST 定理 / Which Dreamed It", "background": "请注意本题与真正的 BEST 定理略有出入：BEST 定理没有从 $1$ 出发的限制，且回路的边序列是循环同构的。", "description": "有 $n$ 个房间，每个房间有若干把钥匙能够打开特定房间的门。\n\n最初你在房间 $1$。每当你到达一个房间，你可以选择该房间的一把钥匙，前往该钥匙对应的房间，并将该钥匙丢到垃圾桶中。\n\n你希望最终回到房间 $1$，且垃圾桶中有所有的钥匙。\n\n你需要求出方案数，答案对 $10^6 + 3$ 取模。两组方案不同，当且仅当使用钥匙的顺序不同。\n\n注意，每把钥匙都是不同的。\n\n原 BZOJ3659。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行一个整数 $n$。\n\n接下来 $n$ 行，第 $i$ 行描述房间 $i$：\n\n首先一个数 $s$，表示这个房间的钥匙数目，接下来 $s$ 个数，分别描述每把钥匙能够打开的房间的门。", "outputFormat": "对于每组数据，一行一个整数，表示答案对 $10^6+3$ 取模后的值。", "hint": "### 样例解释\n\n* 样例 $1$ 说明\n\n在第一组样例中，没有钥匙，则方案数为 $1$。\n\n在第二组样例中，你不可能使用第二个房间的钥匙，所以方案数为 $0$。\n\n* 样例 $2$ 说明\n\n只要使用完所有的钥匙即可，不一定要经过所有的房间。\n\n* 样例 $3$ 说明\n\n前三组数据在取模前的答案分别是 $2,190080,49476320425715737559040000000$。\n\n### 数据范围\n\n对于 $50\\%$ 的数据，$n \\le 4$，$\\sum s \\le 30$。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 15$，$1 \\le n \\le 100$，$0 \\le \\sum s \\le 3141592$。\n\n2021/5/14 加强 by [SSerxhs](https://www.luogu.com.cn/user/29826)&[滑大稽](https://www.luogu.com.cn/user/203743)", "locale": "zh-CN"}}}
{"pid": "P5808", "type": "P", "difficulty": 7, "samples": [["40 5 6\n1 2 3 5 8 13\n1 3 4 9 6 7\n1 1 4 5 1 4", "349344375"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "递推", "O2优化", "快速傅里叶变换 FFT", "快速数论变换 NTT", "模板题"], "title": "【模板】常系数非齐次线性递推", "background": "NaCly\\_Fish 一到机房，所有做题的人便都看着她笑。有的叫道，“鱼鱼，你怎么又爆零了！”她不回答，对教练说：“要两道数学题，一道数据结构。”便打开电脑。他们又故意的高声嚷道，“你怎么连 exgcd 都写不对了！”......\n\nNaCly\\_Fish 自己知道不能和同机房的神仙们谈天，便只好向隔壁初一的说话。有一回对我说道，“你学过 OI 么？”我略略点一点头。他说，“学过 OI，...... 我便考你一考。常系数线性齐次递推，怎样算的？”我想，机房垫底 AFO 的人，也配考我么？便回过脸去，不再理会。NaCly\\_Fish 等了许久，很恳切的说道，“不会算罢？…… 我教给你，记着！这算法应该好好记着，将来比赛的时候，做题要用。”我懒懒的答她道，“谁要你教，不是把递推系数写在矩阵第一列，剩下斜着放 $1$，再快速幂么？”NaCly\\_Fish 显出极高兴的样子，将两个指头的长指甲敲着课桌，点头说，“对呀对呀！...... 这还有四样求法，你知道么？”......\n****  \nNaCly\\_Fish 看见了这题，她根本不会做。  \n看在她那么菜的份上，请您做了这题，帮帮她吧。", "description": "已知递推式：  \n\n$$a_n = P(n) + \\sum\\limits_{i=1}^k f_i \\times a_{n-i}$$  \n\n其中 $P(x)$ 是一个 $m$ 次多项式。\n\n给定 $f_1,f_2,\\dots,f_k$，$a_0,a_1,\\dots,a_{k-1}$，和 $P(x)$ 的各项系数，求 $a_n$。  \n答案对 $998244353$ 取模。", "inputFormat": "第一行三个正整数 $n,m,k$。  \n第二行 $k$ 个整数，表示 $a_0,a_1,\\dots,a_{k-1}$。  \n第三行 $k$ 个整数，表示 $f_1,f_2,\\dots,f_k$。  \n第四行 $m+1$ 个整数，由低到高的表示 $P(x)$ 的系数。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 10^9$，$1\\le m,k \\le 30000$。    \n除第一行外，输入的所有数在 $[0,998244353)$ 范围内。  \n\n数据有一定梯度。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Non-homogeneous Linear Recurrence with Constant Coefficients", "background": "As soon as NaCly_Fish arrived in the computer lab, everyone who was solving problems looked at her and laughed. Some shouted, “Fishy, why did you get zero points again!” She did not answer, and said to the coach: “Two math problems, and one data structure problem.” Then she turned on the computer. They deliberately shouted louder, “How can you even write exgcd wrong!”......\n\nNaCly_Fish knew she could not chat with the geniuses in the same lab, so she had to talk to the first-year middle school students next door. Once she asked me, “Have you learned OI?” I nodded slightly. She said, “If you have learned OI, ...... then I will test you. For a homogeneous linear recurrence with constant coefficients, how do you compute it?” I thought, someone who is AFO and last in the lab, how dare she test me? So I turned my head away and ignored her. NaCly_Fish waited for a long time and said sincerely, “You can’t do it, right? ... I will teach you, remember this! You should memorize this algorithm well. You will need it when solving problems in future contests.” I lazily replied, “Who needs you to teach me? Isn’t it just writing the recurrence coefficients in the first column of a matrix, putting the remaining $1$’s along the diagonal, and then doing fast exponentiation?” NaCly_Fish looked very happy, tapped the desk with her two long fingernails, nodded, and said, “Yes, yes! ...... There are four more methods as well, do you know them?”......\n****  \nAfter NaCly_Fish saw this problem, she could not solve it at all.  \nSince she is so bad at it, please solve this problem and help her.", "description": "Given the recurrence:\n\n$$a_n = P(n) + \\sum\\limits_{i=1}^k f_i \\times a_{n-i}$$\n\nwhere $P(x)$ is a polynomial of degree $m$.\n\nGiven $f_1,f_2,\\dots,f_k$, $a_0,a_1,\\dots,a_{k-1}$, and the coefficients of $P(x)$, find $a_n$.  \nOutput the answer modulo $998244353$.", "inputFormat": "The first line contains three positive integers $n,m,k$.  \nThe second line contains $k$ integers, representing $a_0,a_1,\\dots,a_{k-1}$.  \nThe third line contains $k$ integers, representing $f_1,f_2,\\dots,f_k$.  \nThe fourth line contains $m+1$ integers, from low degree to high degree, representing the coefficients of $P(x)$.", "outputFormat": "Output one line with one integer, representing the answer.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1\\le n \\le 10^9$, $1\\le m,k \\le 30000$.  \nExcept for the first line, all input numbers are in the range $[0,998244353)$.  \n\nThe testdata has multiple difficulty levels.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】常系数非齐次线性递推", "background": "NaCly\\_Fish 一到机房，所有做题的人便都看着她笑。有的叫道，“鱼鱼，你怎么又爆零了！”她不回答，对教练说：“要两道数学题，一道数据结构。”便打开电脑。他们又故意的高声嚷道，“你怎么连 exgcd 都写不对了！”......\n\nNaCly\\_Fish 自己知道不能和同机房的神仙们谈天，便只好向隔壁初一的说话。有一回对我说道，“你学过 OI 么？”我略略点一点头。他说，“学过 OI，...... 我便考你一考。常系数线性齐次递推，怎样算的？”我想，机房垫底 AFO 的人，也配考我么？便回过脸去，不再理会。NaCly\\_Fish 等了许久，很恳切的说道，“不会算罢？…… 我教给你，记着！这算法应该好好记着，将来比赛的时候，做题要用。”我懒懒的答她道，“谁要你教，不是把递推系数写在矩阵第一列，剩下斜着放 $1$，再快速幂么？”NaCly\\_Fish 显出极高兴的样子，将两个指头的长指甲敲着课桌，点头说，“对呀对呀！...... 这还有四样求法，你知道么？”......\n****  \nNaCly\\_Fish 看见了这题，她根本不会做。  \n看在她那么菜的份上，请您做了这题，帮帮她吧。", "description": "已知递推式：  \n\n$$a_n = P(n) + \\sum\\limits_{i=1}^k f_i \\times a_{n-i}$$  \n\n其中 $P(x)$ 是一个 $m$ 次多项式。\n\n给定 $f_1,f_2,\\dots,f_k$，$a_0,a_1,\\dots,a_{k-1}$，和 $P(x)$ 的各项系数，求 $a_n$。  \n答案对 $998244353$ 取模。", "inputFormat": "第一行三个正整数 $n,m,k$。  \n第二行 $k$ 个整数，表示 $a_0,a_1,\\dots,a_{k-1}$。  \n第三行 $k$ 个整数，表示 $f_1,f_2,\\dots,f_k$。  \n第四行 $m+1$ 个整数，由低到高的表示 $P(x)$ 的系数。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 10^9$，$1\\le m,k \\le 30000$。    \n除第一行外，输入的所有数在 $[0,998244353)$ 范围内。  \n\n数据有一定梯度。", "locale": "zh-CN"}}}
{"pid": "P5809", "type": "P", "difficulty": 7, "samples": [["6\n0 1 2 2 4 3\n", "0 1 998244351 6 998244329 113\n"], ["7\n0 1 1 4 5 1 4\n", "0 1 998244352 998244351 10 7 998244202\n"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "O2优化", "快速傅里叶变换 FFT", "快速数论变换 NTT", "模板题"], "title": "【模板】多项式复合逆", "background": "神鱼姐姐太鸽了 qwq", "description": "令 $n-1$ 次多项式 $F(x)=\\sum\\limits _{i=0}^{n-1} a_ix^i$。\n\n给定 $n$ 和 $F(x)$ 的各项系数，要求一个 $n-1$ 次多项式 $G(x)$ 满足：\n\n$$\nG(F(x))\\equiv x\\pmod{x^n}\n$$\n\n求 $G(x)$ 的各项系数对 $998244353$ 取模的结果。\n\n保证 $a_0=0$，$a_1\\neq 0$。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个非负整数 $a_0,a_1,a_2,\\ldots,a_{n-1}$，其中 $a_i$ 表示 $F(x)$ 的第 $i$ 项系数。保证 $a_0=0$，$a_1\\neq 0$。", "outputFormat": "一行 $n$ 个非负整数，第 $i$ 个非负整数表示 $G(x)$ 的第 $i-1$ 项系数。", "hint": "对于 $100\\%$ 的数据，$2\\leq n\\leq 2^{14}$，$0\\leq a_i < 998,244,353$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Polynomial Composition Inverse", "background": "Shen Yu (姐姐) is procrastinating too much qwq.", "description": "Let $F(x)=\\sum\\limits _{i=0}^{n-1} a_ix^i$ be a degree $n-1$ polynomial.\n\nGiven $n$ and the coefficients of $F(x)$, find a degree $n-1$ polynomial $G(x)$ such that:\n\n$$\nG(F(x))\\equiv x\\pmod{x^n}\n$$\n\nOutput the coefficients of $G(x)$ modulo $998244353$.\n\nIt is guaranteed that $a_0=0$ and $a_1\\neq 0$.", "inputFormat": "The first line contains a positive integer $n$.\n\nThe second line contains $n$ non-negative integers $a_0,a_1,a_2,\\ldots,a_{n-1}$, where $a_i$ is the coefficient of the $i$-th term of $F(x)$. It is guaranteed that $a_0=0$ and $a_1\\neq 0$.", "outputFormat": "Output one line with $n$ non-negative integers. The $i$-th non-negative integer is the coefficient of the $(i-1)$-th term of $G(x)$.", "hint": "For $100\\%$ of the testdata, $2\\leq n\\leq 2^{14}$ and $0\\leq a_i < 998,244,353$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】多项式复合逆", "background": "神鱼姐姐太鸽了 qwq", "description": "令 $n-1$ 次多项式 $F(x)=\\sum\\limits _{i=0}^{n-1} a_ix^i$。\n\n给定 $n$ 和 $F(x)$ 的各项系数，要求一个 $n-1$ 次多项式 $G(x)$ 满足：\n\n$$\nG(F(x))\\equiv x\\pmod{x^n}\n$$\n\n求 $G(x)$ 的各项系数对 $998244353$ 取模的结果。\n\n保证 $a_0=0$，$a_1\\neq 0$。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个非负整数 $a_0,a_1,a_2,\\ldots,a_{n-1}$，其中 $a_i$ 表示 $F(x)$ 的第 $i$ 项系数。保证 $a_0=0$，$a_1\\neq 0$。", "outputFormat": "一行 $n$ 个非负整数，第 $i$ 个非负整数表示 $G(x)$ 的第 $i-1$ 项系数。", "hint": "对于 $100\\%$ 的数据，$2\\leq n\\leq 2^{14}$，$0\\leq a_i < 998,244,353$。", "locale": "zh-CN"}}}
{"pid": "P5810", "type": "P", "difficulty": 4, "samples": [["20", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2004", "四川", "各省省选", "O2优化"], "title": "[SCOI2004] 文本的输入", "background": "", "description": "人们在输入文本时，除了逐个输入这种方式外，还可以利用剪贴板进行复制，如果打入一个字母需要 $1$ 的时间，将已输入的部分复制进剪贴板需要 $5$ 的时间（`Ctrl`+`A`，`Ctrl`+`C`，再取消全选状态），将剪贴板的内容粘贴出来需要 $2$ 的时间（`Ctrl`+`V`）。\n\n如果我们不关心输入文本的内容，而只关心输入文本的长度，要输入一个长度**不低于** $n$ 的文本最少需要多少时间？\n\n**请注意，数据范围与原题略有不同。**\n　　", "inputFormat": "一个正整数 $n$，表示文本的长度。", "outputFormat": "一个正整数 $t$，表示需要的最短的时间。", "hint": "样例解释：先用 $7$ 时间打出 $7$ 个字符，再复制（用去 $5$ 时间），粘贴两次（用去 $4$ 时间），即可用 $16$ 时间打出 $21$ 个字符。\n\n对于 $20\\%$ 的数据，$n\\le 10$；\n\n对于 $60\\%$ 的数据，$n\\le 10^4$；\n\n对于 $100\\%$ 的数据，$n\\le 4\\times 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2004] Text Input", "background": "", "description": "When people input text, besides typing character by character, they can also use the clipboard to copy. Typing one letter takes $1$ unit of time. Copying the part that has already been typed into the clipboard takes $5$ units of time (`Ctrl`+`A`, `Ctrl`+`C`, then cancel the select-all state). Pasting the clipboard content takes $2$ units of time (`Ctrl`+`V`).\n\nIf we do not care about the actual content of the text and only care about its length, what is the minimum time needed to input a text whose length is **at least** $n$?\n\n**Note: The Constraints are slightly different from the original problem.**", "inputFormat": "A positive integer $n$, representing the length of the text.", "outputFormat": "A positive integer $t$, representing the minimum time needed.", "hint": "Sample explanation: First spend $7$ units of time to type $7$ characters, then copy (costs $5$ units of time), paste twice (costs $4$ units of time), and you can type $21$ characters in $16$ units of time.\n\nFor $20\\%$ of the testdata, $n\\le 10$.\n\nFor $60\\%$ of the testdata, $n\\le 10^4$.\n\nFor $100\\%$ of the testdata, $n\\le 4\\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2004] 文本的输入", "background": "", "description": "人们在输入文本时，除了逐个输入这种方式外，还可以利用剪贴板进行复制，如果打入一个字母需要 $1$ 的时间，将已输入的部分复制进剪贴板需要 $5$ 的时间（`Ctrl`+`A`，`Ctrl`+`C`，再取消全选状态），将剪贴板的内容粘贴出来需要 $2$ 的时间（`Ctrl`+`V`）。\n\n如果我们不关心输入文本的内容，而只关心输入文本的长度，要输入一个长度**不低于** $n$ 的文本最少需要多少时间？\n\n**请注意，数据范围与原题略有不同。**\n　　", "inputFormat": "一个正整数 $n$，表示文本的长度。", "outputFormat": "一个正整数 $t$，表示需要的最短的时间。", "hint": "样例解释：先用 $7$ 时间打出 $7$ 个字符，再复制（用去 $5$ 时间），粘贴两次（用去 $4$ 时间），即可用 $16$ 时间打出 $21$ 个字符。\n\n对于 $20\\%$ 的数据，$n\\le 10$；\n\n对于 $60\\%$ 的数据，$n\\le 10^4$；\n\n对于 $100\\%$ 的数据，$n\\le 4\\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P5811", "type": "P", "difficulty": 7, "samples": [["9 10\n4 2 3\n0 1\n0 2\n0 3\n0 4\n0 6\n0 8\n1 7\n3 7\n4 5\n5 6\n", "1 1 3 1 2 2 3 1 3\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2019", "IOI", "Special Judge"], "title": "[IOI 2019] 景点划分", "background": "### 滥用本题评测将封号\n\n注：本题按照传统题方式进行评测，即，你的程序**需要包含 `main` 函数**。", "description": "巴库有 $n$ 处景点，从 $0$ 到 $n-1$ 编号。另外还有 $m$ 条双向道路，从 $0$ 到 $m-1$ 编号。每条道路连接两个不同的景点。经由这些道路，可以在任意两处景点之间往来。\n\nFatima 打算在三天之内参观完所有这些景点。她已经决定要在第一天参观 $a$ 处景点，第二天参观 $b$ 处景点，第三天参观 $c$ 处景点。因此，她要将 $n$ 处景点划分为三个集合 $A$、$B$ 和 $C$，其规模分别为 $a$、$b$ 和 $c$。每处景点恰好属于其中一个集合，因此有 $a+b+c=n$。\n\nFatima 想要找到这样的景点划分 $A$、$B$ 和 $C$，使得这三个集合中的至少两个是联通的。一个景点集合 $S$ 被称为是联通的，如果能够经由这些道路在 $S$ 中的任意两处景点之间往来，且不需要经过不在 $S$ 中的景点。如果满足上述要求，则景点的一个划分 $A$、$B$ 和 $C$ 被称为是合法的。\n\n请帮助 Fatima 找到一个合法的景点划分 （给定 $a$、$b$ 和 $c$），或者判断合法的划分不存在。如果存在多个合法的划分，你可以给出其中的任何一个。\n\n**实现细节**\n\n你需要实现下述函数：\n`int [] find_split（int n,int a,int b,int c,int [] p,int [] q）`\n- $n$：景点的数量。\n- $a$、$b$ 和 $c$：集合$A$、$B$ 和 $C$ 的期望规模。\n- $p$ 和 $q$：长度为 $m$ 的数组，包含道路的端点。对每个 $i$ （$ 0 \\le i \\le m-1 $），$p[i]$ 和 $q[i]$ 是由道路 $i$ 连接的两处景点。\n- 该函数需要返回一个长度为 $n$ 的数组。记该数组为 $s$。如果不存在合法的划分，$s$ 应当包含 $n$ 个零。否则，对于 $0 \\le i \\le n-1$，$s[i]$ 应为 $1$、$2$ 或 $3$ 中的一个。以分别表示景点 $i$ 被归到集合 $A$、$B$ 或 $C$\n", "inputFormat": "第一行，两个正整数 $n$、$m$。\n\n第二行，三个正整数 $a$、$b$ 和 $c$。\n\n第 $3+i$ 行 （对于 $ 0 \\le i \\le m-1 $） 两个正整数 $p[i]$、$q[i]$。\n\n意义见题目描述", "outputFormat": "共一行，内容为 `find_split` 所返回的数组。", "hint": "**样例说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sltz4zao.png)\n\n一个可能解为 $[1,1,3,1,2,2,3,1,3]$。这个解刻画了这样的划分：$A=\\{0,1,3,7\\}$，$B=\\{4,5\\}$，$C=\\{2,6,8\\}$。集合 $A$ 和 $B$ 是联通的。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，\n- $3 \\le n \\le 10^5$。\n- $2 \\le m \\le 2 \\times 10^5$。\n- $1 \\le a,b,c \\le n$。\n- $a+b+c=n$。\n- 每一对景点之间至多有一条道路。\n- 经由这些道路，可以在任何两处景点之间往来。\n- 对于 $0 \\le i \\le m-1$，有 $0 \\le p[i],q[i] \\le n-1$ 和 $p[i] ≠ q[i] $。\n\n**子任务**\n1. （$7$ 分） 每处景点至多可做两条道路的端点。\n2. （$11$ 分） $a=1$\n3. （$22$ 分） $m=n-1$\n4. （$24$ 分） $n \\le 2500$，$m \\le 5000$。\n5. （$36$ 分） 没有任何附加限制。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2019] Sightseeing Splitting", "background": "### Account bans for abusing this problem's judging.\n\nNote: This problem is judged in the traditional way, i.e., your program **must contain the `main` function**.", "description": "Baku has $n$ sightseeing spots, numbered from $0$ to $n-1$. There are also $m$ bidirectional roads, numbered from $0$ to $m-1$. Each road connects two different spots. Using these roads, it is possible to travel between any two spots.\n\nFatima plans to visit all the spots within three days. She has decided to visit $a$ spots on the first day, $b$ spots on the second day, and $c$ spots on the third day. Therefore, she wants to split the $n$ spots into three sets $A$, $B$, and $C$, with sizes $a$, $b$, and $c$ respectively. Each spot belongs to exactly one set, so $a+b+c=n$.\n\nFatima wants to find a split into $A$, $B$, and $C$ such that at least two of these three sets are connected. A set of spots $S$ is called connected if it is possible to travel between any two spots in $S$ using the roads, without having to pass through any spot not in $S$. If the above requirement is satisfied, then the split into $A$, $B$, and $C$ is called valid.\n\nPlease help Fatima find a valid split (given $a$, $b$, and $c$), or determine that no valid split exists. If multiple valid splits exist, you may output any one of them.\n\n**Implementation details**\n\nYou need to implement the following function:  \n`int [] find_split（int n,int a,int b,int c,int [] p,int [] q）`\n- $n$: the number of sightseeing spots.\n- $a$, $b$, and $c$: the desired sizes of sets $A$, $B$, and $C$.\n- $p$ and $q$: arrays of length $m$ containing the endpoints of the roads. For each $i$ ($ 0 \\le i \\le m-1 $), $p[i]$ and $q[i]$ are the two spots connected by road $i$.\n- The function should return an array of length $n$. Call this array $s$. If no valid split exists, $s$ should contain $n$ zeros. Otherwise, for $0 \\le i \\le n-1$, $s[i]$ should be one of $1$, $2$, or $3$, indicating that spot $i$ is assigned to set $A$, $B$, or $C$, respectively.", "inputFormat": "The first line contains two positive integers $n$ and $m$.\n\nThe second line contains three positive integers $a$, $b$, and $c$.\n\nLine $3+i$ (for $ 0 \\le i \\le m-1 $) contains two positive integers $p[i]$ and $q[i]$.\n\nTheir meanings are the same as in the statement.", "outputFormat": "One line, containing the array returned by `find_split`.", "hint": "**Sample explanation**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sltz4zao.png)\n\nOne possible solution is $[1,1,3,1,2,2,3,1,3]$. This solution describes the following split: $A=\\{0,1,3,7\\}$, $B=\\{4,5\\}$, $C=\\{2,6,8\\}$. Sets $A$ and $B$ are connected.\n\n**Constraints**\n\nFor $100\\%$ of the testdata:\n- $3 \\le n \\le 10^5$.\n- $2 \\le m \\le 2 \\times 10^5$.\n- $1 \\le a,b,c \\le n$.\n- $a+b+c=n$.\n- There is at most one road between each pair of spots.\n- Using these roads, it is possible to travel between any two spots.\n- For $0 \\le i \\le m-1$, $0 \\le p[i],q[i] \\le n-1$ and $p[i] ≠ q[i]$.\n\n**Subtasks**\n1. ($7$ points) Each spot can be an endpoint of at most two roads.\n2. ($11$ points) $a=1$.\n3. ($22$ points) $m=n-1$.\n4. ($24$ points) $n \\le 2500$, $m \\le 5000$.\n5. ($36$ points) No additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2019] 景点划分", "background": "### 滥用本题评测将封号\n\n注：本题按照传统题方式进行评测，即，你的程序**需要包含 `main` 函数**。", "description": "巴库有 $n$ 处景点，从 $0$ 到 $n-1$ 编号。另外还有 $m$ 条双向道路，从 $0$ 到 $m-1$ 编号。每条道路连接两个不同的景点。经由这些道路，可以在任意两处景点之间往来。\n\nFatima 打算在三天之内参观完所有这些景点。她已经决定要在第一天参观 $a$ 处景点，第二天参观 $b$ 处景点，第三天参观 $c$ 处景点。因此，她要将 $n$ 处景点划分为三个集合 $A$、$B$ 和 $C$，其规模分别为 $a$、$b$ 和 $c$。每处景点恰好属于其中一个集合，因此有 $a+b+c=n$。\n\nFatima 想要找到这样的景点划分 $A$、$B$ 和 $C$，使得这三个集合中的至少两个是联通的。一个景点集合 $S$ 被称为是联通的，如果能够经由这些道路在 $S$ 中的任意两处景点之间往来，且不需要经过不在 $S$ 中的景点。如果满足上述要求，则景点的一个划分 $A$、$B$ 和 $C$ 被称为是合法的。\n\n请帮助 Fatima 找到一个合法的景点划分 （给定 $a$、$b$ 和 $c$），或者判断合法的划分不存在。如果存在多个合法的划分，你可以给出其中的任何一个。\n\n**实现细节**\n\n你需要实现下述函数：\n`int [] find_split（int n,int a,int b,int c,int [] p,int [] q）`\n- $n$：景点的数量。\n- $a$、$b$ 和 $c$：集合$A$、$B$ 和 $C$ 的期望规模。\n- $p$ 和 $q$：长度为 $m$ 的数组，包含道路的端点。对每个 $i$ （$ 0 \\le i \\le m-1 $），$p[i]$ 和 $q[i]$ 是由道路 $i$ 连接的两处景点。\n- 该函数需要返回一个长度为 $n$ 的数组。记该数组为 $s$。如果不存在合法的划分，$s$ 应当包含 $n$ 个零。否则，对于 $0 \\le i \\le n-1$，$s[i]$ 应为 $1$、$2$ 或 $3$ 中的一个。以分别表示景点 $i$ 被归到集合 $A$、$B$ 或 $C$\n", "inputFormat": "第一行，两个正整数 $n$、$m$。\n\n第二行，三个正整数 $a$、$b$ 和 $c$。\n\n第 $3+i$ 行 （对于 $ 0 \\le i \\le m-1 $） 两个正整数 $p[i]$、$q[i]$。\n\n意义见题目描述", "outputFormat": "共一行，内容为 `find_split` 所返回的数组。", "hint": "**样例说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sltz4zao.png)\n\n一个可能解为 $[1,1,3,1,2,2,3,1,3]$。这个解刻画了这样的划分：$A=\\{0,1,3,7\\}$，$B=\\{4,5\\}$，$C=\\{2,6,8\\}$。集合 $A$ 和 $B$ 是联通的。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，\n- $3 \\le n \\le 10^5$。\n- $2 \\le m \\le 2 \\times 10^5$。\n- $1 \\le a,b,c \\le n$。\n- $a+b+c=n$。\n- 每一对景点之间至多有一条道路。\n- 经由这些道路，可以在任何两处景点之间往来。\n- 对于 $0 \\le i \\le m-1$，有 $0 \\le p[i],q[i] \\le n-1$ 和 $p[i] ≠ q[i] $。\n\n**子任务**\n1. （$7$ 分） 每处景点至多可做两条道路的端点。\n2. （$11$ 分） $a=1$\n3. （$22$ 分） $m=n-1$\n4. （$24$ 分） $n \\le 2500$，$m \\le 5000$。\n5. （$36$ 分） 没有任何附加限制。", "locale": "zh-CN"}}}
{"pid": "P5812", "type": "P", "difficulty": 7, "samples": [["7 7\n0 8\n3 7\n5 9\n7 7\n10 6\n12 6\n14 9\n0 1 1\n0 2 6\n0 6 8\n2 3 1\n2 6 7\n3 4 2\n4 6 5\n1 5", "27\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2019", "IOI", "Special Judge"], "title": "[IOI 2019] 天桥", "background": "### 滥用本题评测将封号\n\n注：本题按照传统题方式进行评测，即，你的程序**需要包含 `main` 函数**。", "description": "Kenan 为沿着巴库大街某一侧的建筑和天桥绘制了一张规划图。规划图中有 $n$ 栋建筑，从 $0$ 到 $n-1$ 编号。还有 $m$ 座天桥，从 $0$ 到 $m-1$ 编号。这张规划图绘制在一张二维平面上，其中建筑和天桥分别是垂直和水平的线段。\n\n第 $i$（$0 \\le i \\le n-1$） 栋建筑的底部坐落在坐标 （$x[i],0$） 上，建筑的高度为 $h[i]$。因此，它对应一条连接点 （$x[i],0$） 和 （$x[i],h[i]$） 的线段。\n\n第 $j$（$0 \\le j \\le m-1$） 座天桥的两端分别在第 $l[j]$ 栋建筑和第 $r[j]$ 栋建筑上，并具有正的 $y$ 坐标 $y[j]$。因此，它对应一条连接点 （$x[l[j]],y[j]$） 和 （$x[r[j]],y[j]$） 的线段。\n\n称某座天桥和某栋建筑相交，如果它们有某个公共的点。因此，一座天桥在它的两个端点处与两栋建筑相交，同时还可能在中间和其他建筑相交。\n\nKenan 想要找出从第 $s$ 栋建筑的底部到第 $g$ 栋建筑的底部的最短路径长度，或者确认这样的路径不存在。在这里行人只能沿着建筑和天桥行走，并且不允许在地面上行走，也就是说不允许沿着 $y$ 坐标为 $0$ 的水平线行走。\n\n行人能够在任意交点从某座天桥走进某栋建筑，或者从某栋建筑走上某座天桥。如果两座天桥的端点之一在同一点上，行人也可以从其中一座天桥走上另一座天桥。\n\n你的任务是帮助 Kenan 回答他的问题。\n\n**实现细节**\n\n你需要实现下列函数。\n`int64 min_distance(int[] x,int[] h,int[] l,int[] r,int[] y,int s,int g)`\n\n- $x$ 和 $h$：长度为 $n$ 的整数数组。\n- $l$、$r$ 和 $y$：长度为 $m$ 的整数数组。\n- $s$ 和 $g$：两个整数。\n- 如果从第 $s$ 栋建筑的底部到第 $g$ 栋建筑的底部的最短路径存在，则该函数应该返回最短路径的长度。否则，该函数应该返回`-1`。", "inputFormat": "- 第 $1$ 行：$n$，$m$。\n- 第 $2+i$ 行（$0 \\le i \\le n-1$）：$x[i]$，$h[i]$。\n- 第 $n+2+j$ 行（$0 \\le j \\le m-1$）：$l[j]$，$r[j]$，$y[j]$。\n- 第 $n+m+2$ 行：$s$，$g$。", "outputFormat": "共一行，为函数 `min_distance` 的返回值。", "hint": "**样例说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t0lihb5c.png)\n\n**限制条件**\n\n- $1 \\le n,m \\le 10^5$。\n- $0 \\le x[0] < x[1] < \\cdots < x[n-1] \\le 10^9$。\n- $1 \\le h[i] \\le 10^9$（对于所有 $0 \\le i \\le n-1$）。\n- $0 \\le l[j] \\le r[j] \\le n-1$（对于所有 $0 \\le j \\le m-1$）。\n- $1 \\le y[j] \\le \\min(h[l[j]],h[r[j]])$（对于所有 $0 \\le j \\le m-1$）。\n- $0 \\le s,g \\le n-1$。\n- $s ≠ g$。\n- 除在端点处外，任意两座天桥不会有其他公共的点。\n\n**子任务**\n\n1. （$10$ 分）$n,m \\le 50$。\n2. （$14$ 分）每座天桥最多与 $10$ 栋建筑相交。\n3. （$15$ 分）$s=0$，$g=n-1$，且所有建筑的高度相等。\n4. （$18$ 分）$s=0$，$g=n-1$。\n5. （$43$ 分）没有任何附加限制。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2019] Skybridges", "background": "### Abuse of this problem’s judging system will result in account suspension.\n\nNote: This problem is judged in the traditional way, i.e., your program **must contain a `main` function**.", "description": "Kenan has drawn a plan of the buildings and skybridges along one side of Baku Avenue. The plan contains $n$ buildings, numbered from $0$ to $n-1$. It also contains $m$ skybridges, numbered from $0$ to $m-1$. The plan is drawn on a two-dimensional plane, where buildings and skybridges are vertical and horizontal line segments, respectively.\n\nThe bottom of building $i$ ($0 \\le i \\le n-1$) is located at coordinate $(x[i],0)$, and its height is $h[i]$. Therefore, it corresponds to the line segment connecting $(x[i],0)$ and $(x[i],h[i])$.\n\nSkybridge $j$ ($0 \\le j \\le m-1$) has its two endpoints on building $l[j]$ and building $r[j]$, and has a positive $y$-coordinate $y[j]$. Therefore, it corresponds to the line segment connecting $(x[l[j]],y[j])$ and $(x[r[j]],y[j])$.\n\nA skybridge and a building are said to intersect if they share at least one common point. Thus, a skybridge intersects the two buildings at its endpoints, and it may also intersect other buildings in between.\n\nKenan wants to find the length of the shortest path from the bottom of building $s$ to the bottom of building $g$, or determine that no such path exists. Pedestrians can only walk along buildings and skybridges, and are not allowed to walk on the ground, meaning they are not allowed to walk along the horizontal line with $y$-coordinate $0$.\n\nAt any intersection point, a pedestrian can move from a skybridge onto a building, or from a building onto a skybridge. If an endpoint of one skybridge is at the same point as an endpoint of another skybridge, the pedestrian can also move from one skybridge to the other.\n\nYour task is to help Kenan answer his question.\n\n**Implementation Details**\n\nYou need to implement the following function.  \n`int64 min_distance(int[] x,int[] h,int[] l,int[] r,int[] y,int s,int g)`\n\n- $x$ and $h$: integer arrays of length $n$.\n- $l$, $r$, and $y$: integer arrays of length $m$.\n- $s$ and $g$: two integers.\n- If the shortest path from the bottom of building $s$ to the bottom of building $g$ exists, the function should return the length of the shortest path. Otherwise, it should return `-1`.", "inputFormat": "- Line $1$: $n$, $m$.\n- Line $2+i$ ($0 \\le i \\le n-1$): $x[i]$, $h[i]$.\n- Line $n+2+j$ ($0 \\le j \\le m-1$): $l[j]$, $r[j]$, $y[j]$.\n- Line $n+m+2$: $s$, $g$.", "outputFormat": "A single line containing the return value of the function `min_distance`.", "hint": "**Sample Explanation**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t0lihb5c.png)\n\n**Constraints**\n\n- $1 \\le n,m \\le 10^5$.\n- $0 \\le x[0] < x[1] < \\cdots < x[n-1] \\le 10^9$.\n- $1 \\le h[i] \\le 10^9$ (for all $0 \\le i \\le n-1$).\n- $0 \\le l[j] \\le r[j] \\le n-1$ (for all $0 \\le j \\le m-1$).\n- $1 \\le y[j] \\le \\min(h[l[j]],h[r[j]])$ (for all $0 \\le j \\le m-1$).\n- $0 \\le s,g \\le n-1$.\n- $s \\ne g$.\n- Except at endpoints, any two skybridges do not have any other common points.\n\n**Subtasks**\n\n1. ($10$ points) $n,m \\le 50$.\n2. ($14$ points) Each skybridge intersects at most $10$ buildings.\n3. ($15$ points) $s=0$, $g=n-1$, and all buildings have equal height.\n4. ($18$ points) $s=0$, $g=n-1$.\n5. ($43$ points) No additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2019] 天桥", "background": "### 滥用本题评测将封号\n\n注：本题按照传统题方式进行评测，即，你的程序**需要包含 `main` 函数**。", "description": "Kenan 为沿着巴库大街某一侧的建筑和天桥绘制了一张规划图。规划图中有 $n$ 栋建筑，从 $0$ 到 $n-1$ 编号。还有 $m$ 座天桥，从 $0$ 到 $m-1$ 编号。这张规划图绘制在一张二维平面上，其中建筑和天桥分别是垂直和水平的线段。\n\n第 $i$（$0 \\le i \\le n-1$） 栋建筑的底部坐落在坐标 （$x[i],0$） 上，建筑的高度为 $h[i]$。因此，它对应一条连接点 （$x[i],0$） 和 （$x[i],h[i]$） 的线段。\n\n第 $j$（$0 \\le j \\le m-1$） 座天桥的两端分别在第 $l[j]$ 栋建筑和第 $r[j]$ 栋建筑上，并具有正的 $y$ 坐标 $y[j]$。因此，它对应一条连接点 （$x[l[j]],y[j]$） 和 （$x[r[j]],y[j]$） 的线段。\n\n称某座天桥和某栋建筑相交，如果它们有某个公共的点。因此，一座天桥在它的两个端点处与两栋建筑相交，同时还可能在中间和其他建筑相交。\n\nKenan 想要找出从第 $s$ 栋建筑的底部到第 $g$ 栋建筑的底部的最短路径长度，或者确认这样的路径不存在。在这里行人只能沿着建筑和天桥行走，并且不允许在地面上行走，也就是说不允许沿着 $y$ 坐标为 $0$ 的水平线行走。\n\n行人能够在任意交点从某座天桥走进某栋建筑，或者从某栋建筑走上某座天桥。如果两座天桥的端点之一在同一点上，行人也可以从其中一座天桥走上另一座天桥。\n\n你的任务是帮助 Kenan 回答他的问题。\n\n**实现细节**\n\n你需要实现下列函数。\n`int64 min_distance(int[] x,int[] h,int[] l,int[] r,int[] y,int s,int g)`\n\n- $x$ 和 $h$：长度为 $n$ 的整数数组。\n- $l$、$r$ 和 $y$：长度为 $m$ 的整数数组。\n- $s$ 和 $g$：两个整数。\n- 如果从第 $s$ 栋建筑的底部到第 $g$ 栋建筑的底部的最短路径存在，则该函数应该返回最短路径的长度。否则，该函数应该返回`-1`。", "inputFormat": "- 第 $1$ 行：$n$，$m$。\n- 第 $2+i$ 行（$0 \\le i \\le n-1$）：$x[i]$，$h[i]$。\n- 第 $n+2+j$ 行（$0 \\le j \\le m-1$）：$l[j]$，$r[j]$，$y[j]$。\n- 第 $n+m+2$ 行：$s$，$g$。", "outputFormat": "共一行，为函数 `min_distance` 的返回值。", "hint": "**样例说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t0lihb5c.png)\n\n**限制条件**\n\n- $1 \\le n,m \\le 10^5$。\n- $0 \\le x[0] < x[1] < \\cdots < x[n-1] \\le 10^9$。\n- $1 \\le h[i] \\le 10^9$（对于所有 $0 \\le i \\le n-1$）。\n- $0 \\le l[j] \\le r[j] \\le n-1$（对于所有 $0 \\le j \\le m-1$）。\n- $1 \\le y[j] \\le \\min(h[l[j]],h[r[j]])$（对于所有 $0 \\le j \\le m-1$）。\n- $0 \\le s,g \\le n-1$。\n- $s ≠ g$。\n- 除在端点处外，任意两座天桥不会有其他公共的点。\n\n**子任务**\n\n1. （$10$ 分）$n,m \\le 50$。\n2. （$14$ 分）每座天桥最多与 $10$ 栋建筑相交。\n3. （$15$ 分）$s=0$，$g=n-1$，且所有建筑的高度相等。\n4. （$18$ 分）$s=0$，$g=n-1$。\n5. （$43$ 分）没有任何附加限制。", "locale": "zh-CN"}}}
{"pid": "P5813", "type": "P", "difficulty": 4, "samples": [["5 5\n3\n15 10 6 4\n70 100 7 2\n30 70 1 6\n", "93\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2001", "背包 DP", "WC"], "title": "[WC2001] 高性能计算机", "background": "", "description": "现在有一项时间紧迫的工程计算任务要交给你——国家高性能并行计算机的主管工程师——来完成。为了尽可能充分发挥并行计算机的优势，我们的计算任务应当划分成若干个小的子任务。\n\n这项大型计算任务包括 $A$ 和 $B$ 两个互不相关的较小的计算任务。为了充分发挥并行计算机的运算能力，这些任务需要进行分解。研究发现，$A$ 和 $B$ 都可以各自划分成很多较小的子任务，所有的 $A$ 类子任务的工作量都是一样的，所有的 $B$ 类子任务也是如此（$A$ 和 $B$ 类的子任务的工作量不一定相同）。$A$ 和 $B$ 两个计算任务之间，以及各子任务之间都没有执行顺序上的要求。\n\n这台超级计算机拥有 $p$ 个计算节点，每个节点都包括一个串行处理器、本地主存和高速 cache。然而由于常年使用和不连贯的升级，各个计算节点的计算能力并不对称。一个节点的计算能力包括如下几个方面：\n\n1. 就本任务来说，每个节点都有三种工作状态：待机、$A$ 类和 $B$ 类。其中，$A$ 类状态下执行 $A$ 类任务；$B$ 类状态下执行 $B$ 类任务；待机状态下不执行计算。所有的处理器在开始工作之前都处于待机状态，而从其它的状态转入 $A$ 或 $B$ 的工作状态（包括 $A$ 和 $B$ 之间相互转换），都要花费一定的启动时间。对于不同的处理节点，这个时间不一定相同。用两个正整数 $t_{i}^{A}$ ​和 $t_{i}^{B}$ ($i = 1,2,\\cdots,p$)分别表示节点 $i$ 转入工作状态 $A$ 和工作状态 $B$ 的启动时间（单位：ns）。\n\n2. 一个节点在连续处理同一类任务的时候，执行时间——不含状态转换的时间——随任务量（这一类子任务的数目）的平方增长，即：\n\n若节点 $i$ 连续处理 $x$ 个 $A$ 类子任务，则对应的执行时间为：$t = k_{i}^{A} x^2$；\n\n类似的，若节点 $i$ 连续处理 $x$ 个 $B$ 类子任务，对应的执行时间为：$t = k_{i}^{B} x^2$。\n\n其中，$k_{i}^{A}$ ​和 $k_{i}^{B} $ ​是系数，单位是 ns，$i=1,2,\\cdots,p$。\n\n任务分配必须在所有计算开始之前完成，所谓任务分配，即给每个计算节点设置一个任务队列，队列由一串 $A$ 类和 $B$ 类子任务组成。两类子任务可以交错排列。\n\n计算开始后，各计算节点分别从各自的子任务队列中顺序读取计算任务并执行，队列中连续的同类子任务将由该计算节点一次性读出，队列中一串连续的同类子任务不能被分成两部分执行。\n\n现在需要你编写程序，给这 $p$ 个节点安排计算任务，使得这个工程计算任务能够尽早完成。假定任务安排好后不再变动，而且所有的节点都同时开始运行，任务安排的目标是使最后结束计算的节点的完成时间尽可能早。", "inputFormat": "第一行是对计算任务的描述，包括两个正整数 $n_A$ 和 $n_B$，分别是 $A$ 类和 $B$ 类子任务的数目，两个整数之间由一个空格隔开。\n\n后面部分是对此计算机的描述：\n\n第二行是一个整数 $p$，即计算节点的数目。\n\n随后连续的 $p$ 行按顺序分别描述各个节点的信息，第 $i$ 个节点由第 $i+2$ 行描述，该行包括下述四个正整数（相邻两个整数之间有一个空格）：$t_{i}^{A},t_{i}^{B},k_{i}^{A},k_{i}^{B}$。", "outputFormat": "只有一行，包含有一个正整数，即从各节点开始计算到任务完成所用的时间。\n\n", "hint": "对于所有数据： $1 \\le n_A \\le 60$，$1 \\le n_B \\le 60$，$1 \\le p \\le 20$，$1 \\le t_{i}^{A} \\le 1000$，$1 \\le t_{i}^{B} \\le 1000$，$1 \\le k_{i}^{A} \\le 50$，$1 \\le k_{i}^{B} \\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[WC2001] High-Performance Computer", "background": "", "description": "You now have a time-critical engineering computation task to complete, as the chief engineer of a national high-performance parallel computer. To make full use of the advantages of parallel computing, the computation task should be split into several smaller subtasks.\n\nThis large computation task consists of two independent smaller computation tasks, $A$ and $B$. To fully use the computing power of the parallel computer, these tasks need to be decomposed. It is found that both $A$ and $B$ can each be divided into many smaller subtasks. The workload of all type $A$ subtasks is the same, and the workload of all type $B$ subtasks is also the same (the workloads of type $A$ and type $B$ subtasks are not necessarily the same). There is no required execution order between tasks $A$ and $B$, nor among the subtasks.\n\nThis supercomputer has $p$ computing nodes. Each node includes a serial processor, local main memory, and high-speed cache. However, due to long-term use and inconsistent upgrades, the computing abilities of the nodes are not symmetric. A node’s computing ability includes the following aspects:\n\n1. For this task, each node has three working states: standby, type $A$, and type $B$. In type $A$ state it executes type $A$ tasks; in type $B$ state it executes type $B$ tasks; in standby state it does not compute. All processors are in standby before starting work. Switching from any other state into working state $A$ or $B$ (including switching between $A$ and $B$) requires a certain startup time. This time may differ across nodes. Use two positive integers $t_{i}^{A}$ and $t_{i}^{B}$ ($i = 1,2,\\cdots,p$) to represent the startup time (in ns) for node $i$ to enter working state $A$ and working state $B$, respectively.\n\n2. When a node continuously processes tasks of the same type, the execution time (excluding state switching time) grows with the square of the task amount (the number of subtasks of that type), i.e.:\n\nIf node $i$ continuously processes $x$ type $A$ subtasks, the corresponding execution time is $t = k_{i}^{A} x^2$.\n\nSimilarly, if node $i$ continuously processes $x$ type $B$ subtasks, the corresponding execution time is $t = k_{i}^{B} x^2$.\n\nHere, $k_{i}^{A}$ and $k_{i}^{B}$ are coefficients in ns, for $i = 1,2,\\cdots,p$.\n\nTask assignment must be completed before any computation starts. “Task assignment” means setting a task queue for each computing node. The queue consists of a sequence of type $A$ and type $B$ subtasks. The two types of subtasks can be interleaved.\n\nAfter computation starts, each node reads computation tasks from its own task queue in order and executes them. A consecutive block of same-type subtasks in the queue will be read and executed by that node in one batch, and such a consecutive block cannot be split into two parts for execution.\n\nYou need to write a program to schedule the computation tasks for these $p$ nodes so that the engineering computation task can be completed as early as possible. Assume the schedule will not change after being set, and all nodes start running at the same time. The goal is to make the completion time of the last finishing node as early as possible.", "inputFormat": "The first line describes the computation tasks, containing two positive integers $n_A$ and $n_B$, which are the numbers of type $A$ and type $B$ subtasks, respectively. The two integers are separated by one space.\n\nThe following part describes the computer:\n\nThe second line contains an integer $p$, the number of computing nodes.\n\nThen follow $p$ lines describing the nodes in order. Node $i$ is described on line $i+2$, which contains four positive integers (separated by one space): $t_{i}^{A},t_{i}^{B},k_{i}^{A},k_{i}^{B}$.", "outputFormat": "Only one line containing one positive integer: the time from when all nodes start computing until the task is completed.", "hint": "For all testdata: $1 \\le n_A \\le 60$, $1 \\le n_B \\le 60$, $1 \\le p \\le 20$, $1 \\le t_{i}^{A} \\le 1000$, $1 \\le t_{i}^{B} \\le 1000$, $1 \\le k_{i}^{A} \\le 50$, $1 \\le k_{i}^{B} \\le 50$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2001] 高性能计算机", "background": "", "description": "现在有一项时间紧迫的工程计算任务要交给你——国家高性能并行计算机的主管工程师——来完成。为了尽可能充分发挥并行计算机的优势，我们的计算任务应当划分成若干个小的子任务。\n\n这项大型计算任务包括 $A$ 和 $B$ 两个互不相关的较小的计算任务。为了充分发挥并行计算机的运算能力，这些任务需要进行分解。研究发现，$A$ 和 $B$ 都可以各自划分成很多较小的子任务，所有的 $A$ 类子任务的工作量都是一样的，所有的 $B$ 类子任务也是如此（$A$ 和 $B$ 类的子任务的工作量不一定相同）。$A$ 和 $B$ 两个计算任务之间，以及各子任务之间都没有执行顺序上的要求。\n\n这台超级计算机拥有 $p$ 个计算节点，每个节点都包括一个串行处理器、本地主存和高速 cache。然而由于常年使用和不连贯的升级，各个计算节点的计算能力并不对称。一个节点的计算能力包括如下几个方面：\n\n1. 就本任务来说，每个节点都有三种工作状态：待机、$A$ 类和 $B$ 类。其中，$A$ 类状态下执行 $A$ 类任务；$B$ 类状态下执行 $B$ 类任务；待机状态下不执行计算。所有的处理器在开始工作之前都处于待机状态，而从其它的状态转入 $A$ 或 $B$ 的工作状态（包括 $A$ 和 $B$ 之间相互转换），都要花费一定的启动时间。对于不同的处理节点，这个时间不一定相同。用两个正整数 $t_{i}^{A}$ ​和 $t_{i}^{B}$ ($i = 1,2,\\cdots,p$)分别表示节点 $i$ 转入工作状态 $A$ 和工作状态 $B$ 的启动时间（单位：ns）。\n\n2. 一个节点在连续处理同一类任务的时候，执行时间——不含状态转换的时间——随任务量（这一类子任务的数目）的平方增长，即：\n\n若节点 $i$ 连续处理 $x$ 个 $A$ 类子任务，则对应的执行时间为：$t = k_{i}^{A} x^2$；\n\n类似的，若节点 $i$ 连续处理 $x$ 个 $B$ 类子任务，对应的执行时间为：$t = k_{i}^{B} x^2$。\n\n其中，$k_{i}^{A}$ ​和 $k_{i}^{B} $ ​是系数，单位是 ns，$i=1,2,\\cdots,p$。\n\n任务分配必须在所有计算开始之前完成，所谓任务分配，即给每个计算节点设置一个任务队列，队列由一串 $A$ 类和 $B$ 类子任务组成。两类子任务可以交错排列。\n\n计算开始后，各计算节点分别从各自的子任务队列中顺序读取计算任务并执行，队列中连续的同类子任务将由该计算节点一次性读出，队列中一串连续的同类子任务不能被分成两部分执行。\n\n现在需要你编写程序，给这 $p$ 个节点安排计算任务，使得这个工程计算任务能够尽早完成。假定任务安排好后不再变动，而且所有的节点都同时开始运行，任务安排的目标是使最后结束计算的节点的完成时间尽可能早。", "inputFormat": "第一行是对计算任务的描述，包括两个正整数 $n_A$ 和 $n_B$，分别是 $A$ 类和 $B$ 类子任务的数目，两个整数之间由一个空格隔开。\n\n后面部分是对此计算机的描述：\n\n第二行是一个整数 $p$，即计算节点的数目。\n\n随后连续的 $p$ 行按顺序分别描述各个节点的信息，第 $i$ 个节点由第 $i+2$ 行描述，该行包括下述四个正整数（相邻两个整数之间有一个空格）：$t_{i}^{A},t_{i}^{B},k_{i}^{A},k_{i}^{B}$。", "outputFormat": "只有一行，包含有一个正整数，即从各节点开始计算到任务完成所用的时间。\n\n", "hint": "对于所有数据： $1 \\le n_A \\le 60$，$1 \\le n_B \\le 60$，$1 \\le p \\le 20$，$1 \\le t_{i}^{A} \\le 1000$，$1 \\le t_{i}^{B} \\le 1000$，$1 \\le k_{i}^{A} \\le 50$，$1 \\le k_{i}^{B} \\le 50$。", "locale": "zh-CN"}}}
{"pid": "P5814", "type": "P", "difficulty": 6, "samples": [["6 13\n0.9 0.7 0.8 0 0 0 2 6 8 0 0 0\n0 0 0 1 0 1\n1 4 0.5 2\n2 3 0.9 5\n2 5 0.8 2\n2 6 0.8 7\n3 5 0.8 2\n5 6 0.8 4\n-1 -1\n", "0.00021184\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2001", "网络流", "费用流", "CTSC/CTS"], "title": "[CTSC2001] 终极情报网", "background": "", "description": "在最后的诺曼底登陆战开始之前，盟军与德军的情报部门围绕着最终的登陆地点展开了一场规模空前的情报战。 这场情报战中，盟军的战术是利用那些潜伏在敌军内部的双重间谍，将假的登陆消息发布给敌军的情报机关的负责人。那些已经潜入敌后的间谍们都是盟军情报部的精英，忠实可靠；但是如何选择合适的人选，以及最佳的消息传递方法，才能保证假消息能够尽快而且安全准确地传递到德军指挥官们的耳朵里，成了困扰盟军情报部长的最大问题。他需要你的帮助。\n\n以下是情报部长提供的作战资料：\n\n在敌后一共潜伏着我方最优秀的 $N$ 名间谍，分别用数字 $1,2,\\cdots,N$ 编号。在给定的作战时间内，任意两人之间至多只进行一次点对点的双人联系。 我将给你一份表格，表格中将提供任意两位间谍 $i$ 和 $j$ 之间进行联系的安全程度，用一个 $[0,1]$ 的实数 $S_{i,j}$ 表示；以及他们这次联系时，能够互相传递的消息的最大数目，用一个正整数表示 $M_{i,j}$（如果在表格中没有被提及，那么间谍 $i$ 和 $j$ 之间不进行直接联系）。 假消息从盟军总部传递到每个间谍手里的渠道也不是绝对安全，我们用 $[0,1]$ 的实数 $AS_j$ 表示总部与间谍 $j$ 之间进行联系的安全程度，$AM_j $  则表示总部和间谍 $j$ 之间进行联系时传递的消息的最大数目。对于不和总部直接联系的间谍，他的  $AM_j = 0$（而表格中给出的他的 $AS_j$ 是没有意义的）。 当然，假消息从间谍手中交到敌军的情报部官员的办公桌上的过程是绝对安全的，也即是说，间谍与敌军情报部门之间要么不进行直接联系，要么其联系的安全程度是 $1$（即完全可靠）。\n\n现在情报部打算把 $K$ 条假消息“透露”到德军那里。消息先由总部一次性发给 $N$ 名间谍中的一些人，再通过他们之间的情报网传播，最终由这 $N$ 名间谍中的某些将情报送到德军手中。 对于一条消息，只有安全的通过了所有的中转过程到达敌军情报部，这个传递消息的过程才算是安全的；因此根据乘法原理，它的安全程度 $P$ 就是从总部出发，经多次传递直到到达德军那里，每一次传递该消息的安全程度的乘积。 而对于整个计划而言，只有当 $N$ 条消息都安全的通过情报网到达德军手中，没有一条引起怀疑时，才算是成功的。所以计划的可靠程度是所有消息的安全程度的乘积。 显然，计划的可靠性取决于这些消息在情报网中的传递方法。 我需要一个方案，确定消息应该从哪些人手中传递到哪些人手中，使得最终计划的可靠性最大。\n\n你可以利用计算机，来求得这个最可靠的消息传递方案。", "inputFormat": "输入包含了盟军的作战资料表格。\n\n第一行包括两个整数 $N$ 和 $K$ ，分别是间谍的总人数和计划包含的消息总数。\n\n第二行包括 $2N$ 个数，前 $N$ 个数是实数 $AS_1,AS_2,\\cdots,AS_N$ （范围在 $[0,1]$ 以内）；后 $N$ 个数是整数 $AM_1,AM_2,\\cdots,AM_N$ 。\n\n第三行包含了 $N$ 个整数，其中第 $i$（$i = 1,2,\\cdots,N$）个整数如果为 $0$ 表示间谍 $i$ 与德军情报部不进行联系，如果为 $1$ 则表示间谍 $i$ 与德军情报部进行联系。\n\n第四行开始，每行包括 $4$ 个数，依次分别是：代表间谍编号的正整数 $i$ 和 $j$ ，间谍 $i$ 和 $j$ 联系的安全性参数 $S_{i,j}$ ( $[0,1]$ 范围内的实数)，以及 $i,j$ 之间传递的最大消息数 $M_{i,j}$ (每一行的 $i$ 均小于 $j$)。\n\n最后的一行为 `-1 -1` ，表示输入数据的结束。", "outputFormat": "输出只有一行。这一行中包含一个实数 $P$ ，给出的是整个计划的可靠程度 $P$ ，**保留 $5$ 位有效数字**（四舍五入）。\n\n如果情报网根本不能将 $K$ 条消息传到德军手中，那么计划的可靠性为 $0$ 。\n\n(你可以假定，如果计划存在，那么它的可靠性大于 $10^{-12}$)", "hint": "$1 \\le N,K \\le 300$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2001] Ultimate Intelligence Network.", "background": "", "description": "Before the final Normandy landing battle began, the Allied and German intelligence agencies fought an unprecedented intelligence war over the final landing location. In this intelligence war, the Allied tactic was to use double agents hidden inside the enemy to release fake landing information to the heads of the German intelligence agencies. Those agents who had already infiltrated behind enemy lines were all elites of the Allied intelligence department, loyal and reliable. However, how to choose suitable people, and the best way to transmit messages, so that the fake information could be delivered to the German commanders as quickly, safely, and accurately as possible, became the biggest problem troubling the Allied intelligence minister. He needs your help.\n\nThe minister provides the following operational data:\n\nThere are a total of $N$ of our best spies behind enemy lines, numbered $1,2,\\cdots,N$. Within the given operation time, any two people can make at most one point-to-point two-person contact. You will be given a table. The table provides the security level of a contact between any two spies $i$ and $j$, represented by a real number $S_{i,j}$ in $[0,1]$; and the maximum number of messages they can exchange in this contact, represented by a positive integer $M_{i,j}$ (if it is not mentioned in the table, then spies $i$ and $j$ do not contact directly). The channel for sending fake messages from the Allied headquarters to each spy is also not absolutely safe. We use a real number $AS_j$ in $[0,1]$ to represent the security level of contact between the headquarters and spy $j$, and $AM_j$ to represent the maximum number of messages that can be transmitted when the headquarters contacts spy $j$. For spies that do not contact the headquarters directly, $AM_j = 0$ (and the given $AS_j$ is meaningless). Of course, the process of delivering a fake message from a spy to the German intelligence officer’s desk is absolutely safe; that is, a spy either does not contact the German intelligence department directly, or the security level of that contact is $1$ (completely reliable).\n\nNow the intelligence department plans to “leak” $K$ fake messages to the Germans. The messages are first sent by the headquarters in one batch to some of the $N$ spies, then spread through their intelligence network, and finally delivered to the Germans by some of these $N$ spies. For a single message, the transmission is considered safe only if it passes safely through all intermediate steps and reaches the German intelligence department. Therefore, by the multiplication rule, its security level $P$ is the product of the security levels of every transmission of that message, from the headquarters through multiple transfers until it reaches the Germans. For the whole plan, it is successful only when all $K$ messages pass safely through the network and reach the Germans, with none raising suspicion. So the reliability of the plan is the product of the security levels of all messages. Obviously, the reliability depends on how these messages are transmitted in the network. You need a scheme that decides from whom to whom each message should be passed, so that the final reliability is maximized.\n\nYou can use a computer to find the most reliable message transmission plan.", "inputFormat": "The input contains the Allied operational data table.\n\nThe first line contains two integers $N$ and $K$, which are the total number of spies and the total number of messages in the plan.\n\nThe second line contains $2N$ numbers. The first $N$ numbers are real numbers $AS_1,AS_2,\\cdots,AS_N$ (in the range $[0,1]$). The next $N$ numbers are integers $AM_1,AM_2,\\cdots,AM_N$.\n\nThe third line contains $N$ integers. The $i$-th integer ($i = 1,2,\\cdots,N$) is $0$ if spy $i$ does not contact the German intelligence department, and $1$ if spy $i$ does.\n\nStarting from the fourth line, each line contains $4$ numbers in order: the positive integers $i$ and $j$ representing spy IDs, the security parameter $S_{i,j}$ of the contact between spies $i$ and $j$ (a real number in $[0,1]$), and the maximum number of messages $M_{i,j}$ that can be transmitted between $i$ and $j$ (in each line, $i$ is less than $j$).\n\nThe last line is `-1 -1`, which indicates the end of input.", "outputFormat": "Output only one line. This line contains a real number $P$, which is the reliability $P$ of the whole plan, **rounded to $5$ significant digits**.\n\nIf the intelligence network cannot transmit $K$ messages to the Germans at all, then the plan reliability is $0$.\n\n(You may assume that if a plan exists, then its reliability is greater than $10^{-12}$.)", "hint": "$1 \\le N,K \\le 300$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2001] 终极情报网", "background": "", "description": "在最后的诺曼底登陆战开始之前，盟军与德军的情报部门围绕着最终的登陆地点展开了一场规模空前的情报战。 这场情报战中，盟军的战术是利用那些潜伏在敌军内部的双重间谍，将假的登陆消息发布给敌军的情报机关的负责人。那些已经潜入敌后的间谍们都是盟军情报部的精英，忠实可靠；但是如何选择合适的人选，以及最佳的消息传递方法，才能保证假消息能够尽快而且安全准确地传递到德军指挥官们的耳朵里，成了困扰盟军情报部长的最大问题。他需要你的帮助。\n\n以下是情报部长提供的作战资料：\n\n在敌后一共潜伏着我方最优秀的 $N$ 名间谍，分别用数字 $1,2,\\cdots,N$ 编号。在给定的作战时间内，任意两人之间至多只进行一次点对点的双人联系。 我将给你一份表格，表格中将提供任意两位间谍 $i$ 和 $j$ 之间进行联系的安全程度，用一个 $[0,1]$ 的实数 $S_{i,j}$ 表示；以及他们这次联系时，能够互相传递的消息的最大数目，用一个正整数表示 $M_{i,j}$（如果在表格中没有被提及，那么间谍 $i$ 和 $j$ 之间不进行直接联系）。 假消息从盟军总部传递到每个间谍手里的渠道也不是绝对安全，我们用 $[0,1]$ 的实数 $AS_j$ 表示总部与间谍 $j$ 之间进行联系的安全程度，$AM_j $  则表示总部和间谍 $j$ 之间进行联系时传递的消息的最大数目。对于不和总部直接联系的间谍，他的  $AM_j = 0$（而表格中给出的他的 $AS_j$ 是没有意义的）。 当然，假消息从间谍手中交到敌军的情报部官员的办公桌上的过程是绝对安全的，也即是说，间谍与敌军情报部门之间要么不进行直接联系，要么其联系的安全程度是 $1$（即完全可靠）。\n\n现在情报部打算把 $K$ 条假消息“透露”到德军那里。消息先由总部一次性发给 $N$ 名间谍中的一些人，再通过他们之间的情报网传播，最终由这 $N$ 名间谍中的某些将情报送到德军手中。 对于一条消息，只有安全的通过了所有的中转过程到达敌军情报部，这个传递消息的过程才算是安全的；因此根据乘法原理，它的安全程度 $P$ 就是从总部出发，经多次传递直到到达德军那里，每一次传递该消息的安全程度的乘积。 而对于整个计划而言，只有当 $N$ 条消息都安全的通过情报网到达德军手中，没有一条引起怀疑时，才算是成功的。所以计划的可靠程度是所有消息的安全程度的乘积。 显然，计划的可靠性取决于这些消息在情报网中的传递方法。 我需要一个方案，确定消息应该从哪些人手中传递到哪些人手中，使得最终计划的可靠性最大。\n\n你可以利用计算机，来求得这个最可靠的消息传递方案。", "inputFormat": "输入包含了盟军的作战资料表格。\n\n第一行包括两个整数 $N$ 和 $K$ ，分别是间谍的总人数和计划包含的消息总数。\n\n第二行包括 $2N$ 个数，前 $N$ 个数是实数 $AS_1,AS_2,\\cdots,AS_N$ （范围在 $[0,1]$ 以内）；后 $N$ 个数是整数 $AM_1,AM_2,\\cdots,AM_N$ 。\n\n第三行包含了 $N$ 个整数，其中第 $i$（$i = 1,2,\\cdots,N$）个整数如果为 $0$ 表示间谍 $i$ 与德军情报部不进行联系，如果为 $1$ 则表示间谍 $i$ 与德军情报部进行联系。\n\n第四行开始，每行包括 $4$ 个数，依次分别是：代表间谍编号的正整数 $i$ 和 $j$ ，间谍 $i$ 和 $j$ 联系的安全性参数 $S_{i,j}$ ( $[0,1]$ 范围内的实数)，以及 $i,j$ 之间传递的最大消息数 $M_{i,j}$ (每一行的 $i$ 均小于 $j$)。\n\n最后的一行为 `-1 -1` ，表示输入数据的结束。", "outputFormat": "输出只有一行。这一行中包含一个实数 $P$ ，给出的是整个计划的可靠程度 $P$ ，**保留 $5$ 位有效数字**（四舍五入）。\n\n如果情报网根本不能将 $K$ 条消息传到德军手中，那么计划的可靠性为 $0$ 。\n\n(你可以假定，如果计划存在，那么它的可靠性大于 $10^{-12}$)", "hint": "$1 \\le N,K \\le 300$。", "locale": "zh-CN"}}}
{"pid": "P5815", "type": "P", "difficulty": 4, "samples": [["3 4\n1 2 3\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2010", "重庆", "二分", "各省省选"], "title": "[CQOI2010] 扑克牌", "background": "", "description": "你有 $n$ 种牌，第 $i$ 种牌的数目为 $c_i$。另外有一种特殊的牌：joker，它的数目是 $m$。你可以用每种牌各一张来组成一套牌，也可以用一张 joker 和除了某一种牌以外的其他牌各一张组成 $1$ 套牌。比如，当 $n=3$ 时，一共有 $4$ 种合法的套牌：$\\{1,2,3\\}$，$\\{J,2,3\\}$，$\\{1,J,3\\}$，$\\{1,2,J\\}$。\n\n给出 $n$，$m$ 和 $c_i$，你的任务是组成尽量多的套牌。每张牌最多只能用在一副套牌里（可以有牌不使用）。", "inputFormat": "第一行包含两个整数 $n$，$m$，即牌的种数和 joker 的个数。\n\n第二行包含 $n$ 个整数 $c_i$，即每种牌的张数。\n", "outputFormat": "输出仅一个整数，即最多组成的套牌数目。\n", "hint": "**样例说明**\n\n输入数据表明：一共有 $1$ 个 $1$，$2$ 个 $2$，$3$ 个 $3$，$4$ 个 joker。最多可以组成三副套牌：$\\{1,J,3\\}$，$\\{J,2,3\\}$，$\\{J,2,3\\}$，joker 还剩一个，其余牌全部用完。\n\n**数据范围**\n\n对于 $50\\%$ 的数据，$2 \\le n \\le 5$，$0 \\le m \\le 10^6$，$0 \\le c_i \\le 200$。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 50$，$0 \\le m,c_i \\le 5 \\times 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2010] Playing Cards", "background": "", "description": "You have $n$ types of cards. The number of cards of type $i$ is $c_i$. There is also a special card type: joker, and its number is $m$.\n\nYou can form one set of cards by taking one card from each type. You can also form one set by taking one joker and one card from every other type except one specific type. For example, when $n=3$, there are $4$ valid sets in total: $\\{1,2,3\\}$, $\\{J,2,3\\}$, $\\{1,J,3\\}$, $\\{1,2,J\\}$.\n\nGiven $n$, $m$, and $c_i$, your task is to form as many sets as possible. Each card can be used in at most one set (you may leave some cards unused).", "inputFormat": "The first line contains two integers $n$, $m$, representing the number of card types and the number of jokers.\n\nThe second line contains $n$ integers $c_i$, representing the number of cards of each type.", "outputFormat": "Output only one integer: the maximum number of sets that can be formed.", "hint": "**Sample Explanation**\n\nThe input shows that there are $1$ card of type $1$, $2$ cards of type $2$, $3$ cards of type $3$, and $4$ jokers. At most three sets can be formed: $\\{1,J,3\\}$, $\\{J,2,3\\}$, $\\{J,2,3\\}$. One joker remains, and all other cards are used up.\n\n**Constraints**\n\nFor $50\\%$ of the testdata, $2 \\le n \\le 5$, $0 \\le m \\le 10^6$, $0 \\le c_i \\le 200$.\n\nFor $100\\%$ of the testdata, $2 \\le n \\le 50$, $0 \\le m,c_i \\le 5 \\times 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2010] 扑克牌", "background": "", "description": "你有 $n$ 种牌，第 $i$ 种牌的数目为 $c_i$。另外有一种特殊的牌：joker，它的数目是 $m$。你可以用每种牌各一张来组成一套牌，也可以用一张 joker 和除了某一种牌以外的其他牌各一张组成 $1$ 套牌。比如，当 $n=3$ 时，一共有 $4$ 种合法的套牌：$\\{1,2,3\\}$，$\\{J,2,3\\}$，$\\{1,J,3\\}$，$\\{1,2,J\\}$。\n\n给出 $n$，$m$ 和 $c_i$，你的任务是组成尽量多的套牌。每张牌最多只能用在一副套牌里（可以有牌不使用）。", "inputFormat": "第一行包含两个整数 $n$，$m$，即牌的种数和 joker 的个数。\n\n第二行包含 $n$ 个整数 $c_i$，即每种牌的张数。\n", "outputFormat": "输出仅一个整数，即最多组成的套牌数目。\n", "hint": "**样例说明**\n\n输入数据表明：一共有 $1$ 个 $1$，$2$ 个 $2$，$3$ 个 $3$，$4$ 个 joker。最多可以组成三副套牌：$\\{1,J,3\\}$，$\\{J,2,3\\}$，$\\{J,2,3\\}$，joker 还剩一个，其余牌全部用完。\n\n**数据范围**\n\n对于 $50\\%$ 的数据，$2 \\le n \\le 5$，$0 \\le m \\le 10^6$，$0 \\le c_i \\le 200$。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 50$，$0 \\le m,c_i \\le 5 \\times 10^8$。", "locale": "zh-CN"}}}
{"pid": "P5816", "type": "P", "difficulty": 5, "samples": [["4\n0 2\n2 0\n-2 0\n0 -2\n", "5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "重庆", "各省省选"], "title": "[CQOI2010] 内部白点", "background": "", "description": "无限大正方形网格里有 $n$ 个黑色的顶点，所有其他顶点都是白色的（网格的顶点即坐标为整数的点，又称整点）。每秒钟，所有内部白点同时变黑，直到不存在内部白点为止。你的任务是统计最后网格中的黑点个数。\n\n内部白点的定义：一个白色的整点 $P(x,y)$ 是内部白点当且仅当 $P$ 在水平线的左边和右边各至少有一个黑点（即存在$x_1 < x < x_2$ 使得 $(x_1,y)$ 和 $(x_2,y)$ 都是黑点），且在竖直线的上边和下边各至少有一个黑点（即存在 $y_1 < y < y_2$ 使得 $(x,y_1)$ 和 $(x,y_2)$ 都是黑点）。", "inputFormat": "输入第一行包含一个整数 $n$，即初始黑点个数。\n\n以下 $n$ 行每行包含两个整数 $x$，$y$，即一个黑点的坐标。没有两个黑点的坐标相同，坐标的绝对值均不超过 $10^9$。", "outputFormat": "输出仅一行，包含黑点的最终数目。\n\n如果变色过程永不终止，输出`-1`。\n", "hint": "**数据范围**\n\n对于 $36\\%$ 的数据，$n \\le 500$。\n\n对于 $64\\%$ 的数据，$n \\le 3 \\times 10^4$。\n\n对于 $100\\%$ 的数据，$n \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2010] Internal White Points", "background": "", "description": "On an infinite square grid, there are $n$ black vertices, and all other vertices are white (grid vertices are points with integer coordinates, also called lattice points). Every second, all internal white points turn black simultaneously, until there are no internal white points left. Your task is to count the number of black points in the grid at the end.\n\nDefinition of an internal white point: a white lattice point $P(x,y)$ is an internal white point if and only if there is at least one black point to the left and to the right of $P$ on the same horizontal line (i.e., there exist $x_1 < x < x_2$ such that $(x_1,y)$ and $(x_2,y)$ are both black), and at least one black point above and below $P$ on the same vertical line (i.e., there exist $y_1 < y < y_2$ such that $(x,y_1)$ and $(x,y_2)$ are both black).", "inputFormat": "The first line contains an integer $n$, the number of initial black points.\n\nThe next $n$ lines each contain two integers $x$, $y$, the coordinates of a black point. No two black points have the same coordinates, and the absolute value of each coordinate does not exceed $10^9$.", "outputFormat": "Output one line containing the final number of black points.\n\nIf the recoloring process never terminates, output `-1`.", "hint": "**Constraints**\n\nFor $36\\%$ of the testdata, $n \\le 500$.\n\nFor $64\\%$ of the testdata, $n \\le 3 \\times 10^4$.\n\nFor $100\\%$ of the testdata, $n \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2010] 内部白点", "background": "", "description": "无限大正方形网格里有 $n$ 个黑色的顶点，所有其他顶点都是白色的（网格的顶点即坐标为整数的点，又称整点）。每秒钟，所有内部白点同时变黑，直到不存在内部白点为止。你的任务是统计最后网格中的黑点个数。\n\n内部白点的定义：一个白色的整点 $P(x,y)$ 是内部白点当且仅当 $P$ 在水平线的左边和右边各至少有一个黑点（即存在$x_1 < x < x_2$ 使得 $(x_1,y)$ 和 $(x_2,y)$ 都是黑点），且在竖直线的上边和下边各至少有一个黑点（即存在 $y_1 < y < y_2$ 使得 $(x,y_1)$ 和 $(x,y_2)$ 都是黑点）。", "inputFormat": "输入第一行包含一个整数 $n$，即初始黑点个数。\n\n以下 $n$ 行每行包含两个整数 $x$，$y$，即一个黑点的坐标。没有两个黑点的坐标相同，坐标的绝对值均不超过 $10^9$。", "outputFormat": "输出仅一行，包含黑点的最终数目。\n\n如果变色过程永不终止，输出`-1`。\n", "hint": "**数据范围**\n\n对于 $36\\%$ 的数据，$n \\le 500$。\n\n对于 $64\\%$ 的数据，$n \\le 3 \\times 10^4$。\n\n对于 $100\\%$ 的数据，$n \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5817", "type": "P", "difficulty": 5, "samples": [["4\n1\n2\n5\n4\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2011", "重庆", "各省省选"], "title": "[CQOI2011] 分金币", "background": "", "description": "圆桌上坐着 $n$ 个人，每人有一定数量的金币，金币总数能被 $n$ 整除。每个人可以给他左右相邻的人一些金币，最终使\n得每个人的金币数目相等。\n\n你的任务是求出被转手的金币数量的最小值。", "inputFormat": "第一行为整数 $n$（$ n \\ge 3$）。\n\n以下 $n$ 行每行一个正整数，按逆时针顺序给出每个人拥有的金币数。\n", "outputFormat": "共一行，输出被转手金币数量的最小值。", "hint": "**样例说明**\n\n设四个人编号为 $1,2,3,4$。第 $3$ 个人给第 $2$ 个人 $2$ 个金币（变成 $1,4,3,4$），第 $2$ 个人和第 $4$ 个人分别给第 $1$ 个人 $1$ 个金币。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，$3 \\le n \\le 10^5$，$总金币数 \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2011] Distributing Gold Coins", "background": "", "description": "There are $n$ people sitting around a round table. Each person has some number of gold coins, and the total number of coins is divisible by $n$. Each person can give some coins to their left and right neighbors, and in the end everyone must have the same number of coins.\n\nYour task is to find the minimum total number of coins that are passed from hand to hand.", "inputFormat": "The first line contains an integer $n$ ($n \\ge 3$).\n\nThe next $n$ lines each contain a positive integer, given in counterclockwise order, representing the number of coins each person has.", "outputFormat": "Output one line containing the minimum total number of coins that are passed from hand to hand.", "hint": "**Sample Explanation**\n\nSuppose the four people are numbered $1,2,3,4$. Person $3$ gives person $2$ $2$ coins (becoming $1,4,3,4$). Then person $2$ and person $4$ each give person $1$ $1$ coin.\n\n**Constraints**\n\nFor $100\\%$ of the testdata, $3 \\le n \\le 10^5$, and $total$ $coins \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2011] 分金币", "background": "", "description": "圆桌上坐着 $n$ 个人，每人有一定数量的金币，金币总数能被 $n$ 整除。每个人可以给他左右相邻的人一些金币，最终使\n得每个人的金币数目相等。\n\n你的任务是求出被转手的金币数量的最小值。", "inputFormat": "第一行为整数 $n$（$ n \\ge 3$）。\n\n以下 $n$ 行每行一个正整数，按逆时针顺序给出每个人拥有的金币数。\n", "outputFormat": "共一行，输出被转手金币数量的最小值。", "hint": "**样例说明**\n\n设四个人编号为 $1,2,3,4$。第 $3$ 个人给第 $2$ 个人 $2$ 个金币（变成 $1,4,3,4$），第 $2$ 个人和第 $4$ 个人分别给第 $1$ 个人 $1$ 个金币。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，$3 \\le n \\le 10^5$，$总金币数 \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5818", "type": "P", "difficulty": 7, "samples": [["10 10 66103", "475"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "江苏"], "title": "[JSOI2011] 同分异构体计数", "background": "", "description": "Antonio 最近对有机化学比较感兴趣，他想请你帮助他快速计算出某种烃类的同分异构体的数目。 \n\n为了表述方便，我们作出如下定义： \n- 环烷烃： 具有 $n$ 个碳原子的环烷烃可以表示成一张具有 $n$ 个顶点 $n$ 条边的无向连通简单图(基环+外向树)。每个顶点的度数不超过 $4$。 \n- M-环烷烃：至多有 $m$ 个顶点在环上的环烷烃。（注意环上至少有 $3$ 个顶点，因为任意两个顶点之间至多只能有 $1$ 条边）。 \n- 同构：假设结构 $A$ 和结构 $B$ 均具有 $n$ 个碳原子，$A$ 和 $B$ 同构当且仅当能够对 $A$ 和 $B$ 中的每个碳原子都按照 $1~n$ 编号，使得对于编号为 $v_1$ 和 $v_2$ 的两个碳原子，他们在 $A$ 中存在边相连当且仅当他们在 $B$ 中存在边相连。（换言之，$A$ 和 $B$ 对应的图同构）。\n \n现在，给出 $n$，$m$，Antonio 希望你帮助他统计有多少种互不同构的含有 $n$ 个碳原子的 M-环烷烃。由于这个数量可能很大，你只需要输出它对 $p$ 的余数。（$p$ 是一个素数）。 \n\n在本题中，我们不考虑某结构在化学上是否能够稳定存在，也不考虑其他的异构方式。", "inputFormat": "输入文件只有一行，用空格隔开的三个整数 $n$，$m$，$p$ 。\n\n", "outputFormat": "输出文件有且仅有一行，表示具有 $n$ 个碳原子的互不同构的M-环烷烃 的数量，对 $p$ 取模。", "hint": "**数据范围**\n\n$3 \\le n \\le 1000$，$3 \\le m \\le 50$，$m \\le n$，$10^4 \\le p \\le 2 \\times 10^9$，保证 $p$ 为素数。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2011] Counting Structural Isomers", "background": "", "description": "Antonio has recently become interested in organic chemistry, and he wants you to help him quickly compute the number of structural isomers of a certain type of hydrocarbon.\n\nFor convenience, we define the following:\n\n- Cycloalkane: A cycloalkane with $n$ carbon atoms can be represented as an undirected connected simple graph with $n$ vertices and $n$ edges (a base cycle plus outward trees). The degree of each vertex is at most $4$.\n- M-cycloalkane: A cycloalkane in which at most $m$ vertices lie on the cycle. (Note that the cycle must contain at least $3$ vertices, because between any two vertices there can be at most $1$ edge.)\n- Isomorphism: Suppose structures $A$ and $B$ both have $n$ carbon atoms. $A$ and $B$ are isomorphic if and only if we can label every carbon atom in both $A$ and $B$ with numbers $1 \\sim n$ such that for two carbon atoms labeled $v_1$ and $v_2$, there is an edge between them in $A$ if and only if there is an edge between them in $B$. (In other words, the corresponding graphs of $A$ and $B$ are isomorphic.)\n\nNow, given $n$ and $m$, Antonio wants you to count how many pairwise non-isomorphic M-cycloalkanes with $n$ carbon atoms there are. Since this number may be very large, you only need to output it modulo $p$ ($p$ is a prime).\n\nIn this problem, we do not consider whether a structure can exist stably in chemistry, and we do not consider other types of isomerism.", "inputFormat": "The input contains only one line with three integers $n$, $m$, and $p$, separated by spaces.", "outputFormat": "Output exactly one line: the number of pairwise non-isomorphic M-cycloalkanes with $n$ carbon atoms, modulo $p$.", "hint": "**Constraints**\n\n$3 \\le n \\le 1000$, $3 \\le m \\le 50$, $m \\le n$, $10^4 \\le p \\le 2 \\times 10^9$, and $p$ is guaranteed to be prime.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2011] 同分异构体计数", "background": "", "description": "Antonio 最近对有机化学比较感兴趣，他想请你帮助他快速计算出某种烃类的同分异构体的数目。 \n\n为了表述方便，我们作出如下定义： \n- 环烷烃： 具有 $n$ 个碳原子的环烷烃可以表示成一张具有 $n$ 个顶点 $n$ 条边的无向连通简单图(基环+外向树)。每个顶点的度数不超过 $4$。 \n- M-环烷烃：至多有 $m$ 个顶点在环上的环烷烃。（注意环上至少有 $3$ 个顶点，因为任意两个顶点之间至多只能有 $1$ 条边）。 \n- 同构：假设结构 $A$ 和结构 $B$ 均具有 $n$ 个碳原子，$A$ 和 $B$ 同构当且仅当能够对 $A$ 和 $B$ 中的每个碳原子都按照 $1~n$ 编号，使得对于编号为 $v_1$ 和 $v_2$ 的两个碳原子，他们在 $A$ 中存在边相连当且仅当他们在 $B$ 中存在边相连。（换言之，$A$ 和 $B$ 对应的图同构）。\n \n现在，给出 $n$，$m$，Antonio 希望你帮助他统计有多少种互不同构的含有 $n$ 个碳原子的 M-环烷烃。由于这个数量可能很大，你只需要输出它对 $p$ 的余数。（$p$ 是一个素数）。 \n\n在本题中，我们不考虑某结构在化学上是否能够稳定存在，也不考虑其他的异构方式。", "inputFormat": "输入文件只有一行，用空格隔开的三个整数 $n$，$m$，$p$ 。\n\n", "outputFormat": "输出文件有且仅有一行，表示具有 $n$ 个碳原子的互不同构的M-环烷烃 的数量，对 $p$ 取模。", "hint": "**数据范围**\n\n$3 \\le n \\le 1000$，$3 \\le m \\le 50$，$m \\le n$，$10^4 \\le p \\le 2 \\times 10^9$，保证 $p$ 为素数。", "locale": "zh-CN"}}}
{"pid": "P5819", "type": "P", "difficulty": 6, "samples": [["5 6\n1 0.0 10.0\n1.5 0.0 10.0\n2.0 0.0 10.0\n2.5 0.0 10.0\n3.0 0.0 10.0\n0.0 5.0\n0.4 5.0\n1.3 5.0\n2.0 5.0\n2.7 5.0\n3.6 5.0", "1 2 2 3"], ["4 2\n0.1 0.0 3.0\n0.1 2.0 4.0\n0.0 3.0 8.0\n0.6 1.0 6.0\n0.6 6.0\n0.0 2.5", "3 0 1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "洛谷原创"], "title": "【L&K R-03】音游大计算", "background": "", "description": "小 K 喜欢玩音游，特别是一款叫做 dimou 的音游。dimou 的判定机制是这样的：dimou 是单面（不像某 dy 开头的东西）下落式音游。具体来说，在屏幕底端有一条判定线。一首曲子有若干打击点（即 key，可以看做一条与判定线平行的只有左右宽度的线段），每个 key 会在某个时刻从顶端匀速下落，而玩家需要尽量精准地在每个 key 与判定线重合时点击它。\n\n当然，玩家有可能在 key 接触判定线之前就点击了，也可能在 key 已经落到判定线之下时才点击。这时候，就需要考虑游戏的判定系统，以统计玩家完成一首曲子的情况。dimou 有三种判定：perfect，good 和 miss。总共有六种情况——\n\n情况 $1$：玩家点击的时间在某个 key 下落至其与判定线重合的时间的前 $1s$ 或更多（记为 $\\triangle t\\ge1$，下同），则不会产生任何判定效果（等于无意义点击）；\n\n情况 $2$：$0.6\\le\\triangle t<1$，则此 key 产生一次 miss 判定并消失；\n\n情况 $3$：$0.2\\le\\triangle t<0.6$，则此 key 产生一次 good 判定并消失；\n\n情况 $4$：$-0.2<\\triangle t<0.2$（负数代表在 key 到达判定线之后点击），则此 key 产生一次 perfect 判定并消失；\n\n情况 $5$：$-0.6<\\triangle t\\le-0.2$，则此 key 产生一次 good 判定并消失；\n\n情况 $6$：$\\triangle t\\le-0.6$，则此 key 在点击之前就会落出屏幕，记一次 miss 判定并消失（即在此 key 落于判定线之下 $0.6s$ 后自己产生一次 miss 判定），点击对此 key 不会产生任何判定效果。\n\n除此之外，dimou 还有最大连击判定（max combo）。一段连击（combo）是指从某一个非 miss 的判定开始，到某一个非 miss 的判定结束（在这段区间内 **（按时间顺序）** 没有任何 miss 判定），判定的总数量。而 max combo 则指的是所有 combo 的最大值。\n\n除此之外，dimou 还有一些判定规则。一次点击的位置可以看做判定线上的一个点，则过此点作判定线的垂线，只有与此垂线有交点（交点可在端点）的 key 才**可能**因此次点击产生判定效果。并且， **每次点击只会对可能产生判定效果的 key 中位置（纵向高度）最低（离屏幕顶端最远）的一个产生判定效果。** 形象地说，你只有点击某个 key 下方的位置才可能将其消除，并且若两个 key 有上下相对距离地一起下落，那么如果点击可以使下面的 key 消除，则一定不会使上面的 key 消除。特殊地，如果一次点击对两个或以上位置（高度）相同的 key 都可能产生判定效果，且没有更低的可能产生判定效果的 key，则这些 key 都会被消除。\n\n为了把一首曲子打好，小 K 决定背谱，即记住所有 key 的位置和它们下落到判定线的时间。当然，小 K 也会事先决定好自己的打法，即决定在什么时间在什么位置点击。可是小 K 并不会计算自己的打法可以得到的最终成绩。请你帮小 K 算算，他的打法会得到多少 perfect 判定，多少 good 判定，多少 miss 判定，以及 max combo。\n\n注意：小 K 不会在同一时间点击两次或以上。如果同一时间有多个判定，按 miss，good，perfect 的顺序依次处理。", "inputFormat": "第一行两个正整数 $n,m$，代表 key 数量与小 K 的点击数。\n\n紧接着 $n$ 行，每行三个浮点数（小数位数不超过 $5$ 位）$t_i,a_i,b_i$，分别表示每个 key 从曲子开始算起到达判定线的时间，其左端点位置，右端点位置。\n\n紧接着 $m$ 行，每行两个浮点数（小数位数不超过 $5$ 位）$T_i,x_i$，分别表示小 K 每次点击从曲子开始算起的时间和其位置。", "outputFormat": "一行，输出四个非负整数，两两用单个空格隔开，分别代表 perfect 数，good 数，miss 数和 max combo。", "hint": "样例 $3$：[输入](https://www.luogu.com.cn/paste/qrbt8fnq)，[输出](https://www.luogu.com.cn/paste/evke45h8)。\n\n样例 $4$：[输入](https://www.luogu.com.cn/paste/a71namso)，[输出](https://www.luogu.com.cn/paste/jgpcani2)。\n\n【样例解释】\n\n对于样例 $1$：$5$ 个 key 产生的判定按时间顺序分别为 \n miss，good，perfect，good，miss。第一次和最后一次点击不产生判定效果。\n\n对于样例 $2$：按时间顺序，第一次点击（$T=0.0$），可能产生判定效果的有（按输入顺序）第 $1,2,4$ 个 key。第 $1,2$ 个 key 同时到达判定线，第 $4$ 个 key 比第 $1,2$ 个 key 高。因此第一次点击只让第 $1,2$ 个 key 产生 perfect 判定。第二次点击（$T=0.6$），与其垂线有交点的有第 $3,4$ 个 key，但第 $3$ 个 key 此时已经产生 miss 判定并消失，因此这次点击让第 $4$ 个 key 产生一次 perfect 判定，此时在同一时间出现了两个判定 perfect，miss，按照规则先处理 miss 再处理 perfect。所以，所有判定按时间顺序分别是 perfect，perfect，miss，perfect。容易发现 miss 把判定序列分成了两段，第一段的 combo 为 $2$，第二段的 combo 为 $1$，所以 max combo 为 $2$。\n\n【数据范围】\n\n对于 $30\\%$ 数据，$n,m\\le5000$。\n\n对于另外 $20\\%$ 数据，$n\\le5000$，$m\\le114514$。\n\n对于另外 $10\\%$ 数据，所有 $a_i$ 相等，所有 $b_i$ 相等。\n\n对于另外 $10\\%$ 数据，$t_i,T_i,a_i,b_i,x_i$ 在 $[0,10^4]$ 中随机生成。\n\n对于 $100\\%$ 数据，$1\\le n,m\\le114514$，$0\\le t_i,T_i,a_i,b_i,x_i\\le 10^4$，$a_i\\le b_i$。", "locale": "zh-CN", "translations": {"en": {"title": "[L&K R-03] Rhythm Game Big Calculation.", "background": "", "description": "Xiao K likes playing rhythm games, especially one called dimou. The judgment system of dimou works like this: dimou is a single-sided falling rhythm game (unlike something starting with “dy”). Specifically, there is a judgment line at the bottom of the screen. A song has several hit objects (called keys; you can think of each as a line segment parallel to the judgment line, with only left-right width). Each key falls from the top at a constant speed at some time, and the player needs to click it as accurately as possible when it overlaps the judgment line.\n\nOf course, the player may click before a key touches the judgment line, or click only after the key has already fallen below the judgment line. In that case, we need to consider the game’s judgment system to count how the player finishes the song. dimou has three judgments: perfect, good, and miss. There are six cases in total.\n\nCase $1$: If the click time is $1s$ or more before the time when some key falls to overlap the judgment line (denote this as $\\triangle t\\ge1$, same below), then no judgment effect is produced (equivalent to a meaningless click).\n\nCase $2$: If $0.6\\le\\triangle t<1$, then this key produces one miss judgment and disappears.\n\nCase $3$: If $0.2\\le\\triangle t<0.6$, then this key produces one good judgment and disappears.\n\nCase $4$: If $-0.2<\\triangle t<0.2$ (a negative value means clicking after the key reaches the judgment line), then this key produces one perfect judgment and disappears.\n\nCase $5$: If $-0.6<\\triangle t\\le-0.2$, then this key produces one good judgment and disappears.\n\nCase $6$: If $\\triangle t\\le-0.6$, then this key will have already fallen out of the screen before the click, counting as one miss judgment and disappearing (that is, it produces one miss judgment by itself after it has been below the judgment line for $0.6s$). Clicking has no judgment effect on this key.\n\nIn addition, dimou has a maximum combo statistic (max combo). A combo segment is the total number of judgments from some non-miss judgment to some non-miss judgment (within this interval, in **time order**, there is no miss judgment). max combo is the maximum value among all combos.\n\nBesides, dimou has some additional rules. The position of a click can be considered as a point on the judgment line. Draw the perpendicular line to the judgment line through this point; only keys that intersect this perpendicular line (the intersection may be at an endpoint) **may** produce a judgment effect due to this click. Moreover, **each click only produces a judgment effect on the one key among those that may produce an effect whose position (vertical height) is the lowest (farthest from the top of the screen).** Intuitively, you can only remove a key by clicking somewhere below it, and if two keys fall together with some vertical distance between them, then if a click can remove the lower key, it will definitely not remove the upper key. Specially, if one click may produce a judgment effect on two or more keys with the same position (height), and there is no lower key that may produce a judgment effect, then all these keys will be removed.\n\nTo play a song well, Xiao K decides to memorize the chart, i.e., remember the position of every key and the time when it falls to the judgment line. Of course, Xiao K will also decide his play plan in advance, i.e., decide at what time and at what position to click. But Xiao K cannot compute the final score his plan will get. Please help Xiao K calculate how many perfect judgments, how many good judgments, how many miss judgments, and the max combo he will obtain.\n\nNote: Xiao K will not click two or more times at the same time. If there are multiple judgments at the same time, process them in the order miss, good, perfect.", "inputFormat": "The first line contains two positive integers $n,m$, representing the number of keys and the number of clicks by Xiao K.\n\nThen follow $n$ lines, each containing three floating-point numbers (with at most $5$ digits after the decimal point) $t_i,a_i,b_i$, representing, for each key, the time from the start of the song to when it reaches the judgment line, its left endpoint position, and its right endpoint position.\n\nThen follow $m$ lines, each containing two floating-point numbers (with at most $5$ digits after the decimal point) $T_i,x_i$, representing the time from the start of the song for each click and its position.", "outputFormat": "Output one line with four non-negative integers, separated pairwise by a single space, representing the number of perfect, the number of good, the number of miss, and the max combo.", "hint": "Sample $3$: [input](https://www.luogu.com.cn/paste/qrbt8fnq), [output](https://www.luogu.com.cn/paste/evke45h8).\n\nSample $4$: [input](https://www.luogu.com.cn/paste/a71namso), [output](https://www.luogu.com.cn/paste/jgpcani2).\n\n[Sample Explanation]\n\nFor sample $1$: The judgments produced by the $5$ keys, in time order, are miss, good, perfect, good, miss. The first and the last click do not produce any judgment effect.\n\nFor sample $2$: In time order, for the first click ($T=0.0$), the keys that may produce a judgment effect are keys $1,2,4$ (in input order). Keys $1,2$ reach the judgment line at the same time, and key $4$ is higher than keys $1,2$. Therefore, the first click only makes keys $1,2$ produce perfect judgments. For the second click ($T=0.6$), the keys intersecting its perpendicular line are keys $3,4$, but key $3$ has already produced a miss judgment and disappeared, so this click makes key $4$ produce one perfect judgment. At this time, there are two judgments at the same time: perfect and miss. According to the rule, process miss before perfect. Therefore, all judgments in time order are perfect, perfect, miss, perfect. It is easy to see that the miss splits the judgment sequence into two segments: the first segment has a combo of $2$, the second segment has a combo of $1$, so max combo is $2$.\n\n[Constraints]\n\nFor $30\\%$ of the data, $n,m\\le5000$.\n\nFor another $20\\%$ of the data, $n\\le5000$, $m\\le114514$.\n\nFor another $10\\%$ of the data, all $a_i$ are equal, and all $b_i$ are equal.\n\nFor another $10\\%$ of the data, $t_i,T_i,a_i,b_i,x_i$ are randomly generated in $[0,10^4]$.\n\nFor $100\\%$ of the data, $1\\le n,m\\le114514$, $0\\le t_i,T_i,a_i,b_i,x_i\\le 10^4$, and $a_i\\le b_i$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【L&K R-03】音游大计算", "background": "", "description": "小 K 喜欢玩音游，特别是一款叫做 dimou 的音游。dimou 的判定机制是这样的：dimou 是单面（不像某 dy 开头的东西）下落式音游。具体来说，在屏幕底端有一条判定线。一首曲子有若干打击点（即 key，可以看做一条与判定线平行的只有左右宽度的线段），每个 key 会在某个时刻从顶端匀速下落，而玩家需要尽量精准地在每个 key 与判定线重合时点击它。\n\n当然，玩家有可能在 key 接触判定线之前就点击了，也可能在 key 已经落到判定线之下时才点击。这时候，就需要考虑游戏的判定系统，以统计玩家完成一首曲子的情况。dimou 有三种判定：perfect，good 和 miss。总共有六种情况——\n\n情况 $1$：玩家点击的时间在某个 key 下落至其与判定线重合的时间的前 $1s$ 或更多（记为 $\\triangle t\\ge1$，下同），则不会产生任何判定效果（等于无意义点击）；\n\n情况 $2$：$0.6\\le\\triangle t<1$，则此 key 产生一次 miss 判定并消失；\n\n情况 $3$：$0.2\\le\\triangle t<0.6$，则此 key 产生一次 good 判定并消失；\n\n情况 $4$：$-0.2<\\triangle t<0.2$（负数代表在 key 到达判定线之后点击），则此 key 产生一次 perfect 判定并消失；\n\n情况 $5$：$-0.6<\\triangle t\\le-0.2$，则此 key 产生一次 good 判定并消失；\n\n情况 $6$：$\\triangle t\\le-0.6$，则此 key 在点击之前就会落出屏幕，记一次 miss 判定并消失（即在此 key 落于判定线之下 $0.6s$ 后自己产生一次 miss 判定），点击对此 key 不会产生任何判定效果。\n\n除此之外，dimou 还有最大连击判定（max combo）。一段连击（combo）是指从某一个非 miss 的判定开始，到某一个非 miss 的判定结束（在这段区间内 **（按时间顺序）** 没有任何 miss 判定），判定的总数量。而 max combo 则指的是所有 combo 的最大值。\n\n除此之外，dimou 还有一些判定规则。一次点击的位置可以看做判定线上的一个点，则过此点作判定线的垂线，只有与此垂线有交点（交点可在端点）的 key 才**可能**因此次点击产生判定效果。并且， **每次点击只会对可能产生判定效果的 key 中位置（纵向高度）最低（离屏幕顶端最远）的一个产生判定效果。** 形象地说，你只有点击某个 key 下方的位置才可能将其消除，并且若两个 key 有上下相对距离地一起下落，那么如果点击可以使下面的 key 消除，则一定不会使上面的 key 消除。特殊地，如果一次点击对两个或以上位置（高度）相同的 key 都可能产生判定效果，且没有更低的可能产生判定效果的 key，则这些 key 都会被消除。\n\n为了把一首曲子打好，小 K 决定背谱，即记住所有 key 的位置和它们下落到判定线的时间。当然，小 K 也会事先决定好自己的打法，即决定在什么时间在什么位置点击。可是小 K 并不会计算自己的打法可以得到的最终成绩。请你帮小 K 算算，他的打法会得到多少 perfect 判定，多少 good 判定，多少 miss 判定，以及 max combo。\n\n注意：小 K 不会在同一时间点击两次或以上。如果同一时间有多个判定，按 miss，good，perfect 的顺序依次处理。", "inputFormat": "第一行两个正整数 $n,m$，代表 key 数量与小 K 的点击数。\n\n紧接着 $n$ 行，每行三个浮点数（小数位数不超过 $5$ 位）$t_i,a_i,b_i$，分别表示每个 key 从曲子开始算起到达判定线的时间，其左端点位置，右端点位置。\n\n紧接着 $m$ 行，每行两个浮点数（小数位数不超过 $5$ 位）$T_i,x_i$，分别表示小 K 每次点击从曲子开始算起的时间和其位置。", "outputFormat": "一行，输出四个非负整数，两两用单个空格隔开，分别代表 perfect 数，good 数，miss 数和 max combo。", "hint": "样例 $3$：[输入](https://www.luogu.com.cn/paste/qrbt8fnq)，[输出](https://www.luogu.com.cn/paste/evke45h8)。\n\n样例 $4$：[输入](https://www.luogu.com.cn/paste/a71namso)，[输出](https://www.luogu.com.cn/paste/jgpcani2)。\n\n【样例解释】\n\n对于样例 $1$：$5$ 个 key 产生的判定按时间顺序分别为 \n miss，good，perfect，good，miss。第一次和最后一次点击不产生判定效果。\n\n对于样例 $2$：按时间顺序，第一次点击（$T=0.0$），可能产生判定效果的有（按输入顺序）第 $1,2,4$ 个 key。第 $1,2$ 个 key 同时到达判定线，第 $4$ 个 key 比第 $1,2$ 个 key 高。因此第一次点击只让第 $1,2$ 个 key 产生 perfect 判定。第二次点击（$T=0.6$），与其垂线有交点的有第 $3,4$ 个 key，但第 $3$ 个 key 此时已经产生 miss 判定并消失，因此这次点击让第 $4$ 个 key 产生一次 perfect 判定，此时在同一时间出现了两个判定 perfect，miss，按照规则先处理 miss 再处理 perfect。所以，所有判定按时间顺序分别是 perfect，perfect，miss，perfect。容易发现 miss 把判定序列分成了两段，第一段的 combo 为 $2$，第二段的 combo 为 $1$，所以 max combo 为 $2$。\n\n【数据范围】\n\n对于 $30\\%$ 数据，$n,m\\le5000$。\n\n对于另外 $20\\%$ 数据，$n\\le5000$，$m\\le114514$。\n\n对于另外 $10\\%$ 数据，所有 $a_i$ 相等，所有 $b_i$ 相等。\n\n对于另外 $10\\%$ 数据，$t_i,T_i,a_i,b_i,x_i$ 在 $[0,10^4]$ 中随机生成。\n\n对于 $100\\%$ 数据，$1\\le n,m\\le114514$，$0\\le t_i,T_i,a_i,b_i,x_i\\le 10^4$，$a_i\\le b_i$。", "locale": "zh-CN"}}}
{"pid": "P5820", "type": "P", "difficulty": 5, "samples": [["2\n1 1 1 1 1 1\n1 1 1 2 2 2", "YES\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "洛谷原创"], "title": "【L&K R-03】射击场决战", "background": "", "description": "【如果不想看题面请阅读分割线以下部分】\n\n小 L 与小 K 是两个帮派的首领，也是死敌。某年某月，两个帮派发生了大规模的冲突。小 K 因为实力不敌，被小 L 的爪牙团团包围，最终被逼近了一个大型射击场。小 K 自知大势已去，正准备与小 L 拼死一战时，却传来消息，说小 L 要邀请自己与他来玩一场游戏。小 K 知道其中有鬼，但却别无它计，只能只身前往小 L 指定的会面点。\n\n会面点在射击场旁。小 L 站在场上，满脸笑容地对走来的小 K 招手。“啊，小 K ，好久不见。我记得上次我们见面的时候，还是在那个小酒馆。当时，我与你谈笑风生，指点江山，不亦乐乎。没想到，如今，我们竟到此地步啊！”小 L 顿了顿，继续说道：“你是我曾经的兄弟，我不想以暴力的方式了解你我。正好，我有一个好方法：不如我们用游戏的方式来场决战吧！这样如何，小 K ？”小 K 知道，自己并没有否定小 L 的余地。于是，小 K 点了点头。小 L 看到小 K 点头，又露出了笑容，开始讲起了游戏的规则。\n\n“如你所见，我们的游戏要在这片射击场上进行。射击场总共有 $n$ 行 $m$  列，共 $n\\times m$ 个靶。为了方便，取行的方向为左右，列的方向为前后。这个射击场有一个特点：每个靶上都有一个计数器。击中一个靶，这个靶的计数器示数就会加一。但是，每个靶的示数有一个范围，只能是不小于 $0$，不大于 $k$ 的整数。倘若击中一个靶，而在未击中此靶前此靶计数器的示数已经为 $k$，那么击中时，此靶计数器示数就会溢出清 $0$，并产生溢出错误的信号，经电线开始传递。由于靶场电线的特殊布置，信号只会往右侧传递。信号传递过程中会影响若干其它同行靶的计数器。如果这些被影响到的靶计数器示数为 $k$，其同样会溢出清 $0$ 并产生溢出错误信号，与之前的信号叠加（但加一效果不会叠加）；否则，其示数会加一，并发出纠正讯息，截断信号传播，即在其右侧的靶不会继续被信号影响。当然，如果信号一直传递而未被截断，那么它最终会传入信息管理终端。由于信号在传递过程中不断叠加，再加之信息管理终端要处理庞大的信息，纠正错误信号的能力较差，可能会导致终端死机甚至发生爆炸的危险，这是违规的。\n\n“我与你会轮流选择其中一个靶进行一次射击，射击哪个靶由射击者自行决定。如果轮到某个人射击，但他无法进行不违规的射击，那么他就输了。因为这是我设计的游戏，先手当然是我。但是，我也会给你一些选择。靶场上每个靶计数器的初始示数不一定为 $0$，是可以被我设置的。我这里恰好有几种设置方案，但我不知道该选哪种好，可否请你帮我选一选？”\n\n小 L 从口袋里抽出了几张纸条。小 K 一看，每张纸条却没有写每个靶计数器的初始示数，只写着三个数字 $a,b,c$。小 L 所不知道的是，小 K 有着惊人的观察能力，在小 L 讲刚才那一番话之时，小 K 就已经通过分析靶上示数的变化以及电路的布置，得出了计数器初始示数生成的规律。靶场上靶的计数器初始示数是一个个按顺序生成的。并且，生成的顺序是按行优先，从左到右，从上到下。具体来说，是按照第 $1$ 行第 $1,2,\\ldots ,m$ 个，第 $2$ 行第 $1,2,\\ldots ,m$ 个，……，第 $n$ 行第 $1,2,\\ldots ,m$ 个的顺序生成。生成一个计数器的示数需要用到 $a,b,c$ 作为参数。并且，每生成一个计数器的示数，$a,b,c$ 都会产生变化。具体来说，每生成一个计数器的示数，便引用一次以下的函数：\n\n```\ntypedef unsigned long long ull; \ninline ull generate(ull&a,ull&b,ull&c,ull&k)\n{ \n\ta<<=19;a+=b+c;\n\ta<<=26;a^=c+=a+81;b--;\n\ta<<=7;a>>=(b^c^1145)&14;\n\tc*=a;a|=b+=c;a^=b&c;\n\treturn a%(k+1);\n}\n```\n\n函数的返回值即为生成的计数器示数。容易发现，初始示数均为不小于 $0$，不大于 $k$ 的整数，不违反规则。\n\n小 K 知道小 L 是绝顶聪明的人，且一定会以自己的胜利为目标进行游戏。当然，小 K 因为掌握了许多这个游戏的信息，水平不会落后于小 L。小 K 不能违反小 L 制定的规则，否则可能惹恼小 L，使冲突再次爆发。但是，小 K 可以通过计算，得出小 L 给出的方案中哪些是小 L 必胜，哪些是自己必胜的，并选择一个自己必胜的方案进行游戏。\n\n可惜时间不允许小 K 做太长时间的计算。恰好，会编程的你可以帮助小 K 在较短的时间内得出结果。请你帮小 K 算算，在小 L 给出的所有方案中，哪些小 L 必胜，哪些小 L 必败。\n\n-----------------------\n\n考虑到小 L 说的话可能太长以至于难以理解，小 K 决定更为简洁地叙述这个问题。小 L 提供了一个 $n$ 行 $m$ 列的数阵。小 L 与小 K 二人轮流操作，每次可以将数阵中的某个数加上 $1$。若加 $1$ 后此数大于 $k$，则此数清零，将加 $1$ 操作传递给其右侧的数。若某个数需要传递操作，但其右侧没有数，则这个操作对应的人的初始操作将不可进行。最后无法操作的人败。小 L 为先手，二人都绝顶聪明。若小 L 会赢则输出 `YES`，否则输出 `NO`。\n\n数阵里初始的数由小 L 提供。小 L 提供了若干个填充数阵的方案，每个方案中数阵里的数由上文的函数生成，生成顺序从左到右，从上到下。方案的互异性体现在参数 $a,b,c$ 的不同。请你对每种方案给出答案。 **保证生成方式与题目的正确解法无关。** 注意对于每种方案，小 L 实际上提供了六个参数 $k,n,m,a,b,c$，即 $k,n,m$ 在每种方案中也可能各不相同。", "inputFormat": "第一行为小 L 给出方案总数。\n\n对于每种方案，按顺序给出六个参数：$k,n,m,a,b,c$，其意义如题所示。", "outputFormat": "对于每种方案，如果小 L 会赢，输出 `YES`，否则输出 `NO`。", "hint": "【样例解释】\n\n两种方案中射击场上都只有一个靶。\n\n对于方案一，此靶计数器上的初始数值为 $0$。小 L 先手射击此靶使其计数器加 $1$。轮到小 K 时，计数器示数为 $1$，不存在不违规射击方案，小 K 输，小 L 赢。\n\n对于方案二，此靶计数器上的初始数值为 $1$，不存在不违规射击方案，小 L 输。\n\n【数据范围】\n\n最多 $20$ 种方案。\n\n| 数据编号 | $n$ 的范围 | $m$ 的范围 | $k$ 的范围 | 特殊性质 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $n=1$ | $1\\le m\\le5$ | $1\\le k\\le 5$ | 无 |\n| $2$ | $n=1$ | $1\\le m\\le20$ | $1\\le k\\le 5$ | 无 |\n| $3$ | $n=1$ | $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | 无 |\n| $4$ | $1\\le n \\le2$ | $1\\le m\\le100000$ |$1\\le k\\le 10^{18}$  | 无 |\n| $5$ | $1\\le n \\le100000$ | $m=1$ | $1\\le k\\le 10^{18}$ | 无 |\n| $6$ | $1\\le n \\le1000$ | $1\\le m\\le1000$ | $1\\le k\\le 10^{18}$ | $k$为偶数 |\n| $7$ | $1\\le n \\le50000$ | $1\\le m\\le20$ | $1\\le k\\le 10^{18}$ | $k$为偶数 |\n| $8$ | $1\\le n \\le10$ | $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | $k$为偶数 |\n| $9\\sim 11$ | $1\\le n \\le1000$ |$1\\le m\\le1000$  | $1\\le k\\le 10^{18}$ | 无 |\n| $12\\sim 14$ | $1\\le n \\le50000$ | $1\\le m\\le20$ | $1\\le k\\le 10^{18}$ | 无 |\n| $15\\sim 17$ | $1\\le n \\le10$| $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | 无 |\n\n对于所有数据，$k,n,m,a,b,c$ 均为正整数，$1\\le a,b,c\\le10^{18}$。各数据点分值分布如下：编号为 $1$ 的数据点分值为 $7$；编号为 $9$、$12$、$15$ 的数据点分值为 $5$；其余数据点分值为 $6$。", "locale": "zh-CN", "translations": {"en": {"title": "[L&K R-03] Final Duel at the Shooting Range", "background": "", "description": "[If you do not want to read the story, please read the part below the separator.]\n\nXiao L and Xiao K are the leaders of two gangs, and they are sworn enemies. One year, a large-scale conflict broke out between the two gangs. Xiao K, being weaker, was surrounded by Xiao L’s followers and was finally forced to retreat to a large shooting range. Xiao K knew the situation was hopeless. Just as he was about to fight Xiao L to the death, news came that Xiao L wanted to invite him to play a game. Xiao K knew there must be a trap, but he had no other choice, so he went alone to the meeting point Xiao L specified.\n\nThe meeting point was beside the shooting range. Xiao L stood in the field and waved to the approaching Xiao K with a smile. “Ah, Xiao K, long time no see. I remember the last time we met, it was in that small tavern. Back then, I chatted with you happily and talked about the world. Who would have thought we would end up like this today!” Xiao L paused and continued, “You used to be my brother. I do not want to end things between us with violence. Luckily, I have a good idea: how about we settle this with a game? What do you say, Xiao K?” Xiao K knew he had no room to refuse Xiao L, so he nodded. Seeing that, Xiao L smiled again and began to explain the rules of the game.\n\n“As you can see, our game will be played on this shooting range. The range has a total of $n$ rows and $m$ columns, i.e. $n\\times m$ targets. For convenience, let the row direction be left to right, and the column direction be front to back. This shooting range has a special feature: each target has a counter. If you hit a target, the displayed value of its counter increases by one. However, each counter value has a range: it can only be an integer not less than $0$ and not greater than $k$. If you hit a target when its counter value is already $k$ before the hit, then upon being hit, its counter overflows, resets to $0$, and emits an overflow error signal that starts to travel along wires. Due to the special wiring of the range, the signal only travels to the right. During the transmission, it affects some other counters in the same row. If an affected counter has value $k$, it will also overflow, reset to $0$, and emit an overflow error signal, which stacks with the previous signal (but the $+1$ effect does not stack). Otherwise, its value increases by one, and it sends a correction message that cuts off the signal propagation, meaning targets to its right will no longer be affected. Of course, if the signal keeps traveling without being cut off, it will eventually reach the information management terminal. Because signals keep stacking during transmission, and because the terminal has to process huge amounts of information, its ability to correct error signals is weak; this may cause the terminal to crash or even explode, which is against the rules.\n\n“You and I will take turns choosing one target to shoot once. The shooter decides which target to shoot. If it is someone’s turn to shoot but they cannot make a shot without breaking the rules, then they lose. Since I designed this game, I will go first. However, I will also give you some choices. The initial value of each target’s counter is not necessarily $0$; I can set it. I happen to have several setting plans, but I do not know which one to choose. Could you help me pick one?”\n\nXiao L took a few slips of paper out of his pocket. Xiao K looked and found that each slip did not list the initial values of all counters; it only had three numbers $a,b,c$. What Xiao L did not know was that Xiao K had amazing observation skills. While Xiao L was speaking, Xiao K had already analyzed how the displayed values changed and how the circuit was wired, and figured out the rule used to generate the initial counter values. The initial values of the counters are generated one by one in order. The order is row-major: from left to right, from top to bottom. Specifically, they are generated in the order of row $1$ column $1,2,\\ldots,m$, then row $2$ column $1,2,\\ldots,m$, ..., up to row $n$ column $1,2,\\ldots,m$. Generating one counter value uses $a,b,c$ as parameters, and after each generation, $a,b,c$ all change. Concretely, for each generated counter value, the following function is called once:\n\n```\ntypedef unsigned long long ull; \ninline ull generate(ull&a,ull&b,ull&c,ull&k)\n{ \n\ta<<=19;a+=b+c;\n\ta<<=26;a^=c+=a+81;b--;\n\ta<<=7;a>>=(b^c^1145)&14;\n\tc*=a;a|=b+=c;a^=b&c;\n\treturn a%(k+1);\n}\n```\n\nThe return value of the function is the generated counter value. It is easy to see that all initial values are integers between $0$ and $k$, so they do not violate the rules.\n\nXiao K knows Xiao L is extremely smart and will surely aim to win. Of course, since Xiao K also knows a lot about this game, his skill will not be worse than Xiao L’s. Xiao K cannot break the rules made by Xiao L, or he might anger Xiao L and cause the conflict to break out again. However, Xiao K can compute which of Xiao L’s plans guarantee a win for Xiao L, and which guarantee a win for himself, and then choose a plan where he is guaranteed to win.\n\nUnfortunately, time does not allow Xiao K to compute for too long. Luckily, you can program and help Xiao K get the result in a short time. Please help Xiao K determine, among all the plans Xiao L provides, which ones make Xiao L sure to win and which ones make Xiao L sure to lose.\n\n-----------------------\n\nSince what Xiao L said may be too long to understand, Xiao K decides to describe the problem more concisely. Xiao L provides a number matrix with $n$ rows and $m$ columns. Xiao L and Xiao K take turns operating. Each time, one number in the matrix can be increased by $1$. If after adding $1$ this number becomes greater than $k$, then it is reset to zero, and the $+1$ operation is passed to the number on its right. If a number needs to pass the operation but there is no number to its right, then the current player’s initial operation is not allowed. The player who cannot make a move loses. Xiao L moves first, and both players are extremely smart. If Xiao L will win, output `YES`; otherwise output `NO`.\n\nThe initial numbers in the matrix are provided by Xiao L. Xiao L provides several plans to fill the matrix; in each plan, the numbers in the matrix are generated by the function above, in order from left to right and from top to bottom. The difference between plans lies in different parameters $a,b,c$. **It is guaranteed that the generation method is irrelevant to the correct solution of this problem.** Note that for each plan, Xiao L actually provides six parameters $k,n,m,a,b,c$, meaning $k,n,m$ may also differ between plans.", "inputFormat": "The first line contains the total number of plans provided by Xiao L.\n\nFor each plan, six parameters are given in order: $k,n,m,a,b,c$, with meanings as described in the statement.", "outputFormat": "For each plan, if Xiao L will win, output `YES`; otherwise output `NO`.", "hint": "[Sample Explanation]\n\nIn both plans, there is only one target in the shooting range.\n\nFor plan 1, the initial value on this target’s counter is $0$. Xiao L, as the first player, shoots this target and makes its counter increase by $1$. When it is Xiao K’s turn, the counter value is $1$, and there is no legal shot, so Xiao K loses and Xiao L wins.\n\nFor plan 2, the initial value on this target’s counter is $1$, and there is no legal shot, so Xiao L loses.\n\n[Constraints]\n\nAt most $20$ plans.\n\n| Test ID | Range of $n$ | Range of $m$ | Range of $k$ | Special Property |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $n=1$ | $1\\le m\\le5$ | $1\\le k\\le 5$ | None |\n| $2$ | $n=1$ | $1\\le m\\le20$ | $1\\le k\\le 5$ | None |\n| $3$ | $n=1$ | $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | None |\n| $4$ | $1\\le n \\le2$ | $1\\le m\\le100000$ |$1\\le k\\le 10^{18}$  | None |\n| $5$ | $1\\le n \\le100000$ | $m=1$ | $1\\le k\\le 10^{18}$ | None |\n| $6$ | $1\\le n \\le1000$ | $1\\le m\\le1000$ | $1\\le k\\le 10^{18}$ | $k$ is even |\n| $7$ | $1\\le n \\le50000$ | $1\\le m\\le20$ | $1\\le k\\le 10^{18}$ | $k$ is even |\n| $8$ | $1\\le n \\le10$ | $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | $k$ is even |\n| $9\\sim 11$ | $1\\le n \\le1000$ |$1\\le m\\le1000$  | $1\\le k\\le 10^{18}$ | None |\n| $12\\sim 14$ | $1\\le n \\le50000$ | $1\\le m\\le20$ | $1\\le k\\le 10^{18}$ | None |\n| $15\\sim 17$ | $1\\le n \\le10$| $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | None |\n\nFor all testdata, $k,n,m,a,b,c$ are positive integers, and $1\\le a,b,c\\le10^{18}$. The score distribution is as follows: test ID $1$ is worth $7$ points; test IDs $9$, $12$, and $15$ are worth $5$ points; all others are worth $6$ points.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【L&K R-03】射击场决战", "background": "", "description": "【如果不想看题面请阅读分割线以下部分】\n\n小 L 与小 K 是两个帮派的首领，也是死敌。某年某月，两个帮派发生了大规模的冲突。小 K 因为实力不敌，被小 L 的爪牙团团包围，最终被逼近了一个大型射击场。小 K 自知大势已去，正准备与小 L 拼死一战时，却传来消息，说小 L 要邀请自己与他来玩一场游戏。小 K 知道其中有鬼，但却别无它计，只能只身前往小 L 指定的会面点。\n\n会面点在射击场旁。小 L 站在场上，满脸笑容地对走来的小 K 招手。“啊，小 K ，好久不见。我记得上次我们见面的时候，还是在那个小酒馆。当时，我与你谈笑风生，指点江山，不亦乐乎。没想到，如今，我们竟到此地步啊！”小 L 顿了顿，继续说道：“你是我曾经的兄弟，我不想以暴力的方式了解你我。正好，我有一个好方法：不如我们用游戏的方式来场决战吧！这样如何，小 K ？”小 K 知道，自己并没有否定小 L 的余地。于是，小 K 点了点头。小 L 看到小 K 点头，又露出了笑容，开始讲起了游戏的规则。\n\n“如你所见，我们的游戏要在这片射击场上进行。射击场总共有 $n$ 行 $m$  列，共 $n\\times m$ 个靶。为了方便，取行的方向为左右，列的方向为前后。这个射击场有一个特点：每个靶上都有一个计数器。击中一个靶，这个靶的计数器示数就会加一。但是，每个靶的示数有一个范围，只能是不小于 $0$，不大于 $k$ 的整数。倘若击中一个靶，而在未击中此靶前此靶计数器的示数已经为 $k$，那么击中时，此靶计数器示数就会溢出清 $0$，并产生溢出错误的信号，经电线开始传递。由于靶场电线的特殊布置，信号只会往右侧传递。信号传递过程中会影响若干其它同行靶的计数器。如果这些被影响到的靶计数器示数为 $k$，其同样会溢出清 $0$ 并产生溢出错误信号，与之前的信号叠加（但加一效果不会叠加）；否则，其示数会加一，并发出纠正讯息，截断信号传播，即在其右侧的靶不会继续被信号影响。当然，如果信号一直传递而未被截断，那么它最终会传入信息管理终端。由于信号在传递过程中不断叠加，再加之信息管理终端要处理庞大的信息，纠正错误信号的能力较差，可能会导致终端死机甚至发生爆炸的危险，这是违规的。\n\n“我与你会轮流选择其中一个靶进行一次射击，射击哪个靶由射击者自行决定。如果轮到某个人射击，但他无法进行不违规的射击，那么他就输了。因为这是我设计的游戏，先手当然是我。但是，我也会给你一些选择。靶场上每个靶计数器的初始示数不一定为 $0$，是可以被我设置的。我这里恰好有几种设置方案，但我不知道该选哪种好，可否请你帮我选一选？”\n\n小 L 从口袋里抽出了几张纸条。小 K 一看，每张纸条却没有写每个靶计数器的初始示数，只写着三个数字 $a,b,c$。小 L 所不知道的是，小 K 有着惊人的观察能力，在小 L 讲刚才那一番话之时，小 K 就已经通过分析靶上示数的变化以及电路的布置，得出了计数器初始示数生成的规律。靶场上靶的计数器初始示数是一个个按顺序生成的。并且，生成的顺序是按行优先，从左到右，从上到下。具体来说，是按照第 $1$ 行第 $1,2,\\ldots ,m$ 个，第 $2$ 行第 $1,2,\\ldots ,m$ 个，……，第 $n$ 行第 $1,2,\\ldots ,m$ 个的顺序生成。生成一个计数器的示数需要用到 $a,b,c$ 作为参数。并且，每生成一个计数器的示数，$a,b,c$ 都会产生变化。具体来说，每生成一个计数器的示数，便引用一次以下的函数：\n\n```\ntypedef unsigned long long ull; \ninline ull generate(ull&a,ull&b,ull&c,ull&k)\n{ \n\ta<<=19;a+=b+c;\n\ta<<=26;a^=c+=a+81;b--;\n\ta<<=7;a>>=(b^c^1145)&14;\n\tc*=a;a|=b+=c;a^=b&c;\n\treturn a%(k+1);\n}\n```\n\n函数的返回值即为生成的计数器示数。容易发现，初始示数均为不小于 $0$，不大于 $k$ 的整数，不违反规则。\n\n小 K 知道小 L 是绝顶聪明的人，且一定会以自己的胜利为目标进行游戏。当然，小 K 因为掌握了许多这个游戏的信息，水平不会落后于小 L。小 K 不能违反小 L 制定的规则，否则可能惹恼小 L，使冲突再次爆发。但是，小 K 可以通过计算，得出小 L 给出的方案中哪些是小 L 必胜，哪些是自己必胜的，并选择一个自己必胜的方案进行游戏。\n\n可惜时间不允许小 K 做太长时间的计算。恰好，会编程的你可以帮助小 K 在较短的时间内得出结果。请你帮小 K 算算，在小 L 给出的所有方案中，哪些小 L 必胜，哪些小 L 必败。\n\n-----------------------\n\n考虑到小 L 说的话可能太长以至于难以理解，小 K 决定更为简洁地叙述这个问题。小 L 提供了一个 $n$ 行 $m$ 列的数阵。小 L 与小 K 二人轮流操作，每次可以将数阵中的某个数加上 $1$。若加 $1$ 后此数大于 $k$，则此数清零，将加 $1$ 操作传递给其右侧的数。若某个数需要传递操作，但其右侧没有数，则这个操作对应的人的初始操作将不可进行。最后无法操作的人败。小 L 为先手，二人都绝顶聪明。若小 L 会赢则输出 `YES`，否则输出 `NO`。\n\n数阵里初始的数由小 L 提供。小 L 提供了若干个填充数阵的方案，每个方案中数阵里的数由上文的函数生成，生成顺序从左到右，从上到下。方案的互异性体现在参数 $a,b,c$ 的不同。请你对每种方案给出答案。 **保证生成方式与题目的正确解法无关。** 注意对于每种方案，小 L 实际上提供了六个参数 $k,n,m,a,b,c$，即 $k,n,m$ 在每种方案中也可能各不相同。", "inputFormat": "第一行为小 L 给出方案总数。\n\n对于每种方案，按顺序给出六个参数：$k,n,m,a,b,c$，其意义如题所示。", "outputFormat": "对于每种方案，如果小 L 会赢，输出 `YES`，否则输出 `NO`。", "hint": "【样例解释】\n\n两种方案中射击场上都只有一个靶。\n\n对于方案一，此靶计数器上的初始数值为 $0$。小 L 先手射击此靶使其计数器加 $1$。轮到小 K 时，计数器示数为 $1$，不存在不违规射击方案，小 K 输，小 L 赢。\n\n对于方案二，此靶计数器上的初始数值为 $1$，不存在不违规射击方案，小 L 输。\n\n【数据范围】\n\n最多 $20$ 种方案。\n\n| 数据编号 | $n$ 的范围 | $m$ 的范围 | $k$ 的范围 | 特殊性质 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $n=1$ | $1\\le m\\le5$ | $1\\le k\\le 5$ | 无 |\n| $2$ | $n=1$ | $1\\le m\\le20$ | $1\\le k\\le 5$ | 无 |\n| $3$ | $n=1$ | $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | 无 |\n| $4$ | $1\\le n \\le2$ | $1\\le m\\le100000$ |$1\\le k\\le 10^{18}$  | 无 |\n| $5$ | $1\\le n \\le100000$ | $m=1$ | $1\\le k\\le 10^{18}$ | 无 |\n| $6$ | $1\\le n \\le1000$ | $1\\le m\\le1000$ | $1\\le k\\le 10^{18}$ | $k$为偶数 |\n| $7$ | $1\\le n \\le50000$ | $1\\le m\\le20$ | $1\\le k\\le 10^{18}$ | $k$为偶数 |\n| $8$ | $1\\le n \\le10$ | $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | $k$为偶数 |\n| $9\\sim 11$ | $1\\le n \\le1000$ |$1\\le m\\le1000$  | $1\\le k\\le 10^{18}$ | 无 |\n| $12\\sim 14$ | $1\\le n \\le50000$ | $1\\le m\\le20$ | $1\\le k\\le 10^{18}$ | 无 |\n| $15\\sim 17$ | $1\\le n \\le10$| $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | 无 |\n\n对于所有数据，$k,n,m,a,b,c$ 均为正整数，$1\\le a,b,c\\le10^{18}$。各数据点分值分布如下：编号为 $1$ 的数据点分值为 $7$；编号为 $9$、$12$、$15$ 的数据点分值为 $5$；其余数据点分值为 $6$。", "locale": "zh-CN"}}}
{"pid": "P5821", "type": "P", "difficulty": 6, "samples": [["8 5 3\niamangry\nanger\n1 4\n2 2 m\n1 2", "218\n238"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "洛谷原创"], "title": "【L&K R-03】密码串匹配", "background": "众所周知，小 L 很喜欢用 $123321$ 做密码。每次登陆 Codeforces，都会看见显眼的一行提示：\n\n```text\nYour password is extremely weak or has been leaked . Please, change it ASAP. \n(see https://haveibeenpwned.com/)\n```", "description": "在被机惨之后，小 L 痛定思痛，决定使用更安全的密码。小 L 设计出了一个可能长达 $200,000$ 位的仅由小写字母构成的密码，并保证没有人能记住，猜出或试出（包括小 L 自己）。\n\n为了防止自己忘记整串密码（不用防止了，已经忘记了），小 L 编写了一个程序，可以存储小 L 的密码串 $T$，但是不能直接输出（因为这个程序可能会被他人使用），小 L 第一次会根据记忆还原出长度为 $l$ 的一个字符串 $P$，后面会根据程序的输出修改 $P$ 的某一位，这个程序可以求出当前猜测串 $P$ 与密码串 $T$ 的相同长度的字串的 **失配度** 。\n\n定义字符 `a` 的值为 $1$，字符 `b` 的值为 $2$，以此类推，字符 `z` 的值为 $26$。定义两个字符串 $s,t$ 的失配度为对应位置上的值相减后的平方。\n\n现在，小 L 想知道他的程序是否正确，请你也编写一个类似的程序。", "inputFormat": "输入的第一行为三个数 $n,l,m$，分别表示密码串 $T$ 的长度 $n$，猜测串 $P$ 的长度 $l$，和操作次数 $m$。\n\n接下来的两行有两个字符串，分别为 $T$ 和 $P$。\n\n接下来的 $m$ 行，每行的第一个整数为 $op$，表示操作的类型：\n\n若 $op=1$，接下来有一个整数 $x$，表示要求 $P$ 和从 $T$ 的第 $x$ 位开始长度为 $l$ 的字串的失配度；\n\n若 $op=2$，接下来有一个整数 $x$ 和一个字符 $c$，表示修改 $P$ 的第 $x$ 位，使其等于 $c$。", "outputFormat": "对于每个 $1$ 操作，输出一行，为所求值。", "hint": "**请注意本题特殊的时间限制。**\n\n**本题数据规模大，请注意常数优化。**\n\n为了防止题目过于卡常，本题 **提供 [八聚氧](https://www.luogu.com.cn/paste/ky1fh8zk)** ，直接加在代码最前提交即可。\n\n本题中所有编号从 $1$ 开始。\n\n- Subtask \\#1：$30$ 分，保证 $n,m\\le 5\\times 10^3$；\n- Subtask \\#2：$30$ 分，保证没有 $2$ 操作；\n- Subtask \\#3：$40$ 分，保证 $n,m\\le 2\\times 10^5$。\n\n对于 $100\\%$ 的数据，保证 $1\\le l\\le n,1\\le x$。\n\n对于所有 $1$ 操作，保证 $x-1+l\\le n$。\n\n对于所有 $2$ 操作，保证 $x\\le l$。\n\n### 样例解释\n\n$(a-a)^2+(n-n)^2+(g-g)^2+(r-e)^2+(y-r)^2=13^2+7^2=218$。\n\n$(a-a)^2+(m-m)^2+(a-g)^2+(n-e)^2+(g-r)^2=6^2+9^2+11^2=238$。", "locale": "zh-CN", "translations": {"en": {"title": "[L&K R-03] Password String Matching", "background": "As everyone knows, Little L really likes to use $123321$ as a password. Every time he logs in to Codeforces, he sees a very eye-catching message:\n\n```text\nYour password is extremely weak or has been leaked . Please, change it ASAP. \n(see https://haveibeenpwned.com/)\n```", "description": "After getting destroyed by the judge, Little L reflected and decided to use a safer password. Little L designed a password that may be as long as $200{,}000$ characters and consists only of lowercase letters, and he guarantees that nobody can remember it, guess it, or brute-force it (including Little L himself).\n\nTo avoid forgetting the whole password string (no need to avoid it; he has already forgotten it), Little L wrote a program that can store his password string $T$, but cannot output it directly (because others might use this program). The first time, Little L reconstructs a string $P$ of length $l$ from memory. Later, he will modify one character of $P$ based on the program’s output. This program can compute the **mismatch degree** between the current guess string $P$ and the substring of $T$ with the same length.\n\nDefine the value of character `a` as $1$, character `b` as $2$, and so on, up to character `z` as $26$. Define the mismatch degree of two strings $s,t$ as the sum of the squares of the differences of their values at corresponding positions.\n\nNow, Little L wants to know whether his program is correct. Please write a similar program as well.", "inputFormat": "The first line contains three integers $n,l,m$, representing the length $n$ of the password string $T$, the length $l$ of the guess string $P$, and the number of operations $m$.\n\nThe next two lines contain two strings, which are $T$ and $P$.\n\nThe next $m$ lines each start with an integer $op$, indicating the type of operation:\n\n- If $op=1$, then an integer $x$ follows, meaning you need to query the mismatch degree between $P$ and the substring of $T$ of length $l$ starting from position $x$.\n- If $op=2$, then an integer $x$ and a character $c$ follow, meaning you modify the $x$-th character of $P$ to make it equal to $c$.", "outputFormat": "For each operation of type $1$, output one line containing the required value.", "hint": "**Please note the special time limit of this problem.**\n\n**The data size is large, so please optimize constants carefully.**\n\nTo prevent the problem from being too strict on runtime, this problem **provides [Bajuyang](https://www.luogu.com.cn/paste/ky1fh8zk)**. You can paste it directly at the very beginning of your code and submit.\n\nIn this problem, all indices start from $1$.\n\n- Subtask \\#1: $30$ points, guaranteed $n,m\\le 5\\times 10^3$.\n- Subtask \\#2: $30$ points, guaranteed there is no operation type $2$.\n- Subtask \\#3: $40$ points, guaranteed $n,m\\le 2\\times 10^5$.\n\nFor $100\\%$ of the testdata, it is guaranteed that $1\\le l\\le n$ and $1\\le x$.\n\nFor all operations of type $1$, it is guaranteed that $x-1+l\\le n$.\n\nFor all operations of type $2$, it is guaranteed that $x\\le l$.\n\n### Sample Explanation\n\n$(a-a)^2+(n-n)^2+(g-g)^2+(r-e)^2+(y-r)^2=13^2+7^2=218$.\n\n$(a-a)^2+(m-m)^2+(a-g)^2+(n-e)^2+(g-r)^2=6^2+9^2+11^2=238$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【L&K R-03】密码串匹配", "background": "众所周知，小 L 很喜欢用 $123321$ 做密码。每次登陆 Codeforces，都会看见显眼的一行提示：\n\n```text\nYour password is extremely weak or has been leaked . Please, change it ASAP. \n(see https://haveibeenpwned.com/)\n```", "description": "在被机惨之后，小 L 痛定思痛，决定使用更安全的密码。小 L 设计出了一个可能长达 $200,000$ 位的仅由小写字母构成的密码，并保证没有人能记住，猜出或试出（包括小 L 自己）。\n\n为了防止自己忘记整串密码（不用防止了，已经忘记了），小 L 编写了一个程序，可以存储小 L 的密码串 $T$，但是不能直接输出（因为这个程序可能会被他人使用），小 L 第一次会根据记忆还原出长度为 $l$ 的一个字符串 $P$，后面会根据程序的输出修改 $P$ 的某一位，这个程序可以求出当前猜测串 $P$ 与密码串 $T$ 的相同长度的字串的 **失配度** 。\n\n定义字符 `a` 的值为 $1$，字符 `b` 的值为 $2$，以此类推，字符 `z` 的值为 $26$。定义两个字符串 $s,t$ 的失配度为对应位置上的值相减后的平方。\n\n现在，小 L 想知道他的程序是否正确，请你也编写一个类似的程序。", "inputFormat": "输入的第一行为三个数 $n,l,m$，分别表示密码串 $T$ 的长度 $n$，猜测串 $P$ 的长度 $l$，和操作次数 $m$。\n\n接下来的两行有两个字符串，分别为 $T$ 和 $P$。\n\n接下来的 $m$ 行，每行的第一个整数为 $op$，表示操作的类型：\n\n若 $op=1$，接下来有一个整数 $x$，表示要求 $P$ 和从 $T$ 的第 $x$ 位开始长度为 $l$ 的字串的失配度；\n\n若 $op=2$，接下来有一个整数 $x$ 和一个字符 $c$，表示修改 $P$ 的第 $x$ 位，使其等于 $c$。", "outputFormat": "对于每个 $1$ 操作，输出一行，为所求值。", "hint": "**请注意本题特殊的时间限制。**\n\n**本题数据规模大，请注意常数优化。**\n\n为了防止题目过于卡常，本题 **提供 [八聚氧](https://www.luogu.com.cn/paste/ky1fh8zk)** ，直接加在代码最前提交即可。\n\n本题中所有编号从 $1$ 开始。\n\n- Subtask \\#1：$30$ 分，保证 $n,m\\le 5\\times 10^3$；\n- Subtask \\#2：$30$ 分，保证没有 $2$ 操作；\n- Subtask \\#3：$40$ 分，保证 $n,m\\le 2\\times 10^5$。\n\n对于 $100\\%$ 的数据，保证 $1\\le l\\le n,1\\le x$。\n\n对于所有 $1$ 操作，保证 $x-1+l\\le n$。\n\n对于所有 $2$ 操作，保证 $x\\le l$。\n\n### 样例解释\n\n$(a-a)^2+(n-n)^2+(g-g)^2+(r-e)^2+(y-r)^2=13^2+7^2=218$。\n\n$(a-a)^2+(m-m)^2+(a-g)^2+(n-e)^2+(g-r)^2=6^2+9^2+11^2=238$。", "locale": "zh-CN"}}}
{"pid": "P5822", "type": "P", "difficulty": 7, "samples": [["3 3 1 1 2\n100 200 300\n1 1 50\n1 2 2\n2 3 1", "545/2\n349\n300"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2019", "洛谷原创"], "title": "【L&K R-03】大航海时代", "background": "", "description": "【如果不想看题面请阅读分割线以下部分】\n\n$$\\text{Onde\\space a\\space terra\\space acaba\\space e\\space o\\space mar\\space começa}$$\n\n>_15 世纪末，是一个伟大时代的开始。自此之后，人们开始逐渐认识到大千世界的险恶与奇丽，开始前仆后继地展开一个又一个不可思议的冒险，开始缓缓地驾驭那波涛汹涌、变幻莫测的大海。_\n\n>_15 世纪末，是一个伟大时代的开始。为了征服海洋，人们集人类之智慧，制造出方舟巨轮；汇天地之灵怪，制造出罗盘、六分仪。海上的康庄大道从此建立，人们航行于各地，商贸随之诞生。_\n\n>_15 世纪末，是一个伟大时代的开始。商品与金钱象征着欲望，在海上流动了起来。原先分隔的黄金汇聚成大金库，让人们尝到了商业的甜头。贸易的花朵开遍整个欧洲，航线上船只往来不绝，财富源源不断地从海上涌出。_\n\n>_[更多](https://www.luogu.org/paste/k9bqwpps)_\n\n>……\n\n>_大航海时代，是人类文明崭新的起点。_\n\n海上经商，商人们必须对航路有充分的了解。欧洲的城市不计其数，航路更是数不胜数。当然，人们无需知晓所有城市的位置，更无需清楚所有航路的情况。人们只需要知道，有几个主要城市，并且有几条海上航路连接着它们即可，其他的城市与航路都是次要的，不会带来过多收益。\n\n商船沿着航路往来于城市之间。它们每到一个城市，卸下一些货品，城市里的商人便会根据货品的数目给出相应的报酬。这些报酬由船主收取，并将部分报酬分发给水手们。不过大家并不关心这件事，他们只会关心一艘船获得的总收益。\n\n商船的航行总会伴随着危险与损失。海上的天气难以预测，船只随时都可能会被大浪吞没，或者被飓风刮得千疮百孔。不过这些情况比较特殊，我们并不考虑。我们考虑的是，商船在航行过程中的必要支出。一趟航行往往需要几星期甚至几个月的时间。在这段时间里，船员需要淡水与食物，船也需要适当的维护。人们总结经验发现，一段航行的必要支出与航行距离和载货量有直接关系。\n\n大航海时代的人们就是在这些规律下生活的，考量着商船的支出与收益，缓行于茫茫大海之上，每日如此，单调而无趣。大航海时代，对于大部分人来说，或许并没有那么伟大。\n\n当然，生于现代的我们不必在意这些东西。这也是当然的，现代人怎么会为古代人考虑什么东西呢？\n\n然而，小 L 和小 K 发现他们必须开始考虑这些事物了，因为他们不小心掉进了虫洞，回到了大航海时代。回到过去的他们用唯一的财产：手机，换来了一艘船和一船货物。为了生存，他们要驾驶着这艘船航行于海上，用货物与商人们换取钱财。\n\n----------------------------------\n\n小 L 和小 K 通过调查了解了海上贸易的一些基本规律。共有 $n$ 个主要城市和 $m$ 条连接着它们的航道，船只能沿着这些航道航行。注意航道是单向的，因为如果是双向，航线就容易交叉，发生事故。第 $i$ 条航道的距离为 $dis_i$，若商船在经过此航道时载货量（下称货物量）为 $p$，则航行完此航道需花费 $p\\times dis_i$  的金币。商船到达一个城市，会卸下部分货物与商人交易。每座城市都有一个大商人，会根据 **船上卸下** 的货物量付给商船一定的金币。每座城市的大商人不同，标准也不一样。第 $i$ 座城市的大商人标准为 $mea_i$，若商船在 $i$ 号城市卸下量为 $p$ 的商品，大商人会付给商船 $p\\times mea_i$ 的金币。商船每到达一座城市，只会与大商人进行一次交易。当然，一座城市可以重复到达，每次到达都会与大商人进行交易。\n\n小 L 和小 K 需要遵循这些规律，沿着航道进行海上贸易。小 L 和小 K 在一开始总共有量为 $q$ 的货品。小 L 和小 K 本该精打细算，详细计算出他们在每座城市应该卸下的货物量。但是小 L 和小 K 是懒癌晚期患者，并不想这样做。他们随便想了两个正整数 $s,t$，于是如果需要卸下货物，他们便会卸下总货物量 $\\frac{s}{s+t}$ 的货物。\n\n在他们的商贸之旅开始之前，小 L 和小 K 就已经研究出了回到现代的方法。但是他们并不着急回去。因为回溯时间导致的时空错位，小 L 和小 K 身上的时间是静止的。也就是说他们拥有无限的时间。他们决定利用此原理在这个时代大赚一笔。小 L 和小 K 可以选择从任意一座城市出发。他们希望知道从每座城市出发，可以赚到的最大金币数量是多少。当然因为他们比较懒，这个问题由你来解决。\n\n需要注意的是，尽管在大航海时代分数的运算并没有普及，但小 L 和小 K 为了自己方便而将他们得到的信息部分用分数（有理数）来表示。也就是说，虽然 $dis_i,mea_i,q$ 是由当时的人们给出的，所以是整数，但是货物量和金币量可以是分数，即小 L 和小 K 用有理数的计算法则计算自己的收益。小 L 和小 K 在出发的城市也会进行交易。", "inputFormat": "第一行，五个正整数 $n,m,s,t,q$。\n\n第二行， $n$ 个正整数，第 $i$ 个数表示 $mea_i$。\n\n接下来 $m$ 行，每行三个正整数 $a,b,dis_i$，表示从城市 $a$ 到城市 $b$ 有一条长为 $dis_i$ 的单向航道。", "outputFormat": "共 $n$ 行，第 $i$ 行表示从 $i$ 号城市出发可以赚到的最大金币数量，输出格式见下文。\n\n关于分数的输出格式：\n\n可能以 ```a/b``` 的形式输出，表示分数 $\\frac{a}{b}$，其中 $a,b$ 为正整数。也可能以 ```-a/b``` 的形式输出，表示分数 $-\\frac{a}{b}$，其中 $a,b$ 为正整数。也可能以 ```a``` 的形式输出，表示**整数** $a$。注意 $\\gcd(a,b)$ 一定为 $1$。如果 $b$ 为 $1$，则必须以 ```a``` 的形式输出。", "hint": "【样例说明】\n\n$\\frac{s}{s+t}=\\frac{1}{2}$，小 L 和小 K 每次会卸下一半的货物进行交易。\n\n从 $1$ 号城市出发：先在 $1$ 号城市进行交易，用 $2\\times\\frac{1}{2}=1$ 的货物量交易，获得金币 $1\\times 100=100$，剩余货物量 $2-1=1$。之后如果走 $1\\rightarrow1$ 的航道，会再花费 $1\\times 50=50$ 的金币回到城市 $1$，很不划算。如果走 $1\\rightarrow2$ 的航道，只需要再花费 $1\\times 2=2$ 的金币就可以到达城市 $2$。到达城市 $2$ 进行交易，用 $1\\times\\frac{1}{2}=\\frac{1}{2}$ 的货物量交易，获得金币 $\\frac{1}{2}\\times 200=100$，剩余货物量 $1-\\frac{1}{2}=\\frac{1}{2}$。接下来走 $2\\rightarrow3$，花费 $\\frac{1}{2}\\times1=\\frac{1}{2}$ 的金币。到达城市 $3$，用 $\\frac{1}{2}\\times\\frac{1}{2}=\\frac{1}{4}$的货物量交易，交易获得金币 $\\frac{1}{4}\\times300=75$，剩余货物量 $\\frac{1}{2}-\\frac{1}{4}=\\frac{1}{4}$。总获利 $100-2+100-\\frac{1}{2}+75=\\frac{545}{2}$。\n\n从 $2$ 号城市出发：走 $2\\rightarrow3$，在 $2,3$ 号城市交易，获利 $200-1+150=349$。\n\n从 $3$ 号城市出发：在 $3$ 号城市交易，获利 $300$。\n\n【数据范围】\n\n对于 $10\\%$ 的数据，$n\\le 3,m\\le 9$，$s,t,q,mea_i,dis_i\\le10$。\n\n对于 $50\\%$ 的数据，$n\\le 10,m\\le 100$，$s,t,q,mea_i,dis_i\\le10$。\n\n对于另外 $10\\%$ 数据，$m=n$，且对于任意正整数 $i\\in[1,n]$，编号为 $i$ 的城市有一条到编号为 $(i\\mod n)+1$ 的城市的航道。\n\n对于另外 $10\\%$ 数据，对于任意正整数 $i\\in[1,n]$，若存在航道 \n $i\\rightarrow j$，则 $j>i$。\n\n对于 $100\\%$ 的数据，$n\\le 50,m\\le 500$，$s,t,q,mea_i,dis_i\\le10^4$。\n\n【补充说明】\n\n城市从 $1$ 到 $n$ 编号。\n\n请注意本题特殊的时空限制。\n\n为了防止题目过于卡常，本题 **提供 [八聚氧](https://www.luogu.com.cn/paste/ky1fh8zk)** ，直接加在代码最前提交即可。保证标程在加上八聚氧后通过每个数据点的最大用时小于时限的一半。请大胆尝试解法。", "locale": "zh-CN", "translations": {"en": {"title": "[L&K R-03] Age of Discovery", "background": "", "description": "[If you do not want to read the full statement, please read the part below the divider.]\n\n$$\\text{Onde\\space a\\space terra\\space acaba\\space e\\space o\\space mar\\space começa}$$\n\n>_At the end of the 15th century, a great era began. From then on, people gradually came to know the dangers and wonders of the world, started one incredible adventure after another, and slowly learned to navigate the rough and unpredictable sea._\n\n>_At the end of the 15th century, a great era began. To conquer the ocean, people gathered human wisdom to build giant ships; and drew on the mysteries of nature to create the compass and the sextant. From then on, smooth sea routes were established. People sailed to various places, and trade was born._\n\n>_At the end of the 15th century, a great era began. Goods and money, symbols of desire, began to flow across the sea. Gold that was once separated gathered into great vaults, letting people taste the sweetness of business. The flowers of trade bloomed all over Europe, ships traveled endlessly along routes, and wealth poured out from the sea._\n\n>_[More](https://www.luogu.org/paste/k9bqwpps)_\n\n>……\n\n>_The Age of Discovery was a brand-new starting point for human civilization._\n\nTo do business at sea, merchants must fully understand the routes. There are countless cities in Europe, and even more routes. Of course, people do not need to know the locations of all cities, nor the details of all routes. They only need to know that there are several major cities and several sea routes connecting them. Other cities and routes are secondary and will not bring much profit.\n\nMerchant ships travel between cities along routes. Each time a ship arrives at a city, it unloads some goods, and the merchants in the city pay a corresponding reward based on the amount of goods. The ship owner collects this reward and distributes part of it to the sailors. But nobody cares about that; they only care about the total profit a ship earns.\n\nSailing always comes with danger and loss. The weather at sea is hard to predict; ships may be swallowed by huge waves or torn apart by hurricanes. However, these are special cases and we will not consider them. What we consider is the necessary expenses during sailing. A voyage often takes weeks or even months. During this time, the crew needs fresh water and food, and the ship needs maintenance. From experience, people found that the necessary cost of a voyage is directly related to the sailing distance and the amount of cargo.\n\nPeople in the Age of Discovery lived under these rules, weighing a ship’s expenses and income, moving slowly across the vast sea day after day—monotonous and boring. For most people, the Age of Discovery might not have been that great.\n\nOf course, we who live in modern times do not need to care about these things. Naturally, why would modern people think about such things for ancient people?\n\nHowever, Little L and Little K found that they had to start caring about them, because they accidentally fell into a wormhole and returned to the Age of Discovery. After returning to the past, they traded their only property—a mobile phone—for a ship and a shipload of goods. To survive, they must sail this ship on the sea and exchange goods with merchants for money.\n\n----------------------------------\n\nLittle L and Little K investigated and learned some basic rules of maritime trade. There are $n$ major cities and $m$ sea routes connecting them, and ships can only sail along these routes. Note that routes are directed, because if they were bidirectional, routes would easily cross and accidents would happen. The distance of the $i$-th route is $dis_i$. If the cargo load (hereinafter called the amount of goods) is $p$ when the ship travels along this route, then completing this route costs $p\\times dis_i$ gold coins.\n\nWhen the ship arrives at a city, it unloads part of the goods to trade. Each city has a “big merchant”, who pays the ship a certain amount of gold coins based on the amount of goods **unloaded from the ship**. Big merchants differ from city to city, and so do their standards. The standard of the big merchant in city $i$ is $mea_i$. If the ship unloads $p$ goods in city $i$, the big merchant pays $p\\times mea_i$ gold coins. Each time the ship arrives at a city, it trades with the big merchant exactly once. Of course, a city may be visited repeatedly, and each visit triggers a trade with the big merchant.\n\nLittle L and Little K must follow these rules and conduct maritime trade along the routes. Initially, Little L and Little K have a total amount of goods $q$. They should have planned carefully and computed exactly how much to unload in each city. But they are extremely lazy and do not want to do that. They randomly chose two positive integers $s,t$. Therefore, whenever they need to unload goods, they will unload $\\frac{s}{s+t}$ of the total goods currently on the ship.\n\nBefore their trading journey began, Little L and Little K had already figured out how to return to modern times. But they were not in a hurry to go back. Due to time-space misalignment caused by traveling back in time, time is frozen for them. That is, they have unlimited time. They decided to use this principle to make a fortune in this era. They may choose to start from any city. They want to know, for each starting city, what is the maximum number of gold coins they can earn. Since they are lazy, you are asked to solve this problem.\n\nNote that although fraction arithmetic was not widely used in the Age of Discovery, Little L and Little K, for their own convenience, expressed part of the information they obtained using fractions (rational numbers). That is, although $dis_i,mea_i,q$ are integers given by people of that time, the amount of goods and the amount of gold coins may be fractions. Little L and Little K compute their profit using the rules of rational arithmetic. Little L and Little K will also trade in the city where they start.", "inputFormat": "The first line contains five positive integers $n,m,s,t,q$.\n\nThe second line contains $n$ positive integers; the $i$-th number denotes $mea_i$.\n\nThe next $m$ lines each contain three positive integers $a,b,dis_i$, indicating that there is a directed sea route of length $dis_i$ from city $a$ to city $b$.", "outputFormat": "Output $n$ lines. The $i$-th line denotes the maximum number of gold coins that can be earned starting from city $i$. The output format is described below.\n\nAbout the output format for fractions:\n\nIt may be printed as ```a/b```, representing the fraction $\\frac{a}{b}$, where $a,b$ are positive integers. It may also be printed as ```-a/b```, representing the fraction $-\\frac{a}{b}$, where $a,b$ are positive integers. It may also be printed as ```a```, representing the **integer** $a$. Note that $\\gcd(a,b)$ is guaranteed to be $1$. If $b$ is $1$, then it must be printed in the form ```a```.", "hint": "[Sample Explanation.]\n\n$\\frac{s}{s+t}=\\frac{1}{2}$, so each time Little L and Little K will unload half of the goods to trade.\n\nStarting from city $1$: first trade in city $1$, trade using $2\\times\\frac{1}{2}=1$ goods, obtain $1\\times 100=100$ gold coins, and the remaining goods are $2-1=1$. If they then take the route $1\\rightarrow1$, it will cost another $1\\times 50=50$ gold coins to return to city $1$, which is not worth it. If they take the route $1\\rightarrow2$, it only costs another $1\\times 2=2$ gold coins to reach city $2$. Arriving at city $2$ and trading, they trade using $1\\times\\frac{1}{2}=\\frac{1}{2}$ goods and obtain $\\frac{1}{2}\\times 200=100$ gold coins, leaving $1-\\frac{1}{2}=\\frac{1}{2}$ goods. Next, take $2\\rightarrow3$, costing $\\frac{1}{2}\\times1=\\frac{1}{2}$ gold coins. Arriving at city $3$, trade using $\\frac{1}{2}\\times\\frac{1}{2}=\\frac{1}{4}$ goods, obtain $\\frac{1}{4}\\times300=75$ gold coins, leaving $\\frac{1}{2}-\\frac{1}{4}=\\frac{1}{4}$ goods. Total profit is $100-2+100-\\frac{1}{2}+75=\\frac{545}{2}$.\n\nStarting from city $2$: take $2\\rightarrow3$, trade in cities $2$ and $3$, profit is $200-1+150=349$.\n\nStarting from city $3$: trade in city $3$, profit is $300$.\n\n[Constraints.]\n\nFor $10\\%$ of the testdata, $n\\le 3,m\\le 9$, and $s,t,q,mea_i,dis_i\\le10$.\n\nFor $50\\%$ of the testdata, $n\\le 10,m\\le 100$, and $s,t,q,mea_i,dis_i\\le10$.\n\nFor another $10\\%$ of the testdata, $m=n$, and for any positive integer $i\\in[1,n]$, city $i$ has a route to city $(i\\mod n)+1$.\n\nFor another $10\\%$ of the testdata, for any positive integer $i\\in[1,n]$, if there exists a route $i\\rightarrow j$, then $j>i$.\n\nFor $100\\%$ of the testdata, $n\\le 50,m\\le 500$, and $s,t,q,mea_i,dis_i\\le10^4$.\n\n[Additional Notes.]\n\nCities are numbered from $1$ to $n$.\n\nPlease note the special time limit of this problem.\n\nTo prevent the problem from being too time-tight, this problem **provides [Octaoxygen](https://www.luogu.com.cn/paste/ky1fh8zk)**. You can paste it directly at the very beginning of your code before submitting. It is guaranteed that, after adding Octaoxygen, the maximum running time of the official solution on each test point is less than half of the time limit. Feel free to try your approach.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【L&K R-03】大航海时代", "background": "", "description": "【如果不想看题面请阅读分割线以下部分】\n\n$$\\text{Onde\\space a\\space terra\\space acaba\\space e\\space o\\space mar\\space começa}$$\n\n>_15 世纪末，是一个伟大时代的开始。自此之后，人们开始逐渐认识到大千世界的险恶与奇丽，开始前仆后继地展开一个又一个不可思议的冒险，开始缓缓地驾驭那波涛汹涌、变幻莫测的大海。_\n\n>_15 世纪末，是一个伟大时代的开始。为了征服海洋，人们集人类之智慧，制造出方舟巨轮；汇天地之灵怪，制造出罗盘、六分仪。海上的康庄大道从此建立，人们航行于各地，商贸随之诞生。_\n\n>_15 世纪末，是一个伟大时代的开始。商品与金钱象征着欲望，在海上流动了起来。原先分隔的黄金汇聚成大金库，让人们尝到了商业的甜头。贸易的花朵开遍整个欧洲，航线上船只往来不绝，财富源源不断地从海上涌出。_\n\n>_[更多](https://www.luogu.org/paste/k9bqwpps)_\n\n>……\n\n>_大航海时代，是人类文明崭新的起点。_\n\n海上经商，商人们必须对航路有充分的了解。欧洲的城市不计其数，航路更是数不胜数。当然，人们无需知晓所有城市的位置，更无需清楚所有航路的情况。人们只需要知道，有几个主要城市，并且有几条海上航路连接着它们即可，其他的城市与航路都是次要的，不会带来过多收益。\n\n商船沿着航路往来于城市之间。它们每到一个城市，卸下一些货品，城市里的商人便会根据货品的数目给出相应的报酬。这些报酬由船主收取，并将部分报酬分发给水手们。不过大家并不关心这件事，他们只会关心一艘船获得的总收益。\n\n商船的航行总会伴随着危险与损失。海上的天气难以预测，船只随时都可能会被大浪吞没，或者被飓风刮得千疮百孔。不过这些情况比较特殊，我们并不考虑。我们考虑的是，商船在航行过程中的必要支出。一趟航行往往需要几星期甚至几个月的时间。在这段时间里，船员需要淡水与食物，船也需要适当的维护。人们总结经验发现，一段航行的必要支出与航行距离和载货量有直接关系。\n\n大航海时代的人们就是在这些规律下生活的，考量着商船的支出与收益，缓行于茫茫大海之上，每日如此，单调而无趣。大航海时代，对于大部分人来说，或许并没有那么伟大。\n\n当然，生于现代的我们不必在意这些东西。这也是当然的，现代人怎么会为古代人考虑什么东西呢？\n\n然而，小 L 和小 K 发现他们必须开始考虑这些事物了，因为他们不小心掉进了虫洞，回到了大航海时代。回到过去的他们用唯一的财产：手机，换来了一艘船和一船货物。为了生存，他们要驾驶着这艘船航行于海上，用货物与商人们换取钱财。\n\n----------------------------------\n\n小 L 和小 K 通过调查了解了海上贸易的一些基本规律。共有 $n$ 个主要城市和 $m$ 条连接着它们的航道，船只能沿着这些航道航行。注意航道是单向的，因为如果是双向，航线就容易交叉，发生事故。第 $i$ 条航道的距离为 $dis_i$，若商船在经过此航道时载货量（下称货物量）为 $p$，则航行完此航道需花费 $p\\times dis_i$  的金币。商船到达一个城市，会卸下部分货物与商人交易。每座城市都有一个大商人，会根据 **船上卸下** 的货物量付给商船一定的金币。每座城市的大商人不同，标准也不一样。第 $i$ 座城市的大商人标准为 $mea_i$，若商船在 $i$ 号城市卸下量为 $p$ 的商品，大商人会付给商船 $p\\times mea_i$ 的金币。商船每到达一座城市，只会与大商人进行一次交易。当然，一座城市可以重复到达，每次到达都会与大商人进行交易。\n\n小 L 和小 K 需要遵循这些规律，沿着航道进行海上贸易。小 L 和小 K 在一开始总共有量为 $q$ 的货品。小 L 和小 K 本该精打细算，详细计算出他们在每座城市应该卸下的货物量。但是小 L 和小 K 是懒癌晚期患者，并不想这样做。他们随便想了两个正整数 $s,t$，于是如果需要卸下货物，他们便会卸下总货物量 $\\frac{s}{s+t}$ 的货物。\n\n在他们的商贸之旅开始之前，小 L 和小 K 就已经研究出了回到现代的方法。但是他们并不着急回去。因为回溯时间导致的时空错位，小 L 和小 K 身上的时间是静止的。也就是说他们拥有无限的时间。他们决定利用此原理在这个时代大赚一笔。小 L 和小 K 可以选择从任意一座城市出发。他们希望知道从每座城市出发，可以赚到的最大金币数量是多少。当然因为他们比较懒，这个问题由你来解决。\n\n需要注意的是，尽管在大航海时代分数的运算并没有普及，但小 L 和小 K 为了自己方便而将他们得到的信息部分用分数（有理数）来表示。也就是说，虽然 $dis_i,mea_i,q$ 是由当时的人们给出的，所以是整数，但是货物量和金币量可以是分数，即小 L 和小 K 用有理数的计算法则计算自己的收益。小 L 和小 K 在出发的城市也会进行交易。", "inputFormat": "第一行，五个正整数 $n,m,s,t,q$。\n\n第二行， $n$ 个正整数，第 $i$ 个数表示 $mea_i$。\n\n接下来 $m$ 行，每行三个正整数 $a,b,dis_i$，表示从城市 $a$ 到城市 $b$ 有一条长为 $dis_i$ 的单向航道。", "outputFormat": "共 $n$ 行，第 $i$ 行表示从 $i$ 号城市出发可以赚到的最大金币数量，输出格式见下文。\n\n关于分数的输出格式：\n\n可能以 ```a/b``` 的形式输出，表示分数 $\\frac{a}{b}$，其中 $a,b$ 为正整数。也可能以 ```-a/b``` 的形式输出，表示分数 $-\\frac{a}{b}$，其中 $a,b$ 为正整数。也可能以 ```a``` 的形式输出，表示**整数** $a$。注意 $\\gcd(a,b)$ 一定为 $1$。如果 $b$ 为 $1$，则必须以 ```a``` 的形式输出。", "hint": "【样例说明】\n\n$\\frac{s}{s+t}=\\frac{1}{2}$，小 L 和小 K 每次会卸下一半的货物进行交易。\n\n从 $1$ 号城市出发：先在 $1$ 号城市进行交易，用 $2\\times\\frac{1}{2}=1$ 的货物量交易，获得金币 $1\\times 100=100$，剩余货物量 $2-1=1$。之后如果走 $1\\rightarrow1$ 的航道，会再花费 $1\\times 50=50$ 的金币回到城市 $1$，很不划算。如果走 $1\\rightarrow2$ 的航道，只需要再花费 $1\\times 2=2$ 的金币就可以到达城市 $2$。到达城市 $2$ 进行交易，用 $1\\times\\frac{1}{2}=\\frac{1}{2}$ 的货物量交易，获得金币 $\\frac{1}{2}\\times 200=100$，剩余货物量 $1-\\frac{1}{2}=\\frac{1}{2}$。接下来走 $2\\rightarrow3$，花费 $\\frac{1}{2}\\times1=\\frac{1}{2}$ 的金币。到达城市 $3$，用 $\\frac{1}{2}\\times\\frac{1}{2}=\\frac{1}{4}$的货物量交易，交易获得金币 $\\frac{1}{4}\\times300=75$，剩余货物量 $\\frac{1}{2}-\\frac{1}{4}=\\frac{1}{4}$。总获利 $100-2+100-\\frac{1}{2}+75=\\frac{545}{2}$。\n\n从 $2$ 号城市出发：走 $2\\rightarrow3$，在 $2,3$ 号城市交易，获利 $200-1+150=349$。\n\n从 $3$ 号城市出发：在 $3$ 号城市交易，获利 $300$。\n\n【数据范围】\n\n对于 $10\\%$ 的数据，$n\\le 3,m\\le 9$，$s,t,q,mea_i,dis_i\\le10$。\n\n对于 $50\\%$ 的数据，$n\\le 10,m\\le 100$，$s,t,q,mea_i,dis_i\\le10$。\n\n对于另外 $10\\%$ 数据，$m=n$，且对于任意正整数 $i\\in[1,n]$，编号为 $i$ 的城市有一条到编号为 $(i\\mod n)+1$ 的城市的航道。\n\n对于另外 $10\\%$ 数据，对于任意正整数 $i\\in[1,n]$，若存在航道 \n $i\\rightarrow j$，则 $j>i$。\n\n对于 $100\\%$ 的数据，$n\\le 50,m\\le 500$，$s,t,q,mea_i,dis_i\\le10^4$。\n\n【补充说明】\n\n城市从 $1$ 到 $n$ 编号。\n\n请注意本题特殊的时空限制。\n\n为了防止题目过于卡常，本题 **提供 [八聚氧](https://www.luogu.com.cn/paste/ky1fh8zk)** ，直接加在代码最前提交即可。保证标程在加上八聚氧后通过每个数据点的最大用时小于时限的一半。请大胆尝试解法。", "locale": "zh-CN"}}}
{"pid": "P5823", "type": "P", "difficulty": 3, "samples": [["3", "1 2 3 1 3 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "洛谷原创", "Special Judge", "构造"], "title": "【L&K R-03】课表的排列", "background": "小 L 早上来到教室，发现今天的课表非常有趣。", "description": "今天的课表是：\n\n    语文 数学 英语 语文 英语 数学\n\n今天的课表上一共有三个科目：语文、数学、英语。每个科目都有两节课。每科的两节课间隔的课程数分别为 $2,3,1$，从小到大排序后为 $1,2,3$，是一个公差为 $1$ 的等差数列。\n\n小 L 想知道，对于更多的科目，具有这样有趣性质的课表是否存在。换句话说，如果课表上一共有 $n$ 个科目，每个科目都有且仅有两节课，小 L 想知道是否存在一个课表，满足这 $n$ 科的两节课间隔的课程数从小到大排序后是一个公差为 $1$ 的等差数列。\n\n但是，小 L 只会写时间复杂度为 $O((2n)!\\times n\\log_2 n)$ 的算法，于是他求助于你，请你判断是否存在这样的课表，如果存在，还要输出一种可能的情况。", "inputFormat": "输入仅一行，一个 **奇数** $n$，表示课表上的课程数。", "outputFormat": "输出仅一行。\n\n如果不存在这样的课表，输出  `-1`；\n\n如果存在这样的课表，输出 $2n$ 个整数，表示课表。令 $1,2,\\ldots ,n$ 中的每一个整数对应一个科目，每个整数在课表中均会出现两次，且满足小 L 的性质。由于可能有多种可能的答案，你可以给出任意一种课表，刚到教室的小 K 会写出程序来检验你的课表是否满足小 L 的性质。", "hint": "**本题使用 Special Judge。**\n\n本题共 $20$ 个数据点，每个数据点 $5$ 分。\n\n| 数据编号$~x$ | $n=$ |\n| :-----------: | :-----------: |\n| $1\\sim 10$ | $2x+1$ |\n| $11\\sim 15$ | $200x+1$ |\n| $16\\sim 20$ | $100000x+1$ |", "locale": "zh-CN", "translations": {"en": {"title": "[L&K R-03] Timetable Arrangement", "background": "Little L came to the classroom in the morning and found today’s timetable very interesting.", "description": "Today’s timetable is:\n\n    Chinese Math English Chinese English Math\n\nThere are three subjects on today’s timetable: Chinese, Math, and English. Each subject has two classes. For each subject, the number of classes between its two occurrences is $2,3,1$. After sorting these numbers from small to large, we get $1,2,3$, which is an arithmetic sequence with common difference $1$.\n\nLittle L wants to know whether a timetable with the same interesting property exists for more subjects. In other words, if there are $n$ subjects on the timetable, and each subject appears exactly twice, Little L wants to know whether there exists a timetable such that, after sorting the numbers of classes between the two classes of each of the $n$ subjects from small to large, the result is an arithmetic sequence with common difference $1$.\n\nHowever, Little L can only write an algorithm with time complexity $O((2n)!\\times n\\log_2 n)$, so he asks you for help. You need to determine whether such a timetable exists. If it exists, you also need to output one possible timetable.", "inputFormat": "The input contains only one line: an **odd** integer $n$, representing the number of subjects on the timetable.", "outputFormat": "Output only one line.\n\nIf no such timetable exists, output `-1`.\n\nIf such a timetable exists, output $2n$ integers representing the timetable. Let each integer in $1,2,\\ldots,n$ correspond to one subject. Each integer appears exactly twice in the timetable, and the timetable must satisfy Little L’s property. Since there may be multiple valid answers, you may output any one. Little K, who has just arrived at the classroom, will write a program to check whether your timetable satisfies Little L’s property.", "hint": "**This problem uses Special Judge.**\n\nThere are $20$ test points in total, and each test point is worth $5$ points.\n\n| Data Index $~x$ | $n=$ |\n| :-----------: | :-----------: |\n| $1\\sim 10$ | $2x+1$ |\n| $11\\sim 15$ | $200x+1$ |\n| $16\\sim 20$ | $100000x+1$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【L&K R-03】课表的排列", "background": "小 L 早上来到教室，发现今天的课表非常有趣。", "description": "今天的课表是：\n\n    语文 数学 英语 语文 英语 数学\n\n今天的课表上一共有三个科目：语文、数学、英语。每个科目都有两节课。每科的两节课间隔的课程数分别为 $2,3,1$，从小到大排序后为 $1,2,3$，是一个公差为 $1$ 的等差数列。\n\n小 L 想知道，对于更多的科目，具有这样有趣性质的课表是否存在。换句话说，如果课表上一共有 $n$ 个科目，每个科目都有且仅有两节课，小 L 想知道是否存在一个课表，满足这 $n$ 科的两节课间隔的课程数从小到大排序后是一个公差为 $1$ 的等差数列。\n\n但是，小 L 只会写时间复杂度为 $O((2n)!\\times n\\log_2 n)$ 的算法，于是他求助于你，请你判断是否存在这样的课表，如果存在，还要输出一种可能的情况。", "inputFormat": "输入仅一行，一个 **奇数** $n$，表示课表上的课程数。", "outputFormat": "输出仅一行。\n\n如果不存在这样的课表，输出  `-1`；\n\n如果存在这样的课表，输出 $2n$ 个整数，表示课表。令 $1,2,\\ldots ,n$ 中的每一个整数对应一个科目，每个整数在课表中均会出现两次，且满足小 L 的性质。由于可能有多种可能的答案，你可以给出任意一种课表，刚到教室的小 K 会写出程序来检验你的课表是否满足小 L 的性质。", "hint": "**本题使用 Special Judge。**\n\n本题共 $20$ 个数据点，每个数据点 $5$ 分。\n\n| 数据编号$~x$ | $n=$ |\n| :-----------: | :-----------: |\n| $1\\sim 10$ | $2x+1$ |\n| $11\\sim 15$ | $200x+1$ |\n| $16\\sim 20$ | $100000x+1$ |", "locale": "zh-CN"}}}
{"pid": "P5824", "type": "P", "difficulty": 7, "samples": [["13 6", "83517427\n0\n721878522\n19628064\n0\n9321312\n8568\n0\n792\n71\n0\n14"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "O2优化", "组合数学", "生成函数", "快速傅里叶变换 FFT", "快速数论变换 NTT"], "title": "十二重计数法", "background": "组合数学是一门古老而迷人的学科。\n\n传说早在 $114514$ 年前，一位名为忆哀的神灵来到地球，发现了人类——另一种有智慧的物种。  \n\n她觉得这很有趣，为了加速人类文明的发展，她向人间传下了一类计数问题——十二重计数，这也正是组合数学的开端。  \n\n而只有搞明白这类问题，才能在组合数学上继续深入。", "description": "有 $n$ 个球和 $m$ 个盒子，球要全部装进盒子里。  \n还有一些限制条件，那么有多少种方法放球？（与放的先后顺序无关）  \n\n限制条件分别如下：    \n\n$\\text{I}$：球之间互不相同，盒子之间互不相同。    \n$\\text{II}$：球之间互不相同，盒子之间互不相同，每个盒子至多装一个球。   \n$\\text{III}$：球之间互不相同，盒子之间互不相同，每个盒子至少装一个球。  \n\n$\\text{IV}$：球之间互不相同，盒子全部相同。        \n$\\text{V}$：球之间互不相同，盒子全部相同，每个盒子至多装一个球。   \n$\\text{VI}$：球之间互不相同，盒子全部相同，每个盒子至少装一个球。\n\n$\\text{VII}$：球全部相同，盒子之间互不相同。  \n$\\text{VIII}$：球全部相同，盒子之间互不相同，每个盒子至多装一个球。  \n$\\text{IX}$：球全部相同，盒子之间互不相同，每个盒子至少装一个球。   \n\n$\\text{X}$：球全部相同，盒子全部相同。   \n$\\text{XI}$：球全部相同，盒子全部相同，每个盒子至多装一个球。  \n$\\text{XII}$：球全部相同，盒子全部相同，每个盒子至少装一个球。\n\n由于答案可能很大，所以要对 $998244353$ 取模。", "inputFormat": "仅一行两个正整数 $n,m$。", "outputFormat": "输出十二行，每行一个整数，对应每一种限制条件的答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n,m \\le 2\\times 10^5$。\n\norz $\\mathsf E \\color{red}\\mathsf{ntropyIncreaser}$。", "locale": "zh-CN", "translations": {"en": {"title": "Twelvefold Counting Method", "background": "Combinatorics is an old and fascinating subject.\n\nLegend has it that as early as $114514$ years ago, a deity named Yi Ai came to Earth and discovered humans—another intelligent species.\n\nShe found this very interesting. In order to speed up the development of human civilization, she passed down to the human world a type of counting problem—the twelvefold counting. This was also the beginning of combinatorics.\n\nOnly by figuring out this type of problem can one continue to go deeper in combinatorics.", "description": "There are $n$ balls and $m$ boxes, and all balls must be put into the boxes.\nThere are also some constraints. How many ways are there to place the balls? (The order of placing does not matter.)\n\nThe constraints are as follows:\n\n$\\text{I}$: All balls are distinct, and all boxes are distinct.  \n$\\text{II}$: All balls are distinct, and all boxes are distinct; each box holds at most one ball.  \n$\\text{III}$: All balls are distinct, and all boxes are distinct; each box holds at least one ball.\n\n$\\text{IV}$: All balls are distinct, and all boxes are identical.  \n$\\text{V}$: All balls are distinct, and all boxes are identical; each box holds at most one ball.  \n$\\text{VI}$: All balls are distinct, and all boxes are identical; each box holds at least one ball.\n\n$\\text{VII}$: All balls are identical, and all boxes are distinct.  \n$\\text{VIII}$: All balls are identical, and all boxes are distinct; each box holds at most one ball.  \n$\\text{IX}$: All balls are identical, and all boxes are distinct; each box holds at least one ball.\n\n$\\text{X}$: All balls are identical, and all boxes are identical.  \n$\\text{XI}$: All balls are identical, and all boxes are identical; each box holds at most one ball.  \n$\\text{XII}$: All balls are identical, and all boxes are identical; each box holds at least one ball.\n\nSince the answer may be very large, take it modulo $998244353$.", "inputFormat": "Only one line with two positive integers $n,m$.", "outputFormat": "Output twelve lines. Each line contains one integer, corresponding to the answer under each constraint.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1\\le n,m \\le 2\\times 10^5$.\n\norz $\\mathsf E \\color{red}\\mathsf{ntropyIncreaser}$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "十二重计数法", "background": "组合数学是一门古老而迷人的学科。\n\n传说早在 $114514$ 年前，一位名为忆哀的神灵来到地球，发现了人类——另一种有智慧的物种。  \n\n她觉得这很有趣，为了加速人类文明的发展，她向人间传下了一类计数问题——十二重计数，这也正是组合数学的开端。  \n\n而只有搞明白这类问题，才能在组合数学上继续深入。", "description": "有 $n$ 个球和 $m$ 个盒子，球要全部装进盒子里。  \n还有一些限制条件，那么有多少种方法放球？（与放的先后顺序无关）  \n\n限制条件分别如下：    \n\n$\\text{I}$：球之间互不相同，盒子之间互不相同。    \n$\\text{II}$：球之间互不相同，盒子之间互不相同，每个盒子至多装一个球。   \n$\\text{III}$：球之间互不相同，盒子之间互不相同，每个盒子至少装一个球。  \n\n$\\text{IV}$：球之间互不相同，盒子全部相同。        \n$\\text{V}$：球之间互不相同，盒子全部相同，每个盒子至多装一个球。   \n$\\text{VI}$：球之间互不相同，盒子全部相同，每个盒子至少装一个球。\n\n$\\text{VII}$：球全部相同，盒子之间互不相同。  \n$\\text{VIII}$：球全部相同，盒子之间互不相同，每个盒子至多装一个球。  \n$\\text{IX}$：球全部相同，盒子之间互不相同，每个盒子至少装一个球。   \n\n$\\text{X}$：球全部相同，盒子全部相同。   \n$\\text{XI}$：球全部相同，盒子全部相同，每个盒子至多装一个球。  \n$\\text{XII}$：球全部相同，盒子全部相同，每个盒子至少装一个球。\n\n由于答案可能很大，所以要对 $998244353$ 取模。", "inputFormat": "仅一行两个正整数 $n,m$。", "outputFormat": "输出十二行，每行一个整数，对应每一种限制条件的答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n,m \\le 2\\times 10^5$。\n\norz $\\mathsf E \\color{red}\\mathsf{ntropyIncreaser}$。", "locale": "zh-CN"}}}
{"pid": "P5825", "type": "P", "difficulty": 6, "samples": [["4", "1 11 11 1 0"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "组合数学", "Stirling 数", "生成函数", "快速傅里叶变换 FFT", "快速数论变换 NTT"], "title": "排列计数", "background": "", "description": "我们记一个排列 $P$ 的升高为 $k$ 当且仅当存在 $k$ 个位置 $i$ 使得 $P_i<P_{i+1}$。\n\n现在给定排列长度 $n$，对于所有整数 $k\\in [0,n]$ 求有多少个排列的升高为 $k$。", "inputFormat": "一个整数 $n$。", "outputFormat": "一行，$n+1$ 个整数，第 $i$ 个整数表示长度为 $n$ 且升高为 $i-1$ 个排列的个数，对 $998244353$ 取模。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 2\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Permutation Ascent Counting", "background": "", "description": "We say a permutation $P$ has $k$ ascents if and only if there exist $k$ positions $i$ such that $P_i < P_{i+1}$.\n\nNow given the permutation length $n$, for all integers $k \\in [0, n]$, find how many permutations have exactly $k$ ascents.", "inputFormat": "An integer $n$.", "outputFormat": "One line with $n + 1$ integers. The $i$-th integer indicates the number of permutations of length $n$ with exactly $i - 1$ ascents, taken modulo $998244353$.", "hint": "For $100\\%$ of the testdata, $1 \\leq n \\leq 2 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "排列计数", "background": "", "description": "我们记一个排列 $P$ 的升高为 $k$ 当且仅当存在 $k$ 个位置 $i$ 使得 $P_i<P_{i+1}$。\n\n现在给定排列长度 $n$，对于所有整数 $k\\in [0,n]$ 求有多少个排列的升高为 $k$。", "inputFormat": "一个整数 $n$。", "outputFormat": "一行，$n+1$ 个整数，第 $i$ 个整数表示长度为 $n$ 且升高为 $i-1$ 个排列的个数，对 $998244353$ 取模。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 2\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5826", "type": "P", "difficulty": 5, "samples": [["0 5 5 5\n1 3 2 2 4\n3 1 5 2\n2 3 2\n3 1 2 3\n3 1 2 4\n5 1 3 2 2 4\n", "No\nYes\nNo\nYes\nYes"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["字符串", "线段树", "O2优化", "可持久化", "有限状态自动机", "模板题"], "title": "【模板】子序列自动机", "background": "本题中，若 $x$ 是 $y$ 的子序列，则等价于存在一个**单调递增**序列 $z$，满足 $|z| = |x|$，$z_{|x|} \\leq |y|$，且 $\\forall i \\in [1, ~|x|],~y_{z_i} = x_i$。其中 $|x|,~|y|,~|z|$ 分别代表序列 $x,~y,~z$ 的长度，$x_i,~y_i,~z_i$ 分别代表序列 $x,~y,~z$ 的第 $i$ 项。\n\n这是一道在 ``yLOI2020`` 备选题里被毙掉的题目。", "description": "给定一个长度为 $n$ 的正整数序列 $a$ ，有 $q$ 次询问，第 $i$ 次询问给定一个长度为 $L_i$ 的序列 $b_i$，请你判断 $b_i$ 是不是 $a$ 的子序列。序列 $a$ 和所有 $b_i$ 中的元素都不大于一个给定的正整数 $m$。", "inputFormat": "每个测试点有且仅有一组数据。\n\n输入的第一行是四个用空格隔开的整数，分别代表 $type,~n,~q,~m$。其中 $type$ 代表测试点所在的子任务编号，其余变量的含义见【题目描述】。\n\n输入的第二行是 $n$ 个用空格隔开的整数，第 $i$ 个数字代表序列 $a$ 的第 $i$ 个元素 $a_i$。\n\n第 $3$ 行至第 $(q + 2)$ 行，每行代表一次询问。第 $(i + 2)$ 行的输入格式为：\n\n- 第 $(i + 2)$ 行的行首有一个整数 $l_i$，代表第 $i$ 次询问的序列长度。一个空格后有 $l_i$ 个用空格隔开的整数。该行的第 $(j + 1)$ 个整数代表序列 $b_i$ 的第 $j$ 个元素 $b_{i, j}$。", "outputFormat": "对于每次询问，输出一行一个字符串，若给定的序列是 $a$ 的子序列，则输出 `Yes`，否则输出 `No`。", "hint": "#### 样例 1 解释\n\n- 对于第一次询问，原序列中没有 $5$，所以给定序列显然不是原序列的子序列。\n- 对于第二次询问，存在两个合法的序列 $z$，分别是 $\\{2,~3\\}$ 和 $\\{2,~4\\}$。即 $a_{2} = b_{2, 1},~a_3 = b_{2, 2}$ 或 $a_2 = b_{2, 1},~a_{4} = b_{2, 2}$。这里 $b_{i, j}$ 代表序列 $b_i$ 的第 $j$ 个元素，序列 $z$ 的含义见【题目背景】，下同。\n- 对于第三次询问，不存在合法的序列 $z$。\n- 对于第四次询问，存在两个合法的序列 $z$，分别是 $\\{1,~3,~5\\}$ 和 $\\{1,~4,~5\\}$。\n- 对于第五次询问，存在一个合法的序列 $z$，为 $\\{1,~2,~3,~4,~5\\}$。\n\n#### 数据范围与约定\n\n**本题采用多测试点捆绑测试，共有 3 个子任务**。\n\n- Subtask 1（20 points）：$type = 1$，$n, q, m \\leq 100$，$\\sum_{i = 1}^{q} l_i \\leq 10^3$。\n- Subtask 2（35 points）：$type = 2$，$n,q \\leq 10^5$，$m \\leq 26$，$\\sum_{i = 1}^{q} l_i \\leq 10^6$。\n- Subtask 3（45 points）：$type = 3$，$n,q,m \\leq 10^5$，$\\sum_{i = 1}^q L_i \\leq 10^6$。\n\n对于全部的测试点，保证 $1 \\leq n, m, q \\leq 10^5$，$1 \\leq a_i, b_{i, j} \\leq m$，$1 \\leq l_i \\leq 10^6$，$\\sum_{i = 1}^{q} l_i \\leq 10^6$。\n\n\n### 提示\n\n- 请注意常数因子对程序效率造成的影响。\n- 本题输入规模较大，请注意数据读入对程序效率造成的影响。\n- 请注意输入第一行的顺序为先输入询问次数 $q$，再输入序列元素最大值 $m$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Subsequence Automaton.", "background": "In this problem, if $x$ is a subsequence of $y$, then it is equivalent to the existence of a **strictly increasing** sequence $z$ such that $|z| = |x|$, $z_{|x|} \\leq |y|$, and $\\forall i \\in [1, ~|x|],~y_{z_i} = x_i$. Here $|x|,~|y|,~|z|$ denote the lengths of sequences $x,~y,~z$, and $x_i,~y_i,~z_i$ denote the $i$-th element of sequences $x,~y,~z$.\n\nThis problem was rejected in the backup problem set of ``yLOI2020``.", "description": "Given a positive integer sequence $a$ of length $n$, there are $q$ queries. In the $i$-th query, a sequence $b_i$ of length $L_i$ is given. You need to determine whether $b_i$ is a subsequence of $a$. All elements in sequence $a$ and all $b_i$ are no greater than a given positive integer $m$.", "inputFormat": "Each test case contains exactly one dataset.\n\nThe first line contains four integers separated by spaces: $type,~n,~q,~m$. Here $type$ indicates the subtask number of the test point, and the meanings of the other variables are the same as in the Description.\n\nThe second line contains $n$ integers separated by spaces. The $i$-th number is the $i$-th element $a_i$ of sequence $a$.\n\nLines $3$ to $(q + 2)$ each represent a query. The input format of line $(i + 2)$ is:\n\n- At the beginning of line $(i + 2)$ there is an integer $l_i$, which is the length of the sequence in the $i$-th query. After one space, there are $l_i$ integers separated by spaces. The $(j + 1)$-th integer on this line is the $j$-th element $b_{i, j}$ of sequence $b_i$.", "outputFormat": "For each query, output one string per line. If the given sequence is a subsequence of $a$, output `Yes`; otherwise output `No`.", "hint": "#### Explanation for Sample 1\n\n- For the first query, there is no $5$ in the original sequence, so the given sequence is obviously not a subsequence of the original sequence.\n- For the second query, there are two valid sequences $z$, which are $\\{2,~3\\}$ and $\\{2,~4\\}$. That is, $a_{2} = b_{2, 1},~a_3 = b_{2, 2}$ or $a_2 = b_{2, 1},~a_{4} = b_{2, 2}$. Here $b_{i, j}$ denotes the $j$-th element of sequence $b_i$. The meaning of sequence $z$ is given in the Background, and the same below.\n- For the third query, there is no valid sequence $z$.\n- For the fourth query, there are two valid sequences $z$, which are $\\{1,~3,~5\\}$ and $\\{1,~4,~5\\}$.\n- For the fifth query, there is one valid sequence $z$, which is $\\{1,~2,~3,~4,~5\\}$.\n\n#### Constraints and Conventions\n\n**This problem uses bundled multi-point testing, with a total of 3 subtasks**.\n\n- Subtask 1 (20 points): $type = 1$, $n, q, m \\leq 100$, $\\sum_{i = 1}^{q} l_i \\leq 10^3$.\n- Subtask 2 (35 points): $type = 2$, $n,q \\leq 10^5$, $m \\leq 26$, $\\sum_{i = 1}^{q} l_i \\leq 10^6$.\n- Subtask 3 (45 points): $type = 3$, $n,q,m \\leq 10^5$, $\\sum_{i = 1}^q L_i \\leq 10^6$.\n\nFor all test points, it is guaranteed that $1 \\leq n, m, q \\leq 10^5$, $1 \\leq a_i, b_{i, j} \\leq m$, $1 \\leq l_i \\leq 10^6$, and $\\sum_{i = 1}^{q} l_i \\leq 10^6$.\n\n### Notes\n\n- Please pay attention to the impact of constant factors on program efficiency.\n- The input size of this problem is large, so please pay attention to input reading efficiency.\n- Please note that in the first line of input, the order is to input the number of queries $q$ first, and then the maximum value $m$ of sequence elements.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】子序列自动机", "background": "本题中，若 $x$ 是 $y$ 的子序列，则等价于存在一个**单调递增**序列 $z$，满足 $|z| = |x|$，$z_{|x|} \\leq |y|$，且 $\\forall i \\in [1, ~|x|],~y_{z_i} = x_i$。其中 $|x|,~|y|,~|z|$ 分别代表序列 $x,~y,~z$ 的长度，$x_i,~y_i,~z_i$ 分别代表序列 $x,~y,~z$ 的第 $i$ 项。\n\n这是一道在 ``yLOI2020`` 备选题里被毙掉的题目。", "description": "给定一个长度为 $n$ 的正整数序列 $a$ ，有 $q$ 次询问，第 $i$ 次询问给定一个长度为 $L_i$ 的序列 $b_i$，请你判断 $b_i$ 是不是 $a$ 的子序列。序列 $a$ 和所有 $b_i$ 中的元素都不大于一个给定的正整数 $m$。", "inputFormat": "每个测试点有且仅有一组数据。\n\n输入的第一行是四个用空格隔开的整数，分别代表 $type,~n,~q,~m$。其中 $type$ 代表测试点所在的子任务编号，其余变量的含义见【题目描述】。\n\n输入的第二行是 $n$ 个用空格隔开的整数，第 $i$ 个数字代表序列 $a$ 的第 $i$ 个元素 $a_i$。\n\n第 $3$ 行至第 $(q + 2)$ 行，每行代表一次询问。第 $(i + 2)$ 行的输入格式为：\n\n- 第 $(i + 2)$ 行的行首有一个整数 $l_i$，代表第 $i$ 次询问的序列长度。一个空格后有 $l_i$ 个用空格隔开的整数。该行的第 $(j + 1)$ 个整数代表序列 $b_i$ 的第 $j$ 个元素 $b_{i, j}$。", "outputFormat": "对于每次询问，输出一行一个字符串，若给定的序列是 $a$ 的子序列，则输出 `Yes`，否则输出 `No`。", "hint": "#### 样例 1 解释\n\n- 对于第一次询问，原序列中没有 $5$，所以给定序列显然不是原序列的子序列。\n- 对于第二次询问，存在两个合法的序列 $z$，分别是 $\\{2,~3\\}$ 和 $\\{2,~4\\}$。即 $a_{2} = b_{2, 1},~a_3 = b_{2, 2}$ 或 $a_2 = b_{2, 1},~a_{4} = b_{2, 2}$。这里 $b_{i, j}$ 代表序列 $b_i$ 的第 $j$ 个元素，序列 $z$ 的含义见【题目背景】，下同。\n- 对于第三次询问，不存在合法的序列 $z$。\n- 对于第四次询问，存在两个合法的序列 $z$，分别是 $\\{1,~3,~5\\}$ 和 $\\{1,~4,~5\\}$。\n- 对于第五次询问，存在一个合法的序列 $z$，为 $\\{1,~2,~3,~4,~5\\}$。\n\n#### 数据范围与约定\n\n**本题采用多测试点捆绑测试，共有 3 个子任务**。\n\n- Subtask 1（20 points）：$type = 1$，$n, q, m \\leq 100$，$\\sum_{i = 1}^{q} l_i \\leq 10^3$。\n- Subtask 2（35 points）：$type = 2$，$n,q \\leq 10^5$，$m \\leq 26$，$\\sum_{i = 1}^{q} l_i \\leq 10^6$。\n- Subtask 3（45 points）：$type = 3$，$n,q,m \\leq 10^5$，$\\sum_{i = 1}^q L_i \\leq 10^6$。\n\n对于全部的测试点，保证 $1 \\leq n, m, q \\leq 10^5$，$1 \\leq a_i, b_{i, j} \\leq m$，$1 \\leq l_i \\leq 10^6$，$\\sum_{i = 1}^{q} l_i \\leq 10^6$。\n\n\n### 提示\n\n- 请注意常数因子对程序效率造成的影响。\n- 本题输入规模较大，请注意数据读入对程序效率造成的影响。\n- 请注意输入第一行的顺序为先输入询问次数 $q$，再输入序列元素最大值 $m$。", "locale": "zh-CN"}}}
{"pid": "P5827", "type": "P", "difficulty": 7, "samples": [["1\n2\n3\n4\n5\n", "1\n1\n1\n10\n238\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "O2优化", "组合数学", "生成函数", "快速傅里叶变换 FFT", "快速数论变换 NTT"], "title": "点双连通图计数", "background": "", "description": "求 $n$ 个点的有标号点双连通图（简单无向图，整个图是一个点双连通分量）的个数，答案对 $998244353$ 取模。", "inputFormat": "共五行，每行一个整数 $n$，表示一次询问。", "outputFormat": "共五行，每行一个整数，表示一次询问的答案。", "hint": "$1 \\le n \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Counting Labeled Biconnected Graphs", "background": "　", "description": "Find the number of labeled vertex-biconnected graphs on $n$ vertices (a simple undirected graph, and the whole graph is one vertex-biconnected component). Output the answer modulo $998244353$.", "inputFormat": "There are five lines in total. Each line contains one integer $n$, representing one query.", "outputFormat": "There are five lines in total. Each line contains one integer, representing the answer to one query.", "hint": "Constraints: $1 \\le n \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "点双连通图计数", "background": "", "description": "求 $n$ 个点的有标号点双连通图（简单无向图，整个图是一个点双连通分量）的个数，答案对 $998244353$ 取模。", "inputFormat": "共五行，每行一个整数 $n$，表示一次询问。", "outputFormat": "共五行，每行一个整数，表示一次询问的答案。", "hint": "$1 \\le n \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5828", "type": "P", "difficulty": 7, "samples": [["1\n2\n3\n4\n5\n", "1\n0\n1\n10\n253\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "O2优化", "组合数学", "生成函数", "快速傅里叶变换 FFT", "快速数论变换 NTT"], "title": "边双连通图计数", "background": "", "description": "求 $n$ 个点的有标号边双连通图（简单无向图，整个图是一个边双连通分量）的个数，答案对 $998244353$ 取模。", "inputFormat": "共五行，每行一个整数 $n$，表示一次询问。", "outputFormat": "共五行，每行一个整数，表示一次询问的答案。", "hint": "$1 \\le n \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Counting Edge-Biconnected Graphs", "background": "", "description": "Find the number of labeled edge-biconnected graphs on $n$ vertices (simple undirected graphs where the whole graph is a single edge-biconnected component). Output the answer modulo $998244353$.", "inputFormat": "There are five lines in total. Each line contains one integer $n$, representing one query.", "outputFormat": "There are five lines in total. Each line contains one integer, representing the answer to one query.", "hint": "Constraints: $1 \\le n \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "边双连通图计数", "background": "", "description": "求 $n$ 个点的有标号边双连通图（简单无向图，整个图是一个边双连通分量）的个数，答案对 $998244353$ 取模。", "inputFormat": "共五行，每行一个整数 $n$，表示一次询问。", "outputFormat": "共五行，每行一个整数，表示一次询问的答案。", "hint": "$1 \\le n \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5829", "type": "P", "difficulty": 5, "samples": [["aaaabbabbaa\n5\n2 4\n7 10\n3 4\n1 2\n4 11\n", "1\n1\n2\n0\n2\n"], ["zzaaccaazzccaacczz\n3\n2 18\n10 18\n3 5\n", "1\n2\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "树形数据结构", "最近公共祖先 LCA", "KMP 算法", "模板题"], "title": "【模板】失配树", "background": "", "description": "给定一个字符串 $s$，定义它的 **$k$ 前缀** $\\mathit{pre}_k$ 为字符串 $s_{1\\dots k}$，**$k$ 后缀** $\\mathit{suf}_k$ 为字符串 $s_{|s|-k+1\\dots |s|}$，其中 $1 \\le k \\le |s|$。\n\n定义 $\\bold{Border}(s)$ 为**对于 $i \\in [1, |s|)$，满足 $\\mathit{pre}_i = \\mathit{suf}_i$** 的字符串 $\\mathit{pre}_i$ 的集合。$\\bold{Border}(s)$ 中的每个元素都称之为字符串 $s$ 的 $\\operatorname{border}$。\n\n有 $m$ 组询问，每组询问给定 $p,q$，求 $s$ 的 **$\\boldsymbol{p}$ 前缀** 和 **$\\boldsymbol{q}$ 前缀** 的 **最长公共 $\\operatorname{border}$**  的长度。", "inputFormat": "第一行一个字符串 $s$。\n\n第二行一个整数 $m$。\n\n接下来 $m$ 行，每行两个整数 $p,q$。", "outputFormat": "对于每组询问，一行一个整数，表示答案。若不存在公共 $\\operatorname{border}$，请输出 $0$。", "hint": "样例 $2$ 说明：\n\n对于第一个询问，$2$ 前缀和 $18$ 前缀分别是 ``zz`` 和 ``zzaaccaazzccaacczz``，由于 ``zz`` 只有一个 $\\operatorname{border}$，即 ``z``，故最长公共 $\\operatorname{border}$ 长度为 $1$。\n\n---\n\n对于 $16\\%$ 的数据，$s$ 中的字符全部相等。\n\n对于 $100\\%$ 的数据，$1\\leq p,q \\le |s|\\leq 10^6$，$1 \\leq m \\leq 10^5$，$s_i \\in [\\texttt{a}, \\texttt{z}]$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Failure Tree.", "background": "", "description": "Given a string $s$, define its **$k$-prefix** $\\mathit{pre}_k$ as the substring $s_{1\\dots k}$, and its **$k$-suffix** $\\mathit{suf}_k$ as the substring $s_{|s|-k+1\\dots |s|}$, where $1 \\le k \\le |s|$.\n\nDefine $\\bold{Border}(s)$ as the set of strings $\\mathit{pre}_i$ that satisfy **for $i \\in [1, |s|)$, $\\mathit{pre}_i = \\mathit{suf}_i$**. Each element in $\\bold{Border}(s)$ is called a $\\operatorname{border}$ of the string $s$.\n\nThere are $m$ queries. Each query gives $p, q$. Find the length of the **longest common $\\operatorname{border}$** of the **$\\boldsymbol{p}$-prefix** and the **$\\boldsymbol{q}$-prefix** of $s$.", "inputFormat": "The first line contains a string $s$.\n\nThe second line contains an integer $m$.\n\nThe next $m$ lines each contain two integers $p, q$.", "outputFormat": "For each query, output one integer per line, representing the answer. If there is no common $\\operatorname{border}$, output $0$.", "hint": "Explanation for Sample 2:\n\nFor the first query, the $2$-prefix and the $18$-prefix are ``zz`` and ``zzaaccaazzccaacczz``. Since ``zz`` has only one $\\operatorname{border}$, namely ``z``, the length of the longest common $\\operatorname{border}$ is $1$.\n\n---\n\nFor $16\\%$ of the testdata, all characters in $s$ are the same.\n\nFor $100\\%$ of the testdata, $1\\leq p,q \\le |s|\\leq 10^6$, $1 \\leq m \\leq 10^5$, and $s_i \\in [\\texttt{a}, \\texttt{z}]$.\n\nConstraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】失配树", "background": "", "description": "给定一个字符串 $s$，定义它的 **$k$ 前缀** $\\mathit{pre}_k$ 为字符串 $s_{1\\dots k}$，**$k$ 后缀** $\\mathit{suf}_k$ 为字符串 $s_{|s|-k+1\\dots |s|}$，其中 $1 \\le k \\le |s|$。\n\n定义 $\\bold{Border}(s)$ 为**对于 $i \\in [1, |s|)$，满足 $\\mathit{pre}_i = \\mathit{suf}_i$** 的字符串 $\\mathit{pre}_i$ 的集合。$\\bold{Border}(s)$ 中的每个元素都称之为字符串 $s$ 的 $\\operatorname{border}$。\n\n有 $m$ 组询问，每组询问给定 $p,q$，求 $s$ 的 **$\\boldsymbol{p}$ 前缀** 和 **$\\boldsymbol{q}$ 前缀** 的 **最长公共 $\\operatorname{border}$**  的长度。", "inputFormat": "第一行一个字符串 $s$。\n\n第二行一个整数 $m$。\n\n接下来 $m$ 行，每行两个整数 $p,q$。", "outputFormat": "对于每组询问，一行一个整数，表示答案。若不存在公共 $\\operatorname{border}$，请输出 $0$。", "hint": "样例 $2$ 说明：\n\n对于第一个询问，$2$ 前缀和 $18$ 前缀分别是 ``zz`` 和 ``zzaaccaazzccaacczz``，由于 ``zz`` 只有一个 $\\operatorname{border}$，即 ``z``，故最长公共 $\\operatorname{border}$ 长度为 $1$。\n\n---\n\n对于 $16\\%$ 的数据，$s$ 中的字符全部相等。\n\n对于 $100\\%$ 的数据，$1\\leq p,q \\le |s|\\leq 10^6$，$1 \\leq m \\leq 10^5$，$s_i \\in [\\texttt{a}, \\texttt{z}]$。", "locale": "zh-CN"}}}
{"pid": "P5830", "type": "P", "difficulty": 7, "samples": [["见附件", "见附件"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "各省省选", "浙江", "Special Judge"], "title": "[ZJOI2016] 随机树生成器", "background": "附加文件及样例可在页面底部「附件」中下载。", "description": "小 Y 最近有了一个随机数生成器 (random number generator)。小 Y 想用这个随机数生成器生成 $n$ 个节点的树。树为一种没有环的无向连通图。\n\n经过小 Y 的研究，她发现了 $4$ 种随机树生成方法。\n\n第一种方法为首先生成一个 $1$ 到 $n$ 的全排列 $p_1,p_2,…,p_n$。接着对于所有的节点 $i (2 \\leq i \\leq n)$，由 $p_i$ 向 $p_j$ 连一条边，其中 $j$ 是 $1$ 到 $i-1$ 中的随机整数。\n\n第二种方法为首先生成一个 $1$ 到 $n$ 的全排列 $p_1,p_2,…,p_n$。接着对于所有的节点 $i (2 \\leq i \\leq n)$，由 $p_i$ 向 $p_j$ 连一条边，其中 $j$ 是 $\\lfloor \\frac {i}{2} \\rfloor$ 到 $i-1$ 中的随机整数。\n\n第三种方法为首先有一个 $n$ 个点的图，里面没有边。接着等概率地随机生成点对 $u,v$ ，如果当前图中 $u,v$ 不连通，那么将边 $(u,v)$ 加入到图中。重复这个过程，直到这个图连通为止。\n\n第四种方法为在所有 $n$ 个点的不同的有标号的树中，等概率地随机选取一棵树。两个树是不同的当且仅当存在一条边 $(u,v)$ 只出现在其中一棵树中。比如 $(1,2),(1,3)$ 和 $(1,2),(2,3)$ 是两棵不同的树。\n\n小 Y 用这四种方法生成了很多棵 $n$ 个节点的树，但她忘记了这些树分别由哪种方法生成的。你能帮帮她辨认这些树由哪种随机方法生成吗？\n\n在这个题目中令 $n=1000$，也就是小 Y 生成的树的节点个数都为 $1000$。", "inputFormat": "第一行包含 $1$ 个正整数 $T$，表示是**第** $T$ 组测试数据。\n\n接下来一个正整数 $m$，表示有 $m$ 棵树。\n\n对于每棵树，共 $n-1$ 行。每行包含 $2$ 个正整数 $u,v$，表示这棵树中有一条节点 $u$ 与节点 $v$ 之间的边。", "outputFormat": "输出共 $m$ 行，每行一个 $1$ 到 $4$ 之间的正整数，表示这棵树随机生成的方式。", "hint": "对于所有的测试数据，保证输入的树是由上述四种方式随机生成。  \n\n各测试点满足以下约定：   \n\n| 测试点 | $m$ | 约定|\n| --- | --- | --- |\n| 1 | $=2000$ | 只会出现第 $1,2$ 种生成方式 |\n| 2 | $=3000$ | 只会出现第 $1,2,3$ 种生成方式 |\n| 3 | $=3000$ | 只会出现第 $1,3,4$ 种生成方式 |\n| 4 | $=4000$ | 无 |\n| 5 | $=4000$ | 无 |\n\n对于每个测试点，保证每种可能出现的生成方式恰好出现 $1000$ 次。\n\n#### 评分方式\n\n对于每个测试点，有 $10$ 个评分参数 $a_{10},a_9,a_8,…,a_1$。\n\n如果你的输出中错误的答案个数为 $x$, 那么你将获得 $2s$ 的分数，其中 $s$ 为满足 $x \\leq a_s$ 最大的整数。如果 $x>a_1$，那么你将获得 $0$ 分。\n\n如果输出格式有异常你将同样获得 $0$ 分，请确保你的输出中共有 $m$ 行，每行为一个 $1$ 到 $4$ 之间的正整数。\n\n对于每个测试点的具体评分参数见附加文件中的 `scores`。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2016] Random Tree Generator", "background": "The additional files and samples can be downloaded from “Attachments” at the bottom of the page.", "description": "Xiao Y recently got a random number generator (random number generator). Xiao Y wants to use this random number generator to generate a tree with $n$ nodes. A tree is an undirected connected graph with no cycles.\n\nAfter some research, Xiao Y found $4$ random tree generation methods.\n\nThe first method is: first generate a uniformly random permutation $p_1,p_2,\\ldots,p_n$ of $1$ to $n$. Then for every node $i$ $(2 \\leq i \\leq n)$, add an edge from $p_i$ to $p_j$, where $j$ is a random integer from $1$ to $i-1$.\n\nThe second method is: first generate a uniformly random permutation $p_1,p_2,\\ldots,p_n$ of $1$ to $n$. Then for every node $i$ $(2 \\leq i \\leq n)$, add an edge from $p_i$ to $p_j$, where $j$ is a random integer from $\\lfloor \\frac {i}{2} \\rfloor$ to $i-1$.\n\nThe third method is: first start with a graph of $n$ vertices with no edges. Then repeatedly generate a pair of vertices $u,v$ uniformly at random. If $u$ and $v$ are not connected in the current graph, add the edge $(u,v)$ to the graph. Repeat this process until the graph becomes connected.\n\nThe fourth method is: among all different labeled trees on $n$ vertices, choose one uniformly at random. Two trees are different if and only if there exists an edge $(u,v)$ that appears in exactly one of them. For example, $(1,2),(1,3)$ and $(1,2),(2,3)$ are two different trees.\n\nXiao Y generated many trees with $n$ nodes using these four methods, but she forgot which method generated each tree. Can you help her identify which random method generated each tree?\n\nIn this problem, let $n=1000$, meaning every tree generated by Xiao Y has $1000$ nodes.", "inputFormat": "The first line contains $1$ positive integer $T$, indicating the $T$-th set of testdata.\n\nThen an integer $m$, indicating there are $m$ trees.\n\nFor each tree, there are $n-1$ lines. Each line contains $2$ positive integers $u,v$, indicating there is an edge between node $u$ and node $v$ in this tree.", "outputFormat": "Output a total of $m$ lines. Each line contains a positive integer from $1$ to $4$, indicating the random generation method of the corresponding tree.", "hint": "For all testdata, it is guaranteed that the input trees are generated by the four methods above.\n\nEach test point satisfies the following rules.\n\n| Test Point | $m$ | Rule |\n| --- | --- | --- |\n| 1 | $=2000$ | Only methods $1,2$ will appear. |\n| 2 | $=3000$ | Only methods $1,2,3$ will appear. |\n| 3 | $=3000$ | Only methods $1,3,4$ will appear. |\n| 4 | $=4000$ | None. |\n| 5 | $=4000$ | None. |\n\nFor each test point, it is guaranteed that each possible appearing generation method appears exactly $1000$ times.\n\n#### Scoring\n\nFor each test point, there are $10$ scoring parameters $a_{10},a_9,a_8,\\ldots,a_1$.\n\nIf the number of wrong answers in your output is $x$, then you will get a score of $2s$, where $s$ is the largest integer satisfying $x \\leq a_s$. If $x>a_1$, then you will get $0$ points.\n\nIf the output format is abnormal, you will also get $0$ points. Please make sure your output has exactly $m$ lines, and each line is an integer from $1$ to $4$.\n\nFor the specific scoring parameters of each test point, see `scores` in the additional files.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2016] 随机树生成器", "background": "附加文件及样例可在页面底部「附件」中下载。", "description": "小 Y 最近有了一个随机数生成器 (random number generator)。小 Y 想用这个随机数生成器生成 $n$ 个节点的树。树为一种没有环的无向连通图。\n\n经过小 Y 的研究，她发现了 $4$ 种随机树生成方法。\n\n第一种方法为首先生成一个 $1$ 到 $n$ 的全排列 $p_1,p_2,…,p_n$。接着对于所有的节点 $i (2 \\leq i \\leq n)$，由 $p_i$ 向 $p_j$ 连一条边，其中 $j$ 是 $1$ 到 $i-1$ 中的随机整数。\n\n第二种方法为首先生成一个 $1$ 到 $n$ 的全排列 $p_1,p_2,…,p_n$。接着对于所有的节点 $i (2 \\leq i \\leq n)$，由 $p_i$ 向 $p_j$ 连一条边，其中 $j$ 是 $\\lfloor \\frac {i}{2} \\rfloor$ 到 $i-1$ 中的随机整数。\n\n第三种方法为首先有一个 $n$ 个点的图，里面没有边。接着等概率地随机生成点对 $u,v$ ，如果当前图中 $u,v$ 不连通，那么将边 $(u,v)$ 加入到图中。重复这个过程，直到这个图连通为止。\n\n第四种方法为在所有 $n$ 个点的不同的有标号的树中，等概率地随机选取一棵树。两个树是不同的当且仅当存在一条边 $(u,v)$ 只出现在其中一棵树中。比如 $(1,2),(1,3)$ 和 $(1,2),(2,3)$ 是两棵不同的树。\n\n小 Y 用这四种方法生成了很多棵 $n$ 个节点的树，但她忘记了这些树分别由哪种方法生成的。你能帮帮她辨认这些树由哪种随机方法生成吗？\n\n在这个题目中令 $n=1000$，也就是小 Y 生成的树的节点个数都为 $1000$。", "inputFormat": "第一行包含 $1$ 个正整数 $T$，表示是**第** $T$ 组测试数据。\n\n接下来一个正整数 $m$，表示有 $m$ 棵树。\n\n对于每棵树，共 $n-1$ 行。每行包含 $2$ 个正整数 $u,v$，表示这棵树中有一条节点 $u$ 与节点 $v$ 之间的边。", "outputFormat": "输出共 $m$ 行，每行一个 $1$ 到 $4$ 之间的正整数，表示这棵树随机生成的方式。", "hint": "对于所有的测试数据，保证输入的树是由上述四种方式随机生成。  \n\n各测试点满足以下约定：   \n\n| 测试点 | $m$ | 约定|\n| --- | --- | --- |\n| 1 | $=2000$ | 只会出现第 $1,2$ 种生成方式 |\n| 2 | $=3000$ | 只会出现第 $1,2,3$ 种生成方式 |\n| 3 | $=3000$ | 只会出现第 $1,3,4$ 种生成方式 |\n| 4 | $=4000$ | 无 |\n| 5 | $=4000$ | 无 |\n\n对于每个测试点，保证每种可能出现的生成方式恰好出现 $1000$ 次。\n\n#### 评分方式\n\n对于每个测试点，有 $10$ 个评分参数 $a_{10},a_9,a_8,…,a_1$。\n\n如果你的输出中错误的答案个数为 $x$, 那么你将获得 $2s$ 的分数，其中 $s$ 为满足 $x \\leq a_s$ 最大的整数。如果 $x>a_1$，那么你将获得 $0$ 分。\n\n如果输出格式有异常你将同样获得 $0$ 分，请确保你的输出中共有 $m$ 行，每行为一个 $1$ 到 $4$ 之间的正整数。\n\n对于每个测试点的具体评分参数见附加文件中的 `scores`。", "locale": "zh-CN"}}}
{"pid": "P5831", "type": "P", "difficulty": 1, "samples": [["3 4\n4 1 2 3\n4 1 3 2\n4 2 1 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "USACO", "枚举"], "title": "[USACO19DEC] Cow Gymnastics B", "background": "", "description": "为了提高健康水平，奶牛们开始进行体操训练了！Farmer John 选定了他最喜爱的奶牛 Bessie 来执教其他 $N$ 头奶牛，同时评估她们学习不同的体操技术的进度。\n\n$K$ 次训练课的每一次，Bessie 都会根据 $N$ 头奶牛的表现给她们进行排名。之后，她对这些排名的一致性产生了好奇。称一对不同的奶牛是**一致的**，如果其中一头奶牛在每次训练课中都表现得都比另一头要好。\n\n请帮助 Bessie 计算一致的奶牛的对数。", "inputFormat": "输入的第一行包含两个正整数 $K$ 和 $N$。以下 $K$ 行每行包含整数 $1 \\ldots N$ 的某种排列，表示奶牛们的排名（奶牛们用编号 $1 \\ldots N$ 进行区分）。如果在某一行中 $A$ 出现在 $B$ 之前，表示奶牛 $A$ 表现得比奶牛 $B$ 要好。", "outputFormat": "输出一行，包含一致的奶牛的对数。", "hint": "一致的奶牛对为 $(1,4)$、$(2,4)$、$(3,4)$ 和 $(1,3)$。\n\n$1 \\leq K \\leq 10$，$1 \\leq N \\leq 20$。\n\n供题：Nick Wu", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19DEC] Cow Gymnastics B", "background": "", "description": "To improve their health, the cows have started doing gymnastics training. Farmer John chose his favorite cow, Bessie, to coach the other $N$ cows, while also evaluating their progress in learning different gymnastics skills.\n\nIn each of the $K$ training sessions, Bessie ranks the $N$ cows based on their performance. Later, she became curious about how consistent these rankings are. A pair of different cows is called **consistent** if one cow performs better than the other in every training session.\n\nPlease help Bessie count the number of consistent cow pairs.", "inputFormat": "The first line contains two positive integers $K$ and $N$. The next $K$ lines each contain a permutation of the integers $1 \\ldots N$, representing the rankings of the cows (the cows are identified by numbers $1 \\ldots N$). If in a line $A$ appears before $B$, it means cow $A$ performed better than cow $B$.", "outputFormat": "Output one line containing the number of consistent cow pairs.", "hint": "The consistent cow pairs are $(1,4)$, $(2,4)$, $(3,4)$, and $(1,3)$.\n\n$1 \\leq K \\leq 10$, $1 \\leq N \\leq 20$.\n\nProblem by: Nick Wu.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO19DEC] Cow Gymnastics B", "background": "", "description": "为了提高健康水平，奶牛们开始进行体操训练了！Farmer John 选定了他最喜爱的奶牛 Bessie 来执教其他 $N$ 头奶牛，同时评估她们学习不同的体操技术的进度。\n\n$K$ 次训练课的每一次，Bessie 都会根据 $N$ 头奶牛的表现给她们进行排名。之后，她对这些排名的一致性产生了好奇。称一对不同的奶牛是**一致的**，如果其中一头奶牛在每次训练课中都表现得都比另一头要好。\n\n请帮助 Bessie 计算一致的奶牛的对数。", "inputFormat": "输入的第一行包含两个正整数 $K$ 和 $N$。以下 $K$ 行每行包含整数 $1 \\ldots N$ 的某种排列，表示奶牛们的排名（奶牛们用编号 $1 \\ldots N$ 进行区分）。如果在某一行中 $A$ 出现在 $B$ 之前，表示奶牛 $A$ 表现得比奶牛 $B$ 要好。", "outputFormat": "输出一行，包含一致的奶牛的对数。", "hint": "一致的奶牛对为 $(1,4)$、$(2,4)$、$(3,4)$ 和 $(1,3)$。\n\n$1 \\leq K \\leq 10$，$1 \\leq N \\leq 20$。\n\n供题：Nick Wu", "locale": "zh-CN"}}}
{"pid": "P5832", "type": "P", "difficulty": 1, "samples": [["7\nABCDABC", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2019", "USACO"], "title": "[USACO19DEC] Where Am I? B", "background": "", "description": "Farmer John 出门沿着马路散步，但是他现在发现可能迷路了！\n\n沿路有一排共 $N$ 个农场。不幸的是农场并没有编号，这使得 Farmer John 难以分辨他在这条路上所处的位置。然而，每个农场都沿路设有一个彩色的邮箱，所以 Farmer John 希望能够通过查看最近的几个邮箱的颜色来唯一确定他所在的位置。\n\n每个邮箱的颜色用 A..Z 之间的一个字母来指定，所以沿着道路的 $N$ 个邮箱的序列可以用一个长为 $N$ 的由字母 A..Z 组成的字符串来表示。某些邮箱可能会有相同的颜色。Farmer John 想要知道最小的 $K$ 的值，使得他查看任意连续 $K$ 个邮箱序列，他都可以唯一确定这一序列在道路上的位置。\n\n例如，假设沿路的邮箱序列为 `ABCDABC` 。Farmer John 不能令 $K=3$，因为如果他看到了 `ABC`，沿路有两个这一连续颜色序列可能所在的位置。最小可行的 $K$ 的值为 $K=4$，因为如果他查看任意连续 4 个邮箱，这一颜色序列可以唯一确定他在道路上的位置。", "inputFormat": "输入的第一行包含 $N$，第二行包含一个由 $N$ 个字符组成的字符串，每个字符均在 A..Z 之内。", "outputFormat": "输出一行，包含一个整数，为可以解决 Farmer John 的问题的最小 $K$ 值。", "hint": "$1 \\leq N \\leq 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19DEC] Where Am I? B", "background": "", "description": "Farmer John goes out for a walk along the road, but now he realizes he might be lost.\n\nAlong the road there is a line of $N$ farms. Unfortunately, the farms are not numbered, which makes it hard for Farmer John to tell where he is on this road. However, each farm has a colored mailbox by the roadside, so Farmer John hopes to uniquely determine his position by looking at the colors of the most recent few mailboxes.\n\nEach mailbox color is specified by a letter from A..Z, so the sequence of $N$ mailboxes along the road can be represented as a string of length $N$ consisting of letters A..Z. Some mailboxes may have the same color. Farmer John wants to know the smallest value of $K$ such that, by looking at any consecutive sequence of $K$ mailboxes, he can uniquely determine where this sequence occurs on the road.\n\nFor example, suppose the mailbox sequence along the road is `ABCDABC`. Farmer John cannot set $K=3$, because if he sees `ABC`, there are two possible positions on the road where this consecutive color sequence could be. The smallest feasible value is $K=4$, because if he looks at any consecutive 4 mailboxes, that color sequence can uniquely determine his position on the road.", "inputFormat": "The first line of input contains $N$. The second line contains a string of $N$ characters, each of which is in A..Z.", "outputFormat": "Output one line containing an integer: the minimum value of $K$ that can solve Farmer John's problem.", "hint": "Constraints: $1 \\leq N \\leq 100$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO19DEC] Where Am I? B", "background": "", "description": "Farmer John 出门沿着马路散步，但是他现在发现可能迷路了！\n\n沿路有一排共 $N$ 个农场。不幸的是农场并没有编号，这使得 Farmer John 难以分辨他在这条路上所处的位置。然而，每个农场都沿路设有一个彩色的邮箱，所以 Farmer John 希望能够通过查看最近的几个邮箱的颜色来唯一确定他所在的位置。\n\n每个邮箱的颜色用 A..Z 之间的一个字母来指定，所以沿着道路的 $N$ 个邮箱的序列可以用一个长为 $N$ 的由字母 A..Z 组成的字符串来表示。某些邮箱可能会有相同的颜色。Farmer John 想要知道最小的 $K$ 的值，使得他查看任意连续 $K$ 个邮箱序列，他都可以唯一确定这一序列在道路上的位置。\n\n例如，假设沿路的邮箱序列为 `ABCDABC` 。Farmer John 不能令 $K=3$，因为如果他看到了 `ABC`，沿路有两个这一连续颜色序列可能所在的位置。最小可行的 $K$ 的值为 $K=4$，因为如果他查看任意连续 4 个邮箱，这一颜色序列可以唯一确定他在道路上的位置。", "inputFormat": "输入的第一行包含 $N$，第二行包含一个由 $N$ 个字符组成的字符串，每个字符均在 A..Z 之内。", "outputFormat": "输出一行，包含一个整数，为可以解决 Farmer John 的问题的最小 $K$ 值。", "hint": "$1 \\leq N \\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P5833", "type": "P", "difficulty": 2, "samples": [["3\nButtercup must be milked beside Bella\nBlue must be milked beside Bella\nSue must be milked beside Beatrice", "Beatrice\nSue\nBelinda\nBessie\nBetsy\nBlue\nBella\nButtercup"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2019", "USACO", "枚举"], "title": "[USACO19DEC] Livestock Lineup B", "background": "", "description": "每天，Farmer John 都要给他的 $8$ 头奶牛挤奶。她们的名字分别是 Bessie，Buttercup，Belinda，Beatrice，Bella，Blue，Betsy，和 Sue。\n\n不幸的是，这些奶牛相当难以伺候，她们要求 Farmer John 以一种符合 $N$ 条限制的顺序给她们挤奶。每条限制的形式为“$X$ 必须紧邻着 $Y$ 挤奶”，要求奶牛 $X$ 在挤奶顺序中必须紧接在奶牛 $Y$ 之后，或者紧接在奶牛 $Y$ 之前。\n\n请帮助 Farmer John 求出一种满足所有限制的奶牛挤奶顺序。保证这样的顺序是存在的。如果有多种顺序都满足要求，请输出字典序最小的一种。也就是说，第一头奶牛需要是所有可能排在任意合法奶牛顺序的第一位的奶牛中名字字典序最小的。在所有合法的以这头字典序最小的奶牛为首的奶牛顺序中，第二头奶牛需要是字典序最小的，以此类推。", "inputFormat": "输入的第一行包含 $N$。以下 $N$ 行每行包含一句句子，以 \"$X$ must be milked beside $Y$\" 的格式描述了一条限制，其中 $X$ 和 $Y$ 为 Farmer John 的某些奶牛的名字（上文列举了八个可能的名字）。", "outputFormat": "请用 $8$ 行输出一个奶牛的顺序，每行输出一头奶牛的名字，满足所有的限制。如果由多种顺序符合要求，输出字典序最小的奶牛顺序。", "hint": "$1 \\leq N \\leq 7$。\n\n供题：Brian Dean", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19DEC] Livestock Lineup B", "background": "", "description": "Every day, Farmer John milks his $8$ cows. Their names are Bessie, Buttercup, Belinda, Beatrice, Bella, Blue, Betsy, and Sue.\n\nUnfortunately, these cows are quite hard to deal with. They require Farmer John to milk them in an order that satisfies $N$ constraints. Each constraint is of the form \"$X$ must be milked beside $Y$\", meaning cow $X$ must be immediately after cow $Y$ in the milking order, or immediately before cow $Y$.\n\nPlease help Farmer John find a milking order that satisfies all constraints. It is guaranteed that such an order exists. If there are multiple valid orders, output the one with the smallest lexicographical order. That is, the first cow must be the one with the smallest name in lexicographical order among all cows that can appear first in some valid milking order. Among all valid milking orders that start with this lexicographically smallest cow, the second cow must be lexicographically smallest, and so on.", "inputFormat": "The first line contains $N$. The next $N$ lines each contain a sentence describing a constraint in the format \"$X$ must be milked beside $Y$\", where $X$ and $Y$ are names of Farmer John's cows (from the eight possible names listed above).", "outputFormat": "Output a cow order in $8$ lines, one cow name per line, satisfying all constraints. If multiple orders satisfy the requirements, output the lexicographically smallest cow order.", "hint": "$1 \\leq N \\leq 7$.\n\nProblem by: Brian Dean.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO19DEC] Livestock Lineup B", "background": "", "description": "每天，Farmer John 都要给他的 $8$ 头奶牛挤奶。她们的名字分别是 Bessie，Buttercup，Belinda，Beatrice，Bella，Blue，Betsy，和 Sue。\n\n不幸的是，这些奶牛相当难以伺候，她们要求 Farmer John 以一种符合 $N$ 条限制的顺序给她们挤奶。每条限制的形式为“$X$ 必须紧邻着 $Y$ 挤奶”，要求奶牛 $X$ 在挤奶顺序中必须紧接在奶牛 $Y$ 之后，或者紧接在奶牛 $Y$ 之前。\n\n请帮助 Farmer John 求出一种满足所有限制的奶牛挤奶顺序。保证这样的顺序是存在的。如果有多种顺序都满足要求，请输出字典序最小的一种。也就是说，第一头奶牛需要是所有可能排在任意合法奶牛顺序的第一位的奶牛中名字字典序最小的。在所有合法的以这头字典序最小的奶牛为首的奶牛顺序中，第二头奶牛需要是字典序最小的，以此类推。", "inputFormat": "输入的第一行包含 $N$。以下 $N$ 行每行包含一句句子，以 \"$X$ must be milked beside $Y$\" 的格式描述了一条限制，其中 $X$ 和 $Y$ 为 Farmer John 的某些奶牛的名字（上文列举了八个可能的名字）。", "outputFormat": "请用 $8$ 行输出一个奶牛的顺序，每行输出一头奶牛的名字，满足所有的限制。如果由多种顺序符合要求，输出字典序最小的奶牛顺序。", "hint": "$1 \\leq N \\leq 7$。\n\n供题：Brian Dean", "locale": "zh-CN"}}}
{"pid": "P5834", "type": "P", "difficulty": 2, "samples": [["4", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2019", "USACO"], "title": "[USACO19DEC] MooBuzz S", "background": "", "description": "Farmer John 的奶牛们最近成为了一个简单的数字游戏“FizzBuzz”的狂热玩家。这个游戏的规则很简单：奶牛们站成一圈，依次从一开始报数，每头奶牛在轮到她的时候报一个数。如果一头奶牛将要报的数字是 $3$ 的倍数，她应当报 `Fizz` 来代替这个数。如果一头奶牛将要报的数字是 $5$ 的倍数，她应当报 `Buzz` 来代替这个数。如果一头奶牛将要报的数字是 $15$ 的倍数，她应当报 `FizzBuzz` 来代替这个数。于是这个游戏的开始部分的记录为：\n\n`1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16`\n\n由于词汇的匮乏，奶牛们玩的 FizzBuzz 中用`Moo` 代替了 `Fizz`、`Buzz`、`FizzBuzz`。于是奶牛版的游戏的开始部分的记录为：\n\n`1, 2, Moo, 4, Moo, Moo, 7, 8, Moo, Moo, 11, Moo, 13, 14, Moo, 16`\n\n给定 $N$，请求出这个游戏中第 $N$ 个被报的数。", "inputFormat": "输入包含一个整数 $N$。", "outputFormat": "输出游戏中被报出的第 $N$ 个数。", "hint": "关于部分分：\n\n测试点 $1$ 为样例。\n\n测试点 $2\\sim 5$ 满足 $N\\le 10^6$。\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 10^9$\n\n供题：Brian Dean", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19DEC] MooBuzz S", "background": "", "description": "Farmer John’s cows have recently become enthusiastic players of a simple number game called “FizzBuzz.” The rules of this game are simple: the cows stand in a circle and count in order starting from $1$, and each cow says one item when it is her turn. If the number a cow is about to say is a multiple of $3$, she should say `Fizz` instead of the number. If it is a multiple of $5$, she should say `Buzz` instead of the number. If it is a multiple of $15$, she should say `FizzBuzz` instead of the number. Therefore, the beginning of the record of the game is:\n\n`1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16`\n\nDue to a limited vocabulary, in the cows’ version of FizzBuzz they use `Moo` to replace `Fizz`, `Buzz`, and `FizzBuzz`. Therefore, the beginning of the record of the cows’ game is:\n\n`1, 2, Moo, 4, Moo, Moo, 7, 8, Moo, Moo, 11, Moo, 13, 14, Moo, 16`\n\nGiven $N$, find the $N$-th number that is spoken in this game.", "inputFormat": "The input contains one integer $N$.", "outputFormat": "Output the $N$-th number spoken in the game.", "hint": "About partial scoring:\n\nTest point $1$ is the sample.\n\nTest points $2 \\sim 5$ satisfy $N \\le 10^6$.\n\nFor $100\\%$ of the testdata, $1 \\leq N \\leq 10^9$.\n\nProblem by: Brian Dean.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO19DEC] MooBuzz S", "background": "", "description": "Farmer John 的奶牛们最近成为了一个简单的数字游戏“FizzBuzz”的狂热玩家。这个游戏的规则很简单：奶牛们站成一圈，依次从一开始报数，每头奶牛在轮到她的时候报一个数。如果一头奶牛将要报的数字是 $3$ 的倍数，她应当报 `Fizz` 来代替这个数。如果一头奶牛将要报的数字是 $5$ 的倍数，她应当报 `Buzz` 来代替这个数。如果一头奶牛将要报的数字是 $15$ 的倍数，她应当报 `FizzBuzz` 来代替这个数。于是这个游戏的开始部分的记录为：\n\n`1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16`\n\n由于词汇的匮乏，奶牛们玩的 FizzBuzz 中用`Moo` 代替了 `Fizz`、`Buzz`、`FizzBuzz`。于是奶牛版的游戏的开始部分的记录为：\n\n`1, 2, Moo, 4, Moo, Moo, 7, 8, Moo, Moo, 11, Moo, 13, 14, Moo, 16`\n\n给定 $N$，请求出这个游戏中第 $N$ 个被报的数。", "inputFormat": "输入包含一个整数 $N$。", "outputFormat": "输出游戏中被报出的第 $N$ 个数。", "hint": "关于部分分：\n\n测试点 $1$ 为样例。\n\n测试点 $2\\sim 5$ 满足 $N\\le 10^6$。\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 10^9$\n\n供题：Brian Dean", "locale": "zh-CN"}}}
{"pid": "P5835", "type": "P", "difficulty": 5, "samples": [["3 5\n1 1 1\n2 2 -1\n3 3 -1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "二分", "USACO", "排序", "队列"], "title": "[USACO19DEC] Meetings S", "background": "", "description": "有两个牛棚位于一维数轴上的点 $0$ 和 $L$ 处（$1 \\leq L \\leq 10^9$）。同时有 $N$ 头奶牛（$1 \\leq N \\leq 5 \\times 10^4$）位于数轴上不同的位置（将牛棚和奶牛看作点）。每头奶牛 $i$ 初始时位于某个位置 $x_i$，并朝着正向或负向以一个单位每秒的速度移动，用一个等于 $1$ 或 $-1$ 的整数 $d_i$ 表示。每头奶牛还拥有一个在范围 $[1,10^3]$ 内的重量。所有奶牛始终以恒定的速度移动，直到以下事件之一发生：\n- 如果奶牛 $i$ 移动到了一个牛棚，则奶牛 $i$ 停止移动。\n- 当奶牛 $i$ 和 $j$ 占据了相同的点的时候，并且这一点不是一个牛棚，则发生了相遇。此时，奶牛 $i$ 被赋予奶牛 $j$ 先前的速度，反之亦然。注意奶牛可能在一个非整数点相遇。\n\n令 $T$ 等于停止移动的奶牛（由于到达两个牛棚之一）的重量之和至少等于所有奶牛的重量之和的一半的最早时刻。请求出在时刻 $0 \\ldots T$（包括时刻 $T$）之间发生的奶牛对相遇的总数。\n", "inputFormat": "输入的第一行包含两个空格分隔的整数 $N$ 和 $L$。\n\n以下 $N$ 行，每行包含三个空格分隔的整数 $w_i$，$x_i$ 以及 $d_i$。所有的位置 $x_i$ 各不相同，并且满足 $0<x_i<L$。", "outputFormat": "输出一行，包含答案。", "hint": "### 样例解释\n\n在这个例子中，奶牛们按如下方式移动：\n\n1. 第一和第二头奶牛于时刻 0.5 在位置 1.5 相遇。此时第一头奶牛拥有速度 -1，第二头奶牛拥有速度 1。\n2. 第二和第三头奶牛于时刻 1 在位置 2 相遇。此时第二头奶牛拥有速度 −1，第三头奶牛拥有速度 1。\n3. 第一头奶牛于时刻 2 到达左边的牛棚。\n4. 第二头奶牛于时刻 3 到达左边的牛棚。\n5. 由于到达牛棚的奶牛的总重量已经至少是所有奶牛的总重量的一半，这个过程此时终止。如果继续进行下去，第三头奶牛将会在时刻 4 到达右边的牛棚。\n\n发生了恰好两次相遇。 \n\n### 子任务\n\n测试点 $2\\sim 4$ 满足 $N\\le 10^2$，并且对所有 $i$，$w_i=1$。\n\n测试点 $5\\sim 7$ 满足 $N\\le 10^2$。\n\n供题：Benjamin Qi", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19DEC] Meetings S", "background": "", "description": "There are two barns located at points $0$ and $L$ on a one-dimensional number line ($1 \\leq L \\leq 10^9$). There are also $N$ cows ($1 \\leq N \\leq 5 \\times 10^4$) at distinct positions on the number line (treat the barns and cows as points). Each cow $i$ starts at position $x_i$ and moves at a speed of 1 unit per second in either the positive or negative direction, represented by an integer $d_i$ equal to $1$ or $-1$. Each cow also has a weight in the range $[1,10^3]$. All cows move at constant speed until one of the following events happens:\n\n- If cow $i$ reaches a barn, then cow $i$ stops moving.\n- When cows $i$ and $j$ occupy the same point, and this point is not a barn, then a meeting happens. At that moment, cow $i$ is given cow $j$'s previous velocity, and vice versa. Note that cows may meet at a non-integer point.\n\nLet $T$ be the earliest time such that the total weight of the cows that have stopped moving (because they reached one of the two barns) is at least half of the total weight of all cows. Find the total number of pairwise cow meetings that occur during time $0 \\ldots T$ (including time $T$).", "inputFormat": "The first line contains two space-separated integers $N$ and $L$.\n\nThe next $N$ lines each contain three space-separated integers $w_i$, $x_i$, and $d_i$. All positions $x_i$ are distinct and satisfy $0 < x_i < L$.", "outputFormat": "Output one line containing the answer.", "hint": "### Sample Explanation\n\nIn this example, the cows move as follows:\n\n1. The first and second cows meet at time 0.5 at position 1.5. At this time, the first cow has velocity -1, and the second cow has velocity 1.\n2. The second and third cows meet at time 1 at position 2. At this time, the second cow has velocity −1, and the third cow has velocity 1.\n3. The first cow reaches the left barn at time 2.\n4. The second cow reaches the left barn at time 3.\n5. Since the total weight of the cows that have reached a barn is already at least half of the total weight of all cows, the process stops at this time. If it continued, the third cow would reach the right barn at time 4.\n\nExactly two meetings occur.\n\n### Subtasks\n\nTestdata 2 to 4 satisfy $N \\leq 10^2$, and for all $i$, $w_i = 1$.\n\nTestdata 5 to 7 satisfy $N \\leq 10^2$.\n\nProblem author: Benjamin Qi.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO19DEC] Meetings S", "background": "", "description": "有两个牛棚位于一维数轴上的点 $0$ 和 $L$ 处（$1 \\leq L \\leq 10^9$）。同时有 $N$ 头奶牛（$1 \\leq N \\leq 5 \\times 10^4$）位于数轴上不同的位置（将牛棚和奶牛看作点）。每头奶牛 $i$ 初始时位于某个位置 $x_i$，并朝着正向或负向以一个单位每秒的速度移动，用一个等于 $1$ 或 $-1$ 的整数 $d_i$ 表示。每头奶牛还拥有一个在范围 $[1,10^3]$ 内的重量。所有奶牛始终以恒定的速度移动，直到以下事件之一发生：\n- 如果奶牛 $i$ 移动到了一个牛棚，则奶牛 $i$ 停止移动。\n- 当奶牛 $i$ 和 $j$ 占据了相同的点的时候，并且这一点不是一个牛棚，则发生了相遇。此时，奶牛 $i$ 被赋予奶牛 $j$ 先前的速度，反之亦然。注意奶牛可能在一个非整数点相遇。\n\n令 $T$ 等于停止移动的奶牛（由于到达两个牛棚之一）的重量之和至少等于所有奶牛的重量之和的一半的最早时刻。请求出在时刻 $0 \\ldots T$（包括时刻 $T$）之间发生的奶牛对相遇的总数。\n", "inputFormat": "输入的第一行包含两个空格分隔的整数 $N$ 和 $L$。\n\n以下 $N$ 行，每行包含三个空格分隔的整数 $w_i$，$x_i$ 以及 $d_i$。所有的位置 $x_i$ 各不相同，并且满足 $0<x_i<L$。", "outputFormat": "输出一行，包含答案。", "hint": "### 样例解释\n\n在这个例子中，奶牛们按如下方式移动：\n\n1. 第一和第二头奶牛于时刻 0.5 在位置 1.5 相遇。此时第一头奶牛拥有速度 -1，第二头奶牛拥有速度 1。\n2. 第二和第三头奶牛于时刻 1 在位置 2 相遇。此时第二头奶牛拥有速度 −1，第三头奶牛拥有速度 1。\n3. 第一头奶牛于时刻 2 到达左边的牛棚。\n4. 第二头奶牛于时刻 3 到达左边的牛棚。\n5. 由于到达牛棚的奶牛的总重量已经至少是所有奶牛的总重量的一半，这个过程此时终止。如果继续进行下去，第三头奶牛将会在时刻 4 到达右边的牛棚。\n\n发生了恰好两次相遇。 \n\n### 子任务\n\n测试点 $2\\sim 4$ 满足 $N\\le 10^2$，并且对所有 $i$，$w_i=1$。\n\n测试点 $5\\sim 7$ 满足 $N\\le 10^2$。\n\n供题：Benjamin Qi", "locale": "zh-CN"}}}
{"pid": "P5836", "type": "P", "difficulty": 3, "samples": [["5 5\nHHGHG\n1 2\n2 3\n2 4\n1 5\n1 4 H\n1 4 G\n1 3 G\n1 3 H\n5 5 H", "10110"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "树形数据结构", "2019", "USACO", "并查集", "最近公共祖先 LCA"], "title": "[USACO19DEC] Milk Visits S", "background": "", "description": "Farmer John 计划建造 $N$ 个农场，用 $N-1$ 条道路连接，构成一棵树（也就是说，所有农场之间都互相可以到达，并且没有环）。每个农场有一头奶牛，品种为更赛牛或荷斯坦牛之一。\n\nFarmer John 的 $M$ 个朋友经常前来拜访他。在朋友 $i$ 拜访之时，Farmer John 会与他的朋友沿着从农场 $A_i$ 到农场 $B_i$ 之间的唯一路径行走（可能有 $A_i = B_i$）。除此之外，他们还可以品尝他们经过的路径上任意一头奶牛的牛奶。由于 Farmer John 的朋友们大多数也是农场主，他们对牛奶有着极强的偏好。他的有些朋友只喝更赛牛的牛奶，其余的只喝荷斯坦牛的牛奶。任何 Farmer John 的朋友只有在他们访问时能喝到他们偏好的牛奶才会高兴。\n\n请求出每个朋友在拜访过后是否会高兴。", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$。\n\n第二行包含一个长为 $N$ 的字符串。如果第 $i$ 个农场中的奶牛是更赛牛，则字符串中第 $i$ 个字符为 `G`，如果第 $i$ 个农场中的奶牛是荷斯坦牛则为 `H`。\n\n以下 $N-1$ 行，每行包含两个不同的整数 $X$ 和 $Y$（$1 \\leq X, Y \\leq N$），表示农场 $X$ 与 $Y$ 之间有一条道路。\n\n以下 $M$ 行，每行包含整数 $A_i$，$B_i$，以及一个字符 $C_i$。$A_i$ 和 $B_i$ 表示朋友 $i$ 拜访时行走的路径的端点，$C_i$ 是 `G` 或 `H` 之一，表示第 $i$ 个朋友喜欢更赛牛的牛奶或是荷斯坦牛的牛奶。", "outputFormat": "输出一个长为 $M$ 的二进制字符串。如果第 $i$ 个朋友会感到高兴，则字符串的第 $i$ 个字符为 `1`，否则为 `0`。", "hint": "在这里，从农场 1 到农场 4 的路径包括农场 1、2 和 4。所有这些农场里都是荷斯坦牛，所以第一个朋友会感到满意，而第二个朋友不会。\n\n关于部分分：\n\n测试点 $1$ 样例。\n\n测试点 $2\\sim 5$ 满足 $N\\le 10^3$，$M\\le 2\\cdot 10^3$。\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 10^5$，$1 \\leq M \\leq 10^5$。\n\n供题：Spencer Compton", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19DEC] Milk Visits S", "background": "", "description": "Farmer John plans to build $N$ farms and connect them with $N-1$ roads, forming a tree (that is, all farms are reachable from each other, and there are no cycles). Each farm has one cow, whose breed is either Guernsey or Holstein.\n\nFarmer John has $M$ friends who often come to visit him. When friend $i$ visits, Farmer John and this friend will walk along the unique path from farm $A_i$ to farm $B_i$ (it is possible that $A_i = B_i$). Also, they can taste the milk from any cow on the path they travel. Since most of Farmer John’s friends are also farmers, they have a very strong preference for milk. Some friends only drink Guernsey milk, and the rest only drink Holstein milk. A friend will be happy only if, during their visit, they can drink the type of milk they prefer.\n\nFor each friend, determine whether they will be happy after the visit.", "inputFormat": "The first line contains two integers $N$ and $M$.\n\nThe second line contains a string of length $N$. If the cow on farm $i$ is a Guernsey cow, then the $i$-th character is `G`; if the cow on farm $i$ is a Holstein cow, then the $i$-th character is `H`.\n\nThe next $N-1$ lines each contain two distinct integers $X$ and $Y$ ($1 \\leq X, Y \\leq N$), indicating that there is a road between farms $X$ and $Y$.\n\nThe next $M$ lines each contain integers $A_i$, $B_i$, and a character $C_i$. $A_i$ and $B_i$ are the endpoints of the path that friend $i$ walks during the visit. $C_i$ is one of `G` or `H`, indicating whether friend $i$ likes Guernsey milk or Holstein milk.", "outputFormat": "Output a binary string of length $M$. If friend $i$ will be happy, then the $i$-th character is `1`; otherwise it is `0`.", "hint": "Here, the path from farm 1 to farm 4 includes farms 1, 2, and 4. All these farms have Holstein cows, so the first friend will be satisfied, while the second friend will not.\n\nAbout subtasks:\n\nTest point $1$ is the sample.\n\nTest points $2\\sim 5$ satisfy $N \\le 10^3$, $M \\le 2\\cdot 10^3$.\n\nFor $100\\%$ of the testdata, $1 \\leq N \\leq 10^5$, $1 \\leq M \\leq 10^5$.\n\nProblem by: Spencer Compton.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO19DEC] Milk Visits S", "background": "", "description": "Farmer John 计划建造 $N$ 个农场，用 $N-1$ 条道路连接，构成一棵树（也就是说，所有农场之间都互相可以到达，并且没有环）。每个农场有一头奶牛，品种为更赛牛或荷斯坦牛之一。\n\nFarmer John 的 $M$ 个朋友经常前来拜访他。在朋友 $i$ 拜访之时，Farmer John 会与他的朋友沿着从农场 $A_i$ 到农场 $B_i$ 之间的唯一路径行走（可能有 $A_i = B_i$）。除此之外，他们还可以品尝他们经过的路径上任意一头奶牛的牛奶。由于 Farmer John 的朋友们大多数也是农场主，他们对牛奶有着极强的偏好。他的有些朋友只喝更赛牛的牛奶，其余的只喝荷斯坦牛的牛奶。任何 Farmer John 的朋友只有在他们访问时能喝到他们偏好的牛奶才会高兴。\n\n请求出每个朋友在拜访过后是否会高兴。", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$。\n\n第二行包含一个长为 $N$ 的字符串。如果第 $i$ 个农场中的奶牛是更赛牛，则字符串中第 $i$ 个字符为 `G`，如果第 $i$ 个农场中的奶牛是荷斯坦牛则为 `H`。\n\n以下 $N-1$ 行，每行包含两个不同的整数 $X$ 和 $Y$（$1 \\leq X, Y \\leq N$），表示农场 $X$ 与 $Y$ 之间有一条道路。\n\n以下 $M$ 行，每行包含整数 $A_i$，$B_i$，以及一个字符 $C_i$。$A_i$ 和 $B_i$ 表示朋友 $i$ 拜访时行走的路径的端点，$C_i$ 是 `G` 或 `H` 之一，表示第 $i$ 个朋友喜欢更赛牛的牛奶或是荷斯坦牛的牛奶。", "outputFormat": "输出一个长为 $M$ 的二进制字符串。如果第 $i$ 个朋友会感到高兴，则字符串的第 $i$ 个字符为 `1`，否则为 `0`。", "hint": "在这里，从农场 1 到农场 4 的路径包括农场 1、2 和 4。所有这些农场里都是荷斯坦牛，所以第一个朋友会感到满意，而第二个朋友不会。\n\n关于部分分：\n\n测试点 $1$ 样例。\n\n测试点 $2\\sim 5$ 满足 $N\\le 10^3$，$M\\le 2\\cdot 10^3$。\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 10^5$，$1 \\leq M \\leq 10^5$。\n\n供题：Spencer Compton", "locale": "zh-CN"}}}
{"pid": "P5837", "type": "P", "difficulty": 4, "samples": [["3 2\n2 1 2 4\n2 3 5 3", "428571"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2019", "USACO", "最短路"], "title": "[USACO19DEC] Milk Pumping G", "background": "", "description": "Farmer John 最近为了扩张他的牛奶产业帝国而收购了一个新的农场。这一新的农场通过一个管道网络与附近的小镇相连，FJ 想要找出其中最合适的一组管道，将其购买并用来将牛奶从农场输送到小镇。\n\n这个管道网络可以用 $N$ 个接合点（管道的端点）来描述，将其编号为 $1 \\ldots N$。接合点 $1$ 表示 FJ 的农场，接合点 $N$ 表示小镇。有 $M$ 条双向的管道，每条连接了两个接合点。使用第 $i$ 条管道需要 FJ 花费 $c_i$ 美元购入，可以支持每秒 $f_i$ 升牛奶的流量。\n\nFJ 想要购买一条管道组成一条单一路径，路径的两端点分别为接合点 $1$ 和 $N$。这条路径的花费等于路径上所有管道的费用之和。路径上的流量等于路径上所有管道的最小流量（因为这是沿这条路径输送牛奶的瓶颈）。FJ 想要最大化路径流量与路径花费之比。保证存在从 $1$ 到 $N$之间的路径。\n", "inputFormat": "输入的第一行包含 $N$ 和 $M$。以下 $M$ 行每行以四个整数描述一条管道：$a$ 和 $b$（管道连接的两个不同的接合点），$c$（管道的花费），以及 $f$（管道的流量）。花费和流量均为范围 $1 \\ldots 1000$ 之内的正整数。", "outputFormat": "输出 $10^6$ 乘以最优解的值，并向下取整（也就是说，如果这个数本身不是整数，输出小于它的最接近它的整数）。", "hint": "在这个例子中，仅由一条路径从 $1$ 到 $N$。 它的流量为 $\\min(3,4)=3$，花费为 $2+5=7$。\n\n### 数据范围\n\n测试点 $2\\sim 5$ 满足 $N,M\\le 100$。\n\n对于 $100\\%$ 的数据，$2 \\leq N \\leq 1000$，$1 \\leq M \\leq 1000$。\n\n供题：Brian Dean", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19DEC] Milk Pumping G", "background": "", "description": "Farmer John recently bought a new farm in order to expand his milk industry empire. This new farm is connected to a nearby town by a network of pipelines, and FJ wants to find the best set of pipelines to buy and use to transport milk from the farm to the town.\n\nThis pipeline network can be described by $N$ junctions (endpoints of pipelines), numbered $1 \\ldots N$. Junction $1$ represents FJ's farm, and junction $N$ represents the town. There are $M$ bidirectional pipelines, each connecting two junctions. Using the $i$-th pipeline costs FJ $c_i$ dollars to buy, and it can support a flow rate of $f_i$ liters of milk per second.\n\nFJ wants to buy some pipelines that form a single simple path whose endpoints are junction $1$ and junction $N$. The cost of this path is the sum of the costs of all pipelines on the path. The flow rate of the path is the minimum flow rate among all pipelines on the path (because this is the bottleneck when sending milk along the path). FJ wants to maximize the ratio of the path flow rate to the path cost. It is guaranteed that there exists a path from $1$ to $N$.", "inputFormat": "The first line of input contains $N$ and $M$. The next $M$ lines each describe one pipeline with four integers: $a$ and $b$ (the two different junctions the pipeline connects), $c$ (the cost of the pipeline), and $f$ (the flow rate of the pipeline). Both cost and flow rate are positive integers in the range $1 \\ldots 1000$.", "outputFormat": "Output $10^6$ times the value of the optimal answer, rounded down (that is, if this number is not an integer, output the greatest integer less than it).", "hint": "In this example, there is only one path from $1$ to $N$. Its flow rate is $\\min(3,4)=3$, and its cost is $2+5=7$.\n\n### Constraints\n\nTest cases $2 \\sim 5$ satisfy $N,M\\le 100$.\n\nFor $100\\%$ of the testdata, $2 \\leq N \\leq 1000$ and $1 \\leq M \\leq 1000$.\n\nProblem by: Brian Dean.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO19DEC] Milk Pumping G", "background": "", "description": "Farmer John 最近为了扩张他的牛奶产业帝国而收购了一个新的农场。这一新的农场通过一个管道网络与附近的小镇相连，FJ 想要找出其中最合适的一组管道，将其购买并用来将牛奶从农场输送到小镇。\n\n这个管道网络可以用 $N$ 个接合点（管道的端点）来描述，将其编号为 $1 \\ldots N$。接合点 $1$ 表示 FJ 的农场，接合点 $N$ 表示小镇。有 $M$ 条双向的管道，每条连接了两个接合点。使用第 $i$ 条管道需要 FJ 花费 $c_i$ 美元购入，可以支持每秒 $f_i$ 升牛奶的流量。\n\nFJ 想要购买一条管道组成一条单一路径，路径的两端点分别为接合点 $1$ 和 $N$。这条路径的花费等于路径上所有管道的费用之和。路径上的流量等于路径上所有管道的最小流量（因为这是沿这条路径输送牛奶的瓶颈）。FJ 想要最大化路径流量与路径花费之比。保证存在从 $1$ 到 $N$之间的路径。\n", "inputFormat": "输入的第一行包含 $N$ 和 $M$。以下 $M$ 行每行以四个整数描述一条管道：$a$ 和 $b$（管道连接的两个不同的接合点），$c$（管道的花费），以及 $f$（管道的流量）。花费和流量均为范围 $1 \\ldots 1000$ 之内的正整数。", "outputFormat": "输出 $10^6$ 乘以最优解的值，并向下取整（也就是说，如果这个数本身不是整数，输出小于它的最接近它的整数）。", "hint": "在这个例子中，仅由一条路径从 $1$ 到 $N$。 它的流量为 $\\min(3,4)=3$，花费为 $2+5=7$。\n\n### 数据范围\n\n测试点 $2\\sim 5$ 满足 $N,M\\le 100$。\n\n对于 $100\\%$ 的数据，$2 \\leq N \\leq 1000$，$1 \\leq M \\leq 1000$。\n\n供题：Brian Dean", "locale": "zh-CN"}}}
{"pid": "P5838", "type": "P", "difficulty": 5, "samples": [["5 5\n1 1 2 1 2\n1 2\n2 3\n2 4\n1 5\n1 4 1\n1 4 2\n1 3 2\n1 3 1\n5 5 1", "10110"], ["6 4\n1 2 3 3 3 3\n1 2\n2 3\n3 4\n2 5\n5 6\n4 6 1\n4 6 2\n4 6 3\n4 6 4", "0110"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2019", "USACO", "树上启发式合并", "树链剖分"], "title": "[USACO19DEC] Milk Visits G", "background": "", "description": "Farmer John 计划建造 $N$ 个农场，用 $N-1$ 条道路连接，构成一棵树（也就是说，所有农场之间都互相可以到达，并且没有环）。每个农场有一头奶牛，品种为 $1$ 到 $N$ 之间的一个整数 $T_i$。\n\nFarmer John 的 $M$ 个朋友经常前来拜访他。在朋友 $i$ 拜访之时，Farmer John 会与他的朋友沿着从农场 $A_i$ 到农场 $B_i$ 之间的唯一路径行走（可能有 $A_i = B_i$）。除此之外，他们还可以品尝他们经过的路径上任意一头奶牛的牛奶。由于 Farmer John 的朋友们大多数也是农场主，他们对牛奶有着极强的偏好。他的每个朋友都只喝某种特定品种的奶牛的牛奶。任何 Farmer John 的朋友只有在他们访问时能喝到他们偏好的牛奶才会高兴。\n\n请求出每个朋友在拜访过后是否会高兴。\n\n", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$。\n\n第二行包含 $N$ 个空格分隔的整数 $T_1,T_2,\\ldots, T_N$。第 $i$ 个农场内的奶牛的品种用 $T_i$ 表示。\n\n以下 $N-1$ 行，每行包含两个不同的整数 $X$ 和 $Y$（$1 \\leq X, Y \\leq N$），表示农场 $X$ 与 $Y$ 之间有一条边。\n\n以下 $M$ 行，每行包含整数 $A_i$，$B_i$，以及$C_i$。$A_i$ 和 $B_i$ 表示朋友 $i$ 拜访时行走的路径的端点，$C_i$（$1\\le C_i\\le N$）表示这个朋友喜欢的牛奶的奶牛品种。", "outputFormat": "输出一个长为 $M$ 的二进制字符串。如果第 $i$ 个朋友会感到高兴，则字符串的第 $i$ 个字符为 `1`，否则为 `0`。", "hint": "测试点性质：\n\n测试点 $2$ 为以下第二个样例。\n\n测试点 $3$ 满足 $N\\le 10^3$，$M\\le 2\\cdot 10^3$。\n\n测试点 $4\\sim 7$ 满足 $C_i\\le 10$。\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 10^5$，$1 \\leq M \\leq 10^5$。\n\n供题：Spencer Compton", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19DEC] Milk Visits G", "background": "", "description": "Farmer John plans to build $N$ farms and connect them with $N-1$ roads to form a tree (that is, every pair of farms is reachable, and there are no cycles). Each farm has one cow, with breed $T_i$, an integer between $1$ and $N$.\n\nFarmer John has $M$ friends who often come to visit him. When friend $i$ visits, Farmer John and this friend will walk along the unique path from farm $A_i$ to farm $B_i$ (it is possible that $A_i = B_i$). In addition, they can taste the milk of any cow on the path they travel. Since most of Farmer John’s friends are also farmers, they have strong preferences for milk. Each friend only drinks milk from one specific breed of cow. A friend will be happy only if, during their visit, they can drink milk of their preferred breed.\n\nPlease determine whether each friend will be happy after the visit.", "inputFormat": "The first line contains two integers $N$ and $M$.\n\nThe second line contains $N$ space-separated integers $T_1,T_2,\\ldots, T_N$. The cow breed on farm $i$ is given by $T_i$.\n\nThe next $N-1$ lines each contain two distinct integers $X$ and $Y$ ($1 \\leq X, Y \\leq N$), indicating there is an edge between farms $X$ and $Y$.\n\nThe next $M$ lines each contain integers $A_i$, $B_i$, and $C_i$. $A_i$ and $B_i$ are the endpoints of the path friend $i$ walks during the visit, and $C_i$ ($1 \\le C_i \\le N$) is the cow breed whose milk this friend likes.", "outputFormat": "Output a binary string of length $M$. If friend $i$ will be happy, the $i$-th character of the string is `1`, otherwise it is `0`.", "hint": "Test point properties.\n\nTest point $2$ is the second sample below.\n\nTest point $3$ satisfies $N\\le 10^3$, $M\\le 2\\cdot 10^3$.\n\nTest points $4\\sim 7$ satisfy $C_i\\le 10$.\n\nFor $100\\%$ of the testdata, $1 \\leq N \\leq 10^5$, $1 \\leq M \\leq 10^5$.\n\nProblem author: Spencer Compton.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO19DEC] Milk Visits G", "background": "", "description": "Farmer John 计划建造 $N$ 个农场，用 $N-1$ 条道路连接，构成一棵树（也就是说，所有农场之间都互相可以到达，并且没有环）。每个农场有一头奶牛，品种为 $1$ 到 $N$ 之间的一个整数 $T_i$。\n\nFarmer John 的 $M$ 个朋友经常前来拜访他。在朋友 $i$ 拜访之时，Farmer John 会与他的朋友沿着从农场 $A_i$ 到农场 $B_i$ 之间的唯一路径行走（可能有 $A_i = B_i$）。除此之外，他们还可以品尝他们经过的路径上任意一头奶牛的牛奶。由于 Farmer John 的朋友们大多数也是农场主，他们对牛奶有着极强的偏好。他的每个朋友都只喝某种特定品种的奶牛的牛奶。任何 Farmer John 的朋友只有在他们访问时能喝到他们偏好的牛奶才会高兴。\n\n请求出每个朋友在拜访过后是否会高兴。\n\n", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$。\n\n第二行包含 $N$ 个空格分隔的整数 $T_1,T_2,\\ldots, T_N$。第 $i$ 个农场内的奶牛的品种用 $T_i$ 表示。\n\n以下 $N-1$ 行，每行包含两个不同的整数 $X$ 和 $Y$（$1 \\leq X, Y \\leq N$），表示农场 $X$ 与 $Y$ 之间有一条边。\n\n以下 $M$ 行，每行包含整数 $A_i$，$B_i$，以及$C_i$。$A_i$ 和 $B_i$ 表示朋友 $i$ 拜访时行走的路径的端点，$C_i$（$1\\le C_i\\le N$）表示这个朋友喜欢的牛奶的奶牛品种。", "outputFormat": "输出一个长为 $M$ 的二进制字符串。如果第 $i$ 个朋友会感到高兴，则字符串的第 $i$ 个字符为 `1`，否则为 `0`。", "hint": "测试点性质：\n\n测试点 $2$ 为以下第二个样例。\n\n测试点 $3$ 满足 $N\\le 10^3$，$M\\le 2\\cdot 10^3$。\n\n测试点 $4\\sim 7$ 满足 $C_i\\le 10$。\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 10^5$，$1 \\leq M \\leq 10^5$。\n\n供题：Spencer Compton", "locale": "zh-CN"}}}
{"pid": "P5839", "type": "P", "difficulty": 5, "samples": [["5 5 2\nabcde\n0 1 4 4 4\n2 0 4 4 4\n6 5 0 3 2\n5 5 5 0 4\n3 7 0 5 0", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2019", "USACO", "前缀和", "Floyd 算法"], "title": "[USACO19DEC] Moortal Cowmbat G", "background": "", "description": "Bessie 玩格斗游戏真牛快打已经有很长时间了。然而，最近游戏开发者发布了一项更新，这迫使 Bessie 改变她的打法。\n\n游戏总共使用 $M$ 个按键，标记为前 $M$ 个小写字母。Bessie 在游戏中最喜欢的组合键是一个长为 $N$ 的按键字符串 $S$。然而，由于最近的更新，现在每种组合键必须由一些“连击”所组成，其中连击的定义为相同的按键连续按下至少 $K$ 次。Bessie想要修改她最喜欢的组合键，创造一个同样长为 $N$ 的新组合键，然而这一新组合键由按键连击所组成，以适应规则的变化。\n\nBessie 需要消耗 $a_{ij}$ 天来训练她在组合键中某个特定的位置用按键 $j$ 来取代按键 $i$（也就是说，将 $S$ 中的某个特定的字符由 $i$ 变为 $j$ 的代价为 $a_{ij}$）。注意有可能将按键 $i$ 换成某种中间按键 $k$ 然后再从按键 $k$ 换成按键 $j$ 会比直接从按键 $i$ 换成按键 $j$ 消耗更短的时间（或者更一般地说，可能有一条起点为 $i$ 终点为 $j$ 的更改路径给出了从按键 $i$ 最终更改为按键 $j$ 的最小总代价）。\n\n帮助 Bessie 求出她创建一个满足新要求的组合键所需要的最小天数。", "inputFormat": "输入的第一行包含 $N$，$M$ 和 $K$。第二行包含 $S$，最后 $M$ 行包含一个 $M\\times M$ 的数字方阵 $a_{ij}$，其中 $a_{ij}$ 为一个范围为 $0 \\ldots 1000$ 的整数，并且对于所有的 $i$，有 $a_{ii} = 0$。", "outputFormat": "输出一个整数，表示 Bessie 将她的组合键改为一个满足新要求的新的组合键所需要的最小天数。", "hint": "在这个例子中的最优方案是将 `a` 改为 `b`，将 `d` 改为 `e`，再将两个 `e` 都改为 `c`。这总共消耗 $1+4+0+0=5$ 天，最终的组合键为 `bbccc`。\n\n测试点性质：\n\n测试点 $2\\sim 4$ 满足 $N\\le 1000$，$K\\le 50$。\n\n测试点 $5\\sim 8$ 满足 $N\\le 3\\times 10^4$，$K\\le 50$。\n\n对于 $100\\%$ 的数据，$1 \\leq M \\leq 26$，$1 \\leq K\\leq N \\leq 10^5$。\n\n供题：Eric Wei", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19DEC] Moortal Cowmbat G", "background": "", "description": "Bessie has been playing the fighting game \"Moortal Cowmbat\" for a long time. However, the game developers recently released an update that forces Bessie to change her playstyle.\n\nThe game uses a total of $M$ keys, labeled as the first $M$ lowercase letters. Bessie's favorite combo in the game is a key string $S$ of length $N$. However, due to the recent update, every combo must be made up of some \"combos\", where a combo is defined as pressing the same key consecutively at least $K$ times. Bessie wants to modify her favorite combo to create a new combo of the same length $N$, but this new combo must be composed of such key combos to fit the new rules.\n\nBessie needs to spend $a_{ij}$ days to train herself to replace key $i$ with key $j$ at a specific position in the combo (that is, the cost to change a specific character in $S$ from $i$ to $j$ is $a_{ij}$). Note that it may be faster to change key $i$ to some intermediate key $k$ and then change key $k$ to key $j$ than to change directly from key $i$ to key $j$ (or, more generally, there may be a change path from $i$ to $j$ that gives the minimum total cost to finally change $i$ into $j$).\n\nHelp Bessie find the minimum number of days needed to create a combo that satisfies the new requirements.", "inputFormat": "The first line contains $N$, $M$, and $K$. The second line contains $S$. The last $M$ lines contain an $M\\times M$ matrix of integers $a_{ij}$, where $a_{ij}$ is an integer in the range $0 \\ldots 1000$, and for all $i$, $a_{ii} = 0$.", "outputFormat": "Output one integer, the minimum number of days needed for Bessie to change her combo into a new combo that satisfies the new requirements.", "hint": "In this example, the optimal plan is to change `a` to `b`, change `d` to `e`, and then change both `e` characters to `c`. This costs a total of $1+4+0+0=5$ days, and the final combo is `bbccc`.\n\nTest point properties:\n\nTest points $2\\sim 4$ satisfy $N\\le 1000$, $K\\le 50$.\n\nTest points $5\\sim 8$ satisfy $N\\le 3\\times 10^4$, $K\\le 50$.\n\nFor $100\\%$ of the data, $1 \\leq M \\leq 26$, $1 \\leq K\\leq N \\leq 10^5$.\n\nProblem by: Eric Wei.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO19DEC] Moortal Cowmbat G", "background": "", "description": "Bessie 玩格斗游戏真牛快打已经有很长时间了。然而，最近游戏开发者发布了一项更新，这迫使 Bessie 改变她的打法。\n\n游戏总共使用 $M$ 个按键，标记为前 $M$ 个小写字母。Bessie 在游戏中最喜欢的组合键是一个长为 $N$ 的按键字符串 $S$。然而，由于最近的更新，现在每种组合键必须由一些“连击”所组成，其中连击的定义为相同的按键连续按下至少 $K$ 次。Bessie想要修改她最喜欢的组合键，创造一个同样长为 $N$ 的新组合键，然而这一新组合键由按键连击所组成，以适应规则的变化。\n\nBessie 需要消耗 $a_{ij}$ 天来训练她在组合键中某个特定的位置用按键 $j$ 来取代按键 $i$（也就是说，将 $S$ 中的某个特定的字符由 $i$ 变为 $j$ 的代价为 $a_{ij}$）。注意有可能将按键 $i$ 换成某种中间按键 $k$ 然后再从按键 $k$ 换成按键 $j$ 会比直接从按键 $i$ 换成按键 $j$ 消耗更短的时间（或者更一般地说，可能有一条起点为 $i$ 终点为 $j$ 的更改路径给出了从按键 $i$ 最终更改为按键 $j$ 的最小总代价）。\n\n帮助 Bessie 求出她创建一个满足新要求的组合键所需要的最小天数。", "inputFormat": "输入的第一行包含 $N$，$M$ 和 $K$。第二行包含 $S$，最后 $M$ 行包含一个 $M\\times M$ 的数字方阵 $a_{ij}$，其中 $a_{ij}$ 为一个范围为 $0 \\ldots 1000$ 的整数，并且对于所有的 $i$，有 $a_{ii} = 0$。", "outputFormat": "输出一个整数，表示 Bessie 将她的组合键改为一个满足新要求的新的组合键所需要的最小天数。", "hint": "在这个例子中的最优方案是将 `a` 改为 `b`，将 `d` 改为 `e`，再将两个 `e` 都改为 `c`。这总共消耗 $1+4+0+0=5$ 天，最终的组合键为 `bbccc`。\n\n测试点性质：\n\n测试点 $2\\sim 4$ 满足 $N\\le 1000$，$K\\le 50$。\n\n测试点 $5\\sim 8$ 满足 $N\\le 3\\times 10^4$，$K\\le 50$。\n\n对于 $100\\%$ 的数据，$1 \\leq M \\leq 26$，$1 \\leq K\\leq N \\leq 10^5$。\n\n供题：Eric Wei", "locale": "zh-CN"}}}
{"pid": "P5840", "type": "P", "difficulty": 6, "samples": [["3\na\nbc\nabc\n5\n1 abca\n2 1\n1 bca\n2 2\n2 3\n", "1\n2\n1\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432]}, "tags": ["2015", "线段树", "树状数组", "AC 自动机", "差分", "COCI（克罗地亚）"], "title": "[COCI 2014/2015 #5] Divljak", "background": null, "description": "Alice 有 $n$ 个字符串 $S_1, S_2, \\dots, S_n$，Bob 有一个字符串集合 $T$，一开始集合是空的。\n\n接下来会发生 $q$ 个操作，操作有两种形式：\n\n1. `1 P`：Bob 往自己的集合里添加了一个字符串 $P$。\n2. `2 x`：Alice 询问 Bob，集合 $T$ 中有多少个字符串包含串 $S_x$（我们称串 $A$ 包含串 $B$，当且仅当 $B$ 是 $A$ 的子串）。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行一个字符串 ${S}_i$。\n\n接下来一行一个整数 $q$。\n\n接下来 $q$ 行，每行一个操作。", "outputFormat": "对每个 `2 x` 操作，一行一个整数，表示答案。", "hint": "对于 $50\\%$ 的数据，$n\\le 20000$。\n\n对于 $100\\%$ 的数据，$1\\le n, q\\le 10^5$，字符串由小写字母构成，$S$ 中所有字符串的长度之和与所有 $P$ 的长度之和分别 $\\le 2\\times 10^6$。\n\n译自 [COCI 2014/2015 CONTEST #5](https://hsin.hr/coci/archive/2014_2015/contest5_tasks.pdf)。", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2014/2015 #5] Divljak", "background": "", "description": "Alice has $n$ strings $S_1, S_2, \\dots, S_n$, and Bob has a set of strings $T$, which is empty at the beginning.\n\nThen there will be $q$ operations. There are two types of operations:\n\n1. `1 P`: Bob adds a string $P$ to his set.\n2. `2 x`: Alice asks Bob how many strings in set $T$ contain the string $S_x$ (we say string $A$ contains string $B$ if and only if $B$ is a substring of $A$).", "inputFormat": "The first line contains an integer $n$.\n\nThe next $n$ lines each contain a string ${S}_i$.\n\nThe next line contains an integer $q$.\n\nThe next $q$ lines each contain one operation.", "outputFormat": "For each `2 x` operation, output one integer per line, representing the answer.", "hint": "For $50\\%$ of the testdata, $n \\le 20000$.\n\nFor $100\\%$ of the testdata, $1 \\le n, q \\le 10^5$. All strings consist of lowercase letters. The sum of lengths of all strings in $S$ and the sum of lengths of all strings $P$ are each $\\le 2 \\times 10^6$.\n\nTranslated from [COCI 2014/2015 CONTEST #5](https://hsin.hr/coci/archive/2014_2015/contest5_tasks.pdf)。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COCI 2014/2015 #5] Divljak", "background": null, "description": "Alice 有 $n$ 个字符串 $S_1, S_2, \\dots, S_n$，Bob 有一个字符串集合 $T$，一开始集合是空的。\n\n接下来会发生 $q$ 个操作，操作有两种形式：\n\n1. `1 P`：Bob 往自己的集合里添加了一个字符串 $P$。\n2. `2 x`：Alice 询问 Bob，集合 $T$ 中有多少个字符串包含串 $S_x$（我们称串 $A$ 包含串 $B$，当且仅当 $B$ 是 $A$ 的子串）。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行一个字符串 ${S}_i$。\n\n接下来一行一个整数 $q$。\n\n接下来 $q$ 行，每行一个操作。", "outputFormat": "对每个 `2 x` 操作，一行一个整数，表示答案。", "hint": "对于 $50\\%$ 的数据，$n\\le 20000$。\n\n对于 $100\\%$ 的数据，$1\\le n, q\\le 10^5$，字符串由小写字母构成，$S$ 中所有字符串的长度之和与所有 $P$ 的长度之和分别 $\\le 2\\times 10^6$。\n\n译自 [COCI 2014/2015 CONTEST #5](https://hsin.hr/coci/archive/2014_2015/contest5_tasks.pdf)。", "locale": "zh-CN"}}}
{"pid": "P5841", "type": "P", "difficulty": 7, "samples": [["4 6\na\nb\nabc\nbc\n1 2\n1 3\n3 1\n4 2\n2 4\n2 4\n", "2\n4 1 3 5 6\n3 1 2 4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2011", "并查集", "Special Judge", "字典树 Trie", "CTSC/CTS"], "title": "[CTSC2011] 字符串重排", "background": null, "description": "对于两个字符串 $A = a_1 a_2 \\cdots a_n$ 和 $B = b_1 b_2 \\cdots b_n$，定义其最长公共前缀长度 $\\text{lcp} (A,B)$  如下：\n\n$$\\text{lcp}(A,B) = \\max \\{k|0 \\le k \\le n,k \\le m,a_1 a_2 \\cdots a_k = b_1 b_2 \\cdots b_k \\}$$\n\n给定 $n$ 个由小写字母组成的两两不同的非空字符串 $S_1,S_2,\\cdots , S_n$，对于一个 $1$ 到 $n$ 的排列 $P=(p_1,p_2,\\cdots,p_n)$，定义 $P$ 的价值 $W(P)$ 如下：\n\n$$W(P) = \\sum_{i=2}^n (\\text{lcp}(S_{p_{i-1}},S_{p_i}))^2$$\n\n我们设能够产生最大价值的排列为 $P^*_G$。\n\n此外，还有 $q$ 个附加任务。对于第 $i$ 个任务，给定两个 $1$ 到 $n$ 之间的不同的整数 $X_i$ 和 $Y_i$。对于排列 $P$，若 $P$ 在满足 $W(P) = W(P^*_G)$ 的前提条件之下，同时满足第 $X_i$ 个字符串 $S_{X_i}$ 恰好排在第 $Y_i$ 个字符串 $S_{Y_i}$ 之前， 即 $\\text{pos}(S_{X_i}) + 1 = \\text{pos}(S_{Y_i})$，其中 $\\text{pos}(S_i)$ 表示字符串 $S_i$ 在排列中的位置，则排列 $P$ 还将获得 $2^i$ 的奖励。所有任务的奖励之和称之为总任务奖励。\n\n我们设能够使得总任务奖励最大的排列为 $P^*_B$。\n\n试求：\n\n1. $W(P^*_G)$，即可能产生的最大价值；\n2. $P^*_B$，在保证最大价值前提下，可以使总任务奖励最大的排列。", "inputFormat": "第一行包含两个整数 $n$ 和 $q$，表示字符串和附加任务的数量，中间用一个空格隔开；\n\n接下来 $n$ 行，描述字符串，其中第 $i$ 行包含一个字符串 $S_i$；\n\n接下来 $q$ 行，描述附加任务，其中第 $i$ 行包含两个整数 $X_i$ 和 $Y_i$，中间用一个空格隔开。", "outputFormat": "包含三行。\n\n第一行包含一个非负整数 $W(P^*_G)$；\n\n第二行若干个数，每两个数之间用一个空格隔开，这一行第一个数表示满足附加任务的数量 $k$，接下来 $k$ 个数为这些任务的序号，序号从 $1$ 开始，按从小到大的顺序输出；\n\n第三行包含 $n$ 个用一个空格隔开的正整数，表示一个 $1$ 到 $n$ 的排列 $P^*_B$。", "hint": "**评分标准**\n\n对于一个测试点：\n\n- 如果输出文件的第一行正确可以得到 $2$ 分；\n- 如果输出文件的第二行正确可以得到 $4$ 分；\n- 如果输出文件的第三行正确可以得到 $4$ 分；\n- 如果输出文件的三行都正确则可以得到 $10$ 分。\n\n对于第三问中的排列，如果存在多个解， 则输出任意一个解均可得分。\n\n若某问无法完成，也请按照格式输出，以避免测评失败。\n\n**数据范围**\n\n- 对于 $10\\%$ 的数据，$n \\le 10$，$q=1$，每个字符串的长度不超过 $50$；\n- 对于 $20\\%$ 的数据，$n \\le 50$，$q=1$，每个字符串的长度不超过 $50$；\n- 对于 $50\\%$ 的数据，$n,q \\le 1000$，每个字符串的长度不超过 $1000$；\n- 对于 $70\\%$ 的数据，任意字符串不为其他任何一个字符串的前缀；\n- 对于 $100\\%$ 的数据，$n \\le 4 \\times 10^4$，$q \\le 10^5$，每个字符串的长度不超过 $10^4$，所有字符串的长度和不超过 $2 \\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2011] String Rearrangement", "background": "", "description": "For two strings $A = a_1 a_2 \\cdots a_n$ and $B = b_1 b_2 \\cdots b_n$, define the length of their longest common prefix $\\text{lcp}(A,B)$ as follows:\n\n$$\\text{lcp}(A,B) = \\max \\{k|0 \\le k \\le n,k \\le m,a_1 a_2 \\cdots a_k = b_1 b_2 \\cdots b_k \\}$$\n\nGiven $n$ pairwise distinct non-empty strings $S_1,S_2,\\cdots , S_n$ consisting of lowercase letters, for a permutation $P=(p_1,p_2,\\cdots,p_n)$ of $1$ to $n$, define the value $W(P)$ as:\n\n$$W(P) = \\sum_{i=2}^n (\\text{lcp}(S_{p_{i-1}},S_{p_i}))^2$$\n\nLet a permutation that can produce the maximum value be $P^*_G$.\n\nIn addition, there are $q$ extra tasks. For the $i$-th task, two different integers $X_i$ and $Y_i$ between $1$ and $n$ are given. For a permutation $P$, if under the condition that $W(P) = W(P^*_G)$, it also satisfies that the $X_i$-th string $S_{X_i}$ is placed immediately before the $Y_i$-th string $S_{Y_i}$, i.e. $\\text{pos}(S_{X_i}) + 1 = \\text{pos}(S_{Y_i})$, where $\\text{pos}(S_i)$ denotes the position of string $S_i$ in the permutation, then the permutation $P$ will additionally receive a reward of $2^i$. The sum of rewards of all tasks is called the total task reward.\n\nLet a permutation that can maximize the total task reward be $P^*_B$.\n\nFind:\n\n1. $W(P^*_G)$, the maximum value possible.\n2. $P^*_B$, a permutation that, while ensuring the maximum value, can maximize the total task reward.", "inputFormat": "The first line contains two integers $n$ and $q$, representing the number of strings and the number of extra tasks, separated by a space.\n\nIn the next $n$ lines, the strings are given. The $i$-th line contains a string $S_i$.\n\nIn the next $q$ lines, the extra tasks are given. The $i$-th line contains two integers $X_i$ and $Y_i$, separated by a space.", "outputFormat": "The output contains three lines.\n\nThe first line contains a non-negative integer $W(P^*_G)$.\n\nThe second line contains several numbers separated by single spaces. The first number is the number of satisfied extra tasks $k$, followed by $k$ numbers which are the indices of these tasks. The indices start from $1$ and must be output in increasing order.\n\nThe third line contains $n$ positive integers separated by spaces, representing a permutation $P^*_B$ of $1$ to $n$.", "hint": "**Scoring**\n\nFor each test point:\n\n- If the first line of the output file is correct, you can get $2$ points.\n- If the second line of the output file is correct, you can get $4$ points.\n- If the third line of the output file is correct, you can get $4$ points.\n- If all three lines are correct, you can get $10$ points.\n\nFor the permutation in the third question, if multiple solutions exist, outputting any one of them will be accepted.\n\nIf you cannot complete some part, please still output according to the required format to avoid judging failure.\n\n**Constraints**\n\n- For $10\\%$ of the data, $n \\le 10$, $q = 1$, and each string length is at most $50$.\n- For $20\\%$ of the data, $n \\le 50$, $q = 1$, and each string length is at most $50$.\n- For $50\\%$ of the data, $n,q \\le 1000$, and each string length is at most $1000$.\n- For $70\\%$ of the data, no string is a prefix of any other string.\n- For $100\\%$ of the data, $n \\le 4 \\times 10^4$, $q \\le 10^5$, each string length is at most $10^4$, and the sum of all string lengths is at most $2 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2011] 字符串重排", "background": null, "description": "对于两个字符串 $A = a_1 a_2 \\cdots a_n$ 和 $B = b_1 b_2 \\cdots b_n$，定义其最长公共前缀长度 $\\text{lcp} (A,B)$  如下：\n\n$$\\text{lcp}(A,B) = \\max \\{k|0 \\le k \\le n,k \\le m,a_1 a_2 \\cdots a_k = b_1 b_2 \\cdots b_k \\}$$\n\n给定 $n$ 个由小写字母组成的两两不同的非空字符串 $S_1,S_2,\\cdots , S_n$，对于一个 $1$ 到 $n$ 的排列 $P=(p_1,p_2,\\cdots,p_n)$，定义 $P$ 的价值 $W(P)$ 如下：\n\n$$W(P) = \\sum_{i=2}^n (\\text{lcp}(S_{p_{i-1}},S_{p_i}))^2$$\n\n我们设能够产生最大价值的排列为 $P^*_G$。\n\n此外，还有 $q$ 个附加任务。对于第 $i$ 个任务，给定两个 $1$ 到 $n$ 之间的不同的整数 $X_i$ 和 $Y_i$。对于排列 $P$，若 $P$ 在满足 $W(P) = W(P^*_G)$ 的前提条件之下，同时满足第 $X_i$ 个字符串 $S_{X_i}$ 恰好排在第 $Y_i$ 个字符串 $S_{Y_i}$ 之前， 即 $\\text{pos}(S_{X_i}) + 1 = \\text{pos}(S_{Y_i})$，其中 $\\text{pos}(S_i)$ 表示字符串 $S_i$ 在排列中的位置，则排列 $P$ 还将获得 $2^i$ 的奖励。所有任务的奖励之和称之为总任务奖励。\n\n我们设能够使得总任务奖励最大的排列为 $P^*_B$。\n\n试求：\n\n1. $W(P^*_G)$，即可能产生的最大价值；\n2. $P^*_B$，在保证最大价值前提下，可以使总任务奖励最大的排列。", "inputFormat": "第一行包含两个整数 $n$ 和 $q$，表示字符串和附加任务的数量，中间用一个空格隔开；\n\n接下来 $n$ 行，描述字符串，其中第 $i$ 行包含一个字符串 $S_i$；\n\n接下来 $q$ 行，描述附加任务，其中第 $i$ 行包含两个整数 $X_i$ 和 $Y_i$，中间用一个空格隔开。", "outputFormat": "包含三行。\n\n第一行包含一个非负整数 $W(P^*_G)$；\n\n第二行若干个数，每两个数之间用一个空格隔开，这一行第一个数表示满足附加任务的数量 $k$，接下来 $k$ 个数为这些任务的序号，序号从 $1$ 开始，按从小到大的顺序输出；\n\n第三行包含 $n$ 个用一个空格隔开的正整数，表示一个 $1$ 到 $n$ 的排列 $P^*_B$。", "hint": "**评分标准**\n\n对于一个测试点：\n\n- 如果输出文件的第一行正确可以得到 $2$ 分；\n- 如果输出文件的第二行正确可以得到 $4$ 分；\n- 如果输出文件的第三行正确可以得到 $4$ 分；\n- 如果输出文件的三行都正确则可以得到 $10$ 分。\n\n对于第三问中的排列，如果存在多个解， 则输出任意一个解均可得分。\n\n若某问无法完成，也请按照格式输出，以避免测评失败。\n\n**数据范围**\n\n- 对于 $10\\%$ 的数据，$n \\le 10$，$q=1$，每个字符串的长度不超过 $50$；\n- 对于 $20\\%$ 的数据，$n \\le 50$，$q=1$，每个字符串的长度不超过 $50$；\n- 对于 $50\\%$ 的数据，$n,q \\le 1000$，每个字符串的长度不超过 $1000$；\n- 对于 $70\\%$ 的数据，任意字符串不为其他任何一个字符串的前缀；\n- 对于 $100\\%$ 的数据，$n \\le 4 \\times 10^4$，$q \\le 10^5$，每个字符串的长度不超过 $10^4$，所有字符串的长度和不超过 $2 \\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5842", "type": "P", "difficulty": 7, "samples": [["3\n1 14 4\n1 30 4\n10 60 5\n", "18\n40\n66\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "四川", "各省省选"], "title": "[SCOI2012] Blinker 的仰慕者", "background": "", "description": "Blinker 有非常多的仰慕者，他给每个仰慕者一个正整数编号。而且这些编号还隐藏着特殊的意义，即编号的各位数字之积表示这名仰慕者对 Blinker 的重要度。 现在 Blinker 想知道编号介于某两个值 $A$,$B$ 之间，且重要度为某个定值 $K$ 的仰慕者编号和。", "inputFormat": "输入的第一行是一个整数 $N$，表示 Blinker 想知道的信息个数。\n\n接下来的 $N$ 行，每行有三个数，$A$,$B$,$K$。表示 Blinker想知道编号介于 $A$ 和 $B$ 之间的，重要度为 $K$ 的仰慕者的编号和。   ", "outputFormat": "输出 $N$ 行，每行输出介于 $A$ 和 $B$ 之间，重要度为 $K$ 的仰慕者编号和。结果可能很大请对 $20120427$ 取模。", "hint": "- 对于 $20\\%$ 的数据，保证： $2 \\le A  \\le B \\le 10^9$，$1 \\le N \\le 30$；\n- 对于 $50\\%$ 的数据，保证：$ 2 \\le A \\le B \\le 10^{18}$，$1\\le N \\le 30$；\n- 对于 $100\\%$ 的数据，保证：  $ 2 \\le A \\le B \\le 10^{18}$，$1 \\le N \\le 5000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2012] Blinker’s Admirers", "background": "", "description": "Blinker has many admirers, and he gives each admirer a positive integer ID. These IDs also hide a special meaning: the product of the digits of an ID represents how important this admirer is to Blinker. Now Blinker wants to know the sum of all admirer IDs between two values $A$ and $B$, whose importance equals a fixed value $K$.", "inputFormat": "The first line contains an integer $N$, which represents the number of queries Blinker wants to ask.\n\nThe next $N$ lines each contain three numbers $A$, $B$, and $K$, meaning Blinker wants the sum of all admirer IDs between $A$ and $B$ whose importance is $K$.", "outputFormat": "Output $N$ lines. For each query, output the sum of all admirer IDs between $A$ and $B$ whose importance is $K$. Since the result may be very large, take it modulo $20120427$.", "hint": "## Constraints\n\n- For $20\\%$ of the testdata: $2 \\le A \\le B \\le 10^9$, $1 \\le N \\le 30$.\n- For $50\\%$ of the testdata: $2 \\le A \\le B \\le 10^{18}$, $1 \\le N \\le 30$.\n- For $100\\%$ of the testdata: $2 \\le A \\le B \\le 10^{18}$, $1 \\le N \\le 5000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2012] Blinker 的仰慕者", "background": "", "description": "Blinker 有非常多的仰慕者，他给每个仰慕者一个正整数编号。而且这些编号还隐藏着特殊的意义，即编号的各位数字之积表示这名仰慕者对 Blinker 的重要度。 现在 Blinker 想知道编号介于某两个值 $A$,$B$ 之间，且重要度为某个定值 $K$ 的仰慕者编号和。", "inputFormat": "输入的第一行是一个整数 $N$，表示 Blinker 想知道的信息个数。\n\n接下来的 $N$ 行，每行有三个数，$A$,$B$,$K$。表示 Blinker想知道编号介于 $A$ 和 $B$ 之间的，重要度为 $K$ 的仰慕者的编号和。   ", "outputFormat": "输出 $N$ 行，每行输出介于 $A$ 和 $B$ 之间，重要度为 $K$ 的仰慕者编号和。结果可能很大请对 $20120427$ 取模。", "hint": "- 对于 $20\\%$ 的数据，保证： $2 \\le A  \\le B \\le 10^9$，$1 \\le N \\le 30$；\n- 对于 $50\\%$ 的数据，保证：$ 2 \\le A \\le B \\le 10^{18}$，$1\\le N \\le 30$；\n- 对于 $100\\%$ 的数据，保证：  $ 2 \\le A \\le B \\le 10^{18}$，$1 \\le N \\le 5000$。", "locale": "zh-CN"}}}
{"pid": "P5843", "type": "P", "difficulty": 6, "samples": [["2 4\nC 0 0 2 1\nP 4 -1 -1 -1 1 1 1 1 -1 2\nQ -2 -2 2 2\nQ -1.5 0 0.0 0.0\nC 1 1005\nQ -1.5 0 0.0 0.0", "0\n2\n0"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2012", "四川", "各省省选"], "title": "[SCOI2012] Blinker 的噩梦", "background": "", "description": "一天 Blinker 醒来，发现自己成为了一个二维世界的点，而且被标记上了一个奇怪的值。\n\n这个世界是由 $N$ 个边界互不相交（且不相切）的图形组成，这里图形仅包括圆和凸多边形。每个图形还有一个权值。每次 Blinker 走进或走出某个图形时（相切时经过不算），Blinker 的标记值就会被异或上那个值。\n\n现在，我们记录了 Blinker 在这个世界的 $M$ 天的信息。每天可能发生两种事情，一种是某个图形的权值更改为某个值；另一种是 Blinker 从某个点走到另一个点。 \n\n我们假设 Blinker 首次出发前的标记值为 $0$，我们希望知道他每次到达目的地后的标记值。", "inputFormat": "输入的第一行包含 $2$ 个数，$N$ 和 $M$，分别表示这个世界的图形数和记录的天数。 \n\n接下来有 $N$ 行，每行表示一个图形。 \n\n如果一行以字符 `C` 开头，表示这个图形是一个圆，后面紧跟着三个实数 $x$, $y$, $r$ 和一个整数 $v$，分别表示圆的 $x$ 坐标，$y$ 坐标和圆的半径以及该图形对应的值。 \n\n如果一行以字符 `P` 开头，表示这个图形是凸多边形，后面紧跟着一个整数 $L$，表示凸多边形的点数，然后后面有 $L$ 对实数 $x_0$,$y_0$,$x_1$,$y_1$ $\\cdots$，表示 $L$ 个点的坐标，这一行最后一个数是一个整数 $v$，表示这个图形对应的值，保证凸多边形上的点按照顺时针给出。 \n\n接下来有 $M$ 行，每行表示一天的记录信息。\n\n如果一行以字符 `Q` 开头，表示这一天 Blinker 出行了，接下来有 $x_0,y_0,x_1,y_1$ 四个实数，分别表示出发点的坐标和目的地的坐标。\n\n如果一行以字符 `C` 开头，表示这一天某个图形的值改变了，接下来有两个 $i$ 和 $v$，表示输入中第 $i$ 个出现的图形的值变成 $v$。", "outputFormat": "对于 Blinker 的每个出行输出他到达目的地后的标记值，很显然这个值与 Blinker 的路径无关。", "hint": "**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mj50qefg.png)\n\n样例的世界形如上图：\n\n第一天 Binker 的初始标记值为 $0$，可能从 $A$ 沿直线走到 $B$，或者他绕过圆走到 $B$，他的标记值最终都保持不变为 $0$（假设沿直线从 $A$ 走到 $B$，共穿过 $4$ 次边界，Binker 的标记值变化过程为 $1,3,1,0$）;\n\n第二天 Binker 的初始标记值为 $0$，他通过某种不经过图形边界的方法到达了 $C$ 点（即 Binker 瞬间移动或闪烁），然后从 $C$ 沿某种路径走到 $D$，这时他的标记值变为 $2$；\n\n第三天圆的权值变为 $1005$；\n\n第四天 Binker 的初始标记值为 $2$，他再次回到 $C$，并再次从 $C$ 走到 $D$，这时他的标记值又变为 $0$。\n\n**数据范围**\n- 对于 $30\\%$ 的数据，$1 \\le M \\le 10.00$，凸多边形的点数加上圆的个数小于等于 $1000$；\n- 对于 $100\\%$ 的数据，$1 \\le N \\le 10^5$，$1 \\le M \\le 10^5$，单个凸多边形的点数小于等于 $34$。图形互不相交，且 Binker 的出发点和目的地不在图形的边界。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2012] Blinker’s Nightmare", "background": "", "description": "One day, Blinker woke up and found that he had become a point in a two-dimensional world, and was marked with a strange value.\n\nThis world consists of $N$ shapes whose boundaries do not intersect (and do not touch). The shapes include only circles and convex polygons. Each shape also has a weight. Each time Blinker enters or leaves a shape (passing while tangent does not count), Blinker’s marked value will be XORed with that weight.\n\nNow, we have recorded Blinker’s information for $M$ days in this world. Each day, one of two things may happen: the weight of some shape is changed to a certain value; or Blinker moves from one point to another point.\n\nWe assume that Blinker’s marked value before his first departure is $0$, and we want to know his marked value after he arrives at the destination each time.", "inputFormat": "The first line contains $2$ numbers, $N$ and $M$, representing the number of shapes in this world and the number of recorded days.\n\nNext, there are $N$ lines, each describing a shape.\n\nIf a line starts with the character `C`, it means the shape is a circle. It is followed by three real numbers $x$, $y$, $r$ and an integer $v$, representing the circle’s $x$ coordinate, $y$ coordinate, radius, and the value of this shape.\n\nIf a line starts with the character `P`, it means the shape is a convex polygon. It is followed by an integer $L$, the number of vertices of the convex polygon, then $L$ pairs of real numbers $x_0$,$y_0$,$x_1$,$y_1$ $\\cdots$, representing the coordinates of the $L$ points. The last number on this line is an integer $v$, representing the value of this shape. It is guaranteed that the points of the convex polygon are given in clockwise order.\n\nNext, there are $M$ lines, each describing one day’s record.\n\nIf a line starts with the character `Q`, it means Blinker traveled on that day. It is followed by four real numbers $x_0,y_0,x_1,y_1$, representing the coordinates of the starting point and the destination.\n\nIf a line starts with the character `C`, it means the value of a shape changed on that day. It is followed by two numbers $i$ and $v$, meaning that the value of the $i$-th shape in the input becomes $v$.", "outputFormat": "For each of Blinker’s travels, output his marked value after he arrives at the destination. Obviously, this value is independent of Blinker’s path.", "hint": "**Sample Explanation**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mj50qefg.png)\n\nThe sample world looks like the figure above:\n\nOn day 1, Binker’s initial marked value is $0$. He may go from $A$ to $B$ along a straight line, or he may go around the circle to reach $B$. His marked value finally remains $0$ in both cases. (Assuming he goes from $A$ to $B$ along the straight line, he crosses the boundary $4$ times, and Binker’s marked value changes as $1,3,1,0$.)\n\nOn day 2, Binker’s initial marked value is $0$. He reaches point $C$ by some method that does not pass through any shape boundary (that is, Binker teleports or blinks), and then goes from $C$ to $D$ along some path. At this time, his marked value becomes $2$.\n\nOn day 3, the circle’s weight becomes $1005$.\n\nOn day 4, Binker’s initial marked value is $2$. He returns to $C$ again, and again goes from $C$ to $D$. At this time, his marked value becomes $0$ again.\n\n**Constraints**\n- For $30\\%$ of the testdata, $1 \\le M \\le 10.00$, and the total number of polygon vertices plus the number of circles is at most $1000$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 10^5$, $1 \\le M \\le 10^5$, and the number of vertices in a single convex polygon is at most $34$. The shapes do not intersect each other, and Blinker’s starting point and destination are not on any shape boundary.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2012] Blinker 的噩梦", "background": "", "description": "一天 Blinker 醒来，发现自己成为了一个二维世界的点，而且被标记上了一个奇怪的值。\n\n这个世界是由 $N$ 个边界互不相交（且不相切）的图形组成，这里图形仅包括圆和凸多边形。每个图形还有一个权值。每次 Blinker 走进或走出某个图形时（相切时经过不算），Blinker 的标记值就会被异或上那个值。\n\n现在，我们记录了 Blinker 在这个世界的 $M$ 天的信息。每天可能发生两种事情，一种是某个图形的权值更改为某个值；另一种是 Blinker 从某个点走到另一个点。 \n\n我们假设 Blinker 首次出发前的标记值为 $0$，我们希望知道他每次到达目的地后的标记值。", "inputFormat": "输入的第一行包含 $2$ 个数，$N$ 和 $M$，分别表示这个世界的图形数和记录的天数。 \n\n接下来有 $N$ 行，每行表示一个图形。 \n\n如果一行以字符 `C` 开头，表示这个图形是一个圆，后面紧跟着三个实数 $x$, $y$, $r$ 和一个整数 $v$，分别表示圆的 $x$ 坐标，$y$ 坐标和圆的半径以及该图形对应的值。 \n\n如果一行以字符 `P` 开头，表示这个图形是凸多边形，后面紧跟着一个整数 $L$，表示凸多边形的点数，然后后面有 $L$ 对实数 $x_0$,$y_0$,$x_1$,$y_1$ $\\cdots$，表示 $L$ 个点的坐标，这一行最后一个数是一个整数 $v$，表示这个图形对应的值，保证凸多边形上的点按照顺时针给出。 \n\n接下来有 $M$ 行，每行表示一天的记录信息。\n\n如果一行以字符 `Q` 开头，表示这一天 Blinker 出行了，接下来有 $x_0,y_0,x_1,y_1$ 四个实数，分别表示出发点的坐标和目的地的坐标。\n\n如果一行以字符 `C` 开头，表示这一天某个图形的值改变了，接下来有两个 $i$ 和 $v$，表示输入中第 $i$ 个出现的图形的值变成 $v$。", "outputFormat": "对于 Blinker 的每个出行输出他到达目的地后的标记值，很显然这个值与 Blinker 的路径无关。", "hint": "**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mj50qefg.png)\n\n样例的世界形如上图：\n\n第一天 Binker 的初始标记值为 $0$，可能从 $A$ 沿直线走到 $B$，或者他绕过圆走到 $B$，他的标记值最终都保持不变为 $0$（假设沿直线从 $A$ 走到 $B$，共穿过 $4$ 次边界，Binker 的标记值变化过程为 $1,3,1,0$）;\n\n第二天 Binker 的初始标记值为 $0$，他通过某种不经过图形边界的方法到达了 $C$ 点（即 Binker 瞬间移动或闪烁），然后从 $C$ 沿某种路径走到 $D$，这时他的标记值变为 $2$；\n\n第三天圆的权值变为 $1005$；\n\n第四天 Binker 的初始标记值为 $2$，他再次回到 $C$，并再次从 $C$ 走到 $D$，这时他的标记值又变为 $0$。\n\n**数据范围**\n- 对于 $30\\%$ 的数据，$1 \\le M \\le 10.00$，凸多边形的点数加上圆的个数小于等于 $1000$；\n- 对于 $100\\%$ 的数据，$1 \\le N \\le 10^5$，$1 \\le M \\le 10^5$，单个凸多边形的点数小于等于 $34$。图形互不相交，且 Binker 的出发点和目的地不在图形的边界。", "locale": "zh-CN"}}}
{"pid": "P5844", "type": "P", "difficulty": 4, "samples": [["5 20 6\n1\n2\n10\n12\n14", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "二分", "IOI", "前缀和", "双指针 two-pointer"], "title": "[IOI 2011] ricehub", "background": "", "description": "乡间有一条笔直而长的路称为“米道”。沿着这条米道上$R$  块稻田，每块稻田的坐标均为一个 $1$ 到 $L$ 之间(含 $1$ 和 $L$ )的整数。这些稻田按照坐标以不减的顺序给出，即对于 $0 \\le i < R$，稻田 $i$ 的坐标 $X[i]$ 满足 $1 \\le X[0] \\le \\cdots \\le X[R-1] \\le L$。\n\n注意：可能有多块稻田位于同一个坐标上。\n\n我们计划建造一个米仓用于储存尽可能多的稻米。和稻田一样，米仓将建在米道上，其坐标也是一个 $1$ 到 $L$ 之间的整数（含 $1$ 和 $L$）。这个米仓可以建在满足上述条件的任一个位置上，包括那些原来已有一个或多个稻田存在的位置。\n\n在收获季节，每一块稻田刚好出产一滿货车的稻米。为了将这些稻米运到米仓，需要雇用一位货车司机来运米。司机的收费是每一满货车运送一个单位的距离收取 $1$ 元。換言之，将稻米从特定的稻田运到米仓的费用在数值上等于稻田坐标与米仓坐标之差的绝对值。\n\n不幸的是，今年预算有限，我们至多只能花费 $B$ 元运费。你的任务是要帮我们找出一个建造米仓的位置，可以收集到尽可能多的稻米。", "inputFormat": "第一行 三个整数 $R,L,B$；\n\n接下来 $R$ 行 每行一个整数 表示 $X[i]$。", "outputFormat": "一个整数，表示最多稻米数", "hint": "对于 $100\\%$ 的数据，$1 \\le R \\le 10^5$，$1 \\le L \\le 10^9$，$ 0 \\le B \\le 2 \\times 10^{15}$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2011] ricehub", "background": "", "description": "In the countryside, there is a straight and long road called the “Rice Road”. Along this Rice Road there are $R$ rice fields, and the coordinate of each field is an integer between $1$ and $L$ (including $1$ and $L$). These fields are given in non-decreasing order of coordinates, that is, for $0 \\le i < R$, the coordinate $X[i]$ of field $i$ satisfies $1 \\le X[0] \\le \\cdots \\le X[R-1] \\le L$.\n\nNote: multiple fields may be located at the same coordinate.\n\nWe plan to build a rice hub to store as much rice as possible. Like the rice fields, the hub will be built on the Rice Road, and its coordinate is also an integer between $1$ and $L$ (including $1$ and $L$). The hub can be built at any position that satisfies the above conditions, including positions where one or more rice fields already exist.\n\nDuring harvest season, each rice field produces exactly one full truckload of rice. To transport this rice to the hub, we need to hire a truck driver. The driver charges $1$ yuan per unit distance for each full truckload. In other words, the cost to transport rice from a particular field to the hub equals the absolute difference between the field’s coordinate and the hub’s coordinate.\n\nUnfortunately, this year the budget is limited, and we can spend at most $B$ yuan on transportation. Your task is to help us find a hub location that can collect as much rice as possible.", "inputFormat": "The first line contains three integers $R, L, B$.\n\nThe next $R$ lines each contain one integer, representing $X[i]$.", "outputFormat": "Output one integer, the maximum amount of rice that can be collected.", "hint": "For $100\\%$ of the testdata, $1 \\le R \\le 10^5$, $1 \\le L \\le 10^9$, $0 \\le B \\le 2 \\times 10^{15}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2011] ricehub", "background": "", "description": "乡间有一条笔直而长的路称为“米道”。沿着这条米道上$R$  块稻田，每块稻田的坐标均为一个 $1$ 到 $L$ 之间(含 $1$ 和 $L$ )的整数。这些稻田按照坐标以不减的顺序给出，即对于 $0 \\le i < R$，稻田 $i$ 的坐标 $X[i]$ 满足 $1 \\le X[0] \\le \\cdots \\le X[R-1] \\le L$。\n\n注意：可能有多块稻田位于同一个坐标上。\n\n我们计划建造一个米仓用于储存尽可能多的稻米。和稻田一样，米仓将建在米道上，其坐标也是一个 $1$ 到 $L$ 之间的整数（含 $1$ 和 $L$）。这个米仓可以建在满足上述条件的任一个位置上，包括那些原来已有一个或多个稻田存在的位置。\n\n在收获季节，每一块稻田刚好出产一滿货车的稻米。为了将这些稻米运到米仓，需要雇用一位货车司机来运米。司机的收费是每一满货车运送一个单位的距离收取 $1$ 元。換言之，将稻米从特定的稻田运到米仓的费用在数值上等于稻田坐标与米仓坐标之差的绝对值。\n\n不幸的是，今年预算有限，我们至多只能花费 $B$ 元运费。你的任务是要帮我们找出一个建造米仓的位置，可以收集到尽可能多的稻米。", "inputFormat": "第一行 三个整数 $R,L,B$；\n\n接下来 $R$ 行 每行一个整数 表示 $X[i]$。", "outputFormat": "一个整数，表示最多稻米数", "hint": "对于 $100\\%$ 的数据，$1 \\le R \\le 10^5$，$1 \\le L \\le 10^9$，$ 0 \\le B \\le 2 \\times 10^{15}$。", "locale": "zh-CN"}}}
{"pid": "P5845", "type": "P", "difficulty": 5, "samples": [["13 12 9\n0 1 1\n0 2 4\n0 3 11\n1 4 11\n1 5 7\n1 6 15\n2 7 3\n2 8 13\n2 9 23\n3 10 3\n3 11 1\n3 12 2\n4 5 6 7 8 9 10 11 12\n", "13\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2011", "IOI", "最短路"], "title": "[IOI 2011] crocodile", "background": null, "description": "考古学家 Benjamas 考察了神秘的鳄鱼地下宫殿之后需要设法逃离。这个地下宫殿包含 $N$ 个洞穴和 $M$ 条双向的通道。每条通道连接一对不同的洞穴，两个洞穴之间最多只有一条通道，在不同的通道上行走可能需要不同的时间。$N$ 个洞穴中有 $K$ 个洞穴是出口洞穴，Benjamas 可以从出口洞穴逃离。Benjamas 从 $0$ 号洞穴出发，她希望尽快地到达一个出口洞穴。\n\n鳄鱼门卫要阻止 Benjamas 逃离宫殿。它可以通过机关来堵住任意一个的通道（任意时刻，只能堵住一个通道）。即无论何时，鳄鱼门卫堵住一个新的通道，则之前堵住的通道就会被打开。\n\nBenjamas 逃离过程可以描述如下：每次她试图离开一个洞穴时，鳄鱼门卫都会封闭一条连接该洞穴的通道。Benjamas 只能选择没有被封闭的通道走到下一个洞穴。Benjamas 一旦进入一条通道，在她到达该通道的另一端前，鳄鱼门卫不能封闭这条通道。当 Benjamas 到达下一个洞穴，鳄鱼门卫可以选择再封闭一条通道（可以是 Benjamas 刚刚走过的那条通道）。\n\nBenjamas 需要设计一个逃生计划，确切地说，她希望有一系列指令告诉她如何逃生。\n\n设 $A$ 是一个洞穴，如果 $A$ 是出口洞穴，Benjamas 可以直接逃生。否则，对洞穴 $A$，指令是下列形式中的一种：\n\n- 在洞穴 $A$，优先选择一条通道到洞穴 $B$。如果该通道被封堵，则选择另一通道去洞穴 $C$。\n\n- 不用考虑洞穴 $A$，按照逃生计划不会到达 $A$。\n\n注意：数据保证不管鳄鱼门卫如何封闭通道，总能找到一个好的逃生计划保证 Benjamas 在有限时间内可以到达一个出口洞穴。在所有逃生计划中，在最坏情况下用时最短的逃生计划所用的时间定义为 $T$。", "inputFormat": "第一行三个整数 $N$，$M$，$K$；\n\n接下来 $M$ 行 每行三个整数 表示一条无向边的两端和长度（无重边）；\n\n接下来 $K$ 个整数 表示出口洞穴。", "outputFormat": "一个整数 最小时间 $T$。", "hint": "**数据范围**\n\n对于 $100\\%$ 的数据，$3 \\le N \\le 10^5$，$2 \\le M \\le 10^6$，测试数据保证 $T$ 存在，且 $T \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2011] crocodile", "background": "", "description": "After exploring the mysterious underground crocodile palace, archaeologist Benjamas needs to find a way to escape. This underground palace contains $N$ caves and $M$ bidirectional tunnels. Each tunnel connects a pair of different caves, and there is at most one tunnel between any two caves. Traveling along different tunnels may take different amounts of time. Among the $N$ caves, there are $K$ exit caves, and Benjamas can escape from any exit cave. Benjamas starts from cave $0$ and wants to reach an exit cave as quickly as possible.\n\nThe crocodile guard wants to stop Benjamas from escaping the palace. It can use a mechanism to block any one tunnel (at any moment, it can block only one tunnel). That is, whenever the guard blocks a new tunnel, the previously blocked tunnel will be opened.\n\nBenjamas’s escape process can be described as follows: each time she tries to leave a cave, the crocodile guard will block one tunnel connected to that cave. Benjamas can only choose an unblocked tunnel to go to the next cave. Once Benjamas enters a tunnel, the guard cannot block that tunnel before she reaches the other end. When Benjamas arrives at the next cave, the guard may choose to block another tunnel (which may be the tunnel Benjamas just used).\n\nBenjamas needs to design an escape plan. More precisely, she wants a sequence of instructions that tells her how to escape.\n\nLet $A$ be a cave. If $A$ is an exit cave, Benjamas can escape immediately. Otherwise, for cave $A$, the instruction is one of the following forms:\n\n- At cave $A$, first try to take the tunnel to cave $B$. If that tunnel is blocked, then take another tunnel to cave $C$.\n\n- Ignore cave $A$; according to the escape plan, cave $A$ will never be reached.\n\nNote: The testdata guarantees that no matter how the crocodile guard blocks tunnels, there always exists a good escape plan that guarantees Benjamas can reach an exit cave in finite time. Among all escape plans, the time used by the escape plan with the minimum time in the worst case is defined as $T$.", "inputFormat": "The first line contains three integers $N$, $M$, $K$.\n\nThe next $M$ lines each contain three integers, describing the two endpoints of an undirected edge and its length (no multiple edges).\n\nThe next line contains $K$ integers, describing the exit caves.", "outputFormat": "Output one integer, the minimum time $T$.", "hint": "**Constraints**\n\nFor $100\\%$ of the testdata, $3 \\le N \\le 10^5$, $2 \\le M \\le 10^6$. The testdata guarantees that $T$ exists, and $T \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2011] crocodile", "background": null, "description": "考古学家 Benjamas 考察了神秘的鳄鱼地下宫殿之后需要设法逃离。这个地下宫殿包含 $N$ 个洞穴和 $M$ 条双向的通道。每条通道连接一对不同的洞穴，两个洞穴之间最多只有一条通道，在不同的通道上行走可能需要不同的时间。$N$ 个洞穴中有 $K$ 个洞穴是出口洞穴，Benjamas 可以从出口洞穴逃离。Benjamas 从 $0$ 号洞穴出发，她希望尽快地到达一个出口洞穴。\n\n鳄鱼门卫要阻止 Benjamas 逃离宫殿。它可以通过机关来堵住任意一个的通道（任意时刻，只能堵住一个通道）。即无论何时，鳄鱼门卫堵住一个新的通道，则之前堵住的通道就会被打开。\n\nBenjamas 逃离过程可以描述如下：每次她试图离开一个洞穴时，鳄鱼门卫都会封闭一条连接该洞穴的通道。Benjamas 只能选择没有被封闭的通道走到下一个洞穴。Benjamas 一旦进入一条通道，在她到达该通道的另一端前，鳄鱼门卫不能封闭这条通道。当 Benjamas 到达下一个洞穴，鳄鱼门卫可以选择再封闭一条通道（可以是 Benjamas 刚刚走过的那条通道）。\n\nBenjamas 需要设计一个逃生计划，确切地说，她希望有一系列指令告诉她如何逃生。\n\n设 $A$ 是一个洞穴，如果 $A$ 是出口洞穴，Benjamas 可以直接逃生。否则，对洞穴 $A$，指令是下列形式中的一种：\n\n- 在洞穴 $A$，优先选择一条通道到洞穴 $B$。如果该通道被封堵，则选择另一通道去洞穴 $C$。\n\n- 不用考虑洞穴 $A$，按照逃生计划不会到达 $A$。\n\n注意：数据保证不管鳄鱼门卫如何封闭通道，总能找到一个好的逃生计划保证 Benjamas 在有限时间内可以到达一个出口洞穴。在所有逃生计划中，在最坏情况下用时最短的逃生计划所用的时间定义为 $T$。", "inputFormat": "第一行三个整数 $N$，$M$，$K$；\n\n接下来 $M$ 行 每行三个整数 表示一条无向边的两端和长度（无重边）；\n\n接下来 $K$ 个整数 表示出口洞穴。", "outputFormat": "一个整数 最小时间 $T$。", "hint": "**数据范围**\n\n对于 $100\\%$ 的数据，$3 \\le N \\le 10^5$，$2 \\le M \\le 10^6$，测试数据保证 $T$ 存在，且 $T \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5846", "type": "P", "difficulty": 5, "samples": [["6\n3 4 5 1 2 6\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "IOI", "分类讨论"], "title": "[IOI 2005] bir", "background": null, "description": "今天是 Byteman 的生日。有 $n$ 个孩子参加他的生日宴会（包括 Byteman ）。孩子们从 $1$ 到 $n$ 编号。Byteman 的父母准备了一张大圆桌并放了n把椅子在圆桌周围。孩子们来了就坐下。$1$ 号孩子坐其中一个，然后 $2$ 号孩子坐在他左边，然后 $3$ 号孩子坐在 $2$ 号左边，以此类推。最后 $n$ 号孩子坐在最后一个空椅子上，也就是 $n-1$ 号孩子和 $1$ 号孩子之间。\n\nByteman 的父母非常了解这些孩子，知道如果有些孩子坐在一起就会非常吵。因此他们将按特定顺序调整这些孩子的座位。用一个置换 $p_1,p_2,\\cdots,p_n$ ($p_1,p_2,\\cdots,p_n$是 $1$ 到 $n$ 的整数)来表示这个顺序。孩子 $p_1$ 将坐在 $p_2$ 和 $p_n$ 之间，孩子 $p_i$ ($ i = 2,3,…n-1$)将坐在孩子 $p_{i-1}$ 和 $p_{i+1}$ 之间，孩子 $p_n$ 将坐在孩子 $p_{n-1}$ 和 $p_1$ 之间。需要注意的是 $p_1$ 可以坐在 $p_n$ 左边也可以坐在 $p_n$ 右边。 \n\n让所有孩子按给定顺序做好，Byteman 父母必须让每个孩子绕圆桌向左或向右移动一些座位。他们必须决定每个孩子如何移动，也就是说它们必须决定一个方向，以及距离。对于给定的移动信号，所有孩子立刻站起来，移到合适的位置坐下。 串座过程使研会变得乱七八糟，乱七八糟值等于所有孩子中最大移动距离，孩子们可以以很多种方式移动，Byteman 父母将选择乱七八糟值最小的。帮他们找到这一种方案。 \n\n你的任务是写一个程序： 从标准输入读入孩子的数目和描述目标序列的那个置换。 算出最小的乱七八糟值。", "inputFormat": "第一行包括一个整数 $n$ ($1 \\le n \\le 10^6$)。 \n\n第二行包括 $n$ 个整数 $p_1,p_2,\\cdots,p_n$，以一个空格分开。$p_1,p_2,\\cdots,p_n$ 是集合 $\\{1,2,\\cdots,n\\}$ 的一个置换，描述目标顺序。", "outputFormat": "一行包含一个整数：最小的乱七八糟值。", "hint": "对于 $50\\%$ 的数据，$1 \\le n \\le 1000$；\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2005] bir", "background": "", "description": "Today is Byteman’s birthday. There are $n$ children at his birthday party (including Byteman). The children are numbered from $1$ to $n$. Byteman’s parents prepared a big round table and placed $n$ chairs around it. When the children arrive, they sit down as follows: child $1$ sits on some chair, then child $2$ sits to the left of child $1$, then child $3$ sits to the left of child $2$, and so on. Finally, child $n$ sits on the last empty chair, i.e. between child $n-1$ and child $1$.\n\nByteman’s parents know the children very well, and they know that if some children sit next to each other, they will be very noisy. Therefore, they will rearrange the children’s seats in a specific order. This order is given by a permutation $p_1,p_2,\\cdots,p_n$ ($p_1,p_2,\\cdots,p_n$ are integers from $1$ to $n$). Child $p_1$ will sit between $p_2$ and $p_n$, child $p_i$ ($i = 2,3,\\ldots,n-1$) will sit between children $p_{i-1}$ and $p_{i+1}$, and child $p_n$ will sit between children $p_{n-1}$ and $p_1$. Note that $p_1$ may sit either to the left of $p_n$ or to the right of $p_n$.\n\nTo make all children sit in the given order, Byteman’s parents must let each child move some seats to the left or to the right around the table. They must decide how each child moves, that is, they must decide a direction and a distance. For a given moving instruction, all children stand up at once and move to their target seats and sit down. This process makes the party messy. The messiness is defined as the maximum moving distance among all children. Since the children can move in many different ways, Byteman’s parents will choose the one that minimizes the messiness. Help them find such a plan.\n\nYour task is to write a program that reads from standard input the number of children and the permutation describing the target order, and computes the minimum possible messiness.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 10^6$).\n\nThe second line contains $n$ integers $p_1,p_2,\\cdots,p_n$, separated by single spaces. $p_1,p_2,\\cdots,p_n$ is a permutation of the set $\\{1,2,\\cdots,n\\}$, describing the target order.", "outputFormat": "One line containing one integer: the minimum messiness.", "hint": "For $50\\%$ of the testdata, $1 \\le n \\le 1000$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2005] bir", "background": null, "description": "今天是 Byteman 的生日。有 $n$ 个孩子参加他的生日宴会（包括 Byteman ）。孩子们从 $1$ 到 $n$ 编号。Byteman 的父母准备了一张大圆桌并放了n把椅子在圆桌周围。孩子们来了就坐下。$1$ 号孩子坐其中一个，然后 $2$ 号孩子坐在他左边，然后 $3$ 号孩子坐在 $2$ 号左边，以此类推。最后 $n$ 号孩子坐在最后一个空椅子上，也就是 $n-1$ 号孩子和 $1$ 号孩子之间。\n\nByteman 的父母非常了解这些孩子，知道如果有些孩子坐在一起就会非常吵。因此他们将按特定顺序调整这些孩子的座位。用一个置换 $p_1,p_2,\\cdots,p_n$ ($p_1,p_2,\\cdots,p_n$是 $1$ 到 $n$ 的整数)来表示这个顺序。孩子 $p_1$ 将坐在 $p_2$ 和 $p_n$ 之间，孩子 $p_i$ ($ i = 2,3,…n-1$)将坐在孩子 $p_{i-1}$ 和 $p_{i+1}$ 之间，孩子 $p_n$ 将坐在孩子 $p_{n-1}$ 和 $p_1$ 之间。需要注意的是 $p_1$ 可以坐在 $p_n$ 左边也可以坐在 $p_n$ 右边。 \n\n让所有孩子按给定顺序做好，Byteman 父母必须让每个孩子绕圆桌向左或向右移动一些座位。他们必须决定每个孩子如何移动，也就是说它们必须决定一个方向，以及距离。对于给定的移动信号，所有孩子立刻站起来，移到合适的位置坐下。 串座过程使研会变得乱七八糟，乱七八糟值等于所有孩子中最大移动距离，孩子们可以以很多种方式移动，Byteman 父母将选择乱七八糟值最小的。帮他们找到这一种方案。 \n\n你的任务是写一个程序： 从标准输入读入孩子的数目和描述目标序列的那个置换。 算出最小的乱七八糟值。", "inputFormat": "第一行包括一个整数 $n$ ($1 \\le n \\le 10^6$)。 \n\n第二行包括 $n$ 个整数 $p_1,p_2,\\cdots,p_n$，以一个空格分开。$p_1,p_2,\\cdots,p_n$ 是集合 $\\{1,2,\\cdots,n\\}$ 的一个置换，描述目标顺序。", "outputFormat": "一行包含一个整数：最小的乱七八糟值。", "hint": "对于 $50\\%$ 的数据，$1 \\le n \\le 1000$；\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P5847", "type": "P", "difficulty": 4, "samples": [["3\n2\n5\n9\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "IOI"], "title": "[IOI 2005] mea", "background": null, "description": "考虑一个非递减的整数序列 $S_1,\\cdots,S_{n+1}$ ($S_i \\le S_{i+1}$，$1 \\le i \\le n$)。序列 $M_1 \\cdots M_n$ 是定义在序列 $S$ 的基础上，关系式为 $M_i = \\frac{S_i + S_{i+1}}{2}$（$1 \\le i \\le n$），序列 $M$ 叫做序列 $S$ 的平均数序列。\n\n例如序列 $1,2,2,4$ 的平均数序列为 $1.5,2,3$. 注意到平均数序列中的元素可能为小数。但是本题的任务只是处理平均数序列都为整数的情况。\n\n给出一个 $n$ 个数字的非递减的整数序列 $M_1,M_2,\\cdots,M_n$。请你计算出：序列 $S_1,\\cdots,S_{n+1}$ 的平均序列是 $M_1,\\cdots,M_n$。 求满足以上条件的序列 $S$ 的总个数。\n\n任务：从标准输入文件中读入一个非递减的整数序列。计算出平均序列是给出序列的整数序列的总个数。把计算结果写到标准输出文件中。", "inputFormat": "输入文件的第一行包含一个整数 $n$（$2 \\le n \\le 5 \\times 10^6$）。\n\n接下来的 $n$ 行包含了这个给出的整数序列 $M_1,\\cdots,M_n$。第 $i+1$ 行包含一个整数 $M_i$ ( $1 \\le M_i \\le 10^9$)。", "outputFormat": "输出文件仅一行，即所求答案。", "hint": "**样例说明**\n\n一共存在 $4$ 种序列，它们的平均数序列都是 $2,5,9$。这四种序列如下：\n\n- $2,2,8,10$\n- $1,3,7,11$\n- $0,4,6,12$\n- $-1,5,5,13$\n\n**数据范围**\n\n对于 $50\\%$ 的数据，$2 \\le n \\le 1000$，$1 \\le M_i \\le 2 \\times 10^4$；\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 5 \\times 10^6$，$1 \\le M_i \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2005] mea", "background": "", "description": "Consider a non-decreasing integer sequence $S_1,\\cdots,S_{n+1}$ ($S_i \\le S_{i+1}$, $1 \\le i \\le n$). A sequence $M_1 \\cdots M_n$ is defined based on the sequence $S$ by the relation $M_i = \\frac{S_i + S_{i+1}}{2}$ ($1 \\le i \\le n$). The sequence $M$ is called the mean sequence of $S$.\n\nFor example, the mean sequence of $1,2,2,4$ is $1.5,2,3$. Note that elements in the mean sequence may be decimals. However, in this problem, you only need to handle the case where all elements of the mean sequence are integers.\n\nYou are given a non-decreasing integer sequence $M_1,M_2,\\cdots,M_n$ of length $n$. Please compute the total number of sequences $S_1,\\cdots,S_{n+1}$ such that the mean sequence of $S$ is exactly $M_1,\\cdots,M_n$.\n\nTask: Read a non-decreasing integer sequence from standard input. Compute the number of integer sequences whose mean sequence equals the given integer sequence. Write the result to standard output.", "inputFormat": "The first line contains an integer $n$ ($2 \\le n \\le 5 \\times 10^6$).\n\nThe next $n$ lines contain the given integer sequence $M_1,\\cdots,M_n$. The $(i+1)$-th line contains an integer $M_i$ ($1 \\le M_i \\le 10^9$).", "outputFormat": "Output only one line, which is the required answer.", "hint": "**Sample Explanation**\n\nThere are $4$ sequences in total whose mean sequence is $2,5,9$. These four sequences are:\n\n- $2,2,8,10$\n- $1,3,7,11$\n- $0,4,6,12$\n- $-1,5,5,13$\n\n**Constraints**\n\nFor $50\\%$ of the testdata, $2 \\le n \\le 1000$, $1 \\le M_i \\le 2 \\times 10^4$.\n\nFor $100\\%$ of the testdata, $2 \\le n \\le 5 \\times 10^6$, $1 \\le M_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2005] mea", "background": null, "description": "考虑一个非递减的整数序列 $S_1,\\cdots,S_{n+1}$ ($S_i \\le S_{i+1}$，$1 \\le i \\le n$)。序列 $M_1 \\cdots M_n$ 是定义在序列 $S$ 的基础上，关系式为 $M_i = \\frac{S_i + S_{i+1}}{2}$（$1 \\le i \\le n$），序列 $M$ 叫做序列 $S$ 的平均数序列。\n\n例如序列 $1,2,2,4$ 的平均数序列为 $1.5,2,3$. 注意到平均数序列中的元素可能为小数。但是本题的任务只是处理平均数序列都为整数的情况。\n\n给出一个 $n$ 个数字的非递减的整数序列 $M_1,M_2,\\cdots,M_n$。请你计算出：序列 $S_1,\\cdots,S_{n+1}$ 的平均序列是 $M_1,\\cdots,M_n$。 求满足以上条件的序列 $S$ 的总个数。\n\n任务：从标准输入文件中读入一个非递减的整数序列。计算出平均序列是给出序列的整数序列的总个数。把计算结果写到标准输出文件中。", "inputFormat": "输入文件的第一行包含一个整数 $n$（$2 \\le n \\le 5 \\times 10^6$）。\n\n接下来的 $n$ 行包含了这个给出的整数序列 $M_1,\\cdots,M_n$。第 $i+1$ 行包含一个整数 $M_i$ ( $1 \\le M_i \\le 10^9$)。", "outputFormat": "输出文件仅一行，即所求答案。", "hint": "**样例说明**\n\n一共存在 $4$ 种序列，它们的平均数序列都是 $2,5,9$。这四种序列如下：\n\n- $2,2,8,10$\n- $1,3,7,11$\n- $0,4,6,12$\n- $-1,5,5,13$\n\n**数据范围**\n\n对于 $50\\%$ 的数据，$2 \\le n \\le 1000$，$1 \\le M_i \\le 2 \\times 10^4$；\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 5 \\times 10^6$，$1 \\le M_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5848", "type": "P", "difficulty": 5, "samples": [["4\nQ 1\nI 1 4 2\nQ 3\nQ 1\nI 2 2 -1\nQ 3\nE\n", "4\n1\n0\n3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "IOI"], "title": "[IOI 2005] mou", "background": "", "description": "游乐园已经开始运行一个崭新的模拟过山车。模拟的轨道由 $n$ 段铁轨组成，并且首尾相连。第一段铁轨从高度 $0$ 开始。\n\n操作员 Byteman 能通过调整连续几段的铁轨高度来改造这条轨道。在被改造的一段前面的铁轨高度不受影响。 每一次铁轨被调整。后面的轨必须升起或降低来保持连通，并保证起点高度为 $0$。下页举例说明轨道改造过程。 每次开始时车都有足够能量到达高度 $h$。也就是说，只要轨道的高度不超过 $h$，车就一直开下去, 甚至直到结束。 \n\n给出每天的运行和改造情况, 为每次运行计算在车停止前，到达的铁轨数。铁轨以一个 $n$ 个数的数列形式表示 ，一个数对应一段铁轨。第 $i$ 个 $d_i$ 表示在第 $i$ 段铁轨上的高度变化。也就是说，在到达铁轨 $i$ 前，如果车的高度是 $h$，那么经过铁轨i后，高度变为 $h+d_i$。\n\n最初轨道是一条水平线。就是说对于所有的 $i$ 都是 $d_i=0$。运行和改造交错进行。 每个改造用三个数表示: $a$ ，$b$ 和 $D$。表示从 $a$ 到 $b$ (包括 $a$,$b$) 的所有 $d_i$ 改为 $d_i=D$。每次运行给定一个数字 $h$ ——车能到达的最大高度。", "inputFormat": "输入的第一行包括一个正整数 $n$ ——铁轨的数目。\n\n下面的行包括改造和运行，各有一个标识符： \n\n- 改造——一个字母 `I`，和整数$a$,$b$,$D$ ,中间用一个空格隔开。\n- 运行——一个字母 `Q`，和一个整数 $h$，用一个空格隔开。 \n- 一个字母 `E` ——结束符号，表示输入结束。 \n\n你可以假设任意时刻任意铁轨的高度在 $[1，1000000000]$ 区间内。\n\n输入不超过 $10000$ 行。", "outputFormat": "第 $i$ 行需包含一个整数， 即第 $i$ 次运行经过的铁轨数。", "hint": "对于 $50\\%$ 的数据，$1 \\le n \\le 2 \\times 10^4$，且输入不超过 $1000$ 行；\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^9$，$1 \\le a,b \\le n$，$- 10^9 \\le D \\le 10^9$，$0 \\le h \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2005] mou", "background": "", "description": "An amusement park has started operating a brand new simulated roller coaster. The simulated track consists of $n$ rail segments, and the first and last segments are connected to form a loop. The first rail segment starts at height $0$.\n\nThe operator Byteman can modify the track by adjusting the heights of several consecutive rail segments. The heights of the segments before the modified part are not affected. Each time the rail heights are adjusted, the segments after the modified part must be raised or lowered to keep the track connected, and the starting height must remain $0$. The next page illustrates the modification process.\n\nAt the start of each run, the car has enough energy to reach height $h$. That is, as long as the height of the track does not exceed $h$, the car keeps moving, even until it finishes.\n\nGiven the daily runs and modifications, for each run compute how many rail segments the car passes before it stops.\n\nThe rails are represented as a sequence of $n$ numbers, where each number corresponds to one rail segment. The $i$-th value $d_i$ denotes the height change on the $i$-th segment. In other words, if the car’s height is $h$ before reaching segment $i$, then after passing segment $i$, the height becomes $h+d_i$.\n\nInitially, the track is a horizontal line, meaning $d_i=0$ for all $i$. Runs and modifications are interleaved. Each modification is given by three numbers: $a$, $b$, and $D$, meaning that all $d_i$ for $i$ from $a$ to $b$ (inclusive) are set to $d_i=D$. Each run is given a number $h$, the maximum height the car can reach.", "inputFormat": "The first line of input contains a positive integer $n$, the number of rail segments.\n\nThe following lines contain modifications and runs, each starting with an identifier:\n\n- Modification: a letter `I`, followed by integers $a$, $b$, and $D$, separated by single spaces.\n- Run: a letter `Q`, followed by an integer $h$, separated by a single space.\n- A letter `E`: the termination symbol, indicating the end of input.\n\nYou may assume that at any time, the height of any rail segment is within the range $[1,1000000000]$.\n\nThe input contains no more than $10000$ lines.", "outputFormat": "For the $i$-th run, output one integer per line: the number of rail segments passed in that run.", "hint": "For $50\\%$ of the testdata, $1 \\le n \\le 2 \\times 10^4$, and the input contains no more than $1000$ lines.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^9$, $1 \\le a,b \\le n$, $- 10^9 \\le D \\le 10^9$, $0 \\le h \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2005] mou", "background": "", "description": "游乐园已经开始运行一个崭新的模拟过山车。模拟的轨道由 $n$ 段铁轨组成，并且首尾相连。第一段铁轨从高度 $0$ 开始。\n\n操作员 Byteman 能通过调整连续几段的铁轨高度来改造这条轨道。在被改造的一段前面的铁轨高度不受影响。 每一次铁轨被调整。后面的轨必须升起或降低来保持连通，并保证起点高度为 $0$。下页举例说明轨道改造过程。 每次开始时车都有足够能量到达高度 $h$。也就是说，只要轨道的高度不超过 $h$，车就一直开下去, 甚至直到结束。 \n\n给出每天的运行和改造情况, 为每次运行计算在车停止前，到达的铁轨数。铁轨以一个 $n$ 个数的数列形式表示 ，一个数对应一段铁轨。第 $i$ 个 $d_i$ 表示在第 $i$ 段铁轨上的高度变化。也就是说，在到达铁轨 $i$ 前，如果车的高度是 $h$，那么经过铁轨i后，高度变为 $h+d_i$。\n\n最初轨道是一条水平线。就是说对于所有的 $i$ 都是 $d_i=0$。运行和改造交错进行。 每个改造用三个数表示: $a$ ，$b$ 和 $D$。表示从 $a$ 到 $b$ (包括 $a$,$b$) 的所有 $d_i$ 改为 $d_i=D$。每次运行给定一个数字 $h$ ——车能到达的最大高度。", "inputFormat": "输入的第一行包括一个正整数 $n$ ——铁轨的数目。\n\n下面的行包括改造和运行，各有一个标识符： \n\n- 改造——一个字母 `I`，和整数$a$,$b$,$D$ ,中间用一个空格隔开。\n- 运行——一个字母 `Q`，和一个整数 $h$，用一个空格隔开。 \n- 一个字母 `E` ——结束符号，表示输入结束。 \n\n你可以假设任意时刻任意铁轨的高度在 $[1，1000000000]$ 区间内。\n\n输入不超过 $10000$ 行。", "outputFormat": "第 $i$ 行需包含一个整数， 即第 $i$ 次运行经过的铁轨数。", "hint": "对于 $50\\%$ 的数据，$1 \\le n \\le 2 \\times 10^4$，且输入不超过 $1000$ 行；\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^9$，$1 \\le a,b \\le n$，$- 10^9 \\le D \\le 10^9$，$0 \\le h \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5849", "type": "P", "difficulty": 3, "samples": [["3 2 8\n1 2 5\n", "10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "IOI"], "title": "[IOI 2015] boxes", "background": "", "description": "IOI2015 开幕式正在进行最后一个环节。按计划在开幕式期间，每个代表队都将收到由主办方发放的一个装有纪念品的盒子。然而所有志愿者都被精彩的开幕式所吸引，除 Aman 外其他人完全忘记了发放纪念品这件事。Aman 是一位热情的志愿者，为使得 IOI 尽量圆满，他要用最短的时间将所有纪念品发放出去。\n\n开幕式的场地是一个圆环，被分为 $L$个完全相等的区域，这些区域的编号依次为 $0$ 到 $L-1$，也就是说，对于$0\\le \n i\\le L-2$,区域 $i$ 与区域 $i+1$ 相邻，且区域 $L-1$ 与区域 $0$ 相邻。场地上共有 $N$ 个代表队，每队坐在上面的一个区域上，每个区域可以包含任意多个代表队，也可以为空。\n\n一共有 $N$ 个相同的纪念品。开始，Aman 和所有纪念品都在区域 $0$。Aman 应该给每队一个纪念品，并且在发放完最后一个纪念品后他必须回到区域 $0$。注意，有些队可能坐在区域 $0$。\n\n在任意时刻，Aman 只能够携带至多 $K$ 个纪念品。Aman 必须从区域 $0$ 取走这些纪念品，且取纪念品不需要时间。纪念品一旦从区域 $0$ 被取走后，Aman 只能将其发放给某个代表队或者随身携带。无论何时，Aman 携带一个或更多的纪念品到达一个这样的区域，该区域有一个代表队尚未收到纪念品，Aman 便可将他携带的一个纪念品发给这个代表队。这种发放也在瞬间完成。他所花的时间都消耗在区域之间的移动上。无论携带多少纪念品，Aman 都需要 $1$ 秒钟从一个区域移动到其相邻的区域（可以顺时针移动也可以逆时针移动）。\n\n你的任务是计算出 Aman 发放完所有纪念品并返回到他的最初区域所需要的最短时间（秒数）。", "inputFormat": "- 第 $1$ 行有三个整数 $N$，$K$，$L$，分别表示 代表队的数目，Aman 每次最多能携带的纪念品数量 ，开幕式场地上的区域数目；\n- 第 $2$ 行有 $N$ 个整数，分别为 $p[0],\\cdots,p[N−1]$，其中 $p[i]$ （$0\\le i\\le N-1$）代表第 $i$ 支代表队所在区域编号。$p$ 的元素按非递减排序。", "outputFormat": "共一行，Aman 所需要的最短时间（秒数）。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 10^7$，$1\\le K\\le N$，$1\\le L\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2015] boxes", "background": "", "description": "The opening ceremony of IOI 2015 is in its final part. According to the plan, during the ceremony, each delegation should receive a box containing souvenirs provided by the organizers. However, all volunteers were attracted by the wonderful ceremony and completely forgot about distributing the souvenirs, except Aman. Aman is an enthusiastic volunteer, and to make IOI as successful as possible, he wants to distribute all souvenirs in the shortest time.\n\nThe ceremony venue is a circular ring divided into $L$ equal areas. These areas are numbered from $0$ to $L-1$. That is, for $0\\le i\\le L-2$, area $i$ is adjacent to area $i+1$, and area $L-1$ is adjacent to area $0$. There are $N$ delegations in total, each sitting in one of these areas. Each area may contain any number of delegations, and it may also be empty.\n\nThere are $N$ identical souvenirs. At the beginning, Aman and all souvenirs are in area $0$. Aman should give one souvenir to each delegation, and after distributing the last souvenir, he must return to area $0$. Note that some delegations may be in area $0$.\n\nAt any moment, Aman can carry at most $K$ souvenirs. Aman must take these souvenirs from area $0$, and taking souvenirs takes no time. Once a souvenir is taken from area $0$, Aman can only give it to some delegation or carry it with him. Whenever Aman arrives at an area while carrying one or more souvenirs, and that area has at least one delegation that has not yet received a souvenir, Aman can give one of the souvenirs he is carrying to that delegation. This distribution is also instantaneous. The time he spends is only on moving between areas. No matter how many souvenirs he carries, Aman needs $1$ second to move from one area to an adjacent area (he can move clockwise or counterclockwise).\n\nYour task is to compute the minimum time (in seconds) Aman needs to distribute all souvenirs and return to his initial area.", "inputFormat": "- Line $1$ contains three integers $N$, $K$, $L$, representing the number of delegations, the maximum number of souvenirs Aman can carry each time, and the number of areas in the venue, respectively.\n- Line $2$ contains $N$ integers $p[0],\\cdots,p[N−1]$, where $p[i]$ ($0\\le i\\le N-1$) denotes the area index where the $i$-th delegation is located. The elements of $p$ are sorted in non-decreasing order.", "outputFormat": "One line containing the minimum time (in seconds) Aman needs.", "hint": "For $100\\%$ of the testdata, $1\\le N\\le 10^7$, $1\\le K\\le N$, $1\\le L\\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2015] boxes", "background": "", "description": "IOI2015 开幕式正在进行最后一个环节。按计划在开幕式期间，每个代表队都将收到由主办方发放的一个装有纪念品的盒子。然而所有志愿者都被精彩的开幕式所吸引，除 Aman 外其他人完全忘记了发放纪念品这件事。Aman 是一位热情的志愿者，为使得 IOI 尽量圆满，他要用最短的时间将所有纪念品发放出去。\n\n开幕式的场地是一个圆环，被分为 $L$个完全相等的区域，这些区域的编号依次为 $0$ 到 $L-1$，也就是说，对于$0\\le \n i\\le L-2$,区域 $i$ 与区域 $i+1$ 相邻，且区域 $L-1$ 与区域 $0$ 相邻。场地上共有 $N$ 个代表队，每队坐在上面的一个区域上，每个区域可以包含任意多个代表队，也可以为空。\n\n一共有 $N$ 个相同的纪念品。开始，Aman 和所有纪念品都在区域 $0$。Aman 应该给每队一个纪念品，并且在发放完最后一个纪念品后他必须回到区域 $0$。注意，有些队可能坐在区域 $0$。\n\n在任意时刻，Aman 只能够携带至多 $K$ 个纪念品。Aman 必须从区域 $0$ 取走这些纪念品，且取纪念品不需要时间。纪念品一旦从区域 $0$ 被取走后，Aman 只能将其发放给某个代表队或者随身携带。无论何时，Aman 携带一个或更多的纪念品到达一个这样的区域，该区域有一个代表队尚未收到纪念品，Aman 便可将他携带的一个纪念品发给这个代表队。这种发放也在瞬间完成。他所花的时间都消耗在区域之间的移动上。无论携带多少纪念品，Aman 都需要 $1$ 秒钟从一个区域移动到其相邻的区域（可以顺时针移动也可以逆时针移动）。\n\n你的任务是计算出 Aman 发放完所有纪念品并返回到他的最初区域所需要的最短时间（秒数）。", "inputFormat": "- 第 $1$ 行有三个整数 $N$，$K$，$L$，分别表示 代表队的数目，Aman 每次最多能携带的纪念品数量 ，开幕式场地上的区域数目；\n- 第 $2$ 行有 $N$ 个整数，分别为 $p[0],\\cdots,p[N−1]$，其中 $p[i]$ （$0\\le i\\le N-1$）代表第 $i$ 支代表队所在区域编号。$p$ 的元素按非递减排序。", "outputFormat": "共一行，Aman 所需要的最短时间（秒数）。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 10^7$，$1\\le K\\le N$，$1\\le L\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5850", "type": "P", "difficulty": 7, "samples": [["13 8", "91\n7462\n546546\n35387352\n3869654\n396558319\n363789591\n879373476\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "集训队互测", "O2优化", "生成函数", "快速傅里叶变换 FFT"], "title": "calc加强版", "background": "[原题链接](https://www.luogu.com.cn/problem/P4463)", "description": "一个序列 $a_1,\\cdots,a_n$ 是合法的，当且仅当：\n\n长度为给定的 $n$。\n\n$a_1,\\cdots,a_n$ 都是 $[1,k]$ 中的整数。\n\n$a_1,\\cdots,a_n$ 互不相等。\n\n一个序列的值定义为它里面所有数的乘积，即 $a_1\\times a_2\\times\\cdots\\times a_n$ 。\n\n求所有不同合法序列的值的和。\n\n两个序列不同当且仅当他们任意一位不一样。\n\n输出答案对 $998244353$ 取余的结果。", "inputFormat": "一行两个数 $k,m$。", "outputFormat": "共 $m$ 行，第 $i(1\\le i\\le m)$ 行表示 $n=i$ 时的答案。", "hint": "$\\text{subtask 1 (84 pts)}$：$1\\le m\\le 500$\n\n$\\text{subtask 2 (16 pts)}$：$1\\le m\\le 5\\times 10^5$，建议使用高效输出方式。\n\n对所有数据，$1\\le m\\le k\\le 998244352$。", "locale": "zh-CN", "translations": {"en": {"title": "calc Enhanced Version.", "background": "[Original problem link](https://www.luogu.com.cn/problem/P4463)", "description": "A sequence $a_1,\\cdots,a_n$ is valid if and only if:\n\n- Its length is the given $n$.\n- $a_1,\\cdots,a_n$ are all integers in $[1,k]$.\n- $a_1,\\cdots,a_n$ are pairwise distinct.\n\nThe value of a sequence is defined as the product of all numbers in it, i.e., $a_1\\times a_2\\times\\cdots\\times a_n$.\n\nFind the sum of the values of all different valid sequences.\n\nTwo sequences are different if and only if they differ at any position.\n\nOutput the answer modulo $998244353$.", "inputFormat": "One line with two numbers $k,m$.", "outputFormat": "There are $m$ lines in total.  \nOn the $i$-th line $(1\\le i\\le m)$, output the answer when $n=i$.", "hint": "$\\text{subtask 1 (84 pts)}$：$1\\le m\\le 500$.\n\n$\\text{subtask 2 (16 pts)}$：$1\\le m\\le 5\\times 10^5$，it is recommended to use an efficient output method.\n\nFor all testdata, $1\\le m\\le k\\le 998244352$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "calc加强版", "background": "[原题链接](https://www.luogu.com.cn/problem/P4463)", "description": "一个序列 $a_1,\\cdots,a_n$ 是合法的，当且仅当：\n\n长度为给定的 $n$。\n\n$a_1,\\cdots,a_n$ 都是 $[1,k]$ 中的整数。\n\n$a_1,\\cdots,a_n$ 互不相等。\n\n一个序列的值定义为它里面所有数的乘积，即 $a_1\\times a_2\\times\\cdots\\times a_n$ 。\n\n求所有不同合法序列的值的和。\n\n两个序列不同当且仅当他们任意一位不一样。\n\n输出答案对 $998244353$ 取余的结果。", "inputFormat": "一行两个数 $k,m$。", "outputFormat": "共 $m$ 行，第 $i(1\\le i\\le m)$ 行表示 $n=i$ 时的答案。", "hint": "$\\text{subtask 1 (84 pts)}$：$1\\le m\\le 500$\n\n$\\text{subtask 2 (16 pts)}$：$1\\le m\\le 5\\times 10^5$，建议使用高效输出方式。\n\n对所有数据，$1\\le m\\le k\\le 998244352$。", "locale": "zh-CN"}}}
{"pid": "P5851", "type": "P", "difficulty": 5, "samples": [["2 2\n100 1 2\n100 1 1\n", "200\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2019", "USACO", "区间 DP"], "title": "[USACO19DEC] Greedy Pie Eaters P", "background": null, "description": "Farmer John 有 $M$ 头奶牛，为了方便，编号为 $1,\\dots,M$。这些奶牛平时都吃青草，但是喜欢偶尔换换口味。Farmer John 一天烤了 $N$ 个派请奶牛吃，这 $N$ 个派编号为 $1,\\dots,N$。第 $i$ 头奶牛喜欢吃编号在 $\\left[ l_i,r_i \\right]$ 中的派（包括两端），并且没有两头奶牛喜欢吃相同范围的派。第 $i$ 头奶牛有一个体重 $w_i$，这是一个在 $\\left[ 1,10^6 \\right]$ 中的正整数。\n\nFarmer John 可以选择一个奶牛序列 $c_1,c_2,\\dots,c_K$，并让这些奶牛按这个顺序轮流吃派。不幸的是，这些奶牛不知道分享！当奶牛吃派时，她会把她喜欢吃的派都吃掉——也就是说，她会吃掉编号在 $[l_{c_i},r_{c_i}]$ 中所有剩余的派。Farmer John 想要避免当轮到一头奶牛吃派时，她所有喜欢的派在之前都被吃掉了这样尴尬的情况。因此，他想让你计算，要使奶牛按 $c_1,c_2,\\dots,c_K$ 的顺序吃派，轮到这头奶牛时她喜欢的派至少剩余一个的情况下，这些奶牛的最大可能体重（$w_{c_1}+w_{c_2}+\\ldots+w_{c_K}$）是多少。", "inputFormat": "第一行包含两个正整数 $N,M$；\n\n接下来 $M$ 行，每行三个正整数 $w_i,l_i,r_i$。", "outputFormat": "输出对于一个合法的序列，最大可能的体重值。", "hint": "#### 样例解释\n在这个样例中，如果奶牛 $1$ 先吃，那么奶牛 $2$ 就吃不到派了。然而，先让奶牛 $2$ 吃，然后奶牛 $1$ 只吃编号为 $2$ 的派，仍可以满足条件。\n\n#### 数据范围\n对于测试点 $2-5$，满足 $N \\le 50,M \\le 20$；\n\n对于测试点 $6-9$，满足 $N \\le 50$。\n\n对于全部数据，$1 \\le N \\le 300,1 \\le M \\le \\dfrac{N(N-1)}{2},1 \\le l_i,r_i \\le N,1 \\le w_i \\le 10^6$。\n\nUSACO 2019 December 铂金组 T1", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19DEC] Greedy Pie Eaters P", "background": null, "description": "Farmer John has $M$ cows, conveniently labeled $1 \\ldots M$, who enjoy the occasional change of pace\nfrom eating grass.  As a treat for the cows, Farmer John has baked $N$ pies ($1 \\leq N \\leq 300$), labeled\n$1 \\ldots N$.  Cow $i$ enjoys pies with labels in the range $[l_i, r_i]$ (from $l_i$ to $r_i$ inclusive),\nand no two cows enjoy the exact same range of pies.  Cow $i$ also has a weight, $w_i$, which \nis an integer in the range $1 \\ldots 10^6$.\n\nFarmer John may choose a sequence of cows $c_1,c_2,\\ldots, c_K,$ after which the\nselected cows will take turns eating in that order. Unfortunately, the cows \ndon't know how to share! When it is cow $c_i$'s turn to eat, she will consume\nall of the  pies that she enjoys --- that is, all remaining pies in the interval\n$[l_{c_i},r_{c_i}]$.  Farmer John would like to avoid the awkward situation\noccurring when it is a cows turn to eat but all of the pies she enjoys have already been\nconsumed. Therefore, he wants you to compute the largest possible total weight\n($w_{c_1}+w_{c_2}+\\ldots+w_{c_K}$) of a sequence $c_1,c_2,\\ldots, c_K$ for which each cow in the\nsequence eats at least one pie.", "inputFormat": "The first line contains two integers $N$ and $M(1\\leq M\\leq \\frac{N(N+1)}{2})$ \n\nThe next $M$ lines each describe a cow in terms of the integers $w_i$,$l_i$, and $r_i$.", "outputFormat": "Print the maximum possible total weight of a valid sequence.", "hint": "In this example, if cow $1$ eats first, then there will be nothing left for cow $2$ to eat. However, if cow $2$ eats first, then cow $1$ will be satisfied by eating the second pie only.\n\nTest cases $2-5$ satisfy $N\\leq50$ and $M\\leq 20$.\n\nTest cases $6-9$ satisfy $N\\leq 50$.", "locale": "en"}, "zh-CN": {"title": "[USACO19DEC] Greedy Pie Eaters P", "background": null, "description": "Farmer John 有 $M$ 头奶牛，为了方便，编号为 $1,\\dots,M$。这些奶牛平时都吃青草，但是喜欢偶尔换换口味。Farmer John 一天烤了 $N$ 个派请奶牛吃，这 $N$ 个派编号为 $1,\\dots,N$。第 $i$ 头奶牛喜欢吃编号在 $\\left[ l_i,r_i \\right]$ 中的派（包括两端），并且没有两头奶牛喜欢吃相同范围的派。第 $i$ 头奶牛有一个体重 $w_i$，这是一个在 $\\left[ 1,10^6 \\right]$ 中的正整数。\n\nFarmer John 可以选择一个奶牛序列 $c_1,c_2,\\dots,c_K$，并让这些奶牛按这个顺序轮流吃派。不幸的是，这些奶牛不知道分享！当奶牛吃派时，她会把她喜欢吃的派都吃掉——也就是说，她会吃掉编号在 $[l_{c_i},r_{c_i}]$ 中所有剩余的派。Farmer John 想要避免当轮到一头奶牛吃派时，她所有喜欢的派在之前都被吃掉了这样尴尬的情况。因此，他想让你计算，要使奶牛按 $c_1,c_2,\\dots,c_K$ 的顺序吃派，轮到这头奶牛时她喜欢的派至少剩余一个的情况下，这些奶牛的最大可能体重（$w_{c_1}+w_{c_2}+\\ldots+w_{c_K}$）是多少。", "inputFormat": "第一行包含两个正整数 $N,M$；\n\n接下来 $M$ 行，每行三个正整数 $w_i,l_i,r_i$。", "outputFormat": "输出对于一个合法的序列，最大可能的体重值。", "hint": "#### 样例解释\n在这个样例中，如果奶牛 $1$ 先吃，那么奶牛 $2$ 就吃不到派了。然而，先让奶牛 $2$ 吃，然后奶牛 $1$ 只吃编号为 $2$ 的派，仍可以满足条件。\n\n#### 数据范围\n对于测试点 $2-5$，满足 $N \\le 50,M \\le 20$；\n\n对于测试点 $6-9$，满足 $N \\le 50$。\n\n对于全部数据，$1 \\le N \\le 300,1 \\le M \\le \\dfrac{N(N-1)}{2},1 \\le l_i,r_i \\le N,1 \\le w_i \\le 10^6$。\n\nUSACO 2019 December 铂金组 T1", "locale": "zh-CN"}}}
{"pid": "P5852", "type": "P", "difficulty": 5, "samples": [["5 18\n1 2\n1 3\n3 4\n3 5\n1 4 1\n2 1\n2 2\n2 3\n2 4\n2 5\n1 5 1\n2 1\n2 2\n2 3\n2 4\n2 5\n1 1 1\n2 1\n2 2\n2 3\n2 4\n2 5\n", "1\n0\n1\n1\n0\n2\n0\n2\n1\n1\n5\n1\n3\n1\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["树形数据结构", "2019", "USACO", "树状数组"], "title": "[USACO19DEC] Bessie's Snow Cow P", "background": null, "description": "农场下雪啦！Bessie 和往年开冬一样在堆雪牛。她之前是个写实派，总是想把她的雪牛堆得和个真牛一样。但今年不一样，受到来自东方的神秘力量的影响，她想来点抽象艺术，因此她想堆成一棵树的样子。这棵树由 $N$ 个雪球，$N-1$ 根树枝构成，每根树枝连接两个雪球，并且每两个雪球之间路径唯一。\n\nBessie 要给她的雪牛来点细节。因此她给其中一个雪球加了个鼻子，来表示这是他那抽象的牛的头，并且把它称作雪球 $1$。为了让雪牛更好看，她还要给某些雪球来点不同的颜色。于是，她用旧牛奶桶装满了颜料泼到雪牛上。这些颜料分别被编号为 $1,2,\\dots 10^5$，且每种颜色都无限量供应。\n\n当 Bessie 把一桶颜料泼到一个雪球上时，这个雪球子树上的所有雪球也会被染色（我们称雪球 $y$ 在雪球 $x$ 的子树里当且仅当雪球 $x$ 处在雪球 $y$ 到雪球 $1$ 的路径上）。Bessie 有着精确的泼颜料技术，因此在泼完一种颜料后，一个雪球上之前被染过的所有颜色依然清晰可见。例如，一个雪球之前显现出来颜色 $\\left[ 1,2,3 \\right]$，然后 Bessie 把装有 $4$ 号颜色的牛奶桶泼上去，那么这个雪球将显现出来颜色 $\\left[ 1,2,3,4 \\right]$。 在泼了几桶颜料以后，Bessie 可能想要了解她的雪牛有多五彩斑斓。令雪球 $x$ 的『颜色丰富度』为这个雪球被染上的不同颜色总数 ，当 Bessie 想了解雪球 $x$ 的相关信息时，你应该回答她雪球 $x$ 的子树中所有的雪球的颜色丰富度之和。\n\n救救孩子吧！", "inputFormat": "第一行，$N$ 和询问数 $Q$。\n\n接下来 $N-1$ 行每行两个用空格隔开的数 $a$ 和 $b$，表示雪球 $a$ 和 $b$ 中间有一根树枝相连。\n\n最后 $Q$ 行每行一个请求，格式及对应含义如下：\n\n - `1 x c`（修改）：表示 Bessie 把一桶装有颜色 $c$ 的颜料泼到雪球 $x$ ，使得其子树上所有雪球被染色。\n - `2 x`（询问）：询问雪球 $x$ 的子树的颜色丰富度之和。", "outputFormat": "对于每个询问，输出所询问子树的颜色丰富度之和。**为了防止溢出，你需要使用 64 位整数。**", "hint": "#### 样例解释\n执行完第一个修改后雪球 $4$ 被染上了颜色 $1$。\n\n执行完第二个修改后雪球 $4$ 和雪球 $5$ 被染上了颜色 $2$。\n\n执行完第三个修改后所有雪球都被染上了颜色 $1$。\n#### 数据范围\n对于测试点 $2,3$，$1\\le N\\le 10^2,1\\le Q\\le 2\\times 10^2$；\n\n对于测试点 $4-6$，$1\\le N\\le 10^3,1\\le Q\\le 2\\times 10^3$；\n\n对于 $100\\%$ 的数据，$1\\le N,\\ Q,\\ c \\le 10^5, 1\\le a,\\ b,\\ x \\le N$。\n\nUSACO 2019 December 铂金组T2", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19DEC] Bessie's Snow Cow P", "background": null, "description": "Snow has arrived on the farm, and as she does at the beginning of every winter,\nBessie is building a snow-cow! Most of the time, Bessie strives to make her\nsculpture look as much like a real cow as possible.  However, feeling\nartistically inspired, this year she decides to pursue a more abstract route and\nbuild a sculpture in the shape of a tree, consisting of $N$ snowballs\n$(1\\le N\\le 10^5)$ connected by  $N-1$ branches, each connecting a pair of\nsnowballs such that there is a  unique path between every pair of snowballs. \n\nBessie has added a nose to one of the snowballs, so it represents the head of\nthe abstract snow cow.  She designates it as snowball number 1.  To add more\nvisual interest, she plans to dye some of the snowballs different colors in an\nartistic fashion by filling old milk pails with colored dye and splashing them\nonto the sculpture.  Colors are identified by integers in the range\n$1 \\ldots 10^5$, and  Bessie has an unlimited supply of buckets filled with dyes\nof every possible color.\n\nWhen Bessie splashes a snowball with a bucket of dye, all the snowballs in its \nsubtree are also splashed with the same dye (snowball $y$ is in the subtree of\nsnowball $x$ if $x$ lies on the path from $y$ to the head snowball). By\nsplashing each color with great care, Bessie makes sure that all colors a \nsnowball has been splashed with will remain visible. For example, if a snowball\nhad colors $[1,2,3]$ and Bessie splashes it with color $4$, the snowball will\nthen have colors $[1,2,3,4]$. \n\nAfter splashing the snowballs some number of times, Bessie may also want to know\nhow colorful a part of her snow-cow is.  The \"colorfulness\" of a snowball $x$ is\nequal to the number of distinct colors $c$ such that snowball $x$ is colored\n$c$. If Bessie asks you about snowball $x$, you should reply with the sum of the\ncolorfulness values of all snowballs in the subtree of $x.$\n\nPlease help Bessie find the colorfulness of her snow-cow at certain points in\ntime.", "inputFormat": "The first line contains $N$ and the number of queries $Q$.\n\nThe next $N-1$ lines each contain two space-separated numbers $a$ and $b$, indicating that there is a branch connecting snowballs $a$ and $b$.\n\nThe last $Q$ lines each contain a request, with the format and corresponding meanings as follows:\n\n- `1 x c` (Modification): Indicates that Bessie pours a bucket of paint of color $c$ onto snowball $x$, dyeing all snowballs in its subtree.\n- `2 x` (Query): Queries the sum of colorfulness in the subtree of snowball $x$.", "outputFormat": "For each query, output the sum of colorfulness in the queried subtree. **To prevent overflow, you must use 64-bit integers.**", "hint": "After the first query of type $1$, snowball $4$ is dyed with color $1$.\n\nAfter the second query of type $1$, snowballs $4$ and $5$ are dyed with color $1$.\n\nAfter the third query of type $1$, all snowballs are dyed with color $1$.", "locale": "en"}, "zh-CN": {"title": "[USACO19DEC] Bessie's Snow Cow P", "background": null, "description": "农场下雪啦！Bessie 和往年开冬一样在堆雪牛。她之前是个写实派，总是想把她的雪牛堆得和个真牛一样。但今年不一样，受到来自东方的神秘力量的影响，她想来点抽象艺术，因此她想堆成一棵树的样子。这棵树由 $N$ 个雪球，$N-1$ 根树枝构成，每根树枝连接两个雪球，并且每两个雪球之间路径唯一。\n\nBessie 要给她的雪牛来点细节。因此她给其中一个雪球加了个鼻子，来表示这是他那抽象的牛的头，并且把它称作雪球 $1$。为了让雪牛更好看，她还要给某些雪球来点不同的颜色。于是，她用旧牛奶桶装满了颜料泼到雪牛上。这些颜料分别被编号为 $1,2,\\dots 10^5$，且每种颜色都无限量供应。\n\n当 Bessie 把一桶颜料泼到一个雪球上时，这个雪球子树上的所有雪球也会被染色（我们称雪球 $y$ 在雪球 $x$ 的子树里当且仅当雪球 $x$ 处在雪球 $y$ 到雪球 $1$ 的路径上）。Bessie 有着精确的泼颜料技术，因此在泼完一种颜料后，一个雪球上之前被染过的所有颜色依然清晰可见。例如，一个雪球之前显现出来颜色 $\\left[ 1,2,3 \\right]$，然后 Bessie 把装有 $4$ 号颜色的牛奶桶泼上去，那么这个雪球将显现出来颜色 $\\left[ 1,2,3,4 \\right]$。 在泼了几桶颜料以后，Bessie 可能想要了解她的雪牛有多五彩斑斓。令雪球 $x$ 的『颜色丰富度』为这个雪球被染上的不同颜色总数 ，当 Bessie 想了解雪球 $x$ 的相关信息时，你应该回答她雪球 $x$ 的子树中所有的雪球的颜色丰富度之和。\n\n救救孩子吧！", "inputFormat": "第一行，$N$ 和询问数 $Q$。\n\n接下来 $N-1$ 行每行两个用空格隔开的数 $a$ 和 $b$，表示雪球 $a$ 和 $b$ 中间有一根树枝相连。\n\n最后 $Q$ 行每行一个请求，格式及对应含义如下：\n\n - `1 x c`（修改）：表示 Bessie 把一桶装有颜色 $c$ 的颜料泼到雪球 $x$ ，使得其子树上所有雪球被染色。\n - `2 x`（询问）：询问雪球 $x$ 的子树的颜色丰富度之和。", "outputFormat": "对于每个询问，输出所询问子树的颜色丰富度之和。**为了防止溢出，你需要使用 64 位整数。**", "hint": "#### 样例解释\n执行完第一个修改后雪球 $4$ 被染上了颜色 $1$。\n\n执行完第二个修改后雪球 $4$ 和雪球 $5$ 被染上了颜色 $2$。\n\n执行完第三个修改后所有雪球都被染上了颜色 $1$。\n#### 数据范围\n对于测试点 $2,3$，$1\\le N\\le 10^2,1\\le Q\\le 2\\times 10^2$；\n\n对于测试点 $4-6$，$1\\le N\\le 10^3,1\\le Q\\le 2\\times 10^3$；\n\n对于 $100\\%$ 的数据，$1\\le N,\\ Q,\\ c \\le 10^5, 1\\le a,\\ b,\\ x \\le N$。\n\nUSACO 2019 December 铂金组T2", "locale": "zh-CN"}}}
{"pid": "P5853", "type": "P", "difficulty": 7, "samples": [["3 0 192603497\n", "1 2 3\n"], ["3 1 144408983\n", "3 4 4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2019", "USACO", "组合数学", "生成函数"], "title": "[USACO19DEC] Tree Depth P", "background": null, "description": "为了迎接新年，Farmer John 决定给他的奶牛们一个节日二叉搜索树！\n\n为了生成这个二叉搜索树，Farmer John 从一个 $1 \\dots N$ 的排列 $a= \\{1,2, \\dots ,N\\}$ 开始，然后以参数 $l$ 和 $r$ 开始运行如下的伪代码：\n```\ngenerate(l,r):\n  if l > r, return empty subtree;\n  x = argmin_{l <= i <= r} a_i; // index of min a_i in {a_l,...,a_r}\n  return a BST with x as the root, \n    generate(l,x-1) as the left subtree,\n    generate(x+1,r) as the right subtree;\n```\n例如，排列 $\\{ 3,2,5,1,4 \\}$ 将产生如下的二叉搜索树：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gw6ursc0.png)\n\n令 $d_i(a)$ 表示节点 $i$ 在用排列 $a$ 生成的二叉搜索树中的深度。深度定义为这个节点到根节点的路径上的点数。在上述例子中，$d_4(a)=1,d_2(a)=d_5(a)=2,d_1(a)=d_3(a)=3$。\n\n$a$ 中的逆序对数等于满足 $1 \\le i<j \\le N$ 且 $a_i>a_j$ 的数对 $(i,j)$ 的个数。奶牛们知道 Farmer John 用来生成二叉搜索树的排列 $a$ 中恰好有 $K$ 个逆序对。对于所有满足条件的 $a$，请计算对于每个 $1 \\le i \\le N$，$\\sum_a d_i(a)$ 对 $M$ 取模后的结果。", "inputFormat": "输入只有一行，包含三个整数 $N,K,M$。", "outputFormat": "输出一行 $N$ 个整数，第 $i$ 个整数表示 $\\sum_a d_i(a) \\bmod M$。两个整数之间用一个空格隔开。", "hint": "#### 样例解释 1\n\n对于这个样例，唯一满足条件的排列为 $a=\\{1,2,3\\}$。\n\n#### 样例解释 2\n\n对于这个样例，满足条件的两个排列分别为 $a=\\{1,3,2\\}$ 和 $a=\\{2,1,3\\}$。\n\n#### 数据范围\n\n对于全部数据，$1\\le N\\le 300$，$0\\le K\\le \\frac{N(N-1)}{2}$，保证 $M$ 是一个 $\\left[ 10^8,10^9+9 \\right]$ 范围中的质数。\n\n对于测试点 $3,4$，满足 $N \\le 8$；\n\n对于测试点 $5-7$，满足 $N \\le 20$；\n\n对于测试点 $8-10$，满足 $N \\le 50$。\n\nUSACO 2019 December 铂金组T3", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19DEC] Tree Depth P", "background": null, "description": "For the new year, Farmer John decided to give his cows a festive binary search tree\n(BST)! \n\nTo generate the BST, FJ starts with a permutation $a=\\{a_1,a_2,\\ldots,a_N\\}$\nof the integers $1\\ldots N$, where $N\\le 300$.  He then runs the following\npseudocode with arguments $1$ and $N.$\n\n```\ngenerate(l,r):\n  if l > r, return empty subtree;\n  x = argmin_{l <= i <= r} a_i; // index of min a_i in {a_l,...,a_r}\n  return a BST with x as the root, \n    generate(l,x-1) as the left subtree,\n    generate(x+1,r) as the right subtree;\n```\nFor example, the permutation $\\{3,2,5,1,4\\}$ generates the following BST:\n\n```\n    4\n   / \\\n  2   5\n / \\ \n1   3\n```\nLet $d_i(a)$ denote the depth of node $i$ in the tree corresponding to $a,$ \nmeaning the number of nodes on the path from $a_i$ to the root. In the above\nexample, $d_4(a)=1, d_2(a)=d_5(a)=2,$ and $d_1(a)=d_3(a)=3.$\n\nThe number of inversions of $a$ is equal to the number of pairs of integers\n$(i,j)$ such that $1\\le i<j\\le N$ and $a_i>a_j.$ The cows know that the $a$ that\nFJ will use to generate the BST has exactly $K$ inversions\n$(0\\le K\\le \\frac{N(N-1)}{2})$.  Over all $a$ satisfying this condition, compute\nthe remainder when $\\sum_ad_i(a)$ is divided by $M$ for each $1\\le i\\le N.$", "inputFormat": "The only line of input consists of three space-separated integers $N,K$,and $M$, followed by a new line. $M$ will be a prime number in the range $[10^8,10^9+9]$.", "outputFormat": "Print $N$ space-separated integers denoting $\\sum_a d_i(a) (\\bmod M)$ for each $1\\leq i\\leq N$", "hint": "### Sample Explanation\nFor the first example,the only permutation is $a=\\{1,2,3\\}$.\n\nFor the second example,the two permutations are $a=\\{1,3,2\\}$ and $a=\\{2,1,3\\}$.\n\n### Data range\nTest cases $3-4$ satisfy $N\\leq 8$.  \nTest cases $5-7$ satisfy $N\\leq 20$.  \nTest cases $8-10$ satisfy $N\\leq 50$.", "locale": "en"}, "zh-CN": {"title": "[USACO19DEC] Tree Depth P", "background": null, "description": "为了迎接新年，Farmer John 决定给他的奶牛们一个节日二叉搜索树！\n\n为了生成这个二叉搜索树，Farmer John 从一个 $1 \\dots N$ 的排列 $a= \\{1,2, \\dots ,N\\}$ 开始，然后以参数 $l$ 和 $r$ 开始运行如下的伪代码：\n```\ngenerate(l,r):\n  if l > r, return empty subtree;\n  x = argmin_{l <= i <= r} a_i; // index of min a_i in {a_l,...,a_r}\n  return a BST with x as the root, \n    generate(l,x-1) as the left subtree,\n    generate(x+1,r) as the right subtree;\n```\n例如，排列 $\\{ 3,2,5,1,4 \\}$ 将产生如下的二叉搜索树：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gw6ursc0.png)\n\n令 $d_i(a)$ 表示节点 $i$ 在用排列 $a$ 生成的二叉搜索树中的深度。深度定义为这个节点到根节点的路径上的点数。在上述例子中，$d_4(a)=1,d_2(a)=d_5(a)=2,d_1(a)=d_3(a)=3$。\n\n$a$ 中的逆序对数等于满足 $1 \\le i<j \\le N$ 且 $a_i>a_j$ 的数对 $(i,j)$ 的个数。奶牛们知道 Farmer John 用来生成二叉搜索树的排列 $a$ 中恰好有 $K$ 个逆序对。对于所有满足条件的 $a$，请计算对于每个 $1 \\le i \\le N$，$\\sum_a d_i(a)$ 对 $M$ 取模后的结果。", "inputFormat": "输入只有一行，包含三个整数 $N,K,M$。", "outputFormat": "输出一行 $N$ 个整数，第 $i$ 个整数表示 $\\sum_a d_i(a) \\bmod M$。两个整数之间用一个空格隔开。", "hint": "#### 样例解释 1\n\n对于这个样例，唯一满足条件的排列为 $a=\\{1,2,3\\}$。\n\n#### 样例解释 2\n\n对于这个样例，满足条件的两个排列分别为 $a=\\{1,3,2\\}$ 和 $a=\\{2,1,3\\}$。\n\n#### 数据范围\n\n对于全部数据，$1\\le N\\le 300$，$0\\le K\\le \\frac{N(N-1)}{2}$，保证 $M$ 是一个 $\\left[ 10^8,10^9+9 \\right]$ 范围中的质数。\n\n对于测试点 $3,4$，满足 $N \\le 8$；\n\n对于测试点 $5-7$，满足 $N \\le 20$；\n\n对于测试点 $8-10$，满足 $N \\le 50$。\n\nUSACO 2019 December 铂金组T3", "locale": "zh-CN"}}}
{"pid": "P5854", "type": "P", "difficulty": 4, "samples": [["5\n4 1 3 2 5\n", "19 21\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "笛卡尔树", "模板题"], "title": "【模板】笛卡尔树", "background": "本题部分写法可能触发 GCC15.1 在 O2 下的编译器 bug。建议 C++ 用户以 C++14（GCC9）提交代码。", "description": "给定一个 $1 \\sim n$ 的排列 $p$，构建其笛卡尔树。\n\n即构建一棵二叉树，满足：\n\n1. 每个节点的编号满足二叉搜索树的性质。\n2. 节点 $i$ 的权值为 $p_i$，每个节点的权值满足小根堆的性质。", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个排列 $p_{1 \\dots n}$。", "outputFormat": "设 $l_i,r_i$ 分别表示节点 $i$ 的左右儿子的编号（若不存在则为 $0$）。\n\n一行两个整数，分别表示 $\\operatorname{xor}_{i = 1}^n i \\times (l_i + 1)$ 和 $\\operatorname{xor}_{i = 1}^n i \\times (r_i + 1)$。", "hint": "【样例解释】\n\n| $i$ | $l_i$ | $r_i$ |\n| :-: | :-: | :-: |\n| $1$ | $0$ | $0$ |\n| $2$ | $1$ | $4$ |\n| $3$ | $0$ | $0$ |\n| $4$ | $3$ | $5$ |\n| $5$ | $0$ | $0$ |\n\n【数据范围】\n\n对于 $30\\%$ 的数据，$n \\le 10^3$。\n\n对于 $60\\%$ 的数据，$n \\le 10^5$。\n\n对于 $80\\%$ 的数据，$n \\le 10^6$。\n\n对于 $90\\%$ 的数据，$n \\le 5 \\times 10^6$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^7$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Cartesian Tree.", "background": "Some implementations of this problem may trigger a compiler bug in GCC 15.1 under O2. C++ users are advised to submit with C++14 (GCC9).", "description": "Given a permutation $p$ of $1 \\sim n$, build its Cartesian tree.\n\nThat is, build a binary tree that satisfies:\n\n1. The index of each node satisfies the property of a binary search tree.\n2. The weight of node $i$ is $p_i$, and the weights satisfy the min-heap property.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains a permutation $p_{1 \\dots n}$.", "outputFormat": "Let $l_i, r_i$ denote the indices of the left and right children of node $i$ (use $0$ if it does not exist).\n\nOutput one line with two integers: $\\operatorname{xor}_{i = 1}^n i \\times (l_i + 1)$ and $\\operatorname{xor}_{i = 1}^n i \\times (r_i + 1)$.", "hint": "[Sample Explanation]\n\n| $i$ | $l_i$ | $r_i$ |\n| :-: | :-: | :-: |\n| $1$ | $0$ | $0$ |\n| $2$ | $1$ | $4$ |\n| $3$ | $0$ | $0$ |\n| $4$ | $3$ | $5$ |\n| $5$ | $0$ | $0$ |\n\n[Constraints]\n\nFor $30\\%$ of the testdata, $n \\le 10^3$.\n\nFor $60\\%$ of the testdata, $n \\le 10^5$.\n\nFor $80\\%$ of the testdata, $n \\le 10^6$.\n\nFor $90\\%$ of the testdata, $n \\le 5 \\times 10^6$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】笛卡尔树", "background": "本题部分写法可能触发 GCC15.1 在 O2 下的编译器 bug。建议 C++ 用户以 C++14（GCC9）提交代码。", "description": "给定一个 $1 \\sim n$ 的排列 $p$，构建其笛卡尔树。\n\n即构建一棵二叉树，满足：\n\n1. 每个节点的编号满足二叉搜索树的性质。\n2. 节点 $i$ 的权值为 $p_i$，每个节点的权值满足小根堆的性质。", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个排列 $p_{1 \\dots n}$。", "outputFormat": "设 $l_i,r_i$ 分别表示节点 $i$ 的左右儿子的编号（若不存在则为 $0$）。\n\n一行两个整数，分别表示 $\\operatorname{xor}_{i = 1}^n i \\times (l_i + 1)$ 和 $\\operatorname{xor}_{i = 1}^n i \\times (r_i + 1)$。", "hint": "【样例解释】\n\n| $i$ | $l_i$ | $r_i$ |\n| :-: | :-: | :-: |\n| $1$ | $0$ | $0$ |\n| $2$ | $1$ | $4$ |\n| $3$ | $0$ | $0$ |\n| $4$ | $3$ | $5$ |\n| $5$ | $0$ | $0$ |\n\n【数据范围】\n\n对于 $30\\%$ 的数据，$n \\le 10^3$。\n\n对于 $60\\%$ 的数据，$n \\le 10^5$。\n\n对于 $80\\%$ 的数据，$n \\le 10^6$。\n\n对于 $90\\%$ 的数据，$n \\le 5 \\times 10^6$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^7$。", "locale": "zh-CN"}}}
{"pid": "P5855", "type": "P", "difficulty": 2, "samples": [["3 2\n094\n2 01\n3 149\n2 45\n145\n345\n", "11"], ["2 1\n12\n2 12\n2 34\n13\n", "-1"], ["6 10\n907887\n9 295064731\n6 796350\n9 295378410\n5 48520\n9 745208361\n7 8079632\n111664\n422880\n521471\n433649\n037388\n091076\n235569\n979229\n268527\n690028\n", "153085"], ["18 10\n869813962161100526\n7 1762348\n8 13948756\n6 542169\n8 78314952\n6 432601\n9 697130845\n8 16358709\n8 95204367\n8 24079563\n6 145602\n7 6231549\n6 157096\n8 62534170\n5 82390\n7 5396702\n8 20536491\n7 1438692\n5 59261\n396440170984129947\n891187409797339137\n626815840963841542\n192230179244843846\n148170753474901744\n142718603216393332\n486224779191226121\n819116507635433912\n879948053659796486\n875405657525125039\n", "1468282385203195"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "枚举"], "title": "「SWTR-3」Password", "background": "小 $\\mathrm{A}$ 在茂密的森林里找到了一个宝箱。\n\n宝箱设有密码锁，但小 $\\mathrm{A}$ 不知道密码。", "description": "宝箱的密码由 $n$ 位数字组成，如果将它们连在一起写，就可以看作是一个长度为 $n$ 的字符串。\n\n小 $\\mathrm{A}$ 想通过猜的方式试出密码。对于每一位数字，都会有一个集合 $s_i$，表示小 $\\mathrm{A}$ 第 $i$ 位的尝试范围。\n\n同时，小 $\\mathrm{A}$ 已经试过了 $k$ 个密码组合 $d_1,d_2,\\dots,d_k$，**这些密码不一定符合上文中的“尝试范围”**。\n\n小 $\\mathrm{A}$ 想知道他最多还需要尝试多少次才可以试出宝箱的密码，如果永远试不出输出 $\\mathrm{-1}$。", "inputFormat": "第一行，两个整数 $n,k$。\n\n第二行，一个长度为 $n$ 的字符串 $a$，表示宝箱的密码。\n\n接下来 $n$ 行，每行以一个整数 $v_i$ 开头，表示 $s_i$ 的大小，接下来一个长度为 $v_i$ 的字符串 $s_i$，保证 $s_i$ 各位数字互不相同。\n\n接下来 $k$ 行，每行一个**互不相同**的长度为 $n$ 的字符串 $d_i$，表示小 $\\mathrm{A}$ 已经试过了哪些密码组合。", "outputFormat": "输出小 $\\mathrm{A}$ 最多还需要尝试多少次可以试出宝箱的密码，如果永远试不出，输出 $-1$。", "hint": "---\n\n### 样例说明\n\n- 在样例 $1$ 中，小 $\\mathrm{A}$ 可能试的密码组合有：`014,015,044,045,094,095,114,115,144,145,194,195` 共 $12$ 个数，其中包含密码，但因为 `145` 已经试过，所以小 $\\mathrm{A}$ 最多还需尝试 $11$ 次。\n\n- 在样例 $2$ 中，小 $\\mathrm{A}$ 可能试的密码组合有：`13,14,23,24`，共 $4$ 个数，其中没有密码，所以小 $\\mathrm{A}$ 永远试不出密码。\n\n---\n\n### 数据范围与约定\n\n**本题使用捆绑测试。**\n\nSubtask 编号 | $n\\leq$ | 特殊性质 | 分数\n:-: | :-: | :-: | :-:\n$1$ | $18$ | 答案为 $-1$ | $7$\n$2$ | $1$ | 无 | $13$\n$3$ | $6$ | 无 | $24$\n$4$ | $18$ | $k=0$ | $21$\n$5$ | $18$ | 无 | $35$\n\n对于 $100\\%$ 的数据，有 $1\\leq n\\leq 18$，$0\\leq k \\leq\\min(10^n-1,10^4)$。\n\n保证 $d_i$ 不为密码。\n\n---\n\n对于所有测试点，时间限制 $1\\mathrm{s}$，空间限制 $128\\mathrm{MB}$。", "locale": "zh-CN", "translations": {"en": {"title": "\"SWTR-3\" Password", "background": "Little $\\mathrm{A}$ found a treasure chest in a dense forest.\n\nThe chest has a combination lock, but little $\\mathrm{A}$ does not know the password.", "description": "The password of the chest consists of $n$ digits. If you write them together, it can be seen as a string of length $n$.\n\nLittle $\\mathrm{A}$ wants to guess the password. For each digit position, there is a set $s_i$, representing the range of digits little $\\mathrm{A}$ will try for the $i$-th position.\n\nAlso, little $\\mathrm{A}$ has already tried $k$ password strings $d_1,d_2,\\dots,d_k$. **These passwords do not necessarily satisfy the above “try ranges”.**\n\nLittle $\\mathrm{A}$ wants to know the maximum number of additional attempts he may still need to crack the chest’s password. If he can never crack it, output $\\mathrm{-1}$.", "inputFormat": "The first line contains two integers $n,k$.\n\nThe second line contains a string $a$ of length $n$, representing the chest’s password.\n\nIn the next $n$ lines, each line starts with an integer $v_i$, indicating the size of $s_i$, followed by a string $s_i$ of length $v_i$. It is guaranteed that all digits in $s_i$ are distinct.\n\nIn the next $k$ lines, each line contains a **distinct** string $d_i$ of length $n$, indicating the password strings that little $\\mathrm{A}$ has already tried.", "outputFormat": "Output the maximum number of additional attempts little $\\mathrm{A}$ may still need to crack the chest’s password. If he can never crack it, output $-1$.", "hint": "---\n\n### Sample Explanation\n\n- In sample $1$, the possible password strings little $\\mathrm{A}$ may try are: `014,015,044,045,094,095,114,115,144,145,194,195`, a total of $12$ strings. This set contains the real password, but since `145` has already been tried, little $\\mathrm{A}$ may need at most $11$ more attempts.\n\n- In sample $2$, the possible password strings little $\\mathrm{A}$ may try are: `13,14,23,24`, a total of $4$ strings. None of them is the real password, so little $\\mathrm{A}$ can never crack the password.\n\n---\n\n### Constraints and Notes\n\n**This problem uses bundled testdata.**\n\nSubtask ID | $n\\leq$ | Special Property | Score\n:-: | :-: | :-: | :-:\n$1$ | $18$ | The answer is $-1$ | $7$\n$2$ | $1$ | None | $13$\n$3$ | $6$ | None | $24$\n$4$ | $18$ | $k=0$ | $21$\n$5$ | $18$ | None | $35$\n\nFor $100\\%$ of the data, $1\\leq n\\leq 18$ and $0\\leq k \\leq\\min(10^n-1,10^4)$.\n\nIt is guaranteed that $d_i$ is not the password.\n\n---\n\nFor all test points, the time limit is $1\\mathrm{s}$ and the memory limit is $128\\mathrm{MB}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「SWTR-3」Password", "background": "小 $\\mathrm{A}$ 在茂密的森林里找到了一个宝箱。\n\n宝箱设有密码锁，但小 $\\mathrm{A}$ 不知道密码。", "description": "宝箱的密码由 $n$ 位数字组成，如果将它们连在一起写，就可以看作是一个长度为 $n$ 的字符串。\n\n小 $\\mathrm{A}$ 想通过猜的方式试出密码。对于每一位数字，都会有一个集合 $s_i$，表示小 $\\mathrm{A}$ 第 $i$ 位的尝试范围。\n\n同时，小 $\\mathrm{A}$ 已经试过了 $k$ 个密码组合 $d_1,d_2,\\dots,d_k$，**这些密码不一定符合上文中的“尝试范围”**。\n\n小 $\\mathrm{A}$ 想知道他最多还需要尝试多少次才可以试出宝箱的密码，如果永远试不出输出 $\\mathrm{-1}$。", "inputFormat": "第一行，两个整数 $n,k$。\n\n第二行，一个长度为 $n$ 的字符串 $a$，表示宝箱的密码。\n\n接下来 $n$ 行，每行以一个整数 $v_i$ 开头，表示 $s_i$ 的大小，接下来一个长度为 $v_i$ 的字符串 $s_i$，保证 $s_i$ 各位数字互不相同。\n\n接下来 $k$ 行，每行一个**互不相同**的长度为 $n$ 的字符串 $d_i$，表示小 $\\mathrm{A}$ 已经试过了哪些密码组合。", "outputFormat": "输出小 $\\mathrm{A}$ 最多还需要尝试多少次可以试出宝箱的密码，如果永远试不出，输出 $-1$。", "hint": "---\n\n### 样例说明\n\n- 在样例 $1$ 中，小 $\\mathrm{A}$ 可能试的密码组合有：`014,015,044,045,094,095,114,115,144,145,194,195` 共 $12$ 个数，其中包含密码，但因为 `145` 已经试过，所以小 $\\mathrm{A}$ 最多还需尝试 $11$ 次。\n\n- 在样例 $2$ 中，小 $\\mathrm{A}$ 可能试的密码组合有：`13,14,23,24`，共 $4$ 个数，其中没有密码，所以小 $\\mathrm{A}$ 永远试不出密码。\n\n---\n\n### 数据范围与约定\n\n**本题使用捆绑测试。**\n\nSubtask 编号 | $n\\leq$ | 特殊性质 | 分数\n:-: | :-: | :-: | :-:\n$1$ | $18$ | 答案为 $-1$ | $7$\n$2$ | $1$ | 无 | $13$\n$3$ | $6$ | 无 | $24$\n$4$ | $18$ | $k=0$ | $21$\n$5$ | $18$ | 无 | $35$\n\n对于 $100\\%$ 的数据，有 $1\\leq n\\leq 18$，$0\\leq k \\leq\\min(10^n-1,10^4)$。\n\n保证 $d_i$ 不为密码。\n\n---\n\n对于所有测试点，时间限制 $1\\mathrm{s}$，空间限制 $128\\mathrm{MB}$。", "locale": "zh-CN"}}}
{"pid": "P5856", "type": "P", "difficulty": 5, "samples": [["5\n12 30 48 36 18\n", "4"], ["10\n72 81 27 90 45 45 27 99 45 18\n", "6"], ["4\n1 2 4 8", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "O2优化", "状压 DP"], "title": "「SWTR-3」Game", "background": "小 E 在玩一个数字游戏。", "description": "小 E 有 $n$ 个正整数 $a_1,a_2,\\dots,a_n$。他可以进行以下操作任意次：\n\n选择一个数 $q$，和一个集合 $S=\\{d_1,d_2,\\dots,d_m\\}$，使得 $a_{d_1},a_{d_2},\\dots,a_{d_m}$ 能被 $q$ 整除，并将 $a_{d_1},a_{d_2},\\dots,a_{d_m}$ 除以 $q$。\n\n- $q$ 要满足可以写成 $p^z$ 的形式，其中 $p$ 为质数，$z$ 为正整数。\n\n求最少需要进行多少次操作才能将这些数变为相等的数。", "inputFormat": "第一行，一个整数 $n$。\n\n第二行，$n$ 个整数 $a_1,a_2,\\dots,a_n$。", "outputFormat": "输出一个整数表示答案。", "hint": "#### 「样例 1 说明」\n\n一开始的序列为 12 30 48 36 18。  \n选择 $S=\\{4,5\\},p=3$，操作后变为 12 30 48 12 6。  \n选择 $S=\\{1,3,4\\},p=2$，操作后变为 6 30 24 6 6。  \n选择 $S=\\{2\\},p=5$，操作后变为 6 6 24 6 6。  \n选择 $S=\\{3\\},p=2^2=4$，操作后变为 6 6 6 6 6。  \n共 4 次操作，方法不唯一。\n\n#### 「数据范围与约定」\n\n**本题使用捆绑测试。**\n\nSubtask 编号 | $n\\leq$ | $a_i\\leq$ | 特殊性质 | 得分\n:-: | :-: | :-: | :-: | :-:\n$1$ | $8$ | $50$ | $a_i$ 中有一个数为 $1$ | $13$\n$2$ | $10$ | $100$ | 无 | $17$\n$3$ | $10^3$ | $10^4$ | 无 | $29$\n$4$ | $10^5$ | $10^6$ | 无 | $41$\n\n对于 $100\\%$ 的数据，有 $1\\leq n\\leq 10^5$，$1\\leq a_i\\leq 10^6$。\n\n对于所有测试点，时间限制 1s，空间限制 128MB。\n\n#### 「来源」\n\n[Sweet Round 03 B](https://www.luogu.com.cn/contest/24755)。  \nidea & solution：ET2006 & Alex_Wei。", "locale": "zh-CN", "translations": {"en": {"title": "\"SWTR-3\" Game", "background": "Little E is playing a number game.", "description": "Little E has $n$ positive integers $a_1,a_2,\\dots,a_n$. He can perform the following operation any number of times:\n\nChoose a number $q$ and a set $S=\\{d_1,d_2,\\dots,d_m\\}$ such that $a_{d_1},a_{d_2},\\dots,a_{d_m}$ are divisible by $q$, and divide $a_{d_1},a_{d_2},\\dots,a_{d_m}$ by $q$.\n\n- $q$ must be in the form $p^z$, where $p$ is a prime number and $z$ is a positive integer.\n\nFind the minimum number of operations needed to make all these numbers equal.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n$ integers $a_1,a_2,\\dots,a_n$.", "outputFormat": "Output one integer representing the answer.", "hint": "#### \"Sample 1 Explanation\"\n\nThe initial sequence is 12 30 48 36 18.  \nChoose $S=\\{4,5\\},p=3$, after the operation it becomes 12 30 48 12 6.  \nChoose $S=\\{1,3,4\\},p=2$, after the operation it becomes 6 30 24 6 6.  \nChoose $S=\\{2\\},p=5$, after the operation it becomes 6 6 24 6 6.  \nChoose $S=\\{3\\},p=2^2=4$, after the operation it becomes 6 6 6 6 6.  \nA total of 4 operations are used, and the method is not unique.\n\n#### \"Constraints and Notes\"\n\n**This problem uses bundled testdata.**\n\nSubtask ID | $n\\leq$ | $a_i\\leq$ | Special Property | Score\n:-: | :-: | :-: | :-: | :-:\n$1$ | $8$ | $50$ | There is a number equal to $1$ among $a_i$ | $13$\n$2$ | $10$ | $100$ | None | $17$\n$3$ | $10^3$ | $10^4$ | None | $29$\n$4$ | $10^5$ | $10^6$ | None | $41$\n\nFor $100\\%$ of the data, $1\\leq n\\leq 10^5$ and $1\\leq a_i\\leq 10^6$.\n\nFor all test points, the time limit is 1s and the memory limit is 128MB.\n\n#### \"Source\"\n\n[Sweet Round 03 B](https://www.luogu.com.cn/contest/24755)。  \nidea & solution: ET2006 & Alex_Wei。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「SWTR-3」Game", "background": "小 E 在玩一个数字游戏。", "description": "小 E 有 $n$ 个正整数 $a_1,a_2,\\dots,a_n$。他可以进行以下操作任意次：\n\n选择一个数 $q$，和一个集合 $S=\\{d_1,d_2,\\dots,d_m\\}$，使得 $a_{d_1},a_{d_2},\\dots,a_{d_m}$ 能被 $q$ 整除，并将 $a_{d_1},a_{d_2},\\dots,a_{d_m}$ 除以 $q$。\n\n- $q$ 要满足可以写成 $p^z$ 的形式，其中 $p$ 为质数，$z$ 为正整数。\n\n求最少需要进行多少次操作才能将这些数变为相等的数。", "inputFormat": "第一行，一个整数 $n$。\n\n第二行，$n$ 个整数 $a_1,a_2,\\dots,a_n$。", "outputFormat": "输出一个整数表示答案。", "hint": "#### 「样例 1 说明」\n\n一开始的序列为 12 30 48 36 18。  \n选择 $S=\\{4,5\\},p=3$，操作后变为 12 30 48 12 6。  \n选择 $S=\\{1,3,4\\},p=2$，操作后变为 6 30 24 6 6。  \n选择 $S=\\{2\\},p=5$，操作后变为 6 6 24 6 6。  \n选择 $S=\\{3\\},p=2^2=4$，操作后变为 6 6 6 6 6。  \n共 4 次操作，方法不唯一。\n\n#### 「数据范围与约定」\n\n**本题使用捆绑测试。**\n\nSubtask 编号 | $n\\leq$ | $a_i\\leq$ | 特殊性质 | 得分\n:-: | :-: | :-: | :-: | :-:\n$1$ | $8$ | $50$ | $a_i$ 中有一个数为 $1$ | $13$\n$2$ | $10$ | $100$ | 无 | $17$\n$3$ | $10^3$ | $10^4$ | 无 | $29$\n$4$ | $10^5$ | $10^6$ | 无 | $41$\n\n对于 $100\\%$ 的数据，有 $1\\leq n\\leq 10^5$，$1\\leq a_i\\leq 10^6$。\n\n对于所有测试点，时间限制 1s，空间限制 128MB。\n\n#### 「来源」\n\n[Sweet Round 03 B](https://www.luogu.com.cn/contest/24755)。  \nidea & solution：ET2006 & Alex_Wei。", "locale": "zh-CN"}}}
{"pid": "P5857", "type": "P", "difficulty": 6, "samples": [["11\n1 1 3\n4 3 5\n2 3 1\n123 231 132\n1 1017 12345\n1017 1567 1\n1710 1017 999\n1987 1789 375168429\n101777 171077 99999\n123321 200000 321123\n2 2 1", "1\n32\n6\n198296574\n832895500\n1593639\n928595966\n438358858\n366897935\n745426660\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["数学", "O2优化"], "title": "「SWTR-3」Matrix", "background": "", "description": "小 E 有一个 $n \\times m$ 的魔法矩阵，每个格子有激活和未激活两个状态。一开始，格子都是未激活的。\n\n小 E 有一个魔法棒，可以使用 $k$ 次魔法。每次使用魔法时小 $\\mathrm{E}$ 需选择一个魔法格子 $(x,y)$ 并改变第 $x$ 行和第 $y$ 列的所有魔法格子的状态。**$(x,y)$ 的状态会被改变两次。**\n\n现在小 E 想知道，使用 $k$ 次魔法之后可以得到多少个不同的魔法矩阵。\n\n- 两个魔法矩阵不同，当且仅当两个魔法矩阵中有一个对应格子的状态不同。\n\n由于答案很大，请对 $998244353$ 取模。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行，一个整数 $T$，测试数据的组数。\n\n每一组测试数据由一行三个整数 $n,m,k$ 组成——矩阵的长，矩阵的宽，使用魔法的次数。", "outputFormat": "对于每组测试数据，输出单独的一行整数，表示使用 $k$ 次魔法之后可以得到多少个不同的魔法矩阵。", "hint": "#### 「样例说明」\n\n- 对于第 1 组测试数据：无论如何使用魔法棒，最多只会有 1 种不同的魔法矩阵。 \n- 对于第 3 组测试数据：任选一个格子使用 1 次魔法棒都能得到一个不同的魔法矩阵，共 $2\\times 3=6$ 种不同的魔法矩阵。\n\n---\n\n### 数据范围与约定\n\n测试点编号 | $n\\leq$ | $m\\leq$ | $k\\leq$\n:-: | :-: | :-: | :-:\n$1$ | $1$ | $1$ | $10^9$\n$2$ | $4$ | $4$ | $4$\n$3-5$ | $200$ | $200$ | $200$\n$6-7$ | $1$ | $1000$ | $10^5$\n$8$ | $1000$ | $1000$ | $1$\n$9-12$ | $1000$ | $1000$ | $10^5$\n$13-20$ | $2\\times 10^5$ | $2\\times 10^5$ | $10^9$\n\n对于 $100\\%$ 的数据，$1 \\leq T \\leq 64$，$\\ 1 \\leq n,m \\leq 2\\times 10^5$，$\\ 1 \\leq k \\leq 10^9$。\n\n对于所有测试点，时间限制 1s，空间限制 32MB。\n\n#### 「来源」\n\n[Sweet Round 03 C](https://www.luogu.com.cn/contest/24755)。  \nidea & solution：ET2006。", "locale": "zh-CN", "translations": {"en": {"title": "\"SWTR-3\" Matrix", "background": "", "description": "Little E has an $n \\times m$ magic matrix. Each cell has two states: activated and not activated. At the beginning, all cells are not activated.\n\nLittle E has a magic wand and can use magic $k$ times. Each time magic is used, Little E needs to choose a magic cell $(x,y)$ and toggle the state of all magic cells in row $x$ and column $y$. **The state of $(x,y)$ will be toggled twice.**\n\nNow Little E wants to know how many different magic matrices can be obtained after using magic $k$ times.\n\n- Two magic matrices are different if and only if there exists at least one corresponding cell whose state is different in the two matrices.\n\nSince the answer may be very large, output it modulo $998244353$.", "inputFormat": "**This problem contains multiple test cases.**\n\nThe first line contains an integer $T$, the number of test cases.\n\nEach test case consists of one line with three integers $n,m,k$ — the height of the matrix, the width of the matrix, and the number of times magic is used.", "outputFormat": "For each test case, output a single line with one integer, representing how many different magic matrices can be obtained after using magic $k$ times.", "hint": "#### \"Sample Explanation\"\n\n- For the $1$st test case: no matter how the magic wand is used, at most $1$ different magic matrix can be obtained.\n- For the $3$rd test case: using the magic wand once on any cell can produce a different magic matrix, for a total of $2 \\times 3 = 6$ different magic matrices.\n\n---\n\n### Constraints and Notes\n\nTest point ID | $n \\leq$ | $m \\leq$ | $k \\leq$\n:-: | :-: | :-: | :-:\n$1$ | $1$ | $1$ | $10^9$\n$2$ | $4$ | $4$ | $4$\n$3-5$ | $200$ | $200$ | $200$\n$6-7$ | $1$ | $1000$ | $10^5$\n$8$ | $1000$ | $1000$ | $1$\n$9-12$ | $1000$ | $1000$ | $10^5$\n$13-20$ | $2 \\times 10^5$ | $2 \\times 10^5$ | $10^9$\n\nFor $100\\%$ of the testdata, $1 \\leq T \\leq 64$, $1 \\leq n,m \\leq 2 \\times 10^5$, $1 \\leq k \\leq 10^9$.\n\nFor all test points, the time limit is $1$s and the memory limit is $32$MB.\n\n#### \"Source\"\n\n[Sweet Round 03 C](https://www.luogu.com.cn/contest/24755)。  \nIdea & solution: ET2006。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「SWTR-3」Matrix", "background": "", "description": "小 E 有一个 $n \\times m$ 的魔法矩阵，每个格子有激活和未激活两个状态。一开始，格子都是未激活的。\n\n小 E 有一个魔法棒，可以使用 $k$ 次魔法。每次使用魔法时小 $\\mathrm{E}$ 需选择一个魔法格子 $(x,y)$ 并改变第 $x$ 行和第 $y$ 列的所有魔法格子的状态。**$(x,y)$ 的状态会被改变两次。**\n\n现在小 E 想知道，使用 $k$ 次魔法之后可以得到多少个不同的魔法矩阵。\n\n- 两个魔法矩阵不同，当且仅当两个魔法矩阵中有一个对应格子的状态不同。\n\n由于答案很大，请对 $998244353$ 取模。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行，一个整数 $T$，测试数据的组数。\n\n每一组测试数据由一行三个整数 $n,m,k$ 组成——矩阵的长，矩阵的宽，使用魔法的次数。", "outputFormat": "对于每组测试数据，输出单独的一行整数，表示使用 $k$ 次魔法之后可以得到多少个不同的魔法矩阵。", "hint": "#### 「样例说明」\n\n- 对于第 1 组测试数据：无论如何使用魔法棒，最多只会有 1 种不同的魔法矩阵。 \n- 对于第 3 组测试数据：任选一个格子使用 1 次魔法棒都能得到一个不同的魔法矩阵，共 $2\\times 3=6$ 种不同的魔法矩阵。\n\n---\n\n### 数据范围与约定\n\n测试点编号 | $n\\leq$ | $m\\leq$ | $k\\leq$\n:-: | :-: | :-: | :-:\n$1$ | $1$ | $1$ | $10^9$\n$2$ | $4$ | $4$ | $4$\n$3-5$ | $200$ | $200$ | $200$\n$6-7$ | $1$ | $1000$ | $10^5$\n$8$ | $1000$ | $1000$ | $1$\n$9-12$ | $1000$ | $1000$ | $10^5$\n$13-20$ | $2\\times 10^5$ | $2\\times 10^5$ | $10^9$\n\n对于 $100\\%$ 的数据，$1 \\leq T \\leq 64$，$\\ 1 \\leq n,m \\leq 2\\times 10^5$，$\\ 1 \\leq k \\leq 10^9$。\n\n对于所有测试点，时间限制 1s，空间限制 32MB。\n\n#### 「来源」\n\n[Sweet Round 03 C](https://www.luogu.com.cn/contest/24755)。  \nidea & solution：ET2006。", "locale": "zh-CN"}}}
{"pid": "P5858", "type": "P", "difficulty": 4, "samples": [["5 3 3\n1 3 2 4 5\n", "40"], ["5 3 3\n1 -3 -2 4 5\n", "21"], ["7 4 2\n-5 3 -1 -4 7 -6 5\n", "17"], ["5 3 1\n-1 -3 -2 -4 -5\n", "-15"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "单调队列", "O2优化"], "title": "「SWTR-3」Golden Sword", "background": "小 E 不幸在一场战斗中失去了他的金宝剑。", "description": "制造一把金宝剑需要 $n$ 种原料，编号为 $1$ 到 $n$，编号为 $i$ 的原料的坚固值为 $a_i$。\n\n炼金是很讲究放入原料的顺序的，因此小 E 必须**按照 $1$ 到 $n$ 的顺序**依次将这些原料放入炼金锅。\n\n但是，炼金锅的容量非常有限，它**最多只能容纳 $w$ 个原料**。\n\n所幸的是，**每放入一个原料之前**，小 E 可以从中取出一些原料，数量不能超过 $s$ 个。\n\n- 我们定义第 $i$ 种原料的耐久度为：放入第 $i$ 种原料时锅内的原料总数（包括正在放入的原料） $\\times\\ a_i$，则宝剑的耐久度为**所有原料**的耐久度之和。\n\n小 E 当然想让他的宝剑的耐久度尽可能得大，这样他就可以带着它进行更多的战斗，请求出耐久度的最大值。\n\n注：这里的“放入第 $i$ 种原料时锅内的原料总数**包括正在放入锅中的原料**，详细信息请见样例。", "inputFormat": "第一行，三个整数 $n,w,s$。\n\n第二行，$n$ 个整数 $a_1,a_2,\\dots,a_n$。", "outputFormat": "一行一个整数，表示耐久度的最大值。", "hint": "#### 「样例说明」\n\n- **对于样例 1**，一种可行的**最优**方案为：\n首先放进原料 1，此时锅内有 $1$ 种原料，耐久度为 $1\\times a_1=1\\times 1=1$。  \n再放进原料 2，此时锅内有 $2$ 种原料，耐久度为 $2\\times a_2=2\\times 3=6$。  \n再放进原料 3，此时锅内有 $3$ 种原料，耐久度为 $3\\times a_3=3\\times 2=6$。  \n取出原料 1，再放进原料 4，此时锅内有 $3$ 种原料，耐久度为 $3\\times a_4=3\\times 4=12$。  \n取出原料 4，再放进原料 5，此时锅内有 $3$ 种原料，耐久度为 $3\\times a_5=3\\times 5=15$。  \n最终答案为 $1+6+6+12+15=40$。  \n- **对于样例 2**，一种可行的**最优**方案为：  \n放进原料 1，耐久度为 $1\\times 1=1$。  \n取出原料 1，放进原料 2，耐久度为 $1\\times (-3)=-3$。  \n放进原料 3，耐久度为 $2\\times (-2)=-4$。  \n放进原料 4，耐久度为 $3\\times 4=12$。  \n取出原料 2，放进原料 5，耐久度为 $3\\times 5=15$。  \n最终答案为 $1+(-3)+(-4)+12+15=21$。  \n- **对于样例 3**，一种可行的**最优**方案为：  \n  $a_1+2a_2+2a_3+3a_4+4a_5+3a_6+4a_7=17$。 \n- **对于样例 4**，一种可行的**最优**方案为：  \n$a_1+a_2+a_3+a_4+a_5=-15$。\n\n#### 「数据范围与约定」\n\n**本题使用捆绑测试。**\n\n- Subtask #1（15 points）：$n\\leq 10$。\n- Subtask #2（5 points）：$n\\leq 100$，$a_i\\geq0$。\n- Subtask #3（15 points）：$n\\leq 300$。\n- Subtask #4（15 points）：$s=w=n$。\n- Subtask #5（5 points）：$a_i\\geq 0$。\n- Subtask #6（10 points）：$n\\leq 2\\times 10^3$。\n- Subtask #7（10 points）：$s=1$。\n- Subtask #8（25 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\leq s \\leq w \\leq n \\leq 5\\times 10^3$，$|a_i| \\leq 10^9$。对于 Subtask $i$ 有 $|a_i|\\leq 10^{i+1}$。\n\n#### 「帮助/说明」\n\n本题下发大样例，具体输入输出见 [**Big Sample**](https://pan.baidu.com/s/1erVDllDlvNlEShxh3U42gA) 中的 gold01-08.in/gold01-08.out。提取码：757d。  \n**文件名与 Subtask 编号一一对应。**\n\n#### 「来源」\n\n[Sweet Round 03 D](https://www.luogu.com.cn/contest/24755)。  \nidea & solution：ET2006。", "locale": "zh-CN", "translations": {"en": {"title": "\"SWTR-3\" Golden Sword", "background": "Little E unfortunately lost his golden sword in a battle.", "description": "To make a golden sword, $n$ kinds of materials are needed, numbered from $1$ to $n$. The sturdiness value of material $i$ is $a_i$.\n\nAlchemy pays great attention to the order of adding materials, so Little E must add these materials into the alchemy pot **in the order from $1$ to $n$**, one by one.\n\nHowever, the pot has a very limited capacity: it can hold **at most $w$ materials**.\n\nFortunately, **before adding each material**, Little E may take out some materials from the pot, but the number taken out cannot exceed $s$.\n\n- We define the durability of material $i$ as: (the total number of materials in the pot when adding material $i$, **including the material being added**) $\\times\\ a_i$. Then, the sword's durability is the sum of the durabilities of **all materials**.\n\nLittle E of course wants his sword's durability to be as large as possible, so that he can take it into more battles. Please output the maximum possible durability.\n\nNote: Here, “the total number of materials in the pot when adding material $i$” **includes the material currently being put into the pot**. For details, see the samples.", "inputFormat": "The first line contains three integers $n,w,s$.\n\nThe second line contains $n$ integers $a_1,a_2,\\dots,a_n$.", "outputFormat": "Output one integer in one line, representing the maximum durability.", "hint": "#### \"Sample Explanation\"\n\n- **For Sample 1**, one feasible **optimal** plan is:\nFirst put in material 1. Now there is $1$ material in the pot, and the durability is $1\\times a_1=1\\times 1=1$.  \nThen put in material 2. Now there are $2$ materials in the pot, and the durability is $2\\times a_2=2\\times 3=6$.  \nThen put in material 3. Now there are $3$ materials in the pot, and the durability is $3\\times a_3=3\\times 2=6$.  \nTake out material 1, then put in material 4. Now there are $3$ materials in the pot, and the durability is $3\\times a_4=3\\times 4=12$.  \nTake out material 4, then put in material 5. Now there are $3$ materials in the pot, and the durability is $3\\times a_5=3\\times 5=15$.  \nThe final answer is $1+6+6+12+15=40$.  \n- **For Sample 2**, one feasible **optimal** plan is:  \nPut in material 1, and the durability is $1\\times 1=1$.  \nTake out material 1, put in material 2, and the durability is $1\\times (-3)=-3$.  \nPut in material 3, and the durability is $2\\times (-2)=-4$.  \nPut in material 4, and the durability is $3\\times 4=12$.  \nTake out material 2, put in material 5, and the durability is $3\\times 5=15$.  \nThe final answer is $1+(-3)+(-4)+12+15=21$.  \n- **For Sample 3**, one feasible **optimal** plan is:  \n  $a_1+2a_2+2a_3+3a_4+4a_5+3a_6+4a_7=17$. \n- **For Sample 4**, one feasible **optimal** plan is:  \n$a_1+a_2+a_3+a_4+a_5=-15$.\n\n#### \"Constraints and Notes\"\n\n**This problem uses bundled testdata.**\n\n- Subtask #1 (15 points): $n\\leq 10$.\n- Subtask #2 (5 points): $n\\leq 100$, $a_i\\geq0$.\n- Subtask #3 (15 points): $n\\leq 300$.\n- Subtask #4 (15 points): $s=w=n$.\n- Subtask #5 (5 points): $a_i\\geq 0$.\n- Subtask #6 (10 points): $n\\leq 2\\times 10^3$.\n- Subtask #7 (10 points): $s=1$.\n- Subtask #8 (25 points): no special restrictions.\n\nFor $100\\%$ of the data, $1 \\leq s \\leq w \\leq n \\leq 5\\times 10^3$, $|a_i| \\leq 10^9$. For Subtask $i$, $|a_i|\\leq 10^{i+1}$.\n\n#### \"Help / Notes\"\n\nThis problem provides large samples. For the exact input and output, see gold01-08.in / gold01-08.out in [**Big Sample**](https://pan.baidu.com/s/1erVDllDlvNlEShxh3U42gA). Extraction code: 757d.  \n**The filenames correspond one-to-one with the Subtask numbers.**\n\n#### \"Source\"\n\n[Sweet Round 03 D](https://www.luogu.com.cn/contest/24755).  \nIdea & solution: ET2006.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「SWTR-3」Golden Sword", "background": "小 E 不幸在一场战斗中失去了他的金宝剑。", "description": "制造一把金宝剑需要 $n$ 种原料，编号为 $1$ 到 $n$，编号为 $i$ 的原料的坚固值为 $a_i$。\n\n炼金是很讲究放入原料的顺序的，因此小 E 必须**按照 $1$ 到 $n$ 的顺序**依次将这些原料放入炼金锅。\n\n但是，炼金锅的容量非常有限，它**最多只能容纳 $w$ 个原料**。\n\n所幸的是，**每放入一个原料之前**，小 E 可以从中取出一些原料，数量不能超过 $s$ 个。\n\n- 我们定义第 $i$ 种原料的耐久度为：放入第 $i$ 种原料时锅内的原料总数（包括正在放入的原料） $\\times\\ a_i$，则宝剑的耐久度为**所有原料**的耐久度之和。\n\n小 E 当然想让他的宝剑的耐久度尽可能得大，这样他就可以带着它进行更多的战斗，请求出耐久度的最大值。\n\n注：这里的“放入第 $i$ 种原料时锅内的原料总数**包括正在放入锅中的原料**，详细信息请见样例。", "inputFormat": "第一行，三个整数 $n,w,s$。\n\n第二行，$n$ 个整数 $a_1,a_2,\\dots,a_n$。", "outputFormat": "一行一个整数，表示耐久度的最大值。", "hint": "#### 「样例说明」\n\n- **对于样例 1**，一种可行的**最优**方案为：\n首先放进原料 1，此时锅内有 $1$ 种原料，耐久度为 $1\\times a_1=1\\times 1=1$。  \n再放进原料 2，此时锅内有 $2$ 种原料，耐久度为 $2\\times a_2=2\\times 3=6$。  \n再放进原料 3，此时锅内有 $3$ 种原料，耐久度为 $3\\times a_3=3\\times 2=6$。  \n取出原料 1，再放进原料 4，此时锅内有 $3$ 种原料，耐久度为 $3\\times a_4=3\\times 4=12$。  \n取出原料 4，再放进原料 5，此时锅内有 $3$ 种原料，耐久度为 $3\\times a_5=3\\times 5=15$。  \n最终答案为 $1+6+6+12+15=40$。  \n- **对于样例 2**，一种可行的**最优**方案为：  \n放进原料 1，耐久度为 $1\\times 1=1$。  \n取出原料 1，放进原料 2，耐久度为 $1\\times (-3)=-3$。  \n放进原料 3，耐久度为 $2\\times (-2)=-4$。  \n放进原料 4，耐久度为 $3\\times 4=12$。  \n取出原料 2，放进原料 5，耐久度为 $3\\times 5=15$。  \n最终答案为 $1+(-3)+(-4)+12+15=21$。  \n- **对于样例 3**，一种可行的**最优**方案为：  \n  $a_1+2a_2+2a_3+3a_4+4a_5+3a_6+4a_7=17$。 \n- **对于样例 4**，一种可行的**最优**方案为：  \n$a_1+a_2+a_3+a_4+a_5=-15$。\n\n#### 「数据范围与约定」\n\n**本题使用捆绑测试。**\n\n- Subtask #1（15 points）：$n\\leq 10$。\n- Subtask #2（5 points）：$n\\leq 100$，$a_i\\geq0$。\n- Subtask #3（15 points）：$n\\leq 300$。\n- Subtask #4（15 points）：$s=w=n$。\n- Subtask #5（5 points）：$a_i\\geq 0$。\n- Subtask #6（10 points）：$n\\leq 2\\times 10^3$。\n- Subtask #7（10 points）：$s=1$。\n- Subtask #8（25 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\leq s \\leq w \\leq n \\leq 5\\times 10^3$，$|a_i| \\leq 10^9$。对于 Subtask $i$ 有 $|a_i|\\leq 10^{i+1}$。\n\n#### 「帮助/说明」\n\n本题下发大样例，具体输入输出见 [**Big Sample**](https://pan.baidu.com/s/1erVDllDlvNlEShxh3U42gA) 中的 gold01-08.in/gold01-08.out。提取码：757d。  \n**文件名与 Subtask 编号一一对应。**\n\n#### 「来源」\n\n[Sweet Round 03 D](https://www.luogu.com.cn/contest/24755)。  \nidea & solution：ET2006。", "locale": "zh-CN"}}}
{"pid": "P5859", "type": "P", "difficulty": 5, "samples": [["11\n1 -1 2 2 -1 7\n1 2 2 -1 0 10\n1 2 1 1 -1 17\n3 5 4\n3 -99999 0\n3 -3 6\n3 1 -1\n4 2\n2 1\n4 2\n4 1\n", "7\n10\n17\n17\n17\n10\noops!"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["计算几何", "线段树", "O2优化"], "title": "「SWTR-3」Plane Mirrors", "background": "小 $\\mathrm{A}$ 在学物理。\n\n老师在讲“平面镜成像”这个物理现象。\n\n但老师讲课太无聊，所以他就睡着了。", "description": "小 $\\mathrm{A}$ 梦见自己站在了一个平台上，在他的周围有一些平面镜，我们假定他的位置为 $(0,0)$。\n\n他发现，每个平面镜都有一个初始不透明度，记做 $v_i$。\n\n下文中，我们定义：\n\n- 一个射线的“不透明度”为：该射线穿过的所有平面镜的初始不透明度之和。\n\n- 一个平面镜的“视觉不透明度”为：所有**从 $(0,0)$ 发出**且**经过该平面镜**的射线的不透明度最大值。\n\n小 $\\mathrm{A}$ 突然发现自己能够控制这些平面镜，于是就有了下面这道题目。\n\n小 $\\mathrm{A}$ 需要你完成以下操作：\n\n`1 x1 y1 x2 y2 v`：变出一个两端分别在 $(x_1,y_1),(x_2,y_2)$，初始不透明度为 $v$ 的平面镜。\n\n`2 d`：摧毁第 $d$ 个变出来的平面镜，保证未被摧毁。\n\n`3 x y`：设 $\\mathrm{A=(0,0),B=(x,y)}$，询问射线 $\\mathrm{AB}$ 的不透明度。\n\n`4 d`：询问第 $d$ 个平面镜的视觉不透明度，如已被摧毁则输出 `oops!`。", "inputFormat": "第一行，一个整数 $n$，表示操作次数。\n\n接下来 $n$ 行，第 $i$ 行先是一个整数 $opt$，然后：\n\n- 如果 $opt=1$，五个整数 $x_1,y_1,x_2,y_2,v$。\n\n- 如果 $opt=3$，两个整数 $x,y$。\n\n- 否则一个整数 $d$。", "outputFormat": "对于每一个 $3,4$ 询问，输出一行答案。", "hint": "---\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f7i3u2l6.png)\n\n如图，蓝色代表射线，红色代表平面镜。\n\n对于第 $1$ 次询问：可以看出射线只穿过了平面镜 $1$，答案为 $7$。\n\n对于第 $2$ 次询问：可以看出射线只穿过了平面镜 $2$，答案为 $10$。\n\n对于第 $3$ 次询问：可以看出射线穿过了平面镜 $1,2$，答案为 $7+10=17$。\n\n对于第 $4$ 次询问，可以看出射线穿过了平面镜 $3$，答案为 $17$。\n\n对于第 $5$ 次询问，可以看出穿过平面镜 $2$ 的不透明度最大的射线为 $(0,0)(2,2)$（射线不唯一），穿过了平面镜 $1,2$，答案为 $7+10=17$。\n\n对于第 $6$ 次询问，可以看出穿过平面镜 $2$ 的不透明度最大的射线为 $(0,0)(2,2)$（射线不唯一），穿过了平面镜 $2$，答案为 $10$。\n\n对于第 $7$ 次询问，因为平面镜 $1$ 已被摧毁，所以输出 `oops!`。\n\n---\n\n### 数据范围与约定\n\n测试点编号|$n\\leq$|特殊性质\n:-:|:-:|:-:\n$1-4$|$1000$|$x,y$ 绝对值小于 $10^3$ 且**没有 $4$ 询问**\n$5-8$|$2\\times 10^5$|所有 $y$ 相等\n$9-12$|$2\\times 10^5$|$x\\ge 0$\n$13-20$|$2\\times 10^5$|无\n\n对于 $100\\%$ 的数据，有 $1\\leq n\\leq 2\\times 10^5$，$1\\leq v\\leq 10^3$ 且 $0\\leq |x|,|y|\\leq 10^5$。\n\n保证平面镜的总数不会超过 $10^5$。\n\n保证所有平面镜不会穿过 $(0,0)$，但**不保证**平面镜会退化成一个点。\n\n保证所有 $3$ 询问 $(x,y)\\neq(0,0)$。\n\n---\n\n对于所有测试点，时间限制 $2\\mathrm{s}$，空间限制 $128\\mathrm{MB}$。", "locale": "zh-CN", "translations": {"en": {"title": "\"SWTR-3\" Plane Mirrors", "background": "Student $\\mathrm{A}$ is studying physics.\n\nThe teacher is explaining the physical phenomenon of “plane mirror imaging”.\n\nBut the lecture is too boring, so he falls asleep.", "description": "Student $\\mathrm{A}$ dreams that he is standing on a platform. Around him there are some plane mirrors, and we assume his position is $(0,0)$.\n\nHe finds that each plane mirror has an initial opacity, denoted by $v_i$.\n\nIn what follows, we define:\n\n- The “opacity” of a ray as: the sum of the initial opacities of all plane mirrors that the ray passes through.\n\n- The “visual opacity” of a plane mirror as: the maximum opacity among all rays that **originate from $(0,0)$** and **pass through that plane mirror**.\n\nStudent $\\mathrm{A}$ suddenly discovers that he can control these plane mirrors, so the following problem arises.\n\nStudent $\\mathrm{A}$ needs you to perform the following operations:\n\n`1 x1 y1 x2 y2 v`: Create a plane mirror whose two endpoints are at $(x_1,y_1),(x_2,y_2)$, with initial opacity $v$.\n\n`2 d`: Destroy the $d$-th created plane mirror. It is guaranteed that it has not been destroyed.\n\n`3 x y`: Let $\\mathrm{A=(0,0),B=(x,y)}$. Query the opacity of the ray $\\mathrm{AB}$.\n\n`4 d`: Query the visual opacity of the $d$-th plane mirror. If it has been destroyed, output `oops!`.", "inputFormat": "The first line contains an integer $n$, denoting the number of operations.\n\nThe next $n$ lines: the $i$-th line starts with an integer $opt$, and then:\n\n- If $opt=1$, five integers $x_1,y_1,x_2,y_2,v$.\n\n- If $opt=3$, two integers $x,y$.\n\n- Otherwise, one integer $d$.", "outputFormat": "For each query of type $3$ or $4$, output one line with the answer.", "hint": "---\n\n### Sample Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f7i3u2l6.png)\n\nAs shown in the figure, blue represents rays and red represents plane mirrors.\n\nFor the 1st query: we can see the ray only passes through plane mirror $1$, so the answer is $7$.\n\nFor the 2nd query: we can see the ray only passes through plane mirror $2$, so the answer is $10$.\n\nFor the 3rd query: we can see the ray passes through plane mirrors $1,2$, so the answer is $7+10=17$.\n\nFor the 4th query: we can see the ray passes through plane mirror $3$, so the answer is $17$.\n\nFor the 5th query: we can see that among rays passing through plane mirror $2$, the ray with the maximum opacity is $(0,0)(2,2)$ (the ray is not unique). It passes through plane mirrors $1,2$, so the answer is $7+10=17$.\n\nFor the 6th query: we can see that among rays passing through plane mirror $2$, the ray with the maximum opacity is $(0,0)(2,2)$ (the ray is not unique). It passes through plane mirror $2$, so the answer is $10$.\n\nFor the 7th query: since plane mirror $1$ has been destroyed, output `oops!`.\n\n---\n\n### Constraints and Notes\n\nTest point ID|$n\\leq$|Special property\n:-:|:-:|:-:\n$1-4$|$1000$|$|x|,|y|$ are less than $10^3$ and there are **no type $4$ queries**\n$5-8$|$2\\times 10^5$|all $y$ are equal\n$9-12$|$2\\times 10^5$|$x\\ge 0$\n$13-20$|$2\\times 10^5$|none\n\nFor $100\\%$ of the testdata, $1\\leq n\\leq 2\\times 10^5$, $1\\leq v\\leq 10^3$, and $0\\leq |x|,|y|\\leq 10^5$.\n\nIt is guaranteed that the total number of plane mirrors will not exceed $10^5$.\n\nIt is guaranteed that no plane mirror passes through $(0,0)$, but it is **not guaranteed** that a plane mirror will not degenerate into a point.\n\nIt is guaranteed that for all type $3$ queries, $(x,y)\\neq(0,0)$.\n\n---\n\nFor all test points, the time limit is $2\\mathrm{s}$ and the memory limit is $128\\mathrm{MB}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「SWTR-3」Plane Mirrors", "background": "小 $\\mathrm{A}$ 在学物理。\n\n老师在讲“平面镜成像”这个物理现象。\n\n但老师讲课太无聊，所以他就睡着了。", "description": "小 $\\mathrm{A}$ 梦见自己站在了一个平台上，在他的周围有一些平面镜，我们假定他的位置为 $(0,0)$。\n\n他发现，每个平面镜都有一个初始不透明度，记做 $v_i$。\n\n下文中，我们定义：\n\n- 一个射线的“不透明度”为：该射线穿过的所有平面镜的初始不透明度之和。\n\n- 一个平面镜的“视觉不透明度”为：所有**从 $(0,0)$ 发出**且**经过该平面镜**的射线的不透明度最大值。\n\n小 $\\mathrm{A}$ 突然发现自己能够控制这些平面镜，于是就有了下面这道题目。\n\n小 $\\mathrm{A}$ 需要你完成以下操作：\n\n`1 x1 y1 x2 y2 v`：变出一个两端分别在 $(x_1,y_1),(x_2,y_2)$，初始不透明度为 $v$ 的平面镜。\n\n`2 d`：摧毁第 $d$ 个变出来的平面镜，保证未被摧毁。\n\n`3 x y`：设 $\\mathrm{A=(0,0),B=(x,y)}$，询问射线 $\\mathrm{AB}$ 的不透明度。\n\n`4 d`：询问第 $d$ 个平面镜的视觉不透明度，如已被摧毁则输出 `oops!`。", "inputFormat": "第一行，一个整数 $n$，表示操作次数。\n\n接下来 $n$ 行，第 $i$ 行先是一个整数 $opt$，然后：\n\n- 如果 $opt=1$，五个整数 $x_1,y_1,x_2,y_2,v$。\n\n- 如果 $opt=3$，两个整数 $x,y$。\n\n- 否则一个整数 $d$。", "outputFormat": "对于每一个 $3,4$ 询问，输出一行答案。", "hint": "---\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f7i3u2l6.png)\n\n如图，蓝色代表射线，红色代表平面镜。\n\n对于第 $1$ 次询问：可以看出射线只穿过了平面镜 $1$，答案为 $7$。\n\n对于第 $2$ 次询问：可以看出射线只穿过了平面镜 $2$，答案为 $10$。\n\n对于第 $3$ 次询问：可以看出射线穿过了平面镜 $1,2$，答案为 $7+10=17$。\n\n对于第 $4$ 次询问，可以看出射线穿过了平面镜 $3$，答案为 $17$。\n\n对于第 $5$ 次询问，可以看出穿过平面镜 $2$ 的不透明度最大的射线为 $(0,0)(2,2)$（射线不唯一），穿过了平面镜 $1,2$，答案为 $7+10=17$。\n\n对于第 $6$ 次询问，可以看出穿过平面镜 $2$ 的不透明度最大的射线为 $(0,0)(2,2)$（射线不唯一），穿过了平面镜 $2$，答案为 $10$。\n\n对于第 $7$ 次询问，因为平面镜 $1$ 已被摧毁，所以输出 `oops!`。\n\n---\n\n### 数据范围与约定\n\n测试点编号|$n\\leq$|特殊性质\n:-:|:-:|:-:\n$1-4$|$1000$|$x,y$ 绝对值小于 $10^3$ 且**没有 $4$ 询问**\n$5-8$|$2\\times 10^5$|所有 $y$ 相等\n$9-12$|$2\\times 10^5$|$x\\ge 0$\n$13-20$|$2\\times 10^5$|无\n\n对于 $100\\%$ 的数据，有 $1\\leq n\\leq 2\\times 10^5$，$1\\leq v\\leq 10^3$ 且 $0\\leq |x|,|y|\\leq 10^5$。\n\n保证平面镜的总数不会超过 $10^5$。\n\n保证所有平面镜不会穿过 $(0,0)$，但**不保证**平面镜会退化成一个点。\n\n保证所有 $3$ 询问 $(x,y)\\neq(0,0)$。\n\n---\n\n对于所有测试点，时间限制 $2\\mathrm{s}$，空间限制 $128\\mathrm{MB}$。", "locale": "zh-CN"}}}
{"pid": "P5860", "type": "P", "difficulty": 7, "samples": [["3\n1 1 1\n", "3"], ["5\n1 2 1 3 1\n", "8"], ["8\n1 2 1 2 4 1 3 1\n", "44"], ["50\n8 1 10 2 2 1 2 1 1 2 5 1 11 6 13 13 10 4 1 13 11 2 2 11 13 10 1 1 4 3 4 2 15 2 2 1 1 2 1 7 14 2 2 4 13 2 7 5 6 10 ", "176873472"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 3000, 3000, 3000, 3000, 3000, 3000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "O2优化", "生成函数"], "title": "「SWTR-3」Counting Trees", "background": "一个风和日丽的早晨，小 $\\mathrm{S}$ 带着他的好朋友小 $\\mathrm{A}$ 在小树林里面数树。\n\n看着满树林的树，小 $\\mathrm{S}$ 灵感一闪，想到了一道题目。\n\n---\n\n$$\\mathrm{Suddenly,\\ Little\\ S\\ thought\\ of\\ a\\ supercalifragilisticexpialidocious\\ problem.}$$\n\n$$\\mathrm{He\\ wanted\\ Little\\ A\\ to\\ answer\\ it.}$$", "description": "现在有 $n$ 个点，每个点有一个权值 $v_i$。\n\n小 $\\mathrm{S}$ 想要小 $\\mathrm{A}$ 从中选一些点组成一个集合，设集合 $S=\\{d_1,d_2,\\dots,d_m\\}(1\\leq m\\leq n)$。\n\n当然，小 $\\mathrm{A}$ 还需要保证这些点能形成一颗树，且 $d_i$ 的度数为 $v_{d_i}(i\\in[1,m])$。\n\n- 节点的度数：与它相邻的节点的个数。\n\n小 $\\mathrm{S}$ 想问小 $\\mathrm{A}$ 有多少种满足条件的方案。\n\n小 $\\mathrm{A}$ 深知自己肯定不会这道题目，所以他就拿来问你了。\n\n由于方案数可能很大，所以请对 $998244353$ 取模。", "inputFormat": "第一行，一个整数 $n$。\n\n第二行，$n$ 个整数 $v_1,v_2,\\dots,v_n$", "outputFormat": "一行一个整数，表示方案数。", "hint": "---\n\n### 样例说明\n\n- 对于样例 $1$，在三个节点中任选两个即可，答案为 $C^{2}_{3}=3$。\n\n- 对于样例 $2$，如图，共有 $8$ 种选择节点的方法。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g0suqsi0.png)\n\n---\n\n### 数据范围与约定\n\n**本题使用捆绑测试。**\n\n| Subtask 编号 | $n\\leq$ | 特殊性质 | 得分 |\n| :-: | :-: | :-: | :-: |\n| $1$ | $20$ | 无 | $11$ |\n| $2$ | $50$ | 无 | $12$ |\n| $3$ | $300$ | 无 | $10$ |\n| $4$ | $2500$ | 无 | $17$ |\n| $5$ | $4\\times 10^4$ | 无 | $6$ |\n| $6$ | $3\\times 10^5$ | $v_i\\leq 3$ | $8$ |\n| $7$ | $3\\times 10^5$ | 数据随机 | $7$ |\n| $8$ | $5\\times 10^5$ | 无 | $29$ |\n\n对于 $100\\%$ 的数据，$2 \\leq n \\leq 5 \\times 10^5$，$\\ 1 \\leq v_i \\leq n$。\n\n---\n\n$\\mathrm{Subtask\\ 7}$ 中“数据随机”指：对于所有 $v_i$，$\\frac{1}{3}$ 的概率为 1，$\\frac{2}{3}$ 的概率为 $[2,n]$ 中等概率选择一个数。\n\n---\n\n对于前 $4$ 个 $\\mathrm{Subtask}$，时间限制 $1\\mathrm{s}$。\n\n对于第 $5$ 个 $\\mathrm{Subtask}$，时间限制 $3\\mathrm{s}$。\n\n对于后 $3$ 个 $\\mathrm{Subtask}$，时间限制 $6\\mathrm{s}$。\n\n对于所有测试点，空间限制 $256\\mathrm{MB}$。", "locale": "zh-CN", "translations": {"en": {"title": "“SWTR-3” Counting Trees", "background": "On a sunny morning, Little $\\mathrm{S}$ took his good friend Little $\\mathrm{A}$ to count trees in a small forest.\n\nLooking at the forest full of trees, Little $\\mathrm{S}$ suddenly got an idea and came up with a problem.\n\n---\n\n$$\\mathrm{Suddenly,\\ Little\\ S\\ thought\\ of\\ a\\ supercalifragilisticexpialidocious\\ problem.}$$\n\n$$\\mathrm{He\\ wanted\\ Little\\ A\\ to\\ answer\\ it.}$$", "description": "There are $n$ vertices, and each vertex has a weight $v_i$.\n\nLittle $\\mathrm{S}$ wants Little $\\mathrm{A}$ to choose some vertices to form a set. Let the set be $S=\\{d_1,d_2,\\dots,d_m\\}(1\\leq m\\leq n)$.\n\nOf course, Little $\\mathrm{A}$ also needs to ensure that these vertices can form a tree, and the degree of $d_i$ is $v_{d_i}(i\\in[1,m])$.\n\n- Degree of a vertex: the number of vertices adjacent to it.\n\nLittle $\\mathrm{S}$ asks Little $\\mathrm{A}$ how many ways there are that satisfy the conditions.\n\nLittle $\\mathrm{A}$ knows he definitely cannot solve this problem, so he asks you for help.\n\nSince the number of ways may be very large, output it modulo $998244353$.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n$ integers $v_1,v_2,\\dots,v_n$.", "outputFormat": "Output one integer in one line, representing the number of valid ways.", "hint": "---\n\n### Sample Explanation\n\n- For sample $1$, it is enough to choose any two vertices among the three vertices. The answer is $C^{2}_{3}=3$.\n\n- For sample $2$, as shown in the figure, there are $8$ ways to choose vertices.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g0suqsi0.png)\n\n---\n\n### Constraints and Notes\n\n**This problem uses bundled testdata.**\n\n| Subtask ID | $n\\leq$ | Special Property | Score |\n| :-: | :-: | :-: | :-: |\n| $1$ | $20$ | None | $11$ |\n| $2$ | $50$ | None | $12$ |\n| $3$ | $300$ | None | $10$ |\n| $4$ | $2500$ | None | $17$ |\n| $5$ | $4\\times 10^4$ | None | $6$ |\n| $6$ | $3\\times 10^5$ | $v_i\\leq 3$ | $8$ |\n| $7$ | $3\\times 10^5$ | Random testdata | $7$ |\n| $8$ | $5\\times 10^5$ | None | $29$ |\n\nFor $100\\%$ of the testdata, $2 \\leq n \\leq 5 \\times 10^5$ and $\\ 1 \\leq v_i \\leq n$.\n\n---\n\nIn $\\mathrm{Subtask\\ 7}$, “random testdata” means: for every $v_i$, it equals $1$ with probability $\\frac{1}{3}$, and with probability $\\frac{2}{3}$ it is chosen uniformly at random from $[2,n]$.\n\n---\n\nFor the first $4$ $\\mathrm{Subtask}$s, the time limit is $1\\mathrm{s}$.\n\nFor the $5$th $\\mathrm{Subtask}$, the time limit is $3\\mathrm{s}$.\n\nFor the last $3$ $\\mathrm{Subtask}$s, the time limit is $6\\mathrm{s}$.\n\nFor all test points, the memory limit is $256\\mathrm{MB}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「SWTR-3」Counting Trees", "background": "一个风和日丽的早晨，小 $\\mathrm{S}$ 带着他的好朋友小 $\\mathrm{A}$ 在小树林里面数树。\n\n看着满树林的树，小 $\\mathrm{S}$ 灵感一闪，想到了一道题目。\n\n---\n\n$$\\mathrm{Suddenly,\\ Little\\ S\\ thought\\ of\\ a\\ supercalifragilisticexpialidocious\\ problem.}$$\n\n$$\\mathrm{He\\ wanted\\ Little\\ A\\ to\\ answer\\ it.}$$", "description": "现在有 $n$ 个点，每个点有一个权值 $v_i$。\n\n小 $\\mathrm{S}$ 想要小 $\\mathrm{A}$ 从中选一些点组成一个集合，设集合 $S=\\{d_1,d_2,\\dots,d_m\\}(1\\leq m\\leq n)$。\n\n当然，小 $\\mathrm{A}$ 还需要保证这些点能形成一颗树，且 $d_i$ 的度数为 $v_{d_i}(i\\in[1,m])$。\n\n- 节点的度数：与它相邻的节点的个数。\n\n小 $\\mathrm{S}$ 想问小 $\\mathrm{A}$ 有多少种满足条件的方案。\n\n小 $\\mathrm{A}$ 深知自己肯定不会这道题目，所以他就拿来问你了。\n\n由于方案数可能很大，所以请对 $998244353$ 取模。", "inputFormat": "第一行，一个整数 $n$。\n\n第二行，$n$ 个整数 $v_1,v_2,\\dots,v_n$", "outputFormat": "一行一个整数，表示方案数。", "hint": "---\n\n### 样例说明\n\n- 对于样例 $1$，在三个节点中任选两个即可，答案为 $C^{2}_{3}=3$。\n\n- 对于样例 $2$，如图，共有 $8$ 种选择节点的方法。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g0suqsi0.png)\n\n---\n\n### 数据范围与约定\n\n**本题使用捆绑测试。**\n\n| Subtask 编号 | $n\\leq$ | 特殊性质 | 得分 |\n| :-: | :-: | :-: | :-: |\n| $1$ | $20$ | 无 | $11$ |\n| $2$ | $50$ | 无 | $12$ |\n| $3$ | $300$ | 无 | $10$ |\n| $4$ | $2500$ | 无 | $17$ |\n| $5$ | $4\\times 10^4$ | 无 | $6$ |\n| $6$ | $3\\times 10^5$ | $v_i\\leq 3$ | $8$ |\n| $7$ | $3\\times 10^5$ | 数据随机 | $7$ |\n| $8$ | $5\\times 10^5$ | 无 | $29$ |\n\n对于 $100\\%$ 的数据，$2 \\leq n \\leq 5 \\times 10^5$，$\\ 1 \\leq v_i \\leq n$。\n\n---\n\n$\\mathrm{Subtask\\ 7}$ 中“数据随机”指：对于所有 $v_i$，$\\frac{1}{3}$ 的概率为 1，$\\frac{2}{3}$ 的概率为 $[2,n]$ 中等概率选择一个数。\n\n---\n\n对于前 $4$ 个 $\\mathrm{Subtask}$，时间限制 $1\\mathrm{s}$。\n\n对于第 $5$ 个 $\\mathrm{Subtask}$，时间限制 $3\\mathrm{s}$。\n\n对于后 $3$ 个 $\\mathrm{Subtask}$，时间限制 $6\\mathrm{s}$。\n\n对于所有测试点，空间限制 $256\\mathrm{MB}$。", "locale": "zh-CN"}}}
{"pid": "P5861", "type": "P", "difficulty": 7, "samples": [["4\n2 4\n1 2\n2 3\n2 3\n2\n2 1 3\n2 1 1\n", "1\n0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "IOI"], "title": "[IOI 2015] teams", "background": "", "description": "班里有 $N$ 个学生,他们的编号为从 $0$ 到 $N-1$。每天，老师都有一些项目需要学生去完成。每个项目都需要由一组学生在一天内完成。项目的难度可能不同。对于每个项目，老师知道应该选择由多少学生组成的小组去完成。\n\n不同的学生对小组的规模有不同的喜好。更准确地说, 对学生 $i$ 而言, 他只愿意在小组规模介于 $A[i]$ 和 $B[i]$ 之间（含 $A[i]$ 和 $B[i]$）的小组工作。每一天，一个学生最多只能被分配到一个小组工作。有些学生可能未被分配到任何小组中。每个小组只负责一个项目。\n\n老师已选择好接下来 $Q$ 天中每一天的项目。对于每一天, 现需要判断是否有一种分配学生的方案，使得每个项目都有一个小组负责。", "inputFormat": "- 第 $1$ 行有一个正整数 $N$，表示班内学生的数量；\n- 第 $2$ 到 $N+1$ 行有两个 $A[i]$，$B[i]$；\n- 第 $N+2$ 行有一个正整数 $Q$；\n- 第 $N+3$ 到 $N+Q+2$ 行，包含一个正整数 $M$，表示当天要完成的项目数， 后有一个长度为 $M$ 的序列 $K$。$K[i]$ （$1\\le i\\le M$） 表示项目 $i$ 所需的小组规模。", "outputFormat": "共 $Q$ 行，对于每一个问题, 你的程序必须输出是否存在一种小组分配的方案，可以完成当天的所有项目。若可以完成分组去完成当天所有的项目，输出 `1`, 否则，应输出 `0`。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 5 \\times 10^5$，$1\\le Q\\le 2 \\times 10^5$， $\\sum M \\leq 2\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2015] teams", "background": "", "description": "There are $N$ students in the class, numbered from $0$ to $N-1$. Every day, the teacher has some projects that need to be completed by students. Each project must be completed within one day by a team of students. The projects may have different difficulty levels. For each project, the teacher knows how many students should be chosen to form a team to complete it.\n\nDifferent students have different preferences for team size. More precisely, for student $i$, they are only willing to work in a team whose size is between $A[i]$ and $B[i]$ (including $A[i]$ and $B[i]$). Each day, a student can be assigned to at most one team. Some students may not be assigned to any team. Each team is responsible for exactly one project.\n\nThe teacher has already selected the projects for each of the next $Q$ days. For each day, you need to determine whether there exists an assignment of students such that every project has a team responsible for it.", "inputFormat": "- Line $1$ contains a positive integer $N$, the number of students in the class.\n- Lines $2$ to $N+1$ each contain two integers $A[i]$, $B[i]$.\n- Line $N+2$ contains a positive integer $Q$.\n- Lines $N+3$ to $N+Q+2$ each contain a positive integer $M$, the number of projects to be completed that day, followed by a sequence $K$ of length $M$. $K[i]$ ($1 \\le i \\le M$) denotes the required team size for project $i$.", "outputFormat": "Output $Q$ lines. For each query, your program must output whether there exists a team assignment plan that can complete all projects of that day. If it is possible to form teams to complete all projects for that day, output `1`; otherwise, output `0`.", "hint": "For $100\\%$ of the testdata, $1 \\le N \\le 5 \\times 10^5$, $1 \\le Q \\le 2 \\times 10^5$, $\\sum M \\leq 2 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2015] teams", "background": "", "description": "班里有 $N$ 个学生,他们的编号为从 $0$ 到 $N-1$。每天，老师都有一些项目需要学生去完成。每个项目都需要由一组学生在一天内完成。项目的难度可能不同。对于每个项目，老师知道应该选择由多少学生组成的小组去完成。\n\n不同的学生对小组的规模有不同的喜好。更准确地说, 对学生 $i$ 而言, 他只愿意在小组规模介于 $A[i]$ 和 $B[i]$ 之间（含 $A[i]$ 和 $B[i]$）的小组工作。每一天，一个学生最多只能被分配到一个小组工作。有些学生可能未被分配到任何小组中。每个小组只负责一个项目。\n\n老师已选择好接下来 $Q$ 天中每一天的项目。对于每一天, 现需要判断是否有一种分配学生的方案，使得每个项目都有一个小组负责。", "inputFormat": "- 第 $1$ 行有一个正整数 $N$，表示班内学生的数量；\n- 第 $2$ 到 $N+1$ 行有两个 $A[i]$，$B[i]$；\n- 第 $N+2$ 行有一个正整数 $Q$；\n- 第 $N+3$ 到 $N+Q+2$ 行，包含一个正整数 $M$，表示当天要完成的项目数， 后有一个长度为 $M$ 的序列 $K$。$K[i]$ （$1\\le i\\le M$） 表示项目 $i$ 所需的小组规模。", "outputFormat": "共 $Q$ 行，对于每一个问题, 你的程序必须输出是否存在一种小组分配的方案，可以完成当天的所有项目。若可以完成分组去完成当天所有的项目，输出 `1`, 否则，应输出 `0`。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 5 \\times 10^5$，$1\\le Q\\le 2 \\times 10^5$， $\\sum M \\leq 2\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5862", "type": "P", "difficulty": 6, "samples": [["5\n4 3 2 1 0\n6\n0 1\n1 2\n2 3\n3 4\n0 1\n1 2\n", "3\n0 4\n1 3\n3 4"], ["5\n3 0 4 2 1\n5\n1 1\n4 0\n2 3\n1 4\n0 4\n", "3\n1 4\n4 2\n2 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "IOI", "Special Judge"], "title": "[IOI 2015] sorting", "background": "", "description": "Aizhan 有一个由 $N$ 个互不相同的整数组成的序列 $S[0],S[1],\\cdots,S[N-1]$，其中 $S[i]$ 取值范围是 $[0,N-1]$。Aizhan 试图通过交换某些元素对的方法将这个序列按照升序排序。Aizhan 的朋友 Ermek 也想交换某些元素对， Ermek 的交换未必有助于 Aizhan 的排序。\n\nErmek 和 Aizhan 打算通过若干轮次来修改这个序列。在每一轮，Ermek 首先做一次交换，然后 Aizhan 做另一次交换。更确切地说，做交换的人选择两个有效的下标并交换这两个下标的元素。请注意这两个下标可能相同。如果它们相等，则对这个元素自身做交换，并不改变这个序列。\n\nAizhan 知道 Ermek 并不关心对序列 \n$S$ 排序的事情。Aizhan还知道 Ermek 将会选择哪些下标。Ermek 打算参加 $M$ 轮交换，将这些轮次从 $0$ 到 $M-1$ 编号。对于 $0$ 到 $M-1$ 之间的每个 $i$，Ermek 在第 $i$ 轮将选择下标 $X[i]$ 和 $Y[i]$ 的元素进行交换。\n\nAizhan 要对序列 $S$ 按升序进行排序。在每一轮之前，如果 Aizhan 看到当前的序列已经按升序排列，她将结束这个排序过程。给定初始序列 $S$ 以及 Ermek 要选择的下标，请你找出一个交换的序列，使得 Aizhan 能完成对序列 $S$ 的排序。此外，在有些子任务中，你还要找出尽可能短的交换序列来完成排序任务。题目保证通过 $M$ 或更少的轮次能够将序列 $S$ 排好序。\n\n请注意如果 Aizhan 发现在 Ermek 的交换之后，序列 $S$ 已经排好序，则 Aizhan 可以选择交换两个相同下标（例如 $0$ 和 $0$）的元素。这样，序列 $S$ 在这一轮次之后也完成排序，于是也达到了 Aizhan 的目标。另外，如果初始序列 $S$ 就已经排好序，那么所需的最少排序轮数就是 $0$。", "inputFormat": "- 第 $1$ 行有一个正整数 $N$，表示序列 $S$ 的长度；\n- 第 $2$ 行有 $N$ 个正整数，分别为 $S[0],\\cdots,S[N-1]$，即初始序列 $S$；\n- 第 $3$ 行有一个正整数 $M$，表示 Ermek 打算做交换的次数；\n- 第 $4$ 到 $M+3$ 行，有两个正整数 $X[i]$，$Y[i]$，表示对于 $0\\le i\\le M-1$, 在第 $i$ 轮 Ermek 打算交换下标为 $X[i]$ 和 $Y[i]$ 的数组。", "outputFormat": "- 第 $1$ 行 : 交换的长度 $R$；\n- 第 $2+i$（$0\\le i < R$）行：$P[i]$，$Q[i]$。\n\n注：$P$，$Q$分别为两个整数数组。利用这两个数组报告 Aizhan 完成对序列 $S$ 排序的一种可能的交换序列，假设这个交换序列的长度为 $R$，对于 $0$ 到 $R-1$ 之间的每个 $i$，Aizhan 在轮次 $i$ 选择的下标将被存入 $P[i]$ 和 $Q[i]$。 你可以假设数组 $P$ 和 $Q$ 均已分别被分配了 \n$M$ 个元素。", "hint": "对于 $100\\%$ 的数据，$1 \\le N\\le 2 \\times 10^5$，$1 \\le M \\le 6 \\times 10^5$。要求 $R$ 取最小值。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2015] sorting", "background": "", "description": "Aizhan has a sequence $S[0],S[1],\\cdots,S[N-1]$ consisting of $N$ distinct integers, where $S[i]$ is in the range $[0,N-1]$. Aizhan tries to sort this sequence in increasing order by swapping some pairs of elements. Aizhan’s friend Ermek also wants to swap some pairs of elements, and Ermek’s swaps may not help Aizhan sort the sequence.\n\nErmek and Aizhan plan to modify this sequence through several rounds. In each round, Ermek makes one swap first, and then Aizhan makes another swap. More precisely, the person who performs a swap chooses two valid indices and swaps the elements at those indices. Note that the two indices may be the same. If they are equal, it is a swap of an element with itself and does not change the sequence.\n\nAizhan knows that Ermek does not care about sorting the sequence $S$. She also knows which indices Ermek will choose. Ermek plans to take part in $M$ rounds of swaps, numbered from $0$ to $M-1$. For each $i$ between $0$ and $M-1$, in round $i$, Ermek will swap the elements at indices $X[i]$ and $Y[i]$.\n\nAizhan wants to sort the sequence $S$ in increasing order. Before each round, if Aizhan sees that the current sequence is already sorted in increasing order, she will stop the sorting process. Given the initial sequence $S$ and the indices Ermek will choose, you need to find a sequence of swaps so that Aizhan can finish sorting $S$. In addition, in some subtasks, you also need to find a swap sequence that is as short as possible. The problem guarantees that $S$ can be sorted in $M$ or fewer rounds.\n\nNote that if Aizhan finds that after Ermek’s swap, the sequence $S$ is already sorted, then Aizhan may choose to swap two identical indices (for example $0$ and $0$). This way, $S$ is still sorted after this round, and Aizhan’s goal is achieved. Also, if the initial sequence $S$ is already sorted, then the minimum number of sorting rounds needed is $0$.", "inputFormat": "- Line $1$ contains a positive integer $N$, the length of the sequence $S$.\n- Line $2$ contains $N$ positive integers $S[0],\\cdots,S[N-1]$, the initial sequence $S$.\n- Line $3$ contains a positive integer $M$, the number of swaps Ermek plans to perform.\n- Lines $4$ to $M+3$ each contain two positive integers $X[i]$, $Y[i]$, meaning that for $0\\le i\\le M-1$, in round $i$, Ermek plans to swap the elements at indices $X[i]$ and $Y[i]$.", "outputFormat": "- Line $1$: the length of the swap sequence $R$.\n- Line $2+i$ ($0\\le i < R$): $P[i]$, $Q[i]$.\n\nNote: $P$ and $Q$ are two integer arrays. Use these two arrays to report one possible swap sequence with which Aizhan can finish sorting $S$. Suppose the length of this swap sequence is $R$. For each $i$ from $0$ to $R-1$, the indices Aizhan chooses in round $i$ will be stored in $P[i]$ and $Q[i]$. You may assume that arrays $P$ and $Q$ have each been allocated $M$ elements.", "hint": "For $100\\%$ of the testdata, $1 \\le N\\le 2 \\times 10^5$, $1 \\le M \\le 6 \\times 10^5$. It is required that $R$ be minimized.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2015] sorting", "background": "", "description": "Aizhan 有一个由 $N$ 个互不相同的整数组成的序列 $S[0],S[1],\\cdots,S[N-1]$，其中 $S[i]$ 取值范围是 $[0,N-1]$。Aizhan 试图通过交换某些元素对的方法将这个序列按照升序排序。Aizhan 的朋友 Ermek 也想交换某些元素对， Ermek 的交换未必有助于 Aizhan 的排序。\n\nErmek 和 Aizhan 打算通过若干轮次来修改这个序列。在每一轮，Ermek 首先做一次交换，然后 Aizhan 做另一次交换。更确切地说，做交换的人选择两个有效的下标并交换这两个下标的元素。请注意这两个下标可能相同。如果它们相等，则对这个元素自身做交换，并不改变这个序列。\n\nAizhan 知道 Ermek 并不关心对序列 \n$S$ 排序的事情。Aizhan还知道 Ermek 将会选择哪些下标。Ermek 打算参加 $M$ 轮交换，将这些轮次从 $0$ 到 $M-1$ 编号。对于 $0$ 到 $M-1$ 之间的每个 $i$，Ermek 在第 $i$ 轮将选择下标 $X[i]$ 和 $Y[i]$ 的元素进行交换。\n\nAizhan 要对序列 $S$ 按升序进行排序。在每一轮之前，如果 Aizhan 看到当前的序列已经按升序排列，她将结束这个排序过程。给定初始序列 $S$ 以及 Ermek 要选择的下标，请你找出一个交换的序列，使得 Aizhan 能完成对序列 $S$ 的排序。此外，在有些子任务中，你还要找出尽可能短的交换序列来完成排序任务。题目保证通过 $M$ 或更少的轮次能够将序列 $S$ 排好序。\n\n请注意如果 Aizhan 发现在 Ermek 的交换之后，序列 $S$ 已经排好序，则 Aizhan 可以选择交换两个相同下标（例如 $0$ 和 $0$）的元素。这样，序列 $S$ 在这一轮次之后也完成排序，于是也达到了 Aizhan 的目标。另外，如果初始序列 $S$ 就已经排好序，那么所需的最少排序轮数就是 $0$。", "inputFormat": "- 第 $1$ 行有一个正整数 $N$，表示序列 $S$ 的长度；\n- 第 $2$ 行有 $N$ 个正整数，分别为 $S[0],\\cdots,S[N-1]$，即初始序列 $S$；\n- 第 $3$ 行有一个正整数 $M$，表示 Ermek 打算做交换的次数；\n- 第 $4$ 到 $M+3$ 行，有两个正整数 $X[i]$，$Y[i]$，表示对于 $0\\le i\\le M-1$, 在第 $i$ 轮 Ermek 打算交换下标为 $X[i]$ 和 $Y[i]$ 的数组。", "outputFormat": "- 第 $1$ 行 : 交换的长度 $R$；\n- 第 $2+i$（$0\\le i < R$）行：$P[i]$，$Q[i]$。\n\n注：$P$，$Q$分别为两个整数数组。利用这两个数组报告 Aizhan 完成对序列 $S$ 排序的一种可能的交换序列，假设这个交换序列的长度为 $R$，对于 $0$ 到 $R-1$ 之间的每个 $i$，Aizhan 在轮次 $i$ 选择的下标将被存入 $P[i]$ 和 $Q[i]$。 你可以假设数组 $P$ 和 $Q$ 均已分别被分配了 \n$M$ 个元素。", "hint": "对于 $100\\%$ 的数据，$1 \\le N\\le 2 \\times 10^5$，$1 \\le M \\le 6 \\times 10^5$。要求 $R$ 取最小值。", "locale": "zh-CN"}}}
{"pid": "P5863", "type": "P", "difficulty": 5, "samples": [["156", "4"], ["9524", "4"], ["42657", "6"], ["5735832847451", "28"]], "limits": {"time": [300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "枚举", "ICPC", "分类讨论", "SEERC"], "title": "[SEERC 2018] Numbers", "background": "", "description": "一个回文数是一个正着写和倒着写得到的数字相等的整数。例如，数字 $142241$ 和数字 $102201$ 都是回文数，但数字 $1023401$ 和 $10510$ 不是。你想将一个数字 $n$ 分解成两个回文数之和的形式，请计算分解成上述形式的方案数。", "inputFormat": "仅一行包含一个整数 $n \\ (1 \\leq n \\leq 10^{18})$。", "outputFormat": "输出一个整数，代表将 $n$ 分解为两个回文数之和的方案数。", "hint": "第一个样例中，有下列分解方法：$(5, 151), (55, 101), (101, 55), (151, 5)$。\n\n第二个样例中，有下列分解方法：$(515, 9009), (636, 8888), (8888, 636), (9009, 515)$。\n\n第三个样例中，有下列分解方法：$(33, 42624), (333, 42324), (4884, 37773), (37773, 4884), (42324, 333), (42624, 33)$。", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Numbers", "background": "", "description": "A palindromic number is an integer that reads the same when written normally and when written in reverse. For example, the numbers $142241$ and $102201$ are palindromic, but the numbers $1023401$ and $10510$ are not. You want to decompose a number $n$ into a sum of two palindromic numbers. Please compute the number of ways to decompose it in this form.", "inputFormat": "Only one line contains an integer $n \\ (1 \\leq n \\leq 10^{18})$.", "outputFormat": "Output an integer representing the number of ways to decompose $n$ as the sum of two palindromic numbers.", "hint": "In the first sample, the decompositions are: $(5, 151), (55, 101), (101, 55), (151, 5)$.\n\nIn the second sample, the decompositions are: $(515, 9009), (636, 8888), (8888, 636), (9009, 515)$.\n\nIn the third sample, the decompositions are: $(33, 42624), (333, 42324), (4884, 37773), (37773, 4884), (42324, 333), (42624, 33)$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Numbers", "background": "", "description": "一个回文数是一个正着写和倒着写得到的数字相等的整数。例如，数字 $142241$ 和数字 $102201$ 都是回文数，但数字 $1023401$ 和 $10510$ 不是。你想将一个数字 $n$ 分解成两个回文数之和的形式，请计算分解成上述形式的方案数。", "inputFormat": "仅一行包含一个整数 $n \\ (1 \\leq n \\leq 10^{18})$。", "outputFormat": "输出一个整数，代表将 $n$ 分解为两个回文数之和的方案数。", "hint": "第一个样例中，有下列分解方法：$(5, 151), (55, 101), (101, 55), (151, 5)$。\n\n第二个样例中，有下列分解方法：$(515, 9009), (636, 8888), (8888, 636), (9009, 515)$。\n\n第三个样例中，有下列分解方法：$(33, 42624), (333, 42324), (4884, 37773), (37773, 4884), (42324, 333), (42624, 33)$。", "locale": "zh-CN"}}}
{"pid": "P5864", "type": "P", "difficulty": 4, "samples": [["15000 15000 15000 2", "0"], ["5000 10000 15000 3", "6"], ["15000 15000 15000 3", "1"], ["15000 15000 15000 4", "4"], ["15000 15000 15000 5", "5"], ["15000 15000 15000 6", "14"]], "limits": {"time": [200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "ICPC", "SEERC"], "title": "[SEERC 2018] Broken Watch", "background": "", "description": "一架 UFO 坠毁在地球上。外星人船长幸免于难，但他的手表没能逃过这一劫。\n\n外星人的手表和人类的手表非常相似：手表有一个直径为 $\\text{30 mm}$ 的表盘，有三个表针，长度分别为 $A, B$ 和 $C \\ (1000 \\leq A, B, C \\leq 15000)$ 微米。然而，外星人有不同的时间单位：$1$ 分钟里有 $N \\ (2 \\leq N < 2^{32})$ 秒。因此，表盘的边缘上有 $N$ 个刻度而不是 $60$ 个。\n\n手表的玻璃面板已经摔碎，表针也松了：它们可以独立地自由旋转。让三个表针分别指向任意刻度，以表针的尖端的顶点可以构成一个三角形（表针不共线的前提下）。\n\n在救援来之前外星人闲着没事干，就思考起了这样一个问题：按上述方法构成的三角形中，有多少个三角形包含了表盘的中心（答案记为 $M$）。（表盘中心在三角形的某一边上的三角形也要统计。）", "inputFormat": "仅一行包含整数 $A, B, C$ 和 $N$，四个数字之间用一个半角空格隔开。", "outputFormat": "输出 $M \\bmod 2^{64}$ 的值。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Broken Watch", "background": "", "description": "A UFO crashed on Earth. The alien captain survived, but his watch did not.\n\nThe alien watch is very similar to a human watch: it has a dial with a diameter of $\\text{30 mm}$, and three hands with lengths $A$, $B$, and $C$ $(1000 \\leq A, B, C \\leq 15000)$ micrometers. However, aliens use different time units: one minute has $N$ seconds $(2 \\leq N < 2^{32})$. Therefore, there are $N$ tick marks on the rim of the dial instead of $60$.\n\nThe glass panel of the watch is broken, and the hands are loose: they can rotate freely and independently. Let the three hands point to any tick marks. Then the tips of the three hands can form a triangle (assuming the three hands are not collinear).\n\nBefore rescue arrives, the alien has nothing to do and thinks about the following problem: among all triangles formed in the way described above, how many triangles contain the center of the dial (denote the answer by $M$)? (Triangles where the center lies on one side of the triangle should also be counted.)", "inputFormat": "A single line contains integers $A$, $B$, $C$, and $N$, separated by one space.", "outputFormat": "Output the value of $M \\bmod 2^{64}$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Broken Watch", "background": "", "description": "一架 UFO 坠毁在地球上。外星人船长幸免于难，但他的手表没能逃过这一劫。\n\n外星人的手表和人类的手表非常相似：手表有一个直径为 $\\text{30 mm}$ 的表盘，有三个表针，长度分别为 $A, B$ 和 $C \\ (1000 \\leq A, B, C \\leq 15000)$ 微米。然而，外星人有不同的时间单位：$1$ 分钟里有 $N \\ (2 \\leq N < 2^{32})$ 秒。因此，表盘的边缘上有 $N$ 个刻度而不是 $60$ 个。\n\n手表的玻璃面板已经摔碎，表针也松了：它们可以独立地自由旋转。让三个表针分别指向任意刻度，以表针的尖端的顶点可以构成一个三角形（表针不共线的前提下）。\n\n在救援来之前外星人闲着没事干，就思考起了这样一个问题：按上述方法构成的三角形中，有多少个三角形包含了表盘的中心（答案记为 $M$）。（表盘中心在三角形的某一边上的三角形也要统计。）", "inputFormat": "仅一行包含整数 $A, B, C$ 和 $N$，四个数字之间用一个半角空格隔开。", "outputFormat": "输出 $M \\bmod 2^{64}$ 的值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5865", "type": "P", "difficulty": 3, "samples": [["6 3\n1 1 0 1 1 1\n1 2\n1 3\n1 4\n3 5\n3 6", "2"], ["9 4\n1 0 1 0 1 0 0 1 1\n1 2\n2 4\n2 3\n4 5\n1 6\n6 7\n6 8\n7 9", "5"]], "limits": {"time": [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "枚举", "ICPC", "SEERC"], "title": "[SEERC 2018] Tree", "background": "", "description": "给定一棵 $n$ 个点的树，点的编号从 $1$ 到 $n$。每个点有黑色或白色的颜色。选出恰好 $m$ 个黑点，使得黑点两两之间的距离的最大值最小。输出这个最小的最大值。", "inputFormat": "第一行包含两个整数 $n$ 和 $m \\ (1 \\leq m \\leq n \\leq 100)$，代表树的点数和要选出的黑点数量。\n\n第二行包含 $n$ 个整数 $p_1, p_2, \\dots, p_n \\ (0 \\leq p_i \\leq 1)$。如果 $p_i=1$ 则点 $i$ 是黑色的，否则是白色的。数据保证黑点有不少于 $m$ 个。\n\n接下来 $n-1$ 行每行包含两个整数 $v_i$ 和 $u_i \\ (1 \\leq v_i, u_i, \\leq n)$，代表树上有一条连接点 $v_i$ 和 $u_i$ 的边。数据保证这些边构成一棵树。", "outputFormat": "输出一个整数，代表答案。", "hint": "第一个样例中，唯一的选法是选点 $1, 2$ 和 $4$，距离的最大值为 $2$。\n\n第二个样例中，可行的一种选法是选点 $1, 3, 8$ 和 $9$，最大的距离是点 $3$ 和 $9$ 的距离。", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Tree", "background": "", "description": "You are given a tree with $n$ vertices, numbered from $1$ to $n$. Each vertex is colored either black or white. Select exactly $m$ black vertices so that the maximum distance among all pairs of selected black vertices is minimized. Output this minimal possible maximum distance.", "inputFormat": "The first line contains two integers $n$ and $m \\ (1 \\leq m \\leq n \\leq 100)$, representing the number of vertices in the tree and the number of black vertices to be selected.\n\nThe second line contains $n$ integers $p_1, p_2, \\dots, p_n \\ (0 \\leq p_i \\leq 1)$. If $p_i = 1$, then vertex $i$ is black; otherwise it is white. The testdata guarantees that there are at least $m$ black vertices.\n\nThe next $n - 1$ lines each contain two integers $v_i$ and $u_i \\ (1 \\leq v_i, u_i \\leq n)$, indicating that there is an edge between vertices $v_i$ and $u_i$ in the tree. The testdata guarantees that these edges form a tree.", "outputFormat": "Output one integer, which is the answer.", "hint": "In the first sample, the only possible choice is to select vertices $1$, $2$, and $4$, and the maximum distance is $2$.\n\nIn the second sample, one feasible choice is to select vertices $1$, $3$, $8$, and $9$. The maximum distance is the distance between vertices $3$ and $9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Tree", "background": "", "description": "给定一棵 $n$ 个点的树，点的编号从 $1$ 到 $n$。每个点有黑色或白色的颜色。选出恰好 $m$ 个黑点，使得黑点两两之间的距离的最大值最小。输出这个最小的最大值。", "inputFormat": "第一行包含两个整数 $n$ 和 $m \\ (1 \\leq m \\leq n \\leq 100)$，代表树的点数和要选出的黑点数量。\n\n第二行包含 $n$ 个整数 $p_1, p_2, \\dots, p_n \\ (0 \\leq p_i \\leq 1)$。如果 $p_i=1$ 则点 $i$ 是黑色的，否则是白色的。数据保证黑点有不少于 $m$ 个。\n\n接下来 $n-1$ 行每行包含两个整数 $v_i$ 和 $u_i \\ (1 \\leq v_i, u_i, \\leq n)$，代表树上有一条连接点 $v_i$ 和 $u_i$ 的边。数据保证这些边构成一棵树。", "outputFormat": "输出一个整数，代表答案。", "hint": "第一个样例中，唯一的选法是选点 $1, 2$ 和 $4$，距离的最大值为 $2$。\n\n第二个样例中，可行的一种选法是选点 $1, 3, 8$ 和 $9$，最大的距离是点 $3$ 和 $9$ 的距离。", "locale": "zh-CN"}}}
{"pid": "P5866", "type": "P", "difficulty": 4, "samples": [["2\n5 2 4\n1 2 2\n2 3 2\n1 4 2\n4 5 2\n7 2 0\n1 2 1\n1 3 5\n2 4 10\n2 5 1\n5 6 10\n5 7 5", "12\n33"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "树形 DP", "ICPC", "SEERC"], "title": "[SEERC 2018] Space Station", "background": "", "description": "Jones 实现了他的梦想：他加入了国际空间站（ISS）的一次任务。他接受了他的第一个任务：检查空间站上的电子设备的工作状况。\n\nISS 被分为 $N$ 个模块，模块从 $1$ 到 $N$ 编号。Jones 发现，为了提高效率，空间站的设计使任意两个模块之间仅存在一条简单路径。在一次太阳耀斑活动中，连接两个模块的双向通道很容易受到辐射影响。检查一条通道 $i$ 的状况必须花费 $C_i$ 的时间。Jones 需要找到一条从模块 $1$ 出发，经过每条通道至少一次，再回到模块 $1$ 的最快路径。\n\n除了从模块之间的通道中通过之外，Jones 还可以穿上宇航服，跳出空间站，从外面直接从某一模块移动到任意模块上，但是这种方法只能进行最多 $M$ 次。Jones 假设进行一次需要花费固定的时间 $K$。", "inputFormat": "第一行包含一个整数 $T$，代表测试组数。\n\n每个测试组中，第一行包含三个整数 $N, M, K \\ (1 \\leq N, M \\leq 1000)$，接下来 $N-1$ 行每一行包含三个整数 $A, B, C \\ (1 \\leq A \\leq B \\leq N; 0 \\leq C,K \\leq 10^6)$，代表在模块 $A$ 和 $B$ 之间有一条通道，检查它需要花费 $C$ 时间。", "outputFormat": "对于每一组测试数据，输出一行答案。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Space Station", "background": "", "description": "Jones has achieved his dream: he joined a mission to the International Space Station (ISS). He received his first task: to check whether the electronic equipment on the space station is working properly.\n\nThe ISS is divided into $N$ modules, numbered from $1$ to $N$. Jones found that, to improve efficiency, the station was designed so that between any two modules there exists exactly one simple path. During a solar flare event, the bidirectional corridor connecting two modules can easily be affected by radiation. Checking the condition of a corridor $i$ requires $C_i$ time. Jones needs to find the fastest route that starts from module $1$, passes through every corridor at least once, and returns to module $1$.\n\nBesides moving through the corridors between modules, Jones can also put on a spacesuit, leave the station, and move directly from one module to any other module from the outside, but he can do this at most $M$ times. Jones assumes each such move takes a fixed time $K$.", "inputFormat": "The first line contains an integer $T$, which denotes the number of test cases.\n\nFor each test case, the first line contains three integers $N, M, K \\ (1 \\leq N, M \\leq 1000)$. The next $N-1$ lines each contain three integers $A, B, C \\ (1 \\leq A \\leq B \\leq N; 0 \\leq C,K \\leq 10^6)$, meaning there is a corridor between modules $A$ and $B$, and checking it takes $C$ time.", "outputFormat": "For each testdata, output one line containing the answer.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Space Station", "background": "", "description": "Jones 实现了他的梦想：他加入了国际空间站（ISS）的一次任务。他接受了他的第一个任务：检查空间站上的电子设备的工作状况。\n\nISS 被分为 $N$ 个模块，模块从 $1$ 到 $N$ 编号。Jones 发现，为了提高效率，空间站的设计使任意两个模块之间仅存在一条简单路径。在一次太阳耀斑活动中，连接两个模块的双向通道很容易受到辐射影响。检查一条通道 $i$ 的状况必须花费 $C_i$ 的时间。Jones 需要找到一条从模块 $1$ 出发，经过每条通道至少一次，再回到模块 $1$ 的最快路径。\n\n除了从模块之间的通道中通过之外，Jones 还可以穿上宇航服，跳出空间站，从外面直接从某一模块移动到任意模块上，但是这种方法只能进行最多 $M$ 次。Jones 假设进行一次需要花费固定的时间 $K$。", "inputFormat": "第一行包含一个整数 $T$，代表测试组数。\n\n每个测试组中，第一行包含三个整数 $N, M, K \\ (1 \\leq N, M \\leq 1000)$，接下来 $N-1$ 行每一行包含三个整数 $A, B, C \\ (1 \\leq A \\leq B \\leq N; 0 \\leq C,K \\leq 10^6)$，代表在模块 $A$ 和 $B$ 之间有一条通道，检查它需要花费 $C$ 时间。", "outputFormat": "对于每一组测试数据，输出一行答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5867", "type": "P", "difficulty": 4, "samples": [["8 4 4\n7 2\n3 3\n4 5\n5 1\n2 2\n1 4\n8 4\n9 4\n6 1 4 9", "2\n2\n3\n2"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "二分", "前缀和", "ICPC", "SEERC"], "title": "[SEERC 2018] Fishermen", "background": "", "description": "大海可以看成平面直角坐标系下的第一象限。海里有 $n$ 条鱼，每个鱼有一个二维坐标。一个点上可能有多条鱼。\n\n海边有 $m$ 个渔夫，每个渔夫有一个 $x$ 坐标，而他们的 $y$ 坐标都是 $0$。\n\n每个渔夫都有一根长为 $l$ 的钓竿，因此，他能钓到与他距离不超过 $l$ 的鱼。一个 $x$ 坐标为 $x$ 的渔夫和一条坐标为 $(a,b)$ 的鱼之间的距离为 $|a-x|+b$。\n\n分别计算出对于每个渔夫，他可以钓到多少条鱼。", "inputFormat": "第一行包含三个整数 $n, m$ 和 $l \\ (1 \\leq n,m \\leq 2 \\cdot 10^5, 1 \\leq l \\leq 10^9)$，代表鱼的数量、渔夫的数量和钓鱼竿的长度。\n\n接下来 $n$ 行每行包含两个整数 $x_i$ 和 $y_i \\ (1 \\leq x_i, y_i \\leq 10^9)$，代表每条鱼的坐标。\n\n接下来一行包含 $m$ 个整数 $a_i \\ (1 \\leq a_i \\leq 10^9)$，代表每个渔夫的 $x$ 坐标。", "outputFormat": "对于每个渔夫，输出一行答案。", "hint": "图片展示了上面的样例中第三个渔夫可以钓到鱼的区域。\n\n![样例图](https://cdn.luogu.com.cn/upload/image_hosting/cbfqtjw7.png)\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Fishermen", "background": "", "description": "The sea can be considered as the first quadrant of the Cartesian coordinate system. There are $n$ fish in the sea, and each fish has a two-dimensional coordinate. There may be multiple fish at the same point.\n\nThere are $m$ fishermen on the shore. Each fisherman has an $x$ coordinate, and their $y$ coordinate is always $0$.\n\nEach fisherman has a fishing rod of length $l$, so he can catch fish whose distance to him is at most $l$. The distance between a fisherman with $x$ coordinate $x$ and a fish at coordinate $(a,b)$ is $|a-x|+b$.\n\nFor each fisherman, compute how many fish he can catch.", "inputFormat": "The first line contains three integers $n, m$ and $l \\ (1 \\leq n,m \\leq 2 \\cdot 10^5, 1 \\leq l \\leq 10^9)$, representing the number of fish, the number of fishermen, and the length of the fishing rod.\n\nThe next $n$ lines each contain two integers $x_i$ and $y_i \\ (1 \\leq x_i, y_i \\leq 10^9)$, representing the coordinates of each fish.\n\nThe next line contains $m$ integers $a_i \\ (1 \\leq a_i \\leq 10^9)$, representing the $x$ coordinate of each fisherman.", "outputFormat": "For each fisherman, output one line with the answer.", "hint": "The picture shows the region where the third fisherman in the sample above can catch fish.\n\n![sample image](https://cdn.luogu.com.cn/upload/image_hosting/cbfqtjw7.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Fishermen", "background": "", "description": "大海可以看成平面直角坐标系下的第一象限。海里有 $n$ 条鱼，每个鱼有一个二维坐标。一个点上可能有多条鱼。\n\n海边有 $m$ 个渔夫，每个渔夫有一个 $x$ 坐标，而他们的 $y$ 坐标都是 $0$。\n\n每个渔夫都有一根长为 $l$ 的钓竿，因此，他能钓到与他距离不超过 $l$ 的鱼。一个 $x$ 坐标为 $x$ 的渔夫和一条坐标为 $(a,b)$ 的鱼之间的距离为 $|a-x|+b$。\n\n分别计算出对于每个渔夫，他可以钓到多少条鱼。", "inputFormat": "第一行包含三个整数 $n, m$ 和 $l \\ (1 \\leq n,m \\leq 2 \\cdot 10^5, 1 \\leq l \\leq 10^9)$，代表鱼的数量、渔夫的数量和钓鱼竿的长度。\n\n接下来 $n$ 行每行包含两个整数 $x_i$ 和 $y_i \\ (1 \\leq x_i, y_i \\leq 10^9)$，代表每条鱼的坐标。\n\n接下来一行包含 $m$ 个整数 $a_i \\ (1 \\leq a_i \\leq 10^9)$，代表每个渔夫的 $x$ 坐标。", "outputFormat": "对于每个渔夫，输出一行答案。", "hint": "图片展示了上面的样例中第三个渔夫可以钓到鱼的区域。\n\n![样例图](https://cdn.luogu.com.cn/upload/image_hosting/cbfqtjw7.png)\n\n", "locale": "zh-CN"}}}
{"pid": "P5868", "type": "P", "difficulty": 6, "samples": [["5\n1 5 5 3 4\n1 1 4 4 4", "3\nm 1 2\nM 4 5\nm 3 5"], ["5\n1 2 3 4 4\n2 2 2 2 5", "-1"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "Special Judge", "ICPC", "SEERC"], "title": "[SEERC 2018] Min Max Convert", "background": "", "description": "$A$ 是一个有 $N$ 个元素的数列。你可以对这个数列进行以下两种操作：\n\n1. 选出一个下标的区间 $[a, b] \\ (1 \\leq a \\leq b \\leq N)$，设数列中在这个下标区间中的元素的最大值为 $x$，将这个下标区间中的所有元素替换为 $x$。\n2. 选出一个下标的区间 $[a, b] \\ (1 \\leq a \\leq b \\leq N)$，设数列中在这个下标区间中的元素的最小值为 $x$，将这个下标区间中的所有元素替换为 $x$。\n\n计算出一组操作方案，使数列 $A$ 变为另一个给定的数列 $B$（也有 $N$ 个元素）。方案中操作的数列必须小于等于 $2N$。", "inputFormat": "第一行包含一个整数 $N$。\n\n第二行包含一个有 $N$ 个元素的数列 $A$。\n\n第三行包含另一个有 $N$ 个元素的数列 $B$。", "outputFormat": "如果无解，输出 $-1$。否则在第一行输出一个整数 $x$，代表将数列 $A$ 变为 $B$ 所需的最小操作数量。接下来 $x$ 行每行包含一个字符（代表操作的类型，`m ` 代表使用了最小值的操作，`M` 代表使用了最大值的操作）和一个区间 $(a,b)$，描述了所需的每次操作信息。如果有多解，任意输出一组即可。", "hint": "- $1 \\leq N \\leq 100, 000$\n- 数列 $A$ 和 $B$ 中的元素都是区间 $[1, N]$ 中的整数", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Min Max Convert", "background": "", "description": "$A$ is an array with $N$ elements. You can perform the following two operations on this array:\n\n1. Choose an index interval $[a, b] \\ (1 \\leq a \\leq b \\leq N)$. Let the maximum value among the elements in this interval be $x$, and replace all elements in this interval with $x$.\n2. Choose an index interval $[a, b] \\ (1 \\leq a \\leq b \\leq N)$. Let the minimum value among the elements in this interval be $x$, and replace all elements in this interval with $x$.\n\nCompute a sequence of operations that transforms array $A$ into another given array $B$ (also with $N$ elements). The number of operations in the sequence must be less than or equal to $2N$.", "inputFormat": "The first line contains an integer $N$.\n\nThe second line contains an array $A$ with $N$ elements.\n\nThe third line contains another array $B$ with $N$ elements.", "outputFormat": "If there is no solution, output $-1$. Otherwise, output an integer $x$ in the first line, representing the minimum number of operations needed to transform array $A$ into $B$. In the next $x$ lines, each line contains one character (representing the type of operation, `m ` means the minimum-value operation is used, and `M` means the maximum-value operation is used) and an interval $(a,b)$, describing each operation. If there are multiple solutions, output any one of them.", "hint": "- $1 \\leq N \\leq 100, 000$.\n- All elements in arrays $A$ and $B$ are integers in the interval $[1, N]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Min Max Convert", "background": "", "description": "$A$ 是一个有 $N$ 个元素的数列。你可以对这个数列进行以下两种操作：\n\n1. 选出一个下标的区间 $[a, b] \\ (1 \\leq a \\leq b \\leq N)$，设数列中在这个下标区间中的元素的最大值为 $x$，将这个下标区间中的所有元素替换为 $x$。\n2. 选出一个下标的区间 $[a, b] \\ (1 \\leq a \\leq b \\leq N)$，设数列中在这个下标区间中的元素的最小值为 $x$，将这个下标区间中的所有元素替换为 $x$。\n\n计算出一组操作方案，使数列 $A$ 变为另一个给定的数列 $B$（也有 $N$ 个元素）。方案中操作的数列必须小于等于 $2N$。", "inputFormat": "第一行包含一个整数 $N$。\n\n第二行包含一个有 $N$ 个元素的数列 $A$。\n\n第三行包含另一个有 $N$ 个元素的数列 $B$。", "outputFormat": "如果无解，输出 $-1$。否则在第一行输出一个整数 $x$，代表将数列 $A$ 变为 $B$ 所需的最小操作数量。接下来 $x$ 行每行包含一个字符（代表操作的类型，`m ` 代表使用了最小值的操作，`M` 代表使用了最大值的操作）和一个区间 $(a,b)$，描述了所需的每次操作信息。如果有多解，任意输出一组即可。", "hint": "- $1 \\leq N \\leq 100, 000$\n- 数列 $A$ 和 $B$ 中的元素都是区间 $[1, N]$ 中的整数", "locale": "zh-CN"}}}
{"pid": "P5869", "type": "P", "difficulty": 5, "samples": [["2 7\n1 3\n0 2\n1 1\n1 4\n0 4\n0 3\n1 1", "13\n17\n21\n17\n21\n17\n13"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "线段树", "ICPC", "SEERC"], "title": "[SEERC 2018] Matrix Queries", "background": "", "description": "给定一个 $2^n \\times 2^n$ 的矩阵，最开始每个格子都是白色的。格子的颜色可以是白色或黑色。定义一个矩阵的*价值*为：\n\n1. 如果矩阵是单色的，则它的价值为 $1$ 金币；\n2. 否则，将矩阵分割成 $4$ 个大小相等的子矩阵，矩阵的价值为子矩阵的价值之和加 $1$ 金币。\n\n给定 $q$ 个询问，每个询问给定一个行/列的编号 $x$，你需要改变这一行/列中每个格子的颜色（黑色变为白色，白色变为黑色），然后计算出改变之后的新矩阵的*价值*。", "inputFormat": "第一行包含两个整数 $n$ 和 $q \\ (0 \\leq n \\leq 20, 1 \\leq q \\leq 10^6)$，代表矩阵的大小为 $2^n \\times 2^n$ 以及有 $q$ 个询问。\n\n接下来 $q$ 行每行包含两个整数 $t$ 和 $x \\ (0 \\leq t \\leq 1, 1 \\leq x \\leq 2^n)$。如果 $t=0$，则改变第 $x$ 行的颜色；否则，改变第 $x$ 列的颜色。", "outputFormat": "对于每个询问，输出一行答案。", "hint": "样例中，每个询问后的矩阵如下图所示：\n\n![样例图](https://cdn.luogu.com.cn/upload/image_hosting/1cyezquq.png)", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Matrix Queries", "background": "", "description": "Given a $2^n \\times 2^n$ matrix, initially every cell is white. Each cell can be either white or black. Define the *value* of a matrix as follows:\n\n1. If the matrix is monochromatic, then its value is $1$ coin.\n2. Otherwise, split the matrix into $4$ equal-sized submatrices. The value of the matrix is the sum of the values of the submatrices plus $1$ coin.\n\nYou are given $q$ queries. Each query provides a row/column index $x$. You need to flip the color of every cell in that row/column (black becomes white, white becomes black), and then compute the *value* of the new matrix after the change.", "inputFormat": "The first line contains two integers $n$ and $q \\ (0 \\leq n \\leq 20, 1 \\leq q \\leq 10^6)$, meaning the matrix size is $2^n \\times 2^n$ and there are $q$ queries.\n\nThe next $q$ lines each contain two integers $t$ and $x \\ (0 \\leq t \\leq 1, 1 \\leq x \\leq 2^n)$. If $t=0$, flip the colors of row $x$; otherwise, flip the colors of column $x$.", "outputFormat": "For each query, output one line with the answer.", "hint": "In the sample, the matrix after each query is shown in the figure below:\n\n![Sample Figure](https://cdn.luogu.com.cn/upload/image_hosting/1cyezquq.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Matrix Queries", "background": "", "description": "给定一个 $2^n \\times 2^n$ 的矩阵，最开始每个格子都是白色的。格子的颜色可以是白色或黑色。定义一个矩阵的*价值*为：\n\n1. 如果矩阵是单色的，则它的价值为 $1$ 金币；\n2. 否则，将矩阵分割成 $4$ 个大小相等的子矩阵，矩阵的价值为子矩阵的价值之和加 $1$ 金币。\n\n给定 $q$ 个询问，每个询问给定一个行/列的编号 $x$，你需要改变这一行/列中每个格子的颜色（黑色变为白色，白色变为黑色），然后计算出改变之后的新矩阵的*价值*。", "inputFormat": "第一行包含两个整数 $n$ 和 $q \\ (0 \\leq n \\leq 20, 1 \\leq q \\leq 10^6)$，代表矩阵的大小为 $2^n \\times 2^n$ 以及有 $q$ 个询问。\n\n接下来 $q$ 行每行包含两个整数 $t$ 和 $x \\ (0 \\leq t \\leq 1, 1 \\leq x \\leq 2^n)$。如果 $t=0$，则改变第 $x$ 行的颜色；否则，改变第 $x$ 列的颜色。", "outputFormat": "对于每个询问，输出一行答案。", "hint": "样例中，每个询问后的矩阵如下图所示：\n\n![样例图](https://cdn.luogu.com.cn/upload/image_hosting/1cyezquq.png)", "locale": "zh-CN"}}}
{"pid": "P5870", "type": "P", "difficulty": 4, "samples": [["2\n3 3\n1 2\n2 3\n3 1\n4 4\n1 2\n2 3\n3 4\n1 4", "1\n2\n2\n1 4"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "Special Judge", "随机化", "ICPC", "SEERC"], "title": "[SEERC 2018] Modern Djinn", "background": "", "description": "你不是一个 leader，你是一个 president。幸运的是，你有一只精灵，能够实现你的愿望。你的其中一个愿望就是假装你的社会中有 democracy。\n\n社会很简单。社会里有 $N$ 个人，编号从 $1$ 到 $N$，一些人“开心”而另一些很平常（“不开心”）。人类这种生物非常奇妙，人们只在别人不开心时才感到开心。人们共有 $M$ 个愿望，编号从 $1$ 到 $M$，$X \\rightarrow Y$代表 $X$ 想要 $Y$ 不开心。一个人 $X$ 是开心的当且仅当他的至少一个愿望得到满足。\n\nDemocracy 也没那么复杂。有些人说为了实现 democracy，你需要至少一半的人是开心的（或一半的愿望得到满足），但这不全是事实。我刚才说过，你是一个好的 president，而不是一个好的 leader。你可以通过媒体来定义 democracy。因此，在所有的 $M$ 个愿望中，你决定实现至少 $\\lfloor M/4 \\rfloor +1$ 个愿望。\n\n剩下的事情就是选出你想实现的愿望，然后精灵会处理好一切。", "inputFormat": "输入包含多组测试数据。第一行包含一个整数 $T$，代表测试数据的组数。接下来的输入中会按顺序给出每组测试数据。\n\n在每组测试数据中，第一行包含两个正整数 $N$ 和 $M$，代表社会中人的数量和愿望的数量。接下来 $M$ 行每行包含两个整数 $X, Y$，描述了一个愿望：$X$ 希望 $Y$ 不开心。", "outputFormat": "对于每组测试数据，第一行输出一个整数 $K$，代表实现的愿望的数量，第二行输出 $K$ 个整数，代表实现的愿望编号，输出的顺序不做限制。", "hint": "**【数据范围与限制】**\n\n- $1 \\leq T \\leq 10, 000$\n- $2 \\leq N \\leq 100,000$\n- $1 \\leq M \\leq 200,000$\n- 不存在 $X$ 希望 $X$ 不开心这样的愿望。\n- 可能存在多个相同的 $X$ 希望 $Y$ 不开心的愿望。\n- 每组数据保证解一定存在。\n- 输出任何正确的解都可以。\n\n**【样例解释】**\n\n第一组测试数据中，我们可以实现最多 $1$ 个愿望，输出任意一个愿望都是可行的。\n\n第二组测试数据中，另外一个可行的解是实现愿望 $1, 3$ 和 $4$，最少需要实现 $2$ 个愿望。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Modern Djinn", "background": "", "description": "You are not a leader; you are a president. Luckily, you have a djinn that can grant your wishes. One of your wishes is to pretend that your society has democracy.\n\nThe society is simple. There are $N$ people in the society, numbered from $1$ to $N$. Some people are “happy”, while others are ordinary (“unhappy”). Humans are very strange: people feel happy only when others are unhappy. There are $M$ wishes in total, numbered from $1$ to $M$. $X \\rightarrow Y$ means that $X$ wants $Y$ to be unhappy. A person $X$ is happy if and only if at least one of their wishes is fulfilled.\n\nDemocracy is not that complicated either. Some say that to achieve democracy, you need at least half of the people to be happy (or half of the wishes to be fulfilled), but that is not entirely true. As I said, you are a good president, not a good leader. You can define democracy through the media. Therefore, among all $M$ wishes, you decide to fulfill at least $\\lfloor M/4 \\rfloor + 1$ wishes.\n\nThe remaining task is to choose which wishes you want to fulfill, and then the djinn will take care of everything.", "inputFormat": "The input contains multiple test cases. The first line contains an integer $T$, the number of test cases. The following lines give the test cases in order.\n\nFor each test case, the first line contains two positive integers $N$ and $M$, representing the number of people in the society and the number of wishes. The next $M$ lines each contain two integers $X, Y$, describing a wish: $X$ wants $Y$ to be unhappy.", "outputFormat": "For each test case, output an integer $K$ on the first line, the number of wishes to be fulfilled. Output $K$ integers on the second line, the indices of the fulfilled wishes. The order does not matter.", "hint": "**Constraints**\n\n- $1 \\leq T \\leq 10,000$\n- $2 \\leq N \\leq 100,000$\n- $1 \\leq M \\leq 200,000$\n- There is no wish where $X$ wants $X$ to be unhappy.\n- There may be multiple identical wishes where $X$ wants $Y$ to be unhappy.\n- For each test case, a solution is guaranteed to exist.\n- Any correct solution is accepted.\n\n**Sample Explanation**\n\nIn the first test case, we can fulfill at most $1$ wish; outputting any wish is valid.\n\nIn the second test case, another valid solution is to fulfill wishes $1$, $3$, and $4$. At least $2$ wishes must be fulfilled.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Modern Djinn", "background": "", "description": "你不是一个 leader，你是一个 president。幸运的是，你有一只精灵，能够实现你的愿望。你的其中一个愿望就是假装你的社会中有 democracy。\n\n社会很简单。社会里有 $N$ 个人，编号从 $1$ 到 $N$，一些人“开心”而另一些很平常（“不开心”）。人类这种生物非常奇妙，人们只在别人不开心时才感到开心。人们共有 $M$ 个愿望，编号从 $1$ 到 $M$，$X \\rightarrow Y$代表 $X$ 想要 $Y$ 不开心。一个人 $X$ 是开心的当且仅当他的至少一个愿望得到满足。\n\nDemocracy 也没那么复杂。有些人说为了实现 democracy，你需要至少一半的人是开心的（或一半的愿望得到满足），但这不全是事实。我刚才说过，你是一个好的 president，而不是一个好的 leader。你可以通过媒体来定义 democracy。因此，在所有的 $M$ 个愿望中，你决定实现至少 $\\lfloor M/4 \\rfloor +1$ 个愿望。\n\n剩下的事情就是选出你想实现的愿望，然后精灵会处理好一切。", "inputFormat": "输入包含多组测试数据。第一行包含一个整数 $T$，代表测试数据的组数。接下来的输入中会按顺序给出每组测试数据。\n\n在每组测试数据中，第一行包含两个正整数 $N$ 和 $M$，代表社会中人的数量和愿望的数量。接下来 $M$ 行每行包含两个整数 $X, Y$，描述了一个愿望：$X$ 希望 $Y$ 不开心。", "outputFormat": "对于每组测试数据，第一行输出一个整数 $K$，代表实现的愿望的数量，第二行输出 $K$ 个整数，代表实现的愿望编号，输出的顺序不做限制。", "hint": "**【数据范围与限制】**\n\n- $1 \\leq T \\leq 10, 000$\n- $2 \\leq N \\leq 100,000$\n- $1 \\leq M \\leq 200,000$\n- 不存在 $X$ 希望 $X$ 不开心这样的愿望。\n- 可能存在多个相同的 $X$ 希望 $Y$ 不开心的愿望。\n- 每组数据保证解一定存在。\n- 输出任何正确的解都可以。\n\n**【样例解释】**\n\n第一组测试数据中，我们可以实现最多 $1$ 个愿望，输出任意一个愿望都是可行的。\n\n第二组测试数据中，另外一个可行的解是实现愿望 $1, 3$ 和 $4$，最少需要实现 $2$ 个愿望。\n\n", "locale": "zh-CN"}}}
{"pid": "P5871", "type": "P", "difficulty": 4, "samples": [["4 2\n2 3\n2 4", "2"], ["5 7\n2 5\n1 5\n3 5\n2 3\n4 1\n4 3\n4 2", "3"], ["7 7\n5 6\n2 3\n6 7\n2 7\n3 1\n7 5\n7 4", "6"], ["5 6\n1 3\n4 5\n1 4\n2 3\n1 2\n1 5", "5"]], "limits": {"time": [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "ICPC", "SEERC"], "title": "[SEERC 2018] Inversion", "background": "", "description": "定义一个长为 $n$ 的*排列*为一个序列 $p_1, p_2, \\dots, p_n$，其中 $[1, n]$ 范围内的整数都恰好在这个序列中出现一次。定义排列中的一个*逆序对*为一对整数 $(i, j)$，其中 $i, j \\in [1,n]$，且满足 $i<j, p_i>p_j$。\n\n定义一个*逆序对图*为一个有 $n$ 个点的图，图中存在一条 $(i, j)$ 的边当且仅当 $(i,j)$ 是一个逆序对。\n\n定义一个图中的*独立集*为一个图中点的集合，满足集合中的点两两之间没有边相连。定义一个图中的*支配集*为一个图中点的集合，满足不在这个集合中的点都与集合中的某个点有边相连。定义一个图中的*独立支配集*为一个图中点的集合，这个集合既是独立集又是支配集。\n\n给定某一个长为 $n$ 的排列的逆序对图，请计算出这个图中独立支配集的数量。\n\n数据保证答案不会超过 $10^{18}$。", "inputFormat": "第一行包含两个整数 $n$ 和 $m \\ (1 \\leq n \\leq 100, 0 \\leq m \\leq \\frac{n \\times (n-1)}{2})$，代表图中的点数和边数。\n\n接下来 $m$ 行每行包含两个整数 $u_i$ 和 $v_i \\ (1 \\leq u_i, v_i \\leq n)$，代表图中点 $u_i$ 和 $v_i$ 之间有一条边相连。\n\n数据保证图一定对应某一个排列。", "outputFormat": "输出图中独立支配集的数量。\n\n数据保证答案不会超过 $10^{18}$。", "hint": "第一个样例中，图对应排列 $[1,4,2,3]$，独立支配集有 $(1,3,4)$ 和 $(1,2)$。\n\n第二个样例中，图对应排列 $[3,5,4,1,2]$，独立支配集有 $(1,2),(1,3),(4,5)$。\n\n第三个样例中，图对应排列 $[2,4,1,5,7,6,3]$。\n\n第四个样例中，图对应排列 $[5,2,1,4,3]$。", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Inversion", "background": "", "description": "A *permutation* of length $n$ is defined as a sequence $p_1, p_2, \\dots, p_n$, where every integer in the range $[1, n]$ appears in this sequence exactly once. An *inversion pair* in a permutation is defined as a pair of integers $(i, j)$, where $i, j \\in [1,n]$, and it satisfies $i<j, p_i>p_j$.\n\nAn *inversion graph* is defined as a graph with $n$ vertices, where an edge $(i, j)$ exists if and only if $(i,j)$ is an inversion pair.\n\nAn *independent set* in a graph is a set of vertices such that no two vertices in the set are connected by an edge. A *dominating set* in a graph is a set of vertices such that every vertex not in the set is adjacent to some vertex in the set. An *independent dominating set* in a graph is a set of vertices that is both an independent set and a dominating set.\n\nGiven the inversion graph of a permutation of length $n$, compute the number of independent dominating sets in this graph.\n\nIt is guaranteed that the answer will not exceed $10^{18}$.", "inputFormat": "The first line contains two integers $n$ and $m \\ (1 \\leq n \\leq 100, 0 \\leq m \\leq \\frac{n \\times (n-1)}{2})$, representing the number of vertices and the number of edges in the graph.\n\nThe next $m$ lines each contain two integers $u_i$ and $v_i \\ (1 \\leq u_i, v_i \\leq n)$, indicating that there is an edge between vertices $u_i$ and $v_i$.\n\nIt is guaranteed that the graph corresponds to some permutation.", "outputFormat": "Output the number of independent dominating sets in the graph.\n\nIt is guaranteed that the answer will not exceed $10^{18}$.", "hint": "In the first sample, the graph corresponds to the permutation $[1,4,2,3]$, and the independent dominating sets are $(1,3,4)$ and $(1,2)$.\n\nIn the second sample, the graph corresponds to the permutation $[3,5,4,1,2]$, and the independent dominating sets are $(1,2)$, $(1,3)$, and $(4,5)$.\n\nIn the third sample, the graph corresponds to the permutation $[2,4,1,5,7,6,3]$.\n\nIn the fourth sample, the graph corresponds to the permutation $[5,2,1,4,3]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Inversion", "background": "", "description": "定义一个长为 $n$ 的*排列*为一个序列 $p_1, p_2, \\dots, p_n$，其中 $[1, n]$ 范围内的整数都恰好在这个序列中出现一次。定义排列中的一个*逆序对*为一对整数 $(i, j)$，其中 $i, j \\in [1,n]$，且满足 $i<j, p_i>p_j$。\n\n定义一个*逆序对图*为一个有 $n$ 个点的图，图中存在一条 $(i, j)$ 的边当且仅当 $(i,j)$ 是一个逆序对。\n\n定义一个图中的*独立集*为一个图中点的集合，满足集合中的点两两之间没有边相连。定义一个图中的*支配集*为一个图中点的集合，满足不在这个集合中的点都与集合中的某个点有边相连。定义一个图中的*独立支配集*为一个图中点的集合，这个集合既是独立集又是支配集。\n\n给定某一个长为 $n$ 的排列的逆序对图，请计算出这个图中独立支配集的数量。\n\n数据保证答案不会超过 $10^{18}$。", "inputFormat": "第一行包含两个整数 $n$ 和 $m \\ (1 \\leq n \\leq 100, 0 \\leq m \\leq \\frac{n \\times (n-1)}{2})$，代表图中的点数和边数。\n\n接下来 $m$ 行每行包含两个整数 $u_i$ 和 $v_i \\ (1 \\leq u_i, v_i \\leq n)$，代表图中点 $u_i$ 和 $v_i$ 之间有一条边相连。\n\n数据保证图一定对应某一个排列。", "outputFormat": "输出图中独立支配集的数量。\n\n数据保证答案不会超过 $10^{18}$。", "hint": "第一个样例中，图对应排列 $[1,4,2,3]$，独立支配集有 $(1,3,4)$ 和 $(1,2)$。\n\n第二个样例中，图对应排列 $[3,5,4,1,2]$，独立支配集有 $(1,2),(1,3),(4,5)$。\n\n第三个样例中，图对应排列 $[2,4,1,5,7,6,3]$。\n\n第四个样例中，图对应排列 $[5,2,1,4,3]$。", "locale": "zh-CN"}}}
{"pid": "P5872", "type": "P", "difficulty": 4, "samples": [["8 12\n1 2 2 10\n2 3 1 10\n3 8 2 10\n1 4 10 3\n4 5 10 2\n5 6 10 4\n6 8 10 2\n1 7 10 5\n4 7 10 2\n5 7 10 2\n6 7 10 1\n7 8 10 1\n3\n1 3\n2 2\n3 0\n4\n4 5 6 7", "2\n4 5"], ["6 6\n1 4 1 3\n4 6 1 1\n4 2 1 6\n2 6 6 6\n3 4 2 3\n1 3 4 5\n2\n1 2\n2 0\n4\n6 5 3 4", "0"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "最短路", "ICPC", "双指针 two-pointer", "SEERC"], "title": "[SEERC 2018] Rabbit vs Turtle", "background": "", "description": "一只兔子和一只乌龟决定赛跑。由于乌龟来自 Craiova 而兔子来自 Ardeal，乌龟比兔子跑得快的多。我们的目标是帮助兔子赢得比赛。\n\n比赛在一个 $N$ 个点 $M$ 条边的图上进行，比赛在点 $1$ 开始，点 $N$ 结束。比赛前，兔子和乌龟都要先选出一条比赛时他们各自使用的路径。因此，他们知道这个图的情况和经过图上每条边的时间。\n\n乌龟可能跑的比兔子快，但他还是一只乌龟（后文叫做 George）。George 会在他的路径上选出一些点来睡一会。如果某一时刻他知道了兔子在作弊，George 就不再睡觉，直到完成比赛。\n\n兔子（后文叫做 Stan）只有一个优势，他的一个祖祖祖……祖母是一只狐狸，因此他也有狡猾的一面。Stan 并不打算按照他选好的路径来比赛（但 George 会按照路径比赛）。他计划在某一点更改路线，直接通过最短路径到达点 $N$。唯一的问题是他必须做出明智的选择，因为 George 一旦发现 Stan 在作弊，就会不再睡觉，这是不利的。\n\nStan 只能在到达一个点后更改路线（还在边上移动的时候是不能更改的）。他并不知道 George 的休息计划，但你知道！计算出 Stan 可以更改路线并赢得比赛的时间点数量。当 Stan 开始作弊的时候，George 只要没有在睡觉，就会立即察觉到。如果那时 George 在睡觉，则他醒来的时候才会察觉。", "inputFormat": "第一行包含两个整数 $N$ 和 $M$。接下来 $M$ 行用 $(A,B,T,R)$ 的格式来描述图中的边：有一条边连接点 $A$ 和 $B$，乌龟经过这条边需要花费 $T$ 时间，兔子需要花费 $R$ 时间。边按输入顺序从 $1$ 到 $M$ 编号。\n\n接下来一行包含一个整数 $P_T$，代表 George 路径上的边数。接下来 $P_T$ 行用 (边的编号, 睡眠时间) 来描述路径上的边：路径上有一条给定编号的边，在经过这条边后，George 会睡一会，睡眠时间给定。最后一条边的睡眠时间是没有意义的，因为 George 已经到终点了。\n\n接下来一行包含一个整数 $P_R$，代表 Stan 最开始选择的路径上的边数。最后一行包含 $P_R$ 个整数，代表 Stan 最开始路径上的边的编号。", "outputFormat": "输出第一行包含一个整数 $x$，代表 Stan 可以开始作弊的时间点（也就是开始作弊所在的点）数量。第二行包含 $x$ 个递增顺序的整数，代表 Stan 可以开始作弊的点的编号。", "hint": "- $2 \\leq N \\leq 100,000$\n- $1 \\leq P_R, P_T < 100,000$\n- $1 \\leq M \\leq 200,000$\n- $1 \\leq T,R \\leq 1,000,000,000$\n- $0 \\leq$ 睡眠时间 $\\leq 1,000,000,000$\n- 数据保证按照正确的顺序描述比赛路径上的边（即相邻两条边终点、起点相同）。\n- 数据保证乌龟路径上的点不重复。\n- 数据保证兔子路径上的点不重复。\n- 如果兔子和乌龟同时到达终点，认为兔子赢了。\n- 如果兔子在乌龟开始睡觉的时候开始作弊，那么乌龟会睡着，醒来时才察觉兔子在作弊。\n- 认为兔子在作弊当且仅当他改变了路径且新路径严格快于原来的路径（否则就没必要作弊了）。\n- 作弊路径可能与原始路径有相同的点。唯一的要求是在开始作弊的时候，兔子前往和原路径不同的点。在某些情况中，他也可能会回到之前经过的点。", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Rabbit vs Turtle", "background": "", "description": "A rabbit and a turtle decide to race. Since the turtle is from Craiova and the rabbit is from Ardeal, the turtle runs much faster than the rabbit. Our goal is to help the rabbit win the race.\n\nThe race takes place on a graph with $N$ nodes and $M$ edges. The race starts at node $1$ and ends at node $N$. Before the race, both the rabbit and the turtle choose a path that they will use during the race. Therefore, they know the graph and the time needed to traverse each edge.\n\nThe turtle may be faster than the rabbit, but he is still a turtle (called George below). George will choose some nodes on his path to sleep for a while. If at some moment he finds out that the rabbit is cheating, George will stop sleeping until he finishes the race.\n\nThe rabbit (called Stan below) has only one advantage: one of his great-great-great... grandmothers was a fox, so he also has a crafty side. Stan does not plan to follow his chosen path during the race (but George will follow his path). He plans to change his route at some node and then go directly to node $N$ via the shortest path. The only problem is that he must make a wise choice, because once George discovers that Stan is cheating, George will no longer sleep, which is unfavorable.\n\nStan can change his route only after arriving at a node (he cannot change while moving along an edge). He does not know George’s sleeping plan, but you do. Compute how many nodes allow Stan to change his route and win the race. When Stan starts cheating, if George is not sleeping, he will notice immediately. If George is sleeping at that moment, he will notice only when he wakes up.", "inputFormat": "The first line contains two integers $N$ and $M$. The next $M$ lines describe the edges in the format $(A,B,T,R)$: there is an edge connecting nodes $A$ and $B$, the turtle needs $T$ time to traverse this edge, and the rabbit needs $R$ time. The edges are numbered from $1$ to $M$ in the input order.\n\nThe next line contains an integer $P_T$, the number of edges in George’s path. The next $P_T$ lines describe the path as (edge id, sleep time): the path uses the edge with the given id, and after traversing this edge, George will sleep for a while, with the given sleep time. The sleep time after the last edge is meaningless, because George has already reached the finish.\n\nThe next line contains an integer $P_R$, the number of edges in Stan’s initially chosen path. The last line contains $P_R$ integers, the edge ids of the edges in Stan’s initial path.", "outputFormat": "Output on the first line an integer $x$, the number of nodes where Stan can start cheating (i.e., the node where he starts cheating). On the second line output $x$ integers in increasing order, the ids of the nodes where Stan can start cheating.", "hint": "- $2 \\leq N \\leq 100,000$.\n- $1 \\leq P_R, P_T < 100,000$.\n- $1 \\leq M \\leq 200,000$.\n- $1 \\leq T,R \\leq 1,000,000,000$.\n- $0 \\leq$ sleep time $\\leq 1,000,000,000$.\n- The testdata guarantees that the edges on the race paths are described in the correct order (i.e., the end of one edge is the start of the next).\n- The testdata guarantees that the nodes on the turtle’s path do not repeat.\n- The testdata guarantees that the nodes on the rabbit’s path do not repeat.\n- If the rabbit and the turtle arrive at the finish at the same time, the rabbit is considered to win.\n- If the rabbit starts cheating exactly when the turtle starts sleeping, then the turtle will fall asleep and will notice the cheating only when he wakes up.\n- The rabbit is considered cheating if and only if he changes his path and the new path is strictly faster than the original path (otherwise there is no need to cheat).\n- The cheating path may share nodes with the original path. The only requirement is that when he starts cheating, the rabbit moves to a different next node than in the original path. In some cases, he may also return to a node he visited before.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Rabbit vs Turtle", "background": "", "description": "一只兔子和一只乌龟决定赛跑。由于乌龟来自 Craiova 而兔子来自 Ardeal，乌龟比兔子跑得快的多。我们的目标是帮助兔子赢得比赛。\n\n比赛在一个 $N$ 个点 $M$ 条边的图上进行，比赛在点 $1$ 开始，点 $N$ 结束。比赛前，兔子和乌龟都要先选出一条比赛时他们各自使用的路径。因此，他们知道这个图的情况和经过图上每条边的时间。\n\n乌龟可能跑的比兔子快，但他还是一只乌龟（后文叫做 George）。George 会在他的路径上选出一些点来睡一会。如果某一时刻他知道了兔子在作弊，George 就不再睡觉，直到完成比赛。\n\n兔子（后文叫做 Stan）只有一个优势，他的一个祖祖祖……祖母是一只狐狸，因此他也有狡猾的一面。Stan 并不打算按照他选好的路径来比赛（但 George 会按照路径比赛）。他计划在某一点更改路线，直接通过最短路径到达点 $N$。唯一的问题是他必须做出明智的选择，因为 George 一旦发现 Stan 在作弊，就会不再睡觉，这是不利的。\n\nStan 只能在到达一个点后更改路线（还在边上移动的时候是不能更改的）。他并不知道 George 的休息计划，但你知道！计算出 Stan 可以更改路线并赢得比赛的时间点数量。当 Stan 开始作弊的时候，George 只要没有在睡觉，就会立即察觉到。如果那时 George 在睡觉，则他醒来的时候才会察觉。", "inputFormat": "第一行包含两个整数 $N$ 和 $M$。接下来 $M$ 行用 $(A,B,T,R)$ 的格式来描述图中的边：有一条边连接点 $A$ 和 $B$，乌龟经过这条边需要花费 $T$ 时间，兔子需要花费 $R$ 时间。边按输入顺序从 $1$ 到 $M$ 编号。\n\n接下来一行包含一个整数 $P_T$，代表 George 路径上的边数。接下来 $P_T$ 行用 (边的编号, 睡眠时间) 来描述路径上的边：路径上有一条给定编号的边，在经过这条边后，George 会睡一会，睡眠时间给定。最后一条边的睡眠时间是没有意义的，因为 George 已经到终点了。\n\n接下来一行包含一个整数 $P_R$，代表 Stan 最开始选择的路径上的边数。最后一行包含 $P_R$ 个整数，代表 Stan 最开始路径上的边的编号。", "outputFormat": "输出第一行包含一个整数 $x$，代表 Stan 可以开始作弊的时间点（也就是开始作弊所在的点）数量。第二行包含 $x$ 个递增顺序的整数，代表 Stan 可以开始作弊的点的编号。", "hint": "- $2 \\leq N \\leq 100,000$\n- $1 \\leq P_R, P_T < 100,000$\n- $1 \\leq M \\leq 200,000$\n- $1 \\leq T,R \\leq 1,000,000,000$\n- $0 \\leq$ 睡眠时间 $\\leq 1,000,000,000$\n- 数据保证按照正确的顺序描述比赛路径上的边（即相邻两条边终点、起点相同）。\n- 数据保证乌龟路径上的点不重复。\n- 数据保证兔子路径上的点不重复。\n- 如果兔子和乌龟同时到达终点，认为兔子赢了。\n- 如果兔子在乌龟开始睡觉的时候开始作弊，那么乌龟会睡着，醒来时才察觉兔子在作弊。\n- 认为兔子在作弊当且仅当他改变了路径且新路径严格快于原来的路径（否则就没必要作弊了）。\n- 作弊路径可能与原始路径有相同的点。唯一的要求是在开始作弊的时候，兔子前往和原路径不同的点。在某些情况中，他也可能会回到之前经过的点。", "locale": "zh-CN"}}}
{"pid": "P5873", "type": "P", "difficulty": 6, "samples": [["5\n1 2 3\n1 2 2\n1 3 4\n2 1 1 5 5\n2 2 2 2 2", "0\n0\n0\n3\n4"], ["4\n2 1 1 3 3\n2 1 1 2 2\n1 2 2\n1 2 2", "0\n0\n2\n4"], ["7\n1 5 5\n1 5 5\n1 5 5\n2 2 2 9 9\n2 1 1 5 5\n2 1 1 2 2\n1 2 2", "0\n0\n0\n3\n6\n6\n9"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "cdq 分治", "ICPC", "SEERC"], "title": "[SEERC 2018] Points and Rectangles", "background": "", "description": "给定一个空的二维平面，给定 $q$ 次询问。询问有两种类型：\n\n- $1 \\ x \\ y$ — 向平面中添加一个坐标为 $(x,y)$ 的点。\n- $2 \\ x_1 \\ y_1 \\ x_2 \\ y_2$ — 添加一个左下角坐标为 $(x_1,y_1)$、右上角坐标为 $(x_2,y_2)$ 的矩形。矩形的面积可以是 $0$，矩形也可以退化成一个点。\n\n矩形和点可能会重叠。\n\n每次询问操作完成之后，计算出使点在矩形内部或边上的点-矩形对数。", "inputFormat": "第一行包含一个整数 $q \\ (1 \\leq q \\leq 10^5)$，代表询问数。\n\n接下来 $q$ 行每行描述一个询问：\n\n- $1 \\ x \\ y \\ (1 \\leq x,y \\leq 10^9)$ — 向平面中添加一个坐标为 $(x,y)$ 的点。\n- $2 \\ x_1 \\ y_1 \\ x_2 \\ y_2 \\ (1 \\leq x_1 \\leq x_2 \\leq 10^9, 1 \\leq y_1 \\leq y_2 \\leq 10^9)$ — 添加一个左下角坐标为 $(x_1,y_1)$、右上角坐标为 $(x_2,y_2)$ 的矩形。", "outputFormat": "你需要输出 $q$ 行，第 $i$ 行包含一个整数，代表使点在矩形内部或边上的点-矩形对数。", "hint": "第一个样例的解释：\n\n第一次询问操作后，平面上有一个点 $(2,3)$，但没有矩形，因此没有满足条件的点-矩形对。\n\n第二次询问操作后，平面上仍然没有矩形，因此仍然没有这样的对。\n\n第三次询问操作后依然没有矩形。\n\n在第四次询问中，我们向平面中添加了一个左下角为 $(1,1)$、右上角为 $(5,5)$ 的矩形。之前添加的所有的点都在这个矩形中，因此这样的对有 $3$ 个。\n\n第五次询问操作后，我们有 $4$ 个这样的对：上面的 $3$ 对，以及第二次询问插入的点在第五次询问插入的矩形中新增的 $1$ 对。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Points and Rectangles", "background": "", "description": "You are given an empty 2D plane and $q$ queries. There are two types of queries:\n\n- $1 \\ x \\ y$ — Add a point with coordinates $(x,y)$ to the plane.\n- $2 \\ x_1 \\ y_1 \\ x_2 \\ y_2$ — Add a rectangle whose bottom-left corner is $(x_1,y_1)$ and top-right corner is $(x_2,y_2)$. The area of the rectangle can be $0$, and the rectangle may degenerate into a point.\n\nRectangles and points may overlap.\n\nAfter each query is processed, compute the number of point-rectangle pairs such that the point is inside the rectangle or on its boundary.", "inputFormat": "The first line contains an integer $q \\ (1 \\leq q \\leq 10^5)$, denoting the number of queries.\n\nThe next $q$ lines each describe one query:\n\n- $1 \\ x \\ y \\ (1 \\leq x,y \\leq 10^9)$ — Add a point with coordinates $(x,y)$ to the plane.\n- $2 \\ x_1 \\ y_1 \\ x_2 \\ y_2 \\ (1 \\leq x_1 \\leq x_2 \\leq 10^9, 1 \\leq y_1 \\leq y_2 \\leq 10^9)$ — Add a rectangle whose bottom-left corner is $(x_1,y_1)$ and top-right corner is $(x_2,y_2)$.", "outputFormat": "Output $q$ lines. The $i$-th line should contain one integer, representing the number of point-rectangle pairs such that the point is inside the rectangle or on its boundary.", "hint": "Explanation of the first sample:\n\nAfter the first query, there is one point $(2,3)$ on the plane, but there are no rectangles, so there are no valid point-rectangle pairs.\n\nAfter the second query, there are still no rectangles, so there are still no such pairs.\n\nAfter the third query, there are still no rectangles.\n\nIn the fourth query, we add a rectangle with bottom-left corner $(1,1)$ and top-right corner $(5,5)$. All points added before are inside this rectangle, so there are $3$ such pairs.\n\nAfter the fifth query, we have $4$ such pairs: the $3$ pairs above, plus $1$ new pair where the point inserted in the second query lies inside the rectangle inserted in the fifth query.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Points and Rectangles", "background": "", "description": "给定一个空的二维平面，给定 $q$ 次询问。询问有两种类型：\n\n- $1 \\ x \\ y$ — 向平面中添加一个坐标为 $(x,y)$ 的点。\n- $2 \\ x_1 \\ y_1 \\ x_2 \\ y_2$ — 添加一个左下角坐标为 $(x_1,y_1)$、右上角坐标为 $(x_2,y_2)$ 的矩形。矩形的面积可以是 $0$，矩形也可以退化成一个点。\n\n矩形和点可能会重叠。\n\n每次询问操作完成之后，计算出使点在矩形内部或边上的点-矩形对数。", "inputFormat": "第一行包含一个整数 $q \\ (1 \\leq q \\leq 10^5)$，代表询问数。\n\n接下来 $q$ 行每行描述一个询问：\n\n- $1 \\ x \\ y \\ (1 \\leq x,y \\leq 10^9)$ — 向平面中添加一个坐标为 $(x,y)$ 的点。\n- $2 \\ x_1 \\ y_1 \\ x_2 \\ y_2 \\ (1 \\leq x_1 \\leq x_2 \\leq 10^9, 1 \\leq y_1 \\leq y_2 \\leq 10^9)$ — 添加一个左下角坐标为 $(x_1,y_1)$、右上角坐标为 $(x_2,y_2)$ 的矩形。", "outputFormat": "你需要输出 $q$ 行，第 $i$ 行包含一个整数，代表使点在矩形内部或边上的点-矩形对数。", "hint": "第一个样例的解释：\n\n第一次询问操作后，平面上有一个点 $(2,3)$，但没有矩形，因此没有满足条件的点-矩形对。\n\n第二次询问操作后，平面上仍然没有矩形，因此仍然没有这样的对。\n\n第三次询问操作后依然没有矩形。\n\n在第四次询问中，我们向平面中添加了一个左下角为 $(1,1)$、右上角为 $(5,5)$ 的矩形。之前添加的所有的点都在这个矩形中，因此这样的对有 $3$ 个。\n\n第五次询问操作后，我们有 $4$ 个这样的对：上面的 $3$ 对，以及第二次询问插入的点在第五次询问插入的矩形中新增的 $1$ 对。\n\n", "locale": "zh-CN"}}}
{"pid": "P5874", "type": "P", "difficulty": 5, "samples": [["3\n2 1 3\n3 4 1\n1\n2 1 2\n", "8\n6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "2015", "线段树", "IOI"], "title": "[IOI 2015] horses", "background": "", "description": "像他的祖先一样，Mansur 喜欢繁殖马匹。目前，他拥有哈萨克斯坦最大的马场。以前情况可不是这样，$N$ 年前 Mansur 年轻时，他只拥有一匹马，但他一直梦想着成为富豪，最终,他美梦成真。\n\n按照时间的先后顺序将年份编号为 $0$ 到 $N-1$（即 $N-1$ 年是最近的一年）。每年的天气会影响马匹的繁殖。Mansur 用一个正整数 $X[i]$ 记录第 $i$ 年的繁殖系数，如果第 $i$ 年开始时有 $h$ 匹马，那么这一年结束时会有 $h \\times X[i]$ 匹马。\n\n每年，只有年底的时候可以出售马匹。Mansur 用一个正整数 $Y[i]$ 记录第 $i$ 年末卖出一匹马的售价。Mansur 可以卖出任意多匹马，每匹售价均为 $Y[i]$。\n\n现在，Mansur 想知道如果在 $N$ 年中，他总能在最佳时间出售马匹，他能获得的最大收益是多少？你正好在 Mansur 家做客，所以他想请你帮他回答这个问题。\n\nMansur 对记录下的 $X$ 和 $Y$ 做了 $M$ 次更新，每次更新，Mansur 要么改变一个 $X[i]$，要么改变一个 $Y[i]$。每次更新后，他都会问你出售马匹能获得的最大收益。Mansur 的更新是累加的，即你的每个回答时都应该考虑之前的所有更新。注意：某个 $X[i]$ 或者 $Y[i]$ 可能会被更新多次。\n\n对于 Mansur 的问题，实际的答案可能是一个非常大的数字，你只要给出实际答案模 $10^9+7$ 后的结果即可。", "inputFormat": "- 第 $1$ 行，一个整数 $N$，表示总共有 $N$ 年。\n- 第 $2$ 行，共 $N$ 个正整数 $X[0],\\cdots,X[N - 1]$，对于 $0\\le i \\le N-1$，$X[i]$ 表示 $i$ 年的繁殖系数。\n- 第 $3$ 行，共 $N$ 个正整数 $Y[0],\\cdots,Y[N - 1]$，对于 $0\\le i \\le N-1$，$Y[i]$ 表示 $i$ 年末出售一匹马的价格。\n- 第 $4$ 行，一个整数 $M$，表示更新次数。\n- 第 $5,\\cdots,M+4$ 行，每行 $3$ 个数字 $type$，$pos$，$val$ （$type=1$ 表示更改 $X[ pos ]$ 为 $val$，$type=2$ 表示更改 $Y[ pos ]$ 为 $val$）。", "outputFormat": "- 共 $M+1$ 行\n- 第 $1$ 行：一个整数表示初始状态下，Mansur 获得的最大收益模 $10^9+7$ 后的值。\n- 第 $2,\\cdots,M+1$ 行：每行一个整数，表示这次更新后 Mansur 获得的最大收益模 $10^9+7$ 后的值。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 5\\times 10^5$，$0 \\le M \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2015] horses", "background": "", "description": "Like his ancestors, Mansur enjoys breeding horses. He currently owns the largest horse ranch in Kazakhstan. It was not always like this: $N$ years ago, when Mansur was young, he only owned one horse, but he kept dreaming of becoming rich, and in the end his dream came true.\n\nNumber the years in chronological order from $0$ to $N-1$ (that is, year $N-1$ is the most recent year). Each year’s weather affects horse breeding. Mansur records a positive integer $X[i]$ as the breeding factor of year $i$. If there are $h$ horses at the beginning of year $i$, then there will be $h \\times X[i]$ horses at the end of that year.\n\nEach year, horses can only be sold at the end of the year. Mansur records a positive integer $Y[i]$ as the price for selling one horse at the end of year $i$. Mansur may sell any number of horses, and each horse is sold for $Y[i]$.\n\nNow, Mansur wants to know: over these $N$ years, if he always sells horses at the best time, what is the maximum total revenue he can obtain? You happen to be visiting Mansur’s home, so he asks you to help answer this question.\n\nMansur performed $M$ updates to the recorded arrays $X$ and $Y$. In each update, Mansur either changes one $X[i]$ or changes one $Y[i]$. After each update, he asks you again for the maximum revenue from selling horses. Mansur’s updates are cumulative, meaning each answer should take into account all previous updates. Note that some $X[i]$ or $Y[i]$ may be updated multiple times.\n\nThe real answer to Mansur’s question may be extremely large. You only need to output the real answer modulo $10^9+7$.", "inputFormat": "- Line $1$: An integer $N$, the total number of years.\n- Line $2$: $N$ positive integers $X[0],\\cdots,X[N - 1]$. For $0\\le i \\le N-1$, $X[i]$ is the breeding factor of year $i$.\n- Line $3$: $N$ positive integers $Y[0],\\cdots,Y[N - 1]$. For $0\\le i \\le N-1$, $Y[i]$ is the price of selling one horse at the end of year $i$.\n- Line $4$: An integer $M$, the number of updates.\n- Lines $5$ to $M+4$: Each line contains three numbers $type$, $pos$, $val$ ($type=1$ means changing $X[ pos ]$ to $val$, $type=2$ means changing $Y[ pos ]$ to $val$).", "outputFormat": "- A total of $M+1$ lines.\n- Line $1$: One integer, the maximum revenue in the initial state modulo $10^9+7$.\n- Lines $2$ to $M+1$: One integer per line, the maximum revenue after this update modulo $10^9+7$.", "hint": "Constraints: for $100\\%$ of the data, $1\\le N\\le 5\\times 10^5$, $0 \\le M \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2015] horses", "background": "", "description": "像他的祖先一样，Mansur 喜欢繁殖马匹。目前，他拥有哈萨克斯坦最大的马场。以前情况可不是这样，$N$ 年前 Mansur 年轻时，他只拥有一匹马，但他一直梦想着成为富豪，最终,他美梦成真。\n\n按照时间的先后顺序将年份编号为 $0$ 到 $N-1$（即 $N-1$ 年是最近的一年）。每年的天气会影响马匹的繁殖。Mansur 用一个正整数 $X[i]$ 记录第 $i$ 年的繁殖系数，如果第 $i$ 年开始时有 $h$ 匹马，那么这一年结束时会有 $h \\times X[i]$ 匹马。\n\n每年，只有年底的时候可以出售马匹。Mansur 用一个正整数 $Y[i]$ 记录第 $i$ 年末卖出一匹马的售价。Mansur 可以卖出任意多匹马，每匹售价均为 $Y[i]$。\n\n现在，Mansur 想知道如果在 $N$ 年中，他总能在最佳时间出售马匹，他能获得的最大收益是多少？你正好在 Mansur 家做客，所以他想请你帮他回答这个问题。\n\nMansur 对记录下的 $X$ 和 $Y$ 做了 $M$ 次更新，每次更新，Mansur 要么改变一个 $X[i]$，要么改变一个 $Y[i]$。每次更新后，他都会问你出售马匹能获得的最大收益。Mansur 的更新是累加的，即你的每个回答时都应该考虑之前的所有更新。注意：某个 $X[i]$ 或者 $Y[i]$ 可能会被更新多次。\n\n对于 Mansur 的问题，实际的答案可能是一个非常大的数字，你只要给出实际答案模 $10^9+7$ 后的结果即可。", "inputFormat": "- 第 $1$ 行，一个整数 $N$，表示总共有 $N$ 年。\n- 第 $2$ 行，共 $N$ 个正整数 $X[0],\\cdots,X[N - 1]$，对于 $0\\le i \\le N-1$，$X[i]$ 表示 $i$ 年的繁殖系数。\n- 第 $3$ 行，共 $N$ 个正整数 $Y[0],\\cdots,Y[N - 1]$，对于 $0\\le i \\le N-1$，$Y[i]$ 表示 $i$ 年末出售一匹马的价格。\n- 第 $4$ 行，一个整数 $M$，表示更新次数。\n- 第 $5,\\cdots,M+4$ 行，每行 $3$ 个数字 $type$，$pos$，$val$ （$type=1$ 表示更改 $X[ pos ]$ 为 $val$，$type=2$ 表示更改 $Y[ pos ]$ 为 $val$）。", "outputFormat": "- 共 $M+1$ 行\n- 第 $1$ 行：一个整数表示初始状态下，Mansur 获得的最大收益模 $10^9+7$ 后的值。\n- 第 $2,\\cdots,M+1$ 行：每行一个整数，表示这次更新后 Mansur 获得的最大收益模 $10^9+7$ 后的值。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 5\\times 10^5$，$0 \\le M \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5875", "type": "P", "difficulty": 5, "samples": [["6\n13 3 6 20 10 15\n0 0 0 1 1 2 2 1 0 0\n", "35\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384]}, "tags": ["2014", "IOI", "交互题"], "title": "[IOI 2014] friend 朋友", "background": "**这是一道交互题**", "description": "我们建立了一个由编号为 $0,\\cdots,n - 1$ 的 $n$ 个人组成的社交网络。网络中的有些对会成为朋友。如果 $x$ 号人成为 $y$ 号人的朋友，则 $y$ 号人同时也会成为 $x$ 号人的朋友。\n\n这些人将通过 $n$ 个阶段加入这个网络，阶段也编号为 $0$ 至 $n−1$。第 $i$ 号人在第 $i$ 个阶段加入。在阶段 $0$，$0$ 号人加入网络并成为唯一的人。此后 $n - 1$ 个阶段的各个阶段，都有一个人会被主持人加入到网络中，而这个主持人可以是已在网络中的任何一个人。在阶段 $i$ 中（$1\\le i\\le n−1$），该阶段的主持人可以用如下三种方式之一把第 $i$ 号人加入到网络中：\n\n- IAmYourFriend：将第 $i$ 号人仅变成主持人的朋友。\n- MyFriendsAreYourFriends：将第 $i$ 号人变成主持人当前的每一个朋友的朋友。 注意，这个方式不会将第 $i$ 号人变成主持人的朋友。\n- WeAreYourFriends：将第 $i$ 号人变成主持人的朋友，同时也变成主持人当前的每一个朋友的朋友。\n\n在建立此网络之后，我们想挑选一个调查的样本，也就是说要从网络中选择一组人。由于朋友之间通常拥有相似的兴趣，因此样本不应包含任何一对互为朋友的人。每个人都会有一个调查的可信度，表示为一个正整数，而我们想要找出一个可信度总和最大的样本。\n\n### 任务\n\n给定各阶段的描述以及每个人的可信度值，请找出一个可信度总和最大的样本。你只需要实现函数 `findSample`。\n\n* `findSample(n, confidence, host, protocol)`\n\t* $n$: 人数.\n\t* `confidence`: 大小为 $n$ 的数组；`confidence[i]` 表示第 $i$ 号人的可信度。\n\t* `host`: 大小为 $n$ 的数组；`host[i]` 表示阶段 i 的主持人。\n\t* `protocol`: 大小为 $n$ 的数组；`protocol[i]` 表示在阶段 （$0<i<n$） 所采用的方式的代码: `0` 代表 IAmYourFriend，`1` 代表 MyFriendsAreYourFriends，而 `2` 代表 WeAreYourFriends。\n\t* 由于在阶段 `0` 中没有主持人，因此 `host[0]` 和 `protocol[0]` 是没有被定义的，而且在你的程序中也不应访问它们。\n\n这个函数应该返回样本可信度总和的最大值。", "inputFormat": "以下为交互库的输入格式。\n\n第 $1$ 行：一个正整数 $n$，为人数。\n\n第 $2$ 行：共 $n$ 个整数 $\\mathrm{confidence}[0],\\ldots,\\mathrm{confidence}[n-1]$.\n\n第 $3$ 行：共 $2n-2$ 个整数 $\\mathrm{host}[1],\\mathrm{protocol}[1], \\mathrm{host}[2], \\mathrm{protocol}[2],\\cdots, \\mathrm{host}[n-1], \\mathrm{protocol}[n-1]$。", "outputFormat": "本题只支持 C++ 系列语言。\n\n你只能提交一个源文件实现上述的函数，其命名与接口需遵循下面的要求。**不需要添加额外的头文件**。\n\n`int findSample(int n, int confidence[], int host[], int protocol[]);`", "hint": "对于 $100\\%$ 的数据，$2 \\le n \\le 10^5$，$1 \\le \\mathrm{confidence}[i] \\le 10^6$。\n\n|**子任务**|**分值**|$n$|**可信度**|**采用的方式**|\n|:-:|:-:|:-:|:-:|:-:|\n|1|$11$|$n\\leq 10$|$1\\leq \\mathrm{confidence}\\leq 10^6$|全部三种方式|\n|2|$8$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|只有 `MyFriendsAreYourFriends`|\n|3|$8$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|只有 `WeAreYourFriends`|\n|4|$19$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|只有 `IAmYourFriend`|\n|5|$23$|$n\\leq 1000$|所有可信度值均为 $1$|只有 `MyFriendsAreYourFriends` 和 `IAmYourFriend` 两种方式|\n|6|$31$|$n\\leq 10^5$|$1\\leq \\mathrm{confidence}\\leq 10^4$|全部三种方式|", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2014] friend", "background": "**This is an interactive problem.**", "description": "We build a social network consisting of $n$ people numbered $0,\\cdots,n - 1$. Some pairs of people in the network will become friends. If person $x$ becomes a friend of person $y$, then person $y$ will also become a friend of person $x$.\n\nThese people will join the network in $n$ stages, also numbered from $0$ to $n-1$. Person $i$ joins in stage $i$. In stage $0$, person $0$ joins the network and is the only person. After that, in each of the remaining $n - 1$ stages, one person will be added to the network by a host, and this host can be any person already in the network. In stage $i$ ($1\\le i\\le n−1$), the host can add person $i$ to the network using one of the following three methods:\n\n- IAmYourFriend: Make person $i$ become friends only with the host.\n- MyFriendsAreYourFriends: Make person $i$ become friends with each of the host's current friends. Note that this method does not make person $i$ become friends with the host.\n- WeAreYourFriends: Make person $i$ become friends with the host, and also become friends with each of the host's current friends.\n\nAfter building the network, we want to choose a survey sample, that is, select a group of people from the network. Since friends usually have similar interests, the sample should not contain any pair of people who are friends with each other. Each person has a survey credibility value, given as a positive integer, and we want to find a sample with the maximum total credibility.\n\n### Task\n\nGiven the description of each stage and the credibility value of each person, find a sample with the maximum total credibility. You only need to implement the function `findSample`.\n\n* `findSample(n, confidence, host, protocol)`\n\t* $n$: the number of people.\n\t* `confidence`: an array of size $n$; `confidence[i]` is the credibility of person $i$.\n\t* `host`: an array of size $n$; `host[i]` is the host of stage $i$.\n\t* `protocol`: an array of size $n$; `protocol[i]` is the code of the method used in stage ($0<i<n$): `0` means IAmYourFriend, `1` means MyFriendsAreYourFriends, and `2` means WeAreYourFriends.\n\t* Since there is no host in stage `0`, `host[0]` and `protocol[0]` are undefined, and your program must not access them.\n\nThis function should return the maximum possible total credibility of the sample.", "inputFormat": "Below is the input format for the interactive library.\n\nLine $1$: a positive integer $n$, the number of people.\n\nLine $2$: $n$ integers $\\mathrm{confidence}[0],\\ldots,\\mathrm{confidence}[n-1]$.\n\nLine $3$: $2n-2$ integers $\\mathrm{host}[1],\\mathrm{protocol}[1], \\mathrm{host}[2], \\mathrm{protocol}[2],\\cdots, \\mathrm{host}[n-1], \\mathrm{protocol}[n-1]$.", "outputFormat": "This problem only supports the C++ language series.\n\nYou can only submit one source file implementing the function above. The name and interface must follow the requirements below. **Do not add extra header files.**\n\n`int findSample(int n, int confidence[], int host[], int protocol[]);`", "hint": "For $100\\%$ of the testdata, $2 \\le n \\le 10^5$, $1 \\le \\mathrm{confidence}[i] \\le 10^6$.\n\n|**Subtask**|**Score**|$n$|**Credibility**|**Method used**|\n|:-:|:-:|:-:|:-:|:-:|\n|1|$11$|$n\\leq 10$|$1\\leq \\mathrm{confidence}\\leq 10^6$|all three methods|\n|2|$8$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|only `MyFriendsAreYourFriends`|\n|3|$8$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|only `WeAreYourFriends`|\n|4|$19$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|only `IAmYourFriend`|\n|5|$23$|$n\\leq 1000$|all credibility values are $1$|only `MyFriendsAreYourFriends` and `IAmYourFriend`|\n|6|$31$|$n\\leq 10^5$|$1\\leq \\mathrm{confidence}\\leq 10^4$|all three methods|\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2014] friend 朋友", "background": "**这是一道交互题**", "description": "我们建立了一个由编号为 $0,\\cdots,n - 1$ 的 $n$ 个人组成的社交网络。网络中的有些对会成为朋友。如果 $x$ 号人成为 $y$ 号人的朋友，则 $y$ 号人同时也会成为 $x$ 号人的朋友。\n\n这些人将通过 $n$ 个阶段加入这个网络，阶段也编号为 $0$ 至 $n−1$。第 $i$ 号人在第 $i$ 个阶段加入。在阶段 $0$，$0$ 号人加入网络并成为唯一的人。此后 $n - 1$ 个阶段的各个阶段，都有一个人会被主持人加入到网络中，而这个主持人可以是已在网络中的任何一个人。在阶段 $i$ 中（$1\\le i\\le n−1$），该阶段的主持人可以用如下三种方式之一把第 $i$ 号人加入到网络中：\n\n- IAmYourFriend：将第 $i$ 号人仅变成主持人的朋友。\n- MyFriendsAreYourFriends：将第 $i$ 号人变成主持人当前的每一个朋友的朋友。 注意，这个方式不会将第 $i$ 号人变成主持人的朋友。\n- WeAreYourFriends：将第 $i$ 号人变成主持人的朋友，同时也变成主持人当前的每一个朋友的朋友。\n\n在建立此网络之后，我们想挑选一个调查的样本，也就是说要从网络中选择一组人。由于朋友之间通常拥有相似的兴趣，因此样本不应包含任何一对互为朋友的人。每个人都会有一个调查的可信度，表示为一个正整数，而我们想要找出一个可信度总和最大的样本。\n\n### 任务\n\n给定各阶段的描述以及每个人的可信度值，请找出一个可信度总和最大的样本。你只需要实现函数 `findSample`。\n\n* `findSample(n, confidence, host, protocol)`\n\t* $n$: 人数.\n\t* `confidence`: 大小为 $n$ 的数组；`confidence[i]` 表示第 $i$ 号人的可信度。\n\t* `host`: 大小为 $n$ 的数组；`host[i]` 表示阶段 i 的主持人。\n\t* `protocol`: 大小为 $n$ 的数组；`protocol[i]` 表示在阶段 （$0<i<n$） 所采用的方式的代码: `0` 代表 IAmYourFriend，`1` 代表 MyFriendsAreYourFriends，而 `2` 代表 WeAreYourFriends。\n\t* 由于在阶段 `0` 中没有主持人，因此 `host[0]` 和 `protocol[0]` 是没有被定义的，而且在你的程序中也不应访问它们。\n\n这个函数应该返回样本可信度总和的最大值。", "inputFormat": "以下为交互库的输入格式。\n\n第 $1$ 行：一个正整数 $n$，为人数。\n\n第 $2$ 行：共 $n$ 个整数 $\\mathrm{confidence}[0],\\ldots,\\mathrm{confidence}[n-1]$.\n\n第 $3$ 行：共 $2n-2$ 个整数 $\\mathrm{host}[1],\\mathrm{protocol}[1], \\mathrm{host}[2], \\mathrm{protocol}[2],\\cdots, \\mathrm{host}[n-1], \\mathrm{protocol}[n-1]$。", "outputFormat": "本题只支持 C++ 系列语言。\n\n你只能提交一个源文件实现上述的函数，其命名与接口需遵循下面的要求。**不需要添加额外的头文件**。\n\n`int findSample(int n, int confidence[], int host[], int protocol[]);`", "hint": "对于 $100\\%$ 的数据，$2 \\le n \\le 10^5$，$1 \\le \\mathrm{confidence}[i] \\le 10^6$。\n\n|**子任务**|**分值**|$n$|**可信度**|**采用的方式**|\n|:-:|:-:|:-:|:-:|:-:|\n|1|$11$|$n\\leq 10$|$1\\leq \\mathrm{confidence}\\leq 10^6$|全部三种方式|\n|2|$8$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|只有 `MyFriendsAreYourFriends`|\n|3|$8$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|只有 `WeAreYourFriends`|\n|4|$19$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|只有 `IAmYourFriend`|\n|5|$23$|$n\\leq 1000$|所有可信度值均为 $1$|只有 `MyFriendsAreYourFriends` 和 `IAmYourFriend` 两种方式|\n|6|$31$|$n\\leq 10^5$|$1\\leq \\mathrm{confidence}\\leq 10^4$|全部三种方式|", "locale": "zh-CN"}}}
{"pid": "P5876", "type": "P", "difficulty": 2, "samples": [["3   \nabc \nefg \nijh", "a\ne\ni\n"], ["3\naac\naad\naae", "aac\naad\naae"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["NOI 导刊"], "title": "化简单词", "background": "", "description": "最近情报人员得到了一些经过加密的文章，每个单词都很长。破译人员想到先把单词化简一下，方法是把每个单词尽量取短些的前缀，但所取的前缀不能是其他单词的前缀。\n\n这个任务现在就交给你来完成。\n\n解释：“字符串 $\\text{S}_1$ 是 $\\text{S}_2$ 的前缀”是说把字符串 $\\text{S}_2$ 的后面去掉某些，只保留与 $\\text{S}_1$ 相同长度时，$\\text{S}_2$ 就与 $\\text{S}_1$ 完全相同。如：$\\texttt{abc}$ 是 $\\texttt{abcaade}$ 和 $\\texttt{abc}$ 的前缀，但不是 $\\texttt{abadc}$ 的前缀。\n", "inputFormat": "第一行一个整数 $N$，表示单词的个数。\n\n下面有 $N$ 行，每行一个单词。", "outputFormat": "共 $N$ 行，每行一个单词，对应上面的 $N$ 个单词化简后的单词。", "hint": "对于 $100\\%$ 的数据，$1 \\le N \\le 50$，每个单词长度不超过 $50$，并且都是由小写字母构成。\n\n保证所给单词没有一个单词是另一个单词的前缀。\n", "locale": "zh-CN", "translations": {"en": {"title": "Simplify Words", "background": "", "description": "Recently, intelligence officers obtained some encrypted articles, and every word is very long. The codebreakers want to simplify the words first. The method is to take, for each word, the shortest possible prefix, but the chosen prefix must not be a prefix of any other word.\n\nThis task is now assigned to you.\n\nExplanation: “String $\\text{S}_1$ is a prefix of $\\text{S}_2$” means that if you delete some characters from the end of string $\\text{S}_2$ and keep only the part with the same length as $\\text{S}_1$, then $\\text{S}_2$ becomes exactly the same as $\\text{S}_1$. For example, $\\texttt{abc}$ is a prefix of $\\texttt{abcaade}$ and $\\texttt{abc}$, but it is not a prefix of $\\texttt{abadc}$.", "inputFormat": "The first line contains an integer $N$, representing the number of words.\n\nThe following $N$ lines each contain one word.", "outputFormat": "Output $N$ lines, each containing one word, which is the simplified version of the corresponding word above.", "hint": "For $100\\%$ of the testdata, $1 \\le N \\le 50$, each word has length at most $50$, and all words consist of lowercase letters.\n\nIt is guaranteed that none of the given words is a prefix of another word.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "化简单词", "background": "", "description": "最近情报人员得到了一些经过加密的文章，每个单词都很长。破译人员想到先把单词化简一下，方法是把每个单词尽量取短些的前缀，但所取的前缀不能是其他单词的前缀。\n\n这个任务现在就交给你来完成。\n\n解释：“字符串 $\\text{S}_1$ 是 $\\text{S}_2$ 的前缀”是说把字符串 $\\text{S}_2$ 的后面去掉某些，只保留与 $\\text{S}_1$ 相同长度时，$\\text{S}_2$ 就与 $\\text{S}_1$ 完全相同。如：$\\texttt{abc}$ 是 $\\texttt{abcaade}$ 和 $\\texttt{abc}$ 的前缀，但不是 $\\texttt{abadc}$ 的前缀。\n", "inputFormat": "第一行一个整数 $N$，表示单词的个数。\n\n下面有 $N$ 行，每行一个单词。", "outputFormat": "共 $N$ 行，每行一个单词，对应上面的 $N$ 个单词化简后的单词。", "hint": "对于 $100\\%$ 的数据，$1 \\le N \\le 50$，每个单词长度不超过 $50$，并且都是由小写字母构成。\n\n保证所给单词没有一个单词是另一个单词的前缀。\n", "locale": "zh-CN"}}}
{"pid": "P5877", "type": "P", "difficulty": 3, "samples": [["3 5    \n1 1 1  \n1 1 2  \n0 2 2  \n1 3 1  \n1 2 1  \n", "1 \n1 \n2 \n3 \n2\n"], ["3 5\n1 1 2\n1 2 1\n1 3 2\n1 2 3\n1 2 2\n", "1\n2\n3\n4\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["并查集", "NOI 导刊"], "title": "棋盘游戏", "background": "", "description": "为了增强幼儿园小朋友的数数能力，小虎老师给了一个家庭游戏作业。让小虎那一块空的围棋盘，随机在一些方格中放些棋子（有黑白两种颜色），如果一个方格和它的上、下、左、右四个方格之一有相同颜色的棋子，则认为两个格子是相互连通的。这期间，要求小虎不断统计共有多少个连通块。\n\n如下图是一个 $5\\times 9$ 的一块棋盘，其中 `.` 表示空格，`*` 表示黑棋子，`@`表示白棋子。\n\n则有 $4$ 块连通子块。\n```\n.  .  .  .  .  .  .  .  .\n.  .  *  *  .  .  @  @  .\n.  *  *  @  @  .  @  @  .\n.  .  *  @  .  .  *  .  .\n.  .  .  .  .  .  .  .  .\n```\n\n哥哥大虎在一边看一边想，如果棋盘是 $N\\times N$ 的，共放了 $M$ 个棋子，如何使用计算机解决这个问题呢？", "inputFormat": "第一行两个整数：$N,M$。\n\n接下来有 $M$ 行，每行三个整数：$c, x, y$。分别表示依次放入棋子的颜色（$0$ 表示白色，$1$ 表示黑色）、要放入格子的横坐标和格子的纵坐标。\n", "outputFormat": "共 $M$ 行。第 $i$ 行一个整数，表示放入第 $i$ 个棋子后，当前有多少个棋子连通块。", "hint": "对于 $30\\%$ 数据：$1\\le N \\le 10$。\n\n对于 $60\\%$ 数据：$1\\le N\\le 100$。\n\n对于 $100\\%$ 数据：$1\\le N\\le 500$，$1\\le M \\le N \\times N$，$ 0 \\le c \\le 1$，$ 1\\le x, y \\le N$。", "locale": "zh-CN", "translations": {"en": {"title": "Board Game.", "background": "", "description": "To improve kindergarten kids’ counting skills, Teacher Xiaohu gave a family game homework. He asked Xiaohu to take an empty Go board and randomly place some pieces (in two colors: black and white) on some cells. If a cell and one of its four neighbors (up, down, left, right) both contain pieces of the same color, then the two cells are considered connected. During this process, Xiaohu must keep counting how many connected components there are in total.\n\nThe figure below shows a $5\\times 9$ board, where `.` means an empty cell, `*` means a black piece, and `@` means a white piece.\n\nThen there are $4$ connected components.\n```\n.  .  .  .  .  .  .  .  .\n.  .  *  *  .  .  @  @  .\n.  *  *  @  @  .  @  @  .\n.  .  *  @  .  .  *  .  .\n.  .  .  .  .  .  .  .  .\n```\n\nBig brother Dahu watched and thought: if the board is $N\\times N$ and a total of $M$ pieces are placed, how can we solve this problem using a computer?", "inputFormat": "The first line contains two integers: $N, M$.\n\nThe next $M$ lines each contain three integers: $c, x, y$. They represent, in order, the color of the piece to be placed ($0$ means white, $1$ means black), the row coordinate, and the column coordinate of the cell where it is placed.", "outputFormat": "Output $M$ lines in total. The $i$-th line contains one integer, which is the number of connected components of pieces after placing the $i$-th piece.", "hint": "For $30\\%$ of the testdata: $1\\le N \\le 10$.\n\nFor $60\\%$ of the testdata: $1\\le N\\le 100$.\n\nFor $100\\%$ of the testdata: $1\\le N\\le 500$, $1\\le M \\le N \\times N$, $ 0 \\le c \\le 1$, $ 1\\le x, y \\le N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "棋盘游戏", "background": "", "description": "为了增强幼儿园小朋友的数数能力，小虎老师给了一个家庭游戏作业。让小虎那一块空的围棋盘，随机在一些方格中放些棋子（有黑白两种颜色），如果一个方格和它的上、下、左、右四个方格之一有相同颜色的棋子，则认为两个格子是相互连通的。这期间，要求小虎不断统计共有多少个连通块。\n\n如下图是一个 $5\\times 9$ 的一块棋盘，其中 `.` 表示空格，`*` 表示黑棋子，`@`表示白棋子。\n\n则有 $4$ 块连通子块。\n```\n.  .  .  .  .  .  .  .  .\n.  .  *  *  .  .  @  @  .\n.  *  *  @  @  .  @  @  .\n.  .  *  @  .  .  *  .  .\n.  .  .  .  .  .  .  .  .\n```\n\n哥哥大虎在一边看一边想，如果棋盘是 $N\\times N$ 的，共放了 $M$ 个棋子，如何使用计算机解决这个问题呢？", "inputFormat": "第一行两个整数：$N,M$。\n\n接下来有 $M$ 行，每行三个整数：$c, x, y$。分别表示依次放入棋子的颜色（$0$ 表示白色，$1$ 表示黑色）、要放入格子的横坐标和格子的纵坐标。\n", "outputFormat": "共 $M$ 行。第 $i$ 行一个整数，表示放入第 $i$ 个棋子后，当前有多少个棋子连通块。", "hint": "对于 $30\\%$ 数据：$1\\le N \\le 10$。\n\n对于 $60\\%$ 数据：$1\\le N\\le 100$。\n\n对于 $100\\%$ 数据：$1\\le N\\le 500$，$1\\le M \\le N \\times N$，$ 0 \\le c \\le 1$，$ 1\\le x, y \\le N$。", "locale": "zh-CN"}}}
{"pid": "P5878", "type": "P", "difficulty": 4, "samples": [["2 100\n10 8 10 10 13 11\n12 20 6 10 17 24\n", "5"], ["3 65\n10 5 7 10 13 14\n10 5 8 11 14 15\n10 5 9 12 15 16\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["NOI 导刊"], "title": "奖品", "background": "", "description": "学校刚开完运动会，准备为尽可能多的同学评奖，并为每个人颁发一份奖品。一份奖品包括 $N$ 个物品，如：$5$ 支铅笔、$10$ 本练习薄等。每份奖品完全一样。虽然学校的保管室里还有一些办去年运动会后剩余的物品。在商店里，每种物品都有很多，但是，只有两种包装：大盒或小盒，并且不拆开买。\n\n现在的问题是，充分利用这 $M$ 元钱，最多可准备多少分这样的奖品？\n", "inputFormat": "第一行两个整数：$N,M$。\n\n下面有 $N$ 行，每行有六个正整数 $x,y,sm,pm,sv,pv$，分别表示一种物品的相关数据：\n\n* $x$，一份奖品中，这种物品需要的件数。\n* $y$，这种物品去年剩余的件数。\n* $sm$，这种物品小包装的件数。\n* $pm$，这种物品小包装的一盒价格。\n* $sv$，这种物品大包装里的件数。\n* $pv$，这种物品大包装的一盒价格。\n", "outputFormat": "一个整数，最多可准备的礼品份数。", "hint": "对于全部的数据，满足：\n\n$1 \\le N \\le 100$，$1 \\le M \\le 10^5$。\n\n$10 \\le x, pm \\le 100$，$1 \\le y, sm \\le 100$，$sm < sv \\le 100$，$pm<pv\\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "Prizes", "background": "", "description": "The school has just finished its sports meeting and plans to give awards to as many students as possible, giving each person a prize. Each prize contains $N$ kinds of items, such as $5$ pencils, $10$ exercise books, and so on. Every prize is exactly the same. The school storeroom still has some items left over from last year’s sports meeting. In the store, there are plenty of each kind of item, but there are only two types of packaging: a large box or a small box, and you must buy whole boxes without opening them.\n\nNow the problem is: with this $M$ yuan, making full use of the money, what is the maximum number of such prizes that can be prepared?", "inputFormat": "The first line contains two integers: $N, M$.\n\nThen there are $N$ lines. Each line contains six positive integers $x, y, sm, pm, sv, pv$, describing one kind of item:\n\n- $x$: the number of this item needed in one prize.\n- $y$: the number of this item left over from last year.\n- $sm$: the number of this item in one small box.\n- $pm$: the price of one small box of this item.\n- $sv$: the number of this item in one large box.\n- $pv$: the price of one large box of this item.", "outputFormat": "Output one integer: the maximum number of prizes that can be prepared.", "hint": "For all testdata, it holds that:\n\n$1 \\le N \\le 100$, $1 \\le M \\le 10^5$.\n\n$10 \\le x, pm \\le 100$, $1 \\le y, sm \\le 100$, $sm < sv \\le 100$, $pm < pv \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "奖品", "background": "", "description": "学校刚开完运动会，准备为尽可能多的同学评奖，并为每个人颁发一份奖品。一份奖品包括 $N$ 个物品，如：$5$ 支铅笔、$10$ 本练习薄等。每份奖品完全一样。虽然学校的保管室里还有一些办去年运动会后剩余的物品。在商店里，每种物品都有很多，但是，只有两种包装：大盒或小盒，并且不拆开买。\n\n现在的问题是，充分利用这 $M$ 元钱，最多可准备多少分这样的奖品？\n", "inputFormat": "第一行两个整数：$N,M$。\n\n下面有 $N$ 行，每行有六个正整数 $x,y,sm,pm,sv,pv$，分别表示一种物品的相关数据：\n\n* $x$，一份奖品中，这种物品需要的件数。\n* $y$，这种物品去年剩余的件数。\n* $sm$，这种物品小包装的件数。\n* $pm$，这种物品小包装的一盒价格。\n* $sv$，这种物品大包装里的件数。\n* $pv$，这种物品大包装的一盒价格。\n", "outputFormat": "一个整数，最多可准备的礼品份数。", "hint": "对于全部的数据，满足：\n\n$1 \\le N \\le 100$，$1 \\le M \\le 10^5$。\n\n$10 \\le x, pm \\le 100$，$1 \\le y, sm \\le 100$，$sm < sv \\le 100$，$pm<pv\\le 100$。", "locale": "zh-CN"}}}
{"pid": "P5879", "type": "P", "difficulty": 4, "samples": [["2", "4"], ["3", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["NOI 导刊"], "title": "放棋子", "background": "", "description": "小虎刚刚上了幼儿园，老师让他做一个家庭作业：首先画 $3$ 行格子，第一行有三个格子，第二行有 $2$ 个格子，第三行有 $1$ 个格子。每行的格子从左到右可以放棋子，但要求除第一行外，每行放的棋子数不能超过上一行的棋子。第一行的棋子数不能为 $0$，但剩下行可以为空。玩了一会儿，小虎对哥哥大虎说：”这个作业有很多种摆放法，我想找到，但我不知道有多少种方案，你能帮助我吗？”\n\n大虎是学校信息学集训队的，立刻想到用计算机来解决这个问题，并很快有了解答：$13$。\n\n第二天他把问题拿到学校，并说如果第一行有 $N$ 个格子，第二行有 $N-1$ 个格子，……，第 $N$ 行有 $1$ 个格子，怎么办？现在请你一块来帮助他解决这个难题。", "inputFormat": "仅一行，一个正整数 $N$。", "outputFormat": "一行，方案总数。", "hint": "样例 1 说明：$N=2$ 时，有如下 $4$ 种摆放棋子法（`*` 表示棋子，`_` 表示空格）：\n|  方案数| 1 | 2 | 3 | 4 |\n| :----------- | :----------- | :----------- | :----------- | :----------- |\n| **第一行** | `*_` | `**` | `*_` | `**` |\n| **第二行** | `_` | `_` | `*` | `*` |\n\n\n对于 $30\\%$ 数据：$1\\le N\\le 12$。\n\n对于 $50\\%$ 数据：$1\\le N\\le 30$。\n\n对于 $100\\%$ 数据：$1\\le N\\le 100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Placing Pieces", "background": "", "description": "Xiaohu has just started kindergarten. The teacher gave him homework: first draw $3$ rows of cells. The first row has $3$ cells, the second row has $2$ cells, and the third row has $1$ cell. In each row, pieces can be placed from left to right, but except for the first row, the number of pieces placed in each row cannot exceed the number of pieces in the previous row. The number of pieces in the first row cannot be $0$, but the remaining rows may be empty. After playing for a while, Xiaohu said to his older brother Dahu: “There are many ways to place the pieces for this homework. I want to find them, but I do not know how many arrangements there are. Can you help me?”\n\nDahu is in the school’s informatics training team, and he immediately thought of using a computer to solve this problem. He quickly got the answer: $13$.\n\nThe next day, he brought the problem to school and asked: what if the first row has $N$ cells, the second row has $N-1$ cells, …, and the $N$-th row has $1$ cell? Now please help him solve this difficult problem.", "inputFormat": "Only one line: a positive integer $N$.", "outputFormat": "One line: the total number of arrangements.", "hint": "Explanation for Sample 1: when $N=2$, there are the following $4$ ways to place pieces (`*` represents a piece, `_` represents an empty cell):\n|  Arrangement | 1 | 2 | 3 | 4 |\n| :----------- | :----------- | :----------- | :----------- | :----------- |\n| **First row** | `*_` | `**` | `*_` | `**` |\n| **Second row** | `_` | `_` | `*` | `*` |\n\nConstraints:\n\nFor $30\\%$ of the testdata: $1\\le N\\le 12$.\n\nFor $50\\%$ of the testdata: $1\\le N\\le 30$.\n\nFor $100\\%$ of the testdata: $1\\le N\\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "放棋子", "background": "", "description": "小虎刚刚上了幼儿园，老师让他做一个家庭作业：首先画 $3$ 行格子，第一行有三个格子，第二行有 $2$ 个格子，第三行有 $1$ 个格子。每行的格子从左到右可以放棋子，但要求除第一行外，每行放的棋子数不能超过上一行的棋子。第一行的棋子数不能为 $0$，但剩下行可以为空。玩了一会儿，小虎对哥哥大虎说：”这个作业有很多种摆放法，我想找到，但我不知道有多少种方案，你能帮助我吗？”\n\n大虎是学校信息学集训队的，立刻想到用计算机来解决这个问题，并很快有了解答：$13$。\n\n第二天他把问题拿到学校，并说如果第一行有 $N$ 个格子，第二行有 $N-1$ 个格子，……，第 $N$ 行有 $1$ 个格子，怎么办？现在请你一块来帮助他解决这个难题。", "inputFormat": "仅一行，一个正整数 $N$。", "outputFormat": "一行，方案总数。", "hint": "样例 1 说明：$N=2$ 时，有如下 $4$ 种摆放棋子法（`*` 表示棋子，`_` 表示空格）：\n|  方案数| 1 | 2 | 3 | 4 |\n| :----------- | :----------- | :----------- | :----------- | :----------- |\n| **第一行** | `*_` | `**` | `*_` | `**` |\n| **第二行** | `_` | `_` | `*` | `*` |\n\n\n对于 $30\\%$ 数据：$1\\le N\\le 12$。\n\n对于 $50\\%$ 数据：$1\\le N\\le 30$。\n\n对于 $100\\%$ 数据：$1\\le N\\le 100$。\n", "locale": "zh-CN"}}}
{"pid": "P5880", "type": "P", "difficulty": 4, "samples": [["4\n1 1 1 1\n", "28"], ["3\n1 2 3\n", "68"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000]}, "tags": ["O2优化", "组合数学", "排列组合"], "title": "【地理】划分", "background": "小蒟建立了一个城市，$\\texttt{TA}$ 凭借优（cu）异（bi）的人文地理素养，管理着城市并进行规划。", "description": "对于一座新建的城市，可以将其视为一片连通的区域。\n\n现在，小蒟需要建造一些道路，将城市分为若干片互不连通的区域。\n\n首先，小蒟要建造 $a_1$ 条主干道。主干道是一条贯通整个城市的直线。\n\n接着，小蒟要建造 $a_2$ 个环岛。环岛是一条首尾相接的圆形道路。\n\n然后，小蒟要建造一些道路网络。这些道路网络包括 $a_3$ 条正三角形道路（即三条道路连成一个封闭的三角形），$a_4$ 条正四边形道路……$a_n$ 条正 $n$ 边形道路。\n\n小蒟希望用这些道路将城市划分为尽可能多片互不连通区域。可是他不会计算最多能划分成为多少个区域，所以他只能来求助你。\n\n由于最后的答案可能很大很大，你只需要输出答案对 $10^9+7$ 取模的值。", "inputFormat": "第一行，一个正整数 $n$，代表小蒟的计划中边数最多的道路网络是几边形。\n\n第二行，$n$ 个整数，为 $a_{1\\dots n}$。\n", "outputFormat": "一行一个整数，表示答案对 $10^9+7$ 取模后的值。", "hint": "#### 样例解释#1\n\n如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ntmr3tgn.png)\n\n#### 数据范围\n\n对于 $20\\%$ 的数据：$1\\le n \\le 10^3$，$0 \\le a_i \\le 100$。\n\n对于 $100\\%$ 的数据：$1\\le n \\le 3 \\times 10^6$，$0 \\le a_i \\le 10^3$。\n\n**注意内存限制，你的 UKE 很有可能就是 MLE**。\n\n**若 $n=1$ 则只存在直线道路，若 $n=2$ 则只存在直线道路和圆形道路。**", "locale": "zh-CN", "translations": {"en": {"title": "[Geography] Partition", "background": "Xiao Ju built a city. With excellent (and “cheating-level”) human geography skills, $\\texttt{TA}$ manages and plans the city.", "description": "For a newly built city, we can treat it as one connected region.\n\nNow, Xiao Ju needs to build some roads to divide the city into several regions that are disconnected from each other.\n\nFirst, Xiao Ju will build $a_1$ trunk roads. A trunk road is a straight line that goes through the entire city.\n\nNext, Xiao Ju will build $a_2$ roundabouts. A roundabout is a circular road whose start and end connect together.\n\nThen, Xiao Ju will build some road networks. These road networks include $a_3$ regular triangle roads (that is, three roads form a closed triangle), $a_4$ regular quadrilateral roads, $\\ldots$, and $a_n$ regular $n$-gon roads.\n\nXiao Ju wants to use these roads to partition the city into as many disconnected regions as possible. But he cannot compute the maximum number of regions, so he asks you for help.\n\nSince the final answer may be extremely large, you only need to output the answer modulo $10^9+7$.", "inputFormat": "The first line contains a positive integer $n$, meaning that in Xiao Ju’s plan, the road network with the largest number of sides is an $n$-gon.\n\nThe second line contains $n$ integers, which are $a_{1\\dots n}$.", "outputFormat": "Output one integer per line, the answer modulo $10^9+7$.", "hint": "#### Sample Explanation #1\n\nAs shown in the figure below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ntmr3tgn.png)\n\n#### Constraints\n\nFor $20\\%$ of the testdata: $1\\le n \\le 10^3$, $0 \\le a_i \\le 100$.\n\nFor $100\\%$ of the testdata: $1\\le n \\le 3 \\times 10^6$, $0 \\le a_i \\le 10^3$.\n\n**Note the memory limit: your UKE is very likely to get MLE**.\n\n**If $n=1$, then only straight roads exist. If $n=2$, then only straight roads and circular roads exist.**\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【地理】划分", "background": "小蒟建立了一个城市，$\\texttt{TA}$ 凭借优（cu）异（bi）的人文地理素养，管理着城市并进行规划。", "description": "对于一座新建的城市，可以将其视为一片连通的区域。\n\n现在，小蒟需要建造一些道路，将城市分为若干片互不连通的区域。\n\n首先，小蒟要建造 $a_1$ 条主干道。主干道是一条贯通整个城市的直线。\n\n接着，小蒟要建造 $a_2$ 个环岛。环岛是一条首尾相接的圆形道路。\n\n然后，小蒟要建造一些道路网络。这些道路网络包括 $a_3$ 条正三角形道路（即三条道路连成一个封闭的三角形），$a_4$ 条正四边形道路……$a_n$ 条正 $n$ 边形道路。\n\n小蒟希望用这些道路将城市划分为尽可能多片互不连通区域。可是他不会计算最多能划分成为多少个区域，所以他只能来求助你。\n\n由于最后的答案可能很大很大，你只需要输出答案对 $10^9+7$ 取模的值。", "inputFormat": "第一行，一个正整数 $n$，代表小蒟的计划中边数最多的道路网络是几边形。\n\n第二行，$n$ 个整数，为 $a_{1\\dots n}$。\n", "outputFormat": "一行一个整数，表示答案对 $10^9+7$ 取模后的值。", "hint": "#### 样例解释#1\n\n如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ntmr3tgn.png)\n\n#### 数据范围\n\n对于 $20\\%$ 的数据：$1\\le n \\le 10^3$，$0 \\le a_i \\le 100$。\n\n对于 $100\\%$ 的数据：$1\\le n \\le 3 \\times 10^6$，$0 \\le a_i \\le 10^3$。\n\n**注意内存限制，你的 UKE 很有可能就是 MLE**。\n\n**若 $n=1$ 则只存在直线道路，若 $n=2$ 则只存在直线道路和圆形道路。**", "locale": "zh-CN"}}}
{"pid": "P5881", "type": "P", "difficulty": 6, "samples": [["5 5\n36 72 4 9 16\n2 4 6 8 10\n2 3 4 5 6\n", "3 5\n4 7\n4 7\n4 7\n5 8"]], "limits": {"time": [1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "并查集", "O2优化", "素数判断,质数,筛法"], "title": "【化学】实验", "background": "小 Z 紧张地坐在了一张化学实验桌前，进行着化学实验。\n\n教室里又传来了一阵哀叹声：\n\n我…我好像又错了…我能再试一次吗?", "description": "在她的面前，摆放着 $n$ 个试管。试管里装着不明液体。对于每种不明液体，有 $2$ 个已知的化学属性：$a$ 和 $b$。第 $i$ 种液体的两个属性值分别为 $a_i$ 和 $b_i$。\n\n现在，老师给她布置了 $m$ 个实验。\n\n对于每一次实验，有一个参照量 $x$（第 $i$ 次实验的参照量记作 $x_i$）。她需要把不明液体分成尽可能多的组，且满足：任意两种不同组的液体$i$和$j$， $\\operatorname{gcsd(a_i,a_j)}$ 都不能大于 $x^2$。\n\n其中 $\\operatorname{gcsd}$ 代表他们的最大公约平方数。$k$是两个数的公约平方数，当且仅当满足以下两个条件：\n\n- $k$ 为这两个数的公约数；\n\n- $k$ 为完全平方数。\n\n而最大公约平方数 $\\operatorname{gcsd}$ 为所有满足条件的 $k$ 中的最大者。\n\n形象的说， $\\operatorname{gcsd}$ 可以理解成两个数的最大公约数的算术平方根的整数因式部分的平方。\n\n例如：\n\n求 $\\operatorname{gcsd(24,64)}$，就是先求出 $24,64$ 的最大公约数，是 $8$ ，然后 $\\sqrt 8=2\\sqrt 2$，其整数因式是 $2$，所以 $\\operatorname{gcsd(24,64)}=2^2=4$。\n\n她还需要在分组数最多的情况下，使自己的实验得分最大。\n\n实验得分的定义：对于每一种试剂，定义其得分 $c_i$ 为 $b_i$ 分解质因数之后最大的**指数**。\n\n例如：$b_i=12=2^2\\times 3^1$，$c_i=\\max\\{2,1\\}=2$。\n\n$b_i=90=2^1\\times 3^2\\times 5^1$，$c_i=\\max\\{1,2,1\\}=2$。\n\n而实验得分即为所有组内的 $c_i$ 的最大值之和。\n\n当然，她的 $IQ$ 并不高，所以需要请求你的帮助。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$。\n\n第三行 $n$ 个整数 $b_{1\\dots n}$。\n\n第四行 $m$ 个整数 $x_{1\\dots m}$。", "outputFormat": "共 $m$ 行，对于第 $i$ 行，输出 $2$ 个整数：第 $i$ 次试验的组数和实验得分。", "hint": "#### 样例解释 #1\n\n$b_1=2=2^1,c_1=1$。\n\n$b_2=4=2^2,c_2=2$。\n\n$b_3=6=2^1\\times 3^1,c_3=\\max\\{1,1\\}=1$。\n\n$b_4=8=2^3,c_4=3$。\n\n$b_5=10=2^1\\times 5^1,c_5=\\max\\{1,1\\}=1$。\n\n当 $x=2$ 时，可分为三组：$\\{1,2,4\\},\\{3\\},\\{5\\}$。\n\n实验得分为$\\max\\{1,2,3\\}+\\max\\{1\\}+\\max\\{1\\}=5$。\n\n----------\n\n#### 数据范围\n\n**「本题采用捆绑测试」**\n\n| subtask | $n\\le$ | $m\\le$ | $a_i \\le$ | $b_i\\le$ | $x \\le$ | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |:-----------:|\n| $1$ | $4$ | $6$ | $100$ | $4 \\times 10^4$ | $100$ | $5$ |\n| $2$ | $8$ | $7$ | $20$ | $10^3$ | $10$ | $5$ |\n| $3$ |$20$ | $30$ | $50$ | $8 \\times 10^3$ | $100$ | $10$ |\n| $4$ |$100$ | $60$ | $100$ | $4 \\times 10^4$ | $10^3$ | $10$ |\n| $5$ |$5 \\times 10^3$ | $110$ |  $10^3$| $10^5$ | $4 \\times 10^3$ | $10$ |\n| $6$ |$2 \\times 10^4$ | $250$ | $3 \\times 10^3$ | $10^6$ | $3 \\times 10^3$ | $10$ |\n| $7$ |$ 5 \\times 10^4$| $10^3$ | $10^4$ | $2 \\times 10^7$ | $1.5 \\times 10^4$ | $15$ |\n| $8$ |$10^5$  | $8 \\times 10^3$ | $2 \\times 10^4$ | $2 \\times 10^7$ | $2.2 \\times 10^4$ | $15$ |\n| $9$ |$2 \\times 10^5$  | $2 \\times 10^5$ | $4 \\times 10^4$ | $2 \\times 10^7$ | $3 \\times 10^4$ | $20$ |\n\n\n对于 $100\\%$ 的数据：\n\n$1 \\le n,m \\le 2\\times 10^5$，$2 \\le a_i \\le 4\\times 10^4$，$2 \\le b_i \\le 2\\times 10^7$，$2 \\le x \\le 3\\times 10^4$。\n\n我$\\dots$我好像又错了$\\dots$我能再试一次吗?", "locale": "zh-CN", "translations": {"en": {"title": "[Chemistry] Experiment", "background": "Xiao Z sat nervously in front of a chemistry lab table, doing a chemistry experiment.\n\nA sigh came from the classroom again:\n\nI... I think I made a mistake again... Can I try one more time?", "description": "In front of her, there are $n$ test tubes. Each test tube contains an unknown liquid. For each kind of unknown liquid, there are $2$ known chemical attributes: $a$ and $b$. The two attribute values of the $i$-th liquid are $a_i$ and $b_i$.\n\nNow, the teacher assigns her $m$ experiments.\n\nFor each experiment, there is a reference value $x$ (the reference value of the $i$-th experiment is denoted as $x_i$). She needs to divide the unknown liquids into as many groups as possible, such that: for any two liquids $i$ and $j$ in different groups, $\\operatorname{gcsd(a_i,a_j)}$ must not be greater than $x^2$.\n\nHere, $\\operatorname{gcsd}$ denotes the greatest common square divisor. $k$ is a common square divisor of two numbers if and only if it satisfies both of the following:\n\n- $k$ is a common divisor of the two numbers;\n- $k$ is a perfect square.\n\nThe greatest common square divisor $\\operatorname{gcsd}$ is the maximum $k$ among all $k$ that satisfy the conditions.\n\nIntuitively, $\\operatorname{gcsd}$ can be understood as: take the greatest common divisor of the two numbers, take its square root, keep only the integer factor part, and then square it back.\n\nFor example:\n\nTo compute $\\operatorname{gcsd(24,64)}$, first compute the greatest common divisor of $24$ and $64$, which is $8$. Then $\\sqrt 8=2\\sqrt 2$. Its integer factor is $2$, so $\\operatorname{gcsd(24,64)}=2^2=4$.\n\nShe also needs, under the condition that the number of groups is maximized, to maximize her experiment score.\n\nDefinition of the experiment score: for each reagent, define its score $c_i$ as the largest **exponent** in the prime factorization of $b_i$.\n\nFor example: $b_i=12=2^2\\times 3^1$, so $c_i=\\max\\{2,1\\}=2$.\n\n$b_i=90=2^1\\times 3^2\\times 5^1$, so $c_i=\\max\\{1,2,1\\}=2$.\n\nThe experiment score is the sum, over all groups, of the maximum $c_i$ within each group.\n\nOf course, her $IQ$ is not very high, so she needs to ask for your help.", "inputFormat": "The first line contains two integers $n,m$.\n\nThe second line contains $n$ integers $a_{1\\dots n}$.\n\nThe third line contains $n$ integers $b_{1\\dots n}$.\n\nThe fourth line contains $m$ integers $x_{1\\dots m}$.", "outputFormat": "Output $m$ lines. For the $i$-th line, output $2$ integers: the number of groups and the experiment score for the $i$-th experiment.", "hint": "#### Sample Explanation #1\n\n$b_1=2=2^1,c_1=1$.\n\n$b_2=4=2^2,c_2=2$.\n\n$b_3=6=2^1\\times 3^1,c_3=\\max\\{1,1\\}=1$.\n\n$b_4=8=2^3,c_4=3$.\n\n$b_5=10=2^1\\times 5^1,c_5=\\max\\{1,1\\}=1$.\n\nWhen $x=2$, it can be divided into three groups: $\\{1,2,4\\},\\{3\\},\\{5\\}$.\n\nThe experiment score is $\\max\\{1,2,3\\}+\\max\\{1\\}+\\max\\{1\\}=5$.\n\n----------\n\n#### Constraints\n\n**\"This problem uses bundled testdata.\"**\n\n| subtask | $n\\le$ | $m\\le$ | $a_i \\le$ | $b_i\\le$ | $x \\le$ | Score |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |:-----------:|\n| $1$ | $4$ | $6$ | $100$ | $4 \\times 10^4$ | $100$ | $5$ |\n| $2$ | $8$ | $7$ | $20$ | $10^3$ | $10$ | $5$ |\n| $3$ |$20$ | $30$ | $50$ | $8 \\times 10^3$ | $100$ | $10$ |\n| $4$ |$100$ | $60$ | $100$ | $4 \\times 10^4$ | $10^3$ | $10$ |\n| $5$ |$5 \\times 10^3$ | $110$ |  $10^3$| $10^5$ | $4 \\times 10^3$ | $10$ |\n| $6$ |$2 \\times 10^4$ | $250$ | $3 \\times 10^3$ | $10^6$ | $3 \\times 10^3$ | $10$ |\n| $7$ |$ 5 \\times 10^4$| $10^3$ | $10^4$ | $2 \\times 10^7$ | $1.5 \\times 10^4$ | $15$ |\n| $8$ |$10^5$  | $8 \\times 10^3$ | $2 \\times 10^4$ | $2 \\times 10^7$ | $2.2 \\times 10^4$ | $15$ |\n| $9$ |$2 \\times 10^5$  | $2 \\times 10^5$ | $4 \\times 10^4$ | $2 \\times 10^7$ | $3 \\times 10^4$ | $20$ |\n\nFor $100\\%$ of the data:\n\n$1 \\le n,m \\le 2\\times 10^5$, $2 \\le a_i \\le 4\\times 10^4$, $2 \\le b_i \\le 2\\times 10^7$, $2 \\le x \\le 3\\times 10^4$.\n\nI... I think I made a mistake again... Can I try one more time?\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【化学】实验", "background": "小 Z 紧张地坐在了一张化学实验桌前，进行着化学实验。\n\n教室里又传来了一阵哀叹声：\n\n我…我好像又错了…我能再试一次吗?", "description": "在她的面前，摆放着 $n$ 个试管。试管里装着不明液体。对于每种不明液体，有 $2$ 个已知的化学属性：$a$ 和 $b$。第 $i$ 种液体的两个属性值分别为 $a_i$ 和 $b_i$。\n\n现在，老师给她布置了 $m$ 个实验。\n\n对于每一次实验，有一个参照量 $x$（第 $i$ 次实验的参照量记作 $x_i$）。她需要把不明液体分成尽可能多的组，且满足：任意两种不同组的液体$i$和$j$， $\\operatorname{gcsd(a_i,a_j)}$ 都不能大于 $x^2$。\n\n其中 $\\operatorname{gcsd}$ 代表他们的最大公约平方数。$k$是两个数的公约平方数，当且仅当满足以下两个条件：\n\n- $k$ 为这两个数的公约数；\n\n- $k$ 为完全平方数。\n\n而最大公约平方数 $\\operatorname{gcsd}$ 为所有满足条件的 $k$ 中的最大者。\n\n形象的说， $\\operatorname{gcsd}$ 可以理解成两个数的最大公约数的算术平方根的整数因式部分的平方。\n\n例如：\n\n求 $\\operatorname{gcsd(24,64)}$，就是先求出 $24,64$ 的最大公约数，是 $8$ ，然后 $\\sqrt 8=2\\sqrt 2$，其整数因式是 $2$，所以 $\\operatorname{gcsd(24,64)}=2^2=4$。\n\n她还需要在分组数最多的情况下，使自己的实验得分最大。\n\n实验得分的定义：对于每一种试剂，定义其得分 $c_i$ 为 $b_i$ 分解质因数之后最大的**指数**。\n\n例如：$b_i=12=2^2\\times 3^1$，$c_i=\\max\\{2,1\\}=2$。\n\n$b_i=90=2^1\\times 3^2\\times 5^1$，$c_i=\\max\\{1,2,1\\}=2$。\n\n而实验得分即为所有组内的 $c_i$ 的最大值之和。\n\n当然，她的 $IQ$ 并不高，所以需要请求你的帮助。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$。\n\n第三行 $n$ 个整数 $b_{1\\dots n}$。\n\n第四行 $m$ 个整数 $x_{1\\dots m}$。", "outputFormat": "共 $m$ 行，对于第 $i$ 行，输出 $2$ 个整数：第 $i$ 次试验的组数和实验得分。", "hint": "#### 样例解释 #1\n\n$b_1=2=2^1,c_1=1$。\n\n$b_2=4=2^2,c_2=2$。\n\n$b_3=6=2^1\\times 3^1,c_3=\\max\\{1,1\\}=1$。\n\n$b_4=8=2^3,c_4=3$。\n\n$b_5=10=2^1\\times 5^1,c_5=\\max\\{1,1\\}=1$。\n\n当 $x=2$ 时，可分为三组：$\\{1,2,4\\},\\{3\\},\\{5\\}$。\n\n实验得分为$\\max\\{1,2,3\\}+\\max\\{1\\}+\\max\\{1\\}=5$。\n\n----------\n\n#### 数据范围\n\n**「本题采用捆绑测试」**\n\n| subtask | $n\\le$ | $m\\le$ | $a_i \\le$ | $b_i\\le$ | $x \\le$ | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |:-----------:|\n| $1$ | $4$ | $6$ | $100$ | $4 \\times 10^4$ | $100$ | $5$ |\n| $2$ | $8$ | $7$ | $20$ | $10^3$ | $10$ | $5$ |\n| $3$ |$20$ | $30$ | $50$ | $8 \\times 10^3$ | $100$ | $10$ |\n| $4$ |$100$ | $60$ | $100$ | $4 \\times 10^4$ | $10^3$ | $10$ |\n| $5$ |$5 \\times 10^3$ | $110$ |  $10^3$| $10^5$ | $4 \\times 10^3$ | $10$ |\n| $6$ |$2 \\times 10^4$ | $250$ | $3 \\times 10^3$ | $10^6$ | $3 \\times 10^3$ | $10$ |\n| $7$ |$ 5 \\times 10^4$| $10^3$ | $10^4$ | $2 \\times 10^7$ | $1.5 \\times 10^4$ | $15$ |\n| $8$ |$10^5$  | $8 \\times 10^3$ | $2 \\times 10^4$ | $2 \\times 10^7$ | $2.2 \\times 10^4$ | $15$ |\n| $9$ |$2 \\times 10^5$  | $2 \\times 10^5$ | $4 \\times 10^4$ | $2 \\times 10^7$ | $3 \\times 10^4$ | $20$ |\n\n\n对于 $100\\%$ 的数据：\n\n$1 \\le n,m \\le 2\\times 10^5$，$2 \\le a_i \\le 4\\times 10^4$，$2 \\le b_i \\le 2\\times 10^7$，$2 \\le x \\le 3\\times 10^4$。\n\n我$\\dots$我好像又错了$\\dots$我能再试一次吗?", "locale": "zh-CN"}}}
{"pid": "P5882", "type": "P", "difficulty": 5, "samples": [["5 5\n1\n2\n3\n4\n5\n1 2 2 0.7\n3 4 2 0.9\n1 3 1 1.1\n2 4 1 1.3\n4 5 10 2\n", "4.762887\n8.621053\n9.378947\n67.237113\n0.000000\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "Special Judge", "CTSC/CTS"], "title": "[CTSC2015] misc", "background": "", "description": "小强和 B 君是好朋友。 \n\n小强除了 B 君还有很多好朋友，比如洁妹。 \n\nB 君除了小强也还有很多好朋友，比如R君。他们还有很多共同的好朋友，比如小花，葱娘和其他 $3$ 个人。 \n\nB 君发现，人与人之间的关系可以看成是一个无向图，每个人看成一个点，人与人之间的关系看成一条边。 \n\n不同的人在社会中的号召力不一样，我们用 $a_i$ 来表示第 $i$ 个人的号召力。 \n\n人与人之间的关系也各不相同，可能非常友好，可能只是泛泛之交；可能天天腻在一起，可能一年才联系一次。为此，我们用长度边权 $b_j$ 来刻画第 $j$ 条边对应的两个用户的亲密程度，长度约小，双方就越亲密；同时，我们用宽度边权 $c_j$ 来刻画第 $j$ 条边对应的两个用户的交流频率，宽度越大，两个人沟通的频率也就越高。\n\n一条路径的长度指的是这条路径上的所有边的长度边权之和，一条路径的宽度指的是这条路径上的所有边的宽度边权的乘积。 \n\n当两个人 $s$ 和 $t$ 想要交流的时候，他们会选择长度最短的路径来交流。由于最短路可能有多个，我们称 $s$ 到 $t$ 的最短路的宽度为 $\\sigma_{st}$，是所有 $s$ 到 $t$ 的长度最短的路径的宽度和。同时，我们用 $\\sigma_{st} (v)$ 表示所有从 $s$ 到 $t$，且经过 $v$ 的长度最短的路径的宽度和，即 $v$ 对 $s$,$t$ 的影响力。 \n一个人 $v$ 在图中的传播力 $R(v)$ 可以被定义为如下函数： \n\n $$R(v)=\\sum\\limits_{s \\ne v \\ne t} \\frac{a_s a_t \\sigma_{st}(v)}{\\sigma_{st}}$$\n\n即对图中所有不包含 $v$ 的点对，分别计算 $v$ 对该点对的影响力除以该点对的最短路的宽度，再乘上这个点对中两个点的号召力，最后将所有点对的计算结果加和得到节点在图中的传播力。\n \nB 君想快速知道所有节点在图中的传播力。当他去问小强的时候，小强说：“我有一个绝妙的做法，可惜题面太短，写不下。” \n\n你知道怎么做吗？ ", "inputFormat": "第一行包含 $2$ 个正整数 $n$,$m$，分别表示图的点数和边数。 \n\n接下来 $n$ 行中的第 $i$ 行有 $1$ 个非负整数 $a_i$，表示第 $i$ 个人的号召力。 \n接下来 $m$ 行中的第 $j$ 行有 $3$ 个整数 $x_j$,$y_j$,$b_j$ 和一个实数 $c_j$ ，表示点 $x_j$ 和点 $y_j$ 之间有一条长度边权为 $b_j$，宽度边权为 $c_j$ 的边。 ", "outputFormat": "共 $n$ 行，每行一个实数 $R(i)$，表示第 $i$ 个点在图中的传播力。 ", "hint": "**评分标准**\n\n我们会将输出文件的每个数与参考答案进行比较，如果该数与参考答案的相对误差或绝对误差不超过 $10^{-6}$，则判定该数正确。对于参考答案为 $0$ 的数，必须满足绝对误差不超过 $10^{-6}$ 才判定为正确。 \n\n如果输出正确数的个数为 $q$，那么你在该测试点上的得分是 $\\left\\lfloor\\ 5(\\dfrac{q}{n})^7 \\right\\rfloor$ \n\n**数据规模和约定** \n\n对于测试点 $1$,$2$,$3$,$4$，有 $n \\le 100$。 \n\n对于测试点 $5$,$6$,$7$,$8$，所有 $b_j=1$。 \n\n对于测试点 $9$,$10$,$11$,$12$，有 $m=n-1$。 \n\n对于测试点 $1$,$3$,$5$,$7$,$9$,$11$,$13$,$15$,$17$,$19$，所有 $a_i=1$。 \n\n对于测试点 $1$,$2$,$5$,$6$,$9$,$10$,$13$,$14$,$17$,$18$，所有 $c_j=1$。 \n\n对于所有的数据，有 $n \\le 1000$，$m \\le 4 \\times 10^3$，$0<a_j \\le 255$，$0<b_j \\le 15$，$0.5 \\le c_j \\le 2$，$c_j$ 的小数部分最多 $12$ 位。数据保证图是连通的。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2015] misc", "background": "", "description": "Xiaoqiang and Mr. B are good friends.\n\nBesides Mr. B, Xiaoqiang also has many good friends, such as Jie Mei.\n\nBesides Xiaoqiang, Mr. B also has many good friends, such as Mr. R. They also have many mutual friends, such as Xiaohua, Cong Niang, and another $3$ people.\n\nMr. B realized that relationships between people can be viewed as an undirected graph: each person is a vertex, and each relationship is an edge.\n\nDifferent people have different influence in society. Let $a_i$ denote the influence of the $i$-th person.\n\nRelationships between people also vary: they may be very close, or just casual acquaintances; they may stick together every day, or contact only once a year. Therefore, we use a length edge weight $b_j$ to describe the closeness of the two users connected by the $j$-th edge: the smaller the length, the closer they are. At the same time, we use a width edge weight $c_j$ to describe the communication frequency of the two users connected by the $j$-th edge: the larger the width, the more frequently they communicate.\n\nThe length of a path is the sum of the length edge weights of all edges on the path. The width of a path is the product of the width edge weights of all edges on the path.\n\nWhen two people $s$ and $t$ want to communicate, they will choose a shortest path (in terms of length). Since there may be multiple shortest paths, we define the width of the shortest paths from $s$ to $t$ as $\\sigma_{st}$, which is the sum of the widths of all shortest (minimum-length) paths from $s$ to $t$. Also, let $\\sigma_{st}(v)$ denote the sum of the widths of all shortest paths from $s$ to $t$ that pass through $v$, i.e., the influence of $v$ on $s,t$.\n\nThe spreading power $R(v)$ of a person $v$ in the graph is defined as:\n\n$$R(v)=\\sum\\limits_{s \\ne v \\ne t} \\frac{a_s a_t \\sigma_{st}(v)}{\\sigma_{st}}$$\n\nThat is, for all ordered pairs of vertices in the graph that do not include $v$, compute the influence of $v$ on that pair divided by the total width of the shortest paths for that pair, then multiply by the influences of the two endpoints, and finally sum the results over all such pairs to obtain the spreading power of the vertex.\n\nMr. B wants to quickly know the spreading power of every vertex in the graph. When he asked Xiaoqiang, Xiaoqiang said: “I have a brilliant method, but the statement is too short to write it down.”\n\nDo you know how to do it?", "inputFormat": "The first line contains $2$ positive integers $n$ and $m$, representing the number of vertices and the number of edges in the graph.\n\nThe next $n$ lines: the $i$-th line contains one non-negative integer $a_i$, representing the influence of the $i$-th person.\n\nThe next $m$ lines: the $j$-th line contains $3$ integers $x_j$, $y_j$, $b_j$ and one real number $c_j$, meaning there is an edge between vertex $x_j$ and vertex $y_j$ with length edge weight $b_j$ and width edge weight $c_j$.", "outputFormat": "Output $n$ lines. The $i$-th line contains one real number $R(i)$, representing the spreading power of the $i$-th vertex in the graph.", "hint": "**Scoring**\n\nWe will compare each number in the output file with the reference answer. If the relative error or absolute error of that number does not exceed $10^{-6}$, it will be judged correct. For numbers whose reference answer is $0$, the absolute error must not exceed $10^{-6}$ to be judged correct.\n\nIf the number of correct outputs is $q$, then your score on that test point is $\\left\\lfloor\\ 5(\\dfrac{q}{n})^7 \\right\\rfloor$.\n\n**Constraints**\n\nFor test points $1,2,3,4$, $n \\le 100$.\n\nFor test points $5,6,7,8$, all $b_j=1$.\n\nFor test points $9,10,11,12$, $m=n-1$.\n\nFor test points $1,3,5,7,9,11,13,15,17,19$, all $a_i=1$.\n\nFor test points $1,2,5,6,9,10,13,14,17,18$, all $c_j=1$.\n\nFor all testdata, $n \\le 1000$, $m \\le 4 \\times 10^3$, $0<a_j \\le 255$, $0<b_j \\le 15$, $0.5 \\le c_j \\le 2$, and the fractional part of $c_j$ has at most $12$ digits. The graph is guaranteed to be connected.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2015] misc", "background": "", "description": "小强和 B 君是好朋友。 \n\n小强除了 B 君还有很多好朋友，比如洁妹。 \n\nB 君除了小强也还有很多好朋友，比如R君。他们还有很多共同的好朋友，比如小花，葱娘和其他 $3$ 个人。 \n\nB 君发现，人与人之间的关系可以看成是一个无向图，每个人看成一个点，人与人之间的关系看成一条边。 \n\n不同的人在社会中的号召力不一样，我们用 $a_i$ 来表示第 $i$ 个人的号召力。 \n\n人与人之间的关系也各不相同，可能非常友好，可能只是泛泛之交；可能天天腻在一起，可能一年才联系一次。为此，我们用长度边权 $b_j$ 来刻画第 $j$ 条边对应的两个用户的亲密程度，长度约小，双方就越亲密；同时，我们用宽度边权 $c_j$ 来刻画第 $j$ 条边对应的两个用户的交流频率，宽度越大，两个人沟通的频率也就越高。\n\n一条路径的长度指的是这条路径上的所有边的长度边权之和，一条路径的宽度指的是这条路径上的所有边的宽度边权的乘积。 \n\n当两个人 $s$ 和 $t$ 想要交流的时候，他们会选择长度最短的路径来交流。由于最短路可能有多个，我们称 $s$ 到 $t$ 的最短路的宽度为 $\\sigma_{st}$，是所有 $s$ 到 $t$ 的长度最短的路径的宽度和。同时，我们用 $\\sigma_{st} (v)$ 表示所有从 $s$ 到 $t$，且经过 $v$ 的长度最短的路径的宽度和，即 $v$ 对 $s$,$t$ 的影响力。 \n一个人 $v$ 在图中的传播力 $R(v)$ 可以被定义为如下函数： \n\n $$R(v)=\\sum\\limits_{s \\ne v \\ne t} \\frac{a_s a_t \\sigma_{st}(v)}{\\sigma_{st}}$$\n\n即对图中所有不包含 $v$ 的点对，分别计算 $v$ 对该点对的影响力除以该点对的最短路的宽度，再乘上这个点对中两个点的号召力，最后将所有点对的计算结果加和得到节点在图中的传播力。\n \nB 君想快速知道所有节点在图中的传播力。当他去问小强的时候，小强说：“我有一个绝妙的做法，可惜题面太短，写不下。” \n\n你知道怎么做吗？ ", "inputFormat": "第一行包含 $2$ 个正整数 $n$,$m$，分别表示图的点数和边数。 \n\n接下来 $n$ 行中的第 $i$ 行有 $1$ 个非负整数 $a_i$，表示第 $i$ 个人的号召力。 \n接下来 $m$ 行中的第 $j$ 行有 $3$ 个整数 $x_j$,$y_j$,$b_j$ 和一个实数 $c_j$ ，表示点 $x_j$ 和点 $y_j$ 之间有一条长度边权为 $b_j$，宽度边权为 $c_j$ 的边。 ", "outputFormat": "共 $n$ 行，每行一个实数 $R(i)$，表示第 $i$ 个点在图中的传播力。 ", "hint": "**评分标准**\n\n我们会将输出文件的每个数与参考答案进行比较，如果该数与参考答案的相对误差或绝对误差不超过 $10^{-6}$，则判定该数正确。对于参考答案为 $0$ 的数，必须满足绝对误差不超过 $10^{-6}$ 才判定为正确。 \n\n如果输出正确数的个数为 $q$，那么你在该测试点上的得分是 $\\left\\lfloor\\ 5(\\dfrac{q}{n})^7 \\right\\rfloor$ \n\n**数据规模和约定** \n\n对于测试点 $1$,$2$,$3$,$4$，有 $n \\le 100$。 \n\n对于测试点 $5$,$6$,$7$,$8$，所有 $b_j=1$。 \n\n对于测试点 $9$,$10$,$11$,$12$，有 $m=n-1$。 \n\n对于测试点 $1$,$3$,$5$,$7$,$9$,$11$,$13$,$15$,$17$,$19$，所有 $a_i=1$。 \n\n对于测试点 $1$,$2$,$5$,$6$,$9$,$10$,$13$,$14$,$17$,$18$，所有 $c_j=1$。 \n\n对于所有的数据，有 $n \\le 1000$，$m \\le 4 \\times 10^3$，$0<a_j \\le 255$，$0<b_j \\le 15$，$0.5 \\le c_j \\le 2$，$c_j$ 的小数部分最多 $12$ 位。数据保证图是连通的。", "locale": "zh-CN"}}}
{"pid": "P5883", "type": "P", "difficulty": 6, "samples": [["3 3\n2 3 0\n2 2 1\n1 3 1\n", "2/3\n2/9\n3/2\n1/1\n0/1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "线段树", "Special Judge", "期望", "CTSC/CTS"], "title": "[CTSC2013] 没头脑和不高兴", "background": null, "description": "没头脑和不高兴是一对形影不离的好朋友，他们一起上学也一起玩耍。\n\n这天，这对好朋友聚在一起玩纸牌游戏。他们所玩的纸牌总共有 $N$ 张，每一张上面都有一个 $1-N$ 的数字，任意两张纸牌上的数字都不相同。根据他们制定的游戏规则，在每局游戏的开始，所有的牌需要按照从 $1-N$ 的顺序排好。在开心地玩完了一局牌之后，他们发现牌的顺序被弄得乱七八糟，将它们排好序是一件挺麻烦的事情。\n\n他们将凌乱的纸牌在桌面上排成一排，然后开始了排序工作。不高兴由于在上一局游戏中输了牌，非常不高兴。他只将其中**奇数位置**的牌排成了升序，然后把剩下的任务推给了没头脑。没头脑非常没头脑，他采取了一个有些笨的排序方式。每次，他找到两张相邻并且顺序不对的牌交换它们，直到整个序列被排好序为止。\n\n乐于探究的你，想要研究在初始排列随机的情况下没头脑花在交换纸牌上的时间。假设没头脑每交换一对纸牌花费的时间为 $1$，你希望求出他排序时间的期望。此外，为了更好地分析这个问题，你还希望能够计算出所花时间的方差。更进一步地，如果**被不高兴排好序的位置发生了变化**，你是否还能求出没头脑用来排序时间的期望呢？", "inputFormat": "- 输入文件共 $M+1$ 行。\n- 第一行包含两个正整数 $N$,$M$。\n- 接下来 $M$ 行，每行包含三个整数 $l$,$r$,$v$。其中 $1 \\le l \\le r \\le n$，$v\\in\\{0,1\\}$。若 $v=0$ 则表示不高兴不再对 $l$ 到 $r$ 之间的位置排序；反之若 $v=1$ 则表示被不高兴排序的位置将涵盖 $l$ 到 $r$。", "outputFormat": "- 输出文件共 $M+2$ 行。每行输出一个形如 `p/q` 的有理数，其中 $\\gcd(p,q)=1$，$q \\ge 1$，$p,q \\in Z$。\n- 第一行输出在初始条件下没头脑排序时间的期望。\n- 第二行输出在初始条件下没头脑排序时间的方差。\n- 接下来 $M$ 行，每行分别输出在对不高兴排序的位置进行了前若干次修改之后没头脑排序时间的期望。", "hint": "**样例说明**\n\n在初始条件下，不高兴会将位置 $1$ 和 $3$ 的纸牌排好顺序。对于排列 $(1,2,3)$ 和 $(3,2,1)$，他将排列成 $(1,2,3)$，没头脑不需要操作；对于排列 $(1,3,2)$ 和 $(2,3,1)$，他将排列成 $(1,3,2)$ ，没头脑需要交换一次；对于排列 $(2,1,3)$ 和 $(3,1,2)$，他将排列成 $(2,1,3)$，没头脑需要交换一次。因此没头脑所花的时间期望为$\\frac{0 \\times 2+1 \\times 2+1\\times 2}{6}=\\frac{2}{3}$；方差为 $\\frac{ (0-\\frac{2}{3})^2 \\times 2 + (1-\\frac{2}{3})^2 \\times 2+(1-\\frac{2}{3})^2 \\times 2 }{6}=\\frac{2}{9}$。\n\n在进行了第一次修改之后，不高兴会只对位置 $1$ 排序，这和没有排序的效果一样；第二次修改之后，他会对位置 $1$,$2$ 排序；最后一次修改之后，他会对位置 $1$,$2$,$3$ 排序，这样没头脑完全不用参与排序工作。可据此求出对应情况下没头脑排序时间的期望。\n\n**评分标准**\n- 如果选手的前两行正确，其余行出现错误，可以得到 $40\\%$ 的分数。\n- 如果选手的前两行出现错误，其余行正确，可以得到 $50\\%$ 的分数。\n- 如果选手的所有行输出完全正确，可以得到 $100\\%$ 的分数。\n- 其余情况选手不得分。\n\n\n**数据规模和约定**\n\n| 测试点编号 | $N$ 的值 | $M$ 的值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $4$ | $10$ |\n| $2$ | $11$ | $100$ |\n| $3$ | $100$ | $10^3$ |\n| $4$ | $1001$ | $10^4$ |\n| $5$ | $78590$ | $10^5$ |\n| $6$ | $87933$ | $10^5$ |\n| $7$ | $95000$ | $10^5$|\n| $8$ | $99445$ | $10^5$ |\n| $9$ | $99999$ | $10^5$ |\n| $10$ | $100000$ |  $10^5$|", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2013] Not Thinking and Unhappy", "background": "", "description": "Not Thinking and Unhappy are a pair of inseparable good friends. They go to school together and play together.\n\nOne day, they got together to play a card game. There are a total of $N$ cards, and each card has a number from $1-N$ on it. The numbers on any two cards are different. According to the rules they made, at the start of each round, all cards must be arranged in order from $1-N$. After happily finishing a round, they found that the order of the cards had become a complete mess, and sorting them back is quite troublesome.\n\nThey laid the messy cards in a row on the table and began sorting. Unhappy, having lost in the last round, was very unhappy. He only sorted the cards in the **odd positions** into increasing order, and then pushed the remaining work to Not Thinking. Not Thinking was really not thinking: he used a somewhat clumsy sorting method. Each time, he finds two adjacent cards that are in the wrong order and swaps them, until the whole sequence is sorted.\n\nYou, who enjoy exploring, want to study how much time Not Thinking spends swapping cards when the initial permutation is random. Assume each swap costs time $1$. You want to find the expected value of his sorting time. In addition, to analyze this better, you also want to compute the variance of the time spent. Furthermore, if **the positions sorted by Unhappy change**, can you still find the expected sorting time of Not Thinking?", "inputFormat": "- The input file has $M+1$ lines.\n- The first line contains two positive integers $N$, $M$.\n- The next $M$ lines each contain three integers $l$, $r$, $v$. Here $1 \\le l \\le r \\le n$, $v\\in\\{0,1\\}$. If $v=0$, it means Unhappy will no longer sort positions from $l$ to $r$; otherwise, if $v=1$, it means the positions sorted by Unhappy will include $l$ to $r$.", "outputFormat": "- The output file has $M+2$ lines. Each line outputs a rational number in the form `p/q`, where $\\gcd(p,q)=1$, $q \\ge 1$, $p,q \\in Z$.\n- The first line outputs the expected sorting time of Not Thinking under the initial condition.\n- The second line outputs the variance of Not Thinking's sorting time under the initial condition.\n- The next $M$ lines output, respectively, the expected sorting time of Not Thinking after the first several modifications to the positions sorted by Unhappy.", "hint": "**Sample Explanation**\n\nUnder the initial condition, Unhappy will sort the cards at positions $1$ and $3$. For permutations $(1,2,3)$ and $(3,2,1)$, he will make them into $(1,2,3)$, so Not Thinking does not need to do anything. For permutations $(1,3,2)$ and $(2,3,1)$, he will make them into $(1,3,2)$, and Not Thinking needs one swap. For permutations $(2,1,3)$ and $(3,1,2)$, he will make them into $(2,1,3)$, and Not Thinking needs one swap. Therefore, the expected time Not Thinking spends is $\\frac{0 \\times 2+1 \\times 2+1\\times 2}{6}=\\frac{2}{3}$; the variance is $\\frac{ (0-\\frac{2}{3})^2 \\times 2 + (1-\\frac{2}{3})^2 \\times 2+(1-\\frac{2}{3})^2 \\times 2 }{6}=\\frac{2}{9}$.\n\nAfter the first modification, Unhappy will only sort position $1$, which is the same as not sorting at all. After the second modification, he will sort positions $1$, $2$. After the last modification, he will sort positions $1$, $2$, $3$, so Not Thinking does not need to participate in sorting at all. Based on this, you can compute the expected sorting time of Not Thinking in the corresponding cases.\n\n**Scoring**\n\n- If the first two lines are correct but the remaining lines are wrong, you can get $40\\%$ of the score.\n- If the first two lines are wrong but the remaining lines are correct, you can get $50\\%$ of the score.\n- If all output lines are completely correct, you can get $100\\%$ of the score.\n- In all other cases, you get no score.\n\n**Constraints**\n\n| Test Point ID | Value of $N$ | Value of $M$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $4$ | $10$ |\n| $2$ | $11$ | $100$ |\n| $3$ | $100$ | $10^3$ |\n| $4$ | $1001$ | $10^4$ |\n| $5$ | $78590$ | $10^5$ |\n| $6$ | $87933$ | $10^5$ |\n| $7$ | $95000$ | $10^5$ |\n| $8$ | $99445$ | $10^5$ |\n| $9$ | $99999$ | $10^5$ |\n| $10$ | $100000$ | $10^5$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2013] 没头脑和不高兴", "background": null, "description": "没头脑和不高兴是一对形影不离的好朋友，他们一起上学也一起玩耍。\n\n这天，这对好朋友聚在一起玩纸牌游戏。他们所玩的纸牌总共有 $N$ 张，每一张上面都有一个 $1-N$ 的数字，任意两张纸牌上的数字都不相同。根据他们制定的游戏规则，在每局游戏的开始，所有的牌需要按照从 $1-N$ 的顺序排好。在开心地玩完了一局牌之后，他们发现牌的顺序被弄得乱七八糟，将它们排好序是一件挺麻烦的事情。\n\n他们将凌乱的纸牌在桌面上排成一排，然后开始了排序工作。不高兴由于在上一局游戏中输了牌，非常不高兴。他只将其中**奇数位置**的牌排成了升序，然后把剩下的任务推给了没头脑。没头脑非常没头脑，他采取了一个有些笨的排序方式。每次，他找到两张相邻并且顺序不对的牌交换它们，直到整个序列被排好序为止。\n\n乐于探究的你，想要研究在初始排列随机的情况下没头脑花在交换纸牌上的时间。假设没头脑每交换一对纸牌花费的时间为 $1$，你希望求出他排序时间的期望。此外，为了更好地分析这个问题，你还希望能够计算出所花时间的方差。更进一步地，如果**被不高兴排好序的位置发生了变化**，你是否还能求出没头脑用来排序时间的期望呢？", "inputFormat": "- 输入文件共 $M+1$ 行。\n- 第一行包含两个正整数 $N$,$M$。\n- 接下来 $M$ 行，每行包含三个整数 $l$,$r$,$v$。其中 $1 \\le l \\le r \\le n$，$v\\in\\{0,1\\}$。若 $v=0$ 则表示不高兴不再对 $l$ 到 $r$ 之间的位置排序；反之若 $v=1$ 则表示被不高兴排序的位置将涵盖 $l$ 到 $r$。", "outputFormat": "- 输出文件共 $M+2$ 行。每行输出一个形如 `p/q` 的有理数，其中 $\\gcd(p,q)=1$，$q \\ge 1$，$p,q \\in Z$。\n- 第一行输出在初始条件下没头脑排序时间的期望。\n- 第二行输出在初始条件下没头脑排序时间的方差。\n- 接下来 $M$ 行，每行分别输出在对不高兴排序的位置进行了前若干次修改之后没头脑排序时间的期望。", "hint": "**样例说明**\n\n在初始条件下，不高兴会将位置 $1$ 和 $3$ 的纸牌排好顺序。对于排列 $(1,2,3)$ 和 $(3,2,1)$，他将排列成 $(1,2,3)$，没头脑不需要操作；对于排列 $(1,3,2)$ 和 $(2,3,1)$，他将排列成 $(1,3,2)$ ，没头脑需要交换一次；对于排列 $(2,1,3)$ 和 $(3,1,2)$，他将排列成 $(2,1,3)$，没头脑需要交换一次。因此没头脑所花的时间期望为$\\frac{0 \\times 2+1 \\times 2+1\\times 2}{6}=\\frac{2}{3}$；方差为 $\\frac{ (0-\\frac{2}{3})^2 \\times 2 + (1-\\frac{2}{3})^2 \\times 2+(1-\\frac{2}{3})^2 \\times 2 }{6}=\\frac{2}{9}$。\n\n在进行了第一次修改之后，不高兴会只对位置 $1$ 排序，这和没有排序的效果一样；第二次修改之后，他会对位置 $1$,$2$ 排序；最后一次修改之后，他会对位置 $1$,$2$,$3$ 排序，这样没头脑完全不用参与排序工作。可据此求出对应情况下没头脑排序时间的期望。\n\n**评分标准**\n- 如果选手的前两行正确，其余行出现错误，可以得到 $40\\%$ 的分数。\n- 如果选手的前两行出现错误，其余行正确，可以得到 $50\\%$ 的分数。\n- 如果选手的所有行输出完全正确，可以得到 $100\\%$ 的分数。\n- 其余情况选手不得分。\n\n\n**数据规模和约定**\n\n| 测试点编号 | $N$ 的值 | $M$ 的值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $4$ | $10$ |\n| $2$ | $11$ | $100$ |\n| $3$ | $100$ | $10^3$ |\n| $4$ | $1001$ | $10^4$ |\n| $5$ | $78590$ | $10^5$ |\n| $6$ | $87933$ | $10^5$ |\n| $7$ | $95000$ | $10^5$|\n| $8$ | $99445$ | $10^5$ |\n| $9$ | $99999$ | $10^5$ |\n| $10$ | $100000$ |  $10^5$|", "locale": "zh-CN"}}}
{"pid": "P5884", "type": "P", "difficulty": 4, "samples": [["4\n0 3\n1 0\n0 2\n3 1\n1 2\n2 3\n", "0\n1\n0\n1\n0\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "IOI", "Special Judge"], "title": "[IOI 2014] game 游戏", "background": "", "description": "健佳是一个喜欢做游戏的小男生。当有人问问题时，他更喜欢通过玩游戏的方式作答，而不是直接回答。健佳碰到了他的朋友梅玉，跟她讲了台湾的航空网。在台湾有 $n$ 个城市（编号为 $0,\\cdots,n−1$），其中有些城市之间有航线。每个航线连接两个城市，并且是双向的。\n\n梅玉问健佳，是否任意两个城市之间都可以坐飞机互达（直接或间接），健佳不想直接回答，而是要通过做游戏的方式来告诉她。梅玉可以问\"城市 $u$ 和 $v$ 之间有直接航线吗？\"，健佳会立刻直接回答该问题。梅玉会询问每对城市恰好一次，因此总计会有 $r = \\frac{n (n−1)}{2}$ 个问题。如果由前 $i$（$i<r$）个问题的答案可以推断出整个航空网是否连通，也就是说，是否任意一对城市之间都可以坐飞机互达（直接或间接），梅玉就获胜。否则意味着她需要知道全部 $r$ 个回答，此时健佳获胜。\n\n为了让游戏更好玩，他们俩同意，健佳可以不要管台湾的真实航空网，而是可以随着游戏的进展而编造航空网，也就是根据梅玉此前的提问来决定此后如何作答。你的任务是，通过决定健佳如何回答，来帮助他赢得游戏。", "inputFormat": "- 第 $1$ 行：一个正整数 $n$，代表城市数量。\n- 余下 $r$ 行：每行包含两个整数 $u$ 和 $v$，表示对城市 $u$ 和 $v$ 的提问。", "outputFormat": "- 共 $r$ 行，对于每次梅玉的提问，你必须回答在城市 $v$ 和 $u$ 之间是否有直接航线。具体而言，返回值 $1$ 表示有，$0$ 表示没有。", "hint": "**子任务及数据规模**\n\n| 子任务 | 分值 | $n$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $15$ | $n=4$ |\n| $2$ | $27$ | $4 \\le n \\le 80$ |\n| $3$ | $58$ | $4 \\le n \\le 1500$ |\n", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2014] game", "background": "", "description": "Jianjia is a boy who likes playing games. When someone asks him a question, he prefers to answer by playing a game instead of answering directly. Jianjia met his friend Meiyu and told her about Taiwan’s airline network. In Taiwan there are $n$ cities (numbered $0,\\cdots,n−1$), and there are air routes between some pairs of cities. Each route connects two cities and is bidirectional.\n\nMeiyu asked Jianjia whether it is possible to travel by plane between any two cities (directly or indirectly). Jianjia does not want to answer directly, and instead wants to tell her through a game. Meiyu may ask, “Is there a direct air route between cities $u$ and $v$?”, and Jianjia must answer immediately. Meiyu will ask about each pair of cities exactly once, so in total there will be $r = \\frac{n (n−1)}{2}$ questions. If from the answers to the first $i$ questions ($i<r$) it is already possible to determine whether the whole airline network is connected, that is, whether it is possible to travel between any pair of cities by plane (directly or indirectly), then Meiyu wins. Otherwise, this means she needs to know all $r$ answers, and then Jianjia wins.\n\nTo make the game more fun, they agreed that Jianjia does not have to follow the real airline network in Taiwan. Instead, he may make up the airline network as the game progresses, that is, he can decide how to answer later based on Meiyu’s previous questions. Your task is to help him win the game by deciding how Jianjia should answer.", "inputFormat": "- Line $1$: A positive integer $n$, the number of cities.\n- The remaining $r$ lines: Each line contains two integers $u$ and $v$, representing a question about cities $u$ and $v$.", "outputFormat": "- Output $r$ lines. For each question from Meiyu, you must answer whether there is a direct air route between cities $v$ and $u$. Specifically, output $1$ if there is, and $0$ if there is not.", "hint": "**Subtasks and Constraints**\n\n| Subtask | Score | $n$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $15$ | $n=4$ |\n| $2$ | $27$ | $4 \\le n \\le 80$ |\n| $3$ | $58$ | $4 \\le n \\le 1500$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2014] game 游戏", "background": "", "description": "健佳是一个喜欢做游戏的小男生。当有人问问题时，他更喜欢通过玩游戏的方式作答，而不是直接回答。健佳碰到了他的朋友梅玉，跟她讲了台湾的航空网。在台湾有 $n$ 个城市（编号为 $0,\\cdots,n−1$），其中有些城市之间有航线。每个航线连接两个城市，并且是双向的。\n\n梅玉问健佳，是否任意两个城市之间都可以坐飞机互达（直接或间接），健佳不想直接回答，而是要通过做游戏的方式来告诉她。梅玉可以问\"城市 $u$ 和 $v$ 之间有直接航线吗？\"，健佳会立刻直接回答该问题。梅玉会询问每对城市恰好一次，因此总计会有 $r = \\frac{n (n−1)}{2}$ 个问题。如果由前 $i$（$i<r$）个问题的答案可以推断出整个航空网是否连通，也就是说，是否任意一对城市之间都可以坐飞机互达（直接或间接），梅玉就获胜。否则意味着她需要知道全部 $r$ 个回答，此时健佳获胜。\n\n为了让游戏更好玩，他们俩同意，健佳可以不要管台湾的真实航空网，而是可以随着游戏的进展而编造航空网，也就是根据梅玉此前的提问来决定此后如何作答。你的任务是，通过决定健佳如何回答，来帮助他赢得游戏。", "inputFormat": "- 第 $1$ 行：一个正整数 $n$，代表城市数量。\n- 余下 $r$ 行：每行包含两个整数 $u$ 和 $v$，表示对城市 $u$ 和 $v$ 的提问。", "outputFormat": "- 共 $r$ 行，对于每次梅玉的提问，你必须回答在城市 $v$ 和 $u$ 之间是否有直接航线。具体而言，返回值 $1$ 表示有，$0$ 表示没有。", "hint": "**子任务及数据规模**\n\n| 子任务 | 分值 | $n$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $15$ | $n=4$ |\n| $2$ | $27$ | $4 \\le n \\le 80$ |\n| $3$ | $58$ | $4 \\le n \\le 1500$ |\n", "locale": "zh-CN"}}}
{"pid": "P5885", "type": "P", "difficulty": 7, "samples": [["10\n1 1 1 0 0 1 1 1 0 0\n1 1 1 0 0 0 0 0 1 1\n0\n100\n", "0101111001\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "2014", "O2优化", "快速数论变换 NTT", "CTSC/CTS"], "title": "[CTSC2014] 随机数", "background": "", "description": "露露、花花和萱萱最近对计算机中的随机数产生了兴趣。为大家所熟知的是，有计算机生成的随机数序列并非真正的随机数，而是由一定法则生成的伪随机数。 \n\n某一天，露露了解了一种生成随机数的方法，称为 Mersenne twister。给定初始参数 $m \\in Z+$，$ x \\le Z+\\cap[0,2m)$ 和初值 $M_0 \\in Z+\\cap [0,2m)$，它通过下列递推式构造伪随机数列$\\{M_n\\}$: \n\n $$M_n=\\begin{cases}2M_{n-1} & 2M_{n-1}<2^m\\\\(2M_{n-1}-2^m) \\ XOR \\ x & 2M_{n-1}\\geq 2^m\\end{cases}$$\n \n\n 其中 $XOR$ 是二进制异或运算（C/C++ 中的 $^$ 运算）。而参数 $x$ 的选取若使得该数列在长度趋于无穷时，近似等概率地在 $Z+ \\cap (0,2m)$ 中取值，就称 $x$ 为好的。例如，在 $m>1$时 $x=0$ 就显然不是好的。 \n \n在露露向伙伴们介绍了 Mersenne twister 之后，花花想用这一些经典的随机性测试来检验它的随机性强度。为此，花花使用计算机计算\n了一些 $M_k$。 \n\n但细心的萱萱注意到，花花在某次使用二进制输入 $k$ 时，在末尾多输入了 $l$ 个 $0$。她正想告诉花花这个疏忽，然而花花已经计算并记录了\n错误的 $M_k$ 而没有记录 $k$ 的值。虽然这其实不是什么致命的问题，但是在萱萱告诉花花她这个疏漏时，作为完美主义者的花花还是恳求萱萱帮她修正 $M_k$ 的值。萱萱便把这个任务交给了她的 AI ——你。 ", "inputFormat": "- 第一行包含一个正整数 $m$； \n- 第二行为二进制表示的 $x$（共 $m$ 个数，从低位到高位排列）；\n- 第三行为二进制表示的 $M_0$（排列方式同 $x$）； \n- 第四行包含一个整数 $type$。 \n\n接下来分为两种可能的情况： \n1. $type=0$（萱萱记下了花花的输入）：则第五行包含一个整数，表示萱萱记下来的正确的 $k$ 值。 \n2. $type=1$（萱萱未能记下花花的输入）：则第五行为 $l$，第六行输入花花计算出错误的二进制表示的 $M_k$。 ", "outputFormat": "仅一行，为m位的01串，表示你求得的正确Mk（同样要求从低位到高位）。 ", "hint": "对于 $type=0$ 的部分，要么 $m,k \\le 10^6$ 要么 $m\\le 2000,k\\le 10^{18}$；\n\n对于 $type=1$ 的部分，$m \\le 10^3$，$k \\le 10^{18}$，$l \\le 10$，$x$ 是“好的”。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2014] Random Numbers", "background": "", "description": "Lulu, Huahua, and Xuanxuan have recently become interested in random numbers in computers. As is well known, random number sequences generated by computers are not truly random; they are pseudorandom numbers produced by certain rules.\n\nOne day, Lulu learned a method for generating random numbers called the Mersenne twister. Given initial parameters $m \\in Z+$, $ x \\le Z+\\cap[0,2m)$ and an initial value $M_0 \\in Z+\\cap [0,2m)$, it constructs a pseudorandom sequence $\\{M_n\\}$ by the following recurrence:\n\n$$M_n=\\begin{cases}2M_{n-1} & 2M_{n-1}<2^m\\\\(2M_{n-1}-2^m) \\ XOR \\ x & 2M_{n-1}\\geq 2^m\\end{cases}$$\n\nHere, $XOR$ is the bitwise exclusive OR operation (the $^$ operator in C/C++). If the choice of parameter $x$ makes the sequence, as its length tends to infinity, take values in $Z+ \\cap (0,2m)$ approximately with equal probability, then $x$ is called good. For example, when $m>1$, $x=0$ is obviously not good.\n\nAfter Lulu introduced the Mersenne twister to her partners, Huahua wanted to use some classic randomness tests to check its randomness strength. For this, Huahua used a computer to compute some $M_k$.\n\nBut careful Xuanxuan noticed that when Huahua entered $k$ in binary, she accidentally typed $l$ extra $0$’s at the end. Xuanxuan was about to tell Huahua about this mistake, but Huahua had already computed and recorded the wrong $M_k$ without recording the value of $k$. Although this is not a fatal problem, when Xuanxuan told Huahua about the oversight, the perfectionist Huahua still begged Xuanxuan to help her correct the value of $M_k$. Xuanxuan then handed this task to her AI—you.", "inputFormat": "- The first line contains a positive integer $m$.\n- The second line is the binary representation of $x$ (a total of $m$ bits, arranged from low bit to high bit).\n- The third line is the binary representation of $M_0$ (arranged in the same way as $x$).\n- The fourth line contains an integer $type$.\n\nNext, there are two possible cases:\n1. $type=0$ (Xuanxuan recorded Huahua’s input): the fifth line contains an integer, meaning the correct value of $k$ that Xuanxuan recorded.\n2. $type=1$ (Xuanxuan failed to record Huahua’s input): the fifth line is $l$, and the sixth line gives the wrong binary representation of $M_k$ computed by Huahua.", "outputFormat": "Only one line: an $m$-bit 01 string, representing the correct $M_k$ you computed (also required to be from low bit to high bit).", "hint": "For the part with $type=0$, either $m,k \\le 10^6$, or $m \\le 2000,k \\le 10^{18}$.\n\nFor the part with $type=1$, $m \\le 10^3$, $k \\le 10^{18}$, $l \\le 10$, and $x$ is good.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2014] 随机数", "background": "", "description": "露露、花花和萱萱最近对计算机中的随机数产生了兴趣。为大家所熟知的是，有计算机生成的随机数序列并非真正的随机数，而是由一定法则生成的伪随机数。 \n\n某一天，露露了解了一种生成随机数的方法，称为 Mersenne twister。给定初始参数 $m \\in Z+$，$ x \\le Z+\\cap[0,2m)$ 和初值 $M_0 \\in Z+\\cap [0,2m)$，它通过下列递推式构造伪随机数列$\\{M_n\\}$: \n\n $$M_n=\\begin{cases}2M_{n-1} & 2M_{n-1}<2^m\\\\(2M_{n-1}-2^m) \\ XOR \\ x & 2M_{n-1}\\geq 2^m\\end{cases}$$\n \n\n 其中 $XOR$ 是二进制异或运算（C/C++ 中的 $^$ 运算）。而参数 $x$ 的选取若使得该数列在长度趋于无穷时，近似等概率地在 $Z+ \\cap (0,2m)$ 中取值，就称 $x$ 为好的。例如，在 $m>1$时 $x=0$ 就显然不是好的。 \n \n在露露向伙伴们介绍了 Mersenne twister 之后，花花想用这一些经典的随机性测试来检验它的随机性强度。为此，花花使用计算机计算\n了一些 $M_k$。 \n\n但细心的萱萱注意到，花花在某次使用二进制输入 $k$ 时，在末尾多输入了 $l$ 个 $0$。她正想告诉花花这个疏忽，然而花花已经计算并记录了\n错误的 $M_k$ 而没有记录 $k$ 的值。虽然这其实不是什么致命的问题，但是在萱萱告诉花花她这个疏漏时，作为完美主义者的花花还是恳求萱萱帮她修正 $M_k$ 的值。萱萱便把这个任务交给了她的 AI ——你。 ", "inputFormat": "- 第一行包含一个正整数 $m$； \n- 第二行为二进制表示的 $x$（共 $m$ 个数，从低位到高位排列）；\n- 第三行为二进制表示的 $M_0$（排列方式同 $x$）； \n- 第四行包含一个整数 $type$。 \n\n接下来分为两种可能的情况： \n1. $type=0$（萱萱记下了花花的输入）：则第五行包含一个整数，表示萱萱记下来的正确的 $k$ 值。 \n2. $type=1$（萱萱未能记下花花的输入）：则第五行为 $l$，第六行输入花花计算出错误的二进制表示的 $M_k$。 ", "outputFormat": "仅一行，为m位的01串，表示你求得的正确Mk（同样要求从低位到高位）。 ", "hint": "对于 $type=0$ 的部分，要么 $m,k \\le 10^6$ 要么 $m\\le 2000,k\\le 10^{18}$；\n\n对于 $type=1$ 的部分，$m \\le 10^3$，$k \\le 10^{18}$，$l \\le 10$，$x$ 是“好的”。", "locale": "zh-CN"}}}
{"pid": "P5886", "type": "P", "difficulty": 1, "samples": [["4 3 2\n2 2 3\n1 1\n3 1 2 3\n2 1 3\n", "1\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["洛谷月赛"], "title": "Hello, 2020!", "background": "时针与分针重合在「零」的那一霎那，嘀嗒声便宣告了新一年的到来。\n\n在过去的一年里，世事无常。屏幕面前的你可能不久前才听闻「OI」，也可能暂时地结束了竞赛生涯；可能在赛场上叱咤风云名列榜首，也可能独自承受着比赛失利的落寞。\n\n无论如何，过去仍旧是过去，将来依然是将来。\n\n以此题为开端，迎接你的 2020 吧！", "description": "本场比赛有 $n$ 名出题人，$m$ 名选手。\n\n出题人从 $1$ 至 $n$ 依次标号，选手从 $1$ 至 $m$ 依次标号。\n\n比赛结束后选手的最终排名为 $1$ 至 $m$ 中其一，且互不相同。\n\n报名结束后，第 $i$ 位出题人看了看报名列表，对其他出题人说：「我觉得只有这 $k_i$ 位选手有可能最终排名第一，他们分别是 $a_{i,1},a_{i,2},\\dots,a_{i,k_i}$。其他人不可能最终排名第一。」\n\n你面前屏幕上的这道题的出题人通过时空隧道，预先得知了谁是最终排名第一的选手。\n\n出题人把这 $n$ 位出题人的预测都告诉了你，还告诉你恰好只有 $p$ 个出题人的预测是正确的。\n\n请你求出哪些选手可能最终获得第一名，并以从小到大的顺序依次输出这些选手的编号。", "inputFormat": "从标准输入中读取数据。\n\n第一行，三个正整数 $n,m,p$，表示出题人数，选手数，与正确预测数。\n\n接下来 $n$ 行，每行第一个非负整数 $k_i$ 表示第 $i$ 位出题人预测可能最终排名第一的选手位数；接下来 $k_i$ 个正整数 $a_{i,1},a_{i,2},\\dots,a_{i,k_i}$，表示这位出题人预测可能最终排名第一的选手编号。", "outputFormat": "输出数据至标准输出中。\n\n第一行，输出一个非负整数，表示可能最终获得第一名的选手个数。\n\n第二行，以从小到大的顺序依次输出这些选手的编号。", "hint": "子任务 1（$6\\%$）：$n\\leq 20$，$m\\leq 20$。\n\n子任务 2（$30\\%$）：$n\\leq 100$，$m\\leq 100$，$\\sum k_i \\leq 10^4$。\n\n子任务 3（$24\\%$）：$n\\leq 1000$，$m\\leq 1000$。\n\n子任务 4（$40\\%$）：无特殊限制。\n\n对于全部数据，$1\\leq n\\leq 10^5$，$1\\leq m\\leq 10^6$，$0\\leq \\sum k_i \\leq 10^6$，$0\\leq p\\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "Hello, 2020!", "background": "At the moment when the hour hand and the minute hand overlap at “zero”, the ticking sound announces the arrival of a new year.\n\nIn the past year, the world has been unpredictable. You in front of the screen may have only heard of “OI” not long ago, or you may have temporarily ended your contest journey; you may have dominated the contest and topped the leaderboard, or you may have borne the loneliness of failure by yourself.\n\nNo matter what, the past is still the past, and the future is still the future.\n\nLet this problem be the beginning, and welcome your 2020!", "description": "In this contest, there are $n$ problem setters and $m$ contestants.\n\nThe problem setters are numbered from $1$ to $n$, and the contestants are numbered from $1$ to $m$.\n\nAfter the contest ends, the final ranking of contestants is a permutation of $1$ to $m$, and all ranks are distinct.\n\nAfter registration ends, the $i$-th problem setter looked at the registration list and said to the other problem setters: “I think only these $k_i$ contestants might finally rank first. They are $a_{i,1},a_{i,2},\\dots,a_{i,k_i}$. No one else can possibly end up in first place.”\n\nThe problem setter of the problem on your screen learned in advance, through a time tunnel, who the contestant that finally ranks first is.\n\nThe problem setter told you all $n$ predictions made by these problem setters, and also told you that exactly $p$ problem setters’ predictions are correct.\n\nPlease determine which contestants could possibly end up in first place, and output their IDs in increasing order.", "inputFormat": "Read the input from standard input.\n\nThe first line contains three positive integers $n,m,p$, representing the number of problem setters, the number of contestants, and the number of correct predictions.\n\nThe next $n$ lines each start with a non-negative integer $k_i$, indicating how many contestants the $i$-th problem setter predicts could finally rank first; then follow $k_i$ positive integers $a_{i,1},a_{i,2},\\dots,a_{i,k_i}$, indicating the contestant IDs that this problem setter predicts could finally rank first.", "outputFormat": "Write the output to standard output.\n\nThe first line outputs a non-negative integer, indicating the number of contestants who could possibly end up in first place.\n\nThe second line outputs these contestants’ IDs in increasing order.", "hint": "Subtask 1 ($6\\%$): $n\\leq 20$, $m\\leq 20$.\n\nSubtask 2 ($30\\%$): $n\\leq 100$, $m\\leq 100$, $\\sum k_i \\leq 10^4$.\n\nSubtask 3 ($24\\%$): $n\\leq 1000$, $m\\leq 1000$.\n\nSubtask 4 ($40\\%$): no special constraints.\n\nConstraints for all data: $1\\leq n\\leq 10^5$, $1\\leq m\\leq 10^6$, $0\\leq \\sum k_i \\leq 10^6$, $0\\leq p\\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Hello, 2020!", "background": "时针与分针重合在「零」的那一霎那，嘀嗒声便宣告了新一年的到来。\n\n在过去的一年里，世事无常。屏幕面前的你可能不久前才听闻「OI」，也可能暂时地结束了竞赛生涯；可能在赛场上叱咤风云名列榜首，也可能独自承受着比赛失利的落寞。\n\n无论如何，过去仍旧是过去，将来依然是将来。\n\n以此题为开端，迎接你的 2020 吧！", "description": "本场比赛有 $n$ 名出题人，$m$ 名选手。\n\n出题人从 $1$ 至 $n$ 依次标号，选手从 $1$ 至 $m$ 依次标号。\n\n比赛结束后选手的最终排名为 $1$ 至 $m$ 中其一，且互不相同。\n\n报名结束后，第 $i$ 位出题人看了看报名列表，对其他出题人说：「我觉得只有这 $k_i$ 位选手有可能最终排名第一，他们分别是 $a_{i,1},a_{i,2},\\dots,a_{i,k_i}$。其他人不可能最终排名第一。」\n\n你面前屏幕上的这道题的出题人通过时空隧道，预先得知了谁是最终排名第一的选手。\n\n出题人把这 $n$ 位出题人的预测都告诉了你，还告诉你恰好只有 $p$ 个出题人的预测是正确的。\n\n请你求出哪些选手可能最终获得第一名，并以从小到大的顺序依次输出这些选手的编号。", "inputFormat": "从标准输入中读取数据。\n\n第一行，三个正整数 $n,m,p$，表示出题人数，选手数，与正确预测数。\n\n接下来 $n$ 行，每行第一个非负整数 $k_i$ 表示第 $i$ 位出题人预测可能最终排名第一的选手位数；接下来 $k_i$ 个正整数 $a_{i,1},a_{i,2},\\dots,a_{i,k_i}$，表示这位出题人预测可能最终排名第一的选手编号。", "outputFormat": "输出数据至标准输出中。\n\n第一行，输出一个非负整数，表示可能最终获得第一名的选手个数。\n\n第二行，以从小到大的顺序依次输出这些选手的编号。", "hint": "子任务 1（$6\\%$）：$n\\leq 20$，$m\\leq 20$。\n\n子任务 2（$30\\%$）：$n\\leq 100$，$m\\leq 100$，$\\sum k_i \\leq 10^4$。\n\n子任务 3（$24\\%$）：$n\\leq 1000$，$m\\leq 1000$。\n\n子任务 4（$40\\%$）：无特殊限制。\n\n对于全部数据，$1\\leq n\\leq 10^5$，$1\\leq m\\leq 10^6$，$0\\leq \\sum k_i \\leq 10^6$，$0\\leq p\\leq n$。", "locale": "zh-CN"}}}
{"pid": "P5887", "type": "P", "difficulty": 2, "samples": [["4 2 2\n0 1\n", "0"], ["4 2 2\n0 2\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["洛谷月赛"], "title": "Ringed Genesis", "background": "Enzyme runs through the Ringed Genesis，just like Rabbit runs through a Ring. ", "description": "有一个长长的环，环由 $n$ 个格子首尾相接形成，依次编号 $0$ 至 $n-1$。\n\n还有一种动物——兔子。兔子的步长为 $k$。若兔子当前在第 $i$ 个格子，那么下一秒它将跳到第 $(i+k)\\bmod n$ 个格子。\n\n现在有 $m$ 只兔子，第 $i$ 只兔子的初始格子为第 $p_i$ 个格子。随着时间的流逝，有些格子被兔子经过了，有些却一直没有被兔子经过。\n\n你需要求出的是，有多少个格子永远不可能被兔子经过。", "inputFormat": "从标准输入中读取数据。\n\n第一行，三个正整数 $n,m,k$，表示环长，兔子数，步长。\n\n第二行，$m$ 个非负整数 $p_1,p_2,\\dots,p_m$，表示兔子的初始格子。", "outputFormat": "输出数据至标准输出中。\n\n共一行，一个整数，表示答案。", "hint": "子任务 1（$10\\%$）：$k=1$。\n\n子任务 2（$20\\%$）：$k|n$，也即 $\\gcd(k,n)=k$。\n\n子任务 3（$25\\%$）：$1\\leq n\\leq 1000$，$1\\leq m\\leq 1000$。\n\n子任务 4（$45\\%$）：无特殊限制。\n\n对于全部数据，$1 \\leq n \\leq 10^6$，$1 \\leq m \\leq 10^6$，$1 \\leq k \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "Ringed Genesis", "background": "Enzyme runs through the Ringed Genesis, just like Rabbit runs through a Ring.", "description": "There is a long ring made by connecting $n$ cells end to end, numbered from $0$ to $n-1$ in order.\n\nThere is also an animal called a rabbit. The rabbit’s step length is $k$. If the rabbit is currently on the $i$-th cell, then in the next second it will jump to the $((i+k)\\bmod n)$-th cell.\n\nNow there are $m$ rabbits. The initial cell of the $i$-th rabbit is the $p_i$-th cell. As time goes by, some cells are visited by rabbits, while some cells are never visited.\n\nYou need to find how many cells can never be visited by any rabbit.", "inputFormat": "Read input from standard input.\n\nThe first line contains three positive integers $n, m, k$, representing the ring length, the number of rabbits, and the step length.\n\nThe second line contains $m$ non-negative integers $p_1, p_2, \\dots, p_m$, representing the initial cells of the rabbits.", "outputFormat": "Write output to standard output.\n\nOutput one line with one integer, which is the answer.", "hint": "Subtask 1 ($10\\%$): $k = 1$.\n\nSubtask 2 ($20\\%$): $k \\mid n$, i.e. $\\gcd(k, n) = k$.\n\nSubtask 3 ($25\\%$): $1 \\leq n \\leq 1000$, $1 \\leq m \\leq 1000$.\n\nSubtask 4 ($45\\%$): no special constraints.\n\nFor all testdata, $1 \\leq n \\leq 10^6$, $1 \\leq m \\leq 10^6$, $1 \\leq k \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Ringed Genesis", "background": "Enzyme runs through the Ringed Genesis，just like Rabbit runs through a Ring. ", "description": "有一个长长的环，环由 $n$ 个格子首尾相接形成，依次编号 $0$ 至 $n-1$。\n\n还有一种动物——兔子。兔子的步长为 $k$。若兔子当前在第 $i$ 个格子，那么下一秒它将跳到第 $(i+k)\\bmod n$ 个格子。\n\n现在有 $m$ 只兔子，第 $i$ 只兔子的初始格子为第 $p_i$ 个格子。随着时间的流逝，有些格子被兔子经过了，有些却一直没有被兔子经过。\n\n你需要求出的是，有多少个格子永远不可能被兔子经过。", "inputFormat": "从标准输入中读取数据。\n\n第一行，三个正整数 $n,m,k$，表示环长，兔子数，步长。\n\n第二行，$m$ 个非负整数 $p_1,p_2,\\dots,p_m$，表示兔子的初始格子。", "outputFormat": "输出数据至标准输出中。\n\n共一行，一个整数，表示答案。", "hint": "子任务 1（$10\\%$）：$k=1$。\n\n子任务 2（$20\\%$）：$k|n$，也即 $\\gcd(k,n)=k$。\n\n子任务 3（$25\\%$）：$1\\leq n\\leq 1000$，$1\\leq m\\leq 1000$。\n\n子任务 4（$45\\%$）：无特殊限制。\n\n对于全部数据，$1 \\leq n \\leq 10^6$，$1 \\leq m \\leq 10^6$，$1 \\leq k \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P5888", "type": "P", "difficulty": 4, "samples": [["2 1 0", "0"], ["3 3 0", "2"], ["7 13 5\n1 3\n4 5\n5 4\n6 1\n2 2", "443723615"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "洛谷月赛"], "title": "传球游戏", "background": "羊城有善蹴鞠者。会足协之杯，于校园之东北角，施两球场，蹴鞠者站球场中，$n$ 人，一球，二门，三裁判而已。观众团坐。少倾，但闻球场中哨声一响，满坐寂然，无敢哗者。\n\n当是时，传球声，微微风声，队员疾跑声，教练呼喊声，拉拉队助威声，一时齐发，众妙毕备。满场观众无不伸颈，侧目，微笑，默叹，以为妙绝。\n\n未几，我球员施一长传，彼球员截之，望我龙门冲来。\n\n但见守门员 oql 立于门，若有所思——", "description": "**原来他在想这么一个问题：**\n\n场上的 $n$ 个球员围成一圈，编号从 $1$ 到 $n$ ，刚开始球在 $1$ 号球员手中。一共 $m$ 次传球，每次传球必须传给一个人，但不能传到自己手中。求第 $m$ 次传球以后传回 $1$ 号球员的方案数。\n\n但他觉得这个问题太简单了，于是加了 $k$ 条限制，每条限制形如 $a,b$，表示 $a$ 号球员不能将球传给 $b$ 号球员。\n\n为了使得 oql 的注意力转移回球场上，你需要在最短的时间内告诉他这个方案数是多少。\n\n你只需要告诉他答案对 $998244353$ 取模后的结果。", "inputFormat": "输入数据包括 $k+1$ 行：\n\n第一行三个整数 $n,m,k$，分表代表球员数，传球次数，限制条数。\n\n接下来 $k$ 行，每行两个整数 $a_i,b_i$，表示 $a_i$ 号球员不能将球传给 $b_i$ 号球员。\n\n数据保证不会出现不同的 $i,j$ 使得 $a_i=a_j$ 且 $b_i=b_j$。", "outputFormat": "输出一个整数，表示 $m$ 轮后传回 $1$ 号球员的合法方案数对 $998244353$ 取模后的结果。", "hint": "对于 $10\\%$ 的数据，$k=0$。\n\n对于另外 $15\\%$ 的数据，$n\\leq 500$。\n\n对于另外 $20\\%$ 的数据，$n\\leq 5\\times 10^4$。\n\n对于另外 $20\\%$ 的数据，$k\\leq 300$。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 10^9$，$0\\leq m\\leq 200$，$0\\leq k \\leq \\min(n\\times(n-1),5\\times 10^4)$，$1\\leq a_i,b_i\\leq n$，**不保证 $a_i,b_i$ 不相等**。", "locale": "zh-CN", "translations": {"en": {"title": "Passing Game", "background": "In Yangcheng, there are people who are good at playing cuju. During the Football Association Cup, at the northeast corner of the campus, two fields are set up. The cuju players stand in the field: $n$ people, one ball, two goals, three referees, that is all. The audience sits around. After a while, as soon as the whistle on the field blows, everyone becomes silent, and no one dares to make noise.\n\nAt that moment, the sound of passing, the faint sound of wind, the sound of players sprinting, the coach shouting, and the cheerleaders cheering all burst out together, and every wonderful sound is present. The whole audience stretches their necks, looks sideways, smiles, and sighs silently, thinking it is amazing.\n\nSoon, one of our players makes a long pass. Their player intercepts it and charges toward our goal.\n\nThen we see the goalkeeper oql standing at the goal, as if thinking about something.", "description": "**It turns out he is thinking about this problem:**\n\nThere are $n$ players standing in a circle, numbered from $1$ to $n$. At the beginning, the ball is in the hands of player $1$. There are $m$ passes in total. In each pass, the ball must be passed to someone, but it cannot be passed to oneself. Find the number of ways such that after the $m$-th pass, the ball is passed back to player $1$.\n\nBut he thinks this problem is too easy, so he adds $k$ restrictions. Each restriction is of the form $a,b$, meaning that player $a$ cannot pass the ball to player $b$.\n\nTo bring oql’s attention back to the match as soon as possible, you need to tell him this number of ways in the shortest time.\n\nYou only need to output the result modulo $998244353$.", "inputFormat": "The input consists of $k+1$ lines:\n\nThe first line contains three integers $n,m,k$, which represent the number of players, the number of passes, and the number of restrictions.\n\nThe next $k$ lines each contain two integers $a_i,b_i$, indicating that player $a_i$ cannot pass the ball to player $b_i$.\n\nThe data guarantees that there do not exist different $i,j$ such that $a_i=a_j$ and $b_i=b_j$.", "outputFormat": "Output one integer, representing the number of valid ways for the ball to return to player $1$ after $m$ passes, modulo $998244353$.", "hint": "For $10\\%$ of the data, $k=0$.\n\nFor another $15\\%$ of the data, $n\\leq 500$.\n\nFor another $20\\%$ of the data, $n\\leq 5\\times 10^4$.\n\nFor another $20\\%$ of the data, $k\\leq 300$.\n\nFor $100\\%$ of the data, $1\\leq n\\leq 10^9$, $0\\leq m\\leq 200$, $0\\leq k \\leq \\min(n\\times(n-1),5\\times 10^4)$, $1\\leq a_i,b_i\\leq n$, **it is not guaranteed that $a_i$ and $b_i$ are different**.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "传球游戏", "background": "羊城有善蹴鞠者。会足协之杯，于校园之东北角，施两球场，蹴鞠者站球场中，$n$ 人，一球，二门，三裁判而已。观众团坐。少倾，但闻球场中哨声一响，满坐寂然，无敢哗者。\n\n当是时，传球声，微微风声，队员疾跑声，教练呼喊声，拉拉队助威声，一时齐发，众妙毕备。满场观众无不伸颈，侧目，微笑，默叹，以为妙绝。\n\n未几，我球员施一长传，彼球员截之，望我龙门冲来。\n\n但见守门员 oql 立于门，若有所思——", "description": "**原来他在想这么一个问题：**\n\n场上的 $n$ 个球员围成一圈，编号从 $1$ 到 $n$ ，刚开始球在 $1$ 号球员手中。一共 $m$ 次传球，每次传球必须传给一个人，但不能传到自己手中。求第 $m$ 次传球以后传回 $1$ 号球员的方案数。\n\n但他觉得这个问题太简单了，于是加了 $k$ 条限制，每条限制形如 $a,b$，表示 $a$ 号球员不能将球传给 $b$ 号球员。\n\n为了使得 oql 的注意力转移回球场上，你需要在最短的时间内告诉他这个方案数是多少。\n\n你只需要告诉他答案对 $998244353$ 取模后的结果。", "inputFormat": "输入数据包括 $k+1$ 行：\n\n第一行三个整数 $n,m,k$，分表代表球员数，传球次数，限制条数。\n\n接下来 $k$ 行，每行两个整数 $a_i,b_i$，表示 $a_i$ 号球员不能将球传给 $b_i$ 号球员。\n\n数据保证不会出现不同的 $i,j$ 使得 $a_i=a_j$ 且 $b_i=b_j$。", "outputFormat": "输出一个整数，表示 $m$ 轮后传回 $1$ 号球员的合法方案数对 $998244353$ 取模后的结果。", "hint": "对于 $10\\%$ 的数据，$k=0$。\n\n对于另外 $15\\%$ 的数据，$n\\leq 500$。\n\n对于另外 $20\\%$ 的数据，$n\\leq 5\\times 10^4$。\n\n对于另外 $20\\%$ 的数据，$k\\leq 300$。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 10^9$，$0\\leq m\\leq 200$，$0\\leq k \\leq \\min(n\\times(n-1),5\\times 10^4)$，$1\\leq a_i,b_i\\leq n$，**不保证 $a_i,b_i$ 不相等**。", "locale": "zh-CN"}}}
{"pid": "P5889", "type": "P", "difficulty": 5, "samples": [["3 5 4\n1 2 3 3 1\n1 3 4 5\n1 2 2 4\n2 3 1\n1 1 2 3", "2\n1\n6"]], "limits": {"time": [1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2020", "线段树", "O2优化", "哈希 hashing", "洛谷月赛"], "title": "跳树", "background": "兔子喜欢跳树。", "description": "一天，兔子在一棵点数为 $2^n-1$ 完全二叉树上的一个结点上，他准备进行若干次如下的跳跃。\n\n- 跳到这个点的左儿子，保证这个点有左儿子。\n- 跳到这个点的右儿子，保证这个点有右儿子。\n- 跳到这个点的父亲，**若这个点是根，无视此操作**。\n\n其中，$i$ 号点要么没有儿子，要么有左儿子 $2 \\times i$ 和右儿子 $2 \\times i + 1$。\n\n兔子会计划性地跳树，他写下了一个长度为 $m$ 的序列 $op$。$op$ 中的每个数都是 $1$, $2$, $3$ 中的一种。操作 $i$ 对应从上到下第 $i$ 种跳跃方式。\n\n每次，兔子会选择一段区间 $[l,r]$，依次进行跳跃 $op_l,op_{l+1},\\ldots,op_r$。\n\n有时兔子会对一个点的 $op$ 值进行修改。\n\n现在你需要求出兔子每次会跳到哪个结点。\n\n阅读样例解释可以对题意获得更好的理解。", "inputFormat": "第一行三个整数 $n, m, q$，表示树的大小的幂次、$op$ 的长度、操作的次数。\n\n第二行包含 $m$ 个整数 $op_{1,2,\\ldots,m}$，表示序列的初值。\n\n接下来 $q$ 行，每行一个整数 $type$，若 $type$ 为 $1$，接下来三个整数 $s,l,r$，描述起点和进行跳跃的区间；若 $type$ 为 $2$ ，接下来两个整数 $x,y$，描述修改的位置与值。", "outputFormat": "对于每一个 $type=1$，输出一个数，表示跳跃到的结点。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/jxigowfv.png)\n\n其中红边为第一次跳跃的路径，蓝边为第二次，绿边为第三次。\n\n所有测试数据的范围和特点如下表所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lost2xr2.png)\n\n对于 $100\\%$ 的数据，$1\\leq n \\leq 30$，$1\\leq m,q \\leq  5 \\times 10^5$，$1\\leq op_i\\leq 3$。", "locale": "zh-CN", "translations": {"en": {"title": "Jumping on a Tree.", "background": "Rabbits like jumping on trees.", "description": "One day, a rabbit is on a node of a perfect binary tree with $2^n-1$ nodes, and he plans to perform several jumps of the following types:\n\n- Jump to the left child of the current node. It is guaranteed that the node has a left child.\n- Jump to the right child of the current node. It is guaranteed that the node has a right child.\n- Jump to the parent of the current node. **If the current node is the root, ignore this operation.**\n\nFor node $i$, it either has no children, or it has a left child $2 \\times i$ and a right child $2 \\times i + 1$.\n\nThe rabbit will jump in a planned way. He writes down a sequence $op$ of length $m$. Each number in $op$ is one of $1$, $2$, or $3$. Operation $i$ corresponds to the $i$-th jump type listed above from top to bottom.\n\nEach time, the rabbit chooses an interval $[l,r]$ and performs the jumps $op_l,op_{l+1},\\ldots,op_r$ in order.\n\nSometimes, the rabbit will modify the $op$ value at a position.\n\nNow you need to determine which node the rabbit ends up at for each query.\n\nReading the sample explanation can help you understand the statement better.", "inputFormat": "The first line contains three integers $n, m, q$, representing the exponent determining the tree size, the length of $op$, and the number of operations.\n\nThe second line contains $m$ integers $op_{1,2,\\ldots,m}$, representing the initial sequence.\n\nThe next $q$ lines each contain an integer $type$. If $type$ is $1$, then three integers $s,l,r$ follow, describing the starting node and the interval of jumps to perform. If $type$ is $2$, then two integers $x,y$ follow, describing the position to modify and the new value.", "outputFormat": "For each query with $type=1$, output one number, the node where the rabbit ends up after the jumps.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/jxigowfv.png)\n\nThe red edges show the path of the first jump, the blue edges the second, and the green edges the third.\n\nThe constraints and characteristics of all testdata are shown in the table below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lost2xr2.png)\n\nFor $100\\%$ of the data, $1\\leq n \\leq 30$, $1\\leq m,q \\leq  5 \\times 10^5$, and $1\\leq op_i\\leq 3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "跳树", "background": "兔子喜欢跳树。", "description": "一天，兔子在一棵点数为 $2^n-1$ 完全二叉树上的一个结点上，他准备进行若干次如下的跳跃。\n\n- 跳到这个点的左儿子，保证这个点有左儿子。\n- 跳到这个点的右儿子，保证这个点有右儿子。\n- 跳到这个点的父亲，**若这个点是根，无视此操作**。\n\n其中，$i$ 号点要么没有儿子，要么有左儿子 $2 \\times i$ 和右儿子 $2 \\times i + 1$。\n\n兔子会计划性地跳树，他写下了一个长度为 $m$ 的序列 $op$。$op$ 中的每个数都是 $1$, $2$, $3$ 中的一种。操作 $i$ 对应从上到下第 $i$ 种跳跃方式。\n\n每次，兔子会选择一段区间 $[l,r]$，依次进行跳跃 $op_l,op_{l+1},\\ldots,op_r$。\n\n有时兔子会对一个点的 $op$ 值进行修改。\n\n现在你需要求出兔子每次会跳到哪个结点。\n\n阅读样例解释可以对题意获得更好的理解。", "inputFormat": "第一行三个整数 $n, m, q$，表示树的大小的幂次、$op$ 的长度、操作的次数。\n\n第二行包含 $m$ 个整数 $op_{1,2,\\ldots,m}$，表示序列的初值。\n\n接下来 $q$ 行，每行一个整数 $type$，若 $type$ 为 $1$，接下来三个整数 $s,l,r$，描述起点和进行跳跃的区间；若 $type$ 为 $2$ ，接下来两个整数 $x,y$，描述修改的位置与值。", "outputFormat": "对于每一个 $type=1$，输出一个数，表示跳跃到的结点。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/jxigowfv.png)\n\n其中红边为第一次跳跃的路径，蓝边为第二次，绿边为第三次。\n\n所有测试数据的范围和特点如下表所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lost2xr2.png)\n\n对于 $100\\%$ 的数据，$1\\leq n \\leq 30$，$1\\leq m,q \\leq  5 \\times 10^5$，$1\\leq op_i\\leq 3$。", "locale": "zh-CN"}}}
{"pid": "P5890", "type": "P", "difficulty": 6, "samples": [["4\n4 4\n8 6\n15 14\n114514 1", "Yes\n0101\nNo\nYes\n010100000111101\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["Special Judge", "O2优化", "洛谷月赛"], "title": "小欧与回文串构造", "background": "", "description": "小欧很喜欢字符串，尤其是只有 `0` 和 `1` 两种字符的回文串。\n\n小欧也喜欢回文串，尤其是有那么一些回文子串但不是很多的串。\n\n小欧更喜欢构造，所以他思考如下问题：\n\n给定正整数 $n$ 和 $k$，保证 $k\\le n$，能否构造一个长为 $n$ 的，只含有字符 `0` 和 `1` 的字符串 $S$，使得 $S$ 的本质不同非空回文子串个数恰好为 $k$ 呢？\n\n小欧是构造小鬼，打不过已经爆切十万甚至九万道构造的先辈们，因此他找你帮忙解决这个问题，并希望你在有解时给出任意一个构造。\n\n下面给出一些关于字符串的基本定义，字符串大手子可以跳过不读。\n\n- 对于长为 $n$ 的字符串 $S$，定义 $S_i$ 为字符串 $S$ 的从左至右第 $i$ 个字符，\n- 对于长为 $n$ 的字符串 $S$，定义其子串 $S[l;r]\\; (1\\le l\\le r\\le n)$ 为将字符 $S_l,S_{l+1},\\ldots,S_{r}$ 自左至右拼接形成的字符串。特别地，空串也是 $S$ 的子串。\n- 称 $S$ 的两个子串 $S[l_1;r_1]$ 和 $S[l_2;r_2]$ 本质不同，当且仅当 $S[l_1;r_1] \\ne S[l_2;r_2]$。\n- 对于长为 $n$ 的字符串 $S$，定义它的反串 $S^{T}$ 为将字符 $S_n,S_{n-1},\\ldots,S_1$ 自左至右拼接形成的字符串。\n- 字符串 $S$ 为回文串，当且仅当 $S=S^{T}$。", "inputFormat": "**本题有多组数据**。\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n一行两个正整数，表示这组数据给出的 $n$ 和 $k$。\n", "outputFormat": "对于每组数据：\n\n若该组数据没有解，输出一行一个字符串 `No`；\n\n否则输出两行，第一行一个字符串 `Yes`，接下来一行一个长为 $n$ 的 `01` 串，为你构造的解。有多个解输出任意一个即可。\n", "hint": "对于第一组数据，本质不同的回文子串有：`1`，`0`，`101`，`010` 共四个。\n\n### 数据范围与约定\n\n对于 $20\\%$ 的数据，$n\\le 15$。  \n另有 $10\\%$ 的数据，$k=n$。  \n另有 $20\\%$ 的数据，$1000\\le n\\le 2000$，$k\\ge \\left\\lfloor\\dfrac{n}{2}\\right\\rfloor+100$。  \n对于 $100\\%$ 的数据，$1 \\le T \\le 10$，$1\\le k\\le  n\\le 2\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Xiao Ou and Palindrome String Construction", "background": "", "description": "Xiao Ou likes strings, especially palindromic strings that contain only the two characters `0` and `1`.\n\nXiao Ou also likes palindromes, especially strings that have some palindromic substrings, but not too many.\n\nXiao Ou likes construction even more, so he thinks about the following problem:\n\nGiven positive integers $n$ and $k$, with $k \\le n$ guaranteed, can you construct a string $S$ of length $n$ consisting only of characters `0` and `1`, such that the number of essentially different non-empty palindromic substrings of $S$ is exactly $k$?\n\nXiao Ou is a construction newbie and cannot beat the predecessors who have already brute-forced 100,000 or even 90,000 construction problems, so he asks you to help solve this problem, and hopes that when a solution exists, you can output any valid construction.\n\nSome basic definitions about strings are given below. If you are very familiar with strings, you may skip this part.\n\n- For a string $S$ of length $n$, let $S_i$ be the $i$-th character of $S$ from left to right.\n- For a string $S$ of length $n$, define its substring $S[l;r]\\; (1\\le l\\le r\\le n)$ as the string formed by concatenating $S_l, S_{l+1}, \\ldots, S_r$ from left to right. In particular, the empty string is also a substring of $S$.\n- Two substrings $S[l_1;r_1]$ and $S[l_2;r_2]$ of $S$ are called essentially different if and only if $S[l_1;r_1] \\ne S[l_2;r_2]$.\n- For a string $S$ of length $n$, define its reverse string $S^{T}$ as the string formed by concatenating $S_n, S_{n-1}, \\ldots, S_1$ from left to right.\n- A string $S$ is a palindrome if and only if $S = S^{T}$.", "inputFormat": "**This problem has multiple test cases**.\n\nThe first line contains a positive integer $T$, representing the number of test cases.\n\nFor each test case:\n\nOne line contains two positive integers, representing $n$ and $k$ for this test case.", "outputFormat": "For each test case:\n\nIf there is no solution, output one line with the string `No`.\n\nOtherwise, output two lines. The first line is the string `Yes`, and the next line is a `01` string of length $n$, which is your constructed solution. If there are multiple solutions, output any one.", "hint": "For the first test case, the essentially different palindromic substrings are: `1`, `0`, `101`, `010`, for a total of four.\n\n### Constraints and Notes\n\nFor $20\\%$ of the testdata, $n \\le 15$.  \nFor another $10\\%$ of the testdata, $k = n$.  \nFor another $20\\%$ of the testdata, $1000 \\le n \\le 2000$, $k \\ge \\left\\lfloor\\dfrac{n}{2}\\right\\rfloor + 100$.  \nFor $100\\%$ of the testdata, $1 \\le T \\le 10$, $1 \\le k \\le n \\le 2\\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小欧与回文串构造", "background": "", "description": "小欧很喜欢字符串，尤其是只有 `0` 和 `1` 两种字符的回文串。\n\n小欧也喜欢回文串，尤其是有那么一些回文子串但不是很多的串。\n\n小欧更喜欢构造，所以他思考如下问题：\n\n给定正整数 $n$ 和 $k$，保证 $k\\le n$，能否构造一个长为 $n$ 的，只含有字符 `0` 和 `1` 的字符串 $S$，使得 $S$ 的本质不同非空回文子串个数恰好为 $k$ 呢？\n\n小欧是构造小鬼，打不过已经爆切十万甚至九万道构造的先辈们，因此他找你帮忙解决这个问题，并希望你在有解时给出任意一个构造。\n\n下面给出一些关于字符串的基本定义，字符串大手子可以跳过不读。\n\n- 对于长为 $n$ 的字符串 $S$，定义 $S_i$ 为字符串 $S$ 的从左至右第 $i$ 个字符，\n- 对于长为 $n$ 的字符串 $S$，定义其子串 $S[l;r]\\; (1\\le l\\le r\\le n)$ 为将字符 $S_l,S_{l+1},\\ldots,S_{r}$ 自左至右拼接形成的字符串。特别地，空串也是 $S$ 的子串。\n- 称 $S$ 的两个子串 $S[l_1;r_1]$ 和 $S[l_2;r_2]$ 本质不同，当且仅当 $S[l_1;r_1] \\ne S[l_2;r_2]$。\n- 对于长为 $n$ 的字符串 $S$，定义它的反串 $S^{T}$ 为将字符 $S_n,S_{n-1},\\ldots,S_1$ 自左至右拼接形成的字符串。\n- 字符串 $S$ 为回文串，当且仅当 $S=S^{T}$。", "inputFormat": "**本题有多组数据**。\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n一行两个正整数，表示这组数据给出的 $n$ 和 $k$。\n", "outputFormat": "对于每组数据：\n\n若该组数据没有解，输出一行一个字符串 `No`；\n\n否则输出两行，第一行一个字符串 `Yes`，接下来一行一个长为 $n$ 的 `01` 串，为你构造的解。有多个解输出任意一个即可。\n", "hint": "对于第一组数据，本质不同的回文子串有：`1`，`0`，`101`，`010` 共四个。\n\n### 数据范围与约定\n\n对于 $20\\%$ 的数据，$n\\le 15$。  \n另有 $10\\%$ 的数据，$k=n$。  \n另有 $20\\%$ 的数据，$1000\\le n\\le 2000$，$k\\ge \\left\\lfloor\\dfrac{n}{2}\\right\\rfloor+100$。  \n对于 $100\\%$ 的数据，$1 \\le T \\le 10$，$1\\le k\\le  n\\le 2\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5891", "type": "P", "difficulty": 7, "samples": [["7 19\n1 3 -8\n1 4 8\n1 13 -1\n2 2\n1 1 -10\n1 1 8\n2 12\n", "-10\n-10\n"], ["29 1066163924\n2 680224223\n1 440869582 -1203\n2 993311885\n1 729027357 9874\n2 665374856\n1 192704973 -9712\n1 681750770 -1099\n2 239837676\n1 938998353 -109\n2 174153423\n1 781133679 7360\n2 522379034\n2 125773599\n1 483114333 -376\n2 723115805\n2 699246389\n1 527125403 9279\n1 930492461 -9753\n1 14775627 -3676\n1 152692805 5045\n1 945645197 2710\n2 298593273\n1 888744817 2514\n1 651751441 4559\n2 963653895\n1 986621281 -8296\n2 10216021\n2 848072343\n2 482342087\n", "0\n-5264389353\n181209893739\n-398925734374\n-431628986929\n-73026998100\n-298228449649\n73714612345\n53926122085\n97102847037\n96145153438\n110646771673\n199641765482\n314932271763\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化", "洛谷月赛"], "title": "Fracture Ray", "background": "破碎的镜面里倒映着破碎的射线；\n\n破碎的文字中隐藏着破碎的——", "description": "有一个 `long long` 类型的数组 `a[]`。\n\n在给出所有操作之前，给定上界参数 $v$。\n\n共有 $q$ 次操作。每次操作为以下两个函数之一：\n\n```\nvoid modify(int u,int p)\n{\n    for (int i=u;i<=v;i+=count(i))\n        a[i]+=p;\n}\nlong long query(long long u)\n{\n    long long ret=0;\n    for (int i=u;i<=v;i+=count(i))\n        ret+=a[i];\n    return ret;\n}\n```\n\n上述程序为 C++ 代码，其中 `count(i)` 表示 $i$ 二进制下 $1$ 的个数，例如 `count(0)` 的返回值为 $0$，而 `count(10001279)` 的返回值为 $15$。\n\n上述程序中出现的变量 `v` 即上界参数 $v$。\n\n你需要执行上述操作，并在每次执行 `query()` 函数后，输出函数的返回值。", "inputFormat": "从标准输入中读取数据。\n\n第一行，两个正整数 $q,v$，表示操作数，以及上界参数。\n\n接下来 $q$ 行，每行为以下二者之一：\n\n+ `1 u p` 表示执行 `modify(u,p)`；\n+ `2 u` 表示执行 `query(u)` 并输出一行一个整数，为函数的返回值。", "outputFormat": "在每次执行 `query()` 函数后，输出函数的返回值。", "hint": "子任务 1（$8$ 分）：$1\\leq q\\leq 10^3$，$1\\leq v\\leq 10^4$。\n\n子任务 2（$23$ 分）：$1\\leq v\\leq 10^5$。\n\n子任务 3（$16$ 分）：$1\\leq q\\leq 50$。\n\n子任务 4（$28$ 分）：$1\\leq q\\leq 1000$。\n\n子任务 5（$25$ 分）：无特殊限制。\n\n对于全部数据，$1\\leq q\\leq 2\\times 10^5$，$1\\leq u\\leq v< 2^{30}$，$-10^4\\leq p\\leq 10^4$。\n\n请选手注意代码实现时常数因子带来的程序效率上的影响。\n\n已加入 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "Fracture Ray", "background": "Broken rays are reflected in a broken mirror;\n\nbroken words hide something broken—", "description": "There is an array `a[]` of type `long long`.\n\nBefore giving all operations, an upper bound parameter $v$ is given.\n\nThere are $q$ operations in total. Each operation is one of the following two functions:\n\n```\nvoid modify(int u,int p)\n{\n    for (int i=u;i<=v;i+=count(i))\n        a[i]+=p;\n}\nlong long query(long long u)\n{\n    long long ret=0;\n    for (int i=u;i<=v;i+=count(i))\n        ret+=a[i];\n    return ret;\n}\n```\n\nThe above program is C++ code, where `count(i)` denotes the number of $1$ bits in the binary representation of $i$. For example, `count(0)` returns $0$, and `count(10001279)` returns $15$.\n\nThe variable `v` appearing in the program is exactly the upper bound parameter $v$.\n\nYou need to execute the operations above, and after each execution of `query()`, output the return value of the function.", "inputFormat": "Read input from standard input.\n\nThe first line contains two positive integers $q, v$, representing the number of operations and the upper bound parameter.\n\nThe next $q$ lines are one of the following:\n\n+ `1 u p` means executing `modify(u,p)`.\n+ `2 u` means executing `query(u)` and outputting one integer per line, which is the return value of the function.", "outputFormat": "After each execution of `query()`, output the return value of the function.", "hint": "Subtask 1 ($8$ points): $1\\leq q\\leq 10^3$, $1\\leq v\\leq 10^4$.\n\nSubtask 2 ($23$ points): $1\\leq v\\leq 10^5$.\n\nSubtask 3 ($16$ points): $1\\leq q\\leq 50$.\n\nSubtask 4 ($28$ points): $1\\leq q\\leq 1000$.\n\nSubtask 5 ($25$ points): no special restrictions.\n\nFor all data, $1\\leq q\\leq 2\\times 10^5$, $1\\leq u\\leq v< 2^{30}$, $-10^4\\leq p\\leq 10^4$.\n\nPlease pay attention to the impact of constant factors on program efficiency when implementing the code.\n\nHack testdata has been added.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Fracture Ray", "background": "破碎的镜面里倒映着破碎的射线；\n\n破碎的文字中隐藏着破碎的——", "description": "有一个 `long long` 类型的数组 `a[]`。\n\n在给出所有操作之前，给定上界参数 $v$。\n\n共有 $q$ 次操作。每次操作为以下两个函数之一：\n\n```\nvoid modify(int u,int p)\n{\n    for (int i=u;i<=v;i+=count(i))\n        a[i]+=p;\n}\nlong long query(long long u)\n{\n    long long ret=0;\n    for (int i=u;i<=v;i+=count(i))\n        ret+=a[i];\n    return ret;\n}\n```\n\n上述程序为 C++ 代码，其中 `count(i)` 表示 $i$ 二进制下 $1$ 的个数，例如 `count(0)` 的返回值为 $0$，而 `count(10001279)` 的返回值为 $15$。\n\n上述程序中出现的变量 `v` 即上界参数 $v$。\n\n你需要执行上述操作，并在每次执行 `query()` 函数后，输出函数的返回值。", "inputFormat": "从标准输入中读取数据。\n\n第一行，两个正整数 $q,v$，表示操作数，以及上界参数。\n\n接下来 $q$ 行，每行为以下二者之一：\n\n+ `1 u p` 表示执行 `modify(u,p)`；\n+ `2 u` 表示执行 `query(u)` 并输出一行一个整数，为函数的返回值。", "outputFormat": "在每次执行 `query()` 函数后，输出函数的返回值。", "hint": "子任务 1（$8$ 分）：$1\\leq q\\leq 10^3$，$1\\leq v\\leq 10^4$。\n\n子任务 2（$23$ 分）：$1\\leq v\\leq 10^5$。\n\n子任务 3（$16$ 分）：$1\\leq q\\leq 50$。\n\n子任务 4（$28$ 分）：$1\\leq q\\leq 1000$。\n\n子任务 5（$25$ 分）：无特殊限制。\n\n对于全部数据，$1\\leq q\\leq 2\\times 10^5$，$1\\leq u\\leq v< 2^{30}$，$-10^4\\leq p\\leq 10^4$。\n\n请选手注意代码实现时常数因子带来的程序效率上的影响。\n\n已加入 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P5892", "type": "P", "difficulty": 6, "samples": [["5 2 7\n10 2 20 30 1\n", "60\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2014", "IOI", "决策单调性"], "title": "[IOI 2014] holiday 假期", "background": null, "description": "健佳正在制定下个假期去台湾的游玩计划。在这个假期，健佳将会在城市之间奔波，并且参观这些城市的景点。\n\n在台湾共有 $n$ 个城市，它们全部位于一条高速公路上。这些城市连续地编号为 $0$ 到 $n-1$。\n\n对于城市 $i$（$0 < i < n-1$）而言，与其相邻的城市是 $i-1$ 和 $i+1$。但是对于城市 $0$，唯一与其相邻的是城市 $1$。而对于城市 $n-1$，唯一与其相邻的是城市 $n-2$。\n\n每个城市都有若干景点。健佳有 $d$ 天假期并且打算要参观尽量多的景点。健佳已经选择了假期开始要到访的第一个城市。在假期的每一天，健佳可以选择去一个相邻的城市，或者参观所在城市的所有景点，但是不能同时进行。即使健佳在同一个城市停留多次，他也不会去重复参观该城市的景点。请帮助健佳策划这个假期，以便能让他参观尽可能多的景点。", "inputFormat": "- 第 $1$ 行：有三个非负整数，$n$ 代表城市数目，$\\text{start}$ 代表起点城市编号，$d$ 代表假期天数。\n- 第 $2$ 行：$n$ 个非负整数 $a_0,a_1,\\cdots, a_{n-1}$，对于 $0 \\le i \\le n-1$，$a_i$ 代表城市 $i$ 的景点数目。", "outputFormat": "- 共一行，最多参观的景点数目。", "hint": "**子任务**\n\n在所有的子任务中，有 $0 \\le d \\le 2n+\\lfloor\\frac n2\\rfloor$。而且，每个城市中的景点数都是非负整数。\n\n| 子任务 | 分值 | $n$ | 各城市景点数的最大值 | 起点城市 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $7$ | $2 \\le n \\le 20$ | $10^9$ | 无限制 |\n| $2$ | $23$ | $2 \\le n \\le 10^5$ | $100$ | 城市 $0$ |\n| $3$ | $17$ | $2 \\le n \\le 3 \\times 10 ^3$ | $10^9$ |无限制  |\n| $4$ | $53$ | $2 \\le n \\le 10^5$ | $10^9$ | 无限制 |", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2014] holiday Vacation.", "background": "", "description": "Jianjia is planning a trip to Taiwan for the next vacation. During this vacation, Jianjia will travel between cities and visit attractions in those cities.\n\nThere are $n$ cities in Taiwan, all located along a single highway. The cities are numbered consecutively from $0$ to $n-1$.\n\nFor city $i$ ($0 < i < n-1$), its neighboring cities are $i-1$ and $i+1$. For city $0$, the only neighboring city is $1$. For city $n-1$, the only neighboring city is $n-2$.\n\nEach city has some attractions. Jianjia has $d$ days of vacation and wants to visit as many attractions as possible. He has already chosen the first city to visit at the start of the vacation. On each day of the vacation, Jianjia can either move to a neighboring city, or visit all attractions in the current city, but not both. Even if Jianjia stays in the same city multiple times, he will not visit the attractions of that city again. Please help Jianjia plan this vacation so that he can visit as many attractions as possible.", "inputFormat": "- Line $1$: Three non-negative integers, where $n$ is the number of cities, $\\text{start}$ is the index of the starting city, and $d$ is the number of vacation days.\n- Line $2$: $n$ non-negative integers $a_0,a_1,\\cdots, a_{n-1}$. For $0 \\le i \\le n-1$, $a_i$ is the number of attractions in city $i$.", "outputFormat": "- One line: the maximum number of attractions that can be visited.", "hint": "**Subtasks**\n\nIn all subtasks, $0 \\le d \\le 2n+\\lfloor\\frac n2\\rfloor$. Also, the number of attractions in each city is a non-negative integer.\n\n| Subtask | Score | $n$ | Maximum attractions in each city | Starting city |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $7$ | $2 \\le n \\le 20$ | $10^9$ | No restriction |\n| $2$ | $23$ | $2 \\le n \\le 10^5$ | $100$ | City $0$ |\n| $3$ | $17$ | $2 \\le n \\le 3 \\times 10 ^3$ | $10^9$ | No restriction |\n| $4$ | $53$ | $2 \\le n \\le 10^5$ | $10^9$ | No restriction |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2014] holiday 假期", "background": null, "description": "健佳正在制定下个假期去台湾的游玩计划。在这个假期，健佳将会在城市之间奔波，并且参观这些城市的景点。\n\n在台湾共有 $n$ 个城市，它们全部位于一条高速公路上。这些城市连续地编号为 $0$ 到 $n-1$。\n\n对于城市 $i$（$0 < i < n-1$）而言，与其相邻的城市是 $i-1$ 和 $i+1$。但是对于城市 $0$，唯一与其相邻的是城市 $1$。而对于城市 $n-1$，唯一与其相邻的是城市 $n-2$。\n\n每个城市都有若干景点。健佳有 $d$ 天假期并且打算要参观尽量多的景点。健佳已经选择了假期开始要到访的第一个城市。在假期的每一天，健佳可以选择去一个相邻的城市，或者参观所在城市的所有景点，但是不能同时进行。即使健佳在同一个城市停留多次，他也不会去重复参观该城市的景点。请帮助健佳策划这个假期，以便能让他参观尽可能多的景点。", "inputFormat": "- 第 $1$ 行：有三个非负整数，$n$ 代表城市数目，$\\text{start}$ 代表起点城市编号，$d$ 代表假期天数。\n- 第 $2$ 行：$n$ 个非负整数 $a_0,a_1,\\cdots, a_{n-1}$，对于 $0 \\le i \\le n-1$，$a_i$ 代表城市 $i$ 的景点数目。", "outputFormat": "- 共一行，最多参观的景点数目。", "hint": "**子任务**\n\n在所有的子任务中，有 $0 \\le d \\le 2n+\\lfloor\\frac n2\\rfloor$。而且，每个城市中的景点数都是非负整数。\n\n| 子任务 | 分值 | $n$ | 各城市景点数的最大值 | 起点城市 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $7$ | $2 \\le n \\le 20$ | $10^9$ | 无限制 |\n| $2$ | $23$ | $2 \\le n \\le 10^5$ | $100$ | 城市 $0$ |\n| $3$ | $17$ | $2 \\le n \\le 3 \\times 10 ^3$ | $10^9$ |无限制  |\n| $4$ | $53$ | $2 \\le n \\le 10^5$ | $10^9$ | 无限制 |", "locale": "zh-CN"}}}
{"pid": "P5893", "type": "P", "difficulty": 6, "samples": [["1 1 64\n2 0 0 0 0\n2 0 0 0 0\n2 0 0 0 0\n1 0 0 5352072091165800\n2 0 0 0 0\n1 0 0 15571253006461152\n1 0 0 36204425277916896\n1 0 0 80686018200191040\n1 0 0 720602986354563312\n2 0 0 0 0\n1 0 0 90705271009665312\n2 0 0 0 0\n1 0 0 583803309300971760\n1 0 0 3317329660750560\n2 0 0 0 0\n2 0 0 0 0\n2 0 0 0 0\n1 0 0 84776821924066272\n1 0 0 581927323100969664\n1 0 0 93139161501610224\n1 0 0 28340661117472704\n1 0 0 74529074218959360\n2 0 0 0 0\n1 0 0 462419028676725120\n1 0 0 4416867915235776\n1 0 0 840475934823549024\n1 0 0 8247617084266560\n1 0 0 117571055091706944\n1 0 0 839204903894797440\n1 0 0 820805176764813240\n1 0 0 82688722861897152\n1 0 0 136422472061715840\n1 0 0 555837014267982720\n1 0 0 935087613488388360\n1 0 0 17770822018565616\n1 0 0 10726679222715456\n1 0 0 621229604181863040\n1 0 0 12477973789689408\n2 0 0 0 0\n1 0 0 227153207069268480\n1 0 0 262037449583477568\n1 0 0 562837835495871936\n1 0 0 131875056326325312\n1 0 0 922430858108760\n1 0 0 763487168205041280\n2 0 0 0 0\n2 0 0 0 0\n1 0 0 551850903114166656\n1 0 0 243713152409807808\n1 0 0 306811355534716032\n1 0 0 115604757169181280\n2 0 0 0 0\n1 0 0 29254579698314880\n1 0 0 35080064244441216\n1 0 0 97819409912384160\n1 0 0 34259332503876480\n2 0 0 0 0\n2 0 0 0 0\n1 0 0 159548730492191040\n1 0 0 11555364984947784\n2 0 0 0 0\n1 0 0 3373083100427040\n2 0 0 0 0\n2 0 0 0 0\n", "0\n0\n0\n5352072091165800\n720602986354563312\n90705271009665312\n3317329660750560\n3317329660750560\n3317329660750560\n74529074218959360\n12477973789689408\n763487168205041280\n763487168205041280\n115604757169181280\n34259332503876480\n34259332503876480\n11555364984947784\n3373083100427040\n3373083100427040\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520, 235520]}, "tags": ["2013", "IOI", "O2优化"], "title": "[IOI 2013] game 游戏", "background": "警告：**滥用本题评测将被封号**。", "description": "Bazza 和 Shazza 正在玩游戏。游戏在一个 $R$ 行 $C$ 列的网格上进行。其中， $R$ 行编号为 $0,\\cdots, R - 1 $， $C$ 列编号为 $0,\\cdots, C - 1 $。我们用 $(P, Q)$ 表示位于 $P$ 行 $Q$ 列的单元格。每个单元格包含一个非负整数，游戏开始时所有单元格内的整数均为零。\n\n游戏如下进行：任意时刻，Bazza 可以做如下动作之一：\n- 修改一个单元格 $(p, q)$ 内包含的整数值；\n- 要求 Shazza 计算一个给定子矩阵中所有单元格内数字的最大公约数（GCD），子矩阵的两个对角分别为 $(p, q)$ 和 $(u, v)$ （子矩阵包含给定的两个对角点）。\n\nBazza 会做 $N_U + N_Q$ 次动作(其中，修改单元格内数据 $N_U$ 次，询问 GCD $N_Q$ 次) 。\n\n你的任务是对 Bazza 提出的问题给出正确答案。", "inputFormat": "- 第1行: $R$ 表示网格行数，$C$ 表示网格列数，$N$ 表示操作总数。\n- 接下来的 $N$ 行: 每行表示一个动作，以动作发生的先后顺序给出。\n\n表示每个动作的一行的格式如下：\n- `update(P,Q,K)` 表示为： `1 P Q K`\n- `calculate(P,Q,U,V)` 表示为： `2 P Q U V`\n\n", "outputFormat": "共 $N_Q$ 行，对于每次询问，输出答案。\n\n**说明**\n\n`update(P,Q,K)`\n\n- 当Bazza改变单元格中的整数时调用此函数，即把第 $P$ 行第 $Q$ 列的数改为 $K$。\n- $P$: 单元格的行号（$0 \\le P \\le R - 1$ ）。\n- $Q$: 单元格的列号（$0 \\le Q \\le C - 1$ ）。\n- $K$: 这个单元格中新的整数（ $0 \\le K \\le 10^{18}$）。这个新整数可能与原来的整数相同。\n\n`calculate(P,Q,U,V)`\n\n- 该函数计算以 $(P, Q)$ 和 $(U, V)$ 为对角点的子矩阵中所有整数的最大公约数。这个范围是包含单元格 $(P, Q)$ 和 $(U, V)$ 的。\n\n- 如果这个子矩阵中的所有整数都是 $0$，那么该函数返回 $0$。\n\n- $P$: 子矩阵左上角单元格的行号（ $0 \\le P \\le R - 1$ ）。\n- $Q$: 子矩阵左上角单元格的列号 （$ 0 \\le Q \\le C - 1$ ）。\n- $U$: 子矩阵右下角单元格的行号（ $P \\le U \\le R - 1$ ）。\n- $V$: 子矩阵右下角单元格的列号（ $Q \\le V \\le C - 1$ ）。", "hint": "**子任务**\n\n| 子任务 | 分数 | $R$ | $C$ | $N_U$ | $N_Q$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $\\le 100$ | $\\le 100$ | $\\le 100$ | $\\le 100$ |\n| $2$ | $27$ | $\\le 10$ | $\\le 10^5$ | $\\le 10^4$ | $\\le 2.5\\times 10^5$ |\n| $3$ | $26$ | $\\le 2 \\times 10^3$ | $\\le 2 \\times 10^3$ | $\\le 10^4$ | $\\le 2.5 \\times 10^5$ |\n| $4$ | $17$ | $\\le 10^9$ | $\\le 10^9$ | $\\le 10^4$ | $\\le 2.5 \\times 10^5$ |\n| $5$ | $20$ | $\\le 10^9$ | $\\le 10^9$ | $\\le 2.2 \\times 10^4$ | $\\le 2.5 \\times 10^5$ |\n\n**限制**\n\n对于 $100\\%$ 的数据，$1 \\le R,C \\le 10^9$，$0 \\le K \\le 10^{18}$，$K$ 表示 Bazza 放到单元格中的数字。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2013] game", "background": "Warning: **Abusing the judge for this problem will result in your account being banned**.", "description": "Bazza and Shazza are playing a game. The game is played on a grid with $R$ rows and $C$ columns. The $R$ rows are numbered $0,\\cdots, R - 1$, and the $C$ columns are numbered $0,\\cdots, C - 1$. We use $(P, Q)$ to denote the cell located in row $P$ and column $Q$. Each cell contains a non-negative integer, and at the start of the game, all integers in all cells are zero.\n\nThe game proceeds as follows: at any time, Bazza can perform one of the following actions:\n- Modify the integer value contained in a cell $(p, q)$.\n- Ask Shazza to compute the greatest common divisor (GCD) of all numbers in a given submatrix, whose two opposite corners are $(p, q)$ and $(u, v)$ (the submatrix includes these two corner cells).\n\nBazza will perform a total of $N_U + N_Q$ actions (including $N_U$ cell updates and $N_Q$ GCD queries).\n\nYour task is to output the correct answer for each question asked by Bazza.", "inputFormat": "- Line 1: $R$ is the number of rows in the grid, $C$ is the number of columns in the grid, and $N$ is the total number of operations.\n- The next $N$ lines: each line describes an action, given in the order they occur.\n\nThe format of each action line is:\n- `update(P,Q,K)` is given as: `1 P Q K`.\n- `calculate(P,Q,U,V)` is given as: `2 P Q U V`.", "outputFormat": "There are $N_Q$ lines. For each query, output the answer.\n\n**Notes**\n\n`update(P,Q,K)`\n\n- This function is called when Bazza changes the integer in a cell, i.e. set the number in row $P$, column $Q$ to $K$.\n- $P$: the row index of the cell ($0 \\le P \\le R - 1$).\n- $Q$: the column index of the cell ($0 \\le Q \\le C - 1$).\n- $K$: the new integer in this cell ($0 \\le K \\le 10^{18}$). This new integer may be the same as the previous one.\n\n`calculate(P,Q,U,V)`\n\n- This function computes the GCD of all integers in the submatrix with corners $(P, Q)$ and $(U, V)$. This range includes the cells $(P, Q)$ and $(U, V)$.\n\n- If all integers in this submatrix are $0$, then this function returns $0$.\n\n- $P$: the row index of the top-left cell of the submatrix ($0 \\le P \\le R - 1$).\n- $Q$: the column index of the top-left cell of the submatrix ($0 \\le Q \\le C - 1$).\n- $U$: the row index of the bottom-right cell of the submatrix ($P \\le U \\le R - 1$).\n- $V$: the column index of the bottom-right cell of the submatrix ($Q \\le V \\le C - 1$).", "hint": "**Subtasks**\n\n| Subtask | Score | $R$ | $C$ | $N_U$ | $N_Q$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $\\le 100$ | $\\le 100$ | $\\le 100$ | $\\le 100$ |\n| $2$ | $27$ | $\\le 10$ | $\\le 10^5$ | $\\le 10^4$ | $\\le 2.5\\times 10^5$ |\n| $3$ | $26$ | $\\le 2 \\times 10^3$ | $\\le 2 \\times 10^3$ | $\\le 10^4$ | $\\le 2.5 \\times 10^5$ |\n| $4$ | $17$ | $\\le 10^9$ | $\\le 10^9$ | $\\le 10^4$ | $\\le 2.5 \\times 10^5$ |\n| $5$ | $20$ | $\\le 10^9$ | $\\le 10^9$ | $\\le 2.2 \\times 10^4$ | $\\le 2.5 \\times 10^5$ |\n\n**Constraints**\n\nFor $100\\%$ of the testdata, $1 \\le R,C \\le 10^9$, $0 \\le K \\le 10^{18}$, where $K$ is the number Bazza puts into a cell.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2013] game 游戏", "background": "警告：**滥用本题评测将被封号**。", "description": "Bazza 和 Shazza 正在玩游戏。游戏在一个 $R$ 行 $C$ 列的网格上进行。其中， $R$ 行编号为 $0,\\cdots, R - 1 $， $C$ 列编号为 $0,\\cdots, C - 1 $。我们用 $(P, Q)$ 表示位于 $P$ 行 $Q$ 列的单元格。每个单元格包含一个非负整数，游戏开始时所有单元格内的整数均为零。\n\n游戏如下进行：任意时刻，Bazza 可以做如下动作之一：\n- 修改一个单元格 $(p, q)$ 内包含的整数值；\n- 要求 Shazza 计算一个给定子矩阵中所有单元格内数字的最大公约数（GCD），子矩阵的两个对角分别为 $(p, q)$ 和 $(u, v)$ （子矩阵包含给定的两个对角点）。\n\nBazza 会做 $N_U + N_Q$ 次动作(其中，修改单元格内数据 $N_U$ 次，询问 GCD $N_Q$ 次) 。\n\n你的任务是对 Bazza 提出的问题给出正确答案。", "inputFormat": "- 第1行: $R$ 表示网格行数，$C$ 表示网格列数，$N$ 表示操作总数。\n- 接下来的 $N$ 行: 每行表示一个动作，以动作发生的先后顺序给出。\n\n表示每个动作的一行的格式如下：\n- `update(P,Q,K)` 表示为： `1 P Q K`\n- `calculate(P,Q,U,V)` 表示为： `2 P Q U V`\n\n", "outputFormat": "共 $N_Q$ 行，对于每次询问，输出答案。\n\n**说明**\n\n`update(P,Q,K)`\n\n- 当Bazza改变单元格中的整数时调用此函数，即把第 $P$ 行第 $Q$ 列的数改为 $K$。\n- $P$: 单元格的行号（$0 \\le P \\le R - 1$ ）。\n- $Q$: 单元格的列号（$0 \\le Q \\le C - 1$ ）。\n- $K$: 这个单元格中新的整数（ $0 \\le K \\le 10^{18}$）。这个新整数可能与原来的整数相同。\n\n`calculate(P,Q,U,V)`\n\n- 该函数计算以 $(P, Q)$ 和 $(U, V)$ 为对角点的子矩阵中所有整数的最大公约数。这个范围是包含单元格 $(P, Q)$ 和 $(U, V)$ 的。\n\n- 如果这个子矩阵中的所有整数都是 $0$，那么该函数返回 $0$。\n\n- $P$: 子矩阵左上角单元格的行号（ $0 \\le P \\le R - 1$ ）。\n- $Q$: 子矩阵左上角单元格的列号 （$ 0 \\le Q \\le C - 1$ ）。\n- $U$: 子矩阵右下角单元格的行号（ $P \\le U \\le R - 1$ ）。\n- $V$: 子矩阵右下角单元格的列号（ $Q \\le V \\le C - 1$ ）。", "hint": "**子任务**\n\n| 子任务 | 分数 | $R$ | $C$ | $N_U$ | $N_Q$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $\\le 100$ | $\\le 100$ | $\\le 100$ | $\\le 100$ |\n| $2$ | $27$ | $\\le 10$ | $\\le 10^5$ | $\\le 10^4$ | $\\le 2.5\\times 10^5$ |\n| $3$ | $26$ | $\\le 2 \\times 10^3$ | $\\le 2 \\times 10^3$ | $\\le 10^4$ | $\\le 2.5 \\times 10^5$ |\n| $4$ | $17$ | $\\le 10^9$ | $\\le 10^9$ | $\\le 10^4$ | $\\le 2.5 \\times 10^5$ |\n| $5$ | $20$ | $\\le 10^9$ | $\\le 10^9$ | $\\le 2.2 \\times 10^4$ | $\\le 2.5 \\times 10^5$ |\n\n**限制**\n\n对于 $100\\%$ 的数据，$1 \\le R,C \\le 10^9$，$0 \\le K \\le 10^{18}$，$K$ 表示 Bazza 放到单元格中的数字。", "locale": "zh-CN"}}}
{"pid": "P5894", "type": "P", "difficulty": 5, "samples": [["3 2 10\n6 2 9\n4 7\n4 6\n8 5\n2 3\n7 9\n1 8\n5 1\n3 3\n8 7\n7 6\n10 5\n\n", "3"], ["2 1 3\n2 5\n2\n3 1\n5 3\n2 2\n", "-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2013", "二分", "IOI", "O2优化", "优先队列"], "title": "[IOI 2013] robots 机器人", "background": "", "description": "Marita 的弟弟把玩具扔在客厅地板上，乱七八糟。庆幸的是，Marita 设计了一种特殊的机器人可以收拾玩具。 不过，她需要确定哪个机器人去拣起哪个玩具。\n\n一共有 $T$ 个玩具,整数 $W[i]$ 表示这个玩具的重量，整数 $S[i]$ 表示这个玩具的体积。机器人有两种，分别是：弱机器人和小机器人。\n\n- 有 $A$ 个弱机器人。每个弱机器人有一个重量限制 $X[i] $，它只能拿起重量严格小于 $X[i]$ 的玩具，与玩具的体积大小没关系。\n- 有 $B$ 个小机器人。每个小机器人有一个体积限制 $Y[i] $，它只能拿起体积严格小于 $Y[i]$ 的玩具，与玩具的重量大小没有关系。\n\nMarita 的每个机器人用 $1$ 分钟将一个玩具拿走放好。不同的机器人可以同时拿走并放好不同的玩具。\n\n你的任务是确定 Marita 的机器人是否可以将所有的玩具都收拾好，如果是，那么最少用多少时间可以收拾好。\n", "inputFormat": "- 第1行: $A$ 表示弱机器人的数目，$B$ 表示小机器人的数目，$T$ 表示玩具的数目；\n- 第2行: 长度为 $A$ 的数组 $X[0],\\cdots,X[A­-1]$，对于 $0 \\le i \\le A-1$，$X[i]$ 表示第 $i$ 个弱机器人的重量限制；\n- 第3行: 长度为 $B$ 的数组 $Y[0],\\cdots,Y[B-­1]$，对于 $1 \\le i \\le B-1$，$Y[i]$ 表示第 $i$ 个小机器人的体积限制；\n- 接下来 $T$ 行: $W[i]$，$S[i]$，对于 $1 \\le i \\le T$，$W[i]$ 代表第 $i$ 个玩具的重量，$S[i]$ 代表第 $i$ 个玩具的体积。\n\n- 如果 $A = 0$ 或者 $B = 0$ ，那么相应的行（第 $2$ 行或者第 $3$ 行）为空。\n", "outputFormat": "- 共 $1$ 行，输出机器人收拾好所有玩具所需要的最短时间，如果无法收拾好所有玩具，输出 `­-1`。", "hint": "对于 $100\\%$ 的数据，$1 \\le T \\le 10^6$，$0 \\le A,B \\le 5 \\times 10^4$ 且 $1 \\le A+B$，$1 \\le X[i],Y[i],W[i],S[i] \\le 2 \\times 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2013] robots Robots", "background": "", "description": "Marita’s younger brother has thrown toys all over the living room floor, making a big mess. Luckily, Marita has designed special robots that can put the toys away. However, she needs to decide which robot should pick up which toy.\n\nThere are $T$ toys. Integer $W[i]$ represents the weight of the $i$-th toy, and integer $S[i]$ represents the volume of the $i$-th toy. There are two kinds of robots: weak robots and small robots.\n\n- There are $A$ weak robots. Each weak robot has a weight limit $X[i]$. It can only pick up toys with weight strictly less than $X[i]$, regardless of the toy’s volume.\n- There are $B$ small robots. Each small robot has a volume limit $Y[i]$. It can only pick up toys with volume strictly less than $Y[i]$, regardless of the toy’s weight.\n\nEach of Marita’s robots takes $1$ minute to carry one toy away and put it in place. Different robots can carry away and put away different toys at the same time.\n\nYour task is to determine whether Marita’s robots can put away all the toys. If yes, find the minimum time needed.", "inputFormat": "- Line 1: $A$ is the number of weak robots, $B$ is the number of small robots, and $T$ is the number of toys.\n- Line 2: An array of length $A$, $X[0],\\cdots,X[A-1]$. For $0 \\le i \\le A-1$, $X[i]$ is the weight limit of the $i$-th weak robot.\n- Line 3: An array of length $B$, $Y[0],\\cdots,Y[B-1]$. For $0 \\le i \\le B-1$, $Y[i]$ is the volume limit of the $i$-th small robot.\n- The next $T$ lines: $W[i]$, $S[i]$. For $1 \\le i \\le T$, $W[i]$ is the weight of the $i$-th toy, and $S[i]$ is the volume of the $i$-th toy.\n\n- If $A = 0$ or $B = 0$, then the corresponding line (line 2 or line 3) is empty.", "outputFormat": "- One line. Output the minimum time needed for the robots to put away all toys. If it is impossible to put away all toys, output `-1`.", "hint": "For $100\\%$ of the testdata, $1 \\le T \\le 10^6$, $0 \\le A,B \\le 5 \\times 10^4$, and $1 \\le A+B$, $1 \\le X[i],Y[i],W[i],S[i] \\le 2 \\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2013] robots 机器人", "background": "", "description": "Marita 的弟弟把玩具扔在客厅地板上，乱七八糟。庆幸的是，Marita 设计了一种特殊的机器人可以收拾玩具。 不过，她需要确定哪个机器人去拣起哪个玩具。\n\n一共有 $T$ 个玩具,整数 $W[i]$ 表示这个玩具的重量，整数 $S[i]$ 表示这个玩具的体积。机器人有两种，分别是：弱机器人和小机器人。\n\n- 有 $A$ 个弱机器人。每个弱机器人有一个重量限制 $X[i] $，它只能拿起重量严格小于 $X[i]$ 的玩具，与玩具的体积大小没关系。\n- 有 $B$ 个小机器人。每个小机器人有一个体积限制 $Y[i] $，它只能拿起体积严格小于 $Y[i]$ 的玩具，与玩具的重量大小没有关系。\n\nMarita 的每个机器人用 $1$ 分钟将一个玩具拿走放好。不同的机器人可以同时拿走并放好不同的玩具。\n\n你的任务是确定 Marita 的机器人是否可以将所有的玩具都收拾好，如果是，那么最少用多少时间可以收拾好。\n", "inputFormat": "- 第1行: $A$ 表示弱机器人的数目，$B$ 表示小机器人的数目，$T$ 表示玩具的数目；\n- 第2行: 长度为 $A$ 的数组 $X[0],\\cdots,X[A­-1]$，对于 $0 \\le i \\le A-1$，$X[i]$ 表示第 $i$ 个弱机器人的重量限制；\n- 第3行: 长度为 $B$ 的数组 $Y[0],\\cdots,Y[B-­1]$，对于 $1 \\le i \\le B-1$，$Y[i]$ 表示第 $i$ 个小机器人的体积限制；\n- 接下来 $T$ 行: $W[i]$，$S[i]$，对于 $1 \\le i \\le T$，$W[i]$ 代表第 $i$ 个玩具的重量，$S[i]$ 代表第 $i$ 个玩具的体积。\n\n- 如果 $A = 0$ 或者 $B = 0$ ，那么相应的行（第 $2$ 行或者第 $3$ 行）为空。\n", "outputFormat": "- 共 $1$ 行，输出机器人收拾好所有玩具所需要的最短时间，如果无法收拾好所有玩具，输出 `­-1`。", "hint": "对于 $100\\%$ 的数据，$1 \\le T \\le 10^6$，$0 \\le A,B \\le 5 \\times 10^4$ 且 $1 \\le A+B$，$1 \\le X[i],Y[i],W[i],S[i] \\le 2 \\times 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5895", "type": "P", "difficulty": 4, "samples": [["12 8 2\n0 8 4\n8 2 2\n2 7 4\n5 11 3\n5 1 7\n1 3 1\n1 9 5\n10 6 3\n", "18\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["贪心", "2013", "IOI", "树的直径"], "title": "[IOI 2013] dreaming 梦想", "background": "", "description": "天地之初，IOI 尚在遥远的梦想之中。\n\nSerpent(水蛇) 生活的地方有 $N$ 个水坑，编号为 $0，\\cdots，N - 1$，有 $M$ 条双向小路连接\n这些水坑。每两个水坑之间至多有一条路径（路径包含一条或多条小路）相互连接，有些水坑之间根本无法互通(即 $M ≤ N-1$ )。Serpent 走过每条小路需要一个固定的天数，不同的小路需要的天数可能不同。\n\nSerpent 的朋友袋鼠希望新修 $N - M - 1$ 条小路，让Serpent 可以在任何两个水坑间游走。袋鼠可以在任意两个水坑之间修路，Serpent 通过每条新路的时间都是 $L$ 天。\n\n袋鼠希望找到一种修路方式使得修路之后 Serpent 在每两个水坑之间游走的最长时间最短。\n\n**举例说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ahroenu.png)\n\n\n上图中有 $12$ 个水坑 $8$ 条小路 ($N = 12 , M = 8$)。假如 $L = 2$，即 Serpent 通过任何一条新路都需要 $2$ 天。那么，袋鼠可以修建 $3$ 条新路：\n- 水坑 $1$ 和水坑 $2$ 之间；\n- 水坑 $1$ 和水坑 $6$ 之间；\n- 水坑 $4$ 和水坑 $10$ 之间。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/udp17aas.png)\n\n上图显示了修路后的最终状态。从水坑 $0$ 走到水坑 $11$ 的时间最长，需要 $18$ 天。这是最佳结果，无论袋鼠如何选择修路方式，总会存在一些水坑对，Serpent 需要 $18$ 天或者更长时间从其中一个走到另一个。", "inputFormat": "- 第 $1$ 行: $N$ 表示水坑的数目，$M$ 表示原本存在的小路的数目，$L$ 表示 Serpent 通过新修的路径的时间。\n- 第 $2,\\cdots, M + 1$ 行: $A[i]$，$B[i]$，$T[i]$。$A$，$B$，$T$ 分别为三个包含 $M$ 个元素的数组，分别表示每条小路的两个端点和通过这条小路的时间。例如，第 $i$ 条小路连接水坑 $A[i-1]$ 和水坑 $B[i-1]$，通过这条小路的时间是 $T[i-1]$ 天。\n\n\n例如：题目中的例子应该表示为以下格式\n\n```\n12 8 2\n0 8 4\n8 2 2\n2 7 4\n5 11 3\n5 1 7\n1 3 1\n1 9 5\n10 6 3\n```", "outputFormat": "如上所述，表示游走于两个距离最远的水坑之间所需的时间", "hint": "对于 $100\\%$ 的数据，$1 \\le N \\le 10^5$，$0 \\le M \\le N-1$，$0 \\le A[i],B[i] \\le N-1$，$1 \\le T[i] \\le 10^4$，$1 \\le L \\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2013] dreaming Dreams", "background": "", "description": "At the beginning of the world, IOI was still a distant dream.\n\nThere are $N$ ponds where Serpent (the water snake) lives, numbered $0, \\cdots, N - 1$, and there are $M$ undirected paths connecting these ponds. Between any two ponds, there is at most one route (a route consists of one or more paths) connecting them, and some ponds cannot reach each other at all (that is, $M \\le N - 1$). It takes Serpent a fixed number of days to walk along each path, and different paths may take different numbers of days.\n\nSerpent's friend Kangaroo wants to build $N - M - 1$ new paths so that Serpent can travel between any two ponds. Kangaroo may build a path between any two ponds, and the time for Serpent to travel along each new path is always $L$ days.\n\nKangaroo wants to find a way to build the paths such that, after building them, the maximum travel time between any two ponds is as small as possible.\n\n**Example**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ahroenu.png)\n\nIn the figure above, there are $12$ ponds and $8$ paths ($N = 12, M = 8$). Suppose $L = 2$, meaning Serpent needs $2$ days to travel along any new path. Then Kangaroo can build $3$ new paths:\n- between pond $1$ and pond $2$;\n- between pond $1$ and pond $6$;\n- between pond $4$ and pond $10$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/udp17aas.png)\n\nThe figure above shows the final state after building the paths. The longest travel time is from pond $0$ to pond $11$, which takes $18$ days. This is the best possible result: no matter how Kangaroo chooses to build the paths, there will always be some pair of ponds for which Serpent needs at least $18$ days to travel from one to the other.", "inputFormat": "- Line $1$: $N$ is the number of ponds, $M$ is the number of existing paths, and $L$ is the time for Serpent to travel along a newly built path.\n- Lines $2, \\cdots, M + 1$: $A[i]$, $B[i]$, $T[i]$. $A$, $B$, and $T$ are three arrays of length $M$, representing the two endpoints of each path and the time to travel along it. For example, the $i$-th path connects pond $A[i-1]$ and pond $B[i-1]$, and it takes $T[i-1]$ days to travel along this path.\n\nFor example, the sample in the statement should be written in the following format:\n\n```\n12 8 2\n0 8 4\n8 2 2\n2 7 4\n5 11 3\n5 1 7\n1 3 1\n1 9 5\n10 6 3\n```", "outputFormat": "As described above, output the time required to travel between the two farthest ponds (i.e., the maximum travel time between any two ponds).", "hint": "Constraints for $100\\%$ of the data: $1 \\le N \\le 10^5$, $0 \\le M \\le N-1$, $0 \\le A[i],B[i] \\le N-1$, $1 \\le T[i] \\le 10^4$, $1 \\le L \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2013] dreaming 梦想", "background": "", "description": "天地之初，IOI 尚在遥远的梦想之中。\n\nSerpent(水蛇) 生活的地方有 $N$ 个水坑，编号为 $0，\\cdots，N - 1$，有 $M$ 条双向小路连接\n这些水坑。每两个水坑之间至多有一条路径（路径包含一条或多条小路）相互连接，有些水坑之间根本无法互通(即 $M ≤ N-1$ )。Serpent 走过每条小路需要一个固定的天数，不同的小路需要的天数可能不同。\n\nSerpent 的朋友袋鼠希望新修 $N - M - 1$ 条小路，让Serpent 可以在任何两个水坑间游走。袋鼠可以在任意两个水坑之间修路，Serpent 通过每条新路的时间都是 $L$ 天。\n\n袋鼠希望找到一种修路方式使得修路之后 Serpent 在每两个水坑之间游走的最长时间最短。\n\n**举例说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ahroenu.png)\n\n\n上图中有 $12$ 个水坑 $8$ 条小路 ($N = 12 , M = 8$)。假如 $L = 2$，即 Serpent 通过任何一条新路都需要 $2$ 天。那么，袋鼠可以修建 $3$ 条新路：\n- 水坑 $1$ 和水坑 $2$ 之间；\n- 水坑 $1$ 和水坑 $6$ 之间；\n- 水坑 $4$ 和水坑 $10$ 之间。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/udp17aas.png)\n\n上图显示了修路后的最终状态。从水坑 $0$ 走到水坑 $11$ 的时间最长，需要 $18$ 天。这是最佳结果，无论袋鼠如何选择修路方式，总会存在一些水坑对，Serpent 需要 $18$ 天或者更长时间从其中一个走到另一个。", "inputFormat": "- 第 $1$ 行: $N$ 表示水坑的数目，$M$ 表示原本存在的小路的数目，$L$ 表示 Serpent 通过新修的路径的时间。\n- 第 $2,\\cdots, M + 1$ 行: $A[i]$，$B[i]$，$T[i]$。$A$，$B$，$T$ 分别为三个包含 $M$ 个元素的数组，分别表示每条小路的两个端点和通过这条小路的时间。例如，第 $i$ 条小路连接水坑 $A[i-1]$ 和水坑 $B[i-1]$，通过这条小路的时间是 $T[i-1]$ 天。\n\n\n例如：题目中的例子应该表示为以下格式\n\n```\n12 8 2\n0 8 4\n8 2 2\n2 7 4\n5 11 3\n5 1 7\n1 3 1\n1 9 5\n10 6 3\n```", "outputFormat": "如上所述，表示游走于两个距离最远的水坑之间所需的时间", "hint": "对于 $100\\%$ 的数据，$1 \\le N \\le 10^5$，$0 \\le M \\le N-1$，$0 \\le A[i],B[i] \\le N-1$，$1 \\le T[i] \\le 10^4$，$1 \\le L \\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P5896", "type": "P", "difficulty": 7, "samples": [["5 7 2\n0 3\n4 4\n4 6\n4 5\n4 6\n", "25\n"], ["2 6 2\n1 4\n4 1\n", "16\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2016", "IOI", "Special Judge", "斜率优化", "凸完全单调性（wqs 二分）"], "title": "[IOI 2016] aliens", "background": "", "description": "我们的卫星刚刚通过观测一个遥远的星球发现了外星文明。我们也已经获得了该星球的一个正方形区域的低分辨率照片。这个照片上有许多智能生命的迹象。专家们也已经确定了照片上的 $n$ 个兴趣点。这些兴趣点被编号为 $0$ 到 $n−1$。现在我们希望拍摄一些能包含全部 $n$ 个兴趣点的高分辨率照片。\n\n卫星已将低分辨率照片的区域划分成由 $m \\times m$ 个单位正方形的小方格组成的网络。网格的行和列被连续地编号为 $0$ 到 $m−1$（从上到下和从左到右）。我们用坐标 $(s,t)$ 来表示第 $s$ 行与第 $t$ 列上的小方格。第 $i$ 个兴趣点位于小方格 $(r_i,c_i)$ 上，每个小方格子上可以包含任意多个兴趣点。\n\n卫星在一个固定的轨道上运行，而它刚好也直接经过这个网格的主对角线的上方。主对角线就是指在网络中连接左上角和右下角的那条线段。卫星能够在任意的区域上拍摄高分辨率的照片，但必须满足以下条件：\n\n- 拍摄的区域必须是正方形。\n- 这个正方形的两个对角（注：变通理解为主对角线）全部包含在网格的主对角线中。\n- 网格中的每个小方格或者完全在拍摄范围内，或者完全在拍摄范围外。\n卫星最多只能拍摄 $k$ 张高分辨率照片。\n\n一旦卫星拍摄完成，它将把每个拍摄区域的高分辨率照片传送到地面基站（无论这些区域是否包含兴趣点）。尽管一个小方格可能会被多次拍摄，但每个被拍摄到的小方格上的数据只会被传送一次。\n\n因此，我们必须选择最多 $k$ 个正方形区域进行拍摄，而且要保证：\n\n- 每个包含至少一个兴趣点的小方格必须被至少拍摄到一次\n- 被拍摄到至少一次的小方格数目必须是最小的。\n\n你的任务就是去找出被拍摄到的小方格有可能的最小值。", "inputFormat": "- 第 $1$ 行：整数 $n$ 代表兴趣点的数目，$m$ 代表网格中的行数（也是列数） 和 $k$ 代表卫星能够拍摄高分辨率照片的最大次数；\n- 第 $2+i$ （$0 \\le i \\le n−1$） 行：整数 $r_i$ 和 $c_i$。$r$ 和 $c$ 为两个长度为 $n$ 的数组，描述网格中包含兴趣点的那些小方格的坐标。对于 $0\\le i\\le n−1$，第 $i$ 个兴趣点位于坐标为 $(r_i,c_i)$ 的小方格。", "outputFormat": "- 共一行，被至少拍摄一次的小方格的总数的最小值（这些照片必须覆盖所有兴趣点）。", "hint": "**子任务**\n\n在全部子任务中， $1\\le k\\le n$。\n\n| 子任务 | 分数 | $n\\le$ | $m\\le$ | 其他限制 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $4$ | $5$ | $100$ |  $k=n$|\n| $2$ | $12$ | $500$ | $10^3$ | $r_i=c_i$ |\n|  $3$| $9$ | $500$ | $10^3$ | 无 |\n|$4$  |$16$  | $4 \\times 10^3$ | $10^6$ | 无 |\n| $5$ | $19$ | $5\\times 10^4$ | $10^6$ | $k \\le 100$ |\n| $6$ |  $40$| $10^5$ | $10^6$ | 无 |\n", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2016] aliens", "background": "", "description": "Our satellite has just discovered an alien civilization by observing a distant planet. We have also obtained a low-resolution photo of a square area on that planet. The photo shows many signs of intelligent life. Experts have identified $n$ points of interest in the photo. These points are numbered from $0$ to $n-1$. Now we want to take some high-resolution photos that include all $n$ points of interest.\n\nThe satellite has divided the area in the low-resolution photo into a grid made of $m \\times m$ unit squares. The rows and columns of the grid are consecutively numbered from $0$ to $m-1$ (from top to bottom and from left to right). We use coordinates $(s,t)$ to denote the cell in row $s$ and column $t$. The $i$-th point of interest is located in cell $(r_i,c_i)$. Each cell may contain any number of points of interest.\n\nThe satellite moves along a fixed orbit, and it happens to pass directly above the main diagonal of this grid. The main diagonal is the line segment connecting the top-left corner and the bottom-right corner of the grid. The satellite can take a high-resolution photo of any area, but it must satisfy the following conditions:\n\n- The photographed area must be a square.\n- Both diagonals of this square (note: you may understand this as the main diagonal) must lie on the main diagonal of the grid.\n- Each cell in the grid must be either completely inside the photographed area or completely outside it.\n\nThe satellite can take at most $k$ high-resolution photos.\n\nAfter photographing, the satellite will transmit the high-resolution data for every photographed area to the ground station (whether or not the area contains points of interest). Although a cell may be photographed multiple times, the data for each photographed cell will be transmitted only once.\n\nTherefore, we must choose at most $k$ square areas to photograph, and ensure that:\n\n- Every cell that contains at least one point of interest is photographed at least once.\n- The number of cells photographed at least once is minimized.\n\nYour task is to find the minimum possible number of cells that are photographed at least once.", "inputFormat": "- Line $1$: integers $n$ (the number of points of interest), $m$ (the number of rows in the grid, also the number of columns), and $k$ (the maximum number of high-resolution photos the satellite can take).\n- Line $2+i$ ($0 \\le i \\le n-1$): integers $r_i$ and $c_i$. $r$ and $c$ are two arrays of length $n$ describing the coordinates of the cells that contain points of interest. For $0 \\le i \\le n-1$, the $i$-th point of interest is located in the cell with coordinates $(r_i,c_i)$.", "outputFormat": "- One line: the minimum total number of cells that are photographed at least once (the photos must cover all points of interest).", "hint": "**Subtasks**\n\nIn all subtasks, $1 \\le k \\le n$.\n\n| Subtask | Score | $n \\le$ | $m \\le$ | Other constraints |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $4$ | $5$ | $100$ | $k=n$ |\n| $2$ | $12$ | $500$ | $10^3$ | $r_i=c_i$ |\n| $3$ | $9$ | $500$ | $10^3$ | None |\n| $4$ | $16$ | $4 \\times 10^3$ | $10^6$ | None |\n| $5$ | $19$ | $5 \\times 10^4$ | $10^6$ | $k \\le 100$ |\n| $6$ | $40$ | $10^5$ | $10^6$ | None |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2016] aliens", "background": "", "description": "我们的卫星刚刚通过观测一个遥远的星球发现了外星文明。我们也已经获得了该星球的一个正方形区域的低分辨率照片。这个照片上有许多智能生命的迹象。专家们也已经确定了照片上的 $n$ 个兴趣点。这些兴趣点被编号为 $0$ 到 $n−1$。现在我们希望拍摄一些能包含全部 $n$ 个兴趣点的高分辨率照片。\n\n卫星已将低分辨率照片的区域划分成由 $m \\times m$ 个单位正方形的小方格组成的网络。网格的行和列被连续地编号为 $0$ 到 $m−1$（从上到下和从左到右）。我们用坐标 $(s,t)$ 来表示第 $s$ 行与第 $t$ 列上的小方格。第 $i$ 个兴趣点位于小方格 $(r_i,c_i)$ 上，每个小方格子上可以包含任意多个兴趣点。\n\n卫星在一个固定的轨道上运行，而它刚好也直接经过这个网格的主对角线的上方。主对角线就是指在网络中连接左上角和右下角的那条线段。卫星能够在任意的区域上拍摄高分辨率的照片，但必须满足以下条件：\n\n- 拍摄的区域必须是正方形。\n- 这个正方形的两个对角（注：变通理解为主对角线）全部包含在网格的主对角线中。\n- 网格中的每个小方格或者完全在拍摄范围内，或者完全在拍摄范围外。\n卫星最多只能拍摄 $k$ 张高分辨率照片。\n\n一旦卫星拍摄完成，它将把每个拍摄区域的高分辨率照片传送到地面基站（无论这些区域是否包含兴趣点）。尽管一个小方格可能会被多次拍摄，但每个被拍摄到的小方格上的数据只会被传送一次。\n\n因此，我们必须选择最多 $k$ 个正方形区域进行拍摄，而且要保证：\n\n- 每个包含至少一个兴趣点的小方格必须被至少拍摄到一次\n- 被拍摄到至少一次的小方格数目必须是最小的。\n\n你的任务就是去找出被拍摄到的小方格有可能的最小值。", "inputFormat": "- 第 $1$ 行：整数 $n$ 代表兴趣点的数目，$m$ 代表网格中的行数（也是列数） 和 $k$ 代表卫星能够拍摄高分辨率照片的最大次数；\n- 第 $2+i$ （$0 \\le i \\le n−1$） 行：整数 $r_i$ 和 $c_i$。$r$ 和 $c$ 为两个长度为 $n$ 的数组，描述网格中包含兴趣点的那些小方格的坐标。对于 $0\\le i\\le n−1$，第 $i$ 个兴趣点位于坐标为 $(r_i,c_i)$ 的小方格。", "outputFormat": "- 共一行，被至少拍摄一次的小方格的总数的最小值（这些照片必须覆盖所有兴趣点）。", "hint": "**子任务**\n\n在全部子任务中， $1\\le k\\le n$。\n\n| 子任务 | 分数 | $n\\le$ | $m\\le$ | 其他限制 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $4$ | $5$ | $100$ |  $k=n$|\n| $2$ | $12$ | $500$ | $10^3$ | $r_i=c_i$ |\n|  $3$| $9$ | $500$ | $10^3$ | 无 |\n|$4$  |$16$  | $4 \\times 10^3$ | $10^6$ | 无 |\n| $5$ | $19$ | $5\\times 10^4$ | $10^6$ | $k \\le 100$ |\n| $6$ |  $40$| $10^5$ | $10^6$ | 无 |\n", "locale": "zh-CN"}}}
{"pid": "P5897", "type": "P", "difficulty": 7, "samples": [["3 4\n0 2 5\n7 1 1\n0 4 0\n0 0 0 2\n0 3 4 7\n5\n3 2 1\n3 3 3\n2 0 0 5\n1 1 1 6\n3 2 1\n", "2\n7\n5\n"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2013", "IOI", "O2优化"], "title": "[IOI 2013] wombats", "background": "", "description": "布里斯班被变异的袋熊占领，你必须带领大家去安全的地方。\n\n布里斯班的道路像一个大网格，有 $R$ 条东西向的横向道路，从北向南依次编号为 $0,\\cdots, (R - 1) $，有 $C$ 条南北向的纵向道路，从西向同东依次编号为 $0,\\cdots, (C- 1)$ ，如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xyvkmhhp.png)\n\n袋熊从北方入侵，人们逃向南方。人们可以在横向道路上双方向移动，但是在纵向道路上只能往南面安全的地方走。\n\n横向道路 $P$ 和纵向道路 $Q$ 的交点表示为 $(P, Q)$ 。相邻 $2$ 个交点之间的道路线段上\n有一些袋熊，且数目是随时间变化的。 你的任务是引导每个人从最北边（在横向道路 $0$ 上）的指定交点逃到最南端（在横向道路 $R - 1$ 上）的指定交点，路上经过\n的袋熊最少。\n\n首先会告诉你网格的规模以及每条道路线段上的袋熊的数量。然后给你一系列 $E$ 事件，每个事件是下列两者之一：\n- 变化，表示有些道路线段上的袋熊数量发生变化；\n- 逃离, 表示有些人已到达横向道路 $0$ 上指定交点，你必须给他们指出一条路，通往横向道路 $R - 1$ 上指定交点且路上遇到的袋熊最少。\n\n**举例**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zn27laze.png)\n\n上图所示的初始地图中有 $3$ 条横向道路 （$ R = 3$ ）和 $4$ 条纵向道路（$ C = 4$ ），每\n条道路线段上的袋熊数目如线段上的标记所示。考虑下列事件：\n- 一个人到达交点 $A = (0, 2)$ ,希望逃到交点 $B = (2, 1)$ 。如图上虚线所示，他最少需要经过 $2$ 只袋熊。\n- 又一个人到达交点 $X = (0, 3)$ ，希望逃到交点 $Y = (2, 3)$ 。如图上虚线所示，他最少需要经过 $7$ 只袋熊。\n- 发生 $2$ 个变化事件：纵向道路 $0$ 上最上面那条道路线段上的袋熊数目变为 $5 $，横向道路 $1$ 上中间那条道路线段上的袋熊数目变为 $6 $，见下图中圈出来的两个数字。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/agnx5ol9.png)\n\n- 第3个人到达交点 $A = (0, 2)$ ，希望逃到交点 $B = (2, 1)$ ，现在他最少需要经过 $5$ 只袋熊，如图中虚线所示。", "inputFormat": "- 第 $1$ 行： $R$ 表示横向道路的数目，$C$ 表示纵向道路的数目。\n- 第 $2$ 行： $H[0][0],\\cdots,H[0][C-2]$。\n- $\\cdots$\n- 第 $(R + 1)$ 行： $H[R-1][0],\\cdots,H[R-1][C-2]$。\n- 第 $(R + 2)$ 行： $V[0][0],\\cdots,V[0][C-1]$。\n- $H$: 二维数组 $R × (C - 1)$ ，其中 $H[P][Q]$ 表示交点 $(P, Q)$ 和交点 $(P, Q +1)$ 之间的横向道路线段上的袋熊数目。\n- $\\cdots$\n- 第 $(2R)$ 行： $V[R-2][0],\\cdots,V[R-2][C-1]$。\n- $V$: 二维数组 $(R - 1) × C$ ，其中 $V[P][Q]$ 表示交点 $(P, Q)$ 和交点 $(P + 1,Q)$ 之间的纵向道路线段上的袋熊数目。\n- 下一行: $E$。\n- 下 $E$ 行：每行一个事件，按照事件发生的顺序给出。\n\n如果 $C = 1$ ，表示横向道路上每条道路线段上的袋熊数目的若干空行(第 $2$ 到 $R +1$ 行)将会被省略。\n\n表示每个事件的那一行格式如下：\n\n- `1 P Q W` 表示 将交点 $(P, Q)$ 和交点 $(P, Q + 1)$ 之间的横向道路线段上的袋熊数目改为 $W$。\n- `2 P Q W` 表示 将交点 $(P, Q)$ 和交点 $(P + 1, Q)$ 之间的纵向道路线段上的袋熊数目改为 $W$。\n- `3 V1 V2` 表示 计算一个人从交点 $(0, V1)$ 逃到交点 $(R-1, V2)$ 最少需要经过多少只袋熊。\n\n例如：题目中的例子应该表示为以下格式\n\n```\n3 4\n0 2 5\n7 1 1\n0 4 0\n0 0 0 2\n0 3 4 7\n5\n3 2 1\n3 3 3\n2 0 0 5\n1 1 1 6\n3 2 1\n\n```", "outputFormat": "对于每一次询问，给出最少经过袋熊数。", "hint": "对于 $100\\%$ 的数据，$2 \\le R \\le 5 \\times 10^3$，$1 \\le C \\le 200$，最多 $500$ 个变化，最多 $2 \\times 10^5$ 次询问，任意时刻一条道路上最多 $10^3$ 只袋熊。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2013] wombats", "background": "", "description": "Brisbane has been occupied by mutated wombats, and you must lead everyone to a safe place.\n\nThe roads in Brisbane form a large grid. There are $R$ horizontal roads running west to east, numbered from north to south as $0,\\cdots,(R - 1)$. There are $C$ vertical roads running south to north, numbered from west to east as $0,\\cdots,(C - 1)$, as shown in the figure below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xyvkmhhp.png)\n\nWombats invade from the north, and people escape to the south. People can move in both directions along horizontal roads, but along vertical roads they can only move south toward safety.\n\nThe intersection of horizontal road $P$ and vertical road $Q$ is denoted as $(P, Q)$. On each road segment between two adjacent intersections, there are some wombats, and the number changes over time. Your task is to guide each person from a specified intersection on the northernmost road (horizontal road $0$) to a specified intersection on the southernmost road (horizontal road $R - 1$), while encountering as few wombats as possible along the way.\n\nYou are first given the grid size and the number of wombats on each road segment. Then you are given a sequence of $E$ events, each of which is one of the following:\n- an update, meaning the number of wombats on some road segments changes;\n- an escape query, meaning some people have arrived at a specified intersection on horizontal road $0$, and you must tell them a path to a specified intersection on horizontal road $R - 1$ that minimizes the number of wombats encountered.\n\n**Example**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zn27laze.png)\n\nIn the initial map shown above, there are $3$ horizontal roads ($R = 3$) and $4$ vertical roads ($C = 4$). The number of wombats on each road segment is marked on the segment. Consider the following events:\n- A person arrives at intersection $A = (0, 2)$ and wants to escape to intersection $B = (2, 1)$. As shown by the dashed path, they need to pass at least $2$ wombats.\n- Another person arrives at intersection $X = (0, 3)$ and wants to escape to intersection $Y = (2, 3)$. As shown by the dashed path, they need to pass at least $7$ wombats.\n- Two update events occur: the number of wombats on the topmost vertical segment of vertical road $0$ becomes $5$, and the number of wombats on the middle horizontal segment of horizontal road $1$ becomes $6$, as circled in the figure below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/agnx5ol9.png)\n\n- A third person arrives at intersection $A = (0, 2)$ and wants to escape to intersection $B = (2, 1)$. Now they need to pass at least $5$ wombats, as shown by the dashed path in the figure.", "inputFormat": "- Line $1$: $R$ is the number of horizontal roads, and $C$ is the number of vertical roads.\n- Line $2$: $H[0][0],\\cdots,H[0][C-2]$.\n- $\\cdots$\n- Line $(R + 1)$: $H[R-1][0],\\cdots,H[R-1][C-2]$.\n- Line $(R + 2)$: $V[0][0],\\cdots,V[0][C-1]$.\n- $H$: a 2D array of size $R \\times (C - 1)$, where $H[P][Q]$ is the number of wombats on the horizontal road segment between intersection $(P, Q)$ and intersection $(P, Q + 1)$.\n- $\\cdots$\n- Line $(2R)$: $V[R-2][0],\\cdots,V[R-2][C-1]$.\n- $V$: a 2D array of size $(R - 1) \\times C$, where $V[P][Q]$ is the number of wombats on the vertical road segment between intersection $(P, Q)$ and intersection $(P + 1, Q)$.\n- Next line: $E$.\n- The next $E$ lines: one event per line, given in the order they occur.\n\nIf $C = 1$, then the empty lines for the number of wombats on horizontal road segments (lines $2$ to $R + 1$) will be omitted.\n\nThe format of each event line is as follows:\n\n- `1 P Q W` means setting the number of wombats on the horizontal road segment between intersection $(P, Q)$ and intersection $(P, Q + 1)$ to $W$.\n- `2 P Q W` means setting the number of wombats on the vertical road segment between intersection $(P, Q)$ and intersection $(P + 1, Q)$ to $W$.\n- `3 V1 V2` means computing the minimum number of wombats a person must pass when escaping from intersection $(0, V1)$ to intersection $(R-1, V2)$.\n\nFor example, the example in the statement should be written in the following format:\n\n```\n3 4\n0 2 5\n7 1 1\n0 4 0\n0 0 0 2\n0 3 4 7\n5\n3 2 1\n3 3 3\n2 0 0 5\n1 1 1 6\n3 2 1\n\n```", "outputFormat": "For each query, output the minimum number of wombats that must be passed.", "hint": "Constraints: for $100\\%$ of the data, $2 \\le R \\le 5 \\times 10^3$, $1 \\le C \\le 200$, there are at most $500$ updates, at most $2 \\times 10^5$ queries, and at any time there are at most $10^3$ wombats on any road segment.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2013] wombats", "background": "", "description": "布里斯班被变异的袋熊占领，你必须带领大家去安全的地方。\n\n布里斯班的道路像一个大网格，有 $R$ 条东西向的横向道路，从北向南依次编号为 $0,\\cdots, (R - 1) $，有 $C$ 条南北向的纵向道路，从西向同东依次编号为 $0,\\cdots, (C- 1)$ ，如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xyvkmhhp.png)\n\n袋熊从北方入侵，人们逃向南方。人们可以在横向道路上双方向移动，但是在纵向道路上只能往南面安全的地方走。\n\n横向道路 $P$ 和纵向道路 $Q$ 的交点表示为 $(P, Q)$ 。相邻 $2$ 个交点之间的道路线段上\n有一些袋熊，且数目是随时间变化的。 你的任务是引导每个人从最北边（在横向道路 $0$ 上）的指定交点逃到最南端（在横向道路 $R - 1$ 上）的指定交点，路上经过\n的袋熊最少。\n\n首先会告诉你网格的规模以及每条道路线段上的袋熊的数量。然后给你一系列 $E$ 事件，每个事件是下列两者之一：\n- 变化，表示有些道路线段上的袋熊数量发生变化；\n- 逃离, 表示有些人已到达横向道路 $0$ 上指定交点，你必须给他们指出一条路，通往横向道路 $R - 1$ 上指定交点且路上遇到的袋熊最少。\n\n**举例**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zn27laze.png)\n\n上图所示的初始地图中有 $3$ 条横向道路 （$ R = 3$ ）和 $4$ 条纵向道路（$ C = 4$ ），每\n条道路线段上的袋熊数目如线段上的标记所示。考虑下列事件：\n- 一个人到达交点 $A = (0, 2)$ ,希望逃到交点 $B = (2, 1)$ 。如图上虚线所示，他最少需要经过 $2$ 只袋熊。\n- 又一个人到达交点 $X = (0, 3)$ ，希望逃到交点 $Y = (2, 3)$ 。如图上虚线所示，他最少需要经过 $7$ 只袋熊。\n- 发生 $2$ 个变化事件：纵向道路 $0$ 上最上面那条道路线段上的袋熊数目变为 $5 $，横向道路 $1$ 上中间那条道路线段上的袋熊数目变为 $6 $，见下图中圈出来的两个数字。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/agnx5ol9.png)\n\n- 第3个人到达交点 $A = (0, 2)$ ，希望逃到交点 $B = (2, 1)$ ，现在他最少需要经过 $5$ 只袋熊，如图中虚线所示。", "inputFormat": "- 第 $1$ 行： $R$ 表示横向道路的数目，$C$ 表示纵向道路的数目。\n- 第 $2$ 行： $H[0][0],\\cdots,H[0][C-2]$。\n- $\\cdots$\n- 第 $(R + 1)$ 行： $H[R-1][0],\\cdots,H[R-1][C-2]$。\n- 第 $(R + 2)$ 行： $V[0][0],\\cdots,V[0][C-1]$。\n- $H$: 二维数组 $R × (C - 1)$ ，其中 $H[P][Q]$ 表示交点 $(P, Q)$ 和交点 $(P, Q +1)$ 之间的横向道路线段上的袋熊数目。\n- $\\cdots$\n- 第 $(2R)$ 行： $V[R-2][0],\\cdots,V[R-2][C-1]$。\n- $V$: 二维数组 $(R - 1) × C$ ，其中 $V[P][Q]$ 表示交点 $(P, Q)$ 和交点 $(P + 1,Q)$ 之间的纵向道路线段上的袋熊数目。\n- 下一行: $E$。\n- 下 $E$ 行：每行一个事件，按照事件发生的顺序给出。\n\n如果 $C = 1$ ，表示横向道路上每条道路线段上的袋熊数目的若干空行(第 $2$ 到 $R +1$ 行)将会被省略。\n\n表示每个事件的那一行格式如下：\n\n- `1 P Q W` 表示 将交点 $(P, Q)$ 和交点 $(P, Q + 1)$ 之间的横向道路线段上的袋熊数目改为 $W$。\n- `2 P Q W` 表示 将交点 $(P, Q)$ 和交点 $(P + 1, Q)$ 之间的纵向道路线段上的袋熊数目改为 $W$。\n- `3 V1 V2` 表示 计算一个人从交点 $(0, V1)$ 逃到交点 $(R-1, V2)$ 最少需要经过多少只袋熊。\n\n例如：题目中的例子应该表示为以下格式\n\n```\n3 4\n0 2 5\n7 1 1\n0 4 0\n0 0 0 2\n0 3 4 7\n5\n3 2 1\n3 3 3\n2 0 0 5\n1 1 1 6\n3 2 1\n\n```", "outputFormat": "对于每一次询问，给出最少经过袋熊数。", "hint": "对于 $100\\%$ 的数据，$2 \\le R \\le 5 \\times 10^3$，$1 \\le C \\le 200$，最多 $500$ 个变化，最多 $2 \\times 10^5$ 次询问，任意时刻一条道路上最多 $10^3$ 只袋熊。", "locale": "zh-CN"}}}
{"pid": "P5900", "type": "P", "difficulty": 7, "samples": [["7", "11"], ["27", "751065460"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "O2优化", "Pólya 定理", "组合数学", "生成函数", "快速傅里叶变换 FFT"], "title": "无标号无根树计数", "background": "考虑到你谷还没有这类题，于是就放了这么个水题。 \n", "description": "求 $n$ 个点的无标号无根树数量，答案对 $998244353$ 取模。", "inputFormat": "输入一行一个正整数 $n$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【数据范围】   \n对于 $30\\%$ 的数据，$1\\le n \\le 1000$；   \n对于 $100\\%$ 的数据，$1\\le n \\le 2\\times 10^5$。  \n\n虽然 $\\Theta(n \\log^2 n)$ 也能过，但是没什么意义，建议写一下 $\\Theta(n \\log n)$ 的做法。", "locale": "zh-CN", "translations": {"en": {"title": "Counting Unlabeled Unrooted Trees", "background": "Considering that Luogu does not have this type of problem yet, here is a simple easy problem.", "description": "Find the number of unlabeled unrooted trees with $n$ nodes. Output the answer modulo $998244353$.", "inputFormat": "Input one line with a positive integer $n$.", "outputFormat": "Output one line with one integer, representing the answer.", "hint": "Constraints  \nFor $30\\%$ of the testdata, $1\\le n \\le 1000$;  \nFor $100\\%$ of the testdata, $1\\le n \\le 2\\times 10^5$.  \n\nAlthough $\\Theta(n \\log^2 n)$ can also pass, it is not very meaningful. It is recommended to implement a $\\Theta(n \\log n)$ solution.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "无标号无根树计数", "background": "考虑到你谷还没有这类题，于是就放了这么个水题。 \n", "description": "求 $n$ 个点的无标号无根树数量，答案对 $998244353$ 取模。", "inputFormat": "输入一行一个正整数 $n$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【数据范围】   \n对于 $30\\%$ 的数据，$1\\le n \\le 1000$；   \n对于 $100\\%$ 的数据，$1\\le n \\le 2\\times 10^5$。  \n\n虽然 $\\Theta(n \\log^2 n)$ 也能过，但是没什么意义，建议写一下 $\\Theta(n \\log n)$ 的做法。", "locale": "zh-CN"}}}
{"pid": "P5901", "type": "P", "difficulty": 6, "samples": [["6 3 4\n1\n1 2\n1 3\n2 3\n2 3\n5 1\n1 2\n\n1 3\n\n2 3\n\n3 1", "\n\n\n\n\n\n\n\n1 [刷新缓冲区]\n\n3 [刷新缓冲区]\n\n2 [刷新缓冲区]\n\n1 [刷新缓冲区]\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2009", "IOI", "交互题", "Special Judge", "O2优化", "根号分治"], "title": "[IOI 2009] Regions", "background": "### 滥用本题评测将被封号\n\nIOI2009 D2T3\n\n原题时间限制 8s，为节约评测资源，时间限制改为 4s。", "description": "联合国区域发展委员会（The United Nations Regional Development Agency, UNRDA）有一个良好的组织结构。它任用了 $N$ 名委员，每名委员都属于几个地区中的一个。委员们按照其资历被编号为 $1$ 到 $N$ ，$1$ 号委员是主席，资历最高。委员所属地区被编号为 $1$ 到 $R$。除了主席之外所有委员都有一个直接导师。任何直接导师的资历都比他所指导的委员的资历要高。\n\n我们称委员 $A$ 是委员 $B$ 的导师当且仅当 $A$ 是 $B$ 的直接导师或者 $A$ 是 $B$ 的直接导师的导师。显然，主席是所有其他委员的导师，没有任何两名委员互为导师。\n\n现在，为了调查大量对 UNRDA 偏向某些地区的不平衡的组织结构的指控，UNRDA 想要建立一个计算机系统：在给定委员之间的直接导师关系的情况下，该系统可以回答下述形式的问题：给定两个地区 $r_1$ 和 $r_2$，要求系统回答委员会中有多少对委员 $e_1$ 和 $e_2$，满足 $e_1$ 属于 $r_1$，而 $e_2$ 属于 $r_2$，并且 $e_1$ 是 $e_2$ 的导师。每次询问都有两个参数 $r_1$ 和 $r_2$，结果是一个整数：满足上述条件的 $(e_1, e_2)$ 二元组的数量。\n\n**任务**：编写一个程序，给定每个委员的地区和直接导师，**在线** 回答上述询问。\n\n**强制在线将以交互的格式进行**。", "inputFormat": "第一行包含三个整数 $N, R, Q$，分别由一个空格隔开，分别表示雇员人数，区域数和查询数。\n\n接下来 $N$ 行按照资历的顺序给出了 $N$ 个委员的描述信息。其中第 $k$ 行描述了编号为 $k$ 的委员。第一行（描述主席的一行）包含一个整数：主席所属的地区 $H_1$。其余的 $N - 1$ 行，每行包含两个整数，以一个空格隔开分别表示委员 $k$ 的直接导师 $S_k$ 和委员 $k$ 所属的地区 $H_k$。\n\n### 交互格式\n\n在读入所有输入数据之后，你的程序必须依次从标准输入中读入询问，并将询问结果输出至标准输出。必须依次回答 $Q$ 个询问，每次回答一个。**在读入下一个询问之前，你必须先回答当前询问**。\n\n每个询问是标准输入的一行，用两个不同整数 $r_1, r_2$ 表示。", "outputFormat": "对查询的回答是标准输出的一行，包含一个整数，表示在 UNRDA 中有多少对委员 $e_1$ 和 $e_2$ 满足下述条件：$e_1$ 属于地区 $r_1$，$e_2$ 属于地区 $r_2$，并且 $e_1$ 是 $e_2$ 的导师。\n\n**注意**：输入数据保证给出的任意询问的正确答案小于 $10 ^ 9$。\n\n**特别注意**：为了正确地和交互库交互，你的程序必须 **在回答每次询问后刷新标准输出缓冲区**。你同样需要避免意外地在读入标准输入时堵住了输入流，这有可能在你使用 `scanf(\"%d\\n\", ...)` 的语句时发生。\n\n你可以使用如下语句来清空缓冲区：\n\n- 对于 C/C++：`fflush(stdout)`；\n- 对于 C++：`std::cout << std::flush`；\n- 对于 Java：`System.out.flush()`；\n- 对于 Python：`stdout.flush()`；\n- 对于 Pascal：`flush(output)`；\n- 对于其他语言，请自行查阅对应语言的帮助文档。\n\n特别的，对于 C++ 语言，在输出换行时如果你使用 `std::endl` 而不是 `'\\n'`，也可以自动刷新缓冲区。", "hint": "### 数据范围与约定\n\n- 对于 $30\\%$ 的数据，$N\\leq 500$。\n- 对于 $55\\%$ 的数据，没有地区包含超过 $500$ 个委员。\n- 同时满足上述两个条件的数据有 $15\\%$，至少满足上述一个条件的数据有 $70\\%$。\n- 对于 $100\\%$ 的数据，$1 \\le N, Q \\le 2 \\times 10^5$，$1 \\le H_k, r_1, r_2 \\le R \\le 2.5 \\times 10^4$，$1 \\le S_k < k$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2009] Regions", "background": "### Abuse of this problem’s judging will result in account suspension.\n\nIOI 2009 D2T3.\n\nThe original time limit was 8 s. To save judging resources, the time limit has been changed to 4 s.", "description": "The United Nations Regional Development Agency (UNRDA) has a well-organized structure. It employs $N$ commissioners, and each commissioner belongs to one of several regions. The commissioners are numbered from $1$ to $N$ according to seniority, where commissioner $1$ is the chairperson and has the highest seniority. The regions are numbered from $1$ to $R$. Every commissioner except the chairperson has a direct mentor. Any direct mentor has higher seniority than the commissioner they mentor.\n\nWe say that commissioner $A$ is a mentor of commissioner $B$ if and only if $A$ is the direct mentor of $B$, or $A$ is a mentor of the direct mentor of $B$. Clearly, the chairperson is a mentor of every other commissioner, and no two commissioners are mentors of each other.\n\nNow, to investigate many accusations that UNRDA is biased toward certain regions due to an unbalanced organizational structure, UNRDA wants to build a computer system: given the direct mentor relationships between commissioners, the system can answer queries of the following form. Given two regions $r_1$ and $r_2$, the system should answer how many pairs of commissioners $e_1$ and $e_2$ satisfy: $e_1$ belongs to $r_1$, $e_2$ belongs to $r_2$, and $e_1$ is a mentor of $e_2$. Each query has two parameters $r_1$ and $r_2$, and the result is an integer: the number of ordered pairs $(e_1, e_2)$ satisfying the conditions above.\n\n**Task**: Write a program that, given each commissioner’s region and direct mentor, answers the queries above **online**.\n\n**Forced online will be conducted in an interactive format**.", "inputFormat": "The first line contains three integers $N, R, Q$, separated by a single space, representing the number of employees, the number of regions, and the number of queries.\n\nThe next $N$ lines give the description of the $N$ commissioners in order of seniority. Line $k$ describes commissioner number $k$. The first line (the one describing the chairperson) contains one integer: the region $H_1$ to which the chairperson belongs. Each of the remaining $N - 1$ lines contains two integers separated by a single space, representing the direct mentor $S_k$ of commissioner $k$ and the region $H_k$ to which commissioner $k$ belongs.\n\n### Interactive Format\n\nAfter reading all input data, your program must then read the queries one by one from standard input, and output the answers to standard output. You must answer exactly $Q$ queries, one at a time. **Before reading the next query, you must answer the current query first**.\n\nEach query is one line from standard input, containing two distinct integers $r_1, r_2$.", "outputFormat": "For each query, output one line to standard output containing one integer: the number of pairs of commissioners $e_1$ and $e_2$ in UNRDA that satisfy the following conditions: $e_1$ belongs to region $r_1$, $e_2$ belongs to region $r_2$, and $e_1$ is a mentor of $e_2$.\n\n**Note**: The input guarantees that the correct answer for any query is less than $10 ^ 9$.\n\n**Special note**: To interact correctly with the interactive library, your program must **flush the standard output buffer after answering each query**. You also need to avoid accidentally blocking when reading from standard input, which may happen if you use a statement like `scanf(\"%d\\n\", ...)`.\n\nYou may use the following statements to flush the buffer:\n\n- For C/C++: `fflush(stdout)`;\n- For C++: `std::cout << std::flush`;\n- For Java: `System.out.flush()`;\n- For Python: `stdout.flush()`;\n- For Pascal: `flush(output)`;\n- For other languages, please refer to the documentation of the corresponding language.\n\nIn particular, for C++, when outputting a newline, if you use `std::endl` instead of `'\\n'`, the buffer can also be flushed automatically.", "hint": "### Constraints and Notes\n\n- For $30\\%$ of the testdata, $N \\leq 500$.\n- For $55\\%$ of the testdata, no region contains more than $500$ commissioners.\n- $15\\%$ of the testdata satisfies both conditions above, and $70\\%$ of the testdata satisfies at least one of the conditions above.\n- For $100\\%$ of the testdata, $1 \\le N, Q \\le 2 \\times 10^5$, $1 \\le H_k, r_1, r_2 \\le R \\le 2.5 \\times 10^4$, $1 \\le S_k < k$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2009] Regions", "background": "### 滥用本题评测将被封号\n\nIOI2009 D2T3\n\n原题时间限制 8s，为节约评测资源，时间限制改为 4s。", "description": "联合国区域发展委员会（The United Nations Regional Development Agency, UNRDA）有一个良好的组织结构。它任用了 $N$ 名委员，每名委员都属于几个地区中的一个。委员们按照其资历被编号为 $1$ 到 $N$ ，$1$ 号委员是主席，资历最高。委员所属地区被编号为 $1$ 到 $R$。除了主席之外所有委员都有一个直接导师。任何直接导师的资历都比他所指导的委员的资历要高。\n\n我们称委员 $A$ 是委员 $B$ 的导师当且仅当 $A$ 是 $B$ 的直接导师或者 $A$ 是 $B$ 的直接导师的导师。显然，主席是所有其他委员的导师，没有任何两名委员互为导师。\n\n现在，为了调查大量对 UNRDA 偏向某些地区的不平衡的组织结构的指控，UNRDA 想要建立一个计算机系统：在给定委员之间的直接导师关系的情况下，该系统可以回答下述形式的问题：给定两个地区 $r_1$ 和 $r_2$，要求系统回答委员会中有多少对委员 $e_1$ 和 $e_2$，满足 $e_1$ 属于 $r_1$，而 $e_2$ 属于 $r_2$，并且 $e_1$ 是 $e_2$ 的导师。每次询问都有两个参数 $r_1$ 和 $r_2$，结果是一个整数：满足上述条件的 $(e_1, e_2)$ 二元组的数量。\n\n**任务**：编写一个程序，给定每个委员的地区和直接导师，**在线** 回答上述询问。\n\n**强制在线将以交互的格式进行**。", "inputFormat": "第一行包含三个整数 $N, R, Q$，分别由一个空格隔开，分别表示雇员人数，区域数和查询数。\n\n接下来 $N$ 行按照资历的顺序给出了 $N$ 个委员的描述信息。其中第 $k$ 行描述了编号为 $k$ 的委员。第一行（描述主席的一行）包含一个整数：主席所属的地区 $H_1$。其余的 $N - 1$ 行，每行包含两个整数，以一个空格隔开分别表示委员 $k$ 的直接导师 $S_k$ 和委员 $k$ 所属的地区 $H_k$。\n\n### 交互格式\n\n在读入所有输入数据之后，你的程序必须依次从标准输入中读入询问，并将询问结果输出至标准输出。必须依次回答 $Q$ 个询问，每次回答一个。**在读入下一个询问之前，你必须先回答当前询问**。\n\n每个询问是标准输入的一行，用两个不同整数 $r_1, r_2$ 表示。", "outputFormat": "对查询的回答是标准输出的一行，包含一个整数，表示在 UNRDA 中有多少对委员 $e_1$ 和 $e_2$ 满足下述条件：$e_1$ 属于地区 $r_1$，$e_2$ 属于地区 $r_2$，并且 $e_1$ 是 $e_2$ 的导师。\n\n**注意**：输入数据保证给出的任意询问的正确答案小于 $10 ^ 9$。\n\n**特别注意**：为了正确地和交互库交互，你的程序必须 **在回答每次询问后刷新标准输出缓冲区**。你同样需要避免意外地在读入标准输入时堵住了输入流，这有可能在你使用 `scanf(\"%d\\n\", ...)` 的语句时发生。\n\n你可以使用如下语句来清空缓冲区：\n\n- 对于 C/C++：`fflush(stdout)`；\n- 对于 C++：`std::cout << std::flush`；\n- 对于 Java：`System.out.flush()`；\n- 对于 Python：`stdout.flush()`；\n- 对于 Pascal：`flush(output)`；\n- 对于其他语言，请自行查阅对应语言的帮助文档。\n\n特别的，对于 C++ 语言，在输出换行时如果你使用 `std::endl` 而不是 `'\\n'`，也可以自动刷新缓冲区。", "hint": "### 数据范围与约定\n\n- 对于 $30\\%$ 的数据，$N\\leq 500$。\n- 对于 $55\\%$ 的数据，没有地区包含超过 $500$ 个委员。\n- 同时满足上述两个条件的数据有 $15\\%$，至少满足上述一个条件的数据有 $70\\%$。\n- 对于 $100\\%$ 的数据，$1 \\le N, Q \\le 2 \\times 10^5$，$1 \\le H_k, r_1, r_2 \\le R \\le 2.5 \\times 10^4$，$1 \\le S_k < k$。", "locale": "zh-CN"}}}
{"pid": "P5902", "type": "P", "difficulty": 6, "samples": [["4 5 3 100\n2 80 100\n20 125 130\n10 75 150\n5 120 110\n", "50\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2009", "IOI", "O2优化"], "title": "[IOI 2009] Salesman", "background": "IOI2009 D2T4", "description": "旅行商已经发现，最佳的陆上旅行计划是一个难以解决的计算问题，所以他将他的生意转移到多瑙河的线性世界。他有一条很快的船，可以在很短的时间内把他从沿河的任何地方送到任何地方，但不幸的是，这条船耗油量很大。旅行商向上游（靠近河流源头的方向）移动每一米的成本为 $U$ 美元，向下游（远离河流源头的方向）移动每一米的成本为 $D$ 美元。\n\n沿河有 $N$ 个展销会，旅行商想参加。每场展销会只举行一天。对于每个展销会 $X$，旅行商知道它的日期 $T_X$（他买船后的天数为第 $0$ 天），集市的位置 $L_X$ 和他在这场集市上能获得的盈利 $M_X$。位置表示集市到河流源头的距离，以米为单位。他必须在位置为 $S$ 的家 **开始和结束** 他的旅程。\n\n帮助旅行商选择参加哪些展销会（如果有的话）以及按什么顺序，这样他可以在旅行结束时最大化他的利润。旅行商的总利润是指他在参加集市时获得的美元减去他在河上下游旅行所花费的美元的总和。\n\n请记住，如果展销会 $A$ 的举办时间早于展销会 $B$，则旅行商只能按此顺序去展销会（即，他不能先去展销会 $B$，然后再去展销会 $A$）。但是，如果两个集市在同一天举行，旅行商可以按任何顺序参观。旅行商一天去多少个集市是没有限制的，但他不能在同一个集市盈利两次。他可以经过他已经参观过的集市而一无所获。\n\n**任务**：编写一个程序，给定所有展销会的日期，位置和旅行商的盈利额，以及旅行商的家的位置和他移动的代价，求出他在旅行结束时的最大利润。", "inputFormat": "第一行包含四个整数 $N, U, D, S$，分别由一个空格隔开，分别表示展销会数，向上游（$U$）或下游（$D$）移动的单位代价，以及旅行商的家的位置。\n\n接下来的 $N$ 行描述了 $N$ 个展销会。其中第 $k$ 行描述了第 $k$ 个展销会的信息，包含三个整数，分别由一个空格隔开，分别表示展销会日期 $T_k$，它的位置 $L_k$，以及旅行商在该次展销会能获得的的盈利 $M_k$。", "outputFormat": "一行一个整数表示旅行商在旅行结束时的最大利润。", "hint": "### 样例解释\n\n在一个最优方案中，旅行商参加了编号为 $1$ 和 $3$ 的展销会（位置分别为 $80$ 和 $75$）。事件序列以及对应的利润如下：\n\n- 旅行商从家出发，向上游移动 $20$ 米，花费 $100$ 美元。目前利润：$-100$。\n- 旅行商参加展销会 $1$ 并赚取 $100$ 美元。目前利润：$0$。\n- 旅行商向上游移动 $5$ 米，花费 $25$ 美元。目前利润 $-25$。\n- 旅行商参加展销会 $3$ 并赚取 $150$ 美元。目前利润：$125$。\n- 旅行商向下游移动 $25$ 米，回到自己的家，花费 $75$ 美元。最终利润：$50$。\n\n### 数据范围与约定\n\n- 对于 $60\\%$ 的数据，没有两个展销会在同一天举行。\n- 对于 $40\\%$ 的数据，输入的所有数不超过 $5000$。\n- 同时满足上述两个条件的数据有 $15\\%$，至少满足上述一个条件的数据有 $85\\%$。\n- 对于 $100\\%$ 的数据，$1 \\le N, T_k \\le 5\\times 10^5$，$1 \\le D \\le U \\le 10$，$1 \\le S, L_k \\le 5 \\times 10^5 +1$，$1 \\le M_k \\le 4000$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2009] Salesman", "background": "IOI 2009 D2T4.", "description": "The traveling salesman has found that the best overland travel plan is a hard computational problem to solve, so he moved his business to the linear world of the Danube River. He has a very fast boat that can take him from anywhere along the river to anywhere else in a short time, but unfortunately, this boat consumes a lot of fuel. The cost for the salesman to move upstream (toward the river source) by every meter is $U$ dollars, and the cost to move downstream (away from the river source) by every meter is $D$ dollars.\n\nThere are $N$ fairs along the river that the salesman wants to attend. Each fair lasts only one day. For each fair $X$, the salesman knows its day $T_X$ (day $0$ is the day he bought the boat), the fair location $L_X$, and the profit $M_X$ he can earn at this fair. The location is the distance from the river source, in meters. He must **start and end** his trip at his home, located at position $S$.\n\nHelp the salesman choose which fairs to attend (if any) and in what order, so that he can maximize his profit when the trip ends. The salesman’s total profit is the sum of dollars earned from attended fairs minus the dollars spent traveling upstream and downstream.\n\nNote that if fair $A$ is held earlier than fair $B$, then the salesman can only visit them in this order (i.e., he cannot visit fair $B$ first and then fair $A$). However, if two fairs are held on the same day, he may visit them in any order. There is no limit on how many fairs he can visit in one day, but he cannot earn profit from the same fair twice. He may pass through fairs he has already visited without earning anything.\n\n**Task**: Write a program that, given the day, location, and profit of each fair, as well as the location of the salesman’s home and his movement costs, computes the maximum profit he can have at the end of his trip.", "inputFormat": "The first line contains four integers $N, U, D, S$, separated by single spaces, representing the number of fairs, the per-meter cost of moving upstream ($U$) or downstream ($D$), and the position of the salesman’s home.\n\nThe next $N$ lines describe the $N$ fairs. The $k$-th line contains three integers, separated by single spaces, representing the fair day $T_k$, its location $L_k$, and the profit $M_k$ the salesman can earn at this fair.", "outputFormat": "Output one integer: the maximum profit the salesman can have at the end of the trip.", "hint": "### Sample Explanation\n\nIn one optimal plan, the salesman attends fairs $1$ and $3$ (at positions $80$ and $75$, respectively). The sequence of events and the corresponding profit are as follows:\n\n- The salesman leaves home and moves upstream by $20$ meters, costing $100$ dollars. Current profit: $-100$.\n- The salesman attends fair $1$ and earns $100$ dollars. Current profit: $0$.\n- The salesman moves upstream by $5$ meters, costing $25$ dollars. Current profit: $-25$.\n- The salesman attends fair $3$ and earns $150$ dollars. Current profit: $125$.\n- The salesman moves downstream by $25$ meters to return home, costing $75$ dollars. Final profit: $50$.\n\n### Constraints\n\n- For $60\\%$ of the testdata, no two fairs are held on the same day.\n- For $40\\%$ of the testdata, all input numbers are at most $5000$.\n- $15\\%$ of the testdata satisfies both conditions above, and $85\\%$ satisfies at least one of them.\n- For $100\\%$ of the testdata, $1 \\le N, T_k \\le 5\\times 10^5$, $1 \\le D \\le U \\le 10$, $1 \\le S, L_k \\le 5 \\times 10^5 +1$, $1 \\le M_k \\le 4000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2009] Salesman", "background": "IOI2009 D2T4", "description": "旅行商已经发现，最佳的陆上旅行计划是一个难以解决的计算问题，所以他将他的生意转移到多瑙河的线性世界。他有一条很快的船，可以在很短的时间内把他从沿河的任何地方送到任何地方，但不幸的是，这条船耗油量很大。旅行商向上游（靠近河流源头的方向）移动每一米的成本为 $U$ 美元，向下游（远离河流源头的方向）移动每一米的成本为 $D$ 美元。\n\n沿河有 $N$ 个展销会，旅行商想参加。每场展销会只举行一天。对于每个展销会 $X$，旅行商知道它的日期 $T_X$（他买船后的天数为第 $0$ 天），集市的位置 $L_X$ 和他在这场集市上能获得的盈利 $M_X$。位置表示集市到河流源头的距离，以米为单位。他必须在位置为 $S$ 的家 **开始和结束** 他的旅程。\n\n帮助旅行商选择参加哪些展销会（如果有的话）以及按什么顺序，这样他可以在旅行结束时最大化他的利润。旅行商的总利润是指他在参加集市时获得的美元减去他在河上下游旅行所花费的美元的总和。\n\n请记住，如果展销会 $A$ 的举办时间早于展销会 $B$，则旅行商只能按此顺序去展销会（即，他不能先去展销会 $B$，然后再去展销会 $A$）。但是，如果两个集市在同一天举行，旅行商可以按任何顺序参观。旅行商一天去多少个集市是没有限制的，但他不能在同一个集市盈利两次。他可以经过他已经参观过的集市而一无所获。\n\n**任务**：编写一个程序，给定所有展销会的日期，位置和旅行商的盈利额，以及旅行商的家的位置和他移动的代价，求出他在旅行结束时的最大利润。", "inputFormat": "第一行包含四个整数 $N, U, D, S$，分别由一个空格隔开，分别表示展销会数，向上游（$U$）或下游（$D$）移动的单位代价，以及旅行商的家的位置。\n\n接下来的 $N$ 行描述了 $N$ 个展销会。其中第 $k$ 行描述了第 $k$ 个展销会的信息，包含三个整数，分别由一个空格隔开，分别表示展销会日期 $T_k$，它的位置 $L_k$，以及旅行商在该次展销会能获得的的盈利 $M_k$。", "outputFormat": "一行一个整数表示旅行商在旅行结束时的最大利润。", "hint": "### 样例解释\n\n在一个最优方案中，旅行商参加了编号为 $1$ 和 $3$ 的展销会（位置分别为 $80$ 和 $75$）。事件序列以及对应的利润如下：\n\n- 旅行商从家出发，向上游移动 $20$ 米，花费 $100$ 美元。目前利润：$-100$。\n- 旅行商参加展销会 $1$ 并赚取 $100$ 美元。目前利润：$0$。\n- 旅行商向上游移动 $5$ 米，花费 $25$ 美元。目前利润 $-25$。\n- 旅行商参加展销会 $3$ 并赚取 $150$ 美元。目前利润：$125$。\n- 旅行商向下游移动 $25$ 米，回到自己的家，花费 $75$ 美元。最终利润：$50$。\n\n### 数据范围与约定\n\n- 对于 $60\\%$ 的数据，没有两个展销会在同一天举行。\n- 对于 $40\\%$ 的数据，输入的所有数不超过 $5000$。\n- 同时满足上述两个条件的数据有 $15\\%$，至少满足上述一个条件的数据有 $85\\%$。\n- 对于 $100\\%$ 的数据，$1 \\le N, T_k \\le 5\\times 10^5$，$1 \\le D \\le U \\le 10$，$1 \\le S, L_k \\le 5 \\times 10^5 +1$，$1 \\le M_k \\le 4000$。", "locale": "zh-CN"}}}
{"pid": "P5903", "type": "P", "difficulty": 5, "samples": [["6 3 7\n5 5 2 2 0 3\n", "1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化", "树链剖分", "模板题"], "title": "【模板】树上 K 级祖先", "background": "**本题仅作为长链剖分求树上 $k$ 级祖先评测用，不保证卡掉了其他复杂度不正确的做法。**", "description": "给定一棵 $n$ 个点的有根树。\n\n有 $q$ 次询问，第 $i$ 次询问给定 $x_i, k_i$，要求点 $x_i$ 的 $k_i$ 级祖先，答案为 $ans_i$。特别地，$ans_0 = 0$。\n\n\n\n本题中的询问将在程序内生成。\n\n给定一个随机种子 $s$ 和一个随机函数 $\\operatorname{get}(x)$：\n\n```cpp\n#define ui unsigned int\nui s;\n\ninline ui get(ui x) {\n\tx ^= x << 13;\n\tx ^= x >> 17;\n\tx ^= x << 5;\n\treturn s = x; \n}\n```\n\n你需要按顺序依次生成询问。\n\n设 $d_i$ 为点 $i$ 的深度，其中根的深度为 $1$。\n\n对于第 $i$ 次询问，$x_i = ((\\operatorname{get}(s) \\operatorname{xor} ans_{i-1}) \\bmod n) + 1$，$k_i = (\\operatorname{get}(s) \\operatorname{xor} ans_{i-1}) \\bmod d_{x_i}$。", "inputFormat": "第一行三个整数 $n, q, s$。\n\n第二行 $n$ 个整数 $f_{1\\dots n}$，其中 $f_i$ 表示 $i$ 的父亲。特别地，若 $f_i = 0$，则 $i$ 为根。", "outputFormat": "一行一个整数，表示 $\\operatorname{xor}_{i=1}^q i \\times ans_i$。", "hint": "【样例说明】\n\n$x_1 = 4$，$k_1 = 1$，$ans_1 = 2$；  \n$x_2 = 6$，$k_2 = 3$，$ans_2 = 5$；  \n$x_3 = 3$，$k_3 = 0$，$ans_3 = 3$；  \n故输出 $1$。\n\n---\n\n对于 $20\\%$ 的数据，$n,q \\le 10^3$。\n\n对于 $50\\%$ 的数据，$n,q \\le 10^5$。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 5 \\times 10^5$，$1 \\le q \\le 5 \\times 10^6$，$1 \\le s < 2^{32}$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] $K$-th Ancestor on a Tree", "background": "**This problem is only for judging solutions that use long chain decomposition to find the $k$-th ancestor on a tree, and it does not guarantee that other methods with incorrect complexity will be rejected.**", "description": "Given a rooted tree with $n$ nodes.\n\nThere are $q$ queries. In the $i$-th query, $x_i$ and $k_i$ are given. You need to find the $k_i$-th ancestor of node $x_i$, and denote the answer as $ans_i$. In particular, $ans_0 = 0$.\n\nThe queries in this problem are generated within the program.\n\nA random seed $s$ and a random function $\\operatorname{get}(x)$ are given:\n\n```cpp\n#define ui unsigned int\nui s;\n\ninline ui get(ui x) {\n\tx ^= x << 13;\n\tx ^= x >> 17;\n\tx ^= x << 5;\n\treturn s = x; \n}\n```\n\nYou need to generate the queries in order.\n\nLet $d_i$ be the depth of node $i$, where the root has depth $1$.\n\nFor the $i$-th query, $x_i = ((\\operatorname{get}(s) \\operatorname{xor} ans_{i-1}) \\bmod n) + 1$, and $k_i = (\\operatorname{get}(s) \\operatorname{xor} ans_{i-1}) \\bmod d_{x_i}$.", "inputFormat": "The first line contains three integers $n, q, s$.\n\nThe second line contains $n$ integers $f_{1\\dots n}$, where $f_i$ is the parent of $i$. In particular, if $f_i = 0$, then $i$ is the root.", "outputFormat": "Output one integer per line, representing $\\operatorname{xor}_{i=1}^q i \\times ans_i$.", "hint": "[Sample Explanation]\n\n$x_1 = 4$, $k_1 = 1$, $ans_1 = 2$.  \n$x_2 = 6$, $k_2 = 3$, $ans_2 = 5$.  \n$x_3 = 3$, $k_3 = 0$, $ans_3 = 3$.  \nTherefore, the output is $1$.\n\n---\n\nFor $20\\%$ of the testdata, $n, q \\le 10^3$.\n\nFor $50\\%$ of the testdata, $n, q \\le 10^5$.\n\nFor $100\\%$ of the testdata, $2 \\le n \\le 5 \\times 10^5$, $1 \\le q \\le 5 \\times 10^6$, $1 \\le s < 2^{32}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】树上 K 级祖先", "background": "**本题仅作为长链剖分求树上 $k$ 级祖先评测用，不保证卡掉了其他复杂度不正确的做法。**", "description": "给定一棵 $n$ 个点的有根树。\n\n有 $q$ 次询问，第 $i$ 次询问给定 $x_i, k_i$，要求点 $x_i$ 的 $k_i$ 级祖先，答案为 $ans_i$。特别地，$ans_0 = 0$。\n\n\n\n本题中的询问将在程序内生成。\n\n给定一个随机种子 $s$ 和一个随机函数 $\\operatorname{get}(x)$：\n\n```cpp\n#define ui unsigned int\nui s;\n\ninline ui get(ui x) {\n\tx ^= x << 13;\n\tx ^= x >> 17;\n\tx ^= x << 5;\n\treturn s = x; \n}\n```\n\n你需要按顺序依次生成询问。\n\n设 $d_i$ 为点 $i$ 的深度，其中根的深度为 $1$。\n\n对于第 $i$ 次询问，$x_i = ((\\operatorname{get}(s) \\operatorname{xor} ans_{i-1}) \\bmod n) + 1$，$k_i = (\\operatorname{get}(s) \\operatorname{xor} ans_{i-1}) \\bmod d_{x_i}$。", "inputFormat": "第一行三个整数 $n, q, s$。\n\n第二行 $n$ 个整数 $f_{1\\dots n}$，其中 $f_i$ 表示 $i$ 的父亲。特别地，若 $f_i = 0$，则 $i$ 为根。", "outputFormat": "一行一个整数，表示 $\\operatorname{xor}_{i=1}^q i \\times ans_i$。", "hint": "【样例说明】\n\n$x_1 = 4$，$k_1 = 1$，$ans_1 = 2$；  \n$x_2 = 6$，$k_2 = 3$，$ans_2 = 5$；  \n$x_3 = 3$，$k_3 = 0$，$ans_3 = 3$；  \n故输出 $1$。\n\n---\n\n对于 $20\\%$ 的数据，$n,q \\le 10^3$。\n\n对于 $50\\%$ 的数据，$n,q \\le 10^5$。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 5 \\times 10^5$，$1 \\le q \\le 5 \\times 10^6$，$1 \\le s < 2^{32}$。", "locale": "zh-CN"}}}
{"pid": "P5904", "type": "P", "difficulty": 6, "samples": [["7\n1 2\n5 7\n2 5\n2 3\n5 6\n4 5\n", "5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2014", "POI（波兰）", "O2优化", "树形 DP", "树链剖分", "前缀和"], "title": "[POI 2014] HOT-Hotels 加强版", "background": "同 [[POI2014]HOT-Hotels](https://www.luogu.com.cn/problem/P3565)，数据范围加大到 $1 \\le n \\le 10^5$。\n\n来源于 BZOJ4543。", "description": "给出一棵有 $n$ 个点的树，求有多少组点 $(i,j,k)$ 满足 $i,j,k$ 两两之间的距离都相等。  \n\n$(i,j,k)$ 与 $(i,k,j)$ 算作同一组。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n-1$ 行，每行两个整数 $a,b$，表示在 $a,b$ 之间有一条边。", "outputFormat": "一行一个整数，表示所有合法的点的组数。", "hint": "对于 $100\\%$ 的数据， $1\\le n\\le10^5, 1\\le a\\le b\\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] HOT-Hotels Enhanced Version", "background": "Same as [[POI2014]HOT-Hotels](https://www.luogu.com.cn/problem/P3565), but the Constraints are increased to $1 \\le n \\le 10^5$.\n\nSource: BZOJ4543.", "description": "Given a tree with $n$ nodes, find how many triples of nodes $(i,j,k)$ satisfy that the distances between every pair among $i,j,k$ are all equal.\n\n$(i,j,k)$ and $(i,k,j)$ are considered the same triple.", "inputFormat": "The first line contains an integer $n$.\n\nThe next $n-1$ lines each contain two integers $a,b$, meaning there is an edge between $a$ and $b$.", "outputFormat": "Output one integer in one line, representing the number of all valid triples of nodes.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 10^5, 1 \\le a \\le b \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] HOT-Hotels 加强版", "background": "同 [[POI2014]HOT-Hotels](https://www.luogu.com.cn/problem/P3565)，数据范围加大到 $1 \\le n \\le 10^5$。\n\n来源于 BZOJ4543。", "description": "给出一棵有 $n$ 个点的树，求有多少组点 $(i,j,k)$ 满足 $i,j,k$ 两两之间的距离都相等。  \n\n$(i,j,k)$ 与 $(i,k,j)$ 算作同一组。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n-1$ 行，每行两个整数 $a,b$，表示在 $a,b$ 之间有一条边。", "outputFormat": "一行一个整数，表示所有合法的点的组数。", "hint": "对于 $100\\%$ 的数据， $1\\le n\\le10^5, 1\\le a\\le b\\le n$。", "locale": "zh-CN"}}}
{"pid": "P5905", "type": "P", "difficulty": 4, "samples": [["5 7\n1 2 4\n1 4 10\n2 3 7\n4 5 3\n4 2 -2\n3 4 -3\n5 3 4", "128\n1000000072\n999999978\n1000000026\n1000000014\n"], ["5 5\n1 2 4\n3 4 9\n3 4 -3\n4 5 3\n5 3 -2", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "O2优化", "最短路", "模板题"], "title": "【模板】全源最短路（Johnson）", "background": "", "description": "给定一个包含 $n$ 个结点和 $m$ 条带权边的有向图，求所有点对间的最短路径长度，一条路径的长度定义为这条路径上所有边的权值和。\n\n注意：\n\n1. 边权**可能**为负，且图中**可能**存在重边和自环；\n\n2. 部分数据卡 $n$ 轮 SPFA 算法。\n\n", "inputFormat": "第 $1$ 行：$2$ 个整数 $n,m$，表示给定有向图的结点数量和有向边数量。\n\n接下来 $m$ 行：每行 $3$ 个整数 $u,v,w$，表示有一条权值为 $w$ 的有向边从编号为 $u$ 的结点连向编号为 $v$ 的结点。", "outputFormat": "若图中存在负环，输出仅一行 $-1$。\n\n若图中不存在负环：\n\n输出 $n$ 行：令 $dis_{i,j}$ 为从 $i$ 到 $j$ 的最短路，在第 $i$ 行输出 $\\sum\\limits_{j=1}^n j\\times dis_{i,j}$，注意这个结果可能超过 int 存储范围。\n\n如果不存在从 $i$ 到 $j$ 的路径，则 $dis_{i,j}=10^9$；如果 $i=j$，则 $dis_{i,j}=0$。", "hint": "【样例解释】\n\n左图为样例 $1$ 给出的有向图，最短路构成的答案矩阵为：\n\n```\n0 4 11 8 11 \n1000000000 0 7 4 7 \n1000000000 -5 0 -3 0 \n1000000000 -2 5 0 3 \n1000000000 -1 4 1 0 \n```\n\n右图为样例 $2$ 给出的有向图，红色标注的边构成了负环，注意给出的图不一定连通。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7lb35u4u.png)\n\n【数据范围】\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 3\\times 10^3,\\ \\ 1\\leq m\\leq 6\\times 10^3,\\ \\ 1\\leq u,v\\leq n,\\ \\ -3\\times 10^5\\leq w\\leq 3\\times 10^5$。\n\n对于 $20\\%$ 的数据，$1\\leq n\\leq 100$，不存在负环（可用于验证 Floyd 正确性）\n\n对于另外 $20\\%$ 的数据，$w\\ge 0$（可用于验证 Dijkstra 正确性）\n\nupd. 添加一组 Hack 数据：针对 SPFA 的 SLF 优化", "locale": "zh-CN", "translations": {"en": {"title": "[Template] All-Pairs Shortest Paths (Johnson).", "background": "", "description": "Given a directed graph with $n$ nodes and $m$ weighted edges, find the shortest path length between every pair of nodes. The length of a path is defined as the sum of the weights of all edges on the path.\n\nNote:\n\n1. Edge weights **may** be negative, and the graph **may** contain multiple edges and self-loops.\n2. Some testdata is designed to make running SPFA for $n$ rounds fail.", "inputFormat": "Line $1$: Two integers $n, m$, representing the number of nodes and the number of directed edges in the given graph.\n\nNext $m$ lines: Each line contains three integers $u, v, w$, meaning there is a directed edge of weight $w$ from node $u$ to node $v$.", "outputFormat": "If the graph contains a negative cycle, output only one line: $-1$.\n\nIf the graph does not contain a negative cycle:\n\nOutput $n$ lines. Let $dis_{i,j}$ be the shortest path from $i$ to $j$. On line $i$, output $\\sum\\limits_{j=1}^n j\\times dis_{i,j}$. Note that this value may exceed the range of `int`.\n\nIf there is no path from $i$ to $j$, then $dis_{i,j}=10^9$; if $i=j$, then $dis_{i,j}=0$.", "hint": "[Sample Explanation]\n\nThe left figure shows the directed graph given in sample $1$. The answer matrix formed by the shortest paths is:\n\n```\n0 4 11 8 11 \n1000000000 0 7 4 7 \n1000000000 -5 0 -3 0 \n1000000000 -2 5 0 3 \n1000000000 -1 4 1 0 \n```\n\nThe right figure shows the directed graph given in sample $2$. The edges marked in red form a negative cycle. Note that the given graph may be disconnected.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7lb35u4u.png)\n\n[Constraints]\n\nFor $100\\%$ of the data, $1\\leq n\\leq 3\\times 10^3,\\ \\ 1\\leq m\\leq 6\\times 10^3,\\ \\ 1\\leq u,v\\leq n,\\ \\ -3\\times 10^5\\leq w\\leq 3\\times 10^5$.\n\nFor $20\\%$ of the data, $1\\leq n\\leq 100$, and there is no negative cycle (can be used to verify Floyd correctness).\n\nFor another $20\\%$ of the data, $w\\ge 0$ (can be used to verify Dijkstra correctness).\n\nupd. Added a set of hack testdata: targeting the SLF optimization of SPFA.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】全源最短路（Johnson）", "background": "", "description": "给定一个包含 $n$ 个结点和 $m$ 条带权边的有向图，求所有点对间的最短路径长度，一条路径的长度定义为这条路径上所有边的权值和。\n\n注意：\n\n1. 边权**可能**为负，且图中**可能**存在重边和自环；\n\n2. 部分数据卡 $n$ 轮 SPFA 算法。\n\n", "inputFormat": "第 $1$ 行：$2$ 个整数 $n,m$，表示给定有向图的结点数量和有向边数量。\n\n接下来 $m$ 行：每行 $3$ 个整数 $u,v,w$，表示有一条权值为 $w$ 的有向边从编号为 $u$ 的结点连向编号为 $v$ 的结点。", "outputFormat": "若图中存在负环，输出仅一行 $-1$。\n\n若图中不存在负环：\n\n输出 $n$ 行：令 $dis_{i,j}$ 为从 $i$ 到 $j$ 的最短路，在第 $i$ 行输出 $\\sum\\limits_{j=1}^n j\\times dis_{i,j}$，注意这个结果可能超过 int 存储范围。\n\n如果不存在从 $i$ 到 $j$ 的路径，则 $dis_{i,j}=10^9$；如果 $i=j$，则 $dis_{i,j}=0$。", "hint": "【样例解释】\n\n左图为样例 $1$ 给出的有向图，最短路构成的答案矩阵为：\n\n```\n0 4 11 8 11 \n1000000000 0 7 4 7 \n1000000000 -5 0 -3 0 \n1000000000 -2 5 0 3 \n1000000000 -1 4 1 0 \n```\n\n右图为样例 $2$ 给出的有向图，红色标注的边构成了负环，注意给出的图不一定连通。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7lb35u4u.png)\n\n【数据范围】\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 3\\times 10^3,\\ \\ 1\\leq m\\leq 6\\times 10^3,\\ \\ 1\\leq u,v\\leq n,\\ \\ -3\\times 10^5\\leq w\\leq 3\\times 10^5$。\n\n对于 $20\\%$ 的数据，$1\\leq n\\leq 100$，不存在负环（可用于验证 Floyd 正确性）\n\n对于另外 $20\\%$ 的数据，$w\\ge 0$（可用于验证 Dijkstra 正确性）\n\nupd. 添加一组 Hack 数据：针对 SPFA 的 SLF 优化", "locale": "zh-CN"}}}
{"pid": "P5906", "type": "P", "difficulty": 6, "samples": [["8\n1 6 2 2 3 3 1 6\n5\n1 4\n2 5\n2 8\n5 6\n1 7", "1\n1\n6\n1\n6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["莫队", "O2优化", "模板题"], "title": "【模板】回滚莫队&不删除莫队", "background": "这是一道模板题。", "description": "给定一个序列，多次询问一段区间 $[l,r]$，求区间中**相同的数的最远间隔距离**。\n\n序列中两个元素的**间隔距离**指的是**两个元素下标差的绝对值**。", "inputFormat": "第一行一个整数 $n$，表示序列长度。\n\n第二行 $n$ 个整数，描述这个序列。\n\n第三行一个整数 $m$，表示询问个数。\n\n之后 $m$ 行，每行两个整数 $l,r$ 表示询问区间。", "outputFormat": "共 $m$ 行，每行一个整数表示答案。如果区间内不存在两个数相同，则输出 $0$。", "hint": "记 $a_i$ 表示序列元素。\n\n对于 $40\\%$ 的数据，满足 $1\\leq a_i \\leq 400$，$1\\leq n,m\\leq 60000$。\n\n对于 $100\\%$ 的数据，满足 $1\\leq n,m\\leq 2\\cdot 10^5$，$1\\leq a_i\\leq 2\\cdot 10^9$。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Rollback Mo's Algorithm & Mo's Algorithm Without Deletions", "background": "This is a template problem.", "description": "Given a sequence, you will be asked multiple queries on an interval $[l,r]$. For each query, find the **maximum distance between two equal numbers** within the interval.\n\nThe **distance** between two elements in the sequence means the **absolute difference of their indices**.", "inputFormat": "The first line contains an integer $n$, which is the length of the sequence.\n\nThe second line contains $n$ integers describing the sequence.\n\nThe third line contains an integer $m$, which is the number of queries.\n\nThen follow $m$ lines, each containing two integers $l, r$, representing the query interval.", "outputFormat": "Output $m$ lines. Each line contains one integer, the answer. If there are no two equal numbers in the interval, output $0$.", "hint": "Let $a_i$ denote the elements of the sequence.\n\nFor $40\\%$ of the testdata, $1\\leq a_i \\leq 400$, $1\\leq n,m\\leq 60000$.\n\nFor $100\\%$ of the testdata, $1\\leq n,m\\leq 2\\cdot 10^5$, $1\\leq a_i\\leq 2\\cdot 10^9$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】回滚莫队&不删除莫队", "background": "这是一道模板题。", "description": "给定一个序列，多次询问一段区间 $[l,r]$，求区间中**相同的数的最远间隔距离**。\n\n序列中两个元素的**间隔距离**指的是**两个元素下标差的绝对值**。", "inputFormat": "第一行一个整数 $n$，表示序列长度。\n\n第二行 $n$ 个整数，描述这个序列。\n\n第三行一个整数 $m$，表示询问个数。\n\n之后 $m$ 行，每行两个整数 $l,r$ 表示询问区间。", "outputFormat": "共 $m$ 行，每行一个整数表示答案。如果区间内不存在两个数相同，则输出 $0$。", "hint": "记 $a_i$ 表示序列元素。\n\n对于 $40\\%$ 的数据，满足 $1\\leq a_i \\leq 400$，$1\\leq n,m\\leq 60000$。\n\n对于 $100\\%$ 的数据，满足 $1\\leq n,m\\leq 2\\cdot 10^5$，$1\\leq a_i\\leq 2\\cdot 10^9$。\n\n", "locale": "zh-CN"}}}
{"pid": "P5907", "type": "P", "difficulty": 7, "samples": [["6 4 3", "1030980"], ["233333333 114514 1919810", "3191086"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [454656, 454656, 454656, 454656, 454656, 454656, 454656, 454656, 454656, 454656]}, "tags": ["数学", "O2优化"], "title": "数列求和加强版 / SPOJ MOON4", "background": "[原题链接](https://www.luogu.com.cn/problem/P4948)", "description": "给定 $n,a,k$，求：\n\n$$\\sum_{i=1}^n i^k a^i$$\n答案对 $998244353$ 取模。", "inputFormat": "输入一行三个正整数 $n,a,k$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【数据范围】    \n对于 $20\\%$ 的数据，$1\\le n,k \\le 10^5$。  \n对于 $100\\%$ 的数据，$1\\le k \\le 10^7$，$1\\le n,a \\le 998244352$。", "locale": "zh-CN", "translations": {"en": {"title": "Enhanced Sequence Sum / SPOJ MOON4", "background": "[Original link](https://www.luogu.com.cn/problem/P4948)", "description": "Given $n$, $a$, and $k$, compute:\n\n$$\\sum_{i=1}^n i^k a^i$$\n\nOutput the answer modulo $998244353$.", "inputFormat": "Input one line with three positive integers $n$, $a$, and $k$.", "outputFormat": "Output one line with one integer representing the answer.", "hint": "Constraints  \nFor $20\\%$ of the testdata, $1\\le n,k \\le 10^5$.  \nFor $100\\%$ of the testdata, $1\\le k \\le 10^7$, $1\\le n,a \\le 998244352$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数列求和加强版 / SPOJ MOON4", "background": "[原题链接](https://www.luogu.com.cn/problem/P4948)", "description": "给定 $n,a,k$，求：\n\n$$\\sum_{i=1}^n i^k a^i$$\n答案对 $998244353$ 取模。", "inputFormat": "输入一行三个正整数 $n,a,k$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【数据范围】    \n对于 $20\\%$ 的数据，$1\\le n,k \\le 10^5$。  \n对于 $100\\%$ 的数据，$1\\le k \\le 10^7$，$1\\le n,a \\le 998244352$。", "locale": "zh-CN"}}}
{"pid": "P5908", "type": "P", "difficulty": 2, "samples": [["5 1\n1 2\n1 3\n2 4\n3 5", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "广度优先搜索 BFS", "树的遍历"], "title": "猫猫和企鹅", "background": null, "description": "王国里有 $n$ 个居住区，它们之间有 $n-1$ 条道路相连，并且保证从每个居住区出发都可以到达任何一个居住区，并且每条道路的长度都为 $1$。\n\n除 $1$ 号居住区外，每个居住区住着一个小企鹅，有一天一只猫猫从 $1$ 号居住区出发，想要去拜访一些小企鹅。可是猫猫非常的懒，它只愿意去距离它不大于 $d$ 的小企鹅们。\n\n猫猫非常的懒，因此希望你告诉他，他可以拜访多少只小企鹅。", "inputFormat": "第一行两个整数 $n, d$，意义如题所述。\n\n第二行开始，共 $n - 1$ 行，每行两个整数 $u, v$，表示居民区 $u$ 和 $v$ 之间存在道路。", "outputFormat": "一行一个整数，表示猫猫可以拜访多少只小企鹅。", "hint": "对于 $100\\%$ 的数据，满足 $1 \\le n ,d \\le 10^5$，保证所有居民区从 $1$ 开始标号。", "locale": "zh-CN", "translations": {"en": {"title": "Cats and Penguins", "background": "", "description": "There are $n$ residential areas in the kingdom. They are connected by $n - 1$ roads, and it is guaranteed that from any residential area you can reach any other one. The length of each road is $1$.\n\nIn every residential area except area $1$, there lives a little penguin. One day, a cat starts from residential area $1$ and wants to visit some penguins. However, the cat is very lazy and is only willing to visit penguins whose distance from it is at most $d$.\n\nPlease tell the cat how many penguins it can visit.", "inputFormat": "The first line contains two integers $n, d$, with the meanings as described above.\n\nStarting from the second line, there are $n - 1$ lines. Each line contains two integers $u, v$, indicating that there is a road between residential areas $u$ and $v$.", "outputFormat": "Output one integer in a single line, indicating how many penguins the cat can visit.", "hint": "For $100\\%$ of the testdata, $1 \\le n, d \\le 10^5$. It is guaranteed that all residential areas are numbered starting from $1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "猫猫和企鹅", "background": null, "description": "王国里有 $n$ 个居住区，它们之间有 $n-1$ 条道路相连，并且保证从每个居住区出发都可以到达任何一个居住区，并且每条道路的长度都为 $1$。\n\n除 $1$ 号居住区外，每个居住区住着一个小企鹅，有一天一只猫猫从 $1$ 号居住区出发，想要去拜访一些小企鹅。可是猫猫非常的懒，它只愿意去距离它不大于 $d$ 的小企鹅们。\n\n猫猫非常的懒，因此希望你告诉他，他可以拜访多少只小企鹅。", "inputFormat": "第一行两个整数 $n, d$，意义如题所述。\n\n第二行开始，共 $n - 1$ 行，每行两个整数 $u, v$，表示居民区 $u$ 和 $v$ 之间存在道路。", "outputFormat": "一行一个整数，表示猫猫可以拜访多少只小企鹅。", "hint": "对于 $100\\%$ 的数据，满足 $1 \\le n ,d \\le 10^5$，保证所有居民区从 $1$ 开始标号。", "locale": "zh-CN"}}}
{"pid": "P5909", "type": "P", "difficulty": 5, "samples": [["4\n3 5\n5 1\n3 2\n4 6", "3\n8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "CTSC/CTS"], "title": "[CTSC2007] 挂缀pendant", "background": "", "description": "“珠缀花蕊，人间几多酸泪”……\n\n挂缀在很早就被人们作为一种装饰品，垂坠的风韵，华丽摇曳的摆动，展现出一种与众不同的优雅与高贵。而我们的主人公小 Q，正想买一条漂亮的挂缀放在寝室里作为装饰。\n\n挂坠的构成，是由若干粒缀珠相互连接而成。每一个缀珠由三部分组成：分别是珠子、珠子上方的连接环与珠子下方的挂钩。我们可以简单的认为从上往下数的第 $i$ 个缀珠是将它的连接环套在其上方（也就是第 $i-1$ 个）缀珠的挂钩\n之上（第 $1$ 个除外）。小 Q 想买一根足够长的挂缀，这样显得更有韵味。\n\n然而商店的老板告诉小 Q，挂缀是不可能做到任意长的，因为每一个珠子都受到重力作用，对其上方的挂钩有一定的拉力，而挂钩的承受能力是有限的。老板还告诉小 Q，他一共拥有 $N$ 个珠缀（假设每一个珠缀都很漂亮，小 Q 都很喜欢），每个珠缀都有其各自的重量与承受能力。**一个挂缀是稳定的，当且仅当对于其上的每一个珠缀，它下方所有珠缀的重量和（不包含自身）不超过其挂钩的承受能力。**\n\n小 Q 希望她的挂缀尽量长，你能帮她计算出最长可能的稳定挂缀么？当然，如果有多个可选方案，小 Q 希望总重量最小的。", "inputFormat": "第一行包含一个正整数 $N$，表示商店拥有的珠缀数目。\n\n接下来 $N$ 行，每行两个整数 $C_i$，$W_i$，分别表示第 $i$ 个珠缀的承受能力与重量。 ", "outputFormat": "共两行。\n\n第一行包含一个整数 $L$，表示可以找到的最长稳定挂缀长度。\n\n第二行包含一个整数 $W$，表示可以找到的长度为 $L$ 的稳定挂缀中的最小重量和。", "hint": "对于 $30\\%$ 的数据，$N\\le 10^4$；\n\n对于 $100\\%$ 的数据，$N\\le 2 \\times 10^5$，$W_i,C_i  \\le 2^{31}$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2007] Pendant", "background": "", "description": "“Beads decorate the flower core; how many sour tears in this world”……\n\nPendants have long been used as decorations. Their hanging charm and gorgeous swinging movement show a unique elegance and nobility. Our main character, Xiao Q, wants to buy a beautiful pendant to decorate the dormitory.\n\nA pendant is made by connecting several beads. Each bead has three parts: the bead itself, a connecting ring above it, and a hook below it. We can simply think that the $i$-th bead from top to bottom is made by putting its connecting ring onto the hook of the bead above it (that is, the $(i-1)$-th bead), except for the first one. Xiao Q wants to buy a pendant that is long enough, so it looks more charming.\n\nHowever, the shop owner tells Xiao Q that a pendant cannot be arbitrarily long, because each bead is affected by gravity and thus applies a certain pulling force to the hook above it, and the hook has limited capacity. The owner also tells Xiao Q that he has a total of $N$ beads (assume every bead is very beautiful and Xiao Q likes all of them), and each bead has its own weight and load capacity. **A pendant is stable if and only if, for every bead on it, the total weight of all beads below it (excluding itself) does not exceed the capacity of its hook.**\n\nXiao Q wants the pendant to be as long as possible. Please help compute the maximum possible length of a stable pendant. Of course, if there are multiple choices, Xiao Q wants the one with the minimum total weight.", "inputFormat": "The first line contains a positive integer $N$, representing the number of beads in the shop.\n\nThe next $N$ lines each contain two integers $C_i$, $W_i$, representing the capacity and weight of the $i$-th bead, respectively.", "outputFormat": "There are two lines in total.\n\nThe first line contains an integer $L$, representing the maximum length of a stable pendant that can be found.\n\nThe second line contains an integer $W$, representing the minimum total weight among all stable pendants of length $L$.", "hint": "For $30\\%$ of the testdata, $N \\le 10^4$.\n\nFor $100\\%$ of the testdata, $N \\le 2 \\times 10^5$, $W_i, C_i \\le 2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2007] 挂缀pendant", "background": "", "description": "“珠缀花蕊，人间几多酸泪”……\n\n挂缀在很早就被人们作为一种装饰品，垂坠的风韵，华丽摇曳的摆动，展现出一种与众不同的优雅与高贵。而我们的主人公小 Q，正想买一条漂亮的挂缀放在寝室里作为装饰。\n\n挂坠的构成，是由若干粒缀珠相互连接而成。每一个缀珠由三部分组成：分别是珠子、珠子上方的连接环与珠子下方的挂钩。我们可以简单的认为从上往下数的第 $i$ 个缀珠是将它的连接环套在其上方（也就是第 $i-1$ 个）缀珠的挂钩\n之上（第 $1$ 个除外）。小 Q 想买一根足够长的挂缀，这样显得更有韵味。\n\n然而商店的老板告诉小 Q，挂缀是不可能做到任意长的，因为每一个珠子都受到重力作用，对其上方的挂钩有一定的拉力，而挂钩的承受能力是有限的。老板还告诉小 Q，他一共拥有 $N$ 个珠缀（假设每一个珠缀都很漂亮，小 Q 都很喜欢），每个珠缀都有其各自的重量与承受能力。**一个挂缀是稳定的，当且仅当对于其上的每一个珠缀，它下方所有珠缀的重量和（不包含自身）不超过其挂钩的承受能力。**\n\n小 Q 希望她的挂缀尽量长，你能帮她计算出最长可能的稳定挂缀么？当然，如果有多个可选方案，小 Q 希望总重量最小的。", "inputFormat": "第一行包含一个正整数 $N$，表示商店拥有的珠缀数目。\n\n接下来 $N$ 行，每行两个整数 $C_i$，$W_i$，分别表示第 $i$ 个珠缀的承受能力与重量。 ", "outputFormat": "共两行。\n\n第一行包含一个整数 $L$，表示可以找到的最长稳定挂缀长度。\n\n第二行包含一个整数 $W$，表示可以找到的长度为 $L$ 的稳定挂缀中的最小重量和。", "hint": "对于 $30\\%$ 的数据，$N\\le 10^4$；\n\n对于 $100\\%$ 的数据，$N\\le 2 \\times 10^5$，$W_i,C_i  \\le 2^{31}$。", "locale": "zh-CN"}}}
{"pid": "P5910", "type": "P", "difficulty": 0, "samples": [["1\n7 3 4\n1 6 4 6\n7 0 3 3\n2 5 1 5\n", "0 1 0 1\n1 0 1 0\n0 1 0 1\n"], ["2\n7 3 4\n1 6 4 6\n7 0 3 3\n2 5 1 5\n", "0 1 0 1\n1 0 1 0\n0 1 0 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2007", "Special Judge", "CTSC/CTS"], "title": "[CTSC2007] 矩阵Matrix 【征集 SPJ】", "background": "", "description": "给定一个整数 $D$，$n$ 行 $m$ 列的实数矩阵 $A$，其第 $i$ 行第 $j$ 列的元素是 $a_{ij}$，且 $0 \\le a_{ij} \\le D$（$1 \\le i \\le n$，$1 \\le j \\le m$）。希望你能由此提供一个 $n$ 行 $m$ 列的 $01$ 矩阵 $B$，第 $i$ 行 第 $j$ 列的元素是 $b_{ij}$（$1 \\le i \\le n$，$1 \\le j \\le m$），$b_{ij}$ 非 $0$ 即 $1$。\n\n对于给定的 $A$ 矩阵和你提供的 $B$ 矩阵，可以求出\n\n$$p_1=\\max \\begin{cases}\\max\\limits_{ 1 \\le j \\le m} \\{ |\\sum_{i=1}^n (b_{ij}-\\frac{a_{ij}}{D})|\\}\\\\\\max\\limits_{1 \\le i \\le n} \\{ |\\sum_{j=1}^m (b_{ij}-\\frac{a_{ij}}{D})|\\}\\end{cases}$$\n\n$$p_2=\\max_{1 \\le i \\le n,1 \\le j \\le m} \\{|b_{i,j}+b_{i-1,j}+b_{i,j-1}+b_{i-1,j-1}-\\frac{a_{i,j}+a_{i-1,j}+a_{i,j-1}+a_{i-1,j-1}}{D}|\\}$$\n\n在不同的测试例子中，我们希望提供的 $B$ 矩阵能使 $p_1$ 或 $p_2$ 尽量小。", "inputFormat": "第一行有一个整数 $c$，有两种取值：$c=1$ 表示我们的最小化目标是 $p_1$，$c=2$ 则表示希望 $p_2$ 尽量小。\n\n第二行有3个整数 $D$，$n$，$m$，相邻的两个数字间用一个空格隔开，$D$ 的含义如上文所述，$n$ 和 $m$ 分别表示 $A$ 矩阵的行数和列数。\n\n以下有 $n$ 行，每行 $m$ 个实数，描述 $A$ 矩阵。其中第 $i$ 行第 $j$ 列的实数表示 $a_{ij}$，相邻的数字用一个空格隔开。", "outputFormat": "仅包含一个 $n$ 行 $m$ 列的 $01$ 矩阵 $B$，表示你求出的使 $p_c$ 尽量小的答案。其中第 $i$ 行第 $j$ 列的数字表示 $b_{ij}$。相邻的整数之间用一个空格隔开。", "hint": "对于 $40\\%$ 的数据，$c=1$；\n\n对于 $60\\%$ 的数据，$c=2$；\n\n对于 $100\\%$ 的数据，$2 \\le n ,m \\le 700$，$1 \\le D \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2007] Matrix Matrix [Seeking SPJ].", "background": "", "description": "Given an integer $D$ and a real matrix $A$ with $n$ rows and $m$ columns, the element in row $i$ and column $j$ is $a_{ij}$, and $0 \\le a_{ij} \\le D$ ($1 \\le i \\le n$, $1 \\le j \\le m$). You are asked to provide an $n \\times m$ $01$ matrix $B$, whose element in row $i$ and column $j$ is $b_{ij}$ ($1 \\le i \\le n$, $1 \\le j \\le m$), where $b_{ij}$ is either $0$ or $1$.\n\nFor the given matrix $A$ and your matrix $B$, we can compute:\n\n$$p_1=\\max \\begin{cases}\\max\\limits_{ 1 \\le j \\le m} \\{ |\\sum_{i=1}^n (b_{ij}-\\frac{a_{ij}}{D})|\\}\\\\\\max\\limits_{1 \\le i \\le n} \\{ |\\sum_{j=1}^m (b_{ij}-\\frac{a_{ij}}{D})|\\}\\end{cases}$$\n\n$$p_2=\\max_{1 \\le i \\le n,1 \\le j \\le m} \\{|b_{i,j}+b_{i-1,j}+b_{i,j-1}+b_{i-1,j-1}-\\frac{a_{i,j}+a_{i-1,j}+a_{i,j-1}+a_{i-1,j-1}}{D}|\\}$$\n\nFor different test cases, we hope that the matrix $B$ you provide can make $p_1$ or $p_2$ as small as possible.", "inputFormat": "The first line contains an integer $c$, which has two possible values: $c=1$ means our minimization target is $p_1$, and $c=2$ means we want $p_2$ to be as small as possible.\n\nThe second line contains three integers $D$, $n$, and $m$, separated by a single space. The meaning of $D$ is as described above, and $n$ and $m$ are the number of rows and columns of matrix $A$, respectively.\n\nThen follow $n$ lines, each containing $m$ real numbers describing matrix $A$. The real number in row $i$ and column $j$ is $a_{ij}$, and adjacent numbers are separated by a single space.", "outputFormat": "Output only an $n \\times m$ $01$ matrix $B$, representing the answer you found that makes $p_c$ as small as possible. The number in row $i$ and column $j$ is $b_{ij}$. Adjacent integers are separated by a single space.", "hint": "For $40\\%$ of the testdata, $c=1$.\n\nFor $60\\%$ of the testdata, $c=2$.\n\nFor $100\\%$ of the testdata, Constraints: $2 \\le n ,m \\le 700$, $1 \\le D \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2007] 矩阵Matrix 【征集 SPJ】", "background": "", "description": "给定一个整数 $D$，$n$ 行 $m$ 列的实数矩阵 $A$，其第 $i$ 行第 $j$ 列的元素是 $a_{ij}$，且 $0 \\le a_{ij} \\le D$（$1 \\le i \\le n$，$1 \\le j \\le m$）。希望你能由此提供一个 $n$ 行 $m$ 列的 $01$ 矩阵 $B$，第 $i$ 行 第 $j$ 列的元素是 $b_{ij}$（$1 \\le i \\le n$，$1 \\le j \\le m$），$b_{ij}$ 非 $0$ 即 $1$。\n\n对于给定的 $A$ 矩阵和你提供的 $B$ 矩阵，可以求出\n\n$$p_1=\\max \\begin{cases}\\max\\limits_{ 1 \\le j \\le m} \\{ |\\sum_{i=1}^n (b_{ij}-\\frac{a_{ij}}{D})|\\}\\\\\\max\\limits_{1 \\le i \\le n} \\{ |\\sum_{j=1}^m (b_{ij}-\\frac{a_{ij}}{D})|\\}\\end{cases}$$\n\n$$p_2=\\max_{1 \\le i \\le n,1 \\le j \\le m} \\{|b_{i,j}+b_{i-1,j}+b_{i,j-1}+b_{i-1,j-1}-\\frac{a_{i,j}+a_{i-1,j}+a_{i,j-1}+a_{i-1,j-1}}{D}|\\}$$\n\n在不同的测试例子中，我们希望提供的 $B$ 矩阵能使 $p_1$ 或 $p_2$ 尽量小。", "inputFormat": "第一行有一个整数 $c$，有两种取值：$c=1$ 表示我们的最小化目标是 $p_1$，$c=2$ 则表示希望 $p_2$ 尽量小。\n\n第二行有3个整数 $D$，$n$，$m$，相邻的两个数字间用一个空格隔开，$D$ 的含义如上文所述，$n$ 和 $m$ 分别表示 $A$ 矩阵的行数和列数。\n\n以下有 $n$ 行，每行 $m$ 个实数，描述 $A$ 矩阵。其中第 $i$ 行第 $j$ 列的实数表示 $a_{ij}$，相邻的数字用一个空格隔开。", "outputFormat": "仅包含一个 $n$ 行 $m$ 列的 $01$ 矩阵 $B$，表示你求出的使 $p_c$ 尽量小的答案。其中第 $i$ 行第 $j$ 列的数字表示 $b_{ij}$。相邻的整数之间用一个空格隔开。", "hint": "对于 $40\\%$ 的数据，$c=1$；\n\n对于 $60\\%$ 的数据，$c=2$；\n\n对于 $100\\%$ 的数据，$2 \\le n ,m \\le 700$，$1 \\le D \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5911", "type": "P", "difficulty": 4, "samples": [["100 3\n24 60\n10 40\n18 50", "42"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2004", "POI（波兰）", "深度优先搜索 DFS", "剪枝", "状压 DP"], "title": "[POI 2004] PRZ", "background": "一只队伍在爬山时碰到了雪崩，他们在逃跑时遇到了一座桥，他们要尽快的过桥。", "description": "桥已经很旧了，所以它不能承受太重的东西。任何时候队伍在桥上的人都不能超过一定的限制。所以这支队伍过桥时只能分批过，当一组全部过去时，下一组才能接着过。队伍里每个人过桥都需要特定的时间，当一批队员过桥时时间应该算走得最慢的那一个，每个人也有特定的重量，我们想知道如何分批过桥能使总时间最少。", "inputFormat": "第一行两个数：$W$ 表示桥能承受的最大重量和 $n$ 表示队员总数。\n\n接下来 $n$ 行：每行两个数：$t$ 表示该队员过桥所需时间和 $w$ 表示该队员的重量。", "outputFormat": "输出一个数表示最少的过桥时间。", "hint": "对于 $100\\%$ 的数据，$100\\le W \\le400$，$1\\le n\\le 16$，$1\\le t\\le50$，$10\\le w\\le100$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2004] PRZ", "background": "A team encountered an avalanche while climbing. While escaping, they came across a bridge and need to cross it as quickly as possible.", "description": "The bridge is very old, so it cannot hold things that are too heavy. At any moment, the total weight of the people on the bridge cannot exceed a fixed limit. Therefore, the team can only cross the bridge in several batches. Only after one batch has completely crossed can the next batch start crossing.\n\nEach person needs a specific amount of time to cross the bridge. For one batch, the time taken should be counted as the slowest person's time in that batch. Each person also has a specific weight. You need to determine how to split the team into batches so that the total time is minimized.", "inputFormat": "The first line contains two integers: $W$ (the maximum weight the bridge can bear) and $n$ (the total number of team members).\n\nThe next $n$ lines each contain two integers: $t$ (the time needed for this member to cross) and $w$ (this member's weight).", "outputFormat": "Output one integer, the minimum total time needed to cross the bridge.", "hint": "For $100\\%$ of the testdata, $100 \\le W \\le 400$, $1 \\le n \\le 16$, $1 \\le t \\le 50$, $10 \\le w \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2004] PRZ", "background": "一只队伍在爬山时碰到了雪崩，他们在逃跑时遇到了一座桥，他们要尽快的过桥。", "description": "桥已经很旧了，所以它不能承受太重的东西。任何时候队伍在桥上的人都不能超过一定的限制。所以这支队伍过桥时只能分批过，当一组全部过去时，下一组才能接着过。队伍里每个人过桥都需要特定的时间，当一批队员过桥时时间应该算走得最慢的那一个，每个人也有特定的重量，我们想知道如何分批过桥能使总时间最少。", "inputFormat": "第一行两个数：$W$ 表示桥能承受的最大重量和 $n$ 表示队员总数。\n\n接下来 $n$ 行：每行两个数：$t$ 表示该队员过桥所需时间和 $w$ 表示该队员的重量。", "outputFormat": "输出一个数表示最少的过桥时间。", "hint": "对于 $100\\%$ 的数据，$100\\le W \\le400$，$1\\le n\\le 16$，$1\\le t\\le50$，$10\\le w\\le100$。", "locale": "zh-CN"}}}
{"pid": "P5912", "type": "P", "difficulty": 7, "samples": [["5\n1 2\n2 3\n4 3\n5 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2004", "POI（波兰）"], "title": "[POI 2004] JAS", "background": "在 Byteotia 有一个洞穴。", "description": " 它包含 $n$ 个洞室和一些隧道连接他们。\n\n每个洞室之间只有一条唯一的路径连接他们。Hansel 在其中一个洞室藏了宝藏，但是它不会说出它在哪。Gretel 知道，当她询问一个洞室是否有宝藏时，如果她猜对了 Hansel 会告诉她，如果猜错了他会告诉她哪个方向会有宝藏。 给出洞穴的信息，那么无论 Hansel 把宝藏藏在了哪，求出最少要询问多少次才能找到宝藏。", "inputFormat": "输入一个数 $n$，表示洞室总数。\n\n接下来 $n-1$ 行描述 $n-1$ 条边。", "outputFormat": "输出一个数表示最少询问次数。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le50000$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2004] JAS", "background": "There is a cave in Byteotia.", "description": "It contains $n$ chambers and some tunnels connecting them.\n\nBetween any two chambers, there is exactly one unique path connecting them. Hansel hid a treasure in one of the chambers, but he will not say where it is. Gretel knows that when she asks whether a certain chamber contains the treasure, if she guesses correctly Hansel will tell her so; if she guesses wrong, he will tell her in which direction the treasure lies. Given the information about the cave, no matter where Hansel hides the treasure, find the minimum number of questions needed to guarantee finding the treasure.", "inputFormat": "The input contains an integer $n$, representing the total number of chambers.\n\nThe next $n-1$ lines describe $n-1$ edges.", "outputFormat": "Output one integer representing the minimum number of questions.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 50000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2004] JAS", "background": "在 Byteotia 有一个洞穴。", "description": " 它包含 $n$ 个洞室和一些隧道连接他们。\n\n每个洞室之间只有一条唯一的路径连接他们。Hansel 在其中一个洞室藏了宝藏，但是它不会说出它在哪。Gretel 知道，当她询问一个洞室是否有宝藏时，如果她猜对了 Hansel 会告诉她，如果猜错了他会告诉她哪个方向会有宝藏。 给出洞穴的信息，那么无论 Hansel 把宝藏藏在了哪，求出最少要询问多少次才能找到宝藏。", "inputFormat": "输入一个数 $n$，表示洞室总数。\n\n接下来 $n-1$ 行描述 $n-1$ 条边。", "outputFormat": "输出一个数表示最少询问次数。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le50000$。", "locale": "zh-CN"}}}
{"pid": "P5913", "type": "P", "difficulty": 6, "samples": [["3\n3 2\n1 2\n2 3\n4 3\n1 2\n2 3\n3 4\n3 3\n1 2\n2 3\n3 1", "TAK\nNIE\nTAK\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2004", "POI（波兰）"], "title": "[POI 2004] KAG", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/8x4n4ya8.png)", "inputFormat": "第一行一个整数 $k$ 表示 $k$ 组数据。\n\n接下来描述每个数据开头两个数 $n$ 和 $m$，接下来 $m$ 行每行两个数表示一条边。", "outputFormat": "输出共 $k$ 行，每行输出一个判定，如果该图为 c-algae 输出 `TAK`，否则输出 `NIE`。", "hint": "对于 $100\\%$ 的数据，$1\\le k\\le10$，$1\\le n\\le10^4$，$0\\le m\\le10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2004] KAG", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/8x4n4ya8.png)", "inputFormat": "The first line contains an integer $k$, indicating there are $k$ test cases.\n\nFor each test case, it starts with two integers $n$ and $m$. Then follow $m$ lines, each containing two integers describing an edge.", "outputFormat": "Output a total of $k$ lines. For each line, output one decision: if the graph is c-algae, output `TAK`; otherwise, output `NIE`.", "hint": "For $100\\%$ of the testdata, $1\\le k\\le10$, $1\\le n\\le10^4$, $0\\le m\\le10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2004] KAG", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/8x4n4ya8.png)", "inputFormat": "第一行一个整数 $k$ 表示 $k$ 组数据。\n\n接下来描述每个数据开头两个数 $n$ 和 $m$，接下来 $m$ 行每行两个数表示一条边。", "outputFormat": "输出共 $k$ 行，每行输出一个判定，如果该图为 c-algae 输出 `TAK`，否则输出 `NIE`。", "hint": "对于 $100\\%$ 的数据，$1\\le k\\le10$，$1\\le n\\le10^4$，$0\\le m\\le10^5$。", "locale": "zh-CN"}}}
{"pid": "P5914", "type": "P", "difficulty": 4, "samples": [["4\n6\n7\n10\n15", "42"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2004", "POI（波兰）"], "title": "[POI 2004] MOS", "background": "一个夜晚一些旅行者想要过桥。", "description": "他们只有一个火把。\n- 火把的亮光最多允许两个旅行者同时过桥。\n- 没有火把或者多于 $2$ 个人则不能过桥。\n\n每个旅行者过桥都需要特定的时间，两个旅行者同时过桥时时间应该算较慢的那个。现在我们想知道所有旅行者最少要花费多少时间才能全部过桥?", "inputFormat": "第一行一个数 $n$ 表示旅行者的总数。\n\n接下来 $n$ 行表示所有旅行者的过桥时间，时间从小到大排列。", "outputFormat": "输出一个数表示最少过桥时间。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le10^5$，过桥时间均不超过 $10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2004] MOS", "background": "One night, some travelers want to cross a bridge.", "description": "They only have one torch.\n- The light from the torch allows at most two travelers to cross the bridge at the same time.\n- Without the torch, or with more than $2$ people, they cannot cross.\n\nEach traveler needs a specific amount of time to cross the bridge. When two travelers cross together, the time is counted as the slower one. Now we want to know the minimum total time needed for all travelers to cross the bridge.", "inputFormat": "The first line contains an integer $n$, the total number of travelers.\n\nThe next $n$ lines give the crossing times of all travelers, sorted from small to large.", "outputFormat": "Output one number, the minimum total crossing time.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 10^5$, and each crossing time does not exceed $10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2004] MOS", "background": "一个夜晚一些旅行者想要过桥。", "description": "他们只有一个火把。\n- 火把的亮光最多允许两个旅行者同时过桥。\n- 没有火把或者多于 $2$ 个人则不能过桥。\n\n每个旅行者过桥都需要特定的时间，两个旅行者同时过桥时时间应该算较慢的那个。现在我们想知道所有旅行者最少要花费多少时间才能全部过桥?", "inputFormat": "第一行一个数 $n$ 表示旅行者的总数。\n\n接下来 $n$ 行表示所有旅行者的过桥时间，时间从小到大排列。", "outputFormat": "输出一个数表示最少过桥时间。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le10^5$，过桥时间均不超过 $10^9$。", "locale": "zh-CN"}}}
{"pid": "P5915", "type": "P", "difficulty": 7, "samples": [["3 2", "2"], ["7 7", "818503"], ["114514 233", "782307368"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "递推", "矩阵加速", "快速傅里叶变换 FFT"], "title": "冬至", "background": ">春生秋死，不知冬至。", "description": "给你 $1 \\sim k$ 的整数，你可以选其中的数，组成长度为 $n$ 的串（可重复使用），且不能有子串是 $1\\sim k$ 的排列。\n  \n问方案总数模 $998244353$。", "inputFormat": "一行两个正整数 $n,k$。", "outputFormat": "一行一个整数，表示方案总数模 $998244353$ 的值。", "hint": "【样例 1 解释】  \n可以组成的合法排列有：$1,1,1$ 和 $2,2,2$  \n其余均不合法，都含有 $1 \\sim 2$ 的排列，因此答案为 $2$。\n\n【样例 2 解释】  \n总共有 $7^7$ 种情况，其中有 $7!$ 个不合法（即 $1 \\sim 7$ 的排列情况数），答案为 $7^7-7!$，即 $818503$。\n\n【数据范围】   \n对于 $100\\%$ 的数据，$1\\le k \\le 10^4$，$1\\le n \\le 10^9$。\n  \nBy：毕克", "locale": "zh-CN", "translations": {"en": {"title": "Winter Solstice", "background": "> Spring is born and autumn dies, not knowing the Winter Solstice.", "description": "You are given the integers $1 \\sim k$. You may choose numbers from them to form a string of length $n$ (repetition is allowed), and no substring is allowed to be a permutation of $1 \\sim k$.\n\nFind the total number of valid strings modulo $998244353$.", "inputFormat": "A single line with two positive integers $n, k$.", "outputFormat": "A single line with one integer, the total number of valid strings modulo $998244353$.", "hint": "[Sample 1 Explanation]  \nThe valid strings that can be formed are: $1,1,1$ and $2,2,2$.  \nAll others are invalid, because they contain a permutation of $1 \\sim 2$. Therefore, the answer is $2$.\n\n[Sample 2 Explanation]  \nThere are $7^7$ strings in total. Among them, $7!$ are invalid (i.e. the number of permutations of $1 \\sim 7$).  \nSo the answer is $7^7-7!$, which is $818503$.\n\n[Constraints]  \nFor all testdata, $1\\le k \\le 10^4$, $1\\le n \\le 10^9$.\n\nBy: Bike (毕克).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "冬至", "background": ">春生秋死，不知冬至。", "description": "给你 $1 \\sim k$ 的整数，你可以选其中的数，组成长度为 $n$ 的串（可重复使用），且不能有子串是 $1\\sim k$ 的排列。\n  \n问方案总数模 $998244353$。", "inputFormat": "一行两个正整数 $n,k$。", "outputFormat": "一行一个整数，表示方案总数模 $998244353$ 的值。", "hint": "【样例 1 解释】  \n可以组成的合法排列有：$1,1,1$ 和 $2,2,2$  \n其余均不合法，都含有 $1 \\sim 2$ 的排列，因此答案为 $2$。\n\n【样例 2 解释】  \n总共有 $7^7$ 种情况，其中有 $7!$ 个不合法（即 $1 \\sim 7$ 的排列情况数），答案为 $7^7-7!$，即 $818503$。\n\n【数据范围】   \n对于 $100\\%$ 的数据，$1\\le k \\le 10^4$，$1\\le n \\le 10^9$。\n  \nBy：毕克", "locale": "zh-CN"}}}
{"pid": "P5916", "type": "P", "difficulty": 3, "samples": [["2\n2\n0 0\n0 0 1\n3\n1 2\n3 4 5", "Case 1: 0.00000\nCase 2: 58.42574"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2014", "各省省选", "福建"], "title": "[FJOI2014] 病毒防护带", "background": "众所周知，在国王胖哥的带领下， K 国国泰民安，空前繁荣，但今天 K 国却遇到了空前的危机。", "description": "在 K 国境内同时发现了 $n$ 个未知的病毒，每个病毒会从它被发现的位置开始感染 K 国的土地， K 国可以看做是一个无限大的二维平面，而病毒的感染形状可以看做是一个不断扩大的圆形区域，即在 $t$ 时间这个病毒会感染半径为 $t$ 的圆形土地，这个圆形的圆心为发现这个病毒的位置。\n\n但是万幸的是， K 国有独特的病毒防护带可以杀死这些病毒，所以 K 国国王胖哥在刚发现病毒之时就开始着手进行杀毒工作，所谓的病毒防护带可以看成是一条直线，可以选定建立在 K 国的任意位置，即可以放置在 K 国所表示的平面上的任意位置，一旦病毒在扩散的过程中接触到这个防护带，病毒就会死亡，它感染的土地面积就固定为这个病毒死亡时所占的土地面积。注意由于防护带的建立十分昂贵， K 国最多只能建立一条病毒防护带。\n\n现在胖哥想知道要如何设立这个病毒防护带，才能使每个病毒感染的平均面积最小，即被感染的总土地面积除以病毒数 $n$，每个病毒可以独立看待，即任意一个病毒的死亡不会影响到其他的病毒。注意如果同一个区域被多个病毒感染，那么在计算被感染的土地面积时需要计算多次，即若有一个病毒在位置 $(0,0)$ 被发现，一个病毒在位置 $(1,1)$ 被发现，它们都在 $t=1$ 时接触到防护带死亡，那么此时 K 国被感染的面积为 $p_i\\times2$，病毒感染的平均面积为 $p_i$。\n\n由于 K 国有举世无双的安全监测系统和卫生防护系统，可以认为在病毒防护带建立完毕之后病毒才开始进行扩散。若病毒出现在病毒防护带上，他感染的土地面积可以看做 $0$。\n\n请编程输出在最优决策下，这些病毒感染的平均面积。", "inputFormat": "第 $1$ 行中给出正整数 $Q$，表示该组数据中有多少组测试样例。\n\n每组样例首先输入一个整数 $n$，表示该组样例中病毒的个数。\n\n之后一行输入两个正整数 $x,y$，表示第一个病毒的坐标。\n\n之后一行输入三个正整数 $a,b,c$，如果第 $i$ 个病毒的坐标为 $(x, y)$，那么第 $i+1$ 个病毒的坐标为 $(x',y')$，其中$x'=(a\\times x^2+b\\times x+c)\\bmod107$，$y'=(a\\times y^2+b\\times y+c)\\bmod107$，其中 $\\bmod$ 是取模运算符号。", "outputFormat": "首先输出样例编号，之后输出在最优决策下，这些病毒会感染的K国的土地面积，答案保留 $5$ 位小数，详见输出示例，请严格按照输出实例中的格式输出。", "hint": "对于 $100\\%$ 的数据，满足 $0\\le Q\\times n \\le 10^7$，$0\\le x,y,a,b,c\\le100$，$Q\\le n$，$0<n\\le1000000$", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2014] Virus Defense Belt", "background": "As everyone knows, under the leadership of King Pang Ge, Country K is peaceful and prosperous like never before. But today, Country K has encountered an unprecedented crisis.", "description": "Within Country K, $n$ unknown viruses have been discovered at the same time. Each virus starts infecting the land of Country K from the position where it is discovered. Country K can be viewed as an infinite 2D plane, and the infected region of a virus can be viewed as a continuously expanding circular area. That is, at time $t$, the virus infects a circle of radius $t$, with the center at the discovery position of that virus.\n\nFortunately, Country K has a unique virus defense belt that can kill these viruses. So King Pang Ge began disinfection work immediately after discovering the viruses. The so-called virus defense belt can be considered as a straight line, which can be placed at any position on the plane representing Country K. Once a virus touches this defense belt during its spread, it dies, and its infected land area becomes fixed as the area it occupied at the moment of death. Note that building the defense belt is very expensive, so Country K can build at most one virus defense belt.\n\nNow Pang Ge wants to know how to place this virus defense belt so that the average infected area of each virus is minimized, i.e. the total infected land area divided by the number of viruses $n$. Each virus can be considered independently, meaning the death of any one virus does not affect the others. Note that if the same region is infected by multiple viruses, it must be counted multiple times when computing the infected land area. For example, if one virus is discovered at $(0,0)$ and another at $(1,1)$, and both touch the defense belt and die at $t=1$, then the infected area of Country K at this time is $p_i\\times2$, and the average infected area per virus is $p_i$.\n\nSince Country K has a world-class security monitoring system and public health protection system, you may assume that viruses start spreading only after the defense belt has been built. If a virus appears on the defense belt, its infected land area can be considered as $0$.\n\nPlease write a program to output, under the optimal decision, the average infected area of these viruses.", "inputFormat": "The 1st line contains a positive integer $Q$, indicating how many test cases are in this dataset.\n\nFor each test case, first input an integer $n$, indicating the number of viruses in this test case.\n\nThen one line contains two positive integers $x,y$, indicating the coordinates of the first virus.\n\nThen one line contains three positive integers $a,b,c$. If the coordinates of the $i$-th virus are $(x, y)$, then the coordinates of the $(i+1)$-th virus are $(x',y')$, where $x'=(a\\times x^2+b\\times x+c)\\bmod107$, $y'=(a\\times y^2+b\\times y+c)\\bmod107$. Here $\\bmod$ is the modulo operator.", "outputFormat": "First output the sample index, then output, under the optimal decision, the land area of Country K that will be infected by these viruses. Print the answer with $5$ digits after the decimal point. See the output example for details. Please strictly follow the format in the output example.", "hint": "For $100\\%$ of the data, it holds that $0\\le Q\\times n \\le 10^7$, $0\\le x,y,a,b,c\\le100$, $Q\\le n$, $0<n\\le1000000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2014] 病毒防护带", "background": "众所周知，在国王胖哥的带领下， K 国国泰民安，空前繁荣，但今天 K 国却遇到了空前的危机。", "description": "在 K 国境内同时发现了 $n$ 个未知的病毒，每个病毒会从它被发现的位置开始感染 K 国的土地， K 国可以看做是一个无限大的二维平面，而病毒的感染形状可以看做是一个不断扩大的圆形区域，即在 $t$ 时间这个病毒会感染半径为 $t$ 的圆形土地，这个圆形的圆心为发现这个病毒的位置。\n\n但是万幸的是， K 国有独特的病毒防护带可以杀死这些病毒，所以 K 国国王胖哥在刚发现病毒之时就开始着手进行杀毒工作，所谓的病毒防护带可以看成是一条直线，可以选定建立在 K 国的任意位置，即可以放置在 K 国所表示的平面上的任意位置，一旦病毒在扩散的过程中接触到这个防护带，病毒就会死亡，它感染的土地面积就固定为这个病毒死亡时所占的土地面积。注意由于防护带的建立十分昂贵， K 国最多只能建立一条病毒防护带。\n\n现在胖哥想知道要如何设立这个病毒防护带，才能使每个病毒感染的平均面积最小，即被感染的总土地面积除以病毒数 $n$，每个病毒可以独立看待，即任意一个病毒的死亡不会影响到其他的病毒。注意如果同一个区域被多个病毒感染，那么在计算被感染的土地面积时需要计算多次，即若有一个病毒在位置 $(0,0)$ 被发现，一个病毒在位置 $(1,1)$ 被发现，它们都在 $t=1$ 时接触到防护带死亡，那么此时 K 国被感染的面积为 $p_i\\times2$，病毒感染的平均面积为 $p_i$。\n\n由于 K 国有举世无双的安全监测系统和卫生防护系统，可以认为在病毒防护带建立完毕之后病毒才开始进行扩散。若病毒出现在病毒防护带上，他感染的土地面积可以看做 $0$。\n\n请编程输出在最优决策下，这些病毒感染的平均面积。", "inputFormat": "第 $1$ 行中给出正整数 $Q$，表示该组数据中有多少组测试样例。\n\n每组样例首先输入一个整数 $n$，表示该组样例中病毒的个数。\n\n之后一行输入两个正整数 $x,y$，表示第一个病毒的坐标。\n\n之后一行输入三个正整数 $a,b,c$，如果第 $i$ 个病毒的坐标为 $(x, y)$，那么第 $i+1$ 个病毒的坐标为 $(x',y')$，其中$x'=(a\\times x^2+b\\times x+c)\\bmod107$，$y'=(a\\times y^2+b\\times y+c)\\bmod107$，其中 $\\bmod$ 是取模运算符号。", "outputFormat": "首先输出样例编号，之后输出在最优决策下，这些病毒会感染的K国的土地面积，答案保留 $5$ 位小数，详见输出示例，请严格按照输出实例中的格式输出。", "hint": "对于 $100\\%$ 的数据，满足 $0\\le Q\\times n \\le 10^7$，$0\\le x,y,a,b,c\\le100$，$Q\\le n$，$0<n\\le1000000$", "locale": "zh-CN"}}}
{"pid": "P5917", "type": "P", "difficulty": 4, "samples": [["1 2\n2 3\n3 4\n4 5", "40\n4 10\n5 8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2001", "IOI"], "title": "[IOI 1995] 铺放矩形块", "background": "", "description": "给定 $ 4 $ 个矩形块，找出一个最小的封闭矩形将这 $ 4 $ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。\n\n所有 $ 4 $ 个矩形块的边都与封闭矩形的边相平行。\n\n可能存在满足条件且有着同样面积的各种不同的封闭矩形， 你应该输出所有这些封闭矩形的边长。\n", "inputFormat": "输入文件共有 $ 4 $ 行。每一行用两个正整数来表示一个给定的矩形块的两个边长。矩形块的每条边的边长范围最小是 $ 1 $，最大是 $ 50 $。", "outputFormat": "输出文件的总行数为解的总数加 $ 1 $。第一行是一个整数， 代表封闭矩形的最小面积（子任务 $ A $）。接下来的每一行都表示一个解，由数 $ P $ 和数$ Q $ 来表示，并且 $ P \\leq Q $（子任务 $ B $）。这些行必须根据 $ P $ 的大小按升序排列，$ P $ 小的行在前，大的在后。且所有行都应是不同的。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1995] Placing Rectangular Blocks", "background": "", "description": "Given $4$ rectangles, find a smallest enclosing rectangle that can contain all $4$ rectangles without overlapping. “Smallest” means the enclosing rectangle has the minimum area.\n\nAll sides of the $4$ rectangles are parallel to the sides of the enclosing rectangle.\n\nThere may be multiple different enclosing rectangles with the same minimum area. You should output the side lengths of all such enclosing rectangles.", "inputFormat": "The input has $4$ lines. Each line contains two positive integers representing the two side lengths of one given rectangle. The side length of each rectangle is at least $1$ and at most $50$.", "outputFormat": "The total number of output lines is the number of solutions plus $1$. The first line is an integer representing the minimum area of the enclosing rectangle (Subtask $A$). Each following line represents one solution, given by two numbers $P$ and $Q$, with $P \\leq Q$ (Subtask $B$). These lines must be sorted in increasing order of $P$ (smaller $P$ first). All lines must be distinct.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1995] 铺放矩形块", "background": "", "description": "给定 $ 4 $ 个矩形块，找出一个最小的封闭矩形将这 $ 4 $ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。\n\n所有 $ 4 $ 个矩形块的边都与封闭矩形的边相平行。\n\n可能存在满足条件且有着同样面积的各种不同的封闭矩形， 你应该输出所有这些封闭矩形的边长。\n", "inputFormat": "输入文件共有 $ 4 $ 行。每一行用两个正整数来表示一个给定的矩形块的两个边长。矩形块的每条边的边长范围最小是 $ 1 $，最大是 $ 50 $。", "outputFormat": "输出文件的总行数为解的总数加 $ 1 $。第一行是一个整数， 代表封闭矩形的最小面积（子任务 $ A $）。接下来的每一行都表示一个解，由数 $ P $ 和数$ Q $ 来表示，并且 $ P \\leq Q $（子任务 $ B $）。这些行必须根据 $ P $ 的大小按升序排列，$ P $ 小的行在前，大的在后。且所有行都应是不同的。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5918", "type": "P", "difficulty": 6, "samples": [["4", "5\n1 4 8 6 9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "各省省选", "福建", "Special Judge"], "title": "[FJOI2015] 金币换位问题", "background": "", "description": "给定一个 $n$，最开始序列长这样：\n\n$$\n\\underbrace{\\tt 111\\cdots11}_{n \\text{ 个 } 1}\\underbrace{\\tt 000\\cdots00}_{n \\text{ 个 } 0}\\verb!__!\n$$\n\n现在要求用最少的交换步数，使得最终的序列为\n\n$$\n\\underbrace{\\tt 101010\\cdots 1010}_{2\\times n \\text{ 个 } 01 \\text{ 交替排列}}\\verb!__!\n$$\n\n所谓交换是指**将相邻两个非空格的数一起挪到两个空格上**。\n\n例如，下面是 $n=4$ 时的一组合法解：\n\n- 初始状态：$\\verb!11110000__!$。\n- 第 $1$ 步：$\\verb!__11000011!$。\n- 第 $2$ 步：$\\verb!101__00011!$。\n- 第 $3$ 步：$\\verb!1010100__1!$。\n- 第 $4$ 步：$\\verb!10101__001!$。\n- 第 $5$ 步：$\\verb!10101010__!$。\n\n可以证明，最少的操作次数就是 $5$ 步。", "inputFormat": "输入共一行一个整数 $n$。\n", "outputFormat": "第一行输出最少移动步数。\n\n接下来一行为移动方案，只要输出被移动的两个非空格格子左边那个的编号。详见样例。", "hint": "对于 $100\\%$ 的数据，$2<n\\le 2\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2015] Coin Swapping Problem", "background": "", "description": "Given an integer $n$, the initial sequence looks like this:\n\n$$\n\\underbrace{\\tt 111\\cdots11}_{n \\text{ ones}}\\underbrace{\\tt 000\\cdots00}_{n \\text{ zeros}}\\verb!__!\n$$\n\nNow you need to use the minimum number of swaps to make the final sequence become:\n\n$$\n\\underbrace{\\tt 101010\\cdots 1010}_{2\\times n \\text{ digits with alternating } 0 \\text{ and } 1}\\verb!__!\n$$\n\nA swap means **moving two adjacent non-blank digits together onto the two blanks**.\n\nFor example, the following is a valid solution when $n=4$:\n\n- Initial state: $\\verb!11110000__!$.\n- Step $1$: $\\verb!__11000011!$.\n- Step $2$: $\\verb!101__00011!$.\n- Step $3$: $\\verb!1010100__1!$.\n- Step $4$: $\\verb!10101__001!$.\n- Step $5$: $\\verb!10101010__!$.\n\nIt can be proven that the minimum number of operations is $5$.", "inputFormat": "The input contains one line with an integer $n$.", "outputFormat": "Output the minimum number of moves in the first line.\n\nIn the next line, output a move plan. You only need to output the index of the left one of the two moved non-blank cells. See the sample for details.", "hint": "For $100\\%$ of the testdata, $2<n\\le 2\\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2015] 金币换位问题", "background": "", "description": "给定一个 $n$，最开始序列长这样：\n\n$$\n\\underbrace{\\tt 111\\cdots11}_{n \\text{ 个 } 1}\\underbrace{\\tt 000\\cdots00}_{n \\text{ 个 } 0}\\verb!__!\n$$\n\n现在要求用最少的交换步数，使得最终的序列为\n\n$$\n\\underbrace{\\tt 101010\\cdots 1010}_{2\\times n \\text{ 个 } 01 \\text{ 交替排列}}\\verb!__!\n$$\n\n所谓交换是指**将相邻两个非空格的数一起挪到两个空格上**。\n\n例如，下面是 $n=4$ 时的一组合法解：\n\n- 初始状态：$\\verb!11110000__!$。\n- 第 $1$ 步：$\\verb!__11000011!$。\n- 第 $2$ 步：$\\verb!101__00011!$。\n- 第 $3$ 步：$\\verb!1010100__1!$。\n- 第 $4$ 步：$\\verb!10101__001!$。\n- 第 $5$ 步：$\\verb!10101010__!$。\n\n可以证明，最少的操作次数就是 $5$ 步。", "inputFormat": "输入共一行一个整数 $n$。\n", "outputFormat": "第一行输出最少移动步数。\n\n接下来一行为移动方案，只要输出被移动的两个非空格格子左边那个的编号。详见样例。", "hint": "对于 $100\\%$ 的数据，$2<n\\le 2\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5919", "type": "P", "difficulty": 6, "samples": [["2\n5\n14", "2 1 4 5 3\n2 3 1 5 6 7 4 9 10 11 12 13 14 8"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2004", "POI（波兰）", "数论", "背包 DP"], "title": "[POI 2004] MAK", "background": null, "description": "置换就是 $n$ 个元素 $1$ 对 $1$ 的函数映射$p:\\{1,2,\\ldots,n\\}\\to\\{1,2,\\ldots,n\\}$，一个置换 $p$ 的 `order` 等于最小的 $k\\ge1$，且对所有的 $i=1,2,...,n$ 都满足：\n$$p(p(...(p(i))...))=i$$\n（共 $k$ 次）\n\n\n举个例子，对于 $3$ 个元素的 `order` $p(1)=3,p(2)=2,p(3)=1$ 为 $ 2$，因为$p(p(1))=1,p(p(2))=2,p(p(3))=3$。\n\n对于给定的 $n$ 我们想要一个长度为 $n$ 的置换的 `order` 尽量大。比如说长度为 $5$ 的置换的 order 最大为 $6$。\n\n一个例子就是 $p(1)=4,p(2)=5,p(3)=2,p(4)=1,p(5)=3$。\n\n对于所有使得 `order` 最大的置换中，我们要找到字典序最小的那个。\n\n更精确来说，我们说置换 $p$ 小于置换 $r$，即存在一个 $i$，使得对于所有 $j<i$ 都满足 $p(j)=r(j)$ 且 $p(i)<r(i)$。那么对于长度为 $5$ 的置换中最小的那个为 $p(1)=2,p(2)=1,p(3)=4,p(4)=5,p(5)=3$。", "inputFormat": "第一行一个数 $d$ 表示一共 $d$ 组数据。\n\n接下来 $d$ 行表示长度为 $n_1,n_2,...,n_d$。", "outputFormat": "输出 $d$ 行每行一个最优置换。", "hint": "对于 $100\\%$ 的数据，$1\\le d\\le10$，$1\\le n_i\\le10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2004] MAK", "background": "", "description": "A permutation is a one-to-one function mapping of $n$ elements $p:\\{1,2,\\ldots,n\\}\\to\\{1,2,\\ldots,n\\}$. The `order` of a permutation $p$ is the smallest $k\\ge 1$ such that for all $i=1,2,\\ldots,n$, the following holds:\n$$p(p(\\ldots(p(i))\\ldots))=i$$\n($k$ times in total).\n\nFor example, for $3$ elements, the permutation with `order` $2$ is $p(1)=3,p(2)=2,p(3)=1$, because $p(p(1))=1,p(p(2))=2,p(p(3))=3$.\n\nFor a given $n$, we want a permutation of length $n$ whose `order` is as large as possible. For example, among permutations of length $5$, the maximum possible order is $6$.\n\nOne example is $p(1)=4,p(2)=5,p(3)=2,p(4)=1,p(5)=3$.\n\nAmong all permutations that achieve the maximum `order`, we need to find the lexicographically smallest one.\n\nMore precisely, we say permutation $p$ is smaller than permutation $r$ if there exists an $i$ such that for all $j<i$ we have $p(j)=r(j)$ and $p(i)<r(i)$. Then, among permutations of length $5$, the smallest one is $p(1)=2,p(2)=1,p(3)=4,p(4)=5,p(5)=3$.", "inputFormat": "The first line contains an integer $d$, meaning there are $d$ test cases.\n\nThe next $d$ lines give the lengths $n_1,n_2,\\ldots,n_d$.", "outputFormat": "Output $d$ lines, each containing one optimal permutation.", "hint": "For $100\\%$ of the testdata, $1\\le d\\le 10$ and $1\\le n_i\\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2004] MAK", "background": null, "description": "置换就是 $n$ 个元素 $1$ 对 $1$ 的函数映射$p:\\{1,2,\\ldots,n\\}\\to\\{1,2,\\ldots,n\\}$，一个置换 $p$ 的 `order` 等于最小的 $k\\ge1$，且对所有的 $i=1,2,...,n$ 都满足：\n$$p(p(...(p(i))...))=i$$\n（共 $k$ 次）\n\n\n举个例子，对于 $3$ 个元素的 `order` $p(1)=3,p(2)=2,p(3)=1$ 为 $ 2$，因为$p(p(1))=1,p(p(2))=2,p(p(3))=3$。\n\n对于给定的 $n$ 我们想要一个长度为 $n$ 的置换的 `order` 尽量大。比如说长度为 $5$ 的置换的 order 最大为 $6$。\n\n一个例子就是 $p(1)=4,p(2)=5,p(3)=2,p(4)=1,p(5)=3$。\n\n对于所有使得 `order` 最大的置换中，我们要找到字典序最小的那个。\n\n更精确来说，我们说置换 $p$ 小于置换 $r$，即存在一个 $i$，使得对于所有 $j<i$ 都满足 $p(j)=r(j)$ 且 $p(i)<r(i)$。那么对于长度为 $5$ 的置换中最小的那个为 $p(1)=2,p(2)=1,p(3)=4,p(4)=5,p(5)=3$。", "inputFormat": "第一行一个数 $d$ 表示一共 $d$ 组数据。\n\n接下来 $d$ 行表示长度为 $n_1,n_2,...,n_d$。", "outputFormat": "输出 $d$ 行每行一个最优置换。", "hint": "对于 $100\\%$ 的数据，$1\\le d\\le10$，$1\\le n_i\\le10^4$。", "locale": "zh-CN"}}}
{"pid": "P5920", "type": "P", "difficulty": 5, "samples": [["6 5\n7 3\n3 4\n3 3\n6 1\n1 1\n5 5\n5 5\n3 1", "22"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "IOI"], "title": "[IOI 2005] gar", "background": " Byteman 拥有镇上最漂亮的花园。", "description": "他在自己的花园里面种了 $N$ 朵玫瑰花。\n\n夏天来了，所有的花都开的非常的漂亮。 Byteman 开始意识到自己没有能力看管自己花园里的所有的花，所以他决定雇佣两个园丁来帮助他。\n\n他想在花园中选择两块矩形的区域分别交给两个园丁看管。而且这两个矩形区域必须不能相交或者重叠，并且每一个区域要恰好包含 $K$ 朵玫瑰花。\n\nByteman 想要给这两块矩形区域的周围安上栅栏，但是他现在手头比较紧，所以他希望自己花的钱尽量的少。你的任务就是帮助 Byteman 选择两块矩形的区域,使得它们在满足条件的情况下周长和最小。 \n\nByteman 的花园有 $L$ 米长，$W$ 米宽。花园被分成了 $L\\times W$ 个大小相同 $1\\times1$ 的方格。我们以平行与花园的两边建立起一个坐标系。所有的方格的坐标 $(x,y)$ 满足 $1\\leq x\\leq L,1\\leq y\\leq W$。每个方格内可能会有任意数目的玫瑰。 \n\n所选的矩形区域的两边必须跟花园的两边平行，并且矩形区域的四个角的坐标必须是整数。对于 $1\\le L_1\\le L_2\\le L$ 并且 $1\\le W_1\\le W_2\\le W$，一个矩形区域的四个角为 $(L_1,W_1),(L_1,W_2)$，$(L_2,W_1)$ 和 $(L_2,W_2)$: \n\n* 这个矩形内所包含的点的坐标 $(x,y)$ 满足$L_1\\le x\\le L_2$并且$W_1\\le y\\le W_2$。\n\n* 这个矩形的周长是 $2\\times (L_2-L_1+1)+2\\times (W_2-W_1+1)$。所选的两块矩形不能重叠或者相交。也就是它们不能有公共的方格。即使它们有公共的边，计算周长的时候也要分别计算。", "inputFormat": "第一行是 $L$ 和 $W$。\n\n第二行是 $N$ 和 $K$。\n\n接下来 $N$ 行为 $N$ 朵玫瑰的坐标。", "outputFormat": "输出仅有一行，为最小周长。\n\n如果不存在满足题意的矩形，则输出`NO`。", "hint": "对于$100\\%$的数据，$1\\le L,W\\le250$，$2\\le n\\le5000,1\\le k\\le \\frac{n}{2}$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2005] gar", "background": " Byteman 拥有镇上最漂亮的花园。", "description": "他在自己的花园里面种了 $N$ 朵玫瑰花。\n\n夏天来了，所有的花都开的非常的漂亮。 Byteman 开始意识到自己没有能力看管自己花园里的所有的花，所以他决定雇佣两个园丁来帮助他。\n\n他想在花园中选择两块矩形的区域分别交给两个园丁看管。而且这两个矩形区域必须不能相交或者重叠，并且每一个区域要恰好包含 $K$ 朵玫瑰花。\n\nByteman 想要给这两块矩形区域的周围安上栅栏，但是他现在手头比较紧，所以他希望自己花的钱尽量的少。你的任务就是帮助 Byteman 选择两块矩形的区域,使得它们在满足条件的情况下周长和最小。 \n\nByteman 的花园有 $L$ 米长，$W$ 米宽。花园被分成了 $L\\times W$ 个大小相同 $1\\times1$ 的方格。我们以平行与花园的两边建立起一个坐标系。所有的方格的坐标 $(x,y)$ 满足 $1\\leq x\\leq L,1\\leq y\\leq W$。每个方格内可能会有任意数目的玫瑰。 \n\n所选的矩形区域的两边必须跟花园的两边平行，并且矩形区域的四个角的坐标必须是整数。对于 $1\\le L_1\\le L_2\\le L$ 并且 $1\\le W_1\\le W_2\\le W$，一个矩形区域的四个角为 $(L_1,W_1),(L_1,W_2)$，$(L_2,W_1)$ 和 $(L_2,W_2)$: \n\n* 这个矩形内所包含的点的坐标 $(x,y)$ 满足$L_1\\le x\\le L_2$并且$W_1\\le y\\le W_2$。\n\n* 这个矩形的周长是 $2\\times (L_2-L_1+1)+2\\times (W_2-W_1+1)$。所选的两块矩形不能重叠或者相交。也就是它们不能有公共的方格。即使它们有公共的边，计算周长的时候也要分别计算。", "inputFormat": "第一行是 $L$ 和 $W$。\n\n第二行是 $N$ 和 $K$。\n\n接下来 $N$ 行为 $N$ 朵玫瑰的坐标。", "outputFormat": "输出仅有一行，为最小周长。\n\n如果不存在满足题意的矩形，则输出`NO`。", "hint": "对于$100\\%$的数据，$1\\le L,W\\le250$，$2\\le n\\le5000,1\\le k\\le \\frac{n}{2}$", "locale": "zh-CN"}}}
{"pid": "P5921", "type": "P", "difficulty": 5, "samples": [["12\n2 3\n3 9\n9 6\n8 5\n5 7\n7 6\n4 5\n5 1\n1 4\n4 2\n2 8\n8 6", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["1999", "POI（波兰）"], "title": "[POI 1999 R3] 原始生物", "background": "鸣谢 `@Jiangly` 提出错误，`@NaCly_Fish` 修改数据。", "description": "原始生物的遗传密码是一个自然数的序列 $K=\\{a_1,\\dots,a_n\\}$。\n\n原始生物的特征是指在遗传密码 $K$ 中连续出现的数对 $(l,r)$，即存在自然数 $i$ 使得 $l=a_i$ 且 $r=a_{i+1}$。保证不存在 $(p,p)$ 形式的特征。\n\n### 任务\n\n请设计一个程序：\n- 读入一系列的特征；\n- 计算包含这些特征的最短的遗传密码的长度；\n- 将结果输出。", "inputFormat": "第一行是一个整数 $n$，表示特征的总数。\n\n在接下来的 $n$ 行里，每行都是一对由空格分隔的自然数 $l$ 和 $r$，表示数对 $(l,r)$ 是原始生物的特征之一。\n\n输入文件中的特征**可能会有重复**，请过滤掉。", "outputFormat": "仅一行一个整数，表示包含这些特征的最短的遗传密码的长度。", "hint": "### 样例解释\n$\\{8,5,1,4,2,3,9,6,4,5,7,6,2,8,6\\}$ 是一个符合题意的遗传密码。\n\n### 数据范围\n对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le l,r\\le 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 1999 R3] 原始生物", "background": "鸣谢 `@Jiangly` 提出错误，`@NaCly_Fish` 修改数据。", "description": "原始生物的遗传密码是一个自然数的序列 $K=\\{a_1,\\dots,a_n\\}$。\n\n原始生物的特征是指在遗传密码 $K$ 中连续出现的数对 $(l,r)$，即存在自然数 $i$ 使得 $l=a_i$ 且 $r=a_{i+1}$。保证不存在 $(p,p)$ 形式的特征。\n\n### 任务\n\n请设计一个程序：\n- 读入一系列的特征；\n- 计算包含这些特征的最短的遗传密码的长度；\n- 将结果输出。", "inputFormat": "第一行是一个整数 $n$，表示特征的总数。\n\n在接下来的 $n$ 行里，每行都是一对由空格分隔的自然数 $l$ 和 $r$，表示数对 $(l,r)$ 是原始生物的特征之一。\n\n输入文件中的特征**可能会有重复**，请过滤掉。", "outputFormat": "仅一行一个整数，表示包含这些特征的最短的遗传密码的长度。", "hint": "### 样例解释\n$\\{8,5,1,4,2,3,9,6,4,5,7,6,2,8,6\\}$ 是一个符合题意的遗传密码。\n\n### 数据范围\n对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le l,r\\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P5923", "type": "P", "difficulty": 4, "samples": [["8\n0\n3\n5\n4\n6\n2\n1\n7\n", "1\n2 5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2004", "IOI", "单调栈"], "title": "[IOI 2004] empodia 障碍段", "background": "古数学及哲学家毕氏相信自然之本质为数学。\n\n现代生物学家研究生物数列。", "description": "生物数列为满足下列条件的 $M$ 个整数所成的数列：\n\n- 包含 $0, 1, \\cdots, M-1$ 中的所有数字。\n- 起始数字为 $0$，最后一个数字为 $M - 1$。\n- 数列中 $E+1$ 不可以紧接在 $E$ 之后。\n\n生物数列的连续子数列称为数段。如果一个数段的：\n\n- 起点为该数段最小的数字。\n\n- 终点为该数段最大的数字且与起点不是同一个数字。\n\n- 且介于这两个数字之间所有的整数都出现在这个数段中。\n\n则称这个数段为框段。\n\n如果框段中并不包含更短的框段，则称之为障碍段。\n\n以 `(0,3,5,4,6,2,1,7)` 这个生物数列为例。 \n\n整个生物数列是一个框段，可是它包含了另外一框段 `(3,5,4,6)`，因此该生物数列不是障碍段。而框段 `(3,5,4,6)` 并不包含任何更短的框段，所以它是一个障碍段，而且是此生物数列中唯一的障碍段。请写一个程序，在输入生物数列后，输出所有的障碍段。", "inputFormat": "第一行为单一整数 $M$，代表生物数列的长度。 \n\n生物数列中的数字依序出现在接下来的 $M$ 行，每一行有一个整数。", "outputFormat": "第一行为一整数 $H$，代表该生物数列中的障碍段的个数。\n\n接下来的 $H$ 行，将每一个障碍段，依照起点在原输入生物数列中出现的顺序，依序输出。\n\n每行以 $2$ 个整数 $A$ 与 $B$ 代表一个障碍段并以一个空格分开。\n\n原输入生物数列第 $A$ 个元素为该障碍段的起点，而第 $B$ 个元素为该障碍段的终点。", "hint": "对于 $100\\%$ 的数据，$M\\le1100000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2004] empodia 障碍段", "background": "古数学及哲学家毕氏相信自然之本质为数学。\n\n现代生物学家研究生物数列。", "description": "生物数列为满足下列条件的 $M$ 个整数所成的数列：\n\n- 包含 $0, 1, \\cdots, M-1$ 中的所有数字。\n- 起始数字为 $0$，最后一个数字为 $M - 1$。\n- 数列中 $E+1$ 不可以紧接在 $E$ 之后。\n\n生物数列的连续子数列称为数段。如果一个数段的：\n\n- 起点为该数段最小的数字。\n\n- 终点为该数段最大的数字且与起点不是同一个数字。\n\n- 且介于这两个数字之间所有的整数都出现在这个数段中。\n\n则称这个数段为框段。\n\n如果框段中并不包含更短的框段，则称之为障碍段。\n\n以 `(0,3,5,4,6,2,1,7)` 这个生物数列为例。 \n\n整个生物数列是一个框段，可是它包含了另外一框段 `(3,5,4,6)`，因此该生物数列不是障碍段。而框段 `(3,5,4,6)` 并不包含任何更短的框段，所以它是一个障碍段，而且是此生物数列中唯一的障碍段。请写一个程序，在输入生物数列后，输出所有的障碍段。", "inputFormat": "第一行为单一整数 $M$，代表生物数列的长度。 \n\n生物数列中的数字依序出现在接下来的 $M$ 行，每一行有一个整数。", "outputFormat": "第一行为一整数 $H$，代表该生物数列中的障碍段的个数。\n\n接下来的 $H$ 行，将每一个障碍段，依照起点在原输入生物数列中出现的顺序，依序输出。\n\n每行以 $2$ 个整数 $A$ 与 $B$ 代表一个障碍段并以一个空格分开。\n\n原输入生物数列第 $A$ 个元素为该障碍段的起点，而第 $B$ 个元素为该障碍段的终点。", "hint": "对于 $100\\%$ 的数据，$M\\le1100000$。", "locale": "zh-CN"}}}
{"pid": "P5924", "type": "P", "difficulty": 4, "samples": [["21 11\n4\n10 4\n6 2\n7 5\n15 10", "10"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2004", "IOI", "记忆化搜索"], "title": "[IOI 2004] Phidias 菲迪亚斯神", "background": "有名的希腊雕刻神菲迪亚斯正在为他下一座雄伟的雕像作准备。", "description": "为了这座雕像他需要大小为 $W_1\\times H_1,W_2\\times H_2, ...,W_N \\times H_N$ 的矩形大理石板。\n\n最近菲迪亚斯获得一块矩形大理石块。菲迪亚斯想把这块石板切成所需要的大小。\n\n石板或是石板所切割出的部分都可以由垂直(或水平)方向纵贯(或是横贯)加以切割到底成为两块矩形石板，同时切割出的这两块矩形石板都必须具有整数的宽度与高度。\n\n石板只能以此种方法加以切割，同时石板不能粘合成较大石板。\n\n因为石板具有花纹，所以石板也不能旋转。\n\n如果菲迪亚斯切割出一块 $A\\times B$ 的石板，则此石板不能被当成 $B\\times A$ 的石板使用，除非 $A$ 等于 $B$。对每一种所需石板大小菲迪亚斯可切割出零或更多块石板。如果当所有的切割完成时，一块产生出的石板并不是任何所需要的大小，则此石板成为废料。\n\n菲迪亚斯想知道如何切割最初的石板，才能让所产生的废料最少。\n\n例如，下图中的原始石板宽度为 $21$ 且高度为 $11$，而所需石板大小为 $10\\times4,6\\times 2, 7\\times5$ 及 $15\\times 10$, 则最小废料总面积为 $10$。下图同时画出最小废料总面积为 $10$ 的切割方法：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s48ydewh.png)\n\n你的工作是写一个程序由给定的原始石板大小及所需要的各种石板大小计算出最小的废料总面积。", "inputFormat": "第一行为两个整数。\n\n第一个整数 $W$ 为原始石板的宽度，第二个整数 $H$ 为原始石板的高度。\n\n第二行为一个整数 $N$，代表所需石板种类数目。以下 $N$ 行为各种所需石板的大小。\n\n每一行为两个整数，第一个整数为所需石板宽度 $W_i$，第二个整数为所需石板宽度 $H_i$ 。\n", "outputFormat": "为一行且仅包含一个整数，代表最小废料总面积。", "hint": "对于 $100\\%$ 的数据，$1\\le W,H\\le600$，$0\\le N\\le 200$，$1 \\le W_i \\le W$，$1 \\le H_i \\le H$。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2004] Phidias 菲迪亚斯神", "background": "有名的希腊雕刻神菲迪亚斯正在为他下一座雄伟的雕像作准备。", "description": "为了这座雕像他需要大小为 $W_1\\times H_1,W_2\\times H_2, ...,W_N \\times H_N$ 的矩形大理石板。\n\n最近菲迪亚斯获得一块矩形大理石块。菲迪亚斯想把这块石板切成所需要的大小。\n\n石板或是石板所切割出的部分都可以由垂直(或水平)方向纵贯(或是横贯)加以切割到底成为两块矩形石板，同时切割出的这两块矩形石板都必须具有整数的宽度与高度。\n\n石板只能以此种方法加以切割，同时石板不能粘合成较大石板。\n\n因为石板具有花纹，所以石板也不能旋转。\n\n如果菲迪亚斯切割出一块 $A\\times B$ 的石板，则此石板不能被当成 $B\\times A$ 的石板使用，除非 $A$ 等于 $B$。对每一种所需石板大小菲迪亚斯可切割出零或更多块石板。如果当所有的切割完成时，一块产生出的石板并不是任何所需要的大小，则此石板成为废料。\n\n菲迪亚斯想知道如何切割最初的石板，才能让所产生的废料最少。\n\n例如，下图中的原始石板宽度为 $21$ 且高度为 $11$，而所需石板大小为 $10\\times4,6\\times 2, 7\\times5$ 及 $15\\times 10$, 则最小废料总面积为 $10$。下图同时画出最小废料总面积为 $10$ 的切割方法：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s48ydewh.png)\n\n你的工作是写一个程序由给定的原始石板大小及所需要的各种石板大小计算出最小的废料总面积。", "inputFormat": "第一行为两个整数。\n\n第一个整数 $W$ 为原始石板的宽度，第二个整数 $H$ 为原始石板的高度。\n\n第二行为一个整数 $N$，代表所需石板种类数目。以下 $N$ 行为各种所需石板的大小。\n\n每一行为两个整数，第一个整数为所需石板宽度 $W_i$，第二个整数为所需石板宽度 $H_i$ 。\n", "outputFormat": "为一行且仅包含一个整数，代表最小废料总面积。", "hint": "对于 $100\\%$ 的数据，$1\\le W,H\\le600$，$0\\le N\\le 200$，$1 \\le W_i \\le W$，$1 \\le H_i \\le H$。\n\n", "locale": "zh-CN"}}}
{"pid": "P5925", "type": "P", "difficulty": 2, "samples": [["3\n3 5\n1 2\n4 3\n6 3\n5 2\n2 1", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "POI（波兰）"], "title": "[POI 2007] 天然气管道Gaz", "background": "Mary 试图控制成都的天然气市场。", "description": "专家已经标示出了最好的天然气井和中转站在成都的地图。现在需要将中转\n站和天然气井连接起来。\n\n每个中转站必须被连接到正好一个钻油井，反之亦然。 \n\nMary 特别指名，建设的天然气管道必须从某个天然气井开始，向南或者向东建设。\n\nMary 想知道怎么连接每个天然气井和中转站，使得需要的天然气管道的总长度最小。保证有解。", "inputFormat": "第一行为一个正整数 $n$，表示天然气井的数量（中转站的数量与之相等）。\n\n接下来 $n$ 行，每行两个整数 $x_i$ 和 $y_i$，表示天然气井的坐标。向东走则 $x$ 坐标增加，向北走则 $y$ 坐标增加接下来 $n$ 行，每行两个数 $x_j$ 和 $y_j$，表示中转站的坐标。", "outputFormat": "第一行包含一个数，表示最短的连接管道长度。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le50000$，$0\\le x_i,y_i,x_j,y_j\\le100000$\n\n------\n\n## 样例解释：\n![](https://cdn.luogu.com.cn/upload/image_hosting/rwhyfbkm.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2007] 天然气管道Gaz", "background": "Mary 试图控制成都的天然气市场。", "description": "专家已经标示出了最好的天然气井和中转站在成都的地图。现在需要将中转\n站和天然气井连接起来。\n\n每个中转站必须被连接到正好一个钻油井，反之亦然。 \n\nMary 特别指名，建设的天然气管道必须从某个天然气井开始，向南或者向东建设。\n\nMary 想知道怎么连接每个天然气井和中转站，使得需要的天然气管道的总长度最小。保证有解。", "inputFormat": "第一行为一个正整数 $n$，表示天然气井的数量（中转站的数量与之相等）。\n\n接下来 $n$ 行，每行两个整数 $x_i$ 和 $y_i$，表示天然气井的坐标。向东走则 $x$ 坐标增加，向北走则 $y$ 坐标增加接下来 $n$ 行，每行两个数 $x_j$ 和 $y_j$，表示中转站的坐标。", "outputFormat": "第一行包含一个数，表示最短的连接管道长度。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le50000$，$0\\le x_i,y_i,x_j,y_j\\le100000$\n\n------\n\n## 样例解释：\n![](https://cdn.luogu.com.cn/upload/image_hosting/rwhyfbkm.png)", "locale": "zh-CN"}}}
{"pid": "P5926", "type": "P", "difficulty": 6, "samples": [["5 3\n1 4 2 6 7\n2 3\n3 4\n2 5", "2\n4\n1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2009", "各省省选", "江苏", "O2优化"], "title": "[JSOI2009] 面试的考验", "background": "", "description": "求区间最接近且不相等的两数之差的绝对值。\n\n**注：最接近指数值上最接近**", "inputFormat": "第一行输入两个整数 $N,Q$，分别代表序列的长度和询问的个数。\n\n第二行包含 $N$ 个由一个空格分开的正整数，代表了整个序列，从左向右依次编号为 $A_1, A_2……A_n$。\n\n接下来 $Q$ 行，每行两个整数 $i,j$ 表示了一个询问区间。\n\n输入数据保证 $1\\le i<j\\le N$。", "outputFormat": "对于每一个询问输出一行，为所问区间中最接近两个数之差的绝对值。", "hint": "对于 $100\\%$ 的数据，$1\\le N,Q\\le10^5,1\\le A_i\\le10^9$。\n\n数据为全部**纯随机**生成。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2009] 面试的考验", "background": "", "description": "求区间最接近且不相等的两数之差的绝对值。\n\n**注：最接近指数值上最接近**", "inputFormat": "第一行输入两个整数 $N,Q$，分别代表序列的长度和询问的个数。\n\n第二行包含 $N$ 个由一个空格分开的正整数，代表了整个序列，从左向右依次编号为 $A_1, A_2……A_n$。\n\n接下来 $Q$ 行，每行两个整数 $i,j$ 表示了一个询问区间。\n\n输入数据保证 $1\\le i<j\\le N$。", "outputFormat": "对于每一个询问输出一行，为所问区间中最接近两个数之差的绝对值。", "hint": "对于 $100\\%$ 的数据，$1\\le N,Q\\le10^5,1\\le A_i\\le10^9$。\n\n数据为全部**纯随机**生成。", "locale": "zh-CN"}}}
{"pid": "P5927", "type": "P", "difficulty": 5, "samples": [["4      \n2  3    \n3  4    \n1  2    \n4  1   ", "2  6    "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "江苏", "单调栈"], "title": "[JSOI2010] 下棋问题", "background": "有一个新的益智游戏。\n\n", "description": "该游戏由 A 和 B 两人轮流在一个 $1000000\\times1000000$ 的方格棋盘上的网格线交点下棋，网格线交点的坐标以 $(x,y)$ 表示，$(0, 0)$ 代表棋盘最左下角的点。\n\n每一个棋子放置的位置不可以与任何其它棋子在同一坐标上，棋盘上新增加一个棋子时，棋盘上的计数器会自动算出以目前棋盘上棋子所能够围成的 `无障碍四方形` 个数。 \n\n`无障碍四方形` 是指以任意两个棋子所定义出的四方形内部不含其它棋子，每下一个棋子后所算出的 `无障碍四方形` 个数即为下该棋子的得分数。每位下棋者的总分即是该下棋者每个所下棋子的得分数总和。\n\n请写一个程序计算 A 和 B 两位下棋者的累计总分。", "inputFormat": "第一行输入只有一个整数 $n$，代表此盘棋共下了 $n$ 个棋子。\n\n接下来的 $n$ 行，每一行有两个整数，依序代表这 $n$ 个棋子所放置的位置。", "outputFormat": "请输出两个整数，分别代表该盘棋两位下棋者的累计得分数。A 的分数在前，B 的分数在后，中间用一个空格隔开。", "hint": "对于 $100\\%$ 的数据， $1\\le n\\le5000$，$0\\le x,y\\le 1,000,000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2010] 下棋问题", "background": "有一个新的益智游戏。\n\n", "description": "该游戏由 A 和 B 两人轮流在一个 $1000000\\times1000000$ 的方格棋盘上的网格线交点下棋，网格线交点的坐标以 $(x,y)$ 表示，$(0, 0)$ 代表棋盘最左下角的点。\n\n每一个棋子放置的位置不可以与任何其它棋子在同一坐标上，棋盘上新增加一个棋子时，棋盘上的计数器会自动算出以目前棋盘上棋子所能够围成的 `无障碍四方形` 个数。 \n\n`无障碍四方形` 是指以任意两个棋子所定义出的四方形内部不含其它棋子，每下一个棋子后所算出的 `无障碍四方形` 个数即为下该棋子的得分数。每位下棋者的总分即是该下棋者每个所下棋子的得分数总和。\n\n请写一个程序计算 A 和 B 两位下棋者的累计总分。", "inputFormat": "第一行输入只有一个整数 $n$，代表此盘棋共下了 $n$ 个棋子。\n\n接下来的 $n$ 行，每一行有两个整数，依序代表这 $n$ 个棋子所放置的位置。", "outputFormat": "请输出两个整数，分别代表该盘棋两位下棋者的累计得分数。A 的分数在前，B 的分数在后，中间用一个空格隔开。", "hint": "对于 $100\\%$ 的数据， $1\\le n\\le5000$，$0\\le x,y\\le 1,000,000$。", "locale": "zh-CN"}}}
{"pid": "P5928", "type": "P", "difficulty": 6, "samples": [["4 3\n-1 0 0 10\n-1 -1 -1 2\n-1 1 -1 2\n-1 -2 -1 1\n0 2\n0 -2\n1 0", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2014", "模拟退火", "凸包", "半平面交", "CTT（清华集训/北大集训）"], "title": "[清华集训 2014] 文学", "background": "", "description": "巨酱和主席是一对好朋友。他们都很喜欢读书，经常一起阅读相关领域书籍，进行系统的学习。一天主席列出了一份列表，里面共 $p$ 本书，其中不乏《约翰克里斯多夫》，《名人传》等名著。作为一名在文学上有很高修养的知名青年，巨酱打算用尽量少的时间把这份列表中的所有书籍都读完。\n\n作为一名文化人，巨酱阅读书籍的方式也与一般人不同。他使用一种叫做“批量阅读”的阅读方式。首先他根据自己的喜好，对每本书给出了个参数 $x,y$，其中 $i$ 本书的两个参数为 $x_i,y_i$。当然，由于巨酱独特的口味，可能有两本不同的书，它们的 $x,y$ 参数均相同。而每次阅读的时候，他会设置三个系数 $a, b, c$，所有满足 $a \\times x+b \\times y \\leq c$ 的书籍都可以通过这次“批量阅读”读完，这次批量阅读总共需要 $w$ 的时间。\n现在，巨酱有 $n$ 种 “批量阅读”的方案，第 $i$ 种“批量阅读”三个参数为 $a_i,b_i,c_i$，需要的时间为 $w_i$。现在巨酱打算从这 $n$ 种“批量阅读”中选出若干，使得巨酱可以用尽量少的时间读完所有的书。现在我们想知道，巨酱最少用多少时间？", "inputFormat": "第一行两个正整数 $n,p$，分别表示“批量阅读”的方案数以及书的数量。\n\n接下来 $n$ 行，每行四个整数，其中第 $i$ 行包含四个整数 $a_i,b_i,c_i,w_i$，表示第 $i$ 种“批量阅读”的方案。\n\n接下来 $p$ 行，每行两个整数，其中第 $i$ 行包含两个整数 $x_i,y_i$，表示第 $i$ 本书的参数。", "outputFormat": "一行一个整数，表示最少需要的时间。若无论如何也无法读完全部书籍，则输出 $−1$。", "hint": "对于 $100\\%$ 的测试数据，$1 \\leq n,p \\leq 100，−10^6 \\leq a_i,b_i,c_i,x_i,y_i \\leq 10^6， 0 \\lt w_i \\leq 10^6$，且保证对于任何一种“批量阅读”方案，其 $a_i$ 与 $b_i$ 不会同时为 $0$。且不存在 $i, j$（$i$ 不等于 $j$）使得 $a_i \\times b_j=a_j \\times b_i$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2014] 文学", "background": "", "description": "巨酱和主席是一对好朋友。他们都很喜欢读书，经常一起阅读相关领域书籍，进行系统的学习。一天主席列出了一份列表，里面共 $p$ 本书，其中不乏《约翰克里斯多夫》，《名人传》等名著。作为一名在文学上有很高修养的知名青年，巨酱打算用尽量少的时间把这份列表中的所有书籍都读完。\n\n作为一名文化人，巨酱阅读书籍的方式也与一般人不同。他使用一种叫做“批量阅读”的阅读方式。首先他根据自己的喜好，对每本书给出了个参数 $x,y$，其中 $i$ 本书的两个参数为 $x_i,y_i$。当然，由于巨酱独特的口味，可能有两本不同的书，它们的 $x,y$ 参数均相同。而每次阅读的时候，他会设置三个系数 $a, b, c$，所有满足 $a \\times x+b \\times y \\leq c$ 的书籍都可以通过这次“批量阅读”读完，这次批量阅读总共需要 $w$ 的时间。\n现在，巨酱有 $n$ 种 “批量阅读”的方案，第 $i$ 种“批量阅读”三个参数为 $a_i,b_i,c_i$，需要的时间为 $w_i$。现在巨酱打算从这 $n$ 种“批量阅读”中选出若干，使得巨酱可以用尽量少的时间读完所有的书。现在我们想知道，巨酱最少用多少时间？", "inputFormat": "第一行两个正整数 $n,p$，分别表示“批量阅读”的方案数以及书的数量。\n\n接下来 $n$ 行，每行四个整数，其中第 $i$ 行包含四个整数 $a_i,b_i,c_i,w_i$，表示第 $i$ 种“批量阅读”的方案。\n\n接下来 $p$ 行，每行两个整数，其中第 $i$ 行包含两个整数 $x_i,y_i$，表示第 $i$ 本书的参数。", "outputFormat": "一行一个整数，表示最少需要的时间。若无论如何也无法读完全部书籍，则输出 $−1$。", "hint": "对于 $100\\%$ 的测试数据，$1 \\leq n,p \\leq 100，−10^6 \\leq a_i,b_i,c_i,x_i,y_i \\leq 10^6， 0 \\lt w_i \\leq 10^6$，且保证对于任何一种“批量阅读”方案，其 $a_i$ 与 $b_i$ 不会同时为 $0$。且不存在 $i, j$（$i$ 不等于 $j$）使得 $a_i \\times b_j=a_j \\times b_i$。", "locale": "zh-CN"}}}
{"pid": "P5929", "type": "P", "difficulty": 4, "samples": [["11\n3\n21\n14\n6\n18\n10\n2\n15\n12\n3\n2\n2", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["1999", "POI（波兰）"], "title": "[POI 1999 R3] 地图", "background": "一个人口统计办公室要绘制一张地图。", "description": "由于技术的原因只能使用少量的颜色。两个有相同或相近人口的区域在地图应用相同的颜色。例如一种颜色 $k$，则 $A(k)$ 是相应的数，则有：\n- 在用颜色 $k$ 的区域中至少有一半的区域的人口不大于 $A(k)$；\n- 在用颜色 $k$ 的区域中至少有一半的区域的人口不小于 $A(k)$。\n\n区域颜色误差是该区域的人口与 $A(k)$ 差的绝对值。累计误差是所有区域颜色误差的总和。我们要求出一种最佳的染色方案，使得累计误差最小。", "inputFormat": "第一行有一个整数 $n$，表示区域数。\n\n在第二行中的数 $m$ 表示颜色数。\n\n在接下来的 $n$ 行中每行有一个非负整数，表示一个区域的人口。\n\n人口都不超过 $2^{30}$。", "outputFormat": "输出一个整数，表示最小的累计误差。", "hint": "对于 $100\\%$ 的数据，$10 < n < 3000$，$2 \\le m \\le 10$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 1999 R3] 地图", "background": "一个人口统计办公室要绘制一张地图。", "description": "由于技术的原因只能使用少量的颜色。两个有相同或相近人口的区域在地图应用相同的颜色。例如一种颜色 $k$，则 $A(k)$ 是相应的数，则有：\n- 在用颜色 $k$ 的区域中至少有一半的区域的人口不大于 $A(k)$；\n- 在用颜色 $k$ 的区域中至少有一半的区域的人口不小于 $A(k)$。\n\n区域颜色误差是该区域的人口与 $A(k)$ 差的绝对值。累计误差是所有区域颜色误差的总和。我们要求出一种最佳的染色方案，使得累计误差最小。", "inputFormat": "第一行有一个整数 $n$，表示区域数。\n\n在第二行中的数 $m$ 表示颜色数。\n\n在接下来的 $n$ 行中每行有一个非负整数，表示一个区域的人口。\n\n人口都不超过 $2^{30}$。", "outputFormat": "输出一个整数，表示最小的累计误差。", "hint": "对于 $100\\%$ 的数据，$10 < n < 3000$，$2 \\le m \\le 10$。", "locale": "zh-CN"}}}
{"pid": "P5930", "type": "P", "difficulty": 4, "samples": [["3 6\n3 3 4 4 4 2\n3 1 3 2 1 4\n7 3 1 6 4 1", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["1999", "POI（波兰）"], "title": "[POI 1999 R3] 降水", "background": null, "description": "遥远的地方有一块土地。它被划分成 $N\\times M$ 个正方形小块，每块面积是一平方英寸，第 $i$ 行第 $j$ 列的小块可以表示成 $(i,j)$。这块土地高低不平，每一小块地 $(i,j)$ 都有自己的高度 $H(i,j)$（单位是英寸）。\n\n一场倾盆大雨后，这块地由于地势高低不同，许多低洼地方都积存了不少降水。假如你已经知道这块土地的详细信息，你能求出它最多能积存多少立方英寸的降水么？", "inputFormat": "输入文件第一行有两个数 $N,M$，表示土地的规模是 $N\\times M$ 平方英寸。\n\n接下来 $N$ 行，每行有 $M$ 个整数，表示每块地的高度（每个整数在 $[1,10000]$ 内，以英寸为单位）。", "outputFormat": "仅一行一个整数，表示土地中最多能积存多少立方英寸的水。", "hint": "对于 $100\\%$ 的数据，$1\\le N,M \\le 100$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 1999 R3] 降水", "background": null, "description": "遥远的地方有一块土地。它被划分成 $N\\times M$ 个正方形小块，每块面积是一平方英寸，第 $i$ 行第 $j$ 列的小块可以表示成 $(i,j)$。这块土地高低不平，每一小块地 $(i,j)$ 都有自己的高度 $H(i,j)$（单位是英寸）。\n\n一场倾盆大雨后，这块地由于地势高低不同，许多低洼地方都积存了不少降水。假如你已经知道这块土地的详细信息，你能求出它最多能积存多少立方英寸的降水么？", "inputFormat": "输入文件第一行有两个数 $N,M$，表示土地的规模是 $N\\times M$ 平方英寸。\n\n接下来 $N$ 行，每行有 $M$ 个整数，表示每块地的高度（每个整数在 $[1,10000]$ 内，以英寸为单位）。", "outputFormat": "仅一行一个整数，表示土地中最多能积存多少立方英寸的水。", "hint": "对于 $100\\%$ 的数据，$1\\le N,M \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P5931", "type": "P", "difficulty": 4, "samples": [["3\n2 1 0.5\n2 0.5 3\n4 3 4", "1.000\n0.750\n4.000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2015", "三分", "Special Judge", "CTT（清华集训/北大集训）"], "title": "[清华集训 2015] 灯泡", "background": "$2022$ 年，评测数据发生了翻天覆地的变化，请 $2022$ 年前通过此题的人重新交一遍。", "description": "相比 Wildleopard 的家，他的弟弟 Mildleopard 比较穷。他的房子是狭窄的，而且在他的房间里仅有一个灯泡。每天晚上，他徘徊在自己狭小的房子里，思考如何赚更多的钱。有一天，他发现他的影子的长度随着他在灯泡和墙壁之间走动时会发生变化。一个突然的想法出现在他的脑海里，他想知道在房间里他的影子的最大长度。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i78578mk.png)", "inputFormat": "输入文件的第一行包含一个整数 $T$，表示测试数据的组数。\n\n对于每组测试数据仅有一行包含三个实数 $H,h$ 和 $D$，$H$ 表示灯泡的高度，$h$ 表示 Mildleopard 的身高，$D$ 表示灯泡和墙的水平距离。", "outputFormat": "输出文件共 $T$ 行，每组数据占一行，表示影子的最大长度 $L$。当你的输出与标准输出的绝对误差不超过 $10^{-3}$ 即视作通过。", "hint": "$1\\le T \\le 100,0.01 \\le H,h,D \\le 1000,H-h\\ge 0.01$，保证 $H,h,D$ 最多由 $6$ 位小数构成。", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training 2015] Light Bulb", "background": "In $2022$, the judging testdata changed a lot. Please ask anyone who passed this problem before $2022$ to submit again.", "description": "Compared with Wildleopard’s home, his younger brother Mildleopard is poorer. His house is narrow, and there is only one light bulb in his room. Every night, he walks around in his small house, thinking about how to earn more money. One day, he found that the length of his shadow changes as he walks between the light bulb and the wall. A sudden idea came to his mind: he wants to know the maximum possible length of his shadow in the room.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i78578mk.png)", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nFor each test case, there is one line containing three real numbers $H$, $h$, and $D$. $H$ is the height of the light bulb, $h$ is Mildleopard’s height, and $D$ is the horizontal distance between the light bulb and the wall.", "outputFormat": "Output $T$ lines. For each test case, output one line with the maximum shadow length $L$. Your answer is accepted if the absolute error compared with the standard output is at most $10^{-3}$.", "hint": "Constraints: $1 \\le T \\le 100$, $0.01 \\le H, h, D \\le 1000$, $H - h \\ge 0.01$. It is guaranteed that $H$, $h$, and $D$ have at most $6$ digits after the decimal point.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2015] 灯泡", "background": "$2022$ 年，评测数据发生了翻天覆地的变化，请 $2022$ 年前通过此题的人重新交一遍。", "description": "相比 Wildleopard 的家，他的弟弟 Mildleopard 比较穷。他的房子是狭窄的，而且在他的房间里仅有一个灯泡。每天晚上，他徘徊在自己狭小的房子里，思考如何赚更多的钱。有一天，他发现他的影子的长度随着他在灯泡和墙壁之间走动时会发生变化。一个突然的想法出现在他的脑海里，他想知道在房间里他的影子的最大长度。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i78578mk.png)", "inputFormat": "输入文件的第一行包含一个整数 $T$，表示测试数据的组数。\n\n对于每组测试数据仅有一行包含三个实数 $H,h$ 和 $D$，$H$ 表示灯泡的高度，$h$ 表示 Mildleopard 的身高，$D$ 表示灯泡和墙的水平距离。", "outputFormat": "输出文件共 $T$ 行，每组数据占一行，表示影子的最大长度 $L$。当你的输出与标准输出的绝对误差不超过 $10^{-3}$ 即视作通过。", "hint": "$1\\le T \\le 100,0.01 \\le H,h,D \\le 1000,H-h\\ge 0.01$，保证 $H,h,D$ 最多由 $6$ 位小数构成。", "locale": "zh-CN"}}}
{"pid": "P5932", "type": "P", "difficulty": 4, "samples": [["6\n\n0 1 2\n\n2 4 3\n\n4 2 0\n\n0 5 4", "TAK"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["1999", "POI（波兰）"], "title": "[POI 1999 R1] 多边形之战", "background": "多边形之战是一个双人游戏。", "description": "游戏在一个有 $n$ 个顶点的凸多边形上进行，这个凸多边形的 $n-3$ 条对角线将多边形分成 $n-2$ 个三角形，这 $n-3$ 条对角线在多边形的顶点相交。\n\n三角形中的一个被染成黑色，其余是白色。双方轮流进行游戏，当轮到一方时，他必须沿着画好的对角线，从多边形上切下一个三角形。切下黑色三角形的一方获胜。\n- 注：如果连接一个多边形中任意两点的线段都完全包含于这个多边形，则称这个多边形为凸多边形。", "inputFormat": "第一行是一个整数 $n$。表示多边形的顶点数，多边形的顶点从 $0$ 到 $n-1$ 顺时针标号。\n\n接着的 $n-2$ 行描述组成多边形的三角形，其中第 $i+1\\ (1 \\le i \\le n-2)$ 行有三个空格分隔的非负整数 $a, b, c$，它们是第 $i$ 个三角形的顶点编号，第一个给出的三角形是黑色的。", "outputFormat": "唯一一行应包含一个单词：\n- `TAK`，表示先走的一方有必胜策略。\n- `NIE`，表示先走的一方没有必胜策略。", "hint": "对于 $100\\%$ 的数据，$4 \\le n \\le 50000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 1999 R1] 多边形之战", "background": "多边形之战是一个双人游戏。", "description": "游戏在一个有 $n$ 个顶点的凸多边形上进行，这个凸多边形的 $n-3$ 条对角线将多边形分成 $n-2$ 个三角形，这 $n-3$ 条对角线在多边形的顶点相交。\n\n三角形中的一个被染成黑色，其余是白色。双方轮流进行游戏，当轮到一方时，他必须沿着画好的对角线，从多边形上切下一个三角形。切下黑色三角形的一方获胜。\n- 注：如果连接一个多边形中任意两点的线段都完全包含于这个多边形，则称这个多边形为凸多边形。", "inputFormat": "第一行是一个整数 $n$。表示多边形的顶点数，多边形的顶点从 $0$ 到 $n-1$ 顺时针标号。\n\n接着的 $n-2$ 行描述组成多边形的三角形，其中第 $i+1\\ (1 \\le i \\le n-2)$ 行有三个空格分隔的非负整数 $a, b, c$，它们是第 $i$ 个三角形的顶点编号，第一个给出的三角形是黑色的。", "outputFormat": "唯一一行应包含一个单词：\n- `TAK`，表示先走的一方有必胜策略。\n- `NIE`，表示先走的一方没有必胜策略。", "hint": "对于 $100\\%$ 的数据，$4 \\le n \\le 50000$。", "locale": "zh-CN"}}}
{"pid": "P5933", "type": "P", "difficulty": 6, "samples": [["3\n0 2 3\n2 0 4\n3 4 0\n", "50"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2012", "CTT（清华集训/北大集训）", "状压 DP"], "title": "[清华集训 2012] 串珠子", "background": "", "description": "铭铭有 $n$ 个十分漂亮的珠子和若干根颜色不同的绳子。现在铭铭想用绳子把所有的珠子连成一个整体。\n\n现在已知所有的珠子互不相同，用整数 $1$ 到 $n$ 编号。对于第 $i$ 个珠子和第 $j$ 个珠子，可以选择不用绳子连接，或者在 $c_{i,j}$ 根不同颜色的绳子中选择一根将它们连接。如果把珠子看作点，把绳子看作边，将所有珠子连成一个整体即为所有点构成一个连通图。特别地，珠子不能和自己连接。\n\n铭铭希望知道总共有多少种不同的方案将所有珠子连成一个整体。由于答案可能很大，因此只需输出答案对 $1000000007$ 取模的结果。", "inputFormat": "输入第一行包含一个正整数 $n$，表示珠子的个数。接下来 $n$ 行，每行包含 $n$ 个非负整数，用空格隔开。这 $n$ 行中，第 $i$ 行第 $j$ 个数为 $c_{i,j}$。", "outputFormat": "输出一行一个整数，为连接方案数对 $1000000007$ 取模的结果。", "hint": "#### 样例解释\n按每对珠子是否连接有以下四类连接方法。\n\n![Picture](https://s2.ax1x.com/2020/01/19/1C1K1I.png)\n\n每类连接方法包含的方法数为包含的边对应的绳子的 $c_{i,j}$ 之积。\n\n其中图(1)有 $2\\times3\\times4=24$ 种，图(2)有 $2\\times4=8$ 种，图(3)有 $2\\times3=6$ 种，图(4)有 $3\\times4=12$ 种。共 $50$ 种。\n\n#### 数据规模和约定\n对于 $100\\%$ 的数据，$n$ 为正整数，所有的 $c_{i,j}$ 为非负整数且不超过 $1000000007$。保证 $c_{i,j}=c_{j,i}$。每组数据的 $n$ 值如下表所示。\n\n|编号|1|2|3|4|5|6|7|8|9|10|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|$n$|$8$|$9$|$9$|$10$|$11$|$12$|$13$|$14$|$15$|$16$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2012] 串珠子", "background": "", "description": "铭铭有 $n$ 个十分漂亮的珠子和若干根颜色不同的绳子。现在铭铭想用绳子把所有的珠子连成一个整体。\n\n现在已知所有的珠子互不相同，用整数 $1$ 到 $n$ 编号。对于第 $i$ 个珠子和第 $j$ 个珠子，可以选择不用绳子连接，或者在 $c_{i,j}$ 根不同颜色的绳子中选择一根将它们连接。如果把珠子看作点，把绳子看作边，将所有珠子连成一个整体即为所有点构成一个连通图。特别地，珠子不能和自己连接。\n\n铭铭希望知道总共有多少种不同的方案将所有珠子连成一个整体。由于答案可能很大，因此只需输出答案对 $1000000007$ 取模的结果。", "inputFormat": "输入第一行包含一个正整数 $n$，表示珠子的个数。接下来 $n$ 行，每行包含 $n$ 个非负整数，用空格隔开。这 $n$ 行中，第 $i$ 行第 $j$ 个数为 $c_{i,j}$。", "outputFormat": "输出一行一个整数，为连接方案数对 $1000000007$ 取模的结果。", "hint": "#### 样例解释\n按每对珠子是否连接有以下四类连接方法。\n\n![Picture](https://s2.ax1x.com/2020/01/19/1C1K1I.png)\n\n每类连接方法包含的方法数为包含的边对应的绳子的 $c_{i,j}$ 之积。\n\n其中图(1)有 $2\\times3\\times4=24$ 种，图(2)有 $2\\times4=8$ 种，图(3)有 $2\\times3=6$ 种，图(4)有 $3\\times4=12$ 种。共 $50$ 种。\n\n#### 数据规模和约定\n对于 $100\\%$ 的数据，$n$ 为正整数，所有的 $c_{i,j}$ 为非负整数且不超过 $1000000007$。保证 $c_{i,j}=c_{j,i}$。每组数据的 $n$ 值如下表所示。\n\n|编号|1|2|3|4|5|6|7|8|9|10|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|$n$|$8$|$9$|$9$|$10$|$11$|$12$|$13$|$14$|$15$|$16$|", "locale": "zh-CN"}}}
{"pid": "P5934", "type": "P", "difficulty": 6, "samples": [["3 2\n3 2 1\n1 2 3\n1 2 2\n", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2012", "网络流", "最小割", "CTT（清华集训/北大集训）"], "title": "[清华集训 2012] 最小生成树", "background": "", "description": "给定一个边带正权的连通无向图 $G=(V,E)$，其中 $N=|V|,M=|E|$，$N$ 个点从 $1$ 到 $N$ 依次编号，给定三个正整数 $u,v$ 和 $L(u\\ne v)$，假设现在加入一条边权为 $L$ 的边 $(u,v)$，那么需要删掉最少多少条边，才能够使得这条边既可能出现在最小生成树上，也可能出现在最大生成树上？", "inputFormat": "第一行包含用空格隔开的两个整数，分别为 $N$ 和 $M$；\n\n接下来 $M$ 行，每行包含三个正整数 $u,v$ 和 $w$ 表示图 $G$ 存在一条边权为 $w$ 的边 $u,v$。\n\n最后一行包含用空格隔开的三个整数，分别为 $u,v$ 和 $L$；\n\n数据保证图中没有自环。", "outputFormat": "输出一行一个整数表示最少需要删掉的边的数量。", "hint": "#### 样例解释\n我们只需把边 $(1,2)$ 删除即可，删除并加入新边之后，图中的生成树唯一。\n\n#### 数据规模与约定\n对于 $20\\%$ 的数据满足 $N\\leqslant10,M\\leqslant20,L\\leqslant20$；\n\n对于 $50\\%$ 的数据满足 $N\\leqslant300,M\\leqslant3000,L\\leqslant200$；\n\n对于 $100\\%$ 的数据满足 $N\\leqslant20000,M\\leqslant200000,L\\leqslant20000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2012] 最小生成树", "background": "", "description": "给定一个边带正权的连通无向图 $G=(V,E)$，其中 $N=|V|,M=|E|$，$N$ 个点从 $1$ 到 $N$ 依次编号，给定三个正整数 $u,v$ 和 $L(u\\ne v)$，假设现在加入一条边权为 $L$ 的边 $(u,v)$，那么需要删掉最少多少条边，才能够使得这条边既可能出现在最小生成树上，也可能出现在最大生成树上？", "inputFormat": "第一行包含用空格隔开的两个整数，分别为 $N$ 和 $M$；\n\n接下来 $M$ 行，每行包含三个正整数 $u,v$ 和 $w$ 表示图 $G$ 存在一条边权为 $w$ 的边 $u,v$。\n\n最后一行包含用空格隔开的三个整数，分别为 $u,v$ 和 $L$；\n\n数据保证图中没有自环。", "outputFormat": "输出一行一个整数表示最少需要删掉的边的数量。", "hint": "#### 样例解释\n我们只需把边 $(1,2)$ 删除即可，删除并加入新边之后，图中的生成树唯一。\n\n#### 数据规模与约定\n对于 $20\\%$ 的数据满足 $N\\leqslant10,M\\leqslant20,L\\leqslant20$；\n\n对于 $50\\%$ 的数据满足 $N\\leqslant300,M\\leqslant3000,L\\leqslant200$；\n\n对于 $100\\%$ 的数据满足 $N\\leqslant20000,M\\leqslant200000,L\\leqslant20000$。", "locale": "zh-CN"}}}
{"pid": "P5935", "type": "P", "difficulty": 5, "samples": [["2\n1 2 2\ndd\ngg\n\n3 3 3\naaa\naaa\nbaa\n\naaa\naaa\nbaa\n\naaa\naaa\nbcc\n", "d 0 0 0\ng 0 1 0\n\na 1 1 1\nb 1 2 0\nc 2 2 1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["搜索", "2012", "Special Judge", "枚举", "剪枝", "CTT（清华集训/北大集训）"], "title": "[清华集训 2012] 攻占黄金乡", "background": "《海猫鸣泣之时》EP8 终于在今年暑假的末尾出了汉化，作为整个作品中高人气人物古户绘梨花，自然也是在剧中大活跃。在攻占黄金乡的战役中担任了指挥官一职，而整个战役过程也都被记录在了图书之都中，方便后来人的复盘。", "description": "当时的战况如下，黄金乡可以看做是一个长方体空间，我们用 $(0,0,0)\\sim(n-1,m-1,k-1)$ 表示里面的每一个单位区域，绘梨花指挥了 $t$ 艘不同等级的战舰依靠魔法突然出现在了黄金乡的 $t$ 个不同的区域，之后从战舰上便源源不断地涌出山羊们。每一个单位时刻，山羊们会从自己所在的区域向四周 $6$ 个方向扩展一个区域（如果那个相邻的区域已经被占领了，就不扩展），如果两队山羊在同一时刻想占领同一区域，那么等级高的山羊优先占领。\n\n没过多久，黄金乡就变成了一片山羊海，但是作为指挥官的绘梨花却因茫茫多的山羊而找不到战舰所在的位置了，于是她将问题交给了身边的你——山羊君，作为一个急于立下战功然后回故乡找山羊子的青年将领，你自然不会放弃这个机会，于是很快就找到了战舰所在的位置，你的这份功绩自然也会被记录到图书之都的文书之中。", "inputFormat": "第一行一个数 $test$，表示数据组数，以下 $test$ 部分。\n\n每部分第一行 $3$ 个数 $n,m,k$，以下 $n$ 部分，每部分为 $m$ 行 $k$ 列的字符矩阵。\n\n第 $i$ 部分表示区域 $(i,0,0)\\sim(i,m-1,k-1)$ 中的战况。\n\n不同等级的山羊我们用不同的小写英文字母表示，字典序越小的字母表示山羊等级越高。\n\n相邻部分之间用空行隔开。", "outputFormat": "输出 $test$ 部分，每部分用空行隔开。\n\n每部分有 $t$ 行，$t$ 为该组数据中战舰的数目，每行格式为\n```plain\nch x y z\n```\n表示编号为 $ch$ 的战舰的位置为 $(x,y,z)$。\n\n战舰输出顺序无关，如果有多解，输出任意解即可。", "hint": "#### 数据规模和约定\n测试点 $1\\sim3$：$n=1,n\\times m\\times k\\leqslant10$\n\n测试点 $4\\sim6$：$n=1,n\\times m\\times k\\leqslant100$\n\n测试点 $7\\sim10$：$n=1,n\\times m\\times k\\leqslant500$\n\n测试点 $11\\sim20$：$n\\times m\\times k\\leqslant1500$\n\n对于所有数据 $test\\leqslant10,t\\leqslant26$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2012] 攻占黄金乡", "background": "《海猫鸣泣之时》EP8 终于在今年暑假的末尾出了汉化，作为整个作品中高人气人物古户绘梨花，自然也是在剧中大活跃。在攻占黄金乡的战役中担任了指挥官一职，而整个战役过程也都被记录在了图书之都中，方便后来人的复盘。", "description": "当时的战况如下，黄金乡可以看做是一个长方体空间，我们用 $(0,0,0)\\sim(n-1,m-1,k-1)$ 表示里面的每一个单位区域，绘梨花指挥了 $t$ 艘不同等级的战舰依靠魔法突然出现在了黄金乡的 $t$ 个不同的区域，之后从战舰上便源源不断地涌出山羊们。每一个单位时刻，山羊们会从自己所在的区域向四周 $6$ 个方向扩展一个区域（如果那个相邻的区域已经被占领了，就不扩展），如果两队山羊在同一时刻想占领同一区域，那么等级高的山羊优先占领。\n\n没过多久，黄金乡就变成了一片山羊海，但是作为指挥官的绘梨花却因茫茫多的山羊而找不到战舰所在的位置了，于是她将问题交给了身边的你——山羊君，作为一个急于立下战功然后回故乡找山羊子的青年将领，你自然不会放弃这个机会，于是很快就找到了战舰所在的位置，你的这份功绩自然也会被记录到图书之都的文书之中。", "inputFormat": "第一行一个数 $test$，表示数据组数，以下 $test$ 部分。\n\n每部分第一行 $3$ 个数 $n,m,k$，以下 $n$ 部分，每部分为 $m$ 行 $k$ 列的字符矩阵。\n\n第 $i$ 部分表示区域 $(i,0,0)\\sim(i,m-1,k-1)$ 中的战况。\n\n不同等级的山羊我们用不同的小写英文字母表示，字典序越小的字母表示山羊等级越高。\n\n相邻部分之间用空行隔开。", "outputFormat": "输出 $test$ 部分，每部分用空行隔开。\n\n每部分有 $t$ 行，$t$ 为该组数据中战舰的数目，每行格式为\n```plain\nch x y z\n```\n表示编号为 $ch$ 的战舰的位置为 $(x,y,z)$。\n\n战舰输出顺序无关，如果有多解，输出任意解即可。", "hint": "#### 数据规模和约定\n测试点 $1\\sim3$：$n=1,n\\times m\\times k\\leqslant10$\n\n测试点 $4\\sim6$：$n=1,n\\times m\\times k\\leqslant100$\n\n测试点 $7\\sim10$：$n=1,n\\times m\\times k\\leqslant500$\n\n测试点 $11\\sim20$：$n\\times m\\times k\\leqslant1500$\n\n对于所有数据 $test\\leqslant10,t\\leqslant26$", "locale": "zh-CN"}}}
{"pid": "P5936", "type": "P", "difficulty": 6, "samples": [["4\n0 0\n1 5\n4 2\n2 6\n1 2\n5 4\n4 5\n3 1", "2\n1\n4\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["计算几何", "1999", "POI（波兰）", "Special Judge", "凸包", "构造"], "title": "[POI 1999 R2] 飞弹", "background": "一场战争在 U 国与 A 国之间爆发了。", "description": "U 国的负责情报的长官得知，A 国在边界上已经事先布置了 $N$ 个坚实的地堡，这些地堡组成的防御体系将对 U 国的士兵构成极大的威胁！U 国国防部不得不在进攻之前先摧毁这些地堡！\n\n为了出奇制胜，U 国国防部决定：布置在边界的每一个飞弹发射点负责消灭一个地堡。\n\n为了给敌人一个措手不及，$N$ 个飞弹发射点将同时发射飞弹，每个飞弹均以直线全速前进，争取在短时间内给地堡群造成毁灭性的打击。\n\n但是，由于这些飞弹是地对地电子制导型的，两颗飞弹的飞行路线如果相交，电子信号将会互相干扰，从而偏离预定目标。\n\n作为军事顾问，国防部需要你来设计一个作战方案，事先确定每个飞弹点负责哪一个地堡，并且在所设计的方案中，飞弹的飞行线路不相交。\n\n情报部门已经将飞弹发射点和地堡的位置明确标在地图上，并保证这 $2N$ 个坐标点不存在三点共线。", "inputFormat": "第一行是一个数 $N$，表示飞弹发射点的个数，也是敌方地堡的个数。\n\n以下 $N$ 行，每行两个整数 $Rx_i$ 和 $Ry_i\\ (0\\le |Rx_i|,|Ry_i|\\le 10^4)$，第 $i+1$ 行表示第 $i$ 个飞弹发射点的坐标。\n\n再下面 $N$ 行，每行两个整数 $Wx_i$ 和 $Wy_i\\ (0\\le |Wx_i|,|Wy_i|\\le 10^4)$，第 $N+i+1$ 行表示第 $i$ 个地堡的坐标。", "outputFormat": "输出文件有 $N$ 行，第 $i$ 行一个整数 $P_i$ 表示第 $i$ 个飞弹发射点负责消灭第 $P_i$ 个地堡。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 10000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 1999 R2] 飞弹", "background": "一场战争在 U 国与 A 国之间爆发了。", "description": "U 国的负责情报的长官得知，A 国在边界上已经事先布置了 $N$ 个坚实的地堡，这些地堡组成的防御体系将对 U 国的士兵构成极大的威胁！U 国国防部不得不在进攻之前先摧毁这些地堡！\n\n为了出奇制胜，U 国国防部决定：布置在边界的每一个飞弹发射点负责消灭一个地堡。\n\n为了给敌人一个措手不及，$N$ 个飞弹发射点将同时发射飞弹，每个飞弹均以直线全速前进，争取在短时间内给地堡群造成毁灭性的打击。\n\n但是，由于这些飞弹是地对地电子制导型的，两颗飞弹的飞行路线如果相交，电子信号将会互相干扰，从而偏离预定目标。\n\n作为军事顾问，国防部需要你来设计一个作战方案，事先确定每个飞弹点负责哪一个地堡，并且在所设计的方案中，飞弹的飞行线路不相交。\n\n情报部门已经将飞弹发射点和地堡的位置明确标在地图上，并保证这 $2N$ 个坐标点不存在三点共线。", "inputFormat": "第一行是一个数 $N$，表示飞弹发射点的个数，也是敌方地堡的个数。\n\n以下 $N$ 行，每行两个整数 $Rx_i$ 和 $Ry_i\\ (0\\le |Rx_i|,|Ry_i|\\le 10^4)$，第 $i+1$ 行表示第 $i$ 个飞弹发射点的坐标。\n\n再下面 $N$ 行，每行两个整数 $Wx_i$ 和 $Wy_i\\ (0\\le |Wx_i|,|Wy_i|\\le 10^4)$，第 $N+i+1$ 行表示第 $i$ 个地堡的坐标。", "outputFormat": "输出文件有 $N$ 行，第 $i$ 行一个整数 $P_i$ 表示第 $i$ 个飞弹发射点负责消灭第 $P_i$ 个地堡。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 10000$。", "locale": "zh-CN"}}}
{"pid": "P5937", "type": "P", "difficulty": 4, "samples": [["10\n5\n1 2 even\n3 4 odd\n5 6 even\n1 6 even\n7 10 odd", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["1999", "并查集", "离散化", "CEOI（中欧）"], "title": "[CEOI 1999] Parity Game", "background": "", "description": "Alice 和 Bob 在玩一个游戏：他写一个由 $0$ 和 $1$ 组成的序列。Alice 选其中的一段（比如第 $3$ 位到第 $5$ 位），问他这段里面有奇数个 $1$ 还是偶数个 $1$。Bob 回答你的问题，然后 Alice 继续问。Alice 要检查 Bob 的答案，指出在 Bob 的第几个回答一定有问题。有问题的意思就是存在一个 $01$ 序列满足这个回答前的所有回答，而且不存在序列满足这个回答前的所有回答及这个回答。", "inputFormat": "第 $1$ 行一个整数 $n$，是这个 $01$ 序列的长度。\n\n第 $2$ 行一个整数 $m$，是问题和答案的个数。\n\n第 $3$ 行开始是问题和答案，每行先有两个整数，表示你询问的段的开始位置和结束位置。然后是 Bob 的回答。`odd`表示有奇数个 $1$，`even` 表示有偶数个 $1$。", "outputFormat": "输出一行，一个数 $x$，表示存在一个 $01$ 序列满足第 $1$ 到第 $x$ 个回答，但是不存在序列满足第 $1$ 到第 $x+1$ 个回答。如果所有回答都没问题，你就输出所有回答的个数。", "hint": "对于 $100\\%$ 的数据，$1 \\le  n \\leq 10^9$，$m \\leq 5 \\times 10^3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 1999] Parity Game", "background": "", "description": "Alice 和 Bob 在玩一个游戏：他写一个由 $0$ 和 $1$ 组成的序列。Alice 选其中的一段（比如第 $3$ 位到第 $5$ 位），问他这段里面有奇数个 $1$ 还是偶数个 $1$。Bob 回答你的问题，然后 Alice 继续问。Alice 要检查 Bob 的答案，指出在 Bob 的第几个回答一定有问题。有问题的意思就是存在一个 $01$ 序列满足这个回答前的所有回答，而且不存在序列满足这个回答前的所有回答及这个回答。", "inputFormat": "第 $1$ 行一个整数 $n$，是这个 $01$ 序列的长度。\n\n第 $2$ 行一个整数 $m$，是问题和答案的个数。\n\n第 $3$ 行开始是问题和答案，每行先有两个整数，表示你询问的段的开始位置和结束位置。然后是 Bob 的回答。`odd`表示有奇数个 $1$，`even` 表示有偶数个 $1$。", "outputFormat": "输出一行，一个数 $x$，表示存在一个 $01$ 序列满足第 $1$ 到第 $x$ 个回答，但是不存在序列满足第 $1$ 到第 $x+1$ 个回答。如果所有回答都没问题，你就输出所有回答的个数。", "hint": "对于 $100\\%$ 的数据，$1 \\le  n \\leq 10^9$，$m \\leq 5 \\times 10^3$。", "locale": "zh-CN"}}}
{"pid": "P5938", "type": "P", "difficulty": 0, "samples": [["6\n1 7 4 1 E\n3 9 11 8 S\n6 7 10 4 N\n8 3 10 1 N\n11 4 13 1 E\n14 8 20 7 W", "1\n2\n5\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["1999", "POI（波兰）"], "title": "[POI 1999 R3] 祭坛问题", "background": "在中国民间，人们相信鬼只能沿直线移动。\n\n在修建寺庙时，那是非常重要的。", "description": "寺庙要修建在四边分别平行于南北西东的矩形位置之上。两个矩形不能有公共交点。入口位于四堵墙中一堵的中间，门的宽度等于墙长度的一半。祭坛出现在寺庙的中间，矩形的对角线在那里相交。\n\n鬼魂在这个点出现，那么寺庙被亵渎，当且仅当存在从祭坛射出的一束光线，通过入口到外面而且不与其他寺庙（位于建筑区域平行的地带）的墙壁相交或接触，这种情形才可能发生，也就是能在建筑区域从祭坛到无穷远处画一条直线而不碰到任何墙。", "inputFormat": "第一行输入一个整数 $n$。\n\n接下来 $n$ 行，第 $i+1$ 行有第 $i$ 个寺庙的描述。寺庙的描述由四个非负的不大于 $8000$ 的整数（前两个数字是寺庙的西北角的坐标，后两个是相对的东南角的坐标）和一个字母 `E`,`W`,`S` 或 `N`（入口所在的墙的方位）组成（`E`-东，`W`-西，`S`-南，`N`-北）。两两之间由单空格隔开。", "outputFormat": "接下来的几行，你的程序应该按升序写下可能被鬼魂亵渎的寺庙编号。每一个编号占一行。如果没有编号则输出 `BRAK`。", "hint": "### 样例解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/uacmj7y9.png)\n\n### 数据范围\n对于 $100\\%$ 的数据，$1 \\le n \\le 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 1999 R3] 祭坛问题", "background": "在中国民间，人们相信鬼只能沿直线移动。\n\n在修建寺庙时，那是非常重要的。", "description": "寺庙要修建在四边分别平行于南北西东的矩形位置之上。两个矩形不能有公共交点。入口位于四堵墙中一堵的中间，门的宽度等于墙长度的一半。祭坛出现在寺庙的中间，矩形的对角线在那里相交。\n\n鬼魂在这个点出现，那么寺庙被亵渎，当且仅当存在从祭坛射出的一束光线，通过入口到外面而且不与其他寺庙（位于建筑区域平行的地带）的墙壁相交或接触，这种情形才可能发生，也就是能在建筑区域从祭坛到无穷远处画一条直线而不碰到任何墙。", "inputFormat": "第一行输入一个整数 $n$。\n\n接下来 $n$ 行，第 $i+1$ 行有第 $i$ 个寺庙的描述。寺庙的描述由四个非负的不大于 $8000$ 的整数（前两个数字是寺庙的西北角的坐标，后两个是相对的东南角的坐标）和一个字母 `E`,`W`,`S` 或 `N`（入口所在的墙的方位）组成（`E`-东，`W`-西，`S`-南，`N`-北）。两两之间由单空格隔开。", "outputFormat": "接下来的几行，你的程序应该按升序写下可能被鬼魂亵渎的寺庙编号。每一个编号占一行。如果没有编号则输出 `BRAK`。", "hint": "### 样例解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/uacmj7y9.png)\n\n### 数据范围\n对于 $100\\%$ 的数据，$1 \\le n \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P5939", "type": "P", "difficulty": 4, "samples": [["5\n2 3\n3 4\n4 5\n1 6\n12 27", "3"], ["6\n1 6\n10 8\n1 5\n2 20\n4 4\n6 2", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["1998", "POI（波兰）"], "title": "[POI 1998 R3] 折线", "background": null, "description": "给定二维直角坐标系。\n\n我们要求一条折线只能从左边到右边一笔画过去，并且折线的每一段和 $x$ 轴的夹角在 $[-45^\\circ, 45^\\circ]$ 之间。\n\n一条满足上述要求的折线被称为平直折线。\n\n给定坐标系上的 $n$ 个格点，最少需要画多少条平直折线才能覆盖所有的点呢？", "inputFormat": "第一行一个正整数 $n$，表示点的数目。\n\n接下来 $n$ 行，每行两个整数 $x_i,y_i$，表示第 $i$ 个点的坐标。", "outputFormat": "仅一行一个整数，表示最少需要的平直折线数量。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 30000$，$0\\le x_i,y_i\\le 30000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 1998 R3] 折线", "background": null, "description": "给定二维直角坐标系。\n\n我们要求一条折线只能从左边到右边一笔画过去，并且折线的每一段和 $x$ 轴的夹角在 $[-45^\\circ, 45^\\circ]$ 之间。\n\n一条满足上述要求的折线被称为平直折线。\n\n给定坐标系上的 $n$ 个格点，最少需要画多少条平直折线才能覆盖所有的点呢？", "inputFormat": "第一行一个正整数 $n$，表示点的数目。\n\n接下来 $n$ 行，每行两个整数 $x_i,y_i$，表示第 $i$ 个点的坐标。", "outputFormat": "仅一行一个整数，表示最少需要的平直折线数量。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 30000$，$0\\le x_i,y_i\\le 30000$。", "locale": "zh-CN"}}}
{"pid": "P5940", "type": "P", "difficulty": 6, "samples": [["2\n0 5\n3 3", "-4 -1 1 3 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["1997", "POI（波兰）"], "title": "[POI 1997] 跳", "background": "在一个无限长的棋盘上玩一种跳棋游戏。", "description": "其中棋盘被划分成许多区域，每一个区域中可以放置多个的棋子。\n\n规定某一个区域的编号为 $0$，在它开始往左边连续的区域编号为 $-1,-2,-3,…,$在它的右边连续区域编号为 $1,2,3,…,$ ，若区域 $P$ 有棋子，那么棋子有两种跳法：\n\n- 向左跳：则方格 $P-1$ 和 $ P-2 $ 中应增加一枚棋子，方格 $P$ 中应减少一枚棋子。 \n\n- 向右跳：则方格 $P$ 和 $P+1$ 中应减少一枚棋子，方格 $P+2$ 中应增加一枚棋子。\n\n对于给定的初始棋局，经过若干步跳棋后，总可以找到一种目标，就是任意两个相邻的区域棋子数目不超过 $1$ 。\n\n你的任务是对给定的一种初始棋局，找到最终的目标棋局。", "inputFormat": "第一行为一个正整数 $n$， 表示棋盘中放置棋子的状态数。\n\n下面的 $n$ 行描述了每个状态，由两个用空格分隔的整数组成，第一个整数表示区域的位置（不超过 $10^4$），第二个整数表示该区域放置的棋子数目（不超过 $10^8$）。", "outputFormat": "输出最终的棋局，这一行包含若干个整数，其中每一个整数为有棋子的区域编号，所有的区域按从小到大排列。", "hint": "对于 $100\\%$ 的数据，$1\\le n \\le 10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 1997] 跳", "background": "在一个无限长的棋盘上玩一种跳棋游戏。", "description": "其中棋盘被划分成许多区域，每一个区域中可以放置多个的棋子。\n\n规定某一个区域的编号为 $0$，在它开始往左边连续的区域编号为 $-1,-2,-3,…,$在它的右边连续区域编号为 $1,2,3,…,$ ，若区域 $P$ 有棋子，那么棋子有两种跳法：\n\n- 向左跳：则方格 $P-1$ 和 $ P-2 $ 中应增加一枚棋子，方格 $P$ 中应减少一枚棋子。 \n\n- 向右跳：则方格 $P$ 和 $P+1$ 中应减少一枚棋子，方格 $P+2$ 中应增加一枚棋子。\n\n对于给定的初始棋局，经过若干步跳棋后，总可以找到一种目标，就是任意两个相邻的区域棋子数目不超过 $1$ 。\n\n你的任务是对给定的一种初始棋局，找到最终的目标棋局。", "inputFormat": "第一行为一个正整数 $n$， 表示棋盘中放置棋子的状态数。\n\n下面的 $n$ 行描述了每个状态，由两个用空格分隔的整数组成，第一个整数表示区域的位置（不超过 $10^4$），第二个整数表示该区域放置的棋子数目（不超过 $10^8$）。", "outputFormat": "输出最终的棋局，这一行包含若干个整数，其中每一个整数为有棋子的区域编号，所有的区域按从小到大排列。", "hint": "对于 $100\\%$ 的数据，$1\\le n \\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P5941", "type": "P", "difficulty": 2, "samples": [["14\n5\n10\n12\n15\n17\n20\n21\n22\n24\n26\n27\n30\n31\n33", "24\n5\n12\n21"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["1997", "POI（波兰）"], "title": "[POI 1997] ADDON", "background": "科学家们发现了一种新的放射性元素——`ADDON`。`ADDON` 是已知的效率最高的核燃料，因此他们决定建立一个 `ADDON` 核反应堆。", "description": "根据计划，一间燃料室是一根竖直的管子。燃料棒（即装有 `ADDON` 的圆筒）将一根叠一根的被放进燃料室里，搭建成一个圆柱。燃料棒具有不同的高度。\n\n核反应循环开始于将燃料棒放进燃料室中。接下来的步骤才是点火。麻烦的是，圆柱的高度不能是任意的——只有某些特定的高度才能保证反应的安全。这样的高度被称作稳定高度。\n\n现在，反应堆的设计师们面临着两个任务：确定燃料室的高度以及选择一个用于制造 `ADDON` 的燃料棒的高度集合。\n\n我们说一个高度集合是安全的（对于一个特定高度的燃料室），则有：\n\n- 对于任意一根由高度属于这个集合的燃料棒搭建而成的，且高度不超过燃料室的高度的圆柱，它的高度一定是稳定的。\n\n\n我们说一个高度集合是完备的（对于一个特定高度的燃料室），则有：\n\n- 对于任意一根高度是稳定的,并且其高度不超过燃料室高度的圆柱，都一定能够由高度属于该集合的燃料棒搭建而成。\n\n\n现在要写一个程序：\n- 1. 读入一个稳定高度的集合；\n- 2. 找出存在一个安全且完备的高度集合的核燃料室的最大可能值；\n- 3. 对于找到的核燃料室，找出一个元素个数最少的安全且完备的高度集合；\n- 4. 将结果输出。", "inputFormat": "第一行是一个自然数 $n$，代表所给的稳定高度的个数。\n\n接下来的 $n$ 行，每行是一个不超过 $10000$ 的正整数。这些数按照升序给出，代表了稳定高度。", "outputFormat": "第一行是找到的燃料室高度的最大可能值。\n\n接下来的每行按照升序给出你所找到的高度集合中的一个元素。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le10000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 1997] ADDON", "background": "科学家们发现了一种新的放射性元素——`ADDON`。`ADDON` 是已知的效率最高的核燃料，因此他们决定建立一个 `ADDON` 核反应堆。", "description": "根据计划，一间燃料室是一根竖直的管子。燃料棒（即装有 `ADDON` 的圆筒）将一根叠一根的被放进燃料室里，搭建成一个圆柱。燃料棒具有不同的高度。\n\n核反应循环开始于将燃料棒放进燃料室中。接下来的步骤才是点火。麻烦的是，圆柱的高度不能是任意的——只有某些特定的高度才能保证反应的安全。这样的高度被称作稳定高度。\n\n现在，反应堆的设计师们面临着两个任务：确定燃料室的高度以及选择一个用于制造 `ADDON` 的燃料棒的高度集合。\n\n我们说一个高度集合是安全的（对于一个特定高度的燃料室），则有：\n\n- 对于任意一根由高度属于这个集合的燃料棒搭建而成的，且高度不超过燃料室的高度的圆柱，它的高度一定是稳定的。\n\n\n我们说一个高度集合是完备的（对于一个特定高度的燃料室），则有：\n\n- 对于任意一根高度是稳定的,并且其高度不超过燃料室高度的圆柱，都一定能够由高度属于该集合的燃料棒搭建而成。\n\n\n现在要写一个程序：\n- 1. 读入一个稳定高度的集合；\n- 2. 找出存在一个安全且完备的高度集合的核燃料室的最大可能值；\n- 3. 对于找到的核燃料室，找出一个元素个数最少的安全且完备的高度集合；\n- 4. 将结果输出。", "inputFormat": "第一行是一个自然数 $n$，代表所给的稳定高度的个数。\n\n接下来的 $n$ 行，每行是一个不超过 $10000$ 的正整数。这些数按照升序给出，代表了稳定高度。", "outputFormat": "第一行是找到的燃料室高度的最大可能值。\n\n接下来的每行按照升序给出你所找到的高度集合中的一个元素。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le10000$。", "locale": "zh-CN"}}}
{"pid": "P5942", "type": "P", "difficulty": 2, "samples": [["5\n1\n2\n3\n4\n5", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2002", "POI（波兰）"], "title": "[POI 2002] 敌对球迷", "background": "在一个信息王国里决定在两个敌对的球队： LINUKS 和 MICROSOFT 之间举行球赛。", "description": "由于两个球队的球迷结怨甚深，所以要将他们安排在两个距离尽量遥远的城市里，而且只允许他们从电视中看球赛。\n\n信息王国是个岛国，它所有的城市都建在海岸上。沿着海岛周边有一条双向的环行公路。有两种方法可以从每一个城市到达另一个城市：顺时针和逆时针方向。这种双向环行公路方案中较短的距离是城市之间的距离。\n\n现在，你需要计算出把敌对球迷分隔的最大距离。", "inputFormat": "第一行输入一个正整数 $n$，表示海岛上城市的数目。\n\n在接下来的 $n$ 行中输入相邻城市间环行公路的长度。每一行中包含了一个整数。\n\n第 $i+1$ 行为 $i$ 的城市和编号为 $i+1$ 的城市之间公路段的长度，第 $n+1$ 行为城市 $n$ 和城市 $1$ 之间路程的长度。\n环行公路的总长度不超过 $10^9$。", "outputFormat": "一行一个数表示可以将球迷分隔的最大距离。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 50 000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2002] 敌对球迷", "background": "在一个信息王国里决定在两个敌对的球队： LINUKS 和 MICROSOFT 之间举行球赛。", "description": "由于两个球队的球迷结怨甚深，所以要将他们安排在两个距离尽量遥远的城市里，而且只允许他们从电视中看球赛。\n\n信息王国是个岛国，它所有的城市都建在海岸上。沿着海岛周边有一条双向的环行公路。有两种方法可以从每一个城市到达另一个城市：顺时针和逆时针方向。这种双向环行公路方案中较短的距离是城市之间的距离。\n\n现在，你需要计算出把敌对球迷分隔的最大距离。", "inputFormat": "第一行输入一个正整数 $n$，表示海岛上城市的数目。\n\n在接下来的 $n$ 行中输入相邻城市间环行公路的长度。每一行中包含了一个整数。\n\n第 $i+1$ 行为 $i$ 的城市和编号为 $i+1$ 的城市之间公路段的长度，第 $n+1$ 行为城市 $n$ 和城市 $1$ 之间路程的长度。\n环行公路的总长度不超过 $10^9$。", "outputFormat": "一行一个数表示可以将球迷分隔的最大距离。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 50 000$。", "locale": "zh-CN"}}}
{"pid": "P5943", "type": "P", "difficulty": 4, "samples": [["5\n0 1 0 1 0\n0 0 0 0 0\n0 0 0 0 1\n1 0 0 0 0\n0 1 0 0 0", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2002", "POI（波兰）"], "title": "[POI 2002] 最大的园地", "background": "", "description": "在一个 $n\\times n$ 的正方形内找到最大的由 `0` 组成的矩形，输出它的面积。", "inputFormat": "输入的第一行为一个整数 $n$。\n\n接下来的 $n$ 行，每行 $n$ 个数，描述这个正方形。", "outputFormat": "输出其中最大的由 `0` 组成的矩形的面积。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 2000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2002] 最大的园地", "background": "", "description": "在一个 $n\\times n$ 的正方形内找到最大的由 `0` 组成的矩形，输出它的面积。", "inputFormat": "输入的第一行为一个整数 $n$。\n\n接下来的 $n$ 行，每行 $n$ 个数，描述这个正方形。", "outputFormat": "输出其中最大的由 `0` 组成的矩形的面积。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 2000$。", "locale": "zh-CN"}}}
{"pid": "P5944", "type": "P", "difficulty": 6, "samples": [["4\n1 4 3 2", "NIE"], ["4\n1 4 2 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2002", "POI（波兰）"], "title": "[POI 2002] 出圈游戏", "background": "", "description": "有编号从 $1$ 到 $n$ 的 $n$ 个小朋友在玩一种出圈的游戏,编号为 $i+1 $ 的小朋友站在编号为 $i $ 小朋友左边。编号为 $1 $ 的小朋友站在编号为 $n$ 的小朋友左边。首先编号为 $1$ 的小朋友开始报数，接着站在左边的小朋友顺序报数，直到数到某个数字 $K$ 时就出圈。直到所有的小朋友都出圈，则游戏完毕。\n\n现在给出出圈的顺序，求最小的 $K$。", "inputFormat": "第一行有一个正整数 $n$。\n\n第二行有 $n$ 个整数 $a_i$。其中第 $i$ 个整数表示编号为 $i$ 的小朋友第 $a_i$ 个出圈。", "outputFormat": "求最小的 $K$，如果不存在，则输出一个单词 `NIE`。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 20$。\n\n---\n\n$\\text{upd 2022.8.24}$：新增加一组 Hack 数据。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2002] 出圈游戏", "background": "", "description": "有编号从 $1$ 到 $n$ 的 $n$ 个小朋友在玩一种出圈的游戏,编号为 $i+1 $ 的小朋友站在编号为 $i $ 小朋友左边。编号为 $1 $ 的小朋友站在编号为 $n$ 的小朋友左边。首先编号为 $1$ 的小朋友开始报数，接着站在左边的小朋友顺序报数，直到数到某个数字 $K$ 时就出圈。直到所有的小朋友都出圈，则游戏完毕。\n\n现在给出出圈的顺序，求最小的 $K$。", "inputFormat": "第一行有一个正整数 $n$。\n\n第二行有 $n$ 个整数 $a_i$。其中第 $i$ 个整数表示编号为 $i$ 的小朋友第 $a_i$ 个出圈。", "outputFormat": "求最小的 $K$，如果不存在，则输出一个单词 `NIE`。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 20$。\n\n---\n\n$\\text{upd 2022.8.24}$：新增加一组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P5945", "type": "P", "difficulty": 5, "samples": [["2 20 4 3", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2002", "POI（波兰）"], "title": "[POI 2002] 协议", "background": "Z 在一个通讯公司工作。 目前他承担了公司的网络协议设计任务。", "description": "目前他致力于通过一条电缆从一台电脑向另一台电脑发送数据。\n\n在这条电缆中有 $k$ 种不同的电平， 每秒电平会变化 $\\frac{1}{n}$ 次 (我们称 $\\frac{1}{n}$ 秒为一个脉冲)。 一个数据包包含 $m$ 个连续的脉冲。(即每 $\\frac{m}{n}$ 秒发送一个数据包)。\n\n由于技术原因, 每个包里的电平不能一直稳定为一个常数, 而是需要多次改变。 严格地讲, 包含连续 $l$ 个电平相同的脉冲的数据包将不能被发送。 注意相邻两个数据包互不影响。\n\n如果可能被发送的数据包共有 $x$ 种， 那么单个数据包会包含 $\\log_2x$ 位信息(可以为一个小数)。Z 想知道在 $1$ 秒内最多能发送多少位信息。", "inputFormat": "输入一行四个整数：电平种类 $k$， 脉冲频率 $n$， 单个数据包大小 $m$， 在一个数据包中不能连续保持相同电平的脉冲的数目 $l$， 在这个范围内电平至少要改变一次。", "outputFormat": "输出一个整数，为一秒内最大能发送信息的位数，答案向下取整。", "hint": "对于 $100\\%$ 的数据，$2 \\le k \\le 10$，$1 \\le n \\le 1000$，$ 1 \\le m \\le 100$，$2 \\le l \\le m$，$\\frac{n}{m}$ 是一个不超过 $10$ 的整数。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2002] 协议", "background": "Z 在一个通讯公司工作。 目前他承担了公司的网络协议设计任务。", "description": "目前他致力于通过一条电缆从一台电脑向另一台电脑发送数据。\n\n在这条电缆中有 $k$ 种不同的电平， 每秒电平会变化 $\\frac{1}{n}$ 次 (我们称 $\\frac{1}{n}$ 秒为一个脉冲)。 一个数据包包含 $m$ 个连续的脉冲。(即每 $\\frac{m}{n}$ 秒发送一个数据包)。\n\n由于技术原因, 每个包里的电平不能一直稳定为一个常数, 而是需要多次改变。 严格地讲, 包含连续 $l$ 个电平相同的脉冲的数据包将不能被发送。 注意相邻两个数据包互不影响。\n\n如果可能被发送的数据包共有 $x$ 种， 那么单个数据包会包含 $\\log_2x$ 位信息(可以为一个小数)。Z 想知道在 $1$ 秒内最多能发送多少位信息。", "inputFormat": "输入一行四个整数：电平种类 $k$， 脉冲频率 $n$， 单个数据包大小 $m$， 在一个数据包中不能连续保持相同电平的脉冲的数目 $l$， 在这个范围内电平至少要改变一次。", "outputFormat": "输出一个整数，为一秒内最大能发送信息的位数，答案向下取整。", "hint": "对于 $100\\%$ 的数据，$2 \\le k \\le 10$，$1 \\le n \\le 1000$，$ 1 \\le m \\le 100$，$2 \\le l \\le m$，$\\frac{n}{m}$ 是一个不超过 $10$ 的整数。\n", "locale": "zh-CN"}}}
{"pid": "P5946", "type": "P", "difficulty": 5, "samples": [["30 10 5", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2002", "POI（波兰）"], "title": "[POI 2002] B-Smooth 数", "background": "", "description": "$B$ 是一个正整数。\n\n 如果一个自然数 $n$ 被称为 B-smooth 数,那么它的质因子中没有任何一个超过 $B$。 \n\n我们说和 $n$ 等价的一个 B-smooth 数是指它能够表示成小于或等于  $B$ 的正整数乘积。 \n\n你的任务是对给定的闭区间 $[n,n+m]$，求出他们中的 B-smooth 数的个数。", "inputFormat": "第一行是三个整数 $n,m$ 和 $B$。", "outputFormat": "求出 B-smooth 数的个数。", "hint": "对于 $100\\%$的数据，$1\\le n\\le 2\\times 10^9$， $1\\le m\\le 10^8$， $1\\le B\\le 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2002] B-Smooth 数", "background": "", "description": "$B$ 是一个正整数。\n\n 如果一个自然数 $n$ 被称为 B-smooth 数,那么它的质因子中没有任何一个超过 $B$。 \n\n我们说和 $n$ 等价的一个 B-smooth 数是指它能够表示成小于或等于  $B$ 的正整数乘积。 \n\n你的任务是对给定的闭区间 $[n,n+m]$，求出他们中的 B-smooth 数的个数。", "inputFormat": "第一行是三个整数 $n,m$ 和 $B$。", "outputFormat": "求出 B-smooth 数的个数。", "hint": "对于 $100\\%$的数据，$1\\le n\\le 2\\times 10^9$， $1\\le m\\le 10^8$， $1\\le B\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P5947", "type": "P", "difficulty": 5, "samples": [["5\n2 0\n7 4\n4 5\n5 3\n8 15", "1\n2\n1\n0\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2003", "POI（波兰）"], "title": "[POI 2003] Trinomial", "background": "", "description": "求 $(x^2+x+1)^n$ 的第 $i$ 项系数。", "inputFormat": "第一行一个数 $k$ 表示数据的组数。\n\n接下来的 $k$ 行，每行两个整数 $n,i$。\n\n", "outputFormat": "对于每组数据，输出 $x_i \\bmod 3$ 之后的结果。\n", "hint": "对于 $100\\%$ 的数据，$1 \\le k \\le 10000$，$0\\le n\\le 10^{15}$，$0\\le i\\le 2\\times n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2003] Trinomial", "background": "", "description": "求 $(x^2+x+1)^n$ 的第 $i$ 项系数。", "inputFormat": "第一行一个数 $k$ 表示数据的组数。\n\n接下来的 $k$ 行，每行两个整数 $n,i$。\n\n", "outputFormat": "对于每组数据，输出 $x_i \\bmod 3$ 之后的结果。\n", "hint": "对于 $100\\%$ 的数据，$1 \\le k \\le 10000$，$0\\le n\\le 10^{15}$，$0\\le i\\le 2\\times n$。", "locale": "zh-CN"}}}
{"pid": "P5948", "type": "P", "difficulty": 4, "samples": [["6 4\n2\n1\n3\n1\n4\n4\n1\n2", "42\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2003", "POI（波兰）", "排序"], "title": "[POI 2003 R1] Chocolate", "background": null, "description": "有一块 $n\\times m$ 的矩形巧克力，准备将它切成 $n\\times m$ 块。\n\n巧克力上共有 $n-1$ 条横线和 $m-1$ 条竖线，你每次可以沿着其中的一条横线或竖线将巧克力切开，无论切割的长短，沿着每条横线切一次的代价依次为 $y_1,y_2,\\dots,y_{n-1}$，而沿竖线切割的代价依次为 $x_1,x_2,\\dots,x_{m-1}$。\n\n例如，对于下图 $6\\times 4$ 的巧克力：\n![](https://cdn.luogu.com.cn/upload/image_hosting/s0j2oloj.png)\n\n我们先沿着三条横线切割，需要 $3$ 刀，得到 $4$ 条巧克力，然后再将这 $4$ 条巧克力沿竖线切割，每条都需要 $5$ 刀，则最终所花费的代价为 $y_1+y_2+y_3+4\\times (x_1+x_2+x_3+x_4+x_5)$。\n\n当然，上述简单切法不见得是最优切法，那么怎样切割该块巧克力，花费的代价最少呢？", "inputFormat": "第一行为两个整数 $n$ 和 $m$。\n\n接下来 $n-1$ 行，每行一个整数，分别代表 $x_1,x_2,\\dots,x_{n-1}$。\n\n接下来 $m-1$ 行，每行一个整数，分别代表 $y_1,y_2,\\dots,y_{m-1}$。", "outputFormat": "输出一整数，为切割巧克力的最小代价。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10000$，$1\\le m\\le 10000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2003 R1] Chocolate", "background": null, "description": "有一块 $n\\times m$ 的矩形巧克力，准备将它切成 $n\\times m$ 块。\n\n巧克力上共有 $n-1$ 条横线和 $m-1$ 条竖线，你每次可以沿着其中的一条横线或竖线将巧克力切开，无论切割的长短，沿着每条横线切一次的代价依次为 $y_1,y_2,\\dots,y_{n-1}$，而沿竖线切割的代价依次为 $x_1,x_2,\\dots,x_{m-1}$。\n\n例如，对于下图 $6\\times 4$ 的巧克力：\n![](https://cdn.luogu.com.cn/upload/image_hosting/s0j2oloj.png)\n\n我们先沿着三条横线切割，需要 $3$ 刀，得到 $4$ 条巧克力，然后再将这 $4$ 条巧克力沿竖线切割，每条都需要 $5$ 刀，则最终所花费的代价为 $y_1+y_2+y_3+4\\times (x_1+x_2+x_3+x_4+x_5)$。\n\n当然，上述简单切法不见得是最优切法，那么怎样切割该块巧克力，花费的代价最少呢？", "inputFormat": "第一行为两个整数 $n$ 和 $m$。\n\n接下来 $n-1$ 行，每行一个整数，分别代表 $x_1,x_2,\\dots,x_{n-1}$。\n\n接下来 $m-1$ 行，每行一个整数，分别代表 $y_1,y_2,\\dots,y_{m-1}$。", "outputFormat": "输出一整数，为切割巧克力的最小代价。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10000$，$1\\le m\\le 10000$。", "locale": "zh-CN"}}}
{"pid": "P5949", "type": "P", "difficulty": 2, "samples": [["2\n4\n1\n2\n1\n2\n3\n1\n2\n3", "YES\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2000", "BalticOI（波罗的海）"], "title": "[BalticOI 2000] Division expression", "background": "", "description": "除法表达式有如下的形式:  \n\n$X_1/X_2/X_3.../X_n$ ，其中 $X_i$ 是正整数且 $X_i\\le 10^9$， 除法表达式应当按照从左到右的顺序求。\n\n例如表达式 $1/2/1/2$的值为 $1/4$。\n\n但可以在表达式中加入括号来改变计算顺序，例如 $(1/2)/(1/2)$ 的值为 $1$.现给出一个除法表达式 $E$，求是告诉是否可以通过增加括号来使其结果为整数。", "inputFormat": "第一行一个整数 $D$，代表有 $D$ 组数据。\n\n每组数据先给出一个数字 $N$，代表这组数据将有 $N$ 个数。\n\n接下来每行有 $N$ 个数。", "outputFormat": "如果能使得表达式的值为一个整数，则输出 `YES` ，否则为`NO`。", "hint": "对于 $100\\%$ 的数据，$1\\le D\\le10$，$1\\le n\\le10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2000] Division expression", "background": "", "description": "除法表达式有如下的形式:  \n\n$X_1/X_2/X_3.../X_n$ ，其中 $X_i$ 是正整数且 $X_i\\le 10^9$， 除法表达式应当按照从左到右的顺序求。\n\n例如表达式 $1/2/1/2$的值为 $1/4$。\n\n但可以在表达式中加入括号来改变计算顺序，例如 $(1/2)/(1/2)$ 的值为 $1$.现给出一个除法表达式 $E$，求是告诉是否可以通过增加括号来使其结果为整数。", "inputFormat": "第一行一个整数 $D$，代表有 $D$ 组数据。\n\n每组数据先给出一个数字 $N$，代表这组数据将有 $N$ 个数。\n\n接下来每行有 $N$ 个数。", "outputFormat": "如果能使得表达式的值为一个整数，则输出 `YES` ，否则为`NO`。", "hint": "对于 $100\\%$ 的数据，$1\\le D\\le10$，$1\\le n\\le10^4$。", "locale": "zh-CN"}}}
{"pid": "P5950", "type": "P", "difficulty": 6, "samples": [["3 4 5 4 3 4 5 4 3 4", "49999999499999999949999999973"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2000", "字典树 Trie", "BalticOI（波罗的海）"], "title": "[BalticOI 2000] Stickers", "background": "", "description": "Charles 在商店里买了很多很多盒装的不干胶，所有不干胶上都印着 $0-9$ 中的某个数字。\n\n每个盒里装的各种不干胶数目都一样：有 $i_0$个数字 $0$，$ i_1$ 个数字 $1 ,…,i_9$ 个数字 $9$，且每盒中各种数字的不干胶数目都不超过 $9$。\n\n最开始，所有的盒子都是关着的，Charles 每次打开一个新的盒子，然后从已经打开的盒子中取出需要的不干胶拼成一个数，第一次拼成 $1$ ，第二次拼成 $2$ …第N次拼成 $N$ 。为了拼成数 $N$，Charles需要为N的每一个数字使用一张不干胶。\n\n例如，再打开第 $2070$ 的盒子以后，为了拼成数 $2070$ ，它需要从已经打开的盒子（无论是以前打开的还是这次打开的）中取出一个 $2$，两个 $0$ 和一个 $7$。\n\n取出的不干胶可以在之后使用。如果某次打开了一个盒子以后无法拼成相应的数，Charles 就停止工作。给出 $i_0,i_1,i_2,…,i_9$ 的值，编程计算 Charles 一共能拼出多少个数。例如，如果每盒中有各种数字的不干胶恰一张，则 Charles 一共可以拼出 $199990$ 个数。", "inputFormat": "输入包含 $10$ 个 $1$ 位整数：$i_0, i_1, i_2, i_3, i_4, i_5, i_6, i_7, i_8, i_9$，其中 $i_j$ 表示在每个盒子中，写着数字 $j$ 的不干胶的数目。", "outputFormat": "输出能拼出多少个数。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2000] Stickers", "background": "", "description": "Charles 在商店里买了很多很多盒装的不干胶，所有不干胶上都印着 $0-9$ 中的某个数字。\n\n每个盒里装的各种不干胶数目都一样：有 $i_0$个数字 $0$，$ i_1$ 个数字 $1 ,…,i_9$ 个数字 $9$，且每盒中各种数字的不干胶数目都不超过 $9$。\n\n最开始，所有的盒子都是关着的，Charles 每次打开一个新的盒子，然后从已经打开的盒子中取出需要的不干胶拼成一个数，第一次拼成 $1$ ，第二次拼成 $2$ …第N次拼成 $N$ 。为了拼成数 $N$，Charles需要为N的每一个数字使用一张不干胶。\n\n例如，再打开第 $2070$ 的盒子以后，为了拼成数 $2070$ ，它需要从已经打开的盒子（无论是以前打开的还是这次打开的）中取出一个 $2$，两个 $0$ 和一个 $7$。\n\n取出的不干胶可以在之后使用。如果某次打开了一个盒子以后无法拼成相应的数，Charles 就停止工作。给出 $i_0,i_1,i_2,…,i_9$ 的值，编程计算 Charles 一共能拼出多少个数。例如，如果每盒中有各种数字的不干胶恰一张，则 Charles 一共可以拼出 $199990$ 个数。", "inputFormat": "输入包含 $10$ 个 $1$ 位整数：$i_0, i_1, i_2, i_3, i_4, i_5, i_6, i_7, i_8, i_9$，其中 $i_j$ 表示在每个盒子中，写着数字 $j$ 的不干胶的数目。", "outputFormat": "输出能拼出多少个数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5951", "type": "P", "difficulty": 2, "samples": [["100 10 500\n1\n1 0.5", "5.0050000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2003", "Special Judge", "BalticOI（波罗的海）"], "title": "[BalticOI 2003] Barrel", "background": "大水池子。\n", "description": "给定一个水池的底面积 $S$ 和高 $H$。\n\n现在其中有体积为 $V$ 的水量，放入 $n$ 个立方体，给出每个立方体的棱长和密度，请你求出水池中水池的高度。\n\n注：此处我们忽视空气的任何作用力， 认为正方体之间互不接触且不会在水中旋转， 且认为水的密度为 $1$。", "inputFormat": "第一行三个整数 $S,H,V$。\n\n第二行为一个整数 $n$。\n\n接下来的 $n$ 行，每行两个实数，为这个立方体的棱长和密度。", "outputFormat": "输出最终水面的高度。答案误差不超过 $10^{-7}$ 即可。", "hint": "对于 $100\\%$ 的数据，$1\\le S,H,V\\le10000$，$1\\le n\\le 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2003] Barrel", "background": "大水池子。\n", "description": "给定一个水池的底面积 $S$ 和高 $H$。\n\n现在其中有体积为 $V$ 的水量，放入 $n$ 个立方体，给出每个立方体的棱长和密度，请你求出水池中水池的高度。\n\n注：此处我们忽视空气的任何作用力， 认为正方体之间互不接触且不会在水中旋转， 且认为水的密度为 $1$。", "inputFormat": "第一行三个整数 $S,H,V$。\n\n第二行为一个整数 $n$。\n\n接下来的 $n$ 行，每行两个实数，为这个立方体的棱长和密度。", "outputFormat": "输出最终水面的高度。答案误差不超过 $10^{-7}$ 即可。", "hint": "对于 $100\\%$ 的数据，$1\\le S,H,V\\le10000$，$1\\le n\\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P5952", "type": "P", "difficulty": 5, "samples": [["3 2 2\n1\n1\n1\n1 2\n1 1", "65\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "POI（波兰）", "生成树"], "title": "[POI 2018] 水箱", "background": "", "description": "在地面上有一个水箱，它的俯视图被划分成了 $n$ 行 $m$ 列个方格，相邻两个方格之间有一堵厚度可以忽略不计的墙，水箱与外界之间有一堵高度无穷大的墙，因此水不可能漏到外面。已知水箱内每个格子的高度只能是 $[0,H]$ 之间的整数，请统计有多少可能的水位情况。\n\n因为答案可能很大，请对 $10^9+7$ 取模输出。\n\n我们说两种情况是不同的当且仅当存在至少一个方格的水位在两个情况中不同。", "inputFormat": "第一行包含三个正整数 $n,m,H$。\n接下来 $n$ 行，每行 $m-1$ 个整数$ a[i][j](1\\le a[i][j]\\le H)$，表示 $(i,j)$ 和 $(i,j+1)$ 之间的墙的高度。\n\n接下来 $n-1$ 行，每行 $m$ 个整数 $b[i][j](1\\le b[i][j]\\le H)$ ，表示 $(i,j)$ 和 $(i+1,j)$ 之间的墙的高度。", "outputFormat": "输出一行一个整数，即方案数模 $10^9+7$ 的结果。", "hint": "对于 $100\\%$ 的数据，$n\\times m\\le500000$，$1\\le H\\le10^9$。\n\n----\n\n### 样例解释：\n\n要么全部格子水位都是 $2$，要么全部格子水位都在 $[0,1]$ 之间，共 $1+2^6=65$ 种情况。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2018] 水箱", "background": "", "description": "在地面上有一个水箱，它的俯视图被划分成了 $n$ 行 $m$ 列个方格，相邻两个方格之间有一堵厚度可以忽略不计的墙，水箱与外界之间有一堵高度无穷大的墙，因此水不可能漏到外面。已知水箱内每个格子的高度只能是 $[0,H]$ 之间的整数，请统计有多少可能的水位情况。\n\n因为答案可能很大，请对 $10^9+7$ 取模输出。\n\n我们说两种情况是不同的当且仅当存在至少一个方格的水位在两个情况中不同。", "inputFormat": "第一行包含三个正整数 $n,m,H$。\n接下来 $n$ 行，每行 $m-1$ 个整数$ a[i][j](1\\le a[i][j]\\le H)$，表示 $(i,j)$ 和 $(i,j+1)$ 之间的墙的高度。\n\n接下来 $n-1$ 行，每行 $m$ 个整数 $b[i][j](1\\le b[i][j]\\le H)$ ，表示 $(i,j)$ 和 $(i+1,j)$ 之间的墙的高度。", "outputFormat": "输出一行一个整数，即方案数模 $10^9+7$ 的结果。", "hint": "对于 $100\\%$ 的数据，$n\\times m\\le500000$，$1\\le H\\le10^9$。\n\n----\n\n### 样例解释：\n\n要么全部格子水位都是 $2$，要么全部格子水位都在 $[0,1]$ 之间，共 $1+2^6=65$ 种情况。", "locale": "zh-CN"}}}
{"pid": "P5953", "type": "P", "difficulty": 5, "samples": [["3 5 2\n1 5 3 3 3\n4 1 3 3 4\n4 2 4 4 3", "4 20"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "POI（波兰）", "O2优化"], "title": "[POI 2018] Różnorodność", "background": "", "description": "给定一个 $n$ 行 $m$ 列的矩阵，请对于每个长宽均为 $k$ 的连续子正方形，统计里面出现过的数值的种类数。", "inputFormat": "第一行包含三个正整数 $n,m,k$\n接下来 $n$ 行，每行 $m$ 个正整数 $a[i][j](1<=a[i][j]<=100000)$ ，表示矩阵中每个位置的数值。", "outputFormat": "输出一行两个整数 $M$ 和 $ S$。\n设 $f(i,j)$ 表示以 $(i,j)$ 为左上角的正方形内出现过的数值的种类数，则 $M$ 表示 $f$ 的最大值，$ S$ 表示 $f$ 的总和。", "hint": "对于 $100\\%$ 的数据，$n,m\\le3000$，$k\\le \\min(n,m)$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2018] Różnorodność", "background": "", "description": "给定一个 $n$ 行 $m$ 列的矩阵，请对于每个长宽均为 $k$ 的连续子正方形，统计里面出现过的数值的种类数。", "inputFormat": "第一行包含三个正整数 $n,m,k$\n接下来 $n$ 行，每行 $m$ 个正整数 $a[i][j](1<=a[i][j]<=100000)$ ，表示矩阵中每个位置的数值。", "outputFormat": "输出一行两个整数 $M$ 和 $ S$。\n设 $f(i,j)$ 表示以 $(i,j)$ 为左上角的正方形内出现过的数值的种类数，则 $M$ 表示 $f$ 的最大值，$ S$ 表示 $f$ 的总和。", "hint": "对于 $100\\%$ 的数据，$n,m\\le3000$，$k\\le \\min(n,m)$。", "locale": "zh-CN"}}}
{"pid": "P5954", "type": "P", "difficulty": 5, "samples": [["3 2 1\n1 3\n2 3\n3", "3"], ["4 4 1\n1 2\n1 3\n2 4\n3 4\n4", "1 2 3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2013", "各省省选", "江苏", "拓扑排序", "bitset"], "title": "[JSOI2013] 侦探 JYY", "background": "", "description": "JSOI 的世界里一共有 $N$ 个不同的事件（依次由 $1$ 到 $N$ 编号），以及 $M$ 条线索。每一条线索对应一个二元组 $(x,y)$，表示事件 $x$ 发生会导致事件 $y$ 发生。\n\n**注意： 线索是单向的，也就是如果 $y$ 发生了，并不代表 $x$ 一定会发生。**\n\n线索是有传递性的， 即如果存在线索 $(x,y)$ 以及 $(y,z)$， 那么 $x$ 发生则会导致 $z$ 发生。\n\n同时由于世界是合理的，任意一个事件 $x$ 一定不会通过某些线索导致事件 $x$ 本身发生。\n\n另外，整个世界仅包含这 $M$ 条线索， 我们不认为一些事件会凭空发生（就像福尔摩斯永远不会认为诡异的凶杀案是源于神的谴责）。具体而言，对于某个事件 $x$， 如果 $x$ 发生了，并且存在某个事件可能导致 $x$ 发生，那么一定至少有一个可能导致 $x$ 发生的事件发生了。\n\n现在已知世界上的 $M$ 条线索，以及 $D$ 个已经发生的事件，那么由此推断，\n哪些事件一定已经发生了呢？", "inputFormat": "第一行包含用空格隔开的三个整数，分别为 $N$，$M$ 和 $D$。\n\n接下来 $M$ 行，每行两个整数 $x$，$y$ 表示线索 $(x,y)$， 满足 $1\\leq x,y\\leq N$。\n\n接下来 $D$ 行为 $D$ 个 $1$ 到 $N$ 之间不同的整数， 表示已知的已经发生的事件。", "outputFormat": "包含一行至少 $D$ 个由空格隔开的严格递增的正整数， 表示根据 $M$ 条线索以及 $D$ 个已知事件 JYY 所能推断出的一定发生了的事件。", "hint": "### 样例解释\n\n在第一个样例中，由于事件 $1$ 和事件 $2$ 这两个事件中的任何一个发生都会导致事件 $3$ 发生，所以我们并不能确定到底哪个事件发生了。\n\n在第二个样例中，由于事件 $4$ 发生了，所以事件 $2$ 和事件 $3$ 中至少有一个发生了。而不论哪一个发生了，都可以推出事件 $1$ 发生了。\n\n最终由于事件 $1$ 发生了，使得我们可以推断出，所有 $4$ 个事件都必然发生了。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leq D\\leq N\\leq 10^3,1\\leq M\\leq 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2013] 侦探 JYY", "background": "", "description": "JSOI 的世界里一共有 $N$ 个不同的事件（依次由 $1$ 到 $N$ 编号），以及 $M$ 条线索。每一条线索对应一个二元组 $(x,y)$，表示事件 $x$ 发生会导致事件 $y$ 发生。\n\n**注意： 线索是单向的，也就是如果 $y$ 发生了，并不代表 $x$ 一定会发生。**\n\n线索是有传递性的， 即如果存在线索 $(x,y)$ 以及 $(y,z)$， 那么 $x$ 发生则会导致 $z$ 发生。\n\n同时由于世界是合理的，任意一个事件 $x$ 一定不会通过某些线索导致事件 $x$ 本身发生。\n\n另外，整个世界仅包含这 $M$ 条线索， 我们不认为一些事件会凭空发生（就像福尔摩斯永远不会认为诡异的凶杀案是源于神的谴责）。具体而言，对于某个事件 $x$， 如果 $x$ 发生了，并且存在某个事件可能导致 $x$ 发生，那么一定至少有一个可能导致 $x$ 发生的事件发生了。\n\n现在已知世界上的 $M$ 条线索，以及 $D$ 个已经发生的事件，那么由此推断，\n哪些事件一定已经发生了呢？", "inputFormat": "第一行包含用空格隔开的三个整数，分别为 $N$，$M$ 和 $D$。\n\n接下来 $M$ 行，每行两个整数 $x$，$y$ 表示线索 $(x,y)$， 满足 $1\\leq x,y\\leq N$。\n\n接下来 $D$ 行为 $D$ 个 $1$ 到 $N$ 之间不同的整数， 表示已知的已经发生的事件。", "outputFormat": "包含一行至少 $D$ 个由空格隔开的严格递增的正整数， 表示根据 $M$ 条线索以及 $D$ 个已知事件 JYY 所能推断出的一定发生了的事件。", "hint": "### 样例解释\n\n在第一个样例中，由于事件 $1$ 和事件 $2$ 这两个事件中的任何一个发生都会导致事件 $3$ 发生，所以我们并不能确定到底哪个事件发生了。\n\n在第二个样例中，由于事件 $4$ 发生了，所以事件 $2$ 和事件 $3$ 中至少有一个发生了。而不论哪一个发生了，都可以推出事件 $1$ 发生了。\n\n最终由于事件 $1$ 发生了，使得我们可以推断出，所有 $4$ 个事件都必然发生了。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leq D\\leq N\\leq 10^3,1\\leq M\\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5955", "type": "P", "difficulty": 6, "samples": [["5\n2 -2\n-2 -2\n0 2\n3 1\n-3 1", "26"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "POI（波兰）"], "title": "[POI 2018] Pionek", "background": "", "description": "在无限大的二维平面的原点 $(0,0)$ 放置着一个棋子。你有 $n$ 条可用的移动指令，每条指令可以用一个二维整数向量表示。每条指令可以执行 $1$ 次或者不执行。棋子可以重复经过同一个点，两条指令的方向向量也可能相同。你的目标是让棋子最终离原点的**欧几里得距离**最远，请问这个最远距离是多少？", "inputFormat": "第一行包含一个正整数 $n$，表示指令条数。\n\n接下来 $n$ 行，每行两个整数 $x,y$，表示你可以从 $(a,b)$ 移动到 $(a+x,b+y)$。", "outputFormat": "输出一行一个整数，即最大距离的平方。", "hint": "对于 $100\\%$ 的数据，$n\\le 2 \\times 10^5$，$|x|,|y| \\le 10^4$。\n\n-----\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aiztesh5.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2018] Pionek", "background": "", "description": "在无限大的二维平面的原点 $(0,0)$ 放置着一个棋子。你有 $n$ 条可用的移动指令，每条指令可以用一个二维整数向量表示。每条指令可以执行 $1$ 次或者不执行。棋子可以重复经过同一个点，两条指令的方向向量也可能相同。你的目标是让棋子最终离原点的**欧几里得距离**最远，请问这个最远距离是多少？", "inputFormat": "第一行包含一个正整数 $n$，表示指令条数。\n\n接下来 $n$ 行，每行两个整数 $x,y$，表示你可以从 $(a,b)$ 移动到 $(a+x,b+y)$。", "outputFormat": "输出一行一个整数，即最大距离的平方。", "hint": "对于 $100\\%$ 的数据，$n\\le 2 \\times 10^5$，$|x|,|y| \\le 10^4$。\n\n-----\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aiztesh5.png)", "locale": "zh-CN"}}}
{"pid": "P5956", "type": "P", "difficulty": 3, "samples": [["3 3\n1 1 1\n0\n1\n2", "0\n2 \n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "二分", "POI（波兰）", "数论"], "title": "[POI 2017] Podzielno", "background": null, "description": "$B$ 进制数，每个数字 $i \\in [0,B)$ 有 $a_i$ 个。你要用这些数字组成一个最大的 $B$ 进制数 $X$（不能有前导零，不需要用完所有数字），使得 $X$ 是 $B-1$ 的倍数。 $q$ 次询问，每次询问 $X$ 在 $B$ 进制下的第 $k$ 位数字是什么（最低位是第 $0$ 位）。", "inputFormat": "第一行包含两个正整数 $B,q$。\n\n第二行包含 $B$ 个正整数 $a_0,a_1,a_2,...,a_{B-1}$。\n\n接下来 $q$ 行，每行一个整数 $k$，表示一个询问。", "outputFormat": "输出 $q$ 行，每行一个整数，依次回答每个询问，如果那一位不存在，请输出 $-1$。", "hint": "对于 $100\\%$ 的数据，$2\\le B\\le10^6$，$1\\le q\\le 10^5$，$1\\le a_i\\le10^6$，$0\\le k\\le10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2017] Podzielno", "background": null, "description": "$B$ 进制数，每个数字 $i \\in [0,B)$ 有 $a_i$ 个。你要用这些数字组成一个最大的 $B$ 进制数 $X$（不能有前导零，不需要用完所有数字），使得 $X$ 是 $B-1$ 的倍数。 $q$ 次询问，每次询问 $X$ 在 $B$ 进制下的第 $k$ 位数字是什么（最低位是第 $0$ 位）。", "inputFormat": "第一行包含两个正整数 $B,q$。\n\n第二行包含 $B$ 个正整数 $a_0,a_1,a_2,...,a_{B-1}$。\n\n接下来 $q$ 行，每行一个整数 $k$，表示一个询问。", "outputFormat": "输出 $q$ 行，每行一个整数，依次回答每个询问，如果那一位不存在，请输出 $-1$。", "hint": "对于 $100\\%$ 的数据，$2\\le B\\le10^6$，$1\\le q\\le 10^5$，$1\\le a_i\\le10^6$，$0\\le k\\le10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P5957", "type": "P", "difficulty": 4, "samples": [["4 11\n4 1 4\n7 -1 2\n8 -1 3\n9 0 2", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2017", "POI（波兰）"], "title": "[POI 2017] Flappy Bird", "background": "`《飞扬的小鸟》` 是一款风靡的小游戏。", "description": "在游戏中，小鸟一开始位于 $(0,0)$ 处，它的目标是飞到横坐标为 $X$ 的某个位置上。\n\n每一秒，你可以选择点击屏幕，那么小鸟会从 $(x,y)$ 飞到 $(x+1,y+1)$，或者不点击，那么小鸟会飞到 $(x+1,y-1)$。\n\n在游戏中还有 $n$ 个障碍物，用三元组 $(x_i,a_i,b_i)$ 描述，表示在直线 $x=x_i$ 上，$y\\le a_i$ 或者 $y\\ge b_i$ 的部分都是障碍物，碰到或者擦边都算游戏失败。\n\n现在，请你求出小鸟从 $(0,0)$ 飞到目的地最少需要点击多少次屏幕。", "inputFormat": "第一行包含两个整数 $n,X$。\n接下来 $n$ 行，每行三个整数 $x_i,a_i,b_i$。数据保证 $x_i<x_{i+1}$。", "outputFormat": "如果无论如何都飞不到目的地，输出 `NIE`，否则输出点击屏幕的最少次数。", "hint": "对于 $100\\%$ 的数据，$0\\le n\\le 500000$，$1\\le X\\le10^9$，$0<x_i<X$，$-10^9\\le a_i<b_i\\le 10^9$。\n\n-------\n\n### 样例解释：\n![](https://cdn.luogu.com.cn/upload/image_hosting/9lse80af.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2017] Flappy Bird", "background": "`《飞扬的小鸟》` 是一款风靡的小游戏。", "description": "在游戏中，小鸟一开始位于 $(0,0)$ 处，它的目标是飞到横坐标为 $X$ 的某个位置上。\n\n每一秒，你可以选择点击屏幕，那么小鸟会从 $(x,y)$ 飞到 $(x+1,y+1)$，或者不点击，那么小鸟会飞到 $(x+1,y-1)$。\n\n在游戏中还有 $n$ 个障碍物，用三元组 $(x_i,a_i,b_i)$ 描述，表示在直线 $x=x_i$ 上，$y\\le a_i$ 或者 $y\\ge b_i$ 的部分都是障碍物，碰到或者擦边都算游戏失败。\n\n现在，请你求出小鸟从 $(0,0)$ 飞到目的地最少需要点击多少次屏幕。", "inputFormat": "第一行包含两个整数 $n,X$。\n接下来 $n$ 行，每行三个整数 $x_i,a_i,b_i$。数据保证 $x_i<x_{i+1}$。", "outputFormat": "如果无论如何都飞不到目的地，输出 `NIE`，否则输出点击屏幕的最少次数。", "hint": "对于 $100\\%$ 的数据，$0\\le n\\le 500000$，$1\\le X\\le10^9$，$0<x_i<X$，$-10^9\\le a_i<b_i\\le 10^9$。\n\n-------\n\n### 样例解释：\n![](https://cdn.luogu.com.cn/upload/image_hosting/9lse80af.png)", "locale": "zh-CN"}}}
{"pid": "P5958", "type": "P", "difficulty": 5, "samples": [["9 3\n1\n1\n2\n2\n2\n3\n7\n3", "0.6666666667"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2017", "POI（波兰）", "Special Judge", "树形 DP"], "title": "[POI 2017] Sabotaż", "background": null, "description": "某个公司有 $n$ 个人，上下级关系构成了一个有根树。其中有个人是叛徒（这个人不知道是谁）。\n\n对于一个人，如果他下属（直接或者间接，不包括他自己）中叛徒占的比例超过 $x$，那么这个人也会变成叛徒，并且他的所有下属都会变成叛徒。你要求出一个最小的 $x$，使得最坏情况下，叛徒的个数不会超过 $k$。", "inputFormat": "第一行包含两个正整数 $n,k$。\n\n接下来 $n-1$ 行，第 $i$ 行包含一个正整数 $p_{i+1}$，表示 $i+1$ 的父亲是 $p_{i+1}$。", "outputFormat": "输出一行一个实数 $x$，误差在 $10^{-6}$ 以内都认为是正确的。", "hint": "#### 样例解释\n答案中的 $x$ 实际上是一个无限趋近于 $\\frac{2}{3}$ 但是大于 $\\frac{2}{3}$ 的数。 \n\n因为当 $x$ 取 $\\frac{2}{3}$ 时，最坏情况下 $3,7,8,9$ 都是叛徒，超过了 $k=3$。\n#### 数据范围\n对于 $100\\%$ 的数据，$1\\le k\\le n\\le 500000$，$1\\le p_{i+1}\\le i$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2017] Sabotaż", "background": null, "description": "某个公司有 $n$ 个人，上下级关系构成了一个有根树。其中有个人是叛徒（这个人不知道是谁）。\n\n对于一个人，如果他下属（直接或者间接，不包括他自己）中叛徒占的比例超过 $x$，那么这个人也会变成叛徒，并且他的所有下属都会变成叛徒。你要求出一个最小的 $x$，使得最坏情况下，叛徒的个数不会超过 $k$。", "inputFormat": "第一行包含两个正整数 $n,k$。\n\n接下来 $n-1$ 行，第 $i$ 行包含一个正整数 $p_{i+1}$，表示 $i+1$ 的父亲是 $p_{i+1}$。", "outputFormat": "输出一行一个实数 $x$，误差在 $10^{-6}$ 以内都认为是正确的。", "hint": "#### 样例解释\n答案中的 $x$ 实际上是一个无限趋近于 $\\frac{2}{3}$ 但是大于 $\\frac{2}{3}$ 的数。 \n\n因为当 $x$ 取 $\\frac{2}{3}$ 时，最坏情况下 $3,7,8,9$ 都是叛徒，超过了 $k=3$。\n#### 数据范围\n对于 $100\\%$ 的数据，$1\\le k\\le n\\le 500000$，$1\\le p_{i+1}\\le i$。", "locale": "zh-CN"}}}
{"pid": "P5959", "type": "P", "difficulty": 4, "samples": [["7\n6 6 2 2 1\n5 3 5 1 4", "TAK\n1 5 2\n5 7 1\n5 2 4\n7 3 3\n1 4 2\n1 6 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "POI（波兰）", "Special Judge"], "title": "[POI 2018] Plan metra", "background": "", "description": "有一棵 $n$ 个点的无根树，每条边有一个正整数权值，表示长度，定义两点距离为在树上的最短路径的长度。\n\n已知 $2$ 到 $ n-1$ 每个点在树上与 $1$ 和 $n$ 的距离，请根据这些信息还原出这棵树。", "inputFormat": "第一行包含一个正整数 $n$，表示点数。\n\n第二行包含 $n-2$ 个正整数 $d(1,2),d(1,3),...,d(1,n-1)$，分别表示每个点到 $1$ 的距离。\n\n第三行包含 $n-2$ 个正整数 $d(n,2),d(n,3),...,d(n,n-1)$，分别表示每个点到 $n$ 的距离。", "outputFormat": "若无解，输出 `NIE`。\n\n否则第一行输出`TAK`，接下来 $n-1$ 行每行三个正整数 $u,v,c$，表示存在一条长度为 $c$ 的连接 $u$ 和 $v$ 两点的树边。\n\n若有多组解，输出任意一组即可。\n\n**本题使用 Special Judge。**", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 500000$，$1\\le d\\le 1000000$，$1\\le u,v\\le n$，$1\\le c\\le1000000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2018] Plan metra", "background": "", "description": "有一棵 $n$ 个点的无根树，每条边有一个正整数权值，表示长度，定义两点距离为在树上的最短路径的长度。\n\n已知 $2$ 到 $ n-1$ 每个点在树上与 $1$ 和 $n$ 的距离，请根据这些信息还原出这棵树。", "inputFormat": "第一行包含一个正整数 $n$，表示点数。\n\n第二行包含 $n-2$ 个正整数 $d(1,2),d(1,3),...,d(1,n-1)$，分别表示每个点到 $1$ 的距离。\n\n第三行包含 $n-2$ 个正整数 $d(n,2),d(n,3),...,d(n,n-1)$，分别表示每个点到 $n$ 的距离。", "outputFormat": "若无解，输出 `NIE`。\n\n否则第一行输出`TAK`，接下来 $n-1$ 行每行三个正整数 $u,v,c$，表示存在一条长度为 $c$ 的连接 $u$ 和 $v$ 两点的树边。\n\n若有多组解，输出任意一组即可。\n\n**本题使用 Special Judge。**", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 500000$，$1\\le d\\le 1000000$，$1\\le u,v\\le n$，$1\\le c\\le1000000$。", "locale": "zh-CN"}}}
{"pid": "P5960", "type": "P", "difficulty": 4, "samples": [["3 3\n1 2 3\n2 3 -2\n1 3 1", "5 3 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["Special Judge", "差分约束", "模板题"], "title": "【模板】差分约束", "background": "", "description": "给出一组包含 $m$ 个不等式，有 $n$ 个未知数的形如：\n\n$$ \\begin{cases} x_{c_1}-x_{c'_1}\\leq y_1 \\\\x_{c_2}-x_{c'_2} \\leq y_2 \\\\ \\cdots\\\\ x_{c_m} - x_{c'_m}\\leq y_m\\end{cases}$$\n\n的不等式组，求任意一组满足这个不等式组的解。", "inputFormat": "第一行为两个正整数 $n,m$，代表未知数的数量和不等式的数量。\n\n接下来 $m$ 行，每行包含三个整数 $c,c',y$，代表一个不等式 $x_c-x_{c'}\\leq y$。", "outputFormat": "一行，$n$ 个数，表示 $x_1 , x_2 \\cdots x_n$ 的一组可行解，如果有多组解，请输出任意一组，无解请输出 `NO`。", "hint": "**样例解释**\n\n$\\begin{cases}x_1-x_2\\leq 3 \\\\ x_2 - x_3 \\leq -2 \\\\ x_1 - x_3 \\leq 1 \\end{cases}$\n\n一种可行的方法是 $x_1 = 5, x_2 = 3, x_3 = 5$。\n\n$\\begin{cases}5-3  = 2\\leq 3 \\\\ 3 - 5 = -2 \\leq -2 \\\\ 5 - 5  = 0\\leq 1 \\end{cases}$\n\n**数据范围**\n\n对于 $100\\%$ 的数据，$1\\leq n,m \\leq 5\\times 10^3$，$-10^4\\leq y\\leq 10^4$，$1\\leq c,c'\\leq n$，$c \\neq c'$。\n\n**评分策略**\n\n你的答案符合该不等式组即可得分，请确保你的答案中的数据在 `int` 范围内。\n\n如果并没有答案，而你的程序给出了答案，SPJ 会给出 `There is no answer, but you gave it`，结果为 WA；    \n如果并没有答案，而你的程序输出了 `NO`，SPJ 会给出 `No answer`，结果为 AC；       \n如果存在答案，而你的答案错误，SPJ 会给出 `Wrong answer`，结果为 WA；    \n如果存在答案，且你的答案正确，SPJ 会给出 `The answer is correct`，结果为 AC。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Difference Constraints", "background": "", "description": "You are given a system of inequalities with $m$ inequalities and $n$ unknowns of the form:\n\n$$ \\begin{cases} x_{c_1}-x_{c'_1}\\leq y_1 \\\\x_{c_2}-x_{c'_2} \\leq y_2 \\\\ \\cdots\\\\ x_{c_m} - x_{c'_m}\\leq y_m\\end{cases}$$\n\nFind any set of values that satisfies this system of inequalities.", "inputFormat": "The first line contains two positive integers $n, m$, representing the number of unknowns and the number of inequalities.\n\nThe next $m$ lines each contain three integers $c, c', y$, representing an inequality $x_c - x_{c'} \\leq y$.", "outputFormat": "Output one line with $n$ numbers, representing a feasible solution $x_1, x_2 \\cdots x_n$. If there are multiple solutions, output any one of them. If there is no solution, output `NO`.", "hint": "**Sample Explanation**\n\n$\\begin{cases}x_1-x_2\\leq 3 \\\\ x_2 - x_3 \\leq -2 \\\\ x_1 - x_3 \\leq 1 \\end{cases}$\n\nOne feasible solution is $x_1 = 5, x_2 = 3, x_3 = 5$.\n\n$\\begin{cases}5-3  = 2\\leq 3 \\\\ 3 - 5 = -2 \\leq -2 \\\\ 5 - 5  = 0\\leq 1 \\end{cases}$\n\n**Constraints**\n\nFor $100\\%$ of the testdata, $1\\leq n,m \\leq 5\\times 10^3$, $-10^4\\leq y\\leq 10^4$, $1\\leq c,c'\\leq n$, and $c \\neq c'$.\n\n**Scoring Policy**\n\nYou will get points as long as your output satisfies the system of inequalities. Please make sure the numbers in your output are within the `int` range.\n\nIf there is no solution but your program outputs a solution, the SPJ will return `There is no answer, but you gave it`, and the result will be WA.  \nIf there is no solution and your program outputs `NO`, the SPJ will return `No answer`, and the result will be AC.  \nIf a solution exists but your output is incorrect, the SPJ will return `Wrong answer`, and the result will be WA.  \nIf a solution exists and your output is correct, the SPJ will return `The answer is correct`, and the result will be AC.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】差分约束", "background": "", "description": "给出一组包含 $m$ 个不等式，有 $n$ 个未知数的形如：\n\n$$ \\begin{cases} x_{c_1}-x_{c'_1}\\leq y_1 \\\\x_{c_2}-x_{c'_2} \\leq y_2 \\\\ \\cdots\\\\ x_{c_m} - x_{c'_m}\\leq y_m\\end{cases}$$\n\n的不等式组，求任意一组满足这个不等式组的解。", "inputFormat": "第一行为两个正整数 $n,m$，代表未知数的数量和不等式的数量。\n\n接下来 $m$ 行，每行包含三个整数 $c,c',y$，代表一个不等式 $x_c-x_{c'}\\leq y$。", "outputFormat": "一行，$n$ 个数，表示 $x_1 , x_2 \\cdots x_n$ 的一组可行解，如果有多组解，请输出任意一组，无解请输出 `NO`。", "hint": "**样例解释**\n\n$\\begin{cases}x_1-x_2\\leq 3 \\\\ x_2 - x_3 \\leq -2 \\\\ x_1 - x_3 \\leq 1 \\end{cases}$\n\n一种可行的方法是 $x_1 = 5, x_2 = 3, x_3 = 5$。\n\n$\\begin{cases}5-3  = 2\\leq 3 \\\\ 3 - 5 = -2 \\leq -2 \\\\ 5 - 5  = 0\\leq 1 \\end{cases}$\n\n**数据范围**\n\n对于 $100\\%$ 的数据，$1\\leq n,m \\leq 5\\times 10^3$，$-10^4\\leq y\\leq 10^4$，$1\\leq c,c'\\leq n$，$c \\neq c'$。\n\n**评分策略**\n\n你的答案符合该不等式组即可得分，请确保你的答案中的数据在 `int` 范围内。\n\n如果并没有答案，而你的程序给出了答案，SPJ 会给出 `There is no answer, but you gave it`，结果为 WA；    \n如果并没有答案，而你的程序输出了 `NO`，SPJ 会给出 `No answer`，结果为 AC；       \n如果存在答案，而你的答案错误，SPJ 会给出 `Wrong answer`，结果为 WA；    \n如果存在答案，且你的答案正确，SPJ 会给出 `The answer is correct`，结果为 AC。", "locale": "zh-CN"}}}
{"pid": "P5961", "type": "P", "difficulty": 3, "samples": [["7 25\n1 0\n2 0\n3 1\n5 0\n10 0\n13 0\n20 0", "3\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2006", "BalticOI（波罗的海）"], "title": "[BalticOI 2006] coin collector钱币收藏家", "background": null, "description": "有一个国家，流通着 $n$ 种面值的硬币，其中包括了1分硬币。另外，有一种面值为 $K$ 分的纸币，它超过了所有硬币的面值。 有一位硬币收藏家，他想收集每一种面值的硬币样本。他家里已经有一些硬币，但是现在他只带着一张 $K$ 分纸币去商店。 商店里总共有 $K-1$ 种商品，价格分别为 $1$ 分、$2$ 分…… $K-1$ 分。\n\n这家商店使用以下算法找零：  \n1.假设总共需要找 $A$ 分；  \n2.寻找最高的不超过 $A$ 的硬币面值，设它为 $B$ 分硬币；  \n3.给顾客一枚 $B$ 分硬币，然后令 $A$ 为 $A-B$；  \n4.如果 $A=0$，算法结束；否则转2。\n\n收藏家想用他的 $K$ 分纸币买一件商品。请你编写程序，计算：收藏家能够得到多少种他还没有过的硬币? 在满足上一问的前提下，他能够买的最贵的商品是什么?", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $K$。\n\n以下 $n$ 行描述各种流通的硬币的面值和是否已收藏状态。第 $i+1$ 行包含整数 $C_i\\ (1\\le C_i<K)$ 和 $d_i$，$C_i$ 表示第 $i$ 种硬币的面值。若 $d_i=1$，收藏家已经有硬币 $C_i$，若 $d_i=0$，收藏家还没有硬币 $C_i$。输入按照硬币面值递增顺序，也就是 $C_1<C_2<…<C_n$，第一枚硬币是 $1$ 分硬币，也就是 $C_1=1$。", "outputFormat": "输出第一行为一个整数，表示收藏家最多能获得多少种之前还没有的硬币。\n\n第二行为一个整数，表示在前一问的前提下，收藏家能购买的最贵的商品价格。", "hint": "对于所有数据，$1\\le n\\le 5\\times 10^5$，$2\\le K\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2006] coin collector钱币收藏家", "background": null, "description": "有一个国家，流通着 $n$ 种面值的硬币，其中包括了1分硬币。另外，有一种面值为 $K$ 分的纸币，它超过了所有硬币的面值。 有一位硬币收藏家，他想收集每一种面值的硬币样本。他家里已经有一些硬币，但是现在他只带着一张 $K$ 分纸币去商店。 商店里总共有 $K-1$ 种商品，价格分别为 $1$ 分、$2$ 分…… $K-1$ 分。\n\n这家商店使用以下算法找零：  \n1.假设总共需要找 $A$ 分；  \n2.寻找最高的不超过 $A$ 的硬币面值，设它为 $B$ 分硬币；  \n3.给顾客一枚 $B$ 分硬币，然后令 $A$ 为 $A-B$；  \n4.如果 $A=0$，算法结束；否则转2。\n\n收藏家想用他的 $K$ 分纸币买一件商品。请你编写程序，计算：收藏家能够得到多少种他还没有过的硬币? 在满足上一问的前提下，他能够买的最贵的商品是什么?", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $K$。\n\n以下 $n$ 行描述各种流通的硬币的面值和是否已收藏状态。第 $i+1$ 行包含整数 $C_i\\ (1\\le C_i<K)$ 和 $d_i$，$C_i$ 表示第 $i$ 种硬币的面值。若 $d_i=1$，收藏家已经有硬币 $C_i$，若 $d_i=0$，收藏家还没有硬币 $C_i$。输入按照硬币面值递增顺序，也就是 $C_1<C_2<…<C_n$，第一枚硬币是 $1$ 分硬币，也就是 $C_1=1$。", "outputFormat": "输出第一行为一个整数，表示收藏家最多能获得多少种之前还没有的硬币。\n\n第二行为一个整数，表示在前一问的前提下，收藏家能购买的最贵的商品价格。", "hint": "对于所有数据，$1\\le n\\le 5\\times 10^5$，$2\\le K\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5962", "type": "P", "difficulty": 4, "samples": [["12\n2-4,7,9;\n1,4,11-12;\n1,4,10,12;\n1,4-8,10-12;\n1,8;\n1,3-6,8,10-12;\n1,3,5-6,8,11;\n1,8,10-12;\n1-8;\n;\n2;\n2-4,7-10,12;", "29 1\n7 3\n4 2\n1 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2004", "并查集", "BalticOI（波罗的海）"], "title": "[BalticOI 2004] Ships (Day1)", "background": null, "description": "有一个由 $n\\times n$ 的正方形组成的“船”的游戏棋盘。每个单元格可能属于某艘船（黑色）或为空。如果两个边相邻的单元格都是黑色，那么这两个单元格属于同一艘船。不同船之间没有公共边。船的吨位是这些相邻的单元格数。\n\n在给定的样例中，棋盘中（黑色）的单元格属于船，共有一艘 $29$ 吨的船，三艘 $7$ 吨的船，二艘 $4$ 吨的船，三艘 $1$ 吨的船。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uk57lz80.png)\n\n请写一个程序，对给定的游戏局面计算出每艘船的吨位和数量。", "inputFormat": "第一行包含一个整数 $n$ 表示游戏棋盘的大小。\n\n接下来 $n$ 行，第 $i+1$ 行描述第 $i$ 行的列（船）的信息，中间用一个逗号分隔：\n- 如果是单独一个数，那么这一列属于船，这列的左、右单元格是空的；\n- 如果是 `-` 连接的两个数，表示这两列之间的所有格子（包含这两列）都属于船，则左侧和右侧是空的。\n\n数据之间用逗号分隔，每行结尾的分号。行中没有空格。如果某行只有一个分号，则这行没有船的信息。", "outputFormat": "你的程序必须输出船的信息。每行是一个空格分隔的两个整数。第一个数是船的吨位，第二个数是这个吨位的船只数量。必须以递减顺序输出船的吨位，并且至少有一艘船有此吨位。", "hint": "对于所有的数据，$1\\le n<3\\times 10^4$，船舶总数和船舶吨位都不超过 $10^3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2004] Ships (Day1)", "background": null, "description": "有一个由 $n\\times n$ 的正方形组成的“船”的游戏棋盘。每个单元格可能属于某艘船（黑色）或为空。如果两个边相邻的单元格都是黑色，那么这两个单元格属于同一艘船。不同船之间没有公共边。船的吨位是这些相邻的单元格数。\n\n在给定的样例中，棋盘中（黑色）的单元格属于船，共有一艘 $29$ 吨的船，三艘 $7$ 吨的船，二艘 $4$ 吨的船，三艘 $1$ 吨的船。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uk57lz80.png)\n\n请写一个程序，对给定的游戏局面计算出每艘船的吨位和数量。", "inputFormat": "第一行包含一个整数 $n$ 表示游戏棋盘的大小。\n\n接下来 $n$ 行，第 $i+1$ 行描述第 $i$ 行的列（船）的信息，中间用一个逗号分隔：\n- 如果是单独一个数，那么这一列属于船，这列的左、右单元格是空的；\n- 如果是 `-` 连接的两个数，表示这两列之间的所有格子（包含这两列）都属于船，则左侧和右侧是空的。\n\n数据之间用逗号分隔，每行结尾的分号。行中没有空格。如果某行只有一个分号，则这行没有船的信息。", "outputFormat": "你的程序必须输出船的信息。每行是一个空格分隔的两个整数。第一个数是船的吨位，第二个数是这个吨位的船只数量。必须以递减顺序输出船的吨位，并且至少有一艘船有此吨位。", "hint": "对于所有的数据，$1\\le n<3\\times 10^4$，船舶总数和船舶吨位都不超过 $10^3$。", "locale": "zh-CN"}}}
{"pid": "P5963", "type": "P", "difficulty": 3, "samples": [["6\n-8 12\n0 5\n7 -3\n10 -7\n-2 7\n1 4", "-34"], ["10\n70 70\n62 73\n81 65\n59 77\n99 40\n35 88\n80 57\n76 67\n85 57\n53 96", "-155\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "2005", "排序", "BalticOI（波罗的海）"], "title": "[BalticOI 2005] Card 卡牌游戏 (Day0)", "background": null, "description": "Adam 喜欢数。有一次他在他的抽屉里找到了一沓空白纸卡牌，在每张卡牌的两面写上随机的数，然后思考下面的谜题：把所有卡牌按任意顺序（必要时翻转）填入下面格式的表达式，最小的可能得到的表达式的值是多少？\n\n>`□-□+□-□+□-□+...-□`（第一个符号和最后一个符号均为 `-`）\n\n过了一会 Adam 想出了一个解法。你也能想出来吗？编写一个程序解决上面描述的谜题。", "inputFormat": "标准输入的第一行包含卡牌的数量 $N$。\n\n接下来 $N$ 行，第 $i+1$ 行两个整数 $a_i$ 和 $b_i$，分别表示写在第 $i$ 张卡牌两面的数。", "outputFormat": "标准输出仅一行，应当包含最小的可能得到的表达式的值。", "hint": "#### 样例 1 解释\n\n卡牌填入表达式的顺序：$1,2,3,5,4,6$。\n\n此时最小值为 $(-8) - 5 + (-3) - 7 + (-7) - 4 = -34$。\n\n#### 样例 2 解释\n\n卡牌填入表达式的顺序：$2,1,4,3,5,8,6,9,7,10$。\n\n此时最小值为 $62 - 70 + 59 - 81 + 40 - 76 + 35 - 85 + 57 - 96 = -155$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$2\\le N\\le 10^5$，$N$ 为偶数（原因显然），$|a_i|,|b_i|\\le 2000$。\n\n#### 说明\n\n翻译自 BalticOI 2005 Day0 Card。\n\n原官网已经丢失此题，原数据可以在[这里](https://www.acmicpc.net/problem/3373)评测。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2005] Card 卡牌游戏 (Day0)", "background": null, "description": "Adam 喜欢数。有一次他在他的抽屉里找到了一沓空白纸卡牌，在每张卡牌的两面写上随机的数，然后思考下面的谜题：把所有卡牌按任意顺序（必要时翻转）填入下面格式的表达式，最小的可能得到的表达式的值是多少？\n\n>`□-□+□-□+□-□+...-□`（第一个符号和最后一个符号均为 `-`）\n\n过了一会 Adam 想出了一个解法。你也能想出来吗？编写一个程序解决上面描述的谜题。", "inputFormat": "标准输入的第一行包含卡牌的数量 $N$。\n\n接下来 $N$ 行，第 $i+1$ 行两个整数 $a_i$ 和 $b_i$，分别表示写在第 $i$ 张卡牌两面的数。", "outputFormat": "标准输出仅一行，应当包含最小的可能得到的表达式的值。", "hint": "#### 样例 1 解释\n\n卡牌填入表达式的顺序：$1,2,3,5,4,6$。\n\n此时最小值为 $(-8) - 5 + (-3) - 7 + (-7) - 4 = -34$。\n\n#### 样例 2 解释\n\n卡牌填入表达式的顺序：$2,1,4,3,5,8,6,9,7,10$。\n\n此时最小值为 $62 - 70 + 59 - 81 + 40 - 76 + 35 - 85 + 57 - 96 = -155$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$2\\le N\\le 10^5$，$N$ 为偶数（原因显然），$|a_i|,|b_i|\\le 2000$。\n\n#### 说明\n\n翻译自 BalticOI 2005 Day0 Card。\n\n原官网已经丢失此题，原数据可以在[这里](https://www.acmicpc.net/problem/3373)评测。", "locale": "zh-CN"}}}
{"pid": "P5964", "type": "P", "difficulty": 5, "samples": [["5\nBBBAB\nBBBAB\nAAAAA\nBBABA\nBBAAB", "14\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "POI（波兰）"], "title": "[POI 2016] Park wodny", "background": "", "description": "给出一个 $n\\times n$ 的四连通的网格图，每个格子要么是 `A`，要么是 `B`，保证 `B` 的连通块的形状都是矩形。\n\n现在你最多可以把两个 `A` 变成 `B`，问最大的 `B` 的连通块有多大。", "inputFormat": "第一行包含一个正整数 $n$。\n\n接下来 $n$ 行，每行 $n$ 个字符，表示这个网格图。\n", "outputFormat": "输出一行一个整数，即最大的 `B` 的连通块的大小。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2016] Park wodny", "background": "", "description": "给出一个 $n\\times n$ 的四连通的网格图，每个格子要么是 `A`，要么是 `B`，保证 `B` 的连通块的形状都是矩形。\n\n现在你最多可以把两个 `A` 变成 `B`，问最大的 `B` 的连通块有多大。", "inputFormat": "第一行包含一个正整数 $n$。\n\n接下来 $n$ 行，每行 $n$ 个字符，表示这个网格图。\n", "outputFormat": "输出一行一个整数，即最大的 `B` 的连通块的大小。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^3$。", "locale": "zh-CN"}}}
{"pid": "P5965", "type": "P", "difficulty": 3, "samples": [["112", "50"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "PA（波兰）"], "title": "[PA 2019] A+B", "background": "", "description": "在列竖式计算两个十进制数的和的时候，人们可能会错算成这样：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g0xa2tjn.png)\n\n在图里的左边，$248+208$ 被错算成了 $4416$。\n\n给定正整数 $n$，问有多少对非负整数 $a,b$ 满足 $a+b$ 会被错算成 $n$。\n\n请注意 $a$ 可以等于 $b$，且 $a=1,b=2$ 和 $a=2,b=1$ 是两种不同的方案。", "inputFormat": "第一行包含一个正整数 $n$。", "outputFormat": "输出一个整数，即满足条件的 $a,b$ 的数量。", "hint": "对于 $100\\%$ 的数据，$1\\le n<10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] A+B", "background": "", "description": "在列竖式计算两个十进制数的和的时候，人们可能会错算成这样：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g0xa2tjn.png)\n\n在图里的左边，$248+208$ 被错算成了 $4416$。\n\n给定正整数 $n$，问有多少对非负整数 $a,b$ 满足 $a+b$ 会被错算成 $n$。\n\n请注意 $a$ 可以等于 $b$，且 $a=1,b=2$ 和 $a=2,b=1$ 是两种不同的方案。", "inputFormat": "第一行包含一个正整数 $n$。", "outputFormat": "输出一个整数，即满足条件的 $a,b$ 的数量。", "hint": "对于 $100\\%$ 的数据，$1\\le n<10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P5966", "type": "P", "difficulty": 6, "samples": [["6 7\n1 2\n2 3\n3 1\n3 4\n4 5\n5 6\n6 3", "1\n1\n1\n2\n1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "POI（波兰）"], "title": "[POI 2016] Hydrorozgrywka", "background": null, "description": "给定一个 $n$ 个点 $m$ 条边的无向连通图，保证每条边属于且只属于一个环。\n\n两个人在这张图上玩游戏，一开始他们会在某个节点放一个棋子，然后依次移动这个棋子，已经走过的边不能再走，谁不能移动谁就输了。\n\n请求出所有先手必胜的策略中游戏开始时放棋子的位置。", "inputFormat": "第一行包含两个正整数 $ n,m$，表示点数和边数。\n\n接下来 $m$ 行每行包含两个正整数 $a,b$，表示 $a$ 点到 $b$ 点之间有一条无向边。", "outputFormat": "包含 $n$ 行，对于第 $i$ 行，如果在 $i$ 点放棋子先手必胜，输出 `1`，否则输出 `2`。", "hint": "对于 $100\\%$ 的数据，$3\\le n,m\\le 5 \\times 10^5$，$1\\le a,b\\le n$，$a\\ne b$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2016] Hydrorozgrywka", "background": null, "description": "给定一个 $n$ 个点 $m$ 条边的无向连通图，保证每条边属于且只属于一个环。\n\n两个人在这张图上玩游戏，一开始他们会在某个节点放一个棋子，然后依次移动这个棋子，已经走过的边不能再走，谁不能移动谁就输了。\n\n请求出所有先手必胜的策略中游戏开始时放棋子的位置。", "inputFormat": "第一行包含两个正整数 $ n,m$，表示点数和边数。\n\n接下来 $m$ 行每行包含两个正整数 $a,b$，表示 $a$ 点到 $b$ 点之间有一条无向边。", "outputFormat": "包含 $n$ 行，对于第 $i$ 行，如果在 $i$ 点放棋子先手必胜，输出 `1`，否则输出 `2`。", "hint": "对于 $100\\%$ 的数据，$3\\le n,m\\le 5 \\times 10^5$，$1\\le a,b\\le n$，$a\\ne b$。", "locale": "zh-CN"}}}
{"pid": "P5967", "type": "P", "difficulty": 5, "samples": [["4 10\n3 7 4 3", "10\n1 3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["搜索", "2016", "线段树", "堆", "POI（波兰）"], "title": "[POI 2016] Korale", "background": "", "description": "有 $n$ 个带标号的珠子，第 $i$ 个珠子的价值为 $a_i$。\n\n现在你可以选择若干个珠子组成项链（也可以一个都不选），项链的价值为所有珠子的价值和。\n\n给出所有可能的项链排序，先按权值从小到大排序，对于权值相同的，根据所用珠子集合的标号的字典序从小到大排序。\n\n请输出第 $k$ 小的项链的价值，以及所用的珠子集合。", "inputFormat": "第一行包含两个正整数 $n,k$。\n第二行包含 $n$ 个正整数，依次表示每个珠子的价值 $a_i$。", "outputFormat": "第一行输出第 $k$ 小的项链的价值。\n第二行按标号从小到大依次输出该项链里每个珠子的标号。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le k\\le \n\\min(2^n,10^6)$，$1\\le a_i\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2016] Korale", "background": "", "description": "有 $n$ 个带标号的珠子，第 $i$ 个珠子的价值为 $a_i$。\n\n现在你可以选择若干个珠子组成项链（也可以一个都不选），项链的价值为所有珠子的价值和。\n\n给出所有可能的项链排序，先按权值从小到大排序，对于权值相同的，根据所用珠子集合的标号的字典序从小到大排序。\n\n请输出第 $k$ 小的项链的价值，以及所用的珠子集合。", "inputFormat": "第一行包含两个正整数 $n,k$。\n第二行包含 $n$ 个正整数，依次表示每个珠子的价值 $a_i$。", "outputFormat": "第一行输出第 $k$ 小的项链的价值。\n第二行按标号从小到大依次输出该项链里每个珠子的标号。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le k\\le \n\\min(2^n,10^6)$，$1\\le a_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5968", "type": "P", "difficulty": 4, "samples": [["2\n17\n18", "6 3\n16 15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "POI（波兰）"], "title": "[POI 2017] Reprezentacje ró?nicowe", "background": "", "description": "给定一个数列 $a$：\n- 当 $n\\le 2$ 时，$a_n=n$。\n- 当 $n>2$，且 $n$ 是奇数时， $a_n=2\\times a_{n-1}$。\n- 当 $n>2$，且 $n$ 是偶数时，$a_n=a_{n-1}+r_{n-1}$。\n\n其中 $r_{n-1}= \\operatorname{mex}(|a_i-a_j|)(1\\le i\\le j\\le n-1)$， $\\operatorname{mex} \\left\\{ S\\right\\}$ 表示最小的不在 $S$ 集合里面的非负整数。\n\n数列 $a$ 的前若干项依次为：\n\n$1,2,4,8,16,21,42,51,102,112,224,235,470,486,972,990,1980$。\n\n可以证明，对于任意正整数 $x$，只存在唯一一对整数 $(p,q)$ 满足 $x=a_p-a_q$，定义为 $\\operatorname{repr}(x)$。\n\n比如 $\\operatorname{repr}(17)=(6,3)$，$\\operatorname{repr}(18)=(16,15)$。\n现有 $n$ 个询问，每次给定一个正整数 $x$，请求出 $\\operatorname{repr}(x)$。", "inputFormat": "第一行包含一个正整数 $n$。\n\n接下来 $n$ 行，每行一个正整数 $x$，表示一个询问。", "outputFormat": "输出 $n$ 行，每行两个正整数 $ p,q$，依次回答每个询问。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^5$，$1\\le x\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2017] Reprezentacje ró?nicowe", "background": "", "description": "给定一个数列 $a$：\n- 当 $n\\le 2$ 时，$a_n=n$。\n- 当 $n>2$，且 $n$ 是奇数时， $a_n=2\\times a_{n-1}$。\n- 当 $n>2$，且 $n$ 是偶数时，$a_n=a_{n-1}+r_{n-1}$。\n\n其中 $r_{n-1}= \\operatorname{mex}(|a_i-a_j|)(1\\le i\\le j\\le n-1)$， $\\operatorname{mex} \\left\\{ S\\right\\}$ 表示最小的不在 $S$ 集合里面的非负整数。\n\n数列 $a$ 的前若干项依次为：\n\n$1,2,4,8,16,21,42,51,102,112,224,235,470,486,972,990,1980$。\n\n可以证明，对于任意正整数 $x$，只存在唯一一对整数 $(p,q)$ 满足 $x=a_p-a_q$，定义为 $\\operatorname{repr}(x)$。\n\n比如 $\\operatorname{repr}(17)=(6,3)$，$\\operatorname{repr}(18)=(16,15)$。\n现有 $n$ 个询问，每次给定一个正整数 $x$，请求出 $\\operatorname{repr}(x)$。", "inputFormat": "第一行包含一个正整数 $n$。\n\n接下来 $n$ 行，每行一个正整数 $x$，表示一个询问。", "outputFormat": "输出 $n$ 行，每行两个正整数 $ p,q$，依次回答每个询问。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^5$，$1\\le x\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5969", "type": "P", "difficulty": 5, "samples": [["7\n1 2\n2 3\n4 3\n5 4\n6 3\n7 6", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "POI（波兰）"], "title": "[POI 2016] Nadajniki", "background": "", "description": "比特镇一共有 $n$ 个房子，编号依次为 $1$ 到 $n$，这些房子通过 $n-1$ 条无向道路连通在一起，形成了一棵树的结构。\n\nBytesear 要在比特镇实施 Wifi 搭建计划，他要让 Wifi 覆盖到比特镇的每一条道路。\n\nBytesear 可以安置无限多个 Wifi 发射器，但是只能安置在树上的节点上，一个房子可以安置多个 Wifi 发射器。\n\n对于一条道路 $(a,b)$，如果它满足以下两个条件之中的至少一个，那么这条边将被 Wifi 覆盖：\n- $a$ 点放置了 Wifi 发射器或者 $b$ 点放置了 Wifi 发射器。\n- 与 $a$ 点或 $b$ 点直接相邻的点中，至少放置了两个 Wifi 发射器。\n\n请帮助 Bytesear 规划一个最优的放置方案，使得 Wifi 覆盖到比特镇的每一条道路，且放置的 Wifi 发射器总数尽可能少。", "inputFormat": "第一行包含一个正整数 $n$，表示房子的总数。\n\n接下来 $n-1$ 行，每行两个正整数 $a,b$，表示 $a$ 点和 $b$ 点之间有一条边。", "outputFormat": "输出一行一个整数，即最少的 Wifi 发射器总数。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le2 \\times 10^5$，$1\\le a,b\\le n$。\n\n----\n\n### 样例解释：\n\n在 $3$ 号点放置两个 Wifi 发射器。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2016] Nadajniki", "background": "", "description": "比特镇一共有 $n$ 个房子，编号依次为 $1$ 到 $n$，这些房子通过 $n-1$ 条无向道路连通在一起，形成了一棵树的结构。\n\nBytesear 要在比特镇实施 Wifi 搭建计划，他要让 Wifi 覆盖到比特镇的每一条道路。\n\nBytesear 可以安置无限多个 Wifi 发射器，但是只能安置在树上的节点上，一个房子可以安置多个 Wifi 发射器。\n\n对于一条道路 $(a,b)$，如果它满足以下两个条件之中的至少一个，那么这条边将被 Wifi 覆盖：\n- $a$ 点放置了 Wifi 发射器或者 $b$ 点放置了 Wifi 发射器。\n- 与 $a$ 点或 $b$ 点直接相邻的点中，至少放置了两个 Wifi 发射器。\n\n请帮助 Bytesear 规划一个最优的放置方案，使得 Wifi 覆盖到比特镇的每一条道路，且放置的 Wifi 发射器总数尽可能少。", "inputFormat": "第一行包含一个正整数 $n$，表示房子的总数。\n\n接下来 $n-1$ 行，每行两个正整数 $a,b$，表示 $a$ 点和 $b$ 点之间有一条边。", "outputFormat": "输出一行一个整数，即最少的 Wifi 发射器总数。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le2 \\times 10^5$，$1\\le a,b\\le n$。\n\n----\n\n### 样例解释：\n\n在 $3$ 号点放置两个 Wifi 发射器。\n", "locale": "zh-CN"}}}
{"pid": "P5970", "type": "P", "difficulty": 5, "samples": [["5 2\n1 3 4 1 2", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "POI（波兰）"], "title": "[POI 2016] Nim z utrudnieniem", "background": "", "description": "A 和 B 两个人玩游戏，一共有 $m$ 颗石子，A 把它们分成了 $n$ 堆，每堆石子数分别为 $a_1,a_2,...,a_n$，每轮可以选择一堆石子，取掉任意颗石子，但不能不取。谁先不能操作，谁就输了。在游戏开始前，B 可以扔掉若干堆石子，但是必须保证扔掉的堆数是 $d$ 的倍数，且不能扔掉所有石子。\n\nA 先手，请问 B 有多少种扔的方式，使得 B 能够获胜。", "inputFormat": "第一行包含两个正整数 $n,d$。\n\n第二行包含 $n$ 个正整数 $a_1,a_2,...,a_n$。", "outputFormat": "输出一行一个整数，即方案数对 $10^9+7$ 取模的结果。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 5\\times 10^5$，$1\\le d\\le 10$，$1\\le a_i\\le 10^6$，$m$ 不直接给出，但数据保证 $1\\le m\\le 10^7$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2016] Nim z utrudnieniem", "background": "", "description": "A 和 B 两个人玩游戏，一共有 $m$ 颗石子，A 把它们分成了 $n$ 堆，每堆石子数分别为 $a_1,a_2,...,a_n$，每轮可以选择一堆石子，取掉任意颗石子，但不能不取。谁先不能操作，谁就输了。在游戏开始前，B 可以扔掉若干堆石子，但是必须保证扔掉的堆数是 $d$ 的倍数，且不能扔掉所有石子。\n\nA 先手，请问 B 有多少种扔的方式，使得 B 能够获胜。", "inputFormat": "第一行包含两个正整数 $n,d$。\n\n第二行包含 $n$ 个正整数 $a_1,a_2,...,a_n$。", "outputFormat": "输出一行一个整数，即方案数对 $10^9+7$ 取模的结果。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 5\\times 10^5$，$1\\le d\\le 10$，$1\\le a_i\\le 10^6$，$m$ 不直接给出，但数据保证 $1\\le m\\le 10^7$。", "locale": "zh-CN"}}}
{"pid": "P5971", "type": "P", "difficulty": 5, "samples": [["5\n1 2 1 3 3", "8"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["贪心", "2009", "CTSC/CTS"], "title": "[CTSC2009] 移盘子", "background": "", "description": "已知有三根柱子，分别记为 $A$， $B$ 和 $C$。初始状态时 $A$ 上放有 $N$ 个盘子，而 $B$ 和 $C$ 两个柱子上没有放任何盘子。你每次能做的移动操作就是把某根柱子最上面的一个盘子拿下来，然后放到另一个柱子上。盘子有三类，分别用 $1$， $2$， $3$ 来表示。你的目标是，让所有 $1$ 类盘子最终放在 $A$ 上，让所有 $2$ 类盘子最终放在 $B$ 上，所有 $3$ 类盘子最终放在 $C$ 上。现在让你求出实现上述目标总共最少需要多少次移动？", "inputFormat": "输入文件 trique.in 第一行包含一个整数 $N$，为盘子的总数。\n第二行有 $N$ 个数，每个数只能是 $1$， $2$， $3$ 之一。这 $N$ 个数表示在初始状态时第一个柱子上所有盘子的类型，按照从上往下的顺序。", "outputFormat": "输出文件 trique.out 只包含一个数，即最少的移动次数。", "hint": "### 样例说明\n初始状态如下图：\n![](https://cdn.luogu.com.cn/upload/image_hosting/caccgwlp.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/d686q4vz.png)\n\n### 数据范围\n对于 $20$%的数据， 盘子的种类不超过 $2$ 种；\n\n对于 $40$%的数据， $N \\leq 300$；\n\n对于 $100$%的数据， $N \\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2009] Moving Plates", "background": "", "description": "There are three pegs, named $A$, $B$, and $C$. Initially, $A$ has $N$ plates on it, while $B$ and $C$ are empty. Each move consists of taking the top plate from one peg and placing it onto another peg. Plates are of three types, denoted by $1$, $2$, and $3$. Your goal is to have all type $1$ plates on $A$, all type $2$ plates on $B$, and all type $3$ plates on $C$ in the end. Find the minimum number of moves needed to achieve this goal.", "inputFormat": "The input file trique.in contains:\n- The first line: an integer $N$, the total number of plates.\n- The second line: $N$ numbers, each being $1$, $2$, or $3$. These $N$ numbers describe the types of all plates initially on peg $A$, listed from top to bottom.", "outputFormat": "The output file trique.out contains a single number: the minimum number of moves.", "hint": "Sample explanation:\nInitial state as shown below:\n![](https://cdn.luogu.com.cn/upload/image_hosting/caccgwlp.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/d686q4vz.png)\n\nConstraints:\n- For $20$% of the testdata, the number of plate types does not exceed $2$.\n- For $40$% of the testdata, $N \\leq 300$.\n- For $100$% of the testdata, $N \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2009] 移盘子", "background": "", "description": "已知有三根柱子，分别记为 $A$， $B$ 和 $C$。初始状态时 $A$ 上放有 $N$ 个盘子，而 $B$ 和 $C$ 两个柱子上没有放任何盘子。你每次能做的移动操作就是把某根柱子最上面的一个盘子拿下来，然后放到另一个柱子上。盘子有三类，分别用 $1$， $2$， $3$ 来表示。你的目标是，让所有 $1$ 类盘子最终放在 $A$ 上，让所有 $2$ 类盘子最终放在 $B$ 上，所有 $3$ 类盘子最终放在 $C$ 上。现在让你求出实现上述目标总共最少需要多少次移动？", "inputFormat": "输入文件 trique.in 第一行包含一个整数 $N$，为盘子的总数。\n第二行有 $N$ 个数，每个数只能是 $1$， $2$， $3$ 之一。这 $N$ 个数表示在初始状态时第一个柱子上所有盘子的类型，按照从上往下的顺序。", "outputFormat": "输出文件 trique.out 只包含一个数，即最少的移动次数。", "hint": "### 样例说明\n初始状态如下图：\n![](https://cdn.luogu.com.cn/upload/image_hosting/caccgwlp.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/d686q4vz.png)\n\n### 数据范围\n对于 $20$%的数据， 盘子的种类不超过 $2$ 种；\n\n对于 $40$%的数据， $N \\leq 300$；\n\n对于 $100$%的数据， $N \\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P5972", "type": "P", "difficulty": 7, "samples": [["5\n5 3 1 4 2", "0 5\n0 3\n1 2\n3 1\n7 1"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2019", "O2优化", "动态规划优化", "状态合并", "均摊分析", "折半搜索 meet in the middle", "PA（波兰）", "状压 DP"], "title": "[PA 2019] Desant", "background": "", "description": "给定一个 $1$ 到 $n$ 的排列 $a_{1..n}$，它有 $2^n-1$ 个非空子序列。\n\n请对于每个 $k$，找到一个长度为 $k$ 的子序列，使得这个子序列的逆序对数量最少，并输出逆序对数量最少的子序列的数量。", "inputFormat": "第一行包含一个正整数 $n$。\n\n第二行包含 $n$ 个正整数 $a_1,a_2,...,a_n$。", "outputFormat": "输出 $n$ 行，每行两个整数，第 $k$ 行输出长度为 $k$ 的子序列中逆序对数量的最小值以及满足这个最小值的子序列数量。", "hint": "对于 $100\\%$ 的数据，$1\\le k\\le n$，$1\\le n\\le 40$，$1\\le a_i\\le n,a_i\\ne a_j$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Desant", "background": "", "description": "给定一个 $1$ 到 $n$ 的排列 $a_{1..n}$，它有 $2^n-1$ 个非空子序列。\n\n请对于每个 $k$，找到一个长度为 $k$ 的子序列，使得这个子序列的逆序对数量最少，并输出逆序对数量最少的子序列的数量。", "inputFormat": "第一行包含一个正整数 $n$。\n\n第二行包含 $n$ 个正整数 $a_1,a_2,...,a_n$。", "outputFormat": "输出 $n$ 行，每行两个整数，第 $k$ 行输出长度为 $k$ 的子序列中逆序对数量的最小值以及满足这个最小值的子序列数量。", "hint": "对于 $100\\%$ 的数据，$1\\le k\\le n$，$1\\le n\\le 40$，$1\\le a_i\\le n,a_i\\ne a_j$。", "locale": "zh-CN"}}}
{"pid": "P5973", "type": "P", "difficulty": 4, "samples": [["3\n15 2\n24 4\n24 5", "TAK\nTAK\nNIE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "PA（波兰）"], "title": "[PA 2013] Iloczyn", "background": null, "description": "给定正整数 $n$ 和 $k$，问能否将 $n$ 分解为 $k$ 个不同正整数的乘积。", "inputFormat": "第一行一个数 $T$ 表示测试组数。\n\n接下来 $T$ 行每行两个数 $n,k$。", "outputFormat": "输出 $T$ 行，若可以被分解，输出 `TAK`；否则输出 `NIE`。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 4\\times 10^3$，$1\\le n\\le 10^9$，$1\\le k\\le 20$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2013] Iloczyn", "background": null, "description": "给定正整数 $n$ 和 $k$，问能否将 $n$ 分解为 $k$ 个不同正整数的乘积。", "inputFormat": "第一行一个数 $T$ 表示测试组数。\n\n接下来 $T$ 行每行两个数 $n,k$。", "outputFormat": "输出 $T$ 行，若可以被分解，输出 `TAK`；否则输出 `NIE`。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 4\\times 10^3$，$1\\le n\\le 10^9$，$1\\le k\\le 20$。", "locale": "zh-CN"}}}
{"pid": "P5974", "type": "P", "difficulty": 6, "samples": [["10 5 \n1 8 \n2 6 \n4 8 \n2 2 \n9 7 \n8 5 \n5 3 \n3 3 \n4 6 \n4 1 ", "2.236068 \n3 4 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2006", "Special Judge", "CEOI（中欧）"], "title": "[CEOI 2006] ANTENNA", "background": "", "description": "给出 $N$ 个点的坐标，要求能够覆盖其中至少 $K$ 个点的圆的最小半径及圆心位置。", "inputFormat": "第一行两个整数 $N,K$。\n\n接下来的 $N$ 行，每行两个整数，为每个点的坐标。", "outputFormat": "第一行为圆的半径。\n\n第二行为圆心的坐标。\n\n使用 SPJ，满足以下两个条件才正确：\n\n- $R$ 误差不超过 $10^{-4}$。\n\n- 虽然多组解可以输出任意一组，但以你输出的坐标为圆心的圆如果以 $R+0.0002$为半径至少应该覆盖 $K$个点。", "hint": "对于 $100\\%$ 的数据， $2\\le K\\le N\\le 500$，$0\\le X,Y\\le 10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2006] ANTENNA", "background": "", "description": "给出 $N$ 个点的坐标，要求能够覆盖其中至少 $K$ 个点的圆的最小半径及圆心位置。", "inputFormat": "第一行两个整数 $N,K$。\n\n接下来的 $N$ 行，每行两个整数，为每个点的坐标。", "outputFormat": "第一行为圆的半径。\n\n第二行为圆心的坐标。\n\n使用 SPJ，满足以下两个条件才正确：\n\n- $R$ 误差不超过 $10^{-4}$。\n\n- 虽然多组解可以输出任意一组，但以你输出的坐标为圆心的圆如果以 $R+0.0002$为半径至少应该覆盖 $K$个点。", "hint": "对于 $100\\%$ 的数据， $2\\le K\\le N\\le 500$，$0\\le X,Y\\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P5975", "type": "P", "difficulty": 5, "samples": [["6 4\n2 1 \n4 1 \n5 1 \n5 4 \n7 1 \n6 4", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2009", "CEOI（中欧）"], "title": "[CEOI 2009] photo", "background": "", "description": "平面上有若干个点，现在要求用最少的底边在 $X$ 轴上且面积小于等于 $A$ 的矩形覆盖所有点，这些矩形可以重叠。 矩形顶点不必是整点。", "inputFormat": "第一行两个整数 $N,A$。 \n\n以下 $N$ 行输入点坐标。", "outputFormat": "最少的矩形个数。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 100$，$1\\le A\\le 2\\times 10^6$。坐标范围在 $[0,100000]$ 之间。\n\n------\n\n## 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8p4pjwmq.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2009] photo", "background": "", "description": "平面上有若干个点，现在要求用最少的底边在 $X$ 轴上且面积小于等于 $A$ 的矩形覆盖所有点，这些矩形可以重叠。 矩形顶点不必是整点。", "inputFormat": "第一行两个整数 $N,A$。 \n\n以下 $N$ 行输入点坐标。", "outputFormat": "最少的矩形个数。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 100$，$1\\le A\\le 2\\times 10^6$。坐标范围在 $[0,100000]$ 之间。\n\n------\n\n## 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8p4pjwmq.png)", "locale": "zh-CN"}}}
{"pid": "P5976", "type": "P", "difficulty": 4, "samples": [["10 10\n3\nW 3 6 3\nB 6 4 2\nW 3 3 2", "30 9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "CEOI（中欧）"], "title": "[CEOI 2008] Dominance", "background": "", "description": "给出一个宽为 $W$，高为 $H$ 的矩形 。\n \n在它上面有两种点， $black$ 及 $white$。 每个点都有自己的辐射范围。对于其它的点如果它受到白点的辐射多于黑色的，则为白点，反之亦然，如果相同的话则中立。\n\n现给出白点及黑色的坐标及各自的辐射范围，问最后白色点一共有多少个，黑色点共有多少个 。", "inputFormat": "第一行给出 $W$ 和 $H$，左下角坐标为 $(0,0)$, 右上角为 $(W-1,H-1)$。  \n\n第二行给出数字 $N$，代表有多少个点。 \n\n接下来 $N$ 行，每行先给出点的属性，再给出坐标，再给出辐射范围(在$[0, 5\\times 10^8)$)", "outputFormat": "两个数，分别代表白色点有多少个，黑色点有多少个 。", "hint": "对于 $100\\%$ 的数据，$1 \\le  W,H \\le 10^9$，$0 \\le  N \\le  3\\times 10^3$。\n\n\n-----\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hfu3bgfx.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2008] Dominance", "background": "", "description": "给出一个宽为 $W$，高为 $H$ 的矩形 。\n \n在它上面有两种点， $black$ 及 $white$。 每个点都有自己的辐射范围。对于其它的点如果它受到白点的辐射多于黑色的，则为白点，反之亦然，如果相同的话则中立。\n\n现给出白点及黑色的坐标及各自的辐射范围，问最后白色点一共有多少个，黑色点共有多少个 。", "inputFormat": "第一行给出 $W$ 和 $H$，左下角坐标为 $(0,0)$, 右上角为 $(W-1,H-1)$。  \n\n第二行给出数字 $N$，代表有多少个点。 \n\n接下来 $N$ 行，每行先给出点的属性，再给出坐标，再给出辐射范围(在$[0, 5\\times 10^8)$)", "outputFormat": "两个数，分别代表白色点有多少个，黑色点有多少个 。", "hint": "对于 $100\\%$ 的数据，$1 \\le  W,H \\le 10^9$，$0 \\le  N \\le  3\\times 10^3$。\n\n\n-----\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hfu3bgfx.png)", "locale": "zh-CN"}}}
{"pid": "P5977", "type": "P", "difficulty": 6, "samples": [["4 3\n800 300\n200 200\n200 700\n600 700\n400 300\n600 500\n800 900", "171"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "计算几何", "2008", "CEOI（中欧）", "最短路", "凸包"], "title": "[CEOI 2008] Fence", "background": "", "description": "在一个大小为 $1000\\times 1000$ 的区域中，有 $n$ 个固定点, $m$ 棵树 。\n\n现在你要建一个围栏来保护树，建它的费用为你选用的固定点的个数 $\\times 20$ +你没有圈进围栏的树 $\\times 111$。\n\n现在希望这个值越小越好，求最小值。", "inputFormat": "第一行给出 $n,m$。\n\n接下来的 $n$ 行，给出固定的坐标。\n\n接下来的 $m$ 行，给出树的坐标。", "outputFormat": "输出最小费用。\n", "hint": "对于 $100\\%$ 的数据，$3\\le N,M\\le 100$。\n\n----\n\n## 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7vebu0t2.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2008] Fence", "background": "", "description": "在一个大小为 $1000\\times 1000$ 的区域中，有 $n$ 个固定点, $m$ 棵树 。\n\n现在你要建一个围栏来保护树，建它的费用为你选用的固定点的个数 $\\times 20$ +你没有圈进围栏的树 $\\times 111$。\n\n现在希望这个值越小越好，求最小值。", "inputFormat": "第一行给出 $n,m$。\n\n接下来的 $n$ 行，给出固定的坐标。\n\n接下来的 $m$ 行，给出树的坐标。", "outputFormat": "输出最小费用。\n", "hint": "对于 $100\\%$ 的数据，$3\\le N,M\\le 100$。\n\n----\n\n## 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7vebu0t2.png)", "locale": "zh-CN"}}}
{"pid": "P5978", "type": "P", "difficulty": 4, "samples": [["8 10\n7 3 5 12 2 7 3 4", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "CEOI（中欧）"], "title": "[CEOI 2018] Global warming", "background": null, "description": "给定 $n$，你可以将任意 $a_l$ 至 $a_r$（$1\\le l\\le r\\le n$）每一个元素加上一个 $d$（$-x\\le d\\le x$），求 $a$ 数组的最大严格上升子序列长度。", "inputFormat": "第一行两个整数 $n,x$。\n\n第二行 $n$ 个整数表示 $a_1$ 至 $a_n$。", "outputFormat": "一个数，即 $a$ 数组的最大严格上升子序列长度。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 2\\times 10^5$，$0\\leq x\\leq10^9$，$1\\leq a_i\\leq10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2018] Global warming", "background": null, "description": "给定 $n$，你可以将任意 $a_l$ 至 $a_r$（$1\\le l\\le r\\le n$）每一个元素加上一个 $d$（$-x\\le d\\le x$），求 $a$ 数组的最大严格上升子序列长度。", "inputFormat": "第一行两个整数 $n,x$。\n\n第二行 $n$ 个整数表示 $a_1$ 至 $a_n$。", "outputFormat": "一个数，即 $a$ 数组的最大严格上升子序列长度。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 2\\times 10^5$，$0\\leq x\\leq10^9$，$1\\leq a_i\\leq10^9$。", "locale": "zh-CN"}}}
{"pid": "P5979", "type": "P", "difficulty": 7, "samples": [["9\n1 4\n2 5\n3 4\n1 5\n1 1\n2 5\n3 5\n1 3\n1 1", "5 2"], ["2\n1 1\n2 2", "NIE"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "线段树", "cdq 分治", "动态规划优化", "扫描线", "PA（波兰）"], "title": "[PA 2014] Druzyny", "background": "", "description": "体育课上，$n$ 个小朋友排成一行（从 $1$ 到 $n$ 编号），老师想把他们分成若干组，每一组都包含编号连续的一段小朋友，每个小朋友属于且仅属于一个组。\n\n第 $i$ 个小朋友希望它所在的组的人数不多于 $d_i$，不少于 $c_i$，否则他就会不满意。\n\n在所有小朋友都满意的前提下，求可以分成的组的数目的最大值，以及有多少种分组方案能达到最大值。", "inputFormat": "第一行一个整数 $n$，表示小朋友的数目。\n\n接下来 $n$ 行，每行两个整数 $c_i,d_i$，表示 $i$ 所在组的人数的最小值和最大值。", "outputFormat": "如果不存在这样的方案，仅输出一行  `NIE`。\n\n否则输出一行包含两个整数，组的数目的最大值、方案数量。（方案数量对 $10^9+7$ 取模）", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le c_i\\le d_i\\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2014] Druzyny", "background": "", "description": "体育课上，$n$ 个小朋友排成一行（从 $1$ 到 $n$ 编号），老师想把他们分成若干组，每一组都包含编号连续的一段小朋友，每个小朋友属于且仅属于一个组。\n\n第 $i$ 个小朋友希望它所在的组的人数不多于 $d_i$，不少于 $c_i$，否则他就会不满意。\n\n在所有小朋友都满意的前提下，求可以分成的组的数目的最大值，以及有多少种分组方案能达到最大值。", "inputFormat": "第一行一个整数 $n$，表示小朋友的数目。\n\n接下来 $n$ 行，每行两个整数 $c_i,d_i$，表示 $i$ 所在组的人数的最小值和最大值。", "outputFormat": "如果不存在这样的方案，仅输出一行  `NIE`。\n\n否则输出一行包含两个整数，组的数目的最大值、方案数量。（方案数量对 $10^9+7$ 取模）", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le c_i\\le d_i\\le n$。", "locale": "zh-CN"}}}
{"pid": "P5980", "type": "P", "difficulty": 6, "samples": [["5\n2\n2 1 4\n2 5 2\n2\n1 4 3\n1 5 4\n2\n1 5 7\n1 7 5\n2\n1 4 1\n1 2 5\n3\n2 6 4\n1 2 3\n3 4 5", "TAK\nNIE\nTAK\nNIE\nTAK"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "向量", "凸包", "PA（波兰）"], "title": "[PA 2019] Herbata", "background": null, "description": "你有无穷多个容量无限的杯子以及 $n$ 杯水，第 $i$ 杯水的体积为 $l_i$，温度为 $a_i$。\n\n你可以做无限次操作，每次操作是下面两种操作之一：\n1. 选择一杯水，假设它的体积为 $V$，温度为 $T$，那么你可以将其倒入若干个空杯中，使得每一杯的水的温度都为 $T$，且体积之和等于 $V$，注意体积可以是任意非负实数。\n\n2. 选择两杯水，假设一杯的体积为 $V_a$，温度为 $T_a$，另一杯的体积为 $V_b$，温度为 $T_b$，那么你可以将这两杯水混合为一杯体积为 $V_a+V_b$，温度为 $\\dfrac{V_a\\times T_a+V_b\\times T_b}{V_a+V_b}$的水。\n\n你的目标进行若干次操作，使得操作完毕后，对于所有的 $i(1\\le i\\le n)$ 都有第 $i$ 杯水的体积等于 $l_i$，温度等于 $b_i$。请写一个程序判断是否有解。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n每组测试数据第一行包含一个正整数 $n$。\n接下来 $n$ 行，每行三个正整数 $l_i,a_i,b_i$。", "outputFormat": "对于每组数据输出一行，如果有解，输出 `TAK`，否则输出 `NIE`。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 10^5$，$1\\le n\\le 10^5$，$1\\le l_i,a_i,b_i\\le 10^6$，输入数据保证所有的 $n$ 加起来不超过 $10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Herbata", "background": null, "description": "你有无穷多个容量无限的杯子以及 $n$ 杯水，第 $i$ 杯水的体积为 $l_i$，温度为 $a_i$。\n\n你可以做无限次操作，每次操作是下面两种操作之一：\n1. 选择一杯水，假设它的体积为 $V$，温度为 $T$，那么你可以将其倒入若干个空杯中，使得每一杯的水的温度都为 $T$，且体积之和等于 $V$，注意体积可以是任意非负实数。\n\n2. 选择两杯水，假设一杯的体积为 $V_a$，温度为 $T_a$，另一杯的体积为 $V_b$，温度为 $T_b$，那么你可以将这两杯水混合为一杯体积为 $V_a+V_b$，温度为 $\\dfrac{V_a\\times T_a+V_b\\times T_b}{V_a+V_b}$的水。\n\n你的目标进行若干次操作，使得操作完毕后，对于所有的 $i(1\\le i\\le n)$ 都有第 $i$ 杯水的体积等于 $l_i$，温度等于 $b_i$。请写一个程序判断是否有解。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n每组测试数据第一行包含一个正整数 $n$。\n接下来 $n$ 行，每行三个正整数 $l_i,a_i,b_i$。", "outputFormat": "对于每组数据输出一行，如果有解，输出 `TAK`，否则输出 `NIE`。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 10^5$，$1\\le n\\le 10^5$，$1\\le l_i,a_i,b_i\\le 10^6$，输入数据保证所有的 $n$ 加起来不超过 $10^6$。", "locale": "zh-CN"}}}
{"pid": "P5981", "type": "P", "difficulty": 7, "samples": [["2\n3 1 0 1\n4 0 0 0 1\n2 0 1\n1 1", "6 0 1 0 1 0 1\n2 0 1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432]}, "tags": ["2019", "PA（波兰）"], "title": "[PA 2019] Iloczyny Fibonacciego", "background": "", "description": "定义斐波那契数列为 $F_1=1,F_2=2,F_i=F_{i-1}+F_{i-2}(i\\ge 3)$。\n对于任意一个正整数 $x$，我们总能将 $x$ 写成唯一的斐波那契表示 $(b_1,b_2,...,b_n)$，满足：\n\n1. $b_1\\times F_1+b_2\\times F_2+...+b_n\\times F_n=x$。\n2. 对于任意的 $i(1\\le i<n)$ 都有 $b_i=0$ 或 $b_i=1$；对于 $b_n$ 有 $b_n=1$。\n3. 对于任意的 $i(1\\le i<n)$ 都有 $b_i\\times b_{i+1}=0$。\n\n比如 $2=(0,1),4=(1,0,1),5=(0,0,0,1),20=(0,1,0,1,0,1)=F[2]+F[4]+F[6]=2+5+13$。\n\n给定两个斐波那契表示的正整数 $A$ 和 $B$，请输出 $A\\times B$ 的斐波那契表示。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n\n每组测试数据包含两行，分别描述 $A$ 和 $B$ 的斐波那契表示。每行首先是一个正整数 $n$，然后 $n$ 个非负整数 $b_1,b_2,...,b_n$。\n", "outputFormat": "对于每组数据输出一行，按照输入格式输出 $A\\times B$的斐波那契表示。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 10^3$，输入数据保证所有的 $n$ 加起来不超过 $10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Iloczyny Fibonacciego", "background": "", "description": "定义斐波那契数列为 $F_1=1,F_2=2,F_i=F_{i-1}+F_{i-2}(i\\ge 3)$。\n对于任意一个正整数 $x$，我们总能将 $x$ 写成唯一的斐波那契表示 $(b_1,b_2,...,b_n)$，满足：\n\n1. $b_1\\times F_1+b_2\\times F_2+...+b_n\\times F_n=x$。\n2. 对于任意的 $i(1\\le i<n)$ 都有 $b_i=0$ 或 $b_i=1$；对于 $b_n$ 有 $b_n=1$。\n3. 对于任意的 $i(1\\le i<n)$ 都有 $b_i\\times b_{i+1}=0$。\n\n比如 $2=(0,1),4=(1,0,1),5=(0,0,0,1),20=(0,1,0,1,0,1)=F[2]+F[4]+F[6]=2+5+13$。\n\n给定两个斐波那契表示的正整数 $A$ 和 $B$，请输出 $A\\times B$ 的斐波那契表示。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n\n每组测试数据包含两行，分别描述 $A$ 和 $B$ 的斐波那契表示。每行首先是一个正整数 $n$，然后 $n$ 个非负整数 $b_1,b_2,...,b_n$。\n", "outputFormat": "对于每组数据输出一行，按照输入格式输出 $A\\times B$的斐波那契表示。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 10^3$，输入数据保证所有的 $n$ 加起来不超过 $10^6$。", "locale": "zh-CN"}}}
{"pid": "P5982", "type": "P", "difficulty": 6, "samples": [["5\n2 10110\n0 11010\n1 00000", "19"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "排列组合", "前缀和", "PA（波兰）"], "title": "[PA 2019] Trzy kule", "background": "", "description": "对于两个长度为 $n$ 的 $01$ 串 $a_{1..n},b_{1..n}$，定义它们的距离 $\\operatorname{d(a,b)}=|a_1-b_1|+|a_2-b_2|+...+|a_n-b_n|$。\n\n给定三个长度为 $n$的 $01$ 串 $s_1,s_2,s_3$以及三个非负整数 $r_1,r_2,r_3(0\\le r_i\\le n)$，问有多少个长度为 $n$ 的 $01$ 串 $S$满足$\\operatorname{d(S,s[1])}\\le r_1,\\operatorname{d(S,s[2])}\\le r_2,\\operatorname{d(S,s[3])}\\le r_3$ 这三个不等式中至少有一个成立。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行一个非负整数 $r_1$，然后一个长度为 $n$ 的 $01$ 串 $s_1$。\n\n第三行一个非负整数 $r_2$，然后一个长度为 $n$ 的 $01$ 串 $s_2$。\n\n第四行一个非负整数 $r_3$，然后一个长度为 $n$  的 $01$ 串 $s_3$。", "outputFormat": "输出一行一个整数，即满足条件的 $S$ 的数量模 $10^9+7$。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Trzy kule", "background": "", "description": "对于两个长度为 $n$ 的 $01$ 串 $a_{1..n},b_{1..n}$，定义它们的距离 $\\operatorname{d(a,b)}=|a_1-b_1|+|a_2-b_2|+...+|a_n-b_n|$。\n\n给定三个长度为 $n$的 $01$ 串 $s_1,s_2,s_3$以及三个非负整数 $r_1,r_2,r_3(0\\le r_i\\le n)$，问有多少个长度为 $n$ 的 $01$ 串 $S$满足$\\operatorname{d(S,s[1])}\\le r_1,\\operatorname{d(S,s[2])}\\le r_2,\\operatorname{d(S,s[3])}\\le r_3$ 这三个不等式中至少有一个成立。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行一个非负整数 $r_1$，然后一个长度为 $n$ 的 $01$ 串 $s_1$。\n\n第三行一个非负整数 $r_2$，然后一个长度为 $n$ 的 $01$ 串 $s_2$。\n\n第四行一个非负整数 $r_3$，然后一个长度为 $n$  的 $01$ 串 $s_3$。", "outputFormat": "输出一行一个整数，即满足条件的 $S$ 的数量模 $10^9+7$。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P5983", "type": "P", "difficulty": 6, "samples": [["3 5 7\n0 1 123\n1 0 0\n4 8 0\n2 2 16\n2 3 0\n18 19 17\n3 0 0", "NIE\nTAK\nNIE\nTAK\nNIE\nTAK\nNIE"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "PA（波兰）"], "title": "[PA 2019] Osady i warownie 2", "background": "", "description": "$n\\times m$ 的网格，从上到下依次为第 $0$ 到 $n-1$ 行，从左到右依次为第 $0$ 到 $m-1$ 列，每个点都不是障碍格。\n\n定义一条从起点 $(0,0)$ 到终点 $(n-1,m-1)$ 的路径是合法的，当且仅当这条路径经过恰好 $n+m-1$ 个格子(包括起点和终点)，且每一步要么往右走一格，要么往下走一格。当然，这条路径不能经过障碍格(包括起点和终点)。\n\n你有一个 $int$ 变量 $v=0$，你现在需要模拟 $k$ 次操作，每次操作会给出三个非负整数 $r,c,z$，令 $x=(r \\operatorname{xor}\n v)\\bmod n,y=(c \\operatorname{xor}\n v)\\bmod m$：\n1. 如果 $(x,y)$ 是障碍格，那么忽略这次操作，输出 `NIE`。\n2. 否则如果将 $(x,y)$ 变成障碍格后仍然存在合法路径，那么将 $(x,y)$ 变成障碍格，输出 `NIE`。\n3. 否则如果将 $(x,y)$ 变成障碍格后不存在合法路径，那么输出 `TAK`，并将 $v $ 修改为 $v \\operatorname{xor} z$。", "inputFormat": "第一行三个正整数 $n,m,k$。\n\n接下来 $k$ 行，每行三个非负整数 $r,c,z$。", "outputFormat": "对于每个操作输出一行 `TAK` 或 `NIE`。", "hint": "对于 $100\\%$ 的数据,$2\\le n,m\\le 10^5$， $1\\le k\\le 10^6$，$0\\le r,c,z<2^{20}$。\n\n----\n\n\n### 解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e5k1plm4.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Osady i warownie 2", "background": "", "description": "$n\\times m$ 的网格，从上到下依次为第 $0$ 到 $n-1$ 行，从左到右依次为第 $0$ 到 $m-1$ 列，每个点都不是障碍格。\n\n定义一条从起点 $(0,0)$ 到终点 $(n-1,m-1)$ 的路径是合法的，当且仅当这条路径经过恰好 $n+m-1$ 个格子(包括起点和终点)，且每一步要么往右走一格，要么往下走一格。当然，这条路径不能经过障碍格(包括起点和终点)。\n\n你有一个 $int$ 变量 $v=0$，你现在需要模拟 $k$ 次操作，每次操作会给出三个非负整数 $r,c,z$，令 $x=(r \\operatorname{xor}\n v)\\bmod n,y=(c \\operatorname{xor}\n v)\\bmod m$：\n1. 如果 $(x,y)$ 是障碍格，那么忽略这次操作，输出 `NIE`。\n2. 否则如果将 $(x,y)$ 变成障碍格后仍然存在合法路径，那么将 $(x,y)$ 变成障碍格，输出 `NIE`。\n3. 否则如果将 $(x,y)$ 变成障碍格后不存在合法路径，那么输出 `TAK`，并将 $v $ 修改为 $v \\operatorname{xor} z$。", "inputFormat": "第一行三个正整数 $n,m,k$。\n\n接下来 $k$ 行，每行三个非负整数 $r,c,z$。", "outputFormat": "对于每个操作输出一行 `TAK` 或 `NIE`。", "hint": "对于 $100\\%$ 的数据,$2\\le n,m\\le 10^5$， $1\\le k\\le 10^6$，$0\\le r,c,z<2^{20}$。\n\n----\n\n\n### 解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e5k1plm4.png)", "locale": "zh-CN"}}}
{"pid": "P5984", "type": "P", "difficulty": 7, "samples": [["5 8\n1 2 1\n3 1 3\n3 4 1\n5 3 2", "135"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "PA（波兰）"], "title": "[PA 2019] Podatki drogowe", "background": "", "description": "给定一棵 $n$ 个点的无根树，点的编号为 $1$ 到 $n$，边的边权均为 $n$ 的正整数次幂。\n定义 $u$ 到 $v$ 的距离 $\\operatorname{d(u,v)}$ 为 $u$ 和 $v$ 在树上的简单路径经过的边的边权之和。\n\n给定 $k$，请在 $\\dfrac{n\\times (n-1)}{2}$ 个 $\\operatorname{d(u,v)}(1\\le u<v\\le n)$ 中找到第 $k$ 小的值。", "inputFormat": "第一行两个正整数 $n,k$。\n\n接下来 $n-1$ 行，每行三个正整数 $x,y,z(1\\le x,y,z\\le n)$，表示一条连接 $x$ 和 $y$ 的树边，其边权为 $n$ 的 $z$ 次方。", "outputFormat": "输出一行一个整数，即第 $k$ 小的值对 $10^9+7$ 取模的结果。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 2.5\\times 10^4$，$1\\le k\\le \\dfrac{n*(n-1)}{2}$。\n\n\n----\n\n\n\n### 样例解释：\n\n所有的 $d$ 排序后依次为： $5,5,25,30,125,130,130,135,150,155$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Podatki drogowe", "background": "", "description": "给定一棵 $n$ 个点的无根树，点的编号为 $1$ 到 $n$，边的边权均为 $n$ 的正整数次幂。\n定义 $u$ 到 $v$ 的距离 $\\operatorname{d(u,v)}$ 为 $u$ 和 $v$ 在树上的简单路径经过的边的边权之和。\n\n给定 $k$，请在 $\\dfrac{n\\times (n-1)}{2}$ 个 $\\operatorname{d(u,v)}(1\\le u<v\\le n)$ 中找到第 $k$ 小的值。", "inputFormat": "第一行两个正整数 $n,k$。\n\n接下来 $n-1$ 行，每行三个正整数 $x,y,z(1\\le x,y,z\\le n)$，表示一条连接 $x$ 和 $y$ 的树边，其边权为 $n$ 的 $z$ 次方。", "outputFormat": "输出一行一个整数，即第 $k$ 小的值对 $10^9+7$ 取模的结果。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 2.5\\times 10^4$，$1\\le k\\le \\dfrac{n*(n-1)}{2}$。\n\n\n----\n\n\n\n### 样例解释：\n\n所有的 $d$ 排序后依次为： $5,5,25,30,125,130,130,135,150,155$。", "locale": "zh-CN"}}}
{"pid": "P5985", "type": "P", "difficulty": 6, "samples": [["3 5\n2 -1 3", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "PA（波兰）"], "title": "[PA 2019] Muzyka pop", "background": "", "description": "给定 $ n$ 个整数 $a_{1..n}$，请找到 $n$ 个非负整数 $b_{1..n}$，使得 $a_1\\times \\operatorname{f(b_1)}+a_2\\times \\operatorname{f(b_2)}+...+a_n\\times \\operatorname{f(b_n)}$ 的值最大，其中 $\\operatorname{f(x)} $ 为 $x$ 在二进制下的 $1$ 的个数。\n\n你找到的这 $n$ 个非负整数 $b_{1..n}$ 需要满足 $0\\le b_1<b_2<...<b_n\\le m$。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行包含 $n$ 个整数 $a_1,a_2,...,a_n$。", "outputFormat": "输出一行一个整数，即 $a_1\\times \\operatorname{f(b_1)}+a_2\\times \\operatorname{f(b_2)}+...+a_n\\times \\operatorname{f(b_n)}$ 的最大值。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 200$，$n-1\\le m\\le 10^{18}$，$|a_i|\\le 10^{14}$。\n\n----\n\n### 解释：\n\n$b_1=3,b_2=4,b_3=5$，则答案为 $2\\times 2+(-1)\\times 1+3\\times 2=9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Muzyka pop", "background": "", "description": "给定 $ n$ 个整数 $a_{1..n}$，请找到 $n$ 个非负整数 $b_{1..n}$，使得 $a_1\\times \\operatorname{f(b_1)}+a_2\\times \\operatorname{f(b_2)}+...+a_n\\times \\operatorname{f(b_n)}$ 的值最大，其中 $\\operatorname{f(x)} $ 为 $x$ 在二进制下的 $1$ 的个数。\n\n你找到的这 $n$ 个非负整数 $b_{1..n}$ 需要满足 $0\\le b_1<b_2<...<b_n\\le m$。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行包含 $n$ 个整数 $a_1,a_2,...,a_n$。", "outputFormat": "输出一行一个整数，即 $a_1\\times \\operatorname{f(b_1)}+a_2\\times \\operatorname{f(b_2)}+...+a_n\\times \\operatorname{f(b_n)}$ 的最大值。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 200$，$n-1\\le m\\le 10^{18}$，$|a_i|\\le 10^{14}$。\n\n----\n\n### 解释：\n\n$b_1=3,b_2=4,b_3=5$，则答案为 $2\\times 2+(-1)\\times 1+3\\times 2=9$。", "locale": "zh-CN"}}}
{"pid": "P5986", "type": "P", "difficulty": 6, "samples": [["4\n1 4 8 1\n15\n1 2 3\n1 2 4\n1 2 5\n1 3 3\n1 3 5\n1 3 16\n1 4 16\n1 8 17\n1 100 101\n1 100 115\n1 3 9\n2 2\n1 3 9\n3 4\n1 3 9", "1\n2\n-1\n0\n2\n4\n3\n2\n1\n-1\n3\n2\n-1"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "PA（波兰）"], "title": "[PA 2019] Szprotki i szczupaki", "background": "", "description": "在湖中有 $n$ 条小鱼，第 $i$ 条小鱼的重量为 $w_i$。\n\n共 $q$ 个操作，每个操作是下面 $3$ 种之一：\n\n- `1 s k` 假如现在来了一条重量为 $s$ 的大鲨鱼，它的目标是让自己的重量达到至少 $k$ (包含 $k$)，问它至少需要吃掉多少条小鱼？如果鲨鱼当前的重量严格大于要吃掉的小鱼的重量 $w$，那么它可以吃掉这条小鱼，并使得自己的重量增加 $w$。\n- `2 w` 添加一条重量为 $w$ 的小鱼。\n- `3 w` 删除一条重量为 $w$ 的小鱼，保证存在至少一条这样的小鱼。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个正整数 $w_1,w_2,...,w_n$。\n\n第三行一个正整数 $q$。\n\n接下来 $q$ 行，每行若干个整数，描述一个操作。", "outputFormat": "对于每个询问，如果有解，输出一行一个整数，即最少需要吃掉的小鱼数量，如果无解，输出 `-1`。", "hint": "对于 $100\\%$ 的数据，$1\\le w_i\\le 10^{12}$，$1\\le s,k\\le 10^{18}$ ，$1\\le w\\le 10^{12}$，$1\\le n\\le 3\\times 10^5$，$1\\le q\\le 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Szprotki i szczupaki", "background": "", "description": "在湖中有 $n$ 条小鱼，第 $i$ 条小鱼的重量为 $w_i$。\n\n共 $q$ 个操作，每个操作是下面 $3$ 种之一：\n\n- `1 s k` 假如现在来了一条重量为 $s$ 的大鲨鱼，它的目标是让自己的重量达到至少 $k$ (包含 $k$)，问它至少需要吃掉多少条小鱼？如果鲨鱼当前的重量严格大于要吃掉的小鱼的重量 $w$，那么它可以吃掉这条小鱼，并使得自己的重量增加 $w$。\n- `2 w` 添加一条重量为 $w$ 的小鱼。\n- `3 w` 删除一条重量为 $w$ 的小鱼，保证存在至少一条这样的小鱼。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个正整数 $w_1,w_2,...,w_n$。\n\n第三行一个正整数 $q$。\n\n接下来 $q$ 行，每行若干个整数，描述一个操作。", "outputFormat": "对于每个询问，如果有解，输出一行一个整数，即最少需要吃掉的小鱼数量，如果无解，输出 `-1`。", "hint": "对于 $100\\%$ 的数据，$1\\le w_i\\le 10^{12}$，$1\\le s,k\\le 10^{18}$ ，$1\\le w\\le 10^{12}$，$1\\le n\\le 3\\times 10^5$，$1\\le q\\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5987", "type": "P", "difficulty": 6, "samples": [["2 10 7\n2 1 8 6\n5 2 4 4", "15"]], "limits": {"time": [3000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "离散化", "O2优化", "哈希 hashing", "扫描线", "PA（波兰）"], "title": "[PA 2019] Terytoria", "background": "", "description": "在二维平面直角坐标系上，有一个长度为 $X$，宽度为 $Y$ 的地图，注意这个地图的左边界和右边界是连通的，下边界和上边界也是连通的。\n\n在这个地图里，有 $X\\times Y$ 个格子以及 $n$ 个边平行坐标轴的矩形。你只知道每个矩形两个对顶点的坐标，请问在最好情况下，被所有 $n$ 个矩形都覆盖住的格子数量有多少？", "inputFormat": "第一行三个正整数 $n,X,Y$。\n\n接下来 $n$ 行，每行四个整数 $x_1,y_1,x_2,y_2(0\\le x_1,x_2<X,0\\le y_1,y_2<Y,x_1\\ne x_2,y_1\\ne y_2)$，表示第 $i$ 个矩形两个对顶点的坐标为 $(x_1,y_1)$ 和 $(x_2,y_2)$。", "outputFormat": "输出一行一个整数，即被所有 $n$ 个矩形都覆盖住的格子数量的最大可能值。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 5\\times 10^5$，$2\\le X,Y\\le 10^9$。\n\n\n### 样例解释：\n\n下图列举了一些情况，其中第3种情况是最优的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vwqe130.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Terytoria", "background": "", "description": "在二维平面直角坐标系上，有一个长度为 $X$，宽度为 $Y$ 的地图，注意这个地图的左边界和右边界是连通的，下边界和上边界也是连通的。\n\n在这个地图里，有 $X\\times Y$ 个格子以及 $n$ 个边平行坐标轴的矩形。你只知道每个矩形两个对顶点的坐标，请问在最好情况下，被所有 $n$ 个矩形都覆盖住的格子数量有多少？", "inputFormat": "第一行三个正整数 $n,X,Y$。\n\n接下来 $n$ 行，每行四个整数 $x_1,y_1,x_2,y_2(0\\le x_1,x_2<X,0\\le y_1,y_2<Y,x_1\\ne x_2,y_1\\ne y_2)$，表示第 $i$ 个矩形两个对顶点的坐标为 $(x_1,y_1)$ 和 $(x_2,y_2)$。", "outputFormat": "输出一行一个整数，即被所有 $n$ 个矩形都覆盖住的格子数量的最大可能值。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 5\\times 10^5$，$2\\le X,Y\\le 10^9$。\n\n\n### 样例解释：\n\n下图列举了一些情况，其中第3种情况是最优的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vwqe130.png)", "locale": "zh-CN"}}}
{"pid": "P5988", "type": "P", "difficulty": 7, "samples": [["6 8 3 3\n2 -> 1\n2 -> 3\n1 -> 3\n3 -- 6\n1 -> 4\n2 -> 5\n4 -> 6\n4 -- 5", "4"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "PA（波兰）"], "title": "[PA 2019] Wyspa", "background": null, "description": "比特岛位于海上，在比特岛的中心有一个内陆湖。\n\n在比特岛一共有 $n$ 个点，编号为 $1$ 到 $n$，其中 $1$ 到 $a$ 的点按照顺时针或者逆时针表示内陆湖边上的点， $a+1$ 到 $a+b$ 的点按照顺时针或者逆时针表示比特岛海岸线上的点， $a+b+1$ 到 $n$ 的点表示既不在湖边也不在海边的点。\n\n这些点之间连着 $m$ 条单向或双向道路。满足如下限制：\n\n- 每条道路不会经过湖、海或者任意其它点。\n- 任意两点间只会连着最多一条道路\n- 这些道路中不存在“天桥”或者“地下隧道”，任意两条道路只可能在端点处相交，换言之，这是一张平面图。\n- 从任意一个湖边的点出发，都能沿着这些道路直接或间接地到达至少一个海边的点。\n\n现在要在 $b$ 个海边点中选择若干个点作为港口，问有多少种选点的方案使得任意一个湖边的点都能到达至少一个港口？", "inputFormat": "第一行四个正整数 $n,m,a,b$。\n\n接下来 $m$ 行描述 $m$ 条道路，每行要么是 `u -- v` 要么是 `u -> v`($1\\le \nu,v\\le n,u\\ne v$)：\n\n如果是“`u -- v`，表示这是一条连接 $u$ 和 $v$的双向道路。\n\n如果是 `u -> v`，表示这是一条从 $u$出发到达 $v$的单向道路。", "outputFormat": "输出一行一个整数，即满足条件的方案数模 $10^9+7$。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 5\\times 10^5$，$1\\le m\\le 10^6$，$1\\le a,b\\le n,2\\le a+b\\le n$。\n\n---\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e7xeolht.png)\n\n$6$ 号点必选， $4$ 和 $5$ 可选可不选，因此有 $4$种方案。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Wyspa", "background": null, "description": "比特岛位于海上，在比特岛的中心有一个内陆湖。\n\n在比特岛一共有 $n$ 个点，编号为 $1$ 到 $n$，其中 $1$ 到 $a$ 的点按照顺时针或者逆时针表示内陆湖边上的点， $a+1$ 到 $a+b$ 的点按照顺时针或者逆时针表示比特岛海岸线上的点， $a+b+1$ 到 $n$ 的点表示既不在湖边也不在海边的点。\n\n这些点之间连着 $m$ 条单向或双向道路。满足如下限制：\n\n- 每条道路不会经过湖、海或者任意其它点。\n- 任意两点间只会连着最多一条道路\n- 这些道路中不存在“天桥”或者“地下隧道”，任意两条道路只可能在端点处相交，换言之，这是一张平面图。\n- 从任意一个湖边的点出发，都能沿着这些道路直接或间接地到达至少一个海边的点。\n\n现在要在 $b$ 个海边点中选择若干个点作为港口，问有多少种选点的方案使得任意一个湖边的点都能到达至少一个港口？", "inputFormat": "第一行四个正整数 $n,m,a,b$。\n\n接下来 $m$ 行描述 $m$ 条道路，每行要么是 `u -- v` 要么是 `u -> v`($1\\le \nu,v\\le n,u\\ne v$)：\n\n如果是“`u -- v`，表示这是一条连接 $u$ 和 $v$的双向道路。\n\n如果是 `u -> v`，表示这是一条从 $u$出发到达 $v$的单向道路。", "outputFormat": "输出一行一个整数，即满足条件的方案数模 $10^9+7$。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 5\\times 10^5$，$1\\le m\\le 10^6$，$1\\le a,b\\le n,2\\le a+b\\le n$。\n\n---\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e7xeolht.png)\n\n$6$ 号点必选， $4$ 和 $5$ 可选可不选，因此有 $4$种方案。", "locale": "zh-CN"}}}
{"pid": "P5989", "type": "P", "difficulty": 3, "samples": [["5 7\n1999\n2019 2010\n850 1500 1600\n900 900 710 900\n1000 800 600 800 1000", "710"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "PA（波兰）"], "title": "[PA 2019] Wina", "background": "", "description": " $n$ 行 $\\dfrac{n\\times(n+1)}{2}$ 个数叠成了一个数塔。\n\n给定 $k$，你需要从中拿走恰好 $k$ 个数，使得拿走的数的最小值最小。一个数能被拿走当且仅当它左上角和右上角都没有数或者那个数已经被拿走了。", "inputFormat": "第一行两个正整数 $n,k$。\n接下来 $n$ 行，第$i$行 $i$个正整数 $a[i][1],a[i][2],...,a[i][i](1\\le a[i][j]\\le 2019)$，表示从上往下第 $i$ 行从左往右第 $j$ 个数。", "outputFormat": "输出一行一个整数，即拿走的数的最小值的最小值。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 2000$，$1\\le k\\le \\dfrac{n\\times(n+1)}{2}$。\n\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pya9rv24.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Wina", "background": "", "description": " $n$ 行 $\\dfrac{n\\times(n+1)}{2}$ 个数叠成了一个数塔。\n\n给定 $k$，你需要从中拿走恰好 $k$ 个数，使得拿走的数的最小值最小。一个数能被拿走当且仅当它左上角和右上角都没有数或者那个数已经被拿走了。", "inputFormat": "第一行两个正整数 $n,k$。\n接下来 $n$ 行，第$i$行 $i$个正整数 $a[i][1],a[i][2],...,a[i][i](1\\le a[i][j]\\le 2019)$，表示从上往下第 $i$ 行从左往右第 $j$ 个数。", "outputFormat": "输出一行一个整数，即拿走的数的最小值的最小值。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 2000$，$1\\le k\\le \\dfrac{n\\times(n+1)}{2}$。\n\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pya9rv24.png)", "locale": "zh-CN"}}}
{"pid": "P5990", "type": "P", "difficulty": 2, "samples": [["5\n2 4 3 3 3", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2015", "PA（波兰）"], "title": "[PA 2015] Kieszonkowe", "background": null, "description": "给定 $n$ 个数，请从中选出若干个数，使得总和为偶数。\n\n请最大化这个总和。", "inputFormat": "第一行包含一个正整数 $n$。\n\n第二行包含 $n$ 个正整数 $a_1,a_2,...,a_n$。", "outputFormat": "输出一个正整数，即最大的总和，若无解则输出 `NIESTETY`。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le a_i\\le 10^3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2015] Kieszonkowe", "background": null, "description": "给定 $n$ 个数，请从中选出若干个数，使得总和为偶数。\n\n请最大化这个总和。", "inputFormat": "第一行包含一个正整数 $n$。\n\n第二行包含 $n$ 个正整数 $a_1,a_2,...,a_n$。", "outputFormat": "输出一个正整数，即最大的总和，若无解则输出 `NIESTETY`。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le a_i\\le 10^3$。", "locale": "zh-CN"}}}
{"pid": "P5991", "type": "P", "difficulty": 3, "samples": [["51 5000 10000", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "PA（波兰）"], "title": "[PA 2015] Równanie", "background": "", "description": "对于一个正整数 $n$，定义 $\\operatorname{f}(n)$ 为它十进制下每一位数字的平方的和。\n\n现在给定三个正整数 $k,a,b$，请求出满足 $a\\le n\\le b$ 且 $k\\times \\operatorname{f}(n)=n$ 的 $n$ 的个数。", "inputFormat": "第一行包含三个正整数 $k,a,b$。", "outputFormat": "输出一个整数，即满足条件的 $n$ 的个数。", "hint": "对于 $100\\%$ 的数据，$1\\le k,a,b\\le 10^{18}$，$a\\le b$。\n\n---\n\n### 样例解释：\n\n满足的 $3$ 个 $n$ 分别为 $7293,7854$ 和 $7905$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2015] Równanie", "background": "", "description": "对于一个正整数 $n$，定义 $\\operatorname{f}(n)$ 为它十进制下每一位数字的平方的和。\n\n现在给定三个正整数 $k,a,b$，请求出满足 $a\\le n\\le b$ 且 $k\\times \\operatorname{f}(n)=n$ 的 $n$ 的个数。", "inputFormat": "第一行包含三个正整数 $k,a,b$。", "outputFormat": "输出一个整数，即满足条件的 $n$ 的个数。", "hint": "对于 $100\\%$ 的数据，$1\\le k,a,b\\le 10^{18}$，$a\\le b$。\n\n---\n\n### 样例解释：\n\n满足的 $3$ 个 $n$ 分别为 $7293,7854$ 和 $7905$。", "locale": "zh-CN"}}}
{"pid": "P5992", "type": "P", "difficulty": 5, "samples": [["6 4\n1 5\n2 5\n3 6\n4 6\n5 6\n5\n10\n20\n40", "35"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "PA（波兰）"], "title": "[PA 2015] Rozstaw szyn", "background": "", "description": "给定一棵有 $n$ 个点， $m$ 个叶子节点的树，其中 $m$ 个叶子节点分别为 $1$ 到 $m$ 号点，每个叶子节点有一个权值 $r_i$。\n\n你需要给剩下 $n-m$ 个点各指定一个权值，使得树上相邻两个点的权值差的绝对值之和最小。 ", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示点数和叶子数。\n\n接下来 $n-1$ 行，每行两个正整数 $u,v$，表示 $u$ 与 $v$ 之间有一条边。\n\n接下来 $m$ 行，每行一个正整数，依次为 $r_1,r_2,...,r_m$，表示每个叶子的权值。", "outputFormat": "输出一个整数，即树上相邻两个点的权值差的绝对值之和的最小值。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 5\\times 10^5$，$1\\le m\\le n$，$1\\le u,v\\le n$，$1\\le r_i\\le 5\\times 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2015] Rozstaw szyn", "background": "", "description": "给定一棵有 $n$ 个点， $m$ 个叶子节点的树，其中 $m$ 个叶子节点分别为 $1$ 到 $m$ 号点，每个叶子节点有一个权值 $r_i$。\n\n你需要给剩下 $n-m$ 个点各指定一个权值，使得树上相邻两个点的权值差的绝对值之和最小。 ", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示点数和叶子数。\n\n接下来 $n-1$ 行，每行两个正整数 $u,v$，表示 $u$ 与 $v$ 之间有一条边。\n\n接下来 $m$ 行，每行一个正整数，依次为 $r_1,r_2,...,r_m$，表示每个叶子的权值。", "outputFormat": "输出一个整数，即树上相邻两个点的权值差的绝对值之和的最小值。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 5\\times 10^5$，$1\\le m\\le n$，$1\\le u,v\\le n$，$1\\le r_i\\le 5\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5993", "type": "P", "difficulty": 2, "samples": [["5\n5\n4\n12\n11\n10", "TAK\nTAK\nNIE\nNIE\nTAK"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "PA（波兰）"], "title": "[PA 2014] Iloczyn", "background": "译自 PA 2014 Trial Round.", "description": "斐波那契数列的定义为：\n \n- $k=0$ 或 $1$ 时， $F_k=k$；\n\n- $k>1$ 时，$F_k=F_{k-1}+F_{k-2}$。\n\n数列的开头几项为 $0,1,1,2,3,5,8,13,21,34,55,…$。\n\n你的任务是判断给定的数字能否被表示成两个斐波那契数的乘积。", "inputFormat": "第一行包含一个整数 $T$，表示询问数量。\n\n接下来的 $T$ 行，每行一个整数 $n_i$。", "outputFormat": "输出共 $T$ 行，第 $i$ 行为 `TAK`（是）或 `NIE`（否），表示 $n_i$ 能否被表示成两个斐波那契数的乘积。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 10$，$0\\le n_i\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2014] Iloczyn", "background": "译自 PA 2014 Trial Round.", "description": "斐波那契数列的定义为：\n \n- $k=0$ 或 $1$ 时， $F_k=k$；\n\n- $k>1$ 时，$F_k=F_{k-1}+F_{k-2}$。\n\n数列的开头几项为 $0,1,1,2,3,5,8,13,21,34,55,…$。\n\n你的任务是判断给定的数字能否被表示成两个斐波那契数的乘积。", "inputFormat": "第一行包含一个整数 $T$，表示询问数量。\n\n接下来的 $T$ 行，每行一个整数 $n_i$。", "outputFormat": "输出共 $T$ 行，第 $i$ 行为 `TAK`（是）或 `NIE`（否），表示 $n_i$ 能否被表示成两个斐波那契数的乘积。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 10$，$0\\le n_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5994", "type": "P", "difficulty": 4, "samples": [["5\n1 2 3 4 5\n4 3 2 1\n3 4 5\n2 1\n5", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2014", "生成树", "PA（波兰）"], "title": "[PA 2014] Kuglarz", "background": "", "description": "魔术师的桌子上有 $n$ 个杯子排成一行，编号为 $1,2,…,n$，其中某些杯子底下藏有一个小球，如果你准确地猜出是哪些杯子，你就可以获得奖品。\n\n花费 $c_{ij}$ 元，魔术师就会告诉你杯子 $i,i+1,…,j$ 底下藏有球的总数的奇偶性。\n\n采取最优的询问策略，你至少需要花费多少元，才能保证猜出哪些杯子底下藏着球？", "inputFormat": "第一行一个整数 $n$。\n\n第 $i+1$ 行（$1\\le i\\le n$）有 $n+1-i$ 个整数，表示每一种询问所需的花费。\n\n其中 $c_{ij}$（对区间 $[i,j]$ 进行询问的费用，$1\\le i\\le j\\le n$）为第 $i+1$ 行第 $j+1-i$ 个数。", "outputFormat": "输出一个整数，表示最少花费。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 2\\times 10^3$，$1\\le c_{ij}\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2014] Kuglarz", "background": "", "description": "魔术师的桌子上有 $n$ 个杯子排成一行，编号为 $1,2,…,n$，其中某些杯子底下藏有一个小球，如果你准确地猜出是哪些杯子，你就可以获得奖品。\n\n花费 $c_{ij}$ 元，魔术师就会告诉你杯子 $i,i+1,…,j$ 底下藏有球的总数的奇偶性。\n\n采取最优的询问策略，你至少需要花费多少元，才能保证猜出哪些杯子底下藏着球？", "inputFormat": "第一行一个整数 $n$。\n\n第 $i+1$ 行（$1\\le i\\le n$）有 $n+1-i$ 个整数，表示每一种询问所需的花费。\n\n其中 $c_{ij}$（对区间 $[i,j]$ 进行询问的费用，$1\\le i\\le j\\le n$）为第 $i+1$ 行第 $j+1-i$ 个数。", "outputFormat": "输出一个整数，表示最少花费。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 2\\times 10^3$，$1\\le c_{ij}\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5995", "type": "P", "difficulty": 3, "samples": [["3\n3\n2 3 3 5\n1 4 2 6\n1 3 4 6\n3\n1 5 1 3\n2 4 1 3\n3 4 2 5\n4\n1 2 1 10\n1 2 3 8\n2 2 7 10\n1 2 1 10", "TAK\nNIE\nTAK"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000]}, "tags": ["2014", "PA（波兰）"], "title": "[PA 2014] Lustra", "background": "", "description": "Byteasar 公司专门外包生产带有镜子的衣柜。\n\n刚刚举行的招标会上，有 $n$ 个工厂参加竞标。所有镜子都是长方形的，每个工厂能够制造的镜子都有其各自的最大、最小宽度和最大、最小高度。镜子不可以旋转。\n\n如果存在某家工厂满足这样的条件：其他所有工厂能够制造的镜子，它都能够制造。那么这家工厂显然会胜出。若不存在，评判工作将会遇到麻烦。\n\nByteasar 想知道，是否存在某家工厂符合上述条件。", "inputFormat": "第一行有一个整数 $t$，表示测试数据数量。\n\n对于每一组测试数据，第一行有一个整数 $n$。\n\n接下来 $n$行，每行有四个整数 $w1,w2,h1,h2$，表示这家工厂能够制造的镜子的宽度 $w$、高度 $h$ 需要满足 $w_1\\le w\\le w_2,h_1\\le h\\le h_2$。", "outputFormat": "输出共有 $t$ 行，每行为 `TAK` (是)或 `NIE` (否)，表示是否存在某家工厂符合条件。", "hint": "对于 $100\\%$ 的数据，$1\\le t\\le 10$，$2\\le n\\le 10^5$，$1\\le w_1\\le w_2\\le 10^9$，$1\\le h_1\\le h_2\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2014] Lustra", "background": "", "description": "Byteasar 公司专门外包生产带有镜子的衣柜。\n\n刚刚举行的招标会上，有 $n$ 个工厂参加竞标。所有镜子都是长方形的，每个工厂能够制造的镜子都有其各自的最大、最小宽度和最大、最小高度。镜子不可以旋转。\n\n如果存在某家工厂满足这样的条件：其他所有工厂能够制造的镜子，它都能够制造。那么这家工厂显然会胜出。若不存在，评判工作将会遇到麻烦。\n\nByteasar 想知道，是否存在某家工厂符合上述条件。", "inputFormat": "第一行有一个整数 $t$，表示测试数据数量。\n\n对于每一组测试数据，第一行有一个整数 $n$。\n\n接下来 $n$行，每行有四个整数 $w1,w2,h1,h2$，表示这家工厂能够制造的镜子的宽度 $w$、高度 $h$ 需要满足 $w_1\\le w\\le w_2,h_1\\le h\\le h_2$。", "outputFormat": "输出共有 $t$ 行，每行为 `TAK` (是)或 `NIE` (否)，表示是否存在某家工厂符合条件。", "hint": "对于 $100\\%$ 的数据，$1\\le t\\le 10$，$2\\le n\\le 10^5$，$1\\le w_1\\le w_2\\le 10^9$，$1\\le h_1\\le h_2\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5996", "type": "P", "difficulty": 6, "samples": [["5 3\n2 3\n2 6 2\n5 1 3\n5 5 8\n7 3 4\n8 6 1\n3 8 3\n4 3 5\n5 7 6", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "PA（波兰）"], "title": "[PA 2014] Muzeum", "background": "", "description": "吉丽的漫展有 $n$ 件手办和 $m$ 名警卫。\n\n现在我们对其建立平面直角坐标系，每个手办和警卫都可以看做一个点。警卫们的目光都朝着 $y$ 轴负方向，且都有相同大小的视角。警卫可以看见自己视角内（包括边界上的点）的所有手办，不用考虑视线的遮挡。\n\n你打算抢劫吉丽的漫展，但不想被警卫发现。为了实施这次抢劫计划，你可以事先贿赂某些警卫，让他们闭上眼睛。只要某件手办不在任何睁着眼睛的警卫的视野内，你就可以偷走它。你知道每件手办的价格，以及每位警卫需要接受多少钱的贿赂。你想知道自己的最大收益是多少。", "inputFormat": "第一行两个整数 $n,m$，分别表示手办的数量和警卫的数量。\n\n第二行两个整数 $w,h$，表示每个警卫的视角的一半的正切值是 $\\dfrac{w}{h}$。（见配图）\n\n接下来 $n$ 行，每行三个整数 $x_i,y_i,v_i$，表示手办的坐标为 $(x_i,y_i)$，价格为 $v_i$。\n\n接下来 $m$ 行，格式同上，表示警卫的坐标为 $(x_i,y_i)$，需接受贿赂的金额为 $v_i$。\n\n**保证每个点最多只有一个手办或一个警卫。**", "outputFormat": "输出仅一行表示最大收益。", "hint": "对于 $100\\%$ 的数据，$1\\le n,m\\le 2\\times 10^5$，$1\\le w,h\\le 10^9$，$-10^9\\le x_i,y_i\\le 10^9$，$1\\le v_i\\le 10^9$。\n\n\n----\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zxt0if8b.png)\n\n贿赂 售价为 $3+6=9$ 元的两个警卫，偷走 价值共$2+8+4+1=15$ 元的 $4$ 个手办，收益 $15-9=6$ 元。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2014] Muzeum", "background": "", "description": "吉丽的漫展有 $n$ 件手办和 $m$ 名警卫。\n\n现在我们对其建立平面直角坐标系，每个手办和警卫都可以看做一个点。警卫们的目光都朝着 $y$ 轴负方向，且都有相同大小的视角。警卫可以看见自己视角内（包括边界上的点）的所有手办，不用考虑视线的遮挡。\n\n你打算抢劫吉丽的漫展，但不想被警卫发现。为了实施这次抢劫计划，你可以事先贿赂某些警卫，让他们闭上眼睛。只要某件手办不在任何睁着眼睛的警卫的视野内，你就可以偷走它。你知道每件手办的价格，以及每位警卫需要接受多少钱的贿赂。你想知道自己的最大收益是多少。", "inputFormat": "第一行两个整数 $n,m$，分别表示手办的数量和警卫的数量。\n\n第二行两个整数 $w,h$，表示每个警卫的视角的一半的正切值是 $\\dfrac{w}{h}$。（见配图）\n\n接下来 $n$ 行，每行三个整数 $x_i,y_i,v_i$，表示手办的坐标为 $(x_i,y_i)$，价格为 $v_i$。\n\n接下来 $m$ 行，格式同上，表示警卫的坐标为 $(x_i,y_i)$，需接受贿赂的金额为 $v_i$。\n\n**保证每个点最多只有一个手办或一个警卫。**", "outputFormat": "输出仅一行表示最大收益。", "hint": "对于 $100\\%$ 的数据，$1\\le n,m\\le 2\\times 10^5$，$1\\le w,h\\le 10^9$，$-10^9\\le x_i,y_i\\le 10^9$，$1\\le v_i\\le 10^9$。\n\n\n----\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zxt0if8b.png)\n\n贿赂 售价为 $3+6=9$ 元的两个警卫，偷走 价值共$2+8+4+1=15$ 元的 $4$ 个手办，收益 $15-9=6$ 元。\n", "locale": "zh-CN"}}}
{"pid": "P5997", "type": "P", "difficulty": 5, "samples": [["4 3\n4 2 10 3\n11 18 9", "2"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2014", "PA（波兰）"], "title": "[PA 2014] Pakowanie", "background": "", "description": "你有 $n$ 个物品和 $m$ 个包。物品有重量，且不可被分割；包也有各自的容量。要把所有物品装入包中，至少需要几个包？", "inputFormat": "第一行两个整数 $n,m$，表示物品和包的数量。\n\n第二行有 $n$ 个整数 $a_1,a_2,…,a_n$，分别表示物品的重量。\n\n第三行有 $m$个整数 $c_1,c_2,…,c_m$，分别表示包的容量。", "outputFormat": "如果能够装下，输出一个整数表示最少使用包的数目。\n\n若不能全部装下，则输出 `NIE`。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 24$，$1\\le m\\le 100$，$1\\le a_i\\le 10^8$，$1\\le c_i\\le 10^8$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2014] Pakowanie", "background": "", "description": "你有 $n$ 个物品和 $m$ 个包。物品有重量，且不可被分割；包也有各自的容量。要把所有物品装入包中，至少需要几个包？", "inputFormat": "第一行两个整数 $n,m$，表示物品和包的数量。\n\n第二行有 $n$ 个整数 $a_1,a_2,…,a_n$，分别表示物品的重量。\n\n第三行有 $m$个整数 $c_1,c_2,…,c_m$，分别表示包的容量。", "outputFormat": "如果能够装下，输出一个整数表示最少使用包的数目。\n\n若不能全部装下，则输出 `NIE`。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 24$，$1\\le m\\le 100$，$1\\le a_i\\le 10^8$，$1\\le c_i\\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P5998", "type": "P", "difficulty": 6, "samples": [["5\n7 8 1 4\n1 5 2 3\n4 5 2 7\n2 3 5 9\n4 6 8 9", "2\n1 6 2 9\n7 8 1 4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "PA（波兰）"], "title": "[PA 2014] Plemiona", "background": "", "description": "远古时代，在吉丽王国的版图上分布着 $n$ 个部落。建立平面直角坐标系后，每个部落都是一个边平行于坐标轴的矩形。有些地盘可能同时属于多个部落。随着时间推移，部落之间会发生融合。具体来说，若两个部落的公共面积严格大于零，它们会合并成一个新的部落，新部落的形状是包含原来两个部落的最小矩形（边平行于坐标轴）。\n\n数百万年后，部落之间终于达到了稳定状态（任两个部落都不能再合并了），然而吉丽也已经老了。他想知道最终还剩下几个部落，以及各个部落的位置。你能替他完成遗业吗？", "inputFormat": "第一行一个整数 $n$，表示远古时代的部落数量。\n\n接下来 $n$ 行，每行四个整数 $x_1,x_2,y_1,y_2$，表示部落的坐标。", "outputFormat": "第一行输出一个整数 $m$，表示稳定后还剩下的部落数量。\n接下来 $m$ 行，每行四个整数 $x_1,x_2,y_1,y_2$，表示部落的坐标。\n\n请按照字典序（先比较 $x_1$，若 $x_1$ 相等则比较 $x_2$，以此类推）从小到大输出。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^5$，$0\\le x1<x2\\le 10^6$，$0\\le y1<y2\\le 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2014] Plemiona", "background": "", "description": "远古时代，在吉丽王国的版图上分布着 $n$ 个部落。建立平面直角坐标系后，每个部落都是一个边平行于坐标轴的矩形。有些地盘可能同时属于多个部落。随着时间推移，部落之间会发生融合。具体来说，若两个部落的公共面积严格大于零，它们会合并成一个新的部落，新部落的形状是包含原来两个部落的最小矩形（边平行于坐标轴）。\n\n数百万年后，部落之间终于达到了稳定状态（任两个部落都不能再合并了），然而吉丽也已经老了。他想知道最终还剩下几个部落，以及各个部落的位置。你能替他完成遗业吗？", "inputFormat": "第一行一个整数 $n$，表示远古时代的部落数量。\n\n接下来 $n$ 行，每行四个整数 $x_1,x_2,y_1,y_2$，表示部落的坐标。", "outputFormat": "第一行输出一个整数 $m$，表示稳定后还剩下的部落数量。\n接下来 $m$ 行，每行四个整数 $x_1,x_2,y_1,y_2$，表示部落的坐标。\n\n请按照字典序（先比较 $x_1$，若 $x_1$ 相等则比较 $x_2$，以此类推）从小到大输出。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^5$，$0\\le x1<x2\\le 10^6$，$0\\le y1<y2\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P5999", "type": "P", "difficulty": 6, "samples": [["4 2 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2016", "CEOI（中欧）", "组合数学"], "title": "[CEOI 2016] kangaroo", "background": "", "description": "有一个园子，里面有 $n$ 个草丛排成一排，标号 $1\\sim n$，有一个袋鼠，从 $s$ 出发，每次跳一步跳到一个其他的草丛，经过每个草丛恰好一次，最终到达 $t$。显然他会跳跃 $n-1$ 次。为了不被人类发现，袋鼠每次跳跃的方向必须与前一次不同。\n\n具体地，如果他现在在 $now$，他是从 $prev $ 跳跃一次到达 $now$ 的，然后他跳跃一次到达 $next$：\n\n- 那么如果 $prev<now$，就必须有 $next<now$；\n\n- 如果 $now<prev$，就必须有 $now<next$。\n\n问从 $s$ 到 $t$ 的方案数模 $10^9+7$ 的结果。\n\n两个路线不同，当且仅当草丛被访问的顺序不同。\n\n保证至少有一种方案。\n\n初始时可以往任意方向跳。", "inputFormat": " 一行三个整数 $n,s,t$。\n\n", "outputFormat": " 一行一个整数，代表答案。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 2\\times 10^3$，$1\\le s,t\\le n$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2016] kangaroo", "background": "", "description": "有一个园子，里面有 $n$ 个草丛排成一排，标号 $1\\sim n$，有一个袋鼠，从 $s$ 出发，每次跳一步跳到一个其他的草丛，经过每个草丛恰好一次，最终到达 $t$。显然他会跳跃 $n-1$ 次。为了不被人类发现，袋鼠每次跳跃的方向必须与前一次不同。\n\n具体地，如果他现在在 $now$，他是从 $prev $ 跳跃一次到达 $now$ 的，然后他跳跃一次到达 $next$：\n\n- 那么如果 $prev<now$，就必须有 $next<now$；\n\n- 如果 $now<prev$，就必须有 $now<next$。\n\n问从 $s$ 到 $t$ 的方案数模 $10^9+7$ 的结果。\n\n两个路线不同，当且仅当草丛被访问的顺序不同。\n\n保证至少有一种方案。\n\n初始时可以往任意方向跳。", "inputFormat": " 一行三个整数 $n,s,t$。\n\n", "outputFormat": " 一行一个整数，代表答案。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 2\\times 10^3$，$1\\le s,t\\le n$", "locale": "zh-CN"}}}
{"pid": "P6000", "type": "P", "difficulty": 6, "samples": [["abbaaa", "(()())"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "CEOI（中欧）"], "title": "[CEOI 2016] match", "background": "", "description": "给你一个由小写字母组成的字符串 $s$，要你构造一个字典序最小的（认为左括号的字典序比右括号小）合法的括号序列与这个字符串匹配。\n\n字符串和括号序列匹配定义为：首先长度必须相等，其次对于一对匹配的左括号和右括号 $i,j$，必须有 $s_i=s_j$。\n\n\n无解输出 `-1`。", "inputFormat": "一行一个字符串 $s$。", "outputFormat": "一行一个括号序列或者 `-1`。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2016] match", "background": "", "description": "给你一个由小写字母组成的字符串 $s$，要你构造一个字典序最小的（认为左括号的字典序比右括号小）合法的括号序列与这个字符串匹配。\n\n字符串和括号序列匹配定义为：首先长度必须相等，其次对于一对匹配的左括号和右括号 $i,j$，必须有 $s_i=s_j$。\n\n\n无解输出 `-1`。", "inputFormat": "一行一个字符串 $s$。", "outputFormat": "一行一个括号序列或者 `-1`。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P6001", "type": "P", "difficulty": 6, "samples": [["2 3 3\n4 3 5\n101\n110", "0\n8\n16"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "CEOI（中欧）"], "title": "[CEOI 2016] popeala", "background": "", "description": "你办了一场比赛，有 $n$ 个人参加，只有一道题，有 $m$ 个数据点，标号为 $1\\sim m$，每个测试点都有一个分数 $a_i$。\n\n现在所有选手已经提交了程序并且测评完了，你知道每个人都能通过哪些测试点。\n\n你现在要安排捆绑测试的方式，把数据点划分为若干个连续的区间，每个区间至少有一个测试点。每个区间只要有一个测试点错误就不会得分，如果所有\n点都正确得分为所有测试点的分数的和。\n\n**你的目的是最小化所有人的得分和**。你需要对 $1\\le i\\le S$，输出当把所有测试点划分为 $i$ 组时，最小的所有人分数和。", "inputFormat": "第一行三个整数 $n,m,S$。\n\n接下来一行 $m$ 个整数，代表 $a_i$。\n\n接下来 $n$ 行每行一个长度为 $m$ 的 $01$ 串，代表第 $i$ 个人是否通过了第 $j$ 个测试点。", "outputFormat": "$S$ 行，每行一个整数，代表当划分为 $i$ 个捆绑测试点时所有人分数和的最小值。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 50$，$1\\le m\\le 2\\times 10^4$，$S\\le \\min(50,m)，1\\le a_i \\le 10^4$，$\\Sigma a_i\\times n\\le 2\\times10^9$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2016] popeala", "background": "", "description": "你办了一场比赛，有 $n$ 个人参加，只有一道题，有 $m$ 个数据点，标号为 $1\\sim m$，每个测试点都有一个分数 $a_i$。\n\n现在所有选手已经提交了程序并且测评完了，你知道每个人都能通过哪些测试点。\n\n你现在要安排捆绑测试的方式，把数据点划分为若干个连续的区间，每个区间至少有一个测试点。每个区间只要有一个测试点错误就不会得分，如果所有\n点都正确得分为所有测试点的分数的和。\n\n**你的目的是最小化所有人的得分和**。你需要对 $1\\le i\\le S$，输出当把所有测试点划分为 $i$ 组时，最小的所有人分数和。", "inputFormat": "第一行三个整数 $n,m,S$。\n\n接下来一行 $m$ 个整数，代表 $a_i$。\n\n接下来 $n$ 行每行一个长度为 $m$ 的 $01$ 串，代表第 $i$ 个人是否通过了第 $j$ 个测试点。", "outputFormat": "$S$ 行，每行一个整数，代表当划分为 $i$ 个捆绑测试点时所有人分数和的最小值。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 50$，$1\\le m\\le 2\\times 10^4$，$S\\le \\min(50,m)，1\\le a_i \\le 10^4$，$\\Sigma a_i\\times n\\le 2\\times10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P6002", "type": "P", "difficulty": 3, "samples": [["5 4\n3 6 8 4 2", "8"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2020", "USACO", "枚举"], "title": "[USACO20JAN] Berry Picking S", "background": "", "description": "Bessie 和她的妹妹 Elsie 正在 Farmer John 的浆果园里采浆果。Farmer John 的浆果园里有 $N$ 棵浆果树（$1 \\leq N \\leq 1000$）；树 $i$ 上有 $B_i$ 个浆果（$1 \\leq B_i \\leq 1000$）。Bessie 有 $K$ 个篮子（$1 \\leq K \\leq 1000$，$K$ 为偶数）。每个篮子里可以装同一棵树上采下的任意多个浆果，但是不能装来自于不同的树上的浆果，因为它们的口味可能不同。篮子里也可以不装浆果。\n\nBessie 想要使得她得到的浆果数量最大。但是，Farmer John 希望 Bessie 与她的妹妹一同分享，所以 Bessie 必须将浆果数量较多的 $K/2$ 个篮子给 Elsie。这表示 Elsie 很有可能最后比 Bessie 得到更多的浆果，这十分不公平，然而姐妹之间往往就是这样。\n\n帮助 Bessie 求出她最多可以得到的浆果数量。", "inputFormat": "输入的第一行包含空格分隔的整数 $N$ 和 $K$。\n\n第二行包含 $N$ 个空格分隔的整数 $B_1,B_2,\\ldots,B_N$。", "outputFormat": "输出一行答案。", "hint": "### 样例解释\n\n如果 Bessie 在\n\n- 一个篮子里装树 2 的 6 个浆果\n- 两个篮子里每个装树 3 的 4 个浆果\n- 一个篮子里装树 4 的 4 个浆果\n\n那么她能够得到两个各装有 4 个浆果的篮子，总共 8 个浆果。\n\n### 子任务\n\n- 测试点 $1 \\sim 4$ 满足 $K \\leq 10$。\n- 测试点 $5 \\sim 11$ 没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO20JAN] Berry Picking S", "background": "", "description": "Bessie 和她的妹妹 Elsie 正在 Farmer John 的浆果园里采浆果。Farmer John 的浆果园里有 $N$ 棵浆果树（$1 \\leq N \\leq 1000$）；树 $i$ 上有 $B_i$ 个浆果（$1 \\leq B_i \\leq 1000$）。Bessie 有 $K$ 个篮子（$1 \\leq K \\leq 1000$，$K$ 为偶数）。每个篮子里可以装同一棵树上采下的任意多个浆果，但是不能装来自于不同的树上的浆果，因为它们的口味可能不同。篮子里也可以不装浆果。\n\nBessie 想要使得她得到的浆果数量最大。但是，Farmer John 希望 Bessie 与她的妹妹一同分享，所以 Bessie 必须将浆果数量较多的 $K/2$ 个篮子给 Elsie。这表示 Elsie 很有可能最后比 Bessie 得到更多的浆果，这十分不公平，然而姐妹之间往往就是这样。\n\n帮助 Bessie 求出她最多可以得到的浆果数量。", "inputFormat": "输入的第一行包含空格分隔的整数 $N$ 和 $K$。\n\n第二行包含 $N$ 个空格分隔的整数 $B_1,B_2,\\ldots,B_N$。", "outputFormat": "输出一行答案。", "hint": "### 样例解释\n\n如果 Bessie 在\n\n- 一个篮子里装树 2 的 6 个浆果\n- 两个篮子里每个装树 3 的 4 个浆果\n- 一个篮子里装树 4 的 4 个浆果\n\n那么她能够得到两个各装有 4 个浆果的篮子，总共 8 个浆果。\n\n### 子任务\n\n- 测试点 $1 \\sim 4$ 满足 $K \\leq 10$。\n- 测试点 $5 \\sim 11$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P6003", "type": "P", "difficulty": 5, "samples": [["10 3 3", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2020", "二分", "USACO", "整除分块"], "title": "[USACO20JAN] Loan Repayment S", "background": "", "description": "Farmer John 欠了 Bessie $N$ 加仑牛奶（$1 \\leq N \\leq 10^{12}$）。他必须在 $K$ 天内将牛奶给 Bessie。但是，他不想将牛奶太早拿出手。另一方面，他不得不在还债上有所进展，所以他必须每天给 Bessie 至少 $M$ 加仑牛奶（$1 \\leq M \\leq 10^{12}$）。\n\n以下是 Farmer John 决定偿还 Bessie 的方式。首先他选择一个正整数 $X$。然后他每天都重复以下过程：\n\n1. 假设 Farmer John 已经给了 Bessie $G$ 加仑，计算 $\\frac{N-G}{X}$ 向下取整。令这个数为 $Y$。\n2. 如果 $Y$ 小于 $M$，令 $Y$ 等于 $M$。\n3. 给 Bessie $Y$ 加仑牛奶。\n\n求 $X$ 的最大值，使得 Farmer John 按照上述过程能够在 $K$ 天后给 Bessie 至少 $N$ 加仑牛奶 （$1 \\leq K \\leq 10^{12}$）。", "inputFormat": "输入仅有一行，包含三个空格分隔的正整数 $N,K,M$，满足 $K \\times M<N$。", "outputFormat": "输出最大的正整数 $X$，使得按照上述过程 Farmer John 会给 Bessie 至少 $N$ 加仑牛奶。", "hint": "### 样例解释\n\n在这个测试用例中，当 $X=2$ 时 Farmer John 第一天给 Bessie $5$ 加仑，后两天每天给 Bessie $M=3$ 加仑。\n\n### 子任务\n\n- 测试点 $2 \\sim 4$ 满足 $K \\leq 10^5$。\n- 测试点 $5 \\sim 11$ 没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO20JAN] Loan Repayment S", "background": "", "description": "Farmer John 欠了 Bessie $N$ 加仑牛奶（$1 \\leq N \\leq 10^{12}$）。他必须在 $K$ 天内将牛奶给 Bessie。但是，他不想将牛奶太早拿出手。另一方面，他不得不在还债上有所进展，所以他必须每天给 Bessie 至少 $M$ 加仑牛奶（$1 \\leq M \\leq 10^{12}$）。\n\n以下是 Farmer John 决定偿还 Bessie 的方式。首先他选择一个正整数 $X$。然后他每天都重复以下过程：\n\n1. 假设 Farmer John 已经给了 Bessie $G$ 加仑，计算 $\\frac{N-G}{X}$ 向下取整。令这个数为 $Y$。\n2. 如果 $Y$ 小于 $M$，令 $Y$ 等于 $M$。\n3. 给 Bessie $Y$ 加仑牛奶。\n\n求 $X$ 的最大值，使得 Farmer John 按照上述过程能够在 $K$ 天后给 Bessie 至少 $N$ 加仑牛奶 （$1 \\leq K \\leq 10^{12}$）。", "inputFormat": "输入仅有一行，包含三个空格分隔的正整数 $N,K,M$，满足 $K \\times M<N$。", "outputFormat": "输出最大的正整数 $X$，使得按照上述过程 Farmer John 会给 Bessie 至少 $N$ 加仑牛奶。", "hint": "### 样例解释\n\n在这个测试用例中，当 $X=2$ 时 Farmer John 第一天给 Bessie $5$ 加仑，后两天每天给 Bessie $M=3$ 加仑。\n\n### 子任务\n\n- 测试点 $2 \\sim 4$ 满足 $K \\leq 10^5$。\n- 测试点 $5 \\sim 11$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P6004", "type": "P", "difficulty": 4, "samples": [["4 4\n3 2 1 4\n1 2 9\n1 3 7\n2 3 10\n2 4 3", "9"], ["4 1\n1 2 3 4\n4 2 13", "-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2020", "二分", "USACO", "并查集"], "title": "[USACO20JAN] Wormhole Sort S", "background": "", "description": "Farmer John 的奶牛们已经厌倦了他对她们每天早上排好序离开牛棚的要求。她们刚刚完成了量子物理学的博士学位，准备将这一过程搞快点。\n\n今天早上，如同往常一样，Farmer John 的 $N$ 头编号为 $1 \\ldots N$ 的奶牛（$1 \\leq N \\leq 10^5$），分散在牛棚中 $N$ 个编号为 $1 \\ldots N$ 的不同位置，奶牛 $i$ 位于位置 $p_i$。但是今天早上还出现了 $M$ 个编号为 $1 \\ldots M$ 的虫洞（$1 \\leq M \\leq 10^5$），其中虫洞 $i$ 双向连接了位置 $a_i$ 和 $b_i$，宽度为 $w_i$（$1\\le a_i,b_i\\le N, a_i\\neq b_i, 1\\le w_i\\le 10^9$）。\n\n在任何时刻，两头位于一个虫洞两端的奶牛可以选择通过虫洞交换位置。奶牛们需要反复进行这样的交换，直到对于 $1 \\leq i \\leq N$，奶牛 $i$ 位于位置 $i$。\n\n奶牛们不想被虫洞挤坏。帮助她们最大化被她们用来排序的虫洞宽度的最小值。保证奶牛们有可能排好序。", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$。\n\n第二行包含 $N$ 个整数 $p_1,p_2,\\ldots ,p_N$。保证 $p$ 是 $1 \\ldots N$ 的一个排列。\n\n对于 $1$ 到 $M$ 之间的每一个 $i$，第 $i+2$ 行包含整数 $a_i,b_i,w_i$。", "outputFormat": "输出一个整数，为在排序过程中奶牛必须挤进的虫洞的最小宽度的最大值。如果奶牛们不需要用任何虫洞来排序，输出 $-1$。", "hint": "### 样例解释 1\n\n以下是一个仅用宽度至少为 9 的虫洞给奶牛排序的可能方案：\n\n- 奶牛 1 和奶牛 2 使用第三个虫洞交换位置。\n- 奶牛 1 和奶牛 3 使用第一个虫洞交换位置。\n- 奶牛 2 和奶牛 3 使用第三个虫洞交换位置。\n\n### 子任务\n\n- 测试点 $3 \\sim 5$ 满足 $N,M \\leq 1000$。\n- 测试点 $6 \\sim 10$ 没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO20JAN] Wormhole Sort S", "background": "", "description": "Farmer John 的奶牛们已经厌倦了他对她们每天早上排好序离开牛棚的要求。她们刚刚完成了量子物理学的博士学位，准备将这一过程搞快点。\n\n今天早上，如同往常一样，Farmer John 的 $N$ 头编号为 $1 \\ldots N$ 的奶牛（$1 \\leq N \\leq 10^5$），分散在牛棚中 $N$ 个编号为 $1 \\ldots N$ 的不同位置，奶牛 $i$ 位于位置 $p_i$。但是今天早上还出现了 $M$ 个编号为 $1 \\ldots M$ 的虫洞（$1 \\leq M \\leq 10^5$），其中虫洞 $i$ 双向连接了位置 $a_i$ 和 $b_i$，宽度为 $w_i$（$1\\le a_i,b_i\\le N, a_i\\neq b_i, 1\\le w_i\\le 10^9$）。\n\n在任何时刻，两头位于一个虫洞两端的奶牛可以选择通过虫洞交换位置。奶牛们需要反复进行这样的交换，直到对于 $1 \\leq i \\leq N$，奶牛 $i$ 位于位置 $i$。\n\n奶牛们不想被虫洞挤坏。帮助她们最大化被她们用来排序的虫洞宽度的最小值。保证奶牛们有可能排好序。", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$。\n\n第二行包含 $N$ 个整数 $p_1,p_2,\\ldots ,p_N$。保证 $p$ 是 $1 \\ldots N$ 的一个排列。\n\n对于 $1$ 到 $M$ 之间的每一个 $i$，第 $i+2$ 行包含整数 $a_i,b_i,w_i$。", "outputFormat": "输出一个整数，为在排序过程中奶牛必须挤进的虫洞的最小宽度的最大值。如果奶牛们不需要用任何虫洞来排序，输出 $-1$。", "hint": "### 样例解释 1\n\n以下是一个仅用宽度至少为 9 的虫洞给奶牛排序的可能方案：\n\n- 奶牛 1 和奶牛 2 使用第三个虫洞交换位置。\n- 奶牛 1 和奶牛 3 使用第一个虫洞交换位置。\n- 奶牛 2 和奶牛 3 使用第三个虫洞交换位置。\n\n### 子任务\n\n- 测试点 $3 \\sim 5$ 满足 $N,M \\leq 1000$。\n- 测试点 $6 \\sim 10$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P6005", "type": "P", "difficulty": 4, "samples": [["3 3 1\n0 10 20\n1 2\n2 3\n3 1", "24"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "2020", "USACO", "最短路"], "title": "[USACO20JAN] Time is Mooney G", "background": "", "description": "Bessie 正在安排前往牛尼亚的一次出差，那里有 $N$（$2 \\leq N \\leq 1000$）个编号为 $1 \\ldots N$ 的城市，由 $M$（$1 \\leq M \\leq 2000$）条单向的道路连接。Bessie 每次访问城市 $i$ 都可以赚到 $m_i$ 哞尼（$0 \\leq m_i \\leq 1000$）。从城市 $1$ 出发，Bessie 想要赚到尽可能多的哞尼，最后回到城市 $1$。为了避免争议，$m_1=0$。\n\n沿着两个城市之间的道路移动需要消耗一天。出差的准备工作十分费钱；旅行 $T$ 天需要花费 $C \\times T^2$ 哞尼（$1 \\leq C \\leq 1000$）。\n\nBessie 在一次出差中最多可以赚到多少哞尼？注意有可能最优方案是 Bessie 不访问城市 $1$ 之外的任何城市，在这种情况下结果应当为 $0$。", "inputFormat": "输入的第一行包含三个整数 $N$、$M$ 和 $C$。\n\n第二行包含 $N$ 个整数 $m_1,m_2,\\ldots, m_N$。\n\n以下 $M$ 行每行包含两个空格分隔的整数 $a$ 和 $b$（$a \\neq b$），表示从城市 $a$ 到城市 $b$ 的一条单向道路。", "outputFormat": "输出一行，包含所求的答案。", "hint": "最优的旅行方案是 $1 \\to 2 \\to 3 \\to 1 \\to 2 \\to 3 \\to1$。Bessie 总共赚到了 $10+20+10+20-1 \\times 6^2=24$ 哞尼。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO20JAN] Time is Mooney G", "background": "", "description": "Bessie 正在安排前往牛尼亚的一次出差，那里有 $N$（$2 \\leq N \\leq 1000$）个编号为 $1 \\ldots N$ 的城市，由 $M$（$1 \\leq M \\leq 2000$）条单向的道路连接。Bessie 每次访问城市 $i$ 都可以赚到 $m_i$ 哞尼（$0 \\leq m_i \\leq 1000$）。从城市 $1$ 出发，Bessie 想要赚到尽可能多的哞尼，最后回到城市 $1$。为了避免争议，$m_1=0$。\n\n沿着两个城市之间的道路移动需要消耗一天。出差的准备工作十分费钱；旅行 $T$ 天需要花费 $C \\times T^2$ 哞尼（$1 \\leq C \\leq 1000$）。\n\nBessie 在一次出差中最多可以赚到多少哞尼？注意有可能最优方案是 Bessie 不访问城市 $1$ 之外的任何城市，在这种情况下结果应当为 $0$。", "inputFormat": "输入的第一行包含三个整数 $N$、$M$ 和 $C$。\n\n第二行包含 $N$ 个整数 $m_1,m_2,\\ldots, m_N$。\n\n以下 $M$ 行每行包含两个空格分隔的整数 $a$ 和 $b$（$a \\neq b$），表示从城市 $a$ 到城市 $b$ 的一条单向道路。", "outputFormat": "输出一行，包含所求的答案。", "hint": "最优的旅行方案是 $1 \\to 2 \\to 3 \\to 1 \\to 2 \\to 3 \\to1$。Bessie 总共赚到了 $10+20+10+20-1 \\times 6^2=24$ 哞尼。", "locale": "zh-CN"}}}
{"pid": "P6006", "type": "P", "difficulty": 5, "samples": [["7 3\n2 0 -1 1 -2 3 3\n1 5\n2 4\n1 7", "2\n1\n4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2020", "USACO", "区间 DP", "前缀和"], "title": "[USACO20JAN] Farmer John Solves 3SUM G", "background": "", "description": "Farmer John 相信他在算法设计上实现了一个重大突破：他声称他发现了一个 3SUM 问题的近似线性时间算法，这是一个有名的算法问题，尚未发现比运行速度比平方时间明显更优的解法。3SUM 问题的一个形式是：给定一个整数数组 $s_1,\\ldots,s_m$，计算不同索引组成的无序不重三元对 $i,j,k$ 的数量，使得 $s_i+s_j+s_k=0$（$i, j, k$ 互不相同）。\n\n为了测试 Farmer John 的断言，Bessie 提供了一个 $N$ 个整数组成的数组 $A$（$1 \\leq N \\leq 5000$）。Bessie 还会进行 $Q$ 次询问（$1 \\leq Q \\leq 10^5$），每个询问由两个索引 $1 \\leq a_i \\leq b_i \\leq N$ 组成。对于每个询问，Farmer John 必须在子数组 $A[a_i \\ldots b_i]$ 上求解 3SUM 问题。\n\n不幸的是，Farmer John 刚刚发现了他的算法中的一个错误。他很自信他能修复这个算法，但同时，他请你帮他先通过 Bessie 的测试！", "inputFormat": "输入的第一行包含两个空格分隔的整数 $N$ 和 $Q$。\n\n第二行包含空格分隔的数组 $A$ 的元素 $A_1,\\ldots ,A_N$。\n\n以下 $Q$ 行每行包含两个空格分隔的整数 $a_i$ 和 $b_i$，表示一个询问。\n\n保证对于每个数组元素 $A_i$ 有 $-10^6 \\leq A_i \\leq 10^6$。", "outputFormat": "输出包含 $Q$ 行，第 $i$ 行包含一个整数，为第 $i$ 个询问的结果。**注意你需要使用 64 位整数型来避免溢出。**", "hint": "### 样例解释\n\n对于第一个询问，所有的三元对为 $(A_1,A_2,A_5)$ 和 $(A_2,A_3,A_4)$。\n\n### 子任务\n\n- 测试点 $2 \\sim 4$ 满足 $N \\leq 500$。\n- 测试点 $5 \\sim 7$ 满足 $N \\leq 2000$。\n- 测试点 $8 \\sim 15$ 没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO20JAN] Farmer John Solves 3SUM G", "background": "", "description": "Farmer John 相信他在算法设计上实现了一个重大突破：他声称他发现了一个 3SUM 问题的近似线性时间算法，这是一个有名的算法问题，尚未发现比运行速度比平方时间明显更优的解法。3SUM 问题的一个形式是：给定一个整数数组 $s_1,\\ldots,s_m$，计算不同索引组成的无序不重三元对 $i,j,k$ 的数量，使得 $s_i+s_j+s_k=0$（$i, j, k$ 互不相同）。\n\n为了测试 Farmer John 的断言，Bessie 提供了一个 $N$ 个整数组成的数组 $A$（$1 \\leq N \\leq 5000$）。Bessie 还会进行 $Q$ 次询问（$1 \\leq Q \\leq 10^5$），每个询问由两个索引 $1 \\leq a_i \\leq b_i \\leq N$ 组成。对于每个询问，Farmer John 必须在子数组 $A[a_i \\ldots b_i]$ 上求解 3SUM 问题。\n\n不幸的是，Farmer John 刚刚发现了他的算法中的一个错误。他很自信他能修复这个算法，但同时，他请你帮他先通过 Bessie 的测试！", "inputFormat": "输入的第一行包含两个空格分隔的整数 $N$ 和 $Q$。\n\n第二行包含空格分隔的数组 $A$ 的元素 $A_1,\\ldots ,A_N$。\n\n以下 $Q$ 行每行包含两个空格分隔的整数 $a_i$ 和 $b_i$，表示一个询问。\n\n保证对于每个数组元素 $A_i$ 有 $-10^6 \\leq A_i \\leq 10^6$。", "outputFormat": "输出包含 $Q$ 行，第 $i$ 行包含一个整数，为第 $i$ 个询问的结果。**注意你需要使用 64 位整数型来避免溢出。**", "hint": "### 样例解释\n\n对于第一个询问，所有的三元对为 $(A_1,A_2,A_5)$ 和 $(A_2,A_3,A_4)$。\n\n### 子任务\n\n- 测试点 $2 \\sim 4$ 满足 $N \\leq 500$。\n- 测试点 $5 \\sim 7$ 满足 $N \\leq 2000$。\n- 测试点 $8 \\sim 15$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P6007", "type": "P", "difficulty": 5, "samples": [["3 2\n0 1 0 2\n1 2 2 3", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "2020", "USACO", "树状数组", "动态规划优化"], "title": "[USACO20JAN] Springboards G", "background": "", "description": "Bessie 在一个仅允许沿平行于坐标轴方向移动的二维方阵中。她从点 $(0,0)$ 出发，想要到达 $(N,N)$（$1 \\leq N \\leq 10^9$）。为了帮助她达到目的，在方阵中有 $P$（$1 \\leq P \\leq 10^5$）个跳板。每个跳板都有其固定的位置 $(x_1,y_1)$，如果 Bessie 使用它，会落到点 $(x_2,y_2)$。\n\nBessie 是一个过程导向的奶牛，所以她仅允许她自己向上或向右行走，从不向左或向下。类似地，每个跳板也设置为不向左或向下。Bessie 需要行走的距离至少是多少？", "inputFormat": "输入的第一行包含两个空格分隔的整数 $N$ 和 $P$。\n\n以下 $P$ 行每行包含四个整数 $x_1,y_1,x_2,y_2$，其中 $x_1 \\leq x_2$ 且 $y_1 \\leq y_2$。\n\n所有跳板的位置和目标位置均不相同。", "outputFormat": "输出一个整数，为 Bessie 到达点 $(N,N)$ 需要行走的最小距离。", "hint": "### 样例解释\n\nBessie 的最佳路线为：\n\n- Bessie 从 (0,0) 走到 (0,1)（1 单位距离）。\n- Bessie 跳到 (0,2)。\n- Bessie 从 (0,2) 走到 (1,2)（1 单位距离）。\n- Bessie 跳到 (2,3)。\n- Bessie 从 (2,3) 走到 (3,3)（1 单位距离）。\n\nBessie 总共走过的路程为 3 单位距离。\n\n### 子任务\n\n- 测试点 $2 \\sim 5$ 满足 $P \\leq 1000$。\n- 测试点 $6 \\sim 15$ 没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO20JAN] Springboards G", "background": "", "description": "Bessie 在一个仅允许沿平行于坐标轴方向移动的二维方阵中。她从点 $(0,0)$ 出发，想要到达 $(N,N)$（$1 \\leq N \\leq 10^9$）。为了帮助她达到目的，在方阵中有 $P$（$1 \\leq P \\leq 10^5$）个跳板。每个跳板都有其固定的位置 $(x_1,y_1)$，如果 Bessie 使用它，会落到点 $(x_2,y_2)$。\n\nBessie 是一个过程导向的奶牛，所以她仅允许她自己向上或向右行走，从不向左或向下。类似地，每个跳板也设置为不向左或向下。Bessie 需要行走的距离至少是多少？", "inputFormat": "输入的第一行包含两个空格分隔的整数 $N$ 和 $P$。\n\n以下 $P$ 行每行包含四个整数 $x_1,y_1,x_2,y_2$，其中 $x_1 \\leq x_2$ 且 $y_1 \\leq y_2$。\n\n所有跳板的位置和目标位置均不相同。", "outputFormat": "输出一个整数，为 Bessie 到达点 $(N,N)$ 需要行走的最小距离。", "hint": "### 样例解释\n\nBessie 的最佳路线为：\n\n- Bessie 从 (0,0) 走到 (0,1)（1 单位距离）。\n- Bessie 跳到 (0,2)。\n- Bessie 从 (0,2) 走到 (1,2)（1 单位距离）。\n- Bessie 跳到 (2,3)。\n- Bessie 从 (2,3) 走到 (3,3)（1 单位距离）。\n\nBessie 总共走过的路程为 3 单位距离。\n\n### 子任务\n\n- 测试点 $2 \\sim 5$ 满足 $P \\leq 1000$。\n- 测试点 $6 \\sim 15$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P6008", "type": "P", "difficulty": 5, "samples": [["4 9\n#########\n#...#...#\n#.#...#.#\n#########", "9"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "2020", "USACO", "并查集"], "title": "[USACO20JAN] Cave Paintings P", "background": "", "description": "Bessie 成为了一名艺术家，正在创作壁画！她现在正在创作的作品是一个高为 $N$ 的方阵，方阵的每行都由 $M$ 个方格组成（$1\\le N,M\\le 1000$）。每个方格是空的，画了石头，或者画了水。Bessie 已经画上了包含石头的方格，包括整幅画作的边界。她现在想要将某些空的方格画上水，使得如果这幅画是真实的，其中应当不存在水的净移动。定义从上到下第 $i$ 行的方格的高度为 $N+1-i$。Bessie 想要她的画作满足以下限制：\n\n假设方格 $a$ 画的是水。那么如果存在一条从 $a$ 到方格 $b$ 的路径，由高度不超过 $a$ 的空的方格或是有水的方格组成，路径中每相邻两个方格都有一条公共边，那么 $b$ 画的也是水。\n\n求 Bessie 可以创作的不同作品的数量模 $10^9+7$ 的余数。Bessie 可以将任意数量的空格画上水，包括不画以及全画。", "inputFormat": "输入的第一行包含两个空格分隔的整数 $N$ 和 $M$。\n\n以下 $N$ 行每行包含 $M$ 个字符。每个字符均为 `.` 或 `#`，分别表示一个空的方格和一个画有石头的方格。第一行和最后一行、第一列和最后一列仅包含 `#`。", "outputFormat": "输出一个整数，为满足限制的作品的数量模 $10^9+7$ 的余数。", "hint": "### 样例解释\n\n如果第二行中的任意一个方格被画上水，那么所有空的方格必须都被画上水。否则，假设没有这样的方格画有水。那么 Bessie 可以选择画上第三行的空格组成的三个连续区域的任意子集。所以，画作的总数等于 $1+2^3=9$。\n\n### 子任务\n\n- 测试点 $1 \\sim 5$ 满足 $N,M \\leq 10$。\n- 测试点 $ 6 \\sim 15$ 没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO20JAN] Cave Paintings P", "background": "", "description": "Bessie 成为了一名艺术家，正在创作壁画！她现在正在创作的作品是一个高为 $N$ 的方阵，方阵的每行都由 $M$ 个方格组成（$1\\le N,M\\le 1000$）。每个方格是空的，画了石头，或者画了水。Bessie 已经画上了包含石头的方格，包括整幅画作的边界。她现在想要将某些空的方格画上水，使得如果这幅画是真实的，其中应当不存在水的净移动。定义从上到下第 $i$ 行的方格的高度为 $N+1-i$。Bessie 想要她的画作满足以下限制：\n\n假设方格 $a$ 画的是水。那么如果存在一条从 $a$ 到方格 $b$ 的路径，由高度不超过 $a$ 的空的方格或是有水的方格组成，路径中每相邻两个方格都有一条公共边，那么 $b$ 画的也是水。\n\n求 Bessie 可以创作的不同作品的数量模 $10^9+7$ 的余数。Bessie 可以将任意数量的空格画上水，包括不画以及全画。", "inputFormat": "输入的第一行包含两个空格分隔的整数 $N$ 和 $M$。\n\n以下 $N$ 行每行包含 $M$ 个字符。每个字符均为 `.` 或 `#`，分别表示一个空的方格和一个画有石头的方格。第一行和最后一行、第一列和最后一列仅包含 `#`。", "outputFormat": "输出一个整数，为满足限制的作品的数量模 $10^9+7$ 的余数。", "hint": "### 样例解释\n\n如果第二行中的任意一个方格被画上水，那么所有空的方格必须都被画上水。否则，假设没有这样的方格画有水。那么 Bessie 可以选择画上第三行的空格组成的三个连续区域的任意子集。所以，画作的总数等于 $1+2^3=9$。\n\n### 子任务\n\n- 测试点 $1 \\sim 5$ 满足 $N,M \\leq 10$。\n- 测试点 $ 6 \\sim 15$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P6009", "type": "P", "difficulty": 6, "samples": [["5 2\n1 2 1 1 2\n3\n2 3\n4 5\n1 5", "3\n4\n20"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "2020", "USACO", "矩阵运算", "分治"], "title": "[USACO20JAN] Non-Decreasing Subsequences P", "background": "", "description": "Bessie 最近参加了一场 USACO 竞赛，遇到了以下问题。当然 Bessie 知道怎么做。那你呢？\n\n考虑一个仅由范围在 $1 \\ldots K$（$1 \\leq K \\leq 20$）之间的整数组成的长为 $N$ 的序列 $A_1,A_2, \\ldots ,A_N$（$1 \\leq N \\leq 5 \\times 10^4$）。给定 $Q$（ $1 \\leq Q \\leq 2 \\times 10^5$ ）个形式为 $[L_i,R_i]$（$1 \\leq L_i \\leq R_i \\leq N$）的询问。对于每个询问，计算 $A_{L_i},A_{L_i+1}, \\ldots ,A_{R_i}$ 中不下降子序列的数量模 $10^9+7$ 的余数。\n\n$A_L,\\ldots ,A_R$ 的一个不下降子序列是一组索引 （$j_1,j_2, \\ldots ,j_x$），满足 $L\\le j_1<j_2<\\ldots<j_x\\le R$ 以及 $A_{j_1}\\le A_{j_2}\\le \\ldots \\le A_{j_x}$。确保你考虑了空子序列！", "inputFormat": "输入的第一行包含两个空格分隔的整数 $N$ 和 $K$。\n\n第二行包含 $N$ 个空格分隔的整数 $A_1,A_2, \\ldots ,A_N$。\n\n第三行包含一个整数 $Q$。\n\n以下 $Q$ 行每行包含两个空格分隔的整数 $L_i$ 和 $R_i$。", "outputFormat": "对于每个询问 $[L_i,R_i]$，你应当在新的一行内输出 $A_{L_i},A_{L_i+1},\\ldots, A_{R_i}$ 的不下降子序列的数量模 $10^9+7$ 的余数。", "hint": "### 样例解释\n\n对于第一个询问，不下降子序列为 $()$、$(2)$ 和 $(3)$。$(2,3)$ 不是一个不下降子序列，因为 $A_2\\not \\le A_3$。\n\n对于第二个询问，不下降子序列为 $()$、$(4)$、$(5)$ 和 $(4,5)$。\n\n### 子任务\n\n- 测试点 $2 \\sim 3$ 满足 $N \\leq 1000$。\n- 测试点 $4 \\sim 6$ 满足 $K \\leq 5$。\n- 测试点 $7 \\sim 9$ 满足 $Q \\leq 10^5$。\n- 测试点 $10 \\sim 12$ 没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO20JAN] Non-Decreasing Subsequences P", "background": "", "description": "Bessie 最近参加了一场 USACO 竞赛，遇到了以下问题。当然 Bessie 知道怎么做。那你呢？\n\n考虑一个仅由范围在 $1 \\ldots K$（$1 \\leq K \\leq 20$）之间的整数组成的长为 $N$ 的序列 $A_1,A_2, \\ldots ,A_N$（$1 \\leq N \\leq 5 \\times 10^4$）。给定 $Q$（ $1 \\leq Q \\leq 2 \\times 10^5$ ）个形式为 $[L_i,R_i]$（$1 \\leq L_i \\leq R_i \\leq N$）的询问。对于每个询问，计算 $A_{L_i},A_{L_i+1}, \\ldots ,A_{R_i}$ 中不下降子序列的数量模 $10^9+7$ 的余数。\n\n$A_L,\\ldots ,A_R$ 的一个不下降子序列是一组索引 （$j_1,j_2, \\ldots ,j_x$），满足 $L\\le j_1<j_2<\\ldots<j_x\\le R$ 以及 $A_{j_1}\\le A_{j_2}\\le \\ldots \\le A_{j_x}$。确保你考虑了空子序列！", "inputFormat": "输入的第一行包含两个空格分隔的整数 $N$ 和 $K$。\n\n第二行包含 $N$ 个空格分隔的整数 $A_1,A_2, \\ldots ,A_N$。\n\n第三行包含一个整数 $Q$。\n\n以下 $Q$ 行每行包含两个空格分隔的整数 $L_i$ 和 $R_i$。", "outputFormat": "对于每个询问 $[L_i,R_i]$，你应当在新的一行内输出 $A_{L_i},A_{L_i+1},\\ldots, A_{R_i}$ 的不下降子序列的数量模 $10^9+7$ 的余数。", "hint": "### 样例解释\n\n对于第一个询问，不下降子序列为 $()$、$(2)$ 和 $(3)$。$(2,3)$ 不是一个不下降子序列，因为 $A_2\\not \\le A_3$。\n\n对于第二个询问，不下降子序列为 $()$、$(4)$、$(5)$ 和 $(4,5)$。\n\n### 子任务\n\n- 测试点 $2 \\sim 3$ 满足 $N \\leq 1000$。\n- 测试点 $4 \\sim 6$ 满足 $K \\leq 5$。\n- 测试点 $7 \\sim 9$ 满足 $Q \\leq 10^5$。\n- 测试点 $10 \\sim 12$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P6010", "type": "P", "difficulty": 6, "samples": [["4\n3 5 10 2\n3 3 2 1", "7/2\n7/2\n5/1\n-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["贪心", "2020", "倍增", "二分", "USACO", "凸包"], "title": "[USACO20JAN] Falling Portals P", "background": "", "description": "有 $N$（$2 \\leq N \\leq 2 \\times 10^5$）个世界，每个世界有一个传送门。初始时，世界 $i$（对于 $1 \\leq i \\leq N$）位于 $x$ 坐标 $i$，$y$ 坐标 $A_i$（$1 \\leq A_i \\leq 10^9$）。每个世界里还有一头奶牛。在时刻 $0$，所有的 $y$ 坐标各不相同，然后这些世界开始坠落：世界 $i$ 沿着 $y$ 轴负方向以 $i$ 单位每秒的速度移动。\n\n在任意时刻，如果两个世界在某一时刻 $y$ 坐标相同（可能是非整数时刻），传送门之间就会“同步”，使得其中一个世界的奶牛可以选择瞬间传送到另一个世界。\n\n对于每一个 $i$，在世界 $i$ 的奶牛想要去往世界 $Q_i$（$Q_i \\neq i$）。帮助每头奶牛求出如果她以最优方案移动需要多少时间。\n\n每个询问的输出是一个分数 $a/b$，其中 $a$ 和 $b$ 为互质的正整数，或者 $-1$，如果不可能到达。", "inputFormat": "输入的第一行包含一个整数 $N$。\n\n下一行包含 $N$ 个空格分隔的整数 $A_1,A_2,\\ldots,A_N$。\n\n下一行包含 $N$ 个空格分隔的整数 $Q_1,Q_2,\\ldots,Q_N$。", "outputFormat": "输出 $N$ 行，第 $i$ 行包含奶牛 $i$ 的旅程的时间。", "hint": "### 样例解释\n\n考虑原先在世界 $2$ 的奶牛的答案。在时刻 $2$ 世界 $1$ 和世界 $2$ 同步，所以奶牛可以前往世界 $1$。在时刻 $\\frac{7}{2}$ 世界 $1$ 和世界 $3$ 同步，所以奶牛可以前往世界 $3$。\n\n### 子任务\n\n- 测试点 $2 \\sim 3$ 满足 $N \\leq 100$。\n- 测试点 $4 \\sim 5$ 满足 $N \\leq 2000$。\n- 测试点 $6 \\sim 14$ 没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO20JAN] Falling Portals P", "background": "", "description": "有 $N$（$2 \\leq N \\leq 2 \\times 10^5$）个世界，每个世界有一个传送门。初始时，世界 $i$（对于 $1 \\leq i \\leq N$）位于 $x$ 坐标 $i$，$y$ 坐标 $A_i$（$1 \\leq A_i \\leq 10^9$）。每个世界里还有一头奶牛。在时刻 $0$，所有的 $y$ 坐标各不相同，然后这些世界开始坠落：世界 $i$ 沿着 $y$ 轴负方向以 $i$ 单位每秒的速度移动。\n\n在任意时刻，如果两个世界在某一时刻 $y$ 坐标相同（可能是非整数时刻），传送门之间就会“同步”，使得其中一个世界的奶牛可以选择瞬间传送到另一个世界。\n\n对于每一个 $i$，在世界 $i$ 的奶牛想要去往世界 $Q_i$（$Q_i \\neq i$）。帮助每头奶牛求出如果她以最优方案移动需要多少时间。\n\n每个询问的输出是一个分数 $a/b$，其中 $a$ 和 $b$ 为互质的正整数，或者 $-1$，如果不可能到达。", "inputFormat": "输入的第一行包含一个整数 $N$。\n\n下一行包含 $N$ 个空格分隔的整数 $A_1,A_2,\\ldots,A_N$。\n\n下一行包含 $N$ 个空格分隔的整数 $Q_1,Q_2,\\ldots,Q_N$。", "outputFormat": "输出 $N$ 行，第 $i$ 行包含奶牛 $i$ 的旅程的时间。", "hint": "### 样例解释\n\n考虑原先在世界 $2$ 的奶牛的答案。在时刻 $2$ 世界 $1$ 和世界 $2$ 同步，所以奶牛可以前往世界 $1$。在时刻 $\\frac{7}{2}$ 世界 $1$ 和世界 $3$ 同步，所以奶牛可以前往世界 $3$。\n\n### 子任务\n\n- 测试点 $2 \\sim 3$ 满足 $N \\leq 100$。\n- 测试点 $4 \\sim 5$ 满足 $N \\leq 2000$。\n- 测试点 $6 \\sim 14$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P6011", "type": "P", "difficulty": 5, "samples": [["10 4\n1 5 2 6 7 4 9 3 1 5\n2 2 8\n1 3\n1 6\n2 2 8", "2 9\n1 7"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "四川", "各省省选"], "title": "[SCOI2006] 动态最值", "background": "", "description": "有一个包含 $n$ 个元素的数组，要求实现以下操作：\n\n- `DELETE k`：删除位置 $k$ 上的数。右边的数往左移一个位置。\n- `QUERY i j`：查询位置 $i\\sim j$ 上所有数的最小值和最大值。\n\n例如有 $10$ 个元素：\n\n| 位置 | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ | $9$ | $\t10$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | \n| 元素 | $1$ | $5$ | $2$ | $6$ | $7$ | $4$ | $9$ | $3$ | $1$ | $5$ |\n\n`QUERY 2 8` 的结果为 `2 9`。依次执行 `DELETE 3` 和 `DELETE 6`（注意这时删除的是原始数组的元素 $7$）后数组变为：\n\n| 位置 | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | \n| 元素 | $1$ | $5$ | $6$ | $7$ | $4$ | $3$ | $1$ | $5$ |\n\n`QUERY 2 8` 的结果为 `1 7`。\n", "inputFormat": "第一行包含两个数 $n,m$，表示原始数组的元素个数和操作的个数。  \n第二行包括 $n$ 个数，表示原始数组。  \n以下 $m$ 行，每行格式为 `1 k` 或者 `2 i j`，其中第一个数为 $1$ 表示删除操作，为 $2$ 表示询问操作。", "outputFormat": "对每个询问操作输出一行，包括两个数，表示该范围内的最小值和最大值。", "hint": "对于 $50\\%$ 的数据，$1 \\le n, m \\le {10}^4$，删除操作不超过 $100$ 个。  \n对于 $100\\%$ 的数据，$1 \\le n, m \\le {10}^6$，数组中的元素绝对值均不超过 ${10}^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[SCOI2006] 动态最值", "background": "", "description": "有一个包含 $n$ 个元素的数组，要求实现以下操作：\n\n- `DELETE k`：删除位置 $k$ 上的数。右边的数往左移一个位置。\n- `QUERY i j`：查询位置 $i\\sim j$ 上所有数的最小值和最大值。\n\n例如有 $10$ 个元素：\n\n| 位置 | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ | $9$ | $\t10$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | \n| 元素 | $1$ | $5$ | $2$ | $6$ | $7$ | $4$ | $9$ | $3$ | $1$ | $5$ |\n\n`QUERY 2 8` 的结果为 `2 9`。依次执行 `DELETE 3` 和 `DELETE 6`（注意这时删除的是原始数组的元素 $7$）后数组变为：\n\n| 位置 | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | \n| 元素 | $1$ | $5$ | $6$ | $7$ | $4$ | $3$ | $1$ | $5$ |\n\n`QUERY 2 8` 的结果为 `1 7`。\n", "inputFormat": "第一行包含两个数 $n,m$，表示原始数组的元素个数和操作的个数。  \n第二行包括 $n$ 个数，表示原始数组。  \n以下 $m$ 行，每行格式为 `1 k` 或者 `2 i j`，其中第一个数为 $1$ 表示删除操作，为 $2$ 表示询问操作。", "outputFormat": "对每个询问操作输出一行，包括两个数，表示该范围内的最小值和最大值。", "hint": "对于 $50\\%$ 的数据，$1 \\le n, m \\le {10}^4$，删除操作不超过 $100$ 个。  \n对于 $100\\%$ 的数据，$1 \\le n, m \\le {10}^6$，数组中的元素绝对值均不超过 ${10}^9$。", "locale": "zh-CN"}}}
{"pid": "P6012", "type": "P", "difficulty": 6, "samples": [["3 3\n1 1 1", "1"], ["4 3\n1 1 1 2", "7"], ["10 7\n11 45 14 19 19 8 10 8 17 23", "693404716"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "快速傅里叶变换 FFT"], "title": "[P5087] 数学 加强版", "background": "[原题链接](https://www.luogu.com.cn/problem/P5087)", "description": "小奔热衷于乘法，他最喜欢做的事情是：从一个有 $n$ 个元素的可重集中选出 $k$ 个数，并把这 $k$ 个数的乘积作为这个组合的分数。\n\n小奔想试遍所有的这些组合，然后算出所有这些组合的分数之和。但是他还要出模拟赛虐爆我们这些蒟蒻，所以他只好把这个任务交给了你。\n\n作为不良心的出题人，这题你还要将答案对 $10^9 + 7$ 取模。\n", "inputFormat": "第一行两个正整数 $n,k$。  \n第二行 $n$ 个正整数 $a_i$，表示可重集中的元素。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【样例二解释】  \n有四种选择方案，一种是 $\\{1,1,1\\}$ 和三种都是 $\\{1,1,2\\}$，分数之和为 $7$。\n\n【数据范围】  \n对于 $100\\%$ 的数据，$1\\le k \\le n \\le 1.2\\times 10^5$，$1\\le a_i \\le 10^8$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[P5087] 数学 加强版", "background": "[原题链接](https://www.luogu.com.cn/problem/P5087)", "description": "小奔热衷于乘法，他最喜欢做的事情是：从一个有 $n$ 个元素的可重集中选出 $k$ 个数，并把这 $k$ 个数的乘积作为这个组合的分数。\n\n小奔想试遍所有的这些组合，然后算出所有这些组合的分数之和。但是他还要出模拟赛虐爆我们这些蒟蒻，所以他只好把这个任务交给了你。\n\n作为不良心的出题人，这题你还要将答案对 $10^9 + 7$ 取模。\n", "inputFormat": "第一行两个正整数 $n,k$。  \n第二行 $n$ 个正整数 $a_i$，表示可重集中的元素。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【样例二解释】  \n有四种选择方案，一种是 $\\{1,1,1\\}$ 和三种都是 $\\{1,1,2\\}$，分数之和为 $7$。\n\n【数据范围】  \n对于 $100\\%$ 的数据，$1\\le k \\le n \\le 1.2\\times 10^5$，$1\\le a_i \\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P6013", "type": "P", "difficulty": 2, "samples": [["3\n1 10\n2 20\n2 10", "1"], ["5\n1 10\n3 5 5\n2 10\n1 10\n2 20", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "洛谷月赛"], "title": "[CSGRound3] 压岁钱", "background": "祝大家庚子鼠年快乐！Best wishes! \n\n也愿肺炎早日得到控制吧，中国加油！\n\n新年到了，小 Z 总是能收到很多的压岁钱。\n\n小 Z 是个非常喜欢氪金的玩家，所以时不时都会把压岁钱花掉一部分用来买皮肤和石头。\n\n但是小 Z 又十分担心压岁钱没过几天就都被自己花完了。为此，小 Z 有封印大法，能够暂时的把自己的一部分钱封印起来（即无法花费），直到某一天解除封印后才能使用。", "description": "一共存在有 $m$ 个事件，且事件分为以下的 $3$ 种类型。\n\n1. 小 Z 得到了 $a$ 元压岁钱。\n2. 小 Z 花掉了 $a$ 元压岁钱用于买皮肤。\n3. 小 Z 把自己的 $a$ 元钱封印了起来，只有当第 $b$ 个事件发生前 $1$ 秒才会解除封印，并保证每次小 Z 现有的钱大于等于封印的钱。\n\n当小 Z 的钱在某个事件不够花时，小 Z 会感到不开心，同时钱不够花时小 Z 便不会花钱。\n\n请告诉小 Z ，他的钱在几个事件中会不够花。", "inputFormat": "第一行一个整数 $m$，用于表示事件发生的总数。\n\n接下来的 $m$ 行，首先一个整数 $t$，表示事件的类型。\n\n如果 $t=1$ 或 $t=2$，则接下来一个整数 $a$。\n\n如果 $t=3$，则接下来两个整数 $a,b$。", "outputFormat": "一行一个整数，表示**钱不够花**的事件数。", "hint": "**【样例 1 解释】**\n\n第一天：收入 $10$ 元，余额 $10$ 元。\n\n第二天：不够支出 $20$ 元，余额 $10$ 元。\n\n第三天：支出 $10$ 元，余额 $0$ 元。\n\n总计：$1$ 天。\n\n**【样例 2 解释】**\n\n第一天：收入 $10$ 元，余额 $10$ 元。\n\n第二天：封印 $5$ 元，余额 $5$ 元。\n\n第三天：不够支出 $10$ 元，余额 $5$ 元。\n\n第四天：收入 $10$ 元，余额 $15$ 元。\n\n第五天：封印解开，支出 $20$ 元，余额 $0$ 元。\n\n总计：$1$ 天。\n\n---\n\n**【数据范围】**\n\n对于 $50\\%$ 的数据，满足 $m,a \\leq 5\\times 10^3$。\n\n对于 $70\\%$ 的数据，$t \\ne 3$。\n\n对于 $100\\%$ 的数据，满足 $ 1 \\leq b \\le m \\leq 10^6$，$1 \\le t \\le 3$，$1 \\leq a \\leq 10^7$。", "locale": "zh-CN", "translations": {"en": {"title": "[CSGRound3] Lucky Money", "background": "Wishing everyone a happy Year of the Rat in the Gengzi year! Best wishes!\n\nMay the pneumonia outbreak be brought under control as soon as possible. Stay strong, China!\n\nWhen the New Year comes, Xiao Z can always receive a lot of lucky money.\n\nXiao Z is a player who really likes spending money in games, so from time to time he will spend part of his lucky money to buy skins and gems.\n\nBut Xiao Z is also very worried that he will spend all his lucky money in just a few days. To deal with this, Xiao Z has a sealing technique that can temporarily seal away part of his money (meaning it cannot be spent). It can only be used after the seal is lifted on some day.", "description": "There are $m$ events in total, and the events are divided into the following $3$ types.\n\n1. Xiao Z receives $a$ yuan of lucky money.\n2. Xiao Z spends $a$ yuan of lucky money to buy skins.\n3. Xiao Z seals $a$ yuan of his money. The seal will be lifted $1$ second before event $b$ happens. It is guaranteed that each time, the money Xiao Z currently has is greater than or equal to the amount being sealed.\n\nIf Xiao Z does not have enough money to spend on some event, Xiao Z will feel unhappy. At the same time, when he does not have enough money, Xiao Z will not spend the money.\n\nPlease tell Xiao Z in how many events he will not have enough money to spend.", "inputFormat": "The first line contains an integer $m$, which indicates the total number of events.\n\nThe next $m$ lines each start with an integer $t$, indicating the type of the event.\n\nIf $t=1$ or $t=2$, then it is followed by an integer $a$.\n\nIf $t=3$, then it is followed by two integers $a,b$.", "outputFormat": "Output one line with one integer, indicating the number of events in which **there is not enough money to spend**.", "hint": "**[Sample 1 Explanation]**\n\nDay 1: Income $10$ yuan, balance $10$ yuan.\n\nDay 2: Not enough to spend $20$ yuan, balance $10$ yuan.\n\nDay 3: Spend $10$ yuan, balance $0$ yuan.\n\nTotal: $1$ day.\n\n**[Sample 2 Explanation]**\n\nDay 1: Income $10$ yuan, balance $10$ yuan.\n\nDay 2: Seal $5$ yuan, balance $5$ yuan.\n\nDay 3: Not enough to spend $10$ yuan, balance $5$ yuan.\n\nDay 4: Income $10$ yuan, balance $15$ yuan.\n\nDay 5: The seal is lifted, spend $20$ yuan, balance $0$ yuan.\n\nTotal: $1$ day.\n\n---\n\n**[Constraints]**\n\nFor $50\\%$ of the testdata, $m,a \\leq 5\\times 10^3$.\n\nFor $70\\%$ of the testdata, $t \\ne 3$.\n\nFor $100\\%$ of the testdata, $ 1 \\leq b \\le m \\leq 10^6$, $1 \\le t \\le 3$, $1 \\leq a \\leq 10^7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSGRound3] 压岁钱", "background": "祝大家庚子鼠年快乐！Best wishes! \n\n也愿肺炎早日得到控制吧，中国加油！\n\n新年到了，小 Z 总是能收到很多的压岁钱。\n\n小 Z 是个非常喜欢氪金的玩家，所以时不时都会把压岁钱花掉一部分用来买皮肤和石头。\n\n但是小 Z 又十分担心压岁钱没过几天就都被自己花完了。为此，小 Z 有封印大法，能够暂时的把自己的一部分钱封印起来（即无法花费），直到某一天解除封印后才能使用。", "description": "一共存在有 $m$ 个事件，且事件分为以下的 $3$ 种类型。\n\n1. 小 Z 得到了 $a$ 元压岁钱。\n2. 小 Z 花掉了 $a$ 元压岁钱用于买皮肤。\n3. 小 Z 把自己的 $a$ 元钱封印了起来，只有当第 $b$ 个事件发生前 $1$ 秒才会解除封印，并保证每次小 Z 现有的钱大于等于封印的钱。\n\n当小 Z 的钱在某个事件不够花时，小 Z 会感到不开心，同时钱不够花时小 Z 便不会花钱。\n\n请告诉小 Z ，他的钱在几个事件中会不够花。", "inputFormat": "第一行一个整数 $m$，用于表示事件发生的总数。\n\n接下来的 $m$ 行，首先一个整数 $t$，表示事件的类型。\n\n如果 $t=1$ 或 $t=2$，则接下来一个整数 $a$。\n\n如果 $t=3$，则接下来两个整数 $a,b$。", "outputFormat": "一行一个整数，表示**钱不够花**的事件数。", "hint": "**【样例 1 解释】**\n\n第一天：收入 $10$ 元，余额 $10$ 元。\n\n第二天：不够支出 $20$ 元，余额 $10$ 元。\n\n第三天：支出 $10$ 元，余额 $0$ 元。\n\n总计：$1$ 天。\n\n**【样例 2 解释】**\n\n第一天：收入 $10$ 元，余额 $10$ 元。\n\n第二天：封印 $5$ 元，余额 $5$ 元。\n\n第三天：不够支出 $10$ 元，余额 $5$ 元。\n\n第四天：收入 $10$ 元，余额 $15$ 元。\n\n第五天：封印解开，支出 $20$ 元，余额 $0$ 元。\n\n总计：$1$ 天。\n\n---\n\n**【数据范围】**\n\n对于 $50\\%$ 的数据，满足 $m,a \\leq 5\\times 10^3$。\n\n对于 $70\\%$ 的数据，$t \\ne 3$。\n\n对于 $100\\%$ 的数据，满足 $ 1 \\leq b \\le m \\leq 10^6$，$1 \\le t \\le 3$，$1 \\leq a \\leq 10^7$。", "locale": "zh-CN"}}}
{"pid": "P6014", "type": "P", "difficulty": 3, "samples": [["5\n10 10 10 2 3", "5"], ["5\n3 4 5 6 7", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "洛谷月赛"], "title": "[CSGRound3] 斗牛", "background": "又是一年过去了。小 Z 在春节期间可以好好的放松放松，于是小 Z 和小伙伴们玩起了牛哄哄（斗牛）。\n\n游戏规则是这样的：\n\n给定 $5$ 张牌，分别从 $1 \\sim 10$。你需要挑选其中的三张牌加起来是 $10$ 的倍数，另外两张牌的和的个位数则为你最后获得的点数，特别的，如果这两张牌的和是 $10$ 的倍数，则点数为 $10$，也叫做牛哄哄。如果不能构成 $10$ 的倍数，则点数为 $0$，也叫做牛不拢。\n\n如 $5$ $3$ $2$ $3$ $4$ 的点数是 $7$，又叫做牛七。\n\n小 Z 觉得玩的不过瘾，于是对上述规则进行了一些改变。", "description": "给定 $n$ 张牌，牌的大小为 $1 \\sim 10$。你需要挑选其中的 $n-2$ 张牌加起来是 $10$ 的倍数，另外两张牌和的个位数即为你所获得的点数。特别地，如果这两张牌的和是 $10$ 的倍数，则点数为 $10$，也叫做牛哄哄。如果任意 $n-2$ 张牌不能构成 $10$ 的倍数，则点数为 $0$，也叫做牛不拢。\n\n由于小 Z 想要更开心的玩耍，所以需要你来完成这个程序来帮助小 Z 在 $1$ 秒内知道点数。", "inputFormat": "第一行一个整数 $n$，表示一共有 $n$ 张牌。\n\n第二行 $n$ 个整数，表示这 $n$ 张牌的大小。", "outputFormat": "一行一个整数，表示这局牌的点数，点数的范围是 $0 \\sim 10$。", "hint": "**【样例 1 解释】**\n\n$10$ $10$ $10$ 三张牌凑成 $10$ 的倍数，$2+3=5$。\n\n**【样例 2 解释】**\n\n任意三张牌都不能凑成 $10$ 的倍数。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（50 points）：$n = 5$。\n- Subtask 2（30 points）：$n \\le 5 \\times 10^3$。\n- Subtask 3（20 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$5 \\le n \\le 10^6$。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[CSGRound3] Bullfighting", "background": "Another year has passed. During the Spring Festival, Little Z can relax well, so Little Z and friends started playing “Niu Honghong” (Bullfighting).\n\nThe rules are as follows:\n\nGiven $5$ cards, each with a value from $1 \\sim 10$. You need to choose three of them such that their sum is a multiple of $10$. The last two cards’ sum’s ones digit is the score you get. In particular, if the sum of these two cards is a multiple of $10$, then the score is $10$, which is also called “Niu Honghong”. If no such multiple of $10$ can be formed, then the score is $0$, which is also called “Niu Bu Long”.\n\nFor example, the hand $5$ $3$ $2$ $3$ $4$ scores $7$, also called “Niu Qi”.\n\nLittle Z felt it was not exciting enough, so some changes were made to the rules above.", "description": "Given $n$ cards, each with a value from $1 \\sim 10$. You need to choose $n-2$ of them such that their sum is a multiple of $10$. The ones digit of the sum of the remaining two cards is the score you obtain. In particular, if the sum of these two cards is a multiple of $10$, then the score is $10$, which is also called “Niu Honghong”. If no choice of $n-2$ cards can make a multiple of $10$, then the score is $0$, which is also called “Niu Bu Long”.\n\nSince Little Z wants to play more happily, you need to write a program to help Little Z know the score within $1$ second.", "inputFormat": "The first line contains an integer $n$, indicating there are $n$ cards in total.\n\nThe second line contains $n$ integers, representing the values of these $n$ cards.", "outputFormat": "Output one integer in a single line, representing the score of this hand. The score ranges from $0 \\sim 10$.", "hint": "**Sample 1 Explanation**\n\n$10$ $10$ $10$ (three cards) can form a multiple of $10$, and $2+3=5$.\n\n**Sample 2 Explanation**\n\nAny three cards cannot form a multiple of $10$.\n\n---\n\n**Constraints**\n\n**This problem uses bundled tests.**\n\n- Subtask 1 (50 points): $n = 5$.\n- Subtask 2 (30 points): $n \\le 5 \\times 10^3$.\n- Subtask 3 (20 points): no special constraints.\n\nFor $100\\%$ of the testdata, $5 \\le n \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSGRound3] 斗牛", "background": "又是一年过去了。小 Z 在春节期间可以好好的放松放松，于是小 Z 和小伙伴们玩起了牛哄哄（斗牛）。\n\n游戏规则是这样的：\n\n给定 $5$ 张牌，分别从 $1 \\sim 10$。你需要挑选其中的三张牌加起来是 $10$ 的倍数，另外两张牌的和的个位数则为你最后获得的点数，特别的，如果这两张牌的和是 $10$ 的倍数，则点数为 $10$，也叫做牛哄哄。如果不能构成 $10$ 的倍数，则点数为 $0$，也叫做牛不拢。\n\n如 $5$ $3$ $2$ $3$ $4$ 的点数是 $7$，又叫做牛七。\n\n小 Z 觉得玩的不过瘾，于是对上述规则进行了一些改变。", "description": "给定 $n$ 张牌，牌的大小为 $1 \\sim 10$。你需要挑选其中的 $n-2$ 张牌加起来是 $10$ 的倍数，另外两张牌和的个位数即为你所获得的点数。特别地，如果这两张牌的和是 $10$ 的倍数，则点数为 $10$，也叫做牛哄哄。如果任意 $n-2$ 张牌不能构成 $10$ 的倍数，则点数为 $0$，也叫做牛不拢。\n\n由于小 Z 想要更开心的玩耍，所以需要你来完成这个程序来帮助小 Z 在 $1$ 秒内知道点数。", "inputFormat": "第一行一个整数 $n$，表示一共有 $n$ 张牌。\n\n第二行 $n$ 个整数，表示这 $n$ 张牌的大小。", "outputFormat": "一行一个整数，表示这局牌的点数，点数的范围是 $0 \\sim 10$。", "hint": "**【样例 1 解释】**\n\n$10$ $10$ $10$ 三张牌凑成 $10$ 的倍数，$2+3=5$。\n\n**【样例 2 解释】**\n\n任意三张牌都不能凑成 $10$ 的倍数。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（50 points）：$n = 5$。\n- Subtask 2（30 points）：$n \\le 5 \\times 10^3$。\n- Subtask 3（20 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$5 \\le n \\le 10^6$。\n\n", "locale": "zh-CN"}}}
{"pid": "P6015", "type": "P", "difficulty": 4, "samples": [["5\n1 4 3 2 2\n5\n", "3\n1 2 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷月赛"], "title": "[CSGRound3] 游戏", "background": "小 Y 和小 Z 是一对好朋友，他们在玩一个游戏。**游戏只有一个回合**。", "description": "有一个牌堆，一共有 $n$ 张牌，第 $i$ 张牌上有一个数 $a_i$，其中第一张牌是堆顶。\n\n小 Z 先取牌，他可以从堆顶开始取连续若干张牌（**可以取 $0$ 张**），取完的牌拿在手上，也就是不在牌堆里了。\n\n然后小 Y 取牌，同样，她也可以从堆顶开始取连续若干张牌（**可以取 $0$ 张**）。\n\n如果一个人手上的牌的数字和大于 $X$，那么他的分数就是 $0$，否则分数就是数字和。\n\n分数高的人获胜，**如果一样高，则无人获胜**。\n\n小 Z 为了获胜，使用了透视挂，即他知道牌堆里每张牌上写的数。\n\n现在问你对于满足 $1 \\leq X \\leq K$ 的所有整数 $X$，哪些可以使得小 Z 有必胜策略，即小 Z 取完后，不管小 Y 怎么取都一定会**输**。", "inputFormat": "第一行一个整数 $n$，表示牌堆里有几张牌。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$，表示每张牌上写的数。\n\n第三行一个正整数 $K$，含义见题目描述。", "outputFormat": "第一行一个整数，表示满足要求的 $X$ 的个数。\n\n第二行从小到大依次输出满足要求的 $X$，用空格隔开。", "hint": "**【样例解释】**\n\n$X=1,2,3$ 时，小 Z 取一张牌，小 Y 不管怎么取都是零分。\n\n$X=4$ 时，小 Z 如果取 $1$ 张，那么小 Y 取 $1$ 张小 Y 就赢了；否则小 Z 只能是零分。\n\n$X=5$ 时，小 Z 如果取 $1$ 张，那么小 Y 取 $1$ 张小 Y 就赢了；小 Z 如果取了 $2$ 张，小 Y 也取 $2$ 张，平局；否则小 Z 只能是零分。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（3 points）：$n = 1$。\n- Subtask 2（14 points）：$K= 1$。\n- Subtask 3（20 points）：$n,K \\le 100$。\n- Subtask 4（33 points）：$n , K \\le 3333$。\n- Subtask 5（30 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\leq n,K \\leq 10^6$，$1\\leq a_i \\leq K$。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[CSGRound3] Game", "background": "Player Y and Player Z are a pair of good friends, and they are playing a game. **The game has only one round**.", "description": "There is a deck with a total of $n$ cards. The $i$-th card has a number $a_i$ written on it, where the first card is the top of the deck.\n\nPlayer Z draws first. He may draw a consecutive number of cards starting from the top of the deck (**he may draw $0$ cards**). The drawn cards are held in his hand, meaning they are removed from the deck.\n\nThen Player Y draws. Similarly, she may draw a consecutive number of cards starting from the top of the deck (**she may draw $0$ cards**).\n\nIf the sum of the numbers on a player's hand is greater than $X$, then their score is $0$; otherwise, their score equals the sum.\n\nThe player with the higher score wins; **if the scores are equal, then nobody wins**.\n\nIn order to win, Player Z uses a cheating tool (x-ray vision), meaning he knows the number written on every card in the deck.\n\nNow, for all integers $X$ satisfying $1 \\leq X \\leq K$, determine which values of $X$ allow Player Z to have a winning strategy, i.e., after Player Z finishes drawing, no matter how Player Y draws, Player Y will definitely **lose**.", "inputFormat": "The first line contains an integer $n$, representing the number of cards in the deck.\n\nThe second line contains $n$ integers $a_{1\\dots n}$, representing the number written on each card.\n\nThe third line contains a positive integer $K$, as described in the statement.", "outputFormat": "The first line contains an integer, representing the number of values $X$ that satisfy the requirement.\n\nThe second line outputs the values of $X$ that satisfy the requirement in increasing order, separated by spaces.", "hint": "**[Sample Explanation]**\n\nWhen $X=1,2,3$, Player Z draws one card, and no matter how Player Y draws, Player Y will get a score of $0$.\n\nWhen $X=4$, if Player Z draws $1$ card, then if Player Y draws $1$ card, Player Y will win; otherwise, Player Z can only get a score of $0$.\n\nWhen $X=5$, if Player Z draws $1$ card, then if Player Y draws $1$ card, Player Y will win. If Player Z draws $2$ cards, then Player Y also draws $2$ cards, resulting in a tie. Otherwise, Player Z can only get a score of $0$.\n\n---\n\n**[Constraints]**\n\n**This problem uses bundled testdata.**\n\n- Subtask 1 (3 points): $n = 1$.\n- Subtask 2 (14 points): $K = 1$.\n- Subtask 3 (20 points): $n, K \\le 100$.\n- Subtask 4 (33 points): $n, K \\le 3333$.\n- Subtask 5 (30 points): no special restrictions.\n\nFor $100\\%$ of the testdata, $1 \\leq n, K \\leq 10^6$, $1 \\leq a_i \\leq K$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSGRound3] 游戏", "background": "小 Y 和小 Z 是一对好朋友，他们在玩一个游戏。**游戏只有一个回合**。", "description": "有一个牌堆，一共有 $n$ 张牌，第 $i$ 张牌上有一个数 $a_i$，其中第一张牌是堆顶。\n\n小 Z 先取牌，他可以从堆顶开始取连续若干张牌（**可以取 $0$ 张**），取完的牌拿在手上，也就是不在牌堆里了。\n\n然后小 Y 取牌，同样，她也可以从堆顶开始取连续若干张牌（**可以取 $0$ 张**）。\n\n如果一个人手上的牌的数字和大于 $X$，那么他的分数就是 $0$，否则分数就是数字和。\n\n分数高的人获胜，**如果一样高，则无人获胜**。\n\n小 Z 为了获胜，使用了透视挂，即他知道牌堆里每张牌上写的数。\n\n现在问你对于满足 $1 \\leq X \\leq K$ 的所有整数 $X$，哪些可以使得小 Z 有必胜策略，即小 Z 取完后，不管小 Y 怎么取都一定会**输**。", "inputFormat": "第一行一个整数 $n$，表示牌堆里有几张牌。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$，表示每张牌上写的数。\n\n第三行一个正整数 $K$，含义见题目描述。", "outputFormat": "第一行一个整数，表示满足要求的 $X$ 的个数。\n\n第二行从小到大依次输出满足要求的 $X$，用空格隔开。", "hint": "**【样例解释】**\n\n$X=1,2,3$ 时，小 Z 取一张牌，小 Y 不管怎么取都是零分。\n\n$X=4$ 时，小 Z 如果取 $1$ 张，那么小 Y 取 $1$ 张小 Y 就赢了；否则小 Z 只能是零分。\n\n$X=5$ 时，小 Z 如果取 $1$ 张，那么小 Y 取 $1$ 张小 Y 就赢了；小 Z 如果取了 $2$ 张，小 Y 也取 $2$ 张，平局；否则小 Z 只能是零分。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（3 points）：$n = 1$。\n- Subtask 2（14 points）：$K= 1$。\n- Subtask 3（20 points）：$n,K \\le 100$。\n- Subtask 4（33 points）：$n , K \\le 3333$。\n- Subtask 5（30 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\leq n,K \\leq 10^6$，$1\\leq a_i \\leq K$。\n\n", "locale": "zh-CN"}}}
{"pid": "P6016", "type": "P", "difficulty": 5, "samples": [["3 1\n1 2 2 3\n0 1 3\n499122177 1 2", "1"], ["3 3\n1 2 2 3\n0 1 3\n233 1 2", "466\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化", "洛谷月赛"], "title": "[CSGRound3] 出游", "background": "", "description": "学校组织了一次暑期出游活动，报名将在第 $T$ 天截止。\n\n一共有 $n$ 位同学，第 $i$ 位同学有 $a_i$ 位朋友。朋友关系是单向的，换句话说，小 Z 有一个朋友是小 Y，并不意味着小 Y 一定也有一个朋友是小 Z。另外，自己也可能是自己的朋友。\n\n第 $0$ 天时，每位同学会决定自己是否参加活动。第 $i$ 位同学有 $p_i$ 的概率决定参加，$1-p_i$ 的概率决定不参加。\n\n接下来的 $T$ 天里，每位同学会重新决定自己是否参加活动。第 $i$ 位同学这一天决定参加活动，当且仅当至少有一个他的朋友在前一天决定参加，否则便不参加。\n\n你需要求出参加活动的同学人数期望，答案对 $998244353$ 取模。", "inputFormat": "第一行两个整数 $n,T$，含义见题目描述。\n\n接下来 $n$ 行，每行首先两个整数 $p_i, a_i$，$p_i$ 表示模 $998244353$ 意义下第 $i$ 位同学在第 $0$ 天决定参加的概率，$a_i$ 表示他的朋友数量，接下来 $a_i$ 个整数，表示他的朋友。", "outputFormat": "一行一个整数，表示答案对 $998244353$ 取模后的值。", "hint": "**【样例 1 解释】**\n\n| 天数 | 第一位同学去的概率 | 第二位同学去的概率 | 第三位同学去的概率 |\n| :--: | :----------------: | :----------------: | :----------------: |\n| $0$  |        $1$         |        $0$         |     $\\frac 12$     |\n| $1$  |    $\\frac 12 $     |    $\\frac 12 $     |        $0$         |\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（3 points）：$T = 0$。\n- Subtask 2（14 points）：$T = 1$。\n- Subtask 3（33 points）：$n \\le 10$。\n- Subtask 4（20 points）：$T \\le 5 \\times 10^3$。\n- Subtask 5（15 points）：$n \\le 100$。\n- Subtask 6（15 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 500$，$0 \\le T \\le 10^9$，$0 \\le p_i < 998244353$，$0 \\le a_i \\le n$ 且朋友互不相同。", "locale": "zh-CN", "translations": {"en": {"title": "[CSGRound3] Trip", "background": "", "description": "The school organized a summer trip, and registration will close on day $T$.\n\nThere are $n$ students. Student $i$ has $a_i$ friends. The friendship relation is directed. In other words, if student Z has student Y as a friend, it does not mean student Y must have student Z as a friend. Also, a student may be their own friend.\n\nOn day $0$, each student decides whether to join the trip. Student $i$ decides to join with probability $p_i$, and decides not to join with probability $1-p_i$.\n\nDuring the next $T$ days, each student will decide again whether to join. On that day, student $i$ decides to join if and only if at least one of their friends decided to join on the previous day; otherwise, they do not join.\n\nYou need to compute the expected number of students who join the trip. Output the answer modulo $998244353$.", "inputFormat": "The first line contains two integers $n, T$, as described above.\n\nThe next $n$ lines each start with two integers $p_i, a_i$. Here, $p_i$ is the probability (under modulo $998244353$) that student $i$ decides to join on day $0$, and $a_i$ is the number of their friends. Then follow $a_i$ integers indicating their friends.", "outputFormat": "Output one integer, the answer modulo $998244353$.", "hint": "**[Sample 1 Explanation]**\n\n| Day | Probability that the first student goes | Probability that the second student goes | Probability that the third student goes |\n| :--: | :------------------------------------: | :-------------------------------------: | :------------------------------------: |\n| $0$  |                  $1$                   |                  $0$                    |              $\\frac 12$                |\n| $1$  |               $\\frac 12 $              |               $\\frac 12 $               |                  $0$                   |\n\n---\n\n**[Constraints]**\n\n**This problem uses bundled testdata.**\n\n- Subtask 1 (3 points): $T = 0$.\n- Subtask 2 (14 points): $T = 1$.\n- Subtask 3 (33 points): $n \\le 10$.\n- Subtask 4 (20 points): $T \\le 5 \\times 10^3$.\n- Subtask 5 (15 points): $n \\le 100$.\n- Subtask 6 (15 points): No special constraints.\n\nFor $100\\%$ of the testdata: $1 \\le n \\le 500$, $0 \\le T \\le 10^9$, $0 \\le p_i < 998244353$, $0 \\le a_i \\le n$, and all friends are distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSGRound3] 出游", "background": "", "description": "学校组织了一次暑期出游活动，报名将在第 $T$ 天截止。\n\n一共有 $n$ 位同学，第 $i$ 位同学有 $a_i$ 位朋友。朋友关系是单向的，换句话说，小 Z 有一个朋友是小 Y，并不意味着小 Y 一定也有一个朋友是小 Z。另外，自己也可能是自己的朋友。\n\n第 $0$ 天时，每位同学会决定自己是否参加活动。第 $i$ 位同学有 $p_i$ 的概率决定参加，$1-p_i$ 的概率决定不参加。\n\n接下来的 $T$ 天里，每位同学会重新决定自己是否参加活动。第 $i$ 位同学这一天决定参加活动，当且仅当至少有一个他的朋友在前一天决定参加，否则便不参加。\n\n你需要求出参加活动的同学人数期望，答案对 $998244353$ 取模。", "inputFormat": "第一行两个整数 $n,T$，含义见题目描述。\n\n接下来 $n$ 行，每行首先两个整数 $p_i, a_i$，$p_i$ 表示模 $998244353$ 意义下第 $i$ 位同学在第 $0$ 天决定参加的概率，$a_i$ 表示他的朋友数量，接下来 $a_i$ 个整数，表示他的朋友。", "outputFormat": "一行一个整数，表示答案对 $998244353$ 取模后的值。", "hint": "**【样例 1 解释】**\n\n| 天数 | 第一位同学去的概率 | 第二位同学去的概率 | 第三位同学去的概率 |\n| :--: | :----------------: | :----------------: | :----------------: |\n| $0$  |        $1$         |        $0$         |     $\\frac 12$     |\n| $1$  |    $\\frac 12 $     |    $\\frac 12 $     |        $0$         |\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（3 points）：$T = 0$。\n- Subtask 2（14 points）：$T = 1$。\n- Subtask 3（33 points）：$n \\le 10$。\n- Subtask 4（20 points）：$T \\le 5 \\times 10^3$。\n- Subtask 5（15 points）：$n \\le 100$。\n- Subtask 6（15 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 500$，$0 \\le T \\le 10^9$，$0 \\le p_i < 998244353$，$0 \\le a_i \\le n$ 且朋友互不相同。", "locale": "zh-CN"}}}
{"pid": "P6017", "type": "P", "difficulty": 7, "samples": [["7\n4 4\n5 6\n50 70\n90 102\n40 41\n2000 1999\n1785 2425", "13\n5\n442759796\n851878741\n292277388\n943337434\n183253103"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["洛谷月赛"], "title": "[CSGRound3] 仙人掌", "background": "ckw 是一个非常菜的菜鸡。", "description": "ckw 有好多边仙人掌。边仙人掌是一个每条边至多在一个简单环里的简单无向连通图。 \n\nckw 定义了无向图的度数序列，度数序列的长度为图中点的个数，度数序列中第 $i$ 个元素是图中编号为 $i$ 的节点的度数。\n\nckw 想知道，对于所有 $n$ 个点 $m$ 条边的边仙人掌，其不同的度数序列有多少种。\n\n输出答案模 $998244353$ 之后的结果即可。（如果不存在合法仙人掌输出 $0$ 即可）", "inputFormat": "**本题有多组数据**\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据，一行两个整数 $n,m$，分别表示点数和边数。", "outputFormat": "对于每组数据，一行一个整数，表示答案对 $998244353$ 取模后的值。", "hint": "**【样例解释】**\n\n对于第一组数据，这里给出其中四个合法的度数序列：$\\{2,2,2,2\\},\\{1,2,2,3\\},\\{1,2,3,2\\},\\{2,1,3,2\\}$。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（8 points）：$n \\le 5$。\n- Subtask 2（10 points）：$n \\le 10 $。\n- Subtask 3（18 points）：$n \\le 35$。\n- Subtask 4（12 points）：$n \\le 90$。\n- Subtask 5（8 points）：$m = n - 1$。\n- Subtask 6（10 points）：$m = n$。\n- Subtask 7（16 points）：$m = n + 1$。\n- Subtask 8（18 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 10$，$0 \\le n \\le 2 \\times 10^3$，$0 \\le m \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[CSGRound3] Cactus", "background": "ckw is a very weak newbie.", "description": "ckw has many edge-cactus graphs. An edge-cactus graph is a simple undirected connected graph in which each edge belongs to at most one simple cycle.\n\nckw defines the degree sequence of an undirected graph. The length of the degree sequence is the number of vertices in the graph, and the $i$-th element of the degree sequence is the degree of the vertex numbered $i$.\n\nckw wants to know: among all edge-cactus graphs with $n$ vertices and $m$ edges, how many different degree sequences are there.\n\nOutput the answer modulo $998244353$. (If no valid cactus exists, output $0$.)", "inputFormat": "**This problem has multiple test cases.**\n\nThe first line contains an integer $T$, the number of test cases.\n\nFor each test case, one line contains two integers $n, m$, representing the number of vertices and the number of edges.", "outputFormat": "For each test case, output one integer per line, the answer modulo $998244353$.", "hint": "**[Sample Explanation]**\n\nFor the first test case, here are four valid degree sequences: $\\{2,2,2,2\\},\\{1,2,2,3\\},\\{1,2,3,2\\},\\{2,1,3,2\\}$.\n\n---\n\n**[Constraints]**\n\n**This problem uses bundled testdata.**\n\n- Subtask 1 (8 points): $n \\le 5$.\n- Subtask 2 (10 points): $n \\le 10$.\n- Subtask 3 (18 points): $n \\le 35$.\n- Subtask 4 (12 points): $n \\le 90$.\n- Subtask 5 (8 points): $m = n - 1$.\n- Subtask 6 (10 points): $m = n$.\n- Subtask 7 (16 points): $m = n + 1$.\n- Subtask 8 (18 points): no special constraints.\n\nFor $100\\%$ of the testdata, $1 \\le T \\le 10$, $0 \\le n \\le 2 \\times 10^3$, $0 \\le m \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSGRound3] 仙人掌", "background": "ckw 是一个非常菜的菜鸡。", "description": "ckw 有好多边仙人掌。边仙人掌是一个每条边至多在一个简单环里的简单无向连通图。 \n\nckw 定义了无向图的度数序列，度数序列的长度为图中点的个数，度数序列中第 $i$ 个元素是图中编号为 $i$ 的节点的度数。\n\nckw 想知道，对于所有 $n$ 个点 $m$ 条边的边仙人掌，其不同的度数序列有多少种。\n\n输出答案模 $998244353$ 之后的结果即可。（如果不存在合法仙人掌输出 $0$ 即可）", "inputFormat": "**本题有多组数据**\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据，一行两个整数 $n,m$，分别表示点数和边数。", "outputFormat": "对于每组数据，一行一个整数，表示答案对 $998244353$ 取模后的值。", "hint": "**【样例解释】**\n\n对于第一组数据，这里给出其中四个合法的度数序列：$\\{2,2,2,2\\},\\{1,2,2,3\\},\\{1,2,3,2\\},\\{2,1,3,2\\}$。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（8 points）：$n \\le 5$。\n- Subtask 2（10 points）：$n \\le 10 $。\n- Subtask 3（18 points）：$n \\le 35$。\n- Subtask 4（12 points）：$n \\le 90$。\n- Subtask 5（8 points）：$m = n - 1$。\n- Subtask 6（10 points）：$m = n$。\n- Subtask 7（16 points）：$m = n + 1$。\n- Subtask 8（18 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 10$，$0 \\le n \\le 2 \\times 10^3$，$0 \\le m \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P6018", "type": "P", "difficulty": 6, "samples": [["3 2\n1 2\n2 3\n1 1 4\n1 1\n3 2", "5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["树形数据结构", "2010", "O2优化", "字典树 Trie", "Ynoi"], "title": "[Ynoi2010] Fusion tree", "background": "题目背景和题意无关，可以跳过\n\n## 1.前言：\nFusion Tree，中文译作融合树，是一种亚log的数据结构，与1993年由Michael L.Fredman和Dan E.Willard提出。\n\n用途：$O( \\log n/ \\log w+ \\log w )$时间复杂度支持插入，删除，前驱，后继，min，max，以及用于整数排序。\n\n信息论断言对$n$个数的排序在最坏情况下需要$n\\log n$次比较，不过对这个界我们还需要一些研究。\n\n有人证明了任意unit cost RAM算法，其中只包含加法，减法，乘法，和0比较（但是不包含除法和位运算）最坏情况下需要$\\Omega(n\\log n)$的时间去对$n$个数排序。\n\n如果允许使用除法和位运算，他们有一个线性时间复杂度的算法，但是这个算法对unit cost滥用。\n\n这里我们规定我们使用的计算模型的字长是w，每个输入的数都是在$[0,2^w-1]$中的整数。\n\n## 2.一些记号：\n对于一个集合$S$和一个整数$x$，定义$rank(S,x)$为S集合中$\\le x$的元素个数。\n对于一些非负整数$a$，定义$bin(a_1,...,a_n)=2^{a_i}+...+2^{a_n}$。\n\n对于两个非负整数$a,b$，定义$msb(u,v)$为$u$和$v$最高的不相同的位。\n\n## 3.概述：\nFusion Tree大概可以看做是一棵特殊的B-Tree，特性：\n\n1. 叉数$B=O(w^{1/5})$\n\n2. 在一次搜索时，每个在搜索路径上的节点的正确的儿子可以被$O(1)$确定\n\n从这些特性我们可以看出Fusion Tree单次操作的时间复杂度是$O( \\log _w(n) + \\log w) = O( \\log n/\\log w +\\log  w)$的，比$O( \\log n )$低。\n\n但是由于其实现方式，Fusion Tree每次对内部节点的更新复杂度是$O( B^4 )$的。\n为了控制Fusion Tree均摊的更新复杂度，我们将这棵B-Tree的每对叶子节点之间的部分替换为一个大小大约为$O( B^4 )$的Weight Balanced Tree，只在WBT根节点发生变化的时候更新Fusion Tree的内部节点。\n\n具体来说，我们B-Tree维护的是一个排序后的数组的分块，其中每个块都由一棵平衡二叉搜索树维护，fusion tree上只维护一个值来表示块边界，用途是指引每次插入，删除，查询在哪个块中。\n\n可以发现这样我们把内部节点的变化次数除掉了一个$B^4$。\n\n## 4.压缩key的表示：\n\n如何$O(1)$确定搜索路径上的一个节点的正确的儿子：\n\n考虑一个B-Tree的节点，其上面包含了$k$个key，其中$B/2 \\le k \\le B$，记作$S={u_1,u_2,...u_k}$。\n\n然后我们定义出$B(S)$表示\"有区别的位的位置\"，用人话来说就是我们把这$k$个key的trie建出来，然后所有有超过$1$个儿子的节点的高度构成的集合\n（当然这里我们不用把trie建出来，只是这么解释比较直观，而且更能反映出其的一些性质）。\n\n再定义一个集合$K(S)$，为$S$只保留$B(S)$中那些位之后的值，记作$K(S)={u'_1,u'_2,...u'_k}$，发现这个压缩操作对于原集合是保序的。\n\n对于一个任意的$w-bit$的数$u$，我们记$u'(S)$表示$u$只保留$B(S)$中那些位，即把非$B(S)$中的位都置为$0$之后的值。\n\n下面引理表达了一个压缩key的重要性质：\n\n### 引理1：\n设$B(S)$排序后为$c_1<c_2<...<c_r$，定义边界$c_0=-1,c_{r+1}=b$。\n\n定义$u'_i$为$K(S)$中任意的一个压缩后的key。\n\n对于一个任意的$w-bit$的数$u$，满足$u \\neq u_i$，\n\n设$msb(u'(S),u'_i)=c_m$，即$u$和$u_i$在bit位置$c_{m+1},...,c_r$位置处相等，但是在$c_m$处不相等，如果$u'(S)=u'_i$，则我们记$m=0$。\n\n如果$u$和$u_i$不同的最高位$p$满足$p>c_m$，那么我们可以通过：\n\n1. 唯一的一个区间$[c_{j-1},c_j]$满足$p$属于这个区间\n\n2. $u$和$u_i$的大小关系\n\n来确定$rank(S,u)$的值。\n\n证明平凡，把trie画出来，显然可以画成一个平面图，然后可以发现这两个可以唯一地确定出一个平面区域，这个区域中的$S$集合元素个数就是$rank(S,u)$（感觉这种东西光写一堆自然语言也不能说明正确性，需要形式化证明一下？）。\n\n注意到这个引理虽然是对任意$u_i$成立的，但是要求$u$和$u_i$不相同的最高位不是$B(S)$中的一个点，可以发现这个$u_i$其实必须在$u$\"脱离\"这个trie的位置，也就是$p$的父亲子树中。\n\n引理$1$使得我们可以将$rank(S,u)$的计算规模降低到$rank(K(S),u'(S))$，通过计算$rank(K(S),u'(S))$，我们可以确定$u'(S)$在$K(S)$中的前驱后继$u'_j$和$u'_{j+1}$（这两个值不一定存在，但经过平凡的讨论就可以解决。\n\n如果$u_j \\le u \\le u_{j+1}$，那我们已经解决了这个问题\n否则我们令$i=j$或者$i=j+1$，计算出$msb(u_i,u)=p$，然后只要我们知道了包含$p$的区间$[c_j,c_{j+1}]$，我们就可以通过引理$1$来确定出$rank(S,u)$的值。\n\n这里如果我们$u_j \\le u \\le u_{j+1}$，那我们已经达成了目的，不用继续考虑了。\n\n否则如果不满足$u_j \\le u \\le u_{j+1}$，也就是说我们在这个sketch的过程中丢失了信息，即说明保留$K(S)$这些位的信息是不够的，那么$p$一定不在$K(S)$中，也就是说$i=j$和$i=j+1$中$p$较小的$i$满足$p>c_m$，故可以使用引理$1$。\n\n计算$K(S)$和$u'(S)$：\n我们发现没有平凡的方法可以将一个$w-bit$的数$u$在$O(1)$时间把$B(S)$那些位提取出来之后放到连续的一段中（可能可以通过硬件支持实现？），即使经过了一定预处理。\n\n其实我们不需要做到这个，可以用具有：\n\n1. 将需要提取出的位提取出，并放到（可以不连续）的更短的一段中\n\n2. 保序性\n\n的其他变化来实现我们需要的效果。\n\n我们可以通过一次恰当的乘法和一次与运算来实现这个：\n\n沿用引理$1$的定义，设我们需要从$u$中提取这些位，令$C=bin(c_1,...,c_r)$。\n\n假设我们已经算出了$C$，我们先通过令$v=u\\;\\mathrm{AND}\\;C$来将$u$中不需要的那些位置$0$。\n\n然后我们将$v$乘以一个量$M$，从而把$v$中我们需要的那些$bit$转化到一个狭窄的范围内，然后再通过一次$\\mathrm{AND}$来清除掉不需要的位置\n这里给出对一个量$M$的存在性证明和构造：\n\n记$M=bin(m_1,...,m_r)$，如果我们暂时忽略交叉和进位造成的影响，那么可以认为$v$乘$M$是把$c_1,...c_r$这些位置的位重新定位到了。\n\n$c_1+m_1,...,c_r+m_r$上。\n\n如果对任意$1 \\le i,j \\le r$，这$r^2$个$c_i+m_j$都是不同的，那么就不会发生交叉和进位了。\n\n我们现在的目标是构造一个整数集合${m_1,...,m_r}$，使得：\n\n1. $c_1+m_1<c_2+m_2<...<c_r+m_r$\n\n2. 对任意$1 \\le i,j \\le r$，$c_i+m_j$都是两两不同的。\n\n3. 变换后的区间$[c_1+m_1,c_r+m_r]$\"相对较小\"，这里的相对较小其实只要是$O( poly(r) )$的即可，因为这样我们可以通过调整树的叉数来满足后续的条件。\n\n### 引理2：\n\n给一个$r$个整数的序列，$c_1<...<c_r$，存在一个$r$个整数的序列，$m_1,...m_r$，满足：\n\n1. $c_1+m_1<c_2+m_2<...<c_r+m_r$\n\n2. 对任意$1 \\le i,j \\le r$，$c_i+m_j$都是两两不同的。\n\n3. $(c_r+m_r)-(c_1+m_1) \\le r^4$\n\n证明：\n\n先考虑证明存在整数序列$m'_1,...,m'_r$，使得对任意$i,j,a,b$，$m'_i+c_a$与$m'_j+c_b$在模$r^3$的意义下不同余。\n\n如果我们找到了这样的整数序列，那么所有$r^2$个$c_i+m'_j$都是两两不同的，并且由于这个是在模$r^3$意义下两两不同的，所以我们可以对第$i$个$c_i+m'_i$加上$(i-1)*r^3$，这样就可以保证对所有$i$满足$c_i+m'_i<c_{i+1}+m'_{i+1}$了。\n\n关于$m'_1,...,m'_r$的存在性：\n\n使用数学归纳法来证明，显然我们可以找到$m'_1$，这个平凡。\n\n假设结论对$t$成立，即我们已经找到了$m'_1,...,m'_t$，满足对任意$1 \\le i,j \\le t$，$a,b$,有$m'_i+c_a$与$m'_j+c_b$在模$r^3$的意义下不同余。\n可以观察到$m'_{t+1}+c_i \\equiv m'_s+c_j (\\mod r^3\\;)$，即$m'_{t+1} \\equiv m'_s+c_j-c_i (\\mod r^3\\;)$。\n\n\n我们可以令$m'_{t+1}$是$[0,r^3)$中最小的和所有$m'_s+c_j-c_i$不同余的数，这里$1 \\le s \\le t,1 \\le i,j \\le r$。\n\n由鸽巢原理，由于$t*r^2<r^3$，所以我们一定可以找到$m'_{t+1}$。\n\n故当$t+1 \\le s$时，结论对$t+1$成立\n由数学归纳法知结论对$s$成立，同时我们这里给出了一个暴力的$O( r^4 )$的构造算法（$r$轮，每轮最坏枚举$O( r^3 )$个位置）。\n\n## 5.融合：\n融合树的\"融合\"即指将每个节点上的key放到同一个$w-bit$的word上，通过对这个word进行运算来一起处理这些key。\n\n沿用之前$u_i$和$B(S)=\\{c_i\\}$的记号：\n\n我们这个B-Tree的每个节点存了$C=bin(c_1,...c_r)$和$M=bin(m_1,...,m_r)$这两个量，用于计算$u'(S)$，同时还存了$D=bin(c_1+m_1,...,c_r+m_r)$这个量，用于清空$u'(S)$的计算中不需要的位。\n\n同时还需要两个数组，存排序后的$u_i$和$u'_i$，和一个表$f[i][j][2]$表示引理$1$中，如果知道了$u_i$和$j$，还有$u$和$u_i$的大小关系，我们唯一确定的答案是多少。\n\n回顾之前的内容，当我们算出了$j=rank(K(S),u'(S))$后，如果$u$不在$[u_j,u_{j+1}]$的区间中，那么我们把$u'(S) \\;\\mathrm{XOR}\\; u'_j$和$u'(S) \\;\\mathrm{XOR}\\; u'_{j+1}$比较一下，较小的值所对应的$u'_h$，$h=j$或$j+1$，和$u$有更长的公共前缀，即$msb$更小。\n\n令$m=msb(u,u_h)$，然后我们需要知道$m$被哪个$B(S)$中的区间$[c_i,c_{i+1}]$包含，所以需要进行一次$i=rank(B(S),m)$的计算\n还需要进行一次$u$和$u_h$的比较，这个平凡，当这些都做完了，我们查一下表$f$即可得到$rank(S,u)$。\n\n可以发现fusion tree的每个内部节点需要存下$O( B^2 )$大小的表，内部节点个数是$O( n/B^4 )$个，所以是$O( n )$空间的。\n\n下面给出对\n\n1. $rank(K(S),u'(S))$\n\n2. $rank(B(S),m)$，其中$m$是在$[0,w]$中的整数\n\n3. 两个$w-bit$的整数$u,v$，$msb(u,v)$\n\n的计算方法：\n\n### $O(1)$计算$rank(K(S),u'(S))$：\n我们把每个$K(S)$中的元素前面补一个$1$，然后从小到大拼到一起来，这个拼起来的操作就是所谓的\"融合\"。\n\n由于我们$K(S)$中有$k$个元素，每个元素有$r^4$位，所以这里总共用了$k(r^4+1)$位，由于$B/2 \\le k \\le B$，所以我们总的位数是$O( B^5 )$的，由于$B=O( w^{1/5} )$，所以总的位数是$O( w )$的。\n\n所以我们拼起来的这个东西是$O( 1 )$个word的，这里将其定义为$A$。\n\n令$C=\\sum \\limits _{i = 0} ^ {B} 2^{(r^4+1)i}$\n通过$u'(S) \\times C$，可以将$u'(S)$前面补一个$0$之后复制$B$遍，然后拼到一起\n通过$A-u'(S) \\times C$，可以发现对每个$A$中补$1$的位置，其对应的那个$u_i(S)$如果$<u'(S)$，则这个$1$变成$0$，否则$1$不变\n所以我们通过$(A-u'(S) \\times C)\\&C$，然后对这个word数$1$的个数即可知道$rank(K(S),u'(S))$。\n\n由于这个word只在$2^{(r^4+1)i}$这样的位置有$1$，我们可以通过一次对$2^{r^4+1}-1$的取模来得到其中$1$的个数，虽然对常数取模可以用乘法和位运算$O(1)$实现，但我们这里可以给出一个更合适的构造。\n\n我们可以通过将其乘$C \\& (2^{(r^4+1)k}-1)$，这样相当于把其叠加了$k$次之后加起来，可以发现其中有一个长为$r^4+1$的段，这段的二进制表示的值等于这个word在$2^{(r^4+1)i}$这些位置的元素的和。\n\n通过位移和$\\mathrm{AND}$我们可以取出这个长$r^4+1$的段，于是就完成了。\n\n答案即$((((A-u'(S) \\times C) \\& C) \\times (C \\& (2^{(r^4+1)k}-1))) \\& C)>>((k(r^4+1)-1)$\n\n### $O(1)$计算$rank(B(S),m)$，$m$是在$[0,w]$中的整数：\n\n由于我们可以$O(1)$计算$rank(K(S),u'(S))$，所以把这个查出来然后判断那一个数的大小，并且进行一次查表即可。\n\n### $O(1)$计算$msb(u,v)$：\n等价于求$u \\;\\mathrm{XOR}\\; v$的最高位$1$的位置，设$A=u \\;\\mathrm{XOR}\\; v$。\n\n我们将$A$分为$r^c$大小的块，总共$r$块，这里$c$是一个常数,$c>1$\n令$C=(100...0100...0......)_2$，这里每两个$1$之间有$r-1$个$1$，$C$是一个常数。\n\n注意到：\n\n$((100...0)_2-0)\\&(1<<(r^c)-1)=(1<<(r^c)-1)$\n\n$((100...0)_2-y)\\&(1<<(r^c)-1)=0$，这里$y>0$\n\n先考虑对每个块去掉首位，块内是否有$1$。\n\n我们用$A\\& \\sim C$可以去掉每一块的首位。\n\n然后用$C-(A\\& \\sim C)$可以使得每一块中除首位外如果有$1$，则其在该块首位为$0$，否则为$1$。\n\n然后用$(C-(A\\& \\sim C))\\&C$去掉了$C-(A\\& \\sim C)$中每一块中除首位外的部分。\n\n然后用$(C-((C-(A\\& \\sim C))\\&C))$可以得到：如果一块中除首位外有$1$，则块首位为$1$，否则为$0$，且块首位外所有位置都是$0$的一个数\n再考虑对每个块只保留首位，块内是否有$1$。\n\n这个用$A\\&C$即可。\n\n最后$(A\\&C)|(C-((C-(A\\& \\sim C))\\&C))$可以得到：如果一块中有$1$，则块首位为$1$，否则为$0$，且块首位外所有位置都是$0$的一个数。\n\n令$D= \\sum \\limits _{k=0}^{r-1} 2^{k(r^c-1)}$，\n\n通过$(((A\\&C)|(C-((C-(A\\& \\sim C))\\&C))) \\times D)>>(w-r)$可以将每块首位的数字拼到一个长$r$的二进制数中。\n\n然后我们可以使用前面的$O(1)$计算$rank$的方法，令$B'(S)={2^i}$，$i$在$[0,r-1]$间，是整数。\n\n通过$rank(B'(S),(((A\\&C)|(C-((C-(A\\& \\sim C))\\&C))) \\times D)>>(w-r))$就可以得到这个长$r$的二进制数中第一个非0的首位的位置了。\n\n我们知道了第一个非$0$位在哪个块中，然后查这个块里面第一个非$0$位的位置就可以了。\n\n由于我们每个块是$r^c$的大小，所以对一个大小为$r^c$，包含了$2^i$的集合用一次rank即找到了块内第一个非$0$的首位位置。\n\n取$c=4,r=w^{1/5}$，$r^c=w^{4/5}$，我们便$O(1)$查询，$O(w^{4/5})$预处理时间复杂度解决了这个问题，由于预处理次数是$O( n/B^4 )$，所以这里也是线性的。\n\n综上所述，我们得到了一个单次操作复杂度$O( \\log n/\\log w + \\log w )$的数据结构，这里**据说**可以通过一些优化做到$O( \\log n/\\log w )$，但在这里由于我还没看所以暂时不做介绍。\n\n## 6.一些拓展\n如果我们允许下列中的一个：\n\n1. 放松线性空间的限制\n\n2. 保留线性空间的限制，但是使用随机化和整数除法\n\n那么我们可以得到一个$O( \\sqrt{ \\log n } )$的动态搜索的时间复杂度上界。\n\n当$n$超过$2^{(\\log w)^2/36}$时（这里$1/36$的常数是论文中给出的，由于我的部分细节和论文中不同，可能是不同的常数），\n\n对于1的case，可以通过使用vEB树来实现，对于2的case，可以通过使用Y-fast trie实现。\n\n对于这样的$n$，这两个数据结构可以在$O( \\log \\log U )=O( \\log w )=O( \\sqrt{\\log n} )$的时间完成一次搜索操作。\n\n当$n$小于这个数时，\n\n对于较小的$n$，我们使用fusion tree，通过调节$B=Θ(2^ {\\sqrt{\\log n}})$。\n\n在这个$B$下，我们的时间复杂度是$O( \\log n/\\log B + \\log B ) = O( \\sqrt{\\log n} )$。\n\n综上所述，如果引入随机化和整数除法，可以$O( n \\sqrt{\\log n} )$时间，线性空间整数排序。\n\n## 7.总结\n由信息论可以证明基于比较的排序下界是$\\Omega( n\\log n )$的，但整数排序其实是非常复杂的一个问题，还有待研究。", "description": "魔法森林里有一颗大树，下面经常有小孩召开法。\n\n大树可以看做一个有 $n$ 个节点，$n - 1$ 条边的无向连通图。大树的每个节点都有若干瓶矿泉水，初始第 $i$ 个节点有 $a_i$ 瓶矿泉水。\n\n麦杰斯住在大树顶端，有一天他想改造一下大树，方便他巨大多喝水之后可以垃圾分类矿泉水瓶。\n\n麦杰斯喜欢二进制运算，所以他会有以下三种操作：\n\n1. 将树上与一个节点 $x$ 距离为 $1$ 的节点上的矿泉水数量 $+1$。这里树上两点间的距离定义为从一点出发到另外一点的最短路径上边的条数。\n2. 在一个节点 $x$ 上喝掉 $v$ 瓶水。\n3. 询问树上与一个节点 $x$ 距离为 $1$ 的所有节点上的矿泉水数量的异或和。\n\n麦杰斯共有 $m$ 次操作，他希望你在每次 $3$ 操作后告诉他答案。", "inputFormat": "第一行两个正整数 $n,m$，分别表示树的节点个数和麦杰斯的询问个数。\n\n第二行到第 $n$ 行，每行两个整数表示有一条连接这两个节点的边。\n\n第 $n + 1$ 行 $n$ 个整数，第 $i$ 个整数表示初始第 $i$ 个节点上的矿泉水数量。\n\n第 $n + 2$ 行到第 $n + m + 1$ 行，每行先读入一个整数 $opt$ 表示操作类型。\n\n如果 $opt = 1$ 或 $3$ ，接下来读入一个整数 $x$ 表示麦杰斯操作的节点标号。\n\n否则接下来读入两个整数 $x, v$ 表示麦杰斯操作的节点标号和他喝的水的数量。", "outputFormat": "对于每一个 $3$ 操作，输出一行一个整数表示答案。", "hint": "Idea：dangxingyu，Solution：dangxingyu，Code：dangxingyu，Data：dangxingyu\n\n对于 $30\\%$ 的数据，满足 $n \\le 10^3$，$m\\le 10^3$。\n\n对于 $60\\%$ 的数据，满足 $n \\le 10^5$，$m \\le 10^5$。\n\n对于另外 $10\\%$ 的数据，存在一个点满足所有点到该节点的距离 $\\le 1$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n \\le 5\\times 10^5$，$1\\le m \\le 5\\times 10^5$，$0\\le a_i \\le 10^5$，$1 \\le x \\le n$，$opt\\in\\{1,2,3\\}$。\n\n保证任意时刻每个节点的矿泉水数非负。\n\n温馨提示：矿泉水瓶不是干垃圾也不是湿垃圾，而是可回收垃圾。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Ynoi2010] Fusion tree", "background": "", "description": "There is a big tree in a magic forest, and children often hold gatherings under it.\n\nThe tree can be seen as an undirected connected graph with $n$ nodes and $n - 1$ edges. Each node of the tree has some bottles of mineral water. Initially, node $i$ has $a_i$ bottles.\n\nMajies lives at the top of the tree. One day, he wants to remodel the tree so that it will be convenient for him to sort the empty mineral water bottles for recycling after he drinks a lot of water.\n\nMajies likes binary operations, so he will perform the following three types of operations:\n\n1. Add $1$ to the number of mineral water bottles on every node whose distance to a node $x$ is $1$. The distance between two nodes on the tree is defined as the number of edges on the shortest path between them.\n2. Drink $v$ bottles of water at node $x$.\n3. Query the xor sum of the numbers of mineral water bottles on all nodes whose distance to a node $x$ is $1$.\n\nMajies has $m$ operations in total. You need to output the answer after each operation of type $3$.", "inputFormat": "The first line contains two positive integers $n, m$, which represent the number of nodes in the tree and the number of queries.\n\nLines $2$ to $n$ each contain two integers, indicating an edge connecting these two nodes.\n\nLine $n + 1$ contains $n$ integers. The $i$-th integer indicates the initial number of mineral water bottles at node $i$.\n\nLines $n + 2$ to $n + m + 1$ each start with an integer $opt$ representing the operation type.\n\nIf $opt = 1$ or $opt = 3$, then an integer $x$ follows, indicating the node that Majies operates on.\n\nOtherwise, two integers $x, v$ follow, indicating the node that Majies operates on and the number of bottles he drinks.", "outputFormat": "For each operation of type $3$, output one line containing one integer, which is the answer.", "hint": "Idea: dangxingyu, Solution: dangxingyu, Code: dangxingyu, Data: dangxingyu.\n\nFor $30\\%$ of the testdata, $n \\le 10^3$, $m \\le 10^3$.\n\nFor $60\\%$ of the testdata, $n \\le 10^5$, $m \\le 10^5$.\n\nFor another $10\\%$ of the testdata, there exists a node such that the distance from every node to this node is $\\le 1$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 5\\times 10^5$, $1 \\le m \\le 5\\times 10^5$, $0 \\le a_i \\le 10^5$, $1 \\le x \\le n$, $opt\\in\\{1,2,3\\}$.\n\nIt is guaranteed that the number of mineral water bottles at each node is non-negative at any time.\n\nFriendly reminder: mineral water bottles are neither dry waste nor wet waste; they are recyclable waste.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Ynoi2010] Fusion tree", "background": "题目背景和题意无关，可以跳过\n\n## 1.前言：\nFusion Tree，中文译作融合树，是一种亚log的数据结构，与1993年由Michael L.Fredman和Dan E.Willard提出。\n\n用途：$O( \\log n/ \\log w+ \\log w )$时间复杂度支持插入，删除，前驱，后继，min，max，以及用于整数排序。\n\n信息论断言对$n$个数的排序在最坏情况下需要$n\\log n$次比较，不过对这个界我们还需要一些研究。\n\n有人证明了任意unit cost RAM算法，其中只包含加法，减法，乘法，和0比较（但是不包含除法和位运算）最坏情况下需要$\\Omega(n\\log n)$的时间去对$n$个数排序。\n\n如果允许使用除法和位运算，他们有一个线性时间复杂度的算法，但是这个算法对unit cost滥用。\n\n这里我们规定我们使用的计算模型的字长是w，每个输入的数都是在$[0,2^w-1]$中的整数。\n\n## 2.一些记号：\n对于一个集合$S$和一个整数$x$，定义$rank(S,x)$为S集合中$\\le x$的元素个数。\n对于一些非负整数$a$，定义$bin(a_1,...,a_n)=2^{a_i}+...+2^{a_n}$。\n\n对于两个非负整数$a,b$，定义$msb(u,v)$为$u$和$v$最高的不相同的位。\n\n## 3.概述：\nFusion Tree大概可以看做是一棵特殊的B-Tree，特性：\n\n1. 叉数$B=O(w^{1/5})$\n\n2. 在一次搜索时，每个在搜索路径上的节点的正确的儿子可以被$O(1)$确定\n\n从这些特性我们可以看出Fusion Tree单次操作的时间复杂度是$O( \\log _w(n) + \\log w) = O( \\log n/\\log w +\\log  w)$的，比$O( \\log n )$低。\n\n但是由于其实现方式，Fusion Tree每次对内部节点的更新复杂度是$O( B^4 )$的。\n为了控制Fusion Tree均摊的更新复杂度，我们将这棵B-Tree的每对叶子节点之间的部分替换为一个大小大约为$O( B^4 )$的Weight Balanced Tree，只在WBT根节点发生变化的时候更新Fusion Tree的内部节点。\n\n具体来说，我们B-Tree维护的是一个排序后的数组的分块，其中每个块都由一棵平衡二叉搜索树维护，fusion tree上只维护一个值来表示块边界，用途是指引每次插入，删除，查询在哪个块中。\n\n可以发现这样我们把内部节点的变化次数除掉了一个$B^4$。\n\n## 4.压缩key的表示：\n\n如何$O(1)$确定搜索路径上的一个节点的正确的儿子：\n\n考虑一个B-Tree的节点，其上面包含了$k$个key，其中$B/2 \\le k \\le B$，记作$S={u_1,u_2,...u_k}$。\n\n然后我们定义出$B(S)$表示\"有区别的位的位置\"，用人话来说就是我们把这$k$个key的trie建出来，然后所有有超过$1$个儿子的节点的高度构成的集合\n（当然这里我们不用把trie建出来，只是这么解释比较直观，而且更能反映出其的一些性质）。\n\n再定义一个集合$K(S)$，为$S$只保留$B(S)$中那些位之后的值，记作$K(S)={u'_1,u'_2,...u'_k}$，发现这个压缩操作对于原集合是保序的。\n\n对于一个任意的$w-bit$的数$u$，我们记$u'(S)$表示$u$只保留$B(S)$中那些位，即把非$B(S)$中的位都置为$0$之后的值。\n\n下面引理表达了一个压缩key的重要性质：\n\n### 引理1：\n设$B(S)$排序后为$c_1<c_2<...<c_r$，定义边界$c_0=-1,c_{r+1}=b$。\n\n定义$u'_i$为$K(S)$中任意的一个压缩后的key。\n\n对于一个任意的$w-bit$的数$u$，满足$u \\neq u_i$，\n\n设$msb(u'(S),u'_i)=c_m$，即$u$和$u_i$在bit位置$c_{m+1},...,c_r$位置处相等，但是在$c_m$处不相等，如果$u'(S)=u'_i$，则我们记$m=0$。\n\n如果$u$和$u_i$不同的最高位$p$满足$p>c_m$，那么我们可以通过：\n\n1. 唯一的一个区间$[c_{j-1},c_j]$满足$p$属于这个区间\n\n2. $u$和$u_i$的大小关系\n\n来确定$rank(S,u)$的值。\n\n证明平凡，把trie画出来，显然可以画成一个平面图，然后可以发现这两个可以唯一地确定出一个平面区域，这个区域中的$S$集合元素个数就是$rank(S,u)$（感觉这种东西光写一堆自然语言也不能说明正确性，需要形式化证明一下？）。\n\n注意到这个引理虽然是对任意$u_i$成立的，但是要求$u$和$u_i$不相同的最高位不是$B(S)$中的一个点，可以发现这个$u_i$其实必须在$u$\"脱离\"这个trie的位置，也就是$p$的父亲子树中。\n\n引理$1$使得我们可以将$rank(S,u)$的计算规模降低到$rank(K(S),u'(S))$，通过计算$rank(K(S),u'(S))$，我们可以确定$u'(S)$在$K(S)$中的前驱后继$u'_j$和$u'_{j+1}$（这两个值不一定存在，但经过平凡的讨论就可以解决。\n\n如果$u_j \\le u \\le u_{j+1}$，那我们已经解决了这个问题\n否则我们令$i=j$或者$i=j+1$，计算出$msb(u_i,u)=p$，然后只要我们知道了包含$p$的区间$[c_j,c_{j+1}]$，我们就可以通过引理$1$来确定出$rank(S,u)$的值。\n\n这里如果我们$u_j \\le u \\le u_{j+1}$，那我们已经达成了目的，不用继续考虑了。\n\n否则如果不满足$u_j \\le u \\le u_{j+1}$，也就是说我们在这个sketch的过程中丢失了信息，即说明保留$K(S)$这些位的信息是不够的，那么$p$一定不在$K(S)$中，也就是说$i=j$和$i=j+1$中$p$较小的$i$满足$p>c_m$，故可以使用引理$1$。\n\n计算$K(S)$和$u'(S)$：\n我们发现没有平凡的方法可以将一个$w-bit$的数$u$在$O(1)$时间把$B(S)$那些位提取出来之后放到连续的一段中（可能可以通过硬件支持实现？），即使经过了一定预处理。\n\n其实我们不需要做到这个，可以用具有：\n\n1. 将需要提取出的位提取出，并放到（可以不连续）的更短的一段中\n\n2. 保序性\n\n的其他变化来实现我们需要的效果。\n\n我们可以通过一次恰当的乘法和一次与运算来实现这个：\n\n沿用引理$1$的定义，设我们需要从$u$中提取这些位，令$C=bin(c_1,...,c_r)$。\n\n假设我们已经算出了$C$，我们先通过令$v=u\\;\\mathrm{AND}\\;C$来将$u$中不需要的那些位置$0$。\n\n然后我们将$v$乘以一个量$M$，从而把$v$中我们需要的那些$bit$转化到一个狭窄的范围内，然后再通过一次$\\mathrm{AND}$来清除掉不需要的位置\n这里给出对一个量$M$的存在性证明和构造：\n\n记$M=bin(m_1,...,m_r)$，如果我们暂时忽略交叉和进位造成的影响，那么可以认为$v$乘$M$是把$c_1,...c_r$这些位置的位重新定位到了。\n\n$c_1+m_1,...,c_r+m_r$上。\n\n如果对任意$1 \\le i,j \\le r$，这$r^2$个$c_i+m_j$都是不同的，那么就不会发生交叉和进位了。\n\n我们现在的目标是构造一个整数集合${m_1,...,m_r}$，使得：\n\n1. $c_1+m_1<c_2+m_2<...<c_r+m_r$\n\n2. 对任意$1 \\le i,j \\le r$，$c_i+m_j$都是两两不同的。\n\n3. 变换后的区间$[c_1+m_1,c_r+m_r]$\"相对较小\"，这里的相对较小其实只要是$O( poly(r) )$的即可，因为这样我们可以通过调整树的叉数来满足后续的条件。\n\n### 引理2：\n\n给一个$r$个整数的序列，$c_1<...<c_r$，存在一个$r$个整数的序列，$m_1,...m_r$，满足：\n\n1. $c_1+m_1<c_2+m_2<...<c_r+m_r$\n\n2. 对任意$1 \\le i,j \\le r$，$c_i+m_j$都是两两不同的。\n\n3. $(c_r+m_r)-(c_1+m_1) \\le r^4$\n\n证明：\n\n先考虑证明存在整数序列$m'_1,...,m'_r$，使得对任意$i,j,a,b$，$m'_i+c_a$与$m'_j+c_b$在模$r^3$的意义下不同余。\n\n如果我们找到了这样的整数序列，那么所有$r^2$个$c_i+m'_j$都是两两不同的，并且由于这个是在模$r^3$意义下两两不同的，所以我们可以对第$i$个$c_i+m'_i$加上$(i-1)*r^3$，这样就可以保证对所有$i$满足$c_i+m'_i<c_{i+1}+m'_{i+1}$了。\n\n关于$m'_1,...,m'_r$的存在性：\n\n使用数学归纳法来证明，显然我们可以找到$m'_1$，这个平凡。\n\n假设结论对$t$成立，即我们已经找到了$m'_1,...,m'_t$，满足对任意$1 \\le i,j \\le t$，$a,b$,有$m'_i+c_a$与$m'_j+c_b$在模$r^3$的意义下不同余。\n可以观察到$m'_{t+1}+c_i \\equiv m'_s+c_j (\\mod r^3\\;)$，即$m'_{t+1} \\equiv m'_s+c_j-c_i (\\mod r^3\\;)$。\n\n\n我们可以令$m'_{t+1}$是$[0,r^3)$中最小的和所有$m'_s+c_j-c_i$不同余的数，这里$1 \\le s \\le t,1 \\le i,j \\le r$。\n\n由鸽巢原理，由于$t*r^2<r^3$，所以我们一定可以找到$m'_{t+1}$。\n\n故当$t+1 \\le s$时，结论对$t+1$成立\n由数学归纳法知结论对$s$成立，同时我们这里给出了一个暴力的$O( r^4 )$的构造算法（$r$轮，每轮最坏枚举$O( r^3 )$个位置）。\n\n## 5.融合：\n融合树的\"融合\"即指将每个节点上的key放到同一个$w-bit$的word上，通过对这个word进行运算来一起处理这些key。\n\n沿用之前$u_i$和$B(S)=\\{c_i\\}$的记号：\n\n我们这个B-Tree的每个节点存了$C=bin(c_1,...c_r)$和$M=bin(m_1,...,m_r)$这两个量，用于计算$u'(S)$，同时还存了$D=bin(c_1+m_1,...,c_r+m_r)$这个量，用于清空$u'(S)$的计算中不需要的位。\n\n同时还需要两个数组，存排序后的$u_i$和$u'_i$，和一个表$f[i][j][2]$表示引理$1$中，如果知道了$u_i$和$j$，还有$u$和$u_i$的大小关系，我们唯一确定的答案是多少。\n\n回顾之前的内容，当我们算出了$j=rank(K(S),u'(S))$后，如果$u$不在$[u_j,u_{j+1}]$的区间中，那么我们把$u'(S) \\;\\mathrm{XOR}\\; u'_j$和$u'(S) \\;\\mathrm{XOR}\\; u'_{j+1}$比较一下，较小的值所对应的$u'_h$，$h=j$或$j+1$，和$u$有更长的公共前缀，即$msb$更小。\n\n令$m=msb(u,u_h)$，然后我们需要知道$m$被哪个$B(S)$中的区间$[c_i,c_{i+1}]$包含，所以需要进行一次$i=rank(B(S),m)$的计算\n还需要进行一次$u$和$u_h$的比较，这个平凡，当这些都做完了，我们查一下表$f$即可得到$rank(S,u)$。\n\n可以发现fusion tree的每个内部节点需要存下$O( B^2 )$大小的表，内部节点个数是$O( n/B^4 )$个，所以是$O( n )$空间的。\n\n下面给出对\n\n1. $rank(K(S),u'(S))$\n\n2. $rank(B(S),m)$，其中$m$是在$[0,w]$中的整数\n\n3. 两个$w-bit$的整数$u,v$，$msb(u,v)$\n\n的计算方法：\n\n### $O(1)$计算$rank(K(S),u'(S))$：\n我们把每个$K(S)$中的元素前面补一个$1$，然后从小到大拼到一起来，这个拼起来的操作就是所谓的\"融合\"。\n\n由于我们$K(S)$中有$k$个元素，每个元素有$r^4$位，所以这里总共用了$k(r^4+1)$位，由于$B/2 \\le k \\le B$，所以我们总的位数是$O( B^5 )$的，由于$B=O( w^{1/5} )$，所以总的位数是$O( w )$的。\n\n所以我们拼起来的这个东西是$O( 1 )$个word的，这里将其定义为$A$。\n\n令$C=\\sum \\limits _{i = 0} ^ {B} 2^{(r^4+1)i}$\n通过$u'(S) \\times C$，可以将$u'(S)$前面补一个$0$之后复制$B$遍，然后拼到一起\n通过$A-u'(S) \\times C$，可以发现对每个$A$中补$1$的位置，其对应的那个$u_i(S)$如果$<u'(S)$，则这个$1$变成$0$，否则$1$不变\n所以我们通过$(A-u'(S) \\times C)\\&C$，然后对这个word数$1$的个数即可知道$rank(K(S),u'(S))$。\n\n由于这个word只在$2^{(r^4+1)i}$这样的位置有$1$，我们可以通过一次对$2^{r^4+1}-1$的取模来得到其中$1$的个数，虽然对常数取模可以用乘法和位运算$O(1)$实现，但我们这里可以给出一个更合适的构造。\n\n我们可以通过将其乘$C \\& (2^{(r^4+1)k}-1)$，这样相当于把其叠加了$k$次之后加起来，可以发现其中有一个长为$r^4+1$的段，这段的二进制表示的值等于这个word在$2^{(r^4+1)i}$这些位置的元素的和。\n\n通过位移和$\\mathrm{AND}$我们可以取出这个长$r^4+1$的段，于是就完成了。\n\n答案即$((((A-u'(S) \\times C) \\& C) \\times (C \\& (2^{(r^4+1)k}-1))) \\& C)>>((k(r^4+1)-1)$\n\n### $O(1)$计算$rank(B(S),m)$，$m$是在$[0,w]$中的整数：\n\n由于我们可以$O(1)$计算$rank(K(S),u'(S))$，所以把这个查出来然后判断那一个数的大小，并且进行一次查表即可。\n\n### $O(1)$计算$msb(u,v)$：\n等价于求$u \\;\\mathrm{XOR}\\; v$的最高位$1$的位置，设$A=u \\;\\mathrm{XOR}\\; v$。\n\n我们将$A$分为$r^c$大小的块，总共$r$块，这里$c$是一个常数,$c>1$\n令$C=(100...0100...0......)_2$，这里每两个$1$之间有$r-1$个$1$，$C$是一个常数。\n\n注意到：\n\n$((100...0)_2-0)\\&(1<<(r^c)-1)=(1<<(r^c)-1)$\n\n$((100...0)_2-y)\\&(1<<(r^c)-1)=0$，这里$y>0$\n\n先考虑对每个块去掉首位，块内是否有$1$。\n\n我们用$A\\& \\sim C$可以去掉每一块的首位。\n\n然后用$C-(A\\& \\sim C)$可以使得每一块中除首位外如果有$1$，则其在该块首位为$0$，否则为$1$。\n\n然后用$(C-(A\\& \\sim C))\\&C$去掉了$C-(A\\& \\sim C)$中每一块中除首位外的部分。\n\n然后用$(C-((C-(A\\& \\sim C))\\&C))$可以得到：如果一块中除首位外有$1$，则块首位为$1$，否则为$0$，且块首位外所有位置都是$0$的一个数\n再考虑对每个块只保留首位，块内是否有$1$。\n\n这个用$A\\&C$即可。\n\n最后$(A\\&C)|(C-((C-(A\\& \\sim C))\\&C))$可以得到：如果一块中有$1$，则块首位为$1$，否则为$0$，且块首位外所有位置都是$0$的一个数。\n\n令$D= \\sum \\limits _{k=0}^{r-1} 2^{k(r^c-1)}$，\n\n通过$(((A\\&C)|(C-((C-(A\\& \\sim C))\\&C))) \\times D)>>(w-r)$可以将每块首位的数字拼到一个长$r$的二进制数中。\n\n然后我们可以使用前面的$O(1)$计算$rank$的方法，令$B'(S)={2^i}$，$i$在$[0,r-1]$间，是整数。\n\n通过$rank(B'(S),(((A\\&C)|(C-((C-(A\\& \\sim C))\\&C))) \\times D)>>(w-r))$就可以得到这个长$r$的二进制数中第一个非0的首位的位置了。\n\n我们知道了第一个非$0$位在哪个块中，然后查这个块里面第一个非$0$位的位置就可以了。\n\n由于我们每个块是$r^c$的大小，所以对一个大小为$r^c$，包含了$2^i$的集合用一次rank即找到了块内第一个非$0$的首位位置。\n\n取$c=4,r=w^{1/5}$，$r^c=w^{4/5}$，我们便$O(1)$查询，$O(w^{4/5})$预处理时间复杂度解决了这个问题，由于预处理次数是$O( n/B^4 )$，所以这里也是线性的。\n\n综上所述，我们得到了一个单次操作复杂度$O( \\log n/\\log w + \\log w )$的数据结构，这里**据说**可以通过一些优化做到$O( \\log n/\\log w )$，但在这里由于我还没看所以暂时不做介绍。\n\n## 6.一些拓展\n如果我们允许下列中的一个：\n\n1. 放松线性空间的限制\n\n2. 保留线性空间的限制，但是使用随机化和整数除法\n\n那么我们可以得到一个$O( \\sqrt{ \\log n } )$的动态搜索的时间复杂度上界。\n\n当$n$超过$2^{(\\log w)^2/36}$时（这里$1/36$的常数是论文中给出的，由于我的部分细节和论文中不同，可能是不同的常数），\n\n对于1的case，可以通过使用vEB树来实现，对于2的case，可以通过使用Y-fast trie实现。\n\n对于这样的$n$，这两个数据结构可以在$O( \\log \\log U )=O( \\log w )=O( \\sqrt{\\log n} )$的时间完成一次搜索操作。\n\n当$n$小于这个数时，\n\n对于较小的$n$，我们使用fusion tree，通过调节$B=Θ(2^ {\\sqrt{\\log n}})$。\n\n在这个$B$下，我们的时间复杂度是$O( \\log n/\\log B + \\log B ) = O( \\sqrt{\\log n} )$。\n\n综上所述，如果引入随机化和整数除法，可以$O( n \\sqrt{\\log n} )$时间，线性空间整数排序。\n\n## 7.总结\n由信息论可以证明基于比较的排序下界是$\\Omega( n\\log n )$的，但整数排序其实是非常复杂的一个问题，还有待研究。", "description": "魔法森林里有一颗大树，下面经常有小孩召开法。\n\n大树可以看做一个有 $n$ 个节点，$n - 1$ 条边的无向连通图。大树的每个节点都有若干瓶矿泉水，初始第 $i$ 个节点有 $a_i$ 瓶矿泉水。\n\n麦杰斯住在大树顶端，有一天他想改造一下大树，方便他巨大多喝水之后可以垃圾分类矿泉水瓶。\n\n麦杰斯喜欢二进制运算，所以他会有以下三种操作：\n\n1. 将树上与一个节点 $x$ 距离为 $1$ 的节点上的矿泉水数量 $+1$。这里树上两点间的距离定义为从一点出发到另外一点的最短路径上边的条数。\n2. 在一个节点 $x$ 上喝掉 $v$ 瓶水。\n3. 询问树上与一个节点 $x$ 距离为 $1$ 的所有节点上的矿泉水数量的异或和。\n\n麦杰斯共有 $m$ 次操作，他希望你在每次 $3$ 操作后告诉他答案。", "inputFormat": "第一行两个正整数 $n,m$，分别表示树的节点个数和麦杰斯的询问个数。\n\n第二行到第 $n$ 行，每行两个整数表示有一条连接这两个节点的边。\n\n第 $n + 1$ 行 $n$ 个整数，第 $i$ 个整数表示初始第 $i$ 个节点上的矿泉水数量。\n\n第 $n + 2$ 行到第 $n + m + 1$ 行，每行先读入一个整数 $opt$ 表示操作类型。\n\n如果 $opt = 1$ 或 $3$ ，接下来读入一个整数 $x$ 表示麦杰斯操作的节点标号。\n\n否则接下来读入两个整数 $x, v$ 表示麦杰斯操作的节点标号和他喝的水的数量。", "outputFormat": "对于每一个 $3$ 操作，输出一行一个整数表示答案。", "hint": "Idea：dangxingyu，Solution：dangxingyu，Code：dangxingyu，Data：dangxingyu\n\n对于 $30\\%$ 的数据，满足 $n \\le 10^3$，$m\\le 10^3$。\n\n对于 $60\\%$ 的数据，满足 $n \\le 10^5$，$m \\le 10^5$。\n\n对于另外 $10\\%$ 的数据，存在一个点满足所有点到该节点的距离 $\\le 1$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n \\le 5\\times 10^5$，$1\\le m \\le 5\\times 10^5$，$0\\le a_i \\le 10^5$，$1 \\le x \\le n$，$opt\\in\\{1,2,3\\}$。\n\n保证任意时刻每个节点的矿泉水数非负。\n\n温馨提示：矿泉水瓶不是干垃圾也不是湿垃圾，而是可回收垃圾。\n", "locale": "zh-CN"}}}
{"pid": "P6019", "type": "P", "difficulty": 7, "samples": [["10 12\n6 9 9 4 7 8 10 4 9 2\n2 1 4\n1 0 5 0\n2 3 6\n2 10 9\n1 7 9 2\n2 7 9\n1 2 7 1\n1 2 11 4\n2 6 10\n1 3 12 0\n1 14 14 15\n2 7 12\n", "1\n3\n0\n3\n6\n16"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2010", "O2优化", "洛谷月赛", "Ynoi"], "title": "[Ynoi2010] Brodal queue", "background": "题目背景和题意无关，可以跳过\n\n## 1.前言：\nBrodal queue 在 1996 年由 Brodal 提出，是第一个满足每个操作都 worst case 而且达到了基于比较的堆的下界的数据结构\n\n这里给出的 Brodal queue 是一个小根堆\n\n该数据结构的一些特性：\n\n1. 维护了两棵树。\n\n2. Brodal queue 是一种 violation heap，即允许存在一些节点不满足堆性质。\n\n3. 实现真的很复杂，常数真的很大。\n\n## 2.一些记号：\nBrodal queue 维护了两棵树 $T1$ , $T2$，他们的根是 $t1$ 和 $t2$。\n\n定义：\n\n$p(x)$：$x$ 的父亲节点，默认 $x \\neq t1$ 且 $x \\neq t2$。\n\n$rank(x)$：和 $log( subtree\\;size )$ 相关的一个权值。\n\n$n(x,i)$：$x$ 的孩子中满足其 $rank$ 为 $i$ 的个数。\n\n$w(x,i)$：$W(x)$ 中 $rank$ 为 $i$ 的元素个数。\n\n$V$ 和 $W$ 列表：维护所有违反堆性质的节点。\n\n## 3.概述：\n每个曾经作为 $T1$ 的根的点都维护 $V$ 和 $W$，我们用 $V(x)$ 表示 $x$ 节点的 $V$ 集合，$W(x)$ 表示 $x$ 节点的 $W$ 集合。\n\n$V$ 维护的是 $rank \\ge rank(t1)$ 的节点，$W$ 维护的是 $rank<rank(t1)$ 的节点，这个是对插入当时的情况成立的，也就是说在经过结构修改操作之后不一定还满足这个性质。\n\n$V$ 是只加不删的， $W$ 是需要维护平衡的，所以只需要保证 $t1$ 的 $W$ 中的点的 $rank<rank(t1)$。\n\n有以下的一些性质：\n\n$rank$ 的性质：\n\nS1. 叶子节点的 $rank$ 为 $0$。\n\nS2. $rank(x) < rank( p(x) )$。\n\nS3. 如果 $rank(x) > 0$，则 $n(x,rank(x)-1) \\ge 2$。\n\nS4. $n(x,i)$ 只可能为 ${0,2,3,4,5,6,7}$ 中的元素。\n\nS5. 当 $T2 \\neq null$ 时 $rank(t1) \\leq rank(t2)$。\n\n解释：\n\nS1. 边界定义。\n\nS2. $rank$ 构成大根堆。\n\nS3. 一个点有至少两个孩子的 $rank$ 是其 $rank-1$，所以 $x$ 的子树大小关于 $x$ 的 $rank$ 至少是指数级的，所以 $rank$ 最多是 $O( \\log n )$ 的。\n\nS4. $n(x,i)$ 有 $O(1)$ 上界，非 $1$ ，而总共有 $O( \\log n )$ 种 $rank$，所以每个节点的度数都是 $O(\\log n )$ 的。\n\nS5. 要么 $T1$ 比 $T2$ 小，要么 $T2$ 为空。\n\n$V$ 和 $W$ 列表的性质：\n\nO1. $t1$ 是所有元素中的最小元。\n\nO2. 如果 $y$ 在 $V(x)$ 或者 $W(x)$ 中，则 $x \\leq y$，即这个元素在被插入列表时是违背了堆性质的。\n\nO3. 如果 $y<p(y)$ ，那么存在一个 $x$ 使得 $x \\neq y$，$y$ 属于 $V(x)$ 或 $W(x)$，即所有违背堆性质的节点都在某个节点的 $V$ 或 $W$ 列表中。\n\nO4. 对于所有 $x$，有 $w(x,i) \\leq 6$。\n\nO5. 记 $V(x) = (y_|V(x)|,...,y_2,y_1)$ , 则 $rank(y_i) \\ge floor((i-1)/α)$，$α$ 是一个常数。\n\n解释：\n\nO1. 我们要 $O(1)$ 求出最小值，所以规定了最小元是 $t1$。\n\nO2. $x$ 被插入的时候是被插到 $V(t1)$ 或者 $W(t1)$ 中。\n\nO3. 违反堆性质的点一定在另一个点的 $V$ 或者 $W$ 集合中。\n\nO4. $w(x,i)$ 有常数上界，所以 $V$ 和 $W$ 列表的大小是 $O( \\log n )$ 的。\n\nO5. $V$ 列表中的 $rank$ 有一个阶梯的下界。\n\n对于 $t1$，$t2$ 的额外性质：\n\nR1. 对 $i = 0 \\sim rank(tj) - 1$，有 $n(tj,i) \\ne 0$。\n\nR2. $|V(t1)| \\leq α \\times rank(t1)$ ，和前面提到的是同一个 $α$。\n\nR3. 如果 $y$ 属于 $W(t1)$ 则 $rank(y)<rank(t1)$。\n\n解释：\n\nR1. 对于 $t1$，$t2$，每个 $rank$ 的孩子至少有 $2$ 个。\n\nR2. $V(t1)$ 的大小 $|V(t1)|$ 有 $α \\times rank(t1)$ 的上界。\n\nR3. 属于 $W(t1)$ 的点比 $t1$ 小。\n\nR2+O5可以推出如果 $t1$ 的 $rank$ 增大 $1$ ，我们就可以增加 $α$ 个大的违反堆性质的节点，把他们加入 $V(t1)$，并且不违反 $O5$。\n\n每次 DECREASEKEY 时 ，我们直接加一个新的违反堆性质的点到 $V(t1)$ 或者$W(t1)$。\n\n为了避免有太多的违反堆性质的节点，我们递增地做两种不同的变换，主要为了维护 R2 和 O4 性质。\n\n第一种：把 $t2$ 的儿子移动进入 $T1$ ，变成 $t1$ 的孩子，使得 $rank(t1)$ 变大。\n\n第二种：通过把 $2$ 个 $rank$ 为 $k$ 的违反堆性质的节点换成了 $\\leq 1$个$rank$ 为 $k+1$ 的违反堆性质的节点，从而减少 $W(t1)$ 的大小。\n\nNote：我们这里用到了很多可变长数组，默认可变长数组是严格 $O(1)$ 的，这个是平凡的所以不详细讲怎么实现了。\n\n这里给出了一个作者称为 guide 的数据结构的实现。\n\n## 4.Guide Data Structure：\n\n用途：维护 $R1$，$O4$ 性质，即对 $n(t1,i),n(t2,i),w(t1,i)$ 的上界进行维护，大概是一个维护 $O(1)$ 进位的东西。\n\n抽象出这部分要维护的东西，也就是我们这里讲的 guide 数据结构是要维护什么：\n\n维护：一个长为 $k$ 的 int 数组，$x_k,x_{k-1},...x_1$ （这里我们从右往左写序列）。\n\n需要满足：$max(x_i) \\leq T$ , $T$ 是预设的一个阈值常数。\n\n我们只能在这个数组上实现 REDUCE(i) 的操作，即 $x_i$ 至少减少 $2$，$x_{i+1}$ 至多增加 $1$（实际上这里我们 $x_i$ 只能减少 $2$ 或者 $3$，$x_{i+1}$ 只能增加 $0$ 或者 $1$）。\n\n每次可能发生对一个任意位置 $i$ 的 $x_i$ 的 $+1$ 或者 $-1$ 操作，每次操作之后我们被允许通过 $O(1)$ 次 REDUCE 操作，使得我们需要维护的数组仍旧满足性质。\n\nguide 干的事情就是 guide（向导） ，也就是说告诉我们要做什么样的 REDUCE 操作使得这个数组仍旧满足性质。\n\n定义 $x'$ 是 $[T-2,T]$ ，当 $x_i$ 碰到进入 $x'$ 的范围之前我们不考虑对其进行调整。\n\n不妨设 $T=2$，我们对 $T=2$ 维护这个 guide 即可。\n\n把原序列分成一些块，考虑形如 $2$ $1*$ $0$ 这样的连续段，不在段内的元素只可能是单独的 $0$ 或 $1$。\n\n对每个块我们新建一个节点，然后段内的每个元素都指向这个节点。\n\n每个节点上记录块的开头位置。\n\n不在块内的节点直接指向一个 null。\n\n这里我们多个点共用一个 null ，存在多个 null。\n\n有两个重要的性质：\n\n1. 给一个位置 $x$ ，我们可以最坏复杂度 $O(1)$ 找到 $x$ 所属于的块内最左边的元素，\n并且——\n\n2. 我们可以最坏复杂度 $O(1)$ 销毁掉一个给定的块，直接把那个存有值的点改成 null 即可。\n\n这里写一下变换是如何实现的，由于是按照自己的理解写的，所以可能和原论文\n有出入。\n\n注意到我们可以 $O(1)$ 拆掉一个块。\n\n前驱不在块内：\n\n```\ncase1：\n\n0 0\n\n0 1\n\ntrivial\n```\n```\ncase2：\n\n0 1\n\n0 2\n\n1 1\n\ntrivial\n\n```\n```\ncase3:\n\n0 [2 1* 0]\n\n0 [3 1* 0]\n\n1 [1 1* 0]\n\n拆掉这个块\n\n1 1 1* 0\n```\n```\ncase4:\n\n1 0\n\n1 1\n\ntrivial\n```\n```\ncase5:\n\n1 1\n\n1 2\n\n[2 0]\n\ntrivial\n```\n```\ncase6:\n\n1 [2 1* 0]\n\n1 [3 1* 0]\n\n2 [1 1* 0]\n\n[2 1 1* 0]\n```\n前驱是块尾：\n```\ncase7:\n\n[2 1* 0] 0\n\n[2 1* 0] 1\n\ntrivial\n```\n```\ncase8:\n\n[2 1* 0] 1\n\n[2 1* 0] 2\n\n[2 1* 1] 0\n\n[2 1* 1 0]\n```\n```\ncase9:\n\n[2 1* 0] [2 1* 0]\n\n[2 1* 0] [3 1* 0]\n\n[2 1* 1] [1 1* 0]\n\n拆后面的块\n\n[2 1* 1] 1 1* 0\n\n拆前面的块\n\n2 1* 1 1 1* 0\n\n递归成块外的1加1的情况case 2,5,8\n```\n前驱在块内：\n```\ncase10:\n\n[2 1* 0]\n\n[2 1* 1]\n\n拆块\n\n2 1* 1\n\n递归成块外的1加1的情况case 2,5,8\n```\n```\ncase11:\n\n[2 1* 1 1* 0]\n\n[2 1* 2 1* 0]\n\n拆部分块，通过把指针指到第二个2的位置\n\n2 1* [2 1* 0]\n\n递归成块外的1加1的情况case 2,5,8\n```\n\n注意到这里 $2$ 是单调向右走的，除了每次操作可能可以往左边走一格，所以把一个块端点往右移动一段，或者向左移动 $O(1)$ 个位置是可行的。\n\n加个内存池，我们需要的空间不超过 $O(k)$。\n\n（*可能可以四毛子优化一下？）\n\n## 5.link 和 delink\n\n这个是两个基本操作，用于调节 Brodal queue。\n\nlink：\n\n假设我们有 $3$ 个节点 $x_1,x_2,x_3$ ，这三个节点不是根，且有相同的 $rank$。\n\n经过 $O(1)$ 次比较之后，不妨我们设 $x_1$ 是这三个中最小的。\n\n然后我们可以把 $x_2$，$x_3$ 变成 $x_1$ 的最左儿子（因为是链表，只能在头插入），并且 $x_1$ 的 $rank$ 自增 $1$。\n\n然后 $x_2$ 和 $x_3$ 都不是违反堆性质的节点，并且 $x_1$ 仍然满足所有 S1-S5 和 O1-O5 的性质。\n\ndelink：\n\n对一个点 $x$ ，如果 $n(x,rank(x)-1)$ 是 $2$ 或者 $3$，那么把 $x$ 的 $rank$ 为 $rank(x)-1$ 的孩子和父亲的边断开，把它\"切出来\"，然后 $rank(x)$ 变成剩余孩子中的 $max(rank)+1$，这里切出来之后怎么办需要特殊说明。\n\n如果 $n(x,rank(x)-1) \\ge 4$，那么把 $2$ 个 $rank$ 为 $rank(x)-1$ 的孩子切出来。\n\ndelink 一个根节点的 $rank$ 为 $k$ 的树总是会得到 $2$ 或者 $3$ 个根节点的$rank$ 为 $k-1$ 的树，和一个额外的根节点的 $rank \\leq k$ 的树（这个树根节点的 $rank$ 可以是 $[0,k]$ 的任意数）。\n\n考虑如何维护 $t1$ 的孩子，使其满足R1（ $t1$ 对于 $[0,rank(t1)-1]$ 中每个 $rank$ 有$[2,7]$个孩子）。\n\n对 $[0,rank(t1)-3]$ 中每个 $rank$ 的孩子个数，使用两个guide，一个处理个数在 $[2,4]$ 的孩子保证其个数 $ \\ge 2$，一个处理个数在 $[5,7]$ 的孩子保证其个数 $\\leq 7$。\n\n对于 $rank$ 为 $rank(t1)-1$ 和 $rank(t1)-2$ 的孩子需要特判处理。\n\n\n\n对 $t1$ 的孩子用两个 guide 来维护,设其为 guide1 和 guide2。\n\nguide1 维护的是 $rank$ 在 $[T-2,T]$ 中的孩子，guide2 维护的是 $rank$ 在$[2,4]$ 中的孩子，这里我们令 $T=9$，是一个常数。\n\n我们用 guide 中的元素 $a_k$ 代指这个 guide 里面 $rank$ 为 $k$ 的节点个数。\n\nlink 操作会让 guide1 里面的一个元素 $a_k$ 减少 $3$ , 另一个元素 $a_{k+1}$ 增加 $1$ ，注意到这里我们维护的是一个上界的形式，所以减少 $3$ 和减少 $2$是类似的。\n\ndelink 操作会让 guide2 里面的一个元素 $a_k$ 减少 $1$, $a_{k-1}$ 增加 $2$ 或 $3$ , 还会多出一个 $rank$ 在 $[0,k]$ 中的元素，这里维护的是下界形式，所以只用考虑 $+2$。\n\n注：这里其实 $-3$ 会比 $-2$ 容易破坏下界，$+3$ 会比 $+2$容易破坏上界，把 $T$ 改成 $10$ ，或者加一些特判之后这个问题可以被解决，所以不专门讨论这两种情况了。\n\n注：这里原论文给的界是 $T=7$ ，但是我们不知道如何达成，所以在这里讲$T=9$ 的情况。\n\n$t1$ 新增孩子：\n\n如果导致同 $rank$ 的孩子数 $=9$ ，则从处理上界的 guide 得到需要执行的 $O(1)$ 次 reduce 操作（这导致了 guide 的实现的微小变化），对应于用 link 合并 $3$ 个 $rank$为 $k$ 的孩子，得到 $1$ 个 $rank$ 为 $k+1$ 的孩子。\n\n注意此时孩子数减少 $3$ 后变成 $6 > 4$ ，不影响处理下界的 guide。\n\n如果这导致 $rank$ 为 $rank(t1)-2$，$rank(t1)-1$ 的孩子过多，同样用 link 操作进行调整，这时就可能需要增加 $t1$ 的 $rank$ 了。\n\n这里由于我们每次都是把\"切出来\"的节点变成 $t1$ 的孩子，所以不产生额外的违反堆性质的节点。\n\n$t1$ 删除孩子：\n\n类似于新增孩子，但此时 reduce 对应于 delink 操作（这里只考虑 $rank=k$ 的树变为 $rank=k-1$ 的 $2$ 或 $3$ 棵树），delink 产生的额外的 rank 不固定的树会在删除孩子完成之后被新增为 $t1$ 的孩子。\n\n关于这里的常数 $T$ 的解释：\n\n我们考虑一个 guide 中维护的元素到了和这个 guide 的界差 $1$ 的情况才需要\n REDUCE ，不然不需要。\n\n对于 guide1，这个界限就是 $T-1$，对于 guide2，这个界限就是 $3$。\n\n然后我们要让这次 REDUCE 之后不会导致另一个 guide 需要调整。\n\n所以 $T-1\\;-\\;3 > 4$，$3 + 3 < T-2$，可以解出 $T > 8$，故取 $T=9$。\n\n这里和原论文的 $T=7$ 不一样，但也只是常数差别，不会对复杂度和正确性产生影响，所以不仔细讨论这个了。\n\n对于 $t2$ 的新增/删除孩子，情况和 $t1$ 类似，不同之处是 delink 产生了 $O(1)$ 个新的破坏堆性质的点，这部分的详细内容会在后面提到。\n\n定义 $pv$ 集合为 $V$ 集合和 $W$ 集合的并集，即潜在的违反堆性质的点的集合。\n\n设计一个变换，用于减少 $pv$：\n\n这一段是 $W(t1)$ 的 guide 的 REDUCE 的方法，这个变换将 $pv$ 减少了至少 $1$：\n\n假设 $x1,x2$ 是潜在的违反堆性质的点，满足 $k=rank(x1)=rank(x2)<rank(t1)$，且 $x1,x2$不是根或根的孩子。\n\n首先检查 $x1,x2$ 是否满足堆性质，若满足则从 $V$ 或 $W$ 列表中移除，否则：\n\n若 $x1,x2$ 不是兄弟：\n\n不失一般性，设 $p(x1) \\leq p(x2)$，交换 $x1$ 所在子树和 $x2$ 的某个$rank=k$ 的兄弟 $x3$（由 S4 性质可知这样的 $x3$ 一定存在）所在子树（此操作不会增加 $pv$，$x1$ 仍是 $pv$，$x3$ 可能从 $pv$ 变为非 $pv$ 也可能状态不变），之后可设 $y=p(x1)=p(x2)$。\n\n若存在 $rank=k$ 的第三个兄弟，则将 $x1$ 移除并新增为 $t1$的孩子，这样 $y$ 的 $rank=k$ 的儿子减少了一个，而且至少为 $2$ 个，不违反 S4 性质。\n\n若不存在 $rank=k$ 的第三个兄弟，则将 $x1,x2$ 移除并新增为 $t1$ 的孩子，这样 $y$ 的 $rank=k$ 的儿子个数变成 $0$ 了，不违反 S4 性质。\n\n若 $rank(y)=k+1$ 则还需要移除 $y$，更新 $y$ 的 $rank$，并新增 $y$ 为 $t1$的孩子，$y$ 子树原先的位置被从 $t1$ 移除的一个 $rank=k+1$ 的子树代替。\n\n（这可能增加一个违反堆性质的点（需要加入 $W(t1)$ 中），但同时 $x1,x2$ \n 由于父亲变成了 $t1$，所以将符合堆性质），这里还需要对 $W(t1)$ 的 guide 进行一个 $rank=k+1$ 的位置 $+1$ 的操作。\n\n所以至少减少 $2$ 个 $pv$ 中的点，至多增加 $1$ 个点到 $pv$ 中。\n\n（由于 S2 性质保证了等 $rank$ 替换时，被替换的点和用于替换的点没有祖先关系，因此不会成环）\n\n避免过多的违反堆性质的点出现：\n\n当新增一个违反堆性质的点 $x$ 时，若 $rank(x) \\ge rank(t1)$ 则将其加入到 $V(t1)$ 中，否则加入到 $W(t1)$ 中。\n\n对 $W(t1)$ 也开个 guide，里面第 $i$ 个元素就是 $w(t1,i)$。\n\n向 $W(t1)$ 加点时，插入一个点 $k$ 时，让 guide 中的第 $k$ 个元素 $+1$，然后通过 guide 得到需要进行的 reduce(k) 操作。\n\n在 $w(t1,k)=6$，且其中至少 $2$ 个不是 $t2$ 的孩子时，执行上述变换减少 $pv$。\n\n若有超过 $4$ 个是 $t2$ 的孩子，则将多出的点切下并新增为 $t1$ 的孩子（这不影响 $W(t2)$ 的 guide）。\n\n每次进行优先队列操作时：\n\n若 $T2$ 非空，则通过将 $O(1)$ 个孩子从 $t2$ 移到 $t1$，使 $t1$ 的 $rank$ 增加至少 $1$，这使得我们可以支付 $V(t1)$ 新增的不超过 $α$ 个 $pv$。\n\n具体地，若 $rank(t2) \\leq rank(t1)+2$，则把 $t2$ 的 $rank$ 最大的孩子切下并新增为 $t1$ 的孩子，最终当 $t2$ 没有孩子的时候，把 $t2$ 新增为 $t1$ 的孩子。\n\n若 $rank(t2)>rank(t1)+2$，则切下 $t2$ 的一个 $rank$ 为 $rank(t1)+2$ 的孩子，将其delink并新增为 $t1$ 的孩子。\n\n若 $T2$ 为空，则 $V(t1)$ 不会有新增的 $pv$。\n\n## 6.抽象数据结构\n对于一个抽象数据结构——优先队列，我们可以使用 Brodal queue 实现，具体进行的操作为：\n```\nMakeQueue：T1=T2=null\n```\n```\nFindMin(Q): return t1\n```\n```\nInsert(Q,e): 转为Meld(Q,{T1=e,T2=null})\n```\n\n```\nMeld(Q1,Q2):\n\n不失一般性，设 $Q1.t1<Q2.t1$。\n\n若 Q1.T1 的 rank 最大，则把其余的 $3$ 棵树新增为 Q1.t1 的孩子，Q1.T2 设为空，这个过程中不产生新的 $pv$\n\n否则让 Q1.T2，Q2.T2 中 rank 最大的树成为新的 Q1.T2，其余的 $2$ 棵树新增为 Q1.t2 的孩子。\n```\n\n解释：如果 $min$ 所在的那个树的 $rank$ 是这四个里面最大的，那就把其他几个树都插入到 $min$ 所在的那个树的孩子里面，新的树里面 $T2$ 为空\n\n否则 $rank$ 最大的那个树成为新的 $T2$，除了 $min$ 所在的树都插入这个的孩子里面，$min$ 所在的树成为 $T1$\n\n\n```\nDecreaseKey(Q,e,e'):\n\n修改权值后检查是否违反堆性质\n\n如果违反堆性质，则将其加入pv中，此时pv大小+1\n\n然后按前文避免过多的违反堆性质的点出现的方法来让pv减少至少1，使得pv大\n小平衡\n```\n```\nDeleteMin(Q):\n\n将 t2 的孩子（O(log n) 个）全部切下，新增为 t1 的孩子；将 t2 变为 t1 的孩子；\n\n删除 t1 得到 t1 的孩子，总共有 O(log n) 个。\n\n遍历 t1 的孩子，V(t1) 和 W(t1)，从而得到新的最小值t1'\n\n若 t1' 不是 t1 的孩子，则与等 rank 的孩子交换，这可能产生 O(1) 个 pv。\n\n然后将 V(t1),V(t1'),W(t1),W(t1') 合并为 W(t1')：\n\n先将 V(t1') 置为空，然后使用变换令 w(t1',i)<=1，最后使 t1' 成为新的 t1\n```\n\n```\nDelete(Q),e: 转为DecreaseKey(Q,e,-inf),DeleteMin(Q)\n```", "description": "给定一个长为 $n$ 的序列 $a$ ，每个位置有一种颜色，有 $m$ 次操作，支持：\n\n`1 l r x`：区间 $[l,r]$ 的数都变成 $x$。\n\n`2 l r`：查询有多少二元组 $(i,j)$ 满足 $l \\leq i < j \\leq r$ ，且 $a_i = a_j$。\n\n本题强制在线，每次的 $l,r,x$ 需要 $\\operatorname{xor}$ 上（上次答案 $\\bmod 2^{32}$），也就是说使用 `unsigned int` 数据类型存储上次的答案即可，如果之前没有询问，则上次答案为 $0$。这里输出的答案不对 $\\bmod 2^{32}$ 取模。", "inputFormat": "第一行两个整数 $n, m$。\n\n第二行 $n$ 个整数表示序列 $a$。\n\n之后 $m$ 行，每行形如 `1 l r x` 或 `2 l r`，表示上述的操作。", "outputFormat": "对于每个 $2$ 操作，输出一行一个整数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477&ccz181078，Code：ccz181078，Data：nzhtl1477\n\n注意：本题采用**捆绑测试**，只有当你通过一个 subtask 中的所有测试点后，你才能拿到这个 subtask 的分数。\n\n对于其中 $1\\%$ 的数据，为样例 1。\n\n对于另外 $9\\%$ 的数据，没有修改操作。\n\n对于另外 $19\\%$ 的数据，$n,m\\leq 500$。\n\n对于另外 $19\\%$ 的数据，每次修改的区间长度不超过 $5$。\n\n对于另外 $19\\%$ 的数据，保证数据随机。\n\n对于 $100\\%$ 的数据，$1\\leq n,m\\leq 2\\times 10^5$，$1\\leq a_{i},x\\leq n$，$1\\leq l\\leq r\\leq n$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2010] Brodal queue", "background": "题目背景和题意无关，可以跳过\n\n## 1.前言：\nBrodal queue 在 1996 年由 Brodal 提出，是第一个满足每个操作都 worst case 而且达到了基于比较的堆的下界的数据结构\n\n这里给出的 Brodal queue 是一个小根堆\n\n该数据结构的一些特性：\n\n1. 维护了两棵树。\n\n2. Brodal queue 是一种 violation heap，即允许存在一些节点不满足堆性质。\n\n3. 实现真的很复杂，常数真的很大。\n\n## 2.一些记号：\nBrodal queue 维护了两棵树 $T1$ , $T2$，他们的根是 $t1$ 和 $t2$。\n\n定义：\n\n$p(x)$：$x$ 的父亲节点，默认 $x \\neq t1$ 且 $x \\neq t2$。\n\n$rank(x)$：和 $log( subtree\\;size )$ 相关的一个权值。\n\n$n(x,i)$：$x$ 的孩子中满足其 $rank$ 为 $i$ 的个数。\n\n$w(x,i)$：$W(x)$ 中 $rank$ 为 $i$ 的元素个数。\n\n$V$ 和 $W$ 列表：维护所有违反堆性质的节点。\n\n## 3.概述：\n每个曾经作为 $T1$ 的根的点都维护 $V$ 和 $W$，我们用 $V(x)$ 表示 $x$ 节点的 $V$ 集合，$W(x)$ 表示 $x$ 节点的 $W$ 集合。\n\n$V$ 维护的是 $rank \\ge rank(t1)$ 的节点，$W$ 维护的是 $rank<rank(t1)$ 的节点，这个是对插入当时的情况成立的，也就是说在经过结构修改操作之后不一定还满足这个性质。\n\n$V$ 是只加不删的， $W$ 是需要维护平衡的，所以只需要保证 $t1$ 的 $W$ 中的点的 $rank<rank(t1)$。\n\n有以下的一些性质：\n\n$rank$ 的性质：\n\nS1. 叶子节点的 $rank$ 为 $0$。\n\nS2. $rank(x) < rank( p(x) )$。\n\nS3. 如果 $rank(x) > 0$，则 $n(x,rank(x)-1) \\ge 2$。\n\nS4. $n(x,i)$ 只可能为 ${0,2,3,4,5,6,7}$ 中的元素。\n\nS5. 当 $T2 \\neq null$ 时 $rank(t1) \\leq rank(t2)$。\n\n解释：\n\nS1. 边界定义。\n\nS2. $rank$ 构成大根堆。\n\nS3. 一个点有至少两个孩子的 $rank$ 是其 $rank-1$，所以 $x$ 的子树大小关于 $x$ 的 $rank$ 至少是指数级的，所以 $rank$ 最多是 $O( \\log n )$ 的。\n\nS4. $n(x,i)$ 有 $O(1)$ 上界，非 $1$ ，而总共有 $O( \\log n )$ 种 $rank$，所以每个节点的度数都是 $O(\\log n )$ 的。\n\nS5. 要么 $T1$ 比 $T2$ 小，要么 $T2$ 为空。\n\n$V$ 和 $W$ 列表的性质：\n\nO1. $t1$ 是所有元素中的最小元。\n\nO2. 如果 $y$ 在 $V(x)$ 或者 $W(x)$ 中，则 $x \\leq y$，即这个元素在被插入列表时是违背了堆性质的。\n\nO3. 如果 $y<p(y)$ ，那么存在一个 $x$ 使得 $x \\neq y$，$y$ 属于 $V(x)$ 或 $W(x)$，即所有违背堆性质的节点都在某个节点的 $V$ 或 $W$ 列表中。\n\nO4. 对于所有 $x$，有 $w(x,i) \\leq 6$。\n\nO5. 记 $V(x) = (y_|V(x)|,...,y_2,y_1)$ , 则 $rank(y_i) \\ge floor((i-1)/α)$，$α$ 是一个常数。\n\n解释：\n\nO1. 我们要 $O(1)$ 求出最小值，所以规定了最小元是 $t1$。\n\nO2. $x$ 被插入的时候是被插到 $V(t1)$ 或者 $W(t1)$ 中。\n\nO3. 违反堆性质的点一定在另一个点的 $V$ 或者 $W$ 集合中。\n\nO4. $w(x,i)$ 有常数上界，所以 $V$ 和 $W$ 列表的大小是 $O( \\log n )$ 的。\n\nO5. $V$ 列表中的 $rank$ 有一个阶梯的下界。\n\n对于 $t1$，$t2$ 的额外性质：\n\nR1. 对 $i = 0 \\sim rank(tj) - 1$，有 $n(tj,i) \\ne 0$。\n\nR2. $|V(t1)| \\leq α \\times rank(t1)$ ，和前面提到的是同一个 $α$。\n\nR3. 如果 $y$ 属于 $W(t1)$ 则 $rank(y)<rank(t1)$。\n\n解释：\n\nR1. 对于 $t1$，$t2$，每个 $rank$ 的孩子至少有 $2$ 个。\n\nR2. $V(t1)$ 的大小 $|V(t1)|$ 有 $α \\times rank(t1)$ 的上界。\n\nR3. 属于 $W(t1)$ 的点比 $t1$ 小。\n\nR2+O5可以推出如果 $t1$ 的 $rank$ 增大 $1$ ，我们就可以增加 $α$ 个大的违反堆性质的节点，把他们加入 $V(t1)$，并且不违反 $O5$。\n\n每次 DECREASEKEY 时 ，我们直接加一个新的违反堆性质的点到 $V(t1)$ 或者$W(t1)$。\n\n为了避免有太多的违反堆性质的节点，我们递增地做两种不同的变换，主要为了维护 R2 和 O4 性质。\n\n第一种：把 $t2$ 的儿子移动进入 $T1$ ，变成 $t1$ 的孩子，使得 $rank(t1)$ 变大。\n\n第二种：通过把 $2$ 个 $rank$ 为 $k$ 的违反堆性质的节点换成了 $\\leq 1$个$rank$ 为 $k+1$ 的违反堆性质的节点，从而减少 $W(t1)$ 的大小。\n\nNote：我们这里用到了很多可变长数组，默认可变长数组是严格 $O(1)$ 的，这个是平凡的所以不详细讲怎么实现了。\n\n这里给出了一个作者称为 guide 的数据结构的实现。\n\n## 4.Guide Data Structure：\n\n用途：维护 $R1$，$O4$ 性质，即对 $n(t1,i),n(t2,i),w(t1,i)$ 的上界进行维护，大概是一个维护 $O(1)$ 进位的东西。\n\n抽象出这部分要维护的东西，也就是我们这里讲的 guide 数据结构是要维护什么：\n\n维护：一个长为 $k$ 的 int 数组，$x_k,x_{k-1},...x_1$ （这里我们从右往左写序列）。\n\n需要满足：$max(x_i) \\leq T$ , $T$ 是预设的一个阈值常数。\n\n我们只能在这个数组上实现 REDUCE(i) 的操作，即 $x_i$ 至少减少 $2$，$x_{i+1}$ 至多增加 $1$（实际上这里我们 $x_i$ 只能减少 $2$ 或者 $3$，$x_{i+1}$ 只能增加 $0$ 或者 $1$）。\n\n每次可能发生对一个任意位置 $i$ 的 $x_i$ 的 $+1$ 或者 $-1$ 操作，每次操作之后我们被允许通过 $O(1)$ 次 REDUCE 操作，使得我们需要维护的数组仍旧满足性质。\n\nguide 干的事情就是 guide（向导） ，也就是说告诉我们要做什么样的 REDUCE 操作使得这个数组仍旧满足性质。\n\n定义 $x'$ 是 $[T-2,T]$ ，当 $x_i$ 碰到进入 $x'$ 的范围之前我们不考虑对其进行调整。\n\n不妨设 $T=2$，我们对 $T=2$ 维护这个 guide 即可。\n\n把原序列分成一些块，考虑形如 $2$ $1*$ $0$ 这样的连续段，不在段内的元素只可能是单独的 $0$ 或 $1$。\n\n对每个块我们新建一个节点，然后段内的每个元素都指向这个节点。\n\n每个节点上记录块的开头位置。\n\n不在块内的节点直接指向一个 null。\n\n这里我们多个点共用一个 null ，存在多个 null。\n\n有两个重要的性质：\n\n1. 给一个位置 $x$ ，我们可以最坏复杂度 $O(1)$ 找到 $x$ 所属于的块内最左边的元素，\n并且——\n\n2. 我们可以最坏复杂度 $O(1)$ 销毁掉一个给定的块，直接把那个存有值的点改成 null 即可。\n\n这里写一下变换是如何实现的，由于是按照自己的理解写的，所以可能和原论文\n有出入。\n\n注意到我们可以 $O(1)$ 拆掉一个块。\n\n前驱不在块内：\n\n```\ncase1：\n\n0 0\n\n0 1\n\ntrivial\n```\n```\ncase2：\n\n0 1\n\n0 2\n\n1 1\n\ntrivial\n\n```\n```\ncase3:\n\n0 [2 1* 0]\n\n0 [3 1* 0]\n\n1 [1 1* 0]\n\n拆掉这个块\n\n1 1 1* 0\n```\n```\ncase4:\n\n1 0\n\n1 1\n\ntrivial\n```\n```\ncase5:\n\n1 1\n\n1 2\n\n[2 0]\n\ntrivial\n```\n```\ncase6:\n\n1 [2 1* 0]\n\n1 [3 1* 0]\n\n2 [1 1* 0]\n\n[2 1 1* 0]\n```\n前驱是块尾：\n```\ncase7:\n\n[2 1* 0] 0\n\n[2 1* 0] 1\n\ntrivial\n```\n```\ncase8:\n\n[2 1* 0] 1\n\n[2 1* 0] 2\n\n[2 1* 1] 0\n\n[2 1* 1 0]\n```\n```\ncase9:\n\n[2 1* 0] [2 1* 0]\n\n[2 1* 0] [3 1* 0]\n\n[2 1* 1] [1 1* 0]\n\n拆后面的块\n\n[2 1* 1] 1 1* 0\n\n拆前面的块\n\n2 1* 1 1 1* 0\n\n递归成块外的1加1的情况case 2,5,8\n```\n前驱在块内：\n```\ncase10:\n\n[2 1* 0]\n\n[2 1* 1]\n\n拆块\n\n2 1* 1\n\n递归成块外的1加1的情况case 2,5,8\n```\n```\ncase11:\n\n[2 1* 1 1* 0]\n\n[2 1* 2 1* 0]\n\n拆部分块，通过把指针指到第二个2的位置\n\n2 1* [2 1* 0]\n\n递归成块外的1加1的情况case 2,5,8\n```\n\n注意到这里 $2$ 是单调向右走的，除了每次操作可能可以往左边走一格，所以把一个块端点往右移动一段，或者向左移动 $O(1)$ 个位置是可行的。\n\n加个内存池，我们需要的空间不超过 $O(k)$。\n\n（*可能可以四毛子优化一下？）\n\n## 5.link 和 delink\n\n这个是两个基本操作，用于调节 Brodal queue。\n\nlink：\n\n假设我们有 $3$ 个节点 $x_1,x_2,x_3$ ，这三个节点不是根，且有相同的 $rank$。\n\n经过 $O(1)$ 次比较之后，不妨我们设 $x_1$ 是这三个中最小的。\n\n然后我们可以把 $x_2$，$x_3$ 变成 $x_1$ 的最左儿子（因为是链表，只能在头插入），并且 $x_1$ 的 $rank$ 自增 $1$。\n\n然后 $x_2$ 和 $x_3$ 都不是违反堆性质的节点，并且 $x_1$ 仍然满足所有 S1-S5 和 O1-O5 的性质。\n\ndelink：\n\n对一个点 $x$ ，如果 $n(x,rank(x)-1)$ 是 $2$ 或者 $3$，那么把 $x$ 的 $rank$ 为 $rank(x)-1$ 的孩子和父亲的边断开，把它\"切出来\"，然后 $rank(x)$ 变成剩余孩子中的 $max(rank)+1$，这里切出来之后怎么办需要特殊说明。\n\n如果 $n(x,rank(x)-1) \\ge 4$，那么把 $2$ 个 $rank$ 为 $rank(x)-1$ 的孩子切出来。\n\ndelink 一个根节点的 $rank$ 为 $k$ 的树总是会得到 $2$ 或者 $3$ 个根节点的$rank$ 为 $k-1$ 的树，和一个额外的根节点的 $rank \\leq k$ 的树（这个树根节点的 $rank$ 可以是 $[0,k]$ 的任意数）。\n\n考虑如何维护 $t1$ 的孩子，使其满足R1（ $t1$ 对于 $[0,rank(t1)-1]$ 中每个 $rank$ 有$[2,7]$个孩子）。\n\n对 $[0,rank(t1)-3]$ 中每个 $rank$ 的孩子个数，使用两个guide，一个处理个数在 $[2,4]$ 的孩子保证其个数 $ \\ge 2$，一个处理个数在 $[5,7]$ 的孩子保证其个数 $\\leq 7$。\n\n对于 $rank$ 为 $rank(t1)-1$ 和 $rank(t1)-2$ 的孩子需要特判处理。\n\n\n\n对 $t1$ 的孩子用两个 guide 来维护,设其为 guide1 和 guide2。\n\nguide1 维护的是 $rank$ 在 $[T-2,T]$ 中的孩子，guide2 维护的是 $rank$ 在$[2,4]$ 中的孩子，这里我们令 $T=9$，是一个常数。\n\n我们用 guide 中的元素 $a_k$ 代指这个 guide 里面 $rank$ 为 $k$ 的节点个数。\n\nlink 操作会让 guide1 里面的一个元素 $a_k$ 减少 $3$ , 另一个元素 $a_{k+1}$ 增加 $1$ ，注意到这里我们维护的是一个上界的形式，所以减少 $3$ 和减少 $2$是类似的。\n\ndelink 操作会让 guide2 里面的一个元素 $a_k$ 减少 $1$, $a_{k-1}$ 增加 $2$ 或 $3$ , 还会多出一个 $rank$ 在 $[0,k]$ 中的元素，这里维护的是下界形式，所以只用考虑 $+2$。\n\n注：这里其实 $-3$ 会比 $-2$ 容易破坏下界，$+3$ 会比 $+2$容易破坏上界，把 $T$ 改成 $10$ ，或者加一些特判之后这个问题可以被解决，所以不专门讨论这两种情况了。\n\n注：这里原论文给的界是 $T=7$ ，但是我们不知道如何达成，所以在这里讲$T=9$ 的情况。\n\n$t1$ 新增孩子：\n\n如果导致同 $rank$ 的孩子数 $=9$ ，则从处理上界的 guide 得到需要执行的 $O(1)$ 次 reduce 操作（这导致了 guide 的实现的微小变化），对应于用 link 合并 $3$ 个 $rank$为 $k$ 的孩子，得到 $1$ 个 $rank$ 为 $k+1$ 的孩子。\n\n注意此时孩子数减少 $3$ 后变成 $6 > 4$ ，不影响处理下界的 guide。\n\n如果这导致 $rank$ 为 $rank(t1)-2$，$rank(t1)-1$ 的孩子过多，同样用 link 操作进行调整，这时就可能需要增加 $t1$ 的 $rank$ 了。\n\n这里由于我们每次都是把\"切出来\"的节点变成 $t1$ 的孩子，所以不产生额外的违反堆性质的节点。\n\n$t1$ 删除孩子：\n\n类似于新增孩子，但此时 reduce 对应于 delink 操作（这里只考虑 $rank=k$ 的树变为 $rank=k-1$ 的 $2$ 或 $3$ 棵树），delink 产生的额外的 rank 不固定的树会在删除孩子完成之后被新增为 $t1$ 的孩子。\n\n关于这里的常数 $T$ 的解释：\n\n我们考虑一个 guide 中维护的元素到了和这个 guide 的界差 $1$ 的情况才需要\n REDUCE ，不然不需要。\n\n对于 guide1，这个界限就是 $T-1$，对于 guide2，这个界限就是 $3$。\n\n然后我们要让这次 REDUCE 之后不会导致另一个 guide 需要调整。\n\n所以 $T-1\\;-\\;3 > 4$，$3 + 3 < T-2$，可以解出 $T > 8$，故取 $T=9$。\n\n这里和原论文的 $T=7$ 不一样，但也只是常数差别，不会对复杂度和正确性产生影响，所以不仔细讨论这个了。\n\n对于 $t2$ 的新增/删除孩子，情况和 $t1$ 类似，不同之处是 delink 产生了 $O(1)$ 个新的破坏堆性质的点，这部分的详细内容会在后面提到。\n\n定义 $pv$ 集合为 $V$ 集合和 $W$ 集合的并集，即潜在的违反堆性质的点的集合。\n\n设计一个变换，用于减少 $pv$：\n\n这一段是 $W(t1)$ 的 guide 的 REDUCE 的方法，这个变换将 $pv$ 减少了至少 $1$：\n\n假设 $x1,x2$ 是潜在的违反堆性质的点，满足 $k=rank(x1)=rank(x2)<rank(t1)$，且 $x1,x2$不是根或根的孩子。\n\n首先检查 $x1,x2$ 是否满足堆性质，若满足则从 $V$ 或 $W$ 列表中移除，否则：\n\n若 $x1,x2$ 不是兄弟：\n\n不失一般性，设 $p(x1) \\leq p(x2)$，交换 $x1$ 所在子树和 $x2$ 的某个$rank=k$ 的兄弟 $x3$（由 S4 性质可知这样的 $x3$ 一定存在）所在子树（此操作不会增加 $pv$，$x1$ 仍是 $pv$，$x3$ 可能从 $pv$ 变为非 $pv$ 也可能状态不变），之后可设 $y=p(x1)=p(x2)$。\n\n若存在 $rank=k$ 的第三个兄弟，则将 $x1$ 移除并新增为 $t1$的孩子，这样 $y$ 的 $rank=k$ 的儿子减少了一个，而且至少为 $2$ 个，不违反 S4 性质。\n\n若不存在 $rank=k$ 的第三个兄弟，则将 $x1,x2$ 移除并新增为 $t1$ 的孩子，这样 $y$ 的 $rank=k$ 的儿子个数变成 $0$ 了，不违反 S4 性质。\n\n若 $rank(y)=k+1$ 则还需要移除 $y$，更新 $y$ 的 $rank$，并新增 $y$ 为 $t1$的孩子，$y$ 子树原先的位置被从 $t1$ 移除的一个 $rank=k+1$ 的子树代替。\n\n（这可能增加一个违反堆性质的点（需要加入 $W(t1)$ 中），但同时 $x1,x2$ \n 由于父亲变成了 $t1$，所以将符合堆性质），这里还需要对 $W(t1)$ 的 guide 进行一个 $rank=k+1$ 的位置 $+1$ 的操作。\n\n所以至少减少 $2$ 个 $pv$ 中的点，至多增加 $1$ 个点到 $pv$ 中。\n\n（由于 S2 性质保证了等 $rank$ 替换时，被替换的点和用于替换的点没有祖先关系，因此不会成环）\n\n避免过多的违反堆性质的点出现：\n\n当新增一个违反堆性质的点 $x$ 时，若 $rank(x) \\ge rank(t1)$ 则将其加入到 $V(t1)$ 中，否则加入到 $W(t1)$ 中。\n\n对 $W(t1)$ 也开个 guide，里面第 $i$ 个元素就是 $w(t1,i)$。\n\n向 $W(t1)$ 加点时，插入一个点 $k$ 时，让 guide 中的第 $k$ 个元素 $+1$，然后通过 guide 得到需要进行的 reduce(k) 操作。\n\n在 $w(t1,k)=6$，且其中至少 $2$ 个不是 $t2$ 的孩子时，执行上述变换减少 $pv$。\n\n若有超过 $4$ 个是 $t2$ 的孩子，则将多出的点切下并新增为 $t1$ 的孩子（这不影响 $W(t2)$ 的 guide）。\n\n每次进行优先队列操作时：\n\n若 $T2$ 非空，则通过将 $O(1)$ 个孩子从 $t2$ 移到 $t1$，使 $t1$ 的 $rank$ 增加至少 $1$，这使得我们可以支付 $V(t1)$ 新增的不超过 $α$ 个 $pv$。\n\n具体地，若 $rank(t2) \\leq rank(t1)+2$，则把 $t2$ 的 $rank$ 最大的孩子切下并新增为 $t1$ 的孩子，最终当 $t2$ 没有孩子的时候，把 $t2$ 新增为 $t1$ 的孩子。\n\n若 $rank(t2)>rank(t1)+2$，则切下 $t2$ 的一个 $rank$ 为 $rank(t1)+2$ 的孩子，将其delink并新增为 $t1$ 的孩子。\n\n若 $T2$ 为空，则 $V(t1)$ 不会有新增的 $pv$。\n\n## 6.抽象数据结构\n对于一个抽象数据结构——优先队列，我们可以使用 Brodal queue 实现，具体进行的操作为：\n```\nMakeQueue：T1=T2=null\n```\n```\nFindMin(Q): return t1\n```\n```\nInsert(Q,e): 转为Meld(Q,{T1=e,T2=null})\n```\n\n```\nMeld(Q1,Q2):\n\n不失一般性，设 $Q1.t1<Q2.t1$。\n\n若 Q1.T1 的 rank 最大，则把其余的 $3$ 棵树新增为 Q1.t1 的孩子，Q1.T2 设为空，这个过程中不产生新的 $pv$\n\n否则让 Q1.T2，Q2.T2 中 rank 最大的树成为新的 Q1.T2，其余的 $2$ 棵树新增为 Q1.t2 的孩子。\n```\n\n解释：如果 $min$ 所在的那个树的 $rank$ 是这四个里面最大的，那就把其他几个树都插入到 $min$ 所在的那个树的孩子里面，新的树里面 $T2$ 为空\n\n否则 $rank$ 最大的那个树成为新的 $T2$，除了 $min$ 所在的树都插入这个的孩子里面，$min$ 所在的树成为 $T1$\n\n\n```\nDecreaseKey(Q,e,e'):\n\n修改权值后检查是否违反堆性质\n\n如果违反堆性质，则将其加入pv中，此时pv大小+1\n\n然后按前文避免过多的违反堆性质的点出现的方法来让pv减少至少1，使得pv大\n小平衡\n```\n```\nDeleteMin(Q):\n\n将 t2 的孩子（O(log n) 个）全部切下，新增为 t1 的孩子；将 t2 变为 t1 的孩子；\n\n删除 t1 得到 t1 的孩子，总共有 O(log n) 个。\n\n遍历 t1 的孩子，V(t1) 和 W(t1)，从而得到新的最小值t1'\n\n若 t1' 不是 t1 的孩子，则与等 rank 的孩子交换，这可能产生 O(1) 个 pv。\n\n然后将 V(t1),V(t1'),W(t1),W(t1') 合并为 W(t1')：\n\n先将 V(t1') 置为空，然后使用变换令 w(t1',i)<=1，最后使 t1' 成为新的 t1\n```\n\n```\nDelete(Q),e: 转为DecreaseKey(Q,e,-inf),DeleteMin(Q)\n```", "description": "给定一个长为 $n$ 的序列 $a$ ，每个位置有一种颜色，有 $m$ 次操作，支持：\n\n`1 l r x`：区间 $[l,r]$ 的数都变成 $x$。\n\n`2 l r`：查询有多少二元组 $(i,j)$ 满足 $l \\leq i < j \\leq r$ ，且 $a_i = a_j$。\n\n本题强制在线，每次的 $l,r,x$ 需要 $\\operatorname{xor}$ 上（上次答案 $\\bmod 2^{32}$），也就是说使用 `unsigned int` 数据类型存储上次的答案即可，如果之前没有询问，则上次答案为 $0$。这里输出的答案不对 $\\bmod 2^{32}$ 取模。", "inputFormat": "第一行两个整数 $n, m$。\n\n第二行 $n$ 个整数表示序列 $a$。\n\n之后 $m$ 行，每行形如 `1 l r x` 或 `2 l r`，表示上述的操作。", "outputFormat": "对于每个 $2$ 操作，输出一行一个整数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477&ccz181078，Code：ccz181078，Data：nzhtl1477\n\n注意：本题采用**捆绑测试**，只有当你通过一个 subtask 中的所有测试点后，你才能拿到这个 subtask 的分数。\n\n对于其中 $1\\%$ 的数据，为样例 1。\n\n对于另外 $9\\%$ 的数据，没有修改操作。\n\n对于另外 $19\\%$ 的数据，$n,m\\leq 500$。\n\n对于另外 $19\\%$ 的数据，每次修改的区间长度不超过 $5$。\n\n对于另外 $19\\%$ 的数据，保证数据随机。\n\n对于 $100\\%$ 的数据，$1\\leq n,m\\leq 2\\times 10^5$，$1\\leq a_{i},x\\leq n$，$1\\leq l\\leq r\\leq n$。\n", "locale": "zh-CN"}}}
{"pid": "P6020", "type": "P", "difficulty": 7, "samples": [["3 2", "1\n0 2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2010", "Special Judge", "O2优化", "Ynoi"], "title": "[Ynoi2010] Exponential tree", "background": "", "description": "对于给定的 $n,k$，你需要构造一个只含 $0,1$ 的矩阵 $A_{i,j}$，$0\\le i,j\\le n$，满足：\n\n1. $A_{i,i}=1$\n2. $A_{i,i+1}=1$\n3. 对 $i>j$ 有 $A_{i,j}=0$\n4. 若 $A_{i,j}=1$，$j-i>1$，则存在 $i<t<j$，满足 $A_{i,t}=A_{t,j}=1$\n5. 对 $i\\le j$ 有 $(A^k)_{i,j}>0$。\n\n你需要输出满足 $A_{i,j}=1$ 且 $j-i>1$ 的每个 $(i,j)$，设这样的 $(i,j)$ 共有 $m$ 个。\n\n若输出不满足要求，则不能得到该测试点的任何分数。若输出满足要求，则根据 $m$ 进行评分。", "inputFormat": "一行，两个整数 $n,k$。\n", "outputFormat": "第一行一个整数 $m$，接下来 $m$ 行，每行两个整数 $i,j$，依次表示每个满足 $A_{i,j}=1$ 且 $j-i>1$ 的二元组 $(i,j)$。", "hint": "对于 $100\\%$ 的数据，满足 $1900\\le n\\le 2000$\n$2\\le k\\le 15$。\n\n\n| $k$  | $f(n,k)$ |\n| ---- | -------- |\n| 2    | 7.987    |\n| 3    | 3.8085   |\n| 4    | 2.396    |\n| 5    | 1.961    |\n| 6    | 1.6065   |\n| 7    | 1.451    |\n| 8    | 1.2535   |\n| 9    | 1.1975   |\n| 10   | 1.099    |\n| 11   | 1.07     |\n| 12   | 1.034    |\n| 13   | 1.0115   |\n| 14   | 1.001    |\n| 15   | 0.994    |\n\n\n\n每个 $2\\le k\\le 15$ 对应一个总分为 $s(k)$ 的子任务，每个子任务的得分是子任务中每个测试点的得分的最小值。\n\n每个测试点的得分为所在子任务的总分的 $\\max\\left(0,1-\\sqrt{\\max\\left(0,\\frac{m}{n\\cdot f(k)}-1\\right)}\\right)$ 倍。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2010] Exponential tree", "background": "", "description": "对于给定的 $n,k$，你需要构造一个只含 $0,1$ 的矩阵 $A_{i,j}$，$0\\le i,j\\le n$，满足：\n\n1. $A_{i,i}=1$\n2. $A_{i,i+1}=1$\n3. 对 $i>j$ 有 $A_{i,j}=0$\n4. 若 $A_{i,j}=1$，$j-i>1$，则存在 $i<t<j$，满足 $A_{i,t}=A_{t,j}=1$\n5. 对 $i\\le j$ 有 $(A^k)_{i,j}>0$。\n\n你需要输出满足 $A_{i,j}=1$ 且 $j-i>1$ 的每个 $(i,j)$，设这样的 $(i,j)$ 共有 $m$ 个。\n\n若输出不满足要求，则不能得到该测试点的任何分数。若输出满足要求，则根据 $m$ 进行评分。", "inputFormat": "一行，两个整数 $n,k$。\n", "outputFormat": "第一行一个整数 $m$，接下来 $m$ 行，每行两个整数 $i,j$，依次表示每个满足 $A_{i,j}=1$ 且 $j-i>1$ 的二元组 $(i,j)$。", "hint": "对于 $100\\%$ 的数据，满足 $1900\\le n\\le 2000$\n$2\\le k\\le 15$。\n\n\n| $k$  | $f(n,k)$ |\n| ---- | -------- |\n| 2    | 7.987    |\n| 3    | 3.8085   |\n| 4    | 2.396    |\n| 5    | 1.961    |\n| 6    | 1.6065   |\n| 7    | 1.451    |\n| 8    | 1.2535   |\n| 9    | 1.1975   |\n| 10   | 1.099    |\n| 11   | 1.07     |\n| 12   | 1.034    |\n| 13   | 1.0115   |\n| 14   | 1.001    |\n| 15   | 0.994    |\n\n\n\n每个 $2\\le k\\le 15$ 对应一个总分为 $s(k)$ 的子任务，每个子任务的得分是子任务中每个测试点的得分的最小值。\n\n每个测试点的得分为所在子任务的总分的 $\\max\\left(0,1-\\sqrt{\\max\\left(0,\\frac{m}{n\\cdot f(k)}-1\\right)}\\right)$ 倍。", "locale": "zh-CN"}}}
{"pid": "P6021", "type": "P", "difficulty": 6, "samples": [["4\n4 3 2 1\n1 2\n1 3\n4 2\n4\nQ 1\nQ 2\nC 4 10\nQ 1", "3\n1\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "线段树", "树链剖分", "动态树 LCT", "矩阵乘法", "动态 DP", "全局平衡二叉树"], "title": "洪水", "background": null, "description": "小 A 走到一个山脚下，准备给自己造一个小屋。这时候，小 A 的朋友（`op`，又叫管理员）打开了创造模式，然后飞到山顶放了格水。于是小 A 面前出现了一个瀑布。作为平民的小 A 只好老实巴交地爬山堵水。那么问题来了：我们把这个瀑布看成是一个 $n$ 个节点的树，**其中树根为 $1$，** 每个节点有权值（爬上去的代价）。小 A 要选择一些节点，以其权值和作为代价将这些点删除（堵上），使得根节点与所有叶子结点不连通。问最小代价。不过到这还没结束。小 A 的朋友觉得这样子太便宜小 A 了，于是他还会不断地修改地形，使得某个节点的权值发生变化。不过到这还没结束。小 A 觉得朋友做得太绝了，于是放弃了分离所有叶子节点的方案。取而代之的是，每次他只要在某个子树中（和子树之外的点完全无关）。于是他找到你。", "inputFormat": "输入文件第一行包含一个数 $n$，表示树的大小。\n\n接下来一行包含 $n$ 个数，表示第 $i$ 个点的权值。\n\n接下来 $n-1$ 行每行包含两个数 $fr,to$ 。表示树中有一条边 $(fr,to)$ 。\n\n接下来一行一个整数，表示操作的个数。\n\n接下来 $m$ 行每行表示一个操作，若该行第一个数为 $Q$，则表示询问操作，后面跟一个参数 $x$ ，表示对应子树的根；若为 $C$ ，则表示修改操作，后面接两个参数 $x,t$ ，表示将点 $x$ 的权值加上 $t$。", "outputFormat": "对于每次询问操作，输出对应的答案，答案之间用换行隔开。", "hint": "$1 \\leq n \\leq 200000,1 \\leq fr,to \\leq n,1 \\leq x \\leq n$，权值和 $t$ 均在 `int` 范围内且非负。\n\nBZOJ4712", "locale": "zh-CN", "translations": {"zh-CN": {"title": "洪水", "background": null, "description": "小 A 走到一个山脚下，准备给自己造一个小屋。这时候，小 A 的朋友（`op`，又叫管理员）打开了创造模式，然后飞到山顶放了格水。于是小 A 面前出现了一个瀑布。作为平民的小 A 只好老实巴交地爬山堵水。那么问题来了：我们把这个瀑布看成是一个 $n$ 个节点的树，**其中树根为 $1$，** 每个节点有权值（爬上去的代价）。小 A 要选择一些节点，以其权值和作为代价将这些点删除（堵上），使得根节点与所有叶子结点不连通。问最小代价。不过到这还没结束。小 A 的朋友觉得这样子太便宜小 A 了，于是他还会不断地修改地形，使得某个节点的权值发生变化。不过到这还没结束。小 A 觉得朋友做得太绝了，于是放弃了分离所有叶子节点的方案。取而代之的是，每次他只要在某个子树中（和子树之外的点完全无关）。于是他找到你。", "inputFormat": "输入文件第一行包含一个数 $n$，表示树的大小。\n\n接下来一行包含 $n$ 个数，表示第 $i$ 个点的权值。\n\n接下来 $n-1$ 行每行包含两个数 $fr,to$ 。表示树中有一条边 $(fr,to)$ 。\n\n接下来一行一个整数，表示操作的个数。\n\n接下来 $m$ 行每行表示一个操作，若该行第一个数为 $Q$，则表示询问操作，后面跟一个参数 $x$ ，表示对应子树的根；若为 $C$ ，则表示修改操作，后面接两个参数 $x,t$ ，表示将点 $x$ 的权值加上 $t$。", "outputFormat": "对于每次询问操作，输出对应的答案，答案之间用换行隔开。", "hint": "$1 \\leq n \\leq 200000,1 \\leq fr,to \\leq n,1 \\leq x \\leq n$，权值和 $t$ 均在 `int` 范围内且非负。\n\nBZOJ4712", "locale": "zh-CN"}}}
{"pid": "P6022", "type": "P", "difficulty": 2, "samples": [["5 2\n2 4\n", "15"], ["2 2\n2 2\n", "Inf"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2020"], "title": "快乐水", "background": "小 W 要去买快乐水。", "description": "他来到了一家商店门前。\n\n这家商店为了吸引顾客来买快乐水，搞了这么一个活动：「$5$ 个瓶盖换一瓶快乐水」。于是，人们纷纷来他的店里买快乐水。\n\n买完快乐水，他想到了一个问题：\n\n如果一瓶快乐水有 $m$ 个附属品，对于第 $i$ 个附属品，每 $a_i$ 个可以换一瓶全新的快乐水，现在我有买 $n$ 瓶快乐水的钱，我最多能喝多少快乐水呢？", "inputFormat": "第一行两个整数 $n,m$，意义如上。\n\n接下来一行 $m$ 个整数 $a_1,a_2,\\cdots,a_m$，意义如上。", "outputFormat": "如果小 W 可以无限白嫖快乐水，那么输出一行一个字符串 `Inf`。\n\n否则，输出一行一个整数 $s$，表示小 W 最多能喝的快乐水数量。", "hint": "样例一解释：\n\n| 步数 | 已喝 | 未喝 | 附属品一 | 附属品二 |\n| ---- | ---- | ---- | -------- | -------- |\n| 1    | 0    | 5    | 0        | 0        |\n| 2    | 5    | 0    | 5        | 5        |\n| 3    | 5    | 3    | 1        | 1        |\n| 4    | 8    | 0    | 4        | 4        |\n| 5    | 8    | 3    | 0        | 0        |\n| 6    | 11   | 0    | 3        | 3        |\n| 7    | 11   | 1    | 1        | 3        |\n| 8    | 12   | 0    | 2        | 4        |\n| 9    | 12   | 2    | 0        | 0        |\n| 10   | 14   | 0    | 2        | 2        |\n| 11   | 14   | 1    | 0        | 2        |\n| 12   | 15   | 0    | 1        | 3        |\n\n样例二解释：\n\n| 步数 | 已喝     | 未喝     | 附属品一 | 附属品二 |\n| ---- | -------- | -------- | -------- | -------- |\n| 1    | 0        | 2        | 0        | 0        |\n| 2    | 2        | 0        | 2        | 2        |\n| 3    | 2        | 2        | 0        | 0        |\n| 4    | 4        | 0        | 2        | 2        |\n| 5    | 4        | 2        | 0        | 0        |\n| 6    | 6        | 0        | 2        | 2        |\n| 7    | 6        | 2        | 0        | 0        |\n| 8    | 8        | 0        | 2        | 2        |\n| 9    | $\\vdots$ | $\\vdots$ | $\\vdots$ | $\\vdots$ |\n\n很显然小 W 可以像这样无限白嫖快乐水。\n\n**注意：本题中，我们认为无法借还/赊账。**\n********\n数据范围：  \n\n测试点一与样例二相同。\n\n对于其中 $30\\%$ 的数据，$n\\le 100$，$m\\le 2$。\n\n对于 $100\\%$ 的数据，$1\\le n\\le 10^4$，$1\\le m\\le 5$，$1\\le a_i\\le 2\\times10^3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "快乐水", "background": "小 W 要去买快乐水。", "description": "他来到了一家商店门前。\n\n这家商店为了吸引顾客来买快乐水，搞了这么一个活动：「$5$ 个瓶盖换一瓶快乐水」。于是，人们纷纷来他的店里买快乐水。\n\n买完快乐水，他想到了一个问题：\n\n如果一瓶快乐水有 $m$ 个附属品，对于第 $i$ 个附属品，每 $a_i$ 个可以换一瓶全新的快乐水，现在我有买 $n$ 瓶快乐水的钱，我最多能喝多少快乐水呢？", "inputFormat": "第一行两个整数 $n,m$，意义如上。\n\n接下来一行 $m$ 个整数 $a_1,a_2,\\cdots,a_m$，意义如上。", "outputFormat": "如果小 W 可以无限白嫖快乐水，那么输出一行一个字符串 `Inf`。\n\n否则，输出一行一个整数 $s$，表示小 W 最多能喝的快乐水数量。", "hint": "样例一解释：\n\n| 步数 | 已喝 | 未喝 | 附属品一 | 附属品二 |\n| ---- | ---- | ---- | -------- | -------- |\n| 1    | 0    | 5    | 0        | 0        |\n| 2    | 5    | 0    | 5        | 5        |\n| 3    | 5    | 3    | 1        | 1        |\n| 4    | 8    | 0    | 4        | 4        |\n| 5    | 8    | 3    | 0        | 0        |\n| 6    | 11   | 0    | 3        | 3        |\n| 7    | 11   | 1    | 1        | 3        |\n| 8    | 12   | 0    | 2        | 4        |\n| 9    | 12   | 2    | 0        | 0        |\n| 10   | 14   | 0    | 2        | 2        |\n| 11   | 14   | 1    | 0        | 2        |\n| 12   | 15   | 0    | 1        | 3        |\n\n样例二解释：\n\n| 步数 | 已喝     | 未喝     | 附属品一 | 附属品二 |\n| ---- | -------- | -------- | -------- | -------- |\n| 1    | 0        | 2        | 0        | 0        |\n| 2    | 2        | 0        | 2        | 2        |\n| 3    | 2        | 2        | 0        | 0        |\n| 4    | 4        | 0        | 2        | 2        |\n| 5    | 4        | 2        | 0        | 0        |\n| 6    | 6        | 0        | 2        | 2        |\n| 7    | 6        | 2        | 0        | 0        |\n| 8    | 8        | 0        | 2        | 2        |\n| 9    | $\\vdots$ | $\\vdots$ | $\\vdots$ | $\\vdots$ |\n\n很显然小 W 可以像这样无限白嫖快乐水。\n\n**注意：本题中，我们认为无法借还/赊账。**\n********\n数据范围：  \n\n测试点一与样例二相同。\n\n对于其中 $30\\%$ 的数据，$n\\le 100$，$m\\le 2$。\n\n对于 $100\\%$ 的数据，$1\\le n\\le 10^4$，$1\\le m\\le 5$，$1\\le a_i\\le 2\\times10^3$。", "locale": "zh-CN"}}}
{"pid": "P6023", "type": "P", "difficulty": 3, "samples": [["5 1 3\n1 0\n1 2\n1 4\n", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2020"], "title": "走路", "background": "小 W 下载了一款运动软件。", "description": "小 W 准备在接下来的 $m$ 天中锻炼，由于他不能走得太多以至于累死（怎么可能呢），所以他这 $m$ 天最多一共只能走 $n$ 步。  \n这个运动软件为了激励小 W 走路，推出了 $k$ 种激励措施，每种激励措施都形如“如果你第 $p$ 天中走完了 $q$ 步，那么第 $p$ 天中接下来的每一步都会给你加 $1$ 积分”。**激励措施可以叠加，即走一步你可能可以获得多于 $1$ 积分。**  \n现在小 W 想知道，他总计最多可以获取多少积分呢？", "inputFormat": "第一行三个整数 $n,m,k$，意义如上。  \n接下来 $k$ 行，每行两个整数 $p,q$，表示一个激励措施，意义如上。", "outputFormat": "一行 $1$ 个整数，表示 $m$ 天后最多可以获得的积分。", "hint": "样例解释：  \n只有一种方案，即在第一天走 $5$ 步，第一、二步各获得 $1$ 积分，第三、四步各获得 $2$ 积分，第五步获得 $3$ 积分，总计 $9$ 积分。  \n********\n数据范围：  \n对于 $10\\%$ 的数据，$n,m,k\\le10$。  \n对于 $40\\%$ 的数据，$n,m,k \\le 10^3$。  \n对于 $100\\%$ 的数据，$1\\le n\\le 10^{12}$，$1\\le m,k\\le 10^5$，$1\\le p\\le m$，$0\\le q\\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "Walking", "background": "Xiao W downloaded a fitness app.", "description": "Xiao W plans to work out over the next $m$ days. Since he cannot walk too much and get exhausted (how could that happen), over these $m$ days he can walk at most $n$ steps in total.  \nTo encourage Xiao W to walk, the app provides $k$ incentive rules. Each rule is of the form: “If on day $p$ you finish walking $q$ steps, then on day $p$ every subsequent step will give you an additional $1$ point.” **Incentive rules can stack, meaning that for one step you may gain more than $1$ point.**  \nNow Xiao W wants to know: what is the maximum total number of points he can get?", "inputFormat": "The first line contains three integers $n,m,k$, with meanings as above.  \nThe next $k$ lines each contain two integers $p,q$, describing an incentive rule as above.", "outputFormat": "Output one integer, the maximum points that can be obtained after $m$ days.", "hint": "Explanation for the sample:  \nThere is only one plan: walk $5$ steps on the first day. The first and second steps each gain $1$ point, the third and fourth steps each gain $2$ points, and the fifth step gains $3$ points, for a total of $9$ points.\n\nConstraints:  \nFor $10\\%$ of the testdata, $n,m,k \\le 10$.  \nFor $40\\%$ of the testdata, $n,m,k \\le 10^3$.  \nFor $100\\%$ of the testdata, $1 \\le n \\le 10^{12}$, $1 \\le m,k \\le 10^5$, $1 \\le p \\le m$, $0 \\le q \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "走路", "background": "小 W 下载了一款运动软件。", "description": "小 W 准备在接下来的 $m$ 天中锻炼，由于他不能走得太多以至于累死（怎么可能呢），所以他这 $m$ 天最多一共只能走 $n$ 步。  \n这个运动软件为了激励小 W 走路，推出了 $k$ 种激励措施，每种激励措施都形如“如果你第 $p$ 天中走完了 $q$ 步，那么第 $p$ 天中接下来的每一步都会给你加 $1$ 积分”。**激励措施可以叠加，即走一步你可能可以获得多于 $1$ 积分。**  \n现在小 W 想知道，他总计最多可以获取多少积分呢？", "inputFormat": "第一行三个整数 $n,m,k$，意义如上。  \n接下来 $k$ 行，每行两个整数 $p,q$，表示一个激励措施，意义如上。", "outputFormat": "一行 $1$ 个整数，表示 $m$ 天后最多可以获得的积分。", "hint": "样例解释：  \n只有一种方案，即在第一天走 $5$ 步，第一、二步各获得 $1$ 积分，第三、四步各获得 $2$ 积分，第五步获得 $3$ 积分，总计 $9$ 积分。  \n********\n数据范围：  \n对于 $10\\%$ 的数据，$n,m,k\\le10$。  \n对于 $40\\%$ 的数据，$n,m,k \\le 10^3$。  \n对于 $100\\%$ 的数据，$1\\le n\\le 10^{12}$，$1\\le m,k\\le 10^5$，$1\\le p\\le m$，$0\\le q\\le n$。", "locale": "zh-CN"}}}
{"pid": "P6024", "type": "P", "difficulty": 5, "samples": [["2\n999 1\n5000 10000\n", "1 2"], ["1\n1\n0\n", "Impossible"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "Special Judge"], "title": "机器人", "background": "小 W 购买了一个机器人。", "description": "现在，小 W 希望机器人去帮他完成 $n$ 个任务。\n\n每个任务有两种属性：完成需要花的钱 $w_i$，成功率 $p_i$。\n\n小 W 需要将任务按一定顺序排序，随后，机器人会按如下方式做任务：\n\n- 从第一个任务开始做；\n- 花费代价做完第 $i$ 个任务后，如果成功，则继续做第 $i+1$ 个任务，否则重新从第一个任务开始做；\n- 成功做完第 $n$ 个任务后，流程结束。\n\n例如，当 $n=2$ 时，一个可能的流程为：\n- 做任务 $1$，失败；\n- 做任务 $1$，成功；\n- 做任务 $2$，失败；\n- 做任务 $1$，成功；\n- 做任务 $2$，成功；\n- 流程结束，总花费为 $3w_1+2w_2$。\n\n现在，小 W 希望学 OI 的你帮他找到一种排列顺序，使得他的期望花费最小。", "inputFormat": "第一行一个整数 $n$，表示任务的数量。\n\n接下来一行 $n$ 个整数 $w_1,w_2,\\cdots,w_n$，意义如上。\n\n接下来一行 $n$ 个整数 $P_1,P_2,\\cdots,P_n$，其中 $P_i=p_i\\times10^4$，\n$p_i$ 的意义如上。", "outputFormat": "如果无论如何也不可能完成任务，那么输出一行一个字符串`Impossible`。\n\n否则，输出一行 $n$ 个整数 $c_1,c_2,\\cdots,c_n$，其为 $1,2,\\cdots,n$ 的一个排列，表示任务的安排顺序，安排的第 $i$ 件任务是输入中的第 $c_i$  件任务。", "hint": "样例一解释：可以感性理解。既然任务 $2$ 一定成功，那放到最后做肯定不劣。\n\n样例二解释：显然这个任务不可能完成，它的成功率为 $0$。\n\n**注意：无论任务是否成功，总是要花费 $w_i$ 的代价去做。**\n********\n本题带有 $\\text{SPJ}$。如果你的输出与答案的输出一样优（或者都是`Impossible`），那么你将在这个测试点获得满分，否则你将在这个测试点不获得任何分数。\n\n由于某种原因，本题不提供 $\\text{SPJ}$ 给选手。\n********\n数据范围：  \n对于 $10\\%$ 的数据，$1\\le n\\le 10$。  \n对于另外 $20\\%$ 的数据，所有 $w_i$ 相等。  \n对于另外 $20\\%$ 的数据，所有 $p_i$ 相等。  \n对于所有数据，$1\\le n\\le 2\\times10^5$，$1\\le w_i\\le 10^9$，$0\\le P_i\\le10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "机器人", "background": "小 W 购买了一个机器人。", "description": "现在，小 W 希望机器人去帮他完成 $n$ 个任务。\n\n每个任务有两种属性：完成需要花的钱 $w_i$，成功率 $p_i$。\n\n小 W 需要将任务按一定顺序排序，随后，机器人会按如下方式做任务：\n\n- 从第一个任务开始做；\n- 花费代价做完第 $i$ 个任务后，如果成功，则继续做第 $i+1$ 个任务，否则重新从第一个任务开始做；\n- 成功做完第 $n$ 个任务后，流程结束。\n\n例如，当 $n=2$ 时，一个可能的流程为：\n- 做任务 $1$，失败；\n- 做任务 $1$，成功；\n- 做任务 $2$，失败；\n- 做任务 $1$，成功；\n- 做任务 $2$，成功；\n- 流程结束，总花费为 $3w_1+2w_2$。\n\n现在，小 W 希望学 OI 的你帮他找到一种排列顺序，使得他的期望花费最小。", "inputFormat": "第一行一个整数 $n$，表示任务的数量。\n\n接下来一行 $n$ 个整数 $w_1,w_2,\\cdots,w_n$，意义如上。\n\n接下来一行 $n$ 个整数 $P_1,P_2,\\cdots,P_n$，其中 $P_i=p_i\\times10^4$，\n$p_i$ 的意义如上。", "outputFormat": "如果无论如何也不可能完成任务，那么输出一行一个字符串`Impossible`。\n\n否则，输出一行 $n$ 个整数 $c_1,c_2,\\cdots,c_n$，其为 $1,2,\\cdots,n$ 的一个排列，表示任务的安排顺序，安排的第 $i$ 件任务是输入中的第 $c_i$  件任务。", "hint": "样例一解释：可以感性理解。既然任务 $2$ 一定成功，那放到最后做肯定不劣。\n\n样例二解释：显然这个任务不可能完成，它的成功率为 $0$。\n\n**注意：无论任务是否成功，总是要花费 $w_i$ 的代价去做。**\n********\n本题带有 $\\text{SPJ}$。如果你的输出与答案的输出一样优（或者都是`Impossible`），那么你将在这个测试点获得满分，否则你将在这个测试点不获得任何分数。\n\n由于某种原因，本题不提供 $\\text{SPJ}$ 给选手。\n********\n数据范围：  \n对于 $10\\%$ 的数据，$1\\le n\\le 10$。  \n对于另外 $20\\%$ 的数据，所有 $w_i$ 相等。  \n对于另外 $20\\%$ 的数据，所有 $p_i$ 相等。  \n对于所有数据，$1\\le n\\le 2\\times10^5$，$1\\le w_i\\le 10^9$，$0\\le P_i\\le10^4$。", "locale": "zh-CN"}}}
{"pid": "P6025", "type": "P", "difficulty": 5, "samples": [["6 6\n", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2020"], "title": "线段树", "background": "小 W 学习了一种叫做线段树的数据结构。", "description": "很快，小 W 就发现：线段树实在是太浪费空间了！\n\n比如，一棵 $n=6$ 的线段树长下面这样：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/laie1is5.png)\n\n可以发现，只有 $11$ 个节点存储了有用信息，但使用的数组下标到了 $13$。\n\n令 $f(n)$ 表示一棵 $n$ 个叶子节点的线段树所占的最大数组下标，现在小 W 想让你求出：\n$$f(l)\\;\\oplus\\;f(l+1)\\;\\oplus\\;f(l+2)\\;\\oplus\\cdots \\oplus\\;f(r)$$\n其中，$\\oplus$ 表示异或运算，相当于 C++ 中的`^`符号。", "inputFormat": "一行两个整数，表示 $l,r$，意义如上。", "outputFormat": "一行一个整数，表示结果。", "hint": "## 样例解释\n$f(6)=13$，故答案为 $13$。\n## 提示\n如果你不知道什么是线段树：\n```cpp\nvoid build(int k,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\t//do something\n\t\t//e.g. tree[k]=a[l]\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(k<<1,l,mid);\n\tbuild(k<<1|1,mid+1,r);\n\t//do something\n\t//e.g. tree[k]=tree[k<<1]+tree[k<<1|1]\n}\n```\n翻译成人话就是：编号为 $k$ 节点有一个线段 $[l,r]$，如果 $l\\neq r$，那么令 $mid=\\lfloor\\dfrac{l+r}2\\rfloor$，它有两个子节点，左儿子编号为 $2k$，线段为 $[l,mid]$；右儿子编号为 $2k+1$，线段为 $[mid+1,r]$，然后在子节点上递归建树。\n\n调用`build(1,1,n)`后就建好了一棵线段树，即编号为 $1$ 的结点的线段为 $[1,n]$。\n## 数据范围  \n对于 $10\\%$ 的数据，$1\\le l\\le r\\le10^3$。  \n对于 $40\\%$ 的数据，$1\\le l\\le r\\le 10^6$。  \n对于 $100\\%$ 的数据，$1\\le l\\le r\\le10^{15}$，答案在`long long`范围内。  ", "locale": "zh-CN", "translations": {"en": {"title": "Segment Tree", "background": "Little W learned a data structure called the segment tree.", "description": "Soon, Little W discovered that segment trees waste far too much space.\n\nFor example, a segment tree with $n=6$ looks like this:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/laie1is5.png)\n\nYou can see that only $11$ nodes store useful information, but the array indices used go up to $13$.\n\nLet $f(n)$ be the maximum array index occupied by a segment tree with $n$ leaf nodes. Now Little W wants you to compute:\n$$f(l)\\;\\oplus\\;f(l+1)\\;\\oplus\\;f(l+2)\\;\\oplus\\cdots \\oplus\\;f(r)$$\nHere, $\\oplus$ denotes the bitwise XOR operation, which is the `^` operator in C++.", "inputFormat": "One line with two integers $l, r$, with the meaning described above.", "outputFormat": "One line with one integer, the result.", "hint": "# Sample Explanation\n\n$f(6)=13$, so the answer is $13$.\n\n# Hint\n\nIf you do not know what a segment tree is:\n```cpp\nvoid build(int k,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\t//do something\n\t\t//e.g. tree[k]=a[l]\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(k<<1,l,mid);\n\tbuild(k<<1|1,mid+1,r);\n\t//do something\n\t//e.g. tree[k]=tree[k<<1]+tree[k<<1|1]\n}\n```\nIn plain words: node $k$ corresponds to a segment $[l,r]$. If $l\\neq r$, let $mid=\\lfloor\\dfrac{l+r}2\\rfloor$. It has two children: the left child has index $2k$ and segment $[l,mid]$; the right child has index $2k+1$ and segment $[mid+1,r]$. Then build the tree recursively on the child nodes.\n\nAfter calling `build(1,1,n)`, the segment tree is built. That is, node $1$ corresponds to segment $[1,n]$.\n\n## Constraints  \nFor $10\\%$ of the testdata, $1\\le l\\le r\\le10^3$.  \nFor $40\\%$ of the testdata, $1\\le l\\le r\\le 10^6$.  \nFor $100\\%$ of the testdata, $1\\le l\\le r\\le10^{15}$, and the answer fits in `long long`.\n\n# Input Format\n\nOne line with two integers $l, r$, with the meaning described above.\n\n# Output Format\n\nOne line with one integer, the result.\n\n# Hint\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "线段树", "background": "小 W 学习了一种叫做线段树的数据结构。", "description": "很快，小 W 就发现：线段树实在是太浪费空间了！\n\n比如，一棵 $n=6$ 的线段树长下面这样：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/laie1is5.png)\n\n可以发现，只有 $11$ 个节点存储了有用信息，但使用的数组下标到了 $13$。\n\n令 $f(n)$ 表示一棵 $n$ 个叶子节点的线段树所占的最大数组下标，现在小 W 想让你求出：\n$$f(l)\\;\\oplus\\;f(l+1)\\;\\oplus\\;f(l+2)\\;\\oplus\\cdots \\oplus\\;f(r)$$\n其中，$\\oplus$ 表示异或运算，相当于 C++ 中的`^`符号。", "inputFormat": "一行两个整数，表示 $l,r$，意义如上。", "outputFormat": "一行一个整数，表示结果。", "hint": "## 样例解释\n$f(6)=13$，故答案为 $13$。\n## 提示\n如果你不知道什么是线段树：\n```cpp\nvoid build(int k,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\t//do something\n\t\t//e.g. tree[k]=a[l]\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(k<<1,l,mid);\n\tbuild(k<<1|1,mid+1,r);\n\t//do something\n\t//e.g. tree[k]=tree[k<<1]+tree[k<<1|1]\n}\n```\n翻译成人话就是：编号为 $k$ 节点有一个线段 $[l,r]$，如果 $l\\neq r$，那么令 $mid=\\lfloor\\dfrac{l+r}2\\rfloor$，它有两个子节点，左儿子编号为 $2k$，线段为 $[l,mid]$；右儿子编号为 $2k+1$，线段为 $[mid+1,r]$，然后在子节点上递归建树。\n\n调用`build(1,1,n)`后就建好了一棵线段树，即编号为 $1$ 的结点的线段为 $[1,n]$。\n## 数据范围  \n对于 $10\\%$ 的数据，$1\\le l\\le r\\le10^3$。  \n对于 $40\\%$ 的数据，$1\\le l\\le r\\le 10^6$。  \n对于 $100\\%$ 的数据，$1\\le l\\le r\\le10^{15}$，答案在`long long`范围内。  ", "locale": "zh-CN"}}}
{"pid": "P6026", "type": "P", "difficulty": 5, "samples": [["10 1\n", "1"], ["2 2\n", "250000002"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2020", "组合数学"], "title": "餐馆", "background": "小 W 家新开了一家餐馆。", "description": "这家餐馆提供 $n$ 种特色菜，它们被标号为 $1,2,\\cdots,n$。\n\n有一天，餐馆里来了 $k$ 个客人，他们没有想好要吃什么。于是，小 W 给他们出了个主意：每个人先从 $1,2,\\cdots,n$ 中等概率随机一个数 $r$，再从\n $1,2,\\cdots,r$ 中等概率随机一个数 $l$，这个人就点标号在 $l$ 和 $r$ 之间（包括 $l$ 和 $r$）的菜。\n\n于是，客人们按小 W 说的做了。在所有客人都点完单之后，小 W 突然发现：没有两个人都点了相同的一道菜，他每种菜至多做一份就够了！为了证明他是多么的欧皇，他找到了学编程的你，请你帮他计算这种情况发生的概率。", "inputFormat": "两个整数 $n$ 和 $k$，意义如题目描述。", "outputFormat": "一个整数 $p$，表示所求概率对 $10^9+7$ 取模后的结果。", "hint": "样例解释：  \n样例 $1$ 解释：因为只有一位客人，所以无论如何不会有两个人点同样的菜，故所求概率为 $1$。\n\n样例 $2$ 解释：每位客人只点 $1$ 号菜的概率为 $\\dfrac12$，只点 $2$ 号菜的概率为 $\\dfrac14$，两个菜都点的概率为 $\\dfrac14$，两人不点同一道菜即一人只点 $1$ 号菜，一人只点 $2$ 号菜，概率为\n $\\dfrac14\\times\\dfrac12+\\dfrac12\\times\\dfrac14=\\dfrac14$，模 $10^9+7$ 意义下为\n $250000002$。\n*********\n\n提示：如果你不知道如何对有理数取余，请看 [P2613](https://www.luogu.com.cn/problem/P2613)。\n\n********\n数据范围：  \n对于 $10\\%$ 的数据， $k=1$。  \n对于另外 $10\\%$ 的数据， $1\\le k\\le n\\le5$。  \n对于另外 $20\\%$ 的数据， $1\\le k\\le3$。  \n对于另外 $30\\%$ 的数据， $1\\le k\\le n\\le10^3$。  \n对于所有数据， $1\\le k\\le n\\le 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "Restaurant", "background": "Xiao W’s family has just opened a new restaurant.", "description": "The restaurant offers $n$ signature dishes, numbered $1,2,\\cdots,n$.\n\nOne day, $k$ customers came to the restaurant, and they had not decided what to eat. So Xiao W gave them an idea: each person first randomly chooses a number $r$ from $1,2,\\cdots,n$ with equal probability, then randomly chooses a number $l$ from $1,2,\\cdots,r$ with equal probability. This person then orders all dishes with numbers between $l$ and $r$ (including $l$ and $r$).\n\nSo the customers did as Xiao W said. After all customers finished ordering, Xiao W suddenly realized: no two people ordered the same dish, so he only needs to cook at most one portion of each dish. To prove how lucky he is, he found you, who studies programming, and asks you to help compute the probability that this situation happens.", "inputFormat": "Two integers $n$ and $k$, as described in the statement.", "outputFormat": "Output one integer $p$, which is the required probability modulo $10^9+7$.", "hint": "Explanation of the samples:  \nSample $1$: Because there is only one customer, no matter what happens, there cannot be two people ordering the same dish. Therefore, the required probability is $1$.\n\nSample $2$: For each customer, the probability of ordering only dish $1$ is $\\dfrac12$, the probability of ordering only dish $2$ is $\\dfrac14$, and the probability of ordering both dishes is $\\dfrac14$. For the two people to not order any common dish, one must order only dish $1$ and the other must order only dish $2$. The probability is $\\dfrac14\\times\\dfrac12+\\dfrac12\\times\\dfrac14=\\dfrac14$, which modulo $10^9+7$ is $250000002$.\n\n*********\n\nHint: If you do not know how to take a rational number modulo, please see [P2613](https://www.luogu.com.cn/problem/P2613).\n\n********\n\nConstraints:  \nFor $10\\%$ of the testdata, $k=1$.  \nFor another $10\\%$ of the testdata, $1\\le k\\le n\\le5$.  \nFor another $20\\%$ of the testdata, $1\\le k\\le3$.  \nFor another $30\\%$ of the testdata, $1\\le k\\le n\\le10^3$.  \nFor all testdata, $1\\le k\\le n\\le 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "餐馆", "background": "小 W 家新开了一家餐馆。", "description": "这家餐馆提供 $n$ 种特色菜，它们被标号为 $1,2,\\cdots,n$。\n\n有一天，餐馆里来了 $k$ 个客人，他们没有想好要吃什么。于是，小 W 给他们出了个主意：每个人先从 $1,2,\\cdots,n$ 中等概率随机一个数 $r$，再从\n $1,2,\\cdots,r$ 中等概率随机一个数 $l$，这个人就点标号在 $l$ 和 $r$ 之间（包括 $l$ 和 $r$）的菜。\n\n于是，客人们按小 W 说的做了。在所有客人都点完单之后，小 W 突然发现：没有两个人都点了相同的一道菜，他每种菜至多做一份就够了！为了证明他是多么的欧皇，他找到了学编程的你，请你帮他计算这种情况发生的概率。", "inputFormat": "两个整数 $n$ 和 $k$，意义如题目描述。", "outputFormat": "一个整数 $p$，表示所求概率对 $10^9+7$ 取模后的结果。", "hint": "样例解释：  \n样例 $1$ 解释：因为只有一位客人，所以无论如何不会有两个人点同样的菜，故所求概率为 $1$。\n\n样例 $2$ 解释：每位客人只点 $1$ 号菜的概率为 $\\dfrac12$，只点 $2$ 号菜的概率为 $\\dfrac14$，两个菜都点的概率为 $\\dfrac14$，两人不点同一道菜即一人只点 $1$ 号菜，一人只点 $2$ 号菜，概率为\n $\\dfrac14\\times\\dfrac12+\\dfrac12\\times\\dfrac14=\\dfrac14$，模 $10^9+7$ 意义下为\n $250000002$。\n*********\n\n提示：如果你不知道如何对有理数取余，请看 [P2613](https://www.luogu.com.cn/problem/P2613)。\n\n********\n数据范围：  \n对于 $10\\%$ 的数据， $k=1$。  \n对于另外 $10\\%$ 的数据， $1\\le k\\le n\\le5$。  \n对于另外 $20\\%$ 的数据， $1\\le k\\le3$。  \n对于另外 $30\\%$ 的数据， $1\\le k\\le n\\le10^3$。  \n对于所有数据， $1\\le k\\le n\\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P6027", "type": "P", "difficulty": 6, "samples": [["2\n1.000000 1.000000\n2.000000 2.000000\n4.000000 4.000000\n3.000000 3.000000\n", "1\n1.000000 1.000000 -5.000000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2020", "Special Judge"], "title": "轴对称", "background": "小 W 学习了轴对称变换。", "description": "小 W 觉得轴对称变换实在太好玩了，于是在平面上随机点了 $n$ 个点 $A_1,A_2,\\cdots,A_n$，然后进行了一系列轴对称变换，得到了 $B_1,B_2,\\cdots,B_n$ 这 $n$ 个点，其中 $A_1$ 得到 $B_1$，以此类推。\n\n可是他突然忘记自己是怎么变换到的了，所以他请你帮他找到一组步数尽量少的合法的变换。", "inputFormat": "第一行一个整数 $n$，表示点的个数。\n\n接下来 $n$ 行，第 $i+1$ 行两个实数 $x,y$，表示 $A_i$ 的横、纵坐标。\n\n接下来 $n$ 行，第 $i+n+1$ 行两个实数 $x,y$，表示 $B_i$ 的横、纵坐标。", "outputFormat": "第一行一个整数 $k$ ，表示最少的步数。\n\n接下来 $k$ 行，第 $i+1$ 行三个实数 $A,B,C$，表示第 $i$ 次轴对称变换的轴为直线 $Ax+By+C=0$。", "hint": "## 样例解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/8msdygxi.png)\n## 提示\n对于直线 $Ax+By+C=0$，如果 $B$ 非零，那么它就是一次函数 $y=-\\dfrac ABx-\\dfrac CB$ 的图像；否则，它表示一条垂直于 $x$ 轴的直线 $x=-\\dfrac CA$。\n\n本题带有 $\\text{SPJ}$。**因为某种原因，本题不提供** $\\text{SPJ}$ **给选手。**\n\n对于每个测试点，如果你的 $k$ 正确，则获得 $30\\%$ 的分数；\n\n接下来，我们将对 $A_1,A_2,\\cdots,A_n$ 分别进行你给的 $k$ 次轴对称变换，记 $A_i$ 得到的点为 $C_i$。如果对于所有的 $i$，$B_i$ 与 $C_i$ 的 $x,y$ 坐标之差的绝对值都不超过 $10^{-2}$，则你获得 $100\\%$ 的分数。\n\n如果你只想输出 $k$，也请在后面随意输出一些值，防止 $\\text{UKE}$。\n## 数据范围\n\n| 测试点编号 | $n=$ | 构造数据时翻折的次数 |\n| ---------- | ---- | -------------------- |\n| 1,2        | $1$  | $\\le1$               |\n| 3,4        | $2$  | $\\le10$              |\n| 5,6        | $5$  | $\\le10^3$            |\n| 7,8,9,10   | $10$ | $\\le10^5$            |\n\n对于所有数据，$1\\le n\\le10$，$|x|,|y|\\le 10^5$。\n\n所有数据点已经经过 $\\text{SPJ}$ 验证无误。 \n\n请保证你的输出中的所有 $A,B,C$ 满足 $|A|,|B|,|C|\\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Axial Symmetry", "background": "Little W learned axial symmetry transformations.", "description": "Little W thinks axial symmetry transformations are really fun, so he randomly picked $n$ points $A_1,A_2,\\cdots,A_n$ on the plane, and then performed a series of axial symmetry transformations to obtain $n$ points $B_1,B_2,\\cdots,B_n$, where $A_1$ becomes $B_1$, and so on.\n\nHowever, he suddenly forgot how he transformed them, so he asks you to help him find a valid sequence of transformations with as few steps as possible.", "inputFormat": "The first line contains an integer $n$, the number of points.\n\nThe next $n$ lines, line $i+1$ contains two real numbers $x,y$, representing the $x$- and $y$-coordinates of $A_i$.\n\nThe next $n$ lines, line $i+n+1$ contains two real numbers $x,y$, representing the $x$- and $y$-coordinates of $B_i$.", "outputFormat": "The first line contains an integer $k$, the minimum number of steps.\n\nThe next $k$ lines, line $i+1$ contains three real numbers $A,B,C$, indicating that the axis of the $i$-th axial symmetry transformation is the line $Ax+By+C=0$.", "hint": "## Sample Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8msdygxi.png)\n\n## Hint\n\nFor the line $Ax+By+C=0$, if $B$ is non-zero, then it is the graph of the linear function $y=-\\dfrac ABx-\\dfrac CB$; otherwise, it represents a line perpendicular to the $x$-axis, namely $x=-\\dfrac CA$.\n\nThis problem uses an $\\text{SPJ}$. **For some reason, this problem does not provide** the $\\text{SPJ}$ **to contestants.**\n\nFor each test case, if your $k$ is correct, you will get $30\\%$ of the score.\n\nNext, we will apply your $k$ axial symmetry transformations to $A_1,A_2,\\cdots,A_n$ respectively, and let the resulting point of $A_i$ be $C_i$. If for all $i$, the absolute differences between the $x,y$ coordinates of $B_i$ and $C_i$ are both no more than $10^{-2}$, then you will get $100\\%$ of the score.\n\nIf you only want to output $k$, please also output some arbitrary values afterwards to avoid $\\text{UKE}$.\n\n## Constraints\n\n| Test Point ID | $n=$ | Number of folds used when constructing the testdata |\n| ---------- | ---- | -------------------- |\n| 1,2        | $1$  | $\\le1$               |\n| 3,4        | $2$  | $\\le10$              |\n| 5,6        | $5$  | $\\le10^3$            |\n| 7,8,9,10   | $10$ | $\\le10^5$            |\n\nFor all data, $1\\le n\\le10$, $|x|,|y|\\le 10^5$.\n\nAll data points have been verified by the $\\text{SPJ}$ and are correct.\n\nPlease ensure that all $A,B,C$ in your output satisfy $|A|,|B|,|C|\\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "轴对称", "background": "小 W 学习了轴对称变换。", "description": "小 W 觉得轴对称变换实在太好玩了，于是在平面上随机点了 $n$ 个点 $A_1,A_2,\\cdots,A_n$，然后进行了一系列轴对称变换，得到了 $B_1,B_2,\\cdots,B_n$ 这 $n$ 个点，其中 $A_1$ 得到 $B_1$，以此类推。\n\n可是他突然忘记自己是怎么变换到的了，所以他请你帮他找到一组步数尽量少的合法的变换。", "inputFormat": "第一行一个整数 $n$，表示点的个数。\n\n接下来 $n$ 行，第 $i+1$ 行两个实数 $x,y$，表示 $A_i$ 的横、纵坐标。\n\n接下来 $n$ 行，第 $i+n+1$ 行两个实数 $x,y$，表示 $B_i$ 的横、纵坐标。", "outputFormat": "第一行一个整数 $k$ ，表示最少的步数。\n\n接下来 $k$ 行，第 $i+1$ 行三个实数 $A,B,C$，表示第 $i$ 次轴对称变换的轴为直线 $Ax+By+C=0$。", "hint": "## 样例解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/8msdygxi.png)\n## 提示\n对于直线 $Ax+By+C=0$，如果 $B$ 非零，那么它就是一次函数 $y=-\\dfrac ABx-\\dfrac CB$ 的图像；否则，它表示一条垂直于 $x$ 轴的直线 $x=-\\dfrac CA$。\n\n本题带有 $\\text{SPJ}$。**因为某种原因，本题不提供** $\\text{SPJ}$ **给选手。**\n\n对于每个测试点，如果你的 $k$ 正确，则获得 $30\\%$ 的分数；\n\n接下来，我们将对 $A_1,A_2,\\cdots,A_n$ 分别进行你给的 $k$ 次轴对称变换，记 $A_i$ 得到的点为 $C_i$。如果对于所有的 $i$，$B_i$ 与 $C_i$ 的 $x,y$ 坐标之差的绝对值都不超过 $10^{-2}$，则你获得 $100\\%$ 的分数。\n\n如果你只想输出 $k$，也请在后面随意输出一些值，防止 $\\text{UKE}$。\n## 数据范围\n\n| 测试点编号 | $n=$ | 构造数据时翻折的次数 |\n| ---------- | ---- | -------------------- |\n| 1,2        | $1$  | $\\le1$               |\n| 3,4        | $2$  | $\\le10$              |\n| 5,6        | $5$  | $\\le10^3$            |\n| 7,8,9,10   | $10$ | $\\le10^5$            |\n\n对于所有数据，$1\\le n\\le10$，$|x|,|y|\\le 10^5$。\n\n所有数据点已经经过 $\\text{SPJ}$ 验证无误。 \n\n请保证你的输出中的所有 $A,B,C$ 满足 $|A|,|B|,|C|\\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P6028", "type": "P", "difficulty": 5, "samples": [["2\n", "2.5000000000"], ["5", "6.7833333333"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["数学", "2020", "Special Judge", "O2优化", "调和级数", "整除分块"], "title": "算术", "background": "小 W 去上算术课了。", "description": "> 众所周知，高斯在小学的时候，有一天他的数学老师留了一道题：$1+2+\\cdots+100=?$，他认为学生们算 $100$ 个数相加要算很久，然后就准备溜去喝咖啡，但是这个时候高斯却举手说他算完了——他用了我们今天众所周知的等差数列求和公式。\n\n但是，这个算术课的老师就像高斯的老师一样不负责任，他在黑板上留了一道算术题就溜去泡妹子了。但小 W 可没高斯那么聪明，而且这个式子看起来没有巧算方法。于是，他通过电话联系上了学 $\\text{OI}$ 的你，希望你给他帮助。作为回报，他会给你 $100$ 分作为奖励。\n\n具体来讲，黑板上的式子是这样的：\n\n设 $n$ 的质因数分解结果为 $n=\\prod\\limits_{i=1}^kp_i^{\\alpha_i}$，则定义 $f(n)=\\prod\\limits_{i=1}^k{\\dfrac{p_i^{\\alpha_i+1}-1}{p_i^{\\alpha_i+1}-p_i^{\\alpha_i}}}$，求 $\\sum\\limits_{i=1}^nf(i)$ 的值（精度要求参见提示与说明）。\n\n**注意：特别地，我们定义** $f(1)=1$。", "inputFormat": "一行一个整数 $n$，意义如上。", "outputFormat": "一行一个实数表示结果。", "hint": "样例二解释：$f(1)=1,f(2)=\\dfrac{2^2-1}{2^2-2^1}=1.5,f(3)=\\dfrac{3^2-1}{3^2-3^1}=1.3333333333,f(4)=\\dfrac{2^3-1}{2^3-2^2}=1.75,f(5)=\\dfrac{5^2-1}{5^2-5^1}=1.2$。\n********\n本题带有 $\\text{SPJ}$。设你的答案为 $a$，标准答案为 $b$。  \n如果 $ |{a-b}|\\le \\min(\\dfrac b{10^4},10) $，则获得这个测试点的所有分数；  \n否则，如果$|{a-b}|\\le \\min(\\dfrac b{10^3},100)$，则获得这个测试点的分数的 $40\\%$；  \n否则，你将不会获得任何分数。  \n标准答案将会保留 10 位小数。  \n**注意：虽然此题对精度要求较低，但仍建议用更为精确的`long double`存储答案。**\n********\n数据范围：  \n对于 $10\\%$ 的数据，$n\\le10$。  \n对于 $30\\%$ 的数据，$n\\le10^3$。  \n对于 $60\\%$ 的数据，$n\\le10^7$。  \n对于 $100\\%$ 的数据，$1\\le n\\le10^{13}$。", "locale": "zh-CN", "translations": {"en": {"title": "Arithmetic", "background": "Little W went to an arithmetic class.", "description": "> As everyone knows, when Gauss was in elementary school, one day his math teacher gave a problem: $1+2+\\cdots+100=?$. He thought the students would take a long time to add $100$ numbers, so he planned to slip away for coffee. But at that moment, Gauss raised his hand and said he was done—he used the arithmetic progression sum formula that we all know today.\n\nHowever, the arithmetic teacher in this class is just as irresponsible as Gauss’s teacher. After leaving an arithmetic problem on the blackboard, he ran off to flirt. But Little W is not as smart as Gauss, and this expression does not seem to have any clever trick. So he called you, who study $\\text{OI}$, hoping you can help him. In return, he will give you $100$ points as a reward.\n\nSpecifically, the expression on the blackboard is:\n\nLet the prime factorization of $n$ be $n=\\prod\\limits_{i=1}^kp_i^{\\alpha_i}$. Define $f(n)=\\prod\\limits_{i=1}^k{\\dfrac{p_i^{\\alpha_i+1}-1}{p_i^{\\alpha_i+1}-p_i^{\\alpha_i}}}$. Find the value of $\\sum\\limits_{i=1}^nf(i)$ (see the Hint and Notes for precision requirements).\n\n**Note: In particular, we define** $f(1)=1$.", "inputFormat": "One line with an integer $n$, as described above.", "outputFormat": "One line with a real number representing the result.", "hint": "Explanation of Sample 2: $f(1)=1,f(2)=\\dfrac{2^2-1}{2^2-2^1}=1.5,f(3)=\\dfrac{3^2-1}{3^2-3^1}=1.3333333333,f(4)=\\dfrac{2^3-1}{2^3-2^2}=1.75,f(5)=\\dfrac{5^2-1}{5^2-5^1}=1.2$.\n********\nThis problem uses $\\text{SPJ}$. Let your answer be $a$, and the standard answer be $b$.  \nIf $ |{a-b}|\\le \\min(\\dfrac b{10^4},10) $, you will get full score for this test point;  \notherwise, if $|{a-b}|\\le \\min(\\dfrac b{10^3},100)$, you will get $40\\%$ of the score for this test point;  \notherwise, you will get no score.  \nThe standard answer will keep 10 digits after the decimal point.  \n**Note: Although the precision requirement is not strict, it is still recommended to use more accurate `long double` to store the answer.**\n********\nConstraints:  \nFor $10\\%$ of the testdata, $n\\le10$.  \nFor $30\\%$ of the testdata, $n\\le10^3$.  \nFor $60\\%$ of the testdata, $n\\le10^7$.  \nFor $100\\%$ of the testdata, $1\\le n\\le10^{13}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "算术", "background": "小 W 去上算术课了。", "description": "> 众所周知，高斯在小学的时候，有一天他的数学老师留了一道题：$1+2+\\cdots+100=?$，他认为学生们算 $100$ 个数相加要算很久，然后就准备溜去喝咖啡，但是这个时候高斯却举手说他算完了——他用了我们今天众所周知的等差数列求和公式。\n\n但是，这个算术课的老师就像高斯的老师一样不负责任，他在黑板上留了一道算术题就溜去泡妹子了。但小 W 可没高斯那么聪明，而且这个式子看起来没有巧算方法。于是，他通过电话联系上了学 $\\text{OI}$ 的你，希望你给他帮助。作为回报，他会给你 $100$ 分作为奖励。\n\n具体来讲，黑板上的式子是这样的：\n\n设 $n$ 的质因数分解结果为 $n=\\prod\\limits_{i=1}^kp_i^{\\alpha_i}$，则定义 $f(n)=\\prod\\limits_{i=1}^k{\\dfrac{p_i^{\\alpha_i+1}-1}{p_i^{\\alpha_i+1}-p_i^{\\alpha_i}}}$，求 $\\sum\\limits_{i=1}^nf(i)$ 的值（精度要求参见提示与说明）。\n\n**注意：特别地，我们定义** $f(1)=1$。", "inputFormat": "一行一个整数 $n$，意义如上。", "outputFormat": "一行一个实数表示结果。", "hint": "样例二解释：$f(1)=1,f(2)=\\dfrac{2^2-1}{2^2-2^1}=1.5,f(3)=\\dfrac{3^2-1}{3^2-3^1}=1.3333333333,f(4)=\\dfrac{2^3-1}{2^3-2^2}=1.75,f(5)=\\dfrac{5^2-1}{5^2-5^1}=1.2$。\n********\n本题带有 $\\text{SPJ}$。设你的答案为 $a$，标准答案为 $b$。  \n如果 $ |{a-b}|\\le \\min(\\dfrac b{10^4},10) $，则获得这个测试点的所有分数；  \n否则，如果$|{a-b}|\\le \\min(\\dfrac b{10^3},100)$，则获得这个测试点的分数的 $40\\%$；  \n否则，你将不会获得任何分数。  \n标准答案将会保留 10 位小数。  \n**注意：虽然此题对精度要求较低，但仍建议用更为精确的`long double`存储答案。**\n********\n数据范围：  \n对于 $10\\%$ 的数据，$n\\le10$。  \n对于 $30\\%$ 的数据，$n\\le10^3$。  \n对于 $60\\%$ 的数据，$n\\le10^7$。  \n对于 $100\\%$ 的数据，$1\\le n\\le10^{13}$。", "locale": "zh-CN"}}}
{"pid": "P6029", "type": "P", "difficulty": 7, "samples": [["5 5 2\n1 2 10\n2 5 10\n1 3 4\n3 4 2\n4 5 1", "3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2010", "各省省选", "江苏"], "title": "[JSOI2010] 旅行", "background": "", "description": "WJJ 喜欢旅游，这次她打算去一个据说有很多漂亮瀑布的山谷玩。\n\nWJJ 事先得到了一张地图，上面标注了 $N$ 个小动物的聚居地，也就是一个个的小村落。其中第 $1$ 个村庄是 WJJ 现在住的地方，第 $N$ 个村庄是 WJJ 打算去的地方。\n\n这些村庄之间有 $M$ 条双向道路连接着，第 $i$ 条双向道路恰好直接连接两个小村庄 $A_i$，$B_i$，长度为 $C_i$。道路有的是隧道，有的是栈桥，地图上那些看起来在村庄之外交叉的路实际上并不相交——也就是说，如果把这些小村落和双向道路构成的道路网看作图论意义上的图，我们不保证它是平面图，也不保证它没有重边。不过，有一点还是可以保证的：WJJ  细心地验证过，从它居住的村落一定能走到她想去的那个山谷。\n\n在 WJJ 所在的神奇世界中，每只小动物都可以借助仙人掌来施放魔法，其中之一是，交换世界中任意两条双向道路的长度，同时保持其他道路的长度不变。按 WJJ 目前的魔法水平，她最多能使用 $K$ 次这种道路长度交换魔法。可惜的是，由于仙人掌刺比较多，WJJ 并不打算带着它旅行，于是她会在家里完成想要的道路交换后再出门。\n\n假设 WJJ 的旅行途中不会有其他小动物进行道路交换来破坏她设计好的路线。为了尽快达到目的地，WJJ 希望她需要走的总距离越短越好。也就是说，使用最多 $K$ 次魔法后，从村落 $1$ 到村落 $N$ 的最短距离是多少？", "inputFormat": "第一行为 $3$ 个用空格隔开的整数 $N,M,K$。\n\n接下来 $M$ 行，每行 $3$ 个整数，用空格隔开，分别表示 $A_i,B_i,C_i$。", "outputFormat": "一个整数，表示使用最多 $K$ 次魔法后，村落 $1$ 和村落 $N$ 之间的最短距离。", "hint": "### 样例解释\n\n一个可行的方案是，对调第 $1$ 条边和第 $4$ 条边的长度，再对调第 $2$ 条边和第 $5$ 条边的长度。对调后的最短路径为 $1\\rightarrow 2\\rightarrow 5$，长度为 $3$。可以证明，没有比这更优的方案了。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 50$，$1\\leq M\\leq 150$，$1\\leq K\\leq 20$，$1\\leq A_i,B_i\\leq N$，$A_i\\neq B_i$，$1\\leq C_i\\leq 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2010] 旅行", "background": "", "description": "WJJ 喜欢旅游，这次她打算去一个据说有很多漂亮瀑布的山谷玩。\n\nWJJ 事先得到了一张地图，上面标注了 $N$ 个小动物的聚居地，也就是一个个的小村落。其中第 $1$ 个村庄是 WJJ 现在住的地方，第 $N$ 个村庄是 WJJ 打算去的地方。\n\n这些村庄之间有 $M$ 条双向道路连接着，第 $i$ 条双向道路恰好直接连接两个小村庄 $A_i$，$B_i$，长度为 $C_i$。道路有的是隧道，有的是栈桥，地图上那些看起来在村庄之外交叉的路实际上并不相交——也就是说，如果把这些小村落和双向道路构成的道路网看作图论意义上的图，我们不保证它是平面图，也不保证它没有重边。不过，有一点还是可以保证的：WJJ  细心地验证过，从它居住的村落一定能走到她想去的那个山谷。\n\n在 WJJ 所在的神奇世界中，每只小动物都可以借助仙人掌来施放魔法，其中之一是，交换世界中任意两条双向道路的长度，同时保持其他道路的长度不变。按 WJJ 目前的魔法水平，她最多能使用 $K$ 次这种道路长度交换魔法。可惜的是，由于仙人掌刺比较多，WJJ 并不打算带着它旅行，于是她会在家里完成想要的道路交换后再出门。\n\n假设 WJJ 的旅行途中不会有其他小动物进行道路交换来破坏她设计好的路线。为了尽快达到目的地，WJJ 希望她需要走的总距离越短越好。也就是说，使用最多 $K$ 次魔法后，从村落 $1$ 到村落 $N$ 的最短距离是多少？", "inputFormat": "第一行为 $3$ 个用空格隔开的整数 $N,M,K$。\n\n接下来 $M$ 行，每行 $3$ 个整数，用空格隔开，分别表示 $A_i,B_i,C_i$。", "outputFormat": "一个整数，表示使用最多 $K$ 次魔法后，村落 $1$ 和村落 $N$ 之间的最短距离。", "hint": "### 样例解释\n\n一个可行的方案是，对调第 $1$ 条边和第 $4$ 条边的长度，再对调第 $2$ 条边和第 $5$ 条边的长度。对调后的最短路径为 $1\\rightarrow 2\\rightarrow 5$，长度为 $3$。可以证明，没有比这更优的方案了。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 50$，$1\\leq M\\leq 150$，$1\\leq K\\leq 20$，$1\\leq A_i,B_i\\leq N$，$A_i\\neq B_i$，$1\\leq C_i\\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P6030", "type": "P", "difficulty": 6, "samples": [["6 6 1 6\n1 2\n1 3\n2 4\n3 5\n4 6\n5 6", "3.000"], ["9 12 1 9\n1 2\n2 3\n3 1\n3 4\n3 7\n4 5\n5 6\n6 4\n6 7\n7 8\n8 9\n9 7", "9.500"], ["2 0 1 2", "INF"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "各省省选", "山东", "拓扑排序", "Tarjan", "期望", "高斯消元"], "title": "[SDOI2012] 走迷宫", "background": null, "description": "Morenan 被困在了一个迷宫里。迷宫可以视为 $n$ 个点 $m$ 条边的有向图，其中 Morenan 处于起点 $s$，迷宫的终点设为 $t$。可惜的是，Morenan 非常的脑小，他只会从一个点出发随机沿着一条从该点出发的有向边，到达另一个点。这样，Morenan 走的步数可能很长，也可能是无限，更可能到不了终点。若到不了终点，则步数视为无穷大。但你必须想方设法求出 Morenan 所走步数的期望值。", "inputFormat": "第一行四个整数，$n,m,s,t$。\n\n接下来 $m$ 行，每行两个整数 $u, v$ ，表示有一条从 $u$ 到 $v$ 的边。", "outputFormat": "一个浮点数，保留小数点后 $3$ 位，为步数的期望值。若期望值为无穷大，则输出 `INF`。", "hint": "| 测试点 | $n\\leq$ | $m\\leq$ |\n| :----------: | :----------: | :----------: |\n| $1\\sim 6$ | $10$ | $100$ |\n| $7\\sim 12$ | $200$ | $10^4$ |\n| $13\\sim 20$ | $10^4$ | $10^6$ |\n\n另外，均匀分布着 $40\\%$ 的数据，图中没有环，也没有自环。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 10^4$，$0\\leq m \\leq 10^6$，**保证强连通分量的大小不超过** $\\boldsymbol{100}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[SDOI2012] 走迷宫", "background": null, "description": "Morenan 被困在了一个迷宫里。迷宫可以视为 $n$ 个点 $m$ 条边的有向图，其中 Morenan 处于起点 $s$，迷宫的终点设为 $t$。可惜的是，Morenan 非常的脑小，他只会从一个点出发随机沿着一条从该点出发的有向边，到达另一个点。这样，Morenan 走的步数可能很长，也可能是无限，更可能到不了终点。若到不了终点，则步数视为无穷大。但你必须想方设法求出 Morenan 所走步数的期望值。", "inputFormat": "第一行四个整数，$n,m,s,t$。\n\n接下来 $m$ 行，每行两个整数 $u, v$ ，表示有一条从 $u$ 到 $v$ 的边。", "outputFormat": "一个浮点数，保留小数点后 $3$ 位，为步数的期望值。若期望值为无穷大，则输出 `INF`。", "hint": "| 测试点 | $n\\leq$ | $m\\leq$ |\n| :----------: | :----------: | :----------: |\n| $1\\sim 6$ | $10$ | $100$ |\n| $7\\sim 12$ | $200$ | $10^4$ |\n| $13\\sim 20$ | $10^4$ | $10^6$ |\n\n另外，均匀分布着 $40\\%$ 的数据，图中没有环，也没有自环。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 10^4$，$0\\leq m \\leq 10^6$，**保证强连通分量的大小不超过** $\\boldsymbol{100}$。", "locale": "zh-CN"}}}
{"pid": "P6031", "type": "P", "difficulty": 7, "samples": [["1234 2345 3456", "398700213"], ["998244352 1337 5000", "326459680"], ["233333333 114514 9982443", "825888958"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "递推", "期望"], "title": "CF1278F Cards 加强版", "background": "[原题链接](https://www.luogu.com.cn/problem/CF1278F)", "description": "有 $m$ 张牌，其中有一张是王牌。将这些牌均匀随机打乱 $n$ 次，设有 $x$ 次第一张为王牌，求 $x^k$ 的期望值。\n\n答案对 $998244353$ 取模。", "inputFormat": "一行三个正整数 $n,m,k$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【数据范围】  \n对于 $20\\%$ 的数据，$1\\le k \\le 5000$；  \n对于 $40\\%$ 的数据，$1\\le k \\le 10^5$；  \n对于 $100\\%$ 的数据，$1\\le k \\le 10^7$，$1\\le n,m \\le 998244352$。\n\nSolution：iostream  \nData：NaCly\\_Fish", "locale": "zh-CN", "translations": {"zh-CN": {"title": "CF1278F Cards 加强版", "background": "[原题链接](https://www.luogu.com.cn/problem/CF1278F)", "description": "有 $m$ 张牌，其中有一张是王牌。将这些牌均匀随机打乱 $n$ 次，设有 $x$ 次第一张为王牌，求 $x^k$ 的期望值。\n\n答案对 $998244353$ 取模。", "inputFormat": "一行三个正整数 $n,m,k$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【数据范围】  \n对于 $20\\%$ 的数据，$1\\le k \\le 5000$；  \n对于 $40\\%$ 的数据，$1\\le k \\le 10^5$；  \n对于 $100\\%$ 的数据，$1\\le k \\le 10^7$，$1\\le n,m \\le 998244352$。\n\nSolution：iostream  \nData：NaCly\\_Fish", "locale": "zh-CN"}}}
{"pid": "P6032", "type": "P", "difficulty": 4, "samples": [["5 2 3\n0 5\n1 3\n0 2\n1 4\n1 5", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["递推"], "title": "选择客栈 加强版", "background": "", "description": "丽江河边有 $n$ 家很有特色的客栈，客栈按照其位置顺序从 $1$ 到 $n$ 编号。\n\n每家客栈都按照某一种色调进行装饰（总共 $k$ 种，用整数 $0 \\sim k-1$ 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。\n\n两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。\n\n晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 $p$ 。\n\n他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 $p$ 元的咖啡店小聚。 ", "inputFormat": "输入共 $n+1$ 行。\n\n第一行三个整数 $n,k,p$，每两个整数之间用一个空格隔开，分别表示客栈的个数，色调的数目和能接受的最低消费的最高值。\n\n接下来的 $n$ 行，第 $i+1$ 行两个整数，之间用一个空格隔开，分别表示 $i$ 号客栈的装饰色调和 $i$ 号客栈的咖啡店的最低消费。", "outputFormat": "输出一行一个整数，表示可选的住宿方案的总数。", "hint": "【样例解释】 \n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|}\\hline\n\\textsf{客栈编号} & \\text{①} & \\text{②} & \\text{③} & \\text{④} & \\text{⑤} \\\\\\hline\n\\textsf{色调} & 0 & 1 & 0 & 1 & 1 \\\\\\hline\n\\textsf{最低消费} & 5 & 3 & 2 & 4 & 5 \\\\ \\hline\n\\end{array}$$\n\n\n二人要住同样色调的客栈，所有可选的住宿方案包括：住客栈①③，②④，②⑤，④⑤。\n\n但是若选择住 ④⑤ 号客栈的话，④⑤ 号客栈之间的咖啡店的最低消费是 $4$，而两人能承受的最低消费是 $3$ 元，所以不满足要求。因此只有前 $3$ 种方案可选。\n\n【数据范围】  \n对于 $25\\%$ 的数据，$n\\leq 100$；  \n对于 $40\\%$ 的数据，$n\\leq 1000$；   \n对于 $80\\%$ 的数据，$n\\leq 2 \\times 10^5$，$k \\leq 50$；   \n对于 $100\\%$ 的数据，$2\\leq n\\leq2\\times 10^6$，$1 \\le k\\leq 10^4$，$0\\leq p\\leq 100$，$0\\leq$ 最低消费 $\\leq 100$ 。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "选择客栈 加强版", "background": "", "description": "丽江河边有 $n$ 家很有特色的客栈，客栈按照其位置顺序从 $1$ 到 $n$ 编号。\n\n每家客栈都按照某一种色调进行装饰（总共 $k$ 种，用整数 $0 \\sim k-1$ 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。\n\n两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。\n\n晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 $p$ 。\n\n他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 $p$ 元的咖啡店小聚。 ", "inputFormat": "输入共 $n+1$ 行。\n\n第一行三个整数 $n,k,p$，每两个整数之间用一个空格隔开，分别表示客栈的个数，色调的数目和能接受的最低消费的最高值。\n\n接下来的 $n$ 行，第 $i+1$ 行两个整数，之间用一个空格隔开，分别表示 $i$ 号客栈的装饰色调和 $i$ 号客栈的咖啡店的最低消费。", "outputFormat": "输出一行一个整数，表示可选的住宿方案的总数。", "hint": "【样例解释】 \n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|}\\hline\n\\textsf{客栈编号} & \\text{①} & \\text{②} & \\text{③} & \\text{④} & \\text{⑤} \\\\\\hline\n\\textsf{色调} & 0 & 1 & 0 & 1 & 1 \\\\\\hline\n\\textsf{最低消费} & 5 & 3 & 2 & 4 & 5 \\\\ \\hline\n\\end{array}$$\n\n\n二人要住同样色调的客栈，所有可选的住宿方案包括：住客栈①③，②④，②⑤，④⑤。\n\n但是若选择住 ④⑤ 号客栈的话，④⑤ 号客栈之间的咖啡店的最低消费是 $4$，而两人能承受的最低消费是 $3$ 元，所以不满足要求。因此只有前 $3$ 种方案可选。\n\n【数据范围】  \n对于 $25\\%$ 的数据，$n\\leq 100$；  \n对于 $40\\%$ 的数据，$n\\leq 1000$；   \n对于 $80\\%$ 的数据，$n\\leq 2 \\times 10^5$，$k \\leq 50$；   \n对于 $100\\%$ 的数据，$2\\leq n\\leq2\\times 10^6$，$1 \\le k\\leq 10^4$，$0\\leq p\\leq 100$，$0\\leq$ 最低消费 $\\leq 100$ 。", "locale": "zh-CN"}}}
{"pid": "P6033", "type": "P", "difficulty": 4, "samples": [["3 \n1 2 9 \n", "15\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2004", "NOIP 提高组", "O2优化", "排序", "队列"], "title": "[NOIP 2004 提高组] 合并果子 加强版", "background": "本题除【数据范围与约定】外与 [P1090](https://www.luogu.com.cn/problem/P1090) **完  全  一  致**。", "description": "在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。\n\n每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $(n - 1)$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。\n\n因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。\n\n例如有 $3$ 堆果子，数目依次为 $1,~2,~9$。可以先将 $1$、$2$ 堆合并，新堆数目为 $3$，耗费体力为 $3$。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$，耗费体力为 $12$。所以多多总共耗费体力为 $3+12=15$。可以证明 $15$ 为最小的体力耗费值。\n", "inputFormat": "输入的第一行是一个整数 $n$，代表果子的堆数。\\\n输入的第二行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 堆果子的个数 $a_i$。", "outputFormat": "输出一行一个整数，表示最小耗费的体力值。", "hint": "**【数据规模与约定】**\n\n**本题采用多测试点捆绑测试，共有四个子任务**。\n\n- Subtask 1（10 points）：$1 \\leq n \\leq 8$。\n- Subtask 2（20 points）：$1 \\leq n \\leq 10^3$。\n- Subtask 3（30 points）：$1 \\leq n \\leq 10^5$。\n- Subtask 4（40 points）：$1 \\leq n \\leq 10^7$。\n\n对于全部的测试点，保证 $1 \\leq a_i \\leq 10^5$。\n\n**【提示】**\n\n- 请注意常数因子对程序效率造成的影响。\n- 请使用类型合适的变量来存储本题的结果。\n- 本题输入规模较大，请注意数据读入对程序效率造成的影响。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOIP 2004 提高组] 合并果子 加强版", "background": "本题除【数据范围与约定】外与 [P1090](https://www.luogu.com.cn/problem/P1090) **完  全  一  致**。", "description": "在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。\n\n每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $(n - 1)$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。\n\n因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。\n\n例如有 $3$ 堆果子，数目依次为 $1,~2,~9$。可以先将 $1$、$2$ 堆合并，新堆数目为 $3$，耗费体力为 $3$。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$，耗费体力为 $12$。所以多多总共耗费体力为 $3+12=15$。可以证明 $15$ 为最小的体力耗费值。\n", "inputFormat": "输入的第一行是一个整数 $n$，代表果子的堆数。\\\n输入的第二行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 堆果子的个数 $a_i$。", "outputFormat": "输出一行一个整数，表示最小耗费的体力值。", "hint": "**【数据规模与约定】**\n\n**本题采用多测试点捆绑测试，共有四个子任务**。\n\n- Subtask 1（10 points）：$1 \\leq n \\leq 8$。\n- Subtask 2（20 points）：$1 \\leq n \\leq 10^3$。\n- Subtask 3（30 points）：$1 \\leq n \\leq 10^5$。\n- Subtask 4（40 points）：$1 \\leq n \\leq 10^7$。\n\n对于全部的测试点，保证 $1 \\leq a_i \\leq 10^5$。\n\n**【提示】**\n\n- 请注意常数因子对程序效率造成的影响。\n- 请使用类型合适的变量来存储本题的结果。\n- 本题输入规模较大，请注意数据读入对程序效率造成的影响。\n\n", "locale": "zh-CN"}}}
{"pid": "P6034", "type": "P", "difficulty": 5, "samples": [["2", "2"], ["42", "274"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2020"], "title": "Ryoku 与最初之人笔记", "background": "Ryoku 在阅读「最初之人」的笔记的时候，发现了一个有趣的运算：$\\rm xor$，这个运算的输入是两个数，输出是一个数，对应的运算时将输入的两个数化为二进制，再把每一位进行比较，若相同则输出的二进制中的这一位为 $0$，否则为 $1$。 \n\n在关于运算 $\\text{xor}$ 笔记的下面有一道习题。Ryoku 很快就得出了答案，她想要考考你。", "description": "Ryoku 向你复述了题目：求：\n\n$$\\sum_{a = 0}^n \\sum_{b = a + 1}^n [a\\equiv b\\pmod {a \\text{ xor } b}]$$\n\n即：求满足 $a\\equiv b\\pmod {a \\text{ xor } b}$，且 $a,b$ 均为小于等于 $n$ 的非负整数，$a<b$，的有序二元组 $(a,b)$ 个数。", "inputFormat": "输入包含一个整数 $n$。", "outputFormat": "输出包含一个整数，为上式的值，答案对 $10^9 + 7$ 取模。", "hint": "**【样例 1 说明】**\n\n符合题意的数对 $(a,b)$ 的有：$(0,1), (0,2)$。\n\n---\n\n**【数据规模与约定】**\n\n对于 $20\\%$ 的数据，$n\\le 10^3$。  \n对于 $60\\%$ 的数据，$n\\le 10^6$。  \n对于 $70\\%$ 的数据，$n\\le 10^9$。  \n对于 $100\\%$ 的数据，$2\\le n \\le 10^{18}$。  ", "locale": "zh-CN", "translations": {"en": {"title": "Ryoku and the Notes of the First Person", "background": "When Ryoku was reading the notes of the “First Person”, she found an interesting operation: $\\rm xor$. This operation takes two numbers as input and outputs one number. It works by converting the two input numbers into binary, then comparing each bit: if the bits are the same, that bit in the output is $0$; otherwise it is $1$.\n\nBelow the notes about the $\\text{xor}$ operation, there is an exercise. Ryoku quickly got the answer, and she wants to test you.", "description": "Ryoku retold the problem to you: compute:\n\n$$\\sum_{a = 0}^n \\sum_{b = a + 1}^n [a\\equiv b\\pmod {a \\text{ xor } b}]$$\n\nThat is, count the number of ordered pairs $(a,b)$ such that $a\\equiv b\\pmod {a \\text{ xor } b}$, where $a,b$ are non-negative integers not greater than $n$, and $a<b$.", "inputFormat": "The input contains one integer $n$.", "outputFormat": "Output one integer, the value of the expression above, modulo $10^9 + 7$.", "hint": "**[Sample 1 Explanation]**\n\nThe pairs $(a,b)$ that satisfy the condition are: $(0,1), (0,2)$.\n\n---\n\n**[Constraints]**\n\nFor $20\\%$ of the testdata, $n\\le 10^3$.  \nFor $60\\%$ of the testdata, $n\\le 10^6$.  \nFor $70\\%$ of the testdata, $n\\le 10^9$.  \nFor $100\\%$ of the testdata, $2\\le n \\le 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Ryoku 与最初之人笔记", "background": "Ryoku 在阅读「最初之人」的笔记的时候，发现了一个有趣的运算：$\\rm xor$，这个运算的输入是两个数，输出是一个数，对应的运算时将输入的两个数化为二进制，再把每一位进行比较，若相同则输出的二进制中的这一位为 $0$，否则为 $1$。 \n\n在关于运算 $\\text{xor}$ 笔记的下面有一道习题。Ryoku 很快就得出了答案，她想要考考你。", "description": "Ryoku 向你复述了题目：求：\n\n$$\\sum_{a = 0}^n \\sum_{b = a + 1}^n [a\\equiv b\\pmod {a \\text{ xor } b}]$$\n\n即：求满足 $a\\equiv b\\pmod {a \\text{ xor } b}$，且 $a,b$ 均为小于等于 $n$ 的非负整数，$a<b$，的有序二元组 $(a,b)$ 个数。", "inputFormat": "输入包含一个整数 $n$。", "outputFormat": "输出包含一个整数，为上式的值，答案对 $10^9 + 7$ 取模。", "hint": "**【样例 1 说明】**\n\n符合题意的数对 $(a,b)$ 的有：$(0,1), (0,2)$。\n\n---\n\n**【数据规模与约定】**\n\n对于 $20\\%$ 的数据，$n\\le 10^3$。  \n对于 $60\\%$ 的数据，$n\\le 10^6$。  \n对于 $70\\%$ 的数据，$n\\le 10^9$。  \n对于 $100\\%$ 的数据，$2\\le n \\le 10^{18}$。  ", "locale": "zh-CN"}}}
{"pid": "P6035", "type": "P", "difficulty": 5, "samples": [["5\n0 3 0 0 0\n", "1\n1 5 2 3 4"], ["5\n0 3 -1 0 0\n", "3\n1 5 2 3 4"], ["5\n0 3 -1 0 1\n", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2020", "线段树"], "title": "Ryoku 的逆序对", "background": "Ryoku 并不知道这题的背景是什么。", "description": "Ryoku 有一个正整数 $\\{1,2,\\cdots,n\\}$ 的排列 $A = \\{a_i\\}$。\n\n她告诉你一个序列 $B = \\{b_i\\}$，表示对于每个数 $a_i$，对于所有 $j>i$ 有 $b_i$ 个数可以与 $a_i$ 组成逆序对（逆序对的定义是：满足 $i>j$ 且 $a_i < a_j$ 的一组 $(a_i, a_j)$ 称作一对逆序对）。\n\n不幸的是，Ryoku 给你的序列 $B$ 有一些位置污损了，你想知道有多少个可能的排列 $A$ 能符合条件。\n\n请你输出答案并构造一个**字典序最小**的排列 $A$（对于排列 $A = \\{a_i\\},\\ A' = \\{a'_i\\}$ 若存在某个位置 $i$，使得 $\\forall j < i, a_j = a'_j$ 且 $a_i < a'_i$，则 $A$ 的字典序小于 $A'$）。", "inputFormat": "输入包含两行。  \n第一行包含一个整数 $n$。  \n第二行包含 $n$ 个整数，为序列 $B$。若给出的 $b_i = -1$，则代表这个位置被污损了。", "outputFormat": "输出包含两行。  \n第一行包含一个整数，为可能的排列 $A$ 的方案数，对 $10^9 + 7$ 取模。  \n第二行包含 $n$ 个整数，为字典序最小的符合条件的排列。若第一行答案为 $0$，则第二行无需输出。", "hint": "**【样例 1 说明】**\n\n对于 $5$，存在逆序对 $(5,2),(5,3),(5,4)$ 共三对。\n\n**【样例 2 说明】**\n\n符合条件的排列有：$\\{1, 5, 4, 2, 3\\}, \\{1, 5, 3, 2, 4\\}, \\{1, 5, 2, 3, 4\\}$。共三种，其中字典序最小的为 $\\{1, 5, 2, 3, 4\\}$。\n\n---\n\n**【数据规模与约定】**\n\n对于 $10\\%$ 的数据，$b_i \\neq -1$。  \n对于另外 $10\\%$ 的数据，$n \\le 10$。  \n对于另外 $10\\%$ 的数据，$b_i = -1$。  \n对于另外 $30\\%$ 的数据，$n \\le 10^3$。  \n对于另外 $30\\%$ 的数据，$n \\le 10^5$。  \n对于 $100\\%$ 的数据，$0< n \\le 10^6$，$-1 \\le b_i \\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Ryoku 的逆序对", "background": "Ryoku 并不知道这题的背景是什么。", "description": "Ryoku 有一个正整数 $\\{1,2,\\cdots,n\\}$ 的排列 $A = \\{a_i\\}$。\n\n她告诉你一个序列 $B = \\{b_i\\}$，表示对于每个数 $a_i$，对于所有 $j>i$ 有 $b_i$ 个数可以与 $a_i$ 组成逆序对（逆序对的定义是：满足 $i>j$ 且 $a_i < a_j$ 的一组 $(a_i, a_j)$ 称作一对逆序对）。\n\n不幸的是，Ryoku 给你的序列 $B$ 有一些位置污损了，你想知道有多少个可能的排列 $A$ 能符合条件。\n\n请你输出答案并构造一个**字典序最小**的排列 $A$（对于排列 $A = \\{a_i\\},\\ A' = \\{a'_i\\}$ 若存在某个位置 $i$，使得 $\\forall j < i, a_j = a'_j$ 且 $a_i < a'_i$，则 $A$ 的字典序小于 $A'$）。", "inputFormat": "输入包含两行。  \n第一行包含一个整数 $n$。  \n第二行包含 $n$ 个整数，为序列 $B$。若给出的 $b_i = -1$，则代表这个位置被污损了。", "outputFormat": "输出包含两行。  \n第一行包含一个整数，为可能的排列 $A$ 的方案数，对 $10^9 + 7$ 取模。  \n第二行包含 $n$ 个整数，为字典序最小的符合条件的排列。若第一行答案为 $0$，则第二行无需输出。", "hint": "**【样例 1 说明】**\n\n对于 $5$，存在逆序对 $(5,2),(5,3),(5,4)$ 共三对。\n\n**【样例 2 说明】**\n\n符合条件的排列有：$\\{1, 5, 4, 2, 3\\}, \\{1, 5, 3, 2, 4\\}, \\{1, 5, 2, 3, 4\\}$。共三种，其中字典序最小的为 $\\{1, 5, 2, 3, 4\\}$。\n\n---\n\n**【数据规模与约定】**\n\n对于 $10\\%$ 的数据，$b_i \\neq -1$。  \n对于另外 $10\\%$ 的数据，$n \\le 10$。  \n对于另外 $10\\%$ 的数据，$b_i = -1$。  \n对于另外 $30\\%$ 的数据，$n \\le 10^3$。  \n对于另外 $30\\%$ 的数据，$n \\le 10^5$。  \n对于 $100\\%$ 的数据，$0< n \\le 10^6$，$-1 \\le b_i \\le n$。", "locale": "zh-CN"}}}
{"pid": "P6036", "type": "P", "difficulty": 6, "samples": [["3 0.5 0.5\n2 3 3\n0.5 0.5 0.5\n", "3.097"], ["6 0.8 0.2\n1 1 4 5 1 4\n0.9 0.6 0.7 0.7 0.6 0.8\n", "10.521"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2020", "Special Judge", "期望"], "title": "Ryoku 爱学习", "background": "Ryoku 继承了 Riri 在学习方面的天赋，所以她非常热爱学习。但是，不管再怎么热爱学习，Ryoku 也会疲倦的。", "description": "Ryoku 在第 $i$ 时刻会了解到有一个新知识 $i$，这个新知识的实际价值为 $w_i$，由于 Ryoku 爱学习，所以她不会选择不学习知识，但她只有 $p_i$ 的概率能成功掌握这个知识。\n\n然而如果 Ryoku 同时掌握了太多知识，由于 Ryoku 内心的疲倦等因素，Ryoku 感受到的对知识的喜爱程度会改变，我们用一个数值 $R$ 来描述**喜爱程度**的大小。具体而言，设 $R=f(l,r)$ 代表 Ryoku **连续掌握**时刻 $l$ 至时刻 $r$ 的知识时对这些知识的喜爱程度的总和，有参数 $a, b$（$0 < a, b<1$），则有：\n\n$$ f(l,r)=a^{b(r-l)}  \\sum_{i=l}^r w_i$$\n\nRyoku 想要知道她期望能**掌握的每一段连续时刻的知识**的喜爱程度之和是多少（需要注意的是，这里所说的连续时刻的知识不能被一段更长的所包含）。你能帮帮她吗？\n", "inputFormat": "输入包含三行。  \n第一行包含一个整数 $n$，两个实数 $a,b$。  \n第二行包含 $n$ 个整数，为 $w_i$。  \n第三行包含 $n$ 个实数，为 $p_i$。", "outputFormat": "输出包含一行一个正实数，为答案。", "hint": "**【样例 1 说明】**\n\n掌握知识 $1$、知识 $2$、知识 $3$ 时，每一段连续掌握知识的喜爱程度之和为 $\\left(\\dfrac 12\\right)^{\\frac12\\times 2}(2+3+3)=4$。\n\n掌握知识 $1$、知识 $2$ 时，每一段连续掌握知识的喜爱程度之和为 $\\left(\\dfrac 12\\right)^{\\frac12\\times 1}(2+3)=\\dfrac {5\\sqrt2}2\\approx 3.536$。\n\n掌握知识 $1$、知识 $3$ 时，每一段连续掌握知识的喜爱程度之和为 $\\left(\\dfrac 12\\right)^{\\frac12\\times 0}\\times 2 +\\left(\\dfrac 12\\right)^{\\frac12\\times 0}\\times 3  = 5$。\n\n掌握知识 $2$、知识 $3$ 时，每一段连续掌握知识的喜爱程度之和为 $\\left(\\dfrac 12\\right)^{\\frac12\\times 1}(3+3)=3\\sqrt 2\\approx 4.243$。\n\n只掌握知识 $1$ 时，每一段连续掌握知识的喜爱程度之和为 $\\left(\\dfrac 12\\right)^{\\frac12\\times 0}\\times 2  = 2$。\n\n只掌握知识 $2$ 时，每一段连续掌握知识的喜爱程度之和为 $\\left(\\dfrac 12\\right)^{\\frac12\\times 0}\\times 3  = 3$。\n\n只掌握宝物 $3$ 时，每一段连续掌握知识的喜爱程度之和为 $\\left(\\dfrac 12\\right)^{\\frac12\\times 0}\\times 3  = 3$。\n\n什么都不掌握时，每一段连续掌握知识的喜爱程度之和为 $0$。\n\n以上 $8$ 种情况出现的概率均为 $\\dfrac 18$，所以答案约为：\n\n$$(4+3.536+5+4.243+2+3+3+0)\\times \\dfrac 18\\approx3.0973$$\n\n---\n\n**【数据规模与约定】**\n\n对于 $20\\%$ 的数据，$n \\le 18$。  \n对于另外 $15\\%$ 的数据，$w_i = 1$。  \n对于 $55\\%$ 的数据，$n \\le 10^3$。  \n对于另外 $15\\%$ 的数据，$w_i = 1$。  \n对于另外 $15\\%$ 的数据，$b_i \\le 0.2$。  \n\n此外，对于 $100\\%$ 的数据，$0<n\\le10^5$，$0<a,b,p_i<1$，$0<w_i\\le10^3$。保证输入数据的精度不超过 $10^{-2}$。\n\n**本题使用 Special Judge，如果某个测试点中你的答案与标准答案相差小于等于 $10^{-3}$，你就可以通过该测试点。**\n", "locale": "zh-CN", "translations": {"en": {"title": "Ryoku Loves Studying", "background": "Ryoku inherited Riri’s talent for studying, so she really loves studying. However, no matter how much she loves it, Ryoku can still get tired.", "description": "At time $i$, Ryoku will learn that there is a new piece of knowledge $i$. The actual value of this knowledge is $w_i$. Since Ryoku loves studying, she will not choose to skip any knowledge, but she only has probability $p_i$ of successfully mastering this knowledge.\n\nHowever, if Ryoku masters too much knowledge at the same time, due to factors such as her inner tiredness, Ryoku’s level of “liking” for knowledge will change. We use a value $R$ to describe the magnitude of this **liking level**. Specifically, let $R=f(l,r)$ represent the total liking level for the knowledge from time $l$ to time $r$ that Ryoku **masters continuously**. With parameters $a, b$ ($0 < a, b<1$), we have:\n\n$$ f(l,r)=a^{b(r-l)}  \\sum_{i=l}^r w_i$$\n\nRyoku wants to know the expected total liking level of **every continuous segment of time that she can master** (note that the continuous segment here must not be contained in a longer one). Can you help her?", "inputFormat": "The input contains three lines.  \nThe first line contains an integer $n$ and two real numbers $a,b$.  \nThe second line contains $n$ integers, which are $w_i$.  \nThe third line contains $n$ real numbers, which are $p_i$.", "outputFormat": "Output one line containing one positive real number, which is the answer.", "hint": "**[Sample 1 Explanation]**\n\nWhen mastering knowledge $1$, knowledge $2$, and knowledge $3$, the sum of liking levels over each continuously mastered segment is $\\left(\\dfrac 12\\right)^{\\frac12\\times 2}(2+3+3)=4$.\n\nWhen mastering knowledge $1$ and knowledge $2$, the sum of liking levels over each continuously mastered segment is $\\left(\\dfrac 12\\right)^{\\frac12\\times 1}(2+3)=\\dfrac {5\\sqrt2}2\\approx 3.536$.\n\nWhen mastering knowledge $1$ and knowledge $3$, the sum of liking levels over each continuously mastered segment is $\\left(\\dfrac 12\\right)^{\\frac12\\times 0}\\times 2 +\\left(\\dfrac 12\\right)^{\\frac12\\times 0}\\times 3  = 5$.\n\nWhen mastering knowledge $2$ and knowledge $3$, the sum of liking levels over each continuously mastered segment is $\\left(\\dfrac 12\\right)^{\\frac12\\times 1}(3+3)=3\\sqrt 2\\approx 4.243$.\n\nWhen only mastering knowledge $1$, the sum of liking levels over each continuously mastered segment is $\\left(\\dfrac 12\\right)^{\\frac12\\times 0}\\times 2  = 2$.\n\nWhen only mastering knowledge $2$, the sum of liking levels over each continuously mastered segment is $\\left(\\dfrac 12\\right)^{\\frac12\\times 0}\\times 3  = 3$.\n\nWhen only mastering “treasure” $3$, the sum of liking levels over each continuously mastered segment is $\\left(\\dfrac 12\\right)^{\\frac12\\times 0}\\times 3  = 3$.\n\nWhen mastering nothing, the sum of liking levels over each continuously mastered segment is $0$.\n\nThe probabilities of the above $8$ cases are all $\\dfrac 18$, so the answer is approximately:\n\n$$(4+3.536+5+4.243+2+3+3+0)\\times \\dfrac 18\\approx3.0973$$\n\n---\n\n**[Constraints]**\n\nFor $20\\%$ of the testdata, $n \\le 18$.  \nFor another $15\\%$ of the testdata, $w_i = 1$.  \nFor $55\\%$ of the testdata, $n \\le 10^3$.  \nFor another $15\\%$ of the testdata, $w_i = 1$.  \nFor another $15\\%$ of the testdata, $b_i \\le 0.2$.  \n\nIn addition, for $100\\%$ of the testdata, $0<n\\le10^5$, $0<a,b,p_i<1$, $0<w_i\\le10^3$. It is guaranteed that the input precision does not exceed $10^{-2}$.\n\n**This problem uses Special Judge. If, for some test point, the difference between your answer and the standard answer is less than or equal to $10^{-3}$, you can pass that test point.**\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Ryoku 爱学习", "background": "Ryoku 继承了 Riri 在学习方面的天赋，所以她非常热爱学习。但是，不管再怎么热爱学习，Ryoku 也会疲倦的。", "description": "Ryoku 在第 $i$ 时刻会了解到有一个新知识 $i$，这个新知识的实际价值为 $w_i$，由于 Ryoku 爱学习，所以她不会选择不学习知识，但她只有 $p_i$ 的概率能成功掌握这个知识。\n\n然而如果 Ryoku 同时掌握了太多知识，由于 Ryoku 内心的疲倦等因素，Ryoku 感受到的对知识的喜爱程度会改变，我们用一个数值 $R$ 来描述**喜爱程度**的大小。具体而言，设 $R=f(l,r)$ 代表 Ryoku **连续掌握**时刻 $l$ 至时刻 $r$ 的知识时对这些知识的喜爱程度的总和，有参数 $a, b$（$0 < a, b<1$），则有：\n\n$$ f(l,r)=a^{b(r-l)}  \\sum_{i=l}^r w_i$$\n\nRyoku 想要知道她期望能**掌握的每一段连续时刻的知识**的喜爱程度之和是多少（需要注意的是，这里所说的连续时刻的知识不能被一段更长的所包含）。你能帮帮她吗？\n", "inputFormat": "输入包含三行。  \n第一行包含一个整数 $n$，两个实数 $a,b$。  \n第二行包含 $n$ 个整数，为 $w_i$。  \n第三行包含 $n$ 个实数，为 $p_i$。", "outputFormat": "输出包含一行一个正实数，为答案。", "hint": "**【样例 1 说明】**\n\n掌握知识 $1$、知识 $2$、知识 $3$ 时，每一段连续掌握知识的喜爱程度之和为 $\\left(\\dfrac 12\\right)^{\\frac12\\times 2}(2+3+3)=4$。\n\n掌握知识 $1$、知识 $2$ 时，每一段连续掌握知识的喜爱程度之和为 $\\left(\\dfrac 12\\right)^{\\frac12\\times 1}(2+3)=\\dfrac {5\\sqrt2}2\\approx 3.536$。\n\n掌握知识 $1$、知识 $3$ 时，每一段连续掌握知识的喜爱程度之和为 $\\left(\\dfrac 12\\right)^{\\frac12\\times 0}\\times 2 +\\left(\\dfrac 12\\right)^{\\frac12\\times 0}\\times 3  = 5$。\n\n掌握知识 $2$、知识 $3$ 时，每一段连续掌握知识的喜爱程度之和为 $\\left(\\dfrac 12\\right)^{\\frac12\\times 1}(3+3)=3\\sqrt 2\\approx 4.243$。\n\n只掌握知识 $1$ 时，每一段连续掌握知识的喜爱程度之和为 $\\left(\\dfrac 12\\right)^{\\frac12\\times 0}\\times 2  = 2$。\n\n只掌握知识 $2$ 时，每一段连续掌握知识的喜爱程度之和为 $\\left(\\dfrac 12\\right)^{\\frac12\\times 0}\\times 3  = 3$。\n\n只掌握宝物 $3$ 时，每一段连续掌握知识的喜爱程度之和为 $\\left(\\dfrac 12\\right)^{\\frac12\\times 0}\\times 3  = 3$。\n\n什么都不掌握时，每一段连续掌握知识的喜爱程度之和为 $0$。\n\n以上 $8$ 种情况出现的概率均为 $\\dfrac 18$，所以答案约为：\n\n$$(4+3.536+5+4.243+2+3+3+0)\\times \\dfrac 18\\approx3.0973$$\n\n---\n\n**【数据规模与约定】**\n\n对于 $20\\%$ 的数据，$n \\le 18$。  \n对于另外 $15\\%$ 的数据，$w_i = 1$。  \n对于 $55\\%$ 的数据，$n \\le 10^3$。  \n对于另外 $15\\%$ 的数据，$w_i = 1$。  \n对于另外 $15\\%$ 的数据，$b_i \\le 0.2$。  \n\n此外，对于 $100\\%$ 的数据，$0<n\\le10^5$，$0<a,b,p_i<1$，$0<w_i\\le10^3$。保证输入数据的精度不超过 $10^{-2}$。\n\n**本题使用 Special Judge，如果某个测试点中你的答案与标准答案相差小于等于 $10^{-3}$，你就可以通过该测试点。**\n", "locale": "zh-CN"}}}
{"pid": "P6037", "type": "P", "difficulty": 4, "samples": [["5\n4 1 2 1\n1 2 3 2\n3 1 1 4\n3 5 2 5\n2 3 2 3\n", "7\n7\n8\n7\n8"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2020", "深度优先搜索 DFS", "基环树"], "title": "Ryoku 的探索", "background": "Ryoku 对自己所处的世界充满了好奇，她希望能够在她「死」之前尽可能能多地探索世界。\n\n这一天，Ryoku 得到了一张这个世界的地图，她十分高兴。然而，Ryoku 并不知道自己所处的位置到底在哪里，她也不知道她会什么时候死去。她想要知道如何才能尽可能多的探索这个世界。", "description": "Ryoku 所处的世界可以抽象成一个有 $n$ 个点， $n$ 条边的带权无向连通图 $G$。每条边有美观度和长度。\n\nRyoku 会使用这样一个策略探索世界：在每个点寻找一个**端点她未走过**的边中**美观度最高**的走，如果没有边走，就沿着她前往这个点的边返回，类似于图的**深度优先遍历**。\n\n探索的一个方案的长度是这个方案所经过的所有边长度的和（返回时经过的长度不用计算）。\n\n她想知道，对于每一个起点 $s=1,2,\\cdots,n$，她需要走过的长度是多少？\n\n", "inputFormat": "输入包含 $n + 1$  行，其中第一行包含一个整数 $n$。  \n接下来 $n$ 行每行包含四个整数 $u,v,w,p$，描述了一条连接 $u$ 和 $v$，长度为 $w$，美观度为 $p$ 的无向边。", "outputFormat": "输出包含 $n$ 行，每行一个整数，第 $i$ 行为 $s=i$ 时的答案。", "hint": "**【样例 1 说明】**\n\n以下为输入输出样例 1 中的图： （边上红色数组为 $p$，黑色为 $w$）\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rmk07281.png)\n\n若起点为 $1$，顺序为 $1\\to3\\to5\\to2\\to4$，长度之和为 $7$。  \n若起点为 $2$，顺序为 $2\\to3\\to5\\to1\\to4$，长度之和为 $7$。  \n若起点为 $3$，顺序为 $3\\to5\\to1\\to2\\to4$，长度之和为 $8$。  \n若起点为 $4$，顺序为 $4\\to1\\to3\\to5\\to2$，长度之和为 $7$。  \n若起点为 $5$，顺序为 $5\\to3\\to1\\to2\\to4$，长度之和为 $8$。  \n\n---\n\n**【数据规模与约定】**\n\n对于 $40\\%$ 的数据，$n\\le 10^3$。    \n对于 $100\\%$ 的数据，$3 \\le n \\le 10^6$，$1 \\le u,v,p \\le n$，$0\\le w\\le 10^9$，保证 $p$ 互不相同。", "locale": "zh-CN", "translations": {"en": {"title": "Ryoku’s Exploration.", "background": "Ryoku is very curious about the world she lives in. Before she “dies”, she hopes to explore as much of the world as possible.\n\nOne day, Ryoku got a map of this world and was very happy. However, Ryoku does not know where she is, and she also does not know when she will die. She wants to know how to explore as much of this world as possible.", "description": "Ryoku’s world can be modeled as a weighted, undirected, connected graph $G$ with $n$ vertices and $n$ edges. Each edge has a beauty value and a length.\n\nRyoku explores the world using the following strategy: at each vertex, among the edges whose **endpoint she has not visited yet**, she chooses the one with the **highest beauty value** to walk along. If there is no edge to take, she returns along the edge she used to reach this vertex, similar to a graph **depth-first traversal**.\n\nThe length of an exploration plan is the sum of the lengths of all edges that the plan walks through (the distance walked when returning does not need to be counted).\n\nShe wants to know, for every starting vertex $s=1,2,\\cdots,n$, what total length she needs to walk.", "inputFormat": "The input contains $n+1$ lines. The first line contains an integer $n$.  \nThe next $n$ lines each contain four integers $u,v,w,p$, describing an undirected edge connecting $u$ and $v$, with length $w$ and beauty value $p$.", "outputFormat": "Output $n$ lines, each containing one integer. The $i$-th line is the answer when $s=i$.", "hint": "**[Sample 1 Explanation]**\n\nThe following is the graph in Sample Input/Output 1 (the red numbers on edges are $p$, and the black numbers are $w$).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rmk07281.png)\n\nIf the starting point is $1$, the order is $1\\to3\\to5\\to2\\to4$, and the sum of lengths is $7$.  \nIf the starting point is $2$, the order is $2\\to3\\to5\\to1\\to4$, and the sum of lengths is $7$.  \nIf the starting point is $3$, the order is $3\\to5\\to1\\to2\\to4$, and the sum of lengths is $8$.  \nIf the starting point is $4$, the order is $4\\to1\\to3\\to5\\to2$, and the sum of lengths is $7$.  \nIf the starting point is $5$, the order is $5\\to3\\to1\\to2\\to4$, and the sum of lengths is $8$.\n\n---\n\n**[Constraints]**\n\nFor $40\\%$ of the testdata, $n\\le 10^3$.  \nFor $100\\%$ of the testdata, $3 \\le n \\le 10^6$, $1 \\le u,v,p \\le n$, $0\\le w\\le 10^9$. It is guaranteed that all $p$ are distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Ryoku 的探索", "background": "Ryoku 对自己所处的世界充满了好奇，她希望能够在她「死」之前尽可能能多地探索世界。\n\n这一天，Ryoku 得到了一张这个世界的地图，她十分高兴。然而，Ryoku 并不知道自己所处的位置到底在哪里，她也不知道她会什么时候死去。她想要知道如何才能尽可能多的探索这个世界。", "description": "Ryoku 所处的世界可以抽象成一个有 $n$ 个点， $n$ 条边的带权无向连通图 $G$。每条边有美观度和长度。\n\nRyoku 会使用这样一个策略探索世界：在每个点寻找一个**端点她未走过**的边中**美观度最高**的走，如果没有边走，就沿着她前往这个点的边返回，类似于图的**深度优先遍历**。\n\n探索的一个方案的长度是这个方案所经过的所有边长度的和（返回时经过的长度不用计算）。\n\n她想知道，对于每一个起点 $s=1,2,\\cdots,n$，她需要走过的长度是多少？\n\n", "inputFormat": "输入包含 $n + 1$  行，其中第一行包含一个整数 $n$。  \n接下来 $n$ 行每行包含四个整数 $u,v,w,p$，描述了一条连接 $u$ 和 $v$，长度为 $w$，美观度为 $p$ 的无向边。", "outputFormat": "输出包含 $n$ 行，每行一个整数，第 $i$ 行为 $s=i$ 时的答案。", "hint": "**【样例 1 说明】**\n\n以下为输入输出样例 1 中的图： （边上红色数组为 $p$，黑色为 $w$）\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rmk07281.png)\n\n若起点为 $1$，顺序为 $1\\to3\\to5\\to2\\to4$，长度之和为 $7$。  \n若起点为 $2$，顺序为 $2\\to3\\to5\\to1\\to4$，长度之和为 $7$。  \n若起点为 $3$，顺序为 $3\\to5\\to1\\to2\\to4$，长度之和为 $8$。  \n若起点为 $4$，顺序为 $4\\to1\\to3\\to5\\to2$，长度之和为 $7$。  \n若起点为 $5$，顺序为 $5\\to3\\to1\\to2\\to4$，长度之和为 $8$。  \n\n---\n\n**【数据规模与约定】**\n\n对于 $40\\%$ 的数据，$n\\le 10^3$。    \n对于 $100\\%$ 的数据，$3 \\le n \\le 10^6$，$1 \\le u,v,p \\le n$，$0\\le w\\le 10^9$，保证 $p$ 互不相同。", "locale": "zh-CN"}}}
{"pid": "P6038", "type": "P", "difficulty": 6, "samples": [["5 10\n5 9 6 4 2\n3 1\n3 4\n1 2\n1 5\n", "2"], ["7 5\n6 7 4 5 7 8 9\n1 2\n2 3\n2 4\n1 5\n5 6\n5 7\n", "16"], ["8 5\n4 3 2 5 6 7 6 2\n1 2\n1 5\n2 3\n2 4\n5 6\n5 7\n6 8\n", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "线段树", "倍增", "二分", "O2优化", "ST 表"], "title": "「ACOI2020」惊吓路径", "background": "![T6](https://s2.ax1x.com/2020/01/12/lopZpq.png)\n\n3 年 E 班的同学们赢得了去南方的冲绳小岛的机会，在渚打败了鹰冈之后，他们受杀老师的邀请参加“试胆大会”。\n\n试胆大会在一个黑漆漆的洞窟里面进行。赤羽 業（Akabane Karma）现在和奧田 愛美站在洞窟的门口。突然，業想到了一个事情。。。", "description": "杀老师告诉过他们，洞窟可以近似地看成 $n$ 个点的外向树，因为地形原因，所以一个点到另一个点的边是有方向的，且边的方向都是同向的。这棵树的树根为入度为 $0$ 的点。每个点都有一个惊吓值，给出每个点的惊吓值 $a_i$。\n\n杀老师告诉他们，这个洞穴有很多惊吓路径。如果两个节点 $u,v$ 构成的路径是一条惊吓路径的话，满足以下条件：\n\n- $v$ 一定在 $u$ 的子树中。\n\n- $u, v$ 这条路径上的所有的点的惊吓值的或值 $\\geq k$。\n\n走过一条惊吓路径就会收到杀老师的惊喜大礼。杀老师已经提前准备好了惊喜大礼，但是業当然已经知道杀老师有一些下流的意图，更别说惊喜大礼的数量可能不够！杀老师已经承诺有多少条惊吓路径就有多少个惊喜大礼。業已经通过一些神奇的途径知道了杀老师准备的惊喜大礼的个数，现在他想知道有多少条惊吓路径，也就是杀老师最少需要准备惊喜大礼的个数。如果不够，他就会揭穿杀老师的意图。现在業当然想赚，好好捉弄一下杀老师。所以他~~作弊~~提前得到了杀老师的地图，想问这个图里面有多少条惊吓路径？", "inputFormat": "第一行两个整数 $n,k$。\n\n第二行 $n$ 个整数，表示每个点的惊吓值。\n\n接下来 $n-1$ 行，每行有两个整数 $u,v$ 表示节点 $u,v$ 之间有一条有向边，节点 $u$ 可以到达节点 $v$，**节点 $v$ 不可以到达节点 $u$**。\n\n\n\n", "outputFormat": "一行一个整数，表示这个洞穴的惊吓路径条数。", "hint": "#### 样例解释 #1\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lqu4ejku.png)\n\n只有两条路径满足条件：\n\n1. $3\\to 1\\to 2$，这条路径的所有点的惊吓值的或值是 $6\\operatorname{or}5\\operatorname{or}9=15$。\n\n2. $1 \\to 2$，这条路径的所有点的惊吓值的或值是 $5\\operatorname{or}9=13$。\n\n------------\n#### 数据范围 \n**本题采用捆绑测试**。\n\n- Subtask 1（10 points）：$n \\leq 5 \\times 10^3$，$k \\leq 10^5$。    \n- Subtask 2（30 points）：对于任意一条边，$v=u+1$，$n \\leq 10^6$，$k,a_i \\leq 10^9$。     \n- Subtask 3（20 points）：$n \\leq 10^5$，$k,a_i \\leq 10^9$。    \n- Subtask 4（40 points）：$n \\leq 5 \\times 10^5$，$k,a_i \\leq 10^9$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^6$，$1 \\leq k,a_i \\leq 10^9$。\n\n------------\n#### 提示\n**第四个子任务中的测试点空间 256MB，其余子任务中的测试点空间 128MB。**", "locale": "zh-CN", "translations": {"en": {"title": "\"ACOI2020\" Scare Paths.", "background": "![T6](https://s2.ax1x.com/2020/01/12/lopZpq.png)\n\nThe students of Class E, Year 3 won a chance to go to the southern Okinawa island. After defeating Takaoka at Nagisa, they were invited by Koro-sensei to join a “courage test”.\n\nThe courage test takes place in a pitch-dark cave. Akabane Karma is now standing at the entrance of the cave with Okuda Manami. Suddenly, Karma thought of something...", "description": "Koro-sensei told them that the cave can be approximately seen as an out-tree with $n$ nodes. Due to the terrain, the edge from one node to another has a direction, and the directions of all edges are consistent. The root of this tree is the node with in-degree $0$. Each node has a scare value; the scare value of node $i$ is $a_i$.\n\nKoro-sensei told them that there are many scare paths in this cave. If the path formed by two nodes $u, v$ is a scare path, then it satisfies:\n\n- $v$ must be in the subtree of $u$.\n- The bitwise OR of the scare values of all nodes on the path from $u$ to $v$ is $\\geq k$.\n\nWalking through a scare path will earn a “surprise gift” from Koro-sensei. Koro-sensei has prepared the gifts in advance, but Karma already knows Koro-sensei has some improper intentions, not to mention the number of gifts might not be enough. Koro-sensei promised that there would be as many surprise gifts as there are scare paths. Karma has learned, through some mysterious means, how many surprise gifts Koro-sensei prepared. Now he wants to know how many scare paths there are, i.e., the minimum number of gifts Koro-sensei must prepare. If it is not enough, he will expose Koro-sensei’s intentions. Of course, Karma wants to take advantage of this and mess with Koro-sensei. So he ~~cheated~~ got Koro-sensei’s map in advance, and wants to ask: how many scare paths are there in this graph?", "inputFormat": "The first line contains two integers $n, k$.\n\nThe second line contains $n$ integers, representing the scare value of each node.\n\nThe next $n - 1$ lines each contain two integers $u, v$, indicating that there is a directed edge between nodes $u$ and $v$, and node $u$ can reach node $v$. **Node $v$ cannot reach node $u$.**", "outputFormat": "Output one integer in one line, representing the number of scare paths in this cave.", "hint": "#### Sample Explanation #1\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lqu4ejku.png)\n\nOnly two paths satisfy the conditions:\n\n1. $3 \\to 1 \\to 2$. The bitwise OR of the scare values of all nodes on this path is $6\\operatorname{or}5\\operatorname{or}9=15$.\n2. $1 \\to 2$. The bitwise OR of the scare values of all nodes on this path is $5\\operatorname{or}9=13$.\n\n------------\n#### Constraints\n\n**This problem uses bundled testdata.**\n\n- Subtask 1 (10 points): $n \\leq 5 \\times 10^3$, $k \\leq 10^5$.  \n- Subtask 2 (30 points): For any edge, $v = u + 1$, $n \\leq 10^6$, $k, a_i \\leq 10^9$.  \n- Subtask 3 (20 points): $n \\leq 10^5$, $k, a_i \\leq 10^9$.  \n- Subtask 4 (40 points): $n \\leq 5 \\times 10^5$, $k, a_i \\leq 10^9$.\n\nFor $100\\%$ of the testdata: $1 \\leq n \\leq 10^6$, $1 \\leq k, a_i \\leq 10^9$.\n\n------------\n#### Note\n\n**In the fourth subtask, the memory limit is 256MB; in the other subtasks, the memory limit is 128MB.**\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「ACOI2020」惊吓路径", "background": "![T6](https://s2.ax1x.com/2020/01/12/lopZpq.png)\n\n3 年 E 班的同学们赢得了去南方的冲绳小岛的机会，在渚打败了鹰冈之后，他们受杀老师的邀请参加“试胆大会”。\n\n试胆大会在一个黑漆漆的洞窟里面进行。赤羽 業（Akabane Karma）现在和奧田 愛美站在洞窟的门口。突然，業想到了一个事情。。。", "description": "杀老师告诉过他们，洞窟可以近似地看成 $n$ 个点的外向树，因为地形原因，所以一个点到另一个点的边是有方向的，且边的方向都是同向的。这棵树的树根为入度为 $0$ 的点。每个点都有一个惊吓值，给出每个点的惊吓值 $a_i$。\n\n杀老师告诉他们，这个洞穴有很多惊吓路径。如果两个节点 $u,v$ 构成的路径是一条惊吓路径的话，满足以下条件：\n\n- $v$ 一定在 $u$ 的子树中。\n\n- $u, v$ 这条路径上的所有的点的惊吓值的或值 $\\geq k$。\n\n走过一条惊吓路径就会收到杀老师的惊喜大礼。杀老师已经提前准备好了惊喜大礼，但是業当然已经知道杀老师有一些下流的意图，更别说惊喜大礼的数量可能不够！杀老师已经承诺有多少条惊吓路径就有多少个惊喜大礼。業已经通过一些神奇的途径知道了杀老师准备的惊喜大礼的个数，现在他想知道有多少条惊吓路径，也就是杀老师最少需要准备惊喜大礼的个数。如果不够，他就会揭穿杀老师的意图。现在業当然想赚，好好捉弄一下杀老师。所以他~~作弊~~提前得到了杀老师的地图，想问这个图里面有多少条惊吓路径？", "inputFormat": "第一行两个整数 $n,k$。\n\n第二行 $n$ 个整数，表示每个点的惊吓值。\n\n接下来 $n-1$ 行，每行有两个整数 $u,v$ 表示节点 $u,v$ 之间有一条有向边，节点 $u$ 可以到达节点 $v$，**节点 $v$ 不可以到达节点 $u$**。\n\n\n\n", "outputFormat": "一行一个整数，表示这个洞穴的惊吓路径条数。", "hint": "#### 样例解释 #1\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lqu4ejku.png)\n\n只有两条路径满足条件：\n\n1. $3\\to 1\\to 2$，这条路径的所有点的惊吓值的或值是 $6\\operatorname{or}5\\operatorname{or}9=15$。\n\n2. $1 \\to 2$，这条路径的所有点的惊吓值的或值是 $5\\operatorname{or}9=13$。\n\n------------\n#### 数据范围 \n**本题采用捆绑测试**。\n\n- Subtask 1（10 points）：$n \\leq 5 \\times 10^3$，$k \\leq 10^5$。    \n- Subtask 2（30 points）：对于任意一条边，$v=u+1$，$n \\leq 10^6$，$k,a_i \\leq 10^9$。     \n- Subtask 3（20 points）：$n \\leq 10^5$，$k,a_i \\leq 10^9$。    \n- Subtask 4（40 points）：$n \\leq 5 \\times 10^5$，$k,a_i \\leq 10^9$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^6$，$1 \\leq k,a_i \\leq 10^9$。\n\n------------\n#### 提示\n**第四个子任务中的测试点空间 256MB，其余子任务中的测试点空间 128MB。**", "locale": "zh-CN"}}}
{"pid": "P6039", "type": "P", "difficulty": 2, "samples": [["11 0\n5\n", "1.000000\nError"], ["6 8\n4\n", "2.000000\n0.75"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2020", "Special Judge"], "title": "「ACOI2020」音速", "background": "![T1](https://s2.ax1x.com/2020/01/12/loSQJI.png)\n\n防卫省的 乌间 惟臣（Tadaomi Karasuma）老师来到了椚丘中學给予了三年 E 班的同学们重大的任务：在一年内暗杀掉一个超生物（被 茅野 カエデ 取名为杀老师）。于是同学们开始努力地训练。但是很快的，杀老师展现了它的本领，可以以 20 马赫的超高速持久飞行，导致同学们根本碰不到杀老师。于是他们准备找乌间购买一个传送器。", "description": "现在同学们在后山埋伏。同学们对后山足够熟悉，并且后山足够宽广，可以看做一个无限大的平面直角坐标系，而同学们在 $(0,0)$ 这个位置。这时候杀老师在 $(x,y)$ 这个位置捡到了 岡島 大河 所放置的小黄书认真地读了起来。同学们现在可以以自己为圆心，$r$ 为半径画一个圆然后把传送器抛出去，落在圆上一点 $S$，传送器可以在落点处作一条与刚才的圆相切的直线 $PQ$，现在这条直线就是我们的传送器了。\n\n传送器的作用是：把同学们传送到他们所站的点关于 $PQ$ 的对称点。而且他们必须要**传送后移动**到杀老师的位置才能攻击它。现在，乌间看了他们的计划之后十分感叹，但是他有两个问题想问同学：\n\n- 他们用了传送器之后，至少需要移动多远？\n\n- 在保证移动距离最短的方案下，$PQ$ 与 $x$ 轴夹角的 $\\tan$ 值为多少？我们认为夹角在 $[0,180]$ ° 。", "inputFormat": "第一行两个实数 $x,y$，表示杀老师和小黄书的位置，自动抹去无意义的 $0$；   \n第二行一个实数 $r$，意义见题目描述。", "outputFormat": "第一行请输出他们用了传送器之后，至少需要移动的距离，**保留六位小数**。\n     \n第二行请在保证移动距离最短的方案下输出 $PQ$ 与 $x$ 轴夹角的 $\\tan$ 值，**保留二位小数**。  \n\n特殊地，当 $\\tan$ 值无意义的时候，输出 ```Error```；否则，如果有多个角度都可以满足条件，输出 $\\tan$ 值最小的一个，可以把 ```Error``` 视作无穷大。\n\n**注意，$\\tan$ 值为负数的时候，将这个 $\\tan$ 值视作无穷大。夹角指的是那个锐角。**", "hint": "#### 数据范围 \n\n**本题采用捆绑测试**。\n\n- Subtask 1（10 points）：$x,y,r$ 满足 $x^2+y^2=r^2$。     \n- Subtask 2（20 points）：$x,y$ 中至少有一个为 $0$。     \n- Subtask 3（70 points）：数据无特殊限制。    \n\n对于 $100\\%$ 的数据， $0 \\leq |x|,|y|,r \\leq 10^{10}$。\n\n---\n####  提示\n\n1. **本题含有 SPJ**，如果第一个问题的答案与标准答案差的绝对值不大于 $10^{-6}$ 时就能获得该测试点的分数的 $50\\%$。当第一个问题的答案正确时：      \n- 若第二个问题的答案不为 ```Error``` 时，当输出答案与标准答案差的绝对值不大于 $10^{-2}$ 时能得到该测试点的所有分数；\n- 当第二个问题的答案为 ```Error``` 时，只有输出 ```Error``` 才能得到该测试点的所有分数。  \n**因为 SPJ 敏感，如果只能回答第一个问题，也请在第二行随意输出一些值，不要输出 `Error`**。\n\n2. $\\tan$ 值表示在一个 **直角三角形** 中，一个角相对的直角边与其相邻的直角边的比值，比如 $\\tan\\ 45°= 1$。特殊地，$90°$ 的 $\\tan$ 值**无意义**。\n\n3. 和圆只有一个公共交点的直线叫做圆的**切线**，连接切点与圆心的半径**垂直**于切线。", "locale": "zh-CN", "translations": {"en": {"title": "\"ACOI2020\" Speed of Sound.", "background": "![T1](https://s2.ax1x.com/2020/01/12/loSQJI.png)\n\nTeacher Tadaomi Karasuma from the Ministry of Defense came to Kunugigaoka Junior High School and gave the students of Class 3-E an important mission: assassinate a super creature (named Koro-sensei by Kaede Kayano) within one year. So the students began training hard. But soon, Koro-sensei showed his ability: he can fly continuously at an ultra-high speed of 20 Mach, so the students could not even touch him. Therefore, they decided to buy a teleporter from Karasuma.", "description": "Now the students are ambushing in the back mountain. They are very familiar with the terrain, and the back mountain is wide enough to be regarded as an infinite 2D Cartesian coordinate plane. The students are at $(0,0)$. At this moment, Koro-sensei is at $(x,y)$, seriously reading a “little yellow book” left by Taiga Okajima. The students can draw a circle centered at themselves with radius $r$, then throw the teleporter so that it lands at a point $S$ on the circle. At the landing point, the teleporter can create a line $PQ$ tangent to that circle. Now this line is the teleporter.\n\nThe teleporter works as follows: it teleports the students to the point symmetric to where they stand with respect to $PQ$. Also, they must **move after teleporting** to reach Koro-sensei’s position to attack him. After seeing their plan, Karasuma was very impressed, but he has two questions for the students:\n\n- After using the teleporter, what is the minimum distance they need to move?\n\n- Under the plan that guarantees the minimum movement distance, what is the value of $\\tan$ of the angle between $PQ$ and the $x$-axis? We consider the angle to be in $[0,180]^\\circ$.", "inputFormat": "The first line contains two real numbers $x,y$, indicating the positions of Koro-sensei and the little yellow book, with meaningless trailing $0$ automatically removed.  \nThe second line contains one real number $r$, with the meaning described above.", "outputFormat": "On the first line, output the minimum distance they need to move after using the teleporter, **rounded to 6 decimal places**.  \n\nOn the second line, under the plan that guarantees the minimum movement distance, output the value of $\\tan$ of the angle between $PQ$ and the $x$-axis, **rounded to 2 decimal places**.\n\nIn particular, when the $\\tan$ value is undefined, output ```Error```. Otherwise, if multiple angles can satisfy the condition, output the smallest $\\tan$ value. You may treat ```Error``` as $+\\infty$.\n\n**Note: when $\\tan$ is negative, treat this $\\tan$ value as $+\\infty$. The angle refers to the acute angle.**", "hint": "#### Constraints\n\n**This problem uses bundled testdata**.\n\n- Subtask 1 (10 points): $x,y,r$ satisfy $x^2+y^2=r^2$.  \n- Subtask 2 (20 points): at least one of $x,y$ is $0$.  \n- Subtask 3 (70 points): no special constraints on the data.\n\nFor $100\\%$ of the data, $0 \\leq |x|,|y|,r \\leq 10^{10}$.\n\n---\n#### Hint\n\n1. **This problem includes an SPJ**. If the absolute difference between the answer to the first question and the standard answer is at most $10^{-6}$, you can get $50\\%$ of the score for that test point. When the answer to the first question is correct:  \n- If the answer to the second question is not ```Error```, you can get full score for that test point when the absolute difference between your output and the standard answer is at most $10^{-2}$.  \n- If the answer to the second question is ```Error```, only outputting ```Error``` can get full score for that test point.  \n**Because the SPJ is sensitive, if you can only answer the first question, please output any value on the second line, and do not output `Error`.**\n\n2. The $\\tan$ value means: in a **right triangle**, the ratio of the length of the leg opposite an angle to the length of the leg adjacent to it. For example, $\\tan\\ 45^\\circ = 1$. In particular, $\\tan$ at $90^\\circ$ is **undefined**.\n\n3. A line that has exactly one common intersection point with a circle is called a **tangent line** of the circle. The radius connecting the tangency point and the circle center is **perpendicular** to the tangent line.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「ACOI2020」音速", "background": "![T1](https://s2.ax1x.com/2020/01/12/loSQJI.png)\n\n防卫省的 乌间 惟臣（Tadaomi Karasuma）老师来到了椚丘中學给予了三年 E 班的同学们重大的任务：在一年内暗杀掉一个超生物（被 茅野 カエデ 取名为杀老师）。于是同学们开始努力地训练。但是很快的，杀老师展现了它的本领，可以以 20 马赫的超高速持久飞行，导致同学们根本碰不到杀老师。于是他们准备找乌间购买一个传送器。", "description": "现在同学们在后山埋伏。同学们对后山足够熟悉，并且后山足够宽广，可以看做一个无限大的平面直角坐标系，而同学们在 $(0,0)$ 这个位置。这时候杀老师在 $(x,y)$ 这个位置捡到了 岡島 大河 所放置的小黄书认真地读了起来。同学们现在可以以自己为圆心，$r$ 为半径画一个圆然后把传送器抛出去，落在圆上一点 $S$，传送器可以在落点处作一条与刚才的圆相切的直线 $PQ$，现在这条直线就是我们的传送器了。\n\n传送器的作用是：把同学们传送到他们所站的点关于 $PQ$ 的对称点。而且他们必须要**传送后移动**到杀老师的位置才能攻击它。现在，乌间看了他们的计划之后十分感叹，但是他有两个问题想问同学：\n\n- 他们用了传送器之后，至少需要移动多远？\n\n- 在保证移动距离最短的方案下，$PQ$ 与 $x$ 轴夹角的 $\\tan$ 值为多少？我们认为夹角在 $[0,180]$ ° 。", "inputFormat": "第一行两个实数 $x,y$，表示杀老师和小黄书的位置，自动抹去无意义的 $0$；   \n第二行一个实数 $r$，意义见题目描述。", "outputFormat": "第一行请输出他们用了传送器之后，至少需要移动的距离，**保留六位小数**。\n     \n第二行请在保证移动距离最短的方案下输出 $PQ$ 与 $x$ 轴夹角的 $\\tan$ 值，**保留二位小数**。  \n\n特殊地，当 $\\tan$ 值无意义的时候，输出 ```Error```；否则，如果有多个角度都可以满足条件，输出 $\\tan$ 值最小的一个，可以把 ```Error``` 视作无穷大。\n\n**注意，$\\tan$ 值为负数的时候，将这个 $\\tan$ 值视作无穷大。夹角指的是那个锐角。**", "hint": "#### 数据范围 \n\n**本题采用捆绑测试**。\n\n- Subtask 1（10 points）：$x,y,r$ 满足 $x^2+y^2=r^2$。     \n- Subtask 2（20 points）：$x,y$ 中至少有一个为 $0$。     \n- Subtask 3（70 points）：数据无特殊限制。    \n\n对于 $100\\%$ 的数据， $0 \\leq |x|,|y|,r \\leq 10^{10}$。\n\n---\n####  提示\n\n1. **本题含有 SPJ**，如果第一个问题的答案与标准答案差的绝对值不大于 $10^{-6}$ 时就能获得该测试点的分数的 $50\\%$。当第一个问题的答案正确时：      \n- 若第二个问题的答案不为 ```Error``` 时，当输出答案与标准答案差的绝对值不大于 $10^{-2}$ 时能得到该测试点的所有分数；\n- 当第二个问题的答案为 ```Error``` 时，只有输出 ```Error``` 才能得到该测试点的所有分数。  \n**因为 SPJ 敏感，如果只能回答第一个问题，也请在第二行随意输出一些值，不要输出 `Error`**。\n\n2. $\\tan$ 值表示在一个 **直角三角形** 中，一个角相对的直角边与其相邻的直角边的比值，比如 $\\tan\\ 45°= 1$。特殊地，$90°$ 的 $\\tan$ 值**无意义**。\n\n3. 和圆只有一个公共交点的直线叫做圆的**切线**，连接切点与圆心的半径**垂直**于切线。", "locale": "zh-CN"}}}
{"pid": "P6040", "type": "P", "difficulty": 4, "samples": [["5 3 4 1 0\n1 2 3 4 5\n", "27"], ["10 30630 56910 2 0\n7484 99194 86969 17540 29184 68691 91892 81564 93999 74280 \n", "717318"], ["10000000 899999999 923456655 213111 1\n1314520", "9231813656566921"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2020", "单调队列", "O2优化", "动态规划优化"], "title": "「ACOI2020」课后期末考试滑溜滑溜补习班", "background": "![T2](https://s2.ax1x.com/2020/01/12/lopS6f.png)\n\n潮田 渚（Shiota Nagisa）因为理科不大好，自然会被仔细观察学生的杀老师发现，于是渚同学只得加入杀老师举办的课后期末考试滑溜滑溜补习班。至于为什么叫这个名字，额，你不能问我啊。", "description": "在补习班上，因为多个学生会同时有需求，所以杀老师会制造分身用音速移动来回回答问题。\n\n补习班上有 $n$ 个同学，他们每一个人都有一个问题。杀老师为了有序回答学生的问题，把所有学生排成了一列。第 $i$ 个学生的问题有一个困难值 $a_i$，杀老师回答第 $i$ 个学生的问题需要花费 $a_i$ 的精力。杀老师到了哪里，它就要解决那个学生的问题。杀老师最开始会解决序列中第一个同学的问题，他最后会去解决最后一个同学的问题。\n\n杀老师每次解决完一个同学的问题到下一个同学的座位上就要花费 $k$ 点精力值。特殊的，如果杀老师想让自己轻松一点，可以不移动到下一个，可以直接到下两个，下三个，就不用解决跳过的同学的问题了。对应的，它会被学生调侃。受到打击的杀老师自然会花费格外的精力，花费的精力为 $k+(q-p-1) \\times d$（当前位置为 $p$，跳到的位置为 $q$）。\n\n当然的，杀老师也是有速度的啊，并且它想解决学生的一些问题，所以说杀老师最多只会跳过 $x-1$ 个学生，去解决下 $x$ 个学生的问题。", "inputFormat": "第一行五个整数 $n,k,d,x,tp$，表示有 $n$ 个学生，只按顺序去到下一个学生的座位需要花费 $k$ 点精力，每多跳过一个学生就要多花费 $d$ 点精力值，每一次最多只能跳过 $x-1$ 个学生，是否是特殊数据。\n\n- $tp=0$，第二行 $n$ 个整数 $a_{1\\dots n}$，$a_i$ 表示第 $i$ 个学生的问题的困难值为 $a_i$。\n\n- $tp=1$，第二行一个整数 $Seed$，作为种子，然后调用 $rnd$ 函数**依次**生成 $n$ 个整数，作为 $a$ 数组，$a_i$ 表示第 $i$ 个学生的问题的困难值为 $a_i$。\n\n```cpp\ninline int rnd () {\n\tstatic const int MOD = 1e9;\n\treturn Seed = ( 1LL * Seed * 0x66CCFF % MOD + 20120712 ) % MOD;\n}\n```", "outputFormat": "一行一个整数，表示杀老师解决完最后一个同学的问题最少需要花费多少精力。", "hint": "#### 样例解释 #1\n\n杀老师每次不能跳过学生，因此他必须依次移动并解决所有问题，故答案为解决问题所需的精力 $1+2+3+4+5=15$ 与移动所需的精力 $4 \\times 3=12$，所以花费精力之和为 $27$。\n\n------------\n#### 数据范围\n\n**本题采用捆绑测试**。\n\n- Subtask 1（20 points），学生们学习认真听话，留下来的同学也会更少：$tp=0$，$n \\leq 10^3$。     \n- Subtask 2（30 points），杀老师的速度快极了，并且学生们没时间吐槽它：$tp=0$，$n \\leq 10^6$。     \n- Subtask 3（50 points），$tp=1$，其余无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^7$，$0 \\leq k,d,a_i \\leq 10^9$，$1 \\leq x \\leq n-1$。\n\n------------\n#### 提示\n\n对于 $tp=1$ 的数据，$rnd$ 函数只用于减小输入量，标准算法不依赖该数据生成方式。", "locale": "zh-CN", "translations": {"en": {"title": "\"ACOI2020\" After-class Final Exam Slippery Slippery Tutoring Class", "background": "![T2](https://s2.ax1x.com/2020/01/12/lopS6f.png)\n\nShiota Nagisa (潮田 渚) is not very good at science subjects, so Koro-sensei (杀老师), who carefully observes students, would naturally notice. Therefore, Nagisa has to join the after-class final exam Slippery Slippery Tutoring Class held by Koro-sensei. As for why it has this name, well, you cannot ask me.", "description": "In the tutoring class, because multiple students may have needs at the same time, Koro-sensei will create clones and move back and forth at the speed of sound to answer questions.\n\nThere are $n$ students in the class, and each of them has one question. In order to answer students' questions in an orderly way, Koro-sensei lines up all students into a single row. The question of the $i$-th student has a difficulty value $a_i$, and answering the $i$-th student's question costs Koro-sensei $a_i$ energy. Wherever Koro-sensei goes, it must solve that student's question. Koro-sensei will start by solving the first student's question in the sequence, and it will finally go to solve the last student's question.\n\nEach time after solving one student's question and moving to the next student's seat, Koro-sensei needs to spend $k$ energy. Specially, if Koro-sensei wants to make things easier, it can choose not to move to the next one, but jump directly to the second next, the third next, and so on, so it does not need to solve the questions of the skipped students. Correspondingly, it will be teased by the students. Feeling upset, Koro-sensei will naturally spend extra energy, and the energy cost is $k+(q-p-1) \\times d$ (the current position is $p$, and it jumps to position $q$).\n\nOf course, Koro-sensei also has speed, and it still wants to solve some students' questions. Therefore, Koro-sensei will skip at most $x-1$ students at a time, i.e. it will go on to solve the question of the next $x$-th student.", "inputFormat": "The first line contains five integers $n,k,d,x,tp$, meaning there are $n$ students; moving only in order to the next student's seat costs $k$ energy; for each additional skipped student, it costs an extra $d$ energy; each move can skip at most $x-1$ students; and whether this is special testdata.\n\n- If $tp=0$, the second line contains $n$ integers $a_{1\\dots n}$, where $a_i$ is the difficulty value of the $i$-th student's question.\n\n- If $tp=1$, the second line contains one integer $Seed$ as the seed, and then call the $rnd$ function to generate $n$ integers **in order** as the array $a$, where $a_i$ is the difficulty value of the $i$-th student's question.\n\n```cpp\ninline int rnd () {\n\tstatic const int MOD = 1e9;\n\treturn Seed = ( 1LL * Seed * 0x66CCFF % MOD + 20120712 ) % MOD;\n}\n```", "outputFormat": "One line with one integer, meaning the minimum total energy Koro-sensei needs to spend to finish solving the last student's question.", "hint": "#### Sample Explanation #1\n\nKoro-sensei cannot skip students each time, so it must move in order and solve all questions. Therefore, the answer is the energy needed to solve the questions $1+2+3+4+5=15$ plus the energy needed for moving $4 \\times 3=12$, so the total energy cost is $27$.\n\n------------\n\n#### Constraints\n\n**This problem uses bundled testdata.**\n\n- Subtask 1 (20 points): the students study seriously and behave well, so fewer students will remain: $tp=0$, $n \\leq 10^3$.  \n- Subtask 2 (30 points): Koro-sensei is extremely fast, and the students have no time to tease it: $tp=0$, $n \\leq 10^6$.  \n- Subtask 3 (50 points): $tp=1$, with no other special constraints.\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 10^7$, $0 \\leq k,d,a_i \\leq 10^9$, $1 \\leq x \\leq n-1$.\n\n------------\n\n#### Hint\n\nFor $tp=1$ testdata, the $rnd$ function is only used to reduce input size. The standard algorithm does not depend on this generation method.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「ACOI2020」课后期末考试滑溜滑溜补习班", "background": "![T2](https://s2.ax1x.com/2020/01/12/lopS6f.png)\n\n潮田 渚（Shiota Nagisa）因为理科不大好，自然会被仔细观察学生的杀老师发现，于是渚同学只得加入杀老师举办的课后期末考试滑溜滑溜补习班。至于为什么叫这个名字，额，你不能问我啊。", "description": "在补习班上，因为多个学生会同时有需求，所以杀老师会制造分身用音速移动来回回答问题。\n\n补习班上有 $n$ 个同学，他们每一个人都有一个问题。杀老师为了有序回答学生的问题，把所有学生排成了一列。第 $i$ 个学生的问题有一个困难值 $a_i$，杀老师回答第 $i$ 个学生的问题需要花费 $a_i$ 的精力。杀老师到了哪里，它就要解决那个学生的问题。杀老师最开始会解决序列中第一个同学的问题，他最后会去解决最后一个同学的问题。\n\n杀老师每次解决完一个同学的问题到下一个同学的座位上就要花费 $k$ 点精力值。特殊的，如果杀老师想让自己轻松一点，可以不移动到下一个，可以直接到下两个，下三个，就不用解决跳过的同学的问题了。对应的，它会被学生调侃。受到打击的杀老师自然会花费格外的精力，花费的精力为 $k+(q-p-1) \\times d$（当前位置为 $p$，跳到的位置为 $q$）。\n\n当然的，杀老师也是有速度的啊，并且它想解决学生的一些问题，所以说杀老师最多只会跳过 $x-1$ 个学生，去解决下 $x$ 个学生的问题。", "inputFormat": "第一行五个整数 $n,k,d,x,tp$，表示有 $n$ 个学生，只按顺序去到下一个学生的座位需要花费 $k$ 点精力，每多跳过一个学生就要多花费 $d$ 点精力值，每一次最多只能跳过 $x-1$ 个学生，是否是特殊数据。\n\n- $tp=0$，第二行 $n$ 个整数 $a_{1\\dots n}$，$a_i$ 表示第 $i$ 个学生的问题的困难值为 $a_i$。\n\n- $tp=1$，第二行一个整数 $Seed$，作为种子，然后调用 $rnd$ 函数**依次**生成 $n$ 个整数，作为 $a$ 数组，$a_i$ 表示第 $i$ 个学生的问题的困难值为 $a_i$。\n\n```cpp\ninline int rnd () {\n\tstatic const int MOD = 1e9;\n\treturn Seed = ( 1LL * Seed * 0x66CCFF % MOD + 20120712 ) % MOD;\n}\n```", "outputFormat": "一行一个整数，表示杀老师解决完最后一个同学的问题最少需要花费多少精力。", "hint": "#### 样例解释 #1\n\n杀老师每次不能跳过学生，因此他必须依次移动并解决所有问题，故答案为解决问题所需的精力 $1+2+3+4+5=15$ 与移动所需的精力 $4 \\times 3=12$，所以花费精力之和为 $27$。\n\n------------\n#### 数据范围\n\n**本题采用捆绑测试**。\n\n- Subtask 1（20 points），学生们学习认真听话，留下来的同学也会更少：$tp=0$，$n \\leq 10^3$。     \n- Subtask 2（30 points），杀老师的速度快极了，并且学生们没时间吐槽它：$tp=0$，$n \\leq 10^6$。     \n- Subtask 3（50 points），$tp=1$，其余无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^7$，$0 \\leq k,d,a_i \\leq 10^9$，$1 \\leq x \\leq n-1$。\n\n------------\n#### 提示\n\n对于 $tp=1$ 的数据，$rnd$ 函数只用于减小输入量，标准算法不依赖该数据生成方式。", "locale": "zh-CN"}}}
{"pid": "P6041", "type": "P", "difficulty": 5, "samples": [["3 1\n1 1 1\n1 2 3\n1 1\n2 1\n", "5"], ["5 3\n1 2 2 1 1\n1 5 2 4 2\n1 1 2 3\n3 1\n4 2\n5 1\n", "0\n6\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2020", "线段树", "倍增", "二分", "树上启发式合并", "树链剖分", "可持久化线段树"], "title": "「ACOI2020」布丁暗杀计划", "background": "![T3](https://s2.ax1x.com/2020/01/12/lopanO.png)\n\n茅野 カエデ（Kayano Kaede）制定了一个用布丁暗杀杀老师的计划。他们用剩余的鸡蛋加工制成一个布丁。为了外观和味道，他们会在里面加上一些用糯米纸包着的改变口味的食材。为了好看，这些食材从上至下排成了树的模样。在布丁的最底下铺满了对老师炸弹。杀老师吃到那里去之后就会引爆。", "description": "终于，同学们把布丁做好了。最爱吃布丁的茅野开始想，这个布丁有多好吃呢？\n\n一个布丁的好吃程度，取决于里面的改变口味的食材。材料不同的话，颜色和美味度也是不一样的。\n\n布丁里面有 $n$ 种调味食材，有 $n-1$ 个东西连接着，第一种食材在最上面，相当于这一棵树的根。\n\n现在，茅野制定一个布丁的好吃程度与指定的某两个值 $u,k$ 有关，这个好吃程度为，第 $u$ 种食材的 $k$ 级祖先 $v$ 食材的所有 $k$ 级儿子与 $v$ 食材颜色相同的那些 $k$ 级儿子的美味度之和。可以发现，$u$ 或者 $k$ 不同，一般情况下美味度是不同的。所以有 $q$ 个问题想要问你。\n\n**特殊地，如果第 $u$ 种食材没有 $k$ 级祖先，直接输出 $0$ 即可。**", "inputFormat": "第一行两个整数 $n,q$，表示有 $n$ 个食材，$q$ 个询问。\n\n第二行 $n$ 个整数，第 $i$ 个整数表示食材 $i$ 的颜色 $color_i$。\n\n第三行 $n$ 个整数，第 $i$ 个整数表示食材 $i$ 的美味值 $d_i$。\n\n第四行 $n-1$ 个整数，第 $i$ 个整数表示食材 $i+1$ 的父节点 $fa_i$。\n\n接下来 $q$ 行，每行两个整数 $u,k$ 表示询问。", "outputFormat": "有 $q$ 行，每行一个整数，表示询问的结果。", "hint": "#### 样例解释 #1\n![](https://cdn.luogu.com.cn/upload/image_hosting/ap9imym3.png)\n\n食材 $2$ 的 $1$ 级祖先是食材 $1$，食材 $1$ 的 $1$ 级儿子有食材 $2$ 与食材 $3$，食材 $2$ 与食材 $3$ 的颜色都与食材 $1$ 的颜色相同，所以美味度之和为 $2+3=5$。\n\n------------\n#### 数据范围\n**本题采用捆绑测试**。\n\n- Subtask 1（30 points），鸡蛋缺乏，布丁不大：$n \\leq 10^3$，$q \\leq 10^4$。\n- Subtask 2（20 points），食材构成了一条链：$n \\leq 5 \\times 10^5$，$q \\leq 10^5$，$color_i \\leq 10^2$。     \n- Subtask 3（50 points）：数据无特殊限制。 \n\n\n对于 $100\\%$ 的数据，$1 \\leq n,q,color_i \\leq 5 \\times 10^5$，$1 \\leq d_i \\leq 10^5$。\n\n------------\n#### 提示\n\n**第二个子任务中的测试点与第三个子任务中的测试点时限 2S。**", "locale": "zh-CN", "translations": {"en": {"title": "\"ACOI2020\" Pudding Assassination Plan", "background": "![T3](https://s2.ax1x.com/2020/01/12/lopanO.png)\n\nKayano Kaede (茅野 カエデ) made a plan to assassinate Koro-sensei using pudding. They used the remaining eggs to make a pudding. For appearance and taste, they add some ingredients wrapped in rice paper to change the flavor. For better looks, these ingredients are arranged from top to bottom in the shape of a tree. At the very bottom of the pudding, it is filled with bombs for Koro-sensei. When Koro-sensei eats to that part, it will explode.", "description": "Finally, the students finished the pudding. Kaede, who loves pudding the most, started thinking: how tasty is this pudding?\n\nHow tasty a pudding is depends on the flavor-changing ingredients inside. Different ingredients have different colors and tastiness values.\n\nThere are $n$ kinds of flavoring ingredients in the pudding, connected by $n-1$ links. The first ingredient is at the top, which is the root of this tree.\n\nNow, Kaede defines that the tastiness of the pudding depends on two given values $u, k$. This tastiness is defined as follows: let $v$ be the $k$-th ancestor of ingredient $u$. Consider all $k$-th level children of ingredient $v$, and among them, take those $k$-th level children whose color is the same as the color of ingredient $v$. The answer is the sum of the tastiness values of these selected nodes. It can be seen that when $u$ or $k$ changes, in general the tastiness value also changes. Therefore, there are $q$ queries to ask you.\n\n**In particular, if ingredient $u$ does not have a $k$-th ancestor, output $0$ directly.**", "inputFormat": "The first line contains two integers $n, q$, meaning there are $n$ ingredients and $q$ queries.\n\nThe second line contains $n$ integers. The $i$-th integer represents the color of ingredient $i$, $color_i$.\n\nThe third line contains $n$ integers. The $i$-th integer represents the tastiness value of ingredient $i$, $d_i$.\n\nThe fourth line contains $n-1$ integers. The $i$-th integer represents the parent node of the ingredient $i+1$, $fa_i$.\n\nThe next $q$ lines each contain two integers $u, k$, representing a query.", "outputFormat": "There are $q$ lines, each containing one integer, representing the answer to the query.", "hint": "#### Sample Explanation #1\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ap9imym3.png)\n\nThe $1$-st ancestor of ingredient $2$ is ingredient $1$. The $1$-st level children of ingredient $1$ are ingredients $2$ and $3$. The colors of ingredients $2$ and $3$ are both the same as the color of ingredient $1$, so the sum of tastiness values is $2 + 3 = 5$.\n\n------------\n\n#### Constraints\n\n**This problem uses bundled testdata.**\n\n- Subtask 1 (30 points): Eggs are scarce, the pudding is small: $n \\leq 10^3$, $q \\leq 10^4$.\n- Subtask 2 (20 points): The ingredients form a chain: $n \\leq 5 \\times 10^5$, $q \\leq 10^5$, $color_i \\leq 10^2$.\n- Subtask 3 (50 points): No special restrictions on the testdata.\n\nFor $100\\%$ of the testdata, $1 \\leq n, q, color_i \\leq 5 \\times 10^5$, $1 \\leq d_i \\leq 10^5$.\n\n------------\n\n#### Hint\n\n**The time limit for the test points in Subtask 2 and Subtask 3 is 2S.**\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「ACOI2020」布丁暗杀计划", "background": "![T3](https://s2.ax1x.com/2020/01/12/lopanO.png)\n\n茅野 カエデ（Kayano Kaede）制定了一个用布丁暗杀杀老师的计划。他们用剩余的鸡蛋加工制成一个布丁。为了外观和味道，他们会在里面加上一些用糯米纸包着的改变口味的食材。为了好看，这些食材从上至下排成了树的模样。在布丁的最底下铺满了对老师炸弹。杀老师吃到那里去之后就会引爆。", "description": "终于，同学们把布丁做好了。最爱吃布丁的茅野开始想，这个布丁有多好吃呢？\n\n一个布丁的好吃程度，取决于里面的改变口味的食材。材料不同的话，颜色和美味度也是不一样的。\n\n布丁里面有 $n$ 种调味食材，有 $n-1$ 个东西连接着，第一种食材在最上面，相当于这一棵树的根。\n\n现在，茅野制定一个布丁的好吃程度与指定的某两个值 $u,k$ 有关，这个好吃程度为，第 $u$ 种食材的 $k$ 级祖先 $v$ 食材的所有 $k$ 级儿子与 $v$ 食材颜色相同的那些 $k$ 级儿子的美味度之和。可以发现，$u$ 或者 $k$ 不同，一般情况下美味度是不同的。所以有 $q$ 个问题想要问你。\n\n**特殊地，如果第 $u$ 种食材没有 $k$ 级祖先，直接输出 $0$ 即可。**", "inputFormat": "第一行两个整数 $n,q$，表示有 $n$ 个食材，$q$ 个询问。\n\n第二行 $n$ 个整数，第 $i$ 个整数表示食材 $i$ 的颜色 $color_i$。\n\n第三行 $n$ 个整数，第 $i$ 个整数表示食材 $i$ 的美味值 $d_i$。\n\n第四行 $n-1$ 个整数，第 $i$ 个整数表示食材 $i+1$ 的父节点 $fa_i$。\n\n接下来 $q$ 行，每行两个整数 $u,k$ 表示询问。", "outputFormat": "有 $q$ 行，每行一个整数，表示询问的结果。", "hint": "#### 样例解释 #1\n![](https://cdn.luogu.com.cn/upload/image_hosting/ap9imym3.png)\n\n食材 $2$ 的 $1$ 级祖先是食材 $1$，食材 $1$ 的 $1$ 级儿子有食材 $2$ 与食材 $3$，食材 $2$ 与食材 $3$ 的颜色都与食材 $1$ 的颜色相同，所以美味度之和为 $2+3=5$。\n\n------------\n#### 数据范围\n**本题采用捆绑测试**。\n\n- Subtask 1（30 points），鸡蛋缺乏，布丁不大：$n \\leq 10^3$，$q \\leq 10^4$。\n- Subtask 2（20 points），食材构成了一条链：$n \\leq 5 \\times 10^5$，$q \\leq 10^5$，$color_i \\leq 10^2$。     \n- Subtask 3（50 points）：数据无特殊限制。 \n\n\n对于 $100\\%$ 的数据，$1 \\leq n,q,color_i \\leq 5 \\times 10^5$，$1 \\leq d_i \\leq 10^5$。\n\n------------\n#### 提示\n\n**第二个子任务中的测试点与第三个子任务中的测试点时限 2S。**", "locale": "zh-CN"}}}
{"pid": "P6042", "type": "P", "difficulty": 5, "samples": [["5\n1\n2\n3\n4\n5\n", "1\n4\n10\n20\n36\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "递推", "2020", "前缀和", "差分"], "title": "「ACOI2020」学园祭", "background": "![T4](https://s2.ax1x.com/2020/01/12/lopWDS.md.png)\n\n秋天，是学习之秋，食欲之秋，更是，学园祭之秋！随着时间流逝，学园祭也越来越近。终于等到这一天，可是没想到在冲绳岛上邂逅到女装的渚同学的勇次竟然来了！中村 莉櫻（Nakamura Rio）见到这个情况，忙给渚同学换上女装。没办法，勇次已经来了，于是渚同学鼓起勇气迈出了第一步。（为什么自顾自地加提示框啊喂！）", "description": "莉櫻为了利用这个人傻钱多的少爷，尽全力提高消费额，努力地暗示渚同学。没办法，于是渚同学想了一下，提出了一个问题：\n\n给出一个 $n$，定义：\n$$\n\\Gamma(0)=1,\\Gamma(n)={n!}\n$$\n\n$$\nA_i^j=\\frac{\\Gamma(i)}{\\Gamma(j)}\n$$\n求\n$$\n\\sum_{i=1}^n \\sum_{j=1}^i \\sum_{k=1}^j \\gcd(A_{i-j}^j \\times \\Gamma(j),A_{j-k}^k \\times \\Gamma(k)) \n$$\n\n渚同学念着莉櫻举起的对话板上写的字：如果不能在规定时间回答出问题的话，就要把菜单全部买一遍哦！\n\n尽管勇次钱多，但是他并不想吃得太多，因为这个问题有 $T$ 个小问题！\n\n**由于答案可能太大，请将答案对 $10086001$ 取模。**", "inputFormat": "**本题有多组数据**。\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n只有一行一个整数 $n$。", "outputFormat": "对于每组数据，一行一个整数，表示问题的答案对 $10086001$ 取模后的值。", "hint": "#### 数据范围\n**本题采用捆绑测试**。\n\n- Subtask 1（20 points）：$T \\leq 10^3$，$n \\leq 10^2$。   \n- Subtask 2（30 points）：$T \\leq 10^6$，$n \\leq 5 \\times 10^3$。  \n- Subtask 3（50 points）：$T \\leq 10^6$，$n \\leq 10^6$。   \n\n对于 $100\\%$ 的数据，$1 \\leq T,n \\leq 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "\"ACOI2020\" School Festival", "background": "![T4](https://s2.ax1x.com/2020/01/12/lopWDS.md.png)\n\nAutumn is the season of studying, the season of eating, and, even more, the season of the school festival. As time passes, the school festival is getting closer and closer. Finally, the day has come, but unexpectedly, Yuji, who once ran into Nagisa wearing women’s clothing on Okinawa Island, actually showed up. Nakamura Rio (Nakamura Rio) saw this and hurriedly had Nagisa put on women’s clothing. There was no choice: since Yuji was already here, Nagisa gathered his courage and took the first step. (Why are you adding a hint box on your own!)", "description": "To take advantage of this rich-but-foolish young master and increase his spending as much as possible, Rio tried hard to hint at Nagisa. With no other choice, Nagisa thought for a while and raised a question:\n\nGiven an $n$, define:\n$$\n\\Gamma(0)=1,\\Gamma(n)={n!}\n$$\n\n$$\nA_i^j=\\frac{\\Gamma(i)}{\\Gamma(j)}\n$$\nCompute:\n$$\n\\sum_{i=1}^n \\sum_{j=1}^i \\sum_{k=1}^j \\gcd(A_{i-j}^j \\times \\Gamma(j),A_{j-k}^k \\times \\Gamma(k)) \n$$\n\nNagisa read out the words written on the conversation board Rio held up: If you cannot answer the question within the given time, you have to buy the entire menu once!\n\nAlthough Yuji has a lot of money, he does not want to eat too much, because this problem has $T$ subproblems.\n\n**Since the answer may be very large, output the answer modulo $10086001$.**", "inputFormat": "**This problem contains multiple test cases.**\n\nThe first line contains an integer $T$, the number of test cases.\n\nFor each test case:\n\nThere is only one line with one integer $n$.", "outputFormat": "For each test case, output one integer per line: the answer modulo $10086001$.", "hint": "#### Constraints\n\n**This problem uses bundled testdata.**\n\n- Subtask 1 (20 points): $T \\leq 10^3$, $n \\leq 10^2$.  \n- Subtask 2 (30 points): $T \\leq 10^6$, $n \\leq 5 \\times 10^3$.  \n- Subtask 3 (50 points): $T \\leq 10^6$, $n \\leq 10^6$.  \n\nFor $100\\%$ of the testdata, $1 \\leq T,n \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「ACOI2020」学园祭", "background": "![T4](https://s2.ax1x.com/2020/01/12/lopWDS.md.png)\n\n秋天，是学习之秋，食欲之秋，更是，学园祭之秋！随着时间流逝，学园祭也越来越近。终于等到这一天，可是没想到在冲绳岛上邂逅到女装的渚同学的勇次竟然来了！中村 莉櫻（Nakamura Rio）见到这个情况，忙给渚同学换上女装。没办法，勇次已经来了，于是渚同学鼓起勇气迈出了第一步。（为什么自顾自地加提示框啊喂！）", "description": "莉櫻为了利用这个人傻钱多的少爷，尽全力提高消费额，努力地暗示渚同学。没办法，于是渚同学想了一下，提出了一个问题：\n\n给出一个 $n$，定义：\n$$\n\\Gamma(0)=1,\\Gamma(n)={n!}\n$$\n\n$$\nA_i^j=\\frac{\\Gamma(i)}{\\Gamma(j)}\n$$\n求\n$$\n\\sum_{i=1}^n \\sum_{j=1}^i \\sum_{k=1}^j \\gcd(A_{i-j}^j \\times \\Gamma(j),A_{j-k}^k \\times \\Gamma(k)) \n$$\n\n渚同学念着莉櫻举起的对话板上写的字：如果不能在规定时间回答出问题的话，就要把菜单全部买一遍哦！\n\n尽管勇次钱多，但是他并不想吃得太多，因为这个问题有 $T$ 个小问题！\n\n**由于答案可能太大，请将答案对 $10086001$ 取模。**", "inputFormat": "**本题有多组数据**。\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n只有一行一个整数 $n$。", "outputFormat": "对于每组数据，一行一个整数，表示问题的答案对 $10086001$ 取模后的值。", "hint": "#### 数据范围\n**本题采用捆绑测试**。\n\n- Subtask 1（20 points）：$T \\leq 10^3$，$n \\leq 10^2$。   \n- Subtask 2（30 points）：$T \\leq 10^6$，$n \\leq 5 \\times 10^3$。  \n- Subtask 3（50 points）：$T \\leq 10^6$，$n \\leq 10^6$。   \n\n对于 $100\\%$ 的数据，$1 \\leq T,n \\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P6043", "type": "P", "difficulty": 7, "samples": [["5\n5 3\n7 3\n9 6\n100 50\n44 22\n\n", "26\n64\n466\n41441083\n461961723\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 2000, 2000, 2000, 2000, 2000, 5000, 5000, 5000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2020", "倍增", "O2优化", "快速傅里叶变换 FFT", "快速数论变换 NTT"], "title": "「ACOI2020」修学旅行", "background": "![T5](https://s2.ax1x.com/2020/01/12/loS0Wq.md.png)\n\n第一学期开学没多久，E 班的各位就要去修学旅行了！", "description": "现在，六个人 赤羽 業，杉野 友人，奧田 愛美，茅野 楓，神崎 有希子，潮田 渚 为一组，他们将在京都进行一次暗杀旅行。他们的目标仍然是狙击杀老师。政府同时派来了职业狙击手 赤红之眼。但是完成任务的同时，他们想让快乐度尽量的高。\n\n聪明的神崎 有希子（Kanzaki Yukiko）终于求出了快乐度的表达式，令人感到震惊的是，快乐度竟然和旅行景点个数和暗杀杀老师次数有关！\n\n假设他们经过了 $n$ 个景点，暗杀了 $m$ 次杀老师，且定义：\n\n$$\n\\Gamma(a,b)=\\left\\{\n    \\begin{aligned}\n    & 1,a>b&\\\\\n    &  \\prod_{i=a}^b i,a \\le b&\\\\\n    \\end{aligned}\n    \\right.\n$$\n\n那么快乐度为：\n\n$$\n\\sum_{i=0}^m \\lgroup \\frac{\\sqrt{\\sum_{j=0}^i (C_i^j)^2C_{n+2i-j}^{2i}}}{\\Gamma(n+1,n+i)} \\times \\Gamma(n-i+1,n) \\rgroup \n$$\n\n**我们保证** $\\frac{\\sqrt{\\sum_{j=0}^i (C_i^j)^2C_{n+2i-j}^{2i}}}{\\Gamma(n+1,n+i)} \\times \\Gamma(n-i+1,n)$ **是一个整数。**\n\n现在他们有 $T$ 个问题想要问你，如果他们经过了 $n$ 个景点并且暗杀 $m$ 次杀老师，能否告诉他们快乐度呢？\n\n**由于答案可能太大，请将答案对 $998244353$ 取模。**", "inputFormat": "**本题有多组数据**。\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n只有一行两个整数 $n$ 和 $m$。", "outputFormat": "对于每组数据，只有一行一个整数，表示他们经过了 $n$ 个景点，暗杀了 $m$ 次杀老师的快乐度对 $998244353$ 取模后的值。\n\n#### 样例有更新", "hint": "#### 数据范围\n\n**本题采用捆绑测试**。\n\n- Subtask 1（10 points）：$T \\leq 10$，$n,m \\leq 10$。     \n- Subtask 2（20 points）：$T \\leq 100$，$n,m \\leq 5 \\times 10^4$。      \n- Subtask 3（30 points）：$T \\leq 50$，$n,m \\leq 9 \\times 10^8$。  \n- Subtask 4（40 points）：数据无特殊限制。  \n\n对于 $100\\%$ 的数据，$m \\leq n$，$1 \\leq T \\le 10^2$，$1 \\leq n,m \\leq 9 \\times 10^8$。\n\n---\n#### 提示\n\n**第三个子任务中的测试点时限 2S，第四个子任务中的测试点时限 5S。**", "locale": "zh-CN", "translations": {"en": {"title": "\"ACOI2020\" Study Trip", "background": "![T5](https://s2.ax1x.com/2020/01/12/loS0Wq.md.png)\n\nNot long after the first semester begins, everyone in Class E is going on a study trip.", "description": "Now, six people—Akabane Karma, Sugino Tomohito, Okuda Manami, Kayano Kaede, Kanzaki Yukiko, and Shiota Nagisa—form a group. They will go on an assassination trip in Kyoto. Their goal is still to snipe and kill their teacher. The government has also sent a professional sniper, \"Akame no Eye\". While completing the mission, they want the happiness value to be as large as possible.\n\nThe clever Kanzaki Yukiko (Kanzaki Yukiko) finally worked out the expression for the happiness value. Shockingly, the happiness value is actually related to the number of sightseeing spots in the trip and the number of times they assassinate their teacher.\n\nSuppose they pass through $n$ sightseeing spots and assassinate their teacher $m$ times, and define:\n\n$$\n\\Gamma(a,b)=\\left\\{\n    \\begin{aligned}\n    & 1,a>b&\\\\\n    &  \\prod_{i=a}^b i,a \\le b&\\\\\n    \\end{aligned}\n    \\right.\n$$\n\nThen the happiness value is:\n\n$$\n\\sum_{i=0}^m \\lgroup \\frac{\\sqrt{\\sum_{j=0}^i (C_i^j)^2C_{n+2i-j}^{2i}}}{\\Gamma(n+1,n+i)} \\times \\Gamma(n-i+1,n) \\rgroup \n$$\n\n**We guarantee** that $\\frac{\\sqrt{\\sum_{j=0}^i (C_i^j)^2C_{n+2i-j}^{2i}}}{\\Gamma(n+1,n+i)} \\times \\Gamma(n-i+1,n)$ **is an integer.**\n\nNow they have $T$ questions to ask you. If they pass through $n$ sightseeing spots and assassinate their teacher $m$ times, can you tell them the happiness value?\n\n**Since the answer may be very large, output the answer modulo $998244353$.**", "inputFormat": "**This problem contains multiple test cases.**\n\nThe first line contains an integer $T$, the number of test cases.\n\nFor each test case:\n\nThere is only one line with two integers $n$ and $m$.", "outputFormat": "For each test case, output one line containing one integer: the happiness value modulo $998244353$ when they pass through $n$ sightseeing spots and assassinate their teacher $m$ times.\n\n#### The sample has been updated.", "hint": "#### Constraints\n\n**This problem uses bundled testdata.**\n\n- Subtask 1 (10 points): $T \\leq 10$, $n,m \\leq 10$.  \n- Subtask 2 (20 points): $T \\leq 100$, $n,m \\leq 5 \\times 10^4$.  \n- Subtask 3 (30 points): $T \\leq 50$, $n,m \\leq 9 \\times 10^8$.  \n- Subtask 4 (40 points): No special constraints on the testdata.  \n\nFor $100\\%$ of the testdata, $m \\leq n$, $1 \\leq T \\le 10^2$, $1 \\leq n,m \\leq 9 \\times 10^8$.\n\n---\n\n#### Notes\n\n**The time limit is 2 s for the test points in the third subtask, and 5 s for the test points in the fourth subtask.**\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「ACOI2020」修学旅行", "background": "![T5](https://s2.ax1x.com/2020/01/12/loS0Wq.md.png)\n\n第一学期开学没多久，E 班的各位就要去修学旅行了！", "description": "现在，六个人 赤羽 業，杉野 友人，奧田 愛美，茅野 楓，神崎 有希子，潮田 渚 为一组，他们将在京都进行一次暗杀旅行。他们的目标仍然是狙击杀老师。政府同时派来了职业狙击手 赤红之眼。但是完成任务的同时，他们想让快乐度尽量的高。\n\n聪明的神崎 有希子（Kanzaki Yukiko）终于求出了快乐度的表达式，令人感到震惊的是，快乐度竟然和旅行景点个数和暗杀杀老师次数有关！\n\n假设他们经过了 $n$ 个景点，暗杀了 $m$ 次杀老师，且定义：\n\n$$\n\\Gamma(a,b)=\\left\\{\n    \\begin{aligned}\n    & 1,a>b&\\\\\n    &  \\prod_{i=a}^b i,a \\le b&\\\\\n    \\end{aligned}\n    \\right.\n$$\n\n那么快乐度为：\n\n$$\n\\sum_{i=0}^m \\lgroup \\frac{\\sqrt{\\sum_{j=0}^i (C_i^j)^2C_{n+2i-j}^{2i}}}{\\Gamma(n+1,n+i)} \\times \\Gamma(n-i+1,n) \\rgroup \n$$\n\n**我们保证** $\\frac{\\sqrt{\\sum_{j=0}^i (C_i^j)^2C_{n+2i-j}^{2i}}}{\\Gamma(n+1,n+i)} \\times \\Gamma(n-i+1,n)$ **是一个整数。**\n\n现在他们有 $T$ 个问题想要问你，如果他们经过了 $n$ 个景点并且暗杀 $m$ 次杀老师，能否告诉他们快乐度呢？\n\n**由于答案可能太大，请将答案对 $998244353$ 取模。**", "inputFormat": "**本题有多组数据**。\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n只有一行两个整数 $n$ 和 $m$。", "outputFormat": "对于每组数据，只有一行一个整数，表示他们经过了 $n$ 个景点，暗杀了 $m$ 次杀老师的快乐度对 $998244353$ 取模后的值。\n\n#### 样例有更新", "hint": "#### 数据范围\n\n**本题采用捆绑测试**。\n\n- Subtask 1（10 points）：$T \\leq 10$，$n,m \\leq 10$。     \n- Subtask 2（20 points）：$T \\leq 100$，$n,m \\leq 5 \\times 10^4$。      \n- Subtask 3（30 points）：$T \\leq 50$，$n,m \\leq 9 \\times 10^8$。  \n- Subtask 4（40 points）：数据无特殊限制。  \n\n对于 $100\\%$ 的数据，$m \\leq n$，$1 \\leq T \\le 10^2$，$1 \\leq n,m \\leq 9 \\times 10^8$。\n\n---\n#### 提示\n\n**第三个子任务中的测试点时限 2S，第四个子任务中的测试点时限 5S。**", "locale": "zh-CN"}}}
{"pid": "P6044", "type": "P", "difficulty": 3, "samples": [["6 3\n3 8\n4 12\n2 6\n1 10\n5 9\n11 12\n", "4\n1 2 4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2018", "堆", "POI（波兰）", "Special Judge"], "title": "[POI 2018] Prawnicy", "background": "**题目译自 [POI XXV - I etap](https://sio2.mimuw.edu.pl/c/oi25-1/dashboard/) 「[Prawnicy](https://sio2.mimuw.edu.pl/c/oi25-1/p/pra/)」**", "description": "“Bajtazar 父子”律师事务所刚刚收到一位非常重要的客户的订单。案件严重、紧急，需要与律师事务所的律师举行会议。每个律师都有一段固定的空闲时间可以参加会议。你应该选择这样的 $k$ 位律师，以便召开会议的时间（即他们都空闲的时间）尽可能长。\n\n[简要题意](https://www.luogu.com.cn/problem/U252799)", "inputFormat": "第一行包含两个整数 $n$ 和 $k\\ (1\\le k\\le n)$，以一个空格隔开，表示事务所雇用的律师人数和召开会议所需的律师人数。\n\n接下来 $n$ 行，第 $i$ 行包含两个整数 $a_i$ 和 $b_i\\ (1\\le a_i<b_i\\le 10^9)$，以一个空格隔开，表示第 $i$ 个律师在**时刻 $a_i$ 和时刻 $b_i$ 之间**是空闲的。", "outputFormat": "第一行输出一个整数，表示会议可能的最大时长。你可以假设你能够召开至少 $1$ 人的会议。\n\n第二行输出空格分隔的 $k$ 个数，代表参加会议的律师编号（从 $1$ 开始）。如果有多个正确答案，您的程序应输出其中任何一个。", "hint": "#### 样例解释\n\n三位律师会议可能的最大时长是 $4$。编号为 $1$、$2$ 和 $4$ 的律师可以参加，持续时间从 $4$ 到 $8$。另一个同样好的方案是让编号为 $2$、$4$ 和 $5$ 的律师参加，持续时间从 $5$ 到 $9$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/187yuqy1.png)\n\n#### 附加样例\n\n参见 `pra/pra*.in` 和 `pra/pra*.out`：\n\n- 附加样例 $1$：$1$ 组数据，$n=7$，$k=3$，且选择律师的方案有两种。\n\n- 附加样例 $2$：$1$ 组数据，$n=k=1000$，$a_i=i$，$b_i=10^6+i$；\n\n- 附加样例 $3$：$1$ 组数据，$n=1000$，$k=1$，$a_i=2i-1$，$b_i=2i$；\n\n#### 数据范围与提示\n\n测试集分为以下子任务。每个子任务的测试由一个或多个单独的测试组组成。\n\n| Subtask # | 额外限制                         | 分值  |\n|:---------:|:----------------------------:|:---:|\n| $1$         | $n\\le 20$       | $20$  |\n| $2$         | $n\\le 300$，$a_i,b_i\\le 300$      | $15$  |\n| $3$         | $n\\le 5000$       | $15$  |\n| $4$         | $n\\le 10^6$，$k\\in \\{1,n\\}$       | $15$  |\n| $5$         | $n\\le 10^6$       | $35$  |\n\n如果你的程序在第一行输出了正确的时长，但其余的输出是错误的，那么你将获得 $40\\%$ 的分数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2018] Prawnicy", "background": "**题目译自 [POI XXV - I etap](https://sio2.mimuw.edu.pl/c/oi25-1/dashboard/) 「[Prawnicy](https://sio2.mimuw.edu.pl/c/oi25-1/p/pra/)」**", "description": "“Bajtazar 父子”律师事务所刚刚收到一位非常重要的客户的订单。案件严重、紧急，需要与律师事务所的律师举行会议。每个律师都有一段固定的空闲时间可以参加会议。你应该选择这样的 $k$ 位律师，以便召开会议的时间（即他们都空闲的时间）尽可能长。\n\n[简要题意](https://www.luogu.com.cn/problem/U252799)", "inputFormat": "第一行包含两个整数 $n$ 和 $k\\ (1\\le k\\le n)$，以一个空格隔开，表示事务所雇用的律师人数和召开会议所需的律师人数。\n\n接下来 $n$ 行，第 $i$ 行包含两个整数 $a_i$ 和 $b_i\\ (1\\le a_i<b_i\\le 10^9)$，以一个空格隔开，表示第 $i$ 个律师在**时刻 $a_i$ 和时刻 $b_i$ 之间**是空闲的。", "outputFormat": "第一行输出一个整数，表示会议可能的最大时长。你可以假设你能够召开至少 $1$ 人的会议。\n\n第二行输出空格分隔的 $k$ 个数，代表参加会议的律师编号（从 $1$ 开始）。如果有多个正确答案，您的程序应输出其中任何一个。", "hint": "#### 样例解释\n\n三位律师会议可能的最大时长是 $4$。编号为 $1$、$2$ 和 $4$ 的律师可以参加，持续时间从 $4$ 到 $8$。另一个同样好的方案是让编号为 $2$、$4$ 和 $5$ 的律师参加，持续时间从 $5$ 到 $9$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/187yuqy1.png)\n\n#### 附加样例\n\n参见 `pra/pra*.in` 和 `pra/pra*.out`：\n\n- 附加样例 $1$：$1$ 组数据，$n=7$，$k=3$，且选择律师的方案有两种。\n\n- 附加样例 $2$：$1$ 组数据，$n=k=1000$，$a_i=i$，$b_i=10^6+i$；\n\n- 附加样例 $3$：$1$ 组数据，$n=1000$，$k=1$，$a_i=2i-1$，$b_i=2i$；\n\n#### 数据范围与提示\n\n测试集分为以下子任务。每个子任务的测试由一个或多个单独的测试组组成。\n\n| Subtask # | 额外限制                         | 分值  |\n|:---------:|:----------------------------:|:---:|\n| $1$         | $n\\le 20$       | $20$  |\n| $2$         | $n\\le 300$，$a_i,b_i\\le 300$      | $15$  |\n| $3$         | $n\\le 5000$       | $15$  |\n| $4$         | $n\\le 10^6$，$k\\in \\{1,n\\}$       | $15$  |\n| $5$         | $n\\le 10^6$       | $35$  |\n\n如果你的程序在第一行输出了正确的时长，但其余的输出是错误的，那么你将获得 $40\\%$ 的分数。", "locale": "zh-CN"}}}
{"pid": "P6045", "type": "P", "difficulty": 3, "samples": [["2", "650"], ["105383595", "114514"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2020"], "title": "后缀树", "background": "Eztsu 是一个可爱的女孩子，最近她学习了[后缀树](https://www.luogu.com.cn/blog/EternalAlexander/xuan-ku-hou-zhui-shu-mo-shu)，并打算用它来解决如下问题。", "description": "对于一个字符串 $S$，我们定义 $|S|$ 表示 $S$ 的长度。\n\n接着，我们定义 $S_i$ 表示 $S$ 中第 $i$ 个字符，$S_{L...R}$ 表示由 $S$ 中从左往右数，第 $L$ 个字符到第 $R$ 个字符依次连接形成的字符串。\n\n给定 $n$，求有多少种不同的满足下列要求的串 $S$：\n\n- $|S|=n$。\n- $S$ 中仅包含小写字母。\n- 不存在整数 $i \\in [1,n)$ 使得 $S_{1...i}$ 是 $S_{i+1...n}$ 的子串。\n\n对于第三个限制，用通俗一点的说法解释的话，就是不存在一种将这个串分成两段的方式，使得前面一段是后面一段的子串。\n\n两个串 $S$ 和 $T$ 不同当且仅当 $|S|\\neq|T|$ 或 $\\exists i \\in [1,|S|] S_i \\neq T_i$。如果你不知道这是什么意思，你可以理解为它们看起来不同。\n\n可怜的 Eztsu 不会做，所以你要帮她做这道题。\n\n答案可能很大，你只需要输出答案对 $998244353$ 取模的值。\n\n题面补充：\n\n$S$ 是 $T$ 的子串当且仅当存在 $L,R \\in [1,|T|]$ 使得 $T_{L...R}=S$。", "inputFormat": "一行一个正整数 $n$，意义见题目描述。", "outputFormat": "一行一个整数，答案对 $998244353$ 取模的值。", "hint": "#### 样例解释\n\n对于第一组样例，不难发现，这个串符合题意当且仅当两个字符不同，因此答案为 $26 \\times 26 - 26$，可以理解为两个字符任意的方案数减去两个字符相同的方案数。\n\n---\n\n#### 数据范围\n\n**「本题采用捆绑测试」**\n\n对于所有测试点，保证 $1 \\leq n \\leq 10^9$。\n\n$\\text{Subtask 1 (17 pts)}$ $n \\leq 4$。\n\n$\\text{Subtask 2 (78 pts)}$ $n \\leq 2\\times 10^3$。\n\n$\\text{Subtask 3 (5 pts)}$ 没有特殊限制。\n\n---\n\n#### 提示\n\n小写字母一共有 $26$ 个。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "后缀树", "background": "Eztsu 是一个可爱的女孩子，最近她学习了[后缀树](https://www.luogu.com.cn/blog/EternalAlexander/xuan-ku-hou-zhui-shu-mo-shu)，并打算用它来解决如下问题。", "description": "对于一个字符串 $S$，我们定义 $|S|$ 表示 $S$ 的长度。\n\n接着，我们定义 $S_i$ 表示 $S$ 中第 $i$ 个字符，$S_{L...R}$ 表示由 $S$ 中从左往右数，第 $L$ 个字符到第 $R$ 个字符依次连接形成的字符串。\n\n给定 $n$，求有多少种不同的满足下列要求的串 $S$：\n\n- $|S|=n$。\n- $S$ 中仅包含小写字母。\n- 不存在整数 $i \\in [1,n)$ 使得 $S_{1...i}$ 是 $S_{i+1...n}$ 的子串。\n\n对于第三个限制，用通俗一点的说法解释的话，就是不存在一种将这个串分成两段的方式，使得前面一段是后面一段的子串。\n\n两个串 $S$ 和 $T$ 不同当且仅当 $|S|\\neq|T|$ 或 $\\exists i \\in [1,|S|] S_i \\neq T_i$。如果你不知道这是什么意思，你可以理解为它们看起来不同。\n\n可怜的 Eztsu 不会做，所以你要帮她做这道题。\n\n答案可能很大，你只需要输出答案对 $998244353$ 取模的值。\n\n题面补充：\n\n$S$ 是 $T$ 的子串当且仅当存在 $L,R \\in [1,|T|]$ 使得 $T_{L...R}=S$。", "inputFormat": "一行一个正整数 $n$，意义见题目描述。", "outputFormat": "一行一个整数，答案对 $998244353$ 取模的值。", "hint": "#### 样例解释\n\n对于第一组样例，不难发现，这个串符合题意当且仅当两个字符不同，因此答案为 $26 \\times 26 - 26$，可以理解为两个字符任意的方案数减去两个字符相同的方案数。\n\n---\n\n#### 数据范围\n\n**「本题采用捆绑测试」**\n\n对于所有测试点，保证 $1 \\leq n \\leq 10^9$。\n\n$\\text{Subtask 1 (17 pts)}$ $n \\leq 4$。\n\n$\\text{Subtask 2 (78 pts)}$ $n \\leq 2\\times 10^3$。\n\n$\\text{Subtask 3 (5 pts)}$ 没有特殊限制。\n\n---\n\n#### 提示\n\n小写字母一共有 $26$ 个。", "locale": "zh-CN"}}}
{"pid": "P6046", "type": "P", "difficulty": 5, "samples": [["3\n3 1 2", "2 0 1"], ["3\n1 2 3", "499122177 499122177 2"], ["5\n1 4 2 3 5", "499122178 249561091 665496236 582309207 4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "数学", "2020", "期望"], "title": "纯粹容器", "background": "白王正在挑选容器。", "description": "白王制造了 $n$ 个容器，并将它们排成了一队，从左到右依次编号为 $1 \\sim n$。第 $i$ 个容器的**强度**为 $a_i$，保证 $a_i$ 互不相同。为了挑选出最纯粹的容器，白王会进行 $n-1$ 轮操作，每轮操作中，他会等概率随机挑选两个 **位置相邻** 且 **未被击倒** 的容器，令它们进行决斗，在一次决斗中，强度较小的容器将会被击倒并移出队列。\n\n显然最后留下的是强度最大的容器，但是，可怜的容器们很想知道自己能够活多久，于是，它们请你对每个容器求出它存活轮数的期望。答案对 $998244353$ 取模。\n\n一个容器的存活轮数为最大的非负整数 $x < n$ 满足它在第 $x$ 轮未被击倒。\n\n两个容器 $i$ 和 $j$ 位置相邻当且仅当不存在 $k$ 满足 $i<k<j$ 且 $k$ 号容器未被击倒。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数 $a_1, a_2,\\cdots,a_n$，意义见题目描述。", "outputFormat": "一行 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个容器的存活轮数的期望。为了避免浮点误差，保证答案可以表示为最简分数 $\\frac{p}{q}$，你只需要输出一个 $x (0 \\leq x < 998244353)$ 使得 $qx \\equiv p \\pmod {998244353}$。\n", "hint": "#### 样例解释\n\n在第一组样例中，第一个容器无论如何不可能被击倒，第二个容器在第一轮一定会被击倒，第三个容器第一轮一定不被击倒，第二轮一定被击倒。\n\n第二组样例的真实答案为 $\\frac{1}{2}$，$\\frac{1}{2}$，$2$。\n\n---\n\n#### 数据范围\n\n对于所有测试点，保证 $1 \\leq n \\leq 50$，$1 \\leq a_i \\leq n$，$a_i$ 两两不同。\n\n$\\text{Subtask 1 (2 pts)}$ $n \\leq 2$。\n\n$\\text{Subtask 2 (23 pts)}$ $n \\leq 6$。\n\n$\\text{Subtask 3 (31 pts)}$ $n \\leq 18$。\n\n$\\text{Subtask 4 (19 pts)}​$ $a_i = i$。\n\n$\\text{Subtask 5 (25 pts)}$ 无特殊限制。\n\n---\n\n#### 提示\n\n如果你不知道怎么对分数取模，可以参考[这里](https://www.luogu.com.cn/problem/P3811)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "纯粹容器", "background": "白王正在挑选容器。", "description": "白王制造了 $n$ 个容器，并将它们排成了一队，从左到右依次编号为 $1 \\sim n$。第 $i$ 个容器的**强度**为 $a_i$，保证 $a_i$ 互不相同。为了挑选出最纯粹的容器，白王会进行 $n-1$ 轮操作，每轮操作中，他会等概率随机挑选两个 **位置相邻** 且 **未被击倒** 的容器，令它们进行决斗，在一次决斗中，强度较小的容器将会被击倒并移出队列。\n\n显然最后留下的是强度最大的容器，但是，可怜的容器们很想知道自己能够活多久，于是，它们请你对每个容器求出它存活轮数的期望。答案对 $998244353$ 取模。\n\n一个容器的存活轮数为最大的非负整数 $x < n$ 满足它在第 $x$ 轮未被击倒。\n\n两个容器 $i$ 和 $j$ 位置相邻当且仅当不存在 $k$ 满足 $i<k<j$ 且 $k$ 号容器未被击倒。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数 $a_1, a_2,\\cdots,a_n$，意义见题目描述。", "outputFormat": "一行 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个容器的存活轮数的期望。为了避免浮点误差，保证答案可以表示为最简分数 $\\frac{p}{q}$，你只需要输出一个 $x (0 \\leq x < 998244353)$ 使得 $qx \\equiv p \\pmod {998244353}$。\n", "hint": "#### 样例解释\n\n在第一组样例中，第一个容器无论如何不可能被击倒，第二个容器在第一轮一定会被击倒，第三个容器第一轮一定不被击倒，第二轮一定被击倒。\n\n第二组样例的真实答案为 $\\frac{1}{2}$，$\\frac{1}{2}$，$2$。\n\n---\n\n#### 数据范围\n\n对于所有测试点，保证 $1 \\leq n \\leq 50$，$1 \\leq a_i \\leq n$，$a_i$ 两两不同。\n\n$\\text{Subtask 1 (2 pts)}$ $n \\leq 2$。\n\n$\\text{Subtask 2 (23 pts)}$ $n \\leq 6$。\n\n$\\text{Subtask 3 (31 pts)}$ $n \\leq 18$。\n\n$\\text{Subtask 4 (19 pts)}​$ $a_i = i$。\n\n$\\text{Subtask 5 (25 pts)}$ 无特殊限制。\n\n---\n\n#### 提示\n\n如果你不知道怎么对分数取模，可以参考[这里](https://www.luogu.com.cn/problem/P3811)。", "locale": "zh-CN"}}}
{"pid": "P6047", "type": "P", "difficulty": 6, "samples": [["5 2\n3 9 1 9 9\n9 9 1 9 3\n2 1\n5 4", "6"], ["5 1\n9 9 9 9 1\n1 9 9 9 9\n3 3", "81"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "贪心", "2020", "排序", "斜率优化"], "title": "丝之割", "background": "Pharloom 是一个神秘的王国，[丝线与歌](https://www.bilibili.com/video/av43623335)是那里最强大的力量。多弦琴是 Pharloom 的一种强大武器，正如多项式是 OI 中的强大武器。\n\n因为你很讨厌多项式，你决定摧毁多弦琴。", "description": "下面这部分题面只是为了帮助你理解题意，并没有详细的解释。更为严谨清晰的叙述见形式化题意。\n\n多弦琴由两根支柱和连接两根支柱的 $m$ 条弦组成。每根支柱上都均匀安放着 $n$ 个固定点，第 $i$ 条弦连接上方支柱的第 $u_i$ 个固定点和下方支柱的第 $v_i$ 个固定点。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/14igq7bn.png)\n\n> 上图是一把多弦琴\n\n为了摧毁多弦琴，你可以进行若干次切割操作。在一次切割操作中，你可以选择上方支柱的某一个固定点 $u$ 和下方支柱的一个固定点 $v$，所有被 $u$ 到 $v$ 的连线**从左到右**穿过的弦都将被破坏。但同时，你需要付出 $a_u \\times b_v$ 的代价。\n\n形式化题意：有 $m$ 条弦，一条弦可以抽象为一个二元组 $(u,v)$，你可以进行任意次切割操作，一次切割操作你将选择两个下标 $i$ 和 $j$ 满足 $i,j \\in [1,n]$，然后所有满足 $u>i,v<j$ 的弦 $(u,v)$ 都将被破坏，同时你将付出 $a_i \\times b_j​$ 的代价。求破坏所有弦的最小代价和。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数 $a_1,a_2,\\dots,a_n$。\n\n第三行 $n$ 个整数 $b_1,b_2,\\dots,b_n$。\n\n接下来 $m$ 行每行两个整数 $u,v$，表示有一条弦 $(u,v)$。\n\n以上输入的意义见题目描述。", "outputFormat": "一行一个整数，答案。", "hint": "#### 样例解释\n\n对于第一组样例，使用两次切割，分别为 $(1,3)$，$(3,5)$，花费代价 $3 \\times 1 + 1 \\times 3 = 6$。\n\n对于第二组样例，注意切割 $(5,1)$ 不能使弦 $(3,3)$ 消失。\n\n---\n\n#### 数据范围\n\n**「本题采用捆绑测试」**\n\n对于所有测试点，保证 $1 \\leq n, m \\leq 3\\times 10^5$，$2 \\leq u \\leq n$，$1 \\leq v \\leq n-1$，$1 \\leq a_i,b_i \\leq 10^6$。\n\n$\\text{Subtask 1 (21 pts)}$ $n,m \\leq 6$。\n\n$\\text{Subtask 2 (3 pts)}$ $m=1$。\n\n$\\text{Subtask 3 (1 pts)}$ $a_1=b_n = 1$。\n\n$\\text{Subtask 4 (25 pts)}$ $n,m \\leq 100$。\n\n$\\text{Subtask 5 (29 pts)}$ $n,m \\leq 10^3$。\n\n$\\text{Subtask 6 (21 pts)}$ 无特殊限制。\n\n---\n#### 提示\n\n如果你认真观察了数据范围，你会发现这把多弦琴一定能够被破坏。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "丝之割", "background": "Pharloom 是一个神秘的王国，[丝线与歌](https://www.bilibili.com/video/av43623335)是那里最强大的力量。多弦琴是 Pharloom 的一种强大武器，正如多项式是 OI 中的强大武器。\n\n因为你很讨厌多项式，你决定摧毁多弦琴。", "description": "下面这部分题面只是为了帮助你理解题意，并没有详细的解释。更为严谨清晰的叙述见形式化题意。\n\n多弦琴由两根支柱和连接两根支柱的 $m$ 条弦组成。每根支柱上都均匀安放着 $n$ 个固定点，第 $i$ 条弦连接上方支柱的第 $u_i$ 个固定点和下方支柱的第 $v_i$ 个固定点。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/14igq7bn.png)\n\n> 上图是一把多弦琴\n\n为了摧毁多弦琴，你可以进行若干次切割操作。在一次切割操作中，你可以选择上方支柱的某一个固定点 $u$ 和下方支柱的一个固定点 $v$，所有被 $u$ 到 $v$ 的连线**从左到右**穿过的弦都将被破坏。但同时，你需要付出 $a_u \\times b_v$ 的代价。\n\n形式化题意：有 $m$ 条弦，一条弦可以抽象为一个二元组 $(u,v)$，你可以进行任意次切割操作，一次切割操作你将选择两个下标 $i$ 和 $j$ 满足 $i,j \\in [1,n]$，然后所有满足 $u>i,v<j$ 的弦 $(u,v)$ 都将被破坏，同时你将付出 $a_i \\times b_j​$ 的代价。求破坏所有弦的最小代价和。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数 $a_1,a_2,\\dots,a_n$。\n\n第三行 $n$ 个整数 $b_1,b_2,\\dots,b_n$。\n\n接下来 $m$ 行每行两个整数 $u,v$，表示有一条弦 $(u,v)$。\n\n以上输入的意义见题目描述。", "outputFormat": "一行一个整数，答案。", "hint": "#### 样例解释\n\n对于第一组样例，使用两次切割，分别为 $(1,3)$，$(3,5)$，花费代价 $3 \\times 1 + 1 \\times 3 = 6$。\n\n对于第二组样例，注意切割 $(5,1)$ 不能使弦 $(3,3)$ 消失。\n\n---\n\n#### 数据范围\n\n**「本题采用捆绑测试」**\n\n对于所有测试点，保证 $1 \\leq n, m \\leq 3\\times 10^5$，$2 \\leq u \\leq n$，$1 \\leq v \\leq n-1$，$1 \\leq a_i,b_i \\leq 10^6$。\n\n$\\text{Subtask 1 (21 pts)}$ $n,m \\leq 6$。\n\n$\\text{Subtask 2 (3 pts)}$ $m=1$。\n\n$\\text{Subtask 3 (1 pts)}$ $a_1=b_n = 1$。\n\n$\\text{Subtask 4 (25 pts)}$ $n,m \\leq 100$。\n\n$\\text{Subtask 5 (29 pts)}$ $n,m \\leq 10^3$。\n\n$\\text{Subtask 6 (21 pts)}$ 无特殊限制。\n\n---\n#### 提示\n\n如果你认真观察了数据范围，你会发现这把多弦琴一定能够被破坏。", "locale": "zh-CN"}}}
{"pid": "P6048", "type": "P", "difficulty": 6, "samples": [["4\n1 1 3", "499122180"], ["3\n1 2", "3"], ["13\n1 1 1 3 5 4 2 3 7 4 4 6", "776412285"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["搜索", "数学", "2020", "线段树", "剪枝", "树链剖分", "期望"], "title": "最优性剪枝", "background": "Nauuo 是一名出题人。\n\n众所周知，某些出题人非常懒，导致[随便爆搜](https://www.luogu.com.cn/discuss/show/185420)加上一个[最优性剪枝](https://www.luogu.com.cn/discuss/show/184641)就能通过。Nauuo 决定把这些 naive 的暴力都卡掉。", "description": "Nauuo 决定卡一个暴力搜索程序，为此她构建了一组数据。为了简化题目，你将得到这组数据产生的搜索树 $T$。$T$ 中包含 $n$ 个节点，依次编号为 $1 \\sim n$，其中 $1$ 号点是 $T$ 的根节点。一个节点的深度是它到 $1$ 号点的简单路径上的节点个数。\n\n这个程序的伪代码如下\n\n```cpp\nanswer := inf\n\nprocedure dfs(node,depth)\n\tif (node is leaf) \n\t\tanswer := min(answer,depth)\n\t\treturn\n\tif (depth < answer)\n\t\tfor i in children of node\n\t\t\tdfs(i,depth+1)\n\ndfs(1,1)\n```\n\n其中，`:=` 表示赋值运算。\n\n翻译成人话就是说，这个暴力搜索程序将**深度优先**地遍历这棵搜索树，当访问到一个叶节点时，这个程序将用这个叶节点的深度更新答案。\n\n同时，这个程序有一个最优性剪枝，也就是说，当这个程序访问到任意一个深度等于答案的节点时，它将不会再访问这个节点的子节点。\n\n然而，可怜的 Nauuo 并不知道这个程序在某个节点时访问自己子节点的顺序，因此她认为每个节点访问子节点的顺序都是在所有可能的情况中等概率随机的，显然，一共有 $\\prod d_i!$ 种情况，其中 $d_i$ 表示 $i$ 号节点的子节点数量。\n\n现在她想知道这个程序访问到的节点数量的期望，以确定这个程序会不会被自己的数据卡掉。\n\n为了避免浮点误差，答案对 $998244353$ 取模。保证答案能被表示为最简分数 $\\frac{p}{q}$，你只需要输出一个 $x (0\\leq x < 998244353)$ 使得 $qx \\equiv p \\pmod {998244353}$。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n-1$ 个整数 $p_2, p_3 \\cdots p_n$，其中 $p_i$ 表示 $i$ 号节点的父节点编号。", "outputFormat": "一行一个整数，所求 $x$。", "hint": "#### 样例解释\n\n第一组样例的真实答案为 $\\frac{7}{2}$。\n\n一共只有两种情况，如果 $1$ 号节点先遍历 $3$ 号节点，则程序将访问到搜索树中所有节点。如果 $1$ 号节点先遍历 $2$ 号节点，则 $4$ 号节点不会被访问到。\n\n第二组样例中，每个非叶节点的子节点都是唯一的，因此只有一种可能的情况，所有节点都必然被访问到。\n\n第三组样例的真实答案为 $\\frac{94}{9}$。\n\n---\n\n#### 数据范围\n\n**「本题采用捆绑测试」**\n\n对于所有测试点，保证 $1 \\leq n \\leq 3\\times 10^5$，$1 \\leq p_i < i$。\n\n$\\text{Subtask 1 (11 pts)}$ $n \\leq 9$。\n\n$\\text{Subtask 2 (18 pts)}$ $n \\leq 100$。\n\n$\\text{Subtask 3 (19 pts)}$ $n\\leq 10^3$。\n\n$\\text{Subtask 4 (4 pts)}$ $p_i = i-1$。\n\n$\\text{Subtask 5 (8 pts)}$ $p_i =\\lfloor \\frac{i}{2} \\rfloor$。\n\n$\\text{Subtask 6 (40 pts)}$ 无特殊限制。\n\n---\n\n#### 提示\n\n如果你不知道怎么对分数取模，可以参考[这里](https://www.luogu.com.cn/problem/P3811)。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "Optimality Pruning.", "background": "Nauuo is a problem setter.\n\nAs everyone knows, some problem setters are very lazy, so “[random brute force search](https://www.luogu.com.cn/discuss/show/185420)” plus an “[optimality pruning](https://www.luogu.com.cn/discuss/show/184641)” can pass. Nauuo decides to break all these naive brute-force solutions.", "description": "Nauuo decides to break a brute-force search program, so she constructs a set of testdata. To simplify the problem, you are given the search tree $T$ generated by this testdata. $T$ contains $n$ nodes, numbered $1 \\sim n$ in order, where node $1$ is the root of $T$. The depth of a node is the number of nodes on the simple path from it to node $1$.\n\nThe pseudocode of this program is as follows.\n\n```cpp\nanswer := inf\n\nprocedure dfs(node,depth)\n\tif (node is leaf) \n\t\tanswer := min(answer,depth)\n\t\treturn\n\tif (depth < answer)\n\t\tfor i in children of node\n\t\t\tdfs(i,depth+1)\n\ndfs(1,1)\n```\n\nHere, `:=` denotes assignment.\n\nIn plain words, this brute-force search program traverses the search tree in **depth-first** order. When it reaches a leaf node, it updates the answer using the depth of that leaf node.\n\nMeanwhile, this program has an optimality pruning. That is, when the program reaches any node whose depth equals the current answer, it will not visit this node’s children.\n\nHowever, poor Nauuo does not know the order in which the program visits a node’s children. Therefore, she assumes that for each node, the order of visiting its children is uniformly random among all possible orders. Clearly, there are $\\prod d_i!$ possible cases in total, where $d_i$ is the number of children of node $i$.\n\nNow she wants to know the expected number of nodes visited by this program, to determine whether the program will be broken by her testdata.\n\nTo avoid floating-point errors, take the answer modulo $998244353$. The answer is guaranteed to be representable as an irreducible fraction $\\frac{p}{q}$. You only need to output an $x (0\\leq x < 998244353)$ such that $qx \\equiv p \\pmod {998244353}$.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n-1$ integers $p_2, p_3 \\cdots p_n$, where $p_i$ is the index of the parent of node $i$.", "outputFormat": "One line with an integer, the required $x$.", "hint": "#### Sample Explanation\n\nFor the first sample, the true answer is $\\frac{7}{2}$.\n\nThere are only two cases in total. If node $1$ traverses node $3$ first, then the program will visit all nodes in the search tree. If node $1$ traverses node $2$ first, then node $4$ will not be visited.\n\nIn the second sample, each non-leaf node has only one child, so there is only one possible case, and all nodes will definitely be visited.\n\nFor the third sample, the true answer is $\\frac{94}{9}$.\n\n---\n\n#### Constraints\n\n**This problem uses bundled test cases.**\n\nFor all test points, it is guaranteed that $1 \\leq n \\leq 3\\times 10^5$, $1 \\leq p_i < i$.\n\n$\\text{Subtask 1 (11 pts)}$ $n \\leq 9$.\n\n$\\text{Subtask 2 (18 pts)}$ $n \\leq 100$.\n\n$\\text{Subtask 3 (19 pts)}$ $n\\leq 10^3$.\n\n$\\text{Subtask 4 (4 pts)}$ $p_i = i-1$.\n\n$\\text{Subtask 5 (8 pts)}$ $p_i =\\lfloor \\frac{i}{2} \\rfloor$.\n\n$\\text{Subtask 6 (40 pts)}$ No special constraints.\n\n---\n\n#### Hint\n\nIf you do not know how to take a fraction modulo a number, you can refer to [here](https://www.luogu.com.cn/problem/P3811).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最优性剪枝", "background": "Nauuo 是一名出题人。\n\n众所周知，某些出题人非常懒，导致[随便爆搜](https://www.luogu.com.cn/discuss/show/185420)加上一个[最优性剪枝](https://www.luogu.com.cn/discuss/show/184641)就能通过。Nauuo 决定把这些 naive 的暴力都卡掉。", "description": "Nauuo 决定卡一个暴力搜索程序，为此她构建了一组数据。为了简化题目，你将得到这组数据产生的搜索树 $T$。$T$ 中包含 $n$ 个节点，依次编号为 $1 \\sim n$，其中 $1$ 号点是 $T$ 的根节点。一个节点的深度是它到 $1$ 号点的简单路径上的节点个数。\n\n这个程序的伪代码如下\n\n```cpp\nanswer := inf\n\nprocedure dfs(node,depth)\n\tif (node is leaf) \n\t\tanswer := min(answer,depth)\n\t\treturn\n\tif (depth < answer)\n\t\tfor i in children of node\n\t\t\tdfs(i,depth+1)\n\ndfs(1,1)\n```\n\n其中，`:=` 表示赋值运算。\n\n翻译成人话就是说，这个暴力搜索程序将**深度优先**地遍历这棵搜索树，当访问到一个叶节点时，这个程序将用这个叶节点的深度更新答案。\n\n同时，这个程序有一个最优性剪枝，也就是说，当这个程序访问到任意一个深度等于答案的节点时，它将不会再访问这个节点的子节点。\n\n然而，可怜的 Nauuo 并不知道这个程序在某个节点时访问自己子节点的顺序，因此她认为每个节点访问子节点的顺序都是在所有可能的情况中等概率随机的，显然，一共有 $\\prod d_i!$ 种情况，其中 $d_i$ 表示 $i$ 号节点的子节点数量。\n\n现在她想知道这个程序访问到的节点数量的期望，以确定这个程序会不会被自己的数据卡掉。\n\n为了避免浮点误差，答案对 $998244353$ 取模。保证答案能被表示为最简分数 $\\frac{p}{q}$，你只需要输出一个 $x (0\\leq x < 998244353)$ 使得 $qx \\equiv p \\pmod {998244353}$。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n-1$ 个整数 $p_2, p_3 \\cdots p_n$，其中 $p_i$ 表示 $i$ 号节点的父节点编号。", "outputFormat": "一行一个整数，所求 $x$。", "hint": "#### 样例解释\n\n第一组样例的真实答案为 $\\frac{7}{2}$。\n\n一共只有两种情况，如果 $1$ 号节点先遍历 $3$ 号节点，则程序将访问到搜索树中所有节点。如果 $1$ 号节点先遍历 $2$ 号节点，则 $4$ 号节点不会被访问到。\n\n第二组样例中，每个非叶节点的子节点都是唯一的，因此只有一种可能的情况，所有节点都必然被访问到。\n\n第三组样例的真实答案为 $\\frac{94}{9}$。\n\n---\n\n#### 数据范围\n\n**「本题采用捆绑测试」**\n\n对于所有测试点，保证 $1 \\leq n \\leq 3\\times 10^5$，$1 \\leq p_i < i$。\n\n$\\text{Subtask 1 (11 pts)}$ $n \\leq 9$。\n\n$\\text{Subtask 2 (18 pts)}$ $n \\leq 100$。\n\n$\\text{Subtask 3 (19 pts)}$ $n\\leq 10^3$。\n\n$\\text{Subtask 4 (4 pts)}$ $p_i = i-1$。\n\n$\\text{Subtask 5 (8 pts)}$ $p_i =\\lfloor \\frac{i}{2} \\rfloor$。\n\n$\\text{Subtask 6 (40 pts)}$ 无特殊限制。\n\n---\n\n#### 提示\n\n如果你不知道怎么对分数取模，可以参考[这里](https://www.luogu.com.cn/problem/P3811)。\n\n", "locale": "zh-CN"}}}
{"pid": "P6049", "type": "P", "difficulty": 6, "samples": [["2 2", "6"], ["4 6", "13524"], ["9 34", "857311624"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "数学", "2020", "堆"], "title": "燔祭", "background": "", "description": "计算满足如下条件的带标号有根树数量：\n\n- 这棵树一共有 $n$ 个节点。\n- 每个节点都有一个整数权值，且在区间 $[1,m]$ 内。\n- 每个节点的权值都**不大于**其父节点的权值。\n\n答案可能很大，只需输出答案对 $998244353$ 取模的值。\n\n两棵树 $T_1$ 和 $T_2$ 不同当且仅当两棵树的节点数不同或者根节点不同或者存在一个编号 $i$ 使得 $T_1$ 和 $T_2$ 中 $i$ 号节点的父节点编号不同或者 $i$ 号节点的权值不同。", "inputFormat": "一行两个正整数 $n,m$，意义见题目描述。", "outputFormat": "一行一个整数，所求答案。", "hint": "#### 样例解释\n\n对于第一组样例，\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9b2jvz82.png)\n\n六棵树如上图所示，其中圈内的数字是节点编号，圈外的数字是节点权值。\n\n---\n\n#### 数据范围\n\n**「本题采用捆绑测试」**\n\n对于所有测试点，保证 $1 \\leq n \\leq 400$，$1 \\leq m < 998244353$。\n\n$\\text{Subtask 1 (7 pts)}$ $n = 3,m=3 $。\n\n$\\text{Subtask 2 (11 pts)}$ $m=1$。\n\n$\\text{Subtask 3 (19 pts)}$ $n,m\\leq 6$。\n\n$\\text{Subtask 4 (17 pts)}$ $n \\leq 7$。\n\n$\\text{Subtask 5 (11 pts)}$ $n,m \\leq 50$。\n\n$\\text{Subtask 6 (35 pts)}$ 无特殊限制。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "燔祭", "background": "", "description": "计算满足如下条件的带标号有根树数量：\n\n- 这棵树一共有 $n$ 个节点。\n- 每个节点都有一个整数权值，且在区间 $[1,m]$ 内。\n- 每个节点的权值都**不大于**其父节点的权值。\n\n答案可能很大，只需输出答案对 $998244353$ 取模的值。\n\n两棵树 $T_1$ 和 $T_2$ 不同当且仅当两棵树的节点数不同或者根节点不同或者存在一个编号 $i$ 使得 $T_1$ 和 $T_2$ 中 $i$ 号节点的父节点编号不同或者 $i$ 号节点的权值不同。", "inputFormat": "一行两个正整数 $n,m$，意义见题目描述。", "outputFormat": "一行一个整数，所求答案。", "hint": "#### 样例解释\n\n对于第一组样例，\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9b2jvz82.png)\n\n六棵树如上图所示，其中圈内的数字是节点编号，圈外的数字是节点权值。\n\n---\n\n#### 数据范围\n\n**「本题采用捆绑测试」**\n\n对于所有测试点，保证 $1 \\leq n \\leq 400$，$1 \\leq m < 998244353$。\n\n$\\text{Subtask 1 (7 pts)}$ $n = 3,m=3 $。\n\n$\\text{Subtask 2 (11 pts)}$ $m=1$。\n\n$\\text{Subtask 3 (19 pts)}$ $n,m\\leq 6$。\n\n$\\text{Subtask 4 (17 pts)}$ $n \\leq 7$。\n\n$\\text{Subtask 5 (11 pts)}$ $n,m \\leq 50$。\n\n$\\text{Subtask 6 (35 pts)}$ 无特殊限制。\n\n", "locale": "zh-CN"}}}
{"pid": "P6050", "type": "P", "difficulty": 5, "samples": [["4 1\n1 4 1 3", "0"], ["4 2\n1 3 2 3\n3 4 3 3\n", "1\nhhll\nh..l\n..ll\nhh.l"], ["6 7\n1 3 2 3\n4 1 4 2\n3 1 4 1\n6 4 5 4\n2 1 3 1\n5 4 6 4\n1 1 2 1", "1\n.hhh..\nh..l.l\n.h...l\nh....l\nh....l\nhhhlll"], ["6 22\n1 3 2 3\n4 1 4 2\n3 1 4 1\n6 4 5 4\n2 1 3 1\n5 4 6 4\n1 1 2 1\n6 2 5 2\n3 1 3 2\n6 4 5 4\n2 1 2 2\n4 6 4 5\n3 6 4 6\n5 4 6 4\n2 6 3 6\n6 4 5 4\n1 6 2 6\n6 5 6 6\n2 6 2 5\n6 6 5 6\n2 5 2 6\n6 6 5 6", "2\nred\n...h..\nhhh...\n.h...l\nh...l.\nh..l..\n.hhh.."]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": [], "title": "[RC-02] 游戏", "background": "", "description": "Shik 大佬发明了一种游戏。这种游戏在 $N \\times N$ （$N$ 为偶数）的网格上进行，如图所示（左上角为 $(1,1)$，右下角为 $(N,N)$）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fl8gbzim.png)\n\n这种游戏的规则如下：\n- 初始局面为：在最左边一列和最右边一列的网格上分别放置着红方和蓝方的棋子，在最上面一行左半部分和最下面一行左半部分也放置着红方的棋子，在最上面一行右半部分和最下面一行右半部分也放置着蓝方的棋子；\n- 红方先走，蓝方后走；\n- 有一方只剩下 $N\\div 2$ 颗棋子时，游戏结束，另一方获胜；\n- 有一方无棋可走时，游戏结束，另一方获胜；\n- 每次走棋可以让一颗棋子往上下左右方向移动 $1$ 格，但目标格上不能有棋子；\n- 同时满足以下条件时可以吃掉对方棋子：在一行（或一列上），有且仅有 $N-1$ 颗棋子（当 $N>4$ 时为 $N-2$ 颗也可），其中有 $N-2$ 颗己方棋子（当 $N>4$ 时为 $N-3$ 颗也可），另外 $1$ （当 $N>4$ 时为 $2$ 颗也可）颗棋子为敌方的，我方的棋子全部相邻，敌方棋子全部相邻，并且我方有一颗棋子与敌方相邻，**而且此局面为我方主动走成**，则我方可以把这一列上敌方的棋子全部吃掉。\n\n现在，请你模拟走棋的过程。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2rn7td02.png)\n\n以上为一个不可以吃子的局面。（红吃蓝）\n\n但假如蓝棋本来就在 $(3,3)$，红棋从 $(2,2)$ 走到 $(2,3)$，就可以吃子。\n\n**若不能理解，强烈建议手推一遍样例。**", "inputFormat": "输入文件的第一行有两个整数 $N$ 和 $K$，表示棋盘的大小和走棋的总步数。\n\n接下来 $K$ 行，每行四个整数 $a,b,c,d$，表示某一方的原本在 $(a,b)$ 的棋子走到了 $(c,d)$。从第二行开始算起，第偶数行表示蓝方，第奇数行表示红方。", "outputFormat": "分三种情况输出答案：\n- 数据不合法：输出 $0$。\n- 这一局还没有结束：第一行输出 $1$，接下来 $N$ 行，每行 $N$ 个字符，表示目前的局面状态。用```h```表示红方棋子，```l```表示蓝方棋子，```.```表示此网格为空。若此局面某一方可以吃子，输出吃子后的状态。\n- 这一局已经结束：第一行输出 $2$，第二行输出```red```或```blue```，表示哪一方获胜。第三行至第 $N+2$ 行，输出获胜时的局面。用```h```表示红方棋子，```l```表示蓝方棋子，```.```表示此网格为空。若此局面某一方可以吃子，输出吃子后的状态。**你的程序应该忽略使你判断出胜负那一行之后的所有输入。**", "hint": "样例 4 说明：第 21 歩时，红方已胜，因此第 22 歩的非法移动应该忽略。\n\n对于 $30\\%$ 的数据，不存在吃子的情况；\n\n对于 $60\\%$ 的数据，$N=4$；\n\n对于 $80\\%$ 的数据，$4\\le N\\le 6$；\n\n对于 $100\\%$ 的数据，$4\\le N\\le 10$，$1 \\le K \\le 10^3$。", "locale": "zh-CN", "translations": {"en": {"title": "[RC-02] Game", "background": "", "description": "Expert Shik invented a game. The game is played on an $N \\times N$ grid (where $N$ is even), as shown in the figure (top-left is $(1,1)$, bottom-right is $(N,N)$):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fl8gbzim.png)\n\nThe rules are as follows:\n- Initial position: Red pieces are placed on all cells in the leftmost column, and Blue pieces are placed on all cells in the rightmost column. In addition, on the top row and the bottom row, Red pieces are placed on the left half, and Blue pieces are placed on the right half.\n- Red moves first, Blue moves second.\n- When one side has only $N\\div 2$ pieces left, the game ends and the other side wins.\n- When one side has no legal move, the game ends and the other side wins.\n- Each move: move one piece by $1$ cell in one of the four directions (up, down, left, right), and the destination cell must be empty.\n- Capturing is allowed when all of the following are satisfied: in a single row (or a single column), there are exactly $N-1$ pieces (when $N>4$, having $N-2$ pieces is also allowed). Among them, $N-2$ are your own pieces (when $N>4$, having $N-3$ is also allowed), and the remaining $1$ piece (when $N>4$, having $2$ pieces is also allowed) belongs to the opponent. All of your pieces are consecutive, all opponent pieces are consecutive, and at least one of your pieces is adjacent to an opponent piece. **Moreover, this position must be formed by your active move**. Then you may capture (remove) all opponent pieces in that row/column.\n\nNow, please simulate the game process.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2rn7td02.png)\n\nThe position above is one where capturing is not allowed. (Red captures Blue.)\n\nBut if the Blue piece was originally at $(3,3)$, and the Red piece moves from $(2,2)$ to $(2,3)$, then capturing is allowed.\n\n**If you cannot understand this, it is strongly recommended that you manually work through the sample once.**", "inputFormat": "The first line of the input contains two integers $N$ and $K$, representing the board size and the total number of moves.\n\nThe next $K$ lines each contain four integers $a,b,c,d$, meaning that a piece originally at $(a,b)$ moves to $(c,d)$. Counting from the second line of the file, even-numbered lines represent Blue, and odd-numbered lines represent Red.", "outputFormat": "Output the answer in three cases:\n- Invalid testdata: output $0$.\n- The game has not ended yet: output $1$ on the first line. Then output $N$ lines, each with $N$ characters, representing the current board. Use ```h``` for a Red piece, ```l``` for a Blue piece, and ```.``` for an empty cell. If in this position one side can capture, output the state after capturing.\n- The game has ended: output $2$ on the first line. Output ```red``` or ```blue``` on the second line to indicate the winner. From the third line to line $N+2$, output the board position when the winner is determined. Use ```h``` for a Red piece, ```l``` for a Blue piece, and ```.``` for an empty cell. If in this position one side can capture, output the state after capturing. **Your program should ignore all remaining input after the move that allows you to determine the winner.**", "hint": "Explanation for Sample 4: at move 21, Red has already won, so the illegal move at move 22 should be ignored.\n\nFor $30\\%$ of the testdata, there is no capturing.\n\nFor $60\\%$ of the testdata, $N=4$.\n\nFor $80\\%$ of the testdata, $4\\le N\\le 6$.\n\nFor $100\\%$ of the testdata, $4\\le N\\le 10$, $1 \\le K \\le 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[RC-02] 游戏", "background": "", "description": "Shik 大佬发明了一种游戏。这种游戏在 $N \\times N$ （$N$ 为偶数）的网格上进行，如图所示（左上角为 $(1,1)$，右下角为 $(N,N)$）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fl8gbzim.png)\n\n这种游戏的规则如下：\n- 初始局面为：在最左边一列和最右边一列的网格上分别放置着红方和蓝方的棋子，在最上面一行左半部分和最下面一行左半部分也放置着红方的棋子，在最上面一行右半部分和最下面一行右半部分也放置着蓝方的棋子；\n- 红方先走，蓝方后走；\n- 有一方只剩下 $N\\div 2$ 颗棋子时，游戏结束，另一方获胜；\n- 有一方无棋可走时，游戏结束，另一方获胜；\n- 每次走棋可以让一颗棋子往上下左右方向移动 $1$ 格，但目标格上不能有棋子；\n- 同时满足以下条件时可以吃掉对方棋子：在一行（或一列上），有且仅有 $N-1$ 颗棋子（当 $N>4$ 时为 $N-2$ 颗也可），其中有 $N-2$ 颗己方棋子（当 $N>4$ 时为 $N-3$ 颗也可），另外 $1$ （当 $N>4$ 时为 $2$ 颗也可）颗棋子为敌方的，我方的棋子全部相邻，敌方棋子全部相邻，并且我方有一颗棋子与敌方相邻，**而且此局面为我方主动走成**，则我方可以把这一列上敌方的棋子全部吃掉。\n\n现在，请你模拟走棋的过程。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2rn7td02.png)\n\n以上为一个不可以吃子的局面。（红吃蓝）\n\n但假如蓝棋本来就在 $(3,3)$，红棋从 $(2,2)$ 走到 $(2,3)$，就可以吃子。\n\n**若不能理解，强烈建议手推一遍样例。**", "inputFormat": "输入文件的第一行有两个整数 $N$ 和 $K$，表示棋盘的大小和走棋的总步数。\n\n接下来 $K$ 行，每行四个整数 $a,b,c,d$，表示某一方的原本在 $(a,b)$ 的棋子走到了 $(c,d)$。从第二行开始算起，第偶数行表示蓝方，第奇数行表示红方。", "outputFormat": "分三种情况输出答案：\n- 数据不合法：输出 $0$。\n- 这一局还没有结束：第一行输出 $1$，接下来 $N$ 行，每行 $N$ 个字符，表示目前的局面状态。用```h```表示红方棋子，```l```表示蓝方棋子，```.```表示此网格为空。若此局面某一方可以吃子，输出吃子后的状态。\n- 这一局已经结束：第一行输出 $2$，第二行输出```red```或```blue```，表示哪一方获胜。第三行至第 $N+2$ 行，输出获胜时的局面。用```h```表示红方棋子，```l```表示蓝方棋子，```.```表示此网格为空。若此局面某一方可以吃子，输出吃子后的状态。**你的程序应该忽略使你判断出胜负那一行之后的所有输入。**", "hint": "样例 4 说明：第 21 歩时，红方已胜，因此第 22 歩的非法移动应该忽略。\n\n对于 $30\\%$ 的数据，不存在吃子的情况；\n\n对于 $60\\%$ 的数据，$N=4$；\n\n对于 $80\\%$ 的数据，$4\\le N\\le 6$；\n\n对于 $100\\%$ 的数据，$4\\le N\\le 10$，$1 \\le K \\le 10^3$。", "locale": "zh-CN"}}}
{"pid": "P6051", "type": "P", "difficulty": 3, "samples": [["su57jdkjth54hjsns-321d 8 ejre\nerg(&-^%\n\nweruy4uhnd-", "-202\n4"], ["          4532984       d    -1", "4532983"], ["1-1\n1 -1\n1--5\n1-----------1\n-1-1\n--1\n-2.3", "2\n0\n-4\n0\n0\n-1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串"], "title": "[RC-02] 求和", "background": "", "description": "小 Q 给你了几行字符串，字符串中间包含有一些整数，整数之间可能会有其他字符。你需要输出每行中所有整数的和。如果一个行里面一个数都没有则不要输出。**每两个整数之间一定有间隔字符（见样例 $3$）。**\n\n请注意，题目中的整数都是简单的整数，即：整数前面没有多余的符号。假如数据中有 `.`，视作分隔符。", "inputFormat": "每行一个字符串。", "outputFormat": "对于每一个包含了整数的字符串，输出一行一个数，即其中数的和。", "hint": "【样例解释】\n\n- 第一个样例中，第一行有 $57,54,-321,8$ 几个数，和为 $-202$；第二、三行没有数字；第四行只有一个 $4$，输出 $4$。\n- 第二个样例中只有一行，有两个数，和为 $4532893$。\n- 第三个样例的第一行，由于每两个整数之间一定有间隔字符，所以把 `-` 视为间隔字符，输出 $2$。第五行，第一个数为 $-1$，因此把第二个 `-` 视为间隔字符，和为 $-1+1=0$。第七行，将 `.` 视为间隔字符，和为 $-2+3=1$。\n\n【数据范围】\n\n说明：「条件 A」指数据中不存在除数字、空格、换行、水平制表符之外的其他字符；「条件 B」指每两个数之间一定用且只用一个空格隔开。\n\n**由于数据在 Windows 下制造，行末可能有多余的 `\\r` 字符。请注意。**\n\n对于 $10\\%$ 的数据，满足条件 A 和 B，每行一定有且仅有 $10$ 个数；\n\n对于 $40\\%$ 的数据，满足条件 A 和 B，且不存在空行；\n\n对于 $50\\%$ 的数据，满足条件 A 和 B；\n\n对于 $70\\%$ 的数据，满足条件 A；\n\n对于 $100\\%$ 的数据，不存在除水平制表符、空格、换行外的不可见字符，每行不超过 $1000$ 个字符，每行最多包含 $200$ 个整数，不超过 $100$ 行，每个整数均 $\\in[-10^7,10^7]$。", "locale": "zh-CN", "translations": {"en": {"title": "[RC-02] Summation", "background": "", "description": "Xiao Q gives you several lines of strings. Each string contains some integers, and there may be other characters between the integers. You need to output the sum of all integers in each line. If a line contains no numbers at all, do not output anything for that line. **There is guaranteed to be at least one separator character between every two integers (see sample $3$).**\n\nPlease note that the integers in this problem are simple integers, meaning there are no extra symbols before an integer. If the testdata contains `.`, treat it as a separator.", "inputFormat": "Each line contains one string.", "outputFormat": "For each string that contains integers, output one line with one number: the sum of the integers in that string.", "hint": "【Sample Explanation】\n\n- In the first sample, the first line contains $57,54,-321,8$, and their sum is $-202$. The second and third lines contain no digits. The fourth line contains only one number $4$, so output $4$.\n- In the second sample, there is only one line, containing two numbers, and the sum is $4532893$.\n- In the third sample, for the first line, since there is guaranteed to be a separator character between every two integers, `-` is treated as a separator, so output $2$. For the fifth line, the first number is $-1$, so the second `-` is treated as a separator, and the sum is $-1+1=0$. For the seventh line, treat `.` as a separator, so the sum is $-2+3=1$.\n\n【Constraints】\n\nNote: “Condition A” means there are no other characters in the testdata except digits, spaces, newlines, and horizontal tabs. “Condition B” means every two numbers are separated by exactly one space.\n\n**Since the data is created on Windows, there may be extra `\\r` characters at the end of lines. Please be careful.**\n\nFor $10\\%$ of the data, Conditions A and B are satisfied, and each line has exactly $10$ numbers.\n\nFor $40\\%$ of the data, Conditions A and B are satisfied, and there are no empty lines.\n\nFor $50\\%$ of the data, Conditions A and B are satisfied.\n\nFor $70\\%$ of the data, Condition A is satisfied.\n\nFor $100\\%$ of the data, there are no invisible characters other than horizontal tabs, spaces, and newlines. Each line has at most $1000$ characters, each line contains at most $200$ integers, there are at most $100$ lines, and each integer is $\\in[-10^7,10^7]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[RC-02] 求和", "background": "", "description": "小 Q 给你了几行字符串，字符串中间包含有一些整数，整数之间可能会有其他字符。你需要输出每行中所有整数的和。如果一个行里面一个数都没有则不要输出。**每两个整数之间一定有间隔字符（见样例 $3$）。**\n\n请注意，题目中的整数都是简单的整数，即：整数前面没有多余的符号。假如数据中有 `.`，视作分隔符。", "inputFormat": "每行一个字符串。", "outputFormat": "对于每一个包含了整数的字符串，输出一行一个数，即其中数的和。", "hint": "【样例解释】\n\n- 第一个样例中，第一行有 $57,54,-321,8$ 几个数，和为 $-202$；第二、三行没有数字；第四行只有一个 $4$，输出 $4$。\n- 第二个样例中只有一行，有两个数，和为 $4532893$。\n- 第三个样例的第一行，由于每两个整数之间一定有间隔字符，所以把 `-` 视为间隔字符，输出 $2$。第五行，第一个数为 $-1$，因此把第二个 `-` 视为间隔字符，和为 $-1+1=0$。第七行，将 `.` 视为间隔字符，和为 $-2+3=1$。\n\n【数据范围】\n\n说明：「条件 A」指数据中不存在除数字、空格、换行、水平制表符之外的其他字符；「条件 B」指每两个数之间一定用且只用一个空格隔开。\n\n**由于数据在 Windows 下制造，行末可能有多余的 `\\r` 字符。请注意。**\n\n对于 $10\\%$ 的数据，满足条件 A 和 B，每行一定有且仅有 $10$ 个数；\n\n对于 $40\\%$ 的数据，满足条件 A 和 B，且不存在空行；\n\n对于 $50\\%$ 的数据，满足条件 A 和 B；\n\n对于 $70\\%$ 的数据，满足条件 A；\n\n对于 $100\\%$ 的数据，不存在除水平制表符、空格、换行外的不可见字符，每行不超过 $1000$ 个字符，每行最多包含 $200$ 个整数，不超过 $100$ 行，每个整数均 $\\in[-10^7,10^7]$。", "locale": "zh-CN"}}}
{"pid": "P6052", "type": "P", "difficulty": 5, "samples": [["100000 1 2", "321"]], "limits": {"time": [600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 700, 700, 700, 700, 700, 700, 700, 700], "memory": [15360, 15360, 15360, 15360, 15360, 15360, 15360, 15360, 15360, 15360, 15360, 15360, 15360, 15360, 15360, 15360, 15360, 15360, 15360, 15360]}, "tags": ["O2优化"], "title": "[RC-02] yltx 数对", "background": "yltx 又双叒叕出自己不会做的题了……", "description": "yltx 定义若一个**素数**数对 $(x,y)$ 满足 $x\\times y-3\\times (x-y)$ 是素数，则称其为一个 yltx 数对。\n\n他给了你 $T$ 对 $(x,y)$，请你检查他们是否为 yltx 数对。\n\n数据以种子$(x_0,y_0)$的形式给出。\n\n执行 $T$ 次 $x_0\\leftarrow (7x_0+13)\\ \\mathrm{xor}\\ (x_0\\div 13-7)$，第 $i$ 次执行得到的数先取模 $10^4$、加上 $10^4$、取模 $10^4$，再加 $1$，就得到了第 $i$ 组数据的 $x$。这里的除法就是整除，把 $x_0$ 视作 32 位有符号整数。\n\n用同样的方法得到 $y$。\n\n数据生成模板：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint T,x_0,y_0;\nint main() {\n\tscanf(\"%d%d%d\",&T,&x_0,&y_0);\n\twhile(T--){\n\t\tx_0=((7*x_0+13)^(x_0/13-7));\n\t\ty_0=((7*y_0+13)^(y_0/13-7));\n\t\tint x=(x_0%10000+10000)%10000+1,y=(y_0%10000+10000)%10000+1;\n\t\t//x,y即为一组(x,y)。\n\t}\n\treturn 0;\n}\n```", "inputFormat": "第一行三个整数 $T,x_0,y_0$。\n\n", "outputFormat": "$1$行，输出有几对数是 yltx 数对。", "hint": "各测试点数据范围如下：\n\n| 测试点 | T | Subtask |\n| :---: | :---: | :---: |\n| 1 | $\\le10$ | 1 |\n| 2 | $\\le20$ | 1 |\n| 3 | $\\le50$ | 1 |\n| 4 | $\\le100$ | 1 |\n| 5 | $\\le500$ | 1 |\n| 6 | $\\le1000$ | 1 |\n| 7 | $\\le5000$ | 2 |\n| 8 | $\\le10^4$ | 2 |\n| 9 | $\\le5\\times10^4$ | 2 |\n| 10 | $\\le4\\times10^5$ | 2 |\n| 11 | $\\le10^6$ | 2 |\n| 12 | $\\le5\\times10^6$ | 2 |\n| 13 | $\\le4\\times10^7$ | 3 |\n| 14 | $\\le4\\times10^7$ | 3 |\n| 15 | $\\le4\\times10^7$ | 3 |\n| 16 | $\\le4\\times10^7$ | 3 |\n| 17 | $\\le4\\times10^7$ | 3 |\n| 18 | $\\le4\\times10^7$ | 3 |\n| 19 | $\\le4\\times10^7$ | 3 |\n| 20 | $\\le4\\times10^7$ | 3 |\n\n各Subtask捆绑测试。\n\n本题开放数据下载，但希望您能用数据做正确的事。", "locale": "zh-CN", "translations": {"en": {"title": "[RC-02] yltx Prime Pair", "background": "yltx has once again come up with a problem that they cannot solve...", "description": "yltx defines that if a **prime** pair $(x,y)$ satisfies that $x\\times y-3\\times (x-y)$ is prime, then it is called a yltx pair.\n\nHe gives you $T$ pairs $(x,y)$. Please check whether they are yltx pairs.\n\nThe data is given in the form of a seed $(x_0,y_0)$.\n\nPerform $T$ times of $x_0\\leftarrow (7x_0+13)\\ \\mathrm{xor}\\ (x_0\\div 13-7)$. For the value obtained in the $i$-th execution, first take modulo $10^4$, add $10^4$, take modulo $10^4$ again, then add $1$, and you get the $x$ of the $i$-th test case. Here division means integer division, and $x_0$ is treated as a 32-bit signed integer.\n\nUse the same method to get $y$.\n\nData generation template:\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint T,x_0,y_0;\nint main() {\n\tscanf(\"%d%d%d\",&T,&x_0,&y_0);\n\twhile(T--){\n\t\tx_0=((7*x_0+13)^(x_0/13-7));\n\t\ty_0=((7*y_0+13)^(y_0/13-7));\n\t\tint x=(x_0%10000+10000)%10000+1,y=(y_0%10000+10000)%10000+1;\n\t\t//x,y即为一组(x,y)。\n\t}\n\treturn 0;\n}\n```", "inputFormat": "The first line contains three integers $T,x_0,y_0$.", "outputFormat": "$1$ line. Output how many pairs are yltx pairs.", "hint": "The Constraints for each test point are as follows:\n\n| Test Point | T | Subtask |\n| :---: | :---: | :---: |\n| 1 | $\\le10$ | 1 |\n| 2 | $\\le20$ | 1 |\n| 3 | $\\le50$ | 1 |\n| 4 | $\\le100$ | 1 |\n| 5 | $\\le500$ | 1 |\n| 6 | $\\le1000$ | 1 |\n| 7 | $\\le5000$ | 2 |\n| 8 | $\\le10^4$ | 2 |\n| 9 | $\\le5\\times10^4$ | 2 |\n| 10 | $\\le4\\times10^5$ | 2 |\n| 11 | $\\le10^6$ | 2 |\n| 12 | $\\le5\\times10^6$ | 2 |\n| 13 | $\\le4\\times10^7$ | 3 |\n| 14 | $\\le4\\times10^7$ | 3 |\n| 15 | $\\le4\\times10^7$ | 3 |\n| 16 | $\\le4\\times10^7$ | 3 |\n| 17 | $\\le4\\times10^7$ | 3 |\n| 18 | $\\le4\\times10^7$ | 3 |\n| 19 | $\\le4\\times10^7$ | 3 |\n| 20 | $\\le4\\times10^7$ | 3 |\n\nEach Subtask is tested as a bundled group of test points.\n\nThis problem provides testdata for download, but we hope you will use the data to do the right thing.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[RC-02] yltx 数对", "background": "yltx 又双叒叕出自己不会做的题了……", "description": "yltx 定义若一个**素数**数对 $(x,y)$ 满足 $x\\times y-3\\times (x-y)$ 是素数，则称其为一个 yltx 数对。\n\n他给了你 $T$ 对 $(x,y)$，请你检查他们是否为 yltx 数对。\n\n数据以种子$(x_0,y_0)$的形式给出。\n\n执行 $T$ 次 $x_0\\leftarrow (7x_0+13)\\ \\mathrm{xor}\\ (x_0\\div 13-7)$，第 $i$ 次执行得到的数先取模 $10^4$、加上 $10^4$、取模 $10^4$，再加 $1$，就得到了第 $i$ 组数据的 $x$。这里的除法就是整除，把 $x_0$ 视作 32 位有符号整数。\n\n用同样的方法得到 $y$。\n\n数据生成模板：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint T,x_0,y_0;\nint main() {\n\tscanf(\"%d%d%d\",&T,&x_0,&y_0);\n\twhile(T--){\n\t\tx_0=((7*x_0+13)^(x_0/13-7));\n\t\ty_0=((7*y_0+13)^(y_0/13-7));\n\t\tint x=(x_0%10000+10000)%10000+1,y=(y_0%10000+10000)%10000+1;\n\t\t//x,y即为一组(x,y)。\n\t}\n\treturn 0;\n}\n```", "inputFormat": "第一行三个整数 $T,x_0,y_0$。\n\n", "outputFormat": "$1$行，输出有几对数是 yltx 数对。", "hint": "各测试点数据范围如下：\n\n| 测试点 | T | Subtask |\n| :---: | :---: | :---: |\n| 1 | $\\le10$ | 1 |\n| 2 | $\\le20$ | 1 |\n| 3 | $\\le50$ | 1 |\n| 4 | $\\le100$ | 1 |\n| 5 | $\\le500$ | 1 |\n| 6 | $\\le1000$ | 1 |\n| 7 | $\\le5000$ | 2 |\n| 8 | $\\le10^4$ | 2 |\n| 9 | $\\le5\\times10^4$ | 2 |\n| 10 | $\\le4\\times10^5$ | 2 |\n| 11 | $\\le10^6$ | 2 |\n| 12 | $\\le5\\times10^6$ | 2 |\n| 13 | $\\le4\\times10^7$ | 3 |\n| 14 | $\\le4\\times10^7$ | 3 |\n| 15 | $\\le4\\times10^7$ | 3 |\n| 16 | $\\le4\\times10^7$ | 3 |\n| 17 | $\\le4\\times10^7$ | 3 |\n| 18 | $\\le4\\times10^7$ | 3 |\n| 19 | $\\le4\\times10^7$ | 3 |\n| 20 | $\\le4\\times10^7$ | 3 |\n\n各Subtask捆绑测试。\n\n本题开放数据下载，但希望您能用数据做正确的事。", "locale": "zh-CN"}}}
{"pid": "P6053", "type": "P", "difficulty": 6, "samples": [["5 4 4\n0 0 2 2 1\n1 2\n1 3\n2 4\n2 5\n1 1\n1 1\n1 1\n2 3 0\n4 3 3\n5 1\n1 2\n3 1 2\n", "3\n3\n3\n0\n3\n0\n2\n"], ["10 8 8\n5 6 2 1 0 4 0 0 0 3\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n4 8\n4 9\n5 10\n3 10 9\n2 1 6\n1 5\n1 4\n1 7\n1 7\n5 1\n1 1\n3 1 5\n1 7\n1 9\n2 5 0\n4 9 6\n1 10\n4 10 7\n5 1\n", "2\n3\n3\n3\n3\n2\n3\n1\n3\n7\n7\n7\n1\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1800, 2300], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "[RC-02] XOR", "background": "FangZeLi 喜欢异或，所以就有了这道题（然而这并不是他出这种题的理由）。", "description": "**注意，本题中一切 $\\sum$ 均表示求异或和！**\n\n一棵 $n$ 个节点，$n-1$ 条边的有根树，初始时以 $1$ 节点为根。\n\n这棵树上的每个节点 $i$ 都有其点权 $V_{i}$。\n\n令函数 $\\operatorname{Xor}(x)=\\sum_{y\\in  \\operatorname{Subtree}(x)}{V_{y}}$，其中 $\\operatorname{Subtree}(x)$ 表示 $x$ 的子树。\n\n现需支持以下五种操作：\n\n1. `1 x`，表示将 $x$ 换为根，且查询 $\\sum_{i=1}^{n}{\\operatorname{Xor}(i)}$。\n2. `2 x y`，表示令 $V_{x}=y$。\n3. `3 x y` ，表示查询 $\\operatorname{LCA}(x,y)$。\n4. `4 x y`，表示查询 $x$ 到 $y$ 路径上的点的点权异或和。\n5. `5 x`，表示查询 $\\operatorname{Xor}(x)$。", "inputFormat": "第一行三个整数，$n,m,q$，分别表示节点数，$1$ 操作个数，其余操作个数。\n\n接下来一行 $n$ 个整数，表示 $V_{1}\\dots V_{n}$。\n\n接下来 $n-1$ 行，每行两个整数 $x,y$，表示 $x$ 和 $y$ 间有一条边。\n\n接下来 $m+q$ 行，每行两到三个整数，第一个数为操作序号，接下来为相应的操作。", "outputFormat": "若干行，表示 $1,3,4,5$ 操作的结果。", "hint": "对于所有数据，保证 $100\\le n,m,q\\le 10^6$，$0\\le V_i\\le 2^{31}-1$。详细数据范围如下表。\n\n| 测试点编号 | 时间限制/秒 | $n$                | $m$                | $q$                 |\n| :-----: | :--------: | :------------------: | :------------------: | :-------------------: |\n| $1$   |  $1$     | $ 100 $            | $ 100 $            | $ 4 \\times 10 ^ 5 $ |\n| $2,3$   |$1$     | $ 100 $            | $10^ { 6 }$ | $ 4 \\times 10 ^ 5 $ |\n| $4,5$   | $1$     | $ 10 ^ 4$ | $100$              | $ 4 \\times 10 ^ 5 $ |\n| $6,7,8$ |  $ 1 $   | $ 10 ^ 4$ | $10 ^ 6$    | $ 4 \\times 10 ^ 5 $ |\n| $9$    | $ 1.8 $ | $ 10 ^ 6$ | $100$              | $ 10^6$      |\n| $10$   | $ 2.3 $ | $ 10 ^ 6$ | $ 10^6$     | $ 10 ^ 6$    |", "locale": "zh-CN", "translations": {"en": {"title": "[RC-02] XOR", "background": "FangZeLi likes XOR, so this problem was created (though that is not really why he makes such problems).", "description": "**Note: In this problem, every $\\sum$ means taking the XOR-sum.**\n\nThere is a rooted tree with $n$ nodes and $n-1$ edges. Initially, node $1$ is the root.\n\nEach node $i$ on the tree has a node value $V_{i}$.\n\nDefine the function $\\operatorname{Xor}(x)=\\sum_{y\\in \\operatorname{Subtree}(x)}{V_{y}}$, where $\\operatorname{Subtree}(x)$ denotes the subtree of $x$.\n\nYou need to support the following five operations:\n\n1. `1 x`: Make $x$ the root, and query $\\sum_{i=1}^{n}{\\operatorname{Xor}(i)}$.\n2. `2 x y`: Set $V_{x}=y$.\n3. `3 x y`: Query $\\operatorname{LCA}(x,y)$.\n4. `4 x y`: Query the XOR-sum of node values along the path from $x$ to $y$.\n5. `5 x`: Query $\\operatorname{Xor}(x)$.", "inputFormat": "The first line contains three integers $n,m,q$, representing the number of nodes, the number of operation type $1$, and the number of the remaining operations.\n\nThe next line contains $n$ integers, representing $V_{1}\\dots V_{n}$.\n\nThe next $n-1$ lines each contain two integers $x,y$, indicating that there is an edge between $x$ and $y$.\n\nThe next $m+q$ lines each contain two or three integers. The first number is the operation type, followed by the parameters of that operation.", "outputFormat": "Output several lines, each being the result of operations $1,3,4,5$.", "hint": "For all testdata, it is guaranteed that $100\\le n,m,q\\le 10^6$, $0\\le V_i\\le 2^{31}-1$. The detailed Constraints are shown in the table below.\n\n| Test Point ID | Time Limit / s | $n$ | $m$ | $q$ |\n| :-----: | :--------: | :------------------: | :------------------: | :-------------------: |\n| $1$ | $1$ | $ 100 $ | $ 100 $ | $ 4 \\times 10 ^ 5 $ |\n| $2,3$ | $1$ | $ 100 $ | $10^ { 6 }$ | $ 4 \\times 10 ^ 5 $ |\n| $4,5$ | $1$ | $ 10 ^ 4$ | $100$ | $ 4 \\times 10 ^ 5 $ |\n| $6,7,8$ | $ 1 $ | $ 10 ^ 4$ | $10 ^ 6$ | $ 4 \\times 10 ^ 5 $ |\n| $9$ | $ 1.8 $ | $ 10 ^ 6$ | $100$ | $ 10^6$ |\n| $10$ | $ 2.3 $ | $ 10 ^ 6$ | $ 10^6$ | $ 10 ^ 6$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[RC-02] XOR", "background": "FangZeLi 喜欢异或，所以就有了这道题（然而这并不是他出这种题的理由）。", "description": "**注意，本题中一切 $\\sum$ 均表示求异或和！**\n\n一棵 $n$ 个节点，$n-1$ 条边的有根树，初始时以 $1$ 节点为根。\n\n这棵树上的每个节点 $i$ 都有其点权 $V_{i}$。\n\n令函数 $\\operatorname{Xor}(x)=\\sum_{y\\in  \\operatorname{Subtree}(x)}{V_{y}}$，其中 $\\operatorname{Subtree}(x)$ 表示 $x$ 的子树。\n\n现需支持以下五种操作：\n\n1. `1 x`，表示将 $x$ 换为根，且查询 $\\sum_{i=1}^{n}{\\operatorname{Xor}(i)}$。\n2. `2 x y`，表示令 $V_{x}=y$。\n3. `3 x y` ，表示查询 $\\operatorname{LCA}(x,y)$。\n4. `4 x y`，表示查询 $x$ 到 $y$ 路径上的点的点权异或和。\n5. `5 x`，表示查询 $\\operatorname{Xor}(x)$。", "inputFormat": "第一行三个整数，$n,m,q$，分别表示节点数，$1$ 操作个数，其余操作个数。\n\n接下来一行 $n$ 个整数，表示 $V_{1}\\dots V_{n}$。\n\n接下来 $n-1$ 行，每行两个整数 $x,y$，表示 $x$ 和 $y$ 间有一条边。\n\n接下来 $m+q$ 行，每行两到三个整数，第一个数为操作序号，接下来为相应的操作。", "outputFormat": "若干行，表示 $1,3,4,5$ 操作的结果。", "hint": "对于所有数据，保证 $100\\le n,m,q\\le 10^6$，$0\\le V_i\\le 2^{31}-1$。详细数据范围如下表。\n\n| 测试点编号 | 时间限制/秒 | $n$                | $m$                | $q$                 |\n| :-----: | :--------: | :------------------: | :------------------: | :-------------------: |\n| $1$   |  $1$     | $ 100 $            | $ 100 $            | $ 4 \\times 10 ^ 5 $ |\n| $2,3$   |$1$     | $ 100 $            | $10^ { 6 }$ | $ 4 \\times 10 ^ 5 $ |\n| $4,5$   | $1$     | $ 10 ^ 4$ | $100$              | $ 4 \\times 10 ^ 5 $ |\n| $6,7,8$ |  $ 1 $   | $ 10 ^ 4$ | $10 ^ 6$    | $ 4 \\times 10 ^ 5 $ |\n| $9$    | $ 1.8 $ | $ 10 ^ 6$ | $100$              | $ 10^6$      |\n| $10$   | $ 2.3 $ | $ 10 ^ 6$ | $ 10^6$     | $ 10 ^ 6$    |", "locale": "zh-CN"}}}
{"pid": "P6054", "type": "P", "difficulty": 6, "samples": [["4\n3 2 4 0\n10 10 10 20\n0.3 0.5 0.7 0.4\n0.2 0.6 0.2 0.2\n0.7 0.1 0.8 0.2\n0.5 0.5 0.5 0.5\n0.2 0.5 0.3 0.6\n0.3 0.5 0.4 0.1\n3 2 4 1\n10 10 10 20\n0.3 0.5 0.7 0.4\n0.2 0.6 0.2 0.2\n0.7 0.1 0.8 0.2\n0.5 0.5 0.5 0.5\n0.2 0.5 0.3 0.6\n0.3 0.5 0.4 0.1\n2 3 1\n3 2 4 1\n10 10 10 20\n0.3 0.5 0.7 0.4\n0.2 0.6 0.2 0.2\n0.7 0.1 0.8 0.2\n0.5 0.5 0.5 0.5\n0.2 0.5 0.3 0.6\n0.3 0.5 0.4 0.1\n1 2 1\n3 2 4 2\n10 10 10 20\n0.3 0.5 0.7 0.4\n0.2 0.6 0.2 0.2\n0.7 0.1 0.8 0.2\n0.5 0.5 0.5 0.5\n0.2 0.5 0.3 0.6\n0.3 0.5 0.4 0.1\n1 2 1\n2 3 1", "15.1460\n18.5340\n18.7560\n-1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["网络流", "Special Judge", "O2优化", "最小割", "期望"], "title": "[RC-02] 开门大吉", "background": "", "description": "$n$ 位选手去参加节目“开门大吉”。共有 $m$ 套题，每套题包含 $p$ 个题目，第 $i$ 位选手答对第 $j$ 套题中第 $k$ 道的概率为 $f_{i,j,k}$。若某题答错则该选手的答题流程将直接结束。\n\n若一位选手答对第 $i$ 题，会在已得到奖励的基础上，再得到 $c_i$ 元奖励。选手总是从第一道开始，按顺序答题的。\n\n同时，为了防止过多的选手做同一套题，还有 $y$ 条形如“第 $i$ 位选手的套题编号必须至少比第 $j$ 位的大 $k$”的限制。\n\n你需要给每一位选手分配一套题（不同选手可以相同），使得所有人的期望奖励和最小。", "inputFormat": "输入包含多组数据。第一行是一个整数 $T$，为数据组数。\n\n对于每组数据，第一行四个整数 $n,m,p,y$。\n\n接下来一行 $p$ 个整数，第 $i$ 个为 $c_i$。 \n\n接下来 $m$ 个 $n\\times p$ 的矩阵，第 $j$ 个矩阵中第 $i$ 行第 $k$ 个实数为 $f_{i,j,k}$。\n\n接下来 $y$ 行，每行三个整数 $i,j,k$（$1\\le i,j\\le n$，$-m<k<m$），描述一条限制。", "outputFormat": "对于每组数据，输出一个实数，为答案。无解输出 `-1`。\n\n本题有 Special Judge，答案误差在 $5\\times 10^{-4}$ 以内都算对。\n\n由于 SPJ 敏感，请在每组数据末尾都输出一个换行符，并不要再输出其它字符。", "hint": "【样例解释】\n\n这里只解释第二组数据。\n\n一共只有两套题，而第二个人的套题编号大于第三个人，因此第二个人一定是选第二套，第三个人选第一套。\n\n第二个人选第二套，期望支出：$0.2\\times (1-0.5)\\times 10+0.2\\times 0.5 \\times (1-0.3) \\times 20+0.2\\times 0.5 \\times 0.3\\times (1-0.6)  \\times 30+0.2\\times 0.5 \\times 0.3\\times 0.6  \\times 50=3.66$。\n\n其他人的计算方法类似。\n\n【数据范围】\n\n**本题捆绑测试。**\n\n对于所有数据，$1\\le n,m,p\\le 80$，$0\\le y\\le 10^3$，$0\\le f_{i,j,k} \\le 1$，$0\\le c_i\\le 10^5$，$1 \\le T\\le 50$。保证每个测试点的输入数据大小小于 $10\\text{MB}$。\n\nSubtask 1（20 pts）：$n,m,p,y\\le 7$；\n\nSubtask 2（20 pts）：$T\\le 6$，$y=0$；\n\nSubtask 3（20 pts）：$n,m,p\\le 30$，$y\\le 200$；\n\nSubtask 4（20 pts）：$T=1$；\n\nSubtask 5（20 pts）：$T\\le 5$。", "locale": "zh-CN", "translations": {"en": {"title": "[RC-02] Open the Door and Win Big", "background": "", "description": "There are $n$ contestants participating in the show “Open the Door and Win Big”. There are $m$ sets of questions. Each set contains $p$ questions. The probability that contestant $i$ answers question $k$ in set $j$ correctly is $f_{i,j,k}$. If a contestant answers any question wrong, their answering process ends immediately.\n\nIf a contestant answers question $i$ correctly, they receive an additional reward of $c_i$ yuan on top of the rewards already obtained. Contestants always start from the first question and answer in order.\n\nAt the same time, to prevent too many contestants from doing the same set, there are also $y$ constraints of the form: “the set index of contestant $i$ must be at least $k$ larger than that of contestant $j$”.\n\nYou need to assign one set of questions to each contestant (different contestants may be assigned the same set), so that the sum of everyone’s expected rewards is minimized.", "inputFormat": "The input contains multiple test cases. The first line is an integer $T$, the number of test cases.\n\nFor each test case, the first line contains four integers $n,m,p,y$.\n\nThe next line contains $p$ integers, where the $i$-th one is $c_i$.\n\nThen follow $m$ matrices of size $n\\times p$. In the $j$-th matrix, the real number in row $i$ and column $k$ is $f_{i,j,k}$.\n\nThen follow $y$ lines, each containing three integers $i,j,k$ ($1\\le i,j\\le n$, $-m<k<m$), describing one constraint.", "outputFormat": "For each test case, output one real number, the answer. If there is no solution, output `-1`.\n\nThis problem uses a Special Judge. Any answer with an error within $5\\times 10^{-4}$ is accepted.\n\nBecause the SPJ is sensitive, please output a newline at the end of each test case, and do not output any other characters.", "hint": "[Sample Explanation]\n\nOnly the second test case is explained here.\n\nThere are only two sets of questions, and the set index of the second person is larger than that of the third person. Therefore, the second person must choose the second set, and the third person chooses the first set.\n\nIf the second person chooses the second set, the expected cost is: $0.2\\times (1-0.5)\\times 10+0.2\\times 0.5 \\times (1-0.3) \\times 20+0.2\\times 0.5 \\times 0.3\\times (1-0.6)  \\times 30+0.2\\times 0.5 \\times 0.3\\times 0.6  \\times 50=3.66$.\n\nThe calculation method for other people is similar.\n\n[Constraints]\n\n**This problem uses bundled testdata.**\n\nFor all data, $1\\le n,m,p\\le 80$, $0\\le y\\le 10^3$, $0\\le f_{i,j,k} \\le 1$, $0\\le c_i\\le 10^5$, $1 \\le T\\le 50$. It is guaranteed that the input size of each test point is less than $10\\text{MB}$.\n\nSubtask 1 (20 pts): $n,m,p,y\\le 7$.\n\nSubtask 2 (20 pts): $T\\le 6$, $y=0$.\n\nSubtask 3 (20 pts): $n,m,p\\le 30$, $y\\le 200$.\n\nSubtask 4 (20 pts): $T=1$.\n\nSubtask 5 (20 pts): $T\\le 5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[RC-02] 开门大吉", "background": "", "description": "$n$ 位选手去参加节目“开门大吉”。共有 $m$ 套题，每套题包含 $p$ 个题目，第 $i$ 位选手答对第 $j$ 套题中第 $k$ 道的概率为 $f_{i,j,k}$。若某题答错则该选手的答题流程将直接结束。\n\n若一位选手答对第 $i$ 题，会在已得到奖励的基础上，再得到 $c_i$ 元奖励。选手总是从第一道开始，按顺序答题的。\n\n同时，为了防止过多的选手做同一套题，还有 $y$ 条形如“第 $i$ 位选手的套题编号必须至少比第 $j$ 位的大 $k$”的限制。\n\n你需要给每一位选手分配一套题（不同选手可以相同），使得所有人的期望奖励和最小。", "inputFormat": "输入包含多组数据。第一行是一个整数 $T$，为数据组数。\n\n对于每组数据，第一行四个整数 $n,m,p,y$。\n\n接下来一行 $p$ 个整数，第 $i$ 个为 $c_i$。 \n\n接下来 $m$ 个 $n\\times p$ 的矩阵，第 $j$ 个矩阵中第 $i$ 行第 $k$ 个实数为 $f_{i,j,k}$。\n\n接下来 $y$ 行，每行三个整数 $i,j,k$（$1\\le i,j\\le n$，$-m<k<m$），描述一条限制。", "outputFormat": "对于每组数据，输出一个实数，为答案。无解输出 `-1`。\n\n本题有 Special Judge，答案误差在 $5\\times 10^{-4}$ 以内都算对。\n\n由于 SPJ 敏感，请在每组数据末尾都输出一个换行符，并不要再输出其它字符。", "hint": "【样例解释】\n\n这里只解释第二组数据。\n\n一共只有两套题，而第二个人的套题编号大于第三个人，因此第二个人一定是选第二套，第三个人选第一套。\n\n第二个人选第二套，期望支出：$0.2\\times (1-0.5)\\times 10+0.2\\times 0.5 \\times (1-0.3) \\times 20+0.2\\times 0.5 \\times 0.3\\times (1-0.6)  \\times 30+0.2\\times 0.5 \\times 0.3\\times 0.6  \\times 50=3.66$。\n\n其他人的计算方法类似。\n\n【数据范围】\n\n**本题捆绑测试。**\n\n对于所有数据，$1\\le n,m,p\\le 80$，$0\\le y\\le 10^3$，$0\\le f_{i,j,k} \\le 1$，$0\\le c_i\\le 10^5$，$1 \\le T\\le 50$。保证每个测试点的输入数据大小小于 $10\\text{MB}$。\n\nSubtask 1（20 pts）：$n,m,p,y\\le 7$；\n\nSubtask 2（20 pts）：$T\\le 6$，$y=0$；\n\nSubtask 3（20 pts）：$n,m,p\\le 30$，$y\\le 200$；\n\nSubtask 4（20 pts）：$T=1$；\n\nSubtask 5（20 pts）：$T\\le 5$。", "locale": "zh-CN"}}}
