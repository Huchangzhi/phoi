{"pid": "P8888", "type": "P", "difficulty": 5, "samples": [["7 6\n1 9 1 9 8 1 0\n1 1 4 5 1 4\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n1 0 1 0", "45"], ["4 4\n-2 -2 -2 -2\n2 3 4 9\n4 -2 0 4\n0 0 0 0\n-1 0 1 0\n0 0 2 0\n1 2 1 0", "15"]], "limits": {"time": [1200, 1200, 1200, 1200, 1200, 1200, 1200], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "O2优化"], "title": "[DMOI-R1] 实验基地", "background": "小 A 和小 B 用实验基地全新的装备进行了一场世纪蒟蒻之战。", "description": "众所周知，实验基地的武器都是一次性的。现在，小 A 选取了 $n$ 把不同的武器，小 B 也获取了 $m$ 把不同武器。每个人的武器都可以用编号 $1$ 到编号 $n$ 或 $m$ 依次表示，他们将会按此顺序逐个使用武器。\n\n实验仓库记录了所有武器的火力。小 A 的第 $k$ 把武器能爆发出 $a_k$ 的能量，而小 B 的第 $k$ 把武器能爆发出 $b_k$ 的能量。特别的，当小 A 的第 $i$ 把武器与小 B 的第 $j$ 把武器同时使用，会释放 $d_{i,j}$ 的能量。由于某些不可描述的组合的奇效，$a,b,d$ **都可能小于** $0$。\n\n当某人第一个使用了武器，战斗就正式开始，记为第 $1$ 秒，直至某人使用完武器后再无人使用武器，记此时为第 $t$ 秒（$t$ **不为输入数据**）。也就是说，**在第 $1$ 秒和第 $t$ 秒必须有人使用武器，而在 $1$ 至 $t$ 秒内在符合其他条件下，每一秒双方可以选择按顺序使用武器或不使用**。\n\n为了避免打死对方，**双方都不一定使用完武器**。\n\n由于实验基地有发电装置，如果小 A 没有连续使用武器释放能量，而是休息了 $x$ 秒，那么祂将会吸收掉 $Ax+B\\ (A,B \\in \\mathbb{N})$ 的能量。同样，小 B 间隔 $y$ 秒将吸收 $Cy+D\\ (C,D \\in \\mathbb{N})$ 的能量。连续两秒都释放武器间隔时间为 $0$ 秒，以此类推。\n\n为了防止基地被核爆，你需要算出战斗结束后可能释放的最大总能量（可能为负数）。\n\n**若对题目细节有疑惑请先读提示内的额外解释。**", "inputFormat": "第一行有两个数 $n$ 和 $m$。\n\n第二行有 $n$ 个数，第 $k$ 个数字即 $a_k$。\n\n第三行有 $m$ 个数，第 $k$ 个数字即 $b_k$。\n\n接下来 $n$ 行，每行 $m$ 个数字，其中第 $i$ 行第 $j$ 列表示的是 $d_{i,j}$。\n\n最后一行有四个非负整数 $A,B,C,D$。", "outputFormat": "只有一行，输出一个数字，即最大可能能量。", "hint": "1. 战斗的开始时间（第 $1$ 秒）为双方某人最先释放出第一个技能的时间，战斗结束时间为双方某人释放出最后一个技能的时间。**结束时间不定**。\n\n2. 技能必须按顺序释放，但**不一定需要在战斗中释放完**。\n\n3. $a,b,d$ 可以为负数，总计能量可能为负，“吸收能量”指总能量减少 $Ax+B$ 或 $Cy+D$，也就是**间隔时总能量一定减少**，而且时间越长减少越多。\n\n4. 本题 IO 量较大，建议使用合适的读入方式。\n\n### 样例解释：\n\n样例 1：每个人在 $1$ 到 $6$ 秒依次使用自己的编号为 $1$ 到 $6$  的武器即可取到最大值。\n\n样例 2：小 B 在 $1$ 到 $4$ 秒依次使用自己的编号为 $1$ 到 $4$ 的武器，小 A 在第 $4$ 秒使用自己的 $1$ 号武器可以取到最大值。其中单个武器释放的能量为 $(-2)+(2+3+4+9) = 16$，武器碰撞释放 $d_{1,4} = 4$ 单位的能量，小 A 在前 $3$ 秒吸收了 $A \\times 3 + B = 5$ 单位的能量。\n\n### 数据范围：\n\n|Subtask|$n\\leq$|$m\\leq$|分值|\n|-|-|-|-|\n|$1$|$10$|$10$|$20$|\n|$2$|$500$|$500$|$30$|\n|$3$|$3000$|$3000$|$50$|\n\n**本题采用捆绑测试**，您只有通过了一个 Subtask 中的所有测试点才能得到这个 Subtask 的分数。\n\n对于 $100\\%$ 的数据：$0 \\le |a_k|,|b_k|,|d_{i,j}|,A,B,C,D \\leq 1000$, $1\\leq n, m\\leq 3000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[DMOI-R1] 实验基地", "background": "小 A 和小 B 用实验基地全新的装备进行了一场世纪蒟蒻之战。", "description": "众所周知，实验基地的武器都是一次性的。现在，小 A 选取了 $n$ 把不同的武器，小 B 也获取了 $m$ 把不同武器。每个人的武器都可以用编号 $1$ 到编号 $n$ 或 $m$ 依次表示，他们将会按此顺序逐个使用武器。\n\n实验仓库记录了所有武器的火力。小 A 的第 $k$ 把武器能爆发出 $a_k$ 的能量，而小 B 的第 $k$ 把武器能爆发出 $b_k$ 的能量。特别的，当小 A 的第 $i$ 把武器与小 B 的第 $j$ 把武器同时使用，会释放 $d_{i,j}$ 的能量。由于某些不可描述的组合的奇效，$a,b,d$ **都可能小于** $0$。\n\n当某人第一个使用了武器，战斗就正式开始，记为第 $1$ 秒，直至某人使用完武器后再无人使用武器，记此时为第 $t$ 秒（$t$ **不为输入数据**）。也就是说，**在第 $1$ 秒和第 $t$ 秒必须有人使用武器，而在 $1$ 至 $t$ 秒内在符合其他条件下，每一秒双方可以选择按顺序使用武器或不使用**。\n\n为了避免打死对方，**双方都不一定使用完武器**。\n\n由于实验基地有发电装置，如果小 A 没有连续使用武器释放能量，而是休息了 $x$ 秒，那么祂将会吸收掉 $Ax+B\\ (A,B \\in \\mathbb{N})$ 的能量。同样，小 B 间隔 $y$ 秒将吸收 $Cy+D\\ (C,D \\in \\mathbb{N})$ 的能量。连续两秒都释放武器间隔时间为 $0$ 秒，以此类推。\n\n为了防止基地被核爆，你需要算出战斗结束后可能释放的最大总能量（可能为负数）。\n\n**若对题目细节有疑惑请先读提示内的额外解释。**", "inputFormat": "第一行有两个数 $n$ 和 $m$。\n\n第二行有 $n$ 个数，第 $k$ 个数字即 $a_k$。\n\n第三行有 $m$ 个数，第 $k$ 个数字即 $b_k$。\n\n接下来 $n$ 行，每行 $m$ 个数字，其中第 $i$ 行第 $j$ 列表示的是 $d_{i,j}$。\n\n最后一行有四个非负整数 $A,B,C,D$。", "outputFormat": "只有一行，输出一个数字，即最大可能能量。", "hint": "1. 战斗的开始时间（第 $1$ 秒）为双方某人最先释放出第一个技能的时间，战斗结束时间为双方某人释放出最后一个技能的时间。**结束时间不定**。\n\n2. 技能必须按顺序释放，但**不一定需要在战斗中释放完**。\n\n3. $a,b,d$ 可以为负数，总计能量可能为负，“吸收能量”指总能量减少 $Ax+B$ 或 $Cy+D$，也就是**间隔时总能量一定减少**，而且时间越长减少越多。\n\n4. 本题 IO 量较大，建议使用合适的读入方式。\n\n### 样例解释：\n\n样例 1：每个人在 $1$ 到 $6$ 秒依次使用自己的编号为 $1$ 到 $6$  的武器即可取到最大值。\n\n样例 2：小 B 在 $1$ 到 $4$ 秒依次使用自己的编号为 $1$ 到 $4$ 的武器，小 A 在第 $4$ 秒使用自己的 $1$ 号武器可以取到最大值。其中单个武器释放的能量为 $(-2)+(2+3+4+9) = 16$，武器碰撞释放 $d_{1,4} = 4$ 单位的能量，小 A 在前 $3$ 秒吸收了 $A \\times 3 + B = 5$ 单位的能量。\n\n### 数据范围：\n\n|Subtask|$n\\leq$|$m\\leq$|分值|\n|-|-|-|-|\n|$1$|$10$|$10$|$20$|\n|$2$|$500$|$500$|$30$|\n|$3$|$3000$|$3000$|$50$|\n\n**本题采用捆绑测试**，您只有通过了一个 Subtask 中的所有测试点才能得到这个 Subtask 的分数。\n\n对于 $100\\%$ 的数据：$0 \\le |a_k|,|b_k|,|d_{i,j}|,A,B,C,D \\leq 1000$, $1\\leq n, m\\leq 3000$。", "locale": "zh-CN"}}}
{"pid": "P8889", "type": "P", "difficulty": 2, "samples": [["6 2\n3 4 3 5 2 6\n5 4", "3"], ["6 3\n3 4 3 5 2 6\n3 5 6", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["二分", "2022", "O2优化", "排序", "双指针 two-pointer", "语言月赛"], "title": "[入门赛 #7] 狠狠地切割 (Hard Version)", "background": "**本题与 H1 的题意完全一致，区别仅在数据范围。在语言月赛中不存在 H2 题目，本题仅用于增加公开赛的区分度，并不严格遵循比赛考察范围，请酌情完成。**", "description": "现给你一个长度为 $n$ 的序列 $a _ 1, \\cdots, a _ n$ 和 $m$ 个互不相同的整数 $b _ 1, \\cdots, b _ m$。你需要按照这 $m$ 个数对序列 $a$ 进行**狠狠地切割**。\n\n具体的，对于一个数字 $i \\in [1, n]$，如果存在一个整数 $j \\in [1, m]$，使得 $a _ i = b _ j$，则将位置 $i$ 称为一个**切割点**。对序列 $a$ 中的每一个切割点，我们在这个位置进行一次**狠狠地切割**。方法是，将该位置的数字去除，然后在这个位置将其左右的**序列/片段**一分两半。\n\n如果对**狠狠地切割**的定义有疑问，可以参照「样例 #1」及「样例解释 #1」进行理解。\n\n你需要计算，在进行了所有可能的**狠狠地切割**后，序列被切割为了多少**片段**。\n\n特别的，如果在切割后，某一段内没有数组，那这一段不可被叫做**片段**。同样的，如果 $1$ 或 $n$ 为切割点，其与开头和结尾之间也不存在片段。\n\n如果对**片段**的概念有疑问，可以参照「样例 #2」及「样例解释 #2」进行理解。", "inputFormat": "第一行为两个整数，依次表示序列 $a$ 的长度 $n$ 和序列 $b$ 的长度 $m$。  \n第二行有 $n$ 个整数，第 $i$ 个整数表示 $a_i$。  \n第三行有 $m$ 个整数，第 $i$ 个整数表示 $b_i$。", "outputFormat": "\n输出一个整数，代表**狠狠地切割**后的**片段**的个数。", "hint": "### 样例 1 解释\n\n在**狠狠地切割**前，序列 $a$ 如下所示：\n\n$$\\begin{matrix} 3 & 4 & 3 & 5 & 2 & 6 \\end{matrix}$$\n\n容易知道，第二个位置和第四个位置为切割点，我们使用 `|` 对其进行替换，代表去除工作：\n\n$$\\begin{matrix} 3 & | & 3 & | & 2 & 6 \\end{matrix}$$\n\n我们将片段进行简单的标记：\n\n$$\\begin{matrix} \\overbrace{3} ^ \\text{片段 1} & | & \\overbrace{3} ^ \\text{片段 2} & | & \\overbrace{2 \\quad 6} ^ \\text{片段 3} \\end{matrix}$$\n\n共计 $3$ 个片段。\n\n### 样例 2 解释\n\n以下我们展示去除之后的序列：\n\n$$\\begin{matrix} | & 4 & | & | & 2 & | \\end{matrix}$$\n\n我们将片段进行简单的标记：\n\n$$\\begin{matrix} \\overbrace{\\vphantom{0}} ^ \\text{\\color{red}这个不是片段} | & \\overbrace{4} ^ \\text{片段 1} & | & \\overbrace{\\vphantom{0}} ^ \\text{\\color{red}这个不是片段} & | & \\overbrace{2} ^ \\text{片段 2} & | \\overbrace{\\vphantom{0}} ^ \\text{\\color{red}这个不是片段}\\end{matrix}$$\n\n共计 $2$ 个片段。\n\n### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $a$ 序列中没有任何元素在 $b$ 中出现过。形式化的，$\\forall i \\in [1, n], \\forall j \\in [1, m], a _ i \\neq b _ j$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n, m \\leq 5 \\times 10 ^ 5$，$- 10 ^ {18} \\leq a _ i, b_i \\leq 10 ^ {18}$，序列 $b$ 中的元素两两不同。\n\n### 提示\n本题输入规模较大，建议考虑使用较快的读入读出方式。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[入门赛 #7] 狠狠地切割 (Hard Version)", "background": "**本题与 H1 的题意完全一致，区别仅在数据范围。在语言月赛中不存在 H2 题目，本题仅用于增加公开赛的区分度，并不严格遵循比赛考察范围，请酌情完成。**", "description": "现给你一个长度为 $n$ 的序列 $a _ 1, \\cdots, a _ n$ 和 $m$ 个互不相同的整数 $b _ 1, \\cdots, b _ m$。你需要按照这 $m$ 个数对序列 $a$ 进行**狠狠地切割**。\n\n具体的，对于一个数字 $i \\in [1, n]$，如果存在一个整数 $j \\in [1, m]$，使得 $a _ i = b _ j$，则将位置 $i$ 称为一个**切割点**。对序列 $a$ 中的每一个切割点，我们在这个位置进行一次**狠狠地切割**。方法是，将该位置的数字去除，然后在这个位置将其左右的**序列/片段**一分两半。\n\n如果对**狠狠地切割**的定义有疑问，可以参照「样例 #1」及「样例解释 #1」进行理解。\n\n你需要计算，在进行了所有可能的**狠狠地切割**后，序列被切割为了多少**片段**。\n\n特别的，如果在切割后，某一段内没有数组，那这一段不可被叫做**片段**。同样的，如果 $1$ 或 $n$ 为切割点，其与开头和结尾之间也不存在片段。\n\n如果对**片段**的概念有疑问，可以参照「样例 #2」及「样例解释 #2」进行理解。", "inputFormat": "第一行为两个整数，依次表示序列 $a$ 的长度 $n$ 和序列 $b$ 的长度 $m$。  \n第二行有 $n$ 个整数，第 $i$ 个整数表示 $a_i$。  \n第三行有 $m$ 个整数，第 $i$ 个整数表示 $b_i$。", "outputFormat": "\n输出一个整数，代表**狠狠地切割**后的**片段**的个数。", "hint": "### 样例 1 解释\n\n在**狠狠地切割**前，序列 $a$ 如下所示：\n\n$$\\begin{matrix} 3 & 4 & 3 & 5 & 2 & 6 \\end{matrix}$$\n\n容易知道，第二个位置和第四个位置为切割点，我们使用 `|` 对其进行替换，代表去除工作：\n\n$$\\begin{matrix} 3 & | & 3 & | & 2 & 6 \\end{matrix}$$\n\n我们将片段进行简单的标记：\n\n$$\\begin{matrix} \\overbrace{3} ^ \\text{片段 1} & | & \\overbrace{3} ^ \\text{片段 2} & | & \\overbrace{2 \\quad 6} ^ \\text{片段 3} \\end{matrix}$$\n\n共计 $3$ 个片段。\n\n### 样例 2 解释\n\n以下我们展示去除之后的序列：\n\n$$\\begin{matrix} | & 4 & | & | & 2 & | \\end{matrix}$$\n\n我们将片段进行简单的标记：\n\n$$\\begin{matrix} \\overbrace{\\vphantom{0}} ^ \\text{\\color{red}这个不是片段} | & \\overbrace{4} ^ \\text{片段 1} & | & \\overbrace{\\vphantom{0}} ^ \\text{\\color{red}这个不是片段} & | & \\overbrace{2} ^ \\text{片段 2} & | \\overbrace{\\vphantom{0}} ^ \\text{\\color{red}这个不是片段}\\end{matrix}$$\n\n共计 $2$ 个片段。\n\n### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $a$ 序列中没有任何元素在 $b$ 中出现过。形式化的，$\\forall i \\in [1, n], \\forall j \\in [1, m], a _ i \\neq b _ j$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n, m \\leq 5 \\times 10 ^ 5$，$- 10 ^ {18} \\leq a _ i, b_i \\leq 10 ^ {18}$，序列 $b$ 中的元素两两不同。\n\n### 提示\n本题输入规模较大，建议考虑使用较快的读入读出方式。", "locale": "zh-CN"}}}
{"pid": "P8890", "type": "P", "difficulty": 4, "samples": [["2 2 4\n0:00:01 A abc Wrong Answer\n0:00:02 A abc Accepted\n0:19:38 A bcd Accepted\n4:18:22 B abc Accepted", "abc\nbcd\nabc\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["模拟", "2022", "O2优化", "结构体", "语言月赛"], "title": "[入门赛 #7] 打 ACM 最快乐的就是滚榜读队名了 (Hard Version)", "background": "**本题的题意与 [I1](https://www.luogu.com.cn/problem/B3692) 完全相同，区别仅在 $m$ 和 $K$ 的范围。**\n\n在刚刚结束的 ICPC 杭州赛站上，某 E 经历了刺激的滚榜。她发现打 ACM 最快乐的就是滚榜读队名了。", "description": "一场 ICPC 正式赛共 $5$ 小时。\n\n队伍的排名由通过题数与罚时决定。通过题数更多的队伍排名更靠前，若通过题数相同，则罚时更小的队伍排名更靠前。通过题数与罚时均相同的队伍排名相同。本题中可能出现队伍排名相同的情况，此时，认为先出现在提交记录中的队伍排名靠前。\n\n罚时是由通过题目的时间和未通过提交的次数决定的。罚时为每一道题通过时比赛开始的分钟数之和，加上该题之前未通过提交的次数乘 $20$ 分钟得到的。例如，某队在比赛进行 $1:28:35$ 时通过了 G 题，在此之前共有 $3$ 次未通过的提交，则 G 题对罚时的总贡献为 $88+3 \\times 20=148$ 分钟。\n\n**需要注意的是，仅有通过的试题的未通过提交会被计算罚时**。例如，某队在 I 题共有 $14$ 次未通过的提交，但到比赛结束，该队都没有通过 I 题，则这 $14$ 次未通过的提交不会被计算罚时。**在某一题通过后，该队对这一题的任何提交（无论是否能够通过）都不会影响本题通过的结果和本题的罚时。**\n\n选手在比赛过程中可以随时提交某一道试题的代码，代码将被立即评测并返回结果（$\\texttt{Accepted}$，$\\texttt{Time Limit Exceeded}$，$\\texttt{Memory Limit Exceeded}$，$\\texttt{Presentation Error}$，$\\texttt{Wrong Answer}$，$\\texttt{Runtime Error}$）。其中，评测结果 $\\texttt{Accepted}$ 为通过，其他评测结果均为不通过。\n\n在比赛进行的前四小时（$0:00:00 \\sim 4:00:00$），每支队伍的提交均会在排行榜上反映出来。比赛的最后一小时（$4:00:01 \\sim 5:00:00$），排行榜将被冻结（封榜），所有的提交在排行榜对应队伍对应试题上均显示为待判题（提交的队伍知道评测结果）。\n\n在比赛结束后，会进行紧张刺激的滚榜环节。滚榜嘉宾将按照封榜时的排行榜，依照从最后一名到第一名，**先读出队伍队名**，再按照从 A 题依次到最后一题的顺序，公布排行榜上该队“待判题”状态试题最终是否通过。\n\n如果通过，所有队伍的排名将立即重新计算，显然，已经滚榜完成（被滚榜嘉宾念过队名，且所有待判题状态的结果都已经揭晓）的队伍排名不会有影响。若该队伍排名上升，则滚榜嘉宾立即开始下一支队伍的滚榜。因此，一支队伍的队名可能被滚榜嘉宾多次读出。\n\n例如，某队队名为“囤题”，在前四小时没有通过任何一题，封榜时排在最后一名。在封榜后，该队连续通过全部十三道题目。那么滚榜嘉宾有可能读到该队队名七八次。当然，当该队上升到第一名后，其排名不会再发生变化，即使揭晓的判题结果为通过，但其排名没有发生变化，滚榜嘉宾不会再次读出其队名。\n\n现在给出某场 ICPC 完整的提交记录，请你依次输出滚榜嘉宾念出的队名。\n\n**一次提交记录都没有的队伍不会在排行榜上出现，也不会在滚榜中被念到队名。**", "inputFormat": "输入的第一行为三个整数 $n,m,K$，依次为该场 ICPC 试题数、该场 ICPC 队伍数、该场 ICPC 提交记录数。\n\n接下来 $K$ 行，每行为四个空格分隔的字符串，表达一条提交记录。第一个形如 $x:yy:zz$，代表该记录在比赛开始 $x$ 小时 $yy$ 分钟 $zz$ 秒时提交。第二个字符串为一个大写英文字母，代表试题的编号（$\\texttt{A,B,} \\cdots$）。第三个字符串为队名，保证队名不含空格。第四个字符串（可能含有空格，但为仅出现「题目描述」中的六种评测结果）为该评测记录的评测结果，具体字符串的含义见试题描述部分。", "outputFormat": "输出若干行，为该滚榜嘉宾依次读到的队名。", "hint": "### 样例解释\n\n在封榜前，队伍 $\\texttt{abc}$ 仅通过 $\\texttt{A}$ 题，且在第二秒的第一次正确提交之前有一次错误提交，因此罚时为 $20$ 分钟；队伍 $\\texttt{bcd}$ 同样仅通过 $\\texttt{A}$ 题，且在 $0:19:38$ 的第一次正确提交之前没有错误提交，因此罚时为 $19$ 分钟。\n\n在封榜后，队伍 $\\texttt{abc}$ 通过了 $\\texttt{B}$ 题。\n\n在滚榜环节开始，由于封榜后的提交未被揭晓，因此暂时认为队伍 $\\texttt{abc}$ 与 $\\texttt{bcd}$ 均只通过一题，且前者罚时较大，排名靠后。\n\n依照从最后一名到第一名的原则，队伍 $\\texttt{abc}$ 的名字先被念到，并揭晓其在封榜后的提交的结果。其通过了 $\\texttt{B}$ 题，因此其通过题数被更新为 $2$，罚时同样被更新。同时，所有队伍的排名立即被重新计算。由于此时 $\\texttt{abc}$ 通过题目数量大于 $\\texttt{bcd}$，因此其排名重新计算为第一名，而 $\\texttt{bcd}$ 成为最后一名第二名。\n\n这之后，队伍 $\\texttt{bcd}$ 的名字被念到，由于其在封榜后没有提交，因此这时所有队伍的排名没有变化，滚榜嘉宾会进行其上一名队伍的滚榜。\n\n最后，队伍 $\\texttt{abc}$ 的名字被念到，滚榜结束。\n\n需要注意的是，在滚榜过程中是逐题揭晓提交。也就是说，如果一支队伍封榜后通过了多道题，在其进行滚榜过程中，只要按照从 $\\texttt{A}$ 题依次到最后一题的顺序，该队第一个“待判题”状态试题通过，后面的“待判题”同样暂时不会揭晓，而是立刻进行排名更新过程以及可能存在的更换另一支队伍进行滚榜的过程。\n\n### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 20$，$1 \\le m \\le 2 \\times 10^5$，$1 \\le K \\le 2 \\times 10^6$，$0 \\leq x \\leq 5$，$00 \\leq yy < 60$，$00 \\leq zz < 60$，且当 $x = 5$ 时保证 $yy = zz = 00$。\n\n保证提交记录按照提交时间不降序给出，即先给出的提交记录提交时间不会晚于后给出的提交记录的提交时间，试题名称为大写字母 $\\texttt{A} \\sim \\texttt{Z}$，队名均为长度不超过 $50$ 的由小写字母组成的字符串，评测状态为试题中所给的 $6$ 种之一。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[入门赛 #7] 打 ACM 最快乐的就是滚榜读队名了 (Hard Version)", "background": "**本题的题意与 [I1](https://www.luogu.com.cn/problem/B3692) 完全相同，区别仅在 $m$ 和 $K$ 的范围。**\n\n在刚刚结束的 ICPC 杭州赛站上，某 E 经历了刺激的滚榜。她发现打 ACM 最快乐的就是滚榜读队名了。", "description": "一场 ICPC 正式赛共 $5$ 小时。\n\n队伍的排名由通过题数与罚时决定。通过题数更多的队伍排名更靠前，若通过题数相同，则罚时更小的队伍排名更靠前。通过题数与罚时均相同的队伍排名相同。本题中可能出现队伍排名相同的情况，此时，认为先出现在提交记录中的队伍排名靠前。\n\n罚时是由通过题目的时间和未通过提交的次数决定的。罚时为每一道题通过时比赛开始的分钟数之和，加上该题之前未通过提交的次数乘 $20$ 分钟得到的。例如，某队在比赛进行 $1:28:35$ 时通过了 G 题，在此之前共有 $3$ 次未通过的提交，则 G 题对罚时的总贡献为 $88+3 \\times 20=148$ 分钟。\n\n**需要注意的是，仅有通过的试题的未通过提交会被计算罚时**。例如，某队在 I 题共有 $14$ 次未通过的提交，但到比赛结束，该队都没有通过 I 题，则这 $14$ 次未通过的提交不会被计算罚时。**在某一题通过后，该队对这一题的任何提交（无论是否能够通过）都不会影响本题通过的结果和本题的罚时。**\n\n选手在比赛过程中可以随时提交某一道试题的代码，代码将被立即评测并返回结果（$\\texttt{Accepted}$，$\\texttt{Time Limit Exceeded}$，$\\texttt{Memory Limit Exceeded}$，$\\texttt{Presentation Error}$，$\\texttt{Wrong Answer}$，$\\texttt{Runtime Error}$）。其中，评测结果 $\\texttt{Accepted}$ 为通过，其他评测结果均为不通过。\n\n在比赛进行的前四小时（$0:00:00 \\sim 4:00:00$），每支队伍的提交均会在排行榜上反映出来。比赛的最后一小时（$4:00:01 \\sim 5:00:00$），排行榜将被冻结（封榜），所有的提交在排行榜对应队伍对应试题上均显示为待判题（提交的队伍知道评测结果）。\n\n在比赛结束后，会进行紧张刺激的滚榜环节。滚榜嘉宾将按照封榜时的排行榜，依照从最后一名到第一名，**先读出队伍队名**，再按照从 A 题依次到最后一题的顺序，公布排行榜上该队“待判题”状态试题最终是否通过。\n\n如果通过，所有队伍的排名将立即重新计算，显然，已经滚榜完成（被滚榜嘉宾念过队名，且所有待判题状态的结果都已经揭晓）的队伍排名不会有影响。若该队伍排名上升，则滚榜嘉宾立即开始下一支队伍的滚榜。因此，一支队伍的队名可能被滚榜嘉宾多次读出。\n\n例如，某队队名为“囤题”，在前四小时没有通过任何一题，封榜时排在最后一名。在封榜后，该队连续通过全部十三道题目。那么滚榜嘉宾有可能读到该队队名七八次。当然，当该队上升到第一名后，其排名不会再发生变化，即使揭晓的判题结果为通过，但其排名没有发生变化，滚榜嘉宾不会再次读出其队名。\n\n现在给出某场 ICPC 完整的提交记录，请你依次输出滚榜嘉宾念出的队名。\n\n**一次提交记录都没有的队伍不会在排行榜上出现，也不会在滚榜中被念到队名。**", "inputFormat": "输入的第一行为三个整数 $n,m,K$，依次为该场 ICPC 试题数、该场 ICPC 队伍数、该场 ICPC 提交记录数。\n\n接下来 $K$ 行，每行为四个空格分隔的字符串，表达一条提交记录。第一个形如 $x:yy:zz$，代表该记录在比赛开始 $x$ 小时 $yy$ 分钟 $zz$ 秒时提交。第二个字符串为一个大写英文字母，代表试题的编号（$\\texttt{A,B,} \\cdots$）。第三个字符串为队名，保证队名不含空格。第四个字符串（可能含有空格，但为仅出现「题目描述」中的六种评测结果）为该评测记录的评测结果，具体字符串的含义见试题描述部分。", "outputFormat": "输出若干行，为该滚榜嘉宾依次读到的队名。", "hint": "### 样例解释\n\n在封榜前，队伍 $\\texttt{abc}$ 仅通过 $\\texttt{A}$ 题，且在第二秒的第一次正确提交之前有一次错误提交，因此罚时为 $20$ 分钟；队伍 $\\texttt{bcd}$ 同样仅通过 $\\texttt{A}$ 题，且在 $0:19:38$ 的第一次正确提交之前没有错误提交，因此罚时为 $19$ 分钟。\n\n在封榜后，队伍 $\\texttt{abc}$ 通过了 $\\texttt{B}$ 题。\n\n在滚榜环节开始，由于封榜后的提交未被揭晓，因此暂时认为队伍 $\\texttt{abc}$ 与 $\\texttt{bcd}$ 均只通过一题，且前者罚时较大，排名靠后。\n\n依照从最后一名到第一名的原则，队伍 $\\texttt{abc}$ 的名字先被念到，并揭晓其在封榜后的提交的结果。其通过了 $\\texttt{B}$ 题，因此其通过题数被更新为 $2$，罚时同样被更新。同时，所有队伍的排名立即被重新计算。由于此时 $\\texttt{abc}$ 通过题目数量大于 $\\texttt{bcd}$，因此其排名重新计算为第一名，而 $\\texttt{bcd}$ 成为最后一名第二名。\n\n这之后，队伍 $\\texttt{bcd}$ 的名字被念到，由于其在封榜后没有提交，因此这时所有队伍的排名没有变化，滚榜嘉宾会进行其上一名队伍的滚榜。\n\n最后，队伍 $\\texttt{abc}$ 的名字被念到，滚榜结束。\n\n需要注意的是，在滚榜过程中是逐题揭晓提交。也就是说，如果一支队伍封榜后通过了多道题，在其进行滚榜过程中，只要按照从 $\\texttt{A}$ 题依次到最后一题的顺序，该队第一个“待判题”状态试题通过，后面的“待判题”同样暂时不会揭晓，而是立刻进行排名更新过程以及可能存在的更换另一支队伍进行滚榜的过程。\n\n### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 20$，$1 \\le m \\le 2 \\times 10^5$，$1 \\le K \\le 2 \\times 10^6$，$0 \\leq x \\leq 5$，$00 \\leq yy < 60$，$00 \\leq zz < 60$，且当 $x = 5$ 时保证 $yy = zz = 00$。\n\n保证提交记录按照提交时间不降序给出，即先给出的提交记录提交时间不会晚于后给出的提交记录的提交时间，试题名称为大写字母 $\\texttt{A} \\sim \\texttt{Z}$，队名均为长度不超过 $50$ 的由小写字母组成的字符串，评测状态为试题中所给的 $6$ 种之一。", "locale": "zh-CN"}}}
{"pid": "P8891", "type": "P", "difficulty": 1, "samples": [["6 1\n1 1 4 5 1 1\n0 7", "1 1 4 5 1 1"], ["3 1\n0 3 9\n1 2", "-2 3 9"], ["见文件附件的 queries3.in", "见文件附件的 queries3.ans"], ["见文件附件的 queries4.in", "见文件附件的 queries4.ans"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "O2优化"], "title": "「UOI-R1」询问", "background": "ZSS 有一个序列，但他实在不太聪明，以至于一个操作问题都要来问你了。", "description": "给定 $n$ 个数的整数序列 $a_1, a_2, \\cdots, a_n$，有 $m$ 次操作，每次操作给定 $x, y$，你需要找到所有 $i$，满足 $i \\oplus x = 0$，然后 $a_i \\gets a_i - y$。如果没有任何一个这样的 $i$，则序列什么也不会更改。这里的 $\\oplus$ 为按位异或操作。\n\n操作结束后，你需要输出这个序列。", "inputFormat": "第一行，两个正整数 $n,m$，表示序列长度和操作次数。\n\n接下来一行，表示初始序列。\n\n接下来 $m$ 行，每行两个数 $x,y$，意思如题面所示。", "outputFormat": "输出一行，$n$ 个数，表示操作结束后的序列。", "hint": "对于 $20\\%$ 的数据，保证 $1 \\leq n, m \\leq 10^3$。\n\n对于另外 $20\\%$ 的数据，保证 $x=0$。\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n, m \\leq 10^6$，$-10^8 \\leq y, a_i \\leq 10^{8}$，$0 \\leq x \\leq n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「UOI-R1」询问", "background": "ZSS 有一个序列，但他实在不太聪明，以至于一个操作问题都要来问你了。", "description": "给定 $n$ 个数的整数序列 $a_1, a_2, \\cdots, a_n$，有 $m$ 次操作，每次操作给定 $x, y$，你需要找到所有 $i$，满足 $i \\oplus x = 0$，然后 $a_i \\gets a_i - y$。如果没有任何一个这样的 $i$，则序列什么也不会更改。这里的 $\\oplus$ 为按位异或操作。\n\n操作结束后，你需要输出这个序列。", "inputFormat": "第一行，两个正整数 $n,m$，表示序列长度和操作次数。\n\n接下来一行，表示初始序列。\n\n接下来 $m$ 行，每行两个数 $x,y$，意思如题面所示。", "outputFormat": "输出一行，$n$ 个数，表示操作结束后的序列。", "hint": "对于 $20\\%$ 的数据，保证 $1 \\leq n, m \\leq 10^3$。\n\n对于另外 $20\\%$ 的数据，保证 $x=0$。\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n, m \\leq 10^6$，$-10^8 \\leq y, a_i \\leq 10^{8}$，$0 \\leq x \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P8892", "type": "P", "difficulty": 2, "samples": [["1\n12341234\n1234", "Y"], ["1\n6012739810910020338452\n12345678", "Y"], ["1\n123456789\n465", "N"], ["见文件附件的 magnets4.in", "见文件附件的 magnets4.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "O2优化"], "title": "「UOI-R1」磁铁", "background": "", "description": "有两串磁铁 $a,b$，均可以看作由一些小写或大写字符或数字组成的。\n\n你可以对磁铁 $a$ 进行**无限次**操作，每次操作可以是以下两个中的一个：\n\n1. 将前若干个字符删除，例如删除 $\\texttt{91987}$ 的前 $3$ 个字符后字符串将会变成 $\\texttt{87}$。\n2. 将后若干个字符移至前面去，例如将 $\\texttt{91987}$ 的后 $3$ 个字符移至前面去后字符串会变成 $\\texttt{98791}$。\n\n问经过操作后，能否使磁铁 $a$ 和 $b$ 相等，$a$ 和 $b$ 相等当且仅当 $a$ 和 $b$ 长度相等且每个字符都相同。\n\n为了防止 ````不可以，总司令```` 的情况发生，你需要回答多次。", "inputFormat": "第一行，数据组数 $t$。\n\n接下来 $t$ 组数据，每组两行字符串，表示磁铁串 $a, b$。", "outputFormat": "输出 $t$ 行，每行输出 `Y` 或 `N` 表示操作后可以或不可以使得 $a$ 和 $b$ 相等。", "hint": "**【样例解释 #1】** \n\n$$\n\\texttt{12341234}\\\\ \\to \\texttt{1234}\\\\ = \\texttt{1234}\n$$\n\n**【样例解释 #2】** \n\n$$\n\\texttt{6012739810910020338452}\\\\\n\\to \\texttt{2601273981091002033845}\\\\\n\\to \\texttt{601273981091002033845}\\\\\n\\to \\texttt{384560127398109100203}\\\\\n\\to \\texttt{4560127398109100203}\\\\\n\\to \\texttt{0345601273981091002}\\\\\n\\to \\texttt{345601273981091002}\\\\\n\\to \\texttt{091002345601273981}\\\\\n\\to \\texttt{2345601273981}\\\\\n\\to \\texttt{3981234560127}\\\\\n\\to \\texttt{81234560127}\\\\\n\\to \\texttt{01278123456}\\\\\n\\to \\texttt{78123456}\\\\\n\\to \\texttt{12345678} \\\\\n=\\texttt{12345678}\n$$\n\n**【数据范围】**\n\n以下记 $ \\left| a \\right|$ 表示每组数据磁铁 $a$ 的长度，$\\left| b \\right|$ 表示每组数据磁铁 $b$ 的长度。\n\n对于 $20\\%$ 的数据，保证 $\\left| a \\right| = 1$。\n\n对于另外 $20\\%$ 的数据，保证 $\\left| b \\right| = 1$。\n\n对于 $100\\%$，保证 $1 \\leq \\left| a \\right|, \\left| b \\right| \\leq 1000$，$1 \\leq t \\leq 10$。\n\n保证 $a$ 和 $b$ 非空且只包含大小写英文字母或数字。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「UOI-R1」磁铁", "background": "", "description": "有两串磁铁 $a,b$，均可以看作由一些小写或大写字符或数字组成的。\n\n你可以对磁铁 $a$ 进行**无限次**操作，每次操作可以是以下两个中的一个：\n\n1. 将前若干个字符删除，例如删除 $\\texttt{91987}$ 的前 $3$ 个字符后字符串将会变成 $\\texttt{87}$。\n2. 将后若干个字符移至前面去，例如将 $\\texttt{91987}$ 的后 $3$ 个字符移至前面去后字符串会变成 $\\texttt{98791}$。\n\n问经过操作后，能否使磁铁 $a$ 和 $b$ 相等，$a$ 和 $b$ 相等当且仅当 $a$ 和 $b$ 长度相等且每个字符都相同。\n\n为了防止 ````不可以，总司令```` 的情况发生，你需要回答多次。", "inputFormat": "第一行，数据组数 $t$。\n\n接下来 $t$ 组数据，每组两行字符串，表示磁铁串 $a, b$。", "outputFormat": "输出 $t$ 行，每行输出 `Y` 或 `N` 表示操作后可以或不可以使得 $a$ 和 $b$ 相等。", "hint": "**【样例解释 #1】** \n\n$$\n\\texttt{12341234}\\\\ \\to \\texttt{1234}\\\\ = \\texttt{1234}\n$$\n\n**【样例解释 #2】** \n\n$$\n\\texttt{6012739810910020338452}\\\\\n\\to \\texttt{2601273981091002033845}\\\\\n\\to \\texttt{601273981091002033845}\\\\\n\\to \\texttt{384560127398109100203}\\\\\n\\to \\texttt{4560127398109100203}\\\\\n\\to \\texttt{0345601273981091002}\\\\\n\\to \\texttt{345601273981091002}\\\\\n\\to \\texttt{091002345601273981}\\\\\n\\to \\texttt{2345601273981}\\\\\n\\to \\texttt{3981234560127}\\\\\n\\to \\texttt{81234560127}\\\\\n\\to \\texttt{01278123456}\\\\\n\\to \\texttt{78123456}\\\\\n\\to \\texttt{12345678} \\\\\n=\\texttt{12345678}\n$$\n\n**【数据范围】**\n\n以下记 $ \\left| a \\right|$ 表示每组数据磁铁 $a$ 的长度，$\\left| b \\right|$ 表示每组数据磁铁 $b$ 的长度。\n\n对于 $20\\%$ 的数据，保证 $\\left| a \\right| = 1$。\n\n对于另外 $20\\%$ 的数据，保证 $\\left| b \\right| = 1$。\n\n对于 $100\\%$，保证 $1 \\leq \\left| a \\right|, \\left| b \\right| \\leq 1000$，$1 \\leq t \\leq 10$。\n\n保证 $a$ 和 $b$ 非空且只包含大小写英文字母或数字。\n\n", "locale": "zh-CN"}}}
{"pid": "P8893", "type": "P", "difficulty": 3, "samples": [["5 5 2\n1 2\n3\n3 2 1 2\n4 3 1 2 3\n5 3 1 3 4", "3"], ["1 1 1\n1\n0", "0"], ["7 7 2\n1 2\n2\n3 2 1 2\n6 2 1 2", "-1"], ["见文件附件的 rec4.in", "见文件附件的 rec4.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化", "拓扑排序"], "title": "「UOI-R1」智能推荐", "background": "数据已加强。", "description": "现在有 $N$ 道题。\n\n天数的编号从 $0$ 开始，每一天你可以做若干道题，你只能做以前推荐过的或者当天推荐的题（每道题只可以做一次）。第一天，智能推荐会推荐 $p$ 道题。\n\n推荐规则如下：\n\n对于第 $i$ 道题，如果有可能被推荐的话，就会有一个题目集合 $s_i$。当且仅当你把 $s_i$ 中每一道题都做出来并且其中有一道题是当天做的，那么下一天就会推荐第 $i$ 题。\n\n你想做完第 $K$ 道题，问至少第几天你才能满足愿望？\n", "inputFormat": "第一行三个整数 $N,K,p$，含义如题目所述。\n\n第二行 $p$ 个整数，表示第一天推荐的题的题号。\n\n第三行一个整数 $R$，表示有 $R$ 条推荐规则。\n\n接下来 $R$ 行，每行包含一条规则，每行格式如下：\n\n一个整数 $v_i$，表示要推荐的题的题号。接着一个整数 $s_i$，表示要使得这道题被推荐，一共要做的题目数量。接下来 $s_i$ 个整数 $p_i$，表示要做的每道题。\n", "outputFormat": "一个整数表示最少第几天才能满足愿望。\n\n如无论如何，第 $K$ 题都无法完成，则输出 `-1`。\n", "hint": "**【样例解释 #1】**\n\n第 $0$ 天推了第 $1,2$ 题，都做了。\n\n第 $1$ 推了第 $3$ 题，做了。\n\n第 $2$ 推了第 $4$ 题，做了。\n\n第 $3$ 推了第 $5$ 题，也就是第 $K$ 题，做了。\n\n第 $3$ 天即可做完第 $K$ 题目。\n\n**【样例解释 #2】**\n\n第 $0$ 天推了第 $1$ 题，也就是第 $K$ 题，做了。\n第 $0$ 天就做完了。\n\n**【数据范围】**\n\n以下记 $\\left| s_i \\right|$ 表示推荐规则中第 $i$ 条规则中，如果 $v_i$ 被推荐，要做的所有题。\n\n对于 $30\\%$ 的数据，保证 $1 \\leq N \\leq 100$。\n\n对于 $50\\%$ 的数据，保证没有环。\n\n对于 $100\\%$ 的数据，保证 $1 \\le K,s_i,p_i,v_i \\le N \\le 5\\times 10^3$，$0 \\leq R \\leq 5 \\times 10^3$。$|s_i|$ 互不相同，且对于每一个 $|s_i|$ 都有 $p_i$ 互不相同，$v_i$ 互不相同。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「UOI-R1」智能推荐", "background": "数据已加强。", "description": "现在有 $N$ 道题。\n\n天数的编号从 $0$ 开始，每一天你可以做若干道题，你只能做以前推荐过的或者当天推荐的题（每道题只可以做一次）。第一天，智能推荐会推荐 $p$ 道题。\n\n推荐规则如下：\n\n对于第 $i$ 道题，如果有可能被推荐的话，就会有一个题目集合 $s_i$。当且仅当你把 $s_i$ 中每一道题都做出来并且其中有一道题是当天做的，那么下一天就会推荐第 $i$ 题。\n\n你想做完第 $K$ 道题，问至少第几天你才能满足愿望？\n", "inputFormat": "第一行三个整数 $N,K,p$，含义如题目所述。\n\n第二行 $p$ 个整数，表示第一天推荐的题的题号。\n\n第三行一个整数 $R$，表示有 $R$ 条推荐规则。\n\n接下来 $R$ 行，每行包含一条规则，每行格式如下：\n\n一个整数 $v_i$，表示要推荐的题的题号。接着一个整数 $s_i$，表示要使得这道题被推荐，一共要做的题目数量。接下来 $s_i$ 个整数 $p_i$，表示要做的每道题。\n", "outputFormat": "一个整数表示最少第几天才能满足愿望。\n\n如无论如何，第 $K$ 题都无法完成，则输出 `-1`。\n", "hint": "**【样例解释 #1】**\n\n第 $0$ 天推了第 $1,2$ 题，都做了。\n\n第 $1$ 推了第 $3$ 题，做了。\n\n第 $2$ 推了第 $4$ 题，做了。\n\n第 $3$ 推了第 $5$ 题，也就是第 $K$ 题，做了。\n\n第 $3$ 天即可做完第 $K$ 题目。\n\n**【样例解释 #2】**\n\n第 $0$ 天推了第 $1$ 题，也就是第 $K$ 题，做了。\n第 $0$ 天就做完了。\n\n**【数据范围】**\n\n以下记 $\\left| s_i \\right|$ 表示推荐规则中第 $i$ 条规则中，如果 $v_i$ 被推荐，要做的所有题。\n\n对于 $30\\%$ 的数据，保证 $1 \\leq N \\leq 100$。\n\n对于 $50\\%$ 的数据，保证没有环。\n\n对于 $100\\%$ 的数据，保证 $1 \\le K,s_i,p_i,v_i \\le N \\le 5\\times 10^3$，$0 \\leq R \\leq 5 \\times 10^3$。$|s_i|$ 互不相同，且对于每一个 $|s_i|$ 都有 $p_i$ 互不相同，$v_i$ 互不相同。\n", "locale": "zh-CN"}}}
{"pid": "P8894", "type": "P", "difficulty": 3, "samples": [["2\n1 4\n2 3", "24"], ["见文件附件的 sum2.in", "见文件附件的 sum2.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "O2优化"], "title": "「UOI-R1」求和", "background": "", "description": "给定 $n$ 个区间 $p_i, q_i$。\n\n求$\\sum\\limits_{s_1={p_1}}^{q_1}\\sum\\limits_{s_2={p_2}}^{q_2}\\sum\\limits_{s_3={p_3}}^{q_3} \\cdots\\sum\\limits_{s_n={p_n}}^{q_n}\\max\\limits_{i=1}^ns_i$ 对 $998244353$ 取余的值。", "inputFormat": "第 $1$ 行，一个整数 $n$，表示区间数量。\n\n第 $2$ 至 $(n+1)$ 行，每行两个整数 $p_i,q_i$。", "outputFormat": "一个整数，表示答案。你需要将答案取余 $998244353$ 后输出。", "hint": "### 样例解释\n\n取 $s = \\{1, 2\\}, \\max\\limits_{i=1}^ns_i=2$。\n\n取 $s = \\{2, 2\\}, \\max\\limits_{i=1}^ns_i = 2$。\n\n取 $s = \\{3, 2\\}, \\max\\limits_{i=1}^ns_i = 3$。\n\n取 $s = \\{4, 2\\}, \\max\\limits_{i=1}^ns_i= 4$。\n\n取 $s = \\{1, 3\\}, \\max\\limits_{i=1}^ns_i=3$。\n\n取 $s = \\{2, 3\\}, \\max\\limits_{i=1}^ns_i = 3$。\n\n取 $s = \\{3, 3\\}, \\max\\limits_{i=1}^ns_i = 3$。\n\n取 $s = \\{4, 3\\}, \\max\\limits_{i=1}^ns_i= 4$。\n\n$2+2+3+4+3+3+3+4 = 24$。\n\n### 数据范围\n\n对于 $30\\%$ 的数据，保证 $n \\leq 8$，$p_i, q_i \\leq 10$。\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 5 \\times 10^3$，$1 \\leq p_i \\leq q_i \\leq 5 \\times 10^3$。有区间可能相同。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「UOI-R1」求和", "background": "", "description": "给定 $n$ 个区间 $p_i, q_i$。\n\n求$\\sum\\limits_{s_1={p_1}}^{q_1}\\sum\\limits_{s_2={p_2}}^{q_2}\\sum\\limits_{s_3={p_3}}^{q_3} \\cdots\\sum\\limits_{s_n={p_n}}^{q_n}\\max\\limits_{i=1}^ns_i$ 对 $998244353$ 取余的值。", "inputFormat": "第 $1$ 行，一个整数 $n$，表示区间数量。\n\n第 $2$ 至 $(n+1)$ 行，每行两个整数 $p_i,q_i$。", "outputFormat": "一个整数，表示答案。你需要将答案取余 $998244353$ 后输出。", "hint": "### 样例解释\n\n取 $s = \\{1, 2\\}, \\max\\limits_{i=1}^ns_i=2$。\n\n取 $s = \\{2, 2\\}, \\max\\limits_{i=1}^ns_i = 2$。\n\n取 $s = \\{3, 2\\}, \\max\\limits_{i=1}^ns_i = 3$。\n\n取 $s = \\{4, 2\\}, \\max\\limits_{i=1}^ns_i= 4$。\n\n取 $s = \\{1, 3\\}, \\max\\limits_{i=1}^ns_i=3$。\n\n取 $s = \\{2, 3\\}, \\max\\limits_{i=1}^ns_i = 3$。\n\n取 $s = \\{3, 3\\}, \\max\\limits_{i=1}^ns_i = 3$。\n\n取 $s = \\{4, 3\\}, \\max\\limits_{i=1}^ns_i= 4$。\n\n$2+2+3+4+3+3+3+4 = 24$。\n\n### 数据范围\n\n对于 $30\\%$ 的数据，保证 $n \\leq 8$，$p_i, q_i \\leq 10$。\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 5 \\times 10^3$，$1 \\leq p_i \\leq q_i \\leq 5 \\times 10^3$。有区间可能相同。\n", "locale": "zh-CN"}}}
{"pid": "P8895", "type": "P", "difficulty": 3, "samples": [["4 1 998244353\n1 2 2 3\n3 4", "2\n8"], ["见下发文件 sequence2.in", "见下发文件 sequence2.out"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "平衡树", "2022", "洛谷原创", "O2优化"], "title": "「DPOI-1」优美的序列", "background": "#### Update on 2022.12.18：新增一组针对 @[zhuoxingmu](https://www.luogu.com.cn/user/421155) 的 Hack 数据，放置于 #21，分值为 $5$ 分。\n#### Update on 2022.12.18：新增一组针对 @[大眼仔Happy](https://www.luogu.com.cn/user/537046) 的 Hack 数据，放置于 #22，分值为 $5$ 分。\n#### Update on 2025.7.7：新增两组 hack 数据，来自工单 <https://www.luogu.com.cn/ticket/XQCA458514>，放置于 #23、#24。#21~#24 全部改为 $0$ 分。\n------------\n不可以，总司令。", "description": "总司令给你一个长为 $n$ 的序列 $a$。\n\n他认为这个 $a$ 现在也许不够优美，他希望将其重排为一个 $a'$，使之变得优美。\n\n我们称一个长为 $n$ 的序列 $a$ 优美，当且仅当 $\\exists i \\in [1,n]$，满足：\n\n- $\\forall j \\in [1, i)$，$a_j > a_{j + 1}$。\n- $\\forall j \\in (i, n]$，$a_j > a_{j - 1}$。\n\n他命令你求出 $a$ 经过重排可以得到多少个不同的 $a'$。由于结果可能很大，你只需要求出结果对 $p$ 取模的值。\n\n由于一个固定的 $a$ 太无趣了，于是他给你 $m$ 次修改，每次修改形如 `x k`，表示令 $a_x \\leftarrow k$。你需要在每次修改后求出当前的答案。", "inputFormat": "第一行，三个整数 $n, m, p$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$；\n\n接下来 $m$ 行，每行两个整数 $x, k$，表示一次修改操作。", "outputFormat": "共 $m + 1$ 行，每行一个整数，表示初始状态下及每次修改后所求的值。", "hint": "#### 样例 #1 解释\n对于初始状态，满足条件的 $a'$ 有 $[2, 1, 2, 3], [3, 2, 1, 2]$，共 $2$ 个。\n\n对于第一次修改后的 $a = [1, 2, 4, 3]$，满足条件的 $a'$ 有 $[1, 2, 3, 4], [2, 1, 3, 4], [3, 1, 2, 4], [4, 1, 2, 3], [3, 2, 1, 4], [4, 2, 1, 3], [4, 3, 1, 2], [4, 3, 2, 1]$，共 $8$ 个。\n#### 样例 #2 解释\n该样例满足测试点 $15 \\sim 20$ 的限制。\n#### 数据范围\n| 测试点编号 | $n \\leq$ | $m \\leq$ | 特殊条件 |\n| :------: | :------: | :------: | :------: |\n| $1 \\sim 2$ | $10$ | $10$ | 无 |\n| $3 \\sim 4$ | $100$ | $100$ | 无 |\n| $5 \\sim 6$ | $10^3$ | $10^3$ | 无 |\n| $7 \\sim 10$ | $10^5$ | $10^5$ | 无 |\n| $11 \\sim 12$ | $5 \\times 10^5$ | $0$ | $a$ 为一个**排列** |\n| $13 \\sim 14$ | $5 \\times 10^5$ | $0$ | 无 |\n| $15 \\sim 20$ | $5 \\times 10^5$ | $5\\times 10^5$ | 无 |\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^5$，$0 \\leq m \\leq 5 \\times 10^5$，$2 \\leq p \\leq 10^9$，$1 \\leq a_i, k, x \\leq n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「DPOI-1」优美的序列", "background": "#### Update on 2022.12.18：新增一组针对 @[zhuoxingmu](https://www.luogu.com.cn/user/421155) 的 Hack 数据，放置于 #21，分值为 $5$ 分。\n#### Update on 2022.12.18：新增一组针对 @[大眼仔Happy](https://www.luogu.com.cn/user/537046) 的 Hack 数据，放置于 #22，分值为 $5$ 分。\n#### Update on 2025.7.7：新增两组 hack 数据，来自工单 <https://www.luogu.com.cn/ticket/XQCA458514>，放置于 #23、#24。#21~#24 全部改为 $0$ 分。\n------------\n不可以，总司令。", "description": "总司令给你一个长为 $n$ 的序列 $a$。\n\n他认为这个 $a$ 现在也许不够优美，他希望将其重排为一个 $a'$，使之变得优美。\n\n我们称一个长为 $n$ 的序列 $a$ 优美，当且仅当 $\\exists i \\in [1,n]$，满足：\n\n- $\\forall j \\in [1, i)$，$a_j > a_{j + 1}$。\n- $\\forall j \\in (i, n]$，$a_j > a_{j - 1}$。\n\n他命令你求出 $a$ 经过重排可以得到多少个不同的 $a'$。由于结果可能很大，你只需要求出结果对 $p$ 取模的值。\n\n由于一个固定的 $a$ 太无趣了，于是他给你 $m$ 次修改，每次修改形如 `x k`，表示令 $a_x \\leftarrow k$。你需要在每次修改后求出当前的答案。", "inputFormat": "第一行，三个整数 $n, m, p$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$；\n\n接下来 $m$ 行，每行两个整数 $x, k$，表示一次修改操作。", "outputFormat": "共 $m + 1$ 行，每行一个整数，表示初始状态下及每次修改后所求的值。", "hint": "#### 样例 #1 解释\n对于初始状态，满足条件的 $a'$ 有 $[2, 1, 2, 3], [3, 2, 1, 2]$，共 $2$ 个。\n\n对于第一次修改后的 $a = [1, 2, 4, 3]$，满足条件的 $a'$ 有 $[1, 2, 3, 4], [2, 1, 3, 4], [3, 1, 2, 4], [4, 1, 2, 3], [3, 2, 1, 4], [4, 2, 1, 3], [4, 3, 1, 2], [4, 3, 2, 1]$，共 $8$ 个。\n#### 样例 #2 解释\n该样例满足测试点 $15 \\sim 20$ 的限制。\n#### 数据范围\n| 测试点编号 | $n \\leq$ | $m \\leq$ | 特殊条件 |\n| :------: | :------: | :------: | :------: |\n| $1 \\sim 2$ | $10$ | $10$ | 无 |\n| $3 \\sim 4$ | $100$ | $100$ | 无 |\n| $5 \\sim 6$ | $10^3$ | $10^3$ | 无 |\n| $7 \\sim 10$ | $10^5$ | $10^5$ | 无 |\n| $11 \\sim 12$ | $5 \\times 10^5$ | $0$ | $a$ 为一个**排列** |\n| $13 \\sim 14$ | $5 \\times 10^5$ | $0$ | 无 |\n| $15 \\sim 20$ | $5 \\times 10^5$ | $5\\times 10^5$ | 无 |\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^5$，$0 \\leq m \\leq 5 \\times 10^5$，$2 \\leq p \\leq 10^9$，$1 \\leq a_i, k, x \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P8896", "type": "P", "difficulty": 4, "samples": [["2\n5\n0 1 4 0 0\n3 4 4 1 3\n3\n1 2 2\n2 2 2", "YES\nNO"], ["见下发文件 road2.in", "见下发文件 road2.out"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2022", "洛谷原创", "O2优化", "优先队列", "构造"], "title": "「DPOI-1」道路规划", "background": "不可以，总司令。", "description": "战场上有 $n$ 个据点，从 $1\\sim n$ 编号。**每两个据点**之间**都**有一条双向道路。\n\n一天，总司令来战区巡视，走着走着迷路了，于是愤怒地下达命令，让你把每一条双向道路变成单向的，使得这些道路**不包含环**（否则总司令会迷路）。但由于每个据点的规模互不相同，总司令从第 $i$ 个据点出发沿着单向道路能**直接到达**的据点数量需要在 $[l_i,r_i]$ 之间。换言之，第 $i$ 个点的出度需要在 $[l_i,r_i]$ 之间。你需要告诉总司令有没有可能满足他的需求。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行，一个整数 $n$，表示据点数量；\n\n第二行，$n$ 个整数 $l_1, l_2, \\dots, l_n$；\n\n第三行，$n$ 个整数 $r_1, r_2, \\dots, r_n$。", "outputFormat": "对于每组数据：\n\n一行，一个字符串。若可以满足总司令的需求，一行 `YES`；否则，一行 `NO`。", "hint": "#### 样例 #1 解释\n下面是第 $1$ 组数据中一种可行的方案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2uvwlydw.png)\n\n#### 样例 #2 解释\n该样例满足测试点 $3 \\sim 6$ 的限制。\n#### 数据范围\n**本题测试点分数不等分。**\n\n|  测试点编号  | $n \\le$ | 特殊条件 |每个测试点分数|\n| :----------: | :-----------: | :------: | :----: |\n|     $1\\sim 2$      |     $10$     |   无   |$5$|\n|     $3\\sim 6$      |     $1000$     |    无     |$5$|\n|     $7\\sim 8$      |     $10^5$     |    所有 $l_i = i-1$ 或所有 $l_i \\geq \\min (i, n - 1)$    |$5$|\n| $9 \\sim 10$  | $10^5$ | $l_i=0$ 或 $r_i=n-1$ |$5$|\n| $11 \\sim 15$ | $10^5$ | 无 |$10$|\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$，$0 \\leq l_i \\leq r_i < n$，$1 \\leq T \\leq 10$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「DPOI-1」道路规划", "background": "不可以，总司令。", "description": "战场上有 $n$ 个据点，从 $1\\sim n$ 编号。**每两个据点**之间**都**有一条双向道路。\n\n一天，总司令来战区巡视，走着走着迷路了，于是愤怒地下达命令，让你把每一条双向道路变成单向的，使得这些道路**不包含环**（否则总司令会迷路）。但由于每个据点的规模互不相同，总司令从第 $i$ 个据点出发沿着单向道路能**直接到达**的据点数量需要在 $[l_i,r_i]$ 之间。换言之，第 $i$ 个点的出度需要在 $[l_i,r_i]$ 之间。你需要告诉总司令有没有可能满足他的需求。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行，一个整数 $n$，表示据点数量；\n\n第二行，$n$ 个整数 $l_1, l_2, \\dots, l_n$；\n\n第三行，$n$ 个整数 $r_1, r_2, \\dots, r_n$。", "outputFormat": "对于每组数据：\n\n一行，一个字符串。若可以满足总司令的需求，一行 `YES`；否则，一行 `NO`。", "hint": "#### 样例 #1 解释\n下面是第 $1$ 组数据中一种可行的方案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2uvwlydw.png)\n\n#### 样例 #2 解释\n该样例满足测试点 $3 \\sim 6$ 的限制。\n#### 数据范围\n**本题测试点分数不等分。**\n\n|  测试点编号  | $n \\le$ | 特殊条件 |每个测试点分数|\n| :----------: | :-----------: | :------: | :----: |\n|     $1\\sim 2$      |     $10$     |   无   |$5$|\n|     $3\\sim 6$      |     $1000$     |    无     |$5$|\n|     $7\\sim 8$      |     $10^5$     |    所有 $l_i = i-1$ 或所有 $l_i \\geq \\min (i, n - 1)$    |$5$|\n| $9 \\sim 10$  | $10^5$ | $l_i=0$ 或 $r_i=n-1$ |$5$|\n| $11 \\sim 15$ | $10^5$ | 无 |$10$|\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$，$0 \\leq l_i \\leq r_i < n$，$1 \\leq T \\leq 10$。", "locale": "zh-CN"}}}
{"pid": "P8897", "type": "P", "difficulty": 2, "samples": [["4\n1 6 4 6", "12 4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "USACO", "2022", "排序"], "title": "[USACO22DEC] Cow College B", "background": "", "description": "Farmer John 计划为奶牛们新开办一所大学！ \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wiy5l6d6.png)\n\n有 $N(1 \\le N \\le 10^5)$ 头奶牛可能会入学。每头奶牛最多愿意支付 $c_i$ 的学费 $(1 \\le c_i \\le 10^6)$。 Farmer John 可以设定所有奶牛入学需要支付的学费。如果这笔学费大于一头奶牛愿意支付的最高金额，那么这头奶牛就不会入学。Farmer John 想赚尽可能多的钱，从而可以给他的讲师提供一笔可观的工资。请求出他能赚到的钱的数量，以及此时应当收取多少学费。 ", "inputFormat": "输入的第一行包含 $N$。\n\n第二行包含 $N$ 个整数 $c_1,c_2, \\cdots,c_N$，其中 $c_i$ 是奶牛 $i$ 愿意支付的最高学费金额。 ", "outputFormat": "输出 Farmer John 可以赚到的最大金额以及最优情况下他应该收取的学费。如果有多个解，输出收取学费最小的解。 \n \n**注意这个问题涉及到的整数可能需要使用 64 位整数型（例如，Java 中的 \"long\"，C/C++ 中的 \"long long\"）。**", "hint": "### 样例 1 解释\n\n如果 Farmer John 收费 $4$，那么 $3$ 头奶牛将会入学，从而使他赚取 $3 \\times 4=12$ 的金额。\n\n### 测试点性质\n\n- 测试点 $2-4$ 满足 $c_i \\le 1000$。\n- 测试点 $5-8$ 满足 $N \\le 5000$。\n- 测试点 $9-12$ 没有额外限制。 ", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Cow College B", "background": "", "description": "Farmer John plans to open a new college for his cows!\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wiy5l6d6.png)\n\nThere are $N(1 \\le N \\le 10^5)$ cows that might enroll. Each cow is willing to pay at most $c_i$ in tuition $(1 \\le c_i \\le 10^6)$. Farmer John can set a single tuition that all cows must pay to enroll. If this tuition is greater than a cow’s maximum willingness to pay, then that cow will not enroll. Farmer John wants to earn as much money as possible so he can pay his instructors well. Compute how much money he can earn and the tuition he should charge to achieve that.", "inputFormat": "The first line contains $N$.\n\nThe second line contains $N$ integers $c_1,c_2, \\cdots,c_N$, where $c_i$ is the maximum tuition cow $i$ is willing to pay.", "outputFormat": "Output the maximum amount Farmer John can earn and the tuition he should charge in the optimal case. If there are multiple answers, output the one with the smallest tuition.\n \nNote that the integers involved may require 64-bit integer types (e.g., long in Java, long long in C/C++).", "hint": "### Sample 1 Explanation\n\nIf Farmer John charges $4$, then $3$ cows will enroll, earning him $3 \\times 4=12$.\n\n### Testpoint Properties\n\n- Testpoints $2-4$ satisfy $c_i \\le 1000$.\n- Testpoints $5-8$ satisfy $N \\le 5000$.\n- Testpoints $9-12$ have no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Cow College B", "background": "", "description": "Farmer John 计划为奶牛们新开办一所大学！ \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wiy5l6d6.png)\n\n有 $N(1 \\le N \\le 10^5)$ 头奶牛可能会入学。每头奶牛最多愿意支付 $c_i$ 的学费 $(1 \\le c_i \\le 10^6)$。 Farmer John 可以设定所有奶牛入学需要支付的学费。如果这笔学费大于一头奶牛愿意支付的最高金额，那么这头奶牛就不会入学。Farmer John 想赚尽可能多的钱，从而可以给他的讲师提供一笔可观的工资。请求出他能赚到的钱的数量，以及此时应当收取多少学费。 ", "inputFormat": "输入的第一行包含 $N$。\n\n第二行包含 $N$ 个整数 $c_1,c_2, \\cdots,c_N$，其中 $c_i$ 是奶牛 $i$ 愿意支付的最高学费金额。 ", "outputFormat": "输出 Farmer John 可以赚到的最大金额以及最优情况下他应该收取的学费。如果有多个解，输出收取学费最小的解。 \n \n**注意这个问题涉及到的整数可能需要使用 64 位整数型（例如，Java 中的 \"long\"，C/C++ 中的 \"long long\"）。**", "hint": "### 样例 1 解释\n\n如果 Farmer John 收费 $4$，那么 $3$ 头奶牛将会入学，从而使他赚取 $3 \\times 4=12$ 的金额。\n\n### 测试点性质\n\n- 测试点 $2-4$ 满足 $c_i \\le 1000$。\n- 测试点 $5-8$ 满足 $N \\le 5000$。\n- 测试点 $9-12$ 没有额外限制。 ", "locale": "zh-CN"}}}
{"pid": "P8898", "type": "P", "difficulty": 3, "samples": [["6\n5 0\nGHHGG\n5 1\nGHHGG\n5 2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH", "5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "USACO", "2022", "Special Judge"], "title": "[USACO22DEC] Feeding the Cows B", "background": "", "description": "Farmer John 有 $N(1 \\le N \\le 10^5)$ 头奶牛，每头奶牛的品种是更赛牛（Guernsey）或荷斯坦牛（Holstein）之一。她们沿水平方向排成一行，奶牛们占据的位置编号为 $1 \\cdots N$。\n\n由于奶牛们都饿了，FJ 决定在 $1 \\cdots N$ 中的某些位置上种植草地。更赛牛和荷斯坦牛喜欢不同类型的草，所以如果 Farmer John 决定在某个位置种草，他必须选择种植更赛牛喜欢的草或荷斯坦牛喜欢的草——他不能在同一个位置同时种两种草。种植的每一片草地都可以喂饱数量不限的相应品种的奶牛。 \n\n每头奶牛愿意移动至多 $K(0 \\le K \\le N-1)$ 个位置以前往一个草地。求出喂饱所有奶牛所需种植的最小草地数量。此外，输出一种使用最小草地数量喂饱所有奶牛的种植方案。任何满足上述条件的方案均视为正确。 ", "inputFormat": "每个测试用例包含 $T$ 个子测试用例，为一种奶牛的排列。输入的第一行包含 $T(1 \\le T \\le 10)$。以下是 $T$ 个子测试用例。\n\n每个子测试用例的第一行包含 $N$ 和 $K$。第二行包含一个长度为 $N$ 的字符串，其中第 $i$ 个字符表示第 $i$ 头奶牛的品种（G 表示更赛牛，H 表示荷斯坦牛）。", "outputFormat": "对于 $T$ 个子测试用例中的每一个，输出两行。第一行输出喂饱所有奶牛所需的最小草地数量。第二行输出一个长度为 $N$ 的字符串，表示一种使用最小草地数量喂饱所有奶牛的种植方案。第 $i$ 个字符表示第 $i$ 个位置，若不种草则为 $\\texttt{.}$，若种植喂饱更赛牛的草则为 $\\texttt{G}$，若种植喂饱荷斯坦牛的草则为 $\\texttt{H}$。任何合法的方案均可通过。 ", "hint": "### 样例 1 解释\n\n注意对于某些子测试用例，存在多种可通过的方案使用最小数量的草地。例如，在第四个子测试用例中，以下是另一个可以通过的答案：\n\n$$\\texttt{.GH..}$$\n\n这个方案在第二个位置种植一块喂饱更赛牛的草地以及在第三个位置种植一块喂饱荷斯坦牛的草地。这使用了最小数量的草地并确保了所有奶牛都在她们喜欢的草地的 $3$ 个位置以内。\n\n### 测试点性质\n\n- 测试点 $2-4$ 满足 $N \\le 10$。\n- 测试点 $5-8$ 满足 $N \\le 40$。\n- 测试点 $9-12$ 满足 $N \\le 10^5$。 ", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Feeding the Cows B", "background": "", "description": "Farmer John has $N (1 \\le N \\le 10^5)$ cows, each of which is either Guernsey or Holstein. They stand in a row along a horizontal line, occupying positions $1 \\cdots N$.\n\nSince the cows are hungry, FJ decides to plant grass patches at some positions among $1 \\cdots N$. Guernseys and Holsteins prefer different types of grass, so if Farmer John decides to plant grass at a position, he must choose either the type preferred by Guernseys or the type preferred by Holsteins—he cannot plant both types at the same position. Each planted grass patch can feed an unlimited number of cows of the corresponding breed.\n\nEach cow is willing to move at most $K (0 \\le K \\le N - 1)$ positions to reach a grass patch. Determine the minimum number of grass patches needed to feed all cows. In addition, output one planting plan that feeds all cows using the minimum number of patches. Any plan that satisfies the conditions is considered correct.", "inputFormat": "Each input contains $T$ test cases, each describing an arrangement of cows. The first line contains $T (1 \\le T \\le 10)$. Then $T$ test cases follow.\n\nFor each test case, the first line contains $N$ and $K$. The second line contains a string of length $N$, where the $i$-th character indicates the breed of the $i$-th cow ($\\texttt{G}$ for Guernsey, $\\texttt{H}$ for Holstein).", "outputFormat": "For each of the $T$ test cases, output two lines. The first line should contain the minimum number of grass patches needed to feed all cows. The second line should contain a string of length $N$ representing one optimal planting plan. The $i$-th character corresponds to position $i$: output $\\texttt{.}$ if no grass is planted, $\\texttt{G}$ if grass for Guernseys is planted, and $\\texttt{H}$ if grass for Holsteins is planted. Any valid plan will be accepted.", "hint": "### Explanation for Sample 1\n\nNote that for some test cases, there are multiple optimal planting plans using the minimum number of patches. For example, in the fourth test case, the following is another acceptable answer:\n\n$$\\texttt{.GH..}$$\n\nThis plan plants a Guernsey-feeding patch at position $2$ and a Holstein-feeding patch at position $3$. This uses the minimum number of patches and ensures that all cows are within $3$ positions of their preferred grass.\n\n### Testdata Properties\n\n- Testdata $2$–$4$ satisfies $N \\le 10$.\n- Testdata $5$–$8$ satisfies $N \\le 40$.\n- Testdata $9$–$12$ satisfies $N \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Feeding the Cows B", "background": "", "description": "Farmer John 有 $N(1 \\le N \\le 10^5)$ 头奶牛，每头奶牛的品种是更赛牛（Guernsey）或荷斯坦牛（Holstein）之一。她们沿水平方向排成一行，奶牛们占据的位置编号为 $1 \\cdots N$。\n\n由于奶牛们都饿了，FJ 决定在 $1 \\cdots N$ 中的某些位置上种植草地。更赛牛和荷斯坦牛喜欢不同类型的草，所以如果 Farmer John 决定在某个位置种草，他必须选择种植更赛牛喜欢的草或荷斯坦牛喜欢的草——他不能在同一个位置同时种两种草。种植的每一片草地都可以喂饱数量不限的相应品种的奶牛。 \n\n每头奶牛愿意移动至多 $K(0 \\le K \\le N-1)$ 个位置以前往一个草地。求出喂饱所有奶牛所需种植的最小草地数量。此外，输出一种使用最小草地数量喂饱所有奶牛的种植方案。任何满足上述条件的方案均视为正确。 ", "inputFormat": "每个测试用例包含 $T$ 个子测试用例，为一种奶牛的排列。输入的第一行包含 $T(1 \\le T \\le 10)$。以下是 $T$ 个子测试用例。\n\n每个子测试用例的第一行包含 $N$ 和 $K$。第二行包含一个长度为 $N$ 的字符串，其中第 $i$ 个字符表示第 $i$ 头奶牛的品种（G 表示更赛牛，H 表示荷斯坦牛）。", "outputFormat": "对于 $T$ 个子测试用例中的每一个，输出两行。第一行输出喂饱所有奶牛所需的最小草地数量。第二行输出一个长度为 $N$ 的字符串，表示一种使用最小草地数量喂饱所有奶牛的种植方案。第 $i$ 个字符表示第 $i$ 个位置，若不种草则为 $\\texttt{.}$，若种植喂饱更赛牛的草则为 $\\texttt{G}$，若种植喂饱荷斯坦牛的草则为 $\\texttt{H}$。任何合法的方案均可通过。 ", "hint": "### 样例 1 解释\n\n注意对于某些子测试用例，存在多种可通过的方案使用最小数量的草地。例如，在第四个子测试用例中，以下是另一个可以通过的答案：\n\n$$\\texttt{.GH..}$$\n\n这个方案在第二个位置种植一块喂饱更赛牛的草地以及在第三个位置种植一块喂饱荷斯坦牛的草地。这使用了最小数量的草地并确保了所有奶牛都在她们喜欢的草地的 $3$ 个位置以内。\n\n### 测试点性质\n\n- 测试点 $2-4$ 满足 $N \\le 10$。\n- 测试点 $5-8$ 满足 $N \\le 40$。\n- 测试点 $9-12$ 满足 $N \\le 10^5$。 ", "locale": "zh-CN"}}}
{"pid": "P8899", "type": "P", "difficulty": 3, "samples": [["4\n\n1 3\n0 0\n0 0\n1 1\n\n2 4\n00 0\n01 1\n10 1\n11 1\n\n1 2\n0 1\n0 0\n\n2 4\n00 0\n01 1\n10 1\n11 0", "OK\nOK\nLIE\nLIE"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "贪心", "USACO", "2022"], "title": "[USACO22DEC] Reverse Engineering B", "background": "", "description": "Elsie 有一个程序，接受一个 $N(1 \\le N \\le 100)$ 个变量的数组 $b[0], \\cdots ,b[N−1]$ 作为输入，其中每个变量等于 $0$ 或 $1$，并且返回对输入数组应用一系列 `if / else if / else` 语句的结果。每个语句检查至多一个输入变量的值，并返回 $0$ 或 $1$。这类程序的一个例子是：\n\n```cpp\nif (b[1] == 1) return 1;\nelse if (b[0] == 0) return 0;\nelse return 1;\n```\n\n例如，如果上方程序的输入是 \"10\"（即 $b[0]=1$ 及 $b[1]=0$），那么输出应当为 $1$。 \n\nElsie 告诉了 Bessie 对于 $M(1 \\le M \\le 100)$ 个不同输入的正确输出。Bessie 现在正试图对 Elsie 的程序进行逆向工程。不幸的是，Elsie 可能说了谎；可能不存在上述形式的程序行为与 Elsie 所说的均一致。 \n\n对于 $T(1 \\le T \\le 10)$ 个子测试用例中的每一个，判断 Elsie 是否一定在说谎。", "inputFormat": "输入的第一行包含 $T$，为子测试用例的数量。\n\n每一个子测试用例的第一行包含两个整数 $N$ 和 $M$，以下 $M$ 行，每行包含一个由 $N$ 个 $0$ 或 $1$ 组成的字符串，表示一个输入（即 $b[0] \\cdots b[N−1]$ 的值），以及另一个字符（$0$ 或 $1$）表示输出。相邻的子测试用例之间用空行分隔。 ", "outputFormat": "对于每一个子测试用例，输出一行，包含 $\\texttt{OK}$ 或 $\\texttt{LIE}$，分别表示 Elsie 可能没有说谎或是一定在说谎。 ", "hint": "### 样例 1 解释\n\n以下是第一个子测试用例的一个合法的程序：\n\n```cpp\nif (b[0] == 0) return 0;\nelse return 1;\n```\n\n以下是第一个子测试用例的另一个合法的程序：\n\n```cpp\nif (b[0] == 1) return 1;\nelse return 0;\n```\n\n以下是第二个子测试用例的一个合法的程序：\n\n```cpp\nif (b[1] == 1) return 1;\nelse if (b[0] == 0) return 0;\nelse return 1;\n```\n\n显然，对于第三个子测试用例不存在对应的合法的程序，因为 Elsie 的程序一定始终对相同的输入产生相同的输出。\n\n可以证明对于最后一个子测试用例不存在对应的合法的程序。 \n\n### 测试点性质\n\n- 测试点 $2-3$ 满足 $N=2$。\n- 测试点 $4-5$ 满足 $M=2$。\n- 测试点 $6-12$ 没有额外限制。 ", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Reverse Engineering B", "background": "", "description": "Elsie has a program that takes as input an array of $N$ variables ($1 \\le N \\le 100$), $b[0], \\cdots, b[N-1]$, where each variable equals $0$ or $1$, and returns the result of applying a sequence of `if / else if / else` statements to the input. Each branch checks at most one input variable and returns $0$ or $1$. An example of such a program is:\n\n```cpp\nif (b[1] == 1) return 1;\nelse if (b[0] == 0) return 0;\nelse return 1;\n```\n\nFor example, if the input to the program above is \"10\" (i.e., $b[0] = 1$ and $b[1] = 0$), then the output should be $1$.\n\nElsie told Bessie the correct outputs for $M$ different inputs ($1 \\le M \\le 100$). Bessie is now trying to reverse engineer Elsie’s program. Unfortunately, Elsie may have lied; there might be no program of the above form whose behavior matches everything Elsie said.\n\nFor each of $T$ test cases ($1 \\le T \\le 10$), determine whether Elsie is certainly lying.", "inputFormat": "The first line contains $T$, the number of test cases.\n\nFor each test case, the first line contains two integers $N$ and $M$. Each of the following $M$ lines contains a string of $N$ characters, each $0$ or $1$, representing an input (the values of $b[0] \\cdots b[N-1]$), followed by another character ($0$ or $1$) representing the output. Consecutive test cases are separated by a blank line.", "outputFormat": "For each test case, output a single line containing $\\texttt{OK}$ or $\\texttt{LIE}$, indicating respectively that Elsie might not be lying or is certainly lying.", "hint": "### Explanation for Sample 1\n\nHere is one valid program for the first test case:\n\n```cpp\nif (b[0] == 0) return 0;\nelse return 1;\n```\n\nHere is another valid program for the first test case:\n\n```cpp\nif (b[0] == 1) return 1;\nelse return 0;\n```\n\nHere is one valid program for the second test case:\n\n```cpp\nif (b[1] == 1) return 1;\nelse if (b[0] == 0) return 0;\nelse return 1;\n```\n\nClearly, no valid program exists for the third test case, since Elsie’s program must always produce the same output for the same input.\n\nIt can be proven that no valid program exists for the last test case.\n\n### Properties of test points\n\n- Test points $2$–$3$ satisfy $N = 2$.\n- Test points $4$–$5$ satisfy $M = 2$.\n- Test points $6$–$12$ have no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Reverse Engineering B", "background": "", "description": "Elsie 有一个程序，接受一个 $N(1 \\le N \\le 100)$ 个变量的数组 $b[0], \\cdots ,b[N−1]$ 作为输入，其中每个变量等于 $0$ 或 $1$，并且返回对输入数组应用一系列 `if / else if / else` 语句的结果。每个语句检查至多一个输入变量的值，并返回 $0$ 或 $1$。这类程序的一个例子是：\n\n```cpp\nif (b[1] == 1) return 1;\nelse if (b[0] == 0) return 0;\nelse return 1;\n```\n\n例如，如果上方程序的输入是 \"10\"（即 $b[0]=1$ 及 $b[1]=0$），那么输出应当为 $1$。 \n\nElsie 告诉了 Bessie 对于 $M(1 \\le M \\le 100)$ 个不同输入的正确输出。Bessie 现在正试图对 Elsie 的程序进行逆向工程。不幸的是，Elsie 可能说了谎；可能不存在上述形式的程序行为与 Elsie 所说的均一致。 \n\n对于 $T(1 \\le T \\le 10)$ 个子测试用例中的每一个，判断 Elsie 是否一定在说谎。", "inputFormat": "输入的第一行包含 $T$，为子测试用例的数量。\n\n每一个子测试用例的第一行包含两个整数 $N$ 和 $M$，以下 $M$ 行，每行包含一个由 $N$ 个 $0$ 或 $1$ 组成的字符串，表示一个输入（即 $b[0] \\cdots b[N−1]$ 的值），以及另一个字符（$0$ 或 $1$）表示输出。相邻的子测试用例之间用空行分隔。 ", "outputFormat": "对于每一个子测试用例，输出一行，包含 $\\texttt{OK}$ 或 $\\texttt{LIE}$，分别表示 Elsie 可能没有说谎或是一定在说谎。 ", "hint": "### 样例 1 解释\n\n以下是第一个子测试用例的一个合法的程序：\n\n```cpp\nif (b[0] == 0) return 0;\nelse return 1;\n```\n\n以下是第一个子测试用例的另一个合法的程序：\n\n```cpp\nif (b[0] == 1) return 1;\nelse return 0;\n```\n\n以下是第二个子测试用例的一个合法的程序：\n\n```cpp\nif (b[1] == 1) return 1;\nelse if (b[0] == 0) return 0;\nelse return 1;\n```\n\n显然，对于第三个子测试用例不存在对应的合法的程序，因为 Elsie 的程序一定始终对相同的输入产生相同的输出。\n\n可以证明对于最后一个子测试用例不存在对应的合法的程序。 \n\n### 测试点性质\n\n- 测试点 $2-3$ 满足 $N=2$。\n- 测试点 $4-5$ 满足 $M=2$。\n- 测试点 $6-12$ 没有额外限制。 ", "locale": "zh-CN"}}}
{"pid": "P8900", "type": "P", "difficulty": 4, "samples": [["4\n2 1 4 5\n1 2\n2 3\n2 4", "3\n3 2 1\n4 2 2\n2 1 1"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "USACO", "2022", "Special Judge", "构造"], "title": "[USACO22DEC] Barn Tree S", "background": "", "description": "Farmer John 的农场有 $N$ 个牛棚 $(2 \\le N \\le 2 \\times 10^5)$，编号为 $1 \\cdots N$。有 $N−1$ 条道路，每条道路连接两个牛棚，并且从任一牛棚均可通过一些道路到达任一其他牛棚。目前，第 $j$ 个牛棚中有 $h_j$ 个干草捆 $(1 \\le h_j \\le 10^9)$。 \n\n为使他的奶牛们满意，Farmer John 想移动这些干草，使得每个牛棚都有相同数量的干草捆。他可以选择任何一对由一条道路连接的牛棚，并命令他的农场工人将不超过第一个牛棚中干草捆数量的任意正整数个干草捆从第一个牛棚移动到第二个牛棚。 \n\n请求出一个 Farmer John 可以发出的命令序列，以尽可能少的命令数完成这一任务。输入保证存在符合要求的命令序列。 ", "inputFormat": "输入的第一行包含整数 $N$。\n\n第二行包含空格分隔的整数 $h_j$，其中 $j=1\\cdots N$。\n\n最后 $N−1$ 行每行包含两个空格分隔的牛棚编号 $u_i,v_i$，表示有一条双向道路连接 $u_i$ 和 $v_i$。", "outputFormat": "输出命令的最小数量，然后输出该数量的命令序列，每行输出一条命令。\n\n每条命令的格式应为三个空格分隔的正整数：出发牛棚，目标牛棚，以及从出发牛棚移动到目标牛棚的干草捆数量。\n\n如果有多组解，输出任意一组。 ", "hint": "### 样例 1 解释\n\n在这个例子中，共有十二个干草捆和四个牛棚，这意味着每个牛棚最后必须有三个干草捆。输出样例中的命令顺序可以用以下的自然语言表述： \n\n1. 从牛棚 $3$ 到牛棚 $2$，移动 $1$ 个干草捆。\n2. 从牛棚 $4$ 到牛棚 $2$，移动 $2$ 个干草捆。\n3. 从牛棚 $2$ 到牛棚 $1$，移动 $1$ 个干草捆。\n\n### 测试点性质\n\n- 测试点 $2-8$ 满足 $N \\le 5000$。\n- 测试点 $7-10$ 满足 $v_i=u_i+1$。\n- 测试点 $11-16$ 没有额外限制。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Barn Tree S", "background": "", "description": "Farmer John’s farm has $N$ barns $(2 \\le N \\le 2 \\times 10^5)$, labeled $1 \\cdots N$. There are $N−1$ roads, each connecting two barns, and from any barn it is possible to reach any other barn via some roads. Currently, barn $j$ contains $h_j$ haybales $(1 \\le h_j \\le 10^9)$.\n\nTo keep his cows happy, Farmer John wants to move the hay so that every barn has the same number of haybales. He may choose any pair of barns connected by a single road and instruct his farmhands to move any positive integer number of haybales, up to the amount in the first barn, from the first barn to the second barn.\n\nFind a sequence of commands that Farmer John can issue to complete this task using as few commands as possible. The input guarantees that such a sequence exists.", "inputFormat": "The first line contains the integer $N$.\n\nThe second line contains space-separated integers $h_j$ for $j=1 \\cdots N$.\n\nEach of the last $N−1$ lines contains two space-separated barn indices $u_i, v_i$, indicating there is a bidirectional road between $u_i$ and $v_i$.", "outputFormat": "Output the minimum number of commands, then output a sequence of that many commands, one per line.\n\nEach command should be three space-separated positive integers: the source barn, the destination barn, and the number of haybales moved from the source to the destination.\n\nIf there are multiple solutions, output any of them.", "hint": "### Sample 1 Explanation\n\nIn this example, there are twelve haybales and four barns, which means each barn must end up with three haybales. The sequence in the sample output can be described in natural language as follows:\n\n1. From barn $3$ to barn $2$, move $1$ haybale.\n2. From barn $4$ to barn $2$, move $2$ haybales.\n3. From barn $2$ to barn $1$, move $1$ haybale.\n\n### Testpoint Properties\n\n- Testpoints $2-8$ satisfy $N \\le 5000$.\n- Testpoints $7-10$ satisfy $v_i=u_i+1$.\n- Testpoints $11-16$ have no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Barn Tree S", "background": "", "description": "Farmer John 的农场有 $N$ 个牛棚 $(2 \\le N \\le 2 \\times 10^5)$，编号为 $1 \\cdots N$。有 $N−1$ 条道路，每条道路连接两个牛棚，并且从任一牛棚均可通过一些道路到达任一其他牛棚。目前，第 $j$ 个牛棚中有 $h_j$ 个干草捆 $(1 \\le h_j \\le 10^9)$。 \n\n为使他的奶牛们满意，Farmer John 想移动这些干草，使得每个牛棚都有相同数量的干草捆。他可以选择任何一对由一条道路连接的牛棚，并命令他的农场工人将不超过第一个牛棚中干草捆数量的任意正整数个干草捆从第一个牛棚移动到第二个牛棚。 \n\n请求出一个 Farmer John 可以发出的命令序列，以尽可能少的命令数完成这一任务。输入保证存在符合要求的命令序列。 ", "inputFormat": "输入的第一行包含整数 $N$。\n\n第二行包含空格分隔的整数 $h_j$，其中 $j=1\\cdots N$。\n\n最后 $N−1$ 行每行包含两个空格分隔的牛棚编号 $u_i,v_i$，表示有一条双向道路连接 $u_i$ 和 $v_i$。", "outputFormat": "输出命令的最小数量，然后输出该数量的命令序列，每行输出一条命令。\n\n每条命令的格式应为三个空格分隔的正整数：出发牛棚，目标牛棚，以及从出发牛棚移动到目标牛棚的干草捆数量。\n\n如果有多组解，输出任意一组。 ", "hint": "### 样例 1 解释\n\n在这个例子中，共有十二个干草捆和四个牛棚，这意味着每个牛棚最后必须有三个干草捆。输出样例中的命令顺序可以用以下的自然语言表述： \n\n1. 从牛棚 $3$ 到牛棚 $2$，移动 $1$ 个干草捆。\n2. 从牛棚 $4$ 到牛棚 $2$，移动 $2$ 个干草捆。\n3. 从牛棚 $2$ 到牛棚 $1$，移动 $1$ 个干草捆。\n\n### 测试点性质\n\n- 测试点 $2-8$ 满足 $N \\le 5000$。\n- 测试点 $7-10$ 满足 $v_i=u_i+1$。\n- 测试点 $11-16$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P8901", "type": "P", "difficulty": 4, "samples": [["5\n1\n4\n1\n9\n2\n2 3\n2\n7 10\n3\n4 9 4", "Farmer Nhoj\nFarmer John\nFarmer John\nFarmer John\nFarmer Nhoj"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["博弈论", "USACO", "2022", "素数判断,质数,筛法"], "title": "[USACO22DEC] Circular Barn S", "background": "", "description": "Farmer John 和他的死对头 Farmer Nhoj 在一个环形牛棚内玩游戏。牛棚内有 $N(1 \\le N \\le 10^5)$ 个房间，第 $i$ 个房间初始时内有 $a_i$ 头奶牛 $(1 \\le a_i \\le 5 \\times 10^6)$。游戏玩法如下：\n\n- 两位农夫将总是在同一个房间里。进入一个房间后，每位农夫各执行一次行动，Farmer John 在先。两位农夫在游戏开始时进入房间 $1$。\n- 如果当前房间中的奶牛数量为零，则此时执行行动的农夫即失败。否则，执行行动的农夫选择一个整数 $P$，其中 $P$ 为 $1$ 或一个不超过当前房间中奶牛的数量的质数，并从当前房间中移除 $P$ 头奶牛。\n- 两位农夫均完成行动之后，两位农夫移动到环形牛棚的下一间房间。也就是说，如果农夫们在房间 $i$，那么他们会移动到房间 $i+1$，除非他们在房间 $N$，在这种情况下他们会移动到房间 $1$。\n\n当两位农夫均采用最优策略时，求获胜的农夫。 ", "inputFormat": "输入包含 $T$ 个子测试用例。输入的第一行包含 $T(1 \\le T \\le 1000)$。下面是 $T$ 个子测试用例。\n\n每个子测试用例的第一行包含 $N$，第二行包含 $a_1, \\cdots ,a_N$。\n\n输入保证所有 $N$ 之和不超过 $2 \\times 10^5$。 ", "outputFormat": " 对于每一个子测试用例，输出获胜的农夫，为 `Farmer John` 或 `Farmer Nhoj` 之一。", "hint": "### 样例 1 解释\n\n对于第一个子测试用例，Farmer John 可以从第一个房间中移除 $1$、$2$ 或 $3$ 头奶牛。无论他移除多少头奶牛，Nhoj 都可以移除剩余的奶牛，迫使 FJ 在他们绕回第一个房间时失败。\n\n对于第二个子测试用例，FJ 可以移除 $5$ 头奶牛，迫使 Nhoj 面对剩下的 $4$ 头奶牛。现在，Nhoj 可以移除 $1$、$2$ 或 $3$ 奶牛。现在的情况类似于第一个子测试用例。\n\n对于第三个和第四个子测试用例，FJ 可以立即移除第一个房间的所有奶牛，使 Nhoj 失败。\n\n对于第五个子测试用例，FJ 可以从第一个房间中移除 $1$\n、$2$ 或 $3$ 奶牛，然后 Nhoj 可以随后移除余下的奶牛。当他们绕回第一个房间时，FJ 将会失败。 \n\n### 测试点性质\n\n- 测试点 $2-4$ 满足 $N=1$。\n- 测试点 $1,2,5-7$ 满足 $a_i \\le 1000$。\n- 测试点 $8-20$ 没有额外限制。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Circular Barn S", "background": "", "description": "Farmer John and his archrival Farmer Nhoj play a game in a circular barn. The barn has $N$ rooms $(1 \\le N \\le 10^5)$, and the $i$-th room initially contains $a_i$ cows $(1 \\le a_i \\le 5 \\times 10^6)$. The game proceeds as follows:\n\n- The two farmers are always in the same room. Upon entering a room, each farmer takes one move, with Farmer John moving first. At the start of the game, they enter room $1$.\n- If the current room has zero cows, then the farmer whose turn it is loses. Otherwise, the farmer whose turn it is chooses an integer $P$, where $P$ is $1$ or a prime number not exceeding the number of cows in the current room, and removes $P$ cows from the current room.\n- After both farmers have completed their moves, they move to the next room in the circular barn. That is, if they are in room $i$, they move to room $i+1$, unless they are in room $N$, in which case they move to room $1$.\n\nDetermine the winner when both farmers play optimally.", "inputFormat": "The input contains $T$ subtest cases. The first line contains $T$ $(1 \\le T \\le 1000)$. Then follow $T$ subtest cases.\n\nFor each subtest case, the first line contains $N$, and the second line contains $a_1, \\cdots, a_N$.\n\nIt is guaranteed that the sum of all $N$ does not exceed $2 \\times 10^5$.", "outputFormat": "For each subtest case, output the winner, either `Farmer John` or `Farmer Nhoj`.", "hint": "### Sample 1 Explanation\n\nFor the first subtest case, Farmer John can remove $1$, $2$, or $3$ cows from the first room. No matter how many he removes, Nhoj can remove the remaining cows, forcing FJ to lose when they loop back to the first room.\n\nFor the second subtest case, FJ can remove $5$ cows, forcing Nhoj to face the remaining $4$ cows. Now Nhoj can remove $1$, $2$, or $3$ cows. The situation is now similar to the first subtest case.\n\nFor the third and fourth subtest cases, FJ can immediately remove all cows from the first room, causing Nhoj to lose.\n\nFor the fifth subtest case, FJ can remove $1$, $2$, or $3$ cows from the first room, and then Nhoj can remove the remaining cows afterward. When they loop back to the first room, FJ will lose.\n\n### Test Point Properties\n\n- Test points $2$–$4$ satisfy $N=1$.\n- Test points $1,2,5$–$7$ satisfy $a_i \\le 1000$.\n- Test points $8$–$20$ have no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Circular Barn S", "background": "", "description": "Farmer John 和他的死对头 Farmer Nhoj 在一个环形牛棚内玩游戏。牛棚内有 $N(1 \\le N \\le 10^5)$ 个房间，第 $i$ 个房间初始时内有 $a_i$ 头奶牛 $(1 \\le a_i \\le 5 \\times 10^6)$。游戏玩法如下：\n\n- 两位农夫将总是在同一个房间里。进入一个房间后，每位农夫各执行一次行动，Farmer John 在先。两位农夫在游戏开始时进入房间 $1$。\n- 如果当前房间中的奶牛数量为零，则此时执行行动的农夫即失败。否则，执行行动的农夫选择一个整数 $P$，其中 $P$ 为 $1$ 或一个不超过当前房间中奶牛的数量的质数，并从当前房间中移除 $P$ 头奶牛。\n- 两位农夫均完成行动之后，两位农夫移动到环形牛棚的下一间房间。也就是说，如果农夫们在房间 $i$，那么他们会移动到房间 $i+1$，除非他们在房间 $N$，在这种情况下他们会移动到房间 $1$。\n\n当两位农夫均采用最优策略时，求获胜的农夫。 ", "inputFormat": "输入包含 $T$ 个子测试用例。输入的第一行包含 $T(1 \\le T \\le 1000)$。下面是 $T$ 个子测试用例。\n\n每个子测试用例的第一行包含 $N$，第二行包含 $a_1, \\cdots ,a_N$。\n\n输入保证所有 $N$ 之和不超过 $2 \\times 10^5$。 ", "outputFormat": " 对于每一个子测试用例，输出获胜的农夫，为 `Farmer John` 或 `Farmer Nhoj` 之一。", "hint": "### 样例 1 解释\n\n对于第一个子测试用例，Farmer John 可以从第一个房间中移除 $1$、$2$ 或 $3$ 头奶牛。无论他移除多少头奶牛，Nhoj 都可以移除剩余的奶牛，迫使 FJ 在他们绕回第一个房间时失败。\n\n对于第二个子测试用例，FJ 可以移除 $5$ 头奶牛，迫使 Nhoj 面对剩下的 $4$ 头奶牛。现在，Nhoj 可以移除 $1$、$2$ 或 $3$ 奶牛。现在的情况类似于第一个子测试用例。\n\n对于第三个和第四个子测试用例，FJ 可以立即移除第一个房间的所有奶牛，使 Nhoj 失败。\n\n对于第五个子测试用例，FJ 可以从第一个房间中移除 $1$\n、$2$ 或 $3$ 奶牛，然后 Nhoj 可以随后移除余下的奶牛。当他们绕回第一个房间时，FJ 将会失败。 \n\n### 测试点性质\n\n- 测试点 $2-4$ 满足 $N=1$。\n- 测试点 $1,2,5-7$ 满足 $a_i \\le 1000$。\n- 测试点 $8-20$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P8902", "type": "P", "difficulty": 4, "samples": [["3\n0 2 2\n0 1\n0", "1 3 2"], ["3\n0 1 1\n0 0\n0", "0 1 1"], ["4\n0 1 2 2\n0 1 1\n0 1\n0", "1 2 3 2"], ["4\n0 1 1 2\n0 0 2\n0 2\n0", "1 2 2 0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["USACO", "2022", "Special Judge", "构造"], "title": "[USACO22DEC] Range Reconstruction S", "background": "", "description": "Bessie 有一个数组 $a_1, \\cdots, a_N$，其中 $1 \\le N \\le 300$ 并对于所有 $i$ 有 $0 \\le a_i \\le 10^9$。她不会告诉你数组 $a$ 本身，但她会告诉你 $a$ 的每个子数组的全距。也就是说，对于每对索引 $i \\le j$，Bessie 告诉你 $r_{i,j}= \\max a[i \\cdots j]− \\min a[i \\cdots j]$。给定这些 $r$ 的值，构造一个可以作为 Bessie 的原始数组的数组。你的数组中的数值应在 $[−10^9,10^9]$ 范围内。 ", "inputFormat": "输入的第一行包含 $N$。\n\n以下 $N$ 行，第 $i$ 行包含整数 $r_{i,i},r_{i,i+1}, \\cdots ,r_{i,N}$。\n\n输入保证存在某个数组 $a$，其中的数值在 $[0,10^9]$ 范围内，满足对于所有的 $i \\le j$，有 $r_{i,j}= \\max a[i \\cdots j]−\\min a[i\\cdots j]$。 ", "outputFormat": "输出一行，包含 $N$ 个整数 $b_1,b_2, \\cdots ,b_N$，在 $[−10^9,10^9]$ 范围内，表示你的数组。这些数需要满足对于所有的 $i \\le j$ 有 $r_{i,j}= \\max a[i \\cdots j]−\\min a[i\\cdots j]$。 ", "hint": "### 样例 1 解释\n\n例如，$r_{1,3}=\\max a[1 \\cdots 3]−\\min a[1\\cdots 3]=3−1=2$。\n\n### 样例 2 解释\n\n这个样例满足子任务 $1$ 的限制。\n\n### 样例 3 解释\n\n这个样例满足子任务 2 的限制。 \n\n### 测试点性质\n\n- 测试点 $5$ 满足 $r_{1,N} \\le 1$。\n- 测试点 $6-8$ 满足对于所有 $1 \\le i<N$ 均有 $r_{i,i+1}=1$。\n- 测试点 $9-14$ 没有额外限制。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Range Reconstruction S", "background": "", "description": "Bessie has an array $a_1, \\cdots, a_N$, where $1 \\le N \\le 300$ and for all $i$ we have $0 \\le a_i \\le 10^9$. She will not tell you the array $a$ itself, but she will tell you the range of every subarray of $a$. That is, for every pair of indices $i \\le j$, Bessie tells you $r_{i,j}= \\max a[i \\cdots j]− \\min a[i \\cdots j]$. Given these $r$ values, construct an array that could be Bessie's original array. The values in your array must be in the range $[−10^9,10^9]$.", "inputFormat": "The first line contains $N$.\n\nThe next $N$ lines: line $i$ contains the integers $r_{i,i},r_{i,i+1}, \\cdots ,r_{i,N}$.\n\nIt is guaranteed that there exists some array $a$, with values in the range $[0,10^9]$, such that for all $i \\le j$, $r_{i,j}= \\max a[i \\cdots j]−\\min a[i\\cdots j]$.", "outputFormat": "Output one line containing $N$ integers $b_1,b_2, \\cdots ,b_N$ in the range $[−10^9,10^9]$, representing your array. These numbers must satisfy that for all $i \\le j$, $r_{i,j}= \\max a[i \\cdots j]−\\min a[i\\cdots j]$.", "hint": "Sample 1 Explanation\n\nFor example, $r_{1,3}=\\max a[1 \\cdots 3]−\\min a[1\\cdots 3]=3−1=2$.\n\nSample 2 Explanation\n\nThis sample satisfies the constraints of subtask 1.\n\nSample 3 Explanation\n\nThis sample satisfies the constraints of subtask 2.\n\nProperties of test points\n\n- Test point $5$ satisfies $r_{1,N} \\le 1$.\n- Test points $6-8$ satisfy that for all $1 \\le i<N$ we have $r_{i,i+1}=1$.\n- Test points $9-14$ have no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Range Reconstruction S", "background": "", "description": "Bessie 有一个数组 $a_1, \\cdots, a_N$，其中 $1 \\le N \\le 300$ 并对于所有 $i$ 有 $0 \\le a_i \\le 10^9$。她不会告诉你数组 $a$ 本身，但她会告诉你 $a$ 的每个子数组的全距。也就是说，对于每对索引 $i \\le j$，Bessie 告诉你 $r_{i,j}= \\max a[i \\cdots j]− \\min a[i \\cdots j]$。给定这些 $r$ 的值，构造一个可以作为 Bessie 的原始数组的数组。你的数组中的数值应在 $[−10^9,10^9]$ 范围内。 ", "inputFormat": "输入的第一行包含 $N$。\n\n以下 $N$ 行，第 $i$ 行包含整数 $r_{i,i},r_{i,i+1}, \\cdots ,r_{i,N}$。\n\n输入保证存在某个数组 $a$，其中的数值在 $[0,10^9]$ 范围内，满足对于所有的 $i \\le j$，有 $r_{i,j}= \\max a[i \\cdots j]−\\min a[i\\cdots j]$。 ", "outputFormat": "输出一行，包含 $N$ 个整数 $b_1,b_2, \\cdots ,b_N$，在 $[−10^9,10^9]$ 范围内，表示你的数组。这些数需要满足对于所有的 $i \\le j$ 有 $r_{i,j}= \\max a[i \\cdots j]−\\min a[i\\cdots j]$。 ", "hint": "### 样例 1 解释\n\n例如，$r_{1,3}=\\max a[1 \\cdots 3]−\\min a[1\\cdots 3]=3−1=2$。\n\n### 样例 2 解释\n\n这个样例满足子任务 $1$ 的限制。\n\n### 样例 3 解释\n\n这个样例满足子任务 2 的限制。 \n\n### 测试点性质\n\n- 测试点 $5$ 满足 $r_{1,N} \\le 1$。\n- 测试点 $6-8$ 满足对于所有 $1 \\le i<N$ 均有 $r_{i,i+1}=1$。\n- 测试点 $9-14$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P8903", "type": "P", "difficulty": 5, "samples": [["3 10 8\n5 5 4\n6 7 3\n10 6 3", "15"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "USACO", "2022", "背包 DP"], "title": "[USACO22DEC] Bribing Friends G", "background": "", "description": "Bessie 想要观看纪录片：奶牛基因组学，但她不想一个人去。不幸的是，她的朋友们没有足够的热情和她一起去！于是，Bessie 需要贿赂她的朋友们陪她去电影院。她的贿赂武器库中有两种工具：**哞尼**和**冰激凌甜筒**。\n\nBessie 有 $N(1 \\le N \\le 2000)$ 个朋友。然而，并非所有的朋友都是生而平等的！朋友 $i$ 有受欢迎度 $P_i(1 \\le P_i \\le 2000)$，Bessie 想最大化陪她的朋友们的受欢迎度之和。朋友 $i$ 只有当 Bessie 给了她 $C_i(1 \\le C_i \\le 2000)$ 哞尼才愿意陪她。如果 Bessie 给她 $X_i(1 \\le X_i \\le 2000)$ 个冰激凌甜筒，她还可以给 Bessie $1$ 哞尼的折扣。Bessie 可以从朋友那里得到任意整数数量的折扣，只要这些折扣不会使得朋友倒给她哞尼。 \n\nBessie 有 $A$ 哞尼和 $B$ 个冰激凌甜筒可供使用（$0 \\le A,B \\le 2000$）。请帮助她求出如果她以最优方案花费她的哞尼和冰激凌甜筒，她可以达到的最大受欢迎度之和。 ", "inputFormat": "输入的第 1 行包含三个整数 $N$，$A$ 和 $B$，分别表示 Bessie 拥有的朋友的数量，哞尼的数量和冰激凌甜筒的数量。\n\n以下 $N$ 行每行包含三个整数 $P_i$，$C_i$ 和 $X_i$，表示受欢迎度（$P_i$），贿赂朋友 $i$ 陪 Bessie 所需要的哞尼（$C_i$），以及从朋友 $i$ 处获得 $1$ 哞尼的折扣所需要的冰激凌甜筒的数量（$X_i$）。", "outputFormat": "输出陪 Bessie 的朋友们的最大受欢迎度之和，假设她以最优方案花费她的哞尼和冰激凌甜筒。 ", "hint": "### 样例 1 解释\n\nBessie 可以将 $4$ 哞尼和 $4$ 个冰激凌甜筒给奶牛 $1$，将 $6$ 哞尼和 $3$ 个冰激凌甜筒给奶牛 $3$，这样奶牛 $1$ 和 $3$ 就可以陪她，得到 $5+10=15$ 的受欢迎度。\n\n### 测试点性质\n\n - 测试点 $2-4$ 满足 $N \\le 5$ 以及 $C_i=1$。\n - 测试点 $5-7$ 满足 $B=0$。\n - 测试点 $8-10$ 满足 $N,A,B,P_i,C_i,X_i \\le 50$。\n - 测试点 $11-15$ 满足 $N,A,B,P_i,C_i,X_i \\le 200$。\n - 测试点 $16-20$ 没有额外限制。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Bribing Friends G", "background": "", "description": "Bessie wants to watch the documentary: Cow Genomics, but she does not want to go alone. Unfortunately, her friends are not enthusiastic enough to go with her. So Bessie needs to bribe her friends to accompany her to the movie theater. She has two tools in her bribery arsenal: **Moonies** and **ice cream cones**.\n\nBessie has $N(1 \\le N \\le 2000)$ friends. However, not all friends are created equal. Friend $i$ has popularity $P_i(1 \\le P_i \\le 2000)$, and Bessie wants to maximize the sum of popularities of the friends who go with her. Friend $i$ will go with Bessie only if Bessie gives her $C_i(1 \\le C_i \\le 2000)$ Moonies. If Bessie gives her $X_i(1 \\le X_i \\le 2000)$ ice cream cones, then the friend can also give Bessie a discount of $1$ Moony. Bessie can obtain any integer number of discounts from a friend, as long as these discounts do not make the friend give Moonies back to her.\n\nBessie has $A$ Moonies and $B$ ice cream cones available ($0 \\le A,B \\le 2000$). Please help her find the maximum possible total popularity she can achieve if she spends her Moonies and ice cream cones in the best way.", "inputFormat": "The first line contains three integers $N$, $A$, and $B$, representing the number of friends Bessie has, the number of Moonies, and the number of ice cream cones.\n\nThe next $N$ lines each contain three integers $P_i$, $C_i$, and $X_i$, representing the popularity ($P_i$), the number of Moonies needed to bribe friend $i$ to accompany Bessie ($C_i$), and the number of ice cream cones needed to get a discount of $1$ Moony from friend $i$ ($X_i$).", "outputFormat": "Output the maximum total popularity of the friends who accompany Bessie, assuming she spends her Moonies and ice cream cones in the best way.", "hint": "### Explanation for Sample 1\n\nBessie can give $4$ Moonies and $4$ ice cream cones to cow $1$, and give $6$ Moonies and $3$ ice cream cones to cow $3$. Then cows $1$ and $3$ can accompany her, obtaining popularity $5+10=15$.\n\n### Test Point Properties\n\n- Test points $2-4$ satisfy $N \\le 5$ and $C_i=1$.\n- Test points $5-7$ satisfy $B=0$.\n- Test points $8-10$ satisfy $N,A,B,P_i,C_i,X_i \\le 50$.\n- Test points $11-15$ satisfy $N,A,B,P_i,C_i,X_i \\le 200$.\n- Test points $16-20$ have no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Bribing Friends G", "background": "", "description": "Bessie 想要观看纪录片：奶牛基因组学，但她不想一个人去。不幸的是，她的朋友们没有足够的热情和她一起去！于是，Bessie 需要贿赂她的朋友们陪她去电影院。她的贿赂武器库中有两种工具：**哞尼**和**冰激凌甜筒**。\n\nBessie 有 $N(1 \\le N \\le 2000)$ 个朋友。然而，并非所有的朋友都是生而平等的！朋友 $i$ 有受欢迎度 $P_i(1 \\le P_i \\le 2000)$，Bessie 想最大化陪她的朋友们的受欢迎度之和。朋友 $i$ 只有当 Bessie 给了她 $C_i(1 \\le C_i \\le 2000)$ 哞尼才愿意陪她。如果 Bessie 给她 $X_i(1 \\le X_i \\le 2000)$ 个冰激凌甜筒，她还可以给 Bessie $1$ 哞尼的折扣。Bessie 可以从朋友那里得到任意整数数量的折扣，只要这些折扣不会使得朋友倒给她哞尼。 \n\nBessie 有 $A$ 哞尼和 $B$ 个冰激凌甜筒可供使用（$0 \\le A,B \\le 2000$）。请帮助她求出如果她以最优方案花费她的哞尼和冰激凌甜筒，她可以达到的最大受欢迎度之和。 ", "inputFormat": "输入的第 1 行包含三个整数 $N$，$A$ 和 $B$，分别表示 Bessie 拥有的朋友的数量，哞尼的数量和冰激凌甜筒的数量。\n\n以下 $N$ 行每行包含三个整数 $P_i$，$C_i$ 和 $X_i$，表示受欢迎度（$P_i$），贿赂朋友 $i$ 陪 Bessie 所需要的哞尼（$C_i$），以及从朋友 $i$ 处获得 $1$ 哞尼的折扣所需要的冰激凌甜筒的数量（$X_i$）。", "outputFormat": "输出陪 Bessie 的朋友们的最大受欢迎度之和，假设她以最优方案花费她的哞尼和冰激凌甜筒。 ", "hint": "### 样例 1 解释\n\nBessie 可以将 $4$ 哞尼和 $4$ 个冰激凌甜筒给奶牛 $1$，将 $6$ 哞尼和 $3$ 个冰激凌甜筒给奶牛 $3$，这样奶牛 $1$ 和 $3$ 就可以陪她，得到 $5+10=15$ 的受欢迎度。\n\n### 测试点性质\n\n - 测试点 $2-4$ 满足 $N \\le 5$ 以及 $C_i=1$。\n - 测试点 $5-7$ 满足 $B=0$。\n - 测试点 $8-10$ 满足 $N,A,B,P_i,C_i,X_i \\le 50$。\n - 测试点 $11-15$ 满足 $N,A,B,P_i,C_i,X_i \\le 200$。\n - 测试点 $16-20$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P8904", "type": "P", "difficulty": 5, "samples": [["5\n2 4 3 1 5\n3\n4 3\n1 3\n3 2", "7\n10\n7"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "数学", "线段树", "USACO", "2022"], "title": "[USACO22DEC] Mountains G", "background": "", "description": "沿着 Farmer John 的农场边缘有 $N(1 \\le N \\le 2000)$ 座排成一行等间隔分布的山。这些山可以用一个高度数组 $h_1,h_2, \\cdots ,h_N$ 表示。对于山 $i$，如果没有一座山严格高于连接山 $j$ 和 $i$ 山顶的视线，则可以看到山 $j$。形式化地说，对于两座山 $i<j$，如果不存在 $k$ 使得 $i<k<j$ 并且 $(k,h_k)$ 高于连接 $(i,h_i)$ 和 $(j,h_j)$ 的线段，则这两座山之间互相可以看到对方。给定 $Q(1 \\le Q \\le 2000)$ 次更新操作，每次更新增加一座山的高度。求每次更新后可以互相看到的山的无序对数。 ", "inputFormat": "输入的第一行包含 $N$。\n\n第 $2$ 行包含 $N$ 个高度 $h_1,h_2,\\cdots,h_N$（对每一个 $i$，有 $0 \\le h_i \\le 10^9$）。\n\n第 $3$ 行包含 $Q$。\n\n第 $4$ 到 $3+Q$ 行每行包含 $x,y(1 \\le x \\le N,1 \\le y)$，其中 $x$ 为山的编号，$y$ 是山增加的高度。输入保证这座山更新后的高度不超过 $10^9$。 ", "outputFormat": "输出 $Q$ 行，包含每次更新后可以互相看到的山的无序对数。 ", "hint": "### 样例 1 解释\n\n初始时，以下的山之间可以互相看到：$(1,2)$，$(2,3)$，$(2,5)$，$(3,4)$，$(3,5)$，$(4,5)$，共 $6$ 对。\n\n第一次更新后，山 $4$ 的高度为 $4$，这不会阻挡现有的可见性，但使得山 $4$ 现在可以看到山 $2$，从而使得答案变为 $7$。\n\n第二次更新后，山 $1$ 的高度为 $5$，这不会阻挡现有的可见性，但使得山 $1$ 现在可以看到山 $3$，$4$ 和 $5$，从而使得答案变为 $10$。\n\n第三次更新后，山 $3$ 的高度为 $5$，阻挡了山 $1$ 看到山 $4$，阻挡了山 $2$ 看到山 $4$ 和 $5$，同时由于该山本就可以看到其他所有山，所以并没有使得该山看到更多的山，从而使得答案变为 $7$。\n\n### 测试点性质\n\n - 测试点 $2-5$ 满足 $N,Q \\le 100$。\n - 测试点 $6-11$ 满足 $Q \\le 10$。\n - 测试点 $12-21$ 没有额外性质。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Mountains G", "background": "", "description": "Along the edge of Farmer John’s farm, there are $N(1 \\le N \\le 2000)$ mountains arranged in a line at equal spacing. These mountains can be represented by a height array $h_1,h_2,\\cdots,h_N$. For mountain $i$, mountain $j$ is visible if there is no mountain strictly higher than the line of sight connecting the peaks of mountains $j$ and $i$. Formally, for two mountains $i<j$, if there does not exist $k$ such that $i<k<j$ and the point $(k,h_k)$ is above the line segment connecting $(i,h_i)$ and $(j,h_j)$, then these two mountains can see each other.  \n\nYou are given $Q(1 \\le Q \\le 2000)$ update operations, each of which increases the height of one mountain. After each update, output the number of unordered pairs of mountains that can see each other.", "inputFormat": "The first line contains $N$.\n\nThe second line contains $N$ heights $h_1,h_2,\\cdots,h_N$ (for each $i$, $0 \\le h_i \\le 10^9$).\n\nThe third line contains $Q$.\n\nLines $4$ to $3+Q$ each contain $x,y(1 \\le x \\le N,1 \\le y)$, where $x$ is the index of the mountain and $y$ is the amount by which its height increases. The input guarantees that the height of this mountain after the update does not exceed $10^9$.", "outputFormat": "Output $Q$ lines, each containing the number of unordered pairs of mountains that can see each other after the corresponding update.", "hint": "### Sample 1 Explanation\n\nInitially, the following pairs of mountains can see each other: $(1,2)$, $(2,3)$, $(2,5)$, $(3,4)$, $(3,5)$, $(4,5)$, for a total of $6$ pairs.\n\nAfter the first update, the height of mountain $4$ becomes $4$. This does not block any existing visibility, but it makes mountain $4$ able to see mountain $2$, so the answer becomes $7$.\n\nAfter the second update, the height of mountain $1$ becomes $5$. This does not block any existing visibility, but it makes mountain $1$ able to see mountains $3$, $4$, and $5$, so the answer becomes $10$.\n\nAfter the third update, the height of mountain $3$ becomes $5$. This blocks mountain $1$ from seeing mountain $4$, and blocks mountain $2$ from seeing mountains $4$ and $5$. At the same time, since this mountain could already see all other mountains, it does not make it see more mountains, so the answer becomes $7$.\n\n### Test Point Properties\n\n- Test points $2-5$ satisfy $N,Q \\le 100$.\n- Test points $6-11$ satisfy $Q \\le 10$.\n- Test points $12-21$ have no additional properties.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Mountains G", "background": "", "description": "沿着 Farmer John 的农场边缘有 $N(1 \\le N \\le 2000)$ 座排成一行等间隔分布的山。这些山可以用一个高度数组 $h_1,h_2, \\cdots ,h_N$ 表示。对于山 $i$，如果没有一座山严格高于连接山 $j$ 和 $i$ 山顶的视线，则可以看到山 $j$。形式化地说，对于两座山 $i<j$，如果不存在 $k$ 使得 $i<k<j$ 并且 $(k,h_k)$ 高于连接 $(i,h_i)$ 和 $(j,h_j)$ 的线段，则这两座山之间互相可以看到对方。给定 $Q(1 \\le Q \\le 2000)$ 次更新操作，每次更新增加一座山的高度。求每次更新后可以互相看到的山的无序对数。 ", "inputFormat": "输入的第一行包含 $N$。\n\n第 $2$ 行包含 $N$ 个高度 $h_1,h_2,\\cdots,h_N$（对每一个 $i$，有 $0 \\le h_i \\le 10^9$）。\n\n第 $3$ 行包含 $Q$。\n\n第 $4$ 到 $3+Q$ 行每行包含 $x,y(1 \\le x \\le N,1 \\le y)$，其中 $x$ 为山的编号，$y$ 是山增加的高度。输入保证这座山更新后的高度不超过 $10^9$。 ", "outputFormat": "输出 $Q$ 行，包含每次更新后可以互相看到的山的无序对数。 ", "hint": "### 样例 1 解释\n\n初始时，以下的山之间可以互相看到：$(1,2)$，$(2,3)$，$(2,5)$，$(3,4)$，$(3,5)$，$(4,5)$，共 $6$ 对。\n\n第一次更新后，山 $4$ 的高度为 $4$，这不会阻挡现有的可见性，但使得山 $4$ 现在可以看到山 $2$，从而使得答案变为 $7$。\n\n第二次更新后，山 $1$ 的高度为 $5$，这不会阻挡现有的可见性，但使得山 $1$ 现在可以看到山 $3$，$4$ 和 $5$，从而使得答案变为 $10$。\n\n第三次更新后，山 $3$ 的高度为 $5$，阻挡了山 $1$ 看到山 $4$，阻挡了山 $2$ 看到山 $4$ 和 $5$，同时由于该山本就可以看到其他所有山，所以并没有使得该山看到更多的山，从而使得答案变为 $7$。\n\n### 测试点性质\n\n - 测试点 $2-5$ 满足 $N,Q \\le 100$。\n - 测试点 $6-11$ 满足 $Q \\le 10$。\n - 测试点 $12-21$ 没有额外性质。", "locale": "zh-CN"}}}
{"pid": "P8905", "type": "P", "difficulty": 5, "samples": [["8 10\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n1 5\n2 6\n3 7\n4 8", "12"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["USACO", "并查集", "2022", "枚举", "连通块"], "title": "[USACO22DEC] Strongest Friendship Group G", "background": "", "description": "Farmer John 有 $N$ 头奶牛（$2 \\le N \\le 10^5$），编号为 $1\\cdots N$。这些奶牛中有 $M(1 \\le M \\le 2\\times 10^5)$ 对朋友。\n\n一组奶牛被称为是「小团体」，如果该组中的每头奶牛都可以从该组中的每头其他奶牛出发通过完全位于该组内的一系列朋友关系到达（连接到组外奶牛的朋友关系无效）。小团体的「强度」是组内奶牛的最小组内朋友数乘以组内奶牛的数量（同样，注意连接到组外奶牛的朋友关系不计入此定义）。\n\n求所有小团体的最大强度。 ", "inputFormat": "输入的第一行包含 $N$ 和 $M$。\n\n以下 $M$ 行每行包含两个整数 $u_i$ 和 $v_i$，表示奶牛 $u_i$ 和 $v_i$ 是朋友（$1 \\le u_i,v_i \\le N,u_i\\neq v_i$）。每个奶牛无序对至多出现一次。 ", "outputFormat": " 输出一行，包含所有小团体的最大强度。 ", "hint": "### 样例 1 解释\n\n可以观察到最大强度来自编号为 $1,2,3,4$ 的奶牛组。该组内奶牛的最小朋友数为 $3$，故答案为 $4 \\times 3=12$。\n\n### 测试点性质\n\n - 对于 $1 \\le T \\le 3$，测试点 $T$ 满足 $N \\le 16$。\n - 对于 $4 \\le T \\le 9$，测试点 $T$ 满足 $N \\le 1000$。\n- 对于 $10 \\le T \\le 20$，测试点 $T$ 没有额外限制。 ", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Strongest Friendship Group G", "background": "", "description": "Farmer John has $N$ cows ($2 \\le N \\le 10^5$), numbered $1 \\cdots N$. Among these cows, there are $M$ ($1 \\le M \\le 2 \\times 10^5$) pairs of friends.\n\nA group of cows is called a \"friend group\" if, for every cow in the group, it can reach every other cow in the group by following a sequence of friendships that stays entirely within the group (friendships that connect to cows outside the group are invalid). The \"strength\" of a friend group is defined as:\n\n(the minimum number of in-group friends among cows in the group) $\\times$ (the number of cows in the group)\n\n(again, note that friendships connecting to cows outside the group are not counted in this definition).\n\nFind the maximum strength among all friend groups.", "inputFormat": "The first line contains $N$ and $M$.\n\nThe next $M$ lines each contain two integers $u_i$ and $v_i$, indicating that cows $u_i$ and $v_i$ are friends ($1 \\le u_i, v_i \\le N$, $u_i \\neq v_i$). Each unordered pair of cows appears at most once.", "outputFormat": "Output one line containing the maximum strength among all friend groups.", "hint": "### Explanation for Sample 1\n\nIt can be seen that the maximum strength comes from the group of cows numbered $1, 2, 3, 4$. In this group, the minimum number of friends is $3$, so the answer is $4 \\times 3 = 12$.\n\n### Test Point Properties\n\n- For $1 \\le T \\le 3$, test point $T$ satisfies $N \\le 16$.\n- For $4 \\le T \\le 9$, test point $T$ satisfies $N \\le 1000$.\n- For $10 \\le T \\le 20$, test point $T$ has no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Strongest Friendship Group G", "background": "", "description": "Farmer John 有 $N$ 头奶牛（$2 \\le N \\le 10^5$），编号为 $1\\cdots N$。这些奶牛中有 $M(1 \\le M \\le 2\\times 10^5)$ 对朋友。\n\n一组奶牛被称为是「小团体」，如果该组中的每头奶牛都可以从该组中的每头其他奶牛出发通过完全位于该组内的一系列朋友关系到达（连接到组外奶牛的朋友关系无效）。小团体的「强度」是组内奶牛的最小组内朋友数乘以组内奶牛的数量（同样，注意连接到组外奶牛的朋友关系不计入此定义）。\n\n求所有小团体的最大强度。 ", "inputFormat": "输入的第一行包含 $N$ 和 $M$。\n\n以下 $M$ 行每行包含两个整数 $u_i$ 和 $v_i$，表示奶牛 $u_i$ 和 $v_i$ 是朋友（$1 \\le u_i,v_i \\le N,u_i\\neq v_i$）。每个奶牛无序对至多出现一次。 ", "outputFormat": " 输出一行，包含所有小团体的最大强度。 ", "hint": "### 样例 1 解释\n\n可以观察到最大强度来自编号为 $1,2,3,4$ 的奶牛组。该组内奶牛的最小朋友数为 $3$，故答案为 $4 \\times 3=12$。\n\n### 测试点性质\n\n - 对于 $1 \\le T \\le 3$，测试点 $T$ 满足 $N \\le 16$。\n - 对于 $4 \\le T \\le 9$，测试点 $T$ 满足 $N \\le 1000$。\n- 对于 $10 \\le T \\le 20$，测试点 $T$ 没有额外限制。 ", "locale": "zh-CN"}}}
{"pid": "P8906", "type": "P", "difficulty": 6, "samples": [["3 4\n10 4 4\n9 5 3\n2 1 6\n3 1\n2 3\n2 1\n3 2\n2 2\n1 3\n3 3\n1 1\n1 2", "11\n18\n22\n22\n22\n-1\n-1\n-1\n-1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["USACO", "2022", "最短路", "均摊分析", "折半搜索 meet in the middle"], "title": "[USACO22DEC] Breakdown P", "background": "", "description": "Farmer John 的农场可以用一个带权有向图表示，道路（边）连接不同的结点，每条边的权值是通过道路所需的时间。每天，Bessie 喜欢从牛棚（位于结点 $1$）经过恰好 $K$ 条道路前往草地（位于结点 $N$），并希望在此限制下尽快到达草地。然而，在某些时候，道路停止维护，一条一条地开始破损，变得无法通行。帮助 Bessie 求出每一时刻从牛棚到草地的最短路径！\n\n形式化地说，我们从一个 $N$ 个结点（$1 \\le N \\le 300$）和 $N^2$ 条边的带权有向完全图开始：对于 $1 \\le i,j \\le N$ 的每一对 $(i,j)$ 存在一条边（注意存在 $N$ 个自环）。每次移除一条边后，输出从 $1$ 到 $N$ 的所有路径中经过恰好 $K$ 条边（不一定各不相同）的路径的最小权值（$2 \\le K \\le 8$）。注意在第 $i$ 次移除后，该图还剩下 $N^2-i$ 条边。\n\n路径的权值定义为路径上所有边的权值之和。注意一条路径可以包含同一条边多次或同一个结点多次，包括结点 $1$\n和 $N$。", "inputFormat": "输入的第一行包含 $N$ 和 $K$。\n\n以下 $N$ 行每行包含 $N$ 个整数。第 $i$ 行的第 $j$ 个整数为 $w_{ij}(1 \\le w_{ij} \\le 10^8)$。\n\n以下 $N^2$ 行，每行包含两个整数 $i$ 和 $j$（$1 \\le i,j \\le N$）。每对整数出现恰好一次。 ", "outputFormat": "输出 $N^2$ 行，为每一次移除后经过 $K$ 条边的路径的最小权值。如果不存在经过 $K$ 条边的路径则输出 $-1$。 ", "hint": "### 样例 1 解释\n\n第一次移除后，最短的经过 $4$ 条边的路径为：\n\n$$1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 2 \\rightarrow 3$$\n\n第二次移除后，最短的经过 $4$ 条边的路径为：\n\n$$1 \\rightarrow 3 \\rightarrow 2 \\rightarrow 1 \\rightarrow 3$$\n\n第三次移除后，最短的经过 $4$ 条边的路径为：\n\n$$1 \\rightarrow 3 \\rightarrow 3 \\rightarrow 3 \\rightarrow 3$$\n\n六次移除后，不再存在经过 $4$ 条边的路径。 \n\n### 测试点性质\n\n - 对于 $2 \\le T \\le 14$，测试点 $T$ 满足 $K=\\lfloor \\dfrac{T+3}{2} \\rfloor$。 ", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Breakdown P", "background": "", "description": "Farmer John’s farm can be represented as a weighted directed graph. Roads (edges) connect different nodes, and the weight of each edge is the time needed to travel along that road. Every day, Bessie likes to go from the barn (located at node $1$) to the pasture (located at node $N$) using exactly $K$ roads, and she wants to arrive as quickly as possible under this restriction. However, at certain times, roads stop being maintained and begin to break down one by one, becoming impassable. Help Bessie find the shortest path from the barn to the pasture at every moment.\n\nFormally, we start with a weighted directed complete graph with $N$ nodes ($1 \\le N \\le 300$) and $N^2$ edges: for every pair $(i,j)$ with $1 \\le i,j \\le N$, there is an edge (note that there are $N$ self-loops). After each removal of one edge, output the minimum total weight among all paths from $1$ to $N$ that use exactly $K$ edges (edges on the path do not have to be distinct) ($2 \\le K \\le 8$). Note that after the $i$-th removal, the graph has $N^2-i$ edges remaining.\n\nThe weight of a path is defined as the sum of the weights of all edges on the path. Note that a path may contain the same edge multiple times or visit the same node multiple times, including nodes $1$ and $N$.", "inputFormat": "The first line contains $N$ and $K$.\n\nThe next $N$ lines each contain $N$ integers. The $j$-th integer in the $i$-th line is $w_{ij}(1 \\le w_{ij} \\le 10^8)$.\n\nThe following $N^2$ lines each contain two integers $i$ and $j$ ($1 \\le i,j \\le N$). Each pair of integers appears exactly once.", "outputFormat": "Output $N^2$ lines. For each edge removal, output the minimum total weight of a path that uses exactly $K$ edges. If no such path exists, output $-1$.", "hint": "### Sample 1 Explanation\n\nAfter the first removal, the shortest path that uses exactly $4$ edges is:\n\n$$1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 2 \\rightarrow 3$$\n\nAfter the second removal, the shortest path that uses exactly $4$ edges is:\n\n$$1 \\rightarrow 3 \\rightarrow 2 \\rightarrow 1 \\rightarrow 3$$\n\nAfter the third removal, the shortest path that uses exactly $4$ edges is:\n\n$$1 \\rightarrow 3 \\rightarrow 3 \\rightarrow 3 \\rightarrow 3$$\n\nAfter the sixth removal, there is no longer any path that uses exactly $4$ edges.\n\n### Testdata Properties\n\n- For $2 \\le T \\le 14$, testdata $T$ satisfies $K=\\lfloor \\dfrac{T+3}{2} \\rfloor$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Breakdown P", "background": "", "description": "Farmer John 的农场可以用一个带权有向图表示，道路（边）连接不同的结点，每条边的权值是通过道路所需的时间。每天，Bessie 喜欢从牛棚（位于结点 $1$）经过恰好 $K$ 条道路前往草地（位于结点 $N$），并希望在此限制下尽快到达草地。然而，在某些时候，道路停止维护，一条一条地开始破损，变得无法通行。帮助 Bessie 求出每一时刻从牛棚到草地的最短路径！\n\n形式化地说，我们从一个 $N$ 个结点（$1 \\le N \\le 300$）和 $N^2$ 条边的带权有向完全图开始：对于 $1 \\le i,j \\le N$ 的每一对 $(i,j)$ 存在一条边（注意存在 $N$ 个自环）。每次移除一条边后，输出从 $1$ 到 $N$ 的所有路径中经过恰好 $K$ 条边（不一定各不相同）的路径的最小权值（$2 \\le K \\le 8$）。注意在第 $i$ 次移除后，该图还剩下 $N^2-i$ 条边。\n\n路径的权值定义为路径上所有边的权值之和。注意一条路径可以包含同一条边多次或同一个结点多次，包括结点 $1$\n和 $N$。", "inputFormat": "输入的第一行包含 $N$ 和 $K$。\n\n以下 $N$ 行每行包含 $N$ 个整数。第 $i$ 行的第 $j$ 个整数为 $w_{ij}(1 \\le w_{ij} \\le 10^8)$。\n\n以下 $N^2$ 行，每行包含两个整数 $i$ 和 $j$（$1 \\le i,j \\le N$）。每对整数出现恰好一次。 ", "outputFormat": "输出 $N^2$ 行，为每一次移除后经过 $K$ 条边的路径的最小权值。如果不存在经过 $K$ 条边的路径则输出 $-1$。 ", "hint": "### 样例 1 解释\n\n第一次移除后，最短的经过 $4$ 条边的路径为：\n\n$$1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 2 \\rightarrow 3$$\n\n第二次移除后，最短的经过 $4$ 条边的路径为：\n\n$$1 \\rightarrow 3 \\rightarrow 2 \\rightarrow 1 \\rightarrow 3$$\n\n第三次移除后，最短的经过 $4$ 条边的路径为：\n\n$$1 \\rightarrow 3 \\rightarrow 3 \\rightarrow 3 \\rightarrow 3$$\n\n六次移除后，不再存在经过 $4$ 条边的路径。 \n\n### 测试点性质\n\n - 对于 $2 \\le T \\le 14$，测试点 $T$ 满足 $K=\\lfloor \\dfrac{T+3}{2} \\rfloor$。 ", "locale": "zh-CN"}}}
{"pid": "P8907", "type": "P", "difficulty": 5, "samples": [["7 6\n1 3\n1 4\n7 1\n2 3\n2 4\n3 5", "5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["USACO", "2022", "启发式合并"], "title": "[USACO22DEC] Making Friends P", "background": "", "description": "FJ 的 $N(2 \\le N \\le 2 \\times 10^5)$ 头编号为 $1 \\cdots N$ 的奶牛之中初始时有 $M(1 \\le M \\le 2 \\times 10^5)$ 对朋友。奶牛们一头一头地离开农场去度假。第 $i$ 天，第 $i$ 头奶牛离开了农场，同时第 $i$ 头奶牛的所有仍在农场的朋友互相都成为了朋友。问总共建立了多少新的朋友关系？\n\n", "inputFormat": "输入的第一行包含 $N$ 和 $M$。\n\n以下 $M$ 行每行包含两个整数 $u_i$ 和 $v_i$，表示奶牛 $u_i$ 和 $v_i$ 是朋友（$1 \\le u_i,v_i \\le N,u_i \\neq v_i$）。每个奶牛无序对至多出现一次。 \n\n", "outputFormat": " 输出一行，包含形成的新的朋友关系的总数。不要计入初始时已经是朋友的奶牛对。 ", "hint": "### 样例 1 解释\n\n第 $1$ 天，三个新的朋友关系被建立：$(3,4)$，$(3,7)$ 和 $(4,7)$。\n\n第 $3$ 天，两个新的朋友关系被建立：$(4,5)$ 和 $(5,7)$。\n\n### 测试点性质\n\n - 测试点 $2-3$ 满足 $N \\le 500$。\n - 测试点 $4-7$ 满足 $N \\le 10^4$。\n - 测试点 $8-17$ 没有额外限制。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO22DEC] Making Friends P", "background": "", "description": "Among FJ's $N(2 \\le N \\le 2 \\times 10^5)$ cows numbered $1 \\cdots N$, there are initially $M(1 \\le M \\le 2 \\times 10^5)$ pairs of friends. The cows leave the farm one by one to go on vacation. On day $i$, cow $i$ leaves the farm, and at the same time, all of cow $i$'s friends that are still on the farm become friends with each other. How many new friendship relationships are created in total?", "inputFormat": "The first line contains $N$ and $M$.\n\nThe next $M$ lines each contain two integers $u_i$ and $v_i$, meaning cows $u_i$ and $v_i$ are friends ($1 \\le u_i,v_i \\le N, u_i \\neq v_i$). Each unordered pair of cows appears at most once.", "outputFormat": "Output one line containing the total number of new friendship relationships formed. Do not count pairs of cows that were already friends initially.", "hint": "### Explanation for Sample 1\n\nOn day $1$, three new friendship relationships are created: $(3,4)$, $(3,7)$, and $(4,7)$.\n\nOn day $3$, two new friendship relationships are created: $(4,5)$ and $(5,7)$.\n\n### Test Point Properties\n\n- Test points $2-3$ satisfy $N \\le 500$.\n- Test points $4-7$ satisfy $N \\le 10^4$.\n- Test points $8-17$ have no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO22DEC] Making Friends P", "background": "", "description": "FJ 的 $N(2 \\le N \\le 2 \\times 10^5)$ 头编号为 $1 \\cdots N$ 的奶牛之中初始时有 $M(1 \\le M \\le 2 \\times 10^5)$ 对朋友。奶牛们一头一头地离开农场去度假。第 $i$ 天，第 $i$ 头奶牛离开了农场，同时第 $i$ 头奶牛的所有仍在农场的朋友互相都成为了朋友。问总共建立了多少新的朋友关系？\n\n", "inputFormat": "输入的第一行包含 $N$ 和 $M$。\n\n以下 $M$ 行每行包含两个整数 $u_i$ 和 $v_i$，表示奶牛 $u_i$ 和 $v_i$ 是朋友（$1 \\le u_i,v_i \\le N,u_i \\neq v_i$）。每个奶牛无序对至多出现一次。 \n\n", "outputFormat": " 输出一行，包含形成的新的朋友关系的总数。不要计入初始时已经是朋友的奶牛对。 ", "hint": "### 样例 1 解释\n\n第 $1$ 天，三个新的朋友关系被建立：$(3,4)$，$(3,7)$ 和 $(4,7)$。\n\n第 $3$ 天，两个新的朋友关系被建立：$(4,5)$ 和 $(5,7)$。\n\n### 测试点性质\n\n - 测试点 $2-3$ 满足 $N \\le 500$。\n - 测试点 $4-7$ 满足 $N \\le 10^4$。\n - 测试点 $8-17$ 没有额外限制。", "locale": "zh-CN"}}}
