{"pid": "P12571", "type": "P", "difficulty": 0, "samples": [["8\naabaaaba\n3\n3 7\n1 8\n4 4", "4\n6\n0"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "交互题", "Special Judge", "UOI（乌克兰）"], "title": "[UOI 2023] An Array of Characters and Almost Palindromes【交互库尚未配置】", "background": "", "description": "This is an interactive problem.\n\nA string is considered a palindrome if it reads the same from both sides. Formally, a string $s$ of length $n$ is considered a palindrome if $s_i = s_{n-i+1}$ for $1 \\le i \\le n$. For example, the strings ``gg``, ``ara``, ``abacaba``, and ``rotator`` are palindromes, while the strings ``array``, ``palindrome``, and ``uoi`` are not.\n\nWe call a string a **nearly palindrome** if its characters can be rearranged to form a palindrome. For example, the strings ``n``, ``ara``, ``arr``, and ``array`` are nearly palindromes, while the strings ``palindrome``, ``uoi``, and ``random`` are not.\n\nA substring of a string is a string that can be obtained by deleting some (possibly zero) elements from its beginning and end.\n\nLet $f(s)$ be the maximum length among the lengths of substrings of $s$ that are **not** nearly palindromes, or $0$ if there are no such substrings.\n\nYou are given a string $s$ of length $n$ consisting of lowercase Latin letters. You are also given $q$ queries of the form $l_i$, $r_i$. For each query, find the value of $f(s[l_i..r_i])$, where $s[l_i..r_i]$ denotes the substring consisting of characters $s_{l_i}, s_{l_{i} + 1}, \\ldots, s_{r_i}$.", "inputFormat": "The first line contains one integer $n$ ($1 \\le n \\le 2\\cdot 10^5$) --- the length of the string.\n\nThe second line contains a string $s$ consisting of $n$ lowercase Latin letters.\n\nThe third line contains one integer $q$ ($1\\le q \\le 2\\cdot 10^5$) --- the number of queries.\n\nThe fourth line contains two integers $l_1, r_1$ ($1 \\leq l_1 \\leq r_1 \\leq n$) --- the parameters of the first query.\n\nYou will receive the parameters of the next queries from the jury program (see section Interaction Protocol).\n\n### Interaction Protocol\n\n\nThe jury program will output two integers $l_i$, $r_i$ ($1\\le l_i\\le r_i\\le n$) on separate lines for each query, starting from the second one.\n\nThe jury program will not output the parameters for the next query until it reads the response of your program to the previous query.\n\nMake sure to call the $\\texttt{flush}$ method after outputting each line. You can use:\n\n- $\\texttt{fflush(stdout)}$, $\\texttt{cout <{}< endl}$, or $\\texttt{cout.flush()}$ in $\\tt{C++}$;\n- $\\texttt{System.out.flush()}$ in $\\tt{Java}$;\n- $\\texttt{flush(output)}$ in $\\tt{Pascal}$;\n- $\\texttt{sys.stdout.flush()}$ in $\\tt{Python}$;\n- consult the documentation for other programming languages.", "outputFormat": "For each $i$-th query, output one integer --- the value of $f(s[l_i..r_i])$, in a separate line.", "hint": "In the first example, you need to find the answers to three queries:\n\n- $s[3..7] =\\;$``baaab``, which has a substring ``aaab`` of length 4, which is not an **almost palindrome**;\n- $s[1..8] =\\;$``aabaaaba``, which has a substring ``aabaaa`` of length 6, which is not an **almost palindrome**;\n- $s[4..4] =\\;$``a``, all substrings of which are **almost palindromes**.\n\n### Scoring\n\n- ($6$ points): $q=1$, $l_1=1$, $r_1=n$, $n$ is even, $s$ has the form ``aabbaabbaa...``;\n- ($9$ points): $q=1$, $l_1=1$, $r_1=n$, $n \\le 200$;\n- ($5$ points): $q=1$, $l_1=1$, $r_1=n$, $n \\le 5000$;\n- ($8$ points): $q=1$, $l_1=1$, $r_1=n$;\n- ($10$ points): $s$ contains only letters $\\tt{a}$ and $\\tt{b}$;\n- ($8$ points): $s_{l_i} \\neq s_{r_i}$ for $1 \\le i \\le q$;\n- ($7$ points): $s_i \\neq s_{i+1}$ for $1 \\le i < n$;\n- ($10$ points): $s$ contains only letters $\\tt{a}, \\tt{b}, \\tt{c}, \\tt{d}, \\tt{e}$, and $\\tt{f}$;\n- ($18$ points): $(r_i-l_i+1)$ is odd for $1\\le i\\le q$;\n- ($19$ points): without additional constraints.", "locale": "en", "translations": {"en": {"title": "[UOI 2023] An Array of Characters and Almost Palindromes【交互库尚未配置】", "background": "", "description": "This is an interactive problem.\n\nA string is considered a palindrome if it reads the same from both sides. Formally, a string $s$ of length $n$ is considered a palindrome if $s_i = s_{n-i+1}$ for $1 \\le i \\le n$. For example, the strings ``gg``, ``ara``, ``abacaba``, and ``rotator`` are palindromes, while the strings ``array``, ``palindrome``, and ``uoi`` are not.\n\nWe call a string a **nearly palindrome** if its characters can be rearranged to form a palindrome. For example, the strings ``n``, ``ara``, ``arr``, and ``array`` are nearly palindromes, while the strings ``palindrome``, ``uoi``, and ``random`` are not.\n\nA substring of a string is a string that can be obtained by deleting some (possibly zero) elements from its beginning and end.\n\nLet $f(s)$ be the maximum length among the lengths of substrings of $s$ that are **not** nearly palindromes, or $0$ if there are no such substrings.\n\nYou are given a string $s$ of length $n$ consisting of lowercase Latin letters. You are also given $q$ queries of the form $l_i$, $r_i$. For each query, find the value of $f(s[l_i..r_i])$, where $s[l_i..r_i]$ denotes the substring consisting of characters $s_{l_i}, s_{l_{i} + 1}, \\ldots, s_{r_i}$.", "inputFormat": "The first line contains one integer $n$ ($1 \\le n \\le 2\\cdot 10^5$) --- the length of the string.\n\nThe second line contains a string $s$ consisting of $n$ lowercase Latin letters.\n\nThe third line contains one integer $q$ ($1\\le q \\le 2\\cdot 10^5$) --- the number of queries.\n\nThe fourth line contains two integers $l_1, r_1$ ($1 \\leq l_1 \\leq r_1 \\leq n$) --- the parameters of the first query.\n\nYou will receive the parameters of the next queries from the jury program (see section Interaction Protocol).\n\n### Interaction Protocol\n\n\nThe jury program will output two integers $l_i$, $r_i$ ($1\\le l_i\\le r_i\\le n$) on separate lines for each query, starting from the second one.\n\nThe jury program will not output the parameters for the next query until it reads the response of your program to the previous query.\n\nMake sure to call the $\\texttt{flush}$ method after outputting each line. You can use:\n\n- $\\texttt{fflush(stdout)}$, $\\texttt{cout <{}< endl}$, or $\\texttt{cout.flush()}$ in $\\tt{C++}$;\n- $\\texttt{System.out.flush()}$ in $\\tt{Java}$;\n- $\\texttt{flush(output)}$ in $\\tt{Pascal}$;\n- $\\texttt{sys.stdout.flush()}$ in $\\tt{Python}$;\n- consult the documentation for other programming languages.", "outputFormat": "For each $i$-th query, output one integer --- the value of $f(s[l_i..r_i])$, in a separate line.", "hint": "In the first example, you need to find the answers to three queries:\n\n- $s[3..7] =\\;$``baaab``, which has a substring ``aaab`` of length 4, which is not an **almost palindrome**;\n- $s[1..8] =\\;$``aabaaaba``, which has a substring ``aabaaa`` of length 6, which is not an **almost palindrome**;\n- $s[4..4] =\\;$``a``, all substrings of which are **almost palindromes**.\n\n### Scoring\n\n- ($6$ points): $q=1$, $l_1=1$, $r_1=n$, $n$ is even, $s$ has the form ``aabbaabbaa...``;\n- ($9$ points): $q=1$, $l_1=1$, $r_1=n$, $n \\le 200$;\n- ($5$ points): $q=1$, $l_1=1$, $r_1=n$, $n \\le 5000$;\n- ($8$ points): $q=1$, $l_1=1$, $r_1=n$;\n- ($10$ points): $s$ contains only letters $\\tt{a}$ and $\\tt{b}$;\n- ($8$ points): $s_{l_i} \\neq s_{r_i}$ for $1 \\le i \\le q$;\n- ($7$ points): $s_i \\neq s_{i+1}$ for $1 \\le i < n$;\n- ($10$ points): $s$ contains only letters $\\tt{a}, \\tt{b}, \\tt{c}, \\tt{d}, \\tt{e}$, and $\\tt{f}$;\n- ($18$ points): $(r_i-l_i+1)$ is odd for $1\\le i\\le q$;\n- ($19$ points): without additional constraints.", "locale": "en"}, "zh-CN": {"title": "[UOI 2023] An Array of Characters and Almost Palindromes【交互库尚未配置】", "background": "", "description": "这是一道交互题。\n\n如果一个字符串从正反两个方向读都相同，则称其为回文串。形式化地说，长度为 $n$ 的字符串 $s$ 是回文串当且仅当对所有 $1 \\le i \\le n$ 都有 $s_i = s_{n-i+1}$。例如，字符串 `gg`、`ara`、`abacaba` 和 `rotator` 是回文串，而 `array`、`palindrome` 和 `uoi` 不是。\n\n我们称一个字符串为**近回文串**，如果可以通过重新排列其字符使其成为回文串。例如，字符串 `n`、`ara`、`arr` 和 `array` 是近回文串，而 `palindrome`、`uoi` 和 `random` 不是。\n\n字符串的子串是指通过从开头和结尾删除若干（可能为零）个字符后得到的字符串。\n\n定义 $f(s)$ 为字符串 $s$ 的所有**非**近回文串子串中的最大长度，若不存在这样的子串则返回 $0$。\n\n给定一个由小写拉丁字母组成的长度为 $n$ 的字符串 $s$，以及 $q$ 个形如 $l_i$, $r_i$ 的查询。对于每个查询，计算 $f(s[l_i..r_i])$ 的值，其中 $s[l_i..r_i]$ 表示由字符 $s_{l_i}, s_{l_{i} + 1}, \\ldots, s_{r_i}$ 组成的子串。\n", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 2\\cdot 10^5$）——字符串的长度。\n\n第二行包含一个由 $n$ 个小写拉丁字母组成的字符串 $s$。\n\n第三行包含一个整数 $q$（$1 \\le q \\le 2\\cdot 10^5$）——查询的数量。\n\n第四行包含两个整数 $l_1, r_1$（$1 \\leq l_1 \\leq r_1 \\leq n$）——第一个查询的参数。\n\n后续查询的参数将由评测程序给出（见交互协议部分）。\n\n### 交互协议\n\n评测程序将从第二个查询开始，逐行输出每个查询的两个整数 $l_i$, $r_i$（$1 \\le l_i \\le r_i \\le n$）。\n\n评测程序在读取到你的程序对前一个查询的响应后，才会输出下一个查询的参数。\n\n请确保在每次输出后调用刷新函数。可以使用以下方法：\n- C++：`fflush(stdout)`、`cout << endl` 或 `cout.flush()`；\n- Java：`System.out.flush()`；\n- Pascal：`flush(output)`；\n- Python：`sys.stdout.flush()`；\n- 其他编程语言请参考相关文档。", "outputFormat": "对于每个查询，输出一行一个整数——$f(s[l_i..r_i])$ 的值。", "hint": "在第一个样例中，需要回答三个查询：\n1. $s[3..7] =\\;$`baaab`，其子串 `aaab` 长度为 4，不是**近回文串**；\n2. $s[1..8] =\\;$`aabaaaba`，其子串 `aabaaa` 长度为 6，不是**近回文串**；\n3. $s[4..4] =\\;$`a`，其所有子串都是**近回文串**。\n\n### 评分标准\n\n- （$6$ 分）：$q=1$，$l_1=1$，$r_1=n$，$n$ 为偶数，$s$ 形如 `aabbaabbaa...`；\n- （$9$ 分）：$q=1$，$l_1=1$，$r_1=n$，$n \\le 200$；\n- （$5$ 分）：$q=1$，$l_1=1$，$r_1=n$，$n \\le 5000$；\n- （$8$ 分）：$q=1$，$l_1=1$，$r_1=n$；\n- （$10$ 分）：$s$ 仅包含字母 `a` 和 `b`；\n- （$8$ 分）：对所有 $1 \\le i \\le q$，$s_{l_i} \\neq s_{r_i}$；\n- （$7$ 分）：对所有 $1 \\le i < n$，$s_i \\neq s_{i+1}$；\n- （$10$ 分）：$s$ 仅包含字母 `a`、`b`、`c`、`d`、`e` 和 `f`；\n- （$18$ 分）：对所有 $1 \\le i \\le q$，$(r_i-l_i+1)$ 为奇数；\n- （$19$ 分）：无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12572", "type": "P", "difficulty": 4, "samples": [["1 0\n1", "99\n99 98 ... 7 6 5 4 3 2 1"], ["2 0\n3\n16", "101\n99 98 ... 7 6 5 4 3 2 1 1 1\n103\n99 98 ... 7 6 5 4 4 3 3 2 2 1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "Special Judge", "构造", "UOI（乌克兰）"], "title": "[UOI 2023] An Array and Addition Again", "background": "", "description": "Given an array $a$ with elements numbered from $1$ to $100$. Initially, $a_i = 0$ for $1 \\leq i < 100$, and the last element $a_{100}$ is equal to $1$.\n\nThe array $a$ can be modified using **increment operations**. To perform $m$ **increment operations**, it is necessary to select $m$ integers $p_1, p_2, \\dots, p_m$ ($1\\le p_i < 100$) and sequentially execute assignments $a_{p_i} \\leftarrow (a_{p_i} + a_{p_i + 1})$ for $i$ from $1$ to $m$.\n\nGiven an integer $n$, find the sequence of **increment operations** after which the element at the first position in array $a$ becomes equal to $n$.", "inputFormat": "The first line contains two integers $t$ and $g$ ($1 \\le t \\le 100$, $0 \\leq g \\leq 5$) --- the number of input sets and the test block number, respectively.\n\nIn the next $t$ lines, there is a single integer $n$ ($1 \\le n \\le 10^{18}$) --- the value that $a_1$ should be equal to after performing the **increment operations** in the corresponding set.", "outputFormat": "For each set of input data, output one integer $m$ ($0 \\leq m \\leq 2000$) in the first line --- the number of **increase operations**.\n\nIn the second line, output $m$ integers $p_i$ ($1 \\le p_i < 100$) --- the parameters of the **increase operations**.\n\nIf there are multiple correct answers, you can output any of them.", "hint": "For clarity, the examples of the input data in the problem statement have been reduced. To obtain the correct answer, replace $\\tt{...}$ with the sequence of integers from $97$ to $8$.\n\nLet's consider the second set of input data for the second example, where $n = 16$. The first 8 elements of the array $a$ after performing the next operation look as follows:\n\n- $p_1$ = 99, $a = [0, 0, 0, 0, 0, 0, 0, 0, \\ldots, 0, 0, 1, 1]$;\n- $p_2$ = 98, $a = [0, 0, 0, 0, 0, 0, 0, 0, \\ldots, 0, 1, 1, 1]$;\n- $\\ldots$\n- $p_{93} = 7$, $a = [0, 0, 0, 0, 0, 0, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{94} = 6$, $a = [0, 0, 0, 0, 0, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{95} = 5$, $a = [0, 0, 0, 0, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{96} = 4$, $a = [0, 0, 0, 1, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{97} = 4$, $a = [0, 0, 0, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{98} = 3$, $a = [0, 0, 2, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{99} = 3$, $a = [0, 0, 4, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{100} = 2$, $a = [0, 4, 4, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{101} = 2$, $a = [0, 8, 4, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{102} = 1$, $a = [8, 8, 4, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{103} = 1$, $a = [16, 8, 4, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$.\n\n### Scoring\n\nThe first four test blocks allow using **no more than 300** increment operations.\n\n- ($4$ points): $n \\leq 100$;\n- ($6$ points): $n = k^2$ for some integer $1 \\le k \\le 100$;\n- ($10$ points): $n = (2^k - 1)$ for some integer $k$;\n- ($13$ points): $n$ is a Fibonacci number (i.e., $n$ is an element of the sequence where each element is the sum of the two previous ones: $1, 1, 2, 3, 5, 8, 13, 21, 34, \\dots$);\n- (up to $67$ points): without additional restrictions. Let the maximum number of increment operations used be $c$. If $c \\le 300$, you will receive $67$ points, otherwise you will receive ($17 + \\left \\lfloor \\frac{2000 - c}{34} \\right \\rfloor$) points.\n\nThe $\\tt{C++}$ code that calculates the number of points for the last test block depending on the number of increment operations used is:\n\n```cpp\n((c <= 300) ? 67 : (17 + (2000 - c) / 34))\n```", "locale": "en", "translations": {"en": {"title": "[UOI 2023] An Array and Addition Again", "background": "", "description": "Given an array $a$ with elements numbered from $1$ to $100$. Initially, $a_i = 0$ for $1 \\leq i < 100$, and the last element $a_{100}$ is equal to $1$.\n\nThe array $a$ can be modified using **increment operations**. To perform $m$ **increment operations**, it is necessary to select $m$ integers $p_1, p_2, \\dots, p_m$ ($1\\le p_i < 100$) and sequentially execute assignments $a_{p_i} \\leftarrow (a_{p_i} + a_{p_i + 1})$ for $i$ from $1$ to $m$.\n\nGiven an integer $n$, find the sequence of **increment operations** after which the element at the first position in array $a$ becomes equal to $n$.", "inputFormat": "The first line contains two integers $t$ and $g$ ($1 \\le t \\le 100$, $0 \\leq g \\leq 5$) --- the number of input sets and the test block number, respectively.\n\nIn the next $t$ lines, there is a single integer $n$ ($1 \\le n \\le 10^{18}$) --- the value that $a_1$ should be equal to after performing the **increment operations** in the corresponding set.", "outputFormat": "For each set of input data, output one integer $m$ ($0 \\leq m \\leq 2000$) in the first line --- the number of **increase operations**.\n\nIn the second line, output $m$ integers $p_i$ ($1 \\le p_i < 100$) --- the parameters of the **increase operations**.\n\nIf there are multiple correct answers, you can output any of them.", "hint": "For clarity, the examples of the input data in the problem statement have been reduced. To obtain the correct answer, replace $\\tt{...}$ with the sequence of integers from $97$ to $8$.\n\nLet's consider the second set of input data for the second example, where $n = 16$. The first 8 elements of the array $a$ after performing the next operation look as follows:\n\n- $p_1$ = 99, $a = [0, 0, 0, 0, 0, 0, 0, 0, \\ldots, 0, 0, 1, 1]$;\n- $p_2$ = 98, $a = [0, 0, 0, 0, 0, 0, 0, 0, \\ldots, 0, 1, 1, 1]$;\n- $\\ldots$\n- $p_{93} = 7$, $a = [0, 0, 0, 0, 0, 0, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{94} = 6$, $a = [0, 0, 0, 0, 0, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{95} = 5$, $a = [0, 0, 0, 0, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{96} = 4$, $a = [0, 0, 0, 1, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{97} = 4$, $a = [0, 0, 0, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{98} = 3$, $a = [0, 0, 2, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{99} = 3$, $a = [0, 0, 4, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{100} = 2$, $a = [0, 4, 4, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{101} = 2$, $a = [0, 8, 4, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{102} = 1$, $a = [8, 8, 4, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$;\n- $p_{103} = 1$, $a = [16, 8, 4, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$.\n\n### Scoring\n\nThe first four test blocks allow using **no more than 300** increment operations.\n\n- ($4$ points): $n \\leq 100$;\n- ($6$ points): $n = k^2$ for some integer $1 \\le k \\le 100$;\n- ($10$ points): $n = (2^k - 1)$ for some integer $k$;\n- ($13$ points): $n$ is a Fibonacci number (i.e., $n$ is an element of the sequence where each element is the sum of the two previous ones: $1, 1, 2, 3, 5, 8, 13, 21, 34, \\dots$);\n- (up to $67$ points): without additional restrictions. Let the maximum number of increment operations used be $c$. If $c \\le 300$, you will receive $67$ points, otherwise you will receive ($17 + \\left \\lfloor \\frac{2000 - c}{34} \\right \\rfloor$) points.\n\nThe $\\tt{C++}$ code that calculates the number of points for the last test block depending on the number of increment operations used is:\n\n```cpp\n((c <= 300) ? 67 : (17 + (2000 - c) / 34))\n```", "locale": "en"}, "zh-CN": {"title": "[UOI 2023] An Array and Addition Again", "background": "", "description": "给定一个编号从 $1$ 到 $100$ 的数组 $a$。初始时，对于 $1 \\leq i < 100$ 有 $a_i = 0$，最后一个元素 $a_{100} = 1$。\n\n可以通过**增量操作**来修改数组 $a$。要执行 $m$ 次**增量操作**，需要选择 $m$ 个整数 $p_1, p_2, \\dots, p_m$（$1 \\le p_i < 100$），并按顺序执行赋值操作 $a_{p_i} \\leftarrow (a_{p_i} + a_{p_i + 1})$（$i$ 从 $1$ 到 $m$）。\n\n给定一个整数 $n$，找到一组**增量操作**序列，使得在执行完这些操作后，数组 $a$ 的第一个元素 $a_1$ 等于 $n$。", "inputFormat": "第一行包含两个整数 $t$ 和 $g$（$1 \\le t \\le 100$，$0 \\leq g \\leq 5$）——分别表示输入数据的组数和测试块编号。\n\n接下来的 $t$ 行，每行包含一个整数 $n$（$1 \\le n \\le 10^{18}$）——在执行完**增量操作**后，$a_1$ 应该达到的目标值。\n", "outputFormat": "对于每组输入数据，第一行输出一个整数 $m$（$0 \\leq m \\leq 2000$）——**增量操作**的次数。\n\n第二行输出 $m$ 个整数 $p_i$（$1 \\le p_i < 100$）——**增量操作**的参数。\n\n如果存在多个正确答案，输出任意一个均可。", "hint": "为了清晰起见，题目描述中的输入样例已被简化。要得到正确答案，请将 $\\tt{...}$ 替换为从 $97$ 到 $8$ 的整数序列。\n\n以第二个样例的第二组输入数据为例，其中 $n = 16$。在执行以下操作后，数组 $a$ 的前 $8$ 个元素的变化如下：\n\n- $p_1 = 99$，$a = [0, 0, 0, 0, 0, 0, 0, 0, \\ldots, 0, 0, 1, 1]$；\n- $p_2 = 98$，$a = [0, 0, 0, 0, 0, 0, 0, 0, \\ldots, 0, 1, 1, 1]$；\n- $\\ldots$\n- $p_{93} = 7$，$a = [0, 0, 0, 0, 0, 0, 1, 1, \\ldots, 1, 1, 1, 1]$；\n- $p_{94} = 6$，$a = [0, 0, 0, 0, 0, 1, 1, 1, \\ldots, 1, 1, 1, 1]$；\n- $p_{95} = 5$，$a = [0, 0, 0, 0, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$；\n- $p_{96} = 4$，$a = [0, 0, 0, 1, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$；\n- $p_{97} = 4$，$a = [0, 0, 0, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$；\n- $p_{98} = 3$，$a = [0, 0, 2, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$；\n- $p_{99} = 3$，$a = [0, 0, 4, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$；\n- $p_{100} = 2$，$a = [0, 4, 4, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$；\n- $p_{101} = 2$，$a = [0, 8, 4, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$；\n- $p_{102} = 1$，$a = [8, 8, 4, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$；\n- $p_{103} = 1$，$a = [16, 8, 4, 2, 1, 1, 1, 1, \\ldots, 1, 1, 1, 1]$。\n\n### 评分标准\n\n前四个测试块允许使用**不超过 300 次**增量操作。\n\n- （$4$ 分）：$n \\leq 100$；\n- （$6$ 分）：$n = k^2$，其中 $1 \\le k \\le 100$；\n- （$10$ 分）：$n = (2^k - 1)$，其中 $k$ 为整数；\n- （$13$ 分）：$n$ 是斐波那契数（即 $n$ 属于序列 $1, 1, 2, 3, 5, 8, 13, 21, 34, \\dots$）；\n- （最多 $67$ 分）：无额外限制。设使用的增量操作次数为 $c$。如果 $c \\le 300$，得 $67$ 分；否则得 $(17 + \\left \\lfloor \\frac{2000 - c}{34} \\right \\rfloor)$ 分。\n\n用于计算最后一个测试块得分的 $\\tt{C++}$ 代码如下：\n\n```cpp\n((c <= 300) ? 67 : (17 + (2000 - c) / 34))\n```\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12573", "type": "P", "difficulty": 6, "samples": [["5 5 3\n1 3 2 7 1\n1 5\n2 3\n3 4\n1 3\n1 1", "3\n6\n3\n5\n7"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "UOI（乌克兰）"], "title": "[UOI 2023] An Array and XOR", "background": "", "description": "Given an integer $m$, an array $a$ of non-negative integers of length $n$, and $q$ queries of the form $l_i$, $r_i$. All elements of array $a$ are less than $2^m$.\n\nLet us define the function $f_i(x) = \\min_{j \\in [l_i, r_i]} (a_j \\oplus x)$, where $\\oplus$ denotes the bitwise exclusive OR operation. For each query, you need to find the value $\\max_{x \\in \\{0, 1, \\ldots, 2^m-1\\}} f_i(x)$.\n\nBitwise exclusive OR of non-negative integers $a$ and $b$ $(a \\oplus b)$ equals a non-negative integer that has a 1 in a certain position in its binary representation if and only if the binary representations of $a$ and $b$ have different values in that position. For example, $3_{10} \\oplus 5_{10} = 0011_{2} \\oplus 0101_{2} = 0110_{2} = 6_{10}$.", "inputFormat": "The first line contains three integers $n$, $q$, $m$ ($1 \\le n \\le 10^5$, $1 \\le q \\le 5 \\cdot 10^5$, $1 \\le m \\le 50$), representing the length of the array, the number of queries, and the limit on the elements of the array, respectively.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i < 2^m$), representing the elements of the array.\n\nThe following $q$ lines each contain two integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$), representing the parameters of the $i$-th query.", "outputFormat": "For each $i$-th query, output a single integer on a separate line --- the value of $\\max_{x \\in \\{0, 1, \\ldots, 2^m-1\\}} f_i(x)$.", "hint": "The first query. \n\n$f_1(0)=\\min(1 \\oplus 0, 3 \\oplus 0, 2 \\oplus 0, 7 \\oplus 0, 1 \\oplus 0)=\\min(1, 3, 2, 7, 1)=1$\n\n$f_1(1)=\\min(1 \\oplus 1, 3 \\oplus 1, 2 \\oplus 1, 7 \\oplus 1, 1 \\oplus 1)=\\min(0, 2, 3, 6, 0)=0$\n\n$f_1(2)=\\min(1 \\oplus 2, 3 \\oplus 2, 2 \\oplus 2, 7 \\oplus 2, 1 \\oplus 2)=\\min(3, 1, 0, 5, 3)=0$\n\n$f_1(3)=\\min(1 \\oplus 3, 3 \\oplus 3, 2 \\oplus 3, 7 \\oplus 3, 1 \\oplus 3)=\\min(2, 0, 1, 4, 2)=0$\n\n$f_1(4)=\\min(1 \\oplus 4, 3 \\oplus 4, 2 \\oplus 4, 7 \\oplus 4, 1 \\oplus 4)=\\min(5, 7, 6, 3, 5)=3$\n\n$f_1(5)=\\min(1 \\oplus 5, 3 \\oplus 5, 2 \\oplus 5, 7 \\oplus 5, 1 \\oplus 5)=\\min(4, 6, 7, 2, 4)=2$\n\n$f_1(6)=\\min(1 \\oplus 6, 3 \\oplus 6, 2 \\oplus 6, 7 \\oplus 6, 1 \\oplus 6)=\\min(7, 5, 4, 1, 7)=1$\n\n$f_1(7)=\\min(1 \\oplus 7, 3 \\oplus 7, 2 \\oplus 7, 7 \\oplus 7, 1 \\oplus 7)=\\min(6, 4, 5, 0, 6)=0$\n\nThe answer to this query is equal to $\\max_{x \\in \\{0, 1, \\ldots, 2^3-1\\}} f_1(x) = \\max(1, 0, 0, 0, 3, 2, 1, 0) = 3$.\n\n### Scoring\n\n- ($4$ points): $n \\le 100$, $q \\le 100$, $m \\le 10$;\n- ($17$ points): $q=1$, $l_1=1$, $r_1=n$;\n- ($16$ points): $q \\le 2 \\cdot 10^5$; $a_i \\le a_{i+1}$ for $1 \\le i < n$;\n- ($17$ points): $n\\le 10^4$, $q \\le 10^4$;\n- ($26$ points): $n \\le 5 \\cdot 10^4$, $m \\le 30$;\n- ($20$ points): no additional constraints.", "locale": "en", "translations": {"en": {"title": "[UOI 2023] An Array and XOR", "background": "", "description": "Given an integer $m$, an array $a$ of non-negative integers of length $n$, and $q$ queries of the form $l_i$, $r_i$. All elements of array $a$ are less than $2^m$.\n\nLet us define the function $f_i(x) = \\min_{j \\in [l_i, r_i]} (a_j \\oplus x)$, where $\\oplus$ denotes the bitwise exclusive OR operation. For each query, you need to find the value $\\max_{x \\in \\{0, 1, \\ldots, 2^m-1\\}} f_i(x)$.\n\nBitwise exclusive OR of non-negative integers $a$ and $b$ $(a \\oplus b)$ equals a non-negative integer that has a 1 in a certain position in its binary representation if and only if the binary representations of $a$ and $b$ have different values in that position. For example, $3_{10} \\oplus 5_{10} = 0011_{2} \\oplus 0101_{2} = 0110_{2} = 6_{10}$.", "inputFormat": "The first line contains three integers $n$, $q$, $m$ ($1 \\le n \\le 10^5$, $1 \\le q \\le 5 \\cdot 10^5$, $1 \\le m \\le 50$), representing the length of the array, the number of queries, and the limit on the elements of the array, respectively.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i < 2^m$), representing the elements of the array.\n\nThe following $q$ lines each contain two integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$), representing the parameters of the $i$-th query.", "outputFormat": "For each $i$-th query, output a single integer on a separate line --- the value of $\\max_{x \\in \\{0, 1, \\ldots, 2^m-1\\}} f_i(x)$.", "hint": "The first query. \n\n$f_1(0)=\\min(1 \\oplus 0, 3 \\oplus 0, 2 \\oplus 0, 7 \\oplus 0, 1 \\oplus 0)=\\min(1, 3, 2, 7, 1)=1$\n\n$f_1(1)=\\min(1 \\oplus 1, 3 \\oplus 1, 2 \\oplus 1, 7 \\oplus 1, 1 \\oplus 1)=\\min(0, 2, 3, 6, 0)=0$\n\n$f_1(2)=\\min(1 \\oplus 2, 3 \\oplus 2, 2 \\oplus 2, 7 \\oplus 2, 1 \\oplus 2)=\\min(3, 1, 0, 5, 3)=0$\n\n$f_1(3)=\\min(1 \\oplus 3, 3 \\oplus 3, 2 \\oplus 3, 7 \\oplus 3, 1 \\oplus 3)=\\min(2, 0, 1, 4, 2)=0$\n\n$f_1(4)=\\min(1 \\oplus 4, 3 \\oplus 4, 2 \\oplus 4, 7 \\oplus 4, 1 \\oplus 4)=\\min(5, 7, 6, 3, 5)=3$\n\n$f_1(5)=\\min(1 \\oplus 5, 3 \\oplus 5, 2 \\oplus 5, 7 \\oplus 5, 1 \\oplus 5)=\\min(4, 6, 7, 2, 4)=2$\n\n$f_1(6)=\\min(1 \\oplus 6, 3 \\oplus 6, 2 \\oplus 6, 7 \\oplus 6, 1 \\oplus 6)=\\min(7, 5, 4, 1, 7)=1$\n\n$f_1(7)=\\min(1 \\oplus 7, 3 \\oplus 7, 2 \\oplus 7, 7 \\oplus 7, 1 \\oplus 7)=\\min(6, 4, 5, 0, 6)=0$\n\nThe answer to this query is equal to $\\max_{x \\in \\{0, 1, \\ldots, 2^3-1\\}} f_1(x) = \\max(1, 0, 0, 0, 3, 2, 1, 0) = 3$.\n\n### Scoring\n\n- ($4$ points): $n \\le 100$, $q \\le 100$, $m \\le 10$;\n- ($17$ points): $q=1$, $l_1=1$, $r_1=n$;\n- ($16$ points): $q \\le 2 \\cdot 10^5$; $a_i \\le a_{i+1}$ for $1 \\le i < n$;\n- ($17$ points): $n\\le 10^4$, $q \\le 10^4$;\n- ($26$ points): $n \\le 5 \\cdot 10^4$, $m \\le 30$;\n- ($20$ points): no additional constraints.", "locale": "en"}, "zh-CN": {"title": "[UOI 2023] An Array and XOR", "background": "", "description": "给定一个整数 $m$，一个长度为 $n$ 的非负整数数组 $a$，以及 $q$ 个形如 $l_i$, $r_i$ 的查询。数组 $a$ 的所有元素都小于 $2^m$。\n\n定义函数 $f_i(x) = \\min_{j \\in [l_i, r_i]} (a_j \\oplus x)$，其中 $\\oplus$ 表示按位异或运算。对于每个查询，你需要找到 $\\max_{x \\in \\{0, 1, \\ldots, 2^m-1\\}} f_i(x)$ 的值。\n\n非负整数 $a$ 和 $b$ 的按位异或 $(a \\oplus b)$ 是一个非负整数，其二进制表示中某一位为 1 当且仅当 $a$ 和 $b$ 在该位的二进制值不同。例如，$3_{10} \\oplus 5_{10} = 0011_{2} \\oplus 0101_{2} = 0110_{2} = 6_{10}$。", "inputFormat": "第一行包含三个整数 $n$, $q$, $m$（$1 \\le n \\le 10^5$, $1 \\le q \\le 5 \\cdot 10^5$, $1 \\le m \\le 50$），分别表示数组长度、查询数量和数组元素的位数限制。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\ldots, a_n$（$0 \\le a_i < 2^m$），表示数组的元素。\n\n接下来的 $q$ 行，每行包含两个整数 $l_i$ 和 $r_i$（$1 \\le l_i \\le r_i \\le n$），表示第 $i$ 个查询的参数。", "outputFormat": "对于每个查询，输出一行一个整数——$\\max_{x \\in \\{0, 1, \\ldots, 2^m-1\\}} f_i(x)$ 的值。", "hint": "第一个查询的分析：\n\n$f_1(0)=\\min(1 \\oplus 0, 3 \\oplus 0, 2 \\oplus 0, 7 \\oplus 0, 1 \\oplus 0)=\\min(1, 3, 2, 7, 1)=1$\n\n$f_1(1)=\\min(1 \\oplus 1, 3 \\oplus 1, 2 \\oplus 1, 7 \\oplus 1, 1 \\oplus 1)=\\min(0, 2, 3, 6, 0)=0$\n\n$f_1(2)=\\min(1 \\oplus 2, 3 \\oplus 2, 2 \\oplus 2, 7 \\oplus 2, 1 \\oplus 2)=\\min(3, 1, 0, 5, 3)=0$\n\n$f_1(3)=\\min(1 \\oplus 3, 3 \\oplus 3, 2 \\oplus 3, 7 \\oplus 3, 1 \\oplus 3)=\\min(2, 0, 1, 4, 2)=0$\n\n$f_1(4)=\\min(1 \\oplus 4, 3 \\oplus 4, 2 \\oplus 4, 7 \\oplus 4, 1 \\oplus 4)=\\min(5, 7, 6, 3, 5)=3$\n\n$f_1(5)=\\min(1 \\oplus 5, 3 \\oplus 5, 2 \\oplus 5, 7 \\oplus 5, 1 \\oplus 5)=\\min(4, 6, 7, 2, 4)=2$\n\n$f_1(6)=\\min(1 \\oplus 6, 3 \\oplus 6, 2 \\oplus 6, 7 \\oplus 6, 1 \\oplus 6)=\\min(7, 5, 4, 1, 7)=1$\n\n$f_1(7)=\\min(1 \\oplus 7, 3 \\oplus 7, 2 \\oplus 7, 7 \\oplus 7, 1 \\oplus 7)=\\min(6, 4, 5, 0, 6)=0$\n\n该查询的答案为 $\\max_{x \\in \\{0, 1, \\ldots, 2^3-1\\}} f_1(x) = \\max(1, 0, 0, 0, 3, 2, 1, 0) = 3$。\n\n### 评分标准\n\n- （$4$ 分）：$n \\le 100$，$q \\le 100$，$m \\le 10$；\n- （$17$ 分）：$q=1$，$l_1=1$，$r_1=n$；\n- （$16$ 分）：$q \\le 2 \\cdot 10^5$；$a_i \\le a_{i+1}$（$1 \\le i < n$）；\n- （$17$ 分）：$n \\le 10^4$，$q \\le 10^4$；\n- （$26$ 分）：$n \\le 5 \\cdot 10^4$，$m \\le 30$；\n- （$20$ 分）：无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12574", "type": "P", "difficulty": 3, "samples": [["3\nRLL\n2", "2 1 0"], ["7\nRLLLRRL\n10", "2 2 0 0 0 1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "倍增", "2021", "UOI（乌克兰）"], "title": "[UOI 2021] 机器人", "background": "", "description": "哥萨克·武斯购买了一个非常有趣的游戏。游戏由一条包含 $n$ 个格子的带子组成，格子从左到右编号为 $1$ 到 $n$，每个格子中恰好有一个机器人。此外，每个格子上写有一个字母 $\\texttt{L}$ 或 $\\texttt{R}$。\n\n每一秒钟，所有位于标有 $\\texttt{L}$ 的格子上的机器人会向左移动一格，而位于标有 $\\texttt{R}$ 的格子上的机器人会向右移动一格。如果移动后机器人超出了带子的边界，则该机器人变为非活跃状态，并且**不再参与游戏**。\n\n哥萨克·武斯计划玩恰好 $t$ 秒。他想知道在 $t$ 秒后每个格子上会有多少个机器人。\n", "inputFormat": "第一行包含一个整数 $n$（$1 \\leq n \\leq 10^6$）——哥萨克·武斯购买的游戏中格子的数量。\n\n第二行包含 $n$ 个字符，每个字符是 $\\tt{L}$ 或 $\\tt{R}$，第 $i$ 个字符表示编号为 $i$ 的格子上的字母。\n\n第三行包含一个整数 $t$（$1 \\leq t \\leq 10^{18}$）——游戏持续的秒数。", "outputFormat": "输出 $n$ 个数字，第 $i$ 个数字表示 $t$ 秒后编号为 $i$ 的格子上的机器人数量。\n", "hint": "在第一个样例中，经过一秒后的答案是 $[1, 2, 0]$：第一个格子的机器人移动到第二个格子，第二个格子的机器人移动到第一个格子，第三个格子的机器人移动到第二个格子。再经过一秒后，答案是 $[2, 1, 0]$：第一个格子的机器人移动到第二个格子，第二个格子的两个机器人移动到第一个格子。\n\n### 评分标准\n\n1. （$17$ 分）：$1 \\leq n, t \\leq 10^3$；\n2. （$34$ 分）：$1 \\leq n \\leq 10^3$；\n3. （$49$ 分）：无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[UOI 2021] 机器人", "background": "", "description": "哥萨克·武斯购买了一个非常有趣的游戏。游戏由一条包含 $n$ 个格子的带子组成，格子从左到右编号为 $1$ 到 $n$，每个格子中恰好有一个机器人。此外，每个格子上写有一个字母 $\\texttt{L}$ 或 $\\texttt{R}$。\n\n每一秒钟，所有位于标有 $\\texttt{L}$ 的格子上的机器人会向左移动一格，而位于标有 $\\texttt{R}$ 的格子上的机器人会向右移动一格。如果移动后机器人超出了带子的边界，则该机器人变为非活跃状态，并且**不再参与游戏**。\n\n哥萨克·武斯计划玩恰好 $t$ 秒。他想知道在 $t$ 秒后每个格子上会有多少个机器人。\n", "inputFormat": "第一行包含一个整数 $n$（$1 \\leq n \\leq 10^6$）——哥萨克·武斯购买的游戏中格子的数量。\n\n第二行包含 $n$ 个字符，每个字符是 $\\tt{L}$ 或 $\\tt{R}$，第 $i$ 个字符表示编号为 $i$ 的格子上的字母。\n\n第三行包含一个整数 $t$（$1 \\leq t \\leq 10^{18}$）——游戏持续的秒数。", "outputFormat": "输出 $n$ 个数字，第 $i$ 个数字表示 $t$ 秒后编号为 $i$ 的格子上的机器人数量。\n", "hint": "在第一个样例中，经过一秒后的答案是 $[1, 2, 0]$：第一个格子的机器人移动到第二个格子，第二个格子的机器人移动到第一个格子，第三个格子的机器人移动到第二个格子。再经过一秒后，答案是 $[2, 1, 0]$：第一个格子的机器人移动到第二个格子，第二个格子的两个机器人移动到第一个格子。\n\n### 评分标准\n\n1. （$17$ 分）：$1 \\leq n, t \\leq 10^3$；\n2. （$34$ 分）：$1 \\leq n \\leq 10^3$；\n3. （$49$ 分）：无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12575", "type": "P", "difficulty": 6, "samples": [["3 3 3 2 0\n\n2\n\n5\n\n5\n\n2\n\n6\n\n6\n\n6\n\n7\n\n10", "\n1 1 1\n\n1 1 2\n\n1 1 3\n\n1 2 1\n\n1 2 2\n\n1 2 3\n\n1 3 1\n\n1 3 2\n\n1 3 3\n\n2 2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["二分", "2021", "交互题", "Special Judge", "UOI（乌克兰）"], "title": "[UOI 2021] 第 k 小的数", "background": "", "description": "这是一道交互题。\n\n哥萨克·武斯有三个秘密的正整数数组 $a$、$b$ 和 $c$。它们的长度分别为 $|a|$、$|b|$ 和 $|c|$，这些长度不一定相同。已知每个数组都是已排序的，即每个后续元素都不小于前一个元素。\n\n你想获取关于这些数组的特定信息——即在三个数组合并后的排序数组中第 $k$ 小的元素值。也就是说，如果将这三个数组合并成一个长度为 $|a|+|b|+|c|$ 的大数组并从小到大排序，你需要找出排序后数组中的第 $k$ 个元素。\n\n哥萨克·武斯拒绝直接展示这些数组给你。但他同意以下交互方式：你可以查询特定数组中的特定位置的元素值。你可以选择一个数组和一个位置，哥萨克会告诉你该位置上的元素值。注意，你可以多次进行这种查询操作，且不限于同一个数组。由于哥萨克非常忙碌，他最多允许你提出 $Q$ 次查询。\n\n你的任务是找出三个数组合并后第 $k$ 小的元素。", "inputFormat": "第一行包含五个整数 $|a|$、$|b|$、$|c|$、$k$ 和 $g$（$0 \\leq |a|, |b|, |c| \\leq 10^6$，$1 \\leq k \\leq |a| + |b| + |c|$）。\n\n保证所有数组中的元素都在 $[1, 10^9]$ 范围内。\n\n整数 $g$（$0 \\leq g \\leq 9$）表示测试用例的分组编号（参见评分标准）。\n\n### 交互方式\n\n首先读取五个整数 $|a|$、$|b|$、$|c|$、$k$ 和 $g$。\n\n要发起查询，输出 `1 r m`。其中：\n- $r$ 表示数组编号（$1$ 对应数组 $a$，$2$ 对应数组 $b$，$3$ 对应数组 $c$）；\n- $m$ 表示该数组中的位置（例如，$m=1$ 表示第一个元素，$m=|a|$ 表示最后一个元素）。\n\n示例查询 `1 3 10` 表示获取数组 $c$ 的第 $10$ 个元素。\n\n每次查询后，必须换行并刷新输出缓冲区，否则会得到 \"超出时间限制\" 的判定。刷新缓冲区的方法：\n- C++: `fflush(stdout)` 或 `cout.flush()`；\n- Java: `System.out.flush()`；\n- Pascal: `flush(output)`；\n- Python: `stdout.flush()`；\n其他语言请参考相关文档。\n\n注意：如果查询无效（超出查询限制或不满足约束条件），交互器会输出 `-1` 并终止程序。如果读取到 `-1`，请立即终止程序以避免不可预期的判定结果。\n\n当你确定答案 $x$ 时，输出 `2 x`。", "outputFormat": "见交互方式。", "hint": "### 评分标准\n\n设 $n = \\max(|a|, |b|, |c|)$，$m = \\max(a_i, b_j, c_t)$。\n\n1. （$6$ 分）：$n \\leq 10$，$Q = 150$；\n2. （$4$ 分）：$|b|=0$，$|c|=0$，$m \\leq 2$，$Q = 150$；\n3. （$9$ 分）：$|c|=0$，$m \\leq 2$，$Q = 125$；\n4. （$10$ 分）：$m \\leq 2$，$Q = 125$；\n5. （$13$ 分）：$|c|=0$，$Q = 1000$；\n6. （$13$ 分）：$|c|=0$，$Q = 125$；\n7. （$17$ 分）：$Q = 1000$；\n8. （$21$ 分）：$Q = 125$；\n9. （$7$ 分）：$Q = 65$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[UOI 2021] 第 k 小的数", "background": "", "description": "这是一道交互题。\n\n哥萨克·武斯有三个秘密的正整数数组 $a$、$b$ 和 $c$。它们的长度分别为 $|a|$、$|b|$ 和 $|c|$，这些长度不一定相同。已知每个数组都是已排序的，即每个后续元素都不小于前一个元素。\n\n你想获取关于这些数组的特定信息——即在三个数组合并后的排序数组中第 $k$ 小的元素值。也就是说，如果将这三个数组合并成一个长度为 $|a|+|b|+|c|$ 的大数组并从小到大排序，你需要找出排序后数组中的第 $k$ 个元素。\n\n哥萨克·武斯拒绝直接展示这些数组给你。但他同意以下交互方式：你可以查询特定数组中的特定位置的元素值。你可以选择一个数组和一个位置，哥萨克会告诉你该位置上的元素值。注意，你可以多次进行这种查询操作，且不限于同一个数组。由于哥萨克非常忙碌，他最多允许你提出 $Q$ 次查询。\n\n你的任务是找出三个数组合并后第 $k$ 小的元素。", "inputFormat": "第一行包含五个整数 $|a|$、$|b|$、$|c|$、$k$ 和 $g$（$0 \\leq |a|, |b|, |c| \\leq 10^6$，$1 \\leq k \\leq |a| + |b| + |c|$）。\n\n保证所有数组中的元素都在 $[1, 10^9]$ 范围内。\n\n整数 $g$（$0 \\leq g \\leq 9$）表示测试用例的分组编号（参见评分标准）。\n\n### 交互方式\n\n首先读取五个整数 $|a|$、$|b|$、$|c|$、$k$ 和 $g$。\n\n要发起查询，输出 `1 r m`。其中：\n- $r$ 表示数组编号（$1$ 对应数组 $a$，$2$ 对应数组 $b$，$3$ 对应数组 $c$）；\n- $m$ 表示该数组中的位置（例如，$m=1$ 表示第一个元素，$m=|a|$ 表示最后一个元素）。\n\n示例查询 `1 3 10` 表示获取数组 $c$ 的第 $10$ 个元素。\n\n每次查询后，必须换行并刷新输出缓冲区，否则会得到 \"超出时间限制\" 的判定。刷新缓冲区的方法：\n- C++: `fflush(stdout)` 或 `cout.flush()`；\n- Java: `System.out.flush()`；\n- Pascal: `flush(output)`；\n- Python: `stdout.flush()`；\n其他语言请参考相关文档。\n\n注意：如果查询无效（超出查询限制或不满足约束条件），交互器会输出 `-1` 并终止程序。如果读取到 `-1`，请立即终止程序以避免不可预期的判定结果。\n\n当你确定答案 $x$ 时，输出 `2 x`。", "outputFormat": "见交互方式。", "hint": "### 评分标准\n\n设 $n = \\max(|a|, |b|, |c|)$，$m = \\max(a_i, b_j, c_t)$。\n\n1. （$6$ 分）：$n \\leq 10$，$Q = 150$；\n2. （$4$ 分）：$|b|=0$，$|c|=0$，$m \\leq 2$，$Q = 150$；\n3. （$9$ 分）：$|c|=0$，$m \\leq 2$，$Q = 125$；\n4. （$10$ 分）：$m \\leq 2$，$Q = 125$；\n5. （$13$ 分）：$|c|=0$，$Q = 1000$；\n6. （$13$ 分）：$|c|=0$，$Q = 125$；\n7. （$17$ 分）：$Q = 1000$；\n8. （$21$ 分）：$Q = 125$；\n9. （$7$ 分）：$Q = 65$。", "locale": "zh-CN"}}}
{"pid": "P12576", "type": "P", "difficulty": 6, "samples": [["4 4\n1 10 4 5\n1 2\n2 3\n2 4\n3 1", "4"], ["2 2\n1 2\n1 2\n2 1", "1"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["博弈论", "2021", "拓扑排序", "UOI（乌克兰）"], "title": "[UOI 2021] 数字图", "background": "", "description": "瓦西里和彼得里克发现了一个数字图——这是一个连通的有向图，每个顶点上都标有一个数字。\n\n两人急需一个数字，于是决定在图上游玩一个游戏。他们将棋子放在编号为 1 的顶点上。每一回合可以选择以下两种操作之一：\n1. 结束游戏并获得当前顶点上的数字；\n2. 沿着有向边将棋子移动到相邻顶点。\n\n如果游戏进行到 $10^{100}$ 回合仍未结束，则自动终止并获得当前顶点上的数字。\n\n瓦西里先手，他希望最大化最终获得的数字；而彼得里克则希望最小化这个数字。假设双方都采取最优策略，求游戏结束时他们将获得的数字。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$（$1 \\leq n \\leq 250\\,000$，$1 \\leq m \\leq 500\\,000$）——分别表示图的顶点数和边数。\n\n第二行包含 $n$ 个整数 $a_i$（$1 \\leq a_i \\leq 10^9$）——表示每个顶点上的数字。\n\n接下来的 $m$ 行，每行包含两个整数 $x$ 和 $y$（$1 \\leq x, y \\leq n$），表示存在一条从顶点 $x$ 指向 $y$ 的有向边。", "outputFormat": "输出一个整数，表示在双方都采取最优策略时，游戏结束时获得的数字。", "hint": "第一个样例的图示如图 1 所示，顶点标注格式为\"顶点编号（数字）\"：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ssfvk5ca.png)\n1. 瓦西里先手，可以选择立即结束游戏或移动到顶点 2。最优选择是移动。\n2. 彼得里克回合，最优选择是移动到顶点 3。\n3. 最后如果瓦西里移动到顶点 1，彼得里克会结束游戏获得数字 1，因此瓦西里会选择直接结束游戏获得数字 4。\n\n第二个样例的图示如图 2 所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9crldhqu.png)\n\n双方将交替移动 $10^{100}$ 步，最终棋子停留在顶点 1。\n\n### 评分标准\n\n1. （$6$ 分）给定的图是一条所有边同向的直线；\n2. （$8$ 分）给定的图是一棵以顶点 1 为根的树，所有边方向从根向下；\n3. （$14$ 分）给定的图是一个环；\n4. （$26$ 分）$1 \\leq a_i \\leq 2$；\n5. （$46$ 分）无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[UOI 2021] 数字图", "background": "", "description": "瓦西里和彼得里克发现了一个数字图——这是一个连通的有向图，每个顶点上都标有一个数字。\n\n两人急需一个数字，于是决定在图上游玩一个游戏。他们将棋子放在编号为 1 的顶点上。每一回合可以选择以下两种操作之一：\n1. 结束游戏并获得当前顶点上的数字；\n2. 沿着有向边将棋子移动到相邻顶点。\n\n如果游戏进行到 $10^{100}$ 回合仍未结束，则自动终止并获得当前顶点上的数字。\n\n瓦西里先手，他希望最大化最终获得的数字；而彼得里克则希望最小化这个数字。假设双方都采取最优策略，求游戏结束时他们将获得的数字。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$（$1 \\leq n \\leq 250\\,000$，$1 \\leq m \\leq 500\\,000$）——分别表示图的顶点数和边数。\n\n第二行包含 $n$ 个整数 $a_i$（$1 \\leq a_i \\leq 10^9$）——表示每个顶点上的数字。\n\n接下来的 $m$ 行，每行包含两个整数 $x$ 和 $y$（$1 \\leq x, y \\leq n$），表示存在一条从顶点 $x$ 指向 $y$ 的有向边。", "outputFormat": "输出一个整数，表示在双方都采取最优策略时，游戏结束时获得的数字。", "hint": "第一个样例的图示如图 1 所示，顶点标注格式为\"顶点编号（数字）\"：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ssfvk5ca.png)\n1. 瓦西里先手，可以选择立即结束游戏或移动到顶点 2。最优选择是移动。\n2. 彼得里克回合，最优选择是移动到顶点 3。\n3. 最后如果瓦西里移动到顶点 1，彼得里克会结束游戏获得数字 1，因此瓦西里会选择直接结束游戏获得数字 4。\n\n第二个样例的图示如图 2 所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9crldhqu.png)\n\n双方将交替移动 $10^{100}$ 步，最终棋子停留在顶点 1。\n\n### 评分标准\n\n1. （$6$ 分）给定的图是一条所有边同向的直线；\n2. （$8$ 分）给定的图是一棵以顶点 1 为根的树，所有边方向从根向下；\n3. （$14$ 分）给定的图是一个环；\n4. （$26$ 分）$1 \\leq a_i \\leq 2$；\n5. （$46$ 分）无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12577", "type": "P", "difficulty": 6, "samples": [["5\n1 7\n1 3\n2 2\n2 1\n1 1 2 3 3\n10 4 15 15 1\n8\n5 3 3 1\n5 3 3 2\n5 3 3 3\n5 3 1 1\n4 3 1 2\n4 3 1 3\n3 4 1 3\n2 1 1 100", "-1\n1\n2\n5\n-1\n3\n4\n-1"], ["5\n1 4\n1 1\n1 1\n1 4\n3 2 2 2 2\n4 4 6 7 5\n5\n5 2 4 7\n1 1 1 3\n4 2 1 9\n1 4 3 7\n3 4 2 4", "5\n-1\n4\n4\n1"], ["5\n1 4\n2 1\n3 3\n4 1\n2 1 2 3 2\n8 3 7 7 9\n5\n1 5 2 4\n1 2 1 4\n5 2 1 6\n1 4 3 5\n1 5 4 7", "2\n-1\n4\n2\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["线段树", "2021", "树链剖分", "UOI（乌克兰）"], "title": "[UOI 2021] 树上的强盗", "background": "", "description": "有 $n$ 个城市，编号从 $1$ 到 $n$。所有城市通过 $n-1$ 条道路连接，形成一个连通图。每条道路都有特定的长度。\n\n已知编号为 $i$ 的城市在时间 $t_i$ 被编号为 $a_i$ 的强盗团伙占领（$1 \\leq a_i \\leq n$）。从被占领的时刻 $t_i$ 开始（包括 $t_i$ 时刻），只有 $a_i$ 号团伙的成员才能通过该城市。\n\n你需要回答 $m$ 个如下形式的查询：\n\n- `u v b T`：判断编号为 $b$ 的团伙成员能否在时间 $T$ 从城市 $u$ 前往城市 $v$。如果无法完成旅程，还需要输出路径上第一个无法通过的城市编号。在城市间移动需要花费时间，时间等于路的长度。\n", "inputFormat": "第一行包含一个整数 $n$（$2 \\leq n \\leq 10^5$）——城市数量。\n\n接下来的 $n-1$ 行，每行包含两个整数 $p_i$ 和 $d_i$（$1 \\leq p_i < i$，$1 \\leq d_i \\leq 10^3$），表示城市 $i$ 和 $p_i$ 之间有一条长度为 $d_i$ 的道路。编号从 2 开始。\n\n下一行包含 $n$ 个整数 $a_i$（$1 \\leq a_i \\leq n$），表示占领每个城市的强盗团伙编号。\n\n下一行包含 $n$ 个整数 $t_i$（$1 \\leq t_i \\leq 10^9$），表示每个城市被占领的时间。\n\n下一行包含一个整数 $m$（$1 \\leq m \\leq 10^5$）——查询数量。\n\n最后 $m$ 行，每行包含四个整数 $u_i$, $v_i$, $b_i$, $T_i$（$1 \\leq u_i, v_i, b_i \\leq n$，$1 \\leq T_i \\leq 10^9$），分别表示查询的起点城市、终点城市、团伙编号和出发时间。\n", "outputFormat": "对于每个查询，输出一行一个整数——路径上第一个无法通过的城市编号。如果全程可通行，输出 `-1`。\n\n注意本题输入输出数据量较大，建议使用快速的输入输出方法，例如：\n- C++ 中使用 `scanf/printf` 而非 `cin/cout`；\n- Python 中使用 `sys.stdin.readline` 而非 `input`；\n- 建议使用 PyPy 解释器运行 Python 代码。", "hint": "### 评分标准\n\n1. （$7$ 分）：所有 $p_i = 1$；\n2. （$9$ 分）：$n, m \\leq 10^3$；\n3. （$11$ 分）：$p_i = i-1$，$t_i = 1$；\n4. （$18$ 分）：$p_i = i-1$，$a_i = 1$，$b_i = 2$；\n5. （$15$ 分）：$p_i = i-1$；\n6. （$11$ 分）：$t_i = 1$；\n7. （$17$ 分）：$a_i = 1$，$b_i = 2$；\n8. （$12$ 分）：无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[UOI 2021] 树上的强盗", "background": "", "description": "有 $n$ 个城市，编号从 $1$ 到 $n$。所有城市通过 $n-1$ 条道路连接，形成一个连通图。每条道路都有特定的长度。\n\n已知编号为 $i$ 的城市在时间 $t_i$ 被编号为 $a_i$ 的强盗团伙占领（$1 \\leq a_i \\leq n$）。从被占领的时刻 $t_i$ 开始（包括 $t_i$ 时刻），只有 $a_i$ 号团伙的成员才能通过该城市。\n\n你需要回答 $m$ 个如下形式的查询：\n\n- `u v b T`：判断编号为 $b$ 的团伙成员能否在时间 $T$ 从城市 $u$ 前往城市 $v$。如果无法完成旅程，还需要输出路径上第一个无法通过的城市编号。在城市间移动需要花费时间，时间等于路的长度。\n", "inputFormat": "第一行包含一个整数 $n$（$2 \\leq n \\leq 10^5$）——城市数量。\n\n接下来的 $n-1$ 行，每行包含两个整数 $p_i$ 和 $d_i$（$1 \\leq p_i < i$，$1 \\leq d_i \\leq 10^3$），表示城市 $i$ 和 $p_i$ 之间有一条长度为 $d_i$ 的道路。编号从 2 开始。\n\n下一行包含 $n$ 个整数 $a_i$（$1 \\leq a_i \\leq n$），表示占领每个城市的强盗团伙编号。\n\n下一行包含 $n$ 个整数 $t_i$（$1 \\leq t_i \\leq 10^9$），表示每个城市被占领的时间。\n\n下一行包含一个整数 $m$（$1 \\leq m \\leq 10^5$）——查询数量。\n\n最后 $m$ 行，每行包含四个整数 $u_i$, $v_i$, $b_i$, $T_i$（$1 \\leq u_i, v_i, b_i \\leq n$，$1 \\leq T_i \\leq 10^9$），分别表示查询的起点城市、终点城市、团伙编号和出发时间。\n", "outputFormat": "对于每个查询，输出一行一个整数——路径上第一个无法通过的城市编号。如果全程可通行，输出 `-1`。\n\n注意本题输入输出数据量较大，建议使用快速的输入输出方法，例如：\n- C++ 中使用 `scanf/printf` 而非 `cin/cout`；\n- Python 中使用 `sys.stdin.readline` 而非 `input`；\n- 建议使用 PyPy 解释器运行 Python 代码。", "hint": "### 评分标准\n\n1. （$7$ 分）：所有 $p_i = 1$；\n2. （$9$ 分）：$n, m \\leq 10^3$；\n3. （$11$ 分）：$p_i = i-1$，$t_i = 1$；\n4. （$18$ 分）：$p_i = i-1$，$a_i = 1$，$b_i = 2$；\n5. （$15$ 分）：$p_i = i-1$；\n6. （$11$ 分）：$t_i = 1$；\n7. （$17$ 分）：$a_i = 1$，$b_i = 2$；\n8. （$12$ 分）：无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12578", "type": "P", "difficulty": 5, "samples": [["2 2 1", "2\n0 1\n1 0"], ["4 4 2", "4\n0 2 3 1\n0 1 3 2\n3 1 0 2\n3 2 0 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "Special Judge", "构造", "Ad-hoc", "UOI（乌克兰）"], "title": "[UOI 2021] 彩色矩阵", "background": "", "description": "给定一个 $n \\times m$ 的网格，即包含 $n$ 行和 $m$ 列。\n\n哥萨克 Vus 希望用最少数量的颜色为单元格着色。但他要求不存在两个颜色相同的单元格，且它们之间的曼哈顿距离等于 $k$。\n\n两个单元格 $(x_1, y_1)$ 和 $(x_2, y_2)$ 之间的曼哈顿距离为 $|x_1 - x_2| + |y_1 - y_2|$。\n\n请找到所需的最少颜色数量，并输出着色后的网格。", "inputFormat": "第一行包含三个整数 $n$、$m$、$k$（$1 \\leq n, m, k \\leq 100$，$k < \\min(n, m)$）——分别表示行数、列数以及固定的曼哈顿距离。\n", "outputFormat": "第一行输出所需的最少颜色数量 $t$。\n\n接下来的 $n$ 行中，每行输出 $m$ 个数字——表示表格中对应单元格的颜色编号（$0 \\leq c_{i,j} \\leq t-1$）。\n\n如果有多种可能的表格，可以输出其中任意一种。", "hint": "### 说明\n\n在第一个示例中，位置 $(1,1)$ 和 $(2,2)$ 的颜色为 $0$，而位置 $(1,2)$ 和 $(2,1)$ 的颜色为 $1$。位置 $(1,1)$ 和 $(1,2)$ 之间的曼哈顿距离为 $|1-1| + |1-2| = 1$。由于 $k=1$，这两个位置必须使用不同的颜色。而位置 $(1,2)$ 和 $(2,1)$ 之间的距离为 $|1-2| + |2-1| = 2$，因此它们可以使用相同的颜色。\n\n### 评分标准\n\n- （17 分）：$k=1$；\n- （18 分）：$k=2$；\n- （14 分）：$k=3$；\n- （13 分）：$k=4$；\n- （24 分）：$k$ 为奇数；\n- （14 分）：无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[UOI 2021] 彩色矩阵", "background": "", "description": "给定一个 $n \\times m$ 的网格，即包含 $n$ 行和 $m$ 列。\n\n哥萨克 Vus 希望用最少数量的颜色为单元格着色。但他要求不存在两个颜色相同的单元格，且它们之间的曼哈顿距离等于 $k$。\n\n两个单元格 $(x_1, y_1)$ 和 $(x_2, y_2)$ 之间的曼哈顿距离为 $|x_1 - x_2| + |y_1 - y_2|$。\n\n请找到所需的最少颜色数量，并输出着色后的网格。", "inputFormat": "第一行包含三个整数 $n$、$m$、$k$（$1 \\leq n, m, k \\leq 100$，$k < \\min(n, m)$）——分别表示行数、列数以及固定的曼哈顿距离。\n", "outputFormat": "第一行输出所需的最少颜色数量 $t$。\n\n接下来的 $n$ 行中，每行输出 $m$ 个数字——表示表格中对应单元格的颜色编号（$0 \\leq c_{i,j} \\leq t-1$）。\n\n如果有多种可能的表格，可以输出其中任意一种。", "hint": "### 说明\n\n在第一个示例中，位置 $(1,1)$ 和 $(2,2)$ 的颜色为 $0$，而位置 $(1,2)$ 和 $(2,1)$ 的颜色为 $1$。位置 $(1,1)$ 和 $(1,2)$ 之间的曼哈顿距离为 $|1-1| + |1-2| = 1$。由于 $k=1$，这两个位置必须使用不同的颜色。而位置 $(1,2)$ 和 $(2,1)$ 之间的距离为 $|1-2| + |2-1| = 2$，因此它们可以使用相同的颜色。\n\n### 评分标准\n\n- （17 分）：$k=1$；\n- （18 分）：$k=2$；\n- （14 分）：$k=3$；\n- （13 分）：$k=4$；\n- （24 分）：$k$ 为奇数；\n- （14 分）：无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12579", "type": "P", "difficulty": 6, "samples": [["5 3\n20 40 9 25 15\n3 10\n5 21\n4 135", "5\n25\n9\n11"], ["4 2\n20 4 8 36\n1 2\n4 18", "16\n8\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["线段树", "2021", "生成树", "最大公约数 gcd", "UOI（乌克兰）"], "title": "[UOI 2021] 哥萨克与 GCD", "background": "", "description": "哥萨克 Vus 得到了一个包含 $n$ 个整数的数组 $a$。随后，他被告知存在另一个同样由 $n$ 个整数组成的数组 $b$，但具体内容未知。为了确定数组 $b$，哥萨克可以无限次使用以下操作\n  - 选择两个整数 $1 \\leq l \\leq r \\leq n$。\n  - 查询 $b_l + b_{l + 1} + \\dots + b_r$ 的和。\n  - 支付 $\\gcd(a_l, a_{l+1}, ..., a_r)$ 戈比，其中 $\\gcd$ 表示最大公约数（例如 $\\gcd(3, 5) = 1$，而 $\\gcd(15, 30, 6) = 3$）。\n\nVus 需要你求出确定数组 $b$ 所需的最小戈比数。\n\n随后，哥萨克会对数组 $a$ 进行 $q$ 次修改，每次将某个 $a_i$ 改为 $x$。每次修改后，你需要重新计算更新后的数组所需的最小戈比数。", "inputFormat": "第一行包含两个整数 $n$ 和 $q$ $(1 \\leq n \\leq 10^5, 0 \\leq q \\leq 10^5)$ —— 分别表示数组 $a$ 的长度和修改次数。\n\n第二行包含 $n$ 个整数 $a_1, a_2, ..., a_n$ $(1 \\leq a_i \\leq 10^9)$ —— 数组 $a$ 的初始元素。\n\n接下来的 $q$ 行，每行包含两个整数 $i$ 和 $x$ $(1 \\leq i \\leq n, 1 \\leq x \\leq 10^9)$ —— 表示修改的位置和修改后的值。", "outputFormat": "输出 $q + 1$ 个数字 —— 分别对应初始数组和每次修改后的数组所需的最小戈比数。\n\n第一个数字是初始数组 $a$ 的答案。\n\n接下来的 $q$ 个数字是每次修改后的答案。", "hint": "### 评分标准\n\n- （8 分）：$n \\le 10^2, q = 0$；\n- （7 分）：$n \\le 10^3, q = 0$；\n- （11 分）：$q = 0$；\n- （12 分）：$q \\leq 100$；\n- （9 分）：$q \\leq 500$；\n- （23 分）：$q \\leq 10000$；\n- （30 分）：无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[UOI 2021] 哥萨克与 GCD", "background": "", "description": "哥萨克 Vus 得到了一个包含 $n$ 个整数的数组 $a$。随后，他被告知存在另一个同样由 $n$ 个整数组成的数组 $b$，但具体内容未知。为了确定数组 $b$，哥萨克可以无限次使用以下操作\n  - 选择两个整数 $1 \\leq l \\leq r \\leq n$。\n  - 查询 $b_l + b_{l + 1} + \\dots + b_r$ 的和。\n  - 支付 $\\gcd(a_l, a_{l+1}, ..., a_r)$ 戈比，其中 $\\gcd$ 表示最大公约数（例如 $\\gcd(3, 5) = 1$，而 $\\gcd(15, 30, 6) = 3$）。\n\nVus 需要你求出确定数组 $b$ 所需的最小戈比数。\n\n随后，哥萨克会对数组 $a$ 进行 $q$ 次修改，每次将某个 $a_i$ 改为 $x$。每次修改后，你需要重新计算更新后的数组所需的最小戈比数。", "inputFormat": "第一行包含两个整数 $n$ 和 $q$ $(1 \\leq n \\leq 10^5, 0 \\leq q \\leq 10^5)$ —— 分别表示数组 $a$ 的长度和修改次数。\n\n第二行包含 $n$ 个整数 $a_1, a_2, ..., a_n$ $(1 \\leq a_i \\leq 10^9)$ —— 数组 $a$ 的初始元素。\n\n接下来的 $q$ 行，每行包含两个整数 $i$ 和 $x$ $(1 \\leq i \\leq n, 1 \\leq x \\leq 10^9)$ —— 表示修改的位置和修改后的值。", "outputFormat": "输出 $q + 1$ 个数字 —— 分别对应初始数组和每次修改后的数组所需的最小戈比数。\n\n第一个数字是初始数组 $a$ 的答案。\n\n接下来的 $q$ 个数字是每次修改后的答案。", "hint": "### 评分标准\n\n- （8 分）：$n \\le 10^2, q = 0$；\n- （7 分）：$n \\le 10^3, q = 0$；\n- （11 分）：$q = 0$；\n- （12 分）：$q \\leq 100$；\n- （9 分）：$q \\leq 500$；\n- （23 分）：$q \\leq 10000$；\n- （30 分）：无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12580", "type": "P", "difficulty": 0, "samples": [["1 256\n4\n\n0 1 1 1", "\n1 3 2 4 2\n\n2 1 4 2 3"]], "limits": {"time": [30000, 30000, 30000, 30000, 30000, 30000, 30000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "交互题", "Special Judge", "UOI（乌克兰）"], "title": "[UOI 2021] 猜排列【交互题暂未配置】", "background": "", "description": "请注意本题不寻常的时间限制。\n\n给定一个由 $n$ 个数字组成的排列（$n$ 是 2 的幂次）。排列中元素的顺序对你来说是未知的。\n\n排列是指长度为 $n$ 的整数序列，包含从 $1$ 到 $n$ 的所有数字，每个数字恰好出现一次。例如，$[1]$、$[4, 3, 5, 1, 2]$、$[3, 2, 1]$ 是排列，而 $[1, 1]$、$[4, 3, 1]$、$[2, 3, 4]$ 不是。\n\n此外，存在一种查询方式：你可以提供一个长度为 $n$ 的数组 $a$，满足 $1 \\le a_i \\le n$（注意 $a$ 不一定是排列）。作为响应，你会得到一个长度为 $n$ 的数组 $c$，其生成规则如下：\n\n```\nc = 长度为 n 的全零数组\nfor i = 1 to n:\n    if p[a[i]] > p[i]:\n         c[a[i]] += 1\n返回 c\n```\n\n你的任务是找出隐藏的排列 $p$。最大查询次数请参见“评分”部分。", "inputFormat": "第一行包含两个整数 $t$ 和 $q$（$1 \\le t, q \\le 256$）——分别是测试用例的数量和每个测试用例允许的最大查询次数。\n\n### 交互说明\n\n对于每个测试用例，首先读取一个整数 $n$（$1 \\le n \\le 1024$），表示排列 $p$ 的长度。\n\n保证 $n$ 是 2 的幂次（即存在非负整数 $k$ 使得 $2^k = n$）。\n\n要发起查询，请输出 $1\\ a_1\\ a_2 \\dots \\ a_n$（$1 \\le a_i \\le n$）。\n\n作为响应，评测系统会返回数组 $c$，其生成规则如题目描述所示，格式为 $c_1\\ c_2\\ \\dots \\ c_n$。\n\n发起查询后，请确保输出换行符并刷新输出缓冲区，否则可能触发“超出时间限制”错误。刷新缓冲区的方法如下：\n- C++：`fflush(stdout)` 或 `cout.flush()`；\n- Java：`System.out.flush()`；\n- Pascal：`flush(output)`；\n- Python：`stdout.flush()`；\n\n其他语言请参考相关文档。\n\n注意：如果你的查询无效（超过查询次数限制或数组 $a$ 不满足条件），评测系统会返回 $-1$ 并终止程序。如果读取到 $-1$，请立即终止程序以避免意外结果。\n\n当你确定排列 $p$ 后，请输出 $2\\ p_1\\ p_2 \\dots \\ p_n$。\n\n如果是最后一个测试用例，程序应终止；否则继续处理下一个测试用例。", "outputFormat": "见交互说明。", "hint": "### 说明\n\n从第一次查询可知 $p_1 < p_3 < p_4 < p_2$。\n\n因此，所求排列为 $[1, 4, 2, 3]$。\n\n### 评分\n\n$q$ 表示程序允许的最大查询次数。\n\n- （3 分）$n \\le 16$，$q=256$，$t=128$；\n- （7 分）$n \\le 32$，$q=256$，$t=128$；\n- （8 分）$n \\le 256$，$q=256$，$t=128$；\n- （14 分）$n \\le 512$，$q=256$，$t=128$；\n- （20 分）$n \\le 512$，$q=128$，$t=256$；\n- （最高 48 分）$n \\le 1024$，$q=127$，$t=256$；设 $k$ 为单个测试用例中实际使用的最大查询次数，则得分规则为：\n    - 若 $k > 127$，得 0 分；\n    - 若 $55 < k \\le 127$，得 $48 - \\lceil \\frac{24(k-55)}{37} \\rceil$ 分；\n    - 若 $k \\le 55$，得 48 分；\n    \n翻译由 DeepSeek V3 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[UOI 2021] 猜排列【交互题暂未配置】", "background": "", "description": "请注意本题不寻常的时间限制。\n\n给定一个由 $n$ 个数字组成的排列（$n$ 是 2 的幂次）。排列中元素的顺序对你来说是未知的。\n\n排列是指长度为 $n$ 的整数序列，包含从 $1$ 到 $n$ 的所有数字，每个数字恰好出现一次。例如，$[1]$、$[4, 3, 5, 1, 2]$、$[3, 2, 1]$ 是排列，而 $[1, 1]$、$[4, 3, 1]$、$[2, 3, 4]$ 不是。\n\n此外，存在一种查询方式：你可以提供一个长度为 $n$ 的数组 $a$，满足 $1 \\le a_i \\le n$（注意 $a$ 不一定是排列）。作为响应，你会得到一个长度为 $n$ 的数组 $c$，其生成规则如下：\n\n```\nc = 长度为 n 的全零数组\nfor i = 1 to n:\n    if p[a[i]] > p[i]:\n         c[a[i]] += 1\n返回 c\n```\n\n你的任务是找出隐藏的排列 $p$。最大查询次数请参见“评分”部分。", "inputFormat": "第一行包含两个整数 $t$ 和 $q$（$1 \\le t, q \\le 256$）——分别是测试用例的数量和每个测试用例允许的最大查询次数。\n\n### 交互说明\n\n对于每个测试用例，首先读取一个整数 $n$（$1 \\le n \\le 1024$），表示排列 $p$ 的长度。\n\n保证 $n$ 是 2 的幂次（即存在非负整数 $k$ 使得 $2^k = n$）。\n\n要发起查询，请输出 $1\\ a_1\\ a_2 \\dots \\ a_n$（$1 \\le a_i \\le n$）。\n\n作为响应，评测系统会返回数组 $c$，其生成规则如题目描述所示，格式为 $c_1\\ c_2\\ \\dots \\ c_n$。\n\n发起查询后，请确保输出换行符并刷新输出缓冲区，否则可能触发“超出时间限制”错误。刷新缓冲区的方法如下：\n- C++：`fflush(stdout)` 或 `cout.flush()`；\n- Java：`System.out.flush()`；\n- Pascal：`flush(output)`；\n- Python：`stdout.flush()`；\n\n其他语言请参考相关文档。\n\n注意：如果你的查询无效（超过查询次数限制或数组 $a$ 不满足条件），评测系统会返回 $-1$ 并终止程序。如果读取到 $-1$，请立即终止程序以避免意外结果。\n\n当你确定排列 $p$ 后，请输出 $2\\ p_1\\ p_2 \\dots \\ p_n$。\n\n如果是最后一个测试用例，程序应终止；否则继续处理下一个测试用例。", "outputFormat": "见交互说明。", "hint": "### 说明\n\n从第一次查询可知 $p_1 < p_3 < p_4 < p_2$。\n\n因此，所求排列为 $[1, 4, 2, 3]$。\n\n### 评分\n\n$q$ 表示程序允许的最大查询次数。\n\n- （3 分）$n \\le 16$，$q=256$，$t=128$；\n- （7 分）$n \\le 32$，$q=256$，$t=128$；\n- （8 分）$n \\le 256$，$q=256$，$t=128$；\n- （14 分）$n \\le 512$，$q=256$，$t=128$；\n- （20 分）$n \\le 512$，$q=128$，$t=256$；\n- （最高 48 分）$n \\le 1024$，$q=127$，$t=256$；设 $k$ 为单个测试用例中实际使用的最大查询次数，则得分规则为：\n    - 若 $k > 127$，得 0 分；\n    - 若 $55 < k \\le 127$，得 $48 - \\lceil \\frac{24(k-55)}{37} \\rceil$ 分；\n    - 若 $k \\le 55$，得 48 分；\n    \n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12581", "type": "P", "difficulty": 6, "samples": [["2 2\n2 4 10\n4 5 15\n1 3 50\n3 1 100", "135"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["线段树", "2021", "UOI（乌克兰）"], "title": "[UOI 2021] 敌人与军刀", "background": "", "description": "哥萨克 Vus 来到营地拜访一位朋友，这位朋友在自己的工坊里开始锻造军刀。朋友已经锻造了 $n$ 把军刀，其中第 $i$ 把军刀有两个参数——长度和锋利度，分别记为 $a_i$ 和 $b_i$，同时第 $i$ 把军刀的价格为 $cost_i$ 卢布。\n\n最近，营地里出现了 $m$ 个敌人。首领为每个敌人提供了悬赏——抓住第 $j$ 个敌人可以获得 $profit_j$ 卢布的奖励。但不同的敌人也有不同的护甲参数——厚度和强度，分别记为 $c_j$ 和 $d_j$。\n\n要抓住敌人，必须击穿他的护甲。为此需要一把军刀，其长度不小于护甲的厚度，且锋利度不小于护甲的强度。形式化地说，用第 $i$ 把军刀可以抓住第 $j$ 个敌人，当且仅当同时满足以下两个条件：$a_i \\geq c_j$ 且 $b_i \\geq d_j$。\n\n哥萨克 Vus 想知道他最多能赚取多少卢布，以便决定是否值得从事如此危险的工作，并请你帮忙。\n\n请注意，营地里可以赊账，因此哥萨克 Vus 在某些时刻可能拥有负数的卢布。此外，哥萨克 Vus 可以用同一把军刀抓住多个敌人。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$（$1 \\leq n, m \\leq 10^6$）——分别表示军刀和敌人的数量。\n\n接下来的 $n$ 行，每行包含三个整数 $a_i$、$b_i$ 和 $cost_i$（$0 \\leq a_i, b_i, cost_i \\leq 10^9$）——第 $i$ 把军刀的长度、锋利度和价格。\n\n接下来的 $m$ 行，每行包含三个整数 $c_j$、$d_j$ 和 $profit_j$（$0 \\leq c_j, d_j, profit_j \\leq 10^9$）——第 $j$ 个敌人的护甲厚度、强度和悬赏金额。", "outputFormat": "输出一个整数——哥萨克 Vus 能赚取的最大卢布数。\n", "hint": "### 评分标准\n\n- （13 分）：对于任意两个不同的敌人 $(i,j)$，要么 $c_i > c_j$，要么 $d_i > d_j$，即不存在一个敌人其护甲的两个参数均不劣于另一个敌人；$n, m \\leq 5\\,000$；\n- （10 分）：对于任意两个不同的敌人 $(i,j)$，要么 $c_i > c_j$，要么 $d_i > d_j$，即不存在一个敌人其护甲的两个参数均不劣于另一个敌人；$n, m \\leq 10^5$；\n- （13 分）：对于任意两把不同的军刀 $(i,j)$，要么 $a_i > a_j$，要么 $b_i > b_j$，即不存在一把军刀其攻击的两个参数均不劣于另一把军刀；$n, m \\leq 5\\,000$；\n- （10 分）：对于任意两把不同的军刀 $(i,j)$，要么 $a_i > a_j$，要么 $b_i > b_j$，即不存在一把军刀其攻击的两个参数均不劣于另一把军刀；$n, m \\leq 10^5$；\n- （14 分）：$n, m \\leq 5000$；\n- （23 分）：$n, m \\leq 10^5$；\n- （17 分）：无额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[UOI 2021] 敌人与军刀", "background": "", "description": "哥萨克 Vus 来到营地拜访一位朋友，这位朋友在自己的工坊里开始锻造军刀。朋友已经锻造了 $n$ 把军刀，其中第 $i$ 把军刀有两个参数——长度和锋利度，分别记为 $a_i$ 和 $b_i$，同时第 $i$ 把军刀的价格为 $cost_i$ 卢布。\n\n最近，营地里出现了 $m$ 个敌人。首领为每个敌人提供了悬赏——抓住第 $j$ 个敌人可以获得 $profit_j$ 卢布的奖励。但不同的敌人也有不同的护甲参数——厚度和强度，分别记为 $c_j$ 和 $d_j$。\n\n要抓住敌人，必须击穿他的护甲。为此需要一把军刀，其长度不小于护甲的厚度，且锋利度不小于护甲的强度。形式化地说，用第 $i$ 把军刀可以抓住第 $j$ 个敌人，当且仅当同时满足以下两个条件：$a_i \\geq c_j$ 且 $b_i \\geq d_j$。\n\n哥萨克 Vus 想知道他最多能赚取多少卢布，以便决定是否值得从事如此危险的工作，并请你帮忙。\n\n请注意，营地里可以赊账，因此哥萨克 Vus 在某些时刻可能拥有负数的卢布。此外，哥萨克 Vus 可以用同一把军刀抓住多个敌人。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$（$1 \\leq n, m \\leq 10^6$）——分别表示军刀和敌人的数量。\n\n接下来的 $n$ 行，每行包含三个整数 $a_i$、$b_i$ 和 $cost_i$（$0 \\leq a_i, b_i, cost_i \\leq 10^9$）——第 $i$ 把军刀的长度、锋利度和价格。\n\n接下来的 $m$ 行，每行包含三个整数 $c_j$、$d_j$ 和 $profit_j$（$0 \\leq c_j, d_j, profit_j \\leq 10^9$）——第 $j$ 个敌人的护甲厚度、强度和悬赏金额。", "outputFormat": "输出一个整数——哥萨克 Vus 能赚取的最大卢布数。\n", "hint": "### 评分标准\n\n- （13 分）：对于任意两个不同的敌人 $(i,j)$，要么 $c_i > c_j$，要么 $d_i > d_j$，即不存在一个敌人其护甲的两个参数均不劣于另一个敌人；$n, m \\leq 5\\,000$；\n- （10 分）：对于任意两个不同的敌人 $(i,j)$，要么 $c_i > c_j$，要么 $d_i > d_j$，即不存在一个敌人其护甲的两个参数均不劣于另一个敌人；$n, m \\leq 10^5$；\n- （13 分）：对于任意两把不同的军刀 $(i,j)$，要么 $a_i > a_j$，要么 $b_i > b_j$，即不存在一把军刀其攻击的两个参数均不劣于另一把军刀；$n, m \\leq 5\\,000$；\n- （10 分）：对于任意两把不同的军刀 $(i,j)$，要么 $a_i > a_j$，要么 $b_i > b_j$，即不存在一把军刀其攻击的两个参数均不劣于另一把军刀；$n, m \\leq 10^5$；\n- （14 分）：$n, m \\leq 5000$；\n- （23 分）：$n, m \\leq 10^5$；\n- （17 分）：无额外限制。", "locale": "zh-CN"}}}
{"pid": "P12582", "type": "P", "difficulty": 5, "samples": [["7\n3 -5 -1 4 2 5 3\n0 1\n0 2\n2 3\n2 4\n4 6\n5 6", "14"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "交互题", "树形 DP", "KOI（韩国）"], "title": "「KTSC 2019 R1」树", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\nlong long findSum(int N, std::vector<int>C, std::vector<int> Node1, std::vector<int> Node2);\n```\n\n题目译自 [2019년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2019/) T1「[트리](https://assets.ioikorea.or.kr/ioitst/2019/1/tree/tree_statement.pdf)」\n\n", "description": "有一棵包含 $N$ 个节点的树 $T=(V, E)$。每个节点上写有一个整数（可以为负）。我们需要找到满足以下条件的两棵子图 $T_{a}=\\left(V_{a}, E_{a}\\right)$ 和 $T_{b}=\\left(V_{b}, E_{b}\\right)$：\n\n- $V_{a} \\neq \\varnothing, V_{b} \\neq \\varnothing$；\n- $T_{a}$ 和 $T_{b}$ 都是连通图；\n- $V_{a} \\cap V_{b}=\\varnothing$；\n- $E$ 中没有连接 $V_{a}$ 中节点和 $V_{b}$ 中节点的边；\n- 最后，我们希望 $V_{a}$ 中所有节点的整数之和与 $V_{b}$ 中所有节点的整数之和的总和尽可能大。\n\n考虑下面的例子：$T=(\\{0,1,2,3,4,5,6\\},\\{(0,1),(0,2),(2,3),(2,4),(4,6),(5,6)\\})$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kca4z6ad.png)\n\n节点上的数字表示节点编号，节点内的数字表示该节点上的值。可以有多种方法找到符合条件的 $T_{a}$ 和 $T_{b}$，但选择 $V_{a}=\\{0,2,3\\}$ 和 $V_{b}=\\{5,6\\}$，两个子图中的整数和为 $\\{3+(-1)+4\\}+\\{5+3\\}=14$，这是最大的值。虽然有其他方法，但无法得到比 $14$ 更大的值。\n\n你需要实现以下函数：\n\n`\nlong long findSum(int N, int C[], int Node1[], int Node2[]);`\n\n该函数将会被调用一次，传入输入参数并返回问题的答案。$N$ 表示节点数，节点编号从 $0$ 到 $N-1$。编号为 $i (0\\leq i\\leq N-1)$ 的节点上写的数为 $C_i$。编号为 $Node1_i$ 和 $Node2_i (0\\leq i\\leq N-2)$ 的节点由一条边连接。\n\n这些函数必须按照上述描述工作。当然，你可以创建其他函数并在内部使用。提交的代码不得进行输入输出操作或访问其他文件。", "inputFormat": "示例评测程序将按照以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2$ 行：$N$ 个整数 $C_{0}, C_{1}, \\ldots, C_{N-1}$，表示每个节点的值。\n- 接下来的 $N-1$ 行：两个整数 $a$ 和 $b$，表示编号为 $a$ 和 $b$ 的节点由边连接。\n\n注意：每行最后一个数字后面不得有空格或其他字符，否则示例评测程序可能无法正确工作。", "outputFormat": "示例评测程序将输出 `findSum()` 函数的返回值。", "hint": "对于所有输入数据，满足：\n\n- $-10^{9} \\leq C_{i} \\leq 10^{9}$\n- $3 \\leq N \\leq 5\\cdot 10^5$\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n| $1$ | $7$ | $N \\le 20$ |\n| $2$ | $19$ | $N \\le 5000$ |\n| $3$ | $74$ | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KTSC 2019 R1」树", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\nlong long findSum(int N, std::vector<int>C, std::vector<int> Node1, std::vector<int> Node2);\n```\n\n题目译自 [2019년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2019/) T1「[트리](https://assets.ioikorea.or.kr/ioitst/2019/1/tree/tree_statement.pdf)」\n\n", "description": "有一棵包含 $N$ 个节点的树 $T=(V, E)$。每个节点上写有一个整数（可以为负）。我们需要找到满足以下条件的两棵子图 $T_{a}=\\left(V_{a}, E_{a}\\right)$ 和 $T_{b}=\\left(V_{b}, E_{b}\\right)$：\n\n- $V_{a} \\neq \\varnothing, V_{b} \\neq \\varnothing$；\n- $T_{a}$ 和 $T_{b}$ 都是连通图；\n- $V_{a} \\cap V_{b}=\\varnothing$；\n- $E$ 中没有连接 $V_{a}$ 中节点和 $V_{b}$ 中节点的边；\n- 最后，我们希望 $V_{a}$ 中所有节点的整数之和与 $V_{b}$ 中所有节点的整数之和的总和尽可能大。\n\n考虑下面的例子：$T=(\\{0,1,2,3,4,5,6\\},\\{(0,1),(0,2),(2,3),(2,4),(4,6),(5,6)\\})$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kca4z6ad.png)\n\n节点上的数字表示节点编号，节点内的数字表示该节点上的值。可以有多种方法找到符合条件的 $T_{a}$ 和 $T_{b}$，但选择 $V_{a}=\\{0,2,3\\}$ 和 $V_{b}=\\{5,6\\}$，两个子图中的整数和为 $\\{3+(-1)+4\\}+\\{5+3\\}=14$，这是最大的值。虽然有其他方法，但无法得到比 $14$ 更大的值。\n\n你需要实现以下函数：\n\n`\nlong long findSum(int N, int C[], int Node1[], int Node2[]);`\n\n该函数将会被调用一次，传入输入参数并返回问题的答案。$N$ 表示节点数，节点编号从 $0$ 到 $N-1$。编号为 $i (0\\leq i\\leq N-1)$ 的节点上写的数为 $C_i$。编号为 $Node1_i$ 和 $Node2_i (0\\leq i\\leq N-2)$ 的节点由一条边连接。\n\n这些函数必须按照上述描述工作。当然，你可以创建其他函数并在内部使用。提交的代码不得进行输入输出操作或访问其他文件。", "inputFormat": "示例评测程序将按照以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2$ 行：$N$ 个整数 $C_{0}, C_{1}, \\ldots, C_{N-1}$，表示每个节点的值。\n- 接下来的 $N-1$ 行：两个整数 $a$ 和 $b$，表示编号为 $a$ 和 $b$ 的节点由边连接。\n\n注意：每行最后一个数字后面不得有空格或其他字符，否则示例评测程序可能无法正确工作。", "outputFormat": "示例评测程序将输出 `findSum()` 函数的返回值。", "hint": "对于所有输入数据，满足：\n\n- $-10^{9} \\leq C_{i} \\leq 10^{9}$\n- $3 \\leq N \\leq 5\\cdot 10^5$\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n| $1$ | $7$ | $N \\le 20$ |\n| $2$ | $19$ | $N \\le 5000$ |\n| $3$ | $74$ | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P12583", "type": "P", "difficulty": 0, "samples": [["6 3\n0 0\n1 1\n2 2\n4 3\n0 2\n2 0\n0 5 2\n1 3 4\n4 1 5", "4\n4\n3"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "交互题", "Special Judge", "KOI（韩国）"], "title": "「KTSC 2019 R1」山羊【暂时无法评测】", "background": "**本题因官方交互库在洛谷出现编译错误暂时无法评测，目前正在尝试修复。**\n\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nvoid init(std::vector<int> X, std::vector<int> Y);\nint count(int A, int B, int C);\n```\n\n题目译自 [2019년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2019/) T2「[트리](https://assets.ioikorea.or.kr/ioitst/2019/1/goat/goat_statement.pdf)」\n\n", "description": "在广阔的平原上有 $N$ 头山羊。没有两个或以上的山羊在同一位置。这些山羊都是机器人，只能在原地旋转。山羊的鼻子上有 LED 灯，可以远程点亮。山羊的眼睛是可以实时远程查看摄像头捕获的图像，并可以保存想要的场景。山羊可以看到自己，也有透视功能，即使山羊重叠也能知道有多少只。山羊的左右视野为 $180^{\\circ}$，在 $180^{\\circ}$ 边界上的物体也能看见。\n\n根据山羊的位置，有些山羊可以一次看到 $N$ 头山羊，而有些山羊无论朝哪个方向看都无法一次看到 $N$ 头山羊。例如，下面的图中，编号为 $0$ 到 $5$ 的六只山羊中，$5$ 号山羊可以一次看到六只山羊，但 $2$ 号山羊无论朝哪个方向看都无法一次看到六只山羊。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2xojzv7b.png)\n\n为了进行特殊的实验，我们选择两只一次能看到 N 头山羊的不同山羊，再从剩下的山羊中任意选择一只。这三只选定的山羊将点亮鼻子，以便随时确认它们的位置。观察选定三只山羊眼中捕获到的图像，并在每只山羊能看到点亮的三只山羊同框的场景下各自保存一张图像。然后，逐一查看保存的三张图像，对每张图像中点亮的两只其他山羊之间（包括边界）可见的所有山羊进行特殊标记。这个标记是为了特殊的实验，实验的目标是统计 $N$ 只山羊中被标记了三次的山羊数量。\n\n例如，如果在全部六只山羊中选定的三只山羊用红点表示，下面的图显示了以每只山羊为基准被特殊标记的山羊。（当然，每张图并非是保存的场景本身。）在这种情况下，被标记了三次的山羊数量是 $4$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/eag49b9y.png)\n\n你需要为这个实验实现以下两个函数：\n\n- `void init(int x[], int y[]);`\n\n最先被调用，并且只调用一次。`x` 和 `y` 是大小为 $N$ 的数组（向量）。`x[0..N-1]` 表示山羊的 $x$ 坐标，`y[0..N-1]` 表示山羊的 $y$ 坐标。编号为 $i (0 \\leq i \\leq N-1)$ 的山羊位置是 `(x[i], y[i])`。\n\n- `int count(int a, int b, int c);`\n\n使用给定的三只山羊的坐标 `(x[a], y[a])`，`(x[b], y[b])`，`(x[c], y[c])`，计算被标记了三次的山羊数量并返回。", "inputFormat": "示例评测程序以以下格式读取输入：\n\n- 第 $1$ 行：$N\\, Q$，其中 $N$ 表示山羊的数量，$Q$ 表示查询的数量\n- 接下来的 $N$ 行：每行两个整数 $x\\, y$，表示山羊位置的 $x$ 坐标和 $y$ 坐标\n- 接下来的 $Q$ 行：每行三个整数 $a\\,b\\,c (0 \\leq a, b, c \\leq N-1)$，表示三只山羊的编号", "outputFormat": "示例评测程序对每个查询输出一行一个整数，表示满足条件的山羊数量。\n\n", "hint": "### 样例说明 #1\n下面是样例 1 的函数调用及其结果：\n\n| 函数调用 | 返回值 |\n| :-----------: | :-----------: |\n|`init({0, 1, 2, 4, 0, 2}, {0, 1, 2, 3, 2, 0})`|  |\n|`count(0, 5, 2)`|$4$|\n|`count(1, 3, 4)`|$4$|\n|`count(4, 1, 5)`|$3$|\n\n### 数据范围\n对于所有输入数据，满足：\n\n- $3 \\leq N \\leq 3\\,000$\n- $1 \\leq Q \\leq 5 \\times 10^{6}$\n- 所有山羊的 $x$ 坐标和 $y$ 坐标都在 $0$ 到 $10^{9}$ 之间\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n| $1$ | $5$ | $N \\leq 500, Q \\leq 10^{5}$；任何三点不在一条直线上 |\n| $2$ | $17$ | $N \\leq 500, Q \\leq 10^{5}$ |\n| $3$ | $10$ | $N \\leq 500$；任何三点不在一条直线上 |\n| $4$ | $8$ | $N \\leq 500$ |\n| $5$ | $29$ | 任何三点不在一条直线上 |\n| $6$ | $31$ | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KTSC 2019 R1」山羊【暂时无法评测】", "background": "**本题因官方交互库在洛谷出现编译错误暂时无法评测，目前正在尝试修复。**\n\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nvoid init(std::vector<int> X, std::vector<int> Y);\nint count(int A, int B, int C);\n```\n\n题目译自 [2019년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2019/) T2「[트리](https://assets.ioikorea.or.kr/ioitst/2019/1/goat/goat_statement.pdf)」\n\n", "description": "在广阔的平原上有 $N$ 头山羊。没有两个或以上的山羊在同一位置。这些山羊都是机器人，只能在原地旋转。山羊的鼻子上有 LED 灯，可以远程点亮。山羊的眼睛是可以实时远程查看摄像头捕获的图像，并可以保存想要的场景。山羊可以看到自己，也有透视功能，即使山羊重叠也能知道有多少只。山羊的左右视野为 $180^{\\circ}$，在 $180^{\\circ}$ 边界上的物体也能看见。\n\n根据山羊的位置，有些山羊可以一次看到 $N$ 头山羊，而有些山羊无论朝哪个方向看都无法一次看到 $N$ 头山羊。例如，下面的图中，编号为 $0$ 到 $5$ 的六只山羊中，$5$ 号山羊可以一次看到六只山羊，但 $2$ 号山羊无论朝哪个方向看都无法一次看到六只山羊。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2xojzv7b.png)\n\n为了进行特殊的实验，我们选择两只一次能看到 N 头山羊的不同山羊，再从剩下的山羊中任意选择一只。这三只选定的山羊将点亮鼻子，以便随时确认它们的位置。观察选定三只山羊眼中捕获到的图像，并在每只山羊能看到点亮的三只山羊同框的场景下各自保存一张图像。然后，逐一查看保存的三张图像，对每张图像中点亮的两只其他山羊之间（包括边界）可见的所有山羊进行特殊标记。这个标记是为了特殊的实验，实验的目标是统计 $N$ 只山羊中被标记了三次的山羊数量。\n\n例如，如果在全部六只山羊中选定的三只山羊用红点表示，下面的图显示了以每只山羊为基准被特殊标记的山羊。（当然，每张图并非是保存的场景本身。）在这种情况下，被标记了三次的山羊数量是 $4$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/eag49b9y.png)\n\n你需要为这个实验实现以下两个函数：\n\n- `void init(int x[], int y[]);`\n\n最先被调用，并且只调用一次。`x` 和 `y` 是大小为 $N$ 的数组（向量）。`x[0..N-1]` 表示山羊的 $x$ 坐标，`y[0..N-1]` 表示山羊的 $y$ 坐标。编号为 $i (0 \\leq i \\leq N-1)$ 的山羊位置是 `(x[i], y[i])`。\n\n- `int count(int a, int b, int c);`\n\n使用给定的三只山羊的坐标 `(x[a], y[a])`，`(x[b], y[b])`，`(x[c], y[c])`，计算被标记了三次的山羊数量并返回。", "inputFormat": "示例评测程序以以下格式读取输入：\n\n- 第 $1$ 行：$N\\, Q$，其中 $N$ 表示山羊的数量，$Q$ 表示查询的数量\n- 接下来的 $N$ 行：每行两个整数 $x\\, y$，表示山羊位置的 $x$ 坐标和 $y$ 坐标\n- 接下来的 $Q$ 行：每行三个整数 $a\\,b\\,c (0 \\leq a, b, c \\leq N-1)$，表示三只山羊的编号", "outputFormat": "示例评测程序对每个查询输出一行一个整数，表示满足条件的山羊数量。\n\n", "hint": "### 样例说明 #1\n下面是样例 1 的函数调用及其结果：\n\n| 函数调用 | 返回值 |\n| :-----------: | :-----------: |\n|`init({0, 1, 2, 4, 0, 2}, {0, 1, 2, 3, 2, 0})`|  |\n|`count(0, 5, 2)`|$4$|\n|`count(1, 3, 4)`|$4$|\n|`count(4, 1, 5)`|$3$|\n\n### 数据范围\n对于所有输入数据，满足：\n\n- $3 \\leq N \\leq 3\\,000$\n- $1 \\leq Q \\leq 5 \\times 10^{6}$\n- 所有山羊的 $x$ 坐标和 $y$ 坐标都在 $0$ 到 $10^{9}$ 之间\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n| $1$ | $5$ | $N \\leq 500, Q \\leq 10^{5}$；任何三点不在一条直线上 |\n| $2$ | $17$ | $N \\leq 500, Q \\leq 10^{5}$ |\n| $3$ | $10$ | $N \\leq 500$；任何三点不在一条直线上 |\n| $4$ | $8$ | $N \\leq 500$ |\n| $5$ | $29$ | 任何三点不在一条直线上 |\n| $6$ | $31$ | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P12584", "type": "P", "difficulty": 0, "samples": [["4 3\n3 1\n2 4\n1 4", "0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "交互题", "KOI（韩国）"], "title": "「KTSC 2019 R1」产油国", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nlong long findEdges(int N, std::vector<int> A, std::vector<int> B);\n```\n\n题目译自 [2019년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2019/) T3「[산유국](https://assets.ioikorea.kr/ioitst/2019/1/oil/oil_statement.pdf)」", "description": "阿塞拜疆是一个地下资源丰富的国家，盛产石油，国民可以非常廉价地使用汽油。\n\n阿塞拜疆的首都巴库有 $N$ 个十字路口和 $M+N-1$ 条双向道路。巴库是一座南北向狭长的城市。十字路口按南北方向排成一条直线，从最北端的十字路口开始，依次编号为 $1$ 到 $N$。\n\n城市中有旧路和新建的道路。共有 $N-1$ 条旧路，分别连接编号为 $i (1 \\leq i < N)$ 的十字路口和编号为 $i+1$ 的十字路口。此外，还有 $M$ 条新建道路，每条新建道路连接一对不同的、未被旧路连接的十字路口。任意一对十字路口之间最多只有一条道路连接。\n\n由于近期财政状况不佳，巴库决定在部分道路上设置收费站来收取通行费。为了避免市民的不满，只会在恰好两条道路上收取通行费。每当一辆车通过收费站时，需要支付 $1$ 马纳特（阿塞拜疆的货币单位）的通行费。如果一辆车经过两个收费站，那么需要支付 $2$ 马纳特。\n\n每个十字路口都有 $N-1$ 辆汽车。每个十字路口的汽车都会前往除当前所在十字路口外的其他不同十字路口。司机在从十字路口 $u$ 到十字路口 $v$ 时，会选择通行费最少的路径（因为在这个国家汽油非常便宜）。\n\n当所有汽车都到达目的地后，请编写一个程序，找出应该在哪两条道路上设置收费站，才能使收取的通行费总额最大。\n\n你需要实现以下函数：\n\n`long long findEdges(int N, int A[], int B[]);`\n\n该函数只会在程序开始时被调用一次，用于提供十字路口和道路的结构信息。参数说明如下：\n\n`N`：十字路口的数量。\n`A` 和 `B`：大小为 `M` 的数组，表示新建的 $M$ 条道路。其中，`A[i]` 和 `B[i]` 表示第 $i (0 \\leq i < M)$ 条新建道路连接的两个十字路口编号。\n\n你的任务是根据给定的十字路口和道路信息，计算在两条道路上设置收费站所能收取的最大通行费总额，并返回这个值。\n\n函数必须按照上述描述进行操作。你可以在程序中创建和使用其他函数，但不得进行任何输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按照以下格式读取输入：\n\n- 第 $1$ 行：两个整数 $N$ 和 $M$，分别表示十字路口的数量和新建道路的数量。\n- 接下来的 $M$ 行：每行两个自然数，表示一条新建道路连接的两个十字路口编号。", "outputFormat": "示例评测程序会输出你的代码中 `findEdges()` 函数返回的值。", "hint": "### 样例说明 #1\n| 调用 | 结果 |\n| :----------: | :----------: |\n| `findEdges(4, {3, 2, 1}, {1, 4, 4})` | 函数被调用，返回值 $0$ |\n\n### 数据范围\n\n| 子任务 | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n| $1$| $10$| $3 \\leq N \\leq 100，0 \\leq M \\leq 100$|\n|$2$|$13$|$3 \\leq N \\leq 2000，0 \\leq M \\leq 2000$|\n|$3$|$48$|$3 \\leq N \\leq 10^5，0 \\leq M \\leq 10^5$|\n|$4$|$29$|$3 \\leq N \\leq 5\\cdot 10^5，0 \\leq M \\leq 5\\cdot 10^5$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KTSC 2019 R1」产油国", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nlong long findEdges(int N, std::vector<int> A, std::vector<int> B);\n```\n\n题目译自 [2019년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2019/) T3「[산유국](https://assets.ioikorea.kr/ioitst/2019/1/oil/oil_statement.pdf)」", "description": "阿塞拜疆是一个地下资源丰富的国家，盛产石油，国民可以非常廉价地使用汽油。\n\n阿塞拜疆的首都巴库有 $N$ 个十字路口和 $M+N-1$ 条双向道路。巴库是一座南北向狭长的城市。十字路口按南北方向排成一条直线，从最北端的十字路口开始，依次编号为 $1$ 到 $N$。\n\n城市中有旧路和新建的道路。共有 $N-1$ 条旧路，分别连接编号为 $i (1 \\leq i < N)$ 的十字路口和编号为 $i+1$ 的十字路口。此外，还有 $M$ 条新建道路，每条新建道路连接一对不同的、未被旧路连接的十字路口。任意一对十字路口之间最多只有一条道路连接。\n\n由于近期财政状况不佳，巴库决定在部分道路上设置收费站来收取通行费。为了避免市民的不满，只会在恰好两条道路上收取通行费。每当一辆车通过收费站时，需要支付 $1$ 马纳特（阿塞拜疆的货币单位）的通行费。如果一辆车经过两个收费站，那么需要支付 $2$ 马纳特。\n\n每个十字路口都有 $N-1$ 辆汽车。每个十字路口的汽车都会前往除当前所在十字路口外的其他不同十字路口。司机在从十字路口 $u$ 到十字路口 $v$ 时，会选择通行费最少的路径（因为在这个国家汽油非常便宜）。\n\n当所有汽车都到达目的地后，请编写一个程序，找出应该在哪两条道路上设置收费站，才能使收取的通行费总额最大。\n\n你需要实现以下函数：\n\n`long long findEdges(int N, int A[], int B[]);`\n\n该函数只会在程序开始时被调用一次，用于提供十字路口和道路的结构信息。参数说明如下：\n\n`N`：十字路口的数量。\n`A` 和 `B`：大小为 `M` 的数组，表示新建的 $M$ 条道路。其中，`A[i]` 和 `B[i]` 表示第 $i (0 \\leq i < M)$ 条新建道路连接的两个十字路口编号。\n\n你的任务是根据给定的十字路口和道路信息，计算在两条道路上设置收费站所能收取的最大通行费总额，并返回这个值。\n\n函数必须按照上述描述进行操作。你可以在程序中创建和使用其他函数，但不得进行任何输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按照以下格式读取输入：\n\n- 第 $1$ 行：两个整数 $N$ 和 $M$，分别表示十字路口的数量和新建道路的数量。\n- 接下来的 $M$ 行：每行两个自然数，表示一条新建道路连接的两个十字路口编号。", "outputFormat": "示例评测程序会输出你的代码中 `findEdges()` 函数返回的值。", "hint": "### 样例说明 #1\n| 调用 | 结果 |\n| :----------: | :----------: |\n| `findEdges(4, {3, 2, 1}, {1, 4, 4})` | 函数被调用，返回值 $0$ |\n\n### 数据范围\n\n| 子任务 | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n| $1$| $10$| $3 \\leq N \\leq 100，0 \\leq M \\leq 100$|\n|$2$|$13$|$3 \\leq N \\leq 2000，0 \\leq M \\leq 2000$|\n|$3$|$48$|$3 \\leq N \\leq 10^5，0 \\leq M \\leq 10^5$|\n|$4$|$29$|$3 \\leq N \\leq 5\\cdot 10^5，0 \\leq M \\leq 5\\cdot 10^5$|", "locale": "zh-CN"}}}
{"pid": "P12585", "type": "P", "difficulty": 0, "samples": [["3\n1 3 8", "29\n29"], ["5\n1 3 4 6 9", "39\n18\n18\n18"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "交互题", "KOI（韩国）"], "title": "「KTSC 2019 R1」广播站", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nvoid stations(std::vector<int> X);\nvoid answer(std::vector<long long> Ans);\n```\n\n题目译自 [2019년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2019/) T4「[방송국](https://assets.ioikorea.kr/ioitst/2019/1/stations/stations_statement.pdf)」", "description": "有 $N$ 个广播站，分别是 $s_{1}, s_{2}, \\ldots, s_{N}$，它们位于一条直线上。广播站 $s_{i}$ 的位置是正整数 $x_{i}$。你需要为每个广播站 $s_{i}$ 分配广播信号的范围 $r_{i}$。当广播站 $s_{i}$ 进行广播时，距离 $s_{i}$ 不超过 $r_{i}$ 的广播站可以接收到 $s_{i}$ 的广播信号。换句话说，如果广播站 $s_{j}$ 位于闭区间 $\\left[ x_{i} - r_{i}, x_{i} + r_{i} \\right ]$ 内，那么 $s_{j}$ 就能接收到 $s_{i}$ 的广播信号。\n\n广播站 $s_{i}$ 的广播可以通过 $h - 1 (h > 1)$ 个其他广播站传递给广播站 $s_{j}$。也就是说，存在广播站 $s_{i_{1}}, s_{i_{2}}, \\ldots, s_{i_{h-1}}$，使得 $s_{i}$ 的广播传递给 $s_{i_{1}}$，每个 $s_{i_{k}}$ 再传递给 $s_{i_{k+1}}$，最后 $s_{i_{h-1}}$ 传递给 $s_{j}$，这样 $s_{i}$ 的广播在 $h$ 次传递内就可以到达 $s_{j}$。当然，当 $h=1$ 时，表示 $s_{i}$ 的广播直接传递给 $s_{j}$。在这些情况下，我们称 $s_{i}$ 的广播在 $h$ 步内传递到了 $s_{j}$。\n\n我们希望选择一个广播站作为 $h$-集中站。这个广播站不进行广播，但必须能够在最多 $h$ 步内接收到其他所有广播站的广播。我们可以将 $h$-集中站的广播信号范围设为 $0$。\n\n当为每个广播站 $s_{i}$ 分配广播范围 $r_{i}$ 时，分配成本定义为广播范围的平方和。也就是说，成本为 $\n\\sum_{i=1}^{N} r_{i}^{2}$。我们将以最小化这个成本来分配广播范围。如果广播站 $s$ 作为 $h$-集中站时的最小分配成本为 $\nC_{h}^{*}(s)$，那么问题的目标就是在所有可能的 $h$-集中站 $s$ 中，找到具有最小 $\nC_{h}^{*}(s)$ 的那个，以及给出导致该最小成本的广播范围分配。\n\n给定 $N$ 个广播站的位置，对于每个 $h=1, 2, \\ldots, N-1$，编写一个程序，输出所有可能的 $h$-集中站 $s$ 的最小分配成本 $\nC_{h}^{*}(s)$ 中的最小值。\n\n例如，下面的图 1 和图 2 是 $5$ 个广播站 $s_{1}, \\ldots, s_{5}$，它们分别位于坐标 $1, 3, 4, 6, 9$，当 $h=2$ 时的情况。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/m2mzhp0t.png)\n\n在图 1 中，当为 $s_{1}, s_{2}, s_{3}, s_{4}$ 分别分配广播范围 $3, 1, 5, 2$，且 $s_{5}$ 作为 $2$-集中站时，最小成本为 $39$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j08cfqmh.png)\n\n在图 2 中，当为 $s_{1}, s_{2}, s_{4}, s_{5}$ 分别分配广播范围 $2, 1, 2, 3$，且 $s_{3}$ 作为 $2$-集中站时，最小成本为 $18$。\n\n因此，$18$ 是所有可能的 $2$-集中站的最小成本中的最小值。\n\n你需要为管理员实现以下一个函数：\n\n`void stations(int N, int X[]);`\n\n接受广播站的数量 `N` 和每个广播站的位置 `X[0..N-1]` 作为参数。其中，`X[]` 是大小为 `N` 的向量（`vector`），`X[i]` 的值互不相同，且按升序存储。\n\n你需要在 `stations()` 函数中使用以下函数来提交答案：\n\n`void answer(long long Y[]);`\n\n这是一个提交大小为 `N - 1` 的向量 `Y[]` 的函数。对于 $i = 0, \\ldots, N - 2$，`Y[i]` 的值是所有可能的 $(i + 1)$-集中站的最小成本的最小值。这个函数必须在 `stations()` 函数中且只能被调用一次。\n\n该函数必须按照上述描述进行操作。当然，你可以创建和使用其他函数，但不得进行任何输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按照以下格式读取输入：\n\n- 第 $1$ 行：$N$，其中 $N$ 表示广播站的数量\n- 第 $2$ 行：$N$ 个整数 $x_{1}\\,x_{2}\\,\\cdots\\,x_{N}$，其中 $x_{i}$ 为广播站的位置", "outputFormat": "示例评测程序对于每个 $i = 1, \\ldots, N - 1$，在第 $i$ 行输出所有可能的 $i$-集中站的最小成本的最小值。", "hint": "### 数据范围\n对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 120$\n- $1 \\leq x_{1} < x_{2} < \\cdots < x_{N} \\leq 10^{8}$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$11$|$N \\leq 7$|\n|$2$|$21$|$N \\leq 30$|\n|$3$|$17$|$N \\leq 60$|\n|$4$|$51$|无附加限制|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KTSC 2019 R1」广播站", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nvoid stations(std::vector<int> X);\nvoid answer(std::vector<long long> Ans);\n```\n\n题目译自 [2019년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2019/) T4「[방송국](https://assets.ioikorea.kr/ioitst/2019/1/stations/stations_statement.pdf)」", "description": "有 $N$ 个广播站，分别是 $s_{1}, s_{2}, \\ldots, s_{N}$，它们位于一条直线上。广播站 $s_{i}$ 的位置是正整数 $x_{i}$。你需要为每个广播站 $s_{i}$ 分配广播信号的范围 $r_{i}$。当广播站 $s_{i}$ 进行广播时，距离 $s_{i}$ 不超过 $r_{i}$ 的广播站可以接收到 $s_{i}$ 的广播信号。换句话说，如果广播站 $s_{j}$ 位于闭区间 $\\left[ x_{i} - r_{i}, x_{i} + r_{i} \\right ]$ 内，那么 $s_{j}$ 就能接收到 $s_{i}$ 的广播信号。\n\n广播站 $s_{i}$ 的广播可以通过 $h - 1 (h > 1)$ 个其他广播站传递给广播站 $s_{j}$。也就是说，存在广播站 $s_{i_{1}}, s_{i_{2}}, \\ldots, s_{i_{h-1}}$，使得 $s_{i}$ 的广播传递给 $s_{i_{1}}$，每个 $s_{i_{k}}$ 再传递给 $s_{i_{k+1}}$，最后 $s_{i_{h-1}}$ 传递给 $s_{j}$，这样 $s_{i}$ 的广播在 $h$ 次传递内就可以到达 $s_{j}$。当然，当 $h=1$ 时，表示 $s_{i}$ 的广播直接传递给 $s_{j}$。在这些情况下，我们称 $s_{i}$ 的广播在 $h$ 步内传递到了 $s_{j}$。\n\n我们希望选择一个广播站作为 $h$-集中站。这个广播站不进行广播，但必须能够在最多 $h$ 步内接收到其他所有广播站的广播。我们可以将 $h$-集中站的广播信号范围设为 $0$。\n\n当为每个广播站 $s_{i}$ 分配广播范围 $r_{i}$ 时，分配成本定义为广播范围的平方和。也就是说，成本为 $\n\\sum_{i=1}^{N} r_{i}^{2}$。我们将以最小化这个成本来分配广播范围。如果广播站 $s$ 作为 $h$-集中站时的最小分配成本为 $\nC_{h}^{*}(s)$，那么问题的目标就是在所有可能的 $h$-集中站 $s$ 中，找到具有最小 $\nC_{h}^{*}(s)$ 的那个，以及给出导致该最小成本的广播范围分配。\n\n给定 $N$ 个广播站的位置，对于每个 $h=1, 2, \\ldots, N-1$，编写一个程序，输出所有可能的 $h$-集中站 $s$ 的最小分配成本 $\nC_{h}^{*}(s)$ 中的最小值。\n\n例如，下面的图 1 和图 2 是 $5$ 个广播站 $s_{1}, \\ldots, s_{5}$，它们分别位于坐标 $1, 3, 4, 6, 9$，当 $h=2$ 时的情况。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/m2mzhp0t.png)\n\n在图 1 中，当为 $s_{1}, s_{2}, s_{3}, s_{4}$ 分别分配广播范围 $3, 1, 5, 2$，且 $s_{5}$ 作为 $2$-集中站时，最小成本为 $39$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j08cfqmh.png)\n\n在图 2 中，当为 $s_{1}, s_{2}, s_{4}, s_{5}$ 分别分配广播范围 $2, 1, 2, 3$，且 $s_{3}$ 作为 $2$-集中站时，最小成本为 $18$。\n\n因此，$18$ 是所有可能的 $2$-集中站的最小成本中的最小值。\n\n你需要为管理员实现以下一个函数：\n\n`void stations(int N, int X[]);`\n\n接受广播站的数量 `N` 和每个广播站的位置 `X[0..N-1]` 作为参数。其中，`X[]` 是大小为 `N` 的向量（`vector`），`X[i]` 的值互不相同，且按升序存储。\n\n你需要在 `stations()` 函数中使用以下函数来提交答案：\n\n`void answer(long long Y[]);`\n\n这是一个提交大小为 `N - 1` 的向量 `Y[]` 的函数。对于 $i = 0, \\ldots, N - 2$，`Y[i]` 的值是所有可能的 $(i + 1)$-集中站的最小成本的最小值。这个函数必须在 `stations()` 函数中且只能被调用一次。\n\n该函数必须按照上述描述进行操作。当然，你可以创建和使用其他函数，但不得进行任何输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按照以下格式读取输入：\n\n- 第 $1$ 行：$N$，其中 $N$ 表示广播站的数量\n- 第 $2$ 行：$N$ 个整数 $x_{1}\\,x_{2}\\,\\cdots\\,x_{N}$，其中 $x_{i}$ 为广播站的位置", "outputFormat": "示例评测程序对于每个 $i = 1, \\ldots, N - 1$，在第 $i$ 行输出所有可能的 $i$-集中站的最小成本的最小值。", "hint": "### 数据范围\n对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 120$\n- $1 \\leq x_{1} < x_{2} < \\cdots < x_{N} \\leq 10^{8}$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$11$|$N \\leq 7$|\n|$2$|$21$|$N \\leq 30$|\n|$3$|$17$|$N \\leq 60$|\n|$4$|$51$|无附加限制|", "locale": "zh-CN"}}}
{"pid": "P12586", "type": "P", "difficulty": 0, "samples": [["6 3\n2 1 0 1 0 2\n0 1 0 3 0 0\n2 0 1 0 0 2\n1 2 2 2 2 0\n1 2 2 0 0 1\n0 1 0 0 2 1", "9"], ["4 3\n10 20 10 20\n20 10 20 10\n10 20 10 20\n20 10 20 10", "40"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "交互题", "KOI（韩国）"], "title": "「KTSC 2019 R2」嫩芽", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nint diff(int K, std::vector<std::vector<int>> V);\n```\n\n题目译自 [2019년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2019/) T1「[새싹](https://assets.ioikorea.kr/ioitst/2019/1/sprout/sprout_statement.pdf)」\n\n", "description": "巴库将一块大的正方形地均匀分割成了 $N \\times N$ 个小方形田地。在每块田地里撒下了 $P$ 颗种子，一周后，有些种子发了芽，有些还没有发芽。比如，下面的图显示了 $6 \\times 6$ 田地中每块田地发芽的情况。最左上角的田地里有两颗芽，而最右下角的田地里只有一颗芽。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/w2q9z8ec.png)\n\n观察田地时，巴库想到了最近学到的中位数。中位数是奇数个给定值中的一个，当这些值排序时，正好位于中间的那个值。比如，五个给定值是 $0,1,2,2,3$ 时，中位数是 $2$。\n\n巴库想知道中位数和平均数之间的差异有多大，所以他决定比较每块田地发芽数量的中位数和平均数。为了进行多种情况的比较，他决定在相邻的 $K \\times K$ 个田地上计算中位数和平均数。这样的话，可以在给定的 $N \\times N$ 田地上总共进行 $(N-K+1) \\times(N-K+1)$ 次比较。\n\n例如，对于上图中的田地，用 $3 \\times 3$ 的区域计算中位数和平均数结果如下表。最左上角的 $3 \\times 3$ 田地中发芽数量是 $2, 1, 0, 0, 1, 0, 2, 0, 1$，因此中位数是 $1$，平均数是 $\\frac{7}{9}$。最右上角的 $3 \\times 3$ 田地中，中位数是 $0$，平均数是 $\\frac{8}{9}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/72zn5a4f.png)\n\n巴库想知道中位数和平均数差值的最大值。在上例中，最大差值出现在下图中标红色边框的部分，中位数是 $0$，平均数是 $1$，两者差值是 $1$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zjy088on.png)\n\n巴库为了方便计算，决定找出中位数和平均数差值乘以 $K^{2}$ 后的最大值。所以，在上例中最大值是 $9$。你需要为巴库实现以下函数：\n\n`int diff(int K, int V[][]);`\n\n该函数只会被调用一次，`V` 是大小为 $N \\times N$ 的数组（向量），每块田地发芽的数量 `V[0..N-1][0..N-1]` 是传入的参数。函数需要计算出 $K \\times K$ 区域中中位数和平均数的差值乘以 $K^{2}$ 的最大值并返回。\n\n这些函数必须按照上述描述工作。当然，你可以创建和使用其他函数，但不得进行任何输入输出操作或访问其他文件。\n\n", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,K$，其中 $N$ 表示田地的大小，$K$ 表示区域的大小。\n- 接下来的 $N$ 行：$V_{i,0}\\, V_{i,1}\\,\\cdots \\,V_{i,N-1}$，其中 $V_{i,0}\\, V_{i,1}\\, \\cdots\\, V_{i,N-1}$ 表示第 $i$ 行的发芽数量。", "outputFormat": "示例评测程序会输出你在 `diff()` 函数中返回的值。", "hint": "对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 2000$\n- $K$ 为奇数，$1 \\leq K \\leq N$\n- $0 \\leq V_{i,j} \\leq 30 (0 \\leq i, j \\leq N-1)$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :----------: | :----------: | :----------: |\n|$1$|$17$|$N \\leq 100$|\n|$2$|$24$|$N \\leq 300$|\n|$3$|$42$|$N \\leq 700$|\n|$4$|$67$|无附加限制|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KTSC 2019 R2」嫩芽", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nint diff(int K, std::vector<std::vector<int>> V);\n```\n\n题目译自 [2019년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2019/) T1「[새싹](https://assets.ioikorea.kr/ioitst/2019/1/sprout/sprout_statement.pdf)」\n\n", "description": "巴库将一块大的正方形地均匀分割成了 $N \\times N$ 个小方形田地。在每块田地里撒下了 $P$ 颗种子，一周后，有些种子发了芽，有些还没有发芽。比如，下面的图显示了 $6 \\times 6$ 田地中每块田地发芽的情况。最左上角的田地里有两颗芽，而最右下角的田地里只有一颗芽。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/w2q9z8ec.png)\n\n观察田地时，巴库想到了最近学到的中位数。中位数是奇数个给定值中的一个，当这些值排序时，正好位于中间的那个值。比如，五个给定值是 $0,1,2,2,3$ 时，中位数是 $2$。\n\n巴库想知道中位数和平均数之间的差异有多大，所以他决定比较每块田地发芽数量的中位数和平均数。为了进行多种情况的比较，他决定在相邻的 $K \\times K$ 个田地上计算中位数和平均数。这样的话，可以在给定的 $N \\times N$ 田地上总共进行 $(N-K+1) \\times(N-K+1)$ 次比较。\n\n例如，对于上图中的田地，用 $3 \\times 3$ 的区域计算中位数和平均数结果如下表。最左上角的 $3 \\times 3$ 田地中发芽数量是 $2, 1, 0, 0, 1, 0, 2, 0, 1$，因此中位数是 $1$，平均数是 $\\frac{7}{9}$。最右上角的 $3 \\times 3$ 田地中，中位数是 $0$，平均数是 $\\frac{8}{9}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/72zn5a4f.png)\n\n巴库想知道中位数和平均数差值的最大值。在上例中，最大差值出现在下图中标红色边框的部分，中位数是 $0$，平均数是 $1$，两者差值是 $1$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zjy088on.png)\n\n巴库为了方便计算，决定找出中位数和平均数差值乘以 $K^{2}$ 后的最大值。所以，在上例中最大值是 $9$。你需要为巴库实现以下函数：\n\n`int diff(int K, int V[][]);`\n\n该函数只会被调用一次，`V` 是大小为 $N \\times N$ 的数组（向量），每块田地发芽的数量 `V[0..N-1][0..N-1]` 是传入的参数。函数需要计算出 $K \\times K$ 区域中中位数和平均数的差值乘以 $K^{2}$ 的最大值并返回。\n\n这些函数必须按照上述描述工作。当然，你可以创建和使用其他函数，但不得进行任何输入输出操作或访问其他文件。\n\n", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,K$，其中 $N$ 表示田地的大小，$K$ 表示区域的大小。\n- 接下来的 $N$ 行：$V_{i,0}\\, V_{i,1}\\,\\cdots \\,V_{i,N-1}$，其中 $V_{i,0}\\, V_{i,1}\\, \\cdots\\, V_{i,N-1}$ 表示第 $i$ 行的发芽数量。", "outputFormat": "示例评测程序会输出你在 `diff()` 函数中返回的值。", "hint": "对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 2000$\n- $K$ 为奇数，$1 \\leq K \\leq N$\n- $0 \\leq V_{i,j} \\leq 30 (0 \\leq i, j \\leq N-1)$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :----------: | :----------: | :----------: |\n|$1$|$17$|$N \\leq 100$|\n|$2$|$24$|$N \\leq 300$|\n|$3$|$42$|$N \\leq 700$|\n|$4$|$67$|无附加限制|", "locale": "zh-CN"}}}
{"pid": "P12587", "type": "P", "difficulty": 6, "samples": [["10 3\n1 3 2 5 1 4 6 2 1 3\n2 8\n2 4\n7 9", "6\n1\n0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "交互题", "KOI（韩国）"], "title": "「KTSC 2019 R2」外星仙人掌", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nvoid init(std::vector<int> H);\n\nlong long query(int S, int E);\n```\n\n题目译自 [2019년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2019/) T3「[외계 선인장](https://assets.ioikorea.kr/ioitst/2019/1/cactus/cactus_statement.pdf)」\n\n", "description": "某个外星行星的大部分地表是沙漠，因此降雨非常少。这个星球上的植物都是仙人掌。由于降雨量极少，仙人掌们进化出了互相协作储存水的方法。\n\n行星的某个区域是一个只有上下和左右方向的二维平面。在这个区域内，有 $N$ 棵仙人掌排成一行。每棵仙人掌的宽度都是 $1$ 米，但高度可能不同。为了美化环境，只保留从第 $S$ 棵仙人掌到第 $E$ 棵仙人掌，当降雨量充足时，仙人掌上方的空隙中会积水。如下图所示，下图中箭头指示的范围外的仙人掌可以忽略。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3oqf6q0m.png)\n\n你需要根据仙人掌的高度和保留下来的仙人掌范围来计算积水的面积。给定的范围最多有 Q 次。范围始终适用于所有存在的初始仙人掌状态。\n\n你需要实现以下函数：\n\n- `void init(int H[]);`\n\n这个函数只会在程序开始时被调用一次。$H$ 是大小为 $N$ 的数组（向量），按从左到右的顺序存储仙人掌的高度。$N$ 是仙人掌的数量。\n\n- `long long query(int S, int E);`\n\n给定第 $S$ 棵仙人掌到第 $E$ 棵仙人掌的范围 $(1 \\leq S \\leq E \\leq N)$，当降雨量充足时，返回积水的面积。这个函数最多会被调用 $Q$ 次。所有调用都是独立的，即一次调用中移除的仙人掌与其他调用无关。\n\n这些函数必须按照上述描述工作。当然，你可以创建和使用其他函数，但不得进行任何输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 1 行：$N\\, Q$\n- 下一行：$N$ 个自然数，按从左到右的顺序表示仙人掌的高度。\n- 接下来的 $Q$ 行：每行两个自然数 $S, E (1 \\leq S \\leq E \\leq N)$，表示只保留从第 $S$ 棵仙人掌到第 $E$ 棵仙人掌且下了充足的雨。", "outputFormat": "示例评测程序会按行输出你在 `query()` 函数中返回的值。", "hint": "### 样例说明 #1\n在上述输入中，你的代码运行方式如下：\n\n| 调用 | 结果 |\n| :----------: | :----------: |\n|`init({1, 3, 2, 5, 1, 4, 6, 2, 1, 3})`|初始调用|\n|`query(2, 8)`|`Query` 调用，返回值 `6`|\n|`query(2, 4)`|`Query` 调用，返回值 `1`|\n|`query(7, 9)`|`Query` 调用，返回值 `0`|\n\n### 数据范围\n对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 5\\cdot 10^5$，$1 \\leq Q \\leq 5\\cdot 10^5$\n- 仙人掌的高度在 $1$ 到 $10^{9}$ 之间\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :----------: | :----------: | :----------: |\n|$1$|$13$|$1 \\leq N \\leq 5000$，$1 \\leq Q \\leq 5000$|\n|$2$|$12$|$1 \\leq N \\leq 5000$|\n|$3$|$22$|仙人掌的高度不超过 $20$|\n|$4$|$34$|$1 \\leq N \\leq 10^5$，$1 \\leq Q \\leq 10^5$|\n|$5$|$69$|无附加限制|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KTSC 2019 R2」外星仙人掌", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nvoid init(std::vector<int> H);\n\nlong long query(int S, int E);\n```\n\n题目译自 [2019년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2019/) T3「[외계 선인장](https://assets.ioikorea.kr/ioitst/2019/1/cactus/cactus_statement.pdf)」\n\n", "description": "某个外星行星的大部分地表是沙漠，因此降雨非常少。这个星球上的植物都是仙人掌。由于降雨量极少，仙人掌们进化出了互相协作储存水的方法。\n\n行星的某个区域是一个只有上下和左右方向的二维平面。在这个区域内，有 $N$ 棵仙人掌排成一行。每棵仙人掌的宽度都是 $1$ 米，但高度可能不同。为了美化环境，只保留从第 $S$ 棵仙人掌到第 $E$ 棵仙人掌，当降雨量充足时，仙人掌上方的空隙中会积水。如下图所示，下图中箭头指示的范围外的仙人掌可以忽略。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3oqf6q0m.png)\n\n你需要根据仙人掌的高度和保留下来的仙人掌范围来计算积水的面积。给定的范围最多有 Q 次。范围始终适用于所有存在的初始仙人掌状态。\n\n你需要实现以下函数：\n\n- `void init(int H[]);`\n\n这个函数只会在程序开始时被调用一次。$H$ 是大小为 $N$ 的数组（向量），按从左到右的顺序存储仙人掌的高度。$N$ 是仙人掌的数量。\n\n- `long long query(int S, int E);`\n\n给定第 $S$ 棵仙人掌到第 $E$ 棵仙人掌的范围 $(1 \\leq S \\leq E \\leq N)$，当降雨量充足时，返回积水的面积。这个函数最多会被调用 $Q$ 次。所有调用都是独立的，即一次调用中移除的仙人掌与其他调用无关。\n\n这些函数必须按照上述描述工作。当然，你可以创建和使用其他函数，但不得进行任何输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 1 行：$N\\, Q$\n- 下一行：$N$ 个自然数，按从左到右的顺序表示仙人掌的高度。\n- 接下来的 $Q$ 行：每行两个自然数 $S, E (1 \\leq S \\leq E \\leq N)$，表示只保留从第 $S$ 棵仙人掌到第 $E$ 棵仙人掌且下了充足的雨。", "outputFormat": "示例评测程序会按行输出你在 `query()` 函数中返回的值。", "hint": "### 样例说明 #1\n在上述输入中，你的代码运行方式如下：\n\n| 调用 | 结果 |\n| :----------: | :----------: |\n|`init({1, 3, 2, 5, 1, 4, 6, 2, 1, 3})`|初始调用|\n|`query(2, 8)`|`Query` 调用，返回值 `6`|\n|`query(2, 4)`|`Query` 调用，返回值 `1`|\n|`query(7, 9)`|`Query` 调用，返回值 `0`|\n\n### 数据范围\n对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 5\\cdot 10^5$，$1 \\leq Q \\leq 5\\cdot 10^5$\n- 仙人掌的高度在 $1$ 到 $10^{9}$ 之间\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :----------: | :----------: | :----------: |\n|$1$|$13$|$1 \\leq N \\leq 5000$，$1 \\leq Q \\leq 5000$|\n|$2$|$12$|$1 \\leq N \\leq 5000$|\n|$3$|$22$|仙人掌的高度不超过 $20$|\n|$4$|$34$|$1 \\leq N \\leq 10^5$，$1 \\leq Q \\leq 10^5$|\n|$5$|$69$|无附加限制|", "locale": "zh-CN"}}}
{"pid": "P12588", "type": "P", "difficulty": 0, "samples": [["8\nLLLRRLLL", "6"], ["20\nLLRLLRRLLRLLRLLRRLLR", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "交互题", "KOI（韩国）"], "title": "「KTSC 2019 R2」多边形", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <string>\n\nint polygon(std::string S);\n```\n\n题目译自 [2019년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2019/) T4「[다각형](https://assets.ioikorea.kr/ioitst/2019/1/polygon/polygon_statement.pdf)」\n\n", "description": "考虑一个由水平和垂直边组成，并有 $N$ 个顶点的多边形 $P$。多边形 $P$ 的边只能在端点相交，每个顶点正好有两条边的端点相交。当沿着多边形 $P$ 的边逆时针移动时，会在顶点处向左或向右转弯。如果在顶点处向左转弯，用 $\\texttt{L}$ 表示；向右转弯，则用 $\\texttt{R}$ 表示。这样就可以用 $\\texttt{L}$ 和 $\\texttt{R}$ 组成的字符串来表示多边形。例如，图 1 中的多边形可以用字符串\n\n$$\\texttt{LLRLLRRLLRLLRLLRRLLR}$$\n\n表示。用字符串表示多边形时，字符串的起始位置总是多边形最左边边的上方顶点。这个字符总是 $\\texttt{L}$。\n\n![图 1](https://cdn.luogu.com.cn/upload/image_hosting/jfn9lpkx.png)\n\n用给定字符串表示的多边形需要满足以下条件：对于任意垂直线 $V$，$V$ 在多边形水平边的内部（不包括端点）最多只能有 $2$ 个交点。\n\n对于多边形 $P$，其包含的最小水平和垂直边组成的矩形记为 $B(P)$。它由多边形 $P$ 的最左、最右、最上和最下边与矩形的垂直和水平线重合（见图 2）。\n\n![图 2](https://cdn.luogu.com.cn/upload/image_hosting/kd2bh9lu.png)\n\n给定由字母 $\\texttt{L}$ 和 $\\texttt{R}$ 组成的长度为 $N$ 的字符串，绘制这个字符串表示的满足上述条件的多边形 $P$。此时，多边形 $P$ 的边长为整数。编写一个程序，使 $B(P)$ 的面积最小，并输出其最小值。\n\n你需要为管理员实现以下一个函数：\n\n- `int polygon(string S);`\n\n接受长度为 $N$ 的字符串 $S$ 作为参数。字符串 $S$ 的每个字符是 $\\texttt{L}$ 或 $\\texttt{R}$。函数需要找到字符串 $S$ 表示的多边形 $P$ 中使 $B(P)$ 的面积最小的情况，并返回这个最小面积。\n\n函数必须按照上述描述进行操作。当然，你可以创建和使用其他函数，但不得进行任何输入输出操作或访问其他文件。\n\n", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$，表示字符串的长度\n- 第 $2$ 行：长度为 $N$ 的字符串 $c_{1} c_{2} \\cdots c_{N}$，其中 $c_{1}=\\texttt{L}, c_{i}=\\texttt{L}$ 或 $\\texttt{R} (2 \\leq i \\leq N)$", "outputFormat": "示例评测程序会输出 `polygon` 函数的返回值。", "hint": "对于所有输入数据，满足：\n\n- 输入字符串仅包含字母 $\\texttt{L}$ 或 $\\texttt{R}$\n- 表示上述条件的多边形的输入字符串总是存在至少一个\n- $4 \\leq N \\leq 800$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :----------: | :----------: | :----------: |\n|$1$|$20$|$N \\leq 10$|\n|$2$|$36$|$N \\leq 40$|\n|$3$|$21$|$N \\leq 100$|\n|$4$|$73$|无附加限制|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KTSC 2019 R2」多边形", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <string>\n\nint polygon(std::string S);\n```\n\n题目译自 [2019년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2019/) T4「[다각형](https://assets.ioikorea.kr/ioitst/2019/1/polygon/polygon_statement.pdf)」\n\n", "description": "考虑一个由水平和垂直边组成，并有 $N$ 个顶点的多边形 $P$。多边形 $P$ 的边只能在端点相交，每个顶点正好有两条边的端点相交。当沿着多边形 $P$ 的边逆时针移动时，会在顶点处向左或向右转弯。如果在顶点处向左转弯，用 $\\texttt{L}$ 表示；向右转弯，则用 $\\texttt{R}$ 表示。这样就可以用 $\\texttt{L}$ 和 $\\texttt{R}$ 组成的字符串来表示多边形。例如，图 1 中的多边形可以用字符串\n\n$$\\texttt{LLRLLRRLLRLLRLLRRLLR}$$\n\n表示。用字符串表示多边形时，字符串的起始位置总是多边形最左边边的上方顶点。这个字符总是 $\\texttt{L}$。\n\n![图 1](https://cdn.luogu.com.cn/upload/image_hosting/jfn9lpkx.png)\n\n用给定字符串表示的多边形需要满足以下条件：对于任意垂直线 $V$，$V$ 在多边形水平边的内部（不包括端点）最多只能有 $2$ 个交点。\n\n对于多边形 $P$，其包含的最小水平和垂直边组成的矩形记为 $B(P)$。它由多边形 $P$ 的最左、最右、最上和最下边与矩形的垂直和水平线重合（见图 2）。\n\n![图 2](https://cdn.luogu.com.cn/upload/image_hosting/kd2bh9lu.png)\n\n给定由字母 $\\texttt{L}$ 和 $\\texttt{R}$ 组成的长度为 $N$ 的字符串，绘制这个字符串表示的满足上述条件的多边形 $P$。此时，多边形 $P$ 的边长为整数。编写一个程序，使 $B(P)$ 的面积最小，并输出其最小值。\n\n你需要为管理员实现以下一个函数：\n\n- `int polygon(string S);`\n\n接受长度为 $N$ 的字符串 $S$ 作为参数。字符串 $S$ 的每个字符是 $\\texttt{L}$ 或 $\\texttt{R}$。函数需要找到字符串 $S$ 表示的多边形 $P$ 中使 $B(P)$ 的面积最小的情况，并返回这个最小面积。\n\n函数必须按照上述描述进行操作。当然，你可以创建和使用其他函数，但不得进行任何输入输出操作或访问其他文件。\n\n", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$，表示字符串的长度\n- 第 $2$ 行：长度为 $N$ 的字符串 $c_{1} c_{2} \\cdots c_{N}$，其中 $c_{1}=\\texttt{L}, c_{i}=\\texttt{L}$ 或 $\\texttt{R} (2 \\leq i \\leq N)$", "outputFormat": "示例评测程序会输出 `polygon` 函数的返回值。", "hint": "对于所有输入数据，满足：\n\n- 输入字符串仅包含字母 $\\texttt{L}$ 或 $\\texttt{R}$\n- 表示上述条件的多边形的输入字符串总是存在至少一个\n- $4 \\leq N \\leq 800$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :----------: | :----------: | :----------: |\n|$1$|$20$|$N \\leq 10$|\n|$2$|$36$|$N \\leq 40$|\n|$3$|$21$|$N \\leq 100$|\n|$4$|$73$|无附加限制|", "locale": "zh-CN"}}}
{"pid": "P12589", "type": "P", "difficulty": 0, "samples": [["3 2 14 5 1\n4 6 6 10 1000\n0 7 3 9 200\n1 2 8 5 150", "1750"], ["13 0 38 100 25\n1 39 2 46 190\n9 78 10 80 230\n20 42 21 89 170\n27 26 28 68 170\n35 41 36 99 270\n43 36 44 63 280\n51 15 52 27 150\n57 14 58 29 190\n64 2 65 90 160\n75 33 76 35 290\n78 5 79 100 290\n88 28 89 40 190\n94 7 95 50 250", "11770"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "交互题", "KOI（韩国）"], "title": "「KTSC 2019 R2」大平原", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <algorithm>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nlong long shortest_path(pair<int,int> src, pair<int,int> dst, vector<pair<int,int>> p1, vector<pair<int,int>> p2, vector<int> w);\n```\n\n题目译自 [2019년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2019/) T4「[다각형](https://assets.ioikorea.kr/ioitst/2019/1/plain/plain_statement.pdf)」\n\n", "description": "一只蚂蚁在大平原上从起点移动到终点，它以每公里 $100$ 分钟的速度前进。蚂蚁只能平行于 $x$ 轴和 $y$ 轴移动，在丘陵地带移动时间可能会增加。给定起点、终点、丘陵地带的范围和每个丘陵地带 $1$ 公里的移动时间，计算蚂蚁从起点到终点所需的最短时间。\n\n丘陵地带是由平行于 $x$ 轴和 $y$ 轴的边组成的矩形，每个矩形都有 $1$ 公里的移动时间。这段时间只适用于矩形的内部，不适用于边界。此外，不同的矩形不会重叠，起点、终点和不同的矩形的顶点坐标都是整数且不重叠。起点和终点始终位于所有矩形的外部。\n\n例如，下图显示了两个矩形，其中一个矩形的左下角坐标为 $(0,1)$，右上角坐标为 $(5,2)$，每公里移动时间为 $200$ 分钟。另一个矩形的左下角坐标为 $(4,3)$，右上角坐标为 $(9,4)$，每公里移动时间为 $1000$ 分钟。图中标注了从点 $A$ 到点 $B$ 以及从点 $C$ 到点 $D$ 的最短时间路径，它们分别为 $700$ 分钟和 $1000$ 分钟。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ezj1kb5y.png)\n\n你需要实现以下函数：\n\n- `long long shortest_path(pair<int, int> src, pair<int, int> dst, vector<pair<int, int>> p1, vector<pair<int, int>> p2, vector<int> w);`\n\n这个函数只会调用一次。`src` 和 `dst` 分别是起点和终点。每个矩形的左下角坐标在 `p1`，右上角坐标在 `p2`。利用给定的值计算从 `src` 到 `dst` 的最短时间并返回。\n\n函数必须按照上述描述进行操作。当然，你可以创建和使用其他函数，但不得进行任何输入输出操作或访问其他文件。\n\n", "inputFormat": "示例评测程序按以下格式读取输入。$x, y$ 坐标的单位为公里：\n\n- 第 $1$ 行：$N\\,x_{s}\\,y_{s}\\,x_{e}\\,y_{e}$，其中 $N$ 表示矩形的数量，$x_{s}, y_{s}$ 表示起点的 $x$ 和 $y$ 坐标，$x_{e}, y_{e}$ 表示终点的 $x$ 和 $y$ 坐标\n\n- 接下来的 $N$ 行：每行给出一个矩形的坐标和移动时间 $x_{1}\\,y_{1}\\,x_{2}\\,y_{2}\\,w$，其中 $x_{1}, y_{1}$ 表示矩形左下角的 $x$ 和 $y$ 坐标，$x_{2},y_{2}$ 表示矩形右上角的 $x$ 和 $y$ 坐标，$w$ 表示矩形内部的 $1$ 公里移动时间\n\n", "outputFormat": "示例评测程序会输出 `shortest_path` 函数的返回值。\n\n", "hint": "对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 10^5$\n- $100 \\leq w \\leq 10^{8}$\n- $0 \\leq x, y \\leq 10^{8}$（$x, y$ 是起点、终点或矩形的顶点坐标）\n- $N, w, x, y$ 都是整数\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$23$|$N \\leq 500$|\n|$2$|$35$|$N \\leq 5000$|\n|$3$|$31$|$x_{2} - x_{1} = 1$|\n|$4$|$61$|无附加限制|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KTSC 2019 R2」大平原", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <algorithm>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nlong long shortest_path(pair<int,int> src, pair<int,int> dst, vector<pair<int,int>> p1, vector<pair<int,int>> p2, vector<int> w);\n```\n\n题目译自 [2019년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2019/) T4「[다각형](https://assets.ioikorea.kr/ioitst/2019/1/plain/plain_statement.pdf)」\n\n", "description": "一只蚂蚁在大平原上从起点移动到终点，它以每公里 $100$ 分钟的速度前进。蚂蚁只能平行于 $x$ 轴和 $y$ 轴移动，在丘陵地带移动时间可能会增加。给定起点、终点、丘陵地带的范围和每个丘陵地带 $1$ 公里的移动时间，计算蚂蚁从起点到终点所需的最短时间。\n\n丘陵地带是由平行于 $x$ 轴和 $y$ 轴的边组成的矩形，每个矩形都有 $1$ 公里的移动时间。这段时间只适用于矩形的内部，不适用于边界。此外，不同的矩形不会重叠，起点、终点和不同的矩形的顶点坐标都是整数且不重叠。起点和终点始终位于所有矩形的外部。\n\n例如，下图显示了两个矩形，其中一个矩形的左下角坐标为 $(0,1)$，右上角坐标为 $(5,2)$，每公里移动时间为 $200$ 分钟。另一个矩形的左下角坐标为 $(4,3)$，右上角坐标为 $(9,4)$，每公里移动时间为 $1000$ 分钟。图中标注了从点 $A$ 到点 $B$ 以及从点 $C$ 到点 $D$ 的最短时间路径，它们分别为 $700$ 分钟和 $1000$ 分钟。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ezj1kb5y.png)\n\n你需要实现以下函数：\n\n- `long long shortest_path(pair<int, int> src, pair<int, int> dst, vector<pair<int, int>> p1, vector<pair<int, int>> p2, vector<int> w);`\n\n这个函数只会调用一次。`src` 和 `dst` 分别是起点和终点。每个矩形的左下角坐标在 `p1`，右上角坐标在 `p2`。利用给定的值计算从 `src` 到 `dst` 的最短时间并返回。\n\n函数必须按照上述描述进行操作。当然，你可以创建和使用其他函数，但不得进行任何输入输出操作或访问其他文件。\n\n", "inputFormat": "示例评测程序按以下格式读取输入。$x, y$ 坐标的单位为公里：\n\n- 第 $1$ 行：$N\\,x_{s}\\,y_{s}\\,x_{e}\\,y_{e}$，其中 $N$ 表示矩形的数量，$x_{s}, y_{s}$ 表示起点的 $x$ 和 $y$ 坐标，$x_{e}, y_{e}$ 表示终点的 $x$ 和 $y$ 坐标\n\n- 接下来的 $N$ 行：每行给出一个矩形的坐标和移动时间 $x_{1}\\,y_{1}\\,x_{2}\\,y_{2}\\,w$，其中 $x_{1}, y_{1}$ 表示矩形左下角的 $x$ 和 $y$ 坐标，$x_{2},y_{2}$ 表示矩形右上角的 $x$ 和 $y$ 坐标，$w$ 表示矩形内部的 $1$ 公里移动时间\n\n", "outputFormat": "示例评测程序会输出 `shortest_path` 函数的返回值。\n\n", "hint": "对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 10^5$\n- $100 \\leq w \\leq 10^{8}$\n- $0 \\leq x, y \\leq 10^{8}$（$x, y$ 是起点、终点或矩形的顶点坐标）\n- $N, w, x, y$ 都是整数\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$23$|$N \\leq 500$|\n|$2$|$35$|$N \\leq 5000$|\n|$3$|$31$|$x_{2} - x_{1} = 1$|\n|$4$|$61$|无附加限制|", "locale": "zh-CN"}}}
{"pid": "P12590", "type": "P", "difficulty": 2, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": [], "title": "橙色预警嘻", "background": "### 在本次比赛中，每道题目均可以多次提交答案，系统以最后一次提交为准计算分数。在比赛结束前，你无法获知你的分数。\n\n### 为避免自动识别语言产生失误，建议每道题目都自行选择代码的提交语言，避免产生意外失分。\n\n### Python 选手建议使用 PyPy3 提交本场比赛的编程题，可能会获得更高的效率。需要注意，PyPy3 无 NumPy 库支持，请根据个人所需选择 Python3 或 PyPy3。\n\n---\n![](https://cdn.luogu.com.cn/upload/image_hosting/xhvb1cc1.png)\n\n橙色预警！@dadaaa 在嘻嘻！", "description": "给定一个序列 $a_n=3^n+5^n(n \\geq 1)$，求最小的正整数 $m$ 使得存在正整数 $t \\geq 1$ 对于所有的正整数 $n \\geq m+t$ 都满足 $a_n \\equiv a_{n-m} \\pmod{10^5}$。", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只需要**编写一个程序输出这个整数**，输出多余的内容将无法得分。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "橙色预警嘻", "background": "### 在本次比赛中，每道题目均可以多次提交答案，系统以最后一次提交为准计算分数。在比赛结束前，你无法获知你的分数。\n\n### 为避免自动识别语言产生失误，建议每道题目都自行选择代码的提交语言，避免产生意外失分。\n\n### Python 选手建议使用 PyPy3 提交本场比赛的编程题，可能会获得更高的效率。需要注意，PyPy3 无 NumPy 库支持，请根据个人所需选择 Python3 或 PyPy3。\n\n---\n![](https://cdn.luogu.com.cn/upload/image_hosting/xhvb1cc1.png)\n\n橙色预警！@dadaaa 在嘻嘻！", "description": "给定一个序列 $a_n=3^n+5^n(n \\geq 1)$，求最小的正整数 $m$ 使得存在正整数 $t \\geq 1$ 对于所有的正整数 $n \\geq m+t$ 都满足 $a_n \\equiv a_{n-m} \\pmod{10^5}$。", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只需要**编写一个程序输出这个整数**，输出多余的内容将无法得分。", "hint": "", "locale": "zh-CN"}}}
