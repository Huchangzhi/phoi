{"pid": "P10613", "type": "P", "difficulty": 6, "samples": [["3 2", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2008", "O2优化", "背包 DP", "根号分治", "PA（波兰）"], "title": "[PA 2008] Cliquers", "background": "", "description": "统计结点个数为 $n$，且每一个连通分量都是完全图的本质不同的图的个数 $x$。\n\n求 $m^x \\bmod P$，其中 $P=10^9-401$ 为一个质数。", "inputFormat": "一行两个整数，分别为 $n,m$。", "outputFormat": "一行一个整数，表示所求的结果。", "hint": "**【样例解释】**\n\n当 $n=3$ 时，$3$ 种情况如下图所示。注意您应当输出的是 $m^x \\bmod P=2^3 \\bmod (10^9-401)$ 的值。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oeqoqluo.png)\n\n**【数据范围】**\n\n对于所有数据，$1\\leq n,m\\leq 2\\times 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2008] Cliquers", "background": "", "description": "统计结点个数为 $n$，且每一个连通分量都是完全图的本质不同的图的个数 $x$。\n\n求 $m^x \\bmod P$，其中 $P=10^9-401$ 为一个质数。", "inputFormat": "一行两个整数，分别为 $n,m$。", "outputFormat": "一行一个整数，表示所求的结果。", "hint": "**【样例解释】**\n\n当 $n=3$ 时，$3$ 种情况如下图所示。注意您应当输出的是 $m^x \\bmod P=2^3 \\bmod (10^9-401)$ 的值。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oeqoqluo.png)\n\n**【数据范围】**\n\n对于所有数据，$1\\leq n,m\\leq 2\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P10614", "type": "P", "difficulty": 6, "samples": [["1\nGTC\n10", "1\n22783\n528340\n497452"]], "limits": {"time": [3000], "memory": [524288]}, "tags": ["字符串", "O2优化", "有限状态自动机", "DP 套 DP"], "title": "BZOJ3864 Hero meet devil", "background": "", "description": "给定一个字符集为 `ACGT` 的字符串 $S$。定义 $\\text{LCS}(S,T)$ 为两个字符串 $S,T$ 的最长公共子序列。\n\n对于每个 $0\\leq i \\leq |S|$，求有多少个长度为 $m$，字符集 `ACGT` 的字符串 $T$，满足 $|\\text{LCS}(S,T)|=i$，答案对 $10^9+7$ 取模。", "inputFormat": "第一行一个整数 $T$ 表示数据组数。\n\n对于每组数据，第一行一个字符串 $S$，第二行一个整数 $m$。", "outputFormat": "对于每组数据，输出 $i=0,1,\\dots,|S|$ 时的答案，每个占一行。", "hint": "对于 $100\\%$ 的数据，保证 $1\\leq T\\leq 5$，$1\\leq |S| \\leq 15$，$1\\leq m\\leq 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ3864 Hero meet devil", "background": "", "description": "给定一个字符集为 `ACGT` 的字符串 $S$。定义 $\\text{LCS}(S,T)$ 为两个字符串 $S,T$ 的最长公共子序列。\n\n对于每个 $0\\leq i \\leq |S|$，求有多少个长度为 $m$，字符集 `ACGT` 的字符串 $T$，满足 $|\\text{LCS}(S,T)|=i$，答案对 $10^9+7$ 取模。", "inputFormat": "第一行一个整数 $T$ 表示数据组数。\n\n对于每组数据，第一行一个字符串 $S$，第二行一个整数 $m$。", "outputFormat": "对于每组数据，输出 $i=0,1,\\dots,|S|$ 时的答案，每个占一行。", "hint": "对于 $100\\%$ 的数据，保证 $1\\leq T\\leq 5$，$1\\leq |S| \\leq 15$，$1\\leq m\\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P10615", "type": "P", "difficulty": 3, "samples": [["3\nA+00A+A+ 00B+D+A- B-C+00C+", "bounded"], ["1\nK+K-Q+Q", "unbounded"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "并查集", "O2优化", "深度优先搜索 DFS", "图论建模", "ICPC", "Floyd 算法", "WF"], "title": "[ICPC 2013 WF] Self-Assembly", "background": "", "description": "Automatic Chemical Manufacturing is experimenting with a process called self-assembly. In this process, molecules with natural affinity for each other are mixed together in a solution and allowed to spontaneously assemble themselves into larger structures. But there is one problem: sometimes molecules assemble themselves into a structure of unbounded size, which gums up the machinery.\n\nYou must write a program to decide whether a given collection of molecules can be assembled into a structure of unbounded size. You should make two simplifying assumptions: 1) the problem is restricted to two dimensions, and 2) each molecule in the collection is represented as a square. The four edges of the square represent the surfaces on which the molecule can connect to other compatible molecules.\n\nIn each test case, you will be given a set of molecule descriptions. Each type of molecule is described by four two-character *connector labels* that indicate how its edges can connect to the edges of other molecules. There are two types of connector labels:\n\n- An uppercase letter $(A, \\dots , Z)$ followed by $+$ or $−$. Two edges are compatible if their labels have the same letter but different signs. For example, $A+$ is compatible with $A-$ but is not compatible with $A+$ or $B-$.\n- Two zero digits $00$. An edge with this label is not compatible with any edge (not even with another edge labeled $00$).\n\nAssume there is an unlimited supply of molecules of each type, which may be rotated and reflected. As the molecules assemble themselves into larger structures, the edges of two molecules may be adjacent to each other only if they are compatible. It is permitted for an edge, regardless of its connector label, to be connected to nothing (no adjacent molecule on that edge).\n\nFigure A.1 shows an example of three molecule types and a structure of bounded size that can be assembled from them (other bounded structures are also possible with this set of molecules).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kjmni4to.png)", "inputFormat": "The input consists of a single test case. A test case consists of two lines. The first contains an integer $n(1 \\leq n \\leq 40 000)$ indicating the number of molecule types. The second line contains $n$ eight-character strings, each describing a single type of molecule, separated by single spaces. Each string consists of four two-character connector labels representing the four edges of the molecule in clockwise order.", "outputFormat": "Display the word `unbounded` if the set of molecule types can generate a structure of unbounded size.\nOtherwise, display the word `bounded`.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Self-Assembly", "background": "", "description": "Automatic Chemical Manufacturing is experimenting with a process called self-assembly. In this process, molecules with natural affinity for each other are mixed together in a solution and allowed to spontaneously assemble themselves into larger structures. But there is one problem: sometimes molecules assemble themselves into a structure of unbounded size, which gums up the machinery.\n\nYou must write a program to decide whether a given collection of molecules can be assembled into a structure of unbounded size. You should make two simplifying assumptions: 1) the problem is restricted to two dimensions, and 2) each molecule in the collection is represented as a square. The four edges of the square represent the surfaces on which the molecule can connect to other compatible molecules.\n\nIn each test case, you will be given a set of molecule descriptions. Each type of molecule is described by four two-character *connector labels* that indicate how its edges can connect to the edges of other molecules. There are two types of connector labels:\n\n- An uppercase letter $(A, \\dots , Z)$ followed by $+$ or $−$. Two edges are compatible if their labels have the same letter but different signs. For example, $A+$ is compatible with $A-$ but is not compatible with $A+$ or $B-$.\n- Two zero digits $00$. An edge with this label is not compatible with any edge (not even with another edge labeled $00$).\n\nAssume there is an unlimited supply of molecules of each type, which may be rotated and reflected. As the molecules assemble themselves into larger structures, the edges of two molecules may be adjacent to each other only if they are compatible. It is permitted for an edge, regardless of its connector label, to be connected to nothing (no adjacent molecule on that edge).\n\nFigure A.1 shows an example of three molecule types and a structure of bounded size that can be assembled from them (other bounded structures are also possible with this set of molecules).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kjmni4to.png)", "inputFormat": "The input consists of a single test case. A test case consists of two lines. The first contains an integer $n(1 \\leq n \\leq 40 000)$ indicating the number of molecule types. The second line contains $n$ eight-character strings, each describing a single type of molecule, separated by single spaces. Each string consists of four two-character connector labels representing the four edges of the molecule in clockwise order.", "outputFormat": "Display the word `unbounded` if the set of molecule types can generate a structure of unbounded size.\nOtherwise, display the word `bounded`.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Self-Assembly", "background": "", "description": "自动化化学制造正在试验一种称为自组装的过程。在这个过程中，具有天然亲和力的分子被混合在一起，并允许它们自发地组装成更大的结构。但有一个问题：有时分子会自组装成无限大的结构，导致设备故障。\n\n你必须编写一个程序来决定给定的分子集合是否可以组装成一个无限大的结构。你应该做两个简化假设：1）问题仅限于二维，2）集合中的每个分子表示为一个正方形。正方形的四个边代表分子可以连接到其他兼容分子的表面。\n\n在每个测试用例中，你将得到一组分子描述。每种类型的分子由四个两个字符的*连接标签*描述，指示其边缘如何连接到其他分子的边缘。有两种类型的连接标签：\n\n- 一个大写字母 $(A, \\dots , Z)$ 后跟 $+$ 或 $−$。如果两个边的标签具有相同的字母但符号不同，则它们是兼容的。例如，$A+$ 与 $A-$ 兼容，但与 $A+$ 或 $B-$ 不兼容。\n- 两个数字 $00$。带有此标签的边与任何边都不兼容（即使是另一个标记为 $00$ 的边也不兼容）。\n\n假设每种类型的分子都有无限供应，并且可以旋转和反射。随着分子自组装成更大的结构，两个分子的边只有在兼容时才可以相邻。允许边缘（无论其连接标签如何）不连接到任何东西（该边没有相邻分子）。\n\n图 A.1 显示了三种分子类型的示例以及可以从中组装的有限大小结构（使用该分子集也可以组装其他有限结构）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kjmni4to.png)", "inputFormat": "输入由一个测试用例组成。一个测试用例由两行组成。第一行包含一个整数 $n(1 \\leq n \\leq 40 000)$，表示分子类型的数量。第二行包含 $n$ 个八字符的字符串，每个字符串描述一种分子的类型，单个空格分隔。每个字符串由四个两个字符的连接标签组成，按顺时针顺序表示分子的四个边。", "outputFormat": "如果这组分子类型可以生成一个无限大的结构，则显示单词 `unbounded`。否则，显示单词 `bounded`。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10616", "type": "P", "difficulty": 6, "samples": [["0 49.9", "0.0"], ["50 49.85", "7.10178453"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "Special Judge", "O2优化", "ICPC", "WF"], "title": "[ICPC 2013 WF] Hey, Better Bettor", "background": "> “In the casino, the cardinal rule is to keep them playing and to keep them coming back. The\nlonger they play, the more they lose, and in the end, we get it all.”  \n> (from the 1995 film *Casino*)", "description": "Recent recessions have not been kind to entertainment venues, including the gambling industry. Competition is fierce among casinos to attract players with lots of money, and some have begun to offer especially sweet deals. One casino is offering the following: you can gamble as much as you want at the casino. After you are finished, if you are down by any amount from when you started, the casino will refund $x\\%$ of your losses to you. Obviously, if you are ahead, you can keep all of your winnings. There is no time limit or money limit on this offer, but you can redeem it only once.\n\nFor simplicity, assume all bets cost $1$ dollar and pay out $2$ dollars. Now suppose $x$ is $20$. If you make $10$ bets in total before quitting and only $3$ of them pay out, your total loss is $3.2$ dollars. If $6$ of them pay out, you have gained $2$ dollars.\n\nGiven $x$ and the percentage probability $p$ of winning any individual bet, write a program to determine the maximum expected profit you can make from betting at this casino, using any gambling strategy.", "inputFormat": "The input consists of a single test case. A test case consists of the refund percentage $x (0 \\leq x < 100)$ followed by the winning probability percentage $p (0 \\leq p < 50)$. Both $x$ and $p$ have at most two digits after the decimal point.", "outputFormat": "Display the maximum expected profit with an absolute error of at most $10^{-3}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Hey, Better Bettor", "background": "> “In the casino, the cardinal rule is to keep them playing and to keep them coming back. The\nlonger they play, the more they lose, and in the end, we get it all.”  \n> (from the 1995 film *Casino*)", "description": "Recent recessions have not been kind to entertainment venues, including the gambling industry. Competition is fierce among casinos to attract players with lots of money, and some have begun to offer especially sweet deals. One casino is offering the following: you can gamble as much as you want at the casino. After you are finished, if you are down by any amount from when you started, the casino will refund $x\\%$ of your losses to you. Obviously, if you are ahead, you can keep all of your winnings. There is no time limit or money limit on this offer, but you can redeem it only once.\n\nFor simplicity, assume all bets cost $1$ dollar and pay out $2$ dollars. Now suppose $x$ is $20$. If you make $10$ bets in total before quitting and only $3$ of them pay out, your total loss is $3.2$ dollars. If $6$ of them pay out, you have gained $2$ dollars.\n\nGiven $x$ and the percentage probability $p$ of winning any individual bet, write a program to determine the maximum expected profit you can make from betting at this casino, using any gambling strategy.", "inputFormat": "The input consists of a single test case. A test case consists of the refund percentage $x (0 \\leq x < 100)$ followed by the winning probability percentage $p (0 \\leq p < 50)$. Both $x$ and $p$ have at most two digits after the decimal point.", "outputFormat": "Display the maximum expected profit with an absolute error of at most $10^{-3}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Hey, Better Bettor", "background": "", "description": "> “在赌场里，首要规则是让他们继续玩，让他们不断回来。他们玩得越久，输得越多，最终，我们会赢得一切。”  \n> （摘自 1995 年电影《赌场》）\n\n最近的经济衰退对包括赌博业在内的娱乐场所并不友好。赌场之间竞争激烈，以吸引有钱的玩家，一些赌场开始提供特别优厚的优惠。其中一个赌场提供以下优惠：你可以在赌场里随意赌博。当你结束时，如果你比开始时输了任何金额，赌场将退还你损失的 $x\\%$。显然，如果你赢钱了，你可以保留所有的奖金。此优惠没有时间限制或金额限制，但你只能兑现一次。\n\n为了简化，假设所有赌注的成本为 $1$ 美元，并支付 $2$ 美元。现在假设 $x$ 是 $20$。如果你在退出前总共下注 $10$ 次，只有 $3$ 次获胜，你的总损失是 $3.2$ 美元。如果 $6$ 次获胜，你就赚了 $2$ 美元。\n\n给定 $x$ 和赢得任何单个赌注的概率百分比 $p$，编写一个程序来确定你在这个赌场下注所能获得的最大期望利润，使用任何赌博策略。\n\n输入由一个单一的测试用例组成。测试用例包含退款百分比 $x (0 \\leq x < 100)$，随后是赢得概率百分比 $p (0 \\leq p < 50)$。$x$ 和 $p$ 的小数点后最多有两位数字。\n\n显示最大期望利润，绝对误差不超过 $10^{-3}$。", "inputFormat": "输入由一个单一的测试用例组成。测试用例包含退款百分比 $x (0 \\leq x < 100)$，随后是赢得概率百分比 $p (0 \\leq p < 50)$。$x$ 和 $p$ 的小数点后最多有两位数字。", "outputFormat": "输出最大期望利润，绝对误差不超过 $10^{-3}$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10617", "type": "P", "difficulty": 0, "samples": [["3 3 2\n1 2 42\n2 3 1\n2 3 1\n2 3", "2"], ["4 4 5\n1 2 5\n1 3 4\n4 2 5\n4 3 6\n4 4 4 4 1", "3"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "O2优化", "ICPC", "WF"], "title": "[ICPC 2013 WF] Surely You Congest", "background": "", "description": "You are in charge of designing an advanced centralized traffic management system for smart cars. The goal is to use global information to instruct morning commuters, who must drive downtown from the suburbs, how best to get to the city center while avoiding traffic jams.\n\nUnfortunately, since commuters know the city and are selfish, you cannot simply tell them to travel routes that take longer than normal (otherwise they will just ignore your directions). You can only convince them to change to different routes that are equally fast.\n\nThe city’s network of roads consists of intersections that are connected by bidirectional roads of various travel times. Each commuter starts at some intersection, which may vary from commuter to commuter. All commuters end their journeys at the same place, which is downtown at intersection 1. If two commuters attempt to start travelling along the same road in the same direction at the same time, there will be congestion; you must avoid this. However, it is fine if two commuters pass through the same intersection simultaneously or if they take the same road starting at different times.\n\nDetermine the maximum number of commuters who can drive downtown without congestion, subject to all commuters starting their journeys at exactly the same time and without any of them taking a suboptimal route.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/74bo2ud4.png)\n\nIn Figure C.1, cars are shown in their original locations. One car is already downtown. Of the cars at intersection 4, one can go along the dotted route through intersection 3, and another along the dashed route through intersection 2. But the remaining two cars cannot reach downtown while avoiding congestion. So a maximum of 3 cars can reach downtown with no congestion.", "inputFormat": "The input consists of a single test case. The first line contains three integers $n, m,$ and $c$, where $n (1 \\leq n \\leq 25 000)$ is the number of intersections, $m (0 \\leq m \\leq 50 000)$ is the number of roads, and $c (0 \\leq c \\leq 1 000)$ is the number of commuters. Each of the next $m$ lines contains three integers $x_i, y_i$, and $t_i$ describing one road, where $x_i$ and $y_i (1 \\leq x_i, y_i \\leq n)$ are the distinct intersections the road connects, and $t_i (1 \\leq t_i \\leq 10 000)$ is the time it takes to travel along that road in either direction. You may assume that downtown is reachable from every intersection. The last line contains $c$ integers listing the starting intersections of the commuters.", "outputFormat": "Display the maximum number of commuters who can reach downtown without congestion.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Surely You Congest", "background": "", "description": "You are in charge of designing an advanced centralized traffic management system for smart cars. The goal is to use global information to instruct morning commuters, who must drive downtown from the suburbs, how best to get to the city center while avoiding traffic jams.\n\nUnfortunately, since commuters know the city and are selfish, you cannot simply tell them to travel routes that take longer than normal (otherwise they will just ignore your directions). You can only convince them to change to different routes that are equally fast.\n\nThe city’s network of roads consists of intersections that are connected by bidirectional roads of various travel times. Each commuter starts at some intersection, which may vary from commuter to commuter. All commuters end their journeys at the same place, which is downtown at intersection 1. If two commuters attempt to start travelling along the same road in the same direction at the same time, there will be congestion; you must avoid this. However, it is fine if two commuters pass through the same intersection simultaneously or if they take the same road starting at different times.\n\nDetermine the maximum number of commuters who can drive downtown without congestion, subject to all commuters starting their journeys at exactly the same time and without any of them taking a suboptimal route.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/74bo2ud4.png)\n\nIn Figure C.1, cars are shown in their original locations. One car is already downtown. Of the cars at intersection 4, one can go along the dotted route through intersection 3, and another along the dashed route through intersection 2. But the remaining two cars cannot reach downtown while avoiding congestion. So a maximum of 3 cars can reach downtown with no congestion.", "inputFormat": "The input consists of a single test case. The first line contains three integers $n, m,$ and $c$, where $n (1 \\leq n \\leq 25 000)$ is the number of intersections, $m (0 \\leq m \\leq 50 000)$ is the number of roads, and $c (0 \\leq c \\leq 1 000)$ is the number of commuters. Each of the next $m$ lines contains three integers $x_i, y_i$, and $t_i$ describing one road, where $x_i$ and $y_i (1 \\leq x_i, y_i \\leq n)$ are the distinct intersections the road connects, and $t_i (1 \\leq t_i \\leq 10 000)$ is the time it takes to travel along that road in either direction. You may assume that downtown is reachable from every intersection. The last line contains $c$ integers listing the starting intersections of the commuters.", "outputFormat": "Display the maximum number of commuters who can reach downtown without congestion.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Surely You Congest", "background": "", "description": "你负责设计一个先进的集中交通管理系统，以便为智能汽车提供服务。目标是利用全局信息指导早晨从郊区驾车前往市中心的通勤者，帮助他们避免交通拥堵。\n\n不幸的是，由于通勤者了解城市且自私，你不能简单地让他们走比平时更慢的路线（否则他们会忽略你的指示）。你只能说服他们改变到同样快的不同路线。\n\n城市的道路网络由连接双向道路的交叉口组成，各条道路的行驶时间不同。每个通勤者从某个交叉口出发，这些交叉口因人而异。所有通勤者的行程终点都是市中心的 1 号交叉口。如果两名通勤者同时在同一方向上行驶在同一条道路上，会造成拥堵；你必须避免这种情况。然而，如果两名通勤者同时经过同一个交叉口或者在不同时间使用同一条道路，这是允许的。\n\n确定在所有通勤者同时开始旅程且没有任何人走次优路线的情况下，最多有多少通勤者可以在不拥堵的情况下开车到市中心。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/74bo2ud4.png)", "inputFormat": "输入由一个单独的测试用例组成。第一行包含三个整数 $n, m, c$，其中 $n (1 \\leq n \\leq 25 000)$ 表示交叉口的数量，$m (0 \\leq m \\leq 50 000)$ 表示道路的数量，$c (0 \\leq c \\leq 1 000)$ 表示通勤者的数量。接下来的 $m$ 行中的每一行包含三个整数 $x_i, y_i, t_i$，描述了一条道路，其中 $x_i$ 和 $y_i (1 \\leq x_i, y_i \\leq n)$ 是道路连接的不同交叉口，$t_i (1 \\leq t_i \\leq 10 000)$ 是沿该道路行驶的时间。最后一行包含 $c$ 个整数，列出了通勤者的起始交叉口。", "outputFormat": "显示最多有多少通勤者可以在不拥堵的情况下到达市中心。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10618", "type": "P", "difficulty": 5, "samples": [["1\n2\n3\n105", "1 2\n2 6\n3 12\n105 720"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "2013", "O2优化", "剪枝", "ICPC", "WF"], "title": "[ICPC 2013 WF] Factors", "background": "", "description": "The fundamental theorem of arithmetic states that every integer greater than $1$ can be uniquely represented as a product of one or more primes. While unique, several arrangements of the prime factors may be possible. For example:\n\n- $10=2\\times 5=5\\times 2$；\n- $20=2\\times 2\\times 5=2\\times 5\\times 2=5\\times 2\\times 2$；\n\nLet $f(k)$ be the number of different arrangements of the prime factors of $k$. So $f(10) = 2$ and $f(20) = 3$.\n\nGiven a positive number $n$, there always exists at least one number $k$ such that $f(k) = n$. We want to know the smallest such $k$.", "inputFormat": "The input consists of at most $1 000$ test cases, each on a separate line. Each test case is a positive integer $n < 2^{63}$.", "outputFormat": "For each test case, display its number $n$ and the smallest number $k > 1$ such that $f(k) = n$. The numbers in the input are chosen such that $k < 2^{63}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Factors", "background": "", "description": "The fundamental theorem of arithmetic states that every integer greater than $1$ can be uniquely represented as a product of one or more primes. While unique, several arrangements of the prime factors may be possible. For example:\n\n- $10=2\\times 5=5\\times 2$；\n- $20=2\\times 2\\times 5=2\\times 5\\times 2=5\\times 2\\times 2$；\n\nLet $f(k)$ be the number of different arrangements of the prime factors of $k$. So $f(10) = 2$ and $f(20) = 3$.\n\nGiven a positive number $n$, there always exists at least one number $k$ such that $f(k) = n$. We want to know the smallest such $k$.", "inputFormat": "The input consists of at most $1 000$ test cases, each on a separate line. Each test case is a positive integer $n < 2^{63}$.", "outputFormat": "For each test case, display its number $n$ and the smallest number $k > 1$ such that $f(k) = n$. The numbers in the input are chosen such that $k < 2^{63}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Factors", "background": "", "description": "算术基本定理指出，每个大于 $1$ 的整数都可以唯一表示为一个或多个素数的乘积。虽然表示是唯一的，但素数因子的排列可能有多种。例如：\n\n- $10=2\\times 5=5\\times 2$；\n- $20=2\\times 2\\times 5=2\\times 5\\times 2=5\\times 2\\times 2$；\n\n令 $f(k)$ 为 $k$ 的素数因子不同排列的数量。因此，$f(10) = 2$ 且 $f(20) = 3$。\n\n给定一个正整数 $n$，总是至少存在一个数字 $k$ 使得 $f(k) = n$。我们想知道最小的这样的 $k$。", "inputFormat": "输入包含最多 $1 000$ 个测试用例，每个测试用例占一行。每个测试用例是一个正整数 $n < 2^{63}$。", "outputFormat": "对于每个测试用例，输出其数字 $n$ 以及最小的 $k > 1$ 使得 $f(k) = n$。输入中的数字选择使得 $k < 2^{63}$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10619", "type": "P", "difficulty": 0, "samples": [["1 2\nV1 V2 V1 V1 V2", "5"], ["2 1\nV1 V2 V1 V1 V2", "6"], ["1 2\nR10 V1 V2 V1 E", "30"], ["4 1\nV1 R2 V2 V4 R2 V1 E V3 E", "17"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "O2优化", "ICPC", "WF"], "title": "[ICPC 2013 WF] Harvard", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/hb9vxjp8.png)", "description": "The term “Harvard architecture” applies to a computer that has physically separate memories for instructions and data. The term originated with the Harvard Mark I computer, delivered by IBM in 1944, which used paper tape for instructions and relays for data.\n\nSome modern microcontrollers use the Harvard architecture – but not paper tape and relays! Data memory is organized in banks, each containing the same number of data items. Each data-referencing instruction has a byte offset $f$ to a bank, and a bit $a$ that is used to select the bank to be referenced. If $a$ is $0$, then bank $0$ is referenced. If $a$ is $1$, then the value in a *bank select register* (BSR) identifies the bank to be used. Assume each instruction takes the same time to execute, and there is an instruction that can set the BSR’s value.\n\nFor example, suppose there are $4$ banks of $8$ bytes each. To access location $5$, either use a single instruction with $a = 0$ and $f = 5$, or set the BSR to $0$ in one instruction and then use an instruction with $a = 1$ and $f = 5$. The first approach is faster since it does not require setting the BSR.\n\nNow suppose (with the same memory) the location to access is $20$. Only one approach will work here: execute an instruction that sets the BSR to $2$ (unless the BSR already has the value $2$) and then use an instruction with $a = 1$ and $f = 4$.\n\nA program is a sequence of operations. Each operation is either\n\n- a variable reference, written as V$i$, where $i$ is a positive integer, or\n- a repetition, written as R$n$ `<program>` E, where $n$ is a positive integer and `<program>` is an arbitrary program. This operation is equivalent to n sequential occurrences of `<program>`.\n\nYour problem is to determine the minimum running time of programs. In particular, given the number and size of the memory banks and a program to be executed, find the minimum number of instructions (which reference memory location and possibly set the BSR) that must be executed to run the program. To do this you must identify a mapping of variables to memory banks that yields the smallest execution time, and report that execution time – that is, the number of memory references and BSR register settings required. The BSR’s value is initially undefined, and changes only when an instruction explicitly sets its value.", "inputFormat": "The input consists of a single test case. A test case consists of two lines. The first line contains two integers $b$ and $s$, where $1 \\leq b \\leq 13$ is the number of memory banks and $1 \\leq s \\leq 13$ is the number of variables that can be stored in each memory bank. The second line contains a non-empty program with at most $1 000$ space-separated elements (each R$n$, V$i$, and E counts as one element).\n\nYou may assume the following:\n- In a repetition R$n$, the number of repetitions satisfies $1 \\leq n \\leq 10^6$.\n- In a loop operation R$n$ `<program>` E, the loop body `<program>` is not empty.\n- In a variable reference V$i$, the variable index satisfies $1 \\leq i \\leq \\min(b \\times s, 13)$.\n- The total number of variable references performed by an execution of the program is at most $10^{12}$.", "outputFormat": "Display the minimum number of instructions that must be executed to complete the program.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Harvard", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/hb9vxjp8.png)", "description": "The term “Harvard architecture” applies to a computer that has physically separate memories for instructions and data. The term originated with the Harvard Mark I computer, delivered by IBM in 1944, which used paper tape for instructions and relays for data.\n\nSome modern microcontrollers use the Harvard architecture – but not paper tape and relays! Data memory is organized in banks, each containing the same number of data items. Each data-referencing instruction has a byte offset $f$ to a bank, and a bit $a$ that is used to select the bank to be referenced. If $a$ is $0$, then bank $0$ is referenced. If $a$ is $1$, then the value in a *bank select register* (BSR) identifies the bank to be used. Assume each instruction takes the same time to execute, and there is an instruction that can set the BSR’s value.\n\nFor example, suppose there are $4$ banks of $8$ bytes each. To access location $5$, either use a single instruction with $a = 0$ and $f = 5$, or set the BSR to $0$ in one instruction and then use an instruction with $a = 1$ and $f = 5$. The first approach is faster since it does not require setting the BSR.\n\nNow suppose (with the same memory) the location to access is $20$. Only one approach will work here: execute an instruction that sets the BSR to $2$ (unless the BSR already has the value $2$) and then use an instruction with $a = 1$ and $f = 4$.\n\nA program is a sequence of operations. Each operation is either\n\n- a variable reference, written as V$i$, where $i$ is a positive integer, or\n- a repetition, written as R$n$ `<program>` E, where $n$ is a positive integer and `<program>` is an arbitrary program. This operation is equivalent to n sequential occurrences of `<program>`.\n\nYour problem is to determine the minimum running time of programs. In particular, given the number and size of the memory banks and a program to be executed, find the minimum number of instructions (which reference memory location and possibly set the BSR) that must be executed to run the program. To do this you must identify a mapping of variables to memory banks that yields the smallest execution time, and report that execution time – that is, the number of memory references and BSR register settings required. The BSR’s value is initially undefined, and changes only when an instruction explicitly sets its value.", "inputFormat": "The input consists of a single test case. A test case consists of two lines. The first line contains two integers $b$ and $s$, where $1 \\leq b \\leq 13$ is the number of memory banks and $1 \\leq s \\leq 13$ is the number of variables that can be stored in each memory bank. The second line contains a non-empty program with at most $1 000$ space-separated elements (each R$n$, V$i$, and E counts as one element).\n\nYou may assume the following:\n- In a repetition R$n$, the number of repetitions satisfies $1 \\leq n \\leq 10^6$.\n- In a loop operation R$n$ `<program>` E, the loop body `<program>` is not empty.\n- In a variable reference V$i$, the variable index satisfies $1 \\leq i \\leq \\min(b \\times s, 13)$.\n- The total number of variable references performed by an execution of the program is at most $10^{12}$.", "outputFormat": "Display the minimum number of instructions that must be executed to complete the program.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Harvard", "background": "", "description": "“哈佛架构”一词适用于指令和数据具有物理上分开的存储器的计算机。该术语起源于哈佛 Mark I 计算机，由 IBM 于 1944 年交付，该计算机使用纸带作为指令，使用继电器作为数据。\n\n一些现代微控制器使用哈佛架构——但不使用纸带和继电器！数据存储器被组织成多个存储区（bank），每个存储区包含相同数量的数据项。每条引用数据的指令都有一个字节偏移量 $f$ 和一个位 $a$，用于选择要引用的存储区。如果 $a$ 为 $0$，则引用存储区 $0$。如果 $a$ 为 $1$，则在*存储区选择寄存器*（BSR）中的值标识要使用的存储区。假设每条指令执行时间相同，并且存在可以设置 BSR 值的指令。\n\n例如，假设有 $4$ 个存储区，每个存储区有 $8$ 个字节。要访问位置 $5$，可以使用 $a = 0$ 和 $f = 5$ 的单条指令，或者在一条指令中将 BSR 设置为 $0$，然后使用 $a = 1$ 和 $f = 5$ 的指令。第一种方法更快，因为它不需要设置 BSR。\n\n现在假设（使用相同的存储器）要访问的位置是 $20$。这里只能使用一种方法：执行一条指令将 BSR 设置为 $2$（除非 BSR 已经是 $2$），然后使用 $a = 1$ 和 $f = 4$ 的指令。\n\n程序是操作的序列。每个操作可以是\n\n- 变量引用，写作 V$i$，其中 $i$ 是正整数，或\n- 重复，写作 R$n$ `<program>` E，其中 $n$ 是正整数，`<program>` 是任意程序。此操作相当于 `<program>` 的 n 次连续出现。\n\n你的任务是确定程序的最小运行时间。具体来说，给定内存存储区的数量和大小以及要执行的程序，找出必须执行的最小指令数（引用内存位置和可能设置 BSR），以运行程序。为此，你必须确定将变量映射到存储区的方式，以产生最小的执行时间，并报告该执行时间——即完成程序所需的内存引用和 BSR 寄存器设置的数量。BSR 的值最初未定义，仅在指令显式设置其值时更改。", "inputFormat": "输入包含一个测试用例。测试用例包含两行。第一行包含两个整数 $b$ 和 $s$，其中 $1 \\leq b \\leq 13$ 是存储区的数量，$1 \\leq s \\leq 13$ 是每个存储区可以存储的变量数。第二行包含一个非空程序，最多包含 $1 000$ 个用空格分隔的元素（每个 R$n$, V$i$ 和 E 都算作一个元素）。\n\n你可以假设以下几点：\n- 在重复 R$n$ 中，重复次数满足 $1 \\leq n \\leq 10^6$。\n- 在循环操作 R$n$ `<program>` E 中，循环体 `<program>` 不为空。\n- 在变量引用 V$i$ 中，变量索引满足 $1 \\leq i \\leq \\min(b \\times s, 13)$。\n- 程序执行的总变量引用数最多为 $10^{12}$。", "outputFormat": "显示完成程序所需执行的最小指令数。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10620", "type": "P", "difficulty": 4, "samples": [["2 3\n1 2 3 4 5 6 7 8 9 10 11 12", "1"], ["2 2\n3 1 3 3 3 3 3 3", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "二分", "O2优化", "ICPC", "WF"], "title": "[ICPC 2013 WF] Low Power", "background": "", "description": "You are building advanced chips for machines. Making the chips is easy, but the power supply turns out to be an issue since the available batteries have varied power outputs.\n\nConsider the problem of $n$ machines, each with two chips, where each chip is powered by $k$ batteries. Surprisingly, it does not matter how much power each chip gets, but a machine works best when its two chips have power outputs as close as possible. The power output of a chip is simply the smallest power output of its $k$ batteries.\n\nYou have a stockpile of 2nk batteries that you want to assign to the chips. It might not be possible to allocate the batteries so that in every machine both chips have equal power outputs, but you want to allocate them so that the differences are as small as possible. To be precise, you want to tell your customers that in all machines the difference of power outputs of the two chips is at most $d$, and you want to make $d$ as small as possible. To do this you must determine an optimal allocation of the batteries to the machines.\n\nConsider Sample Input $1$. There are $2$ machines, each requiring $3$ batteries per chip, and a supply of batteries with power outputs $1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12$. You can, for instance, assign the batteries with power outputs $1, 3, 5$ to one chip, those with power $2, 4, 12$ to the other chip of the same machine, those with power $6, 8, 9$ to the third chip, and those with power $7, 10, 11$ to the fourth. The power outputs of the chips are $1, 2, 6,$ and $7$, respectively, and the difference between power outputs is $1$ in both machines. Note that there are many other ways to achieve this result.", "inputFormat": "The input consists of a single test case. A test case consists of two lines. The first line contains two positive integers: the number of machines $n$ and the number of batteries per chip $k (2nk \\leq 10^6)$. The second line contains $2nk$ integers $p_i$ specifying the power outputs of the batteries $(1 \\leq p_i \\leq 10^9)$.", "outputFormat": "Display the smallest number $d$ such that you can allocate the batteries so that the difference of power outputs of the two chips in each machine is at most $d$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Low Power", "background": "", "description": "You are building advanced chips for machines. Making the chips is easy, but the power supply turns out to be an issue since the available batteries have varied power outputs.\n\nConsider the problem of $n$ machines, each with two chips, where each chip is powered by $k$ batteries. Surprisingly, it does not matter how much power each chip gets, but a machine works best when its two chips have power outputs as close as possible. The power output of a chip is simply the smallest power output of its $k$ batteries.\n\nYou have a stockpile of 2nk batteries that you want to assign to the chips. It might not be possible to allocate the batteries so that in every machine both chips have equal power outputs, but you want to allocate them so that the differences are as small as possible. To be precise, you want to tell your customers that in all machines the difference of power outputs of the two chips is at most $d$, and you want to make $d$ as small as possible. To do this you must determine an optimal allocation of the batteries to the machines.\n\nConsider Sample Input $1$. There are $2$ machines, each requiring $3$ batteries per chip, and a supply of batteries with power outputs $1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12$. You can, for instance, assign the batteries with power outputs $1, 3, 5$ to one chip, those with power $2, 4, 12$ to the other chip of the same machine, those with power $6, 8, 9$ to the third chip, and those with power $7, 10, 11$ to the fourth. The power outputs of the chips are $1, 2, 6,$ and $7$, respectively, and the difference between power outputs is $1$ in both machines. Note that there are many other ways to achieve this result.", "inputFormat": "The input consists of a single test case. A test case consists of two lines. The first line contains two positive integers: the number of machines $n$ and the number of batteries per chip $k (2nk \\leq 10^6)$. The second line contains $2nk$ integers $p_i$ specifying the power outputs of the batteries $(1 \\leq p_i \\leq 10^9)$.", "outputFormat": "Display the smallest number $d$ such that you can allocate the batteries so that the difference of power outputs of the two chips in each machine is at most $d$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Low Power", "background": "", "description": "你正在为机器制造先进的芯片。制造芯片很容易，但电源供应却成为了一个问题，因为现有电池的输出功率各不相同。\n\n考虑 $n$ 台机器的问题，每台机器有两个芯片，每个芯片由 $k$ 块电池供电。出人意料的是，每个芯片获得的电量多少并不重要，但机器在两个芯片的功率输出尽可能接近时工作效果最佳。芯片的功率输出仅为其 $k$ 块电池中输出功率最小的那块电池的输出。\n\n你有一堆共 $2nk$ 块电池，你需要将它们分配给这些芯片。可能无法分配这些电池使得每台机器的两个芯片的功率输出都相等，但你希望尽量减小它们之间的差异。具体来说，你希望告诉客户，所有机器中两个芯片的功率输出差异至多为 $d$，并且你希望使 $d$ 尽可能小。为此，你必须确定电池分配给机器的最优方案。\n\n考虑样例输入 $1$。有 $2$ 台机器，每个芯片需要 $3$ 块电池，有一组功率输出为 $1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12$ 的电池。你可以例如将输出功率为 $1, 3, 5$ 的电池分配给一个芯片，将输出功率为 $2, 4, 12$ 的电池分配给同一机器的另一个芯片，将输出功率为 $6, 8, 9$ 的电池分配给第三个芯片，将输出功率为 $7, 10, 11$ 的电池分配给第四个芯片。芯片的功率输出分别为 $1, 2, 6, 7$，两台机器中功率输出的差异分别为 $1$。注意，还有许多其他方式可以实现这一结果。", "inputFormat": "输入包含一个测试用例。测试用例包含两行。第一行包含两个正整数：机器的数量 $n$ 和每个芯片所需的电池数 $k$ $(2nk \\leq 10^6)$。第二行包含 $2nk$ 个整数 $p_i$，指定电池的功率输出 $(1 \\leq p_i \\leq 10^9)$。", "outputFormat": "输出一个最小的数字 $d$，使你可以分配这些电池，使每台机器中两个芯片的功率输出差异至多为 $d$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10621", "type": "P", "difficulty": 7, "samples": [["12 9 9\n1 8\n1 16\n6 16\n9 29\n19 31\n23 24\n30 23\n29 18\n20 12\n22 8\n14 0\n14 8", "10"], ["4 5 7\n10 10\n15 10\n15 17\n10 17", "1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "O2优化", "ICPC", "WF"], "title": "[ICPC 2013 WF] Map Tiles", "background": "", "description": "Publishing maps is not an easy task. First you need some appropriate transformation to display the earth’s spherical shape in a two-dimensional plane. Then another issue arises – most high-quality maps are too large to be printed on a single page of paper. To cope with that, map publishers often split maps into several rectangular tiles, and print each tile on one page. In this problem, you will examine this “tiling” process.\n\nThe International Cartographic Publishing Company (ICPC) needs to cut their printing costs by minimizing the number of tiles used for their maps. Even with a fixed tile size (determined by the page size) and map scale, you can still optimize the situation by adjusting the tile grid.\nThe left side of Figure G.1 shows 14 map tiles covering a region. The right side shows how you can cover the same region with only 10 tiles, without changing the tile sizes or orientation.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a9a9dj7t.png)\n\nYour task is to help the ICPC find the minimum number of tiles needed to cover a given region. For simplicity, the region will be given as a closed polygon that does not intersect itself. \n\nNote that the tiles must be part of a rectangular grid aligned with the $x$-axis and $y$-axis. That is, they touch each other only with their whole sides and cannot be rotated. Also note that although all input coordinates are integers, tiles may be located at non-integer coordinates.\n\nThe polygon may touch the edges of marginal lines (as in Sample Input 2). However, to avoid floatingpoint issues, you may assume the optimal answer will not change even if the polygon is allowed to go outside the map tiles by a distance of $10^{-6}$.", "inputFormat": "The input consists of a single test case. The first line of a test case contains three integers: $n, x_s$, and $y_s$. The number of polygon vertices is $n (3 \\leq n \\leq 50)$, and $x_s$ and $y_s (1 \\leq x_s, y_s \\leq 100)$ are the dimensions of each tile. Each of the next $n$ lines contains two integers $x$ and $y (0 \\leq x \\leq 10x_s, 0 \\leq y \\leq 10y_s)$, specifying the vertices of the polygon representing the region (in either clockwise or counter-clockwise order).", "outputFormat": "Display the minimal number of tiles necessary to cover the whole interior of the polygon.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Map Tiles", "background": "", "description": "Publishing maps is not an easy task. First you need some appropriate transformation to display the earth’s spherical shape in a two-dimensional plane. Then another issue arises – most high-quality maps are too large to be printed on a single page of paper. To cope with that, map publishers often split maps into several rectangular tiles, and print each tile on one page. In this problem, you will examine this “tiling” process.\n\nThe International Cartographic Publishing Company (ICPC) needs to cut their printing costs by minimizing the number of tiles used for their maps. Even with a fixed tile size (determined by the page size) and map scale, you can still optimize the situation by adjusting the tile grid.\nThe left side of Figure G.1 shows 14 map tiles covering a region. The right side shows how you can cover the same region with only 10 tiles, without changing the tile sizes or orientation.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a9a9dj7t.png)\n\nYour task is to help the ICPC find the minimum number of tiles needed to cover a given region. For simplicity, the region will be given as a closed polygon that does not intersect itself. \n\nNote that the tiles must be part of a rectangular grid aligned with the $x$-axis and $y$-axis. That is, they touch each other only with their whole sides and cannot be rotated. Also note that although all input coordinates are integers, tiles may be located at non-integer coordinates.\n\nThe polygon may touch the edges of marginal lines (as in Sample Input 2). However, to avoid floatingpoint issues, you may assume the optimal answer will not change even if the polygon is allowed to go outside the map tiles by a distance of $10^{-6}$.", "inputFormat": "The input consists of a single test case. The first line of a test case contains three integers: $n, x_s$, and $y_s$. The number of polygon vertices is $n (3 \\leq n \\leq 50)$, and $x_s$ and $y_s (1 \\leq x_s, y_s \\leq 100)$ are the dimensions of each tile. Each of the next $n$ lines contains two integers $x$ and $y (0 \\leq x \\leq 10x_s, 0 \\leq y \\leq 10y_s)$, specifying the vertices of the polygon representing the region (in either clockwise or counter-clockwise order).", "outputFormat": "Display the minimal number of tiles necessary to cover the whole interior of the polygon.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Map Tiles", "background": "", "description": "出版地图并非易事。首先，你需要进行适当的变换，以在二维平面上显示地球的球形形状。接着出现另一个问题——大多数高质量的地图都太大，无法印在一页纸上。为了解决这个问题，地图出版商通常将地图分割成若干个矩形块，并在每页上打印一个块。在这个问题中，你将研究这种“瓦片化”过程。\n\n国际制图出版公司（ICPC）需要通过最小化用于其地图的瓦片数量来削减印刷成本。即使固定了瓦片大小（由页面大小决定）和地图比例，你仍然可以通过调整瓦片网格来优化情况。图 G.1 的左侧显示了覆盖一个区域的 14 个地图瓦片。右侧显示了如何在不改变瓦片大小或方向的情况下，仅用 10 个瓦片覆盖相同的区域。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a9a9dj7t.png)\n\n你的任务是帮助 ICPC 找出覆盖给定区域所需的最少瓦片数量。为简化起见，该区域将给出为不自相交的闭合多边形。\n\n请注意，瓦片必须是与 $x$ 轴和 $y$ 轴对齐的矩形网格的一部分。也就是说，它们只能用完整的边接触，不能旋转。另外，尽管所有输入坐标都是整数，瓦片的位置可以是非整数坐标。\n\n多边形可能接触边界线的边缘（如样例输入 2 中所示）。但是，为避免浮点数问题，可以假设即使允许多边形超出地图瓦片的距离为 $10^{-6}$，最优答案也不会改变。", "inputFormat": "输入包含一个测试用例。测试用例的第一行包含三个整数：$n, x_s$ 和 $y_s$。多边形的顶点数为 $n (3 \\leq n \\leq 50)$，$x_s$ 和 $y_s (1 \\leq x_s, y_s \\leq 100)$ 是每个瓦片的尺寸。接下来的 $n$ 行中的每一行包含两个整数 $x$ 和 $y (0 \\leq x \\leq 10x_s, 0 \\leq y \\leq 10y_s)$，指定表示区域的多边形的顶点（按顺时针或逆时针顺序）。", "outputFormat": "输出覆盖多边形的整个内部所需的最少瓦片数量。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10622", "type": "P", "difficulty": 6, "samples": [["7\n1 2 1 2 4 3 3", "Impossible"], ["7\n1 2 3 2 4 1 3\n", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "O2优化", "ICPC", "WF"], "title": "[ICPC 2013 WF] Matryoshka", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/tsc2hi05.png)", "description": "Matryoshkas are sets of traditional Russian wooden dolls of decreasing size placed one inside the other. A matryoshka doll can be opened to reveal a smaller figure of the same sort inside, which has, in turn, another figure inside, and so on.\n\nThe Russian Matryoshka Museum recently exhibited a collection of similarly designed matryoshka sets, differing only in the number of nested dolls in each set. Unfortunately, some over-zealous (and obviously unsupervised) children separated these sets, placing all the individual dolls in a row. There are $n$ dolls in the row, each with an integer size. You need to reassemble the matryoshka sets, knowing neither the number of sets nor the number of dolls in each set. You know only that every complete set consists of dolls with consecutive sizes from $1$ to some number $m$, which may vary between the different sets.\n\nWhen reassembling the sets, you must follow these rules:\n- You can put a doll or a nested group of dolls only inside a larger doll.\n- You can combine two groups of dolls only if they are adjacent in the row.\n- Once a doll becomes a member of a group, it cannot be transferred to another group or permanently separated from the group. It can be temporarily separated only when combining two groups.\n\nYour time is valuable, and you want to do this reassembly process as quickly as possible. The only time-consuming part of this task is opening and subsequently closing a doll, so you want to minimize how often you do this. For example, the minimum number of openings (and subsequent closings) when combining group $[1, 2, 6]$ with the group $[4]$ is two, since you have to open the dolls with sizes $6$ and $4$. When combining group $[1, 2, 5]$ with the group $[3, 4]$, you need to perform three openings.\n\nWrite a program to calculate the minimum number of openings required to combine all disassembled matryoshka sets.", "inputFormat": "The input consists of a single test case. A test case consists of two lines. The first line contains one integer $n (1 \\leq n \\leq 500)$ representing the number of individual dolls in the row. The second line contains $n$ positive integers specifying the sizes of the dolls in the order they appear in the row. Each size is between $1$ and $500$ inclusive.", "outputFormat": "Display the minimum number of openings required when reassembling the matryoshka sets. If reassembling cannot be done (some of the kids might have been excessively zealous and taken some dolls), display the word `Impossible`.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Matryoshka", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/tsc2hi05.png)", "description": "Matryoshkas are sets of traditional Russian wooden dolls of decreasing size placed one inside the other. A matryoshka doll can be opened to reveal a smaller figure of the same sort inside, which has, in turn, another figure inside, and so on.\n\nThe Russian Matryoshka Museum recently exhibited a collection of similarly designed matryoshka sets, differing only in the number of nested dolls in each set. Unfortunately, some over-zealous (and obviously unsupervised) children separated these sets, placing all the individual dolls in a row. There are $n$ dolls in the row, each with an integer size. You need to reassemble the matryoshka sets, knowing neither the number of sets nor the number of dolls in each set. You know only that every complete set consists of dolls with consecutive sizes from $1$ to some number $m$, which may vary between the different sets.\n\nWhen reassembling the sets, you must follow these rules:\n- You can put a doll or a nested group of dolls only inside a larger doll.\n- You can combine two groups of dolls only if they are adjacent in the row.\n- Once a doll becomes a member of a group, it cannot be transferred to another group or permanently separated from the group. It can be temporarily separated only when combining two groups.\n\nYour time is valuable, and you want to do this reassembly process as quickly as possible. The only time-consuming part of this task is opening and subsequently closing a doll, so you want to minimize how often you do this. For example, the minimum number of openings (and subsequent closings) when combining group $[1, 2, 6]$ with the group $[4]$ is two, since you have to open the dolls with sizes $6$ and $4$. When combining group $[1, 2, 5]$ with the group $[3, 4]$, you need to perform three openings.\n\nWrite a program to calculate the minimum number of openings required to combine all disassembled matryoshka sets.", "inputFormat": "The input consists of a single test case. A test case consists of two lines. The first line contains one integer $n (1 \\leq n \\leq 500)$ representing the number of individual dolls in the row. The second line contains $n$ positive integers specifying the sizes of the dolls in the order they appear in the row. Each size is between $1$ and $500$ inclusive.", "outputFormat": "Display the minimum number of openings required when reassembling the matryoshka sets. If reassembling cannot be done (some of the kids might have been excessively zealous and taken some dolls), display the word `Impossible`.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Matryoshka", "background": "", "description": "套娃是俄罗斯传统木制玩具，由一组逐渐变小的娃娃组成，依次放置在另一个娃娃内部。一个套娃可以打开，露出一个更小的类似玩偶，而这个玩偶内部又有另一个玩偶，以此类推。\n\n俄罗斯套娃博物馆最近展出了一系列设计相似的套娃，不同之处仅在于每套娃娃中嵌套的数量不同。不幸的是，一些过于热心（显然没有得到监督）的孩子把这些套娃拆散了，并将所有的单个娃娃排成一行。现在这一行中有 $n$ 个娃娃，每个都有一个整数大小。你需要重新组装这些套娃，既不知道套娃的数量，也不知道每套娃娃中娃娃的数量。你只知道每套完整的套娃由大小从 $1$ 到某个数字 $m$ 的连续大小的娃娃组成，而这个数字 $m$ 在不同的套娃中可能有所不同。\n\n在重新组装套娃时，你必须遵循以下规则：\n- 你只能将一个娃娃或一个嵌套的娃娃组放入一个更大的娃娃中。\n- 你只能合并两个在行中相邻的娃娃组。\n- 一旦一个娃娃成为一个组的成员，它不能被转移到另一个组或永久地从组中分离。它只能在合并两个组时暂时分离。\n\n你的时间非常宝贵，你希望尽快完成这个重新组装过程。这个任务中唯一耗时的部分是打开和随后关闭一个娃娃，因此你希望尽量减少这样的操作次数。例如，当将组 $[1, 2, 6]$ 与组 $[4]$ 合并时，最少需要进行两次开关操作，因为你必须打开大小为 $6$ 和 $4$ 的娃娃。而当将组 $[1, 2, 5]$ 与组 $[3, 4]$ 合并时，需要进行三次开关操作。\n\n编写一个程序计算重新组装所有拆散的套娃所需的最少开关次数。", "inputFormat": "输入包含一个测试用例。测试用例由两行组成。第一行包含一个整数 $n (1 \\leq n \\leq 500)$，表示行中单个娃娃的数量。第二行包含 $n$ 个正整数，按照它们在行中出现的顺序指定娃娃的大小。每个大小在 $1$ 到 $500$ 之间（包括 $1$ 和 $500$）。", "outputFormat": "输出重新组装套娃所需的最少开关次数。如果重新组装无法完成（可能有些孩子过于热心，带走了一些娃娃），则输出 `Impossible`。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10623", "type": "P", "difficulty": 0, "samples": [["3 1 2 3\n2 1 1\n2 2 1", "4"], ["4 1 1 5\n2 0 2 2 2", "12"], ["2 3 3 5\n2 2 2 2 2\n2 2 2 2 2\n2 2 2 2 2", "18"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "O2优化", "ICPC", "WF"], "title": "[ICPC 2013 WF] Pirate Chest", "background": "", "description": "Pirate Dick finally had enough of fighting, marauding, theft, and making life miserable for many on the open seas. So he decided to retire, and he found the perfect island to spend the rest of his days on, provided he does not run out of money. He has plenty of gold coins now, and he wants to store them in a chest (he is a pirate after all). Dick can construct a rectangular chest with integer dimensions of any size up to a specified maximum size for the top but with an arbitrary integer height. Now he needs a place to hide the chest. While exploring the island, he found the perfect solution.\n\nDick will hide his chest by submerging it in a murky pond. The pond has a rectangular surface, and it completely fills the bottom of a valley that has high vertical rocky walls. Dick surveyed the pond and knows its depth for each of the squares of a Cartesian coordinate grid system placed on the pond surface. When Dick submerges the chest, it will sink as far as possible until it touches the bottom. The top of the chest will remain parallel to the pond’s surface and the chest will be aligned with the grid squares. The water displaced by the submerged chest will raise the level of the pond’s surface (this will occur even if there is no space around the chest for the displaced water to rise). The walls of the valley are high enough that the water can never splash out of the valley. Of course, since the chest must be invisible, its top must be strictly below the surface of the pond. Your job is to find the volume of the largest chest that\nPirate Dick can hide this way.\n\nIn Figure I.1, the leftmost image shows a pond, the middle image shows a possible placement of a chest of volume 3, and the rightmost image shows a placement of a chest of volume 4, which is the maximum possible volume. Note that if the second chest were made one unit taller, its top would be visible because it would be at exactly the same height as the surface of the water.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6hz0e4z8.png)", "inputFormat": "The input consists of a single test case. A test case starts with a line containing four integers $a, b, m$, and $n (1 \\leq a, b, m, n \\leq 500)$. The pond’s surface dimensions are $m \\times n$ and the maximum size of the top (and bottom) of the chest is $a \\times b$. In addition, $a$ and $b$ are small enough that it is not possible to cover the entire pond with a chest with top size $a \\times b$. Each of the remaining $m$ lines in a test case contains $n$ integers $d_{i,j}$ specifying the pond’s depth at grid square $(i, j)$, where $0 \\leq d_{i,j} ≤ 10^9$ for each $1 \\leq i \\leq m$ and $1 \\leq j \\leq n$.", "outputFormat": "Display the maximum volume of a rectangular chest with integer dimensions (where one of the dimensions of the top is bounded by $a$ and the other is bounded by $b$) that can be completely submerged below the surface of the pond. If no chest can be hidden in the pond, display $0$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Pirate Chest", "background": "", "description": "Pirate Dick finally had enough of fighting, marauding, theft, and making life miserable for many on the open seas. So he decided to retire, and he found the perfect island to spend the rest of his days on, provided he does not run out of money. He has plenty of gold coins now, and he wants to store them in a chest (he is a pirate after all). Dick can construct a rectangular chest with integer dimensions of any size up to a specified maximum size for the top but with an arbitrary integer height. Now he needs a place to hide the chest. While exploring the island, he found the perfect solution.\n\nDick will hide his chest by submerging it in a murky pond. The pond has a rectangular surface, and it completely fills the bottom of a valley that has high vertical rocky walls. Dick surveyed the pond and knows its depth for each of the squares of a Cartesian coordinate grid system placed on the pond surface. When Dick submerges the chest, it will sink as far as possible until it touches the bottom. The top of the chest will remain parallel to the pond’s surface and the chest will be aligned with the grid squares. The water displaced by the submerged chest will raise the level of the pond’s surface (this will occur even if there is no space around the chest for the displaced water to rise). The walls of the valley are high enough that the water can never splash out of the valley. Of course, since the chest must be invisible, its top must be strictly below the surface of the pond. Your job is to find the volume of the largest chest that\nPirate Dick can hide this way.\n\nIn Figure I.1, the leftmost image shows a pond, the middle image shows a possible placement of a chest of volume 3, and the rightmost image shows a placement of a chest of volume 4, which is the maximum possible volume. Note that if the second chest were made one unit taller, its top would be visible because it would be at exactly the same height as the surface of the water.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6hz0e4z8.png)", "inputFormat": "The input consists of a single test case. A test case starts with a line containing four integers $a, b, m$, and $n (1 \\leq a, b, m, n \\leq 500)$. The pond’s surface dimensions are $m \\times n$ and the maximum size of the top (and bottom) of the chest is $a \\times b$. In addition, $a$ and $b$ are small enough that it is not possible to cover the entire pond with a chest with top size $a \\times b$. Each of the remaining $m$ lines in a test case contains $n$ integers $d_{i,j}$ specifying the pond’s depth at grid square $(i, j)$, where $0 \\leq d_{i,j} ≤ 10^9$ for each $1 \\leq i \\leq m$ and $1 \\leq j \\leq n$.", "outputFormat": "Display the maximum volume of a rectangular chest with integer dimensions (where one of the dimensions of the top is bounded by $a$ and the other is bounded by $b$) that can be completely submerged below the surface of the pond. If no chest can be hidden in the pond, display $0$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Pirate Chest", "background": "", "description": "海盗迪克终于厌倦了战斗、抢劫、偷窃，以及在开阔海域上给许多人带来的痛苦。因此，他决定退休，并找到了一个完美的岛屿，打算在那里度过余生，只要他不用尽光金币就行。他现在有大量的金币，想要把它们存放在一个箱子里（毕竟他是海盗）。迪克可以制造一个整数尺寸的矩形箱子，顶部尺寸的大小可以高达指定的最大尺寸，但高度可以是任意整数。现在他需要一个地方来隐藏这个箱子。在探索岛屿时，他找到了一个完美的解决方案。\n\n迪克将把他的箱子藏在一个混浊的池塘中。池塘有一个矩形的表面，并完全填满了一个有高垂直岩壁的山谷底部。迪克调查了池塘，并了解到每个笛卡尔坐标网格系统方格的深度。当迪克将箱子浸入水中时，它将尽可能沉入，直到触及底部。箱子的顶部将保持与池塘表面平行，并且箱子将与网格方格对齐。被浸入水中的箱子所排开的水将抬高池塘表面的水平（即使周围没有空间供排开的水升起）。山谷的岩壁足够高，以至于水永远不会溅出山谷。当然，由于箱子必须看不见，它的顶部必须严格低于池塘表面。你的任务是找出海盗迪克能够用这种方式隐藏的最大箱子的容积。\n\n在图 I.1 中，最左边的图像显示了一个池塘，中间的图像显示了一个容积为 3 的箱子的可能摆放方式，最右边的图像显示了容积为 4 的箱子的摆放方式，这是可能的最大容积。请注意，如果第二个箱子的高度再增加一个单位，它的顶部将会可见，因为它的高度与水表面正好相同。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6hz0e4z8.png)", "inputFormat": "输入包含一个测试用例。测试用例以一行四个整数 $a, b, m, n (1 \\leq a, b, m, n \\leq 500)$ 开始。池塘表面的尺寸为 $m \\times n$，箱子顶部（和底部）的最大尺寸为 $a \\times b$。此外，$a$ 和 $b$ 足够小，不能用顶部尺寸为 $a \\times b$ 的箱子覆盖整个池塘。在测试用例的其余部分，每个深度的 $m$ 行中包含 $n$ 个整数 $d_{i,j}$，指定网格方格 $(i, j)$ 处的池塘深度，其中对于每个 $1 \\leq i \\leq m$ 和 $1 \\leq j \\leq n$，$0 \\leq d_{i,j} \\leq 10^9$。", "outputFormat": "显示能够完全浸入池塘表面以下的最大矩形箱子的容积。如果无法在池塘中隐藏箱子，则显示 $0$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10624", "type": "P", "difficulty": 6, "samples": [["6 10\n-8 2\n8 2\n8 14\n0 14\n0 6\n-8 14", "101.576437872"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "2013", "Special Judge", "O2优化", "积分", "定积分", "线段相交", "扫描线", "ICPC", "WF"], "title": "[ICPC 2013 WF] Pollution Solution", "background": "", "description": "As an employee of Aqueous Contaminate Management, you must monitor the pollution that gets dumped (sometimes accidentally, sometimes purposefully) into rivers, lakes and oceans. One of your jobs is to measure the impact of the pollution on various ecosystems in the water such as coral reefs, spawning grounds, and so on.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k4nih8sh.png)\n\nThe model you use in your analysis is illustrated in Figure J.1. The shoreline (the horizontal line in the figure) lies on the $x$-axis with the source of the pollution located at the origin $(0,0)$. The spread of the pollution into the water is represented by the semicircle, and the polygon represents the ecosystem of concern. You must determine the area of the ecosystem that is contaminated, represented by the dark blue region in the figure.", "inputFormat": "The input consists of a single test case. A test case starts with a line containing two integers n and $r$, where $3 \\leq n \\leq 100$ is the number of vertices in the polygon and $1 \\leq r \\leq 1 000$ is the radius of the pollution field. This is followed by $n$ lines, each containing two integers $x_i, y_i$, giving the coordinates of the polygon vertices in counter-clockwise order, where $-1 500 \\leq x_i \\leq 1 500$ and $0 \\leq y_i \\leq 1 500$. The polygon does not self-intersect or touch itself. No vertex lies on the circle boundary.", "outputFormat": "Display the area of the polygon that falls within the semicircle centered at the origin with radius $r$. Give the result with an absolute error of at most $10^{-3}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Pollution Solution", "background": "", "description": "As an employee of Aqueous Contaminate Management, you must monitor the pollution that gets dumped (sometimes accidentally, sometimes purposefully) into rivers, lakes and oceans. One of your jobs is to measure the impact of the pollution on various ecosystems in the water such as coral reefs, spawning grounds, and so on.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k4nih8sh.png)\n\nThe model you use in your analysis is illustrated in Figure J.1. The shoreline (the horizontal line in the figure) lies on the $x$-axis with the source of the pollution located at the origin $(0,0)$. The spread of the pollution into the water is represented by the semicircle, and the polygon represents the ecosystem of concern. You must determine the area of the ecosystem that is contaminated, represented by the dark blue region in the figure.", "inputFormat": "The input consists of a single test case. A test case starts with a line containing two integers n and $r$, where $3 \\leq n \\leq 100$ is the number of vertices in the polygon and $1 \\leq r \\leq 1 000$ is the radius of the pollution field. This is followed by $n$ lines, each containing two integers $x_i, y_i$, giving the coordinates of the polygon vertices in counter-clockwise order, where $-1 500 \\leq x_i \\leq 1 500$ and $0 \\leq y_i \\leq 1 500$. The polygon does not self-intersect or touch itself. No vertex lies on the circle boundary.", "outputFormat": "Display the area of the polygon that falls within the semicircle centered at the origin with radius $r$. Give the result with an absolute error of at most $10^{-3}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Pollution Solution", "background": "", "description": "作为水污染管理公司的员工，你必须监测被排放到河流、湖泊和海洋中的污染物（有时是意外的，有时是故意的）。你的工作之一是测量污染对水中各种生态系统的影响，如珊瑚礁、产卵场所等。\n\n![Illustration](https://cdn.luogu.com.cn/upload/image_hosting/k4nih8sh.png)\n\n你在分析中使用的模型如图 J.1 所示。岸线（图中的水平线）位于 $x$ 轴上，污染源位于原点 $(0,0)$ 处。污染物在水中的扩散由半圆表示，多边形表示了关注的生态系统。你需要确定被污染的生态系统区域的面积，即图中的深蓝色区域。", "inputFormat": "输入包含一个测试用例。测试用例以一行两个整数 $n$ 和 $r$ 开始，其中 $3 \\leq n \\leq 100$ 是多边形顶点的数量，$1 \\leq r \\leq 1,000$ 是污染场的半径。接下来的 $n$ 行，每行包含两个整数 $x_i, y_i$，表示多边形顶点的坐标，顺时针给出，其中 $-1,500 \\leq x_i \\leq 1,500$ 且 $0 \\leq y_i \\leq 1,500$。多边形不自相交或自交。没有顶点位于半圆边界上。", "outputFormat": "显示位于以原点为中心、半径为 $r$ 的半圆内的多边形的面积。结果的绝对误差不超过 $10^{-3}$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10625", "type": "P", "difficulty": 0, "samples": [["HFBIGEDCJA\nBIGEDCJFAH\nBIGEDCJFAH", "Pre Post In Post In Pre\nHFBJCDEGIA\nBIGEDCJFAH\nIGEDCJBAFH"], ["BNLFAGHPEDOCMJIK\nNLBGAPHCODEIJMKF\nNLFAGHPEDOCMJIKB", "In Pre In Post Post Pre\nBLNFKMEHAGPCODIJ\nNLBAGHPEODCMIJKF\nNLGAPHDOCEJIMKFB\nPost Pre In In Post Pre\nBLNFKICPGAHEODMJ\nNLBGAPHCODEIJMKF\nNLAGHPDOECJMIKFB"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "O2优化", "ICPC", "WF"], "title": "[ICPC 2013 WF] Up a Tree", "background": "", "description": "Anatoly Cheng McDougal is a typical student in many ways. Whenever possible he tries to cut and paste code instead of writing it from scratch. Unavoidably this approach causes him problems. For example, when he first learned about preorder, inorder and postorder traversals of trees, and was given code for a preorder print of a tree (shown on the left below), he simply cut and pasted the code, then moved the print statement to the correct location and renamed the procedure. However, he forgot to rename the procedure calls inside the code, resulting in the defective inorder print and postorder print code shown below.\n\n```cpp\nvoid prePrint(TNode t)\n{\n    output(t.value);\n    if (t.left != null)\n        prePrint(t.left);\n    if (t.right != null)\n        prePrint(t.right);\n}\nvoid inPrint(TNode t)\n{\n    if (t.left != null)\n        prePrint(t.left);\n    output(t.value);\n    if (t.right != null)\n        prePrint(t.right);\n}\nvoid postPrint(TNode t)\n{\n    if (t.left != null)\n        prePrint(t.left);\n    if (t.right != null)\n        prePrint(t.right);\n    output(t.value);\n}\n```\n\nAt this point, Anatoly did not behave like a typical student. He actually tested his code! Unfortunately, when the results were not correct, he reverted back to typical student behavior. He panicked and started randomly changing calls in all three procedures, hoping to get things right. Needless to say, the situation became even worse now than when he started.\n\nAnatoly’s professor tested the code on a random tree of characters. When she looked at the output of his three print routines, she correctly guessed what had happened. However, instead of going directly to his code, she decided to try to reconstruct Anatoly’s code just by observing the output. In order to do this, she correctly made the following assumptions:\n\n1. The output statement in each print routine is in the correct location (for example, between the two recursive calls in the inPrint routine).\n2. Among the six recursive calls made by the three routines, exactly two calls are to prePrint, exactly two are to inPrint, and exactly two are to postPrint, though potentially in the wrong routines.\n\nSoon the professor realized that reconstructing Anatoly’s code and the test tree from his output was not a simple task and that the result might be ambiguous. You will have to help her find all possible reconstructions of Anatoly’s code. In addition, for each such reconstruction, you are to find the alphabetically first tree (as described in the output section) giving the observed output.", "inputFormat": "The input consists of a single test case. A test case consists of three strings on three separate lines: the observed output of Anatoly’s `prePrint`, `inPrint` and `postPrint` routines (in that order) on some test tree. Each of these strings consists of $n$ uppercase letters $(4 \\leq n \\leq 26)$, with no repeated letters in any string. The test case is guaranteed to have at least one solution.", "outputFormat": "Display all possible reconstructions for the test case, ordered as described in the last paragraph below. The output for each reconstruction consists of two parts. The first part is a single line and describes the six calls in Anatoly’s routines: first the two (recursive) calls in Anatoly’s `prePrint` routine, followed by the calls in his `inPrint` routine, and finally the calls in his `postPrint` routine. The calls are described by the words `Pre`, `In`, and `Post`, separated by spaces. For example, if Anatoly’s routines were correct, the resulting output of the first part of the reconstruction would be `Pre Pre In In Post Post`.\n\nThe second part consists of three lines and describes the first test tree that could have generated the observed outputs. The first line is the *correct* preorder print of the tree, and the second and third lines contain the correct inorder and postorder prints, respectively. The first tree is the one with the alphabetically first preorder print. If there are multiple such trees, the first of these is the one with the alphabetically first inorder print.\n\nEvery reconstruction is a sequence of $6$ tokens chosen from `Pre`, `In`, and `Post`. The ordering of reconstructions is lexicographic with respect to the following ordering of tokens: Pre < In < Post.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Up a Tree", "background": "", "description": "Anatoly Cheng McDougal is a typical student in many ways. Whenever possible he tries to cut and paste code instead of writing it from scratch. Unavoidably this approach causes him problems. For example, when he first learned about preorder, inorder and postorder traversals of trees, and was given code for a preorder print of a tree (shown on the left below), he simply cut and pasted the code, then moved the print statement to the correct location and renamed the procedure. However, he forgot to rename the procedure calls inside the code, resulting in the defective inorder print and postorder print code shown below.\n\n```cpp\nvoid prePrint(TNode t)\n{\n    output(t.value);\n    if (t.left != null)\n        prePrint(t.left);\n    if (t.right != null)\n        prePrint(t.right);\n}\nvoid inPrint(TNode t)\n{\n    if (t.left != null)\n        prePrint(t.left);\n    output(t.value);\n    if (t.right != null)\n        prePrint(t.right);\n}\nvoid postPrint(TNode t)\n{\n    if (t.left != null)\n        prePrint(t.left);\n    if (t.right != null)\n        prePrint(t.right);\n    output(t.value);\n}\n```\n\nAt this point, Anatoly did not behave like a typical student. He actually tested his code! Unfortunately, when the results were not correct, he reverted back to typical student behavior. He panicked and started randomly changing calls in all three procedures, hoping to get things right. Needless to say, the situation became even worse now than when he started.\n\nAnatoly’s professor tested the code on a random tree of characters. When she looked at the output of his three print routines, she correctly guessed what had happened. However, instead of going directly to his code, she decided to try to reconstruct Anatoly’s code just by observing the output. In order to do this, she correctly made the following assumptions:\n\n1. The output statement in each print routine is in the correct location (for example, between the two recursive calls in the inPrint routine).\n2. Among the six recursive calls made by the three routines, exactly two calls are to prePrint, exactly two are to inPrint, and exactly two are to postPrint, though potentially in the wrong routines.\n\nSoon the professor realized that reconstructing Anatoly’s code and the test tree from his output was not a simple task and that the result might be ambiguous. You will have to help her find all possible reconstructions of Anatoly’s code. In addition, for each such reconstruction, you are to find the alphabetically first tree (as described in the output section) giving the observed output.", "inputFormat": "The input consists of a single test case. A test case consists of three strings on three separate lines: the observed output of Anatoly’s `prePrint`, `inPrint` and `postPrint` routines (in that order) on some test tree. Each of these strings consists of $n$ uppercase letters $(4 \\leq n \\leq 26)$, with no repeated letters in any string. The test case is guaranteed to have at least one solution.", "outputFormat": "Display all possible reconstructions for the test case, ordered as described in the last paragraph below. The output for each reconstruction consists of two parts. The first part is a single line and describes the six calls in Anatoly’s routines: first the two (recursive) calls in Anatoly’s `prePrint` routine, followed by the calls in his `inPrint` routine, and finally the calls in his `postPrint` routine. The calls are described by the words `Pre`, `In`, and `Post`, separated by spaces. For example, if Anatoly’s routines were correct, the resulting output of the first part of the reconstruction would be `Pre Pre In In Post Post`.\n\nThe second part consists of three lines and describes the first test tree that could have generated the observed outputs. The first line is the *correct* preorder print of the tree, and the second and third lines contain the correct inorder and postorder prints, respectively. The first tree is the one with the alphabetically first preorder print. If there are multiple such trees, the first of these is the one with the alphabetically first inorder print.\n\nEvery reconstruction is a sequence of $6$ tokens chosen from `Pre`, `In`, and `Post`. The ordering of reconstructions is lexicographic with respect to the following ordering of tokens: Pre < In < Post.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Up a Tree", "background": "", "description": "Anatoly Cheng McDougal 在许多方面都是典型的学生。每当可能时，他都会尝试剪切和粘贴代码，而不是从头开始编写。不可避免地，这种方法给他带来了问题。例如，当他第一次学习树的前序、中序和后序遍历，并获得了前序打印树的代码（如下面左侧所示），他只是简单地剪切和粘贴代码，然后将打印语句移动到正确的位置并重命名过程。然而，他忘记了在代码内部重命名过程调用，导致了下面有缺陷的中序打印和后序打印代码。\n\n```cpp\nvoid prePrint(TNode t)\n{\n    output(t.value);\n    if (t.left != null)\n        prePrint(t.left);\n    if (t.right != null)\n        prePrint(t.right);\n}\nvoid inPrint(TNode t)\n{\n    if (t.left != null)\n        prePrint(t.left);\n    output(t.value);\n    if (t.right != null)\n        prePrint(t.right);\n}\nvoid postPrint(TNode t)\n{\n    if (t.left != null)\n        prePrint(t.left);\n    if (t.right != null)\n        prePrint(t.right);\n    output(t.value);\n}\n```\n\n此时，Anatoly 不像典型的学生那样行事。他实际上测试了他的代码！不幸的是，当结果不正确时，他又恢复了典型的学生行为。他慌乱了，开始随机更改所有三个过程中的调用，希望能弄对。不用说，现在的情况比他刚开始时更糟糕了。\n\nAnatoly 的教授在一个随机的字符树上测试了代码。当她查看他三个打印例程的输出时，她正确猜测到发生了什么。然而，她没有直接查看他的代码，而是决定仅通过观察输出来重建Anatoly的代码。为了做到这一点，她正确地做出了以下假设：\n\n1. 每个打印例程中的输出语句在正确的位置（例如，在 `inPrint` 例程中的两个递归调用之间）。\n2. 在三个例程中进行的六次递归调用中，恰好有两次调用 `prePrint`，两次调用 `inPrint` 和两次调用 `postPrint`，尽管它们可能在错误的例程中。\n\n不久，教授意识到从Anatoly的输出重建代码和测试树并不是一件简单的任务，结果可能是模棱两可的。你需要帮助她找出所有可能的Anatoly代码重建方式。此外，对于每种重建方式，你需要找出字母顺序最早的树（如下面输出部分所描述的）。", "inputFormat": "输入包含一个测试用例。一个测试用例由三行字符串组成：Anatoly 的 `prePrint`、`inPrint` 和 `postPrint` 例程在某个测试树上的观察输出（按顺序）。每个字符串由 $n$ 个大写字母组成（$4 \\leq n \\leq 26$），每个字符串中没有重复的字母。保证测试用例至少有一种解决方案。", "outputFormat": "显示测试用例的所有可能重建方式，按照以下最后一段中描述的顺序排序。每种重建方式的输出分为两部分。第一部分是单行描述Anatoly例程中的六次调用：首先是Anatoly的 `prePrint` 例程中的两次（递归）调用，然后是 `inPrint` 例程中的调用，最后是 `postPrint` 例程中的调用。调用由单词 `Pre`、`In` 和 `Post` 描述，用空格分隔。例如，如果Anatoly的例程是正确的，则重建方式的第一部分的输出将是 `Pre Pre In In Post Post`。\n\n第二部分包括三行，描述能够生成观察输出的第一棵树。第一行是树的正确前序遍历打印，第二行和第三行分别包含正确的中序遍历和后序遍历打印。第一棵树是按字母顺序最早的前序打印树。如果有多棵这样的树，则选择其中前序打印字母顺序最早的树。\n\n每种重建方式都是从 `Pre`、`In` 和 `Post` 中选择的六个标记的序列。重建方式的排序是按照以下标记的词法顺序：`Pre` < `In` < `Post`。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10626", "type": "P", "difficulty": 6, "samples": [["15 5\n(![2]|[3])&![4]\n1\n2\n3\n4\n5", "True\nFalse\nTrue\nFalse\nFalse"], ["20 4\n(!![23])^((([116])))\n54\n1\n200\n89", "True\nFalse\nFalse\nTrue"], ["32 4\n[2]|[5]&[1]|(([1000000000])|[7])\n4\n10\n6\n1", "True\nTrue\nTrue\nFalse"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "线段树", "树上启发式合并", "2024", "树链剖分", "动态树 LCT", "JOI（日本）"], "title": "[JOI Open 2024] 考试 2 / Examination 2", "background": null, "description": "JOI 君在 IOI 高中上学，期末考试即将来临。考试的内容是计算 **IOI 函数**。IOI 函数是将 $[1,10^9]$ 之间的整数映射到布尔值（即 $\\texttt{True}/\\texttt{False}$）的函数。IOI 函数可以从以下六条 IOI 高中规定的规则中构造：\n\n1. 设 $a$ 为 $[1,10^9]$ 之间的整数，则 $\\texttt{[a]}$ 是一个 IOI 函数。它将不小于 $a$ 的整数映射成 $\\texttt{True}$，将小于 $a$ 的整数映射成 $\\texttt{False}$。\n\n2. 记 $\\texttt{f}$ 为 IOI 函数，则 $\\texttt{(f)}$ 是一个 IOI 函数，它的映射规则与 $\\texttt{f}$ 的映射规则相同。\n\n3. 记 $\\texttt{f}$ 为 IOI 函数，则 $\\texttt{!f}$ 是一个 IOI 函数。设 $x$ 为整数，若 $\\texttt{f}$ 将 $x$ 映射为 $\\texttt{True}$，则 $\\texttt{!f}$ 将 $x$ 映射为 $\\texttt{False}$；否则 $\\texttt{!f}$ 将 $x$ 映射为 $\\texttt{True}$。\n\n4. 记 $\\texttt{f},\\texttt{g}$ 为 IOI 函数，则 $\\texttt{f\\&g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\\texttt{f\\&g}$ 将 $x$ 映射为 $\\texttt{True}$，当且仅当 $\\texttt{f},\\texttt{g}$ 都将 $x$ 映射为 $\\texttt{True}$。\n\n5. 记 $\\texttt{f},\\texttt{g}$ 为 IOI 函数，则 $\\texttt{f\\^ g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\\texttt{f\\^ g}$ 将 $x$ 映射为 $\\texttt{True}$，当且仅当 $\\texttt{f},\\texttt{g}$ 中恰好有一个将 $x$ 映射为 $\\texttt{True}$。\n\n6. 记 $\\texttt{f},\\texttt{g}$ 为 IOI 函数，则 $\\texttt{f|g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\\texttt{f|g}$ 将 $x$ 映射为 $\\texttt{True}$，当且仅当 $\\texttt{f},\\texttt{g}$ 中至少有一个将 $x$ 映射为 $\\texttt{True}$。\n\n如果某个 IOI 函数用多条规则构造出，数字更大的规则将决定函数值。例如，对于 $\\texttt{[1]\\&[2]|[3]}$ 应当应用规则 6，其中 $\\texttt{f} = \\texttt{[1]\\&[2]},\\texttt{g} = \\texttt{[3]}$（而非应用规则 4，其中 $\\texttt{f} = \\texttt{[1]},\\texttt{g} = \\texttt{[2]|[3]}$）。额外地，对于规则 4，5，6，应当最大化 $\\texttt{f}$ 的长度。例如，对于 $\\texttt{[4]ˆ[5]ˆ[6]}$，应当在 $\\texttt{f} = \\texttt{[4]ˆ[5]},\\texttt{g} = \\texttt{[6]}$ 上应用规则 5（而非 $\\texttt{f} = \\texttt{[4]},\\texttt{g} = \\texttt{[5]ˆ[6]}$）。\n\n为备战期末考试，JOI 君准备好了一个长度为 $N$ 的 IOI 函数 $S$。他打算用 $Q$ 个整数 $X_1,X_2,\\cdots,X_Q$ 来练习他的计算技能。于是他找来了你——能够熟练处理 IOI 函数的人，来解决这个问题。\n\n你需要写一个程序。给定 $N,Q,S$ 以及 $X_1,X_2,\\cdots,X_Q$，对于 $i=1,2=\\cdots,Q$，回答 IOI 函数 $S$ 会将 $X_i$ 映射成 $\\texttt{True}$ 还是 $\\texttt{False}$。", "inputFormat": "输入格式如下所示：\n\n> $N$ $Q$\\\n> $S$\\\n> $X_1$\\\n> $X_2$\\\n> $\\vdots$\\\n> $X_Q$", "outputFormat": "输出 $Q$ 行，第 $i$ 行为 $\\texttt{True}$ 或者 $\\texttt{False}$，即 $X_i$ 被 $S$ 映射成的值。", "hint": "### 样例解释\n\n样例 $1$ 解释如下：\n\n| $X_i$ | $\\texttt{![2]}$ | $\\texttt{[3]}$ | $\\texttt{![2]\\char124[3]}$ | $\\texttt{![4]}$ | $\\texttt{(![2]\\char124[3])\\&![4]}$ |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| $1$ | $\\texttt{True}$ | $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{True}$ |\n| $2$ | $\\texttt{False}$ | $\\texttt{False}$ | $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{False}$ |\n| $3$ |  $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{True}$ |\n| $4$ | $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{False}$ | $\\texttt{False}$ |\n| $5$ |  $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{False}$ | $\\texttt{False}$ |\n\n样例 $1$ 满足子任务 $3,6,7$ 的条件。\n\n样例 $2$ 满足子任务 $1,3,5\\sim 7$ 的条件。\n\n样例 $3$ 满足子任务 $3,4,6,7$ 的条件。\t\n\n### 数据范围\n\n- $1 \\le N \\le 1\\,000\\,000$；\n- $1 \\le Q \\le 200\\,000$；\n- $S$ 为长度为 $N$ 的 IOI 函数；\n- $1 \\le X_i \\le 10^9$（$1 \\le i \\le Q$）；\n- $N, Q, X_i$（$1 \\le i \\le Q$）均为整数。\n\n### 子任务\n\n1. （$5$ points）$S$ 中不含 $\\texttt{\\&}$ 和 $\\texttt{|}$；\n2. （$20$ points）$Q = 1$；\n3. （$10$ points）$N \\le 10\\,000$；\n4. （$6$ points）$S$ 中不含 $\\texttt{!}$ 和 $\\texttt{ˆ}$；\n5. （$12$ points）当应用规则 4 或 6 来构造 $S$ 时，$\\texttt{f}$ 和 $\\texttt{g}$ 中至少有一个是用规则 1 得到的；\n6. （$20$ points）$N \\le 400\\, 000$；\n7. （$27$ points）无额外约束。\n\n*赛时公告：如果你复制题面中的 LaTeX，可能会得到 `ˆ`，但实际上是 `^`。请特别注意。\n\n由 Starrykiller 根据英文题面翻译。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI Open 2024] 考试 2 / Examination 2", "background": null, "description": "JOI 君在 IOI 高中上学，期末考试即将来临。考试的内容是计算 **IOI 函数**。IOI 函数是将 $[1,10^9]$ 之间的整数映射到布尔值（即 $\\texttt{True}/\\texttt{False}$）的函数。IOI 函数可以从以下六条 IOI 高中规定的规则中构造：\n\n1. 设 $a$ 为 $[1,10^9]$ 之间的整数，则 $\\texttt{[a]}$ 是一个 IOI 函数。它将不小于 $a$ 的整数映射成 $\\texttt{True}$，将小于 $a$ 的整数映射成 $\\texttt{False}$。\n\n2. 记 $\\texttt{f}$ 为 IOI 函数，则 $\\texttt{(f)}$ 是一个 IOI 函数，它的映射规则与 $\\texttt{f}$ 的映射规则相同。\n\n3. 记 $\\texttt{f}$ 为 IOI 函数，则 $\\texttt{!f}$ 是一个 IOI 函数。设 $x$ 为整数，若 $\\texttt{f}$ 将 $x$ 映射为 $\\texttt{True}$，则 $\\texttt{!f}$ 将 $x$ 映射为 $\\texttt{False}$；否则 $\\texttt{!f}$ 将 $x$ 映射为 $\\texttt{True}$。\n\n4. 记 $\\texttt{f},\\texttt{g}$ 为 IOI 函数，则 $\\texttt{f\\&g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\\texttt{f\\&g}$ 将 $x$ 映射为 $\\texttt{True}$，当且仅当 $\\texttt{f},\\texttt{g}$ 都将 $x$ 映射为 $\\texttt{True}$。\n\n5. 记 $\\texttt{f},\\texttt{g}$ 为 IOI 函数，则 $\\texttt{f\\^ g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\\texttt{f\\^ g}$ 将 $x$ 映射为 $\\texttt{True}$，当且仅当 $\\texttt{f},\\texttt{g}$ 中恰好有一个将 $x$ 映射为 $\\texttt{True}$。\n\n6. 记 $\\texttt{f},\\texttt{g}$ 为 IOI 函数，则 $\\texttt{f|g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\\texttt{f|g}$ 将 $x$ 映射为 $\\texttt{True}$，当且仅当 $\\texttt{f},\\texttt{g}$ 中至少有一个将 $x$ 映射为 $\\texttt{True}$。\n\n如果某个 IOI 函数用多条规则构造出，数字更大的规则将决定函数值。例如，对于 $\\texttt{[1]\\&[2]|[3]}$ 应当应用规则 6，其中 $\\texttt{f} = \\texttt{[1]\\&[2]},\\texttt{g} = \\texttt{[3]}$（而非应用规则 4，其中 $\\texttt{f} = \\texttt{[1]},\\texttt{g} = \\texttt{[2]|[3]}$）。额外地，对于规则 4，5，6，应当最大化 $\\texttt{f}$ 的长度。例如，对于 $\\texttt{[4]ˆ[5]ˆ[6]}$，应当在 $\\texttt{f} = \\texttt{[4]ˆ[5]},\\texttt{g} = \\texttt{[6]}$ 上应用规则 5（而非 $\\texttt{f} = \\texttt{[4]},\\texttt{g} = \\texttt{[5]ˆ[6]}$）。\n\n为备战期末考试，JOI 君准备好了一个长度为 $N$ 的 IOI 函数 $S$。他打算用 $Q$ 个整数 $X_1,X_2,\\cdots,X_Q$ 来练习他的计算技能。于是他找来了你——能够熟练处理 IOI 函数的人，来解决这个问题。\n\n你需要写一个程序。给定 $N,Q,S$ 以及 $X_1,X_2,\\cdots,X_Q$，对于 $i=1,2=\\cdots,Q$，回答 IOI 函数 $S$ 会将 $X_i$ 映射成 $\\texttt{True}$ 还是 $\\texttt{False}$。", "inputFormat": "输入格式如下所示：\n\n> $N$ $Q$\\\n> $S$\\\n> $X_1$\\\n> $X_2$\\\n> $\\vdots$\\\n> $X_Q$", "outputFormat": "输出 $Q$ 行，第 $i$ 行为 $\\texttt{True}$ 或者 $\\texttt{False}$，即 $X_i$ 被 $S$ 映射成的值。", "hint": "### 样例解释\n\n样例 $1$ 解释如下：\n\n| $X_i$ | $\\texttt{![2]}$ | $\\texttt{[3]}$ | $\\texttt{![2]\\char124[3]}$ | $\\texttt{![4]}$ | $\\texttt{(![2]\\char124[3])\\&![4]}$ |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| $1$ | $\\texttt{True}$ | $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{True}$ |\n| $2$ | $\\texttt{False}$ | $\\texttt{False}$ | $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{False}$ |\n| $3$ |  $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{True}$ |\n| $4$ | $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{False}$ | $\\texttt{False}$ |\n| $5$ |  $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{False}$ | $\\texttt{False}$ |\n\n样例 $1$ 满足子任务 $3,6,7$ 的条件。\n\n样例 $2$ 满足子任务 $1,3,5\\sim 7$ 的条件。\n\n样例 $3$ 满足子任务 $3,4,6,7$ 的条件。\t\n\n### 数据范围\n\n- $1 \\le N \\le 1\\,000\\,000$；\n- $1 \\le Q \\le 200\\,000$；\n- $S$ 为长度为 $N$ 的 IOI 函数；\n- $1 \\le X_i \\le 10^9$（$1 \\le i \\le Q$）；\n- $N, Q, X_i$（$1 \\le i \\le Q$）均为整数。\n\n### 子任务\n\n1. （$5$ points）$S$ 中不含 $\\texttt{\\&}$ 和 $\\texttt{|}$；\n2. （$20$ points）$Q = 1$；\n3. （$10$ points）$N \\le 10\\,000$；\n4. （$6$ points）$S$ 中不含 $\\texttt{!}$ 和 $\\texttt{ˆ}$；\n5. （$12$ points）当应用规则 4 或 6 来构造 $S$ 时，$\\texttt{f}$ 和 $\\texttt{g}$ 中至少有一个是用规则 1 得到的；\n6. （$20$ points）$N \\le 400\\, 000$；\n7. （$27$ points）无额外约束。\n\n*赛时公告：如果你复制题面中的 LaTeX，可能会得到 `ˆ`，但实际上是 `^`。请特别注意。\n\n由 Starrykiller 根据英文题面翻译。", "locale": "zh-CN"}}}
{"pid": "P10627", "type": "P", "difficulty": 7, "samples": [["3\n1 1 1\n3\n1 2 2", "1"], ["6\n1 1 1 1 1 1\n7\n1 3 5 4 2 2 3", "3"], ["6\n4000 1 1 0 4000 1\n5\n1 1 2 3 5", "1"], ["5\n1 2 2 2 1\n8\n2 3 2 1 4 1 2 3", "2"], ["10\n2 2 2 2 2 2 2 2 2 2\n18\n1 3 5 7 9 2 4 6 8 1 3 5 7 9 2 4 6 8", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "JOI（日本）"], "title": "[JOI Open 2024] 中暑 / Heat Stroke", "background": "", "description": "JOI 岛由 $L$ 个区组成，从西到东依次编号为 $1$ 到 $L$。岛上有 $(L-1)$ 条路，编号为 $1$ 到 $L-1$。第 $i$ 条路（$1\\le i\\le L-1$）双向连接着区 $i$ 和区 $i+1$。\n\n现在，IOI 20XX 计划在 JOI 岛上举行！然而，令人担心的是，JOI 岛以其“火炉”称号而闻名于世。在岛上中暑风险较高，尤其是对于不适应 JOI 岛炎热气候的外国人。所以，IOI 的组织者决定采取以下措施：\n\n- 对于每一个 $1\\le i\\le L$，在区 $i$ 上有一个容量为 $C_i$ 人的医院。注意，$C_i$ 可以为 $0$。\n\n- 在 IOI 活动中，当有人在第 $x$ 条路（$1\\le x\\le L-1$）上中暑时，中暑者将以以下的程序送医：\n    - 将中暑者送往区 $x$ 或者区 $x+1$ 上的未满员的医院。如果两个区上的医院都未满员，则送往哪一个医院都可以。如果两个医院都满员了，用直升机将中暑者送往岛外的医院。\n\n由于动用直升机花销不小，组织者们想要估计可能的需要动用直升机的病人数量的**最大值**。他们考虑如下的情境：\n\n- 在 IOI 活动之前，医院中没有病人；\n- 在 IOI 活动中，有 $N$ 个人会依次中暑。第 $j$ 个（$1\\le j\\le N$）人在第 $X_j$ 条路上中暑；\n- 对于任意 $1\\le j\\le N-1$，当第 $(j+1)$ 个人中暑时，第 $1,2,\\cdots,j$ 个人已经送达医院。由于中暑症状较为严重，在 IOI 活动中无人出院。\n\n你需要写一个程序。给定区的数量，医院的信息和中暑者的信息，在上述情境下，计算可能的需要动用直升机的病人数量的最大值。\n", "inputFormat": "输入格式如下所示：\n> $L$\\\n> $C_1$ $C_2$ $\\cdots$ $C_L$ \\\n> $N$\\\n> $X_1$ $X_2$ $\\cdots$ $X_N$", "outputFormat": "输出一行一个数，即可能的需要动用直升机的病人数量的最大值。", "hint": "### 样例解释\n\n对于样例 $1$，考虑如下的情况：\n\n- 将第一个中暑者送往区 $2$ 上的医院。此时，三个区上的医院的病人数量分别为 $0,1,0$；\n- 将第二个中暑者送往区 $3$ 上的医院。此时，三个区上的医院的病人数量分别为 $0,1,1$；\n- 对于第三个中暑者，由于区 $2,3$ 上的医院均已满员，所以只能用直升机送出岛。\n\n此时共有 $1$ 人动用直升机送出岛。可以证明这是最大值。\n\n对于样例 $2$，考虑如下的情况：\n\n- 将第一个中暑者送往区 $2$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,0,0,0,0$；\n- 将第二个中暑者送往区 $4$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,0,1,0,0$；\n- 将第三个中暑者送往区 $5$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,0,1,1,0$；\n- 对于第四个中暑者，由于区 $4,5$ 上的医院均已满员，所以只能用直升机送出岛。\n- 将第五个中暑者送往区 $3$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,1,1,1,0$；\n- 对于第六个中暑者，由于区 $2,3$ 上的医院均已满员，所以只能用直升机送出岛。\n- 对于第七个中暑者，由于区 $3,4$ 上的医院均已满员，所以只能用直升机送出岛。\n\n此时共有 $3$ 人动用直升机送出岛。可以证明这是最大值。\n\n样例 $1$ 满足子任务 $1\\sim 8$ 的条件。\n\n样例 $2$ 满足子任务 $2\\sim 8$ 的条件。\n\n样例 $3$ 满足子任务 $1,5\\sim 8$ 的条件。\n\n样例 $4,5$ 满足子任务 $5\\sim 8$ 的条件。\n\n### 数据范围\n\n- $2 \\le L \\le 8\\,000$；\n- $0 \\le C_i \\le 8\\,000$（$1 \\le i \\le L$）；\n- $1 \\le N \\le 8\\,000$；\n- $1 \\le X_j \\le L − 1$（$1 \\le j \\le N$）；\n- 输入数字全为整数。\n\n【子任务】\n\n1. （$6 $ points）$X_1 \\le X_2 \\le\\cdots\\le X_N$；\n2. （$7 $ points）$L \\le 18, N \\le 18, C_i = 1 $（$1 \\le i \\le L$）；\n3. （$7 $ points）$L \\le 18, N \\le 100, C_i = 1 $（$1 \\le i \\le L$）；\n4. （$25$  points）$L \\le 100, N \\le 100, C_i = 1$ （$1 \\le i \\le L$）；\n5. （$25$  points）$L \\le 100, N \\le 100$；\n6. （$10$  points）$L \\le 600, N \\le 600$；\n7. （$15$  points）$L \\le 3\\,500, N \\le 3\\,500$；\n8. （$5 $ points）无额外约束。\n\n由 Starrykiller 根据英文题面翻译。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI Open 2024] 中暑 / Heat Stroke", "background": "", "description": "JOI 岛由 $L$ 个区组成，从西到东依次编号为 $1$ 到 $L$。岛上有 $(L-1)$ 条路，编号为 $1$ 到 $L-1$。第 $i$ 条路（$1\\le i\\le L-1$）双向连接着区 $i$ 和区 $i+1$。\n\n现在，IOI 20XX 计划在 JOI 岛上举行！然而，令人担心的是，JOI 岛以其“火炉”称号而闻名于世。在岛上中暑风险较高，尤其是对于不适应 JOI 岛炎热气候的外国人。所以，IOI 的组织者决定采取以下措施：\n\n- 对于每一个 $1\\le i\\le L$，在区 $i$ 上有一个容量为 $C_i$ 人的医院。注意，$C_i$ 可以为 $0$。\n\n- 在 IOI 活动中，当有人在第 $x$ 条路（$1\\le x\\le L-1$）上中暑时，中暑者将以以下的程序送医：\n    - 将中暑者送往区 $x$ 或者区 $x+1$ 上的未满员的医院。如果两个区上的医院都未满员，则送往哪一个医院都可以。如果两个医院都满员了，用直升机将中暑者送往岛外的医院。\n\n由于动用直升机花销不小，组织者们想要估计可能的需要动用直升机的病人数量的**最大值**。他们考虑如下的情境：\n\n- 在 IOI 活动之前，医院中没有病人；\n- 在 IOI 活动中，有 $N$ 个人会依次中暑。第 $j$ 个（$1\\le j\\le N$）人在第 $X_j$ 条路上中暑；\n- 对于任意 $1\\le j\\le N-1$，当第 $(j+1)$ 个人中暑时，第 $1,2,\\cdots,j$ 个人已经送达医院。由于中暑症状较为严重，在 IOI 活动中无人出院。\n\n你需要写一个程序。给定区的数量，医院的信息和中暑者的信息，在上述情境下，计算可能的需要动用直升机的病人数量的最大值。\n", "inputFormat": "输入格式如下所示：\n> $L$\\\n> $C_1$ $C_2$ $\\cdots$ $C_L$ \\\n> $N$\\\n> $X_1$ $X_2$ $\\cdots$ $X_N$", "outputFormat": "输出一行一个数，即可能的需要动用直升机的病人数量的最大值。", "hint": "### 样例解释\n\n对于样例 $1$，考虑如下的情况：\n\n- 将第一个中暑者送往区 $2$ 上的医院。此时，三个区上的医院的病人数量分别为 $0,1,0$；\n- 将第二个中暑者送往区 $3$ 上的医院。此时，三个区上的医院的病人数量分别为 $0,1,1$；\n- 对于第三个中暑者，由于区 $2,3$ 上的医院均已满员，所以只能用直升机送出岛。\n\n此时共有 $1$ 人动用直升机送出岛。可以证明这是最大值。\n\n对于样例 $2$，考虑如下的情况：\n\n- 将第一个中暑者送往区 $2$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,0,0,0,0$；\n- 将第二个中暑者送往区 $4$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,0,1,0,0$；\n- 将第三个中暑者送往区 $5$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,0,1,1,0$；\n- 对于第四个中暑者，由于区 $4,5$ 上的医院均已满员，所以只能用直升机送出岛。\n- 将第五个中暑者送往区 $3$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,1,1,1,0$；\n- 对于第六个中暑者，由于区 $2,3$ 上的医院均已满员，所以只能用直升机送出岛。\n- 对于第七个中暑者，由于区 $3,4$ 上的医院均已满员，所以只能用直升机送出岛。\n\n此时共有 $3$ 人动用直升机送出岛。可以证明这是最大值。\n\n样例 $1$ 满足子任务 $1\\sim 8$ 的条件。\n\n样例 $2$ 满足子任务 $2\\sim 8$ 的条件。\n\n样例 $3$ 满足子任务 $1,5\\sim 8$ 的条件。\n\n样例 $4,5$ 满足子任务 $5\\sim 8$ 的条件。\n\n### 数据范围\n\n- $2 \\le L \\le 8\\,000$；\n- $0 \\le C_i \\le 8\\,000$（$1 \\le i \\le L$）；\n- $1 \\le N \\le 8\\,000$；\n- $1 \\le X_j \\le L − 1$（$1 \\le j \\le N$）；\n- 输入数字全为整数。\n\n【子任务】\n\n1. （$6 $ points）$X_1 \\le X_2 \\le\\cdots\\le X_N$；\n2. （$7 $ points）$L \\le 18, N \\le 18, C_i = 1 $（$1 \\le i \\le L$）；\n3. （$7 $ points）$L \\le 18, N \\le 100, C_i = 1 $（$1 \\le i \\le L$）；\n4. （$25$  points）$L \\le 100, N \\le 100, C_i = 1$ （$1 \\le i \\le L$）；\n5. （$25$  points）$L \\le 100, N \\le 100$；\n6. （$10$  points）$L \\le 600, N \\le 600$；\n7. （$15$  points）$L \\le 3\\,500, N \\le 3\\,500$；\n8. （$5 $ points）无额外约束。\n\n由 Starrykiller 根据英文题面翻译。", "locale": "zh-CN"}}}
{"pid": "P10628", "type": "P", "difficulty": 6, "samples": [["4\n2 0 3 1", ""]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["二分", "2024", "交互题", "Special Judge", "置换", "JOI（日本）"], "title": "[JOI Open 2024] 图书馆 3 / Library 3", "background": "由于洛谷评测系统的限制，实际提交时，不需要引入 $\\texttt{library3.h}$。你需要在代码中添加：\n\n```cpp\nvoid answer(std::vector<int>);\nint query(std::vector<int>);\n```\n\n请使用 C++ 20 提交，不保证使用其他标准提交能够通过。", "description": "几百年的时光弹指一瞬，JOI 城已然是一片废墟。IOI 酱——一个探险家，正在探索图书馆的故址。由探索结果得知：\n\n- JOI 城的图书馆中有一个水平的书架，上面有 $N$ 个**位置**来放书，从左到右依次编号为 $0\\sim N-1$。一个位置只能放一本书。\n- 有 $N$ 本书放在书架上，编号为 $0\\sim N-1$。\n- 定义 $N$ 本书的一个**摆放**为一种将 $N$ 本书放在 $N$ 个位置上的方式。\n- 存在 $N$ 本书的一个**正确摆放**，其中第 $B_i$（$0\\le i\\le N-1$）本书放在位置 $i$ 上，其中 $B_i$ 两两不同。\n\n书的摆放总会改变，而这个图书馆是通过不断重复以下步骤来将书还原成正确摆放的：\n\n> **操作** 令 $x$ 是最左边的书，满足 $x$ 的位置与它在正确摆放中的位置不同。令 $y$ 为 $x$ 正确位置上的书，交换 $x,y$。\n\n尽管 IOI 酱找到了许多旧书，她无法得知书的正确摆放。然而，她发现了一台旧机器，可以执行上面的操作。如果指定一个摆放并向机器发起询问，机器就会回答从当前摆放到正确摆放，需要重复执行多少次操作。IOI 酱想要利用这台机器，获得书的正确摆放。由于机器过于老旧，她最多只能询问 $5\\, 000$ 次。\n\n你需要写一个程序。给定书架的信息，通过最多 $5\\,000$ 次询问，找出书的正确摆放。\n\n【实现细节】\n\n**这是一道交互题，你只需要提交一个文件（`library3.cpp`）。**\n\n你需要在文件中引入 `library3.h`，并实现以下函数：\n\n- `void solve(int N)`\\\n该函数在每个测试点中被调用恰好一次。\n    - 参数 $N$ 代表书的数量。\n\n在 `library3.cpp` 中，你可以调用以下函数：\n\n- `int query(const std::vector<int> a)`\\\nIOI 酱用这个函数向机器发起询问。\n    - 参数 `a` 为一个长度为 $N$ 的数组，即要询问的摆放。也就是说，在指定的摆放中，第 `a[i]` 本书（$0\\le i\\le N-1$）被放在位置 $i$。\n    - 返回值为一个整数，即从指定的摆放到正确摆放，需要重复执行多少次操作。\n    - 参数中，数组 `a` 的长度必须为 $N$。如果不满足这个条件，你的程序将被判为 **Wrong Answer[1]**。\n    - 参数中，数组 `a` 中的每个元素都必须在 $0$ 到 $N-1$ 之间。如果不满足这个条件，你的程序将被判为 **Wrong Answer[2]**。\n    - 参数中，数组 `a` 中的元素必须两两不同。如果不满足这个条件，你的程序将被判为 **Wrong Answer[3]**。\n    - 该函数最多只能被调用 $5\\,000$ 次。如果超出调用次数，你的程序将被判为 **Wrong Answer[4]**。\n\n- `void answer(std::vector<int> b)`\\\n你的程序用这个函数回答正确摆放。\n    - 参数 `b` 为一个长度为 $N$ 的数组，即正确摆放。也就是说，在正确摆放中，第 `b[i]` 本书（$0\\le i\\le N-1$）被放在位置 $i$。\n    - 参数中，数组 `b` 的长度必须为 $N$。如果不满足这个条件，你的程序将被判为 **Wrong Answer[5]**。\n    - 参数中，数组 `b` 中的每个元素都必须在 $0$ 到 $N-1$ 之间。如果不满足这个条件，你的程序将被判为 **Wrong Answer[6]**。\n    - 参数中，数组 `b` 中的元素必须两两不同。如果不满足这个条件，你的程序将被判为 **Wrong Answer[7]**。\n    - 如果你回答的摆放并不是正确摆放，你的程序将被判为 **Wrong Answer[8]**。\n    - 该函数必须被调用恰好一次。如果超出调用次数，你的程序将被判为 **Wrong Answer[9]**。如果未调用，你的程序将被判为 **Wrong Answer[10]**。\n\n【注意事项】\n\n你的程序可以定义其他函数，也可以使用全局变量。\n\n你的程序不得使用标准输入输出流，不得以任何形式读写其他文件。但是，你的程序可以使用标准错误流来输出调试信息。\n\n【编译运行】\n\n可以从附件中获取 sample grader。Sample grader 即为文件 `grader.cpp`。将 `grader.cpp`，`library3.cpp`，`library3.h` 放置在同一目录下，运行以下命令即可编译你的程序。你也可以运行文件 `compile.sh` 来编译程序。\n\n> 编译命令：`g++ -std=gnu++20 -O2 -o grader grader.cpp library3.cpp`\n\n编译成功的话，会生成可执行文件 `grader`。注意，实际评测时用的 grader 与 sample grader 是不同的。Sample grader 会以单进程方式执行，从标准输入流中读取数据，输出结果到标准输出流。\n\n*赛时公告：Sample grader 是非适应性的。实际评测时使用的 grader 是否适应是未知的。\n\n", "inputFormat": "Sample grader 按照以下方式读取输入：\n\n> $N$\\\n> $B_0$ $B_1$ $\\cdots$ $B_{N-1}$\n\n在正确摆放中，第 $B_i$（$0\\le i\\le N-1$）本书放在位置 $i$ 上。", "outputFormat": "Sample grader 会输出以下结果：\n\n- 如果你的程序被评为正确的，返回调用 `query` 函数的次数。例如：`Accepted: 3000`。\n- 否则，如果你的程序满足任一形式的错误，则按照题目描述中的错误类型输出。例如：`Wrong Answer[3]`。\n\n如果你的程序同时满足多种错误的条件，只会输出一种错误。", "hint": "\n\n如下是一种可能的交互过程：\n\n| 调用 | 调用 | 返回值 |\n| :--: | :--:| :--: |\n| `solve(4)` | | |\n| | `query([0, 1, 2, 3])` | `3` |\n| | `query([1, 3, 0, 2])` | `2` |\n| | `query([3, 0, 1, 2])` | `2` |\n| | `query([2, 0, 3, 1])` | `0` |\n| | `answer([2, 0, 3, 1])` | |\n\n\n考虑调用 `query([0, 1, 2, 3])`。操作将会按照如下方式进行：\n\n- 交换第 $0$ 本书和第 $1$ 本书的位置。于是，第 $1,0,2,3$ 本书分别被放在位置 $0,1,2,3$ 上。\n- 交换第 $1$ 本书和第 $3$ 本书的位置。于是，第 $3,0,2,1$ 本书分别被放在位置 $0,1,2,3$ 上。\n- 交换第 $3$ 本书和第 $2$ 本书的位置。于是，第 $2,0,3,1$ 本书分别被放在位置 $0,1,2,3$ 上。\n\n在 $3$ 次操作后，将指定的摆放还原成了正确的摆放，所以返回值为 `3`。\n\n样例满足所有子任务的限制条件。\n\n### 数据范围\n\n- $2 \\le N \\le 500$；\n- $0 \\le B_i \\le N - 1$（$0 \\le i \\le N - 1$）；\n- $B_i\\neq B_j$（$0 \\le i < j \\le N - 1$）；\n- 输入数字全为整数。\n\n### 子任务\n\n1. （$2 $ points）$N \\le 6$；\n2. （$19$ points）$N \\le 100$；\n3. （$79$ points）无额外约束。\n\n由 Starrykiller 根据英文题面翻译。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI Open 2024] 图书馆 3 / Library 3", "background": "由于洛谷评测系统的限制，实际提交时，不需要引入 $\\texttt{library3.h}$。你需要在代码中添加：\n\n```cpp\nvoid answer(std::vector<int>);\nint query(std::vector<int>);\n```\n\n请使用 C++ 20 提交，不保证使用其他标准提交能够通过。", "description": "几百年的时光弹指一瞬，JOI 城已然是一片废墟。IOI 酱——一个探险家，正在探索图书馆的故址。由探索结果得知：\n\n- JOI 城的图书馆中有一个水平的书架，上面有 $N$ 个**位置**来放书，从左到右依次编号为 $0\\sim N-1$。一个位置只能放一本书。\n- 有 $N$ 本书放在书架上，编号为 $0\\sim N-1$。\n- 定义 $N$ 本书的一个**摆放**为一种将 $N$ 本书放在 $N$ 个位置上的方式。\n- 存在 $N$ 本书的一个**正确摆放**，其中第 $B_i$（$0\\le i\\le N-1$）本书放在位置 $i$ 上，其中 $B_i$ 两两不同。\n\n书的摆放总会改变，而这个图书馆是通过不断重复以下步骤来将书还原成正确摆放的：\n\n> **操作** 令 $x$ 是最左边的书，满足 $x$ 的位置与它在正确摆放中的位置不同。令 $y$ 为 $x$ 正确位置上的书，交换 $x,y$。\n\n尽管 IOI 酱找到了许多旧书，她无法得知书的正确摆放。然而，她发现了一台旧机器，可以执行上面的操作。如果指定一个摆放并向机器发起询问，机器就会回答从当前摆放到正确摆放，需要重复执行多少次操作。IOI 酱想要利用这台机器，获得书的正确摆放。由于机器过于老旧，她最多只能询问 $5\\, 000$ 次。\n\n你需要写一个程序。给定书架的信息，通过最多 $5\\,000$ 次询问，找出书的正确摆放。\n\n【实现细节】\n\n**这是一道交互题，你只需要提交一个文件（`library3.cpp`）。**\n\n你需要在文件中引入 `library3.h`，并实现以下函数：\n\n- `void solve(int N)`\\\n该函数在每个测试点中被调用恰好一次。\n    - 参数 $N$ 代表书的数量。\n\n在 `library3.cpp` 中，你可以调用以下函数：\n\n- `int query(const std::vector<int> a)`\\\nIOI 酱用这个函数向机器发起询问。\n    - 参数 `a` 为一个长度为 $N$ 的数组，即要询问的摆放。也就是说，在指定的摆放中，第 `a[i]` 本书（$0\\le i\\le N-1$）被放在位置 $i$。\n    - 返回值为一个整数，即从指定的摆放到正确摆放，需要重复执行多少次操作。\n    - 参数中，数组 `a` 的长度必须为 $N$。如果不满足这个条件，你的程序将被判为 **Wrong Answer[1]**。\n    - 参数中，数组 `a` 中的每个元素都必须在 $0$ 到 $N-1$ 之间。如果不满足这个条件，你的程序将被判为 **Wrong Answer[2]**。\n    - 参数中，数组 `a` 中的元素必须两两不同。如果不满足这个条件，你的程序将被判为 **Wrong Answer[3]**。\n    - 该函数最多只能被调用 $5\\,000$ 次。如果超出调用次数，你的程序将被判为 **Wrong Answer[4]**。\n\n- `void answer(std::vector<int> b)`\\\n你的程序用这个函数回答正确摆放。\n    - 参数 `b` 为一个长度为 $N$ 的数组，即正确摆放。也就是说，在正确摆放中，第 `b[i]` 本书（$0\\le i\\le N-1$）被放在位置 $i$。\n    - 参数中，数组 `b` 的长度必须为 $N$。如果不满足这个条件，你的程序将被判为 **Wrong Answer[5]**。\n    - 参数中，数组 `b` 中的每个元素都必须在 $0$ 到 $N-1$ 之间。如果不满足这个条件，你的程序将被判为 **Wrong Answer[6]**。\n    - 参数中，数组 `b` 中的元素必须两两不同。如果不满足这个条件，你的程序将被判为 **Wrong Answer[7]**。\n    - 如果你回答的摆放并不是正确摆放，你的程序将被判为 **Wrong Answer[8]**。\n    - 该函数必须被调用恰好一次。如果超出调用次数，你的程序将被判为 **Wrong Answer[9]**。如果未调用，你的程序将被判为 **Wrong Answer[10]**。\n\n【注意事项】\n\n你的程序可以定义其他函数，也可以使用全局变量。\n\n你的程序不得使用标准输入输出流，不得以任何形式读写其他文件。但是，你的程序可以使用标准错误流来输出调试信息。\n\n【编译运行】\n\n可以从附件中获取 sample grader。Sample grader 即为文件 `grader.cpp`。将 `grader.cpp`，`library3.cpp`，`library3.h` 放置在同一目录下，运行以下命令即可编译你的程序。你也可以运行文件 `compile.sh` 来编译程序。\n\n> 编译命令：`g++ -std=gnu++20 -O2 -o grader grader.cpp library3.cpp`\n\n编译成功的话，会生成可执行文件 `grader`。注意，实际评测时用的 grader 与 sample grader 是不同的。Sample grader 会以单进程方式执行，从标准输入流中读取数据，输出结果到标准输出流。\n\n*赛时公告：Sample grader 是非适应性的。实际评测时使用的 grader 是否适应是未知的。\n\n", "inputFormat": "Sample grader 按照以下方式读取输入：\n\n> $N$\\\n> $B_0$ $B_1$ $\\cdots$ $B_{N-1}$\n\n在正确摆放中，第 $B_i$（$0\\le i\\le N-1$）本书放在位置 $i$ 上。", "outputFormat": "Sample grader 会输出以下结果：\n\n- 如果你的程序被评为正确的，返回调用 `query` 函数的次数。例如：`Accepted: 3000`。\n- 否则，如果你的程序满足任一形式的错误，则按照题目描述中的错误类型输出。例如：`Wrong Answer[3]`。\n\n如果你的程序同时满足多种错误的条件，只会输出一种错误。", "hint": "\n\n如下是一种可能的交互过程：\n\n| 调用 | 调用 | 返回值 |\n| :--: | :--:| :--: |\n| `solve(4)` | | |\n| | `query([0, 1, 2, 3])` | `3` |\n| | `query([1, 3, 0, 2])` | `2` |\n| | `query([3, 0, 1, 2])` | `2` |\n| | `query([2, 0, 3, 1])` | `0` |\n| | `answer([2, 0, 3, 1])` | |\n\n\n考虑调用 `query([0, 1, 2, 3])`。操作将会按照如下方式进行：\n\n- 交换第 $0$ 本书和第 $1$ 本书的位置。于是，第 $1,0,2,3$ 本书分别被放在位置 $0,1,2,3$ 上。\n- 交换第 $1$ 本书和第 $3$ 本书的位置。于是，第 $3,0,2,1$ 本书分别被放在位置 $0,1,2,3$ 上。\n- 交换第 $3$ 本书和第 $2$ 本书的位置。于是，第 $2,0,3,1$ 本书分别被放在位置 $0,1,2,3$ 上。\n\n在 $3$ 次操作后，将指定的摆放还原成了正确的摆放，所以返回值为 `3`。\n\n样例满足所有子任务的限制条件。\n\n### 数据范围\n\n- $2 \\le N \\le 500$；\n- $0 \\le B_i \\le N - 1$（$0 \\le i \\le N - 1$）；\n- $B_i\\neq B_j$（$0 \\le i < j \\le N - 1$）；\n- 输入数字全为整数。\n\n### 子任务\n\n1. （$2 $ points）$N \\le 6$；\n2. （$19$ points）$N \\le 100$；\n3. （$79$ points）无额外约束。\n\n由 Starrykiller 根据英文题面翻译。", "locale": "zh-CN"}}}
{"pid": "P10630", "type": "P", "difficulty": 6, "samples": [["5\n-5 5 -2\n2 5 10\n1 4 -2\n4 -5 4\n-2 2 7", "19"], ["6\n0 0 6\n1 0 -2\n2 0 8\n0 1 -2\n1 1 5\n2 1 -2", "15"], ["5\n0 0 2\n4 0 2\n3 2 -1\n1 2 2\n1 1 -1", "5"], ["2\n0 0 -1\n1 0 -1", "0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "JOI（日本）"], "title": "[JOI Open 2017] 推土机 / Bulldozer", "background": "", "description": "**译自 [JOI Open 2017](https://contests.ioi-jp.org/open-2017/index.html) T2 「ブルドーザー / Bulldozer」**\n\n平面上有 $N$ 个点，点 $i\\:(1≤i≤N)$ 位于 $(X_i, Y_i)$，点 $i\\:(1≤i≤N)$ 的权值为非零整数 $W_i$（可能为负数）。  \n在平面上画两条平行线，所得的总价值为平行线之间（压线也算）所有点的权值之和。求总价值至多不超过多少。", "inputFormat": "第一行包含一个整数 $N$。  \n在接下来的 $N$ 行中，第 $i$ 行包含三个用空格分隔的整数 $X_i,Y_i,W_i$。", "outputFormat": "一行，一个整数，表示最大总价值。", "hint": "**样例解释 1**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rk2miemg.png)\n\n选择点 $2, 3, 4, 5$。\n\n**样例解释 2**\n\n注意，点 $1,2,3$ 共线。点 $4,5,6$ 共线。\n\n**样例解释 3**\n\n这组样例中没有三点共线。选择的平行线一条过点 $1,2$，另一条过点 $3,4$。\n\n#### 数据范围\n\n所有输入数据都满足以下条件。\n\n $1≤N≤2000, |X_i|,|Y_i|≤10^9,1 ≤|W_i|≤10^9(1≤i≤N)$ 。$(X_i,Y_i)≠(X_j,Y_j)\\:(1≤i<j≤N)$ 。\n\n|子任务|分值|$N≤100$|无三点共线|设 $L$ 是在平面上通过两个不同点的一条线，$L'$ 是在平面上另一条通过两个不同点的线，那么 $L$ 和 $L'$ **不**相互平行|其他条件|\n|:---------:|:------------:|:-------------:|:---------------:|:-:|:------------:|\n|$1$     |$5$    |√            |×                 |×|所有点都在 $x$ 轴上|\n|$2$     |$20$  |√          |√               |√|无|\n|$3$     |$35$  |×          |√                |√|无|\n|$4$     |$20$  |×          |√                |×|无|\n|$5$     |$20$  |×          |×                |×|无|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI Open 2017] 推土机 / Bulldozer", "background": "", "description": "**译自 [JOI Open 2017](https://contests.ioi-jp.org/open-2017/index.html) T2 「ブルドーザー / Bulldozer」**\n\n平面上有 $N$ 个点，点 $i\\:(1≤i≤N)$ 位于 $(X_i, Y_i)$，点 $i\\:(1≤i≤N)$ 的权值为非零整数 $W_i$（可能为负数）。  \n在平面上画两条平行线，所得的总价值为平行线之间（压线也算）所有点的权值之和。求总价值至多不超过多少。", "inputFormat": "第一行包含一个整数 $N$。  \n在接下来的 $N$ 行中，第 $i$ 行包含三个用空格分隔的整数 $X_i,Y_i,W_i$。", "outputFormat": "一行，一个整数，表示最大总价值。", "hint": "**样例解释 1**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rk2miemg.png)\n\n选择点 $2, 3, 4, 5$。\n\n**样例解释 2**\n\n注意，点 $1,2,3$ 共线。点 $4,5,6$ 共线。\n\n**样例解释 3**\n\n这组样例中没有三点共线。选择的平行线一条过点 $1,2$，另一条过点 $3,4$。\n\n#### 数据范围\n\n所有输入数据都满足以下条件。\n\n $1≤N≤2000, |X_i|,|Y_i|≤10^9,1 ≤|W_i|≤10^9(1≤i≤N)$ 。$(X_i,Y_i)≠(X_j,Y_j)\\:(1≤i<j≤N)$ 。\n\n|子任务|分值|$N≤100$|无三点共线|设 $L$ 是在平面上通过两个不同点的一条线，$L'$ 是在平面上另一条通过两个不同点的线，那么 $L$ 和 $L'$ **不**相互平行|其他条件|\n|:---------:|:------------:|:-------------:|:---------------:|:-:|:------------:|\n|$1$     |$5$    |√            |×                 |×|所有点都在 $x$ 轴上|\n|$2$     |$20$  |√          |√               |√|无|\n|$3$     |$35$  |×          |√                |√|无|\n|$4$     |$20$  |×          |√                |×|无|\n|$5$     |$20$  |×          |×                |×|无|", "locale": "zh-CN"}}}
{"pid": "P10631", "type": "P", "difficulty": 6, "samples": [["3 5 8 6\n1\n5 6 2 8", "3"], ["1 1 1 10\n3\n5 6 2 8\n1 2 2 3\n8 10 3 5", "1"], ["20 68 85 74\n5\n30 70 14 100\n5 24 15 67\n75 86 75 79\n75 90 19 62\n93 98 26 58", "4"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2017", "线段树", "广度优先搜索 BFS", "扫描线", "JOI（日本）"], "title": "[JOI Open 2017] 高尔夫 / Golf", "background": "", "description": "**译自 [JOI Open 2017](https://contests.ioi-jp.org/open-2017/index.html) T3 「ゴルフ / Golf」**\n\n平面的第一象限上有 $N$ 个矩形障碍，矩形的两组对边分别平行于 $x$ 轴和 $y$ 轴。矩形 $i(1\\le i\\le N)$ 的左下角是 $(A_i, C_i)$，右上角是 $(B_i, D_i)$。任意两个矩形（包括边界）不相交。  \nJOI 君需要将一个高尔夫球从 $(S,T)$ 打到 $(U,V)$，保证这两点不同，保证这两点不在障碍内或障碍的边界上。  \nJOI 君只能朝平行于 $x$ 轴或平行与 $y$ 轴的方向击球（JOI 君可以跟着移动）。球可以经过边界，但不能进入障碍物内部。球撞进障碍物后会停下（JOI 君仍然可以朝远离障碍物的方向击球）。  \n求最少要击球多少次，才能将高尔夫球打进 $(U,V)$。", "inputFormat": "第一行有四个整数 $S, T, U, V$。  \n第二行有一个整数 $N$。  \n在接下来的 $N$ 行中，每行有四个整数 $A_i, B_i, C_i, D_i$。", "outputFormat": "输出一行，一个整数，表示最少击球次数。", "hint": "**样例解释 1**\n\n$(3,5) → (3,2) → (8,2) → (8,6)$\n\n\n#### 数据范围\n\n$1\\le S, T, U, V\\le 10^9, 1\\le N\\le 10^5, 1\\le A_i<B_i\\le 10^9, 1\\le C_i<D_i\\le 10^9,$ $(S,T)≠(U,V)$。  \n\n- 子任务 #1（10 分）：$S, T, U, V, N, B_i, D_i\\le 1000$；  \n- 子任务 #2（20 分）：$N\\le 1000$；  \n- 子任务 #3（70 分）：没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI Open 2017] 高尔夫 / Golf", "background": "", "description": "**译自 [JOI Open 2017](https://contests.ioi-jp.org/open-2017/index.html) T3 「ゴルフ / Golf」**\n\n平面的第一象限上有 $N$ 个矩形障碍，矩形的两组对边分别平行于 $x$ 轴和 $y$ 轴。矩形 $i(1\\le i\\le N)$ 的左下角是 $(A_i, C_i)$，右上角是 $(B_i, D_i)$。任意两个矩形（包括边界）不相交。  \nJOI 君需要将一个高尔夫球从 $(S,T)$ 打到 $(U,V)$，保证这两点不同，保证这两点不在障碍内或障碍的边界上。  \nJOI 君只能朝平行于 $x$ 轴或平行与 $y$ 轴的方向击球（JOI 君可以跟着移动）。球可以经过边界，但不能进入障碍物内部。球撞进障碍物后会停下（JOI 君仍然可以朝远离障碍物的方向击球）。  \n求最少要击球多少次，才能将高尔夫球打进 $(U,V)$。", "inputFormat": "第一行有四个整数 $S, T, U, V$。  \n第二行有一个整数 $N$。  \n在接下来的 $N$ 行中，每行有四个整数 $A_i, B_i, C_i, D_i$。", "outputFormat": "输出一行，一个整数，表示最少击球次数。", "hint": "**样例解释 1**\n\n$(3,5) → (3,2) → (8,2) → (8,6)$\n\n\n#### 数据范围\n\n$1\\le S, T, U, V\\le 10^9, 1\\le N\\le 10^5, 1\\le A_i<B_i\\le 10^9, 1\\le C_i<D_i\\le 10^9,$ $(S,T)≠(U,V)$。  \n\n- 子任务 #1（10 分）：$S, T, U, V, N, B_i, D_i\\le 1000$；  \n- 子任务 #2（20 分）：$N\\le 1000$；  \n- 子任务 #3（70 分）：没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P10632", "type": "P", "difficulty": 7, "samples": [["3\n0 1\n1 2", "5.6667"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "点分治", "多项式", "Special Judge", "O2优化", "期望", "快速数论变换 NTT"], "title": "Normal", "background": "", "description": "某天 WJMZBMR 学习了一个神奇的算法：树的点分治！\n\n这个算法的核心是这样的：\n\n```cpp\ntime = 0\nSolve(Tree a) {\n  time += a.size;\n  if (a.size == 1) return;\n  else {\n    select x in a;\n    delete a[x];\n  }\n}\n```\n\n```\n消耗时间 = 0\nSolve(树 a)\n  消耗时间 += a 的大小\n  如果 a 中 只有 1 个点\n    退出\n  否则\n    在 a 中选一个点x\n    在 a 中删除点x\n```\n\n那么 $a$ 变成了几个小一点的树，对每个小树递归调用 `Solve`。\n\n我们注意到的这个算法的时间复杂度跟选择的点 $x$ 是密切相关的，如果 $x$ 是树的重心，那么时间复杂度就是 $O(n \\log n)$。\n\nWJMZBMR 决定随机在 $a$ 中选择一个点作为 $x$，Sevenkplus 告诉他这样做的最坏复杂度是 $O(n^2)$，但是 WJMZBMR 就是不信，于是 Sevenkplus 花了几分钟写了一个程序证明了这一点，你也试试看吧。\n\n现在给你一颗树，你能告诉 WJMZBMR 他的算法需要的期望消耗时间吗（以给出的 `Solve` 函数中的为标准）？", "inputFormat": "第一行一个整数 $n$，表示树的大小；接下来 $n-1$ 行每行两个整数 $a,b$，表示 $a$ 和 $b$ 之间有一条边。\n\n树的结点从 $0$ 开始编号。", "outputFormat": "一行一个浮点数表示答案，并四舍五入到小数点后 $4$ 位。", "hint": "对于所有的数据，保证 $1\\leq n\\leq 30000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Normal", "background": "", "description": "某天 WJMZBMR 学习了一个神奇的算法：树的点分治！\n\n这个算法的核心是这样的：\n\n```cpp\ntime = 0\nSolve(Tree a) {\n  time += a.size;\n  if (a.size == 1) return;\n  else {\n    select x in a;\n    delete a[x];\n  }\n}\n```\n\n```\n消耗时间 = 0\nSolve(树 a)\n  消耗时间 += a 的大小\n  如果 a 中 只有 1 个点\n    退出\n  否则\n    在 a 中选一个点x\n    在 a 中删除点x\n```\n\n那么 $a$ 变成了几个小一点的树，对每个小树递归调用 `Solve`。\n\n我们注意到的这个算法的时间复杂度跟选择的点 $x$ 是密切相关的，如果 $x$ 是树的重心，那么时间复杂度就是 $O(n \\log n)$。\n\nWJMZBMR 决定随机在 $a$ 中选择一个点作为 $x$，Sevenkplus 告诉他这样做的最坏复杂度是 $O(n^2)$，但是 WJMZBMR 就是不信，于是 Sevenkplus 花了几分钟写了一个程序证明了这一点，你也试试看吧。\n\n现在给你一颗树，你能告诉 WJMZBMR 他的算法需要的期望消耗时间吗（以给出的 `Solve` 函数中的为标准）？", "inputFormat": "第一行一个整数 $n$，表示树的大小；接下来 $n-1$ 行每行两个整数 $a,b$，表示 $a$ 和 $b$ 之间有一条边。\n\n树的结点从 $0$ 开始编号。", "outputFormat": "一行一个浮点数表示答案，并四舍五入到小数点后 $4$ 位。", "hint": "对于所有的数据，保证 $1\\leq n\\leq 30000$。", "locale": "zh-CN"}}}
{"pid": "P10633", "type": "P", "difficulty": 5, "samples": [["3 5\n2 4 3\nQuery 2 2\nModify 1 3\nQuery 2 2\nModify 1 2\nQuery 1 1", "2\n3\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["树状数组", "cdq 分治", "O2优化"], "title": "BZOJ2989 数列/BZOJ4170 极光", "background": "", "description": "给定一个长度为 $n$ 的正整数数列 $a_i$，两个位置的 $\\text{graze}$ 值为两者位置差与数值差的和：$\\text{graze}(x,y)=|x-y|+|a_x-a_y|$。\n\n你必须支持两种操作（$k$ 都是正整数）：\n- `Modify x k`，表示将第 $x$ 个数的值修改为 $k$；\n- `Query x k`，表示询问有几个 $i$ 满足 $\\text{graze}(x,i) \\leq k$；\n\n询问不仅要考虑当前数列，还要考虑任意历史版本，即统计任意位置上出现过的任意数值与当前的 $a_x$ 的 $\\text{graze}$ 值 $\\leq k$ 的对数。（某位置多次修改为同样的数值，按多次统计。）", "inputFormat": "第一行两个整数 $n,q$，表示数列长度与操作数；\n\n第二行 $n$ 个正整数，代表初始数列。\n\n第 $3\\sim q+2$ 行，每行一个操作。", "outputFormat": "对于每次询问操作，输出一个非负整数表示答案。", "hint": "对于所有数据，保证 $1\\leq n\\leq 6\\times 10^4$，$1\\leq$ 修改操作数 $\\leq 5\\times 10^4$，$1\\leq$ 询问次数 $\\leq 6\\times 10^4$，$1\\leq a_i$ 的所有历史版本的最大值 $\\leq 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ2989 数列/BZOJ4170 极光", "background": "", "description": "给定一个长度为 $n$ 的正整数数列 $a_i$，两个位置的 $\\text{graze}$ 值为两者位置差与数值差的和：$\\text{graze}(x,y)=|x-y|+|a_x-a_y|$。\n\n你必须支持两种操作（$k$ 都是正整数）：\n- `Modify x k`，表示将第 $x$ 个数的值修改为 $k$；\n- `Query x k`，表示询问有几个 $i$ 满足 $\\text{graze}(x,i) \\leq k$；\n\n询问不仅要考虑当前数列，还要考虑任意历史版本，即统计任意位置上出现过的任意数值与当前的 $a_x$ 的 $\\text{graze}$ 值 $\\leq k$ 的对数。（某位置多次修改为同样的数值，按多次统计。）", "inputFormat": "第一行两个整数 $n,q$，表示数列长度与操作数；\n\n第二行 $n$ 个正整数，代表初始数列。\n\n第 $3\\sim q+2$ 行，每行一个操作。", "outputFormat": "对于每次询问操作，输出一个非负整数表示答案。", "hint": "对于所有数据，保证 $1\\leq n\\leq 6\\times 10^4$，$1\\leq$ 修改操作数 $\\leq 5\\times 10^4$，$1\\leq$ 询问次数 $\\leq 6\\times 10^4$，$1\\leq a_i$ 的所有历史版本的最大值 $\\leq 10^5$。", "locale": "zh-CN"}}}
