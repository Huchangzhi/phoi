{"pid": "P2025", "type": "P", "difficulty": 6, "samples": [["10", "10"], ["1000000", "3527171714"], ["10000000", "191685100"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["洛谷原创", "Dirichlet 卷积", "欧拉函数"], "title": "Dirichlet 半在线卷积", "background": "", "description": "已知函数 $f$ 满足 $f(1)=1$，且\n\n$$f(n)=\\sum_{d|n,d<n}f(d)\\varphi(n/d).$$\n\n给定正整数 $n$，试求出 $f(1),f(2),\\cdots,f(n)$ 的值。为控制输出量，你只需输出下式的值：\n\n$$\\bigoplus_{k=1}^n\\left(f(k)\\bmod 2^{32}\\right). $$\n\n其中 $\\oplus$ 代表异或。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "一行一个非负整数，代表 $\\bigoplus_{k=1}^n\\left(f(k)\\bmod 2^{32}\\right) $ 的值。", "hint": "对于所有数据，$1\\le n\\le 5\\times 10^7$。\n\n对于样例一，$f$ 的前 $10$ 项依次为：$1,1,2,3,4,6,6,9,10,12$。\n\n时限为 std 的 1.5 倍。", "locale": "zh-CN", "translations": {"en": {"title": "Dirichlet Semi-Online Convolution", "background": "", "description": "Given a function $f$ satisfying $f(1)=1$, and\n\n$$f(n)=\\sum_{d|n,d<n}f(d)\\varphi(n/d).$$\n\nGiven a positive integer $n$, compute the values $f(1), f(2), \\cdots, f(n)$. To control the output size, you only need to output the value of the following expression:\n\n$$\\bigoplus_{k=1}^n\\left(f(k)\\bmod 2^{32}\\right). $$\n\nHere $\\oplus$ denotes xor.", "inputFormat": "One line with a positive integer $n$.", "outputFormat": "One line with a non-negative integer, representing the value of $\\bigoplus_{k=1}^n\\left(f(k)\\bmod 2^{32}\\right)$.", "hint": "For all testdata, $1 \\le n \\le 5 \\times 10^7$.\n\nFor Sample 1, the first $10$ terms of $f$ are: $1, 1, 2, 3, 4, 6, 6, 9, 10, 12$.\n\nThe time limit is $1.5$ times that of std.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Dirichlet 半在线卷积", "background": "", "description": "已知函数 $f$ 满足 $f(1)=1$，且\n\n$$f(n)=\\sum_{d|n,d<n}f(d)\\varphi(n/d).$$\n\n给定正整数 $n$，试求出 $f(1),f(2),\\cdots,f(n)$ 的值。为控制输出量，你只需输出下式的值：\n\n$$\\bigoplus_{k=1}^n\\left(f(k)\\bmod 2^{32}\\right). $$\n\n其中 $\\oplus$ 代表异或。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "一行一个非负整数，代表 $\\bigoplus_{k=1}^n\\left(f(k)\\bmod 2^{32}\\right) $ 的值。", "hint": "对于所有数据，$1\\le n\\le 5\\times 10^7$。\n\n对于样例一，$f$ 的前 $10$ 项依次为：$1,1,2,3,4,6,6,9,10,12$。\n\n时限为 std 的 1.5 倍。", "locale": "zh-CN"}}}
{"pid": "P2026", "type": "P", "difficulty": 2, "samples": [["3 6\n2 4\n", "y=2x\n\n"], ["3 5\n2 7", "y=-2x+11"], ["3 -1\n5 -2", "y=-1/2*x+1/2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "洛谷原创"], "title": "求一次函数解析式", "background": "做数学寒假作业的怨念……\n", "description": "给定两个整点的坐标，求它们所在直线的函数解析式（一次函数）。\n", "inputFormat": "第一行有两个整数 $x_1,y_1$，表示第一个整点的坐标为 $(x_1,y_1)$。\n\n第二行有两个整数 $x_2,y_2$，表示第二个整点的坐标为 $(x_2,y_2)$。", "outputFormat": "输出共一行，即这个函数解析式。\n", "hint": "$2 x$ 表示为 `2x`。\n\n$\\frac{1}{2}x$ 表示为 `1/2*x`。", "locale": "zh-CN", "translations": {"en": {"title": "Find the Analytic Expression of a Linear Function", "background": "Resentment from doing winter vacation math homework.", "description": "Given the coordinates of two lattice points, find the function expression of the line they determine (a linear function).", "inputFormat": "The first line contains two integers $x_1, y_1$, indicating that the coordinates of the first lattice point are $(x_1, y_1)$.\n\nThe second line contains two integers $x_2, y_2$, indicating that the coordinates of the second lattice point are $(x_2, y_2)$.", "outputFormat": "Output a single line, which is the function expression.", "hint": "$2 x$ is written as `2x`.\n\n$\\frac{1}{2}x$ is written as `1/2*x`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "求一次函数解析式", "background": "做数学寒假作业的怨念……\n", "description": "给定两个整点的坐标，求它们所在直线的函数解析式（一次函数）。\n", "inputFormat": "第一行有两个整数 $x_1,y_1$，表示第一个整点的坐标为 $(x_1,y_1)$。\n\n第二行有两个整数 $x_2,y_2$，表示第二个整点的坐标为 $(x_2,y_2)$。", "outputFormat": "输出共一行，即这个函数解析式。\n", "hint": "$2 x$ 表示为 `2x`。\n\n$\\frac{1}{2}x$ 表示为 `1/2*x`。", "locale": "zh-CN"}}}
{"pid": "P2027", "type": "P", "difficulty": 3, "samples": [["write whatever u c ,.,.,.,. $ asdf $", "asdf"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "BrainFuck", "background": "bf 是一种编程语言，全称为 BrainFuck，因为题目名称不能太露骨，所以就简写成 bf 了。", "description": "这种语言的运行机制十分简单，只有一个大小为 $30000$ 的有符号 $8$ 位整数（范围 $[-128,127]$）的内存槽，和一个指向内存槽中位置的指针，在最初的时候指向内存槽的第一个整数。\n\n这种语言的字符集也是十分的简单，只有`+ - , . > < []`。\n\n|字符|意义|\n|:-|:-|\n|`<` 　|指针所指向的内存地址减一。|\n|`>` 　|指针所指向的内存地址加一。|\n|`+` 　|指针所指向的内存里面的数值加一。|\n|`-` 　|指针所指向的内存里面的数值减一。|\n|`.` 　|输出当前指针所指向的内存里面的数值（以字符形式输出）。|\n|`,` 　|将读入缓冲区中的一个字节送入当前指针指向的内存里面。如果读入缓冲区为空则送入 $-1$。|\n|`[` 　|当前指针指向的内存里面的数值不为 $0$ 时，重复执行与之相匹配的 `]` 之间的语句，直到回到 `[` 时当前指针指向的内存中的数值为 $0$。|\n|`]` 　|如上。|", "inputFormat": "输入数据若干行，代码有注释。直到一个 `$` 为代码截止。\n\n`$` 后面紧跟一个空格（不属于输入缓冲区），空格后面是输入缓冲区里面的内容，以一个空格和一个 `$` 截止。", "outputFormat": "输出这段代码的执行结果。", "hint": "对于 $10\\%$ 的数据，没有循环。\n\n对于另外 $10\\%$ 的数据，循环没有嵌套。\n\n对于 $100\\%$ 的数据，输入的程序不会访问越界，输入的程序能够在 $10^6$ 步内运行结束，输入的字符串的长度不大于 $30000$。\n\n字符在内存中的数值为字符所对应的 ASCII 码。", "locale": "zh-CN", "translations": {"en": {"title": "BrainFuck", "background": "bf is a programming language, short for BrainFuck. Since the problem title should not be too explicit, we abbreviate it as bf.", "description": "The execution model is very simple: there is an array of $30000$ signed $8$-bit integers (range $[-128,127]$) and a pointer to a position in this array, which initially points to the first cell.\n\nThe character set is also very simple: only `+ - , . > < []`.\n\n|Character|Meaning|\n|:-|:-|\n|`<` 　|Decrease the memory address pointed to by the pointer by one.|\n|`>` 　|Increase the memory address pointed to by the pointer by one.|\n|`+` 　|Increase the value in the current cell by one.|\n|`-` 　|Decrease the value in the current cell by one.|\n|`.` 　|Output the value in the current cell as a character.|\n|`,` 　|Read one byte from the input buffer into the current cell. If the input buffer is empty, store $-1$.|\n|`[` 　|While the value in the current cell is not $0$, repeat the statements between it and the matching `]`, until upon returning to `[` the current cell becomes $0$.|\n|`]` 　|Same as above.|", "inputFormat": "The input consists of several lines; the code may contain comments. The code ends at the first `$`.\n\nImmediately after the `$` comes a space (which does not belong to the input buffer), then the contents of the input buffer, ending with a space and a `$`.", "outputFormat": "Output the result of executing this code.", "hint": "For $10\\%$ of the testdata, there are no loops.\n\nFor another $10\\%$ of the testdata, loops have no nesting.\n\nFor $100\\%$ of the testdata, the program will not access out of bounds, the program will finish within $10^6$ steps, and the input string length is no greater than $30000$.\n\nThe value of a character in memory is the character’s ASCII code.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "BrainFuck", "background": "bf 是一种编程语言，全称为 BrainFuck，因为题目名称不能太露骨，所以就简写成 bf 了。", "description": "这种语言的运行机制十分简单，只有一个大小为 $30000$ 的有符号 $8$ 位整数（范围 $[-128,127]$）的内存槽，和一个指向内存槽中位置的指针，在最初的时候指向内存槽的第一个整数。\n\n这种语言的字符集也是十分的简单，只有`+ - , . > < []`。\n\n|字符|意义|\n|:-|:-|\n|`<` 　|指针所指向的内存地址减一。|\n|`>` 　|指针所指向的内存地址加一。|\n|`+` 　|指针所指向的内存里面的数值加一。|\n|`-` 　|指针所指向的内存里面的数值减一。|\n|`.` 　|输出当前指针所指向的内存里面的数值（以字符形式输出）。|\n|`,` 　|将读入缓冲区中的一个字节送入当前指针指向的内存里面。如果读入缓冲区为空则送入 $-1$。|\n|`[` 　|当前指针指向的内存里面的数值不为 $0$ 时，重复执行与之相匹配的 `]` 之间的语句，直到回到 `[` 时当前指针指向的内存中的数值为 $0$。|\n|`]` 　|如上。|", "inputFormat": "输入数据若干行，代码有注释。直到一个 `$` 为代码截止。\n\n`$` 后面紧跟一个空格（不属于输入缓冲区），空格后面是输入缓冲区里面的内容，以一个空格和一个 `$` 截止。", "outputFormat": "输出这段代码的执行结果。", "hint": "对于 $10\\%$ 的数据，没有循环。\n\n对于另外 $10\\%$ 的数据，循环没有嵌套。\n\n对于 $100\\%$ 的数据，输入的程序不会访问越界，输入的程序能够在 $10^6$ 步内运行结束，输入的字符串的长度不大于 $30000$。\n\n字符在内存中的数值为字符所对应的 ASCII 码。", "locale": "zh-CN"}}}
{"pid": "P2028", "type": "P", "difficulty": 3, "samples": [["4 2 3", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "洛谷原创", "Stirling 数"], "title": "龙兄摘苹果", "background": "", "description": "龙兄在淘淘摘苹果的那个果园里摘了 $n$ 个完全互不相同的苹果，好客的园主为他提供了 $k$ 个篮子，他想把苹果装在篮子里拎回家（由于龙兄的手是无限大的，所以你不必考虑他能不能同时拎这么多篮子）。\n\n同时，他不希望有任何一个篮子里是空的，因为这样就做不到物尽其用。因此他想知道一共有多少种放苹果的方法，由于他的大脑运算过慢，所以找到了聪明机智的你，他在摘苹果上已经花了很长时间，所以他只能等 $1$ 秒。\n\n由于方法很可能非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常多，龙兄的大脑无法存储，所以他会给你一个数 $p$，输出方法数除以 $p$ 的余数就可以了。", "inputFormat": "一行三个数，依次为 $n$，$k$，$p$，含义如题面所示。", "outputFormat": "一个数，方法数除以 $p$ 的余数，行末有回车。", "hint": "### 样例解释\n\n一共有 $4$ 个苹果，$2$ 个篮子。\n\n有以下 $7$ 种方法。\n\n- $\\{1\\},\\{2,3,4\\}$；\n- $\\{2\\},\\{1,3,4\\}$；\n- $\\{3\\},\\{1,2,4\\}$；\n- $\\{4\\},\\{1,2,3\\}$；\n- $\\{1,2\\},\\{3,4\\}$；\n- $\\{1,3\\},\\{2,4\\}$；\n- $\\{1,4\\},\\{2,3\\}$。\n\n$7$ 除以 $3$ 余 $1$。\n\n### 数据范围及约定\n\n- 对于 $20\\%$ 的数据，$n \\le 8$，$k \\le 8$。\n- 对于 $60\\%$ 的数据，$n \\le 100$，$k \\le 100$。\n- 对于 $100\\%$ 的数据，$n \\le 10000$，$k \\le 1000$。\n\n保证所有数据 $n \\ge k$，且答案在 $64$ 位整型范围内。", "locale": "zh-CN", "translations": {"en": {"title": "Long Xiong Picks Apples", "background": "", "description": "In the same orchard where Tao Tao picked apples, Long Xiong picked $n$ completely distinct apples. The hospitable owner provided him with $k$ baskets. He wants to put the apples into the baskets and carry them home (since Long Xiong’s hands are infinitely large, you do not need to consider whether he can carry multiple baskets at once).\n\nHe also does not want any basket to be empty, so as to make full use of the baskets. Therefore, he wants to know how many ways there are to distribute the apples. Because his brain computes slowly, he has asked you for help. He has already spent a long time picking apples, so he can only wait $1$ second.\n\nSince the number of ways may be extremely large, he will give you a number $p$; output the remainder when the number of ways is divided by $p$.\n\nTwo distributions are considered the same if each basket contains the same set of apples, and the order of baskets does not matter.", "inputFormat": "One line with three integers $n$, $k$, and $p$, as described above.", "outputFormat": "A single integer: the remainder when the number of ways is divided by $p$, followed by a newline.", "hint": "Sample explanation:\n\nThere are $4$ apples and $2$ baskets.\n\nThere are the following $7$ ways.\n- $\\{1\\},\\{2,3,4\\}$.\n- $\\{2\\},\\{1,3,4\\}$.\n- $\\{3\\},\\{1,2,4\\}$.\n- $\\{4\\},\\{1,2,3\\}$.\n- $\\{1,2\\},\\{3,4\\}$.\n- $\\{1,3\\},\\{2,4\\}$.\n- $\\{1,4\\},\\{2,3\\}$.\n\n$7$ divided by $3$ leaves a remainder of $1$.\n\nConstraints:\n- For $20\\%$ of the testdata, $n \\le 8$, $k \\le 8$.\n- For $60\\%$ of the testdata, $n \\le 100$, $k \\le 100$.\n- For $100\\%$ of the testdata, $n \\le 10000$, $k \\le 1000$.\n\nIt is guaranteed for all testdata that $n \\ge k$, and the answer fits in a $64$-bit integer.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "龙兄摘苹果", "background": "", "description": "龙兄在淘淘摘苹果的那个果园里摘了 $n$ 个完全互不相同的苹果，好客的园主为他提供了 $k$ 个篮子，他想把苹果装在篮子里拎回家（由于龙兄的手是无限大的，所以你不必考虑他能不能同时拎这么多篮子）。\n\n同时，他不希望有任何一个篮子里是空的，因为这样就做不到物尽其用。因此他想知道一共有多少种放苹果的方法，由于他的大脑运算过慢，所以找到了聪明机智的你，他在摘苹果上已经花了很长时间，所以他只能等 $1$ 秒。\n\n由于方法很可能非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常非常多，龙兄的大脑无法存储，所以他会给你一个数 $p$，输出方法数除以 $p$ 的余数就可以了。", "inputFormat": "一行三个数，依次为 $n$，$k$，$p$，含义如题面所示。", "outputFormat": "一个数，方法数除以 $p$ 的余数，行末有回车。", "hint": "### 样例解释\n\n一共有 $4$ 个苹果，$2$ 个篮子。\n\n有以下 $7$ 种方法。\n\n- $\\{1\\},\\{2,3,4\\}$；\n- $\\{2\\},\\{1,3,4\\}$；\n- $\\{3\\},\\{1,2,4\\}$；\n- $\\{4\\},\\{1,2,3\\}$；\n- $\\{1,2\\},\\{3,4\\}$；\n- $\\{1,3\\},\\{2,4\\}$；\n- $\\{1,4\\},\\{2,3\\}$。\n\n$7$ 除以 $3$ 余 $1$。\n\n### 数据范围及约定\n\n- 对于 $20\\%$ 的数据，$n \\le 8$，$k \\le 8$。\n- 对于 $60\\%$ 的数据，$n \\le 100$，$k \\le 100$。\n- 对于 $100\\%$ 的数据，$n \\le 10000$，$k \\le 1000$。\n\n保证所有数据 $n \\ge k$，且答案在 $64$ 位整型范围内。", "locale": "zh-CN"}}}
{"pid": "P2029", "type": "P", "difficulty": 3, "samples": [["6 3\n1 2 3 4 5 6\n1 1 1 20 1 1", "39"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "洛谷原创"], "title": "跳舞", "background": "", "description": "小明今天得到一个跳舞毯游戏程序 Dance。游戏每次连续出 $N$ 个移动的“箭头”，箭头依次标号为 $1$ 到 $N$，并且得到相应的分数 $S _ 1, S _ 2, \\ldots, S _ n$。如果你能“踏中”第 $i$ 号箭头，你将获得相应的分数 $S_i$；否则将被扣除相应的分数。\n\n另外，游戏还有一个累计奖励机制：如果踏准次数累计达到 $T$，并且是在踏中第 $i$ 个箭头达到的，则将得到 $B_i$ 的奖励分数,累计也将清零，重新开始。\n\n例如：$N=6,T=3$，相应的序列 $S$ 和 $B$ 分别为 $\\{1,2,3,4,5,6\\}$、$\\{0,0,4,7,9,10\\}$，如果小明踏中所有箭头，则得分为：$(1+2+3+4)+(4+5+6+10)=35$。\n\n小明是个 Dance 高手，可以踏中他想踏中的任意一个箭头。但他发现，根据给定的 $N,T,S,B$，踏中所有的箭头不一定能得最高分，小明很想知道最高能得多少分，你能帮助小明计算一下最多可得多少分吗？\n", "inputFormat": "第一行两个整数 $N$ 和 $T$。\n\n第二行 $N$ 个整数，为 $S$ 的相应分数。\n\n第三行也有 $N$ 个整数，为 $B$ 的相应分数。", "outputFormat": "一个整数，可得到的最高分数。\n", "hint": "\n【样例解释】\n\n跳过第一个，扣 $1$ 分，连踩 $3$ 个，得 $9$ 分，并获得附加分 $20$ 分，之后再连踩 $2$ 个，共 $39$ 分。\n\n【数据范围】\n\n对于 $20\\%$ 的数据 $0\\le N,T\\le100$；\n\n对于 $100\\%$ 的数据 $0\\le N,T\\le 5000$；\n\n序列 $S$ 和 $B$ 各有 $N$ 个数，所有分数为 $[0,10000]$ 之间的整数。", "locale": "zh-CN", "translations": {"en": {"title": "Dancing", "background": "", "description": "Xiao Ming got a dance pad game program called Dance. In each round, the game outputs $N$ moving \"arrows\", numbered $1$ to $N$, and the corresponding scores are $S_1, S_2, \\ldots, S_N$. If you hit arrow $i$, you gain $S_i$ points; otherwise, you lose $S_i$ points.\n\nAdditionally, the game has an accumulation reward: if the accumulated number of hits reaches $T$ upon hitting arrow $i$, you receive a bonus of $B_i$ points, and the accumulated count is reset to $0$ and restarted.\n\nFor example: $N = 6, T = 3$, and the sequences $S$ and $B$ are {1, 2, 3, 4, 5, 6} and {0, 0, 4, 7, 9, 10}, respectively. If Xiao Ming hits all arrows, the score is: $(1+2+3+4) + (4+5+6+10) = 35$.\n\nXiao Ming is a Dance expert and can hit any arrows he chooses. However, he finds that for given $N, T, S, B$, hitting all arrows does not necessarily yield the highest score. He wants to know the maximum possible score. Can you help him compute the maximum obtainable total score?", "inputFormat": "The first line contains two integers $N$ and $T$.\n\nThe second line contains $N$ integers, the scores of $S$.\n\nThe third line contains $N$ integers, the bonuses of $B$.", "outputFormat": "Output one integer, the maximum obtainable score.", "hint": "Sample explanation:\n\nSkip the first arrow and lose 1 point, then hit 3 arrows to gain 9 points and receive an additional 20 points in bonus, then hit 2 more arrows, for a total of 39 points.\n\nConstraints:\n\n- For 20% of the testdata, $0 \\le N, T \\le 100$.\n- For 100% of the testdata, $0 \\le N, T \\le 5000$.\n- The sequences $S$ and $B$ each contain $N$ numbers, and all scores are integers in $[0, 10000]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "跳舞", "background": "", "description": "小明今天得到一个跳舞毯游戏程序 Dance。游戏每次连续出 $N$ 个移动的“箭头”，箭头依次标号为 $1$ 到 $N$，并且得到相应的分数 $S _ 1, S _ 2, \\ldots, S _ n$。如果你能“踏中”第 $i$ 号箭头，你将获得相应的分数 $S_i$；否则将被扣除相应的分数。\n\n另外，游戏还有一个累计奖励机制：如果踏准次数累计达到 $T$，并且是在踏中第 $i$ 个箭头达到的，则将得到 $B_i$ 的奖励分数,累计也将清零，重新开始。\n\n例如：$N=6,T=3$，相应的序列 $S$ 和 $B$ 分别为 $\\{1,2,3,4,5,6\\}$、$\\{0,0,4,7,9,10\\}$，如果小明踏中所有箭头，则得分为：$(1+2+3+4)+(4+5+6+10)=35$。\n\n小明是个 Dance 高手，可以踏中他想踏中的任意一个箭头。但他发现，根据给定的 $N,T,S,B$，踏中所有的箭头不一定能得最高分，小明很想知道最高能得多少分，你能帮助小明计算一下最多可得多少分吗？\n", "inputFormat": "第一行两个整数 $N$ 和 $T$。\n\n第二行 $N$ 个整数，为 $S$ 的相应分数。\n\n第三行也有 $N$ 个整数，为 $B$ 的相应分数。", "outputFormat": "一个整数，可得到的最高分数。\n", "hint": "\n【样例解释】\n\n跳过第一个，扣 $1$ 分，连踩 $3$ 个，得 $9$ 分，并获得附加分 $20$ 分，之后再连踩 $2$ 个，共 $39$ 分。\n\n【数据范围】\n\n对于 $20\\%$ 的数据 $0\\le N,T\\le100$；\n\n对于 $100\\%$ 的数据 $0\\le N,T\\le 5000$；\n\n序列 $S$ 和 $B$ 各有 $N$ 个数，所有分数为 $[0,10000]$ 之间的整数。", "locale": "zh-CN"}}}
{"pid": "P2030", "type": "P", "difficulty": 3, "samples": [["4 4\nAbcd\nDeF\nAAa\naBccc\nAb\nAA\nAbC\naBcc", "3\n5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "高精度", "递推", "二分"], "title": "遥控车", "background": "", "description": "平平带着韵韵来到了游乐园，看到了 $n$ 辆漂亮的遥控车，每辆车上都有一个唯一的名字 name[i]。韵韵早就迫不及待地想玩名字是 $s$ 的遥控车。可是韵韵毕竟还小，她想象的名字可能是一辆车名字的前缀（也就是说能确定一个 $i$，使 $s$ 是 name[i] 的前缀），这时她就能玩第 $i$ 辆车；或者是一个无中生有的名字，即 $s$ 不是任何一辆车名字的前缀，这时候她什么也不能玩。\n\n你需要完成下面的任务：\n\n1. 韵韵想了 $m$ 个她想要的名字，请告诉她能玩多少次。\n\n2. 由于管理员粗心的操作，导致每辆车的摆放位置都可能出现微小的差错，原来第 $i$ 辆车现在的位置可能是 $i-1$ 、 $i$ 、 $i+1$ 中的任意一个（第 $1$ 辆车的位置不可能是 $0$，第 $n$ 辆车的位置不可能是 $n+1$）。请你计算出共有多少种可能的排列。\n\n注：数据保证当 $s$ 是 name[i] 的前缀时，$i$ 是唯一确定的。一辆车可以玩多次。", "inputFormat": "第一行是 $2$ 个正整数 $n$ 、 $m$。\n\n接下来 $n$ 行，每行 $1$ 个字符串 name[i]，表示第 $i$ 辆车的名字。接下来 $m$ 行，每行 $1$ 个字符串 $s$，表示韵韵想要的名字。", "outputFormat": "第一行输出韵韵能玩的次数。第二行输出共有多少种可能的排列。\n", "hint": "【注意】\n\n对于题目涉及到的字符串严格区分大小写，且长度小于 $255$。\n\n【数据范围】\n\n对于 $20\\%$ 的数据 $n \\le 10,m \\le 10$；\n\n对于 $40\\%$ 的数据 $n \\le 1000$，$m \\le 1000$；\n\n对于 $100\\%$ 的数据 $n \\le 10000$，$m \\le 10000$。", "locale": "zh-CN", "translations": {"en": {"title": "Remote-Controlled Cars", "background": "", "description": "Pingping takes Yunyun to an amusement park and sees $n$ beautiful remote-controlled cars. Each car has a unique name name[i]. Yunyun has long wanted to play the car whose name is $s$. However, since Yunyun is still young, the name she imagines might be a prefix of some car’s name (that is, there exists an $i$ such that $s$ is a prefix of name[i]); in this case, she can play the $i$-th car. Or it might be a completely made-up name that is not a prefix of any car’s name; in that case, she cannot play anything.\n\nYou need to complete the following tasks:\n\n1. Yunyun thinks of $m$ desired names. Tell her how many times she can play.\n\n2. Due to the staff’s careless operation, each car’s placement may have a slight error: the original $i$-th car may now be at any one of the positions $i-1$, $i$, or $i+1$ (the position of the $1$-st car cannot be $0$, and the position of the $n$-th car cannot be $n+1$). Calculate how many possible permutations there are.\n\nNote: The testdata guarantees that when $s$ is a prefix of name[i], the index $i$ is uniquely determined. A car can be played multiple times.", "inputFormat": "The first line contains two positive integers $n$ and $m$.\n\nThe next $n$ lines each contain one string name[i], the name of the $i$-th car. Then the next $m$ lines each contain one string $s$, the name Yunyun wants.", "outputFormat": "Output two lines:\n- The first line contains the number of times Yunyun can play.\n- The second line contains the number of possible permutations.", "hint": "Note:\n- All strings are strictly case-sensitive and have length less than $255$.\n\nConstraints:\n- For $20\\%$ of the testdata, $n \\le 10$, $m \\le 10$.\n- For $40\\%$ of the testdata, $n \\le 1000$, $m \\le 1000$.\n- For $100\\%$ of the testdata, $n \\le 10000$, $m \\le 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "遥控车", "background": "", "description": "平平带着韵韵来到了游乐园，看到了 $n$ 辆漂亮的遥控车，每辆车上都有一个唯一的名字 name[i]。韵韵早就迫不及待地想玩名字是 $s$ 的遥控车。可是韵韵毕竟还小，她想象的名字可能是一辆车名字的前缀（也就是说能确定一个 $i$，使 $s$ 是 name[i] 的前缀），这时她就能玩第 $i$ 辆车；或者是一个无中生有的名字，即 $s$ 不是任何一辆车名字的前缀，这时候她什么也不能玩。\n\n你需要完成下面的任务：\n\n1. 韵韵想了 $m$ 个她想要的名字，请告诉她能玩多少次。\n\n2. 由于管理员粗心的操作，导致每辆车的摆放位置都可能出现微小的差错，原来第 $i$ 辆车现在的位置可能是 $i-1$ 、 $i$ 、 $i+1$ 中的任意一个（第 $1$ 辆车的位置不可能是 $0$，第 $n$ 辆车的位置不可能是 $n+1$）。请你计算出共有多少种可能的排列。\n\n注：数据保证当 $s$ 是 name[i] 的前缀时，$i$ 是唯一确定的。一辆车可以玩多次。", "inputFormat": "第一行是 $2$ 个正整数 $n$ 、 $m$。\n\n接下来 $n$ 行，每行 $1$ 个字符串 name[i]，表示第 $i$ 辆车的名字。接下来 $m$ 行，每行 $1$ 个字符串 $s$，表示韵韵想要的名字。", "outputFormat": "第一行输出韵韵能玩的次数。第二行输出共有多少种可能的排列。\n", "hint": "【注意】\n\n对于题目涉及到的字符串严格区分大小写，且长度小于 $255$。\n\n【数据范围】\n\n对于 $20\\%$ 的数据 $n \\le 10,m \\le 10$；\n\n对于 $40\\%$ 的数据 $n \\le 1000$，$m \\le 1000$；\n\n对于 $100\\%$ 的数据 $n \\le 10000$，$m \\le 10000$。", "locale": "zh-CN"}}}
{"pid": "P2031", "type": "P", "difficulty": 3, "samples": [["asdsd\r\n3\r\nas\r\nsd\r\nds", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "线性数据结构"], "title": "脑力达人之分割字串", "background": "好吧，该来的废话还是要来的。\n\n画外音：\n\n终于，在两轮的重重选拔之后，我们的海选终于结束了。现在进入我们的循环赛环节。循坏赛一共有四场，最后选出得分最高的 $16$ 人进入对决，得分相同则和按用时排名，若仍有不能确定 $16$ 人的情况，则去尾处理。\n\n欢迎您收看有洛谷卫视重磅推出的综合性文艺知识类节目“开心玩游戏，轻松赢比赛”，我是 LUWM。学编程，就选洛谷， 感谢洛谷 Online Judge 对本节目的大力支持。下面，我们有请 $10$ 位选手上台，由大屏幕给出题目。\n", "description": "现在有一个字符串，你可以对这个字符串进行拆分，如 `abcvsdaas` 可以拆分为 `abc|vs|d|aas`，现在再给你一个字典，要求分割成的每一个子串必须要有包含其中的任意一个单词。那么最多可以分为几个子串呢？\n", "inputFormat": "第一行，一行字符串\n\n第二行一个正整数 $N$，表示字典中字符串的数量\n\n接下来 $N$ 行，每行一个字符串 $A_i$，表示字典中的一个字符串。\n", "outputFormat": "一个整数，表示最多的分割数。\n", "hint": "特殊情况：\n\n如果原字符串不能被分割，请输出 $0$。\n\n\n\n数据范围：\n\n对于 $20\\%$ 的数据，$1\\leq |s| \\leq 50,1\\leq n\\leq 50$。\n\n对于 $100\\%$ 的数据，$1\\leq |A_i| \\leq |s|\\leq 300，1\\leq N\\leq 500$。\n\n其中，$|s|,|A_i|$ 表示字符串 $s$ 与 $A_i$ 的长度。", "locale": "zh-CN", "translations": {"en": {"title": "Mind Master: Split the String", "background": "Alright, time for the usual prelude.\n\nVoice-over:\n\nAt last, after two rounds of rigorous selection, our open audition has come to an end. Now we enter the round-robin stage. There are four matches in the round-robin, and the top $16$ scorers advance to the showdown. If scores are tied, rank by time used; if we still cannot determine the top $16$, truncate.\n\nWelcome to the comprehensive arts-and-knowledge show “Play Happily, Win Easily,” proudly presented by Luogu TV. I am LUWM. Learn programming? Choose Luogu. Many thanks to Luogu Online Judge for its strong support. Now, let’s invite $10$ contestants to the stage; the big screen will display the problem.", "description": "You are given a string. You may split this string into segments. For example, `abcvsdaas` can be split as `abc|vs|d|aas`. You are also given a dictionary. Each segment after splitting must contain at least one word from the dictionary as a substring. What is the maximum number of segments you can obtain?", "inputFormat": "- The first line contains a string.\n- The second line contains a positive integer $N$, the number of strings in the dictionary.\n- The next $N$ lines each contain a string $A_i$, representing a dictionary string.", "outputFormat": "Output one integer, the maximum number of segments.", "hint": "Special case:\nIf the original string cannot be split, output $0$.\n\nConstraints:\nFor $20\\%$ of the testdata, $1\\leq |s| \\leq 50, 1\\leq n\\leq 50$.\nFor $100\\%$ of the testdata, $1\\leq |A_i| \\leq |s|\\leq 300, 1\\leq N\\leq 500$.\nHere, $|s|, |A_i|$ denote the lengths of string $s$ and $A_i$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "脑力达人之分割字串", "background": "好吧，该来的废话还是要来的。\n\n画外音：\n\n终于，在两轮的重重选拔之后，我们的海选终于结束了。现在进入我们的循环赛环节。循坏赛一共有四场，最后选出得分最高的 $16$ 人进入对决，得分相同则和按用时排名，若仍有不能确定 $16$ 人的情况，则去尾处理。\n\n欢迎您收看有洛谷卫视重磅推出的综合性文艺知识类节目“开心玩游戏，轻松赢比赛”，我是 LUWM。学编程，就选洛谷， 感谢洛谷 Online Judge 对本节目的大力支持。下面，我们有请 $10$ 位选手上台，由大屏幕给出题目。\n", "description": "现在有一个字符串，你可以对这个字符串进行拆分，如 `abcvsdaas` 可以拆分为 `abc|vs|d|aas`，现在再给你一个字典，要求分割成的每一个子串必须要有包含其中的任意一个单词。那么最多可以分为几个子串呢？\n", "inputFormat": "第一行，一行字符串\n\n第二行一个正整数 $N$，表示字典中字符串的数量\n\n接下来 $N$ 行，每行一个字符串 $A_i$，表示字典中的一个字符串。\n", "outputFormat": "一个整数，表示最多的分割数。\n", "hint": "特殊情况：\n\n如果原字符串不能被分割，请输出 $0$。\n\n\n\n数据范围：\n\n对于 $20\\%$ 的数据，$1\\leq |s| \\leq 50,1\\leq n\\leq 50$。\n\n对于 $100\\%$ 的数据，$1\\leq |A_i| \\leq |s|\\leq 300，1\\leq N\\leq 500$。\n\n其中，$|s|,|A_i|$ 表示字符串 $s$ 与 $A_i$ 的长度。", "locale": "zh-CN"}}}
{"pid": "P2032", "type": "P", "difficulty": 3, "samples": [["5 3\n1 5 3 4 2\n", "5\n5\n4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["单调队列"], "title": "扫描", "background": "", "description": "有一个 $1 \\times n$ 的矩阵，有 $n$ 个整数。\n\n现在给你一个可以盖住连续 $k$ 个数的木板。\n\n一开始木板盖住了矩阵的第 $1 \\sim k$ 个数，每次将木板向右移动一个单位，直到右端与第 $n$ 个数重合。\n\n每次移动前输出被覆盖住的数字中最大的数是多少。", "inputFormat": "第一行两个整数 $n,k$，表示共有 $n$ 个数，木板可以盖住 $k$ 个数。\n\n第二行 $n$ 个整数，表示矩阵中的元素。  ", "outputFormat": "共 $n - k + 1$ 行，每行一个整数。\n\n第 $i$ 行表示第 $i \\sim i + k - 1$ 个数中最大值是多少。  ", "hint": "对于 $20\\%$ 的数据，$1 \\leq k \\leq n \\leq 10^3$。\n\n对于 $50\\%$ 的数据，$1 \\leq k \\leq n \\leq 10^4$。\n\n对于 $100\\%$ 的数据，$1 \\leq k \\leq n \\leq 2 \\times 10^6$，矩阵中的元素大小不超过 $10^4$ 并且均为正整数。 ", "locale": "zh-CN", "translations": {"en": {"title": "Scanning", "background": "", "description": "There is a $1 \\times n$ array containing $n$ integers.\n\nYou are given a plank that can cover $k$ consecutive numbers.\n\nAt the beginning, the plank covers the $1 \\sim k$ numbers of the array. Each time, move the plank one unit to the right until its right end coincides with the $n$-th number.\n\nBefore each move, output the maximum among the numbers currently covered by the plank.", "inputFormat": "The first line contains two integers $n, k$, meaning there are $n$ numbers and the plank can cover $k$ consecutive numbers.\n\nThe second line contains $n$ integers, which are the elements of the array.", "outputFormat": "Output $n - k + 1$ lines, one integer per line.\n\nThe $i$-th line is the maximum value among the $i \\sim i + k - 1$ numbers.", "hint": "- For $20\\%$ of the testdata, $1 \\leq k \\leq n \\leq 10^3$.\n- For $50\\%$ of the testdata, $1 \\leq k \\leq n \\leq 10^4$.\n- For $100\\%$ of the testdata, $1 \\leq k \\leq n \\leq 2 \\times 10^6$, and each element in the array is a positive integer not exceeding $10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "扫描", "background": "", "description": "有一个 $1 \\times n$ 的矩阵，有 $n$ 个整数。\n\n现在给你一个可以盖住连续 $k$ 个数的木板。\n\n一开始木板盖住了矩阵的第 $1 \\sim k$ 个数，每次将木板向右移动一个单位，直到右端与第 $n$ 个数重合。\n\n每次移动前输出被覆盖住的数字中最大的数是多少。", "inputFormat": "第一行两个整数 $n,k$，表示共有 $n$ 个数，木板可以盖住 $k$ 个数。\n\n第二行 $n$ 个整数，表示矩阵中的元素。  ", "outputFormat": "共 $n - k + 1$ 行，每行一个整数。\n\n第 $i$ 行表示第 $i \\sim i + k - 1$ 个数中最大值是多少。  ", "hint": "对于 $20\\%$ 的数据，$1 \\leq k \\leq n \\leq 10^3$。\n\n对于 $50\\%$ 的数据，$1 \\leq k \\leq n \\leq 10^4$。\n\n对于 $100\\%$ 的数据，$1 \\leq k \\leq n \\leq 2 \\times 10^6$，矩阵中的元素大小不超过 $10^4$ 并且均为正整数。 ", "locale": "zh-CN"}}}
{"pid": "P2033", "type": "P", "difficulty": 4, "samples": [["......bA\r\n.....^..\r\n........\r\n........\r\n........\r\n........\r\n........\r\n........\r\nmove 2\r\nturn right\r\nmove 1\r\n#\r\n", "......>b\r\n........\r\n........\r\n........\r\n........\r\n........\r\n........\r\n........\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "洛谷原创"], "title": "Chessboard Dance", "background": null, "description": "在棋盘上跳舞是件有意思的事情。现在给你一张国际象棋棋盘和棋盘上的一些子以及你的初始位置和方向。求按一定操作后，棋盘的状态。\n\n操作有四种，描述如下：\n\n|操作|描述|\n|:-:|:-:|\n|`move n`|        $n$ 是非负整数，表示你按目前所在方向前进 $n$ 步，如果即将走出棋盘，则停止。如果面前有棋子，则将其向前推一步。|\n|`turn left`|    向左转 $90$ 度|\n|`turn right`|    向右转 $90$ 度|\n|`turn back`|    向后转|", "inputFormat": "输入前 $8$ 行，每行 $8$ 个字符，给出棋盘状态。`.` 表示该格为空，字母表示棋子，不同字母表示不同的棋子。你所在位置用 `^`、`<`、`>`、`v` 四个字母中一个表示，分别表示你的方向上、左、右、下。\n\n接下来有若干行，每行一个操作。以 `#` 结束。操作数不超过 $1000$ 个。", "outputFormat": "输出 $8$ 行，每行 $8$ 个字符，表示经过一系列操作后棋盘和你的状态。表示方法同输入。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Chessboard Dance", "background": "", "description": "Dancing on a chessboard is an interesting thing. You are given a chessboard with some pieces on it, along with your initial position and facing direction. After performing a sequence of operations, output the final state of the board.\n\nThere are four operations, described as follows:\n\n| Operation | Description |\n|:-:|:-:|\n| `move n` | $n$ is a non-negative integer, meaning you move forward $n$ steps in your current direction. If you are about to move off the board, stop. If there is a piece in front of you, push it forward by one square. |\n| `turn left` | Turn left by $90$ degrees. |\n| `turn right` | Turn right by $90$ degrees. |\n| `turn back` | Turn around. |", "inputFormat": "The first $8$ lines, each with $8$ characters, give the board state. `.` means the square is empty; letters indicate pieces, and different letters indicate different pieces. Your position is represented by one of `^`, `<`, `>`, `v`, which indicate your facing direction up, left, right, or down, respectively.\n\nThen there are several lines, one per operation, ending with `#`. The number of operations does not exceed $1000$.", "outputFormat": "Output $8$ lines, each with $8$ characters, representing the board and your state after the sequence of operations. The representation is the same as in the input.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Chessboard Dance", "background": null, "description": "在棋盘上跳舞是件有意思的事情。现在给你一张国际象棋棋盘和棋盘上的一些子以及你的初始位置和方向。求按一定操作后，棋盘的状态。\n\n操作有四种，描述如下：\n\n|操作|描述|\n|:-:|:-:|\n|`move n`|        $n$ 是非负整数，表示你按目前所在方向前进 $n$ 步，如果即将走出棋盘，则停止。如果面前有棋子，则将其向前推一步。|\n|`turn left`|    向左转 $90$ 度|\n|`turn right`|    向右转 $90$ 度|\n|`turn back`|    向后转|", "inputFormat": "输入前 $8$ 行，每行 $8$ 个字符，给出棋盘状态。`.` 表示该格为空，字母表示棋子，不同字母表示不同的棋子。你所在位置用 `^`、`<`、`>`、`v` 四个字母中一个表示，分别表示你的方向上、左、右、下。\n\n接下来有若干行，每行一个操作。以 `#` 结束。操作数不超过 $1000$ 个。", "outputFormat": "输出 $8$ 行，每行 $8$ 个字符，表示经过一系列操作后棋盘和你的状态。表示方法同输入。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2034", "type": "P", "difficulty": 4, "samples": [["5 2\n1\n2\n3\n4\n5 \n", "12"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "线段树", "单调队列"], "title": "选择数字", "background": "", "description": "给定一行 $n$ 个非负整数 $a_1 ,\\cdots, a_n$。现在你可以选择其中若干个数，但不能有超过 $k$ 个连续的数字被选择。你的任务是使得选出的数字的和最大。", "inputFormat": "第一行两个整数 $n,k$。\n\n以下 $n$ 行，每行一个整数表示 $a_i$。", "outputFormat": "输出一个值表示答案。", "hint": "对于 $20\\%$ 的数据，$n \\le 10$。\n\n对于另外 $20\\%$ 的数据，$k=1$。\n\n对于 $60\\%$ 的数据，$n \\le 10^3$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^5$，$1 \\le k \\le n$，$0 \\le $ 数字大小 $ \\le 10^9$。\n\n时间限制 $500$ms。", "locale": "zh-CN", "translations": {"en": {"title": "Choosing Numbers", "background": "", "description": "Given a sequence of $n$ non-negative integers $a_1 ,\\cdots, a_n$. You may choose some of them, but no more than $k$ consecutive numbers can be chosen. Your task is to maximize the sum of the chosen numbers.", "inputFormat": "The first line contains two integers $n,k$.\n\nThe following $n$ lines each contain one integer, representing $a_i$.", "outputFormat": "Output a single value representing the answer.", "hint": "For $20\\%$ of the testdata, $n \\le 10$.\n\nFor another $20\\%$ of the testdata, $k=1$.\n\nFor $60\\%$ of the testdata, $n \\le 10^3$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^5$, $1 \\le k \\le n$, $0 \\le a_i \\le 10^9$.\n\nTime limit: 500 ms.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "选择数字", "background": "", "description": "给定一行 $n$ 个非负整数 $a_1 ,\\cdots, a_n$。现在你可以选择其中若干个数，但不能有超过 $k$ 个连续的数字被选择。你的任务是使得选出的数字的和最大。", "inputFormat": "第一行两个整数 $n,k$。\n\n以下 $n$ 行，每行一个整数表示 $a_i$。", "outputFormat": "输出一个值表示答案。", "hint": "对于 $20\\%$ 的数据，$n \\le 10$。\n\n对于另外 $20\\%$ 的数据，$k=1$。\n\n对于 $60\\%$ 的数据，$n \\le 10^3$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^5$，$1 \\le k \\le n$，$0 \\le $ 数字大小 $ \\le 10^9$。\n\n时间限制 $500$ms。", "locale": "zh-CN"}}}
{"pid": "P2035", "type": "P", "difficulty": 2, "samples": [["3 4\n10\n8\n11\n", "3\n1\n2\n3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2008", "USACO"], "title": "[USACO08JAN] iCow B", "background": "", "description": "被无止境的农活压榨得筋疲力尽后，FarmerJohn 打算用他在 MP3 播放器市场新买的 iCow 来听些音乐，放松一下。FJ 的 iCow 里存了 $N(1 \\le N \\le 1{,}000)$ 首曲子，按 $1..N$ 依次编号。至于曲子播放的顺序，则是按一个 FarmerJohn 自己设计的算法来决定：\n\n- 第 $i$ 首曲子有一个初始权值 $R_i\\ (1 \\le R_i \\le 10{,}000)$。\n-  当一首曲子播放完毕，接下来播放的将是所有曲子中权值最大的那首（如果有两首或多首曲子的权值相同，那么这些曲子中编号最小的那首会被选中）。\n- 一首曲子在播放结束后，它的权值会被平均地分给其他 $N-1$ 首曲子，它本身的权值清零。\n- 如果一首曲子的权值无法被平均分配（也就是说，无法被 $N-1$ 整除），那么被 $N-1$ 除的余数部分将会以 $1$ 为单位，顺次分配给排名靠前的曲子（也就是说，顺序为曲目 $1$ 、曲目 $2 \\cdots $ 依次下去。当然，刚播放过的那首曲子需要被跳过），直到多出的部分被分配完。\n\n在选定的下一首曲子播放完毕后，这个算法再次被执行，调整曲子的权值，并选出再接下来播放的曲目。\n\n请你计算一下，按 FJ 的算法，最先播放的 $T\\ (1 \\le T \\le 1000)$ 首曲子分别是哪些。", "inputFormat": "第 $1$ 行有两个用空格隔开的整数：$N$ 和 $T$。\n\n第 $2$ 至第 $N+1$ 行，第 $i+1$ 行为 $1$ 个整数 $R_i$。", "outputFormat": "输出共 $T$ 行，第 $i$ 行输出一个整数，表示 iCow 播放的第 $i$ 首曲子。", "hint": "每一首曲子播放前，三首曲子的权值分别为：\n\n- $[10,8,11]$。播放 $\\#3$，$11/2 = 5$，权值余量为 $1$。\n- $[16,13,0]$。播放 $\\#1$，$16/2 = 8$。\n- $[0,21,8]$。播放 $\\#2$，$21/2 = 10$，权值余量为 $1$。\n- $[11,0,18]$。播放 $\\#3$，……\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08JAN] iCow B", "background": "", "description": "Exhausted by endless farm work, Farmer John plans to relax by listening to music on his newly purchased iCow in the MP3 player market. FJ’s iCow stores $N(1 \\le N \\le 1{,}000)$ songs, numbered $1..N$ in order. The playback order of the songs is determined by an algorithm designed by Farmer John:\n\n- The $i$-th song has an initial weight $R_i\\ (1 \\le R_i \\le 10{,}000)$.\n- When a song finishes playing, the next song to play is the one with the maximum weight among all songs (if two or more songs have the same weight, the one with the smallest index among them is chosen).\n- After a song finishes playing, its weight is evenly distributed to the other $N-1$ songs, and its own weight becomes zero.\n- If a song’s weight cannot be evenly distributed (i.e., it is not divisible by $N-1$), then the remainder after division by $N-1$ will be distributed in units of $1$ to the songs earlier in index order (that is, song $1$, song $2$, and so on; of course, skip the song that just played), until the extra part is fully distributed.\n\nAfter the selected next song finishes playing, this algorithm is executed again to adjust the weights and select the following song.\n\nPlease compute which songs are played first for the initial $T\\ (1 \\le T \\le 1000)$ plays according to FJ’s algorithm.", "inputFormat": "The first line contains two integers separated by a space: $N$ and $T$.\n\nThe second to the $(N+1)$-th lines: line $i+1$ contains one integer $R_i$.", "outputFormat": "Output $T$ lines. On the $i$-th line, output one integer, the index of the $i$-th song played by iCow.", "hint": "Before each play, the weights of the three songs are:\n\n- $[10,8,11]$. Play $\\#3$, $11/2 = 5$, remainder $1$.\n- $[16,13,0]$. Play $\\#1$, $16/2 = 8$.\n- $[0,21,8]$. Play $\\#2$, $21/2 = 10$, remainder $1$.\n- $[11,0,18]$. Play $\\#3$...\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO08JAN] iCow B", "background": "", "description": "被无止境的农活压榨得筋疲力尽后，FarmerJohn 打算用他在 MP3 播放器市场新买的 iCow 来听些音乐，放松一下。FJ 的 iCow 里存了 $N(1 \\le N \\le 1{,}000)$ 首曲子，按 $1..N$ 依次编号。至于曲子播放的顺序，则是按一个 FarmerJohn 自己设计的算法来决定：\n\n- 第 $i$ 首曲子有一个初始权值 $R_i\\ (1 \\le R_i \\le 10{,}000)$。\n-  当一首曲子播放完毕，接下来播放的将是所有曲子中权值最大的那首（如果有两首或多首曲子的权值相同，那么这些曲子中编号最小的那首会被选中）。\n- 一首曲子在播放结束后，它的权值会被平均地分给其他 $N-1$ 首曲子，它本身的权值清零。\n- 如果一首曲子的权值无法被平均分配（也就是说，无法被 $N-1$ 整除），那么被 $N-1$ 除的余数部分将会以 $1$ 为单位，顺次分配给排名靠前的曲子（也就是说，顺序为曲目 $1$ 、曲目 $2 \\cdots $ 依次下去。当然，刚播放过的那首曲子需要被跳过），直到多出的部分被分配完。\n\n在选定的下一首曲子播放完毕后，这个算法再次被执行，调整曲子的权值，并选出再接下来播放的曲目。\n\n请你计算一下，按 FJ 的算法，最先播放的 $T\\ (1 \\le T \\le 1000)$ 首曲子分别是哪些。", "inputFormat": "第 $1$ 行有两个用空格隔开的整数：$N$ 和 $T$。\n\n第 $2$ 至第 $N+1$ 行，第 $i+1$ 行为 $1$ 个整数 $R_i$。", "outputFormat": "输出共 $T$ 行，第 $i$ 行输出一个整数，表示 iCow 播放的第 $i$ 首曲子。", "hint": "每一首曲子播放前，三首曲子的权值分别为：\n\n- $[10,8,11]$。播放 $\\#3$，$11/2 = 5$，权值余量为 $1$。\n- $[16,13,0]$。播放 $\\#1$，$16/2 = 8$。\n- $[0,21,8]$。播放 $\\#2$，$21/2 = 10$，权值余量为 $1$。\n- $[11,0,18]$。播放 $\\#3$，……\n", "locale": "zh-CN"}}}
{"pid": "P2036", "type": "P", "difficulty": 2, "samples": [["1\n3 10", "7"], ["2\n3 8\n5 8", "1"], ["4\n1 7\n2 6\n3 8\n4 9", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["模拟", "搜索", "2008", "COCI（克罗地亚）"], "title": "[COCI 2008/2009 #2] PERKET", "background": null, "description": "Perket 是一种流行的美食。为了做好 Perket，厨师必须谨慎选择食材，以在保持传统风味的同时尽可能获得最全面的味道。你有 $n$ 种可支配的配料。对于每一种配料，我们知道它们各自的酸度 $s$ 和苦度 $b$。当我们添加配料时，总的酸度为每一种配料的酸度总乘积；总的苦度为每一种配料的苦度的总和。\n\n众所周知，美食应该做到口感适中，所以我们希望选取配料，以使得酸度和苦度的绝对差最小。\n\n另外，我们必须添加至少一种配料，因为没有任何食物是只以水为配料的。", "inputFormat": "第一行一个整数 $n$，表示可供选用的食材种类数。\n\n接下来 $n$ 行，每行 $2$ 个整数 $s_i$ 和 $b_i$，表示第 $i$ 种食材的酸度和苦度。", "outputFormat": "一行一个整数，表示可能的总酸度和总苦度的最小绝对差。", "hint": "对于第三组样例，选择最后三种食材，此时的总酸度为 $2 \\times 3 \\times 4 = 24$，总苦度为 $6+8+9=23$，差值为 $1$。\n\n#### 数据规模与约定\n对于 $100\\%$ 的数据，有 $1 \\leq n \\leq 10$，且将所有可用食材全部使用产生的总酸度和总苦度小于 $1 \\times 10^9$。\n#### 说明\n- 本题满分 $70$ 分。\n- 题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #2](https://hsin.hr/coci/archive/2008_2009/contest2_tasks.pdf) PERKET，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2008/2009 #2] PERKET", "background": "# Description\n\nPerket is a popular dish. To make a good Perket, the chef must choose the ingredients carefully to achieve the most balanced flavor while keeping the traditional taste. You have $n$ available ingredients. For each ingredient, we know its sourness $s$ and bitterness $b$. When we add ingredients, the total sourness is the product of the sourness values of the chosen ingredients; the total bitterness is the sum of the bitterness values of the chosen ingredients.\n\nIt is well known that a good dish should be well balanced, so we want to choose a subset of ingredients that minimizes the absolute difference between the total sourness and the total bitterness.\n\nAlso, we must add at least one ingredient, because no dish is made with only water.", "description": "Perket is a popular dish. To make a good Perket, the chef must choose the ingredients carefully to achieve the most balanced flavor while keeping the traditional taste. You have $n$ available ingredients. For each ingredient, we know its sourness $s$ and bitterness $b$. When we add ingredients, the total sourness is the product of the sourness values of the chosen ingredients; the total bitterness is the sum of the bitterness values of the chosen ingredients.\n\nIt is well known that a good dish should be well balanced, so we want to choose a subset of ingredients that minimizes the absolute difference between the total sourness and the total bitterness.\n\nAlso, we must add at least one ingredient, because no dish is made with only water.\n\n# Description", "inputFormat": "The first line contains an integer $n$, the number of available ingredient types.\nThe next $n$ lines each contain $2$ integers $s_i$ and $b_i$, the sourness and bitterness of the $i$-th ingredient.", "outputFormat": "Output a single integer: the minimum possible absolute difference between the total sourness and the total bitterness.", "hint": "For the third sample, choose the last three ingredients. Then the total sourness is $2 \\times 3 \\times 4 = 24$, the total bitterness is $6+8+9=23$, and the difference is $1$.\n\nConstraints\n- For $100\\%$ of the testdata, $1 \\leq n \\leq 10$, and the total sourness and the total bitterness obtained by using all available ingredients are less than $1 \\times 10^9$.\n\nNotes\n- This problem is worth $70$ points.\n- Translated from [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #2](https://hsin.hr/coci/archive/2008_2009/contest2_tasks.pdf) PERKET, translator @[mnesia](https://www.luogu.com.cn/user/115711).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COCI 2008/2009 #2] PERKET", "background": null, "description": "Perket 是一种流行的美食。为了做好 Perket，厨师必须谨慎选择食材，以在保持传统风味的同时尽可能获得最全面的味道。你有 $n$ 种可支配的配料。对于每一种配料，我们知道它们各自的酸度 $s$ 和苦度 $b$。当我们添加配料时，总的酸度为每一种配料的酸度总乘积；总的苦度为每一种配料的苦度的总和。\n\n众所周知，美食应该做到口感适中，所以我们希望选取配料，以使得酸度和苦度的绝对差最小。\n\n另外，我们必须添加至少一种配料，因为没有任何食物是只以水为配料的。", "inputFormat": "第一行一个整数 $n$，表示可供选用的食材种类数。\n\n接下来 $n$ 行，每行 $2$ 个整数 $s_i$ 和 $b_i$，表示第 $i$ 种食材的酸度和苦度。", "outputFormat": "一行一个整数，表示可能的总酸度和总苦度的最小绝对差。", "hint": "对于第三组样例，选择最后三种食材，此时的总酸度为 $2 \\times 3 \\times 4 = 24$，总苦度为 $6+8+9=23$，差值为 $1$。\n\n#### 数据规模与约定\n对于 $100\\%$ 的数据，有 $1 \\leq n \\leq 10$，且将所有可用食材全部使用产生的总酸度和总苦度小于 $1 \\times 10^9$。\n#### 说明\n- 本题满分 $70$ 分。\n- 题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #2](https://hsin.hr/coci/archive/2008_2009/contest2_tasks.pdf) PERKET，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。", "locale": "zh-CN"}}}
{"pid": "P2037", "type": "P", "difficulty": 3, "samples": [["3\r\nTUT-GLOP\r\n3-10-10-10\r\n310-1010\r\n", "310-1010 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "搜索"], "title": "电话号码", "background": "", "description": "一串由长长的数字组成的电话号码通常很难记忆。为了方便记忆，有种方法是用单词来方便记忆。例如用 `Three Tens` 来记忆电话 `3-10-10-10`。\n\n电话号码的标准形式是七位数字，中间用连字号分成前三个和后四个数字（例如：`888-1200`）。电话号码可以用字母来表示。以下是字母与数字的对应：\n\n - `A`，`B` 和 `C` 对应 `2`；\n - `D`，`E` 和 `F` 对应 `3`；\n - `G`，`H` 和 `I` 对应 `4`；\n - `J`，`K` 和 `L` 对应 `5`；\n - `M`，`N` 和 `O` 对应 `6`；\n - `P`，`R` 和 `S` 对应 `7`；\n - `T`，`U` 和 `V` 对应 `8`；\n - `W`，`X` 和 `Y` 对应 `9`。\n\n你会发现其中没有字母 `Q` 和 `Z`。电话中的连字号是可以忽略。例如 `TUT-GLOP` 的标准形式是 `888-4567`，`310-GINO` 的标准形式是 `310-4466`，`3-10-10-10` 的标准形式是 `310-1010`。\n\n如果两个电话号码的标准形式是一样的，那么这两个电话号码就是一样的。\n\n现在有一本电话簿，请从中找出哪些电话号码是重复的。\n", "inputFormat": "第一行一个正整数 $N$，表示有多少个电话号码。\n\n以下 $N$ 行，每行一个电话号码，电话号码由数字、大写字母（除 `Q`、`Z`）和连字符组成。电话号码长度不会超过 $1000$。所有电话号码都合法。\n", "outputFormat": "将所有重复的电话号码按字典序以标准形式输出，并且在每个电话号码后跟一个整数，表示该电话号码共出现了多少次，电话号码和整数间用一个空格隔开。不要输出多余空行。\n\n如果没有重复的电话号码，则输出：`No duplicates.`（注意最后一个字母 `s` 有一个点。）\n", "hint": "【数据范围】\n\n对于 $30\\%$ 的数据，$N\\le20$。\n\n对于 $50\\%$ 的数据，$N\\le10000$。\n\n对于 $100\\%$ 的数据，$N\\le10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Telephone Numbers", "background": "", "description": "A telephone number consisting of a long string of digits is usually hard to remember. To make it easier, one approach is to use words to aid memorization. For example, use `Three Tens` to remember `3-10-10-10`.\n\nThe standard form of a telephone number is seven digits, split into the first three and the last four digits with a hyphen (for example: `888-1200`). Telephone numbers can be written with letters. The correspondence between letters and digits is as follows:\n- `A`, `B`, and `C` correspond to `2`;\n- `D`, `E`, and `F` correspond to `3`;\n- `G`, `H`, and `I` correspond to `4`;\n- `J`, `K`, and `L` correspond to `5`;\n- `M`, `N`, and `O` correspond to `6`;\n- `P`, `R`, and `S` correspond to `7`;\n- `T`, `U`, and `V` correspond to `8`;\n- `W`, `X`, and `Y` correspond to `9`.\n\nYou will notice that the letters `Q` and `Z` are not present. Hyphens in telephone numbers can be ignored. For example, the standard form of `TUT-GLOP` is `888-4567`, the standard form of `310-GINO` is `310-4466`, and the standard form of `3-10-10-10` is `310-1010`.\n\nIf two telephone numbers have the same standard form, then they are considered identical.\n\nGiven a phone book, find which telephone numbers are duplicates.", "inputFormat": "The first line contains a positive integer $N$, the number of telephone numbers.\n\nThe following $N$ lines each contain one telephone number. Each number consists of digits, uppercase letters (excluding `Q` and `Z`), and hyphens. The length of each telephone number does not exceed $1000$. All telephone numbers are valid.", "outputFormat": "Output all duplicate telephone numbers in lexicographic order, in standard form. After each telephone number, output an integer indicating how many times it appears, separated by a single space. Do not output extra blank lines.\n\nIf there are no duplicate telephone numbers, output: `No duplicates.`", "hint": "Constraints\n\nFor $30\\%$ of the testdata, $N \\le 20$.\n\nFor $50\\%$ of the testdata, $N \\le 10000$.\n\nFor $100\\%$ of the testdata, $N \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "电话号码", "background": "", "description": "一串由长长的数字组成的电话号码通常很难记忆。为了方便记忆，有种方法是用单词来方便记忆。例如用 `Three Tens` 来记忆电话 `3-10-10-10`。\n\n电话号码的标准形式是七位数字，中间用连字号分成前三个和后四个数字（例如：`888-1200`）。电话号码可以用字母来表示。以下是字母与数字的对应：\n\n - `A`，`B` 和 `C` 对应 `2`；\n - `D`，`E` 和 `F` 对应 `3`；\n - `G`，`H` 和 `I` 对应 `4`；\n - `J`，`K` 和 `L` 对应 `5`；\n - `M`，`N` 和 `O` 对应 `6`；\n - `P`，`R` 和 `S` 对应 `7`；\n - `T`，`U` 和 `V` 对应 `8`；\n - `W`，`X` 和 `Y` 对应 `9`。\n\n你会发现其中没有字母 `Q` 和 `Z`。电话中的连字号是可以忽略。例如 `TUT-GLOP` 的标准形式是 `888-4567`，`310-GINO` 的标准形式是 `310-4466`，`3-10-10-10` 的标准形式是 `310-1010`。\n\n如果两个电话号码的标准形式是一样的，那么这两个电话号码就是一样的。\n\n现在有一本电话簿，请从中找出哪些电话号码是重复的。\n", "inputFormat": "第一行一个正整数 $N$，表示有多少个电话号码。\n\n以下 $N$ 行，每行一个电话号码，电话号码由数字、大写字母（除 `Q`、`Z`）和连字符组成。电话号码长度不会超过 $1000$。所有电话号码都合法。\n", "outputFormat": "将所有重复的电话号码按字典序以标准形式输出，并且在每个电话号码后跟一个整数，表示该电话号码共出现了多少次，电话号码和整数间用一个空格隔开。不要输出多余空行。\n\n如果没有重复的电话号码，则输出：`No duplicates.`（注意最后一个字母 `s` 有一个点。）\n", "hint": "【数据范围】\n\n对于 $30\\%$ 的数据，$N\\le20$。\n\n对于 $50\\%$ 的数据，$N\\le10000$。\n\n对于 $100\\%$ 的数据，$N\\le10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P2038", "type": "P", "difficulty": 2, "samples": [["1\n2\n4 4 10\n6 6 20", "1 30"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2014", "NOIP 提高组", "枚举"], "title": "[NOIP 2014 提高组] 无线网络发射器选址", "background": "NOIP2014 提高组 D2T1", "description": "随着智能手机的日益普及，人们对无线网的需求日益增大。某城市决定对城市内的公共场所覆盖无线网。\n\n假设该城市的布局为由严格平行的 $129$ 条东西向街道和 $129$ 条南北向街道所形成的网格状，并且相邻的平行街道之间的距离都是恒定值 $1$。东西向街道从北到南依次编号为 $0,1,2 \\dots 128$，南北向街道从西到东依次编号为 $0,1,2 \\dots 128$。\n\n东西向街道和南北向街道相交形成路口，规定编号为 $x$ 的南北向街道和编号为 $y$ 的东西向街道形成的路口的坐标是 $(x, y)$。在某些路口存在一定数量的公共场所。\n\n由于政府财政问题，只能安装一个大型无线网络发射器。该无线网络发射器的传播范围是一个以该点为中心，边长为 $2d$ 的正方形。传播范围包括正方形边界。\n\n现在政府有关部门准备安装一个传播参数为 $d$ 的无线网络发射器，希望你帮助他们在城市内找出合适的路口作为安装地点，使得覆盖的公共场所最多。", "inputFormat": "第一行包含一个整数 $d$，表示无线网络发射器的传播距离。\n\n第二行包含一个整数 $n$，表示有公共场所的路口数目。\n\n接下来 $n$ 行，每行给出三个整数 $x, y, k$，中间用一个空格隔开，分别代表路口的坐标 $(x, y)$ 以及该路口公共场所的数量。同一坐标只会给出一次。", "outputFormat": "输出一行，包含两个整数，用一个空格隔开，分别表示能覆盖最多公共场所的安装地点方案数，以及能覆盖的最多公共场所的数量。", "hint": "对于 $100\\%$ 的数据，$1 \\leq d \\leq 20, 1 \\leq n \\leq 20, 0 \\leq x \\leq 128, 0 \\leq y \\leq 128, 0 < k \\leq 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2014 Senior] Wireless Network Transmitter Placement", "background": "NOIP 2014 Senior D2T1.", "description": "With the increasing popularity of smartphones, the demand for wireless networks is growing. A certain city decides to cover public places with a wireless network.\n\nAssume the city layout is a grid formed by $129$ east-west streets and $129$ north-south streets, and the distance between any two adjacent parallel streets is a constant $1$. The east-west streets are numbered $0,1,2 \\dots 128$ from north to south, and the north-south streets are numbered $0,1,2 \\dots 128$ from west to east.\n\nIntersections are formed where an east-west street meets a north-south street. The intersection of the north-south street numbered $x$ and the east-west street numbered $y$ has coordinates $(x, y)$. Some intersections have a certain number of public places.\n\nDue to budget constraints, only one large wireless network transmitter can be installed. Its coverage area is a square centered at the installation point with side length $2d$. The coverage includes the square’s boundary.\n\nNow the authorities plan to install a transmitter with parameter $d$. Please help them find a suitable intersection in the city as the installation location to maximize the number of public places covered.", "inputFormat": "The first line contains an integer $d$, the coverage parameter of the wireless network transmitter.\n\nThe second line contains an integer $n$, the number of intersections that have public places.\n\nThe next $n$ lines each contain three integers $x, y, k$ separated by a space, representing the intersection coordinates $(x, y)$ and the number of public places at that intersection. Each coordinate appears at most once.", "outputFormat": "Output one line containing two integers separated by a space: the number of installation locations that achieve the maximum coverage of public places, and the maximum number of public places covered.", "hint": "For $100\\%$ of the testdata, $1 \\leq d \\leq 20, 1 \\leq n \\leq 20, 0 \\leq x \\leq 128, 0 \\leq y \\leq 128, 0 < k \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2014 提高组] 无线网络发射器选址", "background": "NOIP2014 提高组 D2T1", "description": "随着智能手机的日益普及，人们对无线网的需求日益增大。某城市决定对城市内的公共场所覆盖无线网。\n\n假设该城市的布局为由严格平行的 $129$ 条东西向街道和 $129$ 条南北向街道所形成的网格状，并且相邻的平行街道之间的距离都是恒定值 $1$。东西向街道从北到南依次编号为 $0,1,2 \\dots 128$，南北向街道从西到东依次编号为 $0,1,2 \\dots 128$。\n\n东西向街道和南北向街道相交形成路口，规定编号为 $x$ 的南北向街道和编号为 $y$ 的东西向街道形成的路口的坐标是 $(x, y)$。在某些路口存在一定数量的公共场所。\n\n由于政府财政问题，只能安装一个大型无线网络发射器。该无线网络发射器的传播范围是一个以该点为中心，边长为 $2d$ 的正方形。传播范围包括正方形边界。\n\n现在政府有关部门准备安装一个传播参数为 $d$ 的无线网络发射器，希望你帮助他们在城市内找出合适的路口作为安装地点，使得覆盖的公共场所最多。", "inputFormat": "第一行包含一个整数 $d$，表示无线网络发射器的传播距离。\n\n第二行包含一个整数 $n$，表示有公共场所的路口数目。\n\n接下来 $n$ 行，每行给出三个整数 $x, y, k$，中间用一个空格隔开，分别代表路口的坐标 $(x, y)$ 以及该路口公共场所的数量。同一坐标只会给出一次。", "outputFormat": "输出一行，包含两个整数，用一个空格隔开，分别表示能覆盖最多公共场所的安装地点方案数，以及能覆盖的最多公共场所的数量。", "hint": "对于 $100\\%$ 的数据，$1 \\leq d \\leq 20, 1 \\leq n \\leq 20, 0 \\leq x \\leq 128, 0 \\leq y \\leq 128, 0 < k \\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P2039", "type": "P", "difficulty": 4, "samples": [["5\n0 0 0 1 0\n\n", "1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "安徽"], "title": "[AHOI2009] 跳棋", "background": null, "description": "在一个 $1$ 行 $N$ 列（$N$ 是奇数）的棋盘上，有 $K$ 个格子是红色的。这种情况下，你有一个跳棋在最左端的格子上。你的目标是将它移动到最右边的格子，在开始移动之间，你可以在棋盘的任意空位上放棋子。在游戏开始后 你只可以随时在一个红色格子上放棋子。棋子的移动规则是：每次只可以选择一个棋子，跳过与之相邻的棋子走到后面的空格上，被它跳过的棋子被吃掉，即从棋盘上移走，如相邻棋子的另一侧有棋子，则不能跳。\n\n\n请回答以下两个问题：\n\n1. 移动开始前至少要放多少棋子才能完成任务。\n2. 如果要使开始前放的棋子数要求尽量少，那么在移动过程中最少需要放多少个棋子才能完成任务。\n\n\n关于规则的补充说明：\n\n1. 只能往空位上放棋子，不管是移动开始前还是移动过程中。\n2. 移动前棋盘最左端的那个原始棋子绝对不能被吃掉。", "inputFormat": "第一行一个正奇数 $N$。\n\n第二行有 $N$ 个整数，如果第 $i$ 个整数是 $1$，说明第 $i$ 个格子是红色格子，否则为白色格子。\n\n数字间用空格分开。", "outputFormat": "两行，每行一个整数分别代表第一问和第二问的结果。", "hint": "在游戏开始前，可以在第二个格子上放上一个棋子，游戏开始后可用最左边的棋子吃掉它，从而移动到第三格。然后由于第四格是个红色的格子，在游戏中可以在那放一个棋子，然后用已经移动第三格的棋子把它吃掉，从而达到终点。\n\n$100\\%$ 的数据中，$1\\le N\\le  1000$，输出中的数字不超过 $10^ {15}$。\n\n$30\\%$ 的数据中，$N\\le 20$。\n\n\nSource: [Ahoi2009] checker", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2009] Checkers", "background": "", "description": "On a board with 1 row and $N$ columns (where $N$ is odd), there are $K$ red squares. In this situation, you have a checker on the leftmost square. Your goal is to move it to the rightmost square. Before the movement begins, you may place pieces on any empty squares on the board. After the game starts, you may place pieces only on red squares at any time. The movement rule is: each move you may choose exactly one piece and jump over an adjacent piece to the empty square immediately beyond; the jumped-over piece is captured and removed from the board. If the square immediately beyond the adjacent piece is occupied, the jump is not allowed.\n\nAnswer the following two questions:\n\n1. Before the movement starts, what is the minimum number of pieces you must place to complete the task?\n2. If the number of pieces placed before the start is minimized, what is the minimum number of pieces you must place during the movement?\n\nAdditional clarifications on the rules:\n\n1. Pieces can only be placed on empty squares, whether before the movement starts or during the game.\n2. The original piece on the leftmost square before the movement starts must never be captured.", "inputFormat": "The first line contains a positive odd integer $N$.\n\nThe second line contains $N$ integers. If the $i$-th integer is $1$, then the $i$-th square is red; otherwise, it is white.\n\nThe numbers are separated by spaces.", "outputFormat": "Output two lines. Each line contains one integer, representing the answers to the first and second questions, respectively.", "hint": "Before the game starts, you can place a piece on the second square. After the game starts, use the leftmost piece to capture it and thus move to the third square. Then, since the fourth square is red, you can place a piece there during the game, and use the piece that has moved to the third square to capture it, thereby reaching the end.\n\nConstraints:\n- For $100\\%$ of the testdata, $1 \\le N \\le 1000$, and the numbers in the output do not exceed $10^{15}$.\n- For $30\\%$ of the testdata, $N \\le 20$.\n\nSource: [Ahoi2009] checker.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2009] 跳棋", "background": null, "description": "在一个 $1$ 行 $N$ 列（$N$ 是奇数）的棋盘上，有 $K$ 个格子是红色的。这种情况下，你有一个跳棋在最左端的格子上。你的目标是将它移动到最右边的格子，在开始移动之间，你可以在棋盘的任意空位上放棋子。在游戏开始后 你只可以随时在一个红色格子上放棋子。棋子的移动规则是：每次只可以选择一个棋子，跳过与之相邻的棋子走到后面的空格上，被它跳过的棋子被吃掉，即从棋盘上移走，如相邻棋子的另一侧有棋子，则不能跳。\n\n\n请回答以下两个问题：\n\n1. 移动开始前至少要放多少棋子才能完成任务。\n2. 如果要使开始前放的棋子数要求尽量少，那么在移动过程中最少需要放多少个棋子才能完成任务。\n\n\n关于规则的补充说明：\n\n1. 只能往空位上放棋子，不管是移动开始前还是移动过程中。\n2. 移动前棋盘最左端的那个原始棋子绝对不能被吃掉。", "inputFormat": "第一行一个正奇数 $N$。\n\n第二行有 $N$ 个整数，如果第 $i$ 个整数是 $1$，说明第 $i$ 个格子是红色格子，否则为白色格子。\n\n数字间用空格分开。", "outputFormat": "两行，每行一个整数分别代表第一问和第二问的结果。", "hint": "在游戏开始前，可以在第二个格子上放上一个棋子，游戏开始后可用最左边的棋子吃掉它，从而移动到第三格。然后由于第四格是个红色的格子，在游戏中可以在那放一个棋子，然后用已经移动第三格的棋子把它吃掉，从而达到终点。\n\n$100\\%$ 的数据中，$1\\le N\\le  1000$，输出中的数字不超过 $10^ {15}$。\n\n$30\\%$ 的数据中，$N\\le 20$。\n\n\nSource: [Ahoi2009] checker", "locale": "zh-CN"}}}
{"pid": "P2040", "type": "P", "difficulty": 3, "samples": [["0 1 1\n1 0 0\n1 0 1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "递归", "枚举", "剪枝"], "title": "打开所有的灯", "background": "pmshz 在玩一个益 (ruo) 智 (zhi) 的小游戏，目的是打开九盏灯所有的灯，这样的游戏难倒了 pmshz……", "description": "这个灯很奇 (fan) 怪 (ren)，点一下就会将这个灯和其周围四盏灯的开关状态全部改变。现在你的任务就是就是告诉 pmshz 要全部打开这些灯。\n\n例如\n```plain\n0  1  1\n1  0  0\n1  0  1\n```\n点一下最中间的灯 $(2,2)$ 就变成了\n\n```plain\n0  0  1\n0  1  1\n1  1  1\n```\n\n再点一下左上角的灯 $(1,1)$ 就变成了\n\n```plain\n1  1  1\n1  1  1\n1  1  1\n```\n\n达成目标。\n\n最少需要 $2$ 步。", "inputFormat": "$9$ 个数字，以 $3\\times3$ 的格式输入，每两个数字中间只有一个空格，表示灯初始的开关状态。（$0$ 表示关，$1$ 表示开）", "outputFormat": "一个整数，表示最少打开所有灯所需要的步数。", "hint": "这个题水不水，就看你怎么考虑了……", "locale": "zh-CN", "translations": {"en": {"title": "Turn On All the Lights", "background": "pmshz is playing a small puzzle game (yì zhì; jokingly \"ruò zhì\"). The goal is to turn on all nine lights. This game has stumped pmshz.", "description": "These lights behave in a peculiar (annoying) way: pressing a light will flip the on/off state of that light and its four neighboring lights. Your task is to tell pmshz how to turn all the lights on.\n\nFor example\n```plain\n0  1  1\n1  0  0\n1  0  1\n```\nPressing the center light $(2,2)$ becomes\n\n```plain\n0  0  1\n0  1  1\n1  1  1\n```\n\nPressing the top-left light $(1,1)$ becomes\n\n```plain\n1  1  1\n1  1  1\n1  1  1\n```\n\nGoal achieved.\n\nThe minimum number of steps is $2$.", "inputFormat": "$9$ numbers given in a $3\\times3$ layout, with exactly one space between adjacent numbers, representing the initial on/off state of the lights ($0$ means off, $1$ means on).", "outputFormat": "A single integer, the minimum number of presses required to turn on all the lights.", "hint": "How easy this problem is depends on how you think about it.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "打开所有的灯", "background": "pmshz 在玩一个益 (ruo) 智 (zhi) 的小游戏，目的是打开九盏灯所有的灯，这样的游戏难倒了 pmshz……", "description": "这个灯很奇 (fan) 怪 (ren)，点一下就会将这个灯和其周围四盏灯的开关状态全部改变。现在你的任务就是就是告诉 pmshz 要全部打开这些灯。\n\n例如\n```plain\n0  1  1\n1  0  0\n1  0  1\n```\n点一下最中间的灯 $(2,2)$ 就变成了\n\n```plain\n0  0  1\n0  1  1\n1  1  1\n```\n\n再点一下左上角的灯 $(1,1)$ 就变成了\n\n```plain\n1  1  1\n1  1  1\n1  1  1\n```\n\n达成目标。\n\n最少需要 $2$ 步。", "inputFormat": "$9$ 个数字，以 $3\\times3$ 的格式输入，每两个数字中间只有一个空格，表示灯初始的开关状态。（$0$ 表示关，$1$ 表示开）", "outputFormat": "一个整数，表示最少打开所有灯所需要的步数。", "hint": "这个题水不水，就看你怎么考虑了……", "locale": "zh-CN"}}}
{"pid": "P2041", "type": "P", "difficulty": 4, "samples": [["1", "1\n1 1"], ["2", "4\n1 1\n2 1\n2 2\n1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["数学"], "title": "分裂游戏", "background": "", "description": "有一个无限大的棋盘，棋盘左下角有一个大小为 $n$ 的阶梯形区域，其中最左下角的那个格子里有一枚棋子。你每次可以把一枚棋子“分裂”成两枚棋子，分别放在原位置的上边一格和右边一格。（但如果目标位置已有棋子，则不能这样做）你的目的是通过有限次的操作，让整个阶梯里不再有任何棋子。下图所示的是 $n = 2$ 时的一种解法。\n\n![](https://cdn.luogu.com.cn/upload/pic/1116.png) \n\n我们用从下往上数的方式标记行，从左往右数的方式标记列，以 (行,列) 来标记棋子，并且都从 $1$ 开始。\n\n例如，第三步中的三个棋子坐标分别为 $(3,1),(2,2),(1,2)$。\n\n现在已知 $n$，你需要做的是给出合适的操作序列。\n", "inputFormat": "输入一个正整数 $n$。\n", "outputFormat": "如果有解，第一行应包含一个正整数 $m$，表示总共需要的操作步数。\n\n以下 $m$ 行，每行包括两个正整数 $x_i,y_i$，表示第 $i$ 步操作分裂的是处于第 $x_i$ 行第 $y_i$ 列的棋子。\n\n如果无解，只需在第一行输出 $-1$。", "hint": "- 对于 $40\\%$ 的数据：$n \\leq 8$；\n- 对于 $100\\%$ 的数据：$n \\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Splitting Game", "background": "", "description": "There is an infinite board. In the lower-left corner, there is a staircase-shaped region of size $n$, and there is a single piece in the very bottom-left cell of this staircase. Each time, you may “split” one piece into two pieces, placing them in the cell one square above and the cell one square to the right of the original position, respectively. (However, if a target cell already contains a piece, you cannot perform this operation.) Your goal is to, after finitely many operations, make the entire staircase contain no pieces. The figure below shows one solution when $n = 2$.\n\n![](https://cdn.luogu.com.cn/upload/pic/1116.png) \n\nWe number rows from bottom to top and columns from left to right, and denote a piece by (row, column), both starting from $1$.\n\nFor example, in the third step, the three pieces are at coordinates $(3, 1)$, $(2, 2)$, $(1, 2)$.\n\nGiven $n$, you need to output a suitable sequence of operations.", "inputFormat": "Input a single positive integer $n$.", "outputFormat": "If there is a solution, the first line should contain a positive integer $m$, the total number of operations.\n\nIn the next $m$ lines, each line contains two positive integers $x_i, y_i$, indicating that in the $i$-th operation you split the piece at row $x_i$, column $y_i$.\n\nIf there is no solution, output $-1$ on the first line.", "hint": "- Constraints: For $40\\%$ of the testdata, $n \\leq 8$.\n- Constraints: For $100\\%$ of the testdata, $n \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "分裂游戏", "background": "", "description": "有一个无限大的棋盘，棋盘左下角有一个大小为 $n$ 的阶梯形区域，其中最左下角的那个格子里有一枚棋子。你每次可以把一枚棋子“分裂”成两枚棋子，分别放在原位置的上边一格和右边一格。（但如果目标位置已有棋子，则不能这样做）你的目的是通过有限次的操作，让整个阶梯里不再有任何棋子。下图所示的是 $n = 2$ 时的一种解法。\n\n![](https://cdn.luogu.com.cn/upload/pic/1116.png) \n\n我们用从下往上数的方式标记行，从左往右数的方式标记列，以 (行,列) 来标记棋子，并且都从 $1$ 开始。\n\n例如，第三步中的三个棋子坐标分别为 $(3,1),(2,2),(1,2)$。\n\n现在已知 $n$，你需要做的是给出合适的操作序列。\n", "inputFormat": "输入一个正整数 $n$。\n", "outputFormat": "如果有解，第一行应包含一个正整数 $m$，表示总共需要的操作步数。\n\n以下 $m$ 行，每行包括两个正整数 $x_i,y_i$，表示第 $i$ 步操作分裂的是处于第 $x_i$ 行第 $y_i$ 列的棋子。\n\n如果无解，只需在第一行输出 $-1$。", "hint": "- 对于 $40\\%$ 的数据：$n \\leq 8$；\n- 对于 $100\\%$ 的数据：$n \\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P2042", "type": "P", "difficulty": 6, "samples": [["9 8 \n2 -6 3 5 1 -5 -3 6 3 \nGET-SUM 5 4\nMAX-SUM\nINSERT 8 3 -5 7 2\nDELETE 12 1\nMAKE-SAME 3 3 2\nREVERSE 3 6\nGET-SUM 5 4\nMAX-SUM", "-1\n10\n1\n10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "2005", "平衡树", "NOI"], "title": "[NOI2005] 维护数列", "background": null, "description": "请写一个程序，要求维护一个数列，支持以下 $6$ 种操作：\n\n| 编号 | 名称 | 格式 | 说明 |\n| :-----------: | :-----------: | :-----------: | :----------- |\n| 1 | 插入 | $\\operatorname{INSERT}\\ posi \\ tot \\ c_1 \\ c_2 \\cdots c_{tot}$ | 在当前数列的第 $posi$ 个数字后插入 $tot$ 个数字：$c_1, c_2 \\cdots c_{tot}$；若在数列首插入，则 $posi$ 为 $0$ |\n| 2 | 删除 | $\\operatorname{DELETE} \\ posi \\ tot$ | 从当前数列的第 $posi$ 个数字开始连续删除 $tot$ 个数字 |\n| 3 | 修改 | $\\operatorname{MAKE-SAME} \\ posi \\ tot \\ c$ | 从当前数列的第 $posi$ 个数字开始的连续 $tot$ 个数字统一修改为 $c$ |\n| 4 | 翻转 | $\\operatorname{REVERSE} \\ posi \\ tot$ | 取出从当前数列的第 $posi$ 个数字开始的 $tot$ 个数字，翻转后放入原来的位置 |\n| 5 | 求和 | $\\operatorname{GET-SUM} \\ posi \\ tot$ | 计算从当前数列的第 $posi$ 个数字开始的 $tot$ 个数字的和并输出 |\n| 6 | 求最大子列和 | $\\operatorname{MAX-SUM}$ | 求出当前数列中和最大的一段非空子列，并输出最大和 |", "inputFormat": "第一行包含两个整数 $N$ 和 $M$，$N$ 表示初始时数列中数的个数，$M$ 表示要进行的操作数目。\n\n第二行包含 $N$ 个数字，描述初始时的数列。以下 $M$ 行，每行一条命令，格式参见问题描述中的表格。", "outputFormat": "对于输入数据中的 $\\operatorname{GET-SUM}$ 和 $\\operatorname{MAX-SUM}$ 操作，向输出文件依次打印结果，每个答案（数字）占一行。", "hint": "#### 数据规模与约定\n\n- 你可以认为在任何时刻，数列中至少有 $1$ 个数。\n- 输入数据一定是正确的，即指定位置的数在数列中一定存在。\n- 对于 $50\\%$ 的数据，任何时刻数列中最多含有 $3 \\times 10^4$ 个数。\n- 对于 $100\\%$ 的数据，任何时刻数列中最多含有 $5 \\times 10^5$ 个数，任何时刻数列中任何一个数字均在 $[-10^3, 10^3]$ 内，$1 \\le M \\le 2 \\times 10^4$，插入的数字总数不超过 $4 \\times 10^6$。\n\n题面由 @syksykCCC 提供。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2005] Sequence Maintenance", "background": "", "description": "Please write a program to maintain a sequence that supports the following $6$ operations:\n\n| ID | Name | Format | Note |\n| :-----------: | :-----------: | :-----------: | :----------- |\n| 1 | Insert | $\\operatorname{INSERT}\\ posi \\ tot \\ c_1 \\ c_2 \\cdots c_{tot}$ | Insert $tot$ numbers $c_1, c_2 \\cdots c_{tot}$ after the $posi$-th number of the current sequence; if inserting at the beginning of the sequence, then $posi$ is $0$. |\n| 2 | Delete | $\\operatorname{DELETE} \\ posi \\ tot$ | Starting from the $posi$-th number of the current sequence, delete $tot$ consecutive numbers. |\n| 3 | Make-Same | $\\operatorname{MAKE-SAME} \\ posi \\ tot \\ c$ | Starting from the $posi$-th number of the current sequence, set $tot$ consecutive numbers all to $c$. |\n| 4 | Reverse | $\\operatorname{REVERSE} \\ posi \\ tot$ | Take the $tot$ numbers starting from the $posi$-th number, reverse them, and put them back in the original position. |\n| 5 | Get-Sum | $\\operatorname{GET-SUM} \\ posi \\ tot$ | Compute and output the sum of the $tot$ numbers starting from the $posi$-th number of the current sequence. |\n| 6 | Max-Subarray Sum | $\\operatorname{MAX-SUM}$ | Find a contiguous subarray of the current sequence with the maximum sum and output that maximum sum. |", "inputFormat": "The first line contains two integers $N$ and $M$, where $N$ is the number of elements in the initial sequence, and $M$ is the number of operations to perform.\n\nThe second line contains $N$ numbers describing the initial sequence. Each of the following $M$ lines contains one command; see the table in the Description for the formats.", "outputFormat": "For each $\\operatorname{GET-SUM}$ and $\\operatorname{MAX-SUM}$ operation in the input, print the result to the output in order, one answer (number) per line.", "hint": "#### Constraints\n\n- You may assume that at any time, the sequence contains at least $1$ number.\n- The input is guaranteed to be valid, i.e., the specified positions always exist in the sequence.\n- For $50\\%$ of the testdata, the sequence contains at most $3 \\times 10^4$ numbers at any time.\n- For $100\\%$ of the testdata, the sequence contains at most $5 \\times 10^5$ numbers at any time; each number is within $[-10^3, 10^3]$ at any time; $1 \\le M \\le 2 \\times 10^4$; the total count of inserted numbers does not exceed $4 \\times 10^6$.\n\nProblem statement provided by @syksykCCC.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2005] 维护数列", "background": null, "description": "请写一个程序，要求维护一个数列，支持以下 $6$ 种操作：\n\n| 编号 | 名称 | 格式 | 说明 |\n| :-----------: | :-----------: | :-----------: | :----------- |\n| 1 | 插入 | $\\operatorname{INSERT}\\ posi \\ tot \\ c_1 \\ c_2 \\cdots c_{tot}$ | 在当前数列的第 $posi$ 个数字后插入 $tot$ 个数字：$c_1, c_2 \\cdots c_{tot}$；若在数列首插入，则 $posi$ 为 $0$ |\n| 2 | 删除 | $\\operatorname{DELETE} \\ posi \\ tot$ | 从当前数列的第 $posi$ 个数字开始连续删除 $tot$ 个数字 |\n| 3 | 修改 | $\\operatorname{MAKE-SAME} \\ posi \\ tot \\ c$ | 从当前数列的第 $posi$ 个数字开始的连续 $tot$ 个数字统一修改为 $c$ |\n| 4 | 翻转 | $\\operatorname{REVERSE} \\ posi \\ tot$ | 取出从当前数列的第 $posi$ 个数字开始的 $tot$ 个数字，翻转后放入原来的位置 |\n| 5 | 求和 | $\\operatorname{GET-SUM} \\ posi \\ tot$ | 计算从当前数列的第 $posi$ 个数字开始的 $tot$ 个数字的和并输出 |\n| 6 | 求最大子列和 | $\\operatorname{MAX-SUM}$ | 求出当前数列中和最大的一段非空子列，并输出最大和 |", "inputFormat": "第一行包含两个整数 $N$ 和 $M$，$N$ 表示初始时数列中数的个数，$M$ 表示要进行的操作数目。\n\n第二行包含 $N$ 个数字，描述初始时的数列。以下 $M$ 行，每行一条命令，格式参见问题描述中的表格。", "outputFormat": "对于输入数据中的 $\\operatorname{GET-SUM}$ 和 $\\operatorname{MAX-SUM}$ 操作，向输出文件依次打印结果，每个答案（数字）占一行。", "hint": "#### 数据规模与约定\n\n- 你可以认为在任何时刻，数列中至少有 $1$ 个数。\n- 输入数据一定是正确的，即指定位置的数在数列中一定存在。\n- 对于 $50\\%$ 的数据，任何时刻数列中最多含有 $3 \\times 10^4$ 个数。\n- 对于 $100\\%$ 的数据，任何时刻数列中最多含有 $5 \\times 10^5$ 个数，任何时刻数列中任何一个数字均在 $[-10^3, 10^3]$ 内，$1 \\le M \\le 2 \\times 10^4$，插入的数字总数不超过 $4 \\times 10^6$。\n\n题面由 @syksykCCC 提供。", "locale": "zh-CN"}}}
{"pid": "P2043", "type": "P", "difficulty": 2, "samples": [["10", "2 8\n3 4\n5 2\n7 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["数学"], "title": "质因子分解", "background": "", "description": "对 $N!$ 进行质因子分解。", "inputFormat": "输入数据仅有一行包含一个正整数 $N$，$N \\leq 10000$。", "outputFormat": "输出数据包含若干行，每行两个正整数 $p,a$，中间用一个空格隔开。表示 $N!$ 包含 $a$ 个质因子 $p$，要求按 $p$ 的值从小到大输出。", "hint": "$10! = 3628800 = (2^8) \\times (3^4) \\times (5^2) \\times 7$。", "locale": "zh-CN", "translations": {"en": {"title": "Prime Factorization of N!", "background": "", "description": "Perform the prime factorization of $N!$.", "inputFormat": "The input consists of a single line containing a positive integer $N$, with $N \\leq 10000$.", "outputFormat": "Output multiple lines. Each line contains two positive integers $p$ and $a$, separated by a single space, indicating that $N!$ contains $a$ copies of the prime factor $p$. Output them in increasing order of $p$.", "hint": "$10! = 3628800 = (2^8) \\times (3^4) \\times (5^2) \\times 7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "质因子分解", "background": "", "description": "对 $N!$ 进行质因子分解。", "inputFormat": "输入数据仅有一行包含一个正整数 $N$，$N \\leq 10000$。", "outputFormat": "输出数据包含若干行，每行两个正整数 $p,a$，中间用一个空格隔开。表示 $N!$ 包含 $a$ 个质因子 $p$，要求按 $p$ 的值从小到大输出。", "hint": "$10! = 3628800 = (2^8) \\times (3^4) \\times (5^2) \\times 7$。", "locale": "zh-CN"}}}
{"pid": "P2044", "type": "P", "difficulty": 4, "samples": [["11 8 7 1 5 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "贪心", "高精度", "2012", "矩阵运算", "NOI", "素数判断,质数,筛法", "矩阵乘法"], "title": "[NOI2012] 随机数生成器", "background": "", "description": "栋栋最近迷上了随机算法，而随机数是生成随机算法的基础。栋栋准备使用线性同余法（Linear Congruential Method）来生成一个随机数列，这种方法需要设置四个非负整数参数 $m,a,c,X_0$，按照下面的公式生成出一系列随机数 $\\{X_n\\}$：\n$$X_{n+1}=(aX_n +c)\\bmod m$$\n\n其中 $\\bmod m$ 表示前面的数除以 $m$ 的余数。从这个式子可以看出，这个序列的下一个数总是由上一个数生成的。\n\n用这种方法生成的序列具有随机序列的性质，因此这种方法被广泛地使用，包括常用的 C++ 和 Pascal 的产生随机数的库函数使用的也是这种方法。\n\n栋栋知道这样产生的序列具有良好的随机性，不过心急的他仍然想尽快知道 $X_n$ 是多少。由于栋栋需要的随机数是 $0,1,\\dots,g-1$ 之间的，他需要将 $X_n$ 除以 $g$ 取余得到他想要的数，即 $X_n \\bmod g$，你只需要告诉栋栋他想要的数 $X_n \\bmod g$ 是多少就可以了。\n", "inputFormat": "一行 $6$ 个用空格分割的整数 $m,a,c,X_0,n$ 和 $g$，其中 $a,c,X_0$ 是非负整数，$m,n,g$ 是正整数。\n", "outputFormat": "输出一个数，即 $X_n \\bmod g$。\n", "hint": "计算得 $X_n=X_5=8$，故$(X_n \\bmod g) = (8 \\bmod 3) = 2$。\n\n对于 $100\\%$ 的数据，$n,m,a,c,X_0\\leq 10^{18}$，$1\\leq g\\leq 10^8$，$n,m\\geq 1$，$a,c,X_0\\geq 0$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2012] Random Number Generator", "background": "", "description": "Dongdong has recently become fascinated with randomized algorithms, and random numbers are the foundation for generating them. He plans to use the Linear Congruential Method to generate a sequence of random numbers. This method requires setting four non-negative integer parameters $m, a, c, X_0$, and generates a sequence $\\{X_n\\}$ according to the formula:\n$$X_{n+1} = (a X_n + c) \\bmod m$$\n\nHere, $\\bmod m$ denotes the remainder when the preceding number is divided by $m$. From this equation, we can see that the next number in the sequence is always determined by the previous one.\n\nSequences generated by this method have properties of random sequences, so it is widely used. The standard library functions for generating random numbers in C++ and Pascal also use this method.\n\nDongdong knows that the sequence produced this way has good randomness, but he is impatient and wants to know $X_n$ as soon as possible. Since the random numbers he needs are between $0, 1, \\dots, g - 1$, he will take $X_n$ modulo $g$ to get the number he wants, i.e., $X_n \\bmod g$. You only need to tell Dongdong the value of $X_n \\bmod g$.", "inputFormat": "One line contains 6 space-separated integers $m, a, c, X_0, n$ and $g$, where $a, c, X_0$ are non-negative integers, and $m, n, g$ are positive integers.", "outputFormat": "Output a single number, which is $X_n \\bmod g$.", "hint": "We compute $X_n = X_5 = 8$, thus $(X_n \\bmod g) = (8 \\bmod 3) = 2$.\n\nConstraints: For $100\\%$ of the testdata, $n, m, a, c, X_0 \\leq 10^{18}$, $1 \\leq g \\leq 10^8$, $n, m \\geq 1$, $a, c, X_0 \\geq 0$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2012] 随机数生成器", "background": "", "description": "栋栋最近迷上了随机算法，而随机数是生成随机算法的基础。栋栋准备使用线性同余法（Linear Congruential Method）来生成一个随机数列，这种方法需要设置四个非负整数参数 $m,a,c,X_0$，按照下面的公式生成出一系列随机数 $\\{X_n\\}$：\n$$X_{n+1}=(aX_n +c)\\bmod m$$\n\n其中 $\\bmod m$ 表示前面的数除以 $m$ 的余数。从这个式子可以看出，这个序列的下一个数总是由上一个数生成的。\n\n用这种方法生成的序列具有随机序列的性质，因此这种方法被广泛地使用，包括常用的 C++ 和 Pascal 的产生随机数的库函数使用的也是这种方法。\n\n栋栋知道这样产生的序列具有良好的随机性，不过心急的他仍然想尽快知道 $X_n$ 是多少。由于栋栋需要的随机数是 $0,1,\\dots,g-1$ 之间的，他需要将 $X_n$ 除以 $g$ 取余得到他想要的数，即 $X_n \\bmod g$，你只需要告诉栋栋他想要的数 $X_n \\bmod g$ 是多少就可以了。\n", "inputFormat": "一行 $6$ 个用空格分割的整数 $m,a,c,X_0,n$ 和 $g$，其中 $a,c,X_0$ 是非负整数，$m,n,g$ 是正整数。\n", "outputFormat": "输出一个数，即 $X_n \\bmod g$。\n", "hint": "计算得 $X_n=X_5=8$，故$(X_n \\bmod g) = (8 \\bmod 3) = 2$。\n\n对于 $100\\%$ 的数据，$n,m,a,c,X_0\\leq 10^{18}$，$1\\leq g\\leq 10^8$，$n,m\\geq 1$，$a,c,X_0\\geq 0$。\n", "locale": "zh-CN"}}}
