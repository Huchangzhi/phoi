{"pid": "P3471", "type": "P", "difficulty": 6, "samples": [["5 6 7\nababbd\nabbbbd\naaabad\ncaabbd\ncabaad\n2 3 5 4\n5 3 5 5\n3 5 2 2\n1 2 4 3\n2 2 5 1\n1 1 3 3\n4 1 5 6\n", "3\n3\n3\n2\n3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2008", "平衡树", "POI（波兰）", "离散化", "哈希 hashing"], "title": "[POI 2008] POC-Trains", "background": "", "description": "The Trains of Colour Parade begins tomorrow in Byteotia.\n\nIntense preparations are already in progress at the station's auxiliary tracks. There are $n$ parallel tracks at the station, numbered from $1$ to $n$. The train no. $i$ occupies the $i^{th}$ track.\n\nEvery train consists of $l$ cars and each car is painted with one of 26 colours (denoted by non-capital letters of the English alphabet).\n\nWe say that two trains look the same, if their corresponding cars are painted the same colour.\n\nThroughout the parade a crane will switch places of certain pairs of cars. The real parade, however, will take place tomorrow.\n\nToday the train dispatcher, Byteasar, watched the general rehearsal    closely. He even wrote down the sequence of car swaps.\n\nByteasar particularly dislikes many trains looking the same.\n\nFor each train $p$ he would like to calculate the maximum number    of trains that at some moment look the same as the train $p$ at the very same moment.\n\n## Task\n\nWrite a programme that:\n\n- reads descriptions of the trains occupying tracks and the sequence of car swaps,\n\n- for each train determines the maximum number of trains that look the same as it at certain moment,\n\n- writes out the result.\n\n\n给出n个字符串，长度均为len；\n\n有m次操作，每次将两个字符交换；\n\n求每个字符串在任何时点上，与相同的它最多的字符串个数；\n", "inputFormat": "The first line of the input contains three integers $n$, $l$ and $m$ ($2 \\le n \\le 1000$, $1 \\le l \\le 100$, $0 \\le m \\le 100\\ 000$), denoting respectively the number of trains, their common length and the number of car swaps. The following $n$ lines contain descriptions of the trains on successive tracks. The\n\n$k^{th}$ line consists of $l$ small letters of the English alphabet denoting the colours of successive cars of the $k^{th}$ train. Then $m$ lines describing the car swaps follow, in the order of the swaps. The $r^{th}$ line contains four integers $p_1$, $w_1$, $p_2$, $w_2$ ($1 \\le p_1, p_2, \\le n$, $1 \\le w_1, w_2 \\le l$, $p_1 \\ne p_2$ or $w_1 \\ne w_2$) denoting the $r^{th}$ car swap-the car no. $w_1$ of the train no. $p_1$ is swapped with the car no. $w_2$ of the train no. $p_2$.\n", "outputFormat": "Your programme should write out exactly $n$ lines. The $k^[th}$ line should contain one integer-the number of trains looking the same as the train no. $k$ at certain moment.\n", "hint": "The figure presents the successive car swaps:\n\n```cpp\ntrack 1:  ababbd    ababbd    ababbd    ababbd    aaabbd    aaabbd    aaabbd    aaabbd\ntrack 2:  abbbbd    ababbd    ababbd    aaabbd    aaabbd    acabbd    acabbd    acabbd\ntrack 3:  aaabad -> aaabad -> aaabad -> aaabbd -> aaabbd -> aaabbd -> aaabbd -> aaabbd\ntrack 4:  caabbd    caabbd    caabbd    caabbd    cabbbd    cabbbd    cabbbd    dabbbd\ntrack 5:  cabaad    cabbad    caabbd    caabbd    caabbd    aaabbd    aaabbd    aaabbc\n           (0)       (1)       (2)       (3)       (4)       (5)       (6)       (7)\n```\n\nThe number of trains looking the same as either of the trains no. 1, 2 or 3 was maximal at time (4) (when all three looked the same). The number of trains looking the same as the train no. 5 was maximal at time (5) and (6). The number of trains looking the same as the train no. 4 was maximal at time (2).\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2008] POC-Trains", "background": "", "description": "The Trains of Colour Parade begins tomorrow in Byteotia.\n\nIntense preparations are already in progress at the station’s auxiliary tracks. There are $n$ parallel tracks at the station, numbered from $1$ to $n$. Train no. $i$ occupies the $i^{th}$ track.\n\nEvery train consists of $l$ cars, and each car is painted with one of 26 colours (denoted by lowercase letters of the English alphabet).\n\nWe say that two trains look the same if their corresponding cars are painted the same colour.\n\nThroughout the parade a crane will switch places of certain pairs of cars. The real parade, however, will take place tomorrow.\n\nToday the train dispatcher, Byteasar, watched the general rehearsal closely. He even wrote down the sequence of car swaps.\n\nByteasar particularly dislikes many trains looking the same.\n\nFor each train $p$ he would like to calculate the maximum number of trains that, at some moment, look the same as train $p$ at that very moment.\n\nTask\n\nWrite a program that:\n- reads the descriptions of the trains occupying the tracks and the sequence of car swaps,\n- for each train determines the maximum number of trains that look the same as it at some moment,\n- writes out the result.\n\nGiven $n$ strings, each of length $l$.\nThere are $m$ operations, each swapping two characters.\nFor each string, find the maximum number of strings that are identical to it at some moment.", "inputFormat": "The first line of input contains three integers $n$, $l$ and $m$ ($2 \\le n \\le 1000$, $1 \\le l \\le 100$, $0 \\le m \\le 100\\,000$), denoting respectively the number of trains, their common length, and the number of car swaps. The following $n$ lines contain descriptions of the trains on successive tracks.\n\nThe $k^{th}$ of these lines consists of $l$ lowercase letters of the English alphabet, denoting the colours of successive cars of the $k^{th}$ train. Then $m$ lines describing the car swaps follow, in the order of the swaps. The $r^{th}$ line contains four integers $p_1$, $w_1$, $p_2$, $w_2$ ($1 \\le p_1, p_2 \\le n$, $1 \\le w_1, w_2 \\le l$, $p_1 \\ne p_2$ or $w_1 \\ne w_2$), denoting the $r^{th}$ car swap—the car no. $w_1$ of train no. $p_1$ is swapped with the car no. $w_2$ of train no. $p_2$.", "outputFormat": "Your program should write out exactly $n$ lines. The $k^{th}$ line should contain one integer—the number of trains that, at some moment, look the same as train no. $k$.", "hint": "The figure presents the successive car swaps:\n```cpp\ntrack 1:  ababbd    ababbd    ababbd    ababbd    aaabbd    aaabbd    aaabbd    aaabbd\ntrack 2:  abbbbd    ababbd    ababbd    aaabbd    aaabbd    acabbd    acabbd    acabbd\ntrack 3:  aaabad -> aaabad -> aaabad -> aaabbd -> aaabbd -> aaabbd -> aaabbd -> aaabbd\ntrack 4:  caabbd    caabbd    caabbd    caabbd    cabbbd    cabbbd    cabbbd    dabbbd\ntrack 5:  cabaad    cabbad    caabbd    caabbd    caabbd    aaabbd    aaabbd    aaabbc\n           (0)       (1)       (2)       (3)       (4)       (5)       (6)       (7)\n```\n\nThe number of trains looking the same as either of trains no. 1, 2, or 3 was maximal at time (4) (when all three looked the same). The number of trains looking the same as train no. 5 was maximal at times (5) and (6). The number of trains looking the same as train no. 4 was maximal at time (2).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2008] POC-Trains", "background": "", "description": "The Trains of Colour Parade begins tomorrow in Byteotia.\n\nIntense preparations are already in progress at the station's auxiliary tracks. There are $n$ parallel tracks at the station, numbered from $1$ to $n$. The train no. $i$ occupies the $i^{th}$ track.\n\nEvery train consists of $l$ cars and each car is painted with one of 26 colours (denoted by non-capital letters of the English alphabet).\n\nWe say that two trains look the same, if their corresponding cars are painted the same colour.\n\nThroughout the parade a crane will switch places of certain pairs of cars. The real parade, however, will take place tomorrow.\n\nToday the train dispatcher, Byteasar, watched the general rehearsal    closely. He even wrote down the sequence of car swaps.\n\nByteasar particularly dislikes many trains looking the same.\n\nFor each train $p$ he would like to calculate the maximum number    of trains that at some moment look the same as the train $p$ at the very same moment.\n\n## Task\n\nWrite a programme that:\n\n- reads descriptions of the trains occupying tracks and the sequence of car swaps,\n\n- for each train determines the maximum number of trains that look the same as it at certain moment,\n\n- writes out the result.\n\n\n给出n个字符串，长度均为len；\n\n有m次操作，每次将两个字符交换；\n\n求每个字符串在任何时点上，与相同的它最多的字符串个数；\n", "inputFormat": "The first line of the input contains three integers $n$, $l$ and $m$ ($2 \\le n \\le 1000$, $1 \\le l \\le 100$, $0 \\le m \\le 100\\ 000$), denoting respectively the number of trains, their common length and the number of car swaps. The following $n$ lines contain descriptions of the trains on successive tracks. The\n\n$k^{th}$ line consists of $l$ small letters of the English alphabet denoting the colours of successive cars of the $k^{th}$ train. Then $m$ lines describing the car swaps follow, in the order of the swaps. The $r^{th}$ line contains four integers $p_1$, $w_1$, $p_2$, $w_2$ ($1 \\le p_1, p_2, \\le n$, $1 \\le w_1, w_2 \\le l$, $p_1 \\ne p_2$ or $w_1 \\ne w_2$) denoting the $r^{th}$ car swap-the car no. $w_1$ of the train no. $p_1$ is swapped with the car no. $w_2$ of the train no. $p_2$.\n", "outputFormat": "Your programme should write out exactly $n$ lines. The $k^[th}$ line should contain one integer-the number of trains looking the same as the train no. $k$ at certain moment.\n", "hint": "The figure presents the successive car swaps:\n\n```cpp\ntrack 1:  ababbd    ababbd    ababbd    ababbd    aaabbd    aaabbd    aaabbd    aaabbd\ntrack 2:  abbbbd    ababbd    ababbd    aaabbd    aaabbd    acabbd    acabbd    acabbd\ntrack 3:  aaabad -> aaabad -> aaabad -> aaabbd -> aaabbd -> aaabbd -> aaabbd -> aaabbd\ntrack 4:  caabbd    caabbd    caabbd    caabbd    cabbbd    cabbbd    cabbbd    dabbbd\ntrack 5:  cabaad    cabbad    caabbd    caabbd    caabbd    aaabbd    aaabbd    aaabbc\n           (0)       (1)       (2)       (3)       (4)       (5)       (6)       (7)\n```\n\nThe number of trains looking the same as either of the trains no. 1, 2 or 3 was maximal at time (4) (when all three looked the same). The number of trains looking the same as the train no. 5 was maximal at time (5) and (6). The number of trains looking the same as the train no. 4 was maximal at time (2).\n", "locale": "zh-CN"}}}
{"pid": "P3472", "type": "P", "difficulty": 6, "samples": [["8\n2 3 2 2 6 7 8 5\n", "3 5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2008", "POI（波兰）", "Tarjan", "基环树"], "title": "[POI 2008] MAF-Mafia", "background": "", "description": "Mob feud rages in Equatorial Byteotia. The mob bosses have come to the country's capital, Byteburg, to settle the dispute.\n\nNegotiations were very tense, and at one point the trigger-happy participants drew their guns.\n\nEach participant aims at another with a pistol.\n\nShould they go on a killing spree, the shooting will go in accordance with the following code of honour:\n\nthe participants shoot in a certain order, and at any moment at most one of them is shooting, no shooter misses, his target dies instantly, hence he may not shoot afterwards, everyone shoots once, provided he had not been shot before he has a chance to shoot, no participant may change his first target of choice, even if the target is already dead (then the shot causes no further casualties).\n\nAn undertaker watches from afar, as he usually does. After all, the mobsters have never failed to stimulate his business.\n\nHe sees potential profit in the shooting, but he would like to know tight estimations. Precisely he would like to know the minimum and maximum possible death rate.\n\nThe undertaker sees who aims at whom, but does not know the order of shooting.\n\nYou are to write a programme that determines the numbers he is so keen to know.\n\nTask Write a programme that:\n\nreads from the standard input what target each mobster has chosen,                        determines the minimum and maximum number of casualties, writes out the result to the standard output.\n", "inputFormat": "The first line of the standard input contains the number of participants $n$ ($1\\le n\\le 1{,}000{,}000$).\n\nThey are numbered from $1$ to $n$.\n\nThe second line contains $n$ integers $s_1,s_2,\\cdots,s_n$, separated by single spaces, $1\\le s_i\\le n$.\n\n$s_i$ denotes the number of $i^\\mathrm{th}$ participant's target.\n\nNote that it is possible that $s_i=i$ for some $i$ (the nerves, you know).\n", "outputFormat": "Your programme should write out two integers separated by a single      space in the first and only line of the standard output. These numbers      should be, respectively, the minimum and maximum number of casualties resulting from the shooting.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2008] MAF-Mafia", "background": "", "description": "Mob feud rages in Equatorial Byteotia. The mob bosses have come to the country's capital, Byteburg, to settle the dispute.\n\nNegotiations were very tense, and at one point the trigger-happy participants drew their guns.\n\nEach participant aims at another with a pistol.\n\nShould they go on a killing spree, the shooting will go in accordance with the following code of honour:\n\nthe participants shoot in a certain order, and at any moment at most one of them is shooting, no shooter misses, his target dies instantly, hence he may not shoot afterwards, everyone shoots once, provided he had not been shot before he has a chance to shoot, no participant may change his first target of choice, even if the target is already dead (then the shot causes no further casualties).\n\nAn undertaker watches from afar, as he usually does. After all, the mobsters have never failed to stimulate his business.\n\nHe sees potential profit in the shooting, but he would like to know tight estimations. Precisely he would like to know the minimum and maximum possible death rate.\n\nThe undertaker sees who aims at whom, but does not know the order of shooting.\n\nYou are to write a programme that determines the numbers he is so keen to know.\n\nTask Write a programme that:\n\nreads from the standard input what target each mobster has chosen,                        determines the minimum and maximum number of casualties, writes out the result to the standard output.\n", "inputFormat": "The first line of the standard input contains the number of participants $n$ ($1\\le n\\le 1{,}000{,}000$).\n\nThey are numbered from $1$ to $n$.\n\nThe second line contains $n$ integers $s_1,s_2,\\cdots,s_n$, separated by single spaces, $1\\le s_i\\le n$.\n\n$s_i$ denotes the number of $i^\\mathrm{th}$ participant's target.\n\nNote that it is possible that $s_i=i$ for some $i$ (the nerves, you know).\n", "outputFormat": "Your programme should write out two integers separated by a single      space in the first and only line of the standard output. These numbers      should be, respectively, the minimum and maximum number of casualties resulting from the shooting.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2008] MAF-Mafia", "background": "", "description": "在赤道 Byteotia，黑帮之间的争斗愈演愈烈。黑帮老大们来到该国的首都 Byteburg，以解决争端。\n\n谈判非常紧张，在某个时刻，手痒的参与者们拔出了他们的枪。\n\n每个参与者都用手枪瞄准另一个人。\n\n如果他们开始大开杀戒，射击将按照以下荣誉代码进行：\n\n参与者按一定顺序射击，并且在任何时刻最多只有一个人开枪，射手不会失手，他的目标会立即死亡，因此他之后不能再开枪，每个人都开一次枪，前提是他在有机会开枪之前没有被击中，任何参与者都不能改变他最初选择的目标，即使目标已经死了（那么射击不会造成进一步的伤亡）。\n\n一个殡葬承办人从远处观察，正如他通常所做的那样。毕竟，黑帮分子从未让他的生意冷清过。\n\n他在射击中看到了潜在的利润，但他想知道准确的估计。他想知道最小和最大可能的死亡率。\n\n殡葬承办人看到谁瞄准了谁，但不知道射击的顺序。\n\n你需要编写一个程序来确定他如此渴望知道的数字。\n\n任务 编写一个程序：\n\n从标准输入读取每个黑帮分子选择的目标，确定最小和最大伤亡人数，将结果写入标准输出。", "inputFormat": "标准输入的第一行包含参与者的数量 $n$ ($1 \\le n \\le 1{,}000{,}000$)。\n\n他们的编号从 $1$ 到 $n$。\n\n第二行包含 $n$ 个整数 $s_1,s_2,\\cdots,s_n$，用单个空格分隔，$1 \\le s_i \\le n$。\n\n$s_i$ 表示第 $i$ 个参与者的目标编号。\n\n注意，可能存在 $s_i=i$ 的情况（紧张导致的）。", "outputFormat": "你的程序应在标准输出的第一行输出两个用单个空格分隔的整数。这些数字分别是射击导致的最小和最大伤亡人数。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3473", "type": "P", "difficulty": 6, "samples": [["3 5 10\n4 2\n+++++\n++*++\n++++*\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "POI（波兰）"], "title": "[POI 2008] UCI-The Great Escape", "background": "", "description": "Al Bytone, the infamous thief, plans a bank robbery. He knows only too well that the moment he robs the bank a pursuit will be commenced. Unfortunately, Al Bytone is a poor driver and turning left causes him great trouble. This is why he tries to devise such an escape route that at each intersection he would either ride straight ahead or turn right. He is also aware that once he passes through any intersection, the police will come and remain there, waiting for him. Therefore he may pass through any intersection at most once. Furthermore, the police are always present at certain intersections, so Al Bytone will have to avoid these intersections as well (there's no police at the intersections near the bank and near Al Bytone's hideout.)\n\nAl Bytone is planning his escape route. To your great (and rather unpleasant) surprise, he paid you a visit and told to calculate the number of different escape routes leading from the bank to his hideout complying the aforementioned requirements. Needless to say, Al Bytone does not take 'no' as an answer...\n\nThe streets of Byteburg form a rectangular grid. Every street runs either in the North-South or East-West direction, and every two non-parallel streets intersect. The bank is situated to the south of the south-western-most intersection. Al Bytone will start his great escape driving north.\n\n<Task>\n\nWrite a programme that:\n\n- reads from the standard input the location of hideout, descriptions of intersections with police and a positive integer k,\n- calculates the number of different escape routes leading from the bank to the hideout complying the aforementioned requirements,\n- writes out to the standard output this number's residue modulo k.", "inputFormat": "There are three integers in the first line of the standard input, $n$, $m$ and $k$ ($1\\le n,m\\le 100$, $1\\le k\\le 10^9$).\n\nThe numbers $n$ and $m$ denote the number of streets leading in      East-West and North-South direction, respectively.\n\nThe second line contains two integers $x$ and $y$ ($1\\le x\\le n$, $1\\le y\\le m$).\n\nThese represent the hideout's location - at the intersection      of $x^{\\mathrm{th}}$ street leading in Nort…\n", "outputFormat": "Your programme should write out the residue of the number of escape      routes modulo $k$ in the first and only line of the standard output.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2008] UCI-The Great Escape", "background": "", "description": "Al Bytone, the infamous thief, plans a bank robbery. He knows only too well that the moment he robs the bank a pursuit will be commenced. Unfortunately, Al Bytone is a poor driver and turning left causes him great trouble. This is why he tries to devise such an escape route that at each intersection he would either ride straight ahead or turn right. He is also aware that once he passes through any intersection, the police will come and remain there, waiting for him. Therefore he may pass through any intersection at most once. Furthermore, the police are always present at certain intersections, so Al Bytone will have to avoid these intersections as well (there's no police at the intersections near the bank and near Al Bytone's hideout.)\n\nAl Bytone is planning his escape route. To your great (and rather unpleasant) surprise, he paid you a visit and told to calculate the number of different escape routes leading from the bank to his hideout complying the aforementioned requirements. Needless to say, Al Bytone does not take 'no' as an answer...\n\nThe streets of Byteburg form a rectangular grid. Every street runs either in the North-South or East-West direction, and every two non-parallel streets intersect. The bank is situated to the south of the south-western-most intersection. Al Bytone will start his great escape driving north.\n\n<Task>\n\nWrite a programme that:\n\n- reads from the standard input the location of hideout, descriptions of intersections with police and a positive integer k,\n- calculates the number of different escape routes leading from the bank to the hideout complying the aforementioned requirements,\n- writes out to the standard output this number's residue modulo k.", "inputFormat": "There are three integers in the first line of the standard input, $n$, $m$ and $k$ ($1\\le n,m\\le 100$, $1\\le k\\le 10^9$).\n\nThe numbers $n$ and $m$ denote the number of streets leading in      East-West and North-South direction, respectively.\n\nThe second line contains two integers $x$ and $y$ ($1\\le x\\le n$, $1\\le y\\le m$).\n\nThese represent the hideout's location - at the intersection      of $x^{\\mathrm{th}}$ street leading in Nort…\n", "outputFormat": "Your programme should write out the residue of the number of escape      routes modulo $k$ in the first and only line of the standard output.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2008] UCI-The Great Escape", "background": "", "description": "阿尔·拜通，这个臭名昭著的小偷，计划进行银行抢劫。\n\n他非常清楚，一旦他抢劫银行，追捕就会开始。不幸的是，阿尔·拜通是个糟糕的司机，左转对他来说是个大麻烦。这就是为什么他试图设计一个逃跑路线，使得在每个路口他要么直行，要么右转。他也知道，一旦他经过任何一个路口，警察就会到达并留在那里等他。\n\n因此，他最多只能经过每个路口一次。\n\n此外，警察总是在某些路口待命，所以阿尔·拜通也必须避开这些路口（银行附近和阿尔·拜通藏身处附近的路口没有警察）。阿尔·拜通正在计划他的逃跑路线。令你非常（且相当不愉快）惊讶的是，他拜访了你，并要求你计算符合上述要求的从银行到他藏身处的不同逃跑路线的数量。不用说，阿尔·拜通不接受“拒绝”作为答案……\n\nByteburg 的街道形成一个矩形网格。每条街道要么是南北方向，要么是东西方向，并且每两条不平行的街道相交。银行位于最西南路口的南边。\n\n阿尔·拜通将开始他的伟大逃亡，向北行驶。\n\n任务\n\n编写一个程序：\n\n从标准输入读取藏身处的位置、警察所在路口的描述和一个正整数 $k$，计算符合上述要求的从银行到藏身处的不同逃跑路线的数量，并将该数量对 $k$ 取模的结果写入标准输出。", "inputFormat": "标准输入的第一行有三个整数 $n$、$m$ 和 $k$（$1\\le n,m\\le 100$，$1\\le k\\le 10^9$）。\n\n数字 $n$ 和 $m$ 分别表示东西方向和南北方向的街道数量。\n\n第二行包含两个整数 $x$ 和 $y$（$1\\le x\\le n$，$1\\le y\\le m$）。\n\n这些代表藏身处的位置——在第 $x$ 条南北方向街道和第 $y$ 条东西方向街道的交叉口。", "outputFormat": "你的程序应在标准输出的第一行写出逃跑路线数量对 $k$ 取模的结果。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3474", "type": "P", "difficulty": 6, "samples": [["8 4\n1 2 1 3\n25 1 2 1\n4 20 3 3\n3 30 12 2", "2 1 4 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2008", "POI（波兰）", "Special Judge", "前缀和", "单调栈"], "title": "[POI 2008] KUP-Plot purchase", "background": "", "description": "Byteasar is going to buy an industrial plot.\n\nHis fortune is estimated at $k$ bythalers and this is exactly the amount    Byteasar would like to spend on the parcel.\n\nFinding a parcel worth exactly $k$ bythalers, however, is not an easy task.\n\nFor this reason Byteasar is ready to buy a more expensive plot.\n\nHe considers taking out a loan. The Byteotian Credit Bank will grant him    a loan of up to $k$ bythalers. Thus, Byteasar can spend no more than $2k$    bythalers on the parcel and he would like to spend no less than $k$ bythalers.\n\nThe area in which Byteasar wants to buy his parcel is a square with side    length of $n$ metres. The current landlords have set up various prices per square metre. Byteasar has spoken to each one of them and has then prepared a price map    of the area. The map depicts the price of every metre by metre square. Clearly, there    are $n^2$ such squares. Now is the time to find the dream parcel. It has to be rectangular and consist of whole unit squares. Byteasar has already started looking for the plot on the map,    but after many hours he was still unable to find a suitable one. Be a chap and help him!\n\n<Task> \n\nWrite a programme that:\n\nreads the numbers $k$ and $n$ from the standard input,  along with the price map of the area, determines a parcel with price in the interval $[k,2k]$ or states that no such parcel exists, writes out the result to the standard output.\n\n", "inputFormat": "The first line of the standard input contains two integers, $k$ and $n$, separated by a single space, $1\\le k\\le 10^9$, $1\\le n\\le 2000$.\n\nEach of the following $n$ lines contains $n$ non-negative integers, separated by single spaces.\n\n$i^\\mathrm{th}$ number in the line no. $j+1$ denotes the price of unit square with coordinates $(i,j)$.\n\nThe price of one square metre does not exceed $2{,}000{,}000{,}000$ bythalers.\n", "outputFormat": "If no plot with price in the interval $[k,2k]$ exists, your programme should output exactly one line with word `NIE` (NO in Polish).\n\nOtherwise it should print out one line with four positive integers $x_1,y_1,x_2,y_2$ separated by single spaces and denoting the rectangle's      coordinates.\n\n$(x_1,y_1)$ denotes the upper left rectangle corner, while $(x_2,y_2)$ the lower right corner.\n\nThen it consists of the squares: $\\{x,y\\mid x_1\\le x\\le x_2,y_1\\le y\\le y_2\\}$.\n\nThe sum $c$ of prices of the squares forming up this rectangle should satisfy the inequality $k\\le c\\le 2k$.\n\nIf more than one rectangular parcel satisfies this condition, pick one arbitrarily.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2008] KUP-Plot purchase", "background": "", "description": "Byteasar is going to buy an industrial plot.\n\nHis fortune is estimated at $k$ bythalers and this is exactly the amount    Byteasar would like to spend on the parcel.\n\nFinding a parcel worth exactly $k$ bythalers, however, is not an easy task.\n\nFor this reason Byteasar is ready to buy a more expensive plot.\n\nHe considers taking out a loan. The Byteotian Credit Bank will grant him    a loan of up to $k$ bythalers. Thus, Byteasar can spend no more than $2k$    bythalers on the parcel and he would like to spend no less than $k$ bythalers.\n\nThe area in which Byteasar wants to buy his parcel is a square with side    length of $n$ metres. The current landlords have set up various prices per square metre. Byteasar has spoken to each one of them and has then prepared a price map    of the area. The map depicts the price of every metre by metre square. Clearly, there    are $n^2$ such squares. Now is the time to find the dream parcel. It has to be rectangular and consist of whole unit squares. Byteasar has already started looking for the plot on the map,    but after many hours he was still unable to find a suitable one. Be a chap and help him!\n\n<Task> \n\nWrite a programme that:\n\nreads the numbers $k$ and $n$ from the standard input,  along with the price map of the area, determines a parcel with price in the interval $[k,2k]$ or states that no such parcel exists, writes out the result to the standard output.\n\n", "inputFormat": "The first line of the standard input contains two integers, $k$ and $n$, separated by a single space, $1\\le k\\le 10^9$, $1\\le n\\le 2000$.\n\nEach of the following $n$ lines contains $n$ non-negative integers, separated by single spaces.\n\n$i^\\mathrm{th}$ number in the line no. $j+1$ denotes the price of unit square with coordinates $(i,j)$.\n\nThe price of one square metre does not exceed $2{,}000{,}000{,}000$ bythalers.\n", "outputFormat": "If no plot with price in the interval $[k,2k]$ exists, your programme should output exactly one line with word `NIE` (NO in Polish).\n\nOtherwise it should print out one line with four positive integers $x_1,y_1,x_2,y_2$ separated by single spaces and denoting the rectangle's      coordinates.\n\n$(x_1,y_1)$ denotes the upper left rectangle corner, while $(x_2,y_2)$ the lower right corner.\n\nThen it consists of the squares: $\\{x,y\\mid x_1\\le x\\le x_2,y_1\\le y\\le y_2\\}$.\n\nThe sum $c$ of prices of the squares forming up this rectangle should satisfy the inequality $k\\le c\\le 2k$.\n\nIf more than one rectangular parcel satisfies this condition, pick one arbitrarily.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2008] KUP-Plot purchase", "background": "", "description": "Byteasar 打算购买一块工业用地。\n\n他的财富估计为 $k$ bythalers，这正是 Byteasar 想要花在这块地上的金额。\n\n然而，找到一块价值恰好为 $k$ bythalers 的地并不是一件容易的事。\n\n因此，Byteasar 准备购买一块更昂贵的地。\n\n他考虑贷款。Byteotian 信贷银行会为他提供最多 $k$ bythalers 的贷款。因此，Byteasar 可以在这块地上花费不超过 $2k$ bythalers，并且他希望花费不少于 $k$ bythalers。\n\nByteasar 想要购买的地块所在的区域是一个边长为 $n$ 米的正方形。当前的地主为每平方米设定了不同的价格。Byteasar 已经与他们每个人交谈过，并准备了一张该区域的价格地图。地图显示了每平方米的价格。显然，这里有 $n^2$ 个这样的正方形。现在是时候找到梦想中的地块了。它必须是矩形的，并且由完整的单位正方形组成。Byteasar 已经开始在地图上寻找地块，但经过许多小时的努力，他仍然无法找到合适的地块。请帮帮他吧！\n\n任务\n\n编写一个程序：\n\n从标准输入读取数字 $k$ 和 $n$，以及该区域的价格地图，确定一个价格在区间 $[k,2k]$ 内的地块，或者说明不存在这样的地块，将结果写入标准输出。", "inputFormat": "标准输入的第一行包含两个整数 $k$ 和 $n$，用一个空格分隔，$1\\le k\\le 10^9$，$1\\le n\\le 2000$。\n\n接下来的 $n$ 行中的每一行包含 $n$ 个非负整数，用空格分隔。\n\n第 $j+1$ 行的第 $i$ 个数字表示坐标为 $(i,j)$ 的单位正方形的价格。\n\n每平方米的价格不超过 $2,000,000,000$ bythalers。", "outputFormat": "如果不存在价格在区间 $[k,2k]$ 内的地块，你的程序应输出一行，内容为单词 `NIE`（波兰语中的 NO）。\n\n否则，它应该输出一行，包含四个正整数 $x_1,y_1,x_2,y_2$，用空格分隔，表示矩形的坐标。\n\n$(x_1,y_1)$ 表示矩形的左上角，而 $(x_2,y_2)$ 表示右下角。\n\n然后它由这些正方形组成：$\\{x,y\\mid x_1\\le x\\le x_2,y_1\\le y\\le y_2\\}$。\n\n这些正方形的价格总和 $c$ 应满足不等式 $k\\le c\\le 2k$。\n\n如果有多个矩形地块满足此条件，则任意选择一个。", "hint": "给定 $k,n$ 和 $n\\times n$ 的矩阵，求一个子矩形满足权值和在 $[k,2k]$ 之间。\n\n$n<2000$，$1\\le k\\le10^9$，每个价格都是不大于 $2 \\times 10^9$ 的非负整数。\n\n感谢 @cn：苏炯念 提供的 spj。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3475", "type": "P", "difficulty": 5, "samples": [["6 8\n1 2\n1 6\n2 3\n2 5\n2 6\n3 4\n4 5\n5 6\n", "1 2 6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "POI（波兰）", "Special Judge", "枚举", "深度优先搜索 DFS", "模拟退火", "进制", "状压 DP"], "title": "[POI 2008] POD-Subdivision of Kingdom", "background": "[English Edition](/paste/eu7u3hqg)", "description": "给出一张有 $n$ 个点 $m$ 条边的无向图，你需要求出一组合法的方案，使得图被划分为点数均为 $\\frac n2$ 的两个集合，且两个端点在不同集合中的边数最少。", "inputFormat": "第一行两个整数 $n,m$。\n\n之后 $m$ 行，每行两个整数 $a, b$，表示在 $a$ 与 $b$ 之间有一条边。", "outputFormat": "一行 $\\frac n2$ 个整数，表示在你求出的方案中的一个集合的所有点，由编号从小到大排序。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 26$，$1\\le a,b\\le n$，且 $n$ 为偶数。保证没有重边。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2008] POD-Subdivision of Kingdom", "background": "[English Edition](/paste/eu7u3hqg)", "description": "Given an undirected graph with $n$ vertices and $m$ edges, you need to find a valid partition of the vertices into two sets, each of size $\\frac{n}{2}$, such that the number of edges whose endpoints lie in different sets is minimized.", "inputFormat": "The first line contains two integers $n, m$.\n\nThen follow $m$ lines, each containing two integers $a, b$, indicating that there is an edge between $a$ and $b$.", "outputFormat": "Output one line with $\\frac{n}{2}$ integers: all vertices in one of the sets from your partition, sorted in increasing order by their labels.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 26$, $1 \\le a, b \\le n$, and $n$ is even. It is guaranteed that there are no multiple edges.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2008] POD-Subdivision of Kingdom", "background": "[English Edition](/paste/eu7u3hqg)", "description": "给出一张有 $n$ 个点 $m$ 条边的无向图，你需要求出一组合法的方案，使得图被划分为点数均为 $\\frac n2$ 的两个集合，且两个端点在不同集合中的边数最少。", "inputFormat": "第一行两个整数 $n,m$。\n\n之后 $m$ 行，每行两个整数 $a, b$，表示在 $a$ 与 $b$ 之间有一条边。", "outputFormat": "一行 $\\frac n2$ 个整数，表示在你求出的方案中的一个集合的所有点，由编号从小到大排序。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 26$，$1\\le a,b\\le n$，且 $n$ 为偶数。保证没有重边。", "locale": "zh-CN"}}}
{"pid": "P3476", "type": "P", "difficulty": 6, "samples": [["5\n0 0\n1 2\n0 2\n1 0\n1 1\n", "7.0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2008", "POI（波兰）", "深度优先搜索 DFS", "叉积"], "title": "[POI 2008] TRO-Triangles", "background": "", "description": "$n$ pairwise disjoint points in the plane are given ($n\\ge 3$).\n\nThere are $\\dfrac{n(n-1)(n-2)}{6}$ triangles whose    vertices are some pairwise different points among them    (including degenerate triangles, i.e. ones whose vertices are collinear).\n\nWe want to calculate the sum of areas of all the triangles with vertices    in the given points.\n\nThose parts of the plane that belong to many triangles are to be calculated    multiple times. We assume that the area of degenerate triangles (i.e. those    with collinear vertices) is zero.\n\n<Task>\n\nWrite a programme that:\n\nreads from the standard input the coordinates of the points in the plane,                 determines the sum of the areas of all the triangles with vertices in       the given points,                  prints out the result to the standard output.\n\n\n", "inputFormat": "In the first line of the standard input there is one integer $n$ ($3\\le n\\le 3000$) denoting the number of selected points.\n\nEach of the following $n$ lines contains two integers $x_i$ and $y_i$ ($0\\le x_i,y_i\\le 10^4$) separated by a single space and denoting   the coordinates of the $i^\\mathrm{th}$ point (for $i=1,2,\\cdots,n$).\n\nNo pair (ordered) of coordinates appears more than once.\n", "outputFormat": "In the first and only line of the standard output there should be one   real number equal to the sum of the areas of all the triangles with   vertices in the given points. The outcome should be printed out with   exactly one digit after dot and should not differ from the correct value   by more than $0.1$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2008] TRO-Triangles", "background": "", "description": "$n$ pairwise disjoint points in the plane are given ($n\\ge 3$).\n\nThere are $\\dfrac{n(n-1)(n-2)}{6}$ triangles whose    vertices are some pairwise different points among them    (including degenerate triangles, i.e. ones whose vertices are collinear).\n\nWe want to calculate the sum of areas of all the triangles with vertices    in the given points.\n\nThose parts of the plane that belong to many triangles are to be calculated    multiple times. We assume that the area of degenerate triangles (i.e. those    with collinear vertices) is zero.\n\n<Task>\n\nWrite a programme that:\n\nreads from the standard input the coordinates of the points in the plane,                 determines the sum of the areas of all the triangles with vertices in       the given points,                  prints out the result to the standard output.\n\n\n", "inputFormat": "In the first line of the standard input there is one integer $n$ ($3\\le n\\le 3000$) denoting the number of selected points.\n\nEach of the following $n$ lines contains two integers $x_i$ and $y_i$ ($0\\le x_i,y_i\\le 10^4$) separated by a single space and denoting   the coordinates of the $i^\\mathrm{th}$ point (for $i=1,2,\\cdots,n$).\n\nNo pair (ordered) of coordinates appears more than once.\n", "outputFormat": "In the first and only line of the standard output there should be one   real number equal to the sum of the areas of all the triangles with   vertices in the given points. The outcome should be printed out with   exactly one digit after dot and should not differ from the correct value   by more than $0.1$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2008] TRO-Triangles", "background": "", "description": "平面上给定了 $n$ 个两两不相交的点（$n \\ge 3$）。\n\n这些点中有 $\\dfrac{n(n-1)(n-2)}{6}$ 个三角形，其顶点是其中一些两两不同的点（包括退化三角形，即顶点共线的三角形）。\n\n我们想要计算所有以给定点为顶点的三角形的面积之和。\n\n属于多个三角形的平面部分需要多次计算。我们假设退化三角形（即顶点共线的三角形）的面积为零。\n\n<Task>\n\n编写一个程序：\n\n从标准输入读取平面上点的坐标，确定所有以给定点为顶点的三角形的面积之和，输出结果到标准输出。", "inputFormat": "标准输入的第一行有一个整数 $n$（$3 \\le n \\le 3000$），表示选定点的数量。\n\n接下来的 $n$ 行中的每一行包含两个整数 $x_i$ 和 $y_i$（$0 \\le x_i, y_i \\le 10^4$），用一个空格分隔，表示第 $i$ 个点的坐标（对于 $i=1,2,\\cdots,n$）。\n\n没有一对（有序的）坐标会出现多于一次。", "outputFormat": "标准输出的第一行应该是一个实数，等于所有以给定点为顶点的三角形的面积之和。结果应精确到小数点后一位，并且与正确值的误差不超过 $0.1$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3477", "type": "P", "difficulty": 6, "samples": [["4 1000\n2 1 10 2\n", "5\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "POI（波兰）"], "title": "[POI 2008] PER-Permutation", "background": "", "description": "Multiset is a mathematical object similar to a set,    but each member of a multiset may have more than one membership.\n\nJust as with any set, the members of a multiset can be ordered    in many ways. We call each such ordering a permutation    of the multiset. For example, among the permutations of the    multiset{1,1,2,3,3,3,7,8}. there are {2,3,1,3,3,7,1,8}   and{8,7,3,3,3,2,1,1}.\n\nWe will say that one permutation of a given multiset is smaller    (in lexicographic order) than another permutation, if on the first    position that does not match the first permutation has a smaller    element than the other one. All permutations of a given multiset    can be numbered (starting from one) in an increasing order.\n\nTask      Write a programme that   reads the description of a permutation of a multiset and a positive          integerm from the standard input,                      determines the remainder of the rank of that permutation in the          lexicographic ordering modulo m,         writes out the result to the standard output.\n\n多重集合是数学中的一个概念，它的定义很像集合，但是在多重集之中，同一个元素可以出现多次。\n\n\n和集合一样，多重集的的元素可以有很多种元素的排布顺序。我们把它叫作多重集的排列。\n\n\n现在我们定义多重集的某个排列$s_i$比某个排列$s_j$\n\n的大小比较为字典序比较。这样某个多重集的排列可以从小到大得排起来。\n\n\n现在给你一个元素个数为n的多重集的一个排列和m，求这个排列的排名取模m。\n", "inputFormat": "The first line of the standard input holds two integers n($1\\le n \\le 300000$) and m  ($2 \\le m \\le 10^9$ ) ,separated by      a single space. These denote, respectively, the cardinality of the      multiset and \\dots\\ the number m.\n\nThe second line of the standard input contains n positive integers      $a_i$($1\\le a_i \\le 300000$), separated by single spaces and denoting      successive elements of the multiset permutation.\n\n第一行 两个整数n,m\n\n\n第二行 n个数，代表多重集的排列\n", "outputFormat": "The first and only line of the standard output is to hold one integer,      the remainder modulo m of the rank of the input permutation in the      lexicographic ordering.\n\n\n一行一个整数 排名取模m\n", "hint": "感谢@远航之曲 贡献的翻译\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2008] PER-Permutation", "background": "", "description": "A multiset is like a set, but elements may appear more than once.\n\nA permutation of a multiset is any ordering of its elements. For example, among the permutations of the multiset {1, 1, 2, 3, 3, 3, 7, 8}, there are {2, 3, 1, 3, 3, 7, 1, 8} and {8, 7, 3, 3, 3, 2, 1, 1}.\n\nWe use lexicographic order to compare two permutations: at the first position where they differ, the permutation with the smaller element is considered smaller. All permutations of a given multiset can be sorted increasingly and numbered starting from 1 (this number is called the rank).\n\nTask: Given a permutation of a multiset of size n and a positive integer m, compute the remainder modulo m of the rank of this permutation in lexicographic order.", "inputFormat": "- The first line contains two integers n and m ($1 \\le n \\le 300000$, $2 \\le m \\le 10^9$): the size of the multiset and the modulus m.\n- The second line contains n positive integers $a_i$ ($1 \\le a_i \\le 300000$), the given permutation of the multiset.", "outputFormat": "Output a single integer: the rank of the given permutation in lexicographic order, taken modulo m.", "hint": "Thanks to @远航之曲 for the translation.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2008] PER-Permutation", "background": "", "description": "Multiset is a mathematical object similar to a set,    but each member of a multiset may have more than one membership.\n\nJust as with any set, the members of a multiset can be ordered    in many ways. We call each such ordering a permutation    of the multiset. For example, among the permutations of the    multiset{1,1,2,3,3,3,7,8}. there are {2,3,1,3,3,7,1,8}   and{8,7,3,3,3,2,1,1}.\n\nWe will say that one permutation of a given multiset is smaller    (in lexicographic order) than another permutation, if on the first    position that does not match the first permutation has a smaller    element than the other one. All permutations of a given multiset    can be numbered (starting from one) in an increasing order.\n\nTask      Write a programme that   reads the description of a permutation of a multiset and a positive          integerm from the standard input,                      determines the remainder of the rank of that permutation in the          lexicographic ordering modulo m,         writes out the result to the standard output.\n\n多重集合是数学中的一个概念，它的定义很像集合，但是在多重集之中，同一个元素可以出现多次。\n\n\n和集合一样，多重集的的元素可以有很多种元素的排布顺序。我们把它叫作多重集的排列。\n\n\n现在我们定义多重集的某个排列$s_i$比某个排列$s_j$\n\n的大小比较为字典序比较。这样某个多重集的排列可以从小到大得排起来。\n\n\n现在给你一个元素个数为n的多重集的一个排列和m，求这个排列的排名取模m。\n", "inputFormat": "The first line of the standard input holds two integers n($1\\le n \\le 300000$) and m  ($2 \\le m \\le 10^9$ ) ,separated by      a single space. These denote, respectively, the cardinality of the      multiset and \\dots\\ the number m.\n\nThe second line of the standard input contains n positive integers      $a_i$($1\\le a_i \\le 300000$), separated by single spaces and denoting      successive elements of the multiset permutation.\n\n第一行 两个整数n,m\n\n\n第二行 n个数，代表多重集的排列\n", "outputFormat": "The first and only line of the standard output is to hold one integer,      the remainder modulo m of the rank of the input permutation in the      lexicographic ordering.\n\n\n一行一个整数 排名取模m\n", "hint": "感谢@远航之曲 贡献的翻译\n", "locale": "zh-CN"}}}
{"pid": "P3478", "type": "P", "difficulty": 4, "samples": [["8\n1 4\n5 6\n4 5\n6 7\n6 8\n2 4\n3 4\n", "7\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "树形数据结构", "2008", "POI（波兰）", "Special Judge", "O2优化", "树形 DP"], "title": "[POI 2008] STA-Station", "background": "", "description": "给定一个 $n$ 个点的树，请求出一个结点，使得以这个结点为根时，所有结点的深度之和最大。\n\n一个结点的深度之定义为该节点到根的简单路径上边的数量。", "inputFormat": "第一行有一个整数，表示树的结点个数 $n$。  \n接下来 $(n - 1)$ 行，每行两个整数 $u, v$，表示存在一条连接 $u, v$ 的边。", "outputFormat": "**本题存在 Special Judge**。\n\n输出一行一个整数表示你选择的结点编号。如果有多个结点符合要求，输出任意一个即可。", "hint": "#### 样例 1 解释\n\n输出 $7$ 和 $8$ 都是正确答案。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 10^6$，$1 \\leq u, v \\leq n$，给出的是一棵树。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2008] STA-Station", "background": "", "description": "Given a tree with $n$ nodes, find a node such that when this node is chosen as the root, the sum of depths of all nodes is maximized.\n\nThe depth of a node is defined as the number of edges on the simple path from that node to the root.", "inputFormat": "The first line contains an integer $n$, the number of nodes in the tree.  \nThe next $(n - 1)$ lines each contain two integers $u, v$, indicating that there is an edge connecting $u$ and $v$.", "outputFormat": "This problem uses Special Judge.\n\nOutput one line with an integer, the index of the chosen node. If multiple nodes satisfy the requirement, output any one of them.", "hint": "Sample 1 Explanation:\n\nOutputting $7$ or $8$ are both correct answers.\n\nConstraints:\n\nFor all test points, it is guaranteed that $1 \\leq n \\leq 10^6$, $1 \\leq u, v \\leq n$, and the input is a tree.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2008] STA-Station", "background": "", "description": "给定一个 $n$ 个点的树，请求出一个结点，使得以这个结点为根时，所有结点的深度之和最大。\n\n一个结点的深度之定义为该节点到根的简单路径上边的数量。", "inputFormat": "第一行有一个整数，表示树的结点个数 $n$。  \n接下来 $(n - 1)$ 行，每行两个整数 $u, v$，表示存在一条连接 $u, v$ 的边。", "outputFormat": "**本题存在 Special Judge**。\n\n输出一行一个整数表示你选择的结点编号。如果有多个结点符合要求，输出任意一个即可。", "hint": "#### 样例 1 解释\n\n输出 $7$ 和 $8$ 都是正确答案。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 10^6$，$1 \\leq u, v \\leq n$，给出的是一棵树。", "locale": "zh-CN"}}}
{"pid": "P3479", "type": "P", "difficulty": 6, "samples": [["12 3 1\n1 12\n3 8\n7 8\n8 9\n2 12\n10 12\n9 12\n4 8\n5 8\n8 11\n6 8\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2009", "POI（波兰）"], "title": "[POI 2009] GAS-Fire Extinguishers", "background": "\n", "description": "Byteasar has had a new palace built. It consists of $n$ chambers and $n-1$ corridors connecting them. Each corridor connects exactly two chambers. The rooms are numbered from $1$ to $n$. There is only a single entrance to the palace, which leads to chamber no. $1$). For each chamber there is exactly one route leading to it from the entrance, without turning back on the way. In other words, the chambers and the corridors form a tree - a connected acyclic graph.\n\nThe fire marshal who is to approve the building demands placing fire extinguishers inside.\n\nThe following are his exact requirements:\n\n- The fire extinguishers should be placed in (some) chambers, and one chamber  may store any number of extinguishers.\n- Each chamber has to be assigned one fire extinguisher, though it may be stored  in another chamber.\n- Each fire extinguisher can be assigned to at most $S$ different chambers.\n- For each room its assigned extinguisher is within the range of $K$ corridors.\n\nByteasar has a week spot for lavish palaces, so it is no surprise he has very little money now, right after completion of another splendid palace.\n\nTherefore he is interested in the minimum number of fire extinguishers sufficient  for satisfying fire marshal's demands.\n\n", "inputFormat": "The first line of the standard input contains three integers $n$, $s$ and $k$ separated by single spaces, $1\\le n\\le 10^5$, $1\\le s\\le n$, $1\\le k\\le 20$.\n\nEach of the following $n-1$ lines holds two integers separated by a single space.\n\nLine no. $i+1$ contains the numbers $x_i,y_i$ denoting the corridor connecting chambers no.$x_i$ and $y_i$.", "outputFormat": "The first and only line of the standard output is to hold one integer - the minimum number of fire extinguishers that have to be installed in palace.\n", "hint": "$1\\leq n,m\\leq 100000, 1\\leq k \\leq 20 , x_i\\geq 1$", "locale": "en", "translations": {"en": {"title": "[POI 2009] GAS-Fire Extinguishers", "background": "\n", "description": "Byteasar has had a new palace built. It consists of $n$ chambers and $n-1$ corridors connecting them. Each corridor connects exactly two chambers. The rooms are numbered from $1$ to $n$. There is only a single entrance to the palace, which leads to chamber no. $1$). For each chamber there is exactly one route leading to it from the entrance, without turning back on the way. In other words, the chambers and the corridors form a tree - a connected acyclic graph.\n\nThe fire marshal who is to approve the building demands placing fire extinguishers inside.\n\nThe following are his exact requirements:\n\n- The fire extinguishers should be placed in (some) chambers, and one chamber  may store any number of extinguishers.\n- Each chamber has to be assigned one fire extinguisher, though it may be stored  in another chamber.\n- Each fire extinguisher can be assigned to at most $S$ different chambers.\n- For each room its assigned extinguisher is within the range of $K$ corridors.\n\nByteasar has a week spot for lavish palaces, so it is no surprise he has very little money now, right after completion of another splendid palace.\n\nTherefore he is interested in the minimum number of fire extinguishers sufficient  for satisfying fire marshal's demands.\n\n", "inputFormat": "The first line of the standard input contains three integers $n$, $s$ and $k$ separated by single spaces, $1\\le n\\le 10^5$, $1\\le s\\le n$, $1\\le k\\le 20$.\n\nEach of the following $n-1$ lines holds two integers separated by a single space.\n\nLine no. $i+1$ contains the numbers $x_i,y_i$ denoting the corridor connecting chambers no.$x_i$ and $y_i$.", "outputFormat": "The first and only line of the standard output is to hold one integer - the minimum number of fire extinguishers that have to be installed in palace.\n", "hint": "$1\\leq n,m\\leq 100000, 1\\leq k \\leq 20 , x_i\\geq 1$", "locale": "en"}, "zh-CN": {"title": "[POI 2009] GAS-Fire Extinguishers", "background": null, "description": "Byteasar 新建了一座宫殿。它由 $n$ 个房间和 $n-1$ 条走廊连接而成。每条走廊正好连接两个房间。房间编号从 $1$ 到 $n$。宫殿只有一个入口，通向编号为 $1$ 的房间。对于每个房间，从入口到它只有一条不回头的路线。换句话说，房间和走廊形成了一棵树——一个连通无环图。\n\n负责批准建筑的消防员要求在内部放置灭火器。\n\n他的具体要求如下：\n\n- 灭火器应放置在（某些）房间中，一个房间可以存放任意数量的灭火器。\n- 每个房间必须分配一个灭火器，尽管它可以存放在另一个房间中。\n- 每个灭火器最多可以分配给 $s$ 个不同的房间。\n- 对于每个房间，其分配的灭火器在 $k$ 条走廊范围内。\n\nByteasar 对奢华的宫殿情有独钟，所以毫不奇怪，在完成另一个辉煌的宫殿后，他现在几乎没有钱。\n\n因此，他对满足消防员要求所需的最少灭火器数量感兴趣。", "inputFormat": "标准输入的第一行包含三个整数 $n$、$s$ 和 $k$，用单个空格分隔，$1 \\le n \\le 10^5$，$1 \\le s \\le n$，$1 \\le k \\le 20$。\n\n接下来的 $n-1$ 行中的每一行包含两个整数，用单个空格分隔。\n\n第 $i+1$ 行包含数字 $x_i,y_i$，表示连接房间编号 $x_i$ 和 $y_i$ 的走廊。", "outputFormat": "标准输出的第一行应包含一个整数——在宫殿中必须安装的最少灭火器数量。", "hint": "$1 \\leq n,s \\leq 100000, 1 \\leq k \\leq 20 , x_i \\geq 1$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3480", "type": "P", "difficulty": 6, "samples": [["2\n2\n2 2\n3\n1 2 4\n", "NIE\nTAK\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["博弈论", "2009", "POI（波兰）"], "title": "[POI 2009] KAM-Pebbles", "background": "", "description": "Johny and Margaret are playing \"pebbles\". Initially there is a certain number of pebbles on a table, grouped in $n$ piles. The piles are next to each other, forming a single row. The arrangement of stones satisfies an additional property that each pile consists of at least as many pebbles as the one to the left (with the obvious exception of the leftmost pile). The players alternately remove any number of pebbles from a single pile of their choice. They have to take care, though, not to make any pile smaller than the one left to it. In other words, the piles have to satisfy the initial property after the move as well. When one of the players cannot make a move (i.e. before his move there are no more pebbles on the table), he loses. Johny always starts, to compensate for Margaret's mastery in this game.\n\nIn fact Margaret is so good that she always makes the best move, and wins the game whenever she has a chance. Therefore Johny asks your help - he would like to know if he stands a chance of beating Margaret with a particular initial arrangement. Write a programme that determines answers to Johny's inquiries.\n", "inputFormat": "In the first line of the standard input there is a single integer $u$ ($1\\le u\\le 10$) denoting the number of initial pebble arrangements to analyse.\n\nThe following $2u$ lines contain descriptions of these arrangements; each one takes exactly two lines.\n\nThe first line of each description contains a single integer $n$, $1\\le n\\le 1000$  - the number of piles.\n\nThe second line of description holds  non-negative integers  separated by single spaces and denoting the numbers of pebbles in successive piles, left to right.\n\nThese numbers satisfy the following inequality $a_1\\le a_2\\le \\cdots \\le a_n$.\n\n\nThe total number of pebbles in any arrangement does not exceed $1000$.\n", "outputFormat": "Precisely $n$ lines should be printed out on the standard output.\n\nThe $i$-th of these lines (for $1\\le i\\le u$) should hold the word TAK (yes in Polish), if Johny can win starting with the $i$-th initial arrangement given in the input, or the word NIE (no in Polish), if Johny is bound to lose that game, assuming optimal play of Margaret.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] KAM-Pebbles", "background": "", "description": "Johny and Margaret are playing \"pebbles\". Initially there is a certain number of pebbles on a table, grouped in $n$ piles. The piles are next to each other, forming a single row. The arrangement of stones satisfies an additional property that each pile consists of at least as many pebbles as the one to the left (with the obvious exception of the leftmost pile). The players alternately remove any number of pebbles from a single pile of their choice. They have to take care, though, not to make any pile smaller than the one left to it. In other words, the piles have to satisfy the initial property after the move as well. When one of the players cannot make a move (i.e. before his move there are no more pebbles on the table), he loses. Johny always starts, to compensate for Margaret's mastery in this game.\n\nIn fact Margaret is so good that she always makes the best move, and wins the game whenever she has a chance. Therefore Johny asks your help - he would like to know if he stands a chance of beating Margaret with a particular initial arrangement. Write a programme that determines answers to Johny's inquiries.\n", "inputFormat": "In the first line of the standard input there is a single integer $u$ ($1\\le u\\le 10$) denoting the number of initial pebble arrangements to analyse.\n\nThe following $2u$ lines contain descriptions of these arrangements; each one takes exactly two lines.\n\nThe first line of each description contains a single integer $n$, $1\\le n\\le 1000$  - the number of piles.\n\nThe second line of description holds  non-negative integers  separated by single spaces and denoting the numbers of pebbles in successive piles, left to right.\n\nThese numbers satisfy the following inequality $a_1\\le a_2\\le \\cdots \\le a_n$.\n\n\nThe total number of pebbles in any arrangement does not exceed $1000$.\n", "outputFormat": "Precisely $n$ lines should be printed out on the standard output.\n\nThe $i$-th of these lines (for $1\\le i\\le u$) should hold the word TAK (yes in Polish), if Johny can win starting with the $i$-th initial arrangement given in the input, or the word NIE (no in Polish), if Johny is bound to lose that game, assuming optimal play of Margaret.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] KAM-Pebbles", "background": null, "description": "有 $n$ 堆石子。除了第一堆外，每堆石子个数都不少于前一堆的石子个数。两人轮流操作。每次操作可以从一堆石子中移走任意多颗石子，但是要保证操作后仍然满足初始时的条件。没有石子可移动的人就输掉了游戏。问先手是否必胜。", "inputFormat": "多组输入，第一行一个整数 $u$ 代表数据组数（$1\\le u\\le 10$）\n\n接下来共 $2u$ 行，每两行代表一组数据：\n\n第一行只有一个整数 $n$（$1\\le n\\le 1000$），表示石子堆数；\n\n第二行有 $n$ 个整数用空格隔开，第 $i$ 个整数 $a_i$ 表示第 $i$ 堆的石子个数，保证 $a_1\\le a_2\\le a_3\\le \\cdots\\le a_n$。\n\n对于每组数据，保证石子总数不超过 $1000$。", "outputFormat": "输出 $u$ 行。在第 $i$ 行，如果第 $i$ 组数据是先手必胜，输出 `TAK`，否则输出 `NIE`。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3481", "type": "P", "difficulty": 6, "samples": [["2\n4 5\n3 1 2 1\n1 3 1 2 1\n7 7\n1 1 2 1 2 1 3\n1 1 2 1 3 1 3\n", "0\n1\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "POI（波兰）"], "title": "[POI 2009] PRZ-Algorithm Speedup", "background": "", "description": "As a punishment for misbehaving, Byteasar is to calculate a certain mysterious and nasty Boolean-valued function $F(x,y)$, which is defined for a pair of positive integer sequences $x=(x_1,x_2,\\cdots,x_n)$, $y=(y_1,y_2,\\cdots,y_n)$ as follows:\n\n- boolean $F(x, y)$\n- if $W(x)\\neq W(y)$ then return $0$ \n- else if $|W(x)|=|W(y)|=1$ then return $1$\n- else return $F(p(x), p(y)) \\wedge F(s(x), s(y))$.\n\nWhere:\n\n- $W(x)$ denotes the set of members of the sequence $x$ (order and repetitions of elements are insignificant),\n- $p(x)$ denotes the longest prefix (initial part of any length) of the sequence $x$, such that $W(x)\\neq W(p(x))$,\n- $s(x)$ denotes the longest suffix (final part of any length) of the sequence $x$, such that $W(x)\\neq W(s(x))$,\n- $\\wedge$ denotes the logical conjunction, $1$ - true, $0$ - false,      and $|z|$ - cardinality of set $z$.\n\nFor example, for the sequence $x=(2,3,7,2,7,4,7,2,4)$ we have: $W(x)=\\{2,3,4,7\\}$, $p(x)=(2,3,7,2,7)$, $s(x)=(7,2,7,4,7,2,4)$. For very large data a programme calculating values of the function $F$ directly from definition is too slow by any standards. Therefore you are to make these calculations as fast as possible.\n\nWrite a programme that reads several pairs of sequences $(x,y)$ from the standard input and    prints out the values $F(x,y)$ on the standard output for every input pair.\n\n", "inputFormat": "The first line of the standard input contains one integer $k$ ($1\\le k\\le 13$) denoting the number of sequence pairs to analyse.\n\nNext $3k$ line hold descriptions of test cases.\n\nThe first line of each description contains two integers $n$ and $m$ ($1\\le n,m\\le 100{,}000$) separated by a single space and denoting the lengths of the first and second sequence, respectively.\n\nThe second line holds $n$ integers $x_i$ ($1\\le x_i\\le 100$) that form the sequence $x$, separated by single spaces.\n\nThe third line holds $m$ integers $y_i$ ($1\\le y_i\\le 100$),    that form the sequence $y$, separated by single spaces.\n", "outputFormat": "The output should consist of exactly $k$ lines; the $i$-th line (for $1\\le i\\le k$) should contain a single integer - 0 or 1 - the value of $F(x, y)$ for $i$-th test case.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] PRZ-Algorithm Speedup", "background": "", "description": "As a punishment for misbehaving, Byteasar is to calculate a certain mysterious and nasty Boolean-valued function $F(x,y)$, which is defined for a pair of positive integer sequences $x=(x_1,x_2,\\cdots,x_n)$, $y=(y_1,y_2,\\cdots,y_n)$ as follows:\n\n- boolean $F(x, y)$\n- if $W(x)\\neq W(y)$ then return $0$ \n- else if $|W(x)|=|W(y)|=1$ then return $1$\n- else return $F(p(x), p(y)) \\wedge F(s(x), s(y))$.\n\nWhere:\n\n- $W(x)$ denotes the set of members of the sequence $x$ (order and repetitions of elements are insignificant),\n- $p(x)$ denotes the longest prefix (initial part of any length) of the sequence $x$, such that $W(x)\\neq W(p(x))$,\n- $s(x)$ denotes the longest suffix (final part of any length) of the sequence $x$, such that $W(x)\\neq W(s(x))$,\n- $\\wedge$ denotes the logical conjunction, $1$ - true, $0$ - false,      and $|z|$ - cardinality of set $z$.\n\nFor example, for the sequence $x=(2,3,7,2,7,4,7,2,4)$ we have: $W(x)=\\{2,3,4,7\\}$, $p(x)=(2,3,7,2,7)$, $s(x)=(7,2,7,4,7,2,4)$. For very large data a programme calculating values of the function $F$ directly from definition is too slow by any standards. Therefore you are to make these calculations as fast as possible.\n\nWrite a programme that reads several pairs of sequences $(x,y)$ from the standard input and    prints out the values $F(x,y)$ on the standard output for every input pair.\n\n", "inputFormat": "The first line of the standard input contains one integer $k$ ($1\\le k\\le 13$) denoting the number of sequence pairs to analyse.\n\nNext $3k$ line hold descriptions of test cases.\n\nThe first line of each description contains two integers $n$ and $m$ ($1\\le n,m\\le 100{,}000$) separated by a single space and denoting the lengths of the first and second sequence, respectively.\n\nThe second line holds $n$ integers $x_i$ ($1\\le x_i\\le 100$) that form the sequence $x$, separated by single spaces.\n\nThe third line holds $m$ integers $y_i$ ($1\\le y_i\\le 100$),    that form the sequence $y$, separated by single spaces.\n", "outputFormat": "The output should consist of exactly $k$ lines; the $i$-th line (for $1\\le i\\le k$) should contain a single integer - 0 or 1 - the value of $F(x, y)$ for $i$-th test case.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] PRZ-Algorithm Speedup", "background": null, "description": "由于行为不端，Byteasar 被要求计算一个神秘且棘手的布尔值函数 $F(x,y)$，该函数定义在一对正整数序列 $x=(x_1,x_2,\\cdots,x_n)$ 和 $y=(y_1,y_2,\\cdots,y_n)$ 上，如下所示：\n\n- 布尔函数 $F(x, y)$\n- 如果 $W(x)\n\\neq W(y)$ 则返回 $0$\n- 否则如果 $|W(x)|=|W(y)|=1$ 则返回 $1$\n- 否则返回 $F(p(x), p(y)) \\wedge F(s(x), s(y))$。\n\n其中：\n\n- $W(x)$ 表示序列 $x$ 的成员集合（元素的顺序和重复无关紧要），\n- $p(x)$ 表示序列 $x$ 的最长前缀（任意长度的初始部分），使得 $W(x)\n\\neq W(p(x))$，\n- $s(x)$ 表示序列 $x$ 的最长后缀（任意长度的末尾部分），使得 $W(x)\n\\neq W(s(x))$，\n- $\\wedge$ 表示逻辑与，1 表示真，0 表示假，$|z|$ 表示集合 $z$ 的基数。\n\n例如，对于序列 $x=(2,3,7,2,7,4,7,2,4)$，我们有：$W(x)=\\{2,3,4,7\\}$，$p(x)=(2,3,7,2,7)$，$s(x)=(7,2,7,4,7,2,4)$。对于非常大的数据，直接从定义计算函数 $F$ 的值的程序速度太慢。因此，你需要尽可能快地进行这些计算。\n\n编写一个程序，从标准输入读取若干对序列 $(x,y)$，并在标准输出中打印每个输入对的 $F(x,y)$ 值。", "inputFormat": "标准输入的第一行包含一个整数 $k$ ($1\\le k\\le 13$)，表示要分析的序列对的数量。\n\n接下来的 $3k$ 行包含测试用例的描述。\n\n每个描述的第一行包含两个整数 $n$ 和 $m$ ($1\\le n,m\\le 100{,}000$)，用单个空格分隔，表示第一和第二序列的长度。\n\n第二行包含 $n$ 个整数 $x_i$ ($1\\le x_i\\le 100$)，形成序列 $x$，以单个空格分隔。\n\n第三行包含 $m$ 个整数 $y_i$ ($1\\le y_i\\le 100$)，形成序列 $y$，以单个空格分隔。", "outputFormat": "输出应由正好 $k$ 行组成；第 $i$ 行（对于 $1\\le i\\le k$）应包含一个整数 - 0 或 1 - 表示第 $i$ 个测试用例的 $F(x, y)$ 值。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3482", "type": "P", "difficulty": 5, "samples": [["6\n2400 2000 1200 2400 1600 4000\n1 4 5 3 6 2\n5 3 2 4 6 1\n", "11200\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "POI（波兰）", "置换"], "title": "[POI 2009] SLO-Elephants", "background": "", "description": "A parade of all elephants is to commence soon at the Byteotian zoo.\n\nThe zoo employees have encouraged these enormous animals to form a single line,  as the manager wills it to be the initial figure of the parade.\n\nUnfortunately, the manager himself came to the parade and did not quite like  what he saw - he had intended an entirely different order of the elephants.\n\nTherefore he enforced his ordering, claiming the animals would seem most  majestic this way, and made the employees reorder the elephants accordingly.\n\nAs a pack of moving elephants can wreak havoc, the employees decided to have  them rearranged by swapping one pair at a time. Luckily the animals need not  stand next to each other in order to swap positions in the line. Making an elephant  move, however, is not as easy as it sounds. In fact, the effort one has to put  into it is proportional to the animal's mass. Hence, the effort involved in  swapping a pair of elephants of respective masses $m_1$ and $m_2$ can be  estimated by $m_1+m_2$. What is the minimum effort involved in rearranging  the elephants according to manager's will?\n\nWrite a programme that:\n\n- reads from the standard input the masses of all elephants from the zoo,        along with their current and desired order in the line,\n- determines a sequence of elephant swaps leading from the initial to the        desired order of animals in the line, such that this sequence minimises        the summary effort involved in all the swaps, \n- prints out the summary effort on the standard output.\n\n\n", "inputFormat": "The first line of the standard input contains a single integer $n$  ($1\\le n\\le 1{,}000{,}000$) denoting the number of elephants in the zoo.\n\nWe assume that the elephants are numbered from $1$ to $n$ to simplify things.\n\nThe second line holds $n$ integers $m_i$ ($100\\le m_i\\le 6{,}500$ dla $1\\le i\\le n$)  separated by single spaces and denoting the masses of respective elephants  (in kilogrammes).\n\nThe third line of input contains $n$ pairwise different integers $a_i$  ($1\\le a_i\\le n$) separated by single spaces and denoting the numbers of successive elephants in the initial ordering.\n\nThe fourth line holds $n$ pairwise different integers $b_i$ ($1 \\le  b_i \\le  n$) separated by single spaces and denoting the numbers of successive elephants in the ordering desired by the zoo manager. You may assume that the sequences $(a_i)$ and $(b_i)$ differ.", "outputFormat": "The first and only line of the standard output should contain a single integer  denoting the minimum summary effort involved in reordering the elephants  from the order represented by the sequence to the one represented by $(b_i)$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] SLO-Elephants", "background": "", "description": "A parade of all elephants is to commence soon at the Byteotian zoo.\n\nThe zoo employees have encouraged these enormous animals to form a single line,  as the manager wills it to be the initial figure of the parade.\n\nUnfortunately, the manager himself came to the parade and did not quite like  what he saw - he had intended an entirely different order of the elephants.\n\nTherefore he enforced his ordering, claiming the animals would seem most  majestic this way, and made the employees reorder the elephants accordingly.\n\nAs a pack of moving elephants can wreak havoc, the employees decided to have  them rearranged by swapping one pair at a time. Luckily the animals need not  stand next to each other in order to swap positions in the line. Making an elephant  move, however, is not as easy as it sounds. In fact, the effort one has to put  into it is proportional to the animal's mass. Hence, the effort involved in  swapping a pair of elephants of respective masses $m_1$ and $m_2$ can be  estimated by $m_1+m_2$. What is the minimum effort involved in rearranging  the elephants according to manager's will?\n\nWrite a programme that:\n\n- reads from the standard input the masses of all elephants from the zoo,        along with their current and desired order in the line,\n- determines a sequence of elephant swaps leading from the initial to the        desired order of animals in the line, such that this sequence minimises        the summary effort involved in all the swaps, \n- prints out the summary effort on the standard output.\n\n\n", "inputFormat": "The first line of the standard input contains a single integer $n$  ($1\\le n\\le 1{,}000{,}000$) denoting the number of elephants in the zoo.\n\nWe assume that the elephants are numbered from $1$ to $n$ to simplify things.\n\nThe second line holds $n$ integers $m_i$ ($100\\le m_i\\le 6{,}500$ dla $1\\le i\\le n$)  separated by single spaces and denoting the masses of respective elephants  (in kilogrammes).\n\nThe third line of input contains $n$ pairwise different integers $a_i$  ($1\\le a_i\\le n$) separated by single spaces and denoting the numbers of successive elephants in the initial ordering.\n\nThe fourth line holds $n$ pairwise different integers $b_i$ ($1 \\le  b_i \\le  n$) separated by single spaces and denoting the numbers of successive elephants in the ordering desired by the zoo manager. You may assume that the sequences $(a_i)$ and $(b_i)$ differ.", "outputFormat": "The first and only line of the standard output should contain a single integer  denoting the minimum summary effort involved in reordering the elephants  from the order represented by the sequence to the one represented by $(b_i)$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] SLO-Elephants", "background": "", "description": "在 Byteotian 动物园，一场大象游行即将开始。动物园的员工鼓励这些庞大的动物排成一列，因为经理希望这是游行的初始形态。不幸的是，经理亲自来到游行现场，对所见的情形并不满意——他原本打算让大象按完全不同的顺序排列。因此，他强制执行了他所设想的顺序，声称这样动物看起来会最为庄严，并让员工按照他的意愿重新排列大象。由于移动大象群可能会造成混乱，员工决定通过一次交换一对大象的方式来重新排列它们。幸运的是，动物们不需要站在一起就可以交换位置。然而，让大象移动并不像听起来那么简单。实际上，所需的努力与动物的质量成正比。因此，交换质量分别为 $m_1$ 和 $m_2$ 的一对大象所需的努力可以估算为 $m_1+m_2$。重新排列大象以符合经理的意愿所需的最小努力是多少？\n\n编写一个程序：\n\n- 从标准输入读取动物园中所有大象的质量，以及它们当前和期望的排列顺序。\n- 确定一个大象交换序列，从初始顺序到期望的动物排列顺序，使得这个序列中的所有交换的总努力最小化。\n- 在标准输出上打印出总的最小努力。", "inputFormat": "标准输入的第一行包含一个整数 $n$ ($1 \\le n \\le 1{,}000{,}000$)，表示动物园中的大象数量。\n\n为了简化问题，我们假设大象的编号从 $1$ 到 $n$。\n\n第二行包含 $n$ 个整数 $m_i$ ($100 \\le m_i \\le 6{,}500$ 对于 $1 \\le i \\le n$)，用空格分隔，表示各个大象的质量（单位：千克）。\n\n输入的第三行包含 $n$ 个两两不同的整数 $a_i$ ($1 \\le a_i \\le n$)，用空格分隔，表示初始排列中连续大象的编号。\n\n第四行包含 $n$ 个两两不同的整数 $b_i$ ($1 \\le b_i \\le n$)，用空格分隔，表示动物园经理期望的排列中连续大象的编号。可以假设序列 $(a_i)$ 和 $(b_i)$ 是不同的。", "outputFormat": "标准输出的第一行应包含一个整数，表示将大象从序列 $(a_i)$ 表示的顺序重新排列到 $(b_i)$ 表示的顺序所需的最小总努力。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3483", "type": "P", "difficulty": 6, "samples": [["6 5 6 1\n1 2\n6 5\n5 1\n3 3\n3 4\n4 1\n2 3 4 3\n", "1 3 2\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2009", "树状数组", "POI（波兰）"], "title": "[POI 2009] STR-Fire Brigade", "background": "", "description": "In the capital of Byteotia, Bytau, the layout of streets is highly regular. Every street leads either from north to south, or from east to west. Therefore every north-south street intersects every east-west street in exactly one spot. Furthermore, along every street its successive intersections are exactly 1 km apart.\n\nBytau is not only the capital, but also one of the oldest cities in Byteotia. No wonder that there are as many as  historic buildings, each at one of the intersections. The City Council cares for their protection very much, and is now concerned with the risk of fire. Hence they have decided to establish two main fire stations in the city. Each monument is going to be protected by the nearest station; by both, should both fire stations be equally close.\n\nHousing is very dense in Bytau, so Euclidean distance is not the measure of choice. The distance between a monument and fire station should rather be defined as the length of the shortest path along the streets between them.\n\nThe City Council has prepared several projects of the stations' location. And you have been asked to determine, for each of them, the number of monuments protected by: the first station only, the second station only, and both stations, respectively.", "inputFormat": "In the first line of the standard input there are four integers $n$, $m$, $z$ and $p$ ($1\\le n,m\\le 1{,}000{,}000{,}000$, $1\\le z,p\\le 100{,}000$)      separated by single spaces and denoting respectively: the number of streets leading from north to south, the number of streets leading from east to west,      the number of historic buildings in Bytau, and the number of projects proposed by the City Council.\n\nThe north-south streets are numbered from $1$ to $n$, west to east. The east-west streets are numbered from $1$ to $m$, north to south. The intersection of $x$-th north-south and $y$-th east-west street will be denoted by the coordinates $(x,y)$.\n\nIn each of the following  lines there are two integers $x_i$ and $y_i$ ($1 ≤ xi ≤ n$, $1 ≤ yi ≤ m$) separated by a single space and denoting the coordinates of the i-th monument. No pair of different monuments is located at the same intersection.\n\nEach of the following $p$ lines contains one proposal of the City Council - four integers $x_{j,1}, y_{j,1}, x_{j,2}, y_{j,2}$ separated by single spaces, $1 ≤ x_{j,1},x_{j,2} ≤ n$, $1 ≤ y_{j,1},y_{j,2} ≤ m$, $(x_{j,1},y_{j,1})≠(x_{j,2},y_{j,2})$. The coordinates $(x_{j,1},y_{j,1})$ and $(x_{j,2},y_{j,2})$ describe the intersections at which the fire stations are to be located according to the $j$-th proposal $(1 ≤ j ≤ p)$.\n\n", "outputFormat": "Your programme should print out exactly $p$ lines on the standard output.\n\nThere should be three integers in the $j$-th line, denoting:\n\nthe number of monuments protected by the first station of $j$-th proposal of the City Council only, the number of monuments protected by the second      station only and the number of monuments protected by both stations, respectively.\n\nThese numbers should be separated by single spaces.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] STR-Fire Brigade", "background": "", "description": "In the capital of Byteotia, Bytau, the layout of streets is highly regular. Every street leads either from north to south, or from east to west. Therefore every north-south street intersects every east-west street in exactly one spot. Furthermore, along every street its successive intersections are exactly 1 km apart.\n\nBytau is not only the capital, but also one of the oldest cities in Byteotia. No wonder that there are as many as  historic buildings, each at one of the intersections. The City Council cares for their protection very much, and is now concerned with the risk of fire. Hence they have decided to establish two main fire stations in the city. Each monument is going to be protected by the nearest station; by both, should both fire stations be equally close.\n\nHousing is very dense in Bytau, so Euclidean distance is not the measure of choice. The distance between a monument and fire station should rather be defined as the length of the shortest path along the streets between them.\n\nThe City Council has prepared several projects of the stations' location. And you have been asked to determine, for each of them, the number of monuments protected by: the first station only, the second station only, and both stations, respectively.", "inputFormat": "In the first line of the standard input there are four integers $n$, $m$, $z$ and $p$ ($1\\le n,m\\le 1{,}000{,}000{,}000$, $1\\le z,p\\le 100{,}000$)      separated by single spaces and denoting respectively: the number of streets leading from north to south, the number of streets leading from east to west,      the number of historic buildings in Bytau, and the number of projects proposed by the City Council.\n\nThe north-south streets are numbered from $1$ to $n$, west to east. The east-west streets are numbered from $1$ to $m$, north to south. The intersection of $x$-th north-south and $y$-th east-west street will be denoted by the coordinates $(x,y)$.\n\nIn each of the following  lines there are two integers $x_i$ and $y_i$ ($1 ≤ xi ≤ n$, $1 ≤ yi ≤ m$) separated by a single space and denoting the coordinates of the i-th monument. No pair of different monuments is located at the same intersection.\n\nEach of the following $p$ lines contains one proposal of the City Council - four integers $x_{j,1}, y_{j,1}, x_{j,2}, y_{j,2}$ separated by single spaces, $1 ≤ x_{j,1},x_{j,2} ≤ n$, $1 ≤ y_{j,1},y_{j,2} ≤ m$, $(x_{j,1},y_{j,1})≠(x_{j,2},y_{j,2})$. The coordinates $(x_{j,1},y_{j,1})$ and $(x_{j,2},y_{j,2})$ describe the intersections at which the fire stations are to be located according to the $j$-th proposal $(1 ≤ j ≤ p)$.\n\n", "outputFormat": "Your programme should print out exactly $p$ lines on the standard output.\n\nThere should be three integers in the $j$-th line, denoting:\n\nthe number of monuments protected by the first station of $j$-th proposal of the City Council only, the number of monuments protected by the second      station only and the number of monuments protected by both stations, respectively.\n\nThese numbers should be separated by single spaces.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] STR-Fire Brigade", "background": "", "description": "在 Byteotia 的首都 Bytau，街道布局非常规则。每条街道要么从北到南，要么从东到西。因此，每一条南北街道与每一条东西街道正好在一个点相交。此外，沿着每条街道，其连续的交叉口之间的距离正好是 1 公里。\n\nBytau 不仅是首都，也是 Byteotia 最古老的城市之一。难怪这里有许多历史建筑，每个都位于一个交叉口。市议会非常重视它们的保护，现在担心火灾的风险。因此，他们决定在城市中建立两个主要的消防站。每个纪念碑将由最近的消防站保护；如果两个消防站距离相等，则由两个消防站共同保护。\n\nBytau 的住房非常密集，因此欧几里得距离不是首选的度量标准。纪念碑与消防站之间的距离应定义为沿街道之间的最短路径的长度。\n\n市议会已经准备了几个消防站位置的方案。现在要求你确定，对于每个方案，分别有多少纪念碑仅由第一个消防站保护，仅由第二个消防站保护，以及由两个消防站共同保护。", "inputFormat": "标准输入的第一行有四个整数 $n$、$m$、$z$ 和 $p$ ($1 \\le n,m \\le 1{,}000{,}000{,}000$, $1 \\le z,p \\le 100{,}000$)，用单个空格分隔，分别表示：从北到南的街道数量，从东到西的街道数量，Bytau 中的历史建筑数量，以及市议会提出的项目数量。\n\n南北街道从 $1$ 到 $n$ 编号，从西到东。东西街道从 $1$ 到 $m$ 编号，从北到南。第 $x$ 条南北街道和第 $y$ 条东西街道的交叉点将用坐标 $(x,y)$ 表示。\n\n在接下来的 $z$ 行中，每行有两个整数 $x_i$ 和 $y_i$ ($1 \\le x_i \\le n$, $1 \\le y_i \\le m$)，用单个空格分隔，表示第 $i$ 个纪念碑的坐标。没有两个不同的纪念碑位于同一个交叉口。\n\n接下来的 $p$ 行中的每一行包含市议会的一个提案 - 四个整数 $x_{j,1}, y_{j,1}, x_{j,2}, y_{j,2}$，用单个空格分隔，$1 \\le x_{j,1},x_{j,2} \\le n$, $1 \\le y_{j,1},y_{j,2} \\le m$, $(x_{j,1},y_{j,1}) \neq (x_{j,2},y_{j,2})$。坐标 $(x_{j,1},y_{j,1})$ 和 $(x_{j,2},y_{j,2})$ 描述了根据第 $j$ 个提案消防站要设置的位置 $(1 \\le j \\le p)$。", "outputFormat": "你的程序应在标准输出中打印出正好 $p$ 行。\n\n在第 $j$ 行中应该有三个整数，分别表示：\n\n仅由市议会第 $j$ 个提案的第一个消防站保护的纪念碑数量，仅由第二个消防站保护的纪念碑数量，以及由两个消防站共同保护的纪念碑数量。\n\n这些数字应以单个空格分隔。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3484", "type": "P", "difficulty": 5, "samples": [["2\nK adeccecced\nN 5\n", "5\nacedccecced addebcecced adebebecced adecbedcced cceccecce\n4\naedddde bdecdde bececde ccedcde\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "POI（波兰）"], "title": "[POI 2009] WYS-Isles in a Triangular Grid", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/kjilqzz8.png)\n\nThe shapes in the figures 1.1, 1.2 and 1.3 are isles. The shape in the figure 1.4 is not an isle. The shapes in the figures 2.2, 2.3 and 2.5 are congruent.\n\nWe aim at obtaining a systematic description, for each n ≤ 10, of all non-congruent isles that can be formed by n triangles with side length 1, and calculating how many such isles there are.\n\nThe boundary of every isle formed by at most ten triangles is a polygonal chain consisting of unitary segments of the grid. It can be revolved about, i.e. it can be contoured without detaching pencil from the sheet, in such a way that its every segment is followed once, and we come back to the initial point. It may happen though that some point has to be crossed more than once (see Figure 2.4).\n\nLuckily, in case of isles formed by at most ten triangles the shape's perimeter is connected (and can be thus contoured without detaching pencil from the sheet), unlike the one in Figure 1.2.\n\nWhile circling around the perimeter, after each unit segment we make a turn of either of the following types:\n\n- a - 120 degrees left,\n- b - 60 degrees left,\n- c - 0 degrees (i.e. no turn, actually),\n- d - 60 degrees right,\n- e - 120 degrees right.\n\nEach cycle around the isle can be described by a word consisting of letters from the set {a,b,c,d,e}, where each letter tells which turn should be made after each successive unit segment the perimeter consists of. The cycle description has as many letters as there are such unit segments. This means we also describe the turn after the last segment of the polygonal chain, even though it is not required to uniquely determine the shape. This redundant letter is, however, very helpful in transforming one description of a cycle around the shape to another one that differs only in the initial point.\n\nThe words cdddcddd, dcdddcdd, cbbbcbbb describe different cycles around the shape of the Figure 2.1.\n\nThe words cbeddcde, adcabcbb, abcbbadc describe different cycles around the shape of the Figure 2.2.\n\nThe words acdabbcb i cddebced describe different cycles around the shape of the Figure 2.3.\n\nIf the inside of the shape is constantly on right hand side during a cycle around some shape, we call such cycle a clockwise cycle.\n\nOne can determine, for each isle, the set of all isles congruent with it and these isles' clockwise cycles. The code of an isle is such a word that:\n\n1. it is a description of a clockwise cycle around the contour of some isle congruent with the latter,\n2. it is the lexicographically smallest of all words satisfying the previous condition.\n\nFor the isle depicted in Figures 2.2 and 2.3, which are congruent, we take into account all clockwise cycles around each of them:\n\n    beddcdec, eddcdecb, ddcdecbe, dcdecbed, cdecbedd, decbeddc, ecbeddcd, cbeddcde\n\nand\n\n    bcedcdde, cedcddeb, edcddebc, dcddebce, cddebced, ddebcedc, debcedcd, ebcedcdd\n\nso their common code is: bcedcdde, the lexicographically smallest of all the words above.\n\nThe code of the isle depicted in Figure 2.4 is: aadecddcddde.\n\nWrite a programme that:\n\nfor a given code of an isle of size k generates the codes of all isles of size k+1 that can be obtained from the latter by adding one triangle to it,\nfor a given integer n generates the codes of all isles of size n.", "inputFormat": "In the first line of the standard input an integer t (1 ≤ t ≤ 5), denoting the number of queries, is given. Each of the following t lines contains a query of some type. The query of type 1 consists of the letter K and a code of an isle formed by at most ten triangles, separated by a single space. The query of type 2 consists of the letter N and an integer n (1 ≤ n ≤ 10), separated by a single space.", "outputFormat": "The answers to the queries should be printed out to the standard output.\n\nFor queries of type 1 the number of distinct codes of isles that can be obtained by adding one triangle from isles congruent to the one described by the given code. In the following line all these codes, separated by single spaces, should be printed in lexicographic order.\n\nFor queries of type 2 the number of distinct codes of isles formed by n triangles should be printed. In the following line all these codes should be printed in lexicographic order.", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] WYS-Isles in a Triangular Grid", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/kjilqzz8.png)\n\nThe shapes in the figures 1.1, 1.2 and 1.3 are isles. The shape in the figure 1.4 is not an isle. The shapes in the figures 2.2, 2.3 and 2.5 are congruent.\n\nWe aim at obtaining a systematic description, for each n ≤ 10, of all non-congruent isles that can be formed by n triangles with side length 1, and calculating how many such isles there are.\n\nThe boundary of every isle formed by at most ten triangles is a polygonal chain consisting of unitary segments of the grid. It can be revolved about, i.e. it can be contoured without detaching pencil from the sheet, in such a way that its every segment is followed once, and we come back to the initial point. It may happen though that some point has to be crossed more than once (see Figure 2.4).\n\nLuckily, in case of isles formed by at most ten triangles the shape's perimeter is connected (and can be thus contoured without detaching pencil from the sheet), unlike the one in Figure 1.2.\n\nWhile circling around the perimeter, after each unit segment we make a turn of either of the following types:\n\n- a - 120 degrees left,\n- b - 60 degrees left,\n- c - 0 degrees (i.e. no turn, actually),\n- d - 60 degrees right,\n- e - 120 degrees right.\n\nEach cycle around the isle can be described by a word consisting of letters from the set {a,b,c,d,e}, where each letter tells which turn should be made after each successive unit segment the perimeter consists of. The cycle description has as many letters as there are such unit segments. This means we also describe the turn after the last segment of the polygonal chain, even though it is not required to uniquely determine the shape. This redundant letter is, however, very helpful in transforming one description of a cycle around the shape to another one that differs only in the initial point.\n\nThe words cdddcddd, dcdddcdd, cbbbcbbb describe different cycles around the shape of the Figure 2.1.\n\nThe words cbeddcde, adcabcbb, abcbbadc describe different cycles around the shape of the Figure 2.2.\n\nThe words acdabbcb i cddebced describe different cycles around the shape of the Figure 2.3.\n\nIf the inside of the shape is constantly on right hand side during a cycle around some shape, we call such cycle a clockwise cycle.\n\nOne can determine, for each isle, the set of all isles congruent with it and these isles' clockwise cycles. The code of an isle is such a word that:\n\n1. it is a description of a clockwise cycle around the contour of some isle congruent with the latter,\n2. it is the lexicographically smallest of all words satisfying the previous condition.\n\nFor the isle depicted in Figures 2.2 and 2.3, which are congruent, we take into account all clockwise cycles around each of them:\n\n    beddcdec, eddcdecb, ddcdecbe, dcdecbed, cdecbedd, decbeddc, ecbeddcd, cbeddcde\n\nand\n\n    bcedcdde, cedcddeb, edcddebc, dcddebce, cddebced, ddebcedc, debcedcd, ebcedcdd\n\nso their common code is: bcedcdde, the lexicographically smallest of all the words above.\n\nThe code of the isle depicted in Figure 2.4 is: aadecddcddde.\n\nWrite a programme that:\n\nfor a given code of an isle of size k generates the codes of all isles of size k+1 that can be obtained from the latter by adding one triangle to it,\nfor a given integer n generates the codes of all isles of size n.", "inputFormat": "In the first line of the standard input an integer t (1 ≤ t ≤ 5), denoting the number of queries, is given. Each of the following t lines contains a query of some type. The query of type 1 consists of the letter K and a code of an isle formed by at most ten triangles, separated by a single space. The query of type 2 consists of the letter N and an integer n (1 ≤ n ≤ 10), separated by a single space.", "outputFormat": "The answers to the queries should be printed out to the standard output.\n\nFor queries of type 1 the number of distinct codes of isles that can be obtained by adding one triangle from isles congruent to the one described by the given code. In the following line all these codes, separated by single spaces, should be printed in lexicographic order.\n\nFor queries of type 2 the number of distinct codes of isles formed by n triangles should be printed. In the following line all these codes should be printed in lexicographic order.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] WYS-Isles in a Triangular Grid", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/kjilqzz8.png)\n\n图 1.1、1.2 和 1.3 中的形状是岛屿。图 1.4 中的形状不是岛屿。图 2.2、2.3 和 2.5 中的形状是全等的。\n\n我们的目标是系统地描述每个 $n \\leq 10$ 的所有不全等的岛屿，这些岛屿可以由边长为 1 的 $n$ 个三角形组成，并计算出这样的岛屿有多少个。\n\n由最多十个三角形组成的每个岛屿的边界是由网格的单位线段组成的多边形链。它可以旋转，即可以在不将笔从纸上抬起的情况下进行轮廓描绘，使得每个线段都被依次经过一次，并回到起始点。然而，可能会出现某些点必须多次经过的情况（见图 2.4）。\n\n幸运的是，由最多十个三角形组成的岛屿的形状的周长是连通的（因此可以在不将笔从纸上抬起的情况下进行轮廓描绘），不像图 1.2 中的那样。\n\n在围绕周长旋转时，每经过一个单位线段，我们会进行以下类型的转向之一：\n\n- a - 向左 120 度，\n- b - 向左 60 度，\n- c - 0 度（即实际上不转向），\n- d - 向右 60 度，\n- e - 向右 120 度。\n\n围绕岛屿的每个循环可以用一个由集合 {a,b,c,d,e} 中的字母组成的单词来描述，其中每个字母表示在组成周长的每个连续单位线段之后应进行的转向。循环描述的字母数量与这样的单位线段数量相同。这意味着我们也描述了多边形链最后一个线段之后的转向，即使这不是唯一确定形状所必需的。然而，这个冗余的字母在将一个形状的循环描述转换为仅在起始点不同的另一个描述时非常有用。\n\n单词 cdddcddd、dcdddcdd、cbbbcbbb 描述了图 2.1 形状的不同循环。\n\n单词 cbeddcde、adcabcbb、abcbbadc 描述了图 2.2 形状的不同循环。\n\n单词 acdabbcb 和 cddebced 描述了图 2.3 形状的不同循环。\n\n如果在围绕某个形状的循环中形状的内部始终在右手边，我们称这样的循环为顺时针循环。\n\n可以确定每个岛屿的所有与之全等的岛屿及其顺时针循环的集合。岛屿的代码是这样的一个单词：\n\n1. 它是围绕与后者全等的某个岛屿的轮廓的顺时针循环的描述，\n2. 在满足上述条件的所有单词中，它是字典序最小的。\n\n对于图 2.2 和 2.3 中描绘的岛屿，它们是全等的，我们考虑围绕每个岛屿的所有顺时针循环：\n\n    beddcdec, eddcdecb, ddcdecbe, dcdecbed, cdecbedd, decbeddc, ecbeddcd, cbeddcde\n\n和\n\n    bcedcdde, cedcddeb, edcddebc, dcddebce, cddebced, ddebcedc, debcedcd, ebcedcdd\n\n因此它们的公共代码是：bcedcdde，这是上述所有单词中字典序最小的。\n\n图 2.4 中描绘的岛屿的代码是：aadecddcddde。\n\n编写一个程序：\n\n对于给定的大小为 $k$ 的岛屿代码，生成通过在其上添加一个三角形可以从中获得的所有大小为 $k+1$ 的岛屿的代码；\n对于给定的整数 $n$，生成由 $n$ 个三角形组成的所有岛屿的代码。", "inputFormat": "标准输入的第一行给出一个整数 $t$（$1 \\leq t \\leq 5$），表示查询的数量。接下来的 $t$ 行中的每一行包含一个某种类型的查询。类型 1 的查询由字母 K 和一个由最多十个三角形组成的岛屿的代码组成，中间用一个空格分隔。类型 2 的查询由字母 N 和一个整数 $n$（$1 \\leq n \\leq 10$）组成，中间用一个空格分隔。", "outputFormat": "查询的答案应输出到标准输出。\n\n对于类型 1 的查询，可以通过从与给定代码描述的岛屿全等的岛屿中添加一个三角形获得的不同代码的数量。在下一行中，所有这些代码应按字典序排列并用空格分隔。\n\n对于类型 2 的查询，应打印由 $n$ 个三角形组成的不同岛屿代码的数量。在下一行中，所有这些代码应按字典序排列。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3485", "type": "P", "difficulty": 6, "samples": [["6 7\n1 2 a\n1 3 x\n1 4 b\n2 6 l\n3 5 y\n4 5 z\n6 5 a\n3\n1 5 3\n", "3 ala\n-1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2009", "POI（波兰）", "Special Judge", "广度优先搜索 BFS"], "title": "[POI 2009] BAJ-The Walk of Bytie-boy", "background": "[English Edition](/paste/9lmt83m9)", "description": "给出一张 $n$ 个点 $m$ 条边的有向图，每条边上有一个字母，并给出一个整数 $d$ 和一个序列 $s_1, s_2, \\dots, s_d$。  \n\n你需要对每一个 $i(1\\le i<n)$ 求出一条从 $s_i$ 到 $s_{i+1}$ 的最短路径满足这条路径上的边上的字母连起来后是回文的。  \n\n不保证每个点最多只在 $s$ 中出现一次。", "inputFormat": "第一行两个整数 $n, m$。\n\n之后 $m$ 行，每行两个整数 $x_i, y_i$ 与一个字母 $c_i$，表示有一条从 $x_i$ 到 $y_i$ 的边，这条边上的字母是 $c_i$。\n\n之后一行一个整数 $d$。\n\n之后一行 $d$ 个整数， 表示序列 $s$。", "outputFormat": "输出共 $d-1$ 行，第 $i$ 行输出一条从 $s_i$ 到 $s_{i+1}$ 的满足条件的路径。  \n\n若不存在这样的路径，则输出 `-1`，否则输出这条路径上的所有字母。  \n\n如果有多条满足条件的路径，任意输出一条即可。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 400$，$1\\le m\\le 6\\times10^4$，$1\\le x_i,y_i\\le n$，$2\\le d\\le100$，$1\\le s_i\\le n$。\n\n同时保证不会出现重边与自环。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2009] BAJ-The Walk of Bytie-boy", "background": "[English Edition](/paste/9lmt83m9)", "description": "You are given a directed graph with $n$ vertices and $m$ edges. Each edge has a letter on it. You are also given an integer $d$ and a sequence $s_1, s_2, \\dots, s_d$.\n\nFor each $i$ ($1 \\le i < d$), you need to find a shortest path from $s_i$ to $s_{i+1}$ such that the letters on the edges of this path, concatenated in order, form a palindrome.\n\nIt is not guaranteed that each vertex appears at most once in $s$.", "inputFormat": "The first line contains two integers $n, m$.\n\nThen follow $m$ lines. Each line contains two integers $x_i, y_i$ and a letter $c_i$, indicating there is a directed edge from $x_i$ to $y_i$, and the letter on this edge is $c_i$.\n\nThe next line contains an integer $d$.\n\nThe last line contains $d$ integers, giving the sequence $s$.", "outputFormat": "Output $d-1$ lines. On the $i$-th line, output a path from $s_i$ to $s_{i+1}$ that satisfies the condition.\n\nIf no such path exists, output `-1`; otherwise, output all letters on this path.\n\nIf there are multiple valid paths, output any one of them.", "hint": "For $100\\%$ of the testdata, $2 \\le n \\le 400$, $1 \\le m \\le 6\\times 10^4$, $1 \\le x_i, y_i \\le n$, $2 \\le d \\le 100$, $1 \\le s_i \\le n$.\n\nIt is also guaranteed that there are no multiple edges or self-loops.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2009] BAJ-The Walk of Bytie-boy", "background": "[English Edition](/paste/9lmt83m9)", "description": "给出一张 $n$ 个点 $m$ 条边的有向图，每条边上有一个字母，并给出一个整数 $d$ 和一个序列 $s_1, s_2, \\dots, s_d$。  \n\n你需要对每一个 $i(1\\le i<n)$ 求出一条从 $s_i$ 到 $s_{i+1}$ 的最短路径满足这条路径上的边上的字母连起来后是回文的。  \n\n不保证每个点最多只在 $s$ 中出现一次。", "inputFormat": "第一行两个整数 $n, m$。\n\n之后 $m$ 行，每行两个整数 $x_i, y_i$ 与一个字母 $c_i$，表示有一条从 $x_i$ 到 $y_i$ 的边，这条边上的字母是 $c_i$。\n\n之后一行一个整数 $d$。\n\n之后一行 $d$ 个整数， 表示序列 $s$。", "outputFormat": "输出共 $d-1$ 行，第 $i$ 行输出一条从 $s_i$ 到 $s_{i+1}$ 的满足条件的路径。  \n\n若不存在这样的路径，则输出 `-1`，否则输出这条路径上的所有字母。  \n\n如果有多条满足条件的路径，任意输出一条即可。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 400$，$1\\le m\\le 6\\times10^4$，$1\\le x_i,y_i\\le n$，$2\\le d\\le100$，$1\\le s_i\\le n$。\n\n同时保证不会出现重边与自环。", "locale": "zh-CN"}}}
{"pid": "P3486", "type": "P", "difficulty": 5, "samples": [["7 2\n2 1 8 2 1 0\n3 5 1 0 1\n3 1 2 2\n3 5 6\n3 2\n1\n", "2 5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "POI（波兰）"], "title": "[POI 2009] KON-Ticket Inspector", "background": "", "description": "Byteasar works as a ticket inspector in a Byteotian National Railways (BNR)    express train that connects Byteburg with Bitwise.\n\nThe third stage of the BNR reform (The never ending saga of BNR reforms and the Bitwise hub was presented in the problems Railway from the third stage of XIV Polish OI and Station from the third stage of XV Polish OI. Their knowledge, however, is not required at all in order to solve this        problem.) has begun. In particular, the salaries system has already been changed.\n\nFor example, to encourage Byteasar and other ticket inspectors to efficient work, their salaries now depend on the number of tickets (passengers) they    inspect. Byteasar is able to control all the passengers on the train in the time between two successive stations, but he is not eager to waste his energy in doing so. Eventually he decided he would check the tickets exactly $k$ times per ride.\n\nBefore setting out, Byteasar is given a detailed summary from which he knows    exactly how many passengers will travel from each station to another. Based    on that he would like to choose the moments of control in such a way that    the number of passengers checked is maximal. Obviously, Byteasar is not    paid extra for checking someone multiple times - that would be pointless,    and would only disturb the passengers. Write a programme that will determine    for Byteasar when he should check the tickets in order to maximise his    revenue.\n", "inputFormat": "In the first line of the standard input two positive integers $n$ and $k$ ($1 ≤ k < n ≤ 600$, $k ≤ 50$) are given. These are separated by a single space and denote, respectively, the number of stations en route and the number of controls Byteasar intends to make. The stations are numbered from $1$ to $n$ in the order of appearance on the route.\n\nIn the next $n-1$ lines the summary on passengers is given. The $(i+1)$-th line contains information on the passengers who enter the train on the station $i$ - it is a sequence of $n-i$ nonnegative integers $x_{i,i+1},x_{i,i+2},…,x_{i,n}$ separated by single spaces. The number $x_{i,j}$ (for $1 ≤ i < j ≤ n$) denotes the number of passengers who enter the train on station $i$ and leave it on station $j$. The total number of passengers (i.e. the sum of all $x_{i,j}$) does not exceed $2{,}000{,}000{,}000$.", "outputFormat": "Your programme should print out (in a single line) an increasing sequence of $k$ integers from the interval from $1$ to $n-1$ separated by single spaces to the standard output. These numbers should be the numbers of stations upon leaving which Byteasar should control the tickets.", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] KON-Ticket Inspector", "background": "", "description": "Byteasar works as a ticket inspector in a Byteotian National Railways (BNR)    express train that connects Byteburg with Bitwise.\n\nThe third stage of the BNR reform (The never ending saga of BNR reforms and the Bitwise hub was presented in the problems Railway from the third stage of XIV Polish OI and Station from the third stage of XV Polish OI. Their knowledge, however, is not required at all in order to solve this        problem.) has begun. In particular, the salaries system has already been changed.\n\nFor example, to encourage Byteasar and other ticket inspectors to efficient work, their salaries now depend on the number of tickets (passengers) they    inspect. Byteasar is able to control all the passengers on the train in the time between two successive stations, but he is not eager to waste his energy in doing so. Eventually he decided he would check the tickets exactly $k$ times per ride.\n\nBefore setting out, Byteasar is given a detailed summary from which he knows    exactly how many passengers will travel from each station to another. Based    on that he would like to choose the moments of control in such a way that    the number of passengers checked is maximal. Obviously, Byteasar is not    paid extra for checking someone multiple times - that would be pointless,    and would only disturb the passengers. Write a programme that will determine    for Byteasar when he should check the tickets in order to maximise his    revenue.\n", "inputFormat": "In the first line of the standard input two positive integers $n$ and $k$ ($1 ≤ k < n ≤ 600$, $k ≤ 50$) are given. These are separated by a single space and denote, respectively, the number of stations en route and the number of controls Byteasar intends to make. The stations are numbered from $1$ to $n$ in the order of appearance on the route.\n\nIn the next $n-1$ lines the summary on passengers is given. The $(i+1)$-th line contains information on the passengers who enter the train on the station $i$ - it is a sequence of $n-i$ nonnegative integers $x_{i,i+1},x_{i,i+2},…,x_{i,n}$ separated by single spaces. The number $x_{i,j}$ (for $1 ≤ i < j ≤ n$) denotes the number of passengers who enter the train on station $i$ and leave it on station $j$. The total number of passengers (i.e. the sum of all $x_{i,j}$) does not exceed $2{,}000{,}000{,}000$.", "outputFormat": "Your programme should print out (in a single line) an increasing sequence of $k$ integers from the interval from $1$ to $n-1$ separated by single spaces to the standard output. These numbers should be the numbers of stations upon leaving which Byteasar should control the tickets.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] KON-Ticket Inspector", "background": "", "description": "有 $n$ 个车站，现在有一辆火车从 $1$ 到 $n$ 驶过，给出 $a_{i,j}$ 代表从 $i$ 站上车 $j$ 站下车的人的个数。列车行驶过程中你有 $K$ 次检票机会，所有当前在车上的人会被检票，问最多能检多少个不同的人的票。", "inputFormat": "第一行正整数 $N,K$，$1≤K＜N≤600$，$K≤50$。接下来 $N-1$ 行，第 $i$ 行第 $j$ 个数描述第 $i$ 站上，到第 $i+j$ 站下的乘客个数。总乘客数 $≤2\\times 10^9$。", "outputFormat": "单调增的 $K$ 个整数，用空格隔开，表示经过哪些站以后查票。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3487", "type": "P", "difficulty": 5, "samples": [["3\n12 5 8 3 15 8 0", "12\n15\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "单调队列", "POI（波兰）"], "title": "[POI 2009] ARC-Architects", "background": "", "description": "给定一个序列 $a_i$（$1\\leq a_i\\leq 10^9$）且 $1\\leq i\\le n$ 且 $n\\leq  \n 1.5\\times 10^7$，和一个整数 $k$（$k\\leq n$ 且 $k\\leq 10^6$），求出 $a$ 的一个长度为 $k$ 的子序列 $a_{b_i}$ 满足：\n\n1. $1\\leq b_1\\leq b_2\\leq \\ldots\\leq b_k$\n2. 在满足 $1$ 的情况下 $a_{b_1}, a_{b_2},\\ldots , a_{b_k}$ 字典序最大。\n", "inputFormat": "第一行一个数 $k$，以下一行，为序列 $a_i$。以一个单独的 $0$ 结束。\n", "outputFormat": "$k$ 行，每行一个数，其中第 $i$ 行为 $a_{b_i}$。\n", "hint": "本题原为交互题，为评测方便，需要将下面的代码粘贴到文件中。\n\n将第一次输入改为 `=inicjuj()` 形式，将之后的每一次输入改为 `=wczytaj()` 形式，将输出改为 `wypisz(jakoscProjektu)` 形式（`jakoscProjektu` 代表你输出的数）。\n\n```cpp\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\n#define MAGIC_BEGIN -435634223\n#define MAGIC_END -324556462\n\n#define MIN_K 1\n#define MAX_K 1000000\n#define MAX_N 15000000\n#define MIN_A 1\n#define MAX_A 1000000000\n#define MIN_TYP 1\n#define MAX_TYP 3\n#define MIN_PAR 0\n#define MAX_PAR 1000000000\n\n#define ERROR 0\n#define CORRECT 1\n\n#define unlikely(x) __builtin_expect(!!(x), 0)\n\nstatic int init = 0; // czy zostala juz wywolana funkcja inicjuj()\nstatic int lib_n; // ile biblioteka podala juz liczb\nstatic int con_k; // ile zawodnik podal liczb\n\nstatic int N, K, A, TYP, PAR; // parametry testu wczytywane z pliku\nstatic int bre, len_sub, bou, is_end; // zmienne pomocnicze\n\nstatic int rand2_status = 198402041;\n\nstatic inline int rand2(int a, int b){\n  rand2_status = rand2_status * 1103515245ll + 12345;\n  int x = rand2_status;\n  if (x < 0) x = -x; // -2^31 sie nie zdarza :D\n  x >>= 1;\n  x = a + x % (b - a + 1);\n  return x;\n}\n\n/* test losowy */\nstatic inline int random_test()\n{\n    return rand2(1, A);\n}\n\n/* test z dlugim podciagiem nierosnacym */\nstatic inline int decreasing_test()\n{\n    int tmp;\n    if(bre == 0) {\n        bre = rand2(0, (N - lib_n + 1 - len_sub));\n        tmp = A;\n        A -= rand2(0, (A - 1) / len_sub);\n        len_sub--;\n    }\n    else {\n        bre--;\n        tmp = rand2(1, A);\n    }\n    return tmp;\n}\n\n/* test z dlugim podciagiem niemalejacym */\nstatic inline int increasing_test()\n{\n    return bou - decreasing_test();\n}\n\nstatic void finish(int res, const char com[])\n{\n    if(res == ERROR)\n        printf(\"%s\\n\", com);\n    exit(0);\n}\n\n/* Inicjuje dane wejsciowe i zwraca liczbe projektow */\nint inicjuj()\n{\n    if(init == 1)\n        finish(ERROR, \"Program zawodnika moze wywolac funkcje inicjuj tylko raz!!!\");\n    init = 1;\n    scanf(\"%d\", &K);\n    if (K > 0){\n      TYP = 0;\n      N = MAX_N + 2;\n      return K;\n    }\n    int magic_begin, magic_end;\n    scanf(\"%d%d\", &magic_begin, &TYP);\n    if(magic_begin != MAGIC_BEGIN || TYP < MIN_TYP || TYP > MAX_TYP)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    scanf(\"%d%d%d%d\", &N, &K, &A, &PAR);\n    if(N < 1 || N > MAX_N || N < K || K > MAX_K || A < MIN_A || A > MAX_A \n        || PAR < MIN_PAR || PAR > MAX_PAR)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    scanf(\"%d\", &magic_end);\n    if(magic_end != MAGIC_END)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    con_k = 0;\n    lib_n = 0;\n    is_end = 0;\n    if(TYP == 2 || TYP == 3) {\n        len_sub = PAR;\n        bre = 0;\n    }\n    if(TYP == 2)\n        bou = A--;\n    return K;\n}\n\n/* Sluzy do wczytania ciagu reprezentujacego jakosci projektow */\nint wczytaj()\n{\n    if(unlikely(init == 0))\n        finish(ERROR, \"Program zawodnika nie wywolal funkcji inicjuj!!!\");\n    if(unlikely(lib_n > N || is_end == 1))\n        finish(ERROR, \"Program zawodnika wywolal funkcje wczytaj po otrzymaniu informacji o koncu ciagu!!!\");\n    if(unlikely(lib_n == N))\n        return 0;\n    lib_n++;\n    switch (TYP) {\n      case 0:\n        scanf(\"%d\", &A);\n        if(A == 0)\n          is_end = 1;\n        return A;\n        break;\n      case 1: return random_test(); break;\n      case 2: return increasing_test(); break;\n      case 3: return decreasing_test(); break;\n      default:\n              finish(ERROR, \"Nieznany typ testu\");\n    }\n    return -1;\n}\n\n/* Sluzy do wypisania wyznaczonego podciagu */\nvoid wypisz(int jakoscProjektu)\n{\n    if(init == 0)\n        finish(ERROR, \"Program zawodnika nie wywolal funkcji inicjuj!!!\");\n    printf(\"%d\\n\", jakoscProjektu);\n    if(++con_k == K)\n        finish(CORRECT, \"\");\n}\n```", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2009] ARC-Architects", "background": "", "description": "Given a sequence $a_i$ ($1 \\le a_i \\le 10^9$) for $1 \\le i \\le n$ with $n \\le 1.5 \\times 10^7$, and an integer $k$ ($k \\le n$ and $k \\le 10^6$), find a subsequence of $a$ of length $k$, denoted $a_{b_i}$, such that:\n\n1. $1 \\le b_1 \\le b_2 \\le \\ldots \\le b_k$.\n2. Subject to 1, the sequence $a_{b_1}, a_{b_2}, \\ldots, a_{b_k}$ is lexicographically maximum.", "inputFormat": "The first line contains a number $k$. The next line contains the sequence $a_i$. The input ends with a single $0$.", "outputFormat": "Output $k$ lines, one number per line. The $i$-th line should be $a_{b_i}$.", "hint": "This problem was originally interactive. For evaluation convenience, paste the following code into your file.\n\nReplace the first input with a call to `inicjuj()`, replace each subsequent input with a call to `wczytaj()`, and replace your output with `wypisz(jakoscProjektu)` (where `jakoscProjektu` is the number you output).\n\n```cpp\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\n#define MAGIC_BEGIN -435634223\n#define MAGIC_END -324556462\n\n#define MIN_K 1\n#define MAX_K 1000000\n#define MAX_N 15000000\n#define MIN_A 1\n#define MAX_A 1000000000\n#define MIN_TYP 1\n#define MAX_TYP 3\n#define MIN_PAR 0\n#define MAX_PAR 1000000000\n\n#define ERROR 0\n#define CORRECT 1\n\n#define unlikely(x) __builtin_expect(!!(x), 0)\n\nstatic int init = 0; // czy zostala juz wywolana funkcja inicjuj()\nstatic int lib_n; // ile biblioteka podala juz liczb\nstatic int con_k; // ile zawodnik podal liczb\n\nstatic int N, K, A, TYP, PAR; // parametry testu wczytywane z pliku\nstatic int bre, len_sub, bou, is_end; // zmienne pomocnicze\n\nstatic int rand2_status = 198402041;\n\nstatic inline int rand2(int a, int b){\n  rand2_status = rand2_status * 1103515245ll + 12345;\n  int x = rand2_status;\n  if (x < 0) x = -x; // -2^31 sie nie zdarza :D\n  x >>= 1;\n  x = a + x % (b - a + 1);\n  return x;\n}\n\n/* test losowy */\nstatic inline int random_test()\n{\n    return rand2(1, A);\n}\n\n/* test z dlugim podciagiem nierosnacym */\nstatic inline int decreasing_test()\n{\n    int tmp;\n    if(bre == 0) {\n        bre = rand2(0, (N - lib_n + 1 - len_sub));\n        tmp = A;\n        A -= rand2(0, (A - 1) / len_sub);\n        len_sub--;\n    }\n    else {\n        bre--;\n        tmp = rand2(1, A);\n    }\n    return tmp;\n}\n\n/* test z dlugim podciagiem niemalejacym */\nstatic inline int increasing_test()\n{\n    return bou - decreasing_test();\n}\n\nstatic void finish(int res, const char com[])\n{\n    if(res == ERROR)\n        printf(\"%s\\n\", com);\n    exit(0);\n}\n\n/* Inicjuje dane wejsciowe i zwraca liczbe projektow */\nint inicjuj()\n{\n    if(init == 1)\n        finish(ERROR, \"Program zawodnika moze wywolac funkcje inicjuj tylko raz!!!\");\n    init = 1;\n    scanf(\"%d\", &K);\n    if (K > 0){\n      TYP = 0;\n      N = MAX_N + 2;\n      return K;\n    }\n    int magic_begin, magic_end;\n    scanf(\"%d%d\", &magic_begin, &TYP);\n    if(magic_begin != MAGIC_BEGIN || TYP < MIN_TYP || TYP > MAX_TYP)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    scanf(\"%d%d%d%d\", &N, &K, &A, &PAR);\n    if(N < 1 || N > MAX_N || N < K || K > MAX_K || A < MIN_A || A > MAX_A \n        || PAR < MIN_PAR || PAR > MAX_PAR)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    scanf(\"%d\", &magic_end);\n    if(magic_end != MAGIC_END)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    con_k = 0;\n    lib_n = 0;\n    is_end = 0;\n    if(TYP == 2 || TYP == 3) {\n        len_sub = PAR;\n        bre = 0;\n    }\n    if(TYP == 2)\n        bou = A--;\n    return K;\n}\n\n/* Sluzy do wczytania ciagu reprezentujacego jakosci projektow */\nint wczytaj()\n{\n    if(unlikely(init == 0))\n        finish(ERROR, \"Program zawodnika nie wywolal funkcji inicjuj!!!\");\n    if(unlikely(lib_n > N || is_end == 1))\n        finish(ERROR, \"Program zawodnika wywolal funkcje wczytaj po otrzymaniu informacji o koncu ciagu!!!\");\n    if(unlikely(lib_n == N))\n        return 0;\n    lib_n++;\n    switch (TYP) {\n      case 0:\n        scanf(\"%d\", &A);\n        if(A == 0)\n          is_end = 1;\n        return A;\n        break;\n      case 1: return random_test(); break;\n      case 2: return increasing_test(); break;\n      case 3: return decreasing_test(); break;\n      default:\n              finish(ERROR, \"Nieznany typ testu\");\n    }\n    return -1;\n}\n\n/* Sluzy do wypisania wyznaczonego podciagu */\nvoid wypisz(int jakoscProjektu)\n{\n    if(init == 0)\n        finish(ERROR, \"Program zawodnika nie wywolal funkcji inicjuj!!!\");\n    printf(\"%d\\n\", jakoscProjektu);\n    if(++con_k == K)\n        finish(CORRECT, \"\");\n}\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2009] ARC-Architects", "background": "", "description": "给定一个序列 $a_i$（$1\\leq a_i\\leq 10^9$）且 $1\\leq i\\le n$ 且 $n\\leq  \n 1.5\\times 10^7$，和一个整数 $k$（$k\\leq n$ 且 $k\\leq 10^6$），求出 $a$ 的一个长度为 $k$ 的子序列 $a_{b_i}$ 满足：\n\n1. $1\\leq b_1\\leq b_2\\leq \\ldots\\leq b_k$\n2. 在满足 $1$ 的情况下 $a_{b_1}, a_{b_2},\\ldots , a_{b_k}$ 字典序最大。\n", "inputFormat": "第一行一个数 $k$，以下一行，为序列 $a_i$。以一个单独的 $0$ 结束。\n", "outputFormat": "$k$ 行，每行一个数，其中第 $i$ 行为 $a_{b_i}$。\n", "hint": "本题原为交互题，为评测方便，需要将下面的代码粘贴到文件中。\n\n将第一次输入改为 `=inicjuj()` 形式，将之后的每一次输入改为 `=wczytaj()` 形式，将输出改为 `wypisz(jakoscProjektu)` 形式（`jakoscProjektu` 代表你输出的数）。\n\n```cpp\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\n#define MAGIC_BEGIN -435634223\n#define MAGIC_END -324556462\n\n#define MIN_K 1\n#define MAX_K 1000000\n#define MAX_N 15000000\n#define MIN_A 1\n#define MAX_A 1000000000\n#define MIN_TYP 1\n#define MAX_TYP 3\n#define MIN_PAR 0\n#define MAX_PAR 1000000000\n\n#define ERROR 0\n#define CORRECT 1\n\n#define unlikely(x) __builtin_expect(!!(x), 0)\n\nstatic int init = 0; // czy zostala juz wywolana funkcja inicjuj()\nstatic int lib_n; // ile biblioteka podala juz liczb\nstatic int con_k; // ile zawodnik podal liczb\n\nstatic int N, K, A, TYP, PAR; // parametry testu wczytywane z pliku\nstatic int bre, len_sub, bou, is_end; // zmienne pomocnicze\n\nstatic int rand2_status = 198402041;\n\nstatic inline int rand2(int a, int b){\n  rand2_status = rand2_status * 1103515245ll + 12345;\n  int x = rand2_status;\n  if (x < 0) x = -x; // -2^31 sie nie zdarza :D\n  x >>= 1;\n  x = a + x % (b - a + 1);\n  return x;\n}\n\n/* test losowy */\nstatic inline int random_test()\n{\n    return rand2(1, A);\n}\n\n/* test z dlugim podciagiem nierosnacym */\nstatic inline int decreasing_test()\n{\n    int tmp;\n    if(bre == 0) {\n        bre = rand2(0, (N - lib_n + 1 - len_sub));\n        tmp = A;\n        A -= rand2(0, (A - 1) / len_sub);\n        len_sub--;\n    }\n    else {\n        bre--;\n        tmp = rand2(1, A);\n    }\n    return tmp;\n}\n\n/* test z dlugim podciagiem niemalejacym */\nstatic inline int increasing_test()\n{\n    return bou - decreasing_test();\n}\n\nstatic void finish(int res, const char com[])\n{\n    if(res == ERROR)\n        printf(\"%s\\n\", com);\n    exit(0);\n}\n\n/* Inicjuje dane wejsciowe i zwraca liczbe projektow */\nint inicjuj()\n{\n    if(init == 1)\n        finish(ERROR, \"Program zawodnika moze wywolac funkcje inicjuj tylko raz!!!\");\n    init = 1;\n    scanf(\"%d\", &K);\n    if (K > 0){\n      TYP = 0;\n      N = MAX_N + 2;\n      return K;\n    }\n    int magic_begin, magic_end;\n    scanf(\"%d%d\", &magic_begin, &TYP);\n    if(magic_begin != MAGIC_BEGIN || TYP < MIN_TYP || TYP > MAX_TYP)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    scanf(\"%d%d%d%d\", &N, &K, &A, &PAR);\n    if(N < 1 || N > MAX_N || N < K || K > MAX_K || A < MIN_A || A > MAX_A \n        || PAR < MIN_PAR || PAR > MAX_PAR)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    scanf(\"%d\", &magic_end);\n    if(magic_end != MAGIC_END)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    con_k = 0;\n    lib_n = 0;\n    is_end = 0;\n    if(TYP == 2 || TYP == 3) {\n        len_sub = PAR;\n        bre = 0;\n    }\n    if(TYP == 2)\n        bou = A--;\n    return K;\n}\n\n/* Sluzy do wczytania ciagu reprezentujacego jakosci projektow */\nint wczytaj()\n{\n    if(unlikely(init == 0))\n        finish(ERROR, \"Program zawodnika nie wywolal funkcji inicjuj!!!\");\n    if(unlikely(lib_n > N || is_end == 1))\n        finish(ERROR, \"Program zawodnika wywolal funkcje wczytaj po otrzymaniu informacji o koncu ciagu!!!\");\n    if(unlikely(lib_n == N))\n        return 0;\n    lib_n++;\n    switch (TYP) {\n      case 0:\n        scanf(\"%d\", &A);\n        if(A == 0)\n          is_end = 1;\n        return A;\n        break;\n      case 1: return random_test(); break;\n      case 2: return increasing_test(); break;\n      case 3: return decreasing_test(); break;\n      default:\n              finish(ERROR, \"Nieznany typ testu\");\n    }\n    return -1;\n}\n\n/* Sluzy do wypisania wyznaczonego podciagu */\nvoid wypisz(int jakoscProjektu)\n{\n    if(init == 0)\n        finish(ERROR, \"Program zawodnika nie wywolal funkcji inicjuj!!!\");\n    printf(\"%d\\n\", jakoscProjektu);\n    if(++con_k == K)\n        finish(CORRECT, \"\");\n}\n```", "locale": "zh-CN"}}}
{"pid": "P3488", "type": "P", "difficulty": 6, "samples": [["4 4 2 1\n1 3\n2 3\n3 3\n2 -1\n", "TAK\nTAK\nNIE\nTAK\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "线段树", "POI（波兰）"], "title": "[POI 2009] LYZ-Ice Skates", "background": "", "description": "Byteasar runs a skate club. Its members meet on a regular basis and train    together, and they always use the club's ice-skates. The skate sizes are    (by convention) numbered from ![](http://main.edu.pl/images/OI16/lyz-en-tex.1.png) to ![](http://main.edu.pl/images/OI16/lyz-en-tex.2.png). Naturally, each club member has    some foot size, but that is not all to it! Skaters have skate size tolerance    factor ![](http://main.edu.pl/images/OI16/lyz-en-tex.3.png): a skater with foot size ![](http://main.edu.pl/images/OI16/lyz-en-tex.4.png) can wear skates with    sizes from ![](http://main.edu.pl/images/OI16/lyz-en-tex.5.png) up to ![](http://main.edu.pl/images/OI16/lyz-en-tex.6.png). It should be noted, though, that    no skater ever wears two skates of different size simultaneously.\n\nTo supply the club, Byteasar bought ![](http://main.edu.pl/images/OI16/lyz-en-tex.7.png) pairs of ice-skates of each size,    i.e. from ![](http://main.edu.pl/images/OI16/lyz-en-tex.8.png) to ![](http://main.edu.pl/images/OI16/lyz-en-tex.9.png). As time passes, some people join the club, just as    some established members leave it. Byteasar worries if he will have enough    skates of appropriate size for every member at each training.\n\nWe assume that initially the club has no members at all. Byteasar will give    you a sequence of ![](http://main.edu.pl/images/OI16/lyz-en-tex.10.png) events of the following form: ![](http://main.edu.pl/images/OI16/lyz-en-tex.11.png) (new) members with    foot size ![](http://main.edu.pl/images/OI16/lyz-en-tex.12.png) have joined/left the club. Right after each such event    Byteasar wants to know whether he has enough skates of appropriate size for    every club member. He asks you to write a programme that will check it for    him.\n", "inputFormat": "The first line of the standard input contains four integers ![](http://main.edu.pl/images/OI16/lyz-en-tex.13.png), ![](http://main.edu.pl/images/OI16/lyz-en-tex.14.png),      ![](http://main.edu.pl/images/OI16/lyz-en-tex.15.png) and ![](http://main.edu.pl/images/OI16/lyz-en-tex.16.png) (![](http://main.edu.pl/images/OI16/lyz-en-tex.17.png), ![](http://main.edu.pl/images/OI16/lyz-en-tex.18.png),      ![](http://main.edu.pl/images/OI16/lyz-en-tex.19.png), ![](http://main.edu.pl/images/OI16/lyz-en-tex.20.png)), separated by single spaces, that      denote, respectively: maximum skate size, number of events, number of      skate pairs of each size Byteasar initially bought, and the skate size      tolerance factor. The following ![](http://main.edu.pl/images/OI16/lyz-en-tex.21.png) lines contain the sequence of ![](http://main.edu.pl/images/OI16/lyz-en-tex.22.png)      events, one per line. The ![](http://main.edu.pl/images/OI16/lyz-en-tex.23.png)-th line (for ![](http://main.edu.pl…\n", "outputFormat": "Your programme should print out ![](http://main.edu.pl/images/OI16/lyz-en-tex.35.png) lines to the standard output.\n\nThe ![](http://main.edu.pl/images/OI16/lyz-en-tex.36.png)-th line (for ![](http://main.edu.pl/images/OI16/lyz-en-tex.37.png)) should either contain the word      TAK (Polish for yes), or the word NIE (Polish for      no), depending on whether Byteasar has the skates of appropriate      size for every club member right after the ![](http://main.edu.pl/images/OI16/lyz-en-tex.38.png)-th event.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] LYZ-Ice Skates", "background": "", "description": "Byteasar runs a skate club. Its members meet on a regular basis and train    together, and they always use the club's ice-skates. The skate sizes are    (by convention) numbered from ![](http://main.edu.pl/images/OI16/lyz-en-tex.1.png) to ![](http://main.edu.pl/images/OI16/lyz-en-tex.2.png). Naturally, each club member has    some foot size, but that is not all to it! Skaters have skate size tolerance    factor ![](http://main.edu.pl/images/OI16/lyz-en-tex.3.png): a skater with foot size ![](http://main.edu.pl/images/OI16/lyz-en-tex.4.png) can wear skates with    sizes from ![](http://main.edu.pl/images/OI16/lyz-en-tex.5.png) up to ![](http://main.edu.pl/images/OI16/lyz-en-tex.6.png). It should be noted, though, that    no skater ever wears two skates of different size simultaneously.\n\nTo supply the club, Byteasar bought ![](http://main.edu.pl/images/OI16/lyz-en-tex.7.png) pairs of ice-skates of each size,    i.e. from ![](http://main.edu.pl/images/OI16/lyz-en-tex.8.png) to ![](http://main.edu.pl/images/OI16/lyz-en-tex.9.png). As time passes, some people join the club, just as    some established members leave it. Byteasar worries if he will have enough    skates of appropriate size for every member at each training.\n\nWe assume that initially the club has no members at all. Byteasar will give    you a sequence of ![](http://main.edu.pl/images/OI16/lyz-en-tex.10.png) events of the following form: ![](http://main.edu.pl/images/OI16/lyz-en-tex.11.png) (new) members with    foot size ![](http://main.edu.pl/images/OI16/lyz-en-tex.12.png) have joined/left the club. Right after each such event    Byteasar wants to know whether he has enough skates of appropriate size for    every club member. He asks you to write a programme that will check it for    him.\n", "inputFormat": "The first line of the standard input contains four integers ![](http://main.edu.pl/images/OI16/lyz-en-tex.13.png), ![](http://main.edu.pl/images/OI16/lyz-en-tex.14.png),      ![](http://main.edu.pl/images/OI16/lyz-en-tex.15.png) and ![](http://main.edu.pl/images/OI16/lyz-en-tex.16.png) (![](http://main.edu.pl/images/OI16/lyz-en-tex.17.png), ![](http://main.edu.pl/images/OI16/lyz-en-tex.18.png),      ![](http://main.edu.pl/images/OI16/lyz-en-tex.19.png), ![](http://main.edu.pl/images/OI16/lyz-en-tex.20.png)), separated by single spaces, that      denote, respectively: maximum skate size, number of events, number of      skate pairs of each size Byteasar initially bought, and the skate size      tolerance factor. The following ![](http://main.edu.pl/images/OI16/lyz-en-tex.21.png) lines contain the sequence of ![](http://main.edu.pl/images/OI16/lyz-en-tex.22.png)      events, one per line. The ![](http://main.edu.pl/images/OI16/lyz-en-tex.23.png)-th line (for ![](http://main.edu.pl…\n", "outputFormat": "Your programme should print out ![](http://main.edu.pl/images/OI16/lyz-en-tex.35.png) lines to the standard output.\n\nThe ![](http://main.edu.pl/images/OI16/lyz-en-tex.36.png)-th line (for ![](http://main.edu.pl/images/OI16/lyz-en-tex.37.png)) should either contain the word      TAK (Polish for yes), or the word NIE (Polish for      no), depending on whether Byteasar has the skates of appropriate      size for every club member right after the ![](http://main.edu.pl/images/OI16/lyz-en-tex.38.png)-th event.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] LYZ-Ice Skates", "background": "", "description": "滑冰俱乐部初始有 $[1,n]$ 号码溜冰鞋各 $k$ 双，已知 $x$ 号脚的人可以穿 $[x,x+d]$ 号码的鞋子。\n\n现在有 $m$ 次操作，每次两个数 $r,x$，表示来了 $x$ 个 $r$ 号脚的人，$x$ 为负则表示离开。在每次操作之后，你需要判断溜冰鞋是否足够。", "inputFormat": "第一行 $4$ 个整数 $n,m,k,d$。\n\n接下来 $m$ 行，每行两个整数 $r_i,x_i$，代表一次操作。", "outputFormat": "$m$ 行，每行一个字符串，若此次操作后满足题意则输出 `TAK`，否则输出 `NIE`。", "hint": "$n\\le 2\\times 10^5,m\\le 5\\times 10^5,k\\le 10^9,1\\le r_i\\le n-d,-10^9\\le x_i\\le 10^9,0\\le d<n$", "locale": "zh-CN"}}}
{"pid": "P3489", "type": "P", "difficulty": 5, "samples": [["6 7 4 2\n2 1 2\n3 2 1 3\n1 2 2 0\n2 3 9 0\n1 4 2 1 2\n2 5 3 0\n4 5 5 2 2 3\n4 6 18 0\n5 6 3 2 1 2\n", "24\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "POI（波兰）", "最短路"], "title": "[POI 2009] WIE-Hexer", "background": "", "description": "Byteasar has become a hexer - a conqueror of monsters.\n\nCurrently he is to return to his hometown Byteburg. The way home, alas, leads through a land full of beasts. Fortunately the habitants, forced to fight the monsters for centuries, have mastered the art of blacksmithery - they are now capable of making special swords that are very efficient against the beasts.\n\nThe land Byteasar wanders through is quite vast: many towns lie there, and many roads connect them.\n\nThese roads do not cross outside the towns (mostly because some of them are underground passages).\n\nByteasar has gathered all practical information about the land (all hexers like to know these things).\n\nHe knows what kind of monsters he may come across each of the roads and how much time he needs to walk it down.\n\nHe also knows in which villages there are blacksmiths and against what kinds of monsters the swords that they make work.\n\nByteasar wants to get back to Byteburg as soon as possible.\n\nAs a hexer he is quite ashamed that he does not know the best route, and that he has no sword on him at the moment.\n\nHelp him find the shortest path to Byteburg such that whenever he could meet some king of monster, previously he would have a chance to get an appropriate sword to fight the beast.\n\nYou need not worry about the number or weight of the swords - every hexer is as strong as an ox, so he can carry (virtually) unlimited number of equipment, swords in particular.\n", "inputFormat": "The first line of the standard input holds four integers: $n,m,p,k$ ($1\\le n\\le 200,0\\le m\\le 3000,1\\le p\\le 13,0\\le k\\le n$),separated by single spaces, that denote respectively:\n\nthe number of towns, the number of roads connecting them,the number of different kinds of monsters and the number of blacksmiths.\n\nThe towns are numbered from $1$ to $n$ in such a way that $n$ is Byteburg's number and $1$ is the number of the village which Byteasar starts in. The monster kinds are numbered from $1$ to $p$.\n\nIn the following $k$ lines the profiles of successive blacksmiths are given,one per line. The $(i+1)$-st line holds the integers $w_i,q_i,r_{i,1}<r_{i,2}<...<r_{i,q_i}$($1\\le w_i\\le n,1\\le q_i\\le p,1\\le r_{i,j}\\le p$),separated by single spaces, that denote respectively: the number of town in which the blacksmith lives, the number of different kinds of monsters against which his swords are efficient, and the kinds of monsters themselves (in increasing order). Note that a town may have more than one blacksmith.\n\nThen $m$ lines with roads' descriptions follow.The $(k+i+1)$-th line holds the integers$v_i,w_i,t_i,s_i,u_{i,1}<u_{i,2}<...<u_{i,s_i}$($1\\le v_i<w_i\\le n,1\\le t_i\\le 500,0\\le s_i\\le p,1\\le u_{i,j}\\le p$)separated by single spaces, that denote respectively: the towns that the road connects, the time needed to walk down the road (same in both directions), the number of different kinds of monsters that may appear on that road, and finally the kinds of monsters themselves (in increasing order). No two roads connect the same pair of towns.\n", "outputFormat": "Your programme is to print out one integer to the standard output -  the minimum summary time required to reach Byteburg.\n\nShould reaching Byteburg be impossible, the number should be $-1$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] WIE-Hexer", "background": "", "description": "Byteasar has become a hexer - a conqueror of monsters.\n\nCurrently he is to return to his hometown Byteburg. The way home, alas, leads through a land full of beasts. Fortunately the habitants, forced to fight the monsters for centuries, have mastered the art of blacksmithery - they are now capable of making special swords that are very efficient against the beasts.\n\nThe land Byteasar wanders through is quite vast: many towns lie there, and many roads connect them.\n\nThese roads do not cross outside the towns (mostly because some of them are underground passages).\n\nByteasar has gathered all practical information about the land (all hexers like to know these things).\n\nHe knows what kind of monsters he may come across each of the roads and how much time he needs to walk it down.\n\nHe also knows in which villages there are blacksmiths and against what kinds of monsters the swords that they make work.\n\nByteasar wants to get back to Byteburg as soon as possible.\n\nAs a hexer he is quite ashamed that he does not know the best route, and that he has no sword on him at the moment.\n\nHelp him find the shortest path to Byteburg such that whenever he could meet some king of monster, previously he would have a chance to get an appropriate sword to fight the beast.\n\nYou need not worry about the number or weight of the swords - every hexer is as strong as an ox, so he can carry (virtually) unlimited number of equipment, swords in particular.\n", "inputFormat": "The first line of the standard input holds four integers: $n,m,p,k$ ($1\\le n\\le 200,0\\le m\\le 3000,1\\le p\\le 13,0\\le k\\le n$),separated by single spaces, that denote respectively:\n\nthe number of towns, the number of roads connecting them,the number of different kinds of monsters and the number of blacksmiths.\n\nThe towns are numbered from $1$ to $n$ in such a way that $n$ is Byteburg's number and $1$ is the number of the village which Byteasar starts in. The monster kinds are numbered from $1$ to $p$.\n\nIn the following $k$ lines the profiles of successive blacksmiths are given,one per line. The $(i+1)$-st line holds the integers $w_i,q_i,r_{i,1}<r_{i,2}<...<r_{i,q_i}$($1\\le w_i\\le n,1\\le q_i\\le p,1\\le r_{i,j}\\le p$),separated by single spaces, that denote respectively: the number of town in which the blacksmith lives, the number of different kinds of monsters against which his swords are efficient, and the kinds of monsters themselves (in increasing order). Note that a town may have more than one blacksmith.\n\nThen $m$ lines with roads' descriptions follow.The $(k+i+1)$-th line holds the integers$v_i,w_i,t_i,s_i,u_{i,1}<u_{i,2}<...<u_{i,s_i}$($1\\le v_i<w_i\\le n,1\\le t_i\\le 500,0\\le s_i\\le p,1\\le u_{i,j}\\le p$)separated by single spaces, that denote respectively: the towns that the road connects, the time needed to walk down the road (same in both directions), the number of different kinds of monsters that may appear on that road, and finally the kinds of monsters themselves (in increasing order). No two roads connect the same pair of towns.\n", "outputFormat": "Your programme is to print out one integer to the standard output -  the minimum summary time required to reach Byteburg.\n\nShould reaching Byteburg be impossible, the number should be $-1$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] WIE-Hexer", "background": "", "description": "Byteasar 成为了一名猎魔人——一个征服怪物的人。\n\n目前他要返回他的家乡 Byteburg。可惜回家的路要经过一个充满野兽的土地。幸运的是，当地居民被迫与怪物斗争了几个世纪，已经掌握了锻造的艺术——他们现在能够制造出对抗野兽非常有效的特殊剑。\n\nByteasar 所经过的土地相当广阔：那里有许多城镇，许多道路连接着它们。\n\n这些道路不会在城镇外交叉（主要是因为其中一些是地下通道）。\n\nByteasar 已经收集了关于这片土地的所有实用信息（所有猎魔人都喜欢知道这些事情）。\n\n他知道在每条路上可能遇到的怪物种类，以及他需要多少时间才能走完这条路。\n\n他还知道在哪些村庄有铁匠，以及他们制作的剑对哪些种类的怪物有效。\n\nByteasar 想尽快回到 Byteburg。\n\n作为一个猎魔人，他对自己不知道最佳路线感到相当羞愧，而且他目前身上没有剑。\n\n帮助他找到到 Byteburg 的最短路径，以便每当他可能遇到某种怪物时，他之前就有机会获得一把合适的剑来对抗野兽。\n\n你不需要担心剑的数量或重量——每个猎魔人都像牛一样强壮，所以他可以携带（几乎）无限数量的装备，特别是剑。", "inputFormat": "标准输入的第一行包含四个整数：$n,m,p,k$ ($1\\le n\\le 200,0\\le m\\le 3000,1\\le p\\le 13,0\\le k\\le n$)，它们分别表示：\n\n城镇的数量，连接它们的道路数量，不同种类的怪物数量和铁匠的数量。\n\n城镇从 $1$ 到 $n$ 编号，其中 $n$ 是 Byteburg 的编号，$1$ 是 Byteasar 开始的村庄编号。怪物种类从 $1$ 到 $p$ 编号。\n\n接下来的 $k$ 行给出了连续铁匠的资料，每行一个。第 $(i+1)$ 行包含整数 $w_i,q_i,r_{i,1}<r_{i,2}<...<r_{i,q_i}$ ($1\\le w_i\\le n,1\\le q_i\\le p,1\\le r_{i,j}\\le p$)，它们分别表示：铁匠所在的城镇编号，他的剑对抗的不同种类怪物的数量，以及怪物种类本身（按升序排列）。注意，一个城镇可能有多个铁匠。\n\n然后是 $m$ 行道路的描述。第 $(k+i+1)$ 行包含整数 $v_i,w_i,t_i,s_i,u_{i,1}<u_{i,2}<...<u_{i,s_i}$ ($1\\le v_i<w_i\\le n,1\\le t_i\\le 500,0\\le s_i\\le p,1\\le u_{i,j}\\le p$)，它们分别表示：道路连接的城镇，走完这条路所需的时间（两个方向相同），这条路上可能出现的不同种类怪物的数量，最后是怪物种类本身（按升序排列）。没有两条道路连接同一对城镇。", "outputFormat": "你的程序应输出一个整数到标准输出——到达 Byteburg 所需的最短总时间。\n\n如果无法到达 Byteburg，则该数字应为 $-1$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3490", "type": "P", "difficulty": 0, "samples": [["2\n1 2\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2009", "POI（波兰）"], "title": "[POI 2009] FIB-Words 2", "background": "", "description": "The following task is a significantly harder version of task Words from the third stage of 16th Polish OI. It wasn't used in the contest itself, but is an extension for those who solved \"Words\" and want more. :-)    Let ![](http://main.edu.pl/images/OI16/fib-en-tex.1.png) be a function acting on strings composed of the digits 0    and 1.\n\nThe function ![](http://main.edu.pl/images/OI16/fib-en-tex.2.png) transforms the string ![](http://main.edu.pl/images/OI16/fib-en-tex.3.png) by replacing (independently    and concurrently) every digit 0 with 1 and every digit    1 with the string ![](http://main.edu.pl/images/OI16/fib-en-tex.4.png).\n\nFor example ![](http://main.edu.pl/images/OI16/fib-en-tex.5.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.6.png)    (i.e. ![](http://main.edu.pl/images/OI16/fib-en-tex.7.png) assigns an empty string to the empty string).\n\nNote that ![](http://main.edu.pl/images/OI16/fib-en-tex.8.png) is an injection, or a one-to-one function.\n\nBy ![](http://main.edu.pl/images/OI16/fib-en-tex.9.png) we denote the function ![](http://main.edu.pl/images/OI16/fib-en-tex.10.png) composed with itself ![](http://main.edu.pl/images/OI16/fib-en-tex.11.png) times.\n\nIn particular, ![](http://main.edu.pl/images/OI16/fib-en-tex.12.png) is the identity function ![](http://main.edu.pl/images/OI16/fib-en-tex.13.png).\n\nWe are interested in the strings of the form ![](http://main.edu.pl/images/OI16/fib-en-tex.14.png)    for ![](http://main.edu.pl/images/OI16/fib-en-tex.15.png) This sequence begins with the following strings:\n\n![](http://main.edu.pl/images/OI16/fib-en-tex.16.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.17.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.18.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.19.png),    ![](http://main.edu.pl/images/OI16/fib-en-tex.20.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.21.png).\n\nWe call the string ![](http://main.edu.pl/images/OI16/fib-en-tex.22.png) a substring of the string ![](http://main.edu.pl/images/OI16/fib-en-tex.23.png) if it occurs    in ![](http://main.edu.pl/images/OI16/fib-en-tex.24.png) as  a contiguous (i.e. one-block) subsequence.\n\nA sequence of integers ![](http://main.edu.pl/images/OI16/fib-en-tex.25.png) is given.\n\nYour task is to check whether a string of the form    ![](http://main.edu.pl/images/OI16/fib-en-tex.26.png)    is a substring of ![](http://main.edu.pl/images/OI16/fib-en-tex.27.png) for some ![](http://main.edu.pl/images/OI16/fib-en-tex.28.png), and if it is,    you shuold find minimal such ![](http://main.edu.pl/images/OI16/fib-en-tex.29.png).\n", "inputFormat": "The first line of the standard input contains a single integer ![](http://main.edu.pl/images/OI16/fib-en-tex.30.png),      ![](http://main.edu.pl/images/OI16/fib-en-tex.31.png).\n\nThe second line of standard input holds ![](http://main.edu.pl/images/OI16/fib-en-tex.32.png) non-negative integers      ![](http://main.edu.pl/images/OI16/fib-en-tex.33.png)(![](http://main.edu.pl/images/OI16/fib-en-tex.34.png)), separated by single spaces.\n", "outputFormat": "Your programme should print out ![](http://main.edu.pl/images/OI16/fib-en-tex.35.png) lines to the standard output,     one for each test unit.\n\nYour programm should print to standard output minimal non-negative integer ![](http://main.edu.pl/images/OI16/fib-en-tex.36.png),     such that ![](http://main.edu.pl/images/OI16/fib-en-tex.37.png) is a substring of      ![](http://main.edu.pl/images/OI16/fib-en-tex.38.png), or NIE (no in Polish) if such ![](http://main.edu.pl/images/OI16/fib-en-tex.39.png) doesn't exist.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] FIB-Words 2", "background": "", "description": "The following task is a significantly harder version of task Words from the third stage of 16th Polish OI. It wasn't used in the contest itself, but is an extension for those who solved \"Words\" and want more. :-)    Let ![](http://main.edu.pl/images/OI16/fib-en-tex.1.png) be a function acting on strings composed of the digits 0    and 1.\n\nThe function ![](http://main.edu.pl/images/OI16/fib-en-tex.2.png) transforms the string ![](http://main.edu.pl/images/OI16/fib-en-tex.3.png) by replacing (independently    and concurrently) every digit 0 with 1 and every digit    1 with the string ![](http://main.edu.pl/images/OI16/fib-en-tex.4.png).\n\nFor example ![](http://main.edu.pl/images/OI16/fib-en-tex.5.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.6.png)    (i.e. ![](http://main.edu.pl/images/OI16/fib-en-tex.7.png) assigns an empty string to the empty string).\n\nNote that ![](http://main.edu.pl/images/OI16/fib-en-tex.8.png) is an injection, or a one-to-one function.\n\nBy ![](http://main.edu.pl/images/OI16/fib-en-tex.9.png) we denote the function ![](http://main.edu.pl/images/OI16/fib-en-tex.10.png) composed with itself ![](http://main.edu.pl/images/OI16/fib-en-tex.11.png) times.\n\nIn particular, ![](http://main.edu.pl/images/OI16/fib-en-tex.12.png) is the identity function ![](http://main.edu.pl/images/OI16/fib-en-tex.13.png).\n\nWe are interested in the strings of the form ![](http://main.edu.pl/images/OI16/fib-en-tex.14.png)    for ![](http://main.edu.pl/images/OI16/fib-en-tex.15.png) This sequence begins with the following strings:\n\n![](http://main.edu.pl/images/OI16/fib-en-tex.16.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.17.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.18.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.19.png),    ![](http://main.edu.pl/images/OI16/fib-en-tex.20.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.21.png).\n\nWe call the string ![](http://main.edu.pl/images/OI16/fib-en-tex.22.png) a substring of the string ![](http://main.edu.pl/images/OI16/fib-en-tex.23.png) if it occurs    in ![](http://main.edu.pl/images/OI16/fib-en-tex.24.png) as  a contiguous (i.e. one-block) subsequence.\n\nA sequence of integers ![](http://main.edu.pl/images/OI16/fib-en-tex.25.png) is given.\n\nYour task is to check whether a string of the form    ![](http://main.edu.pl/images/OI16/fib-en-tex.26.png)    is a substring of ![](http://main.edu.pl/images/OI16/fib-en-tex.27.png) for some ![](http://main.edu.pl/images/OI16/fib-en-tex.28.png), and if it is,    you shuold find minimal such ![](http://main.edu.pl/images/OI16/fib-en-tex.29.png).\n", "inputFormat": "The first line of the standard input contains a single integer ![](http://main.edu.pl/images/OI16/fib-en-tex.30.png),      ![](http://main.edu.pl/images/OI16/fib-en-tex.31.png).\n\nThe second line of standard input holds ![](http://main.edu.pl/images/OI16/fib-en-tex.32.png) non-negative integers      ![](http://main.edu.pl/images/OI16/fib-en-tex.33.png)(![](http://main.edu.pl/images/OI16/fib-en-tex.34.png)), separated by single spaces.\n", "outputFormat": "Your programme should print out ![](http://main.edu.pl/images/OI16/fib-en-tex.35.png) lines to the standard output,     one for each test unit.\n\nYour programm should print to standard output minimal non-negative integer ![](http://main.edu.pl/images/OI16/fib-en-tex.36.png),     such that ![](http://main.edu.pl/images/OI16/fib-en-tex.37.png) is a substring of      ![](http://main.edu.pl/images/OI16/fib-en-tex.38.png), or NIE (no in Polish) if such ![](http://main.edu.pl/images/OI16/fib-en-tex.39.png) doesn't exist.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] FIB-Words 2", "background": "", "description": "以下任务是第 16 届波兰信息学奥林匹克第三阶段任务“Words”的一个显著更难的版本。它并未在比赛中使用，而是为那些解决了“Words”并想要更多挑战的人提供的扩展。令 $f$ 是一个作用于由数字 0 和 1 组成的字符串的函数。\n\n函数 $f$ 将字符串 $s$ 转换为通过独立且同时地将每个数字 0 替换为 1，并将每个数字 1 替换为字符串 $10$。\n\n例如，$f(0) = 1$，$f(1) = 10$（即 $f$ 将空字符串映射为空字符串）。\n\n注意，$f$ 是一个单射，即一对一函数。\n\n我们用 $f^n$ 表示函数 $f$ 自身复合 $n$ 次。\n\n特别地，$f^0$ 是恒等函数 $id$。\n\n我们对形如 $f^n(0)$ 的字符串感兴趣，其中 $n \\geq 0$。这个序列以以下字符串开始：\n\n$f^0(0) = 0$，$f^1(0) = 1$，$f^2(0) = 10$，$f^3(0) = 101$，$f^4(0) = 10110$，$f^5(0) = 10110101$。\n\n如果字符串 $u$ 作为一个连续（即单块）子序列出现在字符串 $v$ 中，我们称字符串 $u$ 是字符串 $v$ 的子串。\n\n给定一个整数序列 $a_1, a_2, \\ldots, a_k$。\n\n你的任务是检查形如 $f^{a_i}(0)$ 的字符串是否是 $f^n(0)$ 的子串，对于某个 $n \\geq 0$，如果是，你需要找到最小的这样的 $n$。", "inputFormat": "标准输入的第一行包含一个整数 $k$，$1 \\leq k \\leq 1000$。\n\n标准输入的第二行包含 $k$ 个非负整数 $a_1, a_2, \\ldots, a_k$（$0 \\leq a_i \\leq 10^9$），以单个空格分隔。", "outputFormat": "你的程序应输出 $k$ 行到标准输出，每个测试单元一行。\n\n你的程序应输出最小的非负整数 $n$，使得 $f^{a_i}(0)$ 是 $f^n(0)$ 的子串，或者如果这样的 $n$ 不存在，则输出 NIE（波兰语中的“否”）。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
