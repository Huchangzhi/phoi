{"pid": "P12691", "type": "P", "difficulty": 5, "samples": [["6\n2 6 1 3\n4 1 4 6\n6 5 4 6\n1 3 2 5\n3 2 1 3\n5 4 1 6\n", "YES\n3 4 6 2 1 5"], ["2\n1 1 2 2\n2 2 1 1", "NO"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "树状数组", "2022", "Special Judge", "KOI（韩国）"], "title": "[KOI 2022 Round 1] 补给", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "在一个二维平面上有 $N$ 个军事基地。第 $i$ 个基地的位置是坐标 $(X_i, Y_i)$。\n\n负责该区域的补给部队打算对所有基地进行补给。每个第 $i$ 个基地可以接受补给的日期是从第 $A_i$ 天到第 $B_i$ 天之间的某一天。\n\n由于正处于战争时期，补给部队必须保持整体从左上方向右下方推进的队形，因此只能朝右上方向前进。因此，必须为每个基地分配一个具体的补给日期 $V_i$，使得满足以下所有条件：\n\n- 对所有的 $i$，都满足 $A_i \\leq V_i \\leq B_i$；\n- 对所有 $i, j$ 满足 $X_i < X_j$ 且 $Y_i < Y_j$ 时，必须满足 $V_i < V_j$；\n- 对所有 $i \\ne j$，必须有 $V_i \\ne V_j$。\n\n给定各个基地的位置 $(X_i, Y_i)$ 以及它们可接受补给的日期范围 $[A_i, B_i]$，请编写一个程序判断是否存在一种补给日期的分配方案，满足上述所有条件。如果存在，输出 YES，并按基地编号顺序输出每个基地的分配日期；如果不存在，输出 NO。\n\n下图展示了一个包含 6 个基地的示例情况。图中的每个点代表一个基地，点的右上方标注了该基地可以接受补给的日期范围。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/phg5424h.png)\n\n下图还展示了为这些基地安排补给日期的一个可行方案，点的右下方标注了分配给每个基地的具体补给日期。图中弯曲的线表示补给部队在第 2 天至第 3 天之间可能处于的位置范围。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4uzfezse.png)", "inputFormat": "第一行输入一个整数 $N$，表示基地的数量。\n\n接下来 $N$ 行，每行输入四个整数 $X_i$, $Y_i$, $A_i$, $B_i$，以空格分隔，表示第 $i$ 个基地的位置和其可接受补给的日期范围。", "outputFormat": "如果存在合法的补给方案，第一行输出 `YES`，第二行输出 $N$ 个整数，表示按基地编号顺序分配的补给日期，数与数之间以空格分隔。\n\n如果不存在合法的补给方案，输出 `NO`。", "hint": "**约束条件**\n\n- 所有给定的数都是整数。\n- $1 \\leq N \\leq 250\\,000$\n- $1 \\leq A_i \\leq B_i \\leq N$\n- $1 \\leq X_i \\leq N$\n- $1 \\leq Y_i \\leq N$\n- 所有 $X_i$ 互不相同，即 $i \\ne j$ 时 $X_i \\ne X_j$\n- 所有 $Y_i$ 互不相同，即 $i \\ne j$ 时 $Y_i \\ne Y_j$\n\n**子任务**\n\n1. （13 分）$N \\leq 10$\n2. （18 分）$N \\leq 2\\,500$\n3. （22 分）对所有 $i$，满足 $B_i = N$\n4. （47 分）无附加限制", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2022 Round 1] 补给", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "在一个二维平面上有 $N$ 个军事基地。第 $i$ 个基地的位置是坐标 $(X_i, Y_i)$。\n\n负责该区域的补给部队打算对所有基地进行补给。每个第 $i$ 个基地可以接受补给的日期是从第 $A_i$ 天到第 $B_i$ 天之间的某一天。\n\n由于正处于战争时期，补给部队必须保持整体从左上方向右下方推进的队形，因此只能朝右上方向前进。因此，必须为每个基地分配一个具体的补给日期 $V_i$，使得满足以下所有条件：\n\n- 对所有的 $i$，都满足 $A_i \\leq V_i \\leq B_i$；\n- 对所有 $i, j$ 满足 $X_i < X_j$ 且 $Y_i < Y_j$ 时，必须满足 $V_i < V_j$；\n- 对所有 $i \\ne j$，必须有 $V_i \\ne V_j$。\n\n给定各个基地的位置 $(X_i, Y_i)$ 以及它们可接受补给的日期范围 $[A_i, B_i]$，请编写一个程序判断是否存在一种补给日期的分配方案，满足上述所有条件。如果存在，输出 YES，并按基地编号顺序输出每个基地的分配日期；如果不存在，输出 NO。\n\n下图展示了一个包含 6 个基地的示例情况。图中的每个点代表一个基地，点的右上方标注了该基地可以接受补给的日期范围。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/phg5424h.png)\n\n下图还展示了为这些基地安排补给日期的一个可行方案，点的右下方标注了分配给每个基地的具体补给日期。图中弯曲的线表示补给部队在第 2 天至第 3 天之间可能处于的位置范围。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4uzfezse.png)", "inputFormat": "第一行输入一个整数 $N$，表示基地的数量。\n\n接下来 $N$ 行，每行输入四个整数 $X_i$, $Y_i$, $A_i$, $B_i$，以空格分隔，表示第 $i$ 个基地的位置和其可接受补给的日期范围。", "outputFormat": "如果存在合法的补给方案，第一行输出 `YES`，第二行输出 $N$ 个整数，表示按基地编号顺序分配的补给日期，数与数之间以空格分隔。\n\n如果不存在合法的补给方案，输出 `NO`。", "hint": "**约束条件**\n\n- 所有给定的数都是整数。\n- $1 \\leq N \\leq 250\\,000$\n- $1 \\leq A_i \\leq B_i \\leq N$\n- $1 \\leq X_i \\leq N$\n- $1 \\leq Y_i \\leq N$\n- 所有 $X_i$ 互不相同，即 $i \\ne j$ 时 $X_i \\ne X_j$\n- 所有 $Y_i$ 互不相同，即 $i \\ne j$ 时 $Y_i \\ne Y_j$\n\n**子任务**\n\n1. （13 分）$N \\leq 10$\n2. （18 分）$N \\leq 2\\,500$\n3. （22 分）对所有 $i$，满足 $B_i = N$\n4. （47 分）无附加限制", "locale": "zh-CN"}}}
{"pid": "P12692", "type": "P", "difficulty": 6, "samples": [["5 10 \n1 2 1 \n1 3 2 \n2 4 3 \n2 5 4", "7 \n7 \n6 \n5 \n4 \n4 \n3 \n3 \n2 \n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": [], "title": "BZOJ3784 树上的路径", "background": "", "description": "给定一个 $n$ 个结点的树，结点用正整数 $1 \\sim n$ 编号。每条边有一个正整数权值。用 $d(a, b)$ 表示从结点 $a$ 到结点 $b$ 路边上经过边的权值。其中要求 $a < b$。将这 $\\frac{n \\times (n-1)}{2}$ 个距离从大到小排序，输出前 $m$ 个距离值。", "inputFormat": "第一行两个正整数 $n, m$。\n\n下面 $n-1$ 行，每行三个正整数 $a, b, c$ 表示结点 $a$ 到结点 $b$ 有一条权值为 $c$ 的边。\n", "outputFormat": "共 $m$ 行，如题所述。", "hint": "对于 $100\\%$ 的数据，$n \\leq 5 \\times 10^4$，$m \\leq \\min(3 \\times 10^5, \\frac{n \\times (n-1)}{2})$，$a, b \\leq n$，$C \\leq 10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ3784 树上的路径", "background": "", "description": "给定一个 $n$ 个结点的树，结点用正整数 $1 \\sim n$ 编号。每条边有一个正整数权值。用 $d(a, b)$ 表示从结点 $a$ 到结点 $b$ 路边上经过边的权值。其中要求 $a < b$。将这 $\\frac{n \\times (n-1)}{2}$ 个距离从大到小排序，输出前 $m$ 个距离值。", "inputFormat": "第一行两个正整数 $n, m$。\n\n下面 $n-1$ 行，每行三个正整数 $a, b, c$ 表示结点 $a$ 到结点 $b$ 有一条权值为 $c$ 的边。\n", "outputFormat": "共 $m$ 行，如题所述。", "hint": "对于 $100\\%$ 的数据，$n \\leq 5 \\times 10^4$，$m \\leq \\min(3 \\times 10^5, \\frac{n \\times (n-1)}{2})$，$a, b \\leq n$，$C \\leq 10^4$。", "locale": "zh-CN"}}}
{"pid": "P12693", "type": "P", "difficulty": 5, "samples": [["5\n1 2\n2 3\n2 4\n1 5\n3\n0 1 1\n0 2 3\n1 2 3 1 1 4", "13"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "树链剖分"], "title": "BZOJ3589 动态树", "background": "", "description": "别忘了这是一棵动态树，每时每刻都是动态的。\n\n小明要求你在这棵树上维护两种事件：\n\n- 事件 0：这棵树长出了一些果子，即某个子树中的每个节点都会长出 $k$ 个果子。\n- 事件 1：小明希望你求出几条树枝上的果子数。一条树枝其实就是一个从某个节点到根的路径的一段。\n\n每次小明会选定一些树枝，让你求出在这些树枝上的节点的果子数的和。注意，树枝之间可能会重合，这时重合的部分的节点的果子只要算一次。", "inputFormat": "第一行一个整数 $n$，即节点数。\n\n接下来 $n - 1$ 行，每行两个数字 $u, v$。表示果子 $u$ 和果子 $v$ 之间有一条直接的边。节点从 $1$ 开始编号。\n\n再接下来一个整数 $Q$，表示事件。\n\n最后 $Q$ 行，每行开头要么是 $0$，要么是 $1$。\n\n如果是 $0$，表示这个事件是事件 $0$。这行接下来的 $2$ 个整数 $u, delta$ 表示以 $u$ 为根的子树中的每个节点长出了 $delta$ 个果子。\n\n如果是 $1$，表示这个事件是事件 $1$。这行接下来一个整数 $k$，表示这次询问涉及 $k$ 个树枝。接下来 $k$ 对整数 $u_k, v_k$，每个树枝从节点 $u_k$ 到节点 $v_k$。由于果子数可能非常多，请输出这个数模 $2^{31}$ 的结果。", "outputFormat": "对于每个事件 $1$，输出询问的果子数。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 2 \\times 10^5$，$1 \\leq Q \\leq 2 \\times 10^5$，$k = 5$。\n\n生成每个树枝的过程是这样的：先在树中随机找一个节点，然后在这个节点到根的路径上随机选一个节点，这两个节点就作为树枝的两端。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ3589 动态树", "background": "", "description": "别忘了这是一棵动态树，每时每刻都是动态的。\n\n小明要求你在这棵树上维护两种事件：\n\n- 事件 0：这棵树长出了一些果子，即某个子树中的每个节点都会长出 $k$ 个果子。\n- 事件 1：小明希望你求出几条树枝上的果子数。一条树枝其实就是一个从某个节点到根的路径的一段。\n\n每次小明会选定一些树枝，让你求出在这些树枝上的节点的果子数的和。注意，树枝之间可能会重合，这时重合的部分的节点的果子只要算一次。", "inputFormat": "第一行一个整数 $n$，即节点数。\n\n接下来 $n - 1$ 行，每行两个数字 $u, v$。表示果子 $u$ 和果子 $v$ 之间有一条直接的边。节点从 $1$ 开始编号。\n\n再接下来一个整数 $Q$，表示事件。\n\n最后 $Q$ 行，每行开头要么是 $0$，要么是 $1$。\n\n如果是 $0$，表示这个事件是事件 $0$。这行接下来的 $2$ 个整数 $u, delta$ 表示以 $u$ 为根的子树中的每个节点长出了 $delta$ 个果子。\n\n如果是 $1$，表示这个事件是事件 $1$。这行接下来一个整数 $k$，表示这次询问涉及 $k$ 个树枝。接下来 $k$ 对整数 $u_k, v_k$，每个树枝从节点 $u_k$ 到节点 $v_k$。由于果子数可能非常多，请输出这个数模 $2^{31}$ 的结果。", "outputFormat": "对于每个事件 $1$，输出询问的果子数。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 2 \\times 10^5$，$1 \\leq Q \\leq 2 \\times 10^5$，$k = 5$。\n\n生成每个树枝的过程是这样的：先在树中随机找一个节点，然后在这个节点到根的路径上随机选一个节点，这两个节点就作为树枝的两端。", "locale": "zh-CN"}}}
{"pid": "P12694", "type": "P", "difficulty": 6, "samples": [["3\n213 46290770 80175784\n3 46290770 80175784\n3333 46290770 80175784\n", "27\n27\n297"]], "limits": {"time": [1000, 1000], "memory": [524288, 524288]}, "tags": ["原根", "中国剩余定理 CRT", "大步小步算法 BSGS"], "title": "BZOJ2219 数论之神", "background": "", "description": "对于给定的 $3$ 个非负整数 $A,B,K$，求出满足：\n- $X^A \\equiv B \\pmod{(2\\times K + 1)}$ \n- $X$ 在范围 $[0, 2K]$ 内\n\n的 $X$ 的个数。", "inputFormat": "第一行有一个正整数 $T$，表示接下来的数据的组数（$T \\leq 1000$）。之后对于每组数据，给出了 $3$ 个整数 $A, B, K$ （$1 \\leq A, B \\leq 10^9$, $1 \\leq K \\leq 5 \\times 10^8$）", "outputFormat": "输出一行，表示答案。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ2219 数论之神", "background": "", "description": "对于给定的 $3$ 个非负整数 $A,B,K$，求出满足：\n- $X^A \\equiv B \\pmod{(2\\times K + 1)}$ \n- $X$ 在范围 $[0, 2K]$ 内\n\n的 $X$ 的个数。", "inputFormat": "第一行有一个正整数 $T$，表示接下来的数据的组数（$T \\leq 1000$）。之后对于每组数据，给出了 $3$ 个整数 $A, B, K$ （$1 \\leq A, B \\leq 10^9$, $1 \\leq K \\leq 5 \\times 10^8$）", "outputFormat": "输出一行，表示答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12695", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["高精度", "博弈论", "2014", "多项式", "提交答案", "排序", "置换", "凸包", "其它技巧", "位运算", "快速数论变换 NTT", "分类讨论", "湖北"], "title": "序列游戏", "background": "出题人：VFleaKing & hjy96", "description": "从前有一天 hjy 在机房里愉快地刷题，但是他绞尽脑汁也只会写暴力，因此他想起了什么题都能够一眼秒的你，请你来帮助他 AC 吧！由于 hjy 现在心情比较糟，所以不想告诉你题面，请你根据他写的暴力程序推测题面，并帮他 AC。幸运的是我们并不是一无所知：我们知道这个程序的输入是两个整数序列。\n\n我们给出 prog.exe，这是 hjy 写的暴力。你可以给这个程序一些输入，来推测他的用途。\n\n我们给出 20 个输入文件 game1 ~ 20.in，请你写一个程序计算出对应的正确答案 game1 ~ 20.out。", "inputFormat": "第一行有一个正整数 algoNum。表示算法编号。\n\n第二行有一个正整数 $n$。表示序列长度。\n\n第三行包括 $n$ 个用空格隔开的整数用来表示序列 $a[1], a[2], \\dots, a[n]$。\n\n第四行包括 $n$ 个用空格隔开的整数用来表示序列 $b[1], b[2], \\dots, b[n]$。", "outputFormat": "请根据 prog.exe 进行推测。\n", "hint": "为降低难度，操作相似的测试点相邻（有各别例外）。\n\n运行 prog.exe 的方式为在命令行里输入\n\n```\nprog.exe <input> <output>\n```\n\n用来指定 prog 的输入和输出的文件位置。例如\n\n```\nprog.exe prog1.in prog1.out\n```\nprog.exe 会检测输入数据的合法性。如果数据不合法 prog.exe 会报错并不会产生输出。\n\n当然我们还提供了 linux 版的 prog。运行方式为\n```\n./prog <input> <output>\n```\n注意 prog.exe 是个暴力程序，对于大数据它会跑得非常慢。\n\n数据规模见输入文件。下表为原题的测试点分数，在洛谷上每个测试点 5 分。\n\n| 数据编号 | 分值 |\n| --- | --- |\n| 1 | $2$ |\n| 2 | $4$ |\n| 3 | $7$ |\n| 4 | $8$ |\n| 5 | $9$ |\n| 6 | $10$ |\n| 7 | $20$ |\n| 8 | $45$ |\n| 9 | $10$ |\n| 10 | $15$ |\n| 11 | $5$ |\n| 12 | $35$ |\n| 13 | $10$ |\n| 14 | $20$|\n| 15 | $25$ |\n| 16 | $10$ |\n| 17 | $15$ |\n| 18 | $30$ |\n| 19 | $10$ |\n| 20 | $10$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "序列游戏", "background": "出题人：VFleaKing & hjy96", "description": "从前有一天 hjy 在机房里愉快地刷题，但是他绞尽脑汁也只会写暴力，因此他想起了什么题都能够一眼秒的你，请你来帮助他 AC 吧！由于 hjy 现在心情比较糟，所以不想告诉你题面，请你根据他写的暴力程序推测题面，并帮他 AC。幸运的是我们并不是一无所知：我们知道这个程序的输入是两个整数序列。\n\n我们给出 prog.exe，这是 hjy 写的暴力。你可以给这个程序一些输入，来推测他的用途。\n\n我们给出 20 个输入文件 game1 ~ 20.in，请你写一个程序计算出对应的正确答案 game1 ~ 20.out。", "inputFormat": "第一行有一个正整数 algoNum。表示算法编号。\n\n第二行有一个正整数 $n$。表示序列长度。\n\n第三行包括 $n$ 个用空格隔开的整数用来表示序列 $a[1], a[2], \\dots, a[n]$。\n\n第四行包括 $n$ 个用空格隔开的整数用来表示序列 $b[1], b[2], \\dots, b[n]$。", "outputFormat": "请根据 prog.exe 进行推测。\n", "hint": "为降低难度，操作相似的测试点相邻（有各别例外）。\n\n运行 prog.exe 的方式为在命令行里输入\n\n```\nprog.exe <input> <output>\n```\n\n用来指定 prog 的输入和输出的文件位置。例如\n\n```\nprog.exe prog1.in prog1.out\n```\nprog.exe 会检测输入数据的合法性。如果数据不合法 prog.exe 会报错并不会产生输出。\n\n当然我们还提供了 linux 版的 prog。运行方式为\n```\n./prog <input> <output>\n```\n注意 prog.exe 是个暴力程序，对于大数据它会跑得非常慢。\n\n数据规模见输入文件。下表为原题的测试点分数，在洛谷上每个测试点 5 分。\n\n| 数据编号 | 分值 |\n| --- | --- |\n| 1 | $2$ |\n| 2 | $4$ |\n| 3 | $7$ |\n| 4 | $8$ |\n| 5 | $9$ |\n| 6 | $10$ |\n| 7 | $20$ |\n| 8 | $45$ |\n| 9 | $10$ |\n| 10 | $15$ |\n| 11 | $5$ |\n| 12 | $35$ |\n| 13 | $10$ |\n| 14 | $20$|\n| 15 | $25$ |\n| 16 | $10$ |\n| 17 | $15$ |\n| 18 | $30$ |\n| 19 | $10$ |\n| 20 | $10$ |", "locale": "zh-CN"}}}
{"pid": "P12696", "type": "P", "difficulty": 2, "samples": [["1\n1", "0"], ["8\n6 1 2 3 2 4 5 10", "3"], ["6\n3 4 6 10 2 5", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "KOI（韩国）"], "title": "[KOI 2022 Round 2] 原位卡片", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "有 $ N $ 张卡片按左右一排排列。每张卡片上写有一个整数，第 $ i $ 张卡片上写的整数是 $ A_i $。（$ 1 \\leq i \\leq N $）\n\n你可以从这 $ N $ 张卡片中选择若干张卡片并将其移除。此时，剩下卡片的顺序保持不变。\n\n例如，设 $ N = 5 $，$ A = [3, 1, 4, 1, 5] $。如果你移除了第二张和第五张卡片，那么剩下卡片上的数字依次为 3、4、1。也就是说，剩下的卡片中从左数第 3 张卡片上的数字是 1。\n\n移除若干张卡片后，如果剩下卡片中从左数第 $ x $ 张卡片上写的数正好等于 $ x $，那么我们称该卡片为“原位卡片”。如果所有剩下的卡片都是原位卡片，那么我们称卡片序列达到了“原位状态”。\n\n例如，设 $ N = 8 $，$ A = [6, 1, 2, 3, 2, 4, 5, 10] $。如果你移除了第一张、第五张和第八张卡片，那么剩下的卡片上的数依次为 1、2、3、4、5。在这种情况下，所有剩下的卡片都是原位卡片，因此卡片序列处于原位状态。\n\n又如，若 $ N = 6 $，$ A = [3, 4, 6, 10, 2, 5] $，为了达到原位状态，必须将所有卡片都移除，使得不剩下一张卡片。\n\n请注意，如果将所有卡片都移除，总是可以达到原位状态。\n\n请编写程序，计算为了使卡片序列达到原位状态，至少需要移除多少张卡片。", "inputFormat": "第一行包含一个整数 $ N $。\n\n第二行包含 $ N $ 个整数 $ A_1, A_2, \\ldots, A_N $，依次给出。", "outputFormat": "输出一个整数，表示最少需要移除的卡片数。", "hint": "**约束条件**\n\n- $ 1 \\leq N \\leq 250\\,000 $\n- 对于所有的 $ i $（$ 1 \\leq i \\leq N $），有 $ 1 \\leq A_i \\leq 250\\,000 $\n\n**子任务**\n\n1. （5 分）$ N = 1 $\n2. （16 分）$ N \\leq 20 $\n3. （28 分）$ N \\leq 1\\,500 $\n4. （51 分）无额外限制条件", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2022 Round 2] 原位卡片", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "有 $ N $ 张卡片按左右一排排列。每张卡片上写有一个整数，第 $ i $ 张卡片上写的整数是 $ A_i $。（$ 1 \\leq i \\leq N $）\n\n你可以从这 $ N $ 张卡片中选择若干张卡片并将其移除。此时，剩下卡片的顺序保持不变。\n\n例如，设 $ N = 5 $，$ A = [3, 1, 4, 1, 5] $。如果你移除了第二张和第五张卡片，那么剩下卡片上的数字依次为 3、4、1。也就是说，剩下的卡片中从左数第 3 张卡片上的数字是 1。\n\n移除若干张卡片后，如果剩下卡片中从左数第 $ x $ 张卡片上写的数正好等于 $ x $，那么我们称该卡片为“原位卡片”。如果所有剩下的卡片都是原位卡片，那么我们称卡片序列达到了“原位状态”。\n\n例如，设 $ N = 8 $，$ A = [6, 1, 2, 3, 2, 4, 5, 10] $。如果你移除了第一张、第五张和第八张卡片，那么剩下的卡片上的数依次为 1、2、3、4、5。在这种情况下，所有剩下的卡片都是原位卡片，因此卡片序列处于原位状态。\n\n又如，若 $ N = 6 $，$ A = [3, 4, 6, 10, 2, 5] $，为了达到原位状态，必须将所有卡片都移除，使得不剩下一张卡片。\n\n请注意，如果将所有卡片都移除，总是可以达到原位状态。\n\n请编写程序，计算为了使卡片序列达到原位状态，至少需要移除多少张卡片。", "inputFormat": "第一行包含一个整数 $ N $。\n\n第二行包含 $ N $ 个整数 $ A_1, A_2, \\ldots, A_N $，依次给出。", "outputFormat": "输出一个整数，表示最少需要移除的卡片数。", "hint": "**约束条件**\n\n- $ 1 \\leq N \\leq 250\\,000 $\n- 对于所有的 $ i $（$ 1 \\leq i \\leq N $），有 $ 1 \\leq A_i \\leq 250\\,000 $\n\n**子任务**\n\n1. （5 分）$ N = 1 $\n2. （16 分）$ N \\leq 20 $\n3. （28 分）$ N \\leq 1\\,500 $\n4. （51 分）无额外限制条件", "locale": "zh-CN"}}}
{"pid": "P12697", "type": "P", "difficulty": 3, "samples": [["4\n1 2 2 4", "1"], ["5\n6 3 3 1 -1", "2"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "KOI（韩国）"], "title": "[KOI 2022 Round 2] 更换卡片", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "桌面上放置了 $N$ 张卡片。为方便描述，我们将最左边的卡片称为第 1 张卡片，接下来的称为第 2 张卡片，以此类推，最右边的卡片为第 $N$ 张卡片。\n\n每张卡片上都写有一个整数。记第 $i$ 张卡片上写的数为 $x_i$。\n\n你可以选择更改这 $N$ 张卡片中部分卡片上写的数字，使得从左到右卡片上的数字呈现以下三种形式之一：\n\n- 单调递增（每张卡片上的数比左边那张卡片上的数大相同的量）；\n- 单调递减（每张卡片上的数比左边那张卡片上的数小相同的量）；\n- 所有卡片上的数都相同。\n\n你只能将卡片上的数改为整数，并且需要使改动的卡片数量尽可能少。\n\n例如，考虑下面的情况：卡片上的数依次为 1、2、2、4。\n\n你可以将第 3 张卡片上的数字改为 3，这样卡片上的数就依次为 1、2、3、4，满足每张卡片上的数字比左边一张大 1。此时只更改了 1 张卡片。\n\n或者，你可以将第 1 张和第 4 张卡片上的数字都改为 2，使所有卡片上的数字都变为 2，此时共更改了 2 张卡片。\n\n给定从最左边到最右边所有卡片上原本写的数，请计算为了满足上述任意一种形式，最少需要更改多少张卡片。", "inputFormat": "第一行包含一个整数 $N$，表示卡片的数量。\n\n第二行包含 $N$ 个整数 $x_1, x_2, \\ldots, x_N$，表示从左到右每张卡片上写的数，数之间用空格分隔。\n", "outputFormat": "输出一个整数，表示为了满足条件需要更改的卡片数量的最小值。\n", "hint": "**约束条件**\n\n- $2 \\leq N \\leq 500$\n- 对所有 $1 \\leq i \\leq N$，有 $-1\\,000\\,000 \\leq x_i \\leq 1\\,000\\,000$\n\n**子任务**\n\n1. （3 分）$N \\leq 3$\n2. （10 分）最少只需更改不超过 2 张卡片\n3. （20 分）保证存在一种最优解使得相邻卡片上数的差值不超过 100\n4. （67 分）无额外限制条件", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2022 Round 2] 更换卡片", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "桌面上放置了 $N$ 张卡片。为方便描述，我们将最左边的卡片称为第 1 张卡片，接下来的称为第 2 张卡片，以此类推，最右边的卡片为第 $N$ 张卡片。\n\n每张卡片上都写有一个整数。记第 $i$ 张卡片上写的数为 $x_i$。\n\n你可以选择更改这 $N$ 张卡片中部分卡片上写的数字，使得从左到右卡片上的数字呈现以下三种形式之一：\n\n- 单调递增（每张卡片上的数比左边那张卡片上的数大相同的量）；\n- 单调递减（每张卡片上的数比左边那张卡片上的数小相同的量）；\n- 所有卡片上的数都相同。\n\n你只能将卡片上的数改为整数，并且需要使改动的卡片数量尽可能少。\n\n例如，考虑下面的情况：卡片上的数依次为 1、2、2、4。\n\n你可以将第 3 张卡片上的数字改为 3，这样卡片上的数就依次为 1、2、3、4，满足每张卡片上的数字比左边一张大 1。此时只更改了 1 张卡片。\n\n或者，你可以将第 1 张和第 4 张卡片上的数字都改为 2，使所有卡片上的数字都变为 2，此时共更改了 2 张卡片。\n\n给定从最左边到最右边所有卡片上原本写的数，请计算为了满足上述任意一种形式，最少需要更改多少张卡片。", "inputFormat": "第一行包含一个整数 $N$，表示卡片的数量。\n\n第二行包含 $N$ 个整数 $x_1, x_2, \\ldots, x_N$，表示从左到右每张卡片上写的数，数之间用空格分隔。\n", "outputFormat": "输出一个整数，表示为了满足条件需要更改的卡片数量的最小值。\n", "hint": "**约束条件**\n\n- $2 \\leq N \\leq 500$\n- 对所有 $1 \\leq i \\leq N$，有 $-1\\,000\\,000 \\leq x_i \\leq 1\\,000\\,000$\n\n**子任务**\n\n1. （3 分）$N \\leq 3$\n2. （10 分）最少只需更改不超过 2 张卡片\n3. （20 分）保证存在一种最优解使得相邻卡片上数的差值不超过 100\n4. （67 分）无额外限制条件", "locale": "zh-CN"}}}
{"pid": "P12698", "type": "P", "difficulty": 4, "samples": [["7\n1 2\n1 3\n1 5\n2 7\n4 6\n4 7\n6\n1 1\n2 1 2\n4 1 2 3 4\n5 1 2 4 6 7\n6 1 2 3 4 5 6\n7 1 2 3 4 5 6 7", "0\n1\n3\n10\n7\n21"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["并查集", "2022", "KOI（韩国）"], "title": "[KOI 2022 Round 2] 树与查询", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "有一个由 1 到 $N$ 的 $N$ 个节点组成的树。第 $i$ 条边连接两个不同的节点 $A_i$ 和 $B_i$。（$1 \\leq i \\leq N - 1$）\n\n在这 $N$ 个节点中选择一些节点，记为 $S = \\{s_1, s_2, \\dots, s_K\\}$。如果存在 $i$ （$1 \\leq i \\leq K$），使得 $s_i = v$，则称节点 $v$ 属于集合 $S$。\n\n如果集合 $S$ 中的两个不同节点 $u$ 和 $v$ 满足，仅通过集合 $S$ 中的节点即可在树上从 $u$ 移动到 $v$，则称“$u$ 和 $v$ 在 $S$ 上是连接的”。\n\n例如，考虑如下树（$N = 7$）。如果 $K = 6$ 且 $S = \\{1, 2, 3, 4, 5, 6\\}$，则 “1 和 2”、“3 和 5”、“4 和 6”在集合 $S$ 上是连接的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iioob9ly.png)\n\n然而，“1 和 6”、“2 和 7”在集合 $S$ 上不是连接的。\n\n我们定义满足以下条件的节点对 $(u, v)$ 的数量为集合 $S$ 的连接强度：\n\n1. $u$ 和 $v$ 是不同的两个节点。\n2. $1 \\leq u < v \\leq N$。\n3. $u$ 和 $v$ 在集合 $S$ 上是连接的。\n\n给定一个选择的节点集合 $S$，请计算 $S$ 的连接强度。你需要回答 $Q$ 个查询。", "inputFormat": "第一行给出整数 $N$。\n\n接下来 $N - 1$ 行，每行包含两个整数 $A_i$ 和 $B_i$，表示第 $i$ 条边连接的两个节点。\n\n接着是一个整数 $Q$，表示查询的数量。\n\n接下来 $Q$ 行，每行表示一个查询。每个查询首先给出整数 $K$，接着是 $K$ 个整数 $s_1, s_2, \\dots, s_K$，表示集合 $S$。\n", "outputFormat": "对于每个查询，输出一行，表示该查询中给定集合 $S$ 的连接强度。\n", "hint": "**约束条件**\n\n- $2 \\leq N \\leq 250,000$\n- $1 \\leq Q \\leq 100,000$\n- 对于所有的 $i$（$1 \\leq i \\leq N - 1$），有 $1 \\leq A_i \\leq N$。\n- 对于所有的 $i$（$1 \\leq i \\leq N - 1$），有 $1 \\leq B_i \\leq N$。\n- 对于所有的 $i$（$1 \\leq i \\leq N - 1$），有 $A_i \\neq B_i$。\n- 给定的图是树。\n- 对于每个查询，$1 \\leq K \\leq N$。\n- 对于每个查询，给出的 K 个节点 $s_1, s_2, \\dots, s_K$ 是不同的。\n- 在 $Q$ 个查询中，所有的 $K$ 总和不超过 1,000,000。\n\n**子任务**\n\n1. （3 分）$N = 3$。\n2. （10 分）$N \\leq 50, Q \\leq 50$。\n3. （11 分）$N \\leq 2,500, Q \\leq 2,500$。\n4. （13 分）每个查询中，$K = 3$。\n5. （63 分）无额外约束条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2022 Round 2] 树与查询", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "有一个由 1 到 $N$ 的 $N$ 个节点组成的树。第 $i$ 条边连接两个不同的节点 $A_i$ 和 $B_i$。（$1 \\leq i \\leq N - 1$）\n\n在这 $N$ 个节点中选择一些节点，记为 $S = \\{s_1, s_2, \\dots, s_K\\}$。如果存在 $i$ （$1 \\leq i \\leq K$），使得 $s_i = v$，则称节点 $v$ 属于集合 $S$。\n\n如果集合 $S$ 中的两个不同节点 $u$ 和 $v$ 满足，仅通过集合 $S$ 中的节点即可在树上从 $u$ 移动到 $v$，则称“$u$ 和 $v$ 在 $S$ 上是连接的”。\n\n例如，考虑如下树（$N = 7$）。如果 $K = 6$ 且 $S = \\{1, 2, 3, 4, 5, 6\\}$，则 “1 和 2”、“3 和 5”、“4 和 6”在集合 $S$ 上是连接的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iioob9ly.png)\n\n然而，“1 和 6”、“2 和 7”在集合 $S$ 上不是连接的。\n\n我们定义满足以下条件的节点对 $(u, v)$ 的数量为集合 $S$ 的连接强度：\n\n1. $u$ 和 $v$ 是不同的两个节点。\n2. $1 \\leq u < v \\leq N$。\n3. $u$ 和 $v$ 在集合 $S$ 上是连接的。\n\n给定一个选择的节点集合 $S$，请计算 $S$ 的连接强度。你需要回答 $Q$ 个查询。", "inputFormat": "第一行给出整数 $N$。\n\n接下来 $N - 1$ 行，每行包含两个整数 $A_i$ 和 $B_i$，表示第 $i$ 条边连接的两个节点。\n\n接着是一个整数 $Q$，表示查询的数量。\n\n接下来 $Q$ 行，每行表示一个查询。每个查询首先给出整数 $K$，接着是 $K$ 个整数 $s_1, s_2, \\dots, s_K$，表示集合 $S$。\n", "outputFormat": "对于每个查询，输出一行，表示该查询中给定集合 $S$ 的连接强度。\n", "hint": "**约束条件**\n\n- $2 \\leq N \\leq 250,000$\n- $1 \\leq Q \\leq 100,000$\n- 对于所有的 $i$（$1 \\leq i \\leq N - 1$），有 $1 \\leq A_i \\leq N$。\n- 对于所有的 $i$（$1 \\leq i \\leq N - 1$），有 $1 \\leq B_i \\leq N$。\n- 对于所有的 $i$（$1 \\leq i \\leq N - 1$），有 $A_i \\neq B_i$。\n- 给定的图是树。\n- 对于每个查询，$1 \\leq K \\leq N$。\n- 对于每个查询，给出的 K 个节点 $s_1, s_2, \\dots, s_K$ 是不同的。\n- 在 $Q$ 个查询中，所有的 $K$ 总和不超过 1,000,000。\n\n**子任务**\n\n1. （3 分）$N = 3$。\n2. （10 分）$N \\leq 50, Q \\leq 50$。\n3. （11 分）$N \\leq 2,500, Q \\leq 2,500$。\n4. （13 分）每个查询中，$K = 3$。\n5. （63 分）无额外约束条件。", "locale": "zh-CN"}}}
{"pid": "P12699", "type": "P", "difficulty": 5, "samples": [["3 4 5 3\n3 2\n2 5\n7 6\n1 2\n4 3\n3 6\n7 4", "2\n3 3"], ["3 3 4 4\n1 1\n2 2\n3 3\n1 3\n3 1\n4 4", "2\n-2 -2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2022", "Special Judge", "扫描线", "KOI（韩国）"], "title": "[KOI 2022 Round 2] 红蓝", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "在坐标平面上有 $N$ 个红色点和 $M$ 个蓝色点。给定自然数 $W$ 和 $H$。\n\n第 $i$ 个 ($1 \\leq i \\leq N$) 红色点的坐标是 $(r_{xi}, r_{yi})$，第 $j$ 个 ($1 \\leq j \\leq M$) 蓝色点的坐标是 $(b_{xj}, b_{yj})$。\n\n所有点的坐标都是不同的。\n\n我们需要放置一个宽度为 $W$，高度为 $H$ 的矩形，该矩形的边与坐标轴平行，并且它的四个顶点是整数坐标。我们希望最大化矩形内包含的红色点与蓝色点数量之差。\n\n矩形包含点的条件是：如果矩形的左下角坐标为 $(a, b)$，且点的坐标为 $(x, y)$，那么该点包含在矩形内当且仅当满足 $a \\leq x \\leq a+W$ 且 $b \\leq y \\leq b+H$。\n\n我们要求得这个差值的最大值，并找到符合这个最大差值的矩形位置。\n\n下图展示了在平面上有 3 个红色点和 4 个蓝色点的情况。为了说明问题，红色点用圆圈表示，蓝色点用三角形表示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1j8grh16.png)\n\n假设 $W = 5$，$H = 3$，那么如果将矩形的左下角放在 $(3, 3)$，矩形内包含 1 个红色点和 3 个蓝色点，这时点的数量差为 2。无论矩形放置在哪里，点的数量差都不会大于 3，因此答案是 2。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fxgmqc3b.png)", "inputFormat": "第一行给出整数 $N$ 和 $M$，以及矩形的宽度 $W$ 和高度 $H$。\n\n接下来的 $N$ 行，每行包含一个红色点的坐标 $(r_{xi}, r_{yi})$。\n\n接下来的 $M$ 行，每行包含一个蓝色点的坐标 $(b_{xj}, b_{yj})$。", "outputFormat": "输出一个整数，表示最大点数差值。然后输出矩形左下角的坐标 $(a, b)$。\n\n如果答案有多个，输出任意一个即可。", "hint": "**约束条件**\n\n- $1 \\leq N, M \\leq 100\\,000$\n- $1 \\leq W, H \\leq 10^9$\n- $1 \\leq r_{xi}, r_{yi} \\leq 10^9$ ($1 \\leq i \\leq N$)\n- $1 \\leq b_{xj}, b_{yj} \\leq 10^9$ ($1 \\leq j \\leq M$)\n\n**子任务**\n\n1. （5 分）$1 \\leq N, M, W, H, r_{xi}, r_{yi}, b_{xj}, b_{yj} \\leq 50$\n2. （11 分）$1 \\leq N, M, W, H, r_{xi}, r_{yi}, b_{xj}, b_{yj} \\leq 1\\,000$\n3. （15 分）$1 \\leq N, M \\leq 100$\n4. （9 分）$1 \\leq N, M \\leq 1\\,000$\n5. （60 分）无额外约束条件", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2022 Round 2] 红蓝", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "在坐标平面上有 $N$ 个红色点和 $M$ 个蓝色点。给定自然数 $W$ 和 $H$。\n\n第 $i$ 个 ($1 \\leq i \\leq N$) 红色点的坐标是 $(r_{xi}, r_{yi})$，第 $j$ 个 ($1 \\leq j \\leq M$) 蓝色点的坐标是 $(b_{xj}, b_{yj})$。\n\n所有点的坐标都是不同的。\n\n我们需要放置一个宽度为 $W$，高度为 $H$ 的矩形，该矩形的边与坐标轴平行，并且它的四个顶点是整数坐标。我们希望最大化矩形内包含的红色点与蓝色点数量之差。\n\n矩形包含点的条件是：如果矩形的左下角坐标为 $(a, b)$，且点的坐标为 $(x, y)$，那么该点包含在矩形内当且仅当满足 $a \\leq x \\leq a+W$ 且 $b \\leq y \\leq b+H$。\n\n我们要求得这个差值的最大值，并找到符合这个最大差值的矩形位置。\n\n下图展示了在平面上有 3 个红色点和 4 个蓝色点的情况。为了说明问题，红色点用圆圈表示，蓝色点用三角形表示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1j8grh16.png)\n\n假设 $W = 5$，$H = 3$，那么如果将矩形的左下角放在 $(3, 3)$，矩形内包含 1 个红色点和 3 个蓝色点，这时点的数量差为 2。无论矩形放置在哪里，点的数量差都不会大于 3，因此答案是 2。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fxgmqc3b.png)", "inputFormat": "第一行给出整数 $N$ 和 $M$，以及矩形的宽度 $W$ 和高度 $H$。\n\n接下来的 $N$ 行，每行包含一个红色点的坐标 $(r_{xi}, r_{yi})$。\n\n接下来的 $M$ 行，每行包含一个蓝色点的坐标 $(b_{xj}, b_{yj})$。", "outputFormat": "输出一个整数，表示最大点数差值。然后输出矩形左下角的坐标 $(a, b)$。\n\n如果答案有多个，输出任意一个即可。", "hint": "**约束条件**\n\n- $1 \\leq N, M \\leq 100\\,000$\n- $1 \\leq W, H \\leq 10^9$\n- $1 \\leq r_{xi}, r_{yi} \\leq 10^9$ ($1 \\leq i \\leq N$)\n- $1 \\leq b_{xj}, b_{yj} \\leq 10^9$ ($1 \\leq j \\leq M$)\n\n**子任务**\n\n1. （5 分）$1 \\leq N, M, W, H, r_{xi}, r_{yi}, b_{xj}, b_{yj} \\leq 50$\n2. （11 分）$1 \\leq N, M, W, H, r_{xi}, r_{yi}, b_{xj}, b_{yj} \\leq 1\\,000$\n3. （15 分）$1 \\leq N, M \\leq 100$\n4. （9 分）$1 \\leq N, M \\leq 1\\,000$\n5. （60 分）无额外约束条件", "locale": "zh-CN"}}}
{"pid": "P12700", "type": "P", "difficulty": 5, "samples": [["4\n1 2 2 1", "3"], ["5\n3 1 4 5 1", "7"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2022", "KOI（韩国）"], "title": "[KOI 2022 Round 2] 停车场", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "有一个圆形的停车塔。停车塔上有 $N$ 个格子，按顺时针方向依次编号为第 1 个格、第 2 个格、……、第 $N$ 个格。每个格子中都停有一辆车，第 $i$ 个格子中的车辆编号为 $a_i$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cvus8hb5.png)\n\n停车塔上有两个按钮：按下按钮 A 会使整个停车塔顺时针旋转一格，按下按钮 B 会使停车塔逆时针旋转一格。下图左边展示了按下按钮 A 后的状态，右边展示了按下按钮 B 后的状态。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vneppep8.png)\n\n此时，目标是将所有车辆从停车塔中依次取出。\n\n车辆只能从最底部的一个格子被取出。初始时，第 1 个格子位于最底部。要取出不在最底部的车辆，必须先按按钮将其旋转至最底部的位置。\n\n此外，编号为 $x$ 的车辆只能在编号小于 $x$ 的所有车辆都已被取出的情况下才能被取出。换句话说，如果停车塔中还剩下编号小于 $x$ 的车辆，那么编号为 $x$ 的车辆就不能被取出。\n\n请你编写一个程序，计算将所有车辆从停车塔中取出所需按按钮的最少总次数。", "inputFormat": "第一行包含一个整数 $N$。\n\n第二行包含 $N$ 个整数 $a_1, a_2, \\dots, a_N$，表示每个格子中车辆的编号，按顺时针顺序排列，以空格分隔。\n", "outputFormat": "输出一个整数，表示将所有车辆从停车塔中取出所需按按钮的最少总次数。\n", "hint": "**约束条件**\n\n- $1 \\leq N \\leq 100\\,000$\n- $1 \\leq a_i \\leq 1\\,000\\,000\\,000$\n\n**子任务**\n\n1. （8 分）对于所有的 $i$，$a_i = 1$。即，所有车辆编号都为 1。\n2. （9 分）对于所有的 $i \\ne j$，有 $a_i \\ne a_j$。即，所有车辆编号各不相同。\n3. （10 分）$N \\leq 10$\n4. （21 分）$N \\leq 100$\n5. （31 分）$N \\leq 1\\,000$\n6. （21 分）无额外约束条件", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2022 Round 2] 停车场", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "有一个圆形的停车塔。停车塔上有 $N$ 个格子，按顺时针方向依次编号为第 1 个格、第 2 个格、……、第 $N$ 个格。每个格子中都停有一辆车，第 $i$ 个格子中的车辆编号为 $a_i$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cvus8hb5.png)\n\n停车塔上有两个按钮：按下按钮 A 会使整个停车塔顺时针旋转一格，按下按钮 B 会使停车塔逆时针旋转一格。下图左边展示了按下按钮 A 后的状态，右边展示了按下按钮 B 后的状态。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vneppep8.png)\n\n此时，目标是将所有车辆从停车塔中依次取出。\n\n车辆只能从最底部的一个格子被取出。初始时，第 1 个格子位于最底部。要取出不在最底部的车辆，必须先按按钮将其旋转至最底部的位置。\n\n此外，编号为 $x$ 的车辆只能在编号小于 $x$ 的所有车辆都已被取出的情况下才能被取出。换句话说，如果停车塔中还剩下编号小于 $x$ 的车辆，那么编号为 $x$ 的车辆就不能被取出。\n\n请你编写一个程序，计算将所有车辆从停车塔中取出所需按按钮的最少总次数。", "inputFormat": "第一行包含一个整数 $N$。\n\n第二行包含 $N$ 个整数 $a_1, a_2, \\dots, a_N$，表示每个格子中车辆的编号，按顺时针顺序排列，以空格分隔。\n", "outputFormat": "输出一个整数，表示将所有车辆从停车塔中取出所需按按钮的最少总次数。\n", "hint": "**约束条件**\n\n- $1 \\leq N \\leq 100\\,000$\n- $1 \\leq a_i \\leq 1\\,000\\,000\\,000$\n\n**子任务**\n\n1. （8 分）对于所有的 $i$，$a_i = 1$。即，所有车辆编号都为 1。\n2. （9 分）对于所有的 $i \\ne j$，有 $a_i \\ne a_j$。即，所有车辆编号各不相同。\n3. （10 分）$N \\leq 10$\n4. （21 分）$N \\leq 100$\n5. （31 分）$N \\leq 1\\,000$\n6. （21 分）无额外约束条件", "locale": "zh-CN"}}}
{"pid": "P12701", "type": "P", "difficulty": 5, "samples": [["5\n5 1 7 5 4\n4 3", "5 7 7 7 8"], ["4\n7 4 2 9\n10 1", "7 8 8 9\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["二分", "2022", "KOI（韩国）"], "title": "[KOI 2022 Round 2] 升级", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "你正在培养 $N$ 名游戏角色。第 $i$ 名角色的当前等级为 $L_i$（$1 \\leq i \\leq N$）。\n\n为了提升角色的等级，你将总共进行 $M$ 次训练。每次训练按如下方式进行：\n\n- 按照等级从低到高的顺序，选择 $K$ 名角色。如果有多个角色的等级相同，可以从中任选。\n- 将所选角色的等级各提升 1 级。\n\n例如，设 $M = 4$，$K = 3$，并且 $N = 5$ 个角色的初始等级依次为 5、1、7、5、4。\n\n第一次训练后，第 2、5、4 个角色的等级将提升，角色等级变为 5、2、7、6、5。\n\n上面的例子中，每次训练之后角色的等级如下所示：\n\n| 训练次数 | 角色等级              |\n|:----------:|:-----------------------:|\n| 1        | $5, 2, 7, 6, 5$         |\n| 2        | $6, 3, 7, 6, 6$         |\n| 3        | $7, 4, 7, 6, 7$         |\n| 4        | $7, 5, 8, 7, 7$         |\n\n请你编写程序，在 $M$ 次训练全部结束后，按升序输出 $N$ 名角色的最终等级。", "inputFormat": "第一行包含一个整数 $N$，表示角色数量。\n\n第二行包含 $N$ 个整数 $L_1, L_2, \\ldots, L_N$，表示每个角色的初始等级，以空格分隔。\n\n第三行包含两个整数 $M$ 和 $K$，以空格分隔，表示总共进行 $M$ 次训练，每次训练提升等级的角色数为 $K$。\n", "outputFormat": "一行输出 $N$ 个整数，表示 $M$ 次训练后各角色的等级，按升序排列。\n", "hint": "**约束条件**\n\n- $1 \\leq N \\leq 100\\,000$\n- $1 \\leq M \\leq 10^9$\n- $1 \\leq K \\leq N$\n- $1 \\leq L_i \\leq 10^9$（$1 \\leq i \\leq N$）\n\n**子任务**\n\n1. （4 分）$N \\leq 1\\,000$，$M \\leq 1\\,000$\n2. （10 分）$K = 1$\n3. （32 分）$M \\leq 100\\,000$\n4. （54 分）无额外约束条件", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2022 Round 2] 升级", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "你正在培养 $N$ 名游戏角色。第 $i$ 名角色的当前等级为 $L_i$（$1 \\leq i \\leq N$）。\n\n为了提升角色的等级，你将总共进行 $M$ 次训练。每次训练按如下方式进行：\n\n- 按照等级从低到高的顺序，选择 $K$ 名角色。如果有多个角色的等级相同，可以从中任选。\n- 将所选角色的等级各提升 1 级。\n\n例如，设 $M = 4$，$K = 3$，并且 $N = 5$ 个角色的初始等级依次为 5、1、7、5、4。\n\n第一次训练后，第 2、5、4 个角色的等级将提升，角色等级变为 5、2、7、6、5。\n\n上面的例子中，每次训练之后角色的等级如下所示：\n\n| 训练次数 | 角色等级              |\n|:----------:|:-----------------------:|\n| 1        | $5, 2, 7, 6, 5$         |\n| 2        | $6, 3, 7, 6, 6$         |\n| 3        | $7, 4, 7, 6, 7$         |\n| 4        | $7, 5, 8, 7, 7$         |\n\n请你编写程序，在 $M$ 次训练全部结束后，按升序输出 $N$ 名角色的最终等级。", "inputFormat": "第一行包含一个整数 $N$，表示角色数量。\n\n第二行包含 $N$ 个整数 $L_1, L_2, \\ldots, L_N$，表示每个角色的初始等级，以空格分隔。\n\n第三行包含两个整数 $M$ 和 $K$，以空格分隔，表示总共进行 $M$ 次训练，每次训练提升等级的角色数为 $K$。\n", "outputFormat": "一行输出 $N$ 个整数，表示 $M$ 次训练后各角色的等级，按升序排列。\n", "hint": "**约束条件**\n\n- $1 \\leq N \\leq 100\\,000$\n- $1 \\leq M \\leq 10^9$\n- $1 \\leq K \\leq N$\n- $1 \\leq L_i \\leq 10^9$（$1 \\leq i \\leq N$）\n\n**子任务**\n\n1. （4 分）$N \\leq 1\\,000$，$M \\leq 1\\,000$\n2. （10 分）$K = 1$\n3. （32 分）$M \\leq 100\\,000$\n4. （54 分）无额外约束条件", "locale": "zh-CN"}}}
{"pid": "P12702", "type": "P", "difficulty": 5, "samples": [["9\n1 1 1 2 2 3 3 4 3", "1 4 2 5 6 3 7 8 9"], ["3\n1 1 1", "-1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "并查集", "2022", "优先队列", "KOI（韩国）"], "title": "[KOI 2022 Round 2] 食事计划", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "在 KOI 国家，铁柱所在的地方有 $N$ 个餐厅。每个餐厅只售卖一种食物，食物的类型通过整数 $A_i$ 来表示，$i$（$1 \\leq i \\leq N$）。\n\n铁柱计划访问所有的餐厅，并为自己制定一个食事计划。铁柱的食事计划可以用从 $1$ 到 $N$ 的整数排列 $P$ 来表示。举例来说，如果 $P = [2, 4, 3, 1]$，这意味着铁柱将依次访问餐厅 2、4、3 和 1。\n\n由于铁柱不希望连续吃相同类型的食物，所以在他的食事计划中，连续的两个餐厅必须提供不同类型的食物。也就是说，对于 $i = 1, 2, \\dots, N-1$，$A_{P_i} \\neq A_{P_{i+1}}$ 必须成立，而符合这一条件的食事计划被称为合法食事计划。\n\n例如，假设 $N = 9$，且提供的食物类型是 $A = [1, 1, 1, 2, 2, 3, 3, 4, 3]$，则如果铁柱的食事计划是 $P = [3, 4, 1, 5, 6, 2, 7, 8, 9]$，那么计划中的每两个相邻餐厅的食物类型都不同，符合条件。\n\n若铁柱的食事计划是 $P = [1, 4, 2, 5, 6, 3, 7, 8, 9]$，这也是一个合法的食事计划，并且是按字典顺序最前的合法计划。\n\n然而，若食物类型是 $A = [1, 1, 1]$，无论怎样安排食事计划，都无法满足“连续两餐不同类型”的要求。\n\n当给定 $N$ 个餐厅的食物类型时，如果无法制定合法的食事计划，则输出 `-1`；否则，输出字典序最前的合法食事计划。", "inputFormat": "第一行给出整数 $N$，表示餐厅的数量。\n\n第二行给出 $N$ 个整数 $A_1, A_2, \\dots, A_N$，表示每个餐厅的食物类型。", "outputFormat": "如果无法制定合法的食事计划，输出 `-1`。如果能够制定合法的食事计划，则输出字典序最前的合法食事计划 $P$，每个数之间用一个空格分隔。", "hint": "**约束条件**\n\n- $1 \\leq N \\leq 300\\,000$\n- $1 \\leq A_i \\leq N$\n\n**子任务**\n\n1. （5 分）$N \\leq 8$\n2. （12 分）$N \\leq 20$\n3. （32 分）$N \\leq 5\\,000$\n4. （51 分）无额外约束条件", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2022 Round 2] 食事计划", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "在 KOI 国家，铁柱所在的地方有 $N$ 个餐厅。每个餐厅只售卖一种食物，食物的类型通过整数 $A_i$ 来表示，$i$（$1 \\leq i \\leq N$）。\n\n铁柱计划访问所有的餐厅，并为自己制定一个食事计划。铁柱的食事计划可以用从 $1$ 到 $N$ 的整数排列 $P$ 来表示。举例来说，如果 $P = [2, 4, 3, 1]$，这意味着铁柱将依次访问餐厅 2、4、3 和 1。\n\n由于铁柱不希望连续吃相同类型的食物，所以在他的食事计划中，连续的两个餐厅必须提供不同类型的食物。也就是说，对于 $i = 1, 2, \\dots, N-1$，$A_{P_i} \\neq A_{P_{i+1}}$ 必须成立，而符合这一条件的食事计划被称为合法食事计划。\n\n例如，假设 $N = 9$，且提供的食物类型是 $A = [1, 1, 1, 2, 2, 3, 3, 4, 3]$，则如果铁柱的食事计划是 $P = [3, 4, 1, 5, 6, 2, 7, 8, 9]$，那么计划中的每两个相邻餐厅的食物类型都不同，符合条件。\n\n若铁柱的食事计划是 $P = [1, 4, 2, 5, 6, 3, 7, 8, 9]$，这也是一个合法的食事计划，并且是按字典顺序最前的合法计划。\n\n然而，若食物类型是 $A = [1, 1, 1]$，无论怎样安排食事计划，都无法满足“连续两餐不同类型”的要求。\n\n当给定 $N$ 个餐厅的食物类型时，如果无法制定合法的食事计划，则输出 `-1`；否则，输出字典序最前的合法食事计划。", "inputFormat": "第一行给出整数 $N$，表示餐厅的数量。\n\n第二行给出 $N$ 个整数 $A_1, A_2, \\dots, A_N$，表示每个餐厅的食物类型。", "outputFormat": "如果无法制定合法的食事计划，输出 `-1`。如果能够制定合法的食事计划，则输出字典序最前的合法食事计划 $P$，每个数之间用一个空格分隔。", "hint": "**约束条件**\n\n- $1 \\leq N \\leq 300\\,000$\n- $1 \\leq A_i \\leq N$\n\n**子任务**\n\n1. （5 分）$N \\leq 8$\n2. （12 分）$N \\leq 20$\n3. （32 分）$N \\leq 5\\,000$\n4. （51 分）无额外约束条件", "locale": "zh-CN"}}}
{"pid": "P12703", "type": "P", "difficulty": 7, "samples": [["4\n1 9\n1 8\n1 0\n9 9 9\n6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4", "9\n8\n0\n9\n9\n8"], ["11\n1 9\n1 8\n3 0\n4 7\n4 1\n3 6\n1 0\n8 7\n8 1\n10 6\n0 0 0 0 0 0\n21\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n7 1\n8 2\n9 3\n10 4\n11 5\n1 6\n2 7\n3 8\n4 9\n5 10\n6 11", "7\n8\n8\n7\n7\n7\n0\n7\n1\n7\n7\n7\n1\n7\n0\n7\n0\n8\n1\n6\n0"], ["11\n1 9\n1 8\n3 0\n4 7\n4 1\n3 6\n1 0\n8 7\n8 1\n10 6\n1000000000000 1000000000000\n1000000000000 1000000000000\n1000000000000 1000000000000\n21\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n7 1\n8 2\n9 3\n10 4\n11 5\n1 6\n2 7\n3 8\n4 9\n5 10\n6 11", "9\n8\n8\n15\n9\n14\n0\n7\n1\n7\n14\n9\n15\n9\n22\n9\n23\n8\n15\n16\n16"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["点分治", "2022", "最短路", "KOI（韩国）"], "title": "[KOI 2022 Round 2] 外环路", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "KOI 城市由 $N$ 个十字路口和 $N - 1$ 条双向道路组成，任意两个不同的十字路口之间都可以仅通过道路到达。也就是说，城市的道路网络结构是一棵树。这些道路位于二维平面上，除了端点外互不相交。每条道路都有一个不小于 0 的整数权重，表示通过这条道路所需的时间。\n\nKOI 城市在几十年前还是一个小村庄，随着人口流入和城市规模的迅速扩张，市长为了行政便利，为所有十字路口编号为 1 到 $N$。这个编号系统满足以下性质：\n\n- 1 号十字路口是城市的中心，保证至少连接了两条道路。\n- 各个十字路口的编号是以 1 号十字路口为根进行先序遍历（Preorder Traversal）所得到的一种顺序。\n- 对于每个十字路口，设其直接相邻（即通过一条道路连接）的十字路口中编号最小的为基准，从该点出发按逆时针方向依次列出其相邻的十字路口编号，这些编号应是递增的。\n\n随着 KOI 城市人口迅速增长，交通拥堵问题日益严重。为了解决这一问题，市长决定通过建设外环道路将交通设施最为薄弱的地区连接起来。\n\n设所有仅连接一条道路的十字路口的编号按升序排列为 $\\{v_1, v_2, \\dots, v_k\\}$，市长将为所有的 $1 \\leq i \\leq k$ 建设一条连接 $v_i$ 和 $v_{(i \\bmod k) + 1}$ 的双向道路。每条道路的权重为不小于 0 的整数 $w_i$，这些权重将作为输入给出。\n\n由于编号系统的特殊性，可以保证这些新增的外环道路在非端点处互不相交。\n\n你打算为 KOI 城市构建一套导航系统。该系统需要回答 $Q$ 个查询，每个查询给出两个十字路口 $u$ 和 $v$，你需要输出从 $u$ 号十字路口到 $v$ 号十字路口所需的最短时间。这个最短时间是指从 $u$ 到 $v$ 所经过路径的所有道路权重之和的最小值。\n\n请你编写程序，在给定城市道路结构和查询的前提下，快速回答所有 $Q$ 个查询。", "inputFormat": "第一行包含一个整数 $N$，表示十字路口的数量。\n\n接下来的 $N - 1$ 行，第 $i$ 行包含两个整数 $p_i$ 和 $c_i$，表示存在一条连接 $p_i$ 和 $i+1$ 的双向道路，权重为 $c_i$。\n\n设整数 $k$ 表示仅连接一条道路的十字路口的数量。\n\n随后一行包含 $k$ 个整数 $w_1, w_2, \\dots, w_k$，以空格分隔，其中 $w_i$ 是连接 $v_i$ 和 $v_{(i \\bmod k)+1}$ 的新建道路的权重。\n\n接下来一行包含一个整数 $Q$，表示查询数量。\n\n接下来的 $Q$ 行，每行两个整数 $u, v$，表示一次从 $u$ 到 $v$ 的查询。", "outputFormat": "共 $Q$ 行，每行一个整数，表示每个查询中 $u$ 到 $v$ 的最短路径长度。", "hint": "**样例 1 说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fcuqax1l.png)\n\n上面的地图对应于示例 1。示例 1 满足子任务 2、5、6 的约束条件。\n\n**样例 2、3 说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5b0ae9y3.png)\n\n上面的地图对应于示例 2 和示例 3。示例 2 的情况下，满足 $w_i = 0$；示例 3 的情况下，满足 $w_i = 10^{12}$。示例 2 满足子任务 4、5、6 的约束条件，示例 3 满足子任务 3、5、6 的约束条件。\n\n请注意，示例 3 中从第 12 行开始的数列：\n\n```\n1000000000000 1000000000000 1000000000000 1000000000000 1000000000000 1000000000000\n```\n\n在实际中是作为一行输入给出的，但由于篇幅限制，在此被分成了多行显示。（本段内容在正式比赛中并未提供。）\n\n**约束条件**\n\n- $4 \\leq N \\leq 100\\,000$\n- $1 \\leq p_i \\leq i$\n- $0 \\leq c_i, w_i \\leq 10^{12}$\n- $1 \\leq Q \\leq 250\\,000$\n- $1 \\leq u, v \\leq N$ 且 $u \\ne v$\n\n**子任务**\n\n1. （6 分）所有查询满足 $u = 1$\n2. （8 分）对所有 $1 \\leq i \\leq N - 1$，$p_i = 1$\n3. （5 分）对所有 $1 \\leq i \\leq N - 1$，$c_i \\leq 10^6$，并且对所有 $1 \\leq i \\leq k$，$w_i = 10^{12}$\n4. （15 分）对所有 $1 \\leq i \\leq k$，$w_i = 0$\n5. （57 分）不存在连接 4 条及以上道路的十字路口\n6. （9 分）无额外约束条件", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2022 Round 2] 外环路", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "KOI 城市由 $N$ 个十字路口和 $N - 1$ 条双向道路组成，任意两个不同的十字路口之间都可以仅通过道路到达。也就是说，城市的道路网络结构是一棵树。这些道路位于二维平面上，除了端点外互不相交。每条道路都有一个不小于 0 的整数权重，表示通过这条道路所需的时间。\n\nKOI 城市在几十年前还是一个小村庄，随着人口流入和城市规模的迅速扩张，市长为了行政便利，为所有十字路口编号为 1 到 $N$。这个编号系统满足以下性质：\n\n- 1 号十字路口是城市的中心，保证至少连接了两条道路。\n- 各个十字路口的编号是以 1 号十字路口为根进行先序遍历（Preorder Traversal）所得到的一种顺序。\n- 对于每个十字路口，设其直接相邻（即通过一条道路连接）的十字路口中编号最小的为基准，从该点出发按逆时针方向依次列出其相邻的十字路口编号，这些编号应是递增的。\n\n随着 KOI 城市人口迅速增长，交通拥堵问题日益严重。为了解决这一问题，市长决定通过建设外环道路将交通设施最为薄弱的地区连接起来。\n\n设所有仅连接一条道路的十字路口的编号按升序排列为 $\\{v_1, v_2, \\dots, v_k\\}$，市长将为所有的 $1 \\leq i \\leq k$ 建设一条连接 $v_i$ 和 $v_{(i \\bmod k) + 1}$ 的双向道路。每条道路的权重为不小于 0 的整数 $w_i$，这些权重将作为输入给出。\n\n由于编号系统的特殊性，可以保证这些新增的外环道路在非端点处互不相交。\n\n你打算为 KOI 城市构建一套导航系统。该系统需要回答 $Q$ 个查询，每个查询给出两个十字路口 $u$ 和 $v$，你需要输出从 $u$ 号十字路口到 $v$ 号十字路口所需的最短时间。这个最短时间是指从 $u$ 到 $v$ 所经过路径的所有道路权重之和的最小值。\n\n请你编写程序，在给定城市道路结构和查询的前提下，快速回答所有 $Q$ 个查询。", "inputFormat": "第一行包含一个整数 $N$，表示十字路口的数量。\n\n接下来的 $N - 1$ 行，第 $i$ 行包含两个整数 $p_i$ 和 $c_i$，表示存在一条连接 $p_i$ 和 $i+1$ 的双向道路，权重为 $c_i$。\n\n设整数 $k$ 表示仅连接一条道路的十字路口的数量。\n\n随后一行包含 $k$ 个整数 $w_1, w_2, \\dots, w_k$，以空格分隔，其中 $w_i$ 是连接 $v_i$ 和 $v_{(i \\bmod k)+1}$ 的新建道路的权重。\n\n接下来一行包含一个整数 $Q$，表示查询数量。\n\n接下来的 $Q$ 行，每行两个整数 $u, v$，表示一次从 $u$ 到 $v$ 的查询。", "outputFormat": "共 $Q$ 行，每行一个整数，表示每个查询中 $u$ 到 $v$ 的最短路径长度。", "hint": "**样例 1 说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fcuqax1l.png)\n\n上面的地图对应于示例 1。示例 1 满足子任务 2、5、6 的约束条件。\n\n**样例 2、3 说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5b0ae9y3.png)\n\n上面的地图对应于示例 2 和示例 3。示例 2 的情况下，满足 $w_i = 0$；示例 3 的情况下，满足 $w_i = 10^{12}$。示例 2 满足子任务 4、5、6 的约束条件，示例 3 满足子任务 3、5、6 的约束条件。\n\n请注意，示例 3 中从第 12 行开始的数列：\n\n```\n1000000000000 1000000000000 1000000000000 1000000000000 1000000000000 1000000000000\n```\n\n在实际中是作为一行输入给出的，但由于篇幅限制，在此被分成了多行显示。（本段内容在正式比赛中并未提供。）\n\n**约束条件**\n\n- $4 \\leq N \\leq 100\\,000$\n- $1 \\leq p_i \\leq i$\n- $0 \\leq c_i, w_i \\leq 10^{12}$\n- $1 \\leq Q \\leq 250\\,000$\n- $1 \\leq u, v \\leq N$ 且 $u \\ne v$\n\n**子任务**\n\n1. （6 分）所有查询满足 $u = 1$\n2. （8 分）对所有 $1 \\leq i \\leq N - 1$，$p_i = 1$\n3. （5 分）对所有 $1 \\leq i \\leq N - 1$，$c_i \\leq 10^6$，并且对所有 $1 \\leq i \\leq k$，$w_i = 10^{12}$\n4. （15 分）对所有 $1 \\leq i \\leq k$，$w_i = 0$\n5. （57 分）不存在连接 4 条及以上道路的十字路口\n6. （9 分）无额外约束条件", "locale": "zh-CN"}}}
{"pid": "P12704", "type": "P", "difficulty": 6, "samples": [["2 3 6 0\nRLD\nRLU\n2 1 1 3\n2 2 1 3\n2 3 1 1\n2 3 1 2\n1 2 2 3\n1 3 2 3", "010111"], ["3 3 5 0\nDRU\nULU\nDRD\n1 1 1 3\n1 3 1 1\n3 1 2 1\n2 3 2 1\n1 1 1 1", "01111"], ["2 3 6 10000001\nRLD\nRLU", "111001"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "O2优化", "Tarjan"], "title": "Retribution", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/ij24f1iy.png?x-oss-process=image)\n", "description": "给你一个 $n\\times m$ 的棋盘，每个格点上标有一个字符 $c_{i,j}\\in\\{\\texttt{U},\\texttt{D},\\texttt{L},\\texttt{R}\\}$，分别代表上、下、左、右。在一个格点可以移动到一个与它相邻的格点，但移动方向**不能**与当前所在格点上的字符所代表的方向相同且不能移出棋盘。\n\n给出 $q$ 次询问，每次询问给出两个格点 $s,t$，询问能否从格点 $s$ 通过若干次移动到达格点 $t$。", "inputFormat": "为避免输入数据过大，本题使用特殊的读入方式。**请使用 `C++11` 及以上的语言进行编写与提交。**\n\n第一行四个正整数 $n,m,q,seed$，其中 $seed$ 为输入参数。\n\n接下来 $n$ 行，每行 $m$ 个字符描述棋盘。\n\n```cpp\nmt19937_64 R;\ninline void init(int seed){\n    R=mt19937_64(seed);\n}\ninline int get(int l,int r){\n    uniform_int_distribution<int> distribution(l,r);\n    return distribution(R);\n}\n```\n\n你需要在你的代码中加入此段代码，初始化时调用 `init(seed);`\n\n接下来 $q$ 次调用 `int a=get(1,n),b=get(1,m),x=get(1,n),y=get(1,m);`，其中 $a,b,x,y$ 分别描述 $s,t$ 的位置 $(a,b),(x,y)$，表示一次询问。", "outputFormat": "输出一行 $q$ 个字符，第 $i$ 个字符为 $0$ 表示第 $i$ 个询问中 $s$ 无法到达 $t$，为 $1$ 则表示第 $i$ 个询问中 $s$ 可以到达 $t$。", "hint": "\n**Retribution - Kry.exe & nm-y (Insane 16.2)**\n\n### 样例解释\n\n**为了便于阅读，对于样例 1 和样例 2，直接输入了询问而不使用特殊方式读入。**\n\n对于样例 1 第一次询问，格点 $(2,1)$ 无法移动出第 $1$ 列。\n\n对于样例 1 第四次询问，格点 $(2,3)$ 可以移动到 $(2,2)$ 从而移动到 $(1,2)$。\n\n对于样例 1 第六次询问，格点 $(1,3)$ 可以依次移动到 $(1,2),(2,2),(2,3)$。\n\n### 数据规模\n\n本题采用捆绑测试。\n\n| $\\text{Subtask}$ | $n\\le$ | $m\\le$ | $q\\le$ | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $100$ | $100$ | $10^3$ | $10$ |\n| $2$ | $3$ | $500$ | $2\\times10^5$ | $20$ |\n| $3$ | $300$ | $300$ | $2\\times10^5$ | $20$ |\n| $4$ | $1500$ | $1500$ | $10^6$ | $50$ |\n\n对于所有数据，保证 $1\\le n,m\\le 1.5\\times10^3$，$1\\le q\\le 10^6$，$c_{i,j}\\in\\{\\texttt{U},\\texttt{D},\\texttt{L},\\texttt{R}\\}$，$1\\le a,x\\le n$，$1\\le b,y\\le m$，$0\\le s<2^{31}$。\n\n### 子任务依赖\n\n本题开启所有合理的子任务依赖。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Retribution", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/ij24f1iy.png?x-oss-process=image)\n", "description": "给你一个 $n\\times m$ 的棋盘，每个格点上标有一个字符 $c_{i,j}\\in\\{\\texttt{U},\\texttt{D},\\texttt{L},\\texttt{R}\\}$，分别代表上、下、左、右。在一个格点可以移动到一个与它相邻的格点，但移动方向**不能**与当前所在格点上的字符所代表的方向相同且不能移出棋盘。\n\n给出 $q$ 次询问，每次询问给出两个格点 $s,t$，询问能否从格点 $s$ 通过若干次移动到达格点 $t$。", "inputFormat": "为避免输入数据过大，本题使用特殊的读入方式。**请使用 `C++11` 及以上的语言进行编写与提交。**\n\n第一行四个正整数 $n,m,q,seed$，其中 $seed$ 为输入参数。\n\n接下来 $n$ 行，每行 $m$ 个字符描述棋盘。\n\n```cpp\nmt19937_64 R;\ninline void init(int seed){\n    R=mt19937_64(seed);\n}\ninline int get(int l,int r){\n    uniform_int_distribution<int> distribution(l,r);\n    return distribution(R);\n}\n```\n\n你需要在你的代码中加入此段代码，初始化时调用 `init(seed);`\n\n接下来 $q$ 次调用 `int a=get(1,n),b=get(1,m),x=get(1,n),y=get(1,m);`，其中 $a,b,x,y$ 分别描述 $s,t$ 的位置 $(a,b),(x,y)$，表示一次询问。", "outputFormat": "输出一行 $q$ 个字符，第 $i$ 个字符为 $0$ 表示第 $i$ 个询问中 $s$ 无法到达 $t$，为 $1$ 则表示第 $i$ 个询问中 $s$ 可以到达 $t$。", "hint": "\n**Retribution - Kry.exe & nm-y (Insane 16.2)**\n\n### 样例解释\n\n**为了便于阅读，对于样例 1 和样例 2，直接输入了询问而不使用特殊方式读入。**\n\n对于样例 1 第一次询问，格点 $(2,1)$ 无法移动出第 $1$ 列。\n\n对于样例 1 第四次询问，格点 $(2,3)$ 可以移动到 $(2,2)$ 从而移动到 $(1,2)$。\n\n对于样例 1 第六次询问，格点 $(1,3)$ 可以依次移动到 $(1,2),(2,2),(2,3)$。\n\n### 数据规模\n\n本题采用捆绑测试。\n\n| $\\text{Subtask}$ | $n\\le$ | $m\\le$ | $q\\le$ | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $100$ | $100$ | $10^3$ | $10$ |\n| $2$ | $3$ | $500$ | $2\\times10^5$ | $20$ |\n| $3$ | $300$ | $300$ | $2\\times10^5$ | $20$ |\n| $4$ | $1500$ | $1500$ | $10^6$ | $50$ |\n\n对于所有数据，保证 $1\\le n,m\\le 1.5\\times10^3$，$1\\le q\\le 10^6$，$c_{i,j}\\in\\{\\texttt{U},\\texttt{D},\\texttt{L},\\texttt{R}\\}$，$1\\le a,x\\le n$，$1\\le b,y\\le m$，$0\\le s<2^{31}$。\n\n### 子任务依赖\n\n本题开启所有合理的子任务依赖。", "locale": "zh-CN"}}}
{"pid": "P12705", "type": "P", "difficulty": 6, "samples": [["5 10\n<0\n01\n11\n10\n60\n2 5\n4 5\n1 5\n1 3\n1 3\n1 3\n4 5\n3 5\n3 4\n4 5", "No\nYes\nYes\nNo\nYes\nNo\nNo\nNo\nNo\nNo"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "O2优化"], "title": "呃呃", "background": null, "description": "给你一张 $n$ 个点的简单无向图。\n\n接下来有 $q$ 次操作，每次操作为添加一条边或删去一条边，请在每次操作后判断图中是否有四元环。", "inputFormat": "**本题有特殊的读入格式，具体见下发文件的 `duru.cpp`。**\n\n第一行两个整数 $n,q$。\n\n接下来读入一个 $n\\times n$ 的 $01$ 矩阵表示这张图的邻接矩阵 $a_{1\\dots n,1\\dots n}$，**这部分采用特殊的方法读入**。\n\n接下来 $q$ 行，每行两个整数 $u,v$。若 $(u,v)$ 这条边存在则本次操作为将其删去，否则本次操作为将其加入。", "outputFormat": "共 $q$ 行，每行一个字符串 `Yes` 或 `No`。", "hint": "### 样例解释 #1\n读入的邻接矩阵解密后为：\n```cpp\n00110\n00001\n10001\n10000\n01100\n```\n即初始有边 $(1,3),(1,4),(2,5),(3,5)$。\n\n第二次操作后有 $(1,3),(1,4),(4,5),(3,5)$ 四条边，存在一个四元环 $(3,1,4,5)$。\n\n第五次操作后有 $(1,3),(1,5),(1,4),(4,5),(3,5)$ 五条边，存在一个四元环 $(3,1,4,5)$。\n\n第十次操作后有 $(1,4),(1,5),(3,4),(4,5)$ 四条边，不存在四元环。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $n,q\\le$ | 分数 | \n| :-----: | :-----:  |  :-----: | \n| $1$ | $50$ |$5$ | \n| $2$ | $100$ |$10$ | \n| $3$ | $1000$ |$20$ | \n| $4$ | $5000$ |$30$ | \n| $5$ | $10^4$ |$35$ | \n\n对于所有数据，保证 $1\\le n,q \\le 10^4$，$1\\le u,v\\le n$，$u\\ne v$，$a_{i,j}=a_{j,i}$，$a_{i,i}=0$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "呃呃", "background": null, "description": "给你一张 $n$ 个点的简单无向图。\n\n接下来有 $q$ 次操作，每次操作为添加一条边或删去一条边，请在每次操作后判断图中是否有四元环。", "inputFormat": "**本题有特殊的读入格式，具体见下发文件的 `duru.cpp`。**\n\n第一行两个整数 $n,q$。\n\n接下来读入一个 $n\\times n$ 的 $01$ 矩阵表示这张图的邻接矩阵 $a_{1\\dots n,1\\dots n}$，**这部分采用特殊的方法读入**。\n\n接下来 $q$ 行，每行两个整数 $u,v$。若 $(u,v)$ 这条边存在则本次操作为将其删去，否则本次操作为将其加入。", "outputFormat": "共 $q$ 行，每行一个字符串 `Yes` 或 `No`。", "hint": "### 样例解释 #1\n读入的邻接矩阵解密后为：\n```cpp\n00110\n00001\n10001\n10000\n01100\n```\n即初始有边 $(1,3),(1,4),(2,5),(3,5)$。\n\n第二次操作后有 $(1,3),(1,4),(4,5),(3,5)$ 四条边，存在一个四元环 $(3,1,4,5)$。\n\n第五次操作后有 $(1,3),(1,5),(1,4),(4,5),(3,5)$ 五条边，存在一个四元环 $(3,1,4,5)$。\n\n第十次操作后有 $(1,4),(1,5),(3,4),(4,5)$ 四条边，不存在四元环。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $n,q\\le$ | 分数 | \n| :-----: | :-----:  |  :-----: | \n| $1$ | $50$ |$5$ | \n| $2$ | $100$ |$10$ | \n| $3$ | $1000$ |$20$ | \n| $4$ | $5000$ |$30$ | \n| $5$ | $10^4$ |$35$ | \n\n对于所有数据，保证 $1\\le n,q \\le 10^4$，$1\\le u,v\\le n$，$u\\ne v$，$a_{i,j}=a_{j,i}$，$a_{i,i}=0$。", "locale": "zh-CN"}}}
{"pid": "P12706", "type": "P", "difficulty": 6, "samples": [["3 5", "111\n010\n100"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "Special Judge", "O2优化", "构造", "Ad-hoc"], "title": "蜜蜂构造题", "background": "给你一张 $n$ 个点的简单无向图。\n\n接下来有 $q$ 次操作，每次操作为添加一条边或删去一条边，请在每次操作后判断图中是否有四元环。\n\n等等，题面放错了。\n\n并非呃呃 / bee。\n\n---\n在「[呃呃 / ee](https://www.luogu.com.cn/problem/P12705)」一题中，如何构造数据成为了一个难题。\n\n当初始边数过小时，可能会让一些 $O(m\\sqrt m)$ 的做法得以通过，而初始边数过大时又随机不出一张无四元环的初始图。\n\n给你一道呃呃，输出一组足够强力的数据。", "description": "给你一个整数 $n$，有一集合 $U=\\{1,2,\\dots,n\\}$。\n\n你需要构造 $n$ 个集合 $S_{1,2,\\dots ,n}$，满足条件：\n- 对所有 $1\\le i \\le n$，$S_i\\sube U$；\n- 对所有 $1\\le i<j\\le n$，$|S_i\\cap S_j|\\le 1$。\n\n为了不让暴力通过，你希望 $\\displaystyle\\sum_{i=1}^n|S_i|$ 尽量大。", "inputFormat": "一行两个整数 $n,L$，关于 $L$ 的信息见「数据规模与约定」部分。", "outputFormat": "输出 $n$ 行，每行一个长为 $n$ 的 `01` 字符串。\n\n若第 $i$ 行第 $j$ 列的字符为 `1`，代表 $j\\in S_i$，否则代表 $j\\notin S_i$。", "hint": "### 数据规模与约定\n为了衡量你的构造强度，你将会得到一个整数 $L$。\n\n对于每个数据点，你需要构造出一组解使得 $\\sum_{i=1}^n|S_i|\\ge L$。\n\n::cute-table\n| 数据点编号 | $n=$ | $L=$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $4$ | $8$ | $10$ |\n| $2$ | $10$ | $23$ | $10$ |\n| $3$ | $2333$ | $4666$ | $10$ |\n| $4$ | ^ | $6996$ | $10$ |\n| $5$ | ^ | $10^4$ | $10$ |\n| $6$ | ^ | $2\\times 10^4$ | $10$ |\n| $7$ | ^ | $4\\times 10^4$ | $10$ |\n| $8$ | ^ | $6\\times 10^4$ | $10$ |\n| $9$ | ^ | $8\\times 10^4$ | $10$ |\n| $10$ | ^ | $10^5$ | $10$ |\n\n对于所有数据，保证 $4\\le n\\le 2333$。\n\n### 提示\n\n构造一张左右部点数均为 $n$ 的二分图，对于所有 $1\\le i,j\\le n$，左侧点 $i$ 与右侧点 $j$ 之间有边当且仅当 $j\\in S_i$。容易验证，此时构造出的图中无四元环。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "蜜蜂构造题", "background": "给你一张 $n$ 个点的简单无向图。\n\n接下来有 $q$ 次操作，每次操作为添加一条边或删去一条边，请在每次操作后判断图中是否有四元环。\n\n等等，题面放错了。\n\n并非呃呃 / bee。\n\n---\n在「[呃呃 / ee](https://www.luogu.com.cn/problem/P12705)」一题中，如何构造数据成为了一个难题。\n\n当初始边数过小时，可能会让一些 $O(m\\sqrt m)$ 的做法得以通过，而初始边数过大时又随机不出一张无四元环的初始图。\n\n给你一道呃呃，输出一组足够强力的数据。", "description": "给你一个整数 $n$，有一集合 $U=\\{1,2,\\dots,n\\}$。\n\n你需要构造 $n$ 个集合 $S_{1,2,\\dots ,n}$，满足条件：\n- 对所有 $1\\le i \\le n$，$S_i\\sube U$；\n- 对所有 $1\\le i<j\\le n$，$|S_i\\cap S_j|\\le 1$。\n\n为了不让暴力通过，你希望 $\\displaystyle\\sum_{i=1}^n|S_i|$ 尽量大。", "inputFormat": "一行两个整数 $n,L$，关于 $L$ 的信息见「数据规模与约定」部分。", "outputFormat": "输出 $n$ 行，每行一个长为 $n$ 的 `01` 字符串。\n\n若第 $i$ 行第 $j$ 列的字符为 `1`，代表 $j\\in S_i$，否则代表 $j\\notin S_i$。", "hint": "### 数据规模与约定\n为了衡量你的构造强度，你将会得到一个整数 $L$。\n\n对于每个数据点，你需要构造出一组解使得 $\\sum_{i=1}^n|S_i|\\ge L$。\n\n::cute-table\n| 数据点编号 | $n=$ | $L=$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $4$ | $8$ | $10$ |\n| $2$ | $10$ | $23$ | $10$ |\n| $3$ | $2333$ | $4666$ | $10$ |\n| $4$ | ^ | $6996$ | $10$ |\n| $5$ | ^ | $10^4$ | $10$ |\n| $6$ | ^ | $2\\times 10^4$ | $10$ |\n| $7$ | ^ | $4\\times 10^4$ | $10$ |\n| $8$ | ^ | $6\\times 10^4$ | $10$ |\n| $9$ | ^ | $8\\times 10^4$ | $10$ |\n| $10$ | ^ | $10^5$ | $10$ |\n\n对于所有数据，保证 $4\\le n\\le 2333$。\n\n### 提示\n\n构造一张左右部点数均为 $n$ 的二分图，对于所有 $1\\le i,j\\le n$，左侧点 $i$ 与右侧点 $j$ 之间有边当且仅当 $j\\in S_i$。容易验证，此时构造出的图中无四元环。", "locale": "zh-CN"}}}
{"pid": "P12707", "type": "P", "difficulty": 2, "samples": [["1", "1"], ["2", "2"], ["5", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "KOI（韩国）"], "title": "[KOI 2021 Round 1] 橡皮擦", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "在 $N$ 个格子中，从左到右依次存放着从 1 到 $N$ 的数字。每个格子也从左到右依次编号为 1 到 $N$。也就是说，初始时每个格子的编号和格子中存储的数字是相同的。\n\n下图是当 $N = 7$ 时的示例：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n9ebwkua.png)\n\n重复执行以下操作，直到只剩下一个数字为止：\n\n- (A) 删除所有奇数编号格子中的数字  \n- (B) 将剩下的数字向左移动，紧凑排列  \n\n第一次操作中的 (A) 步骤完成后，格子的状态如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q7zyp41w.png)\n\n然后执行 (B) 步骤后，格子如下所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q9rg813t.png)\n\n当进行第二次操作时，格子的变化如下两图所示：\n\n第一步 (A) 之后：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t91cplt8.png)\n\n接着进行 (B) 之后：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j1rjvbz5.png)\n\n此时只剩下一个数字，因此不再进行操作。\n\n请你编写一个程序，输入 $N$，按照上述方式进行操作，计算并输出最后剩下的数字。", "inputFormat": "第一行输入一个整数 $N$。", "outputFormat": "输出最后剩下的数字，占据一行。", "hint": "**约束条件**\n\n- $1 \\leq N \\leq 100$\n\n**子任务**\n\n1. （5 分）仅给出输入输出样例  \n2. （15 分）$N \\leq 8$  \n3. （30 分）$N$ 是以下数之一：$1, 2, 4, 8, 16, 32, 64$，即 $N$ 是 $1$ 或 $2$ 的若干次幂  \n4. （50 分）无附加约束条件", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2021 Round 1] 橡皮擦", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "在 $N$ 个格子中，从左到右依次存放着从 1 到 $N$ 的数字。每个格子也从左到右依次编号为 1 到 $N$。也就是说，初始时每个格子的编号和格子中存储的数字是相同的。\n\n下图是当 $N = 7$ 时的示例：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n9ebwkua.png)\n\n重复执行以下操作，直到只剩下一个数字为止：\n\n- (A) 删除所有奇数编号格子中的数字  \n- (B) 将剩下的数字向左移动，紧凑排列  \n\n第一次操作中的 (A) 步骤完成后，格子的状态如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q7zyp41w.png)\n\n然后执行 (B) 步骤后，格子如下所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q9rg813t.png)\n\n当进行第二次操作时，格子的变化如下两图所示：\n\n第一步 (A) 之后：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t91cplt8.png)\n\n接着进行 (B) 之后：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j1rjvbz5.png)\n\n此时只剩下一个数字，因此不再进行操作。\n\n请你编写一个程序，输入 $N$，按照上述方式进行操作，计算并输出最后剩下的数字。", "inputFormat": "第一行输入一个整数 $N$。", "outputFormat": "输出最后剩下的数字，占据一行。", "hint": "**约束条件**\n\n- $1 \\leq N \\leq 100$\n\n**子任务**\n\n1. （5 分）仅给出输入输出样例  \n2. （15 分）$N \\leq 8$  \n3. （30 分）$N$ 是以下数之一：$1, 2, 4, 8, 16, 32, 64$，即 $N$ 是 $1$ 或 $2$ 的若干次幂  \n4. （50 分）无附加约束条件", "locale": "zh-CN"}}}
{"pid": "P12708", "type": "P", "difficulty": 3, "samples": [["4\n1 1 1 1", "1"], ["10\n4 -1 2 1 -3 1 2 2 1 3", "3"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "KOI（韩国）"], "title": "[KOI 2021 Round 1] 分割", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "给定一个由 $N$ 个整数组成的数列 $A_1, A_2, \\ldots, A_N$。我们想将该数列划分为连续的四个部分，每个部分至少包含一个数，且每一部分的数字之和必须相等。\n\n也就是说，存在整数 $i, j, k$（满足 $1 \\leq i < j < k < N$），使得将数列划分为以下四段：\n\n- $[A_1, \\ldots, A_i]$\n- $[A_{i+1}, \\ldots, A_j]$\n- $[A_{j+1}, \\ldots, A_k]$\n- $[A_{k+1}, \\ldots, A_N]$\n\n例如，若给定的数列是：\n\n$$4, -1, 2, 1, -3, 1, 2, 2, 1, 3$$\n\n若分成以下四段：\n\n$$[4, -1, 2], [1, -3, 1, 2], [2, 1], [3]$$\n\n则每部分的和不同，不符合条件。\n\n若分为：\n\n$$[4, -1], [2, 1], [-3, 1, 2, 2, 1], [3]$$\n\n则每一部分的和都相同，符合条件。\n\n以下划分方式也符合条件：\n\n- $[4, -1], [2, 1, -3, 1, 2], [2, 1], [3]$  \n- $[4, -1, 2, 1, -3], [1, 2], [2, 1], [3]$\n\n请你编写一个程序，输入数列，计算上述方式下，满足要求的不同划分方法的总数。", "inputFormat": "第一行输入整数 $N$。\n\n第二行输入 $N$ 个整数 $A_1, A_2, \\ldots, A_N$，用空格隔开。", "outputFormat": "输出满足条件的划分方法总数，占据一行。\n\n（提示：输出结果可能很大，请在 C/C++ 中使用 `long long` 类型，在 Java 中使用 `long` 类型。）\n", "hint": "**约束条件**\n\n- $4 \\leq N \\leq 100\\,000$\n- 对所有 $1 \\leq i \\leq N$，有 $-1\\,000 \\leq A_i \\leq 1\\,000$\n\n**子任务**\n\n1. （5 分）所有 $A_i = 0$  \n2. （7 分）所有 $A_i > 0$  \n3. （4 分）所有 $A_i \\geq 0$  \n4. （11 分）$N \\leq 10$  \n5. （19 分）$N \\leq 500$  \n6. （23 分）$N \\leq 5\\,000$  \n7. （31 分）无附加约束条件", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2021 Round 1] 分割", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "给定一个由 $N$ 个整数组成的数列 $A_1, A_2, \\ldots, A_N$。我们想将该数列划分为连续的四个部分，每个部分至少包含一个数，且每一部分的数字之和必须相等。\n\n也就是说，存在整数 $i, j, k$（满足 $1 \\leq i < j < k < N$），使得将数列划分为以下四段：\n\n- $[A_1, \\ldots, A_i]$\n- $[A_{i+1}, \\ldots, A_j]$\n- $[A_{j+1}, \\ldots, A_k]$\n- $[A_{k+1}, \\ldots, A_N]$\n\n例如，若给定的数列是：\n\n$$4, -1, 2, 1, -3, 1, 2, 2, 1, 3$$\n\n若分成以下四段：\n\n$$[4, -1, 2], [1, -3, 1, 2], [2, 1], [3]$$\n\n则每部分的和不同，不符合条件。\n\n若分为：\n\n$$[4, -1], [2, 1], [-3, 1, 2, 2, 1], [3]$$\n\n则每一部分的和都相同，符合条件。\n\n以下划分方式也符合条件：\n\n- $[4, -1], [2, 1, -3, 1, 2], [2, 1], [3]$  \n- $[4, -1, 2, 1, -3], [1, 2], [2, 1], [3]$\n\n请你编写一个程序，输入数列，计算上述方式下，满足要求的不同划分方法的总数。", "inputFormat": "第一行输入整数 $N$。\n\n第二行输入 $N$ 个整数 $A_1, A_2, \\ldots, A_N$，用空格隔开。", "outputFormat": "输出满足条件的划分方法总数，占据一行。\n\n（提示：输出结果可能很大，请在 C/C++ 中使用 `long long` 类型，在 Java 中使用 `long` 类型。）\n", "hint": "**约束条件**\n\n- $4 \\leq N \\leq 100\\,000$\n- 对所有 $1 \\leq i \\leq N$，有 $-1\\,000 \\leq A_i \\leq 1\\,000$\n\n**子任务**\n\n1. （5 分）所有 $A_i = 0$  \n2. （7 分）所有 $A_i > 0$  \n3. （4 分）所有 $A_i \\geq 0$  \n4. （11 分）$N \\leq 10$  \n5. （19 分）$N \\leq 500$  \n6. （23 分）$N \\leq 5\\,000$  \n7. （31 分）无附加约束条件", "locale": "zh-CN"}}}
{"pid": "P12709", "type": "P", "difficulty": 3, "samples": [["7\n9 9 4 1 4 9 9", "57"], ["3\n2 5 4", "10"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "KOI（韩国）"], "title": "[KOI 2021 Round 1] 采蜜", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "如下图所示，从左到右排列着 $N$ 个位置。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7qartslo.png)\n\n从这些位置中选择两个**不同**的位置，各放置一只蜜蜂；再从剩下的位置中选择一个位置放置蜂巢。如下图所示，浅灰色的位置表示蜜蜂所在位置，深灰色的位置表示蜂巢所在位置。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cwt2drd5.png)\n\n两只蜜蜂会笔直地朝着蜂巢飞行，并在途中经过的每一个位置采集蜂蜜。每个位置上标注的数字表示蜜蜂经过时可以采集到的蜂蜜数量。\n\n1. 如果两只蜜蜂都经过了某个位置，则它们都会各自采集标注的数量（包括蜂巢所在位置）。\n2. 蜜蜂在起始位置不会采蜜。\n\n当按如下图所示进行布置时，两只蜜蜂各自会采到 $4 + 1 + 4 + 9 + 9 = 27$ 的蜂蜜，总共为 $54$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2mwrw0ww.png)\n\n当按如下图所示进行布置时，从最左侧位置出发的蜜蜂会采到 $9 + 4 + 4 + 9 + 9 = 35$ 的蜂蜜，另一只蜜蜂会采到 $4 + 9 + 9 = 22$ 的蜂蜜，总共为 $57$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r9g05w98.png)\n\n而当按另一种方式布置时，总蜂蜜量为 $31$。\n\n请你编写一个程序，输入每个位置上蜂蜜的数量，计算蜜蜂能够采集到的最大蜂蜜总量。", "inputFormat": "第一行输入一个整数 $N$，表示位置数量。\n\n第二行输入 $N$ 个整数，表示从左到右各个位置的蜂蜜数量，数字之间以空格分隔。", "outputFormat": "输出一个整数，表示蜜蜂能够采集到的最大蜂蜜总量，占据一行。", "hint": "**约束条件**\n\n- $3 \\leq N \\leq 100\\,000$\n- 每个位置的蜂蜜数量是 $1$ 到 $10\\,000$ 之间的整数\n\n**子任务**\n\n1. （11 分）$N \\leq 20$\n2. （13 分）$N \\leq 500$\n3. （31 分）$N \\leq 5\\,000$\n4. （45 分）无附加约束条件", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2021 Round 1] 采蜜", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "如下图所示，从左到右排列着 $N$ 个位置。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7qartslo.png)\n\n从这些位置中选择两个**不同**的位置，各放置一只蜜蜂；再从剩下的位置中选择一个位置放置蜂巢。如下图所示，浅灰色的位置表示蜜蜂所在位置，深灰色的位置表示蜂巢所在位置。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cwt2drd5.png)\n\n两只蜜蜂会笔直地朝着蜂巢飞行，并在途中经过的每一个位置采集蜂蜜。每个位置上标注的数字表示蜜蜂经过时可以采集到的蜂蜜数量。\n\n1. 如果两只蜜蜂都经过了某个位置，则它们都会各自采集标注的数量（包括蜂巢所在位置）。\n2. 蜜蜂在起始位置不会采蜜。\n\n当按如下图所示进行布置时，两只蜜蜂各自会采到 $4 + 1 + 4 + 9 + 9 = 27$ 的蜂蜜，总共为 $54$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2mwrw0ww.png)\n\n当按如下图所示进行布置时，从最左侧位置出发的蜜蜂会采到 $9 + 4 + 4 + 9 + 9 = 35$ 的蜂蜜，另一只蜜蜂会采到 $4 + 9 + 9 = 22$ 的蜂蜜，总共为 $57$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r9g05w98.png)\n\n而当按另一种方式布置时，总蜂蜜量为 $31$。\n\n请你编写一个程序，输入每个位置上蜂蜜的数量，计算蜜蜂能够采集到的最大蜂蜜总量。", "inputFormat": "第一行输入一个整数 $N$，表示位置数量。\n\n第二行输入 $N$ 个整数，表示从左到右各个位置的蜂蜜数量，数字之间以空格分隔。", "outputFormat": "输出一个整数，表示蜜蜂能够采集到的最大蜂蜜总量，占据一行。", "hint": "**约束条件**\n\n- $3 \\leq N \\leq 100\\,000$\n- 每个位置的蜂蜜数量是 $1$ 到 $10\\,000$ 之间的整数\n\n**子任务**\n\n1. （11 分）$N \\leq 20$\n2. （13 分）$N \\leq 500$\n3. （31 分）$N \\leq 5\\,000$\n4. （45 分）无附加约束条件", "locale": "zh-CN"}}}
{"pid": "P12710", "type": "P", "difficulty": 4, "samples": [["4\n3 -1\n-2 1\n2 2\n-1 1", "5"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "树形 DP", "KOI（韩国）"], "title": "[KOI 2021 Round 1] 两个团队", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "某公司的组织架构可以用一棵有根树（rooted tree）来表示。树中的每个节点表示一名员工，边表示直属上下级关系。每位员工从 $1$ 到 $N$ 编号，其中编号 $1$ 的员工是公司的总裁，即树的根节点。每位员工都有一个整数形式的“能力值”，该能力值可能为负数。\n\n下面是一棵示意组织树的例子，节点内的数字表示员工编号。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yblc9z43.png)\n\n现在希望从中选择若干人担任“团队负责人”。每位团队负责人必须组成自己的团队，团队必须满足以下条件：\n\n1. 团队成员必须是该负责人下属员工（不一定是直属下属）。例如，如果员工 $3$ 是负责人，那么员工 $8$ 或 $11$ 可以是团队成员，但员工 $1$ 或 $9$ 不可以。\n2. 如果某员工被包含为团队成员，那么该员工的直属上司也必须被包含为团队成员（负责人除外）。例如，若员工 $3$ 是负责人，则团队为 $\\{3, 6, 11\\}$ 是合法的，但 $\\{3, 8, 11\\}$ 是不合法的，因为员工 $11$ 的上司 $6$ 没有被包含。\n3. 团队的得分定义为团队负责人及所有成员的能力值总和，团队成员的选择必须使团队得分最大。（若得分最大的团队组成不唯一，可任选其一。）例如，在所有员工的能力值均为正的情况下，若员工 $3$ 被选为负责人，则其团队必须为 $\\{3, 6, 7, 8, 11, 12\\}$，其中任何一人缺席都不被允许。\n4. 员工不能同时属于两个团队（包括不能作为另一个团队的负责人）。也就是说，若某员工 $A$ 是负责人，其下属 $B$ 由于第 3 条必须包含进 $A$ 的团队，则 $A$ 和 $B$ 都不能被选为负责人。\n\n公司最终希望选出两名团队负责人，组成两个团队，使这两个团队的得分总和（即所有成员能力值之和的总和）最大。\n\n请你编写一个程序，计算在满足所有约束条件的前提下，这两个团队得分之和的最大值。\n\n输入保证一定存在合法的两个团队的构成方式。", "inputFormat": "第一行输入一个整数 $N$，表示员工人数。\n\n接下来的 $N$ 行中，每行输入两个整数，分别表示第 $i$ 位员工的能力值和直属上司的编号，两数之间以空格分隔。其中员工 $1$ 没有上司，因此其上司编号为 $-1$。\n", "outputFormat": "输出一个整数，表示两个团队得分之和的最大值，占据一行。\n\n（提示：输出结果可能非常大，请在 C/C++ 中使用 `long long` 类型，在 Java 中使用 `long` 类型。）\n", "hint": "**约束条件**\n\n- $2 \\leq N \\leq 200\\,000$\n- 每名员工的能力值在 $-1\\,000\\,000\\,000$ 到 $1\\,000\\,000\\,000$ 之间\n- 除员工 $1$ 外的每位员工 $i$ 的直属上司编号不超过 $i - 1$\n- 输入保证一定可以构成符合要求的两个团队\n\n**子任务**\n\n1. （17 分）所有员工的能力值均为正数  \n2. （12 分）$N \\leq 5\\,000$，且员工 $i$ 的直属上司为 $i - 1$（员工 $1$ 除外）  \n3. （20 分）员工 $i$ 的直属上司为 $i - 1$（员工 $1$ 除外）  \n4. （16 分）$N \\leq 400$  \n5. （17 分）$N \\leq 5\\,000$  \n6. （18 分）无附加约束条件", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2021 Round 1] 两个团队", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "某公司的组织架构可以用一棵有根树（rooted tree）来表示。树中的每个节点表示一名员工，边表示直属上下级关系。每位员工从 $1$ 到 $N$ 编号，其中编号 $1$ 的员工是公司的总裁，即树的根节点。每位员工都有一个整数形式的“能力值”，该能力值可能为负数。\n\n下面是一棵示意组织树的例子，节点内的数字表示员工编号。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yblc9z43.png)\n\n现在希望从中选择若干人担任“团队负责人”。每位团队负责人必须组成自己的团队，团队必须满足以下条件：\n\n1. 团队成员必须是该负责人下属员工（不一定是直属下属）。例如，如果员工 $3$ 是负责人，那么员工 $8$ 或 $11$ 可以是团队成员，但员工 $1$ 或 $9$ 不可以。\n2. 如果某员工被包含为团队成员，那么该员工的直属上司也必须被包含为团队成员（负责人除外）。例如，若员工 $3$ 是负责人，则团队为 $\\{3, 6, 11\\}$ 是合法的，但 $\\{3, 8, 11\\}$ 是不合法的，因为员工 $11$ 的上司 $6$ 没有被包含。\n3. 团队的得分定义为团队负责人及所有成员的能力值总和，团队成员的选择必须使团队得分最大。（若得分最大的团队组成不唯一，可任选其一。）例如，在所有员工的能力值均为正的情况下，若员工 $3$ 被选为负责人，则其团队必须为 $\\{3, 6, 7, 8, 11, 12\\}$，其中任何一人缺席都不被允许。\n4. 员工不能同时属于两个团队（包括不能作为另一个团队的负责人）。也就是说，若某员工 $A$ 是负责人，其下属 $B$ 由于第 3 条必须包含进 $A$ 的团队，则 $A$ 和 $B$ 都不能被选为负责人。\n\n公司最终希望选出两名团队负责人，组成两个团队，使这两个团队的得分总和（即所有成员能力值之和的总和）最大。\n\n请你编写一个程序，计算在满足所有约束条件的前提下，这两个团队得分之和的最大值。\n\n输入保证一定存在合法的两个团队的构成方式。", "inputFormat": "第一行输入一个整数 $N$，表示员工人数。\n\n接下来的 $N$ 行中，每行输入两个整数，分别表示第 $i$ 位员工的能力值和直属上司的编号，两数之间以空格分隔。其中员工 $1$ 没有上司，因此其上司编号为 $-1$。\n", "outputFormat": "输出一个整数，表示两个团队得分之和的最大值，占据一行。\n\n（提示：输出结果可能非常大，请在 C/C++ 中使用 `long long` 类型，在 Java 中使用 `long` 类型。）\n", "hint": "**约束条件**\n\n- $2 \\leq N \\leq 200\\,000$\n- 每名员工的能力值在 $-1\\,000\\,000\\,000$ 到 $1\\,000\\,000\\,000$ 之间\n- 除员工 $1$ 外的每位员工 $i$ 的直属上司编号不超过 $i - 1$\n- 输入保证一定可以构成符合要求的两个团队\n\n**子任务**\n\n1. （17 分）所有员工的能力值均为正数  \n2. （12 分）$N \\leq 5\\,000$，且员工 $i$ 的直属上司为 $i - 1$（员工 $1$ 除外）  \n3. （20 分）员工 $i$ 的直属上司为 $i - 1$（员工 $1$ 除外）  \n4. （16 分）$N \\leq 400$  \n5. （17 分）$N \\leq 5\\,000$  \n6. （18 分）无附加约束条件", "locale": "zh-CN"}}}
