{"pid": "P12812", "type": "P", "difficulty": 0, "samples": [["2\n2\n0 0 1 1 1 1\n1 1 2 2 -1 -1\n3\n0 0\n0.25 0.25\n0 2\n3\n0 0 1 1 2 2\n0 0 1 1 1 1\n1 1 2 2 -1 -1\n1\n0 2", "0.000000000\n0.250000000\n1.000000000\n0.444444444"]], "limits": {"time": [10000, 10000, 10000], "memory": [524288, 524288, 524288]}, "tags": ["2019", "Special Judge", "ICPC"], "title": "[AMPPZ 2019] Ghost", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "\n在克拉科夫参观瓦维尔城堡时，你的团队被幽灵困在了一个古老的密室中。除非你们能回答他的问题，否则他不会放你们出去。\n\n墙上挂着 $n$ 幅画作——如果将墙面视为标准的欧几里得平面，这些画作都是轴对齐的矩形。对于每幅画作，你都确切知道其尺寸和起始位置。在某个时刻——我们称之为时刻 0——幽灵开始移动这些画作，每幅画以各自的方向和速度移动。由于你们团队观察力敏锐，可以轻松推测出每幅画的确切速度。\n\n一段时间后，幽灵停止了表演并开始提出棘手的问题。每个问题由两个数字 $l$ 和 $r$ 组成，表示表演的某些时刻。你必须告诉幽灵在 $l$ 到 $r$ 之间是否存在某个时刻，墙上的某个点同时被所有画作覆盖。如果是这样，你还需确定在 $l$ 到 $r$ 之间所有画作的最大可能公共面积。\n\n如果你们想离开这个房间，最好给幽灵正确的答案！\n", "inputFormat": "\n**本题单个测试点内有多组测试数据。**\n\n输入的第一行包含测试数据组数 $z$ ($1 \\le z \\le 4000$)。每组测试数据的格式如下：\n\n每组测试数据的第一行包含画作数量 $n$ ($1 \\le n \\le 100000$)。接下来的 $n$ 行每行包含六个数字  \n$x_1, y_1, x_2, y_2, v_x, v_y$  \n($-1000000 \\le x_1 < x_2 \\le 1000000$；  \n$-1000000 \\le y_1 < y_2 \\le 1000000$；  \n$-1000000 \\le v_x, v_y \\le 1000000$)，  \n其中 $(x_1, y_1)$ 是画作左下角的坐标，$(x_2, y_2)$ 是右上角的坐标，$(v_x, v_y)$ 是其速度向量。这意味着在时刻 $t$，左下角位于点 $(x_1 + t v_x, y_1 + t v_y)$，右上角位于 $(x_2 + t v_x, y_2 + t v_y)$。\n\n接下来一行包含幽灵的问题数量 $q$ ($1 \\le q \\le 100000$)。随后的 $q$ 行每行包含两个实数 $l$, $r$ ($0 \\le l \\le r \\le 1000000$)，小数点后最多 4 位，表示幽灵询问的闭时间区间 $[l, r]$。\n\n所有测试数据中画作的总数不超过 1000000。  \n所有测试数据中问题的总数也不超过 1000000。\n", "outputFormat": "\n对于幽灵的每个问题，输出一个实数——给定时间区间内所有画作交集的最大面积。如果绝对误差或相对误差不超过 $10^{-6}$，你的答案将被视为正确。换句话说，如果你的程序输出 $a$ 而正确值为 $b$，当满足以下条件时答案被接受：\n\n$$\n\\frac{|a - b|}{\\max(1, b)} \\le 10^{-6}\n$$\n\n交集可能为空——此时你的程序应输出 $0$ ($\\pm 10^{-6}$)。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AMPPZ 2019] Ghost", "background": "\n**Time limit: 10s, memory limit: 512MB.**\n", "description": "\nWhile sightseeing the Wawel castle in Kraków, your team has been trapped in an ancient chamber by the Ghost. He will not let you out, unless you answer his questions.\n\nOn the wall there are $n$ paintings – if we treat the wall as a standard Euclidean plane, the paintings are axis-aligned rectangles. For every painting you know precisely its dimensions and starting location. In some moment – let us call it the moment 0 – Ghost starts moving the paintings, each one in its own direction and speed. As you are an observant team, for every painting you can easily guess its exact speed.\n\nAfter some time, the Ghost stops the show and starts asking tough questions. Every question consists of two numbers $l$ and $r$ denoting some moments of the show. You must tell Ghost if there was a moment between $l$ and $r$ when some spot on the wall was simultaneously covered by all the paintings. If so, you must also determine the maximal possible common area for all paintings between the moments $l$ and $r$.\n\nIf you want to ever leave this room, better give Ghost the right answers!\n", "inputFormat": "\nThe first line of input contains the number of test cases $z$ ($1 \\le z \\le 4000$). The test cases follow, each one in the following format:\n\nThe first line of a test case contains the number of paintings $n$ ($1 \\le n \\le 100000$). Each of the following $n$ lines contains six numbers  \n$x_1, y_1, x_2, y_2, v_x, v_y$  \n($-1000000 \\le x_1 < x_2 \\le 1000000$;  \n$-1000000 \\le y_1 < y_2 \\le 1000000$;  \n$-1000000 \\le v_x, v_y \\le 1000000$),  \nwhere $(x_1, y_1)$ are the coordinates of the lower left corner of the painting, $(x_2, y_2)$ – the upper right corner, and $(v_x, v_y)$ is its speed vector. This means that in the moment $t$ the lower left corner is at the spot $(x_1 + t v_x, y_1 + t v_y)$, and the upper right corner is at $(x_2 + t v_x, y_2 + t v_y)$.\n\nThe next line contains the number of Ghost’s questions $q$ ($1 \\le q \\le 100000$). Each of the following $q$ lines contains two real numbers $l$, $r$ ($0 \\le l \\le r \\le 1000000$) given with at most 4 decimal places after the separator, meaning that Ghost asks for a closed time interval $[l, r]$.\n\nThe total number of paintings in all test cases does not exceed 1000000.  \nThe total number of questions in all test cases also does not exceed 1000000.", "outputFormat": "\nFor every Ghost’s question output a single real number – the maximal area achieved by the intersection of all the paintings in the given time interval. Your answer will be considered correct if the absolute or relative error is at most $10^{-6}$. In other words, if your program outputs $a$ and the correct value is $b$, the answer is accepted if\n\n$$\n\\frac{|a - b|}{\\max(1, b)} \\le 10^{-6}\n$$\n\nThe intersection may be empty – in that case, your program should output $0$ ($\\pm 10^{-6}$).\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[AMPPZ 2019] Ghost", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "\n在克拉科夫参观瓦维尔城堡时，你的团队被幽灵困在了一个古老的密室中。除非你们能回答他的问题，否则他不会放你们出去。\n\n墙上挂着 $n$ 幅画作——如果将墙面视为标准的欧几里得平面，这些画作都是轴对齐的矩形。对于每幅画作，你都确切知道其尺寸和起始位置。在某个时刻——我们称之为时刻 0——幽灵开始移动这些画作，每幅画以各自的方向和速度移动。由于你们团队观察力敏锐，可以轻松推测出每幅画的确切速度。\n\n一段时间后，幽灵停止了表演并开始提出棘手的问题。每个问题由两个数字 $l$ 和 $r$ 组成，表示表演的某些时刻。你必须告诉幽灵在 $l$ 到 $r$ 之间是否存在某个时刻，墙上的某个点同时被所有画作覆盖。如果是这样，你还需确定在 $l$ 到 $r$ 之间所有画作的最大可能公共面积。\n\n如果你们想离开这个房间，最好给幽灵正确的答案！\n", "inputFormat": "\n**本题单个测试点内有多组测试数据。**\n\n输入的第一行包含测试数据组数 $z$ ($1 \\le z \\le 4000$)。每组测试数据的格式如下：\n\n每组测试数据的第一行包含画作数量 $n$ ($1 \\le n \\le 100000$)。接下来的 $n$ 行每行包含六个数字  \n$x_1, y_1, x_2, y_2, v_x, v_y$  \n($-1000000 \\le x_1 < x_2 \\le 1000000$；  \n$-1000000 \\le y_1 < y_2 \\le 1000000$；  \n$-1000000 \\le v_x, v_y \\le 1000000$)，  \n其中 $(x_1, y_1)$ 是画作左下角的坐标，$(x_2, y_2)$ 是右上角的坐标，$(v_x, v_y)$ 是其速度向量。这意味着在时刻 $t$，左下角位于点 $(x_1 + t v_x, y_1 + t v_y)$，右上角位于 $(x_2 + t v_x, y_2 + t v_y)$。\n\n接下来一行包含幽灵的问题数量 $q$ ($1 \\le q \\le 100000$)。随后的 $q$ 行每行包含两个实数 $l$, $r$ ($0 \\le l \\le r \\le 1000000$)，小数点后最多 4 位，表示幽灵询问的闭时间区间 $[l, r]$。\n\n所有测试数据中画作的总数不超过 1000000。  \n所有测试数据中问题的总数也不超过 1000000。\n", "outputFormat": "\n对于幽灵的每个问题，输出一个实数——给定时间区间内所有画作交集的最大面积。如果绝对误差或相对误差不超过 $10^{-6}$，你的答案将被视为正确。换句话说，如果你的程序输出 $a$ 而正确值为 $b$，当满足以下条件时答案被接受：\n\n$$\n\\frac{|a - b|}{\\max(1, b)} \\le 10^{-6}\n$$\n\n交集可能为空——此时你的程序应输出 $0$ ($\\pm 10^{-6}$)。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12813", "type": "P", "difficulty": 6, "samples": [["12\n4 1\n3 2\n3 0\n2 3\n1 0\n0 1\n1 2\n2 -1\n2 2\n3 1\n2 0\n1 1", "NIE\nNIE\nNIE\nNIE\nNIE\nNIE\nNIE\nTAK\nNIE\nNIE\nNIE\nTAK"]], "limits": {"time": [30000, 30000], "memory": [8192, 8192]}, "tags": ["2019", "哈希 hashing", "ICPC"], "title": "[AMPPZ 2019] Donuts", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).\n\n**请注意本题特殊的内存限制（8 MB）。**\n", "description": "\n平面上的一个整数坐标点集 $S$ 被称为*甜甜圈*，如果存在一个中点 $(a, b)$ 和两个半径 $L$ 和 $R$（其中 $a, b, L, R$ 为整数且半径非负），使得 $S$ 恰好是所有与 $(a, b)$ 的距离落在区间 $(L, R]$ 内的点的集合。形式化定义为：\n\n$$\nS = \\{(x, y) \\in \\mathbb{Z} \\times \\mathbb{Z} : L < \\text{dist}((x, y), (a, b)) \\leq R\\},\n$$\n\n其中 $\\text{dist}$ 表示欧几里得距离。\n\n我们从空集开始，逐个添加点。每次添加点后，判断当前集合是否是一个甜甜圈。\n\n**请注意本题特殊的内存限制（8 MB）。**\n", "inputFormat": "\n**本题单个测试点内有多组测试数据。**  \n\n输入的第一行包含点的数量 $n$（$2 \\cdot 10^7 \\leq n \\leq 2.5 \\cdot 10^7$）。接下来的 $n$ 行每行描述一个添加的点，坐标由单个空格分隔。坐标是绝对值不超过 5000 的整数。所有给定的点互不相同。", "outputFormat": "\n对于每个点，输出一行 $\\texttt{TAK}$（如果添加该点后集合是一个甜甜圈）或 $\\texttt{NIE}$（如果不是）。", "hint": "\n**样例解释：该示例仅用于解释输入格式**，显然不满足 $n \\geq 2 \\cdot 10^7$ 的条件（但满足其他所有条件）。实际测试点中不包含这组数据。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[AMPPZ 2019] Donuts", "background": "\n**Time limit:** 30s, **memory limit:** 8MB.\n\n\n**Please note an exceptionally low memory limit (8MB) for this problem.**\n", "description": "\nA set $S$ of integer coordinate points in a plane is a *donut*, if there exists a midpoint $(a, b)$ and two radii $L$ and $R$ (with integer $a, b, L, R$ and non-negative radii) such that $S$ is precisely the set of all points whose distance from $(a, b)$ is in the interval $(L, R]$. Formally,\n\n$$\nS = \\{(x, y) \\in \\mathbb{Z} \\times \\mathbb{Z} : L < \\text{dist}((x, y), (a, b)) \\leq R\\},\n$$\n\nwhere $\\text{dist}$ denotes standard plane distance.\n\nWe begin with an empty set and add points one by one. Determine, after every added point, if the set is currently a donut.\n\n**Please note an exceptionally low memory limit (8MB) for this problem.**", "inputFormat": "\nThe first line of input contains the number of points $n$ ($2 \\cdot 10^7 \\leq n \\leq 2.5 \\cdot 10^7$). Each of the next $n$ lines describes a single added point, giving its coordinates separated by a single space. The coordinates are integers of absolute value not greater than 5000. All the given points are distinct.\n", "outputFormat": "\nFor every point output (in a separate line) $\\texttt{TAK}$, if after adding this point the set is a donut, and $\\texttt{NIE}$, if it isn’t.\n", "hint": "\n**Example: The example is given only for explaining the input format**, and it obviously does not satisfy the $n \\geq 2 \\cdot 10^7$ condition (though it satisfies all the others). Your program will **not** be checked on the example test.\n", "locale": "en"}, "zh-CN": {"title": "[AMPPZ 2019] Donuts", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).\n\n**请注意本题特殊的内存限制（8 MB）。**\n", "description": "\n平面上的一个整数坐标点集 $S$ 被称为*甜甜圈*，如果存在一个中点 $(a, b)$ 和两个半径 $L$ 和 $R$（其中 $a, b, L, R$ 为整数且半径非负），使得 $S$ 恰好是所有与 $(a, b)$ 的距离落在区间 $(L, R]$ 内的点的集合。形式化定义为：\n\n$$\nS = \\{(x, y) \\in \\mathbb{Z} \\times \\mathbb{Z} : L < \\text{dist}((x, y), (a, b)) \\leq R\\},\n$$\n\n其中 $\\text{dist}$ 表示欧几里得距离。\n\n我们从空集开始，逐个添加点。每次添加点后，判断当前集合是否是一个甜甜圈。\n\n**请注意本题特殊的内存限制（8 MB）。**\n", "inputFormat": "\n**本题单个测试点内有多组测试数据。**  \n\n输入的第一行包含点的数量 $n$（$2 \\cdot 10^7 \\leq n \\leq 2.5 \\cdot 10^7$）。接下来的 $n$ 行每行描述一个添加的点，坐标由单个空格分隔。坐标是绝对值不超过 5000 的整数。所有给定的点互不相同。", "outputFormat": "\n对于每个点，输出一行 $\\texttt{TAK}$（如果添加该点后集合是一个甜甜圈）或 $\\texttt{NIE}$（如果不是）。", "hint": "\n**样例解释：该示例仅用于解释输入格式**，显然不满足 $n \\geq 2 \\cdot 10^7$ 的条件（但满足其他所有条件）。实际测试点中不包含这组数据。\n\n", "locale": "zh-CN"}}}
{"pid": "P12814", "type": "P", "difficulty": 7, "samples": [["RDUL", "2"], ["RDRU", "0"], ["RLRLRL", "6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "ICPC", "NERC/NEERC"], "title": "[NERC 2021] Admissible Map", "background": "", "description": "A $\\textit{map}$ is a matrix consisting of symbols from the set of $\\texttt{U}$, $\\texttt{L}$, $\\texttt{D}$, and $\\texttt{R}$.\n\nA $\\textit{map graph}$ of a map matrix $a$ is a directed graph with $n \\cdot m$ vertices numbered as $(i, j)$ ($1 \\le i \\le n; 1 \\le j \\le m$), where $n$ is the number of rows in the matrix, $m$ is the number of columns in the matrix. The graph has $n \\cdot m$ directed edges $(i, j) \\to (i + di_{a_{i, j}}, j + dj_{a_{i, j}})$, where $(di_U, dj_U) = (-1, 0)$; $(di_L, dj_L) = (0, -1)$; $(di_D, dj_D) = (1, 0)$; $(di_R, dj_R) = (0, 1)$. A map graph is $\\textit{valid}$ when all edges point to valid vertices in the graph.\n\nAn $\\textit{admissible map}$ is a map such that its map graph is valid and consists of a set of cycles.\n\nA $\\textit{description}$ of a map $a$ is a concatenation of all rows of the map --- a string $a_{1,1} a_{1,2} \\ldots a_{1, m} a_{2, 1} \\ldots a_{n, m}$.\n\nYou are given a string $s$. Your task is to find how many substrings of this string can constitute a description of some admissible map. \n\nA $\\textit{substring}$ of a string $s_1s_2 \\ldots s_l$ of length $l$ is defined by a pair of indices $p$ and $q$ ($1 \\le p \\le q \\le l$) and is equal to $s_ps_{p+1} \\ldots s_q$. Two substrings of $s$ are considered different when the pair of their indices $(p, q)$ differs, even if they represent the same resulting string.", "inputFormat": "In the only input line, there is a string $s$, consisting of at least one and at most $20\\,000$ symbols $\\texttt{U}$, $\\texttt{L}$, $\\texttt{D}$, or $\\texttt{R}$.", "outputFormat": "Output one integer --- the number of substrings of $s$ that constitute a description of some admissible map.", "hint": "In the first example, there are two substrings that can constitute a description of an admissible map --- $\\texttt{RDUL}$ as a matrix of size $2 \\times 2$ (pic. 1) and $\\texttt{DU}$ as a matrix of size $2 \\times 1$ (pic. 2). \n\nIn the second example, no substring can constitute a description of an admissible map. E.g. if we try to look at the string $\\texttt{RDRU}$ as a matrix of size $2 \\times 2$, we can find out that the resulting graph is not a set of cycles (pic. 3).\n\n\nIn the third example, three substrings $\\texttt{RL}$, two substrings $\\texttt{RLRL}$ and one substring $\\texttt{RLRLRL}$ can constitute an admissible map, some of them in multiple ways. E.g. here are two illustrations of substring $\\texttt{RLRLRL}$ as matrices of size $3 \\times 2$ (pic. 4) and $1 \\times 6$ (pic. 5).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l6bwviyf.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s5569ho8.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2021] Admissible Map", "background": "", "description": "A $\\textit{map}$ is a matrix consisting of symbols from the set of $\\texttt{U}$, $\\texttt{L}$, $\\texttt{D}$, and $\\texttt{R}$.\n\nA $\\textit{map graph}$ of a map matrix $a$ is a directed graph with $n \\cdot m$ vertices numbered as $(i, j)$ ($1 \\le i \\le n; 1 \\le j \\le m$), where $n$ is the number of rows in the matrix, $m$ is the number of columns in the matrix. The graph has $n \\cdot m$ directed edges $(i, j) \\to (i + di_{a_{i, j}}, j + dj_{a_{i, j}})$, where $(di_U, dj_U) = (-1, 0)$; $(di_L, dj_L) = (0, -1)$; $(di_D, dj_D) = (1, 0)$; $(di_R, dj_R) = (0, 1)$. A map graph is $\\textit{valid}$ when all edges point to valid vertices in the graph.\n\nAn $\\textit{admissible map}$ is a map such that its map graph is valid and consists of a set of cycles.\n\nA $\\textit{description}$ of a map $a$ is a concatenation of all rows of the map --- a string $a_{1,1} a_{1,2} \\ldots a_{1, m} a_{2, 1} \\ldots a_{n, m}$.\n\nYou are given a string $s$. Your task is to find how many substrings of this string can constitute a description of some admissible map. \n\nA $\\textit{substring}$ of a string $s_1s_2 \\ldots s_l$ of length $l$ is defined by a pair of indices $p$ and $q$ ($1 \\le p \\le q \\le l$) and is equal to $s_ps_{p+1} \\ldots s_q$. Two substrings of $s$ are considered different when the pair of their indices $(p, q)$ differs, even if they represent the same resulting string.", "inputFormat": "In the only input line, there is a string $s$, consisting of at least one and at most $20\\,000$ symbols $\\texttt{U}$, $\\texttt{L}$, $\\texttt{D}$, or $\\texttt{R}$.", "outputFormat": "Output one integer --- the number of substrings of $s$ that constitute a description of some admissible map.", "hint": "In the first example, there are two substrings that can constitute a description of an admissible map --- $\\texttt{RDUL}$ as a matrix of size $2 \\times 2$ (pic. 1) and $\\texttt{DU}$ as a matrix of size $2 \\times 1$ (pic. 2). \n\nIn the second example, no substring can constitute a description of an admissible map. E.g. if we try to look at the string $\\texttt{RDRU}$ as a matrix of size $2 \\times 2$, we can find out that the resulting graph is not a set of cycles (pic. 3).\n\n\nIn the third example, three substrings $\\texttt{RL}$, two substrings $\\texttt{RLRL}$ and one substring $\\texttt{RLRLRL}$ can constitute an admissible map, some of them in multiple ways. E.g. here are two illustrations of substring $\\texttt{RLRLRL}$ as matrices of size $3 \\times 2$ (pic. 4) and $1 \\times 6$ (pic. 5).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l6bwviyf.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s5569ho8.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2021] Admissible Map", "background": "", "description": "一个**地图**是由符号集 $\\{\\texttt{U}, \\texttt{L}, \\texttt{D}, \\texttt{R}\\}$ 中的符号组成的矩阵。\n\n地图矩阵 $a$ 的**地图图集**是一个有向图，包含 $n \\cdot m$ 个顶点，编号为 $(i, j)$（$1 \\le i \\le n$；$1 \\le j \\le m$），其中 $n$ 是矩阵的行数，$m$ 是矩阵的列数。该图有 $n \\cdot m$ 条有向边 $(i, j) \\to (i + di_{a_{i, j}}, j + dj_{a_{i, j}})$，其中 $(di_U, dj_U) = (-1, 0)$；$(di_L, dj_L) = (0, -1)$；$(di_D, dj_D) = (1, 0)$；$(di_R, dj_R) = (0, 1)$。当地图图集中的所有边都指向图中的有效顶点时，该地图图集是**有效的**。\n\n一个**可容许地图**是指其地图图集有效且由一组环构成的地图。\n\n地图 $a$ 的**描述**是地图所有行的拼接——即字符串 $a_{1,1} a_{1,2} \\ldots a_{1, m} a_{2, 1} \\ldots a_{n, m}$。\n\n给定一个字符串 $s$，你的任务是找出该字符串中有多少个子串可以构成某个可容许地图的描述。\n\n字符串 $s_1s_2 \\ldots s_l$ 的**子串**由一对索引 $p$ 和 $q$（$1 \\le p \\le q \\le l$）定义，等于 $s_ps_{p+1} \\ldots s_q$。当两个子串的索引对 $(p, q)$ 不同时，即使它们表示相同的字符串，也被认为是不同的子串。", "inputFormat": "唯一的输入行包含一个字符串 $s$，由至少 1 个、最多 $20\\,000$ 个符号 $\\texttt{U}$、$\\texttt{L}$、$\\texttt{D}$ 或 $\\texttt{R}$ 组成。\n", "outputFormat": "输出一个整数——能够构成某个可容许地图描述的 $s$ 的子串数量。\n", "hint": "在第一个例子中，有两个子串可以构成可容许地图的描述——$\\texttt{RDUL}$ 作为 $2 \\times 2$ 的矩阵（图 1）和 $\\texttt{DU}$ 作为 $2 \\times 1$ 的矩阵（图 2）。\n\n在第二个例子中，没有任何子串可以构成可容许地图的描述。例如，如果我们尝试将字符串 $\\texttt{RDRU}$ 视为 $2 \\times 2$ 的矩阵，可以发现生成的图不是一组环（图 3）。\n\n在第三个例子中，三个子串 $\\texttt{RL}$、两个子串 $\\texttt{RLRL}$ 和一个子串 $\\texttt{RLRLRL}$ 可以构成可容许地图，其中某些子串有多种方式。例如，子串 $\\texttt{RLRLRL}$ 可以表示为 $3 \\times 2$ 的矩阵（图 4）或 $1 \\times 6$ 的矩阵（图 5）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l6bwviyf.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s5569ho8.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12815", "type": "P", "difficulty": 7, "samples": [["1 5\n3 1 7 10 700 400 100\n0 2 10 50 102", "1.0555555555555556\n0.8666666666666667\n0.5476190476190478\n0.12745098039215708\n0.0"], ["2 5\n3 10 70 100 700 400 100\n3 10 30 100 700 400 100\n2 10 50 70 110", "2.2967032967032974\n2.216776340655188\n1.8690167362600323\n1.7301587301587305\n1.5271317829457367"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2021] Budget Distribution", "background": "", "description": "Distributing budgeted money with limited resources and many constraints is a hard problem. A $\\textit{budget plan}$ consists of $t$ topics; $i$-th topic consists of $n_i$ items. \nFor each topic, the $\\textit{optimal relative money distribution}$ is known. The optimal relative distribution for the topic $i$ is a list of real numbers $p_{i,j}$, where $\\sum\\limits_{j=1}^{n_i}{p_{i,j}} = 1$. \n\nLet's denote the amount of money assigned to $j$-th item of the topic $i$ as $c_{i, j}$; the total amount of money for the topic is $C_i = \\sum\\limits_{j=1}^{n_i}{c_{i,j}}$. A $\\textit{non-optimality}$ of the plan for the topic $i$ is defined as $\\sum\\limits_{j=1}^{n_i}\\left|\\frac{c_{i, j}}{C_i} - p_{i, j}\\right|$. Informally, the non-optimality is the total difference between the optimal and the actual ratios of money assigned to all the items in the topic. The $\\textit{total plan non-optimality}$ is the sum of non-optimalities of all $t$ topics. Your task is to minimize the total plan non-optimality.\n\nHowever, the exact amount of money available is not known yet. $j$-th item of $i$-th topic already has $\\hat c_{i,j}$ dollars assigned to it and they cannot be taken back. Also, there are $q$ possible values of the extra unassigned amounts of money available $x_k$. For each of them, you need to calculate the minimal possible total non-optimality among all ways to distribute this extra money. You don't need to assign an integer amount of money to an item, any real number is possible, but all the extra money must be distributed among all the items in addition to $\\hat c_{i,j}$ already assigned. \nFormally, for each value of extra money $x_k$ you'll need to find its distribution $d_{i,j}$ such that $d_{i, j} \\ge 0$ and $\\sum\\limits_{i=1}^{t}\\sum\\limits_{j=1}^{n_i} d_{i,j} = x_k$, giving the resulting budget assignments $c_{i,j} = \\hat c_{i,j} + d_{i,j}$ that minimize the total plan non-optimality.", "inputFormat": "The first line contains two integers $t$ ($1 \\le t \\le 5 \\cdot 10^4$) and $q$ ($1 \\le q \\le 3 \\cdot 10^5$) --- the number of topics in the budget and the number of possible amounts of extra money. \n\nThe next $t$ lines contain descriptions of topics. Each line starts with an integer $n_i$ ($2 \\le n_i \\le 5$) --- the number of items in $i$-th topic; it is followed by $n_i$ integers $\\hat c_{i, j}$ ($0 \\le \\hat c_{i, j} \\le 10^5$; for any $i$, at least one of $\\hat c_{i,j} > 0$) --- the amount of money already assigned to $j$-th item in $i$-th topic; they are followed by $n_i$ integers $p'_{i,j}$ ($1 \\le p'_{i,j} \\le 1000$) --- they determine the values of $p_{i,j}$ as $p_{i, j} = {p'_{i, j}} \\big/ {\\sum\\limits_{j=1}^{n_i}{p'_{i, j}}}$ with $\\sum\\limits_{j=1}^{n_i}{p_{i,j}} = 1$.  \n\nThe next line contains $q$ integers $x_k$ ($0 \\le x_k \\le 10^{12}$) --- $k$-th possible amount of extra money. ", "outputFormat": "Output $q$ real numbers --- the minimal possible non-optimality for the corresponding amount of extra money $x_k$. An absolute or a relative error of the answer must not exceed $10^{-6}$. ", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2021] Budget Distribution", "background": "", "description": "Distributing budgeted money with limited resources and many constraints is a hard problem. A $\\textit{budget plan}$ consists of $t$ topics; $i$-th topic consists of $n_i$ items. \nFor each topic, the $\\textit{optimal relative money distribution}$ is known. The optimal relative distribution for the topic $i$ is a list of real numbers $p_{i,j}$, where $\\sum\\limits_{j=1}^{n_i}{p_{i,j}} = 1$. \n\nLet's denote the amount of money assigned to $j$-th item of the topic $i$ as $c_{i, j}$; the total amount of money for the topic is $C_i = \\sum\\limits_{j=1}^{n_i}{c_{i,j}}$. A $\\textit{non-optimality}$ of the plan for the topic $i$ is defined as $\\sum\\limits_{j=1}^{n_i}\\left|\\frac{c_{i, j}}{C_i} - p_{i, j}\\right|$. Informally, the non-optimality is the total difference between the optimal and the actual ratios of money assigned to all the items in the topic. The $\\textit{total plan non-optimality}$ is the sum of non-optimalities of all $t$ topics. Your task is to minimize the total plan non-optimality.\n\nHowever, the exact amount of money available is not known yet. $j$-th item of $i$-th topic already has $\\hat c_{i,j}$ dollars assigned to it and they cannot be taken back. Also, there are $q$ possible values of the extra unassigned amounts of money available $x_k$. For each of them, you need to calculate the minimal possible total non-optimality among all ways to distribute this extra money. You don't need to assign an integer amount of money to an item, any real number is possible, but all the extra money must be distributed among all the items in addition to $\\hat c_{i,j}$ already assigned. \nFormally, for each value of extra money $x_k$ you'll need to find its distribution $d_{i,j}$ such that $d_{i, j} \\ge 0$ and $\\sum\\limits_{i=1}^{t}\\sum\\limits_{j=1}^{n_i} d_{i,j} = x_k$, giving the resulting budget assignments $c_{i,j} = \\hat c_{i,j} + d_{i,j}$ that minimize the total plan non-optimality.", "inputFormat": "The first line contains two integers $t$ ($1 \\le t \\le 5 \\cdot 10^4$) and $q$ ($1 \\le q \\le 3 \\cdot 10^5$) --- the number of topics in the budget and the number of possible amounts of extra money. \n\nThe next $t$ lines contain descriptions of topics. Each line starts with an integer $n_i$ ($2 \\le n_i \\le 5$) --- the number of items in $i$-th topic; it is followed by $n_i$ integers $\\hat c_{i, j}$ ($0 \\le \\hat c_{i, j} \\le 10^5$; for any $i$, at least one of $\\hat c_{i,j} > 0$) --- the amount of money already assigned to $j$-th item in $i$-th topic; they are followed by $n_i$ integers $p'_{i,j}$ ($1 \\le p'_{i,j} \\le 1000$) --- they determine the values of $p_{i,j}$ as $p_{i, j} = {p'_{i, j}} \\big/ {\\sum\\limits_{j=1}^{n_i}{p'_{i, j}}}$ with $\\sum\\limits_{j=1}^{n_i}{p_{i,j}} = 1$.  \n\nThe next line contains $q$ integers $x_k$ ($0 \\le x_k \\le 10^{12}$) --- $k$-th possible amount of extra money. ", "outputFormat": "Output $q$ real numbers --- the minimal possible non-optimality for the corresponding amount of extra money $x_k$. An absolute or a relative error of the answer must not exceed $10^{-6}$. ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2021] Budget Distribution", "background": "", "description": "在资源有限且约束众多的情况下分配预算资金是一个难题。一个**预算计划**包含 $t$ 个主题；第 $i$ 个主题包含 $n_i$ 个项目。  \n对于每个主题，已知其**最优相对资金分配**。主题 $i$ 的最优相对分配是一个实数列表 $p_{i,j}$，其中 $\\sum\\limits_{j=1}^{n_i}{p_{i,j}} = 1$。  \n\n设 $c_{i, j}$ 表示分配给主题 $i$ 的第 $j$ 个项目的资金金额；该主题的总资金为 $C_i = \\sum\\limits_{j=1}^{n_i}{c_{i,j}}$。主题 $i$ 的**非最优性**定义为 $\\sum\\limits_{j=1}^{n_i}\\left|\\frac{c_{i, j}}{C_i} - p_{i, j}\\right|$。通俗地说，非最优性是所有项目中实际分配资金比例与最优比例的总差异。**总计划非最优性**是所有 $t$ 个主题的非最优性之和。你的任务是最小化总计划非最优性。  \n\n然而，目前尚不清楚具体可用的资金总额。主题 $i$ 的第 $j$ 个项目已经分配了 $\\hat c_{i,j}$ 美元，且这些资金不可撤回。此外，还有 $q$ 种可能的额外未分配资金金额 $x_k$。对于每种情况，你需要计算在所有分配该额外资金的方式中，可能的最小总非最优性。分配给项目的资金金额不必是整数，任何实数均可，但所有额外资金必须全部分配到各个项目中（即在 $\\hat c_{i,j}$ 的基础上增加）。  \n形式化地说，对于每种额外资金 $x_k$，你需要找到其分配方案 $d_{i,j}$，满足 $d_{i, j} \\ge 0$ 且 $\\sum\\limits_{i=1}^{t}\\sum\\limits_{j=1}^{n_i} d_{i,j} = x_k$，使得最终预算分配 $c_{i,j} = \\hat c_{i,j} + d_{i,j}$ 的总计划非最优性最小。  ", "inputFormat": "第一行包含两个整数 $t$（$1 \\le t \\le 5 \\cdot 10^4$）和 $q$（$1 \\le q \\le 3 \\cdot 10^5$）——预算中的主题数量和可能的额外资金金额数量。  \n\n接下来的 $t$ 行描述各个主题。每行以一个整数 $n_i$（$2 \\le n_i \\le 5$）开头，表示第 $i$ 个主题的项目数量；随后是 $n_i$ 个整数 $\\hat c_{i, j}$（$0 \\le \\hat c_{i, j} \\le 10^5$；对于任意 $i$，至少有一个 $\\hat c_{i,j} > 0$）——已分配给第 $i$ 个主题第 $j$ 个项目的资金金额；接着是 $n_i$ 个整数 $p'_{i,j}$（$1 \\le p'_{i,j} \\le 1000$）——它们决定了 $p_{i,j}$ 的值，计算公式为 $p_{i, j} = {p'_{i, j}} \\big/ {\\sum\\limits_{j=1}^{n_i}{p'_{i, j}}}$，且 $\\sum\\limits_{j=1}^{n_i}{p_{i,j}} = 1$。  \n\n最后一行包含 $q$ 个整数 $x_k$（$0 \\le x_k \\le 10^{12}$）——第 $k$ 种可能的额外资金金额。  \n", "outputFormat": "输出 $q$ 个实数——对应额外资金 $x_k$ 的最小可能非最优性。答案的绝对或相对误差不得超过 $10^{-6}$。  \n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12816", "type": "P", "difficulty": 3, "samples": [["1 1\n3 5\n8 6", "3\n1 1 1 5\n1 5 8 5\n8 5 8 6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2021] Connect the Points", "background": "", "description": "You are given three points on a plane. You should choose some segments on the plane that are parallel to coordinate axes, so that all three points become connected. The total length of the chosen segments should be the minimal possible.\n\nTwo points $a$ and $b$ are considered connected if there is a sequence of points $p_0 = a, p_1, \\ldots, p_k = b$ such that points $p_i$ and $p_{i+1}$ lie on the same segment.", "inputFormat": "The input consists of three lines describing three points. Each line contains two integers $x$ and $y$ separated by a space --- the coordinates of the point ($-10^9 \\le x, y \\le 10^9$). The points are pairwise distinct.\n", "outputFormat": "On the first line output $n$ --- the number of segments, at most 100.\n\nThe next $n$ lines should contain descriptions of segments. Output four integers $x_1$, $y_1$, $x_2$, $y_2$ on a line --- the coordinates of the endpoints of the corresponding segment ($-10^9 \\le x_1, y_1, x_2, y_2 \\le 10^9$). Each segment should be either horizontal or vertical.\n\nIt is guaranteed that the solution with the given constraints exists.", "hint": "The points and the segments from the example are shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ln8aeda.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2021] Connect the Points", "background": "", "description": "You are given three points on a plane. You should choose some segments on the plane that are parallel to coordinate axes, so that all three points become connected. The total length of the chosen segments should be the minimal possible.\n\nTwo points $a$ and $b$ are considered connected if there is a sequence of points $p_0 = a, p_1, \\ldots, p_k = b$ such that points $p_i$ and $p_{i+1}$ lie on the same segment.", "inputFormat": "The input consists of three lines describing three points. Each line contains two integers $x$ and $y$ separated by a space --- the coordinates of the point ($-10^9 \\le x, y \\le 10^9$). The points are pairwise distinct.\n", "outputFormat": "On the first line output $n$ --- the number of segments, at most 100.\n\nThe next $n$ lines should contain descriptions of segments. Output four integers $x_1$, $y_1$, $x_2$, $y_2$ on a line --- the coordinates of the endpoints of the corresponding segment ($-10^9 \\le x_1, y_1, x_2, y_2 \\le 10^9$). Each segment should be either horizontal or vertical.\n\nIt is guaranteed that the solution with the given constraints exists.", "hint": "The points and the segments from the example are shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ln8aeda.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2021] Connect the Points", "background": "", "description": "给定平面上的三个点。你需要选择若干条与坐标轴平行的线段，使得这三个点相互连通。所选线段的总长度应尽可能短。\n\n当两个点 $a$ 和 $b$ 之间存在一系列点 $p_0 = a, p_1, \\ldots, p_k = b$，且每对相邻点 $p_i$ 和 $p_{i+1}$ 位于同一条线段上时，我们认为这两个点是**连通的**。\n", "inputFormat": "输入包含三行，每行描述一个点。每行包含两个用空格分隔的整数 $x$ 和 $y$ —— 点的坐标（$-10^9 \\le x, y \\le 10^9$）。这些点两两不同。\n", "outputFormat": "第一行输出 $n$ —— 线段的数量，最多为 100。\n\n接下来的 $n$ 行应描述每条线段。每行输出四个整数 $x_1$, $y_1$, $x_2$, $y_2$ —— 对应线段端点的坐标（$-10^9 \\le x_1, y_1, x_2, y_2 \\le 10^9$）。每条线段必须水平或垂直。\n\n题目保证在给定约束条件下存在解。", "hint": "样例中的点和线段如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ln8aeda.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12817", "type": "P", "difficulty": 2, "samples": [["6\nDETERMINED TRME\nDETERMINED TERM\nPSEUDOPSEUDOHYPOPARATHYROIDISM PEPA\nDEINSTITUTIONALIZATION DONATION\nCONTEST CODE\nSOLUTION SOLUTION", "YES\nNO\nNO\nYES\nNO\nYES"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "ICPC", "NERC/NEERC"], "title": "[NERC 2021] Deletive Editing", "background": "", "description": "Daisy loves playing games with words. Recently, she has been playing the following Deletive Editing word game with Daniel. \n\nDaisy picks a word, for example, $\\tt{DETERMINED}$. On each game turn, Daniel calls out a letter, for example, $\\tt{E}$, and Daisy removes $\\textbf{the first occurrence}$ of this letter from the word, getting $\\tt{DTERMINED}$. On the next turn, Daniel calls out a letter again, for example, $\\tt{D}$, and Daisy removes its first occurrence, getting $\\tt{TERMINED}$. They continue with $\\tt{I}$, getting $\\tt{TERMNED}$, with $\\tt{N}$, getting $\\tt{TERMED}$, and with $\\tt{D}$, getting $\\tt{TERME}$. Now, if Daniel calls out the letter $\\tt{E}$, Daisy gets $\\tt{TRME}$, but there is no way she can get the word $\\tt{TERM}$ if they start playing with the word $\\tt{DETERMINED}$.\n\nDaisy is curious if she can get the final word of her choice, starting from the given initial word, by playing this game for zero or more turns. Your task it help her to figure this out.", "inputFormat": "The first line of the input contains an integer $n$ --- the number of test cases ($1 \\le n \\le 10\\,000$). The following $n$ lines contain test cases. \n\nEach test case consists of two words $s$ and $t$ separated by a space. Each word consists of at least one and at most 30 uppercase English letters; $s$ is the Daisy's initial word for the game; $t$ is the final word that Daisy would like to get at the end of the game.", "outputFormat": "Output $n$ lines to the output --- a single line for each test case. Output $\\tt{YES}$ if it is possible for Daisy to get from the initial word $s$ to the final word $t$ by playing the Deletive Editing game. Output $\\tt{NO}$ otherwise.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2021] Deletive Editing", "background": "", "description": "Daisy loves playing games with words. Recently, she has been playing the following Deletive Editing word game with Daniel. \n\nDaisy picks a word, for example, $\\tt{DETERMINED}$. On each game turn, Daniel calls out a letter, for example, $\\tt{E}$, and Daisy removes $\\textbf{the first occurrence}$ of this letter from the word, getting $\\tt{DTERMINED}$. On the next turn, Daniel calls out a letter again, for example, $\\tt{D}$, and Daisy removes its first occurrence, getting $\\tt{TERMINED}$. They continue with $\\tt{I}$, getting $\\tt{TERMNED}$, with $\\tt{N}$, getting $\\tt{TERMED}$, and with $\\tt{D}$, getting $\\tt{TERME}$. Now, if Daniel calls out the letter $\\tt{E}$, Daisy gets $\\tt{TRME}$, but there is no way she can get the word $\\tt{TERM}$ if they start playing with the word $\\tt{DETERMINED}$.\n\nDaisy is curious if she can get the final word of her choice, starting from the given initial word, by playing this game for zero or more turns. Your task it help her to figure this out.", "inputFormat": "The first line of the input contains an integer $n$ --- the number of test cases ($1 \\le n \\le 10\\,000$). The following $n$ lines contain test cases. \n\nEach test case consists of two words $s$ and $t$ separated by a space. Each word consists of at least one and at most 30 uppercase English letters; $s$ is the Daisy's initial word for the game; $t$ is the final word that Daisy would like to get at the end of the game.", "outputFormat": "Output $n$ lines to the output --- a single line for each test case. Output $\\tt{YES}$ if it is possible for Daisy to get from the initial word $s$ to the final word $t$ by playing the Deletive Editing game. Output $\\tt{NO}$ otherwise.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2021] Deletive Editing", "background": "", "description": "Daisy 喜欢玩文字游戏。最近，她一直在和 Daniel 玩一个叫做**删除编辑**的文字游戏。\n\nDaisy 先选择一个单词，例如 $\\tt{DETERMINED}$。每一轮游戏中，Daniel 喊出一个字母，例如 $\\tt{E}$，然后 Daisy 从单词中**删除该字母的第一次出现**，得到 $\\tt{DTERMINED}$。下一轮，Daniel 再次喊出一个字母，例如 $\\tt{D}$，Daisy 删除它的第一次出现，得到 $\\tt{TERMINED}$。他们继续喊 $\\tt{I}$，得到 $\\tt{TERMNED}$；喊 $\\tt{N}$，得到 $\\tt{TERMED}$；喊 $\\tt{D}$，得到 $\\tt{TERME}$。此时如果 Daniel 喊出字母 $\\tt{E}$，Daisy 会得到 $\\tt{TRME}$，但如果他们从 $\\tt{DETERMINED}$ 开始玩这个游戏，就无法得到单词 $\\tt{TERM}$。\n\nDaisy 很好奇，她是否能够从给定的初始单词出发，通过玩若干轮（包括零轮）这个游戏，最终得到她想要的单词。你的任务是帮她判断这一点。", "inputFormat": "输入的第一行包含一个整数 $n$ —— 测试用例的数量（$1 \\le n \\le 10\\,000$）。接下来的 $n$ 行包含各个测试用例。\n\n每个测试用例由两个单词 $s$ 和 $t$ 组成，中间用空格隔开。每个单词由 1 到 30 个大写英文字母组成；$s$ 是 Daisy 的初始单词，$t$ 是 Daisy 希望最终得到的单词。\n", "outputFormat": "输出 $n$ 行 —— 每个测试用例一行。如果 Daisy 能够通过玩删除编辑游戏从初始单词 $s$ 得到最终单词 $t$，则输出 $\\tt{YES}$，否则输出 $\\tt{NO}$。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12818", "type": "P", "difficulty": 5, "samples": [["6 3\n1 3 5", "0 2\n2 4\n4 6"], ["10 2\n1 2", "0 2\n2 10"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["二分", "2021", "Special Judge", "构造", "ICPC", "NERC/NEERC"], "title": "[NERC 2021] Even Split", "background": "", "description": "A revolution has recently happened in Segmentland. The new government is committed to equality, and they hired you to help with land redistribution in the country.\n\nSegmentland is a segment of length $l$ kilometers, with the capital in one of its ends. There are $n$ citizens in Segmentland, the home of $i$-th citizen is located at the point $a_i$ kilometers from the capital. No two homes are located at the same point. Each citizen should receive a segment of positive length with ends at integer distances from the capital that contains her home. The union of these segments should be the whole of Segmentland, and they should not have common points besides their ends. To ensure equality, the difference between the lengths of the longest and the shortest segments should be as small as possible.", "inputFormat": "The first line of the input contains two integers $l$ and $n$ ($2 \\leq l \\leq 10^9; 1 \\leq n \\leq 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 < a_1 < a_2 < \\dots < a_n < l$).", "outputFormat": "Output $n$ pairs of numbers $s_i, f_i$ ($0 \\leq s_i < f_i \\leq l$), one pair per line. The pair on $i$-th line denotes the~ends of the $[s_i, f_i]$ segment that $i$-th citizen receives.\n\nIf there are many possible arrangements with the same difference between the lengths of the longest and the shortest segments, you can output any of them.", "hint": "In the first example, it is possible to make all segments equal. $\\textit{Viva la revolucion!}$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3wu9r2og.png)\n\nIn the second example, citizens live close to the capital, so the length of the shortest segment is 2 and the length of the longest segment is 8.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j6sev5h6.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2021] Even Split", "background": "", "description": "A revolution has recently happened in Segmentland. The new government is committed to equality, and they hired you to help with land redistribution in the country.\n\nSegmentland is a segment of length $l$ kilometers, with the capital in one of its ends. There are $n$ citizens in Segmentland, the home of $i$-th citizen is located at the point $a_i$ kilometers from the capital. No two homes are located at the same point. Each citizen should receive a segment of positive length with ends at integer distances from the capital that contains her home. The union of these segments should be the whole of Segmentland, and they should not have common points besides their ends. To ensure equality, the difference between the lengths of the longest and the shortest segments should be as small as possible.", "inputFormat": "The first line of the input contains two integers $l$ and $n$ ($2 \\leq l \\leq 10^9; 1 \\leq n \\leq 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 < a_1 < a_2 < \\dots < a_n < l$).", "outputFormat": "Output $n$ pairs of numbers $s_i, f_i$ ($0 \\leq s_i < f_i \\leq l$), one pair per line. The pair on $i$-th line denotes the~ends of the $[s_i, f_i]$ segment that $i$-th citizen receives.\n\nIf there are many possible arrangements with the same difference between the lengths of the longest and the shortest segments, you can output any of them.", "hint": "In the first example, it is possible to make all segments equal. $\\textit{Viva la revolucion!}$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3wu9r2og.png)\n\nIn the second example, citizens live close to the capital, so the length of the shortest segment is 2 and the length of the longest segment is 8.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j6sev5h6.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2021] Even Split", "background": "删除了题面中的敏感词。", "description": "Segmentland 是一个长度为 $l$ 公里的线段，首都位于其一端。该国共有 $n$ 位公民，第 $i$ 位公民的家位于距离首都 $a_i$ 公里的点上。所有公民的居住点都不相同。每位公民应该获得一个长度为正的线段，其端点与首都的距离为整数，且必须包含她自己的家。这些线段的并集必须覆盖整个 Segmentland，且它们之间除了端点外不能有重叠部分。为了确保平等，最长线段与最短线段的长度差应尽可能小。\n", "inputFormat": "输入的第一行包含两个整数 $l$ 和 $n$（$2 \\leq l \\leq 10^9$；$1 \\leq n \\leq 10^5$）。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n$（$0 < a_1 < a_2 < \\dots < a_n < l$）。", "outputFormat": "输出 $n$ 对数 $s_i, f_i$（$0 \\leq s_i < f_i \\leq l$），每行一对。第 $i$ 行的数对表示第 $i$ 位公民获得的线段 $[s_i, f_i]$ 的端点。\n\n如果有多种分配方案都能使最长线段与最短线段的长度差相同，可以输出其中任意一种。", "hint": "在第一个样例中，可以使所有线段长度相等。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3wu9r2og.png)\n\n在第二个样例中，公民居住点靠近首都，因此最短线段长度为 2，最长线段长度为 8。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j6sev5h6.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12819", "type": "P", "difficulty": 5, "samples": [["2\n4\n1 2 3 4\n8\n1 1 2 3 4 4 6 7", "2\n4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2021", "ICPC", "NERC/NEERC"], "title": "[NERC 2021] Fancy Stack", "background": "", "description": "Little Fiona has a collection of $n$ blocks of various sizes $a_1, a_2, \\ldots, a_n$, where $n$ is even. Some of the blocks can be equal in size. She would like to put all these blocks one onto another to form a $\\textit{fancy}$ stack.\n\nLet $b_1, b_2, \\ldots, b_n$ be the sizes of blocks in the stack from top to bottom. Since Fiona is using all her blocks, $b_1, b_2, \\ldots, b_n$ must be a permutation of $a_1, a_2, \\ldots, a_n$. Fiona thinks the stack is $\\textit{fancy}$ if both of the following conditions are satisfied:\n- The second block is strictly bigger than the first one, and then each block is alternately strictly smaller or strictly bigger than the previous one. Formally, $b_1 < b_2 > b_3 < b_4 > \\ldots > b_{n-1} < b_n$.\n- The sizes of the blocks on even positions are strictly increasing. Formally, $b_2 < b_4 < b_6 < \\ldots < b_n$ (remember that $n$ is even).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/16lldnv3.png)\n\nTwo stacks are considered different if their corresponding sequences $b_1, b_2, \\ldots, b_n$ differ in at least one position.\n\nFiona wants to know how many different fancy stacks she can build with all of her blocks. Since large numbers scare Fiona, find this number modulo $998\\,244\\,353$.", "inputFormat": "Each input contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 2500$). Description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ --- the number of blocks at Fiona's disposal ($2 \\le n \\le 5000$; $n$ is even). The second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ --- the sizes of the blocks in non-decreasing order ($1 \\le a_1 \\le a_2 \\le \\dotsb \\le a_n \\le n$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5000$.", "outputFormat": "For each test case, print the number of ways to build a fancy stack, modulo $998\\,244\\,353$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2021] Fancy Stack", "background": "", "description": "Little Fiona has a collection of $n$ blocks of various sizes $a_1, a_2, \\ldots, a_n$, where $n$ is even. Some of the blocks can be equal in size. She would like to put all these blocks one onto another to form a $\\textit{fancy}$ stack.\n\nLet $b_1, b_2, \\ldots, b_n$ be the sizes of blocks in the stack from top to bottom. Since Fiona is using all her blocks, $b_1, b_2, \\ldots, b_n$ must be a permutation of $a_1, a_2, \\ldots, a_n$. Fiona thinks the stack is $\\textit{fancy}$ if both of the following conditions are satisfied:\n- The second block is strictly bigger than the first one, and then each block is alternately strictly smaller or strictly bigger than the previous one. Formally, $b_1 < b_2 > b_3 < b_4 > \\ldots > b_{n-1} < b_n$.\n- The sizes of the blocks on even positions are strictly increasing. Formally, $b_2 < b_4 < b_6 < \\ldots < b_n$ (remember that $n$ is even).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/16lldnv3.png)\n\nTwo stacks are considered different if their corresponding sequences $b_1, b_2, \\ldots, b_n$ differ in at least one position.\n\nFiona wants to know how many different fancy stacks she can build with all of her blocks. Since large numbers scare Fiona, find this number modulo $998\\,244\\,353$.", "inputFormat": "Each input contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 2500$). Description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ --- the number of blocks at Fiona's disposal ($2 \\le n \\le 5000$; $n$ is even). The second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ --- the sizes of the blocks in non-decreasing order ($1 \\le a_1 \\le a_2 \\le \\dotsb \\le a_n \\le n$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5000$.", "outputFormat": "For each test case, print the number of ways to build a fancy stack, modulo $998\\,244\\,353$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2021] Fancy Stack", "background": "", "description": "小 Fiona 有 $n$ 个大小各异的积木 $a_1, a_2, \\ldots, a_n$，其中 $n$ 为偶数。有些积木的大小可能相同。她想把这些积木一块一块地堆叠起来，形成一个**花式**堆叠。\n\n设 $b_1, b_2, \\ldots, b_n$ 为从顶部到底部的积木大小序列。由于 Fiona 要使用所有积木，$b_1, b_2, \\ldots, b_n$ 必须是 $a_1, a_2, \\ldots, a_n$ 的一个排列。Fiona 认为堆叠是**花式**的，当且仅当满足以下两个条件：\n1. 第二块积木严格大于第一块，之后每块积木交替严格小于或严格大于前一块。形式化地说，$b_1 < b_2 > b_3 < b_4 > \\ldots > b_{n-1} < b_n$。\n2. 位于偶数位置的积木大小严格递增。形式化地说，$b_2 < b_4 < b_6 < \\ldots < b_n$（记住 $n$ 是偶数）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/16lldnv3.png)\n\n如果两个堆叠对应的序列 $b_1, b_2, \\ldots, b_n$ 在至少一个位置上不同，则认为它们是不同的堆叠。\n\nFiona 想知道她能用所有积木堆出多少种不同的花式堆叠。由于大数字会让 Fiona 害怕，请将结果对 $998\\,244\\,353$ 取模后输出。", "inputFormat": "每个输入包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \\le t \\le 2500$）。接下来是每个测试用例的描述。\n\n每个测试用例的第一行包含一个整数 $n$ —— Fiona 拥有的积木数量（$2 \\le n \\le 5000$；$n$ 为偶数）。第二行包含 $n$ 个整数 $a_1, a_2, \\ldots, a_n$ —— 积木的大小，按非递减顺序给出（$1 \\le a_1 \\le a_2 \\le \\dotsb \\le a_n \\le n$）。\n\n保证所有测试用例的 $n$ 之和不超过 $5000$。\n", "outputFormat": "对于每个测试用例，输出可以构建的花式堆叠的数量，结果对 $998\\,244\\,353$ 取模。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12820", "type": "P", "difficulty": 7, "samples": [["5\n0 0 0\n2 0 0\n2 2 0\n0 2 0\n1 1 4\n4\n1 2 5\n2 3 5\n3 4 5\n4 1 5\n7\n0 1\n0 5\n1 5\n2 5\n3 5\n4 5\n5 5", "-1\n16.492422502470642\n9.276987657639736\n4.123105625617661\n1.030776406404415\n-1\n-1"], ["16\n0 5 0\n1 2 0\n2 5 5\n3 7 0\n4 0 0\n4 3 5\n5 5 1\n6 2 0\n6 6 5\n7 4 4\n7 8 0\n8 2 0\n9 4 0\n4 6 4\n6 3 3\n2 4 5\n22\n11 10 9\n12 8 10\n2 6 5\n9 10 7\n8 15 6\n16 3 6\n15 6 7\n7 3 14\n8 10 15\n11 13 10\n16 6 2\n12 10 13\n10 7 15\n16 3 2\n3 4 1\n14 7 9\n11 9 4\n3 6 7\n5 6 8\n14 4 3\n3 1 2\n9 4 14\n7\n0 7\n1 7\n1 16\n2 10\n3 9\n4 16\n5 16", "120.483405354306325\n-1\n93.929895222484783\n68.181919663536940\n40.918561474148331\n11.067441790921070\n-1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2021] Global Warming", "background": "", "description": "You are developing a new computer game. Let's consider an island in the middle of the ocean in a three-dimensional space with $z$-axis pointing upwards. The surface of the ocean is a horizontal plane with $z = 0$. The island is a polyhedron of a special form.\n\nYou are given $n$ points $(x_i, y_i, z_i)$; there are some edges between them. If we look at the island from above or if we discard $z$ coordinate of each point, points and edges form a planar connected graph. Every face of this planar graph, except the external one, is a nondegenerate triangle. Every edge of the graph belongs to at least one internal face. All points that lie on the edge of the external face of the graph have $z$ coordinates equal to zero. Other points may have arbitrary non-negative $z$ coordinates. Every face of the planar graph corresponds to the face of the polyhedron with the same vertices.\n\nDue to global warming, the level of the ocean is increasing and floods the island. Your task is to compute various global warming scenarios for the game. \n\nIn each scenario, the level of the ocean increased to the height $h$, so that the surface of the ocean is a plane $z = h$. Parts of the island that are $\\textbf{below or at the height h}$ are now $\\textit{flooded}$, even though some parts may be not reachable from the ocean by water (see the illustration for the second example). In a scenario, a player is standing in $p$-th point. You shall compute the area of the surface of the part of the island where the player is standing, or determine that the player is standing at or below the water level and has drowned. \n\nFormally, we say that two points on the surface of the island belong to the same part if a player can move between them walking by the surface of the island staying strictly higher than ocean level. Note that you should find the area of the surface of the island itself, not the area of its projection on a horizontal plane.", "inputFormat": "The first line contains a single integer $n$ --- the number of points ($1 \\le n \\le 10^5$).\n\nEach of the next $n$ lines contains three integers $x_i$, $y_i$, and $z_i$ --- the coordinates of $i$-th point ($-10^6 \\le x_i, y_i \\le 10^6$; $0 \\le z_i \\le 10^6$).\n\nThe next line contains a single integer $m$ --- the number of internal faces of the planar graph ($1 \\le m \\le 10^5$). They are also the faces of the island's polyhedron.\n\nEach of the next $m$ lines contains three integers $a_i$, $b_i$, and $c_i$ --- the indices of three points that are vertices of $i$-th internal face ($1 \\le a_i, b_i, c_i \\le n$).\n\nIt is guaranteed that if $z$ coordinate is discarded, then the resulting graph is a connected and planar graph. All its faces, except the external one, are nondegenerate triangles. All points that lie on the edge of the external face of the planar graph have $z$ coordinate equal to zero.\n\nThe next line contains an integer $q$ --- the number of global warming scenarios to compute ($1 \\le q \\le 10^5$).\n\nEach of the next $q$ lines contains two integers $h_i$ and $p_i$ --- the level of the ocean and the index of the point where the player is standing respectively ($0 \\le h_i \\le 10^6$; $1 \\le p_i \\le n$).", "outputFormat": "For every scenario output a single real number --- the area of the surface of part of the island where the player is standing. If the player's position is flooded by water, output $-1$ instead.\n\nThe answer is considered correct if its absolute or relative error does not exceed $10^{-6}$.", "hint": "The illustrations of the examples are views of the island from the above. The ocean is hatched. The island is drawn with contour lines, with higher parts in darker colors.\n\n### Sample 1\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6i7gpzp5.png)\n\n### Sample 2\n\nThe island in the second example looks as follows.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/85a3xso9.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kgxdolc5.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zf3pxpa6.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2021] Global Warming", "background": "", "description": "You are developing a new computer game. Let's consider an island in the middle of the ocean in a three-dimensional space with $z$-axis pointing upwards. The surface of the ocean is a horizontal plane with $z = 0$. The island is a polyhedron of a special form.\n\nYou are given $n$ points $(x_i, y_i, z_i)$; there are some edges between them. If we look at the island from above or if we discard $z$ coordinate of each point, points and edges form a planar connected graph. Every face of this planar graph, except the external one, is a nondegenerate triangle. Every edge of the graph belongs to at least one internal face. All points that lie on the edge of the external face of the graph have $z$ coordinates equal to zero. Other points may have arbitrary non-negative $z$ coordinates. Every face of the planar graph corresponds to the face of the polyhedron with the same vertices.\n\nDue to global warming, the level of the ocean is increasing and floods the island. Your task is to compute various global warming scenarios for the game. \n\nIn each scenario, the level of the ocean increased to the height $h$, so that the surface of the ocean is a plane $z = h$. Parts of the island that are $\\textbf{below or at the height h}$ are now $\\textit{flooded}$, even though some parts may be not reachable from the ocean by water (see the illustration for the second example). In a scenario, a player is standing in $p$-th point. You shall compute the area of the surface of the part of the island where the player is standing, or determine that the player is standing at or below the water level and has drowned. \n\nFormally, we say that two points on the surface of the island belong to the same part if a player can move between them walking by the surface of the island staying strictly higher than ocean level. Note that you should find the area of the surface of the island itself, not the area of its projection on a horizontal plane.", "inputFormat": "The first line contains a single integer $n$ --- the number of points ($1 \\le n \\le 10^5$).\n\nEach of the next $n$ lines contains three integers $x_i$, $y_i$, and $z_i$ --- the coordinates of $i$-th point ($-10^6 \\le x_i, y_i \\le 10^6$; $0 \\le z_i \\le 10^6$).\n\nThe next line contains a single integer $m$ --- the number of internal faces of the planar graph ($1 \\le m \\le 10^5$). They are also the faces of the island's polyhedron.\n\nEach of the next $m$ lines contains three integers $a_i$, $b_i$, and $c_i$ --- the indices of three points that are vertices of $i$-th internal face ($1 \\le a_i, b_i, c_i \\le n$).\n\nIt is guaranteed that if $z$ coordinate is discarded, then the resulting graph is a connected and planar graph. All its faces, except the external one, are nondegenerate triangles. All points that lie on the edge of the external face of the planar graph have $z$ coordinate equal to zero.\n\nThe next line contains an integer $q$ --- the number of global warming scenarios to compute ($1 \\le q \\le 10^5$).\n\nEach of the next $q$ lines contains two integers $h_i$ and $p_i$ --- the level of the ocean and the index of the point where the player is standing respectively ($0 \\le h_i \\le 10^6$; $1 \\le p_i \\le n$).", "outputFormat": "For every scenario output a single real number --- the area of the surface of part of the island where the player is standing. If the player's position is flooded by water, output $-1$ instead.\n\nThe answer is considered correct if its absolute or relative error does not exceed $10^{-6}$.", "hint": "The illustrations of the examples are views of the island from the above. The ocean is hatched. The island is drawn with contour lines, with higher parts in darker colors.\n\n### Sample 1\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6i7gpzp5.png)\n\n### Sample 2\n\nThe island in the second example looks as follows.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/85a3xso9.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kgxdolc5.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zf3pxpa6.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2021] Global Warming", "background": "", "description": "你正在开发一款新的电脑游戏。考虑三维空间中海洋中央的一座岛屿，其中 $z$ 轴垂直向上。海洋表面是水平面 $z = 0$。岛屿是一个特殊形态的多面体。\n\n给定 $n$ 个点 $(x_i, y_i, z_i)$，这些点之间存在若干边。如果从上方观察岛屿或忽略每个点的 $z$ 坐标，这些点和边构成一个平面连通图。该平面图的每个内部面（除外部面外）都是非退化三角形。图的每条边至少属于一个内部面。所有位于平面图外部面边上的点 $z$ 坐标均为零，其他点的 $z$ 坐标可以是任意非负值。平面图的每个面对应多面体中具有相同顶点的面。\n\n由于全球变暖，海平面上升并逐渐淹没岛屿。你的任务是为游戏计算不同的全球变暖情景。\n\n在每个情景中，海平面上升到高度 $h$，此时海洋表面为平面 $z = h$。岛屿中**高度小于等于 $h$** 的部分被**淹没**，即使某些部分可能无法被海水触及（参见第二个样例的图示）。在情景中，玩家站在第 $p$ 个点上。你需要计算玩家所在岛屿部分的表面积，或者判定玩家所在位置已被淹没（即玩家已溺水）。\n\n形式化地说，如果两个点位于岛屿表面，且玩家可以严格高于海平面的情况下在岛屿表面行走从一个点到达另一个点，则认为这两个点属于同一部分。注意，你需要计算岛屿表面的实际面积，而非其在水平面上的投影面积。", "inputFormat": "第一行包含一个整数 $n$ —— 点的数量（$1 \\le n \\le 10^5$）。\n\n接下来的 $n$ 行，每行包含三个整数 $x_i$、$y_i$ 和 $z_i$ —— 第 $i$ 个点的坐标（$-10^6 \\le x_i, y_i \\le 10^6$；$0 \\le z_i \\le 10^6$）。\n\n接下来一行包含一个整数 $m$ —— 平面图的内部面数量（$1 \\le m \\le 10^5$），也是岛屿多面体的面数量。\n\n接下来的 $m$ 行，每行包含三个整数 $a_i$、$b_i$ 和 $c_i$ —— 第 $i$ 个内部面的三个顶点索引（$1 \\le a_i, b_i, c_i \\le n$）。\n\n保证忽略 $z$ 坐标后，所得图是连通且平面的。除外部面外，所有面均为非退化三角形。所有位于平面图外部面边上的点 $z$ 坐标为零。\n\n接下来一行包含一个整数 $q$ —— 需要计算的全球变暖情景数量（$1 \\le q \\le 10^5$）。\n\n接下来的 $q$ 行，每行包含两个整数 $h_i$ 和 $p_i$ —— 海平面高度和玩家所在点的索引（$0 \\le h_i \\le 10^6$；$1 \\le p_i \\le n$）。", "outputFormat": "对于每个情景，输出一个实数 —— 玩家所在岛屿部分的表面积。如果玩家所在位置被淹没，输出 $-1$。\n\n答案的绝对或相对误差不超过 $10^{-6}$ 即视为正确。\n", "hint": "样例图示为岛屿的俯视图。淹没区域用阴影表示，岛屿用等高线绘制，颜色越深表示高度越高。\n\n### 样例 1\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6i7gpzp5.png)\n\n### 样例 2\n\n第二个样例中的岛屿形态如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/85a3xso9.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kgxdolc5.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zf3pxpa6.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12821", "type": "P", "difficulty": 7, "samples": [["4\n1 15 10\n4\n1 10 1\n10\n2 15 10\n4 5\n2 11 15\n10 17", "5\n1\n26\n504"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "ICPC", "NERC/NEERC"], "title": "[NERC 2021] Heroes of Might", "background": "", "description": "Recently, Hellen played her favorite game \"Heroes of Might\". She had a hero with only one Rust dragon, which was attacked by another hero with a lot of peasants. Another hero had $n$ groups of peasants, $i$-th of them had $a_i$ peasants in it. Unfortunately, Hellen lost that battle, but now she is wondering how big the health of the Rust dragon should be to win against such a big army of peasants?\n\nLet's discuss how the battle goes. Initially, the Rust dragon has $h_d$ health points, and each peasant has $h_p$ health points. So $i$-th group of peasants has a total of $H = h_p \\cdot a_i$ health points at the start of the battle. The battle consists of several rounds. In each round, two things happen:\n\n- First, $\\textbf{the dragon chooses one group of peasants and attacks it}$. The health of that group is decreased by the dragon's damage rating $d$. If the group has zero or less health points, it is destroyed and is removed from the game. \n- Second, $\\textbf{each one of the peasant groups attacks the dragon}$. A group with the total current health $H$ has $\\lceil\\frac{H}{h_p}\\rceil$ peasants still alive and each of them decreases the dragon's health by one.\n\nIf the dragon's health becomes zero or less at any point, it dies and Hellen loses. If all peasant groups are destroyed, Hellen wins the battle. \n\nYou need to determine the smallest possible $h_d$, which could make Hellen win if she chooses targets on each turn optimally. ", "inputFormat": "The first line of the input contains an integer $t$ ($1 \\le t \\le 1000$) --- the number of test cases you need to solve.\n\nEach of the test cases is described by two lines. The first line contains three numbers $n$ ($1 \\le n \\le 1000$), $d$ ($1 \\le d \\le 10^9$), and $h_p$ ($1 \\le h_p \\le 10^9$) --- the number of peasant groups, the dragon's damage rating, and the health of each peasant. The second line contains $n$ numbers $a_i$ ($1 \\le a_i \\le 10^9; h_p \\cdot \\sum{a_i} \\le 10^9$) --- the number of peasants in each group.\n\nThe sum of $n$ over all test cases does not exceed $1000$.", "outputFormat": "For each test case, output one number --- the smallest amount of health $h_d$ that the dragon should have for Hellen to win the battle. If the dragon is never attacked by a peasant, it should still have positive health, so output 1 in this case.", "hint": "In the third test case, the optimal Hellen's strategy leads to the following battle. At the start, the dragon has $h_d=26$ health points, and two groups of peasants have $H_1=4\\cdot10$ and $H_2=5\\cdot10$ health points. We'll denote them as $H_1=40(4)$ and $H_2=50(5)$, placing the value of $\\lceil\\frac{H}{h_p}\\rceil$ in the brackets. \n\n$$\\begin{array}{c}\nh_d=26, H_1=40(4), H_2=50(5) & \\text{Round 1} & \\textbf{The dragon attacks the first group}, \\text{dealing 15 damage, leaving}\\ H_1=25(3). \\\\\nh_d=26, H_1=25(3), H_2=50(5) &  & \\text{Peasants attack the dragon}, \\text{dealing 3+5 damage, leaving}\\ h_d=18. \\\\\nh_d=18, H_1=25(3), H_2=50(5) & \\text{Round 2} & \\textbf{The dragon attacks the first group}, \\text{dealing 15 damage, leaving}\\ H_1=10(1). \\\\\nh_d=18, H_1=10(1), H_2=50(5) & & \\text{Peasants attack the dragon}, \\text{dealing 1+5 damage, leaving}\\ h_d=12. \\\\\nh_d=12, H_1=10(1), H_2=50(5) & \\text{Round 3} & \\textbf{The dragon attacks the second group}, \\text{dealing 15 damage, leaving}\\ H_2=35(4). \\\\\nh_d=12, H_1=10(1), H_2=35(4) &  & \\text{Peasants attack the dragon}, \\text{dealing 1+4 damage, leaving}\\ h_d=7. \\\\\nh_d=7, H_1=10(1), H_2=35(4) & \\text{Round 4} & \\textbf{The dragon attacks the second group}, \\text{dealing 15 damage, leaving}\\ H_2=20(2). \\\\\nh_d=7, H_1=10(1), H_2=20(2) &  & \\text{Peasants attack the dragon}, \\text{dealing 1+2 damage, leaving}\\ h_d=4. \\\\\nh_d=4, H_1=10(1), H_2=20(2) & \\text{Round 5} & \\textbf{The dragon attacks the second group}, \\text{dealing 15 damage, leaving}\\ H_2=5(1) \\\\\nh_d=4, H_1=10(1), H_2=5(1) &  & \\text{Peasants attack the dragon}, \\text{dealing 1+1 damage, leaving}\\ h_d=2. \\\\\nh_d=2, H_1=10(1), H_2=5(1) & \\text{Round 6} & \\textbf{The dragon attacks the second group},  \\text{destroying it, so it is removed from the game.} \\\\\nh_d=2, H_1=10(1) &  & \\text{Peasants attack the dragon}, \\text{dealing 1 damage, leaving}\\ h_d=1. \\\\\nh_d=1, H_1=10(1) & \\text{Round 7} & \\textbf{The dragon attacks the first group}, \\text{destroying it, so it is removed from the game.} \\\\\nh_d=1 & \\text{Game over} & \\text{The dragon is still alive, Hellen wins.}\n\\end{array}$$", "locale": "en", "translations": {"en": {"title": "[NERC 2021] Heroes of Might", "background": "", "description": "Recently, Hellen played her favorite game \"Heroes of Might\". She had a hero with only one Rust dragon, which was attacked by another hero with a lot of peasants. Another hero had $n$ groups of peasants, $i$-th of them had $a_i$ peasants in it. Unfortunately, Hellen lost that battle, but now she is wondering how big the health of the Rust dragon should be to win against such a big army of peasants?\n\nLet's discuss how the battle goes. Initially, the Rust dragon has $h_d$ health points, and each peasant has $h_p$ health points. So $i$-th group of peasants has a total of $H = h_p \\cdot a_i$ health points at the start of the battle. The battle consists of several rounds. In each round, two things happen:\n\n- First, $\\textbf{the dragon chooses one group of peasants and attacks it}$. The health of that group is decreased by the dragon's damage rating $d$. If the group has zero or less health points, it is destroyed and is removed from the game. \n- Second, $\\textbf{each one of the peasant groups attacks the dragon}$. A group with the total current health $H$ has $\\lceil\\frac{H}{h_p}\\rceil$ peasants still alive and each of them decreases the dragon's health by one.\n\nIf the dragon's health becomes zero or less at any point, it dies and Hellen loses. If all peasant groups are destroyed, Hellen wins the battle. \n\nYou need to determine the smallest possible $h_d$, which could make Hellen win if she chooses targets on each turn optimally. ", "inputFormat": "The first line of the input contains an integer $t$ ($1 \\le t \\le 1000$) --- the number of test cases you need to solve.\n\nEach of the test cases is described by two lines. The first line contains three numbers $n$ ($1 \\le n \\le 1000$), $d$ ($1 \\le d \\le 10^9$), and $h_p$ ($1 \\le h_p \\le 10^9$) --- the number of peasant groups, the dragon's damage rating, and the health of each peasant. The second line contains $n$ numbers $a_i$ ($1 \\le a_i \\le 10^9; h_p \\cdot \\sum{a_i} \\le 10^9$) --- the number of peasants in each group.\n\nThe sum of $n$ over all test cases does not exceed $1000$.", "outputFormat": "For each test case, output one number --- the smallest amount of health $h_d$ that the dragon should have for Hellen to win the battle. If the dragon is never attacked by a peasant, it should still have positive health, so output 1 in this case.", "hint": "In the third test case, the optimal Hellen's strategy leads to the following battle. At the start, the dragon has $h_d=26$ health points, and two groups of peasants have $H_1=4\\cdot10$ and $H_2=5\\cdot10$ health points. We'll denote them as $H_1=40(4)$ and $H_2=50(5)$, placing the value of $\\lceil\\frac{H}{h_p}\\rceil$ in the brackets. \n\n$$\\begin{array}{c}\nh_d=26, H_1=40(4), H_2=50(5) & \\text{Round 1} & \\textbf{The dragon attacks the first group}, \\text{dealing 15 damage, leaving}\\ H_1=25(3). \\\\\nh_d=26, H_1=25(3), H_2=50(5) &  & \\text{Peasants attack the dragon}, \\text{dealing 3+5 damage, leaving}\\ h_d=18. \\\\\nh_d=18, H_1=25(3), H_2=50(5) & \\text{Round 2} & \\textbf{The dragon attacks the first group}, \\text{dealing 15 damage, leaving}\\ H_1=10(1). \\\\\nh_d=18, H_1=10(1), H_2=50(5) & & \\text{Peasants attack the dragon}, \\text{dealing 1+5 damage, leaving}\\ h_d=12. \\\\\nh_d=12, H_1=10(1), H_2=50(5) & \\text{Round 3} & \\textbf{The dragon attacks the second group}, \\text{dealing 15 damage, leaving}\\ H_2=35(4). \\\\\nh_d=12, H_1=10(1), H_2=35(4) &  & \\text{Peasants attack the dragon}, \\text{dealing 1+4 damage, leaving}\\ h_d=7. \\\\\nh_d=7, H_1=10(1), H_2=35(4) & \\text{Round 4} & \\textbf{The dragon attacks the second group}, \\text{dealing 15 damage, leaving}\\ H_2=20(2). \\\\\nh_d=7, H_1=10(1), H_2=20(2) &  & \\text{Peasants attack the dragon}, \\text{dealing 1+2 damage, leaving}\\ h_d=4. \\\\\nh_d=4, H_1=10(1), H_2=20(2) & \\text{Round 5} & \\textbf{The dragon attacks the second group}, \\text{dealing 15 damage, leaving}\\ H_2=5(1) \\\\\nh_d=4, H_1=10(1), H_2=5(1) &  & \\text{Peasants attack the dragon}, \\text{dealing 1+1 damage, leaving}\\ h_d=2. \\\\\nh_d=2, H_1=10(1), H_2=5(1) & \\text{Round 6} & \\textbf{The dragon attacks the second group},  \\text{destroying it, so it is removed from the game.} \\\\\nh_d=2, H_1=10(1) &  & \\text{Peasants attack the dragon}, \\text{dealing 1 damage, leaving}\\ h_d=1. \\\\\nh_d=1, H_1=10(1) & \\text{Round 7} & \\textbf{The dragon attacks the first group}, \\text{destroying it, so it is removed from the game.} \\\\\nh_d=1 & \\text{Game over} & \\text{The dragon is still alive, Hellen wins.}\n\\end{array}$$", "locale": "en"}, "zh-CN": {"title": "[NERC 2021] Heroes of Might", "background": "", "description": "最近，Hellen 玩了她最爱的游戏《英雄无敌》。她有一个只带了一条锈龙的英雄，结果被另一个带着大量农民的英雄攻击了。对方英雄有 $n$ 组农民，第 $i$ 组有 $a_i$ 个农民。不幸的是，Hellen 输掉了那场战斗，但现在她在思考：锈龙需要多少生命值才能击败这么庞大的农民军队？\n\n让我们讨论战斗的流程。初始时，锈龙有 $h_d$ 点生命值，每个农民有 $h_p$ 点生命值。因此，第 $i$ 组农民在战斗开始时总共有 $H = h_p \\cdot a_i$ 点生命值。战斗由若干回合组成，每回合发生以下两件事：\n\n1. **锈龙选择一组农民并攻击它**。该组的生命值减少 $d$ 点（$d$ 是锈龙的攻击力）。如果该组的生命值降至零或以下，它会被摧毁并从游戏中移除。\n2. **每一组存活的农民都会攻击锈龙**。当前总生命值为 $H$ 的组仍有 $\\lceil\\frac{H}{h_p}\\rceil$ 个存活的农民，每个农民会减少锈龙 1 点生命值。\n\n如果在任意时刻锈龙的生命值降至零或以下，它就会死亡，Hellen 输掉战斗。如果所有农民组都被摧毁，Hellen 获胜。\n\n你需要求出最小的 $h_d$ 值，使得 Hellen 在每回合最优选择攻击目标的情况下能够获胜。", "inputFormat": "输入的第一行包含一个整数 $t$（$1 \\le t \\le 1000$）—— 需要解决的测试用例数量。\n\n每个测试用例由两行描述。第一行包含三个数 $n$（$1 \\le n \\le 1000$）、$d$（$1 \\le d \\le 10^9$）和 $h_p$（$1 \\le h_p \\le 10^9$）—— 农民组的数量、锈龙的攻击力以及每个农民的生命值。第二行包含 $n$ 个数 $a_i$（$1 \\le a_i \\le 10^9$；$h_p \\cdot \\sum{a_i} \\le 10^9$）—— 每组农民的数量。\n\n所有测试用例的 $n$ 之和不超过 $1000$。", "outputFormat": "对于每个测试用例，输出一个数 —— 锈龙需要的最小生命值 $h_d$，使得 Hellen 能获胜。如果农民从未攻击过锈龙，锈龙仍需保持正生命值，此时输出 $1$。\n", "hint": "在第三个测试用例中，Hellen 的最优策略导致战斗流程如下：初始时，锈龙有 $h_d=26$ 点生命值，两组农民的生命值分别为 $H_1=4\\cdot10$ 和 $H_2=5\\cdot10$。我们用 $H_1=40(4)$ 和 $H_2=50(5)$ 表示，括号内是 $\\lceil\\frac{H}{h_p}\\rceil$ 的值。\n\n$$\\begin{array}{c}\nh_d=26, H_1=40(4), H_2=50(5) & \\text{第 1 回合} & \\textbf{锈龙攻击第一组}，造成\\ 15\\ 点伤害，剩余\\ H_1=25(3)。 \\\\\nh_d=26, H_1=25(3), H_2=50(5) &  & \\text{农民攻击锈龙}，造成\\ 3+5\\ 点伤害，剩余\\ h_d=18。 \\\\\nh_d=18, H_1=25(3), H_2=50(5) & \\text{第 2 回合} & \\textbf{锈龙攻击第一组}，造成\\ 15\\ 点伤害，剩余\\ H_1=10(1)。 \\\\\nh_d=18, H_1=10(1), H_2=50(5) &  & \\text{农民攻击锈龙}，造成\\ 1+5\\ 点伤害，剩余\\ h_d=12。 \\\\\nh_d=12, H_1=10(1), H_2=50(5) & \\text{第 3 回合} & \\textbf{锈龙攻击第二组}，造成\\ 15\\ 点伤害，剩余\\ H_2=35(4)。 \\\\\nh_d=12, H_1=10(1), H_2=35(4) &  & \\text{农民攻击锈龙}，造成\\ 1+4\\ 点伤害，剩余\\ h_d=7。 \\\\\nh_d=7, H_1=10(1), H_2=35(4) & \\text{第 4 回合} & \\textbf{锈龙攻击第二组}，造成\\ 15\\ 点伤害，剩余\\ H_2=20(2)。 \\\\\nh_d=7, H_1=10(1), H_2=20(2) &  & \\text{农民攻击锈龙}，造成\\ 1+2\\ 点伤害，剩余\\ h_d=4。 \\\\\nh_d=4, H_1=10(1), H_2=20(2) & \\text{第 5 回合} & \\textbf{锈龙攻击第二组}，造成\\ 15\\ 点伤害，剩余\\ H_2=5(1)。 \\\\\nh_d=4, H_1=10(1), H_2=5(1) &  & \\text{农民攻击锈龙}，造成\\ 1+1\\ 点伤害，剩余\\ h_d=2。 \\\\\nh_d=2, H_1=10(1), H_2=5(1) & \\text{第 6 回合} & \\textbf{锈龙攻击第二组}，摧毁该组，将其从游戏中移除。 \\\\\nh_d=2, H_1=10(1) &  & \\text{农民攻击锈龙}，造成 \\ 1\\ 点伤害，剩余\\ h_d=1。 \\\\\nh_d=1, H_1=10(1) & \\text{第 7 回合} & \\textbf{锈龙攻击第一组}，摧毁该组，将其从游戏中移除。 \\\\\nh_d=1 & \\text{战斗结束} & \\text{锈龙存活，\\ Hellen\\ 获胜。}\n\\end{array}$$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12822", "type": "P", "difficulty": 4, "samples": [["1\n2 3\n\n1\n\n1\n\n3\n\n0\n\n1", "\n\nSCAN 1 2\n\nDIG 1 2\n\nSCAN 2 2\n\nDIG 1 1\n\nDIG 1 3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "交互题", "Special Judge", "构造", "ICPC", "Ad-hoc", "NERC/NEERC"], "title": "[NERC 2021] Interactive Treasure Hunt", "background": "", "description": "$\\textit{This is an interactive problem.}$\n\nThere is a grid of $n\\times m$ cells. Two treasure chests are buried in two different cells of the grid. Your task is to find both of them. You can make two types of operations:\n\n- $\\tt{DIG}$ $r$ $c$: try to find the treasure in the cell $(r, c)$. The interactor will tell you if you found the treasure or not.\n- $\\tt{SCAN}$ $r$ $c$: scan from the cell $(r, c)$. The result of this operation is the sum of Manhattan distances from the cell $(r, c)$ to the cells where the treasures are hidden. Manhattan distance from a cell $(r_1, c_1)$ to a cell $(r_2, c_2)$ is calculated as $|r_1 - r_2| + |c_1 - c_2|$.\nYou need to find the treasures in at most 7 operations. This includes both $\\tt{DIG}$ and $\\tt{SCAN}$ operations in total. To solve the test you need to call $\\tt{DIG}$ operation at least once in both of the cells where the treasures are hidden.\n\n### Interactive Protocol\n\nYour program has to process multiple test cases in a single run. First, the testing system writes $t$ --- the number of test cases ($1\\le t \\le 100$). Then, $t$ test cases should be processed one by one.\n\nIn each test case, your program should start by reading the integers $n$ and $m$ ($2 \\le n, m \\le 16$).\n\nThen, your program can make queries of two types:\n\n- $\\tt{DIG}$ $r$ $c$ ($1\\le r\\le n$; $1\\le c\\le m$). The interactor responds with integer $1$, if you found the treasure, and $0$ if not. If you try to find the treasure in the same cell multiple times, the result will be $0$ since the treasure is already found. \n\n- $\\tt{SCAN}$ $r$ $c$ ($1\\le r\\le n$; $1\\le c\\le m$). The interactor responds with an integer that is the sum of Manhattan distances from the cell $(r, c)$ to the cells where the treasures were hidden. The sum is calculated for both cells with treasures, even if you already found one of them.\n\nAfter you found both treasures, i.e. you received $1$ for two $\\tt{DIG}$ operations, your program should continue to the next test case or exit if that test case was the last one. ", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2021] Interactive Treasure Hunt", "background": "", "description": "$\\textit{This is an interactive problem.}$\n\nThere is a grid of $n\\times m$ cells. Two treasure chests are buried in two different cells of the grid. Your task is to find both of them. You can make two types of operations:\n\n- $\\tt{DIG}$ $r$ $c$: try to find the treasure in the cell $(r, c)$. The interactor will tell you if you found the treasure or not.\n- $\\tt{SCAN}$ $r$ $c$: scan from the cell $(r, c)$. The result of this operation is the sum of Manhattan distances from the cell $(r, c)$ to the cells where the treasures are hidden. Manhattan distance from a cell $(r_1, c_1)$ to a cell $(r_2, c_2)$ is calculated as $|r_1 - r_2| + |c_1 - c_2|$.\nYou need to find the treasures in at most 7 operations. This includes both $\\tt{DIG}$ and $\\tt{SCAN}$ operations in total. To solve the test you need to call $\\tt{DIG}$ operation at least once in both of the cells where the treasures are hidden.\n\n### Interactive Protocol\n\nYour program has to process multiple test cases in a single run. First, the testing system writes $t$ --- the number of test cases ($1\\le t \\le 100$). Then, $t$ test cases should be processed one by one.\n\nIn each test case, your program should start by reading the integers $n$ and $m$ ($2 \\le n, m \\le 16$).\n\nThen, your program can make queries of two types:\n\n- $\\tt{DIG}$ $r$ $c$ ($1\\le r\\le n$; $1\\le c\\le m$). The interactor responds with integer $1$, if you found the treasure, and $0$ if not. If you try to find the treasure in the same cell multiple times, the result will be $0$ since the treasure is already found. \n\n- $\\tt{SCAN}$ $r$ $c$ ($1\\le r\\le n$; $1\\le c\\le m$). The interactor responds with an integer that is the sum of Manhattan distances from the cell $(r, c)$ to the cells where the treasures were hidden. The sum is calculated for both cells with treasures, even if you already found one of them.\n\nAfter you found both treasures, i.e. you received $1$ for two $\\tt{DIG}$ operations, your program should continue to the next test case or exit if that test case was the last one. ", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2021] Interactive Treasure Hunt", "background": "", "description": "**这是一道交互题。**\n\n有一个 $n \\times m$ 的网格。两个宝箱被埋藏在网格的两个不同单元格中。你的任务是找到这两个宝箱。你可以进行两种操作：\n\n1. **DIG** $r$ $c$：尝试在单元格 $(r, c)$ 挖掘宝藏。交互器会告诉你是否找到了宝藏。\n2. **SCAN** $r$ $c$：从单元格 $(r, c)$ 进行扫描。该操作的结果是从 $(r, c)$ 到两个宝藏所在单元格的曼哈顿距离之和。曼哈顿距离的计算公式为 $|r_1 - r_2| + |c_1 - c_2|$。\n\n你需要在最多 7 次操作内找到两个宝藏（包括 **DIG** 和 **SCAN** 操作）。为了通过测试，你必须在两个藏有宝藏的单元格中各调用至少一次 **DIG** 操作。\n\n### 交互协议\n\n你的程序需要在一轮运行中处理多个测试用例。首先，测试系统会给出 $t$ —— 测试用例的数量（$1 \\le t \\le 100$）。然后，依次处理 $t$ 个测试用例。\n\n在每个测试用例中，你的程序首先需要读取两个整数 $n$ 和 $m$（$2 \\le n, m \\le 16$）。\n\n然后，你的程序可以发起以下两种查询：\n\n1. **DIG** $r$ $c$（$1 \\le r \\le n$；$1 \\le c \\le m$）。交互器会返回整数 $1$（如果找到了宝藏）或 $0$（如果未找到）。如果你多次在同一个单元格挖掘，由于宝藏已被取走，结果将始终为 $0$。\n2. **SCAN** $r$ $c$（$1 \\le r \\le n$；$1 \\le c \\le m$）。交互器会返回一个整数，表示从 $(r, c)$ 到两个宝藏所在单元格的曼哈顿距离之和。即使你已经找到一个宝藏，该操作仍然会计算两个宝藏的距离之和。\n\n当你找到两个宝藏（即通过 **DIG** 操作两次获得 $1$ 的响应）后，你的程序应继续处理下一个测试用例，或者如果是最后一个测试用例则退出。\n", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12823", "type": "P", "difficulty": 5, "samples": [["4\n0 566 1 0\n566 0 239 30\n1 239 0 1\n0 30 1 0", "2 4 2 0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "Special Judge", "区间 DP", "ICPC", "NERC/NEERC"], "title": "[NERC 2021] Job Lookup", "background": "", "description": "Julia's $n$ friends want to organize a startup in a new country they moved to. They assigned each other numbers from 1 to $n$ according to the jobs they have, from the most front-end tasks to the most back-end ones. They also estimated a matrix $c$, where $c_{ij} = c_{ji}$ is the average number of messages per month between people doing jobs $i$ and $j$.\n\nNow they want to make a hierarchy tree. It will be a $\\textbf{binary tree}$ with each node containing one member of the team. Some member will be selected as a leader of the team and will be contained in the root node. In order for the leader to be able to easily reach any subordinate, for each node $v$ of the tree, the following should apply: all members in its left subtree must have smaller numbers than $v$, and all members in its right subtree must \nhave larger numbers than $v$.\n\nAfter the hierarchy tree is settled, people doing jobs $i$ and $j$ will be communicating via the shortest path in the tree between their nodes. Let's denote the length of this path as $d_{ij}$. Thus, the cost of their communication is $c_{ij} \\cdot d_{ij}$.\n\nYour task is to find a hierarchy tree that minimizes the total cost of communication over all pairs: $\\sum_{1 \\le i < j \\le n} c_{ij} \\cdot d_{ij}$.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 200$) -- the number of team members organizing a startup.\n\nThe next $n$ lines contain $n$ integers each, $j$-th number in $i$-th line is $c_{ij}$ ---\nthe estimated number of messages per month between team members $i$ and $j$ ($0 \\le c_{ij} \\le 10^9; c_{ij} = c_{ji}; c_{ii} = 0$).", "outputFormat": "Output a description of a hierarchy tree that minimizes the total cost of communication. To do so, for each team member from 1 to $n$ output the number of the member in its parent node, or 0 for the leader. If there are many optimal trees, output a description of any one of them.\n", "hint": "The minimal possible total cost is $566 \\cdot 1+239 \\cdot 1+30 \\cdot 1+1 \\cdot 2+1 \\cdot 2=839$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/isxizhg5.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2021] Job Lookup", "background": "", "description": "Julia's $n$ friends want to organize a startup in a new country they moved to. They assigned each other numbers from 1 to $n$ according to the jobs they have, from the most front-end tasks to the most back-end ones. They also estimated a matrix $c$, where $c_{ij} = c_{ji}$ is the average number of messages per month between people doing jobs $i$ and $j$.\n\nNow they want to make a hierarchy tree. It will be a $\\textbf{binary tree}$ with each node containing one member of the team. Some member will be selected as a leader of the team and will be contained in the root node. In order for the leader to be able to easily reach any subordinate, for each node $v$ of the tree, the following should apply: all members in its left subtree must have smaller numbers than $v$, and all members in its right subtree must \nhave larger numbers than $v$.\n\nAfter the hierarchy tree is settled, people doing jobs $i$ and $j$ will be communicating via the shortest path in the tree between their nodes. Let's denote the length of this path as $d_{ij}$. Thus, the cost of their communication is $c_{ij} \\cdot d_{ij}$.\n\nYour task is to find a hierarchy tree that minimizes the total cost of communication over all pairs: $\\sum_{1 \\le i < j \\le n} c_{ij} \\cdot d_{ij}$.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 200$) -- the number of team members organizing a startup.\n\nThe next $n$ lines contain $n$ integers each, $j$-th number in $i$-th line is $c_{ij}$ ---\nthe estimated number of messages per month between team members $i$ and $j$ ($0 \\le c_{ij} \\le 10^9; c_{ij} = c_{ji}; c_{ii} = 0$).", "outputFormat": "Output a description of a hierarchy tree that minimizes the total cost of communication. To do so, for each team member from 1 to $n$ output the number of the member in its parent node, or 0 for the leader. If there are many optimal trees, output a description of any one of them.\n", "hint": "The minimal possible total cost is $566 \\cdot 1+239 \\cdot 1+30 \\cdot 1+1 \\cdot 2+1 \\cdot 2=839$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/isxizhg5.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2021] Job Lookup", "background": "", "description": "Julia 的 $n$ 个朋友想要在他们新搬去的国家创办一家初创公司。他们根据各自的工作内容（从前端到后端）给自己分配了编号 $1$ 到 $n$。他们还估计了一个矩阵 $c$，其中 $c_{ij} = c_{ji}$ 表示从事工作 $i$ 和 $j$ 的人之间每月的平均消息数量。\n\n现在他们想要建立一棵**层级树**。这棵树将是一棵**二叉树**，每个节点包含团队中的一名成员。某位成员将被选为团队领导，并位于根节点。为了确保领导能够轻松联系到任何下属，对于树中的每个节点 $v$，必须满足以下条件：其左子树中的所有成员编号必须小于 $v$，而其右子树中的所有成员编号必须大于 $v$。\n\n当层级树确定后，从事工作 $i$ 和 $j$ 的成员将通过他们在树中节点之间的最短路径进行通信。设该路径长度为 $d_{ij}$，则他们的通信成本为 $c_{ij} \\cdot d_{ij}$。\n\n你的任务是找到一棵层级树，使得所有成员对的通信总成本最小化：$\\sum_{1 \\le i < j \\le n} c_{ij} \\cdot d_{ij}$。\n", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 200$）—— 组织初创公司的团队成员数量。\n\n接下来的 $n$ 行，每行包含 $n$ 个整数，第 $i$ 行的第 $j$ 个数是 $c_{ij}$ —— 团队成员 $i$ 和 $j$ 之间每月的估计消息数量（$0 \\le c_{ij} \\le 10^9$；$c_{ij} = c_{ji}$；$c_{ii} = 0$）。\n", "outputFormat": "输出描述一棵最小化通信总成本的层级树。为此，对于编号从 $1$ 到 $n$ 的每个团队成员，输出其父节点的成员编号，如果是领导（根节点）则输出 $0$。如果存在多棵最优树，输出其中任意一棵的描述即可。\n", "hint": "最小的可能总成本为 $566 \\cdot 1 + 239 \\cdot 1 + 30 \\cdot 1 + 1 \\cdot 2 + 1 \\cdot 2 = 839$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/isxizhg5.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12824", "type": "P", "difficulty": 7, "samples": [["6 7\n1 3\n1 2 10\n2 3 5\n1 3 7\n4 5 3\n3 6 100\n4 6 3\n5 6 8", "16\nABBCBA"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "网络流", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2021] Kingdom Partition", "background": "", "description": "The King is gone. After the King's rule, all the roads in the Kingdom are run down and need repair. Three of the King's children, Adrian, Beatrice and Cecilia, are dividing the Kingdom between themselves.\n\nAdrian and Beatrice do not like each other and do not plan to maintain any relations between themselves in the future. Cecilia is on good terms with both of them. Moreover, most of the Kingdom's workers support Cecilia, so she has better resources and more opportunity to repair the infrastructure and develop the~economy. \n\nCecilia proposes to partition the Kingdom into three districts: A (for Adrian), B (for Beatrice), and C (for Cecilia), and let Adrian and Beatrice to negotiate and choose any towns they want to be in their districts, and agree on how they want to partition the Kingdom into three districts.\n\nAdrian's castle is located in town $a$, and Beatrice's one is located in town $b$. So Adrian and Beatrice want their castles to be located in districts A and B, respectively. Cecilia doesn't have a castle, so district C can consist of no towns.\n\nThere is an issue for Adrian and Beatrice. When they choose the towns, they will have to pay for the roads' repair.\n\nThe cost to repair the road of length $l$ is $2l$ gold. However, Adrian and Beatrice don't have to bear all the repair costs. The repair cost for the road of length $l$ that they bear depends on what towns it connects:\n\n- For a road between two towns inside district A, Adrian has to pay $2l$ gold;\n- For a road between two towns inside district B, Beatrice has to pay $2l$ gold;\n- For a road between towns from district A and district C, Adrian has to pay $l$ gold, Cecilia bears the remaining cost;\n- For a road between towns from district B and district C, Beatrice has to pay $l$ gold, Cecilia bears the remaining cost.\n\nThe roads that connect towns from district A and district B won't be repaired, since Adrian and Beatrice are not planning to use them, so no one pays for them. Cecilia herself will repair the roads that connect the towns inside district C, so Adrian and Beatrice won't bear the cost of their repair either.\n\nAdrian and Beatrice want to minimize the total cost they spend on roads' repair. Find the cheapest way for them to partition the Kingdom into three districts.", "inputFormat": "The first line contains two integers $n$ and $m$ --- the number of towns and the number of roads in the Kingdom ($2 \\le n \\le 1000$; $0 \\le m \\le 2000$).\n\nThe second line contains two integers that represent town $a$ and town $b$ --- the towns that have to be located in district A and district B, respectively ($1 \\le a, b \\le n$; $a \\ne b$).\n\nThe following $m$ lines describe the Kingdom roads. The $i$-th of them consists of three integers $u_i$, $v_i$, and $l_i$ representing a road of length $l_i$ between towns $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$; $u_i \\ne v_i$; $1 \\le l_i \\le 10^9$).\n\nEach pair of towns is connected with at most one road.", "outputFormat": "In the first line output a single integer --- the minimum total cost of roads' repair for Adrian and Beatrice.\n\nIn the second line output a string consisting of $n$ characters $\\tt{A}$, $\\tt{B}$, and $\\tt{C}$, $i$-th of the characters representing the district that the $i$-th town should belong to.\n\nIf several cheapest ways to partition the Kingdom exist, print any of them.", "hint": "The following picture illustrates the example. Adrian and Beatrice don't pay for the dashed roads, they pay $2l$ for the bold roads, and $l$ for the solid roads.\n\nSo the total cost is $2 \\cdot 5 + 3 + 3 = 16$.\n\nThe castles of Adrian and Beatrice are located in bold towns.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/11ffx3k7.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2021] Kingdom Partition", "background": "", "description": "The King is gone. After the King's rule, all the roads in the Kingdom are run down and need repair. Three of the King's children, Adrian, Beatrice and Cecilia, are dividing the Kingdom between themselves.\n\nAdrian and Beatrice do not like each other and do not plan to maintain any relations between themselves in the future. Cecilia is on good terms with both of them. Moreover, most of the Kingdom's workers support Cecilia, so she has better resources and more opportunity to repair the infrastructure and develop the~economy. \n\nCecilia proposes to partition the Kingdom into three districts: A (for Adrian), B (for Beatrice), and C (for Cecilia), and let Adrian and Beatrice to negotiate and choose any towns they want to be in their districts, and agree on how they want to partition the Kingdom into three districts.\n\nAdrian's castle is located in town $a$, and Beatrice's one is located in town $b$. So Adrian and Beatrice want their castles to be located in districts A and B, respectively. Cecilia doesn't have a castle, so district C can consist of no towns.\n\nThere is an issue for Adrian and Beatrice. When they choose the towns, they will have to pay for the roads' repair.\n\nThe cost to repair the road of length $l$ is $2l$ gold. However, Adrian and Beatrice don't have to bear all the repair costs. The repair cost for the road of length $l$ that they bear depends on what towns it connects:\n\n- For a road between two towns inside district A, Adrian has to pay $2l$ gold;\n- For a road between two towns inside district B, Beatrice has to pay $2l$ gold;\n- For a road between towns from district A and district C, Adrian has to pay $l$ gold, Cecilia bears the remaining cost;\n- For a road between towns from district B and district C, Beatrice has to pay $l$ gold, Cecilia bears the remaining cost.\n\nThe roads that connect towns from district A and district B won't be repaired, since Adrian and Beatrice are not planning to use them, so no one pays for them. Cecilia herself will repair the roads that connect the towns inside district C, so Adrian and Beatrice won't bear the cost of their repair either.\n\nAdrian and Beatrice want to minimize the total cost they spend on roads' repair. Find the cheapest way for them to partition the Kingdom into three districts.", "inputFormat": "The first line contains two integers $n$ and $m$ --- the number of towns and the number of roads in the Kingdom ($2 \\le n \\le 1000$; $0 \\le m \\le 2000$).\n\nThe second line contains two integers that represent town $a$ and town $b$ --- the towns that have to be located in district A and district B, respectively ($1 \\le a, b \\le n$; $a \\ne b$).\n\nThe following $m$ lines describe the Kingdom roads. The $i$-th of them consists of three integers $u_i$, $v_i$, and $l_i$ representing a road of length $l_i$ between towns $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$; $u_i \\ne v_i$; $1 \\le l_i \\le 10^9$).\n\nEach pair of towns is connected with at most one road.", "outputFormat": "In the first line output a single integer --- the minimum total cost of roads' repair for Adrian and Beatrice.\n\nIn the second line output a string consisting of $n$ characters $\\tt{A}$, $\\tt{B}$, and $\\tt{C}$, $i$-th of the characters representing the district that the $i$-th town should belong to.\n\nIf several cheapest ways to partition the Kingdom exist, print any of them.", "hint": "The following picture illustrates the example. Adrian and Beatrice don't pay for the dashed roads, they pay $2l$ for the bold roads, and $l$ for the solid roads.\n\nSo the total cost is $2 \\cdot 5 + 3 + 3 = 16$.\n\nThe castles of Adrian and Beatrice are located in bold towns.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/11ffx3k7.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2021] Kingdom Partition", "background": "", "description": "国王已逝。在国王统治结束后，王国中的所有道路都已年久失修，需要修复。国王的三个孩子 Adrian、Beatrice 和 Cecilia 正在商议如何将王国划分为三个区域。\n\nAdrian 和 Beatrice 彼此不和，未来也不打算维持任何关系。Cecilia 与他们两人关系良好。此外，王国的大多数工人都支持 Cecilia，因此她拥有更好的资源和更多机会来修复基础设施并发展经济。\n\nCecilia 提议将王国划分为三个区域：A（Adrian 的领地）、B（Beatrice 的领地）和 C（Cecilia 的领地），并让 Adrian 和 Beatrice 协商选择他们希望纳入各自领地的城镇，并商定如何将王国划分为三个区域。\n\nAdrian 的城堡位于城镇 $a$，Beatrice 的城堡位于城镇 $b$。因此，Adrian 和 Beatrice 希望他们的城堡分别位于区域 A 和 B。Cecilia 没有城堡，因此区域 C 可以没有城镇。\n\nAdrian 和 Beatrice 在选择城镇时面临一个问题：他们需要承担道路修复的费用。\n\n一条长度为 $l$ 的道路的修复成本为 $2l$ 金币。然而，Adrian 和 Beatrice 不必承担全部修复费用。根据道路连接的城镇所属区域，他们需要承担的费用如下：\n\n- 对于连接两个区域 A 内城镇的道路，Adrian 需要支付 $2l$ 金币；\n- 对于连接两个区域 B 内城镇的道路，Beatrice 需要支付 $2l$ 金币；\n- 对于连接区域 A 和区域 C 城镇的道路，Adrian 需要支付 $l$ 金币，Cecilia 承担剩余费用；\n- 对于连接区域 B 和区域 C 城镇的道路，Beatrice 需要支付 $l$ 金币，Cecilia 承担剩余费用。\n\n连接区域 A 和区域 B 城镇的道路不会被修复，因为 Adrian 和 Beatrice 不打算使用它们，因此无人支付其费用。Cecilia 会自行修复连接区域 C 内城镇的道路，因此 Adrian 和 Beatrice 也不需承担这些道路的修复费用。\n\nAdrian 和 Beatrice 希望最小化他们在道路修复上的总支出。请找出他们划分王国为三个区域的最经济方案。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$ —— 王国中的城镇数量和道路数量（$2 \\le n \\le 1000$；$0 \\le m \\le 2000$）。\n\n第二行包含两个整数 $a$ 和 $b$ —— 必须分别位于区域 A 和区域 B 的城镇（$1 \\le a, b \\le n$；$a \\ne b$）。\n\n接下来的 $m$ 行描述王国的道路。第 $i$ 行包含三个整数 $u_i$、$v_i$ 和 $l_i$，表示城镇 $u_i$ 和 $v_i$ 之间有一条长度为 $l_i$ 的道路（$1 \\le u_i, v_i \\le n$；$u_i \\ne v_i$；$1 \\le l_i \\le 10^9$）。\n\n每对城镇之间最多有一条道路连接。", "outputFormat": "第一行输出一个整数 —— Adrian 和 Beatrice 在道路修复上的最小总成本。\n\n第二行输出一个由 $n$ 个字符组成的字符串，字符为 $\\tt{A}$、$\\tt{B}$ 或 $\\tt{C}$，第 $i$ 个字符表示第 $i$ 个城镇所属的区域。\n\n如果存在多种最小成本的划分方案，输出其中任意一种即可。", "hint": "下图展示了示例的划分方案。Adrian 和 Beatrice 无需为虚线道路支付费用，为粗线道路支付 $2l$，为实线道路支付 $l$。\n\n因此，总成本为 $2 \\cdot 5 + 3 + 3 = 16$。\n\nAdrian 和 Beatrice 的城堡位于加粗的城镇中。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/11ffx3k7.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12825", "type": "P", "difficulty": 3, "samples": [["5 5 1\n1 2\n2 3\n1 4\n4 3\n3 5", "Possible\n3\n1 2 3\n3\n1 4 3"], ["5 5 1\n1 2\n2 3\n3 4\n2 5\n5 4", "Impossible"], ["3 3 2\n1 2\n2 3\n3 1", "Impossible"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2021] Labyrinth", "background": "", "description": "Leslie and Leon entered a labyrinth. The labyrinth consists of $n$ halls and $m$ one-way passages between them. The halls are numbered from $1$ to $n$.\n\nLeslie and Leon start their journey in the hall $s$. Right away, they quarrel and decide to explore the~labyrinth separately. However, they want to meet again at the end of their journey.\n\nTo help Leslie and Leon, your task is to find two different paths from the given hall $s$ to some other hall $t$, such that these two paths do not share halls other than the staring hall $s$ and the ending hall $t$. The hall $t$ has not been determined yet, so you can choose any of the labyrinth's halls as $t$ except $s$.\n\nLeslie's and Leon's paths do not have to be the shortest ones, but their paths must be simple, visiting any hall at most once. Also, they cannot visit any common halls except $s$ and $t$ during their journey, even at different times.", "inputFormat": "The first line contains three integers $n$, $m$, and $s$, where $n$ ($2 \\le n \\le 2 \\cdot 10^5$) is the number of vertices, $m$ ($0 \\le m \\le 2 \\cdot 10^5$) is the number of edges in the labyrinth, and $s$ ($1 \\le s \\le n$) is the starting hall.\n\nThen $m$ lines with descriptions of passages follow. Each description contains two integers $u_i$, $v_i$ ($1 \\le u_i, v_i \\le n$; $u_i \\neq v_i$), denoting a passage from the hall $u_i$ to the hall $v_i$. The passages are one-way. Each tuple $(u_i, v_i)$ is present in the input at most once. The labyrinth can contain cycles and is not necessarily connected in any way.", "outputFormat": "If it is possible to find the desired two paths, output $\\tt{Possible}$, otherwise output $\\tt{Impossible}$.\n\nIf the answer exists, output two path descriptions. Each description occupies two lines. The first line of the description contains an integer $h$ ($2 \\le h \\le n$) --- the number of halls in a path, and the second line contains distinct integers $w_1, w_2, \\dots, w_h$ ($w_1 = s$; $1 \\le w_j \\le n$; $w_h = t$) --- the halls in the path in the order of passing.\nBoth paths must end at the same vertex $t$. The paths must be different, and all intermediate halls in these paths must be distinct.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2021] Labyrinth", "background": "", "description": "Leslie and Leon entered a labyrinth. The labyrinth consists of $n$ halls and $m$ one-way passages between them. The halls are numbered from $1$ to $n$.\n\nLeslie and Leon start their journey in the hall $s$. Right away, they quarrel and decide to explore the~labyrinth separately. However, they want to meet again at the end of their journey.\n\nTo help Leslie and Leon, your task is to find two different paths from the given hall $s$ to some other hall $t$, such that these two paths do not share halls other than the staring hall $s$ and the ending hall $t$. The hall $t$ has not been determined yet, so you can choose any of the labyrinth's halls as $t$ except $s$.\n\nLeslie's and Leon's paths do not have to be the shortest ones, but their paths must be simple, visiting any hall at most once. Also, they cannot visit any common halls except $s$ and $t$ during their journey, even at different times.", "inputFormat": "The first line contains three integers $n$, $m$, and $s$, where $n$ ($2 \\le n \\le 2 \\cdot 10^5$) is the number of vertices, $m$ ($0 \\le m \\le 2 \\cdot 10^5$) is the number of edges in the labyrinth, and $s$ ($1 \\le s \\le n$) is the starting hall.\n\nThen $m$ lines with descriptions of passages follow. Each description contains two integers $u_i$, $v_i$ ($1 \\le u_i, v_i \\le n$; $u_i \\neq v_i$), denoting a passage from the hall $u_i$ to the hall $v_i$. The passages are one-way. Each tuple $(u_i, v_i)$ is present in the input at most once. The labyrinth can contain cycles and is not necessarily connected in any way.", "outputFormat": "If it is possible to find the desired two paths, output $\\tt{Possible}$, otherwise output $\\tt{Impossible}$.\n\nIf the answer exists, output two path descriptions. Each description occupies two lines. The first line of the description contains an integer $h$ ($2 \\le h \\le n$) --- the number of halls in a path, and the second line contains distinct integers $w_1, w_2, \\dots, w_h$ ($w_1 = s$; $1 \\le w_j \\le n$; $w_h = t$) --- the halls in the path in the order of passing.\nBoth paths must end at the same vertex $t$. The paths must be different, and all intermediate halls in these paths must be distinct.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2021] Labyrinth", "background": "", "description": "Leslie 和 Leon 进入了一个迷宫。这个迷宫由 $n$ 个大厅和 $m$ 条单向通道组成，大厅编号为 $1$ 到 $n$。\n\nLeslie 和 Leon 从大厅 $s$ 开始他们的探险。很快他们发生了争吵，决定分开探索迷宫。不过，他们希望在旅程结束时能够再次相遇。\n\n为了帮助 Leslie 和 Leon，你的任务是找到从给定大厅 $s$ 到另一个大厅 $t$ 的两条不同路径，且这两条路径除了起点 $s$ 和终点 $t$ 外不共享任何其他大厅。终点 $t$ 尚未确定，因此你可以选择迷宫中除 $s$ 外的任意大厅作为 $t$。\n\nLeslie 和 Leon 的路径不必是最短路径，但必须是简单路径（即不重复访问任何大厅）。此外，在旅程中除了 $s$ 和 $t$ 外，他们不能访问任何共同的大厅，即使是在不同时间访问也不行。\n", "inputFormat": "第一行包含三个整数 $n$、$m$ 和 $s$，其中 $n$（$2 \\le n \\le 2 \\cdot 10^5$）是顶点数量，$m$（$0 \\le m \\le 2 \\cdot 10^5$）是迷宫中的通道数量，$s$（$1 \\le s \\le n$）是起始大厅。\n\n接下来 $m$ 行描述通道。每行包含两个整数 $u_i$ 和 $v_i$（$1 \\le u_i, v_i \\le n$；$u_i \\neq v_i$），表示一条从大厅 $u_i$ 到大厅 $v_i$ 的单向通道。每条通道 $(u_i, v_i)$ 在输入中最多出现一次。迷宫中可能存在环，且不保证任何连通性。\n", "outputFormat": "如果存在满足条件的两条路径，输出 **Possible**，否则输出 **Impossible**。\n\n如果存在解，则输出两条路径的描述。每条描述占两行：第一行是一个整数 $h$（$2 \\le h \\le n$）表示路径中的大厅数量，第二行是 $h$ 个互不相同的整数 $w_1, w_2, \\dots, w_h$（$w_1 = s$；$1 \\le w_j \\le n$；$w_h = t$），按顺序表示路径经过的大厅。两条路径必须终止于同一个顶点 $t$，且路径必须不同，所有中间大厅必须互不相同。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12826", "type": "P", "difficulty": 2, "samples": [["2\n3\n1 3 7\n3 2 6\n7 6 4\n5\n8 9 10 15 1 \n9 1 2 14 9 \n10 2 3 13 10 \n15 14 13 7 6 \n1 9 10 6 8 \n", "1 2 4 \n1 2\n2 3\n8 1 3 7 8 \n1 2\n1 4\n2 3\n2 5\n"], ["1\n2\n10000000000 29999508480\n29999508480 20000000000", "10000000000 20000000000\n1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["Special Judge", "O2优化", "Ad-hoc", "洛谷比赛"], "title": "「DLESS-2」XOR and Tree Construction", "background": "一道题目需要一个题目背景。", "description": "Bob 有一棵 $n$ 个点的无根树 $T$，树上每个点都有权值，第 $i$ 个点的权值为 $a_i$。Alice 记录了一个 $n\\times n$ 的矩阵 $b$，其中 $b_{i,j}$ 表示树上 $i\\to j$ 最短路径上所有点的点权的异或和。\n\nAlice 观察这个矩阵，惊奇地发现矩阵里所有数都是**正整数**。\n\n不幸的是，某一天，Bob 把他的树搞丢了。于是你得到了 Alice 记录的矩阵，并需要还原出一种可能的树 $T$ 与序列 $a$。值得注意的是，Alice 非常靠谱，因此你总是可以还原出至少一种树。", "inputFormat": "本题有多组测试数据，第一行输入一个正整数 $T$，代表数据组数。\n\n对于每组数据：\n- 第一行输入一个正整数 $n$。\n- 接下来 $n$ 行，每行 $n$ 个正整数，其中第 $i$ 行第 $j$ 个数表示 $b_{i,j}$。", "outputFormat": "对于每组数据：\n- 第一行输出 $n$ 个数，分别代表每个点的点权 $a_1,a_2,\\cdots,a_n$。\n- 接下来 $n-1$ 行，每行输出两个数 $u,v$，代表有一条连接 $u,v$ 的边。", "hint": "对于所有数据，保证：\n- $1\\le T\\le 10$\n- $1\\le n\\le 500$\n- $1\\le b_{i,j}<2^{60}$\n\n**本题采用捆绑测试**，各子任务描述如下：\n- Subtask 1（5 pts）：$n=2$。\n- Subtask 2（10 pts）：$n=3$。\n- Subtask 3（10 pts）：$n=4$。\n- Subtask 4（15 pts）：$n\\le 8$。\n- Subtask 5（25 pts）：$b_{i,i}$ 互不相同。\n- Subtask 6（35 pts）：无特殊限制。", "locale": "zh-CN", "translations": {"en": {"title": "「DLESS-2」XOR and Tree Construction", "background": "", "description": "Bob has an unrooted tree $T$ with $n$ vertices. Each vertex has a weight, with the weight of vertex $i$ being $a_i$. Alice has recorded an $n \\times n$ matrix $b$, where $b_{i,j}$ is the XOR sum of the weights of all vertices on the shortest path from vertex $i$ to vertex $j$.\n\nAlice observed this matrix and, to her surprise, found that all its elements are **positive integers**.\n\nUnfortunately, one day, Bob lost his tree. Now, you are given Alice's matrix $b$, and your task is to reconstruct a possible tree $T$ and the sequence of weights $a$. It is worth noting that Alice is very reliable, so it is guaranteed that at least one such tree can always be reconstructed.", "inputFormat": "The input consists of multiple test cases. The first line contains a single positive integer $T$, representing the number of test cases.\n\nFor each test case:\n- The first line contains a positive integer $n$.\n- The next $n$ lines describe the matrix $b$. The $j$-th integer on the $i$-th of these lines is $b_{i,j}$.", "outputFormat": "For each test case:\n- In the first line, output $n$ integers, representing the vertex weights $a_1, a_2, \\ldots, a_n$.\n- Then, output $n-1$ lines. Each line should contain two integers $u,v$, representing an edge between vertex $u$ and vertex $v$.", "hint": "For all test data, it is guaranteed that:\n- $1\\le T\\le 10$\n- $1\\le n\\le 500$\n- $1\\le b_{i,j}<2^{60}$\n\n**This problem uses bundled tests.** The subtasks are described as follows:\n- Subtask 1 (5 pts): $n=2$.\n- Subtask 2 (10 pts): $n=3$.\n- Subtask 3 (10 pts): $n=4$.\n- Subtask 4 (15 pts): $n\\le 8$.\n- Subtask 5 (25 pts): The values $b_{i,i}$ are all distinct.\n- Subtask 6 (35 pts): No additional constraints.", "locale": "en"}, "zh-CN": {"title": "「DLESS-2」XOR and Tree Construction", "background": "一道题目需要一个题目背景。", "description": "Bob 有一棵 $n$ 个点的无根树 $T$，树上每个点都有权值，第 $i$ 个点的权值为 $a_i$。Alice 记录了一个 $n\\times n$ 的矩阵 $b$，其中 $b_{i,j}$ 表示树上 $i\\to j$ 最短路径上所有点的点权的异或和。\n\nAlice 观察这个矩阵，惊奇地发现矩阵里所有数都是**正整数**。\n\n不幸的是，某一天，Bob 把他的树搞丢了。于是你得到了 Alice 记录的矩阵，并需要还原出一种可能的树 $T$ 与序列 $a$。值得注意的是，Alice 非常靠谱，因此你总是可以还原出至少一种树。", "inputFormat": "本题有多组测试数据，第一行输入一个正整数 $T$，代表数据组数。\n\n对于每组数据：\n- 第一行输入一个正整数 $n$。\n- 接下来 $n$ 行，每行 $n$ 个正整数，其中第 $i$ 行第 $j$ 个数表示 $b_{i,j}$。", "outputFormat": "对于每组数据：\n- 第一行输出 $n$ 个数，分别代表每个点的点权 $a_1,a_2,\\cdots,a_n$。\n- 接下来 $n-1$ 行，每行输出两个数 $u,v$，代表有一条连接 $u,v$ 的边。", "hint": "对于所有数据，保证：\n- $1\\le T\\le 10$\n- $1\\le n\\le 500$\n- $1\\le b_{i,j}<2^{60}$\n\n**本题采用捆绑测试**，各子任务描述如下：\n- Subtask 1（5 pts）：$n=2$。\n- Subtask 2（10 pts）：$n=3$。\n- Subtask 3（10 pts）：$n=4$。\n- Subtask 4（15 pts）：$n\\le 8$。\n- Subtask 5（25 pts）：$b_{i,i}$ 互不相同。\n- Subtask 6（35 pts）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P12827", "type": "P", "difficulty": 6, "samples": [["2\n5 6\n1 2 4 8 16\n0 1 3 3\n0 1 4 3\n1 2 4 0\n1 2 4 1\n0 1 5 114514\n0 1 4 5\n6 7\n1 1 4 5 1 4\n0 1 3 0\n1 2 4 0\n1 1 2 1\n1 2 6 0\n1 1 4 5\n0 2 4 4\n1 1 2 0", "2\n2\n12\n13\n16\n3\n2\n5\n1\n5\n5\n3\n0"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "数位 DP", "线性基", "洛谷比赛"], "title": "「DLESS-2」XOR and Even", "background": "", "description": "给定一个长度为 $n$ 的非负整数序列 $a$，$q$ 次询问，每次询问形如以下两种中的一种：\n\n- ```0 l r x```: 在区间 $[l,r]$ 中选出**偶数**个数（可以是 $0$ 个，此时异或和为 $0$，下同），使得这些数的异或和小于等于 $x$，求方案数，答案对 $10^9+7$ 取模。\n- ```1 l r x```: 在区间 $[l,r]$ 中选出**偶数**个数，使得这些数的异或和异或上 $x$ 最大，求这个最大值。", "inputFormat": "本题有多组测试数据，第一行输入一个数 $T$ 表示数据组数。\n\n对于每组数据，第一行输入两个数 $n,q$。\n\n第二行输入 $n$ 个数，代表序列 $a$。\n\n接下来 $q$ 行，每行一次询问，格式如问题描述所示。", "outputFormat": "对于每次询问，输出一行一个数，表示答案。", "hint": "对于所有数据，保证：\n\n- $1\\le T\\le 10^4$\n- $1\\le n,\\sum n\\le 5\\times10^5$\n- $1\\le q,\\sum q\\le 5\\times10^5$\n- $1\\le l<r\\le n$\n- $0\\le a_i,x<2^{30}$\n\n**本题采用捆绑测试**，各子任务描述如下：\n\n| Subtask | $\\sum n\\le$ | $\\sum q\\le$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $1000$ | 无 | $10$ |\n| $2$ | $1000$ | $1000$ | A | $15$ |\n| $3$ | $1000$ | $1000$ | B | $15$ |\n| $4$ | $1000$ | $1000$ | 无 | $10$ |\n| $5$ | $5\\times10^4$ | $5\\times10^4$ | 无 | $10$ |\n| $6$ | $5\\times10^5$ | $5\\times10^5$ | A | $15$ |\n| $7$ | $5\\times10^5$ | $5\\times10^5$ | B | $15$ |\n| $8$ | $5\\times10^5$ | $5\\times10^5$ | 无 | $10$ |\n\n特殊性质 A：操作类型一定为 $0$。\n\n特殊性质 B：操作类型一定为 $1$。", "locale": "zh-CN", "translations": {"en": {"title": "「DLESS-2」XOR and Even", "background": "", "description": "You are given a sequence $a$ of $n$ non-negative integers. You need to process $q$ queries, each being one of the following two types:\n\n- ```0 l r x```: Count the number of ways to select an **even** number of elements from the range $[l, r]$ (inclusive) such that their XOR sum is less than or equal to $x$. Selecting zero elements is allowed, and their XOR sum is $0$. Output the count modulo $10^9+7$.\n- ```1 l r x```: Select an **even** number of elements from the range $[l, r]$ (inclusive). Let their XOR sum be $S$. Find the maximum possible value of $S \\oplus x$.", "inputFormat": "This problem contains multiple test cases. The first line contains an integer $T$, the number of test cases.\n\nFor each test case:\nThe first line contains two integers, $n$ and $q$.\nThe second line contains $n$ integers, representing the sequence $a$.\nEach of the next $q$ lines describes a query in the format specified in the problem description.", "outputFormat": "For each query, output a single integer on one line, representing the answer.", "hint": "For all test cases, it is guaranteed that:\n\n- $1\\le T\\le 10^4$\n- $1\\le n,\\sum n\\le 5\\times10^5$\n- $1\\le q,\\sum q\\le 5\\times10^5$\n- $1\\le l<r\\le n$\n- $0\\le a_i,x<2^{30}$\n\n**This problem uses subtasks for scoring (bundled testing)**. The descriptions of the subtasks are as follows:\n\n| Subtask | $\\sum n\\le$ | $\\sum q\\le$ | Special Property | Score |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $1000$ | None | $10$ |\n| $2$ | $1000$ | $1000$ | A | $15$ |\n| $3$ | $1000$ | $1000$ | B | $15$ |\n| $4$ | $1000$ | $1000$ | None | $10$ |\n| $5$ | $5\\times10^4$ | $5\\times10^4$ | None | $10$ |\n| $6$ | $5\\times10^5$ | $5\\times10^5$ | A | $15$ |\n| $7$ | $5\\times10^5$ | $5\\times10^5$ | B | $15$ |\n| $8$ | $5\\times10^5$ | $5\\times10^5$ | None | $10$ |\n\nSpecial Property A: All queries are of type 0.\n\nSpecial Property B: All queries are of type 1.", "locale": "en"}, "zh-CN": {"title": "「DLESS-2」XOR and Even", "background": "", "description": "给定一个长度为 $n$ 的非负整数序列 $a$，$q$ 次询问，每次询问形如以下两种中的一种：\n\n- ```0 l r x```: 在区间 $[l,r]$ 中选出**偶数**个数（可以是 $0$ 个，此时异或和为 $0$，下同），使得这些数的异或和小于等于 $x$，求方案数，答案对 $10^9+7$ 取模。\n- ```1 l r x```: 在区间 $[l,r]$ 中选出**偶数**个数，使得这些数的异或和异或上 $x$ 最大，求这个最大值。", "inputFormat": "本题有多组测试数据，第一行输入一个数 $T$ 表示数据组数。\n\n对于每组数据，第一行输入两个数 $n,q$。\n\n第二行输入 $n$ 个数，代表序列 $a$。\n\n接下来 $q$ 行，每行一次询问，格式如问题描述所示。", "outputFormat": "对于每次询问，输出一行一个数，表示答案。", "hint": "对于所有数据，保证：\n\n- $1\\le T\\le 10^4$\n- $1\\le n,\\sum n\\le 5\\times10^5$\n- $1\\le q,\\sum q\\le 5\\times10^5$\n- $1\\le l<r\\le n$\n- $0\\le a_i,x<2^{30}$\n\n**本题采用捆绑测试**，各子任务描述如下：\n\n| Subtask | $\\sum n\\le$ | $\\sum q\\le$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $1000$ | 无 | $10$ |\n| $2$ | $1000$ | $1000$ | A | $15$ |\n| $3$ | $1000$ | $1000$ | B | $15$ |\n| $4$ | $1000$ | $1000$ | 无 | $10$ |\n| $5$ | $5\\times10^4$ | $5\\times10^4$ | 无 | $10$ |\n| $6$ | $5\\times10^5$ | $5\\times10^5$ | A | $15$ |\n| $7$ | $5\\times10^5$ | $5\\times10^5$ | B | $15$ |\n| $8$ | $5\\times10^5$ | $5\\times10^5$ | 无 | $10$ |\n\n特殊性质 A：操作类型一定为 $0$。\n\n特殊性质 B：操作类型一定为 $1$。", "locale": "zh-CN"}}}
{"pid": "P12828", "type": "P", "difficulty": 6, "samples": [["3\n8 3\n11 3\n114514 11451", "7\n13\n184193935"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化", "中国剩余定理 CRT", "洛谷比赛"], "title": "「DLESS-2」XOR and Number Theory", "background": "", "description": "给出 $n,m$，对于所有满足以下两个条件的二元组 $(x,y)$，求 $x^2\\bmod(y^2-xy)$ 的和：\n- $1\\le x< y\\le n$\n- $x\\oplus y=\\gcd(x,y)\\le m$\n\n其中 $\\oplus$ 表示按位异或运算。\n\n由于结果可能很大，所以答案对 $10^9+7$ 取模。", "inputFormat": "本题有多组测试数据，第一行输入一个正整数 $T$，表示数据组数。\n\n对于每组数据，输入一行两个数 $n,m$。", "outputFormat": "对于每组数据，输出一行一个数，代表答案。", "hint": "对于所有数据，保证：\n\n- $1\\le T\\le 3000$\n- $2\\le n\\le 10^9$\n- $1\\le m\\le n$\n- $1\\le \\sum m\\le 10^5$\n\n**本题采用打包测试**，各测试包描述如下：\n\n| Subtask | $n\\le$ | $\\sum n\\le$ | $\\sum m\\le$ | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $1000$ | $1000$ | $1000$ | $10$ |\n| $2$ | $10^4$ | $10^4$ | $10^4$ | $10$ |\n| $3$ | $10^7$ | $10^7$ | $10^5$ | $10$ |\n| $4$ | $5\\times10^7$ | $5\\times10^7$ | $10^5$ | $20$ |\n| $5$ | $10^9$ | $+\\infty$ | $1000$ | $10$ |\n| $6$ | $10^9$ | $+\\infty$ | $5000$ | $10$ |\n| $7$ | $10^9$ | $+\\infty$ | $3\\times 10^4$ | $10$ |\n| $8$ | $10^9$ | $+\\infty$ | $10^5$ | $20$ |\n", "locale": "zh-CN", "translations": {"en": {"title": "「DLESS-2」XOR and Number Theory", "background": "", "description": "Given two integers $n$ and $m$. You need to find the sum of $x^2\\bmod(y^2-xy)$ over all pairs of integers $(x,y)$ that satisfy the following two conditions:\n- $1\\le x< y\\le n$\n- $x\\oplus y=\\gcd(x,y)\\le m$\n\nHere, $\\oplus$ denotes the bitwise XOR operation.\n\nSince the result can be very large, output the answer modulo $10^9+7$.", "inputFormat": "There are multiple test cases. The first line contains a single positive integer $T$, indicating the number of test cases.\n\nFor each test case, there is a single line containing two integers, $n$ and $m$.", "outputFormat": "For each test case, output a single line containing one integer, representing the answer modulo $10^9+7$.", "hint": "For all test data, it is guaranteed that:\n\n- $1\\le T\\le 3000$\n- $2\\le n\\le 10^9$\n- $1\\le m\\le n$\n- $1\\le \\sum m\\le 10^5$ \n\n**This problem uses subtasks for grading.** The description for each subtask is as follows:\n\n| Subtask | $n\\le$ | $\\sum n\\le$ | $\\sum m\\le$ | Points |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $1000$ | $1000$ | $1000$ | $10$ |\n| $2$ | $10^4$ | $10^4$ | $10^4$ | $10$ |\n| $3$ | $10^7$ | $10^7$ | $10^5$ | $10$ |\n| $4$ | $5\\times10^7$ | $5\\times10^7$ | $10^5$ | $20$ |\n| $5$ | $10^9$ | $+\\infty$ | $1000$ | $10$ |\n| $6$ | $10^9$ | $+\\infty$ | $5000$ | $10$ |\n| $7$ | $10^9$ | $+\\infty$ | $3\\times 10^4$ | $10$ |\n| $8$ | $10^9$ | $+\\infty$ | $10^5$ | $20$ |\n", "locale": "en"}, "zh-CN": {"title": "「DLESS-2」XOR and Number Theory", "background": "", "description": "给出 $n,m$，对于所有满足以下两个条件的二元组 $(x,y)$，求 $x^2\\bmod(y^2-xy)$ 的和：\n- $1\\le x< y\\le n$\n- $x\\oplus y=\\gcd(x,y)\\le m$\n\n其中 $\\oplus$ 表示按位异或运算。\n\n由于结果可能很大，所以答案对 $10^9+7$ 取模。", "inputFormat": "本题有多组测试数据，第一行输入一个正整数 $T$，表示数据组数。\n\n对于每组数据，输入一行两个数 $n,m$。", "outputFormat": "对于每组数据，输出一行一个数，代表答案。", "hint": "对于所有数据，保证：\n\n- $1\\le T\\le 3000$\n- $2\\le n\\le 10^9$\n- $1\\le m\\le n$\n- $1\\le \\sum m\\le 10^5$\n\n**本题采用打包测试**，各测试包描述如下：\n\n| Subtask | $n\\le$ | $\\sum n\\le$ | $\\sum m\\le$ | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $1000$ | $1000$ | $1000$ | $10$ |\n| $2$ | $10^4$ | $10^4$ | $10^4$ | $10$ |\n| $3$ | $10^7$ | $10^7$ | $10^5$ | $10$ |\n| $4$ | $5\\times10^7$ | $5\\times10^7$ | $10^5$ | $20$ |\n| $5$ | $10^9$ | $+\\infty$ | $1000$ | $10$ |\n| $6$ | $10^9$ | $+\\infty$ | $5000$ | $10$ |\n| $7$ | $10^9$ | $+\\infty$ | $3\\times 10^4$ | $10$ |\n| $8$ | $10^9$ | $+\\infty$ | $10^5$ | $20$ |\n", "locale": "zh-CN"}}}
{"pid": "P12829", "type": "P", "difficulty": 7, "samples": [["3\n3 2\n7 6 3 2 5 1 0 4 \n1 1\n1 0\n2 4\n1 3 0 2 \n1 2\n1 0\n1 1\n2 3\n2 3\n0 2 1 3 \n2 1\n1 2\n2 3", "18\n18\n5\n5\n3\n3\n3\n1\n5\n"], ["3\n2 2\n1 3 2 0 \n2 1\n2 1\n2 2\n1 0 3 2 \n2 2\n2 0\n3 5\n2 5 3 1 7 0 6 4 \n1 4\n2 0\n2 0\n1 5\n2 5", "4\n4\n6\n6\n21\n21\n21\n11\n19"], ["1\n5 9\n21 26 25 9 11 15 4 5 20 14 3 10 23 27 19 7 18 6 29 28 16 17 12 30 22 8 24 2 1 31 0 13 \n2 21\n1 16\n1 15\n2 0\n2 10\n2 24\n2 11\n1 30\n1 21", "269\n225\n227\n227\n259\n257\n267\n223\n275"], ["1\n0 4\n0\n1 0\n2 0\n2 0\n1 0", "0\n0\n0\n0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 131072, 131072, 131072]}, "tags": ["O2优化", "分治", "虚树", "字典树 Trie", "线段树合并", "洛谷比赛"], "title": "「DLESS-2」XOR and Inversion", "background": "", "description": "给定 $0\\sim 2^n-1$ 的排列 $p$，下标从 $0$ 开始，$q$ 次操作，每次操作形如以下两种中的一种：\n\n- `1 x`: 将排列中的每个元素 $p_i$ 替换为 $p_i \\oplus x$。\n- `2 x`: 重新排列 $p$。对于每一个下标 $i$，操作后下标 $i$ 处的新元素是操作前下标 $i \\oplus x$ 处的元素。\n\n其中 $\\oplus$ 表示按位异或运算。操作有后效性。\n\n每次操作后，求出整个序列的逆序对数。", "inputFormat": "本题有多组测试数据，第一行输入一个正整数 $T$，代表数据组数。\n\n对于每组数据：\n\n第一行输入两个数 $n,q$。\n\n第二行输入 $2^n$ 个数，代表排列 $p$。\n\n接下来 $q$ 行，每行两个数，代表一次操作，格式如题目描述所示。", "outputFormat": "在每次操作后，输出一行一个数，代表答案。", "hint": "对于所有数据，保证：\n\n- $1\\le T\\le 10^5$\n- $1\\le 2^n,\\sum 2^n\\le 2^{20}$\n- $1\\le q,\\sum q\\le 10^6$\n- $0\\le x<2^n$\n\n**本题采用打包测试**，各子任务描述如下：\n\n| Subtask | $\\sum 2^n\\le$ | $\\sum q\\le$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2^9$ | $500$ | 无 | $5$ |\n| $2$ | $2^{11}$ | $2000$ | 无 | $10$ |\n| $3$ | $2^{15}$ | $3\\times10^5$ | 无 | $15$ |\n| $4$ | $2^{18}$ | $3\\times10^5$ | A | $5$ |\n| $5$ | $2^{18}$ | $3\\times10^5$ | B | $5$ |\n| $6$ | $2^{18}$ | $3\\times10^5$ | 无 | $10$ |\n| $7$ | $2^{20}$ | $10^6$ | A | $5$ |\n| $8$ | $2^{20}$ | $10^6$ | B | $10$ |\n| $9$ | $2^{20}$ | $3\\times10^5$ | 无 | $15$ |\n| $10$ | $2^{20}$ | $10^6$ | 无 | $10$ |\n| $11$ | $2^{20}$ | $10^6$ | 无 | $10$ |\n\n**其中，除第 $11$ 个子任务空间限制为 128MB 外，其余子任务空间限制为 1GB。**\n\n特殊性质 A：只有第一种操作。\n\n特殊性质 B：只有第二种操作。", "locale": "zh-CN", "translations": {"en": {"title": "「DLESS-2」XOR and Inversion", "background": "", "description": "You are given a permutation $p$ of integers from $0$ to $2^n-1$. You need to perform $q$ operations. Each operation is one of the following two types:\n\n- `1 x`: Every element $p_i$ in the permutation is replaced by $p_i \\oplus x$.\n- `2 x`: The permutation is reordered. For every $i$, the new element at index $i$ is the element that was previously at index $i \\oplus x$.\n\nHere, $\\oplus$ denotes the bitwise XOR operation. The effects of the operations are cumulative.\n\nAfter each operation, you need to find the total number of inversions in the current permutation.", "inputFormat": "The input consists of multiple test cases. The first line contains a single positive integer $T$, representing the number of test cases.\n\nFor each test case:\n\nThe first line contains two integers $n$ and $q$.\n\nThe second line contains $2^n$ integers, representing the permutation $p$.\n\nThe next $q$ lines each contain two integers, representing an operation in the format described above.", "outputFormat": "After each operation, output a single line with a single integer, which is the answer.", "hint": "For all test data, it is guaranteed that:\n\n- $1\\le T\\le 10^5$\n- $1\\le 2^n, \\sum 2^n\\le 2^{20}$\n- $1\\le q, \\sum q\\le 10^6$\n- $0\\le x<2^n$\n\n**This problem uses bundled tests.** The subtasks are described as follows:\n\n| Subtask | $\\sum 2^n\\le$ | $\\sum q\\le$ | Special Properties | Points |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2^9$ | $500$ | None | $5$ |\n| $2$ | $2^{11}$ | $2000$ | None | $10$ |\n| $3$ | $2^{15}$ | $3\\times10^5$ | None | $15$ |\n| $4$ | $2^{18}$ | $3\\times10^5$ | A | $5$ |\n| $5$ | $2^{18}$ | $3\\times10^5$ | B | $5$ |\n| $6$ | $2^{18}$ | $3\\times10^5$ | None | $10$ |\n| $7$ | $2^{20}$ | $10^6$ | A | $5$ |\n| $8$ | $2^{20}$ | $10^6$ | B | $10$ |\n| $9$ | $2^{20}$ | $3\\times10^5$ | None | $15$ |\n| $10$ | $2^{20}$ | $10^6$ | None | $10$ |\n| $11$ | $2^{20}$ | $10^6$ | None | $10$ |\n\n**The memory limit for Subtask 11 is 128MB; for all other subtasks, it is 1GB.**\n\nSpecial Property A: Only type 1 operations are given.\n\nSpecial Property B: Only type 2 operations are given.", "locale": "en"}, "zh-CN": {"title": "「DLESS-2」XOR and Inversion", "background": "", "description": "给定 $0\\sim 2^n-1$ 的排列 $p$，下标从 $0$ 开始，$q$ 次操作，每次操作形如以下两种中的一种：\n\n- `1 x`: 将排列中的每个元素 $p_i$ 替换为 $p_i \\oplus x$。\n- `2 x`: 重新排列 $p$。对于每一个下标 $i$，操作后下标 $i$ 处的新元素是操作前下标 $i \\oplus x$ 处的元素。\n\n其中 $\\oplus$ 表示按位异或运算。操作有后效性。\n\n每次操作后，求出整个序列的逆序对数。", "inputFormat": "本题有多组测试数据，第一行输入一个正整数 $T$，代表数据组数。\n\n对于每组数据：\n\n第一行输入两个数 $n,q$。\n\n第二行输入 $2^n$ 个数，代表排列 $p$。\n\n接下来 $q$ 行，每行两个数，代表一次操作，格式如题目描述所示。", "outputFormat": "在每次操作后，输出一行一个数，代表答案。", "hint": "对于所有数据，保证：\n\n- $1\\le T\\le 10^5$\n- $1\\le 2^n,\\sum 2^n\\le 2^{20}$\n- $1\\le q,\\sum q\\le 10^6$\n- $0\\le x<2^n$\n\n**本题采用打包测试**，各子任务描述如下：\n\n| Subtask | $\\sum 2^n\\le$ | $\\sum q\\le$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2^9$ | $500$ | 无 | $5$ |\n| $2$ | $2^{11}$ | $2000$ | 无 | $10$ |\n| $3$ | $2^{15}$ | $3\\times10^5$ | 无 | $15$ |\n| $4$ | $2^{18}$ | $3\\times10^5$ | A | $5$ |\n| $5$ | $2^{18}$ | $3\\times10^5$ | B | $5$ |\n| $6$ | $2^{18}$ | $3\\times10^5$ | 无 | $10$ |\n| $7$ | $2^{20}$ | $10^6$ | A | $5$ |\n| $8$ | $2^{20}$ | $10^6$ | B | $10$ |\n| $9$ | $2^{20}$ | $3\\times10^5$ | 无 | $15$ |\n| $10$ | $2^{20}$ | $10^6$ | 无 | $10$ |\n| $11$ | $2^{20}$ | $10^6$ | 无 | $10$ |\n\n**其中，除第 $11$ 个子任务空间限制为 128MB 外，其余子任务空间限制为 1GB。**\n\n特殊性质 A：只有第一种操作。\n\n特殊性质 B：只有第二种操作。", "locale": "zh-CN"}}}
{"pid": "P12830", "type": "P", "difficulty": 3, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["动态规划 DP", "2025", "数论", "蓝桥杯国赛"], "title": "[蓝桥杯 2025 国 B] 新型锁", "background": "", "description": "密码学家小蓝受邀参加国际密码学研讨会，为此他设计了一种新型锁，巧妙地融合了数学的严谨性与密码学的安全性。这把锁包含 2025 个连续的数字格，每个格子需填入一个正整数，从而形成一个长度为 2025 的序列 $\\{a_1, a_2, \\ldots, a_{2025}\\}$，其中 $a_i$ 表示第 $i$ 个格子上的数字。\n\n要想解锁，该序列需满足以下条件：任意两个相邻格子中的数字，其最小公倍数（LCM）均为 2025。即对于所有的 $i$（$1 \\leq i \\leq 2024$），需满足：\n\n$$\\text{LCM}(a_i, a_{i+1}) = 2025$$\n\n现在，请你计算有多少个不同的序列能够解开这把锁。由于答案可能很大，你只需输出其对 $10^9 + 7$ 取余后的结果即可。", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2025 国 B] 新型锁", "background": "", "description": "密码学家小蓝受邀参加国际密码学研讨会，为此他设计了一种新型锁，巧妙地融合了数学的严谨性与密码学的安全性。这把锁包含 2025 个连续的数字格，每个格子需填入一个正整数，从而形成一个长度为 2025 的序列 $\\{a_1, a_2, \\ldots, a_{2025}\\}$，其中 $a_i$ 表示第 $i$ 个格子上的数字。\n\n要想解锁，该序列需满足以下条件：任意两个相邻格子中的数字，其最小公倍数（LCM）均为 2025。即对于所有的 $i$（$1 \\leq i \\leq 2024$），需满足：\n\n$$\\text{LCM}(a_i, a_{i+1}) = 2025$$\n\n现在，请你计算有多少个不同的序列能够解开这把锁。由于答案可能很大，你只需输出其对 $10^9 + 7$ 取余后的结果即可。", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12831", "type": "P", "difficulty": 3, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["2025", "数论", "素数判断,质数,筛法", "蓝桥杯国赛"], "title": "[蓝桥杯 2025 国 B] 互质藏卡", "background": "", "description": "小蓝整理着阁楼上的旧物，偶然发现了一个落满灰尘的卡片箱。打开箱子，里面整齐地摆放着 17600 张卡片，每张卡片上都写有一个数字，恰好包含了从 1 到 17600 的所有正整数。\n\n儿时的他热衷于收集各种卡牌，数量之多令人咋舌。如今，再次翻阅这些尘封的记忆，小蓝不禁感慨万千。他想起收藏家前辈的箴言：“收藏的魅力在于精粹，而非数量”。于是，他决定从这些卡牌中选取 $2025$ 张，组成一套“互质藏卡”。\n\n“互质藏卡”的特点在于：任意两张卡片上的数字之间互质，即它们的最大公约数恒为 $1$。现在，请你帮小蓝计算，共有多少种不同的选取方案，使得选出的 $2025$ 张卡片满足“互质藏卡”的条件。由于答案可能很大，你只需给出其对 $10^9 + 7$ 取余后的结果即可。\n\n注意：两个选取方案被认为是不同的，当且仅当它们所包含的数字集合不完全相同。即，若存在至少一个数字出现在其中一个集合但不出现在另一个集合中，则这两个方案被视为不同。", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2025 国 B] 互质藏卡", "background": "", "description": "小蓝整理着阁楼上的旧物，偶然发现了一个落满灰尘的卡片箱。打开箱子，里面整齐地摆放着 17600 张卡片，每张卡片上都写有一个数字，恰好包含了从 1 到 17600 的所有正整数。\n\n儿时的他热衷于收集各种卡牌，数量之多令人咋舌。如今，再次翻阅这些尘封的记忆，小蓝不禁感慨万千。他想起收藏家前辈的箴言：“收藏的魅力在于精粹，而非数量”。于是，他决定从这些卡牌中选取 $2025$ 张，组成一套“互质藏卡”。\n\n“互质藏卡”的特点在于：任意两张卡片上的数字之间互质，即它们的最大公约数恒为 $1$。现在，请你帮小蓝计算，共有多少种不同的选取方案，使得选出的 $2025$ 张卡片满足“互质藏卡”的条件。由于答案可能很大，你只需给出其对 $10^9 + 7$ 取余后的结果即可。\n\n注意：两个选取方案被认为是不同的，当且仅当它们所包含的数字集合不完全相同。即，若存在至少一个数字出现在其中一个集合但不出现在另一个集合中，则这两个方案被视为不同。", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "hint": "", "locale": "zh-CN"}}}
