{"pid": "P1100", "type": "P", "difficulty": 2, "samples": [["1314520\n", "249036820\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "数学", "进制", "位运算"], "title": "高低位交换", "background": null, "description": "给出一个小于 $2^{32}$ 的非负整数。这个数可以用一个 $32$ 位的二进制数表示（不足 $32$ 位用 $0$ 补足）。我们称这个二进制数的前 $16$ 位为“高位”，后 $16$ 位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。\n\n例如，数 $1314520$ 用二进制表示为 $0000\\,0000\\,0001\\,0100\\,0000\\,1110\\,1101\\,1000$（添加了 $11$ 个前导 $0$ 补足为 $32$ 位），其中前 $16$ 位为高位，即 $0000\\,0000\\,0001\\,0100$；后 $16$ 位为低位，即 $0000\\,1110\\,1101\\,1000$。将它的高低位进行交换，我们得到了一个新的二进制数 $0000\\,1110\\,1101\\,1000\\,0000\\,0000\\,0001\\,0100$。它即是十进制的 $249036820$。", "inputFormat": "一个小于 $2^{32}$ 的非负整数。", "outputFormat": "将新的数输出。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Swap High and Low Bits", "background": null, "description": "You are given a non-negative integer less than $2^{32}$. This number can be represented as a 32-bit binary number (pad with leading zeros if it has fewer than 32 bits). We call the first 16 bits the high 16 bits, and the last 16 bits the low 16 bits. Swap its high and low 16 bits to obtain a new number. What is this new number (in decimal)?\n\nFor example, the number $1314520$ is represented in binary as $0000\\,0000\\,0001\\,0100\\,0000\\,1110\\,1101\\,1000$ (with $11$ leading zeros added to make it 32 bits), where the high 16 bits are $0000\\,0000\\,0001\\,0100$, and the low 16 bits are $0000\\,1110\\,1101\\,1000$. After swapping the high and low bits, we get a new binary number $0000\\,1110\\,1101\\,1000\\,0000\\,0000\\,0001\\,0100$. This is $249036820$ in decimal.", "inputFormat": "A non-negative integer less than $2^{32}$.", "outputFormat": "Output the new number.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "高低位交换", "background": null, "description": "给出一个小于 $2^{32}$ 的非负整数。这个数可以用一个 $32$ 位的二进制数表示（不足 $32$ 位用 $0$ 补足）。我们称这个二进制数的前 $16$ 位为“高位”，后 $16$ 位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。\n\n例如，数 $1314520$ 用二进制表示为 $0000\\,0000\\,0001\\,0100\\,0000\\,1110\\,1101\\,1000$（添加了 $11$ 个前导 $0$ 补足为 $32$ 位），其中前 $16$ 位为高位，即 $0000\\,0000\\,0001\\,0100$；后 $16$ 位为低位，即 $0000\\,1110\\,1101\\,1000$。将它的高低位进行交换，我们得到了一个新的二进制数 $0000\\,1110\\,1101\\,1000\\,0000\\,0000\\,0001\\,0100$。它即是十进制的 $249036820$。", "inputFormat": "一个小于 $2^{32}$ 的非负整数。", "outputFormat": "将新的数输出。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1101", "type": "P", "difficulty": 2, "samples": [["7\naaaaaaa\naaaaaaa\naaaaaaa\naaaaaaa\naaaaaaa\naaaaaaa\naaaaaaa\n", "*******\n*******\n*******\n*******\n*******\n*******\n*******\n"], ["8\nqyizhong\ngydthkjy\nnwidghji\norbzsfgz\nhhgrhwth\nzzzzzozo\niwdfrgng\nyyyygggg", "*yizhong\ngy******\nn*i*****\no**z****\nh***h***\nz****o**\ni*****n*\ny******g"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "搜索"], "title": "单词方阵", "background": "", "description": "给一 $n \\times n$ 的字母方阵，内可能蕴含多个 `yizhong` 单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 $8$ 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉，因此有可能共用字母。输出时，将不是单词的字母用 `*` 代替，以突出显示单词。", "inputFormat": "第一行输入一个数 $n$。$(7 \\le n \\le 100)$。\n\n第二行开始输入 $n \\times n$ 的字母矩阵。\n", "outputFormat": "突出显示单词的 $n \\times n$ 矩阵。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Word Grid", "background": null, "description": "Given an $n \\times n$ letter grid, there may be multiple occurrences of the word `yizhong`. Each word is placed contiguously along a single direction. Placement can be along any of the $8$ directions, and the direction does not change within the same word. Different words may cross and share letters. In the output, replace letters that are not part of any occurrence of the word with `*` to highlight the words.", "inputFormat": "- The first line contains an integer $n$ ($7 \\le n \\le 100$).\n- Starting from the second line, input the $n \\times n$ letter matrix.", "outputFormat": "Output the $n \\times n$ matrix where letters not belonging to any `yizhong` are replaced by `*`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "单词方阵", "background": "", "description": "给一 $n \\times n$ 的字母方阵，内可能蕴含多个 `yizhong` 单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 $8$ 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉，因此有可能共用字母。输出时，将不是单词的字母用 `*` 代替，以突出显示单词。", "inputFormat": "第一行输入一个数 $n$。$(7 \\le n \\le 100)$。\n\n第二行开始输入 $n \\times n$ 的字母矩阵。\n", "outputFormat": "突出显示单词的 $n \\times n$ 矩阵。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1102", "type": "P", "difficulty": 2, "samples": [["4 1\n1 1 2 3\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "二分", "排序", "哈希 hashing", "双指针 two-pointer", "STL"], "title": "A-B 数对", "background": "出题是一件痛苦的事情！\n\n相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！", "description": "给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。", "inputFormat": "输入共两行。\n\n第一行，两个正整数 $N,C$。\n\n第二行，$N$ 个正整数，作为要求处理的那串数。", "outputFormat": "一行，表示该串正整数中包含的满足 $A - B = C$ 的数对的个数。", "hint": "对于 $75\\%$ 的数据，$1 \\leq N \\leq 2000$。\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 2 \\times 10^5$，$0 \\leq a_i <2^{30}$，$1 \\leq C < 2^{30}$。\n\n2017/4/29 新添数据两组", "locale": "zh-CN", "translations": {"en": {"title": "A - B Pairs", "background": null, "description": "Given a sequence of positive integers and a positive integer $C$, compute the number of pairs $(A, B)$ such that $A - B = C$. Pairs with the same values at different positions are considered distinct.", "inputFormat": "The input consists of two lines.\n\nThe first line contains two positive integers $N, C$.\n\nThe second line contains $N$ positive integers, which form the sequence to be processed.", "outputFormat": "Output one line containing the number of pairs in the sequence that satisfy $A - B = C$.", "hint": "Constraints:\n\n- For $75\\%$ of the testdata, $1 \\leq N \\leq 2000$.\n- For $100\\%$ of the testdata, $1 \\leq N \\leq 2 \\times 10^5$, $0 \\leq a_i < 2^{30}$, $1 \\leq C < 2^{30}$.\n\nTwo new testdata sets were added on 2017/4/29.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "A-B 数对", "background": "出题是一件痛苦的事情！\n\n相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！", "description": "给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。", "inputFormat": "输入共两行。\n\n第一行，两个正整数 $N,C$。\n\n第二行，$N$ 个正整数，作为要求处理的那串数。", "outputFormat": "一行，表示该串正整数中包含的满足 $A - B = C$ 的数对的个数。", "hint": "对于 $75\\%$ 的数据，$1 \\leq N \\leq 2000$。\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 2 \\times 10^5$，$0 \\leq a_i <2^{30}$，$1 \\leq C < 2^{30}$。\n\n2017/4/29 新添数据两组", "locale": "zh-CN"}}}
{"pid": "P1103", "type": "P", "difficulty": 3, "samples": [["4 1\n1 2\n2 4\n3 1\n5 3\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "书本整理", "background": null, "description": "Frank 是一个非常喜爱整洁的人。他有一大堆书和一个书架，想要把书放在书架上。书架可以放下所有的书，所以 Frank 首先将书按高度顺序排列在书架上。但是 Frank 发现，由于很多书的宽度不同，所以书看起来还是非常不整齐。于是他决定从中拿掉 $k$ 本书，使得书架可以看起来整齐一点。\n\n书架的不整齐度是这样定义的：每两本书宽度的差的绝对值的和。例如有 $4$ 本书：\n\n$1 \\times 2$  \n$5 \\times 3$  \n$2 \\times 4$  \n$3 \\times 1$    \n\n那么 Frank 将其排列整齐后是：\n\n$1 \\times 2$  \n$2 \\times 4$  \n$3 \\times 1$  \n$5 \\times 3$  \n\n不整齐度就是 $2+3+2=7$。\n\n已知每本书的高度都不一样，请你求出去掉 $k$ 本书后的最小的不整齐度。", "inputFormat": "第一行两个数字 $n$ 和 $k$，代表书有几本，从中去掉几本（$1 \\le n \\le 100, 1  \\le k<n$）。\n\n下面的 $n$ 行，每行两个数字表示一本书的高度和宽度，均小于等于 $200$。\n\n保证高度不重复。", "outputFormat": "一行一个整数，表示书架的最小不整齐度。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Book Arrangement", "background": "", "description": "Frank is a neat person. He has a large pile of books and a bookshelf, and he wants to put the books on the shelf. The shelf can hold all the books, so Frank first arranges the books on the shelf in order of height. However, Frank finds that since many books have different widths, the shelf still looks messy. He decides to remove $k$ books so that the shelf looks tidier.\n\nThe messiness of the shelf is defined as the sum of the absolute differences of the widths between each pair of adjacent books (after ordering by height). For example, there are $4$ books:\n\n$1 \\times 2$  \n$5 \\times 3$  \n$2 \\times 4$  \n$3 \\times 1$    \n\nAfter arranging them by height, Frank gets:\n\n$1 \\times 2$  \n$2 \\times 4$  \n$3 \\times 1$  \n$5 \\times 3$  \n\nThe messiness is $2+3+2=7$.\n\nEach book has a distinct height. Please find the minimum possible messiness after removing $k$ books.", "inputFormat": "The first line contains two integers $n$ and $k$, the number of books and the number to remove ($1 \\le n \\le 100$, $1 \\le k < n$).\n\nEach of the next $n$ lines contains two integers, the height and width of a book, both no more than $200$.\n\nHeights are guaranteed to be distinct.", "outputFormat": "Output a single integer: the minimum messiness of the shelf.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "书本整理", "background": null, "description": "Frank 是一个非常喜爱整洁的人。他有一大堆书和一个书架，想要把书放在书架上。书架可以放下所有的书，所以 Frank 首先将书按高度顺序排列在书架上。但是 Frank 发现，由于很多书的宽度不同，所以书看起来还是非常不整齐。于是他决定从中拿掉 $k$ 本书，使得书架可以看起来整齐一点。\n\n书架的不整齐度是这样定义的：每两本书宽度的差的绝对值的和。例如有 $4$ 本书：\n\n$1 \\times 2$  \n$5 \\times 3$  \n$2 \\times 4$  \n$3 \\times 1$    \n\n那么 Frank 将其排列整齐后是：\n\n$1 \\times 2$  \n$2 \\times 4$  \n$3 \\times 1$  \n$5 \\times 3$  \n\n不整齐度就是 $2+3+2=7$。\n\n已知每本书的高度都不一样，请你求出去掉 $k$ 本书后的最小的不整齐度。", "inputFormat": "第一行两个数字 $n$ 和 $k$，代表书有几本，从中去掉几本（$1 \\le n \\le 100, 1  \\le k<n$）。\n\n下面的 $n$ 行，每行两个数字表示一本书的高度和宽度，均小于等于 $200$。\n\n保证高度不重复。", "outputFormat": "一行一个整数，表示书架的最小不整齐度。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1104", "type": "P", "difficulty": 2, "samples": [["3\nYangchu 1992 4 23\nQiujingya 1993 10 13\nLuowen 1991 8 1\n", "Luowen\nYangchu\nQiujingya\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "字符串", "排序"], "title": "生日", "background": null, "description": "cjf 君想调查学校 OI 组每个同学的生日，并按照年龄从大到小的顺序排序。但 cjf 君最近作业很多，没有时间，所以请你帮她排序。", "inputFormat": "输入共有 $n + 1$ 行，\n\n第 $1$ 行为 OI 组总人数 $n$；\n\n第 $2$ 行至第 $n+1$ 行分别是每人的姓名 $s$、出生年 $y$、月 $m$、日 $d$。", "outputFormat": "输出共有 $n$ 行，即 $n$ 个年龄从大到小同学的姓名（如果有两个同学年龄相同，输入靠后的同学先输出）。", "hint": "数据保证，$1<n<100$，$1\\leq |s|<20$。保证年月日实际存在，且年份 $\\in [1960,2020]$。", "locale": "zh-CN", "translations": {"en": {"title": "Birthday", "background": null, "description": "cjf wants to collect the birthdays of every student in the school OI group and sort them by age in descending order (older first). However, cjf has a lot of homework recently and has no time, so please help her sort them.", "inputFormat": "The input contains $n + 1$ lines.\n\nThe first line contains the total number $n$ of people in the OI group.\n\nLines $2$ to $n + 1$ each contain one person's name $s$, birth year $y$, month $m$, and day $d$.", "outputFormat": "Output $n$ lines.\n\nPrint the names of the students in descending order of age. (If two students share the same birthday, print the one that appears later in the input first.)", "hint": "It is guaranteed that $1 < n < 100$ and $1 \\leq |s| < 20$. The given dates are valid, and the year $\\in [1960, 2020]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "生日", "background": null, "description": "cjf 君想调查学校 OI 组每个同学的生日，并按照年龄从大到小的顺序排序。但 cjf 君最近作业很多，没有时间，所以请你帮她排序。", "inputFormat": "输入共有 $n + 1$ 行，\n\n第 $1$ 行为 OI 组总人数 $n$；\n\n第 $2$ 行至第 $n+1$ 行分别是每人的姓名 $s$、出生年 $y$、月 $m$、日 $d$。", "outputFormat": "输出共有 $n$ 行，即 $n$ 个年龄从大到小同学的姓名（如果有两个同学年龄相同，输入靠后的同学先输出）。", "hint": "数据保证，$1<n<100$，$1\\leq |s|<20$。保证年月日实际存在，且年份 $\\in [1960,2020]$。", "locale": "zh-CN"}}}
{"pid": "P1105", "type": "P", "difficulty": 2, "samples": [["5\n2 0 2\n4 1 3\n3 1 3\n5 3 4\n1 1 5\n", "0 5\n1 5\n1 5\n5 5\n0 0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "搜索", "排序"], "title": "平台", "background": "", "description": "空间中有一些平台。给出每个平台的位置，请你计算从每一个平台的边缘落下之后会落到哪一个平台上。\n\n注意，如果某两个平台的某个两边缘横坐标相同，物体从上面那个平台落下之后将不会落在下面那个平台上（即平台的范围是一个开区间，不包含端点）。平台**可能会重叠**。\n\n从平台下落时视作从平台下方开始下落，也就是说不会落到高度相同的平台上。**如果有两个平台的高度相同且都可以被落到的话，那么会落到编号靠前的那个平台。**", "inputFormat": "第一行有一个数 $N$ 表示平台的个数;\n\n接下来 $N$ 行每行三个整数 分别是平台的高度 $H_i$，左端点的 $X$ 坐标 $L_i$，右端点的 $X$ 坐标 $R_i$。\n\n其中，$1 \\le N \\le {10}^3$，$0 \\le H,L,R \\le 2 \\times {10}^4$。", "outputFormat": "输出共 $N$ 行，每行两个数，分别表示：\n\n从第 $i$ 个平台的左边缘落下后到达的平台序号和右边缘落下以后到达的平台序号。\n\n输入数据中第一个平台的序号是 $1$。如果某个平台的某个边缘下面没有平台了，输出 $0$。\n", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/qeknowf7.png)", "locale": "zh-CN", "translations": {"en": {"title": "Platforms", "background": null, "description": "There are several platforms in space. Given the position of each platform, determine which platform you will land on after stepping off each platform’s edges.\n\nNote: If the x-coordinates of some edge of two platforms are the same, then an object falling from the upper platform will not land on the lower one (i.e., each platform covers an open interval, excluding endpoints). Platforms may overlap.\n\nWhen stepping off a platform, the fall is considered to start just below that platform, so you will not land on a platform of the same height. If there are two platforms with the same height that are both eligible to be landed on, you will land on the one with the smaller index.", "inputFormat": "The first line contains an integer $N$, the number of platforms.\n\nEach of the next $N$ lines contains three integers: the height $H_i$, the left endpoint’s $X$-coordinate $L_i$, and the right endpoint’s $X$-coordinate $R_i$.\n\nConstraints: $1 \\le N \\le 10^3$, $0 \\le H, L, R \\le 2 \\times 10^4$.", "outputFormat": "Output $N$ lines. For each $i$, output two integers: the index of the platform reached by falling from the left edge of platform $i$, and the index reached by falling from the right edge of platform $i$.\n\nPlatforms are numbered from $1$ in the input. If there is no platform below a given edge, output $0$.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/qeknowf7.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "平台", "background": "", "description": "空间中有一些平台。给出每个平台的位置，请你计算从每一个平台的边缘落下之后会落到哪一个平台上。\n\n注意，如果某两个平台的某个两边缘横坐标相同，物体从上面那个平台落下之后将不会落在下面那个平台上（即平台的范围是一个开区间，不包含端点）。平台**可能会重叠**。\n\n从平台下落时视作从平台下方开始下落，也就是说不会落到高度相同的平台上。**如果有两个平台的高度相同且都可以被落到的话，那么会落到编号靠前的那个平台。**", "inputFormat": "第一行有一个数 $N$ 表示平台的个数;\n\n接下来 $N$ 行每行三个整数 分别是平台的高度 $H_i$，左端点的 $X$ 坐标 $L_i$，右端点的 $X$ 坐标 $R_i$。\n\n其中，$1 \\le N \\le {10}^3$，$0 \\le H,L,R \\le 2 \\times {10}^4$。", "outputFormat": "输出共 $N$ 行，每行两个数，分别表示：\n\n从第 $i$ 个平台的左边缘落下后到达的平台序号和右边缘落下以后到达的平台序号。\n\n输入数据中第一个平台的序号是 $1$。如果某个平台的某个边缘下面没有平台了，输出 $0$。\n", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/qeknowf7.png)", "locale": "zh-CN"}}}
{"pid": "P1106", "type": "P", "difficulty": 3, "samples": [["175438 \n4\n", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "贪心"], "title": "删数问题", "background": null, "description": "键盘输入一个高精度的正整数 $n$（不超过 $250$ 位），去掉其中任意 $k$ 个数字后剩下的数字按原左右次序将组成一个新的非负整数。编程对给定的 $n$ 和 $k$，寻找一种方案使得剩下的数字组成的新数最小。", "inputFormat": "输入两行正整数。\n\n第一行输入一个高精度的正整数 $n$。\n\n第二行输入一个正整数 $k$，表示需要删除的数字个数。", "outputFormat": "输出一个整数，最后剩下的最小数。", "hint": "用 $\\operatorname{len}(n)$ 表示 $n$ 的**位数**，保证 $1 \\leq k < \\operatorname{len}(n) \\leq 250$。\n\n**注意：去掉若干数字后剩下的数可以存在前导零，而输出时不要输出前导零。**", "locale": "zh-CN", "translations": {"en": {"title": "Delete Digits Problem", "background": null, "description": "Input a high-precision positive integer $n$ (no more than $250$ digits). After removing any $k$ digits, the remaining digits, kept in their original left-to-right order, form a new non-negative integer. Given $n$ and $k$, write a program to find a strategy to remove digits so that the resulting number is minimal.", "inputFormat": "The input consists of two lines of positive integers.\n\nThe first line contains the high-precision positive integer $n$.\n\nThe second line contains the positive integer $k$, the number of digits to delete.", "outputFormat": "Output a single integer: the minimal possible remaining number.", "hint": "Let $\\operatorname{len}(n)$ denote the number of digits of $n$, and it is guaranteed that $1 \\leq k < \\operatorname{len}(n) \\leq 250$.\n\nNote: after deleting some digits, the remaining number may have leading zeros, but do not output leading zeros.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "删数问题", "background": null, "description": "键盘输入一个高精度的正整数 $n$（不超过 $250$ 位），去掉其中任意 $k$ 个数字后剩下的数字按原左右次序将组成一个新的非负整数。编程对给定的 $n$ 和 $k$，寻找一种方案使得剩下的数字组成的新数最小。", "inputFormat": "输入两行正整数。\n\n第一行输入一个高精度的正整数 $n$。\n\n第二行输入一个正整数 $k$，表示需要删除的数字个数。", "outputFormat": "输出一个整数，最后剩下的最小数。", "hint": "用 $\\operatorname{len}(n)$ 表示 $n$ 的**位数**，保证 $1 \\leq k < \\operatorname{len}(n) \\leq 250$。\n\n**注意：去掉若干数字后剩下的数可以存在前导零，而输出时不要输出前导零。**", "locale": "zh-CN"}}}
{"pid": "P1107", "type": "P", "difficulty": 4, "samples": [["3 10 2\n3 1 4 10\n6 3 5 9 7 8 9\n5 4 5 3 6 9", "8"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2008", "北京"], "title": "[BJWC2008] 雷涛的小猫", "background": "原最大整数参见 P1012", "description": "雷涛同学非常的有爱心，在他的宿舍里，养着一只因为受伤被救助的小猫（当然，这样的行为是违反学生宿舍管理条例的）。在他的照顾下，小猫很快恢复了健康，并且愈发的活泼可爱了。\n\n可是有一天，雷涛下课回到寝室，却发现小猫不见了！经过一番寻找，才发现她正趴在阳台上对窗外的柿子树发呆…\n\n在北京大学的校园里，有许多柿子树，在雷涛所在的宿舍楼前，就有 $N$ 棵。并且这 $N$ 棵柿子树每棵的高度都是 $H$。冬天的寒冷渐渐笼罩了大地，树上的叶子渐渐掉光了，只剩下一个个黄澄澄的柿子，看着非常喜人。而雷涛的小猫恰好非常的爱吃柿子，看着窗外树上的柿子，她十分眼馋，于是决定利用自己敏捷的跳跃能力跳到树上去吃柿子。\n\n小猫可以从宿舍的阳台上跳到窗外任意一棵柿子树的树顶。之后，她每次都可以在当前位置沿着当前所在的柿子树向下跳 $1$ 单位距离。当然，小猫的能力远不止如此，她还可以在树之间跳跃。每次她都可以从当前这棵树跳到另外的任意一棵，在这个过程中，她的高度会下降 `Delta` 单位距离。每个时刻，只要她所在的位置有柿子，她就可以吃掉。整个“吃柿子行动”一直到小猫落到地面上为止。\n\n雷涛调查了所有柿子树上柿子的生长情况。他很想知道，小猫从阳台出发，最多能吃到多少柿子？他知道写一个程序可以很容易的解决这个问题，但是他现在懒于写任何代码。于是，现在你的任务就是帮助雷涛写一个这样的程序。\n\n图为 $N=3, H=10, Delta=2$ 的一个例子。小猫按照图示路线进行跳跃，可以吃到最多的 $8$ 个柿子。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/69gyw9xt.png)", "inputFormat": "第一行有三个以空格分隔的整数，分别代表 $N,H,Delta$。\n\n接下来的 $N$ 行，每行第一个整数为 $N_i$，代表第 $i$ 棵树上的柿子数量。\n\n接下来是 $N_i$ 个整数，每个整数 $T_{i,j}$ 代表第 $i$ 棵柿子树的 $T_{i,j}$ 高度上长有一个柿子。", "outputFormat": "一个整数，即小猫最多吃到的柿子数。", "hint": "### 数据范围及约定\n\n对于全部数据，$1 \\leq N, H ≤ 2000$，$0 \\leq N_i ≤ 5000$，$1 ≤ Delta ≤ H,1 ≤ T_{i,j} ≤ H$。\n\n输入文件大小不大于 40MB。注意输入输出效率。\n\n来源 Excalibur, 2008。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2008] Lei Tao's Kitten", "background": null, "description": "Lei Tao is very compassionate. In his dormitory, he keeps a kitten that was rescued after being injured (of course, this violates the student dormitory management regulations). Under his care, the kitten quickly recovered and became even more lively and adorable.\n\nBut one day, after class, Lei Tao returned to his room and found that the kitten was missing! After searching for a while, he discovered that she was lying on the balcony, staring blankly at the persimmon tree outside the window.\n\nThere are many persimmon trees on the campus of Peking University, and there are $N$ of them right in front of Lei Tao’s dorm building. All these $N$ persimmon trees have the same height $H$. As the cold of winter gradually spreads over the land, the leaves on the trees fall off, leaving only the golden persimmons, which look very tempting. It just so happens that Lei Tao’s kitten loves to eat persimmons. Seeing the persimmons on the trees outside the window, she became very eager, and decided to use her agile jumping ability to jump onto the trees to eat persimmons.\n\nThe kitten can jump from the dormitory balcony to the top of any tree outside. After that, each time she can jump downward along the current tree by 1 unit of distance. Of course, her abilities are not limited to this—she can also jump between trees. Each time she can jump from the current tree to any other one, and in this process her height decreases by `Delta` units. At any moment, if there is a persimmon at her current position, she can eat it. The entire \"persimmon-eating operation\" continues until the kitten reaches the ground.\n\nThe figure shows an example with $N=3, H=10, Delta=2$. Following the route shown in the figure, the kitten can eat at most 8 persimmons.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/69gyw9xt.png)", "inputFormat": "The first line contains three integers separated by spaces, representing $N, H, Delta$.\n\nThe next $N$ lines each begin with an integer $N_i$, representing the number of persimmons on the $i$-th tree.\n\nThen follow $N_i$ integers, where each integer $T_{i,j}$ indicates that there is a persimmon at height $T_{i,j}$ on the $i$-th tree.", "outputFormat": "Output a single integer: the maximum number of persimmons the kitten can eat.", "hint": "Constraints and Notes\n\nFor all testdata, $1 \\leq N, H \\leq 2000$, $0 \\leq N_i \\leq 5000$, $1 \\leq Delta \\leq H, 1 \\leq T_{i,j} \\leq H$.\n\nThe input file size is no more than 40 MB. Pay attention to I/O efficiency.\n\nSource: Excalibur, 2008.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2008] 雷涛的小猫", "background": "原最大整数参见 P1012", "description": "雷涛同学非常的有爱心，在他的宿舍里，养着一只因为受伤被救助的小猫（当然，这样的行为是违反学生宿舍管理条例的）。在他的照顾下，小猫很快恢复了健康，并且愈发的活泼可爱了。\n\n可是有一天，雷涛下课回到寝室，却发现小猫不见了！经过一番寻找，才发现她正趴在阳台上对窗外的柿子树发呆…\n\n在北京大学的校园里，有许多柿子树，在雷涛所在的宿舍楼前，就有 $N$ 棵。并且这 $N$ 棵柿子树每棵的高度都是 $H$。冬天的寒冷渐渐笼罩了大地，树上的叶子渐渐掉光了，只剩下一个个黄澄澄的柿子，看着非常喜人。而雷涛的小猫恰好非常的爱吃柿子，看着窗外树上的柿子，她十分眼馋，于是决定利用自己敏捷的跳跃能力跳到树上去吃柿子。\n\n小猫可以从宿舍的阳台上跳到窗外任意一棵柿子树的树顶。之后，她每次都可以在当前位置沿着当前所在的柿子树向下跳 $1$ 单位距离。当然，小猫的能力远不止如此，她还可以在树之间跳跃。每次她都可以从当前这棵树跳到另外的任意一棵，在这个过程中，她的高度会下降 `Delta` 单位距离。每个时刻，只要她所在的位置有柿子，她就可以吃掉。整个“吃柿子行动”一直到小猫落到地面上为止。\n\n雷涛调查了所有柿子树上柿子的生长情况。他很想知道，小猫从阳台出发，最多能吃到多少柿子？他知道写一个程序可以很容易的解决这个问题，但是他现在懒于写任何代码。于是，现在你的任务就是帮助雷涛写一个这样的程序。\n\n图为 $N=3, H=10, Delta=2$ 的一个例子。小猫按照图示路线进行跳跃，可以吃到最多的 $8$ 个柿子。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/69gyw9xt.png)", "inputFormat": "第一行有三个以空格分隔的整数，分别代表 $N,H,Delta$。\n\n接下来的 $N$ 行，每行第一个整数为 $N_i$，代表第 $i$ 棵树上的柿子数量。\n\n接下来是 $N_i$ 个整数，每个整数 $T_{i,j}$ 代表第 $i$ 棵柿子树的 $T_{i,j}$ 高度上长有一个柿子。", "outputFormat": "一个整数，即小猫最多吃到的柿子数。", "hint": "### 数据范围及约定\n\n对于全部数据，$1 \\leq N, H ≤ 2000$，$0 \\leq N_i ≤ 5000$，$1 ≤ Delta ≤ H,1 ≤ T_{i,j} ≤ H$。\n\n输入文件大小不大于 40MB。注意输入输出效率。\n\n来源 Excalibur, 2008。", "locale": "zh-CN"}}}
{"pid": "P1108", "type": "P", "difficulty": 3, "samples": [["12\n68 69 54 64 68 64 70 67 78 62 98 87\n", "4 2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "枚举"], "title": "低价购买", "background": null, "description": "“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。\n\n这里是某支股票的价格清单：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}\\hline\n\\textsf{日期} & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\cr\\hline\n\\textsf{价格} & 68 & 69 & 54 & 64 & 68 & 64 & 70 & 67 & 78 & 62& 98 & 87 \\cr\\hline\n\\end{array}$$\n\n最优秀的投资者可以购买最多 $4$ 次股票，可行方案中的一种是：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|}\\hline\n\\textsf{日期} & 2 & 5 & 6 & 10 \\cr\\hline\n\\textsf{价格} & 69 & 68 & 64 & 62 \\cr\\hline\n\\end{array}\n$$", "inputFormat": "第一行共一个整数 $N\\ (1  \\le  N  \\le 5000)$，股票发行天数。\n\n第二行一行 $N$ 个整数，是每天的股票价格。保证是大小不超过 $2^{16}$ 的正整数。", "outputFormat": "输出共一行两个整数，分别为最大购买次数和拥有最大购买次数的方案数（数据保证 $ \\le 2^{31}$）当二种方案“看起来一样”时（就是说它们构成的价格队列一样的时候）,这 $2$ 种方案被认为是相同的。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Buy Low", "background": null, "description": "The advice “buy low” is half the rule for success in the cow stock market. To be considered a great investor, you must follow this advice: “buy low; buy lower.” Each time you buy a stock, you must buy it at a price lower than the last time you bought it. The more times you buy, the better. Your goal, while following the above advice, is to find the maximum number of times you can buy the stock. You will be given the daily selling prices of a stock over a period of time, and you may choose on which days to buy. Every purchase must follow the “buy low; buy lower” principle. Write a program to compute the maximum number of purchases.\n\nHere is a price list for a certain stock:\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}\\hline\n\\textsf{日期} & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\cr\\hline\n\\textsf{价格} & 68 & 69 & 54 & 64 & 68 & 64 & 70 & 67 & 78 & 62& 98 & 87 \\cr\\hline\n\\end{array}$$\n\nThe best investor can buy at most $4$ times. One feasible plan is:\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|}\\hline\n\\textsf{日期} & 2 & 5 & 6 & 10 \\cr\\hline\n\\textsf{价格} & 69 & 68 & 64 & 62 \\cr\\hline\n\\end{array}\n$$", "inputFormat": "The first line contains a single integer $N\\ (1  \\le  N  \\le 5000)$, the number of trading days.\n\nThe second line contains $N$ integers, the stock price for each day. Each is guaranteed to be a positive integer not exceeding $2^{16}$.", "outputFormat": "Output two integers in one line: the maximum number of purchases, and the number of schemes that achieve this maximum (guaranteed $ \\le 2^{31}$). When two schemes “look the same” (that is, they form the same sequence of prices), the two schemes are considered identical.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "低价购买", "background": null, "description": "“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。\n\n这里是某支股票的价格清单：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}\\hline\n\\textsf{日期} & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\cr\\hline\n\\textsf{价格} & 68 & 69 & 54 & 64 & 68 & 64 & 70 & 67 & 78 & 62& 98 & 87 \\cr\\hline\n\\end{array}$$\n\n最优秀的投资者可以购买最多 $4$ 次股票，可行方案中的一种是：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|}\\hline\n\\textsf{日期} & 2 & 5 & 6 & 10 \\cr\\hline\n\\textsf{价格} & 69 & 68 & 64 & 62 \\cr\\hline\n\\end{array}\n$$", "inputFormat": "第一行共一个整数 $N\\ (1  \\le  N  \\le 5000)$，股票发行天数。\n\n第二行一行 $N$ 个整数，是每天的股票价格。保证是大小不超过 $2^{16}$ 的正整数。", "outputFormat": "输出共一行两个整数，分别为最大购买次数和拥有最大购买次数的方案数（数据保证 $ \\le 2^{31}$）当二种方案“看起来一样”时（就是说它们构成的价格队列一样的时候）,这 $2$ 种方案被认为是相同的。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1109", "type": "P", "difficulty": 2, "samples": [["2\n10 20\n10 15\n", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "贪心"], "title": "学生分组", "background": "", "description": "有 $n$ 组学生，给出初始时每组中的学生个数，再给出每组学生人数的上界 $R$ 和下界 $L\\ (L \\le R)$，每次你可以在某组中选出一个学生把他安排到另外一组中，问最少要多少次才可以使 $N$ 组学生的人数都在 $[L,R]$ 中。\n", "inputFormat": "第一行一个整数 $n$，表示学生组数；\n\n第二行 $n$ 个整数，表示每组的学生个数；\n\n第三行两个整数 $L,R$，表示下界和上界。\n", "outputFormat": "一个数，表示最少的交换次数，如果不能满足题目条件输出 $-1$。", "hint": "### 数据范围及约定\n\n对于全部数据，保证 $1\\le n \\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "Student Grouping", "background": null, "description": "There are $n$ groups of students. You are given the initial number of students in each group, and the upper bound $R$ and lower bound $L$ for each group size (with $L \\le R$). In one operation, you may select one student from a group and move them to another group. What is the minimum number of operations required to make the sizes of all $n$ groups fall within $[L, R]$?", "inputFormat": "The first line contains an integer $n$, the number of student groups.\nThe second line contains $n$ integers, the number of students in each group.\nThe third line contains two integers $L, R$, the lower and upper bounds.", "outputFormat": "Output a single integer, the minimum number of moves. If it is impossible to satisfy the condition, output -1.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $1 \\le n \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "学生分组", "background": "", "description": "有 $n$ 组学生，给出初始时每组中的学生个数，再给出每组学生人数的上界 $R$ 和下界 $L\\ (L \\le R)$，每次你可以在某组中选出一个学生把他安排到另外一组中，问最少要多少次才可以使 $N$ 组学生的人数都在 $[L,R]$ 中。\n", "inputFormat": "第一行一个整数 $n$，表示学生组数；\n\n第二行 $n$ 个整数，表示每组的学生个数；\n\n第三行两个整数 $L,R$，表示下界和上界。\n", "outputFormat": "一个数，表示最少的交换次数，如果不能满足题目条件输出 $-1$。", "hint": "### 数据范围及约定\n\n对于全部数据，保证 $1\\le n \\le 50$。", "locale": "zh-CN"}}}
{"pid": "P1110", "type": "P", "difficulty": 5, "samples": [["3 5\n5 3 1\nINSERT 2 9\nMIN_SORT_GAP\nINSERT 2 6\nMIN_GAP\nMIN_SORT_GAP\n", "2\n2\n1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2500, 2500], "memory": [162000, 162000, 162000, 162000, 162000, 162000, 162000]}, "tags": ["2007", "线段树", "各省省选", "平衡树", "堆", "浙江", "STL"], "title": "[ZJOI2007] 报表统计", "background": null, "description": "小 Q 的妈妈是一个出纳，经常需要做一些统计报表的工作。今天是妈妈的生日，小 Q 希望可以帮妈妈分担一些工作，作为她的生日礼物之一。\n\n经过仔细观察，小 Q 发现统计一张报表实际上是维护一个非负整数数列，并且进行一些查询操作。\n\n在最开始的时候，有一个长度为 $n$ 的整数序列 $a$，并且有以下三种操作：\n        \n- `INSERT i k`：在原数列的第 $i$ 个元素后面添加一个新元素 $k$；如果原数列的第 $i$ 个元素已经添加了若干元素，则添加在这些元素的最后（见样例说明）。\n- `MIN_GAP`：查询相邻两个元素的之间差值（绝对值）的最小值。\n- `MIN_SORT_GAP`：查询所有元素中最接近的两个元素的差值（绝对值）。\n\n于是小 Q 写了一个程序，使得程序可以自动完成这些操作，但是他发现对于一些大的报表他的程序运行得很慢，你能帮助他改进程序么？", "inputFormat": "第一行包含两个整数，分别表示原数列的长度 $n$ 以及操作的次数 $m$。\n\n第二行为 $n$ 个整数，为初始序列，第 $i$ 个整数表示 $a_i$。\n\n接下来的 $m$ 行，每行一个操作，即 `INSERT i k`，`MIN_GAP`，`MIN_SORT_GAP` 中的一种（无多余空格或者空行）。", "outputFormat": "对于每一个 `MIN_GAP` 和 `MIN_SORT_GAP` 命令，输出一行答案即可。", "hint": "#### 样例输入输出 1 解释\n\n一开始的序列为 $\\{5,3,1\\}$。\n\n执行操作 `INSERT 2  9` 将得到 $\\{5,3,9,1\\}$，此时 `MIN_GAP` 为 $2$，`MIN_SORT_GAP` 为 $2$。\n\n再执行操作 `INSERT 2  6` 将得到：$\\{5,3, 9, 6, 1\\}$。\n\n注意这个时候原序列的第 $2$ 个元素后面已经添加了一个 $9$，此时添加的 $6$ 应加在 $9$ 的后面。这个时候 `MIN_GAP` 为 $2$，`MIN_SORT_GAP` 为 $1$。\n\n---\n\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $2 \\le n, m \\le 5\\times10^5$，$1 \\leq i \\leq n$，$0 \\leq a_i, k \\leq 5 \\times 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2007] Report Statistics", "background": null, "description": "Little Q’s mother is a cashier and often needs to prepare statistical reports. Today is her birthday, and Little Q wants to help with some of the work as a birthday present.\n\nAfter careful observation, Little Q finds that preparing a report is essentially maintaining a sequence of non-negative integers and performing some queries.\n\nInitially, there is an integer sequence $a$ of length $n$, and the following three operations are supported:\n- `INSERT i k`: Append a new element $k$ immediately after the $i$-th element of the original sequence. If some elements have already been appended after the $i$-th original element, append $k$ after all those appended elements (see the sample explanation).\n- `MIN_GAP`: Query the minimum absolute difference between any two adjacent elements.\n- `MIN_SORT_GAP`: Query the minimum absolute difference between the two closest elements among all elements.\n\nLittle Q wrote a program to automate these operations, but it runs slowly on large reports. Can you help improve it?", "inputFormat": "- The first line contains two integers, the length $n$ of the original sequence and the number of operations $m$.\n- The second line contains $n$ integers, the initial sequence; the $i$-th integer is $a_i$.\n- The next $m$ lines each contain one operation, which is one of `INSERT i k`, `MIN_GAP`, or `MIN_SORT_GAP` (no extra spaces or blank lines).", "outputFormat": "For each `MIN_GAP` and `MIN_SORT_GAP` command, output the answer on its own line.", "hint": "#### Explanation of Sample Input/Output 1\n\nThe initial sequence is $\\{5,3,1\\}$.\n\nAfter performing `INSERT 2 9`, the sequence becomes $\\{5,3,9,1\\}$. At this time, `MIN_GAP` is $2$, and `MIN_SORT_GAP` is $2$.\n\nNext, performing `INSERT 2 6` yields $\\{5,3,9,6,1\\}$.\n\nNote that by this time one $9$ has already been appended after the 2nd element of the original sequence, so the newly inserted $6$ should be placed after $9$. Now `MIN_GAP` is $2$, and `MIN_SORT_GAP` is $1$.\n\n---\n\n#### Constraints\n\nFor all test points, it is guaranteed that $2 \\le n, m \\le 5 \\times 10^5$, $1 \\le i \\le n$, and $0 \\le a_i, k \\le 5 \\times 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2007] 报表统计", "background": null, "description": "小 Q 的妈妈是一个出纳，经常需要做一些统计报表的工作。今天是妈妈的生日，小 Q 希望可以帮妈妈分担一些工作，作为她的生日礼物之一。\n\n经过仔细观察，小 Q 发现统计一张报表实际上是维护一个非负整数数列，并且进行一些查询操作。\n\n在最开始的时候，有一个长度为 $n$ 的整数序列 $a$，并且有以下三种操作：\n        \n- `INSERT i k`：在原数列的第 $i$ 个元素后面添加一个新元素 $k$；如果原数列的第 $i$ 个元素已经添加了若干元素，则添加在这些元素的最后（见样例说明）。\n- `MIN_GAP`：查询相邻两个元素的之间差值（绝对值）的最小值。\n- `MIN_SORT_GAP`：查询所有元素中最接近的两个元素的差值（绝对值）。\n\n于是小 Q 写了一个程序，使得程序可以自动完成这些操作，但是他发现对于一些大的报表他的程序运行得很慢，你能帮助他改进程序么？", "inputFormat": "第一行包含两个整数，分别表示原数列的长度 $n$ 以及操作的次数 $m$。\n\n第二行为 $n$ 个整数，为初始序列，第 $i$ 个整数表示 $a_i$。\n\n接下来的 $m$ 行，每行一个操作，即 `INSERT i k`，`MIN_GAP`，`MIN_SORT_GAP` 中的一种（无多余空格或者空行）。", "outputFormat": "对于每一个 `MIN_GAP` 和 `MIN_SORT_GAP` 命令，输出一行答案即可。", "hint": "#### 样例输入输出 1 解释\n\n一开始的序列为 $\\{5,3,1\\}$。\n\n执行操作 `INSERT 2  9` 将得到 $\\{5,3,9,1\\}$，此时 `MIN_GAP` 为 $2$，`MIN_SORT_GAP` 为 $2$。\n\n再执行操作 `INSERT 2  6` 将得到：$\\{5,3, 9, 6, 1\\}$。\n\n注意这个时候原序列的第 $2$ 个元素后面已经添加了一个 $9$，此时添加的 $6$ 应加在 $9$ 的后面。这个时候 `MIN_GAP` 为 $2$，`MIN_SORT_GAP` 为 $1$。\n\n---\n\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $2 \\le n, m \\le 5\\times10^5$，$1 \\leq i \\leq n$，$0 \\leq a_i, k \\leq 5 \\times 10^8$。", "locale": "zh-CN"}}}
{"pid": "P1111", "type": "P", "difficulty": 3, "samples": [["4 4\n1 2 6\n1 3 4\n1 4 5\n4 2 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["二分", "并查集", "排序", "生成树"], "title": "修复公路", "background": "A 地区在地震过后，连接所有村庄的公路都造成了损坏而无法通车。政府派人修复这些公路。", "description": "给出 A 地区的村庄数 $N$，和公路数 $M$，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）。", "inputFormat": "第 $1$ 行两个正整数 $N,M$。\n\n下面 $M$ 行，每行 $3$ 个正整数 $x,y,t$，告诉你这条公路连着 $x,y$ 两个村庄，在时间 $t$ 时能修复完成这条公路。", "outputFormat": "如果全部公路修复完毕仍然存在两个村庄无法通车，则输出 $-1$，否则输出最早什么时候任意两个村庄能够通车。", "hint": "$1\\leq x, y\\leq N \\le 10 ^ 3$，$1\\leq M, t \\le 10 ^ 5$。", "locale": "zh-CN", "translations": {"en": {"title": "Repairing Roads", "background": null, "description": "Given the number of villages $N$ and the number of roads $M$ in region A. The roads are bidirectional. You are told which two villages each road connects and when this road will be completed. Find the earliest time when any two villages can travel between each other, i.e., the earliest time when for any pair of villages there exists at least one completed path (possibly consisting of multiple roads).", "inputFormat": "The first line contains two positive integers $N, M$.\n\nThen the next $M$ lines follow. Each line contains three positive integers $x, y, t$, indicating that this road connects villages $x$ and $y$, and it will be completed at time $t$.", "outputFormat": "If, after all roads are completed, there still exist two villages that cannot travel between each other, output $-1$. Otherwise, output the earliest time when any two villages can travel between each other.", "hint": "$1\\leq x, y\\leq N \\le 10 ^ 3$, $1\\leq M, t \\le 10 ^ 5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "修复公路", "background": "A 地区在地震过后，连接所有村庄的公路都造成了损坏而无法通车。政府派人修复这些公路。", "description": "给出 A 地区的村庄数 $N$，和公路数 $M$，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）。", "inputFormat": "第 $1$ 行两个正整数 $N,M$。\n\n下面 $M$ 行，每行 $3$ 个正整数 $x,y,t$，告诉你这条公路连着 $x,y$ 两个村庄，在时间 $t$ 时能修复完成这条公路。", "outputFormat": "如果全部公路修复完毕仍然存在两个村庄无法通车，则输出 $-1$，否则输出最早什么时候任意两个村庄能够通车。", "hint": "$1\\leq x, y\\leq N \\le 10 ^ 3$，$1\\leq M, t \\le 10 ^ 5$。", "locale": "zh-CN"}}}
{"pid": "P1112", "type": "P", "difficulty": 3, "samples": [["10 11 190000 960000 2", "191919\n383838\n575757\n767676\n959595"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "数学", "进制", "构造"], "title": "波浪数", "background": "", "description": "波浪数是在一对**不同**数字之间交替转换的数，如 $1212121$，双重波浪数则是指在两种进制下都是波浪数的数，如十进制数 $191919$ 是一个十进制下的波浪数，它对应的十一进制数 $121212$ 也是一个波浪数，所以十进制数 $191919$ 是一个双重波浪数。特别地，只有一位的数也算作波浪数，例如 $1$。\n\n类似的可以定义三重波浪数，三重波浪数在三种不同的进制中都是波浪数，甚至还有四重波浪数，如 $300_{(10)}=606_{(7)}=363_{(9)}=454_{(8)}=1\\mathtt{A}1_{(13)}$，下标表示采用的进制。你的任务就是在指定范围内找出双重、三重、四重波浪数。\n", "inputFormat": "单独一行包含五个用空格隔开的十进制整数 $l, r, L, R, k$。$[l, r]$ 表示应当考虑的进制的范围，$[L,R]$ 表示应当考虑的数字的范围，$k$ 表示你应该找的波浪数的重数。", "outputFormat": "从小到大以十进制形式输出指定范围内的指定重数的波浪数。一行输出一个数。\n", "hint": "### 数据范围及约定\n\n对于全部数据，保证 $2\\le l\\le r\\le 32$，$1\\le L\\le R\\le 10^7$，$k\\in \\{2, 3, 4\\}$。", "locale": "zh-CN", "translations": {"en": {"title": "Wavy Numbers", "background": null, "description": "A wavy number is a number that alternates between a pair of distinct digits, such as $1212121$. A double wavy number is a number that is wavy in two bases. For example, the decimal number $191919$ is wavy in base 10, and its base 11 representation $121212$ is also wavy, so the decimal number $191919$ is a double wavy number. In particular, a single-digit number also counts as a wavy number, e.g., $1$.\n\nSimilarly, we define triple wavy numbers as numbers that are wavy in three different bases, and even quadruple wavy numbers, e.g., $300_{(10)}=606_{(7)}=363_{(9)}=454_{(8)}=1\\mathtt{A}1_{(13)}$, where the subscript denotes the base. Your task is to find, within the specified ranges, all double, triple, or quadruple wavy numbers.", "inputFormat": "A single line contains five space-separated decimal integers $l, r, L, R, k$. The interval $[l, r]$ denotes the range of bases to consider, the interval $[L, R]$ denotes the range of numbers to consider, and $k$ specifies the multiplicity of wavy numbers to find.", "outputFormat": "Output, in increasing order and in decimal, all wavy numbers within the specified range that have the specified multiplicity. Print one number per line.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $2 \\le l \\le r \\le 32$, $1 \\le L \\le R \\le 10^7$, and $k \\in \\{2, 3, 4\\}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "波浪数", "background": "", "description": "波浪数是在一对**不同**数字之间交替转换的数，如 $1212121$，双重波浪数则是指在两种进制下都是波浪数的数，如十进制数 $191919$ 是一个十进制下的波浪数，它对应的十一进制数 $121212$ 也是一个波浪数，所以十进制数 $191919$ 是一个双重波浪数。特别地，只有一位的数也算作波浪数，例如 $1$。\n\n类似的可以定义三重波浪数，三重波浪数在三种不同的进制中都是波浪数，甚至还有四重波浪数，如 $300_{(10)}=606_{(7)}=363_{(9)}=454_{(8)}=1\\mathtt{A}1_{(13)}$，下标表示采用的进制。你的任务就是在指定范围内找出双重、三重、四重波浪数。\n", "inputFormat": "单独一行包含五个用空格隔开的十进制整数 $l, r, L, R, k$。$[l, r]$ 表示应当考虑的进制的范围，$[L,R]$ 表示应当考虑的数字的范围，$k$ 表示你应该找的波浪数的重数。", "outputFormat": "从小到大以十进制形式输出指定范围内的指定重数的波浪数。一行输出一个数。\n", "hint": "### 数据范围及约定\n\n对于全部数据，保证 $2\\le l\\le r\\le 32$，$1\\le L\\le R\\le 10^7$，$k\\in \\{2, 3, 4\\}$。", "locale": "zh-CN"}}}
{"pid": "P1113", "type": "P", "difficulty": 3, "samples": [["7\n1 5 0\n2 2 1 0\n3 3 2 0\n4 6 1 0\n5 1 2 4 0\n6 8 2 4 0\n7 4 3 5 6 0\n", "23\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "图论", "递推", "拓扑排序"], "title": "杂务", "background": null, "description": "John 的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。\n\n当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务 $1$。\n\nJohn 有需要完成的 $n$ 个杂务的清单，并且这份清单是有一定顺序的，杂务 $k\\ (k>1)$ 的准备工作只可能在杂务 $1$ 至 $k-1$ 中。\n\n写一个程序依次读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定 John 的农场有足够多的工人来同时完成任意多项任务。", "inputFormat": "第 $1$ 行，一个整数 $n\\ (3 \\le n \\le 10{,}000)$，必须完成的杂务的数目；\n\n第 $2$ 至 $n+1$ 行，每行有一些用空格隔开的整数，分别表示：\n\n- 工作序号（保证在输入文件中是从 $1$ 到 $n$ 有序递增的）；\n- 完成工作所需要的时间 $len\\ (1 \\le len \\le 100)$；\n- 一些必须完成的准备工作，总数不超过 $100$ 个，由一个数字 $0$ 结束。有些杂务没有需要准备的工作只描述一个单独的 $0$。\n\n保证整个输入文件中不会出现多余的空格。", "outputFormat": "一个整数，表示完成所有杂务所需的最短时间。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Chores", "background": null, "description": "Before milking the cows, John's farm has many chores to complete, each requiring a certain amount of time. For example: gathering the cows, driving them into the barn, cleaning their udders, and other tasks. It is necessary to finish all chores as early as possible to have more time to produce more milk.\n\nOf course, some chores must be done only after certain other chores are completed. For example, you can clean a cow’s udder only after driving it into the barn, and you cannot milk a cow before cleaning its udder. We call these the preparatory tasks for a given task. At least one task requires no preparatory work; the earliest task that can be started is labeled task $1$.\n\nJohn has a list of $n$ tasks to complete, and the list has a specific order: the preparatory tasks of task $k\\ (k>1)$ can only be among tasks $1$ to $k-1$.\n\nWrite a program that reads the description of each task in order and computes the minimum time needed to finish all tasks. Independent tasks can be executed simultaneously, and you may assume John's farm has enough workers to carry out any number of tasks in parallel.", "inputFormat": "- Line $1$: an integer $n\\ (3 \\le n \\le 10{,}000)$, the number of tasks to complete.\n- Lines $2$ to $n+1$: each line contains space-separated integers, representing:\n  - the task index (guaranteed to appear in strictly increasing order from $1$ to $n$ in the input file);\n  - the time required to complete the task $len\\ (1 \\le len \\le 100)$;\n  - zero or more preparatory tasks, terminated by a single $0$. If a task has no preparatory tasks, it is described by a single $0$.\n  \nThere are no extra spaces anywhere in the input file.", "outputFormat": "Output a single integer: the minimum time required to complete all tasks.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "杂务", "background": null, "description": "John 的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。\n\n当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务 $1$。\n\nJohn 有需要完成的 $n$ 个杂务的清单，并且这份清单是有一定顺序的，杂务 $k\\ (k>1)$ 的准备工作只可能在杂务 $1$ 至 $k-1$ 中。\n\n写一个程序依次读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定 John 的农场有足够多的工人来同时完成任意多项任务。", "inputFormat": "第 $1$ 行，一个整数 $n\\ (3 \\le n \\le 10{,}000)$，必须完成的杂务的数目；\n\n第 $2$ 至 $n+1$ 行，每行有一些用空格隔开的整数，分别表示：\n\n- 工作序号（保证在输入文件中是从 $1$ 到 $n$ 有序递增的）；\n- 完成工作所需要的时间 $len\\ (1 \\le len \\le 100)$；\n- 一些必须完成的准备工作，总数不超过 $100$ 个，由一个数字 $0$ 结束。有些杂务没有需要准备的工作只描述一个单独的 $0$。\n\n保证整个输入文件中不会出现多余的空格。", "outputFormat": "一个整数，表示完成所有杂务所需的最短时间。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1114", "type": "P", "difficulty": 3, "samples": [["9\n0 1 0 0 0 1 1 0 0\n", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["线性数据结构", "前缀和"], "title": "“非常男女”计划", "background": "", "description": "近来，初一年的 `XXX` 小朋友致力于研究班上同学的配对问题（别想太多，仅是舞伴），通过各种推理和实验，他掌握了大量的实战经验。例如，据他观察，身高相近的人似乎比较合得来。\n\n万圣节来临之际，`XXX` 准备在学校策划一次大型的 “非常男女” 配对活动。对于这次活动的参与者，`XXX` 有自己独特的选择方式。他希望能选择男女人数相等且身高都很接近的一些人。这种选择方式实现起来很简单。他让学校的所有人按照身高排成一排，然后从中选出连续的若干个人，使得这些人中男女人数相等。为了使活动更热闹，`XXX` 当然希望他能选出的人越多越好。请编写程序告诉他，他最多可以选出多少人来。\n", "inputFormat": "第一行有一个正整数 $n\\ (1\\le n \\le 10^5)$，代表学校的人数。\n\n第二行有 $n$ 个用空格隔开的数，这些数只能是 $0$ 或 $1$，其中，$0$ 代表是一个女生，$1$ 代表是一个男生。\n", "outputFormat": "输出一个非负整数。这个数表示在输入数据中最长的一段男女人数相等的子区间的长度。\n\n如果不存在男女人数相等的子区间，请输出 $0$。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "\"The 'Fei Chang Nan Nu' Plan\"", "background": null, "description": "Lately, seventh-grader \"XXX\" has been studying how to pair up classmates (don’t overthink it—just dance partners). Through various reasoning and experiments, he has gained a lot of hands-on experience. For example, he observed that people with similar heights seem to get along better.\n\nWith Halloween approaching, \"XXX\" plans to organize a large-scale \"Fei Chang Nan Nu\" pairing event at school. He has his own unique way of selecting participants: he wants to choose an equal number of boys and girls whose heights are all very close. This is easy to achieve. He asks everyone in the school to line up in order of height, then selects a consecutive segment of people such that the number of boys and girls in that segment is equal. To make the event livelier, \"XXX\" naturally wants to select as many people as possible. Please write a program to tell him the maximum number of people he can select.", "inputFormat": "The first line contains a positive integer $n\\ (1\\le n \\le 10^5)$, representing the number of people in the school.\n\nThe second line contains $n$ space-separated numbers, each of which is $0$ or $1$. Here, $0$ represents a girl and $1$ represents a boy.", "outputFormat": "Output a non-negative integer. This number indicates the length of the longest contiguous subarray in the input where the number of boys and girls is equal.\n\nIf no such subarray exists, output $0$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "“非常男女”计划", "background": "", "description": "近来，初一年的 `XXX` 小朋友致力于研究班上同学的配对问题（别想太多，仅是舞伴），通过各种推理和实验，他掌握了大量的实战经验。例如，据他观察，身高相近的人似乎比较合得来。\n\n万圣节来临之际，`XXX` 准备在学校策划一次大型的 “非常男女” 配对活动。对于这次活动的参与者，`XXX` 有自己独特的选择方式。他希望能选择男女人数相等且身高都很接近的一些人。这种选择方式实现起来很简单。他让学校的所有人按照身高排成一排，然后从中选出连续的若干个人，使得这些人中男女人数相等。为了使活动更热闹，`XXX` 当然希望他能选出的人越多越好。请编写程序告诉他，他最多可以选出多少人来。\n", "inputFormat": "第一行有一个正整数 $n\\ (1\\le n \\le 10^5)$，代表学校的人数。\n\n第二行有 $n$ 个用空格隔开的数，这些数只能是 $0$ 或 $1$，其中，$0$ 代表是一个女生，$1$ 代表是一个男生。\n", "outputFormat": "输出一个非负整数。这个数表示在输入数据中最长的一段男女人数相等的子区间的长度。\n\n如果不存在男女人数相等的子区间，请输出 $0$。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1115", "type": "P", "difficulty": 2, "samples": [["7\n2 -4 3 -1 2 -4 3\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "贪心", "递推", "分治", "前缀和", "线性 DP"], "title": "最大子段和", "background": "", "description": "给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。\n", "inputFormat": "第一行是一个整数，表示序列的长度 $n$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个数字 $a_i$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 样例 1 解释\n\n选取 $[3, 5]$ 子段 $\\{3, -1, 2\\}$，其和为 $4$。\n\n#### 数据规模与约定\n\n- 对于 $40\\%$ 的数据，保证 $n \\leq 2 \\times 10^3$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 2 \\times 10^5$，$-10^4 \\leq a_i \\leq 10^4$。\n\n---\n\n2026/01/21：增加一组 [hack 数据](https://www.luogu.com.cn/ticket/KLET103093)。", "locale": "zh-CN", "translations": {"en": {"title": "Maximum Subarray Sum", "background": null, "description": "Given a sequence $a$ of length $n$, choose a non-empty contiguous subarray whose sum is maximized.", "inputFormat": "The first line contains an integer $n$, the length of the sequence.\nThe second line contains $n$ integers; the $i$-th is $a_i$.", "outputFormat": "Output one line with a single integer, the answer.", "hint": "- Explanation for Sample 1: Choose the subarray $[3, 5]$, which is $\\{3, -1, 2\\}$; its sum is $4$.\n- Constraints:\n  - For 40% of the testdata, it is guaranteed that $n \\le 2 \\times 10^3$.\n  - For 100% of the testdata, it is guaranteed that $1 \\le n \\le 2 \\times 10^5$ and $-10^4 \\le a_i \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最大子段和", "background": "", "description": "给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。\n", "inputFormat": "第一行是一个整数，表示序列的长度 $n$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个数字 $a_i$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 样例 1 解释\n\n选取 $[3, 5]$ 子段 $\\{3, -1, 2\\}$，其和为 $4$。\n\n#### 数据规模与约定\n\n- 对于 $40\\%$ 的数据，保证 $n \\leq 2 \\times 10^3$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 2 \\times 10^5$，$-10^4 \\leq a_i \\leq 10^4$。\n\n---\n\n2026/01/21：增加一组 [hack 数据](https://www.luogu.com.cn/ticket/KLET103093)。", "locale": "zh-CN"}}}
{"pid": "P1116", "type": "P", "difficulty": 2, "samples": [["4\n4 3 2 1 ", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "排序"], "title": "车厢重组", "background": "", "description": "在一个旧式的火车站旁边有一座桥，其桥面可以绕河中心的桥墩水平旋转。一个车站的职工发现桥的长度最多能容纳两节车厢，如果将桥旋转 $180$ 度，则可以把相邻两节车厢的位置交换，用这种方法可以重新排列车厢的顺序。于是他就负责用这座桥将进站的车厢按车厢号从小到大排列。他退休后，火车站决定将这一工作自动化，其中一项重要的工作是编一个程序，输入初始的车厢顺序，计算最少用多少步就能将车厢排序。\n", "inputFormat": "共两行。  \n\n第一行是车厢总数 $N( \\le 1000)$。\n  \n第二行是 $N$ 个不同的数表示初始的车厢顺序。  \n（**注**：实际上数据中并不都在同一行，有可能分行输入）\n", "outputFormat": "一个整数，最少的旋转次数。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Carriage Reordering", "background": null, "description": "Next to an old-style railway station there is a bridge whose deck can rotate horizontally around the pier at the center of the river. A station worker discovered that the bridge can hold at most two carriages. If the bridge is rotated by $180$ degrees, the positions of two adjacent carriages can be swapped. Using this method, the order of the carriages can be rearranged. He was responsible for rearranging incoming carriages in increasing order of their carriage numbers. After he retired, the station decided to automate this work. One important task is to write a program that, given the initial order of the carriages, computes the minimum number of steps needed to sort the carriages.", "inputFormat": "The input consists of two parts.\n\nThe first line is the total number of carriages $N( \\le 10000)$.\n\nThe second line contains $N$ distinct integers representing the initial order of the carriages.  \n（Note: In the testdata, these integers are not necessarily on a single line and may be split across multiple lines.）", "outputFormat": "Output a single integer, the minimum number of rotations.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "车厢重组", "background": "", "description": "在一个旧式的火车站旁边有一座桥，其桥面可以绕河中心的桥墩水平旋转。一个车站的职工发现桥的长度最多能容纳两节车厢，如果将桥旋转 $180$ 度，则可以把相邻两节车厢的位置交换，用这种方法可以重新排列车厢的顺序。于是他就负责用这座桥将进站的车厢按车厢号从小到大排列。他退休后，火车站决定将这一工作自动化，其中一项重要的工作是编一个程序，输入初始的车厢顺序，计算最少用多少步就能将车厢排序。\n", "inputFormat": "共两行。  \n\n第一行是车厢总数 $N( \\le 1000)$。\n  \n第二行是 $N$ 个不同的数表示初始的车厢顺序。  \n（**注**：实际上数据中并不都在同一行，有可能分行输入）\n", "outputFormat": "一个整数，最少的旋转次数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1117", "type": "P", "difficulty": 6, "samples": [["4\naabbbb\ncccccc\naabaabaabaa\nbbaabaababaaba\n", "3\n5\n4\n7\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "2016", "NOI", "O2优化", "枚举", "ST 表", "后缀数组 SA", "差分", "调和级数"], "title": "[NOI2016] 优秀的拆分", "background": "", "description": "如果一个字符串可以被拆分为 $\\text{AABB}$ 的形式，其中 $\\text{A}$ 和 $\\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  \n例如，对于字符串 $ \\texttt{aabaabaa} $ ，如果令 $\\text{A}=\\texttt{aab}$，$\\text{B}=\\texttt{a}$，我们就找到了这个字符串拆分成 $\\text{AABB}$ 的一种方式。\n\n一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  \n比如我们令 $\\text{A}=\\texttt{a}$，$\\text{B}=\\texttt{baa}$，也可以用 $\\text{AABB}$ 表示出上述字符串；但是，字符串 $\\texttt{abaabaa}$ 就没有优秀的拆分。\n\n现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。\n\n以下事项需要注意：\n\n1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。\n2. 在一个拆分中，允许出现 $\\text{A}=\\text{B}$。例如 $\\texttt{cccc}$ 存在拆分 $\\text{A}=\\text{B}=\\texttt{c}$。\n3. 字符串本身也是它的一个子串。", "inputFormat": "每个输入文件包含多组数据。\n\n输入文件的第一行只有一个整数 $T$，表示数据的组数。\n\n接下来 $T$ 行，每行包含一个仅由英文小写字母构成的字符串 $S$，意义如题所述。", "outputFormat": "输出 $T$ 行，每行包含一个整数，表示字符串 $S$ 所有子串的所有拆分中，总共有多少个是优秀的拆分。", "hint": "### 样例解释\n\n我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。\n\n第一组数据中，共有三个子串存在优秀的拆分：  \n$S[1,4]=\\texttt{aabb}$，优秀的拆分为 $\\text{A}=\\texttt{a}$，$\\text{B}=\\texttt{b}$；  \n$S[3,6]=\\texttt{bbbb}$，优秀的拆分为 $\\text{A}=\\texttt{b}$，$\\text{B}=\\texttt{b}$；  \n$S[1,6]=\\texttt{aabbbb}$，优秀的拆分为 $\\text{A}=\\texttt{a}$，$\\text{B}=\\texttt{bb}$。  \n而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。\n\n第二组数据中，有两类，总共四个子串存在优秀的拆分：  \n对于子串 $S[1,4]=S[2,5]=S[3,6]=\\texttt{cccc}$，它们优秀的拆分相同，均为 $\\text{A}=\\texttt{c}$，$\\text{B}=\\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  \n对于子串 $S[1,6]=\\texttt{cccccc}$，它优秀的拆分有两种：$\\text{A}=\\texttt{c}$，$\\text{B}=\\texttt{cc}$ 和 $\\text{A}=\\texttt{cc}$，$\\text{B}=\\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  \n所以第二组数据的答案是 $3+2=5$。\n\n第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。\n\n第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。\n\n### 数据范围\n\n对于全部的测试点，保证 $1 \\leq T \\leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。\n\n我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：\n\n::cute-table{tuack}\n\n| 测试点编号   | $n \\leq$  | 特殊性质           |\n| :----------: | :-------: | :----------------: |\n| $1 \\sim 2$   | $300$     | $S$ 中所有字符相同 |\n| $3 \\sim 4$   | $2\\,000$  | ^ |\n| $5 \\sim 6$   | $10$      | 无                   |\n| $7 \\sim 8$   | $20$      | ^ |\n| $9 \\sim 10$  | $30$      | ^ |\n| $11 \\sim 12$ | $50$      | ^ |\n| $13 \\sim 14$ | $100$     | ^ |\n| $15$         | $200$     | ^ |\n| $16$         | $300$     | ^ |\n| $17$         | $500$     | ^ |\n| $18$         | $1\\,000$  | ^ |\n| $19$         | $2\\,000$  | ^ |\n| $20$         | $30\\,000$ | ^ |", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2016] Excellent Split", "background": null, "description": "If a string can be split into the form $\\text{AABB}$, where $\\text{A}$ and $\\text{B}$ are any non-empty strings, then we call this split of the string excellent. For example, for the string $\\texttt{aabaabaa}$, if we set $\\text{A}=\\texttt{aab}$ and $\\text{B}=\\texttt{a}$, we have found one way to split this string into $\\text{AABB}$.\n\nA string may have no excellent split, or it may have more than one excellent split. For example, if we set $\\text{A}=\\texttt{a}$ and $\\text{B}=\\texttt{baa}$, the above string can also be expressed as $\\text{AABB}$; however, the string $\\texttt{abaabaa}$ has no excellent split.\n\nNow given a string $S$ of length $n$, we need to count, over all substrings of $S$ and all their possible splits, the total number of excellent splits. Here a substring refers to a contiguous segment of the string.\n\nNotes:\n1. Identical substrings that appear at different positions are considered different substrings, and their excellent splits are all counted in the answer.\n2. In a split, $\\text{A}=\\text{B}$ is allowed. For example, $\\texttt{cccc}$ has the split $\\text{A}=\\text{B}=\\texttt{c}$.\n3. The string itself is also one of its substrings.", "inputFormat": "Each input file contains multiple test cases.\n\nThe first line of the input file contains a single integer $T$, indicating the number of test cases.\n\nThen follow $T$ lines, each containing a string $S$ consisting only of lowercase English letters, as described above.", "outputFormat": "Output $T$ lines. Each line contains an integer, indicating the total number of excellent splits among all splits of all substrings of $S$.", "hint": "Sample explanation.\n\nWe use $S[i, j]$ to denote the substring of $S$ from the $i$-th character to the $j$-th character (1-based indexing).\n\nIn the first dataset, there are three substrings with excellent splits: $S[1,4]=\\texttt{aabb}$, whose excellent split is $\\text{A}=\\texttt{a}$, $\\text{B}=\\texttt{b}$; $S[3,6]=\\texttt{bbbb}$, whose excellent split is $\\text{A}=\\texttt{b}$, $\\text{B}=\\texttt{b}$; $S[1,6]=\\texttt{aabbbb}$, whose excellent split is $\\text{A}=\\texttt{a}$, $\\text{B}=\\texttt{bb}$. The remaining substrings have no excellent splits, so the answer for the first dataset is $3$.\n\nIn the second dataset, there are in total four substrings that have excellent splits, divided into two types: for the substrings $S[1,4]=S[2,5]=S[3,6]=\\texttt{cccc}$, they share the same excellent split $\\text{A}=\\texttt{c}$, $\\text{B}=\\texttt{c}$, but since these substrings are at different positions, they are counted three times; for the substring $S[1,6]=\\texttt{cccccc}$, it has two excellent splits: $\\text{A}=\\texttt{c}$, $\\text{B}=\\texttt{cc}$ and $\\text{A}=\\texttt{cc}$, $\\text{B}=\\texttt{c}$, which are different splits of the same substring and are both counted. Therefore, the answer for the second dataset is $3+2=5$.\n\nIn the third dataset, $S[1,8]$ and $S[4,11]$ each have two excellent splits. Among them, $S[1,8]$ is the example in the problem statement, so the answer is $2+2=4$.\n\nIn the fourth dataset, $S[1,4]$, $S[6,11]$, $S[7,12]$, $S[2,11]$, and $S[1,8]$ each have one excellent split, while $S[3,14]$ has two excellent splits, so the answer is $5+2=7$.\n\n### Constraints\n\nFor all test points, it is guaranteed that $1 \\leq T \\leq 10$. The following limits apply to a single input within a dataset; that is, within the same test point, all of its $T$ datasets satisfy the constraints.\n\nLet $n$ be the length of string $S$. The detailed constraints for each test point are shown in the table below:\n\n::cute-table{tuack}\n\n| Test point ID | $n \\leq$  | Special property                 |\n| :-----------: | :-------: | :------------------------------: |\n| $1 \\sim 2$    | $300$     | All characters in $S$ are the same |\n| $3 \\sim 4$    | $2\\,000$  | ^                                |\n| $5 \\sim 6$    | $10$      | None                             |\n| $7 \\sim 8$    | $20$      | ^                                |\n| $9 \\sim 10$   | $30$      | ^                                |\n| $11 \\sim 12$  | $50$      | ^                                |\n| $13 \\sim 14$  | $100$     | ^                                |\n| $15$          | $200$     | ^                                |\n| $16$          | $300$     | ^                                |\n| $17$          | $500$     | ^                                |\n| $18$          | $1\\,000$  | ^                                |\n| $19$          | $2\\,000$  | ^                                |\n| $20$          | $30\\,000$ | ^                                |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2016] 优秀的拆分", "background": "", "description": "如果一个字符串可以被拆分为 $\\text{AABB}$ 的形式，其中 $\\text{A}$ 和 $\\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  \n例如，对于字符串 $ \\texttt{aabaabaa} $ ，如果令 $\\text{A}=\\texttt{aab}$，$\\text{B}=\\texttt{a}$，我们就找到了这个字符串拆分成 $\\text{AABB}$ 的一种方式。\n\n一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  \n比如我们令 $\\text{A}=\\texttt{a}$，$\\text{B}=\\texttt{baa}$，也可以用 $\\text{AABB}$ 表示出上述字符串；但是，字符串 $\\texttt{abaabaa}$ 就没有优秀的拆分。\n\n现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。\n\n以下事项需要注意：\n\n1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。\n2. 在一个拆分中，允许出现 $\\text{A}=\\text{B}$。例如 $\\texttt{cccc}$ 存在拆分 $\\text{A}=\\text{B}=\\texttt{c}$。\n3. 字符串本身也是它的一个子串。", "inputFormat": "每个输入文件包含多组数据。\n\n输入文件的第一行只有一个整数 $T$，表示数据的组数。\n\n接下来 $T$ 行，每行包含一个仅由英文小写字母构成的字符串 $S$，意义如题所述。", "outputFormat": "输出 $T$ 行，每行包含一个整数，表示字符串 $S$ 所有子串的所有拆分中，总共有多少个是优秀的拆分。", "hint": "### 样例解释\n\n我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。\n\n第一组数据中，共有三个子串存在优秀的拆分：  \n$S[1,4]=\\texttt{aabb}$，优秀的拆分为 $\\text{A}=\\texttt{a}$，$\\text{B}=\\texttt{b}$；  \n$S[3,6]=\\texttt{bbbb}$，优秀的拆分为 $\\text{A}=\\texttt{b}$，$\\text{B}=\\texttt{b}$；  \n$S[1,6]=\\texttt{aabbbb}$，优秀的拆分为 $\\text{A}=\\texttt{a}$，$\\text{B}=\\texttt{bb}$。  \n而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。\n\n第二组数据中，有两类，总共四个子串存在优秀的拆分：  \n对于子串 $S[1,4]=S[2,5]=S[3,6]=\\texttt{cccc}$，它们优秀的拆分相同，均为 $\\text{A}=\\texttt{c}$，$\\text{B}=\\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  \n对于子串 $S[1,6]=\\texttt{cccccc}$，它优秀的拆分有两种：$\\text{A}=\\texttt{c}$，$\\text{B}=\\texttt{cc}$ 和 $\\text{A}=\\texttt{cc}$，$\\text{B}=\\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  \n所以第二组数据的答案是 $3+2=5$。\n\n第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。\n\n第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。\n\n### 数据范围\n\n对于全部的测试点，保证 $1 \\leq T \\leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。\n\n我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：\n\n::cute-table{tuack}\n\n| 测试点编号   | $n \\leq$  | 特殊性质           |\n| :----------: | :-------: | :----------------: |\n| $1 \\sim 2$   | $300$     | $S$ 中所有字符相同 |\n| $3 \\sim 4$   | $2\\,000$  | ^ |\n| $5 \\sim 6$   | $10$      | 无                   |\n| $7 \\sim 8$   | $20$      | ^ |\n| $9 \\sim 10$  | $30$      | ^ |\n| $11 \\sim 12$ | $50$      | ^ |\n| $13 \\sim 14$ | $100$     | ^ |\n| $15$         | $200$     | ^ |\n| $16$         | $300$     | ^ |\n| $17$         | $500$     | ^ |\n| $18$         | $1\\,000$  | ^ |\n| $19$         | $2\\,000$  | ^ |\n| $20$         | $30\\,000$ | ^ |", "locale": "zh-CN"}}}
{"pid": "P1118", "type": "P", "difficulty": 3, "samples": [["4 16", "3 1 2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2006", "USACO", "枚举", "深度优先搜索 DFS"], "title": "[USACO06FEB] Backward Digit Sums G/S", "background": null, "description": "`FJ` and his cows enjoy playing a mental game. They write down the numbers from $1$ to $ N(1 \\le N  \\le 12)$ in a certain order and then sum adjacent numbers to produce a new list with one fewer number.  They repeat this until only a single number is left.  For example, one instance of the game (when $N=4$) might go like this:\n\n```cpp\n    3   1   2   4\n      4   3   6\n        7   9\n         16\n```\nBehind `FJ`'s back, the cows have started playing a more difficult game, in which they try to determine the starting sequence from only the final total and the number $N$.  Unfortunately, the game is a bit above `FJ`'s mental arithmetic capabilities.\n\n\nWrite a program to help `FJ` play the game and keep up with the cows.", "inputFormat": "Line 1: Two space-separated integers: $N$ and the final sum.", "outputFormat": "Line 1: An ordering of the integers $1\\cdots N$ that leads to the given sum. If there are multiple solutions, choose the one that is lexicographically least, i.e., that puts smaller numbers first.", "hint": "- For $40\\%$ of the data, $1\\le N\\le 7$;\n- For $80\\%$ of the data, $1\\le N \\le 10$;\n- For $100\\%$ of the data, $1\\le N \\le 12$, $1\\le sum\\le 12345$.", "locale": "en", "translations": {"en": {"title": "[USACO06FEB] Backward Digit Sums G/S", "background": null, "description": "`FJ` and his cows enjoy playing a mental game. They write down the numbers from $1$ to $ N(1 \\le N  \\le 12)$ in a certain order and then sum adjacent numbers to produce a new list with one fewer number.  They repeat this until only a single number is left.  For example, one instance of the game (when $N=4$) might go like this:\n\n```cpp\n    3   1   2   4\n      4   3   6\n        7   9\n         16\n```\nBehind `FJ`'s back, the cows have started playing a more difficult game, in which they try to determine the starting sequence from only the final total and the number $N$.  Unfortunately, the game is a bit above `FJ`'s mental arithmetic capabilities.\n\n\nWrite a program to help `FJ` play the game and keep up with the cows.", "inputFormat": "Line 1: Two space-separated integers: $N$ and the final sum.", "outputFormat": "Line 1: An ordering of the integers $1\\cdots N$ that leads to the given sum. If there are multiple solutions, choose the one that is lexicographically least, i.e., that puts smaller numbers first.", "hint": "- For $40\\%$ of the data, $1\\le N\\le 7$;\n- For $80\\%$ of the data, $1\\le N \\le 10$;\n- For $100\\%$ of the data, $1\\le N \\le 12$, $1\\le sum\\le 12345$.", "locale": "en"}, "zh-CN": {"title": "[USACO06FEB] Backward Digit Sums G/S", "background": "", "description": "`FJ` 和他的奶牛们喜欢玩一个心算游戏。他们将数字从 $1$ 到 $N(1 \\le N \\le 12)$ 按某种顺序写下来，然后将相邻的数字相加，得到一个数字更少的新列表。他们重复这个过程，直到只剩下一个数字。例如，游戏的一种情况（当 $N=4$ 时）可能是这样的：\n\n```cpp\n    3   1   2   4\n      4   3   6\n        7   9\n         16\n```\n在 `FJ` 背后，奶牛们开始玩一个更难的游戏，她们试图从最终的总和和数字 $N$ 中确定起始序列。不幸的是，这个游戏有点超出了 `FJ` 的心算能力。\n\n\n编写一个程序来帮助 `FJ` 玩这个游戏，并跟上奶牛们的步伐。\n\n", "inputFormat": "共一行两个正整数 $n,sum$。\n", "outputFormat": "输出包括一行，为字典序最小的那个答案。\n\n当无解的时候，请什么也不输出。\n", "hint": "- 对于 $40\\%$ 的数据，$1\\le N\\le 7$；\n- 对于 $80\\%$ 的数据，$1\\le N \\le 10$；\n- 对于 $100\\%$ 的数据，$1\\le N \\le 12$，$1\\le sum\\le 12345$。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P1119", "type": "P", "difficulty": 4, "samples": [["4 5\n1 2 3 4\n0 2 1\n2 3 1\n3 1 2\n2 1 4\n0 3 5\n4\n2 0 2\n0 1 2\n0 1 3\n0 1 4", "-1\n-1\n5\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "枚举", "最短路"], "title": "灾后重建", "background": "B 地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。\n", "description": "给出 B 地区的村庄数 $N$，村庄编号从 $0$ 到 $N-1$，和所有 $M$ 条公路的长度，公路是双向的。并给出第 $i$ 个村庄重建完成的时间 $t_i$，你可以认为是同时开始重建并在第 $t_i$ 天重建完成，并且在当天即可通车。若 $t_i$ 为 $0$ 则说明地震未对此地区造成损坏，一开始就可以通车。之后有 $Q$ 个询问 $(x,y,t)$，对于每个询问你要回答在第 $t$ 天，从村庄 $x$ 到村庄 $y$ 的最短路径长度为多少。如果无法找到从 $x$ 村庄到 $y$ 村庄的路径，经过若干个已重建完成的村庄，或者村庄 $x$ 或村庄 $y$ 在第 $t$ 天仍未重建完成，则需要输出 $-1$。", "inputFormat": "第一行包含两个正整数 $N,M$，表示了村庄的数目与公路的数量。\n\n第二行包含 $N$ 个非负整数 $t_0,t_1,\\cdots,t_{N-1}$，表示了每个村庄重建完成的时间，数据保证了 $t_0 \\le t_1 \\le \\cdots \\le t_{N-1}$。\n\n接下来 $M$ 行，每行 $3$ 个非负整数 $i,j,w$，$w$ 不超过 $10000$，表示了有一条连接村庄 $i$ 与村庄 $j$ 的道路，长度为 $w$，保证 $i\\neq j$，且对于任意一对村庄只会存在一条道路。\n\n接下来一行也就是 $M+3$ 行包含一个正整数 $Q$，表示 $Q$ 个询问。\n\n接下来 $Q$ 行，每行 $3$ 个非负整数 $x,y,t$，询问在第 $t$ 天，从村庄 $x$ 到村庄 $y$ 的最短路径长度为多少，数据保证了 $t$ 是不下降的。", "outputFormat": "共 $Q$ 行，对每一个询问 $(x,y,t)$ 输出对应的答案，即在第 $t$ 天，从村庄 $x$ 到村庄 $y$ 的最短路径长度为多少。如果在第 $t$ 天无法找到从 $x$ 村庄到 $y$ 村庄的路径，经过若干个已重建完成的村庄，或者村庄 $x$ 或村庄 $y$ 在第 $t$ 天仍未修复完成，则输出 $-1$。", "hint": "- 对于 $30\\%$ 的数据，有 $N\\le 50$；\n- 对于 $30\\%$ 的数据，有 $t_i=0$，其中有 $20\\%$ 的数据有 $t_i=0$ 且 $N>50$；\n- 对于 $50\\%$ 的数据，有 $Q\\le 100$；\n- 对于 $100\\%$ 的数据，有 $1\\le N\\le 200$，$0\\le M\\le \\dfrac{N\\times(N-1)}{2}$，$1\\le Q\\le 50000$，所有输入数据涉及整数均不超过 $10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Post-disaster Reconstruction", "background": null, "description": "Given the number of villages $N$ in Region B, numbered from $0$ to $N-1$, and the lengths of all $M$ bidirectional roads. For each village $i$, you are given the day it is completed $t_i$. All reconstructions start simultaneously, and village $i$ is completed on day $t_i$, becoming open to traffic on that day. If $t_i$ is $0$, the earthquake did not damage that village and it is open from the beginning. Then there are $Q$ queries $(x,y,t)$. For each query, answer the length of the shortest path from village $x$ to village $y$ on day $t$. If there is no path from $x$ to $y$ using only villages that have been completed by day $t$, or if village $x$ or village $y$ has not been completed by day $t$, output $-1$.", "inputFormat": "- The first line contains two positive integers $N,M$, the number of villages and the number of roads.\n- The second line contains $N$ non-negative integers $t_0,t_1,\\cdots,t_{N-1}$, the completion day of each village, and it is guaranteed that $t_0 \\le t_1 \\le \\cdots \\le t_{N-1}$.\n- The next $M$ lines each contain three non-negative integers $i,j,w$ with $w \\le 10000$, indicating a road between villages $i$ and $j$ with length $w$. It is guaranteed that $i \\ne j$, and for any pair of villages there is at most one road.\n- The next line contains a positive integer $Q$, the number of queries.\n- The next $Q$ lines each contain three non-negative integers $x,y,t$, asking for the shortest path length from village $x$ to village $y$ on day $t$. It is guaranteed that $t$ is non-decreasing across the queries.", "outputFormat": "Output $Q$ lines. For each query $(x,y,t)$, output the corresponding answer: the length of the shortest path from village $x$ to village $y$ on day $t$. If on day $t$ there is no path from $x$ to $y$ using only villages that have been completed by day $t$, or if village $x$ or village $y$ has not been completed by day $t$, output $-1$.", "hint": "- For $30\\%$ of the testdata, $N \\le 50$.\n- For $30\\%$ of the testdata, $t_i=0$; among them, for $20\\%$ of the testdata, $t_i=0$ and $N>50$.\n- For $50\\%$ of the testdata, $Q \\le 100$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 200$, $0 \\le M \\le \\dfrac{N\\times(N-1)}{2}$, $1 \\le Q \\le 50000$, and all integers in the input are at most $10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "灾后重建", "background": "B 地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。\n", "description": "给出 B 地区的村庄数 $N$，村庄编号从 $0$ 到 $N-1$，和所有 $M$ 条公路的长度，公路是双向的。并给出第 $i$ 个村庄重建完成的时间 $t_i$，你可以认为是同时开始重建并在第 $t_i$ 天重建完成，并且在当天即可通车。若 $t_i$ 为 $0$ 则说明地震未对此地区造成损坏，一开始就可以通车。之后有 $Q$ 个询问 $(x,y,t)$，对于每个询问你要回答在第 $t$ 天，从村庄 $x$ 到村庄 $y$ 的最短路径长度为多少。如果无法找到从 $x$ 村庄到 $y$ 村庄的路径，经过若干个已重建完成的村庄，或者村庄 $x$ 或村庄 $y$ 在第 $t$ 天仍未重建完成，则需要输出 $-1$。", "inputFormat": "第一行包含两个正整数 $N,M$，表示了村庄的数目与公路的数量。\n\n第二行包含 $N$ 个非负整数 $t_0,t_1,\\cdots,t_{N-1}$，表示了每个村庄重建完成的时间，数据保证了 $t_0 \\le t_1 \\le \\cdots \\le t_{N-1}$。\n\n接下来 $M$ 行，每行 $3$ 个非负整数 $i,j,w$，$w$ 不超过 $10000$，表示了有一条连接村庄 $i$ 与村庄 $j$ 的道路，长度为 $w$，保证 $i\\neq j$，且对于任意一对村庄只会存在一条道路。\n\n接下来一行也就是 $M+3$ 行包含一个正整数 $Q$，表示 $Q$ 个询问。\n\n接下来 $Q$ 行，每行 $3$ 个非负整数 $x,y,t$，询问在第 $t$ 天，从村庄 $x$ 到村庄 $y$ 的最短路径长度为多少，数据保证了 $t$ 是不下降的。", "outputFormat": "共 $Q$ 行，对每一个询问 $(x,y,t)$ 输出对应的答案，即在第 $t$ 天，从村庄 $x$ 到村庄 $y$ 的最短路径长度为多少。如果在第 $t$ 天无法找到从 $x$ 村庄到 $y$ 村庄的路径，经过若干个已重建完成的村庄，或者村庄 $x$ 或村庄 $y$ 在第 $t$ 天仍未修复完成，则输出 $-1$。", "hint": "- 对于 $30\\%$ 的数据，有 $N\\le 50$；\n- 对于 $30\\%$ 的数据，有 $t_i=0$，其中有 $20\\%$ 的数据有 $t_i=0$ 且 $N>50$；\n- 对于 $50\\%$ 的数据，有 $Q\\le 100$；\n- 对于 $100\\%$ 的数据，有 $1\\le N\\le 200$，$0\\le M\\le \\dfrac{N\\times(N-1)}{2}$，$1\\le Q\\le 50000$，所有输入数据涉及整数均不超过 $10^5$。", "locale": "zh-CN"}}}
