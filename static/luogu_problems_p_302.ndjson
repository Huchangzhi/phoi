{"pid": "P7110", "type": "P", "difficulty": 7, "samples": [["3 5\n1 1\n1 3\n3 2\n2 2\n3 2", "0\n1\n"], ["5 6\n1 1\n1 3\n2 2\n2 3\n2 4\n3 5", "1"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["平衡树", "洛谷原创", "O2优化", "洛谷月赛"], "title": "晚秋绝诗", "background": "", "description": "在晚秋时分观赏 L 国举世闻名的佳景——藏雾山，无不是一件惬意之事。\n\n藏雾山共有 $n$ 座山峰，从 $1$ 到 $n$ 编号。起初，$n$ 座山峰的山顶均被秋雾遮盖，因而无法辨别其高度。\n\n同时，称第 $i$ 座山峰为**间峰**，当且仅当其高度恰好是第 $i-1$ 座与第 $i + 1$ 座高度的平均值（特别地，第 $1$ 座与第 $n$ 座**不算**间峰）。藏雾山一带向来会在**部分间峰**的山底悬挂旗帜，起初所有山峰的山底均无旗帜。\n\n现有 $m$ 天，每天会发生以下之一的事件：\n\n- 雾去/雾回：第 $x$ 座山峰山顶的秋雾散去，或重新聚集。\n- 旗升/旗落：第 $x$ 座山峰山底的旗帜挂起，或被人卸下。\n- 来客：一位登山爱好者造访藏雾山欲攀登第 $x$ 座山峰，他希望能当天知晓该山峰的海拔高度。\n\n登山爱好者们将以两种方式知晓：直接观测出**未被秋雾遮盖**山峰的海拔高度，或是利用当天各山底旗帜给出的间峰信息，**尽可能地推算出其余**山峰的高度。除此之外，他们无法使用其他方式，包括但不限于与过往的来客交流分享信息等。\n\n你能求出每位登山爱好者能否知晓目标山峰的高度吗？", "inputFormat": "第一行包含两个正整数 $n$ 和 $m$，分别为藏雾山的山峰个数和事件持续的天数。\n\n接下来 $m$ 行，每行包含两个正整数 $op, x$，其中 $op \\in \\{1,2,3\\}$，具体地：\n\n- 对于 $op=1$，保证 $1 \\le x \\le n$，表示若第 $x$ 座山峰的山顶有雾，则变为无雾状态；若第 $x$ 座山峰的山顶无雾，则变为有雾状态。\n- 对于 $op=2$，保证 $2 \\le x < n$，表示若第 $x$ 座山峰的山底无旗，则变为有旗状态；若第 $x$ 座山峰的山底有旗，则变为无旗状态。\n- 对于 $op=3$，保证 $1 \\le x \\le n$，表示一位欲攀登第 $x$ 座山峰的登山爱好者造访。", "outputFormat": "输出若干行，每行一个布尔值依次表示每位登山爱好者能否知晓高度，$1$ 则能，$0$ 则不能。", "hint": "**【样例解释 #1】**\n\n在没有任何间峰信息的情况下，第一个登山爱好者不可能知晓被秋雾遮盖山峰的高度。\n\n第二个登山爱好者造访时已知山峰 $1$ 的高度、山峰 $3$ 的高度以及山峰 $2$ 为间峰，因此山峰 $2$ 的高度能通过平均值计算得到。\n\n----\n\n**【数据规模与约定】**\n\n**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。\n\n- Subtask #1 (7 points)：$n \\le 5$，$m \\le 10$。\n- Subtask #2 (13 points)：$n,m \\le 100$。\n- Subtask #3 (15 points)：$n,m \\le 2000$。\n- Subtask #4 (20 points)：$n,m \\le 10^5$。\n- Subtask #5 (20 points)：所有 $op = 1$ 事件在所有 $op = 2$ 事件后。\n- Subtask #6 (25 points)：无特殊限制。\n\n对于所有的数据，保证 $3 \\le n \\le 5 \\cdot 10^5$，$1 \\le m \\le 5 \\cdot 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "晚秋绝诗", "background": "", "description": "在晚秋时分观赏 L 国举世闻名的佳景——藏雾山，无不是一件惬意之事。\n\n藏雾山共有 $n$ 座山峰，从 $1$ 到 $n$ 编号。起初，$n$ 座山峰的山顶均被秋雾遮盖，因而无法辨别其高度。\n\n同时，称第 $i$ 座山峰为**间峰**，当且仅当其高度恰好是第 $i-1$ 座与第 $i + 1$ 座高度的平均值（特别地，第 $1$ 座与第 $n$ 座**不算**间峰）。藏雾山一带向来会在**部分间峰**的山底悬挂旗帜，起初所有山峰的山底均无旗帜。\n\n现有 $m$ 天，每天会发生以下之一的事件：\n\n- 雾去/雾回：第 $x$ 座山峰山顶的秋雾散去，或重新聚集。\n- 旗升/旗落：第 $x$ 座山峰山底的旗帜挂起，或被人卸下。\n- 来客：一位登山爱好者造访藏雾山欲攀登第 $x$ 座山峰，他希望能当天知晓该山峰的海拔高度。\n\n登山爱好者们将以两种方式知晓：直接观测出**未被秋雾遮盖**山峰的海拔高度，或是利用当天各山底旗帜给出的间峰信息，**尽可能地推算出其余**山峰的高度。除此之外，他们无法使用其他方式，包括但不限于与过往的来客交流分享信息等。\n\n你能求出每位登山爱好者能否知晓目标山峰的高度吗？", "inputFormat": "第一行包含两个正整数 $n$ 和 $m$，分别为藏雾山的山峰个数和事件持续的天数。\n\n接下来 $m$ 行，每行包含两个正整数 $op, x$，其中 $op \\in \\{1,2,3\\}$，具体地：\n\n- 对于 $op=1$，保证 $1 \\le x \\le n$，表示若第 $x$ 座山峰的山顶有雾，则变为无雾状态；若第 $x$ 座山峰的山顶无雾，则变为有雾状态。\n- 对于 $op=2$，保证 $2 \\le x < n$，表示若第 $x$ 座山峰的山底无旗，则变为有旗状态；若第 $x$ 座山峰的山底有旗，则变为无旗状态。\n- 对于 $op=3$，保证 $1 \\le x \\le n$，表示一位欲攀登第 $x$ 座山峰的登山爱好者造访。", "outputFormat": "输出若干行，每行一个布尔值依次表示每位登山爱好者能否知晓高度，$1$ 则能，$0$ 则不能。", "hint": "**【样例解释 #1】**\n\n在没有任何间峰信息的情况下，第一个登山爱好者不可能知晓被秋雾遮盖山峰的高度。\n\n第二个登山爱好者造访时已知山峰 $1$ 的高度、山峰 $3$ 的高度以及山峰 $2$ 为间峰，因此山峰 $2$ 的高度能通过平均值计算得到。\n\n----\n\n**【数据规模与约定】**\n\n**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。\n\n- Subtask #1 (7 points)：$n \\le 5$，$m \\le 10$。\n- Subtask #2 (13 points)：$n,m \\le 100$。\n- Subtask #3 (15 points)：$n,m \\le 2000$。\n- Subtask #4 (20 points)：$n,m \\le 10^5$。\n- Subtask #5 (20 points)：所有 $op = 1$ 事件在所有 $op = 2$ 事件后。\n- Subtask #6 (25 points)：无特殊限制。\n\n对于所有的数据，保证 $3 \\le n \\le 5 \\cdot 10^5$，$1 \\le m \\le 5 \\cdot 10^5$。", "locale": "zh-CN"}}}
{"pid": "P7111", "type": "P", "difficulty": 7, "samples": [["2 2\n1 1\n1 2 2\n2 0 2", "499122177\n0"], ["5 3\n12 16 3 15 9\n1 13 25\n3 10 30\n4 11 17", "743774619\n107297923\n234909256"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["洛谷原创", "O2优化", "生成函数", "分块", "洛谷月赛"], "title": "青春有悔", "background": "岁月奔波，已值青年的 Gnar 踏上了梦想与未来的征途。\n\n他终失败而归。", "description": "那是一次持续 $n$ 天的角逐，每天 Gnar 必须参加一场考试，受诸多因素影响第 $i$ 天 Gnar 理论得分上限为 $a_i$，实际他当天考试的得分为 $[0, a_i]$ 中**等概率随机的整数**（因时间不够、简单题丢分等）。$n$ 天后，官方将结算总分，并划定分数线，总分达到**分数线及以上**者方可入围。\n\n无数个“凭什么”横生于脑海，似乎每天都有发挥的缺陷。“缺陷……要是能改写过往的遗憾……”\n\n深夜，Gnar 开始了 $q$ 次幻想。每次幻想中 Gnar 重返了角逐的第 $p$ 天，以不同的状态参加考试，使当天得分变为 $[0,x]$ 中**等概率随机的整数**，其余 $n-1$ 天依旧在 $[0,a_i]$ 中随机。然而一些微妙的效应导致分数线变为了 $y$，入围的机会真能如所料高于现实吗？\n\n请你求出每次幻想中的入围概率对 $998244353$ 取模的结果。容易证明答案可以表示为最简分数 $\\frac{Q}{P}$，你输出的 $R$ 即满足 $R \\cdot P \\equiv Q \\pmod{998244353}$ 的最小非负整数。\n\n毕竟幻想，重返第 $p$ 天新的得分上限 $x$ 并不会改变现实 $a_p$ 的值，唯一萌生的只有对青春的悔恨。", "inputFormat": "第一行包含两个正整数 $n$ 和 $q$，分别为天数和幻想次数。\n\n第二行包含 $n$ 个整数 $a_1,a_2, \\ldots ,a_n$，表示现实中每天的得分上限。\n\n接下来$q$行，每行包含三个整数 $p,x,y$，分别为该次幻想的重返日期，新的得分上限以及新的分数线。", "outputFormat": "输出 $q$ 行，每行一个整数，对应每次幻想中的入围概率对 $998244353$ 取模的结果。", "hint": "**【样例解释 #1】**\n\n第一次幻想，Gnar 重返了第一天，两天分别的得分情况在 $\\{0,0\\}$，$\\{0,1\\}$，$\\{1,0\\}$，$\\{1,1\\}$，$\\{2,0\\}$，$\\{2,1\\}$ 内等概率产生，其中只有后三种能够入围，故答案为 $\\frac{1}{2}$。\n\n第二次幻想，Gnar 重返了第二天，状态反而变差，即使拿满两天的得分上限也没机会入围。\n\n----\n\n**【数据规模与约定】**\n\n**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。\n\n- Subtask #1 (10 points)：$n,q,a_i,x,y \\le 100$。\n- Subtask #2 (10 points)：$n,q,a_i,x,y \\le 500$。\n- Subtask #3 (10 points)：$a_i,x \\le 1$。\n- Subtask #4 (20 points)：$\\sum a_i \\le 10^5$。\n- Subtask #5 (25 points)：$q = 1$。\n- Subtask #6 (25 points)：无特殊限制。\n\n对于所有的数据，保证 $1 \\le n,q \\le 10^5$，$1 \\le p \\le n$，$0 \\le a_i,x,y \\le 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "青春有悔", "background": "岁月奔波，已值青年的 Gnar 踏上了梦想与未来的征途。\n\n他终失败而归。", "description": "那是一次持续 $n$ 天的角逐，每天 Gnar 必须参加一场考试，受诸多因素影响第 $i$ 天 Gnar 理论得分上限为 $a_i$，实际他当天考试的得分为 $[0, a_i]$ 中**等概率随机的整数**（因时间不够、简单题丢分等）。$n$ 天后，官方将结算总分，并划定分数线，总分达到**分数线及以上**者方可入围。\n\n无数个“凭什么”横生于脑海，似乎每天都有发挥的缺陷。“缺陷……要是能改写过往的遗憾……”\n\n深夜，Gnar 开始了 $q$ 次幻想。每次幻想中 Gnar 重返了角逐的第 $p$ 天，以不同的状态参加考试，使当天得分变为 $[0,x]$ 中**等概率随机的整数**，其余 $n-1$ 天依旧在 $[0,a_i]$ 中随机。然而一些微妙的效应导致分数线变为了 $y$，入围的机会真能如所料高于现实吗？\n\n请你求出每次幻想中的入围概率对 $998244353$ 取模的结果。容易证明答案可以表示为最简分数 $\\frac{Q}{P}$，你输出的 $R$ 即满足 $R \\cdot P \\equiv Q \\pmod{998244353}$ 的最小非负整数。\n\n毕竟幻想，重返第 $p$ 天新的得分上限 $x$ 并不会改变现实 $a_p$ 的值，唯一萌生的只有对青春的悔恨。", "inputFormat": "第一行包含两个正整数 $n$ 和 $q$，分别为天数和幻想次数。\n\n第二行包含 $n$ 个整数 $a_1,a_2, \\ldots ,a_n$，表示现实中每天的得分上限。\n\n接下来$q$行，每行包含三个整数 $p,x,y$，分别为该次幻想的重返日期，新的得分上限以及新的分数线。", "outputFormat": "输出 $q$ 行，每行一个整数，对应每次幻想中的入围概率对 $998244353$ 取模的结果。", "hint": "**【样例解释 #1】**\n\n第一次幻想，Gnar 重返了第一天，两天分别的得分情况在 $\\{0,0\\}$，$\\{0,1\\}$，$\\{1,0\\}$，$\\{1,1\\}$，$\\{2,0\\}$，$\\{2,1\\}$ 内等概率产生，其中只有后三种能够入围，故答案为 $\\frac{1}{2}$。\n\n第二次幻想，Gnar 重返了第二天，状态反而变差，即使拿满两天的得分上限也没机会入围。\n\n----\n\n**【数据规模与约定】**\n\n**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。\n\n- Subtask #1 (10 points)：$n,q,a_i,x,y \\le 100$。\n- Subtask #2 (10 points)：$n,q,a_i,x,y \\le 500$。\n- Subtask #3 (10 points)：$a_i,x \\le 1$。\n- Subtask #4 (20 points)：$\\sum a_i \\le 10^5$。\n- Subtask #5 (25 points)：$q = 1$。\n- Subtask #6 (25 points)：无特殊限制。\n\n对于所有的数据，保证 $1 \\le n,q \\le 10^5$，$1 \\le p \\le n$，$0 \\le a_i,x,y \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P7112", "type": "P", "difficulty": 5, "samples": [["2 998244353\n1 4\n1 5", "1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "O2优化", "线性代数", "高斯消元", "行列式", "模板题"], "title": "【模板】行列式求值", "background": "模板题，无背景。", "description": "给定一个 $n$ 阶行列式 $A$，求 $|A|$。结果对 $p$ 取模。", "inputFormat": "第一行两个正整数 $n$ 和 $p$。\n\n接下来共 $n$ 行，第 $i+1$ 行 $n$ 个正整数，其中第 $j$ 个表示 $A_{i,j}$。", "outputFormat": "输出 $|A|$ 在模 $p$ 意义下的最小自然数值。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 600$，$1\\le a_{i,j}< 10^9+7$，$1\\le p\\le 10^9+7$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【模板】行列式求值", "background": "模板题，无背景。", "description": "给定一个 $n$ 阶行列式 $A$，求 $|A|$。结果对 $p$ 取模。", "inputFormat": "第一行两个正整数 $n$ 和 $p$。\n\n接下来共 $n$ 行，第 $i+1$ 行 $n$ 个正整数，其中第 $j$ 个表示 $A_{i,j}$。", "outputFormat": "输出 $|A|$ 在模 $p$ 意义下的最小自然数值。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 600$，$1\\le a_{i,j}< 10^9+7$，$1\\le p\\le 10^9+7$。", "locale": "zh-CN"}}}
{"pid": "P7113", "type": "P", "difficulty": 3, "samples": [["5 1\n3 2 3 5\n2 4 5\n2 5 4\n0\n0\n", "1 3\n2 3\n"], ["见附件中的 water/water2.in", "见附件中的 water/water2.ans"], ["见附件中的 water/water3.in", "见附件中的 water/water3.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "高精度", "2020", "NOIP 提高组", "拓扑排序"], "title": "[NOIP2020] 排水系统", "background": "", "description": "对于一个城市来说，排水系统是极其重要的一个部分。\n\n有一天，小 C 拿到了某座城市排水系统的设计图。排水系统由 $n$ 个排水结点（它们从 $1 \\sim n$ 编号）和若干个单向排水管道构成。每一个排水结点有若干个管道用于汇集其他排水结点的污水（简称为该结点的汇集管道），也有若干个管道向其他的排水结点排出污水（简称为该结点的排出管道）。\n\n排水系统的结点中有 $m$ 个污水接收口，它们的编号分别为 $1, 2, \\ldots , m$，污水只能从这些接收口流入排水系统，并且这些结点没有汇集管道。排水系统中还有若干个最终排水口，它们将污水运送到污水处理厂，没有排出管道的结点便可视为一个最终排水口。\n\n现在各个污水接收口分别都接收了 $1$ 吨污水，污水进入每个结点后，会均等地从当前结点的每一个排出管道流向其他排水结点，而最终排水口将把污水排出系统。\n\n现在小 C 想知道，在该城市的排水系统中，每个最终排水口会排出多少污水。该城市的排水系统设计科学，管道不会形成回路，即不会发生污水形成环流的情况。", "inputFormat": "第一个两个用单个空格分隔的整数 $n, m$。分别表示排水结点数与接收口数量。  \n接下来 $n$ 行，第 $i$ 行用于描述结点 $i$ 的所有排出管道。其中每行第一个整数 $d_i$ 表示其排出管道的数量，接下来 $d_i$ 个用单个空格分隔的整数 $a_1, a_2, \\ldots , a_{d_i}$ 依次表示管道的目标排水结点。  \n保证不会出现两条起始结点与目标结点均相同的管道。", "outputFormat": "输出若干行，按照编号从小到大的顺序，给出每个最终排水口排出的污水体积。其中体积使用分数形式进行输出，即每行输出两个用单个空格分隔的整数 $p$，$q$，表示排出的污水体积为 $\\frac{p}{q}$。要求 $p$ 与 $q$ 互素，$q = 1$ 时也需要输出 $q$。", "hint": "**【样例 #1 解释】**\n\n$1$ 号结点是接收口，$4, 5$ 号结点没有排出管道，因此是最终排水口。  \n$1$ 吨污水流入 $1$ 号结点后，均等地流向 $2, 3, 5$ 号结点，三个结点各流入 $\\frac{1}{3}$ 吨污水。  \n$2$ 号结点流入的 $\\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\\frac{1}{6}$ 吨污水。  \n$3$ 号结点流入的 $\\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\\frac{1}{6}$ 吨污水。  \n最终，$4$ 号结点排出 $\\frac{1}{6} + \\frac{1}{6} = \\frac{1}{3}$ 吨污水，$5$ 号结点排出 $\\frac{1}{3} + \\frac{1}{6} + \\frac{1}{6} = \\frac{2}{3}$ 吨污水。\n\n**【数据范围】**\n\n| 测试点编号 | $n \\le$ | $m \\le$ |\n|:-:|:-:|:-:|\n| $1 \\sim 3$ | $10$ | $1$ |\n| $4 \\sim 6$ | ${10}^3$ | $1$ |\n| $7 \\sim 8$ | ${10}^5$ | $1$ |\n| $9 \\sim 10$ | ${10}^5$ | $10$ |\n\n对于全部的测试点，保证 $1 \\le n \\le {10}^5$，$1 \\le m \\le 10$，$0 \\le d_i \\le 5$。\n\n数据保证，污水在从一个接收口流向一个最终排水口的过程中，不会经过超过 $10$ 个中间排水结点（即接收口和最终排水口不算在内）。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOIP2020] 排水系统", "background": "", "description": "对于一个城市来说，排水系统是极其重要的一个部分。\n\n有一天，小 C 拿到了某座城市排水系统的设计图。排水系统由 $n$ 个排水结点（它们从 $1 \\sim n$ 编号）和若干个单向排水管道构成。每一个排水结点有若干个管道用于汇集其他排水结点的污水（简称为该结点的汇集管道），也有若干个管道向其他的排水结点排出污水（简称为该结点的排出管道）。\n\n排水系统的结点中有 $m$ 个污水接收口，它们的编号分别为 $1, 2, \\ldots , m$，污水只能从这些接收口流入排水系统，并且这些结点没有汇集管道。排水系统中还有若干个最终排水口，它们将污水运送到污水处理厂，没有排出管道的结点便可视为一个最终排水口。\n\n现在各个污水接收口分别都接收了 $1$ 吨污水，污水进入每个结点后，会均等地从当前结点的每一个排出管道流向其他排水结点，而最终排水口将把污水排出系统。\n\n现在小 C 想知道，在该城市的排水系统中，每个最终排水口会排出多少污水。该城市的排水系统设计科学，管道不会形成回路，即不会发生污水形成环流的情况。", "inputFormat": "第一个两个用单个空格分隔的整数 $n, m$。分别表示排水结点数与接收口数量。  \n接下来 $n$ 行，第 $i$ 行用于描述结点 $i$ 的所有排出管道。其中每行第一个整数 $d_i$ 表示其排出管道的数量，接下来 $d_i$ 个用单个空格分隔的整数 $a_1, a_2, \\ldots , a_{d_i}$ 依次表示管道的目标排水结点。  \n保证不会出现两条起始结点与目标结点均相同的管道。", "outputFormat": "输出若干行，按照编号从小到大的顺序，给出每个最终排水口排出的污水体积。其中体积使用分数形式进行输出，即每行输出两个用单个空格分隔的整数 $p$，$q$，表示排出的污水体积为 $\\frac{p}{q}$。要求 $p$ 与 $q$ 互素，$q = 1$ 时也需要输出 $q$。", "hint": "**【样例 #1 解释】**\n\n$1$ 号结点是接收口，$4, 5$ 号结点没有排出管道，因此是最终排水口。  \n$1$ 吨污水流入 $1$ 号结点后，均等地流向 $2, 3, 5$ 号结点，三个结点各流入 $\\frac{1}{3}$ 吨污水。  \n$2$ 号结点流入的 $\\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\\frac{1}{6}$ 吨污水。  \n$3$ 号结点流入的 $\\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\\frac{1}{6}$ 吨污水。  \n最终，$4$ 号结点排出 $\\frac{1}{6} + \\frac{1}{6} = \\frac{1}{3}$ 吨污水，$5$ 号结点排出 $\\frac{1}{3} + \\frac{1}{6} + \\frac{1}{6} = \\frac{2}{3}$ 吨污水。\n\n**【数据范围】**\n\n| 测试点编号 | $n \\le$ | $m \\le$ |\n|:-:|:-:|:-:|\n| $1 \\sim 3$ | $10$ | $1$ |\n| $4 \\sim 6$ | ${10}^3$ | $1$ |\n| $7 \\sim 8$ | ${10}^5$ | $1$ |\n| $9 \\sim 10$ | ${10}^5$ | $10$ |\n\n对于全部的测试点，保证 $1 \\le n \\le {10}^5$，$1 \\le m \\le 10$，$0 \\le d_i \\le 5$。\n\n数据保证，污水在从一个接收口流向一个最终排水口的过程中，不会经过超过 $10$ 个中间排水结点（即接收口和最终排水口不算在内）。", "locale": "zh-CN"}}}
{"pid": "P7114", "type": "P", "difficulty": 5, "samples": [["3\nnnrnnr\nzzzaab\nmmlmmlo\n", "8\n9\n16\n"], ["5\nkkkkkkkkkkkkkkkkkkkk\nlllllllllllllrrlllrr\ncccccccccccccxcxxxcc\nccccccccccccccaababa\nggggggggggggggbaabab\n", "156\n138\n138\n147\n194\n"], ["见附件中的 string/string3.in", "见附件中的 string/string3.ans"], ["见附件中的 string/string4.in", "见附件中的 string/string4.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "2020", "倍增", "树状数组", "NOIP 提高组", "哈希 hashing", "调和级数", "Z 函数"], "title": "[NOIP2020] 字符串匹配", "background": "", "description": "小 C 学习完了字符串匹配的相关内容，现在他正在做一道习题。\n\n对于一个字符串 $S$，题目要求他找到 $S$ 的所有具有下列形式的拆分方案数：\n\n$S = ABC$，$S = ABABC$，$S = ABAB \\ldots ABC$，其中 $A$，$B$，$C$ 均是非空字符串，且 $A$ 中出现奇数次的字符数量不超过 $C$ 中出现奇数次的字符数量。\n\n更具体地，我们可以定义 $AB$ 表示两个字符串 $A$，$B$ 相连接，例如 $A = \\texttt{aab}$，$B = \\texttt{ab}$，则 $AB = \\texttt{aabab}$。\n\n并递归地定义 $A^1=A$，$A^n = A^{n - 1} A$（$n \\ge 2$ 且为正整数）。例如 $A = \\texttt{abb}$，则 $A^3=\\texttt{abbabbabb}$。\n\n则小 C 的习题是求 $S = {(AB)}^iC$ 的方案数，其中 $F(A) \\le F(C)$，$F(S)$ 表示字符串 $S$ 中出现奇数次的字符的数量。两种方案不同当且仅当拆分出的 $A$、$B$、$C$ 中有至少一个字符串不同。\n\n小 C 并不会做这道题，只好向你求助，请你帮帮他。", "inputFormat": "本题有多组数据，输入文件第一行一个正整数 $T$ 表示数据组数。\n\n每组数据仅一行一个字符串 $S$，意义见题目描述。$S$ 仅由英文小写字母构成。", "outputFormat": "对于每组数据输出一行一个整数表示答案。", "hint": "**【样例 #1 解释】**\n\n对于第一组数据，所有的方案为\n\n1. $A=\\texttt{n}$，$B=\\texttt{nr}$，$C=\\texttt{nnr}$。\n2. $A=\\texttt{n}$，$B=\\texttt{nrn}$，$C=\\texttt{nr}$。\n3. $A=\\texttt{n}$，$B=\\texttt{nrnn}$，$C=\\texttt{r}$。\n4. $A=\\texttt{nn}$，$B=\\texttt{r}$，$C=\\texttt{nnr}$。\n5. $A=\\texttt{nn}$，$B=\\texttt{rn}$，$C=\\texttt{nr}$。\n6. $A=\\texttt{nn}$，$B=\\texttt{rnn}$，$C=\\texttt{r}$。\n7. $A=\\texttt{nnr}$，$B=\\texttt{n}$，$C=\\texttt{nr}$。\n8. $A=\\texttt{nnr}$，$B=\\texttt{nn}$，$C=\\texttt{r}$。\n\n**【数据范围】**\n\n| 测试点编号 | $\\lvert S \\rvert \\le$ | 特殊性质 |\n|:-:|:-:|:-:|\n| $1 \\sim 4$ | $10$ | 无 |\n| $5 \\sim 8$ | $100$ | 无 |\n| $9 \\sim 12$ | $1000$ | 无 |\n| $13 \\sim 14$ | $2^{15}$ | $S$ 中只包含一种字符 |\n| $15 \\sim 17$ | $2^{16}$ | $S$ 中只包含两种字符 |\n| $18 \\sim 21$ | $2^{17}$ | 无 |\n| $22 \\sim 25$ | $2^{20}$ | 无 |\n\n对于所有测试点，保证 $1 \\le T \\le 5$，$1 \\le |S| \\le 2^{20}$。 ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOIP2020] 字符串匹配", "background": "", "description": "小 C 学习完了字符串匹配的相关内容，现在他正在做一道习题。\n\n对于一个字符串 $S$，题目要求他找到 $S$ 的所有具有下列形式的拆分方案数：\n\n$S = ABC$，$S = ABABC$，$S = ABAB \\ldots ABC$，其中 $A$，$B$，$C$ 均是非空字符串，且 $A$ 中出现奇数次的字符数量不超过 $C$ 中出现奇数次的字符数量。\n\n更具体地，我们可以定义 $AB$ 表示两个字符串 $A$，$B$ 相连接，例如 $A = \\texttt{aab}$，$B = \\texttt{ab}$，则 $AB = \\texttt{aabab}$。\n\n并递归地定义 $A^1=A$，$A^n = A^{n - 1} A$（$n \\ge 2$ 且为正整数）。例如 $A = \\texttt{abb}$，则 $A^3=\\texttt{abbabbabb}$。\n\n则小 C 的习题是求 $S = {(AB)}^iC$ 的方案数，其中 $F(A) \\le F(C)$，$F(S)$ 表示字符串 $S$ 中出现奇数次的字符的数量。两种方案不同当且仅当拆分出的 $A$、$B$、$C$ 中有至少一个字符串不同。\n\n小 C 并不会做这道题，只好向你求助，请你帮帮他。", "inputFormat": "本题有多组数据，输入文件第一行一个正整数 $T$ 表示数据组数。\n\n每组数据仅一行一个字符串 $S$，意义见题目描述。$S$ 仅由英文小写字母构成。", "outputFormat": "对于每组数据输出一行一个整数表示答案。", "hint": "**【样例 #1 解释】**\n\n对于第一组数据，所有的方案为\n\n1. $A=\\texttt{n}$，$B=\\texttt{nr}$，$C=\\texttt{nnr}$。\n2. $A=\\texttt{n}$，$B=\\texttt{nrn}$，$C=\\texttt{nr}$。\n3. $A=\\texttt{n}$，$B=\\texttt{nrnn}$，$C=\\texttt{r}$。\n4. $A=\\texttt{nn}$，$B=\\texttt{r}$，$C=\\texttt{nnr}$。\n5. $A=\\texttt{nn}$，$B=\\texttt{rn}$，$C=\\texttt{nr}$。\n6. $A=\\texttt{nn}$，$B=\\texttt{rnn}$，$C=\\texttt{r}$。\n7. $A=\\texttt{nnr}$，$B=\\texttt{n}$，$C=\\texttt{nr}$。\n8. $A=\\texttt{nnr}$，$B=\\texttt{nn}$，$C=\\texttt{r}$。\n\n**【数据范围】**\n\n| 测试点编号 | $\\lvert S \\rvert \\le$ | 特殊性质 |\n|:-:|:-:|:-:|\n| $1 \\sim 4$ | $10$ | 无 |\n| $5 \\sim 8$ | $100$ | 无 |\n| $9 \\sim 12$ | $1000$ | 无 |\n| $13 \\sim 14$ | $2^{15}$ | $S$ 中只包含一种字符 |\n| $15 \\sim 17$ | $2^{16}$ | $S$ 中只包含两种字符 |\n| $18 \\sim 21$ | $2^{17}$ | 无 |\n| $22 \\sim 25$ | $2^{20}$ | 无 |\n\n对于所有测试点，保证 $1 \\le T \\le 5$，$1 \\le |S| \\le 2^{20}$。 ", "locale": "zh-CN"}}}
{"pid": "P7115", "type": "P", "difficulty": 6, "samples": [["2 3\n1 1 2\n2 1 2\n", "6\n1 3\n2 3\n2 3\n3 1\n3 2\n3 2\n"], ["见附件中的 ball/ball2.in", "见附件中的 ball/ball2.ans"], ["见附件中的 ball/ball3.in", "见附件中的 ball/ball3.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "NOIP 提高组", "Special Judge", "分治", "构造", "Ad-hoc"], "title": "[NOIP2020] 移球游戏", "background": "", "description": "小 C 正在玩一个移球游戏，他面前有 $n + 1$ 根柱子，柱子从 $1 \\sim n + 1$ 编号，其中 $1$ 号柱子、$2$ 号柱子、……、$n$ 号柱子上各有 $m$ 个球，它们自底向上放置在柱子上，$n + 1$ 号柱子上初始时没有球。这 $n \\times m$ 个球共有 $n$ 种颜色，每种颜色的球各 $m$ 个。\n\n初始时一根柱子上的球可能是五颜六色的，而小 C 的任务是将所有同种颜色的球移到同一根柱子上，这是唯一的目标，而每种颜色的球最后放置在哪根柱子则没有限制。\n\n小 C 可以通过若干次操作完成这个目标，一次操作能将一个球从一根柱子移到另一根柱子上。更具体地，将 $x$ 号柱子上的球移动到 $y$ 号柱子上的要求为：\n\n1. $x$ 号柱子上至少有一个球；\n2. $y$ 号柱子上至多有 $m - 1$ 个球；\n3. 只能将 $x$ 号柱子最上方的球移到 $y$ 号柱子的最上方。\n\n小 C 的目标并不难完成，因此他决定给自己加加难度：在完成目标的基础上，使用的操作次数不能超过 $820000$。换句话说，小 C 需要使用至多 $820000$ 次操作完成目标。\n\n小 C 被难住了，但他相信难不倒你，请你给出一个操作方案完成小 C 的目标。合法的方案可能有多种，你只需要给出任意一种，题目保证一定存在一个合法方案。", "inputFormat": "第一行两个用空格分隔的整数 $n, m$。分别表示球的颜色数、每种颜色球的个数。  \n接下来 $n$ 行每行 $m$ 个用单个空格分隔的整数，第 $i$ 行的整数按自底向上的顺序依次给出了 $i$ 号柱子上的球的颜色。", "outputFormat": "本题采用自定义校验器（special judge）评测。  \n你的输出的第一行应该仅包含单个整数 $k$，表示你的方案的操作次数。你应保证 $0 \\le k \\le 820000$。  \n接下来 $k$ 行每行你应输出两个用单个空格分隔的正整数 $x, y$，表示这次操作将 $x$ 号柱子最上方的球移动到 $y$ 号柱子最上方。你应保证 $1 \\le x, y \\le n + 1$ 且 $x \\ne y$。", "hint": "**【样例 #1 解释】**\n\n柱子中的内容为：按自底向上的顺序依次给出柱子上每个球的颜色。\n\n| 操作 | $1$ 号柱子 | $2$ 号柱子 | $3$ 号柱子 |\n|:-:|:-:|:-:|:-:|\n| 初始 | $1\\ 1\\ 2$ | $2\\ 1\\ 2$ | |\n| $1\\ 3$ | $1\\ 1$ | $2\\ 1\\ 2$ | $2$ |\n| $2\\ 3$ | $1\\ 1$ | $2\\ 1$ | $2\\ 2$ |\n| $2\\ 3$ | $1\\ 1$ | $2$ | $2\\ 2\\ 1$ |\n| $3\\ 1$ | $1\\ 1\\ 1$ | $2$ | $2\\ 2$ |\n| $3\\ 2$ | $1\\ 1\\ 1$ | $2\\ 2$ | $2$ |\n| $3\\ 2$ | $1\\ 1\\ 1$ | $2\\ 2\\ 2$ | |\n\n**【数据范围】**\n\n| 测试点编号 | $n \\le$ | $m \\le$ |\n|:-:|:-:|:-:|\n| $1 \\sim 2$ | $2$ | $20$ |\n| $3 \\sim 5$ | $10$ | $20$ |\n| $6 \\sim 8$ | $50$ | $85$ |\n| $9 \\sim 14$ | $50$ | $300$ |\n| $15 \\sim 20$ | $50$ | $400$ |\n\n对于所有测试点，保证 $2 \\le n \\le 50$，$2 \\le m \\le 400$。\n\n**【校验器】**\n\n为了方便选手测试，在附件中的 `ball` 目录下我们下发了 `checker.cpp` 文件，选手可以编译该程序，并使用它校验自己的输出文件。但请注意它与最终评测时所使用的校验器并不完全一致。你也不需要关心其代码的具体内容。\n\n编译命令为：`g++ checker.cpp −o checker -std=c++11`。\n\n`checker` 的使用方式为：`checker <inputfile> <outputfile>`，参数依次表示输入文件与你的输出文件。\n\n若你输出的数字大小范围不合法，则校验器会给出相应提示。若你的输出数字大小范围正确，但方案错误，则校验器会给出简要的错误信息：\n\n1. `A x`，表示进行到第 $x$ 个操作时不合法。\n2. `B x`，表示操作执行完毕后第 $x$ 个柱子上的球不合法。\n\n若你的方案正确，校验器会给出 `OK`。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOIP2020] 移球游戏", "background": "", "description": "小 C 正在玩一个移球游戏，他面前有 $n + 1$ 根柱子，柱子从 $1 \\sim n + 1$ 编号，其中 $1$ 号柱子、$2$ 号柱子、……、$n$ 号柱子上各有 $m$ 个球，它们自底向上放置在柱子上，$n + 1$ 号柱子上初始时没有球。这 $n \\times m$ 个球共有 $n$ 种颜色，每种颜色的球各 $m$ 个。\n\n初始时一根柱子上的球可能是五颜六色的，而小 C 的任务是将所有同种颜色的球移到同一根柱子上，这是唯一的目标，而每种颜色的球最后放置在哪根柱子则没有限制。\n\n小 C 可以通过若干次操作完成这个目标，一次操作能将一个球从一根柱子移到另一根柱子上。更具体地，将 $x$ 号柱子上的球移动到 $y$ 号柱子上的要求为：\n\n1. $x$ 号柱子上至少有一个球；\n2. $y$ 号柱子上至多有 $m - 1$ 个球；\n3. 只能将 $x$ 号柱子最上方的球移到 $y$ 号柱子的最上方。\n\n小 C 的目标并不难完成，因此他决定给自己加加难度：在完成目标的基础上，使用的操作次数不能超过 $820000$。换句话说，小 C 需要使用至多 $820000$ 次操作完成目标。\n\n小 C 被难住了，但他相信难不倒你，请你给出一个操作方案完成小 C 的目标。合法的方案可能有多种，你只需要给出任意一种，题目保证一定存在一个合法方案。", "inputFormat": "第一行两个用空格分隔的整数 $n, m$。分别表示球的颜色数、每种颜色球的个数。  \n接下来 $n$ 行每行 $m$ 个用单个空格分隔的整数，第 $i$ 行的整数按自底向上的顺序依次给出了 $i$ 号柱子上的球的颜色。", "outputFormat": "本题采用自定义校验器（special judge）评测。  \n你的输出的第一行应该仅包含单个整数 $k$，表示你的方案的操作次数。你应保证 $0 \\le k \\le 820000$。  \n接下来 $k$ 行每行你应输出两个用单个空格分隔的正整数 $x, y$，表示这次操作将 $x$ 号柱子最上方的球移动到 $y$ 号柱子最上方。你应保证 $1 \\le x, y \\le n + 1$ 且 $x \\ne y$。", "hint": "**【样例 #1 解释】**\n\n柱子中的内容为：按自底向上的顺序依次给出柱子上每个球的颜色。\n\n| 操作 | $1$ 号柱子 | $2$ 号柱子 | $3$ 号柱子 |\n|:-:|:-:|:-:|:-:|\n| 初始 | $1\\ 1\\ 2$ | $2\\ 1\\ 2$ | |\n| $1\\ 3$ | $1\\ 1$ | $2\\ 1\\ 2$ | $2$ |\n| $2\\ 3$ | $1\\ 1$ | $2\\ 1$ | $2\\ 2$ |\n| $2\\ 3$ | $1\\ 1$ | $2$ | $2\\ 2\\ 1$ |\n| $3\\ 1$ | $1\\ 1\\ 1$ | $2$ | $2\\ 2$ |\n| $3\\ 2$ | $1\\ 1\\ 1$ | $2\\ 2$ | $2$ |\n| $3\\ 2$ | $1\\ 1\\ 1$ | $2\\ 2\\ 2$ | |\n\n**【数据范围】**\n\n| 测试点编号 | $n \\le$ | $m \\le$ |\n|:-:|:-:|:-:|\n| $1 \\sim 2$ | $2$ | $20$ |\n| $3 \\sim 5$ | $10$ | $20$ |\n| $6 \\sim 8$ | $50$ | $85$ |\n| $9 \\sim 14$ | $50$ | $300$ |\n| $15 \\sim 20$ | $50$ | $400$ |\n\n对于所有测试点，保证 $2 \\le n \\le 50$，$2 \\le m \\le 400$。\n\n**【校验器】**\n\n为了方便选手测试，在附件中的 `ball` 目录下我们下发了 `checker.cpp` 文件，选手可以编译该程序，并使用它校验自己的输出文件。但请注意它与最终评测时所使用的校验器并不完全一致。你也不需要关心其代码的具体内容。\n\n编译命令为：`g++ checker.cpp −o checker -std=c++11`。\n\n`checker` 的使用方式为：`checker <inputfile> <outputfile>`，参数依次表示输入文件与你的输出文件。\n\n若你输出的数字大小范围不合法，则校验器会给出相应提示。若你的输出数字大小范围正确，但方案错误，则校验器会给出简要的错误信息：\n\n1. `A x`，表示进行到第 $x$ 个操作时不合法。\n2. `B x`，表示操作执行完毕后第 $x$ 个柱子上的球不合法。\n\n若你的方案正确，校验器会给出 `OK`。", "locale": "zh-CN"}}}
{"pid": "P7116", "type": "P", "difficulty": 6, "samples": [["3 2\n3 3\n1 1\n2 -1\n1 1\n", "21\n"], ["5 4\n6 8 6 5\n3 1\n2 1\n1 1\n2 1\n2 -1\n", "10265\n"], ["见附件中的 walk/walk3.in", "见附件中的 walk/walk3.ans"], ["见附件中的 walk/walk4.in", "见附件中的 walk/walk4.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2020", "NOIP 提高组", "拉格朗日插值法"], "title": "[NOIP2020] 微信步数", "background": "", "description": "小 C 喜欢跑步，并且非常喜欢在微信步数排行榜上刷榜，为此他制定了一个刷微信步数的计划。\n\n他来到了一处空旷的场地，处于该场地中的人可以用 $k$ 维整数坐标 $(a_1, a_2, \\ldots , a_k)$ 来表示其位置。场地有大小限制，第 $i$ 维的大小为 $w_i$，因此处于场地中的人其坐标应满足 $1 \\le a_i \\le w_i$（$1 \\le i \\le k$）。\n\n小 C 打算在接下来的 $P = w_1 \\times w_2 \\times \\cdots \\times w_k$ 天中，每天从场地中一个新的位置出发，开始他的刷步数计划（换句话说，他将会从场地中每个位置都出发一次进行计划）。\n\n他的计划非常简单，每天按照事先规定好的路线行进，每天的路线由 $n$ 步移动构成，每一步可以用 $c_i$ 与 $d_i$ 表示：若他当前位于 $(a_1, a_2, \\ldots , a_{c_i}, \\ldots, a_k)$，则这一步他将会走到 $(a_1, a_2, \\ldots , a_{c_i} + d_i, \\ldots , a_k)$，其中 $1 \\le c_i \\le k$，$d_i \\in \\{-1, 1\\}$。小 C 将会不断重复这个路线，直到他走出了场地的范围才结束一天的计划。（即走完第 $n$ 步后，若小 C 还在场内，他将回到第 $1$ 步从头再走一遍）。\n\n小 C 对自己的速度非常有自信，所以他并不在意具体耗费的时间，他只想知道 $P$ 天之后，他一共刷出了多少步微信步数。请你帮他算一算。", "inputFormat": "第一行两个用单个空格分隔的整数 $n, k$。分别表示路线步数与场地维数。  \n接下来一行 $k$ 个用单个空格分隔的整数 $w_i$，表示场地大小。  \n接下来 $n$ 行每行两个用单个空格分隔的整数 $c_i, d_i$，依次表示每一步的方向，具体意义见题目描述。", "outputFormat": "仅一行一个整数表示答案。答案可能很大，你只需要输出其对 ${10}^9 + 7$ 取模后的值。  \n若小 C 的计划会使得他在某一天在场地中永远走不出来，则输出一行一个整数 $-1$。", "hint": "**【样例 #1 解释】**\n\n从 $(1, 1)$ 出发将走 $2$ 步，从 $(1, 2)$ 出发将走 $4$ 步，从 $(1, 3)$ 出发将走 $4$ 步。  \n从 $(2, 1)$ 出发将走 $2$ 步，从 $(2, 2)$ 出发将走 $3$ 步，从 $(2, 3)$ 出发将走 $3$ 步。  \n从 $(3, 1)$ 出发将走 $1$ 步，从 $(3, 2)$ 出发将走 $1$ 步，从 $(3, 3)$ 出发将走 $1$ 步。  \n共计 $21$ 步。\n\n**【数据范围】**\n\n| 测试点编号 | $n \\le$ | $k \\le$ | $w_i \\le$ |\n|:-:|:-:|:-:|:-:|\n| $1 \\sim 3$ | $5$ | $5$ | $3$ |\n| $4 \\sim 6$ | $100$ | $3$ | $10$ |\n| $7 \\sim 8$ | ${10}^5$ | $1$ | ${10}^5$ |\n| $9 \\sim 12$ | ${10}^5$ | $2$ | ${10}^6$ |\n| $13 \\sim 16$ | $5 \\times {10}^5$ | $10$ | ${10}^6$ |\n| $17 \\sim 20$ | $5 \\times {10}^5$ | $3$ | ${10}^9$ |\n\n对于所有测试点，保证 $1 \\le n \\le 5 \\times {10}^5$，$1 \\le k \\le 10$，$1 \\le w_i \\le {10}^9$，$d_i \\in \\{-1, 1\\}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOIP2020] 微信步数", "background": "", "description": "小 C 喜欢跑步，并且非常喜欢在微信步数排行榜上刷榜，为此他制定了一个刷微信步数的计划。\n\n他来到了一处空旷的场地，处于该场地中的人可以用 $k$ 维整数坐标 $(a_1, a_2, \\ldots , a_k)$ 来表示其位置。场地有大小限制，第 $i$ 维的大小为 $w_i$，因此处于场地中的人其坐标应满足 $1 \\le a_i \\le w_i$（$1 \\le i \\le k$）。\n\n小 C 打算在接下来的 $P = w_1 \\times w_2 \\times \\cdots \\times w_k$ 天中，每天从场地中一个新的位置出发，开始他的刷步数计划（换句话说，他将会从场地中每个位置都出发一次进行计划）。\n\n他的计划非常简单，每天按照事先规定好的路线行进，每天的路线由 $n$ 步移动构成，每一步可以用 $c_i$ 与 $d_i$ 表示：若他当前位于 $(a_1, a_2, \\ldots , a_{c_i}, \\ldots, a_k)$，则这一步他将会走到 $(a_1, a_2, \\ldots , a_{c_i} + d_i, \\ldots , a_k)$，其中 $1 \\le c_i \\le k$，$d_i \\in \\{-1, 1\\}$。小 C 将会不断重复这个路线，直到他走出了场地的范围才结束一天的计划。（即走完第 $n$ 步后，若小 C 还在场内，他将回到第 $1$ 步从头再走一遍）。\n\n小 C 对自己的速度非常有自信，所以他并不在意具体耗费的时间，他只想知道 $P$ 天之后，他一共刷出了多少步微信步数。请你帮他算一算。", "inputFormat": "第一行两个用单个空格分隔的整数 $n, k$。分别表示路线步数与场地维数。  \n接下来一行 $k$ 个用单个空格分隔的整数 $w_i$，表示场地大小。  \n接下来 $n$ 行每行两个用单个空格分隔的整数 $c_i, d_i$，依次表示每一步的方向，具体意义见题目描述。", "outputFormat": "仅一行一个整数表示答案。答案可能很大，你只需要输出其对 ${10}^9 + 7$ 取模后的值。  \n若小 C 的计划会使得他在某一天在场地中永远走不出来，则输出一行一个整数 $-1$。", "hint": "**【样例 #1 解释】**\n\n从 $(1, 1)$ 出发将走 $2$ 步，从 $(1, 2)$ 出发将走 $4$ 步，从 $(1, 3)$ 出发将走 $4$ 步。  \n从 $(2, 1)$ 出发将走 $2$ 步，从 $(2, 2)$ 出发将走 $3$ 步，从 $(2, 3)$ 出发将走 $3$ 步。  \n从 $(3, 1)$ 出发将走 $1$ 步，从 $(3, 2)$ 出发将走 $1$ 步，从 $(3, 3)$ 出发将走 $1$ 步。  \n共计 $21$ 步。\n\n**【数据范围】**\n\n| 测试点编号 | $n \\le$ | $k \\le$ | $w_i \\le$ |\n|:-:|:-:|:-:|:-:|\n| $1 \\sim 3$ | $5$ | $5$ | $3$ |\n| $4 \\sim 6$ | $100$ | $3$ | $10$ |\n| $7 \\sim 8$ | ${10}^5$ | $1$ | ${10}^5$ |\n| $9 \\sim 12$ | ${10}^5$ | $2$ | ${10}^6$ |\n| $13 \\sim 16$ | $5 \\times {10}^5$ | $10$ | ${10}^6$ |\n| $17 \\sim 20$ | $5 \\times {10}^5$ | $3$ | ${10}^9$ |\n\n对于所有测试点，保证 $1 \\le n \\le 5 \\times {10}^5$，$1 \\le k \\le 10$，$1 \\le w_i \\le {10}^9$，$d_i \\in \\{-1, 1\\}$。", "locale": "zh-CN"}}}
{"pid": "P7117", "type": "P", "difficulty": 4, "samples": [["3\n2 3 3\n", "simple\n2\n2 1\n1 1\n"], ["3\n97 109 101\n", "simple\n2\n54 42\n47 55\n"], ["9\n9 9 8 2 4 4 3 5 3\n", "nice\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2020", "Special Judge", "O2优化", "构造"], "title": "Mivik 卷积", "background": "卷王之王卷穿肠（doge", "description": "从前有一只 Mivik，他喜欢卷积。他定义两个仅与 $x$ 有关的多项式函数 $f\\left(x\\right)$ 和 $g\\left(x\\right)$ 的 Mivik 卷积如下：\n\n$$\nf\\left(x\\right)\\otimes g\\left(x\\right)=\\sum_{k=0}^{\\deg f +\\deg g}\\max_{i\\in [0,\\deg f] \\land j\\in [0,\\deg g]\\land i+j=k}\\left\\{\\left[x^i\\right]f\\left(x\\right)+\\left[x^j\\right]g\\left(x\\right)\\right\\} x^k\n$$\n\n其中 $\\deg f$ 表示 $f$ 的最高项次数，$\\left[x^i\\right]f\\left(x\\right)$ 代表 $f\\left(x\\right)$ 这一函数中 $x^i$ 这一项的系数。\n\n请注意，Mivik 卷积是左结合的，也就是说 $a\\otimes b\\otimes c=(a\\otimes b)\\otimes c$。\n\nMivik 定义 Mivik 函数为能表示为 $f\\left(x\\right)=ax+b$ 形式的函数，其中 $a$、$b$ 均为整数。例如 $f\\left(x\\right)=-3+2x$ 是 Mivik 函数，而 $f\\left(x\\right)=\\frac{1}{x}$ 不是。\n\nMivik 又定义一个函数 $f\\left(x\\right)$ 是 simple 的，当且仅当存在一个 Mivik 函数的序列 $S$（大小为 $\\left|S\\right|$），使得：\n\n$$\nf\\left(x\\right)=S_1\\otimes S_2\\otimes S_3\\otimes\\cdots\\otimes S_{\\left|S\\right|}.\n$$\n\n现在 Mivik 给了你一个多项式函数，问你这个函数是不是 simple 的；如果是，请顺便告诉他任意一种可能的 $S$。", "inputFormat": "第一行一个正整数 $n$，代表这个多项式函数的项数。\n\n第二行 $n$ 个整数，次数从低到高依次代表这个多项式函数的系数 $f_i$。保证最高项系数不为 $0$。", "outputFormat": "如果这个函数不是 simple 的，输出一行 `nice`。\n\n否则，先输出一行 `simple`，然后接下来一行输出你构造的 $S$ 的大小 $\\left|S\\right|$。接下来在 $\\left|S\\right|$ 行给出你构造的 $S$ 序列，每行两个整数 $a$ 和 $b$，描述一个 Mivik 函数 $f\\left(x\\right)=ax+b$。", "hint": "### 样例解释 #1\n\n给定的函数 $f\\left(x\\right)=2+3x+3x^2$ 可以由 $\\left(2x+1\\right)\\otimes\\left(x+1\\right)$ 得到。\n\n### 测试点约束\n\n**本题采用捆绑测试。**\n\n对于全部数据，有 $1\\le n\\le 5\\times 10^5$，$-10^8\\le f_i\\le 10^8$。\n\n每个子任务的具体限制见下表：\n\n| 子任务编号 | 分值 | $n\\le$ |\n|:-:|:-:|:-:|\n| 1 | 5 | $1$ |\n| 2 | 5 | $2$ |\n| 3 | 20 | $20$ |\n| 4 | 30 | $5000$ |\n| 5 | 40 | $5\\times 10^5$ |\n\n**本题读入输出量较大，请使用较快的读入输出方式。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Mivik 卷积", "background": "卷王之王卷穿肠（doge", "description": "从前有一只 Mivik，他喜欢卷积。他定义两个仅与 $x$ 有关的多项式函数 $f\\left(x\\right)$ 和 $g\\left(x\\right)$ 的 Mivik 卷积如下：\n\n$$\nf\\left(x\\right)\\otimes g\\left(x\\right)=\\sum_{k=0}^{\\deg f +\\deg g}\\max_{i\\in [0,\\deg f] \\land j\\in [0,\\deg g]\\land i+j=k}\\left\\{\\left[x^i\\right]f\\left(x\\right)+\\left[x^j\\right]g\\left(x\\right)\\right\\} x^k\n$$\n\n其中 $\\deg f$ 表示 $f$ 的最高项次数，$\\left[x^i\\right]f\\left(x\\right)$ 代表 $f\\left(x\\right)$ 这一函数中 $x^i$ 这一项的系数。\n\n请注意，Mivik 卷积是左结合的，也就是说 $a\\otimes b\\otimes c=(a\\otimes b)\\otimes c$。\n\nMivik 定义 Mivik 函数为能表示为 $f\\left(x\\right)=ax+b$ 形式的函数，其中 $a$、$b$ 均为整数。例如 $f\\left(x\\right)=-3+2x$ 是 Mivik 函数，而 $f\\left(x\\right)=\\frac{1}{x}$ 不是。\n\nMivik 又定义一个函数 $f\\left(x\\right)$ 是 simple 的，当且仅当存在一个 Mivik 函数的序列 $S$（大小为 $\\left|S\\right|$），使得：\n\n$$\nf\\left(x\\right)=S_1\\otimes S_2\\otimes S_3\\otimes\\cdots\\otimes S_{\\left|S\\right|}.\n$$\n\n现在 Mivik 给了你一个多项式函数，问你这个函数是不是 simple 的；如果是，请顺便告诉他任意一种可能的 $S$。", "inputFormat": "第一行一个正整数 $n$，代表这个多项式函数的项数。\n\n第二行 $n$ 个整数，次数从低到高依次代表这个多项式函数的系数 $f_i$。保证最高项系数不为 $0$。", "outputFormat": "如果这个函数不是 simple 的，输出一行 `nice`。\n\n否则，先输出一行 `simple`，然后接下来一行输出你构造的 $S$ 的大小 $\\left|S\\right|$。接下来在 $\\left|S\\right|$ 行给出你构造的 $S$ 序列，每行两个整数 $a$ 和 $b$，描述一个 Mivik 函数 $f\\left(x\\right)=ax+b$。", "hint": "### 样例解释 #1\n\n给定的函数 $f\\left(x\\right)=2+3x+3x^2$ 可以由 $\\left(2x+1\\right)\\otimes\\left(x+1\\right)$ 得到。\n\n### 测试点约束\n\n**本题采用捆绑测试。**\n\n对于全部数据，有 $1\\le n\\le 5\\times 10^5$，$-10^8\\le f_i\\le 10^8$。\n\n每个子任务的具体限制见下表：\n\n| 子任务编号 | 分值 | $n\\le$ |\n|:-:|:-:|:-:|\n| 1 | 5 | $1$ |\n| 2 | 5 | $2$ |\n| 3 | 20 | $20$ |\n| 4 | 30 | $5000$ |\n| 5 | 40 | $5\\times 10^5$ |\n\n**本题读入输出量较大，请使用较快的读入输出方式。**", "locale": "zh-CN"}}}
{"pid": "P7118", "type": "P", "difficulty": 5, "samples": [["3\n0 2\n3 0\n0 0\n", "4\n"], ["7\n2 3\n4 5\n6 7\n0 0\n0 0\n0 0\n0 0\n", "410\n"], ["9\n2 3\n4 5\n0 0\n0 0\n6 7\n0 0\n8 9\n0 0\n0 0\n", "5206\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "O2优化", "组合数学", "Catalan 数"], "title": "Galgame", "background": "众所周知，as_lky 喜欢 Galgame。", "description": "as_lky 搞到了很多 Galgame（真的很多！）。一款 Galgame 可以被描述为很多场景（Scene）的结合，它们形成了一棵 **以 1 为根** 的二叉树，每一个结点都是一个场景，一个结点的左儿子和右儿子分别对应在该场景选 A 选项和 B 选项能够到达的场景（可能会到达空场景，即游戏结束），我们称其为 A 场景和 B 场景。\n\nas_lky 如下定义了两个不同的 Galgame 场景哪个更有趣（两款 Galgame 谁更为有趣也就取决于它们的初始场景谁更有趣）：\n\n1. 如果这两个场景能够到达的场景总数（即通过任意选择能够到达的不同场景总数，包括该场景本身）不一样，那么能到达的场景数更多的那个更有趣；\n2. 如果这两个场景的 A 场景不一样有趣，那么 A 场景更有趣的场景更有趣；\n3. 否则这两个场景谁更有趣完全等价于他们 B 场景谁更有趣。\n\n值得注意的是，空场景能到达的场景数被定义为 0。\n\n![示例](https://cdn.luogu.com.cn/upload/image_hosting/4d2208qd.png)\n\n例如，对于上图给出的例子（若无法正常查看请 `右键 -> 查看图像`），我们这样判定 1 和 7 这两个场景谁更有趣：\n\n- 首先，1 和 7 能到达的场景数都是 6，因此我们首先尝试比较其 A 场景：2 和 8。\n- 由于 2 和 8 能到达的场景数不同（分别是 3 和 2），则 2 场景比 8 场景更有趣；继而可以得到 1 场景比 7 场景更有趣。\n\nas_lky 定义两个 Galgame 场景本质相同，当且仅当这两个场景都为空场景，或者它们的 A 场景本质相同且 B 场景本质相同。\n\nas_lky 认为一款 Galgame 的有趣度是所有可能的、本质不同的、不及这款 Galgame 有趣的 Galgame 数量。现在 as_lky 给了你一款 Galgame，请告诉他这款 Galgame 的有趣度是多少。as_lky 觉得这个数字可能有些大，所以他想让你输出这个数字对 $998244353$ 取模的结果。", "inputFormat": "第一行一个正整数 $n$，代表这款 Galgame 中共有多少场景。\n\n接下来 $n$ 行，每行两个非负整数 $a_i$ 和 $b_i$，分别代表该场景的 A 场景和 B 场景，0 代表空场景。保证数据合法。", "outputFormat": "一行一个非负整数，代表有趣度对 $998244353$ 取模的结果。", "hint": "### 样例解释\n\n样例一：下图分别给出了 as_lky 给你的 Galgame（左）和所有四种没有该 Galgame 有趣的 Galgame（右）：（若无法正常查看请 `右键 -> 查看图像`）\n\n![示例](https://cdn.luogu.com.cn/upload/image_hosting/oxer1eac.png)\n\n### 测试点约束\n\n**本题采用捆绑测试。**\n\n对于全部数据，有 $1\\le n\\le 10^6$，$0\\le a_i,b_i\\le n$。\n\n每个子任务的具体限制见下表：\n\n| 子任务编号 | 分值 | $n\\le$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|\n| 1 | 10 | $10$ | $\\times$ |\n| 2 | 20 | $5000$ | $\\times$ |\n| 3 | 30 | $10^6$ | $\\surd$ |\n| 4 | 40 | $10^6$ | $\\times$ |\n\n特殊性质：保证数据均匀随机生成，即 $n$ 给定时，若所有场景数为 $n$ 的本质不同 Galgame 共有 $S$ 种，则每种本质不同的 Galgame 出现概率均为 $\\frac{1}{S}$。\n\n**本题读入量较大，请使用较快的读入方式。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Galgame", "background": "众所周知，as_lky 喜欢 Galgame。", "description": "as_lky 搞到了很多 Galgame（真的很多！）。一款 Galgame 可以被描述为很多场景（Scene）的结合，它们形成了一棵 **以 1 为根** 的二叉树，每一个结点都是一个场景，一个结点的左儿子和右儿子分别对应在该场景选 A 选项和 B 选项能够到达的场景（可能会到达空场景，即游戏结束），我们称其为 A 场景和 B 场景。\n\nas_lky 如下定义了两个不同的 Galgame 场景哪个更有趣（两款 Galgame 谁更为有趣也就取决于它们的初始场景谁更有趣）：\n\n1. 如果这两个场景能够到达的场景总数（即通过任意选择能够到达的不同场景总数，包括该场景本身）不一样，那么能到达的场景数更多的那个更有趣；\n2. 如果这两个场景的 A 场景不一样有趣，那么 A 场景更有趣的场景更有趣；\n3. 否则这两个场景谁更有趣完全等价于他们 B 场景谁更有趣。\n\n值得注意的是，空场景能到达的场景数被定义为 0。\n\n![示例](https://cdn.luogu.com.cn/upload/image_hosting/4d2208qd.png)\n\n例如，对于上图给出的例子（若无法正常查看请 `右键 -> 查看图像`），我们这样判定 1 和 7 这两个场景谁更有趣：\n\n- 首先，1 和 7 能到达的场景数都是 6，因此我们首先尝试比较其 A 场景：2 和 8。\n- 由于 2 和 8 能到达的场景数不同（分别是 3 和 2），则 2 场景比 8 场景更有趣；继而可以得到 1 场景比 7 场景更有趣。\n\nas_lky 定义两个 Galgame 场景本质相同，当且仅当这两个场景都为空场景，或者它们的 A 场景本质相同且 B 场景本质相同。\n\nas_lky 认为一款 Galgame 的有趣度是所有可能的、本质不同的、不及这款 Galgame 有趣的 Galgame 数量。现在 as_lky 给了你一款 Galgame，请告诉他这款 Galgame 的有趣度是多少。as_lky 觉得这个数字可能有些大，所以他想让你输出这个数字对 $998244353$ 取模的结果。", "inputFormat": "第一行一个正整数 $n$，代表这款 Galgame 中共有多少场景。\n\n接下来 $n$ 行，每行两个非负整数 $a_i$ 和 $b_i$，分别代表该场景的 A 场景和 B 场景，0 代表空场景。保证数据合法。", "outputFormat": "一行一个非负整数，代表有趣度对 $998244353$ 取模的结果。", "hint": "### 样例解释\n\n样例一：下图分别给出了 as_lky 给你的 Galgame（左）和所有四种没有该 Galgame 有趣的 Galgame（右）：（若无法正常查看请 `右键 -> 查看图像`）\n\n![示例](https://cdn.luogu.com.cn/upload/image_hosting/oxer1eac.png)\n\n### 测试点约束\n\n**本题采用捆绑测试。**\n\n对于全部数据，有 $1\\le n\\le 10^6$，$0\\le a_i,b_i\\le n$。\n\n每个子任务的具体限制见下表：\n\n| 子任务编号 | 分值 | $n\\le$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|\n| 1 | 10 | $10$ | $\\times$ |\n| 2 | 20 | $5000$ | $\\times$ |\n| 3 | 30 | $10^6$ | $\\surd$ |\n| 4 | 40 | $10^6$ | $\\times$ |\n\n特殊性质：保证数据均匀随机生成，即 $n$ 给定时，若所有场景数为 $n$ 的本质不同 Galgame 共有 $S$ 种，则每种本质不同的 Galgame 出现概率均为 $\\frac{1}{S}$。\n\n**本题读入量较大，请使用较快的读入方式。**", "locale": "zh-CN"}}}
{"pid": "P7119", "type": "P", "difficulty": 5, "samples": [["2 2\nTT\n2 2\n1 2\n", "2\n1\n3\n"], ["5 0\nHTHTH\n", "8\n"], ["10 10\nHTHHTHTHHH\n9 9\n5 5\n10 10\n7 7\n6 6\n9 9\n4 4\n9 9\n7 7\n2 2\n", "19\n30\n27\n40\n33\n38\n27\n28\n37\n40\n47\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "2020", "线段树", "O2优化"], "title": "Mivik 的游戏", "background": "Mivik 和 W!ʌ!k 在玩游戏！", "description": "Mivik 首先把 $n$ 枚硬币摆成一排，其中有一些正面朝上，其余的都是反面朝上。W!ʌ!k 打算不断执行以下操作直到这 $n$ 枚硬币中没有硬币反面朝上：\n\n- 如果现在这 $n$ 枚硬币中有 $k$ 枚硬币反面朝上，那么翻转从左到右第 $k$ 枚硬币。具体地，如果从左到右第 $k$ 枚硬币正面朝上，则将其变为反面朝上；如果从左到右第 $k$ 枚硬币反面朝上，则将其变为正面朝上。\n\n在 W!ʌ!k 开始玩游戏之前，Mivik 想考考 W!ʌ!k。Mivik 想让 W!ʌ!k 算出他总共会进行多少次这样的操作，或者是 W!ʌ!k 永远无法停止执行操作。\n\nW!ʌ!k 很快解决了这个问题，但是心理比 yky 还变态的 Mivik 显然不会放过他。Mivik 进行了很多次操作，每次他翻转了一个区间的硬币，他要求 W!ʌ!k 算出他总共会进行多少次这样的操作，或者是 W!ʌ!k 永远无法停止执行操作。\n\n**请注意，W!ʌ!k 只是需要计算总共会进行多少次操作，而不会真正进行操作。**", "inputFormat": "输入共 $\\left(m+2\\right)$ 行。\n\n第一行为两个非负整数 $n,m$，其中 $n$ 表示 Mivik 的硬币的个数，$m$ 表示 Mivik 进行的翻转操作的次数。\n\n第二行为一个只包含有 $\\texttt H$ 和 $\\texttt T$ 的字符串。第 $i$ 个字符 $s_i$ 为 $\\texttt H$ 则表示从左到右第 $i$ 枚硬币初始时是正面朝上；$s_i$ 为 $\\texttt T$ 则表示从左到右第 $i$ 枚硬币初始时是反面朝上。\n\n接下来 $m$ 行，每行两个正整数 $l_i,r_i$，表示 Mivik 翻转了从左到右数 $l_i\\sim r_i$（包括 $l_i$ 和 $r_i$）的硬币。", "outputFormat": "输出 $\\left(m+1\\right)$ 行，分别表示在真正执行操作前后共 $\\left(m+1\\right)$ 个时刻开始 W!ʌ!k 总共会进行多少次这样的操作，或者是 W!ʌ!k 永远无法停止执行操作。如果某一时刻 W!ʌ!k 不能停止执行操作，则在对应行输出字符串 $\\texttt{never}$。", "hint": "### 样例解释 #1\n初始时两枚硬币都是反面朝上，因此如果 W!ʌ!k 从此刻开始执行操作， W!ʌ!k 会将编号为 $2$ 的硬币翻转过来。操作后只有一枚硬币反面朝上，因此第 $2$ 次操作会将编号为 $1$ 的硬币翻转过来。在第 $2$ 次操作后没有硬币反面朝上，因此 W!ʌ!k 不会再执行操作，总共会执行 $2$ 次操作。\n\n### 样例解释 #2\n这 $8$ 次操作分别翻转了第 $2,1,2,3,4,3,2,1$ 枚硬币。\n\n### 测试点约束\n**本题采用捆绑测试。**\n\n对于全部数据，有 $1\\le n,m\\le10^6$，$s_i\\in\\left\\{\\texttt H,\\texttt T\\right\\}$，$1\\le l_i\\le r_i\\le n$。\n\n每个子任务的具体限制见下表：\n\n| 子任务编号 | 分值 | 特殊限制 |\n|:-:|:-:|:-:|\n| 1 | 10 | $n\\le3$ |\n| 2 | 20 | $n,m\\le100$ |\n| 3 | 30 | $m\\le10$ |\n| 4 | 20 | $l_i=r_i$ |\n| 5 | 20 | 无 |\n\n**本题读入输出量较大，请使用较快的读入输出方式。**", "locale": "zh-CN", "translations": {"en": {"title": "Mivik's Game", "background": "Mivik and W!ʌ!k are playing a game.", "description": "Mivik first places $n$ coins in a row. Some are face up and the rest are face down. W!ʌ!k plans to repeatedly perform the following operation until none of the $n$ coins is face down:\n\n- If there are currently $k$ coins that are face down among the $n$ coins, then flip the $k$-th coin from left to right. Specifically, if the $k$-th coin from left to right is face up, change it to face down; if it is face down, change it to face up.\n\nBefore W!ʌ!k starts playing, Mivik wants to test W!ʌ!k. Mivik wants W!ʌ!k to compute how many such operations he will perform in total, or whether W!ʌ!k will never be able to stop performing operations.\n\nW!ʌ!k solved this problem quickly, but Mivik, whose mindset is even more twisted than yky's, obviously would not let him off. Mivik performs many flips: each time, he flips an interval of coins, and he requires W!ʌ!k to compute how many such operations W!ʌ!k will perform in total, or whether W!ʌ!k will never be able to stop performing operations.\n\n**Note that W!ʌ!k only needs to compute how many operations will be performed in total, and will not actually perform the operations.**", "inputFormat": "The input has $\\left(m+2\\right)$ lines.\n\nThe first line contains two non-negative integers $n,m$, where $n$ is the number of Mivik's coins, and $m$ is the number of interval-flip operations performed by Mivik.\n\nThe second line is a string consisting only of $\\texttt H$ and $\\texttt T$. If the $i$-th character $s_i$ is $\\texttt H$, it means the $i$-th coin from left to right is initially face up; if $s_i$ is $\\texttt T$, it means the $i$-th coin from left to right is initially face down.\n\nThe next $m$ lines each contain two positive integers $l_i,r_i$, meaning Mivik flipped the coins from positions $l_i$ to $r_i$ (inclusive) from left to right.", "outputFormat": "Output $\\left(m+1\\right)$ lines. They represent, at the $\\left(m+1\\right)$ moments (before actually performing any of Mivik's flips, and after each of the $m$ flips), how many such operations W!ʌ!k would perform in total if he starts at that moment, or whether W!ʌ!k will never be able to stop performing operations. If at some moment W!ʌ!k cannot stop performing operations, output the string $\\texttt{never}$ on the corresponding line.", "hint": "### Sample Explanation #1\nInitially, both coins are face down, so if W!ʌ!k starts performing operations from this moment, he will flip coin $2$. After that, only one coin is face down, so the second operation will flip coin $1$. After the second operation, no coin is face down, so W!ʌ!k will not perform any more operations, and he will perform $2$ operations in total.\n\n### Sample Explanation #2\nThese $8$ operations flip coins $2,1,2,3,4,3,2,1$, respectively.\n\n### Test Point Constraints\n**This problem uses bundled tests.**\n\nFor all data, $1\\le n,m\\le10^6$, $s_i\\in\\left\\{\\texttt H,\\texttt T\\right\\}$, $1\\le l_i\\le r_i\\le n$.\n\nThe specific limits for each subtask are shown in the table below:\n\n| Subtask ID | Score | Special Constraints |\n|:-:|:-:|:-:|\n| 1 | 10 | $n\\le3$ |\n| 2 | 20 | $n,m\\le100$ |\n| 3 | 30 | $m\\le10$ |\n| 4 | 20 | $l_i=r_i$ |\n| 5 | 20 | None. |\n\n**The input and output size of this problem is large, so please use fast I/O.**\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Mivik 的游戏", "background": "Mivik 和 W!ʌ!k 在玩游戏！", "description": "Mivik 首先把 $n$ 枚硬币摆成一排，其中有一些正面朝上，其余的都是反面朝上。W!ʌ!k 打算不断执行以下操作直到这 $n$ 枚硬币中没有硬币反面朝上：\n\n- 如果现在这 $n$ 枚硬币中有 $k$ 枚硬币反面朝上，那么翻转从左到右第 $k$ 枚硬币。具体地，如果从左到右第 $k$ 枚硬币正面朝上，则将其变为反面朝上；如果从左到右第 $k$ 枚硬币反面朝上，则将其变为正面朝上。\n\n在 W!ʌ!k 开始玩游戏之前，Mivik 想考考 W!ʌ!k。Mivik 想让 W!ʌ!k 算出他总共会进行多少次这样的操作，或者是 W!ʌ!k 永远无法停止执行操作。\n\nW!ʌ!k 很快解决了这个问题，但是心理比 yky 还变态的 Mivik 显然不会放过他。Mivik 进行了很多次操作，每次他翻转了一个区间的硬币，他要求 W!ʌ!k 算出他总共会进行多少次这样的操作，或者是 W!ʌ!k 永远无法停止执行操作。\n\n**请注意，W!ʌ!k 只是需要计算总共会进行多少次操作，而不会真正进行操作。**", "inputFormat": "输入共 $\\left(m+2\\right)$ 行。\n\n第一行为两个非负整数 $n,m$，其中 $n$ 表示 Mivik 的硬币的个数，$m$ 表示 Mivik 进行的翻转操作的次数。\n\n第二行为一个只包含有 $\\texttt H$ 和 $\\texttt T$ 的字符串。第 $i$ 个字符 $s_i$ 为 $\\texttt H$ 则表示从左到右第 $i$ 枚硬币初始时是正面朝上；$s_i$ 为 $\\texttt T$ 则表示从左到右第 $i$ 枚硬币初始时是反面朝上。\n\n接下来 $m$ 行，每行两个正整数 $l_i,r_i$，表示 Mivik 翻转了从左到右数 $l_i\\sim r_i$（包括 $l_i$ 和 $r_i$）的硬币。", "outputFormat": "输出 $\\left(m+1\\right)$ 行，分别表示在真正执行操作前后共 $\\left(m+1\\right)$ 个时刻开始 W!ʌ!k 总共会进行多少次这样的操作，或者是 W!ʌ!k 永远无法停止执行操作。如果某一时刻 W!ʌ!k 不能停止执行操作，则在对应行输出字符串 $\\texttt{never}$。", "hint": "### 样例解释 #1\n初始时两枚硬币都是反面朝上，因此如果 W!ʌ!k 从此刻开始执行操作， W!ʌ!k 会将编号为 $2$ 的硬币翻转过来。操作后只有一枚硬币反面朝上，因此第 $2$ 次操作会将编号为 $1$ 的硬币翻转过来。在第 $2$ 次操作后没有硬币反面朝上，因此 W!ʌ!k 不会再执行操作，总共会执行 $2$ 次操作。\n\n### 样例解释 #2\n这 $8$ 次操作分别翻转了第 $2,1,2,3,4,3,2,1$ 枚硬币。\n\n### 测试点约束\n**本题采用捆绑测试。**\n\n对于全部数据，有 $1\\le n,m\\le10^6$，$s_i\\in\\left\\{\\texttt H,\\texttt T\\right\\}$，$1\\le l_i\\le r_i\\le n$。\n\n每个子任务的具体限制见下表：\n\n| 子任务编号 | 分值 | 特殊限制 |\n|:-:|:-:|:-:|\n| 1 | 10 | $n\\le3$ |\n| 2 | 20 | $n,m\\le100$ |\n| 3 | 30 | $m\\le10$ |\n| 4 | 20 | $l_i=r_i$ |\n| 5 | 20 | 无 |\n\n**本题读入输出量较大，请使用较快的读入输出方式。**", "locale": "zh-CN"}}}
{"pid": "P7120", "type": "P", "difficulty": 6, "samples": [["4 16777259\n", "40\n"], ["10 2147483647\n", "17167120\n"], ["10000000 998244353\n", "3414058\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["递推", "2020", "O2优化", "组合数学"], "title": "Chino 的比赛", "background": "", "description": "Chino 想要用现在手里有的 $n$ 道题出成一套模拟赛。一开始，这 $n$ 道题按照由易到难的顺序排列。\n\n但是因为 Chino 是一个可爱的妹子，所以她会将这些题目的顺序打乱。具体地，她会执行恰好奇数次操作，每次操作她会将其中两道题的位置交换。一套可能的模拟赛就是这些题的一个排列。\n\nChino 为了评估一套模拟赛的可爱程度，她定义 $s$ 表示使得开始时的题目顺序变为这套模拟赛的题目顺序的最少操作次数，定义 $t$ 表示开始时与这套模拟赛中位置相同的题目数量，那么这套模拟赛的可爱程度就是 $s/\\left(t+1\\right)$。\n\n按照套路，你现在应该帮 Chino 计算某一套模拟赛的可爱程度。Chino 觉得这不够可爱，所以她想让你计算所有可能的模拟赛的可爱程度的两倍和。可以发现这一定是一个非负整数。为了避免答案过大，你只需要输出其对质数 $p$ 取模后的结果即可。\n\n形式化地，对于置换 $\\pi$，令 $\\nu\\left(\\pi\\right)$ 表示其不动点个数，设 $\\upsilon\\left(\\pi\\right)$ 为其能够被分解成为的最少个数对换乘积的对换数目。设 $n$ 元对称群为 $S_n$，$n$ 元交错群为 $A_n$，求\n$$\n2\\sum_{\\pi\\in S_n\\land\\pi\\notin A_n}\\frac{\\upsilon\\left(\\pi\\right)}{\\nu\\left(\\pi\\right)+1}.\n$$\n\n这一定是一个非负整数。答案对质数 $p$ 取模后输出。", "inputFormat": "输入一行两个正整数 $n,p$。", "outputFormat": "输出一行一个非负整数，表示所有可能的 $n$ 道题的模拟赛的可爱程度之和对 $p$ 取模后的结果。", "hint": "### 样例解释 #1\n四道题的所有可能的模拟赛题目排列顺序有：\n- $\\left\\{1,2,4,3\\right\\}$，可爱程度为 $1/3$；\n- $\\left\\{1,3,2,4\\right\\}$，可爱程度为 $1/3$；\n- $\\left\\{1,4,3,2\\right\\}$，可爱程度为 $1/3$；\n- $\\left\\{2,1,3,4\\right\\}$，可爱程度为 $1/3$；\n- $\\left\\{2,3,4,1\\right\\}$，可爱程度为 $3$；\n- $\\left\\{2,4,1,3\\right\\}$，可爱程度为 $3$；\n- $\\left\\{3,1,4,2\\right\\}$，可爱程度为 $3$；\n- $\\left\\{3,2,1,4\\right\\}$，可爱程度为 $1/3$；\n- $\\left\\{3,4,2,1\\right\\}$，可爱程度为 $3$；\n- $\\left\\{4,1,2,3\\right\\}$，可爱程度为 $3$；\n- $\\left\\{4,2,3,1\\right\\}$，可爱程度为 $1/3$；\n- $\\left\\{4,3,1,2\\right\\}$，可爱程度为 $3$。\n\n### 测试点约束\n**本题采用捆绑测试。**\n\n对于全部数据，有 $1\\le n\\le2\\times10^7$，$2^{25}<p<2^{31}$，$p$ 为质数。\n\t\n每个子任务的具体限制见下表：\n\n| 子任务编号 | 分值 | $n\\le$ | $p=998244353$ |\n|:-:|:-:|:-:|:-:|\n| 1 | 10 | $2\\times10^1$ | $\\times$ |\n| 2 | 10 | $2\\times10^2$ | $\\surd$ |\n| 3 | 10 | $2\\times10^3$ | $\\times$ |\n| 4 | 20 | $2\\times10^4$ | $\\times$ |\n| 5 | 20 | $2\\times10^5$ | $\\surd$ |\n| 6 | 10 | $2\\times10^6$ | $\\surd$ |\n| 7 | 20 | $2\\times10^7$ | $\\times$ |\n\n### 更快的取模\n本题中你可能会执行大量取模操作，因此你可以参考[几种取模优化方法（译自 min-25 的博客）](https://loj.ac/d/327)来提高取模运算的效率。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Chino 的比赛", "background": "", "description": "Chino 想要用现在手里有的 $n$ 道题出成一套模拟赛。一开始，这 $n$ 道题按照由易到难的顺序排列。\n\n但是因为 Chino 是一个可爱的妹子，所以她会将这些题目的顺序打乱。具体地，她会执行恰好奇数次操作，每次操作她会将其中两道题的位置交换。一套可能的模拟赛就是这些题的一个排列。\n\nChino 为了评估一套模拟赛的可爱程度，她定义 $s$ 表示使得开始时的题目顺序变为这套模拟赛的题目顺序的最少操作次数，定义 $t$ 表示开始时与这套模拟赛中位置相同的题目数量，那么这套模拟赛的可爱程度就是 $s/\\left(t+1\\right)$。\n\n按照套路，你现在应该帮 Chino 计算某一套模拟赛的可爱程度。Chino 觉得这不够可爱，所以她想让你计算所有可能的模拟赛的可爱程度的两倍和。可以发现这一定是一个非负整数。为了避免答案过大，你只需要输出其对质数 $p$ 取模后的结果即可。\n\n形式化地，对于置换 $\\pi$，令 $\\nu\\left(\\pi\\right)$ 表示其不动点个数，设 $\\upsilon\\left(\\pi\\right)$ 为其能够被分解成为的最少个数对换乘积的对换数目。设 $n$ 元对称群为 $S_n$，$n$ 元交错群为 $A_n$，求\n$$\n2\\sum_{\\pi\\in S_n\\land\\pi\\notin A_n}\\frac{\\upsilon\\left(\\pi\\right)}{\\nu\\left(\\pi\\right)+1}.\n$$\n\n这一定是一个非负整数。答案对质数 $p$ 取模后输出。", "inputFormat": "输入一行两个正整数 $n,p$。", "outputFormat": "输出一行一个非负整数，表示所有可能的 $n$ 道题的模拟赛的可爱程度之和对 $p$ 取模后的结果。", "hint": "### 样例解释 #1\n四道题的所有可能的模拟赛题目排列顺序有：\n- $\\left\\{1,2,4,3\\right\\}$，可爱程度为 $1/3$；\n- $\\left\\{1,3,2,4\\right\\}$，可爱程度为 $1/3$；\n- $\\left\\{1,4,3,2\\right\\}$，可爱程度为 $1/3$；\n- $\\left\\{2,1,3,4\\right\\}$，可爱程度为 $1/3$；\n- $\\left\\{2,3,4,1\\right\\}$，可爱程度为 $3$；\n- $\\left\\{2,4,1,3\\right\\}$，可爱程度为 $3$；\n- $\\left\\{3,1,4,2\\right\\}$，可爱程度为 $3$；\n- $\\left\\{3,2,1,4\\right\\}$，可爱程度为 $1/3$；\n- $\\left\\{3,4,2,1\\right\\}$，可爱程度为 $3$；\n- $\\left\\{4,1,2,3\\right\\}$，可爱程度为 $3$；\n- $\\left\\{4,2,3,1\\right\\}$，可爱程度为 $1/3$；\n- $\\left\\{4,3,1,2\\right\\}$，可爱程度为 $3$。\n\n### 测试点约束\n**本题采用捆绑测试。**\n\n对于全部数据，有 $1\\le n\\le2\\times10^7$，$2^{25}<p<2^{31}$，$p$ 为质数。\n\t\n每个子任务的具体限制见下表：\n\n| 子任务编号 | 分值 | $n\\le$ | $p=998244353$ |\n|:-:|:-:|:-:|:-:|\n| 1 | 10 | $2\\times10^1$ | $\\times$ |\n| 2 | 10 | $2\\times10^2$ | $\\surd$ |\n| 3 | 10 | $2\\times10^3$ | $\\times$ |\n| 4 | 20 | $2\\times10^4$ | $\\times$ |\n| 5 | 20 | $2\\times10^5$ | $\\surd$ |\n| 6 | 10 | $2\\times10^6$ | $\\surd$ |\n| 7 | 20 | $2\\times10^7$ | $\\times$ |\n\n### 更快的取模\n本题中你可能会执行大量取模操作，因此你可以参考[几种取模优化方法（译自 min-25 的博客）](https://loj.ac/d/327)来提高取模运算的效率。", "locale": "zh-CN"}}}
{"pid": "P7121", "type": "P", "difficulty": 5, "samples": [["见 sample/1.in", "见 sample/1.out"], ["见 sample/2.in", "见 sample/2.out"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2020", "Special Judge", "O2优化", "逆元"], "title": "Ame 和 Gura 的奇妙探险", "background": "\n#### 鉴于洛谷的 SPJ 编译可能依赖于用户选择的编译器版本，且 SPJ 使用了 C++11，请 C++ 选手使用 C++11 或以上进行提交。\n\n~~Lewdson~~ Watson Amelia 和 Gawr Gura 在玩 Mivicraft。\n\nGura 想将地狱里的交通升级为冰船隧道，但在此之前她先得有一把精准采集的镐子。尝试了一遍又一遍，但终究未能成功的她只好可怜兮兮地找到 Ame。Ame 立刻说道：“So easy! I'll get it in my first try.”\n\n（第一次之后）“Well let's try it again!”\n\n（第二次之后）“Hmmm maybe something's getting wrong today?”\n\n（第三次之后）“I'll give you a ground pound you silly enchanting table!”\n\n（第四次之后）“.. Damn.”\n\n于是 Ame 决定借助一些 技 巧 来拿到精准采集的镐子。她通过查询资料得知 Mivicraft 产生随机数使用了梅森旋转算法（Mersenne Twister，MT19937）。Mivicraft 会通过一个 MT19937 引擎产生一系列的随机数来生成世界的区块。", "description": "Ame 知道，只要她能够找到初始化 MT19937 引擎时使用的种子，她就能够推断出自己如何才能获得一把精准采集的镐子。于是她游历世界，并通过聪明的侦探头脑算出了这个 MT19937 引擎 **刚被初始化后** 生成的 $N$ 个随机数（注：这里的 $N$ 是 MT19937 引擎中的一个参数）。现在她把这 $N$ 个随机数给了你，希望你能够推断出初始化 MT19937 引擎时使用的种子（$0\\le\\text{种子}<2^{32}$）。值得注意的是，Mivicraft 使用的并非标准的 MT19937 引擎，其中的一些参数与论文相比有所改变，Ame 把它们附加到了输入中。请你帮帮 Ame 吧！\n\n好心的 Mivik 为你准备了一份简单易懂的 MT19937 实现，请在附件中查看。", "inputFormat": "第一行 10 个非负整数，分别对应 MT19937 中的 10 个参数：$N$、$M$、$A$、$U$、$S$、$B$、$T$、$C$、$L$ 和 $F$。\n\n接下来 $N$ 行，每行一个非负整数，依次表示 MT19937 引擎刚被初始化后生成的 $N$ 个随机数。", "outputFormat": "一行一个非负整数，代表 MT19937 引擎初始化时使用的种子。数据保证有解，如果有多个解，你只需要输出任意一个即可。", "hint": "### 样例解释 #1\n\n十个参数全部使用标准的 MT19937 参数，种子为 `233333`。也就是说，你可以通过下面的程序产生同样的随机数序列：\n\n```cpp\n#include <iostream>\n#include <random>\n\nstd::mt19937 engine(233333);\nint main() {\n\tfor (int i = 0; i < 624; ++i)\n\t\tstd::cout << engine() << std::endl;\n\treturn 0;\n}\n```\n\n### 测试点约束\n\n**本题采用捆绑测试。**\n\n对于全部数据，有 $10\\le M<N\\le 2\\times 10^5$，$0\\le A,B,C<2^{32}$，$1\\le U,S,T,L\\le 31$，$1\\le F<2^{32}$，保证 $F$ 是奇数。\n\n每个子任务的具体限制见下表：\n\n| 子任务编号 | 分值 | 特殊限制 |\n|:-:|:-:|:-:|\n| 1 | 20 | 种子小于等于 $1000$ |\n| 2 | 30 | $U=S=T=L=16$，$A=B=C=0$ |\n| 3 | 50 | 无 |\n\n**注：下发文件使用 UTF-8 编码，请使用可识别该编码的编辑器打开。**\n\n**附件下载备用链接：[百度网盘](https://pan.baidu.com/s/1ZJQfZK93Qw2lYrDHLQJh2Q) 提取码：jf9e**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Ame 和 Gura 的奇妙探险", "background": "\n#### 鉴于洛谷的 SPJ 编译可能依赖于用户选择的编译器版本，且 SPJ 使用了 C++11，请 C++ 选手使用 C++11 或以上进行提交。\n\n~~Lewdson~~ Watson Amelia 和 Gawr Gura 在玩 Mivicraft。\n\nGura 想将地狱里的交通升级为冰船隧道，但在此之前她先得有一把精准采集的镐子。尝试了一遍又一遍，但终究未能成功的她只好可怜兮兮地找到 Ame。Ame 立刻说道：“So easy! I'll get it in my first try.”\n\n（第一次之后）“Well let's try it again!”\n\n（第二次之后）“Hmmm maybe something's getting wrong today?”\n\n（第三次之后）“I'll give you a ground pound you silly enchanting table!”\n\n（第四次之后）“.. Damn.”\n\n于是 Ame 决定借助一些 技 巧 来拿到精准采集的镐子。她通过查询资料得知 Mivicraft 产生随机数使用了梅森旋转算法（Mersenne Twister，MT19937）。Mivicraft 会通过一个 MT19937 引擎产生一系列的随机数来生成世界的区块。", "description": "Ame 知道，只要她能够找到初始化 MT19937 引擎时使用的种子，她就能够推断出自己如何才能获得一把精准采集的镐子。于是她游历世界，并通过聪明的侦探头脑算出了这个 MT19937 引擎 **刚被初始化后** 生成的 $N$ 个随机数（注：这里的 $N$ 是 MT19937 引擎中的一个参数）。现在她把这 $N$ 个随机数给了你，希望你能够推断出初始化 MT19937 引擎时使用的种子（$0\\le\\text{种子}<2^{32}$）。值得注意的是，Mivicraft 使用的并非标准的 MT19937 引擎，其中的一些参数与论文相比有所改变，Ame 把它们附加到了输入中。请你帮帮 Ame 吧！\n\n好心的 Mivik 为你准备了一份简单易懂的 MT19937 实现，请在附件中查看。", "inputFormat": "第一行 10 个非负整数，分别对应 MT19937 中的 10 个参数：$N$、$M$、$A$、$U$、$S$、$B$、$T$、$C$、$L$ 和 $F$。\n\n接下来 $N$ 行，每行一个非负整数，依次表示 MT19937 引擎刚被初始化后生成的 $N$ 个随机数。", "outputFormat": "一行一个非负整数，代表 MT19937 引擎初始化时使用的种子。数据保证有解，如果有多个解，你只需要输出任意一个即可。", "hint": "### 样例解释 #1\n\n十个参数全部使用标准的 MT19937 参数，种子为 `233333`。也就是说，你可以通过下面的程序产生同样的随机数序列：\n\n```cpp\n#include <iostream>\n#include <random>\n\nstd::mt19937 engine(233333);\nint main() {\n\tfor (int i = 0; i < 624; ++i)\n\t\tstd::cout << engine() << std::endl;\n\treturn 0;\n}\n```\n\n### 测试点约束\n\n**本题采用捆绑测试。**\n\n对于全部数据，有 $10\\le M<N\\le 2\\times 10^5$，$0\\le A,B,C<2^{32}$，$1\\le U,S,T,L\\le 31$，$1\\le F<2^{32}$，保证 $F$ 是奇数。\n\n每个子任务的具体限制见下表：\n\n| 子任务编号 | 分值 | 特殊限制 |\n|:-:|:-:|:-:|\n| 1 | 20 | 种子小于等于 $1000$ |\n| 2 | 30 | $U=S=T=L=16$，$A=B=C=0$ |\n| 3 | 50 | 无 |\n\n**注：下发文件使用 UTF-8 编码，请使用可识别该编码的编辑器打开。**\n\n**附件下载备用链接：[百度网盘](https://pan.baidu.com/s/1ZJQfZK93Qw2lYrDHLQJh2Q) 提取码：jf9e**", "locale": "zh-CN"}}}
{"pid": "P7122", "type": "P", "difficulty": 6, "samples": [["1\n10\n", "108\n"], ["233333\n666666\n", "588544964910\n"], ["1\n1000000000000000000\n", "1419691012023749904603586777179575510\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["高精度", "2020", "O2优化", "快速傅里叶变换 FFT", "快速数论变换 NTT"], "title": "Chino 与线段树", "background": null, "description": "Chino 刚学习了一种叫做线段树的数据结构。可是她在写线段树时遇到了一个问题：她不知道该使用多大的空间，只知道线段树的叶子结点个数 $n$ 为一个在范围 $[a,b]$ 之内的正整数。\n\nChino 设 $f(n)$ 表示一棵 $n$ 个叶子结点的线段树所占的最大数组下标。她觉得如果她知道了\n\n$$\\sum_{n=a}^{b}f(n)$$\n\n那么她就能够算出她需要多少使用多大的空间。所以她来请教聪明的你来帮帮她。\n\n具体地，Chino 构建线段树的伪代码如下：\n\n$\\begin{aligned}\n&\\underline{\\kern{300pt}}\\\\\n&\\mathbf{Function:}\\ \\text{Build a Segment Tree.}\\\\[-10pt]\n&\\underline{\\kern{300pt}}\\\\[-5pt]\n&\\begin{array}{r|l}\n1&\\ \\mathbf{function}\\ \\text{BuildSegmentTree}(x,l,r):\\\\\n2&\\qquad \\mathbf{if}\\ (l \\ne r)\\ \\mathbf{then}:\\\\\n3&\\qquad\\qquad m \\gets \\left\\lfloor (l+r)/2 \\right\\rfloor\\\\\n4&\\qquad\\qquad \\text{BuildSegmentTree}(2x,l,m)\\\\\n5&\\qquad\\qquad \\text{BuildSegmentTree}(2x+1,m+1,r)\\\\\n6&\\qquad \\mathbf{end\\ if}\\\\\n7&\\ \\mathbf{end\\ function}\\\\\n\\end{array}\\\\[-13pt]\n&\\underline{\\kern{300pt}}\n\\end{aligned}$\n\n线段树所占的最大数组下标即为在 $\\def\\t#1{\\text{#1}}\\t{BuildSegmentTree}\\left(1,1,n\\right)$ 后所有调用的 $\\def\\t#1{\\text{#1}}\\t{BuildSegmentTree}$ 中参数 $x$ 的最大值。", "inputFormat": "输入共二行。\n\n第一行为一个正整数 $a$；第二行为一个正整数 $b$。其意义如题面所述。", "outputFormat": "输出一行一个正整数，表示你的答案。", "hint": "### 样例解释 #1\n$1\\sim 10$ 个叶子结点的线段树的最大下标分别为 $1,3,5,7,9,13,13,15,17,25$，求和得到 $108$。\n\n### 测试点约束\n**本题采用捆绑测试。**\n\n对于全部数据，有 $1\\le a\\le b\\le10^{10^6}$。\n\n每个子任务的具体限制见下表：\n\n| 子任务编号 | 分值 | $b\\le$ | $a=b$ |\n|:-:|:-:|:-:|:-:|\n| 1 | 10 | $10^{10^0}$ | $\\times$ |\n| 2 | 10 | $10^{10^1}$ | $\\times$ |\n| 3 | 10 | $10^{10^2}$ | $\\times$ |\n| 4 | 10 | $10^{10^3}$ | $\\surd$ |\n| 5 | 10 | $10^{10^3}$ | $\\times$ |\n| 6 | 10 | $10^{10^4}$ | $\\surd$ |\n| 7 | 10 | $10^{10^4}$ | $\\times$ |\n| 8 | 10 | $10^{10^5}$ | $\\surd$ |\n| 9 | 10 | $10^{10^5}$ | $\\times$ |\n| 10 | 10 | $10^{10^6}$ | $\\times$ |", "locale": "zh-CN", "translations": {"en": {"title": "Chino and Segment Trees", "background": "", "description": "Chino has just learned a data structure called the segment tree. However, she ran into a problem when writing a segment tree: she does not know how much space to allocate. She only knows that the number of leaf nodes $n$ is a positive integer within the range $[a,b]$.\n\nChino defines $f(n)$ as the maximum array index used by a segment tree with $n$ leaf nodes. She believes that if she knows\n\n$$\\sum_{n=a}^{b}f(n)$$\n\nthen she can figure out how much space she needs. So she asks you, the clever one, to help her.\n\nSpecifically, the pseudocode for building the segment tree is as follows:\n\n$\\begin{aligned}\n&\\underline{\\kern{300pt}}\\\\\n&\\mathbf{Function:}\\ \\text{Build a Segment Tree.}\\\\[-10pt]\n&\\underline{\\kern{300pt}}\\\\[-5pt]\n&\\begin{array}{r|l}\n1&\\ \\mathbf{function}\\ \\text{BuildSegmentTree}(x,l,r):\\\\\n2&\\qquad \\mathbf{if}\\ (l \\ne r)\\ \\mathbf{then}:\\\\\n3&\\qquad\\qquad m \\gets \\left\\lfloor (l+r)/2 \\right\\rfloor\\\\\n4&\\qquad\\qquad \\text{BuildSegmentTree}(2x,l,m)\\\\\n5&\\qquad\\qquad \\text{BuildSegmentTree}(2x+1,m+1,r)\\\\\n6&\\qquad \\mathbf{end\\ if}\\\\\n7&\\ \\mathbf{end\\ function}\\\\\n\\end{array}\\\\[-13pt]\n&\\underline{\\kern{300pt}}\n\\end{aligned}$\n\nThe maximum array index used by the segment tree is the maximum value of the parameter $x$ among all calls to $\\def\\t#1{\\text{#1}}\\t{BuildSegmentTree}$ after executing $\\def\\t#1{\\text{#1}}\\t{BuildSegmentTree}\\left(1,1,n\\right)$.", "inputFormat": "The input has two lines.\n\nThe first line contains a positive integer $a$; the second line contains a positive integer $b$. Their meanings are as described in the statement.", "outputFormat": "Output one line containing one positive integer, which is your answer.", "hint": "### Sample Explanation #1\n\nFor segment trees with $1\\sim 10$ leaf nodes, the maximum indices are $1,3,5,7,9,13,13,15,17,25$, respectively. Summing them gives $108$.\n\n### Test Point Constraints\n\n**This problem uses bundled testdata.**\n\nFor all data, $1\\le a\\le b\\le10^{10^6}$.\n\nThe specific limits for each subtask are shown in the table below:\n\n| Subtask ID | Score | $b\\le$ | $a=b$ |\n|:-:|:-:|:-:|:-:|\n| 1 | 10 | $10^{10^0}$ | $\\times$ |\n| 2 | 10 | $10^{10^1}$ | $\\times$ |\n| 3 | 10 | $10^{10^2}$ | $\\times$ |\n| 4 | 10 | $10^{10^3}$ | $\\surd$ |\n| 5 | 10 | $10^{10^3}$ | $\\times$ |\n| 6 | 10 | $10^{10^4}$ | $\\surd$ |\n| 7 | 10 | $10^{10^4}$ | $\\times$ |\n| 8 | 10 | $10^{10^5}$ | $\\surd$ |\n| 9 | 10 | $10^{10^5}$ | $\\times$ |\n| 10 | 10 | $10^{10^6}$ | $\\times$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Chino 与线段树", "background": null, "description": "Chino 刚学习了一种叫做线段树的数据结构。可是她在写线段树时遇到了一个问题：她不知道该使用多大的空间，只知道线段树的叶子结点个数 $n$ 为一个在范围 $[a,b]$ 之内的正整数。\n\nChino 设 $f(n)$ 表示一棵 $n$ 个叶子结点的线段树所占的最大数组下标。她觉得如果她知道了\n\n$$\\sum_{n=a}^{b}f(n)$$\n\n那么她就能够算出她需要多少使用多大的空间。所以她来请教聪明的你来帮帮她。\n\n具体地，Chino 构建线段树的伪代码如下：\n\n$\\begin{aligned}\n&\\underline{\\kern{300pt}}\\\\\n&\\mathbf{Function:}\\ \\text{Build a Segment Tree.}\\\\[-10pt]\n&\\underline{\\kern{300pt}}\\\\[-5pt]\n&\\begin{array}{r|l}\n1&\\ \\mathbf{function}\\ \\text{BuildSegmentTree}(x,l,r):\\\\\n2&\\qquad \\mathbf{if}\\ (l \\ne r)\\ \\mathbf{then}:\\\\\n3&\\qquad\\qquad m \\gets \\left\\lfloor (l+r)/2 \\right\\rfloor\\\\\n4&\\qquad\\qquad \\text{BuildSegmentTree}(2x,l,m)\\\\\n5&\\qquad\\qquad \\text{BuildSegmentTree}(2x+1,m+1,r)\\\\\n6&\\qquad \\mathbf{end\\ if}\\\\\n7&\\ \\mathbf{end\\ function}\\\\\n\\end{array}\\\\[-13pt]\n&\\underline{\\kern{300pt}}\n\\end{aligned}$\n\n线段树所占的最大数组下标即为在 $\\def\\t#1{\\text{#1}}\\t{BuildSegmentTree}\\left(1,1,n\\right)$ 后所有调用的 $\\def\\t#1{\\text{#1}}\\t{BuildSegmentTree}$ 中参数 $x$ 的最大值。", "inputFormat": "输入共二行。\n\n第一行为一个正整数 $a$；第二行为一个正整数 $b$。其意义如题面所述。", "outputFormat": "输出一行一个正整数，表示你的答案。", "hint": "### 样例解释 #1\n$1\\sim 10$ 个叶子结点的线段树的最大下标分别为 $1,3,5,7,9,13,13,15,17,25$，求和得到 $108$。\n\n### 测试点约束\n**本题采用捆绑测试。**\n\n对于全部数据，有 $1\\le a\\le b\\le10^{10^6}$。\n\n每个子任务的具体限制见下表：\n\n| 子任务编号 | 分值 | $b\\le$ | $a=b$ |\n|:-:|:-:|:-:|:-:|\n| 1 | 10 | $10^{10^0}$ | $\\times$ |\n| 2 | 10 | $10^{10^1}$ | $\\times$ |\n| 3 | 10 | $10^{10^2}$ | $\\times$ |\n| 4 | 10 | $10^{10^3}$ | $\\surd$ |\n| 5 | 10 | $10^{10^3}$ | $\\times$ |\n| 6 | 10 | $10^{10^4}$ | $\\surd$ |\n| 7 | 10 | $10^{10^4}$ | $\\times$ |\n| 8 | 10 | $10^{10^5}$ | $\\surd$ |\n| 9 | 10 | $10^{10^5}$ | $\\times$ |\n| 10 | 10 | $10^{10^6}$ | $\\times$ |", "locale": "zh-CN"}}}
{"pid": "P7123", "type": "P", "difficulty": 7, "samples": [["2\ncenter\nleft\ncenter\nleft\nright\ntreasure\n", "0 left 0\n1 left 1\n1 right 0\n0 left 0\n1 right 0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Indiana Jones and the Uniform Cave", "background": "这是一道 IO 交互题。", "description": "Indiana Jones has stuck in the Uniform Cave. There are many round chambers in the cave, and all of them are indistinguishable from each other. Each chamber has the same number of one-way passages evenly distributed along the chamber’s wall. Passages are indistinguishable from each other, too. The Cave is magical. All passages lead to other chambers or to the same one. However, the last passage, after all passages are visited, leads to the treasure. Even the exact number of chambers is a mystery. It is known that each chamber is reachable from each other chamber using the passages.\n\nDr. Jones noticed that each chamber has a stone in the center. He decided to use these stones to mark chambers and passages. A stone can be placed to the left or to the right of one of the passages. When Indiana Jones enters the chamber all that he can observe is the location of the stone in the chamber. He can move the stone to the desired location and take any passage leading out of the chamber.\n\nYour task is to help Indiana Jones to visit every passage in the Uniform Cave and find the treasure.", "inputFormat": "First, the testing system writes the integer m — the number of passages in each chamber ($2 \\leq m \\le 20$).\n\nDr. Jones enters the chamber and sees, in the next line, where the stone is placed: either in the “center” of the chamber or to the “left”, or to the “right” of some passage. On the first visit to the chamber, the stone is in the center.\n\nYour solution shall output his actions: the number and the side of the passage to place the stone to, and the number of the passage to take. Both numbers are relative to the passage marked by the stone, counting clockwise from 0 to m − 1. If the stone is in the center of the chamber, the origin is random.\n\nFor example, “3 left 1” tells that Dr. Jones moves the stone three passages clockwise and places it to the left of the passage, then he takes the passage to the right of the initial stone position.\n\nAfter each move testing system tells either the location of the stone in the next chamber or “treasure”, if Indiana Jones had found it. The testing system writes “treasure” when all the passages are visited.\n\nIf Dr. Jones does not find the treasure room after 20 000 passages are taken, he starves to death, and your solution receives the “Wrong Answer” outcome. You also receive this outcome if your solution terminates before all passages are taken.\n\nThe total number of chambers in the cave is unknown, but you may assume that it does not exceed 20, and that each chamber is reachable from every other chamber.", "outputFormat": "", "hint": "Dr. Jones enters the example cave and sees that the stone in the first chamber is in the center. He marks the chamber by placing the stone to the left of some passage and takes it. He sees the chamber where the stone is to the left of the passage, so he is in the first chamber again. He moves the stone clockwise and takes the passage marked by it. This passage leads to the second chamber. He marks it by placing the stone to the right of some passage and takes another one. He is in the first chamber again, so he returns to the second chamber and takes the remaining passage. This passage leads to the treasure.", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Indiana Jones and the Uniform Cave", "background": "这是一道 IO 交互题。", "description": "Indiana Jones has stuck in the Uniform Cave. There are many round chambers in the cave, and all of them are indistinguishable from each other. Each chamber has the same number of one-way passages evenly distributed along the chamber’s wall. Passages are indistinguishable from each other, too. The Cave is magical. All passages lead to other chambers or to the same one. However, the last passage, after all passages are visited, leads to the treasure. Even the exact number of chambers is a mystery. It is known that each chamber is reachable from each other chamber using the passages.\n\nDr. Jones noticed that each chamber has a stone in the center. He decided to use these stones to mark chambers and passages. A stone can be placed to the left or to the right of one of the passages. When Indiana Jones enters the chamber all that he can observe is the location of the stone in the chamber. He can move the stone to the desired location and take any passage leading out of the chamber.\n\nYour task is to help Indiana Jones to visit every passage in the Uniform Cave and find the treasure.", "inputFormat": "First, the testing system writes the integer m — the number of passages in each chamber ($2 \\leq m \\le 20$).\n\nDr. Jones enters the chamber and sees, in the next line, where the stone is placed: either in the “center” of the chamber or to the “left”, or to the “right” of some passage. On the first visit to the chamber, the stone is in the center.\n\nYour solution shall output his actions: the number and the side of the passage to place the stone to, and the number of the passage to take. Both numbers are relative to the passage marked by the stone, counting clockwise from 0 to m − 1. If the stone is in the center of the chamber, the origin is random.\n\nFor example, “3 left 1” tells that Dr. Jones moves the stone three passages clockwise and places it to the left of the passage, then he takes the passage to the right of the initial stone position.\n\nAfter each move testing system tells either the location of the stone in the next chamber or “treasure”, if Indiana Jones had found it. The testing system writes “treasure” when all the passages are visited.\n\nIf Dr. Jones does not find the treasure room after 20 000 passages are taken, he starves to death, and your solution receives the “Wrong Answer” outcome. You also receive this outcome if your solution terminates before all passages are taken.\n\nThe total number of chambers in the cave is unknown, but you may assume that it does not exceed 20, and that each chamber is reachable from every other chamber.", "outputFormat": "", "hint": "Dr. Jones enters the example cave and sees that the stone in the first chamber is in the center. He marks the chamber by placing the stone to the left of some passage and takes it. He sees the chamber where the stone is to the left of the passage, so he is in the first chamber again. He moves the stone clockwise and takes the passage marked by it. This passage leads to the second chamber. He marks it by placing the stone to the right of some passage and takes another one. He is in the first chamber again, so he returns to the second chamber and takes the remaining passage. This passage leads to the treasure.", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Indiana Jones and the Uniform Cave", "background": "", "description": "现在在一个洞穴里寻宝。这个洞穴有 $n$ 个房间。房间是不可区分的。每个房间都引出 $m$ 个单向道路，终点可以是自己也可以是其它房间。这些单向道路的入口均匀地分布在房间的墙壁上，且每条单向道路也是不可区分的。保证整个有向图是强连通的。你一开始在某一个房间，如果遍历了所有的边，就能找到宝藏。\n\n每个房间有一个石子，这也是你区分房间和道路的唯一工具。一开始石子是在这个房间的某一个通道的入口前，并且是放在中央的。你每到一个房间，可以选择将石子移动到某个通道前，把它放在通道左边或者右边（不能是中间），然后再从某个通道走出去。你不可以把石子带出房间。你并没有携带过多的食物，所以如果你走了超过 $20000$ 条边，你就会因为食物耗尽而饿死。你要在规定步数之内找到宝藏。", "inputFormat": "共 $m$ 行，每行一个字符串，表示该房间内石头被放置的位置为某个通道的 $\"center\"$，$\"left\"$ 或 $\"right\"$。当第一次到达一个墓室时，石头处在中间(center)。", "outputFormat": "每行一个非负整数 $st$，表示将石头放在原所在位置顺时针方向第 $st$ 个通道入口；一个字符串，表示将它放在该通道入口 $dir$ 的位置（$\"center\"$，$\"left\"$ 或 $\"right\"$）；一个非负整数 $pa$ ，表示从石子的原来位置顺时针方向第 $pa$ 个通道走出。\n\n通道顺时针从 $0$ 到 $m−1$ 编号。如果石头一开始是在中间（$center$），它会位于随机一个通道入口处。\n\n每走一步，评测机会返回该房间的石头的位置或者 $\"treasure\"$ （如果您找到了宝藏且所有的通道都被走过时，就会反馈 $\"treasure\"$ ）。\n\n**举个栗子**：`3 left 1` 表示将石头顺时针移动了 $3$ 个通道，并将其放置在该通道的左侧，然后走向最初石头所在位置的右侧的通道。\n\n你最多可以进行 $20000$ 次操作。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7124", "type": "P", "difficulty": 6, "samples": [["6\n1 1 2 3 3\n6\n1 1 2 3 3", "=1+1+3+5+6=2+2=4----+4+2=3+3+6=5-+5=6!\n=1+1+3+5+6=2+2=4----+4+2=3+3+6=5-+5=6!"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2008", "Special Judge", "O2优化", "Ynoi"], "title": "[Ynoi2008] stcm", "background": "w33z 是良心出题人！\n\n请使用高效输出方式，本题最多需要输出 50MB。", "description": "给定一棵树，你可以维护一个集合，支持三种操作：\n\n1. 当前集合中插入一个节点 $x$\n2. 撤回上一次插入操作\n3. 将当前点集标为第 $i$ 个点的子树补信息\n\n一个点 $x$ 的子树补信息定义为，树的点集除去 $x$ 的子树（包括 $x$）内的点得到的集合；\n需要保证每个点的子树补信息都是正确的。", "inputFormat": "**本题输入含有多组测试数据。**\n\n一组测试数据格式为：\n\n第一行一个正整数 $n$。\n\n之后一行 $n-1$ 个正整数，第 $i$ 个数表示 $i+1$ 节点的父亲节点 $j$，保证 $j<i+1$。\n\n请读入至 EOF。", "outputFormat": "对每一组数据，输出一个字符串，从左往右，每个\"+x\"形式的子串代表进行一次 1 操作，对象为编号 $x$ 的节点，每个\"-\"子串代表进行一次 2 操作，每个\"=x\"形式的子串代表进行一次 3 操作，对象为编号 $x$ 的节点，每个\"!\"子串代表全部操作都已结束，在其后面的任何输入会被忽略，字符串必须以\"!\"表示结束。\n\n输出的字符串中不允许以任何空白字符分隔。", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：ccz181078，Data：ccz181078&nzhtl1477\n\n对于 $100\\%$ 的数据，满足 $1\\le n\\le 10^5$，$1\\le T\\le 3$。\n\n题目采用 Special Judge 评测。\n\n允许进行的 1 操作次数为 $4.5 \\times 10^6$ 次，不允许插入一个当前集合中存在的元素。\n\n当最后一次未被撤回的插入操作不存在时，不允许进行 2 操作。\n\n对每个点，必须对其进行**恰好一次** 3 操作。\n\n**所有测试数据输出独立检验。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2008] stcm", "background": "w33z 是良心出题人！\n\n请使用高效输出方式，本题最多需要输出 50MB。", "description": "给定一棵树，你可以维护一个集合，支持三种操作：\n\n1. 当前集合中插入一个节点 $x$\n2. 撤回上一次插入操作\n3. 将当前点集标为第 $i$ 个点的子树补信息\n\n一个点 $x$ 的子树补信息定义为，树的点集除去 $x$ 的子树（包括 $x$）内的点得到的集合；\n需要保证每个点的子树补信息都是正确的。", "inputFormat": "**本题输入含有多组测试数据。**\n\n一组测试数据格式为：\n\n第一行一个正整数 $n$。\n\n之后一行 $n-1$ 个正整数，第 $i$ 个数表示 $i+1$ 节点的父亲节点 $j$，保证 $j<i+1$。\n\n请读入至 EOF。", "outputFormat": "对每一组数据，输出一个字符串，从左往右，每个\"+x\"形式的子串代表进行一次 1 操作，对象为编号 $x$ 的节点，每个\"-\"子串代表进行一次 2 操作，每个\"=x\"形式的子串代表进行一次 3 操作，对象为编号 $x$ 的节点，每个\"!\"子串代表全部操作都已结束，在其后面的任何输入会被忽略，字符串必须以\"!\"表示结束。\n\n输出的字符串中不允许以任何空白字符分隔。", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：ccz181078，Data：ccz181078&nzhtl1477\n\n对于 $100\\%$ 的数据，满足 $1\\le n\\le 10^5$，$1\\le T\\le 3$。\n\n题目采用 Special Judge 评测。\n\n允许进行的 1 操作次数为 $4.5 \\times 10^6$ 次，不允许插入一个当前集合中存在的元素。\n\n当最后一次未被撤回的插入操作不存在时，不允许进行 2 操作。\n\n对每个点，必须对其进行**恰好一次** 3 操作。\n\n**所有测试数据输出独立检验。**", "locale": "zh-CN"}}}
{"pid": "P7125", "type": "P", "difficulty": 7, "samples": [["10 10\n2 2 2 1 2 7 7 9 6 10\n1 4\n4 4\n1 3\n2 6\n6 6\n7 10\n2 6\n4 10\n3 5\n3 7\n", "2\n0\n2\n1\n0\n3\n1\n6\n0\n1\n"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2008", "O2优化", "Ynoi"], "title": "[Ynoi2008] rsmemq", "background": "", "description": "给定一个长为 $n$ 的序列 $a$，定义 $x$ 为区间 $[l, r]$ 的众数当且仅当不存在 $y$ 使得 $y$ 在区间 $[l, r]$ 中的出现次数**大于** $x$ 在区间 $[l,r]$ 中的出现次数。\n\n有 $m$ 次询问，每次询问给出 $l, r$，求有多少二元组 $(l',r')$ 满足 $l\\le l'\\le r'\\le r$，且 $[l', r']$ 的区间长度为奇数，且 $(l' + r') / 2$**（注意这里是下标而不是下标对应的值）**&#8203;是区间 $[l', r']$ 中的众数。", "inputFormat": "输入的第一行包含两个数 $n$，$m$。\n\n之后一行 $n$ 个数表示这个序列。\n\n之后 $m$ 行，每行两个数 $l$，$r$ 表示一次询问。\n\n", "outputFormat": "输出共 $m$ 行，表示每个询问对应的答案。", "hint": "Idea：yummy&nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477&czr，Data：nzhtl1477(partially uploaded)\n\n对于 $100\\%$ 的数据，其中 $1\\le n,m\\le 5\\times 10^5$，$1\\le l\\le r\\le n$，$1\\le a_i\\le n$，所有数值为整数。\n\n样例解释：\n\n$[1,4]$ 中满足条件的子区间为 $[1,3]$，$[2,2]$。\n\n$[1,3]$ 中满足条件的子区间为 $[1,3]$，$[2,2]$。\n\n$[2,6]$ 中满足条件的子区间为 $[2,2]$。\n\n$[7,10]$ 中满足条件的子区间为 $[7,7]$，$[8,10]$，$[10,10]$。\n\n$[4,10]$ 中满足条件的子区间为 $[7,7]$，$[6,8]$，$[5,9]$，$[4,10]$，$[8,10]$，$[10,10]$。\n\n$[3,7]$ 中满足条件的子区间为 $[7,7]$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2008] rsmemq", "background": "", "description": "给定一个长为 $n$ 的序列 $a$，定义 $x$ 为区间 $[l, r]$ 的众数当且仅当不存在 $y$ 使得 $y$ 在区间 $[l, r]$ 中的出现次数**大于** $x$ 在区间 $[l,r]$ 中的出现次数。\n\n有 $m$ 次询问，每次询问给出 $l, r$，求有多少二元组 $(l',r')$ 满足 $l\\le l'\\le r'\\le r$，且 $[l', r']$ 的区间长度为奇数，且 $(l' + r') / 2$**（注意这里是下标而不是下标对应的值）**&#8203;是区间 $[l', r']$ 中的众数。", "inputFormat": "输入的第一行包含两个数 $n$，$m$。\n\n之后一行 $n$ 个数表示这个序列。\n\n之后 $m$ 行，每行两个数 $l$，$r$ 表示一次询问。\n\n", "outputFormat": "输出共 $m$ 行，表示每个询问对应的答案。", "hint": "Idea：yummy&nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477&czr，Data：nzhtl1477(partially uploaded)\n\n对于 $100\\%$ 的数据，其中 $1\\le n,m\\le 5\\times 10^5$，$1\\le l\\le r\\le n$，$1\\le a_i\\le n$，所有数值为整数。\n\n样例解释：\n\n$[1,4]$ 中满足条件的子区间为 $[1,3]$，$[2,2]$。\n\n$[1,3]$ 中满足条件的子区间为 $[1,3]$，$[2,2]$。\n\n$[2,6]$ 中满足条件的子区间为 $[2,2]$。\n\n$[7,10]$ 中满足条件的子区间为 $[7,7]$，$[8,10]$，$[10,10]$。\n\n$[4,10]$ 中满足条件的子区间为 $[7,7]$，$[6,8]$，$[5,9]$，$[4,10]$，$[8,10]$，$[10,10]$。\n\n$[3,7]$ 中满足条件的子区间为 $[7,7]$。", "locale": "zh-CN"}}}
{"pid": "P7126", "type": "P", "difficulty": 7, "samples": [["10 9 2\n1 1 1 2 3 4 1 1 1\n1 3\n2 4\n3 5\n4 6\n5 7\n6 8\n7 9\n8 10\n5 5", "1\n1\n2\n3\n3\n3\n2\n1\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2008", "O2优化", "Ynoi"], "title": "[Ynoi2008] rdCcot", "background": "", "description": "给一棵边权为 $1$ 的树和一个常数 $C$，节点用 $1$ 到 $n$ 的整数表示。\n\n定义 $dist(a,b)$ 为节点 $a,b$ 在树上的距离，即 $a$ 到 $b$ 的简单路径上的边权和，特别地，$dist(a,a) = 0$。  \n\n每次查询的时候给出一个区间 $[l,r]$，查询有多少个 C-块，定义如下：  \n\n对任意两个节点 $a,b$，定义 $a,b$ 是 C-连通的，当且仅当存在一个长为 $t$ 的节点序列 $\\{v_i\\}$，满足：  \n\n1. $v_1=a$  \n2. $v_t=b$  \n3. 对任意 $1\\le i\\le t-1$，$dist(v_i,v_{i+1})\\le C$  \n4. 对任意 $1\\le i\\le t$，$l\\le v_i\\le r$  \n\n定义“C-块”为一个点集 $S$，满足：  \n\n1. 对任意 $a$ 属于 $S$，$b$ 属于 $S$ 的补集，$a,b$ 不 C-连通  \n2. 对任意 $a,b$ 属于 $S$，$a$ 和 $b$ C-连通  \n3. 对任意 $a$ 属于 $S$，有 $l\\le a \\le r$\n", "inputFormat": "第一行三个数 $n$，$m$，$C$ 依次表示树的节点个数，询问次数，还有常数 $C$；\n\n第二行共 $n-1$ 个数 $p_2\\;p_3\\;\\dots\\;p_n$，表示对于 $2 \\le i\\le n$ 的整数 $i$，$i$ 和 $p_i$ 之间有一条无向边；\n\n保证输入的数据构成一棵树；\n\n之后 $m$ 行，每行两个数 $l\\;\\;r$，表示这次询问的区间是 $[l,r]$，保证 $l \\le r$；\n\n保证 $1 \\le n\\le 3\\cdot 10^5,1 \\le m\\le 6\\cdot 10^5$。", "outputFormat": "共 $m$ 行，依次回答各组询问：每行输出一行一个整数表示这组询问的答案。\n\n", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：nzhtl1477&ccz181078，Data：ccz181078\n\n本题有多个子任务，每个子任务可能包含多个测试点，只有通过了一个子任务中的所有测试点才能得到该子任务的分数。\n\n每个子任务的测试点满足一些特殊的限制，具体如下表：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/14tqwasg.png)\n\n其中，性质1、性质2的含义如下：\n\n性质1：存在一个点 $w$ 使得 $dist(1,w)=n-1$；\n\n性质2：$n=m$，且第 $i$ 次询问为 $l=1,\\;r=i$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2008] rdCcot", "background": "", "description": "给一棵边权为 $1$ 的树和一个常数 $C$，节点用 $1$ 到 $n$ 的整数表示。\n\n定义 $dist(a,b)$ 为节点 $a,b$ 在树上的距离，即 $a$ 到 $b$ 的简单路径上的边权和，特别地，$dist(a,a) = 0$。  \n\n每次查询的时候给出一个区间 $[l,r]$，查询有多少个 C-块，定义如下：  \n\n对任意两个节点 $a,b$，定义 $a,b$ 是 C-连通的，当且仅当存在一个长为 $t$ 的节点序列 $\\{v_i\\}$，满足：  \n\n1. $v_1=a$  \n2. $v_t=b$  \n3. 对任意 $1\\le i\\le t-1$，$dist(v_i,v_{i+1})\\le C$  \n4. 对任意 $1\\le i\\le t$，$l\\le v_i\\le r$  \n\n定义“C-块”为一个点集 $S$，满足：  \n\n1. 对任意 $a$ 属于 $S$，$b$ 属于 $S$ 的补集，$a,b$ 不 C-连通  \n2. 对任意 $a,b$ 属于 $S$，$a$ 和 $b$ C-连通  \n3. 对任意 $a$ 属于 $S$，有 $l\\le a \\le r$\n", "inputFormat": "第一行三个数 $n$，$m$，$C$ 依次表示树的节点个数，询问次数，还有常数 $C$；\n\n第二行共 $n-1$ 个数 $p_2\\;p_3\\;\\dots\\;p_n$，表示对于 $2 \\le i\\le n$ 的整数 $i$，$i$ 和 $p_i$ 之间有一条无向边；\n\n保证输入的数据构成一棵树；\n\n之后 $m$ 行，每行两个数 $l\\;\\;r$，表示这次询问的区间是 $[l,r]$，保证 $l \\le r$；\n\n保证 $1 \\le n\\le 3\\cdot 10^5,1 \\le m\\le 6\\cdot 10^5$。", "outputFormat": "共 $m$ 行，依次回答各组询问：每行输出一行一个整数表示这组询问的答案。\n\n", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：nzhtl1477&ccz181078，Data：ccz181078\n\n本题有多个子任务，每个子任务可能包含多个测试点，只有通过了一个子任务中的所有测试点才能得到该子任务的分数。\n\n每个子任务的测试点满足一些特殊的限制，具体如下表：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/14tqwasg.png)\n\n其中，性质1、性质2的含义如下：\n\n性质1：存在一个点 $w$ 使得 $dist(1,w)=n-1$；\n\n性质2：$n=m$，且第 $i$ 次询问为 $l=1,\\;r=i$。", "locale": "zh-CN"}}}
{"pid": "P7127", "type": "P", "difficulty": 2, "samples": [["2\n0\n1", "0\n1/4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1500, 1500, 1500, 1500, 1500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "计算几何", "2020"], "title": "「RdOI R1」一次函数(function)", "background": "**请使用较快的读入方式。**\n\n众所周知，一次函数的解析式如下：\n\n$$y=kx+b$$\n\n或者，我们可以表示为：\n\n$$f(x)=kx+b$$\n\n这个就是一次函数的解析式，下文中用到的解析式均用 $y=kx+b$ 表示。\n\n- 如果不知道什么是一次函数的[戳我](https://baike.baidu.com/item/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0)。\n- 如果不知道什么是函数图像的[戳我](https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F/514135)。", "description": "设 $S_k$ 表示直线 $l_{k1}:y=kx+k-1$，$l_{k2}:y=(k+1)x+k$ 与 $x$ 轴围成的三角形的面积，求：\n\n$$\\sum_{i=1}^nS_i$$\n\n本题中，共有 $t$ 次询问，每次询问给出 $n_i$，求上式在 $n=n_i$ 时的取值。\n\n若 $n<1$，该和式的值视作 $0$。", "inputFormat": "一共 $t+1$ 行。\n\n第一行，一个整数 $t$，表示有 $t$ 组测试数据。\n\n接下来 $t$ 行，每行一个整数 $n_i$，含义如题面所述。", "outputFormat": "一共 $t$ 行。\n\n每一行，每行一个数表示你所求得的答案。\n\n结果可能是分数，请**约分**至最简分数，分数请用 `xxx/xxx` 表示，如 $\\dfrac{1}{2}$ 表示为 `1/2`，$\\dfrac{2}{4}$ 表示为 `1/2`，请注意约分。\n\n注：若答案为 $0$，请输出 `0`。", "hint": "【样例解释】\n\n当 $n=0$ 时，根据题意，输出 $0$。\n\n当 $n=1$ 时，$S_1$ 就是 $y=x$、$y=2x+1$ 与 $x$ 轴所夹面积，为 $\\dfrac{1}{4}$。\n\n---\n\n【数据范围】\n\n- 对于 $5\\%$ 的数据，$t \\le 100,n=0$。\n- 对于另外 $20\\%$ 的数据，$t \\le 100,n \\le 2020$。\n- 对于另外 $20\\%$ 的数据，$t \\le 5 \\times 10^4,n \\le 5 \\times 10^3$。\n- 对于 $100\\%$ 的数据，$1 \\le t \\le 2 \\times 10^6,0 \\le n \\le 2 \\times 10^6$。\n\n---\n\n【说明/提示】\n\n- 建议画图思考。\n- **请注意输出答案的时候约分**。\n- **请使用较快的读入方式**。\n\n---\n\n【文件读入读出】**（模拟，提交代码时不需使用）**\n\n- 文件名：`function.cpp`\n- 读入文件名：`function.in`\n- 读出文件名：`function.out`", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「RdOI R1」一次函数(function)", "background": "**请使用较快的读入方式。**\n\n众所周知，一次函数的解析式如下：\n\n$$y=kx+b$$\n\n或者，我们可以表示为：\n\n$$f(x)=kx+b$$\n\n这个就是一次函数的解析式，下文中用到的解析式均用 $y=kx+b$ 表示。\n\n- 如果不知道什么是一次函数的[戳我](https://baike.baidu.com/item/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0)。\n- 如果不知道什么是函数图像的[戳我](https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F/514135)。", "description": "设 $S_k$ 表示直线 $l_{k1}:y=kx+k-1$，$l_{k2}:y=(k+1)x+k$ 与 $x$ 轴围成的三角形的面积，求：\n\n$$\\sum_{i=1}^nS_i$$\n\n本题中，共有 $t$ 次询问，每次询问给出 $n_i$，求上式在 $n=n_i$ 时的取值。\n\n若 $n<1$，该和式的值视作 $0$。", "inputFormat": "一共 $t+1$ 行。\n\n第一行，一个整数 $t$，表示有 $t$ 组测试数据。\n\n接下来 $t$ 行，每行一个整数 $n_i$，含义如题面所述。", "outputFormat": "一共 $t$ 行。\n\n每一行，每行一个数表示你所求得的答案。\n\n结果可能是分数，请**约分**至最简分数，分数请用 `xxx/xxx` 表示，如 $\\dfrac{1}{2}$ 表示为 `1/2`，$\\dfrac{2}{4}$ 表示为 `1/2`，请注意约分。\n\n注：若答案为 $0$，请输出 `0`。", "hint": "【样例解释】\n\n当 $n=0$ 时，根据题意，输出 $0$。\n\n当 $n=1$ 时，$S_1$ 就是 $y=x$、$y=2x+1$ 与 $x$ 轴所夹面积，为 $\\dfrac{1}{4}$。\n\n---\n\n【数据范围】\n\n- 对于 $5\\%$ 的数据，$t \\le 100,n=0$。\n- 对于另外 $20\\%$ 的数据，$t \\le 100,n \\le 2020$。\n- 对于另外 $20\\%$ 的数据，$t \\le 5 \\times 10^4,n \\le 5 \\times 10^3$。\n- 对于 $100\\%$ 的数据，$1 \\le t \\le 2 \\times 10^6,0 \\le n \\le 2 \\times 10^6$。\n\n---\n\n【说明/提示】\n\n- 建议画图思考。\n- **请注意输出答案的时候约分**。\n- **请使用较快的读入方式**。\n\n---\n\n【文件读入读出】**（模拟，提交代码时不需使用）**\n\n- 文件名：`function.cpp`\n- 读入文件名：`function.in`\n- 读出文件名：`function.out`", "locale": "zh-CN"}}}
{"pid": "P7128", "type": "P", "difficulty": 3, "samples": [["3\n3 1 2", "1 3\n1 2"], ["7\n1 3 2 7 6 4 5", "2 4\n1 2\n1 3\n3 7\n2 5\n1 2\n1 3\n3 6\n1 2\n2 5\n1 3\n1 2\n2 4\n1 2\n1 3\n1 2"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "Special Judge"], "title": "「RdOI R1」序列(sequence)", "background": "", "description": "有一序列 $x$ ，长度为 $q$ ，序列中的每个数只出现一次。\n\n即：序列 $x$ 是 $1$ 到 $q$ 的一个排列。\n\n对于序列 $x$ 的操作只有一种：对于一个数 $x_i$ ，你可以使其与 $x_{2i}$ 或 $x_{2i+1}$ 交换位置(如果它们存在的话)。\n\n现在请你使序列 $x$ 变为一个升序序列，并按顺序输出你进行的操作。", "inputFormat": "输入数据共 $2$ 行。\n\n第 $1$ 行， $1$ 个正整数，$q$。\n\n第 $2$ 行， $q$ 个正整数， $x_{1～q}$。", "outputFormat": "输出数据共 $ans$ 行， $ans$ 表示你的操作次数。\n\n第 $1$ ~ $ans$ 行，每行两个整数，$i$ ，$j$ ，表示交换 $x_i$ 和 $x_j$ 的位置 $(i < j)$。", "hint": "【样例说明】\n\n样例#1说明：\n\n交换 $2$ 和 $3$ ，序列变为：$2,1,3$。\n\n再交换 $2$ 和 $1$ ，序列变为：$1,2,3$。\n\n【数据范围】\n\n对于 $40\\%$ 的数据，$3 \\le q \\le 2^{10}$。\n\n对于 $100\\%$ 的数据，$3 \\le q \\le 2^{17}$，$1 \\le x_i \\le q$。\n\n【提示】\n\n- 使用 Special Judge。\n- $q = 2 ^ p - 1(p \\in \\mathbb{N}^*)$  \n- 最多进行 $2q\\times\\lceil\\log_2 q\\rceil$ 次操作。\n- 样例的输出数据只是众多方案中的一种。\n- 因为是 `special judge` ，因此不提供附加样例。\n\n---\n\n【文件读入读出】**（模拟，提交代码时不需使用）**\n\n- 文件名：`sequence.cpp`\n- 读入文件名：`sequence.in`\n- 读出文件名：`sequence.out`\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「RdOI R1」序列(sequence)", "background": "", "description": "有一序列 $x$ ，长度为 $q$ ，序列中的每个数只出现一次。\n\n即：序列 $x$ 是 $1$ 到 $q$ 的一个排列。\n\n对于序列 $x$ 的操作只有一种：对于一个数 $x_i$ ，你可以使其与 $x_{2i}$ 或 $x_{2i+1}$ 交换位置(如果它们存在的话)。\n\n现在请你使序列 $x$ 变为一个升序序列，并按顺序输出你进行的操作。", "inputFormat": "输入数据共 $2$ 行。\n\n第 $1$ 行， $1$ 个正整数，$q$。\n\n第 $2$ 行， $q$ 个正整数， $x_{1～q}$。", "outputFormat": "输出数据共 $ans$ 行， $ans$ 表示你的操作次数。\n\n第 $1$ ~ $ans$ 行，每行两个整数，$i$ ，$j$ ，表示交换 $x_i$ 和 $x_j$ 的位置 $(i < j)$。", "hint": "【样例说明】\n\n样例#1说明：\n\n交换 $2$ 和 $3$ ，序列变为：$2,1,3$。\n\n再交换 $2$ 和 $1$ ，序列变为：$1,2,3$。\n\n【数据范围】\n\n对于 $40\\%$ 的数据，$3 \\le q \\le 2^{10}$。\n\n对于 $100\\%$ 的数据，$3 \\le q \\le 2^{17}$，$1 \\le x_i \\le q$。\n\n【提示】\n\n- 使用 Special Judge。\n- $q = 2 ^ p - 1(p \\in \\mathbb{N}^*)$  \n- 最多进行 $2q\\times\\lceil\\log_2 q\\rceil$ 次操作。\n- 样例的输出数据只是众多方案中的一种。\n- 因为是 `special judge` ，因此不提供附加样例。\n\n---\n\n【文件读入读出】**（模拟，提交代码时不需使用）**\n\n- 文件名：`sequence.cpp`\n- 读入文件名：`sequence.in`\n- 读出文件名：`sequence.out`\n", "locale": "zh-CN"}}}
{"pid": "P7129", "type": "P", "difficulty": 5, "samples": [["2 20\n9 1 4 2\n3 2 4 1\n11 2 4 3\n2 3 2 2", "48"], ["3 20\n9 2 1 1\n10000\n1 4 1 1\n1\n1 4 1 1\n2", "20003"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "O2优化"], "title": "「RdOI R1」冰淇淋游戏(play)", "background": "又有新游戏可玩啦！", "description": "小 T 发现最近市面上出现了一款游戏，这款游戏分为 $n$ 关，第 $i$ 关玩一次需要 $s_i$ 个体力，最多可以玩 $m_i$ 次第 $i$ 关。想玩第 $i$ 关，必须先玩第 $i-1$ 关至少一次，当然，玩第 $1$ 关不需要这个先决条件。\n\n游戏规则是这样的（对于第 $i$ 关）：\n\n一共有 $k_i$ 个冰淇淋排成一排，第 $j$ 个冰淇淋的美味度为 $y_{i,j}$，每次你需要选择一个冰淇淋吃掉，共吃 $k_i$ 次，在第 $j$ 次吃第 $l$ 个冰淇淋可以获得 $j\\times y_{i,l}$ 分。\n\n当然，要想吃冰淇淋可没有那么简单，你需要在第一次吃指定的第 $c_i$ 个冰淇淋，接下来每次只能吃已经吃完的段的两边的冰淇淋，比如第一次吃的是第 $2$ 个冰淇淋，第二次可以吃第 $1$ 个或第 $3$ 个（如果有的话）。\n\n因为小 T 的脑子不太够计算这复杂的分数，所以他想求助你，在使用体力不超过 $t$ 的情况下，最多可以获得多少分数。", "inputFormat": "第一行有两个整数 $n,t$，分别表示关卡数和体力数。\n\n接下来第 $2$ 到第 $2\\times n+1$ 行，第 $2\\times i$ 行和第 $2\\times i+1$ 行描述第 $i$ 关。\n\n第 $2\\times i$ 行四个整数 $s_i,m_i,k_i,c_i$，意义见题面。\n\n第 $2\\times i+1$ 行 $k_i$ 个整数，第 $j$ 个为 $y_{i,j}$，意义见题面。", "outputFormat": "一行一个整数，为使用体力不超过 $t$ 的情况下的获得的分数的最大值。", "hint": "【样例解释】\n\n样例1：\n\n最优解为玩一次第一关再玩一次第二关。\n\n第一关按照第 $2,3,4,1$ 个的顺序吃冰淇淋，可以获得 $2\\times 1+4\\times 2+1\\times 3+3\\times 4=2+8+3+12=25$ 的分数。\n\n第二关按照第 $3,4,2,1$ 个的顺序吃冰淇淋，可以获得 $2\\times 1+2\\times 2+3\\times 3+2\\times 4=2+4+9+8=23$ 的分数。\n\n所以最多可以获得 $25\\times 1+23\\times 1=48$ 的分数。\n\n样例2：\n\n最优解为玩两次第一关，一次第二关，一次第三关。\n\n可以获得 $10000 \\times 2+1 \\times 1+2 \\times 1=20003$ 的分数。\n\n---\n\n【数据范围】\n\n对于 $10\\%$ 的数据，$1 \\le n \\le 10 , 1 \\le k_i,m_i,s_i,y_{i,j} \\le 100 , 1 \\le t \\le 100$。\n\n对于另外 $40\\%$ 的数据，$1 \\le n \\le 100 , 1 \\le k_i,m_i,s_i,y_{i,j} \\le 100 , 1 \\le t \\le 10^4$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 200 , 1 \\le k_i,m_i,s_i,y_{i,j} \\le 500,1 \\le t \\le 10^5,1\\le c_i\\le k_i$。\n\n---\n\n【说明/提示】\n\n- 尝试理解样例\n\n---\n\n【文件读入读出】**（模拟，提交代码时不需使用）**\n\n- 文件名：`play.cpp`\n- 读入文件名：`play.in`\n- 读出文件名：`play.out`", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「RdOI R1」冰淇淋游戏(play)", "background": "又有新游戏可玩啦！", "description": "小 T 发现最近市面上出现了一款游戏，这款游戏分为 $n$ 关，第 $i$ 关玩一次需要 $s_i$ 个体力，最多可以玩 $m_i$ 次第 $i$ 关。想玩第 $i$ 关，必须先玩第 $i-1$ 关至少一次，当然，玩第 $1$ 关不需要这个先决条件。\n\n游戏规则是这样的（对于第 $i$ 关）：\n\n一共有 $k_i$ 个冰淇淋排成一排，第 $j$ 个冰淇淋的美味度为 $y_{i,j}$，每次你需要选择一个冰淇淋吃掉，共吃 $k_i$ 次，在第 $j$ 次吃第 $l$ 个冰淇淋可以获得 $j\\times y_{i,l}$ 分。\n\n当然，要想吃冰淇淋可没有那么简单，你需要在第一次吃指定的第 $c_i$ 个冰淇淋，接下来每次只能吃已经吃完的段的两边的冰淇淋，比如第一次吃的是第 $2$ 个冰淇淋，第二次可以吃第 $1$ 个或第 $3$ 个（如果有的话）。\n\n因为小 T 的脑子不太够计算这复杂的分数，所以他想求助你，在使用体力不超过 $t$ 的情况下，最多可以获得多少分数。", "inputFormat": "第一行有两个整数 $n,t$，分别表示关卡数和体力数。\n\n接下来第 $2$ 到第 $2\\times n+1$ 行，第 $2\\times i$ 行和第 $2\\times i+1$ 行描述第 $i$ 关。\n\n第 $2\\times i$ 行四个整数 $s_i,m_i,k_i,c_i$，意义见题面。\n\n第 $2\\times i+1$ 行 $k_i$ 个整数，第 $j$ 个为 $y_{i,j}$，意义见题面。", "outputFormat": "一行一个整数，为使用体力不超过 $t$ 的情况下的获得的分数的最大值。", "hint": "【样例解释】\n\n样例1：\n\n最优解为玩一次第一关再玩一次第二关。\n\n第一关按照第 $2,3,4,1$ 个的顺序吃冰淇淋，可以获得 $2\\times 1+4\\times 2+1\\times 3+3\\times 4=2+8+3+12=25$ 的分数。\n\n第二关按照第 $3,4,2,1$ 个的顺序吃冰淇淋，可以获得 $2\\times 1+2\\times 2+3\\times 3+2\\times 4=2+4+9+8=23$ 的分数。\n\n所以最多可以获得 $25\\times 1+23\\times 1=48$ 的分数。\n\n样例2：\n\n最优解为玩两次第一关，一次第二关，一次第三关。\n\n可以获得 $10000 \\times 2+1 \\times 1+2 \\times 1=20003$ 的分数。\n\n---\n\n【数据范围】\n\n对于 $10\\%$ 的数据，$1 \\le n \\le 10 , 1 \\le k_i,m_i,s_i,y_{i,j} \\le 100 , 1 \\le t \\le 100$。\n\n对于另外 $40\\%$ 的数据，$1 \\le n \\le 100 , 1 \\le k_i,m_i,s_i,y_{i,j} \\le 100 , 1 \\le t \\le 10^4$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 200 , 1 \\le k_i,m_i,s_i,y_{i,j} \\le 500,1 \\le t \\le 10^5,1\\le c_i\\le k_i$。\n\n---\n\n【说明/提示】\n\n- 尝试理解样例\n\n---\n\n【文件读入读出】**（模拟，提交代码时不需使用）**\n\n- 文件名：`play.cpp`\n- 读入文件名：`play.in`\n- 读出文件名：`play.out`", "locale": "zh-CN"}}}
