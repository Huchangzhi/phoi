{"pid": "P8499", "type": "P", "difficulty": 6, "samples": [["0 3 1\n3\n2 -1 2\n2\n-1 1\n4\n3 3 -1 3\n3\n2 3 -1\n5\n-1 1 5 5 1\n5\n2 3 -1 3 2\n", "Yes\nNo\nYes\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "NOI", "O2优化"], "title": "[NOI2022] 挑战 NPC Ⅱ", "background": "", "description": "诸由杨是一名咸鱼大学生，虽然他每天仍然幻想着在多项式时间内解决 NPC 问题。\n\n诸由杨上课的时候了解到子图同构问题是一个 NPC 问题。他打算给出一个子图同构问题的多项式判定算法，间接地去证明 P = NP，这样他一定可以凭借这个伟大的工作荣获图灵奖！只可惜诸由杨才疏学浅，连子图同构问题属于 NPC 的证明都没有想出来。因而他退而求其次，准备判定一个更加简单的问题：\n\n给定两棵有根树 $G, H$。设 $\\lvert G \\rvert$ 代表树 $G$ 中的节点个数，则这两棵树满足如下限制：$1 \\leq \\lvert H \\rvert \\leq \\lvert G \\rvert \\leq \\lvert H \\rvert + k$。这里诸由杨保证 $k$ 是一个小常数。\n\n诸由杨可以删除 $G$ 中的若干个节点，假定删除节点后后得到的子图为 $G'$。他想要知道是否存在一种删除节点的方式，使得删除后得到的子图 $G'$ 满足如下条件：\n\n- $G'$ 连通。\n- $G'$ 包含 $G$ 中的根节点（也就是说 $G$ 根节点在删除过程中没有被删除）。\n- $G'$ 和 $H$ 同构（也就是说存在一种让 $G'$ 中点重标号的方式，使得重标号得到的图和 $H$ 完全相同，且 $G$ 中的根节点经过重标号后恰好为 $H$ 的根节点）。", "inputFormat": "本题有多组测试数据。\n\n输入的第一行依次包含两个正整数 $C,T$ 和一个非负整数 $k$，三个数字分别表示当前测试点编号，测试数据组数和题目中给定的常数。如果当前测试数据为样例则 $C = 0$。保证 $T \\leq 500$、$k \\leq 5$。\n\n对于每一组测试数据：\n\n输入的第一行包含一个正整数 $n_1$，表示树 $G$ 中的节点个数，保证 $1 \\leq n_1 \\leq {10}^5$，且 $\\sum n_1 \\leq 5 \\times {10}^5$。\n\n输入的第二行包含 $n_1$ 个整数，描述了树 $G$ 的结构。具体地，第 $i$（$1 \\leq i \\leq n_1$）个整数 $a_i$ 表示在树 $G$ 中节点 $i$ 的父节点，如果其为根节点则 $a_i = -1$。保证按照上述规则得到的树为连通有根树。\n\n输入的第三行包含一个正整数 $n_2$，表示 $H$ 中的节点个数，保证对于所有测试数据，满足 $\\max(1, n_1 - k) \\leq n_2 \\leq n_1$。\n\n输入的第四行包含 $n_2$ 个整数，描述了树 $H$ 的结构。具体地，第 $i$（$1 \\leq i \\leq n_2$）个整数 $b_i$ 表示在树 $H$ 中节点 $i$ 的父节点，如果其为根节点则 $b_i = -1$。保证按照上述规则得到的树为连通有根树。", "outputFormat": "对于每一组测试数据：\n\n输出一行一个字符串。如果存在删除 $G$ 中节点的方式，使得其能够同时满足上述三个条件，则输出 `Yes`；否则输出 `No`。", "hint": "**【样例解释 \\#1】**\n\n对于第一个测试点，我们删除第一棵树的 $1$ 号节点。此时剩余的树和输入第二棵树均为包含两个节点的有根树，因而输出为 `Yes`。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vyoktd4u.png)\n\n\n对于第二个测试点，输入第一颗树深度为 $1$，但是输入第二颗树深度为 $2$。因而不论如何删除第一颗树的节点不会导致其树高增加到 $2$，因而输出为 `No`。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r1szu0zb.png)\n\n对于第三个测试点，其输入两颗树均同构于下图的树，因而因而输出为 `Yes`。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kxyllt4y.png)\n\n----\n\n**【样例 \\#2】**\n\n见附件中的 `iso/iso2.in` 与 `iso/iso2.ans`。\n\n该样例数据范围满足测试点 $7 \\sim 8$。\n\n----\n\n**【样例 \\#3】**\n\n见附件中的 `iso/iso3.in` 与 `iso/iso3.ans`。\n\n该样例数据范围满足测试点 $9 \\sim 10$。\n\n----\n\n**【样例 \\#4】**\n\n见附件中的 `iso/iso4.in` 与 `iso/iso4.ans`。\n\n该样例数据范围满足测试点 $13$。\n\n----\n\n**【数据范围】**\n\n对于所有测试数据，满足 $1 \\leq T \\leq 500$，$1 \\le n_2 \\leq n_1 \\le {10}^5$，$\\sum n_1 \\leq 5 \\times {10}^5$，$0 \\leq k \\leq 5$。各测试点的附加限制如下表所示：\n\n| $n_1,n_2$   | $\\sum n_1$           | 测试点           | $k$      | 特殊性质         |\n|:-----------:|:--------------------:|:-------------:|:--------:|:------------:|\n| $\\leq 8$    | $\\leq 500$           | $1 \\sim 3$       | $\\leq 0$ | 无            |\n| $\\leq 8$    | $\\leq 500$           | $4 \\sim 6$       | $\\leq 5$ | 无            |\n| $\\leq 16$   | $\\leq 10^3$          | $7 \\sim 8$         | $\\leq 0$ | 无            |\n| $\\leq 16$   | $\\leq 10^3$          | $9 \\sim 10$        | $\\leq 5$ | 无            |\n| $\\leq 150$  | $\\leq 10^4$          | $11$          | $\\leq 0$ | 无            |\n| $\\leq 150$  | $\\leq 10^4$          | $12$          | $\\leq 1$ | 无            |\n| $\\leq 150$  | $\\leq 10^4$          | $13$          | $\\leq 5$ | 无            |\n| $\\leq 10^5$ | $\\leq 5 \\times 10^5$ | $14 \\sim 16$    | $\\leq 0$ | A |\n| $\\leq 10^5$ | $\\leq 5 \\times 10^5$ | $17 \\sim 20$ | $\\leq 0$ | B  |\n| $\\leq 10^5$ | $\\leq 5 \\times 10^5$ | $21$          | $\\leq 1$ | 无            |\n| $\\leq 10^5$ | $\\leq 5 \\times 10^5$ | $22 \\sim 23$       | $\\leq 3$ | 无            |\n| $\\leq 10^5$ | $\\leq 5 \\times 10^5$ | $24 \\sim 25$       | $\\leq 5$ | 无            |\n\n其中附加限制中的特殊性质如下所示：\n\n- 特殊性质 A：保证有根树 $G$ 每个节点要么是叶节点，要么有恰好 $1$ 个儿子结点；另一种等价的表述是有根树 $G$ 构成了一条链，且根节点为链的一个端点。\n- 特殊性质 B：保证有根树 $G$ 每个节点要么是叶节点，要么有恰好 $2$ 个儿子结点，同时保证 $G$ 的每一个叶节点深度均相同；另一种等价的表述是有根树 $G$ 构成一棵完全二叉树，且根节点为完全二叉树的根节点。\n\n**【提示】**\n\n数据没有**针对任何合理的哈希算法做任何针对性的构造**，所以在合理范围内不需要过度担心因为哈希碰撞而产生的失分问题。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOI2022] 挑战 NPC Ⅱ", "background": "", "description": "诸由杨是一名咸鱼大学生，虽然他每天仍然幻想着在多项式时间内解决 NPC 问题。\n\n诸由杨上课的时候了解到子图同构问题是一个 NPC 问题。他打算给出一个子图同构问题的多项式判定算法，间接地去证明 P = NP，这样他一定可以凭借这个伟大的工作荣获图灵奖！只可惜诸由杨才疏学浅，连子图同构问题属于 NPC 的证明都没有想出来。因而他退而求其次，准备判定一个更加简单的问题：\n\n给定两棵有根树 $G, H$。设 $\\lvert G \\rvert$ 代表树 $G$ 中的节点个数，则这两棵树满足如下限制：$1 \\leq \\lvert H \\rvert \\leq \\lvert G \\rvert \\leq \\lvert H \\rvert + k$。这里诸由杨保证 $k$ 是一个小常数。\n\n诸由杨可以删除 $G$ 中的若干个节点，假定删除节点后后得到的子图为 $G'$。他想要知道是否存在一种删除节点的方式，使得删除后得到的子图 $G'$ 满足如下条件：\n\n- $G'$ 连通。\n- $G'$ 包含 $G$ 中的根节点（也就是说 $G$ 根节点在删除过程中没有被删除）。\n- $G'$ 和 $H$ 同构（也就是说存在一种让 $G'$ 中点重标号的方式，使得重标号得到的图和 $H$ 完全相同，且 $G$ 中的根节点经过重标号后恰好为 $H$ 的根节点）。", "inputFormat": "本题有多组测试数据。\n\n输入的第一行依次包含两个正整数 $C,T$ 和一个非负整数 $k$，三个数字分别表示当前测试点编号，测试数据组数和题目中给定的常数。如果当前测试数据为样例则 $C = 0$。保证 $T \\leq 500$、$k \\leq 5$。\n\n对于每一组测试数据：\n\n输入的第一行包含一个正整数 $n_1$，表示树 $G$ 中的节点个数，保证 $1 \\leq n_1 \\leq {10}^5$，且 $\\sum n_1 \\leq 5 \\times {10}^5$。\n\n输入的第二行包含 $n_1$ 个整数，描述了树 $G$ 的结构。具体地，第 $i$（$1 \\leq i \\leq n_1$）个整数 $a_i$ 表示在树 $G$ 中节点 $i$ 的父节点，如果其为根节点则 $a_i = -1$。保证按照上述规则得到的树为连通有根树。\n\n输入的第三行包含一个正整数 $n_2$，表示 $H$ 中的节点个数，保证对于所有测试数据，满足 $\\max(1, n_1 - k) \\leq n_2 \\leq n_1$。\n\n输入的第四行包含 $n_2$ 个整数，描述了树 $H$ 的结构。具体地，第 $i$（$1 \\leq i \\leq n_2$）个整数 $b_i$ 表示在树 $H$ 中节点 $i$ 的父节点，如果其为根节点则 $b_i = -1$。保证按照上述规则得到的树为连通有根树。", "outputFormat": "对于每一组测试数据：\n\n输出一行一个字符串。如果存在删除 $G$ 中节点的方式，使得其能够同时满足上述三个条件，则输出 `Yes`；否则输出 `No`。", "hint": "**【样例解释 \\#1】**\n\n对于第一个测试点，我们删除第一棵树的 $1$ 号节点。此时剩余的树和输入第二棵树均为包含两个节点的有根树，因而输出为 `Yes`。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vyoktd4u.png)\n\n\n对于第二个测试点，输入第一颗树深度为 $1$，但是输入第二颗树深度为 $2$。因而不论如何删除第一颗树的节点不会导致其树高增加到 $2$，因而输出为 `No`。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r1szu0zb.png)\n\n对于第三个测试点，其输入两颗树均同构于下图的树，因而因而输出为 `Yes`。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kxyllt4y.png)\n\n----\n\n**【样例 \\#2】**\n\n见附件中的 `iso/iso2.in` 与 `iso/iso2.ans`。\n\n该样例数据范围满足测试点 $7 \\sim 8$。\n\n----\n\n**【样例 \\#3】**\n\n见附件中的 `iso/iso3.in` 与 `iso/iso3.ans`。\n\n该样例数据范围满足测试点 $9 \\sim 10$。\n\n----\n\n**【样例 \\#4】**\n\n见附件中的 `iso/iso4.in` 与 `iso/iso4.ans`。\n\n该样例数据范围满足测试点 $13$。\n\n----\n\n**【数据范围】**\n\n对于所有测试数据，满足 $1 \\leq T \\leq 500$，$1 \\le n_2 \\leq n_1 \\le {10}^5$，$\\sum n_1 \\leq 5 \\times {10}^5$，$0 \\leq k \\leq 5$。各测试点的附加限制如下表所示：\n\n| $n_1,n_2$   | $\\sum n_1$           | 测试点           | $k$      | 特殊性质         |\n|:-----------:|:--------------------:|:-------------:|:--------:|:------------:|\n| $\\leq 8$    | $\\leq 500$           | $1 \\sim 3$       | $\\leq 0$ | 无            |\n| $\\leq 8$    | $\\leq 500$           | $4 \\sim 6$       | $\\leq 5$ | 无            |\n| $\\leq 16$   | $\\leq 10^3$          | $7 \\sim 8$         | $\\leq 0$ | 无            |\n| $\\leq 16$   | $\\leq 10^3$          | $9 \\sim 10$        | $\\leq 5$ | 无            |\n| $\\leq 150$  | $\\leq 10^4$          | $11$          | $\\leq 0$ | 无            |\n| $\\leq 150$  | $\\leq 10^4$          | $12$          | $\\leq 1$ | 无            |\n| $\\leq 150$  | $\\leq 10^4$          | $13$          | $\\leq 5$ | 无            |\n| $\\leq 10^5$ | $\\leq 5 \\times 10^5$ | $14 \\sim 16$    | $\\leq 0$ | A |\n| $\\leq 10^5$ | $\\leq 5 \\times 10^5$ | $17 \\sim 20$ | $\\leq 0$ | B  |\n| $\\leq 10^5$ | $\\leq 5 \\times 10^5$ | $21$          | $\\leq 1$ | 无            |\n| $\\leq 10^5$ | $\\leq 5 \\times 10^5$ | $22 \\sim 23$       | $\\leq 3$ | 无            |\n| $\\leq 10^5$ | $\\leq 5 \\times 10^5$ | $24 \\sim 25$       | $\\leq 5$ | 无            |\n\n其中附加限制中的特殊性质如下所示：\n\n- 特殊性质 A：保证有根树 $G$ 每个节点要么是叶节点，要么有恰好 $1$ 个儿子结点；另一种等价的表述是有根树 $G$ 构成了一条链，且根节点为链的一个端点。\n- 特殊性质 B：保证有根树 $G$ 每个节点要么是叶节点，要么有恰好 $2$ 个儿子结点，同时保证 $G$ 的每一个叶节点深度均相同；另一种等价的表述是有根树 $G$ 构成一棵完全二叉树，且根节点为完全二叉树的根节点。\n\n**【提示】**\n\n数据没有**针对任何合理的哈希算法做任何针对性的构造**，所以在合理范围内不需要过度担心因为哈希碰撞而产生的失分问题。", "locale": "zh-CN"}}}
{"pid": "P8500", "type": "P", "difficulty": 7, "samples": [["1\n3 2\n1 1 2022\n2 3 39\n", "1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "线段树", "并查集", "树状数组", "2022", "NOI", "离散化", "O2优化", "扫描线"], "title": "[NOI2022] 冒泡排序", "background": "最近，小 Z 对冒泡排序产生了浓厚的兴趣。\n\n下面是冒泡排序的伪代码：\n\n```\n输入: 一个长度为 n 的序列 a[1...n]\n输出: a 从小到大排序后的结果\nfor i = 1 to n do:\n    for j = 1 to n - 1 do\n        if (a[j] > a[j + 1])\n            交换 a[j] 与 a[j + 1] 的值\n```\n\n冒泡排序的交换次数被定义为在排序时**进行交换的次数**，也就是上面冒泡排序伪代码**第六行**的执行次数。他希望找到一个交换次数尽量少的序列。", "description": "小 Z 所研究的序列均由非负整数构成。它的长度为 $n$，且必须满足 $m$ 个附加条件。其中第 $i$ 个条件为：下标在 $[L_i, R_i]$ 中的数，即 $a_{L_i}, a_{L_{i+1}},\\dots,a_{R_i}$ 这些数，其最小值**恰好为 $\\boldsymbol{V_i}$**。\n\n他知道冒泡排序时常会超时。所以，他想要知道，在所有满足附加条件的序列中，进行冒泡排序的交换次数的最少值是多少。", "inputFormat": "本题有多组数据。\n\n输入的第一行包含一个正整数 $T$。\n\n对于每组数据，第一行包含两个正整数 $n,m$。数据保证 $1 \\leq n,m \\leq 10^6$。\n\n接下来 $m$ 行，每行三个非负整数 $L_i, R_i, V_i$，表示一组附加条件。数据保证 $1 \\leq L_i \\leq R_i \\leq n$、$0 \\leq V_i \\leq 10^9$。\n", "outputFormat": "输出共 $T$ 行，每行一个整数。\n\n对于每组数据，如果存在满足这 $m$ 个附加条件的序列，则输出在所有满足附加条件的序列中，冒泡排序交换次数的最小值。如果不存在满足所有条件的序列，则输出 $-1$。", "hint": "**【样例解释 \\#1】**\n\n这组数据的约束条件为 $a_1 = 2022, \\min\\{a_2, a_3\\} = 39$。\n\n若 $a_2 = 39$，且 $39 \\leq a_3 < 2022$，则冒泡排序只有第一轮有交换操作，这一轮交换了 $a_1, a_2$ 和 $a_2, a_3$，总交换次数为 $2$。\n\n若 $a_2 = 39$，且 $a_3 \\geq 2022$，则冒泡排序只有第一轮有交换操作，这一轮仅仅交换 $a_1, a_2$，总交换次数为 $1$。\n\n若 $a_3 = 39$，且 $39 < a_2 < 2022$，则冒泡排序算法第一轮交换 $a_1, a_2$ 和 $a_2, a_3$，第二轮交换 $a_1, a_2$。总交换次数为 $3$。\n\n若 $a_3 = 39$，且 $a_2 \\geq 2022$，则冒泡排序算法第一轮交换 $a_2, a_3$，第二轮交换 $a_1, a_2$。总交换次数为 $2$。\n\n因此，交换次数的最小值为 $1$。\n\n----\n\n**【样例 \\#2】**\n\n见附件中的 `bubble/bubble2.in` 与 `bubble/bubble2.ans`。\n\n----\n\n**【样例 \\#3】**\n\n见附件中的 `bubble/bubble3.in` 与 `bubble/bubble3.ans`。\n\n这个样例满足测试点 $8 \\sim 10$ 的条件。\n\n----\n\n**【样例 \\#4】**\n\n见附件中的 `bubble/bubble4.in` 与 `bubble/bubble4.ans`。\n\n这个样例满足测试点 $13 \\sim 14$ 的条件。\n\n----\n\n**【样例 \\#5】**\n\n见附件中的 `bubble/bubble5.in` 与 `bubble/bubble5.ans`。\n\n这个样例满足测试点 $15 \\sim 16$ 的条件。\n\n----\n\n**【样例 \\#6】**\n\n见附件中的 `bubble/bubble6.in` 与 `bubble/bubble6.ans`。\n\n这个样例满足测试点 $23 \\sim 25$ 的条件。\n\n----\n\n**【数据范围】**\n\n本题共 $25$ 个测试点。全部测试点满足：$1 \\leq T \\leq 1000$，$1 \\leq \\sum n, \\sum m \\leq 10^6$，$1 \\leq L_i \\leq R_i \\leq n$，$0 \\leq V_i \\leq 10^9$。\n\n其中 $\\sum n, \\sum m$ 分别表示所有测试点的 $n$ 的总和和 $m$ 的总和。$\\sum n^2, \\sum m^2, \\sum n^3, \\sum m^3$ 的含义类似。\n\n| 测试点          | 数据范围                                                   | 特殊性质         |\n|:------------:|:------------------------------------------------------:|:------------:|\n| $1 \\sim 4$   | $n,m \\leq 7$，且最多 $2$ 组数据不满足 $n, m \\leq 5$              |              |\n| $5 \\sim 7$   | $n,m \\leq 17$，且最多 $3$ 组数据不满足 $n, m \\leq 9$             | A |\n| $8 \\sim 10$  | $n,m \\leq 100$，$\\sum n^3,\\sum m^3 \\leq 4 \\times 10^7$  | A |\n| $11 \\sim 12$ | $n,m \\leq 2000$，$\\sum n^2,\\sum m^2 \\leq 4 \\times 10^7$ | A |\n| $13 \\sim 14$ | $n,m \\leq 2000$，$\\sum n^2,\\sum m^2 \\leq 4 \\times 10^7$ | B |\n| $15 \\sim 16$ | $n,m \\leq 2000$，$\\sum n^2,\\sum m^2 \\leq 4 \\times 10^7$ | C |\n| $17 \\sim 18$ | $n,m \\leq 2000$，$\\sum n^2,\\sum m^2 \\leq 4 \\times 10^7$ |              |\n| $19$         | $\\sum n,\\sum m \\leq 10^6$                              | A |\n| $20$         | $\\sum n,\\sum m \\leq 10^6$                              | B |\n| $21 \\sim 22$ | $\\sum n,\\sum m \\leq 10^6$                              | C |\n| $23 \\sim 25$ | $\\sum n,\\sum m \\leq 10^6$                              |              |\n\n特殊性质 A：对于 $1 \\leq i \\leq m$，$0 \\leq V_i \\leq 1$。  \n特殊性质 B：对于 $1 \\leq i \\leq m$，$L_i = R_i$。  \n特殊性质 C：输入给出的 $m$ 个区间 $[L_i, R_i]$ 两两不相交。\n\n----\n\n**【提示】**\n\n本题的部分测试点输入量较大。我们建议你使用较为快速的读入方式。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOI2022] 冒泡排序", "background": "最近，小 Z 对冒泡排序产生了浓厚的兴趣。\n\n下面是冒泡排序的伪代码：\n\n```\n输入: 一个长度为 n 的序列 a[1...n]\n输出: a 从小到大排序后的结果\nfor i = 1 to n do:\n    for j = 1 to n - 1 do\n        if (a[j] > a[j + 1])\n            交换 a[j] 与 a[j + 1] 的值\n```\n\n冒泡排序的交换次数被定义为在排序时**进行交换的次数**，也就是上面冒泡排序伪代码**第六行**的执行次数。他希望找到一个交换次数尽量少的序列。", "description": "小 Z 所研究的序列均由非负整数构成。它的长度为 $n$，且必须满足 $m$ 个附加条件。其中第 $i$ 个条件为：下标在 $[L_i, R_i]$ 中的数，即 $a_{L_i}, a_{L_{i+1}},\\dots,a_{R_i}$ 这些数，其最小值**恰好为 $\\boldsymbol{V_i}$**。\n\n他知道冒泡排序时常会超时。所以，他想要知道，在所有满足附加条件的序列中，进行冒泡排序的交换次数的最少值是多少。", "inputFormat": "本题有多组数据。\n\n输入的第一行包含一个正整数 $T$。\n\n对于每组数据，第一行包含两个正整数 $n,m$。数据保证 $1 \\leq n,m \\leq 10^6$。\n\n接下来 $m$ 行，每行三个非负整数 $L_i, R_i, V_i$，表示一组附加条件。数据保证 $1 \\leq L_i \\leq R_i \\leq n$、$0 \\leq V_i \\leq 10^9$。\n", "outputFormat": "输出共 $T$ 行，每行一个整数。\n\n对于每组数据，如果存在满足这 $m$ 个附加条件的序列，则输出在所有满足附加条件的序列中，冒泡排序交换次数的最小值。如果不存在满足所有条件的序列，则输出 $-1$。", "hint": "**【样例解释 \\#1】**\n\n这组数据的约束条件为 $a_1 = 2022, \\min\\{a_2, a_3\\} = 39$。\n\n若 $a_2 = 39$，且 $39 \\leq a_3 < 2022$，则冒泡排序只有第一轮有交换操作，这一轮交换了 $a_1, a_2$ 和 $a_2, a_3$，总交换次数为 $2$。\n\n若 $a_2 = 39$，且 $a_3 \\geq 2022$，则冒泡排序只有第一轮有交换操作，这一轮仅仅交换 $a_1, a_2$，总交换次数为 $1$。\n\n若 $a_3 = 39$，且 $39 < a_2 < 2022$，则冒泡排序算法第一轮交换 $a_1, a_2$ 和 $a_2, a_3$，第二轮交换 $a_1, a_2$。总交换次数为 $3$。\n\n若 $a_3 = 39$，且 $a_2 \\geq 2022$，则冒泡排序算法第一轮交换 $a_2, a_3$，第二轮交换 $a_1, a_2$。总交换次数为 $2$。\n\n因此，交换次数的最小值为 $1$。\n\n----\n\n**【样例 \\#2】**\n\n见附件中的 `bubble/bubble2.in` 与 `bubble/bubble2.ans`。\n\n----\n\n**【样例 \\#3】**\n\n见附件中的 `bubble/bubble3.in` 与 `bubble/bubble3.ans`。\n\n这个样例满足测试点 $8 \\sim 10$ 的条件。\n\n----\n\n**【样例 \\#4】**\n\n见附件中的 `bubble/bubble4.in` 与 `bubble/bubble4.ans`。\n\n这个样例满足测试点 $13 \\sim 14$ 的条件。\n\n----\n\n**【样例 \\#5】**\n\n见附件中的 `bubble/bubble5.in` 与 `bubble/bubble5.ans`。\n\n这个样例满足测试点 $15 \\sim 16$ 的条件。\n\n----\n\n**【样例 \\#6】**\n\n见附件中的 `bubble/bubble6.in` 与 `bubble/bubble6.ans`。\n\n这个样例满足测试点 $23 \\sim 25$ 的条件。\n\n----\n\n**【数据范围】**\n\n本题共 $25$ 个测试点。全部测试点满足：$1 \\leq T \\leq 1000$，$1 \\leq \\sum n, \\sum m \\leq 10^6$，$1 \\leq L_i \\leq R_i \\leq n$，$0 \\leq V_i \\leq 10^9$。\n\n其中 $\\sum n, \\sum m$ 分别表示所有测试点的 $n$ 的总和和 $m$ 的总和。$\\sum n^2, \\sum m^2, \\sum n^3, \\sum m^3$ 的含义类似。\n\n| 测试点          | 数据范围                                                   | 特殊性质         |\n|:------------:|:------------------------------------------------------:|:------------:|\n| $1 \\sim 4$   | $n,m \\leq 7$，且最多 $2$ 组数据不满足 $n, m \\leq 5$              |              |\n| $5 \\sim 7$   | $n,m \\leq 17$，且最多 $3$ 组数据不满足 $n, m \\leq 9$             | A |\n| $8 \\sim 10$  | $n,m \\leq 100$，$\\sum n^3,\\sum m^3 \\leq 4 \\times 10^7$  | A |\n| $11 \\sim 12$ | $n,m \\leq 2000$，$\\sum n^2,\\sum m^2 \\leq 4 \\times 10^7$ | A |\n| $13 \\sim 14$ | $n,m \\leq 2000$，$\\sum n^2,\\sum m^2 \\leq 4 \\times 10^7$ | B |\n| $15 \\sim 16$ | $n,m \\leq 2000$，$\\sum n^2,\\sum m^2 \\leq 4 \\times 10^7$ | C |\n| $17 \\sim 18$ | $n,m \\leq 2000$，$\\sum n^2,\\sum m^2 \\leq 4 \\times 10^7$ |              |\n| $19$         | $\\sum n,\\sum m \\leq 10^6$                              | A |\n| $20$         | $\\sum n,\\sum m \\leq 10^6$                              | B |\n| $21 \\sim 22$ | $\\sum n,\\sum m \\leq 10^6$                              | C |\n| $23 \\sim 25$ | $\\sum n,\\sum m \\leq 10^6$                              |              |\n\n特殊性质 A：对于 $1 \\leq i \\leq m$，$0 \\leq V_i \\leq 1$。  \n特殊性质 B：对于 $1 \\leq i \\leq m$，$L_i = R_i$。  \n特殊性质 C：输入给出的 $m$ 个区间 $[L_i, R_i]$ 两两不相交。\n\n----\n\n**【提示】**\n\n本题的部分测试点输入量较大。我们建议你使用较为快速的读入方式。", "locale": "zh-CN"}}}
{"pid": "P8501", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "NOI", "网络流", "O2优化", "分治", "凸包", "整数规划"], "title": "[NOI2022] 二次整数规划问题", "background": "", "description": "本题中，你需要解决一个著名的 NP 问题——二次整数规划问题。\n\n二次整数规划问题要有变量：你需要给出一个长度为 $n$ 的**整数**序列 $(x_1, x_2, \\ldots, x_n)$，满足下文中的所有条件。\n\n二次整数规划问题要有约束：你给出的整数序列需要满足以下两类约束：\n\n1. 一类约束是单个变量取值的约束：给出正整数 $k$（$3 \\leq k \\leq 5$）和 $n$ 个区间 $[l_i, r_i]$（$1 \\leq i \\leq n$），其中 $1 \\leq l_i \\leq r_i \\leq k$，你给出的序列需要满足 $\\forall 1 \\leq i \\leq n$，$l_i \\leq x_i \\leq r_i$；\n2. 另一类约束是变量之间取值的约束：给出 $m$ 个三元组 $(p_i, q_i, b_i)$，你给出的序列需要满足 $\\forall 1 \\leq j \\leq m$，$\\lvert x_{p_j} - x_{q_j} \\rvert \\leq b_j$。\n\n二次整数规划问题要有目标函数：在给出 $k-2$ 个目标参数 $v_2,v_3,\\dots,v_{k-1}$（**注意下标范围为 $\\boldsymbol{2}$ 至 $\\boldsymbol{k-1}$**）的前提下，对于一个值域为 $[1,k]$ 的整数数列 $\\{p_1,p_2,\\dots,p_n\\}$，设 $c_i$ 为该序列中取值为 $i$ 的元素个数，$G$ 为满足 $1 \\leq i,j \\leq n$ 且 $|p_i-p_j|\\leq 1$ 的整数二元组 $(i, j)$ 个数，**注意当 $\\boldsymbol{i \\neq j}$ 时，$\\boldsymbol{(i, j)}$ 与 $\\boldsymbol{(j, i)}$ 是不同的二元组**。定义该序列的**权值**为\n\n$$ W(p_1, p_2, \\ldots, p_n) = 10^6 G+\\sum_{i=2}^{k-1} c_i v_i \\text{。} $$\n\n你的序列需要在满足以上两类约束的情况下，最大化其权值。在给出的约束下，保证存在满足约束的序列。\n\n二次整数规划问题不一定要有多组询问，但是我们会给出 $q$ 次询问，每次询问给出不同的权值参数 $v_2, v_3, \\ldots, v_{k-1}$，对于每组询问你需要找到满足约束的最大化权值的序列。为了减少输出量，你只需要输出这个序列的权值。", "inputFormat": "**本题有多组测试数据。** 第一行一个非负整数和一个正整数 $C, T$，分别表示测试点编号和测试数据数量。$C = 0$ 表示该组数据为样例。\n\n对于每组测试数据，第一行四个整数 $k, n, m, q$，描述序列值域、序列长度、变量之间约束的个数和询问次数。\n\n接下来 $n$ 行每行两个整数 $l_i, r_i$，描述序列中每个元素对应的取值区间。\n\n接下来 $m$ 行每行三个整数 $p_j, q_j, b_j$，描述一个变量之间的约束。\n\n接下来 $q$ 行每行 $k - 2$ 个非负整数 $v_2, v_3, \\ldots, v_{k - 1}$ 描述一组询问的权值参数。", "outputFormat": "对于每组数据的每组询问输出一行一个整数，表示序列权值的最大值。", "hint": "**【样例 \\#1】**\n\n见附件中的 `qip/qip1.in` 与 `qip/qip1.ans`。\n\n该样例满足数据范围中测试点 $1$ 的性质。\n\n----\n\n**【样例解释 \\#1】**\n\n第一个测试数据中两组询问对应的最优序列均为 $(1, 2, 2, 1, 3)$，有 $c_2 = 2, G = 21$。\n\n----\n\n**【样例 \\#2】**\n\n见附件中的 `qip/qip2.in` 与 `qip/qip2.ans`。\n\n该样例满足数据范围中测试点 $3$ 的性质。\n\n----\n\n**【样例解释 \\#2】**\n\n第一个测试数据中两组询问对应的最优序列分别为 $(4,4,3,3)$ 和 $(4,3,2,2)$。\n\n----\n\n**【样例 \\#3】**\n\n见附件中的 `qip/qip3.in` 与 `qip/qip3.ans`。\n\n该样例满足数据范围中测试点 $5$ 的性质。\n\n----\n\n**【样例解释 \\#3】**\n\n第一个测试数据中三组询问对应的一个最优序列分别为 $(3, 3, 3, 3, 3)$、$(2, 2, 3, 3, 2)$ 和 $(3, 2, 4, 4, 2)$。\n\n----\n\n**【样例 \\#4】**\n\n见附件中的 `qip/qip4.in` 与 `qip/qip4.ans`。\n\n该样例满足数据范围中测试点 $2$ 的性质。\n\n----\n\n**【样例 \\#5】**\n\n见附件中的 `qip/qip5.in` 与 `qip/qip5.ans`。\n\n该样例满足数据范围中测试点 $4$ 的性质。\n\n----\n\n**【样例 \\#6】**\n\n见附件中的 `qip/qip6.in` 与 `qip/qip6.ans`。\n\n该样例满足数据范围中测试点 $8$ 的性质。\n\n----\n\n**【样例 \\#7】**\n\n见附件中的 `qip/qip7.in` 与 `qip/qip7.ans`。\n\n该样例满足数据范围中测试点 $14$ 的性质。\n\n----\n\n**【样例 \\#8】**\n\n见附件中的 `qip/qip8.in` 与 `qip/qip8.ans`。\n\n该样例满足数据范围中测试点 $17$ 的性质。\n\n----\n\n**【数据范围】**\n\n设 $\\sum q$ 为单个测试点中所有测试数据的 $q$ 的和。对于所有测试点，\n\n- $1 \\leq T \\leq 600$，\n- 第 $i$（$1 \\le i \\le T$）个测试数据中，$1 \\leq n \\leq \\max(\\frac{T}{i},2 \\log_2 T)$，\n- $3 \\leq k \\leq 5$，$0 \\leq m \\leq 3n$，$1 \\leq q,\\sum q \\leq 3 \\times 10^5$，\n- $1 \\leq l_i \\leq r_i \\leq k$，\n- $1 \\leq p_j,q_j \\leq n$，$0 \\leq b_j<k$，\n- $0 \\leq v_2,\\dots,v_{k-1} \\leq 10^{12}$。\n\n| 测试点编号 | $T \\leq$ | $k=$ | $\\sum q \\leq$   | 特殊性质         | 测试点分数 |\n|:-----:|:--------:|:----:|:---------------:|:------------:|:-----:|\n| $1$   | $10$     | $3$  | $200$           | 无            | $4$   |\n| $2$   | $600$    | $3$  | $3 \\times 10^5$ | 无            | $6$   |\n| $3$   | $10$     | $4$  | $200$           | 无            | $4$   |\n| $4$   | $600$    | $4$  | $3 \\times 10^5$ | 无            | $6$   |\n| $5$   | $10$     | $5$  | $300$           | 无            | $5$   |\n| $6$   | $15$     | $5$  | $500$           | 无            | $4$   |\n| $7$   | $25$     | $5$  | $750$           | 无            | $4$   |\n| $8$   | $50$     | $5$  | $1000$          | 无            | $6$   |\n| $9$   | $80$     | $5$  | $1500$          | 无            | $6$   |\n| $10$  | $120$    | $5$  | $2000$          | 无            | $5$   |\n| $11$  | $200$    | $5$  | $8000$          | A | $3$   |\n| $12$  | $400$    | $5$  | $3 \\times 10^4$ | A | $4$   |\n| $13$  | $600$    | $5$  | $2 \\times 10^5$ | A | $5$   |\n| $14$  | $200$    | $5$  | $8000$          | B | $3$   |\n| $15$  | $400$    | $5$  | $3 \\times 10^4$ | B | $4$   |\n| $16$  | $600$    | $5$  | $2 \\times 10^5$ | B | $4$   |\n| $17$  | $120$    | $5$  | $10^5$          | C | $4$   |\n| $18$  | $150$    | $5$  | $2 \\times 10^5$ | C | $5$   |\n| $19$  | $180$    | $5$  | $3 \\times 10^5$ | C | $5$   |\n| $20$  | $300$    | $5$  | $5 \\times 10^4$ | 无            | $5$   |\n| $21$  | $450$    | $5$  | $10^5$          | 无            | $4$   |\n| $22$  | $600$    | $5$  | $3 \\times 10^5$ | 无            | $4$   |\n\n特殊性质 A：$m=0$。\n\n特殊性质 B：$m \\leq 10$，单个测试点中所有测试数据的 $m$ 的和不超过 $200$。\n\n特殊性质 C：数据随机生成。具体地，生成测试点中每组测试数据时，给出参数 $k,n,m,q$ 以及 $k$ 个非负常数 $p_0,p_1,p_2,\\dots,p_{k-1}$，保证 $p_{k-1} \\neq 0$，则按照如下规则生成该组数据：\n\n- 对于 $1 \\leq i \\leq n$，独立均匀生成 $x,y \\in [1,k]$，则 $l_i=\\min(x,y),r_i=\\max(x,y)$；\n- 不断按照如下方式生成三元组直至有 $m$ 个三元组：\n  1. 独立均匀随机生成 $u,v \\in [1,n]$；\n  2. 以 $p$ 为权值随机生成 $w$（对于 $0 \\leq i \\leq k-1$，$w=i$ 的概率为 $\\frac{p_i}{p_0+p_1+\\dots+p_{k-1}}$）；\n  3. 若在原有三元组集合中加入 $(u,v,w)$ 后不存在序列 $(x_1,x_2,\\dots,x_n)$ 满足所有限制，则舍弃当前三元组，否则加入当前三元组。\n- 每组询问的 $v_2, \\ldots, v_{k-1}$ 在 $[0,10^{12}]$ 内独立均匀随机生成。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOI2022] 二次整数规划问题", "background": "", "description": "本题中，你需要解决一个著名的 NP 问题——二次整数规划问题。\n\n二次整数规划问题要有变量：你需要给出一个长度为 $n$ 的**整数**序列 $(x_1, x_2, \\ldots, x_n)$，满足下文中的所有条件。\n\n二次整数规划问题要有约束：你给出的整数序列需要满足以下两类约束：\n\n1. 一类约束是单个变量取值的约束：给出正整数 $k$（$3 \\leq k \\leq 5$）和 $n$ 个区间 $[l_i, r_i]$（$1 \\leq i \\leq n$），其中 $1 \\leq l_i \\leq r_i \\leq k$，你给出的序列需要满足 $\\forall 1 \\leq i \\leq n$，$l_i \\leq x_i \\leq r_i$；\n2. 另一类约束是变量之间取值的约束：给出 $m$ 个三元组 $(p_i, q_i, b_i)$，你给出的序列需要满足 $\\forall 1 \\leq j \\leq m$，$\\lvert x_{p_j} - x_{q_j} \\rvert \\leq b_j$。\n\n二次整数规划问题要有目标函数：在给出 $k-2$ 个目标参数 $v_2,v_3,\\dots,v_{k-1}$（**注意下标范围为 $\\boldsymbol{2}$ 至 $\\boldsymbol{k-1}$**）的前提下，对于一个值域为 $[1,k]$ 的整数数列 $\\{p_1,p_2,\\dots,p_n\\}$，设 $c_i$ 为该序列中取值为 $i$ 的元素个数，$G$ 为满足 $1 \\leq i,j \\leq n$ 且 $|p_i-p_j|\\leq 1$ 的整数二元组 $(i, j)$ 个数，**注意当 $\\boldsymbol{i \\neq j}$ 时，$\\boldsymbol{(i, j)}$ 与 $\\boldsymbol{(j, i)}$ 是不同的二元组**。定义该序列的**权值**为\n\n$$ W(p_1, p_2, \\ldots, p_n) = 10^6 G+\\sum_{i=2}^{k-1} c_i v_i \\text{。} $$\n\n你的序列需要在满足以上两类约束的情况下，最大化其权值。在给出的约束下，保证存在满足约束的序列。\n\n二次整数规划问题不一定要有多组询问，但是我们会给出 $q$ 次询问，每次询问给出不同的权值参数 $v_2, v_3, \\ldots, v_{k-1}$，对于每组询问你需要找到满足约束的最大化权值的序列。为了减少输出量，你只需要输出这个序列的权值。", "inputFormat": "**本题有多组测试数据。** 第一行一个非负整数和一个正整数 $C, T$，分别表示测试点编号和测试数据数量。$C = 0$ 表示该组数据为样例。\n\n对于每组测试数据，第一行四个整数 $k, n, m, q$，描述序列值域、序列长度、变量之间约束的个数和询问次数。\n\n接下来 $n$ 行每行两个整数 $l_i, r_i$，描述序列中每个元素对应的取值区间。\n\n接下来 $m$ 行每行三个整数 $p_j, q_j, b_j$，描述一个变量之间的约束。\n\n接下来 $q$ 行每行 $k - 2$ 个非负整数 $v_2, v_3, \\ldots, v_{k - 1}$ 描述一组询问的权值参数。", "outputFormat": "对于每组数据的每组询问输出一行一个整数，表示序列权值的最大值。", "hint": "**【样例 \\#1】**\n\n见附件中的 `qip/qip1.in` 与 `qip/qip1.ans`。\n\n该样例满足数据范围中测试点 $1$ 的性质。\n\n----\n\n**【样例解释 \\#1】**\n\n第一个测试数据中两组询问对应的最优序列均为 $(1, 2, 2, 1, 3)$，有 $c_2 = 2, G = 21$。\n\n----\n\n**【样例 \\#2】**\n\n见附件中的 `qip/qip2.in` 与 `qip/qip2.ans`。\n\n该样例满足数据范围中测试点 $3$ 的性质。\n\n----\n\n**【样例解释 \\#2】**\n\n第一个测试数据中两组询问对应的最优序列分别为 $(4,4,3,3)$ 和 $(4,3,2,2)$。\n\n----\n\n**【样例 \\#3】**\n\n见附件中的 `qip/qip3.in` 与 `qip/qip3.ans`。\n\n该样例满足数据范围中测试点 $5$ 的性质。\n\n----\n\n**【样例解释 \\#3】**\n\n第一个测试数据中三组询问对应的一个最优序列分别为 $(3, 3, 3, 3, 3)$、$(2, 2, 3, 3, 2)$ 和 $(3, 2, 4, 4, 2)$。\n\n----\n\n**【样例 \\#4】**\n\n见附件中的 `qip/qip4.in` 与 `qip/qip4.ans`。\n\n该样例满足数据范围中测试点 $2$ 的性质。\n\n----\n\n**【样例 \\#5】**\n\n见附件中的 `qip/qip5.in` 与 `qip/qip5.ans`。\n\n该样例满足数据范围中测试点 $4$ 的性质。\n\n----\n\n**【样例 \\#6】**\n\n见附件中的 `qip/qip6.in` 与 `qip/qip6.ans`。\n\n该样例满足数据范围中测试点 $8$ 的性质。\n\n----\n\n**【样例 \\#7】**\n\n见附件中的 `qip/qip7.in` 与 `qip/qip7.ans`。\n\n该样例满足数据范围中测试点 $14$ 的性质。\n\n----\n\n**【样例 \\#8】**\n\n见附件中的 `qip/qip8.in` 与 `qip/qip8.ans`。\n\n该样例满足数据范围中测试点 $17$ 的性质。\n\n----\n\n**【数据范围】**\n\n设 $\\sum q$ 为单个测试点中所有测试数据的 $q$ 的和。对于所有测试点，\n\n- $1 \\leq T \\leq 600$，\n- 第 $i$（$1 \\le i \\le T$）个测试数据中，$1 \\leq n \\leq \\max(\\frac{T}{i},2 \\log_2 T)$，\n- $3 \\leq k \\leq 5$，$0 \\leq m \\leq 3n$，$1 \\leq q,\\sum q \\leq 3 \\times 10^5$，\n- $1 \\leq l_i \\leq r_i \\leq k$，\n- $1 \\leq p_j,q_j \\leq n$，$0 \\leq b_j<k$，\n- $0 \\leq v_2,\\dots,v_{k-1} \\leq 10^{12}$。\n\n| 测试点编号 | $T \\leq$ | $k=$ | $\\sum q \\leq$   | 特殊性质         | 测试点分数 |\n|:-----:|:--------:|:----:|:---------------:|:------------:|:-----:|\n| $1$   | $10$     | $3$  | $200$           | 无            | $4$   |\n| $2$   | $600$    | $3$  | $3 \\times 10^5$ | 无            | $6$   |\n| $3$   | $10$     | $4$  | $200$           | 无            | $4$   |\n| $4$   | $600$    | $4$  | $3 \\times 10^5$ | 无            | $6$   |\n| $5$   | $10$     | $5$  | $300$           | 无            | $5$   |\n| $6$   | $15$     | $5$  | $500$           | 无            | $4$   |\n| $7$   | $25$     | $5$  | $750$           | 无            | $4$   |\n| $8$   | $50$     | $5$  | $1000$          | 无            | $6$   |\n| $9$   | $80$     | $5$  | $1500$          | 无            | $6$   |\n| $10$  | $120$    | $5$  | $2000$          | 无            | $5$   |\n| $11$  | $200$    | $5$  | $8000$          | A | $3$   |\n| $12$  | $400$    | $5$  | $3 \\times 10^4$ | A | $4$   |\n| $13$  | $600$    | $5$  | $2 \\times 10^5$ | A | $5$   |\n| $14$  | $200$    | $5$  | $8000$          | B | $3$   |\n| $15$  | $400$    | $5$  | $3 \\times 10^4$ | B | $4$   |\n| $16$  | $600$    | $5$  | $2 \\times 10^5$ | B | $4$   |\n| $17$  | $120$    | $5$  | $10^5$          | C | $4$   |\n| $18$  | $150$    | $5$  | $2 \\times 10^5$ | C | $5$   |\n| $19$  | $180$    | $5$  | $3 \\times 10^5$ | C | $5$   |\n| $20$  | $300$    | $5$  | $5 \\times 10^4$ | 无            | $5$   |\n| $21$  | $450$    | $5$  | $10^5$          | 无            | $4$   |\n| $22$  | $600$    | $5$  | $3 \\times 10^5$ | 无            | $4$   |\n\n特殊性质 A：$m=0$。\n\n特殊性质 B：$m \\leq 10$，单个测试点中所有测试数据的 $m$ 的和不超过 $200$。\n\n特殊性质 C：数据随机生成。具体地，生成测试点中每组测试数据时，给出参数 $k,n,m,q$ 以及 $k$ 个非负常数 $p_0,p_1,p_2,\\dots,p_{k-1}$，保证 $p_{k-1} \\neq 0$，则按照如下规则生成该组数据：\n\n- 对于 $1 \\leq i \\leq n$，独立均匀生成 $x,y \\in [1,k]$，则 $l_i=\\min(x,y),r_i=\\max(x,y)$；\n- 不断按照如下方式生成三元组直至有 $m$ 个三元组：\n  1. 独立均匀随机生成 $u,v \\in [1,n]$；\n  2. 以 $p$ 为权值随机生成 $w$（对于 $0 \\leq i \\leq k-1$，$w=i$ 的概率为 $\\frac{p_i}{p_0+p_1+\\dots+p_{k-1}}$）；\n  3. 若在原有三元组集合中加入 $(u,v,w)$ 后不存在序列 $(x_1,x_2,\\dots,x_n)$ 满足所有限制，则舍弃当前三元组，否则加入当前三元组。\n- 每组询问的 $v_2, \\ldots, v_{k-1}$ 在 $[0,10^{12}]$ 内独立均匀随机生成。", "locale": "zh-CN"}}}
{"pid": "P8502", "type": "P", "difficulty": 5, "samples": [["4 5\n2 3\n1 1\n2 4\n0 0\n1 3 4 5\n1 4 2 4\n2 3 1 2\n4 4 3 0\n1 3 2 5", "5\n1\n0\n1\n1"], ["10 10\n6 6\n4 10\n2 5\n1 7\n3 4\n5 7\n4 10\n1 7\n1 3\n2 5\n8 8 5 1\n4 7 5 3\n5 9 4 4\n1 5 5 2\n6 2 10 2\n3 3 7 4\n1 10 1 2\n6 2 4 4\n9 2 1 4\n9 10 3 2", "0\n17\n2\n0\n0\n46\n0\n12\n23\n1"], ["10 10\n2 6\n6 9\n5 7\n3 9\n0 0\n0 0\n3 5\n5 5\n3 6\n1 10\n5 9 6 3\n10 8 6 4\n10 8 5 1\n8 6 5 4\n7 2 5 4\n6 1 5 3\n10 4 5 1\n5 5 6 0\n7 9 6 4\n4 9 6 2", "0\n17\n1\n0\n0\n0\n1\n1\n4\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "O2优化", "容斥原理", "差分"], "title": "「CGOI-2」No cost too great", "background": "光芒浸透圣巢，她正犯下弥天之错。\n\n所剩寥寥无几的信仰，为什么始终执着。\n\n我将作灯塔，照耀王国。\n\n但在那之前有更重要的事去做，\n\n无论什么代价都在所不惜，尽管我所剩无多……", "description": "白王正在最后一次参观他建造的宏伟宫殿。现在假设宫殿由 $n$ 个房间构成，房间之间有若干个**单向**通道。出于白王奇怪的装修癖好（不是指到处安电锯），对于第 $i$ 个房间，它向编号在区间 $[l_i,r_i]$ 中的所有房间都连有一条单向通道。例如，$4$ 号房间向 $[2,5]$ 连有单向通道，就意味着从 $4$ 号房间到 $2,3,4,5$ 号房间各有一条单向通道（一个房间可以向自己连有通道）。当一个房间向 $[0,0]$ 连有通道时，表示没有从这个房间出发的通道。\n\n白王提出了 $q$ 个问题，每次询问从 $a$ 号房间，通过恰好 $m$ 条单向通道且不经过 $c$ 号房间到达 $b$ 号房间的方案数（两方案不同，当且仅当存在 $i$ 使得两方案通过的第 $i$ 条通道不同）。因为这个数字可能会很大，所以白王让你将答案模 $998244353$ 后再回答。", "inputFormat": "第一行，两个整数 $n, q$ 表示点数和询问数。\n\n接下来 $n$ 行，每行两个整数 $l, r$，第 $i+1$ 行的整数 $l_i, r_i$ 表示 $i$ 号节点向区间 $[l_i, r_i]$ 中的每个点都连了一条单向边。当 $l_i=r_i=0$ 时，表示该节点没有向任何点连边。\n\n接下来 $q$ 行，每行四个整数 $a, b, c, m$ 表示一个询问。", "outputFormat": "$q$ 行，每行一个整数，第 $i$ 行的数字表示第 $i$ 个询问的方案数模 $998244353$ 的结果。", "hint": "### 样例说明\n\n在样例一中，$1$ 号房间能到达 $2,3$ 号房间，$2$ 号房间能到达 $1$ 号房间，$3$ 号房间能到达 $2,3,4$ 号房间，$4$ 号房间不能到达任何房间。\n\n对于第一个询问，从 $1$ 号房间经过 $5$ 条通道且不经过 $4$ 号房间到达 $3$ 号房间的方案有 `121213`，`121333`，`133213`，`132133`，`133333` 共五种。\n\n---\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n| 编号| 特殊性质 | 空间限制 |分数 |\n| :-: | :-: | :-: | :-: |\n| 0 | $n\\le10$，$q\\le10$，$m\\le4$ | 256MB | 10pts |\n| 1 | $n\\le100$，$q\\le10^4$，$m\\le40$ | 256MB | 15pts |\n| 2 | 对于所有询问，$l_c=r_c=0$ | 256MB | 15pts |\n| 3 | 无 | 256MB | 30pts |\n| 4 | 无 | 128MB | 30pts |\n\n对于 $100\\%$ 的数据，$1\\le n \\le 500$，$1\\le q \\le 10^5$，$1\\le m \\le 100$，$0 \\le l_i \\le r_i \\le n$，$1 \\le a,b,c \\le n$。当且仅当 $l_i=0$ 时 $r_i=0$。时间限制均为 1s。\n\n---\n\n### 提示\n\n**注意空间常数。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「CGOI-2」No cost too great", "background": "光芒浸透圣巢，她正犯下弥天之错。\n\n所剩寥寥无几的信仰，为什么始终执着。\n\n我将作灯塔，照耀王国。\n\n但在那之前有更重要的事去做，\n\n无论什么代价都在所不惜，尽管我所剩无多……", "description": "白王正在最后一次参观他建造的宏伟宫殿。现在假设宫殿由 $n$ 个房间构成，房间之间有若干个**单向**通道。出于白王奇怪的装修癖好（不是指到处安电锯），对于第 $i$ 个房间，它向编号在区间 $[l_i,r_i]$ 中的所有房间都连有一条单向通道。例如，$4$ 号房间向 $[2,5]$ 连有单向通道，就意味着从 $4$ 号房间到 $2,3,4,5$ 号房间各有一条单向通道（一个房间可以向自己连有通道）。当一个房间向 $[0,0]$ 连有通道时，表示没有从这个房间出发的通道。\n\n白王提出了 $q$ 个问题，每次询问从 $a$ 号房间，通过恰好 $m$ 条单向通道且不经过 $c$ 号房间到达 $b$ 号房间的方案数（两方案不同，当且仅当存在 $i$ 使得两方案通过的第 $i$ 条通道不同）。因为这个数字可能会很大，所以白王让你将答案模 $998244353$ 后再回答。", "inputFormat": "第一行，两个整数 $n, q$ 表示点数和询问数。\n\n接下来 $n$ 行，每行两个整数 $l, r$，第 $i+1$ 行的整数 $l_i, r_i$ 表示 $i$ 号节点向区间 $[l_i, r_i]$ 中的每个点都连了一条单向边。当 $l_i=r_i=0$ 时，表示该节点没有向任何点连边。\n\n接下来 $q$ 行，每行四个整数 $a, b, c, m$ 表示一个询问。", "outputFormat": "$q$ 行，每行一个整数，第 $i$ 行的数字表示第 $i$ 个询问的方案数模 $998244353$ 的结果。", "hint": "### 样例说明\n\n在样例一中，$1$ 号房间能到达 $2,3$ 号房间，$2$ 号房间能到达 $1$ 号房间，$3$ 号房间能到达 $2,3,4$ 号房间，$4$ 号房间不能到达任何房间。\n\n对于第一个询问，从 $1$ 号房间经过 $5$ 条通道且不经过 $4$ 号房间到达 $3$ 号房间的方案有 `121213`，`121333`，`133213`，`132133`，`133333` 共五种。\n\n---\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n| 编号| 特殊性质 | 空间限制 |分数 |\n| :-: | :-: | :-: | :-: |\n| 0 | $n\\le10$，$q\\le10$，$m\\le4$ | 256MB | 10pts |\n| 1 | $n\\le100$，$q\\le10^4$，$m\\le40$ | 256MB | 15pts |\n| 2 | 对于所有询问，$l_c=r_c=0$ | 256MB | 15pts |\n| 3 | 无 | 256MB | 30pts |\n| 4 | 无 | 128MB | 30pts |\n\n对于 $100\\%$ 的数据，$1\\le n \\le 500$，$1\\le q \\le 10^5$，$1\\le m \\le 100$，$0 \\le l_i \\le r_i \\le n$，$1 \\le a,b,c \\le n$。当且仅当 $l_i=0$ 时 $r_i=0$。时间限制均为 1s。\n\n---\n\n### 提示\n\n**注意空间常数。**", "locale": "zh-CN"}}}
{"pid": "P8503", "type": "P", "difficulty": 6, "samples": [["7\n1 7\n7 6\n1 2\n2 3\n3 4\n4 5\n5 6", "1\n2\n3\n4\n5\n10"], ["6\n1 4\n4 2\n2 6\n6 1\n6 3\n1 5", "2\n4\n7\n9\n11"], ["18\n14 15\n8 12\n5 4\n10 14\n15 17\n7 5\n3 9\n9 18\n11 13\n1 2\n16 10\n5 11\n5 6\n6 8\n2 3\n2 7\n18 16\n7 10", "1\n2\n6\n7\n8\n10\n13\n19\n22\n26\n30\n35\n40\n41\n45\n49\n54"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "O2优化", "基环树"], "title": "「CGOI-2」No mind to think", "background": "“我的王，这个孩子……不纯粹……他……”\n\n“嗯。容器不能拥有与人交流的能力，否则可能会在交流中产生思维。它们只应该有猎杀的本能，和战斗的天分。就像我的守卫们一样。”\n\n“那些不过是傀儡……”\n\n“傀儡也比这个有思维的家伙好。改天把它带走，它真的好吵……我累了，我出去走走。”\n\n~~无敌的勇敢的性感的神秘的迷人的神气的勤勉的强势的华丽的激情的可怕的漂亮的强大的灰色王子左特骂骂咧咧地滚出了白色宫殿。~~", "description": "圣巢有 $n$ 个鹿角虫车站和 $n$ 条轨道，第 $i$ 条轨道连接 $u_i$ 和 $v_i$ 两个车站。初始时轨道是单向的，第一次经过第 $i$ 条轨道时，只能从 $u_i$ 到达 $v_i$；第一次经过后该轨道变为双向，既可以从 $u_i$ 到 $v_i$，又可以从 $v_i$ 到 $u_i$。\n\n现在白王在 $1$ 号车站，他要经过若干条轨道到达 $2$ 号车站，再从 $2$ 号车站经过若干条轨道到达 $3$ 号车站……一直到 $x$ 号车站。因为白王需要尽快走遍整个王国以便探清瘟疫的情况，所以他问你，当 $x$ 取遍 $[2,n]$ 中的每一个整数时，所经过的最少的轨道数分别是多少。", "inputFormat": "第一行一个整数 $n$，表示车站数与轨道数。\n\n接下来 $n$ 行，每行两个整数。第 $i$ 行的数 $u_i,v_i$ 表示第 $i$ 条轨道第一次经过时只能从 $u_i$ 走到 $v_i$，此后可以双向经过。", "outputFormat": "输出 $n-1$ 行，每行一个数，第 $i$ 个数表示当 $x=i+1$ 时，经过的最少轨道数。", "hint": "### 样例说明\n\n对于样例 1，地图如下所示：\n\n![样例 1 地图](https://z3.ax1x.com/2021/06/24/RMPoN9.png)\n\n$x=2,3,4,5,6$ 的最短路径均为沿着 $1\\to 2\\to3\\to4\\to5\\to6$ 这条路径走，答案分别是 $1,2,3,4,5$。\n\n$x=7$ 时，若仍按照上述路径走，就不能从 $6$ 号车站直接通过 $7\\to 6$ 这条轨道到 $7$ 号车站，因为这条轨道还是单向的。绕路回去需要再经过 $6$ 条轨道，总共 $11$ 条轨道。\n\n但如果先走一遍 $7\\to6$，即沿着 $1\\to7\\to6\\to7\\to1\\to2\\to3\\to4\\to5\\to6$ 的路径走，来到 $6$ 时就能直接走到 $7$，总共只需要经过 $10$ 条轨道，同时也满足了依次经过 $1\\sim 7$ 号点，比上一种方案更优。\n\n---\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n| 编号 | $n$ |分值|\n| :-: | :-: | :-: |\n| 0 | $\\le6$ | 10pts|\n| 1 | $\\le18$ | 20pts |\n| 2 | $\\le3\\times10^3$ | 32pts |\n| 3 | $\\le5\\times10^5$ | 38pts |\n\n对于 $100\\%$ 的数据，$3\\le n\\le5\\times10^5$。\n\n数据保证从 $1$ 号车站出发可以到达任意车站，且无重边自环、二元环。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「CGOI-2」No mind to think", "background": "“我的王，这个孩子……不纯粹……他……”\n\n“嗯。容器不能拥有与人交流的能力，否则可能会在交流中产生思维。它们只应该有猎杀的本能，和战斗的天分。就像我的守卫们一样。”\n\n“那些不过是傀儡……”\n\n“傀儡也比这个有思维的家伙好。改天把它带走，它真的好吵……我累了，我出去走走。”\n\n~~无敌的勇敢的性感的神秘的迷人的神气的勤勉的强势的华丽的激情的可怕的漂亮的强大的灰色王子左特骂骂咧咧地滚出了白色宫殿。~~", "description": "圣巢有 $n$ 个鹿角虫车站和 $n$ 条轨道，第 $i$ 条轨道连接 $u_i$ 和 $v_i$ 两个车站。初始时轨道是单向的，第一次经过第 $i$ 条轨道时，只能从 $u_i$ 到达 $v_i$；第一次经过后该轨道变为双向，既可以从 $u_i$ 到 $v_i$，又可以从 $v_i$ 到 $u_i$。\n\n现在白王在 $1$ 号车站，他要经过若干条轨道到达 $2$ 号车站，再从 $2$ 号车站经过若干条轨道到达 $3$ 号车站……一直到 $x$ 号车站。因为白王需要尽快走遍整个王国以便探清瘟疫的情况，所以他问你，当 $x$ 取遍 $[2,n]$ 中的每一个整数时，所经过的最少的轨道数分别是多少。", "inputFormat": "第一行一个整数 $n$，表示车站数与轨道数。\n\n接下来 $n$ 行，每行两个整数。第 $i$ 行的数 $u_i,v_i$ 表示第 $i$ 条轨道第一次经过时只能从 $u_i$ 走到 $v_i$，此后可以双向经过。", "outputFormat": "输出 $n-1$ 行，每行一个数，第 $i$ 个数表示当 $x=i+1$ 时，经过的最少轨道数。", "hint": "### 样例说明\n\n对于样例 1，地图如下所示：\n\n![样例 1 地图](https://z3.ax1x.com/2021/06/24/RMPoN9.png)\n\n$x=2,3,4,5,6$ 的最短路径均为沿着 $1\\to 2\\to3\\to4\\to5\\to6$ 这条路径走，答案分别是 $1,2,3,4,5$。\n\n$x=7$ 时，若仍按照上述路径走，就不能从 $6$ 号车站直接通过 $7\\to 6$ 这条轨道到 $7$ 号车站，因为这条轨道还是单向的。绕路回去需要再经过 $6$ 条轨道，总共 $11$ 条轨道。\n\n但如果先走一遍 $7\\to6$，即沿着 $1\\to7\\to6\\to7\\to1\\to2\\to3\\to4\\to5\\to6$ 的路径走，来到 $6$ 时就能直接走到 $7$，总共只需要经过 $10$ 条轨道，同时也满足了依次经过 $1\\sim 7$ 号点，比上一种方案更优。\n\n---\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n| 编号 | $n$ |分值|\n| :-: | :-: | :-: |\n| 0 | $\\le6$ | 10pts|\n| 1 | $\\le18$ | 20pts |\n| 2 | $\\le3\\times10^3$ | 32pts |\n| 3 | $\\le5\\times10^5$ | 38pts |\n\n对于 $100\\%$ 的数据，$3\\le n\\le5\\times10^5$。\n\n数据保证从 $1$ 号车站出发可以到达任意车站，且无重边自环、二元环。", "locale": "zh-CN"}}}
{"pid": "P8504", "type": "P", "difficulty": 5, "samples": [["5 3 1\n1 0\n2 0\n3 0\n4 0\n114514 0", "1"], ["3 2 1\n1 0\n1 1\n1 1", "1"], ["4 2 1\n3 2\n2 0\n1 1\n3 1", "249561090"], ["15 5 2\n4 0\n2 0\n3 1\n0 1\n1 4\n2 0\n0 4\n1 4\n0 4\n1 0\n2 2\n4 1\n0 4\n1 0\n4 0", "63887640"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化", "状压 DP"], "title": "「CGOI-2」No will to break", "background": "-传播-由-缺失-它们-子民-思想-哦-思想-信念-\n\n-它们-途径-缺失-切除-哦-虚空-全部-多样性-\n\n-同族-内部-意志-缺失-容器-永远-屈服-哦-\n\n-放-入-物质-全部-缺失-噫-空洞-壳-封印-", "description": "一场战斗由 $n$ 个时刻组成，第 $i$ 个时刻有 $\\frac{x_i}{x_i+y_i}$ 的概率是安全的。\n\n在安全的时刻，你可以进行“聚集”。要求每连续的 $a$ 个时刻都至少要有 $b$ 个时刻进行聚集，在此前提下希望进行聚集的时刻数量尽量少；若不能满足此前提则认为进行聚集的时刻数量为 $0$。求进行聚集的时刻数量的期望，答案对 $998244353$ 取模。", "inputFormat": "第一行输入三个整数 $n,a,b$，含义如上所述。\n\n接下来 $n$ 行，第 $(i+1)$ 行输入两个整数 $x_i,y_i$，表示第 $i$ 个时刻有 $\\frac{x_i}{x_i+y_i}$ 的概率是安全的。", "outputFormat": "输出一个整数，表示期望对 $998244353$ 取模的值。", "hint": "### 样例说明：\n\n用 `1` 表示当前时刻是安全的，`0` 表示不是。\n\n对于样例一，安全性序列只能是 `11111`，每连续三个时刻至少要有一个时刻用来聚集，可以选择第 $3$ 个时刻聚集，满足条件。聚集时刻数量为 $1$，可以证明不会小于 $1$。只有一种可能性，故期望也为 $1$。\n\n对于样例二，安全性序列为 `100`，`101`，`110`，`111` 的概率相等，均为 $\\frac14$，聚集时刻数量分别为 $0,2,1,1$，期望为 $\\frac{0+2+1+1}4=1$。\n\n---\n\n### 数据范围：\n\n**本题采用捆绑测试。**\n\n| 编号| 限制 | 分数 |\n| :-: | :-: | :-: |\n| 0 | $n\\le20$ | 10pts |\n| 1 | $\\forall i$，$x_i=0$ 或 $y_i=0$ | 10pts |\n| 2 | $n\\le3\\times 10^3$ | 30pts |\n| 3 | 无 | 50pts |\n\n对于 $100\\%$ 的数据，$1<n\\le1.5\\times10^4$，$1\\le b<a\\le\\min(n,9)$，$x_i,y_i\\ge0$，$0<x_i+y_i<998244353$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「CGOI-2」No will to break", "background": "-传播-由-缺失-它们-子民-思想-哦-思想-信念-\n\n-它们-途径-缺失-切除-哦-虚空-全部-多样性-\n\n-同族-内部-意志-缺失-容器-永远-屈服-哦-\n\n-放-入-物质-全部-缺失-噫-空洞-壳-封印-", "description": "一场战斗由 $n$ 个时刻组成，第 $i$ 个时刻有 $\\frac{x_i}{x_i+y_i}$ 的概率是安全的。\n\n在安全的时刻，你可以进行“聚集”。要求每连续的 $a$ 个时刻都至少要有 $b$ 个时刻进行聚集，在此前提下希望进行聚集的时刻数量尽量少；若不能满足此前提则认为进行聚集的时刻数量为 $0$。求进行聚集的时刻数量的期望，答案对 $998244353$ 取模。", "inputFormat": "第一行输入三个整数 $n,a,b$，含义如上所述。\n\n接下来 $n$ 行，第 $(i+1)$ 行输入两个整数 $x_i,y_i$，表示第 $i$ 个时刻有 $\\frac{x_i}{x_i+y_i}$ 的概率是安全的。", "outputFormat": "输出一个整数，表示期望对 $998244353$ 取模的值。", "hint": "### 样例说明：\n\n用 `1` 表示当前时刻是安全的，`0` 表示不是。\n\n对于样例一，安全性序列只能是 `11111`，每连续三个时刻至少要有一个时刻用来聚集，可以选择第 $3$ 个时刻聚集，满足条件。聚集时刻数量为 $1$，可以证明不会小于 $1$。只有一种可能性，故期望也为 $1$。\n\n对于样例二，安全性序列为 `100`，`101`，`110`，`111` 的概率相等，均为 $\\frac14$，聚集时刻数量分别为 $0,2,1,1$，期望为 $\\frac{0+2+1+1}4=1$。\n\n---\n\n### 数据范围：\n\n**本题采用捆绑测试。**\n\n| 编号| 限制 | 分数 |\n| :-: | :-: | :-: |\n| 0 | $n\\le20$ | 10pts |\n| 1 | $\\forall i$，$x_i=0$ 或 $y_i=0$ | 10pts |\n| 2 | $n\\le3\\times 10^3$ | 30pts |\n| 3 | 无 | 50pts |\n\n对于 $100\\%$ 的数据，$1<n\\le1.5\\times10^4$，$1\\le b<a\\le\\min(n,9)$，$x_i,y_i\\ge0$，$0<x_i+y_i<998244353$。", "locale": "zh-CN"}}}
{"pid": "P8505", "type": "P", "difficulty": 6, "samples": [["3 3\n1 5\n1 1\n1 0", "2\n2\n1\n1"], ["5 2\n2 1\n4 5", "4\n3\n3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "线段树", "O2优化"], "title": "「CGOI-2」No voice to cry suffering", "background": "父亲，您的王国在崩塌；\n\n父亲，您的人民在离去；\n\n父亲，但您说我不该有为苦难哭泣的声音；\n\n所以我将无能为力，所以我独自分崩离析。", "description": "容器面前有 $n$ 个感染者，这 $n$ 个感染者排成一列，编号依次从 $1$ 到 $n$，第 $i$ 个感染者的感染深度为 $a_i$。\n\n容器会从第 $x$ 个感染者处开始向第 $n$ 个感染者走，依次经过第 $x$ 到 $n$ 个感染者。容器会击杀所有经过的感染者。然而，如果击杀了两个**编号连续，感染深度严格递增**的感染者，那么它会略过下一个感染者（如果存在下一个）。\n\n记 $f_x$ 表示若容器从第 $x$ 个位置开始，击杀的感染者数量（$f$ 之间两两独立）。例如有五个感染者，他们的感染深度依次为：\n\n```plain\n2 6 4 5 1\n```\n\n那么对应的 $f$ 序列为 $\\{4,3,2,2,1\\}$。\n\n你不知道每个感染者的感染深度，只知道 $m$ 组 $f_i-f_{i+1}$ 的值，对于请输出满足条件的不同 $f$ 序列的数量对 $998244353$ 取模的结果。\n\n序列 $f,g$ 不同，当且仅当存在 $1\\le i \\le n$ 满足 $f_i\\not= g_i$。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $m$ 行，每行一个二元组 $(x,y)$，表示 $f_x-f_{x+1}=y$。\n\n注意，数据中可能存在错误的二元组，您需要自行忽略它们。具体地，若二元组 $(x_i,y_i)$ 使得考虑 $1\\sim i-1$ 的所有合法二元组及该二元组后，不存在满足条件的 $f$ 序列，那么该二元组不合法，您在计算答案时不应考虑该二元组。", "outputFormat": "输出为 $(m+1)$ 行，每行 $1$ 个数。\n\n第一行表示不考虑任何二元组时的答案对 $998244353$ 取模的结果。\n\n第 $i(2 \\le i \\le m+1)$ 行表示考虑 $1 \\sim i-1$ 中所有合法二元组时的答案对 $998244353$ 取模的结果。\n\n", "hint": "### 样例一解释\n\n初始：符合条件的 $f$ 序列有 $\\{3,2,1\\},\\{2,2,1\\}$。\n\n约束一：初始的 $f$ 序列都不符合约束一，忽略该条件。\n\n约束二：只有 $\\{3,2,1\\}$ 符合约束条件。\n\n约束三：只有 $\\{2,2,1\\}$ 符合约束条件。结合约束二，不存在合法的 $f$ 序列，忽略该条件。\n\n---\n\n### 数据范围及约定\n\n对于 $20\\%$ 的数据，$n,m\\le5$。\n\n对于 $60\\%$ 的数据，$n\\le10^6$。\n\n对于另外 $10\\%$ 的数据，$m=0$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^{11},0 \\leq m \\leq 5\\times 10^4,0 \\leq |y| \\leq n,1 \\leq x <n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「CGOI-2」No voice to cry suffering", "background": "父亲，您的王国在崩塌；\n\n父亲，您的人民在离去；\n\n父亲，但您说我不该有为苦难哭泣的声音；\n\n所以我将无能为力，所以我独自分崩离析。", "description": "容器面前有 $n$ 个感染者，这 $n$ 个感染者排成一列，编号依次从 $1$ 到 $n$，第 $i$ 个感染者的感染深度为 $a_i$。\n\n容器会从第 $x$ 个感染者处开始向第 $n$ 个感染者走，依次经过第 $x$ 到 $n$ 个感染者。容器会击杀所有经过的感染者。然而，如果击杀了两个**编号连续，感染深度严格递增**的感染者，那么它会略过下一个感染者（如果存在下一个）。\n\n记 $f_x$ 表示若容器从第 $x$ 个位置开始，击杀的感染者数量（$f$ 之间两两独立）。例如有五个感染者，他们的感染深度依次为：\n\n```plain\n2 6 4 5 1\n```\n\n那么对应的 $f$ 序列为 $\\{4,3,2,2,1\\}$。\n\n你不知道每个感染者的感染深度，只知道 $m$ 组 $f_i-f_{i+1}$ 的值，对于请输出满足条件的不同 $f$ 序列的数量对 $998244353$ 取模的结果。\n\n序列 $f,g$ 不同，当且仅当存在 $1\\le i \\le n$ 满足 $f_i\\not= g_i$。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $m$ 行，每行一个二元组 $(x,y)$，表示 $f_x-f_{x+1}=y$。\n\n注意，数据中可能存在错误的二元组，您需要自行忽略它们。具体地，若二元组 $(x_i,y_i)$ 使得考虑 $1\\sim i-1$ 的所有合法二元组及该二元组后，不存在满足条件的 $f$ 序列，那么该二元组不合法，您在计算答案时不应考虑该二元组。", "outputFormat": "输出为 $(m+1)$ 行，每行 $1$ 个数。\n\n第一行表示不考虑任何二元组时的答案对 $998244353$ 取模的结果。\n\n第 $i(2 \\le i \\le m+1)$ 行表示考虑 $1 \\sim i-1$ 中所有合法二元组时的答案对 $998244353$ 取模的结果。\n\n", "hint": "### 样例一解释\n\n初始：符合条件的 $f$ 序列有 $\\{3,2,1\\},\\{2,2,1\\}$。\n\n约束一：初始的 $f$ 序列都不符合约束一，忽略该条件。\n\n约束二：只有 $\\{3,2,1\\}$ 符合约束条件。\n\n约束三：只有 $\\{2,2,1\\}$ 符合约束条件。结合约束二，不存在合法的 $f$ 序列，忽略该条件。\n\n---\n\n### 数据范围及约定\n\n对于 $20\\%$ 的数据，$n,m\\le5$。\n\n对于 $60\\%$ 的数据，$n\\le10^6$。\n\n对于另外 $10\\%$ 的数据，$m=0$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^{11},0 \\leq m \\leq 5\\times 10^4,0 \\leq |y| \\leq n,1 \\leq x <n$。", "locale": "zh-CN"}}}
{"pid": "P8506", "type": "P", "difficulty": 1, "samples": [["1\n#u#n#t#i#t#l#e#d#", "0"], ["1\n# a perfect title", "1"], ["10\n# a\n # b\n## c\n#d\n#  \ne\n# f#g#h#i#j\n  ##k\n# #\nl # m", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "洛谷原创", "洛谷月赛"], "title": "标题计数", "background": "5ab 试图帮洛谷写机器人，数题解中有多少个一级标题。", "description": "Markdown 是一种标记语言。在 Markdown 中，若一行的第一个非空白字符是井号（#），且紧跟着若干个空格，则这一行剩余的**非空白**内容将会按照一级标题渲染。\n\n在本题范围内，下面的都是一级标题：\n\n```plaintext\n# This is a title\n#    This is another title\n    # This is also a title\n    #   You#can#add#more#sharps\n# #\n```\n\n在本题范围内，下面的都不是一级标题：\n\n```plaintext\n<h1>an HTML title</h1>\n#You should insert a space\n## This is a secondary title\naaaaa # This is not a title at all\n # \nYou should add something after the sharp sign\n```\n\n给定一段多行文本，求出这段文本总共有多少个一级标题。", "inputFormat": "第一行输入一个整数 $n$，代表文本的行数。\n\n接下来输入 $n$ 行，是给出的标记文本。", "outputFormat": "输出一行一个整数，为这段文本中的一级标题个数。", "hint": "#### 样例 3 解释\n\n第 2,3,8,10 行（文本第 1,2,7,9 行）是满足条件的一级标题。\n\n---\n\n如果选手在比赛中使用 Windows 系统，则直接从网站或下发题面中复制的样例的换行符是 CRLF，与真实数据中的 LF 会有区别。为了方便调试，建议使用下发文件中的样例进行测试，并直接使用文件输入输出。\n\n### 数据规模与约定\n\n总文本不超过 $100$ 个字符，不超过 $10$ 行。文本中只有英文字母，井号（`#`），换行符（Line Feed，LF，`\\n`）和空格。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|}\\hline\n\\bf{测试点} & \\bf{文本特殊性质}\n\\\\\n\\hline\n1 & 没有空白字符 \\\\\\hline\n2,3& 只有\\ 1\\ 行 \\\\\\hline\n4,5 & / \\\\\\hline\n\\end{array}\n$$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "标题计数", "background": "5ab 试图帮洛谷写机器人，数题解中有多少个一级标题。", "description": "Markdown 是一种标记语言。在 Markdown 中，若一行的第一个非空白字符是井号（#），且紧跟着若干个空格，则这一行剩余的**非空白**内容将会按照一级标题渲染。\n\n在本题范围内，下面的都是一级标题：\n\n```plaintext\n# This is a title\n#    This is another title\n    # This is also a title\n    #   You#can#add#more#sharps\n# #\n```\n\n在本题范围内，下面的都不是一级标题：\n\n```plaintext\n<h1>an HTML title</h1>\n#You should insert a space\n## This is a secondary title\naaaaa # This is not a title at all\n # \nYou should add something after the sharp sign\n```\n\n给定一段多行文本，求出这段文本总共有多少个一级标题。", "inputFormat": "第一行输入一个整数 $n$，代表文本的行数。\n\n接下来输入 $n$ 行，是给出的标记文本。", "outputFormat": "输出一行一个整数，为这段文本中的一级标题个数。", "hint": "#### 样例 3 解释\n\n第 2,3,8,10 行（文本第 1,2,7,9 行）是满足条件的一级标题。\n\n---\n\n如果选手在比赛中使用 Windows 系统，则直接从网站或下发题面中复制的样例的换行符是 CRLF，与真实数据中的 LF 会有区别。为了方便调试，建议使用下发文件中的样例进行测试，并直接使用文件输入输出。\n\n### 数据规模与约定\n\n总文本不超过 $100$ 个字符，不超过 $10$ 行。文本中只有英文字母，井号（`#`），换行符（Line Feed，LF，`\\n`）和空格。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|}\\hline\n\\bf{测试点} & \\bf{文本特殊性质}\n\\\\\n\\hline\n1 & 没有空白字符 \\\\\\hline\n2,3& 只有\\ 1\\ 行 \\\\\\hline\n4,5 & / \\\\\\hline\n\\end{array}\n$$", "locale": "zh-CN"}}}
{"pid": "P8507", "type": "P", "difficulty": 2, "samples": [["2 2", "0.5000000000000000"], ["114 514", "0.0077821011673152"], ["191 9810", "0.0051987767584098"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "洛谷原创", "Special Judge", "洛谷月赛"], "title": "毕业后", "background": "毕业后，同学们都在热烈讨论高中的计划。所有人总是难以避开一个话题——学考。\n\n在浙江，高中生除了要参加普通高等学校招生全国统一考试（简称高考）以外，还要参加普通高中学业水平考试（简称学考）。学生要在高一下、高二上和高二下各参加一次学考。", "description": "**注意：题目中的部分描述可能和现实有所出入。**\n\n学考会考查高中所有科目，并根据成绩分层评级，自高到低为 A~E。每门科目都会按照一个确定的比率 $w$（所有学科都相同）确定 E 等人数。如果学考有**大于一门**科目拿到了 E 等（不合格），该学生将不能毕业。\n\n在另一个平行世界里，高中总共有 $a$ 门科目。全省共有 $b$ 名考生。如果 E 等的分数线过高，可能会导致总存在某些人毕不了业的情况。现在，考试院院长找到了你，希望你确定学考 E 等占所有考生的**最大**比例（即，最大化 $w$ 的值），使得**存在**至少一种方案，能使浙江所有考生都能毕业。\n\n如果按照某个比例算出来的 E 等考生数不为整数，则将考生数**向上**取整。", "inputFormat": "一行，输入两个正整数 $a,b$。", "outputFormat": "输出一个浮点数，表示 E 等级的最大占比。\n\n本题使用自定义校验器，与标准答案之间的绝对误差在 $10^{-6}$ 以内的结果都算作正确答案。", "hint": "#### 样例 1 解释\n\n将 E 等比率设成 $\\frac{1}{2}$，此时每门科目都恰好有一名考生不合格。当第一名考生在第一门科目不合格，第二名考生在第二门科目不合格时，所有考生都能毕业。所以 $\\frac{1}{2}$ 是满足要求的。\n\n可以证明不存在更优的方案。\n\n### 数据规模与约定\n\n对于所有数据，$1\\le a, b\\le 10000$。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|}\\hline\n\\bf{测试点} & \\bf{特殊性质}\n\\\\\n\\hline\n1\\sim3 & b=1\\\\\\hline\n4\\sim6 & a=b \\\\\\hline\n7\\sim10 & /\\\\\\hline\n\\end{array}\n$$\n\n做完这道题，你能否说明，为什么现实中，浙江 E 等不能超过 $5\\%$ 呢？", "locale": "zh-CN", "translations": {"zh-CN": {"title": "毕业后", "background": "毕业后，同学们都在热烈讨论高中的计划。所有人总是难以避开一个话题——学考。\n\n在浙江，高中生除了要参加普通高等学校招生全国统一考试（简称高考）以外，还要参加普通高中学业水平考试（简称学考）。学生要在高一下、高二上和高二下各参加一次学考。", "description": "**注意：题目中的部分描述可能和现实有所出入。**\n\n学考会考查高中所有科目，并根据成绩分层评级，自高到低为 A~E。每门科目都会按照一个确定的比率 $w$（所有学科都相同）确定 E 等人数。如果学考有**大于一门**科目拿到了 E 等（不合格），该学生将不能毕业。\n\n在另一个平行世界里，高中总共有 $a$ 门科目。全省共有 $b$ 名考生。如果 E 等的分数线过高，可能会导致总存在某些人毕不了业的情况。现在，考试院院长找到了你，希望你确定学考 E 等占所有考生的**最大**比例（即，最大化 $w$ 的值），使得**存在**至少一种方案，能使浙江所有考生都能毕业。\n\n如果按照某个比例算出来的 E 等考生数不为整数，则将考生数**向上**取整。", "inputFormat": "一行，输入两个正整数 $a,b$。", "outputFormat": "输出一个浮点数，表示 E 等级的最大占比。\n\n本题使用自定义校验器，与标准答案之间的绝对误差在 $10^{-6}$ 以内的结果都算作正确答案。", "hint": "#### 样例 1 解释\n\n将 E 等比率设成 $\\frac{1}{2}$，此时每门科目都恰好有一名考生不合格。当第一名考生在第一门科目不合格，第二名考生在第二门科目不合格时，所有考生都能毕业。所以 $\\frac{1}{2}$ 是满足要求的。\n\n可以证明不存在更优的方案。\n\n### 数据规模与约定\n\n对于所有数据，$1\\le a, b\\le 10000$。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|}\\hline\n\\bf{测试点} & \\bf{特殊性质}\n\\\\\n\\hline\n1\\sim3 & b=1\\\\\\hline\n4\\sim6 & a=b \\\\\\hline\n7\\sim10 & /\\\\\\hline\n\\end{array}\n$$\n\n做完这道题，你能否说明，为什么现实中，浙江 E 等不能超过 $5\\%$ 呢？", "locale": "zh-CN"}}}
{"pid": "P8508", "type": "P", "difficulty": 3, "samples": [["3 5 1 3\n1 2 2", "2"], ["2 10 4 10\n9 1", "3"], ["10 2 1 2\n1 1 1 1 1 1 1 1 1 1", "10"], ["见下发文件 task/task4.in", "见下发文件 task/task4.ans"], ["见下发文件 task/task5.in", "见下发文件 task/task5.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "洛谷原创", "O2优化", "洛谷月赛"], "title": "做不完的作业", "background": "高中的任务是非常艰巨的，要学习十门功课（浙江要学技术）。导致作业超级加倍，这一点在暑假就已经体现出来了。\n\n作业的总量是一定的，但不同作业下发的时间是不一定的，导致每天都要花不同的时间应付作业。此时，如何保证睡眠是一个需要仔细考虑的问题。", "description": "**提示：如果你对题目内容有疑问，可以配合样例更好地阅读。**\n\n有 $n$ 个任务，第 $i$ 个任务需要 $t_i$ 的时间。Eric 要在若干天内**依次**完成这些任务。Eric 是一个专注的人，所以完成每个任务的时间**必须连续**。\n\n一天有 $x$ 的时间。由于 Eric 需要睡觉，所以 Eric 不能利用所有的时间。具体地：\n\n- Eric 每天**必须睡觉**；\n- Eric 每天的睡觉的时间是连续的，且睡觉时间结束后，第二天恰好开始；\n- Eric **前 $\\boldsymbol i$ 天**的睡觉时间**总和**不能少于 $r\\cdot x\\cdot i$ 的时间。$r$ 是一个给定的实数，$i$ 是一个正整数。\n\nEric 想问你，至少需要多少天才能完成任务。", "inputFormat": "第一行输入四个整数 $n,x,p,q$，代表 $r=\\dfrac p q$。\n\n接下来一行，输入 $n$ 个整数，第 $i$ 个代表 $t_i$。", "outputFormat": "输出一个正整数，代表最小天数。可以证明，在下文限定的数据下，一定存在至少一个解。", "hint": "#### 样例 1 解释\n\n下面是一种可能的方案：\n\nEric 先在第一天做任务 1，总共消耗 $1$ 的时间，用 $4$ 时间睡觉，满足至少要 $5\\times \\dfrac 1 3=\\dfrac 5 3$ 的时间睡觉的要求。\n\nEric 再在第二天加班加点，完成剩下的任务，有 $1$ 的时间睡觉。两天睡觉总量为 $5\\ge 10\\times \\dfrac 1 3=\\dfrac {10} 3$，也是满足要求的。\n\n#### 样例 2 解释\n\nEric 试图在第一天完成任务 1，但假如要做就会熬夜，觉就不够睡。所以 Eric 第一天只能睡大觉。Eric 在第二天完成任务 1 就没有问题。\n\n同时请注意，即使睡觉时间满足了要求，Eric 也不能在第二天就完成任务 2，因为 Eric 必须睡觉。所以 Eric 先睡到第三天，然后完成任务 2。可以证明不存在方案小于三天。\n\n同时注意数据**不保证** $\\gcd(p,q)=1$。\n\n#### 样例 3 解释\n\n显然一天只能干一件活，所以要 $10$ 天。\n\n#### 样例 4 解释\n\n该样例满足子任务 3 的限制条件。\n\n#### 样例 5 解释\n\n该样例满足子任务 5 的限制条件。\n\n### 数据规模与约定\n\n**本题捆绑测试**。对于所有数据，保证 $1\\le n\\le 10^5$，$1\\le t_i<x\\le 10^6$，$1\\le p<q\\le 10^6$。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|}\\hline\n\n\\bf 子任务 & \\bf 分值 & n\\le & \\bf特殊性质\n\\\\\n\\hline\n1 & 10 & 3 & /\\\\\\hline\n2 & 20 & 10^3 & \\bf A \\\\\\hline\n3 & 20 & / & \\bf A\\\\\\hline\n4 & 20 & / & \\bf B\\\\\\hline\n5 & 30 & / & /\\\\\\hline\n\\end{array}\n$$\n\n特殊性质 $\\bf A$：$\\forall i,\\ \\dfrac{t_i}{x}+\\dfrac{p}{q}\\le 1$。\n\n特殊性质 $\\bf B$：$n\\times q\\le 10^6$。\n\n为了减少评测量，本题开启子任务依赖。具体地，当且仅当前四个子任务全部通过时，子任务 5 才计分，否则子任务 5 计 $0$ 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "做不完的作业", "background": "高中的任务是非常艰巨的，要学习十门功课（浙江要学技术）。导致作业超级加倍，这一点在暑假就已经体现出来了。\n\n作业的总量是一定的，但不同作业下发的时间是不一定的，导致每天都要花不同的时间应付作业。此时，如何保证睡眠是一个需要仔细考虑的问题。", "description": "**提示：如果你对题目内容有疑问，可以配合样例更好地阅读。**\n\n有 $n$ 个任务，第 $i$ 个任务需要 $t_i$ 的时间。Eric 要在若干天内**依次**完成这些任务。Eric 是一个专注的人，所以完成每个任务的时间**必须连续**。\n\n一天有 $x$ 的时间。由于 Eric 需要睡觉，所以 Eric 不能利用所有的时间。具体地：\n\n- Eric 每天**必须睡觉**；\n- Eric 每天的睡觉的时间是连续的，且睡觉时间结束后，第二天恰好开始；\n- Eric **前 $\\boldsymbol i$ 天**的睡觉时间**总和**不能少于 $r\\cdot x\\cdot i$ 的时间。$r$ 是一个给定的实数，$i$ 是一个正整数。\n\nEric 想问你，至少需要多少天才能完成任务。", "inputFormat": "第一行输入四个整数 $n,x,p,q$，代表 $r=\\dfrac p q$。\n\n接下来一行，输入 $n$ 个整数，第 $i$ 个代表 $t_i$。", "outputFormat": "输出一个正整数，代表最小天数。可以证明，在下文限定的数据下，一定存在至少一个解。", "hint": "#### 样例 1 解释\n\n下面是一种可能的方案：\n\nEric 先在第一天做任务 1，总共消耗 $1$ 的时间，用 $4$ 时间睡觉，满足至少要 $5\\times \\dfrac 1 3=\\dfrac 5 3$ 的时间睡觉的要求。\n\nEric 再在第二天加班加点，完成剩下的任务，有 $1$ 的时间睡觉。两天睡觉总量为 $5\\ge 10\\times \\dfrac 1 3=\\dfrac {10} 3$，也是满足要求的。\n\n#### 样例 2 解释\n\nEric 试图在第一天完成任务 1，但假如要做就会熬夜，觉就不够睡。所以 Eric 第一天只能睡大觉。Eric 在第二天完成任务 1 就没有问题。\n\n同时请注意，即使睡觉时间满足了要求，Eric 也不能在第二天就完成任务 2，因为 Eric 必须睡觉。所以 Eric 先睡到第三天，然后完成任务 2。可以证明不存在方案小于三天。\n\n同时注意数据**不保证** $\\gcd(p,q)=1$。\n\n#### 样例 3 解释\n\n显然一天只能干一件活，所以要 $10$ 天。\n\n#### 样例 4 解释\n\n该样例满足子任务 3 的限制条件。\n\n#### 样例 5 解释\n\n该样例满足子任务 5 的限制条件。\n\n### 数据规模与约定\n\n**本题捆绑测试**。对于所有数据，保证 $1\\le n\\le 10^5$，$1\\le t_i<x\\le 10^6$，$1\\le p<q\\le 10^6$。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|}\\hline\n\n\\bf 子任务 & \\bf 分值 & n\\le & \\bf特殊性质\n\\\\\n\\hline\n1 & 10 & 3 & /\\\\\\hline\n2 & 20 & 10^3 & \\bf A \\\\\\hline\n3 & 20 & / & \\bf A\\\\\\hline\n4 & 20 & / & \\bf B\\\\\\hline\n5 & 30 & / & /\\\\\\hline\n\\end{array}\n$$\n\n特殊性质 $\\bf A$：$\\forall i,\\ \\dfrac{t_i}{x}+\\dfrac{p}{q}\\le 1$。\n\n特殊性质 $\\bf B$：$n\\times q\\le 10^6$。\n\n为了减少评测量，本题开启子任务依赖。具体地，当且仅当前四个子任务全部通过时，子任务 5 才计分，否则子任务 5 计 $0$ 分。", "locale": "zh-CN"}}}
{"pid": "P8509", "type": "P", "difficulty": 4, "samples": [["5 1 5\n1 2 1\n2 3 1\n3 4 1\n4 5 1", "4\n2201"], ["13 4 5\n1 3 3\n2 3 2\n6 4 5\n7 4 10\n4 8 2\n11 8 3\n5 13 6\n8 13 5\n8 3 4\n10 5 8\n12 10 3\n13 9 9", "85\n111121202112"], ["见下发文件 corridor/corridor3.in", "见下发文件 corridor/corridor3.ans"], ["见下发文件 corridor/corridor4.in", "见下发文件 corridor/corridor4.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "图论", "洛谷原创", "Special Judge", "O2优化", "洛谷月赛"], "title": "如何得到 npy", "background": "作为年级第一大风流人物，Steve 总会给自己找很多东西，包括但不限于 npy。Steve 看上了 Ada，并试图接近她，然而 Ada 并不是那么乐意。", "description": "**提示：你可以阅读题目描述末尾的形式化题面。**\n\nSteve 所在的校园有 $n$ 间教室，编号为 $1$ 到 $n$，有 $n-1$ 条走廊将其连通。也就是说，教室和走廊构成了一棵树。每条走廊都有一定的长度 $w_i$，经过这条走廊的时间等于其长度的数值。\n\nSteve 喜欢在校园里游荡。当然，他希望最后能走到自己的教室 $s$ 或 Ada 的教室 $t$。但由于学校过于错综复杂，且 Steve 不想走回头路，所以他想到了如下方案：\n\n对于每个教室（Steve 和 Ada 的教室除外，这两个教室周围不应该有任何标牌），在一条与其相连的边立上标牌。每次走到这个教室，就从立了标牌的边出。\n\nSteve 可能会在学校的任何一个教室出现，所以一方面，Steve 需要让他从每个教室都能跟着标牌回到他的或 Ada 的教室。另一方面，他希望从学校所有教室走到目的地的**时间总和**尽可能小。\n\n由于 Steve 又要去找 Ada 了，所以请你帮他完成这个任务。\n\n#### 形式化题意\n\n给定一棵 $n$ 个节点的无根树和两个关键点 $s,t$，要求对所有边定向，满足：\n\n- 每条边要么是有向边，要么被删除；\n- 每个点（除 $s,t$）出度恰好为 $1$，$s,t$ 出度为 $0$；\n- 每个点都可以顺着有向边到达 $s$ 或 $t$。\n\n求每个点到 $s$ 或 $t$ 的距离总和最小值。", "inputFormat": "第一行输入三个正整数 $n$，$s$，$t$。\n\n接下来 $n-1$ 行，每行输入三个正整数 $u_i$，$v_i$，$w_i$，代表一条树边 $(u_i,v_i)$，权值为 $w_i$。", "outputFormat": "输出第一行一个正整数，代表最小的权值和。\n\n接下来一行，输出一个字符串 $S$，要求：\n\n- $S_i=\\texttt{0}$，指第 $i$ 条边两边均不立标牌；\n- $S_i=\\texttt{1}$，指第 $i$ 条边在 $u_i$ 处立标牌；\n- $S_i=\\texttt{2}$，指第 $i$ 条边在 $v_i$ 处立标牌。\n\n本题使用自定义校验器评测。如果有多种方案，输出任意一种。", "hint": "#### 样例 1 解释\n\n`2011` 也是合法的答案，但 `2211`，`1102` 等都不是。\n\n#### 样例 2 解释\n\n下图是取到样例中最优解的状态（$(8,13)$ 这条边没有画出）:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/78tlf89y.png)\n\n#### 样例 3 解释\n\n该样例满足子任务 2 的限制条件。\n\n#### 样例 4 解释\n\n该样例满足子任务 5 的限制条件。\n\n---\n\n下发文件中还有 `checker.cpp` 可判定答案是否合法。使用时，先编译（设二进制文件为 `checker`（Linux/MacOS）或 `checker.exe`（Windows）），然后在终端输入如下命令：\n\n```\n./checker in.txt out.txt ans.txt\n```\n\n如果你使用了 Windows 系统且无法运行上述命令，请尝试：\n\n```\nchecker.exe in.txt out.txt ans.txt\n```\n\n其中 `in.txt`、`out.txt`、`ans.txt` 分别是放在同一目录下的输入文件、选手输出、标准答案。\n\n结果可能有如下中的一种：\n\n- `ok`：结果正确，可以得到满分；\n- `wrong answer`：第一行答案错误；\n- `points 0.60`：第一行答案正确，第二行答案错误。\n\n对于所有非满分情况，会有附加消息，意义如下：\n\n- `A x y`：第一行答案错误，标准答案是 $x$，选手答案是 $y$；\n- `B`：第二行长度不符合条件；\n- `C`：第二行出现非法字符；\n- `D`：第二行给出的构造不满足题目中关于度数的限制；\n- `E x y`：第二行给出的构造产生的答案是 $y$，而实际上答案是 $x$。\n\n该校验器和最终评测时采用的校验器可能有所不同。\n\n注意下发文件的输出样例中只有最优答案，没有构造方案。\n\n### 数据规模与约定\n\n**本题捆绑测试**。对于所有数据，$3\\le n\\le 3\\times 10^5$，$1\\le w_i\\le2\\times 10^8$，$1\\le s,t\\le n$，$s\\neq t$。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{c|c|c||c|c}\\hline\n\n\\bf 子任务 & \\bf 分值 & \\bf 依赖 & n\\le & \\bf特殊性质\n\\\\\n\\hline\n\\hline\n1 & 10 & / & 10 & /\\\\\\hline\n2 & 15 & 1 & 18 & /\\\\\\hline\n3 & 15 & / & / & v_i=u_i+1\\\\\\hline\n4 & 10 & / & / & u_i=1\\\\\\hline\n5 & 20 & / & / & 存在边\\ (s,t)\\\\\\hline\n6 & 30 & 2\\sim5 &/ & /\n\\end{array}\n$$\n\n如果你计算出了正确的答案，但是你的构造是错误的，那你将得到该测试点 $60\\%$ 的分数。注意即使你只实现了第一小问，请依旧在第二行输出任意一个非空字符串，否则可能会不计分。\n\n本题中的依赖指：某子任务的得分占比不能超过其所依赖的子任务得分占比。比如，一选手子任务 $1$ 得到 $60\\%$ 的分数，则他的子任务 $2$ 就不会超过对应的 $60\\%$ 分数，即不超过 $9$ 分。\n\n答案可能很大，请注意你使用的数据类型。\n\n---\n\n到毕业为止，Steve 也没有追到 Ada。What a sad story. :-(", "locale": "zh-CN", "translations": {"zh-CN": {"title": "如何得到 npy", "background": "作为年级第一大风流人物，Steve 总会给自己找很多东西，包括但不限于 npy。Steve 看上了 Ada，并试图接近她，然而 Ada 并不是那么乐意。", "description": "**提示：你可以阅读题目描述末尾的形式化题面。**\n\nSteve 所在的校园有 $n$ 间教室，编号为 $1$ 到 $n$，有 $n-1$ 条走廊将其连通。也就是说，教室和走廊构成了一棵树。每条走廊都有一定的长度 $w_i$，经过这条走廊的时间等于其长度的数值。\n\nSteve 喜欢在校园里游荡。当然，他希望最后能走到自己的教室 $s$ 或 Ada 的教室 $t$。但由于学校过于错综复杂，且 Steve 不想走回头路，所以他想到了如下方案：\n\n对于每个教室（Steve 和 Ada 的教室除外，这两个教室周围不应该有任何标牌），在一条与其相连的边立上标牌。每次走到这个教室，就从立了标牌的边出。\n\nSteve 可能会在学校的任何一个教室出现，所以一方面，Steve 需要让他从每个教室都能跟着标牌回到他的或 Ada 的教室。另一方面，他希望从学校所有教室走到目的地的**时间总和**尽可能小。\n\n由于 Steve 又要去找 Ada 了，所以请你帮他完成这个任务。\n\n#### 形式化题意\n\n给定一棵 $n$ 个节点的无根树和两个关键点 $s,t$，要求对所有边定向，满足：\n\n- 每条边要么是有向边，要么被删除；\n- 每个点（除 $s,t$）出度恰好为 $1$，$s,t$ 出度为 $0$；\n- 每个点都可以顺着有向边到达 $s$ 或 $t$。\n\n求每个点到 $s$ 或 $t$ 的距离总和最小值。", "inputFormat": "第一行输入三个正整数 $n$，$s$，$t$。\n\n接下来 $n-1$ 行，每行输入三个正整数 $u_i$，$v_i$，$w_i$，代表一条树边 $(u_i,v_i)$，权值为 $w_i$。", "outputFormat": "输出第一行一个正整数，代表最小的权值和。\n\n接下来一行，输出一个字符串 $S$，要求：\n\n- $S_i=\\texttt{0}$，指第 $i$ 条边两边均不立标牌；\n- $S_i=\\texttt{1}$，指第 $i$ 条边在 $u_i$ 处立标牌；\n- $S_i=\\texttt{2}$，指第 $i$ 条边在 $v_i$ 处立标牌。\n\n本题使用自定义校验器评测。如果有多种方案，输出任意一种。", "hint": "#### 样例 1 解释\n\n`2011` 也是合法的答案，但 `2211`，`1102` 等都不是。\n\n#### 样例 2 解释\n\n下图是取到样例中最优解的状态（$(8,13)$ 这条边没有画出）:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/78tlf89y.png)\n\n#### 样例 3 解释\n\n该样例满足子任务 2 的限制条件。\n\n#### 样例 4 解释\n\n该样例满足子任务 5 的限制条件。\n\n---\n\n下发文件中还有 `checker.cpp` 可判定答案是否合法。使用时，先编译（设二进制文件为 `checker`（Linux/MacOS）或 `checker.exe`（Windows）），然后在终端输入如下命令：\n\n```\n./checker in.txt out.txt ans.txt\n```\n\n如果你使用了 Windows 系统且无法运行上述命令，请尝试：\n\n```\nchecker.exe in.txt out.txt ans.txt\n```\n\n其中 `in.txt`、`out.txt`、`ans.txt` 分别是放在同一目录下的输入文件、选手输出、标准答案。\n\n结果可能有如下中的一种：\n\n- `ok`：结果正确，可以得到满分；\n- `wrong answer`：第一行答案错误；\n- `points 0.60`：第一行答案正确，第二行答案错误。\n\n对于所有非满分情况，会有附加消息，意义如下：\n\n- `A x y`：第一行答案错误，标准答案是 $x$，选手答案是 $y$；\n- `B`：第二行长度不符合条件；\n- `C`：第二行出现非法字符；\n- `D`：第二行给出的构造不满足题目中关于度数的限制；\n- `E x y`：第二行给出的构造产生的答案是 $y$，而实际上答案是 $x$。\n\n该校验器和最终评测时采用的校验器可能有所不同。\n\n注意下发文件的输出样例中只有最优答案，没有构造方案。\n\n### 数据规模与约定\n\n**本题捆绑测试**。对于所有数据，$3\\le n\\le 3\\times 10^5$，$1\\le w_i\\le2\\times 10^8$，$1\\le s,t\\le n$，$s\\neq t$。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{c|c|c||c|c}\\hline\n\n\\bf 子任务 & \\bf 分值 & \\bf 依赖 & n\\le & \\bf特殊性质\n\\\\\n\\hline\n\\hline\n1 & 10 & / & 10 & /\\\\\\hline\n2 & 15 & 1 & 18 & /\\\\\\hline\n3 & 15 & / & / & v_i=u_i+1\\\\\\hline\n4 & 10 & / & / & u_i=1\\\\\\hline\n5 & 20 & / & / & 存在边\\ (s,t)\\\\\\hline\n6 & 30 & 2\\sim5 &/ & /\n\\end{array}\n$$\n\n如果你计算出了正确的答案，但是你的构造是错误的，那你将得到该测试点 $60\\%$ 的分数。注意即使你只实现了第一小问，请依旧在第二行输出任意一个非空字符串，否则可能会不计分。\n\n本题中的依赖指：某子任务的得分占比不能超过其所依赖的子任务得分占比。比如，一选手子任务 $1$ 得到 $60\\%$ 的分数，则他的子任务 $2$ 就不会超过对应的 $60\\%$ 分数，即不超过 $9$ 分。\n\n答案可能很大，请注意你使用的数据类型。\n\n---\n\n到毕业为止，Steve 也没有追到 Ada。What a sad story. :-(", "locale": "zh-CN"}}}
{"pid": "P8511", "type": "P", "difficulty": 6, "samples": [["10\n1 1 2 3 2 3 6 7 7\n10 6 4 10 8 10 5 3 5 4", "0\n15\n12\n15\n15\n15\n14\n15\n15\n15"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "O2优化", "字典树 Trie", "Ynoi"], "title": "[Ynoi Easy Round 2021] TEST_68", "background": "", "description": "给定一棵 $n$ 个节点的树，第 $i$ 个点有一个权值 $a_i$。\n\n对每个点 $x$，其的答案为其所在子树外的所有点中，选两个可以相同的点 $i,j$，$a_i$ 异或 $a_j$ 的最大值，如果选不出两个点，则认为 $x$ 的答案是 $0$。 ", "inputFormat": "第一行一个数 $n$。\n\n之后一行 $n-1$ 个数，第 $i$ 个数表示 $i+1$ 节点的父亲节点 $j$，保证 $j<i+1$。\n\n之后一行 $n$ 个元素，第 $i$ 个元素表示第 $i$ 个点的权值 $a_i$。", "outputFormat": "$n$ 行，每行一个数，其中第 $i$ 行的数表示第 $i$ 个节点对应的答案。", "hint": "Idea：nzhtl1477，Solution：zx2003，Code：nzhtl1477，Data：nzhtl1477\n\n\n对于 $10\\%$ 的数据，满足 $1 \\le n \\le 10^2$。\n\n对于另外 $20\\%$ 的数据，满足 $1 \\le n \\le 10^4$。\n\n对于另外 $30\\%$ 的数据，树构成一条链。\n\n对于另外 $20\\%$ 的数据，满足 $0 \\le a_i \\le 10^2$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n\\le 5 \\times 10^5$，$ 0\\le a_i \\le 10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2021] TEST_68", "background": "", "description": "给定一棵 $n$ 个节点的树，第 $i$ 个点有一个权值 $a_i$。\n\n对每个点 $x$，其的答案为其所在子树外的所有点中，选两个可以相同的点 $i,j$，$a_i$ 异或 $a_j$ 的最大值，如果选不出两个点，则认为 $x$ 的答案是 $0$。 ", "inputFormat": "第一行一个数 $n$。\n\n之后一行 $n-1$ 个数，第 $i$ 个数表示 $i+1$ 节点的父亲节点 $j$，保证 $j<i+1$。\n\n之后一行 $n$ 个元素，第 $i$ 个元素表示第 $i$ 个点的权值 $a_i$。", "outputFormat": "$n$ 行，每行一个数，其中第 $i$ 行的数表示第 $i$ 个节点对应的答案。", "hint": "Idea：nzhtl1477，Solution：zx2003，Code：nzhtl1477，Data：nzhtl1477\n\n\n对于 $10\\%$ 的数据，满足 $1 \\le n \\le 10^2$。\n\n对于另外 $20\\%$ 的数据，满足 $1 \\le n \\le 10^4$。\n\n对于另外 $30\\%$ 的数据，树构成一条链。\n\n对于另外 $20\\%$ 的数据，满足 $0 \\le a_i \\le 10^2$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n\\le 5 \\times 10^5$，$ 0\\le a_i \\le 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P8512", "type": "P", "difficulty": 6, "samples": [["4 5 3\n1 4 3\n2 3 1\n5 5 2\n1 2 4\n1 2\n1 4\n2 3\n", "8\n14\n4\n"], ["10 10 10\n1 5 20\n5 7 7\n3 6 8\n1 6 20\n1 7 14\n5 6 5\n9 9 18\n5 10 5\n1 9 6\n1 5 19\n1 10\n5 5\n7 10\n4 8\n1 9\n1 6\n6 7\n7 10\n2 6\n1 4\n", "124\n98\n124\n86\n59\n80\n28\n124\n80\n127\n"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "颜色段均摊（珂朵莉树 ODT）", "O2优化", "扫描线", "Ynoi"], "title": "[Ynoi Easy Round 2021] TEST_152", "background": null, "description": "转转有一个长度为 $n$ 的操作序列 $(l_i,r_i,v_i)$。\n\n现在有 $q$ 个询问 $(L,R)$。\n\n对于每次询问，你初始有一个长度为 $m$ 的序列 $c$，初值全是 $0$。\n\n现在我们依次执行操作序列的第 $L,L+1,L+2,\\cdots,R$ 项所对应的操作。\n\n每个操作是将序列 $c$ 的第 $l_i$ 项至第 $r_i$ 项赋值为 $v_i$。\n\n询问所有操作结束后整个序列 $c$ 中所有数的和。\n\n询问之间互相独立。", "inputFormat": "第一行三个正整数 $n,m,q$。\n\n第 $2$ 行至第 $n+1$ 行，每行 $3$ 个正整数，第 $i+1$ 行表示 $l_i,r_i,v_i$。\n\n后面 $q$ 行，每行两个正整数，表示一次询问 $L,R$。", "outputFormat": "$q$ 行，每行一个正整数，表示询问的答案。", "hint": "Idea：Ynoi，Solution：Ynoi，Code：Ynoi，Data：Ynoi\n\n对于 $100\\%$ 的数据，满足：\n\n$ 1 \\le n,m,q \\le 5 \\times 10^5$\n\n$ 1 \\le l_i \\le r_i \\le m$\n\n$0 \\le v_i \\le 2 \\times 10^9$\n\n$1 \\le L \\le R \\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2021] TEST_152", "background": null, "description": "转转有一个长度为 $n$ 的操作序列 $(l_i,r_i,v_i)$。\n\n现在有 $q$ 个询问 $(L,R)$。\n\n对于每次询问，你初始有一个长度为 $m$ 的序列 $c$，初值全是 $0$。\n\n现在我们依次执行操作序列的第 $L,L+1,L+2,\\cdots,R$ 项所对应的操作。\n\n每个操作是将序列 $c$ 的第 $l_i$ 项至第 $r_i$ 项赋值为 $v_i$。\n\n询问所有操作结束后整个序列 $c$ 中所有数的和。\n\n询问之间互相独立。", "inputFormat": "第一行三个正整数 $n,m,q$。\n\n第 $2$ 行至第 $n+1$ 行，每行 $3$ 个正整数，第 $i+1$ 行表示 $l_i,r_i,v_i$。\n\n后面 $q$ 行，每行两个正整数，表示一次询问 $L,R$。", "outputFormat": "$q$ 行，每行一个正整数，表示询问的答案。", "hint": "Idea：Ynoi，Solution：Ynoi，Code：Ynoi，Data：Ynoi\n\n对于 $100\\%$ 的数据，满足：\n\n$ 1 \\le n,m,q \\le 5 \\times 10^5$\n\n$ 1 \\le l_i \\le r_i \\le m$\n\n$0 \\le v_i \\le 2 \\times 10^9$\n\n$1 \\le L \\le R \\le n$。", "locale": "zh-CN"}}}
{"pid": "P8513", "type": "P", "difficulty": 7, "samples": [["5 2\n2 -1 1\n0 -3 5\n1 -3 2\n1 3 5\n3 2 2\n1 2 4\n1 -2 -9\n", "2\n9\n"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2021] TEST_136", "background": "", "description": "给定 $n$ 个点 $(x_i,y_i,c_i)$，$i=1,2,\\dots,n$，共有 $m$ 次查询操作，每次查询给定 $A,B,C$，问满足 $Ax_i+By_i+C<0$，$Ax_j+By_j+C<0$，$c_i=c_j$ 的二元组 $(i,j)$ 的个数。", "inputFormat": "第一行两个整数 $n\\ m$；\n\n接下来 $n$ 行，每行三个整数 $x_i\\ y_i\\ c_i$，$i=1,2,\\dots,n$；\n\n接下来 $m$ 行，每行三个整数 $A\\ B\\ C$。", "outputFormat": "共 $m$ 行，每行一个整数，表示答案。", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n样例解释：\n\n第一个查询对应 $(2,2)(3,3)$；\n\n第二个查询对应 $(1,1)(2,2)(2,4)(3,3)(3,5)(4,2)(4,4)(5,3)(5,5)$。\n\n数据范围：\n\n对 $5\\%$ 的数据，$n,m\\le 10^3$；\n\n对另外 $10\\%$ 的数据，$c_i\\le 2$；\n\n对另外 $15\\%$ 的数据，$c_i\\le 100$；\n\n对另外 $15\\%$​ 的数据，$\\max(|x_i|,|y_i|)=10^6$​；\n\n对另外 $15\\%$ 的数据，$|A|=|B|=1$；\n\n对另外 $10\\%$ 的数据，$n\\le 20000,\\;m\\le 200000$；\n\n对于其余数据，无特殊约束。\n\n每部分数据构成子任务，无依赖关系。\n\n所有数据满足：\n\n$1\\le n\\le 50000$；\n\n$1\\le m\\le 500000$；\n\n$A^2+B^2>0$；\n\n$-10^9\\le x_i,y_i,A,B,C\\le 10^9$；\n\n$1\\le c_i\\le n$；\n\n所有数值为整数；\n\n当 $i\\ne j$ 时，$x_i\\ne x_j$ 或 $y_i\\ne y_j$。\n\n对于除了子任务 4 以外的数据，满足 $n$ 个点的 $x,y$ 坐标分别在某个预设的区间内均匀随机选取，并保证没有重复的点，且对于第 $i$ 个点，$c_i$ 和 $x_i,y_i$ 是分别独立地随机选取的，但 $c_i$ 的分布没有特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2021] TEST_136", "background": "", "description": "给定 $n$ 个点 $(x_i,y_i,c_i)$，$i=1,2,\\dots,n$，共有 $m$ 次查询操作，每次查询给定 $A,B,C$，问满足 $Ax_i+By_i+C<0$，$Ax_j+By_j+C<0$，$c_i=c_j$ 的二元组 $(i,j)$ 的个数。", "inputFormat": "第一行两个整数 $n\\ m$；\n\n接下来 $n$ 行，每行三个整数 $x_i\\ y_i\\ c_i$，$i=1,2,\\dots,n$；\n\n接下来 $m$ 行，每行三个整数 $A\\ B\\ C$。", "outputFormat": "共 $m$ 行，每行一个整数，表示答案。", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n样例解释：\n\n第一个查询对应 $(2,2)(3,3)$；\n\n第二个查询对应 $(1,1)(2,2)(2,4)(3,3)(3,5)(4,2)(4,4)(5,3)(5,5)$。\n\n数据范围：\n\n对 $5\\%$ 的数据，$n,m\\le 10^3$；\n\n对另外 $10\\%$ 的数据，$c_i\\le 2$；\n\n对另外 $15\\%$ 的数据，$c_i\\le 100$；\n\n对另外 $15\\%$​ 的数据，$\\max(|x_i|,|y_i|)=10^6$​；\n\n对另外 $15\\%$ 的数据，$|A|=|B|=1$；\n\n对另外 $10\\%$ 的数据，$n\\le 20000,\\;m\\le 200000$；\n\n对于其余数据，无特殊约束。\n\n每部分数据构成子任务，无依赖关系。\n\n所有数据满足：\n\n$1\\le n\\le 50000$；\n\n$1\\le m\\le 500000$；\n\n$A^2+B^2>0$；\n\n$-10^9\\le x_i,y_i,A,B,C\\le 10^9$；\n\n$1\\le c_i\\le n$；\n\n所有数值为整数；\n\n当 $i\\ne j$ 时，$x_i\\ne x_j$ 或 $y_i\\ne y_j$。\n\n对于除了子任务 4 以外的数据，满足 $n$ 个点的 $x,y$ 坐标分别在某个预设的区间内均匀随机选取，并保证没有重复的点，且对于第 $i$ 个点，$c_i$ 和 $x_i,y_i$ 是分别独立地随机选取的，但 $c_i$ 的分布没有特殊限制。", "locale": "zh-CN"}}}
{"pid": "P8518", "type": "P", "difficulty": 7, "samples": [["3\n10 15 13\n2\n0 2 20\n0 1 -11\n", "0 4 13\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2021", "IOI", "交互题"], "title": "[IOI 2021] 分糖果", "background": "### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。", "description": "Khong 阿姨正在给附近一所学校的学生准备 $n$ 盒糖果。盒子的编号分别为 $0$ 到 $n - 1$，开始时盒子都为空。第 $i$ 个盒子 $(0 \\leq i \\leq n - 1)$ 至多可以容纳 $c[i]$ 块糖果（容量为 $c[i]$）。\n\nKhong 阿姨花了 $q$ 天时间准备糖果盒。在第 $j$ 天 $(0 \\leq j \\leq q - 1)$，她根据三个整数 $l[j]$、 $r[j]$ 和 $v[j]$ 执行操作，其中 $0 \\leq l[j] \\leq r[j] \\leq n - 1$ 且 $v[j] \\neq 0$。对于每个编号满足 $l[j] \\leq k \\leq r[j]$ 的盒子 $k$：\n\n- 如果 $v[j] > 0$，Khong 阿姨将糖果一块接一块地放入第 $k$ 个盒子，直到她正好放了 $v[j]$ 块糖果或者该盒子已满。也就是说，如果该盒子在这次操作之前已有 $p$ 块糖果，那么在这次操作之后盒子将有 $\\min(c[k], p + v[j])$ 块糖果。\n\n- 如果 $v[j] < 0$，Khong 阿姨将糖果一块接一块地从第 $k$ 个盒子取出，直到她正好从盒子中取出 $-v[j]$ 块糖果或者该盒子已空。也就是说，如果该盒子在这次操作之前已有 $p$ 块糖果，那么在这次操作之后盒子将有 $\\max(0, p + v[j])$ 块糖果。\n\n你的任务是求出 $q$ 天之后每个盒子中糖果的数量。", "inputFormat": "**实现细节**\n\n你要实现以下函数：\n\n```cpp\nstd::vector<int> distribute_candies(\n  \tstd::vector<int> c, std::vector<int> l, \n  \tstd::vector<int> r, std::vector<int> v)\n```\n\n- $c$：一个长度为 $n$ 的数组。 对于 $0 \\leq i \\leq n - 1$, $c[i]$ 表示盒子 $i$ 的容量。\n\n- $l$、 $r$ 和 $v$：三个长度为 $q$ 的数组。 在第 $j$ 天, 对于 $0 \\leq j \\leq q - 1$，Khong 阿姨执行由整数 $l[j]$、$r[j]$ 和 $v[j]$ 决定的操作，如题面所述。", "outputFormat": "- 该函数应该返回一个长度为 $n$ 的数组。用 $s$ 表示这个数组。 对于 $0 \\leq i \\leq n - 1$，$s[i]$ 应为 $q$ 天以后盒子 $i$ 中的糖果数量。", "hint": "**例 1**\n\n考虑如下调⽤：\n`distribute_candies([10, 15, 13], [0, 0], [2, 1], [20, -11])`\n\n这表示盒子 $0$ 的容量为 $10$ 块糖果，盒子 $1$ 的容量为 $15$ 块糖果，盒子 $2$ 的容量为 $13$ 块糖果。\n\n在第 $0$ 天结束时，盒子 $0$ 有 $\\min(c[0], 0 + v[0]) = 10$ 块糖果，盒子 $1$ 有 $\\min(c[1], 0 + v[0]) = 15$ 块糖果，盒子 2 有 $\\min(c[2], 0 + v[0]) = 13$ 块糖果。\n\n在第 $1$ 天结束时，盒子 $0$ 有 $\\max(0, 10 + v[1]) = 0$ 块糖果，盒子 $1$ 有 $\\max(0, 15 + v[1]) = 4$ 块糖果。因为 $2 > r[1]$，盒子 $2$ 中的糖果数量没有变化。每一天结束时糖果的数量总结如下：\n\n| 天 | 盒子 $0$ | 盒子 $1$ | 盒子 $2$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $0$ | $10$ | $15$ | $13$ |\n| $1$ | $0$ | $4$ | $13$ |\n\n就此情况，函数应该返回 $[0, 4, 13]$。\n\n**约束条件**\n\n- $1 \\le n \\le 200 000$\n\n- $1 \\le q \\le 200 000$\n- $1 \\le c[i] \\le 10 ^ 9$ （对所有 $0 \\le i \\le n - 1$）\n- $0 \\le l[j] \\le r[j] \\le n - 1$（对所有 $0 \\le j \\le q - 1$）\n\n- $−10 ^ 9 \\le v[j] \\le 10 ^ 9$ , $v[j] ≠ 0$（对所有 $0 \\le j \\le q - 1$）\n\n**子任务**\n\n1. （$3$ 分）$n, q \\leq 2000$\n2. （$8$ 分）$v[j] > 0$（对所有 $0 \\le j \\le q - 1$）\n3. （$27$ 分）$c[0] = c[1] = \\cdots = c[n - 1]$\n4. （$29$ 分）$l[j] = 0$ 和 $r[j] = n - 1$（对所有 $0 \\leq j \\leq q - 1$）\n5. （$33$ 分） 没有额外的约束条件。\n\n**评测程序示例**\n\n评测程序示例读入如下格式的输入：\n\n- 第 $1$ 行: $n$\n- 第 $2$ 行: $c[0] ~ c[1] ~ \\cdots ~ c[n - 1]$\n- 第 $3$ 行: $q$\n- 第 $4 + j$ 行 ( $0 \\leq j \\leq q - 1$): $l[j] ~ r[j] ~ v[j]$\n\n评测程序示例按照以下格式打印你的答案：\n\n第 $1$ 行: $s[0] ~ s[1] ~ \\cdots ~ s[n - 1]$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2021] 分糖果", "background": "### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。", "description": "Khong 阿姨正在给附近一所学校的学生准备 $n$ 盒糖果。盒子的编号分别为 $0$ 到 $n - 1$，开始时盒子都为空。第 $i$ 个盒子 $(0 \\leq i \\leq n - 1)$ 至多可以容纳 $c[i]$ 块糖果（容量为 $c[i]$）。\n\nKhong 阿姨花了 $q$ 天时间准备糖果盒。在第 $j$ 天 $(0 \\leq j \\leq q - 1)$，她根据三个整数 $l[j]$、 $r[j]$ 和 $v[j]$ 执行操作，其中 $0 \\leq l[j] \\leq r[j] \\leq n - 1$ 且 $v[j] \\neq 0$。对于每个编号满足 $l[j] \\leq k \\leq r[j]$ 的盒子 $k$：\n\n- 如果 $v[j] > 0$，Khong 阿姨将糖果一块接一块地放入第 $k$ 个盒子，直到她正好放了 $v[j]$ 块糖果或者该盒子已满。也就是说，如果该盒子在这次操作之前已有 $p$ 块糖果，那么在这次操作之后盒子将有 $\\min(c[k], p + v[j])$ 块糖果。\n\n- 如果 $v[j] < 0$，Khong 阿姨将糖果一块接一块地从第 $k$ 个盒子取出，直到她正好从盒子中取出 $-v[j]$ 块糖果或者该盒子已空。也就是说，如果该盒子在这次操作之前已有 $p$ 块糖果，那么在这次操作之后盒子将有 $\\max(0, p + v[j])$ 块糖果。\n\n你的任务是求出 $q$ 天之后每个盒子中糖果的数量。", "inputFormat": "**实现细节**\n\n你要实现以下函数：\n\n```cpp\nstd::vector<int> distribute_candies(\n  \tstd::vector<int> c, std::vector<int> l, \n  \tstd::vector<int> r, std::vector<int> v)\n```\n\n- $c$：一个长度为 $n$ 的数组。 对于 $0 \\leq i \\leq n - 1$, $c[i]$ 表示盒子 $i$ 的容量。\n\n- $l$、 $r$ 和 $v$：三个长度为 $q$ 的数组。 在第 $j$ 天, 对于 $0 \\leq j \\leq q - 1$，Khong 阿姨执行由整数 $l[j]$、$r[j]$ 和 $v[j]$ 决定的操作，如题面所述。", "outputFormat": "- 该函数应该返回一个长度为 $n$ 的数组。用 $s$ 表示这个数组。 对于 $0 \\leq i \\leq n - 1$，$s[i]$ 应为 $q$ 天以后盒子 $i$ 中的糖果数量。", "hint": "**例 1**\n\n考虑如下调⽤：\n`distribute_candies([10, 15, 13], [0, 0], [2, 1], [20, -11])`\n\n这表示盒子 $0$ 的容量为 $10$ 块糖果，盒子 $1$ 的容量为 $15$ 块糖果，盒子 $2$ 的容量为 $13$ 块糖果。\n\n在第 $0$ 天结束时，盒子 $0$ 有 $\\min(c[0], 0 + v[0]) = 10$ 块糖果，盒子 $1$ 有 $\\min(c[1], 0 + v[0]) = 15$ 块糖果，盒子 2 有 $\\min(c[2], 0 + v[0]) = 13$ 块糖果。\n\n在第 $1$ 天结束时，盒子 $0$ 有 $\\max(0, 10 + v[1]) = 0$ 块糖果，盒子 $1$ 有 $\\max(0, 15 + v[1]) = 4$ 块糖果。因为 $2 > r[1]$，盒子 $2$ 中的糖果数量没有变化。每一天结束时糖果的数量总结如下：\n\n| 天 | 盒子 $0$ | 盒子 $1$ | 盒子 $2$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $0$ | $10$ | $15$ | $13$ |\n| $1$ | $0$ | $4$ | $13$ |\n\n就此情况，函数应该返回 $[0, 4, 13]$。\n\n**约束条件**\n\n- $1 \\le n \\le 200 000$\n\n- $1 \\le q \\le 200 000$\n- $1 \\le c[i] \\le 10 ^ 9$ （对所有 $0 \\le i \\le n - 1$）\n- $0 \\le l[j] \\le r[j] \\le n - 1$（对所有 $0 \\le j \\le q - 1$）\n\n- $−10 ^ 9 \\le v[j] \\le 10 ^ 9$ , $v[j] ≠ 0$（对所有 $0 \\le j \\le q - 1$）\n\n**子任务**\n\n1. （$3$ 分）$n, q \\leq 2000$\n2. （$8$ 分）$v[j] > 0$（对所有 $0 \\le j \\le q - 1$）\n3. （$27$ 分）$c[0] = c[1] = \\cdots = c[n - 1]$\n4. （$29$ 分）$l[j] = 0$ 和 $r[j] = n - 1$（对所有 $0 \\leq j \\leq q - 1$）\n5. （$33$ 分） 没有额外的约束条件。\n\n**评测程序示例**\n\n评测程序示例读入如下格式的输入：\n\n- 第 $1$ 行: $n$\n- 第 $2$ 行: $c[0] ~ c[1] ~ \\cdots ~ c[n - 1]$\n- 第 $3$ 行: $q$\n- 第 $4 + j$ 行 ( $0 \\leq j \\leq q - 1$): $l[j] ~ r[j] ~ v[j]$\n\n评测程序示例按照以下格式打印你的答案：\n\n第 $1$ 行: $s[0] ~ s[1] ~ \\cdots ~ s[n - 1]$", "locale": "zh-CN"}}}
{"pid": "P8519", "type": "P", "difficulty": 7, "samples": [["4 5\n0 1 1 2\n0 1 0\n0 2 0\n1 2 1\n1 3 0\n3 1 2\n", "0 1 1 0\n"], ["7 10\n0 1 1 2 2 1 2\n0 1 0\n0 2 0\n1 2 1\n1 3 0\n2 3 0\n3 4 1\n3 5 2\n4 5 0\n4 6 2\n5 6 1\n", "0 1 1 0 1 0 1\n"], ["3 1\n0 0 0\n0 1 0\n", "0 0 1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2021", "IOI", "交互题", "O2优化"], "title": "[IOI 2021] 钥匙", "background": "### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。", "description": "建筑师 Timothy 设计了一个新的密室逃脱游戏。\n\n这个游戏里有 $n$ 个房间，房间从 $0$ 到 $n - 1$ 编号。最开始的时候，每个房间里都恰好有一把钥匙。每把钥匙都有一个类型，钥匙的类型是一个 $0$ 到 $n - 1$ 区间内的整数。第 $i$ 个房间里的钥匙类型是 $r[i]$。注意多个房间里可能会包含相同类型的钥匙，即$r[i]$ 的值不一定是两两不同的。 \n\n游戏里还有 $m$ 条**双向**的通道，通道从 $0$ 到 $m - 1$ 编号。第 $j$ 条通道连接了一对编号不同的房间 $u[j]$ 和 $v[j]$。同一对房间之间可能存在多条通道。\n\n参与游戏的玩家需要收集钥匙和在不同的房间之间通过通道进行移动。 当玩家使用通道 $j$ 从房间 $u[j]$ 移动到 $v[j]$ ，或者反过来从 $v[j]$ 移动到 $u[j]$ 时，我们说玩家**通过**了通道 $j$。 只有当玩家收集到类型为 $c[j]$ 的钥匙时，玩家才可以通过通道 $j$。 \n\n在游戏的任意时刻，玩家可以在某个房间 $x$ 里执行以下两种操作： \n\n- 收集房间 $x$ 里面的钥匙，钥匙的类型是 $r[x]$（除⾮对应类型的钥匙已经被收集过）。\n- 通过通道 $j$，需要满足 $u[j] = x$ 或 $v[j] = x$，且玩家已经获得 $c[j]$ 类型的钥匙。 \n\n注意玩家收集过的钥匙可以一直使用，**永远不会被丢弃**。 \n\n最初玩家会在某个房间 $s$ **开始**游戏，不带任何钥匙。 如果玩家从房间 $s$ 开始，通过一系列上述描述的两种操作，能够到达房间 $t$，那么称房间 $t$ 是**从房间 $s$ 开始可以到达的**。 \n\n对于每一个房间 $i ~ ( 0 \\le i \\le n − 1)$，定义从房间 $i$ 出发能够到达的房间数为 $p[i]$。Timothy 想要知道满⾜ $p[i]$ 值最小的下标 $i$ 的集合。", "inputFormat": "你要实现以下函数：\n\n```cpp\nstd::vector<int> find_reachable(\n\tstd::vector<int> r, std::vector<int> u, \n\tstd::vector<int> v, std::vector<int> c\n)\n```\n\n- $r$：⼀个⻓度为 $n$ 的序列。对于每⼀个 $i ~ ( 0 \\leq i \\leq n − 1)$，第 $i$ 个房间⾥的钥匙类型是 $r[i]$。\n- $u, v$：两个⻓度为 $m$ 的序列。 对于每⼀个 $j ~ ( 0 \\leq j \\leq m − 1)$，第 $j$ 条通道连接了房间 $u[j]$ 和 $v[j]$。\n- $c$：⼀个⻓度为 $m$ 的序列。对于每⼀个 $j ~ ( 0 \\leq j \\leq m − 1)$，通过通道 $j$ 需要⽤到的钥匙类型是 $c[j]$.\n", "outputFormat": "- 这个函数应该返回⼀个⻓度为 $n$ 的序列 $a$。对于 $0 \\leq i \\leq n − 1$ 中的 $i$，如果满⾜ $p[i] \\leq p[j] ~ (0 \\leq j \\leq n − 1)$ 那么 $a[i]$ 的值为 $1$，否则 $a[i]$ 的值为 $0$。", "hint": "**样例解释**\n\n对于例 $1$，考虑以下调用：\n\n```cpp\nfind_reachable([0, 1, 1, 2],\n[0, 0, 1, 1, 3], [1, 2, 2, 3, 1], [0, 0, 1, 0, 2])\n```\n\n如果玩家从房间 $0$ 开始游戏，可以执⾏以下的操作序列：\n\n| 当前房间 | 操作 |\n| :----------: | :----------: |\n| $0$ | 收集钥匙类型 $0$ |\n| $0$ | 通过通道 $0$ 到房间 $1$ |\n| $1$ | 收集钥匙类型 $1$ |\n| $1$ | 通过通道 $2$ 到房间 $2$ |\n| $2$ | 通过通道 $2$ 到房间 $1$ |\n| $1$ | 通过通道 $3$ 到房间 $3$ |\n\n因此从房间 $0$ 出发可以到达房间 $3$。 类似地，我们可以构造出操作序列表明所有 $4$ 个房间都是从房间 $0$ 出发可达的，所以 $p[0] = 4$。 下表展⽰了从各个房间出发可以到达的房间集合：\n\n| 开始房间 $i$ | 可以到达的房间 | $p[i]$ |\n| :----------: | :------------: | :----: |\n|     $0$      | $[0, 1, 2, 3]$ |  $4$   |\n|     $1$      |    $[1, 2]$    |  $2$   |\n|     $2$      |    $[1, 2]$    |  $2$   |\n|     $3$      |  $[1, 2, 3]$   |  $3$   |\n\n所有房间中 $p[i]$ 的最小值是 $2$，这可以在 $i = 1$ 或 $i = 2$ 处取得。所以这次函数调⽤的返回值是 $[0, 1, 1, 0]$。\n\n对于例 $2$：所有房间中 $p[i]$ 的最小值是 $2$，这可以在 $i \\in \\{1, 2, 4, 6\\}$ 处取得。所以这次函数调⽤的返回值是\n$[0, 1, 1, 0, 1, 0, 1]$。\n\n对于例 $3$：所有房间中 $p[i]$ 的最小值是 $1$，这可以在 $i = 2$ 处取得。所以这次函数调⽤的返回值是 $[0, 0, 1]$。\n\n**约束条件**\n\n- $2 \\leq n \\leq 3 \\times 10 ^ 5$\n- $1 \\leq m \\leq 3 \\times 10 ^ 5$\n- $0 \\leq r[i] \\leq n - 1$ （对于所有的 $0 \\leq i \\leq n - 1$）\n- $0 \\leq u[j], v[j] \\leq n - 1$ 且 $u[j] \\neq v[j]$ （对于所有的 $0 \\leq j \\leq m - 1$）\n- $0 \\leq c[j] \\leq n - 1$（对于所有的 $0 \\leq j \\leq m - 1$）\n\n**子任务**\n\n1. （$9$ 分） $c[j] = 0$（对于所有的 $0 \\leq j \\leq m − 1$）且 $n, m \\leq 200$  \n2. （$11$ 分） $n, m \\leq 20$\n3. （$17$ 分） $n, m \\leq 2000$ \n4. （$30$ 分） $c[j] \\leq 29$（对于所有的 $0 \\leq j \\leq m − 1$）且 $r[i] \\leq 29$（对于所有的 $0 \\leq i \\leq n − 1$） \n5. （$33$ 分）没有额外的约束条件。\n\n**样例评分程序**\n\n评测程序⽰例以如下格式读取输⼊数据：\n\n- 第 $1$ ⾏：$n ~ m$\n- 第 $2$ ⾏： $r[0] ~ r[1] ~ \\cdots ~ r[n − 1]$\n- 第 $3 + j$ ⾏ $( 0 \\leq j \\leq m − 1)$： $u[j] ~ v[j] ~ c[j]$\n\n样例评分程序按照以下格式打印 `find_reachable` 函数的返回值：\n\n第 $1$ ⾏： $s[0] ~ s[1] \\cdots ~ s[n − 1]$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2021] 钥匙", "background": "### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。", "description": "建筑师 Timothy 设计了一个新的密室逃脱游戏。\n\n这个游戏里有 $n$ 个房间，房间从 $0$ 到 $n - 1$ 编号。最开始的时候，每个房间里都恰好有一把钥匙。每把钥匙都有一个类型，钥匙的类型是一个 $0$ 到 $n - 1$ 区间内的整数。第 $i$ 个房间里的钥匙类型是 $r[i]$。注意多个房间里可能会包含相同类型的钥匙，即$r[i]$ 的值不一定是两两不同的。 \n\n游戏里还有 $m$ 条**双向**的通道，通道从 $0$ 到 $m - 1$ 编号。第 $j$ 条通道连接了一对编号不同的房间 $u[j]$ 和 $v[j]$。同一对房间之间可能存在多条通道。\n\n参与游戏的玩家需要收集钥匙和在不同的房间之间通过通道进行移动。 当玩家使用通道 $j$ 从房间 $u[j]$ 移动到 $v[j]$ ，或者反过来从 $v[j]$ 移动到 $u[j]$ 时，我们说玩家**通过**了通道 $j$。 只有当玩家收集到类型为 $c[j]$ 的钥匙时，玩家才可以通过通道 $j$。 \n\n在游戏的任意时刻，玩家可以在某个房间 $x$ 里执行以下两种操作： \n\n- 收集房间 $x$ 里面的钥匙，钥匙的类型是 $r[x]$（除⾮对应类型的钥匙已经被收集过）。\n- 通过通道 $j$，需要满足 $u[j] = x$ 或 $v[j] = x$，且玩家已经获得 $c[j]$ 类型的钥匙。 \n\n注意玩家收集过的钥匙可以一直使用，**永远不会被丢弃**。 \n\n最初玩家会在某个房间 $s$ **开始**游戏，不带任何钥匙。 如果玩家从房间 $s$ 开始，通过一系列上述描述的两种操作，能够到达房间 $t$，那么称房间 $t$ 是**从房间 $s$ 开始可以到达的**。 \n\n对于每一个房间 $i ~ ( 0 \\le i \\le n − 1)$，定义从房间 $i$ 出发能够到达的房间数为 $p[i]$。Timothy 想要知道满⾜ $p[i]$ 值最小的下标 $i$ 的集合。", "inputFormat": "你要实现以下函数：\n\n```cpp\nstd::vector<int> find_reachable(\n\tstd::vector<int> r, std::vector<int> u, \n\tstd::vector<int> v, std::vector<int> c\n)\n```\n\n- $r$：⼀个⻓度为 $n$ 的序列。对于每⼀个 $i ~ ( 0 \\leq i \\leq n − 1)$，第 $i$ 个房间⾥的钥匙类型是 $r[i]$。\n- $u, v$：两个⻓度为 $m$ 的序列。 对于每⼀个 $j ~ ( 0 \\leq j \\leq m − 1)$，第 $j$ 条通道连接了房间 $u[j]$ 和 $v[j]$。\n- $c$：⼀个⻓度为 $m$ 的序列。对于每⼀个 $j ~ ( 0 \\leq j \\leq m − 1)$，通过通道 $j$ 需要⽤到的钥匙类型是 $c[j]$.\n", "outputFormat": "- 这个函数应该返回⼀个⻓度为 $n$ 的序列 $a$。对于 $0 \\leq i \\leq n − 1$ 中的 $i$，如果满⾜ $p[i] \\leq p[j] ~ (0 \\leq j \\leq n − 1)$ 那么 $a[i]$ 的值为 $1$，否则 $a[i]$ 的值为 $0$。", "hint": "**样例解释**\n\n对于例 $1$，考虑以下调用：\n\n```cpp\nfind_reachable([0, 1, 1, 2],\n[0, 0, 1, 1, 3], [1, 2, 2, 3, 1], [0, 0, 1, 0, 2])\n```\n\n如果玩家从房间 $0$ 开始游戏，可以执⾏以下的操作序列：\n\n| 当前房间 | 操作 |\n| :----------: | :----------: |\n| $0$ | 收集钥匙类型 $0$ |\n| $0$ | 通过通道 $0$ 到房间 $1$ |\n| $1$ | 收集钥匙类型 $1$ |\n| $1$ | 通过通道 $2$ 到房间 $2$ |\n| $2$ | 通过通道 $2$ 到房间 $1$ |\n| $1$ | 通过通道 $3$ 到房间 $3$ |\n\n因此从房间 $0$ 出发可以到达房间 $3$。 类似地，我们可以构造出操作序列表明所有 $4$ 个房间都是从房间 $0$ 出发可达的，所以 $p[0] = 4$。 下表展⽰了从各个房间出发可以到达的房间集合：\n\n| 开始房间 $i$ | 可以到达的房间 | $p[i]$ |\n| :----------: | :------------: | :----: |\n|     $0$      | $[0, 1, 2, 3]$ |  $4$   |\n|     $1$      |    $[1, 2]$    |  $2$   |\n|     $2$      |    $[1, 2]$    |  $2$   |\n|     $3$      |  $[1, 2, 3]$   |  $3$   |\n\n所有房间中 $p[i]$ 的最小值是 $2$，这可以在 $i = 1$ 或 $i = 2$ 处取得。所以这次函数调⽤的返回值是 $[0, 1, 1, 0]$。\n\n对于例 $2$：所有房间中 $p[i]$ 的最小值是 $2$，这可以在 $i \\in \\{1, 2, 4, 6\\}$ 处取得。所以这次函数调⽤的返回值是\n$[0, 1, 1, 0, 1, 0, 1]$。\n\n对于例 $3$：所有房间中 $p[i]$ 的最小值是 $1$，这可以在 $i = 2$ 处取得。所以这次函数调⽤的返回值是 $[0, 0, 1]$。\n\n**约束条件**\n\n- $2 \\leq n \\leq 3 \\times 10 ^ 5$\n- $1 \\leq m \\leq 3 \\times 10 ^ 5$\n- $0 \\leq r[i] \\leq n - 1$ （对于所有的 $0 \\leq i \\leq n - 1$）\n- $0 \\leq u[j], v[j] \\leq n - 1$ 且 $u[j] \\neq v[j]$ （对于所有的 $0 \\leq j \\leq m - 1$）\n- $0 \\leq c[j] \\leq n - 1$（对于所有的 $0 \\leq j \\leq m - 1$）\n\n**子任务**\n\n1. （$9$ 分） $c[j] = 0$（对于所有的 $0 \\leq j \\leq m − 1$）且 $n, m \\leq 200$  \n2. （$11$ 分） $n, m \\leq 20$\n3. （$17$ 分） $n, m \\leq 2000$ \n4. （$30$ 分） $c[j] \\leq 29$（对于所有的 $0 \\leq j \\leq m − 1$）且 $r[i] \\leq 29$（对于所有的 $0 \\leq i \\leq n − 1$） \n5. （$33$ 分）没有额外的约束条件。\n\n**样例评分程序**\n\n评测程序⽰例以如下格式读取输⼊数据：\n\n- 第 $1$ ⾏：$n ~ m$\n- 第 $2$ ⾏： $r[0] ~ r[1] ~ \\cdots ~ r[n − 1]$\n- 第 $3 + j$ ⾏ $( 0 \\leq j \\leq m − 1)$： $u[j] ~ v[j] ~ c[j]$\n\n样例评分程序按照以下格式打印 `find_reachable` 函数的返回值：\n\n第 $1$ ⾏： $s[0] ~ s[1] \\cdots ~ s[n − 1]$", "locale": "zh-CN"}}}
{"pid": "P8520", "type": "P", "difficulty": 7, "samples": [["5\n4 4\n4 6\n6 4\n4 2\n2 4\n", "1\n4\n0 2 5 5\n0 1 3 5\n3 0 5 3\n4 0 3 3\n"], ["2\n2 2\n4 6\n", "0\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2021", "IOI", "交互题", "Special Judge", "O2优化"], "title": "[IOI 2021] 喷泉公园", "background": "### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。但是你的代码需要声明 `void build(std::vector<int> u, std::vector<int> v, std::vector<int> a, std::vector<int> b)` 函数。\n\n具体的，以下是一种模板：\n```cpp\n#include <vector>\n\nvoid build(std::vector<int> u, std::vector<int> v, std::vector<int> a, std::vector<int> b);\n\nint construct_roads(std::vector<int> x, std::vector<int> y) {\n    // Code here...\n}\n```\n\n由于洛谷技术限制，本题仅包含 IOI 官方数据的部分测试点。", "description": "在附近的一个公园里，有 $n$ 座**喷泉**，编号为从 $0$ 到 $n - 1$。我们把喷泉看成是二维平面上的点。也就是说，喷泉 $i ~ (0 \\leq i \\leq n - 1)$ 是一个点 $(x _ i, y _ i)$，这里 $x _ i$ 和 $y _ i$ 是**偶数**。喷泉的位置各不相同。\n\n建筑师 Timothy 受雇来规划一些**道路**的建设，以及每条道路对应的长椅的摆放。每条道路都是一个长度为 $2$ 的**横向**或**纵向**的线段，其端点是两座不同的喷泉。游客应该能够沿着它们即可在任意两座喷泉之间互相抵达。在最开始时，公园里没有任何道路。\n\n对于每条道路，都要在公园里摆放恰好一个长椅，并将其**分配给**（也就是面朝）这条道路。每个长椅必须摆放在某个点 $(a, ~ b)$ 上，这里 $a$ 和 $b$ 都是**奇数**。所有长椅的位置必须都是**不同的**。在 $(a, ~ b)$ 处的长椅，只能分配给两个端点均为 $(a - 1, ~ b - 1), (a - 1, ~ b + 1), (a + 1, ~ b - 1)$ 和 $(a + 1, ~ b + 1)$ 其中之一的道路。举例来说，在 $(3, ~ 3)$ 处的长椅只能分配给下面四条线段所表示的道路之一：$(2, ~ 2), - (2, ~ 4), ~ (2 , ~ 4) - (4, ~ 4), ~ (4, ~ 4) - (4, ~ 2), ~ (4, ~ 2) - (2, ~ 2)$。\n\n请帮助 Timothy 判断一下，能否在满足上述所有要求的前提下，造出所有道路，并摆放和分配长椅。如果这能做到，请给他一个可行的解决方案。如果有多个满足所有要求的方案，你可以报告其中的任意方案。", "inputFormat": "你要实现以下函数：\n\n```cpp\nint construct_roads(std::vector<int> x, std::vector<int> y)\n```\n- $x, ~ y$: 长度为 $n$ 的两个数组。对所有 $i ~ (0 \\leq i \\leq n - 1)$，喷泉 $i$ 是一个点 $(x[i], y[i]$，这里 $(x[i], y[i])$ 都是偶数。\n- 如果存在某个建设方案，函数应当调用 `build`（参见下文）恰好一次来报告建设方案，并紧接着返回 $1$。\n- 否则，函数应当返回 $0$，并且不做 `build` 的任何调用。\n- 该函数将被调用恰好一次。\n\n你实现的函数可以调用下面的函数，以提供一个可行的道路建设与长椅摆放方案。\n```cpp\nvoid build(std::vector<int> u, std::vector<int> v, std::vector<int> a, std::vector<int> b)\n```\n\n- 设 $m$ 为建设方案中道路的个数。\n- $u, v$: 长度为 $m$ 的两个数组，表示要建设的道路。这些道路的编号为从 $0$ 到 $m - 1$。对所有的 $j ~ (0 \\leq j \\leq m - 1)$，道路 $j$ 要连接喷泉 $u[j]$ 和 $v[j]$。每条道路必须是长度为 $2$ 的横向或纵向线段。任意两条不同的道路，最多只能有一个公共端点（某个喷泉）。这些道路在建成之后，必须能够沿着它们就可以在任意两个喷泉之间相互抵达。\n- $a, b$: 长度为 $m$ 的两个数组，表示长椅。对所有的 $j ~ (0 \\leq j \\leq m - 1)$，将在 $(a[j], b[j])$ 处摆放一个长椅，并且分配给道路 $j$。不同的长椅不能摆放在同一位置。", "outputFormat": "", "hint": "**例 1**\n\n考虑如下调用：\n```cpp\nconstruct_roads([4, 4, 6, 4, 2], [4, 6, 4, 2, 4])\n```\n\n这意味着总共有 $5$ 座喷泉：\n\n- 喷泉 $0$ 坐落在 $(4, 4)$ 处。\n- 喷泉 $1$ 坐落在 $(4, 6)$ 处。\n- 喷泉 $2$ 坐落在 $(6, 4)$ 处。\n- 喷泉 $3$ 坐落在 $(4, 2)$ 处。\n- 喷泉 $4$ 坐落在 $(2, 4)$ 处。\n\n可以建造下面这样 $4$ 条道路，其中每条道路连接两座喷泉，并且摆放着对应的长椅。\n\n| 道路编号 | 道路所连接的喷泉编号 | 所分配的长椅的位置 |\n| :----------: | :----------: | :----------: |\n| $0$ | $0, 2$ | $(5, 5)$ |\n| $1$ | $0, 1$ | $(3, 5)$ |\n| $2$ | $3, 0$ | $(5, 3)$ |\n| $3$ | $4, 0$ | $(3, 3)$ |\n\n该方案对应下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s7vv14bj.png)\n\n为报告此方案，`construct_roads` 应做如下调用：\n\n```cpp\nbuild([0, 0, 3, 4], [2, 1, 0, 0], [5, 3, 5, 3], [5, 5, 3, 3])\n```\n\n随后它应当返回 $1$，\n\n注意，在这个例子中，有多个满足要求的方案，它们都被视为正确。\n\n**例 2**\n\n考虑如下调用：\n\n```cpp\nconstruct_roads([2, 4], [2, 6])\n```\n\n喷泉 $0$ 坐落在 $(2, 2)$ 处，而喷泉 $1$ 坐落在 $(4, 6)$ 处。由于不可能建造出满⾜要求的道路，\n`construct_roads` 应当返回 $0$，并且不做 `build` 的任何调⽤。\n\n**约束条件**\n\n- $1 \\leq n \\leq 2 \\times 10 ^ 5$\n- $2 \\leq x[i], y[i] \\leq 2 \\times 10 ^ 5$\n- $x[i], y[i]$ 都是偶数。\n- 任意两座喷泉的位置都不相同。\n\n**子任务**\n\n1. （$5$ 分）$x[i] = 2$\n2. （$10$ 分）$2 \\leq x[i] \\leq 4$\n3. （$15$ 分）$2 \\leq x[i] \\leq 6$\n4. （$20$ 分）至多只有一种道路建设方案，能够让游客在任意两座喷泉之间沿着这些道路即可抵达。\n5. （$20$ 分）任意四座喷泉都不会构成某一个 $2 \\times 2$ 正方形的四个顶点。\n6. （$30$ 分）没有额外的约束条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2021] 喷泉公园", "background": "### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。但是你的代码需要声明 `void build(std::vector<int> u, std::vector<int> v, std::vector<int> a, std::vector<int> b)` 函数。\n\n具体的，以下是一种模板：\n```cpp\n#include <vector>\n\nvoid build(std::vector<int> u, std::vector<int> v, std::vector<int> a, std::vector<int> b);\n\nint construct_roads(std::vector<int> x, std::vector<int> y) {\n    // Code here...\n}\n```\n\n由于洛谷技术限制，本题仅包含 IOI 官方数据的部分测试点。", "description": "在附近的一个公园里，有 $n$ 座**喷泉**，编号为从 $0$ 到 $n - 1$。我们把喷泉看成是二维平面上的点。也就是说，喷泉 $i ~ (0 \\leq i \\leq n - 1)$ 是一个点 $(x _ i, y _ i)$，这里 $x _ i$ 和 $y _ i$ 是**偶数**。喷泉的位置各不相同。\n\n建筑师 Timothy 受雇来规划一些**道路**的建设，以及每条道路对应的长椅的摆放。每条道路都是一个长度为 $2$ 的**横向**或**纵向**的线段，其端点是两座不同的喷泉。游客应该能够沿着它们即可在任意两座喷泉之间互相抵达。在最开始时，公园里没有任何道路。\n\n对于每条道路，都要在公园里摆放恰好一个长椅，并将其**分配给**（也就是面朝）这条道路。每个长椅必须摆放在某个点 $(a, ~ b)$ 上，这里 $a$ 和 $b$ 都是**奇数**。所有长椅的位置必须都是**不同的**。在 $(a, ~ b)$ 处的长椅，只能分配给两个端点均为 $(a - 1, ~ b - 1), (a - 1, ~ b + 1), (a + 1, ~ b - 1)$ 和 $(a + 1, ~ b + 1)$ 其中之一的道路。举例来说，在 $(3, ~ 3)$ 处的长椅只能分配给下面四条线段所表示的道路之一：$(2, ~ 2), - (2, ~ 4), ~ (2 , ~ 4) - (4, ~ 4), ~ (4, ~ 4) - (4, ~ 2), ~ (4, ~ 2) - (2, ~ 2)$。\n\n请帮助 Timothy 判断一下，能否在满足上述所有要求的前提下，造出所有道路，并摆放和分配长椅。如果这能做到，请给他一个可行的解决方案。如果有多个满足所有要求的方案，你可以报告其中的任意方案。", "inputFormat": "你要实现以下函数：\n\n```cpp\nint construct_roads(std::vector<int> x, std::vector<int> y)\n```\n- $x, ~ y$: 长度为 $n$ 的两个数组。对所有 $i ~ (0 \\leq i \\leq n - 1)$，喷泉 $i$ 是一个点 $(x[i], y[i]$，这里 $(x[i], y[i])$ 都是偶数。\n- 如果存在某个建设方案，函数应当调用 `build`（参见下文）恰好一次来报告建设方案，并紧接着返回 $1$。\n- 否则，函数应当返回 $0$，并且不做 `build` 的任何调用。\n- 该函数将被调用恰好一次。\n\n你实现的函数可以调用下面的函数，以提供一个可行的道路建设与长椅摆放方案。\n```cpp\nvoid build(std::vector<int> u, std::vector<int> v, std::vector<int> a, std::vector<int> b)\n```\n\n- 设 $m$ 为建设方案中道路的个数。\n- $u, v$: 长度为 $m$ 的两个数组，表示要建设的道路。这些道路的编号为从 $0$ 到 $m - 1$。对所有的 $j ~ (0 \\leq j \\leq m - 1)$，道路 $j$ 要连接喷泉 $u[j]$ 和 $v[j]$。每条道路必须是长度为 $2$ 的横向或纵向线段。任意两条不同的道路，最多只能有一个公共端点（某个喷泉）。这些道路在建成之后，必须能够沿着它们就可以在任意两个喷泉之间相互抵达。\n- $a, b$: 长度为 $m$ 的两个数组，表示长椅。对所有的 $j ~ (0 \\leq j \\leq m - 1)$，将在 $(a[j], b[j])$ 处摆放一个长椅，并且分配给道路 $j$。不同的长椅不能摆放在同一位置。", "outputFormat": "", "hint": "**例 1**\n\n考虑如下调用：\n```cpp\nconstruct_roads([4, 4, 6, 4, 2], [4, 6, 4, 2, 4])\n```\n\n这意味着总共有 $5$ 座喷泉：\n\n- 喷泉 $0$ 坐落在 $(4, 4)$ 处。\n- 喷泉 $1$ 坐落在 $(4, 6)$ 处。\n- 喷泉 $2$ 坐落在 $(6, 4)$ 处。\n- 喷泉 $3$ 坐落在 $(4, 2)$ 处。\n- 喷泉 $4$ 坐落在 $(2, 4)$ 处。\n\n可以建造下面这样 $4$ 条道路，其中每条道路连接两座喷泉，并且摆放着对应的长椅。\n\n| 道路编号 | 道路所连接的喷泉编号 | 所分配的长椅的位置 |\n| :----------: | :----------: | :----------: |\n| $0$ | $0, 2$ | $(5, 5)$ |\n| $1$ | $0, 1$ | $(3, 5)$ |\n| $2$ | $3, 0$ | $(5, 3)$ |\n| $3$ | $4, 0$ | $(3, 3)$ |\n\n该方案对应下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s7vv14bj.png)\n\n为报告此方案，`construct_roads` 应做如下调用：\n\n```cpp\nbuild([0, 0, 3, 4], [2, 1, 0, 0], [5, 3, 5, 3], [5, 5, 3, 3])\n```\n\n随后它应当返回 $1$，\n\n注意，在这个例子中，有多个满足要求的方案，它们都被视为正确。\n\n**例 2**\n\n考虑如下调用：\n\n```cpp\nconstruct_roads([2, 4], [2, 6])\n```\n\n喷泉 $0$ 坐落在 $(2, 2)$ 处，而喷泉 $1$ 坐落在 $(4, 6)$ 处。由于不可能建造出满⾜要求的道路，\n`construct_roads` 应当返回 $0$，并且不做 `build` 的任何调⽤。\n\n**约束条件**\n\n- $1 \\leq n \\leq 2 \\times 10 ^ 5$\n- $2 \\leq x[i], y[i] \\leq 2 \\times 10 ^ 5$\n- $x[i], y[i]$ 都是偶数。\n- 任意两座喷泉的位置都不相同。\n\n**子任务**\n\n1. （$5$ 分）$x[i] = 2$\n2. （$10$ 分）$2 \\leq x[i] \\leq 4$\n3. （$15$ 分）$2 \\leq x[i] \\leq 6$\n4. （$20$ 分）至多只有一种道路建设方案，能够让游客在任意两座喷泉之间沿着这些道路即可抵达。\n5. （$20$ 分）任意四座喷泉都不会构成某一个 $2 \\times 2$ 正方形的四个顶点。\n6. （$30$ 分）没有额外的约束条件。", "locale": "zh-CN"}}}
{"pid": "P8521", "type": "P", "difficulty": 4, "samples": [["6 3\nATACAT\nACTATA\n1 3\n4 5\n3 5", "2\n1\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000]}, "tags": ["2021", "IOI", "交互题", "前缀和"], "title": "[IOI 2021] 修改 DNA", "background": "**滥用本题评测将被封号**\n\n**由于技术限制，请不要使用 C++ 14 (GCC 9) 语言提交本题。**\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数", "description": "Grace 是一名生物学家，在新加坡的一个生物信息学公司工作。她的一部分工作是分析不同有机体的 DNA 序列。DNA 序列是包含字符 A、T 和 C 的字符串。注意在本题中，DNA 序列不包含字符 G。\n\n定义一次修改是把 DNA 序列中的两个元素交换位置的操作。例如，通过交换加粗的字符 A 和 C，一次修改可以把 A**C**T**A** 转化为 A**A**T**C**。\n\n两个序列的修改距离是把一个序列转化为另一个序列所用的最少修改次数。如果不能通过修改把一个序列转化为另一个序列，那么这两个序列的修改距离为 $-1$。\n\nGrace 正在分析两个 DNA 序列 $a$ 和 $b$，每个都由 n 个元素组成，下标从 $0$ 到 $n - 1$。你的任务是帮助 Grace 回答以下形式的 $q$ 个问题：子串 $a[x \\ldots y]$ 和 $b[x \\ldots y]$ 的修改距离是多少？这里，DNA 序列 $s$ 的子串 $s[x \\ldots y]$ 定义为 $s$ 的下标从 $x$ 到 $y$（包括 x 和 y）的连续字符序列。也就是说，$s[x \\ldots y]$ 是序列 $s[x] s[x + 1] \\ldots s[y]$。", "inputFormat": "你要实现以下函数：\n```cpp\nvoid init(string a, string b)\n  ```\n- $a, b$：长度为 $n$ 的字符串，表示两个待分析的 DNA 序列。\n恰好调用此函数一次，且发生在任何对 `get_distance` 的调用之前。\n```cpp\nint get_distance(int x, int y)\n```\n- $x, y$：待分析的子串的开始和结束下标。\n此函数应返回子串 $a[x \\ldots y]$ 和 $b[x \\ldots y]$ 的修改距离。\n恰好调用此函数 $q$ 次。", "outputFormat": "", "hint": "对于所有数据：\n\n- $1 \\le n, q \\le 100 \\, 000$\n- $0 \\le x \\le y \\le n - 1$\n- $a$ 和 $b$ 的每个字符都是 A、T 和 C 之⼀\n\n子任务|分值|特殊限制\n:-:|:-:|:-:\n$1$\t|$21$|$y - x \\le 2$\n$2$\t|$22$|\t$q \\le 500$，$y - x \\le 1000$，$a$ 和 $b$ 的每个字符是 A 或 T\n$3$\t|$13$|\t$a$ 和 $b$ 的每个字符是 A 或 T\n$4$\t|$28$|\t$q \\le 500$，$y - x \\le 1000$\n$5$\t|$16$|\t没有额外的约束条件\n\n## 样例解释\n\n如果评测程序调用 `get_distance(1, 3)`，那么该调用应返回 $a[1 \\ldots 3]$ 和 $b[1 \\ldots 3]$（也就是序列 TAC 和 CTA）之间的修改距离。通过 $2$ 次修改可以把 TAC 转化为 CTA：TAC $\\to$ CAT，然后是 CAT $\\to$ CTA。无法通过比 $2$ 次更少的修改完成该转化。\n\n因此，该调用应返回 $2$。\n\n如果评测程序调用 `get_distance(4, 5)`，那么该调用应返回序列 AT 和 TA 之间的修改距离。 通过一次修改可以把 AT 转化为 TA，而且显然至少需要一次。\n\n因此，该调用应返回 $1$。\n\n最后，如果评测程序调用 `get_distance(3, 5)`，由于无法通过修改将序列 CAT 转化为 ATA，因此该调用应返回 $-1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2021] 修改 DNA", "background": "**滥用本题评测将被封号**\n\n**由于技术限制，请不要使用 C++ 14 (GCC 9) 语言提交本题。**\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数", "description": "Grace 是一名生物学家，在新加坡的一个生物信息学公司工作。她的一部分工作是分析不同有机体的 DNA 序列。DNA 序列是包含字符 A、T 和 C 的字符串。注意在本题中，DNA 序列不包含字符 G。\n\n定义一次修改是把 DNA 序列中的两个元素交换位置的操作。例如，通过交换加粗的字符 A 和 C，一次修改可以把 A**C**T**A** 转化为 A**A**T**C**。\n\n两个序列的修改距离是把一个序列转化为另一个序列所用的最少修改次数。如果不能通过修改把一个序列转化为另一个序列，那么这两个序列的修改距离为 $-1$。\n\nGrace 正在分析两个 DNA 序列 $a$ 和 $b$，每个都由 n 个元素组成，下标从 $0$ 到 $n - 1$。你的任务是帮助 Grace 回答以下形式的 $q$ 个问题：子串 $a[x \\ldots y]$ 和 $b[x \\ldots y]$ 的修改距离是多少？这里，DNA 序列 $s$ 的子串 $s[x \\ldots y]$ 定义为 $s$ 的下标从 $x$ 到 $y$（包括 x 和 y）的连续字符序列。也就是说，$s[x \\ldots y]$ 是序列 $s[x] s[x + 1] \\ldots s[y]$。", "inputFormat": "你要实现以下函数：\n```cpp\nvoid init(string a, string b)\n  ```\n- $a, b$：长度为 $n$ 的字符串，表示两个待分析的 DNA 序列。\n恰好调用此函数一次，且发生在任何对 `get_distance` 的调用之前。\n```cpp\nint get_distance(int x, int y)\n```\n- $x, y$：待分析的子串的开始和结束下标。\n此函数应返回子串 $a[x \\ldots y]$ 和 $b[x \\ldots y]$ 的修改距离。\n恰好调用此函数 $q$ 次。", "outputFormat": "", "hint": "对于所有数据：\n\n- $1 \\le n, q \\le 100 \\, 000$\n- $0 \\le x \\le y \\le n - 1$\n- $a$ 和 $b$ 的每个字符都是 A、T 和 C 之⼀\n\n子任务|分值|特殊限制\n:-:|:-:|:-:\n$1$\t|$21$|$y - x \\le 2$\n$2$\t|$22$|\t$q \\le 500$，$y - x \\le 1000$，$a$ 和 $b$ 的每个字符是 A 或 T\n$3$\t|$13$|\t$a$ 和 $b$ 的每个字符是 A 或 T\n$4$\t|$28$|\t$q \\le 500$，$y - x \\le 1000$\n$5$\t|$16$|\t没有额外的约束条件\n\n## 样例解释\n\n如果评测程序调用 `get_distance(1, 3)`，那么该调用应返回 $a[1 \\ldots 3]$ 和 $b[1 \\ldots 3]$（也就是序列 TAC 和 CTA）之间的修改距离。通过 $2$ 次修改可以把 TAC 转化为 CTA：TAC $\\to$ CAT，然后是 CAT $\\to$ CTA。无法通过比 $2$ 次更少的修改完成该转化。\n\n因此，该调用应返回 $2$。\n\n如果评测程序调用 `get_distance(4, 5)`，那么该调用应返回序列 AT 和 TA 之间的修改距离。 通过一次修改可以把 AT 转化为 TA，而且显然至少需要一次。\n\n因此，该调用应返回 $1$。\n\n最后，如果评测程序调用 `get_distance(3, 5)`，由于无法通过修改将序列 CAT 转化为 ATA，因此该调用应返回 $-1$。", "locale": "zh-CN"}}}
{"pid": "P8522", "type": "P", "difficulty": 7, "samples": [["3 2\n2 6 9\n3 1 2\n2 2 3\n1 0 1\n0 1\n2 3", "24\n25"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000]}, "tags": ["倍增", "2021", "IOI", "交互题"], "title": "[IOI 2021] 地牢游戏", "background": "**滥用本题评测将被封号**\n\n**由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。**\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。", "description": "Robert 正在设计一款新的电脑游戏。游戏中有一位英雄、$n$ 个敌人和 $n + 1$ 个地牢。敌人从 $0$ 到 $n - 1$ 编号，地牢从 $0$ 到 $n$ 编号。敌人 $i$（$0 \\le i \\le n - 1$）处在地牢 $i$，其能力值为 $s[i]$。地牢 $n$ 里没有敌人。\n\n英雄一开始进入地牢 $x$，初始能力值为 $z$。每次英雄进入地牢 $i$（$0 \\le i \\le n - 1$）时，都需要面对敌人 $i$，且会发生以下情况中的一种：\n\n如果英雄的能力值大于等于敌人 $i$ 的能力值 $s[i]$，那么英雄会胜出。这使得英雄的能力值增加 $s[i]$（$s[i] \\ge 1$）。这种情况下，下一步英雄将会进入地牢 $w[i]$（$w[i] > i$）。\n\n否则英雄会战败，这使得英雄的能力值增加 $p[i]$（$p[i] \\ge 1$）。在这种情况下，下一步英雄将会进入地牢 $l[i]$。\n\n注意 $p[i]$ 可能会小于、等于、大于 $s[i]$，$l[i]$ 可能会小于、等于、大于 $i$。无论对战结果如何，敌人 $i$ 始终处在地牢 $i$，且能力值为 $s[i]$。\n\n当英雄进入地牢 $n$ 的时候，游戏结束。可以看出无论英雄的起始地牢和初始能力值如何，游戏一定会在有限次对战之后结束。\n\nRobert 希望你通过 $q$ 次模拟来对游戏进行测试。对于每次模拟，Robert 输入英雄的起始地牢 $x$ 和初始能力值 $z$。你需要做的是对于每次模拟给出游戏结束时英雄的能力值。", "inputFormat": "你要实现以下函数：\n```cpp\nvoid init(int n, int[] s, int[] p, int[] w, int[] l)\n```\n- $n$：敌人的数量。\n$s$、$p$、$w$、$l$：长度为 $n$ 的序列。对于每一个 $i$（$0 \\le i \\le n - 1$）：\n  + $s[i]$ 是敌人 $i$ 的能力值，也是击败敌人 $i$ 后英雄增加的能力值。\n  + $p[i]$ 是英雄被敌人 $i$ 击败后增加的能力值。\n  + $w[i]$ 是英雄击败敌人 $i$ 后进入的下一个地牢的编号。\n  + $l[i]$ 是英雄被敌人 $i$ 击败后进入的下一个地牢的编号。\n- 恰好调用此函数一次，且发生在任何对如下的 simulate 函数的调用之前。\n```cpp\nint64 simulate(int x, int z)\n```\n- $x$：英雄的起始地牢编号。\n- $z$：英雄的初始能力值。\n- 假设英雄的起始地牢编号为 $x$，初始能力值为 $z$，函数的返回值是相应情况下游戏结束时英雄的能力值。\n- 恰好调用此函数 $q$ 次。", "outputFormat": "", "hint": "对于所有数据：\n\n- $1 \\le n \\le 400 \\, 000$\n- $1 \\le q \\le 50 \\, 000$\n- $1 \\le s[i], p[i] \\le {10}^7$（对于所有的 $0 \\le i \\le n - 1$）\n- $0 \\le l[i], w[i] \\le n$（对于所有的 $0 \\le i \\le n - 1$）\n- $w[i] > i$（对于所有的 $0 \\le i \\le n - 1$）\n- $0 \\le x \\le n - 1$\n- $1 \\le z \\le {10}^7$\n\n子任务\t|分值|特殊限制\n:-:|:-:|:-:\n$0$|$0$|样例\n$1$|\t$11$|\t$n \\le 50 \\, 000$，$q \\le 100$，$s[i], p[i] \\le 10 \\, 000$（对于所有的 $0 \\le i \\le n - 1$）\n$2$|\t$26$|\t$s[i] = p[i]$（对于所有的 $0 \\le i \\le n - 1$）\n$3$|\t$13$|\t$n \\le 50 \\, 000$，所有的敌人拥有相同的能力值，即 $s[i] = s[j]$，对于所有的 $0 \\le i, j \\le n - 1$\n$4$|\t$12$|\t$n \\le 50 \\, 000$，所有的 $s[i]$ 至多有 $5$ 种不同的数值\n$5$|\t$27$|\t$n \\le 50 \\, 000$\n$6$|\t$11$|\t没有额外的约束条件", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2021] 地牢游戏", "background": "**滥用本题评测将被封号**\n\n**由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。**\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。", "description": "Robert 正在设计一款新的电脑游戏。游戏中有一位英雄、$n$ 个敌人和 $n + 1$ 个地牢。敌人从 $0$ 到 $n - 1$ 编号，地牢从 $0$ 到 $n$ 编号。敌人 $i$（$0 \\le i \\le n - 1$）处在地牢 $i$，其能力值为 $s[i]$。地牢 $n$ 里没有敌人。\n\n英雄一开始进入地牢 $x$，初始能力值为 $z$。每次英雄进入地牢 $i$（$0 \\le i \\le n - 1$）时，都需要面对敌人 $i$，且会发生以下情况中的一种：\n\n如果英雄的能力值大于等于敌人 $i$ 的能力值 $s[i]$，那么英雄会胜出。这使得英雄的能力值增加 $s[i]$（$s[i] \\ge 1$）。这种情况下，下一步英雄将会进入地牢 $w[i]$（$w[i] > i$）。\n\n否则英雄会战败，这使得英雄的能力值增加 $p[i]$（$p[i] \\ge 1$）。在这种情况下，下一步英雄将会进入地牢 $l[i]$。\n\n注意 $p[i]$ 可能会小于、等于、大于 $s[i]$，$l[i]$ 可能会小于、等于、大于 $i$。无论对战结果如何，敌人 $i$ 始终处在地牢 $i$，且能力值为 $s[i]$。\n\n当英雄进入地牢 $n$ 的时候，游戏结束。可以看出无论英雄的起始地牢和初始能力值如何，游戏一定会在有限次对战之后结束。\n\nRobert 希望你通过 $q$ 次模拟来对游戏进行测试。对于每次模拟，Robert 输入英雄的起始地牢 $x$ 和初始能力值 $z$。你需要做的是对于每次模拟给出游戏结束时英雄的能力值。", "inputFormat": "你要实现以下函数：\n```cpp\nvoid init(int n, int[] s, int[] p, int[] w, int[] l)\n```\n- $n$：敌人的数量。\n$s$、$p$、$w$、$l$：长度为 $n$ 的序列。对于每一个 $i$（$0 \\le i \\le n - 1$）：\n  + $s[i]$ 是敌人 $i$ 的能力值，也是击败敌人 $i$ 后英雄增加的能力值。\n  + $p[i]$ 是英雄被敌人 $i$ 击败后增加的能力值。\n  + $w[i]$ 是英雄击败敌人 $i$ 后进入的下一个地牢的编号。\n  + $l[i]$ 是英雄被敌人 $i$ 击败后进入的下一个地牢的编号。\n- 恰好调用此函数一次，且发生在任何对如下的 simulate 函数的调用之前。\n```cpp\nint64 simulate(int x, int z)\n```\n- $x$：英雄的起始地牢编号。\n- $z$：英雄的初始能力值。\n- 假设英雄的起始地牢编号为 $x$，初始能力值为 $z$，函数的返回值是相应情况下游戏结束时英雄的能力值。\n- 恰好调用此函数 $q$ 次。", "outputFormat": "", "hint": "对于所有数据：\n\n- $1 \\le n \\le 400 \\, 000$\n- $1 \\le q \\le 50 \\, 000$\n- $1 \\le s[i], p[i] \\le {10}^7$（对于所有的 $0 \\le i \\le n - 1$）\n- $0 \\le l[i], w[i] \\le n$（对于所有的 $0 \\le i \\le n - 1$）\n- $w[i] > i$（对于所有的 $0 \\le i \\le n - 1$）\n- $0 \\le x \\le n - 1$\n- $1 \\le z \\le {10}^7$\n\n子任务\t|分值|特殊限制\n:-:|:-:|:-:\n$0$|$0$|样例\n$1$|\t$11$|\t$n \\le 50 \\, 000$，$q \\le 100$，$s[i], p[i] \\le 10 \\, 000$（对于所有的 $0 \\le i \\le n - 1$）\n$2$|\t$26$|\t$s[i] = p[i]$（对于所有的 $0 \\le i \\le n - 1$）\n$3$|\t$13$|\t$n \\le 50 \\, 000$，所有的敌人拥有相同的能力值，即 $s[i] = s[j]$，对于所有的 $0 \\le i, j \\le n - 1$\n$4$|\t$12$|\t$n \\le 50 \\, 000$，所有的 $s[i]$ 至多有 $5$ 种不同的数值\n$5$|\t$27$|\t$n \\le 50 \\, 000$\n$6$|\t$11$|\t没有额外的约束条件", "locale": "zh-CN"}}}
{"pid": "P8523", "type": "P", "difficulty": 7, "samples": [["0 2 1 1000\n0 0\n0 1\n1 0\n1 1\n-1", "move 1 0\nright 1 1 1\nand 0 0 1\n0\n0\n0\n1"], ["1 2 1 1000\n0 0\n0 1\n1 0\n1 1\n-1\n", "move 1 0\nright 1 1 1\nand 2 0 1\nor 3 0 1\nleft 3 3 1\nor 0 2 3\n0 0\n0 1\n0 1\n1 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2021", "IOI", "交互题", "Special Judge"], "title": "[IOI 2021] 位移寄存器", "background": "**滥用本题评测将被封号**\n\n**由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。**\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。\n\n你的代码需要在开头添加以下代码：\n\n```cpp\n#include<vector>\nvoid append_move(int t, int y);\nvoid append_store(int t, std::vector<bool> v);\nvoid append_and(int t, int x, int y);\nvoid append_or(int t, int x, int y);\nvoid append_xor(int t, int x, int y);\nvoid append_not(int t, int x);\nvoid append_left(int t, int x, int p);\nvoid append_right(int t, int x, int p);\nvoid append_add(int t, int x, int y);\nvoid append_print(int t);\n```", "description": "工程师 Christopher 在开发一款新的计算机处理器。\n\n这个处理器可以访问 $m$ 个不同的 $b$ 位存储单元（本题中 $m = 100$ 且 $b = 2000$）。它们被称作寄存器，编号从 $0 $ 到 $m - 1$。我们把这些寄存器记为 $r[0], r[1], \\ldots , r[m - 1]$。每个寄存器都是 $b$ 个比特的数组，这些比特从 $0$（最右的比特）到 $b - 1$（最左的比特）编号。对所有的 $i$（$0 \\le i \\le m - 1$）和 $j$（$0 \\le j \\le b - 1$），我们将寄存器 $i$ 的第 $j$ 个比特记为 $r[i][j]$。\n\n对所有的比特序列 $d_0, d_1, \\ldots , d_{l - 1}$（具有某个长度 $l$），该序列的整数值等于 $2^0 \\cdot d_0 + 2^1 \\cdot d_1 + \\cdots + 2^{l - 1} \\cdot d_{l - 1}$。我们说存储在某个寄存器中的整数值就是寄存器中比特序列的整数值，也就是说，该整数值为 $2^0 \\cdot r[i][0] + 2^1 \\cdot r[i][1] + \\cdots + 2^{b - 1} \\cdot r[i][b - 1]$。\n\n该处理器有 $9$ 种类型的指令，可以用来修改寄存器中的比特。每条指令操作一个或多个寄存器，并将其输出存储到其中的一个寄存器。下面我们用 $x := y$ 表示一个修改 $x$ 的值并将其变成 $y$ 的操作。每种类型的指令所做的操作描述如下：\n\n$\\operatorname{\\mathit{move}}(t, y)$：将寄存器 $y$ 中的比特数组拷贝到寄存器 $t$。对所有的 $j$（$0 \\le j \\le b - 1$），设置 $r[t][j] := r[y][j]$。\n\n$\\operatorname{\\mathit{store}}(t, v)$：设置寄存器 t 等于 $v$，这里 $v$ 是某个 $b$ 个比特的数组。对于所有的 $j$（$0 \\le j \\le b - 1$），设置 $r[t][j] := v[j]$。\n\n$\\operatorname{\\mathit{and}}(t, x, y)$：取寄存器 $x$ 和 $y$ 的按位与，并将结果存到寄存器 $t$ 中。对于所有的 $j$（$0 \\le j \\le b - 1$），如果 $r[x][j]$ 和 $r[y][j]$ 同时为 $1$ 则设置 $r[t][j] := 1$，否则设置 $r[t][j] := 0$。\n\n$\\operatorname{\\mathit{or}}(t, x, y)$：取寄存器 $x$ 和 $y$ 的按位或，并将结果存到寄存器 $t$ 中。对于所有的 $j$（$0 \\le j \\le b - 1$），如果 $r[x][j]$ 和 $r[y][j]$ 至少有一个为 1 则设置 $r[t][j] := 1$，否则设置 $r[t][j] := 0$。\n\n$\\operatorname{\\mathit{xor}}(t, x, y)$：取寄存器 $x$ 和 $y$ 的按位异或，并将结果存到寄存器 $t$ 中。对于所有的 $j$（$0 \\le j \\le b - 1$），如果 $r[x][j]$ 和 $r[y][j]$ 恰好有一个为 1 则设置 $r[t][j] := 1$，否则设置 $r[t][j] := 0$。\n\n$\\operatorname{\\mathit{not}}(t, x)$：取寄存器 $x$ 的按位非，并将结果存到寄存器 $t$ 中。对于所有的 $j$（$0 \\le j \\le b - 1$），设置 $r[t][j] := 1 - r[x][j]$。\n\n$\\operatorname{\\mathit{left}}(t, x, p)$：左移寄存器 $x$ 中的所有比特 $p$ 位，并将结果存到寄存器 $t$ 中。将寄存器 $x$ 中的比特左移 $p$ 位的结果，是一个包含 $b$ 个比特的数组 $v$。对于所有的 $j$（$0 \\le j \\le b - 1$），如果 $j \\ge p$ 则 $v[j] = r[x][j - p]$，否则 $v[j] = 0$。对所有的 $j$（$0 \\le j \\le b - 1$），设置 $r[t][j] := v[j]$。\n\n$\\operatorname{\\mathit{right}}(t, x, p)$：右移寄存器 $x$ 中的所有比特 $p$ 位，并将结果存到寄存器 $t$ 中。将寄存器 $x$ 中的比特右移 $p$ 位的结果，是一个包含 $b$ 个比特的数组 $v$。对于所有的 $j$（$0 \\le j \\le b - 1$），如果 $j \\le b - 1 - p$ 则 $v[j] = r[x][j + p]$，否则 $v[j] = 0$。对所有的 $j$（$0 \\le j \\le b - 1$），设置 $r[t][j] := v[j]$。\n\n$\\operatorname{\\mathit{add}}(t, x, y)$：将寄存器 $x$ 和 $y$ 中的整数值加起来，并将结果存到寄存器 $t$ 中。加法是在模 $2^b$ 下做的。正式一些来说，设 $X$ 是操作前存在寄存器 $x$ 中的整数值，而 $Y$ 是操作前存在寄存器 $y$ 中的整数值。设 $T$ 为操作后存在寄存器 $t$ 中的整数值。如果 $X + Y < 2^b$，设置 $t$ 中的比特使得 $T = X + Y$。否则，设置 $t$ 中的比特使得 $T = X + Y - 2^b$。\n\nChristopher 希望你用这个新处理器解决两种任务。任务的类型用整数 $s$ 来表示。对所有类型的任务，你需要创建一个程序，其为上文所定义的指令构成的序列。\n\n程序的输入包括 $n$ 个整数 $a[0], a[1], \\ldots , a[n - 1]$，而每个整数都有 $k$ 个比特，也就是说，$a[i] < 2^k$（$0 \\le i \\le n - 1$）。在程序执行前，输入的所有的数都依次存储在寄存器 $0$ 中，使得对所有的 $i$（$0 \\le i \\le n - 1$），$k$ 比特序列 $r[0][i \\cdot k], r[0][i \\cdot k + 1], \\ldots , r[0][(i + 1) \\cdot k - 1]$ 的整数值等于 $a[i]$。注意 $n \\cdot k \\le b$。寄存器 $0$ 中所有其他的比特（其下标在 $n \\cdot k$ 和 $b - 1$ 之间，包括 $n \\cdot k$ 和 $b - 1$），以及其他所有寄存器中的所有比特，都初始化为 $0$。\n\n执行某个程序就是按序执行其所包含的指令。在最后一条指令执行完毕后，程序的输出将根据寄存器 $0$ 中比特最终的值计算出来。具体来说，输出是 $n$ 个整数 $c[0], c[1], \\ldots , c[n - 1]$ 的序列，这里对所有 $i$（$0 \\le i \\le n - 1$）来说，$c[i]$ 都是寄存器 $0$ 中比特 $i \\cdot k$ 到 $(i + 1) \\cdot k - 1$ 所构成的序列的整数值。注意，在程序运行结束后，寄存器 $0$ 中其余的比特（下标不小于 $n \\cdot k$），以及其他寄存器中的所有比特，可能是任意值。\n\n第一个任务（$s = 0$）是要找出输入整数 $a[0], a[1], \\ldots , a[n - 1]$ 中的最小值。 具体来说，$c[0]$ 必须是 $a[0], a[1], \\ldots , a[n - 1]$ 中的最小值。$c[1], c[2], \\ldots , c[n - 1]$ 的值可以是任意的。\n\n第二个任务（$s = 1$）是要将输入整数 $a[0], a[1], \\ldots , a[n - 1]$ 进行非降序排序。具体来说，对于所有的 $i$（$0 \\le i \\le n - 1$），$c[i]$ 应当等于 $a[0], a[1], \\ldots , a[n - 1]$ 中第 $1 + i$ 小的整数（也就是说，$c[0]$ 是输入整数中的最小整数）。\n\n请帮 Christopher 写一下解决这些任务的程序。每个程序至多只能包含 $q$ 条指令。", "inputFormat": "你要实现如下函数：\n\n```cpp\nvoid construct_instructions(int s, int n, int k, int q)\n ```\n- $s$：任务类型。\n- $n$：输入中的整数的数量。\n- $k$：输入中的每个整数的比特数。\n- $q$：允许的最大的指令数。\n该函数将被恰好调用一次，并应当为所要解决的任务创建一个指令序列。\n\n该函数应当调用以下函数中的一或多个，以创建指令序列：\n\n```cpp\nvoid append_move(int t, int y)\nvoid append_store(int t, std::vector<bool> v)\nvoid append_and(int t, int x, int y)\nvoid append_or(int t, int x, int y)\nvoid append_xor(int t, int x, int y)\nvoid append_not(int t, int x)\nvoid append_left(int t, int x, int p)\nvoid append_right(int t, int x, int p)\nvoid append_add(int t, int x, int y)\n```\n- 每个函数分别往程序追加一条 $\\operatorname{\\mathit{move}}(t, y)$、$\\operatorname{\\mathit{store}}(t, v)$、$\\operatorname{\\mathit{and}}(t, x, y)$、$\\operatorname{\\mathit{or}}(t, x, y)$、$\\operatorname{\\mathit{xor}}(t, x, y)$、$\\operatorname{\\mathit{not}}(t, x)$、$\\operatorname{\\mathit{left}}(t, x, p)$、$\\operatorname{\\mathit{right}}(t, x, p)$ 或 $\\operatorname{\\mathit{add}}(t, x, y)$ 指令。\n- 对于所有相关的指令，$t$、$x$、$y$ 必须至少为 $0$ 且至多为 $m - 1$。\n- 对于所有相关的指令，$t$、$x$、$y$ 不必是两两之间不同的。\n- 对于指令 `left` 和 `right`，$p$ 必须至少为 $0$ 且至多为 b。\n- 对于指令 `store`，$v$ 的长度必须为 $b$。\n\n你还可以调用以下函数，以帮助测试你的答案：\n\n```cpp\nvoid append_print(int t)\n```\n- 在评测你的答案时，对该函数的所有调用都将被忽略。\n- 在评测程序示例中，该函数将往程序追加一个 $\\operatorname{\\mathit{print}}(t)$ 操作。\n- 当评测程序示例在执行某个程序过程中遇到一个 $\\operatorname{\\mathit{print}}(t)$ 操作时，它会打印出由寄存器 $t$ 中前 $n \\cdot k$ 比特构成的 $n$ 个 $k$-比特整数。\n- $t$ 必须满足 $0 \\le t \\le m - 1$。\n- 对该函数的任何调用，都不会算到你所创建的指令的数量里面。\n\n在追加最后一条指令之后，`construct_instructions` 应当返回。随后你创建的程序将在一定数量的测试用例上评测，其中每个测试用例给出的输入数据为 $n$ 个 $k$-比特整数 $a[0], a[1], \\ldots , a[n - 1]$。如果程序对给定输入数据的输出结果 $c[0], c[1], \\ldots , c[n - 1]$ 满足如下条件，你的答案就将被视为通过了对应的样例：\n\n- 如果 $s = 0$，$c[0]$ 应当为 $a[0], a[1], \\ldots , a[n - 1]$ 中的最小值。\n- 如果 $s = 1$，对所有 $i$（$0 \\le i \\le n - 1$）来说，$c[i]$ 应当是 $a[0], a[1], \\ldots , a[n - 1]$ 中第 $1 + i$ 小的整数。\n\n在评测你的答案时，可能会给出下面的错误信息之一：\n\n- `Invalid index`：在调用某些函数时的参数 $t$、$x$ 或 $y$ 所给出的寄存器下标是不正确的（可能是负数）。\n- `Value to store is not b bits long`：提供给 `append_store` 的 $v$ 的长度不等于 $b$。\n- `Invalid shift value`：提供给 `append_left` 或 `append_right` 的 $p$ 的值不在 $0$ 和 $b$ 之间（包括 $0$ 和 $b$）。\n- `Too many instructions`：你的函数试图追加超过 $q$ 条指令。", "outputFormat": "", "hint": "对于所有数据：\n\n- $m = 100$\n- $b = 2000$\n- $0 \\le s \\le 1$\n- $2 \\le n \\le 100$\n- $1 \\le k \\le 10$\n- $q \\le 4000$\n- $0 \\le a[i] \\le 2^k - 1$（对于所有 $0 \\le i \\le n - 1$）\n\n子任务|\t分值|\t特殊限制\n:-:|:-:|:-:\n$1$\t|$10$|\t$s = 0$，$n = 2$，$k \\le 2$，$q = 1000$\n$2$|\t$11$|\t$s = 0$，$n = 2$，$k \\le 2$，$q = 20$\n$3$\t|$12$\t|$s = 0$，$q = 4000$\n$4$\t|$25$|\t$s = 0$，$q = 150$\n$5$\t|$13$\t|$s = 1$，$n \\le 10$，$q = 4000$\n$6$\t|$29$|\t$s = 1$，$q=4000$\n\n感谢 @[Bingxiu](https://www.luogu.com.cn/user/676498) 提供交互库。附件中的交互库可用于本地测试，与实际评测用的交互库有所不同。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2021] 位移寄存器", "background": "**滥用本题评测将被封号**\n\n**由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。**\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。\n\n你的代码需要在开头添加以下代码：\n\n```cpp\n#include<vector>\nvoid append_move(int t, int y);\nvoid append_store(int t, std::vector<bool> v);\nvoid append_and(int t, int x, int y);\nvoid append_or(int t, int x, int y);\nvoid append_xor(int t, int x, int y);\nvoid append_not(int t, int x);\nvoid append_left(int t, int x, int p);\nvoid append_right(int t, int x, int p);\nvoid append_add(int t, int x, int y);\nvoid append_print(int t);\n```", "description": "工程师 Christopher 在开发一款新的计算机处理器。\n\n这个处理器可以访问 $m$ 个不同的 $b$ 位存储单元（本题中 $m = 100$ 且 $b = 2000$）。它们被称作寄存器，编号从 $0 $ 到 $m - 1$。我们把这些寄存器记为 $r[0], r[1], \\ldots , r[m - 1]$。每个寄存器都是 $b$ 个比特的数组，这些比特从 $0$（最右的比特）到 $b - 1$（最左的比特）编号。对所有的 $i$（$0 \\le i \\le m - 1$）和 $j$（$0 \\le j \\le b - 1$），我们将寄存器 $i$ 的第 $j$ 个比特记为 $r[i][j]$。\n\n对所有的比特序列 $d_0, d_1, \\ldots , d_{l - 1}$（具有某个长度 $l$），该序列的整数值等于 $2^0 \\cdot d_0 + 2^1 \\cdot d_1 + \\cdots + 2^{l - 1} \\cdot d_{l - 1}$。我们说存储在某个寄存器中的整数值就是寄存器中比特序列的整数值，也就是说，该整数值为 $2^0 \\cdot r[i][0] + 2^1 \\cdot r[i][1] + \\cdots + 2^{b - 1} \\cdot r[i][b - 1]$。\n\n该处理器有 $9$ 种类型的指令，可以用来修改寄存器中的比特。每条指令操作一个或多个寄存器，并将其输出存储到其中的一个寄存器。下面我们用 $x := y$ 表示一个修改 $x$ 的值并将其变成 $y$ 的操作。每种类型的指令所做的操作描述如下：\n\n$\\operatorname{\\mathit{move}}(t, y)$：将寄存器 $y$ 中的比特数组拷贝到寄存器 $t$。对所有的 $j$（$0 \\le j \\le b - 1$），设置 $r[t][j] := r[y][j]$。\n\n$\\operatorname{\\mathit{store}}(t, v)$：设置寄存器 t 等于 $v$，这里 $v$ 是某个 $b$ 个比特的数组。对于所有的 $j$（$0 \\le j \\le b - 1$），设置 $r[t][j] := v[j]$。\n\n$\\operatorname{\\mathit{and}}(t, x, y)$：取寄存器 $x$ 和 $y$ 的按位与，并将结果存到寄存器 $t$ 中。对于所有的 $j$（$0 \\le j \\le b - 1$），如果 $r[x][j]$ 和 $r[y][j]$ 同时为 $1$ 则设置 $r[t][j] := 1$，否则设置 $r[t][j] := 0$。\n\n$\\operatorname{\\mathit{or}}(t, x, y)$：取寄存器 $x$ 和 $y$ 的按位或，并将结果存到寄存器 $t$ 中。对于所有的 $j$（$0 \\le j \\le b - 1$），如果 $r[x][j]$ 和 $r[y][j]$ 至少有一个为 1 则设置 $r[t][j] := 1$，否则设置 $r[t][j] := 0$。\n\n$\\operatorname{\\mathit{xor}}(t, x, y)$：取寄存器 $x$ 和 $y$ 的按位异或，并将结果存到寄存器 $t$ 中。对于所有的 $j$（$0 \\le j \\le b - 1$），如果 $r[x][j]$ 和 $r[y][j]$ 恰好有一个为 1 则设置 $r[t][j] := 1$，否则设置 $r[t][j] := 0$。\n\n$\\operatorname{\\mathit{not}}(t, x)$：取寄存器 $x$ 的按位非，并将结果存到寄存器 $t$ 中。对于所有的 $j$（$0 \\le j \\le b - 1$），设置 $r[t][j] := 1 - r[x][j]$。\n\n$\\operatorname{\\mathit{left}}(t, x, p)$：左移寄存器 $x$ 中的所有比特 $p$ 位，并将结果存到寄存器 $t$ 中。将寄存器 $x$ 中的比特左移 $p$ 位的结果，是一个包含 $b$ 个比特的数组 $v$。对于所有的 $j$（$0 \\le j \\le b - 1$），如果 $j \\ge p$ 则 $v[j] = r[x][j - p]$，否则 $v[j] = 0$。对所有的 $j$（$0 \\le j \\le b - 1$），设置 $r[t][j] := v[j]$。\n\n$\\operatorname{\\mathit{right}}(t, x, p)$：右移寄存器 $x$ 中的所有比特 $p$ 位，并将结果存到寄存器 $t$ 中。将寄存器 $x$ 中的比特右移 $p$ 位的结果，是一个包含 $b$ 个比特的数组 $v$。对于所有的 $j$（$0 \\le j \\le b - 1$），如果 $j \\le b - 1 - p$ 则 $v[j] = r[x][j + p]$，否则 $v[j] = 0$。对所有的 $j$（$0 \\le j \\le b - 1$），设置 $r[t][j] := v[j]$。\n\n$\\operatorname{\\mathit{add}}(t, x, y)$：将寄存器 $x$ 和 $y$ 中的整数值加起来，并将结果存到寄存器 $t$ 中。加法是在模 $2^b$ 下做的。正式一些来说，设 $X$ 是操作前存在寄存器 $x$ 中的整数值，而 $Y$ 是操作前存在寄存器 $y$ 中的整数值。设 $T$ 为操作后存在寄存器 $t$ 中的整数值。如果 $X + Y < 2^b$，设置 $t$ 中的比特使得 $T = X + Y$。否则，设置 $t$ 中的比特使得 $T = X + Y - 2^b$。\n\nChristopher 希望你用这个新处理器解决两种任务。任务的类型用整数 $s$ 来表示。对所有类型的任务，你需要创建一个程序，其为上文所定义的指令构成的序列。\n\n程序的输入包括 $n$ 个整数 $a[0], a[1], \\ldots , a[n - 1]$，而每个整数都有 $k$ 个比特，也就是说，$a[i] < 2^k$（$0 \\le i \\le n - 1$）。在程序执行前，输入的所有的数都依次存储在寄存器 $0$ 中，使得对所有的 $i$（$0 \\le i \\le n - 1$），$k$ 比特序列 $r[0][i \\cdot k], r[0][i \\cdot k + 1], \\ldots , r[0][(i + 1) \\cdot k - 1]$ 的整数值等于 $a[i]$。注意 $n \\cdot k \\le b$。寄存器 $0$ 中所有其他的比特（其下标在 $n \\cdot k$ 和 $b - 1$ 之间，包括 $n \\cdot k$ 和 $b - 1$），以及其他所有寄存器中的所有比特，都初始化为 $0$。\n\n执行某个程序就是按序执行其所包含的指令。在最后一条指令执行完毕后，程序的输出将根据寄存器 $0$ 中比特最终的值计算出来。具体来说，输出是 $n$ 个整数 $c[0], c[1], \\ldots , c[n - 1]$ 的序列，这里对所有 $i$（$0 \\le i \\le n - 1$）来说，$c[i]$ 都是寄存器 $0$ 中比特 $i \\cdot k$ 到 $(i + 1) \\cdot k - 1$ 所构成的序列的整数值。注意，在程序运行结束后，寄存器 $0$ 中其余的比特（下标不小于 $n \\cdot k$），以及其他寄存器中的所有比特，可能是任意值。\n\n第一个任务（$s = 0$）是要找出输入整数 $a[0], a[1], \\ldots , a[n - 1]$ 中的最小值。 具体来说，$c[0]$ 必须是 $a[0], a[1], \\ldots , a[n - 1]$ 中的最小值。$c[1], c[2], \\ldots , c[n - 1]$ 的值可以是任意的。\n\n第二个任务（$s = 1$）是要将输入整数 $a[0], a[1], \\ldots , a[n - 1]$ 进行非降序排序。具体来说，对于所有的 $i$（$0 \\le i \\le n - 1$），$c[i]$ 应当等于 $a[0], a[1], \\ldots , a[n - 1]$ 中第 $1 + i$ 小的整数（也就是说，$c[0]$ 是输入整数中的最小整数）。\n\n请帮 Christopher 写一下解决这些任务的程序。每个程序至多只能包含 $q$ 条指令。", "inputFormat": "你要实现如下函数：\n\n```cpp\nvoid construct_instructions(int s, int n, int k, int q)\n ```\n- $s$：任务类型。\n- $n$：输入中的整数的数量。\n- $k$：输入中的每个整数的比特数。\n- $q$：允许的最大的指令数。\n该函数将被恰好调用一次，并应当为所要解决的任务创建一个指令序列。\n\n该函数应当调用以下函数中的一或多个，以创建指令序列：\n\n```cpp\nvoid append_move(int t, int y)\nvoid append_store(int t, std::vector<bool> v)\nvoid append_and(int t, int x, int y)\nvoid append_or(int t, int x, int y)\nvoid append_xor(int t, int x, int y)\nvoid append_not(int t, int x)\nvoid append_left(int t, int x, int p)\nvoid append_right(int t, int x, int p)\nvoid append_add(int t, int x, int y)\n```\n- 每个函数分别往程序追加一条 $\\operatorname{\\mathit{move}}(t, y)$、$\\operatorname{\\mathit{store}}(t, v)$、$\\operatorname{\\mathit{and}}(t, x, y)$、$\\operatorname{\\mathit{or}}(t, x, y)$、$\\operatorname{\\mathit{xor}}(t, x, y)$、$\\operatorname{\\mathit{not}}(t, x)$、$\\operatorname{\\mathit{left}}(t, x, p)$、$\\operatorname{\\mathit{right}}(t, x, p)$ 或 $\\operatorname{\\mathit{add}}(t, x, y)$ 指令。\n- 对于所有相关的指令，$t$、$x$、$y$ 必须至少为 $0$ 且至多为 $m - 1$。\n- 对于所有相关的指令，$t$、$x$、$y$ 不必是两两之间不同的。\n- 对于指令 `left` 和 `right`，$p$ 必须至少为 $0$ 且至多为 b。\n- 对于指令 `store`，$v$ 的长度必须为 $b$。\n\n你还可以调用以下函数，以帮助测试你的答案：\n\n```cpp\nvoid append_print(int t)\n```\n- 在评测你的答案时，对该函数的所有调用都将被忽略。\n- 在评测程序示例中，该函数将往程序追加一个 $\\operatorname{\\mathit{print}}(t)$ 操作。\n- 当评测程序示例在执行某个程序过程中遇到一个 $\\operatorname{\\mathit{print}}(t)$ 操作时，它会打印出由寄存器 $t$ 中前 $n \\cdot k$ 比特构成的 $n$ 个 $k$-比特整数。\n- $t$ 必须满足 $0 \\le t \\le m - 1$。\n- 对该函数的任何调用，都不会算到你所创建的指令的数量里面。\n\n在追加最后一条指令之后，`construct_instructions` 应当返回。随后你创建的程序将在一定数量的测试用例上评测，其中每个测试用例给出的输入数据为 $n$ 个 $k$-比特整数 $a[0], a[1], \\ldots , a[n - 1]$。如果程序对给定输入数据的输出结果 $c[0], c[1], \\ldots , c[n - 1]$ 满足如下条件，你的答案就将被视为通过了对应的样例：\n\n- 如果 $s = 0$，$c[0]$ 应当为 $a[0], a[1], \\ldots , a[n - 1]$ 中的最小值。\n- 如果 $s = 1$，对所有 $i$（$0 \\le i \\le n - 1$）来说，$c[i]$ 应当是 $a[0], a[1], \\ldots , a[n - 1]$ 中第 $1 + i$ 小的整数。\n\n在评测你的答案时，可能会给出下面的错误信息之一：\n\n- `Invalid index`：在调用某些函数时的参数 $t$、$x$ 或 $y$ 所给出的寄存器下标是不正确的（可能是负数）。\n- `Value to store is not b bits long`：提供给 `append_store` 的 $v$ 的长度不等于 $b$。\n- `Invalid shift value`：提供给 `append_left` 或 `append_right` 的 $p$ 的值不在 $0$ 和 $b$ 之间（包括 $0$ 和 $b$）。\n- `Too many instructions`：你的函数试图追加超过 $q$ 条指令。", "outputFormat": "", "hint": "对于所有数据：\n\n- $m = 100$\n- $b = 2000$\n- $0 \\le s \\le 1$\n- $2 \\le n \\le 100$\n- $1 \\le k \\le 10$\n- $q \\le 4000$\n- $0 \\le a[i] \\le 2^k - 1$（对于所有 $0 \\le i \\le n - 1$）\n\n子任务|\t分值|\t特殊限制\n:-:|:-:|:-:\n$1$\t|$10$|\t$s = 0$，$n = 2$，$k \\le 2$，$q = 1000$\n$2$|\t$11$|\t$s = 0$，$n = 2$，$k \\le 2$，$q = 20$\n$3$\t|$12$\t|$s = 0$，$q = 4000$\n$4$\t|$25$|\t$s = 0$，$q = 150$\n$5$\t|$13$\t|$s = 1$，$n \\le 10$，$q = 4000$\n$6$\t|$29$|\t$s = 1$，$q=4000$\n\n感谢 @[Bingxiu](https://www.luogu.com.cn/user/676498) 提供交互库。附件中的交互库可用于本地测试，与实际评测用的交互库有所不同。", "locale": "zh-CN"}}}
