{"pid": "P13515", "type": "P", "difficulty": 5, "samples": [["4 4\n1 2 3\n1 3 4\n2 4 3\n3 4 1\n0 0 0 0\n3 8", "14"], ["4 4\n1 2 3\n1 3 4\n2 4 3\n3 4 1\n0 1 1 0\n3 8", "-1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "最短路", "KOI（韩国）"], "title": "[KOI 2025 #1] 木槿花开了", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "KOI 村庄由 $N$ 个建筑和 $M$ 条道路组成。\n\n建筑从 1 到 $N$ 编号，每个建筑可能有也可能没有窗户。对于 $1 \\le i \\le N$ 的每个 $i$，如果第 $i$ 个建筑有窗户，则 $c_i=1$，如果没有窗户，则 $c_i=0$。规定第 1 个建筑和第 $N$ 个建筑没有窗户，即 $c_1 = c_N = 0$。\n\n道路从 1 到 $M$ 编号，每条道路都是连接一个起始建筑和一个到达建筑的单向通道。对于 $1 \\le j \\le M$ 的每个 $j$，第 $j$ 条道路从建筑 $x_j$ 开始，到建筑 $y_j$ 结束，通过这条道路需要花费恰好 $t_j$ 秒。因为是单向道路，所以不能逆向行驶（即，从建筑 $y_j$ 移动到建筑 $x_j$）。\n\n在 KOI 村庄，Hankook 和 Jeong-ul 打算玩一个基于“木槿花开了”游戏改编的以下游戏。\n\n游戏开始时，Jeong-ul 在 1 号建筑。Jeong-ul 的目标是在不被 Hankook 的视线发现一次的情况下，尽可能快地到达 $N$ 号建筑。相反，Hankook 的目标是在 Jeong-ul 到达 $N$ 号建筑之前找到他。\n\nHankook 睁着眼时可以看到整个 KOI 村庄，但无法看到没有窗户的建筑内部。也就是说，Hankook 只能看到有窗户的建筑内部和所有道路。\n\nHankook 从游戏开始（0 秒）时起，周期性地重复以下动作：\n*   首先，闭上眼睛恰好 $a$ 秒。\n*   紧接着，睁开眼睛并观察村庄恰好 $b$ 秒。\n*   此过程无限重复。\n\n我们可以将上述过程用数学公式严格地表达如下：\n*   我们定义“从游戏开始时经过的时间”为 $t$（以秒为单位）。\n*   当时间 $t = k(a+b) + l$ 时（其中 $k$ 为非负整数， $l$ 为满足 $0 \\le l < a+b$ 的实数）：\n    *   如果 $0 \\le l < a$，Hankook 闭着眼睛。\n    *   如果 $a \\le l < a+b$，Hankook 睁着眼睛。\n*   也就是说，对于非负整数 $k$，Hankook 闭眼的时间是闭区间 $[k(a+b), k(a+b)+a]$，睁眼的时间是开区间 $(k(a+b)+a, (k+1)(a+b))$。\n\nJeong-ul 从游戏开始的时刻（0 秒）起，可以随时开始移动，并且在建筑内部（无论是否有窗户）等待和移动都是自由的，不消耗时间。从建筑出来或进入建筑内部也不消耗时间。如果 Jeong-ul 开始沿着某条道路移动，他必须花费该道路所需的确切时间来移动，并且在移动过程中不能在道路上停下或等待。移动结束后，他将到达道路的终点建筑。\n\nJeong-ul 被 Hankook 发现的基准如下：\n*   在 Hankook 睁着眼的时候，如果 Jeong-ul 位于道路上或在有窗户的建筑内部，他会立即被发现，游戏随之结束。因此，在 Hankook 睁着眼的时间段内，Jeong-ul 必须位于没有窗户的建筑内。\n*   在 Hankook 闭着眼的时候，无论 Jeong-ul 在哪里，都绝对不会被发现。\n*   请注意，如果 Jeong-ul 进入没有窗户的建筑的时刻，恰好是 Hankook 开始睁眼的瞬间；或者他进入道路开始移动的时刻，恰好是 Hankook 开始闭眼的瞬间，则不会被发现。\n\n在这些条件下，请编写一个程序，判断 Jeong-ul 是否有可能在不被 Hankook 发现一次的情况下安全到达 $N$ 号建筑，如果可能，计算 Jeong-ul 到达 $N$ 号建筑所需的最短时间（以秒为单位）。", "inputFormat": "第一行给出两个整数 $N$ 和 $M$，以空格分隔。\n\n接下来的 $M$ 行给出道路的信息。其中第 $j$ ($1 \\le j \\le M$) 行包含三个整数 $x_j, y_j, t_j$，以空格分隔。\n\n再下一行给出 $N$ 个整数 $c_1, c_2, \\cdots, c_N$，以空格分隔。\n\n最后一行给出两个整数 $a, b$，以空格分隔。", "outputFormat": "如果无论 Jeong-ul 如何移动都无法到达 $N$ 号建筑，则输出 `-1`。\n\n否则，输出 Jeong-ul 到达 $N$ 号建筑所需的最短时间（以秒为单位）。可以证明，这个值总是一个整数。", "hint": "### 样例 1 解释\n\n随着时间的推移，Jeong-ul 和 Hankook 可以按如下方式行动：\n\n*   0 秒 - 3 秒：Hankook 闭着眼睛。Jeong-ul 在 0 秒时进入 1 号道路（1 号建筑 → 2 号建筑），并于 3 秒时到达 2 号建筑。\n*   3 秒 - 11 秒：Hankook 在 3 秒时睁开眼睛。Jeong-ul 在 2 号建筑一直停留到 11 秒。\n*   11 秒 - 14 秒：Hankook 在 11 秒时闭上眼睛。Jeong-ul 在 11 秒时进入 3 号道路（2 号建筑 → 4 号建筑），并于 14 秒时到达 4 号建筑。\n\n由于 Jeong-ul 没有比 14 秒更快到达 4 号建筑的方法，因此应当输出 14。\n\n### 样例 2 解释\n\n由于除 1 号和 4 号建筑外的所有建筑都有窗户，Jeong-ul 必须在 Hankook 睁开眼睛之前（即，在 $a=3$ 秒内）到达 4 号建筑。但是，Jeong-ul 不可能在 3 秒内到达 4 号建筑。因此，应当输出 `-1`。\n\n### 限制条件\n\n*   给定的所有数都是整数。\n*   $3 \\le N \\le 2000$\n*   $3 \\le M \\le 4000$\n*   对于每个 $1 \\le j \\le M$ 的 $j$，有 $1 \\le x_j, y_j \\le N, x_j \\ne y_j, 1 \\le t_j \\le 100,000$。\n*   对于 $1 \\le j < k \\le M$ 的任意 $j, k$，有 $(x_j, y_j) \\ne (x_k, y_k)$。也就是说，所有道路的起点和终点对都是唯一的。\n*   对于 $2 \\le i \\le N-1$ 的每个 $i$，$c_i \\in \\{0, 1\\}$。\n*   $c_1 = c_N = 0$。即，1 号建筑和 $N$ 号建筑没有窗户。\n*   $1 \\le a, b \\le 10^9$。\n\n### 子任务\n\n1.  (12 分) $N \\le 5, M \\le 10$。\n2.  (19 分) 对于 $2 \\le i \\le N-1$ 的每个 $i$，$c_i=1$。\n3.  (31 分) 对于 $1 \\le j \\le M$ 的每个 $j$，$t_j=1$。\n4.  (27 分) $M=N-1$。并且，对于 $1 \\le j \\le N-1$ 的每个 $j$，$x_j = j, y_j = j+1$。\n5.  (61 分) 无附加限制条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2025 #1] 木槿花开了", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "KOI 村庄由 $N$ 个建筑和 $M$ 条道路组成。\n\n建筑从 1 到 $N$ 编号，每个建筑可能有也可能没有窗户。对于 $1 \\le i \\le N$ 的每个 $i$，如果第 $i$ 个建筑有窗户，则 $c_i=1$，如果没有窗户，则 $c_i=0$。规定第 1 个建筑和第 $N$ 个建筑没有窗户，即 $c_1 = c_N = 0$。\n\n道路从 1 到 $M$ 编号，每条道路都是连接一个起始建筑和一个到达建筑的单向通道。对于 $1 \\le j \\le M$ 的每个 $j$，第 $j$ 条道路从建筑 $x_j$ 开始，到建筑 $y_j$ 结束，通过这条道路需要花费恰好 $t_j$ 秒。因为是单向道路，所以不能逆向行驶（即，从建筑 $y_j$ 移动到建筑 $x_j$）。\n\n在 KOI 村庄，Hankook 和 Jeong-ul 打算玩一个基于“木槿花开了”游戏改编的以下游戏。\n\n游戏开始时，Jeong-ul 在 1 号建筑。Jeong-ul 的目标是在不被 Hankook 的视线发现一次的情况下，尽可能快地到达 $N$ 号建筑。相反，Hankook 的目标是在 Jeong-ul 到达 $N$ 号建筑之前找到他。\n\nHankook 睁着眼时可以看到整个 KOI 村庄，但无法看到没有窗户的建筑内部。也就是说，Hankook 只能看到有窗户的建筑内部和所有道路。\n\nHankook 从游戏开始（0 秒）时起，周期性地重复以下动作：\n*   首先，闭上眼睛恰好 $a$ 秒。\n*   紧接着，睁开眼睛并观察村庄恰好 $b$ 秒。\n*   此过程无限重复。\n\n我们可以将上述过程用数学公式严格地表达如下：\n*   我们定义“从游戏开始时经过的时间”为 $t$（以秒为单位）。\n*   当时间 $t = k(a+b) + l$ 时（其中 $k$ 为非负整数， $l$ 为满足 $0 \\le l < a+b$ 的实数）：\n    *   如果 $0 \\le l < a$，Hankook 闭着眼睛。\n    *   如果 $a \\le l < a+b$，Hankook 睁着眼睛。\n*   也就是说，对于非负整数 $k$，Hankook 闭眼的时间是闭区间 $[k(a+b), k(a+b)+a]$，睁眼的时间是开区间 $(k(a+b)+a, (k+1)(a+b))$。\n\nJeong-ul 从游戏开始的时刻（0 秒）起，可以随时开始移动，并且在建筑内部（无论是否有窗户）等待和移动都是自由的，不消耗时间。从建筑出来或进入建筑内部也不消耗时间。如果 Jeong-ul 开始沿着某条道路移动，他必须花费该道路所需的确切时间来移动，并且在移动过程中不能在道路上停下或等待。移动结束后，他将到达道路的终点建筑。\n\nJeong-ul 被 Hankook 发现的基准如下：\n*   在 Hankook 睁着眼的时候，如果 Jeong-ul 位于道路上或在有窗户的建筑内部，他会立即被发现，游戏随之结束。因此，在 Hankook 睁着眼的时间段内，Jeong-ul 必须位于没有窗户的建筑内。\n*   在 Hankook 闭着眼的时候，无论 Jeong-ul 在哪里，都绝对不会被发现。\n*   请注意，如果 Jeong-ul 进入没有窗户的建筑的时刻，恰好是 Hankook 开始睁眼的瞬间；或者他进入道路开始移动的时刻，恰好是 Hankook 开始闭眼的瞬间，则不会被发现。\n\n在这些条件下，请编写一个程序，判断 Jeong-ul 是否有可能在不被 Hankook 发现一次的情况下安全到达 $N$ 号建筑，如果可能，计算 Jeong-ul 到达 $N$ 号建筑所需的最短时间（以秒为单位）。", "inputFormat": "第一行给出两个整数 $N$ 和 $M$，以空格分隔。\n\n接下来的 $M$ 行给出道路的信息。其中第 $j$ ($1 \\le j \\le M$) 行包含三个整数 $x_j, y_j, t_j$，以空格分隔。\n\n再下一行给出 $N$ 个整数 $c_1, c_2, \\cdots, c_N$，以空格分隔。\n\n最后一行给出两个整数 $a, b$，以空格分隔。", "outputFormat": "如果无论 Jeong-ul 如何移动都无法到达 $N$ 号建筑，则输出 `-1`。\n\n否则，输出 Jeong-ul 到达 $N$ 号建筑所需的最短时间（以秒为单位）。可以证明，这个值总是一个整数。", "hint": "### 样例 1 解释\n\n随着时间的推移，Jeong-ul 和 Hankook 可以按如下方式行动：\n\n*   0 秒 - 3 秒：Hankook 闭着眼睛。Jeong-ul 在 0 秒时进入 1 号道路（1 号建筑 → 2 号建筑），并于 3 秒时到达 2 号建筑。\n*   3 秒 - 11 秒：Hankook 在 3 秒时睁开眼睛。Jeong-ul 在 2 号建筑一直停留到 11 秒。\n*   11 秒 - 14 秒：Hankook 在 11 秒时闭上眼睛。Jeong-ul 在 11 秒时进入 3 号道路（2 号建筑 → 4 号建筑），并于 14 秒时到达 4 号建筑。\n\n由于 Jeong-ul 没有比 14 秒更快到达 4 号建筑的方法，因此应当输出 14。\n\n### 样例 2 解释\n\n由于除 1 号和 4 号建筑外的所有建筑都有窗户，Jeong-ul 必须在 Hankook 睁开眼睛之前（即，在 $a=3$ 秒内）到达 4 号建筑。但是，Jeong-ul 不可能在 3 秒内到达 4 号建筑。因此，应当输出 `-1`。\n\n### 限制条件\n\n*   给定的所有数都是整数。\n*   $3 \\le N \\le 2000$\n*   $3 \\le M \\le 4000$\n*   对于每个 $1 \\le j \\le M$ 的 $j$，有 $1 \\le x_j, y_j \\le N, x_j \\ne y_j, 1 \\le t_j \\le 100,000$。\n*   对于 $1 \\le j < k \\le M$ 的任意 $j, k$，有 $(x_j, y_j) \\ne (x_k, y_k)$。也就是说，所有道路的起点和终点对都是唯一的。\n*   对于 $2 \\le i \\le N-1$ 的每个 $i$，$c_i \\in \\{0, 1\\}$。\n*   $c_1 = c_N = 0$。即，1 号建筑和 $N$ 号建筑没有窗户。\n*   $1 \\le a, b \\le 10^9$。\n\n### 子任务\n\n1.  (12 分) $N \\le 5, M \\le 10$。\n2.  (19 分) 对于 $2 \\le i \\le N-1$ 的每个 $i$，$c_i=1$。\n3.  (31 分) 对于 $1 \\le j \\le M$ 的每个 $j$，$t_j=1$。\n4.  (27 分) $M=N-1$。并且，对于 $1 \\le j \\le N-1$ 的每个 $j$，$x_j = j, y_j = j+1$。\n5.  (61 分) 无附加限制条件。", "locale": "zh-CN"}}}
{"pid": "P13516", "type": "P", "difficulty": 5, "samples": [["11 10\n1 3 3\n2 3 10\n3 4 5\n4 5 8\n9 6 4\n4 7 2\n7 8 2\n5 9 1\n9 10 2\n5 11 3\n1 1 4\n1 2 12\n1 6 6\n1 7 1\n1 8 8\n1 9 6\n1 10 9\n1 11 2\n2 7\n2 1", "NO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\nYES\nNO"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "线段树", "2025", "KOI（韩国）"], "title": "[KOI 2025 #1] 快递运输", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "2050 年，快递最优化研究所 (KOI, Kurier Optimization Institute) 建立了一个全国范围的基于机器人的快递运输网络。\n\n该网络由 $N$ 个物流中心和连接它们的 $N-1$ 条道路组成，物流中心的编号从 1 到 $N$。每条道路的编号从 1 到 $N-1$，其中第 $i$ 条 ($1 \\le i \\le N-1$) 道路连接着 $U_i$ 和 $V_i$ 两个物流中心，道路的长度为 $W_i$。任何一个物流中心都可以通过一条或多条道路到达其他任何一个物流中心。也就是说，快递运输网络是一个由道路连接而成的连通结构。此外，任意两条不同的道路除了在它们的端点（即物流中心）外，不会在任何其他点相交。\n\n我们将所有物流中心和所有道路上的任意点统称为一个**地点**。两个地点 $x, y$ 之间的距离 $d(x, y)$ 定义为从地点 $x$ 到达地点 $y$ 必须经过的最短路径长度。当然，若 $x=y$，则 $d(x, y) = 0$。\n\n一些机器人被放置在特定的物流中心。每个机器人都带有一个给定的**通信范围**。一个通信范围为 $X$、初始位于地点 $p$ 的机器人，可以在满足 $d(p, z) \\le X$ 的所有地点 $z$ 之间自由地、往复地移动，并可以在自己可移动范围内的任意地点取件或放件。\n\n您作为研究所的研究员，需要判断是否可以利用协作的机器人，将快递从 1 号物流中心运输到 $N$ 号物流中心。也就是说，一个机器人可以将快递放在某个地点，然后另一个机器人可以从同一地点取走快递并继续运输。\n\n您需要对总共 $Q$ 个场景进行分析，这些场景是相互关联的。第 $j$ ($1 \\le j \\le Q$) 个场景的形态如下：\n\n*   1 $A_j$ $B_j$：在第 $j-1$ 个场景的基础上，增加一个新机器人。该机器人的初始位置为 $A_j$ 号物流中心，通信范围为 $B_j$。\n*   2 $C_j$：在第 $j-1$ 个场景的基础上，移除在第 $C_j$ 个场景中添加的机器人。保证在第 $C_j$ 个场景中确实添加了一个新的机器人，且同一个机器人不会被移除两次以上。\n\n规定，第 0 个场景为初始状态，即没有任何机器人被放置。\n\n对于每个场景，请编写一个程序来判断，机器人是否能够协作将快递从 1 号物流中心运输到 $N$ 号物流中心。", "inputFormat": "第一行给出两个整数 $N, Q$，以空格分隔。\n\n接下来的 $N-1$ 行给出道路的信息。其中第 $i$ ($1 \\le i \\le N-1$) 行包含三个整数 $U_i, V_i, W_i$，以空格分隔。\n\n接下来的 $Q$ 行给出场景的信息。其中第 $j$ ($1 \\le j \\le Q$) 行是关于第 $j$ 个场景的信息，格式如题面所述。", "outputFormat": "输出 $Q$ 行。第 $j$ ($1 \\le j \\le Q$) 行输出在第 $j$ 个场景下，如果快递能够被运输，则输出 **YES**，否则输出 **NO**。\n", "hint": "### 样例 1 说明\n\n假设我们考虑第八个场景。此时总共放置了六个机器人。其中一种可能的运输方式如下：\n1.  位于 1 号物流中心的唯一一个机器人通信范围为 4。该机器人从 1 号物流中心拿起快递，并将其放在 3 号物流中心。\n2.  位于 2 号物流中心的唯一一个机器人通信范围为 12。该机器人从 3 号物流中心移动并拿起快递，然后将其放在从 3 号物流中心到 4 号物流中心的道路上，距离 3 号物流中心为 1 的位置。\n3.  位于 8 号物流中心的唯一一个机器人通信范围为 8。该机器人从 3 号到 4 号道路上距离 3 号物流中心为 1 的位置移动并拿起快递，然后将其放在从 4 号到 5 号道路上距离 4 号物流中心为 3 的位置。\n4.  位于 10 号物流中心的唯一一个机器人通信范围为 9。该机器人从 4 号到 5 号道路上距离 4 号物流中心为 3 的位置移动并拿起快递，然后将其放在 11 号物流中心。\n\n因为可以运输快递，所以应当输出 **YES**。\n\n假设我们考虑第十个场景。此时总共放置了六个机器人。没有任何机器人能够拿起最初放在 1 号物流中心的快递。因此，无法运输快递。所以应当输出 **NO**。\n\n### 限制条件\n\n*   给定的所有数都是整数。\n*   $2 \\le N \\le 200,000$\n*   $1 \\le Q \\le 200,000$\n*   对于每个 $1 \\le i \\le N-1$ 的 $i$，有 $1 \\le U_i, V_i \\le N$ 且 $1 \\le W_i \\le 10^9$。\n*   运输网络是连通的。\n*   对于每个 $1 \\le j \\le Q$ 的 $j$：\n    *   如果第 $j$ 个场景是增加新机器人，则 $1 \\le A_j \\le N$ 且 $1 \\le B_j \\le 10^{15}$。\n    *   如果第 $j$ 个场景是移除机器人，则 $1 \\le C_j \\le j-1$ 且第 $C_j$ 个场景必须是增加新机器人的场景。同一个机器人不会被移除超过一次。\n\n### 子任务\n\n1.  (8 分) $N \\le 100, Q \\le 6$。对于每个 $1 \\le i \\le N-1$ 的 $i$，$W_i \\le 10$。\n2.  (13 分) 对于每个 $1 \\le i \\le N-1$ 的 $i$，$U_i = i, V_i = i+1$。此外，$N, Q \\le 2500$。\n3.  (25 分) $N, Q \\le 2500$。\n4.  (27 分) 对于每个 $1 \\le i \\le N-1$ 的 $i$，$U_i = i, V_i = i+1$。\n5.  (30 分) 所有的场景都是增加新机器人的场景。\n6.  (26 分) 对于每个 $1 \\le i \\le N-1$ 的 $i$，$W_i = 1$。对于所有 $j$，如果是增加新机器人的场景，$B_j \\le 10$。\n7.  (21 分) 无附加限制条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2025 #1] 快递运输", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "2050 年，快递最优化研究所 (KOI, Kurier Optimization Institute) 建立了一个全国范围的基于机器人的快递运输网络。\n\n该网络由 $N$ 个物流中心和连接它们的 $N-1$ 条道路组成，物流中心的编号从 1 到 $N$。每条道路的编号从 1 到 $N-1$，其中第 $i$ 条 ($1 \\le i \\le N-1$) 道路连接着 $U_i$ 和 $V_i$ 两个物流中心，道路的长度为 $W_i$。任何一个物流中心都可以通过一条或多条道路到达其他任何一个物流中心。也就是说，快递运输网络是一个由道路连接而成的连通结构。此外，任意两条不同的道路除了在它们的端点（即物流中心）外，不会在任何其他点相交。\n\n我们将所有物流中心和所有道路上的任意点统称为一个**地点**。两个地点 $x, y$ 之间的距离 $d(x, y)$ 定义为从地点 $x$ 到达地点 $y$ 必须经过的最短路径长度。当然，若 $x=y$，则 $d(x, y) = 0$。\n\n一些机器人被放置在特定的物流中心。每个机器人都带有一个给定的**通信范围**。一个通信范围为 $X$、初始位于地点 $p$ 的机器人，可以在满足 $d(p, z) \\le X$ 的所有地点 $z$ 之间自由地、往复地移动，并可以在自己可移动范围内的任意地点取件或放件。\n\n您作为研究所的研究员，需要判断是否可以利用协作的机器人，将快递从 1 号物流中心运输到 $N$ 号物流中心。也就是说，一个机器人可以将快递放在某个地点，然后另一个机器人可以从同一地点取走快递并继续运输。\n\n您需要对总共 $Q$ 个场景进行分析，这些场景是相互关联的。第 $j$ ($1 \\le j \\le Q$) 个场景的形态如下：\n\n*   1 $A_j$ $B_j$：在第 $j-1$ 个场景的基础上，增加一个新机器人。该机器人的初始位置为 $A_j$ 号物流中心，通信范围为 $B_j$。\n*   2 $C_j$：在第 $j-1$ 个场景的基础上，移除在第 $C_j$ 个场景中添加的机器人。保证在第 $C_j$ 个场景中确实添加了一个新的机器人，且同一个机器人不会被移除两次以上。\n\n规定，第 0 个场景为初始状态，即没有任何机器人被放置。\n\n对于每个场景，请编写一个程序来判断，机器人是否能够协作将快递从 1 号物流中心运输到 $N$ 号物流中心。", "inputFormat": "第一行给出两个整数 $N, Q$，以空格分隔。\n\n接下来的 $N-1$ 行给出道路的信息。其中第 $i$ ($1 \\le i \\le N-1$) 行包含三个整数 $U_i, V_i, W_i$，以空格分隔。\n\n接下来的 $Q$ 行给出场景的信息。其中第 $j$ ($1 \\le j \\le Q$) 行是关于第 $j$ 个场景的信息，格式如题面所述。", "outputFormat": "输出 $Q$ 行。第 $j$ ($1 \\le j \\le Q$) 行输出在第 $j$ 个场景下，如果快递能够被运输，则输出 **YES**，否则输出 **NO**。\n", "hint": "### 样例 1 说明\n\n假设我们考虑第八个场景。此时总共放置了六个机器人。其中一种可能的运输方式如下：\n1.  位于 1 号物流中心的唯一一个机器人通信范围为 4。该机器人从 1 号物流中心拿起快递，并将其放在 3 号物流中心。\n2.  位于 2 号物流中心的唯一一个机器人通信范围为 12。该机器人从 3 号物流中心移动并拿起快递，然后将其放在从 3 号物流中心到 4 号物流中心的道路上，距离 3 号物流中心为 1 的位置。\n3.  位于 8 号物流中心的唯一一个机器人通信范围为 8。该机器人从 3 号到 4 号道路上距离 3 号物流中心为 1 的位置移动并拿起快递，然后将其放在从 4 号到 5 号道路上距离 4 号物流中心为 3 的位置。\n4.  位于 10 号物流中心的唯一一个机器人通信范围为 9。该机器人从 4 号到 5 号道路上距离 4 号物流中心为 3 的位置移动并拿起快递，然后将其放在 11 号物流中心。\n\n因为可以运输快递，所以应当输出 **YES**。\n\n假设我们考虑第十个场景。此时总共放置了六个机器人。没有任何机器人能够拿起最初放在 1 号物流中心的快递。因此，无法运输快递。所以应当输出 **NO**。\n\n### 限制条件\n\n*   给定的所有数都是整数。\n*   $2 \\le N \\le 200,000$\n*   $1 \\le Q \\le 200,000$\n*   对于每个 $1 \\le i \\le N-1$ 的 $i$，有 $1 \\le U_i, V_i \\le N$ 且 $1 \\le W_i \\le 10^9$。\n*   运输网络是连通的。\n*   对于每个 $1 \\le j \\le Q$ 的 $j$：\n    *   如果第 $j$ 个场景是增加新机器人，则 $1 \\le A_j \\le N$ 且 $1 \\le B_j \\le 10^{15}$。\n    *   如果第 $j$ 个场景是移除机器人，则 $1 \\le C_j \\le j-1$ 且第 $C_j$ 个场景必须是增加新机器人的场景。同一个机器人不会被移除超过一次。\n\n### 子任务\n\n1.  (8 分) $N \\le 100, Q \\le 6$。对于每个 $1 \\le i \\le N-1$ 的 $i$，$W_i \\le 10$。\n2.  (13 分) 对于每个 $1 \\le i \\le N-1$ 的 $i$，$U_i = i, V_i = i+1$。此外，$N, Q \\le 2500$。\n3.  (25 分) $N, Q \\le 2500$。\n4.  (27 分) 对于每个 $1 \\le i \\le N-1$ 的 $i$，$U_i = i, V_i = i+1$。\n5.  (30 分) 所有的场景都是增加新机器人的场景。\n6.  (26 分) 对于每个 $1 \\le i \\le N-1$ 的 $i$，$W_i = 1$。对于所有 $j$，如果是增加新机器人的场景，$B_j \\le 10$。\n7.  (21 分) 无附加限制条件。", "locale": "zh-CN"}}}
{"pid": "P13517", "type": "P", "difficulty": 2, "samples": [["3\n2 5 11", "7"], ["3\n7 20 25", "14"], ["4\n1 4 5 8", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "2025", "KOI（韩国）"], "title": "[KOI 2025 #2] 障碍物", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "你正在和朋友们一起在操场上玩跳跃障碍物的游戏。游戏从数轴上的位置 0 开始，各个障碍物从左到右依次放置在 $X_1 < X_2 < ... < X_N$ 的位置上。其中 $X_1 \\ge 1$。\n\n你的目标是跳过放置在数轴上的所有 $N$ 个障碍物。为了实现这个目标，你可以进行以下两种行动：\n\n*   向右走 1 步。即，如果从位置 $x$ 开始，将会到达位置 $x+1$。\n*   向右跳 2 步。即，如果从位置 $x$ 开始，将会到达位置 $x+2$。\n\n跳过障碍物，意味着必须通过“跳跃”动作越过该障碍物。换句话说，要跳过位于位置 $X_i$ 的障碍物，你必须从位置 $X_i - 1$ 向右跳跃 2 步，从而到达位置 $X_i + 1$。\n\n例如，假设如下图所示，在数轴上的位置 2、5、11 处放置有障碍物。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r6cdstuj.png)\n\n可以通过以下几种方法跳过所有障碍物。下文中，$\\rightarrow$ 表示行走，$\\implies$ 表示跳跃。\n\n*   方法 1: $0 \\rightarrow 1 \\implies 3 \\rightarrow 4 \\implies 6 \\rightarrow 7 \\implies 9 \\rightarrow 10 \\implies 12$ (共移动 8 次，跳过 3 个障碍物)\n![](https://cdn.luogu.com.cn/upload/image_hosting/qhduz50k.png)\n*   方法 2: $0 \\rightarrow 1 \\implies 3 \\rightarrow 4 \\implies 6 \\implies 8 \\implies 10 \\implies 12$ (共移动 7 次，跳过 3 个障碍物)\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ucfl5v1.png)\n但是，使用以下方法则无法跳过所有障碍物。\n\n*   方法 3: $0 \\implies 2 \\implies 4 \\implies 6 \\implies 8 \\implies 10 \\implies 12$ (共移动 6 次，跳过 2 个障碍物)\n![](https://cdn.luogu.com.cn/upload/image_hosting/jyrzfkbk.png)\n\n*   方法 4: $0 \\rightarrow 1 \\implies 3 \\implies 5 \\implies 7 \\implies 9 \\rightarrow 10 \\implies 12$ (共移动 7 次，跳过 2 个障碍物)\n![](https://cdn.luogu.com.cn/upload/image_hosting/fz3udx03.png)\n\n*   方法 5: $0 \\rightarrow 1 \\implies 3 \\rightarrow 4 \\rightarrow 5$ (共移动 5 次，跳过 1 个障碍物)\n![](https://cdn.luogu.com.cn/upload/image_hosting/pbilv3k5.png)\n\n在各个示例中，**移动次数**是行走次数和跳跃次数的总和。在这个示例中，方法 2 是用最少移动次数跳过所有障碍物的最佳方法。\n\n你需要找到一种将**移动次数**最小化、能够跳过所有障碍物的最佳方法。但是，也可能存在仅用给定的两种行动无法跳过所有障碍物的情况。", "inputFormat": "第一行给定 $N$。\n\n第二行依次给定 $N$ 个整数 $X_1, X_2, \\dots, X_N$，由空格分隔。", "outputFormat": "如果无法跳过所有障碍物，则输出 -1。\n\n如果可以跳过所有障碍物，则输出跳过所有障碍物所需的最少移动次数。", "hint": "### 限制条件\n\n*   所有给定的数都是整数。\n*   $1 \\le N \\le 250\\,000$\n*   $1 \\le X_1 < X_2 < ... < X_N \\le 250\\,000$\n\n### 子任务\n\n1.  (7 分) $N = 1, X_1 \\le 5$\n2.  (12 分) $N = 1, X_1 \\le 5\\,000$\n3.  (23 分) 对于所有满足 $1 \\le i \\le N$ 的 $i$，$N \\le 5\\,000$ 且 $X_i \\le 5\\,000$\n4.  (58 分) 无额外限制条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2025 #2] 障碍物", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "你正在和朋友们一起在操场上玩跳跃障碍物的游戏。游戏从数轴上的位置 0 开始，各个障碍物从左到右依次放置在 $X_1 < X_2 < ... < X_N$ 的位置上。其中 $X_1 \\ge 1$。\n\n你的目标是跳过放置在数轴上的所有 $N$ 个障碍物。为了实现这个目标，你可以进行以下两种行动：\n\n*   向右走 1 步。即，如果从位置 $x$ 开始，将会到达位置 $x+1$。\n*   向右跳 2 步。即，如果从位置 $x$ 开始，将会到达位置 $x+2$。\n\n跳过障碍物，意味着必须通过“跳跃”动作越过该障碍物。换句话说，要跳过位于位置 $X_i$ 的障碍物，你必须从位置 $X_i - 1$ 向右跳跃 2 步，从而到达位置 $X_i + 1$。\n\n例如，假设如下图所示，在数轴上的位置 2、5、11 处放置有障碍物。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r6cdstuj.png)\n\n可以通过以下几种方法跳过所有障碍物。下文中，$\\rightarrow$ 表示行走，$\\implies$ 表示跳跃。\n\n*   方法 1: $0 \\rightarrow 1 \\implies 3 \\rightarrow 4 \\implies 6 \\rightarrow 7 \\implies 9 \\rightarrow 10 \\implies 12$ (共移动 8 次，跳过 3 个障碍物)\n![](https://cdn.luogu.com.cn/upload/image_hosting/qhduz50k.png)\n*   方法 2: $0 \\rightarrow 1 \\implies 3 \\rightarrow 4 \\implies 6 \\implies 8 \\implies 10 \\implies 12$ (共移动 7 次，跳过 3 个障碍物)\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ucfl5v1.png)\n但是，使用以下方法则无法跳过所有障碍物。\n\n*   方法 3: $0 \\implies 2 \\implies 4 \\implies 6 \\implies 8 \\implies 10 \\implies 12$ (共移动 6 次，跳过 2 个障碍物)\n![](https://cdn.luogu.com.cn/upload/image_hosting/jyrzfkbk.png)\n\n*   方法 4: $0 \\rightarrow 1 \\implies 3 \\implies 5 \\implies 7 \\implies 9 \\rightarrow 10 \\implies 12$ (共移动 7 次，跳过 2 个障碍物)\n![](https://cdn.luogu.com.cn/upload/image_hosting/fz3udx03.png)\n\n*   方法 5: $0 \\rightarrow 1 \\implies 3 \\rightarrow 4 \\rightarrow 5$ (共移动 5 次，跳过 1 个障碍物)\n![](https://cdn.luogu.com.cn/upload/image_hosting/pbilv3k5.png)\n\n在各个示例中，**移动次数**是行走次数和跳跃次数的总和。在这个示例中，方法 2 是用最少移动次数跳过所有障碍物的最佳方法。\n\n你需要找到一种将**移动次数**最小化、能够跳过所有障碍物的最佳方法。但是，也可能存在仅用给定的两种行动无法跳过所有障碍物的情况。", "inputFormat": "第一行给定 $N$。\n\n第二行依次给定 $N$ 个整数 $X_1, X_2, \\dots, X_N$，由空格分隔。", "outputFormat": "如果无法跳过所有障碍物，则输出 -1。\n\n如果可以跳过所有障碍物，则输出跳过所有障碍物所需的最少移动次数。", "hint": "### 限制条件\n\n*   所有给定的数都是整数。\n*   $1 \\le N \\le 250\\,000$\n*   $1 \\le X_1 < X_2 < ... < X_N \\le 250\\,000$\n\n### 子任务\n\n1.  (7 分) $N = 1, X_1 \\le 5$\n2.  (12 分) $N = 1, X_1 \\le 5\\,000$\n3.  (23 分) 对于所有满足 $1 \\le i \\le N$ 的 $i$，$N \\le 5\\,000$ 且 $X_i \\le 5\\,000$\n4.  (58 分) 无额外限制条件。", "locale": "zh-CN"}}}
{"pid": "P13518", "type": "P", "difficulty": 2, "samples": [["2 0\n-1 2", "6"], ["6 3\n-4 -2 2 6 8 9", "57"], ["9 9\n0 1 3 3 4 5 8 9 10", "49"], ["1 1000000000\n-999999999", "-2999999998"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2025", "KOI（韩国）"], "title": "[KOI 2025 #2] 镜子", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "你正在一条数轴上玩游戏。你的角色位于位置 $s$，数轴上放置了 $N$ 个镜子。各个镜子的位置从左到右依次为 $A_1 \\le A_2 \\le \\cdots \\le A_N$。同一个位置上可能有多个镜子。\n\n你可以使用镜子来改变角色的位置。使用镜子后，角色的位置会移动到以该镜子为中心的对称点。也就是说，当你的角色位于位置 $a$ 时，如果使用位于位置 $b$ 的镜子，你的角色将移动到位置 $2b - a$。\n\n这 $N$ 个镜子每个都必须且只能使用一次。也就是说，不能忽略任何一个镜子不使用，也不能对同一个镜子使用两次或以上。除了每个镜子都必须且只能使用一次这个条件外，你可以按任意顺序使用这些镜子。\n\n你需要计算并输出在这些条件下，你的角色能到达的位置的最大值。", "inputFormat": "第一行给定镜子的数量 $N$ 和你的初始位置 $s$，以空格分隔。\n\n第二行依次给定各个镜子的位置 $A_1, A_2, \\cdots, A_N$，以空格分隔。", "outputFormat": "输出将 $N$ 个镜子每个都使用一次后，角色最终位置的最大值。\n\n注意，答案可能会很大，在某些编程语言中可能需要使用 64 位整型变量 (long long)。", "hint": "### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rjvbt6e9.png)\n\n如果先使用第 1 个镜子 (位置为 -1)，再使用第 2 个镜子 (位置为 2)，如上图所示，角色的最终位置为 6。反之，如果先使用第 2 个镜子，再使用第 1 个镜子，角色的最终位置为 -6。因此，本例的答案是 6。\n\n### 限制条件\n\n*   所有给定的数都是整数。\n*   $1 \\le N \\le 200\\,000$\n*   $-10^9 \\le s \\le 10^9$\n*   $-10^9 \\le A_1 \\le A_2 \\le \\cdots \\le A_N \\le 10^9$\n\n### 子任务\n\n1.  (7 分) $N \\le 2$。\n2.  (25 分) $N$ 是偶数，且 $A_1 = A_2 = \\cdots = A_{N/2} < s < A_{N/2+1} = A_{N/2+2} = \\cdots = A_N$。\n3.  (19 分) $N$ 是偶数，且 $A_{N/2} < s < A_{N/2+1}$。\n4.  (49 分) 无额外限制条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2025 #2] 镜子", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "你正在一条数轴上玩游戏。你的角色位于位置 $s$，数轴上放置了 $N$ 个镜子。各个镜子的位置从左到右依次为 $A_1 \\le A_2 \\le \\cdots \\le A_N$。同一个位置上可能有多个镜子。\n\n你可以使用镜子来改变角色的位置。使用镜子后，角色的位置会移动到以该镜子为中心的对称点。也就是说，当你的角色位于位置 $a$ 时，如果使用位于位置 $b$ 的镜子，你的角色将移动到位置 $2b - a$。\n\n这 $N$ 个镜子每个都必须且只能使用一次。也就是说，不能忽略任何一个镜子不使用，也不能对同一个镜子使用两次或以上。除了每个镜子都必须且只能使用一次这个条件外，你可以按任意顺序使用这些镜子。\n\n你需要计算并输出在这些条件下，你的角色能到达的位置的最大值。", "inputFormat": "第一行给定镜子的数量 $N$ 和你的初始位置 $s$，以空格分隔。\n\n第二行依次给定各个镜子的位置 $A_1, A_2, \\cdots, A_N$，以空格分隔。", "outputFormat": "输出将 $N$ 个镜子每个都使用一次后，角色最终位置的最大值。\n\n注意，答案可能会很大，在某些编程语言中可能需要使用 64 位整型变量 (long long)。", "hint": "### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rjvbt6e9.png)\n\n如果先使用第 1 个镜子 (位置为 -1)，再使用第 2 个镜子 (位置为 2)，如上图所示，角色的最终位置为 6。反之，如果先使用第 2 个镜子，再使用第 1 个镜子，角色的最终位置为 -6。因此，本例的答案是 6。\n\n### 限制条件\n\n*   所有给定的数都是整数。\n*   $1 \\le N \\le 200\\,000$\n*   $-10^9 \\le s \\le 10^9$\n*   $-10^9 \\le A_1 \\le A_2 \\le \\cdots \\le A_N \\le 10^9$\n\n### 子任务\n\n1.  (7 分) $N \\le 2$。\n2.  (25 分) $N$ 是偶数，且 $A_1 = A_2 = \\cdots = A_{N/2} < s < A_{N/2+1} = A_{N/2+2} = \\cdots = A_N$。\n3.  (19 分) $N$ 是偶数，且 $A_{N/2} < s < A_{N/2+1}$。\n4.  (49 分) 无额外限制条件。", "locale": "zh-CN"}}}
{"pid": "P13519", "type": "P", "difficulty": 4, "samples": [["4 4\n1 2\n2 3\n3 1\n3 4", "0\n6\n10\n16"], ["4 4\n2 3\n3 1\n3 4\n1 2", "0\n8\n14\n16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "KOI（韩国）", "Floyd 算法"], "title": "[KOI 2025 #2] 通行费", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "KOI 市由从 1 号到 $N$ 号的 $N$ 座建筑组成，有从 1 号到 $M$ 号的 $M$ 条双向道路连接着各个建筑。每条道路连接两座不同的建筑，其中第 $i$ 条道路双向连接着 $u_i$ 号建筑和 $v_i$ 号建筑。此时，可以利用这些道路在任意两座建筑之间往来。\n\n原本 KOI 市的各条道路都可以免费使用，即所有道路的通行费都为 0 元。但是，KOI 市的市长“郑信息”为了克服 KOI 市的财政困难，决定在 $M$ 天内对各条道路征收通行费。具体来说，“郑信息”在第 $i$ 天会将第 $i$ 条道路的通行费变更为 1 元。因此，当 $M$ 天全部过去后，所有道路的通行费都将变为 1 元。\n\n从 $a$ 号建筑到 $b$ 号建筑的**最小移动成本**定义为从 $a$ 号建筑移动到 $b$ 号建筑所需支付的通行费总和的最小值，并记作 $f(a, b)$。如果 $a=b$，则 $f(a, b)=0$。\n\n路网的**总成本**定义为所有可能的建筑对之间的最小移动成本之和。即，计算所有满足 $1 \\le a, b \\le N$ 的自然数 $a$ 和 $b$ 的 $f(a, b)$ 值，然后将它们全部相加，得到的就是路网的总成本。用数学符号表示，路网的总成本为 $\\sum_{a=1}^{N} \\sum_{b=1}^{N} f(a, b)$。\n\n“郑信息”想要分析通行费的变化会对市民产生怎样的影响。你需要帮助“郑信息”，计算出第 $i$ 天结束后路网的总成本，对每一个 $i$ (从 1 到 $M$) 都进行计算。", "inputFormat": "第一行给定 $N$ 和 $M$，以空格分隔。\n\n接下来 $M$ 行是道路的信息。其中第 $i(1 \\le i \\le M)$ 行给定两个整数 $u_i, v_i$，以空格分隔。", "outputFormat": "共输出 $M$ 行。其中第 $i(1 \\le i \\le M)$ 行，输出第 $i$ 天结束后路网的总成本。", "hint": "### 样例 1 解释\n\n4 天后，各建筑间的最小移动成本可以用下表表示。\n\n|          | **1 号建筑** | **2 号建筑** | **3 号建筑** | **4 号建筑** |\n| :------- | :----------: | :----------: | :----------: | :----------: |\n| **1 号建筑** |      0       |      1       |      1       |      2       |\n| **2 号建筑** |      1       |      0       |      1       |      2       |\n| **3 号建筑** |      1       |      1       |      0       |      1       |\n| **4 号建筑** |      2       |      2       |      1       |      0       |\n\n因此，第 4 天结束后，路网的总成本为表中所有数字之和：\n\n$0 + 1 + 1 + 2 + 1 + 0 + 1 + 2 + 1 + 1 + 0 + 1 + 2 + 2 + 1 + 0 = 16$。\n\n### 限制条件\n\n*   所有给定的数都是整数。\n*   $2 \\le N \\le 500$\n*   $N-1 \\le M \\le \\frac{N(N-1)}{2}$\n*   对于 $1 \\le i \\le M$，满足 $u_i \\ne v_i$。\n*   对于 $1 \\le i \\le M$，满足 $1 \\le u_i, v_i \\le N$。\n*   连接任意两座不同建筑的道路最多只有一条。\n*   可以利用道路在任意两座建筑之间往来。\n\n### 子任务\n\n1.  (10 分) $N \\le 5$。\n2.  (15 分) $N \\le 50$。\n3.  (30 分) $M \\le 500$。\n4.  (45 分) 无额外限制条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2025 #2] 通行费", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "KOI 市由从 1 号到 $N$ 号的 $N$ 座建筑组成，有从 1 号到 $M$ 号的 $M$ 条双向道路连接着各个建筑。每条道路连接两座不同的建筑，其中第 $i$ 条道路双向连接着 $u_i$ 号建筑和 $v_i$ 号建筑。此时，可以利用这些道路在任意两座建筑之间往来。\n\n原本 KOI 市的各条道路都可以免费使用，即所有道路的通行费都为 0 元。但是，KOI 市的市长“郑信息”为了克服 KOI 市的财政困难，决定在 $M$ 天内对各条道路征收通行费。具体来说，“郑信息”在第 $i$ 天会将第 $i$ 条道路的通行费变更为 1 元。因此，当 $M$ 天全部过去后，所有道路的通行费都将变为 1 元。\n\n从 $a$ 号建筑到 $b$ 号建筑的**最小移动成本**定义为从 $a$ 号建筑移动到 $b$ 号建筑所需支付的通行费总和的最小值，并记作 $f(a, b)$。如果 $a=b$，则 $f(a, b)=0$。\n\n路网的**总成本**定义为所有可能的建筑对之间的最小移动成本之和。即，计算所有满足 $1 \\le a, b \\le N$ 的自然数 $a$ 和 $b$ 的 $f(a, b)$ 值，然后将它们全部相加，得到的就是路网的总成本。用数学符号表示，路网的总成本为 $\\sum_{a=1}^{N} \\sum_{b=1}^{N} f(a, b)$。\n\n“郑信息”想要分析通行费的变化会对市民产生怎样的影响。你需要帮助“郑信息”，计算出第 $i$ 天结束后路网的总成本，对每一个 $i$ (从 1 到 $M$) 都进行计算。", "inputFormat": "第一行给定 $N$ 和 $M$，以空格分隔。\n\n接下来 $M$ 行是道路的信息。其中第 $i(1 \\le i \\le M)$ 行给定两个整数 $u_i, v_i$，以空格分隔。", "outputFormat": "共输出 $M$ 行。其中第 $i(1 \\le i \\le M)$ 行，输出第 $i$ 天结束后路网的总成本。", "hint": "### 样例 1 解释\n\n4 天后，各建筑间的最小移动成本可以用下表表示。\n\n|          | **1 号建筑** | **2 号建筑** | **3 号建筑** | **4 号建筑** |\n| :------- | :----------: | :----------: | :----------: | :----------: |\n| **1 号建筑** |      0       |      1       |      1       |      2       |\n| **2 号建筑** |      1       |      0       |      1       |      2       |\n| **3 号建筑** |      1       |      1       |      0       |      1       |\n| **4 号建筑** |      2       |      2       |      1       |      0       |\n\n因此，第 4 天结束后，路网的总成本为表中所有数字之和：\n\n$0 + 1 + 1 + 2 + 1 + 0 + 1 + 2 + 1 + 1 + 0 + 1 + 2 + 2 + 1 + 0 = 16$。\n\n### 限制条件\n\n*   所有给定的数都是整数。\n*   $2 \\le N \\le 500$\n*   $N-1 \\le M \\le \\frac{N(N-1)}{2}$\n*   对于 $1 \\le i \\le M$，满足 $u_i \\ne v_i$。\n*   对于 $1 \\le i \\le M$，满足 $1 \\le u_i, v_i \\le N$。\n*   连接任意两座不同建筑的道路最多只有一条。\n*   可以利用道路在任意两座建筑之间往来。\n\n### 子任务\n\n1.  (10 分) $N \\le 5$。\n2.  (15 分) $N \\le 50$。\n3.  (30 分) $M \\le 500$。\n4.  (45 分) 无额外限制条件。", "locale": "zh-CN"}}}
{"pid": "P13520", "type": "P", "difficulty": 5, "samples": [["4\n6 4\n5 1\n9 8\n2 1", "1\n2\n2\n2"], ["6\n3 2\n5 4\n3 2\n4 3\n4 3\n3 2", "1\n1\n2\n2\n2\n3"], ["8\n13 6\n7 5\n9 4\n11 10\n4 2\n15 5\n16 7\n8 3", "1\n2\n3\n3\n3\n4\n4\n5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "树状数组", "2025", "离散化", "Dilworth 定理", "KOI（韩国）"], "title": "[KOI 2025 #2] 存放箱子", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "小郑想要在仓库里存放箱子。总共有 $N$ 个箱子，编号从 1 到 $N$。第 $i$ ($1 \\le i \\le N$) 号箱子的大小为 $s_i$，收纳容量为 $c_i$。所有箱子的收纳容量都比其自身的大小要小，即满足 $c_i < s_i$。\n\n小郑觉得仓库里的箱子太多、太杂乱，因此想把一些箱子装到另一些箱子里来存放。此时，必须满足以下条件：\n\n*   一个箱子可以装下大小**不大于**其收纳容量的箱子。\n*   已经装有其他箱子的箱子，也可以被装入另一个箱子中。\n*   一个箱子**直接容纳**的箱子最多只能有一个。换句话说，一个箱子内最多可以直接放入一个其他的箱子，但允许这个被放入的箱子内部还装有别的箱子。\n\n存放箱子的成本，等于没有被装在任何其他箱子里的箱子的数量。\n\n例如，假设 $N = 4$，四个箱子的大小和收纳容量分别如下表所示。\n\n| **编号** | **大小** | **收纳容量** |\n| :---: | :---: | :---: |\n|   1   |   6   |   4   |\n|   2   |   5   |   1   |\n|   3   |   9   |   8   |\n|   4   |   2   |   1   |\n\n此时，如下图所示，如果将 4 号箱子放入 1 号箱子，再将 1 号箱子放入 3 号箱子，那么没有被装在其他箱子里的箱子就有 2 个 (3 号箱子和 2 号箱子)，因此存放箱子的成本为 2。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sxmrnti7.png)\n\n但是，如下图所示，如果将 2 号箱子和 4 号箱子都放入 3 号箱子中，由于 3 号箱子内直接容纳了两个箱子，因此不满足条件。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k8bcx8pi.png)\n\n仓库里不必非要放下所有的箱子，所以小郑计划只保留编号较小的一部分箱子，并丢弃其余的。小郑目前还没有决定要使用多少个箱子。\n\n请你帮助小郑，对于从 1 到 $N$ 的所有 $i$，编写一个程序来计算存放 $1, 2, \\ldots, i$ 号箱子所需的最小成本。", "inputFormat": "第一行给定箱子的数量 $N$。\n\n从第二行开始的 $N$ 行，给出了各个箱子的信息。其中第 $i$ 行（指这 $N$ 行中的第 $i$ 行，即文件的第 $i+1$ 行）是关于第 $i$ 号箱子的，给出了其大小 $s_i$ 和收纳容量 $c_i$，以空格分隔。", "outputFormat": "输出 $N$ 行。\n\n第 $i$ ($1 \\le i \\le N$) 行输出存放 $1, 2, \\ldots, i$ 号箱子所需的最小成本。", "hint": "### 限制条件\n\n*   所有给定的数都是整数。\n*   $2 \\le N \\le 2 \\times 10^5$\n*   $1 \\le c_i < s_i \\le 10^9$ ($1 \\le i \\le N$)\n\n### 子任务\n\n1.  (7 分) $N \\le 6$。\n2.  (12 分) 对于所有 $i$，$s_i = c_i + 1$。\n3.  (26 分) $N \\le 1000$。\n4.  (17 分) 对于所有 $i$，$s_i \\le 100$。\n5.  (38 分) 无额外限制条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2025 #2] 存放箱子", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "小郑想要在仓库里存放箱子。总共有 $N$ 个箱子，编号从 1 到 $N$。第 $i$ ($1 \\le i \\le N$) 号箱子的大小为 $s_i$，收纳容量为 $c_i$。所有箱子的收纳容量都比其自身的大小要小，即满足 $c_i < s_i$。\n\n小郑觉得仓库里的箱子太多、太杂乱，因此想把一些箱子装到另一些箱子里来存放。此时，必须满足以下条件：\n\n*   一个箱子可以装下大小**不大于**其收纳容量的箱子。\n*   已经装有其他箱子的箱子，也可以被装入另一个箱子中。\n*   一个箱子**直接容纳**的箱子最多只能有一个。换句话说，一个箱子内最多可以直接放入一个其他的箱子，但允许这个被放入的箱子内部还装有别的箱子。\n\n存放箱子的成本，等于没有被装在任何其他箱子里的箱子的数量。\n\n例如，假设 $N = 4$，四个箱子的大小和收纳容量分别如下表所示。\n\n| **编号** | **大小** | **收纳容量** |\n| :---: | :---: | :---: |\n|   1   |   6   |   4   |\n|   2   |   5   |   1   |\n|   3   |   9   |   8   |\n|   4   |   2   |   1   |\n\n此时，如下图所示，如果将 4 号箱子放入 1 号箱子，再将 1 号箱子放入 3 号箱子，那么没有被装在其他箱子里的箱子就有 2 个 (3 号箱子和 2 号箱子)，因此存放箱子的成本为 2。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sxmrnti7.png)\n\n但是，如下图所示，如果将 2 号箱子和 4 号箱子都放入 3 号箱子中，由于 3 号箱子内直接容纳了两个箱子，因此不满足条件。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k8bcx8pi.png)\n\n仓库里不必非要放下所有的箱子，所以小郑计划只保留编号较小的一部分箱子，并丢弃其余的。小郑目前还没有决定要使用多少个箱子。\n\n请你帮助小郑，对于从 1 到 $N$ 的所有 $i$，编写一个程序来计算存放 $1, 2, \\ldots, i$ 号箱子所需的最小成本。", "inputFormat": "第一行给定箱子的数量 $N$。\n\n从第二行开始的 $N$ 行，给出了各个箱子的信息。其中第 $i$ 行（指这 $N$ 行中的第 $i$ 行，即文件的第 $i+1$ 行）是关于第 $i$ 号箱子的，给出了其大小 $s_i$ 和收纳容量 $c_i$，以空格分隔。", "outputFormat": "输出 $N$ 行。\n\n第 $i$ ($1 \\le i \\le N$) 行输出存放 $1, 2, \\ldots, i$ 号箱子所需的最小成本。", "hint": "### 限制条件\n\n*   所有给定的数都是整数。\n*   $2 \\le N \\le 2 \\times 10^5$\n*   $1 \\le c_i < s_i \\le 10^9$ ($1 \\le i \\le N$)\n\n### 子任务\n\n1.  (7 分) $N \\le 6$。\n2.  (12 分) 对于所有 $i$，$s_i = c_i + 1$。\n3.  (26 分) $N \\le 1000$。\n4.  (17 分) 对于所有 $i$，$s_i \\le 100$。\n5.  (38 分) 无额外限制条件。", "locale": "zh-CN"}}}
{"pid": "P13521", "type": "P", "difficulty": 2, "samples": [["5 1 6\n1 2 3 4 5", "2\n2\n3\n3\n3\n4"], ["5 2 5\n2 3 5 7 11", "5\n8\n8\n8\n12"], ["3 2 3\n1 1 7", "8\n8\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "排序", "前缀和", "双指针 two-pointer", "KOI（韩国）"], "title": "[KOI 2025 #2] 包", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "商户是在 KOI 市经营商店的一位市民。商户的店里有 $N$ 件商品，其中第 $i$ 件商品的重量为 $A_i$。商户收到了情报，得知小偷“金基范”正觊觎自己的店铺，于是他准备采取措施，将损失降到最低。\n\n小偷金基范计划从店里偷走 $K$ 件商品。但如果商品太重，不仅难以偷窃，被警察抓住的可能性也会变高。因此，小偷金基范会**最小化**他所偷商品的总重量。不过，如果店里的商品总数不足 $K$ 件，小偷金基范会偷走店里所有的商品。\n\n在小偷金基范到达店铺之前，商户会把店里的一些商品装进一个包里带走。之后，小偷金基范会对商户没有带走的那些商品，以上述方式实施盗窃。商户希望通过合理地往包里装商品，来**最大化**小偷金基范最终偷走的商品总重量。\n\n商户的包能承受的重量是有限的。当给定一个最大承重 $C$ 时，请对所有的 $x = 1, 2, \\ldots, C$ 回答以下问题：\n\n*   在商户能放入包中的商品总重量不超过 $x$ 的条件下，小偷金基范偷走的商品总重量的最大值是多少？", "inputFormat": "第一行给定 $N, K, C$，由空格分隔。\n\n第二行给定 $N$ 个整数 $A_1, A_2, \\ldots, A_N$，由空格分隔。", "outputFormat": "输出 $C$ 行。第 $i$ 行输出当 $x = i$ 时，小偷金基范偷走的商品总重量的最大值。", "hint": "### 限制条件\n\n*   所有给定的数都是整数。\n*   $1 \\le K \\le N \\le 5\\,000$\n*   $1 \\le C \\le 1\\,000\\,000$\n*   对于所有 $i$ ($1 \\le i \\le N$)，满足 $1 \\le A_i \\le 1\\,000\\,000$\n\n### 子任务\n\n1.  (13 分) $N \\le 10, A_i \\le 10\\,000, C \\le 10\\,000$\n2.  (17 分) $N \\le 80, A_i \\le 10\\,000, C \\le 10\\,000$\n3.  (23 分) $A_i \\le 10\\,000, C \\le 10\\,000$\n4.  (16 分) $K = 1$\n5.  (31 分) 无额外限制条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2025 #2] 包", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "商户是在 KOI 市经营商店的一位市民。商户的店里有 $N$ 件商品，其中第 $i$ 件商品的重量为 $A_i$。商户收到了情报，得知小偷“金基范”正觊觎自己的店铺，于是他准备采取措施，将损失降到最低。\n\n小偷金基范计划从店里偷走 $K$ 件商品。但如果商品太重，不仅难以偷窃，被警察抓住的可能性也会变高。因此，小偷金基范会**最小化**他所偷商品的总重量。不过，如果店里的商品总数不足 $K$ 件，小偷金基范会偷走店里所有的商品。\n\n在小偷金基范到达店铺之前，商户会把店里的一些商品装进一个包里带走。之后，小偷金基范会对商户没有带走的那些商品，以上述方式实施盗窃。商户希望通过合理地往包里装商品，来**最大化**小偷金基范最终偷走的商品总重量。\n\n商户的包能承受的重量是有限的。当给定一个最大承重 $C$ 时，请对所有的 $x = 1, 2, \\ldots, C$ 回答以下问题：\n\n*   在商户能放入包中的商品总重量不超过 $x$ 的条件下，小偷金基范偷走的商品总重量的最大值是多少？", "inputFormat": "第一行给定 $N, K, C$，由空格分隔。\n\n第二行给定 $N$ 个整数 $A_1, A_2, \\ldots, A_N$，由空格分隔。", "outputFormat": "输出 $C$ 行。第 $i$ 行输出当 $x = i$ 时，小偷金基范偷走的商品总重量的最大值。", "hint": "### 限制条件\n\n*   所有给定的数都是整数。\n*   $1 \\le K \\le N \\le 5\\,000$\n*   $1 \\le C \\le 1\\,000\\,000$\n*   对于所有 $i$ ($1 \\le i \\le N$)，满足 $1 \\le A_i \\le 1\\,000\\,000$\n\n### 子任务\n\n1.  (13 分) $N \\le 10, A_i \\le 10\\,000, C \\le 10\\,000$\n2.  (17 分) $N \\le 80, A_i \\le 10\\,000, C \\le 10\\,000$\n3.  (23 分) $A_i \\le 10\\,000, C \\le 10\\,000$\n4.  (16 分) $K = 1$\n5.  (31 分) 无额外限制条件。", "locale": "zh-CN"}}}
{"pid": "P13522", "type": "P", "difficulty": 5, "samples": [["2\n2 2\n5 3\n7\n3 1\n3 2\n3 3\n3 4\n3 5\n3 6\n3 7", "2\n4\n3\n2\n6\n5\n8"], ["3\n-3 3\n2 2\n11 6\n4\n1 6\n6 12\n11 3\n9 4", "-1\n2\n15\n5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "线段树", "倍增", "2025", "动态规划优化", "KOI（韩国）"], "title": "[KOI 2025 #2] 机器人", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "在一条数轴上的不同位置设置了 $N$ 个跳跃台。第 $i$ 个跳跃台拥有一个固定的位置 $X_i$ 和一个初始跳跃力量 $P_i$。你将把一个机器人放置在这条数轴上的某个位置。\n\n机器人会按照以下规则移动：\n\n*   如果机器人所在的位置没有跳跃台，机器人会向左移动 1 个单位。这个过程消耗 1 单位时间。\n*   如果机器人所在的位置有跳跃台，机器人会立即启动该跳跃台，并向右跳跃其力量值的距离。跳跃后，该跳跃台的力量会变为原来的两倍。这个过程消耗 1 单位时间。\n\n例如，假设有 $N=2$ 个跳跃台，设置如下。\n\n| **跳跃台编号** | **位置** $X_i$ | **初始力量** $P_i$ |\n| :--------: | :---------: | :-----------: |\n|     1      |      2      |       2       |\n|     2      |      5      |       3       |\n\n机器人从初始位置 $S = 3$ 出发，移动 $T=7$ 单位时间的过程如下。\n\n| **时间($T$)** | **机器人位置** | **说明**                                                     | **跳跃台状态**             |\n| :----------: | :---------: | :----------------------------------------------------------- | :------------------------- |\n|      0       |      3      | 从初始位置开始。                                             | $P_1 = 2, P_2 = 3$         |\n|      1       |      2      | 因为没有跳跃台，向左移动了 1 个单位。                         | $P_1 = 2, P_2 = 3$         |\n|      2       |      4      | 启动了位置 2 上的 1 号跳跃台，向右跳跃了 2 个单位。           | $P_1 = 4, P_2 = 3$         |\n|      3       |      3      | 因为没有跳跃台，向左移动了 1 个单位。                         | $P_1 = 4, P_2 = 3$         |\n|      4       |      2      | 因为没有跳跃台，向左移动了 1 个单位。                         | $P_1 = 4, P_2 = 3$         |\n|      5       |      6      | 启动了位置 2 上的 1 号跳跃台，向右跳跃了 4 个单位。           | $P_1 = 8, P_2 = 3$         |\n|      6       |      5      | 因为没有跳跃台，向左移动了 1 个单位。                         | $P_1 = 8, P_2 = 3$         |\n|      7       |      8      | 启动了位置 5 上的 2 号跳跃台，向右跳跃了 3 个单位。           | $P_1 = 8, P_2 = 6$         |\n\n给定 $Q$ 个整数对 $(S_j, T_j)$ ($1 \\le j \\le Q$)。对于每对整数，你需要编写一个程序，计算出机器人从位置 $S_j$ 出发，经过恰好 $T_j$ 单位时间后到达的位置。\n\n每次查询都是**独立**计算的，并且总是从跳跃台的初始状态开始。也就是说，每次查询时，数轴上只有一个机器人，且所有跳跃台的力量都会重置为输入给定的初始值。", "inputFormat": "第一行给定 $N$。\n\n接下来 $N$ 行，每行给出一对整数。其中第 $i$ ($1 \\le i \\le N$) 行给定了 $X_i$ 和 $P_i$，以空格分隔。\n\n接下来的一行给定 $Q$。\n\n接下来 $Q$ 行，每行给出一对整数。其中第 $j$ ($1 \\le j \\le Q$) 行给定了 $S_j$ 和 $T_j$，以空格分隔。", "outputFormat": "输出 $Q$ 行。其中第 $j$ ($1 \\le j \\le Q$) 行输出机器人从 $S_j$ 出发，经过恰好 $T_j$ 单位时间后到达的位置。", "hint": "### 限制条件\n\n*   所有给定的数都是整数。\n*   $1 \\le N \\le 300\\,000$\n*   $-10^{17} \\le X_1 < X_2 < ... < X_N \\le 10^{17}$\n*   $1 \\le P_i \\le 10^{17}$ ($1 \\le i \\le N$)\n*   $1 \\le Q \\le 300\\,000$\n*   $-10^{17} \\le S_j\\le 10^{17},1\\le T_j \\le 10^{17}$ ($1 \\le j \\le Q$)\n\n### 子任务\n\n1.  (5 分) $N=1$\n2.  (11 分) $N=2$\n3.  (6 分) 对于所有 $1 \\le i \\le N$ 和 $1 \\le j \\le Q$，满足 $|X_i|, P_i \\le 300, |S_j|, T_j \\le 300$。\n4.  (7 分) 对于所有 $1 \\le i \\le N$ 和 $1 \\le j \\le Q$，满足 $N, Q \\le 3\\,000, |X_i|, P_i \\le 3\\,000, |S_j|, T_j \\le 3\\,000$。\n5.  (12 分) $N, Q \\le 9\\,000$\n6.  (23 分) $N \\le 9\\,000$\n7.  (36 分) 无额外限制条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2025 #2] 机器人", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "在一条数轴上的不同位置设置了 $N$ 个跳跃台。第 $i$ 个跳跃台拥有一个固定的位置 $X_i$ 和一个初始跳跃力量 $P_i$。你将把一个机器人放置在这条数轴上的某个位置。\n\n机器人会按照以下规则移动：\n\n*   如果机器人所在的位置没有跳跃台，机器人会向左移动 1 个单位。这个过程消耗 1 单位时间。\n*   如果机器人所在的位置有跳跃台，机器人会立即启动该跳跃台，并向右跳跃其力量值的距离。跳跃后，该跳跃台的力量会变为原来的两倍。这个过程消耗 1 单位时间。\n\n例如，假设有 $N=2$ 个跳跃台，设置如下。\n\n| **跳跃台编号** | **位置** $X_i$ | **初始力量** $P_i$ |\n| :--------: | :---------: | :-----------: |\n|     1      |      2      |       2       |\n|     2      |      5      |       3       |\n\n机器人从初始位置 $S = 3$ 出发，移动 $T=7$ 单位时间的过程如下。\n\n| **时间($T$)** | **机器人位置** | **说明**                                                     | **跳跃台状态**             |\n| :----------: | :---------: | :----------------------------------------------------------- | :------------------------- |\n|      0       |      3      | 从初始位置开始。                                             | $P_1 = 2, P_2 = 3$         |\n|      1       |      2      | 因为没有跳跃台，向左移动了 1 个单位。                         | $P_1 = 2, P_2 = 3$         |\n|      2       |      4      | 启动了位置 2 上的 1 号跳跃台，向右跳跃了 2 个单位。           | $P_1 = 4, P_2 = 3$         |\n|      3       |      3      | 因为没有跳跃台，向左移动了 1 个单位。                         | $P_1 = 4, P_2 = 3$         |\n|      4       |      2      | 因为没有跳跃台，向左移动了 1 个单位。                         | $P_1 = 4, P_2 = 3$         |\n|      5       |      6      | 启动了位置 2 上的 1 号跳跃台，向右跳跃了 4 个单位。           | $P_1 = 8, P_2 = 3$         |\n|      6       |      5      | 因为没有跳跃台，向左移动了 1 个单位。                         | $P_1 = 8, P_2 = 3$         |\n|      7       |      8      | 启动了位置 5 上的 2 号跳跃台，向右跳跃了 3 个单位。           | $P_1 = 8, P_2 = 6$         |\n\n给定 $Q$ 个整数对 $(S_j, T_j)$ ($1 \\le j \\le Q$)。对于每对整数，你需要编写一个程序，计算出机器人从位置 $S_j$ 出发，经过恰好 $T_j$ 单位时间后到达的位置。\n\n每次查询都是**独立**计算的，并且总是从跳跃台的初始状态开始。也就是说，每次查询时，数轴上只有一个机器人，且所有跳跃台的力量都会重置为输入给定的初始值。", "inputFormat": "第一行给定 $N$。\n\n接下来 $N$ 行，每行给出一对整数。其中第 $i$ ($1 \\le i \\le N$) 行给定了 $X_i$ 和 $P_i$，以空格分隔。\n\n接下来的一行给定 $Q$。\n\n接下来 $Q$ 行，每行给出一对整数。其中第 $j$ ($1 \\le j \\le Q$) 行给定了 $S_j$ 和 $T_j$，以空格分隔。", "outputFormat": "输出 $Q$ 行。其中第 $j$ ($1 \\le j \\le Q$) 行输出机器人从 $S_j$ 出发，经过恰好 $T_j$ 单位时间后到达的位置。", "hint": "### 限制条件\n\n*   所有给定的数都是整数。\n*   $1 \\le N \\le 300\\,000$\n*   $-10^{17} \\le X_1 < X_2 < ... < X_N \\le 10^{17}$\n*   $1 \\le P_i \\le 10^{17}$ ($1 \\le i \\le N$)\n*   $1 \\le Q \\le 300\\,000$\n*   $-10^{17} \\le S_j\\le 10^{17},1\\le T_j \\le 10^{17}$ ($1 \\le j \\le Q$)\n\n### 子任务\n\n1.  (5 分) $N=1$\n2.  (11 分) $N=2$\n3.  (6 分) 对于所有 $1 \\le i \\le N$ 和 $1 \\le j \\le Q$，满足 $|X_i|, P_i \\le 300, |S_j|, T_j \\le 300$。\n4.  (7 分) 对于所有 $1 \\le i \\le N$ 和 $1 \\le j \\le Q$，满足 $N, Q \\le 3\\,000, |X_i|, P_i \\le 3\\,000, |S_j|, T_j \\le 3\\,000$。\n5.  (12 分) $N, Q \\le 9\\,000$\n6.  (23 分) $N \\le 9\\,000$\n7.  (36 分) 无额外限制条件。", "locale": "zh-CN"}}}
{"pid": "P13523", "type": "P", "difficulty": 7, "samples": [["6 15\n6 -7 3 -1 5 2\n-7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7", "-1\n0\n1\n2\n3\n4\n5\n9\n14\n20\n26\n32\n38\n44\n50"], ["10 15\n-2 6 3 -8 1 2 0 -3 9 6\n-7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7", "2\n3\n5\n7\n9\n11\n13\n16\n25\n34\n44\n54\n64\n74\n84"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "分治", "斜率优化", "凸包", "KOI（韩国）"], "title": "[KOI 2025 #2] 序列与查询", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。\n\n**本题测试数据极大，评测时可能需要 2-3 分钟时间预加载数据。**", "description": "对于一个长度为 $l$ 的序列 $[B_1, B_2, \\ldots, B_l]$，序列的**连续子区间**被定义为像 $[B_i, B_{i+1}, \\ldots, B_j]$ 这样在序列中连续出现的数的子序列。连续子区间不能为空。即，必须满足 $1 \\le i \\le j \\le l$。\n\n对于一个长度为 $l$ 的序列 $[B_1, B_2, \\ldots, B_l]$，序列的**最大连续子区间和**被定义为该序列所有连续子区间的元素和中的最大值。例如，序列 $[6, -7, 3, -1, 5, 2]$ 的最大连续子区间和是 9，这可以通过选取子区间 $[3, -1, 5, 2]$ 得到。如果用数学符号表示序列 $B$ 的最大连续子区间和，则为 $\\max_{1 \\le i \\le j \\le l}(\\sum_{k=i}^{j} B_k)$。\n\n给定一个长度为 $N$ 的序列 $[A_1, A_2, \\ldots, A_N]$ 和 $Q$ 个查询。第 $i$ 个查询由一个整数 $X_i$ 表示。当给定 $X_i$ 时，你需要计算序列 $[A_1 + X_i, A_2 + X_i, \\ldots, A_N + X_i]$ 的最大连续子区间和。", "inputFormat": "第一行给定 $N, Q$，以空格分隔。\n\n第二行给定 $A_1, A_2, \\ldots, A_N$，以空格分隔。\n\n第三行给定 $X_1, X_2, \\ldots, X_Q$，以空格分隔。\n", "outputFormat": "输出 $Q$ 行。其中第 $i(1 \\le i \\le Q)$ 行输出序列 $[A_1 + X_i, A_2 + X_i, \\ldots, A_N + X_i]$ 的最大连续子区间和。", "hint": "### 限制条件\n\n*   所有给定的数都是整数。\n*   $1 \\le N \\le 1\\,000\\,000$\n*   $1 \\le Q \\le 1\\,000\\,000$\n*   对于所有满足 $1 \\le i \\le N$ 的 $i$，有 $-10^9 \\le A_i \\le 10^9$。\n*   对于所有满足 $1 \\le i \\le Q$ 的 $i$，有 $-10^9 \\le X_i \\le 10^9$。\n\n### 子任务\n\n1.  (5 分) $N, Q \\le 300$\n2.  (5 分) $N \\le 300$\n3.  (28 分) $N \\le 10\\,000$\n4.  (17 分) $N \\le 125\\,000$\n5.  (16 分) $N \\le 250\\,000$\n6.  (15 分) $N \\le 500\\,000$\n7.  (14 分) 无额外限制条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2025 #2] 序列与查询", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。\n\n**本题测试数据极大，评测时可能需要 2-3 分钟时间预加载数据。**", "description": "对于一个长度为 $l$ 的序列 $[B_1, B_2, \\ldots, B_l]$，序列的**连续子区间**被定义为像 $[B_i, B_{i+1}, \\ldots, B_j]$ 这样在序列中连续出现的数的子序列。连续子区间不能为空。即，必须满足 $1 \\le i \\le j \\le l$。\n\n对于一个长度为 $l$ 的序列 $[B_1, B_2, \\ldots, B_l]$，序列的**最大连续子区间和**被定义为该序列所有连续子区间的元素和中的最大值。例如，序列 $[6, -7, 3, -1, 5, 2]$ 的最大连续子区间和是 9，这可以通过选取子区间 $[3, -1, 5, 2]$ 得到。如果用数学符号表示序列 $B$ 的最大连续子区间和，则为 $\\max_{1 \\le i \\le j \\le l}(\\sum_{k=i}^{j} B_k)$。\n\n给定一个长度为 $N$ 的序列 $[A_1, A_2, \\ldots, A_N]$ 和 $Q$ 个查询。第 $i$ 个查询由一个整数 $X_i$ 表示。当给定 $X_i$ 时，你需要计算序列 $[A_1 + X_i, A_2 + X_i, \\ldots, A_N + X_i]$ 的最大连续子区间和。", "inputFormat": "第一行给定 $N, Q$，以空格分隔。\n\n第二行给定 $A_1, A_2, \\ldots, A_N$，以空格分隔。\n\n第三行给定 $X_1, X_2, \\ldots, X_Q$，以空格分隔。\n", "outputFormat": "输出 $Q$ 行。其中第 $i(1 \\le i \\le Q)$ 行输出序列 $[A_1 + X_i, A_2 + X_i, \\ldots, A_N + X_i]$ 的最大连续子区间和。", "hint": "### 限制条件\n\n*   所有给定的数都是整数。\n*   $1 \\le N \\le 1\\,000\\,000$\n*   $1 \\le Q \\le 1\\,000\\,000$\n*   对于所有满足 $1 \\le i \\le N$ 的 $i$，有 $-10^9 \\le A_i \\le 10^9$。\n*   对于所有满足 $1 \\le i \\le Q$ 的 $i$，有 $-10^9 \\le X_i \\le 10^9$。\n\n### 子任务\n\n1.  (5 分) $N, Q \\le 300$\n2.  (5 分) $N \\le 300$\n3.  (28 分) $N \\le 10\\,000$\n4.  (17 分) $N \\le 125\\,000$\n5.  (16 分) $N \\le 250\\,000$\n6.  (15 分) $N \\le 500\\,000$\n7.  (14 分) 无额外限制条件。", "locale": "zh-CN"}}}
{"pid": "P13524", "type": "P", "difficulty": 5, "samples": [["5\n1 3 3 1", "1 3 4 2 5"], ["7\n1 3 3 5 3 1", "1 6 2 3 5 4 7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["图论", "2025", "Special Judge", "构造", "KOI（韩国）"], "title": "[KOI 2025 #2] 跳跃", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "对于 $N \\ge 2$ 的情况，有 $N$ 个编号从 1 到 $N$ 的顶点按顺序排列在一条直线上，对于每个 $i$ ($1 \\le i \\le N-1$)，都有一条双向连接顶点 $i$ 和 $i+1$ 的边。\n\n例如，在 $N=5$ 的情况下，顶点和边的排列如下图所示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8185ut35.png)\n:::\n\n小郑可以在这个图上通过**跳跃**来移动。当小郑从一个顶点跳跃到另一个顶点时，他会经过它们之间的所有边各一次。\n\n例如：\n\n*   如果小郑从顶点 4 跳到顶点 2，他会分别经过顶点 3 和 4 之间的边，以及顶点 2 和 3 之间的边各一次。\n*   如果小郑从顶点 3 跳到顶点 4，他会经过顶点 3 和 4 之间的边一次。\n\n小郑从顶点 1 开始，经过 $N-1$ 次跳跃后到达顶点 $N$，在此过程中，他恰好访问了每个顶点一次。（最初在顶点 1 也算作一次访问。）\n\n换句话说，如果将小郑访问顶点的顺序记为 $p_1 \\rightarrow p_2 \\rightarrow \\cdots \\rightarrow p_{N-1} \\rightarrow p_N$，则 $p_1 = 1$，$p_N = N$，并且 $\\{p_1, p_2, \\ldots, p_N\\} = \\{1, 2, \\ldots, N\\}$。\n\n此时，将小郑在跳跃过程中经过顶点 $i$ 和 $i+1$ 之间的边的总次数记为 $c_i$ ($1 \\le i \\le N-1$)。\n\n例如，如果小郑按 $(p_1 = 1) \\rightarrow (p_2 = 3) \\rightarrow (p_3 = 4) \\rightarrow (p_4 = 2) \\rightarrow (p_5 = 5)$ 的顺序访问，则 $c_1 = 1, c_2 = 3, c_3 = 3, c_4 = 1$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/87qvldwc.png)\n:::\n\n当给定小郑访问顶点时经过各条边的次数所构成的序列 $c = (c_1, c_2, \\ldots, c_{N-1})$ 时，请编写一个程序，根据此序列求出小郑的访问顺序 $p_1, p_2, \\ldots, p_N$。\n\n给定的序列 $c$ 总是由某个访问顺序生成的，因此满足条件的访问顺序总是存在的。如果存在多个可能的访问顺序，输出任意一个即可。", "inputFormat": "第一行给定顶点的数量 $N$。\n\n第二行给定 $N-1$ 个整数 $c_1, c_2, \\ldots, c_{N-1}$，以空格分隔。此时，$c_i$ 表示经过顶点 $i$ 和 $i+1$ 之间边的次数。\n", "outputFormat": "输出小郑的可能访问顺序 $p_1, p_2, \\ldots, p_N$，以空格分隔。如果存在多个可能的访问顺序，输出任意一个即可。", "hint": "### 限制条件\n\n*   所有给定的数都是整数。\n*   $2 \\le N \\le 200\\,000$\n*   对于所有满足 $1 \\le i \\le N-1$ 的 $i$，有 $1 \\le c_i \\le 10^{18}$。\n*   输入保证存在可能的访问顺序。\n\n### 子任务\n\n1.  (10 分) $N \\le 10$。\n2.  (10 分) 对于所有满足 $1 \\le i \\le N-1$ 的 $i$，有 $c_i \\le 3$。\n3.  (15 分) $N \\ge 4$，且存在一个整数 $M$ ($2 \\le M \\le N-2$)，使得 $c_1 \\le c_2 \\le \\cdots \\le c_M$ 并且 $c_M \\ge c_{M+1} \\ge \\cdots \\ge c_{N-1}$。换句话说，$c_i$ 的序列呈现先单调递增后单调递减的形态。\n4.  (35 分) $N \\le 300$。\n5.  (30 分) 无额外限制条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2025 #2] 跳跃", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "对于 $N \\ge 2$ 的情况，有 $N$ 个编号从 1 到 $N$ 的顶点按顺序排列在一条直线上，对于每个 $i$ ($1 \\le i \\le N-1$)，都有一条双向连接顶点 $i$ 和 $i+1$ 的边。\n\n例如，在 $N=5$ 的情况下，顶点和边的排列如下图所示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8185ut35.png)\n:::\n\n小郑可以在这个图上通过**跳跃**来移动。当小郑从一个顶点跳跃到另一个顶点时，他会经过它们之间的所有边各一次。\n\n例如：\n\n*   如果小郑从顶点 4 跳到顶点 2，他会分别经过顶点 3 和 4 之间的边，以及顶点 2 和 3 之间的边各一次。\n*   如果小郑从顶点 3 跳到顶点 4，他会经过顶点 3 和 4 之间的边一次。\n\n小郑从顶点 1 开始，经过 $N-1$ 次跳跃后到达顶点 $N$，在此过程中，他恰好访问了每个顶点一次。（最初在顶点 1 也算作一次访问。）\n\n换句话说，如果将小郑访问顶点的顺序记为 $p_1 \\rightarrow p_2 \\rightarrow \\cdots \\rightarrow p_{N-1} \\rightarrow p_N$，则 $p_1 = 1$，$p_N = N$，并且 $\\{p_1, p_2, \\ldots, p_N\\} = \\{1, 2, \\ldots, N\\}$。\n\n此时，将小郑在跳跃过程中经过顶点 $i$ 和 $i+1$ 之间的边的总次数记为 $c_i$ ($1 \\le i \\le N-1$)。\n\n例如，如果小郑按 $(p_1 = 1) \\rightarrow (p_2 = 3) \\rightarrow (p_3 = 4) \\rightarrow (p_4 = 2) \\rightarrow (p_5 = 5)$ 的顺序访问，则 $c_1 = 1, c_2 = 3, c_3 = 3, c_4 = 1$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/87qvldwc.png)\n:::\n\n当给定小郑访问顶点时经过各条边的次数所构成的序列 $c = (c_1, c_2, \\ldots, c_{N-1})$ 时，请编写一个程序，根据此序列求出小郑的访问顺序 $p_1, p_2, \\ldots, p_N$。\n\n给定的序列 $c$ 总是由某个访问顺序生成的，因此满足条件的访问顺序总是存在的。如果存在多个可能的访问顺序，输出任意一个即可。", "inputFormat": "第一行给定顶点的数量 $N$。\n\n第二行给定 $N-1$ 个整数 $c_1, c_2, \\ldots, c_{N-1}$，以空格分隔。此时，$c_i$ 表示经过顶点 $i$ 和 $i+1$ 之间边的次数。\n", "outputFormat": "输出小郑的可能访问顺序 $p_1, p_2, \\ldots, p_N$，以空格分隔。如果存在多个可能的访问顺序，输出任意一个即可。", "hint": "### 限制条件\n\n*   所有给定的数都是整数。\n*   $2 \\le N \\le 200\\,000$\n*   对于所有满足 $1 \\le i \\le N-1$ 的 $i$，有 $1 \\le c_i \\le 10^{18}$。\n*   输入保证存在可能的访问顺序。\n\n### 子任务\n\n1.  (10 分) $N \\le 10$。\n2.  (10 分) 对于所有满足 $1 \\le i \\le N-1$ 的 $i$，有 $c_i \\le 3$。\n3.  (15 分) $N \\ge 4$，且存在一个整数 $M$ ($2 \\le M \\le N-2$)，使得 $c_1 \\le c_2 \\le \\cdots \\le c_M$ 并且 $c_M \\ge c_{M+1} \\ge \\cdots \\ge c_{N-1}$。换句话说，$c_i$ 的序列呈现先单调递增后单调递减的形态。\n4.  (35 分) $N \\le 300$。\n5.  (30 分) 无额外限制条件。", "locale": "zh-CN"}}}
{"pid": "P13525", "type": "P", "difficulty": 5, "samples": [["5\n1\n1 2\n2\n1 4\n2 3\n3\n1 6\n2 5\n3 4\n3\n1 6\n2 3\n4 5\n4\n1 8\n5 6\n2 7\n3 4", "0\n1\n2\n1\n6"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "树形 DP", "容斥原理", "KOI（韩国）"], "title": "[KOI 2025 #2] 新的情缘", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "$N$ 对已经分手的伴侣为了寻找新的情缘而聚集在一起。每对伴侣由 1 名男性和 1 名女性组成，这 $N$ 对伴侣总共由 $N$ 名不同的男性和 $N$ 名不同的女性构成。他们分别坐在编号从 1 到 $2N$ 的 $2N$ 张椅子上，并满足以下条件。\n\n*   没有两个人坐在同一张椅子上。也就是说，每张椅子上恰好只坐了 1 个人。\n*   第 $i$ 对分手的伴侣中，男性坐在 $L_i$ 号椅子上，女性坐在 $R_i$ 号椅子上。($1 \\le i \\le N$)\n*   $1 \\le L_i < R_i \\le 2N(1 \\le i \\le N)$\n*   不存在满足 $L_i < L_j < R_i < R_j$ 的情况。($1 \\le i, j \\le N$)\n\n他们计划组成 $N$ 对满足以下条件的新伴侣。\n\n*   新伴侣必须由 1 名男性和 1 名女性组成，并且每个人都必须恰好属于 1 对新伴侣。\n*   每个人都必须与不是自己原配的人配对。\n*   对于任意一对新伴侣，如果男性所坐椅子的编号为 $l$，女性所坐椅子的编号为 $r$，则必须满足 $l < r$。\n\n例如，我们来考虑 $N=3$ 且 $L_1=1, R_1=6, L_2=2, R_2=3, L_3=4, R_3=5$ 的情况。坐在 1 号椅子的男性和坐在 6 号椅子的女性是已经分手的伴侣，因此不能成为新伴侣。坐在 4 号椅子的男性和坐在 3 号椅子的女性虽然不是分手的伴侣，但由于男性所坐椅子的编号更大，因此也不能成为新伴侣。\n\n反之，坐在 1 号椅子的男性和坐在 3 号椅子的女性可以成为新伴侣。坐在 2 号椅子的男性和坐在 5 号椅子的女性，以及坐在 4 号椅子的男性和坐在 6 号椅子的女性，也都可以成为新伴侣。通过这种方式，可以组成满足条件的 3 对新伴侣。\n\n你需要计算组成 $N$ 对新伴侣的不同方法的总数。两种组成 $N$ 对新伴侣的方法被认为是不同的，是指存在一对新伴侣，它只在其中一种方法中出现。\n\n对于上面给出的例子，可以证明组成 3 对伴侣的方法是唯一的。因此，这种情况的答案是 1。\n\n方法的数量可能非常大，请输出其对 $10^9 + 7$ 取模后的余数。\n\n在一次输入中，你需要解决 $T$ 个测试用例。", "inputFormat": "第一行给定测试用例的数量 $T$。\n\n从第二行开始，依次是 $T$ 个测试用例。每个测试用例由 $N+1$ 行组成。\n\n每个测试用例的第一行给定 $N$。\n\n对于每个测试用例，接下来的 $N$ 行中的第 $i$ 行 ($1 \\le i \\le N$) 给定 $L_i$ 和 $R_i$，以空格分隔。", "outputFormat": "对于每个测试用例，输出一行答案。", "hint": "### 限制条件\n\n*   所有给定的数都是整数。\n*   $1 \\le T \\le 100$\n*   $1 \\le N \\le 3\\,000$\n*   如果将所有测试用例的 $N$ 的总和记为 $S$，则 $1 \\le S \\le 3\\,000$。\n*   $1 \\le L_i < R_i \\le 2N(1 \\le i \\le N)$\n*   $L_1, L_2, \\cdots, L_N, R_1, R_2, \\cdots, R_N$ 互不相同。\n*   不存在满足 $L_i < L_j < R_i < R_j$ 的情况。($1 \\le i, j \\le N$)\n\n### 子任务\n\n1.  (11 分) $N \\le 8, S \\le 800$。\n2.  (32 分) $N \\le 16, S \\le 1\\,600$。\n3.  (20 分) $N \\le 100, S \\le 2\\,000$，且不存在满足 $L_i < L_j < R_j < L_k < R_k < R_i$ 的情况 ($1 \\le i, j, k \\le N$)。\n4.  (27 分) $N \\le 100, S \\le 2\\,000$。\n5.  (10 分) 无额外限制条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2025 #2] 新的情缘", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "$N$ 对已经分手的伴侣为了寻找新的情缘而聚集在一起。每对伴侣由 1 名男性和 1 名女性组成，这 $N$ 对伴侣总共由 $N$ 名不同的男性和 $N$ 名不同的女性构成。他们分别坐在编号从 1 到 $2N$ 的 $2N$ 张椅子上，并满足以下条件。\n\n*   没有两个人坐在同一张椅子上。也就是说，每张椅子上恰好只坐了 1 个人。\n*   第 $i$ 对分手的伴侣中，男性坐在 $L_i$ 号椅子上，女性坐在 $R_i$ 号椅子上。($1 \\le i \\le N$)\n*   $1 \\le L_i < R_i \\le 2N(1 \\le i \\le N)$\n*   不存在满足 $L_i < L_j < R_i < R_j$ 的情况。($1 \\le i, j \\le N$)\n\n他们计划组成 $N$ 对满足以下条件的新伴侣。\n\n*   新伴侣必须由 1 名男性和 1 名女性组成，并且每个人都必须恰好属于 1 对新伴侣。\n*   每个人都必须与不是自己原配的人配对。\n*   对于任意一对新伴侣，如果男性所坐椅子的编号为 $l$，女性所坐椅子的编号为 $r$，则必须满足 $l < r$。\n\n例如，我们来考虑 $N=3$ 且 $L_1=1, R_1=6, L_2=2, R_2=3, L_3=4, R_3=5$ 的情况。坐在 1 号椅子的男性和坐在 6 号椅子的女性是已经分手的伴侣，因此不能成为新伴侣。坐在 4 号椅子的男性和坐在 3 号椅子的女性虽然不是分手的伴侣，但由于男性所坐椅子的编号更大，因此也不能成为新伴侣。\n\n反之，坐在 1 号椅子的男性和坐在 3 号椅子的女性可以成为新伴侣。坐在 2 号椅子的男性和坐在 5 号椅子的女性，以及坐在 4 号椅子的男性和坐在 6 号椅子的女性，也都可以成为新伴侣。通过这种方式，可以组成满足条件的 3 对新伴侣。\n\n你需要计算组成 $N$ 对新伴侣的不同方法的总数。两种组成 $N$ 对新伴侣的方法被认为是不同的，是指存在一对新伴侣，它只在其中一种方法中出现。\n\n对于上面给出的例子，可以证明组成 3 对伴侣的方法是唯一的。因此，这种情况的答案是 1。\n\n方法的数量可能非常大，请输出其对 $10^9 + 7$ 取模后的余数。\n\n在一次输入中，你需要解决 $T$ 个测试用例。", "inputFormat": "第一行给定测试用例的数量 $T$。\n\n从第二行开始，依次是 $T$ 个测试用例。每个测试用例由 $N+1$ 行组成。\n\n每个测试用例的第一行给定 $N$。\n\n对于每个测试用例，接下来的 $N$ 行中的第 $i$ 行 ($1 \\le i \\le N$) 给定 $L_i$ 和 $R_i$，以空格分隔。", "outputFormat": "对于每个测试用例，输出一行答案。", "hint": "### 限制条件\n\n*   所有给定的数都是整数。\n*   $1 \\le T \\le 100$\n*   $1 \\le N \\le 3\\,000$\n*   如果将所有测试用例的 $N$ 的总和记为 $S$，则 $1 \\le S \\le 3\\,000$。\n*   $1 \\le L_i < R_i \\le 2N(1 \\le i \\le N)$\n*   $L_1, L_2, \\cdots, L_N, R_1, R_2, \\cdots, R_N$ 互不相同。\n*   不存在满足 $L_i < L_j < R_i < R_j$ 的情况。($1 \\le i, j \\le N$)\n\n### 子任务\n\n1.  (11 分) $N \\le 8, S \\le 800$。\n2.  (32 分) $N \\le 16, S \\le 1\\,600$。\n3.  (20 分) $N \\le 100, S \\le 2\\,000$，且不存在满足 $L_i < L_j < R_j < L_k < R_k < R_i$ 的情况 ($1 \\le i, j, k \\le N$)。\n4.  (27 分) $N \\le 100, S \\le 2\\,000$。\n5.  (10 分) 无额外限制条件。", "locale": "zh-CN"}}}
{"pid": "P13526", "type": "P", "difficulty": 7, "samples": [["7 2\n1 5\n1 5\n2 2\n2 2\n3 2\n3 2", "10\n4\n4\n0\n0\n0\n0"], ["7 3\n1 5\n1 5\n2 2\n2 2\n3 2\n3 2", "14\n4\n4\n0\n0\n0\n0"], ["7 3\n1 5\n1 5\n2 3\n2 3\n3 3\n3 3", "17\n6\n6\n0\n0\n0\n0"], ["20 4\n1 1\n1 2\n2 4\n3 0\n4 7\n6 2\n4 10\n2 9\n4 2\n2 5\n8 1\n6 1\n11 5\n5 9\n1 1\n16 6\n7 10\n6 3\n8 7", "78\n60\n9\n41\n9\n16\n10\n8\n0\n0\n5\n0\n0\n0\n0\n6\n0\n0\n0\n0"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2025", "动态规划优化", "KOI（韩国）"], "title": "[KOI 2025 #2] 庆典", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "KOI 国由 $N$ 个城市组成，各城市分别编号为 $1, 2, \\dots, N$。1 号城市是 KOI 国的首都。\n\nKOI 国有 $N-1$ 条双向道路。对于所有满足 $2 \\le i \\le N$ 的 $i$，$i$ 号城市都与 $P_i$ 号城市通过一条双向道路相连。此时，满足 $P_i < i$，且连接 $i$ 号城市和 $P_i$ 号城市的道路的每日通行费是 $W_i$。\n\n如果 $u$ 号城市位于从 1 号城市（首都）到 $v$ 号城市的简单路径上，我们定义为 $u$ 号城市**管制** $v$ 号城市。$i$ 号城市的**管辖区域**被定义为 $i$ 号城市所管制的所有城市的集合。因此，1 号城市的管辖区域是所有城市，并且对于所有 $1 \\le i \\le N$，$i$ 号城市本身也属于其管辖区域。如果将 KOI 国的道路网看作一个以 1 号城市为根的树形结构，那么 $i$ 号城市的管辖区域就与以 $i$ 号城市为根的子树相对应。\n\nKOI 国的各个城市计划举办庆典。平时所有道路的通行费都是免费的，但在庆典期间，为了分担举办庆典的费用，计划对部分道路征收通行费。\n\n如果在 $i$ 号城市举办庆典，可以选择一部分道路来征收通行费。单日通行费收入是所有征收通行费的道路的每日通行费之和。为了减少民众的不满，选择的道路必须满足以下两个条件：\n\n*   在 KOI 国内任意两个城市之间的简单路径上，征收通行费的道路数量必须不多于 $K$ 条。\n*   征收通行费的道路，其两端点城市都必须位于 $i$ 号城市的管辖区域内。\n\n请你编写一个程序，对于所有 $1 \\le i \\le N$ 的 $i$，分别计算当庆典在 $i$ 号城市举办时，能够获得的最大单日通行费收入。", "inputFormat": "第一行给定 $N$ 和 $K$，以空格分隔。\n\n之后 $N-1$ 行。第 $i-1(2 \\le i \\le N)$ 行给定 $P_i$ 和 $W_i$，以空格分隔。", "outputFormat": "总共输出 $N$ 行。第 $i(1 \\le i \\le N)$ 行输出在 $i$ 号城市举办庆典时的最大单日通行费收入。", "hint": "### 限制条件\n\n*   所有给定的数都是整数。\n*   $1 \\le K < N \\le 300\\,000$\n*   对于所有 $2 \\le i \\le N$，满足 $1 \\le P_i < i$。\n*   对于所有 $2 \\le i \\le N$，满足 $0 \\le W_i \\le 10^9$。\n\n### 子任务\n\n1.  (4 分) $N \\le 3\\,000$。\n2.  (5 分) 与三个或更多道路相连的城市最多只有一个。\n3.  (11 分) 设连接 1 号城市和 $N$ 号城市的简单路径为 $T$。对于所有城市，最多经过 10 条道路即可移动到路径 $T$ 上的某个城市。\n4.  (13 分) $N \\le 100\\,000$，且对于所有 $2 \\le i \\le N$，满足 $W_i = 1$。\n5.  (8 分) 对于所有 $2 \\le i \\le N$，满足 $W_i = 1$。\n6.  (17 分) $N \\le 100\\,000$，且对于所有 $2 \\le i \\le N$，$W_i$ 的值等于 $i$ 号城市管辖区域内所含城市的数量。\n7.  (10 分) 对于所有 $2 \\le i \\le N$，$W_i$ 的值等于 $i$ 号城市管辖区域内所含城市的数量。\n8.  (15 分) $N \\le 100\\,000$。\n9.  (17 分) 无额外限制条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2025 #2] 庆典", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "KOI 国由 $N$ 个城市组成，各城市分别编号为 $1, 2, \\dots, N$。1 号城市是 KOI 国的首都。\n\nKOI 国有 $N-1$ 条双向道路。对于所有满足 $2 \\le i \\le N$ 的 $i$，$i$ 号城市都与 $P_i$ 号城市通过一条双向道路相连。此时，满足 $P_i < i$，且连接 $i$ 号城市和 $P_i$ 号城市的道路的每日通行费是 $W_i$。\n\n如果 $u$ 号城市位于从 1 号城市（首都）到 $v$ 号城市的简单路径上，我们定义为 $u$ 号城市**管制** $v$ 号城市。$i$ 号城市的**管辖区域**被定义为 $i$ 号城市所管制的所有城市的集合。因此，1 号城市的管辖区域是所有城市，并且对于所有 $1 \\le i \\le N$，$i$ 号城市本身也属于其管辖区域。如果将 KOI 国的道路网看作一个以 1 号城市为根的树形结构，那么 $i$ 号城市的管辖区域就与以 $i$ 号城市为根的子树相对应。\n\nKOI 国的各个城市计划举办庆典。平时所有道路的通行费都是免费的，但在庆典期间，为了分担举办庆典的费用，计划对部分道路征收通行费。\n\n如果在 $i$ 号城市举办庆典，可以选择一部分道路来征收通行费。单日通行费收入是所有征收通行费的道路的每日通行费之和。为了减少民众的不满，选择的道路必须满足以下两个条件：\n\n*   在 KOI 国内任意两个城市之间的简单路径上，征收通行费的道路数量必须不多于 $K$ 条。\n*   征收通行费的道路，其两端点城市都必须位于 $i$ 号城市的管辖区域内。\n\n请你编写一个程序，对于所有 $1 \\le i \\le N$ 的 $i$，分别计算当庆典在 $i$ 号城市举办时，能够获得的最大单日通行费收入。", "inputFormat": "第一行给定 $N$ 和 $K$，以空格分隔。\n\n之后 $N-1$ 行。第 $i-1(2 \\le i \\le N)$ 行给定 $P_i$ 和 $W_i$，以空格分隔。", "outputFormat": "总共输出 $N$ 行。第 $i(1 \\le i \\le N)$ 行输出在 $i$ 号城市举办庆典时的最大单日通行费收入。", "hint": "### 限制条件\n\n*   所有给定的数都是整数。\n*   $1 \\le K < N \\le 300\\,000$\n*   对于所有 $2 \\le i \\le N$，满足 $1 \\le P_i < i$。\n*   对于所有 $2 \\le i \\le N$，满足 $0 \\le W_i \\le 10^9$。\n\n### 子任务\n\n1.  (4 分) $N \\le 3\\,000$。\n2.  (5 分) 与三个或更多道路相连的城市最多只有一个。\n3.  (11 分) 设连接 1 号城市和 $N$ 号城市的简单路径为 $T$。对于所有城市，最多经过 10 条道路即可移动到路径 $T$ 上的某个城市。\n4.  (13 分) $N \\le 100\\,000$，且对于所有 $2 \\le i \\le N$，满足 $W_i = 1$。\n5.  (8 分) 对于所有 $2 \\le i \\le N$，满足 $W_i = 1$。\n6.  (17 分) $N \\le 100\\,000$，且对于所有 $2 \\le i \\le N$，$W_i$ 的值等于 $i$ 号城市管辖区域内所含城市的数量。\n7.  (10 分) 对于所有 $2 \\le i \\le N$，$W_i$ 的值等于 $i$ 号城市管辖区域内所含城市的数量。\n8.  (15 分) $N \\le 100\\,000$。\n9.  (17 分) 无额外限制条件。", "locale": "zh-CN"}}}
{"pid": "P13527", "type": "P", "difficulty": 6, "samples": [["1 2\n5", "0.8"], ["2 6\n5 10", "0.72"], ["2 7\n4 4", "0.875"], ["2 3\n4 5", "0.75"], ["4 444\n57 179 239 2", "0.97557326850704739751"], ["2 5\n2 2", "0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2023", "Special Judge", "Moscow Olympiad"], "title": "[OOI 2023] Another n-dimensional chocolate bar / n 维巧克力问题", "background": "CF1801F", "description": "妈妈给小男孩瓦夏买了一块 $n$ 维巧克力，这块巧克力是一个 $n$ 维立方体，每条边的长度都是 $1$。这块巧克力已经被标出了分割线。在第 $i$ 个维度上，可以用超平面将巧克力沿该维度分成 $a_i$ 份相等的小块。因此，巧克力总共被分成 $a_1 \\cdot a_2 \\cdot a_3 \\cdot \\ldots \\cdot a_n$ 块，每一小块在第 $i$ 个维度上的长度都是 $\\frac{1}{a_i}$，因此每一小块的体积为 $\\frac{1}{a_1 a_2 \\cdots a_n}$。\n\n瓦夏和他的朋友们想要把巧克力切成至少 $k$ 块，并且希望最小的那一块的体积尽可能大。巧克力只能在原本小块的连接处切割，每一次切割都必须是沿着参与形成小块的某个超平面，且每次切割都要贯穿整个巧克力。所有切割都完成后，瓦夏才将巧克力分成小块。\n\n更正式地说，瓦夏需要选择 $b_1, b_2, \\dots, b_n$ 这 $n$ 个数（$1 \\le b_i \\le a_i$），表示在第 $i$ 个维度上将巧克力切成 $b_i$ 份。需要满足 $b_1 \\cdot b_2 \\cdot \\ldots \\cdot b_n \\ge k$，这样切割后才能得到不少于 $k$ 块巧克力。可以注意到，在最优切割方案下，最小的一块包含 $\\lfloor \\frac{a_1}{b_1} \\rfloor \\dotsm \\lfloor \\frac{a_n}{b_n} \\rfloor$ 个小块，其体积为 $\\lfloor \\frac{a_1}{b_1} \\rfloor \\dotsm \\lfloor \\frac{a_n}{b_n} \\rfloor \\cdot \\frac{1}{a_1 a_2 \\cdots a_n}$。\n\n瓦夏希望得到的答案是：最小一块体积的最大可能值乘以 $k$，也就是最大化 $\\lfloor \\frac{a_1}{b_1} \\rfloor \\dotsm \\lfloor \\frac{a_n}{b_n} \\rfloor \\cdot \\frac{1}{a_1 a_2 \\cdots a_n} \\cdot k$。请你帮他实现这个目标。\n", "inputFormat": "第一行包含两个整数 $n$ 和 $k$（$1 \\le n \\le 100$，$1 \\le k \\le 10^7$），分别表示巧克力的维度和需要分成的块数。\n\n第二行包含 $n$ 个整数 $a_1,\\ a_2,\\ \\dots,\\ a_n$（$1 \\le a_i \\le 10^7$），表示在每个维度上巧克力被分成的小块数。\n", "outputFormat": "输出一个数，表示最大可能的“最小块体积乘以 $k$”，结果的绝对或相对误差不超过 $10^{-9}$。\n\n如果在给定限制下无法将巧克力分成至少 $k$ 块，输出 $0$。\n", "hint": "### 样例解释\n\n在第一个样例中，一维的巧克力可以这样切割：\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/4yyiz7gv.png)\n:::\n\n此时答案为 $\\frac{2}{5} \\cdot 2 = 0.8$。\n\n在第二个样例中，巧克力可以这样切割：\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mj5ryu3a.png)\n:::\n\n此时答案为 $\\frac{2}{5} \\cdot \\frac{3}{10} \\cdot 6 = 0.72$。\n\n在第三个样例中，巧克力可以这样切割：\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/nnpu0bhr.png)\n:::\n\n此时答案为 $\\frac{2}{4} \\cdot \\frac{1}{4} \\cdot 7 = 0.875$。\n\n### 评分说明\n\n本题的测试数据分为 8 组。只有通过某一组的全部测试点，且通过部分之前组的全部测试点后，才能获得该组的分数。注意，有些分组不需要通过样例中的测试点。“离线评测”表示该组的测试结果只会在比赛结束后公布。\n\n| 组别 | 分值 | $n$ | $k$ | $a_i$ | 必须通过的组 | 备注 |\n|:----:|:----:|:---:|:---:|:-----:|:------------:|:----:|\n| 0    | 0    | --  | --  | --    | --           | 样例测试点 |\n| 1    | 10   | $n \\le 2$ | -- | -- | -- |  |\n| 2    | 12   | --  | $k \\le 500$ | $a_i \\le 500$ | 0 |  |\n| 3    | 13   | --  | $k \\le 20\\,000$ | $a_i \\le 2000$ | 0, 2 |  |\n| 4    | 12   | --  | $k \\le 40\\,000$ | -- | 0, 2, 3 |  |\n| 5    | 10   | --  | $k \\le 200\\,000$ | -- | 0, 2, 3, 4 |  |\n| 6    | 11   | --  | $k \\le 4 \\cdot 10^6$ | $a_i \\le 2000$ | 0, 2, 3 |  |\n| 7    | 15   | --  | $k \\le 5 \\cdot 10^6$ | -- | 0, 2 -- 6 |  |\n| 8    | 17   | --  | --  | --    | 0 -- 7        | **离线评测** |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[OOI 2023] Another n-dimensional chocolate bar / n 维巧克力问题", "background": "CF1801F", "description": "妈妈给小男孩瓦夏买了一块 $n$ 维巧克力，这块巧克力是一个 $n$ 维立方体，每条边的长度都是 $1$。这块巧克力已经被标出了分割线。在第 $i$ 个维度上，可以用超平面将巧克力沿该维度分成 $a_i$ 份相等的小块。因此，巧克力总共被分成 $a_1 \\cdot a_2 \\cdot a_3 \\cdot \\ldots \\cdot a_n$ 块，每一小块在第 $i$ 个维度上的长度都是 $\\frac{1}{a_i}$，因此每一小块的体积为 $\\frac{1}{a_1 a_2 \\cdots a_n}$。\n\n瓦夏和他的朋友们想要把巧克力切成至少 $k$ 块，并且希望最小的那一块的体积尽可能大。巧克力只能在原本小块的连接处切割，每一次切割都必须是沿着参与形成小块的某个超平面，且每次切割都要贯穿整个巧克力。所有切割都完成后，瓦夏才将巧克力分成小块。\n\n更正式地说，瓦夏需要选择 $b_1, b_2, \\dots, b_n$ 这 $n$ 个数（$1 \\le b_i \\le a_i$），表示在第 $i$ 个维度上将巧克力切成 $b_i$ 份。需要满足 $b_1 \\cdot b_2 \\cdot \\ldots \\cdot b_n \\ge k$，这样切割后才能得到不少于 $k$ 块巧克力。可以注意到，在最优切割方案下，最小的一块包含 $\\lfloor \\frac{a_1}{b_1} \\rfloor \\dotsm \\lfloor \\frac{a_n}{b_n} \\rfloor$ 个小块，其体积为 $\\lfloor \\frac{a_1}{b_1} \\rfloor \\dotsm \\lfloor \\frac{a_n}{b_n} \\rfloor \\cdot \\frac{1}{a_1 a_2 \\cdots a_n}$。\n\n瓦夏希望得到的答案是：最小一块体积的最大可能值乘以 $k$，也就是最大化 $\\lfloor \\frac{a_1}{b_1} \\rfloor \\dotsm \\lfloor \\frac{a_n}{b_n} \\rfloor \\cdot \\frac{1}{a_1 a_2 \\cdots a_n} \\cdot k$。请你帮他实现这个目标。\n", "inputFormat": "第一行包含两个整数 $n$ 和 $k$（$1 \\le n \\le 100$，$1 \\le k \\le 10^7$），分别表示巧克力的维度和需要分成的块数。\n\n第二行包含 $n$ 个整数 $a_1,\\ a_2,\\ \\dots,\\ a_n$（$1 \\le a_i \\le 10^7$），表示在每个维度上巧克力被分成的小块数。\n", "outputFormat": "输出一个数，表示最大可能的“最小块体积乘以 $k$”，结果的绝对或相对误差不超过 $10^{-9}$。\n\n如果在给定限制下无法将巧克力分成至少 $k$ 块，输出 $0$。\n", "hint": "### 样例解释\n\n在第一个样例中，一维的巧克力可以这样切割：\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/4yyiz7gv.png)\n:::\n\n此时答案为 $\\frac{2}{5} \\cdot 2 = 0.8$。\n\n在第二个样例中，巧克力可以这样切割：\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mj5ryu3a.png)\n:::\n\n此时答案为 $\\frac{2}{5} \\cdot \\frac{3}{10} \\cdot 6 = 0.72$。\n\n在第三个样例中，巧克力可以这样切割：\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/nnpu0bhr.png)\n:::\n\n此时答案为 $\\frac{2}{4} \\cdot \\frac{1}{4} \\cdot 7 = 0.875$。\n\n### 评分说明\n\n本题的测试数据分为 8 组。只有通过某一组的全部测试点，且通过部分之前组的全部测试点后，才能获得该组的分数。注意，有些分组不需要通过样例中的测试点。“离线评测”表示该组的测试结果只会在比赛结束后公布。\n\n| 组别 | 分值 | $n$ | $k$ | $a_i$ | 必须通过的组 | 备注 |\n|:----:|:----:|:---:|:---:|:-----:|:------------:|:----:|\n| 0    | 0    | --  | --  | --    | --           | 样例测试点 |\n| 1    | 10   | $n \\le 2$ | -- | -- | -- |  |\n| 2    | 12   | --  | $k \\le 500$ | $a_i \\le 500$ | 0 |  |\n| 3    | 13   | --  | $k \\le 20\\,000$ | $a_i \\le 2000$ | 0, 2 |  |\n| 4    | 12   | --  | $k \\le 40\\,000$ | -- | 0, 2, 3 |  |\n| 5    | 10   | --  | $k \\le 200\\,000$ | -- | 0, 2, 3, 4 |  |\n| 6    | 11   | --  | $k \\le 4 \\cdot 10^6$ | $a_i \\le 2000$ | 0, 2, 3 |  |\n| 7    | 15   | --  | $k \\le 5 \\cdot 10^6$ | -- | 0, 2 -- 6 |  |\n| 8    | 17   | --  | --  | --    | 0 -- 7        | **离线评测** |", "locale": "zh-CN"}}}
{"pid": "P13528", "type": "P", "difficulty": 7, "samples": [["5\n1 1 2 2\n2 4\n1 3\n1 3\n2 4\n4 4\n4\n1 1 2 2\n1 2 2 1\n3 4 4 3\n3 4 3 5", "18\n18\n4\n0"], ["8\n1 2 3 4 5 8 6\n3 7\n2 6\n3 8\n5 10\n5 8\n2 9\n3 8\n6 8\n4\n1 3 7 6\n4 1 5 7\n1 7 7 1\n1 8 2 7", "720\n120\n120\n1\n"]], "limits": {"time": [3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "倍增", "二分", "并查集", "2023", "树链剖分", "哈希 hashing", "Moscow Olympiad"], "title": "[OOI 2023] Gasoline prices / 油价", "background": "CF1801E", "description": "伯利兰是一个由 $n$ 个城市组成的庞大国家。伯利兰的公路网络可以被看作是一棵有根树，也就是说全国一共有 $n - 1$ 条道路，并且任意两个城市之间都恰好有一条路径相连，且不会重复经过同一个城市。为了方便表示，每个城市 $i$ 都有一个固定的城市 $p_i$，它表示从城市 $i$ 出发前往城市 $1$ 时，首先要到达的城市。换句话说，如果将树的根设为城市 $1$，那么 $p_i$ 就是城市 $i$ 的父节点。\n\n每个城市都有一个加油站。每个加油站的油价都有一个固定的区间，在这个区间内可以选择任意一个价格。城市 $i$ 的加油站油价可以是 $l_i$ 到 $r_i$ 之间的任意整数（包括两端）。\n\n伯利兰的国王是个顾家的好父亲，他连续 $m$ 年每年都迎来了两位儿子的出生。国王的孩子们从小就参与国家事务，每年年末，他们会检查油价是否公平。自出生起，第 $i$ 年出生的两个孩子分别负责检查从城市 $a_i$ 到城市 $b_i$ 的路径，以及从城市 $c_i$ 到城市 $d_i$ 的路径上的油价。\n\n检查的方式如下：两个孩子分别同时从城市 $a_i$ 和 $c_i$ 出发。第一个孩子沿着从 $a_i$ 到 $b_i$ 的路径前进，第二个孩子则沿着从 $c_i$ 到 $d_i$ 的路径前进。他们会依次检查：起点 $a_i$ 和 $c_i$ 的油价是否相同，然后检查路径上的第二个城市是否油价相同，依此类推，直到终点 $b_i$ 和 $d_i$ 的油价也要一致。保证从 $a_i$ 到 $b_i$ 的路径长度和从 $c_i$ 到 $d_i$ 的路径长度相同。\n\n所有加油站都必须严格遵守法律，因此所有的油价检查都不能出现违规。请你帮助伯利兰的加油站计算，在 $m$ 年内，他们有多少种合法的油价设置方式。换句话说，对于每个 $i$ 从 $1$ 到 $m$，请计算在前 $i$ 年出生的所有王子进行检查后，所有检查都不出现违规，且每个加油站的油价在允许区间内的情况下，总共有多少种油价分配方案。由于答案可能很大，请对 $10^9 + 7$ 取模输出。\n", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 200\\,000$），表示伯利兰的城市数量。\n\n第二行包含 $n-1$ 个整数 $p_2,\\ p_3,\\ \\ldots,\\ p_n$（$1 \\le p_i \\le n$），其中 $p_i$ 表示从城市 $i$ 前往城市 $1$ 时的下一个城市编号。\n\n接下来的 $n$ 行，每行两个整数 $l_i$ 和 $r_i$（$1 \\le l_i \\le r_i < 10^9+7$），表示第 $i$ 个城市加油站允许的油价区间。\n\n再下一行包含一个整数 $m$（$1 \\le m \\le 200\\,000$），表示国王有多少年每年出生两位儿子。\n\n接下来的 $m$ 行，每行四个整数 $a_i, b_i, c_i, d_i$（$1 \\le a_i, b_i, c_i, d_i \\le n$），表示第 $i$ 年出生的两位王子分别要检查的两条路径。保证 $a_i$ 到 $b_i$ 的路径长度等于 $c_i$ 到 $d_i$ 的路径长度。\n", "outputFormat": "输出 $m$ 行，每行一个整数。第 $i$ 行表示在前 $i$ 年出生的所有王子进行检查后，所有检查都不出现违规，且每个加油站油价在允许区间内的情况下，总共有多少种油价分配方案。结果对 $10^9 + 7$ 取模。\n", "hint": "### 样例解释\n\n以第一个样例为例：\n\n- 在头两位王子出生后，城市 $1$ 和城市 $2$ 的油价必须相同。可以在允许的区间内为城市 $1$ 和 $2$ 选择相同的油价方式有 $2$ 种。剩下城市 $3$ 和 $4$ 的油价分别有 $3$ 种和 $3$ 种选择。总方案数为 $2 \\times 3 \\times 3 \\times 1 = 18$。\n- 第二对王子检查的是 $1-2$ 和 $2-1$，这要求城市 $1$ 和 $2$ 的油价一致，这个条件已经满足，因此方案数不变。\n- 第三对王子检查的是 $3-1-2-4$ 和 $4-2-1-3$，这要求城市 $3$ 和 $4$ 的油价相同，城市 $1$ 和 $2$ 的油价也要相同。城市 $1$ 和 $2$ 已经一致，而城市 $3$ 和 $4$ 可以有 $2$ 种相同的油价选择。总方案数为 $2 \\times 2 \\times 1 = 6$。\n- 第四对王子检查的是 $3-1-2-4$ 和 $3-1-2-5$，这要求城市 $4$ 和 $5$ 的油价一致，而城市 $3$ 和 $4$ 已经一致，因此 $3$、$4$、$5$ 三个城市的油价都要一致。城市 $3$ 的油价不能超过 $3$，城市 $5$ 的油价不能低于 $4$，因此不存在满足条件的方案，答案为 $0$。\n\n### 评分说明\n\n本题的数据分为 8 组。只有通过某一组全部测试点，且通过部分之前组全部测试点，才能获得该组分数。有些分组不要求通过样例测试点。“离线评测”表示该组的测试结果只会在比赛结束后公布。\n\n| 组别 | 分值 | $n$ | $m$ | 必须通过的组 | 备注 |\n|:----:|:----:|:---:|:---:|:------------:|:----:|\n| 0    | 0    | --  | --  | --           | 样例测试点 |\n| 1    | 12   | $n \\le 300$ | $m \\le 300$ | 0 |  |\n| 2    | 10   | $n \\le 3000$ | $m \\le 3000$ | -- | $p_i = i - 1$ |\n| 3    | 9    | $n \\le 3000$ | $m \\le 3000$ | 0, 1, 2 |  |\n| 4    | 16   | --  | --  | 0 -- 3       | 所有检查路径的总长度不超过 $10^8$ |\n| 5    | 10   | $n \\le 100\\,000$ | $m \\le 100\\,000$ | 2 | $p_i = i - 1$ |\n| 6    | 12   | --  | --  | 2, 5         | $p_i = i - 1$ |\n| 7    | 13   | $n \\le 100\\,000$ | $m \\le 100\\,000$ | 0 -- 3, 5 |  |\n| 8    | 18   | --  | --  | 0 -- 7       | **离线评测** |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[OOI 2023] Gasoline prices / 油价", "background": "CF1801E", "description": "伯利兰是一个由 $n$ 个城市组成的庞大国家。伯利兰的公路网络可以被看作是一棵有根树，也就是说全国一共有 $n - 1$ 条道路，并且任意两个城市之间都恰好有一条路径相连，且不会重复经过同一个城市。为了方便表示，每个城市 $i$ 都有一个固定的城市 $p_i$，它表示从城市 $i$ 出发前往城市 $1$ 时，首先要到达的城市。换句话说，如果将树的根设为城市 $1$，那么 $p_i$ 就是城市 $i$ 的父节点。\n\n每个城市都有一个加油站。每个加油站的油价都有一个固定的区间，在这个区间内可以选择任意一个价格。城市 $i$ 的加油站油价可以是 $l_i$ 到 $r_i$ 之间的任意整数（包括两端）。\n\n伯利兰的国王是个顾家的好父亲，他连续 $m$ 年每年都迎来了两位儿子的出生。国王的孩子们从小就参与国家事务，每年年末，他们会检查油价是否公平。自出生起，第 $i$ 年出生的两个孩子分别负责检查从城市 $a_i$ 到城市 $b_i$ 的路径，以及从城市 $c_i$ 到城市 $d_i$ 的路径上的油价。\n\n检查的方式如下：两个孩子分别同时从城市 $a_i$ 和 $c_i$ 出发。第一个孩子沿着从 $a_i$ 到 $b_i$ 的路径前进，第二个孩子则沿着从 $c_i$ 到 $d_i$ 的路径前进。他们会依次检查：起点 $a_i$ 和 $c_i$ 的油价是否相同，然后检查路径上的第二个城市是否油价相同，依此类推，直到终点 $b_i$ 和 $d_i$ 的油价也要一致。保证从 $a_i$ 到 $b_i$ 的路径长度和从 $c_i$ 到 $d_i$ 的路径长度相同。\n\n所有加油站都必须严格遵守法律，因此所有的油价检查都不能出现违规。请你帮助伯利兰的加油站计算，在 $m$ 年内，他们有多少种合法的油价设置方式。换句话说，对于每个 $i$ 从 $1$ 到 $m$，请计算在前 $i$ 年出生的所有王子进行检查后，所有检查都不出现违规，且每个加油站的油价在允许区间内的情况下，总共有多少种油价分配方案。由于答案可能很大，请对 $10^9 + 7$ 取模输出。\n", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 200\\,000$），表示伯利兰的城市数量。\n\n第二行包含 $n-1$ 个整数 $p_2,\\ p_3,\\ \\ldots,\\ p_n$（$1 \\le p_i \\le n$），其中 $p_i$ 表示从城市 $i$ 前往城市 $1$ 时的下一个城市编号。\n\n接下来的 $n$ 行，每行两个整数 $l_i$ 和 $r_i$（$1 \\le l_i \\le r_i < 10^9+7$），表示第 $i$ 个城市加油站允许的油价区间。\n\n再下一行包含一个整数 $m$（$1 \\le m \\le 200\\,000$），表示国王有多少年每年出生两位儿子。\n\n接下来的 $m$ 行，每行四个整数 $a_i, b_i, c_i, d_i$（$1 \\le a_i, b_i, c_i, d_i \\le n$），表示第 $i$ 年出生的两位王子分别要检查的两条路径。保证 $a_i$ 到 $b_i$ 的路径长度等于 $c_i$ 到 $d_i$ 的路径长度。\n", "outputFormat": "输出 $m$ 行，每行一个整数。第 $i$ 行表示在前 $i$ 年出生的所有王子进行检查后，所有检查都不出现违规，且每个加油站油价在允许区间内的情况下，总共有多少种油价分配方案。结果对 $10^9 + 7$ 取模。\n", "hint": "### 样例解释\n\n以第一个样例为例：\n\n- 在头两位王子出生后，城市 $1$ 和城市 $2$ 的油价必须相同。可以在允许的区间内为城市 $1$ 和 $2$ 选择相同的油价方式有 $2$ 种。剩下城市 $3$ 和 $4$ 的油价分别有 $3$ 种和 $3$ 种选择。总方案数为 $2 \\times 3 \\times 3 \\times 1 = 18$。\n- 第二对王子检查的是 $1-2$ 和 $2-1$，这要求城市 $1$ 和 $2$ 的油价一致，这个条件已经满足，因此方案数不变。\n- 第三对王子检查的是 $3-1-2-4$ 和 $4-2-1-3$，这要求城市 $3$ 和 $4$ 的油价相同，城市 $1$ 和 $2$ 的油价也要相同。城市 $1$ 和 $2$ 已经一致，而城市 $3$ 和 $4$ 可以有 $2$ 种相同的油价选择。总方案数为 $2 \\times 2 \\times 1 = 6$。\n- 第四对王子检查的是 $3-1-2-4$ 和 $3-1-2-5$，这要求城市 $4$ 和 $5$ 的油价一致，而城市 $3$ 和 $4$ 已经一致，因此 $3$、$4$、$5$ 三个城市的油价都要一致。城市 $3$ 的油价不能超过 $3$，城市 $5$ 的油价不能低于 $4$，因此不存在满足条件的方案，答案为 $0$。\n\n### 评分说明\n\n本题的数据分为 8 组。只有通过某一组全部测试点，且通过部分之前组全部测试点，才能获得该组分数。有些分组不要求通过样例测试点。“离线评测”表示该组的测试结果只会在比赛结束后公布。\n\n| 组别 | 分值 | $n$ | $m$ | 必须通过的组 | 备注 |\n|:----:|:----:|:---:|:---:|:------------:|:----:|\n| 0    | 0    | --  | --  | --           | 样例测试点 |\n| 1    | 12   | $n \\le 300$ | $m \\le 300$ | 0 |  |\n| 2    | 10   | $n \\le 3000$ | $m \\le 3000$ | -- | $p_i = i - 1$ |\n| 3    | 9    | $n \\le 3000$ | $m \\le 3000$ | 0, 1, 2 |  |\n| 4    | 16   | --  | --  | 0 -- 3       | 所有检查路径的总长度不超过 $10^8$ |\n| 5    | 10   | $n \\le 100\\,000$ | $m \\le 100\\,000$ | 2 | $p_i = i - 1$ |\n| 6    | 12   | --  | --  | 2, 5         | $p_i = i - 1$ |\n| 7    | 13   | $n \\le 100\\,000$ | $m \\le 100\\,000$ | 0 -- 3, 5 |  |\n| 8    | 18   | --  | --  | 0 -- 7       | **离线评测** |", "locale": "zh-CN"}}}
{"pid": "P13529", "type": "P", "difficulty": 6, "samples": [["5\n1 1\n1 1 0\n1 1\n3 5\n1 2 0\n1 2 1\n1 2 3\n2 3 5\n2 3 2\n1 3\n2 2\n1 2 1\n2 1 2\n1 2\n3 3\n1 2 7\n2 3 0\n3 1 7\n2 3\n4 5\n1 1 0\n1 2 3\n2 2 0\n2 3 1\n3 4 1\n1 4", "0\n7\n-1\n0\n-1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2023", "强连通分量", "Moscow Olympiad"], "title": "[OOI 2023] 皇家任务", "background": "", "description": "不久前，伯利兰新建成了一套公路网络。某些城市对之间有单向道路，第 $i$ 条道路从城市 $u_i$ 通向城市 $v_i$，其长度为 $w_i$。伯利兰有两个主要城市，编号为 $a$ 和 $b$。\n\n伯利兰的国王非常热爱自己的国家，尤其喜欢计算各种有趣的性质。他把一条路径的「美丽度」定义为该路径上所有道路长度的按位异或（即 XOR）。而他把国家的「美丽度」定义为所有从城市 $a$ 到城市 $b$ 的路径的美丽度的按位异或。注意，这些路径可能有无穷多条，而且可以多次经过同一个城市。\n\n国王想知道他的国家的美丽度是多少，所以他请你帮他计算这个值，或者判断无法计算美丽度。\n\n集合中所有数的按位异或指的是集合中所有非零数的按位异或。如果集合中有无穷多个非零数，则无法计算按位异或。\n\n按位异或是一种二元运算，相当于对两个操作数的每一位分别做逻辑异或。如果对应位不同，则该位结果为 $1$；如果相同，则为 $0$。例如，$x = 109_{10} = 1101101_2$，$y = 41_{10} = 101001_2$，则 $x \\oplus y = 1000100_2 = 68_{10}$。\n\n在图中，一条路径指的是一系列顶点，其中任意两个相邻顶点之间都有一条边相连。", "inputFormat": "每个测试包含若干组数据。第一行一个整数 $t$（$1 \\le t \\le 40\\,000$），表示数据组数。\n\n每组数据的第一行包含两个整数 $n$ 和 $m$（$1 \\le n, m \\le 200\\,000$），分别表示城市数和道路数。\n\n接下来 $m$ 行，每行三个整数 $u_i, v_i, w_i$（$1 \\le u_i, v_i \\le n$，$0 \\le w_i \\le 2^{30} - 1$），表示第 $i$ 条道路的起点、终点和长度。\n\n每组数据的最后一行包含两个整数 $a, b$（$1 \\le a, b \\le n$），表示国王关心的起点和终点。\n\n设 $\\sum n$ 表示所有数据组的 $n$ 之和，$\\sum m$ 表示所有数据组的 $m$ 之和。保证 $\\sum n \\le 200\\,000$，$\\sum m \\le 200\\,000$。\n", "outputFormat": "对于每组数据，输出一个整数，表示伯利兰的美丽度。如果无法计算美丽度，则输出 $-1$。\n", "hint": "### 样例解释\n\n- 在第一组数据中，国家只有一条长度为 $0$ 的道路，因此任意路径的美丽度均为 $0$，所有路径的美丽度异或起来也是 $0$。\n- 在第二组数据中，从城市 $1$ 到城市 $3$ 的路径共有 $6$ 条，其美丽度分别为 $0 \\oplus 5 = 5$、$0 \\oplus 2 = 2$、$1 \\oplus 5 = 4$、$1 \\oplus 2 = 3$、$3 \\oplus 5 = 6$、$3 \\oplus 2 = 1$。将它们按位异或后，答案为 $5 \\oplus 2 \\oplus 4 \\oplus 3 \\oplus 6 \\oplus 1 = 7$。\n- 在第三组数据中，从城市 $1$ 到城市 $2$ 的路径有美丽度 $1$、$1 \\oplus 2 \\oplus 1 = 2$、$1 \\oplus 2 \\oplus 1 \\oplus 2 \\oplus 1 = 1$、$1 \\oplus 2 \\oplus 1 \\oplus 2 \\oplus 1 \\oplus 2 \\oplus 1 = 2$，依此类推。可以发现，从 $1$ 到 $2$ 存在无穷多条美丽度不为 $0$ 的路径，因此无法计算答案。\n- 在第四组数据中，从城市 $2$ 到城市 $3$ 有无穷多条美丽度为 $0$ 的路径，但没有任何美丽度非零的路径，因此最终国家美丽度为 $0$。\n\n### 评分说明\n\n本题测试点分为 6 组。只有通过某一组的所有测试点，且通过部分之前组的所有测试点，才能获得该组分数。有些分组不要求通过样例测试点。“离线评测”表示该组的测试结果只会在比赛结束后公布。\n\n| 组别 | 分值 | $\\sum n$ | $\\sum m$ | $w_i$ | 必须通过的组 | 备注 |\n|:----:|:----:|:--------:|:--------:|:-----:|:------------:|:----:|\n| 0    | 0    | --       | --       | --    | --           | 样例测试点 |\n| 1    | 16   | --       | --       | --    | --           | $n = m$，$u_i = i, v_i = i+1$ 对 $i < n$，$u_n = n, v_n = 1$ |\n| 2    | 17   | --       | --       | $w_i \\le 1$ | --    | $u_i < v_i$ |\n| 3    | 15   | --       | --       | --    | 2            | $u_i < v_i$ |\n| 4    | 19   | $\\sum n \\le 1000$ | $\\sum m \\le 1000$ | $w_i \\le 2^{10} - 1$ | 0 |  |\n| 5    | 14   | --       | --       | $w_i \\le 1$ | 2            |  |\n| 6    | 19   | --       | --       | --    | 0--5         | **离线评测** |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[OOI 2023] 皇家任务", "background": "", "description": "不久前，伯利兰新建成了一套公路网络。某些城市对之间有单向道路，第 $i$ 条道路从城市 $u_i$ 通向城市 $v_i$，其长度为 $w_i$。伯利兰有两个主要城市，编号为 $a$ 和 $b$。\n\n伯利兰的国王非常热爱自己的国家，尤其喜欢计算各种有趣的性质。他把一条路径的「美丽度」定义为该路径上所有道路长度的按位异或（即 XOR）。而他把国家的「美丽度」定义为所有从城市 $a$ 到城市 $b$ 的路径的美丽度的按位异或。注意，这些路径可能有无穷多条，而且可以多次经过同一个城市。\n\n国王想知道他的国家的美丽度是多少，所以他请你帮他计算这个值，或者判断无法计算美丽度。\n\n集合中所有数的按位异或指的是集合中所有非零数的按位异或。如果集合中有无穷多个非零数，则无法计算按位异或。\n\n按位异或是一种二元运算，相当于对两个操作数的每一位分别做逻辑异或。如果对应位不同，则该位结果为 $1$；如果相同，则为 $0$。例如，$x = 109_{10} = 1101101_2$，$y = 41_{10} = 101001_2$，则 $x \\oplus y = 1000100_2 = 68_{10}$。\n\n在图中，一条路径指的是一系列顶点，其中任意两个相邻顶点之间都有一条边相连。", "inputFormat": "每个测试包含若干组数据。第一行一个整数 $t$（$1 \\le t \\le 40\\,000$），表示数据组数。\n\n每组数据的第一行包含两个整数 $n$ 和 $m$（$1 \\le n, m \\le 200\\,000$），分别表示城市数和道路数。\n\n接下来 $m$ 行，每行三个整数 $u_i, v_i, w_i$（$1 \\le u_i, v_i \\le n$，$0 \\le w_i \\le 2^{30} - 1$），表示第 $i$ 条道路的起点、终点和长度。\n\n每组数据的最后一行包含两个整数 $a, b$（$1 \\le a, b \\le n$），表示国王关心的起点和终点。\n\n设 $\\sum n$ 表示所有数据组的 $n$ 之和，$\\sum m$ 表示所有数据组的 $m$ 之和。保证 $\\sum n \\le 200\\,000$，$\\sum m \\le 200\\,000$。\n", "outputFormat": "对于每组数据，输出一个整数，表示伯利兰的美丽度。如果无法计算美丽度，则输出 $-1$。\n", "hint": "### 样例解释\n\n- 在第一组数据中，国家只有一条长度为 $0$ 的道路，因此任意路径的美丽度均为 $0$，所有路径的美丽度异或起来也是 $0$。\n- 在第二组数据中，从城市 $1$ 到城市 $3$ 的路径共有 $6$ 条，其美丽度分别为 $0 \\oplus 5 = 5$、$0 \\oplus 2 = 2$、$1 \\oplus 5 = 4$、$1 \\oplus 2 = 3$、$3 \\oplus 5 = 6$、$3 \\oplus 2 = 1$。将它们按位异或后，答案为 $5 \\oplus 2 \\oplus 4 \\oplus 3 \\oplus 6 \\oplus 1 = 7$。\n- 在第三组数据中，从城市 $1$ 到城市 $2$ 的路径有美丽度 $1$、$1 \\oplus 2 \\oplus 1 = 2$、$1 \\oplus 2 \\oplus 1 \\oplus 2 \\oplus 1 = 1$、$1 \\oplus 2 \\oplus 1 \\oplus 2 \\oplus 1 \\oplus 2 \\oplus 1 = 2$，依此类推。可以发现，从 $1$ 到 $2$ 存在无穷多条美丽度不为 $0$ 的路径，因此无法计算答案。\n- 在第四组数据中，从城市 $2$ 到城市 $3$ 有无穷多条美丽度为 $0$ 的路径，但没有任何美丽度非零的路径，因此最终国家美丽度为 $0$。\n\n### 评分说明\n\n本题测试点分为 6 组。只有通过某一组的所有测试点，且通过部分之前组的所有测试点，才能获得该组分数。有些分组不要求通过样例测试点。“离线评测”表示该组的测试结果只会在比赛结束后公布。\n\n| 组别 | 分值 | $\\sum n$ | $\\sum m$ | $w_i$ | 必须通过的组 | 备注 |\n|:----:|:----:|:--------:|:--------:|:-----:|:------------:|:----:|\n| 0    | 0    | --       | --       | --    | --           | 样例测试点 |\n| 1    | 16   | --       | --       | --    | --           | $n = m$，$u_i = i, v_i = i+1$ 对 $i < n$，$u_n = n, v_n = 1$ |\n| 2    | 17   | --       | --       | $w_i \\le 1$ | --    | $u_i < v_i$ |\n| 3    | 15   | --       | --       | --    | 2            | $u_i < v_i$ |\n| 4    | 19   | $\\sum n \\le 1000$ | $\\sum m \\le 1000$ | $w_i \\le 2^{10} - 1$ | 0 |  |\n| 5    | 14   | --       | --       | $w_i \\le 1$ | 2            |  |\n| 6    | 19   | --       | --       | --    | 0--5         | **离线评测** |\n", "locale": "zh-CN"}}}
{"pid": "P13530", "type": "P", "difficulty": 5, "samples": [["4\n5\n4 9 4 6 8\n1\n7\n2\n8 6\n1\n1", "4"], ["4\n2\n3 4\n2\n1 8\n2\n2 8\n2\n7 9", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "线段树", "2023", "Moscow Olympiad"], "title": "[OOI 2023] Music Festival / 音乐节", "background": "CF1801C", "description": "小男孩维佳非常喜欢听音乐。他一直关注着自己喜欢的乐队，因此知道本周五将有 $n$ 张新专辑发布，第 $i$ 张专辑包含 $k_i$ 首曲目。当然，作为最忠实的粉丝，维佳已经提前听过了所有即将发布的新歌，并且知道第 $i$ 张专辑中第 $j$ 首歌的“酷炫度”为 $a_{i,j}$。\n\n维佳有一个朋友玛莎，他非常希望邀请玛莎一起去参加有他最喜欢乐队出演的音乐节。不过要想让玛莎答应，玛莎需要先体验一下这些新歌。维佳知道，如果玛莎听到的某首歌酷炫度超过她此前听过的所有歌，她就会获得 $1$ 点“印象值”。遗憾的是，专辑只能整张播放，且专辑内歌曲顺序不能改变。\n\n请帮助维佳安排专辑的播放顺序，使得玛莎获得的印象值尽可能大，这样她一定会答应和他一起去音乐节。", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 200\\,000$），表示专辑数量。\n\n接下来是 $n$ 组专辑描述。每组描述包含两行：\n\n- 第一行包含一个整数 $k_i$（$1 \\le k_i \\le 200\\,000$），表示第 $i$ 张专辑的曲目数。\n- 第二行包含 $k_i$ 个整数 $a_{i, 1},\\ a_{i, 2},\\ \\ldots,\\ a_{i, k_i}$（$1 \\le a_{i,j} \\le 200\\,000$），依次表示第 $i$ 张专辑每首歌的酷炫度。\n\n记 $\\sum k_i$ 为所有专辑曲目数之和。保证 $\\sum k_i \\le 200\\,000$。", "outputFormat": "输出一个整数，表示玛莎最多能获得的印象值。", "hint": "### 样例解释\n\n在第一个测试样例中，最优的播放顺序是先听第 $4$ 张、再听第 $2$ 张、第 $3$ 张和第 $1$ 张专辑。这样玛莎依次听到的歌曲为：**1**；**7**；**8**, 6；4, **9**, 4, 6, 8。玛莎将获得 $4$ 点印象值。\n\n在第二个测试样例中，应先播放第 $1$ 张专辑，再播放第 $4$ 张，之后第 $2$ 和第 $3$ 张顺序任意。这样玛莎能获得最大印象值，且第 $1$ 和第 $4$ 张专辑的每首歌都能带来印象值，第 $2$ 和第 $3$ 张专辑则不会带来新的印象值。\n\n### 评分说明\n\n本题测试点分为 7 组。只有通过某一组所有测试点，且通过部分之前组所有测试点，才能获得该组分数。有些分组不要求通过样例测试点。\n\n| 组别 | 分值 | $n$ | $k_i$ | $a_{i, j}$ | 必须通过的组 | 备注 |\n|:----:|:----:|:---:|:-----:|:----------:|:------------:|:----:|\n| 0    | 0    | --  | --    | --         | --           | 样例测试点 |\n| 1    | 14   | $n \\le 7$ | $\\sum k_i \\le 1000$ | -- | 0 |  |\n| 2    | 9    | --  | --    | $a_{i, j} \\le 2$ | -- |  |\n| 3    | 12   | --  | --    | $a_{i, j} \\le 10$ | 0, 2 |  |\n| 4    | 15   | --  | $k_i \\le 2$ | -- | -- |  |\n| 5    | 13   | $n \\le 1000$ | -- | $a_{i, j} \\le 1000$ | 0 |  |\n| 6    | 13   | $n \\le 30\\,000$ | -- | $a_{i, j} \\le 30\\,000$ | 0, 5 |  |\n| 7    | 24   | --  | --    | --         | 0--6         |  |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[OOI 2023] Music Festival / 音乐节", "background": "CF1801C", "description": "小男孩维佳非常喜欢听音乐。他一直关注着自己喜欢的乐队，因此知道本周五将有 $n$ 张新专辑发布，第 $i$ 张专辑包含 $k_i$ 首曲目。当然，作为最忠实的粉丝，维佳已经提前听过了所有即将发布的新歌，并且知道第 $i$ 张专辑中第 $j$ 首歌的“酷炫度”为 $a_{i,j}$。\n\n维佳有一个朋友玛莎，他非常希望邀请玛莎一起去参加有他最喜欢乐队出演的音乐节。不过要想让玛莎答应，玛莎需要先体验一下这些新歌。维佳知道，如果玛莎听到的某首歌酷炫度超过她此前听过的所有歌，她就会获得 $1$ 点“印象值”。遗憾的是，专辑只能整张播放，且专辑内歌曲顺序不能改变。\n\n请帮助维佳安排专辑的播放顺序，使得玛莎获得的印象值尽可能大，这样她一定会答应和他一起去音乐节。", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 200\\,000$），表示专辑数量。\n\n接下来是 $n$ 组专辑描述。每组描述包含两行：\n\n- 第一行包含一个整数 $k_i$（$1 \\le k_i \\le 200\\,000$），表示第 $i$ 张专辑的曲目数。\n- 第二行包含 $k_i$ 个整数 $a_{i, 1},\\ a_{i, 2},\\ \\ldots,\\ a_{i, k_i}$（$1 \\le a_{i,j} \\le 200\\,000$），依次表示第 $i$ 张专辑每首歌的酷炫度。\n\n记 $\\sum k_i$ 为所有专辑曲目数之和。保证 $\\sum k_i \\le 200\\,000$。", "outputFormat": "输出一个整数，表示玛莎最多能获得的印象值。", "hint": "### 样例解释\n\n在第一个测试样例中，最优的播放顺序是先听第 $4$ 张、再听第 $2$ 张、第 $3$ 张和第 $1$ 张专辑。这样玛莎依次听到的歌曲为：**1**；**7**；**8**, 6；4, **9**, 4, 6, 8。玛莎将获得 $4$ 点印象值。\n\n在第二个测试样例中，应先播放第 $1$ 张专辑，再播放第 $4$ 张，之后第 $2$ 和第 $3$ 张顺序任意。这样玛莎能获得最大印象值，且第 $1$ 和第 $4$ 张专辑的每首歌都能带来印象值，第 $2$ 和第 $3$ 张专辑则不会带来新的印象值。\n\n### 评分说明\n\n本题测试点分为 7 组。只有通过某一组所有测试点，且通过部分之前组所有测试点，才能获得该组分数。有些分组不要求通过样例测试点。\n\n| 组别 | 分值 | $n$ | $k_i$ | $a_{i, j}$ | 必须通过的组 | 备注 |\n|:----:|:----:|:---:|:-----:|:----------:|:------------:|:----:|\n| 0    | 0    | --  | --    | --         | --           | 样例测试点 |\n| 1    | 14   | $n \\le 7$ | $\\sum k_i \\le 1000$ | -- | 0 |  |\n| 2    | 9    | --  | --    | $a_{i, j} \\le 2$ | -- |  |\n| 3    | 12   | --  | --    | $a_{i, j} \\le 10$ | 0, 2 |  |\n| 4    | 15   | --  | $k_i \\le 2$ | -- | -- |  |\n| 5    | 13   | $n \\le 1000$ | -- | $a_{i, j} \\le 1000$ | 0 |  |\n| 6    | 13   | $n \\le 30\\,000$ | -- | $a_{i, j} \\le 30\\,000$ | 0, 5 |  |\n| 7    | 24   | --  | --    | --         | 0--6         |  |", "locale": "zh-CN"}}}
{"pid": "P13531", "type": "P", "difficulty": 7, "samples": [["3 5\nabacaba\naba\na\nac\n1 7\n1 3\n2 7\n2 5\n4 5", "7 3 5 3 1"], ["4 4\nabcdca\nab\nca\nbcd\nopenolympiad\n1 5\n2 2\n2 6\n1 6", "2 0 2 3"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["堆", "2023", "扫描线", "AC 自动机", "Moscow Olympiad"], "title": "[OOI 2023] A task for substrings / 字符串问题", "background": "CF1801G", "description": "菲利普非常喜欢关于字符串的小题目。他已经解完了所有他知道的相关题目，但这还不能让他满足。于是，菲利普决定自己出一道题。\n\n为此，他准备了一个字符串 $t$，以及一个由 $n$ 个字符串 $s_1, s_2, s_3, \\ldots, s_n$ 组成的集合。菲利普还有 $m$ 个查询，每个查询中，他会取出字符串 $t$ 的第 $l_i$ 到第 $r_i$ 个字符组成的子串，并统计其中有多少个子串和集合中的某个字符串完全相同。更正式地说，菲利普想要计算有多少对位置 $(a, b)$ 满足 $l_i \\le a \\le b \\le r_i$，并且 $t$ 的第 $a$ 到第 $b$ 个字符组成的子串等于集合中的某个 $s_j$。\n\n字符串 $t$ 的第 $a$ 到第 $b$ 个字符的子串，指的是从 $t$ 的开头删除 $a-1$ 个字符，从结尾删除 $|t|-b$ 个字符后剩下的字符串，其中 $|t|$ 表示 $t$ 的长度。\n\n菲利普已经解决了这个问题，你能做到吗？", "inputFormat": "第一行包含两个正整数 $n$ 和 $m$（$1 \\le n, m \\le 500\\,000$），分别表示集合中字符串的数量和查询的数量。\n\n第二行给出一个只包含小写英文字母的字符串 $t$（$1 \\le |t| \\le 5 \\cdot 10^6$）。\n\n接下来的 $n$ 行，每行包含一个集合中的字符串 $s_i$，每个 $s_i$ 仅包含小写英文字母。记 $S$ 为所有 $s_i$ 的总长度。保证 $S \\le 10^6$，且所有 $s_i$ 互不相同。\n\n接下来的 $m$ 行，每行包含两个正整数 $l_i$ 和 $r_i$（$1 \\le l_i \\le r_i \\le |t|$），表示第 $i$ 个查询中子串的左右端点。\n", "outputFormat": "输出 $m$ 个整数，第 $i$ 个数表示第 $i$ 个查询的答案。", "hint": "### 样例解释\n\n在第一个样例中，第一个查询要求统计整个字符串中属于集合的子串个数。字符串 \"aba\" 对应的子串有 $[1, 3]$ 和 $[4, 6]$，字符串 \"a\" 对应的子串有 $[1, 1]$、$[3, 3]$、$[5, 5]$、$[7, 7]$，字符串 \"ac\" 对应的子串有 $[3, 4]$。所以总共有 $7$ 个子串与集合中的字符串匹配。\n\n在第二个查询中，取 $t$ 的第 $1$ 到第 $3$ 个字符，即字符串 \"aba\"。其中 \"aba\" 匹配 $1$ 次，\"a\" 匹配 $2$ 次，\"ac\" 不出现。\n\n在第三个查询中，取 $t$ 的第 $2$ 到第 $7$ 个字符，即字符串 \"bacaba\"。其中 \"aba\" 匹配 $1$ 次，\"a\" 匹配 $3$ 次，\"ac\" 匹配 $1$ 次。\n\n### 评分说明\n\n本题测试点分为 9 组。只有通过某一组的所有测试点，且通过部分之前组的所有测试点，才能获得该组分数。**离线评测**表示该组测试结果会在比赛结束后公布。\n\n| 组别 | 分值 | $n$ | $m$ | $\\mid t\\mid $ | $S$ | 必须通过的组 | 备注 |\n|:----:|:----:|:---:|:---:|:----:|:----:|:------------:|:-----|\n| 0    | 0    | --  | --  | --   | --   | --           | 样例测试点 |\n| 1    | 10   | $n \\le 100$ | $m \\le 100$ | $\\mid t\\mid  \\le 100$ | $S \\le 10\\,000$ | 0 |  |\n| 2    | 12   | $n \\le 100$ | $m \\le 500$ | $\\mid t\\mid \\le 5000$ | -- | 0, 1 |  |\n| 3    | 7    | $n \\le 5000$ | -- | $\\mid t\\mid  \\le 5000$ | -- | 0, 1, 2 |  |\n| 4    | 8    | $n \\le 100$ | -- | $\\mid t\\mid  \\le 50\\,000$ | -- | 0, 1, 2 |  |\n| 5    | 12   | -- | -- | $\\mid t \\mid \\le 100\\,000$ | $S \\le 100\\,000$ | 0, 1 |  |\n| 6    | 8    | -- | -- | $\\mid t \\mid \\le 250\\,000$ | $S \\le 100\\,000$ | 0, 1, 5 |  |\n| 7    | 7    | -- | -- | $\\mid t \\mid \\le 500\\,000$ | $S \\le 100\\,000$ | 0, 1, 5, 6 |  |\n| 8    | 7    | -- | -- | $\\mid t \\mid \\le 750\\,000$ | $S \\le 100\\,000$ | 0, 1, 5, 6, 7 |  |\n| 9    | 29   | -- | -- | --   | --   | 0--8          | **离线评测** |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[OOI 2023] A task for substrings / 字符串问题", "background": "CF1801G", "description": "菲利普非常喜欢关于字符串的小题目。他已经解完了所有他知道的相关题目，但这还不能让他满足。于是，菲利普决定自己出一道题。\n\n为此，他准备了一个字符串 $t$，以及一个由 $n$ 个字符串 $s_1, s_2, s_3, \\ldots, s_n$ 组成的集合。菲利普还有 $m$ 个查询，每个查询中，他会取出字符串 $t$ 的第 $l_i$ 到第 $r_i$ 个字符组成的子串，并统计其中有多少个子串和集合中的某个字符串完全相同。更正式地说，菲利普想要计算有多少对位置 $(a, b)$ 满足 $l_i \\le a \\le b \\le r_i$，并且 $t$ 的第 $a$ 到第 $b$ 个字符组成的子串等于集合中的某个 $s_j$。\n\n字符串 $t$ 的第 $a$ 到第 $b$ 个字符的子串，指的是从 $t$ 的开头删除 $a-1$ 个字符，从结尾删除 $|t|-b$ 个字符后剩下的字符串，其中 $|t|$ 表示 $t$ 的长度。\n\n菲利普已经解决了这个问题，你能做到吗？", "inputFormat": "第一行包含两个正整数 $n$ 和 $m$（$1 \\le n, m \\le 500\\,000$），分别表示集合中字符串的数量和查询的数量。\n\n第二行给出一个只包含小写英文字母的字符串 $t$（$1 \\le |t| \\le 5 \\cdot 10^6$）。\n\n接下来的 $n$ 行，每行包含一个集合中的字符串 $s_i$，每个 $s_i$ 仅包含小写英文字母。记 $S$ 为所有 $s_i$ 的总长度。保证 $S \\le 10^6$，且所有 $s_i$ 互不相同。\n\n接下来的 $m$ 行，每行包含两个正整数 $l_i$ 和 $r_i$（$1 \\le l_i \\le r_i \\le |t|$），表示第 $i$ 个查询中子串的左右端点。\n", "outputFormat": "输出 $m$ 个整数，第 $i$ 个数表示第 $i$ 个查询的答案。", "hint": "### 样例解释\n\n在第一个样例中，第一个查询要求统计整个字符串中属于集合的子串个数。字符串 \"aba\" 对应的子串有 $[1, 3]$ 和 $[4, 6]$，字符串 \"a\" 对应的子串有 $[1, 1]$、$[3, 3]$、$[5, 5]$、$[7, 7]$，字符串 \"ac\" 对应的子串有 $[3, 4]$。所以总共有 $7$ 个子串与集合中的字符串匹配。\n\n在第二个查询中，取 $t$ 的第 $1$ 到第 $3$ 个字符，即字符串 \"aba\"。其中 \"aba\" 匹配 $1$ 次，\"a\" 匹配 $2$ 次，\"ac\" 不出现。\n\n在第三个查询中，取 $t$ 的第 $2$ 到第 $7$ 个字符，即字符串 \"bacaba\"。其中 \"aba\" 匹配 $1$ 次，\"a\" 匹配 $3$ 次，\"ac\" 匹配 $1$ 次。\n\n### 评分说明\n\n本题测试点分为 9 组。只有通过某一组的所有测试点，且通过部分之前组的所有测试点，才能获得该组分数。**离线评测**表示该组测试结果会在比赛结束后公布。\n\n| 组别 | 分值 | $n$ | $m$ | $\\mid t\\mid $ | $S$ | 必须通过的组 | 备注 |\n|:----:|:----:|:---:|:---:|:----:|:----:|:------------:|:-----|\n| 0    | 0    | --  | --  | --   | --   | --           | 样例测试点 |\n| 1    | 10   | $n \\le 100$ | $m \\le 100$ | $\\mid t\\mid  \\le 100$ | $S \\le 10\\,000$ | 0 |  |\n| 2    | 12   | $n \\le 100$ | $m \\le 500$ | $\\mid t\\mid \\le 5000$ | -- | 0, 1 |  |\n| 3    | 7    | $n \\le 5000$ | -- | $\\mid t\\mid  \\le 5000$ | -- | 0, 1, 2 |  |\n| 4    | 8    | $n \\le 100$ | -- | $\\mid t\\mid  \\le 50\\,000$ | -- | 0, 1, 2 |  |\n| 5    | 12   | -- | -- | $\\mid t \\mid \\le 100\\,000$ | $S \\le 100\\,000$ | 0, 1 |  |\n| 6    | 8    | -- | -- | $\\mid t \\mid \\le 250\\,000$ | $S \\le 100\\,000$ | 0, 1, 5 |  |\n| 7    | 7    | -- | -- | $\\mid t \\mid \\le 500\\,000$ | $S \\le 100\\,000$ | 0, 1, 5, 6 |  |\n| 8    | 7    | -- | -- | $\\mid t \\mid \\le 750\\,000$ | $S \\le 100\\,000$ | 0, 1, 5, 6, 7 |  |\n| 9    | 29   | -- | -- | --   | --   | 0--8          | **离线评测** |\n", "locale": "zh-CN"}}}
{"pid": "P13532", "type": "P", "difficulty": 4, "samples": [["2\n1 2\n2 1", "0"], ["5\n1 5\n2 7\n3 3\n4 10\n2 5", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2023", "Moscow Olympiad"], "title": "[OOI 2023] Buying gifts / 购买礼物", "background": "CF1801B", "description": "小萨沙有两位好朋友，他想在三八妇女节时为她们各自挑选礼物。为此，他来到了城市里最大的购物中心。\n\n购物中心里有 $n$ 个部门，每个部门里恰好有两家商店。我们用 $1$ 到 $n$ 给这些部门编号。已知第 $i$ 个部门的第一家商店的礼物价格为 $a_i$ 卢布，第二家商店的礼物价格为 $b_i$ 卢布。\n\n进入购物中心后，萨沙会依次经过所有 $n$ 个部门，并且在每个部门里只会进入一家商店。因此，在第 $i$ 个部门，他会做如下两种选择之一：\n\n1. 为第一位朋友购买礼物，花费 $a_i$ 卢布。\n2. 为第二位朋友购买礼物，花费 $b_i$ 卢布。\n\n对于每位朋友，萨沙都要至少买一个礼物。此外，他还希望选择礼物的方式，使得两位朋友收到的最贵礼物的价格之差尽可能小，这样谁都不会觉得不公平。\n\n更具体地说，设 $m_1$ 为第一位朋友收到的礼物中最贵的价格，$m_2$ 为第二位朋友收到的礼物中最贵的价格。萨沙想要最小化 $| m_1 - m_2 |$。\n", "inputFormat": "第一行包含一个整数 $n$（$2 \\le n \\le 500\\,000$），表示购物中心的部门数。\n\n接下来的 $n$ 行，每行两个整数 $a_i$ 和 $b_i$（$0 \\le a_i, b_i \\le 10^9$），分别表示第 $i$ 个部门两家商店礼物的价格。\n", "outputFormat": "输出一个整数，表示两位朋友收到的最贵礼物价格的最小差值。", "hint": "### 样例解释\n\n在第一个样例中，萨沙有两种选择：在第一个部门为第一位朋友买礼物，在第二个部门为第二位朋友买礼物，或者反过来。在这两种情况下，$m_1 = m_2 = 1$ 或 $m_1 = m_2 = 2$，结果都是 $0$。\n\n在第二个样例中，可以在第 $2$、$4$、$5$ 个部门为第一位朋友买礼物，在第 $1$、$3$ 个部门为第二位朋友买礼物。此时 $m_1 = \\max(2, 4, 2) = 4$，$m_2 = \\max(5, 3) = 5$，答案为 $|4 - 5| = 1$。\n\n### 评分说明\n\n本题测试点分为 5 组。只有通过某一组的所有测试点，且通过部分之前组的所有测试点，才能获得该组分数。\n\n| 组别 | 分值 | $n$ | $a_i$ 和 $b_i$ | 必须通过的组 | 备注 |\n|:----:|:----:|:---:|:--------------:|:------------:|:----:|\n| 0    | 0    | --  | --             | --           | 样例测试点 |\n| 1    | 16   | $n \\le 20$ | --        | 0            | --   |\n| 2    | 17   | $n \\le 500$ | --       | 0, 1         | --   |\n| 3    | 22   | $n \\le 5000$ | --      | 0, 1, 2      | --   |\n| 4    | 12   | --  | $a_i = b_i$    | --           | --   |\n| 5    | 33   | --  | --             | 0--4         | --   |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[OOI 2023] Buying gifts / 购买礼物", "background": "CF1801B", "description": "小萨沙有两位好朋友，他想在三八妇女节时为她们各自挑选礼物。为此，他来到了城市里最大的购物中心。\n\n购物中心里有 $n$ 个部门，每个部门里恰好有两家商店。我们用 $1$ 到 $n$ 给这些部门编号。已知第 $i$ 个部门的第一家商店的礼物价格为 $a_i$ 卢布，第二家商店的礼物价格为 $b_i$ 卢布。\n\n进入购物中心后，萨沙会依次经过所有 $n$ 个部门，并且在每个部门里只会进入一家商店。因此，在第 $i$ 个部门，他会做如下两种选择之一：\n\n1. 为第一位朋友购买礼物，花费 $a_i$ 卢布。\n2. 为第二位朋友购买礼物，花费 $b_i$ 卢布。\n\n对于每位朋友，萨沙都要至少买一个礼物。此外，他还希望选择礼物的方式，使得两位朋友收到的最贵礼物的价格之差尽可能小，这样谁都不会觉得不公平。\n\n更具体地说，设 $m_1$ 为第一位朋友收到的礼物中最贵的价格，$m_2$ 为第二位朋友收到的礼物中最贵的价格。萨沙想要最小化 $| m_1 - m_2 |$。\n", "inputFormat": "第一行包含一个整数 $n$（$2 \\le n \\le 500\\,000$），表示购物中心的部门数。\n\n接下来的 $n$ 行，每行两个整数 $a_i$ 和 $b_i$（$0 \\le a_i, b_i \\le 10^9$），分别表示第 $i$ 个部门两家商店礼物的价格。\n", "outputFormat": "输出一个整数，表示两位朋友收到的最贵礼物价格的最小差值。", "hint": "### 样例解释\n\n在第一个样例中，萨沙有两种选择：在第一个部门为第一位朋友买礼物，在第二个部门为第二位朋友买礼物，或者反过来。在这两种情况下，$m_1 = m_2 = 1$ 或 $m_1 = m_2 = 2$，结果都是 $0$。\n\n在第二个样例中，可以在第 $2$、$4$、$5$ 个部门为第一位朋友买礼物，在第 $1$、$3$ 个部门为第二位朋友买礼物。此时 $m_1 = \\max(2, 4, 2) = 4$，$m_2 = \\max(5, 3) = 5$，答案为 $|4 - 5| = 1$。\n\n### 评分说明\n\n本题测试点分为 5 组。只有通过某一组的所有测试点，且通过部分之前组的所有测试点，才能获得该组分数。\n\n| 组别 | 分值 | $n$ | $a_i$ 和 $b_i$ | 必须通过的组 | 备注 |\n|:----:|:----:|:---:|:--------------:|:------------:|:----:|\n| 0    | 0    | --  | --             | --           | 样例测试点 |\n| 1    | 16   | $n \\le 20$ | --        | 0            | --   |\n| 2    | 17   | $n \\le 500$ | --       | 0, 1         | --   |\n| 3    | 22   | $n \\le 5000$ | --      | 0, 1, 2      | --   |\n| 4    | 12   | --  | $a_i = b_i$    | --           | --   |\n| 5    | 33   | --  | --             | 0--4         | --   |", "locale": "zh-CN"}}}
{"pid": "P13534", "type": "P", "difficulty": 5, "samples": [["4 4 2 0\n7 4 3 1\n1 2 21\n3 2 6\n1 3 8\n2 4 11", "4"], ["4 4 10 0\n1 2 10 1\n1 2 20\n2 4 30\n1 3 25\n3 4 89", "24"], ["4 4 7 0\n5 1 6 2\n1 2 5\n2 3 10\n3 4 50\n3 4 70", "10"], ["4 1 2 0\n1 1 1 1\n1 3 2", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2023", "最短路", "Moscow Olympiad"], "title": "[OOI 2023] The way home / 回家的路", "background": "CF1801D", "description": "著名魔术师博里斯·布迪尼在 X 国旅行，这个国家共有 $n$ 个城市。不幸的是，他在编号为 $1$ 的城市遭遇了盗窃。现在，布迪尼需要踏上回家的旅程，目标是回到编号为 $n$ 的城市。\n\n他打算乘坐飞机返家。全国共有 $m$ 个航班，第 $i$ 个航班从城市 $a_i$ 飞往城市 $b_i$，票价为 $s_i$ 卢布。要搭乘某个航班，布迪尼必须身处起点城市 $a_i$，并且手中至少有 $s_i$ 卢布（这些钱在登机时会被扣除）。\n\n被盗后，他仅剩 $p$ 卢布。但他并未气馁！在任意城市 $i$，他都可以随时举办魔术表演，每场表演能赚 $w_i$ 卢布。\n\n请帮助布迪尼判断，他是否能够回到家乡。如果可以，求出他至少需要举办多少场表演。", "inputFormat": "第一行包含四个整数 $n$、$m$、$p$ 和 $g$（$2 \\le n \\le 800$，$1 \\le m \\le 3000$，$0 \\le p \\le 10^9$，$0 \\le g \\le 6$），分别表示城市数量、航班数量、初始卢布数和测试组编号。\n\n第二行包含 $n$ 个整数 $w_1, w_2, \\ldots, w_n$（$1 \\le w_i \\le 10^9$），表示在每个城市举办一场表演能获得的收入。\n\n接下来 $m$ 行，每行三个整数 $a_i$、$b_i$ 和 $s_i$（$1 \\le a_i, b_i \\le n$，$1 \\le s_i \\le 10^9$），表示第 $i$ 个航班的起点、终点和票价。\n", "outputFormat": "输出一个整数，表示布迪尼至少需要举办的表演场数。如果无法回家，输出 $-1$。\n", "hint": "### 样例解释\n\n在第一个样例中，布迪尼最优策略是在第一个城市举办 $4$ 场表演，此时他共有 $2 + 7 \\times 4 = 30$ 卢布，然后依次乘坐 $1 \\to 3 \\to 2 \\to 4$ 的航班，花费 $6 + 8 + 11 = 25$ 卢布。\n\n在第二个样例中，布迪尼最优策略是在第一个城市举办 $15$ 场表演，飞到第 $3$ 个城市后再举办 $9$ 场表演，然后前往第 $4$ 个城市。\n\n### 评分说明\n\n本题测试数据分为 6 组。只有通过某一组的全部测试点，且通过部分之前组的全部测试点后，才能获得该组分数。有些分组不要求通过样例测试点。**离线评测**表示该组的测试结果会在比赛结束后公布。\n\n| 组别 | 分值 | $n$ | $m$ | $s_i$ | $w_i$ | 必须通过的组 | 备注 |\n|:----:|:----:|:---:|:---:|:-----:|:-----:|:------------:|:----:|\n| 0    | 0    | --  | --  | --    | --    | --           | 样例测试点 |\n| 1    | 14   | --  | --  | --    | $w_i=1$ | --        |        |\n| 2    | 13   | --  | $m = n - 1$ | --    | --    | --           | $a_i = i$，$b_i = i + 1$ |\n| 3    | 17   | $n \\le 10$ | --  | --    | --    | 0            |        |\n| 4    | 19   | $n \\le 100$ | -- | $s_i \\le 100$ | -- | 0        |        |\n| 5    | 21   | $n \\le 100$ | -- | --    | --    | 0, 3, 4      |        |\n| 6    | 16   | --  | --  | --    | --    | 0--5         | **离线评测** |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[OOI 2023] The way home / 回家的路", "background": "CF1801D", "description": "著名魔术师博里斯·布迪尼在 X 国旅行，这个国家共有 $n$ 个城市。不幸的是，他在编号为 $1$ 的城市遭遇了盗窃。现在，布迪尼需要踏上回家的旅程，目标是回到编号为 $n$ 的城市。\n\n他打算乘坐飞机返家。全国共有 $m$ 个航班，第 $i$ 个航班从城市 $a_i$ 飞往城市 $b_i$，票价为 $s_i$ 卢布。要搭乘某个航班，布迪尼必须身处起点城市 $a_i$，并且手中至少有 $s_i$ 卢布（这些钱在登机时会被扣除）。\n\n被盗后，他仅剩 $p$ 卢布。但他并未气馁！在任意城市 $i$，他都可以随时举办魔术表演，每场表演能赚 $w_i$ 卢布。\n\n请帮助布迪尼判断，他是否能够回到家乡。如果可以，求出他至少需要举办多少场表演。", "inputFormat": "第一行包含四个整数 $n$、$m$、$p$ 和 $g$（$2 \\le n \\le 800$，$1 \\le m \\le 3000$，$0 \\le p \\le 10^9$，$0 \\le g \\le 6$），分别表示城市数量、航班数量、初始卢布数和测试组编号。\n\n第二行包含 $n$ 个整数 $w_1, w_2, \\ldots, w_n$（$1 \\le w_i \\le 10^9$），表示在每个城市举办一场表演能获得的收入。\n\n接下来 $m$ 行，每行三个整数 $a_i$、$b_i$ 和 $s_i$（$1 \\le a_i, b_i \\le n$，$1 \\le s_i \\le 10^9$），表示第 $i$ 个航班的起点、终点和票价。\n", "outputFormat": "输出一个整数，表示布迪尼至少需要举办的表演场数。如果无法回家，输出 $-1$。\n", "hint": "### 样例解释\n\n在第一个样例中，布迪尼最优策略是在第一个城市举办 $4$ 场表演，此时他共有 $2 + 7 \\times 4 = 30$ 卢布，然后依次乘坐 $1 \\to 3 \\to 2 \\to 4$ 的航班，花费 $6 + 8 + 11 = 25$ 卢布。\n\n在第二个样例中，布迪尼最优策略是在第一个城市举办 $15$ 场表演，飞到第 $3$ 个城市后再举办 $9$ 场表演，然后前往第 $4$ 个城市。\n\n### 评分说明\n\n本题测试数据分为 6 组。只有通过某一组的全部测试点，且通过部分之前组的全部测试点后，才能获得该组分数。有些分组不要求通过样例测试点。**离线评测**表示该组的测试结果会在比赛结束后公布。\n\n| 组别 | 分值 | $n$ | $m$ | $s_i$ | $w_i$ | 必须通过的组 | 备注 |\n|:----:|:----:|:---:|:---:|:-----:|:-----:|:------------:|:----:|\n| 0    | 0    | --  | --  | --    | --    | --           | 样例测试点 |\n| 1    | 14   | --  | --  | --    | $w_i=1$ | --        |        |\n| 2    | 13   | --  | $m = n - 1$ | --    | --    | --           | $a_i = i$，$b_i = i + 1$ |\n| 3    | 17   | $n \\le 10$ | --  | --    | --    | 0            |        |\n| 4    | 19   | $n \\le 100$ | -- | $s_i \\le 100$ | -- | 0        |        |\n| 5    | 21   | $n \\le 100$ | -- | --    | --    | 0, 3, 4      |        |\n| 6    | 16   | --  | --  | --    | --    | 0--5         | **离线评测** |", "locale": "zh-CN"}}}
{"pid": "P13535", "type": "P", "difficulty": 6, "samples": [["3\n4 3 1", "0 1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "IOI", "交互题", "Special Judge"], "title": "[IOI 2025] Souvenirs", "background": "**DO NOT** $\\texttt{\\#include \"souvenirs.h\"}$。\n\nAdd the following code at the beginning of your code, and **submit using $\\texttt{\\textcolor{red}{C++\\,20}}$**.\n\n```cpp\n#include <utility>\n#include <vector>\nstd::pair<std::vector<int>, long long> transaction(long long M);\n```", "description": "Amaru is buying souvenirs in a foreign shop. There are $N$ **types** of souvenirs. There are infinitely many souvenirs of each type available in the shop.\n\nEach type of souvenir has a fixed price. Namely, a souvenir of type $i$ ($0 \\leq i < N$) has a price of $P[i]$ coins, where $P[i]$ is a positive integer.\n\nAmaru knows that souvenir types are sorted in decreasing order by price, and that the souvenir prices are distinct. Specifically, $P[0] > P[1] > \\cdots > P[N - 1] > 0$. Moreover, he was able to learn the value of $P[0]$. Unfortunately, Amaru does not have any other information about the prices of the souvenirs.\n\nTo buy some souvenirs, Amaru will perform a number of transactions with the seller.\n\nEach transaction consists of the following steps:\n\n1. Amaru hands some (positive) number of coins to the seller.\n2. The seller puts these coins in a pile on the table in the back room, where Amaru cannot see them.\n3. The seller considers each souvenir type $0, 1, \\ldots, N - 1$ in that order, one by one. Each type is considered **exactly once** per transaction.\n    - When considering souvenir type $i$, if the current number of coins in the pile is at least $P[i]$, then\n        - the seller removes $P[i]$ coins from the pile, and\n        - the seller puts one souvenir of type $i$ on the table.\n4. The seller gives Amaru all the coins remaining in the pile and all souvenirs on the table.\n\nNote that there are no coins or souvenirs on the table before a transaction begins.\n\nYour task is to instruct Amaru to perform some number of transactions, so that:\n\n- in each transaction he buys **at least one** souvenir, and\n- overall he buys **exactly** $i$ souvenirs of type $i$, for each $i$ such that $0 \\leq i < N$. Note that this means that Amaru should not buy any souvenir of type $0$.\n\nAmaru does not have to minimize the number of transactions and has an unlimited supply of coins.\n\n### Implementation Details\n\nYou should implement the following procedure.\n\n```\nvoid buy_souvenirs(int N, long long P0)\n```\n\n- $N$: the number of souvenir types.\n- $P0$: the value of $P[0]$.\n- This procedure is called exactly once for each test case.\n\nThe above procedure can make calls to the following procedure to instruct Amaru to perform a transaction:\n\n```\nstd::pair<std::vector<int>, long long> transaction(long long M)\n```\n\n- $M$: the number of coins handed to the seller by Amaru.\n- The procedure returns a pair. The first element of the pair is an array $L$, containing the types of souvenirs that have been bought (in increasing order). The second element is an integer $R$, the number of coins returned to Amaru after the transaction.\n- It is required that $P[0] > M \\geq P[N - 1]$. The condition $P[0] > M$ ensures that Amaru does not buy any souvenir of type 0, and $M \\geq P[N - 1]$ ensures that Amaru buys at least one souvenir. If these conditions are not met, your solution will receive the verdict Output isn't correct: Invalid argument. Note that contrary to $P[0]$, the value of $P[N - 1]$ is not provided in the input.\n- The procedure can be called at most 5000 times in each test case.\n\nThe behavior of the grader is **not adaptive**. This means that the sequence of prices $P$ is fixed before buy\\_souvenirs is called.", "inputFormat": "```\nN\nP[0] P[1] ... P[N-1]\n```", "outputFormat": "```\nQ[0] Q[1] ... Q[N-1]\n```\n\nHere $Q[i]$ is the number of souvenirs of type $i$ bought in total for each $i$ such that $0 \\leq i < N$.", "hint": "### Example\n\nConsider the following call.\n\n```\nbuy_souvenirs(3, 4)\n```\n\nThere are $N = 3$ types of souvenirs and $P[0] = 4$. Observe that there are only three possible sequences of prices $P$: $[4, 3, 2]$, $[4, 3, 1]$, and $[4, 2, 1]$.\n\nAssume that buy_souvenirs calls `transaction(2)`. Suppose the call returns $([2],1)$, meaning that Amaru bought one souvenir of type 2 and the seller gave him back 1 coin. Observe that this allows us to deduce that $P = [4,3,1]$, since:\n- For $P = [4,3,2]$, `transaction(2)` would have returned $([2],0)$.\n- For $P = [4,2,1]$, `transaction(2)` would have returned $([1],0)$.\n\nThen `buy_souvenirs` can call `transaction(3)`, which returns $([1],0)$, meaning that Amaru bought one souvenir of type 1 and the seller gave him back 0 coins. So far, in total, he has bought one souvenir of type 1 and one souvenir of type 2.\n\nFinally, `buy_souvenirs` can call `transaction(1)`, which returns $([2],0)$, meaning that Amaru bought one souvenir of type 2. Note that we could have also used `transaction(2)` here. At this point, in total Amaru has one souvenir of type 1 and two souvenirs of type 2, as required.\n\n### Constraints\n\n- $2 \\leq N \\leq 100$\n- $1 \\leq P[i] \\leq 10^{15}$ for each $i$ such that $0 \\leq i < N$.\n- $P[i] > P[i + 1]$ for each $i$ such that $0 \\leq i < N - 1$.\n\n### Subtasks\n\n| Subtask | Score | Additional Constraints |\n| :-: | :-: | :-: |\n| 1 | 4 | $N=2$ |\n| 2 | 3 | $P[i]=N-i$ for each $i$ such that $0 \\leq i < N$. |\n| 3 | 14 | $P[i] \\leq P[i+1] + 2$ for each $i$ such that $0 \\leq i < N-1$. |\n| 4 | 18 | $N=3$ |\n| 5 | 28 | $P[i+1] + P[i+2] \\leq P[i]$ for each $i$ such that $0 \\leq i < N-2$. $P[i] \\leq 2 \\cdot P[i+1]$ for each $i$ such that $0 \\leq i < N-1$. |\n| 6 | 33 | No additional constraints. |\n", "locale": "en", "translations": {"en": {"title": "[IOI 2025] Souvenirs", "background": "**DO NOT** $\\texttt{\\#include \"souvenirs.h\"}$。\n\nAdd the following code at the beginning of your code, and **submit using $\\texttt{\\textcolor{red}{C++\\,20}}$**.\n\n```cpp\n#include <utility>\n#include <vector>\nstd::pair<std::vector<int>, long long> transaction(long long M);\n```", "description": "Amaru is buying souvenirs in a foreign shop. There are $N$ **types** of souvenirs. There are infinitely many souvenirs of each type available in the shop.\n\nEach type of souvenir has a fixed price. Namely, a souvenir of type $i$ ($0 \\leq i < N$) has a price of $P[i]$ coins, where $P[i]$ is a positive integer.\n\nAmaru knows that souvenir types are sorted in decreasing order by price, and that the souvenir prices are distinct. Specifically, $P[0] > P[1] > \\cdots > P[N - 1] > 0$. Moreover, he was able to learn the value of $P[0]$. Unfortunately, Amaru does not have any other information about the prices of the souvenirs.\n\nTo buy some souvenirs, Amaru will perform a number of transactions with the seller.\n\nEach transaction consists of the following steps:\n\n1. Amaru hands some (positive) number of coins to the seller.\n2. The seller puts these coins in a pile on the table in the back room, where Amaru cannot see them.\n3. The seller considers each souvenir type $0, 1, \\ldots, N - 1$ in that order, one by one. Each type is considered **exactly once** per transaction.\n    - When considering souvenir type $i$, if the current number of coins in the pile is at least $P[i]$, then\n        - the seller removes $P[i]$ coins from the pile, and\n        - the seller puts one souvenir of type $i$ on the table.\n4. The seller gives Amaru all the coins remaining in the pile and all souvenirs on the table.\n\nNote that there are no coins or souvenirs on the table before a transaction begins.\n\nYour task is to instruct Amaru to perform some number of transactions, so that:\n\n- in each transaction he buys **at least one** souvenir, and\n- overall he buys **exactly** $i$ souvenirs of type $i$, for each $i$ such that $0 \\leq i < N$. Note that this means that Amaru should not buy any souvenir of type $0$.\n\nAmaru does not have to minimize the number of transactions and has an unlimited supply of coins.\n\n### Implementation Details\n\nYou should implement the following procedure.\n\n```\nvoid buy_souvenirs(int N, long long P0)\n```\n\n- $N$: the number of souvenir types.\n- $P0$: the value of $P[0]$.\n- This procedure is called exactly once for each test case.\n\nThe above procedure can make calls to the following procedure to instruct Amaru to perform a transaction:\n\n```\nstd::pair<std::vector<int>, long long> transaction(long long M)\n```\n\n- $M$: the number of coins handed to the seller by Amaru.\n- The procedure returns a pair. The first element of the pair is an array $L$, containing the types of souvenirs that have been bought (in increasing order). The second element is an integer $R$, the number of coins returned to Amaru after the transaction.\n- It is required that $P[0] > M \\geq P[N - 1]$. The condition $P[0] > M$ ensures that Amaru does not buy any souvenir of type 0, and $M \\geq P[N - 1]$ ensures that Amaru buys at least one souvenir. If these conditions are not met, your solution will receive the verdict Output isn't correct: Invalid argument. Note that contrary to $P[0]$, the value of $P[N - 1]$ is not provided in the input.\n- The procedure can be called at most 5000 times in each test case.\n\nThe behavior of the grader is **not adaptive**. This means that the sequence of prices $P$ is fixed before buy\\_souvenirs is called.", "inputFormat": "```\nN\nP[0] P[1] ... P[N-1]\n```", "outputFormat": "```\nQ[0] Q[1] ... Q[N-1]\n```\n\nHere $Q[i]$ is the number of souvenirs of type $i$ bought in total for each $i$ such that $0 \\leq i < N$.", "hint": "### Example\n\nConsider the following call.\n\n```\nbuy_souvenirs(3, 4)\n```\n\nThere are $N = 3$ types of souvenirs and $P[0] = 4$. Observe that there are only three possible sequences of prices $P$: $[4, 3, 2]$, $[4, 3, 1]$, and $[4, 2, 1]$.\n\nAssume that buy_souvenirs calls `transaction(2)`. Suppose the call returns $([2],1)$, meaning that Amaru bought one souvenir of type 2 and the seller gave him back 1 coin. Observe that this allows us to deduce that $P = [4,3,1]$, since:\n- For $P = [4,3,2]$, `transaction(2)` would have returned $([2],0)$.\n- For $P = [4,2,1]$, `transaction(2)` would have returned $([1],0)$.\n\nThen `buy_souvenirs` can call `transaction(3)`, which returns $([1],0)$, meaning that Amaru bought one souvenir of type 1 and the seller gave him back 0 coins. So far, in total, he has bought one souvenir of type 1 and one souvenir of type 2.\n\nFinally, `buy_souvenirs` can call `transaction(1)`, which returns $([2],0)$, meaning that Amaru bought one souvenir of type 2. Note that we could have also used `transaction(2)` here. At this point, in total Amaru has one souvenir of type 1 and two souvenirs of type 2, as required.\n\n### Constraints\n\n- $2 \\leq N \\leq 100$\n- $1 \\leq P[i] \\leq 10^{15}$ for each $i$ such that $0 \\leq i < N$.\n- $P[i] > P[i + 1]$ for each $i$ such that $0 \\leq i < N - 1$.\n\n### Subtasks\n\n| Subtask | Score | Additional Constraints |\n| :-: | :-: | :-: |\n| 1 | 4 | $N=2$ |\n| 2 | 3 | $P[i]=N-i$ for each $i$ such that $0 \\leq i < N$. |\n| 3 | 14 | $P[i] \\leq P[i+1] + 2$ for each $i$ such that $0 \\leq i < N-1$. |\n| 4 | 18 | $N=3$ |\n| 5 | 28 | $P[i+1] + P[i+2] \\leq P[i]$ for each $i$ such that $0 \\leq i < N-2$. $P[i] \\leq 2 \\cdot P[i+1]$ for each $i$ such that $0 \\leq i < N-1$. |\n| 6 | 33 | No additional constraints. |\n", "locale": "en"}, "zh-CN": {"title": "[IOI 2025] 纪念品（souvenirs）", "background": "不要 $\\texttt{\\#include \"souvenirs.h\"}$。\n\n你需要在文件头加入以下内容，并**使用 $\\texttt{\\textcolor{red}{C++\\,20}}$ 提交**：\n\n```cpp\n#include <utility>\n#include <vector>\nstd::pair<std::vector<int>, long long> transaction(long long M);\n```", "description": "Amaru 在一家国外商店购买纪念品。商店有 $N$ **种**纪念品，而且每种纪念品有无限多件现货。\n\n每种纪念品都有一个固定的价格：第 $i$ 种（$0 \\leq i < N$）纪念品的价格为 $P[i]$ 枚硬币，其中 $P[i]$ 是一个正整数。\n\nAmaru 知道纪念品种类是按价格降序排列的，而且所有纪念品的价格互不相同。具体来说，$P[0] > P[1] > \\cdots > P[N-1] > 0$。此外，他还知道 $P[0]$ 的值。不幸的是，Amaru 没有其他纪念品的价格信息。\n\n为了购买纪念品，Amaru 会与卖家进行若干次交易。\n\n每次交易由以下步骤组成：\n\n1. Amaru 向卖家支付一定数量（正数）的硬币。\n1. 卖家将这些硬币堆放在商店后台的桌子上，因此 Amaru 无法看到这些硬币。\n1. 卖家按顺序依次处理每种纪念品 $0, 1, \\ldots, N-1$。每种纪念品在每次交易中被处理**恰好一次**。\n    * 当处理第 $i$ 种纪念品时，如果当前硬币堆中的硬币数量至少为 $P[i]$，则\n        * 卖家从硬币堆中移除 $P[i]$ 枚硬币；\n        * 卖家将一件第 $i$ 种纪念品放在桌子上。\n4. 卖家将剩余的所有硬币和桌子上的纪念品交给 Amaru。\n\n注意，在每次交易开始前，桌上没有任何硬币或纪念品。\n\n你的任务是指导 Amaru 进行若干次交易，使得：\n\n* 在每次交易中，他购买**至少一件**纪念品；\n* 总体上他**恰好**购买了 $i$ 件第 $i$ 种纪念品，其中 $0 \\leq i < N$。注意，这意味着 Amaru 不应购买第 $0$ 种纪念品。\n\nAmaru 不需要最小化交易次数，而且拥有无限量的硬币供应。\n\n### 实现细节\n\n你需要实现以下函数。\n\n```\nvoid buy_souvenirs(int N, long long P0)\n```\n\n* $N$：纪念品的种数。\n* $P0$：$P[0]$ 的值。\n* 对每个测试用例，该函数恰被调用一次。\n\n上述函数可以调用以下函数，来指导 Amaru 进行交易：\n\n```\nstd::pair<std::vector<int>, long long> transaction(long long M)\n```\n\n* $M$：Amaru 支付给卖家的硬币数量。\n* 该函数返回一对元素。第一个元素是数组 $L$，包含按顺序排列的已购买的纪念品种类。第二个元素是整数 $R$，表示交易后卖家返还给 Amaru 的硬币数量。\n* 要求 $P[0] > M \\geq P[N-1]$。条件 $P[0] > M$ 确保 Amaru 不购买第 $0$ 种纪念品，而条件 $M \\geq P[N-1]$ 确保他至少购买一件纪念品。如果这些条件未被满足，你将收到 `Output isn't correct: Invalid argument`。注意，与 $P[0]$ 不同，$P[N-1]$ 的值未在输入中提供。\n* 对每个测试用例，该函数最多被调用 $5000$ 次。\n\n评测程序的行为是**非自适应的**。\n这意味着在调用 `buy_souvenirs` 前，价格序列 $P$ 是固定的。", "inputFormat": "```\nN\nP[0] P[1] ... P[N-1]\n```", "outputFormat": "输出格式：\n\n```\nQ[0] Q[1] ... Q[N-1]\n```\n\n这里，对每个满足 $0 \\leq i < N$ 的 $i$，购买的第 $i$ 种纪念品的数量为 $Q[i]$。", "hint": "### 例子\n\n考虑以下函数调用。\n\n```\nbuy_souvenirs(3, 4)\n```\n\n共有 $N = 3$ 种纪念品，且 $P[0] = 4$。观察到只有三种可能的价格序列 $P$：$[4, 3, 2]$，$[4, 3, 1]$ 和 $[4, 2, 1]$。\n\n假设 `buy_souvenirs` 调用 `transaction(2)`，且函数返回 $([2], 1)$，表示 Amaru 购买了一件第 $2$ 种纪念品，而且卖家返还了 $1$ 枚硬币。通过观察，我们可以推断出 $P = [4, 3, 1]$，因为：\n\n* 对于 $P = [4, 3, 2]$，`transaction(2)` 会返回 $([2], 0)$。\n* 对于 $P = [4, 2, 1]$，`transaction(2)` 会返回 $([1], 0)$。\n\n然后 `buy_souvenirs` 可以调用 `transaction(3)` 返回 $([1], 0)$，表示 Amaru 购买了一件第 $1$ 种纪念品，而卖家返还了 $0$ 枚硬币。到目前为止，Amaru 购买了一件第 $1$ 种纪念品和一件第 $2$ 种纪念品。\n\n最后，`buy_souvenirs` 可以调用 `transaction(1)` 返回 $([2], 0)$，表示 Amaru 购买了一件第 $2$ 种纪念品。注意，这里也可以调用 `transaction(2)`。至此，Amaru 共购买了一件第 $1$ 种纪念品和两件第 $2$ 种纪念品，符合要求。\n\n### 约束条件\n\n* $2 \\leq N \\leq 100$\n* 对每个满足 $0 \\leq i < N$ 的 $i$，有 $1 \\leq P[i] \\leq 10^{15}$ 。\n* 对每个满足 $0 \\leq i < N - 1$ 的 $i$，有 $P[i] > P[i+1]$ 。\n\n### 子任务\n\n| 子任务 | 分数 | 额外的约束条件 |\n| :-----: | :----: | ---------------------- |\n| 1 | $4$ | $N = 2$\n| 2 | $3$ | 对每个满足 $0 \\leq i < N$ 的 $i$，有 $P[i] = N - i$。\n| 3 | $14$ | 对每个满足 $0 \\leq i < N - 1$ 的 $i$，有 $P[i] \\leq P[i+1] + 2$。\n| 4 | $18$ | $N = 3$\n| 5 | $28$ |  对每个满足 $0 \\leq i < N-2$ 的 $i$，有 $P[i+1] + P[i+2] \\leq P[i]$。对每个满足 $0 \\leq i < N-1$ 的 $i$，有 $P[i] \\leq 2 \\cdot P[i+1]$。\n| 6 | $33$ | 没有额外的约束条件。", "locale": "zh-CN"}}}
