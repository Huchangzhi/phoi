{"pid": "P9316", "type": "P", "difficulty": 7, "samples": [["3 4\n1 3\n2 2\n3 2\n1 3", "4 12"], ["2 0", "4 4"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "O2优化", "EGOI（欧洲/女生）"], "title": "[EGOI 2021] Double Move / 二选一游戏", "background": "Day 2 Problem D.\n\n题面译自 [EGOI2021 doublemove](https://stats.egoi.org/media/task_description/2021_doublemove_en.pdf)。", "description": "爱丽丝和鲍勃在玩游戏，克莱尔在帮助他们。共有 $n$ 颗石子，编号从 $1$ 到 $n$。游戏分为三个阶段。\n\n在第一阶段，爱丽丝和鲍勃轮流操作，爱丽丝先手。在每次操作中，玩家宣布他们要拿的石头，但不直接说出拿哪一个，而是给出两个选项。两个选项可能是相同的。也有可能说出已经说过的石头。第一阶段不取石子——玩家只是宣布他们在第二阶段的意图。第一阶段在宣布 $n+1$ 次后结束。\n\n下面是 $n=3$ 的第一阶段的例子：\n\n1. 爱丽丝：“我会取走 $1$ 或 $3$”\n2. 鲍勃：“我会取走 $2$ 或 $2$”\n3. 爱丽丝：“我会取走 $3$ 或 $2$”\n4. 鲍勃：“我会取走 $1$ 或 $3$”\n\n在第二阶段，对于 $n+1$ 次宣布的每一个，克莱尔用说“前者”或“后者”的方式从两个选项中选择一个。我们称克莱尔做出的 $n+1$ 次选择的序列为一个*方案*。可以发现，恰好有 $2\\cdot 2\\cdot 2\\cdot\\cdots\\cdot 2=2^{n+1}$ 种可能的方案。（即使在一些宣布中，两个选项是完全相同的，我们认为“前者”“后者”选择不同为不同的方案。）\n\n下面是克莱尔可能选择的 $16$ 种方案之一：\n\n1. “前者”：爱丽丝将取 $1$。\n2. “前者”：鲍勃将取 $2$。\n3. “后者”：爱丽丝将取 $2$。\n4. “前者”：鲍勃将取 $1$。\n\n在第三阶段，爱丽丝和鲍勃根据克莱尔的选择开始取石子。第一个无法做出要求的操作的人——因为那个石子已经被取走——输掉游戏。注意到有 $n$ 个石子和 $n+1$ 次操作，一个玩家必然最终输掉游戏。\n\n在上面的例子中，爱丽丝先取走 $1$。鲍勃接着取走 $2$。爱丽丝希望继续取走 $2$，但它已经被取走了，所以爱丽丝输掉了游戏，鲍勃因此获胜。\n\n你已知整数 $n$，和第一阶段某一时刻的游戏状态：一个长度为 $k$ 的已经做出的宣布序列。这些宣布可以是完全随意的。\n\n从此时开始，爱丽丝和鲍勃会以最优方式玩游戏，也就是说：\n\n无论爱丽丝和鲍勃怎么玩，克莱尔都均匀随机地从 $2^{n+1}$ 种可能的方案中选择一个。爱丽丝和鲍勃知道这一点，因此当以最优方式玩游戏时，他们都尽力最小化他们输的方案数。\n\n假设爱丽丝和鲍勃会按照上面描述的方式继续游戏。请分别求出两个人赢得游戏的方案数。", "inputFormat": "第一行两个整数 $n,k$：石头数和已经做出的宣布数。\n\n接下来 $k$ 行，每行按照顺序描述一次宣布。每行两个整数：两个石头的编号（在 $1\\sim n$ 且不一定不同）。\n\n注意到当 $k < n+1$ 时，下一个做出宣布的玩家由 $k$ 的奇偶性决定。", "outputFormat": "一行，两个整数：爱丽丝赢的方案数、鲍勃赢的方案数，假设他们都按照上面描述的方式继续玩游戏。\n\n注意到这两个整数的和应当为 $2^{n+1}$。", "hint": "**样例 $1$ 解释**\n\n这个样例与【题目描述】中给出的相同。不需要做出更多的宣布了，因此我们只需要计算多少种方案会导致爱丽丝赢，多少种方案会导致鲍勃赢。爱丽丝赢当且仅当克莱尔在第一步选择了 $1$，且在第三步选择了 $3$。其他方案都会导致爱丽丝输。\n\n---\n\n**样例 $2$ 解释**\n\n如果爱丽丝先宣布 $(1,1)$，鲍勃会宣布 $(2,2)$，无论爱丽丝接下来宣布什么，她都会输，因为克莱尔会在第一步选择 $1$，在第二步选择 $2$，第三步就没有剩下的石头给爱丽丝取了。然而，这不是爱丽丝第一步的最优方案：她应该首先宣布 $(1,2)$。然后，无论鲍勃和爱丽丝在后两步如何宣布，他们都会赢 $8$ 种方案中的 $4$ 种。\n\n---\n\n**数据范围**\n\n对于全部数据，$1\\le n\\le 35$，$0\\le k\\le n+1$。\n\n- 子任务一（$15$ 分）：$n\\le 4$。\n- 子任务二（$34$ 分）：$n\\le 10$。\n- 子任务三（$20$ 分）：$n\\le 25$。\n- 子任务四（$10$ 分）：$k=0$。\n- 子任务五（$21$ 分）：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[EGOI 2021] Double Move / 二选一游戏", "background": "Day 2 Problem D.\n\n题面译自 [EGOI2021 doublemove](https://stats.egoi.org/media/task_description/2021_doublemove_en.pdf)。", "description": "爱丽丝和鲍勃在玩游戏，克莱尔在帮助他们。共有 $n$ 颗石子，编号从 $1$ 到 $n$。游戏分为三个阶段。\n\n在第一阶段，爱丽丝和鲍勃轮流操作，爱丽丝先手。在每次操作中，玩家宣布他们要拿的石头，但不直接说出拿哪一个，而是给出两个选项。两个选项可能是相同的。也有可能说出已经说过的石头。第一阶段不取石子——玩家只是宣布他们在第二阶段的意图。第一阶段在宣布 $n+1$ 次后结束。\n\n下面是 $n=3$ 的第一阶段的例子：\n\n1. 爱丽丝：“我会取走 $1$ 或 $3$”\n2. 鲍勃：“我会取走 $2$ 或 $2$”\n3. 爱丽丝：“我会取走 $3$ 或 $2$”\n4. 鲍勃：“我会取走 $1$ 或 $3$”\n\n在第二阶段，对于 $n+1$ 次宣布的每一个，克莱尔用说“前者”或“后者”的方式从两个选项中选择一个。我们称克莱尔做出的 $n+1$ 次选择的序列为一个*方案*。可以发现，恰好有 $2\\cdot 2\\cdot 2\\cdot\\cdots\\cdot 2=2^{n+1}$ 种可能的方案。（即使在一些宣布中，两个选项是完全相同的，我们认为“前者”“后者”选择不同为不同的方案。）\n\n下面是克莱尔可能选择的 $16$ 种方案之一：\n\n1. “前者”：爱丽丝将取 $1$。\n2. “前者”：鲍勃将取 $2$。\n3. “后者”：爱丽丝将取 $2$。\n4. “前者”：鲍勃将取 $1$。\n\n在第三阶段，爱丽丝和鲍勃根据克莱尔的选择开始取石子。第一个无法做出要求的操作的人——因为那个石子已经被取走——输掉游戏。注意到有 $n$ 个石子和 $n+1$ 次操作，一个玩家必然最终输掉游戏。\n\n在上面的例子中，爱丽丝先取走 $1$。鲍勃接着取走 $2$。爱丽丝希望继续取走 $2$，但它已经被取走了，所以爱丽丝输掉了游戏，鲍勃因此获胜。\n\n你已知整数 $n$，和第一阶段某一时刻的游戏状态：一个长度为 $k$ 的已经做出的宣布序列。这些宣布可以是完全随意的。\n\n从此时开始，爱丽丝和鲍勃会以最优方式玩游戏，也就是说：\n\n无论爱丽丝和鲍勃怎么玩，克莱尔都均匀随机地从 $2^{n+1}$ 种可能的方案中选择一个。爱丽丝和鲍勃知道这一点，因此当以最优方式玩游戏时，他们都尽力最小化他们输的方案数。\n\n假设爱丽丝和鲍勃会按照上面描述的方式继续游戏。请分别求出两个人赢得游戏的方案数。", "inputFormat": "第一行两个整数 $n,k$：石头数和已经做出的宣布数。\n\n接下来 $k$ 行，每行按照顺序描述一次宣布。每行两个整数：两个石头的编号（在 $1\\sim n$ 且不一定不同）。\n\n注意到当 $k < n+1$ 时，下一个做出宣布的玩家由 $k$ 的奇偶性决定。", "outputFormat": "一行，两个整数：爱丽丝赢的方案数、鲍勃赢的方案数，假设他们都按照上面描述的方式继续玩游戏。\n\n注意到这两个整数的和应当为 $2^{n+1}$。", "hint": "**样例 $1$ 解释**\n\n这个样例与【题目描述】中给出的相同。不需要做出更多的宣布了，因此我们只需要计算多少种方案会导致爱丽丝赢，多少种方案会导致鲍勃赢。爱丽丝赢当且仅当克莱尔在第一步选择了 $1$，且在第三步选择了 $3$。其他方案都会导致爱丽丝输。\n\n---\n\n**样例 $2$ 解释**\n\n如果爱丽丝先宣布 $(1,1)$，鲍勃会宣布 $(2,2)$，无论爱丽丝接下来宣布什么，她都会输，因为克莱尔会在第一步选择 $1$，在第二步选择 $2$，第三步就没有剩下的石头给爱丽丝取了。然而，这不是爱丽丝第一步的最优方案：她应该首先宣布 $(1,2)$。然后，无论鲍勃和爱丽丝在后两步如何宣布，他们都会赢 $8$ 种方案中的 $4$ 种。\n\n---\n\n**数据范围**\n\n对于全部数据，$1\\le n\\le 35$，$0\\le k\\le n+1$。\n\n- 子任务一（$15$ 分）：$n\\le 4$。\n- 子任务二（$34$ 分）：$n\\le 10$。\n- 子任务三（$20$ 分）：$n\\le 25$。\n- 子任务四（$10$ 分）：$k=0$。\n- 子任务五（$21$ 分）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P9317", "type": "P", "difficulty": 3, "samples": [["2\n4\n0 3 0 3\n5\n4 1 0 2 0", "4\n10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2022", "O2优化", "EGOI（欧洲/女生）"], "title": "[EGOI 2022] SubsetMex / 子集 mex", "background": "Day 1 Problem A.\n\n题面译自 [EGOI2022 subsetmex](https://stats.egoi.org/media/task_description/2022_subsetmex_en.pdf)。\n\n[![CC BY-SA 3.0](https://licensebuttons.net/l/by-sa/3.0/80x15.png)](https://creativecommons.org/licenses/by-sa/3.0/)", "description": "一个*可重集*是元素可以重复出现的集合。例如，$\\{0,0,1,2,2,5,5,5,8\\}$ 是一个可重集。\n\n给定一个可重集 $S$，值域为 $\\N$，和一个目标自然数 $n$（$n\\notin S$），你的目标是通过重复进行若干次以下的操作，使得 $n\\in S$：\n\n1. 选择一个（可以为空的）子集 $T\\subseteq S$，其中 $T$ 不包含重复元素。\n2. 在 $S$ 中删除 $T$ 中的元素。（重复元素只删除一个。）\n3. 将 $\\operatorname{mex}(T)$ 插入 $S$，其中 $\\operatorname{mex}(T)$ 是最小的不在 $T$ 中的自然数。$\\operatorname{mex}$ 意味着“最小不包含”的值。\n\n你需要求出最少的能使得 $n\\in S$ 的操作次数。\n\n由于 $|S|$ 可能很大，它将以一个大小为 $n$ 的列表 $(f_0,\\ldots f_{n-1})$ 的形式给出，其中 $f_i$ 代表 $i$ 在 $S$ 中的出现次数。（请回忆 $n$ 是我们想要插入 $S$ 的元素。）", "inputFormat": "第一行一个整数 $t$——数据组数。之后每两行描述一组数据：\n\n- 每组数据的第一行一个整数 $n$，表示要插入 $S$ 的元素。\n- 每组数据的第二行 $n$ 个整数 $f_0,f_1,\\ldots,f_{n-1}$，按照上述方式描述了集合 $S$。", "outputFormat": "对于每组数据，输出一行一个整数，表示最少操作次数。", "hint": "**样例 $1$ 解释**\n\n初始 $S=\\{1,1,1,3,3,3\\}$，目标是使得 $4\\in S$。我们如下操作：\n\n1. 令 $T=\\varnothing$，则 $S=\\{0,1,1,1,3,3,3\\}$。\n2. 令 $T=\\{0,1,3\\}$，则 $S=\\{1,1,2,3,3\\}$。\n3. 令 $T=\\{1\\}$，则 $S=\\{0,1,2,3,3\\}$。\n4. 令 $T=\\{0,1,2,3\\}$，则 $S=\\{3,4\\}$。\n\n---\n\n**数据范围**\n\n对于全部数据，$1\\le t\\le 200$，$1\\le n\\le 50$，$0\\le f_i\\le 10^{16}$。\n\n- 子任务一（$5$ 分）：$n\\le 2$。\n- 子任务二（$17$ 分）：$n\\le 20$。\n- 子任务三（$7$ 分）：$f_i=0$。\n- 子任务四（$9$ 分）：$f_i\\le 1$。\n- 子任务五（$20$ 分）：$f_i\\le 2\\times 10^3$。\n- 子任务六（$9$ 分）：$f_0\\le 10^{16}$ 且 $\\forall j\\ne 0,f_j=0$。\n- 子任务七（$10$ 分）：$\\exists i,f_i\\le 10^{16}$ 且 $\\forall j\\ne i,f_j=0$。\n- 子任务八（$23$ 分）：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[EGOI 2022] SubsetMex / 子集 mex", "background": "Day 1 Problem A.\n\n题面译自 [EGOI2022 subsetmex](https://stats.egoi.org/media/task_description/2022_subsetmex_en.pdf)。\n\n[![CC BY-SA 3.0](https://licensebuttons.net/l/by-sa/3.0/80x15.png)](https://creativecommons.org/licenses/by-sa/3.0/)", "description": "一个*可重集*是元素可以重复出现的集合。例如，$\\{0,0,1,2,2,5,5,5,8\\}$ 是一个可重集。\n\n给定一个可重集 $S$，值域为 $\\N$，和一个目标自然数 $n$（$n\\notin S$），你的目标是通过重复进行若干次以下的操作，使得 $n\\in S$：\n\n1. 选择一个（可以为空的）子集 $T\\subseteq S$，其中 $T$ 不包含重复元素。\n2. 在 $S$ 中删除 $T$ 中的元素。（重复元素只删除一个。）\n3. 将 $\\operatorname{mex}(T)$ 插入 $S$，其中 $\\operatorname{mex}(T)$ 是最小的不在 $T$ 中的自然数。$\\operatorname{mex}$ 意味着“最小不包含”的值。\n\n你需要求出最少的能使得 $n\\in S$ 的操作次数。\n\n由于 $|S|$ 可能很大，它将以一个大小为 $n$ 的列表 $(f_0,\\ldots f_{n-1})$ 的形式给出，其中 $f_i$ 代表 $i$ 在 $S$ 中的出现次数。（请回忆 $n$ 是我们想要插入 $S$ 的元素。）", "inputFormat": "第一行一个整数 $t$——数据组数。之后每两行描述一组数据：\n\n- 每组数据的第一行一个整数 $n$，表示要插入 $S$ 的元素。\n- 每组数据的第二行 $n$ 个整数 $f_0,f_1,\\ldots,f_{n-1}$，按照上述方式描述了集合 $S$。", "outputFormat": "对于每组数据，输出一行一个整数，表示最少操作次数。", "hint": "**样例 $1$ 解释**\n\n初始 $S=\\{1,1,1,3,3,3\\}$，目标是使得 $4\\in S$。我们如下操作：\n\n1. 令 $T=\\varnothing$，则 $S=\\{0,1,1,1,3,3,3\\}$。\n2. 令 $T=\\{0,1,3\\}$，则 $S=\\{1,1,2,3,3\\}$。\n3. 令 $T=\\{1\\}$，则 $S=\\{0,1,2,3,3\\}$。\n4. 令 $T=\\{0,1,2,3\\}$，则 $S=\\{3,4\\}$。\n\n---\n\n**数据范围**\n\n对于全部数据，$1\\le t\\le 200$，$1\\le n\\le 50$，$0\\le f_i\\le 10^{16}$。\n\n- 子任务一（$5$ 分）：$n\\le 2$。\n- 子任务二（$17$ 分）：$n\\le 20$。\n- 子任务三（$7$ 分）：$f_i=0$。\n- 子任务四（$9$ 分）：$f_i\\le 1$。\n- 子任务五（$20$ 分）：$f_i\\le 2\\times 10^3$。\n- 子任务六（$9$ 分）：$f_0\\le 10^{16}$ 且 $\\forall j\\ne 0,f_j=0$。\n- 子任务七（$10$ 分）：$\\exists i,f_i\\le 10^{16}$ 且 $\\forall j\\ne i,f_j=0$。\n- 子任务八（$23$ 分）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P9318", "type": "P", "difficulty": 6, "samples": [["2 2", "3"], ["3 3", "12"], ["5 7", "1436232"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2022", "O2优化", "EGOI（欧洲/女生）"], "title": "[EGOI 2022] Lego Wall / 乐高墙", "background": "Day 1 Problem B.\n\n题面译自 [EGOI2022 legowall](https://stats.egoi.org/media/task_description/2022_legowall_en.pdf)。\n\n[![CC BY-SA 3.0](https://licensebuttons.net/l/by-sa/3.0/80x15.png)](https://creativecommons.org/licenses/by-sa/3.0/)\n", "description": "有两种乐高积木，大小分别为 $1\\times 1\\times 1$ 和 $2\\times 1\\times 1$（宽、高、长）。两种积木你都有无限个，每种积木的所有积木块没有任何区别。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1y2rwj59.png)\n\n一个积木块总是以正确的方向使用。四周的面是用同一种材料制成的，除了大小以外没有区别。\n\n我们称两个积木块**锁死**，当且仅当一个块在另一个块的正上方。称两个积木块 $b_0$ 和 $b_k$ **连通**，当且仅当存在一个积木块序列 $b_0,b_1,\\ldots,b_k$，使得任意相邻积木块 $b_{i-1}$ 和 $b_i$ 锁死。我们称一组积木块**连通**，当且仅当组内的每一对积木块都连通。\n\n你希望搭建一个大小为 $w\\times h\\times 1$ 的积木墙，使得这面墙**没有洞**且**连通**。以下是 $4\\times 3\\times 1$ 的积木墙的例子：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ehrcz8d7.png)\n\n另一方面，下面的 $4\\times 3\\times 1$ 的积木墙不连通，因此不被需要：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/twsqgt8x.png)\n\n有多少种搭建**没有洞**且**连通**的积木墙的方案呢？答案可能很大，请输出它对 $10^9+7$ 取模的结果。\n\n注意一个积木墙的镜像版本（旋转 $180^\\circ$）和原来的版本被认为不同，除非他们看起来一模一样。", "inputFormat": "一行，两个整数 $w,h$——积木墙的宽度和高度。", "outputFormat": "一行，一个整数，表示方案数对 $10^9+7$ 取模的结果。", "hint": "**样例 $1$ 解释**\n\n三种方案如图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yi7xhw9f.png)\n\n---\n\n**数据范围**\n\n对于全部数据，$1\\le w\\le 2.5\\times 10^5$，$2\\le h\\le 2.5\\times 10^5$，$w\\times h\\le 5\\times 10^5$。\n\n- 子任务一（$14$ 分）：$w=2$。\n- 子任务二（$12$ 分）：$h=2$。\n- 子任务三（$18$ 分）：$w,h\\le 100$。\n- 子任务四（$30$ 分）：$w\\le 700$。\n- 子任务五（$20$ 分）：$h\\le 700$。\n- 子任务六（$6$ 分）：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[EGOI 2022] Lego Wall / 乐高墙", "background": "Day 1 Problem B.\n\n题面译自 [EGOI2022 legowall](https://stats.egoi.org/media/task_description/2022_legowall_en.pdf)。\n\n[![CC BY-SA 3.0](https://licensebuttons.net/l/by-sa/3.0/80x15.png)](https://creativecommons.org/licenses/by-sa/3.0/)\n", "description": "有两种乐高积木，大小分别为 $1\\times 1\\times 1$ 和 $2\\times 1\\times 1$（宽、高、长）。两种积木你都有无限个，每种积木的所有积木块没有任何区别。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1y2rwj59.png)\n\n一个积木块总是以正确的方向使用。四周的面是用同一种材料制成的，除了大小以外没有区别。\n\n我们称两个积木块**锁死**，当且仅当一个块在另一个块的正上方。称两个积木块 $b_0$ 和 $b_k$ **连通**，当且仅当存在一个积木块序列 $b_0,b_1,\\ldots,b_k$，使得任意相邻积木块 $b_{i-1}$ 和 $b_i$ 锁死。我们称一组积木块**连通**，当且仅当组内的每一对积木块都连通。\n\n你希望搭建一个大小为 $w\\times h\\times 1$ 的积木墙，使得这面墙**没有洞**且**连通**。以下是 $4\\times 3\\times 1$ 的积木墙的例子：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ehrcz8d7.png)\n\n另一方面，下面的 $4\\times 3\\times 1$ 的积木墙不连通，因此不被需要：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/twsqgt8x.png)\n\n有多少种搭建**没有洞**且**连通**的积木墙的方案呢？答案可能很大，请输出它对 $10^9+7$ 取模的结果。\n\n注意一个积木墙的镜像版本（旋转 $180^\\circ$）和原来的版本被认为不同，除非他们看起来一模一样。", "inputFormat": "一行，两个整数 $w,h$——积木墙的宽度和高度。", "outputFormat": "一行，一个整数，表示方案数对 $10^9+7$ 取模的结果。", "hint": "**样例 $1$ 解释**\n\n三种方案如图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yi7xhw9f.png)\n\n---\n\n**数据范围**\n\n对于全部数据，$1\\le w\\le 2.5\\times 10^5$，$2\\le h\\le 2.5\\times 10^5$，$w\\times h\\le 5\\times 10^5$。\n\n- 子任务一（$14$ 分）：$w=2$。\n- 子任务二（$12$ 分）：$h=2$。\n- 子任务三（$18$ 分）：$w,h\\le 100$。\n- 子任务四（$30$ 分）：$w\\le 700$。\n- 子任务五（$20$ 分）：$h\\le 700$。\n- 子任务六（$6$ 分）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P9319", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2022", "交互题", "Special Judge", "O2优化", "EGOI（欧洲/女生）"], "title": "[EGOI 2022] Social Engineering / 社会工程", "background": "Day 1 Problem C.\n\n题面译自 [EGOI2022 socialengineering](https://stats.egoi.org/media/task_description/2022_socialengineering_en.pdf)。\n\n[![CC BY-SA 3.0](https://licensebuttons.net/l/by-sa/3.0/80x15.png)](https://creativecommons.org/licenses/by-sa/3.0/)\n\n**本题是一道 Grader 交互题。**\n\n本题只支持 C++ 提交，提交时不需要包含 `socialengineering.h` 头文件，但需要在代码中包含 `GetMove` 和 `MakeMove` 函数的声明（见【交互方式】部分）。\n\n请使用 C++14、C++17 等语言，**而不是 C++14 (GCC 9)**，因为一些未知原因这个语言下 SPJ 会 CE。\n\n感谢 @[FFTotoro](https://www.luogu.com.cn/user/556366) 提供交互库和测试数据。", "description": "一个社交网络是一个 $n$ 点 $m$ 边的无向连通图组成，其中每个点代表一个人，如果两个人之间有边相连，他们就是朋友。\n\n玛丽亚是这个社交网络的成员。她喜欢以各种事情挑战她的朋友。这意味着，她首先执行一些简单的任务，然后挑战她的一个朋友做同样的事情。这个朋友随后会挑战他的一个朋友，而被挑战的朋友会接着挑战他的另一个朋友，以此类推。同一个人可能会被挑战多次，但每一个无序朋友对最多进行一次挑战。（一旦 A 挑战了 B，那么 A 和 B 都不能再次挑战对方。）换句话说，挑战可以看作图中的一条路径，其中一条边至多经过一次。\n\n如果轮到一个人，而他又不能挑战任何朋友，那么这个人就输了。挑战总是由玛丽亚开始，她很少输。现在其他 $n-1$ 人决定合作，以使玛丽亚输掉下一次挑战，请你帮助他们完成目标。\n\n---\n\n**交互方式**\n\n你必须实现一个函数：\n\n```cpp\nvoid SocialEngineering(int n, int m, vector<pair<int,int>> edges);\n```\n\n这个函数在 $n$ 点 $m$ 边的图上玩该游戏。这个函数会被交互库调用恰好一次。列表 `edges` 包含恰好 $m$ 对整数 $(u,v)$，表示有一条连接点 $u$ 和点 $v$ 的边。节点编号从 $1$ 到 $n$。玛丽亚永远是节点 $1$。你的函数可以调用以下函数：\n\n```cpp\nint GetMove();\n```\n\n这个函数应当在玛丽亚的回合被调用，例如游戏的最开始。如果你在不是玛丽亚的回合调用这个函数，你会 WA。这个函数可以返回以下值之一：\n\n- 一个整数 $v$，其中 $2\\le v\\le n$。这意味着玛丽亚挑战编号为 $v$ 的人。保证这一步一定合法。\n- $0$，如果玛丽亚认输。当玛丽亚没有合法操作时，她就会认输。当这发生时，你的程序应当使 `SocialEngineering` 函数返回，然后你会 AC。\n\n```cpp\nvoid MakeMove(int v);\n```\n\n这个函数应当在不是玛丽亚的回合被调用。这意味着当前回合的人挑战第 $v$ 个人。如果这一步不合法，或者在玛丽亚的回合调用这个函数，你会 WA。如果在游戏开始时，玛丽亚有必胜策略，你的程序应当在第一次调用 `GetMove()` 前使 `SocialEngineering` 函数返回，然后你会 AC。", "inputFormat": "见【交互方式】部分。", "outputFormat": "见【交互方式】部分。", "hint": "**样例交互过程 $1$**\n\n|你的操作|交互库的操作|解释说明|\n|:-|:-|:-|\n||`SocialEngineering(5, 6, {{1,4}, {1,5}, {2,4}, {2,5}, {2,3}, {3,5}})`|`SocialEngineering` 被调用，参数为一个 $5$ 点 $6$ 边的图。|\n|`GetMove()`|返回 $4$|玛丽亚挑战第 $4$ 个人。|\n|`MakeMove(2)`||第 $4$ 个人挑战第 $2$ 个人。|\n|`MakeMove(5)`||第 $2$ 个人挑战第 $5$ 个人。|\n|`MakeMove(1)`||第 $5$ 个人挑战玛丽亚。|\n|`GetMove()`|返回 $0$|玛丽亚没有合法操作，所以她认输。|\n|返回||你赢了游戏，应当使 `SocialEngineering` 函数返回。|\n\n---\n\n**样例交互过程 $2$**\n\n|你的操作|交互库的操作|解释说明|\n|:-|:-|:-|\n||`SocialEngineering(5, 1, {{1,2}})`|`SocialEngineering` 被调用，参数为一个 $2$ 点 $1$ 边的图。|\n|返回||玛丽亚有必胜策略，你的程序应当在未调用 `GetMove()` 前使 `SocialEngineering` 函数返回以认输。|\n\n---\n\n**数据范围**\n\n对于全部数据，$2\\le n\\le 2\\times 10^5$，$1\\le m\\le 4\\times 10^5$。保证图连通，每对无序点对至多作为边出现一次，每条边连接两个不同节点。\n\n当玛丽亚有必胜策略时，她会完美地执行必胜策略。如果她没有必胜策略，她会试图以各种聪明的手段引诱你的程序犯错误。除子任务三外，只有当玛丽亚没有合法操作时，她才会认输。\n\n- 子任务一（$15$ 分）：$n,m\\le 10$。\n- 子任务二（$15$ 分）：除玛丽亚外，每个人至多有 $2$ 个朋友。\n- 子任务三（$20$ 分）：除非玛丽亚有必胜策略，否则她会立即认输。\n- 子任务四（$25$ 分）：$n,m\\le 100$。\n- 子任务五（$25$ 分）：无特殊限制。\n\n---\n\n感谢 @[FFTotoro](https://www.luogu.com.cn/user/556366) 提供交互库和测试数据。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[EGOI 2022] Social Engineering / 社会工程", "background": "Day 1 Problem C.\n\n题面译自 [EGOI2022 socialengineering](https://stats.egoi.org/media/task_description/2022_socialengineering_en.pdf)。\n\n[![CC BY-SA 3.0](https://licensebuttons.net/l/by-sa/3.0/80x15.png)](https://creativecommons.org/licenses/by-sa/3.0/)\n\n**本题是一道 Grader 交互题。**\n\n本题只支持 C++ 提交，提交时不需要包含 `socialengineering.h` 头文件，但需要在代码中包含 `GetMove` 和 `MakeMove` 函数的声明（见【交互方式】部分）。\n\n请使用 C++14、C++17 等语言，**而不是 C++14 (GCC 9)**，因为一些未知原因这个语言下 SPJ 会 CE。\n\n感谢 @[FFTotoro](https://www.luogu.com.cn/user/556366) 提供交互库和测试数据。", "description": "一个社交网络是一个 $n$ 点 $m$ 边的无向连通图组成，其中每个点代表一个人，如果两个人之间有边相连，他们就是朋友。\n\n玛丽亚是这个社交网络的成员。她喜欢以各种事情挑战她的朋友。这意味着，她首先执行一些简单的任务，然后挑战她的一个朋友做同样的事情。这个朋友随后会挑战他的一个朋友，而被挑战的朋友会接着挑战他的另一个朋友，以此类推。同一个人可能会被挑战多次，但每一个无序朋友对最多进行一次挑战。（一旦 A 挑战了 B，那么 A 和 B 都不能再次挑战对方。）换句话说，挑战可以看作图中的一条路径，其中一条边至多经过一次。\n\n如果轮到一个人，而他又不能挑战任何朋友，那么这个人就输了。挑战总是由玛丽亚开始，她很少输。现在其他 $n-1$ 人决定合作，以使玛丽亚输掉下一次挑战，请你帮助他们完成目标。\n\n---\n\n**交互方式**\n\n你必须实现一个函数：\n\n```cpp\nvoid SocialEngineering(int n, int m, vector<pair<int,int>> edges);\n```\n\n这个函数在 $n$ 点 $m$ 边的图上玩该游戏。这个函数会被交互库调用恰好一次。列表 `edges` 包含恰好 $m$ 对整数 $(u,v)$，表示有一条连接点 $u$ 和点 $v$ 的边。节点编号从 $1$ 到 $n$。玛丽亚永远是节点 $1$。你的函数可以调用以下函数：\n\n```cpp\nint GetMove();\n```\n\n这个函数应当在玛丽亚的回合被调用，例如游戏的最开始。如果你在不是玛丽亚的回合调用这个函数，你会 WA。这个函数可以返回以下值之一：\n\n- 一个整数 $v$，其中 $2\\le v\\le n$。这意味着玛丽亚挑战编号为 $v$ 的人。保证这一步一定合法。\n- $0$，如果玛丽亚认输。当玛丽亚没有合法操作时，她就会认输。当这发生时，你的程序应当使 `SocialEngineering` 函数返回，然后你会 AC。\n\n```cpp\nvoid MakeMove(int v);\n```\n\n这个函数应当在不是玛丽亚的回合被调用。这意味着当前回合的人挑战第 $v$ 个人。如果这一步不合法，或者在玛丽亚的回合调用这个函数，你会 WA。如果在游戏开始时，玛丽亚有必胜策略，你的程序应当在第一次调用 `GetMove()` 前使 `SocialEngineering` 函数返回，然后你会 AC。", "inputFormat": "见【交互方式】部分。", "outputFormat": "见【交互方式】部分。", "hint": "**样例交互过程 $1$**\n\n|你的操作|交互库的操作|解释说明|\n|:-|:-|:-|\n||`SocialEngineering(5, 6, {{1,4}, {1,5}, {2,4}, {2,5}, {2,3}, {3,5}})`|`SocialEngineering` 被调用，参数为一个 $5$ 点 $6$ 边的图。|\n|`GetMove()`|返回 $4$|玛丽亚挑战第 $4$ 个人。|\n|`MakeMove(2)`||第 $4$ 个人挑战第 $2$ 个人。|\n|`MakeMove(5)`||第 $2$ 个人挑战第 $5$ 个人。|\n|`MakeMove(1)`||第 $5$ 个人挑战玛丽亚。|\n|`GetMove()`|返回 $0$|玛丽亚没有合法操作，所以她认输。|\n|返回||你赢了游戏，应当使 `SocialEngineering` 函数返回。|\n\n---\n\n**样例交互过程 $2$**\n\n|你的操作|交互库的操作|解释说明|\n|:-|:-|:-|\n||`SocialEngineering(5, 1, {{1,2}})`|`SocialEngineering` 被调用，参数为一个 $2$ 点 $1$ 边的图。|\n|返回||玛丽亚有必胜策略，你的程序应当在未调用 `GetMove()` 前使 `SocialEngineering` 函数返回以认输。|\n\n---\n\n**数据范围**\n\n对于全部数据，$2\\le n\\le 2\\times 10^5$，$1\\le m\\le 4\\times 10^5$。保证图连通，每对无序点对至多作为边出现一次，每条边连接两个不同节点。\n\n当玛丽亚有必胜策略时，她会完美地执行必胜策略。如果她没有必胜策略，她会试图以各种聪明的手段引诱你的程序犯错误。除子任务三外，只有当玛丽亚没有合法操作时，她才会认输。\n\n- 子任务一（$15$ 分）：$n,m\\le 10$。\n- 子任务二（$15$ 分）：除玛丽亚外，每个人至多有 $2$ 个朋友。\n- 子任务三（$20$ 分）：除非玛丽亚有必胜策略，否则她会立即认输。\n- 子任务四（$25$ 分）：$n,m\\le 100$。\n- 子任务五（$25$ 分）：无特殊限制。\n\n---\n\n感谢 @[FFTotoro](https://www.luogu.com.cn/user/556366) 提供交互库和测试数据。", "locale": "zh-CN"}}}
{"pid": "P9320", "type": "P", "difficulty": 6, "samples": [["8 4 11\n1 4 8 1\n6 4\n6 3\n3 7\n6 5\n5 1\n1 2\n1 8\nq 4\nt 3 4 5\nt 2 2 7\nq 4\ne 5 10\ne 1 5\nq 4\nt 1 1 5\nt 2 2 1\nq 1\nq 2", "0\n-1\n9\n4\n-7"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2022", "O2优化", "EGOI（欧洲/女生）"], "title": "[EGOI 2022] Tourists / 乌托邦旅行团", "background": "Day 1 Problem D.\n\n题面译自 [EGOI2022 tourists](https://stats.egoi.org/media/task_description/2022_tourists_en.pdf)。\n\n[![CC BY-SA 3.0](https://licensebuttons.net/l/by-sa/3.0/80x15.png)](https://creativecommons.org/licenses/by-sa/3.0/)", "description": "乌托邦有 $n$ 个城市，编号从 $1$ 到 $n$，还有 $n-1$ 条双向公路连接这些城市。只需使用这些道路就可以在每对城市之间旅行。由于乌托邦非常美丽，目前有 $m$ 个游客，编号从 $1$ 到 $m$，正在访问这个国家。最初，第 $i$ 个游客正在访问城市 $a_i$。多个游客可能在同一个城市；也就是说，对于 $i\\ne j$，可能有 $a_i=a_j$。\n\n每个游客都有一个关于他们目前在乌托邦的游览有多有趣的评分，用一个数字表示，初始的评分均为 $0$。为了鼓励游客进一步游览，乌托邦政$ $府希望通过在选定的城市组织活动来提高游客的评分。当一个活动在城市 $c$ 举行时，所有目前在那里的游客的评分将增加 $d$，其中 $d$ 是一个取决于活动类型的值。\n\n一些游客计划在乌托邦逗留期间在各城市之间旅行。尽管从一个城市到另一个城市几乎不需要花时间（由于高效的乌托邦道路），但它仍然是一种不便，从而导致游客评分的降低。具体地，一个游客如果走了一条由 $k$ 条道路组成的路径，他们的评分会降低 $k$（游客总是会选择两个城市之间最短的路径）。\n\n乌托邦政$ $府要求你记录下游客们旅行时的评分。作为要求的一部分，你将得到 $q$ 个查询作为输入的一部分。你应该按照输入的顺序回答所有的询问。", "inputFormat": "第一行三个整数 $n,m,q$——城市数、游客数、询问数。\n\n第二行 $m$ 个整数 $a_1,a_2,\\ldots,a_m$，其中 $a_i$ 为第 $i$ 个游客初始所在的城市。\n\n接下来 $n-1$ 行，每行两个整数 $v,w$，表示 $v,w$ 之间有一条双向边。\n\n接下来 $q$ 行，每行描述一个询问。每行的格式是以下三种之一：\n\n- 首先一个字母 `t`，接着三个整数 $f_i,g_i,c_i$：所有编号在 $[f_i,g_i]$ 的游客都前往城市 $c_i$。\n- 首先一个字母 `e`，接着两个整数 $c_i,d_i$：城市 $c_i$ 举办一个给评分增加 $d$ 的活动。\n- 首先一个字母 `q`，接着一个整数 $v_i$：询问现在游客 $v_i$ 的评分。\n\n保证输入中至少有一个操作 `q`。", "outputFormat": "对于所有操作 `q` 输出一行一个整数。", "hint": "**数据范围**\n\n对于全部数据，$2\\le n\\le 2\\times 10^5$，$1\\le m,q\\le 2\\times 10^5$，$1\\le a_i\\le n$，保证输入构成一棵树。操作 `t` 中，$1\\le f_i\\le g_i\\le m$，$1\\le c_i\\le n$。操作 `e` 中，$1\\le c_i\\le n$，$0\\le d_i\\le 10^9$。操作 `q` 中，$1\\le v_i\\le m$。\n\n- 子任务一（$10$ 分）：$n,m,q\\le 200$。\n- 子任务二（$15$ 分）：$n,m,q\\le 2\\times 10^3$。\n- 子任务三（$25$ 分）：$m,q\\le 2\\times 10^3$。\n- 子任务四（$25$ 分）：不存在操作 `e`。\n- 子任务五（$25$ 分）：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[EGOI 2022] Tourists / 乌托邦旅行团", "background": "Day 1 Problem D.\n\n题面译自 [EGOI2022 tourists](https://stats.egoi.org/media/task_description/2022_tourists_en.pdf)。\n\n[![CC BY-SA 3.0](https://licensebuttons.net/l/by-sa/3.0/80x15.png)](https://creativecommons.org/licenses/by-sa/3.0/)", "description": "乌托邦有 $n$ 个城市，编号从 $1$ 到 $n$，还有 $n-1$ 条双向公路连接这些城市。只需使用这些道路就可以在每对城市之间旅行。由于乌托邦非常美丽，目前有 $m$ 个游客，编号从 $1$ 到 $m$，正在访问这个国家。最初，第 $i$ 个游客正在访问城市 $a_i$。多个游客可能在同一个城市；也就是说，对于 $i\\ne j$，可能有 $a_i=a_j$。\n\n每个游客都有一个关于他们目前在乌托邦的游览有多有趣的评分，用一个数字表示，初始的评分均为 $0$。为了鼓励游客进一步游览，乌托邦政$ $府希望通过在选定的城市组织活动来提高游客的评分。当一个活动在城市 $c$ 举行时，所有目前在那里的游客的评分将增加 $d$，其中 $d$ 是一个取决于活动类型的值。\n\n一些游客计划在乌托邦逗留期间在各城市之间旅行。尽管从一个城市到另一个城市几乎不需要花时间（由于高效的乌托邦道路），但它仍然是一种不便，从而导致游客评分的降低。具体地，一个游客如果走了一条由 $k$ 条道路组成的路径，他们的评分会降低 $k$（游客总是会选择两个城市之间最短的路径）。\n\n乌托邦政$ $府要求你记录下游客们旅行时的评分。作为要求的一部分，你将得到 $q$ 个查询作为输入的一部分。你应该按照输入的顺序回答所有的询问。", "inputFormat": "第一行三个整数 $n,m,q$——城市数、游客数、询问数。\n\n第二行 $m$ 个整数 $a_1,a_2,\\ldots,a_m$，其中 $a_i$ 为第 $i$ 个游客初始所在的城市。\n\n接下来 $n-1$ 行，每行两个整数 $v,w$，表示 $v,w$ 之间有一条双向边。\n\n接下来 $q$ 行，每行描述一个询问。每行的格式是以下三种之一：\n\n- 首先一个字母 `t`，接着三个整数 $f_i,g_i,c_i$：所有编号在 $[f_i,g_i]$ 的游客都前往城市 $c_i$。\n- 首先一个字母 `e`，接着两个整数 $c_i,d_i$：城市 $c_i$ 举办一个给评分增加 $d$ 的活动。\n- 首先一个字母 `q`，接着一个整数 $v_i$：询问现在游客 $v_i$ 的评分。\n\n保证输入中至少有一个操作 `q`。", "outputFormat": "对于所有操作 `q` 输出一行一个整数。", "hint": "**数据范围**\n\n对于全部数据，$2\\le n\\le 2\\times 10^5$，$1\\le m,q\\le 2\\times 10^5$，$1\\le a_i\\le n$，保证输入构成一棵树。操作 `t` 中，$1\\le f_i\\le g_i\\le m$，$1\\le c_i\\le n$。操作 `e` 中，$1\\le c_i\\le n$，$0\\le d_i\\le 10^9$。操作 `q` 中，$1\\le v_i\\le m$。\n\n- 子任务一（$10$ 分）：$n,m,q\\le 200$。\n- 子任务二（$15$ 分）：$n,m,q\\le 2\\times 10^3$。\n- 子任务三（$25$ 分）：$m,q\\le 2\\times 10^3$。\n- 子任务四（$25$ 分）：不存在操作 `e`。\n- 子任务五（$25$ 分）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P9321", "type": "P", "difficulty": 3, "samples": [["5 4\n20 12 10 15 18\n3 4\n4 1\n1 3\n4 2", "11 10 10 9 8"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2022", "O2优化", "EGOI（欧洲/女生）"], "title": "[EGOI 2022] Data Centers / 数据中心", "background": "Day 2 Problem A.\n\n题面译自 [EGOI2022 datacenters](https://stats.egoi.org/media/task_description/2022_datacenters_en.pdf)。\n\n[![CC BY-SA 3.0](https://licensebuttons.net/l/by-sa/3.0/80x15.png)](https://creativecommons.org/licenses/by-sa/3.0/)", "description": "贡卡软件（贡软）是一家互联网公司，经营许多服务，在全球有 $n$ 个数据中心。每个数据中心都有一些可用的机器。出于安全和冗余的原因，每个服务都有一个或多个副本同时运行。每个副本在一个不同的数据中心运行，并需要一些机器来运行。一个服务的所有副本需要相同数量的机器。\n\n当贡软计划推出一项需要 $c_i$ 个副本，每个副本在 $m$ 台机器上运行的新的服务 $i$ 时，它按照当前可用机器对数据中心降序排序，然后在前 $c_i$ 个数据中心各使用 $m$ 台机器。\n\n请求出在推出 $s$ 个服务后，每个数据中心剩余的机器数量。", "inputFormat": "第一行两个整数 $n,s$，表示数据中心数和服务数。\n\n第二行 $n$ 个整数 $a_i$，表示每个数据中心初始可用机器数。\n\n接下来 $s$ 行，每行两个整数 $m_i,c_i$，表示需要的机器数、副本数。", "outputFormat": "一行，**降序排列**的 $n$ 个整数，表示每个数据中心剩余的机器数。", "hint": "**样例解释**\n\n|步骤|剩余机器数|操作|\n|:-|:-|:-|\n|初始|$[20,12,10,15,18]$||\n|服务 $1$ 前|$[20,18,15,12,10]$|数据中心降序排序|\n|服务 $1$ 后|$[17,15,12,9,10]$|前 $4$ 个数据中心各使用 $3$ 台机器|\n|服务 $2$ 前|$[17,15,12,10,9]$|数据中心降序排序|\n|服务 $2$ 后|$[13,15,12,10,9]$|第 $1$ 个数据中心使用 $4$ 台机器|\n|服务 $3$ 前|$[15,13,12,10,9]$|数据中心降序排序|\n|服务 $3$ 后|$[14,12,11,10,9]$|前 $3$ 个数据中心各使用 $1$ 台机器|\n|服务 $4$ 前|$[14,12,11,10,9]$|数据中心降序排序|\n|服务 $4$ 后|$[10,8,11,10,9]$|前 $2$ 个数据中心各使用 $4$ 台机器|\n|结束|$[11,10,10,9,8]$|数据中心降序排序|\n\n---\n\n**数据范围**\n\n对于全部数据，$1\\le n\\le 10^5$，$0\\le s\\le 5\\times 10^3$，$0\\le a_i\\le 10^9$，$1\\le m_i\\le 10^9$，$1\\le c_i\\le n$，保证任意时刻任意数据中心可用机器数非负。\n\n- 子任务一（$12$ 分）：$n\\le 100$，$s=0$。\n- 子任务二（$12$ 分）：$n\\le 100$，$s\\le 10$。\n- 子任务三（$9$ 分）：$n\\le 5\\times 10^4$，$s\\le 100$。\n- 子任务四（$26$ 分）：$a_i\\le 10^3$。\n- 子任务五（$18$ 分）：$c_i=1$。\n- 子任务六（$23$ 分）：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[EGOI 2022] Data Centers / 数据中心", "background": "Day 2 Problem A.\n\n题面译自 [EGOI2022 datacenters](https://stats.egoi.org/media/task_description/2022_datacenters_en.pdf)。\n\n[![CC BY-SA 3.0](https://licensebuttons.net/l/by-sa/3.0/80x15.png)](https://creativecommons.org/licenses/by-sa/3.0/)", "description": "贡卡软件（贡软）是一家互联网公司，经营许多服务，在全球有 $n$ 个数据中心。每个数据中心都有一些可用的机器。出于安全和冗余的原因，每个服务都有一个或多个副本同时运行。每个副本在一个不同的数据中心运行，并需要一些机器来运行。一个服务的所有副本需要相同数量的机器。\n\n当贡软计划推出一项需要 $c_i$ 个副本，每个副本在 $m$ 台机器上运行的新的服务 $i$ 时，它按照当前可用机器对数据中心降序排序，然后在前 $c_i$ 个数据中心各使用 $m$ 台机器。\n\n请求出在推出 $s$ 个服务后，每个数据中心剩余的机器数量。", "inputFormat": "第一行两个整数 $n,s$，表示数据中心数和服务数。\n\n第二行 $n$ 个整数 $a_i$，表示每个数据中心初始可用机器数。\n\n接下来 $s$ 行，每行两个整数 $m_i,c_i$，表示需要的机器数、副本数。", "outputFormat": "一行，**降序排列**的 $n$ 个整数，表示每个数据中心剩余的机器数。", "hint": "**样例解释**\n\n|步骤|剩余机器数|操作|\n|:-|:-|:-|\n|初始|$[20,12,10,15,18]$||\n|服务 $1$ 前|$[20,18,15,12,10]$|数据中心降序排序|\n|服务 $1$ 后|$[17,15,12,9,10]$|前 $4$ 个数据中心各使用 $3$ 台机器|\n|服务 $2$ 前|$[17,15,12,10,9]$|数据中心降序排序|\n|服务 $2$ 后|$[13,15,12,10,9]$|第 $1$ 个数据中心使用 $4$ 台机器|\n|服务 $3$ 前|$[15,13,12,10,9]$|数据中心降序排序|\n|服务 $3$ 后|$[14,12,11,10,9]$|前 $3$ 个数据中心各使用 $1$ 台机器|\n|服务 $4$ 前|$[14,12,11,10,9]$|数据中心降序排序|\n|服务 $4$ 后|$[10,8,11,10,9]$|前 $2$ 个数据中心各使用 $4$ 台机器|\n|结束|$[11,10,10,9,8]$|数据中心降序排序|\n\n---\n\n**数据范围**\n\n对于全部数据，$1\\le n\\le 10^5$，$0\\le s\\le 5\\times 10^3$，$0\\le a_i\\le 10^9$，$1\\le m_i\\le 10^9$，$1\\le c_i\\le n$，保证任意时刻任意数据中心可用机器数非负。\n\n- 子任务一（$12$ 分）：$n\\le 100$，$s=0$。\n- 子任务二（$12$ 分）：$n\\le 100$，$s\\le 10$。\n- 子任务三（$9$ 分）：$n\\le 5\\times 10^4$，$s\\le 100$。\n- 子任务四（$26$ 分）：$a_i\\le 10^3$。\n- 子任务五（$18$ 分）：$c_i=1$。\n- 子任务六（$23$ 分）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P9322", "type": "P", "difficulty": 5, "samples": [["2\nNKP\n3 3 5 1\nNKP\n2 6 5 3", "2\n2"], ["2\nB\n2 8 3 6\nB\n2 8 5 5", "-1\n1"], ["2\nQ\n3 3 4 5\nQR\n4 1 1 4", "2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2022", "O2优化", "EGOI（欧洲/女生）"], "title": "[EGOI 2022] Superpiece / 超级棋子", "background": "Day 2 Problem B.\n\n题面译自 [EGOI2022 superpiece](https://stats.egoi.org/media/task_description/2022_superpiece_en.pdf)。\n\n[![CC BY-SA 3.0](https://licensebuttons.net/l/by-sa/3.0/80x15.png)](https://creativecommons.org/licenses/by-sa/3.0/)", "description": "你有一个无限大的棋盘。在本题中，棋盘是一个无限大的二维方格，每个方格用 $(r,c)$ 表示，分别代表行和列。目前棋盘上有唯一一个棋子，叫做**超级棋子**。你有你的超级棋子的合法移动列表，它是一个非空字符串，是 `QRBNKP` 的子序列。在每个回合中，超级棋子可以作为给定的棋子之一移动。超级棋子初始位于 $(a,b)$，请求出到达 $(c,d)$ 的最少移动次数。\n\n在本题中可能用到的国际象棋规则如下：\n\n共有六种棋子：皇后、车、象、马、国王、兵。他们的移动方式如下：\n\n- **皇后**（`Q`）可以移动到同行、同列、同对角线的方格。形式化地，对于任意整数 $k\\ne 0$，皇后可以从 $(a,b)$ 移动到 $(a+k,b),(a,b+k),(a+k,b+k),(a+k,b-k)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1e4lh43e.png)\n\n- **车**（`R`）可以移动到同行、同列的方格。形式化地，对于任意整数 $k\\ne 0$，车可以从 $(a,b)$ 移动到 $(a+k,b),(a,b+k)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mwo8ut9o.png)\n\n- **象**（`B`）可以移动到同对角线的方格。形式化地，对于任意整数 $k\\ne 0$，象可以从 $(a,b)$ 移动到 $(a+k,b+k),(a+k,b-k)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dhfo04af.png)\n\n- **马**（`N`）可以移动一个 `L` 形，也就是：先在一个方向移动两格，再在与之垂直的方向移动一格。形式化地，马可以从 $(a,b)$ 移动到 $(a+1,b+2),(a+1,b-2),(a+2,b+1),(a+2,b-1),(a-2,b+1),(a-2,b-1),(a-1,b+2),(a-1,b-2)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jyxiv4s0.png)\n\n- **国王**（`K`）可以移动到相邻的八个格子。形式化地，国王可以从 $(a,b)$ 移动到 $(a,b+1),(a,b-1),(a+1,b),(a-1,b),(a+1,b+1),(a+1,b-1),(a-1,b+1),(a-1,b-1)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qhzd2gzf.png)\n\n- **兵**（`P`）可以向上移动一格。形式化地，兵可以从 $(a,b)$ 移动到 $(a+1,b)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g0dhy9au.png)\n\n请注意，你可能知道的关于国际象棋的其他规则并不适用于本题；请只使用上面列出的那些规则。", "inputFormat": "第一行一个整数 $q$，表示数据组数。之后每两行描述一组数据：\n\n- 每组数据的第一行一个非空字符串，是超级棋子的合法移动列表。这个字符串是 `QRBNKP` 的一个子集，所有字符**按相同顺序**出现。换句话说，它是 `QRBNKP` 的一个子序列。\n- 每组数据的第二行四个整数 $a,b,c,d$——超级棋子的初始和目标位置。保证 $(a,b)\\ne (c,d)$，也就是初始位置和目标位置不同。", "outputFormat": "对于每组数据，输出一行一个整数 $m$，表示最少移动次数。如果不可能到达目标位置，输出 $-1$。", "hint": "**样例 $1$ 解释**\n\n在第一组数据中，我们需要从 $(3,3)$ 走到 $(5,1)$，合法移动有马、国王、兵。有很多种需要两次移动的方案，例如：\n\n- 兵走到 $(4,3)$，马走到 $(5,1)$。\n- 马走到 $(5,2)$，国王走到 $(5,1)$。\n- 国王走到 $(4,2)$，国王走到 $(5,1)$。\n\n不存在少于两次移动的方案——我们需要象或者皇后才能做到。\n\n在第二组数据中，我们需要从 $(2,6)$ 走到 $(5,3)$。同样地，最优方案需要两次移动。此时，每一步都必须是马，利用 $(4,5)$ 或 $(3,4)$ 作为中转站。\n\n---\n\n**样例 $2$ 解释**\n\n在第一组数据中，我们需要从 $(2,8)$ 走到 $(3,6)$。只能按照象的方式走棋，这是不可能的。\n\n在第二组数据中，我们需要从 $(2,8)$ 走到 $(5,5)$，只能按照象的方式走棋。可以在两次移动内实现，例如，利用 $(4,4)$ 作为中转站。\n\n---\n\n**样例 $3$ 解释**\n\n在第一组数据中，我们需要从 $(3,3)$ 走到 $(4,5)$，只能按照皇后的方式走棋。可以利用 $(4,4)$ 为中转站两次移动到达。\n\n在第二组数据中，我们需要从 $(4,1)$ 走到 $(1,4)$，只能按照皇后和车的方式走棋。可以一次移动到达。\n\n---\n\n**数据范围**\n\n对于全部数据，$1\\le q\\le 10^3$，$-10^8\\le a,b,c,d\\le 10^8$。\n\n- 子任务一（$12$ 分）：保证存在 `Q`，保证不存在 `N`。\n- 子任务二（$9$ 分）：保证存在 `QN`。\n- 子任务三（$13$ 分）：保证存在 `R`，保证不存在 `Q`。\n- 子任务四（$8$ 分）：保证只存在 `B`。\n- 子任务五（$6$ 分）：保证存在 `B`，保证不存在 `QR`。\n- 子任务六（$31$ 分）：保证只存在 `N`。\n- 子任务七（$8$ 分）：保证存在 `N`，保证不存在 `QRB`。\n- 子任务八（$7$ 分）：保证存在 `K`，保证不存在 `QRBN`。\n- 子任务九（$6$ 分）：保证只存在 `P`。\n\n注意子任务**并不**按难度顺序排序。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[EGOI 2022] Superpiece / 超级棋子", "background": "Day 2 Problem B.\n\n题面译自 [EGOI2022 superpiece](https://stats.egoi.org/media/task_description/2022_superpiece_en.pdf)。\n\n[![CC BY-SA 3.0](https://licensebuttons.net/l/by-sa/3.0/80x15.png)](https://creativecommons.org/licenses/by-sa/3.0/)", "description": "你有一个无限大的棋盘。在本题中，棋盘是一个无限大的二维方格，每个方格用 $(r,c)$ 表示，分别代表行和列。目前棋盘上有唯一一个棋子，叫做**超级棋子**。你有你的超级棋子的合法移动列表，它是一个非空字符串，是 `QRBNKP` 的子序列。在每个回合中，超级棋子可以作为给定的棋子之一移动。超级棋子初始位于 $(a,b)$，请求出到达 $(c,d)$ 的最少移动次数。\n\n在本题中可能用到的国际象棋规则如下：\n\n共有六种棋子：皇后、车、象、马、国王、兵。他们的移动方式如下：\n\n- **皇后**（`Q`）可以移动到同行、同列、同对角线的方格。形式化地，对于任意整数 $k\\ne 0$，皇后可以从 $(a,b)$ 移动到 $(a+k,b),(a,b+k),(a+k,b+k),(a+k,b-k)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1e4lh43e.png)\n\n- **车**（`R`）可以移动到同行、同列的方格。形式化地，对于任意整数 $k\\ne 0$，车可以从 $(a,b)$ 移动到 $(a+k,b),(a,b+k)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mwo8ut9o.png)\n\n- **象**（`B`）可以移动到同对角线的方格。形式化地，对于任意整数 $k\\ne 0$，象可以从 $(a,b)$ 移动到 $(a+k,b+k),(a+k,b-k)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dhfo04af.png)\n\n- **马**（`N`）可以移动一个 `L` 形，也就是：先在一个方向移动两格，再在与之垂直的方向移动一格。形式化地，马可以从 $(a,b)$ 移动到 $(a+1,b+2),(a+1,b-2),(a+2,b+1),(a+2,b-1),(a-2,b+1),(a-2,b-1),(a-1,b+2),(a-1,b-2)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jyxiv4s0.png)\n\n- **国王**（`K`）可以移动到相邻的八个格子。形式化地，国王可以从 $(a,b)$ 移动到 $(a,b+1),(a,b-1),(a+1,b),(a-1,b),(a+1,b+1),(a+1,b-1),(a-1,b+1),(a-1,b-1)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qhzd2gzf.png)\n\n- **兵**（`P`）可以向上移动一格。形式化地，兵可以从 $(a,b)$ 移动到 $(a+1,b)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g0dhy9au.png)\n\n请注意，你可能知道的关于国际象棋的其他规则并不适用于本题；请只使用上面列出的那些规则。", "inputFormat": "第一行一个整数 $q$，表示数据组数。之后每两行描述一组数据：\n\n- 每组数据的第一行一个非空字符串，是超级棋子的合法移动列表。这个字符串是 `QRBNKP` 的一个子集，所有字符**按相同顺序**出现。换句话说，它是 `QRBNKP` 的一个子序列。\n- 每组数据的第二行四个整数 $a,b,c,d$——超级棋子的初始和目标位置。保证 $(a,b)\\ne (c,d)$，也就是初始位置和目标位置不同。", "outputFormat": "对于每组数据，输出一行一个整数 $m$，表示最少移动次数。如果不可能到达目标位置，输出 $-1$。", "hint": "**样例 $1$ 解释**\n\n在第一组数据中，我们需要从 $(3,3)$ 走到 $(5,1)$，合法移动有马、国王、兵。有很多种需要两次移动的方案，例如：\n\n- 兵走到 $(4,3)$，马走到 $(5,1)$。\n- 马走到 $(5,2)$，国王走到 $(5,1)$。\n- 国王走到 $(4,2)$，国王走到 $(5,1)$。\n\n不存在少于两次移动的方案——我们需要象或者皇后才能做到。\n\n在第二组数据中，我们需要从 $(2,6)$ 走到 $(5,3)$。同样地，最优方案需要两次移动。此时，每一步都必须是马，利用 $(4,5)$ 或 $(3,4)$ 作为中转站。\n\n---\n\n**样例 $2$ 解释**\n\n在第一组数据中，我们需要从 $(2,8)$ 走到 $(3,6)$。只能按照象的方式走棋，这是不可能的。\n\n在第二组数据中，我们需要从 $(2,8)$ 走到 $(5,5)$，只能按照象的方式走棋。可以在两次移动内实现，例如，利用 $(4,4)$ 作为中转站。\n\n---\n\n**样例 $3$ 解释**\n\n在第一组数据中，我们需要从 $(3,3)$ 走到 $(4,5)$，只能按照皇后的方式走棋。可以利用 $(4,4)$ 为中转站两次移动到达。\n\n在第二组数据中，我们需要从 $(4,1)$ 走到 $(1,4)$，只能按照皇后和车的方式走棋。可以一次移动到达。\n\n---\n\n**数据范围**\n\n对于全部数据，$1\\le q\\le 10^3$，$-10^8\\le a,b,c,d\\le 10^8$。\n\n- 子任务一（$12$ 分）：保证存在 `Q`，保证不存在 `N`。\n- 子任务二（$9$ 分）：保证存在 `QN`。\n- 子任务三（$13$ 分）：保证存在 `R`，保证不存在 `Q`。\n- 子任务四（$8$ 分）：保证只存在 `B`。\n- 子任务五（$6$ 分）：保证存在 `B`，保证不存在 `QR`。\n- 子任务六（$31$ 分）：保证只存在 `N`。\n- 子任务七（$8$ 分）：保证存在 `N`，保证不存在 `QRB`。\n- 子任务八（$7$ 分）：保证存在 `K`，保证不存在 `QRBN`。\n- 子任务九（$6$ 分）：保证只存在 `P`。\n\n注意子任务**并不**按难度顺序排序。", "locale": "zh-CN"}}}
{"pid": "P9323", "type": "P", "difficulty": 5, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2022", "交互题", "Special Judge", "O2优化", "EGOI（欧洲/女生）"], "title": "[EGOI 2022] Toy Design / 玩具设计", "background": "Day 2 Problem C.\n\n题面译自 [EGOI2022 toydesign](https://stats.egoi.org/media/task_description/2022_toydesign_en.pdf)。\n\n[![CC BY-SA 3.0](https://licensebuttons.net/l/by-sa/3.0/80x15.png)](https://creativecommons.org/licenses/by-sa/3.0/)", "description": "**本题是一道 Grader 交互题。**\n\n你在一个设计玩具的公司工作。一个将被制作的玩具如下：有 $n$ 个大头针，编号从 $1$ 到 $n$，从盒子中伸出。几对大头针被铁丝在盒子中相连。（换句话说，大头针和铁丝组成了一个无向图，其中大头针是节点、铁丝是边。）铁丝无法从盒子外部看到，唯一获得关于他们的信息的方法是对大头针使用一个**检测器**：我们选择两个大头针 $i,j$（$i\\ne j$），检测器会告诉你这两个大头针是否连通，包括直接和间接。（因此，检测器告诉你图中这两个大头针之间是否有一条路径。）\n\n我们称一组连接方式为玩具的**设计方案**。\n\n你正在使用一个专用的软件来查询和进行设计。软件工作方式如下：从某个称为“$0$ 号方案”的设计方案开始。他不会告诉你盒子内部的铁丝是什么样的。你需要重复进行以下的三步操作：\n\n1. 选择一个设计方案 $a$ 和两个大头针 $i,j$（$i\\ne j$）。\n2. 软件告诉你对这两个大头针使用检测器的结果。换句话说，它告诉你在设计方案 $a$ 中 $i$ 与 $j$ 是否（直接或间接地）连通。\n3. 同时，如果这两个大头针在设计方案 $a$ 中没有被直接或间接地连接，它会创建一个新的设计方案，包含设计方案 $a$ 中的所有铁丝，同时添加一个直接连接 $i,j$ 的铁丝。这个设计方案的编号为下一个可用的编号。（所以，第一个创建的设计方案是 $1$ 号方案，然后是 $2$ 号，以此类推。）请注意这不会修改设计方案 $a$，只会新建一个设计方案包含新的铁丝。\n\n你的目标是使用这种操作获取尽可能多的 $0$ 号方案的信息。\n\n请注意并不总是可能求出 $0$ 号方案的准确的铁丝连接方式，因为无法区分直接和间接的连接。例如，考虑如下的两种 $n=3$ 的设计方案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7vwojkw8.png)\n\n检测器会认为两种方案中任意一对大头针都连通，所以我们无法利用上述软件区分它们。\n\n你的目标是求出任何一种设计方案，使得它与 $0$ 号方案等价。两种设计方案**等价**当且仅当对于任意一对大头针，检测器在两种方案中都返回相同结果。", "inputFormat": "", "outputFormat": "**交互方式**\n\n你需要实现一个函数：\n\n```cpp\nvoid ToyDesign(int n, int max_ops);\n```\n\n作用是给出一种与 $0$ 号方案*等价*的设计方案。你可以调用以下两个函数来实现这一点。你可以调用的第一个函数为：\n\n```cpp\nint Connected(int a, int i, int j);\n```\n\n其中 $1\\le i,j\\le n$，$i\\ne j$，$a\\ge 0$，且 $a$ 不能超过目前已有的设计方案数。如果在设计方案 $a$ 中，大头针 $i,j$ 是（直接或间接地）连通的，它的返回值是 $a$。否则，它的返回值是已有的设计方案数加一，就是包含 $a$ 的所有铁丝以及一根连接 $i,j$ 的铁丝的新的设计方案的编号。函数 `Connected` 可以被调用最多 `max_ops` 次。\n\n当你的程序完成了需要的 `Connected` 调用，它应该描述一种等价于 $0$ 号方案的设计方案。为了描述一个方案，程序应当调用：\n\n```cpp\nvoid DescribeDesign(std::vector<std::pair<int, int>> result);\n```\n\n参数 `result` 是整数对的向量，描述大头针之间的直接铁丝连接。每对数描述一根铁丝，包含被连接的两个大头针的编号。在任意一对（无序的）大头针对之间必须只有至多一根铁丝，且不能有铁丝连接一个大头针和它自己。一旦调用这个函数，你的程序将被终止。", "hint": "**样例交互过程**\n\n|选手程序|Grader|解释|\n|:-|:-|:-|\n||`ToyDesign(4, 20)`|玩具中有 $4$ 个大头针。你需要在 $20$ 次 `Connected` 调用内，给出任何一种等价于 $0$ 号方案的设计方案。|\n|`Connected(0, 1, 2)`|返回 $1$。|大头针 $1,2$ 在 $0$ 号方案中不直接或间接地连通。新的设计方案是 $1$ 号。|\n|`Connected(1, 3, 2)`|返回 $2$。|大头针 $3,2$ 在 $1$ 号方案中不直接或间接地连通。新的设计方案是 $2$ 号。|\n|`Connected(0, 3, 4)`|返回 $0$。|大头针 $3,4$ 在 $0$ 号方案中直接或间接地连通。没有新的设计方案。|\n|`DescribeDesign({{3, 4}})`||描述一个只有一根铁丝的设计方案：连接大头针 $3,4$。|\n\n---\n\n**数据范围**\n\n对于全部数据，$2\\le n\\le 200$。\n\n- 子任务一（$10$ 分）：$n\\le 200$，`max_ops` 为 $20000$。\n- 子任务二（$20$ 分）：$n\\le 8$，`max_ops` 为 $20$。\n- 子任务三（$35$ 分）：$n\\le 200$，`max_ops` 为 $2000$。\n- 子任务四（$35$ 分）：$n\\le 200$，`max_ops` 为 $1350$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[EGOI 2022] Toy Design / 玩具设计", "background": "Day 2 Problem C.\n\n题面译自 [EGOI2022 toydesign](https://stats.egoi.org/media/task_description/2022_toydesign_en.pdf)。\n\n[![CC BY-SA 3.0](https://licensebuttons.net/l/by-sa/3.0/80x15.png)](https://creativecommons.org/licenses/by-sa/3.0/)", "description": "**本题是一道 Grader 交互题。**\n\n你在一个设计玩具的公司工作。一个将被制作的玩具如下：有 $n$ 个大头针，编号从 $1$ 到 $n$，从盒子中伸出。几对大头针被铁丝在盒子中相连。（换句话说，大头针和铁丝组成了一个无向图，其中大头针是节点、铁丝是边。）铁丝无法从盒子外部看到，唯一获得关于他们的信息的方法是对大头针使用一个**检测器**：我们选择两个大头针 $i,j$（$i\\ne j$），检测器会告诉你这两个大头针是否连通，包括直接和间接。（因此，检测器告诉你图中这两个大头针之间是否有一条路径。）\n\n我们称一组连接方式为玩具的**设计方案**。\n\n你正在使用一个专用的软件来查询和进行设计。软件工作方式如下：从某个称为“$0$ 号方案”的设计方案开始。他不会告诉你盒子内部的铁丝是什么样的。你需要重复进行以下的三步操作：\n\n1. 选择一个设计方案 $a$ 和两个大头针 $i,j$（$i\\ne j$）。\n2. 软件告诉你对这两个大头针使用检测器的结果。换句话说，它告诉你在设计方案 $a$ 中 $i$ 与 $j$ 是否（直接或间接地）连通。\n3. 同时，如果这两个大头针在设计方案 $a$ 中没有被直接或间接地连接，它会创建一个新的设计方案，包含设计方案 $a$ 中的所有铁丝，同时添加一个直接连接 $i,j$ 的铁丝。这个设计方案的编号为下一个可用的编号。（所以，第一个创建的设计方案是 $1$ 号方案，然后是 $2$ 号，以此类推。）请注意这不会修改设计方案 $a$，只会新建一个设计方案包含新的铁丝。\n\n你的目标是使用这种操作获取尽可能多的 $0$ 号方案的信息。\n\n请注意并不总是可能求出 $0$ 号方案的准确的铁丝连接方式，因为无法区分直接和间接的连接。例如，考虑如下的两种 $n=3$ 的设计方案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7vwojkw8.png)\n\n检测器会认为两种方案中任意一对大头针都连通，所以我们无法利用上述软件区分它们。\n\n你的目标是求出任何一种设计方案，使得它与 $0$ 号方案等价。两种设计方案**等价**当且仅当对于任意一对大头针，检测器在两种方案中都返回相同结果。", "inputFormat": "", "outputFormat": "**交互方式**\n\n你需要实现一个函数：\n\n```cpp\nvoid ToyDesign(int n, int max_ops);\n```\n\n作用是给出一种与 $0$ 号方案*等价*的设计方案。你可以调用以下两个函数来实现这一点。你可以调用的第一个函数为：\n\n```cpp\nint Connected(int a, int i, int j);\n```\n\n其中 $1\\le i,j\\le n$，$i\\ne j$，$a\\ge 0$，且 $a$ 不能超过目前已有的设计方案数。如果在设计方案 $a$ 中，大头针 $i,j$ 是（直接或间接地）连通的，它的返回值是 $a$。否则，它的返回值是已有的设计方案数加一，就是包含 $a$ 的所有铁丝以及一根连接 $i,j$ 的铁丝的新的设计方案的编号。函数 `Connected` 可以被调用最多 `max_ops` 次。\n\n当你的程序完成了需要的 `Connected` 调用，它应该描述一种等价于 $0$ 号方案的设计方案。为了描述一个方案，程序应当调用：\n\n```cpp\nvoid DescribeDesign(std::vector<std::pair<int, int>> result);\n```\n\n参数 `result` 是整数对的向量，描述大头针之间的直接铁丝连接。每对数描述一根铁丝，包含被连接的两个大头针的编号。在任意一对（无序的）大头针对之间必须只有至多一根铁丝，且不能有铁丝连接一个大头针和它自己。一旦调用这个函数，你的程序将被终止。", "hint": "**样例交互过程**\n\n|选手程序|Grader|解释|\n|:-|:-|:-|\n||`ToyDesign(4, 20)`|玩具中有 $4$ 个大头针。你需要在 $20$ 次 `Connected` 调用内，给出任何一种等价于 $0$ 号方案的设计方案。|\n|`Connected(0, 1, 2)`|返回 $1$。|大头针 $1,2$ 在 $0$ 号方案中不直接或间接地连通。新的设计方案是 $1$ 号。|\n|`Connected(1, 3, 2)`|返回 $2$。|大头针 $3,2$ 在 $1$ 号方案中不直接或间接地连通。新的设计方案是 $2$ 号。|\n|`Connected(0, 3, 4)`|返回 $0$。|大头针 $3,4$ 在 $0$ 号方案中直接或间接地连通。没有新的设计方案。|\n|`DescribeDesign({{3, 4}})`||描述一个只有一根铁丝的设计方案：连接大头针 $3,4$。|\n\n---\n\n**数据范围**\n\n对于全部数据，$2\\le n\\le 200$。\n\n- 子任务一（$10$ 分）：$n\\le 200$，`max_ops` 为 $20000$。\n- 子任务二（$20$ 分）：$n\\le 8$，`max_ops` 为 $20$。\n- 子任务三（$35$ 分）：$n\\le 200$，`max_ops` 为 $2000$。\n- 子任务四（$35$ 分）：$n\\le 200$，`max_ops` 为 $1350$。", "locale": "zh-CN"}}}
{"pid": "P9325", "type": "P", "difficulty": 3, "samples": [["7\n3 1 4 1 5 9 2", "0 2 0 5 2 10 10"], ["4\n1 3 5 6", "0 1 3 7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2023", "枚举", "CCC（加拿大）", "区间 DP", "双指针 two-pointer"], "title": "[CCC 2023 S2] Symmetric Mountains", "background": "", "description": "Rebecca is a tour guide and is trying to market the Rocky Mountains for her magazine. She recently took a beautiful picture consisting of $N$ mountains where the $i\\text{-th}$ mountain from the left has a height $h_i$. She will crop this picture for her magazine, by possibly removing some mountains from the left side of the picture and possibly removing some mountains from the right side of the picture. That is, a crop consists of consecutive mountains starting from the $l\\text{-th}$ to the $r\\text{-th}$ mountain where $l \\leq r$. To please her magazine readers, Rebecca will try to find the most symmetric crop.\n\nWe will measure the $asymmetric\\ value$ of a crop as the sum of the absolute difference for every pair of mountains equidistant from the midpoint of the crop. To help understand that definition, note that the absolute value of $a$ number $v$, written as $|v|$, is the non-negative value of v: for example $\\lvert -6 \\rvert = 6$ and $|14| = 14$. The asymmetric value of a crop is the sum of all $|h_{l+i} - h_{r-i}|$ for $0 \\leq i \\leq \\frac{r-l}{2}$. To put that formula in a different way, we pair up the mountains working from the outside in toward the centre, calculate the absolute difference in height of each of these pairs, and sum them up.\n\nBecause Rebecca does not know how wide the picture needs to be, for all possible crop lengths, find the asymmetric value of the most symmetric crop (the crop with the minimum asymmetric value).", "inputFormat": "The first line consists of an integer $N$, representing the number of mountains in the picture.\n\nThe second line consists of $N$ space-separated integers, where the $i\\text{-th}$ integer from the left represents $h_i$.\n\nThe following table shows how the available 15 marks are distributed:\n\n| Marks | Bounds on $N$ | Bounds on $h_i$ | Additional Constraints |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $5$ | $1 \\leq N \\leq 300$ | $0 \\leq h_i \\leq 10^5$ | None. |\n| $5$ | $1 \\leq N \\leq 5000$ | $0 \\leq h_i \\leq 10^5$ | Height of mountains are in non-decreasing order from left to right. |\n| $5$ | $1 \\leq N \\leq 5000$ | $0 \\leq h_i \\leq 10^5$ | None. |\n", "outputFormat": "Output on one line $N$ space-separated integers, where the $i\\text{-th}$ integer from the left is the asymmetric value of the most symmetric picture of crops of length $i$.", "hint": "Explanation of Output for Sample Input $1$:\n\nWe will show why the fifth value from the left is $2$.Let us try to compute all the asymmetric values of crops with length $5$.\n\nThe height of the mountains in the first crop is $[3, 1, 4, 1, 5]$. The asymmetric value of this crop is $|3 - 5| + |1 - 1| + |4 - 4| = 2$.\n\nThe height of the mountains in the second crop is $[1, 4, 1, 5, 9]$. The asymmetric value of this crop is $|1 - 9| + |4 - 5| + |1 - 1| = 9$.\n\nThe height of the mountains in the last crop is $[4, 1, 5, 9, 2]$. The asymmetric value of this crop is $|4 - 2| + |1 - 9| + |5 - 5| = 10$.\n\nHence, the most symmetric crop of length $5$ is $2$.\n\nExplanation of Output for Sample Input $2$:\n\nThis sample satisfies the second subtask. Note that the only crop of length $4$ is $[1, 3, 5, 6]$ which has asymmetric value of $|1 - 6| + |3 - 5| = 7$.\n\n**本题采用捆绑测试**：\n\n- Subtask 1（5 points）：$1\\leq N \\leq 300$，$0\\leq h_i \\leq 10^5$。\n\n- Subtask 2（5 points）：$1 \\leq N \\leq 5000$，$0 \\leq h_i \\leq 10^5$，保证山的高度从左到右单调不减。\n\n- Subtask 3（5 points）：$1\\leq N\\leq 5000$，$0 \\leq h_i \\leq 10^5$。", "locale": "en", "translations": {"en": {"title": "[CCC 2023 S2] Symmetric Mountains", "background": "", "description": "Rebecca is a tour guide and is trying to market the Rocky Mountains for her magazine. She recently took a beautiful picture consisting of $N$ mountains where the $i\\text{-th}$ mountain from the left has a height $h_i$. She will crop this picture for her magazine, by possibly removing some mountains from the left side of the picture and possibly removing some mountains from the right side of the picture. That is, a crop consists of consecutive mountains starting from the $l\\text{-th}$ to the $r\\text{-th}$ mountain where $l \\leq r$. To please her magazine readers, Rebecca will try to find the most symmetric crop.\n\nWe will measure the $asymmetric\\ value$ of a crop as the sum of the absolute difference for every pair of mountains equidistant from the midpoint of the crop. To help understand that definition, note that the absolute value of $a$ number $v$, written as $|v|$, is the non-negative value of v: for example $\\lvert -6 \\rvert = 6$ and $|14| = 14$. The asymmetric value of a crop is the sum of all $|h_{l+i} - h_{r-i}|$ for $0 \\leq i \\leq \\frac{r-l}{2}$. To put that formula in a different way, we pair up the mountains working from the outside in toward the centre, calculate the absolute difference in height of each of these pairs, and sum them up.\n\nBecause Rebecca does not know how wide the picture needs to be, for all possible crop lengths, find the asymmetric value of the most symmetric crop (the crop with the minimum asymmetric value).", "inputFormat": "The first line consists of an integer $N$, representing the number of mountains in the picture.\n\nThe second line consists of $N$ space-separated integers, where the $i\\text{-th}$ integer from the left represents $h_i$.\n\nThe following table shows how the available 15 marks are distributed:\n\n| Marks | Bounds on $N$ | Bounds on $h_i$ | Additional Constraints |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $5$ | $1 \\leq N \\leq 300$ | $0 \\leq h_i \\leq 10^5$ | None. |\n| $5$ | $1 \\leq N \\leq 5000$ | $0 \\leq h_i \\leq 10^5$ | Height of mountains are in non-decreasing order from left to right. |\n| $5$ | $1 \\leq N \\leq 5000$ | $0 \\leq h_i \\leq 10^5$ | None. |\n", "outputFormat": "Output on one line $N$ space-separated integers, where the $i\\text{-th}$ integer from the left is the asymmetric value of the most symmetric picture of crops of length $i$.", "hint": "Explanation of Output for Sample Input $1$:\n\nWe will show why the fifth value from the left is $2$.Let us try to compute all the asymmetric values of crops with length $5$.\n\nThe height of the mountains in the first crop is $[3, 1, 4, 1, 5]$. The asymmetric value of this crop is $|3 - 5| + |1 - 1| + |4 - 4| = 2$.\n\nThe height of the mountains in the second crop is $[1, 4, 1, 5, 9]$. The asymmetric value of this crop is $|1 - 9| + |4 - 5| + |1 - 1| = 9$.\n\nThe height of the mountains in the last crop is $[4, 1, 5, 9, 2]$. The asymmetric value of this crop is $|4 - 2| + |1 - 9| + |5 - 5| = 10$.\n\nHence, the most symmetric crop of length $5$ is $2$.\n\nExplanation of Output for Sample Input $2$:\n\nThis sample satisfies the second subtask. Note that the only crop of length $4$ is $[1, 3, 5, 6]$ which has asymmetric value of $|1 - 6| + |3 - 5| = 7$.\n\n**本题采用捆绑测试**：\n\n- Subtask 1（5 points）：$1\\leq N \\leq 300$，$0\\leq h_i \\leq 10^5$。\n\n- Subtask 2（5 points）：$1 \\leq N \\leq 5000$，$0 \\leq h_i \\leq 10^5$，保证山的高度从左到右单调不减。\n\n- Subtask 3（5 points）：$1\\leq N\\leq 5000$，$0 \\leq h_i \\leq 10^5$。", "locale": "en"}, "zh-CN": {"title": "[CCC 2023 S2] Symmetric Mountains", "background": "", "description": "Rebecca 是一名导游，正在为她的杂志推广落基山脉。她最近拍了一张包含 $N$ 座山的美丽照片，其中从左到右第 $i$ 座山的高度为 $h_i$。她将为她的杂志裁剪这张照片，可能会从照片的左侧移除一些山，也可能会从照片的右侧移除一些山。也就是说，裁剪包括从第 $l$ 座山到第 $r$ 座山的连续山峰，其中 $l \\leq r$。为了取悦她的杂志读者，Rebecca 将尝试找到最对称的裁剪。\n\n我们将裁剪的不对称值定义为从裁剪的中点开始，每对等距山峰的高度差的绝对值之和。为了帮助理解这个定义，注意到一个数 $v$ 的绝对值，记为 $|v|$，是 $v$ 的非负值：例如 $|-6| = 6$ 和 $|14| = 14$。裁剪的不对称值是所有 $|h_{l+i} - h_{r-i}|$ 的和，其中 $0 \\leq i \\leq \\frac{r-l}{2}$。换句话说，我们从外向内配对山峰，计算每对山峰高度差的绝对值，并将它们相加。\n\n因为 Rebecca 不知道照片需要多宽，所以对于所有可能的裁剪长度，找到不对称值最小的裁剪（即最对称的裁剪）。", "inputFormat": "第一行由一个整数 $N$ 组成，表示照片中山的数量。\n\n第二行由 $N$ 个以空格分隔的整数组成，其中从左到右第 $i$ 个整数表示 $h_i$。\n\n下表显示了可用的 15 分的分配方式：\n\n| 分数 | $N$ 的范围 | $h_i$ 的范围 | 额外限制 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $5$ | $1 \\leq N \\leq 300$ | $0 \\leq h_i \\leq 10^5$ | 无。 |\n| $5$ | $1 \\leq N \\leq 5000$ | $0 \\leq h_i \\leq 10^5$ | 山的高度从左到右单调不减。 |\n| $5$ | $1 \\leq N \\leq 5000$ | $0 \\leq h_i \\leq 10^5$ | 无。 |", "outputFormat": "输出一行 $N$ 个以空格分隔的整数，其中从左到右第 $i$ 个整数是长度为 $i$ 的裁剪中最对称的裁剪的不对称值。", "hint": "对样例输入 1 的输出解释：\n\n我们将展示为什么从左数第五个值是 2。让我们尝试计算所有长度为 5 的裁剪的不对称值。\n\n第一个裁剪中山的高度是 $[3, 1, 4, 1, 5]$。这个裁剪的不对称值是 $|3 - 5| + |1 - 1| + |4 - 4| = 2$。\n\n第二个裁剪中山的高度是 $[1, 4, 1, 5, 9]$。这个裁剪的不对称值是 $|1 - 9| + |4 - 5| + |1 - 1| = 9$。\n\n最后一个裁剪中山的高度是 $[4, 1, 5, 9, 2]$。这个裁剪的不对称值是 $|4 - 2| + |1 - 9| + |5 - 5| = 10$。\n\n因此，长度为 5 的最对称裁剪是不对称值为 2 的裁剪。\n\n对样例输入 2 的输出解释：\n\n这个样例满足第二个子任务。注意，唯一长度为 4 的裁剪是 $[1, 3, 5, 6]$，其不对称值为 $|1 - 6| + |3 - 5| = 7$。\n\n**本题采用捆绑测试**：\n\n- 子任务 1（5 分）：$1\\leq N \\leq 300$，$0\\leq h_i \\leq 10^5$。\n\n- 子任务 2（5 分）：$1 \\leq N \\leq 5000$，$0 \\leq h_i \\leq 10^5$，保证山的高度从左到右单调不减。\n\n- 子任务 3（5 分）：$1\\leq N\\leq 5000$，$0 \\leq h_i \\leq 10^5$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9326", "type": "P", "difficulty": 4, "samples": [["4 5 1 2", "union\nradar\nbadge\nanime"], ["2 2 2 1", "IMPOSSIBLE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "字符串", "2023", "Special Judge", "CCC（加拿大）", "构造", "分类讨论"], "title": "[CCC 2023 S3] Palindromic Poster", "background": "", "description": "Ryo and Kita are designing a new poster for Kessoku Band. After some furious brainstorming, they came to the conclusion that the poster should come in the form of a $2\\text{-D}$ grid of lowercase English letters (i.e. `a` to `z`), with $N$ rows and $M$ columns.\n\nFurthermore, it is known that Ryo and Kita both have peculiar tastes in palindromes. Ryo will only be satisfied with the poster if exactly $R$ of its rows are palindromes, and Kita will only be satisfied with the poster if exactly $C$ of its columns are palindromes. Can you design a poster that will satisfy both Ryo and Kita, or determine that it is impossible to do so?\n\n**Note**: A string is considered a palindrome if it is the same when read forwards and backwards. For example, `kayak` and `bb` are palindromes, whereas `guitar` and `live` are not.\n", "inputFormat": "The first and only line of input consists of $4$ space-separated integers $N, M, R$, and $C$.\n\nThe following table shows how the available $15$ marks are distributed.\n\n| Marks | Bounds on $N$ | Bounds on $M$ | Bounds on $R$ | Bounds on $C$ |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $2$ marks | $2 \\leq N \\leq 2000$ | $2 \\leq M \\leq 2000$ | $R = 1$ | $C = 1$ |\n| $2$ marks | $N = 2$ | $M = 2$ | $0 \\leq R \\leq N$ | $0 \\leq C \\leq M$ |\n| $4$ marks | $N = 2$ | $2 \\leq M \\leq 2000$ | $0 \\leq R \\leq N$ | $0 \\leq C \\leq M$ |\n| $7$ marks | $2 \\leq N \\leq 2000$ | $2 \\leq M \\leq 2000$ | $0 \\leq R \\leq N$ | $0 \\leq C \\leq M$ |\n\n", "outputFormat": "If it is impossible to design a poster that will satisfy both Ryo and Kita, output `IMPOSSIBLE` on a single line.\n\nOtherwise, your output should contain $N$ lines, each consisting of $M$ lowercase English letters, representing your poster design. If there are multiple possible designs, output any ofthem.", "hint": "Explanation of Output for Sample Input $1$：\n\nIn the given design, only the second row (namely `radar`) and the second and third columns (namely `naan` and `iddi`) are palindromes. Since exactly $R = 1$ of the rows and $C = 2$ of the\ncolumns are palindromes, this is an acceptable design.\n\nExplanation of Output for Sample Input $2$：\n\nIn this case, it can be proven that it is impossible to satisfy both Ryo and Kita.\n\n**本题采用捆绑测试**：\n\n- Subtask 1（2 points）：数据保证 $2 \\leq N \\leq 2000$，$2\\leq M\\leq 2000$，$R = 1$，$C = 1$。\n\n- Subtask 2（2 points）：数据保证 $N = 2$，$M = 2$，$0\\leq R\\leq N$，$0\\leq C\\leq M$。\n\n- Subtask 3（4 points）：数据保证 $N = 2$，$2\\leq M \\leq2000$，$0\\leq R\\leq N$，$0\\leq C\\leq M$。\n\n- Subtask 4（7 points）：数据保证 $2\\leq N\\leq 2000$，$2\\leq M \\leq2000$，$0\\leq R\\leq N$，$0\\leq C\\leq M$。", "locale": "en", "translations": {"en": {"title": "[CCC 2023 S3] Palindromic Poster", "background": "", "description": "Ryo and Kita are designing a new poster for Kessoku Band. After some furious brainstorming, they came to the conclusion that the poster should come in the form of a $2\\text{-D}$ grid of lowercase English letters (i.e. `a` to `z`), with $N$ rows and $M$ columns.\n\nFurthermore, it is known that Ryo and Kita both have peculiar tastes in palindromes. Ryo will only be satisfied with the poster if exactly $R$ of its rows are palindromes, and Kita will only be satisfied with the poster if exactly $C$ of its columns are palindromes. Can you design a poster that will satisfy both Ryo and Kita, or determine that it is impossible to do so?\n\n**Note**: A string is considered a palindrome if it is the same when read forwards and backwards. For example, `kayak` and `bb` are palindromes, whereas `guitar` and `live` are not.\n", "inputFormat": "The first and only line of input consists of $4$ space-separated integers $N, M, R$, and $C$.\n\nThe following table shows how the available $15$ marks are distributed.\n\n| Marks | Bounds on $N$ | Bounds on $M$ | Bounds on $R$ | Bounds on $C$ |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $2$ marks | $2 \\leq N \\leq 2000$ | $2 \\leq M \\leq 2000$ | $R = 1$ | $C = 1$ |\n| $2$ marks | $N = 2$ | $M = 2$ | $0 \\leq R \\leq N$ | $0 \\leq C \\leq M$ |\n| $4$ marks | $N = 2$ | $2 \\leq M \\leq 2000$ | $0 \\leq R \\leq N$ | $0 \\leq C \\leq M$ |\n| $7$ marks | $2 \\leq N \\leq 2000$ | $2 \\leq M \\leq 2000$ | $0 \\leq R \\leq N$ | $0 \\leq C \\leq M$ |\n\n", "outputFormat": "If it is impossible to design a poster that will satisfy both Ryo and Kita, output `IMPOSSIBLE` on a single line.\n\nOtherwise, your output should contain $N$ lines, each consisting of $M$ lowercase English letters, representing your poster design. If there are multiple possible designs, output any ofthem.", "hint": "Explanation of Output for Sample Input $1$：\n\nIn the given design, only the second row (namely `radar`) and the second and third columns (namely `naan` and `iddi`) are palindromes. Since exactly $R = 1$ of the rows and $C = 2$ of the\ncolumns are palindromes, this is an acceptable design.\n\nExplanation of Output for Sample Input $2$：\n\nIn this case, it can be proven that it is impossible to satisfy both Ryo and Kita.\n\n**本题采用捆绑测试**：\n\n- Subtask 1（2 points）：数据保证 $2 \\leq N \\leq 2000$，$2\\leq M\\leq 2000$，$R = 1$，$C = 1$。\n\n- Subtask 2（2 points）：数据保证 $N = 2$，$M = 2$，$0\\leq R\\leq N$，$0\\leq C\\leq M$。\n\n- Subtask 3（4 points）：数据保证 $N = 2$，$2\\leq M \\leq2000$，$0\\leq R\\leq N$，$0\\leq C\\leq M$。\n\n- Subtask 4（7 points）：数据保证 $2\\leq N\\leq 2000$，$2\\leq M \\leq2000$，$0\\leq R\\leq N$，$0\\leq C\\leq M$。", "locale": "en"}, "zh-CN": {"title": "[CCC 2023 S3] Palindromic Poster", "background": "", "description": "Ryo 和 Kita 正在为 Kessoku Band 设计一张新海报。经过一番激烈的头脑风暴，他们得出结论，海报应该以一个 $2\\text{-D}$ 的小写英文字母网格（即 `a` 到 `z`）的形式出现，具有 $N$ 行和 $M$ 列。\n\n此外，已知 Ryo 和 Kita 都对回文有独特的品味。Ryo 只有在海报的行中恰好有 $R$ 行是回文时才会满意，而 Kita 只有在海报的列中恰好有 $C$ 列是回文时才会满意。你能设计出一张同时满足 Ryo 和 Kita 的海报，或者确定这是不可能的吗？\n\n**注意**：如果一个字符串正反读都是一样的，则认为它是回文。例如，`kayak` 和 `bb` 是回文，而 `guitar` 和 `live` 不是。", "inputFormat": "输入的第一行包含 $4$ 个用空格分隔的整数 $N, M, R$ 和 $C$。\n\n下表显示了可用的 $15$ 分是如何分配的。\n\n| Marks | Bounds on $N$ | Bounds on $M$ | Bounds on $R$ | Bounds on $C$ |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $2$ marks | $2 \\leq N \\leq 2000$ | $2 \\leq M \\leq 2000$ | $R = 1$ | $C = 1$ |\n| $2$ marks | $N = 2$ | $M = 2$ | $0 \\leq R \\leq N$ | $0 \\leq C \\leq M$ |\n| $4$ marks | $N = 2$ | $2 \\leq M \\leq 2000$ | $0 \\leq R \\leq N$ | $0 \\leq C \\leq M$ |\n| $7$ marks | $2 \\leq N \\leq 2000$ | $2 \\leq M \\leq 2000$ | $0 \\leq R \\leq N$ | $0 \\leq C \\leq M$ |", "outputFormat": "如果不可能设计出一张同时满足 Ryo 和 Kita 的海报，则在一行中输出 `IMPOSSIBLE`。\n\n否则，输出应包含 $N$ 行，每行由 $M$ 个小写英文字母组成，表示你的海报设计。如果有多种可能的设计，输出其中任意一种。", "hint": "对于样例输入 $1$ 的输出解释：\n\n在给定的设计中，只有第二行（即 `radar`）和第二、第三列（即 `naan` 和 `iddi`）是回文。由于恰好有 $R = 1$ 行和 $C = 2$ 列是回文，这是一种可接受的设计。\n\n对于样例输入 $2$ 的输出解释：\n\n在这种情况下，可以证明不可能同时满足 Ryo 和 Kita。\n\n**本题采用捆绑测试**：\n\n- 子任务 1（2 分）：数据保证 $2 \\leq N \\leq 2000$，$2\\leq M\\leq 2000$，$R = 1$，$C = 1$。\n\n- 子任务 2（2 分）：数据保证 $N = 2$，$M = 2$，$0\\leq R\\leq N$，$0\\leq C\\leq M$。\n\n- 子任务 3（4 分）：数据保证 $N = 2$，$2\\leq M \\leq2000$，$0\\leq R\\leq N$，$0\\leq C\\leq M$。\n\n- 子任务 4（7 分）：数据保证 $2\\leq N\\leq 2000$，$2\\leq M \\leq2000$，$0\\leq R\\leq N$，$0\\leq C\\leq M$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9327", "type": "P", "difficulty": 4, "samples": [["5 7\n1 2 15 1\n2 4 9 9\n5 2 5 6\n4 5 4 4\n4 3 3 7\n1 3 2 7\n1 4 2 1", "25"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "CCC（加拿大）", "最短路"], "title": "[CCC 2023 S4] Minimum Cost Roads", "background": "", "description": "As the newly elected mayor of Kitchener, Alanna's first job is to improve the city's road plan.\n\nKitchener's current road plan can be represented as a collection of $N$ intersections with $M$ roads, where the $i\\text{-th}$ road has length $l_i$ meters, costs $c_i$ dollars per year to maintain, and connects intersections $u_i$ and $v_i$. To create a plan, Alanna must select some subset of the $M$ roads to keep and maintain, and that plan's cost is the sum of maintenance costs of all roads in that subset.\n\nTo lower the city's annual spending, Alanna would like to minimize the plan's cost. However, the city also requires that she minimizes travel distances between intersections and will reject any plan that does not conform to those rules. Formally, for any pair of intersections $(i, j)$, if there exists a path from $i$ to $j$ taking $l$ meters on the existing road plan, Alanna's plan must also include a path between those intersections that is at most $l$ meters.", "inputFormat": "The first line contains the integers $N$ and $M$.\n\nEach of the next $M$ lines contains the integers $u_i,v_i,l_i$ and $c_i$, meaning that there currently exists a road from intersection $u_i$ to intersection $v_i$ with length $l_i$ and cost $c_i$$(1 \\leq u_i, v_i \\leq N, u_i \\neq v_i)$.\n\nThe following table shows how the available 15 marks are distributed.\n\n| Marks | Bounds on $N$ and $M$ | Bounds on $l_i$ | Bounds on $c_i$ | Additional Constraints |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $3$ marks | $1 \\leq N\\leq 2000$, $1\\leq M \\leq 2000$ | $l_i = 0$ | $1 \\leq c_i \\leq 10^9$ | None. |\n| $6$ marks | $1 \\leq N\\leq 2000$, $1\\leq M \\leq 2000$ | $1 \\leq l_i \\leq 10^9$ | $1 \\leq c_i \\leq 10^9$ | There is at most one road between any unordered pair of intersections. |\n| $6$ marks | $1 \\leq N\\leq 2000$, $1\\leq M \\leq 2000$ | $0 \\leq l_i \\leq 10^9$ | $1 \\leq c_i \\leq 10^9$ | None. |\n", "outputFormat": "Output one integer, the minimum possible cost of a road plan that meets the requirements.", "hint": "Explanation of Output for Sample Input：\n\nHere is a diagram of the intersections along with a valid road plan with minimum cost.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2astpvkm.png)\n\nEach edge is labeled with a pair $(l, c)$ denoting that it has length $l$ meters and cost $c$ dollars.\n\nAdditionally, the roads that are part of the plan are highlighted in blue, with a total cost of $7 + 1 + 6 + 7 + 4 = 25$.\n\nIt can be shown that we cannot create a cheaper plan that also respects the city’s requirements.\n\n**本题采用捆绑测试**：\n\n- Subtask 1（3 points）：数据保证 $1\\leq N \\leq 2000$，$1\\leq M \\leq 2000$，$l_i = 0$，$1\\leq c_i \\leq 10^9$。\n\n- Subtask 2（6 points）：数据保证 $1\\leq N\\leq 2000$，$1\\leq M \\leq 2000$，$1\\leq l_i \\leq 10^9$，$1\\leq c_i \\leq 10^9$，且在任何一对十字路口之间最多只有一条路。\n\n- Subtask 3（6 points）：数据保证 $1\\leq N\\leq 2000$，$1\\leq M \\leq 2000$，$0\\leq l_i \\leq 10^9$，$1\\leq c_i \\leq 10^9$。", "locale": "en", "translations": {"en": {"title": "[CCC 2023 S4] Minimum Cost Roads", "background": "", "description": "As the newly elected mayor of Kitchener, Alanna's first job is to improve the city's road plan.\n\nKitchener's current road plan can be represented as a collection of $N$ intersections with $M$ roads, where the $i\\text{-th}$ road has length $l_i$ meters, costs $c_i$ dollars per year to maintain, and connects intersections $u_i$ and $v_i$. To create a plan, Alanna must select some subset of the $M$ roads to keep and maintain, and that plan's cost is the sum of maintenance costs of all roads in that subset.\n\nTo lower the city's annual spending, Alanna would like to minimize the plan's cost. However, the city also requires that she minimizes travel distances between intersections and will reject any plan that does not conform to those rules. Formally, for any pair of intersections $(i, j)$, if there exists a path from $i$ to $j$ taking $l$ meters on the existing road plan, Alanna's plan must also include a path between those intersections that is at most $l$ meters.", "inputFormat": "The first line contains the integers $N$ and $M$.\n\nEach of the next $M$ lines contains the integers $u_i,v_i,l_i$ and $c_i$, meaning that there currently exists a road from intersection $u_i$ to intersection $v_i$ with length $l_i$ and cost $c_i$$(1 \\leq u_i, v_i \\leq N, u_i \\neq v_i)$.\n\nThe following table shows how the available 15 marks are distributed.\n\n| Marks | Bounds on $N$ and $M$ | Bounds on $l_i$ | Bounds on $c_i$ | Additional Constraints |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $3$ marks | $1 \\leq N\\leq 2000$, $1\\leq M \\leq 2000$ | $l_i = 0$ | $1 \\leq c_i \\leq 10^9$ | None. |\n| $6$ marks | $1 \\leq N\\leq 2000$, $1\\leq M \\leq 2000$ | $1 \\leq l_i \\leq 10^9$ | $1 \\leq c_i \\leq 10^9$ | There is at most one road between any unordered pair of intersections. |\n| $6$ marks | $1 \\leq N\\leq 2000$, $1\\leq M \\leq 2000$ | $0 \\leq l_i \\leq 10^9$ | $1 \\leq c_i \\leq 10^9$ | None. |\n", "outputFormat": "Output one integer, the minimum possible cost of a road plan that meets the requirements.", "hint": "Explanation of Output for Sample Input：\n\nHere is a diagram of the intersections along with a valid road plan with minimum cost.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2astpvkm.png)\n\nEach edge is labeled with a pair $(l, c)$ denoting that it has length $l$ meters and cost $c$ dollars.\n\nAdditionally, the roads that are part of the plan are highlighted in blue, with a total cost of $7 + 1 + 6 + 7 + 4 = 25$.\n\nIt can be shown that we cannot create a cheaper plan that also respects the city’s requirements.\n\n**本题采用捆绑测试**：\n\n- Subtask 1（3 points）：数据保证 $1\\leq N \\leq 2000$，$1\\leq M \\leq 2000$，$l_i = 0$，$1\\leq c_i \\leq 10^9$。\n\n- Subtask 2（6 points）：数据保证 $1\\leq N\\leq 2000$，$1\\leq M \\leq 2000$，$1\\leq l_i \\leq 10^9$，$1\\leq c_i \\leq 10^9$，且在任何一对十字路口之间最多只有一条路。\n\n- Subtask 3（6 points）：数据保证 $1\\leq N\\leq 2000$，$1\\leq M \\leq 2000$，$0\\leq l_i \\leq 10^9$，$1\\leq c_i \\leq 10^9$。", "locale": "en"}, "zh-CN": {"title": "[CCC 2023 S4] Minimum Cost Roads", "background": "", "description": "作为新当选的基奇纳市市长，Alanna 的首要任务是改善城市的道路规划。\n\n基奇纳当前的道路规划可以表示为 $N$ 个交叉路口和 $M$ 条道路的集合，其中第 $i$ 条道路的长度为 $l_i$ 米，每年维护费用为 $c_i$ 美元，并连接交叉路口 $u_i$ 和 $v_i$。为了制定计划，Alanna 必须选择保留和维护的 $M$ 条道路的一个子集，该计划的费用是该子集中所有道路的维护费用之和。\n\n为了降低城市的年度支出，Alanna 希望将计划的费用最小化。然而，城市还要求她最小化交叉路口之间的旅行距离，并拒绝任何不符合这些规则的计划。正式地，对于任何交叉路口对 $(i, j)$，如果在现有道路规划中存在从 $i$ 到 $j$ 的路径，且路径长度为 $l$ 米，则 Alanna 的计划中也必须包含一条长度不超过 $l$ 米的路径。", "inputFormat": "第一行包含整数 $N$ 和 $M$。\n\n接下来的 $M$ 行中的每一行包含整数 $u_i, v_i, l_i$ 和 $c_i$，表示当前存在一条从交叉路口 $u_i$ 到交叉路口 $v_i$ 的道路，长度为 $l_i$，费用为 $c_i$（$1 \\leq u_i, v_i \\leq N, u_i \neq v_i$）。\n\n下表显示了可用的 15 分数的分布。\n\n| 分数 | $N$ 和 $M$ 的界限 | $l_i$ 的界限 | $c_i$ 的界限 | 额外约束 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $3$ 分 | $1 \\leq N\\leq 2000$, $1\\leq M \\leq 2000$ | $l_i = 0$ | $1 \\leq c_i \\leq 10^9$ | 无。 |\n| $6$ 分 | $1 \\leq N\\leq 2000$, $1\\leq M \\leq 2000$ | $1 \\leq l_i \\leq 10^9$ | $1 \\leq c_i \\leq 10^9$ | 在任意一对交叉路口之间最多只有一条道路。 |\n| $6$ 分 | $1 \\leq N\\leq 2000$, $1\\leq M \\leq 2000$ | $0 \\leq l_i \\leq 10^9$ | $1 \\leq c_i \\leq 10^9$ | 无。 |", "outputFormat": "输出一个整数，表示满足要求的道路规划的最小可能费用。", "hint": "样例输入的输出解释：\n\n这是交叉路口的图示，以及一个具有最小费用的有效道路规划。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2astpvkm.png)\n\n每条边都标有一个对 $(l, c)$，表示其长度为 $l$ 米，费用为 $c$ 美元。\n\n此外，计划中的道路用蓝色突出显示，总费用为 $7 + 1 + 6 + 7 + 4 = 25$。\n\n可以证明，我们无法创建一个更便宜且符合城市要求的计划。\n\n**本题采用捆绑测试**：\n\n- 子任务 1（3 分）：数据保证 $1\\leq N \\leq 2000$，$1\\leq M \\leq 2000$，$l_i = 0$，$1\\leq c_i \\leq 10^9$。\n\n- 子任务 2（6 分）：数据保证 $1\\leq N\\leq 2000$，$1\\leq M \\leq 2000$，$1\\leq l_i \\leq 10^9$，$1\\leq c_i \\leq 10^9$，且在任何一对十字路口之间最多只有一条路。\n\n- 子任务 3（6 分）：数据保证 $1\\leq N\\leq 2000$，$1\\leq M \\leq 2000$，$0\\leq l_i \\leq 10^9$，$1\\leq c_i \\leq 10^9$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9328", "type": "P", "difficulty": 5, "samples": [["12", "0\n1\n3\n4\n8\n9\n11\n12"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "CCC（加拿大）"], "title": "[CCC 2023 S5] The Filter", "background": "", "description": "Alice, the mathematician, likes to study real numbers that are between $0$ and $1$. Her favourite tool is the filter.\n\nA filter covers part of the number line. When a number reaches a filter, two events can happen. If a number is not covered by the filter, the number will pass through. If a number is covered, the number will be removed.\n\nAlice has infinitely many filters. Her first $3$ filters look like this:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2rm8ihzn.png)\n\nIn general, the $k\\text{-th}$ filter can be defined as follows:\n\n- Consider the number line from $0$ to $1$.\n\n- Split this number line into $3^k$ equal-sized pieces. There are $3^k + 1$ points and $3^k$ intervals.\n\n- The $k\\text{-th}$ filter consists of the $2^{\\text{nd}}$ interval, $5^{\\text{th}}$ interval, $8^{\\text{th}}$ interval, and in general, the $(3i-1)^{\\text{th}}$ interval. The points are **not** part of the $k\\text{-th}$ filter.\n\nAlice has instructions for constructing the Cantor set. Start with the number line from $0$ to $1$. Apply all filters on the number line, and remove the numbers that are covered. The remaining numbers form the Cantor set.\n\nAlice wants to research the Cantor set, and she came to you for help. Given an integer $N$, Alice would like to know which fractions $\\frac{x}{N}$ are in the Cantor set.", "inputFormat": "The first line contains the integer $N$.\n\nThe following table shows how the available $15$ marks are distributed.\n\n| Marks | Bounds on $N$ | Additional Constraints |\n| :----------: | :----------: | :----------: |\n| $3$ marks | $3 \\leq N \\leq 3^{18}$ | $N$ is a power of $3$. |\n| $4$ marks | $2 \\leq N \\leq 2 \\times 10^5$ | None. |\n| $8$ marks | $2 \\leq N \\leq 2 \\times 10^9$ | None. |\n", "outputFormat": "Output all integers $x$ where $0 \\leq x \\leq N$ and $\\frac{x}{N}$ is in the Cantor set.\n\nOutput the answers in increasing order. The number of answers will not exceed $10^6$.\n", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/jy3xb2rz.png)\n\n$\\frac{5}{12},\\frac{6}{12},\\frac{7}{12}$ are not in the Cantor set because they were covered by the 1st filter.\nFurthermore, $\\frac{2}{12}$ and $\\frac{10}{12}$\nare not in the Cantor set because they were covered by the $2^{\\text{nd}}$ filter.\n\nIt can be shown that the remaining fractions will pass through all filters.\n\n**本题采用捆绑测试**：\n\n- Subtask 1（3 points）：$3 \\leq N \\leq 3 ^{18}$，$N$ 是 $3$ 的整数次幂。\n\n- Subtask 2（4 points）：$2 \\leq N \\leq 2\\times 10^5$。\n\n- Subtask 3（8 points）：$2 \\leq N \\leq 2 \\times 10^9$。", "locale": "en", "translations": {"en": {"title": "[CCC 2023 S5] The Filter", "background": "", "description": "Alice, the mathematician, likes to study real numbers that are between $0$ and $1$. Her favourite tool is the filter.\n\nA filter covers part of the number line. When a number reaches a filter, two events can happen. If a number is not covered by the filter, the number will pass through. If a number is covered, the number will be removed.\n\nAlice has infinitely many filters. Her first $3$ filters look like this:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2rm8ihzn.png)\n\nIn general, the $k\\text{-th}$ filter can be defined as follows:\n\n- Consider the number line from $0$ to $1$.\n\n- Split this number line into $3^k$ equal-sized pieces. There are $3^k + 1$ points and $3^k$ intervals.\n\n- The $k\\text{-th}$ filter consists of the $2^{\\text{nd}}$ interval, $5^{\\text{th}}$ interval, $8^{\\text{th}}$ interval, and in general, the $(3i-1)^{\\text{th}}$ interval. The points are **not** part of the $k\\text{-th}$ filter.\n\nAlice has instructions for constructing the Cantor set. Start with the number line from $0$ to $1$. Apply all filters on the number line, and remove the numbers that are covered. The remaining numbers form the Cantor set.\n\nAlice wants to research the Cantor set, and she came to you for help. Given an integer $N$, Alice would like to know which fractions $\\frac{x}{N}$ are in the Cantor set.", "inputFormat": "The first line contains the integer $N$.\n\nThe following table shows how the available $15$ marks are distributed.\n\n| Marks | Bounds on $N$ | Additional Constraints |\n| :----------: | :----------: | :----------: |\n| $3$ marks | $3 \\leq N \\leq 3^{18}$ | $N$ is a power of $3$. |\n| $4$ marks | $2 \\leq N \\leq 2 \\times 10^5$ | None. |\n| $8$ marks | $2 \\leq N \\leq 2 \\times 10^9$ | None. |\n", "outputFormat": "Output all integers $x$ where $0 \\leq x \\leq N$ and $\\frac{x}{N}$ is in the Cantor set.\n\nOutput the answers in increasing order. The number of answers will not exceed $10^6$.\n", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/jy3xb2rz.png)\n\n$\\frac{5}{12},\\frac{6}{12},\\frac{7}{12}$ are not in the Cantor set because they were covered by the 1st filter.\nFurthermore, $\\frac{2}{12}$ and $\\frac{10}{12}$\nare not in the Cantor set because they were covered by the $2^{\\text{nd}}$ filter.\n\nIt can be shown that the remaining fractions will pass through all filters.\n\n**本题采用捆绑测试**：\n\n- Subtask 1（3 points）：$3 \\leq N \\leq 3 ^{18}$，$N$ 是 $3$ 的整数次幂。\n\n- Subtask 2（4 points）：$2 \\leq N \\leq 2\\times 10^5$。\n\n- Subtask 3（8 points）：$2 \\leq N \\leq 2 \\times 10^9$。", "locale": "en"}, "zh-CN": {"title": "[CCC 2023 S5] The Filter", "background": "", "description": "数学家 Alice 喜欢研究介于 $0$ 和 $1$ 之间的实数。她最喜欢的工具是滤器。\n\n滤器覆盖数轴的一部分。当一个数字到达滤器时，会发生两种情况。如果一个数字没有被滤器覆盖，则该数字将通过。如果一个数字被覆盖，则该数字将被移除。\n\nAlice 有无数个滤器。她的前三个滤器如下所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2rm8ihzn.png)\n\n一般来说，第 $k$ 个滤器可以定义如下：\n\n- 考虑从 $0$ 到 $1$ 的数轴。\n\n- 将这个数轴分成 $3^k$ 个等大小的部分。有 $3^k + 1$ 个点和 $3^k$ 个区间。\n\n- 第 $k$ 个滤器由第 $2$ 个区间、第 $5$ 个区间、第 $8$ 个区间组成，一般来说，是第 $(3i-1)$ 个区间。这些点**不**是第 $k$ 个滤器的一部分。\n\nAlice 有构造 Cantor 集合的说明。首先从 $0$ 到 $1$ 的数轴开始。对数轴应用所有滤器，并移除被覆盖的数字。剩下的数字形成 Cantor 集合。\n\nAlice 想研究 Cantor 集合，她来找你帮忙。给定一个整数 $N$，Alice 想知道哪些分数 $\\frac{x}{N}$ 在 Cantor 集合中。", "inputFormat": "第一行包含整数 $N$。\n\n下表显示了可用的 $15$ 分的分布情况。\n\n| 分数 | $N$ 的范围 | 额外约束 |\n| :----------: | :----------: | :----------: |\n| $3$ 分 | $3 \\leq N \\leq 3^{18}$ | $N$ 是 $3$ 的幂。 |\n| $4$ 分 | $2 \\leq N \\leq 2 \\times 10^5$ | 无。 |\n| $8$ 分 | $2 \\leq N \\leq 2 \\times 10^9$ | 无。 |", "outputFormat": "输出所有整数 $x$，其中 $0 \\leq x \\leq N$ 且 $\\frac{x}{N}$ 在 Cantor 集合中。\n\n按递增顺序输出答案。答案的数量不会超过 $10^6$。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/jy3xb2rz.png)\n\n$\\frac{5}{12},\\frac{6}{12},\\frac{7}{12}$ 不在 Cantor 集合中，因为它们被第一个滤器覆盖。此外，$\\frac{2}{12}$ 和 $\\frac{10}{12}$ 不在 Cantor 集合中，因为它们被第二个滤器覆盖。\n\n可以证明，剩下的分数将通过所有滤器。\n\n**本题采用捆绑测试**：\n\n- 子任务 1（3 分）：$3 \\leq N \\leq 3 ^{18}$，$N$ 是 $3$ 的整数次幂。\n\n- 子任务 2（4 分）：$2 \\leq N \\leq 2\\times 10^5$。\n\n- 子任务 3（8 分）：$2 \\leq N \\leq 2 \\times 10^9$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9329", "type": "P", "difficulty": 6, "samples": [["5 4 3\n1 2\n1 3\n2 4\n2 5\n2 9\n2 4\n3 5\n4 7\n3 4 2 11\n5 3 4 5\n2 3 1 1\n", "1\n2\n-1\n"], ["10 7 9\n1 8\n6 3\n5 9\n7 9\n3 1\n3 4\n10 1\n2 6\n5 6\n9 4\n7 4\n7 4\n2 4\n7 4\n7 4\n1 4\n8 6 5 3\n3 9 8 0\n4 7 6 15\n7 4 9 3\n6 4 8 0\n9 10 5 16\n5 3 2 4\n2 8 4 3\n6 1 3 3\n", "3\n6\n6\n7\n7\n3\n1\n2\n2\n"], ["8 7 11\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n4 4\n3 7\n2 10\n5 2\n4 1\n4 4\n5 6\n6 3 7 69\n7 1 5 55\n3 1 6 8\n8 2 5 45\n4 6 4 45\n6 1 3 33\n2 1 0 19\n3 7 2 31\n7 1 2 31\n7 2 4 58\n8 3 5 63\n", "7\n5\n5\n5\n4\n2\n0\n2\n1\n4\n5\n"], ["8 7 11\n1 8\n1 4\n3 1\n3 6\n6 7\n2 1\n5 2\n5 5\n5 8\n4 7\n6 6\n4 1\n6 4\n1 7\n4 7 2 18\n2 4 5 1\n4 2 1 32\n1 5 7 21\n2 5 0 50\n8 4 4 33\n1 7 6 16\n4 8 7 18\n1 2 8 13\n5 4 10 42\n7 1 6 40\n", "1\n3\n1\n7\n0\n4\n5\n7\n8\n10\n6"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "O2优化", "JOISC/JOIST（日本）"], "title": "[JOIST 2023] 两种货币 / Two Currencies", "background": "", "description": "在 JOI 王国中，有 $n$ 个城市，编号从 $1$ 到 $n$。JOI 王国有 $n−1$ 条双向道路，编号从 $1$ 到 $n−1$。第 $i$ 条道路连接城市 $a_i$ 和城市 $b_i$。\n\n在 JOI 王国中，一些道路上放有检查站。有 $m$ 个检查站，编号从 $1$ 到 $m$。第 $j$ 个检查站位于道路 $p_j$ 上。通过该检查站需要支付 $1$ 枚金币或 $c_j$ 枚银币。\n\n在 JOI 王国有 $q$ 名公民，编号从 $1$ 到 $q$。第 $k$ 名公民持有 $x_k$ 枚金币和 $y_k$ 枚银币，并希望从城市 $s_k$ 前往城市 $t_k$。由于金币具有较高的价值，所有公民都希望尽可能多地保留金币。\n\n编写一个程序，给定 JOI 王国中的城市、道路、检查站和公民信息，对于每个 $k (1≤k≤q)$，判断公民 $k$ 是否能够从城市 $s_k$ 前往城市 $t_k$，并在此条件成立时计算公民 $k$ 所能保留的最多金币数。", "inputFormat": "从标准输入读入以下数据。\n> $N \\ M \\ Q$\n>\n> $A_1 \\ B_1$\n>\n> $A_2 \\ B_2$\n>\n> $\\vdots$\n>\n> $A_{N - 1} \\ B_{N - 1}$\n>\n> $P_1 \\ C_1$\n>\n> $P_2 \\ C_2$\n>\n> $\\vdots$\n>\n> $P_M \\ C_M$\n>\n> $S_1 \\ T_1 \\ X_1 \\ Y_1$\n>\n> $S_2 \\ T_2 \\ X_2 \\ Y_2$\n>\n> $\\vdots$\n>\n> $S_Q \\ T_Q \\ X_Q \\ Y_Q$", "outputFormat": "向标准输出打印 $q$ 行。在第 $k$ 行 $(1≤k≤q)$ 中，如果公民 $k$ 可以从城市 $s_k$ 前往城市 $t_k$，请输出公民 $k$ 可以保留的最多金币数。否则，在第 $k$ 行中输出 $−1$。\n\nTranslate by @[ZeXic_B](https://www.luogu.com.cn/user/661274)", "hint": "数据范围：$2\\le N\\le 10^5$，$1\\le M,Q\\le 10^5$，$1\\le A_i,B_i\\le N$，$1\\le P_i\\le N-1$，$1\\le C_j\\le 10^9$，$1\\le S_k,T_k\\le N$，$S_k\\neq T_k$，$0\\le X_k\\le 10^9$，$0\\le Y_k\\le 10^{18}$，所有数都是整数，所有城市连通。\n\nSubtasks：\n- Subtask 1（10 分）：$N,M,Q\\le 2000$。\n- Subtask 2（28 分）：$C_1=C_2=\\cdots=C_M$。\n- Subtask 3（30 分）：$A_i=i$，$B_i=i+1$。\n- Subtask 4（32 分）：无特殊限制。", "locale": "zh-CN", "translations": {"en": {"title": "[JOIST 2023] Two Currencies", "background": null, "description": "There are $N$ cities in JOI Kingdom, numbered from $1$ to $N$. There are $N - 1$ roads in JOI Kingdom, numbered from $1$ to $N - 1$. The road $i \\ (1 \\le i \\le N - 1)$ connects the city $A_i$ and the city $B_i$ bi-directionally. It is possible to travel from any city to any other city by passing through some of the roads.\n\nThere are checkpoints on some of the roads in JOI Kingdom. There are $M$ checkpoints, numbered from $1$ to $M$. The checkpoint $j \\ (1 \\le j \\le M)$ is located on the road $P_j$. In order to pass through it, you need to pay either one gold coin or $C_j$ silver coins.\n\nThere are $Q$ citizens in JOI Kingdom, numbered from $1$ to $Q$. The citizen $k \\ (1 \\le k \\le Q)$ has $X_k$ gold coins and $Y_k$ silver coins, and wants to travel from the city $S_k$ to the city $T_k$. Since gold coins are valuable, all the citizens want to keep as many gold coins as possible.\n\nWrite a program which, given information of the cities, the roads, the checkpoints, and the citizens in JOI Kingdom, for each $k \\ (1 \\le k \\le Q)$, determines whether it is possible for the citizen $k$ to travel from the city $S_k$ to the city $T_k$, and, if it is possible, calculates the maximum possible number of gold coins the citizen $k$ can keep.", "inputFormat": "Read the following data from the standard input.\n\n> $N \\ M \\ Q$\n>\n> $A_1 \\ B_1$\n>\n> $A_2 \\ B_2$\n>\n> $\\vdots$\n>\n> $A_{N - 1} \\ B_{N - 1}$\n>\n> $P_1 \\ C_1$\n>\n> $P_2 \\ C_2$\n>\n> $\\vdots$\n>\n> $P_M \\ C_M$\n>\n> $S_1 \\ T_1 \\ X_1 \\ Y_1$\n>\n> $S_2 \\ T_2 \\ X_2 \\ Y_2$\n>\n> $\\vdots$\n>\n> $S_Q \\ T_Q \\ X_Q \\ Y_Q$", "outputFormat": "Write $Q$ lines to the standard output. In the $k$-th line $(1 \\le k \\le Q)$, if the citizen $k$ can travel from the city $S_k$ to the city $T_k$, output the maximum possible number of gold coins the citizen $k$ can keep. Otherwise, output $-1$ in the $k$-th line.", "hint": "**【样例解释 #1】**\n\nThe citizen $1$ can travel from the city $3$ to the city $4$ as follows. After the travel, the citizen $1$ keeps one gold coin.\n\n1.  The citizen $1$ travels from the city $3$ to the city $1$ by passing through the road $2$. There are the checkpoints $1, 2$ on the road $2$. The citizen $1$ pays one gold coin at the checkpoint $1$ and passes through it, and $4$ silver coins at the checkpoint $2$ and passes through it, respectively. After that, the citizen $1$ keeps one gold coin and $7$ silver coins.\n2. The citizen $1$ travels from the city $1$ to the city $2$ by passing through the road $1$. Since there is no checkpoint on the road $1$, the citizen $1$ keeps one gold coin and $7$ silver coins.\n3. The citizen $1$ travels from the city $2$ to the city $4$ by passing through the road $3$. There is the checkpoint $3$ on the road $3$. The citizen $1$ pays $5$ silver coins at the checkpoint $3$ and passes through it. After that, the citizen $1$ keeps one gold coin and $2$ silver coins.\n\nSince it is impossible for the citizen $1$ to travel by finally keeping more than or equal to $2$ gold coins, output $1$ in the first line.\n\nThe citizen $2$ can travel from the city $5$ to the city $3$ as follows. After the travel, the citizen $2$ keeps two gold coins.\n\n1. The citizen $2$ travels from the city $5$ to the city $2$ by passing through the road $4$. There is the checkpoint $4$ on the road $4$. The citizen $2$ pays one gold coin at the checkpoint $4$ and passes through it. After that, the citizen $2$ keeps $3$ gold coins and $5$ silver coins.\n2. The citizen $2$ travels from the city $2$ to the city $1$ by passing through the road $1$. Since there is no checkpoint on the road $1$, the citizen $2$ keeps $3$ gold coins and $5$ silver coins.\n3. The citizen $2$ travels from the city $1$ to the city $3$ by passing through the road $2$. On the road $2$, there are the checkpoints $1, 2$. The citizen $2$ pays one gold coin at the checkpoint $1$ and passes through it, and $4$ silver coins at the checkpoint $2$ and passes through it, respectively. After that, the citizen $2$ keeps $2$ gold coins and one silver coin.\n\nSince it is impossible for the citizen $2$ to travel by finally keeping more than or equal to $3$ gold coins, output $2$ in the second line.\n\nSince it is impossible for the citizen $3$ to travel from the city $2$ to the city $3$, output $-1$ in the third line.\n\n该样例满足子任务 $1, 4$ 的限制。\n\n**【样例解释 #2】**\n\n该样例满足子任务 $1, 2, 4$ 的限制。\n\n**【样例解释 #3】**\n\n该样例满足子任务 $1, 3, 4$ 的限制。\n\n**【样例解释 #4】**\n\n该样例满足子任务 $1, 4$ 的限制。\n\n\n**【数据范围】**\n\n对于所有测试数据，满足 $2 \\le N \\le 10 ^ 5$，$1 \\le M, Q \\le 10 ^ 5$，$1 \\le A_i, B_i \\le N$，$1 \\le P_j \\le N - 1$，$1 \\le C_j \\le 10 ^ 9$，$1 \\le S_k, T_k \\le N$，$S_k \\ne T_k$，$0 \\le X_k \\le 10 ^ 9$，$0 \\le Y_k \\le 10 ^ {18}$，保证给定的道路使所有城市连通，保证所有输入均为整数。\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$10$|$N, M, Q \\le 2000$|\n|$2$|$28$|$C_1 = C_2 = \\dots = C_M$|\n|$3$|$30$|$A_i = i$，$B_i = i + 1$|\n|$4$|$32$|无|", "locale": "en"}, "zh-CN": {"title": "[JOIST 2023] 两种货币 / Two Currencies", "background": "", "description": "在 JOI 王国中，有 $n$ 个城市，编号从 $1$ 到 $n$。JOI 王国有 $n−1$ 条双向道路，编号从 $1$ 到 $n−1$。第 $i$ 条道路连接城市 $a_i$ 和城市 $b_i$。\n\n在 JOI 王国中，一些道路上放有检查站。有 $m$ 个检查站，编号从 $1$ 到 $m$。第 $j$ 个检查站位于道路 $p_j$ 上。通过该检查站需要支付 $1$ 枚金币或 $c_j$ 枚银币。\n\n在 JOI 王国有 $q$ 名公民，编号从 $1$ 到 $q$。第 $k$ 名公民持有 $x_k$ 枚金币和 $y_k$ 枚银币，并希望从城市 $s_k$ 前往城市 $t_k$。由于金币具有较高的价值，所有公民都希望尽可能多地保留金币。\n\n编写一个程序，给定 JOI 王国中的城市、道路、检查站和公民信息，对于每个 $k (1≤k≤q)$，判断公民 $k$ 是否能够从城市 $s_k$ 前往城市 $t_k$，并在此条件成立时计算公民 $k$ 所能保留的最多金币数。", "inputFormat": "从标准输入读入以下数据。\n> $N \\ M \\ Q$\n>\n> $A_1 \\ B_1$\n>\n> $A_2 \\ B_2$\n>\n> $\\vdots$\n>\n> $A_{N - 1} \\ B_{N - 1}$\n>\n> $P_1 \\ C_1$\n>\n> $P_2 \\ C_2$\n>\n> $\\vdots$\n>\n> $P_M \\ C_M$\n>\n> $S_1 \\ T_1 \\ X_1 \\ Y_1$\n>\n> $S_2 \\ T_2 \\ X_2 \\ Y_2$\n>\n> $\\vdots$\n>\n> $S_Q \\ T_Q \\ X_Q \\ Y_Q$", "outputFormat": "向标准输出打印 $q$ 行。在第 $k$ 行 $(1≤k≤q)$ 中，如果公民 $k$ 可以从城市 $s_k$ 前往城市 $t_k$，请输出公民 $k$ 可以保留的最多金币数。否则，在第 $k$ 行中输出 $−1$。\n\nTranslate by @[ZeXic_B](https://www.luogu.com.cn/user/661274)", "hint": "数据范围：$2\\le N\\le 10^5$，$1\\le M,Q\\le 10^5$，$1\\le A_i,B_i\\le N$，$1\\le P_i\\le N-1$，$1\\le C_j\\le 10^9$，$1\\le S_k,T_k\\le N$，$S_k\\neq T_k$，$0\\le X_k\\le 10^9$，$0\\le Y_k\\le 10^{18}$，所有数都是整数，所有城市连通。\n\nSubtasks：\n- Subtask 1（10 分）：$N,M,Q\\le 2000$。\n- Subtask 2（28 分）：$C_1=C_2=\\cdots=C_M$。\n- Subtask 3（30 分）：$A_i=i$，$B_i=i+1$。\n- Subtask 4（32 分）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P9330", "type": "P", "difficulty": 7, "samples": [["3 100000007\n", "2\n"], ["4 100000007\n", "28\n"], ["15 999999937\n", "935834920\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "O2优化", "JOISC/JOIST（日本）"], "title": "[JOIST 2023] JOI 国的节日 2 / Festivals in JOI Kingdom 2", "background": null, "description": "在 JOI 王国，每年都会举行一次全国性的节日。在节日期间，总共有 $N$ 个活动。每个活动的时间表已经固定。$N$ 个活动的时间表由长度为 $N$ 的序列 $a, b$ 描述，满足以下条件：\n\n- 从 $1$ 到 $2N$ 之间的每个整数都出现在 $a$ 或 $b$ 中。\n- $a_i < b_i \\ (1 \\le i \\le N)$。\n- $a_i < a_{i + 1} \\ (1 \\le i \\le N - 1)$。\n\n第 $i$ 个活动将在节日开始后的 $a_i$ 分钟开始，并在节日开始后的 $b_i$ 分钟结束。\n\n节日的参与者可以选择参加任意活动。然而，不允许参加时间表重叠的两个活动。（注意，活动的开始时间和结束时间彼此不同。）\n\nJOI-kun 想参加尽可能多的活动。直到去年，他通过计算机使用以下程序选择参加的活动：\n\n> 对于 $i = 1, 2, \\dots, N$，按以下顺序进行。\n> > 如果第 $i$ 个活动的时间表与他已经选择参加的其他活动的时间表不重叠，他将参加第 $i$ 个活动。否则，他将不参加第 $i$ 个活动。\n\n然而，在学习了计算机科学之后，JOI-kun 注意到上述算法并不一定能最大化他参加的活动数量。从今年开始，JOI-kun 将使用改进的算法。使用改进的算法，JOI-kun 将能够最大化他参加的活动数量。\n\nJOI-kun 想知道使用改进算法时，产生更多活动数量的情况数。\n\n编写一个程序，给定整数 $N$ 和一个大质数 $P$，计算出描述 $N$ 个活动时间表的序列 $a, b$ 的对数，其中改进的算法产生更多的活动数量。由于答案可能非常大，程序应输出答案除以 $P$ 的余数。", "inputFormat": "从标准输入读取以下数据。\n\n> $N \\ P$", "outputFormat": "向标准输出写入一行。输出应包含答案的余数，即描述 $N$ 个活动时间表的序列 $a, b$ 的对数，其中改进的算法产生更多的活动数量，除以 $P$ 的余数。", "hint": "**【样例解释 #1】**\n\n例如，考虑 $a = (1, 2, 4)$ 和 $b = (6, 3, 5)$ 的情况。如果 JOI-kun 使用去年使用的算法，他将只参加第一个活动。另一方面，如果他使用正确的算法来最大化活动数量，他将参加第二个和第三个活动。因此，他将参加两个活动。在这种情况下，改进的算法产生了更多的活动数量。\n\n以下是改进的算法产生更多活动数量的序列对 $a, b$：\n\n- $a = (1, 2, 4), b = (6, 3, 5)$\n- $a = (1, 2, 4), b = (5, 3, 6)$\n\n因此，输出 $2$，这是 $2$ 除以 $100000007$ 的余数。\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\n有 $28$ 对序列 $a, b$ 满足条件。因此，输出 $28$，这是 $28$ 除以 $100000007$ 的余数。\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #3】**\n\n有 $5295044602247148$ 对序列 $a, b$ 满足条件。因此，输出 $935834920$，这是 $5295044602247148$ 除以 $999999937$ 的余数。\n\n该样例满足子任务 $3 \\sim 6$ 的限制。\n\n**【数据范围】**\n\n对于所有测试数据，满足 $1 \\le N \\le 2 \\times 10 ^ 4$，$10 ^ 8 < P < 10 ^ 9$，保证 $P$ 是质数，保证所有输入均为整数。\n\n|子任务编号|分值|$N \\le$|\n|:-:|:-:|:-:|\n|$1$|$5$|$5$|\n|$2$|$5$|$8$|\n|$3$|$27$|$30$|\n|$4$|$14$|$300$|\n|$5$|$36$|$3000$|\n|$6$|$13$|$2 \\times 10 ^ 4$|\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN", "translations": {"en": {"title": "[JOISC 2023] Festivals in JOI Kingdom 2", "background": "", "description": "In JOI Kingdom, a national festival is held once a year. During the period of the festival, there are $N$ events in total. The schedule for each event is already fixed. The schedule of the $N$ events are described by sequences $a, b$ of length $N$ satisfying the following conditions.\n\n- Every integer between $1$ and $2N$, inclusive, appears as an element of $a$ or $b$.\n- $a_i < b_i \\ (1 \\le i \\le N)$.\n- $a_i < a_{i + 1} \\ (1 \\le i \\le N - 1)$.\n\nThe $i$-th event will start at $a_i$ minutes after the beginning of the festival, and end at $b_i$ minutes after the beginning of the festival.\n\nParticipants of the festival may choose any events in which they will participate. However, it is not allowed to participate in two events whose schedules overlap. (Note that the starting times and the ending times of the events are different from each other.)\n\nJOI-kun wants to participate in as many events as possible. Until last year, he chose the events in which he participated by the following procedures on a computer.\n\n> For $i = 1, 2, \\dots, N$，the following are done in this order.\n> > If the schedule of the $i$-th event does not overlap the schedules of the other events in which he already chose to participate, he will participate in the $i$-th event. Otherwise, he will not participate in the $i$-th event.\n\nHowever, after studying computer science, JOI-kun noticed that the above algorithm does not necessarily maximize the number of events in which JOI-kun will participate. From this year, JOI-kun will use an improved algorithm. Using the improved algorithm, JOI-kun will be able to maximize the number of events in which JOI-kun will participate.\n\nJOI-kun wants to know the number of cases where the improved algorithm produces a larger number of events.\n\nWrite a program which, given the integer $N$ and a large prime number $P$, calculates the number of pairs of sequences $a, b$ describing the schedules of the $N$ events for which the improved algorithm produces a larger number of events. Since the answer can be very large, your program should output the remainder of the answer when divided by $P$.", "inputFormat": "Read the following data from the standard input.\n\n> $N \\ P$", "outputFormat": "Write one line to the standard output. The output should contain the remainder of the answer, the number of pairs of sequences $a, b$ describing the schedules of the $N$ events for which the improved algorithm produces a larger number of events, when divided by $P$.", "hint": "**【样例解释 #1】**\n\nFor example, consider the case where $a = (1, 2, 4)$ and $b = (6, 3, 5)$. If JOI-kun uses the algorithm used until last year, he will participate in the first event only. On the other hand, if he uses a correct algorithm to maximize the number of events, he will participate in the second event and the third event. Thus, he will participate in two events. In this case, the improved algorithm produces a larger number of events.\n\nThe following are the pair of sequences $a, b$ for which the improved algorithm produces a larger number of events.\n\n- $a = (1, 2, 4), b = (6, 3, 5)$\n- $a = (1, 2, 4), b = (5, 3, 6)$\n\nTherefore, output $2$, which is the remainder of $2$ when divided by $100000007$.\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\nThere are $28$ pairs of sequences $a, b$ satisfying the condition. Therefore, output $28$, which is the remainder of $28$ when divided by $100000007$.\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #3】**\n\nThere are $5295044602247148$ pairs of sequences $a, b$ satisfying the condition. Therefore, output $935834920$, which is the remainder of $5295044602247148$ when divided by $999999937$.\n\n该样例满足子任务 $3 \\sim 6$ 的限制。\n\n**【数据范围】**\n\n对于所有测试数据，满足 $1 \\le N \\le 2 \\times 10 ^ 4$，$10 ^ 8 < P < 10 ^ 9$，保证 $P$ 是质数，保证所有输入均为整数。\n\n|子任务编号|分值|$N \\le$|\n|:-:|:-:|:-:|\n|$1$|$5$|$5$|\n|$2$|$5$|$8$|\n|$3$|$27$|$30$|\n|$4$|$14$|$300$|\n|$5$|$36$|$3000$|\n|$6$|$13$|$2 \\times 10 ^ 4$|", "locale": "en"}, "zh-CN": {"title": "[JOIST 2023] JOI 国的节日 2 / Festivals in JOI Kingdom 2", "background": null, "description": "在 JOI 王国，每年都会举行一次全国性的节日。在节日期间，总共有 $N$ 个活动。每个活动的时间表已经固定。$N$ 个活动的时间表由长度为 $N$ 的序列 $a, b$ 描述，满足以下条件：\n\n- 从 $1$ 到 $2N$ 之间的每个整数都出现在 $a$ 或 $b$ 中。\n- $a_i < b_i \\ (1 \\le i \\le N)$。\n- $a_i < a_{i + 1} \\ (1 \\le i \\le N - 1)$。\n\n第 $i$ 个活动将在节日开始后的 $a_i$ 分钟开始，并在节日开始后的 $b_i$ 分钟结束。\n\n节日的参与者可以选择参加任意活动。然而，不允许参加时间表重叠的两个活动。（注意，活动的开始时间和结束时间彼此不同。）\n\nJOI-kun 想参加尽可能多的活动。直到去年，他通过计算机使用以下程序选择参加的活动：\n\n> 对于 $i = 1, 2, \\dots, N$，按以下顺序进行。\n> > 如果第 $i$ 个活动的时间表与他已经选择参加的其他活动的时间表不重叠，他将参加第 $i$ 个活动。否则，他将不参加第 $i$ 个活动。\n\n然而，在学习了计算机科学之后，JOI-kun 注意到上述算法并不一定能最大化他参加的活动数量。从今年开始，JOI-kun 将使用改进的算法。使用改进的算法，JOI-kun 将能够最大化他参加的活动数量。\n\nJOI-kun 想知道使用改进算法时，产生更多活动数量的情况数。\n\n编写一个程序，给定整数 $N$ 和一个大质数 $P$，计算出描述 $N$ 个活动时间表的序列 $a, b$ 的对数，其中改进的算法产生更多的活动数量。由于答案可能非常大，程序应输出答案除以 $P$ 的余数。", "inputFormat": "从标准输入读取以下数据。\n\n> $N \\ P$", "outputFormat": "向标准输出写入一行。输出应包含答案的余数，即描述 $N$ 个活动时间表的序列 $a, b$ 的对数，其中改进的算法产生更多的活动数量，除以 $P$ 的余数。", "hint": "**【样例解释 #1】**\n\n例如，考虑 $a = (1, 2, 4)$ 和 $b = (6, 3, 5)$ 的情况。如果 JOI-kun 使用去年使用的算法，他将只参加第一个活动。另一方面，如果他使用正确的算法来最大化活动数量，他将参加第二个和第三个活动。因此，他将参加两个活动。在这种情况下，改进的算法产生了更多的活动数量。\n\n以下是改进的算法产生更多活动数量的序列对 $a, b$：\n\n- $a = (1, 2, 4), b = (6, 3, 5)$\n- $a = (1, 2, 4), b = (5, 3, 6)$\n\n因此，输出 $2$，这是 $2$ 除以 $100000007$ 的余数。\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\n有 $28$ 对序列 $a, b$ 满足条件。因此，输出 $28$，这是 $28$ 除以 $100000007$ 的余数。\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #3】**\n\n有 $5295044602247148$ 对序列 $a, b$ 满足条件。因此，输出 $935834920$，这是 $5295044602247148$ 除以 $999999937$ 的余数。\n\n该样例满足子任务 $3 \\sim 6$ 的限制。\n\n**【数据范围】**\n\n对于所有测试数据，满足 $1 \\le N \\le 2 \\times 10 ^ 4$，$10 ^ 8 < P < 10 ^ 9$，保证 $P$ 是质数，保证所有输入均为整数。\n\n|子任务编号|分值|$N \\le$|\n|:-:|:-:|:-:|\n|$1$|$5$|$5$|\n|$2$|$5$|$8$|\n|$3$|$27$|$30$|\n|$4$|$14$|$300$|\n|$5$|$36$|$3000$|\n|$6$|$13$|$2 \\times 10 ^ 4$|\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9331", "type": "P", "difficulty": 6, "samples": [["4\n1 3\n2 4\n2 3\n4 4\n1\n1\n", "2\n"], ["5\n1 5\n2 4\n2 3\n3 5\n1 5\n1\n3\n", "4\n"], ["5\n1 1\n2 3\n1 5\n3 4\n5 5\n5\n1\n2\n3\n4\n5\n", "-1\n2\n1\n2\n-1\n"], ["4\n1 2\n1 2\n3 4\n3 4\n4\n1\n2\n3\n4\n", "-1\n-1\n-1\n-1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2023", "O2优化", "最短路", "JOISC/JOIST（日本）"], "title": "[JOIST 2023] 护照 / Passport", "background": null, "description": "护照是旅行家进入他国时使用的证件。\n\n在一个星球上有 $N$ 个国家，从 $1$ 到 $N$ 编号。每个国家都签发一种护照。当旅行家获得由国家$i \\ (1 \\le i \\le N)$ 签发的护照后，他能够进入国家 $L_i, L_i + 1, \\dots, R_i$。**这里保证旅行家能够进入其签证的签发国。形式上地说, $L_i \\le i \\le R_i$ 必然成立。**\n\n你有一个爱旅行的朋友。即使他奢望能环游世界，但他最初一种护照也没有。因此，他想通过一下重复以下两项行为来环游这 $N$ 个国家。\n\n- 获得他当前所在国家签发的护照。\n- 用他现有的护照进入某个国家。\n\n知道他的计划后，你想知道这个计划的是否可行，和如果可行的话，他最少需要的护照数量。因为你并不清楚他现在身处何国，所以你预测了 $Q$ 个他可能正居住在那的国家 $X_1, X_2, \\dots, X_Q$。\n\n现在给定各国护照的信息 $L_i, R_i$ 和他可能居住的 $Q$ 个国家，您需要写一个程序，对于每一个可能居住的国家，判断他是否可能环游这 $N$ 个国家，如果可能的话，计算出他需要的最少护照种数。", "inputFormat": "从标准输入读入：\n\n> $N$\n>\n> $L_1 \\ R_1$\n>\n> $L_2 \\ R_2$\n>\n> $\\vdots$\n>\n> $L_N \\ R_N$\n>\n> $Q$\n>\n> $X_1$\n>\n> $X_2$\n>\n> $\\vdots$\n>\n> $X_Q$", "outputFormat": "输出 $Q$ 行至标准输出，第 $j \\ (1 \\le j \\le Q)$ 行一个整数代表若你的朋友位于国家 $X_j$ 的答案。若他能环游这 $N$ 个国家，则输出他需要的最少护照种数，否则输出 $-1$。", "hint": "**【数据范围】**\n\n对于所有测试数据，满足 $2 \\le N \\le 2 \\times 10 ^ 5$，$1 \\le L_i \\le i \\le R_i \\le N$，$1 \\le Q \\le N$，$1 \\le X_1 < X_2 < \\dots < X_Q \\le N$，保证所有输入均为整数。\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$6$|$Q = 1$，$X_1 = 1$|\n|$2$|$16$|$N \\le 300$，$Q = 1$|\n|$3$|$24$|$N \\le 2500$，$Q = 1$|\n|$4$|$8$|$N \\le 2500$|\n|$5$|$46$|无|\n\n**【样例解释 #1】**\n\n假设你的朋友居住在国家 $X_1 = 1$，一种可行的方式如下，最后他获得了 $2$ 种护照：\n\n1. 获得国家 $1$ 签发的护照。\n2. 用国家 $1$ 签发的护照去国家 $2$ 旅行。\n3. 获得国家 $2$ 签发的护照。\n4. 用国家 $1$ 签发的护照去国家 $3$ 旅行。\n5. 用国家 $2$ 签发的护照去国家 $4$ 旅行。\n\n可以证明不存在使用护照种数更小的方案，故输出 $2$。\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\n假设你的朋友居住在国家 $X_1 = 3$。一种可行的方式如下，最后他获得了 $4$ 种护照：\n\n1. 获得国家 $3$ 签发的护照。\n2. 用国家 $3$ 签发的护照去国家 $2$ 旅行。\n3. 获得国家 $2$ 签发的护照。\n4. 用国家 $2$ 签发的护照去国家 $4$ 旅行。\n5. 获得国家 $4$ 签发的护照。\n6. 用国家 $4$ 签发的护照去国家 $5$ 旅行。\n7. 获得国家 $5$ 签发的护照。\n8. 用国家 $5$ 签发的护照去国家 $1$ 旅行。\n\n可以证明不存在使用护照种数更小的方案，故输出 $4$。\n\n该样例满足子任务 $2 \\sim 5$ 的限制。\n\n**【样例解释 #3】**\n\n例如，如果你的朋友居住在 $X_3 = 3$，一种可行的方案书获得国家 $3$ 签发的护照，并用它来依次去国家 $1, 2, 4, 5$ 旅行。故第三行输出 $3$。\n\n但如果你的朋友居住在国家 $X_5 = 5$，即使他获得了国家 $5$ 签发的护照，他也不可能进入任何其他国家，因此，他无法实现自己的旅行计划。故第五行输出 $-1$。\n\n该样例满足子任务 $4 \\sim 5$ 的限制。\n\n**【样例解释 #4】**\n\n该样例满足子任务 $4 \\sim 5$ 的限制。", "locale": "zh-CN", "translations": {"en": {"title": "[JOIST 2023] Passport", "background": null, "description": "Passport is a certificate which is used worldwide when a traveler enters foreign countries.\n\nIn a planet, there are $N$ countries, numbered from $1$ to $N$. Each country issues a passport. When a traveler has a passport issued by the country $i \\ (1 \\le i \\le N)$, the traveler can enter the countries $L_i, L_i + 1, \\dots, R_i$. **Here, it is guaranteed that the traveler can enter the country where the passport was issued. Namely, $L_i \\le i \\le R_i$ is satisfied.**\n\nYou have a friend who likes traveling. Although he dreams of traveling around the world, he does not have a passport in the beginning. Thus, he plans to visit all of the $N$ countries by repeating the following two actions.\n\n- He gets a passport issued by the country where he is currently staying.\n- He moves to a country where he can enter using a passport he currently has.\n\nWhen you hear about his plan, you are wondering whether it is possible to realize the plan, and, if it is possible, what is the minimum number of passports he needs to get. Since you do not know where he lives, you consider $Q$ possible countries $X_1, X_2, \\dots, X_Q$ where he lives.\n\nWrite a program which, given information of the passports and the possibilities of his living place, for each possibility, determines whether it is possible for him to visit all of the $N$ countries, and, if it is possible, calculates the minimum number of passports he needs to get.", "inputFormat": "Read the following data from the standard input.\n\n> $N$\n>\n> $L_1 \\ R_1$\n>\n> $L_2 \\ R_2$\n>\n> $\\vdots$\n>\n> $L_N \\ R_N$\n>\n> $Q$\n>\n> $X_1$\n>\n> $X_2$\n>\n> $\\vdots$\n>\n> $X_Q$", "outputFormat": "Write $Q$ lines to the standard output. The $j$-th line $(1 \\le j \\le Q)$ corresponds to the case where your friend lives in the country $X_j$. If it is possible for him to visit all of the $N$ countries, this line should contain the minimum number of passports he needs to get. Otherwise, this line should contain $-1$.", "hint": "**【样例解释 #1】**\n\nAssume that your friend lives in the country $X_1 = 1$. It is possible for him to visit all of the $4$ countries if he acts in the following way. Then, he gets $2$ passports.\n\n1. He gets a passport issued by the country $1$.\n2. Using the passport issued by the country $1$, he moves to the country $2$.\n3. He gets a passport issued by the country $2$.\n4. Using the passport issued by the country $1$, he moves to the country $3$.\n5. Using the passport issued by the country $2$, he moves to the country $44.\n\nSince it is impossible to realize the plan if he gets less than or equal to $1$ passport, output $2$.\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\nAssume that your friend lives in the country $X_1 = 3$. It is possible for him to visit all of the $5$ countries if he acts in the following way. Then, he gets $4$ passports.\n1. He gets a passport issued by the country $3$.\n2. Using the passport issued by the country $3$, he moves to the country $2$.\n3. He gets a passport issued by the country $2$.\n4. Using the passport issued by the country $2$, he moves to the country $4$.\n5. He gets a passport issued by the country $4$.\n6. Using the passport issued by the country $4$, he moves to the country $5$.\n7. He gets a passport issued by the country $5$.\n8. Using the passport issued by the country $5$, he moves to the country $1$.\n\nSince it is impossible to realize the plan if he gets less than or equal to $3$ passports, output $4$.\n\n该样例满足子任务 $2 \\sim 5$ 的限制。\n\n**【样例解释 #3】**\n\nFor example, if your friend lives in the country $X_3 = 3$, it is possible to realize the plan if he gets a passport issued by the country $3$, and uses it to visit the countries $1, 2, 4, 5$ in this order. Therefore, output $1$ in the third line.\n\nOn the other hand, if your friend lives in the country $X_5 = 5$, it is impossible for him to enter other countries even if he gets a passport issued by the country $5$. Thus, he cannot realize the plan. Therefore, output $-1$ in the fifth line.\n\n该样例满足子任务 $4 \\sim 5$ 的限制。\n\n**【样例解释 #4】**\n\n该样例满足子任务 $4 \\sim 5$ 的限制。\n\n**【数据范围】**\n\n对于所有测试数据，满足 $2 \\le N \\le 2 \\times 10 ^ 5$，$1 \\le L_i \\le i \\le R_i \\le N$，$1 \\le Q \\le N$，$1 \\le X_1 < X_2 < \\dots < X_Q \\le N$，保证所有输入均为整数。\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$6$|$Q = 1$，$X_1 = 1$|\n|$2$|$16$|$N \\le 300$，$Q = 1$|\n|$3$|$24$|$N \\le 2500$，$Q = 1$|\n|$4$|$8$|$N \\le 2500$|\n|$5$|$46$|无|", "locale": "en"}, "zh-CN": {"title": "[JOIST 2023] 护照 / Passport", "background": null, "description": "护照是旅行家进入他国时使用的证件。\n\n在一个星球上有 $N$ 个国家，从 $1$ 到 $N$ 编号。每个国家都签发一种护照。当旅行家获得由国家$i \\ (1 \\le i \\le N)$ 签发的护照后，他能够进入国家 $L_i, L_i + 1, \\dots, R_i$。**这里保证旅行家能够进入其签证的签发国。形式上地说, $L_i \\le i \\le R_i$ 必然成立。**\n\n你有一个爱旅行的朋友。即使他奢望能环游世界，但他最初一种护照也没有。因此，他想通过一下重复以下两项行为来环游这 $N$ 个国家。\n\n- 获得他当前所在国家签发的护照。\n- 用他现有的护照进入某个国家。\n\n知道他的计划后，你想知道这个计划的是否可行，和如果可行的话，他最少需要的护照数量。因为你并不清楚他现在身处何国，所以你预测了 $Q$ 个他可能正居住在那的国家 $X_1, X_2, \\dots, X_Q$。\n\n现在给定各国护照的信息 $L_i, R_i$ 和他可能居住的 $Q$ 个国家，您需要写一个程序，对于每一个可能居住的国家，判断他是否可能环游这 $N$ 个国家，如果可能的话，计算出他需要的最少护照种数。", "inputFormat": "从标准输入读入：\n\n> $N$\n>\n> $L_1 \\ R_1$\n>\n> $L_2 \\ R_2$\n>\n> $\\vdots$\n>\n> $L_N \\ R_N$\n>\n> $Q$\n>\n> $X_1$\n>\n> $X_2$\n>\n> $\\vdots$\n>\n> $X_Q$", "outputFormat": "输出 $Q$ 行至标准输出，第 $j \\ (1 \\le j \\le Q)$ 行一个整数代表若你的朋友位于国家 $X_j$ 的答案。若他能环游这 $N$ 个国家，则输出他需要的最少护照种数，否则输出 $-1$。", "hint": "**【数据范围】**\n\n对于所有测试数据，满足 $2 \\le N \\le 2 \\times 10 ^ 5$，$1 \\le L_i \\le i \\le R_i \\le N$，$1 \\le Q \\le N$，$1 \\le X_1 < X_2 < \\dots < X_Q \\le N$，保证所有输入均为整数。\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$6$|$Q = 1$，$X_1 = 1$|\n|$2$|$16$|$N \\le 300$，$Q = 1$|\n|$3$|$24$|$N \\le 2500$，$Q = 1$|\n|$4$|$8$|$N \\le 2500$|\n|$5$|$46$|无|\n\n**【样例解释 #1】**\n\n假设你的朋友居住在国家 $X_1 = 1$，一种可行的方式如下，最后他获得了 $2$ 种护照：\n\n1. 获得国家 $1$ 签发的护照。\n2. 用国家 $1$ 签发的护照去国家 $2$ 旅行。\n3. 获得国家 $2$ 签发的护照。\n4. 用国家 $1$ 签发的护照去国家 $3$ 旅行。\n5. 用国家 $2$ 签发的护照去国家 $4$ 旅行。\n\n可以证明不存在使用护照种数更小的方案，故输出 $2$。\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\n假设你的朋友居住在国家 $X_1 = 3$。一种可行的方式如下，最后他获得了 $4$ 种护照：\n\n1. 获得国家 $3$ 签发的护照。\n2. 用国家 $3$ 签发的护照去国家 $2$ 旅行。\n3. 获得国家 $2$ 签发的护照。\n4. 用国家 $2$ 签发的护照去国家 $4$ 旅行。\n5. 获得国家 $4$ 签发的护照。\n6. 用国家 $4$ 签发的护照去国家 $5$ 旅行。\n7. 获得国家 $5$ 签发的护照。\n8. 用国家 $5$ 签发的护照去国家 $1$ 旅行。\n\n可以证明不存在使用护照种数更小的方案，故输出 $4$。\n\n该样例满足子任务 $2 \\sim 5$ 的限制。\n\n**【样例解释 #3】**\n\n例如，如果你的朋友居住在 $X_3 = 3$，一种可行的方案书获得国家 $3$ 签发的护照，并用它来依次去国家 $1, 2, 4, 5$ 旅行。故第三行输出 $3$。\n\n但如果你的朋友居住在国家 $X_5 = 5$，即使他获得了国家 $5$ 签发的护照，他也不可能进入任何其他国家，因此，他无法实现自己的旅行计划。故第五行输出 $-1$。\n\n该样例满足子任务 $4 \\sim 5$ 的限制。\n\n**【样例解释 #4】**\n\n该样例满足子任务 $4 \\sim 5$ 的限制。", "locale": "zh-CN"}}}
{"pid": "P9332", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "交互题", "Special Judge", "O2优化", "JOISC/JOIST（日本）"], "title": "[JOIST 2023] 传送带 / Belt Conveyor", "background": "不要 $\\texttt{\\#include \"conveyor.h\"}$。请使用 $\\texttt{C++\\,20}$ 提交。\n\n提交前请将以下内容粘贴到代码前面：\n\n```cpp\n#include <vector>\n\nvoid Solve(int N, std::vector<int> A, std::vector<int> B);\n\nstd::vector<int> Query(std::vector<int> x, std::vector<int> y);\nvoid Answer(std::vector<int> a);\n```", "description": "在 JOI 有限公司的工厂里，有 $N$ 张桌子，从 $0$ 到 $N-1$ 编号。工厂里有 $N-1$ 条皮带输送机，从 $0$ 到 $N-2$ 编号。第 $i$ 条 $(0 \\le i \\le N-2)$ 皮带输送机连接桌子 $A_i$ 和桌子 $B_i$。它将产品从一张桌子运输到另一张桌子。然而，我们**不知道**运输的方向。\n\n\nIOI-kun 是工厂的经理。由于他忘记了每条皮带输送机的运输方向，他将多次按照以下顺序执行操作。\n1. 选择几条输送带，并反转所选输送带的运输方向。\n2. 选择几张桌子，并在每张选定的桌子上放一件商品。\n3. 每当把产品放在一张桌子上时，就会发生以下情况之一。\n\n- 如果没有输送带将产品从该桌子运走，则不会发生任何事情。\n- 如果有输送带将产品从该桌子运走，则桌子上的产品将由其中一条输送带运输。产品将在输送带的目的地停止，并且产品将不再移动。\n4. IOI-kun 会确认每张桌子上是否有产品。如果有产品在桌子上，IOI-kun 会把它们全部拿走。\n5. 对于每个在操作 1 中改变了方向的皮带输送机，IOI-kun 都会将其方向恢复到原来的方向。IOI-kun 希望通过最多执行 $30$ 次上述顺序操作来为每个皮带输送机指定原始方向。\n\n请编写一个程序，根据皮带输送机之间的连接表，实现 IOI-kun 的策略，以通过最多执行 $30$ 次上述顺序操作来为每个皮带输送机指定原始方向。\n\n### 实现细节\n\n你需要实现一份 C++ 程序，提交时**不需要**包含 `conveyor.h`。\n\n你应该实现以下函数。\n\n```cpp\nvoid Solve(int N, std::vector<int> A, std::vector<int> B)\n```\n\n\n该函数仅在每个测试用例中被调用一次：\n\n- 参数 $N$：传送带连接的桌子的数量。\n- 参数 $A$ 和 $B$ 是长度为 $N - 1$ 的数组，描述由皮带输送机连接的桌子。\n\n您的程序可以调用以下函数：\n\n```cpp\nstd::vector<int> Query(std::vector<int> x, std::vector<int> y)\n```\n\n\n使用这个函数，IOI-kun 在工厂中执行操作。\n\n- 参数 $x$ 是一个长度为 $N - 1$ 的数组。对于 $0\\le i\\le N - 2$，如果 $x_i = 1$，IOI-kun 将反转第 $i$ 个传送带的方向，否则不反转该传送带的方向。\n- 参数 $y$ 是一个长度为 $N$ 的数组。对于 $0 \\le j \\le N - 1$，如果 $y_j = 1$，IOI-kun 将在第 $j$ 个桌子上放置一个产品，否则不会在该桌子上放置产品。\n- 设 $z$ 是该函数的返回值。它是一个长度为 $N$ 的数组。对于 $0 \\le j \\le N - 1$，如果 $z_j = 1$，则第 $j$ 个桌子上有产品，如果 $z_j = 0$，则第 $j$ 个桌子上没有产品。\n- 数组 $x$ 的长度应等于 $N - 1$。如果不满足此条件，您的程序将被评为 `Wrong Answer[1]`。\n- 数组 $x$ 中的每个元素都应为 $0$ 或 $1$。如果不满足此条件，您的程序将被评为 `Wrong Answer[2]`。\n- 数组 $y$ 的长度应等于 $N$。如果不满足此条件，您的程序将被评为 `Wrong Answer[3]`。\n- 数组 $y$ 中的每个元素都应为 $0$ 或 $1$。如果不满足上述条件，您的程序将被评为 `Wrong Answer[4]`。\n- 函数 Query 最多只能被调用 $30$ 次。如果被调用次数超过 $30$ 次，您的程序将被评为 `Wrong Answer[5]`。\n\n```cpp\nvoid Answer(std::vector<int> a)\n```\n\n使用这个函数，IOI-kun 会报告每个输送带的原始方向。\n\n- 参数 $a$ 是一个长度为 $N - 1$ 的数组。对于 $0 \\le i \\le N - 2$，如果 $a_i = 0$，则输送带 $i$ 将产品从 $A_i$ 运输到 $B_i$，如果 $a_i = 1$，则将产品从 $B_i$ 运输到 $A_i$。\n- 数组 $a$ 的长度必须等于 $N - 1$。如果条件不满足，您的程序将被评为 `Wrong Answer[6]`。\n- 数组 $a$ 中的每个元素都必须为 $0$ 或 $1$。如果条件不满足，您的程序将被评为 `Wrong Answer[7]`。\n- 如果 IOI-kun 报告了输送带的错误方向，您的程序将被评为 `Wrong Answer[8]`。\n- 函数 `Answer` 必须被**恰好调用一次**。如果函数 `Answer` 被调用多次，您的程序将被评为 `Wrong Answer[9]`。当函数 `Solve` 结束时，如果函数 `Answer` 尚未被调用，您的程序将被评为 `Wrong Answer[10]`。", "inputFormat": "样例评测库将读入以下格式的数据：\n```\nN\nA[0] A[1] ... A[N - 2]\nB[0] B[1] ... B[N - 2]\nC[0] C[1] ... C[N - 2]\n```\n对于 $0\\le i\\le N - 2$，如果第 $i$ 条传送带会将产品从 $A_i$ 运输至 $B_i$，那么 $C_i$ 为 $0$，否则 $C_i$ 为 $1$。", "outputFormat": "样例评测库将以下信息输出到 stdout。\n\n-如果你的程序被判断为正确，它报告的函数 `Query` 调用的数量为 `Accepted: 22` 。\n\n-如果你的程序被判定为任何类型的错误答案，样例评分员将其类型写为 `Wrong Answer[4]`。\n\n\n\n如果您的程序满足几种类型的错误答案的条件，则样例评测库只报告其中一种。\n\n### 输入输出样例\n#### 样例 #1\n```plain\n3\n0 2\n2 1\n1 0\n```", "hint": "|函数调用|函数调用|返回值|\n|:-|:-|:-|\n|`Solve(3, [0, 2], [2, 1])`|||\n||`Query([0, 0], [0, 0, 1])`|`[1, 0, 0]`|\n||`Query([1, 0], [1, 0, 1])`|`[0, 1, 1]`|\n||`Query([1, 1], [0, 0, 1])`|`[0, 0, 1]`|\n||`Query([0, 1], [1, 1, 1])`|`[1, 0, 1]`|\n||`Answer([1, 0])`||\n\n对于对 `Query` 的第一次调用，另一个可能的返回值是 `[0,1,0]`。\n\n\n\n对于对 `Query` 的第二次调用，位置为 $0$ 上的产品通过传送带 $0$ 被传送到位置 $2$，并停在那里。请注意，该产品不会被传送带 $1$ 输送到位置 $1$。\n\n\n\n注意，这个示例输入**不满足任何子任务**的限制条件。\n\n\n\n下发文件中，`sample-02.txt` 满足 Subtask $1$ 的限制条件，`sample-03.txt` 满足 Subtask $2$ 的限制条件。\n\n对于某些测试用例，实际的评测程序**是自适应的**。这意味着评测程序在开始时没有固定的答案，并根据先前对 `Query` 函数的调用进行响应。\n\n**【数据范围】**\n\n对于所有测试数据，满足 $0 \\le A_i, B_i \\le N - 1$，保证忽略所有传送带的方向后所有机器连通，保证所有输入均为整数。\n\n|子任务编号|分值|$N =$|特殊性质|\n|:-:|:-:|:-:|:-:|\n|$1$|$1$|$2$|无|\n|$2$|$14$|$30$|无|\n|$3$|$10$|$10 ^ 5$|$A_i = i$，$B_i = i + 1$|\n|$4$|$75$|$10 ^ 5$|无|\n\nTranslate by @[tbdsh](/user/752485).", "locale": "zh-CN", "translations": {"en": {"title": "[JOIST 2023] Belt Conveyor", "background": "**This is an interactive task. **\nPlease paste the following content in front of the code before submission:\n\n```cpp\n#include <vector>\n\nvoid Solve(int N, std::vector<int> A, std::vector<int> B);\n\nstd::vector<int> Query(std::vector<int> x, std::vector<int> y);\nvoid Answer(std::vector<int> a);\n```", "description": "**【题目描述】**\n\nIn the factory of JOI Co., Ltd., there are $N$ tables, numbered from $0$ to $N - 1$. In the factory, there are $N - 1$ belt conveyors, numbered from $0$ to $N - 2$. The belt conveyor $i \\ (0 \\le i \\le N - 2)$ connects the table $A_i$ and the table $B_i$. It transports products from one table to the other table. However, we cannot see the direction of transportation. If we ignore the directions of the belt conveyors, every pair of tables is connected by a number of belt conveyors.\n\nIOI-kun is the director of the factory. Since he forgets the direction of transportation of every belt conveyor, he will perform the following sequential operations several times.\n\n1. He chooses a number of belt conveyors, and reverses the directions of transportation of the chosen belt conveyors.\n2. He chooses a number of tables, and puts a product on each chosen table.\n3. For every table where a product is put, one of the following happens simultaneously.\n    - If there is no belt conveyor transporting products from it, nothing happens.\n    - If there are belt conveyors transporting products from it, the product on the table is transported by one of such belt conveyors. The product stops at the destination of the belt conveyor. The product will not move anymore.\n4. IOI-kun confirms whether there are one or more products on each table. If there are products on a table, IOI-kun takes all of them.\n5. For every belt conveyor whose direction is reversed in the operation 1., IOI-kun reverts its direction. Its direction becomes the original direction.\n\nIOI-kun wants to specify the original direction of every belt conveyor by performing the above sequential operations at most $30$ times.\n\nWrite a program which, given information of the tables connected by the belt conveyors, implements IOI-kun’s strategy to specify the original direction of every belt conveyor by performing the above sequential operations at most $30$ times.\n\n**【实现细节】**\n\nYou need to submit one file.\n\nThe file is `conveyor.cpp`. It should implement the following function. The program should include `conveyor.h` using the preprocessing directive `#include`.\n\nIn `conveyor.cpp`, the following function should be implemented.\n\n```cpp\nvoid Solve(int N, std::vector<int> A, std::vector<int> B)\n```\n\nThis function is called only once for each test case.\n\n- The parameter `N` is the number of tables $N$.\n- The parameters `A，B` are arrays of length $N - 1$, describing the tables connected by the belt conveyors.\n\nYour program can call the following function.\n\n```cpp\nstd::vector<int> Query(std::vector<int> x, std::vector<int> y)\n```\n\nUsing this function, IOI-kun performs the operations in the factory.\n\n- The parameter `x` is an array of length $N - 1$. For $0 \\le \\texttt{i} \\le N - 2$, IOI-kun reverses the direction of the belt conveyor `i` if `x[i] = 1`, and does not reverses the direction of the belt conveyor `i` if `x[i] = 0`.\n- The parameter `y` is an array of length $$. For $0 \\le \\texttt{j} \\le N - 1$, IOI-kun puts a product on the table `j` if `y[j] = 1`, and does not put a product on the table `j` if `y[j] = 0`.\n- Let `z` be the return value of this function. It is an array of length $N$. For $0 \\le \\texttt{j} \\le N - 1$, there are one or more products on the table `j` if `z[j] = 1`, and there is no product on the table `j` if `z[j] = 0`.\n- The length of the array `x` should be equal to $N - 1$. If this condition is not satisfied, your program is judged as `Wrong Answer [1]`.\n- Every element of the array `x` should be `0` or `1`. If this condition is not satisfied, your program is judged as `Wrong Answer [2]`.\n- The length of the array `y` should be equal to $N$. If this condition is not satisfied, your program is judged as `Wrong Answer [3]`.\n- Every element of the array `y` should be `0` or `1`. If this condition is not satisfied, your program is judged as `Wrong Answer [4]`.\n- The function Query should not be called more than $30$ times. If it is called more than $30$ times, your program is judged as `Wrong Answer [5]`.\n\n```cpp\nvoid Answer(std::vector<int> a)\n```\n\nUsing this function, IOI-kun reports the original direction of each belt conveyor.\n\n- The parameter `a` is an array of length $N - 1$. For $0 \\le \\texttt{i} \\le N - 2$, the belt conveyor `i` transports products from $A_i$ to $B_i$ if `a[i] = 0`, and it transports products from $B_i$ to $A_i$ if `a[i] = 1`.\n- The length of the array `a` should be equal to $N - 1$. If this condition is not satisfied, your program is judged as `Wrong Answer [6]`.\n- Every element of the array `a` should be `0` or `1`. If this condition is not satisfied, your program is judged as `Wrong Answer [7]`.\n- If IOI-kun reports wrong direction of a belt conveyor, your program is judged as `Wrong Answer [8]`.\n- The function `Answer` should be called exactly once. If the function `Answer` is called more than once, your program is judged as `Wrong Answer [9]`. When the function `Solve` terminates, if the function `Answer` is not called, your program is judged as `Wrong Answer [10]`.\n\n#### Important Notices\n\n- Your program can implement other functions for internal use, or use global variables.\n- Your program must not use the standard input and the standard output. Your program must not communicate with other files by any methods. However, your program may output debugging information to the standard error.\n\n**【评测方式】**\n\nYou can download an archive file from the contest webpage which contains the sample grader to test your program. The archive file also contains a sample source file of your program.\n\nThe sample grader is the file `grader.cpp`. In order to test your program, put `grader.cpp`, `conveyor.cpp`, `conveyor.h` in the same directory, and run the following command to compile your programs. Instead, you may run `compile.sh` contained in the archive file.\n\n```plain\ng++ -std=gnu++17 -O2 -o grader grader.cpp conveyor.cpp\n```\n\nWhen the compilation succeeds, the executable file `grader` is generated.\n\nNote that the actual grader is different from the sample grader. The sample grader will be executed as a single process, which will read input data from the standard input and write the results to the standard output.", "inputFormat": "The sample grader reads the following data from the standard input.\n\n> $N$\n>\n> $A_0 \\ A_1 \\ \\cdots \\ A_{N - 2}$\n>\n> $B_0 \\ B_1 \\ \\cdots \\ B_{N - 2}$\n>\n> $C_0 \\ C_1 \\ \\cdots \\ C_{N - 2}$\n\nFor $0 \\le i \\le N - 2$, we have $C_i = 0$ if the belt conveyor $i$ transports products from the table $A_i$ to the table $B_i$. Otherwise, we have $C_i = 1$.", "outputFormat": "The sample grader outputs the following information to the standard output (quotes for clarity).\n\n- If your program is judged as correct, it reports the number of function calls to `Query` as `Accepted: 22`.\n- If your program is judged as any type of Wrong Answer, the sample grader writes its type as `Wrong Answer [4]`.\n\nIf your program satisfies the conditions of several types of Wrong Answer, the sample grader reports only one of them.\n\nIn sample grader, among the belt conveyors transporting products from the table where a product is put, the belt conveyor transporting the product is chosen uniformly and randomly determined by pseudorandom numbers whose results do not change for different executions. In order to change the seed of pseudorandom numbers, run the sample grader with the first integer argument as follows.\n\n```plain\n./grader 2023\n```", "hint": "**【评测程序示例】**\n\nHere is a sample input for the sample grader and corresponding function calls.\n\n**Sample Input 1:**\n\n```plain\n3\n0 2\n2 1\n1 0\n```\n\n|Function Calls|Function Calls|Return Values|\n|:-|:-|:-|\n|`Solve(3, [0, 2], [2, 1])`|||\n||`Query([0, 0], [0, 0, 1])`|`[1, 0, 0]`|\n||`Query([1, 0], [1, 0, 1])`|`[0, 1, 1]`|\n||`Query([1, 1], [0, 0, 1])`|`[0, 0, 1]`|\n||`Query([0, 1], [1, 1, 1])`|`[1, 0, 1]`|\n||`Answer([1, 0])`||\n\nFor the first function call to `Query`, another possible return value is `[0, 1, 0]` other than `[1, 0, 0]`.\n\nFor the second function call to `Query`, the product on the table $0$ is transported to the table $2$ by passing through the belt conveyor $0$, and stops there. Note that this product will not be transported to the table $1$ by passing through the belt conveyor $1$.\n\nNote that this sample input **does not satisfy the constraints of any subtask**.\n\nAmong the files which can be obtained from the contest webpage, `sample-02.txt` satisfies the constraints of Subtask $1$, and `sample-03.txt` satisfies the constraints of Subtask $2$.\n\n#### Notices for Grading\n\nFor some of the test cases, the actual grader is adaptive. This means the grader does not have a fixed answer in the beginning, and responds according to previous function calls to Query. It is guaranteed that there is at least one answer which does not contradict all the responses of the the grader.\n\n**【数据范围】**\n\n对于所有测试数据，满足 $0 \\le A_i, B_i \\le N - 1$，保证忽略所有传送带的方向后所有机器连通，保证所有输入均为整数。\n\n|子任务编号|分值|$N =$|特殊性质|\n|:-:|:-:|:-:|:-:|\n|$1$|$1$|$2$|无|\n|$2$|$14$|$30$|无|\n|$3$|$10$|$10 ^ 5$|$A_i = i$，$B_i = i + 1$|\n|$4$|$75$|$10 ^ 5$|无|", "locale": "en"}, "zh-CN": {"title": "[JOIST 2023] 传送带 / Belt Conveyor", "background": "不要 $\\texttt{\\#include \"conveyor.h\"}$。请使用 $\\texttt{C++\\,20}$ 提交。\n\n提交前请将以下内容粘贴到代码前面：\n\n```cpp\n#include <vector>\n\nvoid Solve(int N, std::vector<int> A, std::vector<int> B);\n\nstd::vector<int> Query(std::vector<int> x, std::vector<int> y);\nvoid Answer(std::vector<int> a);\n```", "description": "在 JOI 有限公司的工厂里，有 $N$ 张桌子，从 $0$ 到 $N-1$ 编号。工厂里有 $N-1$ 条皮带输送机，从 $0$ 到 $N-2$ 编号。第 $i$ 条 $(0 \\le i \\le N-2)$ 皮带输送机连接桌子 $A_i$ 和桌子 $B_i$。它将产品从一张桌子运输到另一张桌子。然而，我们**不知道**运输的方向。\n\n\nIOI-kun 是工厂的经理。由于他忘记了每条皮带输送机的运输方向，他将多次按照以下顺序执行操作。\n1. 选择几条输送带，并反转所选输送带的运输方向。\n2. 选择几张桌子，并在每张选定的桌子上放一件商品。\n3. 每当把产品放在一张桌子上时，就会发生以下情况之一。\n\n- 如果没有输送带将产品从该桌子运走，则不会发生任何事情。\n- 如果有输送带将产品从该桌子运走，则桌子上的产品将由其中一条输送带运输。产品将在输送带的目的地停止，并且产品将不再移动。\n4. IOI-kun 会确认每张桌子上是否有产品。如果有产品在桌子上，IOI-kun 会把它们全部拿走。\n5. 对于每个在操作 1 中改变了方向的皮带输送机，IOI-kun 都会将其方向恢复到原来的方向。IOI-kun 希望通过最多执行 $30$ 次上述顺序操作来为每个皮带输送机指定原始方向。\n\n请编写一个程序，根据皮带输送机之间的连接表，实现 IOI-kun 的策略，以通过最多执行 $30$ 次上述顺序操作来为每个皮带输送机指定原始方向。\n\n### 实现细节\n\n你需要实现一份 C++ 程序，提交时**不需要**包含 `conveyor.h`。\n\n你应该实现以下函数。\n\n```cpp\nvoid Solve(int N, std::vector<int> A, std::vector<int> B)\n```\n\n\n该函数仅在每个测试用例中被调用一次：\n\n- 参数 $N$：传送带连接的桌子的数量。\n- 参数 $A$ 和 $B$ 是长度为 $N - 1$ 的数组，描述由皮带输送机连接的桌子。\n\n您的程序可以调用以下函数：\n\n```cpp\nstd::vector<int> Query(std::vector<int> x, std::vector<int> y)\n```\n\n\n使用这个函数，IOI-kun 在工厂中执行操作。\n\n- 参数 $x$ 是一个长度为 $N - 1$ 的数组。对于 $0\\le i\\le N - 2$，如果 $x_i = 1$，IOI-kun 将反转第 $i$ 个传送带的方向，否则不反转该传送带的方向。\n- 参数 $y$ 是一个长度为 $N$ 的数组。对于 $0 \\le j \\le N - 1$，如果 $y_j = 1$，IOI-kun 将在第 $j$ 个桌子上放置一个产品，否则不会在该桌子上放置产品。\n- 设 $z$ 是该函数的返回值。它是一个长度为 $N$ 的数组。对于 $0 \\le j \\le N - 1$，如果 $z_j = 1$，则第 $j$ 个桌子上有产品，如果 $z_j = 0$，则第 $j$ 个桌子上没有产品。\n- 数组 $x$ 的长度应等于 $N - 1$。如果不满足此条件，您的程序将被评为 `Wrong Answer[1]`。\n- 数组 $x$ 中的每个元素都应为 $0$ 或 $1$。如果不满足此条件，您的程序将被评为 `Wrong Answer[2]`。\n- 数组 $y$ 的长度应等于 $N$。如果不满足此条件，您的程序将被评为 `Wrong Answer[3]`。\n- 数组 $y$ 中的每个元素都应为 $0$ 或 $1$。如果不满足上述条件，您的程序将被评为 `Wrong Answer[4]`。\n- 函数 Query 最多只能被调用 $30$ 次。如果被调用次数超过 $30$ 次，您的程序将被评为 `Wrong Answer[5]`。\n\n```cpp\nvoid Answer(std::vector<int> a)\n```\n\n使用这个函数，IOI-kun 会报告每个输送带的原始方向。\n\n- 参数 $a$ 是一个长度为 $N - 1$ 的数组。对于 $0 \\le i \\le N - 2$，如果 $a_i = 0$，则输送带 $i$ 将产品从 $A_i$ 运输到 $B_i$，如果 $a_i = 1$，则将产品从 $B_i$ 运输到 $A_i$。\n- 数组 $a$ 的长度必须等于 $N - 1$。如果条件不满足，您的程序将被评为 `Wrong Answer[6]`。\n- 数组 $a$ 中的每个元素都必须为 $0$ 或 $1$。如果条件不满足，您的程序将被评为 `Wrong Answer[7]`。\n- 如果 IOI-kun 报告了输送带的错误方向，您的程序将被评为 `Wrong Answer[8]`。\n- 函数 `Answer` 必须被**恰好调用一次**。如果函数 `Answer` 被调用多次，您的程序将被评为 `Wrong Answer[9]`。当函数 `Solve` 结束时，如果函数 `Answer` 尚未被调用，您的程序将被评为 `Wrong Answer[10]`。", "inputFormat": "样例评测库将读入以下格式的数据：\n```\nN\nA[0] A[1] ... A[N - 2]\nB[0] B[1] ... B[N - 2]\nC[0] C[1] ... C[N - 2]\n```\n对于 $0\\le i\\le N - 2$，如果第 $i$ 条传送带会将产品从 $A_i$ 运输至 $B_i$，那么 $C_i$ 为 $0$，否则 $C_i$ 为 $1$。", "outputFormat": "样例评测库将以下信息输出到 stdout。\n\n-如果你的程序被判断为正确，它报告的函数 `Query` 调用的数量为 `Accepted: 22` 。\n\n-如果你的程序被判定为任何类型的错误答案，样例评分员将其类型写为 `Wrong Answer[4]`。\n\n\n\n如果您的程序满足几种类型的错误答案的条件，则样例评测库只报告其中一种。\n\n### 输入输出样例\n#### 样例 #1\n```plain\n3\n0 2\n2 1\n1 0\n```", "hint": "|函数调用|函数调用|返回值|\n|:-|:-|:-|\n|`Solve(3, [0, 2], [2, 1])`|||\n||`Query([0, 0], [0, 0, 1])`|`[1, 0, 0]`|\n||`Query([1, 0], [1, 0, 1])`|`[0, 1, 1]`|\n||`Query([1, 1], [0, 0, 1])`|`[0, 0, 1]`|\n||`Query([0, 1], [1, 1, 1])`|`[1, 0, 1]`|\n||`Answer([1, 0])`||\n\n对于对 `Query` 的第一次调用，另一个可能的返回值是 `[0,1,0]`。\n\n\n\n对于对 `Query` 的第二次调用，位置为 $0$ 上的产品通过传送带 $0$ 被传送到位置 $2$，并停在那里。请注意，该产品不会被传送带 $1$ 输送到位置 $1$。\n\n\n\n注意，这个示例输入**不满足任何子任务**的限制条件。\n\n\n\n下发文件中，`sample-02.txt` 满足 Subtask $1$ 的限制条件，`sample-03.txt` 满足 Subtask $2$ 的限制条件。\n\n对于某些测试用例，实际的评测程序**是自适应的**。这意味着评测程序在开始时没有固定的答案，并根据先前对 `Query` 函数的调用进行响应。\n\n**【数据范围】**\n\n对于所有测试数据，满足 $0 \\le A_i, B_i \\le N - 1$，保证忽略所有传送带的方向后所有机器连通，保证所有输入均为整数。\n\n|子任务编号|分值|$N =$|特殊性质|\n|:-:|:-:|:-:|:-:|\n|$1$|$1$|$2$|无|\n|$2$|$14$|$30$|无|\n|$3$|$10$|$10 ^ 5$|$A_i = i$，$B_i = i + 1$|\n|$4$|$75$|$10 ^ 5$|无|\n\nTranslate by @[tbdsh](/user/752485).", "locale": "zh-CN"}}}
{"pid": "P9333", "type": "P", "difficulty": 6, "samples": [["3 3\n1 0 0\n1 1 0\n1 1 1\n", "3\n3\n2\n"], ["4 12\n1 1 1 0 1 1 0 1 0 1 1 0\n1 1 0 1 1 0 1 1 1 1 1 0\n0 0 1 1 1 0 0 0 0 0 1 1\n1 0 0 0 1 1 1 1 1 0 0 0\n", "5\n4\n6\n6\n"], ["16 4\n0 0 0 0\n0 0 0 1\n0 0 1 0\n0 0 1 1\n0 1 0 0\n0 1 0 1\n0 1 1 0\n0 1 1 1\n1 0 0 0\n1 0 0 1\n1 0 1 0\n1 0 1 1\n1 1 0 0\n1 1 0 1\n1 1 1 0\n1 1 1 1\n", "3\n3\n3\n2\n3\n2\n2\n1\n3\n2\n2\n1\n2\n1\n1\n0\n"], ["4 2\n1 0\n0 1\n1 1\n1 1\n", "2\n2\n1\n1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "O2优化", "JOISC/JOIST（日本）"], "title": "[JOIST 2023] 议会 / Council", "background": "本题子任务编号如果为 0 表示样例，如果是非 0 的一位数表示满足对应的子任务，如果是两位数表示同时满足这两个子任务。", "description": "#### 题目翻译\n\n在 JOI 市议会中，有 $N$ 名议员，编号从 $1$ 到 $N$。议会将召开会议，议员们将对 $M$ 项提案进行表决，编号为 $1$ 到 $M$。如果 $A_{i,j}=1$，则议员 $i (1≤i≤N)$ 将对提案 $j (1≤j≤M)$ 表决肯定票。如果 $A_{i,j}=0$，则议员 $i$ 将对提案 $j$ 表决否定票。\n\nJOI 市议会的程序如下所示。\n\n+ 在 $N$ 名议员中，通过抽签随机选择主席。\n\n+ 主席将在除了主席以外的其他 $N−1$ 名议员中选择副主席。\n\n+ 将对 $M$ 项提案进行表决。除了主席和副主席以外的其他 $N−2$ 名议员，每人对每个提案均投票支持或反对。如果大多数议员（即肯定票大于等于 $⌊\\dfrac{N}{2}⌋$）投票赞成，则议会将批准该提案。其中 $⌊x⌋$ 表示不超过 $x$ 的最大整数。\n\n市长 K 希望议会尽可能地批准更多的提案。市长 K 收集了议员的信息并知道每个议员在每个提案上的表决结果。\n\n请编写程序，在给定议员投票信息的情况下，计算每个议员作为主席时议会可以批准的提案数量的最大可能值。", "inputFormat": "从标准输入读取以下数据。\n\n> $N \\ M$\n>\n> $A_{1, 1} \\ A_{1, 2} \\ \\cdots \\ A_{1, M}$\n>\n> $A_{2, 1} \\ A_{2, 2} \\ \\cdots \\ A_{2, M}$\n>\n> $\\vdots$\n>\n> $A_{N, 1} \\ A_{N, 2} \\ \\cdots \\ A_{N, M}$", "outputFormat": "输出 $N$ 行。输出的第 $i$ 行（$1≤i≤N$）应包含议员 $i$ 作为主席时议会可以批准的提案数量的最大可能值。", "hint": "该样例满足子任务 $1, 2, 4, 5, 6, 7$ 的限制。\n\n**【样例解释 #2】**\n\n该样例满足子任务 $1, 2, 5, 6, 7$ 的限制。\n\n**【样例解释 #3】**\n\n该样例满足子任务 $1, 2, 4, 5, 6, 7$ 的限制。\n\n**【样例解释 #4】**\n\n该样例满足所有子任务的限制。\n\n**【数据范围】**\n\n对于所有测试数据，$3 \\le N \\le 3 \\times 10 ^ 5$，$1 \\le M \\le 20$，$0 \\le A_{i, j} \\le 1$，保证所有输入均为整数。\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$8$|$N \\le 300$|\n|$2$|$8$|$N \\le 3000$|\n|$3$|$6$|$M \\le 2$|\n|$4$|$19$|$M \\le 10$|\n|$5$|$15$|$M \\le 14$|\n|$6$|$22$|$M \\le 17$|\n|$7$|$22$|无|", "locale": "zh-CN", "translations": {"en": {"title": "[JOIST 2023] Council", "background": null, "description": "In the council of JOI City, there are $N$ assembly members, numbered from $1$ to $N$. The council will open a meeting, and the assembly members will take votes on $M$ proposed ordinances, numbered from $1$ to $M$. If $A_{i, j} = 1$, the assembly member $i \\ (1 \\le i \\le N)$ will cast an affirmative vote on the proposed ordinance $j \\ (1 \\le j \\le M)$. If $A_{i, j} = 0$, the assembly member $i$ will cast a negative vote on the proposed ordinance $j$.\n\nThe council of JOI City will be performed as follows.\n\n1. Among the $N$ assembly members, they will randomly choose a chairperson by drawing lots.\n2. The chairperson will choose a deputy chairperson among the $N - 1$ assembly members except for the chairperson.\n3. The votes will be taken on $M$ proposed ordinances. Each of the $N - 2$ assembly members except for the chairperson and the deputy chairperson will cast an affirmative vote or a negative vote on each proposed ordinance. The council will approve a proposed ordinance if a majority of the assembly members (i.e., more than or equal to $\\lfloor \\frac{N}{2} \\rfloor$ assembly members) cast affirmative votes on it. Here, $\\lfloor x \\rfloor$ is the largest integer not exceeding $x$.\n\nMayor K, the mayor of JOI City, wants the council to approve as many proposed ordinances as possible. Mayor K collected information on assembly members. Mayor K knows, on each proposed ordinance, who will cast an affirmative vote and who will cast a negative vote.\n\nWrite a program which, given information of the votes of the assembly members, calculates, for each assembly member, the maximum possible number of proposed ordinances approved by the council if that assembly member is chosen as the chairperson.", "inputFormat": "Read the following data from the standard input.\n\n> $N \\ M$\n>\n> $A_{1, 1} \\ A_{1, 2} \\ \\cdots \\ A_{1, M}$\n>\n> $A_{2, 1} \\ A_{2, 2} \\ \\cdots \\ A_{2, M}$\n>\n> $\\vdots$\n>\n> $A_{N, 1} \\ A_{N, 2} \\ \\cdots \\ A_{N, M}$", "outputFormat": "Write $N$ lines to the standard output. The $i$-th line $(1 \\le i \\le N)$ of output should contain the maximum possible number of proposed ordinances approved by the council if the assembly member $i$ is chosen as the chairperson.", "hint": "**【样例解释 #1】**\n\n- Let’s consider the case where the assembly member $1$ is chosen as the chairperson. If the assembly member $2$ is chosen as the deputy chairperson, the council will approve three proposed ordinances, i.e., the proposed ordinances $1, 2, 3$. If the assembly member $3$ is chosen as the deputy chairperson, the council will approve two proposed ordinances, i.e., the proposed ordinances $1, 2$. Therefore, the maximum number of proposed ordinances approved by the council is $3$. Output $3$ in the first line.\n- Let’s consider the case where the assembly member $2$ is chosen as the chairperson. If the assembly member $1$ is chosen as the deputy chairperson, the council will approve three proposed ordinances, i.e., the proposed ordinances $1, 2, 3$. If the assembly member $3$ is chosen as the deputy chairperson, the\ncouncil will approve one proposed ordinance, i.e., the proposed ordinance $1$. Therefore, the maximum number of proposed ordinances approved by the council is $3$. Output $3$ in the second line.\n- Let’s consider the case where the assembly member $3$ is chosen as the chairperson. If the assembly member $1$ is chosen as the deputy chairperson, the council will approve two proposed ordinances, i.e., the proposed ordinances $1, 2$. If the assembly member $2$ is chosen as the deputy chairperson, the council will approve one proposed ordinance, i.e., the proposed ordinance $1$. Therefore, the maximum number of proposed ordinances approved by the council is $2$. Output $2$ in the third line.\n\n该样例满足子任务 $1, 2, 4, 5, 6, 7$ 的限制。\n\n**【样例解释 #2】**\n\n该样例满足子任务 $1, 2, 5, 6, 7$ 的限制。\n\n**【样例解释 #3】**\n\n该样例满足子任务 $1, 2, 4, 5, 6, 7$ 的限制。\n\n**【样例解释 #4】**\n\n该样例满足所有子任务的限制。\n\n**【数据范围】**\n\n对于所有测试数据，$3 \\le N \\le 3 \\times 10 ^ 5$，$1 \\le M \\le 20$，$0 \\le A_{i, j} \\le 1$，保证所有输入均为整数。\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$8$|$N \\le 300$|\n|$2$|$8$|$N \\le 3000$|\n|$3$|$6$|$M \\le 2$|\n|$4$|$19$|$M \\le 10$|\n|$5$|$15$|$M \\le 14$|\n|$6$|$22$|$M \\le 17$|\n|$7$|$22$|无|", "locale": "en"}, "zh-CN": {"title": "[JOIST 2023] 议会 / Council", "background": "本题子任务编号如果为 0 表示样例，如果是非 0 的一位数表示满足对应的子任务，如果是两位数表示同时满足这两个子任务。", "description": "#### 题目翻译\n\n在 JOI 市议会中，有 $N$ 名议员，编号从 $1$ 到 $N$。议会将召开会议，议员们将对 $M$ 项提案进行表决，编号为 $1$ 到 $M$。如果 $A_{i,j}=1$，则议员 $i (1≤i≤N)$ 将对提案 $j (1≤j≤M)$ 表决肯定票。如果 $A_{i,j}=0$，则议员 $i$ 将对提案 $j$ 表决否定票。\n\nJOI 市议会的程序如下所示。\n\n+ 在 $N$ 名议员中，通过抽签随机选择主席。\n\n+ 主席将在除了主席以外的其他 $N−1$ 名议员中选择副主席。\n\n+ 将对 $M$ 项提案进行表决。除了主席和副主席以外的其他 $N−2$ 名议员，每人对每个提案均投票支持或反对。如果大多数议员（即肯定票大于等于 $⌊\\dfrac{N}{2}⌋$）投票赞成，则议会将批准该提案。其中 $⌊x⌋$ 表示不超过 $x$ 的最大整数。\n\n市长 K 希望议会尽可能地批准更多的提案。市长 K 收集了议员的信息并知道每个议员在每个提案上的表决结果。\n\n请编写程序，在给定议员投票信息的情况下，计算每个议员作为主席时议会可以批准的提案数量的最大可能值。", "inputFormat": "从标准输入读取以下数据。\n\n> $N \\ M$\n>\n> $A_{1, 1} \\ A_{1, 2} \\ \\cdots \\ A_{1, M}$\n>\n> $A_{2, 1} \\ A_{2, 2} \\ \\cdots \\ A_{2, M}$\n>\n> $\\vdots$\n>\n> $A_{N, 1} \\ A_{N, 2} \\ \\cdots \\ A_{N, M}$", "outputFormat": "输出 $N$ 行。输出的第 $i$ 行（$1≤i≤N$）应包含议员 $i$ 作为主席时议会可以批准的提案数量的最大可能值。", "hint": "该样例满足子任务 $1, 2, 4, 5, 6, 7$ 的限制。\n\n**【样例解释 #2】**\n\n该样例满足子任务 $1, 2, 5, 6, 7$ 的限制。\n\n**【样例解释 #3】**\n\n该样例满足子任务 $1, 2, 4, 5, 6, 7$ 的限制。\n\n**【样例解释 #4】**\n\n该样例满足所有子任务的限制。\n\n**【数据范围】**\n\n对于所有测试数据，$3 \\le N \\le 3 \\times 10 ^ 5$，$1 \\le M \\le 20$，$0 \\le A_{i, j} \\le 1$，保证所有输入均为整数。\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$8$|$N \\le 300$|\n|$2$|$8$|$N \\le 3000$|\n|$3$|$6$|$M \\le 2$|\n|$4$|$19$|$M \\le 10$|\n|$5$|$15$|$M \\le 14$|\n|$6$|$22$|$M \\le 17$|\n|$7$|$22$|无|", "locale": "zh-CN"}}}
{"pid": "P9334", "type": "P", "difficulty": 7, "samples": [["6\n5 6 8 7 4 9\n1\n6 9 0 5\n", "3\n"], ["4\n6 2 3 6\n3\n3 2 1 3\n4 5 1 4\n1 1 0 4\n", "1\n2\n3\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "O2优化", "JOISC/JOIST（日本）"], "title": "[JOIST 2023] 水羊羹 2 / Mizuyokan 2", "background": null, "description": "水羊羹是一种用红豆沙制成的日式点心，将红豆沙与琼脂混合，并用矩形模具定型，这样就可以做成水羊羹了。\n\n现在 JOI 君有一台 **水羊羹机器**。使用它，JOI 君可以制作一个横向的矩形水羊羹，其上有 $N-1$ 条垂直切割线。水羊羹的长度和切割线位置由机器上设置的 $N$ 个参数 $d_1,d_2,\\ldots,d_N$ 确定。水羊羹的长度为 $d_1+d_2+\\ldots+d_N$。从左到右第 $(i-1)\\ (1\\le i\\le N)$ 条切割线与第 $i$ 条切割线之间的距离为 $d_i$。这里，我们考虑水羊羹的最左边为第 $0$ 条切割线，水羊羹的最右边为第 $N$ 条切割线。最初，水羊羹机器的参数满足 $d_i=L_i\\ (1\\le i\\le N)$。\n\nJOI 君计划组织 $Q$ 次茶会。第 $j\\ (1\\le j\\le Q)$ 次茶会由整数 $X_j,Y_j,A_j,B_j$ 表示。茶会按如下方式进行：\n\n- 水羊羹机器的参数 $d_{X_j}$ 被更新，并设置为 $Y_j$。\n- JOI 君用水羊羹机器只做了一个新的水羊羹。他把水羊羹在第 $A_j$ 条切割线和第 $B_j$ 条切割线之间的部分取出，用于茶会。他吃掉了剩余部分。\n- JOI 君沿一些切割线来切为茶会准备的水羊羹。他会将水羊羹切为一或更多块。在这个过程中应满足以下条件：如果这些切好的水羊羹块按最初的位置从左到右排列，那么这些水羊羹块的长度序列应该是 **锯齿形** 的。\n\n这里，如果序列中元素交替上升和下降，就称这个序列是锯齿形的。例如，序列 $(2,9,2,7),(7,1,9,4,6),(5),(2,1)$ 是锯齿形的，但序列 $(1,2,3),(7,1,4,4,6),(2,2)$ 不是锯齿形的。准确地说，一个序列 $(x_1,x_2,\\ldots,x_m)$ 被称为锯齿形的，当且仅当以下条件中至少一个被满足：\n\n- 对于 $k=1,2,\\ldots,m-1$，当 $k$ 为奇数时满足不等式 $x_k < x_{k+1}$，当 $k$ 为偶数时满足不等式 $x_k > x_{k+1}$。\n- 对于 $k=1,2,\\ldots,m-1$，当 $k$ 为奇数时满足不等式 $x_k > x_{k+1}$，当 $k$ 为偶数时满足不等式 $x_k < x_{k+1}$。\n\n因为 JOI 君想要把水羊羹给尽可能多的朋友们，他想最大化步骤 $3$ 中得到的水羊羹数。\n\n给定初始水羊羹机器的参数和茶会计划，写一个程序计算对于每次茶会，在满足条件的情况下最多能得到的最大水羊羹数。注意，在本题的限制下，满足条件的水羊羹切分方法必然存在。", "inputFormat": "从标准输入中读入以下数据：\n\n> $N$\n>\n> $L_1 \\ L_2 \\ \\cdots \\ L_N$\n>\n> $Q$\n>\n> $X_1 \\ Y_1 \\ A_1 \\ B_1$\n>\n> $X_2 \\ Y_2 \\ A_2 \\ B_2$\n>\n> $\\vdots$\n>\n> $X_Q \\ Y_Q \\ A_Q \\ B_Q$", "outputFormat": "程序应该在标准输出中输出 $Q$ 行。第 $j$ 行 $(1≤j≤Q)$ 应当包含第 $j$ 场茶会中的所选小片的最大数量。", "hint": "对于所有输入数据，满足：\n\n- $1\\le N \\le 2.5\\times 10^5$\n- $1\\le L_i \\le 10^9$\n- $1\\le Q\\le5\\times10^4$\n- $1\\le X_j\\le N,1\\le Y_j\\le 10^9$\n- $0\\le A_j < B_j \\le N$\n\n详细子任务附加限制及分值如下表所示。\n\n|子任务编号|附加限制|分值 |\n|:---:|:--------:|:-:|\n|$1$|$N\\le 200,Q\\le 10$| $6$|\n|$2$|$N\\le 2\\space000,Q\\le 10$| $9$|\n|$3$|$Q\\le10$|$13$|\n|$4$|$Y_j=L_{X_j}$|$32$|\n|$5$|$L_i,Y_j\\le 1.2\\times10^5$|$29$|\n|$6$|无附加限制|$11$|", "locale": "zh-CN", "translations": {"en": {"title": "[JOIST 2023] Mizuyokan 2", "background": null, "description": "Mizuyokan is a Japanese confectionery made of azuki beans paste. It was made by cooking azuki beans paste with agar, and solidifying them in a rectangular-shaped form.\n\nNow, JOI-kun has a mizuyokan machine. Using it, JOI-kun can make a horizontally long rectangular-shaped mizuyokan with $N - 1$ vertical cutlines. The length of the mizuyokan and the positions of the cutlines are determined by the $N$ parameters $d_1, d_2, \\dots, d_N$ set on the machine. The length of the mizuyokan is $d_1 + d_2 + \\dots + d_N$. The distance between the $(i - 1)$-th cutline $(1 \\le i \\le N)$ from the left and the $i$-th cutline from the left is $d_i$. Here, we consider the leftmost edge of the mizuyokan as the $0$-th cutline, and the rightmost edge of the mizuyokan as the $N$-th cutline. In the beginning, the parameters of the mizuyokan machine satisfy $d_i = L_i \\ (1 \\le i \\le N)$.\n\nJOI-kun has a plan to organize $Q$ tea parties. The $j$-th tea party $(1 \\le j \\le Q)$ is described by the integers $X_j, Y_j, A_j, B_j$. It proceeds as follows.\n\n1. The parameter $d_{X_j}$ of the mizuyokan machine is updated, and it is set as $Y_j$.\n2. JOI-kun makes a new mizuyokan using the mizuyokan machine. He takes the part of the mizuyokan 0between the $A_j$-th cutline and the $B_j$-th cutline, and uses it for the tea party. He eats the rest.\n3. JOI-kun cuts the part of the mizuyokan for the tea party along some of the cutlines. He cuts the part of the mizuyokan into one or more pieces. In this process, the following condition should be satisfied: if the pieces are ordered from the left as in the original positions, the sequence of the lengths of the pieces is **zigzag**.\n\nHere, a sequence is called zigzag if the elements of the sequence increase and decrease alternately. For example, the sequences $(2, 9, 2, 7), (7, 1, 9, 4, 6), (5), (2, 1)$ are zigzag, but the sequences $(1, 2, 3), (7, 1, 4, 4, 6), (2, 2)$ are not zigzag. Precisely, a sequence $(x_1, x_2, \\dots, x_m)$ is called zigzag if one (or the both) of the following conditions are satisfied:\n\n- For $k = 1, 2, \\dots, m - 1$, the inequality $x_k < x_{k + 1}$ is satisfied if $k$ is odd, and the inequality $x_k > x_{k + 1}$ is satisfied if $k$ is even.\n- For $k = 1, 2, \\dots, m - 1$, the inequality $x_k > x_{k + 1}$ is satisfied if $k$ is odd, and the inequality $x_k < x_{k + 1}$ is satisfied if $k$ is even.\n\nSince JOI-kun wants to give mizuyokan to as many friends as possible, he wants to maximize the number of pieces obtained by the procedure 3. of the tea party.\n\nWrite a program which, given information of the initial parameters of the mizuyokan machine and the plan of the tea parties, calculates, for each tea party, the maximum possible number of pieces obtained by cutting the part of the mizuyokan so that the condition is satisfied. Note that, under the constraints of this task, it is always possible to cut the part of the mizuyokan so that the condition is satisfied.", "inputFormat": "Read the following data from the standard input.\n\n> $N$\n>\n> $L_1 \\ L_2 \\ \\cdots \\ L_N$\n>\n> $Q$\n>\n> $X_1 \\ Y_1 \\ A_1 \\ B_1$\n>\n> $X_2 \\ Y_2 \\ A_2 \\ B_2$\n>\n> $\\vdots$\n>\n> $X_Q \\ Y_Q \\ A_Q \\ B_Q$", "outputFormat": "Write $Q$ lines to the standard output. The $j$-th line $(1 \\le j \\le Q)$ of output corresponds to the $j$-th tea party. It contains the maximum possible number of pieces obtained by cutting the part of the mizuyokan in the $j$-th tea party so that the condition is satisfied.", "hint": "**【样例解释 #1】**\n\nIn the first tea party, the parameters of the mizuyokan machine is set as $(d_1, d_2, d_3, d_4, d_5, d_6) = (5, 6, 8, 7, 4, 9)$.\n\nJOI-kun uses the part of the mizuyokan between the $0$-th cutline and the $5$-th cutline as in Figure 1.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/52j3fpkl.png)\n\nFor example, JOI-kun can cut the part of the mizuyokan as follows.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/phx1owbf.png)\n\nIn Method 1, the lengths of the pieces are $5, 14, 7, 4$. Since this sequence is not zigzag, it does not satisfy the condition. On the other hand, in Method 2, the lengths of the pieces are $11, 8, 11$. Since this sequence is zigzag, it satisfies the condition. In Method 3, the length of the piece is $30$. Since this sequence is zigzag, it also satisfies the condition.\n\nIf JOI-kun cuts the part of the mizuyokan by Method 2, he gets $3$ pieces. Since it is not possible for him to cut the part of the mizuyokan so that the condition is satisfied and he gets more than or equal to $4$ pieces, output $3$ in the first line.\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\nIn the first tea party, the length of the part of the mizuyokan for the tea party is $4$. There is a cutline whose distance is $2$ from the leftmost edge. If JOI-kun uses the mizuyokan without cutting it, he gets one piece. The sequence of the lengths of the pieces is $(4)$, which is zigzag. Since he cannot obtain more than one pieces, output $1$.\n\nIn the second tea party, the length of the part of the mizuyokan for the tea party is $9$. There are two cutlines whose distances are $2, 4$ from the leftmost edge. If JOI-kun cuts the mizuyokan at the cutline whose distance is $4$ from the leftmost edge, he gets two pieces. The sequence of the lengths of the pieces is $(4, 5)$, which is zigzag. Since he cannot obtain more than two pieces, output $2$.\n\nIn the third tea party, the length of the part of the mizuyokan for the tea party is $10$. There are three cutlines whose distances are $1, 3, 5$ from the leftmost edge. If JOI-kun cuts the mizuyokan at the cutlines whose distances are $3, 5$ from the leftmost edge, he gets three pieces. The sequence of the lengths of the pieces is $(3, 2, 5)$, which is zigzag. Since he cannot obtain more than three pieces, output $3$.\n\n该样例满足子任务 $1, 2, 3, 5, 6$ 的限制。\n\n**【数据范围】**\n\n对于所有测试数据，满足 $1 \\le N \\le 2.5 \\times 10 ^ 5$，$1 \\le L_i \\le 10 ^ 9$，$1 \\le Q \\le 5 \\times 10 ^ 4$，$1 \\le X_j \\le N$，$1 \\le Y_j \\le 10 ^ 9$，$0 \\le A_j < B_j \\le N$，保证所有输入均为整数。\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$6$|$N \\le 200$，$Q \\le 10$|\n|$2$|$9$|$N \\le 2000$，$Q \\le 10$|\n|$3$|$13$|$Q \\le 10$|\n|$4$|$32$|$Y_j = L_{X_j}$|\n|$5$|$29$|$L_i, Y_j \\le 1.2 \\times 10 ^ 5$|\n|$6$|$11$|无|", "locale": "en"}, "zh-CN": {"title": "[JOIST 2023] 水羊羹 2 / Mizuyokan 2", "background": null, "description": "水羊羹是一种用红豆沙制成的日式点心，将红豆沙与琼脂混合，并用矩形模具定型，这样就可以做成水羊羹了。\n\n现在 JOI 君有一台 **水羊羹机器**。使用它，JOI 君可以制作一个横向的矩形水羊羹，其上有 $N-1$ 条垂直切割线。水羊羹的长度和切割线位置由机器上设置的 $N$ 个参数 $d_1,d_2,\\ldots,d_N$ 确定。水羊羹的长度为 $d_1+d_2+\\ldots+d_N$。从左到右第 $(i-1)\\ (1\\le i\\le N)$ 条切割线与第 $i$ 条切割线之间的距离为 $d_i$。这里，我们考虑水羊羹的最左边为第 $0$ 条切割线，水羊羹的最右边为第 $N$ 条切割线。最初，水羊羹机器的参数满足 $d_i=L_i\\ (1\\le i\\le N)$。\n\nJOI 君计划组织 $Q$ 次茶会。第 $j\\ (1\\le j\\le Q)$ 次茶会由整数 $X_j,Y_j,A_j,B_j$ 表示。茶会按如下方式进行：\n\n- 水羊羹机器的参数 $d_{X_j}$ 被更新，并设置为 $Y_j$。\n- JOI 君用水羊羹机器只做了一个新的水羊羹。他把水羊羹在第 $A_j$ 条切割线和第 $B_j$ 条切割线之间的部分取出，用于茶会。他吃掉了剩余部分。\n- JOI 君沿一些切割线来切为茶会准备的水羊羹。他会将水羊羹切为一或更多块。在这个过程中应满足以下条件：如果这些切好的水羊羹块按最初的位置从左到右排列，那么这些水羊羹块的长度序列应该是 **锯齿形** 的。\n\n这里，如果序列中元素交替上升和下降，就称这个序列是锯齿形的。例如，序列 $(2,9,2,7),(7,1,9,4,6),(5),(2,1)$ 是锯齿形的，但序列 $(1,2,3),(7,1,4,4,6),(2,2)$ 不是锯齿形的。准确地说，一个序列 $(x_1,x_2,\\ldots,x_m)$ 被称为锯齿形的，当且仅当以下条件中至少一个被满足：\n\n- 对于 $k=1,2,\\ldots,m-1$，当 $k$ 为奇数时满足不等式 $x_k < x_{k+1}$，当 $k$ 为偶数时满足不等式 $x_k > x_{k+1}$。\n- 对于 $k=1,2,\\ldots,m-1$，当 $k$ 为奇数时满足不等式 $x_k > x_{k+1}$，当 $k$ 为偶数时满足不等式 $x_k < x_{k+1}$。\n\n因为 JOI 君想要把水羊羹给尽可能多的朋友们，他想最大化步骤 $3$ 中得到的水羊羹数。\n\n给定初始水羊羹机器的参数和茶会计划，写一个程序计算对于每次茶会，在满足条件的情况下最多能得到的最大水羊羹数。注意，在本题的限制下，满足条件的水羊羹切分方法必然存在。", "inputFormat": "从标准输入中读入以下数据：\n\n> $N$\n>\n> $L_1 \\ L_2 \\ \\cdots \\ L_N$\n>\n> $Q$\n>\n> $X_1 \\ Y_1 \\ A_1 \\ B_1$\n>\n> $X_2 \\ Y_2 \\ A_2 \\ B_2$\n>\n> $\\vdots$\n>\n> $X_Q \\ Y_Q \\ A_Q \\ B_Q$", "outputFormat": "程序应该在标准输出中输出 $Q$ 行。第 $j$ 行 $(1≤j≤Q)$ 应当包含第 $j$ 场茶会中的所选小片的最大数量。", "hint": "对于所有输入数据，满足：\n\n- $1\\le N \\le 2.5\\times 10^5$\n- $1\\le L_i \\le 10^9$\n- $1\\le Q\\le5\\times10^4$\n- $1\\le X_j\\le N,1\\le Y_j\\le 10^9$\n- $0\\le A_j < B_j \\le N$\n\n详细子任务附加限制及分值如下表所示。\n\n|子任务编号|附加限制|分值 |\n|:---:|:--------:|:-:|\n|$1$|$N\\le 200,Q\\le 10$| $6$|\n|$2$|$N\\le 2\\space000,Q\\le 10$| $9$|\n|$3$|$Q\\le10$|$13$|\n|$4$|$Y_j=L_{X_j}$|$32$|\n|$5$|$L_i,Y_j\\le 1.2\\times10^5$|$29$|\n|$6$|无附加限制|$11$|", "locale": "zh-CN"}}}
{"pid": "P9335", "type": "P", "difficulty": 7, "samples": [["5 3\n3 3 1 1 1\n2 1 3 2 2\n4 5 3 4 4\n1 2\n2 5\n4 5\n", "48\n63\n24\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2001", "O2优化", "Ynoi"], "title": "[Ynoi2001] 雪に咲く花", "background": "&emsp;何もいらない   \n&emsp;不再奢求什么   \n&emsp;あなたがいればいい   \n&emsp;只要有相伴   \n&emsp;そっと橫顏 息を殺す   \n&emsp;悄悄地侧着脸 屏住呼吸   \n&emsp;まばたきすれば   \n&emsp;似乎一眨眼   \n&emsp;消えてしまいそうで   \n&emsp;就会突然消失一般   \n&emsp;凝視(みつ)めさせて 好きだよ   \n&emsp;凝视着我喜欢的你   \n\n&emsp;あぁ 木々が震え 降り出した雪   \n&emsp;啊啊 树影摇曳 落雪纷纷   \n&emsp;足跡 ふたつ 白く   \n&emsp;唯留两行白色的足迹   \n&emsp;時よ 積もれ   \n&emsp;时光 点点堆积   \n&emsp;時よ 積もれ   \n&emsp;时光 点点堆积   \n&emsp;髪に 胸に ふたりだけの夢に   \n&emsp;在发间 在心中 只属于你我的梦中   \n&emsp;咲けない花の種は   \n&emsp;无法开出花朵的种子   \n&emsp;雪に抱かれ 寄り添うの   \n&emsp;在雪的怀抱中 相依相偎   \n&emsp;靜かに忘れられたい   \n&emsp;只想静静地被遗忘   \n![](https://cdn.luogu.com.cn/upload/image_hosting/g60pi7fc.png)", "description": "给序列 $a_1,\\dots,a_n$，$b_1,\\dots,b_n$，$c_1,\\dots,c_n$，\n\n定义区间 $[l,r]$ 的价值为 $a_l,\\dots,a_r$ 按位与，$b_l,\\dots,b_r$ 按位或，$c_l,\\dots,c_r$ 的最大公因数，这三者的乘积；\n\n$m$ 次查询，每次查询给出区间 $[l,r]$，查询满足 $l\\le l'\\le r'\\le r$ 的 $[l',r']$ 的价值之和。", "inputFormat": "第一行两个整数 $n,m$；\n\n第二行 $n$ 个整数 $a_1,\\dots,a_n$；\n\n第三行 $n$ 个整数 $b_1,\\dots,b_n$；\n\n第四行 $n$ 个整数 $c_1,\\dots,c_n$；\n\n接下来 $m$ 行，每行两个整数 $l,r$ 表示一次查询。\n", "outputFormat": "共 $m$ 行，每行一个整数，表示对应的答案，答案对 $2^{32}$ 取模后输出。\n", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n对于 $100\\%$ 的数据，满足\n\n$1\\le n\\le 10^6$\n\n$1\\le m\\le 5\\times 10^6$\n\n$1\\le a_i,b_i,c_i\\le n$\n\n$1\\le l\\le r\\le n$\n\n建议使用高效的输入输出方式。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2001] 雪に咲く花", "background": "&emsp;何もいらない   \n&emsp;不再奢求什么   \n&emsp;あなたがいればいい   \n&emsp;只要有相伴   \n&emsp;そっと橫顏 息を殺す   \n&emsp;悄悄地侧着脸 屏住呼吸   \n&emsp;まばたきすれば   \n&emsp;似乎一眨眼   \n&emsp;消えてしまいそうで   \n&emsp;就会突然消失一般   \n&emsp;凝視(みつ)めさせて 好きだよ   \n&emsp;凝视着我喜欢的你   \n\n&emsp;あぁ 木々が震え 降り出した雪   \n&emsp;啊啊 树影摇曳 落雪纷纷   \n&emsp;足跡 ふたつ 白く   \n&emsp;唯留两行白色的足迹   \n&emsp;時よ 積もれ   \n&emsp;时光 点点堆积   \n&emsp;時よ 積もれ   \n&emsp;时光 点点堆积   \n&emsp;髪に 胸に ふたりだけの夢に   \n&emsp;在发间 在心中 只属于你我的梦中   \n&emsp;咲けない花の種は   \n&emsp;无法开出花朵的种子   \n&emsp;雪に抱かれ 寄り添うの   \n&emsp;在雪的怀抱中 相依相偎   \n&emsp;靜かに忘れられたい   \n&emsp;只想静静地被遗忘   \n![](https://cdn.luogu.com.cn/upload/image_hosting/g60pi7fc.png)", "description": "给序列 $a_1,\\dots,a_n$，$b_1,\\dots,b_n$，$c_1,\\dots,c_n$，\n\n定义区间 $[l,r]$ 的价值为 $a_l,\\dots,a_r$ 按位与，$b_l,\\dots,b_r$ 按位或，$c_l,\\dots,c_r$ 的最大公因数，这三者的乘积；\n\n$m$ 次查询，每次查询给出区间 $[l,r]$，查询满足 $l\\le l'\\le r'\\le r$ 的 $[l',r']$ 的价值之和。", "inputFormat": "第一行两个整数 $n,m$；\n\n第二行 $n$ 个整数 $a_1,\\dots,a_n$；\n\n第三行 $n$ 个整数 $b_1,\\dots,b_n$；\n\n第四行 $n$ 个整数 $c_1,\\dots,c_n$；\n\n接下来 $m$ 行，每行两个整数 $l,r$ 表示一次查询。\n", "outputFormat": "共 $m$ 行，每行一个整数，表示对应的答案，答案对 $2^{32}$ 取模后输出。\n", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n对于 $100\\%$ 的数据，满足\n\n$1\\le n\\le 10^6$\n\n$1\\le m\\le 5\\times 10^6$\n\n$1\\le a_i,b_i,c_i\\le n$\n\n$1\\le l\\le r\\le n$\n\n建议使用高效的输入输出方式。\n", "locale": "zh-CN"}}}
{"pid": "P9336", "type": "P", "difficulty": 7, "samples": [["5 10\n2 10 1 10 3\n1 2 3 2\n2 1 3\n1 3\n1 5\n2 3 5\n2 3 2\n1 5\n2 5 6\n1 3\n2 5 -1\n2 3 0", "10\n3\n3\n10"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2001", "O2优化", "Ynoi"], "title": "[Ynoi2001] 梦想歌", "background": "&emsp;子供の頃の夢は   \n&emsp;孩童时期的梦想   \n&emsp;色褪せない落書きで   \n&emsp;是永不褪色的涂鸦  \n&emsp;いつまでも描き続けられた   \n&emsp;无论何时都不停描绘着   \n&emsp;願う未来へとつながる   \n&emsp;与理想中的未来紧紧相连   \n&emsp;鐘が鳴る音  \n&emsp;钟声鸣响   \n&emsp;遠くから聞こえてくる  \n&emsp;即使在远方也听得见  \n&emsp;素直な心に    \n&emsp;传达到坦率的内心之中  \n&emsp;届いては響いてる  \n&emsp;随之回响  \n&emsp;光りは  \n&emsp;化作七彩的  \n&emsp;七色に変わって  \n&emsp;光芒\n![](https://tuchuangs.com/imgs/2023/03/19/e23d3bd048e193de.jpg)", "description": "给定树上 $n$ 个点，每个点有一个点权 $v_i$。\n\n在此题面中，启发式合并指，递归地进行从底往上的集合合并，每一次以集合的点权和为键值，将权值和更小的集合中的点加入更大的权值和的集合中，初始时每个点集合为该点本身。\n\n同时我们钦定如下的枚举顺序：假设已经递归进行了所有子树的合并，合并当前层节点时从子树的根开始，将儿子们按编号大小从小到大排序，每一次合并两两集合得到子树的集合。\n\n同时，若两个集合的权值和相同，以集合中最小节点深度为第二关键字进行比较（深度大的向深度小的合并）。\n\n钦定该树的根为 $1$。给出以下查询和修改操作：\n\n```1 x``` 表示查询当前以 $x$ 为根的子树进行启发式合并后，没有进行「合并入另外一个集合」操作的节点权值。\n\n```2 x d```将第 $x$ 个点的节点权值加 $d$。\n\n", "inputFormat": "第一行两个整数 $n,q$，分别表示树的大小和操作次数。\n\n第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$，其中 $a_i$ 表示结点 $i$ 的初始权值。\n\n第三行 $n-1$ 个整数 $p_2,p_3,\\cdots,p_n$，其中 $p_i$ 表示以结点 $1$ 为根时，结点 $i$ 的父亲。\n\n接下来 $q$ 行，每行格式形如 `1 x` 或 `2 x d`，分别对应题目描述中的两种操作。", "outputFormat": "对于每个类型为 $1$ 的操作，输出一行一个整数，表示所求答案。", "hint": "Idea：FutaRimeWoawaSete，Solution：zhoukangyang，Code：Rainybunny，Data：FutaRimeWoawaSete/Rainybunny\n\n对于 $100\\%$ 的数据，$1\\le n,q\\le2\\times10^5$，$1\\le p_i<i$；操作给出的 $x\\in[1,n]$，$d\\in[-10^{18},10^{18}]$；在任意时刻 $a_x\\ge 1$ 且 $\\sum_{x=1}^na_x\\le10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2001] 梦想歌", "background": "&emsp;子供の頃の夢は   \n&emsp;孩童时期的梦想   \n&emsp;色褪せない落書きで   \n&emsp;是永不褪色的涂鸦  \n&emsp;いつまでも描き続けられた   \n&emsp;无论何时都不停描绘着   \n&emsp;願う未来へとつながる   \n&emsp;与理想中的未来紧紧相连   \n&emsp;鐘が鳴る音  \n&emsp;钟声鸣响   \n&emsp;遠くから聞こえてくる  \n&emsp;即使在远方也听得见  \n&emsp;素直な心に    \n&emsp;传达到坦率的内心之中  \n&emsp;届いては響いてる  \n&emsp;随之回响  \n&emsp;光りは  \n&emsp;化作七彩的  \n&emsp;七色に変わって  \n&emsp;光芒\n![](https://tuchuangs.com/imgs/2023/03/19/e23d3bd048e193de.jpg)", "description": "给定树上 $n$ 个点，每个点有一个点权 $v_i$。\n\n在此题面中，启发式合并指，递归地进行从底往上的集合合并，每一次以集合的点权和为键值，将权值和更小的集合中的点加入更大的权值和的集合中，初始时每个点集合为该点本身。\n\n同时我们钦定如下的枚举顺序：假设已经递归进行了所有子树的合并，合并当前层节点时从子树的根开始，将儿子们按编号大小从小到大排序，每一次合并两两集合得到子树的集合。\n\n同时，若两个集合的权值和相同，以集合中最小节点深度为第二关键字进行比较（深度大的向深度小的合并）。\n\n钦定该树的根为 $1$。给出以下查询和修改操作：\n\n```1 x``` 表示查询当前以 $x$ 为根的子树进行启发式合并后，没有进行「合并入另外一个集合」操作的节点权值。\n\n```2 x d```将第 $x$ 个点的节点权值加 $d$。\n\n", "inputFormat": "第一行两个整数 $n,q$，分别表示树的大小和操作次数。\n\n第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$，其中 $a_i$ 表示结点 $i$ 的初始权值。\n\n第三行 $n-1$ 个整数 $p_2,p_3,\\cdots,p_n$，其中 $p_i$ 表示以结点 $1$ 为根时，结点 $i$ 的父亲。\n\n接下来 $q$ 行，每行格式形如 `1 x` 或 `2 x d`，分别对应题目描述中的两种操作。", "outputFormat": "对于每个类型为 $1$ 的操作，输出一行一个整数，表示所求答案。", "hint": "Idea：FutaRimeWoawaSete，Solution：zhoukangyang，Code：Rainybunny，Data：FutaRimeWoawaSete/Rainybunny\n\n对于 $100\\%$ 的数据，$1\\le n,q\\le2\\times10^5$，$1\\le p_i<i$；操作给出的 $x\\in[1,n]$，$d\\in[-10^{18},10^{18}]$；在任意时刻 $a_x\\ge 1$ 且 $\\sum_{x=1}^na_x\\le10^{18}$。", "locale": "zh-CN"}}}
