{"pid": "P5489", "type": "P", "difficulty": 6, "samples": [["5 10\n1 1 2\n1 2 3\n2 1 3\n3 0 1\n1 3 1\n1 1 6\n2 3 7\n1 6 7\n1 7 1\n3 3 6", "2\n2\n-1\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["洛谷原创", "树链剖分", "动态树 LCT"], "title": "EntropyIncreaser 与 动态图", "background": "话说 NaCly_Fish 在和  $\\mathsf E \\color{red}\\mathsf{ntropyIncreaser}$ 吃饭时，问过她一个问题：“一个无向图，支持动态加边，求两点间割点数，怎么做？” \n\n$\\mathsf E \\color{red} \\mathsf{ntropyIncreaser}$ 想了几秒，说：“这不是sb题吗，随便怎么做都行吧。”然后三两句道出了一个算法。\n\n而 NaCly_Fish 还是不会，请你来教教她这题怎么做吧。", "description": "有一个 $n$ 个点的图，初始没有边。  \n有 $q$ 个操作，分为 $3$ 种，具体如下：  \n\n- `1 u v` 表示在 $u,v$ 之间连一条无向边  \n- `2 u v` 表示求 $u,v$ 间的割边数量   \n- `3 u v` 表示求 $u,v$ 间的割点数量   \n\n特别地，对于 $2$、$3$ 操作，若 $u,v$ 不连通，则输出 $-1$    \n****\n为了防止有歧义，这里给出对两点间割边和割点数量的定义：  \n对于所有包含 $u,v$ 的路径的节点集合之交 $S$ ，定义 $S$ 中的元素数量为 $u,v$ 间的割点数。  \n对于所有包含 $u,v$ 的路径的边集合之交 $T$ ，定义 $T$ 中的元素数量为 $u,v$ 间的割边数。  \n****\n**本题强制在线。**  \n从第二行开始，每次的输入的 $u,v$ 都需要异或上 $\\text{last}$ ，才是实际操作的 $u,v$。  \n $\\text{last}$ 为最近一次**答案非 $-1$ 的**询问的答案，定义初始 $\\text{last}=0$   \nps：如果您不知道异或是什么意思，可以看这里：[xor](https://www.baidu.com/link?url=bhG_De1gZYsqrIq7dkhgGj8vP87xSSyoIwk0-5p1fyKmf58cznvq0oYJg0XGoyKNpuGk7EsvjUnyvgJ19_ZA3PhoMJ3hIufHZ5GXh1OaIoS&wd=&eqid=ab26bc160004324d000000035d1ed64e)", "inputFormat": "第一行两个正整数 $n,q$，表示节点数和操作次数。   \n接下来 $q$ 行，每行三个整数，表示一次操作。   \n", "outputFormat": "对于每个$2$、$3$ 操作，输出一行一个整数表示答案。 ", "hint": "~~题目背景为真实事件~~\n\n### 样例说明：  \n实际操作为：  \n```cpp\n5 10\n1 1 2\n1 2 3\n2 1 3\n3 2 3\n1 1 3\n1 3 4\n2 1 5\n1 4 5\n1 5 3\n3 1 4\n```\n\n【数据范围】\n  \n对于 $20\\%$ 的数据，$1\\le n,q \\le 2000$ ；   \n对于另外 $30\\%$ 的数据，所有 $2$、$3$ 操作均在 $1$ 操作之后；    \n对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$1\\le q \\le 3\\times 10^5$。\n    \n对于 $1$ 操作，保证 $u\\neq  v$。  \n\nBy：NaCly_Fish\n\n****\n\n欢迎加入 EI队长粉丝裙，群号：$747262201$   ", "locale": "zh-CN", "translations": {"en": {"title": "EntropyIncreaser and Dynamic Graph", "background": "It is said that when NaCly_Fish was having a meal with $\\mathsf E \\color{red}\\mathsf{ntropyIncreaser}$, he asked her a question: “Given an undirected graph that supports dynamic edge insertions, how do we find the number of articulation points between two vertices?”  \n\n$\\mathsf E \\color{red} \\mathsf{ntropyIncreaser}$ thought for a few seconds and said: “Isn’t this a super easy problem? You can do it however you want.” Then she explained an algorithm in just a few sentences.\n\nBut NaCly_Fish still did not understand it. Please teach her how to solve this problem.", "description": "There is a graph with $n$ vertices, initially with no edges.  \nThere are $q$ operations, of $3$ types, as follows:\n\n- `1 u v` means adding an undirected edge between $u$ and $v$.\n- `2 u v` means querying the number of bridges between $u$ and $v$.\n- `3 u v` means querying the number of articulation points between $u$ and $v$.\n\nIn particular, for operations $2$ and $3$, if $u$ and $v$ are not connected, output $-1$.\n\n****\n\nTo avoid ambiguity, here are the definitions of the number of bridges and articulation points between two vertices:\n\nLet $S$ be the intersection of the vertex sets of all paths that contain both $u$ and $v$. Define the number of elements in $S$ as the number of articulation points between $u$ and $v$.  \nLet $T$ be the intersection of the edge sets of all paths that contain both $u$ and $v$. Define the number of elements in $T$ as the number of bridges between $u$ and $v$.\n\n****\n\n**This problem is strictly online.**  \nStarting from the second line, in each input, $u,v$ must be XORed with $\\text{last}$ to get the actual $u,v$.  \n$\\text{last}$ is the answer of the most recent query whose answer is **not $-1$**, and initially $\\text{last}=0$.  \nps: If you do not know what XOR means, see here: [xor](https://www.baidu.com/link?url=bhG_De1gZYsqrIq7dkhgGj8vP87xSSyoIwk0-5p1fyKmf58cznvq0oYJg0XGoyKNpuGk7EsvjUnyvgJ19_ZA3PhoMJ3hIufHZ5GXh1OaIoS&wd=&eqid=ab26bc160004324d000000035d1ed64e).", "inputFormat": "The first line contains two positive integers $n,q$, representing the number of vertices and the number of operations.  \nThe next $q$ lines each contain three integers, describing one operation.", "outputFormat": "For each operation of type $2$ or $3$, output one line with one integer representing the answer.", "hint": "~~The background story is a real event.~~\n\n### Sample Explanation\n\nThe actual operations are:\n```cpp\n5 10\n1 1 2\n1 2 3\n2 1 3\n3 2 3\n1 1 3\n1 3 4\n2 1 5\n1 4 5\n1 5 3\n3 1 4\n```\n\n### Constraints\n\nFor $20\\%$ of the testdata, $1\\le n,q \\le 2000$.  \nFor another $30\\%$ of the testdata, all operations of type $2$ and $3$ occur after a type $1$ operation.  \nFor $100\\%$ of the testdata, $1\\le n \\le 10^5$, $1\\le q \\le 3\\times 10^5$.\n\nFor type $1$ operations, it is guaranteed that $u\\neq v$.\n\nBy: NaCly_Fish\n\n****\n\nWelcome to join the EI Captain fan group. Group number: $747262201$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "EntropyIncreaser 与 动态图", "background": "话说 NaCly_Fish 在和  $\\mathsf E \\color{red}\\mathsf{ntropyIncreaser}$ 吃饭时，问过她一个问题：“一个无向图，支持动态加边，求两点间割点数，怎么做？” \n\n$\\mathsf E \\color{red} \\mathsf{ntropyIncreaser}$ 想了几秒，说：“这不是sb题吗，随便怎么做都行吧。”然后三两句道出了一个算法。\n\n而 NaCly_Fish 还是不会，请你来教教她这题怎么做吧。", "description": "有一个 $n$ 个点的图，初始没有边。  \n有 $q$ 个操作，分为 $3$ 种，具体如下：  \n\n- `1 u v` 表示在 $u,v$ 之间连一条无向边  \n- `2 u v` 表示求 $u,v$ 间的割边数量   \n- `3 u v` 表示求 $u,v$ 间的割点数量   \n\n特别地，对于 $2$、$3$ 操作，若 $u,v$ 不连通，则输出 $-1$    \n****\n为了防止有歧义，这里给出对两点间割边和割点数量的定义：  \n对于所有包含 $u,v$ 的路径的节点集合之交 $S$ ，定义 $S$ 中的元素数量为 $u,v$ 间的割点数。  \n对于所有包含 $u,v$ 的路径的边集合之交 $T$ ，定义 $T$ 中的元素数量为 $u,v$ 间的割边数。  \n****\n**本题强制在线。**  \n从第二行开始，每次的输入的 $u,v$ 都需要异或上 $\\text{last}$ ，才是实际操作的 $u,v$。  \n $\\text{last}$ 为最近一次**答案非 $-1$ 的**询问的答案，定义初始 $\\text{last}=0$   \nps：如果您不知道异或是什么意思，可以看这里：[xor](https://www.baidu.com/link?url=bhG_De1gZYsqrIq7dkhgGj8vP87xSSyoIwk0-5p1fyKmf58cznvq0oYJg0XGoyKNpuGk7EsvjUnyvgJ19_ZA3PhoMJ3hIufHZ5GXh1OaIoS&wd=&eqid=ab26bc160004324d000000035d1ed64e)", "inputFormat": "第一行两个正整数 $n,q$，表示节点数和操作次数。   \n接下来 $q$ 行，每行三个整数，表示一次操作。   \n", "outputFormat": "对于每个$2$、$3$ 操作，输出一行一个整数表示答案。 ", "hint": "~~题目背景为真实事件~~\n\n### 样例说明：  \n实际操作为：  \n```cpp\n5 10\n1 1 2\n1 2 3\n2 1 3\n3 2 3\n1 1 3\n1 3 4\n2 1 5\n1 4 5\n1 5 3\n3 1 4\n```\n\n【数据范围】\n  \n对于 $20\\%$ 的数据，$1\\le n,q \\le 2000$ ；   \n对于另外 $30\\%$ 的数据，所有 $2$、$3$ 操作均在 $1$ 操作之后；    \n对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$1\\le q \\le 3\\times 10^5$。\n    \n对于 $1$ 操作，保证 $u\\neq  v$。  \n\nBy：NaCly_Fish\n\n****\n\n欢迎加入 EI队长粉丝裙，群号：$747262201$   ", "locale": "zh-CN"}}}
{"pid": "P5490", "type": "P", "difficulty": 5, "samples": [["2\n100 100 200 200\n150 150 250 255\n", "18000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "离散化", "O2优化", "扫描线", "模板题"], "title": "【模板】扫描线 & 矩形面积并", "background": "", "description": "求 $n$ 个四边平行于坐标轴的矩形的面积并。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来 $n$ 行每行四个非负整数 $x_1, y_1, x_2, y_2$，表示一个矩形的四个端点坐标为 $(x_1, y_1),(x_1, y_2),(x_2, y_2),(x_2, y_1)$。", "outputFormat": "一行一个正整数，表示 $n$ 个矩形的并集覆盖的总面积。", "hint": "对于 $20\\%$ 的数据，$1 \\le n \\le 1000$。  \n对于 $100\\%$ 的数据，$1 \\le n \\le {10}^5$，$0 \\le x_1 < x_2 \\le {10}^9$，$0 \\le y_1 < y_2 \\le {10}^9$。\n\nUpdated on 4.10 by Dengduck（口胡） \\& yummy（实现）：增加了一组数据。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Scanline & Union Area of Rectangles", "background": "", "description": "Find the union area of $n$ rectangles whose sides are parallel to the coordinate axes.", "inputFormat": "The first line contains a positive integer $n$.\n\nThe next $n$ lines each contain four non-negative integers $x_1, y_1, x_2, y_2$, indicating that the four vertices of a rectangle are $(x_1, y_1)$, $(x_1, y_2)$, $(x_2, y_2)$, $(x_2, y_1)$.", "outputFormat": "Output one positive integer in a single line, representing the total area covered by the union of the $n$ rectangles.", "hint": "For $20\\%$ of the testdata, $1 \\le n \\le 1000$.  \nFor $100\\%$ of the testdata, $1 \\le n \\le {10}^5$, $0 \\le x_1 < x_2 \\le {10}^9$, $0 \\le y_1 < y_2 \\le {10}^9$.\n\nUpdated on 4.10 by Dengduck (kouhu) \\& yummy (implementation): one more test case was added.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】扫描线 & 矩形面积并", "background": "", "description": "求 $n$ 个四边平行于坐标轴的矩形的面积并。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来 $n$ 行每行四个非负整数 $x_1, y_1, x_2, y_2$，表示一个矩形的四个端点坐标为 $(x_1, y_1),(x_1, y_2),(x_2, y_2),(x_2, y_1)$。", "outputFormat": "一行一个正整数，表示 $n$ 个矩形的并集覆盖的总面积。", "hint": "对于 $20\\%$ 的数据，$1 \\le n \\le 1000$。  \n对于 $100\\%$ 的数据，$1 \\le n \\le {10}^5$，$0 \\le x_1 < x_2 \\le {10}^9$，$0 \\le y_1 < y_2 \\le {10}^9$。\n\nUpdated on 4.10 by Dengduck（口胡） \\& yummy（实现）：增加了一组数据。", "locale": "zh-CN"}}}
{"pid": "P5491", "type": "P", "difficulty": 6, "samples": [["3\n5 1000000009\n4 1000000009\n0 19260817", "383008016 616991993\n2 1000000007\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["二次剩余", "模板题"], "title": "【模板】二次剩余", "background": null, "description": "给出 $N,p$，求解方程 \n\n$$\nx^2 \\equiv N \\pmod{p}\n$$\n\n多组数据，**且保证 $p$ 是奇素数。**", "inputFormat": "第 $1$ 行，一个整数 $T$ 表示数据组数。\n\n第 $2\\sim T+1$ 行，每行两个整数 $N$ 和 $p$，含义详见题目描述。", "outputFormat": "输出共 $T$ 行。\n\n对于每一行输出，若有解，则按 $\\bmod ~p$ 后递增的顺序输出在 $\\bmod~ p$ 意义下的全部解；若两解相同，只输出其中一个；若无解，则输出 `Hola!` 。", "hint": "对于 $100\\%$ 的数据，$1\\leq T\\leq 10^4$，$0\\le N, p\\leq 10^9+9$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Quadratic Residue", "background": "", "description": "Given $N, p$, solve the equation\n\n$$\nx^2 \\equiv N \\pmod{p}\n$$\n\nThere are multiple test cases, **and it is guaranteed that $p$ is an odd prime.**", "inputFormat": "Line $1$ contains an integer $T$, which indicates the number of test cases.\n\nLines $2$ to $T + 1$ each contain two integers $N$ and $p$. Their meanings are described in the statement.", "outputFormat": "Output a total of $T$ lines.\n\nFor each line of output, if there is a solution, output all solutions modulo $p$ in increasing order after taking $\\bmod~ p$. If the two solutions are the same, output only one of them. If there is no solution, output `Hola!`.", "hint": "For $100\\%$ of the testdata, $1 \\le T \\le 10^4$, $0 \\le N, p \\le 10^9 + 9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】二次剩余", "background": null, "description": "给出 $N,p$，求解方程 \n\n$$\nx^2 \\equiv N \\pmod{p}\n$$\n\n多组数据，**且保证 $p$ 是奇素数。**", "inputFormat": "第 $1$ 行，一个整数 $T$ 表示数据组数。\n\n第 $2\\sim T+1$ 行，每行两个整数 $N$ 和 $p$，含义详见题目描述。", "outputFormat": "输出共 $T$ 行。\n\n对于每一行输出，若有解，则按 $\\bmod ~p$ 后递增的顺序输出在 $\\bmod~ p$ 意义下的全部解；若两解相同，只输出其中一个；若无解，则输出 `Hola!` 。", "hint": "对于 $100\\%$ 的数据，$1\\leq T\\leq 10^4$，$0\\le N, p\\leq 10^9+9$。", "locale": "zh-CN"}}}
{"pid": "P5492", "type": "P", "difficulty": 6, "samples": [["3 2\n1 2\n2 3", "665496236"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2018", "记忆化搜索", "概率论", "状压 DP"], "title": "[PKUWC2018] 随机算法", "background": "", "description": "我们知道，求任意图的最大独立集是一类NP完全问题，目前还没有准确的多项式算法，但是有许多多项式复杂度的近似算法。\n\n例如，小 C 常用的一种算法是：\n\n1. 对于一个 $n$ 个点的无向图，先等概率随机一个 $1\\ldots n$ 的排列 $p[1\\ldots n]$。\n\n2. 维护答案集合 $S$ ，一开始 $S$ 为空集，之后按照 $i=1\\ldots n$ 的顺序，检查 $\\{p[i]\\}\\cup S$ 是否是一个独立集，如果是的话就令 $S=\\{p[i]\\}\\cup S$。\n\n3. 最后得到一个独立集 $S$ 作为答案。\n\n小 C 现在想知道，对于给定的一张图，这个算法的正确率，输出答案对 $998244353$ 取模。", "inputFormat": "第一行两个非负整数 $n,m$ 表示给定的图的点数和边数。\n\n接下来 $m$ 行，每行有两个正整数 $(u,v) (u\\neq v)$ 描述这张图的一条无向边。", "outputFormat": "输出正确率，答案对 $998244353$ 取模。", "hint": "#### 样例解释\n这张图的最大独立集显然为 $2$，可以发现只有 $p[1]=2$ 时会得出 $S=\\{2\\}$，否则都是 $S=\\{1,3\\}$，所以答案是 $\\frac{2}{3}$。\n\n\n#### 数据范围\n对于 $10\\%$ 的数据，有$1\\leq n\\leq 9$。\n\n对于 $30\\%$ 的数据，有$1\\leq n\\leq 13$。\n\n对于 $50\\%$ 的数据，有$1\\leq n\\leq 17$。\n\n另有 $10\\%$ 的数据，满足给定的图是一条链。\n\n另有 $10\\%$ 的数据，满足给定的图是一棵树。\n\n对于 $100\\%$ 的数据，有$1\\leq n\\leq 20$，$0\\leq m\\leq \\frac{n\\times (n-1)}{2}$，保证给定的图没有重边和自环。", "locale": "zh-CN", "translations": {"en": {"title": "[PKUWC2018] Randomized Algorithm", "background": "", "description": "We know that finding the maximum independent set of an arbitrary graph is an NP-complete problem. Currently, there is no exact polynomial-time algorithm, but there are many polynomial-time approximation algorithms.\n\nFor example, one algorithm often used by Little C is:\n\n1. For an undirected graph with $n$ vertices, first uniformly randomly generate a permutation $p[1\\ldots n]$ of $1\\ldots n$.\n\n2. Maintain an answer set $S$. Initially, $S$ is empty. Then, in the order $i=1\\ldots n$, check whether $\\{p[i]\\}\\cup S$ is an independent set. If it is, set $S=\\{p[i]\\}\\cup S$.\n\n3. Finally, obtain an independent set $S$ as the answer.\n\nNow Little C wants to know, for a given graph, the probability that this algorithm is correct. Output the answer modulo $998244353$.", "inputFormat": "The first line contains two non-negative integers $n,m$, representing the number of vertices and edges of the given graph.\n\nThe next $m$ lines each contain two positive integers $(u,v)$ $(u\\neq v)$, describing an undirected edge of the graph.", "outputFormat": "Output the probability of being correct, modulo $998244353$.", "hint": "#### Sample Explanation\n\nThe maximum independent set size of this graph is clearly $2$. It can be seen that only when $p[1]=2$ will we get $S=\\{2\\}$; otherwise, we always get $S=\\{1,3\\}$. Therefore, the answer is $\\frac{2}{3}$.\n\n#### Constraints\n\nFor $10\\%$ of the testdata, $1\\leq n\\leq 9$.\n\nFor $30\\%$ of the testdata, $1\\leq n\\leq 13$.\n\nFor $50\\%$ of the testdata, $1\\leq n\\leq 17$.\n\nAnother $10\\%$ of the testdata satisfies that the given graph is a path.\n\nAnother $10\\%$ of the testdata satisfies that the given graph is a tree.\n\nFor $100\\%$ of the testdata, $1\\leq n\\leq 20$, $0\\leq m\\leq \\frac{n\\times (n-1)}{2}$. It is guaranteed that the given graph has no multiple edges and no self-loops.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[PKUWC2018] 随机算法", "background": "", "description": "我们知道，求任意图的最大独立集是一类NP完全问题，目前还没有准确的多项式算法，但是有许多多项式复杂度的近似算法。\n\n例如，小 C 常用的一种算法是：\n\n1. 对于一个 $n$ 个点的无向图，先等概率随机一个 $1\\ldots n$ 的排列 $p[1\\ldots n]$。\n\n2. 维护答案集合 $S$ ，一开始 $S$ 为空集，之后按照 $i=1\\ldots n$ 的顺序，检查 $\\{p[i]\\}\\cup S$ 是否是一个独立集，如果是的话就令 $S=\\{p[i]\\}\\cup S$。\n\n3. 最后得到一个独立集 $S$ 作为答案。\n\n小 C 现在想知道，对于给定的一张图，这个算法的正确率，输出答案对 $998244353$ 取模。", "inputFormat": "第一行两个非负整数 $n,m$ 表示给定的图的点数和边数。\n\n接下来 $m$ 行，每行有两个正整数 $(u,v) (u\\neq v)$ 描述这张图的一条无向边。", "outputFormat": "输出正确率，答案对 $998244353$ 取模。", "hint": "#### 样例解释\n这张图的最大独立集显然为 $2$，可以发现只有 $p[1]=2$ 时会得出 $S=\\{2\\}$，否则都是 $S=\\{1,3\\}$，所以答案是 $\\frac{2}{3}$。\n\n\n#### 数据范围\n对于 $10\\%$ 的数据，有$1\\leq n\\leq 9$。\n\n对于 $30\\%$ 的数据，有$1\\leq n\\leq 13$。\n\n对于 $50\\%$ 的数据，有$1\\leq n\\leq 17$。\n\n另有 $10\\%$ 的数据，满足给定的图是一条链。\n\n另有 $10\\%$ 的数据，满足给定的图是一棵树。\n\n对于 $100\\%$ 的数据，有$1\\leq n\\leq 20$，$0\\leq m\\leq \\frac{n\\times (n-1)}{2}$，保证给定的图没有重边和自环。", "locale": "zh-CN"}}}
{"pid": "P5493", "type": "P", "difficulty": 6, "samples": [["10 3 1000000007", "1458"], ["100000 0 1000000007", "941229402"], ["100000 10 1000000007", "446053671"]], "limits": {"time": [1000, 1000, 1000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "素数判断,质数,筛法"], "title": "质数前缀统计", "background": "这是洲阁筛和 Min_25 筛的重要前置知识。", "description": "设 $S(n)$ 为 $n$ 以内质数的 $k$ 次方和。\n\n给出 $N$，求下列式子的值。\n\n$$\\sum_{i=1}^{\\lfloor\\sqrt{N}\\rfloor} i^2 S \\!\\left( \\left\\lfloor \\frac{N}{i} \\right\\rfloor \\right)$$\n\n所有结果对给定的质数 $p$ 取模。\n\n", "inputFormat": "一行三个整数 $N,k,p$，之间用空格隔开。", "outputFormat": "一行一个整数，代表计算的结果。", "hint": "**样例解释** : \n\n$S \\!\\left( \\left\\lfloor \\frac{N}{1} \\right\\rfloor \\right)\\! = S(10) = 2^3 + 3^3 + 5^3 + 7^3 = 503$。\n\n$S \\!\\left( \\left\\lfloor \\frac{N}{2} \\right\\rfloor \\right)\\! = S(5) = 2^3 + 3^3 + 5^3 = 160$。\n\n$S \\!\\left( \\left\\lfloor \\frac{N}{3} \\right\\rfloor \\right)\\! = S(3) = 2^3 + 3^3 = 35$。\n\n$1^2 S \\!\\left( \\left\\lfloor \\frac{N}{1} \\right\\rfloor \\right)\\! + 2^2 S \\!\\left( \\left\\lfloor \\frac{N}{2} \\right\\rfloor \\right)\\! + 3^2 S \\!\\left( \\left\\lfloor \\frac{N}{3} \\right\\rfloor \\right)\\! = 503 + 640 + 315 = 1458$。\n\n| 测试点编号 | $N \\le$ | $k \\le$ | 时限 |\n| :--: | :--: | :--: | :--: |\n| $1\\sim 3$ | $10^6$ | $10$ | $1\\texttt s$ |\n| $4\\sim 7$ | $4\\times {10}^{10}$ | $0$ | $3\\texttt s$ |\n| $8\\sim 12$ | $4\\times {10}^{10}$ | $10$ | $3\\texttt s$ |\n\n对于 $100\\%$ 的数据，$0 \\le k \\le 10$，$1 \\le N \\le 4\\times {10}^{10}$，${10}^9 < p < 1.01 \\times {10}^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "质数前缀统计", "background": "这是洲阁筛和 Min_25 筛的重要前置知识。", "description": "设 $S(n)$ 为 $n$ 以内质数的 $k$ 次方和。\n\n给出 $N$，求下列式子的值。\n\n$$\\sum_{i=1}^{\\lfloor\\sqrt{N}\\rfloor} i^2 S \\!\\left( \\left\\lfloor \\frac{N}{i} \\right\\rfloor \\right)$$\n\n所有结果对给定的质数 $p$ 取模。\n\n", "inputFormat": "一行三个整数 $N,k,p$，之间用空格隔开。", "outputFormat": "一行一个整数，代表计算的结果。", "hint": "**样例解释** : \n\n$S \\!\\left( \\left\\lfloor \\frac{N}{1} \\right\\rfloor \\right)\\! = S(10) = 2^3 + 3^3 + 5^3 + 7^3 = 503$。\n\n$S \\!\\left( \\left\\lfloor \\frac{N}{2} \\right\\rfloor \\right)\\! = S(5) = 2^3 + 3^3 + 5^3 = 160$。\n\n$S \\!\\left( \\left\\lfloor \\frac{N}{3} \\right\\rfloor \\right)\\! = S(3) = 2^3 + 3^3 = 35$。\n\n$1^2 S \\!\\left( \\left\\lfloor \\frac{N}{1} \\right\\rfloor \\right)\\! + 2^2 S \\!\\left( \\left\\lfloor \\frac{N}{2} \\right\\rfloor \\right)\\! + 3^2 S \\!\\left( \\left\\lfloor \\frac{N}{3} \\right\\rfloor \\right)\\! = 503 + 640 + 315 = 1458$。\n\n| 测试点编号 | $N \\le$ | $k \\le$ | 时限 |\n| :--: | :--: | :--: | :--: |\n| $1\\sim 3$ | $10^6$ | $10$ | $1\\texttt s$ |\n| $4\\sim 7$ | $4\\times {10}^{10}$ | $0$ | $3\\texttt s$ |\n| $8\\sim 12$ | $4\\times {10}^{10}$ | $10$ | $3\\texttt s$ |\n\n对于 $100\\%$ 的数据，$0 \\le k \\le 10$，$1 \\le N \\le 4\\times {10}^{10}$，${10}^9 < p < 1.01 \\times {10}^9$。", "locale": "zh-CN"}}}
{"pid": "P5494", "type": "P", "difficulty": 6, "samples": [["5 12\n0 0 0 0 0\n2 1 1 1\n2 1 1 2\n2 1 1 3\n3 1 1 3\n4 1 2\n2 1 1 4\n2 1 1 5\n0 1 2 4\n2 2 1 4\n3 2 2 4\n1 1 2\n4 1 3", "3\n2\n4\n3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["线段树", "平衡树", "模板题"], "title": "【模板】线段树分裂", "background": "", "description": "给出一个可重集 $a$（编号为 $1$），它支持以下操作：\n\n`0 p x y`：将可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值移动到一个新的可重集中（新可重集编号为从 $2$ 开始的正整数，是上一次产生的新可重集的编号+1）。\n\n`1 p t`：将可重集 $t$ 中的数放入可重集 $p$，且清空可重集 $t$（数据保证在此后的操作中不会出现可重集 $t$）。\n\n`2 p x q`：在 $p$ 这个可重集中加入 $x$ 个数字 $q$。\n\n`3 p x y`：查询可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值的个数。\n\n`4 p k`：查询在 $p$ 这个可重集中第 $k$ 小的数，不存在时输出 `-1`。", "inputFormat": "第一行两个整数 $n,m$，表示可重集中的数在 $1\\sim n$ 的范围内，有 $m$ 个操作。\n\n接下来一行 $n$ 个整数，表示 $1 \\sim n$ 这些数在 $a$ 中出现的次数 $(a_{i} \\leq m)$。\n\n接下来的 $m$ 行每行若干个整数，第一个数为操作的编号 $opt$（$0 \\leq opt \\leq 4$），以**题目描述**为准。", "outputFormat": "依次输出每个查询操作的答案。", "hint": "对于 $30\\%$ 的数据，$1\\leq n \\leq {10}^3$，$1 \\le m \\le {10}^3$；  \n对于 $100\\%$ 的数据，$1 \\le n \\le 2 \\times {10}^5$，$1 \\le x, y, q \\le m \\le 2 \\times {10}^5$。保证数据合法。\n\n不开 `long long` 见祖宗！！\n\n---\n\n题面 by @[Limit](https://www.luogu.com.cn/user/86625)\n\nstd by @[Limit](https://www.luogu.com.cn/user/86625)（线段树分裂）\n\n验题 by @[Froggy](https://www.luogu.com.cn/user/100285)（平衡树，不过合并的复杂度假掉了，倒数第二个测试点就是 hack 数据）\n\n数据 by @[Froggy](https://www.luogu.com.cn/user/100285)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【模板】线段树分裂", "background": "", "description": "给出一个可重集 $a$（编号为 $1$），它支持以下操作：\n\n`0 p x y`：将可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值移动到一个新的可重集中（新可重集编号为从 $2$ 开始的正整数，是上一次产生的新可重集的编号+1）。\n\n`1 p t`：将可重集 $t$ 中的数放入可重集 $p$，且清空可重集 $t$（数据保证在此后的操作中不会出现可重集 $t$）。\n\n`2 p x q`：在 $p$ 这个可重集中加入 $x$ 个数字 $q$。\n\n`3 p x y`：查询可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值的个数。\n\n`4 p k`：查询在 $p$ 这个可重集中第 $k$ 小的数，不存在时输出 `-1`。", "inputFormat": "第一行两个整数 $n,m$，表示可重集中的数在 $1\\sim n$ 的范围内，有 $m$ 个操作。\n\n接下来一行 $n$ 个整数，表示 $1 \\sim n$ 这些数在 $a$ 中出现的次数 $(a_{i} \\leq m)$。\n\n接下来的 $m$ 行每行若干个整数，第一个数为操作的编号 $opt$（$0 \\leq opt \\leq 4$），以**题目描述**为准。", "outputFormat": "依次输出每个查询操作的答案。", "hint": "对于 $30\\%$ 的数据，$1\\leq n \\leq {10}^3$，$1 \\le m \\le {10}^3$；  \n对于 $100\\%$ 的数据，$1 \\le n \\le 2 \\times {10}^5$，$1 \\le x, y, q \\le m \\le 2 \\times {10}^5$。保证数据合法。\n\n不开 `long long` 见祖宗！！\n\n---\n\n题面 by @[Limit](https://www.luogu.com.cn/user/86625)\n\nstd by @[Limit](https://www.luogu.com.cn/user/86625)（线段树分裂）\n\n验题 by @[Froggy](https://www.luogu.com.cn/user/100285)（平衡树，不过合并的复杂度假掉了，倒数第二个测试点就是 hack 数据）\n\n数据 by @[Froggy](https://www.luogu.com.cn/user/100285)", "locale": "zh-CN"}}}
{"pid": "P5495", "type": "P", "difficulty": 5, "samples": [["5 1477\n", "2608816472\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["Dirichlet 卷积", "模板题"], "title": "【模板】Dirichlet 前缀和", "background": "模板题，无背景。", "description": "给定一个长度为 $n$ 的数列 $a_1,a_2,a_3,\\dots,a_n$。\n\n现在你要求出一个长度为 $n$ 的数列 $b_1,b_2,b_3,\\dots,b_n$，满足\n\n$$b_k=\\sum_{i|k}a_i$$\n\n由于某些神秘原因，这里的 $b_k$ 要对 $2^{32}$ 取模。", "inputFormat": "为了避免过大的输入，本题的输入使用随机数生成器。\n\n输入中只有一行两个整数 $n,seed$。其中 $seed$ 为 $32$ 位无符号整数，用来生成数据。\n\n接下来，你要调用 $n$ 次随机数生成器，分别生成 $a_1\\sim a_n$。\n\n对于```C/C++```选手，生成器模板如下：\n\n```cpp\n#define uint unsigned int\nuint seed;\ninline uint getnext(){\n\tseed^=seed<<13;\n\tseed^=seed>>17;\n\tseed^=seed<<5;\n\treturn seed;\n}\n```\n\n对于```Pascal```选手，生成器模板如下：\n\n```pas\nvar seed:dword;\nfunction getnext:dword;\nbegin\n\tseed:=seed xor(seed shl 13);\n\tseed:=seed xor(seed shr 17);\n\tseed:=seed xor(seed shl 5);\n\tgetnext:=seed;\nend;\n```\n\n注意：**所有 $n$ 个数均为 $32$ 位无符号整数**。", "outputFormat": "为了避免过大的输出，你只需输出一个 $32$ 位无符号整数，表示所有 $b_i$ 的异或和。", "hint": "样例中，数列 $a$ 为 $397153977, 974453892, 352446086, 334987182, 2086335567$。\n\n数列 $b$ 为 $397153977, 1371607869, 749600063, 1706595051, 2483489544$。\n\n### 限制与约定\n\n对于 $100\\%$ 的数据， $1\\leq n\\leq 2\\times 10^7$，$0\\leq seed< 2^{32}$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Dirichlet Prefix Sum", "background": "This is a template problem, with no background.", "description": "Given a sequence $a_1,a_2,a_3,\\dots,a_n$ of length $n$.\n\nNow you need to compute a sequence $b_1,b_2,b_3,\\dots,b_n$ of length $n$, satisfying\n\n$$b_k=\\sum_{i|k}a_i$$\n\nDue to some mysterious reasons, each $b_k$ should be taken modulo $2^{32}$.", "inputFormat": "To avoid overly large input, this problem uses a random number generator.\n\nThe input contains only one line with two integers $n, seed$. Here, $seed$ is a $32$-bit unsigned integer used to generate the data.\n\nNext, you need to call the random number generator $n$ times to generate $a_1 \\sim a_n$.\n\nFor ```C/C++``` users, the generator template is as follows:\n\n```cpp\n#define uint unsigned int\nuint seed;\ninline uint getnext(){\n\tseed^=seed<<13;\n\tseed^=seed>>17;\n\tseed^=seed<<5;\n\treturn seed;\n}\n```\n\nFor ```Pascal``` users, the generator template is as follows:\n\n```pas\nvar seed:dword;\nfunction getnext:dword;\nbegin\n\tseed:=seed xor(seed shl 13);\n\tseed:=seed xor(seed shr 17);\n\tseed:=seed xor(seed shl 5);\n\tgetnext:=seed;\nend;\n```\n\nNote: **All $n$ numbers are $32$-bit unsigned integers**.", "outputFormat": "To avoid overly large output, you only need to output one $32$-bit unsigned integer, which is the XOR sum of all $b_i$.", "hint": "In the sample, the sequence $a$ is $397153977, 974453892, 352446086, 334987182, 2086335567$.\n\nThe sequence $b$ is $397153977, 1371607869, 749600063, 1706595051, 2483489544$.\n\n### Constraints and Conventions\n\nFor $100\\%$ of the testdata, $1\\leq n\\leq 2\\times 10^7$, $0\\leq seed< 2^{32}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】Dirichlet 前缀和", "background": "模板题，无背景。", "description": "给定一个长度为 $n$ 的数列 $a_1,a_2,a_3,\\dots,a_n$。\n\n现在你要求出一个长度为 $n$ 的数列 $b_1,b_2,b_3,\\dots,b_n$，满足\n\n$$b_k=\\sum_{i|k}a_i$$\n\n由于某些神秘原因，这里的 $b_k$ 要对 $2^{32}$ 取模。", "inputFormat": "为了避免过大的输入，本题的输入使用随机数生成器。\n\n输入中只有一行两个整数 $n,seed$。其中 $seed$ 为 $32$ 位无符号整数，用来生成数据。\n\n接下来，你要调用 $n$ 次随机数生成器，分别生成 $a_1\\sim a_n$。\n\n对于```C/C++```选手，生成器模板如下：\n\n```cpp\n#define uint unsigned int\nuint seed;\ninline uint getnext(){\n\tseed^=seed<<13;\n\tseed^=seed>>17;\n\tseed^=seed<<5;\n\treturn seed;\n}\n```\n\n对于```Pascal```选手，生成器模板如下：\n\n```pas\nvar seed:dword;\nfunction getnext:dword;\nbegin\n\tseed:=seed xor(seed shl 13);\n\tseed:=seed xor(seed shr 17);\n\tseed:=seed xor(seed shl 5);\n\tgetnext:=seed;\nend;\n```\n\n注意：**所有 $n$ 个数均为 $32$ 位无符号整数**。", "outputFormat": "为了避免过大的输出，你只需输出一个 $32$ 位无符号整数，表示所有 $b_i$ 的异或和。", "hint": "样例中，数列 $a$ 为 $397153977, 974453892, 352446086, 334987182, 2086335567$。\n\n数列 $b$ 为 $397153977, 1371607869, 749600063, 1706595051, 2483489544$。\n\n### 限制与约定\n\n对于 $100\\%$ 的数据， $1\\leq n\\leq 2\\times 10^7$，$0\\leq seed< 2^{32}$。", "locale": "zh-CN"}}}
{"pid": "P5496", "type": "P", "difficulty": 6, "samples": [["debber\n", "1 1 1 2 1 1\n"], ["lwkvjfrphhgkfvzzyx\n", "1 1 2 2 3 1 1 1 1 2 3 1 1 1 1 2 3 4\n"], ["azzzyyzyyx", "1 2 1 2 3 2 2 2 3 3"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["字符串", "O2优化", "回文自动机 PAM", "模板题"], "title": "【模板】回文树 / 回文自动机（PAM）", "background": null, "description": "给定一个字符串 $s$。保证每个字符为小写字母。对于 $s$ 的每个位置，请求出以该位置结尾的回文子串个数。\n\n这个字符串被进行了加密，除了第一个字符，其他字符都需要通过上一个位置的答案来解密。\n\n具体地，若第 $i(i\\geq 1)$ 个位置的答案是 $k$，第 $i+1$ 个字符读入时的 $\\rm ASCII$ 码为 $c$，则第 $i+1$ 个字符实际的 $\\rm ASCII$ 码为 $(c-97+k)\\bmod 26+97$。所有字符在加密前后都为小写字母。", "inputFormat": "一行一个字符串 $s$ 表示被加密后的串。", "outputFormat": "一行， $|s|$ 个整数。第 $i$ 个整数表示原串以第 $i$ 个字符结尾的回文子串个数。", "hint": "### 样例解释\n\n三个样例解码后分别为：\n\n- $\\verb!dfccgs!$；\n- $\\verb!lxlxlisqiiingwaaaa!$；\n- $\\verb!aabaabbaaa!$。\n\n### 数据范围及约定\n\n对于 $100\\%$ 的数据， $1\\leq |s|\\leq 5\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Palindromic Tree / Palindromic Automaton (PAM).", "background": "", "description": "Given a string $s$. It is guaranteed that each character is a lowercase letter. For each position in $s$, find the number of palindromic substrings that end at that position.\n\nThis string has been encrypted. Except for the first character, all other characters must be decrypted using the answer from the previous position.\n\nSpecifically, if the answer at position $i(i\\geq 1)$ is $k$, and the $\\rm ASCII$ code read for the character at position $i+1$ is $c$, then the actual $\\rm ASCII$ code of the character at position $i+1$ is $(c-97+k)\\bmod 26+97$. All characters are lowercase letters both before and after encryption.", "inputFormat": "One line containing a string $s$, representing the encrypted string.", "outputFormat": "One line with $|s|$ integers. The $i$-th integer represents the number of palindromic substrings in the original string that end at the $i$-th character.", "hint": "### Sample Explanation\n\nAfter decoding, the three samples are respectively:\n\n- $\\verb!dfccgs!$;\n- $\\verb!lxlxlisqiiingwaaaa!$;\n- $\\verb!aabaabbaaa!$.\n\n### Constraints and Notes\n\nFor $100\\%$ of the testdata, $1\\leq |s|\\leq 5\\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】回文树 / 回文自动机（PAM）", "background": null, "description": "给定一个字符串 $s$。保证每个字符为小写字母。对于 $s$ 的每个位置，请求出以该位置结尾的回文子串个数。\n\n这个字符串被进行了加密，除了第一个字符，其他字符都需要通过上一个位置的答案来解密。\n\n具体地，若第 $i(i\\geq 1)$ 个位置的答案是 $k$，第 $i+1$ 个字符读入时的 $\\rm ASCII$ 码为 $c$，则第 $i+1$ 个字符实际的 $\\rm ASCII$ 码为 $(c-97+k)\\bmod 26+97$。所有字符在加密前后都为小写字母。", "inputFormat": "一行一个字符串 $s$ 表示被加密后的串。", "outputFormat": "一行， $|s|$ 个整数。第 $i$ 个整数表示原串以第 $i$ 个字符结尾的回文子串个数。", "hint": "### 样例解释\n\n三个样例解码后分别为：\n\n- $\\verb!dfccgs!$；\n- $\\verb!lxlxlisqiiingwaaaa!$；\n- $\\verb!aabaabbaaa!$。\n\n### 数据范围及约定\n\n对于 $100\\%$ 的数据， $1\\leq |s|\\leq 5\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5497", "type": "P", "difficulty": 3, "samples": [["2 4\n", "NO\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["鸽笼原理", "构造"], "title": "[LnOI2019SP] 龟速单项式变换(SMT)", "background": "题目提供者：朝田诗乃\n\n众所周知，这是一题签到题。", "description": "有如下定义：若正整数序列 $a$ 中存在连续若干个正整数的和为 $m$ 的倍数，则这个正整数序列 $a$ 被称为“$m$ 序列”。\n\n给定 $n$ 和 $m$，你需要知道长度为 $n$ 的任意正整数序列 $a$ 是否都是“$m$ 序列”。", "inputFormat": "两个数，$n$ 和 $m$。", "outputFormat": "如果成立输出 `YES` 否则输出 `NO`。", "hint": "样例解释：存在反例 $[1, 2]$。\n\nSubtask 1 (50 pts)：$1 \\le n, m \\le 5$。\n\nSubtask 2 (50 pts)：$1 \\le n, m \\le {10}^{18}$。", "locale": "zh-CN", "translations": {"en": {"title": "[LnOI2019SP] Turtle-Speed Single-Term Transformation (SMT).", "background": "Problem provider: Asada Shino.\n\nAs everyone knows, this is a check-in problem.", "description": "The following definition is given: if, in a positive integer sequence $a$, there exists a sum of several consecutive positive integers that is a multiple of $m$, then the positive integer sequence $a$ is called an “$m$ sequence”.\n\nGiven $n$ and $m$, you need to determine whether every positive integer sequence $a$ of length $n$ is an “$m$ sequence”.", "inputFormat": "Two numbers, $n$ and $m$.", "outputFormat": "If it holds, output `YES`; otherwise output `NO`.", "hint": "Sample explanation: there exists a counterexample $[1, 2]$.\n\nSubtask 1 (50 pts): $1 \\le n, m \\le 5$.\n\nSubtask 2 (50 pts): $1 \\le n, m \\le {10}^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[LnOI2019SP] 龟速单项式变换(SMT)", "background": "题目提供者：朝田诗乃\n\n众所周知，这是一题签到题。", "description": "有如下定义：若正整数序列 $a$ 中存在连续若干个正整数的和为 $m$ 的倍数，则这个正整数序列 $a$ 被称为“$m$ 序列”。\n\n给定 $n$ 和 $m$，你需要知道长度为 $n$ 的任意正整数序列 $a$ 是否都是“$m$ 序列”。", "inputFormat": "两个数，$n$ 和 $m$。", "outputFormat": "如果成立输出 `YES` 否则输出 `NO`。", "hint": "样例解释：存在反例 $[1, 2]$。\n\nSubtask 1 (50 pts)：$1 \\le n, m \\le 5$。\n\nSubtask 2 (50 pts)：$1 \\le n, m \\le {10}^{18}$。", "locale": "zh-CN"}}}
{"pid": "P5498", "type": "P", "difficulty": 5, "samples": [["5 3\n6 12 6 3 27\n1 1\n4 5\n1 3", "6\n37\n100"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": [], "title": "[LnOI2019] 脸滚键盘", "background": "题目提供者：Okami\n\n朝田诗乃：一个优秀的长脖子鹿是会数数字的位数的。", "description": "长颈鹿Abbi喜欢用脸滚键盘，它每次滚键盘就会把一段子区间的值乘起来。\n\n定义子区间为一个区间中的一个连续区间。\n\n定义一段子区间的权值为每个元素权值之积。\n\n定义一段区间的期望权值为任意选出一段子区间的权值的期望值。\n\n给定 $n$ 个数字，分别表示权值 $a_i$。\n\n共 $q$ 次询问，对于一次询问 $l \\ r$ 查询指定区间的期望权值。", "inputFormat": "第一行，两个数 $n$ 和 $q$。\n\n第二行 $n$ 个数，第 $n$ 个数表示序列初始值 $a_i$。\n\n接下来 $q$ 行，每行两个数 $l \\ \\ r$，表示询问的区间。", "outputFormat": "对于每次询问，输出指定区间的期望权值。\n\n由于期望权值可以很大，**请输出期望权值模 $100000007$。**\n\n不要问我除不尽怎么办了，看上面\n\n还是不行的话请移步https://www.luogu.org/problem/P2613", "hint": "时空限制：1s/512MB\n\n对于30%的数据，$1 \\leq n, q \\leq 100$\n\n对于100%的数据，$1 \\leq n, q \\leq 10^6$，$1 \\leq a_i \\leq 10^7$\n\n样例解释：对于区间 $[1,1]$，共有一个子区间 $[1,1]$，权值为 $6$，每个区间取到的概率是 $\\frac{1}{1}$，期望权值为6.\n\n对于区间 $[4,5]$，共有三个子区间 $[4,4]$、$[4,5]$、$[5,5]$，权值分别为 $3$、$81$、$27$，每个区间取到的概率是 $\\frac{1}{3}$，总期望权值为 $37$.\n\n对于区间 $[1,3]$，共有个六子区间 $[1,1]$、$[1,2]$、$[1,3]$、$[2,2]$、$[2,3]$、$[3,3]$，权值分别为 $6$、$72$、$432$、$12$、$72$、$6$，每个区间取到的概率是 $\\frac{1}{6}$，总期望权值为 $100$.\n\n建议使用读入优化。", "locale": "zh-CN", "translations": {"en": {"title": "[LnOI2019] Face-Rolling the Keyboard", "background": "Problem provider: Okami.\n\nAsada Shino: A good long-necked deer can count the number of digits in numbers.", "description": "The giraffe Abbi likes to roll its face on the keyboard. Each time it does so, it multiplies the values in some sub-interval.\n\nA sub-interval is a contiguous interval within an interval.\n\nThe weight of a sub-interval is defined as the product of the weights of all its elements.\n\nThe expected weight of an interval is defined as the expected value of the weight of a sub-interval chosen uniformly at random from all sub-intervals of that interval.\n\nGiven $n$ numbers, where the $i$-th number is the weight $a_i$.\n\nThere are $q$ queries. For each query $l \\ \\ r$, ask for the expected weight of the specified interval.", "inputFormat": "The first line contains two integers $n$ and $q$.\n\nThe second line contains $n$ integers, the $i$-th integer is the initial value $a_i$ of the sequence.\n\nThe next $q$ lines each contain two integers $l \\ \\ r$, representing the query interval.", "outputFormat": "For each query, output the expected weight of the specified interval.\n\nSince the expected weight can be very large, **output the expected weight modulo $100000007$.**\n\nDo not ask what to do if it is not divisible; see above.\n\nIf it still does not work, please refer to https://www.luogu.org/problem/P2613.", "hint": "Time and memory limits: 1 s / 512 MB.\n\nFor $30\\%$ of the testdata, $1 \\leq n, q \\leq 100$.\n\nFor $100\\%$ of the testdata, $1 \\leq n, q \\leq 10^6$, $1 \\leq a_i \\leq 10^7$.\n\nSample explanation: For the interval $[1,1]$, there is only one sub-interval $[1,1]$ with weight $6$. The probability of choosing each sub-interval is $\\frac{1}{1}$, so the expected weight is 6.\n\nFor the interval $[4,5]$, there are three sub-intervals $[4,4]$, $[4,5]$, and $[5,5]$, with weights $3$, $81$, and $27$ respectively. The probability of choosing each sub-interval is $\\frac{1}{3}$, so the total expected weight is $37$.\n\nFor the interval $[1,3]$, there are six sub-intervals $[1,1]$, $[1,2]$, $[1,3]$, $[2,2]$, $[2,3]$, and $[3,3]$, with weights $6$, $72$, $432$, $12$, $72$, and $6$ respectively. The probability of choosing each sub-interval is $\\frac{1}{6}$, so the total expected weight is $100$.\n\nIt is recommended to use fast input.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[LnOI2019] 脸滚键盘", "background": "题目提供者：Okami\n\n朝田诗乃：一个优秀的长脖子鹿是会数数字的位数的。", "description": "长颈鹿Abbi喜欢用脸滚键盘，它每次滚键盘就会把一段子区间的值乘起来。\n\n定义子区间为一个区间中的一个连续区间。\n\n定义一段子区间的权值为每个元素权值之积。\n\n定义一段区间的期望权值为任意选出一段子区间的权值的期望值。\n\n给定 $n$ 个数字，分别表示权值 $a_i$。\n\n共 $q$ 次询问，对于一次询问 $l \\ r$ 查询指定区间的期望权值。", "inputFormat": "第一行，两个数 $n$ 和 $q$。\n\n第二行 $n$ 个数，第 $n$ 个数表示序列初始值 $a_i$。\n\n接下来 $q$ 行，每行两个数 $l \\ \\ r$，表示询问的区间。", "outputFormat": "对于每次询问，输出指定区间的期望权值。\n\n由于期望权值可以很大，**请输出期望权值模 $100000007$。**\n\n不要问我除不尽怎么办了，看上面\n\n还是不行的话请移步https://www.luogu.org/problem/P2613", "hint": "时空限制：1s/512MB\n\n对于30%的数据，$1 \\leq n, q \\leq 100$\n\n对于100%的数据，$1 \\leq n, q \\leq 10^6$，$1 \\leq a_i \\leq 10^7$\n\n样例解释：对于区间 $[1,1]$，共有一个子区间 $[1,1]$，权值为 $6$，每个区间取到的概率是 $\\frac{1}{1}$，期望权值为6.\n\n对于区间 $[4,5]$，共有三个子区间 $[4,4]$、$[4,5]$、$[5,5]$，权值分别为 $3$、$81$、$27$，每个区间取到的概率是 $\\frac{1}{3}$，总期望权值为 $37$.\n\n对于区间 $[1,3]$，共有个六子区间 $[1,1]$、$[1,2]$、$[1,3]$、$[2,2]$、$[2,3]$、$[3,3]$，权值分别为 $6$、$72$、$432$、$12$、$72$、$6$，每个区间取到的概率是 $\\frac{1}{6}$，总期望权值为 $100$.\n\n建议使用读入优化。", "locale": "zh-CN"}}}
{"pid": "P5499", "type": "P", "difficulty": 6, "samples": [["8 5\n1 2 3 3 2 2 7\n1 0 1 3 4 5 0 6\n3 1\n2 2\n3 1\n1 4 1\n3 1", "18 132\n37 360\n35 120"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["树链剖分"], "title": "[LnOI2019] Abbi 并不想研学", "background": "题目提供者：XuKaFy", "description": "**【原版题目】**\n\n给定一颗 $n$ 个节点的树，树的叶节点全部是数字，非叶节点全部是符号 `+` 或者 `*`。\n\n请先对该树进行树链剖分。注意：若出现子树大小相同的情况，请选择编号较小的子节点作为重儿子。\n\n一个节点的权值这样计算：若该节点为叶节点，数值即为节点数值；若该节点非叶节点，则该点的权值为【【【该点的【所有不在该点所在重链上】的子节点】所在重链的所有节点权值】相 `+` 或者相 `*` 的结果（操作取决于该节点的符号）】。\n\n另一种表示方式是：设某一节点 $i$ 的儿子集合为 $D_{i}$，节点 $i$ 的父亲为 $F_{i}$，节点 $i$ 的所在重链节点集合为 $P_{i}$。\n\n我们设：\n$$\nCharge_{i}=\\cup_{k\\in D_{i},\\ k\\not\\in P_{i}}P_{k}\n$$\n\n令 $C_{i}$ 为这个节点的符号，这个节点的权值就是：\n$$\nV_{i}=\n\\begin{cases}\n\\sum_{j\\in Charge_{i}}V_{j} &C_{i}=`+'\\\\\n\\prod_{j\\in Charge_{i}}V_{j} &C_{i}=`\\times'\n\\end{cases}  \n$$\n\n数据不保证每一个非叶节点都有至少一个非链上儿子，若没有合法的儿子则忽略该节点。\n\n你需要支持这三种操作：\n\n1. 改变某一叶节点的数值；\n\n2. 改变某一非叶节点的符号为 `+` 或者 `*`；\n\n3. 查询某一节点所在重链所有节点权值相 `+` 与相 `*` 的值。\n\n为防止溢出，请将所有权值对 $99991$ 取模。", "inputFormat": "第一行输入两个数 $n$ 与 $m$ 表示学生数量与要求数量。\n\n接下来输入 $1$ 行，$n-1$ 个数，表示第 $i+1$ 个节点的父亲为$a$。\n\n接下来一行 $n$ 个数，分别为每个节点的信息：若该节点为叶节点，则是一个数字表示 $V_{i}$，否则为一个数，`0` 表示 `+`，`1`表示 `*`。\n\n接下来输入 $m$ 行，每行一个数字 $c$ 与编号 $k$，表示要求类型为 $c$，操作的节点编号为 $k$。若 $c=1$，那么再输入一个数 $V_{i}$ 表示新的权值。", "outputFormat": "对于每一个 $3$ 操作，请输出一行，该行包括两个数 $a, b$，分别表示将本节点所在重链的所有节点权值相加**以及**相乘的结果。", "hint": "对于 $30\\%$ 的数据，$1 \\le n,m \\le 1000$。\n\n对于 $100\\%$ 的数据，$1 \\le n,m \\le 10^{6}, 1 \\le V_{i}<99991$。\n\n**数据保证任何时刻树上没有权值为 $0$ 的节点。**", "locale": "zh-CN", "translations": {"en": {"title": "[LnOI2019] Abbi Does Not Want to Go on a Study Tour.", "background": "Problem provider: XuKaFy", "description": "**[Original Problem]**\n\nGiven a tree with $n$ nodes. All leaf nodes are numbers, and all non-leaf nodes are symbols `+` or `*`.\n\nFirst, perform Heavy-Light Decomposition (HLD) on the tree. Note: if there is a tie in subtree size, choose the child with the smaller index as the heavy child.\n\nThe value of a node is defined as follows: if the node is a leaf, its value is the number on the node; if the node is not a leaf, then its value is the result of applying `+` or `*` (depending on the node’s symbol) to the values of all nodes on the heavy chains of all its children that are **not on the same heavy chain as this node**.\n\nAnother way to describe it is: let the set of children of node $i$ be $D_{i}$, the parent of node $i$ be $F_{i}$, and the set of nodes on the heavy chain containing node $i$ be $P_{i}$.\n\nDefine:\n$$\nCharge_{i}=\\cup_{k\\in D_{i},\\ k\\not\\in P_{i}}P_{k}\n$$\n\nLet $C_{i}$ be the symbol of this node. Then the value of this node is:\n$$\nV_{i}=\n\\begin{cases}\n\\sum_{j\\in Charge_{i}}V_{j} &C_{i}=`+'\\\\\n\\prod_{j\\in Charge_{i}}V_{j} &C_{i}=`\\times'\n\\end{cases}  \n$$\n\nThe data does not guarantee that every non-leaf node has at least one child outside its chain. If there is no valid child, ignore this node.\n\nYou need to support three operations:\n\n1. Change the value of a leaf node.\n\n2. Change the symbol of a non-leaf node to `+` or `*`.\n\n3. Query, for the heavy chain containing a given node, the sum and the product of the values of all nodes on that heavy chain.\n\nTo prevent overflow, take all values modulo $99991$.", "inputFormat": "The first line contains two integers $n$ and $m$, meaning the number of students and the number of requests.\n\nThen input $1$ line with $n-1$ integers, meaning the parent of node $i+1$ is $a$.\n\nThen input one line with $n$ integers describing each node: if the node is a leaf, it is a number representing $V_{i}$; otherwise it is a number, where `0` means `+` and `1` means `*`.\n\nThen input $m$ lines. Each line contains an integer $c$ and an index $k$, meaning the request type is $c$ and the operated node index is $k$. If $c=1$, then input another integer $V_{i}$ as the new value.", "outputFormat": "For each operation of type $3$, output one line containing two integers $a, b$, meaning the sum **and** the product of the values of all nodes on the heavy chain containing this node.", "hint": "For $30\\%$ of the testdata, $1 \\le n,m \\le 1000$.\n\nFor $100\\%$ of the testdata, $1 \\le n,m \\le 10^{6}, 1 \\le V_{i}<99991$.\n\n**The testdata guarantees that at any time there is no node on the tree whose value is $0$.**\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[LnOI2019] Abbi 并不想研学", "background": "题目提供者：XuKaFy", "description": "**【原版题目】**\n\n给定一颗 $n$ 个节点的树，树的叶节点全部是数字，非叶节点全部是符号 `+` 或者 `*`。\n\n请先对该树进行树链剖分。注意：若出现子树大小相同的情况，请选择编号较小的子节点作为重儿子。\n\n一个节点的权值这样计算：若该节点为叶节点，数值即为节点数值；若该节点非叶节点，则该点的权值为【【【该点的【所有不在该点所在重链上】的子节点】所在重链的所有节点权值】相 `+` 或者相 `*` 的结果（操作取决于该节点的符号）】。\n\n另一种表示方式是：设某一节点 $i$ 的儿子集合为 $D_{i}$，节点 $i$ 的父亲为 $F_{i}$，节点 $i$ 的所在重链节点集合为 $P_{i}$。\n\n我们设：\n$$\nCharge_{i}=\\cup_{k\\in D_{i},\\ k\\not\\in P_{i}}P_{k}\n$$\n\n令 $C_{i}$ 为这个节点的符号，这个节点的权值就是：\n$$\nV_{i}=\n\\begin{cases}\n\\sum_{j\\in Charge_{i}}V_{j} &C_{i}=`+'\\\\\n\\prod_{j\\in Charge_{i}}V_{j} &C_{i}=`\\times'\n\\end{cases}  \n$$\n\n数据不保证每一个非叶节点都有至少一个非链上儿子，若没有合法的儿子则忽略该节点。\n\n你需要支持这三种操作：\n\n1. 改变某一叶节点的数值；\n\n2. 改变某一非叶节点的符号为 `+` 或者 `*`；\n\n3. 查询某一节点所在重链所有节点权值相 `+` 与相 `*` 的值。\n\n为防止溢出，请将所有权值对 $99991$ 取模。", "inputFormat": "第一行输入两个数 $n$ 与 $m$ 表示学生数量与要求数量。\n\n接下来输入 $1$ 行，$n-1$ 个数，表示第 $i+1$ 个节点的父亲为$a$。\n\n接下来一行 $n$ 个数，分别为每个节点的信息：若该节点为叶节点，则是一个数字表示 $V_{i}$，否则为一个数，`0` 表示 `+`，`1`表示 `*`。\n\n接下来输入 $m$ 行，每行一个数字 $c$ 与编号 $k$，表示要求类型为 $c$，操作的节点编号为 $k$。若 $c=1$，那么再输入一个数 $V_{i}$ 表示新的权值。", "outputFormat": "对于每一个 $3$ 操作，请输出一行，该行包括两个数 $a, b$，分别表示将本节点所在重链的所有节点权值相加**以及**相乘的结果。", "hint": "对于 $30\\%$ 的数据，$1 \\le n,m \\le 1000$。\n\n对于 $100\\%$ 的数据，$1 \\le n,m \\le 10^{6}, 1 \\le V_{i}<99991$。\n\n**数据保证任何时刻树上没有权值为 $0$ 的节点。**", "locale": "zh-CN"}}}
{"pid": "P5500", "type": "P", "difficulty": 6, "samples": [["10 4\n3 3 3 3 2 3 3 3 2 2\nQ 1 6 1\nQ 1 6 0\nR 8 8 2\nQ 5 10 1", "5\n4\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": [], "title": "[LnOI2019] 真正的 OIer 从不女装", "background": "题目提供者：朝田诗乃\n\n众所周知，女装只有零次和无数次。", "description": "给定一个长度为 $n$ 的序列 $a$。\n\n有如下定义：若一个序列中所有数字都一样，那么这个序列被称作“诗乃序列”。\n\n对于每次询问，给定 $l$ 和 $r$，求序列 $a$ 中**左右端点都在 $[l,r]$ 中**的最长“诗乃序列”长度。\n\n这题难倒了 Abbi。Abbi 决定女装。当 Abbi 女装时，序列会出现神奇的变化：它可以**在询问的区间 $[l,r]$ 中**挑一个它喜欢的位置 $p$，将区间 $[l,p]$ 和 $(p,r]$ **分别**翻转。\n\nAbbi 想知道，**最多**进行 $k$ 次女装后（可选择进行不足 $k$ 次或不进行女装），能得到的最长的“诗乃序列”的长度是多少？", "inputFormat": "第一行，$n$、$m$，表示序列长度和操作个数。\n\n第二行，$n$ 个数，第$i$个数表示序列初始值 $a_i$。\n\n接下来 $m$ 行，每行描述一个操作，格式如下：\n\n1. $R$ $l$ $r$ $x$：表示将区间 $[l,r]$ 上的数字全部变成 $x$。\n2. $Q$ $l$ $r$ $k$：表示询问在 $[l,r]$ 中进行最多 $k$ 次女装所能得到的最长“诗乃序列”长度。\n\n**注意：询问独立，即每次询问后会将序列复原，不实际执行反转操作。**", "outputFormat": "对于每个 Q 操作，输出询问答案。", "hint": "**时空限制**：1s/512MB。\n\n**数据范围：**\n\n- 对于 $20\\%$ 的数据，$1 ≤ n,m ≤ 100$。\n- 对于另外 $10\\%$ 数据，所有询问的 $k=0$。\n- 对于另外 $10\\%$ 数据，没有 R 操作。\n- 对于 $100\\%$ 的数据，$1≤n,m≤200000$，$0≤k≤1000$，$1≤a_i,x≤10^9$，$1≤l≤r≤n$。\n\n特殊限制：对于后 $80\\%$ 的数据，保证能卡飞 ODT。\n\n**样例解释：**\n\n对于第一次询问，询问的区间为：\n\n```\n3 3 3 3 2 3\n```\n\n女装 $1$ 次，将区间 $[1,4]$ 和 $[5,6]$ 分别翻转，得到：\n\n```\n3 3 3 3 3 2\n```\n\n此时可得到最长“诗乃序列”，长度为 $5$。可以证明没有别的女装方法能得到更长的“诗乃序列”。\n\n此后询问以此类推。\n\n**建议使用读入优化。**", "locale": "zh-CN", "translations": {"en": {"title": "[LnOI2019] A Real OIer Never Cross-dresses", "background": "Problem provider: Asada Shino.\n\nAs everyone knows, there are only zero times and countless times for cross-dressing.", "description": "Given a sequence $a$ of length $n$.\n\nThere is the following definition: if all numbers in a sequence are the same, then this sequence is called a “Shino sequence”.\n\nFor each query, given $l$ and $r$, find the maximum length of a “Shino sequence” in $a$ whose **both endpoints are within $[l,r]$**.\n\nThis problem stumped Abbi. Abbi decided to cross-dress. When Abbi cross-dresses, the sequence undergoes a magical change: it can choose a position $p$ that it likes **within the query interval $[l,r]$**, and **separately** reverse the intervals $[l,p]$ and $(p,r]$.\n\nAbbi wants to know: after cross-dressing at most $k$ times (you may choose to do fewer than $k$ times, or not cross-dress at all), what is the maximum possible length of a “Shino sequence” that can be obtained?", "inputFormat": "The first line contains $n$ and $m$, representing the sequence length and the number of operations.\n\nThe second line contains $n$ numbers, where the $i$-th number is the initial value $a_i$.\n\nThe next $m$ lines each describe an operation in the following format:\n\n1. $R$ $l$ $r$ $x$: set all numbers in the interval $[l,r]$ to $x$.\n2. $Q$ $l$ $r$ $k$: query the maximum length of a “Shino sequence” that can be obtained by cross-dressing at most $k$ times within $[l,r]$.\n\n**Note: Queries are independent. That is, after each query, the sequence is restored; the reversal operations are not actually applied.**", "outputFormat": "For each $Q$ operation, output the answer to the query.", "hint": "**Time and memory limits**: 1s / 512MB.\n\n**Constraints:**\n\n- For $20\\%$ of the testdata, $1 \\le n,m \\le 100$.\n- For another $10\\%$ of the testdata, all queries have $k=0$.\n- For another $10\\%$ of the testdata, there are no $R$ operations.\n- For $100\\%$ of the testdata, $1 \\le n,m \\le 200000$, $0 \\le k \\le 1000$, $1 \\le a_i,x \\le 10^9$, $1 \\le l \\le r \\le n$.\n\nSpecial restriction: for the last $80\\%$ of the testdata, it is guaranteed that ODT can be hacked.\n\n**Sample explanation:**\n\nFor the first query, the queried interval is:\n\n```\n3 3 3 3 2 3\n```\n\nCross-dress once, and reverse $[1,4]$ and $[5,6]$ separately, obtaining:\n\n```\n3 3 3 3 3 2\n```\n\nAt this time, the longest “Shino sequence” has length $5$. It can be proven that no other way of cross-dressing can produce a longer “Shino sequence”.\n\nSubsequent queries proceed similarly.\n\n**It is recommended to use fast input.**\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[LnOI2019] 真正的 OIer 从不女装", "background": "题目提供者：朝田诗乃\n\n众所周知，女装只有零次和无数次。", "description": "给定一个长度为 $n$ 的序列 $a$。\n\n有如下定义：若一个序列中所有数字都一样，那么这个序列被称作“诗乃序列”。\n\n对于每次询问，给定 $l$ 和 $r$，求序列 $a$ 中**左右端点都在 $[l,r]$ 中**的最长“诗乃序列”长度。\n\n这题难倒了 Abbi。Abbi 决定女装。当 Abbi 女装时，序列会出现神奇的变化：它可以**在询问的区间 $[l,r]$ 中**挑一个它喜欢的位置 $p$，将区间 $[l,p]$ 和 $(p,r]$ **分别**翻转。\n\nAbbi 想知道，**最多**进行 $k$ 次女装后（可选择进行不足 $k$ 次或不进行女装），能得到的最长的“诗乃序列”的长度是多少？", "inputFormat": "第一行，$n$、$m$，表示序列长度和操作个数。\n\n第二行，$n$ 个数，第$i$个数表示序列初始值 $a_i$。\n\n接下来 $m$ 行，每行描述一个操作，格式如下：\n\n1. $R$ $l$ $r$ $x$：表示将区间 $[l,r]$ 上的数字全部变成 $x$。\n2. $Q$ $l$ $r$ $k$：表示询问在 $[l,r]$ 中进行最多 $k$ 次女装所能得到的最长“诗乃序列”长度。\n\n**注意：询问独立，即每次询问后会将序列复原，不实际执行反转操作。**", "outputFormat": "对于每个 Q 操作，输出询问答案。", "hint": "**时空限制**：1s/512MB。\n\n**数据范围：**\n\n- 对于 $20\\%$ 的数据，$1 ≤ n,m ≤ 100$。\n- 对于另外 $10\\%$ 数据，所有询问的 $k=0$。\n- 对于另外 $10\\%$ 数据，没有 R 操作。\n- 对于 $100\\%$ 的数据，$1≤n,m≤200000$，$0≤k≤1000$，$1≤a_i,x≤10^9$，$1≤l≤r≤n$。\n\n特殊限制：对于后 $80\\%$ 的数据，保证能卡飞 ODT。\n\n**样例解释：**\n\n对于第一次询问，询问的区间为：\n\n```\n3 3 3 3 2 3\n```\n\n女装 $1$ 次，将区间 $[1,4]$ 和 $[5,6]$ 分别翻转，得到：\n\n```\n3 3 3 3 3 2\n```\n\n此时可得到最长“诗乃序列”，长度为 $5$。可以证明没有别的女装方法能得到更长的“诗乃序列”。\n\n此后询问以此类推。\n\n**建议使用读入优化。**", "locale": "zh-CN"}}}
{"pid": "P5501", "type": "P", "difficulty": 6, "samples": [["4 2\n1 2 2 3\n1 4\n1 2", "21\n5"], ["10 5\n8 6 9 8 1 1 3 10 7 9\n5 8\n1 3\n5 7\n9 9\n5 6\n", "51\n49\n11\n7\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 2000, 2000, 2000, 2000, 2000, 2000, 5000, 5000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["莫队", "O2优化"], "title": "[LnOI2019] 来者不拒，去者不追", "background": "题目提供者：朝田诗乃\n\n![avartar](https://cdn.luogu.com.cn/upload/pic/66100.png)", "description": "给定一个长度为 $n$ 的序列 $a$。给定 $m$ 个询问，每次询问一个区间中 $[l,r]$ 中所有数的“Abbi 值”之和。\n\nAbbi 值定义为：若 $a_i$ 在询问区间 $[l,r]$ 中是第 $k$ 小，那么它的“Abbi 值”等于 $k \\times a_i$。\n\n为了消除歧义举个例子：\n\n有序列 $\\{1,2,2,3\\}$，那么 $1$ 是第 $1$ 小，$2$ 是第 $2$ 小，$3$ 是第 $4$ 小，序列 Abbi 值和为：\n\n$$1 \\times 1+2 \\times 2+2 \\times 2+3 \\times 4=21.$$", "inputFormat": "第一行两个整数，$n$ 和 $m$，分别表示序列长度和询问组数。\n\n第二行 $n$ 个数，第 $i$ 个数为 $a_i$，表示序列的初始值。\n\n接下来 $m$ 行，每行两个数 $l$ 和 $r$，表示询问区间。", "outputFormat": "对于每个询问，输出一行表示答案。", "hint": "前 2 个数据点，$1≤n,m≤1000$，时限 1s。\n\n接下来 14 个数据点，$1≤n,a_i,m≤100000$，$1≤l≤r≤n$，时限 1s。\n\n最后两个数据点，$1≤a_i≤100000$，$1≤l≤r≤n$，$1≤n,m≤500000$，时限 3s。\n\n建议使用读入优化。建议开启 O2 优化。\n\n数据已经过加强。", "locale": "zh-CN", "translations": {"en": {"title": "[LnOI2019] Welcome All Who Come, Do Not Chase Those Who Leave", "background": "Problem provider: Asada Shino\n\n![avartar](https://cdn.luogu.com.cn/upload/pic/66100.png)", "description": "Given a sequence $a$ of length $n$. There are $m$ queries. For each query, you need to find the sum of the “Abbi value” of all numbers in the interval $[l,r]$.\n\nThe Abbi value is defined as follows: if $a_i$ is the $k$-th smallest in the query interval $[l,r]$, then its “Abbi value” equals $k \\times a_i$.\n\nTo avoid ambiguity, here is an example:\n\nGiven the sequence $\\{1,2,2,3\\}$, then $1$ is the $1$-st smallest, $2$ is the $2$-nd smallest, and $3$ is the $4$-th smallest. The sum of Abbi values of the sequence is:\n\n$$1 \\times 1+2 \\times 2+2 \\times 2+3 \\times 4=21.$$", "inputFormat": "The first line contains two integers, $n$ and $m$, representing the length of the sequence and the number of queries.\n\nThe second line contains $n$ numbers. The $i$-th number is $a_i$, representing the initial value of the sequence.\n\nThe next $m$ lines each contain two numbers $l$ and $r$, representing a query interval.", "outputFormat": "For each query, output one line with the answer.", "hint": "Constraints\n\nFor the first 2 test points, $1 \\le n,m \\le 1000$, time limit $1\\text{s}$.\n\nFor the next 14 test points, $1 \\le n,a_i,m \\le 100000$, $1 \\le l \\le r \\le n$, time limit $1\\text{s}$.\n\nFor the last 2 test points, $1 \\le a_i \\le 100000$, $1 \\le l \\le r \\le n$, $1 \\le n,m \\le 500000$, time limit $3\\text{s}$.\n\nIt is recommended to use fast input. It is recommended to enable $O2$ optimization.\n\nThe testdata has been strengthened.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[LnOI2019] 来者不拒，去者不追", "background": "题目提供者：朝田诗乃\n\n![avartar](https://cdn.luogu.com.cn/upload/pic/66100.png)", "description": "给定一个长度为 $n$ 的序列 $a$。给定 $m$ 个询问，每次询问一个区间中 $[l,r]$ 中所有数的“Abbi 值”之和。\n\nAbbi 值定义为：若 $a_i$ 在询问区间 $[l,r]$ 中是第 $k$ 小，那么它的“Abbi 值”等于 $k \\times a_i$。\n\n为了消除歧义举个例子：\n\n有序列 $\\{1,2,2,3\\}$，那么 $1$ 是第 $1$ 小，$2$ 是第 $2$ 小，$3$ 是第 $4$ 小，序列 Abbi 值和为：\n\n$$1 \\times 1+2 \\times 2+2 \\times 2+3 \\times 4=21.$$", "inputFormat": "第一行两个整数，$n$ 和 $m$，分别表示序列长度和询问组数。\n\n第二行 $n$ 个数，第 $i$ 个数为 $a_i$，表示序列的初始值。\n\n接下来 $m$ 行，每行两个数 $l$ 和 $r$，表示询问区间。", "outputFormat": "对于每个询问，输出一行表示答案。", "hint": "前 2 个数据点，$1≤n,m≤1000$，时限 1s。\n\n接下来 14 个数据点，$1≤n,a_i,m≤100000$，$1≤l≤r≤n$，时限 1s。\n\n最后两个数据点，$1≤a_i≤100000$，$1≤l≤r≤n$，$1≤n,m≤500000$，时限 3s。\n\n建议使用读入优化。建议开启 O2 优化。\n\n数据已经过加强。", "locale": "zh-CN"}}}
{"pid": "P5502", "type": "P", "difficulty": 5, "samples": [["5\n30 60 20 20 20", "80"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["暴力数据结构", "2015", "各省省选", "江苏", "分治"], "title": "[JSOI2015] 最大公约数", "background": "", "description": "给定一个长度为 $N$ 的正整数序列 $A_i$ 。\n\n对于其任意一个连续的子序列 $A_l,A_{l+1},...,A_r$ ，我们定义其权值 $W(L,R)$ 为其长度与序列中所有元素的最大公约数的乘积，即 $W(L,R) = (R-L+1) × \\gcd (A_l,...,A_r)$。\n\n`JYY` 希望找出权值最大的子序列。", "inputFormat": "输入一行包含一个正整数 $N$ 。\n\n接下来一行，包含 $N$ 个正整数，表示序列 $A_i$ 。\n ", "outputFormat": "输出文件包含一行一个正整数，表示权值最大的子序列的权值。", "hint": "$1 \\le  A_i \\le  10^{12}, 1 \\le  N \\le  100000$", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2015] Greatest Common Divisor", "background": "", "description": "Given a sequence of positive integers $A_i$ of length $N$.\n\nFor any consecutive subsequence $A_l, A_{l+1}, ..., A_r$, define its weight $W(L, R)$ as the product of its length and the greatest common divisor of all elements in the subsequence, i.e., $W(L, R) = (R - L + 1) × \\gcd(A_l, ..., A_r)$.\n\n`JYY` wants to find the subsequence with the maximum weight.", "inputFormat": "The input contains one line with a positive integer $N$.\n\nThe next line contains $N$ positive integers, representing the sequence $A_i$.", "outputFormat": "Output one line with a positive integer, representing the maximum weight among all subsequences.", "hint": "$1 \\le A_i \\le 10^{12}, 1 \\le N \\le 100000$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2015] 最大公约数", "background": "", "description": "给定一个长度为 $N$ 的正整数序列 $A_i$ 。\n\n对于其任意一个连续的子序列 $A_l,A_{l+1},...,A_r$ ，我们定义其权值 $W(L,R)$ 为其长度与序列中所有元素的最大公约数的乘积，即 $W(L,R) = (R-L+1) × \\gcd (A_l,...,A_r)$。\n\n`JYY` 希望找出权值最大的子序列。", "inputFormat": "输入一行包含一个正整数 $N$ 。\n\n接下来一行，包含 $N$ 个正整数，表示序列 $A_i$ 。\n ", "outputFormat": "输出文件包含一行一个正整数，表示权值最大的子序列的权值。", "hint": "$1 \\le  A_i \\le  10^{12}, 1 \\le  N \\le  100000$", "locale": "zh-CN"}}}
{"pid": "P5503", "type": "P", "difficulty": 6, "samples": [["6\n5\n3\n2\n4\n2\n4", "2\n3\n5\n3\n5\n4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2016", "各省省选", "江苏"], "title": "[JSOI2016] 灯塔", "background": null, "description": "JSOI 的国境线上有 $N$ 座连续的山峰，其中第 $i$ 座的高度是 $h_i$。为了简单起见，我们认为这 $N$ 座山峰排成了连续一条直线。如果在第 $i$ 座山峰上建立一座高度为 $p$（$p≥0$）的灯塔，JYY 发现，这座灯塔能够照亮第 $j$ 座山峰，当且仅当满足如下不等式:\n\n$$h_j \\le h_i+p-\\sqrt {|i-j|}$$\n\nJSOI 国王希望对于每一座山峰，JYY 都能提供建造一座能够照亮全部其他山峰的灯塔所需要的最小高度。你能帮助 JYY 么？", "inputFormat": "输入一行包含一个正整数 $N$。\n\n接下来 $N$ 行，第 $i$ 行包含一个正整数 $h_i$，表示第 $i$ 座山峰的高度。", "outputFormat": "第 $i$ 行包含一个非负整数，表示在第 $i$ 座山峰上修建灯塔所需要的最小高度 $p_i$。", "hint": "对于 $100\\%$ 的数据，$1< N \\le  10^5$，$0 < h_i \\le  10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2016] Lighthouse", "background": "", "description": "Along the border of JSOI, there are $N$ consecutive mountain peaks. The height of the $i$-th peak is $h_i$. For simplicity, we assume these $N$ peaks are arranged along a straight line.\n\nIf a lighthouse of height $p$ ($p \\ge 0$) is built on the $i$-th peak, JYY finds that this lighthouse can illuminate the $j$-th peak if and only if the following inequality holds:\n\n$$h_j \\le h_i + p - \\sqrt {|i-j|}$$\n\nThe king of JSOI wants JYY to provide, for each peak, the minimum height required to build a lighthouse that can illuminate all other peaks. Can you help JYY?", "inputFormat": "The input contains one line with a positive integer $N$.\n\nIn the next $N$ lines, the $i$-th line contains a positive integer $h_i$, representing the height of the $i$-th peak.", "outputFormat": "The $i$-th line contains a non-negative integer, representing the minimum height $p_i$ required to build a lighthouse on the $i$-th peak.", "hint": "For $100\\%$ of the data, $1 < N \\le 10^5$, $0 < h_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2016] 灯塔", "background": null, "description": "JSOI 的国境线上有 $N$ 座连续的山峰，其中第 $i$ 座的高度是 $h_i$。为了简单起见，我们认为这 $N$ 座山峰排成了连续一条直线。如果在第 $i$ 座山峰上建立一座高度为 $p$（$p≥0$）的灯塔，JYY 发现，这座灯塔能够照亮第 $j$ 座山峰，当且仅当满足如下不等式:\n\n$$h_j \\le h_i+p-\\sqrt {|i-j|}$$\n\nJSOI 国王希望对于每一座山峰，JYY 都能提供建造一座能够照亮全部其他山峰的灯塔所需要的最小高度。你能帮助 JYY 么？", "inputFormat": "输入一行包含一个正整数 $N$。\n\n接下来 $N$ 行，第 $i$ 行包含一个正整数 $h_i$，表示第 $i$ 座山峰的高度。", "outputFormat": "第 $i$ 行包含一个非负整数，表示在第 $i$ 座山峰上修建灯塔所需要的最小高度 $p_i$。", "hint": "对于 $100\\%$ 的数据，$1< N \\le  10^5$，$0 < h_i \\le  10^9$。", "locale": "zh-CN"}}}
{"pid": "P5504", "type": "P", "difficulty": 6, "samples": [["5\n2\n2\n5\n2\n3", "21"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2011", "各省省选", "江苏", "动态规划优化", "斜率优化"], "title": "[JSOI2011] 柠檬", "background": "", "description": "$\\text{Flute}$ 很喜欢柠檬。它准备了一串用树枝串起来的贝壳，打算用一种魔法把贝壳变成柠檬。贝壳一共有 $n$ $(1≤n≤100000)$ 只，按顺序串在树枝上。为了方便，我们从左到右给贝壳编号 $1..n$ 。每只贝壳的大小不一定相同，贝壳 $i$ 的大小为 $s_i(1≤s_i≤10000)$ 。\n\n变柠檬的魔法要求$:\\ \\text{Flute}$ 每次从树枝一端取下一小段连续的贝壳，并选择一种贝壳的大小 $s_0$。如果这一小段贝壳中大小为 $s_0$ 的贝壳有 $t$ 只，那么魔法可以把这一小段贝壳变成 $s_0t^2$ 只柠檬。$\\text{Flute}$ 可以取任意多次贝壳，直到树枝上的贝壳被全部取完。各个小段中，$\\text{Flute}$ 选择的贝壳大小 $s_0$ 可以不同。而最终 $\\text{Flute}$ 得到的柠檬数，就是所有小段柠檬数的总和。\n\n$\\text{Flute}$ 想知道，它最多能用这一串贝壳\n变出多少柠檬。请你帮忙解决这个问题。", "inputFormat": "第 $1$ 行：一个整数，表示 $n$ 。\n第 $2..n+1$ 行：每行一个整数，第 $i+1$ 行表示 $s_i$。", "outputFormat": "仅一个整数，表示 $\\text{Flute}$ 最多能得到的柠檬数。", "hint": "$\\text{Flute}$ 先从左端取下 $4$ 只贝壳，它们的大小为 $2, 2, 5, 2$。选择 $s_0=2$，那么这一段里有 $3$ 只大小为 $s_0$ 的贝壳，通过魔法可以得到 $2×3^2 = 18$ 只柠檬。再从右端取下最后一只贝壳，通过魔法可以得到 $3×1^2 = 3$ 只柠檬。总共可以得到 $18+3=21$ 只柠檬。没有比这更优的方案了。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2011] Lemons", "background": "", "description": "$\\text{Flute}$ likes lemons very much. It prepared a string of shells threaded onto a branch and plans to use a kind of magic to turn the shells into lemons. There are $n$ $(1 \\le n \\le 100000)$ shells in total, threaded on the branch in order. For convenience, we number the shells from left to right as $1..n$. The sizes of the shells are not necessarily the same; the size of shell $i$ is $s_i(1 \\le s_i \\le 10000)$.\n\nThe lemon-making magic requires that: each time, $\\text{Flute}$ removes a short consecutive segment of shells from one end of the branch, and chooses a shell size $s_0$. If there are $t$ shells of size $s_0$ in this segment, then the magic can turn this segment into $s_0 t^2$ lemons. $\\text{Flute}$ may remove shells any number of times until all shells on the branch have been removed. For different segments, the chosen shell size $s_0$ may be different. The final number of lemons $\\text{Flute}$ gets is the sum of the lemons obtained from all segments.\n\n$\\text{Flute}$ wants to know the maximum number of lemons that can be produced from this string of shells. Please help solve this problem.", "inputFormat": "Line $1$: an integer $n$.\n\nLines $2..n+1$: each line contains one integer; line $i+1$ gives $s_i$.", "outputFormat": "A single integer, meaning the maximum number of lemons $\\text{Flute}$ can obtain.", "hint": "$\\text{Flute}$ first removes $4$ shells from the left end, with sizes $2, 2, 5, 2$. Choose $s_0 = 2$. Then there are $3$ shells of size $s_0$ in this segment, so the magic yields $2 \\times 3^2 = 18$ lemons. Then remove the last shell from the right end, and the magic yields $3 \\times 1^2 = 3$ lemons. In total, you can get $18 + 3 = 21$ lemons. There is no better plan than this.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2011] 柠檬", "background": "", "description": "$\\text{Flute}$ 很喜欢柠檬。它准备了一串用树枝串起来的贝壳，打算用一种魔法把贝壳变成柠檬。贝壳一共有 $n$ $(1≤n≤100000)$ 只，按顺序串在树枝上。为了方便，我们从左到右给贝壳编号 $1..n$ 。每只贝壳的大小不一定相同，贝壳 $i$ 的大小为 $s_i(1≤s_i≤10000)$ 。\n\n变柠檬的魔法要求$:\\ \\text{Flute}$ 每次从树枝一端取下一小段连续的贝壳，并选择一种贝壳的大小 $s_0$。如果这一小段贝壳中大小为 $s_0$ 的贝壳有 $t$ 只，那么魔法可以把这一小段贝壳变成 $s_0t^2$ 只柠檬。$\\text{Flute}$ 可以取任意多次贝壳，直到树枝上的贝壳被全部取完。各个小段中，$\\text{Flute}$ 选择的贝壳大小 $s_0$ 可以不同。而最终 $\\text{Flute}$ 得到的柠檬数，就是所有小段柠檬数的总和。\n\n$\\text{Flute}$ 想知道，它最多能用这一串贝壳\n变出多少柠檬。请你帮忙解决这个问题。", "inputFormat": "第 $1$ 行：一个整数，表示 $n$ 。\n第 $2..n+1$ 行：每行一个整数，第 $i+1$ 行表示 $s_i$。", "outputFormat": "仅一个整数，表示 $\\text{Flute}$ 最多能得到的柠檬数。", "hint": "$\\text{Flute}$ 先从左端取下 $4$ 只贝壳，它们的大小为 $2, 2, 5, 2$。选择 $s_0=2$，那么这一段里有 $3$ 只大小为 $s_0$ 的贝壳，通过魔法可以得到 $2×3^2 = 18$ 只柠檬。再从右端取下最后一只贝壳，通过魔法可以得到 $3×1^2 = 3$ 只柠檬。总共可以得到 $18+3=21$ 只柠檬。没有比这更优的方案了。", "locale": "zh-CN"}}}
{"pid": "P5505", "type": "P", "difficulty": 5, "samples": [["5 4\n1 3 3 5", "384835"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "江苏", "组合数学", "容斥原理"], "title": "[JSOI2011] 分特产", "background": null, "description": "JYY 带队参加了若干场 $\\text{ACM/ICPC}$ 比赛，带回了许多土特产，要分给实验室的同学们。\n\nJYY 想知道，把这些特产分给 $n$ 个同学，一共有多少种不同的分法？当然，JYY 不希望任何一个同学因为没有拿到特产而感到失落，所以每个同学都必须至少分得一个特产。\n\n例如，JYY 带来了 $2$ 袋麻花和 $1$ 袋包子，分给 $A$ 和 $B$ 两位同学，那么共有 $4$ 种不同的\n分配方法：\n\n $A$：麻花， $B$：麻花、包子\n\n $A$：麻花、麻花， $B$：包子\n\n $A$：包子， $B$：麻花、麻花\n\n $A$：麻花、包子， $B$：麻花", "inputFormat": "输入数据：\n\n第一行是同学的数量 $n$ 和特产的种类 $m$。\n\n第二行包含 $m$ 个整数，表示每一种特产的数量。\n\n$n, m$ 不超过 $1000$ ，每一种特产的数量不超过 $1000$。", "outputFormat": "输出一行，不同分配方案的总数。\n\n由于输出结果可能非常巨大，你只需要输出最终结果\n$\\bmod\\ {10^9+7}$ 的数值就可以了。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2011] Distributing Local Specialties", "background": "", "description": "JYY led a team to several $\\text{ACM/ICPC}$ contests and brought back many local specialties, which he wants to distribute to the students in the lab.\n\nJYY wants to know: if these specialties are distributed to $n$ students, how many different distribution methods are there in total? Of course, JYY does not want any student to feel upset because they did not get any specialties, so each student must receive at least one specialty.\n\nFor example, JYY brought $2$ bags of twisted dough sticks and $1$ bag of buns, and distributes them to students $A$ and $B$. Then there are $4$ different distribution methods:\n\n$A$: twisted dough stick, $B$: twisted dough stick, bun\n\n$A$: twisted dough stick, twisted dough stick, $B$: bun\n\n$A$: bun, $B$: twisted dough stick, twisted dough stick\n\n$A$: twisted dough stick, bun, $B$: twisted dough stick", "inputFormat": "Input testdata:\n\nThe first line contains the number of students $n$ and the number of specialty types $m$.\n\nThe second line contains $m$ integers, where each integer represents the quantity of one type of specialty.\n\n$n, m$ do not exceed $1000$, and the quantity of each specialty type does not exceed $1000$.", "outputFormat": "Output one line: the total number of different distribution plans.\n\nSince the result may be extremely large, you only need to output the value of the final result $\\bmod\\ {10^9+7}$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2011] 分特产", "background": null, "description": "JYY 带队参加了若干场 $\\text{ACM/ICPC}$ 比赛，带回了许多土特产，要分给实验室的同学们。\n\nJYY 想知道，把这些特产分给 $n$ 个同学，一共有多少种不同的分法？当然，JYY 不希望任何一个同学因为没有拿到特产而感到失落，所以每个同学都必须至少分得一个特产。\n\n例如，JYY 带来了 $2$ 袋麻花和 $1$ 袋包子，分给 $A$ 和 $B$ 两位同学，那么共有 $4$ 种不同的\n分配方法：\n\n $A$：麻花， $B$：麻花、包子\n\n $A$：麻花、麻花， $B$：包子\n\n $A$：包子， $B$：麻花、麻花\n\n $A$：麻花、包子， $B$：麻花", "inputFormat": "输入数据：\n\n第一行是同学的数量 $n$ 和特产的种类 $m$。\n\n第二行包含 $m$ 个整数，表示每一种特产的数量。\n\n$n, m$ 不超过 $1000$ ，每一种特产的数量不超过 $1000$。", "outputFormat": "输出一行，不同分配方案的总数。\n\n由于输出结果可能非常巨大，你只需要输出最终结果\n$\\bmod\\ {10^9+7}$ 的数值就可以了。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P5506", "type": "P", "difficulty": 4, "samples": [["4 7\n-1 -1 0 2 1 1 0 0 0 5 0 RAAAAAA\n51 0 1 1 4 0 0 1 0 5 0 UMMMMMM\n-2 0 0 2 0 0 0 0 0 5 1 FFFNNNN\n53 0 0 2 4 0 0 0 0 5 1 FFFNNNN\n", "6 0 0 1\n45 0 0 0\n5 0 0 4\n46 0 0 7\n"], ["7 1\n0 0 0 0 0 2 0 0 0 1 0 A\n1 0 0 0 0 4 0 0 0 3 0 A\n1 0 0 0 0 1 1 1 1 4 0 N\n1 0 -1 0 0 0 0 0 0 2 0 N\n0 1 0 0 0 0 0 3 0 3 0 M\n0 1 -1 0 0 0 0 0 1 3 0 N\n0 1 -1 0 0 0 0 0 2 3 0 N", "0 0 -1 1\n1 0 -1 3\n1 0 -1 4\n1 0 -2 2\n0 1 -1 3\n0 1 -2 1\n0 1 -2 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "封锁", "background": "Steve 带领队伍准备去 M 星消灭黑暗势力，即将降落时被 M 星上空的无人机拦截了。", "description": "为了突破封锁，成功降落， Steve 使用了电磁干扰仪，使无人机开始自相残杀。\n\n然而，情况很快就变得混乱，无法了解当前的情况。\n\n幸好 Steve 的部队已经记录了开始混战前的状况，并设法获得了无人机执行操作的顺序。\n\n每架无人机有 $5$ 项属性 $atk,def,mat,mdf,fix$ ，当前生命值 $hp$ ，当前坐标 $(x,y,z)$ ，当前水平朝向 $f$( 范围 0-7) 和竖直朝向 $h$( 范围 0-4) 。\n\n每一时刻，所有存活的无人机会**先**向正前方移动一格。\n\n随后，存活的无人机会**按编号从小到大**依次执行下列操作之一：\n\n无操作 (N)\n\n上下转向 (U/D) ：改变 $h$ 的值，上为增加，下为减少，如果超过了范围就是无效操作，忽略。\n\n左右转向 (L/R) ：改变 $f$ 的值，左为增加，右为减少，循环（分别对应从上面看的逆时针，顺时针）。\n\n例如：当 $h=4$ 时操作 U 无效，当 $f=0$ 时操作 R 会使\n $f$ 变为 $7$ 。\n\n修复 (F) ：使 $hp$ 增加 $fix$ 点。\n\n子弹 (A) ：使位于这架无人机正前方**最近**的飞机受到伤害，伤害的值为当前飞机的 $atk$ 值与目标的 $def$ 值之差（差为负则不会造成伤害），**如果多架飞机处于同一位置，那么只有编号最小的飞机会受到伤害**。\n\n激光 (M) ：使位于这架无人机正前方的**所有**飞机受到伤害，伤害的值为当前飞机的 $mat$ 值与目标的 $mdf$ 值之差（差为负则不会造成伤害）。\n\n注意：与开火飞机重叠的飞机不会受到伤害\n\n如果受到伤害后， $hp\\leq 0$ ，那么这架飞机就会坠毁。\n\n对于 $f$ 和 $h$ ，它的“正前方”是这样定义的：\n\n首先，根据 $f$ 确定 $x,y$ 方向，如下图。\n\n![](https://cdn.luogu.com.cn/upload/pic/64952.png)\n\n随后，根据 $h$ 进一步确定方向。\n\n对于 $h=0$ 或 $h=4$ ，正前方是正下或正上（ $x,y$ 不变， $z$ 变化）。\n\n对于 $h=1$ 或 $h=3$ ，在上面方向的基础上再向下/上移动一格。\n\n对于 $h=2$ ，正前方为水平方向（ $x,y$ 如上所述， $z$ 不变）。\n\n（有人反馈看不懂方向，这里直接给出 $f,h$ 和正前方\n $(x,y,z)$ 的对应表）\n\n![](https://cdn.luogu.com.cn/upload/pic/71703.png)\n\n现在， Steve 告诉你了所有飞机初始的状态和之后执行的操作。\n\n你需要告诉他，经过 $t$ 个时刻的混战之后，每架飞机的位置和生命值。", "inputFormat": "第一行两个整数 $n,t$ ，表示飞机数和时刻数。\n\n接下来 $n$ 行，每行 $11$ 个整数和一个长为 $t$ 字符串，按编号顺序描述无人机。\n\n这 $11$ 个整数分别为 $x,y,z,h,f,atk,def,mat,mdf,hp,fix$ ，其中 $hp$ 为初始生命值。\n\n字符串的每一个字符均为大写字母，依次表示这 $t$ 个时刻的操作。", "outputFormat": "$n$ 行，每行 $4$ 个整数 $x,y,z,hp$ 。\n\n如果这架飞机没有坠毁，则输出坐标和最终的生命值。\n\n否则，输出坠毁前的坐标， $hp$ 输出 $0$ 。", "hint": "两架飞机移动并改变朝向后互相面对，随后它们分别向对面疯狂开火，最终 1 号飞机率先击落 2 号飞机，因为 2 号飞机已经坠毁，所以 1 号飞机不会被击落。\n\n而它们身后分别跟着两架飞机， 2 号飞机使用激光，所以 3 号飞机也会受到伤害， 1 号飞机使用子弹，所以 4 号飞机不会受到伤害，直到 2 号飞机坠毁后， 1 号飞机发出最后一颗子弹，对 4 号飞机造成了一点伤害。同时两架飞机前三次操作分别进行了三次修复， $hp$ 增加了 $3$ 。\n\n测试时，每个 Subtask 包括 3 个测试点，全部通过才能得到该 Subtask 的分数\n\n------------\n\n样例 2 解释：<https://www.luogu.com.cn/discuss/582252>\n\n---\n\n数据范围：\n\n$1\\leq n,t\\leq 100$\n\n输入的所有数字大小在合理范围内，且绝对值均不大于 $100$ 。\n\n其中 $atk,def,mat,mdf,fix$ 为非负整数。\n\n$hp$ 为正整数。\n\n$x,y,z$ 为整数。\n\n$h$ 为 $0,1,2,3,4$ 中的一个。\n\n$f$ 为 $0,1,2,3,4,5,6,7$ 中的一个。\n\n字符串仅包含 $NFLRUDAM$ $8$ 种字符。\n\n另外，对于前 3 个 subtask ，保证任何时刻飞机的 z 坐标为\n $0$ 。\n\nSubtask | 分值 | 出现的操作\n:-: | :-: | :-: \n1| 12| N\n2| 14| NF\n3| 15| NFLR\n4| 17| NFLRUD\n5| 19| NFLRUDM\n6| 23| NFLRUDMA", "locale": "zh-CN", "translations": {"en": {"title": "Blockade.", "background": "Steve led his team to Planet M to wipe out the dark forces. Just as they were about to land, they were intercepted by drones in the sky above Planet M.", "description": "To break through the blockade and land successfully, Steve used an electromagnetic jammer, causing the drones to start killing each other.\n\nHowever, the situation quickly became chaotic, and it was impossible to understand what was happening.\n\nFortunately, Steve’s troops recorded the situation before the brawl started, and managed to obtain the order of operations executed by the drones.\n\nEach drone has $5$ attributes: $atk,def,mat,mdf,fix$, its current health $hp$, its current coordinates $(x,y,z)$, its current horizontal facing $f$ (range $0$–$7$), and its vertical facing $h$ (range $0$–$4$).\n\nAt each moment, all surviving drones will **first** move one cell straight forward.\n\nThen, the surviving drones will **in increasing order of their IDs** execute exactly one of the following operations:\n\n- No operation (N).\n\n- Turn up/down (U/D): change the value of $h$. Up means increase, down means decrease. If it goes out of range, the operation is invalid and should be ignored.\n\n- Turn left/right (L/R): change the value of $f$. Left means increase, right means decrease, with wrap-around (corresponding to counterclockwise/clockwise when viewed from above).\n\nFor example, when $h=4$, operation U is invalid. When $f=0$, operation R will change $f$ to $7$.\n\n- Repair (F): increase $hp$ by $fix$.\n\n- Bullet (A): deal damage to the **nearest** drone located straight ahead of this drone. The damage value is the difference between the attacker’s current $atk$ and the target’s $def$ (if the difference is negative, it deals no damage). **If multiple drones are at the same position, only the one with the smallest ID takes damage**.\n\n- Laser (M): deal damage to **all** drones straight ahead of this drone. The damage value is the difference between the attacker’s current $mat$ and the target’s $mdf$ (if the difference is negative, it deals no damage).\n\nNote: drones overlapping with the firing drone will not take damage.\n\nIf after taking damage, $hp\\leq 0$, then the drone crashes.\n\nFor $f$ and $h$, “straight ahead” is defined as follows:\n\nFirst, determine the $x,y$ direction based on $f$, as shown in the figure below.\n\n![](https://cdn.luogu.com.cn/upload/pic/64952.png)\n\nThen, further determine the direction based on $h$.\n\n- For $h=0$ or $h=4$, straight ahead is straight down or straight up ($x,y$ unchanged, $z$ changes).\n\n- For $h=1$ or $h=3$, based on the horizontal direction above, also move one cell down/up.\n\n- For $h=2$, straight ahead is the horizontal direction ($x,y$ as above, $z$ unchanged).\n\n(Some people reported that the direction is hard to understand. Here is the direct correspondence table of $f,h$ and the straight-ahead $(x,y,z)$.)\n\n![](https://cdn.luogu.com.cn/upload/pic/71703.png)\n\nNow, Steve has told you the initial state of all drones and the operations they execute afterward.\n\nYou need to tell him, after $t$ moments of fighting, the position and health of each drone.", "inputFormat": "The first line contains two integers $n,t$, representing the number of drones and the number of moments.\n\nThe next $n$ lines each contain $11$ integers and a string of length $t$, describing the drones in order of their IDs.\n\nThese $11$ integers are $x,y,z,h,f,atk,def,mat,mdf,hp,fix$, where $hp$ is the initial health.\n\nEach character in the string is an uppercase letter, representing the operation at each of the $t$ moments in order.", "outputFormat": "Output $n$ lines, each with $4$ integers $x,y,z,hp$.\n\nIf the drone has not crashed, output its coordinates and final health.\n\nOtherwise, output its coordinates right before crashing, and output $0$ for $hp$.", "hint": "After two drones move and change their facing directions, they end up facing each other. Then they both fire crazily at each other. In the end, Drone $1$ shoots down Drone $2$ first. Since Drone $2$ has already crashed, Drone $1$ will not be shot down.\n\nBehind them there are two drones following respectively. Drone $2$ uses a laser, so Drone $3$ will also take damage. Drone $1$ uses bullets, so Drone $4$ will not take damage. This continues until Drone $2$ crashes, after which Drone $1$ fires one last bullet and deals $1$ point of damage to Drone $4$. At the same time, in their first three operations, both drones performed three repairs, so $hp$ increases by $3$.\n\nDuring judging, each Subtask includes 3 test points. You can get the score of that Subtask only if you pass all of them.\n\n------------\n\nSample 2 explanation: <https://www.luogu.com.cn/discuss/582252>\n\n---\n\nConstraints:\n\n$1\\leq n,t\\leq 100$\n\nAll input numbers are within reasonable ranges, and their absolute values are all at most $100$.\n\nAmong them, $atk,def,mat,mdf,fix$ are non-negative integers.\n\n$hp$ is a positive integer.\n\n$x,y,z$ are integers.\n\n$h$ is one of $0,1,2,3,4$.\n\n$f$ is one of $0,1,2,3,4,5,6,7$.\n\nThe string contains only $8$ kinds of characters: $NFLRUDAM$.\n\nIn addition, for the first 3 subtasks, it is guaranteed that at any moment, the drones’ $z$ coordinates are $0$.\n\nSubtask | Score | Operations Appearing\n:-: | :-: | :-:\n1| 12| N\n2| 14| NF\n3| 15| NFLR\n4| 17| NFLRUD\n5| 19| NFLRUDM\n6| 23| NFLRUDMA\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "封锁", "background": "Steve 带领队伍准备去 M 星消灭黑暗势力，即将降落时被 M 星上空的无人机拦截了。", "description": "为了突破封锁，成功降落， Steve 使用了电磁干扰仪，使无人机开始自相残杀。\n\n然而，情况很快就变得混乱，无法了解当前的情况。\n\n幸好 Steve 的部队已经记录了开始混战前的状况，并设法获得了无人机执行操作的顺序。\n\n每架无人机有 $5$ 项属性 $atk,def,mat,mdf,fix$ ，当前生命值 $hp$ ，当前坐标 $(x,y,z)$ ，当前水平朝向 $f$( 范围 0-7) 和竖直朝向 $h$( 范围 0-4) 。\n\n每一时刻，所有存活的无人机会**先**向正前方移动一格。\n\n随后，存活的无人机会**按编号从小到大**依次执行下列操作之一：\n\n无操作 (N)\n\n上下转向 (U/D) ：改变 $h$ 的值，上为增加，下为减少，如果超过了范围就是无效操作，忽略。\n\n左右转向 (L/R) ：改变 $f$ 的值，左为增加，右为减少，循环（分别对应从上面看的逆时针，顺时针）。\n\n例如：当 $h=4$ 时操作 U 无效，当 $f=0$ 时操作 R 会使\n $f$ 变为 $7$ 。\n\n修复 (F) ：使 $hp$ 增加 $fix$ 点。\n\n子弹 (A) ：使位于这架无人机正前方**最近**的飞机受到伤害，伤害的值为当前飞机的 $atk$ 值与目标的 $def$ 值之差（差为负则不会造成伤害），**如果多架飞机处于同一位置，那么只有编号最小的飞机会受到伤害**。\n\n激光 (M) ：使位于这架无人机正前方的**所有**飞机受到伤害，伤害的值为当前飞机的 $mat$ 值与目标的 $mdf$ 值之差（差为负则不会造成伤害）。\n\n注意：与开火飞机重叠的飞机不会受到伤害\n\n如果受到伤害后， $hp\\leq 0$ ，那么这架飞机就会坠毁。\n\n对于 $f$ 和 $h$ ，它的“正前方”是这样定义的：\n\n首先，根据 $f$ 确定 $x,y$ 方向，如下图。\n\n![](https://cdn.luogu.com.cn/upload/pic/64952.png)\n\n随后，根据 $h$ 进一步确定方向。\n\n对于 $h=0$ 或 $h=4$ ，正前方是正下或正上（ $x,y$ 不变， $z$ 变化）。\n\n对于 $h=1$ 或 $h=3$ ，在上面方向的基础上再向下/上移动一格。\n\n对于 $h=2$ ，正前方为水平方向（ $x,y$ 如上所述， $z$ 不变）。\n\n（有人反馈看不懂方向，这里直接给出 $f,h$ 和正前方\n $(x,y,z)$ 的对应表）\n\n![](https://cdn.luogu.com.cn/upload/pic/71703.png)\n\n现在， Steve 告诉你了所有飞机初始的状态和之后执行的操作。\n\n你需要告诉他，经过 $t$ 个时刻的混战之后，每架飞机的位置和生命值。", "inputFormat": "第一行两个整数 $n,t$ ，表示飞机数和时刻数。\n\n接下来 $n$ 行，每行 $11$ 个整数和一个长为 $t$ 字符串，按编号顺序描述无人机。\n\n这 $11$ 个整数分别为 $x,y,z,h,f,atk,def,mat,mdf,hp,fix$ ，其中 $hp$ 为初始生命值。\n\n字符串的每一个字符均为大写字母，依次表示这 $t$ 个时刻的操作。", "outputFormat": "$n$ 行，每行 $4$ 个整数 $x,y,z,hp$ 。\n\n如果这架飞机没有坠毁，则输出坐标和最终的生命值。\n\n否则，输出坠毁前的坐标， $hp$ 输出 $0$ 。", "hint": "两架飞机移动并改变朝向后互相面对，随后它们分别向对面疯狂开火，最终 1 号飞机率先击落 2 号飞机，因为 2 号飞机已经坠毁，所以 1 号飞机不会被击落。\n\n而它们身后分别跟着两架飞机， 2 号飞机使用激光，所以 3 号飞机也会受到伤害， 1 号飞机使用子弹，所以 4 号飞机不会受到伤害，直到 2 号飞机坠毁后， 1 号飞机发出最后一颗子弹，对 4 号飞机造成了一点伤害。同时两架飞机前三次操作分别进行了三次修复， $hp$ 增加了 $3$ 。\n\n测试时，每个 Subtask 包括 3 个测试点，全部通过才能得到该 Subtask 的分数\n\n------------\n\n样例 2 解释：<https://www.luogu.com.cn/discuss/582252>\n\n---\n\n数据范围：\n\n$1\\leq n,t\\leq 100$\n\n输入的所有数字大小在合理范围内，且绝对值均不大于 $100$ 。\n\n其中 $atk,def,mat,mdf,fix$ 为非负整数。\n\n$hp$ 为正整数。\n\n$x,y,z$ 为整数。\n\n$h$ 为 $0,1,2,3,4$ 中的一个。\n\n$f$ 为 $0,1,2,3,4,5,6,7$ 中的一个。\n\n字符串仅包含 $NFLRUDAM$ $8$ 种字符。\n\n另外，对于前 3 个 subtask ，保证任何时刻飞机的 z 坐标为\n $0$ 。\n\nSubtask | 分值 | 出现的操作\n:-: | :-: | :-: \n1| 12| N\n2| 14| NF\n3| 15| NFLR\n4| 17| NFLRUD\n5| 19| NFLRUDM\n6| 23| NFLRUDMA", "locale": "zh-CN"}}}
{"pid": "P5507", "type": "P", "difficulty": 5, "samples": [["3 3 7 2 6\n3 1 4 5 3\n3 1 2 6 4\n3 1 10 3 5\n3 2 8 3 6\n3 7 9 2 1\n1 1 2 3 4\n1 3 11 10 12\n1 8 6 7 4\n1 9 9 8 8\n1 12 10 12 12\n1 7 8 9 10\n", "6\n1 2 3 4 5 6\n"], ["3 3 7 2 6\n3 1 4 5 3\n3 1 2 6 4\n3 1 10 3 5\n3 2 8 3 6\n3 7 9 2 1\n1 1 2 3 4\n1 3 11 10 12\n1 8 6 7 4\n1 9 9 8 8\n1 12 10 12 12\n1 7 8 9 10\n", "6\n1 1 2 3 4 5\n"], ["4 2 2 2 2\n4 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n", "1\n1\n"], ["4 9 3 4 5 \n1 9 8 12 11 \n4 7 5 6 12 \n3 2 2 11 2 \n3 6 8 2 12 \n4 8 4 2 11 \n2 12 9 5 3 \n4 1 1 11 1 \n1 1 7 4 1 \n4 11 6 12 8 \n2 6 3 7 6 \n4 3 9 7 10 \n", "10\n11 4 6 10 7 7 5 9 9 9 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "Special Judge", "O2优化", "广度优先搜索 BFS", "启发式搜索"], "title": "机关", "background": "Steve 成功降落后，在 M 星上发现了一扇大门，但是这扇大门是锁着的。", "description": "这扇门上有一个机关，上面一共有 $12$ 个旋钮，每个旋钮有 $4$ 个状态，将旋钮的状态用数字 $1$ 到 $4$ 表示。\n\n每个旋钮只能向一个方向旋转（状态：$1\\rightarrow2\\rightarrow3\\rightarrow4\\rightarrow1$），在旋转时，会引起另一个旋钮也旋转一次（方向相同，不会引起连锁反应），同一旋钮在不同状态下，可能会引起不同的旋钮旋转（在输入中给出）。\n\n当所有旋钮都旋转到状态 $1$ 时，机关就打开了。\n\n由于旋钮年久失修，旋转一次很困难，而且时间很紧迫，因此 Steve 希望用最少的旋转次数打开机关。\n\n这个任务就交给你了。", "inputFormat": "$12$ 行，每行 $5$ 个整数，描述机关的状态。\n\n第 $i$ 行第一个整数 $s_i$ 表示第 $i$ 个旋钮的初始状态是 $s_i$。\n\n接下来 $4$ 个整数 $a_{i,j},j=1,2,3,4$ 表示这个旋钮在状态 $j$ 时旋转，会引起第 $a_{i,j}$ 个旋钮旋转到下一个状态。", "outputFormat": "第一行一个整数 $n$，表示最少的步数。\n\n第二行 $n$ 个整数，表示依次旋转的旋钮编号。\n\n数据保证有解。", "hint": "样例 $1$ 和 $2$ 输入相同，两个输出都可以通过。\n\n样例 $4$ 解释：\n```\n414334 241424\n旋转11到状态3，引起3旋转到状态1\n411334 241434\n旋转4到状态4，引起11旋转到状态4\n411434 241444\n旋转6到状态1，引起11旋转到状态1\n411431 241414\n旋转10到状态1，引起8旋转到状态1\n411431 211114\n旋转7到状态3，引起9旋转到状态2\n411431 312114\n旋转7到状态4，引起5旋转到状态4\n411441 412114\n旋转5到状态1，引起12旋转到状态1\n411411 412111\n旋转9到状态3，引起7旋转到状态1\n411411 113111\n旋转9到状态4，引起4旋转到状态1\n411111 114111\n旋转9到状态1，引起1旋转到状态1\n111111 111111\n```\n\n数据保证存在打开机关的方式。\n\n每个测试点 $10$ 分。\n\n只要你输出格式正确，输出了正确的步数，并给出了任意一种正确方案，就能得到该测试点的得分。\n\n否则，该测试点不得分。\n\n数据范围：\n\n测试点 | 所需步数\n:-: | :-:\n1 | 4|\n2|6|\n3|8|\n4|9|\n5|10|\n6|11|\n7|12|\n8|13|\n9|15|\n10|17|", "locale": "zh-CN", "translations": {"en": {"title": "Mechanism", "background": "After Steve landed successfully, he found a gate on Planet M, but the gate was locked.", "description": "There is a mechanism on the gate. It has a total of $12$ knobs, and each knob has $4$ states. The states of a knob are represented by the numbers $1$ to $4$.\n\nEach knob can only be rotated in one direction (states: $1\\rightarrow2\\rightarrow3\\rightarrow4\\rightarrow1$). When it is rotated, it will cause another knob to rotate once as well (in the same direction, and it will not cause a chain reaction). The same knob, when in different states, may cause different knobs to rotate (given in the input).\n\nWhen all knobs are rotated to state $1$, the mechanism opens.\n\nBecause the knobs have not been maintained for a long time, rotating once is difficult, and time is tight. Therefore, Steve wants to open the mechanism using the minimum number of rotations.\n\nThis task is left to you.", "inputFormat": "There are $12$ lines, each containing $5$ integers, describing the state of the mechanism.\n\nOn line $i$, the first integer $s_i$ indicates that the initial state of the $i$-th knob is $s_i$.\n\nThe next $4$ integers $a_{i,j}, j=1,2,3,4$ indicate that when this knob is in state $j$ and is rotated, it will cause the $a_{i,j}$-th knob to rotate to the next state.", "outputFormat": "The first line contains an integer $n$, indicating the minimum number of steps.\n\nThe second line contains $n$ integers, indicating the indices of the knobs rotated in order.\n\nThe testdata guarantees that a solution exists.", "hint": "Samples $1$ and $2$ have the same input, and both outputs are accepted.\n\nExplanation for sample $4$:\n```\n414334 241424\nRotate knob 11 to state 3, causing knob 3 to rotate to state 1.\n411334 241434\nRotate knob 4 to state 4, causing knob 11 to rotate to state 4.\n411434 241444\nRotate knob 6 to state 1, causing knob 11 to rotate to state 1.\n411431 241414\nRotate knob 10 to state 1, causing knob 8 to rotate to state 1.\n411431 211114\nRotate knob 7 to state 3, causing knob 9 to rotate to state 2.\n411431 312114\nRotate knob 7 to state 4, causing knob 5 to rotate to state 4.\n411441 412114\nRotate knob 5 to state 1, causing knob 12 to rotate to state 1.\n411411 412111\nRotate knob 9 to state 3, causing knob 7 to rotate to state 1.\n411411 113111\nRotate knob 9 to state 4, causing knob 4 to rotate to state 1.\n411111 114111\nRotate knob 9 to state 1, causing knob 1 to rotate to state 1.\n111111 111111\n```\n\nThe testdata guarantees that there is a way to open the mechanism.\n\nEach test point is worth $10$ points.\n\nAs long as your output format is correct, you output the correct number of steps, and you provide any correct solution, you will get the score for that test point.\n\nOtherwise, you will get $0$ points for that test point.\n\nConstraints:\n\nTest point | Required steps\n:-: | :-:\n1 | 4\n2 | 6\n3 | 8\n4 | 9\n5 | 10\n6 | 11\n7 | 12\n8 | 13\n9 | 15\n10 | 17\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "机关", "background": "Steve 成功降落后，在 M 星上发现了一扇大门，但是这扇大门是锁着的。", "description": "这扇门上有一个机关，上面一共有 $12$ 个旋钮，每个旋钮有 $4$ 个状态，将旋钮的状态用数字 $1$ 到 $4$ 表示。\n\n每个旋钮只能向一个方向旋转（状态：$1\\rightarrow2\\rightarrow3\\rightarrow4\\rightarrow1$），在旋转时，会引起另一个旋钮也旋转一次（方向相同，不会引起连锁反应），同一旋钮在不同状态下，可能会引起不同的旋钮旋转（在输入中给出）。\n\n当所有旋钮都旋转到状态 $1$ 时，机关就打开了。\n\n由于旋钮年久失修，旋转一次很困难，而且时间很紧迫，因此 Steve 希望用最少的旋转次数打开机关。\n\n这个任务就交给你了。", "inputFormat": "$12$ 行，每行 $5$ 个整数，描述机关的状态。\n\n第 $i$ 行第一个整数 $s_i$ 表示第 $i$ 个旋钮的初始状态是 $s_i$。\n\n接下来 $4$ 个整数 $a_{i,j},j=1,2,3,4$ 表示这个旋钮在状态 $j$ 时旋转，会引起第 $a_{i,j}$ 个旋钮旋转到下一个状态。", "outputFormat": "第一行一个整数 $n$，表示最少的步数。\n\n第二行 $n$ 个整数，表示依次旋转的旋钮编号。\n\n数据保证有解。", "hint": "样例 $1$ 和 $2$ 输入相同，两个输出都可以通过。\n\n样例 $4$ 解释：\n```\n414334 241424\n旋转11到状态3，引起3旋转到状态1\n411334 241434\n旋转4到状态4，引起11旋转到状态4\n411434 241444\n旋转6到状态1，引起11旋转到状态1\n411431 241414\n旋转10到状态1，引起8旋转到状态1\n411431 211114\n旋转7到状态3，引起9旋转到状态2\n411431 312114\n旋转7到状态4，引起5旋转到状态4\n411441 412114\n旋转5到状态1，引起12旋转到状态1\n411411 412111\n旋转9到状态3，引起7旋转到状态1\n411411 113111\n旋转9到状态4，引起4旋转到状态1\n411111 114111\n旋转9到状态1，引起1旋转到状态1\n111111 111111\n```\n\n数据保证存在打开机关的方式。\n\n每个测试点 $10$ 分。\n\n只要你输出格式正确，输出了正确的步数，并给出了任意一种正确方案，就能得到该测试点的得分。\n\n否则，该测试点不得分。\n\n数据范围：\n\n测试点 | 所需步数\n:-: | :-:\n1 | 4|\n2|6|\n3|8|\n4|9|\n5|10|\n6|11|\n7|12|\n8|13|\n9|15|\n10|17|", "locale": "zh-CN"}}}
{"pid": "P5508", "type": "P", "difficulty": 6, "samples": [["6 2\n0 1 2 0 0 0\n1 1 2 3 5\n4 5 6 6 2\n", "9\n3\n1 2 6"], ["6 2\n0 1 2 0 0 0\n1 1 2 3 5\n4 5 6 6 2\n", "9\n4\n1 3 4 6"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["图论", "线段树", "Special Judge", "O2优化"], "title": "寻宝", "background": "Steve成功打开了机关，发现机关后是一个巨大的迷宫", "description": "这个迷宫一共有$n$个洞穴，洞穴之间有很多单向隧道，很难数清\n\n但经过分析，发现：\n\n这些隧道可以分为$m$组，对于每一组，编号在区间$[s_l,s_r]$内的每一个洞穴，与编号在区间$[t_l,t_r]$内的每一个洞穴之间，都有一条隧道，每组内共有$(s_r-s_l+1)\\cdot (t_r-t_l+1)$条隧道，通过同组内每一条隧道的时间都相等\n\n为了进一步节约时间，Steve可以挖掘新的隧道\n\n但是，每个洞穴的性质不同，导致挖掘隧道的难度不同，有些洞穴甚至无法挖掘隧道\n\n具体来说，第$i$个洞穴有一个值$v_i$，$v_i=0$表示无法挖掘隧道，对于其它值，表示从第$i$个洞穴开始，挖掘一条到第$j$个洞穴的隧道，并到达第$j$个隧道，需要花费$|i-j|*v_i$时间\n\nSteve希望在最短时间内到达第$n$个洞穴，决定不限制挖掘隧道的数量\n\n现在，你需要告诉Steve最少需要用的时间\n\n如果可能，你应帮助Steve求出一种最优方案", "inputFormat": "第一行两个整数$n,m$\n\n接下来一行$n$个整数$v_1,v_2,...,v_n$\n\n接下来$m$行，每行描述一组隧道\n\n每行$5$个整数$s_l,s_r,t_l,t_r,w$，其中$w$表示通过时间", "outputFormat": "如果无解，则只需输出一行一个整数\"-1\"(不含引号)\n\n如果有解，则按下列格式输出：\n\n第一行一个整数$t$，表示最少花费的时间\n\n如果你无法给出方案，在第二行输出一个整数$0$\n\n如果你可以给出方案，在第二行输出一个整数$c$，在第三行输出$c$个整数，依次表示一种最优方案经过的洞穴编号\n\n你并不需要告诉Steve经过的隧道是否为挖掘出来的，或者属于哪一组", "hint": "样例1：1号到2号走第一组隧道，2号到6号挖掘隧道，用时$1*(6-2)=4$\n\n样例2：1号到3号走第一组隧道，3号到4号挖掘隧道，用时$2*(4-3)=2$，4号到6号走第二组隧道\n\n每个Subtask包括两个测试点，取较低分\n\n对于每个测试点：\n\n如果输出格式错误，那么，该测试点得0分\n\n如果你没有给出正确的用时，那么，该测试点得0分\n\n如果你给出正确的用时，但没有给出方案，那么你可以得到该测试点一半的分数（每个测试点得分向下取整）\n\n如果你给出了错误方案，那么你可能可以得到该测试点一半的分数，或者得0分\n\n如果你给出了正确的方案，那么你可以得到该测试点全部的分数\n\n上面两个输出都可以得到满分，还有一种方案是$1 2 4 6$\n\n如果你输出：\n\n```\n9\n0\n```\n那么你可以得到该测试点一半的分数\n\n数据范围：\n\n$1\\le w,v_i \\le 10^9$\n\nSubtask | 分值| n | m| 特殊性质\n:-: | :-: | :-: | :-: | :-:\n1 | 5| 100| 100| | \n2| 10| 3000| 3000| |\n3| 11| 50000| 50000| 2,3|\n4| 10| 50000| 50000| 1|\n5| 12| 50000| 0| |\n6| 12| 50000| 1| |\n7| 13| 50000| 20|3 |\n8| 13| 50000| 20| |\n9| 14| 50000| 50000| |\n\n特殊性质1：所有$v_i=0$\n\n特殊性质2：所有$v_i \\in \\{0,k\\}$，$k$为常数\n\n特殊性质3：所有$s_l=s_r,t_l=t_r$\n\n保证存在到达$n$号洞穴的方案\n\n关于输出错误方案：\n\n如果输出的$2\\leq c\\leq n$，经过的点以$1$开头，以$n$结尾，且中间的点都是在$(1,n)$的整数，则这组解可能是一组最优解，可以得到一半分数\n\n否则，得0分\n\n~~不用担心spj会TLE/MLE~~", "locale": "zh-CN", "translations": {"en": {"title": "Treasure Hunt.", "background": "Steve successfully opened the mechanism, and found that behind it was a huge maze.", "description": "This maze has a total of $n$ caves. There are many one-way tunnels between the caves, so many that it is hard to count them.\n\nHowever, after analysis, it is found that:\n\nThese tunnels can be divided into $m$ groups. For each group, for every cave with an index in the interval $[s_l,s_r]$, and every cave with an index in the interval $[t_l,t_r]$, there is a tunnel between them. Each group contains a total of $(s_r-s_l+1)\\cdot (t_r-t_l+1)$ tunnels, and the time to pass through any tunnel in the same group is the same.\n\nTo further save time, Steve can dig new tunnels.\n\nHowever, each cave has different properties, which makes digging tunnels of different difficulty. Some caves cannot even dig tunnels.\n\nSpecifically, the $i$-th cave has a value $v_i$. $v_i=0$ means tunnels cannot be dug from it. For other values, it means that starting from cave $i$, digging a tunnel to cave $j$ and arriving at cave $j$ costs $|i-j|*v_i$ time.\n\nSteve wants to reach cave $n$ in the shortest time, and decides not to limit the number of tunnels he digs.\n\nNow, you need to tell Steve the minimum time required.\n\nIf possible, you should help Steve find an optimal plan.", "inputFormat": "The first line contains two integers $n,m$.\n\nThe next line contains $n$ integers $v_1,v_2,...,v_n$.\n\nThe next $m$ lines each describe a group of tunnels.\n\nEach line contains $5$ integers $s_l,s_r,t_l,t_r,w$, where $w$ is the travel time.", "outputFormat": "If there is no solution, output only one line with one integer $-1$.\n\nIf there is a solution, output in the following format:\n\nThe first line contains an integer $t$, which is the minimum time spent.\n\nIf you cannot provide a plan, output an integer $0$ on the second line.\n\nIf you can provide a plan, output an integer $c$ on the second line, and output $c$ integers on the third line, representing (in order) the cave indices visited by one optimal plan.\n\nYou do not need to tell Steve whether each tunnel used is dug, or which group it belongs to.", "hint": "Sample 1: From cave $1$ to cave $2$ use the first group tunnel, then from cave $2$ to cave $6$ dig a tunnel, costing $1*(6-2)=4$ time.\n\nSample 2: From cave $1$ to cave $3$ use the first group tunnel, then from cave $3$ to cave $4$ dig a tunnel, costing $2*(4-3)=2$, then from cave $4$ to cave $6$ use the second group tunnel.\n\nEach subtask includes two test points, and the lower score is taken.\n\nFor each test point:\n\nIf the output format is wrong, then this test point scores $0$.\n\nIf you do not output the correct time, then this test point scores $0$.\n\nIf you output the correct time but do not give a plan, then you can get half of the score of this test point (the score of each test point is rounded down).\n\nIf you give a wrong plan, then you may get half of the score of this test point, or get $0$.\n\nIf you give a correct plan, then you can get the full score of this test point.\n\nThe two outputs above can both get full score. Another plan is $1 2 4 6$.\n\nIf you output:\n\n```\n9\n0\n```\n\nthen you can get half of the score for this test point.\n\nConstraints:\n\n$1\\le w,v_i \\le 10^9$.\n\nSubtask | Score | n | m | Special Property\n:-: | :-: | :-: | :-: | :-:\n1 | 5 | 100 | 100 | |\n2 | 10 | 3000 | 3000 | |\n3 | 11 | 50000 | 50000 | 2,3 |\n4 | 10 | 50000 | 50000 | 1 |\n5 | 12 | 50000 | 0 | |\n6 | 12 | 50000 | 1 | |\n7 | 13 | 50000 | 20 | 3 |\n8 | 13 | 50000 | 20 | |\n9 | 14 | 50000 | 50000 | |\n\nSpecial Property 1: All $v_i=0$.\n\nSpecial Property 2: All $v_i \\in \\{0,k\\}$, where $k$ is a constant.\n\nSpecial Property 3: All $s_l=s_r,t_l=t_r$.\n\nIt is guaranteed that there exists a plan to reach cave $n$.\n\nAbout outputting a wrong plan:\n\nIf the output satisfies $2\\leq c\\leq n$, the visited nodes start with $1$ and end with $n$, and all intermediate nodes are integers in $(1,n)$, then this set of output may be an optimal solution, and you can get half of the score.\n\nOtherwise, you get $0$.\n\n~~Do not worry about the SPJ TLE/MLE.~~\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "寻宝", "background": "Steve成功打开了机关，发现机关后是一个巨大的迷宫", "description": "这个迷宫一共有$n$个洞穴，洞穴之间有很多单向隧道，很难数清\n\n但经过分析，发现：\n\n这些隧道可以分为$m$组，对于每一组，编号在区间$[s_l,s_r]$内的每一个洞穴，与编号在区间$[t_l,t_r]$内的每一个洞穴之间，都有一条隧道，每组内共有$(s_r-s_l+1)\\cdot (t_r-t_l+1)$条隧道，通过同组内每一条隧道的时间都相等\n\n为了进一步节约时间，Steve可以挖掘新的隧道\n\n但是，每个洞穴的性质不同，导致挖掘隧道的难度不同，有些洞穴甚至无法挖掘隧道\n\n具体来说，第$i$个洞穴有一个值$v_i$，$v_i=0$表示无法挖掘隧道，对于其它值，表示从第$i$个洞穴开始，挖掘一条到第$j$个洞穴的隧道，并到达第$j$个隧道，需要花费$|i-j|*v_i$时间\n\nSteve希望在最短时间内到达第$n$个洞穴，决定不限制挖掘隧道的数量\n\n现在，你需要告诉Steve最少需要用的时间\n\n如果可能，你应帮助Steve求出一种最优方案", "inputFormat": "第一行两个整数$n,m$\n\n接下来一行$n$个整数$v_1,v_2,...,v_n$\n\n接下来$m$行，每行描述一组隧道\n\n每行$5$个整数$s_l,s_r,t_l,t_r,w$，其中$w$表示通过时间", "outputFormat": "如果无解，则只需输出一行一个整数\"-1\"(不含引号)\n\n如果有解，则按下列格式输出：\n\n第一行一个整数$t$，表示最少花费的时间\n\n如果你无法给出方案，在第二行输出一个整数$0$\n\n如果你可以给出方案，在第二行输出一个整数$c$，在第三行输出$c$个整数，依次表示一种最优方案经过的洞穴编号\n\n你并不需要告诉Steve经过的隧道是否为挖掘出来的，或者属于哪一组", "hint": "样例1：1号到2号走第一组隧道，2号到6号挖掘隧道，用时$1*(6-2)=4$\n\n样例2：1号到3号走第一组隧道，3号到4号挖掘隧道，用时$2*(4-3)=2$，4号到6号走第二组隧道\n\n每个Subtask包括两个测试点，取较低分\n\n对于每个测试点：\n\n如果输出格式错误，那么，该测试点得0分\n\n如果你没有给出正确的用时，那么，该测试点得0分\n\n如果你给出正确的用时，但没有给出方案，那么你可以得到该测试点一半的分数（每个测试点得分向下取整）\n\n如果你给出了错误方案，那么你可能可以得到该测试点一半的分数，或者得0分\n\n如果你给出了正确的方案，那么你可以得到该测试点全部的分数\n\n上面两个输出都可以得到满分，还有一种方案是$1 2 4 6$\n\n如果你输出：\n\n```\n9\n0\n```\n那么你可以得到该测试点一半的分数\n\n数据范围：\n\n$1\\le w,v_i \\le 10^9$\n\nSubtask | 分值| n | m| 特殊性质\n:-: | :-: | :-: | :-: | :-:\n1 | 5| 100| 100| | \n2| 10| 3000| 3000| |\n3| 11| 50000| 50000| 2,3|\n4| 10| 50000| 50000| 1|\n5| 12| 50000| 0| |\n6| 12| 50000| 1| |\n7| 13| 50000| 20|3 |\n8| 13| 50000| 20| |\n9| 14| 50000| 50000| |\n\n特殊性质1：所有$v_i=0$\n\n特殊性质2：所有$v_i \\in \\{0,k\\}$，$k$为常数\n\n特殊性质3：所有$s_l=s_r,t_l=t_r$\n\n保证存在到达$n$号洞穴的方案\n\n关于输出错误方案：\n\n如果输出的$2\\leq c\\leq n$，经过的点以$1$开头，以$n$结尾，且中间的点都是在$(1,n)$的整数，则这组解可能是一组最优解，可以得到一半分数\n\n否则，得0分\n\n~~不用担心spj会TLE/MLE~~", "locale": "zh-CN"}}}
