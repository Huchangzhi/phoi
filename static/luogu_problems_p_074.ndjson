{"pid": "P2497", "type": "P", "difficulty": 6, "samples": [["10 33\n5 4 660\n10 2 2040\n11 6 3207\n14 5 2006\n18 3 6130\n19 9 3363\n22 1 1265\n25 8 2836\n27 10 7961\n29 7 9075", "3501.000"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2012", "线段树", "各省省选", "平衡树", "山东", "cdq 分治", "斜率优化"], "title": "[SDOI2012] 基站建设", "background": null, "description": "up 主家终于买电脑了，但是接下来有各种问题要处理。首要解决的问题就是网络问题。他要从移动公司开始，通过一些基站来传递网络到他家。\n\n为了简化问题，我们假设移动公司，所有的基站、up 主家位于同一条直线上，他们都位于这一条直线上的某一点 $x$，这些点**可能**会重合。每个基站发射和接收的范围都是一个切于地面的圆，发射的半径 $r$ 是固定的，接收半径 $r'$ 是可调的的。如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nh8yxjx5.png)\n\n一个基站 $i$ 如果想从另一个基站 $j$ 接收到信号（当且仅当 $x_j<x_i$），必须满足 $i$ 的接收范围与 $j$ 的发射范围**相切**，且需要付 $\\sqrt{r'_i}$ 的额外费用。启动每一个点 $i$ 都需要费用 $v_i$。\n\nup 主家如果能接收到某个基站的信号，只需要这个点的发射范围与 up 主家所在的竖线相切或相交即可，如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5t4v8687.png)\n\n当然费用越少就越好咯，于是 up 主想要请你帮他的忙。", "inputFormat": "第一行两个整数 $n, m$。表示基站个数（包括移动公司），up 主家的坐标。（保证大于等于所有基站的坐标）\n\n记下来 $n$ 行，每行三个整数 $x_i$，$r_i$，$v_i$，表示每个基站的坐标，发射范围以及费用。\n\n$x_i$ 是按照坐标从小到大输入的，移动公司位于最小的那个坐标。\n\n$r$ 为 $1\\dots n$ 的排列。", "outputFormat": "一个实数，保留小数点后三位。", "hint": "对于 $100\\%$ 的数据 $n\\le5\\times 10^5$，$x_i,m \\le 10^{12}$，$v_i \\le 10000$", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2012] Base Station Construction", "background": "", "description": "The uploader (UP 主) finally bought a computer, but now there are various issues to deal with. The first problem to solve is the network. He wants to start from the mobile company and relay the network to his home through some base stations.\n\nTo simplify the problem, we assume the mobile company, all base stations, and the UP's home lie on the same straight line, each located at some point $x$ on this line. These points may coincide. Each base station’s transmit and receive ranges are circles tangent to the ground. The transmit radius $r$ is fixed, while the receive radius $r'$ is adjustable. See the figure:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nh8yxjx5.png)\n\nIf base station $i$ wants to receive a signal from another base station $j$ (if and only if $x_j < x_i$), it must satisfy that $i$’s receive range is tangent to $j$’s transmit range, and an extra cost of $\\sqrt{r'_i}$ must be paid. Activating each point $i$ costs $v_i$.\n\nFor the UP’s home to receive a signal from some base station, it suffices that this station’s transmit range is tangent to or intersects the vertical line passing through the UP’s home, as shown below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5t4v8687.png)\n\nOf course, the smaller the total cost, the better, so the UP wants your help.", "inputFormat": "The first line contains two integers $n, m$: the number of base stations (including the mobile company), and the coordinate of the UP’s home. It is guaranteed that $m$ is greater than or equal to the coordinates of all base stations.\n\nThe next $n$ lines each contain three integers $x_i$, $r_i$, $v_i$, representing the coordinate, transmit radius, and activation cost of each base station.\n\nThe $x_i$ are given in increasing order of coordinates, and the mobile company is at the smallest coordinate.\n\nThe sequence $\\{r_i\\}$ is a permutation of $1 \\dots n$.", "outputFormat": "Output a real number with exactly three digits after the decimal point.", "hint": "For $100\\%$ of the testdata, $n \\le 5 \\times 10^5$, $x_i, m \\le 10^{12}$, $v_i \\le 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2012] 基站建设", "background": null, "description": "up 主家终于买电脑了，但是接下来有各种问题要处理。首要解决的问题就是网络问题。他要从移动公司开始，通过一些基站来传递网络到他家。\n\n为了简化问题，我们假设移动公司，所有的基站、up 主家位于同一条直线上，他们都位于这一条直线上的某一点 $x$，这些点**可能**会重合。每个基站发射和接收的范围都是一个切于地面的圆，发射的半径 $r$ 是固定的，接收半径 $r'$ 是可调的的。如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nh8yxjx5.png)\n\n一个基站 $i$ 如果想从另一个基站 $j$ 接收到信号（当且仅当 $x_j<x_i$），必须满足 $i$ 的接收范围与 $j$ 的发射范围**相切**，且需要付 $\\sqrt{r'_i}$ 的额外费用。启动每一个点 $i$ 都需要费用 $v_i$。\n\nup 主家如果能接收到某个基站的信号，只需要这个点的发射范围与 up 主家所在的竖线相切或相交即可，如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5t4v8687.png)\n\n当然费用越少就越好咯，于是 up 主想要请你帮他的忙。", "inputFormat": "第一行两个整数 $n, m$。表示基站个数（包括移动公司），up 主家的坐标。（保证大于等于所有基站的坐标）\n\n记下来 $n$ 行，每行三个整数 $x_i$，$r_i$，$v_i$，表示每个基站的坐标，发射范围以及费用。\n\n$x_i$ 是按照坐标从小到大输入的，移动公司位于最小的那个坐标。\n\n$r$ 为 $1\\dots n$ 的排列。", "outputFormat": "一个实数，保留小数点后三位。", "hint": "对于 $100\\%$ 的数据 $n\\le5\\times 10^5$，$x_i,m \\le 10^{12}$，$v_i \\le 10000$", "locale": "zh-CN"}}}
{"pid": "P2498", "type": "P", "difficulty": 4, "samples": [["1 3 3\r\n2 2", "1.00"], ["1 3 3\r\n3 1", "2.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "二分", "并查集", "各省省选", "山东"], "title": "[SDOI2012] 拯救小云公主", "background": null, "description": "英雄又即将踏上拯救公主的道路……\n\n这次的拯救目标是 —— 爱和正义的小云公主。\n\n英雄来到 boss 的洞穴门口，他一下子就懵了，因为面前不只是一只 boss，而是上千只 boss。当英雄意识到自己还是等级 $1$ 的时候，他明白这就是一个不可能完成的任务。\n\n但他不死心，他在想，能不能避开 boss 去拯救公主呢，嘻嘻。\n\nboss 的洞穴可以看成一个矩形，英雄在左下角 $(1,1)$，公主在右上角 $(row,line)$。英雄为了避开 boss，当然是离 boss 距离越远越好了，所以英雄决定找一条路径使到距离 boss 的最短距离最远。\n\nPs: 英雄走的方向是任意的，但是不能走出矩形的范围。即英雄可以到达矩形范围内的任意一个点（没有必要是整点）\n\n你可以帮帮他吗？\n\n当英雄找到了美丽漂亮的小云公主，立刻就被 boss 包围了！！！英雄缓闭双眼，举手轻挥，白光一闪后使用了回城卷轴，回到了城堡，但只有小云公主回去了……因为英雄忘了进入回城的法阵了。", "inputFormat": "第一行，输入三个整数，$n$ 表示 boss 的数目，$row$、$line$ 表示矩形的大小；\n\n接下来 $n$ 行，每行分别两个整数，表示 boss 的位置坐标。", "outputFormat": "输出一个小数，表示英雄的路径离 boss 的最远距离，精确到小数点后两位。", "hint": "### 数据范围\n\n对于 $20\\%$ 数据，boss 坐标范围小于等于 $50$；\n\n对于 $60\\%$ 数据，$n \\leq 1500$；\n\n对于 $100\\%$ 数据，$n \\leq 3000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2012] Save Princess Xiaoyun", "background": "", "description": "The hero is about to set out to save a princess again.\n\nThis time, the target to save is Princess Xiaoyun, who stands for love and justice.\n\nWhen the hero arrives at the entrance of the boss’s cave, he is stunned: there is not just one boss, but thousands. Upon realizing he is still level $1$, he understands this is an impossible task.\n\nBut he does not give up. He wonders whether he can avoid the bosses and still save the princess.\n\nThe boss’s cave can be viewed as a rectangle. The hero starts at the bottom-left corner $(1, 1)$, and the princess is at the top-right corner $(row, line)$. To avoid the bosses, the farther he stays from them, the better. Therefore, the hero decides to find a path that maximizes the minimal distance to any boss along the path.\n\nNote: The hero can move in any direction but cannot leave the rectangle. That is, he can reach any point within the rectangle (not necessarily integer coordinates).\n\nCan you help him?\n\nWhen the hero finds the beautiful Princess Xiaoyun, he is immediately surrounded by bosses! He gently closes his eyes, waves his hand, and with a flash of white light, uses a town portal scroll to return to the castle, but only Princess Xiaoyun goes back, because the hero forgot to step into the teleportation array.", "inputFormat": "The first line contains three integers: $n$ for the number of bosses, and $row$, $line$ for the size of the rectangle.\n\nThe next $n$ lines each contain two integers, the coordinates of a boss.", "outputFormat": "Output a real number: the maximal possible minimal distance from the path to any boss, with two decimal places.", "hint": "### Constraints\n\n- For $20\\%$ of the testdata, boss coordinate values are $\\leq 50$.\n- For $60\\%$ of the testdata, $n \\leq 1500$.\n- For $100\\%$ of the testdata, $n \\leq 3000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2012] 拯救小云公主", "background": null, "description": "英雄又即将踏上拯救公主的道路……\n\n这次的拯救目标是 —— 爱和正义的小云公主。\n\n英雄来到 boss 的洞穴门口，他一下子就懵了，因为面前不只是一只 boss，而是上千只 boss。当英雄意识到自己还是等级 $1$ 的时候，他明白这就是一个不可能完成的任务。\n\n但他不死心，他在想，能不能避开 boss 去拯救公主呢，嘻嘻。\n\nboss 的洞穴可以看成一个矩形，英雄在左下角 $(1,1)$，公主在右上角 $(row,line)$。英雄为了避开 boss，当然是离 boss 距离越远越好了，所以英雄决定找一条路径使到距离 boss 的最短距离最远。\n\nPs: 英雄走的方向是任意的，但是不能走出矩形的范围。即英雄可以到达矩形范围内的任意一个点（没有必要是整点）\n\n你可以帮帮他吗？\n\n当英雄找到了美丽漂亮的小云公主，立刻就被 boss 包围了！！！英雄缓闭双眼，举手轻挥，白光一闪后使用了回城卷轴，回到了城堡，但只有小云公主回去了……因为英雄忘了进入回城的法阵了。", "inputFormat": "第一行，输入三个整数，$n$ 表示 boss 的数目，$row$、$line$ 表示矩形的大小；\n\n接下来 $n$ 行，每行分别两个整数，表示 boss 的位置坐标。", "outputFormat": "输出一个小数，表示英雄的路径离 boss 的最远距离，精确到小数点后两位。", "hint": "### 数据范围\n\n对于 $20\\%$ 数据，boss 坐标范围小于等于 $50$；\n\n对于 $60\\%$ 数据，$n \\leq 1500$；\n\n对于 $100\\%$ 数据，$n \\leq 3000$。", "locale": "zh-CN"}}}
{"pid": "P2499", "type": "P", "difficulty": 6, "samples": [["1 8 2 2 0\n.......*\n1 1\n1 3\n1 5\n1 7", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "各省省选", "山东"], "title": "[SDOI2012] 象棋", "background": null, "description": "小云和小南两姐妹从小喜欢下象棋，现在作为象棋高手的她们，已经不屑于玩平常的象棋了，于是她们便开始用棋盘和棋子玩各种各样的新游戏。\n\n今天天气晴朗，阳光明媚，她们将在 $n\\times m$ 的棋盘上进行游戏。\n\n棋盘上有 $k$ 颗棋子和若干有障碍格子，令棋盘左上角格子坐标为 $(1,1)$，右下角格子坐标为 $(n,m)$，参数 $a,b$ 规定了所有棋子的走法：在 $(x, y)$ 的棋子下一步能走到 $(x + a, y + b), (x + a, y - b), (x - a, y + b), (x - a, y - b), (x + b, y + a), (x + b, y - a), (x - b, y + a), (x - b, y - a)$ 这八个格子中的一个，棋子任何时候不能跃出棋盘或走到有障碍的格子上。\n\n这 $k$ 颗棋子是相同的，小云和小南的目标是用最少步数把所有棋子移动到特定格子，要求移动过程中不能出现多颗棋子同时在某一格的情况。\n\n她们已经想出步数较少方案，但无法确定这是否为最少步数，所以向作为程序员的你求助。", "inputFormat": "第一行五个空格隔开的整数 $n,m,k,a,b$；\n\n接下来 $n$ 行，每行为长度 $m$ 的字符串，描述棋盘，`.` 表示没有障碍的格子，`*` 表示有障碍的格子；\n\n接下来 $k$ 行，每行两个整数 $x$ 和 $y$，分别表示 $k$ 颗棋子的初始位置；\n\n接下来 $k$ 行，每行两个整数 $x$ 和 $y$，分别表示 $k$ 颗棋子的目标位置。", "outputFormat": "一个整数，为把所有棋子移动到目标位置的最少步数，数据保证有解。", "hint": "【样例说明】\n\n一可行方案如下：第二颗棋子向右跳两步，随后第一颗棋子向右跳两步，共 $4$ 步。值得注意的是，第一颗棋子向右跳三步，随后第二颗棋子向右跳一步的方案尽管能把棋子都移动到目标位置，但途中两颗棋子曾经同时在 $(1, 3)$，违反了规则，所以不能选用此方案。\n\n\n数据范围\n\n其中 $20\\%$ 的数据，$n\\times m\\le 20$；\n\n另外 $10\\%$ 的数据，$n = 1$；\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 100$，$1\\le k\\le 500$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2012] Chinese Chess", "background": "", "description": "Xiaoyun and Xiaonan, two sisters, have liked playing Chinese Chess since childhood. Now, as masters of the game, they are no longer interested in ordinary Chinese Chess, so they begin to play various new games using the board and pieces.\n\nToday the weather is clear and sunny, and they are going to play on an $n\\times m$ board.\n\nThere are $k$ pieces and some blocked cells on the board. Let the top-left cell be $(1, 1)$ and the bottom-right cell be $(n, m)$. Parameters $a, b$ define the moves of all pieces: a piece at $(x, y)$ can move in one step to one of the eight cells $(x + a, y + b), (x + a, y - b), (x - a, y + b), (x - a, y - b), (x + b, y + a), (x + b, y - a), (x - b, y + a), (x - b, y - a)$. A piece can never jump out of the board or onto a blocked cell.\n\nThese $k$ pieces are identical. The goal is to move all pieces to specified cells in the minimum number of steps. During the moves, it is forbidden for multiple pieces to be on the same cell at the same time.\n\nThey have already found a plan with relatively few steps, but they are not sure whether it is optimal, so they ask you, as a programmer, for help.", "inputFormat": "The first line contains five integers $n, m, k, a, b$ separated by spaces.\n\nThe next $n$ lines each contain a string of length $m$ describing the board, where `.` denotes a free cell and `*` denotes a blocked cell.\n\nThe next $k$ lines each contain two integers $x$ and $y$, giving the initial positions of the $k$ pieces.\n\nThe next $k$ lines each contain two integers $x$ and $y$, giving the target positions of the $k$ pieces.", "outputFormat": "Output a single integer: the minimum number of steps needed to move all pieces to their target positions. The testdata guarantees that a solution exists.", "hint": "[Sample explanation]\n\nOne feasible plan is as follows: the second piece jumps two steps to the right, then the first piece jumps two steps to the right, for a total of $4$ steps. Note that although the plan where the first piece jumps three steps to the right and then the second piece jumps one step to the right can also move all pieces to the target positions, the two pieces would simultaneously be at $(1, 3)$ at some moment, which violates the rules, so this plan cannot be used.\n\nConstraints\n\n- For $20\\%$ of the testdata, $n\\times m \\le 20$.\n- Additionally, for $10\\%$ of the testdata, $n = 1$.\n- For $100\\%$ of the testdata, $1 \\le n, m \\le 100$, $1 \\le k \\le 500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2012] 象棋", "background": null, "description": "小云和小南两姐妹从小喜欢下象棋，现在作为象棋高手的她们，已经不屑于玩平常的象棋了，于是她们便开始用棋盘和棋子玩各种各样的新游戏。\n\n今天天气晴朗，阳光明媚，她们将在 $n\\times m$ 的棋盘上进行游戏。\n\n棋盘上有 $k$ 颗棋子和若干有障碍格子，令棋盘左上角格子坐标为 $(1,1)$，右下角格子坐标为 $(n,m)$，参数 $a,b$ 规定了所有棋子的走法：在 $(x, y)$ 的棋子下一步能走到 $(x + a, y + b), (x + a, y - b), (x - a, y + b), (x - a, y - b), (x + b, y + a), (x + b, y - a), (x - b, y + a), (x - b, y - a)$ 这八个格子中的一个，棋子任何时候不能跃出棋盘或走到有障碍的格子上。\n\n这 $k$ 颗棋子是相同的，小云和小南的目标是用最少步数把所有棋子移动到特定格子，要求移动过程中不能出现多颗棋子同时在某一格的情况。\n\n她们已经想出步数较少方案，但无法确定这是否为最少步数，所以向作为程序员的你求助。", "inputFormat": "第一行五个空格隔开的整数 $n,m,k,a,b$；\n\n接下来 $n$ 行，每行为长度 $m$ 的字符串，描述棋盘，`.` 表示没有障碍的格子，`*` 表示有障碍的格子；\n\n接下来 $k$ 行，每行两个整数 $x$ 和 $y$，分别表示 $k$ 颗棋子的初始位置；\n\n接下来 $k$ 行，每行两个整数 $x$ 和 $y$，分别表示 $k$ 颗棋子的目标位置。", "outputFormat": "一个整数，为把所有棋子移动到目标位置的最少步数，数据保证有解。", "hint": "【样例说明】\n\n一可行方案如下：第二颗棋子向右跳两步，随后第一颗棋子向右跳两步，共 $4$ 步。值得注意的是，第一颗棋子向右跳三步，随后第二颗棋子向右跳一步的方案尽管能把棋子都移动到目标位置，但途中两颗棋子曾经同时在 $(1, 3)$，违反了规则，所以不能选用此方案。\n\n\n数据范围\n\n其中 $20\\%$ 的数据，$n\\times m\\le 20$；\n\n另外 $10\\%$ 的数据，$n = 1$；\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 100$，$1\\le k\\le 500$。", "locale": "zh-CN"}}}
{"pid": "P2500", "type": "P", "difficulty": 6, "samples": [["4 3\r\n1 2 1 \r\n2 3 2\r\n3 1 3\r\n5\r\nAskAA\r\nAskAB\r\nMoveB 2\r\nAskAA\r\nAskAB", "1\r\nNo Found!\r\n3\r\n1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2012", "各省省选", "山东", "根号分治"], "title": "[SDOI2012] 集合", "background": "", "description": "小H在学习“集合与图论”的时候遇到了一个问题，他思考了很久依然无法很好完成这个问题。于是他只好来求助你了，给出n个点m条边的带权无向图（即每条无向边上都有一个权值），有3个集合A、B、C。一开始无向图中所有点都属于A集合，有如下9种操作：\n\nMoveA x：表示将第x个点从所在集合中删除，并加入至A集合。\n\nMoveB x：表示将第x个点从所在集合中删除，并加入至B集合。\n\nMoveC x：表示将第x个点从所在集合中删除，并加入至C集合。\n\nAskAA：询问两个端点都属于A集合的所有边中最小的权值是多少。\n\nAskAB：询问两个端点分别属于A集合和B集合的所有边中最小的权值是多少。\n\nAskAC：询问两个端点分别属于A集合和C集合的所有边中最小的权值是多少。\n\nAskBB：询问两个端点都属于B集合的所有边中最小的权值是多少。\n\nAskBC：询问两个端点分别属于B集合和C集合的所有边中最小的权值是多少。\n\nAskCC：询问两个端点都属于C集合的所有边中最小的权值是多少。\n\n你能帮助他解决这个问题吗？\n", "inputFormat": "输入的第1行有两个正整数，分别表示n和m。\n\n在第2行至第m+1行中，每行有三个正整数，分别为u、v、w。表示这条无向边的两个端点分别为u和v(u != v)，且这个边的权值为w(w<=10^9)。\n\n第m+2行有一个正整数q，表示有q个询问。\n\n在第m+3行至第m+q+2行中，每行的输入方式为题目描述里9种操作中的一种。\n", "outputFormat": "对于所有的Ask操作输出最小的权值，如果不存在则输出“No Found!”。\n", "hint": "数据范围\n\n对于其中20%的数据，满足n<=50, m<=2500, q<=2500。\n\n对于另外30%的数据，满足n<=100, m<=10000, q<=20000。\n\n对于另外50%的数据，满足n<=100000,m<=500000,q<=100000。且无向图上任意两个点之间至多能选出3条不相交的路径。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2012] Set", "background": "", "description": "While studying “Sets and Graph Theory,” Xiao H encountered a problem that he could not solve well after thinking for a long time. He asks for your help. You are given a weighted undirected graph with $n$ vertices and $m$ edges (i.e., each undirected edge has a weight). There are three sets A, B, and C. Initially, all vertices in the undirected graph belong to set A. There are nine operations as follows:\n\nMoveA x: Remove vertex $x$ from its current set and add it to set A.\nMoveB x: Remove vertex $x$ from its current set and add it to set B.\nMoveC x: Remove vertex $x$ from its current set and add it to set C.\nAskAA: Query the minimum weight among all edges whose two endpoints both belong to set A.\nAskAB: Query the minimum weight among all edges whose two endpoints belong to sets A and B, respectively.\nAskAC: Query the minimum weight among all edges whose two endpoints belong to sets A and C, respectively.\nAskBB: Query the minimum weight among all edges whose two endpoints both belong to set B.\nAskBC: Query the minimum weight among all edges whose two endpoints belong to sets B and C, respectively.\nAskCC: Query the minimum weight among all edges whose two endpoints both belong to set C.\n\nCan you help him solve this problem?", "inputFormat": "- Line 1 contains two positive integers, denoting $n$ and $m$.\n- Lines 2 to $m+1$: each line contains three positive integers $u$, $v$, $w$, indicating an undirected edge between $u$ and $v$ ($u \\ne v$) with weight $w$ ($w \\le 10^9$).\n- Line $m+2$ contains a positive integer $q$, the number of operations.\n- Lines $m+3$ to $m+q+2$: each line is one of the nine operations described above.", "outputFormat": "For every Ask operation, output the minimum weight. If it does not exist, output \"No Found!\".", "hint": "Constraints\n\n- For 20% of the testdata, $n \\le 50$, $m \\le 2500$, $q \\le 2500$.\n- For an additional 30% of the testdata, $n \\le 100$, $m \\le 10000$, $q \\le 20000$.\n- For the remaining 50% of the testdata, $n \\le 100000$, $m \\le 500000$, $q \\le 100000$, and in the undirected graph, between any two vertices, there exist at most 3 pairwise disjoint paths.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2012] 集合", "background": "", "description": "小H在学习“集合与图论”的时候遇到了一个问题，他思考了很久依然无法很好完成这个问题。于是他只好来求助你了，给出n个点m条边的带权无向图（即每条无向边上都有一个权值），有3个集合A、B、C。一开始无向图中所有点都属于A集合，有如下9种操作：\n\nMoveA x：表示将第x个点从所在集合中删除，并加入至A集合。\n\nMoveB x：表示将第x个点从所在集合中删除，并加入至B集合。\n\nMoveC x：表示将第x个点从所在集合中删除，并加入至C集合。\n\nAskAA：询问两个端点都属于A集合的所有边中最小的权值是多少。\n\nAskAB：询问两个端点分别属于A集合和B集合的所有边中最小的权值是多少。\n\nAskAC：询问两个端点分别属于A集合和C集合的所有边中最小的权值是多少。\n\nAskBB：询问两个端点都属于B集合的所有边中最小的权值是多少。\n\nAskBC：询问两个端点分别属于B集合和C集合的所有边中最小的权值是多少。\n\nAskCC：询问两个端点都属于C集合的所有边中最小的权值是多少。\n\n你能帮助他解决这个问题吗？\n", "inputFormat": "输入的第1行有两个正整数，分别表示n和m。\n\n在第2行至第m+1行中，每行有三个正整数，分别为u、v、w。表示这条无向边的两个端点分别为u和v(u != v)，且这个边的权值为w(w<=10^9)。\n\n第m+2行有一个正整数q，表示有q个询问。\n\n在第m+3行至第m+q+2行中，每行的输入方式为题目描述里9种操作中的一种。\n", "outputFormat": "对于所有的Ask操作输出最小的权值，如果不存在则输出“No Found!”。\n", "hint": "数据范围\n\n对于其中20%的数据，满足n<=50, m<=2500, q<=2500。\n\n对于另外30%的数据，满足n<=100, m<=10000, q<=20000。\n\n对于另外50%的数据，满足n<=100000,m<=500000,q<=100000。且无向图上任意两个点之间至多能选出3条不相交的路径。\n", "locale": "zh-CN"}}}
{"pid": "P2501", "type": "P", "difficulty": 6, "samples": [["4\r\n5 2 3 5", "1\r\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2006", "河南", "各省省选", "枚举"], "title": "[HAOI2006] 数字序列", "background": "", "description": "现在我们有一个长度为 $n$ 的整数序列 $a$。但是它太不好看了，于是我们希望把它变成一个单调严格上升的序列。但是不希望改变过多的数，也不希望改变的幅度太大。\n", "inputFormat": "第一行是一个整数，表示序列长度 $n$。  \n第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 项 $a_i$。", "outputFormat": "第一行输出一个整数，表示最少需要改变多少个数。\n\n第二行输出一个整数，表示在改变的数最少的情况下，每个数改变的绝对值之和的最小值。", "hint": "#### 数据规模与约定\n\n- 对于 $90\\%$ 的数据，保证 $n \\leq 6 \\times 10^3$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 3.5 \\times 10^4$，$1 \\leq a_i \\leq 10^5$。数据保证 $a_i$ 随机生成。\n", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2006] Number Sequence", "background": "", "description": "You are given an integer sequence $a$ of length $n$. It does not look good, so we want to turn it into a strictly increasing sequence. However, we do not want to change too many elements, and we also do not want the magnitude of changes to be too large.", "inputFormat": "The first line contains an integer $n$, the length of the sequence.  \nThe second line contains $n$ integers; the $i$-th integer is the $i$-th element $a_i$ of the sequence.", "outputFormat": "On the first line, output an integer: the minimum number of elements that need to be changed.  \nOn the second line, output an integer: under the condition that the number of changed elements is minimal, the minimum possible sum of absolute changes.", "hint": "Constraints\n\n- For $90\\%$ of the testdata, it is guaranteed that $n \\leq 6 \\times 10^3$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 3.5 \\times 10^4$, $1 \\leq a_i \\leq 10^5$. The testdata guarantees that $a_i$ are generated at random.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2006] 数字序列", "background": "", "description": "现在我们有一个长度为 $n$ 的整数序列 $a$。但是它太不好看了，于是我们希望把它变成一个单调严格上升的序列。但是不希望改变过多的数，也不希望改变的幅度太大。\n", "inputFormat": "第一行是一个整数，表示序列长度 $n$。  \n第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 项 $a_i$。", "outputFormat": "第一行输出一个整数，表示最少需要改变多少个数。\n\n第二行输出一个整数，表示在改变的数最少的情况下，每个数改变的绝对值之和的最小值。", "hint": "#### 数据规模与约定\n\n- 对于 $90\\%$ 的数据，保证 $n \\leq 6 \\times 10^3$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 3.5 \\times 10^4$，$1 \\leq a_i \\leq 10^5$。数据保证 $a_i$ 随机生成。\n", "locale": "zh-CN"}}}
{"pid": "P2502", "type": "P", "difficulty": 5, "samples": [["4 2\n1 2 1\n3 4 2\n1 4", "IMPOSSIBLE"], ["3 3\n1 2 10\n1 2 5\n2 3 8\n1 3", "5/4"], ["3 2\n1 2 2\n2 3 4\n1 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "河南", "并查集", "各省省选", "枚举", "排序"], "title": "[HAOI2006] 旅行", "background": null, "description": "Z 小镇是一个景色宜人的地方，吸引来自各地的观光客来此旅游观光。Z 小镇附近共有 $n$ 个景点（编号为 $1,2,3,\\ldots,n$），这些景点被 $m$ 条道路连接着，所有道路都是双向的，两个景点之间可能有多条道路。\n\n也许是为了保护该地的旅游资源，Z 小镇有个奇怪的规定，就是对于一条给定的公路 $r_i$，任何在该公路上行驶的车辆速度必须为 $v_i$。\n\n速度变化太快使得游客们很不舒服，因此从一个景点前往另一个景点的时候，大家都希望选择行驶过程中最大速度和最小速度的比尽可能小的路线，也就是所谓最舒适的路线。", "inputFormat": "第一行包含两个正整数 $n,m$。\n\n接下来的 $m$ 行每行包含三个正整数 $x,y,v$。表示景点 $x$ 到景点 $y$ 之间有一条双向公路，车辆必须以速度 $v$ 在该公路上行驶。\n\n最后一行包含两个正整数 $s,t$，表示想知道从景点 $s$ 到景点 $t$ 最大最小速度比最小的路径。$s$ 和 $t$ 不可能相同。", "outputFormat": "如果景点 $s$ 到景点 $t$ 没有路径，输出 `IMPOSSIBLE`。否则输出一个数，表示最小的速度比。如果需要，输出一个既约分数。", "hint": "对于 $100\\%$ 的数据，$1 \\le x,y \\le n \\le 500$，$1 \\le v < 3 \\times 10^4$，$1 \\le m \\le 5 \\times 10^3$，$x \\ne y$。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2006] Travel", "background": "", "description": "Z Town is a picturesque place that attracts tourists from all over. There are $n$ scenic spots near Z Town (numbered $1, 2, 3, \\ldots, n$), connected by $m$ roads. All roads are bidirectional, and there may be multiple roads between two spots.\n\nPerhaps to protect local tourism resources, Z Town has a peculiar rule: for a given road $r_i$, any vehicle traveling on that road must have speed $v_i$.\n\nFrequent speed changes make tourists uncomfortable, so when traveling from one spot to another, everyone wants to choose a route that minimizes the ratio between the maximum and minimum speeds during the trip, i.e., the most comfortable route.", "inputFormat": "The first line contains two positive integers $n, m$.\n\nEach of the next $m$ lines contains three positive integers $x, y, v$. This means there is a bidirectional road between spots $x$ and $y$, and vehicles must travel at speed $v$ on that road.\n\nThe last line contains two positive integers $s, t$, asking for the path from spot $s$ to spot $t$ with the smallest ratio of maximum to minimum speeds. $s$ and $t$ are not the same.", "outputFormat": "If there is no path from $s$ to $t$, output `IMPOSSIBLE`. Otherwise, output a number representing the minimal speed ratio. If necessary, output a reduced fraction.", "hint": "For $100\\%$ of the testdata, $1 \\le x, y \\le n \\le 500$, $1 \\le v < 3 \\times 10^4$, $1 \\le m \\le 5 \\times 10^3$, $x \\ne y$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2006] 旅行", "background": null, "description": "Z 小镇是一个景色宜人的地方，吸引来自各地的观光客来此旅游观光。Z 小镇附近共有 $n$ 个景点（编号为 $1,2,3,\\ldots,n$），这些景点被 $m$ 条道路连接着，所有道路都是双向的，两个景点之间可能有多条道路。\n\n也许是为了保护该地的旅游资源，Z 小镇有个奇怪的规定，就是对于一条给定的公路 $r_i$，任何在该公路上行驶的车辆速度必须为 $v_i$。\n\n速度变化太快使得游客们很不舒服，因此从一个景点前往另一个景点的时候，大家都希望选择行驶过程中最大速度和最小速度的比尽可能小的路线，也就是所谓最舒适的路线。", "inputFormat": "第一行包含两个正整数 $n,m$。\n\n接下来的 $m$ 行每行包含三个正整数 $x,y,v$。表示景点 $x$ 到景点 $y$ 之间有一条双向公路，车辆必须以速度 $v$ 在该公路上行驶。\n\n最后一行包含两个正整数 $s,t$，表示想知道从景点 $s$ 到景点 $t$ 最大最小速度比最小的路径。$s$ 和 $t$ 不可能相同。", "outputFormat": "如果景点 $s$ 到景点 $t$ 没有路径，输出 `IMPOSSIBLE`。否则输出一个数，表示最小的速度比。如果需要，输出一个既约分数。", "hint": "对于 $100\\%$ 的数据，$1 \\le x,y \\le n \\le 500$，$1 \\le v < 3 \\times 10^4$，$1 \\le m \\le 5 \\times 10^3$，$x \\ne y$。", "locale": "zh-CN"}}}
{"pid": "P2503", "type": "P", "difficulty": 5, "samples": [["6 3\n1 2 3 4 5 6\n", "0.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "2006", "河南", "各省省选", "模拟退火"], "title": "[HAOI2006] 均分数据", "background": "", "description": "已知 $n$ 个正整数 $a_1,a_2 ... a_n$ 。今要将它们分成 $m$ 组，使得各组数据的数值和最平均，即各组数字之和的均方差最小。均方差公式如下：\n\n$$\\sigma = \\sqrt{\\frac 1m \\sum\\limits_{i=1}^m(\\overline x - x_i)^2},\\overline x = \\frac 1m \\sum\\limits_{i=1}^m x_i$$\n\n其中 $\\sigma$ 为均方差，$\\bar{x}$ 为各组数据和的平均值，$x_i$ 为第 $i$ 组数据的数值和。", "inputFormat": "第一行是两个整数，表示 $n,m$ 的值（ $n$ 是整数个数，$m$ 是要分成的组数）\n\n第二行有 $n$ 个整数，表示 $a_1,a_2 ... a_n$。整数的范围是 $[1,50]$。\n\n（同一行的整数间用空格分开）\n", "outputFormat": "输出一行一个实数，表示最小均方差的值(保留小数点后两位数字)。\n", "hint": "样例解释：$1,6$、$2,5$、$3,4$ 分别为一组\n\n【数据规模】\n\n对于 $40\\%$ 的数据，保证有 $m \\le n \\le 10$，$2 \\le m \\le 6$\n\n对于 $100\\%$ 的数据，保证有 $m \\le n \\le 20$，$2 \\le m \\le 6$\n", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2006] Evenly Divide Data", "background": "", "description": "Given $n$ positive integers $a_1,a_2 ... a_n$. We want to partition them into $m$ groups so that the sums of the groups are as balanced as possible, i.e., the standard deviation of the group sums is minimized. The formula for the standard deviation is as follows:\n\n$$\\sigma = \\sqrt{\\frac 1m \\sum\\limits_{i=1}^m(\\overline x - x_i)^2},\\overline x = \\frac 1m \\sum\\limits_{i=1}^m x_i$$\n\nHere, $\\sigma$ is the standard deviation, $\\bar{x}$ is the average of the group sums, and $x_i$ is the sum of the $i$-th group.", "inputFormat": "The first line contains two integers, representing the values of $n,m$ ($n$ is the number of integers, and $m$ is the number of groups).\n\nThe second line contains $n$ integers, representing $a_1,a_2 ... a_n$. Each integer is in the range $[1,50]$.\n\nIntegers on the same line are separated by spaces.", "outputFormat": "Output one real number on a single line, representing the minimal value of the standard deviation, rounded to two decimal places.", "hint": "Sample explanation: group as $(1,6)$, $(2,5)$, $(3,4)$.\n\nConstraints\n\nFor $40\\%$ of the testdata, it is guaranteed that $m \\le n \\le 10$, $2 \\le m \\le 6$.\n\nFor $100\\%$ of the testdata, it is guaranteed that $m \\le n \\le 20$, $2 \\le m \\le 6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2006] 均分数据", "background": "", "description": "已知 $n$ 个正整数 $a_1,a_2 ... a_n$ 。今要将它们分成 $m$ 组，使得各组数据的数值和最平均，即各组数字之和的均方差最小。均方差公式如下：\n\n$$\\sigma = \\sqrt{\\frac 1m \\sum\\limits_{i=1}^m(\\overline x - x_i)^2},\\overline x = \\frac 1m \\sum\\limits_{i=1}^m x_i$$\n\n其中 $\\sigma$ 为均方差，$\\bar{x}$ 为各组数据和的平均值，$x_i$ 为第 $i$ 组数据的数值和。", "inputFormat": "第一行是两个整数，表示 $n,m$ 的值（ $n$ 是整数个数，$m$ 是要分成的组数）\n\n第二行有 $n$ 个整数，表示 $a_1,a_2 ... a_n$。整数的范围是 $[1,50]$。\n\n（同一行的整数间用空格分开）\n", "outputFormat": "输出一行一个实数，表示最小均方差的值(保留小数点后两位数字)。\n", "hint": "样例解释：$1,6$、$2,5$、$3,4$ 分别为一组\n\n【数据规模】\n\n对于 $40\\%$ 的数据，保证有 $m \\le n \\le 10$，$2 \\le m \\le 6$\n\n对于 $100\\%$ 的数据，保证有 $m \\le n \\le 20$，$2 \\le m \\le 6$\n", "locale": "zh-CN"}}}
{"pid": "P2504", "type": "P", "difficulty": 3, "samples": [["4\n 1 2 3 4\n6\n0 0\n1 0\n1 2\n-1 -1\n-2 0\n2 2", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2006", "河南", "各省省选", "生成树"], "title": "[HAOI2006] 聪明的猴子", "background": "", "description": "在一个热带雨林中生存着一群猴子，它们以树上的果子为生。昨天下了一场大雨，现在雨过天晴，但整个雨林的地表还是被大水淹没着，部分植物的树冠露在水面上。猴子不会游泳，但跳跃能力比较强，它们仍然可以在露出水面的不同树冠上来回穿梭，以找到喜欢吃的果实。\n\n现在，在这个地区露出水面的有 $N$ 棵树，假设每棵树本身的直径都很小，可以忽略不计。我们在这块区域上建立直角坐标系，则每一棵树的位置由其所对应的坐标表示(任意两棵树的坐标都不相同)。\n\n在这个地区住着的猴子有 $M$ 个，下雨时，它们都躲到了茂密高大的树冠中，没有被大水冲走。由于各个猴子的年龄不同、身体素质不同，它们跳跃的能力不同。有的猴子跳跃的距离比较远(当然也可以跳到较近的树上)，而有些猴子跳跃的距离就比较近。这些猴子非常聪明，它们通过目测就可以准确地判断出自己能否跳到对面的树上。\n\n现已知猴子的数量及每一个猴子的最大跳跃距离，还知道露出水面的每一棵树的坐标，你的任务是统计有多少个猴子可以在这个地区露出水面的所有树冠上觅食。\n", "inputFormat": "输入包括：\n\n第 $1$ 行为一个整数，表示猴子的个数 $M$ $(2 \\le M \\le 500)$；\n\n第 $2$ 行为 $M$ 个整数，依次表示猴子的最大跳跃距离（每个整数值在 $1 \\sim 1000$ 之间）；\n\n第 $3$ 行为一个整数表示树的总棵数 $N$ $(2 \\le N \\le 1000)$ ；\n\n第 $4$ 行至第 $N+3$ 行为 $N$ 棵树的坐标（横纵坐标均为整数，范围为：$-1000 \\sim 1000$）。\n\n（同一行的整数间用空格分开）\n", "outputFormat": "输出包括一个整数，表示可以在这个地区的所有树冠上觅食的猴子数。", "hint": "对于 $40\\%$ 的数据，保证有 $2 \\le N \\le 100$，$1 \\le M \\le 100$\n\n对于全部的数据，保证有 $2 \\le N \\le 1000$，$1 \\le M \\le500$\n\n感谢 @charlie003 修正数据", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2006] Smart Monkey", "background": "", "description": "A troop of monkeys lives in a tropical rainforest and feeds on fruit from the trees. After heavy rain yesterday, the sky has cleared, but the forest floor is still flooded, with only parts of the tree canopies above the water. Monkeys cannot swim, but they are good jumpers, so they can still move among the exposed canopies to find the fruit they like to eat.\n\nThere are $N$ trees whose canopies are above the water. Assume each tree’s own diameter is negligible. We set up a Cartesian coordinate system on this area, and each tree’s position is represented by its coordinate (no two trees share the same coordinate).\n\nThere are $M$ monkeys living in this area. During the rain, they hid in dense, tall canopies and were not swept away. Because of differences in age and physical fitness, their jumping abilities differ. Some monkeys can jump farther (they can also jump to closer trees), while others can only jump shorter distances. These monkeys are very smart: by visual judgment, they can accurately decide whether they can jump to another tree.\n\nGiven the number of monkeys and each monkey’s maximum jump distance, as well as the coordinates of all exposed trees, your task is to count how many monkeys can forage on all the exposed tree canopies in this area.", "inputFormat": "The input includes:\n\n- The first line contains an integer $M$ $(2 \\le M \\le 500)$, the number of monkeys.\n- The second line contains $M$ integers, the maximum jump distance of each monkey (each integer is in $1 \\sim 1000$).\n- The third line contains an integer $N$ $(2 \\le N \\le 1000)$, the total number of trees.\n- Lines $4$ to $N+3$ contain the coordinates of the $N$ trees (both coordinates are integers in the range $-1000 \\sim 1000$).\n\n(Integers on the same line are separated by spaces.)", "outputFormat": "Output a single integer: the number of monkeys that can forage on all canopies in this area.", "hint": "For $40\\%$ of the testdata, it is guaranteed that $2 \\le N \\le 100$, $1 \\le M \\le 100$.\n\nFor all the testdata, it is guaranteed that $2 \\le N \\le 1000$, $1 \\le M \\le 500$.\n\nThanks to @charlie003 for correcting the testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2006] 聪明的猴子", "background": "", "description": "在一个热带雨林中生存着一群猴子，它们以树上的果子为生。昨天下了一场大雨，现在雨过天晴，但整个雨林的地表还是被大水淹没着，部分植物的树冠露在水面上。猴子不会游泳，但跳跃能力比较强，它们仍然可以在露出水面的不同树冠上来回穿梭，以找到喜欢吃的果实。\n\n现在，在这个地区露出水面的有 $N$ 棵树，假设每棵树本身的直径都很小，可以忽略不计。我们在这块区域上建立直角坐标系，则每一棵树的位置由其所对应的坐标表示(任意两棵树的坐标都不相同)。\n\n在这个地区住着的猴子有 $M$ 个，下雨时，它们都躲到了茂密高大的树冠中，没有被大水冲走。由于各个猴子的年龄不同、身体素质不同，它们跳跃的能力不同。有的猴子跳跃的距离比较远(当然也可以跳到较近的树上)，而有些猴子跳跃的距离就比较近。这些猴子非常聪明，它们通过目测就可以准确地判断出自己能否跳到对面的树上。\n\n现已知猴子的数量及每一个猴子的最大跳跃距离，还知道露出水面的每一棵树的坐标，你的任务是统计有多少个猴子可以在这个地区露出水面的所有树冠上觅食。\n", "inputFormat": "输入包括：\n\n第 $1$ 行为一个整数，表示猴子的个数 $M$ $(2 \\le M \\le 500)$；\n\n第 $2$ 行为 $M$ 个整数，依次表示猴子的最大跳跃距离（每个整数值在 $1 \\sim 1000$ 之间）；\n\n第 $3$ 行为一个整数表示树的总棵数 $N$ $(2 \\le N \\le 1000)$ ；\n\n第 $4$ 行至第 $N+3$ 行为 $N$ 棵树的坐标（横纵坐标均为整数，范围为：$-1000 \\sim 1000$）。\n\n（同一行的整数间用空格分开）\n", "outputFormat": "输出包括一个整数，表示可以在这个地区的所有树冠上觅食的猴子数。", "hint": "对于 $40\\%$ 的数据，保证有 $2 \\le N \\le 100$，$1 \\le M \\le 100$\n\n对于全部的数据，保证有 $2 \\le N \\le 1000$，$1 \\le M \\le500$\n\n感谢 @charlie003 修正数据", "locale": "zh-CN"}}}
{"pid": "P2505", "type": "P", "difficulty": 6, "samples": [["4 4\n1 2 5\n2 3 5\n3 4 5\n1 4 8", "2\n3\n2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "河南", "各省省选", "拓扑排序", "最短路"], "title": "[HAOI2012] 道路", "background": null, "description": "C 国有 $n$ 座城市，城市之间通过 $m$ 条**单向**道路连接。一条路径被称为最短路，当且仅当不存在从它的起点到终点的另外一条路径总长度比它小。两条最短路不同，当且仅当它们包含的道路序列不同。我们需要对每条道路的重要性进行评估，评估方式为计算有多少条不同的最短路经过该道路。现在，这个任务交给了你。", "inputFormat": "第一行包含两个正整数 $n, m$。\n\n接下来 $m$ 行每行包含三个正整数 $u, v, w$，表示有一条从 $u$ 到 $v$ 长度为 $w$ 的道路", "outputFormat": "输出应有 $m$ 行，第 $i$ 行包含一个数，代表经过第 $i$ 条道路的最短路的数目对 $10^9+7$ 取模后的结果。", "hint": "数据规模\n\n$30\\%$ 的数据满足：$n\\leq 15, m\\leq 30$。\n\n$60\\%$ 的数据满足：$n\\leq 300, m\\leq 1000$。\n\n$100\\%$ 的数据满足：$n\\leq 1500, m\\leq 5000, 1\\leq w\\leq 10000$。\n\n不保证没有重边。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2012] Road", "background": "", "description": "Country C has $n$ cities connected by $m$ directed roads. A path is called a shortest path if and only if there does not exist another path from its start to its end whose total length is smaller. Two shortest paths are different if and only if the sequences of roads they contain are different. We need to assess the importance of each road by counting how many different shortest paths pass through that road. Now, this task is given to you.", "inputFormat": "The first line contains two positive integers $n, m$.\n\nEach of the next $m$ lines contains three positive integers $u, v, w$, indicating there is a road from $u$ to $v$ with length $w$.", "outputFormat": "Output $m$ lines. The $i$-th line contains one number: the number of shortest paths that pass through the $i$-th road, modulo $10^9+7$.", "hint": "Constraints\n\n$30\\%$ of the testdata satisfies: $n \\le 15, m \\le 30$.\n\n$60\\%$ of the testdata satisfies: $n \\le 300, m \\le 1000$.\n\n$100\\%$ of the testdata satisfies: $n \\le 1500, m \\le 5000, 1 \\le w \\le 10000$.\n\nMultiple edges may exist.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2012] 道路", "background": null, "description": "C 国有 $n$ 座城市，城市之间通过 $m$ 条**单向**道路连接。一条路径被称为最短路，当且仅当不存在从它的起点到终点的另外一条路径总长度比它小。两条最短路不同，当且仅当它们包含的道路序列不同。我们需要对每条道路的重要性进行评估，评估方式为计算有多少条不同的最短路经过该道路。现在，这个任务交给了你。", "inputFormat": "第一行包含两个正整数 $n, m$。\n\n接下来 $m$ 行每行包含三个正整数 $u, v, w$，表示有一条从 $u$ 到 $v$ 长度为 $w$ 的道路", "outputFormat": "输出应有 $m$ 行，第 $i$ 行包含一个数，代表经过第 $i$ 条道路的最短路的数目对 $10^9+7$ 取模后的结果。", "hint": "数据规模\n\n$30\\%$ 的数据满足：$n\\leq 15, m\\leq 30$。\n\n$60\\%$ 的数据满足：$n\\leq 300, m\\leq 1000$。\n\n$100\\%$ 的数据满足：$n\\leq 1500, m\\leq 5000, 1\\leq w\\leq 10000$。\n\n不保证没有重边。", "locale": "zh-CN"}}}
{"pid": "P2506", "type": "P", "difficulty": 6, "samples": [["4\n1\n1010\n01\n10101", "5"], ["2\n0\n1", "-1"], ["7\n00011011\n000110\n11\n0001\n1011\n00\n011011", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "四川", "各省省选"], "title": "[SCOI2008] 劣质编码", "background": "四川NOI省选2008\n", "description": "一个编码方案把每个字符对应到一个01 串。例如{1,1010,01,10101}就是一个编码方案，它把四个字符（假设它们为a,b,c,d）分别对应到串1、1010，01，10101。字符串的编码为各字符编码的连接。例如，在刚才的编码方案中，字符串cac的编码为01101，dcb的编码为10101011010。\n\n进一步分析发现，刚才的编码是相当劣质的，因为字符串ba, acc 和d 的编码都是10101。对于一个编码方案，你的任务是找出三个不同的字符串，使得它们的编码全相同。换句话说，找一个01 编码串，使得它至少有三种解码方式。如果有多组解，这个编码串应当尽量短。\n", "inputFormat": "第一行包含一个整数n，即符号的个数。以下n 行每行为一个长度不超过50的01串（可能为空串），即各符号的编码。\n", "outputFormat": "仅一行，包含一个整数，即最短编码的长度。如果无解，输出-1。\n", "hint": "2 <= n <= 30\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2008] Poor-quality Encoding", "background": "Sichuan NOI Qualifier 2008.", "description": "An encoding scheme maps each character to a 01 string. For example, {1, 1010, 01, 10101} is an encoding scheme that maps four characters (assume they are a, b, c, d) to the strings 1, 1010, 01, 10101 respectively. The encoding of a string is the concatenation of the encodings of its characters. For instance, under the above scheme, the encoding of cac is 01101, and the encoding of dcb is 10101011010.\n\nOn further analysis, the above scheme is quite poor-quality, because the encodings of ba, acc, and d are all 10101. For a given encoding scheme, your task is to find three distinct strings whose encodings are identical. In other words, find a 01 code string that has at least three decoding ways. If there are multiple solutions, this code string should be as short as possible.", "inputFormat": "The first line contains an integer $n$, the number of symbols. Each of the following $n$ lines contains a 01 string (possibly empty) of length at most 50, which is the encoding of a symbol.", "outputFormat": "Output a single line containing an integer: the length of the shortest encoding. If there is no solution, output -1.", "hint": "Constraints: $2 \\le n \\le 30$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2008] 劣质编码", "background": "四川NOI省选2008\n", "description": "一个编码方案把每个字符对应到一个01 串。例如{1,1010,01,10101}就是一个编码方案，它把四个字符（假设它们为a,b,c,d）分别对应到串1、1010，01，10101。字符串的编码为各字符编码的连接。例如，在刚才的编码方案中，字符串cac的编码为01101，dcb的编码为10101011010。\n\n进一步分析发现，刚才的编码是相当劣质的，因为字符串ba, acc 和d 的编码都是10101。对于一个编码方案，你的任务是找出三个不同的字符串，使得它们的编码全相同。换句话说，找一个01 编码串，使得它至少有三种解码方式。如果有多组解，这个编码串应当尽量短。\n", "inputFormat": "第一行包含一个整数n，即符号的个数。以下n 行每行为一个长度不超过50的01串（可能为空串），即各符号的编码。\n", "outputFormat": "仅一行，包含一个整数，即最短编码的长度。如果无解，输出-1。\n", "hint": "2 <= n <= 30\n", "locale": "zh-CN"}}}
{"pid": "P2507", "type": "P", "difficulty": 5, "samples": [["3\n3 65\n45 10\n60 25\n", "32\n"], ["3\n5 5\n6 7\n8 8\n", "5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "2008", "四川", "各省省选"], "title": "[SCOI2008] 配对", "background": "", "description": "你有 $n$ 个整数 $A_i$ 和 $n$ 个整数 $B_i$。你需要把它们配对，即每个 $A_i$ 恰好对应一个 $B_{p[i]}$。要求所有配对的整数差的绝对值之和尽量小，但不允许两个相同的数配对。例如 $A = \\{5, 6, 8\\}$，$B = \\{5, 7, 8 \\}$，则最优配对方案是 $5 \\sim 8$、$6 \\sim 5$、$8 \\sim 7$，配对整数的差的绝对值分别为 $3, 1, 1$，和为 $5$。注意，$5 \\sim 5$、$6 \\sim 7$、$8 \\sim 8$ 是不允许的，因为相同的数不许配对。\n", "inputFormat": "第一行为一个正整数 $n$，接下来是 $n$ 行，每行两个整数 $A_i$ 和 $B_i$，保证所有 $A_i$ 各不相同，$B_i$ 也各不相同。\n", "outputFormat": "输出一个整数，即配对整数的差的绝对值之和的最小值。如果无法配对，输出 `-1`。\n", "hint": "$30 \\%$ 的数据满足：$n \\le {10}^4$；  \n$100 \\%$ 的数据满足：$1 \\le n \\le {10}^5$，$A_i$ 和 $B_i$ 均为 $1$ 到 ${10}^9$ 之间的整数。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2008] Pairing", "background": "", "description": "You are given $n$ integers $A_i$ and $n$ integers $B_i$. You need to pair them, that is, each $A_i$ is matched to exactly one $B_{p[i]}$. The goal is to minimize the sum of absolute differences over all pairs, but pairing two equal numbers is not allowed. For example, if $A = \\{5, 6, 8\\}$ and $B = \\{5, 7, 8\\}$, then an optimal pairing is $5 \\sim 8$, $6 \\sim 5$, $8 \\sim 7$, with absolute differences $3, 1, 1$, summing to $5$. Note that $5 \\sim 5$, $6 \\sim 7$, $8 \\sim 8$ are not allowed because equal numbers may not be paired.", "inputFormat": "The first line contains a positive integer $n$. Then follow $n$ lines, each containing two integers $A_i$ and $B_i$. It is guaranteed that all $A_i$ are pairwise distinct, and all $B_i$ are also pairwise distinct.", "outputFormat": "Output a single integer, the minimum possible sum of absolute differences of the paired integers. If it is impossible to pair, output `-1`.", "hint": "Constraints:  \n$30 \\%$ of the testdata satisfies: $n \\le {10}^4$.  \n$100 \\%$ of the testdata satisfies: $1 \\le n \\le {10}^5$, $A_i$ and $B_i$ are integers between $1$ and ${10}^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2008] 配对", "background": "", "description": "你有 $n$ 个整数 $A_i$ 和 $n$ 个整数 $B_i$。你需要把它们配对，即每个 $A_i$ 恰好对应一个 $B_{p[i]}$。要求所有配对的整数差的绝对值之和尽量小，但不允许两个相同的数配对。例如 $A = \\{5, 6, 8\\}$，$B = \\{5, 7, 8 \\}$，则最优配对方案是 $5 \\sim 8$、$6 \\sim 5$、$8 \\sim 7$，配对整数的差的绝对值分别为 $3, 1, 1$，和为 $5$。注意，$5 \\sim 5$、$6 \\sim 7$、$8 \\sim 8$ 是不允许的，因为相同的数不许配对。\n", "inputFormat": "第一行为一个正整数 $n$，接下来是 $n$ 行，每行两个整数 $A_i$ 和 $B_i$，保证所有 $A_i$ 各不相同，$B_i$ 也各不相同。\n", "outputFormat": "输出一个整数，即配对整数的差的绝对值之和的最小值。如果无法配对，输出 `-1`。\n", "hint": "$30 \\%$ 的数据满足：$n \\le {10}^4$；  \n$100 \\%$ 的数据满足：$1 \\le n \\le {10}^5$，$A_i$ 和 $B_i$ 均为 $1$ 到 ${10}^9$ 之间的整数。\n", "locale": "zh-CN"}}}
{"pid": "P2508", "type": "P", "difficulty": 6, "samples": [["4", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2008", "河南", "各省省选", "枚举", "最大公约数 gcd"], "title": "[HAOI2008] 圆上的整点", "background": null, "description": "求一个给定的圆 $(x^2+y^2=r^2)$，在圆周上有多少个点的坐标是整数。", "inputFormat": "一个整数 $r$。", "outputFormat": "一个整数，表示整点个数。", "hint": "$1\\leq r\\leq 2\\times 10^9$", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2008] Lattice Points on a Circle", "background": "", "description": "Given the circle $(x^2+y^2=r^2)$, determine how many points on its circumference have integer coordinates.", "inputFormat": "A single integer $r$.", "outputFormat": "The number of lattice points.", "hint": "Constraints: $r\\leq 2000 000 000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2008] 圆上的整点", "background": null, "description": "求一个给定的圆 $(x^2+y^2=r^2)$，在圆周上有多少个点的坐标是整数。", "inputFormat": "一个整数 $r$。", "outputFormat": "一个整数，表示整点个数。", "hint": "$1\\leq r\\leq 2\\times 10^9$", "locale": "zh-CN"}}}
{"pid": "P2509", "type": "P", "difficulty": 6, "samples": [["PARAM A B\r\nIF A > 5 THEN\r\nC = B * A\r\nEND IF\r\nD = B - C\r\nZ = Y + X\r\nE = T\r\nF = E + E\r\nV = G + G\r\nRETURN F", "Line 5: variable C might not have been initialized\nLine 6: variable X might not have been initialized\nLine 6: variable Y might not have been initialized\nLine 7: variable T might not have been initialized\nLine 9: variable G might not have been initialized"], ["PARAM G\r\nRETURN G\r\nB = K\r\nRETURN C", "Line 3: unreachable code\r\nLine 4: unreachable code"], ["PARAM T C\r\nB = T\r\nA = 4\r\nIF A < 4 THEN\r\nIF B > 3 THEN\r\nQ = 100 + F\r\nELSE\r\nIF C = -1111111111 THEN\r\nQ = T - A\r\nIF Q = 0 THEN\r\nV = V - 1\r\nEND IF\r\nELSE\r\nRETURN I\r\nE = A\r\nEND IF\r\nEND IF\r\nELSE\r\nQ = 1\r\nEND IF\r\nRETURN Q", "Line 6: variable F might not have been initialized\nLine 11: variable V might not have been initialized\nLine 14: variable I might not have been initialized\nLine 15: unreachable code"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2008", "四川", "各省省选"], "title": "[SCOI2008] 警告", "background": "", "description": "有一个简单的脚本语言，只有赋值语句、条件语句和返回语句三种。变量名必须是单个大写字母，且变量都是 $32$ 位带符号整数。\n\n该语言的每条语句必须单独占一行。程序中不含空行，且每行的行首行末均无空格。每行的不同 token 之间用单个空格隔开。该语言的 BNF 如下：\n\n```cpp\n<line> :: <head> | <assignment> | <if> | ELSE | END IF | <return>\n<head> :: PARAM <paramlist> | PARAM\n<assignment> :: <variable> = <rvalue>\n<if> :: IF <variable> <relation> <value> THEN\n<return> :: RETURN <value>\n<paramlist> :: <variable> | <variable> <paramlist>\n<rvalue> :: <value> | <value> <operator> <value>\n<value> :: <variable> | <integer>\n<operator> :: + | - | * | /\n<relation> :: < | = | >\n<variable> :: A | B | ... | Z\n<integer> :: 不含前导 0 的 32 位带符号整数\n```\n程序的第一行是一条 `<head>` 语句，定义了函数的参数，而最后一行一定是 `<return>` 语句。`<head>` 语句不能在除了第一行之外的其他任何地方出现，但 `<return>` 语句可以在程序中多次出现。行号从 $1$ 开始编号。\n每条 `IF` 语句一定有一个配套的 `END IF` 语句，还有一个可选的 `ELSE` 语句（注意没有 `ELSE IF` 语句）。`IF` 语句可以嵌套，它总是比较一个变量和一个整数或者另一个变量。\n\n你应该分析一个给定的程序，并输出两类警告信息（格式见样例输出）：\n\n- 第一类警告：无法到达的代码行。不管各条 `IF` 语句的布尔表达式是真还是假（假设每条 `IF` 语句的布尔表达式都是既可能为真也可能为假，不受其他 `IF` 语句结果影响）。\n\n- 第二类警告：可能未初始化的变量。该语句用到了某个变量的值，但这个变量既不在第一行指定的参数列表里，也没有在此之前由赋值语句赋值过。如果这条语句无法到达，那么不应该给出这类警告。\n\n注意，语句 `ELSE` 和 `END IF` 不是可执行语句，因此不应该收到任何警告信息。\n", "inputFormat": "最多包含 $50$ 行，即你要处理的程序。保证该程序合法。\n", "outputFormat": "警告按照行号从小到大排序。如果同一行内有多个可能未初始化的变量，按照字母顺序从小到大排列。如果没有任何警告信息，你的输出应该为空。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2008] Warning", "background": "", "description": "There is a simple scripting language with only three kinds of statements: assignment, conditional, and return. Variable names must be single uppercase letters, and all variables are 32-bit signed integers.\n\nEach statement of this language must occupy its own line. The program contains no empty lines, and there are no spaces at the beginning or end of any line. Different tokens on the same line are separated by a single space. The BNF of the language is as follows:\n\n```cpp\n<line> :: <head> | <assignment> | <if> | ELSE | END IF | <return>\n<head> :: PARAM <paramlist> | PARAM\n<assignment> :: <variable> = <rvalue>\n<if> :: IF <variable> <relation> <value> THEN\n<return> :: RETURN <value>\n<paramlist> :: <variable> | <variable> <paramlist>\n<rvalue> :: <value> | <value> <operator> <value>\n<value> :: <variable> | <integer>\n<operator> :: + | - | * | /\n<relation> :: < | = | >\n<variable> :: A | B | ... | Z\n<integer> :: 不含前导 0 的 32 位带符号整数\n```\nThe first line of the program is a `<head>` statement that defines the function’s parameters, and the last line is guaranteed to be a `<return>` statement. A `<head>` statement cannot appear anywhere except the first line, but `<return>` statements may appear multiple times in the program. Line numbers start from $1$.\n\nEvery `IF` statement always has a matching `END IF` statement, and may have an optional `ELSE` statement (note that there is no `ELSE IF` statement). `IF` statements may be nested, and they always compare a variable with an integer or another variable.\n\nYou should analyze a given program and output two kinds of warning messages (see the sample output format):\n\n- Type 1 warning: unreachable code lines. These are lines that cannot be executed no matter whether the boolean expressions of the `IF` statements evaluate to true or false (assume that each `IF` condition is independently both possibly true and possibly false, unaffected by other `IF` results).\n\n- Type 2 warning: possibly uninitialized variables. A statement uses the value of some variable, but this variable is neither listed in the parameter list on the first line nor assigned by an assignment statement before this point. If a statement is unreachable, you should not report this warning for it.\n\nNote that the statements `ELSE` and `END IF` are not executable, so they should not receive any warnings.", "inputFormat": "At most $50$ lines, i.e., the program you need to process. The program is guaranteed to be legal.", "outputFormat": "Output warnings sorted by line number in ascending order. If there are multiple possibly uninitialized variables on the same line, list them in alphabetical order. If there are no warnings, your output should be empty.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2008] 警告", "background": "", "description": "有一个简单的脚本语言，只有赋值语句、条件语句和返回语句三种。变量名必须是单个大写字母，且变量都是 $32$ 位带符号整数。\n\n该语言的每条语句必须单独占一行。程序中不含空行，且每行的行首行末均无空格。每行的不同 token 之间用单个空格隔开。该语言的 BNF 如下：\n\n```cpp\n<line> :: <head> | <assignment> | <if> | ELSE | END IF | <return>\n<head> :: PARAM <paramlist> | PARAM\n<assignment> :: <variable> = <rvalue>\n<if> :: IF <variable> <relation> <value> THEN\n<return> :: RETURN <value>\n<paramlist> :: <variable> | <variable> <paramlist>\n<rvalue> :: <value> | <value> <operator> <value>\n<value> :: <variable> | <integer>\n<operator> :: + | - | * | /\n<relation> :: < | = | >\n<variable> :: A | B | ... | Z\n<integer> :: 不含前导 0 的 32 位带符号整数\n```\n程序的第一行是一条 `<head>` 语句，定义了函数的参数，而最后一行一定是 `<return>` 语句。`<head>` 语句不能在除了第一行之外的其他任何地方出现，但 `<return>` 语句可以在程序中多次出现。行号从 $1$ 开始编号。\n每条 `IF` 语句一定有一个配套的 `END IF` 语句，还有一个可选的 `ELSE` 语句（注意没有 `ELSE IF` 语句）。`IF` 语句可以嵌套，它总是比较一个变量和一个整数或者另一个变量。\n\n你应该分析一个给定的程序，并输出两类警告信息（格式见样例输出）：\n\n- 第一类警告：无法到达的代码行。不管各条 `IF` 语句的布尔表达式是真还是假（假设每条 `IF` 语句的布尔表达式都是既可能为真也可能为假，不受其他 `IF` 语句结果影响）。\n\n- 第二类警告：可能未初始化的变量。该语句用到了某个变量的值，但这个变量既不在第一行指定的参数列表里，也没有在此之前由赋值语句赋值过。如果这条语句无法到达，那么不应该给出这类警告。\n\n注意，语句 `ELSE` 和 `END IF` 不是可执行语句，因此不应该收到任何警告信息。\n", "inputFormat": "最多包含 $50$ 行，即你要处理的程序。保证该程序合法。\n", "outputFormat": "警告按照行号从小到大排序。如果同一行内有多个可能未初始化的变量，按照字母顺序从小到大排列。如果没有任何警告信息，你的输出应该为空。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2510", "type": "P", "difficulty": 6, "samples": [["2\r\n1 0 0\r\n1 1 0", "10.472"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2008", "河南", "各省省选", "极角排序"], "title": "[HAOI2008] 下落的圆盘", "background": "", "description": "有 $n$ 个圆盘从天而降，后面落下的可以盖住前面的。求最后形成的封闭区域的周长。看下面这副图, 所有的红色线条的总长度即为所求.\n\n![](https://cdn.luogu.com.cn/upload/pic/1628.png)", "inputFormat": "第一行一个数 $n$，后 $n$ 行每行三个数表示 $r_i,x_i,y_i$。", "outputFormat": "最后的周长，保留三位小数。", "hint": "数据规模：\n\n$n\\le1000$", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2008] Falling Disks", "background": "", "description": "There are n disks falling from the sky, and those that fall later can cover those that fell earlier. Find the perimeter of the final closed region formed. See the figure below; the total length of all the red curves is the required answer.\n\n![](https://cdn.luogu.com.cn/upload/pic/1628.png)", "inputFormat": "The first line contains an integer n.\n\nEach of the next n lines contains three real numbers r_i, x_i, y_i, representing the radius and the center coordinates of the i-th disk.", "outputFormat": "Output the final perimeter, to three decimal places.", "hint": "Constraints\n\n1 ≤ n ≤ 1000.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2008] 下落的圆盘", "background": "", "description": "有 $n$ 个圆盘从天而降，后面落下的可以盖住前面的。求最后形成的封闭区域的周长。看下面这副图, 所有的红色线条的总长度即为所求.\n\n![](https://cdn.luogu.com.cn/upload/pic/1628.png)", "inputFormat": "第一行一个数 $n$，后 $n$ 行每行三个数表示 $r_i,x_i,y_i$。", "outputFormat": "最后的周长，保留三位小数。", "hint": "数据规模：\n\n$n\\le1000$", "locale": "zh-CN"}}}
{"pid": "P2511", "type": "P", "difficulty": 5, "samples": [["3 2                           \n1 \n1\n10", "10 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2008", "河南", "二分", "各省省选", "前缀和"], "title": "[HAOI2008] 木棍分割", "background": null, "description": "有 $n$ 根木棍，第 $i$ 根木棍的长度为 $L_i$，$n$ 根木棍依据编号次序（即最左边是第 $1$ 根木棍，然后是第 $2$ 根木棍，以此类推）连接在一起，总共有 $n-1$ 个连接处。现在允许你**最多**砍断 $m$ 个连接处，砍完后 $n$ 根木棍被分成了很多段，要求满足总长度最大的一段长度最小。\n\n输出总长度最大的一段长度的最小值，并且输出使总长度最大的一段长度最小的方案总数除以 $10007$ 的余数。", "inputFormat": "第一行，两个正整数 $n,m$。\n\n接下来 $n$ 行，第 $i$ 行一个正整数 $L_i$，表示第 $i$ 根木棍的长度。", "outputFormat": "输出 $2$ 个整数，第一个整数是总长度最大的一段长度的最小值，第二个整数是使总长度最大的一段长度最小的方案总数除以 $10007$ 的余数。", "hint": "### 样例解释\n\n可以砍 $1$ 下分成 $1,1$ 和 $10$ 两个部分，也可以砍 $2$ 下分成 $1$、$1$ 和 $10$ 三个部分。\n\n### 数据范围\n\n对于所有的数据，$n \\le 50000,\\ 0\\le m\\le \\min(n-1,1000),\\ 1\\le L_i\\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2008] Stick Segmentation", "background": "", "description": "There are $n$ sticks. The length of the $i$-th stick is $L_i$. The $n$ sticks are connected in the order of their indices (that is, the leftmost is the $1$-st stick, then the $2$-nd stick, and so on). There are $n-1$ joints in total. You are allowed to cut at most $m$ joints. After cutting, the $n$ sticks are divided into several segments. The requirement is to minimize the length of the longest segment.\n\nOutput the minimum possible value of the length of the longest segment, and the remainder of the number of schemes that achieve this minimum when divided by $10007$.", "inputFormat": "The first line contains two positive integers $n, m$.\n\nThe next $n$ lines each contain a positive integer $L_i$, representing the length of the $i$-th stick.", "outputFormat": "Output $2$ integers: the minimum possible value of the length of the longest segment, and the remainder of the number of schemes that achieve this minimum when divided by $10007$.", "hint": "### Sample Explanation\n\nYou can cut once to split into two parts of total lengths $1, 1$ and $10$, or cut twice to split into three parts of total lengths $1$, $1$, and $10$.\n\n### Constraints\n\nFor all testdata, $n \\le 50000,\\ 0 \\le m \\le \\min(n-1, 1000),\\ 1 \\le L_i \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2008] 木棍分割", "background": null, "description": "有 $n$ 根木棍，第 $i$ 根木棍的长度为 $L_i$，$n$ 根木棍依据编号次序（即最左边是第 $1$ 根木棍，然后是第 $2$ 根木棍，以此类推）连接在一起，总共有 $n-1$ 个连接处。现在允许你**最多**砍断 $m$ 个连接处，砍完后 $n$ 根木棍被分成了很多段，要求满足总长度最大的一段长度最小。\n\n输出总长度最大的一段长度的最小值，并且输出使总长度最大的一段长度最小的方案总数除以 $10007$ 的余数。", "inputFormat": "第一行，两个正整数 $n,m$。\n\n接下来 $n$ 行，第 $i$ 行一个正整数 $L_i$，表示第 $i$ 根木棍的长度。", "outputFormat": "输出 $2$ 个整数，第一个整数是总长度最大的一段长度的最小值，第二个整数是使总长度最大的一段长度最小的方案总数除以 $10007$ 的余数。", "hint": "### 样例解释\n\n可以砍 $1$ 下分成 $1,1$ 和 $10$ 两个部分，也可以砍 $2$ 下分成 $1$、$1$ 和 $10$ 三个部分。\n\n### 数据范围\n\n对于所有的数据，$n \\le 50000,\\ 0\\le m\\le \\min(n-1,1000),\\ 1\\le L_i\\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P2512", "type": "P", "difficulty": 5, "samples": [["4\n1\n2\n5\n4", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "贪心", "2008", "河南", "各省省选", "前缀和"], "title": "[HAOI2008] 糖果传递", "background": null, "description": "有 $n$ 个小朋友坐成一圈，每人有 $a_i$ 个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为 $1$。", "inputFormat": "小朋友个数 $n$，下面 $n$ 行 $a_i$。", "outputFormat": "求使所有人获得均等糖果的最小代价。", "hint": "对于 $100\\%$ 的数据 $1 \\leq n\\le 10^6$，$1 \\leq a _ i \\leq 1.5 \\times 10 ^ 9$，$\\sum_{i=1}^{n}{a_i}$ 是 $n$ 的倍数。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2008] Candy Passing", "background": "", "description": "There are $n$ children sitting in a circle, each with $a_i$ candies. Each child can only pass candies to their left and right neighbors. The cost of passing one candy each time is $1$.", "inputFormat": "The first line contains $n$. Each of the next $n$ lines contains $a_i$.", "outputFormat": "Output the minimum cost to make all children have the same number of candies.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le n \\le 10^6$, $1 \\le a_i \\le 1.5 \\times 10^9$, and $\\sum_{i=1}^{n}{a_i}$ is a multiple of $n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2008] 糖果传递", "background": null, "description": "有 $n$ 个小朋友坐成一圈，每人有 $a_i$ 个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为 $1$。", "inputFormat": "小朋友个数 $n$，下面 $n$ 行 $a_i$。", "outputFormat": "求使所有人获得均等糖果的最小代价。", "hint": "对于 $100\\%$ 的数据 $1 \\leq n\\le 10^6$，$1 \\leq a _ i \\leq 1.5 \\times 10 ^ 9$，$\\sum_{i=1}^{n}{a_i}$ 是 $n$ 的倍数。", "locale": "zh-CN"}}}
{"pid": "P2513", "type": "P", "difficulty": 3, "samples": [["4 1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2009", "河南", "各省省选", "数位 DP", "前缀和"], "title": "[HAOI2009] 逆序对数列", "background": null, "description": "对于一个数列 $\\{a_i\\}$，如果有 $i<j$ 且 $a_i>a_j$，那么我们称 $a_i$ 与 $a_j$ 为一对逆序对数。\n\n若对于任意一个由 $1 \\sim n$ 自然数组成的数列，可以很容易求出有多少个逆序对数。那么逆序对数为 $k$ 的这样自然数数列到底有多少个？", "inputFormat": "第一行为两个整数 $n,k$。", "outputFormat": "写入一个整数，表示符合条件的数列个数，由于这个数可能很大，你只需输出该数对 $10000$ 求余数后的结果。", "hint": "**【样例说明】**\n\n下列 $3$ 个数列逆序对数都为 $1$：分别是 $\\{1,2,4,3\\}$；$\\{1,3,2,4\\}$；$\\{2,1,3,4\\}$；\n\n**【测试数据范围】**\n\n- $30\\%$ 的数据 $n\\le 12$。\n\n- $100\\%$ 的数据 $n\\le 1000$，$k\\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2009] Inversion Count Sequence", "background": "", "description": "For a sequence $\\{a_i\\}$, if $i < j$ and $a_i > a_j$, then we call $a_i$ and $a_j$ an inversion pair.\n\nFor any sequence formed by the natural numbers $1 \\sim n$ (i.e., a permutation), it is easy to compute how many inversions it has. How many such sequences have exactly $k$ inversions?", "inputFormat": "The first line contains two integers $n, k$.", "outputFormat": "Output a single integer: the number of sequences that satisfy the condition. Since this number can be very large, you only need to output the result modulo $10000$.", "hint": "【Sample Explanation】\n\nThe following $3$ sequences each have exactly $1$ inversion: $\\{1,2,4,3\\}$; $\\{1,3,2,4\\}$; $\\{2,1,3,4\\}$.\n\nConstraints\n\n- For $30\\%$ of the testdata, $n \\le 12$.\n- For $100\\%$ of the testdata, $n \\le 1000$, $k \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2009] 逆序对数列", "background": null, "description": "对于一个数列 $\\{a_i\\}$，如果有 $i<j$ 且 $a_i>a_j$，那么我们称 $a_i$ 与 $a_j$ 为一对逆序对数。\n\n若对于任意一个由 $1 \\sim n$ 自然数组成的数列，可以很容易求出有多少个逆序对数。那么逆序对数为 $k$ 的这样自然数数列到底有多少个？", "inputFormat": "第一行为两个整数 $n,k$。", "outputFormat": "写入一个整数，表示符合条件的数列个数，由于这个数可能很大，你只需输出该数对 $10000$ 求余数后的结果。", "hint": "**【样例说明】**\n\n下列 $3$ 个数列逆序对数都为 $1$：分别是 $\\{1,2,4,3\\}$；$\\{1,3,2,4\\}$；$\\{2,1,3,4\\}$；\n\n**【测试数据范围】**\n\n- $30\\%$ 的数据 $n\\le 12$。\n\n- $100\\%$ 的数据 $n\\le 1000$，$k\\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P2514", "type": "P", "difficulty": 5, "samples": [["4 2 7 9 \n3 1 10 3 \n6 3 7 1 10 2 7 4 9 \n1 2 4 3 \n6 6 8 2 \n4 10 8 4 \n10 2 9 2 \n7 6 6 2 \n9 3 7 1 \n2 1 6 9 \n3 1 10 9 \n4 2 1 8 \n2 1 3 4 ", "8 \n49 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "河南", "各省省选"], "title": "[HAOI2010] 工厂选址", "background": "", "description": "某地区有 $m$ 座煤矿，其中第 $i$ 号矿每年产量为 $a_i$ 吨。现有一火力发电厂，每年需用煤恰好 $b$ 吨，每年运行的固定费用（不包括煤的运费）为 $h$ 元，每吨原煤从第 $i$ 号矿运到火力发电厂的运费为 $C_{i,0}$ 元。\n\n现规划新建一个发电厂， $m$ 座煤矿每年开采的原煤将全部供给这两座发电厂。有 $n$ 个备选的新发电厂厂址，若在第 $j$ 号备选厂址建新厂，每年运行的固定费用为 $h_j$ 元；每吨原煤从第 $i$ 号矿运到第 $j$ 号备选厂址的运费为 $C_{i,j}$ 元。\n\n试问：应如何选取新厂厂址并分配 $m$ 座煤矿开采的原煤，才能使每年的总费用（发电厂运行费用与原煤运费之和）最小。", "inputFormat": "第一行四个整数 $m,b,h,n$。\n\n接下来一行 $m$ 个整数 $a_1,a_2,...,a_m$ 表示每一处煤矿的年产量。\n\n接下来一行 $n$ 个整数 $h_1,h_2,...,h_n$ 表示新厂建在每一个位置的固定费用。\n\n接下来 $n+1$ 行每行 $m$ 个正整数，第 $i$ 行描述 $C_{1,i-1} , C_{2,i-1} , ... , C_{m , i-1}$的值。", "outputFormat": "第一行一个整数表示选择的新发电厂的厂址编号，如有多个厂址满足条件，输出最小的一个；\n\n第二行一个整数表示最小的年总费用。", "hint": "对于$100 \\%$的数据，$1 \\leq m \\leq 5 \\times 10^4$，$1 \\leq b \\leq 10^4$，$1 \\leq n \\leq 50$，$0 \\leq h , h_i \\leq 100$，$0 \\leq a_i \\leq 500$，$\\sum\\limits_{i=1}^m a_i \\geq b$，$0 \\leq C_{i,j} \\leq 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2010] Factory Location", "background": "", "description": "There are $m$ coal mines in a region, where the $i$-th mine produces $a_i$ tons per year. There is an existing thermal power plant that requires exactly $b$ tons of coal per year. Its fixed annual operating cost (excluding coal transportation) is $h$ yuan. The transportation cost per ton of raw coal from the $i$-th mine to the existing plant is $C_{i,0}$ yuan.\n\nA new power plant is planned to be built. All raw coal mined from the $m$ mines will be entirely supplied to these two power plants. There are $n$ candidate sites for the new plant. If the new plant is built at the $j$-th candidate site, its fixed annual operating cost is $h_j$ yuan, and the transportation cost per ton of raw coal from the $i$-th mine to the $j$-th candidate site is $C_{i,j}$ yuan.\n\nQuestion: Which site should be selected for the new plant, and how should the raw coal from the $m$ mines be allocated to the two plants, so that the total annual cost (the sum of the plants’ operating costs and the coal transportation costs) is minimized?", "inputFormat": "The first line contains four integers $m, b, h, n$.\n\nThe next line contains $m$ integers $a_1, a_2, \\ldots, a_m$, representing the annual output of each coal mine.\n\nThe next line contains $n$ integers $h_1, h_2, \\ldots, h_n$, representing the fixed cost if the new plant is built at each candidate site.\n\nThe next $n+1$ lines each contain $m$ positive integers. The $i$-th line describes the values of $C_{1,i-1} , C_{2,i-1} , \\ldots , C_{m , i-1}$.", "outputFormat": "The first line contains one integer, the index of the selected site for the new power plant. If multiple sites satisfy the condition, output the smallest index.\n\nThe second line contains one integer, the minimal total annual cost.", "hint": "For $100 \\%$ of the testdata (Constraints): $1 \\leq m \\leq 5 \\times 10^4$, $1 \\leq b \\leq 10^4$, $1 \\leq n \\leq 50$, $0 \\leq h , h_i \\leq 100$, $0 \\leq a_i \\leq 500$, $\\sum\\limits_{i=1}^m a_i \\geq b$, $0 \\leq C_{i,j} \\leq 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2010] 工厂选址", "background": "", "description": "某地区有 $m$ 座煤矿，其中第 $i$ 号矿每年产量为 $a_i$ 吨。现有一火力发电厂，每年需用煤恰好 $b$ 吨，每年运行的固定费用（不包括煤的运费）为 $h$ 元，每吨原煤从第 $i$ 号矿运到火力发电厂的运费为 $C_{i,0}$ 元。\n\n现规划新建一个发电厂， $m$ 座煤矿每年开采的原煤将全部供给这两座发电厂。有 $n$ 个备选的新发电厂厂址，若在第 $j$ 号备选厂址建新厂，每年运行的固定费用为 $h_j$ 元；每吨原煤从第 $i$ 号矿运到第 $j$ 号备选厂址的运费为 $C_{i,j}$ 元。\n\n试问：应如何选取新厂厂址并分配 $m$ 座煤矿开采的原煤，才能使每年的总费用（发电厂运行费用与原煤运费之和）最小。", "inputFormat": "第一行四个整数 $m,b,h,n$。\n\n接下来一行 $m$ 个整数 $a_1,a_2,...,a_m$ 表示每一处煤矿的年产量。\n\n接下来一行 $n$ 个整数 $h_1,h_2,...,h_n$ 表示新厂建在每一个位置的固定费用。\n\n接下来 $n+1$ 行每行 $m$ 个正整数，第 $i$ 行描述 $C_{1,i-1} , C_{2,i-1} , ... , C_{m , i-1}$的值。", "outputFormat": "第一行一个整数表示选择的新发电厂的厂址编号，如有多个厂址满足条件，输出最小的一个；\n\n第二行一个整数表示最小的年总费用。", "hint": "对于$100 \\%$的数据，$1 \\leq m \\leq 5 \\times 10^4$，$1 \\leq b \\leq 10^4$，$1 \\leq n \\leq 50$，$0 \\leq h , h_i \\leq 100$，$0 \\leq a_i \\leq 500$，$\\sum\\limits_{i=1}^m a_i \\geq b$，$0 \\leq C_{i,j} \\leq 50$。", "locale": "zh-CN"}}}
{"pid": "P2515", "type": "P", "difficulty": 5, "samples": [["3 10\n5 5 6\n2 3 4\n0 1 1", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "河南", "各省省选", "背包 DP", "树形 DP", "强连通分量", "Tarjan", "基环树"], "title": "[HAOI2010] 软件安装", "background": "", "description": "现在我们的手头有 $N$ 个软件，对于一个软件 $i$，它要占用 $W_i$ 的磁盘空间，它的价值为 $V_i$。我们希望从中选择一些软件安装到一台磁盘容量为 $M$ 计算机上，使得这些软件的价值尽可能大（即 $V_i$ 的和最大）。\n\n但是现在有个问题：软件之间存在依赖关系，即软件 $i$ 只有在安装了软件 $j$（包括软件 $j$ 的直接或间接依赖）的情况下才能正确工作（软件 $i$ 依赖软件 $j$)。幸运的是，一个软件最多依赖另外一个软件。如果一个软件不能正常工作，那么它能够发挥的作用为 $0$。\n\n\n我们现在知道了软件之间的依赖关系：软件 $i$ 依赖软件 $D_i$。现在请你设计出一种方案，安装价值尽量大的软件。一个软件只能被安装一次，如果一个软件没有依赖则 $D_i=0$，这时只要这个软件安装了，它就能正常工作。", "inputFormat": "第 1 行：$N,M(0\\leq N\\leq 100, 0\\leq M\\leq 500)$\n\n第 2 行：$W_1,W_2, ... W_i, ..., W_n (0\\leq W_i\\leq M)$\n\n第 3 行：$V_1, V_2, ..., V_i, ..., V_n  (0\\leq V_i\\leq 1000)$\n\n第 4 行：$D_1, D_2, ..., D_i, ..., D_n (0\\leq D_i\\leq N, D_i≠i)$", "outputFormat": "一个整数，代表最大价值。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2010] Software Installation", "background": "", "description": "We have $N$ software packages. For a software $i$, it occupies $W_i$ units of disk space, and its value is $V_i$. We want to choose some software to install on a computer with disk capacity $M$, so that the total value of the installed software is as large as possible (i.e., the sum of $V_i$ is maximized).\n\nHowever, there is a problem: there are dependency relationships between software. Software $i$ can work properly only if software $j$ (including software $j$’s direct or indirect dependencies) is installed (software $i$ depends on software $j$). Fortunately, a software depends on at most one other software. If a software cannot work properly, then its contribution is $0$.\n\nWe already know the dependencies between software: software $i$ depends on $D_i$. Please design a plan to install software so that the total value is as large as possible. Each software can be installed at most once. If a software has no dependency, then $D_i=0$; in this case, as long as this software is installed, it will work properly.", "inputFormat": "Line 1: $N,M(0\\leq N\\leq 100, 0\\leq M\\leq 500)$\n\nLine 2: $W_1,W_2, ... W_i, ..., W_n (0\\leq W_i\\leq M)$\n\nLine 3: $V_1, V_2, ..., V_i, ..., V_n  (0\\leq V_i\\leq 1000)$\n\nLine 4: $D_1, D_2, ..., D_i, ..., D_n (0\\leq D_i\\leq N, D_i≠i)$", "outputFormat": "An integer representing the maximum total value.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2010] 软件安装", "background": "", "description": "现在我们的手头有 $N$ 个软件，对于一个软件 $i$，它要占用 $W_i$ 的磁盘空间，它的价值为 $V_i$。我们希望从中选择一些软件安装到一台磁盘容量为 $M$ 计算机上，使得这些软件的价值尽可能大（即 $V_i$ 的和最大）。\n\n但是现在有个问题：软件之间存在依赖关系，即软件 $i$ 只有在安装了软件 $j$（包括软件 $j$ 的直接或间接依赖）的情况下才能正确工作（软件 $i$ 依赖软件 $j$)。幸运的是，一个软件最多依赖另外一个软件。如果一个软件不能正常工作，那么它能够发挥的作用为 $0$。\n\n\n我们现在知道了软件之间的依赖关系：软件 $i$ 依赖软件 $D_i$。现在请你设计出一种方案，安装价值尽量大的软件。一个软件只能被安装一次，如果一个软件没有依赖则 $D_i=0$，这时只要这个软件安装了，它就能正常工作。", "inputFormat": "第 1 行：$N,M(0\\leq N\\leq 100, 0\\leq M\\leq 500)$\n\n第 2 行：$W_1,W_2, ... W_i, ..., W_n (0\\leq W_i\\leq M)$\n\n第 3 行：$V_1, V_2, ..., V_i, ..., V_n  (0\\leq V_i\\leq 1000)$\n\n第 4 行：$D_1, D_2, ..., D_i, ..., D_n (0\\leq D_i\\leq N, D_i≠i)$", "outputFormat": "一个整数，代表最大价值。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2516", "type": "P", "difficulty": 5, "samples": [["ABCBDAB.\nBACBBD.", "4\n7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "2010", "河南", "各省省选", "容斥原理"], "title": "[HAOI2010] 最长公共子序列", "background": null, "description": "字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。令给定的字符序列 $X=\\{x_0,x_1,\\cdots ,x_{m-1}\\}$，序列 $Y=\\{y_0,y_1,\\cdots ,y_{k-1}\\}$ 是 $X$ 的子序列，当且仅当存在 $X$ 的一个严格递增下标序列 $\\{i_0,i_1,\\cdots,i_{k-1}\\}$ ，使得对所有的 $j=0,1,\\cdots,k-1$ ，有 $x_{i_j}=y_j$ 。例如，$X=\\verb!\"ABCBDAB\"!$ ，$Y=\\verb!\"BCDB\"!$ 是 $X$ 的一个子序列。对给定的两个字符序列，求出他们最长的公共子序列长度，以及最长公共子序列个数。其中，两个子序列 $i$ 和 $j$ 不同，当且仅当长度不同或子序列中 $\\exist k, i_k \\neq j_k$。", "inputFormat": "第一行为第一个字符序列，都是大写字母组成，以 `.` 结束，大写字母个数不超过 $5000$。\n\n第二行为第二个字符序列，都是大写字母组成，以 `.` 结束，大写字母个数不超过 $5000$。", "outputFormat": "第一行输出上述两个最长公共子序列的长度。\n\n第二行输出所有可能出现的最长公共子序列个数，答案可能很大，只要将答案对 $10^{8}$ 求余即可。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2010] Longest Common Subsequence", "background": "", "description": "A subsequence of a character sequence is a character sequence formed by arbitrarily deleting any number of characters (possibly zero), not necessarily contiguous, from the given sequence. Let the given character sequence be $X=\\{x_0,x_1,\\cdots,x_{m-1}\\}$, and let $Y=\\{y_0,y_1,\\cdots,y_{k-1}\\}$ be a subsequence of $X$ if and only if there exists a strictly increasing index sequence $\\{i_0,i_1,\\cdots,i_{k-1}\\}$ of $X$ such that for all $j=0,1,\\cdots,k-1$, we have $x_{i_j}=y_j$. For example, $X=\\verb!\"ABCBDAB\"!$, and $Y=\\verb!\"BCDB\"!$ is a subsequence of $X$. For two given character sequences, compute the length of their longest common subsequence, and the number of longest common subsequences. Two subsequences $i$ and $j$ are different if and only if their lengths are different, or there exists $\\exists k$ such that $i_k \\neq j_k$.", "inputFormat": "The first line is the first character sequence, consisting of uppercase letters, ending with `.`. The number of uppercase letters does not exceed $5000$.\n\nThe second line is the second character sequence, consisting of uppercase letters, ending with `.`. The number of uppercase letters does not exceed $5000$.", "outputFormat": "On the first line, output the length of the longest common subsequence of the two sequences.\n\nOn the second line, output the number of all possible longest common subsequences. The answer may be large; output the answer modulo $10^{8}$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2010] 最长公共子序列", "background": null, "description": "字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。令给定的字符序列 $X=\\{x_0,x_1,\\cdots ,x_{m-1}\\}$，序列 $Y=\\{y_0,y_1,\\cdots ,y_{k-1}\\}$ 是 $X$ 的子序列，当且仅当存在 $X$ 的一个严格递增下标序列 $\\{i_0,i_1,\\cdots,i_{k-1}\\}$ ，使得对所有的 $j=0,1,\\cdots,k-1$ ，有 $x_{i_j}=y_j$ 。例如，$X=\\verb!\"ABCBDAB\"!$ ，$Y=\\verb!\"BCDB\"!$ 是 $X$ 的一个子序列。对给定的两个字符序列，求出他们最长的公共子序列长度，以及最长公共子序列个数。其中，两个子序列 $i$ 和 $j$ 不同，当且仅当长度不同或子序列中 $\\exist k, i_k \\neq j_k$。", "inputFormat": "第一行为第一个字符序列，都是大写字母组成，以 `.` 结束，大写字母个数不超过 $5000$。\n\n第二行为第二个字符序列，都是大写字母组成，以 `.` 结束，大写字母个数不超过 $5000$。", "outputFormat": "第一行输出上述两个最长公共子序列的长度。\n\n第二行输出所有可能出现的最长公共子序列个数，答案可能很大，只要将答案对 $10^{8}$ 求余即可。", "hint": null, "locale": "zh-CN"}}}
