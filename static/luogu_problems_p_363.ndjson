{"pid": "P8355", "type": "P", "difficulty": 1, "samples": [["3\n(()", "2"], ["2\n()", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["字符串", "O2优化"], "title": "「WHOI-1」ymh  是 AK 哥！！！", "background": "$2077$ 年春。$15$ 岁的 miku 正在对着你谷发呆，突然看到一个奇怪的问题，你能帮帮他么？？\n\n----\n\n你要先学会一些定义。\n\n\n我们约定一个字符串下标从 $1$ 开始，$s[l,r]$ 表示 $s_ls_{l+1}\\dots s_r$ 拼接成的一个字符串。\n\n---\n\n定义括号匹配串如下：\n\n- 空串是括号匹配串。\n- 如果 $A$ 是括号匹配串，则 $(A)$ 是括号匹配串。\n- 如果 $A,B$ 是括号匹配串，则 $AB$ 是括号匹配串。\n\n---\n\n括号匹配前缀长度是指最大的 $k$ 使得 $s[1,k]$ 是一个括号匹配串。\n\n比如：\n- $s=\\text{(())(()}$ 时括号匹配前缀长度是 $4$。\n- $s=\\text{()()()(()))(}$ 时括号匹配前缀长度是 $10$。", "description": "给你一个括号串 $s$。定义一次操作是交换他们当中相邻的两个字符。\n\n你的任务是找出若干次操作后 $s$ 的括号匹配前缀长度最大值。\n", "inputFormat": "一行一个正整数 $n$ 表示字符串长度。\n\n接下来一行一个字符串表示 $s$。", "outputFormat": "一行一个自然数表示答案。", "hint": "\n\n**本题采用 $\\texttt{Subtask}$ 计分方式，只有通过该 $\\texttt{Subtask}$ 的所有测试点才能得到该点的分数。**\n\n| $\\texttt{Subtask}$ 编号 | 特殊限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 | 只含左括号或只含右括号 | 2 |\n| 2 | $n \\leq 2$ | 3 |\n| 3 | $n \\leq 10$ | 10 |\n| 4 | $n \\leq 1000$ | 20 |\n| 5 | 无| 65 |\n\n对于 $100\\%$ 的数据，保证 $ 1\\leq n\\leq10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「WHOI-1」ymh  是 AK 哥！！！", "background": "$2077$ 年春。$15$ 岁的 miku 正在对着你谷发呆，突然看到一个奇怪的问题，你能帮帮他么？？\n\n----\n\n你要先学会一些定义。\n\n\n我们约定一个字符串下标从 $1$ 开始，$s[l,r]$ 表示 $s_ls_{l+1}\\dots s_r$ 拼接成的一个字符串。\n\n---\n\n定义括号匹配串如下：\n\n- 空串是括号匹配串。\n- 如果 $A$ 是括号匹配串，则 $(A)$ 是括号匹配串。\n- 如果 $A,B$ 是括号匹配串，则 $AB$ 是括号匹配串。\n\n---\n\n括号匹配前缀长度是指最大的 $k$ 使得 $s[1,k]$ 是一个括号匹配串。\n\n比如：\n- $s=\\text{(())(()}$ 时括号匹配前缀长度是 $4$。\n- $s=\\text{()()()(()))(}$ 时括号匹配前缀长度是 $10$。", "description": "给你一个括号串 $s$。定义一次操作是交换他们当中相邻的两个字符。\n\n你的任务是找出若干次操作后 $s$ 的括号匹配前缀长度最大值。\n", "inputFormat": "一行一个正整数 $n$ 表示字符串长度。\n\n接下来一行一个字符串表示 $s$。", "outputFormat": "一行一个自然数表示答案。", "hint": "\n\n**本题采用 $\\texttt{Subtask}$ 计分方式，只有通过该 $\\texttt{Subtask}$ 的所有测试点才能得到该点的分数。**\n\n| $\\texttt{Subtask}$ 编号 | 特殊限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 | 只含左括号或只含右括号 | 2 |\n| 2 | $n \\leq 2$ | 3 |\n| 3 | $n \\leq 10$ | 10 |\n| 4 | $n \\leq 1000$ | 20 |\n| 5 | 无| 65 |\n\n对于 $100\\%$ 的数据，保证 $ 1\\leq n\\leq10^6$。", "locale": "zh-CN"}}}
{"pid": "P8356", "type": "P", "difficulty": 3, "samples": [["3\n3 3 1 2\n11 45 14 19\n9876 10 114514 191981", "2\n1688\n426554662\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "数学", "O2优化"], "title": "「WHOI-1」数列计数", "background": "> 不再拥有，数列陪伴我。\n\n", "description": "这种数列满足下面这一条神奇的性质：\n\n- $a_0=0$。\n- $\\forall i\\in[1,n]$ 均有 $a_i=a_{i-1}+x$ 或者 $a_i=a_{i-1}+y$。\n- $\\forall i\\in[1,n],p \\nmid a_i$。\n\n求这样的 $\\{a\\}_0^{n}$ 的数量。答案对 $10^9+7$ 取模。\n\n两个数列不同，当且仅当他们有一个下标存储的元素不同。", "inputFormat": "**一个输入文件包含多组数据。**\n\n第一行一个正整数 $T$ 表示测试点数目。\n\n接下来 $T$ 行表示测试点。对于每组测试点，一行四个正整数，表示 $n,p,x,y$。", "outputFormat": "$T$ 行，每行一个自然数表示该测试点的答案。", "hint": "样例 #1：\n\n这样的 $a$ 有 $[0,1,2,4],[0,2,4,5]$。\n\n样例 #2、#3：\n\n本来可爱的 Otm 已经写好了上万页的样例解释了，但是更可爱的 miku 把它删掉了所以 Otm 不想再写一遍了。\n\n---\n\n**本题采用 $\\texttt{Subtask}$ 计分方式，只有通过该 $\\texttt{Subtask}$ 的所有测试点才能得到该点的分数。**\n\n| $\\texttt{Subtask}$ 编号 | 特殊限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 | $\\sum n\\leq20$ | 10 |\n| 2 | $p\\leq10^3$ | 30 |\n| 3 | $xy,p$ 互质 | 10 |\n| 4 | 无 | 50 |\n\n对于所有测试数据，$1\\leq T\\leq10^3,1\\leq\\sum n\\leq10^4, 1\\leq x,y,p\\leq10^9$，输入均为正整数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「WHOI-1」数列计数", "background": "> 不再拥有，数列陪伴我。\n\n", "description": "这种数列满足下面这一条神奇的性质：\n\n- $a_0=0$。\n- $\\forall i\\in[1,n]$ 均有 $a_i=a_{i-1}+x$ 或者 $a_i=a_{i-1}+y$。\n- $\\forall i\\in[1,n],p \\nmid a_i$。\n\n求这样的 $\\{a\\}_0^{n}$ 的数量。答案对 $10^9+7$ 取模。\n\n两个数列不同，当且仅当他们有一个下标存储的元素不同。", "inputFormat": "**一个输入文件包含多组数据。**\n\n第一行一个正整数 $T$ 表示测试点数目。\n\n接下来 $T$ 行表示测试点。对于每组测试点，一行四个正整数，表示 $n,p,x,y$。", "outputFormat": "$T$ 行，每行一个自然数表示该测试点的答案。", "hint": "样例 #1：\n\n这样的 $a$ 有 $[0,1,2,4],[0,2,4,5]$。\n\n样例 #2、#3：\n\n本来可爱的 Otm 已经写好了上万页的样例解释了，但是更可爱的 miku 把它删掉了所以 Otm 不想再写一遍了。\n\n---\n\n**本题采用 $\\texttt{Subtask}$ 计分方式，只有通过该 $\\texttt{Subtask}$ 的所有测试点才能得到该点的分数。**\n\n| $\\texttt{Subtask}$ 编号 | 特殊限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 | $\\sum n\\leq20$ | 10 |\n| 2 | $p\\leq10^3$ | 30 |\n| 3 | $xy,p$ 互质 | 10 |\n| 4 | 无 | 50 |\n\n对于所有测试数据，$1\\leq T\\leq10^3,1\\leq\\sum n\\leq10^4, 1\\leq x,y,p\\leq10^9$，输入均为正整数。", "locale": "zh-CN"}}}
{"pid": "P8357", "type": "P", "difficulty": 5, "samples": [["20 1 3", "51 2\n4 1"], ["1000 10 100", "13570 4\n72 12 3 1"]], "limits": {"time": [1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "数论", "Special Judge", "O2优化", "记忆化搜索"], "title": "「WHOI-1」Derives", "background": "你的钱里面混进去了一个假币。", "description": "你有 $n$ 枚硬币。经过准确的测量，你发现一定有一枚是假币，假币的质量与其他硬币不同。你想要找出这枚假币。\n\n第 $i$ 轮，假设你当时有 $x_i$ 枚硬币，你会把当前钱堆所有钱分配到若干组，每组 $k_i$ 个，最终剩下的再单独分一组。每个硬币你要拿起来需要 $a$ 秒，那么这将会花费你 $ax_i$ 秒的时间。接下来，你会称量每一组，称量每组需要 $b$ 秒，所以这将会花费你 $b\\cdot\\lceil\\frac{x_i}{k_i}\\rceil$ 秒的时间。由于只有一枚假币，那么只会有一堆的质量与正常的质量不同。**在称量所有堆之后**，你将会选出与正常质量不同的那一堆，并进入下一轮，让 $x_{i+1}=k_i$。一直执行，直到 $x_i=1$。假设进行了 $m$ 轮，那么花费时间 $f=\\sum\\limits_{i=1}^{m}{(ax_i+b\\cdot\\lceil\\frac{x_i}{k_i}\\rceil)}$\n\n请问，你在最差情况下（**即每轮选出不正常的都是 $k_i$ 个一堆的**）最少需要多长时间找出那枚假币？", "inputFormat": "一行三个正整数，代表 $n,a,b$。", "outputFormat": "第一行两个个非负整数 $f,m$，代表最小可能的时间和你的方案的轮数。\n\n接下来一行 $m$ 个正整数，代表 $k_i$。", "hint": "**说明**\n\n**你需要尽量使得花费的时间更少。**\n\n本题采用 Special Judge。\n\n首先，你输出的答案一定要合法，也就是你输出的答案要与下面的选择方法符合，否则将获得 $0$ 分。\n\n接下来，评测机会对你的输出进行判断。如果你输出的答案合法且与正确答案的差 $\\le9$，那么你将获得 $(10-d)\\times100\\%$ 的分数。例如，如果你输出的答案与正确答案的差为 $4$，那么你将获得 $60\\%$ 的分数。如果你输出的答案等于正确答案，你将获得 $100\\%$ 的分数。请不要输出多余的数字或少输出。\n\n**数据范围**\n\n- $\\text{subtask 1(10pts)}:$ $1\\le n\\le2000$。\n- $\\text{subtask 2(20pts)}:$ $1\\le n\\le75000$。\n- $\\text{subtask 3(30pts)}:$ $1\\le n\\le10^7$。\n- $\\text{subtask 4(40pts)}:$ $1\\le n\\le10^9$。\n\n对于所有数据，满足 $0<a,b\\le10^9$。\n\n**样例说明**\n\n对于第一个样例，进行两轮。$x_1=20,k_1=4,x_2=4,k_2=1$。答案 $f=20+15+4+12=51$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「WHOI-1」Derives", "background": "你的钱里面混进去了一个假币。", "description": "你有 $n$ 枚硬币。经过准确的测量，你发现一定有一枚是假币，假币的质量与其他硬币不同。你想要找出这枚假币。\n\n第 $i$ 轮，假设你当时有 $x_i$ 枚硬币，你会把当前钱堆所有钱分配到若干组，每组 $k_i$ 个，最终剩下的再单独分一组。每个硬币你要拿起来需要 $a$ 秒，那么这将会花费你 $ax_i$ 秒的时间。接下来，你会称量每一组，称量每组需要 $b$ 秒，所以这将会花费你 $b\\cdot\\lceil\\frac{x_i}{k_i}\\rceil$ 秒的时间。由于只有一枚假币，那么只会有一堆的质量与正常的质量不同。**在称量所有堆之后**，你将会选出与正常质量不同的那一堆，并进入下一轮，让 $x_{i+1}=k_i$。一直执行，直到 $x_i=1$。假设进行了 $m$ 轮，那么花费时间 $f=\\sum\\limits_{i=1}^{m}{(ax_i+b\\cdot\\lceil\\frac{x_i}{k_i}\\rceil)}$\n\n请问，你在最差情况下（**即每轮选出不正常的都是 $k_i$ 个一堆的**）最少需要多长时间找出那枚假币？", "inputFormat": "一行三个正整数，代表 $n,a,b$。", "outputFormat": "第一行两个个非负整数 $f,m$，代表最小可能的时间和你的方案的轮数。\n\n接下来一行 $m$ 个正整数，代表 $k_i$。", "hint": "**说明**\n\n**你需要尽量使得花费的时间更少。**\n\n本题采用 Special Judge。\n\n首先，你输出的答案一定要合法，也就是你输出的答案要与下面的选择方法符合，否则将获得 $0$ 分。\n\n接下来，评测机会对你的输出进行判断。如果你输出的答案合法且与正确答案的差 $\\le9$，那么你将获得 $(10-d)\\times100\\%$ 的分数。例如，如果你输出的答案与正确答案的差为 $4$，那么你将获得 $60\\%$ 的分数。如果你输出的答案等于正确答案，你将获得 $100\\%$ 的分数。请不要输出多余的数字或少输出。\n\n**数据范围**\n\n- $\\text{subtask 1(10pts)}:$ $1\\le n\\le2000$。\n- $\\text{subtask 2(20pts)}:$ $1\\le n\\le75000$。\n- $\\text{subtask 3(30pts)}:$ $1\\le n\\le10^7$。\n- $\\text{subtask 4(40pts)}:$ $1\\le n\\le10^9$。\n\n对于所有数据，满足 $0<a,b\\le10^9$。\n\n**样例说明**\n\n对于第一个样例，进行两轮。$x_1=20,k_1=4,x_2=4,k_2=1$。答案 $f=20+15+4+12=51$。", "locale": "zh-CN"}}}
{"pid": "P8358", "type": "P", "difficulty": 6, "samples": [["6 5 4 3\n1 3 4 6 10 10\n1 2 7 8 5 9", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 2000, 2000, 2000, 2000, 2000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化"], "title": "「WHOI-1」HanawoTori", "background": "春天到了，花园里的花竞相开放。樱花、梅花、梨花、桃花、牡丹都开放了。\n\n你需要在花园里采花。\n\n日文版题面：[JP 版リンク](https://www.luogu.com.cn/problem/T239022)。\n\n如果你只会 `cout << 1` 这样骗分，建议不要浪费时间在这里。", "description": "这个花园是由位于最左边的两个 $\\texttt{start}$ 格子加上 $2 \\times n$ 个方格组成的一个长列。如下图，$n=6$：\n\n\n![](https://i.bmp.ovh/imgs/2022/04/07/405bb9192e6cf6d9.png)\n\n注意 $n$ 并不包括最左边的两个 $\\texttt{start}$ 格子。每个格子里面都有一棵花，花的美丽程度（下称“**美丽值**”）用一个整数表示，在上图中已经写在格子里了。\n\n\n从**最左边任选**一个 $\\texttt{start}$ 格子开始，每个时刻，你可以走到当前格子**右**、**右上**或**右下**的格子（只要不走出界），并采走里面的花。当走到花园**尽头**时结束。\n\n然后你需要把采到的花按照美丽程度**升序排列**，组成一串花。记**排序过后的**花串中第 $i$ 朵花的美丽值为 $f_i$，那么这串花的“和谐度”$F$ 等于：\n\n$$F = \\min_{i=1}^{n-1} \\begin{cases} k \\times |f_i-f_{i+1}| && |f_i-f_{i+1}| \\bmod  b = a \\\\ |f_i-f_{i+1}| && |f_i-f_{i+1}| \\bmod  b  \\not = a\\\\\\end{cases}$$\n\n现在知道了花园中每个格子内的花的美丽值，你需要计算出可能的**最大** $F$。即在所有可能的行走方案中，可能出现的最大的 $F$ 值。", "inputFormat": "第一行四个整数，代表 $n,a,b,k$；\n\n接下来一行 $n$ 个整数，第 $i$ 个整数代表第 $1$ 行第 $i$ 格内花的美丽值;\n\n接下来一行 $n$ 个整数，第 $i$ 个整数代表第 $2$ 行第 $i$ 格内花的美丽值;\n", "outputFormat": "一行一个整数，表示所求答案。\n", "hint": "**应要求，本题提供一个大样例，链接在下方。**\n\n样例 #1 解释：\n\n一条路径如下图：![](https://i.bmp.ovh/imgs/2022/04/07/84cfe7c13c0d33c1.png)\n\n按时间顺序，得到的花的美丽值为 $\\{1,2,4,6,5,10\\}$；排序后为 $\\{1,2,4,5,6,10\\}$，可以计算出 $F=1$，这是能得到最大的 $F$ 了。\n\n如果您无法写出能够得到满分的程序，可参考如下数据范围获取部分分值：\n\n| 编号 | 特殊限制 | 分值 | 时限 | \n| :----------: | :----------: | :----------: | :----------: |\n| 1 | $n \\leq 30$ | 10 | 1s |\n| 2 | $n\\leq 100$ | 10 | 1s |\n| 3 | $n \\leq 2500$ | 40 | 1s |\n| 4 | $n \\leq 100000$ | 40 | 2s |\n\n对于所有数据，$0 \\leq f_i,k \\leq 10^{8},1  \\leq b < a \\leq 10^8,n \\ge 2$。\n\n提示：\n\n- 可能需要注意常数因子带来的效率差异。\n- 本题存在 $O(n \\log V)$ 的做法。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「WHOI-1」HanawoTori", "background": "春天到了，花园里的花竞相开放。樱花、梅花、梨花、桃花、牡丹都开放了。\n\n你需要在花园里采花。\n\n日文版题面：[JP 版リンク](https://www.luogu.com.cn/problem/T239022)。\n\n如果你只会 `cout << 1` 这样骗分，建议不要浪费时间在这里。", "description": "这个花园是由位于最左边的两个 $\\texttt{start}$ 格子加上 $2 \\times n$ 个方格组成的一个长列。如下图，$n=6$：\n\n\n![](https://i.bmp.ovh/imgs/2022/04/07/405bb9192e6cf6d9.png)\n\n注意 $n$ 并不包括最左边的两个 $\\texttt{start}$ 格子。每个格子里面都有一棵花，花的美丽程度（下称“**美丽值**”）用一个整数表示，在上图中已经写在格子里了。\n\n\n从**最左边任选**一个 $\\texttt{start}$ 格子开始，每个时刻，你可以走到当前格子**右**、**右上**或**右下**的格子（只要不走出界），并采走里面的花。当走到花园**尽头**时结束。\n\n然后你需要把采到的花按照美丽程度**升序排列**，组成一串花。记**排序过后的**花串中第 $i$ 朵花的美丽值为 $f_i$，那么这串花的“和谐度”$F$ 等于：\n\n$$F = \\min_{i=1}^{n-1} \\begin{cases} k \\times |f_i-f_{i+1}| && |f_i-f_{i+1}| \\bmod  b = a \\\\ |f_i-f_{i+1}| && |f_i-f_{i+1}| \\bmod  b  \\not = a\\\\\\end{cases}$$\n\n现在知道了花园中每个格子内的花的美丽值，你需要计算出可能的**最大** $F$。即在所有可能的行走方案中，可能出现的最大的 $F$ 值。", "inputFormat": "第一行四个整数，代表 $n,a,b,k$；\n\n接下来一行 $n$ 个整数，第 $i$ 个整数代表第 $1$ 行第 $i$ 格内花的美丽值;\n\n接下来一行 $n$ 个整数，第 $i$ 个整数代表第 $2$ 行第 $i$ 格内花的美丽值;\n", "outputFormat": "一行一个整数，表示所求答案。\n", "hint": "**应要求，本题提供一个大样例，链接在下方。**\n\n样例 #1 解释：\n\n一条路径如下图：![](https://i.bmp.ovh/imgs/2022/04/07/84cfe7c13c0d33c1.png)\n\n按时间顺序，得到的花的美丽值为 $\\{1,2,4,6,5,10\\}$；排序后为 $\\{1,2,4,5,6,10\\}$，可以计算出 $F=1$，这是能得到最大的 $F$ 了。\n\n如果您无法写出能够得到满分的程序，可参考如下数据范围获取部分分值：\n\n| 编号 | 特殊限制 | 分值 | 时限 | \n| :----------: | :----------: | :----------: | :----------: |\n| 1 | $n \\leq 30$ | 10 | 1s |\n| 2 | $n\\leq 100$ | 10 | 1s |\n| 3 | $n \\leq 2500$ | 40 | 1s |\n| 4 | $n \\leq 100000$ | 40 | 2s |\n\n对于所有数据，$0 \\leq f_i,k \\leq 10^{8},1  \\leq b < a \\leq 10^8,n \\ge 2$。\n\n提示：\n\n- 可能需要注意常数因子带来的效率差异。\n- 本题存在 $O(n \\log V)$ 的做法。\n", "locale": "zh-CN"}}}
{"pid": "P8359", "type": "P", "difficulty": 4, "samples": [["6 6 8\n1 2\n2 3\n2 4\n1 4\n2 5\n1 6\nGC\nDELETE 5\nDELETE 3\nGC\nDELETE 1\nGC\nDELETE 2\nGC\n1 2 3 4 5 6\n", "149\n"], ["样例 2 见附件 garbage2.in\n本组数据满足测试点 6 的限制。", "样例 2 见附件 garbage2.ans"], ["样例 3 见附件 garbage3.in\n本组数据满足测试点 11 的限制。", "样例 3 见附件 garbage3.ans"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["并查集", "各省省选", "2022", "O2优化", "陕西"], "title": "[SNOI2022] 垃圾回收", "background": "", "description": "通常的情况下，编程语言在管理内存时进行如下的选择：\n\n- 让用户进行手动内存管理（C、C++、Rust 等），这会收获很好的性能，但是给用户提供了很大的编程负担。\n- 使用垃圾回收系统（Java、Go 等），这需要维护一个运行时系统，并且在内存使用和程序性能方面造成了许多不可预测的负担。\n\n尽管存在许多的问题，目前最通用的自动化内存管理手段始终为 Tracing Garbage Collector。这种做法的最基础的思路是维护对象间的引用关系，形成一张图，每次回收时通过扫描引用关系推导出已经无法被访问到的对象，释放它们占用的内存。而这种传统的做法最大的问题在于维护引用链需要造成很大的开销，并且随着维护的对象越多，扫描的代价也会越大。\n\n小 L 是一个喜欢思考的女孩子，她发现维护 Garbage Collector 是一件非常复杂的事情，于是她决定考虑一个更简单的模型（注意它与任何现实中的 GC 规则可能是完全不同的！）。\n\n\n对于一个 $n$ 个点 $m$ 条边的无向图，没有重边自环，点和边均从 $1$ 开始标号。其中每个节点代表一个占用了一定内存的对象，每条边对应一个引用关系（注意这里的引用关系是**无向**的），程序从第 $0$ 秒开始运行，在第 $q + 1$ 秒结束运行。对于 $i = 1, 2, 3, \\dots, q$ 的每个时刻 $i$ 发生以下两种操作之一：\n\n- DELETE $i$，删除边 $(x_i,y_i)$，保证不会删除已经被删除的边。\n- GC， 进行一次内存回收，即杀死所有从起点出发不能访问到的点，释放它们占用的内存。（注意这里对节点的删除不会删除与这些点相连的边）\n\n你可以认为这些操作是被瞬间执行完成的，在所有操作执行后，也就是第 $q + 1$ 秒，程序结束，删除所有剩余的节点（包括 $1$ 号点）。\n\n第 $i$ 个点占用的内存为 $a_i$，现在请你求出 $\\sum_{i = 1}^{n} a_i \\cdot \\mathit{alive}_i$，这里 $\\mathit{alive}_i$ 表示第 $i$ 个点存活的时间，在第 $0$ 秒，所有节点都是存活的。", "inputFormat": "输入的第一行是三个正整数 $n, m, q$，分别表示对象的个数，引用关系的个数，操作的个数。\n\n接下来的 $m$ 行每行两个正整数 $x_i, y_i$ 表示第 $i$ 条引用关系的两个端点。\n\n接下来的 $q$ 行每行为以下两种形式之一，第 $i$ 行表示在第 $i$ 秒发生的操作：\n\n- 字符串 DELETE 和正整数 $x$，含义见【题目描述】。\n- 字符串 GC，含义见【题目描述】。\n\n接下来的一行有 $n$ 个正整数 $a_1,a_2,\\dots,a_n$，表示每个对象占用的内存大小。 ", "outputFormat": "输出一行一个整数表示答案，含义见【题目描述】。", "hint": "**【样例 1 解释】**\n\n在第 $4$ 秒时，节点 $5$ 被删除。\n\n在第 $6$ 秒时，节点 $2, 3$ 被删除。\n\n在第 $9$ 秒时，节点 $1, 4, 6$ 被删除。\n\n答案即 $5 \\times 4 + (2 + 3) \\times 6 + (1 + 4 + 6) \\times 9 = 20 + 30 + 99 = 149$。\n\n**【数据规模与约定】**\n\n对于全部数据，$1 \\leq n, m, q \\leq 4 \\times 10^5$，$1 \\leq a_i \\leq 10^8$。\n\n具体的数据规模与约定见下表。\n\n| 测试点编号 | $n$ | $m$ | $q$ | 特殊限制 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1 \\sim 2$ | $\\leq 500$ | $\\leq 500$ | $\\leq 500$ |   |\n| $3 \\sim 5$ | $\\leq 3000$ | $\\leq 3000$ | $\\leq 3000$ |  |\n| $6 \\sim 10$ | $\\leq 5000$ | $\\leq 5000$ | $\\leq 5000$ |  |\n| $11 \\sim 14$ | $\\leq 2 \\times 10^5$ | $n-1$ | $\\leq 2 \\times 10^5$ | 保证一开始图是一棵树 |\n| $15 \\sim 16$ | $\\leq 2 \\times 10^5$ | $\\leq 2 \\times 10^5$ | $\\leq 2 \\times 10^5$ |  |\n| $17 \\sim 20$ | $\\leq 4 \\times 10^5$ | $\\leq 4 \\times 10^5$ | $\\leq 4 \\times 10^5$ |  |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[SNOI2022] 垃圾回收", "background": "", "description": "通常的情况下，编程语言在管理内存时进行如下的选择：\n\n- 让用户进行手动内存管理（C、C++、Rust 等），这会收获很好的性能，但是给用户提供了很大的编程负担。\n- 使用垃圾回收系统（Java、Go 等），这需要维护一个运行时系统，并且在内存使用和程序性能方面造成了许多不可预测的负担。\n\n尽管存在许多的问题，目前最通用的自动化内存管理手段始终为 Tracing Garbage Collector。这种做法的最基础的思路是维护对象间的引用关系，形成一张图，每次回收时通过扫描引用关系推导出已经无法被访问到的对象，释放它们占用的内存。而这种传统的做法最大的问题在于维护引用链需要造成很大的开销，并且随着维护的对象越多，扫描的代价也会越大。\n\n小 L 是一个喜欢思考的女孩子，她发现维护 Garbage Collector 是一件非常复杂的事情，于是她决定考虑一个更简单的模型（注意它与任何现实中的 GC 规则可能是完全不同的！）。\n\n\n对于一个 $n$ 个点 $m$ 条边的无向图，没有重边自环，点和边均从 $1$ 开始标号。其中每个节点代表一个占用了一定内存的对象，每条边对应一个引用关系（注意这里的引用关系是**无向**的），程序从第 $0$ 秒开始运行，在第 $q + 1$ 秒结束运行。对于 $i = 1, 2, 3, \\dots, q$ 的每个时刻 $i$ 发生以下两种操作之一：\n\n- DELETE $i$，删除边 $(x_i,y_i)$，保证不会删除已经被删除的边。\n- GC， 进行一次内存回收，即杀死所有从起点出发不能访问到的点，释放它们占用的内存。（注意这里对节点的删除不会删除与这些点相连的边）\n\n你可以认为这些操作是被瞬间执行完成的，在所有操作执行后，也就是第 $q + 1$ 秒，程序结束，删除所有剩余的节点（包括 $1$ 号点）。\n\n第 $i$ 个点占用的内存为 $a_i$，现在请你求出 $\\sum_{i = 1}^{n} a_i \\cdot \\mathit{alive}_i$，这里 $\\mathit{alive}_i$ 表示第 $i$ 个点存活的时间，在第 $0$ 秒，所有节点都是存活的。", "inputFormat": "输入的第一行是三个正整数 $n, m, q$，分别表示对象的个数，引用关系的个数，操作的个数。\n\n接下来的 $m$ 行每行两个正整数 $x_i, y_i$ 表示第 $i$ 条引用关系的两个端点。\n\n接下来的 $q$ 行每行为以下两种形式之一，第 $i$ 行表示在第 $i$ 秒发生的操作：\n\n- 字符串 DELETE 和正整数 $x$，含义见【题目描述】。\n- 字符串 GC，含义见【题目描述】。\n\n接下来的一行有 $n$ 个正整数 $a_1,a_2,\\dots,a_n$，表示每个对象占用的内存大小。 ", "outputFormat": "输出一行一个整数表示答案，含义见【题目描述】。", "hint": "**【样例 1 解释】**\n\n在第 $4$ 秒时，节点 $5$ 被删除。\n\n在第 $6$ 秒时，节点 $2, 3$ 被删除。\n\n在第 $9$ 秒时，节点 $1, 4, 6$ 被删除。\n\n答案即 $5 \\times 4 + (2 + 3) \\times 6 + (1 + 4 + 6) \\times 9 = 20 + 30 + 99 = 149$。\n\n**【数据规模与约定】**\n\n对于全部数据，$1 \\leq n, m, q \\leq 4 \\times 10^5$，$1 \\leq a_i \\leq 10^8$。\n\n具体的数据规模与约定见下表。\n\n| 测试点编号 | $n$ | $m$ | $q$ | 特殊限制 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1 \\sim 2$ | $\\leq 500$ | $\\leq 500$ | $\\leq 500$ |   |\n| $3 \\sim 5$ | $\\leq 3000$ | $\\leq 3000$ | $\\leq 3000$ |  |\n| $6 \\sim 10$ | $\\leq 5000$ | $\\leq 5000$ | $\\leq 5000$ |  |\n| $11 \\sim 14$ | $\\leq 2 \\times 10^5$ | $n-1$ | $\\leq 2 \\times 10^5$ | 保证一开始图是一棵树 |\n| $15 \\sim 16$ | $\\leq 2 \\times 10^5$ | $\\leq 2 \\times 10^5$ | $\\leq 2 \\times 10^5$ |  |\n| $17 \\sim 20$ | $\\leq 4 \\times 10^5$ | $\\leq 4 \\times 10^5$ | $\\leq 4 \\times 10^5$ |  |", "locale": "zh-CN"}}}
{"pid": "P8360", "type": "P", "difficulty": 6, "samples": [["5 7 3\n1 2 4 8 16\n1 2 3 2 3\n2 2 4 2 32\n3 1 4\n1 1 5 3 1\n2 2 5 1 64\n3 2 4\n2 1 3 3 128\n3 3 5\n", "79\n142\n188\n"], ["样例 2 见附件 military2.in\n本组数据满足测试点 4 的限制。", "样例 2 见附件 military2.ans"], ["样例 3 见附件 military3.in\n本组数据满足测试点 14 的限制。", "样例 3 见附件 military3.ans"], ["样例 4 见附件 military4.in\n本组数据满足测试点 18 的限制。", "样例 4 见附件 military4.ans"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["并查集", "各省省选", "2022", "O2优化", "陕西", "分块"], "title": "[SNOI2022] 军队", "background": "", "description": "R 国的历史非常悠久。\n\nR 国有 $n$ 个城市，国内有 $C$ 个党派，分别记为 $1,2,\\dots,C$。由于 R 国的版图非常长，这 $n$ 个城市的位置可以近似为坐标轴上的 $n$ 个点。在历史的最初，记载了第 $i$ 个城市归属党派 $c_i$，城中有数量为 $a_i$ 的军队。\n\nR 国的历史上，经常发生以下三种事件：\n\n1. 党派 $y$ 进行了一次游说，使城市 $l$ 到城市 $r$ 的所有归属党派 $x$ 的城市全部归属了 $y$。\n\n2. 党派 $x$ 进行了一次征兵，使城市 $l$ 到城市 $r$ 的所有归属党派 $x$ 的城市中的军队数量增加了 $v$。\n\n3. 城市 $l$ 到城市 $r$ 之间的所有城市爆发了战争。这场战争的规模可以描述为两地之间的所有城市中的军队数量之和。注意战争不一定发生在不同党派之间，归属同一个党派的一些城市内部也可能发生内战。由于 R 国的医护系统足够先进，战争不会造成军队数量的减少。\n\n小 N 是一个喜欢历史的女孩子，最近她想整理一下 R 国的战争史，特别是每场战争的规模。但是由于 R 国的历史实在太长了，她用纸和笔进行运算实在力不从心。于是她找到了你，希望你写一个程序，统计出 R 国历史上所有战争的规模。", "inputFormat": "输入的第一行是三个正整数 $n,q,C$，分别表示城市的个数，事件的个数，和 R 国国内党派的个数。\n\n接下来一行有 $n$ 个正整数 $a_1,a_2,\\dots,a_n$，表示每个城市内初始的军队数。\n\n接下来一行有 $n$ 个正整数 $c_1,c_2,\\dots,c_n$，表示每个城市初始归属的党派。\n\n接下来 $q$ 行，每行 $3$ 到 $5$ 个正整数，表示一次事件：\n\n第一个正整数 $\\mathit{op}$ 表示事件的类型。$\\mathit{op}=1,2,3$ 分别表示【题目描述】中所述的游说，征兵和战争事件。\n\n对于每个游说事件，接下来有 $4$ 个正整数 $l,r,x,y$，意义见【题目描述】。\n\n对于每个征兵事件，接下来有 $4$ 个正整数 $l,r,x,v$，意义见【题目描述】。\n\n对于每个战争事件，接下来有 $2$ 个正整数 $l,r$，意义见【题目描述】。", "outputFormat": "对于每个战争事件，输出一行一个整数，表示此次战争的规模。", "hint": "**【样例 1 解释】**\n\n最初，五个城市的军队数量分别为 $1, 2, 4, 8, 16$，归属的党派分别为 $1, 2, 3, 2, 3$。\n\n发生的事件依次为：\n- 党派 $2$ 尝试在城市 $2, 3, 4$ 征兵，归属党派 $2$ 的城市 $2, 4$ 各增加了 $32$ 军队。\n- 城市 $1$ 和 $4$ 之间的所有城市爆发了战争，规模为 $1 + 34 + 4 + 40 = 79$。\n- 党派 $1$ 在城市 $1, 2, 3, 4, 5$ 进行了一次游说，使得原本归属党派 $3$ 的城市 $3, 5$ 归属了党派 $1$。\n- 党派 $1$ 尝试在城市 $2, 3, 4, 5$ 征兵，归属党派 $1$ 的城市 $3, 5$ 各增加了 $64$ 军队。\n- 城市 $2$ 和 $4$ 之间的所有城市爆发了战争，规模为 $34 + 68 + 40 = 142$。\n- 党派 $3$ 尝试在城市 $1, 2, 3$ 征兵，但是党派 $3$ 现在不拥有任何城市，因此并没有成功征兵。\n- 城市 $3$ 和 $5$ 之间的所有城市爆发了战争，规模为 $68 + 40 + 80 = 188$。\n\n因此你的程序应该依次输出 $79, 142, 188$。\n\n**【数据规模与约定】**\n\n对于全部数据，$1 \\leq n, q\\leq 2.5 \\times 10^5$，$1 \\leq a_i, v \\leq 10^8$，$1 \\leq c_i, x, y \\leq C$。\n\n具体的数据规模与约定见下表。\n\n| 测试点编号 |    $n,q\\leq $     |     $C\\leq $      |               特殊约定               |\n| :--------: | :---------------: | :---------------: | :----------------------------------: |\n|    $1$     |       $20$        |       $20$        |                                      |\n|    $2$     |       $50$        |       $50$        |                                      |\n|    $3$     |       $300$       |       $300$       |                                      |\n|    $4$     |      $5000$       |      $5000$       |                                      |\n|    $5$     |      $10^5$       |       $10$        |                                      |\n|    $6$     | $1.5 \\times 10^5$ |       $10$        |                                      |\n|    $7$     |  $2 \\times 10^5$  |       $10$        |                                      |\n|    $8$     | $2.5 \\times 10^5$ |       $10$        |                                      |\n|    $9$     | $1.5 \\times 10^5$ | $1.5 \\times 10^5$ |    对于所有操作，保证 $l=1,r=n$。    |\n|    $10$    | $2.5 \\times 10^5$ | $2.5 \\times 10^5$ |    对于所有操作，保证 $l=1,r=n$。    |\n|    $11$    | $1.5 \\times 10^5$ | $1.5 \\times 10^5$ | 对于所有操作 $1,2$，保证 $l=1,r=n$。 |\n|    $12$    |  $2 \\times 10^5$  |  $2 \\times 10^5$  | 对于所有操作 $1,2$，保证 $l=1,r=n$。 |\n|    $13$    | $2.5 \\times 10^5$ | $2.5 \\times 10^5$ | 对于所有操作 $1,2$，保证 $l=1,r=n$。 |\n|    $14$    | $1.5 \\times 10^5$ | $1.5 \\times 10^5$ |         保证不存在操作 $1$。         |\n|    $15$    | $2.5 \\times 10^5$ | $2.5 \\times 10^5$ |         保证不存在操作 $1$。         |\n|    $16$    |      $10^5$       |      $10^5$       |                                      |\n|    $17$    | $1.5 \\times 10^5$ | $1.5 \\times 10^5$ |                                      |\n|    $18$    |  $2 \\times 10^5$  |  $2\\times 10^5$   |                                      |\n|    $19$    | $2.5 \\times 10^5$ | $2.5 \\times 10^5$ |                                      |\n|    $20$    | $2.5 \\times 10^5$ | $2.5 \\times 10^5$ |                                      |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[SNOI2022] 军队", "background": "", "description": "R 国的历史非常悠久。\n\nR 国有 $n$ 个城市，国内有 $C$ 个党派，分别记为 $1,2,\\dots,C$。由于 R 国的版图非常长，这 $n$ 个城市的位置可以近似为坐标轴上的 $n$ 个点。在历史的最初，记载了第 $i$ 个城市归属党派 $c_i$，城中有数量为 $a_i$ 的军队。\n\nR 国的历史上，经常发生以下三种事件：\n\n1. 党派 $y$ 进行了一次游说，使城市 $l$ 到城市 $r$ 的所有归属党派 $x$ 的城市全部归属了 $y$。\n\n2. 党派 $x$ 进行了一次征兵，使城市 $l$ 到城市 $r$ 的所有归属党派 $x$ 的城市中的军队数量增加了 $v$。\n\n3. 城市 $l$ 到城市 $r$ 之间的所有城市爆发了战争。这场战争的规模可以描述为两地之间的所有城市中的军队数量之和。注意战争不一定发生在不同党派之间，归属同一个党派的一些城市内部也可能发生内战。由于 R 国的医护系统足够先进，战争不会造成军队数量的减少。\n\n小 N 是一个喜欢历史的女孩子，最近她想整理一下 R 国的战争史，特别是每场战争的规模。但是由于 R 国的历史实在太长了，她用纸和笔进行运算实在力不从心。于是她找到了你，希望你写一个程序，统计出 R 国历史上所有战争的规模。", "inputFormat": "输入的第一行是三个正整数 $n,q,C$，分别表示城市的个数，事件的个数，和 R 国国内党派的个数。\n\n接下来一行有 $n$ 个正整数 $a_1,a_2,\\dots,a_n$，表示每个城市内初始的军队数。\n\n接下来一行有 $n$ 个正整数 $c_1,c_2,\\dots,c_n$，表示每个城市初始归属的党派。\n\n接下来 $q$ 行，每行 $3$ 到 $5$ 个正整数，表示一次事件：\n\n第一个正整数 $\\mathit{op}$ 表示事件的类型。$\\mathit{op}=1,2,3$ 分别表示【题目描述】中所述的游说，征兵和战争事件。\n\n对于每个游说事件，接下来有 $4$ 个正整数 $l,r,x,y$，意义见【题目描述】。\n\n对于每个征兵事件，接下来有 $4$ 个正整数 $l,r,x,v$，意义见【题目描述】。\n\n对于每个战争事件，接下来有 $2$ 个正整数 $l,r$，意义见【题目描述】。", "outputFormat": "对于每个战争事件，输出一行一个整数，表示此次战争的规模。", "hint": "**【样例 1 解释】**\n\n最初，五个城市的军队数量分别为 $1, 2, 4, 8, 16$，归属的党派分别为 $1, 2, 3, 2, 3$。\n\n发生的事件依次为：\n- 党派 $2$ 尝试在城市 $2, 3, 4$ 征兵，归属党派 $2$ 的城市 $2, 4$ 各增加了 $32$ 军队。\n- 城市 $1$ 和 $4$ 之间的所有城市爆发了战争，规模为 $1 + 34 + 4 + 40 = 79$。\n- 党派 $1$ 在城市 $1, 2, 3, 4, 5$ 进行了一次游说，使得原本归属党派 $3$ 的城市 $3, 5$ 归属了党派 $1$。\n- 党派 $1$ 尝试在城市 $2, 3, 4, 5$ 征兵，归属党派 $1$ 的城市 $3, 5$ 各增加了 $64$ 军队。\n- 城市 $2$ 和 $4$ 之间的所有城市爆发了战争，规模为 $34 + 68 + 40 = 142$。\n- 党派 $3$ 尝试在城市 $1, 2, 3$ 征兵，但是党派 $3$ 现在不拥有任何城市，因此并没有成功征兵。\n- 城市 $3$ 和 $5$ 之间的所有城市爆发了战争，规模为 $68 + 40 + 80 = 188$。\n\n因此你的程序应该依次输出 $79, 142, 188$。\n\n**【数据规模与约定】**\n\n对于全部数据，$1 \\leq n, q\\leq 2.5 \\times 10^5$，$1 \\leq a_i, v \\leq 10^8$，$1 \\leq c_i, x, y \\leq C$。\n\n具体的数据规模与约定见下表。\n\n| 测试点编号 |    $n,q\\leq $     |     $C\\leq $      |               特殊约定               |\n| :--------: | :---------------: | :---------------: | :----------------------------------: |\n|    $1$     |       $20$        |       $20$        |                                      |\n|    $2$     |       $50$        |       $50$        |                                      |\n|    $3$     |       $300$       |       $300$       |                                      |\n|    $4$     |      $5000$       |      $5000$       |                                      |\n|    $5$     |      $10^5$       |       $10$        |                                      |\n|    $6$     | $1.5 \\times 10^5$ |       $10$        |                                      |\n|    $7$     |  $2 \\times 10^5$  |       $10$        |                                      |\n|    $8$     | $2.5 \\times 10^5$ |       $10$        |                                      |\n|    $9$     | $1.5 \\times 10^5$ | $1.5 \\times 10^5$ |    对于所有操作，保证 $l=1,r=n$。    |\n|    $10$    | $2.5 \\times 10^5$ | $2.5 \\times 10^5$ |    对于所有操作，保证 $l=1,r=n$。    |\n|    $11$    | $1.5 \\times 10^5$ | $1.5 \\times 10^5$ | 对于所有操作 $1,2$，保证 $l=1,r=n$。 |\n|    $12$    |  $2 \\times 10^5$  |  $2 \\times 10^5$  | 对于所有操作 $1,2$，保证 $l=1,r=n$。 |\n|    $13$    | $2.5 \\times 10^5$ | $2.5 \\times 10^5$ | 对于所有操作 $1,2$，保证 $l=1,r=n$。 |\n|    $14$    | $1.5 \\times 10^5$ | $1.5 \\times 10^5$ |         保证不存在操作 $1$。         |\n|    $15$    | $2.5 \\times 10^5$ | $2.5 \\times 10^5$ |         保证不存在操作 $1$。         |\n|    $16$    |      $10^5$       |      $10^5$       |                                      |\n|    $17$    | $1.5 \\times 10^5$ | $1.5 \\times 10^5$ |                                      |\n|    $18$    |  $2 \\times 10^5$  |  $2\\times 10^5$   |                                      |\n|    $19$    | $2.5 \\times 10^5$ | $2.5 \\times 10^5$ |                                      |\n|    $20$    | $2.5 \\times 10^5$ | $2.5 \\times 10^5$ |                                      |", "locale": "zh-CN"}}}
{"pid": "P8361", "type": "P", "difficulty": 6, "samples": [["3\n6 10\n3 3\n6 7\n", "1 4 2 8 5 7\n-1\n0 3 5 3 1 6"], ["样例 2 见附件 double2.in\n本组数据满足测试点 3 的限制。", "样例 2 见附件 double2.ans"], ["样例 3 见附件 double3.in\n本组数据满足测试点 17 的限制。", "样例 3 见附件 double3.ans"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["各省省选", "2022", "Special Judge", "O2优化", "陕西"], "title": "[SNOI2022] 倍增", "background": "", "description": "小 Z 是一个喜欢编程的女孩子。\n\n这天，她在做一道编程题的时候偶然发现了一个神奇的整数 $142857$。\n\n$142857 \\times 2 = 285714$，而 $285714$ 的所有数位恰好是 $142857$ 的一个排列。\n\n她很好奇，有没有更大的满足这种性质的整数。\n\n她写了一个搜索，发现了一些更大的有趣的数：\n\n$26835741 \\times 2 = 53671482$\n\n$0987312654 \\times 2 = 1974625308$\n\n$\\dots$\n\n她不满足于解决十进制下这样的问题，于是她想知道，是否在 $B$ 进制下存在一个 $n$ 位正整数 $x$，满足 $2x$ 的所有数位在 $B$ 进制下是 $x$ 的所有数位的一个排列。\n\n由于她讨厌数字 $0$，因此她还要求对于任意 $1 \\leq i \\leq n$，$x$ 和 $2x$ 在 $B$ 进制下的第 $i$ 位不能同时为 $0$。", "inputFormat": "**输入包含多组数据。**\n\n输入的第一行是一个正整数 $T$，表示数据组数。\n\n接下来 $T$ 行，第 $i$ 行包含两个正整数 $n$ 和 $B$，表示第 $i$ 组数据。", "outputFormat": "对于每组数据，输出一行。\n\n若本组数据有解，按照从高位到低位的顺序输出 $n$ 个非负整数，表示你找到的答案在 $B$ 进制下的值。\n\n否则只需要输出一个数 $-1$。", "hint": "**【样例 1 解释】**\n\n- 第一组数据的解释参见【题目描述】。\n- 对于第二组数据，可以通过枚举所有的 $n$ 位 $B$ 进制数说明一定不能找到这样的正整数。\n- 对于第三组数据，$2x$ 的 $7$ 进制表示为 $103635_{(7)}$，因此这是一个满足题意的答案。\n\n注意此样例的答案文件仅表明了一种可能的合法答案，不表明答案文件恰好对应标准程序的输出。\n\n**【样例 2/3 解释】**\n\n注意此样例的答案文件仅表明了一种可能的合法答案，不表明答案文件恰好对应标准程序的输出。\n\n**【提示】**\n\n由于答案可能不唯一，我们下发了校验器 `checker.cpp` 和库文件 `testlib.h`。\n\n可以使用以下命令编译 `checker.cpp`：\n\n```\ng++ -o checker checker.cpp -O2 -std=c++11\n```\n\n将 `checker.cpp` 编译得到可执行文件 `checker` 后你可以使用以下方式测试你的答案：\n\n`checker <input> <output> <answer>`：利用选手目录下的 `double/double*.ans` 可以用来检验你的答案在样例测试点 `double/double*.in` 的正确性。\n\n`checker <input> <output> <output>`：会检查你的所有有解输出是否符合题目要求。注意以此种方式测试的时候，输出无解总会被报告为合法，因为在此种运行方式下我们只会检查你报告的所有解。\n\n**请选手注意多组数据之间的清空问题。**\n\n**【数据规模与约定】**\n\n对于全部数据，$1 \\leq T \\leq 10^4$，$2 \\leq \\sum B \\leq 2 \\times 10^5$，$1 \\leq \\sum n \\leq 2 \\times 10^5$，$n \\geq 1$，$B \\geq 2$。\n\n具体的数据规模与约定见下表。\n\n| 测试点编号 |    $n \\leq$     |    $ B \\leq$    | $T \\leq$ | 特殊约定            |\n| :--------: | :-------------: | :-------------: | :------: | ------------------- |\n|    $1$     |       $8$       |       $8$       |   $10$   |                     |\n|    $2$     |       $8$       |       $8$       |  $10^4$  |                     |\n|    $3$     | $2 \\times 10^5$ |       $8$       |   $10$   |                     |\n|    $4$     | $2 \\times 10^5$ |       $8$       |  $10^4$  |                     |\n|    $5$     | $2 \\times 10^5$ |       $8$       |  $10^4$  |                     |\n|    $6$     |      $15$       |      $15$       |  $100$   |                     |\n|    $7$     |      $40$       |      $40$       |  $100$   |                     |\n|    $8$     |      $100$      |      $100$      |  $100$   |                     |\n|    $9$     |      $300$      |      $300$      |  $100$   |                     |\n|    $10$    |     $1000$      |     $1000$      |  $100$   |                     |\n|    $11$    |     $3000$      |     $3000$      |  $100$   |                     |\n|    $12$    |     $15000$     |     $15000$     |  $100$   |                     |\n|    $13$    |     $50000$     |     $50000$     |  $100$   |                     |\n|    $14$    | $2 \\times 10^5$ | $2 \\times 10^5$ |  $100$   |                     |\n|    $15$    |      $200$      |      $200$      |  $10^4$  | $n \\geq 100$        |\n|    $16$    |     $5000$      |     $5000$      |  $10^4$  | $n \\geq 100$        |\n|    $17$    | $2 \\times 10^5$ | $2 \\times 10^5$ |  $10^4$  | $n \\geq 100$        |\n|    $18$    |      $300$      |      $300$      |  $10^4$  | $B=3k-1,k \\in \\N^*$ |\n|    $19$    | $2 \\times 10^5$ | $2 \\times 10^5$ |  $10^4$  | $B=3k-1,k \\in \\N^*$ |\n|    $20$    |      $300$      |      $300$      |  $10^4$  | $B=3k,k \\in \\N^*$   |\n|    $21$    | $2 \\times 10^5$ | $2 \\times 10^5$ |  $10^4$  | $B=3k,k \\in \\N^*$   |\n|    $22$    |      $100$      |      $100$      |  $10^4$  |                     |\n|    $23$    |      $500$      |     $5000$      |  $10^4$  |                     |\n|    $24$    | $2 \\times 10^5$ | $2 \\times 10^5$ |  $10^4$  |                     |\n|    $25$    | $2 \\times 10^5$ | $2 \\times 10^5$ |  $10^4$  |                     |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[SNOI2022] 倍增", "background": "", "description": "小 Z 是一个喜欢编程的女孩子。\n\n这天，她在做一道编程题的时候偶然发现了一个神奇的整数 $142857$。\n\n$142857 \\times 2 = 285714$，而 $285714$ 的所有数位恰好是 $142857$ 的一个排列。\n\n她很好奇，有没有更大的满足这种性质的整数。\n\n她写了一个搜索，发现了一些更大的有趣的数：\n\n$26835741 \\times 2 = 53671482$\n\n$0987312654 \\times 2 = 1974625308$\n\n$\\dots$\n\n她不满足于解决十进制下这样的问题，于是她想知道，是否在 $B$ 进制下存在一个 $n$ 位正整数 $x$，满足 $2x$ 的所有数位在 $B$ 进制下是 $x$ 的所有数位的一个排列。\n\n由于她讨厌数字 $0$，因此她还要求对于任意 $1 \\leq i \\leq n$，$x$ 和 $2x$ 在 $B$ 进制下的第 $i$ 位不能同时为 $0$。", "inputFormat": "**输入包含多组数据。**\n\n输入的第一行是一个正整数 $T$，表示数据组数。\n\n接下来 $T$ 行，第 $i$ 行包含两个正整数 $n$ 和 $B$，表示第 $i$ 组数据。", "outputFormat": "对于每组数据，输出一行。\n\n若本组数据有解，按照从高位到低位的顺序输出 $n$ 个非负整数，表示你找到的答案在 $B$ 进制下的值。\n\n否则只需要输出一个数 $-1$。", "hint": "**【样例 1 解释】**\n\n- 第一组数据的解释参见【题目描述】。\n- 对于第二组数据，可以通过枚举所有的 $n$ 位 $B$ 进制数说明一定不能找到这样的正整数。\n- 对于第三组数据，$2x$ 的 $7$ 进制表示为 $103635_{(7)}$，因此这是一个满足题意的答案。\n\n注意此样例的答案文件仅表明了一种可能的合法答案，不表明答案文件恰好对应标准程序的输出。\n\n**【样例 2/3 解释】**\n\n注意此样例的答案文件仅表明了一种可能的合法答案，不表明答案文件恰好对应标准程序的输出。\n\n**【提示】**\n\n由于答案可能不唯一，我们下发了校验器 `checker.cpp` 和库文件 `testlib.h`。\n\n可以使用以下命令编译 `checker.cpp`：\n\n```\ng++ -o checker checker.cpp -O2 -std=c++11\n```\n\n将 `checker.cpp` 编译得到可执行文件 `checker` 后你可以使用以下方式测试你的答案：\n\n`checker <input> <output> <answer>`：利用选手目录下的 `double/double*.ans` 可以用来检验你的答案在样例测试点 `double/double*.in` 的正确性。\n\n`checker <input> <output> <output>`：会检查你的所有有解输出是否符合题目要求。注意以此种方式测试的时候，输出无解总会被报告为合法，因为在此种运行方式下我们只会检查你报告的所有解。\n\n**请选手注意多组数据之间的清空问题。**\n\n**【数据规模与约定】**\n\n对于全部数据，$1 \\leq T \\leq 10^4$，$2 \\leq \\sum B \\leq 2 \\times 10^5$，$1 \\leq \\sum n \\leq 2 \\times 10^5$，$n \\geq 1$，$B \\geq 2$。\n\n具体的数据规模与约定见下表。\n\n| 测试点编号 |    $n \\leq$     |    $ B \\leq$    | $T \\leq$ | 特殊约定            |\n| :--------: | :-------------: | :-------------: | :------: | ------------------- |\n|    $1$     |       $8$       |       $8$       |   $10$   |                     |\n|    $2$     |       $8$       |       $8$       |  $10^4$  |                     |\n|    $3$     | $2 \\times 10^5$ |       $8$       |   $10$   |                     |\n|    $4$     | $2 \\times 10^5$ |       $8$       |  $10^4$  |                     |\n|    $5$     | $2 \\times 10^5$ |       $8$       |  $10^4$  |                     |\n|    $6$     |      $15$       |      $15$       |  $100$   |                     |\n|    $7$     |      $40$       |      $40$       |  $100$   |                     |\n|    $8$     |      $100$      |      $100$      |  $100$   |                     |\n|    $9$     |      $300$      |      $300$      |  $100$   |                     |\n|    $10$    |     $1000$      |     $1000$      |  $100$   |                     |\n|    $11$    |     $3000$      |     $3000$      |  $100$   |                     |\n|    $12$    |     $15000$     |     $15000$     |  $100$   |                     |\n|    $13$    |     $50000$     |     $50000$     |  $100$   |                     |\n|    $14$    | $2 \\times 10^5$ | $2 \\times 10^5$ |  $100$   |                     |\n|    $15$    |      $200$      |      $200$      |  $10^4$  | $n \\geq 100$        |\n|    $16$    |     $5000$      |     $5000$      |  $10^4$  | $n \\geq 100$        |\n|    $17$    | $2 \\times 10^5$ | $2 \\times 10^5$ |  $10^4$  | $n \\geq 100$        |\n|    $18$    |      $300$      |      $300$      |  $10^4$  | $B=3k-1,k \\in \\N^*$ |\n|    $19$    | $2 \\times 10^5$ | $2 \\times 10^5$ |  $10^4$  | $B=3k-1,k \\in \\N^*$ |\n|    $20$    |      $300$      |      $300$      |  $10^4$  | $B=3k,k \\in \\N^*$   |\n|    $21$    | $2 \\times 10^5$ | $2 \\times 10^5$ |  $10^4$  | $B=3k,k \\in \\N^*$   |\n|    $22$    |      $100$      |      $100$      |  $10^4$  |                     |\n|    $23$    |      $500$      |     $5000$      |  $10^4$  |                     |\n|    $24$    | $2 \\times 10^5$ | $2 \\times 10^5$ |  $10^4$  |                     |\n|    $25$    | $2 \\times 10^5$ | $2 \\times 10^5$ |  $10^4$  |                     |\n", "locale": "zh-CN"}}}
{"pid": "P8362", "type": "P", "difficulty": 7, "samples": [["1\n100\n2", "3728"], ["19260817\n1000000000\n3", "28745082"], ["114514233\n1919810233\n10", "135934411"], ["样例 4 见附件 digit4.in", "样例 4 见附件 digit4.ans"], ["样例 5 见附件 digit5.in", "样例 5 见附件 digit5.ans"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["各省省选", "2022", "O2优化", "陕西"], "title": "[SNOI2022] 数位", "background": "", "description": "小 S 是一个喜欢数数的女孩子。\n\n有一天，她在睡前躺在床上数数，当她数到 $977431$ 的时候，她终于困了，并且决定睡觉。但此时她突然发现这个数字的各位数码是单调不增的！她觉得这相当有趣，于是她又睡不着了。\n\n她想知道有多少个数在 $L, R$ 之间，并且它的各位数码是单调不增的。但这个问题太无聊了。\n\n她又想知道有多少数对 $(a, b)$ 在 $L, R$ 之间，并且 $(a + b)$ 的各位数码是单调不增的。但这个问题也太无聊了。\n\n终于，她想到了一个有趣一些的问题：\n\n给定整数 $L, R, k$，求有多少个 $k$ 维向量 $(a_1, a_2, ..., a_k)$ 满足 $(a_1 + a_2 + ... + a_k)$ 的数码是单调不增的，并且 $\\forall i \\in [1, k],  L \\leq a_i \\leq R$。\n\n由于答案可能很大，请你输出它对 $998244353$ 取模的结果。", "inputFormat": "输入的第一行是一个正整数 $L$，含义见【题目描述】。\n\n输入的第二行是一个正整数 $R$，含义见【题目描述】。\n\n输入的第三行是一个正整数 $k$，含义见【题目描述】。", "outputFormat": "输出一行一个整数表示合法的向量数，答案 $998244353$ 取模。", "hint": "**【数据规模与约定】**\n\n对于全部数据，$1 \\leq L \\leq R < 10^{1000}$，$1 \\leq k \\leq 50$。\n\n具体的数据规模与约定见下表。\n\n| 测试点编号 |    $R<$     | $k$  |\n| :--------: | :---------: | :--: |\n|    $1$     |   $10^6$    | $1$  |\n|    $2$     |   $10^6$    | $10$ |\n|    $3$     |   $10^6$    | $20$ |\n|    $4$     |   $10^6$    | $30$ |\n|    $5$     |   $10^6$    | $50$ |\n|    $6$     |  $10^{17}$  | $10$ |\n|    $7$     |  $10^{17}$  | $10$ |\n|    $8$     |  $10^{17}$  | $20$ |\n|    $9$     |  $10^{17}$  | $30$ |\n|    $10$    |  $10^{17}$  | $50$ |\n|    $11$    |  $10^{50}$  | $2$  |\n|    $12$    |  $10^{50}$  | $10$ |\n|    $13$    | $10^{100}$  | $2$  |\n|    $14$    | $10^{100}$  | $3$  |\n|    $15$    | $10^{100}$  | $10$ |\n|    $16$    | $10^{200}$  | $3$  |\n|    $17$    | $10^{200}$  | $10$ |\n|    $18$    | $10^{300}$  | $10$ |\n|    $19$    | $10^{300}$  | $10$ |\n|    $20$    | $10^{300}$  | $20$ |\n|    $21$    | $10^{500}$  | $10$ |\n|    $22$    | $10^{500}$  | $20$ |\n|    $23$    | $10^{1000}$ | $30$ |\n|    $24$    | $10^{1000}$  | $50$ |\n|    $25$    | $10^{1000}$  | $50$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[SNOI2022] 数位", "background": "", "description": "小 S 是一个喜欢数数的女孩子。\n\n有一天，她在睡前躺在床上数数，当她数到 $977431$ 的时候，她终于困了，并且决定睡觉。但此时她突然发现这个数字的各位数码是单调不增的！她觉得这相当有趣，于是她又睡不着了。\n\n她想知道有多少个数在 $L, R$ 之间，并且它的各位数码是单调不增的。但这个问题太无聊了。\n\n她又想知道有多少数对 $(a, b)$ 在 $L, R$ 之间，并且 $(a + b)$ 的各位数码是单调不增的。但这个问题也太无聊了。\n\n终于，她想到了一个有趣一些的问题：\n\n给定整数 $L, R, k$，求有多少个 $k$ 维向量 $(a_1, a_2, ..., a_k)$ 满足 $(a_1 + a_2 + ... + a_k)$ 的数码是单调不增的，并且 $\\forall i \\in [1, k],  L \\leq a_i \\leq R$。\n\n由于答案可能很大，请你输出它对 $998244353$ 取模的结果。", "inputFormat": "输入的第一行是一个正整数 $L$，含义见【题目描述】。\n\n输入的第二行是一个正整数 $R$，含义见【题目描述】。\n\n输入的第三行是一个正整数 $k$，含义见【题目描述】。", "outputFormat": "输出一行一个整数表示合法的向量数，答案 $998244353$ 取模。", "hint": "**【数据规模与约定】**\n\n对于全部数据，$1 \\leq L \\leq R < 10^{1000}$，$1 \\leq k \\leq 50$。\n\n具体的数据规模与约定见下表。\n\n| 测试点编号 |    $R<$     | $k$  |\n| :--------: | :---------: | :--: |\n|    $1$     |   $10^6$    | $1$  |\n|    $2$     |   $10^6$    | $10$ |\n|    $3$     |   $10^6$    | $20$ |\n|    $4$     |   $10^6$    | $30$ |\n|    $5$     |   $10^6$    | $50$ |\n|    $6$     |  $10^{17}$  | $10$ |\n|    $7$     |  $10^{17}$  | $10$ |\n|    $8$     |  $10^{17}$  | $20$ |\n|    $9$     |  $10^{17}$  | $30$ |\n|    $10$    |  $10^{17}$  | $50$ |\n|    $11$    |  $10^{50}$  | $2$  |\n|    $12$    |  $10^{50}$  | $10$ |\n|    $13$    | $10^{100}$  | $2$  |\n|    $14$    | $10^{100}$  | $3$  |\n|    $15$    | $10^{100}$  | $10$ |\n|    $16$    | $10^{200}$  | $3$  |\n|    $17$    | $10^{200}$  | $10$ |\n|    $18$    | $10^{300}$  | $10$ |\n|    $19$    | $10^{300}$  | $10$ |\n|    $20$    | $10^{300}$  | $20$ |\n|    $21$    | $10^{500}$  | $10$ |\n|    $22$    | $10^{500}$  | $20$ |\n|    $23$    | $10^{1000}$ | $30$ |\n|    $24$    | $10^{1000}$  | $50$ |\n|    $25$    | $10^{1000}$  | $50$ |", "locale": "zh-CN"}}}
{"pid": "P8363", "type": "P", "difficulty": 6, "samples": [["3\n-2 1 1 2\n1 0 2 1\n-3 -3 -2 0\n2\n1 2 ", "5\n15"], ["4\n5 1 8 4\n-8 1 -5 4\n-10 2 10 3\n6 0 8 10\n6\n1 2 3 4 7 9", "0\n5\n14\n18\n70\n100"], ["1\n1 1 1000000 1000000\n3\n100 10000 1000000", "10000\n100000000\n1000000000000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2009", "COI（克罗地亚）"], "title": "[COI 2009] PLAHTE", "background": "", "description": "地面上有 $N$ 条矩形床单，所有床单平行于坐标轴且没有任何一条床单覆盖 $(0,0)$。\n\n在 $0$ 时刻的时候油覆盖了 $(0,0)$ 这个格子，且每过一个时刻，油会向八个方向扩散。当油扩散到一个有床单的格子上，油会污染这个格子上的所有床单（只污染被污染的格子，其他未受污染的不算）。\n\n给定你一些时刻，在这些时刻上请你求出所有床单上被污染的格子的总面积。", "inputFormat": "第一行一个正整数 $N$，为床单的数量。\n\n接下来 $N$ 行，每行四个正整数 $x_1,y_1,x_2,y_2$，用 $(x_1,y_1)$ 与 $(x_2,y_2)$ 这两个坐标形成第 $i$ 条床单。\n\n接下来一行一个正整数 $M$，为时刻的数量。\n\n接下来一行 $M$ 个正整数，为时刻。", "outputFormat": "输出 $M$ 行，第 $i$ 行为第 $i$ 个时刻被污染的床单的面积（两条床单重合的话算两个）。", "hint": "$1\\le N,M\\le 10^5$。\n\n$-10^6\\le x_1\\le x_2\\le 10^6,-10^6\\le y_1\\le y_2\\le 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COI 2009] PLAHTE", "background": "", "description": "地面上有 $N$ 条矩形床单，所有床单平行于坐标轴且没有任何一条床单覆盖 $(0,0)$。\n\n在 $0$ 时刻的时候油覆盖了 $(0,0)$ 这个格子，且每过一个时刻，油会向八个方向扩散。当油扩散到一个有床单的格子上，油会污染这个格子上的所有床单（只污染被污染的格子，其他未受污染的不算）。\n\n给定你一些时刻，在这些时刻上请你求出所有床单上被污染的格子的总面积。", "inputFormat": "第一行一个正整数 $N$，为床单的数量。\n\n接下来 $N$ 行，每行四个正整数 $x_1,y_1,x_2,y_2$，用 $(x_1,y_1)$ 与 $(x_2,y_2)$ 这两个坐标形成第 $i$ 条床单。\n\n接下来一行一个正整数 $M$，为时刻的数量。\n\n接下来一行 $M$ 个正整数，为时刻。", "outputFormat": "输出 $M$ 行，第 $i$ 行为第 $i$ 个时刻被污染的床单的面积（两条床单重合的话算两个）。", "hint": "$1\\le N,M\\le 10^5$。\n\n$-10^6\\le x_1\\le x_2\\le 10^6,-10^6\\le y_1\\le y_2\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P8364", "type": "P", "difficulty": 6, "samples": [["20 4 5\n4 3 6 1", "3 3 3 2\n1 0 1 0"], ["100 3 5\n30 20 10", "4 3 3\n1 1 0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2009", "COI（克罗地亚）"], "title": "[COI 2009] IZBORI", "background": "", "description": "有 $V$ 个选民在为选举投票。这次选举有 $N$ 个党派参加，他们要共同争夺议会的 $M$ 个席位。\n\n假设党派编号为 $1$ 至 $N$，且他们分别获得 $v_1,v_2,\\cdots,v_n$ 票。席位分配如下：\n\n1. 所有获得少于 $5\\%$ 的票数的党派直接取消后续参选资格。\n\n2. 一开始议会不会为任何党派预留名额。\n\n3. 对于每个党派，计算 $Q_p=V_p\\div(S_p+1)$，其中 $V_p$ 是党派获得的总票数，$S_p$ 是已经分配给该党派的席位数量。\n\n4. $Q_p$ 最大的党派会获得一个席位。（相同则编号小的获得）\n\n5. 重复第三四步直到满员。\n\n现在已经清点了部分选票，知道了党派现在获得的票数，编写程序以求出在所有可能的情况下，各个党派可能获得的最多或最少席位。\n", "inputFormat": "第一行三个正整数 $V,N,M$。\n\n第二行 $N$ 个正整数，为各个党派目前获得的票数，保证其总和不超过 $V$。", "outputFormat": "输出第一行 $N$ 个整数，为各个党派最多可能得到席位数。\n\n输出第二行 $N$ 个整数，为各个党派最少可能得到席位数。", "hint": "正确输出第一行获得 $20\\%$ 的分数。正确输出第二行获得 $80\\%$ 的分数。\n\n$1\\le V\\le 10^7,1\\le N\\le 100,1\\le M\\le 200$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COI 2009] IZBORI", "background": "", "description": "有 $V$ 个选民在为选举投票。这次选举有 $N$ 个党派参加，他们要共同争夺议会的 $M$ 个席位。\n\n假设党派编号为 $1$ 至 $N$，且他们分别获得 $v_1,v_2,\\cdots,v_n$ 票。席位分配如下：\n\n1. 所有获得少于 $5\\%$ 的票数的党派直接取消后续参选资格。\n\n2. 一开始议会不会为任何党派预留名额。\n\n3. 对于每个党派，计算 $Q_p=V_p\\div(S_p+1)$，其中 $V_p$ 是党派获得的总票数，$S_p$ 是已经分配给该党派的席位数量。\n\n4. $Q_p$ 最大的党派会获得一个席位。（相同则编号小的获得）\n\n5. 重复第三四步直到满员。\n\n现在已经清点了部分选票，知道了党派现在获得的票数，编写程序以求出在所有可能的情况下，各个党派可能获得的最多或最少席位。\n", "inputFormat": "第一行三个正整数 $V,N,M$。\n\n第二行 $N$ 个正整数，为各个党派目前获得的票数，保证其总和不超过 $V$。", "outputFormat": "输出第一行 $N$ 个整数，为各个党派最多可能得到席位数。\n\n输出第二行 $N$ 个整数，为各个党派最少可能得到席位数。", "hint": "正确输出第一行获得 $20\\%$ 的分数。正确输出第二行获得 $80\\%$ 的分数。\n\n$1\\le V\\le 10^7,1\\le N\\le 100,1\\le M\\le 200$。", "locale": "zh-CN"}}}
{"pid": "P8365", "type": "P", "difficulty": 5, "samples": [["5\n1 2 3 4 5\n100 200 300 400 500\n", "18060\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "各省省选", "2022", "O2优化", "辽宁"], "title": "[LNOI2022] 吃", "background": "", "description": "小 A 很喜欢吃东西。\n\n小 A 面前有 $n$ 份食物，第 $i$ 份有参数 $a_i$ 和 $b_i$。小 A 可以按照**任意顺序**吃掉这 $n$ 份食物。当她吃掉编号为 $i$ 的食物时，她可以选择将自己的体重乘以 $a_i$ 或者将自己的体重加上 $b_i$。每份食物只能吃恰好一次。\n\n小 A 的初始体重为 $1$，请求出她吃完 $n$ 份食物后能达到的**最大**体重。答案可能很大，你只需要输出其对 $({10}^9 + 7)$ 取模后的结果。\n\n**注意：你需要最大化体重并将该最大值对 $\\bm{({10}^9 + 7)}$ 取模，而非最大化体重对 $\\bm{({10}^9 + 7)}$ 取模的结果。**", "inputFormat": "第一行输入一个整数 $n$ 表示食物的数量。第二行 $n$ 个整数 $a_1, a_2, \\ldots, a_n$，第三行 $n$ 个整数 $b_1, b_2, \\ldots, b_n$，表示每份食物的参数。", "outputFormat": "输出一个整数，表示小 A 可以得到的最大体重对 $({10}^9 + 7)$ 取模后的结果。", "hint": "**【样例解释 #1】**\n\n以下方案可以达到最大体重：\n\n- 吃掉第一份食物并选择将体重增加 $100$，体重变为 $101$；\n- 吃掉第二份食物并选择将体重增加 $200$，体重变为 $301$；\n- 吃掉第三份食物并选择将体重乘 $3$，体重变为 $903$；\n- 吃掉第四份食物并选择将体重乘 $4$，体重变为 $3612$；\n- 吃掉第五份食物并选择将体重乘 $5$，体重变为 $18060$。\n\n**【样例 #2】**\n\n见附件中的 `food/food2.in` 与 `food/food2.ans`。\n\n该组样例满足 $n \\le 10$ 和特殊性质 E。\n\n**【样例 #3】**\n\n见附件中的 `food/food3.in` 与 `food/food3.ans`。\n\n该组样例满足 $n \\le 20$ 和特殊性质 E。\n\n**【样例 #4】**\n\n见附件中的 `food/food4.in` 与 `food/food4.ans`。\n\n该组样例满足 $n \\le 2000$。\n\n**【样例 #5】**\n\n见附件中的 `food/food5.in` 与 `food/food5.ans`。\n\n该组样例满足特殊性质 A。\n\n**【样例 #6】**\n\n见附件中的 `food/food6.in` 与 `food/food6.ans`。\n\n该组样例满足特殊性质 C。\n\n**【样例 #7】**\n\n见附件中的 `food/food7.in` 与 `food/food7.ans`。\n\n该组样例满足特殊性质 D。\n\n**【样例 #8】**\n\n见附件中的 `food/food8.in` 与 `food/food8.ans`。\n\n该组样例满足特殊性质 B。\n\n**【样例 #9】**\n\n见附件中的 `food/food9.in` 与 `food/food9.ans`。\n\n**【数据范围】**\n\n对于 $100 \\%$ 的测试数据，$1 \\le n \\le 5 \\times {10}^5$，$1 \\le a_i, b_i \\le {10}^6$。\n\n| 测试点编号 | $n \\le $ | 特殊性质 |\n|:-:|:-:|:-:|\n| $1$ | $10$ | DE |\n| $2$ | $10$ | E |\n| $3$ | $10$ | AE |\n| $4$ | $10$ | E |\n| $5$ | $20$ | DE |\n| $6$ | $20$ | E |\n| $7$ | $20$ | E |\n| $8$ | $20$ | E |\n| $9$ | $2000$ | D |\n| $10$ | $2000$ | 无 |\n| $11$ | $2000$ | 无 |\n| $12$ | $2000$ | 无 |\n| $13$ | $5 \\times {10}^5$ | BD |\n| $14$ | $5 \\times {10}^5$ | B |\n| $15$ | $5 \\times {10}^5$ | C |\n| $16$ | $5 \\times {10}^5$ | C |\n| $17$ | ${10}^5$ | 无 |\n| $18$ | ${10}^5$ | 无 |\n| $19$ | $5 \\times {10}^5$ | 无 |\n| $20$ | $5 \\times {10}^5$ | 无 |\n\n特殊性质 A：$a_i = 1$。  \n特殊性质 B：$a_i \\ge b_i$。  \n特殊性质 C：$a_i, b_i$ 在 $[1, {10}^6]$ 内独立均匀随机生成。  \n特殊性质 D：$a_i \\ge 2$。  \n特殊性质 E：$a_i \\le 4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[LNOI2022] 吃", "background": "", "description": "小 A 很喜欢吃东西。\n\n小 A 面前有 $n$ 份食物，第 $i$ 份有参数 $a_i$ 和 $b_i$。小 A 可以按照**任意顺序**吃掉这 $n$ 份食物。当她吃掉编号为 $i$ 的食物时，她可以选择将自己的体重乘以 $a_i$ 或者将自己的体重加上 $b_i$。每份食物只能吃恰好一次。\n\n小 A 的初始体重为 $1$，请求出她吃完 $n$ 份食物后能达到的**最大**体重。答案可能很大，你只需要输出其对 $({10}^9 + 7)$ 取模后的结果。\n\n**注意：你需要最大化体重并将该最大值对 $\\bm{({10}^9 + 7)}$ 取模，而非最大化体重对 $\\bm{({10}^9 + 7)}$ 取模的结果。**", "inputFormat": "第一行输入一个整数 $n$ 表示食物的数量。第二行 $n$ 个整数 $a_1, a_2, \\ldots, a_n$，第三行 $n$ 个整数 $b_1, b_2, \\ldots, b_n$，表示每份食物的参数。", "outputFormat": "输出一个整数，表示小 A 可以得到的最大体重对 $({10}^9 + 7)$ 取模后的结果。", "hint": "**【样例解释 #1】**\n\n以下方案可以达到最大体重：\n\n- 吃掉第一份食物并选择将体重增加 $100$，体重变为 $101$；\n- 吃掉第二份食物并选择将体重增加 $200$，体重变为 $301$；\n- 吃掉第三份食物并选择将体重乘 $3$，体重变为 $903$；\n- 吃掉第四份食物并选择将体重乘 $4$，体重变为 $3612$；\n- 吃掉第五份食物并选择将体重乘 $5$，体重变为 $18060$。\n\n**【样例 #2】**\n\n见附件中的 `food/food2.in` 与 `food/food2.ans`。\n\n该组样例满足 $n \\le 10$ 和特殊性质 E。\n\n**【样例 #3】**\n\n见附件中的 `food/food3.in` 与 `food/food3.ans`。\n\n该组样例满足 $n \\le 20$ 和特殊性质 E。\n\n**【样例 #4】**\n\n见附件中的 `food/food4.in` 与 `food/food4.ans`。\n\n该组样例满足 $n \\le 2000$。\n\n**【样例 #5】**\n\n见附件中的 `food/food5.in` 与 `food/food5.ans`。\n\n该组样例满足特殊性质 A。\n\n**【样例 #6】**\n\n见附件中的 `food/food6.in` 与 `food/food6.ans`。\n\n该组样例满足特殊性质 C。\n\n**【样例 #7】**\n\n见附件中的 `food/food7.in` 与 `food/food7.ans`。\n\n该组样例满足特殊性质 D。\n\n**【样例 #8】**\n\n见附件中的 `food/food8.in` 与 `food/food8.ans`。\n\n该组样例满足特殊性质 B。\n\n**【样例 #9】**\n\n见附件中的 `food/food9.in` 与 `food/food9.ans`。\n\n**【数据范围】**\n\n对于 $100 \\%$ 的测试数据，$1 \\le n \\le 5 \\times {10}^5$，$1 \\le a_i, b_i \\le {10}^6$。\n\n| 测试点编号 | $n \\le $ | 特殊性质 |\n|:-:|:-:|:-:|\n| $1$ | $10$ | DE |\n| $2$ | $10$ | E |\n| $3$ | $10$ | AE |\n| $4$ | $10$ | E |\n| $5$ | $20$ | DE |\n| $6$ | $20$ | E |\n| $7$ | $20$ | E |\n| $8$ | $20$ | E |\n| $9$ | $2000$ | D |\n| $10$ | $2000$ | 无 |\n| $11$ | $2000$ | 无 |\n| $12$ | $2000$ | 无 |\n| $13$ | $5 \\times {10}^5$ | BD |\n| $14$ | $5 \\times {10}^5$ | B |\n| $15$ | $5 \\times {10}^5$ | C |\n| $16$ | $5 \\times {10}^5$ | C |\n| $17$ | ${10}^5$ | 无 |\n| $18$ | ${10}^5$ | 无 |\n| $19$ | $5 \\times {10}^5$ | 无 |\n| $20$ | $5 \\times {10}^5$ | 无 |\n\n特殊性质 A：$a_i = 1$。  \n特殊性质 B：$a_i \\ge b_i$。  \n特殊性质 C：$a_i, b_i$ 在 $[1, {10}^6]$ 内独立均匀随机生成。  \n特殊性质 D：$a_i \\ge 2$。  \n特殊性质 E：$a_i \\le 4$。", "locale": "zh-CN"}}}
{"pid": "P8366", "type": "P", "difficulty": 5, "samples": [["5\n1\n123\n1\n100\n1\n000\n2\n321321\n2\n000001\n", "0\n1\n3\n6\n60\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "各省省选", "2022", "O2优化", "辽宁"], "title": "[LNOI2022] 题", "background": "", "description": "给定长度为 $3 n$、值域为 $[0, 3]$ 的整数序列 $S = s_1 s_2 \\cdots s_{3 n}$。你需要首先将 $S$ 中的每个 $0$ 替换为 $[1, 3]$ 中的任意一个整数，得到序列 $T = t_1 t_2 \\cdots t_{3 n}$，然后给出 $n$ 个长度为 $3$ 的整数序列 ${\\{ a_{i, 1}, a_{i, 2}, a_{i, 3} \\}}_{1 \\le i \\le n}$，使得\n\n- $\\forall 1 \\le i \\le n$，$1 \\le a_{i, 1} < a_{i, 2} < a_{i, 3} \\le 3 n$；\n- $\\forall (i_1, j_1) \\ne (i_2, j_2)$，$a_{i_1, j_1} \\ne a_{i_2, j_2}$；\n- $\\forall 1 \\le i \\le n$，$\\{ t_{a_{i, 1}}, t_{a_{i, 2}}, t_{a_{i, 3}} \\}$ 是 $\\{ 1, 2, 3 \\}$ 的一个排列且逆序对数为奇数。\n\n认为两个方案本质不同当且仅当序列 $T$ 不同或存在 $a_{i, j}$（$1 \\le i \\le n$，$1 \\le j \\le 3$）不同，求以上操作的本质不同的方案数，对 $({10}^9 + 7)$ 取模。", "inputFormat": "**本题有多组测试数据**。输入的第一行包含一个正整数 $C$ 表示测试数据组数。\n\n对于每组测试数据，第一行一个整数 $n$，接下来一行一个长度为 $3 n$ 的字符串描述序列 $S$。", "outputFormat": "对于每组测试数据输出一行一个整数表示方案数对 $({10}^9 + 7)$ 取模的结果。", "hint": "**【样例解释 \\#1】**\n\n前三组测试数据中 $n = 1$，故 $\\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \\} = \\{ 1, 2, 3 \\}$。\n\n对于第一组测试数据，只能有 $T = 123$，而 $\\{ 1, 2, 3 \\}$ 的逆序对数为 $0$ 不合法，故不存在方案。\n\n对于第二组测试数据，$T = 123$ 不合法，而 $T = 132$ 时 $\\{ 1, 3, 2 \\}$ 的逆序对数为 $1$ 合法，故存在一个方案。\n\n对于第三组测试数据，取 $T = 132$，$T = 213$，$T = 321$ 可以得到三个合法方案。\n\n对于第四组测试数据，$T = 321321$，有如下六种方案：\n\n- $\\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \\} = \\{ 1, 2, 3 \\}$，$\\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \\} = \\{ 4, 5, 6 \\}$\n- $\\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \\} = \\{ 4, 5, 6 \\}$，$\\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \\} = \\{ 1, 2, 3 \\}$\n- $\\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \\} = \\{ 1, 2, 6 \\}$，$\\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \\} = \\{ 3, 4, 5 \\}$\n- $\\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \\} = \\{ 3, 4, 5 \\}$，$\\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \\} = \\{ 1, 2, 6 \\}$\n- $\\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \\} = \\{ 1, 5, 6 \\}$，$\\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \\} = \\{ 2, 3, 4 \\}$\n- $\\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \\} = \\{ 2, 3, 4 \\}$，$\\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \\} = \\{ 1, 5, 6 \\}$\n\n**【样例 \\#2】**\n\n见附件中的 ` problem/problem2.in` 与 `problem/problem2.ans`。\n\n该组样例中五组数据的 $n$ 分别为 $3, 5, 8, 12, 17$。\n\n**【样例 \\#3】**\n\n见选手目录下的 `problem/problem3.in` 与 `problem/problem3.ans`。\n\n该组样例满足特殊性质 A，五组数据的 $n$ 分别为 $2, 4, 7, 15, 19$。\n\n**【数据范围】**\n\n对于所有测试数据，$1 \\le C \\le 5$，$1 \\le n \\le 19$，字符串 $S$ 的长度为 $3 n$ 且仅由 $0, 1, 2, 3$ 构成。\n\n| 测试点编号 | $n \\le$ | 特殊性质 |\n|:-:|:-:|:-:|\n| $1$ | $1$ | 无 |\n| $2$ | $2$ | 无 |\n| $3$ | $3$ | 无 |\n| $4$ | $5$ | A |\n| $5$ | $7$ | 无 |\n| $6$ | $10$ | 无 |\n| $7$ | $13$ | A |\n| $8$ | $16$ | 无 |\n| $9$ | $18$ | 无 |\n| $10$ | $19$ | 无 |\n\n特殊性质 A：字符串 $S$ 由全 $0$ 的字符串构成。\n\n**【提示】**\n\n请注意程序的空间消耗。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[LNOI2022] 题", "background": "", "description": "给定长度为 $3 n$、值域为 $[0, 3]$ 的整数序列 $S = s_1 s_2 \\cdots s_{3 n}$。你需要首先将 $S$ 中的每个 $0$ 替换为 $[1, 3]$ 中的任意一个整数，得到序列 $T = t_1 t_2 \\cdots t_{3 n}$，然后给出 $n$ 个长度为 $3$ 的整数序列 ${\\{ a_{i, 1}, a_{i, 2}, a_{i, 3} \\}}_{1 \\le i \\le n}$，使得\n\n- $\\forall 1 \\le i \\le n$，$1 \\le a_{i, 1} < a_{i, 2} < a_{i, 3} \\le 3 n$；\n- $\\forall (i_1, j_1) \\ne (i_2, j_2)$，$a_{i_1, j_1} \\ne a_{i_2, j_2}$；\n- $\\forall 1 \\le i \\le n$，$\\{ t_{a_{i, 1}}, t_{a_{i, 2}}, t_{a_{i, 3}} \\}$ 是 $\\{ 1, 2, 3 \\}$ 的一个排列且逆序对数为奇数。\n\n认为两个方案本质不同当且仅当序列 $T$ 不同或存在 $a_{i, j}$（$1 \\le i \\le n$，$1 \\le j \\le 3$）不同，求以上操作的本质不同的方案数，对 $({10}^9 + 7)$ 取模。", "inputFormat": "**本题有多组测试数据**。输入的第一行包含一个正整数 $C$ 表示测试数据组数。\n\n对于每组测试数据，第一行一个整数 $n$，接下来一行一个长度为 $3 n$ 的字符串描述序列 $S$。", "outputFormat": "对于每组测试数据输出一行一个整数表示方案数对 $({10}^9 + 7)$ 取模的结果。", "hint": "**【样例解释 \\#1】**\n\n前三组测试数据中 $n = 1$，故 $\\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \\} = \\{ 1, 2, 3 \\}$。\n\n对于第一组测试数据，只能有 $T = 123$，而 $\\{ 1, 2, 3 \\}$ 的逆序对数为 $0$ 不合法，故不存在方案。\n\n对于第二组测试数据，$T = 123$ 不合法，而 $T = 132$ 时 $\\{ 1, 3, 2 \\}$ 的逆序对数为 $1$ 合法，故存在一个方案。\n\n对于第三组测试数据，取 $T = 132$，$T = 213$，$T = 321$ 可以得到三个合法方案。\n\n对于第四组测试数据，$T = 321321$，有如下六种方案：\n\n- $\\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \\} = \\{ 1, 2, 3 \\}$，$\\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \\} = \\{ 4, 5, 6 \\}$\n- $\\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \\} = \\{ 4, 5, 6 \\}$，$\\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \\} = \\{ 1, 2, 3 \\}$\n- $\\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \\} = \\{ 1, 2, 6 \\}$，$\\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \\} = \\{ 3, 4, 5 \\}$\n- $\\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \\} = \\{ 3, 4, 5 \\}$，$\\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \\} = \\{ 1, 2, 6 \\}$\n- $\\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \\} = \\{ 1, 5, 6 \\}$，$\\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \\} = \\{ 2, 3, 4 \\}$\n- $\\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \\} = \\{ 2, 3, 4 \\}$，$\\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \\} = \\{ 1, 5, 6 \\}$\n\n**【样例 \\#2】**\n\n见附件中的 ` problem/problem2.in` 与 `problem/problem2.ans`。\n\n该组样例中五组数据的 $n$ 分别为 $3, 5, 8, 12, 17$。\n\n**【样例 \\#3】**\n\n见选手目录下的 `problem/problem3.in` 与 `problem/problem3.ans`。\n\n该组样例满足特殊性质 A，五组数据的 $n$ 分别为 $2, 4, 7, 15, 19$。\n\n**【数据范围】**\n\n对于所有测试数据，$1 \\le C \\le 5$，$1 \\le n \\le 19$，字符串 $S$ 的长度为 $3 n$ 且仅由 $0, 1, 2, 3$ 构成。\n\n| 测试点编号 | $n \\le$ | 特殊性质 |\n|:-:|:-:|:-:|\n| $1$ | $1$ | 无 |\n| $2$ | $2$ | 无 |\n| $3$ | $3$ | 无 |\n| $4$ | $5$ | A |\n| $5$ | $7$ | 无 |\n| $6$ | $10$ | 无 |\n| $7$ | $13$ | A |\n| $8$ | $16$ | 无 |\n| $9$ | $18$ | 无 |\n| $10$ | $19$ | 无 |\n\n特殊性质 A：字符串 $S$ 由全 $0$ 的字符串构成。\n\n**【提示】**\n\n请注意程序的空间消耗。", "locale": "zh-CN"}}}
{"pid": "P8367", "type": "P", "difficulty": 7, "samples": [["2\n2\n2 3\n65472\n5\n1 3 2 1 1\n2 3 3 3\n", "589248\n8589\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["各省省选", "2022", "O2优化", "辽宁"], "title": "[LNOI2022] 盒", "background": null, "description": "有 $n$ 个不同的盒子排成一排。在初始状态下，第 $i$ 个盒子放有 $a_i$ 个货物，总货物数量为 $S = \\sum_{i = 1}^{n} a_i$。对于非负整数数组 $(b_1, b_2, \\ldots, b_n)$ 满足 $\\sum_{i = 1}^{n} b_i = S$，考察以下问题：\n\n你想让第 $i$ 个盒子中拥有恰好 $b_i$ 个货物，为此你可以做如下操作若干次：对两个相邻的盒子，把其中一个盒子的**恰好一个**货物移动至另一个。对 $i, i + 1$（$1 \\le i < n$）号盒子做**一次**操作的代价为 $w_i$。**注意：将 $\\bm{i}$ 号盒子的一个货物移动到 $\\bm{i + 1}$ 号盒子和将 $\\bm{i + 1}$ 号盒子的一个货物移动到 $\\bm{i}$ 号盒子的代价都是 $\\bm{w_i}$**。你需要保证在操作中不存在盒子中的货物数量是负数。\n\n在以上问题下，定义从初始状态达到第 $i$ 个盒子拥有恰好 $b_i$ 个货物的状态的最小代价为 $\\operatorname{val}(b_1, b_2, \\ldots, b_n)$，你需要求出对所有满足 $\\sum_{i = 1}^{n} b_i = S$ 的非负整数数组 $(b_1, b_2, \\ldots, b_n)$，$\\operatorname{val}(b_1, b_2, \\ldots, b_n)$ 的和。输出这个答案对 $998244353$ 取模后的结果。", "inputFormat": "**本题有多组测试数据**。输入的第一行包含一个正整数 $T$，表示测试数据组数。\n\n对于每组数据，输入共三行。第一行一个正整数 $n$ 表示盒子的个数，第二行 $n$ 个非负整数 $a_1, a_2, \\ldots, a_n$ 描述初始状态，第三行 $n - 1$ 个非负整数 $w_1, w_2, \\ldots, w_{n - 1}$ 描述移动货物的代价。", "outputFormat": "对于每组测试数据输出一行一个整数，表示对于所有满足 $\\sum_{i = 1}^{n} b_i = S$ 的非负整数数组，达到目标的代价的最小值之和模 $998244353$ 的结果。", "hint": "**【样例解释 \\#1】**\n\n对于第一组数据，一共有六种需要考虑的情形，它们的 $b_1$ 和 $b_2$ 构成的二元组 $(b_1, b_2)$ 分别为 $(0, 5), (1, 4), (2, 3), (3, 2), (4, 1), (5, 0)$。\n\n对于第一种情形，需要至少 $2$ 次移动，代价最小值为 $65472 \\times 2 = 130944$。\n\n对于第二种情形，需要至少 $1$ 次移动，代价最小值为 $65472$。\n\n对于第三种情形，不需要做任何操作，代价最小值为 $0$。\n\n对于第四种情形，需要至少 $1$ 次移动，代价最小值为 $65472$。\n\n对于第五种情形，需要至少 $2$ 次移动，代价最小值为 $65472 \\times 2 = 130944$。\n\n对于最后一种情形，需要至少 $3$ 次移动，代价最小值为 $65472 \\times 3 = 196416$。\n\n因此，最小代价之和为 $130944 + 65472 + 0 + 65472 + 130944 + 196416 = 589248$。\n\n**【样例 \\#2】**\n\n见附件中的 `box/box2.in` 与 `box/box2.ans`。\n\n这个样例满足测试点 $5 \\sim 8$ 的限制。\n\n**【样例 \\#3】**\n\n见附件中的 `box/box3.in` 与 `box/box3.ans`。\n\n这个样例满足测试点 $9 \\sim 12$ 的限制。\n\n**【样例 \\#4】**\n\n见附件中的 `box/box4.in` 与 `box/box4.ans`。\n\n这个样例满足测试点 $13 \\sim 14$ 的限制。\n\n**【样例 \\#5】**\n\n见附件中的 `box/box5.in` 与 `box/box5.ans`。\n\n这个样例满足测试点 $15 \\sim 16$ 的限制。\n\n**【样例 \\#6】**\n\n见附件中的 `box/box6.in` 与 `box/box6.ans`。\n\n这个样例满足测试点 $17 \\sim 18$ 的限制。\n\n**【数据范围】**\n\n保证对于任何测试点的任何一组数据，有 $2 \\le n \\le 5 \\times {10}^5$，$1 \\le S \\le 2 \\times {10}^6$，$a_i \\ge 0$，$0 \\le w_i < 998244353$。\n\n| 测试点编号 | $T \\le$ | $n \\le$ | $S \\le$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|:-:|\n| $1 \\sim 2$ | $1000$ | $5$ | $5$ | A |\n| $3 \\sim 4$ | $5$ | $9$ | $9$ | 无 |\n| $5 \\sim 8$ | $10$ | $2000$ | $2000$ | 无 |\n| $9 \\sim 12$ | $10$ | $2000$ | $2 \\times {10}^5$ | 无 |\n| $13 \\sim 14$ | $2$ | $2 \\times {10}^5$ | $2 \\times {10}^5$ | B |\n| $15 \\sim 16$ | $2$ | $2 \\times {10}^5$ | $2 \\times {10}^5$ | AC |\n| $17 \\sim 18$ | $2$ | $2 \\times {10}^5$ | $2 \\times {10}^5$ | 无 |\n| $19 \\sim 20$ | $5$ | $5 \\times {10}^5$ | $2 \\times {10}^6$ | 无 |\n\n特殊性质 A：对于任意 $1 \\le i < n$，$w_i = 1$。  \n特殊性质 B：对于任意 $1 \\le i < n - 20$，$a_i = 0$。  \n特殊性质 C：最多只有 $20$ 个 $i \\in [1, n]$ 满足 $a_i \\ne 0$。\n\n**【提示】**\n\n本题有读入量较大的测试点，为了优化程序运行的时间，我们建议你采用较为快速的读入方式。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[LNOI2022] 盒", "background": null, "description": "有 $n$ 个不同的盒子排成一排。在初始状态下，第 $i$ 个盒子放有 $a_i$ 个货物，总货物数量为 $S = \\sum_{i = 1}^{n} a_i$。对于非负整数数组 $(b_1, b_2, \\ldots, b_n)$ 满足 $\\sum_{i = 1}^{n} b_i = S$，考察以下问题：\n\n你想让第 $i$ 个盒子中拥有恰好 $b_i$ 个货物，为此你可以做如下操作若干次：对两个相邻的盒子，把其中一个盒子的**恰好一个**货物移动至另一个。对 $i, i + 1$（$1 \\le i < n$）号盒子做**一次**操作的代价为 $w_i$。**注意：将 $\\bm{i}$ 号盒子的一个货物移动到 $\\bm{i + 1}$ 号盒子和将 $\\bm{i + 1}$ 号盒子的一个货物移动到 $\\bm{i}$ 号盒子的代价都是 $\\bm{w_i}$**。你需要保证在操作中不存在盒子中的货物数量是负数。\n\n在以上问题下，定义从初始状态达到第 $i$ 个盒子拥有恰好 $b_i$ 个货物的状态的最小代价为 $\\operatorname{val}(b_1, b_2, \\ldots, b_n)$，你需要求出对所有满足 $\\sum_{i = 1}^{n} b_i = S$ 的非负整数数组 $(b_1, b_2, \\ldots, b_n)$，$\\operatorname{val}(b_1, b_2, \\ldots, b_n)$ 的和。输出这个答案对 $998244353$ 取模后的结果。", "inputFormat": "**本题有多组测试数据**。输入的第一行包含一个正整数 $T$，表示测试数据组数。\n\n对于每组数据，输入共三行。第一行一个正整数 $n$ 表示盒子的个数，第二行 $n$ 个非负整数 $a_1, a_2, \\ldots, a_n$ 描述初始状态，第三行 $n - 1$ 个非负整数 $w_1, w_2, \\ldots, w_{n - 1}$ 描述移动货物的代价。", "outputFormat": "对于每组测试数据输出一行一个整数，表示对于所有满足 $\\sum_{i = 1}^{n} b_i = S$ 的非负整数数组，达到目标的代价的最小值之和模 $998244353$ 的结果。", "hint": "**【样例解释 \\#1】**\n\n对于第一组数据，一共有六种需要考虑的情形，它们的 $b_1$ 和 $b_2$ 构成的二元组 $(b_1, b_2)$ 分别为 $(0, 5), (1, 4), (2, 3), (3, 2), (4, 1), (5, 0)$。\n\n对于第一种情形，需要至少 $2$ 次移动，代价最小值为 $65472 \\times 2 = 130944$。\n\n对于第二种情形，需要至少 $1$ 次移动，代价最小值为 $65472$。\n\n对于第三种情形，不需要做任何操作，代价最小值为 $0$。\n\n对于第四种情形，需要至少 $1$ 次移动，代价最小值为 $65472$。\n\n对于第五种情形，需要至少 $2$ 次移动，代价最小值为 $65472 \\times 2 = 130944$。\n\n对于最后一种情形，需要至少 $3$ 次移动，代价最小值为 $65472 \\times 3 = 196416$。\n\n因此，最小代价之和为 $130944 + 65472 + 0 + 65472 + 130944 + 196416 = 589248$。\n\n**【样例 \\#2】**\n\n见附件中的 `box/box2.in` 与 `box/box2.ans`。\n\n这个样例满足测试点 $5 \\sim 8$ 的限制。\n\n**【样例 \\#3】**\n\n见附件中的 `box/box3.in` 与 `box/box3.ans`。\n\n这个样例满足测试点 $9 \\sim 12$ 的限制。\n\n**【样例 \\#4】**\n\n见附件中的 `box/box4.in` 与 `box/box4.ans`。\n\n这个样例满足测试点 $13 \\sim 14$ 的限制。\n\n**【样例 \\#5】**\n\n见附件中的 `box/box5.in` 与 `box/box5.ans`。\n\n这个样例满足测试点 $15 \\sim 16$ 的限制。\n\n**【样例 \\#6】**\n\n见附件中的 `box/box6.in` 与 `box/box6.ans`。\n\n这个样例满足测试点 $17 \\sim 18$ 的限制。\n\n**【数据范围】**\n\n保证对于任何测试点的任何一组数据，有 $2 \\le n \\le 5 \\times {10}^5$，$1 \\le S \\le 2 \\times {10}^6$，$a_i \\ge 0$，$0 \\le w_i < 998244353$。\n\n| 测试点编号 | $T \\le$ | $n \\le$ | $S \\le$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|:-:|\n| $1 \\sim 2$ | $1000$ | $5$ | $5$ | A |\n| $3 \\sim 4$ | $5$ | $9$ | $9$ | 无 |\n| $5 \\sim 8$ | $10$ | $2000$ | $2000$ | 无 |\n| $9 \\sim 12$ | $10$ | $2000$ | $2 \\times {10}^5$ | 无 |\n| $13 \\sim 14$ | $2$ | $2 \\times {10}^5$ | $2 \\times {10}^5$ | B |\n| $15 \\sim 16$ | $2$ | $2 \\times {10}^5$ | $2 \\times {10}^5$ | AC |\n| $17 \\sim 18$ | $2$ | $2 \\times {10}^5$ | $2 \\times {10}^5$ | 无 |\n| $19 \\sim 20$ | $5$ | $5 \\times {10}^5$ | $2 \\times {10}^6$ | 无 |\n\n特殊性质 A：对于任意 $1 \\le i < n$，$w_i = 1$。  \n特殊性质 B：对于任意 $1 \\le i < n - 20$，$a_i = 0$。  \n特殊性质 C：最多只有 $20$ 个 $i \\in [1, n]$ 满足 $a_i \\ne 0$。\n\n**【提示】**\n\n本题有读入量较大的测试点，为了优化程序运行的时间，我们建议你采用较为快速的读入方式。", "locale": "zh-CN"}}}
{"pid": "P8368", "type": "P", "difficulty": 7, "samples": [["3\nabcd\nabab\na\n", "2\n3\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["各省省选", "2022", "后缀自动机 SAM", "O2优化", "辽宁", "后缀数组 SA"], "title": "[LNOI2022] 串", "background": "", "description": "为了让你更好地理解题面，给出若干关于字符串的定义：\n\n- 对于一个字符串 $S = s_1 s_2 \\cdots s_n$，定义其长度为 $\\lvert S \\rvert = n$。\n- 对于两个字符串 $S = s_1 s_2 \\cdots s_n$ 和 $T = t_1 t_2 \\cdots t_m$，称 $T$ 为 $S$ 的子串，若 $m = 0$（即 $T$ 为空串）或者 $\\exists 1 \\le i \\le j \\le n$，$T = s_i s_{i + 1} \\cdots s_j$。若 $m = 0$ 或上述判断条件中 $i$ 可以取到 $1$，则称 $T$ 为 $S$ 的前缀；若 $m = 0$ 或上述判断条件中 $j$ 可以取到 $n$，则称 $T$ 为 $S$ 的后缀。\n\n给定一个英文小写字母构成的字符串 $S$，你需要找到一个尽可能长的字符串序列 $(T_0, T_1, \\ldots, T_l)$，满足：\n\n- $T_0$ 是 $S$ 的子串；\n- $\\forall 1 \\le i \\le l$，$\\lvert T_i \\rvert - \\lvert T_{i - 1} \\rvert = 1$；\n- $\\forall 1 \\le i \\le l$，存在 $S$ 的一个长度为 $\\lvert T_i \\rvert + 1$ 的子串 $S'_i$，使得 $S'_i$ 的长度为 $\\lvert T_{i - 1} \\rvert$ 的前缀为 $T_{i - 1}$，长度为 $\\lvert T_i \\rvert$ 的后缀为 $T_i$。\n\n输出这样的字符串序列的长度的最大值（即 $l$ 的最大值）。", "inputFormat": "**本题有多组测试数据**。输入的第一行为一个整数 $T$，表示测试数据组数。对于每组测试数据，输入一行一个英文小写字母构成的字符串 $S$。", "outputFormat": "对于每组测试数据输出一行一个整数，表示题目描述中字符串序列长度的最大值。", "hint": "**【样例解释 \\#1】**\n\n下文中使用符号 $\\epsilon$ 表示空串。\n\n对于第一组测试数据，可以找到如下字符串序列：$T_0 = \\epsilon, T_1 = \\texttt{b}, T_2 = \\texttt{cd}$，其中 $S'_1 = \\texttt{ab}, S'_2 = \\texttt{bcd}$。\n\n对于第二组测试数据，可以找到如下字符串序列：$T_0 = \\epsilon, T_1 = \\texttt{b}, T_2 = \\texttt{ab}, T_3 = \\texttt{bab}$，其中 $S'_1 = \\texttt{ab}, S'_2 = \\texttt{bab}, S'_3 = \\texttt{abab}$。\n\n对于第三组测试数据，可以找到如下字符串序列：$T_0 = \\epsilon$。\n\n**【样例 \\#2】**\n\n见附件中的 `string/string2.in` 与 `string/string2.ans`。\n\n该组样例中的字符串长度有一定梯度，你可以利用该组样例对程序进行检查。\n\n**【样例 \\#3】**\n\n见附件中的 `string/string3.in` 与 `string/string3.ans`。\n\n该组样例满足特殊性质 A。\n\n**【数据范围】**\n\n设 $\\sum |S|$ 表示测试点中所有测试数据的字符串长度和。\n\n对于 $100 \\%$ 的测试数据，$T \\ge 1$，$1 \\le \\lvert S \\rvert \\le 5 \\times {10}^5$，$1 \\le \\sum \\lvert S \\rvert \\le 1.5 \\times {10}^6$。\n\n| 测试点编号 | $\\lvert S \\rvert \\le$ | $\\sum \\lvert S \\rvert \\le$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|\n| $1 \\sim 2$ | $30$ | $150$ | 无 |\n| $3 \\sim 5$ | $200$ | $800$ | 无 |\n| $6 \\sim 8$ | $1000$ | $3000$ | 无 |\n| $9 \\sim 11$ | $5 \\times {10}^5$ | $1.5 \\times {10}^6$ | A |\n| $12 \\sim 15$ | $6 \\times {10}^4$ | $3 \\times {10}^5$ | 无 |\n| $16 \\sim 20$ | $5 \\times {10}^5$ | $1.5 \\times {10}^6$ | 无 |\n\n特殊性质 A：字符串中的每个字符在小写字母中独立均匀随机生成。\n\n**【提示】**\n\n本题输入输出量较大，请使用较为快速的输入输出方式。\n\n例如，若你的代码使用了 `cin` 和 `cout` 作为输入输出方式，你可以选择在代码的**输入输出重定向语句**（`freopen` 语句、 `fopen` 语句等）**之后**加入以下语句加速输入输出速度。\n\n```cpp\nios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n```\n\n**加入该语句后不建议同时使用 `cin, cout` 和其他输入输出方式。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[LNOI2022] 串", "background": "", "description": "为了让你更好地理解题面，给出若干关于字符串的定义：\n\n- 对于一个字符串 $S = s_1 s_2 \\cdots s_n$，定义其长度为 $\\lvert S \\rvert = n$。\n- 对于两个字符串 $S = s_1 s_2 \\cdots s_n$ 和 $T = t_1 t_2 \\cdots t_m$，称 $T$ 为 $S$ 的子串，若 $m = 0$（即 $T$ 为空串）或者 $\\exists 1 \\le i \\le j \\le n$，$T = s_i s_{i + 1} \\cdots s_j$。若 $m = 0$ 或上述判断条件中 $i$ 可以取到 $1$，则称 $T$ 为 $S$ 的前缀；若 $m = 0$ 或上述判断条件中 $j$ 可以取到 $n$，则称 $T$ 为 $S$ 的后缀。\n\n给定一个英文小写字母构成的字符串 $S$，你需要找到一个尽可能长的字符串序列 $(T_0, T_1, \\ldots, T_l)$，满足：\n\n- $T_0$ 是 $S$ 的子串；\n- $\\forall 1 \\le i \\le l$，$\\lvert T_i \\rvert - \\lvert T_{i - 1} \\rvert = 1$；\n- $\\forall 1 \\le i \\le l$，存在 $S$ 的一个长度为 $\\lvert T_i \\rvert + 1$ 的子串 $S'_i$，使得 $S'_i$ 的长度为 $\\lvert T_{i - 1} \\rvert$ 的前缀为 $T_{i - 1}$，长度为 $\\lvert T_i \\rvert$ 的后缀为 $T_i$。\n\n输出这样的字符串序列的长度的最大值（即 $l$ 的最大值）。", "inputFormat": "**本题有多组测试数据**。输入的第一行为一个整数 $T$，表示测试数据组数。对于每组测试数据，输入一行一个英文小写字母构成的字符串 $S$。", "outputFormat": "对于每组测试数据输出一行一个整数，表示题目描述中字符串序列长度的最大值。", "hint": "**【样例解释 \\#1】**\n\n下文中使用符号 $\\epsilon$ 表示空串。\n\n对于第一组测试数据，可以找到如下字符串序列：$T_0 = \\epsilon, T_1 = \\texttt{b}, T_2 = \\texttt{cd}$，其中 $S'_1 = \\texttt{ab}, S'_2 = \\texttt{bcd}$。\n\n对于第二组测试数据，可以找到如下字符串序列：$T_0 = \\epsilon, T_1 = \\texttt{b}, T_2 = \\texttt{ab}, T_3 = \\texttt{bab}$，其中 $S'_1 = \\texttt{ab}, S'_2 = \\texttt{bab}, S'_3 = \\texttt{abab}$。\n\n对于第三组测试数据，可以找到如下字符串序列：$T_0 = \\epsilon$。\n\n**【样例 \\#2】**\n\n见附件中的 `string/string2.in` 与 `string/string2.ans`。\n\n该组样例中的字符串长度有一定梯度，你可以利用该组样例对程序进行检查。\n\n**【样例 \\#3】**\n\n见附件中的 `string/string3.in` 与 `string/string3.ans`。\n\n该组样例满足特殊性质 A。\n\n**【数据范围】**\n\n设 $\\sum |S|$ 表示测试点中所有测试数据的字符串长度和。\n\n对于 $100 \\%$ 的测试数据，$T \\ge 1$，$1 \\le \\lvert S \\rvert \\le 5 \\times {10}^5$，$1 \\le \\sum \\lvert S \\rvert \\le 1.5 \\times {10}^6$。\n\n| 测试点编号 | $\\lvert S \\rvert \\le$ | $\\sum \\lvert S \\rvert \\le$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|\n| $1 \\sim 2$ | $30$ | $150$ | 无 |\n| $3 \\sim 5$ | $200$ | $800$ | 无 |\n| $6 \\sim 8$ | $1000$ | $3000$ | 无 |\n| $9 \\sim 11$ | $5 \\times {10}^5$ | $1.5 \\times {10}^6$ | A |\n| $12 \\sim 15$ | $6 \\times {10}^4$ | $3 \\times {10}^5$ | 无 |\n| $16 \\sim 20$ | $5 \\times {10}^5$ | $1.5 \\times {10}^6$ | 无 |\n\n特殊性质 A：字符串中的每个字符在小写字母中独立均匀随机生成。\n\n**【提示】**\n\n本题输入输出量较大，请使用较为快速的输入输出方式。\n\n例如，若你的代码使用了 `cin` 和 `cout` 作为输入输出方式，你可以选择在代码的**输入输出重定向语句**（`freopen` 语句、 `fopen` 语句等）**之后**加入以下语句加速输入输出速度。\n\n```cpp\nios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n```\n\n**加入该语句后不建议同时使用 `cin, cout` 和其他输入输出方式。**", "locale": "zh-CN"}}}
{"pid": "P8369", "type": "P", "difficulty": 5, "samples": [["1 5 1\n3\n1\n5\n6", "1\n1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["博弈论", "2000", "POI（波兰）", "SG 函数"], "title": "[POI 2000] 条纹", "background": "", "description": "条纹游戏是一个双人的游戏。所需要的物品有一个棋盘以及三种颜色的长方形条纹，这三种颜色分别是红色、绿色和蓝色。所有的红色条纹的尺寸是 $c \\times 1$，所有的绿色条纹的尺寸是 $z \\times 1$，所有的蓝色条纹的尺寸是 $n \\times 1$，这里 $c,z,n$ 是正整数。每种颜色的条纹每个游戏者都拥有无限多个。\n\n一个棋盘是一个尺寸为 $p \\times 1$ 的长方形，由 $p$ 个 $1 \\times 1$ 的方格组成。\n\n游戏者轮流走，每一步都是由一个游戏者任选一种长方形条纹覆盖到棋盘上，并要求遵循以下规则：\n\n1. 条纹不能伸出棋盘之外。\n2. 不能覆盖在已有的条纹之上（即使部分也不行）。\n3. 条纹的边缘必须与棋盘方格的边缘相重叠。谁不能再走，谁就输了。\n\n先手是指在游戏中第一个走的游戏者。那么是否不管后手怎么走，先手都有必胜策略呢？\n\n请你编写一个程序：\n\n1. 读入条纹的尺寸以及至少一个棋盘的尺寸。\n2. 对每一个给出的棋盘判断先手是否必胜。\n3. 将结果输出。", "inputFormat": "第 $\\text{1}$ 行包含三个整数 $c,z,n$，表示三种条纹的长度，依次为红色，绿色以及蓝色。每两个数之间都用空格隔开。\n\n文件的第 $\\text{2}$ 行包括一个整数 $m$ 表示需要考虑的不同棋盘个数。以下 $\\text{3}$ 到 $\\text{m+2}$ 行每行包括一个整数 $p$ ,第 $\\text{i+2}$ 行表示第 $\\text{i}$ 个棋盘的长度。", "outputFormat": "应当包含 $m$ 行。只有一个数字应当被写入文件的第 $i$ 行：\n\n如果对第 $i$ 个棋盘先手有必胜策略，输出 $1$，否则输出 $2$。", "hint": "对于 $100$ % 的数据： $1 \\le c,z,n,m,p \\le 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2000] 条纹", "background": "", "description": "条纹游戏是一个双人的游戏。所需要的物品有一个棋盘以及三种颜色的长方形条纹，这三种颜色分别是红色、绿色和蓝色。所有的红色条纹的尺寸是 $c \\times 1$，所有的绿色条纹的尺寸是 $z \\times 1$，所有的蓝色条纹的尺寸是 $n \\times 1$，这里 $c,z,n$ 是正整数。每种颜色的条纹每个游戏者都拥有无限多个。\n\n一个棋盘是一个尺寸为 $p \\times 1$ 的长方形，由 $p$ 个 $1 \\times 1$ 的方格组成。\n\n游戏者轮流走，每一步都是由一个游戏者任选一种长方形条纹覆盖到棋盘上，并要求遵循以下规则：\n\n1. 条纹不能伸出棋盘之外。\n2. 不能覆盖在已有的条纹之上（即使部分也不行）。\n3. 条纹的边缘必须与棋盘方格的边缘相重叠。谁不能再走，谁就输了。\n\n先手是指在游戏中第一个走的游戏者。那么是否不管后手怎么走，先手都有必胜策略呢？\n\n请你编写一个程序：\n\n1. 读入条纹的尺寸以及至少一个棋盘的尺寸。\n2. 对每一个给出的棋盘判断先手是否必胜。\n3. 将结果输出。", "inputFormat": "第 $\\text{1}$ 行包含三个整数 $c,z,n$，表示三种条纹的长度，依次为红色，绿色以及蓝色。每两个数之间都用空格隔开。\n\n文件的第 $\\text{2}$ 行包括一个整数 $m$ 表示需要考虑的不同棋盘个数。以下 $\\text{3}$ 到 $\\text{m+2}$ 行每行包括一个整数 $p$ ,第 $\\text{i+2}$ 行表示第 $\\text{i}$ 个棋盘的长度。", "outputFormat": "应当包含 $m$ 行。只有一个数字应当被写入文件的第 $i$ 行：\n\n如果对第 $i$ 个棋盘先手有必胜策略，输出 $1$，否则输出 $2$。", "hint": "对于 $100$ % 的数据： $1 \\le c,z,n,m,p \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P8370", "type": "P", "difficulty": 4, "samples": [["1 2\n12\n0 0\n1 1\n2 2\n3 3\n4 5\n5 5\n4 2\n1 4\n0 5\n5 0\n2 3\n3 2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2001", "POI（波兰）"], "title": "[POI 2001] Goldmine", "background": "", "description": "$\\text{Byteman}$ 作为 $\\text{Byteland}$ 的 $\\text{The Goldmine}$（某一公司厂矿）的最有功的雇员之一，即将在年末退休。\n\n为了表示对他的认真勤恳的工作的承认，$\\text{The Goldmine}$ 的管理层愿意奖励他一小块长方形的矿地，此矿地长和宽为 $s$  和 $w$ ，且平行于坐标系统的轴线。长方形矿地的位置可由他自己选。当然，这块地的价值会随着位置的不同而不同。其价值是指这块区域内天然金矿石的数量（若矿石位于这块地的边缘，我们同样认为他是属于这个区域的）。\n\n你们的任务是计算出这块地的最大可能价值（即：为它选择最佳位置）。为简便起见，我们假定整个金矿的矿区是无穷的，但含有天然金矿石的区域却是有限的。\n\n请你编写一个程序：\n\n1. 读入天然金矿石的位置。\n\n2. 计算这块地的最大可能价值（即：求给定大小的这块地所含的天然金矿石的最大数）。", "inputFormat": "第一行输入两个正整数 $s,w$，各自代表着此矩形区域平行 $X$ 轴和 $Y$ 轴的边的长度。\n\n第二行输入一个正整数 $n$，它表示此金矿矿区内天然矿石的数量。接下来的 $n$ 行，每行输入两个用单个空格隔开的整数 $x,y$，它们分别表示了某一天然金矿石的 $X$ 坐标和 $Y$ 坐标。", "outputFormat": "输出一个整数，表示此块给定大小的矿地的最高价值。", "hint": "对于 $100$ % 的数据：$1 \\le s,w \\le 10000,1 \\le n \\le 15000,-30000 \\le x,y \\le 30000$ 。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2001] Goldmine", "background": "", "description": "$\\text{Byteman}$ 作为 $\\text{Byteland}$ 的 $\\text{The Goldmine}$（某一公司厂矿）的最有功的雇员之一，即将在年末退休。\n\n为了表示对他的认真勤恳的工作的承认，$\\text{The Goldmine}$ 的管理层愿意奖励他一小块长方形的矿地，此矿地长和宽为 $s$  和 $w$ ，且平行于坐标系统的轴线。长方形矿地的位置可由他自己选。当然，这块地的价值会随着位置的不同而不同。其价值是指这块区域内天然金矿石的数量（若矿石位于这块地的边缘，我们同样认为他是属于这个区域的）。\n\n你们的任务是计算出这块地的最大可能价值（即：为它选择最佳位置）。为简便起见，我们假定整个金矿的矿区是无穷的，但含有天然金矿石的区域却是有限的。\n\n请你编写一个程序：\n\n1. 读入天然金矿石的位置。\n\n2. 计算这块地的最大可能价值（即：求给定大小的这块地所含的天然金矿石的最大数）。", "inputFormat": "第一行输入两个正整数 $s,w$，各自代表着此矩形区域平行 $X$ 轴和 $Y$ 轴的边的长度。\n\n第二行输入一个正整数 $n$，它表示此金矿矿区内天然矿石的数量。接下来的 $n$ 行，每行输入两个用单个空格隔开的整数 $x,y$，它们分别表示了某一天然金矿石的 $X$ 坐标和 $Y$ 坐标。", "outputFormat": "输出一个整数，表示此块给定大小的矿地的最高价值。", "hint": "对于 $100$ % 的数据：$1 \\le s,w \\le 10000,1 \\le n \\le 15000,-30000 \\le x,y \\le 30000$ 。", "locale": "zh-CN"}}}
{"pid": "P8371", "type": "P", "difficulty": 5, "samples": [["5 3\n0 2 6 7\n0 3 6 7 8\n0 1 8\n1 1 7\n1 1 8\n1 2 1 2\n0 2 1 2\n0 2 3 4", "5\n1\n2\n4\n6\n7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2001", "POI（波兰）"], "title": "[POI 2001] 绿色游戏", "background": null, "description": "绿色游戏是一种两人游戏，双方分别称 $\\text{Ann}$ 和$\\text{Billy}$。游戏的内容主要是轮流在棋盘上移动一颗棋子。\n\n棋盘上的点一部分是绿色的，其余是白色的。它们全部从 $1$ 至 $a+b$ 编号。编号 $1$ 至 $a$ 的点属于 $\\text{Ann}$ ，编号 $a+1$ 至 $a+b$ 的点属于 $\\text{Billy}$。每个点都有一些后继点，均可一步到达。属于 $\\text{Ann}$ 的点的后继点一定属于 $\\text{Billy}$，反之亦然。所有的点都至少有一个后继点，这样总可以往下走一步。\n\n游戏开始时把棋子放在任意的一点 $P$ 上，然后双方轮流移动棋子至当前所在点（属于移动方）的一个后继点上（属于对手）。游戏由点 $P$ 的拥有者开始，结束时棋子第二次到达了某一点，称点 $Q$。如果在从点 $Q$ 至点 $Q$ 的一连串移动中，棋子至少一次被放到绿色点上，则 $\\text{Ann}$ 赢。若从点 $P$ 开始，不管 $\\text{Billy}$ 如何移动， $\\text{Ann}$ 总能保证赢得这次游戏，则称 $\\text{Ann}$ 对起始点 $P$ 有必胜的策略。\n\n请你编写一个程序：\n \n1. 读入对棋盘的描述。\n\n2. 算出 $\\text{Ann}$ 有必胜策略的起始点。", "inputFormat": "首行有两个整数 $a$ 和 $b$ ，两个整数之间用一个空格分开，分别表示属于 $\\text{Ann}$ 和 $\\text{Billy}$ 的点数 $(1 \\le a，b \\le 3000)$。以下 $a+b$ 行是对各点的描述，先描述 $\\text{Ann}$ 的点，再描述 $\\text{Billy}$ 的点。\n\n第 $i+1$ 行（$1 \\le i \\le a+b$） 以整数 $z，k$ 开始：$z$ 表示点 $i$ 的颜色（$0$－白色，$1$－绿色），$k$ 表示后继点的数目。然后是 $K$ 个整数（$2 \\le k \\leq a+b$），写在同一行，代表点 $i$ 后继点的编号，这些整数均用一个空格分开。绿点的个数不超过 $100$ ，所有点的后继点的个数之和不超过 $30000$ 。", "outputFormat": "首行仅一个整数 $L$ ，代表 $\\text{Ann}$ 有 $L$ 个有必胜策略的起始点。以下 $L$ 行按升序顺序依次给出这些点的编号。", "hint": null, "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2001] 绿色游戏", "background": null, "description": "绿色游戏是一种两人游戏，双方分别称 $\\text{Ann}$ 和$\\text{Billy}$。游戏的内容主要是轮流在棋盘上移动一颗棋子。\n\n棋盘上的点一部分是绿色的，其余是白色的。它们全部从 $1$ 至 $a+b$ 编号。编号 $1$ 至 $a$ 的点属于 $\\text{Ann}$ ，编号 $a+1$ 至 $a+b$ 的点属于 $\\text{Billy}$。每个点都有一些后继点，均可一步到达。属于 $\\text{Ann}$ 的点的后继点一定属于 $\\text{Billy}$，反之亦然。所有的点都至少有一个后继点，这样总可以往下走一步。\n\n游戏开始时把棋子放在任意的一点 $P$ 上，然后双方轮流移动棋子至当前所在点（属于移动方）的一个后继点上（属于对手）。游戏由点 $P$ 的拥有者开始，结束时棋子第二次到达了某一点，称点 $Q$。如果在从点 $Q$ 至点 $Q$ 的一连串移动中，棋子至少一次被放到绿色点上，则 $\\text{Ann}$ 赢。若从点 $P$ 开始，不管 $\\text{Billy}$ 如何移动， $\\text{Ann}$ 总能保证赢得这次游戏，则称 $\\text{Ann}$ 对起始点 $P$ 有必胜的策略。\n\n请你编写一个程序：\n \n1. 读入对棋盘的描述。\n\n2. 算出 $\\text{Ann}$ 有必胜策略的起始点。", "inputFormat": "首行有两个整数 $a$ 和 $b$ ，两个整数之间用一个空格分开，分别表示属于 $\\text{Ann}$ 和 $\\text{Billy}$ 的点数 $(1 \\le a，b \\le 3000)$。以下 $a+b$ 行是对各点的描述，先描述 $\\text{Ann}$ 的点，再描述 $\\text{Billy}$ 的点。\n\n第 $i+1$ 行（$1 \\le i \\le a+b$） 以整数 $z，k$ 开始：$z$ 表示点 $i$ 的颜色（$0$－白色，$1$－绿色），$k$ 表示后继点的数目。然后是 $K$ 个整数（$2 \\le k \\leq a+b$），写在同一行，代表点 $i$ 后继点的编号，这些整数均用一个空格分开。绿点的个数不超过 $100$ ，所有点的后继点的个数之和不超过 $30000$ 。", "outputFormat": "首行仅一个整数 $L$ ，代表 $\\text{Ann}$ 有 $L$ 个有必胜策略的起始点。以下 $L$ 行按升序顺序依次给出这些点的编号。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P8374", "type": "P", "difficulty": 7, "samples": [["1\n1\n1 0 0\n1 1 0\n0 0 1", "2"], ["1\n2\n1 1 0 1 1\n1 1 0 0 0\n1 0 1 1 1\n0 1 0 0 0\n0 1 1 1 1", "4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2022", "APIO", "交互题", "Special Judge", "O2优化"], "title": "[APIO2022] 火星", "background": "本题只支持 C++ 提交，提交时不需要包含 `mars.h` 头文件，只需要将附件中的 `mars.h` 中的内容粘贴到代码的开头即可。\n\n请使用 C++14、C++17 等语言，**而不是 C++14 (GCC 9)**，因为一些未知原因这个语言下 SPJ 会 CE。\n\n**【注】：洛谷暂不支持题面中所说的评测方式，我实现了一个洛谷支持的简易版本的交互库，但不能对传递数据进行有效限制，请各位自觉。**\n\n", "description": "你们晓得，法老们是最先去过外太空的人。他们发射过首次登陆行星图特摩斯一世（Thutmus I，现在一般叫它火星）的飞船。行星的表面可以建模成由方形单元构成的 $(2n + 1) \\times (2n + 1)$ 网格，其中每个单元中或者为陆地、或者为水域。对于第 $i$ 行第 $j$ 列（$0 \\le i, j \\le 2 \\cdot n$）的单元，如果单元中为陆地，则其状态表示为 $s[i][j] = \\texttt{1}$；如果单元中为水域，则表示为 $s[i][j] = \\texttt{0}$。\n\n如果在两个陆地单元之间存在某条仅由陆地单元构成的路径，而且路径中每两个连续的前后单元都有公共边，则称这两个陆地单元是连通的。行星上的岛屿被定义为两两连通的陆地单元的极大集合。\n\n飞船的任务是统计该行星上岛屿的数量。然而，考虑到飞船的上古电脑，这事儿并不容易。电脑的内存储器 $h$ 以一个 $(2n + 1) \\times (2n + 1)$ 的二维数组的形式存储数据，且数组的每个位置上可以保存长度为 $100$ 的字符串，串中的每个字母为 $\\texttt{0}$（ASCII 码 $48$）或 $\\texttt{1}$（ASCII 码 $49$）。初始时，存储器的每个位置的第 $0$ 位记录的是上述网格中每个单元的状态，即 $h[i][j][0] = s[i][j]$（对所有 $0 \\le i, j \\le 2 \\cdot n$）。$h$ 中的其他位在初始时都被置为 $\\texttt{0}$（ASCII 码 $48$）。\n\n在处理存储器中的数据时，电脑只能访问存储器中的 $3 \\times 3$ 区块，并且改写该区块左上角位置的值。说得更正式一点，电脑可以访问 $h[i \\dots i + 2][j \\dots j + 2]$（$0 \\le i, j \\le 2 \\cdot (n - 1)$）中的值，并且改写 $h[i][j]$ 中的值。在\n下文中，该过程被叫做**处理单元** $(i, j)$。\n\n为了解决电脑能力的局限，法老们搞出了下面的套路：\n\n- 电脑可以分成 $n$ 个阶段来操作存储器。\n- 在阶段 $k$（$0 \\le k \\le n - 1$），令 $m = 2 \\cdot (n - k - 1)$， 电脑将对所有的 $0 \\le i, j \\le m$，按照 $i$ 的升序以及每个 $i$ 上 $j$ 的升序，处理单元 $(i, j)$。换句话说，电脑将按照如下顺序处理这些单元：$(0, 0), (0, 1),\\cdots , (0, m), (1, 0), (1, 1),\\cdots , (1, m),\\cdots , (m, 0), (m, 1),\\cdots , (m, m)$。\n- 在最后一个阶段（$k = n - 1$），电脑仅处理单元 $(0, 0)$。该阶段结束后，写入到 $h[0][0]$ 的值应该等于行星上的岛屿数量，而且该值应以字符串的形式表示成二进制，其中最低有效位对应于字符串的首字符。\n\n下图给出了电脑操作某个 $5 \\times 5$（$n = 2$）存储器的方式。蓝色单元表示该单元正在被改写，而着色的单元则表示被处理的子数组。\n\n在阶段 $0$，电脑将以如下顺序处理下面的子数组：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/m33yffaa.png)\n\n在阶段 $1$，电脑将仅处理一个子数组：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/inav002a.png)\n\n你的任务是给出一个方法，让电脑能在给定的操作方式下，统计出行星图特摩斯一世上的岛屿数量。\n\n## 实现细节\n\n你需要实现下面的函数：\n\n```cpp\nstring process(string[][] a, int i, int j, int k, int n)\n```\n\n- $a$：一个 $3 \\times 3$ 数组，表示正在被处理的子数组。特别说明，有 $a = h[i \\dots i + 2][j \\dots j + 2]$，这里 $a$ 中的每个元素均为长度恰好为 $100$ 的字符串，而且串中的字符为 $\\texttt{0}$（ASCII 码 $48$）或 $\\texttt{1}$（ASCII 码 $49$）。\n- $i, j$：电脑当前正在处理的单元的行号和列号。\n- $k$：当前阶段的序号。\n- $n$：阶段总数，同时也是行星表面的大小，此时行星表面包含 $(2n + 1) \\times (2n + 1)$ 个单元。\n- 该函数应返回一个长度为 $100$ 的二进制表示字符串。返回值将保存在电脑存储器中的 $h[i][j]$ 处。\n- $k = n - 1$ 时，是该函数的最后一次调用。在此次调用中，函数应以字符串的形式返回行星上的岛屿数量的二进制表示，其最低有效位对应下标 $0$ 处的字符（二进制字符串的首字符），次低有效位对应下标 $1$ 处的字符，以此类推。\n- 该函数必须独立于任何的静态或全局变量，且其返回值应仅依赖于传递给该函数的参数。\n\n每个测试用例包括 $T$ 个独立的场景（也就是说，不同的行星表面情形）。你的函数在每个场景上的行为，必须与这些场景的顺序无关，因为对同一场景的 `process` 函数调用可能不是连续发生的。但是，可以确保对每个场景，会按照题面所描述的顺序来调用函数 `process`。\n\n此外，对每个测试用例，你的程序可能会同时运行多个实例。内存限制和 CPU 用时限制将施加在所有这些实例的总和上。任何故意在这些实例之间偷偷传递数据的行为，都将被认定为作弊，选手可能会因此被取消比赛资格。\n\n**【注】：洛谷暂不支持这种评测方式，我实现了一个洛谷支持的简易版本的交互库，但不能对传递数据进行有效限制，请各位自觉。**\n\n特别说明，在调用函数 `process` 时保存在静态或全局变量中的信息，不保证在下次调用时可以读出。", "inputFormat": "评测程序示例读取如下格式的输入：\n\n- 第 $1$ 行：$T$。\n- 第 $i$ 个区块（$0 \\le i \\le T - 1$）：该区块表示第 $i$ 个场景。\n\t- 第 $1$ 行：$n$。\n\t- 第 $2 + j$ 行（$0 \\le j \\le 2 ⋅ n$）：$s[j][0]\\ s[j][1]\\ \\dots\\ s[j][2 \\cdot n]$。", "outputFormat": "评测程序示例将按照如下格式打印出结果：\n\n- 第 $1 + i$ 行（$0 \\le i \\le T - 1$）：在第 $i$ 个场景上，函数 `process` 最后一次的返回值的十进制表示。", "hint": "## 例子\n\n### 例 $1$\n\n考虑 $n=1$ 的样例，其中 $s$ 如下所示：\n\n```text\n'1' '0' '0'\n'1' '1' '0'\n'0' '0' '1'\n```\n\n在本例中，行星表面包括 $3 \\times 3$ 个单元，其中有 $2$ 个岛屿。对函数 `process` 的调用至多只有 $1$ 个阶段。\n\n在阶段 $0$，评测程序将调用函数 `process` 恰好一次：\n\n```cpp\nprocess([[\"100\",\"000\",\"000\"],[\"100\",\"100\",\"000\"],[\"000\",\"000\",\"100\"]],0,0,0,1)\n```\n\n注意这里仅展示了 $h$ 中每个元素的前 $3$ 位。\n\n该函数应返回 $\\texttt{0100}\\dots$（省略的位全部为零），这里二进制的 $\\dots 0010$ 等于十进制的 $2$。注意，这里省略了 $96$ 个零并用 $\\dots$ 来代替。\n\n### 例 $2$\n\n考虑 $n=2$ 的样例，其中 $s$ 如下所示：\n\n```text\n'1' '1' '0' '1' '1'\n'1' '1' '0' '0' '0'\n'1' '0' '1' '1' '1'\n'0' '1' '0' '0' '0'\n'0' '1' '1' '1' '1'\n```\n\n在本例中，行星表面包括 $5 \\times 5$ 个单元，其中有 $4$ 个岛屿。对函数 `process` 的调用至多只有 $2$ 个阶段。\n\n在阶段 $0$，评测程序将调用函数 `process` 恰好一次：\n\n```cpp\nprocess([[\"100\",\"100\",\"000\"],[\"100\",\"100\",\"000\"],[\"100\",\"000\",\"100\"]],0,0,0,2)\nprocess([[\"100\",\"000\",\"100\"],[\"100\",\"000\",\"000\"],[\"000\",\"100\",\"100\"]],0,1,0,2)\nprocess([[\"000\",\"100\",\"100\"],[\"000\",\"000\",\"000\"],[\"100\",\"100\",\"100\"]],0,2,0,2)\nprocess([[\"100\",\"100\",\"000\"],[\"100\",\"000\",\"100\"],[\"000\",\"100\",\"000\"]],1,0,0,2)\nprocess([[\"100\",\"000\",\"000\"],[\"000\",\"100\",\"100\"],[\"100\",\"000\",\"000\"]],1,1,0,2)\nprocess([[\"000\",\"000\",\"000\"],[\"100\",\"100\",\"100\"],[\"000\",\"000\",\"000\"]],1,2,0,2)\nprocess([[\"100\",\"000\",\"100\"],[\"000\",\"100\",\"000\"],[\"000\",\"100\",\"100\"]],2,0,0,2)\nprocess([[\"000\",\"100\",\"100\"],[\"100\",\"000\",\"000\"],[\"100\",\"100\",\"100\"]],2,1,0,2)\nprocess([[\"100\",\"100\",\"100\"],[\"000\",\"000\",\"000\"],[\"100\",\"100\",\"100\"]],2,2,0,2)\n```\n\n假定上面调用得到的返回值分别为 $\\texttt{011},\\texttt{000},\\texttt{000},\\texttt{111},\\texttt{111},\\texttt{011},\\texttt{110},\\texttt{010},\\texttt{111}$，被省略的位均为零。因此，在阶段 $0$ 结束后，$h$ 将保存有如下的值：\n\n```text\n\"011\", \"000\", \"000\", \"100\", \"100\"\n\"111\", \"111\", \"011\", \"000\", \"000\"\n\"110\", \"010\", \"111\", \"100\", \"100\"\n\"000\", \"100\", \"000\", \"000\", \"000\"\n\"000\", \"100\", \"100\", \"100\", \"100\"\n```\n\n在阶段 $1$，评测程序将调用函数 `process` 一次：\n\n```cpp\nprocess([[\"011\",\"000\",\"000\"],[\"111\",\"111\",\"011\"],[\"110\",\"010\",\"111\"]],0,0,1,2)\n```\n\n最后，本次函数调用应返回 $\\texttt{0010000}\\dots$（被省略的位均为零），这里二进制的 $\\dots 0000100$ 等于十进制的 $4$。注意这里省略了 $93$ 个零并用 $\\dots$ 来代替。\n\n## 约束条件\n\n- $1\\le T\\le 10$。\n- $1\\le n\\le 20$。\n- $s[i][j]$ 为 $\\texttt{0}$（ASCII 码 $48$）或 $\\texttt{1}$（ASCII 码 $49$）（对所有 $0\\le i,j\\le 2\\cdot n$）。\n- $h[i][j]$ 的长度恰好为 $100$（对所有 $0\\le i,j\\le 2\\cdot n$）。\n- $h[i][j]$ 中的每个字符均为 $\\texttt{0}$（ASCII 码 $48$）或 $\\texttt{1}$（ASCII 码 $49$）（对所有 $0\\le i,j\\le 2\\cdot n$）。\n\n对函数 `process` 的每次调用，都有：\n\n- $0\\le k\\le n-1$。\n- $0\\le i,j\\le 2\\cdot (n-k-1)$。\n\n## 子任务\n\n1. （$6$ 分）$n\\le 2$。\n2. （$8$ 分）$n\\le 4$。\n3. （$7$ 分）$n\\le 6$。\n4. （$8$ 分）$n\\le 8$。\n5. （$7$ 分）$n\\le 10$。\n6. （$8$ 分）$n\\le 12$。\n7. （$10$ 分）$n\\le 14$。\n8. （$24$ 分）$n\\le 16$。\n9. （$11$ 分）$n\\le 18$。\n10. （$11$ 分）$n\\le 20$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[APIO2022] 火星", "background": "本题只支持 C++ 提交，提交时不需要包含 `mars.h` 头文件，只需要将附件中的 `mars.h` 中的内容粘贴到代码的开头即可。\n\n请使用 C++14、C++17 等语言，**而不是 C++14 (GCC 9)**，因为一些未知原因这个语言下 SPJ 会 CE。\n\n**【注】：洛谷暂不支持题面中所说的评测方式，我实现了一个洛谷支持的简易版本的交互库，但不能对传递数据进行有效限制，请各位自觉。**\n\n", "description": "你们晓得，法老们是最先去过外太空的人。他们发射过首次登陆行星图特摩斯一世（Thutmus I，现在一般叫它火星）的飞船。行星的表面可以建模成由方形单元构成的 $(2n + 1) \\times (2n + 1)$ 网格，其中每个单元中或者为陆地、或者为水域。对于第 $i$ 行第 $j$ 列（$0 \\le i, j \\le 2 \\cdot n$）的单元，如果单元中为陆地，则其状态表示为 $s[i][j] = \\texttt{1}$；如果单元中为水域，则表示为 $s[i][j] = \\texttt{0}$。\n\n如果在两个陆地单元之间存在某条仅由陆地单元构成的路径，而且路径中每两个连续的前后单元都有公共边，则称这两个陆地单元是连通的。行星上的岛屿被定义为两两连通的陆地单元的极大集合。\n\n飞船的任务是统计该行星上岛屿的数量。然而，考虑到飞船的上古电脑，这事儿并不容易。电脑的内存储器 $h$ 以一个 $(2n + 1) \\times (2n + 1)$ 的二维数组的形式存储数据，且数组的每个位置上可以保存长度为 $100$ 的字符串，串中的每个字母为 $\\texttt{0}$（ASCII 码 $48$）或 $\\texttt{1}$（ASCII 码 $49$）。初始时，存储器的每个位置的第 $0$ 位记录的是上述网格中每个单元的状态，即 $h[i][j][0] = s[i][j]$（对所有 $0 \\le i, j \\le 2 \\cdot n$）。$h$ 中的其他位在初始时都被置为 $\\texttt{0}$（ASCII 码 $48$）。\n\n在处理存储器中的数据时，电脑只能访问存储器中的 $3 \\times 3$ 区块，并且改写该区块左上角位置的值。说得更正式一点，电脑可以访问 $h[i \\dots i + 2][j \\dots j + 2]$（$0 \\le i, j \\le 2 \\cdot (n - 1)$）中的值，并且改写 $h[i][j]$ 中的值。在\n下文中，该过程被叫做**处理单元** $(i, j)$。\n\n为了解决电脑能力的局限，法老们搞出了下面的套路：\n\n- 电脑可以分成 $n$ 个阶段来操作存储器。\n- 在阶段 $k$（$0 \\le k \\le n - 1$），令 $m = 2 \\cdot (n - k - 1)$， 电脑将对所有的 $0 \\le i, j \\le m$，按照 $i$ 的升序以及每个 $i$ 上 $j$ 的升序，处理单元 $(i, j)$。换句话说，电脑将按照如下顺序处理这些单元：$(0, 0), (0, 1),\\cdots , (0, m), (1, 0), (1, 1),\\cdots , (1, m),\\cdots , (m, 0), (m, 1),\\cdots , (m, m)$。\n- 在最后一个阶段（$k = n - 1$），电脑仅处理单元 $(0, 0)$。该阶段结束后，写入到 $h[0][0]$ 的值应该等于行星上的岛屿数量，而且该值应以字符串的形式表示成二进制，其中最低有效位对应于字符串的首字符。\n\n下图给出了电脑操作某个 $5 \\times 5$（$n = 2$）存储器的方式。蓝色单元表示该单元正在被改写，而着色的单元则表示被处理的子数组。\n\n在阶段 $0$，电脑将以如下顺序处理下面的子数组：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/m33yffaa.png)\n\n在阶段 $1$，电脑将仅处理一个子数组：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/inav002a.png)\n\n你的任务是给出一个方法，让电脑能在给定的操作方式下，统计出行星图特摩斯一世上的岛屿数量。\n\n## 实现细节\n\n你需要实现下面的函数：\n\n```cpp\nstring process(string[][] a, int i, int j, int k, int n)\n```\n\n- $a$：一个 $3 \\times 3$ 数组，表示正在被处理的子数组。特别说明，有 $a = h[i \\dots i + 2][j \\dots j + 2]$，这里 $a$ 中的每个元素均为长度恰好为 $100$ 的字符串，而且串中的字符为 $\\texttt{0}$（ASCII 码 $48$）或 $\\texttt{1}$（ASCII 码 $49$）。\n- $i, j$：电脑当前正在处理的单元的行号和列号。\n- $k$：当前阶段的序号。\n- $n$：阶段总数，同时也是行星表面的大小，此时行星表面包含 $(2n + 1) \\times (2n + 1)$ 个单元。\n- 该函数应返回一个长度为 $100$ 的二进制表示字符串。返回值将保存在电脑存储器中的 $h[i][j]$ 处。\n- $k = n - 1$ 时，是该函数的最后一次调用。在此次调用中，函数应以字符串的形式返回行星上的岛屿数量的二进制表示，其最低有效位对应下标 $0$ 处的字符（二进制字符串的首字符），次低有效位对应下标 $1$ 处的字符，以此类推。\n- 该函数必须独立于任何的静态或全局变量，且其返回值应仅依赖于传递给该函数的参数。\n\n每个测试用例包括 $T$ 个独立的场景（也就是说，不同的行星表面情形）。你的函数在每个场景上的行为，必须与这些场景的顺序无关，因为对同一场景的 `process` 函数调用可能不是连续发生的。但是，可以确保对每个场景，会按照题面所描述的顺序来调用函数 `process`。\n\n此外，对每个测试用例，你的程序可能会同时运行多个实例。内存限制和 CPU 用时限制将施加在所有这些实例的总和上。任何故意在这些实例之间偷偷传递数据的行为，都将被认定为作弊，选手可能会因此被取消比赛资格。\n\n**【注】：洛谷暂不支持这种评测方式，我实现了一个洛谷支持的简易版本的交互库，但不能对传递数据进行有效限制，请各位自觉。**\n\n特别说明，在调用函数 `process` 时保存在静态或全局变量中的信息，不保证在下次调用时可以读出。", "inputFormat": "评测程序示例读取如下格式的输入：\n\n- 第 $1$ 行：$T$。\n- 第 $i$ 个区块（$0 \\le i \\le T - 1$）：该区块表示第 $i$ 个场景。\n\t- 第 $1$ 行：$n$。\n\t- 第 $2 + j$ 行（$0 \\le j \\le 2 ⋅ n$）：$s[j][0]\\ s[j][1]\\ \\dots\\ s[j][2 \\cdot n]$。", "outputFormat": "评测程序示例将按照如下格式打印出结果：\n\n- 第 $1 + i$ 行（$0 \\le i \\le T - 1$）：在第 $i$ 个场景上，函数 `process` 最后一次的返回值的十进制表示。", "hint": "## 例子\n\n### 例 $1$\n\n考虑 $n=1$ 的样例，其中 $s$ 如下所示：\n\n```text\n'1' '0' '0'\n'1' '1' '0'\n'0' '0' '1'\n```\n\n在本例中，行星表面包括 $3 \\times 3$ 个单元，其中有 $2$ 个岛屿。对函数 `process` 的调用至多只有 $1$ 个阶段。\n\n在阶段 $0$，评测程序将调用函数 `process` 恰好一次：\n\n```cpp\nprocess([[\"100\",\"000\",\"000\"],[\"100\",\"100\",\"000\"],[\"000\",\"000\",\"100\"]],0,0,0,1)\n```\n\n注意这里仅展示了 $h$ 中每个元素的前 $3$ 位。\n\n该函数应返回 $\\texttt{0100}\\dots$（省略的位全部为零），这里二进制的 $\\dots 0010$ 等于十进制的 $2$。注意，这里省略了 $96$ 个零并用 $\\dots$ 来代替。\n\n### 例 $2$\n\n考虑 $n=2$ 的样例，其中 $s$ 如下所示：\n\n```text\n'1' '1' '0' '1' '1'\n'1' '1' '0' '0' '0'\n'1' '0' '1' '1' '1'\n'0' '1' '0' '0' '0'\n'0' '1' '1' '1' '1'\n```\n\n在本例中，行星表面包括 $5 \\times 5$ 个单元，其中有 $4$ 个岛屿。对函数 `process` 的调用至多只有 $2$ 个阶段。\n\n在阶段 $0$，评测程序将调用函数 `process` 恰好一次：\n\n```cpp\nprocess([[\"100\",\"100\",\"000\"],[\"100\",\"100\",\"000\"],[\"100\",\"000\",\"100\"]],0,0,0,2)\nprocess([[\"100\",\"000\",\"100\"],[\"100\",\"000\",\"000\"],[\"000\",\"100\",\"100\"]],0,1,0,2)\nprocess([[\"000\",\"100\",\"100\"],[\"000\",\"000\",\"000\"],[\"100\",\"100\",\"100\"]],0,2,0,2)\nprocess([[\"100\",\"100\",\"000\"],[\"100\",\"000\",\"100\"],[\"000\",\"100\",\"000\"]],1,0,0,2)\nprocess([[\"100\",\"000\",\"000\"],[\"000\",\"100\",\"100\"],[\"100\",\"000\",\"000\"]],1,1,0,2)\nprocess([[\"000\",\"000\",\"000\"],[\"100\",\"100\",\"100\"],[\"000\",\"000\",\"000\"]],1,2,0,2)\nprocess([[\"100\",\"000\",\"100\"],[\"000\",\"100\",\"000\"],[\"000\",\"100\",\"100\"]],2,0,0,2)\nprocess([[\"000\",\"100\",\"100\"],[\"100\",\"000\",\"000\"],[\"100\",\"100\",\"100\"]],2,1,0,2)\nprocess([[\"100\",\"100\",\"100\"],[\"000\",\"000\",\"000\"],[\"100\",\"100\",\"100\"]],2,2,0,2)\n```\n\n假定上面调用得到的返回值分别为 $\\texttt{011},\\texttt{000},\\texttt{000},\\texttt{111},\\texttt{111},\\texttt{011},\\texttt{110},\\texttt{010},\\texttt{111}$，被省略的位均为零。因此，在阶段 $0$ 结束后，$h$ 将保存有如下的值：\n\n```text\n\"011\", \"000\", \"000\", \"100\", \"100\"\n\"111\", \"111\", \"011\", \"000\", \"000\"\n\"110\", \"010\", \"111\", \"100\", \"100\"\n\"000\", \"100\", \"000\", \"000\", \"000\"\n\"000\", \"100\", \"100\", \"100\", \"100\"\n```\n\n在阶段 $1$，评测程序将调用函数 `process` 一次：\n\n```cpp\nprocess([[\"011\",\"000\",\"000\"],[\"111\",\"111\",\"011\"],[\"110\",\"010\",\"111\"]],0,0,1,2)\n```\n\n最后，本次函数调用应返回 $\\texttt{0010000}\\dots$（被省略的位均为零），这里二进制的 $\\dots 0000100$ 等于十进制的 $4$。注意这里省略了 $93$ 个零并用 $\\dots$ 来代替。\n\n## 约束条件\n\n- $1\\le T\\le 10$。\n- $1\\le n\\le 20$。\n- $s[i][j]$ 为 $\\texttt{0}$（ASCII 码 $48$）或 $\\texttt{1}$（ASCII 码 $49$）（对所有 $0\\le i,j\\le 2\\cdot n$）。\n- $h[i][j]$ 的长度恰好为 $100$（对所有 $0\\le i,j\\le 2\\cdot n$）。\n- $h[i][j]$ 中的每个字符均为 $\\texttt{0}$（ASCII 码 $48$）或 $\\texttt{1}$（ASCII 码 $49$）（对所有 $0\\le i,j\\le 2\\cdot n$）。\n\n对函数 `process` 的每次调用，都有：\n\n- $0\\le k\\le n-1$。\n- $0\\le i,j\\le 2\\cdot (n-k-1)$。\n\n## 子任务\n\n1. （$6$ 分）$n\\le 2$。\n2. （$8$ 分）$n\\le 4$。\n3. （$7$ 分）$n\\le 6$。\n4. （$8$ 分）$n\\le 8$。\n5. （$7$ 分）$n\\le 10$。\n6. （$8$ 分）$n\\le 12$。\n7. （$10$ 分）$n\\le 14$。\n8. （$24$ 分）$n\\le 16$。\n9. （$11$ 分）$n\\le 18$。\n10. （$11$ 分）$n\\le 20$。", "locale": "zh-CN"}}}
{"pid": "P8375", "type": "P", "difficulty": 7, "samples": [["6 5 3\n3 4\n5 0\n4 5\n5 3\n1 4", "4"], ["4 1 2\n1 1", "0"], ["4 3 2\n1 3\n2 0\n3 2", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2022", "APIO", "交互题", "Special Judge", "O2优化"], "title": "[APIO2022] 游戏", "background": "本题只支持 C++ 提交，提交时不需要包含 `game.h` 头文件，只需要将附件中的 `game.h` 中的内容粘贴到代码的开头即可。", "description": "法老们发现了标号从 $0$ 到 $n - 1$ 的 $n$ 个星球，并且在它们之间建立了一个**单向传输系统**。在这个传输系统中，每个传送器连接一个起始星球和一个目的星球。当游客从一个起始星球使用传送器，就可以到达对应的目的星球。需要注意的是，起始星球和目的星球有可能是同一个星球。我们使用 $(u, v)$ 表示一个起始于星球 $u$ 到达星球 $v$ 的传送器。\n\n为了促进传输系统的广泛使用，法老们设计了一个供游客们在乘坐传送系统时可以进行的游戏。一名游客可以从任一星球出发。标号 $0, 1,\\dots , k - 1$（$k \\le n$）的星球被称为**特殊星球**。当游客每次进入一个特殊星球，就可以获得一枚邮票。\n\n目前，对于每个星球 $i$（$0 \\le i \\le k - 2$），都建立了一个传送器 $(i, i + 1)$。这 $k - 1$ 个传送器叫做**起始传送器**。\n\n传送器随着时间不断建立。随着传送器的建立，一名游客也许有可能获得无穷多枚邮票。准确来说，这种情况会在存在一个满足如下条件的星球序列 $w[0], w[1],\\dots , w[t]$ 时发生：\n\n- $1 \\le t$。\n- $0 \\le w[0] \\le k - 1$。\n- $w[t] = w[0]$。\n- 对于每个星球 $i$（$0 \\le i \\le t - 1$），存在一个传送器 $(w[i], w[i + 1])$。\n\n注意一名游客能够使用起始传送器和任何一个目前已经建立的传送器。\n\n你的任务是，帮助法老验证在每次加入新的传送器后，一位游客是否能够拿到无穷多枚邮票。\n\n## 实现细节\n\n你需要实现下述函数：\n\n```cpp\ninit(int n, int k)\n```\n\n- $n$：星球数量。\n- $k$：特殊星球数量。\n- 这个函数只会被调用一次，早于任何一次 `add_teleporter` 调用。\n\n```cpp\nint add_teleporter(int u, int v)\n```\n\n- $u$ 和 $v$：被加入传送器的起始和目的星球。\n- 这个函数至多被调用 $m$ 次（$m$ 的取值范围参阅“约束条件”部分的内容）。\n- 如果当传送器 $(u, v)$ 被加入后游客能够获得无穷多枚邮票，函数需要返回 $1$。否则，这个函数应该返回 $0$。\n- 一旦函数返回了 $1$，你的程序将会被终止。", "inputFormat": "评测程序示例按照如下的格式读取输入数据：\n\n- 第 $1$ 行：$n\\ m\\ k$。\n- 第 $2 + i$ 行（$0 \\le i \\le m - 1$）：$u[i]\\ v[i]$。\n\n评测程序示例首先调用 `init`，然后按照 $i = 0, 1,\\dots , m - 1$ 的顺序调用 `add_teleporter`：$u = u[i]$ 和 $v = v[i]$。", "outputFormat": "程序需要打印多次调用 `add_teleporter` 中首次返回 $1$ 的调用索引（$0$ 到 $m - 1$，包含 $0$ 和 $m - 1$）；当所有 `add_teleporter` 调用中都返回 $0$ 时，你的程序需要返回 $m$。\n\n如果某次 `add_teleporter` 调用返回了 $0$ 和 $1$ 之外的整数，评测程序示例会打印 $-1$，你的程序会被马上终止。", "hint": "## 例子\n\n### 例 $1$\n\n考虑下面的函数调用：\n\n```cpp\ninit(6, 3)\n```\n\n在这个例子里，有 $6$ 个星球和 $3$ 个特殊星球，标号为 $0,1,2$ 的星球是特殊星球。起始传送器是 $(0,1)$ 和 $(1,2)$。\n\n假设评测程序执行下述调用：\n\n- (0) `add_teleporter(3, 4)`：应该返回 $0$。\n- (1) `add_teleporter(5, 0)`：应该返回 $0$。\n- (2) `add_teleporter(4, 5)`：应该返回 $0$。\n- (3) `add_teleporter(5, 3)`：应该返回 $0$。\n- (4) `add_teleporter(1, 4)`：在这种情况下，是可能获得无穷多枚邮票的。例如，游客可以从星球 $0$ 出发，按照 $1, 4, 5, 0, 1, 4, 5, 0,\\dots$ 这个顺序进行。因此，函数需要返回 $1$，进一步你的程序会被终止。\n\n下图对于这个例子进行了说明。特殊星球和起始传送器都使用粗体字表示。通过 `add_teleporter` 加入的传送器，按照顺序被标记为 $0$ 到 $4$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q80oy4px.png)\n\n### 例 $2$\n\n考虑下面的函数调用：\n\n```cpp\ninit(4, 2)\n```\n\n在这个例子里，有 $4$ 个星球和 $2$ 个特殊星球。标号为 $0$ 和 $1$ 星球是特殊星球。起始传送器是 $(0, 1)$。\n\n假设评测程序执行下述调用：\n\n- `add_teleporter(1, 1)`：当加入传送器 $(1, 1)$ 后，我们就能够获得无穷多枚邮票。例如，游客从星球 $1$ 出发，可以使用传送器 $(1, 1)$ 到达星球 $1$ 无限次。因此，函数需要返回 $1$，然后你的程序被终止。\n\n附件包里还包含了另一个样例输入输出。\n\n## 约束条件\n\n- $1\\le n\\le 3\\times 10^5$；\n- $1\\le m\\le 5\\times 10^5$；\n- $1\\le k\\le n$。\n\n对于每次调用 `add_teleporter` 函数：\n\n- $0\\le u\\le n-1$ 和 $0\\le v\\le n-1$；\n- 在传送器 $(u,v)$ 加入之前，不会有从星球 $u$ 到星球 $v$ 的传送器。\n\n## 子任务\n\n1. （$2$ 分）$n=k$，$n\\le 100$，$m\\le 300$；\n2. （$10$ 分）$n\\le 100$，$m\\le 300$。\n3. （$18$ 分）$n\\le 10^3$，$m\\le 5\\times 10^3$。\n4. （$30$ 分）$n\\le 3\\times 10^4$，$m\\le 5\\times 10^4$，$k\\le 10^3$。\n5. （$40$ 分）没有额外的约束条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[APIO2022] 游戏", "background": "本题只支持 C++ 提交，提交时不需要包含 `game.h` 头文件，只需要将附件中的 `game.h` 中的内容粘贴到代码的开头即可。", "description": "法老们发现了标号从 $0$ 到 $n - 1$ 的 $n$ 个星球，并且在它们之间建立了一个**单向传输系统**。在这个传输系统中，每个传送器连接一个起始星球和一个目的星球。当游客从一个起始星球使用传送器，就可以到达对应的目的星球。需要注意的是，起始星球和目的星球有可能是同一个星球。我们使用 $(u, v)$ 表示一个起始于星球 $u$ 到达星球 $v$ 的传送器。\n\n为了促进传输系统的广泛使用，法老们设计了一个供游客们在乘坐传送系统时可以进行的游戏。一名游客可以从任一星球出发。标号 $0, 1,\\dots , k - 1$（$k \\le n$）的星球被称为**特殊星球**。当游客每次进入一个特殊星球，就可以获得一枚邮票。\n\n目前，对于每个星球 $i$（$0 \\le i \\le k - 2$），都建立了一个传送器 $(i, i + 1)$。这 $k - 1$ 个传送器叫做**起始传送器**。\n\n传送器随着时间不断建立。随着传送器的建立，一名游客也许有可能获得无穷多枚邮票。准确来说，这种情况会在存在一个满足如下条件的星球序列 $w[0], w[1],\\dots , w[t]$ 时发生：\n\n- $1 \\le t$。\n- $0 \\le w[0] \\le k - 1$。\n- $w[t] = w[0]$。\n- 对于每个星球 $i$（$0 \\le i \\le t - 1$），存在一个传送器 $(w[i], w[i + 1])$。\n\n注意一名游客能够使用起始传送器和任何一个目前已经建立的传送器。\n\n你的任务是，帮助法老验证在每次加入新的传送器后，一位游客是否能够拿到无穷多枚邮票。\n\n## 实现细节\n\n你需要实现下述函数：\n\n```cpp\ninit(int n, int k)\n```\n\n- $n$：星球数量。\n- $k$：特殊星球数量。\n- 这个函数只会被调用一次，早于任何一次 `add_teleporter` 调用。\n\n```cpp\nint add_teleporter(int u, int v)\n```\n\n- $u$ 和 $v$：被加入传送器的起始和目的星球。\n- 这个函数至多被调用 $m$ 次（$m$ 的取值范围参阅“约束条件”部分的内容）。\n- 如果当传送器 $(u, v)$ 被加入后游客能够获得无穷多枚邮票，函数需要返回 $1$。否则，这个函数应该返回 $0$。\n- 一旦函数返回了 $1$，你的程序将会被终止。", "inputFormat": "评测程序示例按照如下的格式读取输入数据：\n\n- 第 $1$ 行：$n\\ m\\ k$。\n- 第 $2 + i$ 行（$0 \\le i \\le m - 1$）：$u[i]\\ v[i]$。\n\n评测程序示例首先调用 `init`，然后按照 $i = 0, 1,\\dots , m - 1$ 的顺序调用 `add_teleporter`：$u = u[i]$ 和 $v = v[i]$。", "outputFormat": "程序需要打印多次调用 `add_teleporter` 中首次返回 $1$ 的调用索引（$0$ 到 $m - 1$，包含 $0$ 和 $m - 1$）；当所有 `add_teleporter` 调用中都返回 $0$ 时，你的程序需要返回 $m$。\n\n如果某次 `add_teleporter` 调用返回了 $0$ 和 $1$ 之外的整数，评测程序示例会打印 $-1$，你的程序会被马上终止。", "hint": "## 例子\n\n### 例 $1$\n\n考虑下面的函数调用：\n\n```cpp\ninit(6, 3)\n```\n\n在这个例子里，有 $6$ 个星球和 $3$ 个特殊星球，标号为 $0,1,2$ 的星球是特殊星球。起始传送器是 $(0,1)$ 和 $(1,2)$。\n\n假设评测程序执行下述调用：\n\n- (0) `add_teleporter(3, 4)`：应该返回 $0$。\n- (1) `add_teleporter(5, 0)`：应该返回 $0$。\n- (2) `add_teleporter(4, 5)`：应该返回 $0$。\n- (3) `add_teleporter(5, 3)`：应该返回 $0$。\n- (4) `add_teleporter(1, 4)`：在这种情况下，是可能获得无穷多枚邮票的。例如，游客可以从星球 $0$ 出发，按照 $1, 4, 5, 0, 1, 4, 5, 0,\\dots$ 这个顺序进行。因此，函数需要返回 $1$，进一步你的程序会被终止。\n\n下图对于这个例子进行了说明。特殊星球和起始传送器都使用粗体字表示。通过 `add_teleporter` 加入的传送器，按照顺序被标记为 $0$ 到 $4$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q80oy4px.png)\n\n### 例 $2$\n\n考虑下面的函数调用：\n\n```cpp\ninit(4, 2)\n```\n\n在这个例子里，有 $4$ 个星球和 $2$ 个特殊星球。标号为 $0$ 和 $1$ 星球是特殊星球。起始传送器是 $(0, 1)$。\n\n假设评测程序执行下述调用：\n\n- `add_teleporter(1, 1)`：当加入传送器 $(1, 1)$ 后，我们就能够获得无穷多枚邮票。例如，游客从星球 $1$ 出发，可以使用传送器 $(1, 1)$ 到达星球 $1$ 无限次。因此，函数需要返回 $1$，然后你的程序被终止。\n\n附件包里还包含了另一个样例输入输出。\n\n## 约束条件\n\n- $1\\le n\\le 3\\times 10^5$；\n- $1\\le m\\le 5\\times 10^5$；\n- $1\\le k\\le n$。\n\n对于每次调用 `add_teleporter` 函数：\n\n- $0\\le u\\le n-1$ 和 $0\\le v\\le n-1$；\n- 在传送器 $(u,v)$ 加入之前，不会有从星球 $u$ 到星球 $v$ 的传送器。\n\n## 子任务\n\n1. （$2$ 分）$n=k$，$n\\le 100$，$m\\le 300$；\n2. （$10$ 分）$n\\le 100$，$m\\le 300$。\n3. （$18$ 分）$n\\le 10^3$，$m\\le 5\\times 10^3$。\n4. （$30$ 分）$n\\le 3\\times 10^4$，$m\\le 5\\times 10^4$，$k\\le 10^3$。\n5. （$40$ 分）没有额外的约束条件。", "locale": "zh-CN"}}}
{"pid": "P8376", "type": "P", "difficulty": 6, "samples": [["2\n3\n8", "2\n1 0\n3\n0 1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2022", "APIO", "交互题", "Special Judge", "O2优化"], "title": "[APIO2022] 排列", "background": "本题只支持 C++ 提交，提交时不需要包含 `perm.h` 头文件，只需要将附件中的 `perm.h` 中的内容粘贴到代码的开头即可。", "description": "法老们利用行星的引力来加速飞船。假设飞船将依次以 $p[0], p[1],\\dots , p[n - 1]$ 的轨道速度飞掠 $n$ 颗行星。飞掠每颗行星时，法老科学家可以选择是否利用它来加速飞船。为了节省能量，当飞船以轨道速度 $p[i]$ 飞掠一颗行星并完成加速后，它将不能再在以轨道速度 $p[j] < p[i]$ 飞掠行星时进行加速。也就是说，选择用来加速的行星构成 $p[0], p[1],\\dots , p[n - 1]$ 的一个**递增子序列**。$p$ 的子序列是从 $p$ 中删除零个或多个元素得到的序列。例如，$[0]$、$[ ]$、$[0, 2]$ 和 $[0, 1, 2]$ 是 $[0, 1, 2]$ 的子序列，但 $[2, 1]$ 不是。\n\n科学家已经确认，总共有 $k$ 种方案来选择行星对飞船进行加速，但是他们弄丢了轨道速度的记录信息（甚至包括 $n$ 的大小）。不过他们记得 $(p[0], p[1],\\dots , p[n - 1])$ 是 $0, 1,\\dots , n - 1$ 的一个排列。这里的排列是包含从 $0$ 到 $n - 1$ 每个整数恰好一次的序列。 你的任务是找出一个长度尽量小且符合要求的排列 $(p[0], p[1],\\dots , p[n - 1])$。\n\n你要对 $q$ 艘不同的飞船来解决该问题。对每艘飞船 $i$，你会得到一个整数 $k_i$，表示选择行星加速飞船的不同方案数。你的任务是找出长度 $n$ 足够小的轨道速度序列，使得从中恰好可以选出 $k_i$ 个轨道速度递增的行星子序列。\n\n## 实现细节\n\n你要实现以下函数：\n\n```cpp\nint[] construct_permutation(int64 k)\n```\n\n- $k$ 是应有的递增子序列的数量。\n- 该函数要返回有 $n$ 个元素的数组，每个元素是 $0$ 到 $n - 1$ 之间（包括 $0$ 和 $n - 1$）的数。\n- 返回的数组必须是恰好有 $k$ 个递增子序列的合法排列。\n- 该函数总共被调用 $q$ 次。每次调用被视为一个独立的场景。", "inputFormat": "评测程序示例按以下格式读取输入：\n\n- 第 $1$ 行：$q$。\n- 第 $2+i$ 行（$0\\le i\\le q-1$）：$k_i$。", "outputFormat": "评测示例程序对每个 $k_i$ 打印一行，包含对应 `construct_permutation` 调用的返回值。如果出错则打印错误信息。", "hint": "## 例子\n\n### 例 $1$\n\n考虑以下调用：\n\n```cpp\nconstruct_permutation(3)\n```\n\n该函数应该返回一个恰好有 $3$ 个递增子序列的排列。一种可能的答案是 $[1,0]$，它的递增子序列有 $[]$（空的子序列）、$[0]$ 和 $[1]$。\n\n### 例 $2$\n\n考虑以下调用：\n\n```cpp\nconstruct_permutation(8)\n```\n\n该函数应该返回一个恰好有 $8$ 个递增子序列的排列。一种可能的答案是 $[0,1,2]$。\n\n## 约束条件\n\n- $1\\le q\\le 100$。\n- $2\\le k_i\\le 10^{18}$（对所有 $0\\le i\\le q-1$）。\n\n## 子任务\n\n1. （$10$ 分）$2\\le k_i\\le 90$（对所有 $0\\le i\\le q-1$）。如果你给出的所有排列长度至多为 $90$ 且结果正确，你将获得 $10$ 分，否则获得 $0$ 分。\n2. （$90$ 分）没有额外的约束条件。对该子任务，令 $m$ 为你在所有场景中给出的排列的最大长度，则你的得分按下表来计算：\n\n|条件|得分|\n|:-:|:-:|\n|$m\\le 90$|$90$|\n|$90 < m\\le 120$|$90-\\dfrac{m-90}{3}$|\n|$120 < m\\le 5000$|$80-\\dfrac{m-120}{65}$|\n|$m > 5000$|$0$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[APIO2022] 排列", "background": "本题只支持 C++ 提交，提交时不需要包含 `perm.h` 头文件，只需要将附件中的 `perm.h` 中的内容粘贴到代码的开头即可。", "description": "法老们利用行星的引力来加速飞船。假设飞船将依次以 $p[0], p[1],\\dots , p[n - 1]$ 的轨道速度飞掠 $n$ 颗行星。飞掠每颗行星时，法老科学家可以选择是否利用它来加速飞船。为了节省能量，当飞船以轨道速度 $p[i]$ 飞掠一颗行星并完成加速后，它将不能再在以轨道速度 $p[j] < p[i]$ 飞掠行星时进行加速。也就是说，选择用来加速的行星构成 $p[0], p[1],\\dots , p[n - 1]$ 的一个**递增子序列**。$p$ 的子序列是从 $p$ 中删除零个或多个元素得到的序列。例如，$[0]$、$[ ]$、$[0, 2]$ 和 $[0, 1, 2]$ 是 $[0, 1, 2]$ 的子序列，但 $[2, 1]$ 不是。\n\n科学家已经确认，总共有 $k$ 种方案来选择行星对飞船进行加速，但是他们弄丢了轨道速度的记录信息（甚至包括 $n$ 的大小）。不过他们记得 $(p[0], p[1],\\dots , p[n - 1])$ 是 $0, 1,\\dots , n - 1$ 的一个排列。这里的排列是包含从 $0$ 到 $n - 1$ 每个整数恰好一次的序列。 你的任务是找出一个长度尽量小且符合要求的排列 $(p[0], p[1],\\dots , p[n - 1])$。\n\n你要对 $q$ 艘不同的飞船来解决该问题。对每艘飞船 $i$，你会得到一个整数 $k_i$，表示选择行星加速飞船的不同方案数。你的任务是找出长度 $n$ 足够小的轨道速度序列，使得从中恰好可以选出 $k_i$ 个轨道速度递增的行星子序列。\n\n## 实现细节\n\n你要实现以下函数：\n\n```cpp\nint[] construct_permutation(int64 k)\n```\n\n- $k$ 是应有的递增子序列的数量。\n- 该函数要返回有 $n$ 个元素的数组，每个元素是 $0$ 到 $n - 1$ 之间（包括 $0$ 和 $n - 1$）的数。\n- 返回的数组必须是恰好有 $k$ 个递增子序列的合法排列。\n- 该函数总共被调用 $q$ 次。每次调用被视为一个独立的场景。", "inputFormat": "评测程序示例按以下格式读取输入：\n\n- 第 $1$ 行：$q$。\n- 第 $2+i$ 行（$0\\le i\\le q-1$）：$k_i$。", "outputFormat": "评测示例程序对每个 $k_i$ 打印一行，包含对应 `construct_permutation` 调用的返回值。如果出错则打印错误信息。", "hint": "## 例子\n\n### 例 $1$\n\n考虑以下调用：\n\n```cpp\nconstruct_permutation(3)\n```\n\n该函数应该返回一个恰好有 $3$ 个递增子序列的排列。一种可能的答案是 $[1,0]$，它的递增子序列有 $[]$（空的子序列）、$[0]$ 和 $[1]$。\n\n### 例 $2$\n\n考虑以下调用：\n\n```cpp\nconstruct_permutation(8)\n```\n\n该函数应该返回一个恰好有 $8$ 个递增子序列的排列。一种可能的答案是 $[0,1,2]$。\n\n## 约束条件\n\n- $1\\le q\\le 100$。\n- $2\\le k_i\\le 10^{18}$（对所有 $0\\le i\\le q-1$）。\n\n## 子任务\n\n1. （$10$ 分）$2\\le k_i\\le 90$（对所有 $0\\le i\\le q-1$）。如果你给出的所有排列长度至多为 $90$ 且结果正确，你将获得 $10$ 分，否则获得 $0$ 分。\n2. （$90$ 分）没有额外的约束条件。对该子任务，令 $m$ 为你在所有场景中给出的排列的最大长度，则你的得分按下表来计算：\n\n|条件|得分|\n|:-:|:-:|\n|$m\\le 90$|$90$|\n|$90 < m\\le 120$|$90-\\dfrac{m-90}{3}$|\n|$120 < m\\le 5000$|$80-\\dfrac{m-120}{65}$|\n|$m > 5000$|$0$|", "locale": "zh-CN"}}}
